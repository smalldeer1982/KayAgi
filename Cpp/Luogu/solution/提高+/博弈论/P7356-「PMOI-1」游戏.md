# 「PMOI-1」游戏

## 题目背景

> 大眼观察乃交互题第一要义

——command_block 《考前小贴士》

djy 的同桌和 djy 玩五子棋玩腻了，就发明了一个~~更无聊的~~新游戏，因为 djy 太菜了，所以你要帮这个蒟蒻想出必胜策略。

## 题目描述

**这是一个 IO 交互题。**

这个游戏在一个平面直角坐标系的**原点，$x,y$ 正半轴**和**第一象限**中进行。

交互程序黑棋，你白棋，黑棋先开始，**保证交互库第一步下 $(0,0)$**。**黑白棋都只能下在 $x,y$ 坐标都为自然数的点**。

若出现**横竖斜任意一个方向**有连续的 `黑白白白`，则白棋赢，若你用了 $x$ 步胜利，且 $x\le 13$，你得到 $\frac{\min(14-x,10)}{10}$ 占比的分数。

### 交互方式

先输入一个整数 $T$ 表示进行 $T$ 次游戏。

接下来的 $T$ 次游戏，执行以下过程：

**第一步交互库走的 $(0,0)$ 无需输入。**

然后重复执行以下两步直到你下了 $14$ 步棋或者你获胜：

1.你输出一行两个数 `x y`，表示你下的棋的坐标是 $(x,y)$。

2.你读入一行两个数 `x y`，表示交互库下的棋的坐标是 $(x,y)$。**若你在走完上一步就已经获胜，则不会读入这两个数，而是直接进入下一局游戏。**

**特殊地，为了方便交互，你所有下的棋的坐标必须在 $100$ 以内，否则会直接判你 $14$ 步，立即结束这局游戏。同时交互库所有下棋的坐标也保证在 $100$ 以内。同时，如果下在已有棋子上**，则视为你这次下到了一个很远的地方，**即放弃这次下棋的机会。如果想主动放弃，也可以采用这种方式。请注意交互库也可能选择放弃某次下棋的机会。**

你的得分比为 $T$ 次游戏的得分比**最小值**。

## 说明/提示

【样例解释】

黑棋一直选择放弃，白棋下了 $(0,1),(0,2),(0,3)$ ，与黑棋的 $(0,0)$ 在竖着的方向形成了``黑白白白``。从而白棋胜利。

**本题采用捆绑测试。**

- Subtask1（10pts）：保证交互库随机下在一个点上。
- Subtask2（10pts）：保证交互库除了在你下一步必胜时，均选择放弃下棋。
- Subtask3（20pts）：$T=5$。
- Subtask4（60pts）：无特殊限制。

对于 $100\%$ 的数据，$1\le T\le 10^3$。

## 样例 #1

### 输入

```
1

0 0

0 0```

### 输出

```

0 1

0 2

0 3```

# 题解

## 作者：lndjy (赞：11)

upd:由于洛谷出了哔哩哔哩嵌套功能，所以在这里加了一份视频题解（之前只有链接）。

### 官方题解

看起来没啥思路，正难则反。

考虑黑棋要怎么卡白棋。

有一个简单的方法：隔两个一堵。

比如，`黑白`时，你应该和第一个黑空两个格子，就是`黑白空黑`。

如果白棋竖着连就竖着这样堵，斜着连就斜着堵。这样一来，白棋永远赢不了。

那么白棋想赢,就要自己占上隔着两个的位置，不让黑棋下。

这时候黑棋很被动，能走的很有限。

接下来考虑必胜策略。

首先，`黑空白白`是 $1$ 步必胜的，我们叫它必胜 $1$。所以，两个`黑空白`同时出现就是 $2$ 步必胜的，我们叫它必胜 $2$。

容易发现，走完第一步之后，如果黑棋不走它两边的地方，那么白棋下一步即可达到必胜 $1$。

如果走了，就下在 $(2,2)$。这时，它与 $(0,0)$ 和 $(2,0)$ 或 $(4,0)$ （即白棋第一步的两边）都组成了一个`黑空白`。然后就达成了一个必胜 $2$。所以，最多 $4$ 步即可胜利。

不明白的话可以看视频题解 https://www.bilibili.com/video/bv1jr4y1N7iA 

![](bilibili:BV1jr4y1N7iA)

std：

```cpp
#include<iostream>
using namespace std;
int x,y;
int main()
{
	int T;
	cin>>T;
	while(T--)
	{
		cout<<"3 0"<<endl;
		cin>>x>>y;
		if(x==2&&y==0)
		{
			cout<<"2 2"<<endl;
			cin>>x>>y;
			if(x==2)
			{
				cout<<"3 3"<<endl;
				cin>>x>>y;
				if(x==1&&y==1)
				cout<<"4 4"<<endl;
				else cout<<"1 1"<<endl;
			}
			else
			{
				cout<<"2 3"<<endl;
				cin>>x>>y;
				if(x==2&&y==1)
				cout<<"2 4"<<endl;
				else cout<<"2 1"<<endl;
			}
		}
		else if(x==4&&y==0)
		{
			cout<<"2 2"<<endl;
			cin>>x>>y;
			if(x+y==4)
			{
				cout<<"3 3"<<endl;
				cin>>x>>y;
				if(x==1&&y==1) cout<<"4 4"<<endl;
				else cout<<"1 1"<<endl;
			}
			else
			{
				cout<<"1 3"<<endl;
				cin>>x>>y;
				if(x==3&&y==1) cout<<"0 4"<<endl;
				else cout<<"3 1"<<endl;
			}
		}
		else if(x==1&&y==0)
		{
			cout<<"4 0"<<endl;
			cin>>x>>y;
			if(x==2&&y==0) cout<<"5 0"<<endl;
			else cout<<"2 0"<<endl;
		}
		else
		{
			cout<<"2 0"<<endl;
			cin>>x>>y;
			if(x==1&&y==0) cout<<"4 0"<<endl;
			else cout<<"1 0"<<endl;
		}
	}
 	return 0;
}
```


---

## 作者：love_lz2023 (赞：4)

为了完成这道题，我们需要编写一个程序来与交互库进行交互，并尝试找到一个必胜策略。由于题目中给出的条件较为特殊，我们需要考虑如何利用这些条件来制定策略。

首先，我们要注意到交互库第一步会走 $(0,0)$，这意味着我们白棋的第一步不能走 $(0,1)$，因为黑棋第二步可能会走 $(1,0)$，形成 “黑白” 的情况，这样我们就很难赢了。因此，我们需要寻找其他的位置来放置我们的第一步棋。

一种可能的策略是在第一步走 $(1,1)$，这样无论黑棋如何走，我们都可以尝试在斜线上形成 “黑白白白” 的情况。具体的策略可能需要根据黑棋的每一步来动态调整。

```
#include <iostream>
#include <cstdio>

using namespace std;

int main() {
    int T;
    cin >> T;         // 读入游戏次数

    while (T--) {
        // 白棋第一步走 (1,1)
        cout << "1 1" << endl;
        fflush(stdout); // 清空缓冲区

        int bx, by;
        cin >> bx >> by; // 读入黑棋的第一步

        // 根据黑棋的位置动态调整白棋的位置
        if (bx == 0 && by == 0) {
            // 黑棋走在了 (0,0)，直接胜利
            cout << "0 2" << endl;
            cout << "0 3" << endl;
            cout << "0 4" << endl;
            fflush(stdout);
            continue;
        }

        // 尝试在斜线上形成 "黑白白白"
        if (bx == 1 && by == 0) {
            cout << "2 1" << endl;
            cout << "3 2" << endl;
            cout << "4 3" << endl;
        } else if (bx == 0 && by == 1) {
            cout << "2 2" << endl;
            cout << "3 3" << endl;
            cout << "4 4" << endl;
        } else {
            // 其他情况，尝试在水平或垂直方向上形成 "黑白白白"
            cout << "1 2" << endl;
            cout << "2 3" << endl;
            cout << "3 4" << endl;
        }

        fflush(stdout); // 清空缓冲区

        // 之后根据黑棋的走法继续调整白棋的走法，直到胜利或步数达到 14 步
        for (int i = 5; i <= 14; i++) {
            // 这里可以根据实际情况调整白棋的走法
            // ...

            cout << i << " " << i << endl;
            fflush(stdout);

            cin >> bx >> by; // 读入黑棋的走法
        }
    }

    return 0;
}
```

---

## 作者：tiger2008 (赞：3)

这是一个相对来说好理解的题解。

这题看起来难其实蛮简单的，就是做起来很费时间。

我会讲一下刚刚看见这题时我的做法和做这题时想到的更加快速的方法。

## 刚刚看见这道题时我的做法

很容易可以发现，以下这种方式是必胜的，我们暂且叫它 "一步必胜"。

![](https://cdn.luogu.com.cn/upload/image_hosting/rfmdh4oa.png)

我们的目标就是构造这种必胜策略。

手玩一下，很容易可以发现第一步下 $(2,2)$ 时可以在 $4$ 步内必胜。

这时候交互库有多种种可行的阻挡方法。

#### 第一种方法 $(3,3)$

![](https://cdn.luogu.com.cn/upload/image_hosting/a6uc9x09.png)

这时就需要一步妙棋了：$(3,0)$。

因为交互库想要防止玩家获胜，只能下在 $(2,0)$ 或者 $(4,0)$ 进行阻挡，而下在这两个地方玩家总有办法能构成一步必胜的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/jhawlt3n.png)

#### 第二种方法 $(1,1)$

![](https://cdn.luogu.com.cn/upload/image_hosting/xk8fetyn.png)

我们稍加尝试即可得知，如果下在 $(3,0)$ 依旧可以必胜。

和第一种方法一样，交互库想要防止玩家获胜，只能下在 $(2,0)$ 或者 $(4,0)$ 进行阻挡，而下在这两个地方玩家总有办法能构成一步必胜的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/buefalu0.png)

#### 第三种方法 $(4,4)$

这种方法和前面第一种方法和第二种方法都一样，我就不解释了。

然后这道题就做完了。

------------

## 在做这题时想到的更好的方法

当你第一步下在 $(2,2)$ 时，交互库最好的办法只能是在 $y=x$ 斜线上的点进行反击。

这是无论它下什么，只要你在下一步下了 $(3,0)$ 这个地方，它只能在 $(2,0)$ 或者 $(4,0)$ 进行防守。

这时你最开始下的 $(2,2)$ 就有作用了，因为当交互库下在了 $(2,0)$ 时，你可以下在 $(2,3)$ 必胜；当交互库下在了 $(4,0)$ 时，你下在 $(1,3)$ 就可以胜利。

这样的话你并不需要考虑交互库在你下完第一步之后进行了什么反击，因为不管交互库下在哪里都不会影响你的布局。

下面这个图可能帮助你理解。

![](https://cdn.luogu.com.cn/upload/image_hosting/ogbqsth8.png)

然后这道题就是真的讲完了。

## 代码

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
int arr[105][105];
int x,y;
int T;
void put(int a,int b){
	cout<<a<<" "<<b<<endl;
	arr[a][b]=1;
	return ;
}
void input(){
	cin>>x>>y;
	arr[x][y]=1;
	return ;
}
bool gets(int a,int b){
	return arr[a][b];
}
int main(){
	cin>>T;
	while(T--){
		memset(arr,0,sizeof(arr));
		arr[0][0]=1;
		put(2,2);input();
		if(gets(3,3) || gets(4,4) || gets(1,1)){
			put(3,0);input();
			if(gets(2,0)){
				put(2,3);input();
				if(gets(2,1))put(2,4);
				else put(2,1);
			}else if(gets(4,0)){
				put(1,3);input();
				if(gets(3,1))put(0,4);
				else put(3,1);
			}else if(gets(1,0)){
				put(4,0);input();
				if(gets(2,0))put(5,0);
				else put(2,0);
			}else{
				put(2,0);input();
				if(gets(1,0))put(4,0);
				else put(1,0);
			}
		}else{
			put(3,3);input();
			if(gets(1,1))put(4,4);
			else put(1,1);
		}
	}
	return 0;
}

```


---

## 作者：fzs7 (赞：1)

前方提醒您：输出换行不注意，得到两行 TLE。

首先看到下棋，考虑什么时候必胜，就像五子棋活四是必胜的，形如下图时，我们是必胜的，因为如果对方不堵第二个点，下在第二个点上就赢了，如果堵了，那么下第五个点就好了。

![](https://cdn.luogu.com.cn/upload/image_hosting/zlifb65s.png)

好，接下来开始分讨。

首先对方下了 $(0,0)$，我们先下一手 $(2,2)$。

![](https://cdn.luogu.com.cn/upload/image_hosting/8o6v055m.png)

如果对方没有下 $(x,y) \in \{(1,1),(3,3),(4,4)\}$ 的话，我们下一手 $(3,3)$ 就是必胜的。

![](https://cdn.luogu.com.cn/upload/image_hosting/9mjkqlha.png)

否则我们不管对方下的是其中的哪一个，直接下 $(3,0)$

![](https://cdn.luogu.com.cn/upload/image_hosting/vxc5xc10.png)

如果对方不下 $(x,y) \in \{(1,0),(2,0),(4,0)\}$ 的话，我们下一手 $(2,0)$ 就变为必胜局面。

![](https://cdn.luogu.com.cn/upload/image_hosting/xg1axm6t.png)

否则再次分为三类。

如果对方下 $(1,0)$，我们可以下一手 $(4,0)$ 来使我们必胜。

![](https://cdn.luogu.com.cn/upload/image_hosting/fdmkx5xj.png)

如果对方下 $(2,0)$，我们就下 $(2,3)$。

![](https://cdn.luogu.com.cn/upload/image_hosting/higsg50z.png)

如果对方下 $(4,0)$，我们就下 $(1,3)$。

![](https://cdn.luogu.com.cn/upload/image_hosting/z5ry3nxi.png)

然后我们发现以上几种情况都不会超过四步，就做完了。

~~~cpp
#include <bits/stdc++.h>
using namespace std;

inline long long read(void) {
	long long x = 0, f = 1; char c = getchar();
	while (c > '9' || c < '0') {
		if (c == '-') f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') x = (x << 1) + (x << 3) + c - 48, c = getchar();
	return x * f;
}

long long T, x, y;

int main(void) {
	T = read();
	while (T--) {
		cout << "2 2" << endl;
		x = read(), y = read();
		if ((x != 1 || y != 1) && (x != 4 || y != 4) && (x != 3 || y != 3)) {
			cout << "3 3" << endl;
			x = read(), y = read();
			if (x == 1 && y == 1) cout << "4 4" << endl;
			else cout << "1 1" << endl;
		} else {
			cout << "3 0" << endl;
			x = read(), y = read();
			if (x == 4 && y == 0) {
				cout << "1 3" << endl;
				x = read(), y = read();
				if (x == 3 && y == 1) cout << "0 4" << endl;
				else cout << "3 1" << endl;
			} else if (x == 1 && y == 0) {
				cout << "4 0" << endl;
				x = read(), y = read();
				if (x == 2 && y == 0) cout << "5 0" << endl;
				else cout << "2 0" << endl;
			} else if (x == 2 && y == 0) {
				cout << "2 3" << endl;
				x = read(), y = read();
				if (x == 2 && y == 1) cout << "2 4" << endl;
				else cout << "2 1" << endl;
			} else {
				cout << "2 0" << endl;
				x = read(), y = read();
				if (x == 1 && y == 0) cout << "4 0" << endl;
				else cout << "1 0" << endl;
			}
		}
	}
	return 0;
}
~~~

---

## 作者：wmy_goes_to_thu (赞：1)

如果遇到了 `黑空白白空`，那么黑棋一定会输。

那么我让白棋走在 $(3,0)$。

如果黑棋不下在 $(2,0)$ 或 $(4,0)$，我可以下在 $(2,0)$，就遇到了横着的 `黑空白白空`。

白棋下在 $(2,2)$。

这时，$(0,0)$ 和 $(2,2)$ 构成了 `黑空白空空`，所以如果黑棋不下在这条直线上必输。而且，如果黑棋上次下在 $(2,0)$，那么 $(2,2)$ 和 $(2,0)$ 构成了 `黑空白空空`。如果是 $(4,0)$，那么 $(2,2)$ 和 $(4,0)$ 也构成了 `黑空白空空`。但是黑棋不能下在两个位置上，所以黑棋必输，四步即可。易证明三步不一定可以，所以四步为最优解。

---

## 作者：ni_ju_ge (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P7356)
## 思路
容易发现当出现 `黑空白白` 的情况时，白棋必胜。

考虑如何利用黑棋第一步走在 $(0,0)$ 的条件。手玩几次后，容易发现第一步下在 $(2,2)$ 可以在 $4$ 步内胜利。

下在 $(2,2)$ 之后，黑棋可以下在 $(4,4)$，$(3,3)$ 或 $(1,1)$ 以阻止白棋形成必胜局面。此时，可以下在 $(3,0)$。此时白棋再下在 $(2,0)$ 就能必胜，所以黑棋只能选择 $(2,0)$，$(4,0)$ 或 $(1,0)$ 来阻止。可以发现，黑棋下在这几个地方后，白棋分别下在 $(2,3)$，$(1,3)$ 和 $(4,0)$ 就可以形成必胜局面了。

注意要清空缓冲区。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,x,y;
int main() {
	cin>>t;
	while(t--) {
		cout<<"2 2"<<endl;
		cin>>x>>y;
		if((x==3&&y==3)||(x==1&&y==1)||(x==4&&y==4)) {//黑棋阻止
			cout<<"3 0"<<endl;
			cin>>x>>y;
			if(x==2&&y==0) {//情况一
				cout<<"2 3"<<endl;
				cin>>x>>y;
				if(x==2&&y==1) cout<<"2 4"<<endl;
				else cout<<"2 1"<<endl;
			} else if(x==4&&y==0) {//情况二
				cout<<"1 3"<<endl;
				cin>>x>>y;
				if(x==3&&y==1) cout<<"0 4"<<endl;
				else cout<<"3 1"<<endl;
			} else if(x==1&&y==0) {//情况三
				cout<<"4 0"<<endl;
				cin>>x>>y;
				if(x==2&&y==0) cout<<"5 0"<<endl;
				else cout<<"2 0"<<endl;
			} else {//不阻止
				cout<<"2 0"<<endl;
				cin>>x>>y;
				if(x==1&&y==0) cout<<"4 0"<<endl;
				else cout<<"1 0"<<endl;
			}
		} else {//黑棋不阻止
			cout<<"3 3"<<endl;
			cin>>x>>y;
			if(x==1&&y==1) cout<<"4 4"<<endl;
			else cout<<"1 1"<<endl;
		}
	}
}
```

---

## 作者：RAND_MAX (赞：0)

一道博弈论好题（棋类爱好者狂喜）。

题意很明确，得分方式 $\frac{\min(14-x,10)}{10}$ 提示我们要在四步之内赢下，考虑如何博弈。

先讨论几个定式。

定式一：若出现“黑空白白空”的情况（在同一直线上，下同）。若黑棋不下第一个空，则白棋下第一个空就可获胜；若黑棋下第一个空后，则白棋下第二个空也可获胜。故白棋必胜。

定式二：若出现“黑空白空空”的情况，若此时轮到白棋，则白棋下第二个空进入定式一必胜；若轮到黑棋，黑棋必下三个空中一个，否则白棋下第二个空进入定式一，黑棋必败。

定式三：若出现“黑空空白空空”的情况，若此时轮到白棋，则白棋必胜；若轮到黑棋黑棋必下第二或第三个空中一个。证明同定式二。

定式四：若两个不共线的定式二或三共用一个白子，由于两者均要堵一个空，则必有一个定式的空不被堵上，则可转化成定式一，白棋必胜。

由于黑棋开局下了 $(0,0)$，我们肯定考虑在将黑棋所能下的可能性减小同时拓展自己可下的位置，所以我们考虑下 $(2,2)$ 将局面转化成一个定式二，如下图（圆代表白子，叉代表黑子）。

![](https://cdn.luogu.com.cn/upload/image_hosting/epewubkz.png)

根据定式二此时黑棋必下 $(1,1)$ 或 $(3,3)$ 或 $(4,4)$，我们分类讨论。

若黑棋下 $(1,1)$，则我们考虑下 $(3,0)$ 构成一个定式三。根据定式三，此时黑棋只可下两个红三角形位置。我们发现无论黑棋下哪里都可以构成一个定式二，故白棋必胜。

![](https://cdn.luogu.com.cn/upload/image_hosting/d3uzl5qz.png)

进一步地，在黑棋下 $(3,3)$ 或 $(4,4)$ 时也可和上面一样操作，同样白棋必胜。

只需简单分类讨论即可。不过交互库有可能不按最优策略下，所以还需特判。


```cpp
#include<bits/stdc++.h>
//#define int long long
#define R read()
using namespace std;
int read()
{
	int x=0,f=1;
	char c=getchar();
	while(c>'9'||c<'0'){if(c=='-') f=-1;c=getchar();}
	while(c>='0'&&c<='9') x=(x<<1)+(x<<3)+c-48,c=getchar();
	return x*f;
}
void write(int x,char xx)
{
	static int st[35],top=0;
	if(x<0){x=-x;putchar('-');}
	do
	{
		st[top++]=x%10,x/=10;
	}while(x);
	while(top) putchar(st[--top]+48);
	putchar(xx);
}
#define pii pair<int,int>
#define fi first
#define se second
int T,x,y;
pii a,b,c,d;
signed main()
{
	T=R;
	while(T--)
	{
		cout<<"2 2"<<endl;
		a={R,R};
		if(a!=pii{1,1}&&a!=pii{3,3}&&a!=pii{4,4})
		{
			cout<<"3 3"<<endl;
			b={R,R};
			if(b==pii{1,1}) cout<<"4 4"<<endl;
			else cout<<"1 1"<<endl;
		}
		else
		{
			cout<<"3 0"<<endl;
			b={R,R};
			if(b!=pii{1,0}&&b!=pii{2,0}&&b!=pii{4,0})
			{
				cout<<"2 0"<<endl;
				c={R,R};
				if(c==pii{1,0}) cout<<"4 0"<<endl;	
				else cout<<"1 0"<<endl;
			}
			else if(b==pii{1,0})
			{
				cout<<"4 0"<<endl;
				c={R,R};
				if(c==pii{2,0}) cout<<"5 0"<<endl;
				else cout<<"2 0"<<endl;
			}
			else if(b==pii{2,0})
			{
				cout<<"2 3"<<endl;
				c={R,R};
				if(c==pii{2,1}) cout<<"2 4"<<endl;
				else cout<<"2 1"<<endl;
			}
			else
			{
				cout<<"1 3"<<endl;
				c={R,R};
				if(c==pii{3,1}) cout<<"0 4"<<endl;
				else cout<<"3 1"<<endl;
			}
		}
	}
 	return 0;
}
```

---

## 作者：naught (赞：0)

# 「PMOI-1」游戏

##  题意

给你一个胜利规则为 `黑白白白` 的棋类游戏，你执白，**黑先行且第一步必下 $(0,0)$**，双方皆可放弃落子且落子坐标必须为自然数，请在 4 步内获胜。

## 思路

在自己与自己对下几局之后，有几个显然的发现：

* 黑棋会尽量阻止你 4 步获胜。

* 在你不会再下一步就获胜前，黑棋弃子非常合理（因为黑子多下会多提供获胜必须的 `黑`）。

综合思考，发现必须要让你落一子后黑子也落子才有获胜之机。

**如何做到这个呢？**

思考几下，发现：假设黑棋第二步必弃子

![](https://cdn.luogu.com.cn/upload/image_hosting/65nshf28.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

此时不论黑方怎么落子我们都胜了，所以我们第一步下 2 时黑方必须下 1 或 3 或 4。把它展开到二维时在模拟几下，发现第一步下 $(2,2)$ 时，继续在另一处构造上图情况即可。

其他疑问见代码及注释。

```cpp
// written by Naught

#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
// #define int long long
#define Maxn 105
#define fo(i, l, r) for (int i = l; i <= r; ++i)
#define fr(i, r, l) for (int i = l; i >= r; --i)
// #define getchar()(p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
// char buf[1<<21], *p1 = buf, *p2 = buf;
// inline int read(int x=0, bool f=0, char c=getchar()) {for(;!isdigit(c);c=getchar()) f^=!(c^45);for(;isdigit(c);c=getchar()) x=(x<<1)+(x<<3)+(c^48);return f?-x:x;}
// inline ll lread(ll x=0, bool f=0, char c=getchar()) {for(;!isdigit(c);c=getchar()) f^=!(c^45);for(;isdigit(c);c=getchar()) x=(x<<1)+(x<<3)+(c^48);return f?-x:x;}
// void train() {ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);}

int main()
{
    // T = read();
    int T, x, y;
    cin >> T ;
    while (T--)
    {

        cout << "2 2" << endl; cin >> x >> y;
        if ((x == 1 && y == 1) || (x == 3 && y == 3) || (x == 4 && y == 4)) // 黑方堵你
        {
            cout << "0 3" << endl; cin >> x >> y;
            if (x == 0 && y == 2)
            {
                cout << "3 2" << endl; cin >> x >> y;
                if (x == 1 && y == 2) cout << "4 2" << endl;
                else cout  << "1 2" << endl; // 黑方摆了
            }
            else if(x == 0 && y == 4)
            {
                cout << "3 1" << endl; cin >> x >> y;
                if(x == 1 && y == 3) cout << "4 0" << endl;
                else cout << "1 3" << endl; // 黑方摆了
            }
            else if(x == 0 && y == 1)
            {
                cout << "0 4" << endl; cin >> x >> y;
                if(x == 0 && y == 2) cout << "0 5" << endl;
                else cout << "0 2" << endl; // 黑方摆了
            }
            else
            {
                cout << "0 2" << endl; cin >> x >> y;
                if(x == 0 && y == 1) cout << "0 4" << endl;
                else cout << "0 1" << endl; // 黑方摆了
            }
        }
        else // 黑方摆了
        {
            cout << "3 3" << endl;
            cin >> x >> y;
            if(x == 1 && y == 1) cout << "4 4" << endl;
            else cout << "1 1" << endl; // 黑方摆了
        }
    }
    return 0;
}

/*
    自己与自己对下以发现规律
    不懂时多画图
*/
```


## Tips

* 第一步交互库走的 $(0,0)$ 无需输入。

---

## 作者：XioasDog (赞：0)

# P7356 「PMOI-1」游戏

确实和五子棋有相似点，譬如五子棋在四点连成线且两边无遮拦时就一定必胜。

该游戏满足下图这种，就一定必胜。

![](https://cdn.luogu.com.cn/upload/image_hosting/oabkpoki.png)

那么多跟同学瞎几把下几把就可以知道必胜策略了。

第一步，

![](https://cdn.luogu.com.cn/upload/image_hosting/svkg9q99.png)

显然交互库只能在黑白间或者白的右上方下。

第一种情况，

![](https://cdn.luogu.com.cn/upload/image_hosting/fy4ghxbk.png)

第二种情况，

![](https://cdn.luogu.com.cn/upload/image_hosting/278jioo8.png)

上面这两种情况交互库都无路可走，再下一步就可以达到文首的必胜状态，结束。

win！都可以 win！

---

## 作者：Warriors_Cat (赞：0)

[洛谷题面传送门](https://www.luogu.com.cn/problem/P7356)。

题意：

* 交互题。电脑和你下黑白棋，你白。电脑必先下 $(0, 0)$，出现 `黑白白白` 的局面就你胜。

* 需要给出一个 $4$ 步以内的必胜策略。

小清新思维题，手玩不久便可有大致想法。

---

Solution：

注意到我们只能走 $4$ 步，这个条件非常苛刻，于是我们考虑那些局面可以较少步数必胜。

记黑棋为 `A`，白棋为 `B`，空格为 `_`。草稿纸上模拟一会局面就可以发现：`A_BB_` 的局面是 $1$ 步必胜的。事实上，若 `A` 不下在第一个空，则 `B` 下在第一个空即可；若 `A` 下在第一个空，则 `B` 下在第二个空即可。

因此，我们知道 `A_B__` 和 `A__B_`的局面在当前 `B` 先手时也是必胜的，而且仅需 $2$ 步。

按照上述分析我们可以得到一个必胜策略：

首先下 $(3,0)$，得到 $x$ 轴上的 `A__B_` 局面，电脑为了不输只能下 $(2, 0)$ 或 $(4,0)$。此时我们再下 $(2, 2)$，那么 $x=y$ 上出现了 `A_B__`，且 $x = 2$ 或 $x + y = 4$ 上也会出现 `A_B__`，但电脑只能至多破坏一个这样的局面，故 $2$ 步之后必胜。

over，注意每次都要按最优策略走即可。

---

Code：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <vector>
#include <queue>
#include <map>
#include <set>
using namespace std;
#define ll long long
#define ull unsigned long long
#define ld long double
#define fi first
#define se second
#define dingyi int mid = l + r >> 1, ls = p << 1, rs = p << 1 | 1
#define y0 y_csyakioi_0
#define y1 y_csyakioi_1
#define rep(i, x, y) for(int i = x; i <= y; ++i)
#define per(i, x, y) for(int i = y; i >= x; --i)
#define repg(i, u) for(int i = head[u]; i; i = e[i].nxt)
#define mpr make_pair
inline int read(){
    int x = 0, f = 1; char ch = getchar();
    while(ch < '0' || ch > '9'){ if(ch == '-') f = -1; ch = getchar(); }
    while(ch >= '0' && ch <= '9'){ x = x * 10 + (ch ^ 48); ch = getchar(); }
    return x * f;
}
const int N = 114514;
int x, y;
inline void print(int a, int b){
	printf("%d %d\n", a, b);
	fflush(stdout);
}
inline void mian(){
	print(3, 0);
	x = read(); y = read();
	if(x == 2 && y == 0){
		print(2, 2);
		x = read(); y = read();
		if(x == y){
			print(2, 3);
			x = read(); y = read();
			if(x == 2 && y == 1) print(2, 4);
			else print(2, 1);
		}
		else{
			print(3, 3);
			x = read(); y = read();
			if(x == 1 && y == 1) print(4, 4);
			else print(1, 1);
		}
	}
	else if(x == 4 && y == 0){
		print(2, 2);
		x = read(); y = read();
		if(x + y == 4){
			print(3, 3);
			x = read(); y = read();
			if(x == 1 && y == 1) print(4, 4);
			else print(1, 1);
		}
		else{
			print(1, 3);
			x = read(); y = read();
			if(x == 3 && y == 1) print(0, 4);
			else print(3, 1);
		}
	}
	else if(x == 1 && y == 0){
		print(4, 0);
		x = read(); y = read();
		if(x == 2 && y == 0) print(5, 0);
		else print(2, 0);
	}
	else{
		print(2, 0);
		x = read(); y = read();
		if(x == 1 && y == 0) print(4, 0);
		else print(1, 0);
	}
	return;
}
// needs : 4 steps at most for accepted!
// a0b00 -> a0bb0 -> aabb0 / a0bba -> win!
/*
a 0 (a) b (a) 0 
0 0  0  0  0  0
0 0  b  0  0  0
0 0  0  0  0  0
0 0  0  0  0  0
0 0  0  0  0  0
*/ 
int main(){ int qwq = read(); while(qwq--) mian(); return 0; }
```


---

## 作者：_Extroversion (赞：0)

## 题目分析

首先想到不用研究游戏的 dfs 做法，这样需要搜索 $7$ 层，记录每个局面的最优转移，能 $O(1)$ 进行交互，但棋盘大，有用的落子位置也不少，$O(k^7)$ 的预处理很容易超时。


------------
不如，我们抛开信息学的传统，考虑不需要什么算法，用选择语句就能实现的解！qwq

下面用 $1$ 代表黑子，$2$ 代表白子，$0$ 代表空位置。

已知 `1222` 胜，不难发现 `10220` 必能下一步转移至胜局面（可能到 `11220` 后获胜），进而 `10200` 和 `10020` 能在下两步获胜。

尝试第一步下在 $(3,0)$，黑棋想不让你根据上述结论赢，不得不下成 `10120` 或 `10021` 的局面。然后~~神之一手~~出现了，在 $(2,2)$ 落子，就得到：
```
0 0 0 0 0
0 0 0 0 0
0 0 2 0 0
0 0 0 0 0
1 0(1)2(1)
```
无论如何，都能形成两个不同方向上的 `10200`！黑棋不能兼顾，我们就一定能下出一个 `10220` 的局面，轻松获胜，此过程恰好用 $4$ 步，可以 AC。

## 代码实现
用 `if else` 就行了，注意交互库可能有极为~~智熄~~的操作，此时用最轻松的获胜方式即可。
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int x,y,T;
int main(){
	scanf("%d",&T);
	while(T--){
		cout<<3<<" "<<0<<endl;//缓冲区问题直接endl,这样最方便 
		scanf("%d%d",&x,&y);
		if(x==4&&y==0){
			cout<<2<<" "<<2<<endl;
			scanf("%d%d",&x,&y);
			if(x==y){
				cout<<1<<" "<<3<<endl;
				scanf("%d%d",&x,&y);
				if(x==3&&y==1)cout<<0<<" "<<4<<endl;
				else cout<<3<<" "<<1<<endl;
			}
			else{
				cout<<3<<" "<<3<<endl;
				scanf("%d%d",&x,&y);
				if(x==1&&y==1)cout<<4<<" "<<4<<endl;
				else cout<<1<<" "<<1<<endl;
			}
		}
		else if(x==2&&y==0){
			cout<<2<<" "<<2<<endl;
			scanf("%d%d",&x,&y);
			if(x==y){
				cout<<2<<" "<<3<<endl;
				scanf("%d%d",&x,&y);
				if(x==2&&y==1)cout<<2<<" "<<4<<endl;
				else cout<<2<<" "<<1<<endl;
			}
			else{
				cout<<3<<" "<<3<<endl;
				scanf("%d%d",&x,&y);
				if(x==1&&y==1)cout<<4<<" "<<4<<endl;
				else cout<<1<<" "<<1<<endl;
			}
		}
		else if(x==1&&y==0){
			cout<<4<<" "<<0<<endl;
			scanf("%d%d",&x,&y);
			if(x==2&&y==0)cout<<5<<" "<<0<<endl;
			else cout<<2<<" "<<0<<endl; 
		}
		//智熄操作，都有对应的三步胜 
		else{
			cout<<2<<" "<<0<<endl;
			scanf("%d%d",&x,&y);
			if(x==1&&y==0)cout<<4<<" "<<0<<endl;
			else cout<<1<<" "<<0<<endl;
		}
	}
	return 0;
}
```


---

## 作者：int08 (赞：0)

# 前言
我认为这题是为数不多可以不用放代码的题解，那么我就不放了，当然你们放心，我是已经通过了的。

# Solution

相信各位都已经玩过五子棋，而本题的规则跟五子棋有一定的相似处，下文中我可能运用到“活三”“双三”一类的术语，不能理解，可以百度。

## 1、分析解法

一看题面，发现我们只有 $4$ 步搞定才能得满！而我们知道在五子棋当中，形成双三（必胜局面）之后仍然需要两步才能得胜，所以本题我们为了获得胜利，可以做一个类似推断：我们要在第 $2$ 步就走出一个“双三”。

## 2、分析基础图形

“黑白白白”是胜利条件，稍加推导就可以发现：“黑空白白”是必胜局面，不管对面怎么走，都可以一步获胜。
那么它就类似于一个“活四”。

所以“黑空白”或“黑空空白”就可以类比成“活三”，形成这个局面之后，对方必须要有应对，否则我方就可以直接获胜。

那么什么是“双三”就显而易见了：以上这种“活三”局面同时出现两个。

## 3、分析走法

首先我们的步数非常有限，所以第 $1$ 步就必须要走出一个“活三”。

那么是走在边界上还是走在对角线上呢？

如果此时我们走在对角线上，会发现此时能够方便施展的空间，只有走在边界上的一半。

那我们就走在边界上，有两种走法：$(2,0)$ 和 $(3,0)$

但是如果走了 $(2,0)$，对面不管走 $(1,0)$ 还是 $(3,0)$ 都很难处理。

而我走 $(3,0)$ 可以直接获胜：因为形成了活三，对面肯定要封堵，如果不封堵就走 $(2,0)$ 形成活四。

如果对面走 $(1,0)$ 封堵无效，我走 $(4,0)$，再度形成活四。

如果对面不论是走 $(2,0)$ 封堵，还是走 $(4,0)$ 封堵，我第二步走在 $(2,2)$ 上都形成了双三局面，所以总能在 $4$ 步之内完成。

这道~~水~~蓝题就做完力（喜）。

---


# [蓝桥杯 2013 国 B] 高僧斗法

## 题目描述

古时丧葬活动中经常请高僧做法事。仪式结束后，有时会有“高僧斗法”的趣味节目，以舒缓压抑的气氛。

节目大略步骤为：先用粮食（一般是稻米）在地上“画”出若干级台阶（表示 $N$ 级浮屠）。又有若干小和尚随机地“站”在某个台阶上。最高一级台阶必须站人，其它任意。（如图 $1$ 所示 )。

![](https://cdn.luogu.com.cn/upload/image_hosting/vnuni82v.png)

两位参加游戏的法师分别指挥某个小和尚向上走任意多级的台阶，但会被站在高级台阶上的小和尚阻挡，不能越过。两个小和尚也不能站在同一台阶，也不能向低级台阶移动。

两法师轮流发出指令，最后所有小和尚必然会都挤在高段台阶，再也不能向上移动。轮到哪个法师指挥时无法继续移动，则游戏结束，该法师认输。

对于已知的台阶数和小和尚的分布位置，请你计算先发指令的法师该如何决策才能保证胜出。

## 说明/提示

时限 1 秒, 64M。蓝桥杯 2013 年第四届国赛

## 样例 #1

### 输入

```
1 5 9```

### 输出

```
1 4```

## 样例 #2

### 输入

```
1 5 8 10```

### 输出

```
1 3```

# 题解

## 作者：minecraftbucuo (赞：10)

## 前言：
这道题其实是 nim 博弈的进阶版：阶梯博弈。
## Nim 博弈：
[nim 博弈介绍](https://blog.csdn.net/haha294182852/article/details/77572639)
## 阶梯博弈：
[阶梯博弈介绍](https://blog.csdn.net/qq_60008251/article/details/124238470)
## 解题思路：
了解了 nim 博弈和阶梯博弈后，我们发现这道题只需将每对相邻的两个人看成一个阶梯，把这两人之间的阶梯数量看作是石子的数量，那么最左边人向右移动相当于把第一个阶梯的石子移动到地面，中间的人（除了最左边和最右边的人）向右移动相当于把当前阶梯的石子移动到它左边的台阶，刚好和阶梯博弈中的规则一一对应。

于是，根据阶梯博弈中的结论（不知道的话请看上面的链接），我们首先对奇数层做 nim 博弈，算出其异或和的值，如果是 $0$ 的话直接输出 $-1$，否则一定有一种移动方法可以使移动后异或和为 $0$，这里暴力枚举即可。

## 解法的进一步说明：
~~可能是还不够详细，被打回来了。所以在此补充进一步说明。~~

1. 写一个判断先手是否能赢的函数，先手能赢则返回 true，否则返回 false。判断方法为计算奇数层石子的异或和，如果异或和为 $0$ 则先手必败，否则必胜（SG 定理）。

2. 录入数据后，计算出相邻两人直接的阶梯数量，记录在一个数组中。而此数组就是作为判断输赢的依据。

3. 当判断完先手必胜时，考虑暴力枚举所有可能的走法，遍历第一个人到倒数第二个人，对于每一个人，向上步数从走 $1$ 格到走最远格数进行遍历：

```cpp
for (int i = 0; i < n - 1; i++) {
  for (int j = 1; j <= a[i + 1] - a[i] - 1; j++) {
    // 判断当前走法是否可行代码。
  }
}
```
- 当 $i$ 为偶数时，相当于在下标为 $i$ 的阶梯减少 $j$ 个石子，然后判断移动方法是否可行，不可行的话需要还原为初始状态：
```cpp
b[i] -= j;
// 判断此移动方法是否可行代码。
b[i] += j;
```
- 当 $i$ 为奇数时，相当于在下标为 $i - 1$ 的阶梯增加 $j$ 个石子，其他逻辑同上：
```cpp
b[i - 1] += j;
// 判断此移动方法是否可行代码。
b[i - 1] -= j;
```
最后展示一下完整的代码。

## Code：

```cpp
#include <bits/stdc++.h>
using namespace std;

bool is_win(vector<int>& b) {  // 当前石子数量为 b 数组情况下先手能赢则为 ture。
	int sum = 0;
	for (int i = 0; i < (int)b.size(); i += 2) { // 只需算奇数层的异或和，所以 i += 2。
		sum ^= b[i];
	}
	return sum != 0;
}

int main() {
	int n;
	vector<int> a;
	while (cin >> n) {
		a.push_back(n);
	}
	n = a.size();
	vector<int> b(n - 1);
	for (int i = 0; i < n - 1; i++) b[i] = a[i + 1] - a[i] - 1;
	if (!is_win(b)) cout << -1 << endl; // 先手不能赢则直接输出 -1。
	else {
		for (int i = 0; i < n - 1; i++) {
			for (int j = 1; j <= a[i + 1] - a[i] - 1; j++) {
				if (i & 1) {
					b[i - 1] += j; // 相当于当前阶梯石子移动 j 个到前一个阶梯。
					if (!is_win(b)) { // 刚才的后手是现在的先手，他得输。
						cout << a[i] << ' ' << a[i] + j << endl;
						return 0;
					}
					b[i - 1] -= j; // 还原原来的状态，除非前面已经得出了答案。
				} else {
					b[i] -= j;
					if (!is_win(b)) {
						cout << a[i] << ' ' << a[i] + j << endl;
						return 0;
					}
					b[i] += j;
				}
			}
		}
	}
	
	return 0;
}
```
---
## 结语：
本题关键在于能想到转化为阶梯博弈模型。另外，本人代码和题解可能比较屎，有错误欢迎指正，希望大佬们不要嘲笑 ಥ_ಥ。

---

## 作者：SquarFish (赞：5)

如果能想到 [Nim 博弈](https://baike.baidu.com/item/%E5%B0%BC%E5%A7%86%E5%8D%9A%E5%BC%88/58986985)，这道题难度就降低了不少。  
由于百度百科已经解释的很清楚了，这里也不过多解释了，~~绝对不是因为我懒~~。

------------

```
Nim 博弈中涉及到n堆不同的物品，这些堆中各自物品的数量是任意的。
```
“$n$ 堆不同的物品”也就是每两个小和尚之间的台阶。
```
两名玩家在轮流行动时，可以选择将某一堆中任意数量的物品拿走，至少1个，至多全部拿走，但不能不拿或跨堆拿取物品。
根据规则拿到最后一个物品，使得对手无物品可拿的玩家获胜。
```
“可以选择将某一堆中任意数量的物品拿走”也就是指挥某个小和尚向上走任意多级的台阶。

所以我们首先计算相邻的小和尚之间的台阶数。

```cpp
	while (cin >> a[n]) n++;//每个小和尚的位置
	for (int i = 0; i < n - 1; i++) b[i] = a[i + 1] - a[i] - 1;//每两个相邻的小和尚之间的台阶数
```

然后跑一遍 Nim 博弈。

```cpp
bool Nim(){
	int sum = 0;
	for (int i = 0; i < n; i += 2) sum ^= b[i];//记录异或值
	if(sum == 0) return 1;//根据 SG 定理可知，当异或值为0时，先手必败
	return 0;//不为0时，先手必胜
}
```

然后问题来了，我们还要求如何获胜，这怎么求？

仔细想想，当先手的法师指挥后，后手的法师就成了先手。只要先手的法师在操作过后异或值变为 $0$，根据刚刚提到的 SG 定理，后手的法师必败，所以我们暴力枚举可行的方法。

```cpp
	n--;//最后一个小和尚没什么用，直接删掉
	if (Nim()) cout << -1;//无解
	else {
		for (int i = 0; i < n; i++) {//枚举移动第 i 个小和尚
			for (int j = 1; a[i] + j < a[i + 1]; j++) {//枚举移动 j 级台阶
				b[i] -= j;//移动
				if (i != 0) b[i - 1] += j;//a[i]向上走了j级，那 b[i-1] 则要增加 j 级，如果动的是a[1]，由于他下面没有小和尚了，所以不用改;
				if (Nim()) {//检测是否可行
					cout << a[i] << " " << a[i] + j;//找到了，输出
					break;//跳出循环
				}
				b[i] += j;//回溯
				if (i != 0) b[i - 1] -= j;
			}
		}
	}
```
复杂度 $O(n^3)$，由于 $N < 100$，时间不会炸。

~~Ps：上面第一个逗号修了好久。~~

## 完整代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n, a[110], b[110];
bool Nim(){
	int sum = 0;
	for (int i = 0; i < n; i += 2) sum ^= b[i];//记录异或值
	if(sum == 0) return 1;//根据 SG 定理可知，当异或值为0时，先手必败
	return 0;//不为0时，先手必胜
}
int main() {
	while (cin >> a[n]) n++;//每个小和尚的位置
	for (int i = 0; i < n - 1; i++) b[i] = a[i + 1] - a[i] - 1;//每两个相邻的小和尚之间的台阶数
	n--;//最后一个小和尚没什么用，直接删掉
	if (Nim()) cout << -1;//无解
	else {
		for (int i = 0; i < n; i++) {//枚举移动第 i 个小和尚
			for (int j = 1; a[i] + j < a[i + 1]; j++) {//枚举移动 j 级台阶
				b[i] -= j;//移动
				if (i != 0) b[i - 1] += j;//a[i]向上走了j级，那 b[i-1] 则要增加 j 级，如果动的是a[1]，由于他下面没有小和尚了，所以不用改;
				if (Nim()) {//检测是否可行
					cout << a[i] << " " << a[i] + j;//找到了，输出
					break;//跳出循环
				}
				b[i] += j;//回溯
				if (i != 0) b[i - 1] -= j;
			}
		}
	}
	return 0;
}
```

---

## 作者：Dehydration (赞：3)

### 前言

此题为蓝题难度颇高了点，大概黄绿题水准（但是要想到 Nim）。
### 思路

确实是用 Nim 来做题。

第一步：两两分组(具体见代码)。

第二部：进行 Staircase Nim 博弈（不懂请看详解）。

#### 第二部细解：

挪动一组中左边的和尚相当于减少石子。挪动一组中右边的和尚相当于增加石子，这样做是没有用的，因为之后对手可以再移动左边的和尚使局面恢复原来的状况。

**注意**：虽然在必败态增加石子**没有**用，但是在必胜态增加石子却**有可能**导致胜利。

具体实现看代码。

$\large \color{RED} {AC\;Code:}$

```
#include <bits/stdc++.h>
 using namespace std;
 const int MAXN = 155;//虽然 MAXN=55 就能 AC
 int a[MAXN], b[MAXN], cnt;
 bool check()//用异或检查
 {
 	  int ans=0;
     for (int i = 0; i < cnt - 1; i += 2) ans ^= b[i];
     return ans==0;/*
     <=> 
     if(ans)
     return 0;else
     return 1;
     */
 }
 int main()
 {
     string s;
     getline(cin, s);//输入
     stringstream ss(s);//nice
     while (ss >> a[cnt]) cnt++;//cnt
     for (int i = 0; i < cnt - 1; i++) b[i] = a[i + 1] - a[i] - 1;
     if (check()) { cout << -1 << endl; return 0; }//不可能有解，一开始 check()就 Game Over
     for (int i = 0; i < cnt - 1; i++)
     {
         for (int j = 1; j < a[i + 1] - a[i]; j++)
         {
             if (i & 1) b[i - 1] += j;
             else b[i] -= j;
             if (check()) { cout << a[i] << " " << a[i] + j << endl; return 0; }
             if (i & 1) b[i - 1] -= j;
             else b[i] += j;//加回来
         }
     }
     return 0;
 }
```

---

## 作者：Lord_Sky2048 (赞：1)

每两个和尚之间看做一堆,转换为 Nim 博弈即可.

如果将棋子两两成对当作整体考虑，就可以看作 Nim，每对棋子看做一堆石子，石子数相当于棋子间的距离，向上移相当于取走石子；另一方面，将上面的棋子向上移动相当于增加了棋子数量，对手只要把和它成对的另一个石子移动到它的后面就又回到了原来的状态，奇数时特殊处理.

1)  是否可胜.

2)  若可胜，暴力第一步.
```cpp
#include<iostream>
#define N 102
using namespace std; 
int main(){
  int a[N],b[N];
    int n = 0,i,j,k,sum = 0;
      while(cin>>a[n])n++;//存储又有多少个小和尚 
     for(i=1; i<n; i++)b[i-1] = a[i] - a[i-1] - 1;// 进行Nim博弈的转换 
       for(i=0; i<n-1; i+=2) sum ^= b[i];//进行异或 
    if(sum==0)cout<<-1<<endl;//若开始局面为 0 则必输 
    else//若非0 则必赢，因此 需要找到第一步 将局面变为 0 的步骤 
    {
        for(i=0; i<n-1; ++i)//枚举移动第 i 堆  使得剩下的局面异或等于0，
            for(j=1; a[i]+j<a[i+1]; ++j) {//枚举可以移动的步数  保证 前项移动j 步后 不会超过后项 
                b[i] -= j;//拿走 j 个 ，这里代表 前一个向上移动j步 
                if(i!=0)b[i-1] += j;//它的后一堆b[i]向取走了j个，那莫前一堆 b[i-1] 则要增加 j 个 第一堆除外 
            sum = 0;
            for(k=0; k<n-1; k+=2) sum ^= b[k];//重新计算局面， 
           if(sum==0) {cout<<a[i]<<" "<<a[i]+j<<endl; break;}//若变成 0  则后手必败，先手必赢。跳出即可； 
            b[i] += j;//回溯 这不是必赢的操作 
            if(i!=0) b[i-1] -= j; 
          }
    }
    return 0;   
}
```


---

## 作者：sunhaining123456 (赞：1)

# 高僧斗法问题题解
## 问题分析

   这是一个典型的**博弈论**问题，属于"取石子游戏"的变种。我们需要找到先手必胜的策略。

### 关键观察：

***游戏规则‌***：两位法师轮流移动小和尚，每次只能向上移动任意步数，但不能跳过其他小和尚，也不能移动到同一台阶。
   
***游戏结束条件‌***：当所有小和尚都挤在最高台阶无法移动时，当前法师输。
  
博弈性质‌：这实际上是一个 $Nim$ 游戏的变种，可以通过将相邻小和尚之间的距离看作 $Nim$ 堆来解决。

***解题思路***：

将问题转化为 $Nim$ 游戏‌：

将相邻的两个小和尚之间的距离看作一个 $Nim$ 堆。
如果这些距离的异或和为 $0$，当前局面是必败态；否则是必胜态。
我们需要找到一个移动，使得移动后的所有距离异或和为 $0$。

### 具体步骤‌：

计算所有相邻小和尚之间的距离（奇数位置减去偶数位置）
计算这些距离的异或和。
如果异或和为 $0$，直接返回 $-1$（必败态）。
否则，找到一个移动使得异或和变为 $0$。


***代码实现：***

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    vector<int> monks;
    int pos;
    
    // 读取输入
    while (cin >> pos) {
        monks.push_back(pos);
    }
    
    int n = monks.size();
    vector<int> gaps;
    
    // 计算间隔（相邻两个小和尚之间的距离）
    for (int i = 0; i < n - 1; i += 2) {
        gaps.push_back(monks[i + 1] - monks[i] - 1);
    }
    
    // 计算异或和
    int xor_sum = 0;
    for (int gap : gaps) {
        xor_sum ^= gap;
    }
    
    // 如果异或和为0，必败态
    if (xor_sum == 0) {
        cout << -1 << endl;
        return 0;
    }
    
    // 寻找合适的移动
    for (int i = 0; i < monks.size(); ++i) {
        for (int j = monks[i] + 1; j < (i + 1 < monks.size() ? monks[i + 1] : monks[i] + 1000); ++j) {
            // 尝试移动第i个小和尚到位置j
            vector<int> temp_monks = monks;
            temp_monks[i] = j;
            sort(temp_monks.begin(), temp_monks.end());
            
            // 重新计算间隔和异或和
            vector<int> temp_gaps;
            for (int k = 0; k < temp_monks.size() - 1; k += 2) {
                temp_gaps.push_back(temp_monks[k + 1] - temp_monks[k] - 1);
            }
            
            int temp_xor = 0;
            for (int gap : temp_gaps) {
                temp_xor ^= gap;
            }
            
            // 如果移动后异或和为0，找到解
            if (temp_xor == 0) {
                cout << monks[i] << " " << j << endl;
                return 0;
            }
        }
    }
    
    // 如果没有找到解（理论上不会执行到这里）
    cout << -1 << endl;
    return 0;
}
```



**代码解释**

输入处理‌：读取小和尚的位置并存储在 `vector`  中。

计算间隔‌：计算相邻小和尚之间的距离（每隔一个计算）。

异或和计算‌：计算这些距离的异或和，判断当前是必胜态还是必败态。

寻找解‌：
遍历每个小和尚可能移动到的位置,
模拟移动后的状态,
检查移动后是否为必败态（异或和为 $0$）,
找到第一个符合条件的移动并输出。

输出结果‌：如果找到解则输出，否则输出 $-1$。
示例分析

### 示例 $1$

#### 输入：$1$ $5$ $9$

 间隔：$5-1-1=3$,$9-5-1=3$（只取奇数位置）

异或和：$3^3=0$ $\to$ 必败态，输出 $-1$

### 示例 $2$

#### 输入：$1$ $5$ $8$ $10$

间隔：$5-1-1=3$, $10-8-1=1$

异或和：$3^1=2$ $\to$ 必胜态

尝试移动第一个小和尚到 $3$：

新位置：$3$ $5$ $8$ $10$

新间隔：$5-3-1=1$, $10-8-1=1$

异或和：$1^1$=$0$ $\to$ 找到解，输出$1$ $3$

  ***这个解法利用了博弈论中的 Nim 游戏原理，通过将问题转化为 Nim 堆来寻找必胜策略。***

**求过！！！！**

---

## 作者：aimcf (赞：1)

+ 如果前面的小和尚移动了 $c$ 个台阶，后面的也可以移动 $c$ 个台阶，对于这两个和尚而言没有任何的意义。

首先让相邻的小和尚进行配对，间隔为石子的个数。

然后跑一遍 Nim 博弈。

如果所有的石子的数量的异或的值为 $0$，那么通过 SG 定理可知，先发令的法师不会获胜。否则一定会获胜。

否则直接暴力枚举移动的人和移动的步数即可。如果移动完之后答案异或的值为 $0$，那么后手必败（先手必胜）。

时间复杂度 $O(n^3)$，但是远远跑不满。

最后：SDCSP-S 2022 RP++。

---

## 作者：Lofty (赞：0)

### 前言：

这道题转模完和 [P8382](https://www.luogu.com.cn/problem/P8382) 很像，不过这题求一个具体方案，P8382 求总方案数。

前置知识：[nim 游戏](https://www.luogu.com.cn/problem/P2197)。

### Solution：

既然已经说了转模，当然说说怎么转。因为小和尚的移动受到更高级台阶的小和尚的限制，所以博弈操作应该与这段距离有关。如果将一个小和尚到更高级台阶的小和尚距离为 $x$ 的一段,看作一个有 $x$ 个石子的石子堆，对应的操作应该是从一个石子堆中移出一定的石子到相邻石子堆中。这和 nim 的一个经典模型非常契合——阶梯模型（不会自行 bdfs）。于是可以直接转为 nim 游戏出结论。

但这题要我们输出一个具体方案。在阶梯模型中，胜负只与奇数级台阶上的石子数有关，但在求方案时，偶数级台阶也可能产生贡献。

设台阶上的石子数为 $a_i$ ，若必胜则会有 $a_i \oplus a_{i+2} \oplus \cdots \oplus a_n \neq 0$，第一步决策就是使得 $a_i \oplus a_{i+2} \oplus \cdots \oplus a_n = 0$。此时有两种可能的方式：

假设 $a_i \oplus a_{i+2} \oplus \cdots \oplus a_n = k$。

1. $\exist d \in [1,a_{i+1}]$，$a_i+d=k \oplus a_i$。
2. $\exist d \in [1,a_i]$，$a_i-d=k \oplus a_i$。

以上两种均可以产生一种可能的第一步操作，按题目要求选择即可。

### Code：
```
namespace Lofty
{
	int a[N],b[N];
	void work()
	{
		int n=1;
		while(scanf("%d",&a[n])!=EOF)n++;
		--n;
		int res=0,ans=0,cnt=0;
		for(int i=1;i<n;i++)
			b[i]=a[i+1]-a[i]-1;
		for(int i=1;i<n;i++)
			if(i&1)
				res^=b[i];
		if(!res)
			return writeln(-1);
		for(int i=1;i<n;i++)
		{
			if(i&1)
			{
				if((res^b[i])<b[i])//第二种方式
				{
					cnt=a[i],ans=cnt+b[i]-(res^b[i]);
					break;
				}
			}
			else
			{
				if((res^b[i-1])<=b[i]+b[i-1]&&(res^b[i-1])>b[i-1])第一种方式
					cnt=a[i],ans=cnt+(res^b[i-1])-b[i-1];
			}
			if(cnt)
				break;
		}
		writeln(cnt,ans);
	}
}
```
~~做完 P8382 再来做就是降维打击~~

---


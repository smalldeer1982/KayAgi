# [NOI2016] 区间

## 题目描述

在数轴上有 $n$ 个闭区间从 $1$ 至 $n$ 编号，第 $i$ 个闭区间为 $[l_i,r_i]$ 。

现在要从中选出 $m$ 个区间，使得这 $m$ 个区间共同包含至少一个位置。换句话说，就是使得存在一个 $x$ ，使得对于每一个被选中的区间 $[l_i,r_i]$，都有 $l_i \leq x \leq r_i$ 。

对于一个合法的选取方案，它的花费为被选中的最长区间长度减去被选中的最短区间长度。

区间 $[l_i,r_i]$ 的长度定义为 $(r_i-l_i)$ ，即等于它的右端点的值减去左端点的值。

求所有合法方案中最小的花费。如果不存在合法的方案，输出 $-1$。

## 说明/提示

#### 样例输入输出 1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/qoddox9k.png)
 
 如图，当 $n=6$，$m=3$ 时，花费最小的方案是选取 $[3,5],[3,4],[1,4]$ 这三个区间，它们共同包含了 $4$ 这个位置，所以是合法的。其中最长的区间是 $[1, 4]$，最短的区间是 $[3, 4]$，所以它的花费是 $(4 - 1) - (4 - 3) = 2$。

#### 数据规模与约定

本题共 20 个测试点，各测试点信息如下表。
| 测试点编号 | $ n= $ | $ m= $ | $ l_i,r_i $ |
|:-:|:-:|:-:|:-:|
| 1 | $ 20 $ | $ 9 $ | $ 0 \le l_i \le r_i \le 100 $ |
| 2 | $ 20 $ | $ 10 $ | $ 0 \le l_i \le r_i \le 100 $ |
| 3 | $ 199 $ | $ 3 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 4 | $ 200 $ | $ 3 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 5 | $ 1000 $ | $ 2 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 6 | $ 2000 $ | $ 2 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 7 | $ 199 $ | $ 60 $ | $ 0 \le l_i \le r_i \le 5000 $ |
| 8 | $ 200 $ | $ 50 $ | $ 0 \le l_i \le r_i \le 5000 $ |
| 9 | $ 200 $ | $ 50 $ | $ 0 \le l_i \le r_i \le 10^9 $ |
| 10 | $ 1999 $ | $ 500 $ | $ 0 \le l_i \le r_i \le 5000 $ |
| 11 | $ 2000 $ | $ 400 $ | $ 0 \le l_i \le r_i \le 5000 $ |
| 12 | $ 2000 $ | $ 500 $ | $ 0 \le l_i \le r_i \le 10^9 $ |
| 13 | $ 30000 $ | $ 2000 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 14 | $ 40000 $ | $ 1000 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 15 | $ 50000 $ | $ 15000 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 16 | $ 100000 $ | $ 20000 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 17 | $ 200000 $ | $ 20000 $ | $ 0 \le l_i \le r_i \le 10^9 $ |
| 18 | $ 300000 $ | $ 50000 $ | $ 0 \le l_i \le r_i \le 10^9 $ |
| 19 | $ 400000 $ | $ 90000 $ | $ 0 \le l_i \le r_i \le 10^9 $ |
| 20 | $ 500000 $ | $ 200000 $ | $ 0 \le l_i \le r_i \le 10^9 $ |

对于全部的测试点，保证 $1 \leq m \leq n$，$1 \leq n \leq 5 \times 10^5$，$1 \leq m \leq 2 \times 10^5$，$0 \leq l_i \leq r_i \leq 10^9$。

## 样例 #1

### 输入

```
6 3
3 5
1 2
3 4
2 2
1 5
1 4```

### 输出

```
2```

# 题解

## 作者：上进的z君 (赞：82)

首先分析一下题目，l,r这么大很显然就是要离散化了。

接着我们又注意到题目要求的答案跟“最大”，“最小”有关，所以我们就会联想到单调性。

既然是跟区间长度有关，那我们不妨就先按区间长度排个序好了，反正这样子并不会影响答案。


然后我们思考一种最朴素的做法，那就是按排序后的顺序逐一加入区间，然后看看是否有   一个点的被覆盖次数>=m。

如果有的话那就统计一下答案，然后将前面加入的按顺序删掉，直到<m。

重复上诉的过程。

很显然这利用了尺取法的思想。


那么问题就是我们如何快速地得知是否有   一个点的被覆盖次数>=m。

那就很显然维护一棵线段树就好了。

于是这题就成功解决。









    
    
    

    
    
    
    
    


        
        
        
    
    
        
    
    
    
            
            
        
        
            
            
        
    
    
```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<iostream>
#include<algorithm>
#include<stack>
#include<queue>
using namespace std;
const int maxn=501000;
const int INF=1e9;
struct Point{
    int val,ord;
}p[maxn*4];
struct Data{
    int len,ord;
}a[maxn*4];
int L[maxn*2],R[maxn*2],n,m,Right,cur=0;
int tree[maxn*8],add[maxn*8];
bool Cmp1(Point x1,Point x2){
    if(x1.val<x2.val)return true;
    return false;
}
bool Cmp2(Data x1,Data x2){
    if(x1.len<x2.len)return true;
    return false;
}
void Down(int rt,int l,int r){
    if(!add[rt])return;
    int ls=rt*2,rs=rt*2+1;
    tree[ls]+=add[rt];
    tree[rs]+=add[rt];
    add[ls]+=add[rt];
    add[rs]+=add[rt];
    add[rt]=0;
    return;
}
void Update(int rt,int l,int r,int x,int y,int val){
    if(x>r||y<l)return;
    if(x<=l&&y>=r){
        tree[rt]+=val;
        add[rt]+=val;
        return;
    }
    int mid=(l+r)/2;
    Down(rt,l,r);
    Update(rt*2,l,mid,x,y,val);
    Update(rt*2+1,mid+1,r,x,y,val);
    tree[rt]=max(tree[rt*2],tree[rt*2+1]);
    return;
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
        int u,v;
        scanf("%d%d",&u,&v);
        a[i].len=v-u;
        a[i].ord=i;
        cur++;
        p[cur].val=u;
        p[cur].ord=i;
        cur++;
        p[cur].val=v;
        p[cur].ord=i;
    }
    sort(p+1,p+cur+1,Cmp1);
    int num=0;
    p[0].val=-1;
    for(int i=1;i<=cur;i++){
        if(p[i].val!=p[i-1].val)
        num++;
        int u=p[i].ord;
        if(!L[u])
        L[u]=num;
        else R[u]=num;
    }
    Right=num;
    sort(a+1,a+n+1,Cmp2);
    int ans=INF,le=0,ri=0;
    while(true){
        while(tree[1]<m&&ri<=n){
            ri++;
            int u=a[ri].ord,v=L[u],w=R[u];
            Update(1,1,Right,v,w,1);
        }
        if(tree[1]<m)break;
        while(tree[1]>=m&&le<=n){
            le++;
            int u=a[le].ord,v=L[u],w=R[u];
            Update(1,1,Right,v,w,-1);
        }
        ans=min(ans,a[ri].len-a[le].len);
    }
    if(ans==INF)printf("-1\n");
    else
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：wanglichao1121 (赞：49)

首先离散化（10^9线段树。。。）

按照长度（离散前）排序以后肯定一段一段取，于是双指针

每移动一次指针都是logn的线段树上的修改

查询最大值直接看树顶

= =标记下传的什么心态，显然可以永久化，又短又好写又快


```cpp
#include <bits/stdc++.h>
#define mid (l+r>>1)
using namespace std;
int n,m,ans=2100000000,l,r,ad[4000001],ma[4000001],p[4000001];
struct qj{ int l,r;} a[500001];
bool operator<(qj a,qj b){ return (a.r-a.l)<(b.r-b.l);}
inline int sum(int l,int r){ return p[a[r].r]-p[a[r].l]-p[a[l].r]+p[a[l].l];}
void add(int now,int l,int r,int x,int y,int z)
{
    if(l==x && r==y)
    {
        ad[now]+=z;ma[now]+=z;
        return;
    }
    if(x<=mid) add(now*2,l,mid,x,min(mid,y),z);
    if(y>mid) add(now*2+1,mid+1,r,max(x,mid+1),y,z);
    ma[now]=max(ma[now*2],ma[now*2+1])+ad[now];
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
        scanf("%d%d",&a[i].l,&a[i].r),p[i*2-1]=a[i].l,p[i*2]=a[i].r;
    int N=2*n;sort(p+1,p+N+1);N=unique(p+1,p+N+1)-p-1;
    sort(a+1,a+n+1);
    for(int i=1;i<=n;i++)
        a[i].l=lower_bound(p+1,p+N+1,a[i].l)-p,
        a[i].r=lower_bound(p+1,p+N+1,a[i].r)-p;
    for(l=1,r=0;l<=n;add(1,1,N,a[l].l,a[l].r,-1),l++)
    {
        while(r<n && ma[1]<m)
            ++r,add(1,1,N,a[r].l,a[r].r,1);
        if(r==n && ma[1]<m) break;
        ans=min(ans,sum(l,r));        
    }
    printf("%d\n",(ans==2100000000)?-1:ans);
    return 0;
}
```

---

## 作者：EternalEpic (赞：39)

（重新修改了稿子，调整了格式）

最近在练线段树和离散化，就飞到这题了。

平心而论，这道题作为NOI T1 是送分的，个人认为，最多当tg的D2T2。

题解大同小异，都是说开个线段树，把l，r排序，用尺取法搞。

毕竟只要维护单点覆盖数，还是很常见的；而尺取法这个东西不必太在意，就是指再向前扩展时，不断根据状态（即与m大小关系）进行动态收尾调整（就像一个尺子往前移一样），其实笔者做题时也没想这么多，就把它码出来了，后来才知道是传说中的尺取法。

但是这道题也是有坑点的。那我就来讲点其他题解中没有说的坑点吧。

case1：

leni = ri - li ([li ~ ri]) 这点题目条件中讲到了，可我眼瞎加了1，我相信也有同志会搞错（虽然好像不影响排序，最后交上去也能AC）

case2：

离散化，权值线段树最大的bug是空间，开不下4e9就老老实实unique.

我离散化第一遍都写错了：

#### 错误范例

```cpp
a[i].l = lower_bound(uni + 1, uni + tot + 1, a[i].l) - (uni + 1);
a[i].r = lower_bound(uni + 1, uni + tot + 1, a[i].r) - (uni + 1);
```

#### 正确写法

```cpp
a[i].l = lower_bound(uni + 1, uni + tot + 1, a[i].l) - uni;
a[i].r = lower_bound(uni + 1, uni + tot + 1, a[i].r) - uni;
```

case3:

不知道有没有人query写复杂了，就是tmax[1]鸭！！！

~~我是不会告诉你，上面的坑我基本都掉了~~

Last， but not the least!

#### CODE：

```cpp
//Program written by Liu Zhaozhou ~~~
#include <bits/stdc++.h>
#include <algorithm>
#include <queue>
#include <set>
#include <vector>
#include <deque>
#include <string>

#define lowbit(x) x & -x

#pragma GCC optimize(3)

using namespace std;

namespace Base {
inline char gc(void)
{
	static char buf[100000], *p1 = buf, *p2 = buf;
	return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2) ? EOF : *p1++;
}

#define gc() getchar()

template <class T> inline void read(T &x)
{
	T flag = 1; x = 0; register char ch = gc();
	for (; !isdigit(ch); ch = gc()) if (ch == '-') flag = -1;
	for (; isdigit(ch); ch = gc()) x = (x << 1) + (x << 3) + (ch & 15);
	x *= flag; return;
}

template <class T> inline void write(T x) {
	if (x < 0) putchar('-'), x = -x;
	register T y = 1; int len = 1;
	for (; y <= x / 10; y *= 10) ++len;
	for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);
}

template <class T> inline void writeln(T x) {write(x); puts("");}
template <class T> inline void writeln(T x, char c) {write(x); putchar(c);}
template <class T> inline void writeln(char c, T x) {putchar(c); write(x);}

template <class T> inline void chkmax(T &x, const T y) {x > y ? x = x : x = y;}
template <class T> inline void chkmin(T &x, const T y) {x < y ? x = x : x = y;}

typedef long long ll;
typedef unsigned long long ull;
typedef long double ld;

#define Ms(arr, opt) memset(arr, opt, sizeof(arr))
#define Mp(x, y) make_pair(x, y)

inline void file(string str) {
	freopen((str + ".in").c_str(), "r", stdin);
	freopen((str + ".out").c_str(), "w", stdout);
}
}

using namespace Base;

enum {
	Maxn = 5000005
};

class RMQ_SegmentTree {
public:
	int tmax[Maxn << 2 | 1], tag[Maxn << 2 | 1];
	
	inline void pushup(int pos) {
		tmax[pos] = max(tmax[pos << 1], tmax[pos << 1 | 1]);
	}
	
	inline void add(int pos, int val) {
		tag[pos] += val; tmax[pos] += val;
	}
	
	inline void pushdown(int pos) {
		if (tag[pos]) {
			add(pos << 1, tag[pos]);
			add(pos << 1 | 1, tag[pos]);
			tag[pos] = 0; return;
		}
	}
	
	inline void build(int pos, int l, int r) {
		tag[pos] = tmax[pos] = 0;
		if (l == r) return;
		int mid = l + r >> 1;
		build(pos << 1, l, mid);
		build(pos << 1 | 1, mid + 1, r);
	}
	
	inline void modify(int pos, int l, int r, int L, int R, int val)
	{
		if (L > r || R < l) return;
		if (L <= l && R >= r) {add(pos, val); return;}
		pushdown(pos); int mid = l + r >> 1;
		if (L <= mid) modify(pos << 1, l, mid, L, R, val);
		if (R > mid) modify(pos << 1 | 1, mid + 1, r, L, R, val);
		pushup(pos);
	}
	
	inline int query_all(void) {return tmax[1];}
} sgt;

class State {
public:
	int l, r, length;
	inline void setup(int _l, int _r) {
		l = _l, r = _r; length = r - l;
	}
	inline bool operator < (const State&opt)
	const {
		return length < opt.length;
	}
} a[Maxn];

int uni[Maxn], n, m, tot = 0;

signed main(void) {
	//file("");
	read(n), read(m);
	for (int i = 1, u, v; i <= n; i++) {
		read(u); read(v); a[i].setup(u, v);
		uni[++tot] = u; uni[++tot] = v;
	}
	
	sort(a + 1, a + n + 1);
	sort(uni + 1, uni + tot + 1);
	tot = unique(uni + 1, uni + tot + 1) - (uni + 1);
	
	for (int i = 1; i <= n; i++) {
		a[i].l = lower_bound(uni + 1, uni + tot + 1, a[i].l) - uni;
		a[i].r = lower_bound(uni + 1, uni + tot + 1, a[i].r) - uni;
	}
	
	int tmpl = 1, ret = INT_MAX;
	sgt.build(1, 1, tot);
	
	for (int i = 1; i <= n; i++) {
		sgt.modify(1, 1, tot, a[i].l, a[i].r, 1);
		while (sgt.query_all() >= m) {
			chkmin(ret, a[i].length - a[tmpl].length);
			sgt.modify(1, 1, tot, a[tmpl].l, a[tmpl].r, -1);
			tmpl++;
		}
	}
	
	if (ret == INT_MAX) puts("-1");
	else writeln(ret);
	return 0;
}

/**/


```

~~笔者清奇俊秀的代码竟然进了前五页！！！~~

写码不易，谢谢兹磁！

---

## 作者：lcjqwq (赞：27)

先按照长度排个序，然后依次添加区间。什么是添加？设这个区间是$[l,r]$，添加就是把$a_l,a_{l+1},a_{l+2},{...},a_{r}$都加上$1$，其中$a_i$表示第$i$个位置被几个区间覆盖。拿走一个区间的含义就是把它们都减$1$。这个过程很显然可以用线段树维护。

如果在添加到一个区间 $i$ 时，有一个点被区间覆盖了$M$次，那么先更新答案，再把前面的加入过的区间一直拿直到没有一个点被覆盖$M$次。如何判断有没有点被覆盖$M$次？因为是一个一个区间加的，所以只用维护一个$a_i$的最大值，看他是否$=M$就行了。

什么叫**再把前面的加入过的区间一直拿直到没有一个点被覆盖$M$次**？

比如你一直添加区间到第$5$个，此时有一个点被覆盖了$M$次。这时你就将第一个区间拿出，如果此时依然有有一个点被覆盖了$M$次，那么你就拿走第二个...

这个过程就好比一个队列，可以从后面添加区间达到一个点被覆盖了$M$次；从前面弹出区间直到没有一个点被覆盖了$M$次。

差不多就是这样，还有注意一下$l_i,r_i \leq 10^9$，开线段树是要离散化的。上代码： 
```cpp
#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <algorithm>

using namespace std;

const int MAXN = 1000500;
int N, M, l[MAXN], r[MAXN], lid[MAXN], rid[MAXN], cnt;
struct node {
    int left, right, Max, lazy;
    node *ch[2];
}pool[MAXN * 3], *root; 
struct xianduan {
    int len, l, r;
    bool operator < (const xianduan& a) const {
        return len < a.len;
    }
}b[MAXN];
struct getin {
    int d, lid, rid, nid;
    bool operator < (const getin &a) const {
        return d < a.d;
    } 
}a[MAXN * 2];
inline void pushdown(node *r) {
    if(!r->lazy) return ;
    r->Max += r->lazy;
    if(r->ch[0]) r->ch[0]->lazy += r->lazy;
    if(r->ch[1]) r->ch[1]->lazy += r->lazy;
    r->lazy = 0;
}
inline void pushup(node *r) {
    r->Max = max(r->ch[0]->Max, r->ch[1]->Max);
}
inline void build(node *r, int left, int right) {
    r->left = left, r->right = right;
    if(left == right) return ;
    int mid = (left + right) / 2;
    node *lson = &pool[++cnt], *rson = &pool[++cnt];
    r->ch[0] = lson, r->ch[1] = rson;
    build(lson, left, mid); build(rson, mid + 1, right);
}
inline　void　change(node *r, int left, int right, int d) {
    if(r->left == left && r->right == right) {
        r->lazy += d; return ;
    }　　　　
    pushdown(r);
    if(r->ch[0]->right >= right) change(r->ch[0], left, right, d);　　　　
    else if(r->ch[1]->left <= left) change(r->ch[1], left, right, d);　　　　　
    else change(r->ch[0], left, r->ch[0]->right, d), change(r->ch[1], r->ch[1]->left, right, d);
    pushdown(r->ch[0]), pushdown(r->ch[1]), pushup(r);
}　　　　　　　　　　　　　　　　　　　　　　
int main()　 {　　　　　　　　　　　　　　　
    root = &pool[0];
    scanf("%d%d", &N, &M);
    for(int　i　=　1; i <= N; i++) {
    	scanf("%d%d", &l[i], &r[i]);
    	a[2 * i -　1].d = l[i], a[2 * i - 1].lid = i, a[2 * i - 1].rid = -1;　
    	a[2 * i].d = r[i], a[2 * i].lid = -1, a[2 * i].rid　= i;　
    }　
    sort(a + 1, a　+　2 * N + 1);　
    a[0].d = -1;　
    for(int i = 1; i <= 2 * N; i++) {　
        if(a[i].d == a[i - 1].d) a[i].nid = a[i - 1].nid;
        else a[i].nid = a[i - 1].nid + 1;　
        if(a[i].lid != -1) lid[a[i].lid] = a[i].nid; 
        else rid[a[i].rid] = a[i].nid;　
    }　
    build(root, 1, a[2 * N].nid);
    for(int i = 1; i <= N; i++) {
        b[i].len = r[i] - l[i], b[i].l = lid[i], b[i].r = rid[i];
    }
    sort(b + 1, b + N + 1);
    int last =　1, ans = 2147483647;
    for(int i = 1; i <= N; i++) {
        change(root, b[i].l, b[i].r, 1);
        while(root->Max == M) {
            change(root, b[last].l, b[last].r, -1);
            ans = min(ans, b[i].len - b[last].len);
            last++;
        }　　
    }　
    if(ans == 2147483647) ans = -1;
    printf("%d\n", ans);
    return 0;
}
```

不要试图提交我的代码，你会因为一些奇怪的空格花式CE的。



---

## 作者：Taduro (赞：17)

首先我们肯定知道，如果要添加一个区间的话肯定是区间加的，那我一开始的想法就是找到被覆盖m次以上的点，同时在覆盖的时候记下每个点所在的最大和最小的区间。

然而这个算法很难实现，每个点在的最大和最小的区间难以用线段树维护。

那我们换一个做法，枚举能构成答案的区间，，这是个N2的步骤，为了方便计算答案，我们先对区间按长度排个序，这样我们就有一个N2 log N的算法。

接下来考虑优化，想一下前面那个算法有什么浪费的地方？

假设我们在从第i个区间选起，一直选了j个区间，此时符合要求了，我们选完收工，线段树清零。

到了第i+1个区间，好像也至少要选到第j个区间，这么一看，我们只要把第i个区间删了就好了，这样时间复杂度是O(N)。（有点像滑动窗口？）

这样大概就完了吗，还有几个小问题。

Q：怎么判断是否有点被覆盖了m次？

A：这个可以维护一个最大值，这样只要看根节点就好了，都不用写查询函数。

Q：为什么你没有说离散化和去重？

A：这。。。有人会忘吗？

PS:代码里还有点注释

```
#include<cstdio>
#include<iostream>
#include<algorithm>
#define ll long long
#define re register
#ifdef ONLINE_JUDGE
char ss[1<<17],*A=ss,*B=ss;
inline char gc(){if(A==B){B=(A=ss)+fread(ss,1,1<<17,stdin);if(A==B)return EOF;}return*A++;}
template<class T>inline void read(T&x){
    static char c;static int y;
    for(c=gc(),x=0,y=1;c<48||57<c;c=gc())if(c=='-')y=-1;
    for(;48<=c&&c<=57;c=gc())x=((x+(x<<2))<<1)+(c^'0');
    x*=y;
}
#else
void read(ll&x){scanf("%lld",&x);}
#endif		//上面是读优
using namespace std;
struct node{
	ll l,r,z;
}qg[500001];
ll a[1500010],sum[4000010],ad[4000010];		//由于一个区间有两个点，所以最坏情况要开八倍数组
ll n,m,tail,head,ans,size,minn,maxn;
inline bool cmp(node c,node d){
	return c.z<d.z;
}
inline void pushdown(ll rt){
	if (ad[rt]){
		sum[rt<<1]+=ad[rt];
		sum[rt<<1|1]+=ad[rt];
		ad[rt<<1]+=ad[rt];
		ad[rt<<1|1]+=ad[rt];
		ad[rt]=0;
	}
}
void update(ll rt,ll l,ll r,ll x,ll y,ll k){
	if (x>r||l>y) return;
	if (x<=l&&r<=y){
		ad[rt]+=k;
		sum[rt]+=k;
		return;
	}
	pushdown(rt);
	ll mid=(l+r)>>1;
	update(rt<<1,l,mid,x,y,k);
	update(rt<<1|1,mid+1,r,x,y,k);
	sum[rt]=max(sum[rt<<1],sum[rt<<1|1]);
}
int main(){
	ll x,y;
	read(n); read(m);
	for (re int i=1; i<=n; i++){
		read(x); read(y);
		a[i*2]=x; a[i*2+1]=y;
		qg[i].l=x; qg[i].r=y; qg[i].z=y-x;
	}
	sort(a+1,a+n*2+2);					 // 先排序
	size=unique(a+1,a+n*2+1)-(a+1);		//再去重
	sort(qg+1,qg+n+1,cmp);
	for (re int i=1; i<=n; i++){
		qg[i].l=lower_bound(a+1,a+size+1,qg[i].l)-a;	//找到区间i可修改的范围
		qg[i].r=lower_bound(a+1,a+size+1,qg[i].r)-a;
		minn=min(minn,qg[i].l); maxn=max(maxn,qg[i].r);	//这个是线段树的总范围
	}
	head=0; tail=0;
	ans=1e9;
	while (tail<n){
		while (sum[1]<m&&tail<=n){		//入队知道符合条件
		tail++; update(1,minn,maxn,qg[tail].l,qg[tail].r,1);}
		if (sum[1]<m) break;
		while (sum[1]>=m&&tail>=head){	//为保证答案最优出队无用的元素
		head++; update(1,minn,maxn,qg[head].l,qg[head].r,-1);}
		ans=min(ans,qg[tail].z-qg[head].z);
	}
	if (ans==1e9) ans=-1;
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：zzr8178541919 (赞：11)

区间这道题目是一道很好的题。

本题关键在于思维的难度，想到了正确的做法，实现起来并不难。

接下来我们讲一讲做法。

像这一类区间覆盖的问题都是有章可循的。我们看到要求的是最大区间长度减去最小的区间长度。从而我们自然地想到要先给他们按照区间长度排一个序。

然后我们从左到右枚举每一个区间，把覆盖到的每一个点的次数统计出来。
如果我们发现此刻有一个点的个数大于了m，那么说明我们找到了一个可能的答案。把这个答案更新。然后再从前面删区间，直到这个个数小于m。

因为我们知道如果当前找到了一个答案。那么此时的区间能够成一个解。如果现在不从前往后更新，那么我们在之后又会发现另外一个解，但这个解形成的长度肯定不比前一个区间形成的长度更优。所以我们把前面的向后推，又得到了一个新的起点。而如果向后推没有推到小于m，那么之后的最好区间仍然会是
前一个区间

从而这样在不断的更新中能得到最好的答案。
找这样的值由于是下标递增的，可以用线段树维护。

这样的复杂度是O（能过）
```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<queue>
using namespace std;
const int maxn=500005;
const int INF=1e9;
int n,m;
int cnt=0;
struct vode
{
	int len;
	int id;
}a[maxn*4];
struct node
{
	int val;
	int id;
}p[maxn*4];
bool cmp1(node x,node y)
{
	return x.val<y.val;
}
int l[maxn*2];
int r[maxn*2];
bool cmp2(vode x,vode y)
{
	return x.len<y.len;
}
int tree[maxn*8];
int add[maxn*8];
void down(int root,int l,int r)
{
	if(!add[root])
	return;
	tree[root*2]+=add[root];
	tree[root*2+1]+=add[root];
	add[root*2]+=add[root];
	add[root*2+1]+=add[root];
	add[root]=0;
}//线段树的懒标记下传 

void update(int root,int l,int r,int x,int y,int val)
{
	if(x>r || y<l)
	return;
	if(x<=l && y>=r)
	{
		tree[root]+=val;
		add[root]+=val;
		return;
	}
	int mid=(l+r)/2;
	down(root,l,r);
	update(root*2,l,mid,x,y,val);
	update(root*2+1,mid+1,r,x,y,val);
	tree[root]=max(tree[root*2],tree[root*2+1]);
	return;
}//更新部分 

int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		a[i].len=y-x;
		a[i].id=i;
		cnt++;
		p[cnt].val=x;
		p[cnt].id=i;
		cnt++;
		p[cnt].val=y;
		p[cnt].id=i;
	}
	sort(p+1,p+1+cnt,cmp1);
	int tot=0;
	p[0].val=-1;
	for(int i=1;i<=cnt;i++)
	{
		if(p[i].val!=p[i-1].val)
		{
			tot++;
		}//离散化 
		int point=p[i].id;
		if(!l[point])
		l[point]=tot;
		else
		r[point]=tot;
	}
	//前面是预处理部分，以及离散化。 
	int Right=tot;
	sort(a+1,a+1+n,cmp2);
	int ans=INF;
	int L=0;
	int R=0;
	//接下来就是从左往右枚举
	//然后用线段树维护 
	while(true)
	{
		while(tree[1]<m && R<=n)
		{
			R++;
			int u=a[R].id;
			int v=l[u];
			int w=r[u];
			update(1,1,Right,v,w,1);
		}//这里是加入部分，加入就把区间加入线段树中 
		if(tree[1]<m)
		break;//条件成立时直接退 
		while(tree[1]>=m && L<=n)
		{
			L++;
			int u=a[L].id;
			int v=l[u];
			int w=r[u];
			update(1,1,Right,v,w,-1);
		}//这里是删除部分，删去一个区间相当于就是把
		//这个区间的数都减去1。
		//一样的道理 
		ans=min(ans,a[R].len-a[L].len);
		//更新ans的值 
	}
	if(ans==INF)
	{
		printf("-1\n");
	}
	else
	printf("%d\n",ans);
	return 0;
} 
```







---

## 作者：GKxx (赞：6)

跟[连环病原体](https://www.luogu.org/problemnew/show/P4230)挺像的。

把区间按长度排序，端点离散化。

因为要花费最小，所以按长度排序之后，最优方案一定是一段连续的区间$[L_l,R_l],[L_{l+1},R_{l+1}],...,[L_r,R_r]$

注意到对于一个固定的$l$，如果第$l$个区间到第$r$个区间构成了一个合法的方案，那么对于任意$r'>r$，第$l$个区间到第$r'$个区间一定也是一个合法的方案，并且花费一定比$l$到$r$的花费大。

所以我们可以枚举每个$l$，找出最小的$r$使得选择$l$个区间到第$r$个区间是合法的，然后更新答案。

同时注意到重要性质：当$l$递增的时候，最小的$r$单调不减。

于是使用经典的双指针（类似于单调队列或者也可能是就是单调队列）扫一遍即可。

如何判断一个方案是否合法？用线段树维护一段区间上的每个点被覆盖了多少次以及覆盖次数最大值。

复杂度：每个元素至多被两个指针各扫一次，每次扫到都要调用一次线段树上的操作，所以复杂度$O(nlog_{2}n)$

```cpp
#include <cctype>
#include <cstdio>
#include <climits>
#include <algorithm>

template <typename T> inline void read(T& t) {
    int f = 0, c = getchar(); t = 0;
    while (!isdigit(c)) f |= c == '-', c = getchar();
    while (isdigit(c)) t = t * 10 + c - 48, c = getchar();
    if (f) t = -t;
}
#if __cplusplus >= 201103L
template <typename T, typename... Args>
inline void read(T& t, Args&... args) {
    read(t); read(args...);
}
#else
template <typename T1, typename T2>
inline void read(T1& t1, T2& t2) { read(t1); read(t2); }
template <typename T1, typename T2, typename T3>
inline void read(T1& t1, T2& t2, T3& t3) { read(t1, t2); read(t3); }
template <typename T1, typename T2, typename T3, typename T4>
inline void read(T1& t1, T2& t2, T3& t3, T4& t4) { read(t1, t2, t3); read(t4); }
template <typename T1, typename T2, typename T3, typename T4, typename T5>
inline void read(T1& t1, T2& t2, T3& t3, T4& t4, T5& t5) { read(t1, t2, t3, t4); read(t5); }
#endif	// C++11

#ifdef WIN32
#define LLIO "%I64d"
#else
#define LLIO "%lld"
#endif	// WIN32 long long
#define rep(I, A, B) for (int I = (A); I <= (B); ++I)
#define rrep(I, A, B) for (int I = (A); I >= (B); --I)
#define erep(I, X) for (int I = head[X]; I; I = next[I])

const int maxn = 5e5 + 207, inf = INT_MAX;
int mx[maxn << 3], delta[maxn << 3];
int tmp[maxn << 1];
struct Range {
    int le, rg, len;
    Range(int l, int r) : le(l), rg(r), len(r - l) {}
    Range() : le(0), rg(0), len(0) {}
};
Range ran[maxn];
int n, m, all;

inline bool operator<(const Range& lhs, const Range& rhs) {
    return lhs.len < rhs.len;
}

inline void upd(int curr) {
    mx[curr] = std::max(mx[curr << 1], mx[curr << 1 | 1]);
}
inline void pd(int curr, int lb, int rb) {
    if (delta[curr]) {
        int &d = delta[curr];
        delta[curr << 1] += d; delta[curr << 1 | 1] += d;
        mx[curr << 1] += d; mx[curr << 1 | 1] += d; d = 0;
    }
}
void mdf(int curr, int lb, int rb, int l, int r, int d) {
    if (l > rb || r < lb) return;
    if (l <= lb && r >= rb) {
        delta[curr] += d; mx[curr] += d; return;
    }
    pd(curr, lb, rb);
    int mid = (lb + rb) >> 1;
    mdf(curr << 1, lb, mid, l, r, d);
    mdf(curr << 1 | 1, mid + 1, rb, l, r, d);
    upd(curr);
}

int main() {
    read(n, m);
    rep(i, 1, n) {
        int l, r; read(l, r);
        ran[i] = Range(l, r);
        tmp[++all] = l; tmp[++all] = r;
    }
    std::sort(tmp + 1, tmp + all + 1);
    all = std::unique(tmp + 1, tmp + all + 1) - (tmp + 1);
    rep(i, 1, n) {
        ran[i].le = std::lower_bound(tmp + 1, tmp + all + 1, ran[i].le) - tmp;
        ran[i].rg = std::lower_bound(tmp + 1, tmp + all + 1, ran[i].rg) - tmp;
    }
    std::sort(ran + 1, ran + n + 1);
    int ans = inf;
    for (int l = 1, r = 0; l <= n; ++l) {
        bool found = 0;
        while (r < n) {
            ++r; mdf(1, 1, all, ran[r].le, ran[r].rg, 1);
            if (mx[1] >= m) { found = 1; break; }
        }
        if (found) {
            ans = std::min(ans, ran[r].len - ran[l].len);
            mdf(1, 1, all, ran[r].le, ran[r].rg, -1); --r;
        } else break;
        mdf(1, 1, all, ran[l].le, ran[l].rg, -1);
    }
    printf("%d\n", ans < inf ? ans : -1);
    return 0;
}
```

连环病原体那题就是把这里的线段树换成了$lct$而已。

---

## 作者：夏色祭 (赞：6)

## 算法一

首先当我们确定要取的区间花费的最小值和最大值，那么花费在最小值和最大值之间的区间我们都可以取，然后只要判断一下，是否有一个点被至少m个区间覆盖就行了。所以我们先按照花费给这些区间排个序。

然后我的第一反应就是二分答案。

check的时候，因为区间花费是有序的，那么我们一个一个区间扫下去，每次到一个新的区间时，就把当前区间的花费定为最大值，那么花费<当前区间-mid的区间弹出，然后判断一下是否有一个点被至少m个区间覆盖。

我们用个线段树维护一下是否有一个点被至少m个区间覆盖就行了。

因为l和r很大，所以我们可以先离散下，这么线段树就不用动态开点了。

因为每个区间只会被操作两次(加入一次，弹出一次)，所以check的复杂度是$O(n log n)$，再加上二分，最终复杂度就是$O(nlogn^2)$。

预计得分:80

~~这大概就是当年的暴力分把~~

```
// by zykykyk
#include<cstdio>
#include<ctime>
#include<iostream>
#include<algorithm>
#include<cmath>
#include<string>
#include<cstring>
#define rg register
#define il inline
#define vd void
#define ll long long
#define N 500010
#define For(i,x,y) for (rg int i=(x);i<=(y);i++)
#define Dow(i,x,y) for (rg int i=(x);i>=(y);i--)
#define cross(i,k) for (rg int i=first[k];i;i=last[i])
using namespace std;
il ll max(ll x,ll y){return x>y?x:y;}
il ll min(ll x,ll y){return x<y?x:y;}
il ll read(){
    ll x=0;int ch=getchar(),f=1;
    while (!isdigit(ch)&&(ch!='-')&&(ch!=EOF)) ch=getchar();
    if (ch=='-'){f=-1;ch=getchar();}
    while (isdigit(ch)){x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
    return x*f;
}
struct node{
    int l,r,v;
}a[N];
struct Node{
    int v,id;
    bool flag;
}c[N<<1];
int n,m,cnt,tot;
il bool cmp(node a,node b){return a.v<b.v;}
il bool Cmp(Node a,Node b){return a.v<b.v;}
il vd init(){
    n=read(),m=read();
    For(i,1,n) a[i].l=read(),a[i].r=read(),a[i].v=a[i].r-a[i].l;
    sort(a+1,a+1+n,cmp);
    For(i,1,n) c[++cnt]=(Node){a[i].l,i,0},c[++cnt]=(Node){a[i].r,i,1};
    sort(c+1,c+1+cnt,Cmp);
    c[0].v=-1;
    For(i,1,cnt){
        if (c[i].v!=c[i-1].v) tot++;
        c[i].flag?a[c[i].id].r=tot:a[c[i].id].l=tot;
    }
}

int v[N*2*8],lazy[N*2*8];
il vd push_down(int u){
    if (lazy[u]){
        lazy[u<<1]+=lazy[u],lazy[u<<1^1]+=lazy[u];
        v[u<<1]+=lazy[u],v[u<<1^1]+=lazy[u];
        lazy[u]=0;
    }
}
il vd update(int u,int l,int r,int ql,int qr,int x){
    if (l>=ql&&r<=qr){
        v[u]+=x,lazy[u]+=x;
        push_down(u);
        return;
    }
    int mid=l+r>>1;push_down(u);
    if (qr<=mid) update(u<<1,l,mid,ql,qr,x);
    else if (ql>mid) update(u<<1^1,mid+1,r,ql,qr,x);
    else update(u<<1,l,mid,ql,qr,x),update(u<<1^1,mid+1,r,ql,qr,x);
    v[u]=max(v[u<<1],v[u<<1^1]);
}

int l,r,mid,ans;
il bool check(int x){
    int last=1;
    For(i,1,n){
        while (a[i].v-a[last].v>x) update(1,1,tot,a[last].l,a[last].r,-1),last++;
        update(1,1,tot,a[i].l,a[i].r,1);
        if (v[1]>=m){
            For(j,last,i) update(1,1,tot,a[j].l,a[j].r,-1);
            return 1;
        }
    }
    For(i,last,n) update(1,1,tot,a[i].l,a[i].r,-1);
    return 0;
}
il vd Work(){
    l=0,r=a[n].v,ans=-1;
    while (l<=r){
        mid=l+r>>1;
        if (check(mid)) r=mid-1,ans=mid;
            else l=mid+1; 
    }
    printf("%d",ans);
}

int main(){
    init(),Work();
}
```

## 算法二

考虑怎么把外面那层二分去掉。

我们发现一个mid是否成立，即是否有一段编号连续的区间是否有个一点被至少m个区间覆盖。

那么我们依旧现在一个一个扫区间，记一个变量last表示当前在线段树里的是第last个区间到当前区间，然后就是不断判断当前是否有一个点至少被m个区间覆盖，再不断把编号为last的区间弹出线段树，在弹出过程中，取当前区间花费-last区间的花费的最小值就行了。

每个区间只会加入一次和弹出一次，所以复杂度是$O(n log n)$的。

预计得分:100

```
//by zykykyk
#include<cstdio>
#include<ctime>
#include<iostream>
#include<algorithm>
#include<cmath>
#include<string>
#include<cstring>
#define rg register
#define il inline
#define vd void
#define ll long long
#define N 500010
#define For(i,x,y) for (rg int i=(x);i<=(y);i++)
#define Dow(i,x,y) for (rg int i=(x);i>=(y);i--)
#define cross(i,k) for (rg int i=first[k];i;i=last[i])
using namespace std;
il ll max(ll x,ll y){return x>y?x:y;}
il ll min(ll x,ll y){return x<y?x:y;}
il ll read(){
    ll x=0;int ch=getchar(),f=1;
    while (!isdigit(ch)&&(ch!='-')&&(ch!=EOF)) ch=getchar();
    if (ch=='-'){f=-1;ch=getchar();}
    while (isdigit(ch)){x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
    return x*f;
}
struct node{
    int l,r,v;
}a[N];
struct Node{
    int v,id;
    bool flag;
}c[N<<1];
int n,m,cnt,tot;
il bool cmp(node a,node b){return a.v==b.v?a.l<b.l:a.v<b.v;}
il bool Cmp(Node a,Node b){return a.v<b.v;}
il vd init(){
    n=read(),m=read();
    For(i,1,n) a[i].l=read(),a[i].r=read(),a[i].v=a[i].r-a[i].l;
    sort(a+1,a+1+n,cmp);
    For(i,1,n) c[++cnt]=(Node){a[i].l,i,0},c[++cnt]=(Node){a[i].r,i,1};
    sort(c+1,c+1+cnt,Cmp);
    c[0].v=-1;
    For(i,1,cnt){
        if (c[i].v!=c[i-1].v) tot++;
        c[i].flag?a[c[i].id].r=tot:a[c[i].id].l=tot;
    }
}

int v[N*2*8],lazy[N*2*8];
il vd push_down(int u){
    if (lazy[u]){
        lazy[u<<1]+=lazy[u],lazy[u<<1^1]+=lazy[u];
        v[u<<1]+=lazy[u],v[u<<1^1]+=lazy[u];
        lazy[u]=0;
    }
}
il vd update(int u,int l,int r,int ql,int qr,int x){
    if (l>=ql&&r<=qr){
        v[u]+=x,lazy[u]+=x;
        push_down(u);
        return;
    }
    int mid=l+r>>1;push_down(u);
    if (qr<=mid) update(u<<1,l,mid,ql,qr,x);
    else if (ql>mid) update(u<<1^1,mid+1,r,ql,qr,x);
    else update(u<<1,l,mid,ql,qr,x),update(u<<1^1,mid+1,r,ql,qr,x);
    v[u]=max(v[u<<1],v[u<<1^1]);
}

int last,ans;
il vd Work(){
    last=1,ans=1e9;
    For(i,1,n){
    	update(1,1,tot,a[i].l,a[i].r,1);
    	while (v[1]>=m){
    		update(1,1,tot,a[last].l,a[last].r,-1);
            ans=min(ans,a[i].v-a[last].v),last++;
        }
    }
    if (ans==1e9) printf("-1");
    	else printf("%d",ans);
}

int main(){
    init(),Work();
}
```

---

## 作者：maowuyou (赞：5)

# **尺取法 + 线段树优化**
[题目传送器](https://www.luogu.org/problemnew/show/P1712)

------------
####  下面进入正题 ： 
         对前几个点 我们可以采用暴力枚举 选择区间的方案 暴力给每个点的权值+1 ， 
   时间复杂度为 O(2^n*(m/2*n+1)   )   ~~应该有错~~
   
 看起来这个算法很没用 ~~也的确很没用~~ 
 
####  但每一个成功的算法都是有一个不成功的代码优化而来

这个算法也有很大的优化空间 ：

1. 我们可以看到 时间复杂度 中 “2^n” 是一个很难受的项 

     我们首先考录消去它
     
     对此 ， 我们可以采用尺取法 ~~不知道尺取法的自行解决~~
     
     由于 每个区间对答案的贡献 仅与它的长度有关 ， 与其他一切无关
     
     所以 ， 我们可以 把每一个区间 按长度 进行排序
     
     这样的话 ， 我们就可以进行 尺取法 了
     
     设 “尺” 的左端点 为 L ，右端点 为 R 
     
     
    -  L  和 R 最初 都为 1 （假设我们选了长度最小的区间）
    - R 不断 向右 扩展 ， 每扩展一个区间 就把这个区间覆盖的点的点权+1，维护一个点权最大的点
    - 当   点权最大的点的点权>m 时 ， 更新答案 L++
    - 尺取法 到 R>n 时 结束
   
2. 暴力给 每一个点的点权+1 是很费时间的 ~~猪都知道~~

   我们可以用线段树来优化 
   
   线段树 在本题的优点 有两个方面：
   
           1. 加速 区间点权+1 （ 区间+ 操作）
           2. 维护 当前点权最大点 的 点权
   
   有了这线段树 ， 时间复杂度 就能 再 下降一个档次
   
   成为 我们可以接受 的 复杂度
   
## 讲得应该够清楚了  上代码！！！
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#define MAXN 500005
using namespace std;
int n,m,cnt,v[3*MAXN];
int ans=2100000000;
struct node
{
	int l,r,len;
}f[MAXN];
struct Tree
{
	int l,r;
	int val;
	int add;
}tree[10*MAXN];
bool cmp(const node k,const node t)
{
	return k.len<t.len;
}
void push(int now)
{
   tree[now*2].add+=tree[now].add;
   tree[now*2].val+=tree[now].add;
   tree[now*2+1].val+=tree[now].add;
   tree[now*2+1].add+=tree[now].add;
   tree[now].add=0;
}
void build(int l,int r,int now)
{
	tree[now].l=l;
	tree[now].r=r;
	tree[now].add=0;
	if (l==r)
	{
		tree[now].val=0;
		return;
	}
	int mid=(l+r)>>1;
	build(l,mid,now*2);
	build(mid+1,r,now*2+1);
	tree[now].val=max(tree[now*2].val,
                          tree[now*2+1].val);
	return;
}
void change(int now,int l,int r,int k)
{
    if(tree[now].l==l && tree[now].r==r)
    {
        tree[now].add+=k;
        tree[now].val+=k;
        return;
    }
    push(now);
    int mid=(tree[now].l+tree[now].r)>>1;
    if (r<=mid) change(now*2,l,r,k);
    if (l>mid) change(now*2+1,l,r,k);
    if (l<=mid && r>mid)
    {
    	change(now*2,l,mid,k);                                change(now*2+1,mid+1,r,k);
    }
    tree[now].val=max(tree[now*2].val,
                      tree[now*2+1].val);
}
int main()
{
	scanf("%d %d",&n,&m);
	for (int i=1;i<=n;i++)
	{
		scanf("%d %d",&f[i].l,&f[i].r);
		f[i].len=f[i].r-f[i].l+1;
		v[++cnt]=f[i].l;
		v[++cnt]=f[i].r;
	}
	sort(v+1,v+cnt+1);
	int x=unique(v+1,v+cnt+1)-(v+1);
	for (int i=1;i<=n;i++)
	{
	      f[i].l=lower_bound(v+1,v+x+1,f[i].l)-v;               f[i].r=lower_bound(v+1,v+x+1,f[i].r)-v;
	}
	build(1,x+100,1);
	sort(f+1,f+n+1,cmp);
	int now=1;
	for (int i=1;i<=n;i++)
	{
		change(1,f[i].l,f[i].r,1);
		while (tree[1].val>=m && now<=i) 
		{
		     ans=min(ans,f[i].len-f[now].len);
		     change(1,f[now].l,f[now].r,-1);		     now++;
		}
	}
	if (ans!=2100000000) printf("%d\n",ans);
        else puts("-1");
	return 0;
}
```

 

---

## 作者：LevenKoko (赞：4)

##[戳我获得更好观看效果](https://www.cnblogs.com/zhenglw/p/9519162.html)
这道题作为NOI的题目还算是~~比较水的~~（虽然是第一题） 
这道题是区间操作，~~不难看出~~可以用**线段树**做
##【思路分析】 
由于数据很大，我们先进行离散化，然后按区间长度排序并建一棵空树(维护当前区间重合部分最大值)
根据该线段树维护的结果 ，我们可以知道t[1].sum记录的是当前各条线段重合的最大值，只要t[1].sum大于m就符合题目要求了
接着我们采用尺取法,就是搞两个指针，**一部分**时间复杂度可以降到 O(n)并把总体时间复杂度从O(n^2) 降到了O(nlogn) 
在此基础上，我们来求最小花费,我们先将排序好的线段一段一段丢到线段树里，当t[i].sum>=m时，我们将从头开始一段一段删掉，直到不满足条件
在此操作同时，我们维护ans最小值 
具体见代码： 



```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define M 5000005
using namespace std;
inline int read(){
	char chr = getchar();	int f = 1,ans = 0;
	while(!isdigit(chr)) {if(chr == '-') f = -1;chr = getchar();}
	while(isdigit(chr))  {ans = ans * 10;ans += chr - '0';chr = getchar();}
	return ans* f ;
}
void write(int x){
	if(x < 0) putchar('-'),x=-x;
	if(x > 9) write(x / 10);
	putchar(x % 10 + '0');
}
int n,m,c[M<<2],tot=0;
struct segment{int l,r,len;}a[M<<2]; //输入信息
struct node{int l,r,sum,lazy;int mid(){return l + r >> 1;} }t[M<<2];//线段树信息
bool cmp(const segment &a,const segment &b){return a.len<b.len;	}//排序
void push_down(int i){//信息下传
	if(t[i].lazy){
		t[i << 1].lazy += t[i].lazy;
		t[i << 1 | 1].lazy += t[i].lazy;
		t[i << 1].sum += t[i].lazy;
		t[i << 1 | 1].sum += t[i].lazy;
		t[i].lazy = 0;
	}
}
void push_up(int i){//信息上传
	t[i].sum = max(t[i << 1].sum,t[i << 1 | 1].sum);
}
void build(int i,int l,int r){
	t[i].l = l, t[i].r = r;
	if(l == r)	return;
	int m = t[i].mid();
	build(i << 1,l,m);
	build(i << 1 | 1,m+1,r);
}//建树
void updata(int i,int l,int r, int v){
	if(l <= t[i].l && t[i].r <= r){	t[i].lazy += v;	t[i].sum += v;	return;	}
	int m = t[i].mid();
	push_down(i);
	if(l <= m) updata(i << 1, l, r, v);
	if(r > m)  updata(i << 1 | 1, l, r, v);
	push_up(i);
}//节点更新
int main(){	
	n = read();
	m = read();
	for(int i = 1;i <= n;i++)
		a[i].l = read(),a[i].r = read(),a[i].len = a[i].r-a[i].l,c[++tot] = a[i].l,c[++tot] = a[i].r,c[++tot] = a[i].r + 1;
	sort(a + 1,a + n + 1,cmp);	sort(c + 1,c + tot + 1);	tot=unique(c + 1,c + tot + 1) - c - 1;//去重 
	int minl = 0x3f3f3f3f,maxr = -0x3f3f3f3f;
	for(int i = 1;i <=n ;i++)
		a[i].l = lower_bound(c + 1,c + tot + 1 ,a[i].l) -c,minl = min(minl,a[i].l),
		a[i].r = lower_bound(c + 1,c + tot+ 1 ,a[i].r) -c,maxr = max(maxr,a[i].r);
		//阶段1、读入、排序处理、离散化	
	int l = 1,ans = 0x3f3f3f3f;
	build(1,minl,maxr);
	for(int i = 1 ;i <= n;i++){
        updata(1, a[i].l, a[i].r, 1);
        while(t[1].sum >= m){
            ans=min(a[i].len - a[l].len,ans);
            updata(1, a[l].l, a[l].r, -1);        
            l++;
        }
    }//阶段2 尺取法求出最小花费
    if(ans == 0x3f3f3f3f) write(-1);
    else	write(ans);//输出
	return 0;
}
```

---

## 作者：yqbylty (赞：3)

首先看看暴力分，我们最简单的想法就是将所有点被覆盖的次数统计出来，然后将所有出现次数$\ge m$的点都拿出来，然后枚举这些点。对于每一个点，我们将所有覆盖了他的区间都找出来，然后排一下序。那么显然，连续的一段它的差值最小。那么我们只需要枚举这连续的一段区间开始的那一个区间取哪一个就好了，然后更新答案。然后显然我们之前统计一个点被覆盖的次数我们可以用差分来解决。

~~虽然我不知道为啥是45pts~~

**Code:**

```cpp
/*Program from Luvwgyx*/
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ll long long
using namespace std;
const int inf=1e9;
const int maxn=5e5+10;
struct node{int x,y,len;}a[maxn],q[maxn];
int tot,cnt,pos[maxn],sum[maxn];
int read(){
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
void print(int x){
    if(x<0)putchar('-'),x=-x;
    if(x>9)print(x/10);
    putchar(x%10+'0');
}
void write(int x){print(x);puts("");}
bool cmp(node x,node y){return x.len==y.len?x.x==y.x?x.y<y.y:x.x<y.x:x.len<y.len;}
int main(){
    int n=read(),m=read(),ans=inf;
    for(int i=1;i<=n;i++){
        a[i].x=read(),a[i].y=read();a[i].len=a[i].y-a[i].x;
        sum[a[i].x]++;sum[a[i].y+1]--;
    }for(int i=1;i<=100000;i++)sum[i]+=sum[i-1];
    for(int i=1;i<=100000;i++)if(sum[i]>=m)pos[++tot]=i;
    if(!tot){puts("-1");return 0;}
    for(int i=1;i<=tot;i++){
        cnt=0;
        for(int j=1;j<=n;j++)if(a[j].x<=pos[i]&&pos[i]<=a[j].y)q[++cnt]=a[j];
        sort(q+1,q+cnt+1,cmp);
        for(int j=1;j<=cnt-m;j++)ans=min(ans,q[j+m-1].len-q[j].len);
    }write(ans);
    return 0;
}
```

我们看完部分分之后，发现我们复杂度上的局限就在于找出我们满足条件的线段上面。我们发现，我们在枚举连续$m$条线段的时候，其实中间有一大段是没有变化的。所以我们实际上可以用一个支持快速添加删除的数据结构来完成这个操作。所以我们用一个线段树，将这些线段存下来就好了，枚举的过程中加点，然后用一个指针从左往右指来删除点，当然建线段树是要离散化的...

具体看代码吧...

**Code:**

```cpp
/*Program from Luvwgyx*/
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int inf=1e9;
const int maxn=5e5+10;
int tot,link[maxn<<1];
struct node{int x,y,len;}a[maxn];
int read(){
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
void print(int x){
    if(x<0)putchar('-'),x=-x;
    if(x>9)print(x/10);
    putchar(x%10+'0');
}
void write(int x){print(x);puts("");}
struct Segment_Tree{
    struct Seg{int w,f;}tree[maxn<<3];
    void down(int k){
        if(tree[k].f){
            tree[k<<1].w+=tree[k].f;tree[k<<1|1].w+=tree[k].f;
            tree[k<<1].f+=tree[k].f;tree[k<<1|1].f+=tree[k].f;
            tree[k].f=0;
        }
    }
    void update(int k){tree[k].w=max(tree[k<<1].w,tree[k<<1|1].w);}
    void change(int k,int l,int r,int x,int y,int v){
        if(x<=l&&r<=y){tree[k].w+=v;tree[k].f+=v;return ;}
        down(k);int mid=(l+r)>>1;
        if(x<=mid)change(k<<1,l,mid,x,y,v);
        if(mid<y)change(k<<1|1,mid+1,r,x,y,v);
        update(k);
    }
}T;
bool cmp(node x,node y){return x.len<y.len;}
int main(){
    int n=read(),m=read();
    for(int i=1;i<=n;i++){
        a[i].x=read();a[i].y=read();
        a[i].len=(a[i].y-a[i].x+1);
        link[++tot]=a[i].x;link[++tot]=a[i].y;
    }sort(a+1,a+n+1,cmp);sort(link+1,link+tot+1);
    tot=unique(link+1,link+tot+1)-link-1;int l=inf,r=0;
    for(int i=1;i<=n;i++){
        a[i].x=lower_bound(link+1,link+tot+1,a[i].x)-link;
        a[i].y=lower_bound(link+1,link+tot+1,a[i].y)-link;
        l=min(l,a[i].x);r=max(r,a[i].y);
    }int ans=inf,now=1;
    for(int i=1;i<=n;i++){
        T.change(1,l,r,a[i].x,a[i].y,1);
        while(T.tree[1].w>=m){
            ans=min(ans,a[i].len-a[now].len);
            T.change(1,l,r,a[now].x,a[now].y,-1);
            now++;
        }
    }if(ans==inf)puts("-1");else write(ans);
    return 0;
}
```

---

## 作者：asuldb (赞：3)

发现自己的离散化姿势一直有问题

今天终于掌握了正确的姿势

~~虽然这并不能阻挡我noip退役爆零的历史进程~~

还是先来看看离散化怎么写吧，我以前都是这么写的

```
for(std::set<int>::iterator it=s.begin();it!=s.end();it++)
	ma[*it]=++tot;
```

这是使用$set+map$的离散化，但是显然巨大的常数是极大的劣势

正确的操作应该是这个样子

```cpp
std::sort(a+1,a+n+1)
int tot=unique(a+1,a+n+1)-a-1;
for(re int i=1;i<=tot;i++)
	ma[a[i]]=i;
```

$unique$能将一个有序数组去重，返回值是去重之后的尾地址，减去首地址就可以得到去重之后的数量了

之后再来看这道题，也是一道非常神的题

这道题告诉我们暴力通向错误的解，错误的解往往跟正解很接近了

首先$O(n^2logn)$还是比较好想的做法，我们**先将所有的区间按照长度排序**，之后我们**定住一个区间作为长度最小的区间**，强行套用线段树暴力覆盖之后的比它大的区间，直到这个区间有一个点被覆盖了$m$次，那么最后覆盖上去的区间的长度减去定住的最小值就是答案了

对所有的答案取一个$min$就好了

这样是显然不行的呀，我们得想个办法

于是我就想出来一种显然错误的做法

我大胆的猜测答案是单调的

~~少年谁给你的勇气~~

于是这个显然错误的做法是这样的，先将最短的区间一直覆盖，直到覆盖到符合条件为止，之后由于所谓的"答案单调"，那么使下一个次短的区间符合条件的区间一定在前面的答案的后面

这样的复杂度均摊下来是对的

答案单调很有道理，但是凉凉了

很容易就能找到反例了

我们再覆盖第一个最短的区间的时候，由于我们只是在判断最短的区间是否满足条件，所以可能这个时候之后的某个区间就突然满足条件了，所以这个答案显然不是单调的

但是这个错误的思路和正解已经非常接近了，差别只有一点，**我们判断的时候判断的不是最短的区间是否符合条件，而是判断整个区间内是否有点被覆盖了$m$次**

这有什么道理呢，其实联想一下尺取法，和尺取法差不多

我们从最短的区间开始覆盖，可能覆盖的过程中满足条件的点并没有来自当前的区间，但是没有关系，我们直接用当前的区间作为最小的区间就行了，这样显然只会导致答案偏大，而真正的最小区间我们在后面也会取到

代码
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cstring>
#include<set>
#include<algorithm>
#include<map>
#define maxn 500005
#define re register
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
std::set<int> s;
std::map<int,int> ma;
struct node
{
	int ll,rr,len;
	int L,R;
}a[maxn];
int b[maxn<<1];
int n,m,N;
int ans=19999999999;
int l[4000005],r[4000005],d[4000005],tag[4000005];
inline int read()
{
	char c=getchar();
	int x=0;
	while(c<'0'||c>'9') c=getchar();
	while(c>='0'&&c<='9')
	  x=(x<<3)+(x<<1)+c-48,c=getchar();
	return x;
}
inline int cmp(node K,node M)
{
	return K.len<M.len;
}
void build(int x,int y,int i)
{
	l[i]=x;
	r[i]=y;
	if(x==y) return;
	int mid=x+y>>1;
	build(x,mid,i<<1),build(mid+1,y,i<<1|1);
}
inline void pushdown(int i)
{
	if(!tag[i]) return;
	tag[i<<1]+=tag[i];
	tag[i<<1|1]+=tag[i];
	d[i<<1|1]+=tag[i];
	d[i<<1]+=tag[i];
	tag[i]=0;
}
void change(int x,int y,int v,int i)
{
	if(x<=l[i]&&y>=r[i])
	{
		d[i]+=v;
		tag[i]+=v;
		return;
	}
	pushdown(i);
	int mid=l[i]+r[i]>>1;
	if(y<=mid) change(x,y,v,i<<1);
	else if(x>mid) change(x,y,v,i<<1|1);
	else change(x,y,v,i<<1),change(x,y,v,i<<1|1);
	d[i]=max(d[i<<1],d[i<<1|1]);
}
int main()
{
	n=read();
	m=read();
	for(re int i=1;i<=n;i++)
		a[i].ll=read(),a[i].rr=read(),a[i].len=a[i].rr-a[i].ll,b[++N]=a[i].ll,b[++N]=a[i].rr;
	std::sort(a+1,a+n+1,cmp);
	std::sort(b+1,b+N+1);
	int tot=std::unique(b+1,b+N+1)-b-1;
	for(re int i=1;i<=tot;i++)
		ma[b[i]]=i;
	build(1,tot,1);
	for(re int i=1;i<=n;i++) a[i].L=ma[a[i].ll],a[i].R=ma[a[i].rr];
	int now=-1;
	for(re int i=1;i<=n;i++)
	{
		change(a[i].L,a[i].R,1,1);
		if(d[1]==m)
		{
			ans=a[i].len-a[1].len;
			now=i;
			break;
		}
	}
	if(now==-1)
	{
		puts("-1");
		return 0;
	}
	for(re int i=2;i<=n;i++)
	{
		change(a[i-1].L,a[i-1].R,-1,1);
		while(d[1]<m) 
		{
			if(now==n) 
			{
				printf("%d\n",ans);
				return 0;
			} 
			now++;
			change(a[now].L,a[now].R,1,1);
		}
		ans=min(ans,a[now].len-a[i].len);
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：cirnovsky (赞：2)

## 题意简述

题意已经很清楚了，就不再说了

## 题解

我们首先考虑怎么去选择这 $M$ 个区间才能使得最终的花费最小。

不难想到我们需要尽量选择 **长度尽量靠近** 的 $M$ 个区间，换句话说就是我们需要按照区间的长度进行排序。

原因很显然，我们如果选择的区间的长度不靠近，那么就会造成最小的区间长度变小，最大的区间长度变大。然而答案就是长度最大的区间和长度最小的区间，所以我们需要让这两个区间的长度尽量靠近。

排完序后我们就依次把每个区间加入到答案所在的集合里。

具体来说就是维护一个数组 $A$，每当我们加入一个区间 $[l_{i},r_{i}]$，就令 $A_{l_{i}},A_{l_{i}+1},\cdots,A_{r_{i}}$ 全部加一。如果存在某一个 $A_{p}$ 使得 $M\le A_{p}$，我们就更新答案，并且删除最先加入进来的区间，也就是令 $A_{l_{i}},A_{l_{i}+1},\cdots,A_{r_{i}}$ 全部减一。

一些细节：

1. 要离散化（废话

2. 线段树开8倍（每个区间有两个端点

3. 没了

##### [悄悄安利博客](http://boringhacker.github.io/)

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <queue>

using namespace std;

const int SIZE = 500000 + 5;
int MAX[SIZE << 3];
int mark[SIZE << 3];
vector < int > disc;
int n, m, holyans = -1;
struct interval {
	int l, r;
	int len;
	interval(){}
	interval(int L, int R, int S) : l(L), r(R), len(S){}
	bool operator < (const interval& rhs) const {
		return len < rhs.len;
	}
} seg[SIZE];
#define ls (k << 1)
#define rs (k << 1 | 1)
#define mid ((l + r) >> 1)

#define pushdown(k) 			\
	if (mark[k]) {				\
		MAX[ls] += mark[k];		\
		MAX[rs] += mark[k];		\
		mark[ls] += mark[k];	\
		mark[rs] += mark[k];	\
		mark[k] = 0;			\
	}

#define pushup(k) MAX[k] = max(MAX[ls], MAX[rs])
#define GetID(x) (lower_bound(disc.begin(), disc.end(), x) - disc.begin() + 1)

void modify(int k, int l, int r, int x, int y, int v) {
	if (l >= x && r <= y) mark[k] += v, MAX[k] += v;
	else {
		pushdown(k);
		if (mid >= x) modify(ls, l, mid, x, y, v);
		if (mid < y) modify(rs, mid + 1, r, x, y, v);
		pushup(k);
	}
}

void discretization() {
	for (int i = 1; i <= n; ++i) disc.push_back(seg[i].l), disc.push_back(seg[i].r);
	sort(disc.begin(), disc.end());
	sort(seg + 1, seg + 1 + n);
	disc.erase(unique(disc.begin(), disc.end()), disc.end());
	for (int i = 1; i <= n; ++i) seg[i].l = GetID(seg[i].l), seg[i].r = GetID(seg[i].r);
}

signed main() {
	scanf("%d %d", &n, &m);
	for (int i = 1, x, y; i <= n; ++i) scanf("%d %d", &x, &y), seg[i] = interval(x, y, y - x + 1);
	discretization();
	int size = disc.size();
	int max_id = n;
	for (int i = n; i >= 1; --i) {
		while (MAX[1] >= m && max_id > i) {
			modify(1, 1, size, seg[max_id].l, seg[max_id].r, -1);
			--max_id;
			if (MAX[1] >= m) {
				if (~holyans) holyans = min(holyans, seg[max_id].len - seg[i].len);
				else holyans = seg[max_id].len - seg[i].len;
			}
		}
		modify(1, 1, size, seg[i].l, seg[i].r, 1);
		if (MAX[1] >= m) {
			if (~holyans) holyans = min(holyans, seg[max_id].len - seg[i].len);
			else holyans = seg[max_id].len - seg[i].len;
		}
	}
	printf("%d\n", holyans);
	return 0;
}
```

---

## 作者：Randyhoads (赞：2)

[题目链接](https://www.luogu.org/problemnew/show/P1712)

### 题目大意：
	给你N个区间，选出M个，
    使这m个区间共同包含至少一个位置，且使里面区间长度最长减	
    区间长度最短最小


### solution:

线段树 + 尺取法

首先很容易想到对于这个区间覆盖了，就是让区间中的每个点加1，那就是线段树，维护区间最大值

那么这时候就有一个问题：就是区间末尾可能很大。

这个时候就要用到离散化：

显然这道题只关心区间的长度，和区间之间的相互包含关系。因此可以预先把长度记录下来，把出现过的数按数值排序。
注意重复的数。。。
```cpp
	for(int i=1;i<=n;i++)
	{
		l[i]=read(),r[i]=read();
		s[i].len=r[i]-l[i];s[i].num=i;//记录长度 
		++cnt;
		b[cnt].num=i;b[cnt].val=l[i];b[cnt].bz=0;
		++cnt;
		b[cnt].num=i;b[cnt].val=r[i];b[cnt].bz=1;
	}
	sort(b+1,b+cnt+1);//离散化
	int q=0;
	for(int i=1;i<=cnt;i++)
	{
		if(b[i].val!=b[i-1].val) q++;//如果有重复得要										赋成一个值
		if(b[i].bz==0)
		l[b[i].num]=q;
		else
		r[b[i].num]=q;
	}
    for(int i=1;i<=n;i++)
	{
		s[i].l=l[s[i].num];
		s[i].r=r[s[i].num];
	}//最后代回去
```

离散化完了，接下来怎么做？
这个时候如果当前的最大值小于了M，显然我们需要多加区间，而已经大于了，我们可以尝试减少区间来实现更有的解。
显然这和尺取法的思想一样，即选取区间有一定规律，或者说所选取的区间有一定的变化趋势的情况时，步步推进，放缩。。。

然后发现我们要维护最小长度，显然就按长度排序，再尺取法。。
减区间时线段树维护区间-1，加区间时维护区间+1，最后直接查询树顶。。。

先上代码
```cpp
#include<bits/stdc++.h>

using namespace std;

const int MAXN = 500000 +10;

const int inf = 1<<30;

inline long long read()
{
    int f=1,x=0;
    char ch;
    do
    {
        ch=getchar();
        if(ch=='-') f=-1;
    }while(ch<'0'||ch>'9');
    do
    {
        x=(x<<1)+(x<<3)+ch-'0';
        ch=getchar();
    }while(ch>='0'&&ch<='9');
    return f*x;
}

inline int Max(int a,int b)
{
	if(a>=b) return a;
	else return b; 
}

int n,m;

int l[MAXN],r[MAXN];

struct stick
{
	int len;
	int l;
	int r;
	int num;
	friend bool operator < (stick a1,stick a2)
	{
		return a1.len<a2.len;
	}
}s[MAXN*4]; 

struct node
{
	int num;
	int val;
	bool bz;
	friend bool operator < (node a1,node a2)
	{
		return a1.val<a2.val;
	}
};

int cnt =0;

node b[MAXN*4];

struct stree
{
	int l;
	int r;
	int maxv;
	inline int mid()
	{
		return (l+r)>>1;
	}
}tree[MAXN * 8];

#define lc o<<1
#define rc o<<1|1 

inline void build(int o,int l,int r)
{
	tree[o].l=l,tree[o].r=r;
	if(l==r) tree[o].maxv=0;
	else
	{
		int mid=tree[o].mid();
		build(lc,l,mid);
		build(rc,mid+1,r);
		tree[o].maxv=Max(tree[lc].maxv,tree[rc].maxv);
		return;
	}
} 

int add[MAXN * 8];

inline void pushup(int o)
{
	add[lc]+=add[o];
	add[rc]+=add[o];
	tree[lc].maxv+=add[o];
	tree[rc].maxv+=add[o];
	add[o]=0;
}

inline void update(int o,int x,int y,int w)
{
	int l=tree[o].l,r=tree[o].r;
	if(r<x||l>y) return;
	if(x<=l&&y>=r)
	{
		add[o]+=w;
		tree[o].maxv+=w;
		return;
	}
	else
	{
		pushup(o);
		update(lc,x,y,w);
		update(rc,x,y,w);
		tree[o].maxv=Max(tree[lc].maxv,tree[rc].maxv);
	}
}

int ans=1<<30;

int main()
{
	n=read();m=read();
	for(int i=1;i<=n;i++)
	{
		l[i]=read(),r[i]=read();
		s[i].len=r[i]-l[i];s[i].num=i; 
		++cnt;
		b[cnt].num=i;b[cnt].val=l[i];b[cnt].bz=0;
		++cnt;
		b[cnt].num=i;b[cnt].val=r[i];b[cnt].bz=1;
	}
	sort(b+1,b+cnt+1);
	int q=0;
	for(int i=1;i<=cnt;i++)
	{
		if(b[i].val!=b[i-1].val) q++;
		if(b[i].bz==0)
		l[b[i].num]=q;
		else
		r[b[i].num]=q;
	}
	for(int i=1;i<=n;i++)
	{
		s[i].l=l[s[i].num];
		s[i].r=r[s[i].num];
	}
	build(1,1,q);
	sort(s+1,s+n+1);
	int li=0,ri=0;
	while(1)
	{
		while(tree[1].maxv<m&&ri<=n)
		{
			ri++; 
			update(1,s[ri].l,s[ri].r,1);
		}
		if(tree[1].maxv<m) break;
		while(tree[1].maxv>=m&&li<=ri)
		{
			li++; 
			update(1,s[li].l,s[li].r,-1);
		
		} 
			ans=min(ans,s[ri].len-s[li].len);
	}
	if(ans==inf)
	{
		printf("-1");
		return 0;
	}
	printf("%d\n",ans);
}
```

### 彩蛋

1.第一次写的时候把建树的一个L写成了1...
然后全RE，然后非常智障的认为是数组开小了，然后非常智障的又交了几次。。。
2.第二个错是离散化后忘了这一步。。。
```cpp
	for(int i=1;i<=n;i++)
	{
		s[i].l=l[s[i].num];
		s[i].r=r[s[i].num];
	}
```
3.有一次在考试时做过这道题，当时很naive的写的纯模拟，因为根本没想到用线段树，然后模拟加树状数组拿了50分，其他人都拿了60分QwQ
模拟代码
```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>


using namespace std;

const int inf = 1<<30;

int n,m;

struct node
{
    int l,r;
    inline friend bool operator < (node a,node b)
    {
        return a.l<b.l;
        }
};node t[100000+ 10];

inline int read()
{
    int f=1,x=0;
    char ch;
    do
    {
        ch=getchar();
        if(ch=='-') f=-1;
    }while(ch<'0'||ch>'9');
    do
    {
        
        x=(x<<3)+(x<<1)+ch-'0';
        ch=getchar();
    }while(ch>='0'&&ch<='9');
    return f*x;
}

int minn,maxn;
int ans=inf;

int b[500010];

int c[500001];
int lb(int x){return x&-x;};
inline void change(int a,int b)
{
    if(a)
    { 
    while(a<=maxn)
    {
        c[a]+=b;
        a+=lb(a);
    }
    }
}
inline int g_sum(int x)
{
    int re=0;
    while(x>=1)
    {
        re+=c[x];
        x-=lb(x);
    }
    return re;
}

bool boo;

int main()
{
    n=read();
    minn=inf;
    m=read();
    for(int i=1;i<=n;i++)
    {
        t[i].l=read(),t[i].r=read();
        minn=min(minn,t[i].l);
        maxn=max(maxn,t[i].r);
        change(t[i].l,1);
        change(t[i].r+1,-1);
    }
    sort(t+1,t+n+1);
    for(register int i=minn;i<=maxn;i++)
    {
        if(g_sum(i)>=m)
        {
            boo=true;
        int num=0;
        int maxx=0,minx=inf;
        for(register int j=1;j<=n;j++)
        {
            if(i>=t[j].l&&i<=t[j].r)
            {
                num++;
            //	cout<<b[num]<<endl;
                b[num]=t[j].r-t[j].l;
            }
            if(t[j].l>i) break;
        }
        
    
            sort(b+1,b+num+1);
            int xiao = inf;
            for(register int i=1;i<=num-m+1;i++)
            {
                if(b[i+m-1]-b[i]<xiao)
                    xiao=b[i+m-1]-b[i];
            }
            ans=min(ans,xiao);
        /*	for(int i=1;i<=num;i++)
            {
                cout<<b[i]<<" "<<endl;
            }*/
    
    }
    }
    if(ans!=inf)
    cout<<ans<<endl;
    else cout<<-1<<endl;
}

```
尺取法题目：POJ 3061


---

## 作者：kczno1 (赞：2)

假如答案是长度l-r，我们不妨贪心地认为所有长度l-r之间都加入了选择。

所以按长度排序后用双指针来做，用线段树维护当前最大。

而我最想说的是

zkw是解决 区间加 与 可自下向上的维护的值(这题是最大) 的利器！

可见代码add部分，自己画一下图就能懂。


```cpp
#include<bits/stdc++.h>
using namespace std;

int max(int x,int y)
{
    return x>y?x:y;
}
void chmin(int &x,int y)
{
    if (x>y) x=y;
}

#define N (500000+5)
struct ZKW
{
    int a,max;
    void add(int w)
    {
        a+=w;max+=w;
    }
};
ZKW a[N*2*3];int d;
//因为c++位运算的运算符优先级太低，都要打括号，麻烦而且易错。所以我都用define来代替
#define FL (l>>1)//爸爸
#define SL (l^1)//兄弟
#define DL (l&1)//是右儿子or左
#define FR (r>>1)
#define SR (r^1)
#define DR (r&1)
void add(int l,int r,int w)
{
    l+=d;r+=d;
    a[l].add(w);
    if (l!=r)
    {
        a[r].add(w);
        while (SL!=r)
        {
            if (!DL) a[SL].add(w);
            if (DR)  a[SR].add(w);
            a[FL].max=max(a[l].max,a[SL].max)+a[FL].a;
            a[FR].max=max(a[r].max,a[SR].max)+a[FR].a;
            l=FL;r=FR;
        }
    }
    while (FL)
    {
      a[FL].max=max(a[l].max,a[SL].max)+a[FL].a;
      l=FL;
    }
}

struct segment
{
    int l,r,len;
};
segment s[N];
bool len_xiao(const segment &x,const segment &y)
{
    return x.len<y.len;
}

int *dy[N<<1],k,top,now;
bool xiao(const int *x,const int *y)
{
    return *x<*y;
}

int main()
{ freopen("1.in","r",stdin);
    int n,m;
    scanf("%d%d",&n,&m);
    int i;
    for (i=1;i<=n;++i) 
    {
        scanf("%d%d",&s[i].l,&s[i].r);
        s[i].len=s[i].r-s[i].l;
        dy[++k]=&s[i].l;dy[++k]=&s[i].r;
    }
    
    sort(dy+1,dy+k+1,xiao);
    now=*dy[1];top=*dy[1]=1;
    for (i=2;i<=k;++i)
    {
        if (*dy[i]>now) {now=*dy[i];++top; }
        *dy[i]=top;
    }
    for (d=1;d<top;d<<=1);d-=1;
    
    sort(s+1,s+n+1,len_xiao);
    int l=0,r=1,ans=1<<30;//l是已经减了的，r是已经加了的
    add(s[1].l,s[1].r,1);
    while (r<=n)
    {
        while (a[1].max<m&&r<n) {++r;add(s[r].l,s[r].r,1);}
        if (a[1].max<m) break;
        while (a[1].max>=m) {++l;add(s[l].l,s[l].r,-1);}
        chmin(ans,s[r].len-s[l].len);
    }
    
    if (ans==1<<30) printf("%d",-1);
    else printf("%d",ans);
}
```

---

## 作者：Ccliang (赞：2)

其实已经有很多人都写了这道题目的题解，并且思路都差不多，但是此题是我为数不多没看题解做出的紫题，所以还是写了这篇题解。

------------


这道题目的关键在于想清楚怎样的 M 个区间覆盖花费是最小的。

而且很明显这个花费只和这 M 个区间中长度最大和最小的区间有关。

可以想象一下，如果我们有很多个区间，要在其中选 M 个使区间长度的最大值和最小值的差最小，我们肯定会选出长度排名连续的 M 个。因为如果不是连续的话，肯定会让最小值更小或最大值更大。

所以我们可以先把这 N 个区间按区间长度从大到小排序，而且因为 l 和 r 比较大，在排完序之后还要对它进行离散化。

然后我们就可以一个个地将区间覆盖上去，当有一个点被覆盖了 M 次，就更新答案，并将最先覆盖的区间消除。

这个很明显可以用线段树来维护，维护一个区间最大值，而且只有区间修改的操作，覆盖时在该区间整体 +1，消除一个区间时在该区间整体 -1 ，询问最大覆盖次数只要询问线段树的根节点就可以了。

其中还会有一些细节的问题，比如说：

- 线段树数组的空间要开 N 的 8 倍。

- 修改时区间应该是 [ 1 , 2*n ] ，而不是 [ 1 , n ]。

- 区间长度要在离散化之前就计算好

具体实现细节可以看我的代码：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int N = 500000 + 10;
const int M = 200000 + 10;

inline int read()
{
	int res=0;
	char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')res=(res<<1)+(res<<3)+(ch^48),ch=getchar();
	return res;
}

struct section{
	int l,r,len;
	bool operator <(const section x)const
	{
		return len<x.len;
	}
}sec[N];

struct Tree{
	int max,lazy;
}t[N<<3];
#define lson pos<<1
#define rson pos<<1|1
#define mid ((l+r)>>1)	
void pushdown(int pos)
{
	if(!t[pos].lazy)
		return ;
	t[lson].max+=t[pos].lazy;
	t[rson].max+=t[pos].lazy;
	t[lson].lazy+=t[pos].lazy;
	t[rson].lazy+=t[pos].lazy;
	t[pos].lazy=0;
}
#define max(x,y) (x)>(y)?(x):(y)
#define min(x,y) (y==-1)?(x):((x)<(y)?(x):(y))
void change(int pos,int l,int r,int L,int R,int k)
{
	if(l>=L&&r<=R)
	{
		t[pos].lazy+=k,t[pos].max+=k;
		return ;
	}
	pushdown(pos);
	if(L<=mid)
		change(lson,l,mid,L,R,k);
	if(R>mid)
		change(rson,mid+1,r,L,R,k);
	t[pos].max=max(t[lson].max,t[rson].max);
}

int n,m,a[N<<1],cnt,tt,ans=-1;

int main()
{
	n=read(),m=read();
	for(int i=1,l,r;i<=n;i++)
		l=read(),r=read(),sec[i]=(section){l,r,r-l+1},a[++cnt]=l,a[++cnt]=r;
	sort(a+1,a+cnt+1),sort(sec+1,sec+n+1);
	for(int i=1;i<=n;i++)
		sec[i].l=lower_bound(a+1,a+cnt+1,sec[i].l)-a,
		sec[i].r=lower_bound(a+1,a+cnt+1,sec[i].r)-a;//将区间离散化
	tt=n;//tt记录当前选择的区间中最先覆盖的区间编号，也就是区间长度最大的
	for(int i=n;i>=1;i--)
	{
		while(t[1].max>=m&&tt>i)
		{
			change(1,1,cnt,sec[tt].l,sec[tt].r,-1),tt--;
			if(t[1].max>=m)
				ans=min(sec[tt].len-sec[i].len,ans);
		}
		change(1,1,cnt,sec[i].l,sec[i].r,1);
		if(t[1].max>=m)
			ans=min(sec[tt].len-sec[i].len,ans);//这是宏定义下的 min
	}
	printf("%d\n",ans);
	return 0;
}
```


---


# [TOIP 2023] 公路

## 题目描述

某国的公路网由 $n$ 个城镇（编号 $1\sim n$）和 $m$ 条连接两个相异城镇的双向公路组成，每条公路有其长度，以公里表示。最近该国流行起电动车，但是公路之间都没有充电站，电动车只能在城镇充电。该国交通部门官员十分担心有些被观光局规划好的旅程会使电动车的续航力没办法走完一条公路，也因此，官员希望旅程中使用到的最长公路长度要尽量短，否则若有些电动车的实际续航力低于一段公路的长度，它们一定会在公路中间没电。

对于一趟被规划好的旅程，观光局会为其决定好一个起点 $u$ 和终点 $v$，并找出 $\textbf{两条}$ 由 $u$ 到 $v$ $\textbf{公路相互不重复}$ 的路径，来作为一个完整的旅程规划。例如下图是一个 $n=7$、$m=9$ 的例子，点上标示城镇的编号，边上标示公路的长度。

![](https://cdn.luogu.com.cn/upload/image_hosting/cugaijat.png)

若要规划城镇 $1$ 到城镇 $2$ 的旅程，可以采用以下两条路径：

- $1\to 2$ 以及 $1\to 3\to 2$

这两条路径中，所使用到的最长公路长度是 $8$ 公里，但若采用以下两条路径：

- $1\to 2$ 以及 $1\to 3\to 5\to 2$

就可以将使用的最长公路长度降低至 $5$，也是使最长公路最短的选择方式。而若要规划城镇 $1$ 到城镇 $6$ 的旅程，可以采用以下两条路径：

- $1\to 3\to 6$ 以及 $1\to 2\to 5\to 3\to 4\to 6$

使用的最长公路长度是 $7$，同时也是使最长公路最短的选择方式，注意到虽然这两条路径共用了同一个城镇 $3$，但条件只要求“使用的公路不重复”，因此为一种满足条件的路径选择方式。

一个旅程的两条路径所使用的最长公路愈短，则该旅程愈佳。今给定 $q$ 对起终点，请写程序计算每对起终点之最佳旅程使用到的最长公路长度，或者回报不存在任何一种路径的选择方式。


## 说明/提示

### 数据限制

* $2 \le n \le 1000$。
* $n - 1 \le m \le \displaystyle\frac{n\times (n-1)}{2}$。
* $1 \le a_i, b_i \le n$，$a_i \ne b_i$。
* $1 \le l_i \le 10^9$。
* 不会有两条公路连接着相同的一组城镇。
* $1 \le q \le 5\times 10^5$。
* $1 \le u_i, v_i \le n$，$u_i \ne v_i$。
* 输入的数皆为整数。
* 保证任两个城镇可以通过若干条公路直接或间接抵达。

### 评分说明

本题共有四组子任务，条件限制如下所示。每一组可有一或多个测试数据，该组所有测试数据皆需答对才会获得该组分数。

|  子任务  |  分数  | 额外输入限制 |
| :------: | :----: | ------------ |
| 1 | $18$ | $n \le 100$，$m, q \le 300$，$l_i = 1$ |
| 2 | $31$ | $n \le 500$，$m, q \le 1000$ |
| 3 | $22$ | $m\le 3000$ |
| 4 | $29$ | 无额外限制 |

## 样例 #1

### 输入

```
7 9
1 2 5
1 3 3
2 3 8
2 5 3
3 4 3
3 5 4
3 6 2
4 6 7
6 7 6
3
1 2
1 6
3 7```

### 输出

```
5
7
-1```

# 题解

## 作者：MaxFwl (赞：7)

先考虑如何判是否有解，只需要提前处理出每一个边双连通分量即可，复杂度 $O(m)$。

于是我们只需要求出每一个在同一个边双连通分量的点对的对应答案，可以把一张图分成若干个边双连通分量，在这些分量中求解答案。

考虑到边双连通分量的性质不够优秀，综合题意，我们考虑建出它的 MST。

对于不在 MST 上的边，我们按边权从小到大加入，每次找到新的满足要求的点对，我们发现所有新点对一定在该边的两端在 MST 上的路径上经过的边双连通分量中，并且这些边双连通分量会形成一个新的边双连通分量。

我们使用并查集维护每一个形成的边双连通分量，用 `vector` 存下每一个双连通分量中包含的点集，合并时暴力合并 `vector` 即可。

我们来分析复杂度，建 MST 的复杂度是 $O(m \log{m})$ 的，向上合并 `vector` 是 $O(n^2)$ 的，因为每个点最多向上合并 $O(n)$ 次，求解答案的复杂度也是 $O(n^2)$ 的，因为每个有解的点对只需要一次赋值操作。

总复杂度 $O(m \log{m} + n^2)$，作者在实现时使用了启发式合并，不过只有常数上的影响，[code。](https://www.luogu.me/paste/lfznj1qf#)

---

## 作者：D0000 (赞：2)

首先有解显然两个点 $u,v$ 需要在一个边双联通分量内。

考虑答案能否 $\le X$ 就是判断把所有小于等于 $X$ 的边拿出来建图能否使 $u,v$ 在同一个边双。那么想到按边权从小往大加边，询问就变成了第一次让 $u,v$ 在一个点双时加的边。

可以先跑出最小生成树，再从小往大加其他边，维护一个初始没有边的森林 $T$。加边 $(u,v,w)$ 时，先判断 $u,v$ 是否已经在一个边双内（可以使用并查集维护），不是的话就新建一个点权是 $w$ 的节点 $k$，将 $u,v$ 路径上所有点在 $T$ 中的根的父亲设成 $k$。询问就变成了询问两个点的 LCA 的点权。

这样子做的时间复杂度：最小生成树：$O(m\log m)$，由于并查集至多合并 $n-1$ 次，加边操作只会执行 $O(n)$ 次，是 $O(n^2\alpha(n))$，询问 LCA 为 $O(q\log n)$，总共 $O(m\log m+n^2\alpha(n)+q\log n)$，足以通过这个题。

事实上还可以继续优化，观察时间复杂度的和式，发现瓶颈在于加边的 $n^2$。事实上，可以每次加边后在最小生成树上将 $u,v$ 路径上的点缩成一个点即可。注意这样子的存在细节问题，就是不能真的新开一个点复制节点信息，而应该把生成树看成，在并查集中再多维护一个块内深度最浅点。

将并查集单次操作视为常数，排序使用基数排序，LCA 用 [这个](https://oi-wiki.org/topic/rmq/#%E5%9F%BA%E4%BA%8E%E7%8A%B6%E5%8E%8B%E7%9A%84%E7%BA%BF%E6%80%A7-rmq-%E7%AE%97%E6%B3%95)，可以做到线性。

由于这个题是在模拟赛上写的，这里就只提供 $O(n^2)$ 的代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<vector>
#include<utility>
int n,m,fa[1000005],d[1000005],p[1000005],cnt,t[1000005],w,u,v,p2[1000005][22];
bool used[1000005];
std::pair<int,std::pair<int,int>>edge[1000005];
std::vector<int>G[1000005],CH[1000005];
int qup(int x){//if(x>1&&x<9)printf(":%d,%d\n",x,p[x]);
    if(p[x]-x)p[x]=qup(p[x]);
    return p[x];
}
void dfs1(int now=1,int fa=0){//printf("->%d %d\n",now,fa);
    ::fa[now]=fa,d[now]=d[fa]+1;
    for(int i:G[now])if(i-fa)dfs1(i,now);
}
void LINK(int x,int y,int w){//printf("(%d %d)",x,y);fflush(stdout);
    x=qup(x),y=qup(y);//printf("(%d %d)",x,y);fflush(stdout);
    if(x==y)return;
    cnt++,p[x]=p[y]=p[cnt]=cnt,p2[x][0]=p2[y][0]=cnt,t[cnt]=w,CH[cnt].push_back(x),CH[cnt].push_back(y);
}
void link(int a,int b,int vv,int ww){//printf("%d %d\n",a,b);
    if(d[a]<d[b])a^=b^=a^=b;
    while(d[a]>d[b])LINK(a,vv,ww),a=fa[a];
    while(a-b)LINK(a,vv,ww),LINK(b,vv,ww),a=fa[a],b=fa[b];
    LINK(a,vv,ww);//printf("%d %d\n",a,b);
}
void dfs2(int now){//printf("%d %d\n",now,p2[now][0]);
    d[now]=d[p2[now][0]]+1;
    for(int i=1;i<22;i++)p2[now][i]=p2[p2[now][i-1]][i-1];
    for(int i:CH[now])dfs2(i);
}
int lca(int x,int y){
    if(d[x]<d[y])x^=y^=x^=y;
    for(int i=21;~i;i--)if(d[p2[x][i]]>=d[y])x=p2[x][i];
    if(x==y)return x;
    for(int i=21;~i;i--)if(p2[x][i]-p2[y][i])x=p2[x][i],y=p2[y][i];
    return p2[x][0];
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++){
        scanf("%d%d%d",&u,&v,&w);
        edge[i]={w,{u,v}};
    }
    std::sort(edge+1,edge+m+1);
    for(int i=1;i<=n;i++)p[i]=i;
    for(int i=1;i<=m;i++){
        int u=edge[i].second.first,v=edge[i].second.second;
        int uu=qup(u),vv=qup(v);
        if(uu-vv)p[uu]=vv,G[u].push_back(v),G[v].push_back(u),used[i]=1;//,printf("-<%d\n",i);
    }
    dfs1();
    for(int i=1;i<=n;i++)p[i]=i;cnt=n;
    for(int i=1;i<=m;i++)if(!used[i]){
        int u=edge[i].second.first,v=edge[i].second.second;
        int uu=qup(u),vv=qup(v);
        if(uu-vv)link(u,v,vv,edge[i].first);
    }//return 0;
    scanf("%d",&m);
    for(int i=1;i<=cnt;i++)if(!p2[i][0])dfs2(i);
    while(m--){
        scanf("%d%d",&u,&v);
        if(qup(u)-qup(v)){puts("-1");continue;}
        printf("%d\n",t[lca(u,v)]);
    }
}
```

---


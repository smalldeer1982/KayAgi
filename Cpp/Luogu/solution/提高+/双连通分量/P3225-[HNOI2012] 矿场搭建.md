# [HNOI2012] 矿场搭建

## 题目描述

煤矿工地可以看成是由隧道连接挖煤点组成的无向图。为安全起见，希望在工地发生事故时所有挖煤点的工人都能有一条出路逃到救援出口处。于是矿主决定在某些挖煤点设立救援出口，使得无论哪一个挖煤点坍塌之后，其他挖煤点的工人都有一条道路通向救援出口。

请写一个程序，用来计算至少需要设置几个救援出口，以及不同最少救援出口的设置方案总数。

## 说明/提示

### 样例解释

- Case 1 的四组解分别是 $(2,4)$，$(3,4)$，$(4,5)$，$(4,6)$；
- Case 2 的一组解为 $(4,5,6,7)$。

### 数据范围及约定

对于每组数据，设 $m$ 为各组 $S, T$ 中最大值，则有：

- $1 \le m \le 10^3$；
- 各组 $S, T$ 构成的集合 $V\in[1, m] \cap \mathbb Z$。
- $V$ 中任意两点连通。

## 样例 #1

### 输入

```
9
1 3
4 1
3 5
1 2
2 6
1 5
6 3
1 6
3 2
6
1 2
1 3
2 4
2 5
3 6
3 7
0```

### 输出

```
Case 1: 2 4
Case 2: 4 1```

# 题解

## 作者：yybyyb (赞：149)

主要的方法都写在注释里面了。

用Tarjan跑出割点，然后DFS搜索所有的联通快

计算每一个联通快中的割点数目

分类讨论：

如果没有割点

至少需要建立两个出口

从任意非割点的地方选择两个点建立

如果这个分组只有一个割点

只需要在分组内设立一个出口

可以设立在任意一个非割点的地方

如果有两个及以上个割点，则无需建立，可以直接到达其他联通块

  

```cpp
#include<iostream>
#include<cstdlib>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<algorithm>
using namespace std;

#define MAX 501

int Dfn[MAX],vis[MAX],Low[MAX];
bool cut[MAX];
long long Num,Cut,Time,root,rs,m,n,Ans1,Ans2,Case,Group;

void Init();//多组数据，初始化 

struct Node  //定义边 
{
       int v,next;
}e[MAX*MAX];

int h[MAX],cnt;

void Add(int u,int v)  //添加边 
{
      e[cnt]=(Node){v,h[u]};
      h[u]=cnt++;
}

void Tarjan(int u,int f)  //Tarjan跑出所有割点 
{
       int v;
       Dfn[u]=Low[u]=++Time;   
       
       for(int i=h[u];i!=-1;i=e[i].next)//枚举所有直接连接的点 
       {
                v=e[i].v;
                if(!Dfn[v])  //如果没有访问过，证明v是u的子节点 
                {
                       Tarjan(v,u);
                       Low[u]=min(Low[u],Low[v]); //更新Low值 
                       if(Low[v]>=Dfn[u])  //如果v能够回到u或者u的祖先 
                       {
                               if(u!=root)    //如果u不是子树的根节点 
                                   cut[u]=true; //u是割点 
                               else 
                                   rs++;      //根节点子节点数增加 
                       }
                }
                else
                   if(v!=f)    //如果v不是u的父节点，但是v已经访问过 
                      Low[u]=min(Low[u],Dfn[v]);  //判断是否能够更新Low 
       }
}

void DFS(int u)//DFS搜索一边联通块 
{
        int v;
        
        vis[u]=Group; //标记组 
        Num++;        //非割点数 
                   
        for(int i=h[u];i!=-1;i=e[i].next)//访问子节点 
        {
               v=e[i].v;
               if(cut[v]&&vis[v]!=Group) //如果v是割点并且v没有在这个分组内被访问过 
               {
                        Cut++;         //割点数增加 
                        vis[v]=Group;  //标记分组 
               }
               if(!vis[v])     //如果vis未被访问过 
                   DFS(v);     //搜索v 
        }
}

int main()
{
       long long u,v;       
       Case=1;
       
       while(cin>>m&&m)
       {
              Init(); //初始化 
              
           for(int i=1;i<=m;++i)//读入边 
           {
                   cin>>u>>v;
                   Add(u,v);
                   Add(v,u);
                   n=max(n,v);
                   n=max(n,u);
           }
           
           for(int i=1;i<=n;++i)//Tarjan算法求割点 
           {
                     if(!Dfn[i])
                     {
                              root=i;
                              rs=0;
                              Tarjan(i,i);
                              if(rs>=2)       //如果子树根节点的儿子数不少于2个，则这个根节点才是割点 
                                  cut[i]=true;
                     }
           }
           
           for(int i=1;i<=n;++i)//枚举所有点来搜索分组 
           {
                    if(!vis[i]&&!cut[i])//如果i节点没有被访问过并且不是割点 
                    {
                            ++Group;  //增加一个分组 
                            Num=Cut=0;
                            DFS(i);   //搜索这个分组 
                            
                            if(Cut==0)//如果没有割点 
                            {
                                      Ans1+=2;//至少需要建立两个出口 
                                      Ans2*=(Num-1)*Num/2;//从任意非割点的地方选择两个点建立 
                            }
                            
                            if(Cut==1)//如果这个分组只有一个割点 
                            {
                                Ans1+=1;  //只需要在分组内设立一个出口 
                                Ans2*=Num;//可以设立在任意一个非割点的地方 
                            }
                            
                            if(Cut>=2)//如果有两个及以上个割点，则无需建立，可以直接到达其他联通块 
                            {
                                ; 
                        } 
                    }
           }
           
           cout<<"Case "<<Case++<<": "<<Ans1<<" "<<Ans2<<endl;//输出结果     
       }
       
       
       return 0; 
}

void Init()
{
       memset(h,-1,sizeof(h));
       memset(Dfn,0,sizeof(Dfn));
       memset(Low,0,sizeof(Low));
       memset(cut,0,sizeof(cut));
       memset(vis,0,sizeof(vis));
       Time=cnt=n=Ans1=Group=0;
       Ans2=1;
}
```

---

## 作者：wjyyy (赞：134)

   矿点坍塌我们可以抽象为将这个点删去。设图中原来有k个联通块，如果删掉割点，那么现在就有了k+1个联通块，如果不是割点，联通块数目不变。因此我们可以看出，割去任一个割点，割点两边的联通块都需要设一个逃生口。（关于[怎么求割点](http://www.wjyyy.top/)）我们先来分析几个情况：

### 1.链上

![这是一条链](http://www.wjyyy.top/wp-content/uploads/2018/06/QQ截图20180608080620.png)

   可以看出，图中有5个割点：2，3，4，5，6。如果不是割点的点坍塌了，例如1，那么只要在2-7中任意设置一个即可。但如果是割点坍塌了，两边的人只能往两头跑，而我们看到，在上图中，只要设置两个点：一头一尾的逃生出口，就可以满足任何坍塌情况。



### 2.环

   如果在一个环上，每两个点都可以互相直达，那么我们可以设置任一个点作为逃生出口，即可满足其他所有点到达这个地方。但是要考虑逃生出口坍塌的情况，所以一个环上要设置两个逃生出口，可以使无论逃生出口是否坍塌，都有一个逃生出口可用。n个点中任选两个点，方案数是$C^2_n =\frac{n(n-1)}{2}$



### 3.一般情况

   割点会分整个图为多个双连通分量，我们将每个双联通分量看作整个联通块，那么一个双连通分量中只需要设置一个点，就可以满足这个分量里的点能够跑到这个出口来。同上，我们还要考虑出口坍塌的情况。在这里，因为只会坍塌一个点，所以如果出口坍塌了，割点就不会坍塌，这个分量中的其他点可以通过割点跑到另外的双连通分量中，此时等价于同一个双连通分量。我们可以继续将这些点抽象为一个概念：叶子连通块。



### 4.叶子连通块

   叶子节点是没有出度的点，入度为1，也就是只连了一条边。那么叶子连通块的概念就是：只连接了一个割点的双连通分量。  同时，对于连接两个割点的双连通分量，其中一个割点坍塌，那么另一个割点就不会坍塌，可以通过另一个割点合并到另外一个双连通分量中。而叶子连通块就不行了，如果叶子连通块的割点（叶子的父亲）被切断，那么它就是一个单独的连通块，所以这里一定要设置一个逃生出口。在这里设置一个逃生出口，有weight种选择（weight是节点数）。根据乘法原理，最小个数是叶子连通块的个数；总方案数是所有叶子连通块的weight之积。



   所以我们只需要判断一个连通块dfs后是否只找到一个割点（用del数组存起来）



Code：

```pascal
#include<iostream>
#include<cstring>
#include<cstdio>
using std::min;
using std::max;
using std::cin;
using std::cout;
struct node
{
    int n;
    node *nxt;
    node(int n)
    {
        this->n=n;
        nxt=NULL;
    }
    node()
    {
        nxt=NULL;
    }
};
node head[550],*tail[550];
int dfn[550],low[550],cnt=0;//tarjan核心数组
int n,m;
bool del[550];
void tarjan(int x,int from)//求割点数
{
    int son=0;
    dfn[x]=++cnt;
    low[x]=dfn[x];
    node *p=&head[x];
    while(p->nxt!=NULL)
    {
        p=p->nxt;
        if(dfn[p->n])
            low[x]=min(low[x],dfn[p->n]);
        else
        {
            son++;
            tarjan(p->n,x);
            low[x]=min(low[x],low[p->n]);
            if(from!=0&&low[p->n]>=dfn[x])
                del[x]=true;//del=true就是割点
            if(from==0&&son>1)
                del[x]=true;
        }
    }
}
bool app[550];//是否出现过，判断一共有多少个点
unsigned long long sum=0;//sum<1<<64
int num=0,w=0;
bool used[550];
bool flag;
void dfs(int x)//判断是否为叶子连通块
{
    w++;//子节点个数
    node *p=&head[x];
    while(p->nxt!=NULL)
    {
        p=p->nxt;
        if(used[p->n])//遍历过的点或出发割点
            continue;
        if(del[p->n])//找到另一个非出发割点的割点，说明不是叶子连通块
        {
            flag=true;
            continue;
        }
        used[p->n]=true;
        dfs(p->n);
    }
    return;
}

int main()
{
    int u,v,t=0;
    scanf("%d",&m);
    while(m!=0)
    {
        t++;
        cnt=0;
        n=0;
        num=0;
        sum=1;
        memset(app,0,sizeof(app));
        memset(del,0,sizeof(del));
        memset(dfn,0,sizeof(dfn));
        memset(used,0,sizeof(used));
        for(int i=1;i<=544;i++)//最多500个点
            tail[i]=&head[i];
        for(int i=1;i<=m;i++)
        {
            scanf("%d%d",&u,&v);
            app[u]=true;
            app[v]=true;
            if(u>n)
                n=u;
            if(v>n)
                n=v;
            tail[u]->nxt=new node(v);
            tail[u]=tail[u]->nxt;
            tail[v]->nxt=new node(u);
            tail[v]=tail[v]->nxt;
        }


        for(int i=1;i<=n;i++)
            if(!dfn[i])
                tarjan(i,0);

        for(int i=1;i<=n;i++)
            if(del[i]&&app[i])
            {
                used[i]=true;
                node *p=&head[i];
                while(p->nxt!=NULL)
                {
                    p=p->nxt;
                    if(!del[p->n]&&!used[p->n])
                    {
                        w=0;
                        used[p->n]=true;
                        flag=0;
                        dfs(p->n);
                        if(!flag)//乘法原理
                        {
                            num++;//联通块个数
                            sum*=w;//方案个数
                        }

                    }
                }
                used[i]=false;//
            }
        if(num==0)//如果没有割点
        {
            num=2;
            if(n-1==m)
                sum=2;
            else
                sum=n*(n-1)/2;//加法原理
        }
        printf("Case %d: %d ",t,num);
        cout<<sum<<std::endl;
        scanf("%d",&m);
    }
    return 0;
}
```



注：这个题给出的图应该是连通图，不然如果一个矿场有两个矿区，比如两个不相交的环，就需要对每个环单独乘一次，这里没有考虑。

---

## 作者：安好 (赞：84)

/\*
首先看到割点就是Tarjan搞 但是怎么搞

首先假设我们把所有的点双都缩点 那么我们一定可以得到一棵树 然后我们就会发现

1.叶子节点(只含有一个割点的点双)必须建 因为叶子节点如果不建 一旦割点被爆就死翘了

2.非叶节点(含有两个或两个以上的割点的点双)不用建 因为即使一个割点被爆了也可以沿着另一个割点走到一个叶节点

3.还有一种情况就是整个联通块都是点双(即不含割点的点双) 这样我们讨论点双的大小

如果只有一个点 那么这个点必须建 数据没有卡这个的点所以我没写(其实是我忘写了 然后还过了)

如果有两个或两个以上的点 那么要建两个 一个被爆了还可以走另一个

方案数就是乘法原理的问题了 注意叶节点那里出口不能建在割点上

所以先Tarjan求割点再dfs一下每个联通块就好了。

\*/







```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define ll long long
using namespace std;
int head[505],dfn[505],low[505],vis[505],stack[505];
bool cut[505],in_stack[505];
int n,m,cnt,num,tot,deg,ans1,T,cases,root,top;
ll ans2;
struct node
{
    int from;
    int to;
    int next;
}e[1010];
inline void first()
{
    memset(head,0,sizeof(head));
    memset(dfn,0,sizeof(dfn));
    memset(low,0,sizeof(low));
    memset(cut,0,sizeof(cut));
    memset(vis,0,sizeof(vis));
    top=cnt=tot=n=ans1=T=0; ans2=1;
}
inline void insert(int from,int to)
{
    e[++num].from=from;
    e[num].to=to;
    e[num].next=head[from];
    head[from]=num;
}
inline int read()
{
    int x=0,f=1; char c=getchar();
    while (c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while (c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    return x*f;
}
void Tarjan(int now,int father)//求割点 
{
    dfn[now]=low[now]=++tot;
    for(int i=head[now];i;i=e[i].next)
        {
            int v=e[i].to;
            if(!dfn[v])
            {
                Tarjan(v,now);
                low[now]=min(low[now],low[v]);
                if(low[v]>=dfn[now])
                {
                    if(now==root) deg++;
                    else cut[now]=true;
                }
            }
            else if(v!=father) low[now]=min(low[now],dfn[v]);//不要跟求环混了 具体原理去网上找 
        }
}
void dfs(int x)//遍历每个连通块 
{
    vis[x]=T;//标记 
    if(cut[x]) return;
    cnt++;//数量 
    for(int i=head[x];i;i=e[i].next)
    {
        int v=e[i].to;
        if(cut[v]&&vis[v]!=T) num++,vis[v]=T;//统计割点数目。 
        //如果是割点且标记不与遍历的的连通块相同就修改标记。 
        if(!vis[v])dfs(v);
    }
}
int main()
{
    m=read();
    while (m)
    {
        first();
        for (int i=1;i<=m;i++)
        {
            int u=read(),v=read();
            n=max(n,max(u,v));//这个地方要处理一下 
            insert(u,v); insert(v,u);
        }
        for (int i=1;i<=n;i++)
        {
            if (!dfn[i]) Tarjan(root=i,0);
            if (deg>=2) cut[root]=1;//根节点的割点 
            deg=0;//不要忘记是多组数据 
        }
        for (int i=1;i<=n;i++)
            if (!vis[i]&&!cut[i])//不是割点 
            {
                T++; cnt=num=0;//T为连通块的标记 
                dfs(i);
                if (!num) ans1+=2,ans2*=cnt*(cnt-1)/2;//建两个 别忘记除以二 因为两个建立的出口没有差异 
                if (num==1) ans1++,ans2*=cnt;//建一个 
            }
        printf("Case %d: %d %lld\n",++cases,ans1,ans2);
        m=read();
    }
    return 0;
}
```

---

## 作者：米奇奇米 (赞：73)

## 这道题目真是挺难的：主要的算法就是$tarjan$,以及点双连通以及最后对答案的处理用到的组合数学。

### 题目传送门：[P3225 [HNOI2012]矿场搭建](https://www.luogu.org/problemnew/show/P3225)
### 题目大概意思：就是有很多个点，在某个时候一个点将会塌陷，你要建造一些点，使他们在那个点塌陷时成功逃脱！
### 此时我们要分类讨论三种情况：
### 情况一：在一个强连通中没有一个割点（见下图）
![](https://cdn.luogu.com.cn/upload/pic/59701.png)
### 那么此时至少要建立两个点，使得在点坍塌时能顺利逃脱，那么此时要建立的点的个数就是$2*sum1$($sum1$就是强连通的个数)，而方案数则是$C(n,2)->(n*(n-1)/2)$

### 情况二：在一个强连通中有一个割点（见下图）
![](https://cdn.luogu.com.cn/upload/pic/59702.png)
### 绿色的点即为割点，此时在一个强连通分量中只要建立$1$个即可，那么总共需要建立$sum1$个（$sum1$意义同上）；
### 情况三：在一个强连通中有两个割点（见下图）
![](https://cdn.luogu.com.cn/upload/pic/59704.png)
### 绿色的点即为割点，此时就不需要建立任何东西，因为可以逃脱，互相连通的，此时就无需操作
### 以上就是本题的关键之一，下一步就是点双，点双就很简单啦，模板一发就好啦！那我就贴代码啦吧，有点长哦！
```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
#define int long long
#define re register
using namespace std;
const int maxn=5e2+5;
struct Node 
{
	int u,v;
};
struct node
{
	int nex,to;
}ee[maxn];
vector<int> ma[maxn]; //用来存储该点双联通分量的所有顶点 
stack<Node> st;//STL栈
int cut[maxn],dfn[maxn];
int col[maxn],siz[maxn];
int head[maxn],cnt,now,sum,rt,top;
int res1,res2,Case,wyy[maxn],iscut,n;
inline void add_edge(int u,int v) 
{
	ee[++cnt].nex=head[u];
	head[u]=cnt;
	ee[cnt].to=v;
}//前向星连边
inline int read() 
{
    int z=0,f=1;char k;
    while(k<'0'||k>'9'){if(k=='-')f=-1;k=getchar();}
    while(k>='0'&&k<='9'){z=(z<<3)+(z<<1)+k-'0';k=getchar();}
    return z*f;
}
inline int tarjan(int u,int fa) //点双模板，大致介绍一下
// u是当前点，fa是父亲点; 
{
	int lowu=dfn[u]=++now;
	int son=0;
	for ( re int i=head[u];i;i=ee[i].nex )
	{
		int v=ee[i].to;
		Node e=(Node){u,v};
		if(!dfn[v])
		{
			son++;
			st.push(e);
			int lowv=tarjan(v,u);
			lowu=min(lowu,lowv);
			if(lowv>=dfn[u])
			{
				cut[u]=1;//是割点
				iscut=iscut+1;//割点数加1
				ma[iscut].clear();
				for(;;)
				{
					Node x=st.top();
					st.pop();
					if(wyy[x.u]!=iscut)
					{
						ma[iscut].push_back(x.u);
						wyy[x.u]=iscut;
					}
					if(wyy[x.v]!=iscut)
					{
						ma[iscut].push_back(x.v);
						wyy[x.v]=iscut;
					}
					if(x.u==u and x.v==v) break;
				}
			}
		} 
		else 
			if(dfn[v]<dfn[u] and v!=fa) 
			{
				st.push(e);
				lowu=min(lowu,dfn[v]);
			}
	}
	if(fa<0 and son==1) cut[u]=0;////如果u是根节点，u有>=2个孩子；u是割点 
	return lowu;
}
inline void found(int x) 
{
	memset(dfn,0,sizeof(dfn));
	memset(cut,0,sizeof(cut));
	memset(wyy,0,sizeof(wyy));
	iscut=0,now=0;
	for ( re int i=1;i<=n;i++ ) 
		if(!dfn[i]) 
			tarjan(i,-1);
}
inline void Init() 
{
	res1=0,res2=1,rt=0,cnt=0;
	memset(head,0,sizeof(head));
}
signed main() 
{
	while(scanf("%d",&n),n) 
	{
		Init();
		for ( re int i=1;i<=n;i++ ) 
		{
			int u=read(),v=read();
			rt=max(rt,u);
			rt=max(rt,v);
			add_edge(u,v);
			add_edge(v,u);//连边
		}
		found(rt);
		for ( re int i=1;i<=iscut;i++ )
		{
			int num=0;
			for ( re int j=0;j<ma[i].size();j++ ) 
			{
//				cout<<cut[ma[i][j]]<<" ";
				if(cut[ma[i][j]]) num+=1;//统计一个强连通分量里割点的数量
			}
            //高能：分类讨论
			if(num>=2) 
			{
				//I can do nothing
			}
			if(num==1) 
			{
				res1=res1+1;
				res2=res2*(ma[i].size()-1);
			}
			if(num==0) 
			{
				res1=res1+2;
			//	cout<<ma[i].size()<<endl;
				res2=res2*(ma[i].size()*(ma[i].size()-1)/2);//C(n,2)
			}
		}
		for ( re int i=1;i<=rt;i++ )
		{
			if(!wyy[i]) res1=res1+1;
		}// 看看那些孤立的点，还没指定属于哪个点双; 
		++Case;
		printf("Case %d: ",Case);
        printf("%lld %lld\n",res1,res2);
    }
    return 0;
}
			
```
### 这道题目有点难，思维难度比较高，代码细节比较多！但是做完这题，你将获得三倍经验：
#### [经验1：SP16185 BUSINESS - Mining your own business](https://www.luogu.org/problemnew/show/SP16185)
#### [经验2：UVA1108 Mining Your Own Business](https://www.luogu.org/problemnew/show/UVA1108)
#### [经验3：P3225 [HNOI2012]矿场搭建](https://www.luogu.org/problemnew/show/P3225)


---

## 作者：Ofnoname (赞：71)

这里是唯一的一个Tarjan后不用再DFS的题解。

思路：无向图跑Tarjan时就跑出所有割点和DCC（点双连通分量）。

1. 如果这个DCC包含了1个以上的割点，那么无论拿一个割点被堵，都可以通过其他割点逃向其他救生点，没有贡献答案。

2. 如果这个DCC只有1个割点，如果割点被堵，就在DCC内设立一个逃生点，如果逃生点被堵，就从割点出去。贡献为1，方案数为`size[i]-1`（除去割点本身）。

3. 如果这个DCC没有割点。就要用两个逃生点互保。贡献为2，方案数为`size[i]*(size[i]-1)/2`。所有方案数乘起来就是答案。

跑Tarjan时，类似有向图的做法维护一个栈。如果有`LOW[y]>=DFN[x]`的情况，就把从y到栈顶的部分一起弹出，他们和x构成了一个DCC（详见代码）。然后统一计算答案。

**为什么不能在Tarjan时计算答案：**

当你确定一个点双连通分量后，里面的所有点哪些是割点，哪些不是割点还没算完，所以是错的。要等Tarjan完后再算答案。
```cpp
#include <bits/stdc++.h>
#define MAX (1000 + 7)
#define add push_back
using namespace std;

int T,N,M,K,cnt,ans1,c[MAX],LOW[MAX],DFN[MAX];//c保存是否为割点 
long long ans2;

vector <int> L[MAX],DCC[MAX];//DCC数组保存每一个DCC 
stack <int> S;

void Tarjan(int x)
{
	int fa = 0; S.push(x);
	LOW[x] = DFN[x] = ++cnt;
	for (int p = 0; p < L[x].size(); p++)
	{
		const int y = L[x][p];
		if (!DFN[y])
		{
			Tarjan(y);
			LOW[x] = min(LOW[x], LOW[y]);
			if (LOW[y] >= DFN[x])
			{
				fa++; K++;
				if (x!=1 || fa>1) c[x] = 1;
				DCC[K].add(x);
				int z = 0;
				do{//Tarjan时弹栈并直接求出DCC 
					z = S.top(); S.pop();
					DCC[K].add(z);
				}while (z != y);
			}
		}
		else LOW[x] = min(LOW[x], DFN[y]);
	}
}

int main()
{
	while (scanf("%d", &M) && M)
	{
		S = stack <int> ();
		for (int i = 1; i <= N; i++)
			L[i].clear();
		for (int i = 1; i <= K; i++)
			DCC[i].clear();
		N = K = ans1 = cnt = 0; ans2 = 1;
		memset(c, 0, sizeof c);
		memset(LOW, 0, sizeof LOW);
		memset(DFN, 0, sizeof DFN);
		
		for (int i = 1, x = 0, y = 0; i <= M; i++)
		{
			scanf("%d%d", &x, &y);
			L[x].add(y); L[y].add(x);
			N = max(N, max(x,y));
		}
		Tarjan(1);
		for (int i = 1; i <= K; i++)
		{//统一对每一个DCC计算答案。 
			int v1 = DCC[i].size(), v2 = 0;
			//size()即该DCC的点个数，v2计算割点个数 
			for (int p = 0; p < v1; p++)
				v2 += c[DCC[i][p]];
			if (v2 == 1) ans1++, ans2 *= v1 - 1;
			if (v2 == 0) ans1 += 2, ans2 *= v1 * (v1-1) / 2;
		}
		printf("Case %d: %d %lld\n", ++T, ans1, ans2);
	}
}
```

---

## 作者：亦笙箫 (赞：22)

这道题的重点就是理解**矿点坍塌**

我们可以把它理解为**不经过这个点以及它所连向的边**

就像[这道题](https://www.luogu.org/problemnew/show/P3469)

理解了这一点之后

再引入一个概念
## 点双连通分量：

* 如果一个原图连通分量不存在割点，那么可以称之为点双连通分量

然后这个题就~~好做了~~可以做了。

### 但是要分类讨论！！！ 

1. 如果某个点双连通分量里只含有一个原图的割点，那么一旦这个割点坍塌，这个点双连通分量里的人都跑不掉，所以要在这个点双连通分量的除了割点之外的地方设置一个救援出口。

2. 如果某个点双连通分量里含有两个或更多原图的割点，那么任意一个点坍塌，至少还剩一个割点可以让点双连通分量里的人跑到其他点双连通分量里去，所以这个点双连通分量里不需要设置救援出口。
	
3. 设置方法数可以通过乘法原理计算。

## 总结一下

1. 先跑出整个图的割点。

```cpp
void tarjan(int u,int fa)
{
    int child=0;
    low[u]=dfn[u]=++num;
    for(int i=0;i<g[u].size();i++)
    {
        int v=g[u][i];
        if(!dfn[v])
        {
            child++;
            tarjan(v,u);
            low[u]=min(low[u],low[v]);
            if(low[v]>=dfn[u]) isCut[u]=true;
        }
        else
        {
            if(v!=fa&&dfn[v]<dfn[u])
                low[u]=min(low[u],dfn[v]);
        }
    }
    if(fa<0&&child==1) isCut[u]=false;
    return ;
}
```


2. 如果这的点没有跑过并且不是割点，那么就进入这个联通块。一个点双连通分量里如果它不是割点那么从它开始搜，搜到割点标记但不走，一定可以遍历这一整个点双连通分量，各位julao可以尝试思考一下~~手动滑稽~~

```cpp
void dfs(int x,int color)
{
	vis[x]=color;
	Fcut++;
	for(int i=0;i<g[x].size();i++)
	{
		int v=g[x][i];
		if(isCut[v]&&vis[v]!=color)
			Cut++,vis[v]=color;
		if(!vis[v])
			dfs(v,color);
	}
	return ;
}
```

3. 通过乘法原理计算答案时通过这个联通块里的**非割点数量**计算。
	#### 但是要分类讨论割点数量！！！
	1. 如果没有割点，那么需要建两个出口，因为要避免一个出口刚好塌掉的情况。
   2. 如果只有一个割点，那么只用建一个在不是割点的地方即可，如果出口塌掉，那么可以通过割点去到另外一个点双里，而且题目也说了同时只有一个矿点出事。
   3. 如果有两个及以上个割点，那么不用设置出口，因为无论如何它都可以跑到另外的点双里去。

### 注意：$n$ 在输入时求出最大值


**附上AC代码**

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<vector>
#include<stack>

using namespace std;

#define int long long

const int MAXX = 500;

int n,m;
int Num,G;
int QAQ,num;
int Fcut,Cut;
int root,count;
int dfn[MAXX+5];
int low[MAXX+5];
int vis[MAXX+5];
bool isCut[MAXX+5];
vector<int> g[MAXX+5];

void Init()
{
	n=0;num=0;
	Num=0;G=1;
	memset(dfn,0,sizeof(dfn));
	memset(low,0,sizeof(low));
	memset(vis,0,sizeof(vis));
	memset(isCut,false,sizeof(isCut));
	for(int i=1;i<=MAXX;i++)
		g[i].clear();
}

void tarjan(int u,int fa)
{
    int child=0;
    low[u]=dfn[u]=++num;
    for(int i=0;i<g[u].size();i++)
    {
        int v=g[u][i];
        if(!dfn[v])
        {
            child++;
            tarjan(v,u);
            low[u]=min(low[u],low[v]);
            if(low[v]>=dfn[u]) isCut[u]=true;
        }
        else
        {
            if(v!=fa&&dfn[v]<dfn[u])
                low[u]=min(low[u],dfn[v]);
        }
    }
    if(fa<0&&child==1) isCut[u]=false;
    return ;
}

void dfs(int x,int color)
{
	vis[x]=color;
	Fcut++;
	for(int i=0;i<g[x].size();i++)
	{
		int v=g[x][i];
		if(isCut[v]&&vis[v]!=color)
			Cut++,vis[v]=color;
		if(!vis[v])
			dfs(v,color);
	}
	return ;
}

signed main()
{
	while(scanf("%lld",&m)!=EOF)
	{
		if(m==0) return 0;
		++QAQ;
		Init();
		for(int i=1;i<=m;i++)
		{
			int x,y;
			scanf("%lld %lld",&x,&y);
			n=max(n,max(x,y));
			g[x].push_back(y);
			g[y].push_back(x);
		}
		for(int i=1;i<=n;i++)
	        if(!dfn[i])
	            tarjan(i,-1);
		for(int i=1,color=0;i<=n;i++)
		{
			if(!vis[i]&&!isCut[i])
			{
				++color;
				Fcut=Cut=0;
				dfs(i,color);
				if(Cut==0)
					Num+=2,
					G*=(Fcut-1)*Fcut/2;
				if(Cut==1)
					Num+=1,
					G*=Fcut;
			}
		}
		printf("Case %lld: %lld %lld\n",QAQ,Num,G);
	}
	return 0;
}
```


---

## 作者：LDlornd (赞：20)

来发一发找双连通分量的tarjan模板解法。。。

（~~加深一下对tarjan的理解~~）

思路还是找出割点和所有的双连通分量，然后统计每个双连通分量里的个点的个数分情况讨论。

1. 若该连通分量里有不少于两个割点，则它是安全的，因为无论哪个割点炸了，里面的点可以通过其他的没炸的割点跑到其他的双连通分量里去。

1. 若该连通分量里只有一个割点，那么如果这个割点炸了，则里面的点就不可能跑到其他的双连通分量里去了，所以要在这个割点里建一个出口。

1. 若该连通分量里一个割点也没有，说明它与外界完全不连通，这时如果只建一个出口的话，那么如果这个出口炸了就GG，所以还需要另一个出口“以防万一”\*（即建两个出口）


对于方案数的话，我们发现如果要建出口的话，该双连通分量里的任何一个非割点的节点都是可以的，因此用一下组合数学就可以搞定了。

~~好像偏离了主题~~……

主要想讨论的是找出并统计双联通分量的信息事实上也可以使用tarjan的模板来解决，只是判断的位置及条件变了一下（相对于求强连通分量的tarjan算法来说）或者判断里做的事变了一下（相对于求割点的tarjan算法来说）而已。

忽然感觉自己好啰嗦啊，为了不让小伙伴们心烦，那就上代码吧：

```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<iostream>
using namespace std;
const int MAXN=501;
long long int ans=0,fanganshu=1;//记录最终的答案，出口数与方案数 
int n,m,u,v,fenliangtot=0,casenum=0;//顶点数、边数、储存边的信息的临时变量（u、v）、连通分量的总数、数据组数 
int zhan[MAXN],top=0;//dfs时用到的栈 
int visit=0,dfn[MAXN],low[MAXN];//tarjan“必备组件” 
int root[MAXN],num[MAXN],roottot=0;//在进行tarjan时记录根节点以及删除该节点后的分量个数
//在做题时怕会出现图不连通的情况，于是开了个roottot记录tarjan时根节点的个数
bool vis[MAXN];//dfs时用（事实上感觉像一个弱化了的dfn数组） 
struct fenliang//记录图的每一个“联通分量”的数据 
{
    int num,gediannum;//连通分量中的非割点数及割点数 
    fenliang() {num=0;gediannum=0;}
}group[MAXN];
struct edge//邻接表存图 
{
    int v;
    edge *NEXT;
    edge() {v=0;NEXT=NULL;}
}*con[MAXN];
inline void ins(int start,int end)//往图中加边 
{
    edge *p=new(edge);
    p->v=end;
    p->NEXT=con[start];
    con[start]=p;
}
inline void tarjan(int nv)//tarjan模板 
{
    dfn[nv]=low[nv]=++visit;
    for(edge *p=con[nv];p;p=p->NEXT)
    {
        //nv跟vv在同一条边上，则有两种情况（在搜索树中）：
        //1、vv是nv的祖先，此时所遍历到的边就是一条后向边
        //2、vv是nv的儿子节点
        int vv=p->v;
        if(dfn[vv]==0)//如果vv之前没有被访问过，则vv是nv的儿子 
        {
            tarjan(vv);
            low[nv]=min(low[nv],low[vv]); //递归以及更新 
            if(low[vv]>=dfn[nv]) ++num[nv];
            //low[vv]>=dfn[nv]说明在nv的这一棵子树中没有任何一个节点会连到nv的祖先上去
            //所以去掉nv后图就不连通了（nv是割点）
            //但因为无论根节点去掉之后图是否连通，low[vv]>=dfn[nv]一定会成立，所以要减1（见main函数） 
        }
        else low[nv]=min(low[nv],dfn[vv]);//否则就是情况一 
    }
}
inline void dfs(int nv)
{
    vis[nv]=true;
    zhan[++top]=nv;//在遍历时把遍历到的节点入栈 
    for(edge *p=con[nv];p;p=p->NEXT)
    {
        int vv=p->v;
        if(vis[vv]==false)
        {
            dfs(vv);//事实上这个函数和上面tarjan也就是多了下面的判断 
            //在有向图求强连通分量时，我们使用过一个栈，在栈中的元素有可能在同一个强连通分量里面
            //而对于这个无向图，同样的道理，只是我们把强连通分量换成了双联通分量 
            //具体操作事实上和在求强连通的分量时的if(low[nv]==dfn[nv])时一样的
            //只不过一个点可能会在多个双联通分量里面，而一个点最多只会在一个强连通分量里面
            //所以while要换到前面来，并且在最后加一个特判（判断这个点是不是一个割点） 
            if(low[vv]>=dfn[nv])
            {
                ++fenliangtot; //求到了一个双连通分量 
                int place=zhan[top];
                while(place!=nv)
                {
                    --top;
                    if(num[place]) ++group[fenliangtot].gediannum; //现在这个点是割点 
                    else ++group[fenliangtot].num; //现在这个点不是割点 
                    place=zhan[top];
                }
                //对于这一棵子树的根节点的特判 
                if(num[place]) ++group[fenliangtot].gediannum;
                else ++group[fenliangtot].num;
            }
        }
    }
}
inline int read()//日常读入优化 
{
    int x=0,f=1;char c=getchar();
    while(c<'0'||c>'9') {if(c=='-') f=-1;c=getchar();}
    while(c>='0'&&c<='9') {x=x*10+c-'0';c=getchar();}
    return x*f;
}
int main()
{
    while(true)
    {
        m=read();//读入边数 
        if(m==0) return 0;//输入结束 
        memset(con,0,sizeof(con));
        memset(dfn,0,sizeof(dfn));
        memset(num,0,sizeof(num));
        memset(vis,0,sizeof(vis));
        memset(group,0,sizeof(group));
        ans=n=roottot=fenliangtot=0;
        fanganshu=1;
        //该初始化的东西全部初始化一遍 
        while(m--)
        {
            u=read();v=read();
            n=max(n,max(u,v));
            ins(u,v);ins(v,u);
        }//不断往图中加边，因为是无向图，所以加两次 
        for(int i=1;i<=n;++i)
            if(dfn[i]==0)
            {root[++roottot]=i;tarjan(i);}//tarjan找割点 
        //记录根节点是因为根节点要特判，要在tarjan中求出的num值减一才是它的真实的num值 
        for(int i=1;i<=roottot;++i)
            if(num[root[i]]!=0) --num[root[i]];//经过这样处理后所有num值为真的点就是割点了 
        for(int i=1;i<=n;++i)
            if(vis[i]==false) dfs(i);//dfs求点双连通分量 
        for(int i=1;i<=fenliangtot;++i)//遍历求到的双连通分量的数据 
        {
            int a=group[i].num,b=group[i].gediannum;
            if(b>=2) continue;//如果这个双连通分量中割点数大于等于2，说明不要建出口 
            else if(b==1) {++ans;fanganshu*=a;}//如果割点数等于1，则需要建一个出口 
            else if(b==0) {ans+=2;fanganshu*=(a*(a-1)/2);}//如果不存在割点，则要建两个出口 
        }
        printf("Case %d: %lld %lld\n",++casenum,ans,fanganshu);//输出结果
    }
}
```
希望对各位小伙伴有帮助QAQ。


---

## 作者：sycqwq (赞：9)

提供一种圆方树做法。

首先先建出一颗圆方树，考虑对于一个圆点，它坍塌后会产生的影响。

若该点为一个叶子节点，即不为一个割点，则不会对原图的连通性产生影响。

若该点为一个割点，则其的父亲节点所在连通块，和它儿子节点所在的连通块会分离。

此时分离出来的每一个连通块，都应有一个救援出口。

我们暂且不考虑其父亲连通块的状态。

设 $f_i$ 表示点 $i$ 坍塌后，其子树内最少的救援出口数量，设 $g_i$ 为方案数。

则有，对于圆点：

$f_i=\sum\limits_{v\in son_i} \max(f_v,1)$

$g_i=\prod\limits_{v\in son_I} \begin{cases}g_v&f_v\ne0\\size_v&f_v=0\end{cases}$

对于方点：

$f_i=\sum\limits_{v\in son_i}f_v$

$g_i=\prod\limits_{v\in son_I} g_v$

现在考虑其父亲节点所在连通块的状态。

我们不妨令一个割点为根，那么其肯定至少有两个儿子，并且每个儿子的子树中都必定有一个救援出口。

所以，当你断掉一个割点后，其父亲节点所在的连通块，即为根所在的连通块，转移到最后，一定会存在一个救援通道，所以不需要单独考虑。

最终的答案即为 $f_{root}$ 和 $g_{root}$。

注意需要特判整张图就是一个点双的情况。

代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn=5e5+5;
vector<int> e[maxn],g[maxn];
int n,dfn[maxn],low[maxn],idx,dcc,m,d[maxn];
stack<int> q;
void tarjan(int x,int fa)
{
    dfn[x]=low[x]=++idx;
    q.push(x);
    for(auto v:e[x])
    {
        if(v==fa)
            continue;
        if(!dfn[v])
        {
            tarjan(v,x);
            low[x]=min(low[x],low[v]);
            if(low[v]>=dfn[x])
            {
                ++dcc;
                int ls=0;
                do
                {
                    g[dcc].push_back(ls=q.top()),g[q.top()].push_back(dcc),++d[q.top()],q.pop();
                }while(ls!=v);
                ++d[x];
                g[dcc].push_back(x),g[x].push_back(dcc); 
            }
        }
        else
            low[x]=min(low[x],dfn[v]);
    }
}
int f[maxn],G[maxn],siz[maxn];
void dfs(int x,int fa)
{
    G[x]=1;
    siz[x]=x<=n;
    for(auto v:g[x])
    {
        if(v==fa)
            continue;
        dfs(v,x);
        siz[x]+=siz[v];
        if(x<=n)
            f[x]+=max(f[v],1ll),G[x]*=(f[v]==0?siz[v]:G[v]);
        else
            f[x]+=f[v],G[x]*=G[v];
    }
}
signed main()
{
    int T=0;
    while(cin>>m)
    {
        ++T;
        if(m==0)
            break;
        int k=0;
        memset(d,0,sizeof d);
        memset(f,0,sizeof f);
        memset(g,0,sizeof G);
        memset(low,0,sizeof low);
        memset(dfn,0,sizeof dfn);
        memset(d,0,sizeof d);
        n=0;
        while(!q.empty())
            q.pop();
        idx=0;
        for(int i=1;i<=m;i++)
        {
            int x,y;
            cin>>x>>y;
            n=max(n,max(x,y));
            k=x;
            e[x].push_back(y),e[y].push_back(x);
        }
        dcc=n;
        tarjan(k,k); 
        for(int i=1;i<=n;i++)
            if(d[i]>=2)
                k=i;
        dfs(k,k);
        if(dcc==n+1) 
            cout<<"Case "<<T<<": "<<2<<' '<<n*(n-1)/2<<endl; 
        else
            cout<<"Case "<<T<<": "<<f[k]<<' '<<G[k]<<endl;
        for(int i=1;i<=dcc;i++)
            g[i].clear(),e[i].clear();
    }
    return 0;
}
```

---

## 作者：Sundial (赞：7)

[[题目传送门](https://www.luogu.org/problem/P3225)]

思路的话其他大佬都已经讲的很清楚了qwq
我主要是想再提供一种写法

~~其实是自己太菜看不懂其他巨佬的代码QAQ~~

代码里也有一些解释，主要就是要会点双联通分量(代码里的 点分 )就好了

献上蒟蒻的代码
Code:

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 1e4 + 7;
int n, m;
int tot, head[N];
bool cut[N];//记录一个点是不是割点 
vector<int> dcc[N];//记录每个点双里面点 
int id, top, vdcc, dfn[N], low[N], stk[N];
struct edge{
	int net, to;
}e[N * 3];
void add(int u, int v) {
	e[++tot] = {head[u], v};
	head[u] = tot;
}
void tarjan(int u, int fa) {//求点分模板 
	dfn[u] = low[u] = ++id;
	stk[++top] = u;
	if (u == fa && !head[u]) {//单独的点就计入单独的点分 
		dcc[++vdcc].push_back(u);
		return;
	}
	int flag = 0;
	for (int i = head[u]; i; i = e[i].net) {
		int to = e[i].to;
		if (!dfn[to]) {
			tarjan(to, u);
			low[u] = min(low[u], low[to]);
			if (low[to] >= dfn[u]) {
				flag++;
				if (u != fa || flag > 1) {
					cut[u] = true;//记下割点 
				}
				vdcc++;
				dcc[vdcc].clear();//多组数据要清空 
				int y;
				do {
					y = stk[top--];
					dcc[vdcc].push_back(y);
				} while (y != to);//注意这里是to 
				dcc[vdcc].push_back(u);
			}
		} else {
			low[u] = min(low[u], dfn[to]);
		}
	}
}
int main () {
	int Case = 0;
	while (scanf("%d", &m) && m != 0) {
		Case++;
		ll ans1 = 0, ans2 = 1; 
		vdcc = tot = top = id = 0;
		memset(head, 0, sizeof head);
		memset(cut, 0, sizeof cut);
		memset(dfn, 0, sizeof dfn);
		//注意一下多组数据的清空,low数组会被id更新,不用清 
		n = 0;
		for(int i = 1; i <= m; i++) {
			int u, v;
			scanf("%d%d", &u, &v);
			add(u, v), add(v, u);
			n = max(n, max(u, v));//题里面没说点标号就只好自己取max 
		}
		for (int i = 1; i <= n; i++) {
			if (!dfn[i]) {
				tarjan(i, i);
			}
		}
		for (int i = 1; i <= vdcc; i++) {
			int cutnum = 0;
			int siz = (int)dcc[i].size();
			for (int j = 0; j < siz; j++) {
				if (cut[dcc[i][j]]) {
					cutnum++;//记录该点分之中的割点数 
				}
			}
			if (siz == 1) {//单独的点特判一下 
				ans1++;
				continue;
			}
			if (cutnum == 1) {
				ans1++;
				ans2 *=(siz - 1);
				//如果只有一个割点的话,必须要再建一个非割点的出口
				//这样才能保证在割点坍塌之后该点分还能出去 
			} else if (!cutnum) {
				ans1 += 2;
				ans2 *= siz * (siz - 1) / 2;
				//如果没有割点的话就必须建两个出口,然后就是C(n,2),化简后就是n*(n-1)/2
			}
			//还有一种情况就是有两个割点
			//此时无论哪个点塌了,该点分里的点都能有地方出去,所以不需要建出口了 
		}
		printf("Case %d: %lld %lld\n", Case, ans1,ans2);
	}
	return 0;
}
```
蒟蒻也是才开始看双联通分量，如果有不妥的地方还请巨佬们指出

感谢观赏


---

## 作者：k，火魂 (赞：7)

[yybyyb巨佬说的好像不是很清楚](https://www.luogu.org/blog/cjyyb/solution-p3225)

考虑每一个没有割点的子图，坍塌一个点可以利用其他点互达。
需要考虑的是割点，只有割点塌掉才会产生堵死的情况。

yybyyb的分组应该是从每一个点（非割点）进行搜索，遇到割点不搜，记录割点数目，这样就按被割点包围分成了几块，每一块内部没有割点，与该块直接相连的点都是割点。

考虑如果该子图与0个割点相连，那么这个子图一定要建两个出口，方案数就是一个组合数。（只建造一个可能塌掉的是出口）

如果与一个割点相连，如果割点塌掉，那么就会被堵死。如果不是割点塌掉，人民就可以通过割点到其他块，（这种情况就是要在其他块求解了），所以至少建一个，方案数就是该块点的数目

如果与两个割点相连，那么无论哪一个割点塌掉，都可以通过另一个割点到达别的块，所以不需要建造出口。

巨佬的代码（不是我写的哦）

```cpp
#include<iostream>
#include<cstdlib>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<algorithm>
using namespace std;

#define MAX 501

int Dfn[MAX],vis[MAX],Low[MAX];
bool cut[MAX];
long long Num,Cut,Time,root,rs,m,n,Ans1,Ans2,Case,Group;

void Init();//多组数据，初始化 

struct Node  //定义边 
{
       int v,next;
}e[MAX*MAX];

int h[MAX],cnt;

void Add(int u,int v)  //添加边 
{
      e[cnt]=(Node){v,h[u]};
      h[u]=cnt++;
}

void Tarjan(int u,int f)  //Tarjan跑出所有割点 
{
       int v;
       Dfn[u]=Low[u]=++Time;   

       for(int i=h[u];i!=-1;i=e[i].next)//枚举所有直接连接的点 
       {
                v=e[i].v;
                if(!Dfn[v])  //如果没有访问过，证明v是u的子节点 
                {
                       Tarjan(v,u);
                       Low[u]=min(Low[u],Low[v]); //更新Low值 
                       if(Low[v]>=Dfn[u])  //如果v能够回到u或者u的祖先 
                       {
                               if(u!=root)    //如果u不是子树的根节点 
                                   cut[u]=true; //u是割点 
                               else 
                                   rs++;      //根节点子节点数增加 
                       }
                }
                else
                   if(v!=f)    //如果v不是u的父节点，但是v已经访问过 
                      Low[u]=min(Low[u],Dfn[v]);  //判断是否能够更新Low 
       }
}

void DFS(int u)//DFS搜索一边联通块 
{
        int v;

        vis[u]=Group; //标记组 
        Num++;        //非割点数 

        for(int i=h[u];i!=-1;i=e[i].next)//访问子节点 
        {
               v=e[i].v;
               if(cut[v]&&vis[v]!=Group) //如果v是割点并且v没有在这个分组内被访问过 
               {
                        Cut++;         //割点数增加 
                        vis[v]=Group;  //标记分组 
               }
               if(!vis[v])     //如果vis未被访问过 
                   DFS(v);     //搜索v 
        }
}

int main()
{
       long long u,v;       
       Case=1;

       while(cin>>m&&m)
       {
              Init(); //初始化 

           for(int i=1;i<=m;++i)//读入边 
           {
                   cin>>u>>v;
                   Add(u,v);
                   Add(v,u);
                   n=max(n,v);
                   n=max(n,u);
           }

           for(int i=1;i<=n;++i)//Tarjan算法求割点 
           {
                     if(!Dfn[i])
                     {
                              root=i;
                              rs=0;
                              Tarjan(i,i);
                              if(rs>=2)       //如果子树根节点的儿子数不少于2个，则这个根节点才是割点 
                                  cut[i]=true;
                     }
           }

           for(int i=1;i<=n;++i)//枚举所有点来搜索分组 
           {
                    if(!vis[i]&&!cut[i])//如果i节点没有被访问过并且不是割点 
                    {
                            ++Group;  //增加一个分组 
                            Num=Cut=0;
                            DFS(i);   //搜索这个分组 

                            if(Cut==0)//如果没有割点 
                            {
                                      Ans1+=2;//至少需要建立两个出口 
                                      Ans2*=(Num-1)*Num/2;//从任意非割点的地方选择两个点建立 
                            }

                            if(Cut==1)//如果这个分组只有一个割点 
                            {
                                Ans1+=1;  //只需要在分组内设立一个出口 
                                Ans2*=Num;//可以设立在任意一个非割点的地方 
                            }

                            if(Cut>=2)//如果有两个及以上个割点，则无需建立，可以直接到达其他联通块 
                            {
                                ; 
                        } 
                    }
           }

           cout<<"Case "<<Case++<<": "<<Ans1<<" "<<Ans2<<endl;//输出结果     
       }

       return 0; 
}

void Init()
{
       memset(h,-1,sizeof(h));
       memset(Dfn,0,sizeof(Dfn));
       memset(Low,0,sizeof(Low));
       memset(cut,0,sizeof(cut));
       memset(vis,0,sizeof(vis));
       Time=cnt=n=Ans1=Group=0;
       Ans2=1;
}
```


---

## 作者：Mingoal (赞：7)

强联通本来就不熟，这次写篇题解做个笔记。

其实这题lrj的书里有

直接贴代码，里面有解释
```cpp
#include<bits/stdc++.h>
using namespace std;
#define M(a) memset(a,0,sizeof(a))
#define v e[i].to
typedef long long ll;
const int N=503;
struct kk{
    int to,ne;
}e[N*2];//双向建边，两倍
int tot,n,m,T,cnt,num,low[N],dfn[N],ans1,vis[N],cut[N],head[N],Case,x,y,tim,i;
ll ans2;
int read(){
    int x=0;char ch;
    do ch=getchar();while(ch<48||ch>57);
    while(ch>=48&&ch<=57)x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
    return x;
}
void add(int x,int y){
    e[++tot].to=y;
    e[tot].ne=head[x];
    head[x]=tot;
}
void tarjan(int u,int fa){
    int child=0;//u的孩子数量
    dfn[u]=low[u]=++tim;
    for (int i=head[u];i;i=e[i].ne)
        if (!dfn[v]){
            child++;
            tarjan(v,u);
            low[u]=min(low[u],low[v]);
            if (low[v]>=dfn[u]) cut[u]=1;
        }else if (dfn[v]<dfn[u] && v!=fa) low[u]=min(low[u],dfn[v]);
    if (child==1 && !fa) cut[u]=0;//若该点为根节点且只有一个儿子，就不是割点
}
void dfs(int u){
    vis[u]=T;cnt++;
    for (int i=head[u];i;i=e[i].ne){
        if (vis[v]!=T && cut[v]) num++,vis[v]=T;
//刚开始把vis[v]!=T写成!vis[v]，后来发现一个割顶可能会在多个联通块中出现
        if (!vis[v] && !cut[v]) dfs(v);
    }
}
int main(){
    do{
        m=read();
        if (!m) return 0;
        M(vis);M(cut);M(dfn);M(head);//偷了个懒，low不用清空
        n=ans1=T=tot=tim=0;ans2=1;//清空，有多组数据
        for (i=1;i<=m;i++) x=read(),y=read(),add(x,y),add(y,x),n=max(n,max(x,y));
        for (i=1;i<=n;i++)
            if (!dfn[i]) tarjan(i,0);
        for (i=1;i<=n;i++)
            if (!vis[i] && !cut[i]){
                T++,cnt=num=0;
//cnt为当前联通块中总的点的个数，num为割点个数
                dfs(i);
                if (!num) ans1+=2,ans2*=cnt*(cnt-1)/2;
                //内部无割点，则任意选两个出口
                if (num==1) ans1++,ans2*=cnt;
     //内部有一个割点，就任意选一个非割顶的点当作出口
            }
        printf("Case %d: %d %lld\n",++Case,ans1,ans2);
    }while (1);
}
```

---

## 作者：锦忠秀啊 (赞：4)

## 题目大意
在一个无向图上选择尽量少的点涂黑，使得删除任意一个点后，每个连通分量里都至少有一个黑点。

先考虑第一个问题，即至少需要设置几个救援出口。很容易看出这与割点有关，一个点双连通分量可以通过割点通向另一个点双连通分量。

那么我们分类讨论一下：

1、当一个点双连通分量没有割点：需要设置两个救援出口，因为当某一个设有救援出口的挖煤点坍塌之后，必须要有另外一个救援出口。

2、当一个点双连通分量有一个割点：需要设置一个救援出口，虽然通过割点可以通向另一个点双连通分量，但是当割点坍塌之后，就不能通向别处，所以需要在内部设置一个救援出口。

3、当一个点双连通分量有两个或以上割点：显然这时不需要设置救援出口，当一个割点坍塌之后，可以通过另外一个割点通向另一个点双连通分量。

所以我们的做法即为：求出所给无向图的割点和点双联通分量，再计算每个点双连通分量的割点数，然后按上述分类统计至少需要设置几个救援出口，即ans1。

对于第二个问题，只需按照方案数的乘法原理，把每个点双连通分量设置救援出口的方案数累乘即可。设每个点双连通分量的大小为Size，若需要设置一个救援出口，则ans2*=(Size-1)；若需要设置两个救援出口，则ans2*=Size*(Size-1)/2。注意一个独立的点也是双连通分量，这种情况需要特判，否则ans2的值会变为0.

上代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<algorithm>
using namespace std;
const int N=505;
int n,m,T;
int a[N],used[N];
int head[N],ver[N],Next[N],tot;
int dfn[N],low[N],stack[N],top,num,cnt,fa; 
int cut[N];//存储割点 
long long ans1,ans2=1;
vector<int> dcc[N];//存储每个点双连通分量中每个点的编号 
void add(int x,int y)
{
	ver[++tot]=y;
	Next[tot]=head[x];
	head[x]=tot;
}
void tarjan(int x,int fa)//tarjan求点双连通分量和割点 
{
	dfn[x]=low[x]=++num;
	stack[++top]=x;
	if(x==fa && !head[x])//独立点 
	{
		dcc[++cnt].push_back(x);
		return;
	}
	int flag=0;
	for(int i=head[x];i;i=Next[i])
	{
		int y=ver[i];
		if(!dfn[y])
		{
			tarjan(y,fa);
			low[x]=min(low[x],low[y]);
			if(low[y]>=dfn[x])
			{
				flag++;
				if(x!=fa || flag>1)
					cut[x]=1;
				cnt++;
				int z;
				do
				{
					z=stack[top--];
					dcc[cnt].push_back(z);
				}while(z!=y);
				dcc[cnt].push_back(x);
			}
		}
		else
			low[x]=min(low[x],dfn[y]);
	}
}
void clear()//多组数据，需要清空
{
	tot=num=top=cnt=n=ans1=0;
	ans2=1;
	for(int i=1;i<=N;i++)
		dcc[i].clear();
	memset(dfn,0,sizeof(dfn));
	memset(head,0,sizeof(head));
	memset(cut,0,sizeof(cut));
	memset(low,0,sizeof(low));
	memset(stack,0,sizeof(stack));
	memset(a,0,sizeof(a));
	memset(used,0,sizeof(a));
}
int main()
{
	while(~scanf("%d",&m) && m)
	{
		T++;
		clear();
		/*
		因为题目没有给出点的数目
		所以我们将点的编号放进a数组
		这样可以忽略其中没有用的到点的编号 
		*/ 
		for(int i=1;i<=m;i++) 
		{
			int x,y;
			scanf("%d%d",&x,&y);
			add(x,y);
			add(y,x);
			if(!used[x])
			{
				a[++n]=x;
				used[x]=1;
			}
			if(!used[y])
			{
				a[++n]=y;
				used[y]=1;
			}
		}
		sort(a+1,a+n+1);
		for(int i=1;i<=n;i++)//求点双连通分量和割点
			if(!dfn[a[i]])
				tarjan(a[i],a[i]);
		for(int i=1;i<=cnt;i++)
		{
			int sum=0,Size=dcc[i].size();
			for(int j=0;j<Size;j++)//统计当前点双连通分量的割点数目 
				if(cut[dcc[i][j]])
					sum++;
			if(!sum && Size!=1)
			{
				ans1+=2;
				ans2*=(Size*(Size-1)/2);
			}
			if(!sum && Size==1)//特判独立点的情况 
				ans1++;
			if(sum==1)
			{
				ans1++;
				ans2*=(Size-1);
			}
		}
		printf("Case %d: %lld %lld\n",T,ans1,ans2);
	}
	return 0;
}
```
[UVA1108](https://www.luogu.org/problem/UVA1108)
[SP16185](https://www.luogu.org/problem/SP16185)
一样的题目 不过数据更大 而且要记得多开几个long long



---

## 作者：niolle (赞：3)

```.cpp
/*
先tarjan求割点
把所有割点去掉以后寻找块 
如果有一个块没有割点，即这个子图联通，需要加两个点，方案总数*C2,n(即n*(n-1)/2)
如果一个块只有一个割点，则需要在所有不含割点的图里任选一点，方案总数*(n-1) 
如果一个块有多于一个割点，则这个点要么可以通过其中一个割点可以通往救援出口，要么可以通过自己所在的另一个块到达救援出口，不需操作
注意：一定要最后统计割点数
上代码 
*/
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cstdio>
#define rep(i,a,b) for(long long i=a;i<=b;i++)
#define N 505
#define M 1050
using namespace std;
typedef long long ll;
ll m,fir[N],nxt[M],to[M],tot,n;
void ade(ll u,ll v)
{
	to[++tot]=v;
	nxt[tot]=fir[u];
	fir[u]=tot;
}
ll dfn[N],low[N],num,col,book[N][N],sta[N],top,l[N];
bool vis[N];
void Tarjan_dfs(ll x)
{
	dfn[x]=low[x]=++num;
	sta[++top]=x;
	ll son=0;
	for(ll k=fir[x];k!=-1;k=nxt[k]){
		if(!dfn[to[k]]){
			Tarjan_dfs(to[k]);son++;
			low[x]=min(low[x],low[to[k]]);
			if((x==1 && son>1) || (x!=1 && dfn[x]<=low[to[k]])) vis[x]=1;
			if(dfn[x]<=low[to[k]]){
				l[++col]=0;
				book[col][++l[col]]=x;
				//printf("col=%lld,x=%lld\n",col,x);
				while(sta[top]!=x)   book[col][++l[col]]=sta[top],top--;
				//printf("x=%lld,col=%lld,book[%lld]=%lld,si[%lld]=%lld\n",x,col,col,book[col],col,si[col]);
			}
		}
		else low[x]=min(low[x],dfn[to[k]]);
	}
}
void init()
{
	memset(fir,-1,sizeof(fir));
	tot=-1;
	n=col=num=0;
	memset(dfn,0,sizeof(dfn));
	memset(vis,0,sizeof(vis));
}
ll t=0; 
void slove()
{
	init();
	rep(i,1,m){
		ll u,v;
		scanf("%lld%lld",&u,&v);
		ade(u,v);ade(v,u);
		n=max(n,max(u,v));
	}
	rep(i,1,n) if(!dfn[i]){
		top=0;Tarjan_dfs(i);
	} 
	ll ans=1,sum=0;
	rep(i,1,col){
		ll f=0;
		rep(j,1,l[i]) if(vis[book[i][j]]) f++;
		if(f==0) sum+=2,ans=ans*l[i]*(l[i]-1)/2;
		else if(f==1) sum++,ans=ans*(l[i]-1);
	}
	t++;
	printf("Case %lld: %lld %lld\n",t,sum,ans);
}
int main()
{
	while(scanf("%lld",&m) && m) slove();
	return 0;
}
```

---

## 作者：香风智乃 (赞：3)

https://www.luogu.org/problemnew/show/P3225

双连通分量

后面不用dfs的方法（直接在Tarjan中~~胡搞~~处理）

from 信息学竞赛一本通提高篇（排版不错~~但代码风格很迷~~）

具体有三种情况（设n为双连通分量所含的点数）：
- 双连通分量割点数==0，答案为C2n（n个点中选2个的方案数）
- 双连通分量割点数==1，答案为C1n（n个选1个的方案数）
- 双连通分量割点数>=2，不用再添加答案

be[i][j]：第i个双连通分量内的第j个点

详见代码
```cpp
#include<iostream>
#include<cstring>
#include<vector>
#include<cstdio>
using namespace std;
inline int min(int a,int b) {return a<b ? a:b;}
inline int max(int a,int b) {return a>b ? a:b;}
const int maxn=503;
vector <int> g[maxn],be[maxn];
int dfn[maxn],low[maxn],st[maxn];
bool cut[maxn];
int dfs_clock,cnt,top,m,n,root;
void tarjan(int x)
{
    dfn[x]=low[x]=++dfs_clock;
    st[++top]=x;
    int len=g[x].size(),child=0;
    for(int i=0;i<len;i++)
    {
        int to=g[x][i];
        if(!dfn[to])
        {
            child++;
            tarjan(to);
            low[x]=min(low[x],low[to]);，
            if((x==root&&child>1)||(x!=root&&dfn[x]<=low[to])) cut[x]=1;
            if(dfn[x]<=low[to]) //dfs变成了这个，剩下就是裸Tarjan了
            {
                be[++cnt].clear(); //先把上组的清空
                do
                {
                    be[cnt].push_back(st[top--]);
                }while(st[top+1]!=to);
            //	while(st[top]!=x) be[cnt].push_back(st[top--]);
            //上面这个看似等价的语句却只能得40（我查了一早上都找不出来为啥，知道原因的请私我QAQ）（已解决）
                be[cnt].push_back(x); //割点属于多个双连通分量
            }
        }
        else low[x]=min(low[x],dfn[to]);
    }
}
int main()
{
    //freopen("P3225.in","r",stdin);
    int p=0;
    while(scanf("%d",&m)&&m)
    {
        memset(cut,0,sizeof(cut));
        memset(dfn,0,sizeof(dfn));
        memset(low,0,sizeof(low));
        top=cnt=dfs_clock=0;
        n=0; int q1,q2;
        for(int i=1;i<=maxn;i++) g[i].clear();
        for(int i=1;i<=m;i++)
        {
            scanf("%d%d",&q1,&q2);
            g[q1].push_back(q2);
            g[q2].push_back(q1);
            n=max(n,max(q1,q2)); //结点总数要自己找
        }
        for(int i=1;i<=n;i++)
            if(!dfn[i])
            {
                root=i;
                tarjan(i);
            } 
//----------以上为裸的Tarjan-----------
        long long ans1=0,ans2=1;
        for(int i=1;i<=cnt;i++) //判断双连通分量内的割点数
        {
            int tge=0;
            int len=be[i].size();
            for(int j=0;j<len;j++)
                if(cut[be[i][j]])
                    tge++;
            if(tge==0)
            {
                ans1=ans1+2;
                ans2=ans2*(long long)(len*(len-1)/2);
            }else if(tge==1)
            {
                ans1=ans1+1;
                ans2=ans2*(long long)(len-1);
            }
        }
        printf("Case %d: ",++p);
        cout<<ans1<<" "<<ans2<<endl;
    }
    return 0;
}
```
关于代码中弹栈的问题（by mts_246）：

tarjan的时候可能存在一个儿子有一条返祖边，low[v]<dfn[x]，这样弹栈的时候不会弹出，所以找兄弟节点的时候栈顶不一定是x。

---

## 作者：孤叶残影 (赞：3)

首先，如果图本来就是点连通图（即不存在割点），那么从这个图中选出任意两个点就可，如果存在割点且只与一个割点相连的块，这个块则至少要选一个点作为逃生通道，而且可任意选择；对于与多个割点相连的块则没必要选点建逃生通道

------------
### 具体有三种情况：

#### 1.只有一个双边联通分量，割点0，方案C（2，n）；

#### 2.一个双边联通分量只有一个割点，则在非割点处任意选择一个点建通道；

#### 3.割点大于等于2，不需建通道

```cpp
#include<bits/stdc++.h>
#define ll long long
#define M 100005
using namespace std;
int dfn[M],low[M],dfstime,st[M],top;
int head[M],cnt,root,gedian[M];
int m,n,col,bt,T=1;
vector<int> block[M];
struct node{
	int v,next;
}e[M*2];
inline void add_edge(int u,int v)
{
	e[++cnt].v=v;
	e[cnt].next=head[u];
	head[u]=cnt;
}
inline void tarjan(int x)
{
	dfn[x]=low[x]=++dfstime;
	st[++top]=x;
	int ant=0;
	for(int i=head[x];i!=-1;i=e[i].next)
	{
		int y=e[i].v;
		if(!dfn[y])
		{
			ant++;
			tarjan(y);
			low[x]=min(low[x],low[y]);
			if((x==root&&ant>1)||(x!=root&&dfn[x]<=low[y]))//判断割点两个条件，不用判重边，因为对于割点，两点多边和一条边效果一样
			gedian[x]=1;
			if(low[y]>=dfn[x])//构造双边连通
			{
				bt++;
				block[bt].clear();
				do{
					block[bt].push_back(st[top--]);
				}while(st[top+1]!=y);
				block[bt].push_back(x);//割点属于多个双边连通
			}
		}
		else low[x]=min(low[x],dfn[y]);//无向图，不用判断是否在栈中
	}
}
inline void solve()
{
	n=bt=0;
	for(int i=1;i<=m*2;i++)
	{
		dfn[i]=low[i]=0;
		head[i]=-1;
		gedian[i]=0;
	}
	top=dfstime=cnt=0;
	for(int i=1;i<=m;i++)
	{
		int a,b;
		scanf("%d %d",&a,&b);
		n=max(n,max(a,b));
		add_edge(a,b);
		add_edge(b,a);
	}
	for(int i=1;i<=n;i++)
	{
		if(!dfn[i])//图可能有多个联通快
		{
			root=i;
			tarjan(i);
		}
	}
	ll num=1,rest=0;
	for(int i=1;i<=bt;i++)
	{
		int len=block[i].size();
		int genum=0;
		for(int j=0;j<len;j++)
		{
			if(gedian[block[i][j]])
			genum++;
		}
		if(!genum)//无割点
		{
			rest+=2;
			num=num*(len-1)*len/2;
		}	
		else if(genum==1)//一个割点
		{
			rest+=1;
			num=num*(len-1);
		}
	}
	printf("Case %d: ",T++);
	printf("%lld %lld\n",rest,num);
}
int main()
{
	while(scanf("%d",&m)&&m)
	{
		solve();
	}
	return 0;
}
```


---

## 作者：GoldenPotato137 (赞：2)

[戳我获得更好的阅读体验qwq](https://www.goldenpotato.cn/%E5%9B%BE%E8%AE%BA/luogu-p3225-hnoi2012%E7%9F%BF%E5%9C%BA%E6%90%AD%E5%BB%BA/)

---
# Solution
这题比较妙。

首先，~~根据常识~~，**如果一个点爆了，当且仅当它是割点的时候才会影响整个图的连通性**。    
因此，我们考虑把这道题往点双那方面想。

接下来我们思考这个问题：对于一个点双，我们什么时候需要在它这里面放置逃生通道：
1. 如果与它相连的点双块只有一个：**如果爆的是割点，则必须在当前块中的任意点建一个通道；如果爆的是普通点，则当前块则可以与别的块照样联通。**
2. 如果与它相连的点双块有两个以上：**无论爆的是割点还是普通点，都不影响它里面的其他点到其他块去逃生**。 

综上，**我们发现我们只需要在只与1个其他点双块连接的点双块防止逃生通道即可**。我在这里暂时称这种块为“叶子点双”。  

如下图：我们只需要在紫色的点双块中每一个都放置一个逃生通道即可。红色的是其他点双块
![image](https://wx3.sinaimg.cn/large/0061a3rzly1g1wrhf0x7rj30el0bt40b.jpg)

因此，要放置的逃生通道的总数为“叶子点双”的个数，总方案为$\prod (size[x]-1)$ （x为叶子点双）（由乘法原理可得）。

但是，我们要小心一个细节：就是我们在做Tarjan的时候，无论如何都会把1号节点认为是割点。但是，1号节点有可能并不是割点。**1号节点有可能属于某一个点双块，而且这个点双块是有可能为叶子节点的**，我们做的时候要小心判断一下。  

接下来，实现的话就随便写就好。~~笔者写的时候脑袋有点犯二，就用了圆方树来实现~~  
时间复杂度$O(\sum n)$  
就酱，这道题就被我们切掉啦(～￣▽￣)～ 

---
# Code
```cpp
//Luogu P3225 [HNOI2012]矿场搭建
//Apr,8th,2019
//Tarjan求点双+圆方树
#include<iostream>
#include<cstdio>
#include<vector>
#include<cstring>
using namespace std;
long long read()
{
	long long x=0,f=1; char c=getchar();
	while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
	while(isdigit(c)){x=x*10+c-'0';c=getchar();}
	return x*f;
}
const int N=2*500+20;
vector <int> e[N],e2[N];
int n,m;
int dfn[N],low[N],dfn_to,mstack[N],top,cnt,size[N];
bool vis[N];
void Tarjan(int now,int father)
{
	vis[now]=true;
	low[now]=dfn[now]=++dfn_to;
	mstack[++top]=now;
	for(int i=0;i<int(e[now].size());i++)
		if(vis[e[now][i]]==false)
		{
			Tarjan(e[now][i],now);
			low[now]=min(low[now],low[e[now][i]]);
			if(low[e[now][i]] >= dfn[now])
			{
				e2[now].push_back(n+ ++cnt);
				size[cnt]=1;
				while(mstack[top+1]!=e[now][i])
					e2[n+cnt].push_back(mstack[top--]),
					size[cnt]++;
			}
		}
		else if(e[now][i]!=father)
			low[now]=min(low[now],dfn[e[now][i]]);
}
long long ans,ans2;
int dfs(int now)//返回now的子树内的方点个数
{
	int t_cnt=(now>n);
	for(int i=0;i<int(e2[now].size());i++)
		t_cnt+=dfs(e2[now][i]);
	if(now>n and t_cnt==1)
		ans2++,ans*=(size[now-n]-1);
	return t_cnt;
}
bool Check()//判断1所在块是否为叶子块
{
	int x=e2[1][0],t_cnt=0;
	for(int i=0;i<int(e2[x].size());i++)
		if(e2[e2[x][i]].size()!=0)
			t_cnt++;
	return t_cnt==1;
}
int main()
{
	for(int o=1;;o++)
	{
		m=read();
		if(m==0) break;
		for(int i=1;i<=500*2+5;i++)
			e[i].clear(),e2[i].clear();
		dfn_to=cnt=0;
		memset(vis,0,sizeof vis);	
			
		n=0;
		for(int i=1;i<=m;i++)
		{
			int s=read(),t=read();
			e[s].push_back(t);
			e[t].push_back(s);
			n=max(max(n,s),t);
		}
		
		Tarjan(1,0);
		ans=1,ans2=0;
		dfs(1);
		if(e2[1].size()==1 and Check()==true)//特殊处理1号节点
			ans*=(size[e2[1][0]-n]-1),
			ans2++;
		if(cnt==1)//特判只有一个连通块的情况
			ans=(n*(n-1))/2,ans2=2;
			
		
		printf("Case %d: %lld %lld\n",o,ans2,ans);
	}
	return 0;
}

```







---

## 作者：圆满 (赞：2)

 这个题先求出割点（如果没有，直接出口数2，方案数（点数-1）*点数/2就行了 ），然后剩下的点有两种情况：
 1、只和一个割点:有联通用并查集走一遍就可以
 2、和多个割点联通（****不算）
 ```c
#include <bits/stdc++.h>
#define N 5050
#define M 110000
#define inf 2147483647
using namespace std;
int p[N],b[M],nt[M],num,n,fa[N],flag[N],f[N],ans,T,belong[N],o[N],ff;
long long sum=1;
void add(int x,int y)
{
    num++;
    nt[num]=p[x];
    p[x]=num;
    b[num]=y;
}
int father(int x)
{
    if(fa[x]==x)return x;
    return fa[x]=father(fa[x]);
}
int dfs(int x)
{
    int e=p[x],_size=1;
    while(e>0)
    {
        int k=b[e];
        if(!flag[k])
        {
            flag[k]=1;
            _size+=dfs(k);
        }
        e=nt[e];
    }
    return _size;
}
void dfs1(int x)
{
    int e=p[x];
    while(e>0)
    {
        int k=b[e];
        if(fa[k]!=-1&&!flag[k])
        {
            belong[k]++;
            flag[k]=1;
            dfs1(k);
        }
        e=nt[e];
    }
}
int main()
{
    while(scanf("%d",&n)&&n)
    {
        T++;
        memset(f,0,sizeof(f));		//统计并查集每一堆的个数
        memset(o,0,sizeof(o));		//存割点
        num=0;
        ans=0;
        sum=1;
        ff=0;							//是否有割点
        int t=0;
        memset(belong,0,sizeof(belong));//标记关联的割点数
        memset(p,0,sizeof(p));			//前向星
        int m=0;//点数						//更新
        for(int i=1;i<=n;i++)
        {
            int x,y;
            scanf("%d%d",&x,&y);
            add(x,y);
            add(y,x);
            m=max(x,max(m,y));
        }
        for(int i=1;i<=m;i++)fa[i]=i;
        for(int i=1;i<=m;i++)
        {
            memset(flag,0,sizeof(flag));
            flag[i]=1;
            flag[b[p[i]]]=1;
            if(dfs(b[p[i]])<m-1)
            {
                fa[i]=-1;
                o[++t]=i;
                ff++;
            }
        }
        for(int i=1;i<=t;i++)
        {
            memset(flag,0,sizeof(flag));
            flag[o[i]]=1;
            dfs1(o[i]);
        }
        for(int i=1;i<=m;i++)if(belong[i]>1)fa[i]=-1;
        for(int i=1;i<=m;i++)
        {
            if(fa[i]==-1)continue;
            int e=p[i];
            while(e>0)
            {
                int k=b[e];
                if(fa[k]!=-1)
                {
                    int fx=father(i);
                    int fy=father(k);
                    if(fx!=fy)fa[fx]=fy;
                }
                e=nt[e];
            }
        }
        for(int i=1;i<=m;i++)f[father(fa[i])]++;
        for(int i=1;i<=m;i++)
        {
            if(f[i]!=0)
            {
                sum*=f[i];
                ans++;
            }
        }
        if(ff==0)
        {
            sum=m*(m-1)/2;
            ans=2;
        }
        printf("Case %d: %d %lld\n",T,ans,sum);
    }
}


```

---

## 作者：一水阑珊 (赞：2)

# 割点+DFS

首先我们知道，对于这张图，我们可以枚举坍塌的是哪个点，对于每个坍塌的点，最多可以将图分成若干个不连通的块，这样每个块我们可能需要一个出口才能满足题目的要求，枚举每个坍塌的点显然是没有意义的，我们只需要每个图的若干个割点，这样除去割点的图有若干个块，我们可以求出只与一个割点相连的块，这些块必须要一个出口才能满足题目的要求，每个块内有块内个数种选法，然后将所有满足一个割点相连的块的点数连乘就行了

对于每个与一个割点相连的块必须建出口可以换一种方式理解，我们将每个块看做一个点，那么算上割点之后，这张图就变成了一颗树，只有叶子节点我们需要建立出口，因为对于非叶子节点我们不论断掉哪个点我们都有另一种方式相连，这里的叶子节点就是与一个割点相连的块。

最后还有个特判，就是对于一个双连通图，我们至少需要选取两个点作为出口，因为如果就选一个，可能该点为坍塌点，这时我们就任选两个点就行了，方案数为点数(点数-1)>>1。
先tarjan求一下所有的点双。 然后对于每一个点双，分类讨论：

1、只有一个割点，必须选一个非割点。

2、有>=2个割点，不用选 

3、有0个割点，必须选俩。

下面是代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define ll long long
#define max(a,b) ((a)>(b)?(a):(b))
using namespace std;
int const maxn=100000+10;
ll low[maxn],dfn[maxn],head[maxn];
bool cut[maxn];
ll n,t,maxx,cnt,tot,top,len,root;
struct node{
	int next,to;
}a[maxn*2];
void wash(){
	t++;   maxx=-1;
	len=tot=cnt=top=0;
	memset(cut,0,sizeof(cut));
    memset(low,0,sizeof(low));
    memset(a,0,sizeof(a));
    memset(head,0,sizeof(head));
    memset(dfn,0,sizeof(dfn));
}
void add(int u,int to){
	++cnt;
	a[cnt].to=to;
	a[cnt].next=head[u];
	head[u]=cnt;
}
void tarjan(int x){
	int flag=0,i=head[x];
    for(dfn[x]=low[x]=++len;i;i=a[i].next){
        int v=a[i].to;
        if(dfn[v]==0){
            ++flag;
            tarjan(v);
            if(low[v]>=dfn[x]) cut[x]=1,++cnt;//cnt表示割点的个数，以便后面的直接使用 
        }
        low[x]=min(low[x],low[v]);
    }
    if(x==root && flag==1)  cut[x]=0,--cnt;//对根节点进行特判 
}
void dfs(int x,int t){
    dfn[x]=t;
    if(cut[x]==1){
	    ++cnt;
		return;
	}
	++tot;
    for(int i=head[x];i;i=a[i].next){
        int v=a[i].to;
        if(dfn[v]!=t)dfs(v,t);
    }
}
void init(){
	wash();
	for(int i=1;i<=n;i++){
		int x,y;  cin>>x>>y;
		add(x,y),add(y,x);
		maxx=max(maxx,max(x,y));
	}cnt=0;
	for(int i=1;i<=maxx;i++) {
		root=i;
		if(!dfn[i]) tarjan(i);
	}
	if(!cnt){
		printf("Case %d: 2 %d\n",t,maxx*(maxx-1)/2);//因为没有割点，必须至少选择两个点，否则唯一点可能是坍塌点 
		return;
	}
	len=0;
	memset(dfn,0,sizeof(dfn));
	long long ans=1;
	top=0;
	for(int i=1;i<=maxx;i++){
		if(!dfn[i] && !cut[i]){
			tot=cnt=0;
			dfs(i,i);
			if(cnt==0)  top+=2,ans*=(long long)((tot-1)*tot/2);//如果没有割点。。。理由同上 
        	if(cnt==1)  top+=1,ans*=(long long)(tot); //有割点，则相乘 
		}
	}
	printf("Case %d: %d %lld\n",t,top,ans);
	return;
}
int main(){
	//freopen("1.in","r",stdin);
	while(cin>>n && n) init();//多组数据 
	return 0;
}
```



---

## 作者：Ankiia (赞：1)

本题解同步在我的[blog](https://www.cnblogs.com/wzztabaorz/articles/11411493.html)
中发表

~~tarjan的题目一般扫一眼就看出来了~~

~~也可能是我太蒻了只会水水题~~

思路：tarjan求无向图的强连通分量

PS：求tarjan时顺便把割点求出来

与模板不同的是此题不能直接cout强连通分量的个数

要根据强连通分量的割点数量判断

在一个强连通分量（dcc[i]）内：

1.设ans1为至少要修建的救援出口数量，ans2为方案总数

2.若割点数量>1，则对答案无影响

3.若割点数量=1，则有
```cpp
ans1++;
ans2*=(dcc[i].size()-1);
```

4.若割点数量=0，则有
```cpp
ans1+=2;
ans2*=dcc[i].size()*(dcc[i].size()-1)/2;
```

另外在判断第4点时，巨坑：方案总数每次要减半，因为有重复。

code如下（代码略丑，勿喷）
```cpp
#include<bits/stdc++.h>
#define re register int
using namespace std;
int n,m,t,gs,cnt,root,dfn[50010],low[50010],cut[50010];
long long ans1,ans2=1;
vector<int>Edge[50010],dcc[50010];
stack<int>stk;
int read()
{
	int ans=0;
	char w=' ',ch=getchar();
	while(ch<'0' || ch>'9')
	{
		w=ch;
		ch=getchar();
	}
	while(ch>='0' && ch<='9')
	{
		ans=(ans<<3)+(ans<<1);
		ans+=ch-'0';
		ch=getchar();
	}
	return (w=='-'?-ans:ans);
}
void tarjan(int x)
{
	dfn[x]=low[x]=++t;
	stk.push(x);
	if(x==root && Edge[x].size()==0)
	{
		dcc[++cnt].push_back(x);
		return;
	}
	int flag=0;
	for(re j=0;j<Edge[x].size();j++)
	{
		int y=Edge[x][j];
		if(!dfn[y])
		{
			tarjan(y);
			low[x]=min(low[x],low[y]);
			if(low[y]>=dfn[x])
			{
				flag++;
				if(x!=root || flag>1) cut[x]=1;
				cnt++;
				int z=0;
				do
				{
					z=stk.top();
					stk.pop();
					dcc[cnt].push_back(z);
				}while(z!=y);
				dcc[cnt].push_back(x);
			}
		}
		else
		{
			low[x]=min(dfn[y],low[x]);
		}
	}
}
int main()
{
	int a1,a2;
	while(cin>>m && m)
	{
		for(re i=1;i<=m;i++)
		{
			a1=read();a2=read();
			Edge[a1].push_back(a2);
			Edge[a2].push_back(a1);
			n=max(n,max(a1,a2));
		}
		for(re i=1;i<=n;i++)
		{
			if(!dfn[i])
			{
				root=i;
				tarjan(i);
			}
		}
		for(re i=1;i<=cnt;i++)
		{
			int sum=0;
			for(re j=0;j<dcc[i].size();j++)
			{
				if(cut[dcc[i][j]])
				{
					sum++;
				}
			}
			if(sum==0)
			{
				ans1+=2;
				ans2*=dcc[i].size()*(dcc[i].size()-1)/2;
			}
			else if(sum==1)
			{
				ans1++;
				ans2*=(dcc[i].size()-1);
			}
		}
		printf("Case %d: %lld %lld\n",++gs,ans1,ans2);
		n=0;ans1=0;ans2=1;cnt=0;t=0;
		memset(dfn,0,sizeof(dfn));
		memset(low,0,sizeof(low));
		memset(Edge,0,sizeof(Edge));
		memset(dcc,0,sizeof(dcc));
		memset(cut,0,sizeof(cut));
		stk=stack<int>();
	}
	return 0;
}

```


---

## 作者：noall (赞：1)

做此题，需要知道点双连通；知道点双连通，就要知道割顶

### 割顶

#### 什么是割点？

> 对于无向图$G$，如果删除某个点$u$后，连通分量数目增加，称$u$为图的关节点或**割顶**。对于连通图，割顶就是删除之后使图不再联通的点。

#### 怎么求？

##### DFS树

学习求割顶之前要先学习dfs树。

dfs树就是将有向连通图转化为搜索树，节点以dfs序排列。

######  树上的一些定义：

>- $dfn$：时间戳，结点被访问的次序。（起点为$1 $，每次搜索$+1$）
>
>- $low$：结点所能到达的最小$dfn$值 。
>
>- 树边：$dfs$树上应有的边，又父节点指向子节点 。
>
>- 返祖边：$dfs$树上不应有的边，且该边由子辈节点指向父辈节点。（注意这里不一定是父子节点） 
>
>- 横叉边：连接的两个点无父子辈关系。（注意横叉边一定由$dfn$值大的节点指向$dfn$值小的节点，否则它是树边）
>-  图中$5$节点的$low$值为$5$而不是$4$，是因为横插边$(5,6)$会被忽略，看不懂的话，等到下面讲到处理横叉边的时候再理解即可。

我要引用**冯巨佬**的一张图，来举例：

![006oZqiLly1g0o78oufhyj30hk0kdjui.jpg](https://img.langlangago.xyz/2019/04/06/5ca88b4dd085e.jpg)

学完大法师树之后，我们就可以学习求割顶了

##### 思路

为了方便叙述，我们只讨论连通图。在这样的情况下，大法师森林一定只有一棵树。那么树根是不是割顶呢？不难发现，**当且仅当它有两个或更多的子节点**时，它才是割顶——无向图只有树边和反向边，不存在跨越两棵子树的边。对于其他点，我们有下面的定理：

> 定理：在无向联通图G的大法师树中，非根节点u是G的割顶当且仅当u存在一个子节点v，使得v及其所有后代都没有反向边连回u的**祖先**。

可以看下图，很容易看出u是一个割点。

![1.jpg](https://img.langlangago.xyz/2019/07/13/5d292b28875c8.jpg)

可以看下图，很容易看出u不是一个割点。

![2.jpg](https://img.langlangago.xyz/2019/07/13/5d292deac708d.jpg)

**综上，很容易看出，若$low_v \ge dfn_u$，则满足定理中的条件，$u$即为割顶。**

如果不知道$dfn$和$low$是什么，就去看看上面的大法师树吧。

如果还是不理解，就多读几遍！

#### 模板code

```cpp
//模板：https://www.luogu.org/problemnew/show/P3388
const……maxn1……
const……maxn2……

struct edge{……}map[maxn2<<1];

int n,m,dfn[maxn1],low[maxn1],tot;bool iscut[maxn1];
int cnt,head[maxn1];

inline int read(){……}

inline void add(int x,int y){……}

void dfs(int x,int fa){//x是当前节点，fa是当前节点的父亲节点。规定树根的父亲节点是0.
    int child=0;//当前点的子节点数
    dfn[x]=low[x]=++cnt;//时间戳更新
    for(int i=head[x];i;i=map[i].next){
        int y=map[i].to;
        if(!dfn[y]){//如果没有访问过
            child++;//子节点数+1
            dfs(y,x);//向下走
            low[x]=std::min(low[x],low[y]);//更新low值
            if(low[y]>=dfn[x]) iscut[x]=true;//如果符合定理，那么x就是割顶
        }
        else if(y!=fa) low[x]=std::min(low[x],dfn[y]);//如果访问过了，更新low值
    }
    if(!fa&&child==1) iscut[x]=false;//当且仅当它有两个或更多的子节点时，树根才是割顶
    return;
}

int main(){
    n=read(),m=read();
    for(register int i=1;i<=m;i++){
        int x=read(),y=read();
        add(x,y),add(y,x);//双向边
    }
    cnt=0;
    for(register int i=1;i<=n;i++)
        if(!dfn[i]) dfs(i,0);//将点全部遍历一遍
    for(register int i=1;i<=n;i++){
        if(iscut[i]) ++tot;//如果是割顶，总数tot++
    }
    printf("%d\n",tot);
    for(register int i=1;i<=n;i++){
        if(iscut[i]) printf("%d ",i);//将是割点的点输出
    }
    return 0;
}
```

### 点双连通分量

来自冯巨佬……

> 学会了求解割顶，求出BCC就在容易不过了。——冯巨佬

维护一个栈，栈内保存每一次走过的边（一定保存边，因为两个不同的双连通子图可能有交点，但一定没有交边但）。每当发现割顶时，出栈，直到发现当前出栈的边恰好是连接割顶与判定它的子节点的边。则出栈的所有边同属一个双连通子图，这些边的端点也同属一个双连通子图。

代码如下：
因为回溯到根的时候，剩余栈内元素一定是一个双连通子图，故先出栈再特判根。

#### 模板code

```cpp
//from 冯巨佬，增加注释
const int CP=1e3+3;
const int CE=CP*CP;

//边表
class fs{
    public:
        int from,to,nxt;
}E[CE];
int hd[CP],cnt=0;
void add(int x,int y){……}

//bcc
int dfn[CP],low[CP];
int idx=0;

int bel[CP],bcnt=0; //每个点所属的bcc编号，为-1则表示该点是割顶（割顶同时属于两个bcc，所以它的bel无意义）
int stack[CE],top=0;

void tarjan(int cur,int prv)
{
    int child = 0; 
    
    dfn[cur] = low[cur] = ++idx; 
    
    for(int k=hd[cur]; k; k=E[k].nxt)
    {
        int to=E[k].to;
        
        if(!dfn[to]) 
        {
            child++;
            stack[++top]=k; //入栈
            tarjan(to,cur); //向下搜索
            
            low[cur] = min(low[cur], low[to]); 
            
            if(low[to] >= dfn[cur]) //是割顶
            {
                  int pos;
                  ++bcnt;
                  while(true)
                  {
                      pos=stack[top--]; //出栈
                      bel[E[pos].from] = bel[E[pos].to] = bcnt;
                      if(E[pos].from==cur && E[pos].to==to) //到达当前的树边
                           break;//直接退出循环
                  }
                bel[cur] = -1; //标记割顶
            }
        }
        else if(to != prv) low[cur] = min(low[cur], dfn[to]); 
    }
    
    if(!prv && child==1) //处理根
        bel[cur] = bcnt;
}

void bcc() //主求解函数
{
    for(int i=1;i<=n;i++)
        if(!dfn[i])
            tarjan(i,0);
}
```

### 题目思路

嗯，基本是一个裸的模板题，简化题意：在一个无向图上选择尽量少的点涂黑，使得删除任意一个点后，每个连通分量里都至少有一个黑点。

我们可以求出所有的连通子图，然后判断其中的割点。

若割点为1，则应当将答案+2。为什么？因为，我们应当考虑存在割点的连通块不是点-双连通。就是说，当割点塌陷后，将会分成两个连通块，这两个连通块不能互相到达。

若割点为0，则应当将答案+1。很容易理解。

对于只有一个割顶的连通块，设它的大小为s，则共有s−1种不同的涂黑方案，根据乘法原理将这些s−1相乘即可。
对于没有割顶的连通块，方案数为s∗(s−1)/2，与前面的相乘即可。

### code

```cpp
#include<cstdio>
#include<cstring>
#include<vector>
#include<iostream>

#define int long long
const int maxn=1e5+10;

struct edge{
    int from,to,next;
}map[maxn];

int n,m,dfn[maxn],low[maxn],stk[maxn],top,bcnt,ins[maxn],ans1,ans2,idx;
int cnt,head[maxn];
bool iscut[maxn];
std::vector<int>bcc[maxn];

inline void add(int x,int y){
    map[++cnt]=(edge){x,y,head[x]};
    head[x]=cnt;
    return ;
}

inline void init(){
    ans1=bcnt=idx=n=top=cnt=0;
    memset(dfn,0,sizeof(dfn));
    memset(low,0,sizeof(low));
    memset(iscut,false,sizeof(iscut));
    memset(map,0,sizeof(map));
    memset(stk,0,sizeof(stk));
    memset(head,0,sizeof(head));
    memset(ins,0,sizeof(ins));
    return ;
}

void dfs(int x,int fa){
    dfn[x]=low[x]=++idx;
    int child=0;
    for(int i=head[x];i;i=map[i].next){
        int y=map[i].to;
        if(!dfn[y]){
            child++;
            stk[++top]=i;//栈存边
            dfs(y,x);
            low[x]=std::min(low[x],low[y]);
            if(low[y]>=dfn[x]){
                int pos;
                bcnt++;
                bcc[bcnt].clear();//初始化bcc
                while(true){
                    pos=stk[top--];
                    if(!ins[map[pos].from]){//如果它不在任何一个连通块中
                        ins[map[pos].from]=true;
                        bcc[bcnt].push_back(map[pos].from);
                    }
                    if(!ins[map[pos].to]){
                        ins[map[pos].to]=true;
                        bcc[bcnt].push_back(map[pos].to);
                    }
                    if(x==map[pos].from&&y==map[pos].to) break ;
                }
                iscut[x]=true,ins[x]=false;
            }
        }
        else low[x]=std::min(low[x],dfn[y]);
    }
    if(!fa&&child==1) iscut[x]=false;
    return ;
}

inline int read(){
    char ch=getchar();int x=0,f=1;
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return f*x;
}

signed main(){
    int Case=0;
    while(scanf("%lld",&m)&&m){
        init();
        for(register int i=1;i<=m;i++){
            int x=read(),y=read();
            add(x,y),add(y,x);
            n=std::max(n,std::max(x,y));
        }
        for(register int i=1;i<=n;i++){
            if(!dfn[i]) dfs(i,0);
        }
        ans2=1;
        for(int i=1;i<=bcnt;i++){
            int cut=0,sz=bcc[i].size(); 
            for(int j=0;j<sz;j++) if(iscut[bcc[i][j]]) ++cut;//统计割点数
            if(cut==1) ans1+=1,ans2*=(sz-1);
            if(cut==0) ans1+=2,ans2*=(sz*(sz-1))/2;
        }
        printf("Case %lld: %lld %lld\n",++Case,ans1,ans2);
    }
    return 0;
} 
```

---

## 作者：寒鸽儿 (赞：1)

[博客食用效果更佳](https://www.luogu.org/blog/oldherd/solution-p3225)
### 对于tarjan - d-vcc求法的考察
如果一个建立逃生点的点塌了，那么其他点都不能到哪里去，也不能经过它。  
关于经过不经过，这不就是说有关于双连通的问题吗?在同一个双连通分量中，坍塌任意一个点，原图必然还是连通。因而至多在每个v-dcc中建立一个逃生点。  
还能否再去掉一些点？缩点之后，是一棵树，一个结点的度如果大于1，那么其中一个坍塌还能从另一个中逃跑到其他点之中。v-dcc通过什么与其它v-dcc相连呢？必然是割点，否则不满足分量的极大性。而度数就等价于每个分量中的割点数。  
特殊情况是，如果整个图为v-dcc，那么必须设立2个点，因为不能再跑到其他地方去了。  
方案数容易用数学手段统计得到。
附上代码：
```cpp
#include <cstdio>
#include <cstring>
#include <vector>

using namespace std;

const int maxn = 510, maxm = 510;
#define min(x, y) (x) < (y) ? (x) : (y)

int head[maxn], ver[maxm<<1], nex[maxm<<1], tot;
inline void addedge(int u, int v) {
    ver[tot] = v; nex[tot] = head[u]; head[u] = tot++;
}

vector<int> dcc[maxn];
int dfn[maxn], low[maxn], cut[maxn], stack[maxn], st, root, dfs_clock = 1, cc;
inline void tarjan(int cur) {
    stack[st++] = cur;
    dfn[cur] = low[cur] = dfs_clock++;
    if(cur == root && head[cur] == -1) {
        dcc[cc++].push_back(cur);
        return;
    }
    int flag = 0;
    for(int i = head[cur]; i != -1; i = nex[i]) {
        if(!dfn[ver[i]]) {
            tarjan(ver[i]);
            low[cur] = min(low[cur], low[ver[i]]);
            if(dfn[cur] <= low[ver[i]]) {
                flag++;
                if(cur != root || flag == 2) cut[cur] = 1;
                int t;
                do {
                    t = stack[(st--)-1];
                    dcc[cc].push_back(t);
                }while(t != ver[i]);
                dcc[cc++].push_back(cur);
            }
        } else 
            low[cur] = min(low[cur], dfn[ver[i]]);
    }
}



int main() {
    int n, m, u, v, cases = 1;
    while(scanf("%d", &m) == 1 && m) {
        memset(head, -1, sizeof(head));
        memset(dfn, 0, sizeof(dfn));
        memset(cut, 0, sizeof(cut)); 
        n = cc = tot = 0;
        while(m--) {
            scanf("%d %d", &u, &v);
            addedge(u, v);
            addedge(v, u);
        }
        n = max(n, u); n = max(n, v);
        for(int i = 1; i <= n; i++)
            if(!dfn[i]) {
                st = 0;
                root = i, tarjan(i);
            }
        if(cc == 1) {
            printf("Case %d: %d %lld\n", cases++, 2, (long long)dcc[0].size() * (dcc[0].size()-1) / 2);
            dcc[0].clear();
            continue;
        }
        long long num = 0, sor = 1;
        for(int i = 0; i < cc; i++) {
            int ncut = 0;
            for(vector<int>::iterator it = dcc[i].begin(); it != dcc[i].end(); it++)
                if(cut[*it]) ncut++;
            if(ncut == 1) {
                num++; sor *= (dcc[i].size()-ncut);
            }
            dcc[i].clear();
        }
        printf("Case %d: %lld %lld\n", cases++, num, sor);
    }	return 0;

}
```
欢迎互相关注(然而在oi界蒟蒻的圈很小)。  
最后再次安利一下[蒟蒻的洛谷博客](https://www.luogu.org/blog/oldherd/)

---


# BZOJ3252 攻略

## 题目背景

众所周知，桂木桂马是攻略之神，开启攻略之神模式后，他可以同时攻略 $k$ 部游戏。

今天他得到了一款新游戏《XX 半岛》，这款游戏有 $n$ 个场景，某些场景可以通过不同的选择支到达其他场景。所有场景和选择支构成树状结构：开始游戏时在根节点（共通线），叶子节点为结局。每个场景有一个价值，现在桂马开启攻略之神模式，同时攻略 $k$ 次该游戏，问他观赏到的场景的价值和最大是多少？（同一场景观看多次是不能重复得到价值的）

>“为什么你还没玩就知道每个场景的价值呢？”  
>“我已经看到结局了。”

## 题目描述

给定一个有 $n$ 个结点的树，树有点权且点权为正整数。现选取 $k$ 条从根结点出发到叶子结点的简单路径，求这些路径的并集上所有结点的点权之和的最大值。

## 说明/提示

对于所有数据，保证 $1\leq n\leq 2\times 10^5$，$1\leq w_i\leq 2^{31}-1$。

## 样例 #1

### 输入

```
5 2
4 3 2 1 1
1 2
1 5
2 3
2 4```

### 输出

```
10```

# 题解

## 作者：rui_er (赞：16)

我让 cz 搬这道题，cz 给搬了，于是来写个题解（

考虑一个朴素的贪心：每次选择一个到根路径价值和最大的叶子，将价值和累加进答案，并把这条链价值清零。

这个贪心的正确性显然（可以交换法证明），很容易用数据结构维护做到 $O(n\log^2 n)$ 或 $O(n\log n)$。

但是这样太不优美了，而且数据结构比较难写，于是考虑一个更优的做法。

定义路径权值为路径的价值和，对树进行长链剖分。容易发现，贪心的算法流程等价于每次选择权值最大的一条长链，因此答案即为前 $k$ 大的长链的权值之和，可以做到 $O(n)$。

```cpp
//By: OIer rui_er
#include <bits/stdc++.h>
#define rep(x, y, z) for(int x = (y); x <= (z); ++x)
#define per(x, y, z) for(int x = (y); x >= (z); --x)
#define debug(format...) fprintf(stderr, format)
#define fileIO(s) do {freopen(s".in", "r", stdin); freopen(s".out", "w", stdout);} while(false)
#define endl '\n'
using namespace std;
typedef long long ll;

mt19937 rnd(std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::system_clock::now().time_since_epoch()).count());
int randint(int L, int R) {
    uniform_int_distribution<int> dist(L, R);
    return dist(rnd);
}

template<typename T> void chkmin(T& x, T y) {if(x > y) x = y;}
template<typename T> void chkmax(T& x, T y) {if(x < y) x = y;}

template<int mod>
inline unsigned int down(unsigned int x) {
    return x >= mod ? x - mod : x;
}

template<int mod>
struct Modint {
    unsigned int x;
    Modint() = default;
    Modint(unsigned int x) : x(x) {}
    friend istream& operator>>(istream& in, Modint& a) {return in >> a.x;}
    friend ostream& operator<<(ostream& out, Modint a) {return out << a.x;}
    friend Modint operator+(Modint a, Modint b) {return down<mod>(a.x + b.x);}
    friend Modint operator-(Modint a, Modint b) {return down<mod>(a.x - b.x + mod);}
    friend Modint operator*(Modint a, Modint b) {return 1ULL * a.x * b.x % mod;}
    friend Modint operator/(Modint a, Modint b) {return a * ~b;}
    friend Modint operator^(Modint a, int b) {Modint ans = 1; for(; b; b >>= 1, a *= a) if(b & 1) ans *= a; return ans;}
    friend Modint operator~(Modint a) {return a ^ (mod - 2);}
    friend Modint operator-(Modint a) {return down<mod>(mod - a.x);}
    friend Modint& operator+=(Modint& a, Modint b) {return a = a + b;}
    friend Modint& operator-=(Modint& a, Modint b) {return a = a - b;}
    friend Modint& operator*=(Modint& a, Modint b) {return a = a * b;}
    friend Modint& operator/=(Modint& a, Modint b) {return a = a / b;}
    friend Modint& operator^=(Modint& a, int b) {return a = a ^ b;}
    friend Modint& operator++(Modint& a) {return a += 1;}
    friend Modint operator++(Modint& a, int) {Modint x = a; a += 1; return x;}
    friend Modint& operator--(Modint& a) {return a -= 1;}
    friend Modint operator--(Modint& a, int) {Modint x = a; a -= 1; return x;}
    friend bool operator==(Modint a, Modint b) {return a.x == b.x;}
    friend bool operator!=(Modint a, Modint b) {return !(a == b);}
};

const int N = 2e5 + 5;

int n, k, a[N], fa[N], son[N], vis[N];
ll val[N], ans;
vector<int> e[N];
vector<ll> v;

void dfs(int u, int f) {
    fa[u] = f;
    for(int v : e[u]) {
        if(v == f) continue;
        dfs(v, u);
        if(val[v] > val[son[u]]) son[u] = v;
    }
    val[u] = val[son[u]] + a[u];
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    cin >> n >> k;
    rep(i, 1, n) cin >> a[i];
    rep(i, 1, n - 1) {
        int u, v;
        cin >> u >> v;
        e[u].push_back(v);
        e[v].push_back(u);
    }
    dfs(1, 0);
    rep(i, 1, n) vis[son[i]] = 1;
    rep(i, 1, n) if(!vis[i]) v.push_back(val[i]);
    nth_element(v.begin(), v.begin() + k, v.end(), greater<ll>());
    rep(i, 0, min(k, (int)v.size()) - 1) ans += v[i];
    cout << ans << endl;
    return 0;
}
```

---

## 作者：_Dolphin_ (赞：9)

[题目传送门](https://www.luogu.com.cn/problem/P10641)

## Solution

长链剖分大佬们都将的很清楚了，我就来补一发左偏树吧。

我们可以每个节点建一个大根堆，然后自底向上合并。

因为每个节点对答案的贡献最多只有一次，我们可以 dfs 一遍，把 $x$ 的子树合并完后，将 $x$ 的权值加到左偏树的堆顶元素上即可。

其实就是将每一层的最大元素连成一条链。

最后的左偏树中取前 $k$ 大求和即为解。

比如这棵树（样例），$k=2$：

![](https://cdn.luogu.com.cn/upload/image_hosting/9li507ah.png)

我们先将最底层的 $3$ 和 $4$ 合并，得到堆护的序列 $2,1$。

然后将 $2$ 的权值加到堆顶元素上，序列变为 $5,1$。

再将 $2$ 和 $5$ 合并，得到序列 $5,1,1$。

最后将 $1$ 的权值加到堆顶元素上，序列变为 $9,1,1$。

取前 $2$ 个元素求和就可以得到答案 $10$。

其中 $9$ 表示 $1,2,3$ 这条链，$1$ 表示 $5$ 或 $4$ 这条链。

### Code(100 pts):

```cpp
#include<bits/stdc++.h>
#define afor(x,y,z) for(int x=y;x<=z;x++)
#define bfor(x,y,z) for(int x=y;x>=z;x--)
#define cfor(x,y) for(int x=head[y];x;x=nxt[x])
using namespace std;
typedef long long ll;
typedef const int cint;
cint N=2e5+10;
ll n,k,rt,ans,v[N],w[N],d[N],lson[N],rson[N];
ll tot,head[N],to[N],nxt[N];
void add(ll x,ll y) {
	to[++tot]=y;
	nxt[tot]=head[x];
	head[x]=tot;
}
ll merge(ll x,ll y) {
	if(!x||!y) return x+y;
	if(w[x]<w[y]) swap(x,y);
	rson[x]=merge(rson[x],y);
	if(d[lson[x]]<d[rson[x]])
		swap(lson[x],rson[x]);
	d[x]=d[rson[x]]+1;
	return x;
}
ll dfs(ll x) {
	ll ret=0;
	cfor(i,x) {
		ll y=dfs(to[i]);
		if(y) ret=merge(ret,y);
		else ret=merge(ret,to[i]);
	}
	if(ret) w[ret]+=w[x];
	return ret;
}
int main() {
	scanf("%lld%lld",&n,&k);
	afor(i,1,n) scanf("%lld",&w[i]);
	afor(i,1,n-1) {
		ll x,y;
		scanf("%lld%lld",&x,&y);
		add(x,y),v[y]=1;
	}
	afor(i,1,n) if(!v[i]) rt=i;
	ll heap=dfs(rt);
	afor(i,1,k) {
		ans+=w[heap];
		heap=merge(lson[heap],rson[heap]);
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：q1uple (赞：7)

今天学习了长链剖分啊，所以来写篇题解。

前置芝士：重链剖分。

长链剖分与重链剖分相似，只不过“重儿子”变成了表示其子节点中子树深度最大的子结点。

类似于重链剖分，我们可以得到一份求“重儿子”的代码

```cpp
void dfs(int u,int fa){
	f[u]=fa;
	for(int i=h[u];i;i=g[i].nxt){
		int v=g[i].v;
		if(v==fa) 	continue;	
		dfs(v,u);
		if(len[v]>len[son[u]])	son[u]=v;
	}
	len[u]=len[son[u]]+1;
}
```

回到这道题，我们考虑贪心。一种比较容易想到的做法是找到权值最大的路径，然后赋为 $0$，重复 $k$ 次即可，但复杂度我们是不能接受的。

考虑用长链剖分优化，实际上，这只是带了权值而已，我们把它放到树上，然后去出所有的链顶（这样并不会重复），排序取前 $k$ 个值即可。

### code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=3e6+6,mod=1e9+7,INF=2e9;
typedef unsigned long long ull;
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<double,double> pdd;
#define qmi(a,b) a=min(a,b)
#define qma(a,b) a=max(a,b)
#define rep(i,l,r) for(int i=(l);i<=(r);i++)
#define atrep(i,l,r) for(int i=(r);i>=(l);i--)
int n,k;
int a[N];
struct node{
	int nxt,v;
}g[N];
int h[N],idx=0;
void add(int a,int b){
	g[++idx].nxt=h[a],g[idx].v=b,h[a]=idx;
}
int len[N],son[N],f[N];
void dfs(int u,int fa){
	f[u]=fa;
	for(int i=h[u];i;i=g[i].nxt){
		int v=g[i].v;
		if(v==fa) 	continue;	
		dfs(v,u);
		if(len[v]>len[son[u]])	son[u]=v;
	}
	len[u]=len[son[u]]+a[u];
}
int top[N];
void df5(int u,int tf){
	top[u]=tf;
	if(!son[u])	return;
	df5(son[u],tf);
	for(int i=h[u];i;i=g[i].nxt){
		int v=g[i].v;
		if(v==f[u]||v==son[u])	continue;
		df5(v,v);
	}
}


signed main(){
	cin>>n>>k;
	rep(i,1,n)	cin>>a[i];
	rep(i,1,n-1){
		int a,b;
		cin>>a>>b;
		add(a,b);add(b,a);
	}
	dfs(1,0);
	df5(1,1);
	vector<int>vec;
	rep(i,1,n){
		if(top[i]==i)	vec.push_back(len[i]);
	}
	sort(vec.begin(),vec.end());
	reverse(vec.begin(),vec.end());
	int res=0;
	rep(i,0,k-1){
		res+=vec[i];
	}
	cout<<res<<"\n";
}
```

---

## 作者：gyyyyx (赞：4)

很容易想到一个贪心策略：每次选贡献最大的一个叶子节点，并将其到根的路径上所有点权值清零。

简单证明一下，显然权值为 $0$ 的点一定会形成一棵树，假设我们一直不选此叶子结点最终形成了树 $T$，设此叶子结点到根的路径点集为 $A$。

那我们一定能在 $T$ 上找到一条叶子到根的路径 $B$，使得 $A-A\cup B\notin T$。

设 $A'=A-A\cup B,B'=B-A\cup B$

我们由于 $A$ 的贡献最大，因此 $A$ 的点权和大与 $B$ 的点权和，那我们减去 $A'$ 的点权和也必定大于 $B'$ 的点权和。

而 $A'\notin T$ 上，而 $B'\in T$，那么选 $A'$ 必然优于 $B'$，则 $T$ 必然不是最优的，得证。

手动模拟选取过程，我们发现一条从叶子到根的路径相当于一条从叶子到其上方第一个非 $0$ 节点的路径，因为再往上都是 $0$。

感觉很熟悉？树链剖分！

这里我们设重儿子为子树深度最大的儿子，其中子树深度指子树根到叶子节点的点权和最大值。

这样我们找的就是前 $k$ 长的重链的长度和。

代码：

```cpp
#include<bits/stdc++.h>
#define LL long long
#define N 200005
using namespace std;
int n,k;LL val[N];
bool In[N];int rt;
struct Edge{
	int nxt,to;
	Edge(int a=0,int b=0):nxt(a),to(b){}
};
struct Edge e[N];
int head[N],cnt;
inline void AddEdge(int x,int y){
	e[++cnt]=Edge(head[x],y);head[x]=cnt;
}
LL dep[N];int tot;
void DFS(int u){
	int son(0);
	for(int i(head[u]);i;i=e[i].nxt){
		int v(e[i].to);DFS(v);
		if(val[v]>val[son]) son=v;
	}
	val[u]+=val[son];
	for(int i(head[u]);i;i=e[i].nxt){
		int v(e[i].to);
		if(v^son) dep[++tot]=val[v];
	}
}
LL ans;
int main(){
	scanf("%d%d",&n,&k);
	for(int i(1);i<=n;++i) scanf("%lld",&val[i]);
	for(int i(1);i<n;++i){
		int u,v;scanf("%d%d",&u,&v);
		AddEdge(u,v);In[v]=1;
	}
	for(int i(1);i<=n&&!rt;++i) if(!In[i]) rt=i;
	DFS(rt);dep[++tot]=val[1];sort(dep+1,dep+1+tot);
	for(int i(1);i<=k;++i) ans+=dep[tot-i+1];
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：lyas145 (赞：3)

题目在[这里](https://www.luogu.com.cn/problem/P10641)。

### 解题思路

一眼看上去，好像普通的重链剖分和长链剖分都做不了。确实，我们需要换一种剖法。

众所周知，我们把一棵树剖分成若干个链后，这些链是没有相同的节点的，是不是跟题目要求的同一场景观看多次不会重复得到价值一样？

我们再来看看怎么剖分比较好。

如下图（这是改了一下的样例）：

![](https://cdn.luogu.com.cn/upload/image_hosting/nmiyilmk.png)

~~我已经尽量让它好看了~~

红色的数是点权，黑色的数是节点编号。

若我们贪心地去想，我们肯定是先选编号为 $3$ 的叶子节点到根的简单路径，也就是被绿色类四边形物框起来的那条链。然后找第二大的，不难发现是编号为 $4$ 的叶子节点到根的简单路径，但有效部分只是被蓝色类四边形物框起来的那一条链，哎？这两条链似乎都有一个共同的特点：它们都是目前根到叶子结点的简单路径上有效节点的点权和最大的，并且链上不包括无效节点。

~~好像是根到叶子结点，反正反着来也没事。~~

于是我们可以尝试以当前点到以它为根的子树中的叶子结点的路径上节点的点权和最大的那个路径为根据（可能有点绕），进行树链剖分，再把每条链上节点的点权和排个序，把链上节点的点权和前 $k$ 大的加起来就行了。

代码里也有些注释。

### 码儿

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
typedef long long ll;
const int N=2e5+5;
int n,k,rt,cnt;
ll ans;
ll w[N],siz[N];
int fa[N],dep[N],son[N];
int h[N],e[N],ne[N],idx=1;
void add(int a,int b) {
	e[idx]=b;ne[idx]=h[a];h[a]=idx++;
}
void dfs1(int u,int fath) {
	dep[u]=dep[fath]+1;
	fa[u]=fath;
	for (int i=h[u];i;i=ne[i]) {
		int v=e[i];
		if (v==fath) {continue;}
		dfs1(v,u);
		siz[u]=max(siz[u],siz[v]);
//找 u 到以 u 为根节点的子树中的叶子结点的路径中经过节点的点权和最大的那个。
		if (siz[v]>siz[son[u]]) {son[u]=v;}
	}
	siz[u]+=w[u]; //别忘了加上 u 自己的点权！
}
void dfs2(int u) {
	if (son[u]) {dfs2(son[u]);}
	for (int i=h[u];i;i=ne[i]) {
		int v=e[i];
		if (v==fa[u] || v==son[u]) {continue;}
		w[++cnt]=siz[v];
//v 是它所在链上深度最小的节点，这样可以不重复地加入每一条链上节点的点权和（除了根所在的链）。
		dfs2(v);
	}
} 
int main() {
	scanf("%d%d",&n,&k);
	for (int i=1;i<=n;i++) {scanf("%lld",&w[i]);}
	for (int i=1;i<n;i++) {
		int u,v;
		scanf("%d%d",&u,&v);
		fa[v]=u;
		add(u,v);
	}
	for (int i=1;i<=n;i++) {
		if (!fa[i]) {rt=i;}  //找根。
	}
	dfs1(rt,0);  //w 在这之后它存的点权就没用了，所以后面我用 w 数组存的链上节点的点权和。
	dfs2(rt);
	w[++cnt]=siz[rt];  //根节点所在链上节点的点权和在 dfs 中加不上，需要在这加上。
	sort(w+1,w+1+cnt,greater<ll>());  //排序（降序）。
	for (int i=1;i<=k;i++) {ans+=w[i]; }
	printf("%lld\n",ans);
	return 0;
}
```

~~本人很蒟，可能用词不严谨，轻喷。~~

Thanks for reading！

---

## 作者：Genius_Star (赞：3)

### 思路：

~~简单板子题，不知道为啥要搬过来……~~

明显有一个贪心的思路：

- 每次取叶子到根的路径权值和最大的。

- 清空该链上的点的点权。

模拟 $k$ 次即可，但是复杂度不可取，考虑数据结构优化。

将叶子节点按 dfn 序从小到大编号，令 $l_u,r_u$ 表示 $u$ 子树内叶子节点的编号在 $[l_u,r_u]$ 间。

每次找到路径权值和最大的那个叶子节点，可以直接暴力跳父亲清空路径上的点，每次清空就是将区间 $[l_u,r_u]$ 内的叶子结点到根的权值和减去 $w_u$。

若遇到一个点已经被清空了，故该点到根节点路径上的点肯定也被清空了，就可以直接退出了；这样每个点做多只会清空一次。

考虑使用线段树维护上述操作，时间复杂度均摊为 $O(N \log N)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#define Add(x,y) (x+y>=mod)?(x+y-mod):(x+y)
#define lowbit(x) x&(-x)
#define full(l,r,x) for(auto it=l;it!=r;it++) (*it)=x
#define open(s1,s2) freopen(s1,"r",stdin),freopen(s2,"w",stdout);
using namespace std;
typedef long long ll;
typedef double db;
mt19937 R(time(0));
const ll N=200200; 
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
struct Node{
	ll l,r;
	ll tag;
	ll Max;
	ll id;
}X[N<<2];
ll n,k,cnt,ans;
ll a[N],w[N],l[N],r[N],d[N],id[N],fa[N];
vector<ll> E[N];
void add(ll u,ll v){
	E[u].push_back(v);
	E[v].push_back(u);
}
void dfs(ll u,ll f){
	l[u]=n,r[u]=1;
	bool F=1;
	for(auto v:E[u]){
		if(v==f)
		  continue;
		fa[v]=u;
		d[v]=d[u]+w[v];
		dfs(v,u);
		l[u]=min(l[u],l[v]);
		r[u]=max(r[u],r[v]);
		F=0;
	}
	if(F){
		id[++cnt]=u;
		l[u]=r[u]=cnt;
		a[cnt]=d[u];
	}
}
void pushup(ll k){
	X[k].Max=max(X[k<<1].Max,X[k<<1|1].Max);
	if(X[k].Max==X[k<<1].Max)
	  X[k].id=X[k<<1].id;
	else
	  X[k].id=X[k<<1|1].id;
}
void update(ll k,ll v){
	X[k].Max+=v;
	X[k].tag+=v;
}
void push_down(ll k){
	if(X[k].tag){
		update(k<<1,X[k].tag);
		update(k<<1|1,X[k].tag);
		X[k].tag=0;
	}
}
void build(ll k,ll l,ll r){
	X[k].l=l,X[k].r=r;
	if(l==r){
		X[k].Max=a[l];
		X[k].id=l;
		return ;
	}
	ll mid=(l+r)>>1;
	build(k<<1,l,mid);
	build(k<<1|1,mid+1,r);
	pushup(k);
}
void update(ll k,ll l,ll r,ll v){
	if(X[k].l==l&&r==X[k].r){
		update(k,v);
		return ;
	}
	push_down(k);
	ll mid=(X[k].l+X[k].r)>>1;
	if(r<=mid)
	  update(k<<1,l,r,v);
	else if(l>mid)
	  update(k<<1|1,l,r,v);
	else{
		update(k<<1,l,mid,v);
		update(k<<1|1,mid+1,r,v);
	}
	pushup(k);
}
void solve(ll u){
	while(w[u]){
		update(1,l[u],r[u],-w[u]);
		w[u]=0;
		u=fa[u];
	}
}
int main(){
	n=read(),k=read();
	for(int i=1;i<=n;i++)
	  w[i]=read();
	for(int u,v,i=1;i<n;i++){
		u=read(),v=read();
		add(u,v);
	}
	d[1]=w[1];
	dfs(1,0);
	build(1,1,cnt);
	while(k--){
		if(!X[1].Max)
		  break;
		ans+=X[1].Max;
		solve(id[X[1].id]);
	}
	write(ans);
	return 0;
}
```

---

## 作者：xiao7_Mr_10_ (赞：2)

好的如你所见，这道题让我们多条从根到叶节点的路径和最大值，初步想法就是每次我们直接选取某一个路径和最大的叶节点进行修改即可。

显而易见这是对的，然后我们考虑修改的问题。

令 $a_{i}$ 为 $i$ 节点的权值。

考虑线段树，开一个数组每个节点记录这个节点 $i$ 到根节点的距离，线段树维护最大值和最大值所处位置，然后我们肯定是只考虑维护叶子节点，但是没有必要，因为所有叶子节点的答案不会比它的父亲乃至于祖先们劣。

所以每次修改就相当于把 $i$ 节点所管辖的子树值全体减去 $a_{i}$。

对于每个节点我们只会修改一次，所以直接暴力跳链修改每个点，遇到一个已经修改过的点直接退出，这样就能保证每个点只会被修改一次。

时间复杂度 $O(n\log n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e6+5;
struct tree{
	int maxn,id;
}c[N<<2];
vector <int> e[N];
int n,a[N],u,v,tag[N],f[N],b[N],d[N],cnt,siz[N],dfn[N],pos[N];
void dfs(int u,int fa){
	siz[u]=1,pos[u]=++cnt,d[cnt]=b[u],dfn[cnt]=u;
	for(int i = 0;i < e[u].size();i++){
		int v=e[u][i];
		if(v==fa)continue;
		f[v]=u,b[v]=b[u]+a[v];
		dfs(v,u);
		siz[u]+=siz[v];
	}
}
tree merge(tree x,tree y){
	if(x.maxn>=y.maxn)return x;
	return y;
}
void updata(int x){
	c[x]=merge(c[x<<1],c[x<<1|1]);
}
void build(int x,int l,int r){
	if(l==r){
		c[x].maxn=d[l],c[x].id=l;
		return;
	}
	int mid=(l+r)>>1;
	build(x<<1,l,mid);
	build(x<<1|1,mid+1,r);
	updata(x);
}
void down(int x){
	c[x<<1].maxn+=tag[x],c[x<<1|1].maxn+=tag[x];
	tag[x<<1]+=tag[x],tag[x<<1|1]+=tag[x];
	tag[x]=0; 
}
void change(int x,int l,int r,int s,int t,int k){
	if(l>=s&&r<=t){
		c[x].maxn+=k;
		tag[x]+=k;
		return;
	}
	down(x);
	int mid=(l+r)>>1;
	if(s<=mid)change(x<<1,l,mid,s,t,k);
	if(t>mid)change(x<<1|1,mid+1,r,s,t,k);
	updata(x);
}
tree query(int x,int l,int r,int s,int t){
	if(l>=s&&r<=t)return c[x];
	int mid=(l+r)>>1;
	down(x);
	if(s>mid)return query(x<<1|1,mid+1,r,s,t);
	else{
		if(t<=mid)return query(x<<1,l,mid,s,t);
		return merge(query(x<<1,l,mid,s,t),query(x<<1|1,mid+1,r,s,t));
	}
}
int k,vis[N],ans;
void work(int x){
	while(x&&!vis[x]){
		vis[x]=1;
		change(1,1,n,pos[x],pos[x]+siz[x]-1,-a[x]);
		x=f[x];
	}
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> k;
	for(int i = 1;i <= n;i++)cin >> a[i];
	for(int i = 1;i < n;i++){
		cin >> u >> v;
		e[u].push_back(v);
		e[v].push_back(u);
	}
	b[1]=a[1];
	dfs(1,0);
	build(1,1,n);
	for(int i = 1;i <= k;i++){
		tree tmp=c[1];
		ans+=tmp.maxn;
		work(dfn[tmp.id]);	
	}
	cout << ans;
	return 0;
}
```

---

## 作者：lilong (赞：1)

有一个显然的贪心，即每次都取剩余权值和最大的一条路径。由于每个点的权值都只计算一次，因此这样做能够确保前 $k$ 次得到的答案最大。假如不取大的而先取小的，那么答案一定不会优于前者（大的可能没取到），从而保证了贪心的正确性。

接下来考虑如何维护最大值。每一次求出最大值后，同时记录最大值对应的点的编号。对于一个点 $u$，它的权值 $w_u$ 被取走后将会导致以 $u$ 为根的子树中每个点的总权值减少 $w_u$。子树修改？使用 dfs 序加线段树维护即可！

但是如果我们每次都暴力修改会超时。注意到每个权值只能用一次，也就是说只有一次修改是有效的！那么我们使用一个标记数组记录每个点是否被修改，遇到一个点已经被修改时，说明它的祖先也已经修改了（因为都是向根节点跳），直接退出即可。

总时间复杂度 $O((n+k)\log n)$。


```cpp
#include <iostream>
#include <cstdio>
#include <vector>
#define int long long

using namespace std;

vector<int> G[200001];
int n,k,a[200001],w[200001],Lx[200001],Rx[200001],rev[200001],fa[200001],vis[200001],tot,ans;

struct T
{
	int mx,lzy,id;
}t[1000001];

void pushdown( int u )
{
	if( t[u].lzy )
	{
		t[u << 1].mx += t[u].lzy;
		t[u << 1].lzy += t[u].lzy;
		t[u << 1 | 1].mx += t[u].lzy;
		t[u << 1 | 1].lzy += t[u].lzy;
		t[u].lzy = 0;
	}
	return;
}

void pushup( int u )
{
	if( t[u << 1].mx >= t[u << 1 | 1].mx ) t[u].mx = t[u << 1].mx,t[u].id = t[u << 1].id;
	else t[u].mx = t[u << 1 | 1].mx,t[u].id = t[u << 1 | 1].id;
	return;
}

void dfs( int u , int f )
{
	fa[u] = f;
	Lx[u] = ++ tot;
	rev[tot] = u;
	a[u] += w[u];
	for( auto v : G[u] )
	{
		if( v == f ) continue;
		a[v] += a[u];
		dfs( v , u );
	}
	Rx[u] = tot;
}

void build( int u , int l , int r )
{
	if( l == r )
	{
		t[u].mx = a[rev[l]];
		t[u].id = rev[l];
		return;
	}
	int mid = ( l + r ) >> 1;
	build( u << 1 , l , mid );
	build( u << 1 | 1 , mid + 1 , r );
	pushup( u );
}

void update( int u , int l , int r , int L , int R , int x )
{
	if( L <= l && r <= R )
	{
		t[u].mx += x;
		t[u].lzy += x;
		return;
	}
	pushdown( u );
	int mid = ( l + r ) >> 1;
	if( L <= mid ) update( u << 1 , l , mid , L , R , x );
	if( R > mid ) update( u << 1 | 1 , mid + 1 , r , L , R , x );
	pushup( u );
}

T ma( T x , T y )
{
	if( x.mx >= y.mx ) return x;
	return y;
}

T query( int u , int l , int r , int L , int R )
{
	if( L <= l && r <= R )
		return t[u];
	pushdown( u );
	int mid = ( l + r ) >> 1;
	T res;
	res.mx = 0;
	if( L <= mid ) res = ma( res , query( u << 1 , l , mid , L , R ) );
	if( R > mid ) res = ma( res , query( u << 1 | 1 , mid + 1 , r , L , R ) );
	return res;
}

signed main()
{
	int u,v,nw;
	T tt;
	cin >> n >> k;
	for( int i = 1 ; i <= n ; i ++ )
		cin >> w[i];
	for( int i = 1 ; i < n ; i ++ )
	{
		cin >> u >> v;
		G[u].push_back( v );
		G[v].push_back( u );
	}
	dfs( 1 , -1 );
	build( 1 , 1 , n );
	for( int i = 1 ; i <= k ; i ++ )
	{
		tt = query( 1 , 1 , n , 1 , n );
		ans += tt.mx;
		nw = tt.id;
		while( nw != -1 )
		{
			if( vis[nw] ) break;
			vis[nw] = 1;
			update( 1 , 1 , n , Lx[nw] , Rx[nw] , -w[nw] );
			nw = fa[nw];
		}
	}
	cout << ans;
	return 0;
}
```

---

## 作者：Redshift_Shine (赞：1)

## 闲话

这题是我随机到的。

## 思路

显然我们需要在每次选择中尽可能选取最长的一条链来统计权值。

为了达到这一目的，我们需要进行长链剖分。

长链剖分与重链剖分唯一的不同是前者使用到叶子结点的权值进行排序而后者使用子树权值进行排序。

最终选取权值最大的 $k$ 条链即可。

时间复杂度 $O(n)$。

## 代码

```c++
#include <algorithm>
#include <cstdio>
#include <vector>
using namespace std;
const int N = 2e5 + 10;
int n, k, a[N], ds[N], rt = 1, idx;
using ll = long long;
ll lnk[N], res[N], ret;
vector<int> road[N];
bool vis[N];
void dfs1(int x)
{
    for (auto &i : road[x])
    {
        dfs1(i);
        if (lnk[i] > lnk[ds[x]])
            ds[x] = i;
    }
    lnk[x] = lnk[ds[x]] + a[x];
}
void dfs2(int x, int tp)
{
    if (x == tp)
        res[++idx] = lnk[x];
    if (!ds[x])
        return;
    dfs2(ds[x], tp);
    for (auto &i : road[x])
    {
        if (i == ds[x])
            continue;
        dfs2(i, i);
    }
}
int main()
{
    scanf("%d%d", &n, &k);
    for (int i = 1; i <= n; i++)
    {
        scanf("%d", a + i);
    }
    for (int i = 1, x, y; i < n; i++)
    {
        scanf("%d%d", &x, &y);
        road[x].emplace_back(y);
        vis[y] = true;
    }
    while (vis[rt])
        rt++;
    dfs1(rt);
    dfs2(rt, rt);
    sort(res + 1, res + idx + 1);
    for (int i = 0; i < idx and i < k; i++)
    {
        ret += res[idx - i];
    }
    printf("%lld\n", ret);
}
```

---

## 作者：CompileEasily (赞：1)

## P10641 BZOJ3252 攻略

[题目传送门](https://www.luogu.com.cn/problem/P10641)

长链剖分板子。

### 前置知识

[P3384 【模板】重链剖分/树链剖分](https://www.luogu.com.cn/problem/P3384)。

长链剖分只需稍微修改树剖的 DFS1 即可。

### 题意

给定一个有 $n$ 个结点的树，树有点权且点权为正整数。现选取 $k$ 条从根结点出发到叶子结点的简单路径，求这些路径的**并集**上所有结点的点权之和的最大值。

>给定两个集合 A 和 B，把他们所有的元素合并在一起组成的集合叫做它们的并集。——百度百科

### 分析

看到求 $k$ 条从叶子到根的链的点权和最大值，同时还要去重，考虑**长链**剖分，贪心地选出权值前 $k$ 大的链求和，即为答案。

### code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 2e5 + 5;
int n,k;
int a[N];
int fa[N],siz[N],son[N],top[N],cnt = 0;
vector<int> adj[N];
priority_queue<int> q;
inline void dfs1(int u,int fat)
{
	fa[u] = fat,son[u] = 0,siz[u] = a[u];
	for(int v : adj[u])
	{
		if(v == fat) continue;
		dfs1(v,u);
		siz[u] = max(siz[u],siz[v] + a[u]);
		if(siz[son[u]] < siz[v]) son[u] = v;
	}
}
inline void dfs2(int u,int tp)
{
	top[u] = tp;
	if(!son[u]) return;
	dfs2(son[u],tp);
	for(int v : adj[u]) if(v != fa[u] && v != son[u]) dfs2(v,v);
}
signed main()
{
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin >> n >> k;
	for(int i = 1;i <= n;i++) cin >> a[i];
	for(int i = 1,u,v;i < n;i++)
	{
		cin >> u >> v;
		adj[u].push_back(v),adj[v].push_back(u);
	}
	dfs1(1,0),dfs2(1,1);
	for(int i = 1;i <= n;i++)
	{
		if(top[i] == i)
		{
			q.push(siz[i]);
         	//若节点的 top 是它本身，即它是一条长链的链首
            //就将以它为根节点的子树的长链的点权和 push 进优先队列
		}
	}
	int ans = 0;
	for(int i = 1;i <= k && !q.empty();i++)
	{
		ans += q.top();
		q.pop();
	}
	cout << ans;
}
```

---

## 作者：kkxacj (赞：0)

#### 思路

由于是求并集，说明每个点**最多会被算一次贡献**，考虑维护每个点到 $1$ 经过的点的点权和是多少，假设我选了一条 $1$ 到 $x$ 的，我们考虑把 $1$ 到 $x$ 之间的点权和加进答案，然后对于**所有第一次被算贡献的点**的权值删掉。

因为每个点对多被删贡献一次，而且一定是**从 $1$ 到一个点的简单路径间的所有点都被删掉贡献**，也就是说我们可以直接一直跳父亲删贡献然后标记一下就行。

考虑用线段树维护全局最大值/全局最大值位置，树剖后从最大值位置出发一直跳父亲子树修改就行了，时间复杂度是一只 $\log$，可以通过。

**code**

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mhd = 1e6 + 10;
int n,k,m,p,a[mhd],son[mhd],cnt,op,x,y,z,siz[mhd],dep[mhd],fat[mhd],sum,sum1,v[mhd],ans,xa1[mhd];
int bx,by;
int head[mhd];
struct w1
{
	int ad,mx,col,l,r;
}c[mhd];
struct w
{
	int to,nxt;  
}b[mhd];
int xa[mhd],ba[mhd],bj[mhd]; 
void biuld(int p,int l,int r)
{
	c[p].l = l,c[p].r = r;
	if(l == r)
	{
		c[p].mx = xa[l],c[p].col = ba[l];
		return;
	}
	int mid = (l + r) / 2;
	biuld(p * 2,l,mid); biuld(p * 2 + 1,mid + 1,r);
	if(c[p*2].mx > c[p*2+1].mx) c[p].col = c[p*2].col;
	else c[p].col = c[p*2+1].col;
	c[p].mx = max(c[p*2].mx,c[p*2+1].mx);
}
void lazy(int p)
{
	c[p * 2].ad += c[p].ad; c[p * 2 + 1].ad += c[p].ad;
	c[p * 2].mx -= c[p].ad;
	c[p * 2 + 1].mx -= c[p].ad;
	c[p].ad = 0;
}
void change(int p,int l,int r,int k)
{
	if(l <= c[p].l && c[p].r <= r)
	{
		c[p].ad += k;
		c[p].mx -= k;
		return;
	}
	if(c[p].ad) lazy(p);
	int mid = (c[p].l + c[p].r) / 2;
	if(l <= mid) change(p*2,l,r,k);
	if(mid < r) change(p*2 + 1,l,r,k); 
	if(c[p*2].mx > c[p*2+1].mx) c[p].col = c[p*2].col;
	else c[p].col = c[p*2+1].col;
	c[p].mx = max(c[p*2].mx,c[p*2+1].mx);
}
void ask(int p,int l,int r)
{
	if(l <= c[p].l && c[p].r <= r)
	{
		if(c[p].mx > sum) sum1 = c[p].col;
		sum = max(sum,c[p].mx);
		return;
	}
	if(c[p].ad) lazy(p);
	int mid = (c[p].l + c[p].r) / 2;
	if(l <= mid) ask(p * 2,l,r);
	if(mid < r) ask(p * 2 + 1,l,r); 
}
void add(int x,int y)
{
	b[++cnt].to = y;
	b[cnt].nxt = head[x];
	head[x] = cnt;
}
void dfs(int x,int y,int fa)
{
	siz[x] = 1,dep[x] = y; fat[x] = fa;
	for(int i = head[x];i;i = b[i].nxt)
	{
		if(b[i].to != fa) 
		{
			dfs(b[i].to,y + 1,x),siz[x] += siz[b[i].to];
			if(siz[b[i].to] > siz[son[x]]) son[x] = b[i].to; 
		}
	}
}
void dfs1(int x,int y,int fa,int z)//重链，重新构造链 
{
	bj[x] = ++cnt;
	xa[cnt] = z; xa1[cnt] = a[x];//映射 
	ba[cnt] = x;
	if(!son[x]) return;
	dfs1(son[x],y,x,z+a[son[x]]);
	for(int i = head[x];i;i = b[i].nxt)
		if(b[i].to != fa && b[i].to != son[x]) 
			dfs1(b[i].to,b[i].to,x,z+a[b[i].to]);
}
void gx(int x)
{
	if(v[x] || x == 0) return;
	change(1,bj[x],bj[x]+siz[x]-1,xa1[bj[x]]);
	v[x] = 1,gx(fat[x]);
}
signed main()
{
	scanf("%lld",&n); scanf("%lld",&k);
	for(int i = 1;i <= n;i++) scanf("%lld",&a[i]);
	for(int i = 1;i < n;i++) 
	{
		scanf("%lld%lld",&x,&y);
		add(x,y); add(y,x); 
	}
	dfs(1,1,0);
	cnt = 0;
	dfs1(1,1,0,a[1]);
	biuld(1,1,n);
	for(int i = 1;i <= k;i++)
	{
		sum = sum1 = 0;
		ask(1,1,n);
		if(sum > 0)
		{
			ans += sum;
			gx(sum1);
		}
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：junee (赞：0)

# P10641 题解

## 前置知识

树链剖分。

## 题目分析

跟常规树链剖分不同的是，这题是按照儿子节点的链上点权和来取重儿子，将所有的链放到大根堆，然后依次取出前 $k$ 条链，统计答案。

## Code

```cpp
#include<iostream>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<queue>
using namespace std;
const int N=2e5+10;
typedef long long LL;
int h[N],e[N*2],ne[N*2],idx,w[N];
LL sz[N],dep[N],fa[N],son[N],top[N];
int root[N];
LL n,k,ans=0;
priority_queue<LL>q;
void add(int a,int b){
    e[idx]=b,ne[idx]=h[a],h[a]=idx++;
}
void dfs_son(int u,int d,int f){
    sz[u]=0,dep[u]=d,fa[u]=f;
    for(int i=h[u];~i;i=ne[i]){
        int j=e[i];
        if(j==f)continue;
        dfs_son(j,d+1,u);
        if(sz[j]>sz[son[u]])son[u]=j;
    }
    sz[u]=w[u]+sz[son[u]];
}
void dfs(int u,int t){
    top[u]=t;
    if(top[u]==u)q.push(sz[u]);
    if(!son[u])return;
    dfs(son[u],t);
    for(int i=h[u];~i;i=ne[i]){
        int j=e[i];
        if(j==fa[u]||j==son[u])continue;
        dfs(j,j);
    }
}
int main(){
    memset(h,-1,sizeof h);
    cin>>n>>k;
    for(int i=1;i<=n;i++)cin>>w[i];
    for(int i=1,a,b;i<n;i++){
        cin>>a>>b;
        add(a,b),add(b,a);
        root[b]=1;
    }
    for(int i=1;i<=n;i++){
        if(!root[i]){
            dfs_son(i,1,-1);
            dfs(i,i);
            break;
        }
    }
    while(k--){
        ans+=q.top(),q.pop();
    }
    cout<<ans;
    return 0;
}
```

---


# 【模板】可并堆 2

## 题目背景

感谢 @[Spasmodic](https://www.luogu.com.cn/user/121027) 提供初版数据生成器。

[gen](https://www.luogu.com.cn/paste/4vk36jsp)。

## 题目描述

给定正整数 $n$ 和 $m$ 以及一个长为 $n$ 的整数序列 $a_{1,\dots,n}$。

你需要维护序列 $a_{1,\dots,n}$ 以及 $n$ 个集合 $S_{1,\dots,n}$，初始时 $S_i=\{i\}$。

接下来要进行以下四种操作共 $m$ 次，每次操作形如：

- `0 x y`：表示将元素 $y$ 从集合 $S_x$ 中删去。保证此时元素 $y$ 在集合 $S_x$ 中。
- `1 x`：表示询问 $\min_{i\in S_x} a_i$，保证此时集合 $S_x$ 非空。
- `2 x y`：将集合 $S_y$ 中并入 $S_x$ 并清空集合 $S_y$。保证此时集合 $S_x,S_y$ 均非空，且此次操作后不会再出现涉及集合 $S_y$ 的操作。
- `3 x y z`：表示将 $a_y$ 赋值为 $z$。保证此时元素 $y$ 在集合 $S_x$ 中，且 $z<a_y$。

不难发现这是一道堆的模板题，所以现在请你完成它。

## 说明/提示

对于 $20\%$ 的数据，$n=m=10$；

对于 $80\%$ 的数据，$n=m=10^5$；

对于 $100\%$ 的数据，$1\le n,m\le10^6$，$1\le a_i\le2\times10^9$，保证任意时刻任意堆中元素绝对值不超过 $10^{15}$（人话：保证每次 `3` 操作最多单点减 $5\times10^8$）。

---

最后两个点出题人的手写堆和 pbds 的配对堆都跑到了几百毫秒，如果有被卡常的可私。

## 样例 #1

### 输入

```
5 5
1 2 3 4 4
2 4 5
3 4 5 3
1 4
0 4 5
1 4```

### 输出

```
3
4```

# 题解

## 作者：ikunTLE (赞：12)

[题目传送门](https://www.luogu.com.cn/problem/P11266)

### 思路

可以使用 pb_ds 库中的 `priority_queue` 来解决。

与标准库中的 `priority_queue` 相同，pb_ds 库中也实现了一个堆。不同的是，pd_ds 库中增加了删除和修改的操作。

下面介绍一下 `priority_queue` 的基本语法。

`priority_queue` 的头文件在 `bits/extc++.h` 中，但由于它不是一个标准 STL 库，还需要引用命名空间 `__gnu_cxx`。

`priority_queue` 定义声明方式：`__gnu_pbds::priority_queue pq;`，在本题中会用到一下的操作：

- `pq.push(x)`：将数字 `x` 放入堆中。
- `pq.top()`：返回堆顶的元素。
- `pq.erase(it)`：将迭代器 `it` 从堆中消除。
- `pq1.join(pq2)`：将 `pq2` 放入 `pq1` 中，同时清空 `pq2`。
- `pq.modify(it,x)`：将堆中迭代器为 `it` 的值改为 `x`。

**AC CODE**

```cpp
#include<bits/stdc++.h>
#include<bits/extc++.h>
using namespace std;
using namespace __gnu_pbds;
int read(){int x=0;char f=1,ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();return x*f;}
const int N=1e6+10;
__gnu_pbds::priority_queue<int,greater<int>>pq[N];
__gnu_pbds::priority_queue<int,greater<int>>::point_iterator p[N];
int main(){
	int n=read(),m=read();
	for(int i=1;i<=n;++i){
		int x=read();
		p[i]=pq[i].push(x);
	}
	while(m--){
		int op=read();
		if(op==0){
			int x=read(),y=read();
			pq[x].erase(p[y]);
		}
		else if(op==1){
			int x=read();
			printf("%d\n",pq[x].top());
		}
		else if(op==2){
			int x=read(),y=read();
			pq[x].join(pq[y]);
		}
		else if(op==3){
			int x=read(),y=read(),z=read();
			pq[x].modify(p[y],z);
		}
	}
	return 0;
}
```

---

## 作者：bcdmwSjy (赞：10)

题解里怎么没人讲斐波那契堆呢，多优美的数据结构啊。

在这里我们要实现一个斐波那契堆，部分思路来自[此处](https://www.bilibili.com/video/BV1Wy8czTEJu)。

截至本文发布时，本人在此题中的代码为[最优解](https://www.luogu.com.cn/record/list?pid=P11266&orderBy=1&page=1)，已加入代码公开计划，但是强烈反对直接抄袭的行为。

首先我们要知道普通二叉堆都有哪些性质：

1. 是一个完全二叉树。

2. 没有孩子节点比父节点小。

这种堆插入元素，弹出最小值，减少元素的时间复杂度都为 $O(\log n)$，但我们能做到更快吗？

我们可以尝试实现一个最简单的堆——就是一个集合，里面放着存入的元素，还有一个指向最小元素的指针。这样获取最小值只需要访问指针指向的元素就行了，插入元素时就直接把它放进去，然后判断是否需要更新最小值指针，减少元素也非常简单。但是弹出最小值时就有问题了，问题不是弹出它，而是如何快速找到新的最小值。

为了做到这一点，集合需要一定的结构来让我们快速找到最小值。但如果使用二叉堆，我们每次操作后要维护两条性质。但为了加速，我们需要一个没那么严格的结构，尽可能懒一点，非必要就不进行操作，但我们还得能快速求出最小值。

我们首先要去掉的是二叉堆的第一条性质，我们允许任意形态的树，甚至还可以有很多树，这些树用链表穿在一起，称为根链表。每个节点的孩子也用链表存储，这样我们可以快速插入和删除值（以上的链表都是双向循环链表）。

由于我们仍然满足堆的第二条性质，于是整个堆的最小值一点是树根之一，维护一个指针指向它。

加入我们弹出了最小值，那么新的最小值一定是之前的最小值节点的孩子或者是其他的树根，我们遍历上述节点来找到新的最小值。着就需要我们树的总数和每个节点的孩子数量（以下称为度）都相对比较少。

我们来实现一些操作。

插入一个元素最简单的方法就是把只有根节点的树直接加到根链表里，然后更新最小值指针，这样就完成了 $O(1)$ 插入。合并两个堆只需要把它们的根链表并起来即可，时间复杂度 $O(1)$。但是下一次弹出最小值时需要遍历大量节点，因为根链表里的节点都有可能成为下一个最小值。

但是我们可以在弹出的同时把一些小树合并成大树，反正我们也要遍历所有的根节点，这不会使时间复杂度变高，但可以显著减少树的数量，使以后的操作变快。

我们举个例子看看这种方式的效果如何。

例如我们向堆里插入了 $100$ 个元素，然后弹出最小值，这会花费大量时间遍历所有根节点，但是后续的弹出操作会变得很快，因为我们清理了堆，使树根变少很多。

我们也可以从整体的角度分析，把弹出时遍历根的复杂度平均分到插入中，每个插入操作只会增加常数时间，但会使弹出操作的复杂度降低。

弹出最小值分为以下几步：

1. 把最小值的孩子放在根链表中。

2. 合并一些树。为了让树的度和树的个数都减少，我们可以不断合并相同度的树，直到每种度都只有一棵树。注意这个操作，这是保证复杂度的重要一步。

3. 重建堆。重新维护根链表并记录最小值。

第一步的复杂度为节点的最大度，第二步的复杂度为节点的最大度加树的个数，第三步的复杂度也为节点的最大度。

树的个数可以均摊到之前的插入里，所以复杂度取决于节点的最大度，只要最大度小，那操作就会快。

我们看看在特定度数下最大的数是什么样子的。我们每次合并两颗相同度的树，两颗 $0$ 度树（单点）合成 $1$ 度树，两颗 $1$ 度树合成 $2$ 度树……这样我们就得到了一些**二项树**。根据合并时的操作可以得出二项树的子树还是二项树。

在弹出最小值时，我们把最小值节点的孩子放进根链表，再合并相同度的树，所以这些树一定都是二项树。

二项树的大小是指数增长的，每棵树的节点数都是前一颗的二倍，一颗 $d$ 度树有 $2^d$ 个节点，所以 $n$ 个节点的堆只需要最大 $\log_2n$ 度的树就可以存下。

所以，弹出最小值的复杂度被优化到了 $O(\log n)$。

我们再来考虑如何减小一个元素的值。如果减小后不破坏堆的性质，那就什么都不用做，否则直接把它和它的子树扔进根链表里。

这看起来很好，清理时额外消耗的时间可以均摊到减小元素的操作上，但回顾我们之前的分析，弹出最小值的复杂度为对数是因为二项树的大小是指数增长的，但是如果我们随意把子树剪掉，那这些树就不是二项树了。最坏情况下 $d$ 度树只会有 $d+1$ 个节点，从对数增长变为了线性增长，这样弹出最小值的复杂度就出现了大问题。

如果我们不剪掉子树，那这样弹出最小值的复杂度是对了，但是减小元素却比较慢。如果我们剪掉子树，这样弹出最小值的复杂度可能很高。我们采取一种折中的方案，只允许一个节点剪掉一个孩子，剪掉一个孩子后就给它打上一个标记，如果再次给这个节点剪掉孩子就连带着把它自己也剪掉放在根链表里并取消标记。

这听起来不可思议，我们反而多剪掉了一些节点，但我们这么考虑：如果一棵树已经比它存的要少了，那么剪掉一些节点可能让它的度降低，这样就可以理所应当的存较少的节点了，这也使树不会离二项树太远。

我们来仔细分析一下复杂度：

假设我们减小了 $n$ 次元素，最坏情况下只会剪下 $2n$ 次节点，均摊一下每次复杂度还是 $O(1)$ 的。每次平均只会增加两棵树，再把弹出最小值的操作均摊到减小元素操作上，复杂度仍然为常数。

现在只要证明树的度是对数增长即可。

之前说到 $d$ 度树有 $2^d$ 个节点，所以度数是对数的，所以问题变为判断树是不是指数增长的。

但是有减小元素操作后，树的形态不再是固定的，我们需要证明最坏的情况下树也是指数增长的。

假设每次合并把新子树放在右侧，每次合并相同度的树，所以第 $i$ 个孩子至少有 $i-1$ 度，就算再被剪掉一个节点，也至少有 $i-2$ 度。

我们得出，一颗 $d$ 度树至少也是由 $0$ 度树加上 $0$ 到 $d-2$ 度树组成的。

设 $f_d$ 表示 $d$ 度数的最少的节点个数，根据上面的结论可以得出 $f_0=1,f_1=2,f_d=1+f_0+\sum\limits_{i=0}^{d-2}f_i$，我们发现 $f$ 其实是一个从 $1,2$ 开始的斐波那契数列。

斐波那契数列是指数增长的，树的大小也是指数增长的，所以弹出最小值的复杂度仍然为 $O(\log n)$。

最终，我们得到了完整的斐波那契堆，除了弹出最小值以外的操作的复杂度都是 $O(1)$ 的堆，并且弹出最小值的复杂度也相当优，达到了基于比较的排序算法的复杂度下界。

参考实现：

```cpp
class Node{
public:
	bool mark;
	int deg;
	ll key;
	Node *l,*r,*ch,*fa;
	Node(){
		key=deg=0,mark=false,l=this,r=this,ch=fa=nullptr;
	}
	Node(ll k){
		key=k,deg=0,mark=false,l=this,r=this,ch=fa=nullptr;
	}
};

class FibHeap{
	int cnt;
	Node *minp;
public:
	FibHeap(){
		cnt=0,minp=nullptr;
	}
private:
	void removep(Node *p){
		p->l->r=p->r;
		p->r->l=p->l;
	}
	void addp(Node *p,Node *rt){
		p->l=rt->l;
		rt->l->r=p;
		p->r=rt;
		rt->l=p;
	}
	Node* pushp(Node *p){
		if (cnt==0) minp=p;
		else{
			addp(p,minp);
			if (p->key<minp->key) minp=p;
		}
		cnt++;
		return p;
	}
	void megl(Node *u,Node *v){
		Node *t=u->r;
		u->r=v->r;
		v->r->l=u;
		v->r=t;
		t->l=v;
	}
	Node* removemin(){
		Node *t=minp;
		if (t==t->r) minp=nullptr;
		else{
			removep(t);
			minp=t->r;
		}
		t->l=t->r=t;
		return t;
	}
	void link(Node *p,Node *rt){
		removep(p);
		if (rt->ch==nullptr) rt->ch=p;
		else addp(p,rt->ch);
		p->fa=rt;
		p->mark=false;
		rt->deg++;
	}
	void megtrees(){
		int maxd=log(cnt)/log((1+sqrt(5))/2),n=maxd+1;
		Node **rt=new Node*[n];
		for (int i=0;i<n;i++) rt[i]=nullptr;
		while (minp!=nullptr){
			Node *u=removemin();
			int d=u->deg;
			for (;rt[d]!=nullptr;d++){
				Node *v=rt[d];
				if (u->key>v->key) swap(u,v);
				link(v,u);
				rt[d]=nullptr;
			}
			rt[d]=u;
		}
		minp=nullptr;
		for (int i=0;i<n;i++){
			if (rt[i]!=nullptr){
				if (minp==nullptr) minp=rt[i];
				else{
					addp(rt[i],minp);
					if (rt[i]->key<minp->key) minp=rt[i];
				}
			}
		}
		delete [] rt;
	}
	void cut(Node *p,Node *fa){
		removep(p);
		fa->deg--;
		if (p==p->r) fa->ch=nullptr;
		else fa->ch=p->r;
		p->fa=nullptr;
		p->l=p->r=p;
		p->mark=false;
		addp(p,minp);
	}
	void cutout(Node *p){
		p->mark=false;
		Node *fa=p->fa;
		if (fa!=nullptr){
			cut(p,fa);
			if (not fa->mark) fa->mark=true;
			else cutout(fa);
		}
	}
public:
	Node* push(ll k){
		return pushp(new Node(k));
	}
	void join(FibHeap *b){
		if (b==nullptr) return;
		if (minp==nullptr){
			minp=b->minp,cnt=b->cnt;
		}else if (b->minp!=nullptr){
			megl(minp,b->minp);
			if (minp->key>b->minp->key) minp=b->minp;
			cnt+=b->cnt;
		}
		b=nullptr;
	}
	void pop(){
		if (minp==nullptr) return;
		Node *m=minp;
		while (m->ch!=nullptr){
			Node *ch=m->ch;
			removep(ch);
			if (ch->r==ch) m->ch=nullptr;
			else m->ch=ch->r;
			addp(ch,minp);
			ch->fa=nullptr;
		}
		removep(m);
		if (m->r==m) minp=nullptr;
		else{
			minp=m->r;
			megtrees();
		}
		cnt--;
		m=nullptr;
	}
	ll top(){
		if (minp==nullptr) return 0;
		else return minp->key;
	}
	void decrease(Node *p,ll k){
		if (minp==nullptr or p==nullptr) return;
		p->key=k;
		Node *fa=p->fa;
		if (fa!=nullptr and p->key<fa->key) cutout(p);
		if (p->key<minp->key) minp=p;
	}
	void erase(Node *p){
		decrease(p,minp->key-1);
		pop();
	}
};
```

但是指针实现的斐波那契堆常数比较大，和 `pbds` 的配对堆速度差不多，我们可以把指针换成数组，再加上快读后成功抢到了[最优解](https://www.luogu.com.cn/record/229806602)。

应用场景：

一种快一些的堆，插入和减小元素的复杂度都是 $O(1)$，可以优化 dijkstra 算法求最短路至 $O(n\log n+m)$。

---

## 作者：_Lamiris_ (赞：6)

## 题目链接

- [洛谷 P11266 【模板】可并堆 2](https://www.luogu.com.cn/problem/P11266)

## 解题思路

看了题解区，竟然没有人写~~可爱的~~左偏树。

我们需要支持四种操作：

1. 删除集合中的元素。
2. 取集合中的最小值。
3. 合并两个集合。
4. 修改集合中的元素。

那么我们可以用~~常数极小的~~**左偏树（可并堆）** 来解决这道模板题。

**对于左偏树的基础操作，详见[左偏树-OI Wiki](https://oi.wiki/ds/leftist-tree/)或[洛谷 P3377【模板】左偏树/可并堆](https://www.luogu.com.cn/problem/P3377)。**

在支持删除元素的情况下，我们在进行 push_up 操作时需要查找节点 $x$ 的父节点，因此无法使用路径压缩来查找左偏树的根节点。如果直接向上查找根节点，会导致 TLE。

为了解决这个问题，我们可以引入一个 root 数组，其中 $root_x$ 存储集合 $S_x$ 的根节点下标。在每次执行 merge、erase 和 push_up 操作时，对 root 数组进行相应的更新。

在删除操作中，可以直接将元素 $x$ 从左偏树中删除，然后重新初始化元素 $x$，将其作为一个独立的左偏树，再将其合并回原来的左偏树，保证了堆的性质。

此外，对于修改操作，还有另一种更高效的处理方式。由于题目保证 $z<a_y$，我们可以在修改 $x$ 的权值后与其父节点进行比较。如果 $x$ 的父节点的权值大于 $x$ 的权值，则交换 $x$ 和其父节点的位置。这样常数极小~~但是我写挂了~~。

整体时间复杂度为 $O(m\log{n})$，跑得飞快。

以下是使用朴素修改操作的左偏树 AC 代码的[提交记录](https://www.luogu.com.cn/record/191668515)，仅仅跑了 $325$ ms，比最优解手写巨大数据结构的大佬慢了 $19$ ms。

## 参考代码

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace IO
{
    char buf[1<<20],*p1,*p2;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<20,stdin),p1==p2)?EOF:*p1++)
    template<typename T>inline T read(T& x)
    {
        char ch=getchar();bool f=true;x=0;
        while(ch<'0'||ch>'9') f&=(bool)(ch^'-'),ch=getchar();
        while(ch>='0'&&ch<='9') x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
        return x=f?x:-x;
    }
    char pbuf[1<<20],*pp=pbuf;
    inline void push(const char x){if(pp-pbuf==1<<20) fwrite(pbuf,1,1<<20,stdout),pp=pbuf;*pp++=x;}
    inline void flush(){fwrite(pbuf,1,pp-pbuf,stdout);pp=pbuf;}
#define putchar(x) push(x)
    template<typename T>void print(const T x)
    {
        if(x<0){putchar('-');print(-x);return ;}
        if(x>9) print(x/10);putchar(x%10^48);
    }
    template<typename T,typename... Args>inline void read(T& x,Args&... args){read(x);read(args...);}
    template<typename T>inline void print(const T x,const char ch){print(x);putchar(ch);}
#undef getchar
#undef putchar

#define getchar() (IO::p1==IO::p2&&(IO::p2=(IO::p1=IO::buf)+fread(IO::buf,1,1<<20,stdin),IO::p1==IO::p2)?EOF:*IO::p1++)
#define putchar(x) IO::push(x)
#define flush() IO::flush()
}using IO::read,IO::print;
typedef long long ll;

const int N=1e6+1;
int n,m;

int root[N];
struct ZPS{int ls,rs,dis,fa;ll val;}tree[N];
#define ls(x) tree[x].ls
#define rs(x) tree[x].rs
int merge(int x,int y)
{
	if(!x||!y) return x|y;
	if(tree[x].val>tree[y].val||(tree[x].val==tree[y].val&&x>y)) swap(x,y);
	rs(x)=merge(rs(x),y);
	if(tree[ls(x)].dis<tree[rs(x)].dis) swap(ls(x),rs(x));
	tree[x].dis=tree[rs(x)].dis+1;
	return tree[ls(x)].fa=tree[rs(x)].fa=tree[x].fa=x;
}
void push_up(const int x)
{
	if(!x) return ;
	if(tree[ls(x)].dis<tree[rs(x)].dis) swap(ls(x),rs(x));
	if(tree[x].dis^(tree[rs(x)].dis+1))
		tree[x].dis=tree[rs(x)].dis+1,push_up(tree[x].fa);
}
inline int erase(const int x,const int pos)
{
	int y=merge(ls(x),rs(x));
	if(tree[x].fa^x)
	{
		tree[y].fa=tree[x].fa;
		if(ls(tree[y].fa)==x) ls(tree[y].fa)=y;
		if(rs(tree[y].fa)==x) rs(tree[y].fa)=y;
		push_up(tree[y].fa);
	}else root[pos]=tree[y].fa=y;
	tree[x].fa=y;ls(x)=rs(x)=0;
	return pos;
}
inline ll top(const int pos){return tree[root[pos]].val;}
inline void modify(const int x,const int k,const int pos){erase(x,pos);tree[x]={0,0,1,x,k};root[pos]=merge(root[pos],x);}


int main()
{
	#ifndef ONLINE_JUDGE
    freopen("awa.in","r",stdin);
	freopen("awa.out","w",stdout);
	#endif
	 
	read(n,m);
	for(int i=1;i<=n;++i) read(tree[i].val),tree[i].dis=1,tree[i].fa=root[i]=i;

	int opt;ll x,y,z;
	while(m--)
		switch(read(opt))
		{
			case 0:read(x,y),erase(y,x);break;
			case 1:read(x),print(top(x),'\n');break;
			case 2:read(x,y),root[x]=merge(root[x],root[y]);break;
			case 3:read(x,y,z),modify(y,z,x);break;
		}
    
    flush();
	return 0;
}
```

**2025.2.5 update：`push_up` 里判断是否更新父亲节点时写成了与左孩子比较。**

---

## 作者：strcmp (赞：4)

**upd：** 第一版代码的 decrease key 实现有误（进行了一次 pop）。修改了代码逻辑。同时对文本进行了一些修改。

![pEdWQY9.jpg](https://s21.ax1x.com/2025/03/18/pEdWQY9.jpg)

**图文无关。**

这里给个题解区没有的**配对堆**做法，实际上配对堆是很好写的，不知道为什么不怎么普及，可能是时间复杂度证明困难？

顺道宣传一下[我的推荐文章](https://www.luogu.com.cn/article/hylpszdd)，介绍了一些扩展的可并堆。

实际上在 OI 中我建议直接配对堆/斜堆（持久化的话考虑左偏树），毕竟代码很好写。

---

一般来讲基于比较的堆不可能同时做到低于 $\Theta(\log n)$ 的 push 和 pop，因为这是基于比较排序的下界（$\Theta(\log (n!)) = \Theta(n \log n)$，使用斯特林近似公式即可得到），这是由信息论决定的。

配对堆是一种严格 $\Theta(1)$ merge、push 和 top，均摊 $\Theta(\log n)$ 的 pop 的 self-adjusting 数据结构（自调整数据结构，Splay 和斜堆都是这种类型的）。

它的 decrease key 的复杂度并不是 $\Theta(1)$。一个紧的下界 $\Theta(\log \log n)$（有操作序列达到了这个复杂度），还有一个不知道紧不紧的上界 $\Theta((\sqrt{\log \log n})2^{\sqrt{2 \log \log n}})$，注意这个上界同时也是 merge 的均摊复杂度上界。另外如果 decrease key 的复杂度上界放到 $\Theta(\log n)$ 的话，merge 的均摊复杂度可以分析到 $\Theta(1)$。decrease key 的复杂度在 OI 范围内大概可以看作 $\Theta(\log \log n)$。因此用来优化 Dijkstra 是不错的选择。

这东西实际上思想很简单，至于证明的话。学术界对它的 decrease key 都无法给出精确的复杂度。

简单来说，配对堆是一棵满足堆序的**有根树**，所以它只是满足堆序，而可以不是二叉树。

对于合并，令 $r_1,\,r_2$ 分别是两棵树 $T_1,\,T_2$ 的根且 $r_1 \le r_2$（不是那就交换）。只是简单粗暴的令 $r_2$ 成为 $r_1$ 的儿子，把 $T_2$ 拼到 $T_1$ 上。merge 和 push 就做完了。

```cpp
struct Node { ll w; int f, s, b; } t[maxn]; int rt[maxn], n, m; // 前四个东西分别代表权值、父亲、左儿子、右兄弟（我们用左儿子右兄弟法表示配对堆）
#define w(x) (t[x].w)
#define f(x) (t[x].f)
#define s(x) (t[x].s)
#define b(x) (t[x].b)
inline int mg1(int x, int y) {
	if (!x || !y) return x | y;
	if (w(x) > w(y)) swap(x, y);
	return b(y) = s(x), f(s(x)) = y, s(x) = y, f(y) = x;
}
//注意维护父亲是为了做 delete 和 decrease key
//在实现中，如果一个结点有 左 兄弟，那么我们就钦定它的父亲是左兄弟，这同样也是为了方便做上面两个操作
```

但是这样太偷懒了，于是我们 pop 的时候就很头疼。最简单的想法是学左偏树把根的儿子全部 merge 起来。但是完全可以被卡。

配对堆的自调整：将**相邻的**儿子两两配对起来，`12` 配对、`34` 配对、`56` 配对···，配对之后内部自己合并掉（这里 $1$ 是最新的儿子，$2$ 是次新的儿子，以此类推）。合并完然后**以老儿子到新儿子**的顺序依次合并。

老儿子指的是对于根来说先合并进来的儿子，新儿子是后来合并进来的儿子。必须按这个顺序合并**否则时间复杂度没有保证。**

![](https://cdn.luogu.com.cn/upload/image_hosting/voutilzp.png)

简单来说配对堆一般用**左儿子右兄弟**的方式存树，或者说链式前向星。那么加入一个儿子就是链表的头插，调整就是递归到链表尾相邻两两合并，然后让末尾合并的结果跟当前相邻的两个合并的结果合并。

对于 decrease key，就是让配对堆维护**父指针和左兄弟指针**（注意到后者可以合并到前者上面），然后把修改的点 $x$ 直接剖出来跟整棵树合并。

为了实现这个东西，我们可以先做一个“将 $x$ 结点从 $S$ 配对堆中拆出来的操作”。具体的拆法，其实就是兄弟链表上把 $x$ 删了，并且把 $x$ 的左兄弟和右兄弟连接起来。

然后现在 $x$ 变成根了，由于我们是 decrease key，权值只可能变小，因此根是不会改变的。最后让 $x$ 子树跟原树合并即可。

对于 delete，我们直接把 $x$ 进行 decrease key 到 $-\infty$，然后再 pop 即可。 

```cpp
int mg2(int x) {
	if (!x || !b(x)) return f(x) = 0, x; 
	int u = b(x), v = b(u); f(u) = 0; b(x) = b(u) = 0;
	return mg1(mg2(v), mg1(x, u));
}
inline int pop(int x) { f(s(x)) = 0; int u = mg2(s(x)); s(x) = 0; return u; }
inline void cut(int st, int x) {
	if (x == rt[st]) return; 
	x == s(f(x)) ? s(f(x)) = b(x) : b(f(x)) = b(x); 
	if (b(x)) f(b(x)) = f(x); f(x) = b(x) = 0;
}// 把 x 子树单独拆出来
inline ll qmin(int x) { return w(rt[x]); } // op 1
inline void dekey(int st, int x, ll z) {
	w(x) = z; if (x == rt[st]) return;
	cut(st, x); rt[st] = mg1(rt[st], x);
} // op 3
inline int del(int st, int x) { dekey(st, x, -inf); return rt[st] = pop(x); }  // op 0
```

时间复杂度证明可比斜堆困难多了，**非常**复杂，这里是[原论文链接](https://www.cs.cmu.edu/~sleator/papers/pairing-heaps.pdf)。原论文只将 pop 的均摊复杂度分析到了 $\Theta(\log n)$。

如果想看中文，建议 [U 选天天读，功力日日深](https://www.luogu.me/article/j4ok7ax7#)。

效率似乎还行，一般不比左偏树差。

有一种配对堆的变种叫赋权配对堆（或者称为秩对堆，Rank-Paring Heap），能够做到 $\Theta(1)$ 的 decrease key，也就是所有操作复杂度跟斐波那契堆一样（不过我感觉它更像斐波那契堆的变种）。

```cpp
#include <bits/stdc++.h>
#define X first
#define Y second
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define per(i, a, b) for (int i = a; i >= b; i--)
#define pb push_back
#define mp make_pair
#define mid (l + r >> 1)
using namespace std;
typedef long long int ll;
using ull = unsigned long long int;
using pii = pair<int, int>;
using pil = pair<int, ll>;
using pq = priority_queue<int>;
using vec = vector<int>;
constexpr int maxn = 1e6 + 10, N = maxn - 10, mod = 1e6 + 3, B = 205; constexpr ll inf = 1e16;
inline ll ksm(ll a, int b = mod - 2) { ll ls = 1; while (b) (b & 1) && (ls = ls * a % mod), a = a * a % mod, b >>= 1; return ls; }
struct Node { ll w; int f, s, b; } t[maxn]; int rt[maxn], n, m;
#define w(x) (t[x].w)
#define f(x) (t[x].f)
#define s(x) (t[x].s)
#define b(x) (t[x].b)
inline int mg1(int x, int y) {
	if (!x || !y) return x | y;
	if (w(x) > w(y)) swap(x, y);
	return b(y) = s(x), f(s(x)) = y, s(x) = y, f(y) = x;
}
int mg2(int x) {
	if (!x || !b(x)) return f(x) = 0, x; 
	int u = b(x), v = b(u); f(u) = 0; b(x) = b(u) = 0;
	return mg1(mg2(v), mg1(x, u));
}
inline int pop(int x) { f(s(x)) = 0; int u = mg2(s(x)); s(x) = 0; return u; }
inline void cut(int st, int x) {
	if (x == rt[st]) return; 
	x == s(f(x)) ? s(f(x)) = b(x) : b(f(x)) = b(x); 
	if (b(x)) f(b(x)) = f(x); f(x) = b(x) = 0;
}// 把 x 子树单独拆出来
inline ll qmin(int x) { return w(rt[x]); } // op 1
inline void dekey(int st, int x, ll z) {
	w(x) = z; if (x == rt[st]) return;
	cut(st, x); rt[st] = mg1(rt[st], x);
} // op 3
inline int del(int st, int x) { dekey(st, x, -inf); return rt[st] = pop(x); } 
int main() {
	scanf("%d%d", &n, &m);
	rep(i, 1, n) scanf("%lld", &w(i)), rt[i] = i;
	while (m--) {
		int o, x, y; ll z;
		scanf("%d%d", &o, &x);
		if (o == 0) scanf("%d", &y), del(x, y);
		else if (o == 1) printf("%lld\n", qmin(x));
		else if (o == 2) {
			scanf("%d", &y);
			rt[x] = mg1(rt[x], rt[y]); rt[y] = 0;
		}
		else scanf("%d%lld", &y, &z), dekey(x, y, z);
	}
	return 0;
}
```

---

## 作者：wyc0607 (赞：3)

### 思路：用自带的数据结构水过

用优先队列。注意，此优先队列非彼优先队列。这里的是指
```cpp
 bits/extc++.h
 ```
（拓展库）头文件里的优先队列，区别就是，拓展库中的功能更多。

在该头文件中有一个库叫 
```cpp
pb_ds
```

（~~平板电视~~）库，里面就有如刚才的优先队列等。

**使用该库前请先加上**
```cpp
using namespace __gnu_pbds;
```

定义优先队列
```cpp
__gnu_pbds::priority_queue<int> q;
```

**一些操作**

一些标准库里有的功能就不再赘述。

```cpp
q.join(q1)
```
将 $q$ 和 $q1$ 合并，结果放在 $q$。

```cpp
q.erase(iterator *it)
```
将 $q$ 中迭代器删除（若有）。

```cpp
q.modify(iterator *it,typename x)
```
将 $q$ 中迭代器的值改为 $x$（若有）。

### 代码：
```cpp
#include<cstdio>
#include<bits/extc++.h>
using namespace __gnu_pbds;
using namespace std;
__gnu_pbds::priority_queue<int,greater<int>> q[1000005];
__gnu_pbds::priority_queue<int,greater<int>>::point_iterator it[1000005];//it[i] 返回 i 的迭代器
main() {
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=1; i<=n; i++) {
		int x;
		scanf("%d",&x);
		it[i]=q[i].push(x);
	}
	while(m--) {
		int op;
		scanf("%d",&op);
		if(op==0) {
			int x,y;
			scanf("%d%d",&x,&y);
			q[x].erase(it[y]);
		}
		if(op==1) {
			int x;
			scanf("%d",&x);
			printf("%d\n",q[x].top());
		}
		if(op==2) {
			int x,y;
			scanf("%d%d",&x,&y);
			q[x].join(q[y]);
		}
		if(op==3) {
			int x,y,z;
			scanf("%d%d%d",&x,&y,&z);
			q[x].modify(it[y],z);
		}
	}
}
```

---

## 作者：Phartial (赞：3)

什么年代了还在写左偏树 / pbds，不如来看看我们高贵的斜堆！！！

以下提到堆默认小根堆。

斜堆的结构与普通的可并堆相同，但它的 merge 操作惊人的简单：

- 对于两个斜堆 $t_1,t_2$，假设 $t_1$ 的根节点权值小于 $t_2$ 的根节点权值，那么我们先将 $t_2$ 合并到 $t_1$ 的右子树中，再交换 $t_1$ 的左右子树。

有了 merge 操作后，其余几个操作也是简单的了：

- push、top：过于平凡；
- decrease-key：找到目标节点，断开它与父亲的边，然后直接修改它的权值，重新合并回原堆；
- erase：把要删的节点权值 decrease-key 成 $-\infty$，然后直接合并根的左右子树作为新堆。

好那这个这么厉害的东西时间复杂度为啥是对的呢？？？

定义重点为右子树大小大于左子树的节点，轻点为右子树大小不大于左子树的节点。

容易发现一次 merge 的时间复杂度与两个堆最右链长度之和等阶，考虑势能分析。定义一个堆的势能为其中重点的数量，由于一次 merge 后最右链上的重点显然都会变成轻点，即使轻点都变成重点，总的势能也只和两个堆最右链中轻点个数等阶。

而由于最右链上每遇到一个轻点子树大小都至少会减半，所以轻点个数最多只有 $\Theta(\log n)$ 个，均摊后可知 merge 的时间复杂度为 $\Theta(\log n)$。

还有一个不够显然的事情是 decrease-key 中断掉与父亲的边可能导致一些轻点变成重点，但因为删掉的点必然在这一轻点的左子树中，所以这样的轻点个数仍然是 $\Theta(\log n)$ 的，同样可以摊进去。

于是证完了，虽然时间复杂度几乎全是 $\Theta(\log n)$ 但是跑起来飞快！！！

```cpp
#include <limits>
#include <iostream>

using namespace std;

const int kN = 1e6 + 1;

struct E {
  int f, l, r, v;
} e[kN];
int n, q, r[kN];

int M(int x, int y) {
  if (!x || !y) {
    return x | y;
  }
  if (e[x].v > e[y].v) {
    swap(x, y);
  }
  e[e[x].r = M(e[x].r, y)].f = x, swap(e[x].l, e[x].r);
  return x;
}
void D(int &r, int x, int v) {
  int y = e[x].f;
  (y ? e[y].l == x ? e[y].l : e[y].r : r) = e[x].f = 0;
  e[x].v = v, r = M(r, x);
}

int main() {
  ios::sync_with_stdio(0), cin.tie(0);
  cin >> n >> q;
  for (int i = 1; i <= n; ++i) {
    cin >> e[i].v;
    r[i] = i;
  }
  for (int o, x, y, z; q--; ) {
    cin >> o >> x;
    if (o == 0) {
      cin >> y;
      D(r[x], y, numeric_limits<int>::min());
      e[r[x] = M(e[r[x]].l, e[r[x]].r)].f = 0;
    } else if (o == 1) {
      cout << e[r[x]].v << '\n';
    } else if (o == 2) {
      cin >> y;
      e[r[x] = M(r[x], r[y])].f = 0;
    } else {
      cin >> y >> z;
      D(r[x], y, z);
    }
  }
  return 0;
}
```

---

## 作者：lailai0916 (赞：3)

## 原题链接

- [洛谷 P11266 【模板】完全体·堆](https://www.luogu.com.cn/problem/P11266)

## 参考资料

- [pb_ds/堆 - OI Wiki](https://oi.wiki/lang/pb-ds/pq/)

## 解题思路

### 说明

本题使用 GNU PBDS（Policy-Based Data Structures）可以非常优雅地解决。

`__gnu_pbds::priority_queue` 相比标准库的 `std::priority_queue` 提供了更灵活的修改和删除操作。

### 函数

- `push(x)`：向堆中压入元素 `x`，返回该元素位置的迭代器。
- `erase(it)`：把迭代器 `it` 位置的键值从堆中擦除。
- `top()`：返回堆顶元素。
- `join(x)`：把堆 `x` 合并到 `*this` 并把 `x` 清空。
- `modify(it,x)`：把迭代器 `it` 位置的键值修改为 `x`，并对底层储存结构进行排序。

### 实现

初始时，对于每个数 $a_i$，压入堆 $q_i$，并记录其迭代器位置 $it_i$。

对于每次操作：

- `0 x y`：使用 `erase(it)` 在 $q_x$ 删除 $it_y$ 位置的键值。
- `1 x`：使用 `top()` 查询 $q_x$ 堆顶元素（即最小值）。
- `2 x y`：使用 `join(x)` 把 $q_x$ 合并到 $q_y$ 并把 $q_x$ 清空。
- `3 x y z`：使用 `modify(it,x)` 把 $q_x$ 中 $it_y$ 位置的键值修改为 $x$。

代码非常简洁，缺点是常数较大。

## 参考代码

```cpp
#include <bits/stdc++.h>
#include <bits/extc++.h>
using namespace std;
using namespace __gnu_pbds;

const int N=1000005;
__gnu_pbds::priority_queue<int,greater<int>> q[N];
__gnu_pbds::priority_queue<int,greater<int>>::point_iterator it[N];
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		int x;
		cin>>x;
		it[i]=q[i].push(x);
	}
	while(m--)
	{
		int op,x,y,z;
		cin>>op;
		if(op==0)
		{
			cin>>x>>y;
			q[x].erase(it[y]);
		}
		else if(op==1)
		{
			cin>>x;
			cout<<q[x].top()<<'\n';
		}
		else if(op==2)
		{
			cin>>x>>y;
			q[x].join(q[y]);
		}
		else if(op==3)
		{
			cin>>x>>y>>z;
			q[x].modify(it[y],z);
		}
	}
	return 0;
}
```

---

## 作者：ivyjiao (赞：2)

首先我们要知道一个东西：pbds 的 priority_queue，跟我们日常使用的那个堆名字一样。

[OI-WIKI 简介](https://oi-wiki.org/lang/pb-ds/pq/)。

本题需要以下操作：

1. `push()`：向堆中压入一个元素，返回该元素位置的迭代器。
2. `top()`：返回堆顶元素。
3. `modify(point_iterator, const key)`：把迭代器位置的 key 修改为传入的 key，并对底层储存结构进行排序。
4. `erase(point_iterator)`：把迭代器位置的键值从堆中擦除。
5. `join(__gnu_pbds::priority_queue &other)`：把 other 合并到 *this 并把 other 清空。

当然，这题和 [P3377](/problem/P3377) 那题的要求有所不同，注意到 `modify` 和 `erase` 操作需要迭代器，而那题不需要这两个操作，所以这题要记录迭代器位置。

然后需要注意的是即使你已经 `using namespace __gnu_pbds;` 仍需要在声明此数据结构前添加 `__gnu_pbds::`，因为它与 `bits/stdc++.h` 库的 priority_queue 重名。

代码：

```cpp
#include<bits/stdc++.h>
#include<bits/extc++.h>
#define int long long
using namespace std;
using namespace __gnu_pbds;
using pair_heap=__gnu_pbds::priority_queue<int,greater<int>>;
const int N=1e6+1;
int n,m,op,x,y,z;
pair_heap q[N];
pair_heap::point_iterator id[N];
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>x,id[i]=q[i].push(x);
	while(m--){
		cin>>op;
		if(op==0) cin>>x>>y,q[x].erase(id[y]);
		if(op==1) cin>>x,cout<<q[x].top()<<endl;
		if(op==2) cin>>x>>y,q[x].join(q[y]);
		if(op==3) cin>>x>>y>>z,q[x].modify(id[y],z);
	}
}
```

---

## 作者：_WRYYY_ (赞：2)

[博客园观看。](https://www.cnblogs.com/wryyy-233/p/18535842)

也算是对 ``pb_ds`` 库中的优先队列各种操作的科普？

### 一些碎碎念

**提醒**：你可以不看这部分，这部分算是作者探索未知功能的过程。

平常写优先队列的时候一般用不到对值进行修改或者删除的操作，所以我在看这到题的时候在想怎么才能实现题目中的操作，因为我不知道有什么成员函数可以直接获取具体哪个值的迭代器，但是 pb_ds 中却恰好又有这些我所需要的函数，而且都需要迭代器。

首先我是知道 pb_ds 中的所有数据结构支持迭代器访问的，不像标准库的部分数据结构是不支持迭代器的，所以自然而然就想到了 ``lower_bound`` ，想着能不能使用，结果却真过编了，但是当然是没用的，这样只会返回错误的迭代器，后面查阅了资料才想起来 pb_ds 的迭代器比较强大，点类型迭代器只要没被删除都保持有效，所以可以直接保存 ``push`` 时返回的迭代器，然后在具体操作的时候利用上就是了，我开始还不知道为什么要对某个位置进行操作，现在知道了。

### 具体实现

推荐阅读资料：

1. [OI-Wiki 上对 pb_ds 优先队列的介绍。](https://oi-wiki.org/lang/pb-ds/pq/)
2. [该篇博文对 pb_ds 的详细介绍。](https://www.luogu.com/article/rqkexmuc)

首先 ``push`` 操作是会返回点类型迭代器的，所以可以在每个元素一开始被插入的时候记录下来，然后在需要的时候直接调用即可。

注意到在一开始就要开出数组来，所以要知道该迭代器类型名，类型名可以通过编译信息返回获得，比较长，目前我没有什么好的解决办法，有大佬知道的话可以分享一下。

类型名：``detail::binomial_heap<int, greater<int>, allocator<char>>::point_iterator``。

其中 ``binomial_heap`` 应根据具体使用哪个堆来变化名字。

五种堆均已测试，其中冗余计数二项堆和改良的 Fibonacci 堆（``thin_heap``）会 ``MLE``，二叉堆会 ``RE``，配对堆和二项堆均可通过，前者稍快一些，且内存偏少，但是差异均不大。

### Code

以下是配对堆的模板代码：

```cpp
#include <bits/stdc++.h>
#include <bits/extc++.h>
#define N 1000010
#define ll long long
using namespace std;
using namespace __gnu_pbds;
__gnu_pbds::priority_queue<ll, greater<ll>, pairing_heap_tag> q[N];
__gnu_pbds::detail::pairing_heap<ll, std::greater<ll>, std::allocator<char>>::point_iterator id[N];
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);
	q[1].begin();
	int n, m, opt, x, y;
	ll z;
	cin >> n >> m;
	for (int i = 1; i <= n; i++)
	{
		cin >> x;
		id[i] = q[i].push(x);
	}
	while (m--)
	{
		cin >> opt;
		if (opt == 1)
		{
			cin >> x;
			cout << q[x].top() << "\n";
		}
		else if (opt == 2)
		{
			cin >> x >> y;
			q[x].join(q[y]);
		}
		else if (opt == 3)
		{
			cin >> x >> y >> z;
			q[x].modify(id[y], z);
		}
		else
		{
			cin >> x >> y;
			q[x].erase(id[y]);
		}
	}
	return 0;
}
```

具体测试时间效率的时候我加上了快读快写，为了代码简洁性这里给出的是普通的关闭流同步，除了一位大佬手写的超大数据结构外，速度是最快的。

---

## 作者：LEE114514 (赞：1)

## 思路

首先这个题显然平衡树是能做的，但是堆常数上会更优秀。

具体的，我们使用可并堆实现。

对于一个集合，我们维护两个小根堆，$pq1$ 表示未被实际弹出（后面解释）的元素，$pq2$ 表示应该删除的元素。

- 对于插入操作，我们往 $pq1$ 内直接插入。

- 对于删除操作，我们往 $pq2$ 内插入对应元素。

- 对于查询操作，我们检验 $pq2$ 是否非空且堆顶元素与 $pq1$ 堆顶相等，如果是则从两个堆中同时弹出堆顶。重复上述操作直至不满足条件，此时 $pq1$ 的堆顶就是最小值。

- 对于合并操作，我们直接分别合并两个集合的 $pq1,pq2$。

- 对于赋值操作，转化为一次删除和一次插入。

## Code

```cpp
#include <bits/stdc++.h>
#include <ext/pb_ds/priority_queue.hpp>
using namespace std;

struct node2{
	__gnu_pbds::priority_queue<int> pq1,pq2;
	void ins(int x){
		pq1.push(-x);
	}
	void del(int x){
		pq2.push(-x);
	}
	int getmin(){
		while(!pq2.empty()&&pq2.top()==pq1.top()) pq1.pop(),pq2.pop();
		return -pq1.top();
	}
};
void merge(node2 *x,node2 *y){
	x->pq1.join(y->pq1);
	x->pq2.join(y->pq2);
}
const int maxn=1e6+5;
int a[maxn];
node2 *s[maxn];
int n,m;
int op,x,y,z;
int main(){
	scanf("%d%d",&n,&m);
	
	for(int i=1;i<=n;++i){
		s[i]=new node2;
		scanf("%d",a+i),s[i]->ins(a[i]);
	}

	while(m--){
		scanf("%d%d",&op,&x);
		if(op==0){
			scanf("%d",&y);
			s[x]->del(a[y]);
		}else if(op==1){
			printf("%d\n",s[x]->getmin());
		}else if(op==2){
			scanf("%d",&y);
			merge(s[x],s[y]);
		}else{
			scanf("%d%d",&y,&z);
			s[x]->ins(z);
			s[x]->del(a[y]);
			a[y]=z;
		}
	}
}
```

---

## 作者：Flambler (赞：0)

# P11266 题解
### Step 0 前言 Preface
~~[博客食用更佳](https://www.luogu.com.cn/article/b9v80i3f)~~ 这篇题解是我的第二篇题解，还是刷模板题看见的。
### Step 1 思路 Idea
这道题是 `pb_ds` 里的 `priority_queue` 的一道模板题。让我们分析一下：
- 操作 0：就是 `erase` 函数，格式如下 `erase(it)` ，代表删除迭代器为 `it` 的元素。
- 操作 1：就是 `top` 函数，格式如下 `top()` ，代表堆的堆顶。
- 操作 2：就是 `join` 函数，格式如下 `join(other)` ，代表将 `other` 的所有元素移动到 `*this` 里并且清空 `other` 的所有元素。
- 操作 `3`：就是 `modify` 函数，格式如下 `modify(it, x)` ，代表将迭代器为 `it` 的元素设为 $x$ 。  

**但是 `std` 命名空间也有 `priority_queue` 所以要用 `__gnu_pbds::priority_queue`**  
### Step 2 代码 Code
这个代码基本就是这样，但有一点可以优化：就是迭代器可以存储在一个数组，这样用的时候直接调用就行，`push` 函数返回值就是插入后的元素的迭代器。
完整代码如下：
```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/priority_queue.hpp>
#define llmax numeric_limits<long long>::max()
#define llmin numeric_limits<long long>::min()
#define imax numeric_limits<int>::max()
#define imin numeric_limits<int>::min()
#define pb push_back
#define gc getchar
#define pc putchar
#define gs gets
#define ps puts
#define nl ps("")
#define ir iterator
#define us unsigned
#define ll long long
#define chkup(ch) (ch>='A'&&ch<='Z')
#define chklow(ch) (ch>='a'&&ch<='z')
#define dis(x1, y1, x2, y2) sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2))
using namespace std;
char* line;
template<typename _T>
_T read() {
	_T n=0;
    int neagtive=1;
	char ch=gc();
	while(ch<'0'||ch>'9') {
        if(ch=='-') {
            neagtive=-1;
        }
		ch=gc();
	}
	while(ch>='0'&&ch<='9') {
		n=(n<<3)+(n<<1)+ch-'0';
		ch=gc();
	}
    return n*neagtive;
}
template<typename _T>
void write(const _T n) {
	if(n>9) {
		write(n/10);
	}
	pc(n%10+'0');
}
//struct
//variable
const int N=1e6+10;
int a[N];
__gnu_pbds::priority_queue<int, greater<int> > pq[N];  // priority_queue 的数组
__gnu_pbds::priority_queue<int, greater<int> >::point_iterator it[N];  // 迭代器数组
//function
int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    for(int i = 1;i<=n;i++) {
        scanf("%d", a+i);
        it[i]=pq[i].push(a[i]);  // 存储迭代器
    }
    for(int i = 1;i<=m;i++) {
        int op, x, y, z;
        scanf("%d%d", &op, &x);
        if(op==0) {
            scanf("%d", &y);
            pq[x].erase(it[y]);  // 操作 0：删除元素
        } else if(op==1) {
            printf("%d\n", pq[x].top());  // 操作 1：查询元素
        } else if(op==2) {
            scanf("%d", &y);
            pq[x].join(pq[y]);  // 操作 2：合并堆
        } else if(op==3) {
            scanf("%d%d", &y, &z);
            pq[x].modify(it[y], z);  // 操作 3：更改元素
        }
    }
	return 0;
}
```
[100 pts record](https://www.luogu.com.cn/record/202146673)

---

## 作者：FISH酱 (赞：0)

## 小知识

使用 `__gnu_pbds::priority_queue` 数据结构可解决本题，这种数据结构便捷简单。

第一步，也是重点的一步，弄好命名空间，加上 `using namespace __gnu_pbds`，加完了是这样的：

```cpp
using namespace __gnu_pbds;
using namespace std;
```

第二步，直接定义数据结构，`__gnu_pbds::priority_queue<int,less<int>>` 或者是 `__gnu_pbds::priority_queue<int,greater<int>>`，含义为小根堆和大根堆，至此准备工作结束。

## 使用方法

准备好了，那怎么用这种数据结构呢？参见下述操作就可以写出代码了：

操作一，`__gnu_pbds` 有 `erase()` 操作，括号里填入要删除元素的下标。

操作二，`__gnu_pbds` 有 `top()`，不需要参数，即获取第一个元素。

操作三，`__gnu_pbds` 有 `join()` 操作，括号内填入一个集合。

操作四，`__gnu_pbds` 有 `modify()` 操作，括号内填入集合与修改的内容。

好啦，现在可以去写代码了。最后吐槽一句，这题怎么改名字了，差点找不到。

## 防卡常

部分代码存在被卡常问题，你可以关闭同步流、使用 `\n` 换行、使用 `scanf` 和 `printf`。


```cpp
//关同步流
ios::sync_with_stdio(false);

//换行
cout<<'\n';

//scanf和printf演示
scanf("%d",&t);
printf("%d",ans);
```

---

## 作者：ni_ju_ge (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P11266)

下文中的堆皆指小根堆。
## 思路
### 核心操作：堆合并
要将以 $x$ 为根的堆与以 $y$ 为根的堆合并，
 - 若 $x_{dat}$ 小于 $y_{dat}$，就以 $x$ 作为合并后的根结点；反之，则以 $y$ 为根结点。
 - 若以 $x$ 作为根结点，那么将 $y$ 与 $x$ 的一个子树合并，反之亦然。
 - 重复直到 $x$ 和 $y$ 之中有一个为空结点，返回 $x+y$。

显然，当数据是一条链时，时间复杂度是 $O(n)$ 的。

有两种优化方式：
 - 左偏树
 - 像 Treap 一样，用随机数决定与哪个子树合并

本题解使用的为第二种方法。

此操作的核心代码：
```cpp
int merge(int r1,int r2) {//将r1与r2合并
	if(!r1||!r2)return r1+r2;
	if(v[r1].dat>=v[r2].dat) {
		if(v[r1].key<=v[r2].key)v[r2].l=merge(r1,v[r2].l);
		else v[r2].r=merge(r1,v[r2].r);
		return r2;
	} else {
		if(v[r2].key<=v[r1].key)v[r1].l=merge(v[r1].l,r2);
		else v[r1].r=merge(v[r1].r,r2);
		return r1;
	}
}
```
### 删除
找到要删除的结点后，合并它的左右子树，然后以左右子树合并后的根替代它即可。
### 询问
因为我们维护的是小根堆，所以输出根结点的值就行。
### 赋值
将其拆分为删除+插入的操作即可。
## AC code
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node {
	int l,r;
	long long dat,key,id;
} v[1000001];
long long a[1000001];
int n,opt,x,y,z,root[1000001],cnt,m;
bool fl;
int read() {
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') {
		if(ch=='-')w=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();
	return s*w;
}
int make_node(int val,int pos) {
	v[++cnt].dat=val;
	v[cnt].id=pos;
	v[cnt].key=rand();
	return cnt;
}
int merge(int r1,int r2) {
	if(!r1||!r2)return r1+r2;
	if(v[r1].dat>=v[r2].dat) {
		if(v[r1].key<=v[r2].key)v[r2].l=merge(r1,v[r2].l);
		else v[r2].r=merge(r1,v[r2].r);
		return r2;
	} else {
		if(v[r2].key<=v[r1].key)v[r1].l=merge(v[r1].l,r2);
		else v[r1].r=merge(v[r1].r,r2);
		return r1;
	}
}
void take_node(int &pos,int val,int goal) {
	if(!pos)pos=make_node(val,goal);
	else {
		if(v[pos].key%2) {
			take_node(v[pos].l,val,goal);
			if(v[v[pos].l].dat<v[pos].dat) {
				swap(v[v[pos].l].dat,v[pos].dat);
				swap(v[v[pos].l].key,v[pos].key);
				swap(v[v[pos].l].id,v[pos].id);
			}
		} else {
			take_node(v[pos].r,val,goal);
			if(v[v[pos].r].dat<v[pos].dat) {
				swap(v[v[pos].r].dat,v[pos].dat);
				swap(v[v[pos].r].key,v[pos].key);
				swap(v[v[pos].r].id,v[pos].id);
			}
		}
	}
}
void delete_node(int &pos,int goal) {
	if(!pos)return;
	if(v[pos].id==goal) {
		pos=merge(v[pos].l,v[pos].r);
		fl=true;
	} else {
		if(a[goal]>=v[v[pos].l].dat)delete_node(v[pos].l,goal);
		if(fl)return;
		if(a[goal]>=v[v[pos].r].dat)delete_node(v[pos].r,goal);
		if(fl)return;
	}
}
int main() {
	srand(time(0));
	cin>>n>>m;
	for(int i=1; i<=n; i++) {
		a[i]=read();
		root[i]=make_node(a[i],i);
	}
	for(int i=1; i<=m; i++) {
		opt=read();
		if(opt==0) {
			x=read();
			y=read();
			fl=false;
			delete_node(root[x],y);
		}
		if(opt==1) {
			x=read();
			cout<<v[root[x]].dat<<endl;
		}
		if(opt==2) {
			x=read();
			y=read();
			root[x]=merge(root[x],root[y]);
			root[y]=0;
		}
		if(opt==3) {
			x=read();
			y=read();
			z=read();
			fl=false;
			delete_node(root[x],y);
			a[y]=z;
			take_node(root[x],z,y);
		}
	}
}
```
[record](https://www.luogu.com.cn/record/189118242)

---


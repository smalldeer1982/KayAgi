# 罗马游戏

## 题目描述

罗马皇帝很喜欢玩杀人游戏。 他的军队里面有  $n$ 个士兵，每个士兵都是一个独立的团。最近举行了一次平面几何测试，每个士兵都得到了一个分数。 皇帝很喜欢平面几何，他对那些得分很低的士兵嗤之以鼻。

他决定玩这样一个游戏。 它可以发两种命令：

- `M i j` 把  $i$ 所在的团和  $j$ 所在的团合并成一个团。如果  $i,j$ 有一个士兵是死人，那么就忽略该命令。  
- `K i` 把   $i$ 所在的团里面得分最低的士兵杀死。如果  $i$ 这个士兵已经死了，这条命令就忽略。

皇帝希望他每发布一条 `K i` 命令，下面的将军就把被杀的士兵的分数报上来 
（如果这条命令被忽略，那么就报  $0$ 分）。 

保证**士兵的分数互不相同**。

## 说明/提示

对于   $100\%$ 的数据，  $1\le n\le 10^6$，$1\le m\le 10^5$，$0\le a_i\le 10^7$，
**注意测试数据中 `M i j` 的 $i,j$ 可能在同一个团中。** 

## 样例 #1

### 输入

```
5
100 90 66 99 10
7
M 1 5
K 1
K 1
M 2 3
M 3 4
K 5
K 4```

### 输出

```
10
100
0
66```

# 题解

## 作者：vеctorwyx (赞：9)

### ~~加了修饰的~~左偏树模板题

[模板题链接](https://www.luogu.com.cn/problem/P3377)，~~双倍经验~~。

~~简简单单~~把左偏树模板打上就行了，注意数据范围（n<=1e6,m<=1e5）。



------------
~~以上为扯淡内容~~，正文开始。



------------

题意（翻译成~~术语~~）：

对n个小根堆做m个操作：

M （x，y）合并x所在堆和y所在堆（如果x或y被删除则忽略次操作）；

K（x）输出x所在堆的堆顶元素并将其删除，如果x已经被删除这输出0 ；



------------


[百度百科：左偏树](https://baike.baidu.com/item/左偏树/2181887?fr=aladdin)。

外节点：没有左子树或没有右子树的节点；

点的距离：点到它后代中离它最近的外节点经过的边数；

合并方法（小根堆）：

设要将堆顶元素为 Y 的堆并入堆顶元素为 X 的堆（谁并入谁无所谓，这里是为了便于解释），则将X与Y比较，如果X>Y就交换X与Y，将Y继续与X的右子节点比较（递推）。

同时左偏树~~要保证往左偏~~，即保证左子节点的距离要比右子节点的距离要大。

删除最小的点（堆顶元素）的方法：

标记堆顶元素已删除，合并其左子树和右子树；

话不多说，上代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int n,m,a[1000010],d[1000010],ls[1000010],rs[1000010],f[1000010],x,y;//a是每个节点的值，d是节点的距离，ls左子节点，rs右子节点，f父节点（并查集）
bool b[1000010];//是否已经删除
char z;
int find(int x)
{
	if(f[x]==x)
	return x;
	return f[x]=find(f[x]);
}//并查集
int merge(int x,int y)//合并（返回当前节点的值）
{
	if(!x||!y)//有一棵树已经空了
	return x+y;//返回
	if(a[x]>a[y]||(a[x]==a[y]&&x>y))//交换条件
	swap(x,y);
	rs[x]=merge(rs[x],y);//右子节点
	if(d[ls[x]]<d[rs[x]])//如果左子节点距离小于右子节点
	swap(ls[x],rs[x]);//交换左右子树
	d[x]=d[rs[x]]+1;//算出当前点的距离
	return x;
}
int main()
{
	cin>>n;
	d[0]=-1;
	for(int i=1;i<=n;i++)
	{
		f[i]=i;
		cin>>a[i];
	}
	cin>>m; 
	while(m--)
	{
		cin>>z;
		if(z=='M')
		{
			cin>>x>>y;
			if(b[x]||b[y])
			continue;//有一个点已经被删除了
			x=find(x);
			y=find(y);
			if(x==y)//已经在同一个堆中了
			continue;
			f[x]=f[y]=merge(x,y);
		}
		else if(z=='K')
		{
			cin>>x;
			if(b[x])//已经删除
			{
				cout<<0<<endl;
				continue;
			}
			x=find(x);
			cout<<a[x]<<endl;
			b[x]=1;//标记删除
			f[x]=f[ls[x]]=f[rs[x]]=merge(ls[x],rs[x]);//合并左右子树
			ls[x]=rs[x]=d[x]=0;
		}
	}
	return 0;
}
```


---

## 作者：critnos (赞：7)

设 $c_i$ 为第 $i$ 次操作的实际代价，$t_i$ 为第 $i$ 次操作后数据结构的势，我们有

$$c_i+(t_i-t_{i-1})=k_i$$

$(t_i-t_{i-1})$ 为该次操作后势变化的量，$k_i$ 应为一个恒定的容易计算的值。

所以

$$\sum_{i=1}^n (c_i+(t_i-t_{i-1}))=\sum_{i=1}^nk_i$$

得

$$\sum_{i=1}^n c_i=\sum_{i=1}^nk_i-t_n+t_0$$

---

斜堆（skew heap）是一种简易的可并堆。

对于小根堆，合并时，比较两堆的根，将权值小的根作为新堆的根，将另一个堆与新堆的右子树合并，然后交换新堆的左右子树。

定义：

若一个节点的右子树大小不小于以该节点为根的子树大小的一半，则称这个节点为重节点，否则为轻节点。定义斜堆的势为该斜堆中重节点的个数。

容易发现，合并两个斜堆相当于把两个堆从根到最右节点的路径合并后作为新堆的从根到最左节点的路径。那么时间复杂度为两个堆极右路径的和。

设 $h_1,l_1,h_2,l_2$ 分别为第一个堆的极右路径上重节点的个数，第一个堆的极右路径上轻节点的个数，第二个堆的极右路径上重节点的个数，第二个堆的极右路径上轻节点的个数。$c=h_1+l_1+h_2+l_2$。

发现，一个重节点合并后必然变成轻节点。因为我们要分析最坏情况下的摊还时间复杂度，所以我们令势的变化最大，即所有轻节点变为重节点，也即 $t_i-t_{i-1}=-h_1+l_1-h_2+l_2$，那么 $k_i=c+(t_i-t_{i-1})=2(l_1+l_2)$。

我们将证明 $l_1+l_2=O(\log n)$。显然有每个轻节点的右子树小于以该节点为根的子树大小的一半，所以每次子树规模至少缩减一半，故而为 $O(\log n)$。

代入势能分析的式子可得

$$\sum_{i=1}^n c_i=n\log n-t_n+t_0$$

根据定义，我们知道 $t_n=O(n)$，$t_0=0$，所以总时间摊还复杂度为 $O(n\log n)$。

[封装模板](https://www.luogu.com.cn/paste/ve4sq3mb)（可以通过 P2713）

以上。

---

## 作者：SuperJvRuo (赞：4)

随机合并的随机堆了解一下。

合并的时候```rand()&1```一下，决定往左儿子还是右儿子合并。由于合并完全随机，不可能被卡掉，因而表现十分优异。

```
#include<cstdio>
#include<cctype>
#include<cstdlib>
#include<algorithm>

int Read()
{
	int x=0;
	char c=getchar();
	while(!isdigit(c))
		c=getchar();
	while(isdigit(c))
	{
		x=x*10+(c^48);
		c=getchar();
	}
	return x;
}
//和普通的斜堆、左偏树相同
int ch[1000005][2],val[1000005],fa[1000005];
bool out[1000005];

int merge(int x,int y)
{
	if (!x||!y)
		return x+y;
	if (val[x]>val[y]||(val[x]==val[y] && x>y))
		std::swap(x,y);
	int opt=rand()&1;
    //合并的时候随机一下，决定往哪边走路
	ch[x][opt]=merge(ch[x][opt],y);
	fa[ch[x][opt]]=x;
	return x;
}

int find(int x)
{
	while(fa[x])
		x=fa[x];
	return x;
}

void pop(int x)
{
	val[x]=-1;
	fa[ch[x][0]]=fa[ch[x][1]]=0;
	merge(ch[x][0],ch[x][1]);
}

int main()
{
	srand(19260817);
	int n=Read(),x,y;
	for(int i=1; i<=n; i++)
		val[i]=Read();
	int m=Read();
	char opt[3];
	while(m--)
	{
		scanf("%s",opt);
		if(opt[0]=='M')
		{
			x=Read(),y=Read();
			if(val[x]==-1||val[y]==-1||(x=find(x))==(y=find(y)))
				continue;
			merge(x,y);
		}
		else
		{
			x=Read();
			if(val[x]==-1)
				puts("0");
			else
			{
				x=find(x);
				printf("%d\n",val[x]);
				pop(x);
			}
		}
	}
	return 0;
}
```

---

## 作者：Ervin (赞：4)

## 裸裸的可并堆(左偏树)

可以看一下这个模板[点我,点我](https://www.luogu.org/problemnew/show/P3377)

只要稍做改动就可以$AC$啦

对于可并堆我就不介绍了，可以看一下[这个博客](https://www.luogu.org/blog/2e8JR/solution-p3377)，讲的特别清楚(~~毕竟我都是照着这个模板写的~~)

### 好了，直接上代码吧

代码写的有点丑，大家见谅 $STO$

~~~cpp

#include<cstdio>
#include<cmath>
#include<algorithm>
#define N 1000010
using namespace std;
int ch[N][2],val[N],dis[N],f[N],root[N],n,m;
bool bz[N];
inline int getf(int x)
{
	return f[x]?f[x]=getf(f[x]):x;
}
inline int merge(int x,int y)
{
	if(x==0||y==0)
		return x+y;
	if(val[x]>val[y])
		swap(x,y);
	ch[x][1]=merge(ch[x][1],y);
	if(dis[ch[x][0]]<dis[ch[x][1]])
		swap(ch[x][0],ch[x][1]);
	dis[x]=dis[ch[x][1]]+1;
	return x;
}
inline int deletemin(int x)
{
	return merge(ch[x][0],ch[x][1]);
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d",&val[i]),
		root[i]=i;
	scanf("%d",&m);
	for(int i=1;i<=m;i++)
	{
		char comm;
		getchar();
		scanf("%c",&comm);
		if(comm=='M')
		{
			int x,y;
			scanf("%d%d",&x,&y);
			if(bz[x]||bz[y])
				continue;
			int fx=getf(x),fy=getf(y);
			if(fx==fy)
				continue;
			f[fx]=fy;
			root[fy]=merge(root[fx],root[fy]);
		}
		else
		{
			int x;
			scanf("%d",&x);
			if(bz[x])
				printf("0\n");
			else
			{
				int t=getf(x);
				printf("%d\n",val[root[t]]);
				bz[root[t]]=1;
				root[t]=deletemin(root[t]);
			}
		}
	}
	return 0;
}

~~~

---

## 作者：yuzengshen (赞：3)

## ~~**这题一看就是左偏树**~~ 为什么这题是左偏树呢

~~都说了一眼看出来了！因为我最近做的左偏树LUOGU给我推荐的~~

这里出现了两队人的**合并**，大多数人肯定立刻想到**并查集**。

但是这里又出现了**去掉集合内最小值**（砍头），这就超出了并查集的能力范围了

那么我们想一下砍头是谁能干的呢？

我们很容易能想到**堆**

现在思路清晰了，我们需要一个同时具有并查集和堆的功能的数据结构。

因此本题主角**左偏树**横空出世

## 解释一下左偏树是啥

左偏树乍一听觉得肯定是点都集中在左边的树

这种想法大致是对的，但也不完全对。

比如下图，左边只有一个点，右面有一条链

![这颗树仍然是左偏树，但是它左边只有一个点，右面有一条链](https://cdn.luogu.com.cn/upload/image_hosting/lpokt00k.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

所以左偏树的正经定义是：

1.是二叉堆

2.定义一个距离d，一个节点的d就是该节点到最近的一个不满的节点的距离（不满就是儿子数量小于2），那么对于任何一个节点，他的左儿子d >= 右儿子d

特别的，空节点的d定义为-1

优秀的是，左偏树的两个基本操作就是合并和砍头

## 食用方法

由于有这两种神奇的操作，我们可以十分愉快地用这东西切掉这道题

所以左偏树如何食用呢？

PS：接下来是代码，由于我很菜，如果出锅可以评论区提示或者私信我都可以

PPS：不喜勿喷哦，我只是个无辜的小菜鸡。。。

左偏树结构体（当然也可以开数组）
```cpp
struct LT{
	
	int fa,ls,rs;
	int val,dis;
	//fa 相当于并查集的fa
   //ls,rs Left_Son,Right_Son
   //val 这个节点的值
   //dis 上面定义的d
    
}lt[MaxN*2];
```
并查集，这就不多说了
```cpp
int find(int x)
{
	if(x == lt[x].fa) {return x;}
	else {return lt[x].fa=find(lt[x].fa);}
}
```
关键的合并操作

PS：左偏树的push操作就是左偏树和一个单点进行合并
```cpp
int merge(int x,int y) //这个函数返回的是该节点的右儿子，也是接下来的父亲节点 
{
	if(x == 0 || y == 0) {return x+y;} //如果一边是空的，父亲就是非空的，当然都空就是空了 
	if(lt[x].val > lt[y].val) {swap(x,y);} //保证堆性质 
	
	lt[x].rs=merge(lt[x].rs,y); //递归，这里可以得到当前节点的右儿子 
	lt[lt[x].rs].fa=x; //连接右儿子到当前节点 
	if(lt[lt[x].rs].dis > lt[lt[x].ls].dis) {swap(lt[x].ls,lt[x].rs);} //维护左偏性质，不符合就交换左右儿子 
	lt[x].dis=lt[lt[x].rs].dis+1; //由于左偏性质，我们可以知道每个节点的dis都是右儿子dis+1 
	
	return x;
}
```
砍头

```cpp
void pop(int x)
{
	lt[lt[x].ls].fa=lt[x].ls;
	lt[lt[x].rs].fa=lt[x].rs; //把左右儿子fa变成自己（因为他们接下来可能能成为fa） 
	lt[x].fa=merge(lt[x].ls,lt[x].rs); //合并左右儿子孤立被砍的头 
	lt[x].ls=lt[x].rs=0;	//孤立 
	lt[x].val=-1; //标记该点已死 
}
```
**这里说一句，一定要把死掉的点fa变为新的头**

因为这个死点的右儿子能根据合并操作自动更新fa，但是它的左儿子还连着它，所以如果不这么做并查集就会死掉

总体代码如下

PS：此代码是AC代码请放心，但是我进行了防复制粘贴处理，不会影响看代码思路，但是不能AC，所以请不要进行复制粘贴，蟹蟹^_^。

```cpp
#include<iostream>
#include<cstdio>

using namespace std;

#define MaxN 100006

int n,m;

struct LT{
	
	int fa,ls,rs;
	int val,dis;
	
}lt[MaxN*2];

int find(int x)	//找爸爸 
{
	if(x == lt[x].fa) {return x;}
	else {return lt[x].fa=find(lt[x].fa);}
}

int merge(int x,int y)	//合并 
{
	if(x == 0 || y == 0) {return x+y;}
	if(lt[x].val > lt[y].val) {swap(x,y);}
	
	lt[x].rs=merge(lt[x].rs,y);
	lt[lt[x].rs].fa=x;
	if(lt[lt[x].rs].dis > lt[lt[x].ls].dis) {swap(lt[x].ls,lt[x].rs);}
	lt[x].dis=lt[lt[x].rs].dis+1;
	
	return x;
}

void pop(int x)	//砍头 
{
	lt[lt[x].ls].fa=lt[x].ls;
	lt[lt[x].rs].fa=lt[x].rs;
	lt[x].fa=merge(lt[x].ls,lt[x].rs);
	lt[x].ls=lt[x].rs=0;
	lt[x].val=-1;
}

int mian()
{
	lt[0].dis=-1;
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
	{
		scanf("%d",&lt[i].val);
		lt[i].fa=i;
		lt[i].ls=lt[i].rs=0;
	}
	
	scanf("%d",&m);
	for(int i=1;i<=m;++i)
	{
		char op;
		cin>>op;
		if(op == 'M')	//合并 
		{
			int x,y;
			scanf("%d%d",&x,&y);
			if(lt[x].val == -1 || lt[y].val == -1) {continue;}
			int fax=find(x),fay=find(y);	
			if(fax == fay) {continue;}	//这里注意了，要合并的两个团可能本来就是一个团
			merge(fax,fay);
		}
		else	//砍头 
		{
			int x;
			scanf("%d",&x);
			if(lt[x].val == -1) {printf("0\n");continue;}
			
			int fax=find(x);
			printf("%d\n",lt[fax].val);
			pop(fax);
		}
	}
	
	return 0;
}
```


---

## 作者：小黑AWM (赞：3)

你们都不用pbds的吗，发一个pbds版。

左偏树写起来这么烦，当然选择pbds。（~~我不会手写~~）

用并查集维护合并后一个点的集合编号。清清爽爽。
复杂度O(nlogn)我们忽略那个反阿克曼函数。

```cpp
#include <cstdio>
#include <iostream>
#include <ext/pb_ds/priority_queue.hpp>
using namespace std;
const int maxn = 1e6 + 10;
int n, m, x, y;
int dad[maxn], died[maxn], num[maxn], ranks[maxn];
char opt;
struct cmp1{
    bool operator() (pair<int, int> a, pair<int, int> b){
        if(a.second == b.second)
            return a.first > b.first;
        return a.second > b.second;
    }
};
__gnu_pbds::priority_queue <pair<int,int> , cmp1> heap[maxn];
int find(int x){
    return x == dad[x] ? x : dad[x] = find(dad[x]);
}
void unionn(int u, int v){
    int fu = find(u);
    int fv = find(v);
    if(fu == fv)
        return ;
    if(ranks[fu] > ranks[fv]){
        dad[fv] = fu;
        heap[fu].join(heap[fv]);
    }
    else{
        dad[fu] = fv;
        heap[fv].join(heap[fu]);
        ranks[fv] += (ranks[fu] == ranks[fv]);
    }

}
int main(){
    cin >> n ;
    for(int i = 1; i <= n; i++){
        cin >> x;
        num[i] = x;
        dad[i] = i;
        heap[i].push(make_pair(i, x));
    }
    cin >> m;
    for(int i = 1; i <= m; i++){
        cin >> opt >> x;
        if(opt == 'M'){
            cin >> y;
            if(died[x] || died[y] || find(x) == find(y))
                continue;
            else
                unionn(x, y);
        }else{
            if(died[x]){
                cout << 0 << endl;
                continue;
            }
            cout << heap[find(x)].top().second << endl;
            died[heap[find(x)].top().first] = 1;
            heap[find(x)].pop();
        }
    }

    return 0;
}


```

---

## 作者：da32s1da (赞：2)

考虑priority_queue+并查集做法。

- M操作，合并两个pq
- K操作，删除pq的最小值

复杂度$O(\mathrm{nlogn})$，开$O_2$可过

```cpp
#include<cstdio>
#include<queue>
#include<iostream>
using namespace std;
const int N=1e6+50;
typedef pair<int,int> pr;
priority_queue<pr>s[N];
inline void rad(int &_){
    static char ch;
    while(ch=getchar(),ch<'0'||ch>'9');_=ch-48;
    while(ch=getchar(),ch<='9'&&ch>='0')_=_*10+ch-48;
}
int n,m,x,y,opt;
int fa[N],vis[N];char S[5];
int gf(int u){return u==fa[u]?u:fa[u]=gf(fa[u]);}
int main(){
	rad(n);
	for(int i=1;i<=n;i++){
		rad(x);
		s[i].push(pr(-x,i));
	}
	for(int i=1;i<=n;i++)fa[i]=i;
	rad(m);
	for(int i=1;i<=m;i++){
		scanf("%s",S);
		if(S[0]=='M'){
			rad(x);rad(y);
			if(vis[x]|vis[y])continue;
			x=gf(x);y=gf(y);
			if(x==y)continue;
			fa[x]=y;
			while(!s[x].empty())s[y].push(s[x].top()),s[x].pop();//合并两个pq
		}else{
			rad(x);
			if(vis[x])puts("0");
			else{
				x=gf(x);
				if(s[x].empty())puts("0");
				else{
					y=-s[x].top().first;
					while(!s[x].empty()){
						if(y==-s[x].top().first)
						vis[s[x].top().second]=1,s[x].pop();//删除最小值
						else break;
					}
					printf("%d\n",y);
				}
			}
		}
	}
}
```

---

## 作者：gyh20 (赞：2)

### 使用左偏树即可
先利用并查集的思想将每一个人设成一个独立的团。

对于每一个merge操作，合并i,j所在的两个堆。

对于每一个kill操作，从i所在的堆中删除i。

注意记得每个人的死活，对于已死的人的操作自动忽略。

代码如下：
```c
#include<iostream>
#include<cstdio>
#define N 5000002
using namespace std;
int a[N],b,n,c,m,k,l,ls[N],rs[N],fa[N],dis[N],u,v,t,r[N];
bool d[N];
char p;
inline int read(){
    char v=getchar();
    int s=0;
    while(v<'0'||v>'9')v=getchar();
    while(v>='0'&&v<='9'){
        s=(s<<3)+(s<<1)+v-'0';
        v=getchar();
    }
    return s;
}
int merge(int x,int y){
	if(!x||!y)return x+y;
	if(a[x]>a[y])swap(x,y);
	rs[x]=merge(rs[x],y);
	if(dis[ls[x]]<dis[rs[x]])swap(ls[x],rs[x]);
	if(!rs[x])dis[x]=0;
	else dis[x]=dis[rs[x]]+1;
	return x;
}
int root(int s){
	if(fa[s]==s)return s;
	fa[s]=root(fa[s]);
	return fa[s];
}
int main(){
n=read();for(int i=1;i<=n;++i)fa[i]=i;
for(int i=1;i<=n;++i)a[i]=read(),r[i]=i;
m=read();

for(int i=1;i<=m;++i){
	p=getchar();
	while(p!='M'&&p!='K')p=getchar();
	if(p=='M'){
    u=read();
	v=read();
	if(!d[u]&&!d[v]){u=root(u);v=root(v);if(u==v)continue;
	fa[u]=v;
	r[v]=merge(r[u],r[v]);}
	}	
	else{
		u=read();
		if(d[u])printf("0\n");
		else{
			u=root(u);
			printf("%d\n",a[r[u]]);
			d[r[u]]=1;
			r[u]=merge(ls[r[u]],rs[r[u]]);
		}
	}
	
}
// for(int i=1;i<=n;i++)cout<<root(i)<<" ";
 
}
```


---

## 作者：Mosher (赞：1)

### 确实是道左偏树裸题
[模板 P3377](https://www.luogu.org/problemnew/show/P3377)
#### 思路：
```cpp
用并查集维护,
而我们在路径压缩之后,必须要在Pop后，
给Pop掉的点一个指针指向新的根(否则就会直接断掉)

```
（源自：[@_皎月半洒花巨佬](https://www.luogu.org/space/show?uid=28313)） Orz

特别提示：

注意在题中字母“M”，“K”的处理用cin>>(无视换行符等等la ji wan yi)

不然getchar，scanf坑哭你QAQ（某Mo的亲身经历）

Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e6+5;
#define ls tree[x].son[0]
#define rs tree[x].son[1]
int n,m,b,c;char a;

struct node{
    int rt,dis,son[2],val;
}tree[maxn];

inline void s_wap(int &x,int &y){x^=y^=x^=y;}//get到花姐的姿势

inline int merge(int x,int y){
    if(!x||!y) return x+y;
    if(tree[x].val>tree[y].val||(tree[x].val==tree[y].val&&x>y)) s_wap(x,y);
    rs=merge(rs,y);
    if(tree[rs].dis>tree[ls].dis) swap(ls,rs);
    tree[rs].rt=tree[ls].rt=tree[x].rt=x; 
    tree[x].dis=tree[rs].dis+1;
    return x;
}

inline int find(int x){
    return x==tree[x].rt ? x:tree[x].rt=find(tree[x].rt);
}

inline void Pop(int x){
    tree[x].val=-1;tree[ls].rt=ls;tree[rs].rt=rs;tree[x].rt=merge(ls,rs);
}

int main(){
    scanf("%d",&n);
    tree[0].dis=-1;
    for(int i=1;i<=n;++i){
        tree[i].rt=i;
        scanf("%d",&tree[i].val); 
    }
    scanf("%d",&m);
    while(m--){
    	cin>>a;
        scanf("%d",&b);
        if(a=='M'){
            scanf("%d",&c);
            if(tree[c].val==-1||tree[b].val==-1) continue;
            int fb=find(b),fc=find(c);
            if(fb!=fc) tree[fb].rt=tree[fc].rt=merge(fb,fc);
        }else{
            if(tree[b].val==-1) puts("0");
            else printf("%d\n",tree[find(b)].val),Pop(find(b));
        }
    }
    return 0;
}
```
```cpp
对于之前所说的cin>>a
其实可以这么写：
  getchar();getchar();
  scanf("%c",&a);
但这只针对这题，并不是所有题都行，慎用。
用的目的：省时（针对于Linux，非Windows）
（或者你可以在cin>>a之前的scanf("%d\n",&m);）
```
rp++,管理大大求过QAQ

---

## 作者：Honor誉 (赞：0)

就是一模板题。

合并就直接merge。

pop就是将自己的值设为一，再将自己的左右儿子合并即可。

查询直接找到堆顶，输出。

[模板左偏树](https://www.cnblogs.com/2017gdgzoi44/p/11377317.html)

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int dis[1000001],ch[1000001][2],fa[1000001],n,m,x,y,xx,yy,val[1000001];
char op[2];
int merge(int x,int y)
{
	if(!x||!y)
	{
		return x+y;
	}
	if(val[x]>val[y]||(val[x]==val[y]&&x>y))
	{
		swap(x,y);
	}
	ch[x][1]=merge(ch[x][1],y);
	if(dis[ch[x][0]]<dis[ch[x][1]])
	{
		swap(ch[x][0],ch[x][1]);
	}
	fa[x]=fa[ch[x][0]]=fa[ch[x][1]]=x;
	dis[x]=dis[ch[x][1]]+1;
	return x;
}
int getfa(int x)
{
	if(x!=fa[x])
	{
		return fa[x]=getfa(fa[x]);
	}
	return x;
}
void pop(int x)
{
	val[x]=-1;
	fa[ch[x][0]]=ch[x][0];
	fa[ch[x][1]]=ch[x][1];
	fa[x]=merge(ch[x][0],ch[x][1]);
}
int main()
{
	scanf("%d",&n);
	dis[0]=-1;
	for(int i=1;i<=n;i++)
	{
		fa[i]=i;
		scanf("%d",&val[i]);
	}
	scanf("%d",&m);
	for(int i=1;i<=m;i++)
	{
		scanf("%s%d",op,&x);
		if(op[0]=='M')
		{
			scanf("%d",&y);
			if(x==y||val[x]==-1||val[y]==-1)
			{
				continue;
			}
			xx=getfa(x);
			yy=getfa(y);
			if(xx!=yy)
			{
				fa[xx]=fa[yy]=merge(xx,yy);
			}
		}else{
			if(val[x]==-1)
			{
				puts("0");
			}else{
				xx=getfa(x);
				printf("%d\n",val[xx]);
				pop(xx);
			}
		}
	}
	return 0;
}
```

---

## 作者：redegg (赞：0)

并查集+线段树操作思路，并查集就是找爸爸，找祖宗，线段树就是找儿子并且修改最小值。

什么意思呢，我们可以把操作画图，两个节点并入一个节点（合并）可以看作两个点的根节点为并入的那个节点，于是操作完后我们发现他建立了一颗二叉树。

每次合并就是并查集，顺便判断一下下。

那么kill呢？kill其实就是类似线段树操作，我们先找到i号点的根节点，然后依次下访，找到后更改其节点值为无穷大（随便啦），然后上传的时候更新即可，答案就是一开始的根节点的值。

贴下代码（晚上肝题太累了！）

```
#include <bits/stdc++.h>
using namespace std;

int n,m,p;

int l[6000000];
int r[6000000];
int minn[6000000];
int pr[6000010];
bool ok[1000010];
char c[5];

int findfa(int x)
{
    if(pr[x]==x||pr[x]==0)
    {
        pr[x]=x;
        return x;
    }
    return pr[x]=findfa(pr[x]);
}

void mix(int x,int y)
{
    if(ok[x]||ok[y]||findfa(x)==findfa(y))
        return ;
    else
    {
        int ll,rr;
        ll=findfa(x);
        rr=findfa(y);
        p++;
        minn[p]=min(minn[ll],minn[rr]);
        l[p]=ll;
        r[p]=rr;
        pr[rr]=p;
        pr[ll]=p;
    }
}

void change(int x)
{
    //cout<<x<<endl;
    if(minn[l[x]]>1e7&&minn[r[x]]>1e7)
    {
        ok[x]=1;
        minn[x]=1e9;
        return ;
    }
    if(l[x]==0&&r[x]==0)
    {
        ok[x]=1;
        minn[x]=1e9;
        return ;
    }
    if(minn[l[x]]==minn[x])
        change(l[x]);
    if(minn[r[x]]==minn[x])
        change(r[x]);
    minn[x]=min(minn[l[x]],minn[r[x]]);
}

void kill(int x)
{
    if(ok[x])
    {
        printf("0\n");
        return ;
    }
    x=findfa(x);
    if(minn[x]>1e7){
        printf("0\n");
        return ;
    }
    printf("%d\n",minn[x]);
    change(x);
}

int main()
{
    scanf("%d",&n);
    p=n;
    memset(minn,0x3f,sizeof(minn));
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&minn[i]);
        pr[i]=i;
    }
    scanf("%d",&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%s",c+1);
        if(c[1]=='M')
        {
            int x,y;
            scanf("%d%d",&x,&y);
            mix(x,y);
        }
        else
        {
            int x;
            scanf("%d",&x);
            kill(x);
        }
    }
    //asystem("pause");
    return 0;
}

```

---

## 作者：LingFengGold (赞：0)

# 一道很朴素且几乎无需修改的左偏树模板题
#### 没做过模板题的建议先去做一下（[【模板】左偏树（可并堆）] (https://www.luogu.org/problemnew/show/P3377)） 当然这道题也不能完全照搬，我就因为一个小失误WA了；这道题让判断“M”与“K”，读入这两个字符的时候不能单独读入字符，要读字符串，比如ch[10],scanf("%s",ch),if(ch[0]=='M')这样来判断，否则可能会出问题；还有就是根据题意，应该不会出现两个士兵分数一样，所以也不必特判。只需注意这两点，改改数组大小，这题就轻松过了~

我用的结构体，其他好多题解用的数组，形式不大一样，本质一样。
```c
#include<iostream>
#include<cstdio>
#include<algorithm>
#define maxn 1000001
struct node
{
    int dist,lson,rson,val,fa;
}s[maxn];
int n,m,p,t;
int inline read()
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-') f=-1; ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
void swap(int &x,int &y){t=x;x=y;y=t;}
int getf(int x)
{
    return s[x].fa?getf(s[x].fa):x;
}
int merge(int x,int y)
{
    if(!x||!y)
    {
        return x+y;
    }
    if(s[x].val>s[y].val||(s[x].val==s[y].val&&x>y))
    {
        swap(x,y);
    }
    int &ul=s[x].lson,&ur=s[x].rson;
    ur=merge(ur,y);
    s[ur].fa=x;
    if(s[ul].dist<s[ur].dist)
    {
        swap(ul,ur);
    }
    s[x].dist=s[ur].dist+1;
    return x;
}
void pop(int x)
{
    int ul=s[x].lson,ur=s[x].rson;
    s[x].val=-1;
    s[ul].fa=0,s[ur].fa=0;
    merge(ul,ur);
}
int main()
{
    n=read();
    s[0].dist=-1;
    for(int i=1;i<=n;i++)
    {
        s[i].val=read();
    }
    m=read();
    for(int i=1;i<=m;i++)
    {
        char ch[10];
        scanf("%s",&ch);
        if(ch[0]=='M')
        {
            int x,y;
            x=read();y=read();
            if(s[x].val==-1||s[y].val==-1)
            {
                continue;
            }
            if(x==y)
            {
                continue;
            }
            int fx=getf(x),fy=getf(y);
            if(fx!=fy) merge(fx,fy);
        }
        else
        {
            int x=read();
            if(s[x].val==-1)
            {
                printf("0\n");
            }
            else
            {
                int y=getf(x);
                printf("%d\n",s[y].val);
                pop(y);
            }
        }
    }
    return 0;
}
```

---

## 作者：GadTD (赞：0)

# 差分+lca，但是有一个坑

首先需要用求lca的算法

无论用倍增，st , tarjan(这题可以离线)，还是树剖都行；

**然后显然我们要找出（经过次数\*边的权值）最大的一条边**

边的权值在输入数据中，但经过次数怎么求？

首先这个图是棵树，那么我们就会自然而然的想到差分了

用cnt[]数组存经过该节点与其父节点所连边的编号

每次输入请求时，在所输入的两个节点的cnt[]打+1标记，在其lca打-2标记。

然后一遍深搜，在回溯的过程中找到最大的（经过次数\*边的权值）和花费的总时间。

相减即可

但是，如果你考虑的很多，把花费的时间存到long long中，那你就会被坑（我就被坑了），这估计是题目的问题，想AC要用int存sum

下附代码


```cpp
    #include <bits/stdc++.h>
    #define maxn 100100
    using namespace std ;
    struct node{
        int to , nex , val ;
    } edge[ maxn << 1 ];
    int n , m , num , mi , head[ maxn ] , fa[ maxn ] , ff[ maxn ] , dep[ maxn ] , son[ maxn ] , tp[ maxn ] , siz[ maxn ] , cnt [ maxn ] ;
    int sum ;
    int read ()
    {
        int f = 1 , x = 0 ;
        char ch = getchar () ;
        while ( ! isdigit ( ch ) )
        {
            if ( ch == '-' )
                f = -1 ;
            ch = getchar () ;
        }
        while ( isdigit ( ch ) ) 
        {
            x = ( x << 3 ) + ( x << 1 ) + ( ch ^ '0' ) ;
            ch = getchar () ;
        }
        return f * x ;
    } 
    void add ( int x , int y , int v )
    {
        edge[ ++ num ] = ( node ){ y , head[ x ] , v } ;
        head[ x ] = num ;
    }
    //以下为树剖
    void dfs1 ( int u ) 
    {
        siz[ u ] = 1 ;
        for ( int i = head[ u ] ; i ; i = edge[ i ].nex )
        {
            int v = edge[ i ].to ;
            if ( dep[ v ] ) continue ;
            dep[ v ] = dep[ u ] + 1 ;
            fa[ v ] = u ; ff[ v ] = i ;
            dfs1 ( v ) ;
            siz[ u ] += siz[ v ] ;
            if ( siz[ son[ u ] ] < siz[ v ] ) son[ u ] = v ;
        }
    }
    void dfs2 ( int u , int tpz )
    {
        tp[ u ] = tpz ;
        if ( ! son[ u ] ) return ;
        dfs2 ( son[ u ] , tpz ) ;
        for ( int i = head[ u ] ; i ; i = edge[ i ].nex )
        {
            int v = edge[ i ].to ;
            if ( v == fa[ u ] || v == son [ u ] ) continue ;
            dfs2 ( v , v ) ;
        }
    }
    //以上为树剖
    int lca ( int x , int y ) 
    {
        while ( tp[ x ] != tp[ y ] )
        {
            if ( dep[ tp[ x ] ] < dep[ tp[ y ] ] ) y = fa[ tp [ y ] ] ;
            else x = fa[ tp[ x ] ] ;
        }
        return dep[ x ] < dep [ y ] ? x : y ;
    }
    void dfs ( int u )//差分的深搜
    {
        for ( int i = head[ u ] ; i ; i = edge[ i ].nex )
        {
            int v = edge[ i ].to ;
            if ( v == fa[ u ] ) continue ;
            dfs ( v ) ;
            cnt[ u ] += cnt[ v ] ; 
        }
        sum += cnt[ u ] * edge[ ff[ u ] ].val ;
        mi = max ( mi , cnt[ u ] * edge[ ff[ u ] ].val ) ;
    }
    int main ()
    {
        memset ( edge , 0 , sizeof edge ) ;
        int x , y , z ;
        n = read () ; m = read () ;
        for ( int i = 1 ; i < n ; i ++ ) 
        {
            x = read () ; y = read () ; z = read () ;
            add ( x , y , z ) ;
            add ( y , x , z ) ;
        }
        dep[ 1 ] = 1 ; dfs1 ( 1 ) ;
        dfs2 ( 1 , 1 ) ; 
        for ( int i = 1 ; i <= m ; i ++ )
        {
            x = read () ; y = read () ; 
            z = lca ( x , y ) ; 
            cnt[ x ] ++ ; cnt[ y ] ++ ; cnt[ z ] -= 2 ;
        }
        dfs ( 1 ) ;
        cout << sum - mi ;
    }

```

---


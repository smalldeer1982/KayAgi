# 【模板】可持久化线段树 1（可持久化数组）

## 题目背景

**UPDATE : 最后一个点时间空间已经放大**

2021.9.18 增添一组 hack 数据 by @panyf

标题即题意

有了可持久化数组，便可以实现很多衍生的可持久化功能（例如：可持久化并查集）

## 题目描述

如题，你需要维护这样的一个长度为 $ N $ 的数组，支持如下两种操作：


1. 在某个历史版本上修改某一个位置上的值。

2. 访问某个历史版本上的某一位置的值。


此外，每进行一次操作，就会生成一个新的版本。版本编号即为当前操作的编号（从 $1$ 开始编号，版本 $0$ 表示初始状态数组）。

**对于操作 $2$，即为生成一个完全一样的版本，不作任何改动**。即，询问生成的版本是询问所访问的那个版本的复制。

## 说明/提示

### 数据规模

对于 $30\%$ 的数据，$ 1 \leq N, M \leq {10}^3 $。

对于 $50\%$ 的数据，$ 1 \leq N, M \leq {10}^4 $。

对于 $70\%$ 的数据，$ 1 \leq N, M \leq {10}^5 $。

对于 $100\%$ 的数据：

- $ 1 \leq N, M \leq {10}^6$；
- $1 \leq p \leq N$；
- 设当前是第 $x$ 次操作，$0 \leq v < x$；
- $-{10}^9 \leq a_i,c  \leq {10}^9$。

### 样例说明

所有操作结束后，总共生成了 $11$ 个版本，编号为 $0 \sim 10$，依次为：

版本 $0$：`59 46 14 87 41`，

版本 $1$：`59 46 14 87 41`，

版本 $2$：`14 46 14 87 41`，

版本 $3$：`57 46 14 87 41`，

版本 $4$：`88 46 14 87 41`，

版本 $5$：`88 46 14 87 41`，

版本 $6$：`59 46 14 87 41`，

版本 $7$：`59 46 14 87 41`，

版本 $8$：`88 46 14 87 41`，

版本 $9$：`14 46 14 87 41`，

版本 $10$：`59 46 14 87 91`。

## 样例 #1

### 输入

```
5 10
59 46 14 87 41
0 2 1
0 1 1 14
0 1 1 57
0 1 1 88
4 2 4
0 2 5
0 2 4
4 2 1
2 2 2
1 1 5 91```

### 输出

```
59
87
41
87
88
46```

# 题解

## 作者：hyfhaha (赞：624)

本篇blog主要是给自己（大家）看的。

感谢[longlongzhu123](https://www.luogu.org/space/show?uid=57525)奆佬（此人初二LCT）的指点，使本蒟蒻可以快速开始主席树入门。

# what is 主席树？
$ \ \ \ \ \ \ \ $主席树这个名字只不过是OIer们在思考政(zhe)治(xue)的时候发明的好(du)听(liu)的名字。其实主席树的大名叫“可持久化线段树”，一听这名字就知道主席树很毒瘤，所以他的发明者叫黄嘉泰（hjt***(什么鬼啊?)）。

### 分步理解“可持久化线段树”
$ \ \ \ \ \ \ \ $首先我们先来理解人尽皆知的小名“主席树”，我们可以先看到“主席”这两个字，嗯，很好，很霸气，读起来朗朗上口，所以我们可以知道主席树是一个很**霸气**的东西，~~以上扯淡~~。再来看“树”，从这个字我们可以看出主席树的本质是一棵树，那是一棵什么树，结什么果呢，下面看主席树的大名“可持久化线段树”。

$ \ \ \ \ \ \ \ $看“可持久化”这四个字，很好理解，主席树十分**持久**，因为它可持久化。那什么叫持久呢，“可持久化”定义：可以支持回退，访问之前版本的数据结构；支持回退操作的意思就是可以访问未经过其他操作的版本，也就是说返回到了以前的版本。那么我们继续看“线段树”这几个字眼，十分熟悉！相信大家肯定学过线段树，如果没学过$\color{red} \large \text{线段树}$的话，那就可以跳过这篇blog了。我们可以知道主席树是基于**线段树**的一种**数据结构**WOW。

$ \ \ \ \ \ \ \ $综上所述，主席树是一种~~霸气的~~，持久的，基于线段树的**数据结构**。

------------
## 主席树基本原理
$ \ \ \ \ \ \ \ $前文说了，线段树与主席树的本质是一样的，只不过主席树可持久化，那么难点就在于怎么支持可持久化。

$ \ \ \ \ \ \ \ $我们想要支持回退操作就可以对每一次修改操作都进行一次复制，将未进行操作的线段树版本进行复制，再对原线段树版本进行修改，那么我们就可以访问到旧版本的线段树了。不过现在问题来了，这样的空间复杂度将会乘上一个m，变成O(n*m)。不用说，肯定会陷入mle中不可自拔。

$ \ \ \ \ \ \ \ $那我们来分析一下单点修改的线段树：![主席树1](https://cdn.luogu.com.cn/upload/pic/46128.png)

$ \ \ \ \ \ \ \ $我们发现只有橙颜色经过的结点才被修改过。那么我们就可以思考，我们可不可以只对这些节点进行修改呢？答案当然是可以的，主席树的基本思想就是只对进行修改的结点进行复制。那么主席树是长什么样子的呢，下面一起来看一下吧。![主席树2](https://cdn.luogu.com.cn/upload/pic/46147.png)

$ \ \ \ \ \ \ \ $看着怎么恶心的图，相信大家还是可以发现这个图中主席树的一些性质：

1、每一次修改增加的节点个数为log(n)。

2、增加的非叶子结点会连向一个是其他版本的节点，一个是连向新节点。

3、主席树有很多根……

4、对于每一个根都可以构成一棵完整的线段树。

5、每一个节点都有可能有不只一个爸爸……

$ \ \ \ \ \ \ \ $所以我们可以知道主席树只会对部分节点进行复制，并且每一次复制的节点个数是log(n)。我们每一次想询问一个版本的线段树，就可以在那个版本的根构成的线段树中询问。

但同时也延伸出许多问题：

1、怎么构建新节点？怎么给新节点编号？怎么连边？

2、怎么访问子节点？

3、怎么存根？

$ \ \ \ \ \ \ \ $很明显这些问题在线段树中完全不会出现，我们可以感觉到主席树在建树的代码中会和线段树不同。

现在给出刚才问题的答案：

1、直接开一块内存池存新节点。编号为此时总节点数个数+1。开结构体存子节点编号；线段树建什么边，一指了事。

2、访问子节点编号，不是像线段树一样乘2或乘2+1，而是在结构体存子节点编号。

3、另外开个数组存。

------------

代码主要和线段树差不多，下面就看代码吧。

# 代码  P3919 【模板】可持久化数组

所以我们定义一个节点要存三个信息：左儿子，右儿子，权值
```cpp
struct kkk{
	int l,r,val;
}tree[maxn];
```
新建节点：
```cpp
int clone(int node){
	top++;
	tree[top]=tree[node];//全部信息都传到新节点
	return top;
}
```
建树其实就是新建节点的过程：
```cpp
int maketree(int node,int begin,int end){
	node=++top;
	if(begin==end){
		tree[node].val=a[begin];
		return top;
	}
	int mid=(begin+end)>>1;
	tree[node].l=maketree(tree[node].l,begin,mid);
	tree[node].r=maketree(tree[node].r,mid+1,end);
	return node;
}
```
更新和线段树很像：
```cpp
int update(int node,int begin,int end,int x,int val){
	node=clone(node);	//更新就要新建节点 
	if(begin==end){
		tree[node].val=val;
	}else{
		int mid=(begin+end)>>1;
		if(x<=mid)
			tree[node].l=update(tree[node].l,begin,mid,x,val);	//访问左子树 
		else
			tree[node].r=update(tree[node].r,mid+1,end,x,val);	//访问右子树 
	}
	return node;
}
```
询问也一样：
```cpp
int query(int node,int begin,int end,int x){
	if(begin==end){
		return tree[node].val;
	}else{
		int mid=(begin+end)>>1;
		if(x<=mid)
			return query(tree[node].l,begin,mid,x);	//访问左子树 
		else
			return query(tree[node].r,mid+1,end,x);	//访问右子树 
	}
}
```
那么主席树的操作部分就写完了QwQ

再来看主程序，里面看根怎么存储：
```cpp
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	root[0]=maketree(0,1,n);	//root[i]为i版本的根编号，刚开始编号为0 
	for(int i=1;i<=m;i++){
		scanf("%d%d%d",&rt,&mode,&x);
		if(mode==1){
			scanf("%d",&y);
			root[i]=update(root[rt],1,n,x,y);	//保存版本 
		}
		else{
			printf("%d\n",query(root[rt],1,n,x));	//输出 
			root[i]=root[rt];					//新建版本 
		}
	}
}
```
那么这道题就写完了。~~（其实我觉得一看图就懂了，代码什么的都是假的）~~

---

## 作者：pigeonN (赞：38)

听说stl拓展的rope过不了，那我们就手撸一个吧（笑

（这个rope是没有再平衡功能的版本，不过也能过

我们先看看基本rope的节点结构
```cpp
template<typename T> class RopeNode
{
    friend class Rope<T>;
private:
    RopeNode<T>() = default;
    RopeNode<T>(T t);
    RopeNode<T>(vector<T> & s);
    int Height = 0;//用于平衡操作
                   //不过基于本题实践，不平衡也是可以的
                   //所以下面不会包含再平衡操作
    int Size = 0;
    int Begin = 0;//维护的串在Data中的开始下标
                  //只在叶子节点中可能不为0
    RopeNode<T>* Lson = nullptr;
    RopeNode<T>* Rson = nullptr;
    vector<T>* Data = nullptr;//只在叶子节点不为空指针
};
```

可以看出rope是一颗二叉树，并且维护串的大小以及节点高度。

我们再来看看rope所支持的基本操作

1，Connect 返回将两个rope连接后的结果，不改变原来的两个串，我们保证这个操作花费常数时间，接下来看代码。
```cpp
template<typename T>
RopeNode<T> * Rope<T>::Connect(RopeNode<T> * Left, RopeNode<T> * Right)
{
    if (Left == nullptr) return Right;
    if (Right == nullptr) return Left;
    if (GetHeight(Left->Lson) > GetHeight(Left->Rson) && GetHeight(Left->Lson) > GetHeight(Right))
    {
        return UncheckConnect(Left->Lson, UncheckConnect(Left->Rson, Right));
    }
    if (GetHeight(Right->Rson) > GetHeight(Right->Lson) && GetHeight(Right->Rson) > GetHeight(Left))
    {
        return UncheckConnect(UncheckConnect(Left, Right->Lson), Right->Rson);
    }
    //上述两个if是检查是否能将其中一个串放到另一个串的子树中，并不增加树的高度
    return UncheckConnect(Left, Right);
}

```
```cpp
template<typename T>
RopeNode<T> * Rope<T>::UncheckConnect(RopeNode<T> * Left, RopeNode<T> * Right)
{
    RopeNode<T>* ConnectNode = new RopeNode<T>();
    ConnectNode->Lson = Left;
    ConnectNode->Rson = Right;
    ConnectNode->Height = max(GetHeight(Left), GetHeight(Right)) + 1;//高度信息可以不维护，不过为了说明这玩意是可以进行平衡的，我就暂且保留这部分了
    ConnectNode->Size = GetSize(Left) + GetSize(Right);
    MemoryPool.push_back(ConnectNode);
    return ConnectNode;
}
```

2 Substring 返回一个子串，不改变原来的串，这个操作将花费O（height）的时间，看代码。
```cpp
template<typename T>
RopeNode<T> * Rope<T>::Substring(RopeNode<T> * R, int Start, int Len)
{
    if (R == nullptr) return R;
    if (Start <= 0 && Len >= GetSize(R)) return R;
    if (R->Data != nullptr)
    {
        RopeNode<T>* SubNode = new RopeNode<T>(*R);
        SubNode->Begin = R->Begin + (Start > 0 ? Start : 0);
        SubNode->Size = min(R->Size, Len);
        return SubNode;
    }
    RopeNode<T>* Left, *Right;
    if (Start + Len <= GetSize(R->Lson))return Substring(R->Lson, Start, Len);
    if (Start >= GetSize(R->Lson)) return Substring(R->Rson, Start - GetSize(R->Lson), Len);
    Left = Substring(R->Lson, Start, GetSize(R->Lson) - Start);
    Right = Substring(R->Rson, 0, Len - (GetSize(R->Lson) - Start));
    return Connect(Left, Right);
}
```
这个操作就很容易看懂了，不多加说明。

有了两个基本操作之后我们就可以编写我们需要的Change和Fetch操作了

Change操作
```cpp
template<typename T>
RopeNode<T>* Rope<T>::Change(RopeNode<T>* R, int Index, T t)
{
    if (Index < 0 || Index >= GetSize(R)) return R;
    RopeNode<T>* Left = nullptr, *Right = nullptr;
    if (Index > 0) Left = Substring(R, 0, Index);
    if (Index < GetSize(R) - 1) Right = Substring(R, Index + 1, GetSize(R) - Index - 1);
    RopeNode<T>* MidRope = new RopeNode<T>(t);
    MemoryPool.push_back(MidRope);
    return Connect(Left, Connect(MidRope, Right));
}
```
Fetch操作

```cpp
template<typename T>
T Rope<T>::Fetch(RopeNode<T> * R, int Index)
{
    if (R->Data != nullptr) return (*(R->Data))[R->Begin + Index];
    if (Index >= GetSize(R->Lson))
    {
        return Fetch(R->Rson, Index - GetSize(R->Lson));
    }
    else return Fetch(R->Lson, Index);
}
```

可以看出rope的所有操作都不会改变原本的串，这是一个函数式的数据结构。

至于如何查询对应版本则和其他做法一样，保存对应版本的根即可。

以下是完整AC代码

```cpp
#define _CRT_SECURE_NO_WARNINGS
#pragma once
#include<vector>
#include<algorithm>
#include<stdio.h>
using std::vector;
template<typename T> class Rope;
template<typename T> class RopeNode
{
    friend class Rope<T>;
private:
    RopeNode<T>() = default;
    RopeNode<T>(T t);
    RopeNode<T>(vector<T> & s);
    int Height = 0;
    int Size = 0;
    int Begin = 0;
    RopeNode<T>* Lson = nullptr;
    RopeNode<T>* Rson = nullptr;
    vector<T>* Data = nullptr;
};
template<typename T> class Rope
{
public:
    void MakeEmpty();
    RopeNode<T>* Init(vector<T>& v);
    T Fetch(RopeNode<T>* R, int Index);
    RopeNode<T>* Change(RopeNode<T>* R, int Index, T t);
    inline int GetHeight(RopeNode<T>* R);
    inline int GetSize(RopeNode<T>*R);
    RopeNode<T>* Connect(RopeNode<T>* Left, RopeNode<T>* Right);
    RopeNode<T>* UncheckConnect(RopeNode<T>* Left, RopeNode<T>* Right);
    RopeNode<T>* Substring(RopeNode<T>* R, int Start, int Len);
    vector<RopeNode<T>*>  MemoryPool;
};

#define max(x,y) (x)>(y)?(x):(y)
#define min(x,y) (x)<(y)?(x):(y)
template<typename T>
RopeNode<T>::RopeNode(T t)
    :Size(1)
{
    Data = new vector<T>{ t };
}
template<typename T>
RopeNode<T>::RopeNode(vector<T> & s)
    :Size(s.size())
{
    Data = new vector<T>(s);
}
template<typename T>
void Rope<T>::MakeEmpty()
{
    for (auto i : MemoryPool)
    {
        if (i != nullptr) delete i->Data;
        delete i;
    }
    MemoryPool.clear();
}

template<typename T>
RopeNode<T>* Rope<T>::Init(vector<T>& v)
{
    MakeEmpty();
    RopeNode<T>* R = new RopeNode<T>(v);
    MemoryPool.push_back(R);
    return R;
}

template<typename T>
inline int Rope<T>::GetHeight(RopeNode<T> * R)
{
    return R ? R->Height : -1;
}

template<typename T>
inline int Rope<T>::GetSize(RopeNode<T> * R)
{
    return R ? R->Size : 0;
}

template<typename T>
RopeNode<T> * Rope<T>::Connect(RopeNode<T> * Left, RopeNode<T> * Right)
{
    if (Left == nullptr) return Right;
    if (Right == nullptr) return Left;
    if (GetHeight(Left->Lson) > GetHeight(Left->Rson) && GetHeight(Left->Lson) > GetHeight(Right))
    {
        return UncheckConnect(Left->Lson, UncheckConnect(Left->Rson, Right));
    }
    if (GetHeight(Right->Rson) > GetHeight(Right->Lson) && GetHeight(Right->Rson) > GetHeight(Left))
    {
        return UncheckConnect(UncheckConnect(Left, Right->Lson), Right->Rson);
    }
    return UncheckConnect(Left, Right);
}

template<typename T>
T Rope<T>::Fetch(RopeNode<T> * R, int Index)
{
    if (R->Data != nullptr) return (*(R->Data))[R->Begin + Index];
    if (Index >= GetSize(R->Lson))
    {
        return Fetch(R->Rson, Index - GetSize(R->Lson));
    }
    else return Fetch(R->Lson, Index);
}

template<typename T>
RopeNode<T>* Rope<T>::Change(RopeNode<T>* R, int Index, T t)
{
    if (Index < 0 || Index >= GetSize(R)) return R;
    RopeNode<T>* Left = nullptr, *Right = nullptr;
    if (Index > 0) Left = Substring(R, 0, Index);
    if (Index < GetSize(R) - 1) Right = Substring(R, Index + 1, GetSize(R) - Index - 1);
    RopeNode<T>* MidRope = new RopeNode<T>(t);
    MemoryPool.push_back(MidRope);
    return Connect(Left, Connect(MidRope, Right));
}

template<typename T>
RopeNode<T> * Rope<T>::UncheckConnect(RopeNode<T> * Left, RopeNode<T> * Right)
{
    RopeNode<T>* ConnectNode = new RopeNode<T>();
    ConnectNode->Lson = Left;
    ConnectNode->Rson = Right;
    ConnectNode->Height = max(GetHeight(Left), GetHeight(Right)) + 1;
    ConnectNode->Size = GetSize(Left) + GetSize(Right);
    MemoryPool.push_back(ConnectNode);
    return ConnectNode;
}

template<typename T>
RopeNode<T> * Rope<T>::Substring(RopeNode<T> * R, int Start, int Len)
{
    if (R == nullptr) return R;
    if (Start <= 0 && Len >= GetSize(R)) return R;
    if (R->Data != nullptr)
    {
        RopeNode<T>* SubNode = new RopeNode<T>(*R);
        SubNode->Begin = R->Begin + (Start > 0 ? Start : 0);
        SubNode->Size = min(R->Size, Len);
        return SubNode;
    }
    RopeNode<T>* Left, *Right;
    if (Start + Len <= GetSize(R->Lson))return Substring(R->Lson, Start, Len);
    if (Start >= GetSize(R->Lson)) return Substring(R->Rson, Start - GetSize(R->Lson), Len);
    Left = Substring(R->Lson, Start, GetSize(R->Lson) - Start);
    Right = Substring(R->Rson, 0, Len - (GetSize(R->Lson) - Start));
    return Connect(Left, Right);
}
Rope<int> Array;
vector<RopeNode<int>*> Root;
int main(void)
{
    int n, m, i;
    vector<int> init;
    scanf("%d %d", &n, &m);
    for (i = 0; i < n; ++i)
    {
        int t;
        scanf("%d", &t);
        init.push_back(t);
    }
    Root.push_back(Array.Init(init));
    for (i = 0; i < m; ++i)
    {
        int ver, opt, loc, val;
        scanf("%d %d %d", &ver, &opt, &loc);
        if (opt == 2)
        {
            printf("%d\n", Array.Fetch(Root[ver], loc-1));
            Root.push_back(Root[ver]);
        }
        else
        {
            scanf("%d", &val);
            Root.push_back(Array.Change(Root[ver], loc-1, val));
        }

    }
    Array.MakeEmpty();
}
```




---

## 作者：Fading (赞：30)

可持久化数组，可以访问历史版本的数组。

我们考虑使用可持久化数据结构——主席树，如果不理解可以左转模板。

主席树对数组的每一个前缀建树。我们都知道其中$root$数组表示前缀$1..i$主席树的根。
那我们现在换一种方式建树，我们对每一次操作带来的版本建线段树，维护数组的权值。

什么意思呢？看图(我们设这个数组为a={1,2,3,4})：

![](https://cdn.luogu.com.cn/upload/pic/29608.png)

我们发现，这棵线段树叶子节点的权值就是它所对应数组内数的权值，这和普通线段树是类似的。

### 但是我们令非叶子节点的权值为空。这只是为了方便二分查找而设置的。

所以我们在查询数组内数的值时，直接单点询问就可以了，时间复杂度$O(logN)$

```
int query(int rt,int l,int r,int kkk){
    if (l==r) return tree[rt].sum;
    int mid=(l+r)>>1;
    if (kkk<=mid) return query(tree[rt].l,l,mid,kkk);
    else return query(tree[rt].r,mid+1,r,kkk);
}
主程序内：
query(树根,1,n,访问数组的下标);

```
我们令初始状态为第$0$个状态，这个树根即为$root[0]$。
如果我们把$a[4]$改为$5$呢？我们新建一个根$root[1]$

和主席树一样，数组$a[1]$、$a[2]$没有变化，直接连接，和主席树一样。

![](https://cdn.luogu.com.cn/upload/pic/29609.png)

创造右节点。

![](https://cdn.luogu.com.cn/upload/pic/29610.png)

然后$a[3]$也没有变化，连接

![](https://cdn.luogu.com.cn/upload/pic/29611.png)

随后，创造新的叶子节点($a[4]=5$)

代码和主席树神似。
```
void build(int &rt,int l,int r){
    rt=++cnt;
    if(l==r){tree[rt].sum=a[l];return;}
    int mid=(l+r)>>1;
    build(tree[rt].l,l,mid);build(tree[rt].r,mid+1,r);
}//初始建设
void update(int num,int &rt,int l,int r){
    tree[++cnt]=tree[rt]; rt=cnt; 
    int mid=(l+r)/2;
    if (l==r){tree[rt].sum=aaaa; return;}
    if (num<=mid) update(num,tree[rt].l,l,mid);
    else update(num,tree[rt].r,mid+1,r);
}//更新
```
时间复杂度$O(logN)$，我们发现，这次修改我们创造了一个新树根($root[1]$),这恰好表示了第一次修改后的状态。

这么一来，回到某一个状态，就很简单了，若要访问某一个状态i，访问或更新时直接使用$root[i]$即可。

代码如下：
```
#include<bits/stdc++.h>
#define res register int 
#define ll long long
#define jsz inline
using namespace std;
int cnt,n,a[1000660],m,root[1000660],aaaa;
jsz int read(){
    int x=0,f=1;char ch=getchar();
    while (!isdigit(ch)){
        if (ch=='-')f=-1;
        ch=getchar();
    }
    while (isdigit(ch)){
        x=x*10+ch-48;
        ch=getchar();
    }
    return x*f;
}
struct ZXT{
    int l,r,sum;
}tree[20006660];
jsz void build(int &rt,int l,int r){
    rt=++cnt;
    if(l==r){tree[rt].sum=a[l];return;}
    int mid=(l+r)>>1;
    build(tree[rt].l,l,mid);build(tree[rt].r,mid+1,r);
}
jsz void update(int num,int &rt,int l,int r){
    tree[++cnt]=tree[rt]; rt=cnt; 
    int mid=(l+r)/2;
    if (l==r){tree[rt].sum=aaaa; return;}
    if (num<=mid) update(num,tree[rt].l,l,mid);
    else update(num,tree[rt].r,mid+1,r);
}
jsz int query(int rt,int l,int r,int kkk){
    if (l==r) return tree[rt].sum;
    int mid=(l+r)>>1;
    if (kkk<=mid) return query(tree[rt].l,l,mid,kkk);
    else return query(tree[rt].r,mid+1,r,kkk);
}
int main(){
    n=read();m=read();
    for (res i=1;i<=n;i++) a[i]=read();
    build(root[0],1,n);
    for (res i=1;i<=m;i++){
        int xxxx=read();int yyyy=read();
        if (yyyy==1){
            int zzzz=read();aaaa=read();
            root[i]=root[xxxx];
            update(zzzz,root[i],1,n);
        }else{
            int zzzz=read();
            printf("%d\n",query(root[xxxx],1,n,zzzz));
            root[i]=root[xxxx];
        }
    }
}
```

---

## 作者：huangboning (赞：19)

这题一眼裸的可持久化线段树，但可持久化线段树是 $O(n \log n)$ 的，我们有 $O(n)$ 的离线 dfs 做法。

## 算法介绍
我们把所有版本抽象成一棵树，那么每个版本的子节点为由该版本为基础生成的所有版本，树上的边则为所有操作。我们从根节点开始 dfs，当走过一条边时，进行修改操作，更新数组的值。当走到一个版本 $v$ 时，遍历这个节点的询问，每个询问 $(v,p)$ 的答案即为 $a_{p}$。

## 正确性证明
假设目前走到了版本 $v$，那么你一定经过了这个版本的所有父节点。也就是说，你一定进行了从初始状态后的所有修改操作。那么，此时的 $a$ 数组就是当前版本的数组，此时直接处理询问就行了。

## 代码实现

有个小细节，每一个版本可能有多个询问，此时应使用一个 vector 来存每个版本的询问。

还有个特殊情况，对于每个询问 $(v,p)$，需生成一个新版本 $i$，与版本 $v$ 相同。那么我们就将 $i$ 与 $v$ 的父节点连边，修改操作与版本 $v$ 相同，这样 dfs 到这个版本时就会与版本 $v$ 保持一致。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int x,y,z;//i->x,a[y]=z
};
int n,m,a[2000010],ans[2000010],x[2000010],y[2000010],z[2000010],cnt;
vector<pair<int,int>>q[2000010];//{a[i]=x,id}
vector<node>v[2000010];
void dfs(int xx){
	for(int i=0;i<q[xx].size();i++)ans[q[xx][i].second]=a[q[xx][i].first];//处理答案
	for(int i=0;i<v[xx].size();i++){//遍历出边
		int x=v[xx][i].x,y=v[xx][i].y,z=v[xx][i].z,tmp=a[y];//tmp记录此时a[y]值，方便还原
		a[y]=z;//修改操作
		dfs(x);
		a[y]=tmp;//还原
	}
}
signed main()
{
	ios::sync_with_stdio(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i];
	int t=1e6+1;//t为根节点，以及版本0的父节点，因为询问0时会产生一个与0相同的版本，就全部向t连边
	x[0]=t,y[0]=1,z[0]=a[1];
	v[x[0]].push_back({0,y[0],z[0]});//t->0
	for(int i=1;i<=m;i++){
		int op;
		cin>>x[i]>>op>>y[i];
		int xx=x[i],yy=y[i],zz;
		if(op==1){
			cin>>z[i];zz=z[i];
			v[xx].push_back({i,yy,zz});
		}
		else{
			v[x[xx]].push_back({i,y[xx],z[xx]}),q[i].push_back({yy,++cnt});//复制版本，加入询问
			x[i]=x[xx];
			y[i]=y[xx];
			z[i]=z[xx];//记得把x,y,z数组改掉，否则复制该版本时会出问题
		}
	}
	dfs(t);//从根节点t开始dfs
	for(int i=1;i<=cnt;i++)cout<<ans[i]<<"\n";
}
```

---

## 作者：UhhhQQQU (赞：13)

 _**前置知识：线段树**_ 

可持久化数组可以用可持久化线段树或者可持久化平衡树实现，在本篇题解中，~~因为本蒟蒻只会可持久化线段树，~~ 我们先来研究一下如何使用可持久化线段树实现可持久化数组。

>引入

首先，我们对这一题的第一想法是对每一个历史版本新建一个数组~~别注意题目标题，那不重要~~。但是，题目庞大的数据范围会使它MLE，那么，我们就需要一种数据结构来优化空间，它就是——可持久化线段树。

>原理

可持久化线段树，就是把题目中的数据，放入线段树的**叶子节点**中操作。等等，放在线段树里？？？这不是更会MLE吗？

本蒟蒻的回答：



其实是不会的。

原理是什么呢？其实，我们对于每一次修改操作，并不用多新建一个线段树，而只用新建一条从根节点到链就可以了。只用新建一条链的原因是因为我们的线段树是以叶子节点储存数据的，我们要以从根节点到这一个叶子节点上所有节点的数据新建出一条链。（如果不理解的话就联系一下线段树的修改操作）（注意：可持久化线段树是新建节点，而不是修改节点数据，因为存储历史版本）

不理解的话可以看一下下图。
![题解](https://cdn.luogu.com.cn/upload/pic/56149.png)

可持久化线段树在每一次新建操作只用新建O(logn)个节点，所以它比朴素的算法在空间上要优化多了！

>代码

其实这里还有一个关于历史版本的数组rt[]，但非常简单，就不用多说了。

```
#include<cstdio>
int n,m,rt[1000010],cnt;//cnt记录版本的序号 
struct tree{
	int ls,rs,value;
}t[21000010];
inline void read(int &x,char ch=getchar(),bool f=0)
{
	for(x=0;ch>'9'||ch<'0';f=ch=='-',ch=getchar());
	for(;ch>='0'&&ch<='9';x=(x<<3)+(x<<1)+(ch^48),ch=getchar());
	(f)&&(x=-x);
}
void build(int &point,int l,int r)
{
	point=++cnt;
	if(l==r)
	{
		read(t[point].value);
		return;
	}
	int mid=(l+r)>>1;
	build(t[point].ls,l,mid);
	build(t[point].rs,mid+1,r);
}
void change(int &point,int last,int l,int r,int pos,int value)
{
	point=++cnt,t[point]=t[last];
	if(l==r)
	{
		t[point].value=value;
		return;
	}
	int mid=(l+r)>>1;
	if(pos<=mid)change(t[point].ls,t[last].ls,l,mid,pos,value);
	else change(t[point].rs,t[last].rs,mid+1,r,pos,value);
}
int que(int point,int l,int r,int loc)
{
	if(l==r)return t[point].value;
	int mid=(l+r)>>1;
	if(loc<=mid)return que(t[point].ls,l,mid,loc);
	else return que(t[point].rs,mid+1,r,loc);
}
int main()
{
	read(n),read(m);
	build(rt[0],1,n);
	for(int i=1,last,flag,x,y,loc;i<=m;i++)
	{
		read(last),read(flag);
		if(flag==1)
		{
			read(x),read(y);
			change(rt[i],rt[last],1,n,x,y);
		}
		else
		{
			read(loc);
			printf("%d\n",que(rt[last],1,n,loc));
			rt[i]=rt[last];//注意新建的版本序号 
		}
	}
}
```

可持久化数组在可持久化算法中是一个非常重要的知识点，请大家好好记住！

~~哪一位大佬可以教我可持久化平衡树鸭。。。~~

---

## 作者：USSENTERPRISE (赞：6)

# $0.$ 前言
~~出题出挂了，来好好学主席树了~~

### 前置知识

线段树

没了

# $1.$ 简介

对于使用线段树，我们可以较好地解决“带修改的全局第k大（或小）问题”。但是对于某个区间进行求第k大（或小）操作就不是那么容易了。

## $1.1$ “可持久化”

可持久化一词在数据结构中十分常见。“可持久化”的意思就是“带有历史版本的”数据结构。而在我们所接触到的基本数据结构中（如数组、并查集、平衡树等）都有各自的可持久化版本。

## $1.2$ 主席树的引出

主席树，又名 **“可持久化线段树”**。~~至于为什么叫“主席树”我也不是特别明白~~。其基本状态就是一个可以查询多个历史版本的线段树。

## $1.3$ 模板题

 [P3834 【模板】可持久化线段树 1（主席树）](https://www.luogu.com.cn/problem/P3834)

>## 题目背景
>
>这是个非常经典的主席树入门题——静态区间第 $k$ 小
>
>## 题目描述
>
>如题，给定 $n$ 个整数构成的序列，将对于指定的闭区间查询其区间内的第 $k$ 小值。

>## 输入格式
>第一行包含两个正整数 $n,m$，分别表示序列的长度和查询的个数。

>第二行包含 $n$ 个整数，表示这个序列各项的数字。

>接下来 mm 行每行包含三个整数 $l,r,k$ , 表示查询区间 $[l,r]$ 内的第 $k$ 小值。

>## 输出格式

>输出包含 $m$ 行，每行一个整数，依次表示每一次查询的结果

# $2.$ 主席树

## $2.1$ 朴素思想

根据上文所说，主席树就是带有历史版本的线段树。如果要维护历史版本，最普通的思想就是建立多个完整的线段树，并在其上面进行操作。

但是很明显这个方案是不可行的。对于一个时间复杂度在 $O(nlogn)$ 级别上的算法来说，数据通常在 $10^5 - 10^6$。如果维护的历史版本过多，会导致空间复杂读过大(每个历史版本的空间都在 $n<<2$ 即 $n*4$ 的级别上)。

## $2.2$ 正解

对于每次修改，几乎没有对全局所有节点的修改。所以在进行修改时我们只需要将被修改的点建立一个新的“存档”就可以完成修改。

一般的我们只需要新建从根开始向下经过的每一个点就行了。（如下图所示）



## $2.3$ 模板题解决思路

模板题要求查询区间内第k小。根据以往经验我们可以选择运用“权值线段树”解决问题。

对于题目要求的区间查询，我们可以运用前缀和的思想解决问题，即用 $ [1,l-1] $ 中的数据与 $[1,r]$ 中的数据做差得出区间内的“权值线段树”（而不用以爆炸的复杂度为每次询问建树）

## $2.3$ 代码实现（以模板题为例）

### 主席树的建立

对于主席树我们并不能像线段树那样通过公式（$ls=now<<1,\ rs=now<<1|1$）计算出其左右儿子的下标，所以我们就需要建立起数组（或结构体解决）记录节点信息

```cpp
const int N=2e5+15;
int rt[N],ls[N<<5],rs[N<<5],sum[N<<5],tot;
```

然后就是建树了。

建树的时候对于模板题我们需要先建一个空的树，作为以后修改的基准点。

```cpp
void build(int &o,int l,int r){
	o=++tot;
	if(l==r) return;
	int mid=(l+r)>>1;
	build(ls[o],l,mid);
	build(rs[o],mid+1,r);
}
```
~~（真的和线段树建树一模一样呢（大雾））~~

### 修改

我们知道，对于一颗树，如果想要从根访问某个叶子节点，我们需要经过一条链。由于在线段树的单点修改中，我们经过链上的点都需要被修改，所以我们只需要增加这一条链的副本即可。

```cpp
	
inline int modify(int o,int l,int r,int p){
	int oo=++tot;
	ls[oo]=ls[o],rs[oo]=rs[o],sum[oo]=sum[o]+1;
	if(l==r) return oo;
	int mid=(l+r)>>1;
	if(p<=mid) ls[oo]=modify(ls[oo],l,mid,p);
	else rs[oo]=modify(rs[oo],mid+1,r,p);
	return oo;
}

```

### 模板题的查询

模板题的查询和线段树的基本相同。在查询的时候可以想象一颗线段树，每个节点的值是以 $rt[r]$ 为根的线段树相应节点的值减去 $rt[l-1]$ 为根的线段树相应节点的值（可以类比前缀合理解）

对于这样一个线段树就可以运用已有知识解决。

```cpp
inline int query(int L,int R,int l,int r,int k){
	int ans,mid=(l+r)>>1,x=sum[ls[R]]-sum[ls[L]];
	if(l==r) return l;
	if(x>=k) ans=query(ls[L],ls[R],l,mid,k);
	else ans=query(rs[L],rs[R],mid+1,r,k-x);
	return ans;
}
```


# $3.$  最重要的应用之一 —— 可持久化数组

主席树可以较好地维护一个“支持查询历史版本的”线段树，对于可持久化数组我们可以利用其支持历史版本的特点，实现可持久化

## $3.1$ 模板题

- [P3919 【模板】可持久化数组（可持久化线段树/平衡树）](https://www.luogu.com.cn/problem/P3919)

> ### 题目描述
>如题，你需要维护这样的一个长度为 NN 的数组，支持如下几种操作
>
>1. 在某个历史版本上修改某一个位置上的值
>
>2. 访问某个历史版本上的某一位置的值
>
>此外，每进行一次操作（对于操作2，即为生成一个完全一样的版本，不作任何改动），就会生成一个新的版本。版本编号即为当前操作的编号（从1开始编号，版本0表示初始状态数组）
>
>### 输入格式
>输入的第一行包含两个正整数 $N,M$, 分别表示数组长度和操作的个数
>
>第二行包含 $N$ 个整数，依次为初始状态下数组各位的值 (依次为 $a_i$, $1\leq i \leq N$ )
>
>接下来 $M$ 行包含 $3$ 或 $4$ 个整数，代表两种操作之一 ($i$ 为基于的历史版本号)：
>
>> $1.$ 对于操作 $1$ , 格式为 $ v_i\ 1\ loc_i\ value_i$ 即在版本 $v_i$ 的基础上， 将 $a_{loc_i}$ 修改为 $value_i$
>>
>> $2.$ 对于操作 $2$ , 格式为 $ v_i\ 2\ loc_i\ $ 即访问版本 $v_i$ 中 $a_{loc_i}$ 的值， 生成一样版本的对象应为 $v_i$
>
>### 输出格式
>输出包含若干行，依次为每个操作 $2$ 的结果。

## $3.2$ 解决思路

利用主席树解决

我们可以原数组存放在$rt[0]$的树的叶子节点，对于每一次修改直接修改即可

## $3.3$ 代码
```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cctype>
#include<algorithm>
#include<cmath>
#include<queue>

using namespace std;

#define rg register
#define ll long long
#define ull unsigned long long

namespace Enterprise{

	inline int read(){
		rg int s=0,f=0;
		rg char ch=getchar();
		while(not isdigit(ch)) f|=(ch=='-'),ch=getchar();
		while(isdigit(ch)) s=(s<<1)+(s<<3)+(ch^48),ch=getchar();
		return f?-s:s;
	}
	
	const int N=1e6+15;
	int val[N<<5],rt[N],ls[N<<5],rs[N<<5],a[N],tot;
	int n,m;
	
	inline int build(int l,int r){
		int o=++tot;
		if(l==r){ val[o]=a[l];return o; }//遍历到叶子节点赋值
		int mid=(l+r)>>1;
		ls[o]=build(l,mid);
		rs[o]=build(mid+1,r);
		return o;
	}
	
	inline int change(int pre,int l,int r,int x,int v){
		int o=++tot;
		ls[o]=ls[pre],rs[o]=rs[pre],val[o]=val[pre];
		if(l==r){
			val[o]=v;//在叶子节点处修改
			return o;
		}
		int mid=(l+r)>>1;
		if(x<=mid) ls[o]=change(ls[pre],l,mid,x,v);
		else rs[o]=change(rs[pre],mid+1,r,x,v);
		return o;
	}
	
	inline int query(int now,int l,int r,int x){//与正常线段树单点查询无异
		if(l==r) return val[now];
		int mid=(l+r)>>1;
		if(x<=mid) return query(ls[now],l,mid,x);
		else return query(rs[now],mid+1,r,x);
	}
	
	inline void main(){
		n=read(),m=read();
		for(rg int i=1;i<=n;i++) a[i]=read();
		rt[0]=build(1,n);
		for(rg int i=1;i<=m;i++){
			int ver=read(),opt=read(),x=read();
			if(opt==1){
				int v=read();
				rt[i]=change(rt[ver],1,n,x,v);
			}else{
				rt[i]=rt[ver];//直接将当前版本节点编号赋成要求的版本编号。这样可以快捷地完成新建立一个和v_i相同的版本
				printf("%d\n",query(rt[ver],1,n,x));
			}
		}
	}
}

signed main(){
	Enterprise::main();
	return 0;
}
```

# $4.$ 主席树时空复杂度分析

## $4.1$ 时间复杂度

主席树的基本操作的线段树思想大体一致，时间复杂度也基本一致。

对于建树，时间复杂度为 $O(nlogn)$

由于这里查询和修改都是单点操作，所以时间复杂度为 $O(logn)$

所总体时间复杂度基本为 $O((m+n)logn)$

## $4.2$ 空间复杂度

对于 $rt[0]$ 来说，空间复杂度=正常线段树空间复杂度，即最坏 $O(4n)$

对于每次修改，由于仅修改了 $logn$ 个节点，所以所有新建版本的最坏复杂度为 $O(mlogn)$ 

## $4.3$ 小声bb

一般的对于所有节点及其对应值（如节点值，左右儿子等）我们可以开20倍空间，或者 $maxn<<5$ 处理。 ~~各位大佬肯定已经知道了~~。

---

## 作者：cold_jelly (赞：4)

[我的博客](https://www.cnblogs.com/cold-jelly/p/18894210)

模板题：[P3919 【模板】可持久化线段树 1（可持久化数组）](https://www.luogu.com.cn/problem/P3919)

前置知识：[线段树](https://oi-wiki.org/ds/seg/)、动态开点。

****

### 简介

对于一个数据结构，例如普通线段树、树状数组等，我们通常维护的是经过若干次操作后该数据结构的**最新**状态。但对于模板题而言，如果要求我们查询该数据结构所有历史版本的信息时，就需要用到可持久化数据结构了。

何为可持久化？可以支持回退，访问所有历史版本的数据结构就被称为是可持久化的。

比方说对于模板题，不妨按照 naive 的思想看，我们可以在每次修改操作后 copy 一份线段树（预留编号），然后后续访问时再遍历其即可。但是这样做最多会建立 $10^6$ 棵线段树，空间承受不住。不过这种 naive 想法给我们提供了一种实现可持久化的思路。

我们思考，为什么空间炸了呢？原因在于我们开的节点太多了。但是我们又知道，单次修改操作并不会将整棵线段树都发生改变，也就是说，上述 naive 思路**记录了很多无用的、重复的信息**，于是我们可以根据这一点，在每次修改操作时，只 copy 线段树的**部分**节点。基于这样的思路，我们来讲讲可持久化线段树。

### 可持久化线段树的原理

举个例子，现在我们有一棵线段树用于存放区间 $[1,8]$ 的信息，如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/gz0aqpm5.png)

现在我们通过一个操作修改了位置 $6$ 的信息，按照普通线段树操作，相应关联的节点的信息也将被修改（图中红边节点）：

![](https://cdn.luogu.com.cn/upload/image_hosting/1htsdk5a.png)

我们发现，除了红边节点外其余节点的信息并未发生改变，因此在 copy 时无需 copy 这些节点。

我们将 copy 的节点单独拿出来（如图，注意此时原线段树的节点信息并未改变，改变的信息储存在新的节点内）：

![](https://cdn.luogu.com.cn/upload/image_hosting/n7nf46w4.png)

接下来就是作连边处理了。由于在修改后我们依然希望其能够按照正常线段树的功能去进行接下来的操作，所以我们按照线段树的方式给新的节点赋予左右儿子，即将新的节点插入原来的线段树，这个过程可以用左右儿子编号指针（用 $ls$ 和 $rs$ 表示）来实现。如图所示，新加边用红边表示：

![](https://cdn.luogu.com.cn/upload/image_hosting/1ic02z71.png)

我们可以发现，插入节点后，线段树实际上变成了一张有向图。

类似地，如果我们再次修改位置 $8$ 的信息，我们依然可以类似进行操作（这步操作在图中体现为绿色节点及新加边）：

![](https://cdn.luogu.com.cn/upload/image_hosting/xltm4pub.png)

这个过程其实就是可持久化线段树的建立过程。

接下来要解决的问题是，如何通过这个有向图来访问所有历史版本的线段树呢？我们发现，每次修改时，我们新加入的节点中必然是有且仅有一个节点没有父节点，这个节点其实就是每次修改后信息必然改变的根节点；换句话说，这个节点其实是新的线段树的**根节点**，因此每个历史版本的线段树都**唯一**被一个根节点所确定。因此我们在每次访问某个历史版本的线段树时，就可以锚定一个根节点，从根节点往下遍历即可。

具体而言，我们可以用一个 $root$ 数组来存放所有历史版本线段树的根节点，在每次访问时，只需给定其根节点的在 $root$ 中的编号 $k$，即可找到其根节点指针 $root_k$，接着就可以在线段树上进行操作啦。

可以结合下面的图示再理解（前后三张图分别表示我们希望访问三次历史版本的线段树，虚线及浅色表示**不**访问的节点）：

第一个历史版本：

![](https://cdn.luogu.com.cn/upload/image_hosting/62o30xex.png)

第二个历史版本：

![](https://cdn.luogu.com.cn/upload/image_hosting/m6h51745.png)

第三个历史版本：

![](https://cdn.luogu.com.cn/upload/image_hosting/4bmhuqt1.png)

### 可持久化线段树的实现

由于可持久化线段树不再是一棵完全二叉树，我们在给节点编号时不再按层次序编号，而是记录当前节点的左右儿子编号。

```cpp
	struct Tree
	{
		int l, r;
		int v;//值 
	}tr[N * 30];
```

需要注意的是，由于每次修改操作均会创建 $\log n$ 个节点，因此我们最多额外添加 $Q\log n$ 个节点（$Q$ 为询问个数），所以可持久化线段树的空间要求较高。一般我们采用开 $20$ 或 $30$ 倍空间（或者采用 `N<<5`）来避免空间不足的问题。

此外，一般来说，可持久化线段树用动态开点实现，因此我们需要额外记录当前节点编号 $id$。为实现上文所述的实时访问历史版本的功能，我们还需记录根节点：

```cpp
	int id;//编号 
	int root[N];//根节点 
```

准备工作完毕，我们就可以实现可持久化线段树的各项操作啦。

首先来看创建新节点的操作（动态开点），没有什么好说的：

```cpp
	int insert(int u)//动态开点 
	{
		id ++;
		tr[id] = tr[u];
		return id;
	}
```

然后就是建树。可持久化线段树的原始建树过程与线段树基本一样：

```cpp
	int build(int u, int l, int r)
	{
		id ++, u = id;//赋予编号
		if(l == r)
		{
			tr[u].v = a[l];
			return id;//返还编号 
		}
		int mid = l + r >> 1;
		tr[u].l = build(tr[u].l, l, mid);
		tr[u].r = build(tr[u].r, mid + 1, r);
		return u;
	}
```

我们来看模板题需要我们实现什么具体操作：

- 在某个历史版本上修改某一个位置上的值；
- 访问某个历史版本上的某一位置的值。

这其实就是可持久化线段树的修改操作（modify）以及查询操作（query），由于每个历史版本的线段树我们都能够由不同的根节点独立访问，因此这两个操作与普通线段树也是一样的：

```cpp
	int modify(int u, int l, int r, int p, int val)
	{
		u = insert(u);//该路径上的所有点均需重新开点
		if(l == r)
		{
			tr[u].v = val;
			return u;
		}
		int mid = l + r >> 1;
		if(p <= mid) tr[u].l = modify(tr[u].l, l, mid, p, val);
		else tr[u].r = modify(tr[u].r, mid + 1, r, p, val);
		return u;
	}
	int query(int u, int l, int r, int p)
	{
		if(l == r) return tr[u].v;
		int mid = l + r >> 1;
		if(p <= mid) return query(tr[u].l, l, mid, p);
		else return query(tr[u].r, mid + 1, r, p);
	}
```

这就是可持久化线段树的基本操作的实现了。总而言之，可持久化线段树的代码与线段树高度重合，原理基本一致，所以还是比较好写的。

而在主函数的调用中，我们仅需根据版本的索引获取当前版本的根节点即可：

```cpp
	for(int i = 1; i <= Q; i ++)
	{
		scanf("%d%d", &ver, &op);//ver: 版本 
		if(op == 1)
		{
			scanf("%d%d", &p, &c);
			T.root[i] = T.modify(T.root[ver], 1, n, p, c);
		}
		else
		{
			scanf("%d", &p);
			printf("%d\n", T.query(T.root[ver], 1, n, p));
			T.root[i] = T.root[ver];//记录版本索引
		}
	}
```

到此为止，总算是把可持久化线段树好好讲了一遍，不妨再看看总代码再梳理一下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e6 + 10;
int n, Q;
int ver, op, p, c;
int a[N];
struct PersistentSegmentTree
{
	struct Tree
	{
		int l, r;
		int v;//值 
	}tr[N * 30];
	int id;//编号 
	int root[N];//根节点 
	int insert(int u)//动态开点 
	{
		id ++;
		tr[id] = tr[u];
		return id;
	}
	int build(int u, int l, int r)
	{
		id ++, u = id;//赋予编号 
		if(l == r)
		{
			tr[u].v = a[l];
			return id;//返还编号 
		}
		int mid = l + r >> 1;
		tr[u].l = build(tr[u].l, l, mid);
		tr[u].r = build(tr[u].r, mid + 1, r);
		return u;
	}
	int modify(int u, int l, int r, int p, int val)
	{
		u = insert(u);//该路径上的所有点均需重新开点
		if(l == r)
		{
			tr[u].v = val;
			return u;
		}
		int mid = l + r >> 1;
		if(p <= mid) tr[u].l = modify(tr[u].l, l, mid, p, val);
		else tr[u].r = modify(tr[u].r, mid + 1, r, p, val);
		return u;
	}
	int query(int u, int l, int r, int p)
	{
		if(l == r) return tr[u].v;
		int mid = l + r >> 1;
		if(p <= mid) return query(tr[u].l, l, mid, p);
		else return query(tr[u].r, mid + 1, r, p);
	}
}T;
int main()
{
	cin >> n >> Q;
	for(int i = 1; i <= n; i ++) scanf("%d", &a[i]);
	T.root[0] = T.build(0, 1, n);//初始版本的根节点 
	for(int i = 1; i <= Q; i ++)
	{
		scanf("%d%d", &ver, &op);//ver: 版本 
		if(op == 1)
		{
			scanf("%d%d", &p, &c);
			T.root[i] = T.modify(T.root[ver], 1, n, p, c);
		}
		else
		{
			scanf("%d", &p);
			printf("%d\n", T.query(T.root[ver], 1, n, p));
			T.root[i] = T.root[ver];//记录版本索引
		}
	}
	return 0;
}
```

---

## 作者：sLMxf (赞：4)

# [可持久化线段树 1](https://www.luogu.com.cn/problem/P3919)
## Problem
维护序列在某个历史版本上修改/查询某一个位置上的值。
## 算法介绍
什么是可持久化线段树呢？首先来考虑怎么暴力解决这个问题：
### 弱化版：$n,m\le 10^3$
对于每一次操作，我们每次复制一个版本即可。

这样子时空复杂度是 $O(nm)$（易得）。显然过不了。
### 标准版：$n,m\le 10^5$
首先我们将这个序列化成一个线段树。（至于为什么后面再讲）可是这样子复制的话还是 $O(nm)$。

我们来观察一次复制：

![](https://cdn.luogu.com.cn/upload/image_hosting/qo8feq6g.png)

其实真正修改了的只有 树高 个节点（即 $\log n$ 个节点），但是我们复制了 $n$ 个节点。那这样就好办了，我们每次修改只修改一条链即可。

![](https://cdn.luogu.com.cn/upload/image_hosting/4nsf05d0.png)

但是这样子就不能简单地使用基本的线段树了，于是就有了“可持久化线段树”。

可持久化线段树的原理就是如上讲的，**每次修改只插入一条链。**
## 代码实现
按照刚才的分析，最重要的问题就是无法建二叉树。

似乎在动态开点线段树中，我们也遇到了这个问题，当时我们使用了结构体，来存储左儿子右儿子编号。

```cpp
struct tree{
	int l,r,val;
};
```

既然这样我们就需要开启新结点：

```cpp
int add(int node)
{
  a[++top]=a[node];
  return top;
}
```

`top` 的意思是当前节点编号，`node` 的意思是原来的节点“本来修改的对象”，先复制一遍，再进行复制。

接着考虑建树，首先我们定义一个新数组 `tr[i]`，表示第 $i$ 个版本所对应的树根。初始版本的根就叫做 $tr[0]=1$。为了知道节点的左右儿子，`build` 时返回当前节点编号即可。代码实现如下：

```cpp
int build(int node,int l=1,int r=n)
{
  node=++top; // 其实也是 add(node),但是初始版本不用复制，直接这么写就可以了。
  if(l==r)
  {
    a[node].val=read(); // 本题可以直接输入
    return node;
  }
  int mid=(l+r)/2;
  a[node].l=build(a[node].l,l,mid);
  a[node].r=build(a[node].r,mid+1,r);
  return node;
}
```

`update` 和 `build` 差不多，但是 `update` 不能 `node=++top`，而需要 `node=add(node)`：
```cpp
int update(int w,int val,int node,int l=1,int r=n)
{
  node=add(node);
  if(l==r) a[node].val=val;
  else
  {
    int mid=(l+r)/2;
    if(w<=mid) a[node].l=update(w,val,a[node].l,l,mid);
    else a[node].r=update(w,val,a[node].r,mid+1,r);
  }
  return node;
}
```

`query` 实现就非常简单了，和正常的没有区别：
```cpp
int query(int w,int node,int l=1,int r=n)
{
  if(l==r) return a[node].val;
  else
  {
    int mid=(l+r)/2;
    if(w<=mid) return query(w,a[node].l,l,mid);
    else return query(w,a[node].r,mid+1,r);
  }
}
```

---

建树的话调用这个代码就可以了：
```cpp
tr[0]=build(0); // 也可以写作 tr[0]=1;build(0);
```

修改和查询同理。

那么最后的代码如下：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n;
int read() // 快读
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
struct ZX__tree{
	struct tree{
		int l,r,val;
	};
	tree a[32000006];
	int tr[32000006];
	int top;
	int build(int node,int l=1,int r=n)
	{
		node=++top;
		if(l==r)
		{
			a[node].val=read();
			return node;
		}
		int mid=(l+r)/2;
		a[node].l=build(a[node].l,l,mid);
		a[node].r=build(a[node].r,mid+1,r);
		return node;
	}
	int add(int &node)
	{
		top++;
		a[top]=a[node];
		return top;
	}
	int update(int w,int val,int node,int l=1,int r=n)
	{
		node=add(node);
		if(l==r) a[node].val=val;
		else
		{
			int mid=(l+r)/2;
			if(w<=mid) a[node].l=update(w,val,a[node].l,l,mid);
			else a[node].r=update(w,val,a[node].r,mid+1,r);
		}
		return node;
	}
	int query(int w,int node,int l=1,int r=n)
	{
		if(l==r) return a[node].val;
		else
		{
			int mid=(l+r)/2;
			if(w<=mid) return query(w,a[node].l,l,mid);
			else return query(w,a[node].r,mid+1,r);
		}
	}
}a;
signed main()
{
	int T;
	cin>>n>>T;
	a.tr[0]=a.build(0);
	for(int i=1;i<=T;i++)
	{
		int v=read(),op=read();
		if(op==1)
		{
			int w=read(),val=read();
			a.tr[i]=a.update(w,val,a.tr[v]);
		}
		else
		{
			int w=read();
			cout<<a.query(w,a.tr[v])<<endl;
			a.tr[i]=a.tr[v];
		}
	}
	return 0;
}
```
## 正确性证明
主要是对时空复杂度的证明。

对于时间复杂度：很显然的是 $O(n+m\log n)$。（不知道原因的自己回去学好线段树再来）

对于空间复杂度：因为每次只需要建一条链，空间复杂度也优化到了 $O(n+m\log n)$。

所以时空复杂度均为 $O(n+m\log n)$。
## 为什么要将序列变为线段树
1. 本题虽然用不到节点合并，但并不排除别的题有（比如下一道就有）
2. 虽然用不到节点合并，但是二叉树保证了每次我只需要修改左儿子或者右儿子，所以降低了时间复杂度。
3. ~~不然就不是可持久化线段树的例题了。~~

---

## 作者：b__b (赞：3)

~~也许是我写过最长的题解。~~

在这里介绍两种做法：在线的 $\mathcal{O}(n\log n)$ 做法（正解）与离线的 $\mathcal{O}(n)$ 做法。

（感谢[这篇题解](https://www.luogu.com.cn/article/z2kii3r9)为我提供的离线方案的思路。）

# 在线做法（可持久化线段树）
一种简单，容易想到的暴力做法就是每一次创建一个新版本就复制一个新数组，时间和空间复杂度都是 $\mathcal{O}(mn)$（$m$ 次操作，每次创建一个大小为 $n$ 的数组，从原数组复制要进行 $n$ 次操作）。本题 $n \leq 10^6$，$m \leq 10^6$，这种做法显然不可接受。

我们观察需要创建新版本的场景，可以发现每次最多只会修改一个数，有时甚至不会修改，这些不修改的数字如果每一次都复制的话代价太高了。很容易想到每一次只记录修改的部分。

我们可以使用一种叫做**可持久化线段树**的数据结构。（没学过线段树的请右转学习线段树。）

我们现在先将版本 $0$ 到版本 $2$ 的线段树单独画出来：

![](https://cdn.luogu.com.cn/upload/image_hosting/j8bfgq7u.png)

我们发现版本 $0$ 和版本 $1$ 是重复的，我们可以直接将这些节点合并（将第二颗树的根节点的儿子设成第一颗树的根节点的儿子）：

![](https://cdn.luogu.com.cn/upload/image_hosting/porjr3xe.png)

对于版本 $2$，它只修改了一个数，我们可以想到只记录根节点到修改部分的一条“链”，其余的按照上面的方法操作：

![](https://cdn.luogu.com.cn/upload/image_hosting/q7u3w7zl.png)

总结：先将版本 $0$ 的树完整的记录下来，接着之后的版本只记录修改的部分。

现在我们考虑复杂度：

空间复杂度：版本 $0$ 要记录所有的数，会有 $2n-1$ 个节点。总共有 $m$ 个版本。假设每一个版本都有修改，那么每一次都要记录长为 $\lceil \log_2 n \rceil+1$ 的“链”，空间复杂度约为 $\mathcal{O}(n+m\log_2 n)$。在此题中 $n$ 和 $m$ 最大为 $10^6$，内存限制为 $1$ GB，可以接受。

时间复杂度：建第一棵树复杂度为 $\mathcal{O}(n)$，后面每一次查找复杂度都是 $\mathcal{O}(\log n)$ 的，合起来就是 $\mathcal{O}(n+m \log n)$。

现在我们开始编程。

我们不能像普通的线段树一样通过静态数组存储一个满二叉树，这样空间会直接炸掉。

我们可以写一个结构体，里面记录了这个节点的左儿子与右儿子以及它本身的值。
```cpp
//由空间复杂度的分析可得数组大小
struct {int l, r, num;} tree[N << 5];
```
定义一个变量，表示当前分配的点的数量。
```cpp
int rt;
```
每次新建节点时，只需要将 ```rt``` 加一。

我们定义一个数组，表示版本 $i$ 的根节点位置以及现在有多少个版本：
```cpp
int root[N], nowv;
```
我们先看怎么新建第一棵树（原理见注释）：
```cpp
int build(int pl, int pr) { //返回值就是创建的这棵树的根节点的编号
    int cnt = ++rt, mid = (pl + pr) >> 1;
    if (pl == pr) { //区间只有一个数，直接输入
        scanf("%d", &tree[cnt].num);
        return cnt;
    }
    tree[cnt].l = build(pl, mid), tree[cnt].r = build(mid + 1, pr); //分开创建当前节点的左子树与右子树
    return cnt;
}
```
修改一个数：
```cpp
//返回记录的修改“链”的根节点
int upd(int p, int c, int pl, int pr, int bef) { //bef指要修改的树
    int cnt = ++rt, mid = (pl + pr) >> 1;
    tree[cnt].l = tree[bef].l, tree[cnt].r = tree[bef].r; //将这个节点的左右子树都指向原来的树的左右子树
    if (pl == pr) { //区间内只有一个数，直接修改
        tree[cnt].num = c;
        return cnt;
    }
    if (p <= mid) tree[cnt].l = upd(p, c, pl, mid, tree[bef].l); //p在左子树
    else tree[cnt].r = upd(p, c, mid + 1, pr, tree[bef].r); //p在右子树
    return cnt;
}
```
查找：
```cpp
//返回查找的数
int query(int p, int pl, int pr, int now) { //now就是现在正在查找的树
    if (pl == pr) return tree[now].num; //只有一个数，直接返回
    int mid = (pl + pr) >> 1;
    if (p <= mid) return query(p, pl, mid, tree[now].l); //p在左子树
    return query(p, mid + 1, pr, tree[now].r); //p在右子树
}
```
主函数部分：
```cpp
int main() {
    int n, m;
    for (scanf("%d%d", &n, &m), root[nowv++] = build(1, n); m--;) {
        int v, op, p, c;
        scanf("%d%d%d", &v, &op, &p);
        if (op == 1) scanf("%d", &c), root[nowv++] = upd(p, c, 1, n, root[v]);
        else printf("%d\n", query(p, 1, n, root[nowv++] = root[v]));
    }
}
```
整理：
```cpp
#include <cstdio>
const int N = 1e6 + 5;
int rt, root[N], nowv;
struct {int l, r, num;} tree[N << 5];
int build(int pl, int pr) {
    int cnt = ++rt, mid = (pl + pr) >> 1;
    if (pl == pr) {
        scanf("%d", &tree[cnt].num);
        return cnt;
    }
    tree[cnt].l = build(pl, mid), tree[cnt].r = build(mid + 1, pr);
    return cnt;
}
int upd(int p, int c, int pl, int pr, int bef) {
    int cnt = ++rt, mid = (pl + pr) >> 1;
    tree[cnt].l = tree[bef].l, tree[cnt].r = tree[bef].r;
    if (pl == pr) {
        tree[cnt].num = c;
        return cnt;
    }
    if (p <= mid) tree[cnt].l = upd(p, c, pl, mid, tree[bef].l);
    else tree[cnt].r = upd(p, c, mid + 1, pr, tree[bef].r);
    return cnt;
}
int query(int p, int pl, int pr, int now) {
    if (pl == pr) return tree[now].num;
    int mid = (pl + pr) >> 1;
    if (p <= mid) return query(p, pl, mid, tree[now].l);
    return query(p, mid + 1, pr, tree[now].r);
}
int main() {
    int n, m;
    for (scanf("%d%d", &n, &m), root[nowv++] = build(1, n); m--;) {
        int v, op, p, c;
        scanf("%d%d%d", &v, &op, &p);
        if (op == 1) scanf("%d", &c), root[nowv++] = upd(p, c, 1, n, root[v]);
        else printf("%d\n", query(p, 1, n, root[nowv++] = root[v]));
    }
}
```
于是这题在线正解完结。
# 离线（递归）
我们发现，每两个版本之间最多只会有一次修改，如果将版本画出来会形成一颗多叉树。以样例为例（边上只有一个数字代表查询，两个数字代表修改）：

![](https://cdn.luogu.com.cn/upload/image_hosting/oi9o5h9v.png)

我们可以想到通过递归的方法，每次经过一个边的时候就处理这个边所对应的操作。

写一个结构体用来存储操作：
```cpp
struct op {int op, p, c, ind;}; //op是操作类型，p和c如题面所说，ind表示这个操作输出对应的序号（如果不是查询则为0）
```
每一条边上有且只会有一个操作，考虑邻接表。
```cpp
std::vector<std::pair<int, op>> tree[N]; //每一个pair的第一个int表示指向的版本，第二个op表示这条边上的操作
```
定义一个存储查询的数组及表示有多少条查询的变量：
```cpp
int result[N], resind;
```
定义 $a$ 数组：
```cpp
int a[N];
```
递归：
```cpp
void dg(int p) { //遍历到第p个版本
    for (auto g : tree[p]) { //遍历自己的儿子
        const op &nop = g.second;
        if (nop.op == 1) { //修改操作
            int tmp = a[nop.p]; //存储原来的数
            a[nop.p] = nop.c, dg(g.first); //执行修改操作并处理儿子
            a[nop.p] = tmp; //还原原来的状态
        } else result[nop.ind] = a[nop.p], dg(g.first); //存储答案
    }
}
```
主函数：
```cpp
int main() {
    int n, m, nowv = 0; //n与m如题意，nowv表示当前有多少个版本
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++i) scanf("%d", a + i);
    for (int v, op, p, c; m--;) {
        scanf("%d%d%d", &v, &op, &p);
        if (op == 1) scanf("%d", &c);
        else c = 0, resind++; //增加一条查询
        tree[v].push_back({++nowv, {op, p, c, resind}});
    }
    dg(0);
    for (int i = 1; i <= resind; ++i) printf("%d\n", result[i]); //按照顺序输出查询
}
```
整理：
```cpp
#include <cstdio>
#include <vector>
const int N = 1e6 + 5;
int a[N], result[N], resind;
struct op {int op, p, c, ind;};
std::vector<std::pair<int, op>> tree[N];
void dg(int p) {
    for (auto g : tree[p]) {
        const op &nop = g.second;
        if (nop.op == 1) {
            int tmp = a[nop.p];
            a[nop.p] = nop.c, dg(g.first);
            a[nop.p] = tmp;
        } else result[nop.ind] = a[nop.p], dg(g.first);
    }
}
int main() {
    int n, m, nowv = 0;
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++i) scanf("%d", a + i);
    for (int v, op, p, c; m--;) {
        scanf("%d%d%d", &v, &op, &p);
        if (op == 1) scanf("%d", &c);
        else c = 0, resind++;
        tree[v].push_back({++nowv, {op, p, c, resind}});
    }
    dg(0);
    for (int i = 1; i <= resind; ++i) printf("%d\n", result[i]);
}
```
~~又短又快又好理解，简直像是正解。~~

完结撒花~

---

## 作者：_Weslie_ (赞：2)

## 前言

本文所有代码全部定义在以下基础上：

```
#include<bits/stdc++.h>
using namespace std;
const int N=1000005;
struct node{
	int val,lc,rc;//lc,rc 分别指左右儿子
}tr[N*24];
#define ls tr[now].lc
#define rs tr[now].rc
int cnt=0;
```

## 可持久化数据结构的定义

可持久化数据结构总是可以保留每一个历史版本，并且支持操作的不可变特性。可持久化线段树又称主席树，是可持久化数据结构的一种。

## 可持久化线段树的应用场景

- [P3834 【模板】可持久化线段树 2](https://www.luogu.com.cn/problem/P3834)

这是个非常经典的可持久化权值线段树入门题——静态区间第 $k$ 小。

给定 $n$ 个整数构成的序列 $a$，将对于指定的闭区间 $[l, r]$ 查询其区间内的第 $k$ 小值。$n\le 2\times 10^5$。

最朴素的办法就是每次对 $[l,r]$ 排序，然后查询第 $k$ 大。这样的复杂度是 $\operatorname{O}(qn\log n)$ 的，不 TLE 才怪。

那我们怎么办呢？要运用可持久化线段树和线段树二分的结合，后面讲例题时我们再处理这个。

## 可持久化线段树的建树及插入

### 结构图解

![](https://cdn.luogu.com.cn/upload/image_hosting/apvysb7a.png)


如你所见，这是一颗非常普通的线段树的结构（初始值全为 $0$，区间求和）。

现在我们进行单点赋值。假如对 $1$ 位置赋值为 $3$，那么正常线段树我们直接做就行。

在可持久化线段树上，我们要保留历史版本。

![](https://cdn.luogu.com.cn/upload/image_hosting/scui0fbs.png)

保留上一个版本，我们直接在修改的地方新开一个节点。

那么如果我们要在最新版本的基础上，再对 $2$ 位置赋值为 $5$ 呢？

那么新建出来，主席树就长这样了。

![](https://cdn.luogu.com.cn/upload/image_hosting/qkggvl9n.png)

那假如说，我要在最新的版本的基础上，将 $8$ 位置赋值为 $6$，又应如何应对？

![](https://cdn.luogu.com.cn/upload/image_hosting/5o7xyt8c.png)

可以看出来，新的节点中，这次更改的子树挂到父节点上去，另外一个子树则是由基础版本的该子树顶上去。

由可持久化线段树每次更改都需要开新的节点，所以需要动态开点。

什么？你说，根节点怎么处理？怎么找到第 $i$ 个版本？没事的，直接开一个数组记录即可。

这就是可持久化线段树的建构原理。这样，我们可以写出代码。


### 代码实现

```
void build(int l,int r,int &now){//左端点 l，右端点 r，当前节点编号 now
/*
&now 意思是在本函数中 now 的值发生变化之后，调用函数的参数也跟着发生改变。
可以这么理解：
假如一开始 build(l,r,lson)（其中 lson 即左儿子但是没有赋值）。
那么动态开点，now 假如变为 2，那么传进来的 lson 也变为 2。
*/
	if(!now)now=++cnt;//没有这个点
	if(l==r){//叶子
		tr[now].val=a[l];
		return;
	}
	int mid=(l+r)>>1;
	build(l,mid,ls);
	build(mid+1,r,rs);
  //pushup(now);
  //这题（P3919）用不着 pushup，如果需要的话可以
}
void update(int &now,int lst,int l,int r,int pos,int val){
//当前节点 now，上一个版本对应节点 lst，左端点 l，右端点 r，修改的位置 pos 和修改的值 val
	now=++cnt;
	tr[now]=tr[lst];//拷贝一份
	if(l==r){
		tr[now].val=val;//直接修改
		return;
	}
	int mid=(l+r)>>1;
	if(pos<=mid)update(ls,tr[lst].lc,l,mid,pos,val);
	else update(rs,tr[lst].rc,mid+1,r,pos,val);
//修改左边或右边，另外一边因为从 lst 复制过来，所以与 lst 相同。
  //pushup(now);
	return;
}
```

## 可持久化线段树的查询

### 过程分析

一般是查询某个历史版本上某个点的值。这一部分非常简单了。

仍然是在线段树上递归，递归到指定位置为止，期间选择左儿子还是右儿子。

### 代码实现

参照代码理解。

```
int query(int &now,int lst,int l,int r,int pos){
//变量名同上文 update
	if(!now)now=++cnt;
	tr[now]=tr[lst];
	if(l==r)return tr[now].val;
	int mid=(l+r)>>1;
	if(pos<=mid)return query(ls,tr[lst].lc,l,mid,pos);
	else return query(rs,tr[lst].rc,mid+1,r,pos);//左还是右？根据 pos 选择。
}
```

## 可持久化线段树的时间复杂度分析

这个非常简单，显然是 $\operatorname{O}(n\log n)$ 的（递归 $\log n$ 层）。

## 可持久化线段树要开多少倍空间？

非常好问题。

我们修改一个节点，需要新建 $\log n$ 个节点。假设询问次数 $q$ 与 $n$ 同阶。

那么我们需要 $4n+q\log n$ 的空间，其中 $4n$ 是线段树本身就需要，$q\log n$ 是最多 $q$ 次修改，每次新建 $\log n$ 个节点。$q$ 和 $n$ 同阶，那么就需要 $(4+\log n)n$ 个节点。

假设 $n$ 和 $q$ 都是 $10^5$，那么大约需要 $21n$ 的空间。像这题，如果 $n=10^6$，那么就需要 $24n$ 的空间。亲测 $24n$ 可过。

实际上，做题时没有（或许吧）出题人会卡你的可持久化线段树空间。所以大家一般都开到 $32n$。



## 可持久化线段树的例题

### P3919 模板 1

上面已经分析过了。只需要额外写出主函数和头文件、变量定义部分即可。

贴一个主函数代码。

```
int n,q,rt[N],tot;//rt 即前面说过的记录根的数组
int main(){
	scanf("%d%d",&n,&q);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	build(1,n,rt[0]);
	for(int opt,v,l,r;q;q--){
		scanf("%d%d%d",&v,&opt,&l);
		if(opt==1){
			scanf("%d",&r);
			update(rt[++tot],rt[v],1,n,l,r);
		}
		else{
			printf("%d\n",query(rt[++tot],rt[v],1,n,l));
		} 
	}
}
```

### P3834 模板 2

这就是上面我所说的应用场景。回顾一下：

这是个非常经典的可持久化权值线段树入门题——静态区间第 $k$ 小。

给定 $n$ 个整数构成的序列 $a$，将对于指定的闭区间 $[l, r]$ 查询其区间内的第 $k$ 小值。$n\le 2\times 10^5$。

#### 形态 1：区间起点为 1

不妨考虑 $[1,r]$ 怎么做。我们对原数组排序并离散化，建权值线段树。每次到 $i$，就在位置 $i$ 上加 $1$。

![](https://cdn.luogu.com.cn/upload/image_hosting/exslpgi3.png)

那么先插入 $1$。得到区间 $[1,1]$。

![](https://cdn.luogu.com.cn/upload/image_hosting/63pybdw0.png)

接着插入 $2$。得到 $[1,2]$。

![](https://cdn.luogu.com.cn/upload/image_hosting/sfvaz6e9.png)

如果插入 $3$ 和 $4$ 呢？（区间：$[1,4]$）

![](https://cdn.luogu.com.cn/upload/image_hosting/m1yderb3.png)


那么我们要查询区间第 $k$ 大，直接线段树二分（判断左儿子大小是否大于 $k$ 即可）。

#### 形态 2：区间起点不为 1

那么问题来到 $[l,r]$。

设当前线段树上区间 $[a,b]$。事实上，只需要分别考虑第 $l-1$ 和第 $r$ 版本上，左儿子的大小 $siz$，再判断 $siz_r-siz_{l-1}\ge k$ 是否成立（成立就向左，反之向右）。

原因是我们统计从 $1$ 加到 $r$（或 $l-1$），统计的是一个前缀 $[1,r]$（或 $[1,l-1]$）中值域 $[a,b]$ 的数的个数，相减就是 $[l,r]$ 的。

这样就做完了。

#### 代码实现

```
#include<bits/stdc++.h>
using namespace std;
const int N=200005;
struct node{
	int sum,lc,rc;
}tr[N<<5];
#define ls tr[now].lc
#define rs tr[now].rc
#define lls tr[lst].lc
#define lrs tr[lst].rc
void pushup(int now){
	tr[now].sum=tr[ls].sum+tr[rs].sum;
}
int cnt=0;
void build(int l,int r,int &now){
	now=++cnt;
	if(l==r){
		tr[now].sum=0;
		return;
	}
	int mid=(l+r)>>1;
	build(l,mid,ls);
	build(mid+1,r,rs);
	pushup(now);
}
void update(int &now,int lst,int l,int r,int pos,int val){
	now=++cnt;
	tr[now]=tr[lst];
	tr[now].sum+=val;
	if(l==r){
		return;
	}
	int mid=(l+r)>>1;
	if(pos<=mid)update(ls,tr[lst].lc,l,mid,pos,val);
	else update(rs,tr[lst].rc,mid+1,r,pos,val);
	return;
}
int query(int l,int r,int u,int v,int k){
	int mid=(l+r)>>1,x=(tr[tr[v].lc].sum-tr[tr[u].lc].sum);
	if(l==r)return l;
	if(x>=k)return query(l,mid,tr[u].lc,tr[v].lc,k);
	else return query(mid+1,r,tr[u].rc,tr[v].rc,k-x);
}
int n,q,a[N],b[N],rt[N];
int main(){
	scanf("%d%d",&n,&q);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		b[i]=a[i];
	}
	sort(b+1,b+n+1);
	int len=unique(b+1,b+n+1)-b-1;
	build(1,len,rt[0]);
	for(int i=1;i<=n;i++){
		a[i]=lower_bound(b+1,b+len+1,a[i])-b;
		update(rt[i],rt[i-1],1,len,a[i],1);
	}
	for(int l,r,k;q;q--){
		scanf("%d%d%d",&l,&r,&k);
		printf("%d\n",b[query(1,len,rt[l-1],rt[r],k)]);
	}
}
```

---

## 作者：0626SXD (赞：2)

# 可持久化线段树
## 用途
如果是普通的线段树，修改后就找不到之前的信息了，除非再开一个新的线段树，空间复杂度不可接受。所以有了能以较低空间复杂度存储各个版本的可持久化线段树。
## 思想
单点修改时，我们模拟一下线段树的递归过程，不难发现只会修改包含该单点的那一条链上 $\log n$ 级别的点，其他点不会修改，如果我们重复利用那些点，把改变了的点接上去，空间就可以接受了。
## 实现
对于每个版本，用数组存下它的根，修改或查询从这个根开始就是当前版本树。要用动态开点，否则空间不能接受。如果是修改，则每次都要建一个新的点，与原来的点数据相同，然后再递归子节点更改这个新的点。那么每个点的一个子节点会是原来的子节点，另一个子节点是新建的点，就成功地把这条链接到树上了。如果是查询，除了调用外与普通线段树一样。
## 复杂度分析
每次修改和查询都是一条链，长度是 $O(\log n)$ 级别的，总时间复杂度 $O(n\log n)$。

由于是动态开点，一开始树的大小是 $O(n)$ 级别的，后来的修改每次新加一条链，是 $O(\log n)$ 级别的，所以总空间复杂度是 $O(m\log n)$ 的。
## 正确性证明
每次修改只会改动一条链上的点，把这些点接在原树上共用公共信息，除了空间更优外与多个普通线段树无异，显然正确。


```cpp
#include<bits/stdc++.h>
#define ll long long
#define rd read()
#define md (l+r>>1)
#define for_(a,b,c) for(int a=b;a<=c;++a)
#define For_(a,b,c) for(int a=b;a>=c;--a)
using namespace std;
int n,m;
const int N=1e6+10,LG=32;
int a[N];
int tn,rt[N],t[N*LG],lc[N*LG],rc[N*LG];
inline int nd(int p){
	int id=++tn;
	return t[id]=t[p],lc[id]=lc[p],rc[id]=rc[p],id;
}
inline int build(int p,int l,int r){
	p=++tn;
	if(l==r)return t[p]=a[l],p;
	return lc[p]=build(lc[p],l,md),rc[p]=build(rc[p],md+1,r),p;
}
inline int mdf(int p,int l,int r,int x,int val){
	p=nd(p);
	if(l==r)return t[p]=val,p;
	if(x<=md)return lc[p]=mdf(lc[p],l,md,x,val),p;
	else return rc[p]=mdf(rc[p],md+1,r,x,val),p;
}
inline int qry(int p,int l,int r,int x){
	if(l==r)return t[p];
	if(x<=md)return qry(lc[p],l,md,x);
	else return qry(rc[p],md+1,r,x);
}
inline ll read(){ll d=0,f=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=1;ch=getchar();}while(ch<='9'&&ch>='0'){d=(d<<1)+(d<<3)+ch-'0';ch=getchar();}return f?-d:d;}
int main(){
	n=rd,m=rd;
	for_(i,1,n)a[i]=rd;
	rt[0]=build(0,1,n);
	for_(i,1,m){
		int v=rd,op=rd;
		if(op&1){
			int x=rd,val=rd;
			rt[i]=mdf(rt[v],1,n,x,val);
		}
		else{
			int x=rd;
			printf("%d\n",qry(rt[v],1,n,x));
			rt[i]=rt[v];
		}
	}
	return 0;
}
```

---

## 作者：arfa (赞：2)


 划分树是一种来解决区间第 $K$ 大的一种数据结构,其常数,理解难度都要比主席树低很多。同时,划分树紧贴"第 $K$ 大"，所以是一种基于排序的一种数据结构。**建议先学完主席树再看划分树哦**。

 ### 建树

 划分树的建树比较简单,但是相对于其他树来说比较复杂。
 ![](https://s1.ax1x.com/2018/08/31/Pvaer6.png)

 如图,每一层都有一个看似无序的数组。其实,每一个被红色标记的数字都是**要分配到左儿子的**。而分配的规则是什么?就是与**这一层的中位数**做比较, $\leq$ 左边,否则右边。但是这里要注意一下:并不是严格的 $\leq$ **左边,否则右边**。因为中位数可能有相同,而且与 $N$ 的奇偶有一定关系。下面的代码展示会有一个巧妙的运用,大家可以参照代码。

 我们不肯能每一次都对每一层排序,这样子不说常数,就算是理论复杂度也过不去。我们想,找中位数,一次排序就够了。为什么? 比如,我们求 $l,r$ 的中位数,其实就是在排完序过后的 $num[mid]$。


 两个关键数组:
 ```
 tree[log(N),N]   : 也就是树,要存下所有的值,空间复杂度 O(N log N)。
 toleft[log(N),n] : 也就是每一层 1~i 进入左儿子的数量,这里需要理解一下,这是一个前缀和。还有,这个东西不分是在哪一个节点,但是分那一层(没有关系)。 
 ```

 ```pascal
 procedure Build(left,right,deep:longint); // left,right 是左右区间,deep是第几层
 var
 	i,mid,same,ls,rs,flag:longint; // 其中 flag 是用来平衡左右两边的数量的
 begin
 	if left=right then exit; // 到底层了
 	mid:=(left+right) >> 1;
 	same:=mid-left+1;
 	for i:=left to right do 
 		if tree[deep,i]<num[mid] then
 			dec(same);

 	ls:=left; // 分配到左儿子的第一个指针
 	rs:=mid+1; // 分配到右儿子的第一个指针
 	for i:=left to right do
 	begin
 		flag:=0;
 		if (tree[deep,i]<num[mid])or((tree[deep,i]=num[mid])and(same>0)) then // 分配到左边的条件
 		begin
 			flag:=1; tree[deep+1,ls]:=tree[deep,i]; inc(ls);
 			if tree[deep,i]=num[mid] then // 平衡左右个数
 				dec(same);
 		end
 		else
 		begin
 			tree[deep+1,rs]:=tree[deep,i]; inc(rs);
 		end;
 		toleft[deep,i]:=toleft[deep,i-1]+flag;
 	end;
 	Build(left,mid,deep+1); // 继续
 	Build(mid+1,right,deep+1);
 end;
 ```

 ### 查询

 那我们先扯一下主席树的内容。在用主席树求区间第 $K$ 小的时候,我们以 $K$ 为基准,向左就向左,向右要减去向左的值,在划分树中也是这样子的。

 查询难理解的,在于**区间缩小**这种东西。下图,我查询的是 $3$ 到 $7$,那么下一层我就只需要查询 $2$ 到 $3$ 了。当然,我们定义 $left,right$ 为缩小后的区间(目标区间), $l,r$ 还是我所在节点的区间。那为什么要标出目标区间呢? 因为那是**判定答案在左边,右边的基准**。

 ![](https://s1.ax1x.com/2018/08/31/Pvduyq.png)


 ```pascal
 function Query(left,right,k,l,r,deep:longint):longint;
 var
 	mid,x,y,cnt,rx,ry:longint;
 begin
 	if left=right then // 写成 l=r 也无妨,因为目标区间也一定有答案
 		exit(tree[deep,left]);
 	mid:=(l+r) >> 1;
 	x:=toleft[deep,left-1]-toleft[deep,l-1]; // l 到 left 的去左儿子的个数
 	y:=toleft[deep,right]-toleft[deep,l-1]; // l 到 right 的去左儿子的个数
 	ry:=right-l-y; rx:=left-l-x; // ry 是 l 到 right 去右儿子的个数,rx 则是 l 到 lefr 去右儿子的个数
 	cnt:=y-x; // left 到 right 左儿子的个数
 	if cnt>=k then // 主席树常识啦
 		Query:=Query(l+x,l+y-1,k,l,mid,deep+1) // l+x 就是缩小左边界,l+y-1 就是缩小右区间。对于上图来说,就是把 1 和 2 放弃了。
 	else
 		Query:=Query(mid+rx+1,mid+ry+1,k-cnt,mid+1,r,deep+1); // 同样是缩小区间,只不过变成了右边而已。注意要 k-cnt。
 end;
 ```

 ### 理论复杂度和亲测结果

 时间复杂度 : 一次查询只需要 $O(\log\ n)$,$m$次询问,就是 $O(m\ \log\ n)$。

空间复杂度 : 只需要存储 $O(n\ \log\ n)$ 个数字。

 亲测结果:  主席树 : $1482ms$、划分树 : $889ms$。 (非递归,常数比较小)



 ### 后记

 大家可以试着去写非递归版哦。参考博文 : [传送门](https://blog.csdn.net/littlewhite520/article/details/70250722)。

---

## 作者：TH911 (赞：1)

> [例题链接](https://www.luogu.com.cn/problem/P3919)

# 可持久化线段树/主席树

## 可持久化线段树与主席树

“主席树”其实只是一个称呼，“主席树”的提出者也没有进行一个严谨的定义，一般主席树就是指可持久化线段树。（但是本人更喜欢叫“可持久化线段树”，因为不同的人对其界定不同，不够严谨）

## 算法简介

可持久化线段树，可以维护多个历史版本下的线段树，支持单点修改，因此可以用来实现**可持久化数组**。

但是如果给每一个版本都开一个线段树，若有 $n$ 个节点，$m$ 个版本，空间复杂度就是 $\mathcal O(nm)$ 的，不能接受。

因此就有了可持久化线段树，通过一些手段避免了如此之高的空间复杂度，而能使空间复杂度变为 $\mathcal O\left(n+m\log n\right)$。

## 基本原理

假如我们已经有了一棵线段树：

![](https://cdn.luogu.com.cn/upload/image_hosting/4d1ilyr0.png)

那么，以对最左侧的节点修改为例，修改成如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/puxxudn9.png)

修改之后的树（红色部分）中显然并不是所有节点都修改了，图中绿色框出的部分**没有任何修改**。

事实上，修改一个叶节点会且仅会修改其**祖先节点**，因为有且仅有其祖先节点维护的信息包含了叶节点的信息。

那么修改时，需要复制的节点就是树的高度，即 $\left\lceil\log n\right\rceil+1$。

对于不需要复制的节点，可以直接连边。上图中的树可以简化为：

![](https://cdn.luogu.com.cn/upload/image_hosting/8z32u6vl.png)

这样，我们访问某一个版本时，**从对应版本的根节点开始查询**即可，单个节点无需存储其版本号，因为每一个根节点都可以视作对应一棵独立的线段树。

## 与普通线段树的区别

可持久化线段树**必须动态开点**，否则不能实现“连边”。

## 代码实现

以[例题](https://www.luogu.com.cn/problem/P3919)要求实现可持久化数组为例。

### 单个节点

那么就是对于每一个叶节点，维护其对应的数组中的值。

```cpp
struct node{
    int value;
    int l,r,lChild,rChild;
}t[4*N+M*(int)(ceil(log2(N))+1)+1];
```

其实节点数组的大小**可以开大一些**，保证不 MLE 即可。但是个人喜欢~~卡空间~~提前算好，**不要学我**。（`4*N+M*(ceil(log2(N))+1)` 即 $4n+m\left(\left\lceil\log n\right\rceil+1\right)$，初次建好 $\mathcal O(4n)$ 的线段树后，$m$ 次操作每次至多新增 $\mathcal O(\log n+1)$ 个节点。）

其中，$l,r$ 表示其维护的是区间 $[l,r]$ 的信息，$\textit{value}$ 是叶节点的值，$\textit{lChild},\textit{rChild}$ 分别是左子节点、右子节点。

线段树的两种写法，如果采用动态计算区间边界的写法，则无需 $l,r$。

### 根存储

使用数组存储即可。

```cpp
int root[M+1];
```

`root[i]` 表示版本 $i$ 的根节点，至多 $m$ 个版本。

### 新建节点

新建节点（返回节点编号）：

```cpp
int create(node x){
    t[++size]=x;
    return size;
}
```

这种写法相较于直接将节点信息作为参数传入函数，有一个好处：可以在传参时使用列表，更为方便。

例如：

```cpp
create({12,0,0});
```

除此之外，因为涉及到复制节点的操作，也可以封装一个函数：

```cpp
int clone(int p){
    t[++size]=t[p];
    return size;
}
```

### 初始建树

和动态开点线段树基本一样。

建树函数：

```cpp
int build(int l,int r){
    node x;
    x.l=l,x.r=r;
    if(l==r){
        //这一块视需求而定,在本题中如此。
        x.value=a[l];
        return create(x);
    }
    int mid=l+r>>1;
    x.lChild=build(l,mid);
    x.rChild=build(mid+1,r);
    return create(x);
}
```

`build` 函数返回的是建出来的树的根节点，调用时需要存储 `root[0]`。

即：

```cpp
t.root[0]=t.build(1,n);
```

### 单点更新

其实没有必要找到对应的叶节点后再去一个一个复制其祖先节点——这样不光常数更大，而且不好实现（需要实现找父节点）。

只需要从根节点一路复制节点，复制到叶节点即可。

将 $a_x$ 更改为 $k$，返回修改后的（子）树根，代码如下：

```cpp
//a[x]=k
int update(int p,int x,int k){
    p=clone(p);//复制祖先节点
    if(t[p].l==t[p].r){
        t[p].value=k;
        return p;
    }
    //更新&连边
    if(x<=t[t[p].lChild].r){
        t[p].lChild=update(t[p].lChild,x,k);
    }else{
        t[p].rChild=update(t[p].rChild,x,k);
    }
    return p;
}
```

为了实现将新建版本 $i$，将版本 $v$ 中的 $a_p$ 修改为 $c$，可以封装函数：

```cpp
void update(int v,int i,int x,int k){
    root[i]=update(root[v],x,k);
}
```

### 单点查询

单点查询更简单，直接找即可：

```cpp
int query(int p,int x){
    if(t[p].l==t[p].r){
        return t[p].value;
    }
    if(x<=t[t[p].lChild].r){
        return query(t[p].lChild,x);
    }else{
        return query(t[p].rChild,x);
    }
}
```

同时，加上查询版本 $v$（这是新建版本 $i$，一般查询操作视为新建一个一样的版本）：

```cpp
//查询版本 v 的 a[p] 
int query(int v,int i,int x){
    root[i]=root[v];
    return query(root[i],x);
}
```

## 例题 AC 代码

```cpp
//#include<bits/stdc++.h>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
constexpr const int N=1e6,M=1e6;
int a[N+1];
//个人喜欢封装，也建议封装，除非是需要卡常
struct segTree{
	int root[M+1],size;
	struct node{
		int value;
		int l,r,lChild,rChild;
	}t[4*N+M*(int)(ceil(log2(N))+1)+1];
	
	int create(node x){
		t[++size]=x;
		return size;
	}
	int clone(int p){
		t[++size]=t[p];
		return size;
	}
	int build(int l,int r){
		node x;
		x.l=l,x.r=r;
		if(l==r){
			x.value=a[l];
			return create(x);
		}
		int mid=l+r>>1;
		x.lChild=build(l,mid);
		x.rChild=build(mid+1,r);
		return create(x);
	}
	//a[x]=k
	int update(int p,int x,int k){
		p=clone(p);
		if(t[p].l==t[p].r){
			t[p].value=k;
			return p;
		}
		if(x<=t[t[p].lChild].r){
			t[p].lChild=update(t[p].lChild,x,k);
		}else{
			t[p].rChild=update(t[p].rChild,x,k);
		}
		return p;
	}
	void update(int v,int i,int x,int k){
		root[i]=update(root[v],x,k);
	}
	int query(int p,int x){
		if(t[p].l==t[p].r){
			return t[p].value;
		}
		if(x<=t[t[p].lChild].r){
			return query(t[p].lChild,x);
		}else{
			return query(t[p].rChild,x);
		}
	}
	//版本 v 的 a[p] 
	int query(int v,int i,int x){
		root[i]=root[v];
		return query(root[i],x);
	}
}t;
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	t.root[0]=t.build(1,n);
	for(int i=1;i<=m;i++){
		int v,op,p,c;
		cin>>v>>op>>p;
		switch(op){
			case 1:
				cin>>c;
				t.update(v,i,p,c);
				break;
			case 2:
				cout<<t.query(v,i,p)<<'\n';
				break;
		} 
	}
	
	cout.flush();
	 
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
/*
5 1
59 46 14 87 41
0 2 1

59
*/
```

## 总结

其实，可持久化线段树的核心就是：**复制根节点至修改节点路径上的所有节点，充分利用未修改的旧版本信息**。

只要弄清楚这一点，那么可持久化线段树便很好理解了。

***



***

实际上还可以拓展到区间操作，也是类似地复制路径上节点，复杂度同为 $\mathcal O\left(\log n\right)$。因为访问到的节点都是普通线段树区间操作需要访问的节点，复制是 $\mathcal O(1)$ 的。

---

## 作者：_Deer_Peach_ (赞：1)

题意已经够简洁了不再赘述。

众所~不~周知，可持久化线段树就是主席树，是一种支持访问或修改一个序列某一历史版本的数据结构。

首先，让我们看一张图来认识主席树。
![pVMPqgK.png](https://s21.ax1x.com/2025/07/06/pVMPqgK.png)
这张比较抽象的主席树的图来可以比较形象的反映出主席树的性质：
1. 主席树有很多根，且每个根都可以构成一棵完整的线段树；
2. 每个节点不止一个父节点；
3. 每次修改会增加树的高度个节点；
4. 增加的非叶子结点连接一个修改后的子节点和一个被修改版本的对应的未被修改的节点（这句话有点抽象慢慢理解）。

知道了主席树的性质，那么就知道了主席树的实现原理。首先我们不能用常规的方式存储线段树，要用动态开点。

需要以下几个变量：
```cpp
const int N=1e6+5;
const int MAXN=4e7+5;
int a[N];//原序列
int val[MAXN],ls[MAXN],rs[MAXN],cnt;//分别表示：值，左儿子，右儿子，节点编号
int Rt[N],vcnt;//Rt[i]表示i版本下线段树的根，vcnt表示最新版本的编号
```

然后先把最初版本存储下来，也就是建树，时间复杂度 $\mathcal O(n)$。
```cpp
inline void build(int &x,int l,int r){
	x=++cnt;
	if(l==r){
		val[x]=a[l];
		return;
	}
	int mid=l+r>>1;
	build(ls[x],l,mid);
	build(rs[x],mid+1,r);
	return;
}
```

然后更新版本，修改节点数量为树的高度，即 $\log n$ 个节点，时间复杂度 $\mathcal O(\log n)$。
```cpp
inline void update(int &x,int lx,int nowl,int nowr,int pos,int k){
//x为修改后版本的对应节点编号，lx为被修改版本的对应节点编号，nowl，nowr为当前节点维护的左右端点，pos为修改的编号，k为修改的值
	x=++cnt;
	val[x]=val[lx];//复制节点
	ls[x]=ls[lx];
	rs[x]=rs[lx];
	if(nowl==nowr){
		val[x]=k;//更新
		return;
	}
	int mid=nowl+nowr>>1;
	if(pos<=mid)update(ls[x],ls[lx],nowl,mid,pos,k);
	if(mid<pos)update(rs[x],rs[lx],mid+1,nowr,pos,k);
	return; 
}
```

查询答案，时间复杂度 $\mathcal O(\log n)$。
```cpp
inline int query(int &x,int lx,int nowl,int nowr,int pos){//变量名含义同update
	if(!x)x=++cnt;
	val[x]=val[lx];//在本题中，两种操作都会产生一个新版本，所以要同update操作
	ls[x]=ls[lx];
	rs[x]=rs[lx];
	if(nowl==nowr)return val[x];
	int mid=nowl+nowr>>1;
	if(pos<=mid)return query(ls[x],ls[lx],nowl,mid,pos);
	if(mid<pos)return query(rs[x],rs[lx],mid+1,nowr,pos);
}
```
其实跟普通线段树的修改查询区别不大，最大不同就是修改查询要改变根，复制节点（改版本），其他基本相同。

大多数题目中空间限制都较为宽松，因此一般不用担心空间超限的问题，所以大胆开大空间。

完整代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)
#define endl '\n'
const int N=1e6+5;
const int MAXN=4e7+5;
int n,m;
int a[N];
int val[MAXN],ls[MAXN],rs[MAXN],cnt;
int Rt[N],vcnt;
inline void build(int &x,int l,int r){
	x=++cnt;
	if(l==r){
		val[x]=a[l];
		return;
	}
	int mid=l+r>>1;
	build(ls[x],l,mid);
	build(rs[x],mid+1,r);
	return;
}
inline void update(int &x,int lx,int nowl,int nowr,int pos,int k){
	x=++cnt;
	val[x]=val[lx];
	ls[x]=ls[lx];
	rs[x]=rs[lx];
	if(nowl==nowr){
		val[x]=k;
		return;
	}
	int mid=nowl+nowr>>1;
	if(pos<=mid)update(ls[x],ls[lx],nowl,mid,pos,k);
	if(mid<pos)update(rs[x],rs[lx],mid+1,nowr,pos,k);
	return; 
}
inline int query(int &x,int lx,int nowl,int nowr,int pos){
	if(!x)x=++cnt;
	val[x]=val[lx];
	ls[x]=ls[lx];
	rs[x]=rs[lx];
	if(nowl==nowr)return val[x];
	int mid=nowl+nowr>>1;
	if(pos<=mid)return query(ls[x],ls[lx],nowl,mid,pos);
	if(mid<pos)return query(rs[x],rs[lx],mid+1,nowr,pos);
}
signed main(){
	IOS;
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i];
	build(Rt[0],1,n);
	while(m--){
		int v,opt;
		cin>>v>>opt;
		if(opt==1){
			int p,c;
			cin>>p>>c;
			update(Rt[++vcnt],Rt[v],1,n,p,c);
		}
		else{
			int p;
			cin>>p;
			cout<<query(Rt[++vcnt],Rt[v],1,n,p)<<endl;
		}
	}
	return 0;
}
```
[记录](https://www.luogu.com.cn/record/222665316)。

---

## 作者：Ybll_ (赞：1)

# 题意：

写一个支持单点修改和单点查询一个序列某个历史版本的数据结构。

# 算法介绍：

什么是可持久化？可持久化指支持访问或修改数据结构的某一历史版本。

什么是线段树？不会请出门左转把[线段树](https://www.luogu.com.cn/problem/P3372)学了。

可持久化线段树，又称主席树，是一个支持访问或修改一个序列某一历史版本的数据结构。

暴力做法就是每次操作就把当前版本复制一遍，肯定过不了，

都说是线段树了，我们可以先把这个序列放到一个线段树上，考虑到线段树的性质，每一次单点修改会改变 $\log_2n$ 个点，同时为了记录这些历史版本，我们不能直接在线段树上进行修改，那怎么办呢，我们可以新建 $\log_2n$ 个点去存这些点改变后的值，

举个例子：

有一个长度为 $6$ 的序列，将它转换为线段树后修改第 $2$ 个点，这棵主席树就会长成下面这样，红色点就是需要新建的点。

![](https://pic1.imgdb.cn/item/684a9a9c58cb8da5c84808be.png)

~~图有点丑，别喷。~~

然后可以发现主席树的一些性质：

1. 每个孩子可以有多个父亲，但每个父亲最多有两个孩子；
2. 主席树有多个根，每个根对应一个历史版本。

所以我们不能用普通线段树的方式记录两个孩子，即左右儿子的编号不能为 $id\times2$ 和 $id\times2+1$，这个时候就要拿出动态开点这个东西了，同时线段树里每一个节点都要多记两个值，分别是左儿子的编号和右儿子的编号，

同时我们还要开一个数组记录每一个版本的根。

# 代码：

### 建树：

记得用动态开点，最开始建出的树对应版本 $0$。

```cpp
il void build(int &id,int l,int r)
{
	id=++cnt;//动态开点
	tree[id].l=l;
	tree[id].r=r;
	if(l==r)
	{
		tree[id].sum=read();
		return;
	}
	int mid=l+r>>1;
	build(tree[id].ls,l,mid);
	build(tree[id].rs,mid+1,r);
}
```

### 2. 新建节点：

直接将原来点的数据复制过去即可。

```cpp
il void new_node(int &x)
{
	tree[++cnt]=tree[x];
	x=cnt;
}
```
### 单点修改：

先将要修改的版本复制到当前版本在进行修改，其实就是把要修改的版本的根复制到当前版本的根，

还有被修改过的点需要全部重建，

就是在普通线段树的单点修改上加了一个新建节点。

```cpp
il void update(int &id,int p,int x)
{
	if(tree[id].l>p||tree[id].r<p)return;
	new_node(id);
	if(tree[id].l==tree[id].r)
	{
		tree[id].sum=x;
		return;
	}
	update(tree[id].ls,p,x);
	update(tree[id].rs,p,x);
}
```
### 单点查询：

几乎和普通线段树的单点查询一模一样，

注意此题查询操作也会产生新的版本。

```cpp
il int query(int id,int x)
{
	if(tree[id].l>x||tree[id].r<x)return 0;
	if(tree[id].l==tree[id].r)return tree[id].sum;
	return query(tree[id].ls,x)+query(tree[id].rs,x);
}
```

### 代码完全体：
```cpp
#include<bits/stdc++.h>
#define il inline
#define re register
using namespace std;
il int read()
{
	re int x=0,f=1;
	char c;
	while(!isdigit(c=getchar()))
	{
		if(c=='-')f=-1;
	}
	while(isdigit(c))
	{
		x=(x<<1)+(x<<3)+(c^48);
		c=getchar();
	}
	return x*f;
}
il void writing(re int x)
{
	if(x<0)
	{
		putchar('-');
		x=-x;
	}
	if(x>9)writing(x/10);
	putchar(x%10+48);
}
il void write(re int x)
{
	writing(x);
	puts(""); 
}
const int N=1000005;
struct node
{
	int ls,rs,sum,l,r;
}tree[N*30];
int cnt,root[N];
il void new_node(int &x)
{
	tree[++cnt]=tree[x];
	x=cnt;
}
il void build(int &id,int l,int r)
{
	id=++cnt;
	tree[id].l=l;
	tree[id].r=r;
	if(l==r)
	{
		tree[id].sum=read();
		return;
	}
	int mid=l+r>>1;
	build(tree[id].ls,l,mid);
	build(tree[id].rs,mid+1,r);
}
il void update(int &id,int p,int x)
{
	if(tree[id].l>p||tree[id].r<p)return;
	new_node(id);
	if(tree[id].l==tree[id].r)
	{
		tree[id].sum=x;
		return;
	}
	update(tree[id].ls,p,x);
	update(tree[id].rs,p,x);
}
il int query(int id,int x)
{
	if(tree[id].l>x||tree[id].r<x)return 0;
	if(tree[id].l==tree[id].r)return tree[id].sum;
	return query(tree[id].ls,x)+query(tree[id].rs,x);
}
signed main()
{
	int n=read(),Q=read();
	build(root[0],1,n);
	for(int i=1;i<=Q;i++)
	{
		int rt=read(),op=read(),x=read(),y;
		if(op==1)
		{
			y=read();
			root[i]=root[rt];
			update(root[i],x,y);
		}
		else
		{
			write(query(root[rt],x));
			root[i]=root[rt];
		}
	}
	return 0;
}
```

# 正确性证明：

### 时间复杂度：

1. 单点修改：每次修改一共要往下搜 $\log_2n$ 层，共要新建 $\log_2n$ 个点，新建节点 $O(1)$ ，单次时间复杂度为 $O(\log n)$；
2. 单点查询：一共要往下搜 $\log_2n$ 层，单次时间复杂度为 $O(\log n)$。
3. 建树：$O(n)$。

总共有 $m$ 次操作，一次建树，总时间复杂度为 $O(n+m\log n)$。

### 空间复杂度：
1. 建树：$O(n)$；
2. 单点修改：每次修改时要新建 $\log_2n$ 个点，单次空间复杂度为  $O(\log n)$。

总共有 $m$ 次操作，一次建树，总空间复杂度为 $O(n+m\log n)$。

---


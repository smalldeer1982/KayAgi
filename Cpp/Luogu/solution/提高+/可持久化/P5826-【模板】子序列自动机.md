# 【模板】子序列自动机

## 题目背景

本题中，若 $x$ 是 $y$ 的子序列，则等价于存在一个**单调递增**序列 $z$，满足 $|z| = |x|$，$z_{|x|} \leq |y|$，且 $\forall i \in [1, ~|x|],~y_{z_i} = x_i$。其中 $|x|,~|y|,~|z|$ 分别代表序列 $x,~y,~z$ 的长度，$x_i,~y_i,~z_i$ 分别代表序列 $x,~y,~z$ 的第 $i$ 项。

这是一道在 ``yLOI2020`` 备选题里被毙掉的题目。

## 题目描述

给定一个长度为 $n$ 的正整数序列 $a$ ，有 $q$ 次询问，第 $i$ 次询问给定一个长度为 $L_i$ 的序列 $b_i$，请你判断 $b_i$ 是不是 $a$ 的子序列。序列 $a$ 和所有 $b_i$ 中的元素都不大于一个给定的正整数 $m$。

## 说明/提示

#### 样例 1 解释

- 对于第一次询问，原序列中没有 $5$，所以给定序列显然不是原序列的子序列。
- 对于第二次询问，存在两个合法的序列 $z$，分别是 $\{2,~3\}$ 和 $\{2,~4\}$。即 $a_{2} = b_{2, 1},~a_3 = b_{2, 2}$ 或 $a_2 = b_{2, 1},~a_{4} = b_{2, 2}$。这里 $b_{i, j}$ 代表序列 $b_i$ 的第 $j$ 个元素，序列 $z$ 的含义见【题目背景】，下同。
- 对于第三次询问，不存在合法的序列 $z$。
- 对于第四次询问，存在两个合法的序列 $z$，分别是 $\{1,~3,~5\}$ 和 $\{1,~4,~5\}$。
- 对于第五次询问，存在一个合法的序列 $z$，为 $\{1,~2,~3,~4,~5\}$。

#### 数据范围与约定

**本题采用多测试点捆绑测试，共有 3 个子任务**。

- Subtask 1（20 points）：$type = 1$，$n, q, m \leq 100$，$\sum_{i = 1}^{q} l_i \leq 10^3$。
- Subtask 2（35 points）：$type = 2$，$n,q \leq 10^5$，$m \leq 26$，$\sum_{i = 1}^{q} l_i \leq 10^6$。
- Subtask 3（45 points）：$type = 3$，$n,q,m \leq 10^5$，$\sum_{i = 1}^q L_i \leq 10^6$。

对于全部的测试点，保证 $1 \leq n, m, q \leq 10^5$，$1 \leq a_i, b_{i, j} \leq m$，$1 \leq l_i \leq 10^6$，$\sum_{i = 1}^{q} l_i \leq 10^6$。


### 提示

- 请注意常数因子对程序效率造成的影响。
- 本题输入规模较大，请注意数据读入对程序效率造成的影响。
- 请注意输入第一行的顺序为先输入询问次数 $q$，再输入序列元素最大值 $m$。

## 样例 #1

### 输入

```
0 5 5 5
1 3 2 2 4
3 1 5 2
2 3 2
3 1 2 3
3 1 2 4
5 1 3 2 2 4
```

### 输出

```
No
Yes
No
Yes
Yes```

# 题解

## 作者：y2823774827y (赞：42)

 [更好的阅读体验](https://www.cnblogs.com/y2823774827y/p/10619179.html)

## 序列自动机
-  **构造**

$a$是字符集，$|s|=n$，$nxt[i][j]$表示$i$以后的第一个字符$j$的位置，$0$为根节点，整个图是一个$DAG$
```cpp
for(LL i=n;i>=1;--i){
    for(LL j=1;j<=a;++j) nxt[i-1][j]=nxt[i][j];
    nxt[i-1][s[i]]=i;
}
```
- **扩展构建**

当字符集较大时，可套用可持久化，在叶子节点放一个$id$，表示出边。

相关例题：
字符串$K$小子序列，可持久化序列自动机，维护节点大小。

一步一步(从首到尾)走，有序确定[code](https://www.luogu.org/paste/t9xrb852)

## 经典例题
- **判断是否是原字符串的子序列**

构造出了$nxt$后，从根跑一遍就好了。

- **求子序列个数**

从根跑，记忆化搜索，$f[x]$为点$x$为首的子序列个数，$f[y]=(\sum\limits_{x\in y'son}f[x])+1$

- **求两串的公共子序列个数**

两串都构造一下，之间跑就好了。

```cpp
LL Dfs(LL x,LL y){
    if(f[x][y]) return f[x][y];
    for(LL i=1;i<=a;++i)
        if(nxt1[x][i]&&nxt2[y][i])
            f[x][y]+=Dfs(nxt1[x][i],nxt2[y][i]);
    return ++f[x][y];
}
```

- **求字符串的回文子序列个数**

原串与反串都建一遍
$$\begin{aligned}\longrightarrow
1~~2~~3~~4~~5~~6~~7~~8~~9~~10&\\
10~~9~~8~~7~~6~~5~~4~~3~~2~~1&\longleftarrow\\
\end{aligned}$$

就相当于从左右端点这样跑。

求的时候显然$x+y≤n+1$这个序列才是合法的。

$x+y=n+1$时就是会合了一样，在之后的遍历过程会$++f[x][y]$，所以暂时不统计。

但是其他情况我们都是匹配的两个字符，也就是只会统计$abba$，而统计不了$aba$，所以在过程中$++f[x][y]$
```cpp
LL Dfs(LL x,LL y){
	if(f[x][y]) return f[x][y];
	for(LL i=1;i<=a;++i)
		if(nxt1[x][i]&&nxt2[y][i]){
			if(nxt1[x][i]+nxt2[y][i]>n+1) continue;
			if(nxt1[x][i]+nxt2[y][i]<n+1) f[x][y]++;
			f[x][y]=(f[x][y]+Dfs(nxt1[x][i],nxt2[y][i]))%mod;
		}
	return ++f[x][y];
}
```

- **求一个$A,B$的最长公共子序列$S$，使得$C$是$S$的子序列**

还是同样的$Dfs(x,y,z)$，表示一匹配到$C$的$z$位。

改变一下$C$的构建方法
```cpp
for(LL i=1;i<=a;++i) nxt[n][i]=n;
for(LL i=0;i<n;++i){
	for(LL j=1;j<=a;++j) nxt[i][j]=i;
	nxt[i][c[i+1]]=i+1;
}
```

---

## 作者：AThousandSuns (赞：31)

普及组选手来写一发不用可持久化线段树的题解……

我当时做这题的时候并不知道序列自动机这玩意，然而发现已经用过很多次了……

---
$nxt_{i,j}$ 表示 $i$ 后面（不包括自己）第一个 $j$ 的位置。如果没有，设成 $n+1$。

$O(nm)$ 的求法看这里：

```cpp
FOR(j,1,m) nxt[n+1][j]=n+1;
FOR(i,1,n){
	FOR(j,1,m) nxt[i][j]=nxt[i+1][j];
	if(i!=n) nxt[i][a[i+1]]=i+1;
}
```

用在判断子序列上的话，发现就是从 $0$ 开始跳，每次跳到它后面第一个 $a_i$ 的位置。看看最后是否不在 $n+1$。

这么贪心是因为对于所有相同的数，我们只关心能跳到的数中最前面的那个。肯定不会更劣。

但是这题中，如果开这么个两维数组，复杂度是 $O(nm)$ 的，爆了。

标算使用的可持久化线段树，因为观察到 $nxt_i$ 和 $nxt_{i+1}$ 这两个数组只有一个位置不一样。时间复杂度是 $O((n+\sum l)\log m)$，空间复杂度是 $O(m+n\log m)$。

我的普及组做法就不太一样了：我们不需要真的把数组存下来。

$i$ 后面第一个 $j$ 的位置，只需要在所有是 $j$ 的下标中二分就行了！

开 $m$ 个 vector 存下这些下标，每次二分，时间复杂度是 $O(n+(\sum l)\log m)$，空间复杂度是 $O(n+m)$。

极其好写。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=100010;
#define FOR(i,a,b) for(int i=(a);i<=(b);i++)
#define ROF(i,a,b) for(int i=(a);i>=(b);i--)
#define MEM(x,v) memset(x,v,sizeof(x))
inline int read(){
	char ch=getchar();int x=0,f=0;
	while(ch<'0' || ch>'9') f|=ch=='-',ch=getchar();
	while(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();
	return f?-x:x;
}
int n,q;
vector<int> v[maxn];
int main(){
	read();n=read();q=read();read();
	FOR(i,1,n) v[read()].push_back(i);
	while(q--){
		int l=read(),at=0;
		bool flag=true;
		while(l--){
			int x=read();
			if(!flag) continue;
			vector<int>::iterator it=lower_bound(v[x].begin(),v[x].end(),at+1);
			if(it==v[x].end()) flag=false;
			else at=*it;
		}
		puts(flag?"Yes":"No");
	}
}
```

---

## 作者：一扶苏一 (赞：17)

# 【可持久化线段树】【P5826】【模板】子序列自动机

## Description

给定一个序列 $A$，有 $q$ 次询问，每次询问一个序列 $B$ 是不是 $A$ 的子序列

## Limitations

序列 $A$ 长度不超过 $10^5$，询问序列长度之和不超过 $10^6$，询问次数不超过 $10^5$

## Solution

题外话：有关这道题的难度，我觉得大概到不了紫色，但是可持久化线段树的板子是紫色的，所以就设成了紫色

update：被神仙用 ``std::vector`` + 二分给碾过去了，那就改成绿色趴……~~不过为什么改难度之前提交记录清一色可持久化线段树，改了之后清一色二分啊，泥萌是在看难度想做法嘛~~

### Algorithm $1$

考虑对于一个询问序列 $B$，设其与 $A$ 的最长公共子序列在 $A$ 中的**下标**序列为 $Z$，显然当且仅当 $Z$ 的长度为 $|B|$ 时，$B$ 是 $A$ 的子序列。合法的序列 $Z$ 可能会有多个，但是只要我们找到了字典序最小的长度为 $|B|$ 的序列 $Z$，就可以说明 $B$ 是 $A$ 的子序列，否则不是。

考虑寻找字典序最小的 $Z$ 可以贪心的选择，即对于 $B$ 的每个前缀，可以求出其对应的 $Z$ 序列的最后一位最小是多少，当 $B$ 的前缀新增一个数字时，只需要在 $A$ 中从当前 $Z$ 序列最后一位的值的位置开始继续向后扫描，扫到第一个等于新增数字的位置，即是新的 $Z$ 序列的最后一位。而如果扫描到了 $A$ 的最后也没有找到，则意味着不存在合法的 $Z$ 序列，因此 $B$ 不是 $A$ 的子序列。

这样的话每次询问时，最多扫描 $A$ 一次，因此总时间复杂度为 $O(nq + \sum L)$，可以通过 Subtask $1$，期望得分 $20~pts$

### Algorithm $2$

考虑对 $A$ 建立一个子序列自动机，用来识别 $A$ 的所有子序列。

同样运用 ``Algorithm 1`` 中的思想，对于一个字符串$B$，我们只要找到了其与 $A$ 的最长公共子序列在 $A$ 中的字典序最小的下标序列 $Z$，就可以说明 $B$ 是 $A$ 的子序列。那么对于 $A$ 的每一位而言，在其需要新匹配一个数字时，应该转移到 $A$ 后面第一个为该数字的位置，显然这样才能保证 $Z$ 序列的字典序是最小的。因此我们的转移应该对每个位置维护加入一个数字以后它后面第一个为该数字的位置。

考虑我们对 $A$ 从后向前逐位建立自动机，对于第 $i$ 位而言，第 $i - 1$ 位加入 $A_i$ 应该转移到 $i$，而加入其它数字应该转移到 $A_i$ 加入该数字后转移到的位置。因此有伪代码

```
for i : m do
  trans[n][i] <- -1
end
for i = n : 1 do
  for j = 1 : m do
    trans[i - 1][j] <- trans[i][j]
  end
  trans[i - 1][A[i]] <- i
end
```

其中 $n$ 代表 $A$ 的长度，$m$ 代表 $A$ 中的最大值，$trans$ 是一个二维数组，代表这个自动机。

而对一个字符串 $B$ 进行匹配时，只需要将 $B$ 顺着自动机的转移跑一遍，若没有跑出自动机，则 $B$ 是 $A$ 的子序列，否则不是。

```
Function check:
  pos <- 0
  ret <- true
  for i = 1 : L do
    pos <- trans[pos][B[i]]
    if pos == -1 then
      ret <- false
      break
    endif
  end
  return ret
end Func
```

注意到这样构造自动机的时间复杂度为 $O(nm)$，匹配的复杂度为 $O(\sum L)$，因此总时间复杂度 $O(nm + \sum L)$，可以通过 Subtask $1$，$2$，期望得分 $55~pts$。

### Algorithm $3$

注意到构造自动机时，第 $i$ 位与第 $i - 1$ 位只有 $A_i$ 一项不一样，第 $i - 1$ 位的转移可以看做第 $i$ 位的转移的基础上修改了一个位置，因此我们可以从后向前使用可持久化线段树来维护每个位置的转移数组，这样建立自动机的时间复杂度为 $O(n \log m)$，匹配的时间复杂度为 $O(\sum L \log m)$。总时间复杂度 $O((n + \sum L) \log m)$，可以通过全部的 Subtask，期望得分 $100~pts$。

## Code

### Algorithm $2$

代码来自 @[**_皎月半洒花**](https://www.luogu.com.cn/user/28313)

```cpp
#include <cstdio>
#include <vector>
#include <cstring>
#include <iostream>

#define MAXN 200010

using namespace std ;

int L, N, M, Q, S[MAXN], nxt[MAXN][102] ;

void build(){
    for (int i = 1 ; i <= M ; ++ i)
        nxt[L + 2][i] = nxt[L + 1][i] = L + 2 ;
    for (int i = L ; i ; -- i)
        memcpy(nxt[i - 1], nxt[i], sizeof(nxt[i])), nxt[i - 1][S[i]] = i ;
}
int qr(){
    char c = getchar() ;
    int res = 0 ; while (!isdigit(c)) c = getchar() ;
    while (isdigit(c)) res = (res << 1) + (res << 3) + c - 48, c = getchar() ;
    return res ;
}
int main(){
    int i, j, k, emm ;
    cin >> emm >> N >> Q >> M ; L = N ;
    for (i = 1 ; i <= L ; ++ i) scanf("%d", &S[i]) ; build() ;
    for (i = 1 ; i <= Q ; ++ i){
        N = qr() ; int st = 0, ans = 0 ;
        for (j = 1 ; j <= N ; ++ j){
            k = qr(), st = nxt[st][k] ;
            if (!st){
                while (j < N)
                    ++ j, emm = qr() ;
                ans = 1 ;
            }
//            cout << st << endl ;
        }
        printf(ans ? "No\n" : "Yes\n") ;
    }
    return 0 ;
}
```

### Algorithm $3$

```cpp
#include <cstdio>

template <typename T>
inline void qr(T &x) {
  char ch;
  do ch = getchar(); while ((ch > '9') || (ch < '0'));
  do x = x * 10 + (ch ^ 48), ch = getchar(); while ((ch >= '0') && (ch <= '9'));
}

const int maxn = 100005;

struct Tree {
  Tree *ls, *rs;
  int l, r, v;

  Tree(const int L, const int R) : l(L), r(R), v(-1) {
    if (l != r) {
      int mid = (l + r) >> 1;
      ls = new Tree(l, mid);
      rs = new Tree(mid + 1, r);
    }
  }

  Tree(Tree *pre, const int P, const int V) : l(pre->l), r(pre->r), v(0) {
    if (l == r) {
      v = V;
    } else {
      if (pre->ls->r >= P) {
        rs = pre->rs;
        ls = new Tree(pre->ls, P, V);
      } else {
        ls = pre->ls;
        rs = new Tree(pre->rs, P, V);
      }
    }
  }

  int query(const int x) {
    if (this->l == this->r) {
      return this->v;
    } else {
      return (this->ls->r >= x) ? this->ls->query(x) : this->rs->query(x);
    }
  }
};
Tree *rot[maxn];

int tp, n, q, m;
int MU[maxn];

int main() {
  qr(tp); qr(n); qr(q); qr(m);
  rot[n] = new Tree(1, m);
  for (int i = 1; i <= n; ++i) {
    qr(MU[i]);
  }
  for (int i = n; i; --i) {
    rot[i - 1] = new Tree(rot[i], MU[i], i);
  }
  for (int L, x, pos; q; --q) {
    L = pos = 0; qr(L);
    while ((L--) && (pos != -1)) {
      x = 0; qr(x);
      if ((pos = rot[pos]->query(x)) == -1) {
        while (L--) {
          qr(x);
        }
        break;
      }
    }
    puts((~pos) ? "Yes" : "No");
  }
  return 0;
}
```

## appreciation

感谢验题人：@[**_皎月半洒花**](https://www.luogu.com.cn/user/28313) @[**water_lift**](https://www.luogu.com.cn/user/39122)

感谢本文的审核与校对：@[**Dusker**](https://www.luogu.com.cn/user/26538)

---

## 作者：_虹_ (赞：4)

[基本不更新的博客](https://www.luogu.com.cn/blog/RainbowCat/)

提供一个离线O(∑L)做法。

双倍经验，双倍快乐[P3500](https://www.luogu.com.cn/problem/P3500)

首先看一下这题是如何匹配的。

对于文本串A，模式串B已经匹配i位，第i位匹配文本串位置为x，第i+1位为j。

假设存在x<a<b,A(a)==A(b)==j,则第i+1位匹配a位置显然不劣于b位置。

换句话说就是贪心的能匹配就一定匹配。

设函数f(i-1,j)为询问j，考虑完文本串前i-1个字符后，当前未匹配的首个字符。

则对于所有f(i-1,j)==A(i)的j，全部都完成了该字符的匹配,f(i,j)=next(j)。对于不相等的，则有f(i,j)=f(i-1,j)

显然f函数第一维其实没啥用，完全可以删去。

所以直接按照待匹配字符（即f函数）对询问分类，扫描文本串，每次处理等待匹配该字符的询问就行了。

具体实现可以用双向链表或单向链表，这里选择了白嫖std::list

```
#include <iostream>
#include <list>
using namespace std;
const int kmaxn=1000000+5;
int arr[kmaxn];
int ask[kmaxn];
int len[kmaxn];
int pos[kmaxn];
int tar[kmaxn];
list<int> lst[kmaxn];
int n,m,q,t;
int main()
{
	ios::sync_with_stdio(false);
	cin>>t>>n>>q>>m;
	for(int i=1;i<=n;++i)
		cin>>arr[i];
	for(int i=1,m=0;i<=q;++i)
	{
		cin>>len[i];
		for(int j=1,k=len[i];j<=k;++j)
			cin>>ask[++m];
		tar[i]=m+1;
		lst[ask[pos[i]=m-len[i]+1]].push_front(i);
	}
	for(int i=1;i<=n;++i)
	{
		m=lst[arr[i]].size();
		while(m--)
		{
			t=*lst[arr[i]].begin();
			lst[arr[i]].pop_front();
			if((++pos[t])!=tar[t])
				lst[ask[pos[t]]].push_back(t);
		}
	}
	for(int i=1;i<=q;++i)
		cout<<(pos[i]==tar[i]?"Yes\n":"No\n");
	return 0;
} 
```


---

## 作者：Lgx_Q (赞：3)

看到 DL 的做法都是用子序列自动机在线维护，由于本蒟蒻不会这个东西，就来一发 **离线做法**。

---

先用 **vector** 存储每一个询问的序列（离线特色）。

我们想一想，对于一个子序列 $B$ 和原序列 $A$，我们如果进行子序列匹配，若匹配到了 $A_i=B_j$，接下来匹配 $B_{j+1}$ 的时候，是不是只需要在 $A_{i+1...n}$ 中找最前面的相同的数就可以了？

因此，我们可以枚举 $i=1...n$，看看 $A_i$ 哪一些询问的匹配有贡献。由于序列中的数都小于等于 $10^5$，因此可以在值域（也就是桶）上建立 $m$ 个队列，对于第 $k$ 个队列，保存 $q$ 个询问中下一个待匹配的值为 $k$ 的有哪些询问（设其中一个询问序列为 $B$，若需要下一个匹配的值为 $B_{j+1}$，则 $q[B_{j+1}]$ 中保存了询问 $B$ 的编号）。

之后，取出 $q[a[i]]$ 的这些询问编号，设 $p[x]$ 为第 $x$ 个询问下一个匹配的位置为序列第 $p[x]$ 个数（$p[x]$ 从 $1$ 开始）。当取出了 $q[a[i]]$ 中的一个数 $x$，令 $p[x]++$（已经匹配了 $a[i]$ 和 第 $p[x]$ 个位置）。

若 $p[x]≤len[x]$ （即还有待匹配的元素，其中 $len[x]$ 为子序列 $x$ 的长度）然后将 $x$ 压入 $q[B^x[p[x]]]$（$B^x$ 为第 $x$ 个询问的序列）

最后，对于每个询问 $x$ ，若 $p[x]>len[x]$ （即所有都匹配完了），说明第 $x$ 个询问的序列为 $a$ 中的子序列 ```Yes```，否则 ```No```。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=100010;
int n,q,m,len,a[MAXN],val,b[MAXN];
vector<int>query[MAXN];
queue<int>type[MAXN];
signed main()
{
	scanf("%d%d%d%d",&val,&n,&q,&m);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
	}
	for(int i=1;i<=q;i++)
	{
		scanf("%d",&len);
		while(len--)
		{
			scanf("%d",&val);
			query[i].push_back(val);
		}
		type[query[i][0]].push(i);
	}
	for(int i=1;i<=n;i++)
	{
		len=type[a[i]].size();
		while(len--)
		{
			int k=type[a[i]].front();
			type[a[i]].pop();
			b[k]++;
			if(b[k]<query[k].size())
			{
				type[query[k][b[k]]].push(k);
			}
		}
	}
	for(int i=1;i<=q;i++)
	{
		if(b[i]<query[i].size())
		{
			printf("No\n");
		}
		else
		{
			printf("Yes\n");
		}
	}
	return 0;
}

```

---

## 作者：Tenshi (赞：3)

# 子序列自动机

这东西是我刷 ARC 的时候遇到的，~~慕名而来~~。

结合模板题阅读：

[here](https://www.luogu.com.cn/problem/P5826)



## 构建

这个自动机原理十分简单，你可以将它当作一个 dp 来食用：

记所给的字符串为 $w$，字符集为 $S$，$next[i][ch]$ 为第 $i$ 个字符**之后**（不包括位置 $i$）字符 $ch$ 所在的**最近**的位置。

那么我们有转移方程：
$$
next[i][j] = next[i+1][j] ~~~~~~~ (w[i+1] \ne j) 
$$
$$
next[i][j] = i+1 ~~~~~~~ (w[i+1] = j)
$$
注意到转移的方向，我们只需要倒序扫一遍字符串并构建 $next$ 即可。



## 优化

当字符集 $S$ 大小 $|S|$ 很小的时候，直接转移就够了。

那，$|S|$ 比较大的时候如何处理呢？

注意到对于上面的转移方程，其实只有字符 $j = w[i+1]$ 的时候 $next[i][j]$ 才会被更新，那么我们不妨将 $next[i]$ 看成是一个桶（值域是字符集），则我们需要做的操作就是在桶的位置 $j$ 作单点修改。

而因为我们需要开 $n$（字符串 $w$ 长度）次桶，每次都相应地作单点修改，因此这一过程可以用主席树来维护。



## 查询是否存在所求子序列

由 $next$ 构建过程知这是基于贪心的思想构建的，所以我们将待查询的串 $str$ 扔到 $next$ 上并根据查询串的字符作转移，如果跳出去了就肯定没有，反之必然有，复杂度 $O(|str|)$。

也就是本模板题，代码见下面的**实现**。



##  实现

截至目前，洛谷最优解有五页，我排到第四页，~~QAQ~~。

```cpp
#include<bits/stdc++.h>
using namespace std;

#define debug(x) cerr << #x << ": " << (x) << endl
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define dwn(i,a,b) for(int i=(a);i>=(b);i--)
#define pb push_back
#define all(x) (x).begin(), (x).end()

#define x first
#define y second
using pii = pair<int, int>;
using ll = long long;

inline void read(int &x){
    int s=0; x=1;
    char ch=getchar();
    while(ch<'0' || ch>'9') {if(ch=='-')x=-1;ch=getchar();}
    while(ch>='0' && ch<='9') s=(s<<3)+(s<<1)+ch-'0',ch=getchar();
    x*=s;
}

const int N=1e5+5;

struct Node{
	int l, r;
	int go;
}tr[N*25];

int root[N], idx;

int qwq, n, q, m;
int w[N];

void upd(int &p, int q, int l, int r, int x, int k){
	p=++idx;
	tr[p]=tr[q];
	if(l==r){;
		tr[p].go=k;
		return;
	}
	int mid=l+r>>1;
	if(x<=mid) upd(tr[p].l, tr[q].l, l, mid, x, k);
	else upd(tr[p].r, tr[q].r, mid+1, r, x, k);
}

void build(){
	dwn(i,n,1) upd(root[i-1], root[i], 1, m, w[i], i);
}

int query(int u, int l, int r, int x){
	if(l==r) return tr[u].go;
	int mid=l+r>>1;
	if(x<=mid) return query(tr[u].l, l, mid, x);
	return query(tr[u].r, mid+1, r, x);
}

int main(){
	cin>>qwq>>n>>q>>m;
	rep(i,1,n) read(w[i]);
	
	build();
	
	while(q--){
		int k; read(k);
		bool ok=true;
		int u=0;
		while(k--){
			int x; read(x);
			auto go=query(root[u], 1, m, x);
			if(!go) ok=false;
			if(ok) u=go;
		}
		puts(ok? "Yes": "No");
	}
	
	return 0;
}
```



---

## 作者：Luciylove (赞：2)

题面 ：

> 多组测试数据，给出一个串 S 多次查询 T 是不是 S 的子序列。

- Step 1: 我们如果想要在一个串 S 里面，去查询一个子序列 T, 那么可以怎么做？

> Solution 1:

考虑暴力双指针 $(i,j)$ ,当我们发现一个 $S$ 中的一个新的最近的位置 $j'$ 使得 $(i+1,j')$ 是可以匹配的，那么我们就暴力移动他这个是 $O(n + m)$ 的,其中 $m,n$ 分别是母串和子序列的长度。总时间是 $O(qm +\sum n)$ 的.

> Solution 2:

考虑优化暴力的过程我们可以直接记录 $Nxt_{i,j}$ 表示位置 $i$ 后下一个$ j$ 位置。（这个是我在做积木小赛的时候发现的），我们可以用它来 $O(n)$ 匹配。

这就是子序列自动机，我们可以用它做到 $O(k\sum n +m*s)$ 来匹配，其中 $k$ 是单次往下走的时间，$s$ 是字符集的长度。

- Step 2: Compare

这两个东西看起来差不多快啊 (退钱！)，但是，我们不妨钦定 $m$ 是 $n ^ 2$ 级别的，然后字符集是几乎为线性的一个常数。可以解得 ： 在算法 1 下的 $n$ 可以达到 $10^3$级别，但不能维护多的询问，而算法 2 下处理却是游刃有余。

但是，如果没有字符集的限制，我们该如何去处理呢？
首先，观察最基础的处理方式，因为每次至多更新 1 个字符，所以 $Nxt$ 至多更新一个元素，而我们则浪费了太多的时间在维护不变的指针上面。
然后，我们发现，这个指针是在上一个版本上建立的（~~要素察觉~~）,所以我们需要维护一个支持快速维护数组的增量数据结构，也就是可持久化数组，故我们可以使用一颗可持久化线段树去维护子序列自动机。

故我们有 $O(\sum n \log m +m\log m)$ 的时间解决该问题，当然，我们也有更简单的解决方式，我们可以拿一个 $vector$ 存储所有元素的下标，然后二分。

```cpp
#include<bits/stdc++.h>
#define mid (l + r) / 2
using namespace std;
const int MN = 1e6 + 5;
inline int read() {
	int x = 0; bool f = 0; char c = getchar();
	while(c < '0' || c > '9') (c == '-') ? f = 1, c = getchar() : c = getchar();
	while(c >= '0' && c <= '9') x = (x << 1) + (x << 3) + (c ^ 48), c = getchar();
	return (f) ? -x : x;
}
int n, q, lim, cnt, nxt, l, opt, a[MN], b[MN] , rt[MN], ls[MN * 80], rs[MN * 80], val[MN * 80];
inline void Build(int & u, int l, int r) {
	u = ++ cnt;
	if (l == r) {val[u] = 0; return ;}
	Build(ls[u], l, mid), Build(rs[u], mid + 1, r);
	return ;
}
inline void Modify(int pre, int & u, int l, int r, int pos, int k) {
	u = ++ cnt;
	if (l == r) {val[u] = k; return ;}
	if (pos <= mid) rs[u] = rs[pre], Modify(ls[pre], ls[u], l, mid, pos, k);
	else ls[u] = ls[pre], Modify(rs[pre], rs[u], mid + 1, r, pos, k);
}
inline int Qur(int u, int l, int r, int pos) {
	if (l == r) {return val[u];}
	if (pos <= mid) return Qur(ls[u], l, mid, pos);
	else return Qur(rs[u], mid + 1, r, pos);
}
//主席树板子
int main () {
    opt = read(), n = read(), q = read(), lim = read(), Build(rt[n + 1], 1, n);
    for (int i = 1; i <= n; i ++) a[i] = read(); //读入
    for (int i = n; i >= 1; i --) Modify(rt[i + 1], rt[i], 1, n, a[i], i); //维护子序列自动机
    for (int i = 1; i <= q; i ++) {
    	l = read(), nxt = 1; for (int j = 1; j <= l; j ++) b[j] = read();
    	for (int j = 1; j <= l; j ++) {
    		nxt = Qur(rt[nxt], 1, n, b[j]); // 查询下一个数位置
    		if (! nxt) {
    			printf("No\n"); break ;
			}
			nxt ++; //跳到这之后的位置
		}
		if (nxt) printf("Yes\n");
	}
	return 0;
}

```


---

## 作者：Limit (赞：2)

不会用STL的路过

# 题目大意

给出一个序列 $a$ 和一些序列,需要判断这些序列是否是 $a$ 的字序列.

# 分析

这篇文章不会用到vector,保证可以让pascal等语言的用户也看懂并且可以~~轻松~~实现.

# 序列自动机

如何快速判断一个序列是否是另一个序列的子序列,这时就可以用到[序列自动机](https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=1&rsv_idx=1&tn=baidu&wd=%E5%BA%8F%E5%88%97%E8%87%AA%E5%8A%A8%E6%9C%BA&rsv_t=6b87a74KihswDCS6gtfOXIWQ9IrrE7xGKcBf8d8%2BkJbzrp17%2BXfZ5t%2FItZY&rsv_enter=1&rsv_dl=tb&rsv_sug3=18&rsv_sug1=7&rsv_sug7=101&rsv_sug2=0&inputT=3775&rsv_sug4=4181)了,对于暴力的做法可以枚举需要查询的序列的第 $i$ 个位置,在用一个类似指针的东西枚举在原序列中的下一个相等的位置,可以发现这样的时间复杂度为$\mathcal{O}(|a|)$($|a|$表示原序列的长度,末日查询序列长度小于原序列长度),而序列自动机就是讲每个位置的下一个出现元素的位置全部保存,这样就可以做到 $\mathcal{O}(1)$ 查询下一个出现的位置了,但是这个东西的的预处理的时间复杂度为 $\mathcal{O}($ 值域大小 $\times |a|)$,显然会MLE,那么可以发现对于相邻的两个数的这个查询下一个位置的数组最多只有一个位置不一样,所以,就是可以持久化线段树就可以解决了.

最后的时间复杂度为 $\mathcal{O}(\sum_{i=1}^qL_i\log_2m+n\log_2m)$.

# 代码

```cpp
#include<bits/stdc++.h>
#define REP(i,first,last) for(int i=first;i<=last;++i)
#define DOW(i,first,last) for(int i=first;i>=last;--i)
using namespace std;
const int maxN=1e6+7;
int N,M;
int top=0;
int a[maxN],b[maxN];
struct Tree//主席树模板,不多讲了
{
	int lson,rson,sum;
}tree[maxN*80];
int point_cnt=0;
#define LSON tree[now].lson
#define RSON tree[now].rson
#define MIDDLE ((left+right)>>1)
#define LEFT LSON,left,MIDDLE
#define RIGHT RSON,MIDDLE+1,right
#define NEW_LSON tree[new_tree].lson
#define NEW_RSON tree[new_tree].rson
void Updata(int num,int change,int &new_tree,int now,int left=1,int right=top)
{
	if(num<left||right<num)
	{
		new_tree=now;
		return;
	}
	new_tree=++point_cnt;
	tree[new_tree].lson=0;
	tree[new_tree].rson=0;
	tree[new_tree].sum=0;
	if(left==right)
	{
		tree[new_tree].sum=change;
		return;
	}
	if(MIDDLE>=num)
	Updata(num,change,NEW_LSON,LEFT);
	else
	NEW_LSON=LSON;
	if(MIDDLE+1<=num)
	Updata(num,change,NEW_RSON,RIGHT);
	else
	NEW_RSON=RSON;
}
int Query(int num,int now,int left=1,int right=top)
{
	if(num<left||right<num)
	{
		return 0;
	}
	if(left==right)
	{
		return tree[now].sum;
	}
	return Query(num,LEFT)+Query(num,RIGHT);
}
int root[maxN];
void work()//对于每一个序列
{
    point_cnt=0;
	scanf("%d",&M);
	int now=1;
	REP(i,1,M)
	{
		scanf("%d",&b[i]);
	}
	REP(i,1,M)
	{
		now=Query(b[i],root[now]);//查询这个数下一个出现的位置
		if(now==0)//如果不存在就是No
		{
			printf("No\n");
			return;
		}
		now++;//这里记录的是包含自己的所以需要++
	}
	printf("Yes\n");//存在
}
int main()
{
    int opt;
	int T;
	scanf("%d%d%d%d",&opt,&T,&N,&top);
	REP(i,1,N)
	{
		scanf("%d",&a[i]);
	}
	DOW(i,N,1)//倒叙预处理
	{
		Updata(a[i],i,root[i],root[i+1]);
	}
	REP(i,1,T)
	{
		work();
	}
	return 0;
}
```

---

## 作者：王大神——A001 (赞：0)

## 子序列自动机
[传送门](https://www.luogu.com.cn/problem/P5826)

题目要我们求，给定一个序列是否是原串的子序列，那么我们就要快速找到下一位的在原串中的匹配位置。

为了能让子串尽可能匹配，所以我们要找到的匹配位置尽量靠前，而且我们发现，我们是**按位匹配**的，所以可以用可持久化线段树（[主席树](https://wdsa001.github.io/2021/09/21/zhu-xi-shu-ji-chu/)）来处理。

我们要找的是最近的点，所以将串从后往前处理，这样就可以将更近的点不断更新，最后剩下的就是最优的解（这个字符后每个字符最近的位置）。

### 主席树代码
```cpp
#include<iostream>
#include<cstring>
#include<string>
#include<cstdio>
#include<algorithm>
#include<cctype>
#include<queue>
using namespace std;
int r_r(){//快读 
	int x=0,f=1;
	char c=getchar();
	while(!isdigit(c)){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(isdigit(c)){
		x=(x<<1)+(x<<3)+(c^48);
		c=getchar();
	}
	return x*f;
}
const int o_o=2e6+10;
int op,n,q,m;
int a_a[o_o],b_b[o_o];
struct po{
	int l_s;//左子树 
	int r_s;//右子树 
	int i;//编号 
}t_r[o_o];
int x_p=0;
void u_p(int v,int x,int &n_w,int k_k,int l=1,int r=m){
	if(v<l||r<v){//超出范围 
		n_w=k_k;//直接复制根节点信息 
		return;
	}
	n_w=++x_p;//建新点 
	t_r[n_w].l_s=0;
	t_r[n_w].r_s=0;
	t_r[n_w].i=0;
	//初始化新节点 
	
	if(l==r){//找到范围 
		t_r[n_w].i=x;//存坐标 
		return;
	}
	int m_i=(l+r)>>1;
	if(m_i>=v)u_p(v,x,t_r[n_w].l_s,t_r[k_k].l_s,l,m_i);//左子树 
	else t_r[n_w].l_s=t_r[k_k].l_s;
	if(m_i+1<=v)u_p(v,x,t_r[n_w].r_s,t_r[k_k].r_s,m_i+1,r);//右子树 
	else t_r[n_w].r_s=t_r[k_k].r_s;
}
int f_i(int x,int k_k,int l=1,int r=m){
	if(x<l||r<x)return 0;//超出目标范围 
	if(l==r)return t_r[k_k].i;//找到目标叶子结点 
	int m_i=(l+r)>>1; 
	return f_i(x,t_r[k_k].l_s,l,m_i)+f_i(x,t_r[k_k].r_s,m_i+1,r);//统计结果 
}
int g_g[o_o];//每个节点作为根的编号存储 
int main(){
    op=r_r(),n=r_r(),q=r_r(),m=r_r();
	for(int i=1;i<=n;i++)a_a[i]=r_r();//读入序列 
	for(int i=n;i>=1;i--)u_p(a_a[i],i,g_g[i],g_g[i+1]);//将每个点放入树中 
	for(int i=1;i<=q;i++){//多组询问 
		int x_k=r_r();//读取匹配序列长度 
		x_p=0;
		int k_k=1;//开始位置 
		bool b_p=0;//标记是否失败 
		for(int i=1;i<=x_k;i++)b_b[i]=r_r();//读取匹配序列 
		for(int i=1;i<=x_k;i++){
			k_k=f_i(b_b[i],g_g[k_k]);//匹配位置 
			if(k_k==0){//找不到了 
				b_p=1;//标记 
				break;
			}
			k_k++;//进入下一个，当前值已经用过了 
		}
		if(b_p)puts("No");
		else puts("Yes");
	}
	return 0;
}
```

但是我们还可以用 `STL` 来做，通过 `vector` 将每个字符的坐标存下来，在子串匹配的时候，需要什么字符可以直接访问，同时我们存坐标时是有序的（升序），所以可以二分来更快的访问最近的合法位置匹配。 

### 二分代码

```cpp
#include<iostream>
#include<cstring>
#include<string>
#include<cstdio>
#include<algorithm>
#include<cctype>
#include<queue>
using namespace std;
int r_r(){//快读 
	int x=0,f=1;
	char c=getchar();
	while(!isdigit(c)){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(isdigit(c)){
		x=(x<<1)+(x<<3)+(c^48);
		c=getchar();
	}
	return x*f;
}
const int o_o=2e6+10;
vector<int> p_p[o_o];
int main(){
	int t_p=r_r(),n=r_r(),q=r_r(),m=r_r();//读入基本信息 
	for(int i=1;i<=n;i++)p_p[r_r()].push_back(i);//将每从个数的值直接放入到 
	while(q--){
		int l=r_r(),x_x=0;//记录开始的位置，初始化初值 
		bool b_b=1;//初始化判断的 
		while(l--){
			int x=r_r();//读入当前值 
			if(!b_b)continue;//已经不符合要求直接退出循环 
			vector<int>::iterator k_k=lower_bound(p_p[x].begin(),p_p[x].end(),x_x+1);//二分最接近的值 
			if(k_k==p_p[x].end())b_b=0;//变化判断的值 
			else x_x=*k_k;//累计结果 
		}
		if(b_b)puts("Yes");//符合要求 
		else puts("No");//不符合要求 
	}
}
```


---

## 作者：_lfxxx_ (赞：0)

### 题意：
判断一个序列是否是已知序列的子序列。
### 思路：
首先容易想到 $O(nq+\sum L)$ 的暴力匹配，大概是这样的：
```cpp
...//读入
while(q--){
	...//读入
	for(int i=1,p=1;i<=l;++i)
		while(b[i]!=a[p]&&p<=n)
			++p;//拿 B 去匹配 A 
	puts(p<=n?"Yes":"No");
}
```
思考慢在哪里。

上面的程序慢在了找当前需要匹配的数，每次都需要扫一遍整个数组。因此可以想到将每个**数值出现的位置**开个桶记录下来，比如样例的 $a$ 数组：
```
1 3 2 2 4
```
我们就可以这么存储下来：
```cpp
1:1//1 出现在第 1 个位置。
2:3,4//3,4 出现在第 3,4 个位置，下同。
3:2
4:5
```
这样的话我们要找一个数，只要遍历它的值的位置。

由于位置序列有序，所以又可以二分加速。

注意：不能直接开 $10^5\times10^5$ 的数组，会爆，要用动态数组。

时间复杂度 $O(n+(\sum L)\log n)$，而且根本跑不满。
### 代码：
有些细节还是需要看代码的，因此放多一点代码：

变量和题目有些不同，轻D~~凑合看~~。
```cpp
namespace solution{
	vector<int>v[N];
	vector<int>::iterator it;
	int main(){
		int n,T,x,p,type,m;
		bool f;
		cin>>type>>n>>T>>m;
		for(int i=1;i<=n;++i)
			cin>>x,v[x].push_back(i);
		while(T--){
			f=1;
			p=0;
			cin>>n;
			for(int i=1;i<=n;++i){
				cin>>x;
				it=upper_bound(v[x].begin(),v[x].end(),p);
				if(it==v[x].end())//二分
					f=0;
				else
					p=*it;
			}
			if(f)
				cout<<"Yes\n";
			else
				cout<<"No\n";
		}
		return 0;
	}
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	return solution::main();
}
```


---


# [蓝桥杯 2019 国 B] 第八大奇迹

## 题目背景

在一条 R 河流域，繁衍着一个古老的名族 Z。他们世代沿河而居，也在河边发展出了璀璨的文明。

Z 族在 R 河沿岸修建了很多建筑，最近，他们热衷攀比起来。他们总是在比谁的建筑建得最奇特。

幸好 Z 族人对奇特的理解都差不多，他们很快给每栋建筑都打了分，这样评选谁最奇特就轻而易举了。

于是，根据分值，大家很快评出了最奇特的建筑，称为大奇迹。后来他们又陆续评选了第二奇特、第二奇特、……、第七奇特的建筑，依次称为第二大奇迹、第三大奇迹、……、第七大奇迹。

最近，他们开始评选第八奇特的建筑，准备命名为第八大奇迹。在评选中，他们遇到了一些问题。

## 题目描述

首先，Z 族一直在发展，有的建筑被拆除又建了新的建筑，新建筑的奇特值和原建筑不一样，这使得评选不那么容易了。

其次，Z 族的每个人所生活的范围可能不一样，他们见过的建筑并不是所有的建筑，他们坚持他们自己所看到的第八奇特的建筑就是第八大奇迹。

Z 族首领最近很头疼这个问题，他害怕因为意见不一致导致 Z 族发生分歧。他找到你，他想先了解一下，民众自己认为的奇迹是怎样的。

现在告诉在 R 河周边的建筑的变化情况，以及在变化过程中一些人的生活范围，请编程求出每个人认为的第八大奇迹的奇特值是多少。

## 说明/提示

对于 $20\%$ 的评测用例，$1 \le L \le 1000$，$1 \le N \le 1000$。

对于 $40\%$ 的评测用例，$1 \le L \le 10000$，$1 \le N \le 10000$。

对于 $100\%$ 的评测用例，$1 \le L \le 10^5$，$1 \le N \le 10^5$。所有奇特值为不超过 $10^9$ 的非负整数。

蓝桥杯 2019 年国赛 B 组 I 题。

## 样例 #1

### 输入

```
10 15
C 1 10
C 2 20
C 3 30
C 4 40
C 5 50
C 6 60
C 7 70
C 8 80
C 9 90
C 10 100
Q 1 2
Q 1 10
Q 1 8
C 10 1
Q 1 10```

### 输出

```
0
30
10
20
```

# 题解

## 作者：Pengzt (赞：10)

[P8701](https://www.luogu.com.cn/problem/P8701)

显然可以直接将维护的值变为区间前 $8$ 大，为实现的简洁，可使用 vector，使用归并合并信息达到 $\mathcal{8n\log n}$。由于偷懒，归并部分我直接写的 sort，加上 vector 的大常数，加 O2 后即可通过。

时间复杂度：$\mathcal{O}(8n\log n)$。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define pb emplace_back

const int N=1e5+10;
int n,m;
vector<int> tr[N<<2];
vector<int> operator+(vector<int> a,vector<int> b){
	vector<int> c=a;
	for(int i:b)c.pb(i);
	return c;
}
void pushup(int u){
	tr[u]=tr[u<<1]+tr[u<<1|1];
	sort(tr[u].begin(),tr[u].end(),greater<int>());
	while(tr[u].size()>8)tr[u].pop_back();
}
void update(int u,int l,int r,int k,int val){
	if(l==r){
		tr[u].clear();tr[u].pb(val);
		return;
	}
	int mid=(l+r)>>1;
	if(k<=mid)update(u<<1,l,mid,k,val);
	else update(u<<1|1,mid+1,r,k,val);
	pushup(u);
}
vector<int> query(int u,int l,int r,int L,int R){
	if(L<=l&&r<=R)return tr[u];
	int mid=(l+r)>>1;
	vector<int> vec;
	if(L<=mid)vec=vec+query(u<<1,l,mid,L,R);
	if(mid<R)vec=vec+query(u<<1|1,mid+1,r,L,R);
	sort(vec.begin(),vec.end(),greater<int>());
	while(vec.size()>8)vec.pop_back();
	return vec;
}

int main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		char opt;int x,y;
		cin>>opt>>x>>y;
		if(opt=='C')update(1,1,n,x,y);
		else{
			vector<int> tmp=query(1,1,n,x,y);
			if(tmp.size()==8)cout<<tmp.back()<<"\n";
			else cout<<0<<"\n";
		}
	}
	return 0;
}

```

---

## 作者：wdgm4 (赞：6)

~~明明是一道很简单的题，为什么没人做啊。~~

## 正文

前置芝士：[带修改的区间第 $k$ 小](https://www.luogu.com.cn/problem/P2617)

这道题我用树状数组套主席树做的。

~~知周所众~~，主席树可以支持查询第 $k$ 小，但它不能直接支持修改。它的原理是建 $n$ 棵权值线段树，第 $i$ 棵线段树存 $[1,i]$ 的区间内的所有值的数量，查询时前缀和一下即可。

而要是带上修改的话，如果暴力修改前缀和肯定会超时，所以考虑树状数组优化前缀和。这样的话，就不再是直接第 $r$ 棵树减去第 $l-1$ 棵树，而是在树状数组上的 $r$ 的一堆树减去树状数组上的 $l-1$ 的一堆树。这样就可以把前置芝士里的题 $\color{green}{AC}$ 了。

而这道题只不过没有了初始值，第 $k$ 小变成了第 $k$ 大，要多判断本来查询区间内就没有那么多建筑的情况。改改刚才的代码就可以了。

下面放上代码。

```cpp
#include<bits/stdc++.h>
#define XD 114514
#define MAXN 100010
#define MAXM 200010
#define lowbit(x) x&-x
using namespace std;
int n,m,a[MAXN];
int cab[MAXM],len,cab2;
struct question{
	bool kind;
	int l,r;
	int x,y;
} q[MAXN];
struct tree{
	int l,r,val;
} t[MAXN*500];
int cnt,top[MAXN];
int modify(int x,int l,int r,int k,int num){
	int nem=++cnt;
	t[nem]=t[x];t[nem].val+=num;
	if(l==r) return nem;
	int mid=l+r>>1;
	if(k<=mid) t[nem].l=modify(t[x].l,l,mid,k,num);
	else t[nem].r=modify(t[x].r,mid+1,r,k,num);
	return nem;
}
void add(int x,int y,int num){
	for(int i=x;i<=n;i+=lowbit(i)){
		top[i]=modify(top[i],1,len,y,num);
	}
}
int needs_x[MAXN],needs_y[MAXN];
int query(int x,int y,int l,int r,int k){
	if(l==r) return cab[l];
	int nem1=0,nem2=0;
	for(int i=x;i;i-=lowbit(i)) nem1+=t[t[needs_x[i]].r].val;
	for(int i=y;i;i-=lowbit(i)) nem2+=t[t[needs_y[i]].r].val;
	int mid=l+r>>1;
	if(nem2-nem1>=k){
		for(int i=x;i;i-=lowbit(i)) needs_x[i]=t[needs_x[i]].r;
		for(int i=y;i;i-=lowbit(i)) needs_y[i]=t[needs_y[i]].r;
		return query(x,y,mid+1,r,k);
	}else{
		for(int i=x;i;i-=lowbit(i)) needs_x[i]=t[needs_x[i]].l;
		for(int i=y;i;i-=lowbit(i)) needs_y[i]=t[needs_y[i]].l;
		return query(x,y,l,mid,k-(nem2-nem1));
	}
}
int search(int l,int r){
	int nem=0;
	for(int i=r;i;i-=lowbit(i)) nem+=t[top[i]].val;
	for(int i=l-1;i;i-=lowbit(i)) nem-=t[top[i]].val;
	if(nem<8) return 0;
	for(int i=l-1;i;i-=lowbit(i)) needs_x[i]=top[i];
	for(int i=r;i;i-=lowbit(i)) needs_y[i]=top[i];
	return query(l-1,r,1,len,8);
}
int main(){
	ios::sync_with_stdio(false);
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		char ch;cin>>ch;
		if(ch=='Q'){
			q[i].kind=true;
			cin>>q[i].l>>q[i].r;
		}else{
			q[i].kind=false;
			cin>>q[i].x>>q[i].y;
			cab[++cab2]=q[i].y;
		}
	}
	sort(cab+1,cab+1+cab2);
	len=unique(cab+1,cab+1+cab2)-cab-1;
	for(int i=1;i<=m;i++){
		if(q[i].kind){
			cout<<search(q[i].l,q[i].r)<<"\n";
		}else{
			q[i].y=lower_bound(cab+1,cab+1+len,q[i].y)-cab;
			if(a[q[i].x]) add(q[i].x,a[q[i].x],-1);
			a[q[i].x]=q[i].y;
			add(q[i].x,q[i].y,1);
		}
	}
	return 0;
}

```


---

## 作者：Coffee_zzz (赞：4)

操作一是单点修改，操作二是区间查询第 $8$ 大值。$N$ 只有 $10^5$，所以可以考虑 $O(KN \log L)$ 的算法，其中 $K=8$。

考虑架一棵线段树，维护区间前 $8$ 大的值。

单点修改之后，可以将线段树修改路径上所有点都做一次归并排序。由于每个点只需维护前 $8$ 大，所以单点修改的时间复杂度是 $O(K \log L)$。

区间询问的时候可以开一个答案数组，对查询路径上所有点都归并到答案数组上，取前 $8$ 大，所以区间查询第 $8$ 大值的时间复杂度同样是 $O(K \log L)$。

总的复杂度为 $O(KN \log L)$，可以通过。

其中，把答案数组的初值都设为 $0$，就不需要特判区间长度小于 $8$ 的情况了。

记得动态开点线段树要开两倍空间。

```cpp
#include <bits/stdc++.h>

using namespace std;
const int N=1e5+5,K=9;
int val[N<<1][K],ls[N<<1],rs[N<<1],n,q,rt,cnt;
int ans[K],tmp[K];
void upd(int g){
	int a=1,b=1;
	for(int k=1;k<=8;k++){
		if(val[ls[g]][a]>val[rs[g]][b]) val[g][k]=val[ls[g]][a],a++;
		else val[g][k]=val[rs[g]][b],b++;
	}
}
void solve(int l,int r,int &g,int k,int x){
	if(!g) g=++cnt;
	if(l==r){
		val[g][1]=x;
		return;
	}
	int m=l+r>>1;
	if(k<=m) solve(l,m,ls[g],k,x);
	else solve(m+1,r,rs[g],k,x);
	upd(g);
}
void work(int g){
	for(int i=1;i<=8;i++) tmp[i]=ans[i];
	int a=1,b=1;
	for(int k=1;k<=8;k++){
		if(val[g][a]>tmp[b]) ans[k]=val[g][a],a++;
		else ans[k]=tmp[b],b++;
	}
}
void ask(int l,int r,int &g,int a,int b){
	if(!g) g=++cnt;
	if(b<l||a>r) return;
	if(a<=l&&r<=b){
		work(g);
		return;
	}
	int m=l+r>>1;
	ask(l,m,ls[g],a,b);
	ask(m+1,r,rs[g],a,b);
}
signed main(){
	cin>>n>>q;
	char c;
	int a,b;
	for(int i=1;i<=q;i++){
		cin>>c>>a>>b;
		if(c=='C') solve(1,n,rt,a,b);
		else{
			for(int i=1;i<=8;i++) ans[i]=0;
			ask(1,n,rt,a,b);
			cout<<ans[8]<<endl;
		}
	}
	return 0;
}
```

---

## 作者：a16_ (赞：3)

## 前言

好像都是树套树的题解，~~由于我不会树套树~~，所以我使用线段树。

## 题意

写一种数据结构，支持单点修改，区间查询第八大。

## 实现

它是[ P2617 Dynamic Rankings ](https://www.luogu.com.cn/problem/P8701)的弱化版，此题中 $k=8$，$k$ 很小，线段树的每个节点维护区间前 $ 8 $ 大。

具体的，我们定义这样一个结构体 Tree。
```cpp
struct Tree{ int d[8]={0}; }t[N<<2];
```
其中 d 数组就是该节点范围内的区间前八大，第八大就是 `d[7]`。

合并两个区间，就是合并两个有序数组，在归并排序的时候有使用过一种指针式的写法，时间复杂度 $O(k)$。

合并操作很多，可以重载运算符。

于是我们的结构体 Tree 变成这样：

```cpp
struct Tree{
	int d[8]={0};
	Tree operator+(const Tree &tmp)const{
		Tree res; int p1=0,p2=0;
		for(int i=0;i<8;i++)
			res.d[i]=(d[p1]>tmp.d[p2])?d[p1++]:tmp.d[p2++];
		return res;
	}
}t[N<<2];
```

对于修改操作中，就正常写，然后将左右儿子向上合并。

即 `t[p]=t[p<<1]+t[p<<1|1];`


对于查询操作，将询问分为两段，分别得到左右两部分的区间前八大，然后合并。与[小白逛公园](https://www.luogu.com.cn/problem/P4513)的查询操作类似。

```cpp
Tree query(int p,int l,int r,int L,int R){
	if(L<=l&&r<=R) return t[p];
	Tree ans;
	int mid=(l+r)>>1;
	if(mid>=L) ans=ans+query(p<<1,l,mid,L,R);
	if(mid<R) ans=ans+query(p<<1|1,mid+1,r,L,R);
	return ans;
}
```


完整代码如下：

```cpp
##include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
struct Tree{
	int d[8]={0};
	Tree operator+(const Tree &tmp)const{
		Tree res; int p1=0,p2=0;
		for(int i=0;i<8;i++)
			res.d[i]=(d[p1]>tmp.d[p2])?d[p1++]:tmp.d[p2++];
		return res;
	}
}t[N<<2];
void update(int p,int l,int r,int pos,int x){
	if(l==r){ t[p].d[0]=x; return;}
	int mid=(l+r)>>1;
	if(mid>=pos) update(p<<1,l,mid,pos,x);
	else update(p<<1|1,mid+1,r,pos,x);
	t[p]=t[p<<1]+t[p<<1|1];
}
Tree query(int p,int l,int r,int L,int R){
	if(L<=l&&r<=R) return t[p];
	Tree ans;
	int mid=(l+r)>>1;
	if(mid>=L) ans=ans+query(p<<1,l,mid,L,R);
	if(mid<R) ans=ans+query(p<<1|1,mid+1,r,L,R);
	return ans;
}
int main(){
	ios::sync_with_stdio(0);
	int n,m; cin>>n>>m;
	while(m--){
		char opt;int l,r;cin>>opt>>l>>r;
		if(opt=='C') update(1,1,n,l,r);
		else cout<<query(1,1,n,l,r).d[7]<<'\n';
	}
	return 0;
} 
```

可以发现，当 $k$ 较小时，用线段树实现更为的容易，时间复杂度为 $O(km\log n)$，也不慢。










---

## 作者：Register_int (赞：3)

先锐评题解区全是树套树，有没有点素质啊。

考虑返璞归真使用线段树，每个节点记录当前区间的前八大。更新的时候使用归并排序即可，时间复杂度 $O(nk\log n)$。

# AC 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int MAXN = 1e5 + 10;

struct node {
	int l, r; array<int, 8> a;
	node(int l = 0, int r = 0) : l(l), r(r) { for (int i = 0; i < 8; i++) a[i] = 0; }
	node operator + (const node &rhs) const {
		node res(l, rhs.r);
		for (int i = 0, j = 0, k = 0; i < 8; i++) res.a[i] = a[j] > rhs.a[k] ? a[j++] : rhs.a[k++];
		return res;
	}
} t[MAXN << 2];

inline 
void pushup(int p) {
	t[p] = t[p << 1] + t[p << 1 | 1];
}

void build(int l, int r, int p) {
	t[p] = node(l, r); if (l == r) return ;
	int mid = l + r >> 1;
	build(l, mid, p << 1), build(mid + 1, r, p << 1 | 1);
}

void modify(int k, int x, int p) {
	if (t[p].l == t[p].r) return t[p].a[0] = x, void();
	int mid = t[p].l + t[p].r >> 1;
	modify(k, x, p << 1 | k > mid), pushup(p);
}

node query(int l, int r, int p) {
	if (l <= t[p].l && t[p].r <= r) return t[p];
	int mid = t[p].l + t[p].r >> 1; node res;
	if (l <= mid) res = res + query(l, r, p << 1);
	if (r > mid) res = res + query(l, r, p << 1 | 1);
	return res;
}

int n, m, x, y, ans; char opt[2];

int main() {
	for (scanf("%d%d", &n, &m), build(1, n, 1); m--;) {
		scanf("%s%d%d", opt, &x, &y);
		if (*opt == 'C') modify(x, y, 1);
		else printf("%d\n", query(x, y, 1).a[7]);
	}
}
```

---

## 作者：stupid_collie (赞：3)

（其实如果你写过 P2617 Dynamic Rankings，这一题的条件看起来就会相当眼熟了）
### 简化题意：
*给你一个序列，每次询问区间第八大的数，要求支持修改操作* 
### 前置知识：主席树，树状数组
~~算是一道树套树的板子题吧~~ 

我们知道，主席树相当于是一系列权值线段树的前缀和。在使用传统主席树的时候，我们通过将其相减来获得一段区间之内的权值线段树。事实上，主席树的前缀和性质能够拓展到更宽的领域。比如说，利用这一性质，我们就能将其和树状数组联系起来。我们将主席树的每一个根节点存储到树状数组当中，这样一来，利用树状数组维护**单点修改、区间求和**的性质，就能很方便的实现本题中的**修改操作**。

而在查询的时候，我们同样利用树状数组的性质，求一遍 $[1,l-1]$ 和 $[1,r]$ 两个区间的前缀和，再将彼此相减，就能够得到相应区间的权值线段树。


为了方便离散化，我们将所有的操作都读入之后，再对相应的修改值做统一处理。由于所求的是区间第八大，所以我们在离散化的时候，将数组倒过来即可。

```cpp
#include<bits/stdc++.h>

const int maxn = 3e5 + 9;
using namespace std;

struct node{
  int sum,ls,rs;
}tree[maxn<<7];
int rt[maxn<<1],idx,x[maxn],y[maxn];
int b[maxn],c[maxn],totn,val[maxn];
int cnt1,cnt2,n,m;

map<int,int> mp;

struct oper{
  int typ,p1,p2;
}oprs[maxn];

int read(){
  int x = 0,f = 1;
  char ch = getchar();
  while(ch<'0'||ch>'9'){if(ch=='-')f = -f;ch = getchar();}
  while(ch>='0'&&ch<='9'){x = (x<<3)+(x<<1)+(ch^48);ch = getchar();}
  return x*f;
}

inline void pushup(int u){
  tree[u].sum = tree[tree[u].ls].sum + tree[tree[u].rs].sum;
}

void update(int &u,int L,int R,int p,int v = 1){
  tree[++idx] = tree[u],u = idx;
  if(L==R){
    tree[u].sum += v;
    return;
  }

  int mid = (L+R)>>1;
  if(p<=mid)update(tree[u].ls,L,mid,p,v);
  else update(tree[u].rs,mid+1,R,p,v);
  pushup(u);
}

int query(int L,int R,int rnk){
  if(L==R)return L;
  int sum = 0,mid = (L+R)>>1;
  for(int i = 1;i<=cnt1;i++)sum -= tree[tree[x[i]].ls].sum;
  for(int i = 1;i<=cnt2;i++)sum += tree[tree[y[i]].ls].sum;
  //cerr<<"sum2:"<<sum<<'\n';
  if(rnk<=sum){
    for(int i = 1;i<=cnt1;i++)x[i] = tree[x[i]].ls;
    for(int i = 1;i<=cnt2;i++)y[i] = tree[y[i]].ls;
    return query(L,mid,rnk);
  }else{
    for(int i = 1;i<=cnt1;i++)x[i] = tree[x[i]].rs;
    for(int i = 1;i<=cnt2;i++)y[i] = tree[y[i]].rs;
    return query(mid+1,R,rnk-sum);
  }
}

inline int lb(int x){return x&(-x);}
struct BIT{
  void add(int po,int newV,int v = 1){
    for(int i = po;i<=n;i+=lb(i))update(rt[i],0,totn,newV,v);
  }

  int find(int l,int r,int rnk = 8){
    cnt1 = cnt2 = 0;
    int sum = 0;
    for(int i = l-1;i;i -= lb(i))x[++cnt1] = rt[i],sum -= tree[rt[i]].sum;
    for(int i = r;i;i-= lb(i))y[++cnt2] = rt[i],sum += tree[rt[i]].sum;
    //cerr<<"sum:"<<sum<<'\n';
    if(sum<rnk)return 0;
    return query(0,totn,rnk);
  }
}bit;

int main(){
  n = read(),m = read();
  for(int i = 1;i<=m;i++){
    char ch[3];
    int x,y;
    scanf("%s",ch);
    x = read(),y = read();

    if(*ch=='C') oprs[i] = {0,x,y};
    else oprs[i] = {1,x,y};
  }

  //离散化
  int total = 0;
  for(int i = 1;i<=m;i++)
    if(oprs[i].typ==0)b[++total] = oprs[i].p2;
  sort(b+1,b+1+total);
  reverse(b+1,b+1+total);
  for(int i = 1;i<=total;i++)
    if(i==1||b[i]!=b[i-1])c[++totn] = b[i],mp[b[i]] = totn;

  for(int i = 1;i<=m;i++)
    if(oprs[i].typ==0)oprs[i].p2 = mp[oprs[i].p2];
  //离散化结束

  for(int i = 1;i<=m;i++){
    oper now = oprs[i];
    if(now.typ==0){
      //减去原来的值
      if(val[now.p1]!=0)bit.add(now.p1,val[now.p1],-1);
      val[now.p1] = now.p2;
      bit.add(now.p1,now.p2,1);
    }else{
      printf("%d\n",c[bit.find(now.p1,now.p2)]);
    }
  }
}

```

---

## 作者：junee (赞：2)

# P8701 题解

## 前置知识

线段树。

## 简化题意

给定你一个数组，有两个操作：修改某个点的权值；询问一段区间内的第八大的数。

## 题目分析

考虑用线段树维护，每个节点维护一个数组记录前八大的数，暴力维护，可以使用归并排序。

## Code
```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
#include<vector>
using namespace std;
const int N=1e5+10;
int n,m;
struct node{
	int l,r;
	vector<int>rnk;
}tr[N*4];
void pushup(vector<int> &rt,const vector<int> &l,const vector<int> &r){
	int i=0,j=0,k=0;
	while(i<8&&j<8&&k<8){
	    if(l[i]>r[j])rt[k++]=l[i++];
	    else rt[k++]=r[j++];
	}
	while(i<8&&k<8)rt[k++]=l[i++];
	while(j<8&&k<8)rt[k++]=r[j++];
}
void build(int u,int l,int r){
	tr[u].l=l,tr[u].r=r;
	tr[u].rnk.resize(8);
	if(l==r)return;
	int mid=(l+r)>>1;
	build(u<<1,l,mid),build(u<<1|1,mid+1,r);
}
void modify(int u,int pos,int k){
	if(tr[u].l==tr[u].r){
		tr[u].rnk[0]=k;
		return;
	}
	int mid=(tr[u].l+tr[u].r)>>1;
	if(pos<=mid)modify(u<<1,pos,k);
	else modify(u<<1|1,pos,k);
	pushup(tr[u].rnk,tr[u<<1].rnk,tr[u<<1|1].rnk);
}
vector<int> query(int u,int l,int r){
	if(tr[u].l>=l&&tr[u].r<=r){
		return tr[u].rnk;
	}
	int mid=(tr[u].l+tr[u].r)>>1;
	if(l>mid)return query(u<<1|1,l,r);
	if(r<=mid)return query(u<<1,l,r);
	vector<int>ans;
	ans.resize(8);
	pushup(ans,query(u<<1,l,r),query(u<<1|1,l,r));
	return ans;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n>>m;
	build(1,1,n);
	while(m--){
		char op;
		int l,r;
		cin>>op>>l>>r;
		if(op=='C')modify(1,l,r);
		else cout<<query(1,l,r)[7]<<'\n';
	}
	return 0;
}
```

---

## 作者：LBYYSM_123 (赞：2)

### 前语
做了 P2617 Dynamic Rankings，这一题改一改就能 AC。
### 思路
和前面提到的题一样，我们可以用**带修莫队+值域分块**，时间复杂度 $O(n^\frac{5}{3}+m\sqrt{n})$，卡一卡就能过了。
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int sqrtn,sqrtk;
int st[321*2],ed[321*2],bel[100001*2],cnt[100001*2],sum[321*2]; 
int a[100001*2];
int pos[100001*2];
int tmp[200001*2];
int she[100001*2];
int ans[100001*2];
int li=0;
int hash_work(int zhi){
	int nwei=lower_bound(tmp+1,tmp+li+1,zhi)-tmp;
	she[nwei]=zhi;
	return nwei;
} 
struct __ask{
	int l;
	int r;
	int gai;
	int id;
	bool operator<(const __ask &la)const{
		if(pos[l]==pos[la.l])
			if(pos[r]==pos[la.r])
				return gai<la.gai;
			else
				return r<la.r;
		else
			return l<la.l;
	} 
}qv[100001*2];
struct __modify{
	int wei;
	int zhi;
}ch[100001*2];
void add(int zhi){
	cnt[zhi]++;
	sum[bel[zhi]]++;
}
void sub(int zhi){
	cnt[zhi]--;
	sum[bel[zhi]]--;
}
void modify(int dang,int know){
	if(ch[know].wei>=qv[dang].l&&ch[know].wei<=qv[dang].r)
		sub(a[ch[know].wei]),add(ch[know].zhi);
	swap(a[ch[know].wei],ch[know].zhi);
}
int query(int k){
	int __ge=0,__cnt=0;
	while(__cnt+sum[__ge]<k){
		if(__ge>sqrtk) return 0;
		__cnt+=sum[__ge],__ge++;
	}
	for(int i=st[__ge];i<=ed[__ge];i++)
		if(__cnt+cnt[i]>=k)
			return i;
		else
			__cnt+=cnt[i];
}
signed main(){
	//freopen("P2617_2.in","r",stdin);
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	int sumask=0,sumgai=0;
	cin>>n>>m;sqrtn=pow(n,2.0/3.0);sqrtk=sqrt(100000*2);
	for(int i=1;i<=sqrtk;i++)
		st[i]=100000*2/sqrtk*(i-1)+1,ed[i]=100000*2/sqrtk*i;ed[sqrtk]=100000*2;
	for(int i=1;i<=sqrtk;i++)
		for(int j=st[i];j<=ed[i];j++)
			bel[j]=i;
	for(int i=1;i<=n;i++)
		a[i]=0,pos[i]=i/sqrtn+1,tmp[++li]=a[i];
	for(int i=1;i<=m;i++){
		char c;
		cin>>c;
		if(c=='Q'){
			sumask++;
			int l,r;
			cin>>l>>r;
			qv[sumask]={l,r,sumgai,sumask};
		}
		else{
			int x,y;
			cin>>x>>y;
			tmp[++li]=y;
			sumgai++;
			ch[sumgai]={x,y};
		}
	}
	sort(tmp+1,tmp+li+1);
	for(int i=1;i<=n;i++)
		a[i]=hash_work(a[i]);
	for(int i=1;i<=sumgai;i++)
		ch[i].zhi=hash_work(ch[i].zhi);
	sort(qv+1,qv+sumask+1);
	int l=1,r=0,now=0;
	for(int i=1;i<=sumask;i++){
		int linl=qv[i].l,linr=qv[i].r,linnow=qv[i].gai;
		while(l>linl) add(a[--l]);
		while(r<linr) add(a[++r]);
		while(l<linl) sub(a[l++]);
		while(r>linr) sub(a[r--]);
		while(now<linnow) modify(i,++now);
		while(now>linnow) modify(i,now--);
		ans[qv[i].id]=query((r-l+1)-8+1);
	} 
	for(int i=1;i<=sumask;i++)
		cout<<she[ans[i]]<<'\n';
	return 0;
} 
```

---

## 作者：f_hxr_ (赞：1)

考虑线段树。由于是单点修改，所以我们不需要懒标记标记。又由于我们需要区间查询，所以我们需要快速地合并区间信息。

~~我会树套树！~~

还记得我们是怎么求区间次大值的吗？

我们维护同时区间最大值和区间次大值，这样我们就能在区间合并的时候，拿子区间的最大值去更新父区间的最大值和次大值。

这题也一样。对于每个线段树结点，我们维护其对应区间的**前** $8$ 大的值。父结点的前 $8$ 大值就来自于子结点的前 $8$ 大值。

合并也非常，把子结点的区间拿出来，排个序即可。

注意到子结点的区间也是有序的，我们可以用归并排序的方法把两个区间合在一起。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=1e5+7;
int N,Q;
int dat[maxn<<2][9];
void pushup(int p){
	int pwp=1,qwq=1,tmp=1;
	while(tmp<=8)
		if(dat[p<<1][pwp]>=dat[p<<1|1][qwq])dat[p][tmp++]=dat[p<<1][pwp++];
		else dat[p][tmp++]=dat[p<<1|1][qwq++];
}
void modify(int p,int L,int R,int inx,int xx){
	if(L>=R){dat[p][1]=xx;return;}
	int mid=(L+R)>>1;
	if(inx<=mid)modify(p<<1,L,mid,inx,xx);
	else modify(p<<1|1,mid+1,R,inx,xx);
	pushup(p);
}
void query(int p,int L,int R,int ql,int qr,int* ret){
	if(ql<=L&&R<=qr){
		for(int i=1;i<=8;i++)ret[i]=dat[p][i];
		return;
	}
	int mid=(L+R)>>1;
	if(ql<=mid&&mid+1<=qr){
		int lhq[9],rmj[9];
		query(p<<1,L,mid,ql,qr,lhq);
		query(p<<1|1,mid+1,R,ql,qr,rmj);
		int pwp=1,qwq=1,tmp=1;
		while(tmp<=8)
			if(lhq[pwp]>=rmj[qwq])ret[tmp++]=lhq[pwp++];
			else ret[tmp++]=rmj[qwq++];
		return;
	}
	if(ql<=mid){
		int tmp[9];
		query(p<<1,L,mid,ql,qr,tmp);
		for(int i=1;i<=8;i++)ret[i]=tmp[i];
	}
	if(mid+1<=qr){
		int tmp[9];
		query(p<<1|1,mid+1,R,ql,qr,tmp);
		for(int i=1;i<=8;i++)ret[i]=tmp[i];
	}
}
int main(){
	scanf("%d %d",&N,&Q);
	while(Q--){
		char op;int a,b;
		scanf(" %c %d %d",&op,&a,&b);
		if(op=='C'){
			modify(1,1,N,a,b);
		}else if(op=='Q'){
			int ret[9];
			query(1,1,N,a,b,ret);
			printf("%d\n",ret[8]);
		}
	}
	return 0;
}
```

---

## 作者：Wf_yjqd (赞：1)

线段树板子咋就蓝了。。

------------

求动态区间第 $8$ 大，显然可以使用线段树。

$8$ 很小，所以可以对于每个节点维护对应区间的前 $8$ 大。

用两个子节点的前 $8$ 大更新每个节点。

复杂度 $\operatorname{O}(n\log l)$。

------------

码量很小，没啥好讲，适合练板子。

最优解第 $2$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=8e5+84;
namespace Sherry_fast_in_out{
    inline int read(){
        int x=0;
        char c=getchar();
        while(c<'0'||c>'9')
            c=getchar();
        while(c>='0'&&c<='9'){
            x=x*10+c-'0';
            c=getchar();
        }
        return x;
    }
    inline void write(register int x){
        if(x>9)
            write(x/10);
        putchar(x%10+'0');
        return ;
    }
}
using namespace Sherry_fast_in_out;
namespace SegmTre{
    struct Mx{
        int _[9];
    };
    struct Point{
        int l,r;
        Mx mx;
    }T[maxn];
    int top0,top1,ls,rs;
    Mx ans;
    inline Mx Merge(Mx l,Mx r){
        top0=top1=1;
        for(int i=1;i<=8;i++){
            if(l._[top0]>r._[top1]){
                ans._[i]=l._[top0];
                top0++;
            }
            else{
                ans._[i]=r._[top1];
                top1++;
            }
        }
        return ans;
    }
    inline void Init(int id,int l,int r){
        T[id].l=l;
        T[id].r=r;
        if(l==r)
            return ;
        Init(id<<1,l,l+r>>1);
        Init(id<<1|1,(l+r>>1)+1,r);
        T[id].mx=Merge(T[id<<1].mx,T[id<<1|1].mx);
        return ;
    }
    inline void Modify(int id,int p,int x){
        if(T[id].l==T[id].r){
            T[id].mx._[1]=x;
            return ;
        }
        Modify((p<=T[id].l+T[id].r>>1)?(id<<1):(id<<1|1),p,x);
        T[id].mx=Merge(T[id<<1].mx,T[id<<1|1].mx);
        return ;
    }
    inline Mx Query(int id,int l,int r){
        if(T[id].l>=l&&T[id].r<=r)
            return T[id].mx;
        int mid=T[id].l+T[id].r>>1;
        if(l<=mid&&mid<r)
            return Merge(Query(id<<1,l,r),Query(id<<1|1,l,r));
        if(l<=mid)
            return Query(id<<1,l,r);
        return Query(id<<1|1,l,r);
    }
}
int l,n,x,y;
char s[168];
int main(){
    l=read();
    n=read();
    SegmTre::Init(1,1,l);
    while(n--){
        scanf("%s",s);
        x=read();
        y=read();
        if(s[0]=='C')
            SegmTre::Modify(1,x,y);
        else{
            write(SegmTre::Query(1,x,y)._[8]);
            putchar('\n');
        }
    }
    return 0;
}
```


---

## 作者：LEE114514 (赞：0)

## 思路

考虑每次查询的都只是第 $8$ 大，又因为这是可以用结合律合并的信息，联想到开一颗线段树，每个线段树结点维护管辖范围内的前八大，合并时做归并排序。

## Code

```
#include <bits/stdc++.h>
using namespace std;
const int maxn=1e5+5;
struct node {
	int a[8];
	node(){
		memset(a,0,sizeof a);
	}
	node operator+(const node &tmp) const {
		node res;
		for(int i=0,p1=0,p2=0;i<8;++i) res.a[i]=(a[p1]>tmp.a[p2])?a[p1++]:tmp.a[p2++];
		return res;
	}
}trr[maxn<<2];
#define ls (p<<1)
#define rs (ls|1)
void upd(int p,int l,int r,int pos,int val){
	if(l==r){
		trr[p].a[0]=val;
		return;
	}
	int mid=(l+r)>>1;
	if(pos<=mid) upd(ls,l,mid,pos,val);
	else upd(rs,mid+1,r,pos,val);
	trr[p]=trr[ls]+trr[rs];
}
node qry(int p,int st,int ed,int l,int r){
	if(l<=st&&ed<=r) return trr[p];
	int mid=(st+ed)>>1;
	node res;
	if(l<=mid) res=res+qry(ls,st,mid,l,r);
	if(mid<r) res=res+qry(rs,mid+1,ed,l,r);
	return res;
}
int n,m,x,y;
char opt[2];
int main() {
	scanf("%d%d",&n,&m);
	while(m--){
		scanf("%s%d%d",opt,&x,&y);
		if(opt[0]=='C') upd(1,1,n,x,y);
		else printf("%d\n",qry(1,1,n,x,y).a[7]);
	}
}
```

---

## 作者：meyi (赞：0)

题目要求的东西即带修区间第 $k$ 大数，其中 $k$ 为小常数 $8$，故我们可以通过 $O(kn\log n)$ 的时间复杂度解决本道题。

考虑求区间 $\max$ 的线段树在干啥，它的每个节点维护了当前区间的 $\max$，类似的，在本题中，我们维护每个节点对应区间的前 $k$ 大数从小到大排序的结果，在合并两个信息的时候 $O(k)$ 归并即可，笔者使用了 `std::vector` `std::merge` 来完成这一操作。

注意要特判区间不足 $k$  个数的情况。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
//#pragma GCC optimize("Ofast,no-stack-protector,unroll-loops")
#define ALL(v) v.begin(),v.end()
#define For(i,_) for(int i=0,i##end=_;i<i##end;++i) // [0,_)
#define FOR(i,_,__) for(int i=_,i##end=__;i<i##end;++i) // [_,__)
#define Rep(i,_) for(int i=(_)-1;i>=0;--i) // [0,_)
#define REP(i,_,__) for(int i=(__)-1,i##end=_;i>=i##end;--i) // [_,__)
typedef long long ll;
typedef unsigned long long ull;
#define V vector
#define pb push_back
#define pf push_front
#define qb pop_back
#define qf pop_front
#define eb emplace_back
typedef pair<int,int> pii;
typedef pair<ll,int> pli;
#define fi first
#define se second
const int dir[4][2]={{-1,0},{0,1},{1,0},{0,-1}},inf=0x3f3f3f3f,mod=1e9+7;
const ll infl=0x3f3f3f3f3f3f3f3fll;
template<class T>inline bool ckmin(T &x,const T &y){return x>y?x=y,1:0;}
template<class T>inline bool ckmax(T &x,const T &y){return x<y?x=y,1:0;}
int init=[](){return cin.tie(nullptr)->sync_with_stdio(false),0;}();
const V<int> e;
template<class T,T(*merge)(const T &,const T &)>
struct SGT{
    int n;
    V<T>t;
    inline void resize(int n_){V<T>((n=n_)<<2).swap(t);}
    inline SGT(int n_=0){resize(n_);}
    inline void push_up(int p){t[p]=merge(t[p<<1],t[p<<1|1]);}
    void query(int p,int l,int r,int ql,int qr,T &ret){
        if(ql<=l&&r<=qr){ret=merge(ret,t[p]);return;}
        int mid=l+r>>1;
        if(ql<=mid)query(p<<1,l,mid,ql,qr,ret);
        if(qr>mid)query(p<<1|1,mid+1,r,ql,qr,ret);
    }
    inline T query(int l,int r){
        assert(0<=l),assert(l<=r),assert(r<n);
        T ret=e;
        query(1,0,n-1,l,r,ret);
        return ret;
    }
    void modify(int p,int l,int r,int k,const T &v){
        if(l==r){t[p]=v;return;}
        int mid=l+r>>1;
        k<=mid?modify(p<<1,l,mid,k,v):modify(p<<1|1,mid+1,r,k,v);
        push_up(p);
    }
    inline void modify(int k,const T& v){
        assert(0<=k),assert(k<n);
        modify(1,0,n-1,k,v);
    }
};
inline V<int> merge(const V<int> &x,const V<int> &y){
	V<int>z(x.size()+y.size());
	merge(ALL(x),ALL(y),z.begin(),greater<int>());
	if(z.size()>8)z.resize(8);
	return z;
}
int main(){
	int t_case=1;
//	scanf("%d",&t_case);
	while(t_case--){
		int m,n;
		scanf("%d%d",&n,&m);
		SGT<V<int>,merge>t(n);
		while(m--){
			char op;
			while(!isupper(op=getchar()));
			int x,y;
			scanf("%d%d",&x,&y),--x;
			if(op=='C')t.modify(x,{y});
			else{
				--y;
				V<int>ans=t.query(x,y);
				printf("%d\n",ans.size()<8?0:ans.back());
			}
		}
	}
	return 0;
}
```

---


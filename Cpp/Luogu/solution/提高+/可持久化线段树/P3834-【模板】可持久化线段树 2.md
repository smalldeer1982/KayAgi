# 【模板】可持久化线段树 2

## 题目背景

这是个非常经典的可持久化权值线段树入门题——静态区间第 $k$ 小。

**数据已经过加强，请使用可持久化权值线段树。同时请注意常数优化**。


## 题目描述

如题，给定 $n$ 个整数构成的序列 $a$，将对于指定的闭区间 $[l, r]$ 查询其区间内的第 $k$ 小值。


## 说明/提示

### 样例 1 解释

$n=5$，数列长度为 $5$，数列从第一项开始依次为$\{25957, 6405, 15770, 26287, 26465\}$。

- 第一次查询为 $[2, 2]$ 区间内的第一小值，即为 $6405$。
- 第二次查询为 $[3, 4]$ 区间内的第一小值，即为 $15770$。
- 第三次查询为 $[4, 5]$ 区间内的第一小值，即为 $26287$。
- 第四次查询为 $[1, 2]$ 区间内的第二小值，即为 $25957$。
- 第五次查询为 $[4, 4]$ 区间内的第一小值，即为 $26287$。


### 数据规模与约定

- 对于 $20\%$ 的数据，满足 $1 \leq n,m \leq 10$。
- 对于 $50\%$ 的数据，满足 $1 \leq n,m \leq 10^3$。
- 对于 $80\%$ 的数据，满足 $1 \leq n,m \leq 10^5$。
- 对于 $100\%$ 的数据，满足 $1 \leq n,m \leq 2\times 10^5$，$0\le a_i \leq 10^9$，$1 \leq l \leq r \leq n$，$1 \leq k \leq r - l + 1$。

## 样例 #1

### 输入

```
5 5
25957 6405 15770 26287 26465 
2 2 1
3 4 1
4 5 1
1 2 2
4 4 1
```

### 输出

```
6405
15770
26287
25957
26287
```

# 题解

## 作者：Euler_Pursuer (赞：377)

### [安利我的博客](https://www.cnblogs.com/LonecharmRiver/articles/9087536.html)

# 抛出问题

给定$N$个数（$int$范围内），一共$M$次询问，每次都要询问区间$[l,r]$的第$k$大的数。
其中$N,M,l,r$均不超过$2\times 10^5$，保证询问有答案。

# 解决问题

## 暴力法

显而易见，最暴力的办法就是区间排序然后输出排序后第$k$个数。最坏情况的时间复杂度是$O(nm\lg n)$，不超时才怪。

## 主席树（可持久化线段树）法

于是针对这个问题，新的数据结构诞生了，也就是主席树。

主席树本名可持久化线段树，也就是说，主席树是基于线段树发展而来的一种数据结构。其前缀"可持久化"意在给线段树增加一些历史点来维护历史数据，使得我们能在较短时间内查询历史数据，图示如下。

![主席树一览](https://cdn.luogu.com.cn/upload/pic/20234.png)

图中的橙色节点为历史节点，其右边多出来的节点是新节点（修改节点）。

下面我们来讲怎么构建这个数据结构。

## 主席树教程

- 要求：掌握线段树这个数据结构。
- 注意：一般主席树一类的题目，难的不是写主席树，而是主席树的运用。

### 主席树的点修改

不同于普通线段树的是主席树的左右子树节点编号并不能够用计算得到，所以我们需要记录下来，但是对应的区间还是没问题的。
```cpp
//节点o表示区间[l,r]，修改点为p，修改值根据题意设定（此处我们先不谈题目，只谈数据结构）
int modify(int o, int l, int r, int p)
{
    int oo = ++node_cnt;
    lc[oo] = lc[o]; rc[oo] = rc[o]; sum[oo] = sum[o] + 1;//新节点，这里是根据模板题来的
    if(l == r)//递归底层返回新节点编号，修改父节点的儿子指向
    {
        //sum[oo] = t;如果题目要求sum是加t的再这样弄，然后上面的+1就去掉
        return oo;
    }
    int mid = (l + r) >> 1;
    if(p <= mid) lc[oo] = modify(lc[oo], l, mid);
    else rc[oo] = modify(rc[oo], mid+1, r);
    //sum[oo] = sum[lc[oo]] + sum[rc[oo]];在该题中，不需要这样做，但是很多情况下是要这样更新的
    return oo;
}
```
至于主席树的区间修改，其实也不难，但是复杂度有点高，简单点的题目一般只有点修改，有时候区间修改可以转化为点修改（比如NOIP2012借教室，有区间修改的解法也有点修改的解法）。

### 主席树的询问（历史区间和）
```cpp
int ql, qr;//查询区间[l,r]
int query(int o, int l, int r)//节点o代表区间[l,r]
{
    int ans = 0, mid = ((l + r) >> 1);
    if(!o) return 0;//不存在的子树
    if(ql <= l && r <= qr) return sum[o];//区间包含返回区间值
    //都是线段树标准操作，只不过是左右子树多了一个记录而已
    if(ql <= mid) ans += query(lc[o], l, mid);
    if(qr > mid) ans += query(rc[o], mid+1, r);
    return ans;
    //点操作就不用说了
}
```

### 主席树复杂度分析

如果只按照上述做法去做的话，每次修改的时间复杂度是$O(\lg n)$，每次询问的复杂度也是$O(\lg n)$。

## 模板题教程

模板题就是主席树的典型例题，询问区间第$k$大。先不说区间$[l,r]$吧，就说说$[1,r]$怎么做。

### 模板题的[1,r]情况

由题意知道我们肯定要对区间进行排序，但是我们的排序不是每次询问才排序，是初始化就排序并离散化——针对数字较大但数据不大的情况下（具体见方法）。排序离散化完毕后，以离散化数组建主席树，设$i$属于区间$[1,n]$，对原数组的$[1,i]$区间的数做**统计**（例如下图，区间中按离散化数组顺序统计$1$的个数、$2$的个数、$3$的个数、$4$的个数、$8$的个数、$9$的个数），有序地插入节点到离散化数组的主席树中，记录好原数组每个节点对应的线段树起点，针对样例有几个示意图。注意，这里的橙色节点是新节点，与之前出现的那个图不一样。

- $[1,1]$的情况
![图示1](https://cdn.luogu.com.cn/upload/pic/20235.png)

- $[1,4]$的情况
![图示2](https://cdn.luogu.com.cn/upload/pic/20236.png)

情况以此类推。

我们按照上面的做法构建的主席树是为了方便我们查找第$k$小值。因为我们是以离散数组构建的主席树，那么从根节点出发，左子树部分的数必定不大于右子树部分的数。于是就可以将左儿子的节点个数$x$与$k$做比较，若$k\leq x$，则第$k$小值一定在左子树里面，若$x\leq k$，则第$k$小值一定在右子树里面，然后递归往下走，缩小范围。值得注意的是，前者递归时，$k$直接传下去即可，后者递归时，需要将$k$减去左子树的数的个数再传递这个$k$值。

例如我们查找$[1,4]$中第$2$小的值，图示如下，绿色节点为该值存在的区间位置。

![图示3](https://cdn.luogu.com.cn/upload/pic/20237.png)

需要注意的是，第二个绿色节点才是绿色根节点的左子树，因为**左子树表示的区间是靠前的那一半**。

方法总结如下：
1. 将原始数组复制一份，然后排序好，然后去掉多余的数，即将数据离散化。推荐使用C++的STL中的`unique`函数；
2. 以**离散化数组**为基础，建一个全$0$的线段树，称作基础主席树；
3. 对原数据中每一个$[1,i]$区间统计，有序地插入新节点（题目中$i$每增加$1$就会多一个数，仅需对主席树对应的节点增加$1$即可）；
4. 对于查询$[1,r]$中第$k$小值的操作，找到$[1,r]$对应的根节点，我们按照线段树的方法操作即可（这个根节点及其子孙构成的必定是一颗线段树）。

### 模板题的解决

现在我们真正来解决区间询问$[l,r]$的问题。

构建主席树的方法是没有问题的，问题正在于区间询问怎么写。其实，解决方案就是将主席树$[1,r]$减去主席树$[1,l-1]$就行了。其实这个原因并不难想，首先看到主席树的底层，全部是对数的统计。当主席树$[1,r]$减去主席树$[1,l-1]$时，统计也跟着减了，也就是说，现在统计记录的是$[l,r]$区间。

而我们不需要单独减，只需要边递归查询边减，具体见查询部分代码。
```cpp
//初始的u和v分别代表的是点l-1和点r，l和r分别表示线段树点代表的区间，初始的k如题
int query(int u, int v, int l, int r, int k)
{
    int ans, mid = ((l + r) >> 1), x = sum[lc[v]] - sum[lc[u]];
    //因为主席树是区间统计好了的，只要减一下即可，无需递归到叶子再处理
    if(l == r)//找到目标位置
        return l;
    if(x >= k) ans = query(lc[u], lc[v], l, mid, k);
    else ans = query(rc[u], rc[v], mid+1, r, k-x);//右子树记得改变k的值
    return ans;
}
```

### 模板题完整代码

至此，模板题也就解决了，下面是完整代码。注意，修改点定义为了全局变量。
```cpp
#include <cstdio>
#include <algorithm>
#define M 200010

using namespace std;

int node_cnt, n, m;
int sum[M<<5], rt[M], lc[M<<5], rc[M<<5];//线段树相关
int a[M], b[M];//原序列和离散序列
int p;//修改点

void build(int &t, int l, int r)
{
    t = ++node_cnt;
    if(l == r)
        return;
    int mid = (l + r) >> 1;
    build(lc[t], l, mid);
    build(rc[t], mid+1, r);
}

int modify(int o, int l, int r)
{
    int oo = ++node_cnt;
    lc[oo] = lc[o]; rc[oo] = rc[o]; sum[oo] = sum[o] + 1;
    if(l == r)
        return oo;
    int mid = (l + r) >> 1;
    if(p <= mid) lc[oo] = modify(lc[oo], l, mid);
    else rc[oo] = modify(rc[oo], mid+1, r);
    return oo;
}

int query(int u, int v, int l, int r, int k)
{
    int ans, mid = ((l + r) >> 1), x = sum[lc[v]] - sum[lc[u]];
    if(l == r)
        return l;
    if(x >= k) ans = query(lc[u], lc[v], l, mid, k);
    else ans = query(rc[u], rc[v], mid+1, r, k-x);
    return ans;
}

int main()
{
    int l, r, k, q, ans;
    scanf("%d%d", &n, &m);
    for(register int i = 1; i <= n; i += 1)
        scanf("%d", &a[i]), b[i] = a[i];
    sort(b+1, b+n+1);
    q = unique(b+1, b+n+1) - b - 1;
    build(rt[0], 1, q);
    for(register int i = 1; i <= n; i += 1)
    {
        p = lower_bound(b+1, b+q+1, a[i])-b;//可以视为查找最小下标的匹配值，核心算法是二分查找
        rt[i] = modify(rt[i-1], 1, q);
    }
    while(m--)
    {
        scanf("%d%d%d", &l, &r, &k);
        ans = query(rt[l-1], rt[r], 1, q, k);
        printf("%d\n", b[ans]);
    }
    return 0;
}
```

### 题目复杂度分析

题目一开始的离散化复杂度为$O(n\lg n)$，构建基础主席树复杂度为$O(n\lg n)$，统计并插入的复杂度是$O(n\lg n + n\lg n)=O(n\lg n)$，询问的复杂度是$O(m\lg n)$。复杂度总和就是$O((m+n)\lg n)$。

# 尾注

~~至今还不知道为什么叫主席树。。。~~

这道题目是离线的，也就是使用的静态主席树。在线修改的一类题目也不难，在此不作讲解，但是以后可能会另写博客。
主席树这个数据结构还是非常棒的，这也提醒我们应该学会创造性思维。
- 感谢LMH大佬的帮助；
- 感谢洛谷平台的帮助；
- 感谢那些写题解的大佬的帮助。

# 写在最后

感谢大家的关注和阅读。

本文章借鉴了少许思路，最后经过本人思考独立撰写此文章，如需转载，请注明出处。

---

## 作者：一扶苏一 (赞：138)

# 大家好，我是个毒瘤，我非常喜欢暴力数据结构，于是我就用莫队+分块过了这个题，而且跑的贼快，甚至跑到了最优解的第二页

## Solution

发现这个题静态查询资瓷离线，于是考虑莫队。

在这里简单介绍一下莫队：

将所有询问离线后，对原序列分块。按照左端点所在块单调不降排序。当左端点所在块相同时，按照右端点单调排序。

然后用头尾指针指向当前的区间，维护区间内的信息。每两个查询间暴力移动指针。移动指针时每移动一下就维护一次答案。

考虑这么做的复杂度：一共有 $O(\sqrt{n})$个块，每个块内右端点单调，所以一个块内右端点最多移移动 $O(n)$ 个位置，于是右端点移动 $O(n~\sqrt{n})$个位置。同理，左端点在一个块内最多移动 $O(\sqrt{n})$ 次，每次最多移动 $O(\sqrt{n})$ 个位置，块内移动次数是 $O(n)$ 。一共有 $O(\sqrt{n})$ 个块，于是左端点移动 $O(n~\sqrt{n})$ 个位置。于是莫队不计修改和查询的总复杂度为 $O(n~\sqrt{n})$。

维护答案时，最显然的想法是用树状数组维护前缀和，这样单次修改复杂度 $O(\log n)$ ，查询时在树状数组上二分，复杂度 $O(\log n)$ 。修改总复杂度 $O(n~\sqrt{n}~\log n)$ ，查询的总复杂度 $O(m~\log n)$ 。于是发现修改的复杂度过高，查询的复杂度完全不需要这么低，那么可以用分块将修改复杂度将至 $O(1)$ ，查询复杂度升高至 $O(\sqrt{n})$ 。具体的，离散化后按照权值分块，每个块维护块内元素出现总次数。查询时暴力从第一个块开始扫，累加元素出现总次数，当加入一个块总次数大于 $k$ 时在块内暴力找位置，总复杂度 $O(n~\sqrt n)$。只开O2最慢的点250ms

## Code

```cpp
#include <cmath>
#include <cstdio>
#include <algorithm>
#ifdef ONLINE_JUDGE
#define freopen(a, b, c)
#endif
#define rg register
#define ci const int
#define cl const long long

typedef long long int ll;

namespace IPT {
	const int L = 10000000;
	char buf[L], *front=buf, *end=buf;
	char GetChar() {
		if (front == end) {
			end = buf + fread(front = buf, 1, L, stdin);
			if (front == end) return -1;
		}
		return *(front++);
	}
}

template <typename T>
inline void qr(T &x) {
	rg char ch = IPT::GetChar(), lst = ' ';
	while ((ch > '9') || (ch < '0')) lst = ch, ch=IPT::GetChar();
	while ((ch >= '0') && (ch <= '9')) x = (x << 1) + (x << 3) + (ch ^ 48), ch = IPT::GetChar();
	if (lst == '-') x = -x;
}

template <typename T>
inline void ReadDb(T &x) {
	rg char ch = IPT::GetChar(), lst = ' ';
	while ((ch > '9') || (ch < '0')) lst = ch, ch = IPT::GetChar();
	while ((ch >= '0') && (ch <= '9')) x = x * 10 + (ch ^ 48), ch = IPT::GetChar();
	if (ch == '.') {
		ch = IPT::GetChar();
		double base = 1;
		while ((ch >= '0') && (ch <= '9')) x += (ch ^ 48) * ((base *= 0.1)), ch = IPT::GetChar();
	}
	if (lst == '-') x = -x;
}

namespace OPT {
	char buf[120];
}

template <typename T>
inline void qw(T x, const char aft, const bool pt) {
	if (x < 0) {x = -x, putchar('-');}
	rg int top=0;
	do {OPT::buf[++top] = x % 10 + '0';} while ( x /= 10);
	while (top) putchar(OPT::buf[top--]);
	if (pt) putchar(aft);
}

const int maxn = 200010;

int n, m;
int belong[maxn], MU[maxn], temp[maxn], bk[maxn], block[maxn], rmp[maxn], lc[maxn];

struct Ask {
	int l, r, id, ans, k;
	inline bool operator<(const Ask &_others) const {
		if (belong[this->l] != belong[_others.l]) return this->l < _others.l;
		if (belong[this->l] & 1) return this->r < _others.r;
		return this->r > _others.r;
	}
};
Ask ask[maxn];

void init_hash();
void add(ci&);
void dlt(ci&);

inline bool cmp(const Ask &_a,const Ask &_b) {
	return _a.id < _b.id;
}

int main() {
	freopen("1.in", "r", stdin) ;
	qr(n); qr(m);
	for (rg int i = 1, sn = sqrt(n); i <= n; ++i) if((belong[i] = i / sn) != belong[i-1]) lc[belong[i]] = i;
	for (rg int i = 1; i <= n; ++i) qr(MU[i]);
	init_hash();
	for (rg int i = 1; i <= m; ++i) {
		qr(ask[i].l); qr(ask[i].r); qr(ask[i].k); ask[i].id = i;
	}
	std::sort(ask + 1, ask + 1 + m);
	int prel = ask[1].l, prer = prel - 1;
	for (rg int i = 1; i <= m; ++i) {
		int l = ask[i].l, r = ask[i].r;
		while (prel < l) dlt(prel++);
		while (prel > l) add(--prel);
		while (prer > r) dlt(prer--);
		while (prer < r) add(++prer);
		int _cnt = 0, cur = 0;
		while (_cnt + block[cur] < ask[i].k) _cnt+=block[cur++];
		for (rg int j = lc[cur]; ; ++j) if((_cnt += bk[j]) >= ask[i].k) {
			ask[i].ans = j; break;
		}
	}
	std::sort(ask + 1, ask + 1 + m, cmp);
	for (rg int i = 1; i <= m; ++i) qw(rmp[ask[i].ans], '\n', true);
	return 0;
}

void init_hash() {
	for (rg int i = 1; i <= n; ++i) temp[i] = MU[i];
	std::sort(temp + 1, temp + 1 + n);
	int *ed = std::unique(temp + 1, temp + 1 + n);
	for (rg int i = 1; i <= n; ++i) {
		int k = MU[i];
		rmp[MU[i] = std::lower_bound(temp + 1, ed, MU[i]) - temp] = k;
	}
}

inline void dlt(ci &k) {
	--bk[MU[k]];
	--block[belong[MU[k]]];
}

inline void add(ci &k) {
	++bk[MU[k]];
	++block[belong[MU[k]]];
}
```

对了顺便把主席树代码放上防止有人喷我不自觉

```cpp
#include <cstdio>
#include <algorithm>
#ifdef ONLINE_JUDGE
#define freopen(a, b, c)
#endif
#define rg register
#define ci const int
#define cl const long long

typedef long long int ll;

namespace IPT {
	const int L = 1000000;
	char buf[L], *front=buf, *end=buf;
	char GetChar() {
		if (front == end) {
			end = buf + fread(front = buf, 1, L, stdin);
			if (front == end) return -1;
		}
		return *(front++);
	}
}

template <typename T>
inline void qr(T &x) {
	rg char ch = IPT::GetChar(), lst = ' ';
	while ((ch > '9') || (ch < '0')) lst = ch, ch=IPT::GetChar();
	while ((ch >= '0') && (ch <= '9')) x = (x << 1) + (x << 3) + (ch ^ 48), ch = IPT::GetChar();
	if (lst == '-') x = -x;
}

template <typename T>
inline void ReadDb(T &x) {
	rg char ch = IPT::GetChar(), lst = ' ';
	while ((ch > '9') || (ch < '0')) lst = ch, ch = IPT::GetChar();
	while ((ch >= '0') && (ch <= '9')) x = x * 10 + (ch ^ 48), ch = IPT::GetChar();
	if (ch == '.') {
		ch = IPT::GetChar();
		double base = 1;
		while ((ch >= '0') && (ch <= '9')) x += (ch ^ 48) * ((base *= 0.1)), ch = IPT::GetChar();
	}
	if (lst == '-') x = -x;
}

namespace OPT {
	char buf[120];
}

template <typename T>
inline void qw(T x, const char aft, const bool pt) {
	if (x < 0) {x = -x, putchar('-');}
	rg int top=0;
	do {OPT::buf[++top] = x % 10 + '0';} while ( x /= 10);
	while (top) putchar(OPT::buf[top--]);
	if (pt) putchar(aft);
}

const int maxn = 200010;
const int maxt = 4000010;

int n, m, sz;
int MU[maxn], temp[maxn], rmp[maxn];

struct Tree {
	Tree *ls, *rs;
	int l, r, v, k;
	inline void update() {
		this->v = 0;
		if(this->ls) this->v = this->ls->v;
		if(this->rs) this->v += this->rs->v;
	}
};
Tree *pool[maxt], qwq[maxt], *rot[maxn];
int pltp;

void init_hash();
void buildpool();
void buildzero(Tree*, ci, ci);
void build(Tree*, Tree*, ci, ci, ci);
int ask(Tree*, Tree*, ci);

int main() {
	freopen("1.in", "r", stdin);
	qr(n); qr(m);
	for (rg int i = 1; i <= n; ++i) qr(MU[i]);
	init_hash();
	buildpool();
	rot[0] = pool[pltp--];
	buildzero(rot[0], 1, sz);
	for (rg int i = 1; i <= n; ++i) {
		rot[i] = pool[pltp--];
		build(rot[i-1], rot[i], 1, sz, MU[i]);
	}
	
	int a, b, c;
	while(m--) {
		a = b = c = 0;
		qr(a); qr(b); qr(c);
		qw(rmp[ask(rot[a-1], rot[b], c)], '\n', true);
	}
	return 0;
}

void init_hash() {
	for (rg int i = 1; i <= n; ++i) temp[i] = MU[i];
	std::sort(temp + 1, temp + 1 + n);
	int *ed = std::unique(temp + 1, temp + 1 + n);
	for (rg int i = 1; i <= n; ++i) {
		int _tp = MU[i];
		rmp[MU[i] = std::lower_bound(temp + 1, ed, MU[i]) - temp] = _tp;
	}
	sz = ed - temp - 1;
}

void buildpool() {
	for (rg int i = 0; i < maxt; ++i) pool[i] = qwq + i;
	pltp = maxt - 1;
}

void buildzero(Tree *u, ci l, ci r) {
	u->l = l; u->r = r;
	if (l == r) return;
	int mid = (l + r) >> 1;
	if (l <= mid) {
		u->ls = pool[pltp--];
		buildzero(u->ls, l, mid);
	}
	if (mid < r) {
		u->rs = pool[pltp--];
		buildzero(u->rs, mid+1, r);
	}
}

void build(Tree *pre, Tree *u, ci l, ci r, ci v) {
	u->l = l; u->r = r;
	if (l == r) {u->v = pre->v + 1;return;}
	int mid = (l + r) >> 1;
	if (v <= mid) {
		u->rs = pre->rs;
		u->ls = pool[pltp--];
		build(pre->ls, u->ls, l, mid, v);
	} else {
		u->ls = pre->ls;
		u->rs = pool[pltp--];
		build(pre->rs, u->rs, mid + 1, r, v);
	}
	u->update();
}

int ask(Tree *pre, Tree *u, ci k) {
	if(u->l == u->r) return u->l;
	int _v = u->ls ? u->ls->v - pre->ls->v : 0;
	return _v < k ? ask(pre->rs, u->rs, k - _v) : ask(pre->ls, u->ls, k);
}
```

## Summary

### 我爱暴力数据结构！

---

## 作者：星星之火 (赞：106)

关于一个很强的操作，整体二分

最基本的运用就是洛谷的主席树模板——静态区间的k大

下面说一说思路

所谓整体，就是所有的询问全部一起处理，这是因为如果单个单个二分的话无疑会超时。那么如何可以做到这点呢？首先对于数组中原来的数和询问，把它们封装在同样的结构体里。这个结构体包括x,y,k,id,type

对于数组中原来的数，通过观察程序可以发现y,k是没有任何作用的。x代表的是这个位置的数的大小，id表示数的位置，type是它的类型（不是询问）

对于询问，x，y，k表示在区间x~y中查询第k小的数，id表示的是询问的编号，type是它的类型（询问）

那么接下来我们要对这些封装好的什么什么东西一起二分，这些东西我们存在一个数组里，在接下来的描述中我们管它叫队列

在solve函数中，ql,ql分别表示当前处理的队列的子列的左端点和右端点。l，r就是我们二分的权值。首先判断，若是ql>qr就直接return。之后判断l是不是与r相等，若是相等说明找到了，此时对于目前处理的队列中所有询问而言结果都是l（或r）。

如果以上都没有满足，那么我们还需要继续二分下去。mid=(l+r)>>1，那么考虑算出当前维护的队列中所有type==1的类型的x值小于等于mid的划分到左边，同时统计个数。而如果大于mid就划分到右边。怎么统计个数呢？我们每次递归是使用树状数组，而每次结束时又把它给清空，（如果这里可以离散化的话好像会很完美，但可不可以我没有去想。。。因为这道题确实只是入门题。当然主要是因为我是蒟蒻的缘故）。对于type==2的元素而言，直接树状数组统计x，y之间的比mid小的数的个数，然后和k比个大小，同样把它划分成左右两边

相信没学过的人有疑问了，为什么我们要划分成左右两边呢？首先我们每次递归处理的是一个子问题，划分是处理子问题的一个大前提。其次，我们得知划分到右边的无论如何不会影响左边的处理，可以理解为对左边不存在贡献。

递归的最后我们只需要修改队列分出左右就好了

值得再次提醒的是，l，r，mid使我们二分的数值，请不要和ql，qr的含义弄混

下面附上代码

```cpp
#include<bits/stdc++.h>
using namespace std;

const int oo=1e9+7;
const int maxn=2e5+15;
int n,m,cnt;
int ans[maxn],tree[maxn]; 
struct NODE
{
	int x;int y;int k;
	int id;int type;
}q[maxn<<1],q1[maxn<<1],q2[maxn<<1];
void add(int x,int y)
{
	while (x<=n)
	{
		tree[x]+=y;
		x+=x&(-x);
	}
}
int sum(int x)
{
	int ans=0;
	while (x)
	{
		ans+=tree[x];
		x-=x&(-x);
	}
	return ans;
}
void solve(int ql,int qr,int l,int r)
{
	if (ql>qr) return;
	if (l==r){
		for (int i=ql;i<=qr;i++)
		if (q[i].type==2) ans[q[i].id]=l;
		return;
	}
	int mid=(l+r)>>1;
	int p1=0,p2=0;
	for (int i=ql;i<=qr;i++)
    if (q[i].type==1){
    	if (q[i].x<=mid){
    		add(q[i].id,1);
    		q1[++p1]=q[i];
		}
		else q2[++p2]=q[i];
	}
	else {
		int res=sum(q[i].y)-sum(q[i].x-1);
		if (res>=q[i].k) q1[++p1]=q[i];
		else {
			q[i].k-=res;
			q2[++p2]=q[i];
		}
	}
	for (int i=1;i<=p1;i++) if (q1[i].type==1) add(q1[i].id,-1);
	for (int i=1;i<=p1;i++)
	q[i+ql-1]=q1[i];
	for (int i=1;i<=p2;i++)
	q[i+ql+p1-1]=q2[i];
	solve(ql,ql+p1-1,l,mid);
	solve(ql+p1,qr,mid+1,r);
}
int main()
{
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n;i++)
	{
		int x;
		scanf("%d",&x);
		q[++cnt]=(NODE){x,1,oo,i,1};
	}
	for (int i=1;i<=m;i++)
	{
		int x,y,k;
		scanf("%d%d%d",&x,&y,&k);
		q[++cnt]=(NODE){x,y,k,i,2};
	}
	solve(1,cnt,-oo,oo);
	for (int i=1;i<=m;i++)
	printf("%d\n",ans[i]);
	return 0;
}
```

---

## 作者：NaCly_Fish (赞：39)

这题还可以线段树合并来做，然而并没有题解，于是来写一篇吧。


线段树合并 与 可持久化线段树其实用到了类似的思想，就是多个线段树共用，降低空间复杂度。

这里所谓线段树合并，就是把两个线段树对应节点的信息合并，并返回新线段树的根（为了防止一些奇怪的问题，所以要新建节点）。而且线段树合并一般用于权值线段树（也就是类似此题的情况），可以证明每次合并均摊 $\text O(\log n)$。

那么来考虑一下怎么合并两个线段树：  

- 如果合并的两棵线段树（有可能是子树）有一个根为空，显然不需要继续合并，直接返回另一个的根  

- 如果两棵线段树都不为空，新建一个节点，信息为这两个节点的合并，然后递归合并左右子树  

写成代码，就是这样的：  
其中 `ls` 和 `rs` 分别表示左右儿子。
```cpp
int merge(int u,int v){
    if(!u||!v) return u|v;
    int x = ++cnt;
    sum[x] = sum[u]+sum[v];
    ls[x] = merge(ls[u],ls[v]);
    rs[x] = merge(rs[u],rs[v]);
    return x;
}

```
那么只需要开 $n$ 个动态开点线段树，然后用前缀和的方法，把 $[1,i]$ 的信息合并到第 $i$ 棵线段树上。

要查询 $[l,r]$ 的第 $k$ 大，用第 $r$ 棵对应减去第 $l-1$ 棵得到的线段树上二分即可。

总时间复杂度 $\Theta((n+q)\log n)$。

代码：  
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#define reg register
#define ll long long
#define N 200003
#define M 7000003
#define mid ((l+r)>>1)
using namespace std;

int rt[N],a[N],b[N];
int ls[M],rs[M],sum[M];
int n,m,q,cnt;

void insert(int &u,int l,int r,int pos){
    if(!u) u = ++cnt;
    sum[u]++;
    if(l==r) return;
    if(pos<=mid) insert(ls[u],l,mid,pos);
    else insert(rs[u],mid+1,r,pos);
}

int merge(int u,int v){
    if(!u||!v) return u|v;
    int x = ++cnt;
    sum[x] = sum[u]+sum[v];
    ls[x] = merge(ls[u],ls[v]);
    rs[x] = merge(rs[u],rs[v]);
    return x;
}

int query(int u,int v,int l,int r,int k){
    if(l==r) return l;
    int s = sum[ls[v]]-sum[ls[u]];
    if(k<=s) return query(ls[u],ls[v],l,mid,k);
    return query(rs[u],rs[v],mid+1,r,k-s);
}

int main(){
    int l,r,k,x;
    scanf("%d%d",&n,&q);
    for(reg int i=1;i<=n;++i){
        scanf("%d",&a[i]);
        b[i] = a[i];
    }
    sort(b+1,b+1+n);
    m = unique(b+1,b+1+n)-b-1;
    for(reg int i=1;i<=n;++i) insert(rt[i],1,m,lower_bound(b+1,b+1+m,a[i])-b);
    for(reg int i=2;i<=n;++i) rt[i] = merge(rt[i],rt[i-1]);
    while(q--){
        scanf("%d%d%d",&l,&r,&k);
        x = query(rt[l-1],rt[r],1,m,k);
        printf("%d\n",b[x]);
    }
    return 0;
}
```

---

## 作者：Xx_queue (赞：17)

这两天学习了主席树，基本上搞懂了主席树是怎么操作的

---

主席树，是一种可持久化线段树。最简单的操作就是维护静态区间第 $k$ 小

主席树通过维护历史版本，实现查询区间的有关操作

---

## 主席树的原理

假设现在有这么一个序列：$4, 1, 3, 5, 2$

问如何求出区间 $[1,3]$ 内大小为第二的数？

~~利用大眼观察法，很显然是3~~

那么让计算机去怎么实现呢？~~它又没有眼睛~~

对于这个序列，我们可以先建一颗空的权值线段树，命名为“树 $0$ ”（方便后面的使用），如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/gey4wrz8.png)

别告诉我你不知道什么是权值线段树，自己去百度；

现在序列里面第一个数是 $4$，我们往树里面插入一个 $4$ ，因为要保留历史版本，所以我们对 $4$ 这个数新建一颗线段树，命名为“树 $1$ ”，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/e239h0xp.png)

为什么是这样呢？

$1\le 4 \le5$，故区间 $[1,5]++$;

$4\le 4 \le5$，故区间 $[4,5]++$;

$4\le 4 \le4$，故区间 $[4,4]++$;

其他的还是 $0$ ;

懂了没有。。。

继续插入第二个数 $1$ ，建成“树 $2$ ” ，这里不解释了

![](https://cdn.luogu.com.cn/upload/image_hosting/89dyw9pb.png)

再插入第三个数 $3$，建成“树 $3$ ”

![](https://cdn.luogu.com.cn/upload/image_hosting/ejwbdazy.png)



OK！现在我们就已经可以求出 $[1,3]$ 内的大小为第二大的数了

递归操作查询排名应该都会吧？

不会的看这里：

 - 进入 $[1,5]$ 节点，我们发现他的左儿子的子树个数为$2$ ， $2\le k $ $(k=2)$，于是进入$[1,3]$节点;

 - 然后我们发现 $[1,3]$ 节点的左儿子子树个数$1 < k$ $(k=2)$，于是进入 $[3,3]$ 节点；

 - 此时我们把 $k$ 更新为 $1$ ($2-1=1$);

 - 走到头了，于是就返回 $3$ ，所以答案就是 $3$ ，也就是原来的序列区间 $[1,3]$ 的第 $2$ 小就是 $3$

现在你明白了主席树是怎么操作了的吧？

---

## 疑问

但是有一个问题：上面我们求的是区间$[1,r]$的第 $k$ 大的数

同理，区间 $[1,r]$ ($r\in$ $[1,n]$ , $r \in N$)的第 $k$ 大数我们也就会求了

那怎么求区间 $[l,r]$ 的第 $k$ 大数呢？

举个例子，求区间$[2,3]$的第 $k$ 大数

我们拿建出来的“树 $3$ ”减掉“树 $1$ ”后，再进行如上操作就可以了

这也就是前缀和思想

所以对于区间$[l,r]$ 我们拿“树 $r$ ”减去“树 $(l-1)$ ”，再query一下就可以求得答案了

还有一个问题：我每个数都开一个线段树来存，空间不会炸掉吗？

所以主席树是这样操作的：

 - 每插入一个数 $x$ ，只有 $[x,x]$ 到 $[1,n]$ 一条链上的点会更新操作，所以我们可以共用一些点，就OK了，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/ym4n9hnp.png)

---

## 例题与代码

那么主席树就介绍完了，具体实现给个例题让大家看看，还有不懂得可以再参考一下他人的博客

[例题:【模板】可持久化线段树1(主席树)](https://www.luogu.com.cn/problem/P3834)

```cpp
#include <bits/stdc++.h>
#define N (200000+5)
#define ls ch[rt][0]
#define rs ch[rt][1]
#define vl ch[vs][0]
#define vr ch[vs][1]
using namespace std;
int n,m,q;
int rt[N],ch[N<<5][2],tot,val[N<<5];//rt:每个线段树的根，ch：左右儿子，tot：编号总数，val：权值
int a[N],b[N];//a：原数组，b：离散化数组
inline int query(int x){//离散化
	return lower_bound(b+1,b+m+1,x)-b;//离散化
}
inline void update(int &rt,int vs,int l,int r,int k){//更新，新建一棵树
	rt=++tot;//新树的根节点为tot++
	ls=vl,rs=vr;//左右儿子都是历史版本的左右儿子
	val[rt]=val[vs]+1;//新加入一个数，rt的权值++
	if(l==r) return;//叶子节点，return
	int mid=(l+r)>>1;//mid为分割区间的中点
	if(k<=mid) update(ls,vl,l,mid,k);//k<=mid，k在左儿子
	else update(rs,vr,mid+1,r,k);//否则k在右儿子
}
inline int query(int rt,int vs,int l,int r,int k){//询问第k大
	if(l==r) return l;//找到了（在叶子节点），return
	int mid=(l+r)>>1;
	int v=val[vl]-val[ls];
        //这里只用算一下k在不在左儿子就行了，不再左儿子就肯定在右儿子
	//这里用当前版本减去历史版本就是类似“前缀和”操作
	if(k<=v) return query(ls,vl,l,mid,k);//在左儿子，继续找
	else return query(rs,vr,mid+1,r,k-v);//不在左儿子，找右儿子，并把k减去左边所有的个数
}
int main(){
	scanf("%d%d",&n,&q);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]),b[i]=a[i];//读入
	sort(b+1,b+n+1);//离散化数组先排序
	m=unique(b+1,b+n+1)-b-1;//离散化
	for(int i=1;i<=n;i++){
		update(rt[i],rt[i-1],1,n,query(a[i]));
        //一个节点一个节点的插入；
	//这里对rt进行引用（&），相当于rt[i]=update(rt[i],rt[i-1],1,n,query(a[i]));
	}
	while(q--){
		int l,r,k;
		scanf("%d%d%d",&l,&r,&k);
		printf("%d\n",b[query(rt[l-1],rt[r],1,n,k)]);//求解静态区间第k小，注意是l-1和r
	}
	return 0;
}

```

---

## 作者：Bronya18C (赞：17)

# ~~专门搞破坏~~
---
作为一名新初一的孩子，我还不会主席树，只能用划分树。

划分树适用于静态查询区间第K大数，时间复杂度为（M*logN），空间比主席树好一点。

---
# 划分树
划分树，类似线段树，主要用于求解某个区间的第k 大元素（时间复杂度log(n)），快排本也可以快速找出，但快排会改变原序列，所以每求一次都得恢复序列。

　划分树，顾名思义是将n 个数的序列不断划分，根结点就是原序列，左孩子保存父结点所有元素排序后的一半，右孩子也存一半，也就是说排名1 -> mid的存在左边，排名(mid+1) -> r 的存在右边，同一结点上每个元素保持原序列中相对的顺序。
 
 当然，一般不会说每个结点开个数组存数，经观察，每一层都包含原本的n 个数，只是顺序不同而已，所以我们可以开val[20][N]来保存，也就是说共20层，每一层N个数。

　　我们还需要一个辅助数组num，num[i]表示i 前面有多少数进入左孩子（i 和i 前面可以弄成本结点内也可以是所有，两种风格不同而已，下面采取的是本结点内），和val一样，num也开成num[20][N]，来表示每一层，i 和i 前面（本结点）有多少进入左孩子。

　　第一层：1 进入左孩子，num[1]=1，5 进入右孩子，num[2]=1，...，num[8]=4。

　　第二层：5 进入左孩子，num[5]=1，6 进入右孩子，num[6]=1，...，num[8]=2。

　　建图时就是维护每一层val[]和num[]的值就可以了。
  以上摘抄于此[blog](https://www.cnblogs.com/hchlqlz-oj-mrj/p/5744308.html)
  
---
# 代码：
---
```
#include<stdio.h>
#include<string.h>
#include<algorithm>
using namespace std;
long long a[200010];       
long long sorted[200010]; 
long long num[50][200010];
long long val[50][200010];
void build(long long l,long long r,long long ceng) {
  if(l==r) return ;
 long long mid=(l+r)/2,isame=mid-l+1;
   for(long long i=l;i<=r;i++) if(val[ceng][i]<sorted[mid]) isame--;
  long long ln=l,rn=mid+1; 
 for(long long i=l;i<=r;i++)
   {
     if(i==l) num[ceng][i]=0;
     else num[ceng][i]=num[ceng][i-1];
     if(val[ceng][i]<sorted[mid] || val[ceng][i]==sorted[mid]&&isame>0)
     {
       val[ceng+1][ln++]=val[ceng][i];
       num[ceng][i]++;
       if(val[ceng][i]==sorted[mid]) isame--;
     }
     else
     {
       val[ceng+1][rn++]=val[ceng][i];
 }
   }
   build(l,mid,ceng+1);
   build(mid+1,r,ceng+1);
 }
 
 
 long long look(long long ceng,long long sl,long long sr,long long l,long long r,long long k)
 {
   if(sl==sr) return val[ceng][sl];
   long long ly; 
   if(l==sl) ly=0;
  else ly=num[ceng][l-1];
   long long tolef=num[ceng][r]-ly;
  if(tolef>=k)
   {
     return look(ceng+1,sl,(sl+sr)/2,sl+ly,sl+num[ceng][r]-1,k);
   }
   else
   {
     long long lr = (sl+sr)/2 + 1 + (l-sl-ly);
     return look(ceng+1,(sl+sr)/2+1,sr,lr,lr+r-l+1-tolef-1,k-tolef);
	}
}
int main()
{
   	long long n,m,l,r,k;
   	scanf("%lld%lld",&n,&m);
	for(long long i=1;i<=n;i++)
    {
       scanf("%lld",&val[0][i]);
       sorted[i]=val[0][i];
    }
    sort(sorted+1,sorted+n+1);
    build(1,n,0);
    while(m--)
    {
    	scanf("%lld%lld%lld",&l,&r,&k);
    	printf("%lld\n",look(0,1,n,l,r,k));
   	}
  return 0;
}
```
---

---

## 作者：lgswdn_SA (赞：12)

### Wavelet Matrix

考虑这样的一个结构（以下序列全部都是 0-index）：

- 对于原序列 $a$，设其最高位是 $H$。令 $c_{H+1,i}=a_i$。然后我们从高到低遍历每一位 $x$。

- 对于 $x$，我们先将 $c_{x}$ 继承自 $c_{x+1}$，然后我们记录 $c_x$ 每个元素二进制最高位 $x$ 的值 $b_{x,i}$。
- 然后我们对原来的 $c_x$ 做一次变换得到新的 $c_{x}$：把第 $x$ 位为 $0$ 的元素挪到左边，然后第 $x$ 位为 $1$ 的元素挪到右边。设 $p_x$ 表示这一位 $0$ 的个数。
- eg：$a=[1,3,2,0]$，我们先得到 $b_1=[0,1,1,0]$，然后得到 $c_1=[1,0,3,2]$，$p_1=2$；然后我们得到 $b_0=[1,0,1,0]$，然后得到 $c_0=[0,2,1,3]$，$p_0=2$。注意 $c$ 并不是一个有序结构。

$O(n\log V)$ 构建这样的结构是简单的。考虑如何 $O(\log V)$ 查询 $k$ 小值。

- 从高往低遍历每一位 $x$。
- 考虑 $i\in[l,r]$ 中 $b_{x,i}=0$ 的个数 $w$。如果 $w<k$ 那么意味着这一位必须是 $0$，那么下一层我们只需要在满足 $b_{x,i}=0$ 的前缀里面问询即可。具体而言，设 $l'$ 表示这一层下标 $<l$ 的 $b_{x,j}=0$ 的个数，$r'$ 表示这一层下标 $\le r$ 的 $b_{x,j}=0$ 的个数，那么只需要递归到下一层时将 $[l,r]$ 替换成 $[l',r'-1]$ 即可。
- 如果 $w>k$ 那么意味着这一位必须是 $1$，那么我们贡献给答案，再将 $k$ 减掉 $w$ 后递归进满足 $b_{x,i}=1$ 的后缀里面问询即可。具体而言，设 $l'$ 表示这一层下标 $<l$ 的 $b_{x,j}=1$ 的个数，$r'$ 表示这一层下标 $\le r$ 的 $b_{x,j}=1$ 的个数，那么只需要递归进到下一层时将 $[l,r]$ 替换成 $[l'+p_x,r'+p_x-1]$ 即可。

注意到我们并不需要对于每个 $x$ 都维护出 $c$，只需在构建时动态维护变换即可。而 $b$ 的维护可以使用一个手写的 bitset（支持单点修改，以及 $O(1)$ 区间查 popcount）。空间复杂度 $O(\frac{n\log V}{w})$。

实现部分参考自 https://zhuanlan.zhihu.com/p/590974585 （如在构建 Wavelet Matrix 时使用 `std::stable_partition` 等，同时该文章内有引用自 https://miti-7.hatenablog.com/entry/2018/04/28/152259 的一些视觉化的演示）。

```
const int N=(1<<18)+5,H=29;
int n,a[N],m;

struct bst {
  ull b[N/64+5],c[N/64+5]; int m;
  #define msk(i) ((1ull<<((i)&63))-1)
  void init(int n) {m=n/64+1;}
  void set(int i) {b[i>>6]|=1ull<<(i&63);}
  bool get(int i) {return (b[i>>6]>>(i&63))&1;}
  int p1(int i) {return c[i>>6]+popcnt(b[i>>6]&msk(i&63));}
  int p0(int i) {return i-c[i>>6]-popcnt(b[i>>6]&msk(i&63));}
  int s1(int l,int r) {return p1(r+1)-p1(l);}
  int s0(int l,int r) {return p0(r+1)-p0(l);}
  void getcnt() {rep(i,1,m-1) c[i]=c[i-1]+popcnt(b[i-1]);}
};

namespace WT {
  bst b[30]; int p[30],c[N];
  void build() {
    rep(i,0,n-1) c[i]=a[i];
    per(h,29,0) {
      b[h].init(n); rep(i,0,n-1) if(c[i]&(1<<h)) b[h].set(i);
      b[h].getcnt(); p[h]=stable_partition(c,c+n,[&](int x) {
        return !((x>>h)&1);})-c;
    }
  }
  int qry(int l,int r,int k,int x=0) {
    k--; per(h,29,0) {
      int cnt=b[h].s0(l,r);
      if(cnt>k) l=b[h].p0(l), r=b[h].p0(r+1)-1, assert(r<=p[h]);
      else x|=1<<h, l=p[h]+b[h].p1(l), r=p[h]+b[h].p1(r+1)-1, k-=cnt;
    } return x;
  }
}

signed main() {
  n=read(), m=read();
  rep(i,0,n-1) a[i]=read();
  WT::build();
  while(m--) {
    int l=read()-1, r=read()-1, k=read();
    printf("%d\n",WT::qry(l,r,k));
  }
  return 0;
}
```

---

## 作者：G我就是菜G (赞：12)

### 前置知识

1. 线段树（不会的先过[【线段树1】](https://www.luogu.org/problemnew/show/P3372) & [【线段树2】](https://www.luogu.org/problemnew/show/P3373)）
2. 知道可持久化数据结构

### 主席树

是一种用来查询区间静态第 $k$ 小的数据结构

原型为线段树，简单的来讲就是开 $n$ 棵线段树，然后区间查询时只要查询第 $l-1$ 棵和第 $r$ 棵做前缀和做差就行了

但是开 $n$ 棵线段树空间复杂度太大

于是我们发现，没加入一个数，只会在一条路径上更改，如果开 $n$ 棵线段树会有很多冗余节点（即重复节点），所以每次加入一个数，我们就多开 $\log n$ 个节点（即路径长度）就行了，空间复杂度为 $O(n\log^2 n)$，时间复杂度为 $O(n\log n)$

### 1. 建空树（$build$）

首先要建一棵空树，由于我们是用前缀和的思想查找，所以在 $tree[0]$ 的位置是一棵空树

代码如下：
```cpp
void build(int &t,int l,int r)  \\t是当前节点编号
{
	int mid=(l+r)>>1;
	t=++cnt;
	if (l==r) return;
	build(ls[t],l,mid);
	build(rs[t],mid+1,r);
}
```

### 2. 插入数字（modify）

在插入数字之前，我们先要对其进行离散，然后插入其编号

如

> 123 54 78 92 193

对其进行离散后为

> 4 1 2 3 5

**空树：**

![](https://cdn.luogu.com.cn/upload/pic/59655.png)

**插入 4：**

![](https://cdn.luogu.com.cn/upload/pic/59657.png)

**插入 1：**

![](https://cdn.luogu.com.cn/upload/pic/59658.png)

**插入 2：**

![](https://cdn.luogu.com.cn/upload/pic/59659.png)

**插入 3：**

![](https://cdn.luogu.com.cn/upload/pic/59661.png)

**插入 5：**

![](https://cdn.luogu.com.cn/upload/pic/59662.png)

每次修改时遍历修改的路径，判断其左儿子还是右儿子有变化，将没变化的儿子序号设为上一棵树对应节点的对应儿子，变化儿子的序号新建一个节点，继续遍历。

代码：
```cpp
int modify(int X,int l,int r)
{
	int mid=(l+r)>>1,XX=++cnt;
	ls[XX]=ls[X],rs[XX]=rs[X],sum[XX]=sum[X]+1;
	if (l==r) return XX;
	if (x<=mid) ls[XX]=modify(ls[XX],l,mid);
	else rs[XX]=modify(rs[XX],mid+1,r);
	return XX;
}
```

### 3. 查询区间第 $k$ 大（$query$）

对于查询区间 $l$ 到 $r$ 的第 $k$ 小

我们同时遍历第 $l-1$ 棵线段树和第 $r$ 棵线段树

定义 $xx=sum[num2]-sum[num1]$ （$num2$ 为第 $r$ 棵线段树当前的节点，$num1$ 表示第 $l-1$ 棵线段树当前对应节点，$sum$ 表示其数字个数之差）

当 $k\le xx$ 时，直接向左走

当 $k> xx$ 时，向右走，同时 $k-=xx$

代码：
```cpp
int query(int num1,int num2,int l,int r,int k)
{
	int mid=(l+r)>>1,xx=sum[ls[num2]]-sum[ls[num1]];
	if (l==r) return l;
	if (k<=xx) return query(ls[num1],ls[num2],l,mid,k);
	else return query(rs[num1],rs[num2],mid+1,r,k-xx);
}
```
### 完整代码：
```cpp
#include <bits/stdc++.h>
#define N 5000010

using namespace std;

int n,m,len,cnt,sum[N],x,l,r,k,ans;
int a[N],b[N],ls[N],rs[N],tree[N];

inline int read()
{
	int x=0,tag=1;
	char c=getchar();
	for (;c<'0' || c>'9';c=getchar()) if (c=='-') tag=-1;
	for (;c>='0' && c<='9';c=getchar()) x=(x<<1)+(x<<3)+c-'0';
	return x*tag;
}

void build(int &t,int l,int r)
{
	t=++cnt;
	if (l==r) return;
	int mid=(l+r)>>1;
	build(ls[t],l,mid);
	build(rs[t],mid+1,r);
}

int modify(int x,int l,int r,int k)
{
	int mid=(l+r)>>1,xx=++cnt;
	ls[xx]=ls[x],rs[xx]=rs[x],sum[xx]=sum[x]+1;
	if (l==r) return xx;
	if (k<=mid) ls[xx]=modify(ls[xx],l,mid,k);
	else rs[xx]=modify(rs[xx],mid+1,r,k);
	return xx;
}

int query(int n1,int n2,int l,int r,int k)
{
	int mid=(l+r)>>1,xx=sum[ls[n2]]-sum[ls[n1]];
	if (l==r) return l;
	if (k<=xx) return query(ls[n1],ls[n2],l,mid,k);
	else return query(rs[n1],rs[n2],mid+1,r,k-xx);
}

int main()
{
	n=read(),m=read();
	for (int i=1;i<=n;i++)
		a[i]=b[i]=read();
	sort(b+1,b+n+1);
	len=unique(b+1,b+n+1)-b-1;
	build(tree[0],1,len);
	for (int i=1;i<=n;i++)
	{
		x=lower_bound(b+1,b+len+1,a[i])-b;
		tree[i]=modify(tree[i-1],1,len,x);
	}
	for (int i=1;i<=m;i++)
	{
		l=read(),r=read(),k=read();
		printf("%d\n",b[query(tree[l-1],tree[r],1,len,k)]);
	}
	return 0;
}
```

### 另一道模板题

[可持久化数组](https://www.luogu.org/problemnew/show/P3919)

不用离散，改成每个节点存数字就行了

查询时只要像线段树查询一样，不需要用前缀和

代码如下：
```cpp
#include <bits/stdc++.h>
#define N 50000010
using namespace std;
int n,m,cnt,opt,loc,k,val;
int tree[N],num[N],ls[N],rs[N];
void build(int &t,int l,int r)
{
    int mid=(l+r)>>1;
    t=++cnt;
    if (l==r)
    {
        scanf("%d",&num[t]);
        return;
    }
    build(ls[t],l,mid);
    build(rs[t],mid+1,r);
}

int modify(int X,int l,int r)
{
    int mid=(l+r)>>1,XX=++cnt;
    ls[XX]=ls[X],rs[XX]=rs[X];
    if (l==r)
    {
        num[XX]=val;return XX;
    }
    if (k<=mid) ls[XX]=modify(ls[XX],l,mid);
    else rs[XX]=modify(rs[XX],mid+1,r);
    return XX;
}

int query(int i,int l,int r,int k)
{
    int mid=(l+r)>>1;
    if (l==r) return num[i];
    if (k<=mid) return query(ls[i],l,mid,k);
    else return query(rs[i],mid+1,r,k);
}

int main()
{
    scanf("%d%d",&n,&m);
    build(tree[0],1,n);
    for (int i=1;i<=m;i++)
    {
        scanf("%d%d",&loc,&opt);
        if (opt==1)
        {
            scanf("%d%d",&k,&val);
            tree[i]=modify(tree[loc],1,n);
        }
        else
        {
            scanf("%d",&k);
            printf("%d\n",query(tree[loc],1,n,k));
            tree[i]=tree[loc];
        }
    }
    return 0;
}
```

---

## 作者：rainygame (赞：11)

> 回来吧我的 BIT！我最高傲的信仰！
> 
> 回来吧我的 BIT！我最高傲的信仰！
>
> 回来吧我的 BIT！我最高傲的信仰！

考虑维护一颗权值树状数组。

对于每个树状数组结点，维护一个有序 `vector` 表示有哪些位置的值在这个结点的范围内。那么我们就可以通过二分查找得出这个树状数组结点中有多少个数在 $[l,r]$ 之间，再套一层二分查找就可以 $O(\log^3 n)$ 地完成一次查询。这部分的代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define MAXN 200001

int n, m, l, r, k, d;
int a[MAXN], b[MAXN];

void init(){
	memcpy(b, a, sizeof(a));
	sort(b+1, b+n+1);
	d = unique(b+1, b+n+1)-b-1;
	for (int i(1); i<=n; ++i) a[i] = lower_bound(b+1, b+d+1, a[i])-b;
}

namespace BIT{
#define lowbit(x) ((x) & -(x))
	vector<int> c[MAXN];
	void add(int x, int ind){
		while (x <= d){
			c[x].push_back(ind);
			x += lowbit(x);
		}
	}
	
	int query(int x){
		int res(0);
		while (x){
//			cout << "QUERY:" << 
			res += upper_bound(c[x].begin(), c[x].end(), r)-upper_bound(c[x].begin(), c[x].end(), l-1);
			x -= lowbit(x);
		}
		return res;
	}
}

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
	cin >> n >> m;
	for (int i(1); i<=n; ++i) cin >> a[i];
	init();
	for (int i(1); i<=n; ++i) BIT::add(a[i], i);
	
	while (m--){
		cin >> l >> r >> k;
		
		int L(1), R(d), mid;
		while (L < R){
			mid = (L+R) >> 1;
			if (BIT::query(mid) >= k) R = mid;
			else L = mid+1;
		}
		cout << b[L] << '\n';
	}
	
	return 0;
}
```

但是无法通过，所以考虑再消掉一个 $\log$。可以把二分写进树状数组里面，就像线段树上二分那样。但是树状数组只有左儿子，没有右儿子。这样好像又没法做了。

其实完全可以不用考虑右儿子的存在与否。可以只用左儿子完成二分。可以像倍增一样，令 $p$ 表示当前可以确定的最小右端点，$c(x)$ 表示 $x$ 号结点在 $[l,r]$ 之间的答案，$k$ 表示我们当前要求的排名。对于 $i \in [0,\lceil\log n\rceil)$，都将 $c(p-2^i)$ 和 $k$ 比较。有两种情况：

- $c(p-2^i) \ge k$。那么就表示第 $k$ 小在左儿子中。此时需要 $p \leftarrow p-2^i$。
- $c(p-2^i) \ge k$。那么就表示第 $k$ 小在右儿子中。这时候问题就变成了“在右儿子中找到第 $k-c(p-2^i)$ 小数”，需要 $k \leftarrow k-c(p-2^i)$。

最后所得的 $p$ 就是答案。

这样我们就得到了 $O(\log^2 n)$ 的查询复杂度，得益于树状数组的优秀常数，我们可以在时限的一半以内[通过](https://www.luogu.com.cn/record/148870911)本题。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define MAXN 200001

int n, m, l, r, k, d, _log;
int a[MAXN], b[MAXN];

void init(){
	memcpy(b, a, sizeof(a));
	sort(b+1, b+n+1);
	d = unique(b+1, b+n+1)-b-1;
	for (int i(1); i<=n; ++i) a[i] = lower_bound(b+1, b+d+1, a[i])-b;
}

namespace BIT{
#define lowbit(x) ((x) & -(x))
	vector<int> c[MAXN];
	void add(int x, int ind){
		while (x <= d){
			c[x].push_back(ind);
			x += lowbit(x);
		}
	}

#define tms(x) (x <= d ? upper_bound(c[x].begin(), c[x].end(), r)-upper_bound(c[x].begin(), c[x].end(), l-1) : INT_MAX)
	int query(int x){
		int pos(1<<_log);
        for (int i(_log-1); i>=0; --i){
            if (tms(pos-(1<<i)) >= x) pos -= (1<<i);
            else x -= tms(pos-(1<<i));
        }
        return pos;
	}
}

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	cin >> n >> m;
	for (int i(1); i<=n; ++i) cin >> a[i];
	init();
    _log = ceil(log2(d));
	for (int i(1); i<=n; ++i) BIT::add(a[i], i);

	while (m--){
		cin >> l >> r >> k;
        cout << b[BIT::query(k)] << '\n';
	}

	return 0;
}
```

---

## 作者：LittleAcbg (赞：9)

这个题除了主席树（可持久化线段树），还可以使用**整体二分**。下面我将在这篇文章中介绍整体二分。

请注意，整体二分是离线算法，不能处理强制在线的问题。

## 二分答案

**这一章节并不是讲二分答案算法的，所以即使你会二分答案也请看完。**

整体二分的基础是二分答案。考虑如下问题：

> 给定整数序列 $a_1,a_2,\dots,a_n$，求其中第 $k$ 小的元素。

尽管这是一个十分简单的问题，但我们依然可以对其进行大炮打蚊子。抛开简单的 `sort` 和 `nth_element` 方法不谈，我们考虑对这个问题进行二分答案。

众所周知，想进行二分答案，我们必须将这个问题转化为一个最优化问题。于是我们把题意写成这样：

> 求一个最小的整数 $x$，使得序列中 $\le x$ 的数的数量 $\ge k$。

可以证明求出的 $x$ 就是序列的第 $k$ 小元素。

然后，就有了一份简单的二分答案代码：

```cpp
bool OK(int x) // 判断是否满足 <=x 的数的数量 >=k 
{
	int cnt = 0;
	for (int i = 1; i <= n; ++i)
		if (a[i] <= x) ++cnt; // 统计数量 
	return cnt >= k; // 判断合法性 
}
void binarySearch(int low, int high) // high,low 为上下界 
{
	while (low < high)
	{
		int mid = (low + high) >> 1; // 取出 mid
		if (OK(mid)) high = mid; // 保留合法解 
		else low = mid + 1; // 去除不合法 x 
	}
	return low; // 此时 low == high，输出即可 
}
```

对二分答案算法就不做过多解释了，大家可以自行上网查询，相关资料还是很多的。

我们考虑将这份代码写成递归形式：

```cpp
void binarySearch(int low, int high)
{
	if (low == high) // 递归一定要记得判终止条件 
	{
		ans = low;
		return;
	}
	
	int mid = (low + high) >> 1; // 取出 mid 
	
	// 将合法性判断直接放在 binarySearch 函数里 
	int cnt = 0;
	for (int i = 1; i <= n; ++i)
		if (a[i] <= mid) ++cnt;
	
	if (cnt >= k) binarySearch(low, mid); // 递归调用 
	else binarySearch(mid + 1, high);
}
```

这份代码还是比较简单的，只是把原先的 `while` 循环改成了递归调用处理。

我们发现这份代码还可以优化。在合法性判断中，代码枚举了整个序列，但实际上这个序列上有一部分元素在之前的二分排除的过程中可以被排除，无需重复计算。

上面那段话可能比较抽象，我们来看一个实际的例子：

> $n=6$，$\{a_n\}=1,1,4,5,1,4$，$k=3$。

初始时 $low=1,high=5$，取出 $mid=3$。计算得序列中 $\le3$ 的元素数量为 $3\ge k$，因此往较小的一半递归，即新的 $[low,high]=[1,3]$。

此时值为 $4,5$ 的元素已经被排除了，不会再参与 $cnt$（$\le mid$ 元素数量）的统计，因此我们可以将它们剔除，此后不再参与 $cnt$ 的计算。

第二个例子：

> $n=6$，$\{a_n\}=1,1,4,5,1,4$，$k=4$。

类似地，取出 $mid=3$ 后，发现序列中 $\le3$ 的元素数量为 $3<k$，要往大的一半递归。此时我们发现，在新的 $[low,high]=[4,5]$ 中，无论是哪个数 $x$，$\le3$ 的元素（$1$）都会计入 $\le x$ 的数的数量，因此我们可以仿照线段树上二分，令 $k\leftarrow k-cnt$，以此来省略这些元素的统计。

剔除元素的方法也很多，我的做法是改变元素在数组中存储的位置，将值 $\le mid$ 的元素存储在数组靠前的位置，$>mid$ 的元素存储在数组靠后的位置，然后递归时只保留一段区间的元素即可。

参考代码：

```cpp
void binarySearch(int low, int high, int st, int ed) // st,ed 表示经剔除之后需要考虑的元素下标区间
{
	if (low == high)
	{
		ans = low;
		return;
	}
	int mid = (low + high) >> 1;
	int cnt = 0,n1 = 0,n2 = 0; // n1,n2 表示 <=mid >mid 的元素数量 
	for (int i = st; i <= ed; ++i)
		if (a[i] <= mid) ++cnt,v1[++n1] = a[i]; // 存储在 v1 中
		else v2[++n2] = a[i]; // 存储在 v2 中
	
	// 还原回原序列，改变位置
	for (int i = 1; i <= n1; ++i) a[st + i - 1] = v1[i];
	for (int i = 1; i <= n2; ++i) a[ed - n2 + i] = v2[i];
	
	// 递归调用 
	if (cnt >= k) binarySearch(low, mid);
	else k -= cnt,binarySearch(mid + 1, high);
	//   ^ 易错点：k -= cnt 容易漏掉
}
```

这个优化其实并没有太大的效果，因为其最坏情况下复杂度仍为 $O(n\log V)$（$V$ 为值域），一种最坏情况的构造就是所有元素都相等的序列。但是，优化后的二分答案框架对我们的整体二分算法有非常大的启发作用。

## 整体二分

接下来开始就是整体二分算法的解释了。回到原问题：

> $m$ 次问询，每次给定区间 $[l,r]$，求序列 $a_l,a_{l+1},\dots,a_r$ 中第 $k$ 小的元素。

根据上面的分析，我们可以对每个问询进行一次二分，时间复杂度 $O(mn\log V)$。

于是我们开始思考这个算法慢在哪儿。发现每次二分我们都对所有 $n$ 个元素进行了 $O(\log V)$ 次分区。分区指将元素分为低区（$x\le mid$）和高区（$x>mid$）。

大量分区会导致算法的效率较低，但我们注意到每次二分，分区的情况总是固定的，因为元素的值是固定的。所以我们考虑对所有问询做一次二分，这样就能大大降低分区所消耗的时间了。

于是就有了**整体二分**。注意到不仅点需要分区，问询也会分区。一个问询在二分答案时向低区递归，就称它属于低区，否则称它属于高区。

考虑将点和问询储存在同一数组里，同时进行分区，可以写出如下代码：

```cpp
struct Operation {int iQ,x,y,k;} op[N * 2],o1[N * 2],o2[N * 2];
/* 定义操作（加点或问询）
加点操作只使用 x（数组位置）、y（数值），iQ == 0
问询操作使用 [x,y] 表示区间 [l,r]，iQ 为问询编号，k 为问询中 k
*/

// 二分框架大致与之前的相同
void binarySearch(int low, int high, int st, int ed)
{
	if (st > ed) return; // 排除没有任何操作的区间，稍后会分析时间复杂度
	if (low == high) return;
	int mid = (low + high) >> 1,n1 = 0,n2 = 0;
	for (int i = st; i <= ed; ++i)
		if (!op[i].iQ)
			if (op[i].y <= mid) o1[++n1] = op[i];
			else o2[++n2] = op[i];
		else
		{
			int cnt = /**/;
			if (cnt >= op[i].k) o1[++n1] = op[i];
			else op[i].k -= cnt,o2[++n2] = op[i];
		}
	for (int i = 1; i <= n1; ++i) op[st + i - 1] = o1[i]; // 分区还原到原数组中
	for (int i = 1; i <= n2; ++i) op[ed - n2 + i] = o2[i];
	binarySearch(low, mid, st, ed - n2); // 两边都要递归
	binarySearch(mid + 1, high, st + n1, ed);
}
```

其中并未加入统计答案的部分，只实现了分区。对代码略作解释：分区和原来基本相同，使用两个临时数组记录，高区和低区都可能有问询，都需要递归处理。

上面那段代码里，$cnt$ 的计算还未写出，考虑如何计算。对问询 $[l,r,k]$，$cnt$ 的含义是 $[l,r]$ 区间内低区点的个数。所以我们可以先进行所有加点操作，维护一个区间和，然后处理问询时直接进行区间和查询即可。这可以使用树状数组（BIT）维护，不会的可以去[这里](https://www.luogu.com.cn/problem/P3374)。

然后我们添加 BIT，新的代码：（`add` 表示点增加，`psq` 表示前缀查询）

```cpp
struct Operation {int iQ,x,y,k;} op[N * 2],o1[N * 2],o2[N * 2];
void binarySearch(int low, int high, int st, int ed)
{
	if (st > ed) return;
	if (low == high) return;
	int mid = (low + high) >> 1,n1 = 0,n2 = 0;
	for (int i = st; i <= ed; ++i)
		if (!op[i].iQ)
			if (op[i].y <= mid) add(op[i].x, 1),o1[++n1] = op[i];
			else o2[++n2] = op[i];
		else
		{
			int cnt = psq(op[i].y) - psq(op[i].x - 1);
			if (cnt >= op[i].k) o1[++n1] = op[i];
			else op[i].k -= cnt,o2[++n2] = op[i];
		}
	for (int i = 1; i <= n1; ++i) if (!o1[i].iQ) add(o1[i].x, -1); // 注意清空 BIT
	for (int i = 1; i <= n1; ++i) op[st + i - 1] = o1[i];
	for (int i = 1; i <= n2; ++i) op[ed - n2 + i] = o2[i];
	binarySearch(low, mid, st, ed - n2);
	binarySearch(mid + 1, high, st + n1, ed);
}
```

使用完 BIT 之后需要清空。

接着，我们还需要考虑如何统计答案。如果一个区间满足 `low == high`，那么区间内问询的答案就唯一确定了，直接记录即可。

直接放代码：

```cpp
if (low == high)
{
	for (int i = st; i <= ed; ++i) ans[op[i].iQ] = low;
	return;
}
```

理论上应当有一个 `if (op[i].iQ)`，不过修改 $ans[0]$ 的值也不会对程序运行结果造成影响。

于是我们就完成了这道题目。完整代码：（时间复杂度分析在代码之后）

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5+9;
int nPos,nQ,nOp,ans[N],bit[N];
struct Operation {int iQ,x,y,k;} op[N * 2],o1[N * 2],o2[N * 2];

// 树状数组（BIT）
int LSB(int x) {return x & -x;}
void add(int x, int z)
{
	while (x <= nPos)
	{
		bit[x] += z;
		x += LSB(x);
	}
}
int psq(int x)
{
	int ret = 0;
	while (x)
	{
		ret += bit[x];
		x -= LSB(x);
	}
	return ret;
}

void binarySearch(int low, int high, int st, int ed) // 整体二分模板
{
	if (st > ed) return;
	if (low == high)
	{
		for (int i = st; i <= ed; ++i) ans[op[i].iQ] = low;
		return;
	}
	int mid = (low + high) >> 1,n1 = 0,n2 = 0;
	for (int i = st; i <= ed; ++i)
		if (!op[i].iQ)
			if (op[i].y <= mid) add(op[i].x, 1),o1[++n1] = op[i];
			else o2[++n2] = op[i];
		else
		{
			int cnt = psq(op[i].y) - psq(op[i].x - 1);
			if (cnt >= op[i].k) o1[++n1] = op[i];
			else op[i].k -= cnt,o2[++n2] = op[i];
		}
	for (int i = 1; i <= n1; ++i) if (!o1[i].iQ) add(o1[i].x, -1);
	for (int i = 1; i <= n1; ++i) op[st + i - 1] = o1[i];
	for (int i = 1; i <= n2; ++i) op[ed - n2 + i] = o2[i];
	binarySearch(low, mid, st, ed - n2);
	binarySearch(mid + 1, high, st + n1, ed);
}

int main()
{
	scanf("%d%d", &nPos, &nQ);
	for (int i = 1; i <= nPos; ++i) // 处理每一个位置
	{
		int h;
		scanf("%d", &h);
		op[i] = (Operation){0, i, h, 0};
	}
	for (int iQ = 1; iQ <= nQ; ++iQ) // 处理每一个询问
	{
		int l,r,k;
		scanf("%d%d%d", &l, &r, &k);
		op[nPos + iQ] = (Operation){iQ, l, r, k};
	}
	binarySearch(0, 1e9, 1, nOp = nPos + nQ); // 整体二分
	for (int iQ = 1; iQ <= nQ; ++iQ) printf("%d\n", ans[iQ]); // 输出答案
	return 0;
}
```

## 时间复杂度分析

实际上，这道题还没有做完，我们还没有证明其时间复杂度正确性。容易发现整体二分外都是 $O(n)$ 的，所以着重看整体二分。

整体二分总共会进行 $\log V$ 层。每一个点或询问都只属于低区、高区之一，而没有操作的区间会进行排除，故总共运行 `binarySearch()` 函数的次数不会超过 $O((m+n)\log V)$。再乘上 BIT 的 $O(\log n)$ 复杂度，总时间复杂度为：

$O\Large(\normalsize(m+n)\log n\log V\Large)$

完结撒花。

---

## 作者：sLMxf (赞：7)

# [可持久化线段树 1](https://www.luogu.com.cn/problem/P3919)
## Problem
维护序列在某个历史版本上修改/查询某一个位置上的值。
## 算法介绍
什么是可持久化线段树呢？首先来考虑怎么暴力解决这个问题：
### 弱化版：$n,m\le 10^3$
对于每一次操作，我们每次复制一个版本即可。

这样子时空复杂度是 $O(nm)$（易得）。显然过不了。
### 标准版：$n,m\le 10^5$
首先我们将这个序列化成一个线段树。（至于为什么后面再讲）可是这样子复制的话还是 $O(nm)$。

我们来观察一次复制：

![](https://cdn.luogu.com.cn/upload/image_hosting/qo8feq6g.png)

其实真正修改了的只有 树高 个节点（即 $\log n$ 个节点），但是我们复制了 $n$ 个节点。那这样就好办了，我们每次修改只修改一条链即可。

![](https://cdn.luogu.com.cn/upload/image_hosting/4nsf05d0.png)

但是这样子就不能简单地使用基本的线段树了，于是就有了“可持久化线段树”。

可持久化线段树的原理就是如上讲的，**每次修改只插入一条链。**
## 代码实现
按照刚才的分析，最重要的问题就是无法建二叉树。

似乎在动态开点线段树中，我们也遇到了这个问题，当时我们使用了结构体，来存储左儿子右儿子编号。

```cpp
struct tree{
	int l,r,val;
};
```

既然这样我们就需要开启新结点：

```cpp
int add(int node)
{
  a[++top]=a[node];
  return top;
}
```

`top` 的意思是当前节点编号，`node` 的意思是原来的节点“本来修改的对象”，先复制一遍，再进行复制。

接着考虑建树，首先我们定义一个新数组 `tr[i]`，表示第 $i$ 个版本所对应的树根。初始版本的根就叫做 $tr[0]=1$。为了知道节点的左右儿子，`build` 时返回当前节点编号即可。代码实现如下：

```cpp
int build(int node,int l=1,int r=n)
{
  node=++top; // 其实也是 add(node),但是初始版本不用复制，直接这么写就可以了。
  if(l==r)
  {
    a[node].val=read(); // 本题可以直接输入
    return node;
  }
  int mid=(l+r)/2;
  a[node].l=build(a[node].l,l,mid);
  a[node].r=build(a[node].r,mid+1,r);
  return node;
}
```

`update` 和 `build` 差不多，但是 `update` 不能 `node=++top`，而需要 `node=add(node)`：
```cpp
int update(int w,int val,int node,int l=1,int r=n)
{
  node=add(node);
  if(l==r) a[node].val=val;
  else
  {
    int mid=(l+r)/2;
    if(w<=mid) a[node].l=update(w,val,a[node].l,l,mid);
    else a[node].r=update(w,val,a[node].r,mid+1,r);
  }
  return node;
}
```

`query` 实现就非常简单了，和正常的没有区别：
```cpp
int query(int w,int node,int l=1,int r=n)
{
  if(l==r) return a[node].val;
  else
  {
    int mid=(l+r)/2;
    if(w<=mid) return query(w,a[node].l,l,mid);
    else return query(w,a[node].r,mid+1,r);
  }
}
```

---

建树的话调用这个代码就可以了：
```cpp
tr[0]=build(0); // 也可以写作 tr[0]=1;build(0);
```

修改和查询同理。

那么最后的代码如下：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n;
int read() // 快读
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
struct ZX__tree{
	struct tree{
		int l,r,val;
	};
	tree a[32000006];
	int tr[32000006];
	int top;
	int build(int node,int l=1,int r=n)
	{
		node=++top;
		if(l==r)
		{
			a[node].val=read();
			return node;
		}
		int mid=(l+r)/2;
		a[node].l=build(a[node].l,l,mid);
		a[node].r=build(a[node].r,mid+1,r);
		return node;
	}
	int add(int &node)
	{
		top++;
		a[top]=a[node];
		return top;
	}
	int update(int w,int val,int node,int l=1,int r=n)
	{
		node=add(node);
		if(l==r) a[node].val=val;
		else
		{
			int mid=(l+r)/2;
			if(w<=mid) a[node].l=update(w,val,a[node].l,l,mid);
			else a[node].r=update(w,val,a[node].r,mid+1,r);
		}
		return node;
	}
	int query(int w,int node,int l=1,int r=n)
	{
		if(l==r) return a[node].val;
		else
		{
			int mid=(l+r)/2;
			if(w<=mid) return query(w,a[node].l,l,mid);
			else return query(w,a[node].r,mid+1,r);
		}
	}
}a;
signed main()
{
	int T;
	cin>>n>>T;
	a.tr[0]=a.build(0);
	for(int i=1;i<=T;i++)
	{
		int v=read(),op=read();
		if(op==1)
		{
			int w=read(),val=read();
			a.tr[i]=a.update(w,val,a.tr[v]);
		}
		else
		{
			int w=read();
			cout<<a.query(w,a.tr[v])<<endl;
			a.tr[i]=a.tr[v];
		}
	}
	return 0;
}
```
## 正确性证明
主要是对时空复杂度的证明。

对于时间复杂度：很显然的是 $O(n+m\log n)$。（不知道原因的自己回去学好线段树再来）

对于空间复杂度：因为每次只需要建一条链，空间复杂度也优化到了 $O(n+m\log n)$。

所以时空复杂度均为 $O(n+m\log n)$。
## 为什么要将序列变为线段树
1. 本题虽然用不到节点合并，但并不排除别的题有（比如下一道就有）
2. 虽然用不到节点合并，但是二叉树保证了每次我只需要修改左儿子或者右儿子，所以降低了时间复杂度。
3. ~~不然就不是可持久化线段树的例题了。~~
# [可持久化线段树 2](https://www.luogu.com.cn/problem/P3834)
## Problem
静态查询区间第 $k$ 大。
## 算法分析
### 弱化版 1：查询的区间为 $[1,n]$
考虑使用权值线段树。这个还是非常简单的，不知道自己去学。

伪代码如下：
```cpp
int query(u,l,r,k):
  if l==r:
    return l;
  if 左孩子数的个数<=k:
    return query(lchild,l,r,k);
  else
    return query(rchild,l,r,k-左孩子数的个数);
```
### 弱化版 2：查询的区间为 $[1,r]$
通过我们对可持久化线段树的认识，我们发现其实可持久化线段树就是一个存储多棵线段树的数据结构且除了初始线段树其他线段树都可以通过另外一个线段树进行单点修改得到。

---
上面的意思是可持久化线段树：
- 存储多棵线段树；
- 除了初始线段树，其余线段树都存在另一个线段树，已经被存储，且只进行了一次单点修改。
---

这篇题解后面只要未说明，权值线段树简称为线段树。（包括可持久化线段树也被称作可持久化权值线段树）

那么我们可以利用可持久化线段树的这个性质，存储 $n$ 棵线段树，第 $i$ 棵线段树存的是前 $i$ 个数。

那么查询 $[1,r]$ 的第 $k$ 大，相当于查询第 $r$ 棵线段树的第 $k$ 大。

变成了弱化版 1。
### 标准版：查询的区间为 $[l,r]$
继续沿用弱化版 2 的思路，我们仍然用可持久化权值线段树来解决这个问题。

以下记 $mid=\frac{L+R}{2}$，下取整。

在 $[1,r]$ 中，假设我们枚举到了 $[L,R]$ 这个区间里的数，要求第 $k$ 大，就是先看 $[L,mid]$ 中有没有 $k$ 个数，如果有就往左边找，否则查右边的。

在 $[l,r]$ 中，也是同理的，假设我们枚举到了 $[L,R]$ 这个区间里的数，要求第 $k$ 大，就是先看 $[L,mid]$ 中有没有 $k$ 个数。问题是怎么求 $[L,mid]$ 里的数，我们可以用 $r$ 这棵树里 $[L,mid]$ 里的数的个数减去 $(l-1)$ 这棵树里 $[L,mid]$ 里的数的个数。

那么这道题不就做完了吗？
## 代码实现
`update` 从原来的单点赋值变为单点 $+1$。这里就不单独贴代码了。

`query` 和弱化版 1 差不多：
```cpp
int query(int nl,int nr,int k,int L=1,int R=cnt)
{
  if(L==R) return L;
  int mid=(L+R)>>1,suml=a[a[nr].l].w-a[a[nl].l].w;
  if(suml>=k) return query(a[nl].l,a[nr].l,k,L,mid);
  else return query(a[nl].r,a[nr].r,k-suml,mid+1,R);
}
```

完整代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int cnt;
struct ZX_tree{
	struct tree{
		int u,l,r,w; // w表示a[u]表示的区间内,数出现的个数 
	};
	tree a[6400005];
	int tr[6400005],tot;
	void add(int &node)
	{
		tot++;
		a[tot]=a[node];
		node=tot;
	}
	void pushup(int u){a[u].w=a[a[u].l].w+a[a[u].r].w;}
	int build(int node=0,int l=1,int r=cnt)
	{
		node=++tot;
		if(l==r) return node;
		int mid=(l+r)>>1;
		a[node].l=build(a[node].l,l,mid);
		a[node].r=build(a[node].r,mid+1,r);
		return node;
	}
	int update(int w,int p,int node,int l=1,int r=cnt)
	{
		add(node);
		if(l==r)
		{
			a[node].w+=p;
			return node;
		}
		int mid=(l+r)/2;
		if(w<=mid) a[node].l=update(w,p,a[node].l,l,mid);
		else a[node].r=update(w,p,a[node].r,mid+1,r);
		pushup(node);
		return node;
	}
	int query(int nl,int nr,int k,int L=1,int R=cnt)
	{
		if(L==R) return L;
		int mid=(L+R)>>1,suml=a[a[nr].l].w-a[a[nl].l].w;
		if(suml>=k) return query(a[nl].l,a[nr].l,k,L,mid);
		else return query(a[nl].r,a[nr].r,k-suml,mid+1,R);
	}
}seg;
int yl[200005],sor[200005];
unordered_map<int,int>mp,dy;
int main()
{
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>yl[i],sor[i]=yl[i];
	sort(sor+1,sor+1+n);
	cnt=unique(sor+1,sor+n+1)-sor-1;
	for(int i=1;i<=cnt;i++) mp[sor[i]]=i,dy[i]=sor[i];
	seg.tr[0]=seg.build();
	for(int i=1;i<=n;i++)
		seg.tr[i]=seg.update(mp[yl[i]],1,seg.tr[i-1]);
	while(m--)
	{
		int l,r,k;
		cin>>l>>r>>k;
		cout<<dy[seg.query(seg.tr[l-1],seg.tr[r],k)]<<'\n';
	}
	return 0;
}
```
## 正确性证明
和模板 1 一样的分析，时空复杂度均为 $O(n+m\log n)$。
## 《其他做法》
话说你都动态开点了，干嘛离散化啊...
```cpp
#include<bits/stdc++.h>
using namespace std;
int len=1000000000,a[6400005];
struct ZX_tree{
	struct tree{
		int u,l,r,val;
	};
	tree a[64200005];
	int tr[26400005],tot;
	int add(int node)
	{
		a[++tot]=a[node];
		return tot;
	}
	int build(int node,int l=0,int r=len)
	{
		node=++tot;
		if(l==r) return node;
		int mid=(l+r)>>1;
		a[node].l=build(node,l,mid);
		a[node].r=build(node,mid+1,r);
		return node;
	}
	void pushup(int u){a[u].val=a[a[u].l].val+a[a[u].r].val;}
	int update(int w,int node,int l=0,int r=len)
	{
		node=add(node);
		if(l==r)
		{
			a[node].val++;
			return tot;
		}
		int mid=(l+r)>>1;
		if(w<=mid)a[node].l=update(w,a[node].l,l,mid);
		else a[node].r=update(w,a[node].r,mid+1,r);
		pushup(node);
		return node;
	}
	int query(int nl,int nr,int k,int l=0,int r=len)
	{
		if(l==r) return l;
		int mid=(l+r)>>1,sm=a[a[nr].l].val-a[a[nl].l].val;
		if(sm>=k) return query(a[nl].l,a[nr].l,k,l,mid);
		else return query(a[nl].r,a[nr].r,k-sm,mid+1,r);
	}
}seg;
unordered_map<int,int>mp,dy;
int main()
{
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++) seg.tr[i]=seg.update(a[i],seg.tr[i-1]);
	while(m--)
	{
		int l,r,k;
		cin>>l>>r>>k;
		cout<<seg.query(seg.tr[l-1],seg.tr[r],k)<<'\n';
	}
	return 0;
}
```

---

## 作者：Sophon (赞：5)

# 主席树  
不带修改，静态查询区间第$\;k\;$小。

## 前置芝士：权值线段树   
&emsp;&emsp;权值线段树是维护一段值域上数的个数的线段树。每个节点的$\;l\;$和$\;r\;$表示~~一个区间~~一段值域，节点权值$\;sum\;$表示整个序列中落在值域$\;[l, r]\;$上的数的总个数。  
&emsp;&emsp;例如，有一个序列$\;\{1,1,2,3,3,3,4,4\}\;$，下图即为这个序列对应的权值线段树。   
   
![](https://i.loli.net/2019/08/10/nkszbqlFRfpjtIw.png)
 
&emsp;&emsp;根节点表示序列中值介于$\;1\sim4\;$之间共有$\;8\;$个数。根节点左孩子表示序列中值介于$\;1\sim2\;$之间共有$\;3\;$个数，其余节点含义类似。

## 正式开始  
  
### 节点定义
节点带三个信息，$\;l\;$为值域左端点，$\;r\;$为值域右端点，$\;sum\;$为值域上数的个数。$\;root[\;]\;$为每个历史版本的根节点下标。$\;a[\;]\;$为原序列。全局$\;cnt\;$为节点总个数。
```cpp
#define sum(p) t[p].sum
#define l(p) t[p].l
#define r(p) t[p].r

using namespace std;

const int N = 200000 + 10;

int cnt;

struct SegmentTree
{
	int l, r, sum;
};

SegmentTree t[N * 40];
int a[N];
int root[N];
```
### 插入新数  
$\;l, r\;$为当前访问的节点维护的值域左右端点，$\;pre\;$为插入前上一版本线段树根节点下标。$\;now\;$为当前（新的待插入）节点下标，$\;v\;$为待插入值。每次插入，先将上一版本线段树根节点拷贝过来，之后再修改发生变化的信息（即$\;sum\;$值）。然后根据$\;v\;$决定向左子树还是右子树递归修改。详见注释。附图是在刚刚的例子中新插入$\;4\;$后的情况，蓝色部分和上一版本未更改部分构成新版本线段树。
![1.png](https://i.loli.net/2019/08/10/vCB6MYbyFg1L9t4.png)
```cpp
void Insert(int l, int r, int pre, int& now, int v)
{
    //拷贝上一版本
	t[++cnt] = t[pre];
	//修改当前now为已经分配到的cnt
	now = cnt;
	//由于从上层递归来的，v一定属于当前节点控制的区间，sum++
	sum(now)++;
	//访问到了叶子节点
	if (l == r)
	{
		return;
	}
	//根据值归属左半区间还是右半区间递归修改
	int mid = (l + r) >> 1;
	if (v <= mid)
	{
		Insert(l, mid, l(pre), l(now), v);
	}
	else
	{
		Insert(mid + 1, r, r(pre), r(now), v);
	}
}
```
对应的主函数中：
```cpp
//由于权值值域太大难以维护，先离散化
//v为vector<int>
for (int i = 1; i <= n; i++)
{
	cin >> a[i];
	v.push_back(a[i]);
}
sort(v.begin(), v.end());
//去重，并删去多余，加快二分
v.erase(unique(v.begin(), v.end()), v.end());

//依次插入
for (int i = 1; i <= n; i++)
{
	Insert(1, n, root[i - 1], root[i], GetId(a[i]));
}
```
其中$\;GetId\;$函数返回离散化后的值：
```cpp
inline int GetId(int x)
{
	return lower_bound(v.begin(), v.end(), x) - v.begin() + 1;
}
```
### 查询  
$\;l, r\;$为当前访问的节点维护的值域左右端点，$\;L, R\;$为线段树历史版本对应的根节点。$\;k\;$为需要查询排第$\;k\;$的元素。
```cpp
int Ask(int l, int r, int L, int R, int k)
{
    //区间长度收缩成1，答案找到
	if (l == r)
	{
		return l;
	}
	int mid = (l + r) >> 1;
	//预先看一眼根节点左子树在两个版本之间差了多少个
	//l_size即为原序列待查询区间中值介于[l(R),r(R)]之间的数个数
	//类似于前缀和
	int l_size = sum(l(R)) - sum(l(L));
    //左子树过大
	if (k <= l_size)
	{
	    //往左子树收缩区间继续查询，参数l(L), l(R)保证了同步访问两个历史版本线段树
	    //即每次参数L和R都维护着同一段值域
		return Ask(l, mid, l(L), l(R), k);
	}
	//左子树不够
	else
	{
	    //同理，往右子树收缩查询范围
		return Ask(mid + 1, r, r(L), r(R), k - l_size);
	}
}
```
对应的主函数：
```cpp
for (int i = 1; i <= m; i++)
{
	int l, r, k;
	cin >> l >> r >> k;
	//类似于前缀和的做法，传入第l-1版和第r版的根节点作为L和R的实参
	cout << v[Ask(1, n, root[l - 1], root[r], k) - 1] << endl;
}
```
## 做法概述 
&emsp;&emsp;建一棵空树，扫描序列，每次动态开点，插入扫描到的新数，同时保留插入前历史版本信息。    
&emsp;&emsp;对于每次询问，找到区间对应的两个历史版本线段树，同步地访问两棵树的节点，根据节点保存的$\;sum\;$值（即对应值域上数个数）向下层递归查找。

附送~~高清无码~~AC程序。

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

#define sum(p) t[p].sum
#define l(p) t[p].l
#define r(p) t[p].r

using namespace std;

const int N = 200000 + 10;

int cnt;

struct SegmentTree
{
	int l, r, sum;
};

SegmentTree t[N * 40];
int a[N];
int root[N];

void Insert(int l, int r, int pre, int& now, int v)
{
	t[++cnt] = t[pre];
	now = cnt;
	sum(now)++;
	if (l == r)
	{
		return;
	}
	int mid = (l + r) >> 1;
	if (v <= mid)
	{
		Insert(l, mid, l(pre), l(now), v);
	}
	else
	{
		Insert(mid + 1, r, r(pre), r(now), v);
	}
}

int Ask(int l, int r, int L, int R, int k)
{
	if (l == r)
	{
		return l;
	}
	int mid = (l + r) >> 1;
	int l_size = sum(l(R)) - sum(l(L));

	if (k <= l_size)
	{
		return Ask(l, mid, l(L), l(R), k);
	}
	else
	{
		return Ask(mid + 1, r, r(L), r(R), k - l_size);
	}
}

vector<int> v;

inline int GetId(int x)
{
	return lower_bound(v.begin(), v.end(), x) - v.begin() + 1;
}

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);

	int n, m;
	cin >> n >> m;

	for (int i = 1; i <= n; i++)
	{
		cin >> a[i];
		v.push_back(a[i]);
	}
	sort(v.begin(), v.end());
	v.erase(unique(v.begin(), v.end()), v.end());

	for (int i = 1; i <= n; i++)
	{
		Insert(1, n, root[i - 1], root[i], GetId(a[i]));
	}

	for (int i = 1; i <= m; i++)
	{
		int l, r, k;
		cin >> l >> r >> k;
		cout << v[Ask(1, n, root[l - 1], root[r], k) - 1] << endl;
	}
}
```

---

## 作者：ni_ju_ge (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P3834)。
## 主席树
前置知识：线段树、权值线段树。

主席树即可持久化线段树，“可持久化”的意思就是可以访问各个历史版本，那么版本该怎么存储呢？

简单的复制无论是时间还是空间上的复杂度都很高，所以需要进行优化。不难发现，从旧版本到新版本，有很大一部分点是不用改变的，所以就可以像这样：
![](https://cdn.luogu.com.cn/upload/image_hosting/cbgctzft.png)

可以看出来，主席树的特点是有很多的根节点，不同的根节点对应着不同的版本。

### 存储
对比线段树，访问子节点显然不能再用 $pos\times 2$ 和 $pos\times 2 + 1$，所以需要使用 $lc$ 和 $rc$ 来存储子节点，另外，因为节点是动态增加的，所以需要统计总结点数，还要开数组记录根节点编号。
```cpp
int ns,rs,root[1000001];//ns为节点总数，rs为根节点总数
struct node {
	int lc,rc,l,r,dat;
} tree[23000001];//23倍空间！
```
### 新建
非常简单，新节点的编号即为加入后的节点总数。
```cpp
void make(int pos) {
	tree[++ns]=tree[pos];//新节点编号的信息与编号为pos的节点一样
}
```
### 建树
与线段树类似，需要注意，要将该节点的父节点的 $lc$ 和 $rc$ 赋值。
```cpp
void build(int left,int right,int f) {;
	tree[++ns].l=left;
	tree[ns].r=right;
	if(tree[f].lc==0)tree[f].lc=ns;
	else tree[f].rc=ns;
	if(left==right) {
		tree[ns].dat=a[left];
		return;
	}
	int mid=(left+right)/2,nows=ns;
	build(left,mid,nows);
	build(mid+1,right,nows);
	tree[nows].dat=tree[tree[nows].lc].dat+tree[tree[nows].rc].dat;
}
```
### 单点修改
和线段树没太大的区别，在修改之前先建新版本即可。
```cpp
void tplus(int pos) {
	if(tree[pos].l==tree[pos].r) {
		make(pos);
		tree[ns].dat=val;
		return;
	}
	int mid=(tree[pos].l+tree[pos].r)/2;
	if(goal<=mid) {
		tplus(tree[pos].lc);
		make(pos);
		tree[ns].lc=ns-1;
	}
	if(goal>mid) {
		tplus(tree[pos].rc);
		make(pos);
		tree[ns].rc=ns-1;
	}
	tree[ns].dat=tree[tree[ns].lc].dat+tree[tree[ns].rc].dat;
	if(pos==root[loc])root[++rs]=ns;//注意将新的根节点存进root
}
```
### 懒标签
懒标签的下传其实和线段树没有什么区别。
```cpp
void pushdown(int pos) {
	if(tree[pos].lazy==0) return;
	tree[tree[pos].lc].dat=tree[tree[pos].lc].lazy=tree[pos].lazy;
	tree[tree[pos].rc].dat=tree[tree[pos].rc].lazy=tree[pos].lazy;
	tree[pos].lazy=0;
}
```
### 本题做法
建 $n+1$ 个版本的权值线段树，版本编号为 $0\sim n$，版本 $i$ 表示区间 $[1\sim i]$ 每个数出现的次数，特别的， $i=0$ 时的权值线段树为空。

这样区间 $[l\sim r]$ 中 $x$ 出现的次数就是区间 $[1\sim r]$ 中出现的次数减去区间 $[1\sim l-1]$ 中出现的次数，然后用类似平衡树的方式查找答案即可。

注意本题还需要离散化。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=8e6;//空间还是要开到很大的
int a[200001],root[200001],b[200001],n,m,ns,rs,loc,goal,val,le,ri;
struct node {
	int lc,rc,l,r,dat,lazy;
} tree[N];
struct ckid {
	int sit,dat;
} v[200001];
bool cmp(ckid x,ckid y) {
	return x.dat<y.dat;
}
int read() {
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') {
		if(ch=='-')w=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();
	return s*w;
}
void print(int x) {
	if(x<0) {
		putchar('-');
		x=-x;
	}
	if(x>9)print(x/10);
	putchar(x%10+'0');
}
void make(int pos) {
	tree[++ns]=tree[pos];
}
void build(int left,int right,int f) {//建初始树
	tree[++ns].l=left;
	tree[ns].r=right;
	if(tree[f].lc==0)tree[f].lc=ns;
	else tree[f].rc=ns;
	if(left==right) {
		tree[ns].dat=a[left];
		return;
	}
	int mid=(left+right)/2,nows=ns;
	build(left,mid,nows);
	build(mid+1,right,nows);
	tree[nows].dat=tree[tree[nows].lc].dat+tree[tree[nows].rc].dat;
}
void tplus(int pos) {
	if(tree[pos].l==tree[pos].r) {
		make(pos);
		tree[ns].dat+=val;
		return;
	}
	int mid=(tree[pos].l+tree[pos].r)/2;
	if(goal<=mid) {
		tplus(tree[pos].lc);
		make(pos);
		tree[ns].lc=ns-1;
	}
	if(goal>mid) {
		tplus(tree[pos].rc);
		make(pos);
		tree[ns].rc=ns-1;
	}
	tree[ns].dat=tree[tree[ns].lc].dat+tree[tree[ns].rc].dat;
	if(pos==root[loc])root[++rs]=ns;
}
int tfind(int pos,int sop) {
	if(tree[pos].l==tree[pos].r)return tree[pos].l;
	int k=tree[tree[sop].lc].dat-tree[tree[pos].lc].dat;
	if(k>=val)return tfind(tree[pos].lc,tree[sop].lc);
	else {
		val-=k;
		return tfind(tree[pos].rc,tree[sop].rc);
	}
}
void lsh() {//离散化
	sort(v+1,v+n+1,cmp);
	for(int i=1; i<=n; i++) {
		a[v[i].sit]=i;
		b[i]=v[i].dat;
	}
}
void updata() {//建树
	for(int i=0; i<n; i++) {
		goal=a[i+1];
		val=1;
		loc=i;
		tplus(root[i]);
	}
}
int main() {
	cin>>n>>m;
	for(int i=1; i<=n; i++) {
		cin>>v[i].dat;
		v[i].sit=i;
	}
	lsh();
	rs=0;
	root[0]=1;
	build(1,n,0);
	updata();
	for(int i=1; i<=m; i++) {
		cin>>le>>ri>>val;
		cout<<b[tfind(root[le-1],root[ri])]<<endl;
	}
}
```

---

## 作者：zhou2414 (赞：1)

# 主席树
## 简介
即可持久化线段树。~~明明可持久化数据结构有很多，但就它名字不一样~~。关于它名字的由来，读者可以自行上网查询。~~吃枣药丸~~。
## 功能
它可以解决历史版本修改查询问题。具体地，它可以支持以下操作：
- 选定某个历史版本的线段树，对其进行修改或者查询。

这么说可能有点难以理解，其实就是可以以较低的空间复杂度保存每一次修改前的信息，以便于查询。
## 原理和复杂度分析
首先来看最朴素的写法，即对于每一个历史版本，开一棵完整的线段树进行表示。如图：

![朴素主席树](https://cdn.luogu.com.cn/upload/image_hosting/l4a2fkp0.png)

其中 $root_i$ 表示第 $i$ 个版本对应的线段树根节点编号。

假设有 $m$ 个版本，那么空间复杂度为 $O(mn\log n)$，显然这样会浪费大量的空间。我们假设第二次修改修改了第四个叶子节点的信息，那么两个主席树本质不同的节点如下图红色节点所示：

![主席树本质不同节点](https://cdn.luogu.com.cn/upload/image_hosting/9g9isaoy.png)

显然白色节点没有必要新建。那么我们可不可以将两棵树合二为一呢？当然是可以的。如下图所示，蓝色节点为新建节点：

![主席树](https://cdn.luogu.com.cn/upload/image_hosting/ukxvjtu0.png)

即让两棵树共用相同的儿子。我们每次只新建修改路径上的节点，其余节点与上一个版本共用，这样每次修改至多增加 $\log n$ 个节点，那么总的空间复杂度就是 $O(n\log n+m\log n)$。查询只需要找到对应版本的根节点，然后正常向下查询即可，显然单次查询复杂度 $O(\log n)$。
## 正确性分析
首先证明新建版本不会影响之前版本信息。由于我们只对新建的节点进行修改，对于之前的版本没有进行任何修改，所以如果是查询之前版本的信息，那么该到哪一个节点并没有影响。

然后证明查询时不会查询到错误版本。当我们向下查询时，如果是新建的节点，那么自然是当前版本的信息没错。如果是共用的节点，那么说明对于共用这个节点的几个版本来说，此节点维护的信息都是一样的，那么显然是正确的。
## 实现
以下以权值线段树的基本操作为例。
### 修改
对于修改操作，先在要求的版本上进行向下递归，每递归到一个节点，就先新建一个节点，然后复制原节点的所有信息。对于需要修改的一个儿子，递归即可。返回时进行 `push_up`，同时将当前节点编号返回，以便于更新父亲的儿子。
#### 代码
示例中为一棵权值线段树，维护的是值域元素数量。
```cpp
inline void push_up(ll id){
	tr[id].sum=tr[tr[id].ls].sum+tr[tr[id].rs].sum;
}
ll add(ll id,ll l,ll r,ll x){//加入一个大小为x的数 
	ll idd=++cnt;//新的编号
	tr[idd].ls=tr[id].ls;
	tr[idd].rs=tr[id].rs;
	tr[idd].sum=tr[id].sum;
	if(l==r){
		tr[idd].sum++;
		return idd;
	}
	if(x<=mid){
		tr[idd].ls=add(tr[idd].ls,l,mid,x);
	}
	else{
		tr[idd].rs=add(tr[idd].rs,mid+1,r,x);
	}
	push_up(idd);
	return idd;//返回当前节点编号以更新父亲儿子
}
int main(){
    root[new_tree]=add(root[old_tree],1,N,x);
}
```
### 查询
如果要查询历史版本第 $k$ 小，那么只需要正常向下递归查询即可。（注意这并不是本题要求的查询）
#### 代码
```cpp
ll query(ll id,ll l,ll r,ll k){
	if(l==r)return l;
	if(k<=tr[tr[id].ls].sum){
		return query(tr[id].ls,l,mid,k);
	}else{
		return query(tr[id].rs,mid+1,r,k-tr[tr[id].ls].sum);
	}
}
```
# 本题解法
将序列的每一个前缀视为一个版本，开一棵主席树，节点维护值域元素数。如果查询区间 $[l,r]$ 的第 $k$ 小，那么就找到版本 $r$ 和版本 $l-1$，将两树对应位置的元素数相减，即可得到该区间对应的版本。

具体实现时，只把向下递归搜索到的节点相减，以节约时间。开始时可以先建一棵空树，以应对 $l-1=0$ 的情况。由于本题值域较大，所以需要进行离散化。
# 代码
只放关键部分。
```cpp
ll qu(ll u,ll v,ll l,ll r,ll k){//区间第k小，u初始时为root[l-1]，v初始时为root[r]
	if(l==r){
		return l;
	}
	ll zuo=tr[tr[u].ls].sum,you=tr[tr[v].ls].sum;
	ll now=you-zuo;
	if(now>=k){
		return qu(tr[u].ls,tr[v].ls,l,mid,k);
	} 
	else{
		return qu(tr[u].rs,tr[v].rs,mid+1,r,k-now);
	}
}
```
# 结语
主席树是可持久化数据结构中比较简单的一个。其他可持久化数据结构的思路与主席树没有太大区别，学懂主席树，再学其他可持久化数据结构可以事半功倍。

---


# [HEOI2012] 采花

## 题目描述

萧薰儿是古国的公主，平时的一大爱好是采花。

今天天气晴朗，阳光明媚，公主清晨便去了皇宫中新建的花园采花。

花园足够大，容纳了 $n$ 朵花，共有 $c$ 种颜色，用整数 $1 \sim c$ 表示。且花是排成一排的，以便于公主采花。公主每次采花后会统计采到的花的颜色数，颜色数越多她会越高兴。同时，她有一癖好，她不允许最后自己采到的花中，某一颜色的花只有一朵。为此，公主每采一朵花，要么此前已采到此颜色的花，要么有相当正确的直觉告诉她，她必能再次采到此颜色的花。

由于时间关系，公主只能走过花园连续的一段进行采花，便让女仆福涵洁安排行程。福涵洁综合各种因素拟定了 $m$ 个行程，然后一一向你询问公主能采到的花共有几种不同的颜色。

## 说明/提示

#### 输入输出样例 $1$ 解释

共有五朵花，颜色分别为 $1,~2,~2,~3,~1$。

对于第一次行程，公主采花的区间为 $[1, 5]$，可以采位置 $1,~2,~3,~5$ 处的花，共有 $1$ 和 $2$ 两种不同的颜色。

对于第二次行程，公主采花的区间为 $[1, 2]$，但是颜色为 $1$ 和 $2$ 的花都只出现了一次，因此公主无花可采。

对于第三次行程，公主采花的区间为 $[2, 2]$，但是颜色为 $2$ 的花只出现了一次，公主无花可采。

对于第四次行程，公主采花的区间为 $[2, 3]$，可以采 $2,~3$ 位置的花，只有 $2$ 这一种颜色。

对于第五次行程，公主采花的区间为 $[3,5]$，但是颜色为 $1, 2, 3$ 的花都只出现了一次，因此公主无花可采。

#### 数据范围与约定

**本题采用多测试点捆绑测试，共有两个子任务**。

对于子任务 $1$，分值为 $100$ 分，保证 $1 \leq n, c, m \leq 3 \times 10^5$。

对于子任务 $2$，分值为 $100$ 分，保证 $1 \leq n, c, m \leq 2 \times 10^6$。

对于全部的测试点，保证 $1 \leq x_i \leq c$，$1 \leq l \leq r \leq n$。

## 样例 #1

### 输入

```
5 3 5
1 2 2 3 1
1 5
1 2
2 2
2 3
3 5```

### 输出

```
2
0
0
1
0
```

# 题解

## 作者：wangjyqh (赞：90)

### 提供一个按照右端点排序的思路（类比hh的项链）
#### 回顾hh的项链，我们使用离线+树状数组，和last[j]表示上一次出现j的位置，对于第p个的数j,我们add(last[j],-1),add(p,1),因为我们按照r排序，只用管最右边的一个，所以留下最右端的就可以，对于一个询问直接树状数组求区间和；
#### 比较一下这两道题的区别，同样是计算颜色不同的数量，但是这道题目要求只有存在两个相同颜色这个颜色才做出贡献，怎么办呢？
#### 我们维护两个东西，last1[j]表示上上次出现j的位置,last2[j]表示上次出现的位置
#### 对于第p个的数j
#### 第一次出现j时没有用，我们直接记录last1=p;
#### 第二次出现j时，他就会产生代价，但值得注意的是我们不应该在第二次出现j的为位置上+1，而是在上一次出现的位置last1上+1，这是因为我们按照r从小到大排序,比如2,2,3这个序列，如果我们在第二次出现2的位置上+1，变成(0,1,0)，当询问[2,3]就不对了,应该在倒数第二次出现的位置+1变成(1,0,0);
#### 两次以上出现，我们只需要在倒数第2次的位置上+1，其他位置上出现j全部为零，实现：add(last1[j],-1);add(last2[j],1),last1=last2,last2=j;
### 扩展：如果将题目的限制改一改变成有n个颜色同时在询问区间，我们我们可以仍按照r递增排序，维护last1,last2,~~,lastn;让倒数第n次的位置上+1,其他出现j的位置上全是0
```
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
struct node
{
	int l,r,pos;
}t[2000010];
int last1[2000010],last2[2000010],c[2000010],a[2000010],ans[2000010];
int n,q,m;
inline bool cmp(node A,node B){
   return A.r<B.r;
}
inline void add(int x,int val){
    for(int i=x;i<=n;i+=(i&-i))c[i]+=val;
}
inline int query(int x){
    int ans=0;
    for(int i=x;i;i-=(i&-i))ans+=c[i];
    return ans;
}
int main(){
    scanf("%d%d%d",&n,&q,&m);
    for(int i=1;i<=n;++i)scanf("%d",&a[i]);
    for(int i=1;i<=m;++i){
       scanf("%d%d",&t[i].l,&t[i].r);
       t[i].pos=i;
    }
    sort(t+1,t+m+1,cmp);
    int j=1;
    for(int i=1;i<=m;++i){
    	for(;j<=t[i].r;++j){
           if(!last1[a[j]])last1[a[j]]=j;
           else {
           	  if(!last2[a[j]]){
           	  	add(last1[a[j]],1);
                last2[a[j]]=j;
           	  }else {
           	  	 add(last2[a[j]],1);
           	  	 add(last1[a[j]],-1);
           	  	 last1[a[j]]=last2[a[j]];
           	  	 last2[a[j]]=j;
           	  } 
           }
    	}
    	ans[t[i].pos]=query(t[i].r)-query(t[i].l-1);
    }
    for(int i=1;i<=m;++i)printf("%d\n",ans[i]);
    return 0;
}
```


---

## 作者：夏色祭 (赞：66)

隔壁有道和这题题意和样例一毛一样的题。。。就是数据范围小了点。。。

题意大概：给出n个数，求区间出现次数>=2的数的个数。

建议做这题之前可以先去做[hh的项链](https://www.luogu.org/problemnew/show/1972 "hh的项链")。

此题和那题做法类似。

我们只关心的是每个区间出现两次及以上的数的最后那个。

比如(1,2,3,2,3,1,1)，我们如果查询[1,7]，那么我们就可以把这个数列看成是(0,0,0,1,1,0,1)，然后用前缀和(用BIT维护)求出这个区间的答案。

具体怎么实现？

我用了一种离线的办法。

先把所有询问的区间都读进来，然后按l排序。

我们先对每个数第二次出现的位置标记为1。

因为现在l是有序的，我们可以从1开始往后搞，每次搞当前询问的l-1为止。如果与当前位置的数相同的下一个数的下一个数存在，我们就把那个数的位置标记为1，如果与当前位置的数相同的下一个数存在，说明我们之前把它标记过了，并且现在它不算了，因为要出现次数为>=2，而我们当前这个数已经不在是包含在询问的区间里的数了，所以它的下一个数肯定不是我们要标记的出现两次及以上的数的最后那个，所以我们要把它标记为0。

代码：


```cpp
#include<cstdio>
#include<algorithm>
#include<string>
#include<set>
#include<vector>
#include<map>
#define For(i,x,y) for (int i=(x);i<=(y);i++)
#define Dow(i,x,y) for (int i=(x);i>=(y);i--)
#define cross(i,k) for (int i=first[k];i;i=last[i])
#define il inline
#define vd void
#define ll long long
#define N 2000010
using namespace std;
namespace fast_IO {
    inline char read() {
        return getchar();
        static const int IN_LEN = 1000000;
        static char buf[IN_LEN], *s, *t;
        if (s == t) {
            t = (s = buf) + fread(buf, 1, IN_LEN, stdin);
            if (s == t) return -1;
        }
        return *s++;
    }
    template<class T>
    inline void read(T &x) {
        static bool iosig;
        static char c;
        for (iosig = false, c = read(); !isdigit(c); c = read()) {
            if (c == '-') iosig = true;
            if (c == -1) return;
        }
        for (x = 0; isdigit(c); c = read())
            x = ((x + (x << 2)) << 1) + (c ^ '0');
        if (iosig) x = -x;
    }
    const int OUT_LEN = 10000000;
    char obuf[OUT_LEN], *ooh = obuf;
    inline void print(char c) {
        if (ooh == obuf + OUT_LEN) fwrite(obuf, 1, OUT_LEN, stdout), ooh = obuf;
        *ooh++ = c;
    }
    template<class T>
    inline void print(T x) {
        static int buf[30], cnt;
        if (x == 0) {
            print('0');
        }
        else {
            if (x < 0) print('-'), x = -x;
            for (cnt = 0; x; x /= 10) buf[++cnt] = x % 10 + 48;
            while (cnt) print((char)buf[cnt--]);
        }
    }
    inline void flush() {
        fwrite(obuf, 1, ooh - obuf, stdout);
    }
}
using namespace fast_IO;
struct node{
    int l,r,id;
}q[N];
int c[N],ans[N],n,m,k,color[N],first[N],next[N],nnext[N],b[N];
il bool cmp(node x,node y){return x.l<y.l;}
il int lowbit(int x){return x&(-x);}
il vd add(int x,int y){
    for(int i=x;i<=n;i+=lowbit(i)) c[i]+=y;
}
il int query(int x){
    int sum=0;
    for (int i=x;i>0;i-=lowbit(i)) sum+=c[i];
    return sum;
}
int main(){
    read(n),read(k),read(m);
    For(i,1,n) read(color[i]);
    Dow(i,n,1){
        next[i]=first[color[i]];
        first[color[i]]=i;
    }
    For(i,1,n)
        nnext[i]=next[next[i]];
    For(i,1,n)
        if (++b[color[i]]==2) add(i,1);
    For(i,1,m){
        read(q[i].l),read(q[i].r);
        q[i].id=i;
    }
    sort(q+1,q+1+m,cmp);
    int now=1;
    For(i,1,m){
        for (;now<q[i].l;now++){
            if (next[now]) add(next[now],-1);
            if (nnext[now]) add(nnext[now],1);
        }
        ans[q[i].id]=query(q[i].r)-query(q[i].l-1);
    }
    For(i,1,m) print(ans[i]),print('\n');
    flush();
}
~~最后说一句：看到题目里的"萧薰儿"一下子就想到了斗破的动漫化，童年毁了啊~~
```

---

## 作者：Sky_star (赞：19)

用ne[i]记录下一个颜色i出现的位置

考虑离线做法我们不断从左往右扫

因为有一种花有两个才有贡献

所以如果我们即将扫过i点如果ne[ne[i]]存在则将ne[ne[i]]的贡献加1

这样就变成了前缀和

树状数组就可以过了

以下附代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
using namespace std;
int t[100001],n,m,c,mp[100001],ne[100001],p[100001];
struct gjh{int l,r,yd,ans;}q[100001];
int lb(int x){return x&(-x);}
void add(int x,int y){while(x<=n)t[x]+=y,x+=lb(x);}
int sum(int x){int num=0;while(x>0)num+=t[x],x-=lb(x);return num;}
bool cmp(gjh a,gjh b){return a.l==b.l?a.r<b.r:a.l<b.l;}
bool cmp1(gjh a,gjh b){return a.yd<b.yd;}
int main()
{
   int l=1;scanf("%d%d%d",&n,&c,&m);for(int i=1;i<=n;i++)scanf("%d",&mp[i]);
   for(int i=n;i>0;i--)ne[i]=p[mp[i]],p[mp[i]]=i;
   for(int i=1;i<=c;i++)if(p[i]&&ne[p[i]])add(ne[p[i]],1);
   for(int i=1;i<=m;i++)scanf("%d%d",&q[i].l,&q[i].r),q[i].yd=i;
   sort(q+1,q+m+1,cmp);
   for(int i=1;i<=m;i++)
   {
        for(;l<q[i].l;l++)
     {
       if(ne[l])add(ne[l],-1);
       if(ne[l]&&ne[ne[l]])add(ne[ne[l]],1);
     }
        q[i].ans=sum(q[i].r)-sum(q[i].l-1);
   }
   sort(q+1,q+m+1,cmp1);
   for(int i=1;i<=m;i++)printf("%d\n",q[i].ans);
   return 0;
}
```

---

## 作者：ix35 (赞：12)

## P4113 [HEOI2012]采花


数据毒瘤，只能拿133分，个人觉得这种数据加强没有意义，反而卡掉了一些复杂度正确的程序。

题目的意思是要求区间内出现超过1次的数的种类。看了一眼感觉是个主席树模板题。

首先将问题做一个转化，假设$pre[i]$表示$i$之前上一个等于$a[i]$的位置，这样我们要求的就是在$[l,r]$中满足$pre[i]>l$的所有位置（当然一个数字可能被统计多次，后面讲）。相当于是区间中值大于某一定值的数的个数。众所周知，主席树是一种二维数据结构，所以......

我们将$pre[i]$插入第$i$棵线段树$rt[i]$中，接下来做查询的时候，将$rt[r]$与$rt[l-1]$做差分，在差分结果上做$[l,r]$的区间和（或者直接做$[l,n]$，稍微快一点，但无法加分）即可。

注意到一个数可能被统计多次（如果区间内出现了三次就会被记两次），因此出现一个$pre[i]$时还可以将$pre[pre[i]]$在当前线段树中减去，也就是上次出现一定比上上次出现要晚，那么上上次就可以扔掉了。

时间复杂度$O(n\log n)$，第八个点$756ms$，最后两点$TLE$。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN=2000010;
int n,m,c,x,y,tot,rt[MAXN],ch[MAXN*40][2],val[MAXN*40],ts[MAXN],pre[MAXN];
int read () {
	int res=0;
	char c=getchar();
	while (c<'0'||c>'9') {c=getchar();}
	while (c>='0'&&c<='9') {
		res=res*10+c-'0';
		c=getchar();
	}
	return res;
}
void write (int x) {
	if (x==0) {putchar('0');}
	int cnt=0;
	char c[20];
	while (x>0) {
		c[++cnt]=(x%10)+'0';
		x/=10;
	}
	while (cnt>0) {putchar(c[cnt--]);}
	putchar('\n');
}
int buildt (int l,int r) {
	int nd=++tot;
	if (l==r) {return nd;}
	int mid=(l+r)>>1;
	ch[nd][0]=buildt(l,mid),ch[nd][1]=buildt(mid+1,r);
	return nd;
}
int add (int rt,int l,int r,int pos,int v) {
	if (pos==0) {return rt;}
	int nd=++tot;
	val[nd]=val[rt]+v;
	if (l==r) {return nd;}
	int mid=(l+r)>>1;
	if (pos<=mid) {
		ch[nd][0]=add(ch[rt][0],l,mid,pos,v);
		ch[nd][1]=ch[rt][1];
	} else {
		ch[nd][1]=add(ch[rt][1],mid+1,r,pos,v);
		ch[nd][0]=ch[rt][0];
	}
	return nd;
}
int query (int rt1,int rt2,int l,int r,int pl,int pr) {
	if (pr<l||r<pl) {return 0;}
	if (pl<=l&&r<=pr) {return val[rt1]-val[rt2];}
	int mid=(l+r)>>1;
	return query(ch[rt1][0],ch[rt2][0],l,mid,pl,pr)+query(ch[rt1][1],ch[rt2][1],mid+1,r,pl,pr);
}
int main () {
	n=read(),c=read(),m=read();
	rt[0]=buildt(1,c);
	for (int i=1;i<=n;i++) {
		x=read();
		pre[i]=ts[x];
		ts[x]=i;
		rt[i]=add(rt[i-1],1,c,pre[pre[i]],-1);
		rt[i]=add(rt[i],1,c,pre[i],1);
	}
	for (int i=1;i<=m;i++) {
		x=read(),y=read();
		write(query(rt[y],rt[x-1],1,c,x,n));
	}
	return 0;
}
```


---

## 作者：Isonan (赞：10)

原题传送门[>Here<](https://www.luogu.org/problemnew/show/P4113)

（这题虽然好像可以用莫队做，标签里也有个莫队，但是做法和正常的莫队有很大的区别，害得我莫队搞了半天还是只有133分。）

考虑对于一个区间[l,r],一种颜色c被计入答案当且仅当该颜色在该区间中出现过两次。即：存在i使得$l\le i\le r$且col[i]==c且$l\le last[i]\le r$。

仔细分析这个式子，我们发现在r确定的时候，我们只要保证c从r开始从右往左第二次出现的位置$\ge l$就可以了。

举个例子：

1 2 3 4 5 6 7 8 **9** 10

3 2 1 2 **4** 2 **4** 1 2 3

当一个区间r==9的时候，只要$l \le 5$就可以保证颜色4一定会被计入答案中。

于是把询问按照r排序，用树状数组存储每种颜色从右往左第二个出现的位置。

设last[i]为i之前第一个与i颜色相同的位置。

维护很简单，每次新加入一个位置i时，把last[i]++,last[last[i]]--就可以了。

代码：

```cpp
#include <cstdio>
#include <algorithm>
#include <cmath>

int count[2000001];
int pos[2000010],n,m,num[2000010],block,ori[2000001],all[2000001],c[2000001],C,last[2000001],colst[2000001];
int ans[2000010],nowans;
struct point{
    int l,r,orig;
}q[2000010];
bool cmp(point a,point b){return a.r<b.r;}
void update(int x,int ad){if(!x)return;for(;x<=n;x+=x&-x)c[x]+=ad;}
int query(int x){if(!x)return 0;int tot=0;for(;x;x-=x&-x)tot+=c[x];return tot;}
int read(){
    int x=0;
    char ch=getchar();
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();
    return x;
}
int main(){
    n=read();
    C=read();
    m=read();
    for(register int i=1;i<=n;++i){
        num[i]=read();
        last[i]=colst[num[i]];
        colst[num[i]]=i;
    }
    for(register int i=1;i<=m;++i)q[i].l=read(),q[i].r=read(),q[i].orig=i;
    std::sort(q+1,q+m+1,cmp);
    for(register int i=1,j=1;i<=n;++i){
    	update(last[i],1);
    	update(last[last[i]],-1);
    	for(;q[j].r==i&&j<=m;j++)ans[q[j].orig]=query(i)-query(q[j].l-1);
    	if(j>m)break;
    }
    for(register int i=1;i<=m;++i)printf("%d\n",ans[i]);
}
```

---

## 作者：Hercules (赞：7)

## 题解：P4113 [HEOI2012]采花

这到题的话有2个子任务，想拿到100分还是很容易的，用莫队就可以。

但是数据范围更大的话就会TLE，所以我们可以用一些其他的更快捷的方法：树状数组 or 线段树

这里推荐的还是树状数组，因为常数更小一点，写这道题之前可以先看一下[HH的项链](https://www.luogu.com.cn/problem/P1972)，做法相似。

---

非强制在线，因此我们可以根据每次行程**右端点从小到大**排序。

从第1朵花开始，分别到当前枚举行程的右端点，然后再走到下一个行程的右端点。

我们需要维护两个数组，分别是当前枚举的 $ j $ 点上一个 $a[j]$ 的位置 $last1[a[j]]$ 以及上上个 $a[j]$ 的位置  $last2[a[j]]$ 

只有此颜色的花存在数量大于1个，才会产生贡献，

因此在 $last2[a[j]]$ 存在的时候，就把 $last2[a[j]]$ 贡献 $+1$ ，其他位出现 $a[j]$ 全部为 $0$ 。

最后用前缀和来求 $ans[e[i].pos] = query(e[i].r) - query(e[i].l - 1)$ 就好。

```c++
#include <bits/stdc++.h>

const int MAXN = 2e6 + 10;
struct Node {int l, r, pos;}e[MAXN];
int n, c, m, a[MAXN], last1[MAXN], last2[MAXN], val[MAXN], ans[MAXN];

inline int read() {
    int X = 0, flag = 0;
    char ch = 0;
    while (!isdigit(ch))
        flag |= ch == '-', ch = getchar();
    while (isdigit(ch))
        X = (X << 3) + (X << 1) + (ch ^ 48), ch = getchar();
    return flag ? -X : X;
}

inline bool cmp(Node x, Node y) {
    return x.r < y.r;
}

inline void add(int x, int num) {
    for (register int i = x; i <= n; i += (i & (-i)))
        val[i] += num;
}

inline int query(int x) {
    int res = 0;
    for (register int i = x; i; i -= (i & (-i)))
        res += val[i];
    return res;
}

signed main() {
#ifndef ONLINE_JUDGE
#ifdef LOCAL
    freopen("testdata.in", "r", stdin);
    freopen("testdata.out", "w", stdout);
#endif
#ifndef LOCAL
    freopen("HEOI2012采花.in", "r", stdin);
    freopen("HEOI2012采花.out", "w", stdout);
#endif
#endif
    n = read(), c = read(), m = read();
    for (register int i = 1; i <= n; i++)
        a[i] = read();
    for (register int i = 1; i <= m; i++)
        e[i].l = read(), e[i].r = read(), e[i].pos = i;
    std::sort(e + 1, e + m + 1, cmp);
    for (register int i = 1; i <= m; i++) {
        for (register int j = e[i - 1].r + 1; j <= e[i].r; j++) {
            if (!last2[a[j]]) {
                last2[a[j]] = j;
            } else {
                if (!last1[a[j]]) {
                    add(last2[a[j]], 1), last1[a[j]] = j;
                } else {
                    add(last2[a[j]], -1), add(last1[a[j]], 1);
                    last2[a[j]] = last1[a[j]], last1[a[j]] = j;
                }
            }
        }
        ans[e[i].pos] = query(e[i].r) - query(e[i].l - 1);
    }
    for (register int i = 1; i <= m; i++)
        printf("%d\n", ans[i]);
    return 0;
}
```







---

## 作者：一扶苏一 (赞：6)

## Description

给定一个长度为 $n$ 的序列，有 $m$ 次询问，每次询问一段区间，求区间中有多少个数出现次数超过 $1$ 次

## Limitation

$n,~m~\leq~2~\times~10^6$

## Solution

好像和大众做法不大一样？

考虑对于每个位置，我们记一个 ``pre`` 和一个 ``post``，代表他前面最后一个出现这个数的位置和他后面第一个出现这个数的位置。

考虑一个位置 $x$ 对一个 $[l,~r]$ 的查询产生贡献当且仅当 $pre_x~\geq~l$ 并且 $post_x~>~r$。

我们发现这个东西是可以树状数组维护的。

考虑统计一段区间内 ``pre`` 大于等于某个数的个数显然可以对 ``pre`` 开权值树状数组，然后按照左端点不升序排序，左端点左移的时候将对应位置的 ``pre`` 加入树状数组，一次查询的答案即为 $BIT_{r}~-~BIT_{l - 1}$。

现在考虑加入 $post_x ~>~r$ 的限制。

我们发现当且仅当满足该条件的位置才对答案有贡献，于是我们只需要保证树状数组里只存有满足该条件的位置的 ``pre``，就可以统计答案了。考虑按照右端点不升序排序，一开始先将最后一次出现的数字的 ``pre`` 加入到树状数组中，每次移动右端点的时候，将 ``post`` 为右端点所在位置的位置的 ``pre`` 加入树状数组即可(即将 $post_x~=~R$ 的 $x$ 的对应 $per_x$ 加入树状数组)。由于大于右端点的部分的 ``pre`` 对答案同样没有贡献了，所以移动右端点的时候别忘了把右端点对应的 ``pre`` 在树状数组上删除。

## Code

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>
#ifdef ONLINE_JUDGE
#define freopen(a, b, c)
#endif

typedef long long int ll;

namespace IPT {
    const int L = 1000000;
    char buf[L], *front=buf, *end=buf;
    char GetChar() {
        if (front == end) {
            end = buf + fread(front = buf, 1, L, stdin);
            if (front == end) return -1;
        }
        return *(front++);
    }
}

template <typename T>
inline void qr(T &x) {
    char ch = IPT::GetChar(), lst = ' ';
    while ((ch > '9') || (ch < '0')) lst = ch, ch=IPT::GetChar();
    while ((ch >= '0') && (ch <= '9')) x = (x << 1) + (x << 3) + (ch ^ 48), ch = IPT::GetChar();
    if (lst == '-') x = -x;
}

namespace OPT {
    char buf[120];
}

template <typename T>
inline void qw(T x, const char aft, const bool pt) {
    if (x < 0) {x = -x, putchar('-');}
    int top=0;
    do {OPT::buf[++top] = static_cast<char>(x % 10 + '0');} while (x /= 10);
    while (top) putchar(OPT::buf[top--]);
    if (pt) putchar(aft);
}

const int maxn = 2000010;

int n, c, m, dn;
int MU[maxn], oc[maxn], pos[maxn], pre[maxn], tree[maxn];
std::vector<int> vc[maxn];

struct Ask {
    int l, r, id, ans;
    
    inline bool operator<(const Ask &_others) const {
        return this->r > _others.r;
    }
};
Ask ask[maxn];
bool cmp(const Ask&, const Ask&);

int lowbit(int);
void update(int, int);
int query(int);

int main() {
    freopen("1.in", "r", stdin);
    qr(n); qr(c); qr(m); dn = n + 1;
    for (int i = 1; i <= n; ++i) {
        qr(MU[i]); pre[i] = oc[MU[i]]; oc[MU[i]] = i;
    }
    for (int i = 1; i <= c; ++i) oc[i] = dn;
    for (int i = n; i; --i) {
        vc[pos[i] = oc[MU[i]]].push_back(i);
        oc[MU[i]] = i;
    }
    for (int i = 1; i <= m; ++i) {
        qr(ask[i].l); qr(ask[i].r); ask[i].id = i;
    }
    std::sort(ask + 1, ask + 1 + m);
    for (auto i : vc[dn]) update(pre[i], 1);
    for (int i = 1, R = n; i <= m; ++i) {
        int l = ask[i].l, r = ask[i].r;
        while (R > r) {
            update(pre[R], -1);
            for (auto j : vc[R]) update(pre[j], 1);
            --R;
        }
        ask[i].ans = query(r) - query(l - 1);
    }
    std::sort(ask + 1, ask + 1 + m, cmp);
    for (int i = 1; i <= m; ++i) {
        qw(ask[i].ans, '\n', true);
    }
    return 0;
}

inline bool cmp(const Ask &_a, const Ask &_b) {
    return _a.id < _b.id;
}

inline int lowbit(int x) {return x & -x;}

void update(int x, int v) {
    if (x == 0) return;
    while (x <= dn) {
        tree[x] += v;
        x += lowbit(x);
    }
}

int query(int x) {
    int _ret = 0;
    while (x) {
        _ret += tree[x];
        x -= lowbit(x);
    }
    return _ret;
}
```



---

## 作者：SovietPower✨ (赞：6)

本题解可能无法通过所有数据，仅供参考。

我用的莫队，和HH的项链很像，时间复杂度在O(n√n)。

莫队算法是一种离线算法，通常不能有修改 操作。

莫队算法的实现步骤为：

1、先对原序列进行分块。

2、离线操作，对询问进行排序，以左端点所在块编号 为第一关键字，右端点的位置为第二关键字，进行排序。然后维护[l,r]的答案，并不断调整l和r。（具体还请百度）

对于这题，如果在询问区间内有一种颜色出现次数>1，就可以++now；出现次数减到1时，--now。

```cpp
#include<cmath>
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=1000005;

int n,c,m,size,color[N],Times[N],now,ans[N];
struct Ques
{
    int l,r,id;
}q[N];

int read()
{
    int now=0;char c=getchar();
    while(c<'0'||c>'9')c=getchar();
    while(c>='0'&&c<='9')now=(now<<3)+(now<<1)+c-'0',c=getchar();
    return now;
}

bool cmp(Ques a,Ques b)
{//左端点所在块为第一关键字，右端点为第二关键字 
    //if((a.l-1)/size+1 == (b.l-1)/size+1) return a.r < b.r;
    if(a.l/size == b.l/size) return a.r < b.r;
    return a.l/size < b.l/size;
}

inline void Add(int p)
{
    ++Times[p];
    if(Times[p]==2)
      ++now;
}
inline void Subd(int p)
{
    --Times[p];
    if(Times[p]==1)
      --now;
}

int main()
{
//    freopen("1flower.in","r",stdin);
//    freopen("1flower.out","w",stdout);
    n=read();c=read();m=read();
    size=sqrt(n);
    for(int i=1;i<=n;i++)
      color[i]=read();
    for(int i=1;i<=m;i++)
      q[i].l=read(),q[i].r=read(),q[i].id=i;
    sort(q+1,q+1+m,cmp);
    for(int i=1,l=1,r=0;i<=m;i++)
    {
        int ln=q[i].l,rn=q[i].r;
        while(l>ln)
          Add(color[--l]);
        while(l<ln)
          Subd(color[l++]);
        while(r<rn)
          Add(color[++r]);
        while(r>rn)
          Subd(color[r--]);
        ans[q[i].id]=now;
    }
    for(int i=1;i<=m;i++)
      printf("%d\n",ans[i]);
//    fclose(stdin);fclose(stdout);
    return 0;
}
```

---

## 作者：Great_Influence (赞：5)

本题解可能无法通过所有数据，仅供参考。

暴力主席树。

具体思路就是主席树暴力维护花的数量，暴力计算。

代码：

```cpp
#include<bits/stdc++.h>
#include<cctype>
#include<algorithm>
#include<deque>
#define For(i,a,b) for(i=(a);i<=(b);++i)
#define Forward(i,a,b) for(i=(a);i>=(b);--i)
using namespace std;
template<typename T>inline void read(T &x)//快读
{
    T s=0,f=1;char k=getchar();
    while(!isdigit(k)&&(k^'-'))k=getchar();
    if(!isdigit(k)){f=-1;k=getchar();}
    while(isdigit(k)){s=s*10+(k^48);k=getchar();}
    x=s*f;
}
const int MAXN=100010;
int n,m,c,head[MAXN],e;//head是主席树的根数组
struct node
{
    int l,r,count;
}p[MAXN<<4];//节点
void make_tree(int poi,int l,int r)//建立空树
{
    if(l==r)return;
    int mid=(l+r)>>1;
    make_tree(p[poi].l=++e,l,mid);
    make_tree(p[poi].r=++e,mid+1,r);
}
void build(int now,int last,int l,int r,int x)//加入新树
{
    if(l==r)
    {
        p[now].count=p[last].count+1;
        return;
    }
    int mid=(l+r)>>1;
    if(x<=mid)
    {
        p[now].r=p[last].r;
        build(p[now].l=++e,p[last].l,l,mid,x);
    }
    else
    {
        p[now].l=p[last].l;
        build(p[now].r=++e,p[last].r,mid+1,r,x);
    }
    p[now].count=p[p[now].l].count+p[p[now].r].count;
}
int query(int now,int last,int l,int r)//查询
{
    //printf("%d %d %d\n",l,r,p[now].count-p[last].count);
    if(p[now].count-p[last].count<2)return 0;
    if(l==r)return 1;
    int mid=(l+r)>>1,ans=0;
    ans=query(p[now].l,p[last].l,l,mid)+query(p[now].r,p[last].r,mid+1,r);
    return ans;
}
int main(void)
{
    read(n);
    read(c);
    read(m);
    int i,l,r,k;
    make_tree(head[0]=++e,1,c);//先建一颗空树作为基础树
    For(i,1,n)read(k),build(head[i]=++e,head[i-1],1,c,k);//再在空树的基础上log2n地更新节点
    while(m--)
    {
        read(l),read(r);
        printf("%d\n",query(head[r],head[l-1],1,c));//查询
    }
    return 0;
}
```

---

## 作者：VioletIsMyLove (赞：3)

题的实质就是寻找 $[l,r]$ 区间出现次数 $>=2$ 的数字的个数,闭区间里面同一个数字有那么多，其实我们只关注离我最近的那 $1$ 个就OK了;

查看那小子所在位置是否 $>=l$,忽然发现这不就抽象成线段了吗?那左端点给1，接下来就是在 $[l,r]$ 闭区间里面统计 $1$ 的数量，
显然前缀和啊，借助于树状数组不就完美的干掉了嘛，实现时记得处理一个擦一个就OK!

Code:
```cpp
#include<bits/stdc++.h>
#define maxn 2000005
#define maxm 6000005
using namespace std;
int n,m,C,c[maxn],lst[maxn],pos[maxn],ans[maxm];
struct ZS{
    int l,r,id;
    bool operator <(const ZS B)const{return r<B.r;}
}Q[maxm];
int read(){
    int ret=0,f=1;char ch=getchar();
    while (!isdigit(ch)){if (ch=='-')f=-f;ch=getchar();}
    while (isdigit(ch)) ret=(ret<<3)+(ret<<1)+ch-'0',ch=getchar();
    return ret*f;
}
void add_data(int x,int date){
	if (!x) return;
	for (;x<=n;x+=x&-x) c[x]+=date;
}
int Ask(int x){
	if (!x) return 0;
	int tot=0;
	for (;x;x-=x&-x) tot+=c[x];
	return tot;
}
int main(){
    n=read();C=read();m=read();
    for (int i=1;i<=n;i++){
        int x=read();
        lst[i]=pos[x];pos[x]=i;
    }
    for (int i=1;i<=m;i++) Q[i].l=read(),Q[i].r=read(),Q[i].id=i;
    sort(Q+1,Q+1+m);
    for (int i=1,j=1;i<=n&&j<=m;i++){
        add_data(lst[lst[i]],-1),add_data(lst[i],1);
        for (;Q[j].r==i&&j<=m;j++) ans[Q[j].id]=Ask(i)-Ask(Q[j].l-1);
    }
    for (int i=1;i<=m;i++)printf("%d\n",ans[i]);
    return 0;
}
```


---

## 作者：abs001 (赞：3)

此题的本质就是在一个区间内找到出现2次的颜色的数量，可以离线解决

全部输入进来之后按r从小到大排序

然后用la1[t]表示颜色t上一次出现的位置，la2[t]表示颜色t上上次出现的位置

则在树状数组里只有将la1[t]的位置填1，其他填0即可

为什么这样可以ac呢？因为当l在上次与最右边之间，最右边颜色是没有贡献的，当l在上上次与最右边之间，上上次的颜色也是没有贡献的，所以只有la1[t]上次的颜色有贡献。

下面贴上代码
# O2优化可过，直接交可得133分

```cpp
#include<bits/stdc++.h>
#define N 2000001
#define M 2000001
using namespace std;

struct node{
    int x, y, z, ans;
    bool operator < (const node &a) const
    {
        return y < a.y;
    }
}q[M];

int n, m, cnt;
int a[N], b[N], la1[N], la2[N], tree[N];

int js(int x)
{
    return x & -x;
}

void change(int x, int y)
{
    for(; x <= n; x += js(x))
        tree[x] += y;
}

int sum(int x)
{
    int ret = 0;
    for(; x; x -= js(x)) ret += tree[x];
    return ret;
}

bool cmp(node l, node r)
{
    return l.z < r.z;
}

int main()
{
    scanf("%d%d%d", &n, &m, &m);
    for(int i = 1; i <= n; i++) scanf("%d", &a[i]), b[i] = a[i];
    for(int i = 1; i <= m; i++) scanf("%d%d", &q[i].x, &q[i].y), q[i].z = i;
    sort(q + 1, q + m + 1);//排序
    sort(b + 1, b + n + 1);
    cnt = unique(b + 1, b + n + 1) - b - 1;//离散化
    for(int i = 1, j = 1; i <= m; i++)
    {
        while(j <= q[i].y)
        {
            int t = lower_bound(b + 1, b + cnt + 1, a[j]) - b;
            if(la2[t]) change(la2[t], -1);//上上次
            if(la1[t]) change(la1[t], 1);//上次
            la2[t] = la1[t], la1[t] = j, j++;
        }
        q[i].ans = sum(q[i].y) - sum(q[i].x - 1);
    }
    sort(q + 1, q + m + 1, cmp);
    for(int i = 1; i <= m; i++) printf("%d\n", q[i].ans);
    return 0;
}
```


---

## 作者：mengbierr (赞：3)

考虑将询问离线。考虑每种颜色的花对答案的贡献，我们发现，对于一个位置上的花，若左端点在从1到上一个与该位置颜色相同的花的位置上，则该颜色对答案有贡献。所以将所有询问按1右端点从小到大排序，定义pre[i]为与该位置距离最近的与它颜色相同的花。对于一个位置，将pre[pre[i]]+1–pre[i]这段区间+1，然后每次询问的答案就是L上的值了，可以用线段树区间加，单点查询来做。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;
const int inf=1000000000;
int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
struct segtree
{
    int ls;
    int rs;
    int mark;
    long long sum;
}tree[4000005];
struct query
{
    int l;
    int r;
    int id;
}q[1000005];
int tot=1,next[1000005],pre[1000005],last[1000005],n,c,m,ans[1000005],a[1000005];
int cmp(query x,query y)
{
    return x.r<y.r;
}
void build(int p,int l,int r)
{
    int mid=l+r>>1;
    if(l==r)
    return;
    tree[p].ls=++tot;
    tree[p].rs=++tot;
    build(tree[p].ls,l,mid);
    build(tree[p].rs,mid+1,r);
}
void modify(int p,int l,int r,int x,int y)
{
    int mid=l+r>>1;
    if(l==x&&r==y)
    {
        tree[p].mark++;
        tree[p].sum+=(r-l+1);
        return;
    }
    tree[tree[p].ls].sum+=(mid-l+1)*tree[p].mark;
    tree[tree[p].rs].sum+=(r-mid)*tree[p].mark;
    tree[tree[p].ls].mark+=tree[p].mark;
    tree[tree[p].rs].mark+=tree[p].mark;
    tree[p].mark=0;
    if(y<=mid)
    modify(tree[p].ls,l,mid,x,y);
    else if(x>mid)
    modify(tree[p].rs,mid+1,r,x,y);
    else
    {
        modify(tree[p].ls,l,mid,x,mid);
        modify(tree[p].rs,mid+1,r,mid+1,y);
    }
    tree[p].sum=tree[tree[p].ls].sum+tree[tree[p].rs].sum;
}
int query(int p,int l,int r,int x)
{
    if(l==r)
    return tree[p].sum;
    int mid=l+r>>1;
    tree[tree[p].ls].sum+=(mid-l+1)*tree[p].mark;
    tree[tree[p].rs].sum+=(r-mid)*tree[p].mark;
    tree[tree[p].ls].mark+=tree[p].mark;
    tree[tree[p].rs].mark+=tree[p].mark;
    tree[p].mark=0;
    if(x<=mid)
    return query(tree[p].ls,l,mid,x);
    return query(tree[p].rs,mid+1,r,x);
}
int main()
{
    n=read(),c=read(),m=read();int now=1;
    for(int i=1;i<=n;i++)
    {
        a[i]=read();
        pre[i]=last[a[i]];
        last[a[i]]=i;
    }
    for(int i=1;i<=m;i++)
    {
        q[i].l=read(),q[i].r=read();
        q[i].id=i;
    }
    sort(q+1,q+m+1,cmp);
    build(1,1,n);
    for(int i=1;i<=n;i++)
    {
        if(pre[i])
        {
            modify(1,1,n,pre[pre[i]]+1,pre[i]);
        }
        while(q[now].r==i)
        {
            ans[q[now].id]=query(1,1,n,q[now].l);
            now++;
        }
        if(now>m)
        break;
    }
    for(int i=1;i<=m;i++)
    {
        printf("%d\n",ans[i]);
    }
}
```
[我的博客](http://blog.csdn.net/mengbi\_er/article/details/77945890)


---

## 作者：Taduro (赞：2)

### 题意

求区间中出现两次的颜色的个数，卡莫队。

### 做法

这题是HH的项链那题的变形吧，但那题我用莫队水过去了，于是到这题就自闭了。

首先做法是离线，将询问以l为第一关键字,r为第二关键字排序，这样我们得到一个l有序的询问序列。

对于每种颜色，预处理出它第一次出现的位置$p[i]$和每个位置后一个位置$nx[i]$。

用一个l指针从左往右扫，用树状数组维护前缀和，使l后每个颜色的**第二个**出现位置上的值为一，之后就是求$[l,r]$的和。

具体实现代码如下：

```c++
for (int i=1; i<=m; i++){
		for (int j=next; j<q[i].l; j++){
			if (nx[j]) add(nx[j],-1);
			if (nx[j]&&nx[nx[j]]) add(nx[nx[j]],1);
		}
		next=q[i].l;
		num[q[i].h]=query(q[i].r)-query(q[i].l-1);
	}
```

我觉得我讲的并不太易懂，所以带大家来看一组样例。


![](https://cdn.luogu.com.cn/upload/pic/48233.png )


~~感觉我这个样例十分垃圾~~

由于我太菜了做不出动态图，所以大家可以无视我的箭头和指针单玩样例。

### 完整代码

```c++
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
struct node{
	int l,r,h;
}q[2000001];
int a[2000010],nx[2000001],p[2000001];
int next=1,num[2000001],n,m,k,c[2000001];
inline bool cmp(node c,node d){return c.l!=d.l?c.l<d.l:c.r<d.r;}
inline int lowbit(int x){return x&(-x);}
inline void add(int x,int y){while(x<=n) c[x]+=y,x+=lowbit(x);}
inline int query(int x){int ans=0;while(x)ans+=c[x],x-=lowbit(x);return ans;}
int main(){
	scanf("%d%d%d",&n,&k,&m);
	for (int i=1; i<=n; i++) scanf("%d",&a[i]);
	for (int i=n; i>=1; i--) nx[i]=p[a[i]],p[a[i]]=i;
	for (int i=1; i<=k; i++) if (p[i]&&nx[p[i]]) add(nx[p[i]],1);
	for (int i=1; i<=m; i++){
		scanf("%d%d",&q[i].l,&q[i].r);
		q[i].h=i;
	}
	sort(q+1,q+m+1,cmp);
	for (int i=1; i<=m; i++){
		for (int j=next; j<q[i].l; j++){
			if (nx[j]) add(nx[j],-1);
			if (nx[j]&&nx[nx[j]]) add(nx[nx[j]],1);
		}
		next=q[i].l;
		num[q[i].h]=query(q[i].r)-query(q[i].l-1);
	}
	for (int i=1; i<=m; i++) printf("%d\n",num[i]);
	return 0;
}
```



---

## 作者：Jiang_zi_chuan (赞：2)

好久没写题解了，有点怀念

因为我最近在练莫队，所以这道题一眼看过就码了个莫队，然后愉快地Tle了。。

看到这道题的数据范围，发现莫队是不行的，看题解发现了一种树状数组的玩法。

然后我一直用pascal捣鼓，结果一直wa得只有10分，实在是找不出问题。

不过我今天突然想到可以用c++搞一搞，结果就真的过了。

思路：

用Next[i]表示与第i朵花颜色相同的下一朵花的位置

发现：一段区间内，从左到右第二次出现的颜色对ans产生贡献，所以可以用树状数组维护前缀和。

那么Next就是用于快速得到某一段区间的第二次出现的颜色

对于查询则是用离线

LuoGu加强数据后最后一个点一直Tle，加了氧气才过掉了，不过原始数据我的程序还是跑的过的，BZOJ里也ac了

但！为防止抄袭，我就不粘AC代码了，粘一个T的吧（具体代码还要自己写哦！！！）

```cpp
#include <bits/stdc++.h> 
using namespace std; 
#define res register int 
#define maxn 2000010 
#define inf 2147483647 
struct node { 
	int l, r, id, ans; 
}; 
node q[maxn]; 
int Next[maxn], color[maxn], p[maxn], n, m, c, tree[maxn]; 
inline int read() { 
	int s = 0, w = 1; 
	char c = getchar(); 
	while (c < '0' || c > '9') { 
		if (c == '-') w = -1; 
		c = getchar(); 
	} 
	while (c >= '0' && c <= '9') 
		s = (s << 3) + (s << 1) + (c ^ 48), c = getchar(); 
	return s * w; 
} 
inline bool cmp1(node x, node y) {
	return x.l == y.l ? x.r < y.r : x.l < y.l;
} 
inline bool cmp2(node x, node y) {
	return x.id < y.id;
} 
inline void add(int x, int y) {
	for (; x <= n; x += (x & (-x))) 
		tree[x] += y;
} 
inline int query(int x) {
	int sum = 0; 
	for (; x > 0; x -= (x & (-x))) 
		sum += tree[x]; 
	return sum;
} 
int main() { 
	n = read(), c = read(), m = read(); 
	for (res i = 1; i <= n; ++i) 
		color[i] = read(); 
	for (res i = n; i > 0; --i) 
		Next[i] = p[color[i]], p[color[i]] = i; 
	for (res i = 1; i <= c; ++i) 
		if (p[i] && Next[p[i]]) 
			add(Next[p[i]], 1); 
	for (res i = 1; i <= m; ++i) 
		q[i].l = read(), q[i].r = read(), q[i].id = i; 
	sort(q + 1, q + 1 + m, cmp1); 
	int l = 1; 
	for (res i = 1; i <= m; ++i) { 
		for (; l < q[i].l; ++l) { 
			if (Next[l]) add(Next[l], -1); 
			if (Next[l] && Next[Next[l]]) add(Next[Next[l]], 1); 
		} 
		q[i].ans = query(q[i].r) - query(q[i].l - 1); 
	} 
	sort(q + 1, q + 1 + m, cmp2); 
	for (res i = 1; i <= m; ++i) printf("%d\n", q[i].ans); 
	return 0; 
}
```

---

## 作者：HomuraCat (赞：0)

树状数组+离线

以询问的右节点排序，考虑左节点对答案的贡献

枚举右端点，到达一个颜色k，记$pre[k]$为当前颜色k前面的第一个颜色k，记$pp[k]$表示当前颜色k前面的第二个颜色k，那么当右端点到达k的时候，将区间$(pp_k, pre_k]$加一即可，（因为左节点在这一段的时候这种颜色会有贡献。

可以用常数小的树状数组维护差分数组，相当于有了单点查询区间修改的功能。

此题卡常，请开O2或者读优

代码：

```cpp
#include<bits/stdc++.h> 
#define Re register
#define fo(i, a, b) for (Re int i = (a); i <= (b); ++i)
#define fd(i, a, b) for (Re int i = (a); i >= (b); --i)
#define edge(i, u) for (Re int i = head[u], v = e[i].v; i; i = e[i].nxt, v = e[i].v)
#define pb push_back
#define F first
#define S second
#define ll long long
#define inf 10000000000007
#define mp std::make_pair
#define lowbit(x) (x & -x)
#define eps 1e-4
#define itset std::set<node>::iterator
#define lb lower_bound
#define N 2000005
#define ls (k << 1)
#define rs (k << 1 | 1)
#define M 260
int n, m, c, a[N], pre[N], ans[N], pp[N];
struct node{
    int l, r, id;
    friend bool operator < (node x, node y)
    {
        return x.r < y.r;
    }
}q[N];
int t[N];
inline void add (int x, int val) {for (int i = x; i <= n; i += lowbit(i)) t[i] += val;}
inline int query (int x) {int ret = 0; for (int i = x; i; i -= lowbit(i)) ret += t[i]; return ret;}
int main ()
{
    scanf("%d %d %d", &n, &c, &m);
    fo (i, 1, n)
        scanf("%d", &a[i]);
    fo (i, 1, m)
    {
        scanf("%d %d", &q[i].l, &q[i].r);
        q[i].id = i;
    }
    std::sort(q + 1, q + m + 1);
    int j = 1;
    fo (i, 1, n)
    {
        add(pre[a[i]] + 1, -1);
        add(pp[a[i]] + 1, 1);
    //    printf("%d %d +1\n", pp[a[i]] + 1, pre[a[i]]);
        pp[a[i]] = pre[a[i]];
        pre[a[i]] = i;
        while (q[j].r == i)
        {
            ans[q[j].id] = query(q[j].l);
            ++j;
        }
    }
    fo (i, 1, m)
        printf("%d\n", ans[i]);
    return 0;
}
```

---

## 作者：王珩030115 (赞：0)

这道题我们采取离线+树状数组的方法。
首先，处理出nxt[i]，表示与a[i]相等的后一个数的位置，那么对于一个a[i]，它对于nxt[i]及以后肯定有贡献+1，用树状数组在nxt[i]处+1,add(nxt[i],1)即可。（注意只有a[i]这种颜色在第一次出现时才有贡献）


------------

假设所有询问的左端点均为1，那么使用上述累加一遍即可求出答案，但由于现在左端点在变化，怎么办呢？  
把询问按左端点排序就行啦！  
从上一个 l 转移到现在的 l 时，把之间的颜色的贡献清楚，换成人话，就是用树状数组在nxt[i]处-1,add(nxt[i],-1)，然后再在nxt[nxt[i]]处+1（如果存在的话），这样的话，每次询问的ans=quiry(r)-quiry(l-1);
```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
struct st{
    int id,l,r;
};
int i,j,k,n,m,c,last,lst[2000005],nxt[2000005],a[2000005],ans[2000005],c1[2000005];
st q[2000005];
inline void read(int& x){
    char s=getchar();x=0; int f=1;
    while(!isdigit(s)){if(s=='-') f=-1; s=getchar();}
    while(isdigit(s)){ x=x*10+s-'0'; s=getchar();}
    x*=f;
}
int lowbit(int x){
    return x&-x;
}
int cmp(st x,st y){
    return x.l<y.l;
}
void add(int x,int d){
    for(int i=x;i<=n;i+=lowbit(i))
      c1[i]+=d;
}
int quiry(int x){
    int c=0;
    for(int i=x;i;i-=lowbit(i))
      c+=c1[i];
      return c;
}
int main()
{
    read(n);read(c);read(m);
    for(i=1;i<=n;i++) read(a[i]);
    for(i=n;i>=1;i--)
       nxt[i]=lst[a[i]],lst[a[i]]=i;
    for(i=1;i<=m;i++){
        read(q[i].l);read(q[i].r);
        q[i].id=i;
    }
    for(i=1;i<=c;i++)
      if(lst[i]&&nxt[lst[i]])
        add(nxt[lst[i]],1);
    sort(q+1,q+m+1,cmp);
    last=1;            
    for(i=1;i<=m;i++){
        for(j=last;j<q[i].l;j++)
           if(nxt[j])
          {
              add(nxt[j],-1);
              if(nxt[nxt[j]])
                  add(nxt[nxt[j]],1);              
          }
          last=q[i].l;
          int x=quiry(q[i].r);
        ans[q[i].id]=quiry(q[i].r)-quiry(q[i].l-1);
    } 
    for(i=1;i<=m;i++)
      printf("%d\n",ans[i]);
    return 0;
}
```

---

## 作者：arfa (赞：0)

这是很明显的一个莫队的板子。

求的东西是什么呢？

- 区间所有数的个数的总和,要求每一个数字的个数要大于 $1$

所以就可以用莫队啦,如果一个数字的个数 $=2$ 产生贡献,变为 $1$ 了,产生负贡献。

时间复杂度: 由于 $N$ 和 $M$ 同阶,所以是 $O(N\sqrt{N})$。预计是 $100$ 分。

```pascal
// luogu-judger-enable-o2
var
    node_num,i,j,n,m,l,r,sum:longint;
    num:array[-1..2000010] of longint;
    id,left,right,recf,ans:array[-1..2000010] of longint;
    bucket:array[-1..2000010] of longint;

procedure Sort(l,r:longint);
var
    i,j,s1,s2,t:longint;
begin
    i:=l; j:=r; s1:=recf[(l+r) div 2]; s2:=right[(l+r) div 2];
    repeat
        while ((recf[i]<s1)or((recf[i]=s1)and(right[i]<s2))) do inc(i);
        while ((recf[j]>s1)or((recf[j]=s1)and(right[j]>s2))) do dec(j);
        if i<=j then
        begin
            t:=recf[i];  recf[i]:=recf[j];   recf[j]:=t;
            t:=id[i];    id[i]:=id[j];       id[j]:=t;
            t:=left[i];  left[i]:=left[j];   left[j]:=t;
            t:=right[i]; right[i]:=right[j]; right[j]:=t;
            inc(i); dec(j);
         end;
    until i>=j;
    if i<r then Sort(i,r);
    if j>l then Sort(l,j);
end;

function Locate(node:longint):longint;
begin
    if node mod node_num=0 then exit(node div node_num);
    exit(node div node_num+1);
end;

procedure Ready;
begin
    read(n,m,m);
    node_num:=trunc(sqrt(n));
    for i:=1 to n do read(num[i]);
    for i:=1 to m do begin id[i]:=i; read(left[i],right[i]); recf[i]:=Locate(left[i]); end;

    Sort(1,m);
end;

procedure add(x:longint); begin inc(bucket[x]); if (bucket[x]=2) then inc(sum); end;

procedure dim(x:longint); begin dec(bucket[x]); if (bucket[x]=1) then dec(sum); end;

begin
    Ready; l:=1; r:=0;
    for i:=1 to m do
    begin
        while r<right[i] do begin  inc(r); add(num[r]); end;
        while r>right[i] do begin dim(num[r]); dec(r); end;
        while l<left[i] do begin dim(num[l]); inc(l); end;
        while l>left[i] do begin dec(l); add(num[l]); end;
        ans[id[i]]:=sum;
    end;

    for i:=1 to m do writeln(ans[i]);
end.
```

如果不满足于 $100$ 分,我们可以把问题直接转化为:

- 区间里有多少个数是唯一的 (类似于 $HH$ 的项链)
 
然后直接主席树搞一搞。到时候再写。

时间复杂度: $O(N\log N)$,预计分数 $200$ 分。

---


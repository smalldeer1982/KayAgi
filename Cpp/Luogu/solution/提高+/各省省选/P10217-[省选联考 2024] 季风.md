# [省选联考 2024] 季风

## 题目背景

生活在二维平面的小 X 准备拜访小 Y，但由于气候的变化，平面上刮起了季风。小 X 想知道季风的影响下，TA 至少要多少天能够到达小 Y 的家，但小 X 也是第一次遇见这种怪事，所以请精通算法的你来帮忙。

## 题目描述

给定 $n,k,x,y$ 和 $2n$ 个整数 $x_0,y_0,x_1,y_1,\dots,x_{n-1},y_{n-1}$。

找到最小的**非负整数** $m$，使得存在 $2m$ 个实数 $x_0',y_0',x_1',y_1',\dots,x_{m-1}',y_{m-1}'$ 满足以下条件，或报告不存在这样的 $m$：
- $\sum \limits_{i=0}^{m-1} (x_i'+x_{i \bmod n})=x$；
- $\sum \limits_{i=0}^{m-1} (y_i'+y_{i \bmod n})=y$；
- $\forall 0\leq i\leq m-1,|x_i'|+|y_i'|\leq k$。

特别地，$m=0$ 时，认为 $\sum \limits_{i=0}^{m-1} (x_i'+x_{i \bmod n})$ 和 $\sum \limits_{i=0}^{m-1} (y_i'+y_{i \bmod n})$ 均为 $0$。

## 说明/提示

**【样例 1 解释】**

该组样例共有四组测试数据。
- 对于第一组测试数据，取 $m=1$，$(x_0',y_0')=(1,1)$ 满足条件，可以证明不存在更小的 $m$ 满足条件；
- 对于第二组测试数据，可以证明不存在任何非负整数 $m$ 满足条件；
- 对于第三组测试数据，取 $m=0$ 满足条件，可以证明不存在更小的 $m$ 满足条件。

**【样例 2】**

见附件中的 `wind2.in/ans`。

该组样例共有八十组测试数据，所有测试数据均满足 $n=1$，其中测试数据 $1\sim 20$ 满足特殊性质 A，$21\sim 40$ 满足特殊性质 B，$41\sim 60$ 满足特殊性质 C。

**【样例 3】**

见附件中的 `wind3.in/ans`。

该组样例共有六十组测试数据，所有测试数据均满足 $n=200$，其中测试数据 $1\sim 20$ 满足特殊性质 A，$21\sim 40$ 满足特殊性质 B。

**【子任务】**

设 $\sum n$ 为单个测试点内所有测试数据 $n$ 的和。对于所有测试数据：

- $1\leq T\leq 5\times 10^4$；
- $1\leq n\leq 10^5$，$1\leq \sum n \leq 10^6$；
- $0\leq |x|,|y|,|x_i|,|y_i|,k\leq 10^8$。

| 测试点编号 | $n\leq$ | $\sum n\leq$ | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $1$ | $300$ | A |
| $2$ | $1$ | $300$ | B |
| $3$ | $1$ | $300$ | C |
| $4$ | $1$ | $300$ | 无 |
| $5$ | $200$ | $5000$ | A |
| $6$ | $200$ | $5000$ | B |
| $7$ | $200$ | $5000$ | 无 |
| $8$ | $10^4$ | $10^5$ | A |
| $9$ | $10^4$ | $10^5$ | B |
| $10$ | $10^5$ | $10^6$ | 无 |

- 特殊性质 A：$\forall 0\leq i \leq n-1$，$|x_i|+|y_i| \leq k$；
- 特殊性质 B：$k=0$；
- 特殊性质 C：$x_0=y_0=0$。

**【提示】**

本题输入文件较大，请使用较为快速的输入方式。

## 样例 #1

### 输入

```
4
1 2 2 2
1 1
1 2 -2 -2
1 1
1 2 0 0
1 1
2 100000000 100000000 100000000
-99999999 0
-100000000 0```

### 输出

```
1
-1
0
399999999```

# 题解

## 作者：Noby_Glds (赞：76)

感觉自己做法很厉害，就记下来看看：

首先我们把 $x_i$ 和 $y_i$ 无限循环，即 $x_i=x_{i\%m+1}$，$y_i$ 同理。

题目要求我们求一个最小非负整数 $m$ 使得 $|\sum_{i=1}^mx_i-X|+|\sum_{i=1}^my_i-Y|\leq mk$

然后很多人就使用二分加分讨，太麻烦了。

直接把绝对值拆了，会有一下四种情况：

$$\sum_{i=1}^m(x_i+y_i+k)\geq X+Y$$

$$\sum_{i=1}^m(x_i-y_i+k)\geq X-Y$$

$$\sum_{i=1}^m(-x_i+y_i+k)\geq -X+Y$$

$$\sum_{i=1}^m(-x_i-y_i+k)\geq -X-Y$$

如果有一个 $m$ 满足上面**所有**的条件，那么这个 $m$ 是合法的（可以自己尝试证明一下）。

接下来我们只针对第一种情况进行分析。

首先设 $s_i=\sum_{j=1}^i(x_j+y_j+k)$，$pos=X+Y$。

然后我们发现，如果 $s_i+ks_n\geq X+Y$，根据 $s_n$ 的取值，$k$ 有不同的范围。

当 $s_n>0$ 时，我们可以获得一个 $k$ 的下界，反之则会获得一个上界。

特别的，当 $s_n=0$ 时，若 $s_i\geq X+Y$，则 $k$ 可取任意值，否则无解。

当我们对四种情况都进行了一遍求上界（下界）之后，我们的 $k$ 会锁定在一个区间 $[l_i,r_i]$ 内。

也就是说，$m=i+kn(l_i\leq k\leq r_i)$ 都是合法的。

然后枚举 $i$，如果 $l_i\leq r_i$，即存在合法区间，那么 $ans=\min(ans,i+l_in)$。

结束，时间复杂度线性。

（并不需要涉及 abs 和 __int128，避坑了十分舒服）
```cpp
#include<bits/stdc++.h>
#define N 1000010
#define int long long
using namespace std;
int T,n,k,X,Y,u,v,aim;
int a[N],x[N],y[N],s[N],t[N],l[N],r[N];
void get(int ox,int oy){
    int pos=ox*X+oy*Y;
    for(int i=1;i<=n;i++) s[i]=s[i-1]+ox*x[i]+oy*y[i]+k;
    if(!s[n]){
        for(int i=1;i<=n;i++) if(s[i]<pos) r[i]=-1;
        return;
    }
    for(int i=1;i<=n;i++){
        if(s[n]>0){
            if(s[i]<pos) l[i]=max(l[i],((pos-s[i])%s[n]?(pos-s[i])/s[n]+1:(pos-s[i])/s[n]));
        }
        else{
            if(s[i]<pos) r[i]=-1;
            else r[i]=min(r[i],(pos-s[i])/s[n]);
        } 
    }
}
signed main(){
    cin>>T;
    while(T--){
        cin>>n>>k>>X>>Y;
        for(int i=1;i<=n;i++) cin>>x[i]>>y[i],l[i]=0,r[i]=1e15;
        if(!X&&!Y){cout<<"0\n";continue;}
        get(1,1),get(1,-1),get(-1,-1),get(-1,1);
        int ans=1e18;
        for(int i=1;i<=n;i++) if(l[i]<=r[i]) ans=min(ans,l[i]*n+i);
        if(ans==1e18) cout<<"-1\n";
        else cout<<ans<<endl;
    }
    return 0;
}
```

---

## 作者：sjr3065335594 (赞：21)

## 题意

找到最小的**非负整数** $m$，使得存在 $2m$ 个实数 $x_0',y_0',x_1',y_1',\dots,x_{m-1}',y_{m-1}'$ 满足以下条件，或报告不存在这样的 $m$：

- $\sum \limits_{i=0}^{m-1} (x_i'+x_{i \bmod n})=x$；

- $\sum \limits_{i=0}^{m-1} (y_i'+y_{i \bmod n})=y$；

- $\forall 0\leq i\leq m-1,|x_i'|+|y_i'|\leq k$。

## 思路

考虑直接推式子。

令 $m-1=qn+r$，所以我们可以将原来的两个式子进行化简

$$\begin{aligned}\sum \limits_{i=0}^{m-1} (x_i'+x_{i \bmod n})&=q\sum\limits_{i=0}^{n-1}x_i+\sum\limits_{i=0}^{r}x_i+\sum\limits_{i=0}^{m-1}x_i'\\&=qS_{x_{n-1}}+S_{x_r}+\sum\limits_{i=0}^{m-1}x_i'\\&=x\end{aligned}$$

其中 $S_{x_i}$ 表示原序列的前缀和。对于 $y$ 的式子和 $x$ 是相同的，即

$$qS_{y_{n-1}}+S_{y_r}+\sum\limits_{i=0}^{m-1}y_i'=y$$

我们可以考虑枚举 $r$，计算对应最小的 $q$ 来解决问题。

由于题目中还有 $|x_i'|+|y_i'|\leq k$ 这一条限制，所以我们需要对 $x_i'$ 和 $y_i'$ 的正负进行思考。

容易想到 $x_i'$ 之间是同号的，$y_i'$ 之间是同号的，这是因为如果要到达 $x,y$，可以通过平均每一次的 $x_i'$，$y_i'$ 来使它们的绝对值之和更小，应是同号的。

而且我们可以发现，通过平均每一次走的距离，可以使得 $|x_i'|+|y_i'|\leq k$ 这一限制变为 $\sum\limits_{i=0}^{m-1}(|x_i'|+|y_i'|)\leq mk$。

所以我们根据 $x_i'$ 和 $y_i'$ 的正负就可以进行分类讨论了。

1. $x_i'$ 为正，$y_i'$ 为正

直接将这两个式子加起来得到

$$q(S_{x_{n-1}}+S_{y_{n-1}})+S_{x_r}+S_{y_r}+\sum\limits_{i=0}^{m-1}x_i'+\sum\limits_{i=0}^{m-1}y_i'=x+y$$

稍微化简一下

$$q(S_{x_{n-1}}+S_{y_{n-1}})+\sum\limits_{i=0}^{m-1}x_i'+\sum\limits_{i=0}^{m-1}y_i'=W$$

其中，$W=x+y-S_{x_r}-S_{y_r}$。

利用 $\sum\limits_{i=0}^{m-1}(|x_i'|+|y_i'|)\leq mk$，将 $\sum\limits_{i=0}^{m-1}x_i'+\sum\limits_{i=0}^{m-1}y_i'$ 直接换为 $mk$，因为都是正数所以绝对值无所谓。

于是原来的式子就变为了一个不等式

$$q(S_{x_{n-1}}+S_{y_{n-1}})+mk\geq W$$

将 $m$ 换为 $qn+r+1$，并移项，使这个式子变为 $Kq\geq B$ 的形式

$$q(S_{x_{n-1}}+S_{y_{n-1}}+nk)\geq W-(r+1)k$$

这个不等式除了 $q$ 以外都是已知的，我们便可以求出此时最小的 $q$。

完了吗？显然还没有。

要注意我们强制使 $x_i'$ 和 $y_i'$ 为正了，那回来看看前边的式子

$$qS_{x_{n-1}}+S_{x_r}+\sum\limits_{i=0}^{m-1}x_i'=x$$

$$qS_{y_{n-1}}+S_{y_r}+\sum\limits_{i=0}^{m-1}y_i'=y$$

发现了吧，要讨论这种条件的先决条件是

$$\begin{cases}qS_{x_{n-1}}\leq x-S_{x_r}\\qS_{y_{n-1}}\leq y-S_{y_r}\end{cases}$$

所以说 $q$ 的取值范围应该是这两个不等式与上边那个的交集。

这里分类讨论其实并不在意 $0$ 被算了多少次，因为多算几次再取最小值也没有影响，所以不等号都选择小于等于或者大于等于。

2. $x_i$ 为正，$y_i$ 为负

这种情况和上边其实都是相同的，只是在最开始的式子变化一下

$$qS_{x_{n-1}}+S_{x_r}+\sum\limits_{i=0}^{m-1}x_i'=x$$

$$qS_{y_{n-1}}+S_{y_r}+\sum\limits_{i=0}^{m-1}y_i'=y$$

由于 $y_i'$ 是负数，我们将第二个式子乘上 $-1$，得到

$$-qS_{y_{n-1}}-S_{y_r}-\sum\limits_{i=0}^{m-1}y_i'=-y$$

$-\sum\limits_{i=0}^{m-1}y_i'$ 这一项虽然有负号但实际上是正的，也就代表着可以加上一个绝对值而值不改变。

所以我们将这个式子和上边 $x$ 的相加

$$qS_{x_{n-1}}+S_{x_r}+\sum\limits_{i=0}^{m-1}x_i'-qS_{y_{n-1}}-S_{y_r}-\sum\limits_{i=0}^{m-1}y_i'=x-y$$

移项化简

$$q(S_{x_{n-1}}-S_{y_{n-1}})+\sum\limits_{i=0}^{m-1}x_i'-\sum\limits_{i=0}^{m-1}y_i'=W$$

其中 $W=x-y-S_{x_r}+S_{y_r}$

显然我们可以将 $\sum\limits_{i=0}^{m-1}x_i'-\sum\limits_{i=0}^{m-1}y_i'$ 这一项直接换成 $mk$，将上式变为不等式（因为这个式子和绝对值相加是相等的所以可以直接换）

$$q(S_{x_{n-1}}-S_{y_{n-1}})+mk\geq W$$

到了这里就已经跟上一种情况方法相同，不再赘述。

3. $x_i'$ 为负，$y_i'$ 为正

这种情况和情况 $2$ 是一样的，只需将 $x$ 的式子乘上 $-1$ 就可以了。

4. $x_i'$ 为负，$y_i'$ 为负

这种情况是前面两种情况的综合，只需要两个式子都乘上 $-1$ 即可。

以上所有讨论记得计算出的 $q$ 一定要和讨论的先决条件取交集！！！

来分析一下时间复杂度，由于枚举 $r$，时间复杂度 $O(n)$，每个 $r$ 需要解 $12$ 个不等式，常数比较大，但是完全足够通过本题。如果还有不理解的话可以看代码。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define mkp(x,y) make_pair(x,y)
#define CLR(a,x) memset(a,x,sizeof(a))
//#define int long long
//#define int __int128
using namespace std;
const int N=2e5+5;
const int M=1e6+5;

namespace ZJ {
	
ll n, k, X, Y; 
ll x[N], y[N];
ll sx[N], sy[N];
const ll LL_INF = LONG_LONG_MAX;

struct SG {// 用来存储区间[l, r]
	ll l, r;
	void print() {
		if(l == -LL_INF) printf("-inf ");
		else printf("%lld ",l);
		if(r == LL_INF) printf("inf\n");
		else printf("%lld\n",r);
	}
};
SG Sol(ll k, ll b) {// 解不等式 kx <= b，返回一个SG表示x的取值范围
	if(k == 0) {
		if(b < 0) return {0,-1};//无解的情况只需要随便返回一个不存在区间即可
		else return {-LL_INF, LL_INF};
	} else if(k < 0) {
		return {ceil(1.0 * b / k), LL_INF};
	} else {
		return {-LL_INF, floor(1.0 * b / k)};
	}
}
SG merge(SG a, SG b) {//取两个区间的交集
	if(a.l > a.r || b.l > b.r) return {0, -1};//有一个区间不存在那整个区间也就不存在
	return {max(a.l, b.l), min(a.r, b.r)};
}


void solve() {
	scanf("%lld%lld%lld%lld", &n, &k, &X, &Y);
	for(int i = 0; i < n; i++) {
		scanf("%lld%lld", &x[i], &y[i]);
		sx[i] = (i > 0 ? sx[i - 1] : 0) + x[i];
		sy[i] = (i > 0 ? sy[i - 1] : 0) + y[i];//求xi,yi的前缀和
	}
	if(X == 0 && Y == 0) {//这种情况一定要特判掉，因为在下边计算m就是在算qn+r+1，n,r大于等于0，所以特判掉答案为0的情况
		printf("0\n");
		return;
	}
	ll ans = LL_INF;
	for(int r = 0; r < n; r++) {
		SG s1, s2, s3, s4; ll q = LL_INF;
		ll sumx = sx[n - 1], sumy = sy[n - 1];
		ll _X = X - sx[r], _Y = Y - sy[r];
		
		// x + & y +
		s1 = merge(Sol(sumx, _X), Sol(sumy, _Y));//先确保满足该组分讨的限制
		s1 = merge(s1, Sol(-(sumx + sumy + n * k), -(_X + _Y - (r + 1) * k)));//因为这里是大于等于号，所以乘上-1变成小于等于
		
		// x + & y -
		s2 = merge(Sol(sumx, _X), Sol(-sumy, -_Y));
		s2 = merge(s2, Sol(-(sumx - sumy + n * k), -(_X - _Y - (r + 1) * k)));
		
		// x - & y +
		s3 = merge(Sol(-sumx, -_X), Sol(sumy, _Y));
		s3 = merge(s3, Sol(-(sumy - sumx + n * k), -(_Y - _X - (r + 1) * k))); 
		
		// x - & y -
		s4 = merge(Sol(-sumx, -_X), Sol(-sumy, -_Y));
		s4 = merge(s4, Sol(-(- sumx - sumy + n * k), -(- _X - _Y - (r + 1) * k)));
		
		if(s1.l <= s1.r && s1.r >= 0)q = min(q, max(s1.l, 0ll));//在每种合法情况取q的最小值
		if(s2.l <= s2.r && s2.r >= 0)q = min(q, max(s2.l, 0ll));
		if(s3.l <= s3.r && s3.r >= 0)q = min(q, max(s3.l, 0ll));
		if(s4.l <= s4.r && s4.r >= 0)q = min(q, max(s4.l, 0ll));
		if(q != LL_INF) ans = min(ans, q * n + r + 1);//注意m=qn+r+1，而不是qn+r
	}
	printf("%lld\n", ans == LL_INF ? -1 : ans);
}
	
	
}

namespace sjr3065335594 {

int t;

int main() {
	scanf("%d", &t);
	while(t--)
		ZJ::solve();
	return 0;
}

}

int main() {
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	return sjr3065335594::main();
	return 0;
}

```

---

## 作者：云浅知处 (赞：14)

考虑什么样的 $m$ 是合法的，发现只需要 $|X-\sum_{i=0}^{m-1} x_i|+|Y-\sum_{i=0} ^{m-1}y_i|\le mk$。

这里认为 $x,y$ 以 $n$ 为周期无限循环。

把绝对值拆开，可以得到四个式子：
$$
\begin{cases}
X+Y-\sum_{i=0}^{m-1}(x_i+y_i+k)\le 0\\
X-Y-\sum_{i=0}^{m-1}(x_i-y_i+k)\le 0\\
-X+Y-\sum_{i=0}^{m-1}(-x_i+y_i+k)\le 0\\
-X-Y-\sum_{i=0}^{m-1}(-x_i-y_i+k)\le 0\\
\end{cases}
$$
考虑直接枚举最后一个周期停下的具体位置，通过以上四个不等式可以确定周期数的范围 $[l,r]$，将四个范围取交，若为空则这个位置不合法，否则将答案对 $l\times n+i$ 取 min 即可。时间复杂度 $O(n)$。

通过以上推导也可以看出，周期数为 $O(nV)$ 级别，于是最终的答案为 $O(n^2V)$ 级别，实际常数大概是 $3$ 左右，于是可以说明答案一定小于 $4\times 10^{18}<2^{63}$，全程使用 `long long` 不会爆。~~但是 inf 一定要开够！！！~~

```cpp
#include<bits/stdc++.h>

#define ll long long
#define fi first
#define se second
#define mk make_pair
#define int long long

using namespace std;

int read(){
	int x=0,f=1;char c=getchar();
	for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
	for(;isdigit(c);c=getchar())x=x*10+c-'0';
	return f==1?x:-x;
}

mt19937 rnd(time(0));
int randint(int l,int r){return rnd()%(r-l+1)+l;}

template<typename T>void cmax(T &x,T v){x=max(x,v);}
template<typename T>void cmin(T &x,T v){x=min(x,v);}

const ll INF=2e13;
const ll INFF=4e18;

void solve(){
	int n=read(),K=read(),X=read(),Y=read();
	vector<ll>x(n),y(n),a(n),b(n),c(n),d(n);

	for(int i=0;i<n;i++)x[i]=read(),y[i]=read();

	if(X==0&&Y==0)return puts("0"),void();

	ll A=0,B=0,C=0,D=0;
	for(int i=0;i<n;i++)a[i]=x[i]+y[i]+K;
	for(int i=0;i<n;i++)b[i]=-x[i]+y[i]+K;
	for(int i=0;i<n;i++)c[i]=x[i]-y[i]+K;
	for(int i=0;i<n;i++)d[i]=-x[i]-y[i]+K;

	for(int i=1;i<n;i++)a[i]+=a[i-1],b[i]+=b[i-1],c[i]+=c[i-1],d[i]+=d[i-1];
	A=a[n-1],B=b[n-1],C=c[n-1],D=d[n-1];

	auto Cap=[&](pair<ll,ll>A,pair<ll,ll>B){return mk(max(A.fi,B.fi),min(A.se,B.se));};

	auto calcL=[&](ll cursum,ll ad){ // min_k s.t. cursum - k * ad <=0
		if(cursum<=0)return 0ll;
		if(ad<=0)return INF+1;
		ll cnt=cursum/ad;
		if(cursum%ad!=0)cnt++;
		return cnt;
	};
	auto calcR=[&](ll cursum,ll ad){ // max_k s.t. cursum - k * ad <=0
		if(ad>0)return INF;
		else if(ad==0){
			if(cursum>0)return -1ll;
			else return INF;
		}
		else{
			if(cursum>0)return -1ll;
			cursum=-cursum,ad=-ad;
			return (ll)(cursum/ad);
		}
	};
	auto calc=[&](ll cursum,ll ad){return mk(calcL(cursum,ad),calcR(cursum,ad));};

	ll ans=INFF;
	for(int i=0;i<n;i++){
		auto cc=mk(0ll,INF);
		cc=Cap(cc,calc(X+Y-a[i],A));
		cc=Cap(cc,calc(-X+Y-b[i],B));
		cc=Cap(cc,calc(X-Y-c[i],C));
		cc=Cap(cc,calc(-X-Y-d[i],D));
		if(cc.fi>cc.se)continue;
		cmin(ans,1ll*cc.fi*n+i+1);
	}
	if(ans>=INFF)puts("-1");
	else cout<<ans<<'\n';
}

signed main(){

	int tt=read();while(tt--)solve();

	return 0;
}
```

---

## 作者：Wf_yjqd (赞：14)

花了三个半小时，细节错爆零了。祭之。

------------

可以理解为初始在 $(0,0)$，求最小 $m$ 使得 $|x-\sum\limits_{i=0}^{m-1}x_{i\mod n}|+|y-\sum\limits_{i=0}^{m-1}y_{i\mod n}|\le k\times m$，即飘 $m$ 天后与 $(x,y)$ 的曼哈顿距离最多为 $
k\times m$。

我们设 $m=n\times z+i(0\le i<n)$，并求出 $x_i$ 的前缀和 $X_i=\sum\limits_{j=0}^{i-1}x_j$，$y_i$ 的前缀和 $Y_i=\sum\limits_{j=0}^{i-1}y_j$，上式变为 $|x-X_n\times z-X_i|+|y-Y_n\times z-Y_i|\le k\times(n\times z+i)$。

我们分讨 $4$ 种情况去掉绝对值（即枚举绝对值内数的正负），然后解出不等式的解，$k$ 即为下界的最小值，求出相应的 $m$ 更新答案即可。

以下以均非负的情况示例。

$X_n\times z\le x-X_i$，$Y_n\times z\le y-Y_i$，讨论 $X_n,Y_n$ 与 $0$ 的关系，维护 $z$ 的上下界。

上式变为 $x+y-X_i-Y_i-k\times i\le z\times(k\times n+X_n+Y_n)$，同理讨论 $k\times n+X_n+Y_n$ 与 $0$ 的关系。

------------

考场错误在代码中指出。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll maxn=1e5+26,inff=2e13+26,inf=3e18+26;
namespace Sherry_IO{
	inline ll read(){
		char c=getchar();
		ll x=0,f=1;
		while(c<'0'||c>'9'){
			if(c=='-')
				f=-1;
			c=getchar();
		}
		while(c>='0'&&c<='9'){
			x=x*10+c-'0';
			c=getchar();
		}
		return x*f;
	}
	inline void write(ll x){
		if(x>9)
			write(x/10);
		putchar(x%10+'0');
		return ;
	}
}
using namespace Sherry_IO;
ll T,n,k,x,y,xx[maxn],yy[maxn],ans,l,r;
inline ll uc(ll x,ll y){
	if((x<0)^(y<0))
		return x/y;
	if(x<0)
		return uc(-x,-y);
	if(!x)//考场没判
		return 0;
	return (x-1)/y+1;
}
inline ll dc(ll x,ll y){
	if((x<0)^(y<0))
		return -uc(-x,y);
	if(x<0)
		return dc(-x,-y);
	return x/y;
}
int main(){
	// freopen("gen.txt","r",stdin);
	// freopen("A.txt","w",stdout);
	T=read();
	while(T--){
		n=read();
		k=read();
		x=read();
		y=read();
		for(int i=1;i<=n;i++){
			xx[i]=xx[i-1]+read();
			yy[i]=yy[i-1]+read();
		}
		ans=inf;
		for(int i=0;i<n;i++){
			//<0 <0 xx[i]+yy[i]-x-y-i*k<=z*(n*k-xx[n]-yy[n])
			l=0;
			r=inff;
			if(!xx[n])
				l=(x<=xx[i]?0:inff);
			else if(xx[n]>0)
				l=max(l,uc(x-xx[i],xx[n]));
			else
				r=min(r,dc(x-xx[i],xx[n]));
			if(!yy[n])
				l=max(l,y<=yy[i]?0:inff);
			else if(yy[n]>0)
				l=max(l,uc(y-yy[i],yy[n]));
			else
				r=min(r,dc(y-yy[i],yy[n]));
			if(n*k-xx[n]-yy[n]>0)
				ans=min(ans,(max(uc(xx[i]+yy[i]-x-y-i*k,n*k-xx[n]-yy[n]),l)<=r?max(uc(xx[i]+yy[i]-x-y-i*k,n*k-xx[n]-yy[n]),l):inff)*n+i);
			else if(n*k-xx[n]-yy[n]<0)
				ans=min(ans,(min(dc(xx[i]+yy[i]-x-y-i*k,n*k-xx[n]-yy[n]),r)>=l?l:inff)*n+i);
			else if(xx[i]+yy[i]-x-y-i*k<=0)
				ans=min(ans,(l<=r?l:inff)*n+i);
			//<0 >=0 xx[i]-yy[i]-x+y-i*k<=z*(n*k-xx[n]+yy[n])
			l=0;
			r=inff;
			if(!xx[n])
				l=(x<=xx[i]?0:inff);
			else if(xx[n]>0)
				l=max(l,uc(x-xx[i],xx[n]));
			else
				r=min(r,dc(x-xx[i],xx[n]));
			if(!yy[n])
				l=max(l,yy[i]<y?0:inff);
			else if(yy[n]<0)
				l=max(l,dc(y-yy[i],yy[n])+1);
			else
				r=min(r,uc(y-yy[i],yy[n])-1);
			if(n*k-xx[n]+yy[n]>0)
				ans=min(ans,(max(uc(xx[i]-yy[i]-x+y-i*k,n*k-xx[n]+yy[n]),l)<=r?max(uc(xx[i]-yy[i]-x+y-i*k,n*k-xx[n]+yy[n]),l):inff)*n+i);
			else if(n*k-xx[n]+yy[n]<0)
				ans=min(ans,(min(dc(xx[i]-yy[i]-x+y-i*k,n*k-xx[n]+yy[n]),r)>=l?l:inff)*n+i);
			else if(xx[i]-yy[i]-x+y-i*k<=0)
				ans=min(ans,(l<=r?l:inff)*n+i);//考场为 ans=min(ans,l*n+i)，以下相应位置犯了相同错误。
			//>=0 <0 x-y-xx[i]+yy[i]-i*k<=z*(n*k+xx[n]-yy[n])
			l=0;
			r=inff;
			if(!xx[n])
				l=(xx[i]<x?0:inff);
			else if(xx[n]<0)
				l=max(l,dc(x-xx[i],xx[n])+1);
			else
				r=min(r,uc(x-xx[i],xx[n])-1);
			if(!yy[n])
				l=max(l,y<=yy[i]?0:inff);
			else if(yy[n]>0)
				l=max(l,uc(y-yy[i],yy[n]));
			else
				r=min(r,dc(y-yy[i],yy[n]));
			if(n*k+xx[n]-yy[n]>0)
				ans=min(ans,(max(uc(x-y-xx[i]+yy[i]-i*k,n*k+xx[n]-yy[n]),l)<=r?max(uc(x-y-xx[i]+yy[i]-i*k,n*k+xx[n]-yy[n]),l):inff)*n+i);
			else if(n*k+xx[n]-yy[n]<0)
				ans=min(ans,(min(dc(x-y-xx[i]+yy[i]-i*k,n*k+xx[n]-yy[n]),r)>=l?l:inff)*n+i);
			else if(x-y-xx[i]+yy[i]-i*k<=0)
				ans=min(ans,(l<=r?l:inff)*n+i);
			//>=0 >=0 x+y-xx[i]-yy[i]-i*k<=z*(n*k+xx[n]+yy[n])
			l=0;
			r=inff;
			if(!xx[n])
				l=(xx[i]<x?0:inff);
			else if(xx[n]<0)
				l=max(l,dc(x-xx[i],xx[n])+1);
			else
				r=min(r,uc(x-xx[i],xx[n])-1);
			if(!yy[n])
				l=max(l,yy[i]<y?0:inff);
			else if(yy[n]<0)
				l=max(l,dc(y-yy[i],yy[n])+1);
			else
				r=min(r,uc(y-yy[i],yy[n])-1);
			if(n*k+xx[n]+yy[n]>0)
				ans=min(ans,(max(uc(x+y-xx[i]-yy[i]-i*k,n*k+xx[n]+yy[n]),l)<=r?max(uc(x+y-xx[i]-yy[i]-i*k,n*k+xx[n]+yy[n]),l):inff)*n+i);
			else if(n*k+xx[n]+yy[n]<0)
				ans=min(ans,(min(dc(x+y-xx[i]-yy[i]-i*k,n*k+xx[n]+yy[n]),r)>=l?l:inff)*n+i);
			else if(x+y-xx[i]-yy[i]-i*k<=0)
				ans=min(ans,(l<=r?l:inff)*n+i);
		}
		if(ans>=n*inff)
			puts("-1");
		else{
			write(ans);
			putchar('\n');
		}
	}
	return 0;
}
/*
4
1 2 2 2
1 1
1 2 -2 -2
1 1
1 2 0 0
1 1
2 100000000 100000000 100000000
-99999999 0
-100000000 0

11:53 ��������

������������л������ 
*/
```

---

## 作者：stardust_Ray (赞：11)

555，考场F了30pts，作题解以寄之。

容易发现当所有的 $x_i'$ 和所有的 $y_i'$ 相等时 $\max({|x_i'|+|y_i'|})$ 最小。那么我们可以枚举 $m\mod n$ 的值，记为 $i$，然后考虑对每一个 $i$ 计算出最小的 $m$，即计算出最小的 $j$，使得 $m=jn+i$。

以下记 $sx_i$ 为 $x_i$ 的前缀和，$sy_i$ 为 $y_i$ 的前缀和。

因为 $\sum \limits_{i=0}^{m-1} (x_i'+x_{i \bmod n})=x$

所以 $x'=\frac{x-j*sx_n-sx_i}{j*n+i}$。

同理 $y'=\frac{y-j*sy_n-sy_i}{j*n+i}$。

此时我们已经满足了前两个条件，接下来会发现第三个不等式转化为了以下的形式：$|x'|+|y'|\leq k$。

把 $x'$ 和 $y'$ 带入，会发现为绝对值不等式的形式。

$$|j*sx_n+sx_i-x|+|j*sy_n+sy_i-y|\leq k*(j*n+i)$$

把 $j$ 当作主元，枚举两个绝对值内的正负性，直接求解即可。时间复杂度 $O(n)$

**Tips: 注意不要使用负数除法，建议使用 double 的运算代替负数除法。**

Code:
```cpp
#include<bits/stdc++.h>
#define within :
#define LJY main
using namespace std;
typedef long long ll;
const int N=1e5+5;
inline int read(){
  char ch=getchar();int x=0,f=1;
  while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}
  while(ch>='0'&&ch<='9')
    x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
  return x*f;
}
const ll inf=9e18;
struct Segment{ll l,r;
bool empty(){return l>r;}};
//线段结构体，用来进行不等式的解的存储
Segment sol(ll k,ll b){
  if(k<0) return Segment{0,(ll)floor((double)(-b)/k)};
  if(k>0) return Segment{(ll)ceil((double)-b/k),inf};
  if(b>=0) return {0,inf};
  else return {inf,0};
}
//求kx+b>=0一类不等式的整数解
Segment operator&(Segment a,Segment b){return Segment{max(a.l,b.l),min(a.r,b.r)};}
ll n,k,x,y,a[N],b[N],sa[N],sb[N],ans;
void ljy(){
  //代码中下标整体右移了一位
  n=read();k=read();x=read();y=read();
  for(int i=1;i<=n;i++) a[i]=read(),b[i]=read();
  ans=inf;
  if(x==0&&y==0){puts("0");return;}
  for(int i=1;i<=n;i++){
    sa[i]=sa[i-1]+a[i];
    sb[i]=sb[i-1]+b[i];
  }//计算前缀和
  for(int i=0;i<n;i++){
    ll k1=sa[n],b1=sa[i]-x;
    ll k2=sb[n],b2=sb[i]-y;
    ll k3=k*n,b3=k*i;
    Segment p1=sol(k1,b1)&sol(k2,b2)&sol(k3-k1-k2,-b1-b2+b3);
    //两个均非负
    Segment p2=sol(-k1,-b1)&sol(k2,b2)&sol(k3+k1-k2,b1-b2+b3);
    
    Segment p3=sol(k1,b1)&sol(-k2,-b2)&sol(k3-k1+k2,-b1+b2+b3);
    //一负一正的两种情况
    Segment p4=sol(-k1,-b1)&sol(-k2,-b2)&sol(k3+k1+k2,b1+b2+b3);
    //两个均非正
    if(!p1.empty()) ans=min(ans,p1.l*n+i);
    if(!p2.empty()) ans=min(ans,p2.l*n+i);
    if(!p3.empty()) ans=min(ans,p3.l*n+i);
    if(!p4.empty()) ans=min(ans,p4.l*n+i);
  }if(ans!=inf) printf("%lld\n",ans);
  else puts("-1");
}
signed LJY(){int T=read();while(T--) ljy();return 0;}
```

---

## 作者：yuanruiqi (赞：8)

赛后有人质疑题目背景的季风和题意的相关性。

考虑季风和 $(X_i,Y_i)$ 的相关性。巧了我正好曾是课代表。若答案为 $m$，容易想到将 $(X_{i\bmod n},Y_{i\bmod n})$ 看做季风对船舶造成的偏移量，记作向量 $V_i$，显然只需要考虑向量的和 $\sum_{i=0}^{m-1}V_i$。这样就差不多做完了。

式子里有两个绝对值，感觉很凸。继续考虑季风，季风可以让我们想到地球公转，大气环流等东西，这些东西显然都是凸的。所以题目肯定和凸有关，真是叫人头秃。

试图将绝对值内的东西写成一次函数，这是容易的，还是考虑季风。我们将 $\bmod \ n$ 看做季节的剩余系，那么只需要考虑最终到达的季节，因为每一年的总风量是恒定的，显然这个就是想要的斜率。

下面就是找到最小的 $x$ 满足 $\lvert k_1x+b_1\rvert+\lvert k_2x+b_2\rvert \le kx$。一种做法是，找到谷底，并对前半部分二分，复杂度 $O(n\log n)$，另一种做法是，按照绝对值的 $0$ 点拆成三段，每一段解一次不等式，可以做到 $O(n)$。

细节不是很好处理，采用二分则需要开 `__int128`。

---

## 作者：Mine_King (赞：8)

谨以此题解纪念我今年 Day1 T1 因少分讨一个 corner case 而 F 了 10 分。

## Problem

[省选联考 2024 Day1 T1 季风](https://www.luogu.com.cn/problem/P10217)

**题目大意：**

给定 $n, k, x, y$ 和 $2n$ 个整数 $x _ 0, y _ 0, x _ 1, y _ 1, \ldots, x _ {n - 1}, y _ {n - 1}$。

找到最小的**非负整数** $m$，使得存在 $2m$ 个实数 $x _ 0', y _ 0', x _ 1', y _ 1', \ldots, x _ {m - 1}', y _ {m - 1}'$ 满足以下条件，或报告不存在这样的 $m$：

- $\sum\limits _ {i = 0} ^ {m - 1} (x _ i' + x _ {i \bmod n}) = x$；
- $\sum\limits _ {i = 0} ^ {m - 1} (y _ i' + y _ {i \bmod n}) = y$；
- $\forall 0 \le i \le m - 1, |x _ i'| + |y _ i'| \le k$。

特别地，$m = 0$ 时，认为 $\sum\limits _ {i = 0} ^ {m - 1} (x _ i' + x _ {i \bmod n})$ 和 $\sum\limits _ {i = 0} ^ {m - 1} (y _ i' + y _ {i \bmod n})$ 均为 $0$。

形象理解就是初始在原点，每次可以选择一个向量 $(x', y')$，然后将位置加上这个向量，然后时刻 $i$ 季风会使你的位置会加上 $(x _ {i \bmod n}, y _ {i \bmod n})$，问最少要多少时间才能走到 $(x, y)$，要求每次选择的 $|x'| + |y'| \le k$。

## Solution

为防止混淆，以下用 $ex, ey$ 代替题目中的 $x, y$。

显然可以把 $x, y$ 的贡献和 $x', y'$ 的贡献分开来计算。

考虑所有模 $n$ 同余的时间，$x, y$ 的贡献会相差 $X = \sum _ {i = 0} ^ {n - 1} x _ i, Y = \sum _ {i = 0} ^ {n - 1} y _ i$ 的若干倍，因此可以考虑将时间按模 $n$ 的余数划分，分别求解答案然后取最小值。

设当前考虑的时间是 $tn + r$，则 $x, y$ 产生的贡献分别是 $tX + \sum _ {i = 1} ^ {r - 1} x _ i, tY + \sum _ {i = 1} ^ {r - 1} y _ i$，考虑合理规划 $x', y'$ 的取值使得可以到达 $(ex, ey)$。

我们发现只有最后一个限制将横坐标和纵坐标绑在一起了，于是考虑用一些方法分离横纵坐标变成一个一维的问题。  
原限制相当于要求 $(x _ i', y _ i')$ 到原点的曼哈顿距离不超过 $k$，因此只需要将点逆时针旋转 $\frac{\pi}{4}$ 就可以将曼哈顿距离转成切比雪夫距离。  
具体地，我们知道 $(x, y)$ 逆时针旋转 $\frac{\pi}{4}$ 后会变成 $(\frac{x - y}{\sqrt{2}}, \frac{x + y}{\sqrt{2}})$，为了方便，我们再令每个点的横纵坐标都乘上 $\sqrt{2}$，显然这样不会出现问题，然后只需要将 $x, y, ex, ey$ 都这样旋转一下就行了，然后原本的限制就变成了 $\max\{x', y'\} \le k$，即 $x' \le k, y' \le k$。

接下来我们只考虑横坐标，纵坐标的求解是一样的。  
显然 $-k(tn + r) \le \sum _ {i = 1} ^ {m - 1} x _ i' \le k(tn + r)$，并且不难发现对于任意 $-k(tn + r) \le v \le k(tn + r)$，都一定可以构造一组 $x'$ 使得 $\sum _ {i = 1} ^ {m - 1} x _ i' = v$。  
因此我们只需要满足：

$$
tX + \sum\limits _ {i = 1} ^ {r - 1} x _ i - k(tn + r) \le ex \le tX + \sum\limits _ {i = 1} ^ {r - 1} x _ i + k(tn + r)
$$

方便起见我们令 $ex \gets ex - \sum _ {i = 1} ^ {r - 1} x _ i$。

$$
tX - k(tn + r) \le ex \le tX + k(tn + r) \\
t(X - kn) - kr \le ex \le t(X + kn) + kr \\
[t(X - kn), t(X + kn)] \cap [ex - kr, ex + kr] \ne \varnothing
$$

现在问题转化为给定 $l, r, l', r'$，求 $t$ 的取值范围，使得 $[tl, tr] \cap [l', r'] \ne \varnothing$，显然合法的 $t$ 是一个区间，我们只需要求出这个区间然后将横纵坐标的区间取个交即可得到答案。

然后考虑这个东西怎么求，只需要一些小小的分讨：

首先可以钦定 $r' \ge 0$，若 $r' < 0$ 则将两个区间都关于原点对称即可。

首先考虑区间下界：

- 若 $tl \le 0$，则 $t$ 的下界为 $0$。
- 否则若 $r \le 0$，则无解。
- 否则答案为 $\left\lceil\frac{tl}{r}\right\rceil$。

然后考虑区间上界：

- 若 $l \le 0$：
  - 若 $r < 0, tl \le 0$，则 $t$ 的上界为 $\left\lfloor\frac{tl}{r}\right\rfloor$。
  - 否则，抛开上面提到的无解情况，答案为 $+\infty$。
- 否则答案为 $\left\lfloor\frac{tr}{l}\right\rfloor$。

至此这题就做完了。

## Code

```cpp
// Think twice, code once.
#include <cstdio>
#include <string>
#include <cstring>
#include <iostream>
#include <algorithm>
#define eputchar(c) putc(c, stderr)
#define eprintf(...) fprintf(stderr, __VA_ARGS__)
#define eputs(str) fputs(str, stderr), putc('\n', stderr)
using namespace std;

int T, n;
long long k, tx, ty;
long long x[100005], y[100005];

void rotate(long long &x, long long &y) {
	long long ax = x - y, ay = x + y;
	x = ax, y = ay;
	return ;
}
pair<long long, long long> calc(long long l, long long r, long long tl, long long tr) {
	if (tr < 0) {
		l = -l, r = -r, swap(l, r);
		tl = -tl, tr = -tr, swap(tl, tr);
	}
	pair<long long, long long> res;
	if (tl <= 0) res.first = 0;
	else {
		if (r > 0) res.first = (tl + r - 1) / r;
		else return {0, -1};
	}
	if (l <= 0) {
		if (r < 0 && tl <= 0) res.second = -tl / -r;
		else res.second = 0x3f3f3f3f3f3f3f3f;
	} else res.second = tr / l;
	return res;
}

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin >> T;
	while (T--) {
		cin >> n >> k >> tx >> ty, rotate(tx, ty);
		for (int i = 0; i < n; i++) cin >> x[i] >> y[i], rotate(x[i], y[i]);
		for (int i = 1; i < n; i++) x[i] += x[i - 1], y[i] += y[i - 1];
		long long X = x[n - 1], Y = y[n - 1];
		long long ans = -1;
		for (int i = 0; i < n; i++) {
			long long xp = tx, yp = ty;
			if (i) xp -= x[i - 1], yp -= y[i - 1];
			pair<long long, long long> ix = calc(X - n * k, X + n * k, xp - i * k, xp + i * k);
			pair<long long, long long> iy = calc(Y - n * k, Y + n * k, yp - i * k, yp + i * k);
			pair<long long, long long> interval(max(ix.first, iy.first), min(ix.second, iy.second));
			if (interval.first > interval.second) continue;
			long long res = interval.first * n + i;
			if (ans == -1 || res < ans) ans = res;
		}
		cout << ans << '\n';
	}
	return 0;
}
```

---

## 作者：elbissoPtImaerD (赞：7)

[前置知识](http://codeforces.com/problemset/problem/1117/C)

将位移拆成两类考虑：一类是风被动产生的，一类是人主动产生的。

前者我们以 $(x,y)$ 为起点考虑位移，后者以 $(0,0)$ 为起点考虑位移。

枚举 $m\bmod n$，记 $N=\lfloor\frac mn\rfloor$。

若存在余数为 $i$ 的合法步数，等价于存在正整数 $N$ 使得 $|Fx(N)| + |Fy(N)| \le Fn(N)$ ，其中 $Fx,Fy,Fn$ 均为关于 $N$ 的一次函数。具体地，记前 $i$ 步位移为 $s$，一轮 $n$ 步位移为 $S$，$Fx(N) = S_xN + s_x + T_x$，$Fy(N) = S_yN + s_y + T_y$，$Fn(N) =  knN + ki$。

将绝对值拆开解一元一次不等式即可求出 $N$ 的范围，从而得到余数为 $i$ 时的最小 $m$。

代码很短很好写。

```cpp
#define int long long
using pii=pair<int,int>;
il pii operator+(pii x,pii y){return pii(x.x+y.x,x.y+y.y);}
il pii operator+=(pii&x,pii y){return x=x+y;}
il pii operator-(pii x,pii y){return pii(x.x-y.x,x.y-y.y);}
il pii operator-=(pii&x,pii y){return x=x-y;}
il pii operator*(pii x,pii y){return pii(max(x.x,y.x),min(x.y,y.y));} // cap
il pii operator*=(pii&x,pii y){return x=x*y;}
const int inf=1LL<<60;
il void Solve()
{
  int n,k,X,Y;
  rd(n),rd(k),rd(X),rd(Y);
  pii d(X,Y),ds{};
  ve<pii>a(n);
  for(int i=0;i<n;++i) rd(a[i].x),rd(a[i].y),ds-=a[i];
  int ans=inf;
  for(int i=0;i<=n;++i) {
    pii fx(ds.x,d.x),fy(ds.y,d.y),fn(n*k,i*k),rag(0,inf);
    // |fx(N)| + |fy(N)| \le fn(N)
    auto F=[&](pii x)->pii // g(x) \ge 0 => x \in [l,r]
    {
      if(x.x) {
        if(x.x>0) return pii(ceil((db)-x.y/x.x),inf);
        else return pii(-inf,floor((db)-x.y/x.x));
      }
      else return x.y<0?pii(inf,-inf):pii(-inf,inf);
    };
    for(pii g:{fn-fx-fy,fn-fx+fy,fn+fx-fy,fn+fx+fy}) rag*=F(g);
    if(rag.x<=rag.y) {
      cn(ans,rag.x*n+i);
    }
    if(i<n) d-=a[i];
  }
  wrt(ans<inf?ans:-1,'\n');
  return;
}
```

---

## 作者：水星湖 (赞：6)

~~某个人调了 $10$ 个小时~~。

首先对题目中给出的式子做一些处理：

* $\sum \limits_{i=0}^{m-1} (x_i'+x_{i \bmod n})=x(1)$；
* $\sum \limits_{i=0}^{m-1} (y_i'+y_{i \bmod n})=y(2)$；
* $\forall 0\leq i\leq m-1,|x_i'|+|y_i'|\leq k(3)$。

首先由 $(3)$ 得，所有非零的 $x_i,y_i$ 正负必然分别相同，否则不优，那么有 $\sum \limits_{i=0}^{m-1}|y_i'|+\sum \limits_{i=0}^{m-1}|x_i'|\le mk(4)$。

记 $S_j=\sum \limits_{i=0}^{j-1} x_{i\bmod n}$，$T_j=\sum \limits_{i=0}^{j-1} y_{i\bmod n}$，由 $(4)$ 结合 $(1)$ 和 $(2)$ 得到 $|S_m-x|+|T_m-y| \le mk$。

容易发现 $S_m$ 可以表示为 $a\times S_n + S_i,i\in[0,n)$，其中 $a$ 为自然数，$T_m$ 同理。

所以可以化简为 $|a\times S_n+S_i-x|+|a\times T_n+T_i-y| \le (a\times n + i)k$。

对于每一个 $i$ 分类讨论前后两个绝对值的正负，每一种情况都能算出一个 $a$ 的取值范围，结合使这种情况成立的绝对值里面的取值范围，可以算出一个符合条件的 $a$ 的最小值，当然如果两个解集算出来没有交集，那就是不存在 $a$ 使这种情况成立（只是当前的 $i$ 和当前分讨的绝对值正负，其他还是要算），就不带着算了。

先贴下代码。
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int ans, n, k, x, y, s[100005], t[100005], l, r;
const int inf = 1ll << 60;
int ceildiv(int a ,int b)
{ 
    if(a >= 0 && b >= 0) return (a + b - 1) / b;
	if(a <= 0 && b >= 0) return  a / b;
	if(a <= 0 && b <= 0) return a = -a,b = -b,(a + b - 1) / b;
	if(a >= 0 && b <= 0) return a / b;
}

void cal(int op,int i)
{
    l = -inf,r = inf;
    if(op == 1)
    {
        if(s[n] > 0) l = ceildiv(x - s[i], s[n]);
        else if(s[n] < 0) r = (x - s[i]) / s[n];
        if(t[n] > 0) l = max(l, ceildiv(y - t[i] ,t[n]));
        else if(t[n] < 0) r = min(r, (y - t[i]) / t[n]);
    }
    if(op == 2)
    {
        if(s[n] > 0) l = ceildiv(x - s[i], s[n]);
        else if(s[n] < 0) r = (x - s[i]) / s[n];
        if(t[n] > 0) r = min(r, (y - t[i]) / t[n]);
        else if(t[n] < 0) l = max(l, ceildiv(y - t[i], t[n]));
    }
    if(op == 3)
    {
        if(s[n] > 0) r = (x - s[i]) / s[n];
        else if(s[n] < 0) l = ceildiv(x - s[i], s[n]);
        if(t[n] > 0) r = min(r, (y - t[i]) / t[n]);
        else if(t[n] < 0) l = max(l, ceildiv(y - t[i], t[n]));
    }
    if(op == 4)
    {
        if(s[n] > 0) r = (x - s[i]) / s[n];
        else if(s[n] < 0) l = ceildiv(x - s[i], s[n]);
        if(t[n] > 0) l = max(l, ceildiv(y - t[i] ,t[n]));
        else if(t[n] < 0) r = min(r, (y - t[i]) / t[n]);
    }
}

void case1(int i)
{
    int a = 0, b = inf;
    if(s[n] + t[n] - n * k > 0)
        b = (i * k + x + y - t[i] - s[i]) / (s[n] + t[n] - n * k);
    if(s[n] + t[n] - n * k < 0)
        a = ceildiv((i * k + x + y - t[i] - s[i]) , (s[n] + t[n] - n * k));
    cal(1,i);
    a = max({l, a, 0ll}); b = min(r, b);
    if(b >= a && a * s[n] + s[i] - x >= 0 && a * t[n] + t[i] - y >= 0 && a * s[n] + s[i] - x + a * t[n] + t[i] - y <= a * n * k + i * k)
        ans = min(ans,a * n + i);
}
void case2(int i)
{
    int a = 0,b = inf;
    if(s[n] - t[n] - n * k > 0)
        b = (i * k + x - y + t[i] - s[i]) / (s[n] - t[n] - n * k);
    if(s[n] - t[n] - n * k < 0)
        a = ceildiv((i * k + x - y + t[i] - s[i]) , (s[n] - t[n] - n * k));
    cal(2,i);
    a = max({l, a, 0ll}); b = min(r, b);
    if(b >= a && a * s[n] + s[i] - x >= 0 && a * t[n] + t[i] - y <= 0 && a * s[n] + s[i] - x - a * t[n] - t[i] + y <= a * n * k + i * k)
        ans = min(ans,a * n + i);
}
void case3(int i)
{
    int a = 0,b = inf;
    if(-t[n] - s[n] - n * k > 0)
        b = (i * k - x - y + t[i] + s[i]) / (-t[n] - s[n] - n * k);
    if(-t[n] - s[n] - n * k < 0)
        a = ceildiv((i * k - x - y + t[i] + s[i]) , (-t[n] - s[n] - n * k));
    cal(3,i); 
    a = max({l, a, 0ll}); b = min(r, b);
    if(b >= a && a * s[n] + s[i] - x <= 0 && a * t[n] + t[i] - y <= 0 && x + y - s[i] - t[i] - a * s[n] - a * t[n] <= a * n * k + i * k)
        ans = min(ans,a * n + i);
}
void case4(int i)
{
    int a = 0,b = inf;
    if(t[n] - s[n] - n * k > 0)
        b = (i * k - x + y - t[i] + s[i]) / (t[n] - s[n] - n * k);
    if(t[n] - s[n] - n * k < 0)
        a = ceildiv((i * k - x + y - t[i] + s[i]) , (t[n] - s[n] - n * k));
    cal(4,i);
    a = max({l, a, 0ll}); b = min(r, b);
    if(b >= a && a * s[n] + s[i] - x <= 0 && a * t[n] + t[i] - y >= 0 && x - s[i] - a * s[n] + a * t[n] + t[i] - y <= a * n * k + i * k)
        ans = min(ans,a * n + i);
}
void solve()
{
    scanf("%lld%lld%lld%lld",&n,&k,&x,&y);
    
    for(int i=1;i<=n;i++)
    {
        scanf("%lld%lld",&s[i],&t[i]);
        s[i] += s[i-1];
        t[i] += t[i-1];
    }
    ans = inf;

    for(int i=0;i<n;i++)
    {
        case1(i);
        case2(i);
        case3(i);
        case4(i);
    }
    if(ans == inf)ans = -1;
    printf("%lld\n", ans);
}
signed main()
{
    int t;cin>>t;
    while(t--) solve();
    return 0;
}

```

稍微解释一下，应该比较易懂，每个 caseX 函数首先求解不等式的解集，然后调用 cal 函数求解绝对值的解集，其次求交集，最后判断解是否符合条件。

$4$ 个情况应该是可以用一个函数的，但是懒得改了。

下面是一些细节。
- 因为除数（你解不等式和绝对值正负要做除法对吧）可能等于 $0$，所以除数是 $0$ 时不能算，也不能想当然的认为当前算出的取值范围中的最小值是成立的，要代入原式检验，~~分式魔怔了~~。
- 不等式除以负数要变号，所以有的是上取整有的是下取整要分清楚。
- ceil 函数可能会丢精度（拜谢天波）。

求赞喵。

2024.3.6 UPD：本人学校考试不等式又没变号，警钟敲烂。

---

## 作者：a_sad_soul (赞：6)

世界上有种痛是你会写但是 CE 的痛。


首先条件有 x 和 y ， 为了讨论方便我们仅讲一个 x 就行了，y 的条件同理可得 。

### 1.符号规定

- $sum[p]$ 表示的是数组 x 的前缀和,即 $sum[p]=\sum\limits_{i=1}^{n}{x_i}$

- $SumX$ 表示的是 x 中所有元素的和 ， 即 $sumX=sum[n]$

分析原式子 ， 把一个循环拆成两个：

$$\large\sum\limits_{i=1}^{m}{x_i^{'}+x_{i \mod m}}=\sum\limits_{i=1}^{m}x_i^{'}+\sum\limits_{i=1}^{m}x_{i\mod n}=x\ \ \ \ \ \ \ \ (1)$$

然后根据 $|x_i^{'}|\le k$ (不讨论 $y$ )得到 $$\large|\frac{1}{m}\sum\limits_{i=1}^{m}x_i^{'}|\le k\ \ \ \ \ (2)$$ 

我们令 $X=\sum\limits_{i=1}^{m}x_i^{'}$ ， 然后变形 (1) 式 ：

$$\large X+\sum\limits_{i=1}^{m}{x_{i\mod n}}=x$$

$$\large\Rightarrow X=x-\sum\limits_{i=1}^{m}x_{i\mod n}\ \ \ \ (3)$$

将 $(2)$ 和 $(3)$ 关联起来 ：


$$\large|\frac{1}{m}(x-\sum\limits_{i=1}^{m}x_{i\mod n})|\le k$$


两边乘 $\large\frac{1}{m}$ 然后移项得：

$$\large|x-\sum\limits_{i=1}^{m}x_{i\mod n}|-mk\le 0$$

令 $m=nt+p$ ,其中 $n\in N,p=1,2,3,...,n-1$

于是上式可以变为

$$\large|x-SumX*t-sum[p]|-(nt+q)k\le 0$$

然后看到 $p$ 的枚举量很小于是我们枚举每个 $p$ ，答案函数就简单地变为一个单峰的关于 $t$ 的函数 。

![](https://cdn.luogu.com.cn/upload/image_hosting/nij8ehgm.png)

如图答案即为最左边小于等于0的点。

我们可以对每个 $p$ 先三分找到最小值再二分更新答案即可。

时间复杂度 $O(nlogn)$。

然后恭喜你 ，最后一个点 T 了。

因为他只给了 500ms ，所以我们要考虑卡常。

考虑到如果当前已经有答案并且已经在当前函数最低点的左边 ， 那么我们仅对其进行二分即可，如果该答案点值大于0 ， 那么直接跳过，原因自证。否则进行一次三分和二分更新。

然鹅，还是有可能被极端数据卡掉(虽然会构造但是就不摆上来了doge) 。 解决办法是随机跑点就行 。

放一个代码（可以被卡掉的）：

```cpp
#include<bits/stdc++.h>
#define MAXN 200005
using namespace std;
__int128 abs(__int128 x)
{
if(x>=0)return x;
return -x;
}
long long read()
{
    long long x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
    return x*f;
}
long long n,k,x,y;
long long X[MAXN],Y[MAXN];
__int128 GetSum(__int128 q,__int128 t)
{
    __int128 a=x-X[q];
    __int128 b=y-Y[q];
    __int128 mult=k*(q+n*t);
    return abs(a-X[n]*t)+abs(b-Y[n]*t)-mult;
}
void write(__int128 x)
{
    if(x<0)putchar('-'),x=-x;
    if(x>=10)write(x/10);
    putchar('0'+x%10);
}
long long getMinnPos(long long q)
{
    long long l=0,r=1e12,mid;
    while(l+2<r)
    {
        mid=(l+r)>>1;
        if(GetSum(q,mid)>GetSum(q,mid+1))l=mid;
        else r=mid;  
        //write(GetSum(q,mid));putchar(' ');
        //write(GetSum(q,mid+1));putchar('\n');
    }
    long long re=-1;
    for(long long i=r+2;i>=max(l-2,0*1ll);--i)
    {
        if(GetSum(q,i)<=0)re=i;
    }
    return re;
}
long long getans(long long q,long long r)
{
    long long mid,re=r,l=0;
    while(l+2<r)
    {
        mid=(l+r)>>1;
        if(GetSum(q,mid)>0)l=mid+1;
        else re=mid,r=mid-1;
    }
    for(long long i=r+2;i>=max(l-2,0*1ll);--i)
    {
        if(GetSum(q,i)<=0)re=min(i*1ll,re);
    }
    return re;
}
int main()
{
    //freopen("wind.in","r",stdin);
    //freopen("wind.out","w",stdout);
    int T=read();
    while (T--)
    {
        n=read(),k=read(),x=read(),y=read();
        X[0]=Y[0]=0;
        for(int i=1;i<=n;++i)
        {
            X[i]=read()+X[i-1];
            Y[i]=read()+Y[i-1];
        }
        if(x==0&&y==0)
        {
            printf("0\n");continue;
        }
        bool sus=0;
        long long ans=1e17;
        long long T=-1;
        for(int i=1;i<=n;++i)
        {	if(T==-1){
            long long t=getMinnPos(i);
            if(t==-1)continue;
            ans=min(i+n*t,ans);
            sus=1;
            ans=min(ans,getans(i,t+5)*n+i);
            T=ans;
        	continue;
			}
        	if(GetSum(i,ans)>GetSum(i,ans+1)&&GetSum(i,ans)>0)continue;
        	else if(GetSum(i,ans)>GetSum(i,ans+1)&&GetSum(i,ans)<=0)ans=min(ans,getans(i,ans+5)*n+i);
        	else 
        	{
        	long long t=getMinnPos(i);
            if(t==-1)continue;
            ans=min(i+n*t,ans);
            sus=1;
            ans=min(ans,getans(i,t+5)*n+i);
            T=ans;
        	continue;	
			}
		}
        if(sus==1)printf("%lld\n",ans);
        else printf("-1\n");
    }
    
    return 0;
}

```


最后 ， 如果你用了 `__int128` 的话请务必重载 `abs` ,不然就会像我一样提交后吃 CE 然后暴毙（哭）。

---

## 作者：船酱魔王 (赞：6)

# P10217 [省选联考 2024] 季风 题解

## 结合背景的题意

汪洋大海可以视为一个无限大的平面直角坐标系 $ xOy $，初始时你在 $ (0,0) $ 坐标。

从 $ 0 $ 时刻开始，永恒的季风吹起，周期长度为 $ n $，在周期的第 $ i $ 时刻，你的小船会被洋流在 $ x,y $ 轴上分别偏移 $ x_i,y_i $ 距离，注意偏移量可以是负数则为向负方向偏移。

你划船很慢，每时每刻只能在两个轴上偏移加起来不超过 $ k $ 个单位长度，注意你只能竖直或水平移动，你不能直接斜着走。

已知船速、风速、终点坐标，请问你划到 $ (x,y) $ 至少需要到第几个时刻？

## 分析

心路历程参见 [我的省选赛游记](https://www.luogu.com/article/nbd3lobz) 对应部分，这里直接给出正解思路与做法。

因为季风是一个周期，所以我们可以考虑过了几个周期，对于所有 $ i $，设过了 $ t $ 个完整周期后下一个周期的第 $ i $ 时刻我们到达终点。

枚举 $ i $ 之后，如果我们想判断一个 $ t $ 是否合法的话，显然对于坐标的贡献有两部分：刮风和划船。我们可以理解为划船操作全是在积攒势能，没有真的动。即在第 $ tn+i $ 个时刻前小船无助地被风刮着走，在 $ tn+i $ 个时刻风刮完后把积攒的势能全放出来。我们只需要判断只被风刮着走的坐标到目标坐标的距离是否不超过 $ (tn+i)k $ 即可。

排除掉周期外时刻的影响，记 $ (x,y) $ 减去前 $ i $ 个坐标后为 $ (a_x,a_y) $，则需要解的方程是 $ \operatorname{dis}\{(a_x,a_y),(tS_x,tS_y)\} \le (tn+i)k $，$ \operatorname{dis} $ 表示两个点的曼哈顿距离，写成绝对值形式为 $ |tS_x-a_x|+|tS_y-a_y| \le (tn+i)k $，零点分段拆绝对值后讨论四种正负号情况把零点分段条件和 $ t $ 的求解都转化成 $ ax+b \le 0 $ 的方程形式即可。

实现很恶心，怎么办？考虑封装 $ ax+b \le 0 $ 方程的求解函数，封装解集为一个结构体，重载或设计函数封装两个解集取交集、对于最大值无穷或最小值负无穷或空集求补集和拿非空解集更新答案的操作即可，这样分类讨论过程就很简洁清新了！

注意因为周期是整数且你划船可能很慢，可能你被风刮到很远时才有机会在若干个周期正好抵达终点而不是与终点擦肩而过，所以 $ t $ 的范围可能取到 $ 3 \times 10^{13} $，这里为了保险我把答案的 `inf` 设置为 $ 9 \times 10^{18} $。

## AC 代码

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#define ll long long
#define ld long double
using namespace std;
const int N = 1e5 + 5;
int T;
int n, k, x, y;
inline int read() {
    int w, f;
    w = 1, f = 0;
    char ch = '#';
    while(ch < '0' || ch > '9') {
        ch = getchar();
        if(ch == '-') w = -1;
    }
    while(ch >= '0' && ch <= '9') {
        f *= 10;
        f += ch - '0';
        ch = getchar();
    }
    return f * w;
}
int xx[N], yy[N];
struct range {
    long long l, r;
};
range make(long long lx, long long rx) {
    range res;
    res.l = lx, res.r = rx;
    return res;
}
const range all = make(0, 3e13);
const range zero = make(2, 1);
range operator+(range p1, range p2) {
    return make(max(p1.l, p2.l), min(p1.r, p2.r));
}
range inv(range x) {
    if(x.l <= 0 && x.r >= (ll)3e13) return zero;
    if(x.l > x.r) return all;
    if(x.r >= (ll)3e13) return make(0, x.l - 1);
    if(x.l <= 0) return make(x.r + 1, (ll)3e13);
    cout << "ERROR" << endl;
    return zero;
}
long long operator+(long long p1, range p2) {
    if(p2.l <= p2.r) return min(p1, p2.l);
    return p1;
}
range prep(long long k, long long b) {
    if(k == 0) return (b <= 0) ? all : zero;
    if(k > 0) return make(0, floor((ld)(-b) / k));
    return make(ceil((ld)(-b) / k), 3e13);
}
void out(range x) {
    printf("{%lld<=x<=%lld}\n", x.l, x.r);
}
int main() {
    //freopen("wind.in", "r", stdin);
    //freopen("wind.out", "w", stdout);
    T = read();
    ll sx, sy, px, py, ax, ay, bd1, bd2;
    range smx, bgx, smy, bgy;
    for(int ti = 1; ti <= T; ti++) {
        n = read(), k = read(), x = read(), y = read();
        sx = 0, sy = 0;
        for(int i = 0; i < n; i++) {
            xx[i] = read(), yy[i] = read();
            sx += xx[i], sy += yy[i];
        }
        px = 0, py = 0;
        ll ans = (ll)9e18 + 5;
        long long nk = (long long)n * k;
        for(int i = 0; i < n; i++) {
            ax = x - px, ay = y - py;
            smx = prep(sx, -ax);
            bgx = inv(smx);
            smy = prep(sy, -ay);
            bgy = inv(smy);
            long long ik = (long long)i * k;
            long long now = 3e13 + 7;
            now = now + (bgx + bgy + prep(sx + sy - nk, -(ik + ax + ay)));
            now = now + (bgx + smy + prep(sx - sy - nk, -(ik + ax - ay)));
            now = now + (smx + bgy + prep(-sx + sy - nk, -(ik - ax + ay)));
            now = now + (smx + smy + prep(-sx - sy - nk, -(ik - ax - ay)));
            if(now < (ll)3e13 + 7) ans = min(ans, (long long)now * n + i);
            px += xx[i], py += yy[i];
        }
        if(ans <= (ll)9e18) {
            printf("%lld\n", ans);
        } else {
            printf("-1\n");
        }
    }
    return 0;
}
```

---

## 作者：EnofTaiPeople (赞：4)

看到这道题目，感觉没有什么很好的性质。

我们发现，序列长度每增大一，就可以获得 $k$ 个“贝”，可以使得 $x$ 或 $y$ 的和变动一。

设 $A_p=\sum\limits_{k=1}^px_{k-1},B_p=\sum\limits_{k=1}^py_{k-1}$。

当序列长度为 $m$ 时，我们有 $mk$ 个“贝”，需要使用 $|\lfloor\dfrac mn\rfloor A_n+A_{m\bmod n}-x|+|\lfloor\dfrac mn\rfloor B_n+B_{m\bmod n}-y|$ 个贝。

其合法当且仅当上式小于等于 $mk$，枚举 $m\bmod n$ 的值之后其形如 $|ax-b|+|cx-d|\le ex+f$ 的形式。

枚举两个绝对值的正负性，一共有四种情况，因为合法情况如果将正数取反依旧成立，所以合法当且仅当四种情况均满足。

枚举正负性之后不等式形如 $kx\ge y$，在分类讨论 $k$ 的正负性即可。

建议大家将 $\inf$ 开大，本题据说只能卡到 $5\times10^{17}$，我场上开的 $10^{18}$：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=(1<<20)+100;
using ll=long long;
using ul=unsigned long long;
using LL=__int128_t;
const ll INF=3e18;
int T,n,m,K,X,Y,c[N];
ll a[N],b[N];
LL ans;
LL sol(ll x,ll X,ll y,ll Y,ll s,ll d){
    //|x-kX|+|y-kY|<=ks+d
    ll L=0,R=INF;
    function<void(ll,ll)>run=[&](ll x,ll y){//kx>=y
        if(!x){
            if(y>0)L=INF,R=0;
            return;
        }
        if(x>0){
            if(y>0)L=max(L,(y-1)/x+1);
        }else{
            if(y>0)L=INF,R=0;
            else{
                x=-x,y=-y;
                R=min(R,y/x);
            }
        }
    };
    run(s+X+Y,x+y-d);
    run(s-X+Y,-x+y-d);
    run(s+X-Y,x-y-d);
    run(s-X-Y,-x-y-d);
    // printf("|%lld-%lld*%lld|+|%lld-%lld*%lld|<=%lld*%lld+%lld\n",x,L,X,y,L,Y,L,s,d);
    if(L>R)return INF;
    else return L;
}
int main(){
    freopen("wind.in","r",stdin);
    freopen("wind.out","w",stdout);
    ios::sync_with_stdio(false),cin.tie(0);
    int i,j,k,l,r,x,y,z;
    for(cin>>T;T--;){
        cin>>n>>K>>X>>Y;
        for(x=1;x<=n;++x){
            cin>>a[x]>>b[x];
            a[x]+=a[x-1];
            b[x]+=b[x-1];
        }
        ans=INF;
        for(x=0;x<n;++x){
            LL v=sol((ll)X-a[x],a[n],(ll)Y-b[x],b[n],1ll*K*n,1ll*K*x);
            // cerr<<x<<" "<<ll(v)<<endl;
            ans=min(ans,v*n+x);
        }
        if(ans>1e18)puts("-1");
        else printf("%lld\n",ll(ans));
    }
    return 0;
}
```

---

## 作者：ZnPdCo (赞：4)

由于下标从 $0$ 开始不方便，**该题解认为下标从 $1$ 开始**。也就是输入的是 $x_1,y_1,x_2,y_2,\dots,x_n,y_n$。

---

设 $X_n=\sum_{i=1}^n x_i$，$Y_n=\sum_{i=1}^n y_i$，$\lfloor\frac{m}{n}\rfloor=a$，$m\bmod n=b$，则有 $m=an+b$。首先容易将原式子进行转换：

$$
x-aX_n-X_b = \sum_{i=1}^{an+b} x'_i \\
y-aY_n-Y_b = \sum_{i=1}^{an+b} y'_i \\
|x'_i|+|y'_i|\le k
$$

因为要使得 $m=an+b$ 尽量小，如果 $x'_i$ 有正有负，那么肯定存在一个更优的方案，就是把正数和负数抵消掉。所以贪心地，$x'_i$ 的正负性肯定是相同的，$y'_i$ 也是同理。取 $x'_i$ 和 $y'_i$ 为正数：

$$
|x-aX_n-X_b| = \sum_{i=1}^{an+b} x'_i \\
|y-aY_n-Y_b| = \sum_{i=1}^{an+b} y'_i \\
x'_i+y'_i\le k
$$

就有：

$$
|x-aX_n-X_b|+|y-aY_n-Y_b| \le (an+b)k
$$

我们可以想到写一个判定性函数，判断 $m=an+b$ 是否存在一个合法的方案。如果存在，需要满足下面这个条件：
$$
|x-aX_n-X_b|+|y-aY_n-Y_b|\le(an+b)k
$$
考虑枚举 $a$ 和 $b$，取 $m=an+b$ 的最小值即可。

---

发现在 $|x-aX_n-X_b|$ 中有两个未知量（注意 $X_n$ 和 $Y_n$ 是已知的）：$a$ 和 $X_b$。其中 $a$ 还算好，因为它是一个系数，但 $X_b$ 就没什么规律可言了，**因为它是输入的**。

所以我们枚举 $b$，那么设 $x''=x-X_b$，$y''=y-Y_b$，此时 $x''$ 和 $y''$ 就是一个定值了（在枚举 $b$ 的情况下）。

$$
|x-aX_n-X_b|+|y-aY_n-Y_b|=|x''-aX_n|+|y''-aY_n|
$$

---

绝对值并不好做，我们能否分类讨论 $|x''-aX_n|$ 和 $|y''-aY_n|$ 的正负情况？

容易发现，它们只有 $3$ 种正负情况——两正，两负，一正一负。

我们是否可以找到这三种情况中 $a$ 的值域，然后**分三个部分**考虑？

我们设三种情况中 $a$ 的值域分别为 $[0,p_1],[p_1+1,p_2],[p_2+1,\infty]$。

对于一个绝对值函数和 $|n-am|+|x-ay|$，$p_1$ 和 $p_2$ 则分别是 $n-am=0$ 和 $x-ay=0$ 时 $a$ 的取值。容易发现它们分别为：$\lfloor\frac{n}{m}\rfloor$ 和 $\lfloor\frac{x}{y}\rfloor$。特殊地，如果分母为 $0$，分子不为 $0$，可以看做是不存在该值。

---

假如我们获得了 $p_1$ 和 $p_2$，我们怎么求解答案？

在 $[0,p_1]$ 中，$|x''-aX_n|+|y''-aY_n|=(x''-aX_n)+(y''-aY_n)$，我们就要求 $(x''-aX_n)+(y''-aY_n)\le(an+b)k$，有 $x''+y''-bk\le a(X_n+Y_n+nk)$。我们发现存在**最小解**为 $a=\lceil\frac{x''+y''-bk}{X_n+Y_n+nk}\rceil$。

在 $[p_1+1,p_2]$ 中，$|x''-aX_n|+|y''-aY_n|=(aX_n-x'')+(y''-aY_n)$，我们就要求 $(aX_n-x'')+(y''-aY_n)\le(an+b)k$，有 $-x''+y''-bk\le a(-X_n+Y_n+nk)$。我们发现存在最小解为 $a=\lceil\frac{-x''+y''-bk}{-X_n+Y_n+nk}\rceil$。

在 $[p_2+1,\infty]$ 中，$|x''-aX_n|+|y''-aY_n|=(aX_n-x'')+(aY_n-y'')$，我们就要求 $(aX_n-x'')+(aY_n-y'')\le(an+b)k$，有 $-x''-y''-bk\le a(-X_n-Y_n+nk)$。我们发现存在最小解为 $a=\lceil\frac{-x''-y''-bk}{-X_n-Y_n+nk}\rceil$。

**注意判断左边界和右边界。**

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
#define ll long long
#define N 100010 
#define inf 1e18
ll T;
ll n, k, X, Y, m;
struct node {
	ll x, y;
} a[N], s[N];
inline ll calc1(ll x, ll y) {
	if(x <= 0) return -1;			// 已满足 
	else if(y == 0) return inf;		// 永不满足
	else return x / y;				// 可满足 
}
inline ll calc2(ll x, ll y, ll l, ll r) {
	if(l < 0) l = 0;
	if(r < 0) r = -1;
	if(l > r) return inf;
	if(y > 0) {
		ll res;
		if(x <= 0) res = 0;
		else res = (x+y-1)/y;
		if(res > r) return inf;
		if(res < l) return l;
		return res;
	} else {
		if(l * y >= x) return l;
		return inf;
	}
}
int main() {
//	freopen("wind3.in", "r", stdin);
//	freopen("wind3.out", "w", stdout);
	scanf("%lld", &T);
	while(T--) {
		scanf("%lld %lld %lld %lld", &n, &k, &X, &Y);
		m = inf;
		for(ll i = 1; i <= n; i++) {
			scanf("%lld %lld", &a[i].x, &a[i].y);
			s[i].x = s[i-1].x + a[i].x;
			s[i].y = s[i-1].y + a[i].y;
		}
		if(X == 0 && Y == 0) {
			printf("0\n");
			continue; 
		}
		for(ll i = 0; i < n; i++) {
			ll x = X - s[i].x, y = Y - s[i].y, xx = s[n].x, yy = s[n].y;
			if(xx < 0) xx *= -1, x *= -1;
			if(yy < 0) yy *= -1, y *= -1;
			ll pos1 = calc1(x, xx), pos2 = calc1(y, yy);
			if(pos1 > pos2) swap(pos1, pos2), swap(x, y), swap(xx, yy);	// x-xx 会先变为 0 
			
			ll res = min({calc2(x+y-i*k, xx+yy+n*k, 0, pos1), 
						  calc2(-x+y-i*k, -xx+yy+n*k, pos1+1, pos2),
						  calc2(-x-y-i*k, -xx-yy+n*k, pos2+1, inf)});

			if(res != inf) m = min(m, res * n + i);
		}
		if(m == inf) printf("-1\n");
		else printf("%lld\n", m);
	}
} 
```

---

## 作者：aeiouaoeiu (赞：3)

upd on 2024.7.19：修改一处笔误，感谢 @[Starrykiller](https://www.luogu.com.cn/user/235125)。

考场上挂麻了。

首先整理式子，把 $x_i$ 和 $x_i'$ 分开。

- $\sum\limits_{i=0}^{m-1}x_i'=x-\sum\limits_{i=0}^{m-1}x_{i \bmod n}$；
- $\sum\limits_{i=0}^{m-1}y_i'=y-\sum\limits_{i=0}^{m-1}y_{i \bmod n}$。

看到 $|x_i'|+|y_i'|\le k$，我们不妨将 $x'$ 和 $y'$ 放到一起考虑。

- $\sum\limits_{i=0}^{m-1}(x_i'+y_i')=x-\sum\limits_{i=0}^{m-1}x_{i \bmod n}+y-\sum\limits_{i=0}^{m-1}y_{i \bmod n}$。

但是这个式子显然是不能囊括所有情况的。

例如，当 $x-\sum\limits_{i=0}^{m-1}x_{i \bmod n}<0,y-\sum\limits_{i=0}^{m-1}y_{i \bmod n}>0$ 时，两者加在一起反倒会让目标距离更短，不一定合法。

思考我们关注的是什么，**距离**。坐标可正可负，但是走到目标所需的距离一定是非负整数。

于是我们给上式加上绝对值，变成凑距离的形式。同时，我们贪心地想，对于每个 $i$，$(x_i'+y_i')$ 直接取 $k$ 一定不劣，于是我们可以继续修改式子。

- $mk\ge|x-\sum\limits_{i=0}^{m-1}x_{i \bmod n}|+|y-\sum\limits_{i=0}^{m-1}y_{i \bmod n}|$。

但是单这样还不够，$m$ 可能非常大，暴力枚举是无法承受的。

考虑到一个 $x_i$ 在 $m$ 足够大时会重复出现多次，不妨令 $m=qn+p$，再预处理 $x,y$ 数组的前缀和 $sx,sy$，可以化简式子。

- $(qn+p)k\ge|x-sx_p-q\cdot sx_{n-1}|+|y-sy_p-q\cdot sy_{n-1}|$。

接下来就是恶心的分讨了。

不妨设 $f_x(q)=|x-sx_p-q\cdot sx_{n-1}|,f_y(q)=|y-sy_p-q\cdot sy_{n-1}|$ 的函数值为 $0$ 时分别有 $\lfloor q\rfloor=xz,yz$。

对 $f_x(q)$ 进行分讨：

- $0\le q\le xz$，此时 $q$ 的增长给 $f_x(q)$ 带来了负收益。

- $q>xz$，此时 $q$ 的增长给 $f_x(q)$ 带来了正收益。

$f_y(q)$ 同理。

两个函数均呈先单调减后单调增的趋势（由于 $q\ge0$ 所以有可能出现没有单调减的情况）。此时将两个函数组合，形成了三部分，内容是类似的。

我们需要实现一个函数 `check(l,r,p,xd,yd)` 能够求出在 $l\le q\le r$，$f_x(q)-f_x(q-1)=xd\cdot sx_{n-1},f_y(q)-f_y(q-1)=yd\cdot sy_{n-1}$ 时，$q$ 的最小值。

根据函数传入的参数，我们可以知道当 $q\to q+1$ 时，$f_x(q)+f_y(q)$ 的增/减量为 $\Delta=xd\cdot sx_{n-1}+yd\cdot sy_{n-1}$。

我们设 $sum=(ln+p+1)k,bas=f_x(l)+f_y(l),R=q-l$。则我们要求一个不等式 $sum+nkR\ge bas+R\Delta$，最小的正整数解为 $R=\lceil\dfrac{bas-sum}{nk-\Delta}\rceil$。

最后判断 $l+R$ 是否出界即可。上述过程均是 $\mathcal O(1)$ 的，我们 $\mathcal O(n)$ 地枚举 $p$ 并求出最小的 $q$，最后的答案即为所有 $p$ 中最小的 $q$。

时间复杂度：$\mathcal O(\sum n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef __int128 LL;
const ll maxn=1000007,ee=1000000000000000007ll;
ll n,k,xg,yg,X[maxn],Y[maxn],sx[maxn],sy[maxn],val[maxn],ans;
LL myabs(LL x){return (x>0?x:-x);}
ll checkseg(ll l,ll r,ll p,ll xd,ll yd){
	if(l>r) return ee;
	LL sum=((LL)l*n+p+1)*(LL)k,bas=myabs(xg-sx[p+1]-(LL)l*sx[n])+myabs(yg-sy[p+1]-(LL)l*sy[n]),delt=xd*sx[n]+yd*sy[n];
	if(bas<=sum) return l*n+p+1; if(delt>=(LL)n*k) return ee;
	LL res=(bas-sum+(LL)n*(LL)k-delt-1)/((LL)n*(LL)k-delt); if(l+res>r) return ee; return (l+res)*n+p+1;
}
void solve(void){
	for(ll i=0,xz,yz,xt,yt;i<n;i++){
		if(val[i+1]!=ee) continue; xz=-1,yz=-1;
		if(sx[n]) xz=max((xg-sx[i+1])/sx[n],0ll); if(sy[n]) yz=max((yg-sy[i+1])/sy[n],0ll);
		if(xz>yz){
			val[i+1]=checkseg(0,yz,i,(sx[n]>0?-1:1),(sy[n]>0?-1:1)); if(val[i+1]!=ee) continue;
			val[i+1]=checkseg(yz+1,xz,i,(sx[n]>0?-1:1),(sy[n]>0?1:-1)); if(val[i+1]!=ee) continue;
			val[i+1]=checkseg(xz+1,ee,i,(sx[n]>0?1:-1),(sy[n]>0?1:-1));
		}else{
			val[i+1]=checkseg(0,xz,i,(sx[n]>0?-1:1),(sy[n]>0?-1:1)); if(val[i+1]!=ee) continue;
			val[i+1]=checkseg(xz+1,yz,i,(sx[n]>0?1:-1),(sy[n]>0?-1:1)); if(val[i+1]!=ee) continue;
			val[i+1]=checkseg(yz+1,ee,i,(sx[n]>0?1:-1),(sy[n]>0?1:-1));
		}
	}
}
int main(void){
	//freopen("data.in","r",stdin);
	//freopen("data.out","w",stdout);
	ios::sync_with_stdio(0),cin.tie(0);
	ll Tccs=1;
	cin>>Tccs;
	for(ll tcs=1;tcs<=Tccs;tcs++){
		cin>>n>>k>>xg>>yg; ans=ee;
		for(int i=1;i<=n;i++) cin>>X[i]>>Y[i],sx[i]=sx[i-1]+X[i],sy[i]=sy[i-1]+Y[i],val[i]=ee;
		if(xg==0&&yg==0){cout<<"0\n"; continue;}
		else solve();
		for(int i=1;i<=n;i++) ans=min(ans,val[i]);
		cout<<(ans>=ee?-1:ans)<<"\n";
	}
	return 0;
}
```

---

## 作者：鼓豆帝王 (赞：3)

题目连接：[P10217 [省选联考 2024] 季风](https://www.luogu.com.cn/problem/P10217)

## 解法说明

### 转化题意

我们先转化题意，整理一下题目里的式子

- $\sum \limits_{i=0}^{m-1} x_i'=x-\sum \limits_{i=0}^{m-1} x_{i\bmod n}$
- $\sum \limits_{i=0}^{m-1} y_i'=y-\sum \limits_{i=0}^{m-1} y_{i\bmod n}$
- $\left|\sum \limits_{i=0}^{m-1} x_i'\right|+\left|\sum \limits_{i=0}^{m-1} y_i'\right|\le mk$

不难看出，本题就是想让我们找到最小的 $m$，使得 

$$
\left|x - \sum _{i=0}^{m-1} x_{i\bmod n}\right|+\left|y - \sum _{i=0}^{m-1} y_{i\bmod n}\right|\le mk
$$

### 特殊情况

其实 $n=1$ 的情况很有提示作用，根据转化后的题意，可以列出方程

$$
|x-mx_0|+|y-my_0|\le mk
$$

注意到其中 $x,y,x_0,y_0,k$ 都是已知的常数，可以直接分类讨论解方程（其实写出正确的分类讨论才是难点，实在是烦）。

### 一般情况

我们推广上述情况，可以把原本方程中的 $m$ 看成是周期数，那么我们只需要枚举 $n$ 个周期的起点，解 $n$ 遍这样的方程，再取结果中的最小值即可。

为表述方便，下面令

- $X_i=\sum \limits_{j=0}^ix_j,i\in[0,n-1]$
- $Y_i=\sum \limits_{j=0}^iy_j,i\in[0,n-1]$
- $t$ 为周期数（也就是未知数）

则可列出方程

$$
\begin{cases}
|x-(X_i+tX_{n-1})|+|y-(Y_i+tY_{n-1})|\le (i+1+nt)k \\
t \ge 0
\end{cases} \\
$$

可以把这个方程整理成我们熟悉的样子

$$
\begin{cases}
|(x-X_i)-X_{n-1}t|+|(y-Y_i)-Y_{n-1}t|\le nkt + (i+1)k \\
t \ge 0
\end{cases} \\
$$

然后分类讨论解方程就行啦。

本题只需要开 `long long` 就够了，~~小心 `abs(__int128)`~~。

该算法的时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。

## AC 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

const ll maxN = 1e5 + 10;
const ll INF = 1e18;

struct numstr {
    ll x, y;
} nums[maxN];

ll t, n, k, x, y;
ll sumx, sumy, ans;

ll up(ll x, ll y) {
    ll res = x / y;
    if (res * y < x && y > 0) res++;
    if (res * y > x && y < 0) res++;
    return res;
}

ll down(ll x, ll y) {
    ll res = x / y;
    if (res * y > x && y > 0) res--;
    if (res * y < x && y < 0) res--;
    return res;
}

void solve(ll a, ll b, ll i, ll id) {
    ll l = 0, r = INF;
    if (sumx == 0) {
        if (a < 0) l = INF;
    }
    else if (sumx > 0) r = min(r, down(a, sumx));
    else l = max(l, up(a, sumx));
    if (sumy == 0) {
        if (b < 0) l = max(l, INF);
    }
    else if (sumy > 0) r = min(r, down(b, sumy));
    else l = max(l, up(b, sumy));
    ll q = sumx + sumy + n * k, p = a + b - i * k;
    if (q == 0) {
        if (p > 0) l = INF;
    }
    else if (q > 0) l = max(l, up(p, q));
    else r = min(r, down(p, q));
    if (l <= r && i + n * l >= 0) ans = min(ans, i + n * l);

    l = 0, r = INF;
    if (sumx == 0) {
        if (a > 0) l = INF;
    }
    else if (sumx > 0) l = max(l, up(a, sumx));
    else r = min(r, down(a, sumx));
    if (sumy == 0) {
        if (b < 0) l = max(l, INF);
    }
    else if (sumy > 0) r = min(r, down(b, sumy));
    else l = max(l, up(b, sumy));
    q = -sumx + sumy + n * k, p = -a + b - i * k;
    if (q == 0) {
        if (p > 0) l = INF;
    }
    else if (q > 0) l = max(l, up(p, q));
    else r = min(r, down(p, q));
    if (l <= r && i + n * l >= 0) ans = min(ans, i + n * l);

    l = 0, r = INF;
    if (sumx == 0) {
        if (a < 0) l = INF;
    }
    else if (sumx > 0) r = min(r, down(a, sumx));
    else l = max(l, up(a, sumx));
    if (sumy == 0) {
        if (b > 0) l = max(l, INF);
    }
    else if (sumy > 0) l = max(l, up(b, sumy));
    else r = min(r, down(b, sumy));
    q = sumx - sumy + n * k, p = a - b - i * k;
    if (q == 0) {
        if (p > 0) l = INF;
    }
    else if (q > 0) l = max(l, up(p, q));
    else r = min(r, down(p, q));
    if (l <= r && i + n * l >= 0) ans = min(ans, i + n * l);

    l = 0, r = INF;
    if (sumx == 0) {
        if (a > 0) l = INF;
    }
    else if (sumx > 0) l = max(l, up(a, sumx));
    else r = min(r, down(a, sumx));
    if (sumy == 0) {
        if (b > 0) l = max(l, INF);
    }
    else if (sumy > 0) l = max(l, up(b, sumy));
    else r = min(r, down(b, sumy));
    q = -sumx - sumy + n * k, p = -a - b - i * k;
    if (q == 0) {
        if (p > 0) l = INF;
    }
    else if (q > 0) l = max(l, up(p, q));
    else r = min(r, down(p, q));
    if (l <= r && i + n * l >= 0) ans = min(ans, i + n * l);
}

int main(void) {
    scanf("%lld", &t);
    for (ll j = 1; j <= t; j++) {
        scanf("%lld%lld%lld%lld", &n, &k, &x, &y);
        for (int i = 1; i <= n; i++) {
            scanf("%lld%lld", &nums[i].x, &nums[i].y);
        }
        if (x == 0 && y == 0) {
            printf("0\n");
            continue;
        }

        sumx = 0, sumy = 0;
        for (int i = 1; i <= n; i++) {
            sumx += nums[i].x, sumy += nums[i].y;
        }

        ll nowx = 0, nowy = 0;
        ans = INF;
        for (ll i = 1; i <= n; i++) {
            nowx += nums[i].x, nowy += nums[i].y;
            solve(x - nowx, y - nowy, i, j);
        }
        if (ans == INF) printf("-1\n");
        else printf("%lld\n", ans);
    }
    return 0;
}
```

---

## 作者：Aiopr_2378 (赞：3)

solution of P10217 [省选联考 2024] 季风

## 解题思路

对于一步操作，我们可以认为将坐标 $(x_i,y_i)$ 向距离该点不超过 $k$ 的点作偏移，然后附加到答案上。最终要求答案所在坐标点与 $(x,y)$ 重合。

发现我们起始并不关心每一步的 $x_i'$ 和 $y_i'$ 具体是多少。可以考虑把这个偏移操作放到最后作，而这样，只需统计 $m$ 个点坐标和与标准点 $(x,y)$ 的距离不超过 $mk$ 即为合法。

现在换一个参考系，对于每一步操作，移动标准点 $(x,y)$ 到位置 $(x+x_{i\bmod n},y+y_{i\bmod n})$，使得在 $m$ 个操作之后，其距离原点 $(0,0)$ 的距离不超过 $mk$。这显然和上面的是等价的。

由于 $m$ 可以很大，不妨枚举 $i=m\bmod n$，找到最小的 $t_i$ 满足条件，则 $m=\min\{i+t_in\}$。

形式化地，令 $(tmpx,tmpy)$ 为当前标准点移动到的坐标，$sumx=\sum\limits_{i=1}^n x_i,sumy=\sum\limits_{i=1}^n y_i$。则对于每个 $i=m\bmod n$，我们需要对下面关于 $t$ 的方程求解并找到最小非负整数解。

$$
|tmpx+t\times sumx|+|tmpy+t\times sumy|\le (i+tn)k
$$

拆开绝对值，会有四种情况，以一种情况为例：

$$
tmpx+tmpy+t\times (sumx+sumy)\le ik+tnk
$$

对上式换元，记

$$
\begin{cases}
A&=tmpx+tmpy\\
B&=sumx+sumy\\
C&=i\\
D&=tn
\end{cases}
$$

则需对下式求解：

$$
A+tB\le C+tD
$$

通过对 $B$ 的正负性讨论即可求解。注意特判 $B=0$ 的情况，此时若 $C-A<0$ 则无解。

对于每个值 $i$，都需要讨论四遍情况然后得到上下界求解吗？事实上只需同时对这四种情况求上下界的交集，就能得到当前 $t$ 的最优值。因为未经讨论的剩余部分一定不优或已被刨除解集。原因是 $|a|+|b|=\max(|a+b|,|a-b|)$。

这样就可以在线性的时间内求解。

## 参考代码

```cpp
#include<iostream>
#include<cmath>
using namespace std;
#define MAXN 100005
#define inf __INT64_MAX__
typedef long double ld;
typedef long long ll;
int T,n;
ll K,X,Y,x[MAXN],y[MAXN],m;
inline void getlim(ll A,ll B,ll C,ll D,ll &uplim,ll &downlim){
    if(B==D){
        if(C-A<0) uplim=-inf;
        return;
    }
    if(B-D>0) uplim=min(uplim,(ll)floor((ld)(C-A)/(B-D)));
    else downlim=max(downlim,(ll)ceil((ld)(C-A)/(B-D)));
}
ll solve(){
    m=inf;
    ll sumx=0,sumy=0;
    for(int i=1;i<=n;i++){
        sumx+=x[i];
        sumy+=y[i];
    }
    ll tmpx=-X,tmpy=-Y;
    if(tmpx==0&&tmpy==0) return 0;
    for(int i=1;i<=n;i++){
        tmpx+=x[i];
        tmpy+=y[i];
        ll uplim=inf,downlim=0;
        getlim(tmpx+tmpy,sumx+sumy,K*i,K*n,uplim,downlim);
        getlim(tmpx-tmpy,sumx-sumy,K*i,K*n,uplim,downlim);
        getlim(-tmpx+tmpy,-sumx+sumy,K*i,K*n,uplim,downlim);
        getlim(-tmpx-tmpy,-sumx-sumy,K*i,K*n,uplim,downlim);
        if(uplim>=downlim) m=min(m,downlim*n+i);
    }
    if(m==inf) return -1;
    return m;
}
int main(){
    ios::sync_with_stdio(0);
    freopen("wind.in","r",stdin);
    freopen("wind.out","w",stdout);
    cin>>T;
    while(T--){
        cin>>n>>K>>X>>Y;
        for(int i=1;i<=n;i++) cin>>x[i]>>y[i];
        cout<<solve()<<endl;
    }
    return 0;
}
```

---

## 作者：CarroT1212 (赞：3)

首先我们对题目式子进行一个移项。

$$
\sum\limits_{i=0}^{m-1}x'_i=x-\sum\limits_{i=0}^{m-1}x_{i\bmod n}\\
\sum\limits_{i=0}^{m-1}y'_i=y-\sum\limits_{i=0}^{m-1}y_{i\bmod n}
$$

右边可视作已知。因为要求每个 $|x'_i|+|y'_i|\le k$，为了让 $m$ 尽量小肯定要让 $|x'_i|+|y'_i|$ 尽量小的同时把 $k$ 卡满。结合题目背景感性理解一下，可知上面条件实际上等价于：

$$
\left|x-\sum\limits_{i=0}^{m-1}x_{i\bmod n}\right|+\left|y-\sum\limits_{i=0}^{m-1}y_{i\bmod n}\right| \le km
$$

现在怎么办呢。

------------

### 90pts

显而易见的是，直接做的话，你很难利用一些单调性之类的东西去快速二分求解。瓶颈在于 $\sum\limits_{i=0}^{m-1}x_{i\bmod n}$ 这玩意关于 $m$ 压根没有单调性。

但是如果令 $m=pn+q$，$\sum\limits_{i=0}^{m-1}x_{i\bmod n}=p\cdot(\sum\limits_{i=0}^{n-1} x_i)+\sum\limits_{i=0}^{q-1} x_i$ 的话，单调性就没那么玄学了。也就是如果我们每次只考虑模 $n$ 意义下同余的 $m$ 的话，两个绝对值里面的 $x-\sum\limits_{i=0}^{m-1}x_{i\bmod n}$ 和 $y-\sum\limits_{i=0}^{m-1}y_{i\bmod n}$ 就是个单增/单减的一次函数或者常数了，好处理很多。看看分组后有什么性质。

枚举 $q$，令 $cx=x-\sum\limits_{i=0}^{q-1} x_i,\ cy=y-\sum\limits_{i=0}^{q-1} y_i,\ sx=\sum\limits_{i=0}^{n-1} x_i,\ sy=\sum\limits_{i=0}^{n-1} y_i$。原不等式变为 $|cx-p\cdot sx|+|cy-p\cdot sy|\le (pn+q)k$。现在只有 $p$ 不知道。

画画图可以发现 $|cx-p\cdot sx|+|cy-p\cdot sy|-(pkn+qk)$ 这玩意是个关于 $p$ 的单谷函数（先单调不升后单调不降，应该可以这么叫吧），因为两个绝对值函数都是 V 字形，加起来再减个一次函数应该就是这样的。可以三分找到单谷函数极值点然后再二分前半段找到第一个 $\le 0$ 的位置。复杂度 $O(n\log V)$。

有一个很严重的问题是这个 $V$（三分上界）到底该取多少？

这个确实不太好确定……至少在 $V\le 10^{10}$ 的时候很明显会被卡，也过不去最后一个大样例。但是再往上 `long long` 就开不下了，所以我场上索性直接砸个 `__int128` 然后把 $V$ 开了 $10^{18}$。

理论复杂度确实挺对的，但是考虑一下三分+二分的常数和 0.5s 时限，还是算了吧，场上试了似乎跑过 $\sum n \le 10^5$ 都挺艰难的。

三分做法的好处是用这个函数的性质规避了几乎所有的分类讨论和 cornercase，除了三分上界之外就没有容易挂的地方了。

```cpp
ll n,k,ax,ay;
ll bx[N],by[N],smx[N],smy[N];
lll cx,cy,sx,sy,ans;
lll asb(lll x) { return x<0?-x:x; }
lll chk(lll mid,lll mod) {
	return asb(cx-mid*sx)+asb(cy-mid*sy)-k*(mid*n+mod);
}
void mian() {
	scanf("%lld%lld%lld%lld",&n,&k,&ax,&ay);
	ans=K;
	for (ll i=0;i<n;i++) scanf("%lld%lld",&bx[i],&by[i]);
	smx[0]=bx[0],smy[0]=by[0];
	for (ll i=1;i<n;i++) smx[i]=smx[i-1]+bx[i],smy[i]=smy[i-1]+by[i];
	sx=smx[n-1],sy=smy[n-1];
	for (ll mod=0;mod<n;mod++) {
		cx=ax-(mod?smx[mod-1]:0ll),cy=ay-(mod?smy[mod-1]:0ll);
		lll l=0,r=J,mid,res=J;
		while (l<r) {
			mid=l+r>>1;
			if (chk(mid,mod)<=chk(mid+1,mod)) r=mid;
			else l=mid+1;
		}
		if (chk(l,mod)<=0) {
			r=l,l=0;
			while (l<=r) {
				mid=l+r>>1;
				if (chk(mid,mod)<=0) res=mid,r=mid-1;
				else l=mid+1;
			}
			ans=min(ans,res*n+mod);
		}
	}
	if (ans==K) cout<<"-1\n";
	else write(ans),cout<<"\n";
}
```

现场认为满分做法是直接手动给这个函数分段，感觉根本调不对也想不到简单做法就扔掉没管了。

------------

### 100pts

让我们从 OIer 变成 MOer！还是那个式子 $|cx-p\cdot sx|+|cy-p\cdot sy|-(pkn+qk)\le 0$。

对绝对值相关情况的处理比较熟悉的话应该会想到，其实可以直接枚举那两个绝对值到底是怎么取的。

具体来说，枚举绝对值里面套的那两个东西的正负性，确定一下这时自变量 $p$ 的取值范围，就可以把那个绝对值扔掉当作普通一元一次不等式来处理了。四种情况加起来总共解十二个一元一次不等式即可。

封装一下确定一次函数自变量取值范围的函数，直接写就完了。复杂度变为 $O(n)$，可以过了。

```cpp
ll n,k,ax,ay;
ll bx[N],by[N],smx[N],smy[N];
lll cx,cy,sx,sy,ans;
void sol(lll a,lll b,lll c,lll &mnn,lll &mxn) {
	if (!a) { if (c==1&&b<0||c==-1&&b>0) mxn=min(mxn,-J); }
	else if (a<0) sol(-a,-b,-c,mnn,mxn);
	else {
		if (c==1) { if (b<0) mnn=max(mnn,-b/a+(-b%a!=0)); }
		else { if (b<=0) mxn=min(mxn,-b/a); else mxn=min(mxn,-J); }
	}
}
void cal(lll b,lll a,lll d,lll c,lll e,lll f,lll mod) {
	lll mnn=0,mxn=J;
	sol(a,b,1,mnn,mxn),sol(c,d,1,mnn,mxn);
	sol(a+c+e,b+d+f,-1,mnn,mxn);
	if (mnn<=mxn) ans=min(ans,mnn*n+mod);
}
void mian() {
	scanf("%lld%lld%lld%lld",&n,&k,&ax,&ay);
	ans=K;
	for (ll i=0;i<n;i++) scanf("%lld%lld",&bx[i],&by[i]);
	smx[0]=bx[0],smy[0]=by[0];
	for (ll i=1;i<n;i++) smx[i]=smx[i-1]+bx[i],smy[i]=smy[i-1]+by[i];
	sx=smx[n-1],sy=smy[n-1];
	for (ll mod=0;mod<n;mod++) {
		cx=ax-(mod?smx[mod-1]:0ll),cy=ay-(mod?smy[mod-1]:0ll);
		cal(cx,-sx,cy,-sy,-k*n,-k*mod,mod),cal(cx,-sx,-cy,sy,-k*n,-k*mod,mod);
		cal(-cx,sx,cy,-sy,-k*n,-k*mod,mod),cal(-cx,sx,-cy,sy,-k*n,-k*mod,mod);
	}
	if (ans==K) cout<<"-1\n";
	else write(ans),cout<<"\n";
}
```

~~感觉自己数学功底还是不太行，遇到那个绝对值方程第一反应就是用 OI 特产乱搞。~~

---

## 作者：sunkuangzheng (赞：3)

$\textbf{P10217}$

> - 给定 $n,k,x,y$ 和 $2n$ 个整数 $x_0,y_0,x_1,y_1,\dots,x_{n-1},y_{n-1}$。
> - 找到最小的**非负整数** $m$，使得存在 $2m$ 个实数 $x_0',y_0',x_1',y_1',\dots,x_{m-1}',y_{m-1}'$ 满足以下条件，或报告不存在这样的 $m$：
>    - $\sum \limits_{i=0}^{m-1} (x_i'+x_{i \bmod n})=x$；
>    - $\sum \limits_{i=0}^{m-1} (y_i'+y_{i \bmod n})=y$；
>    - $\forall 0\leq i\leq m-1,|x_i'|+|y_i'|\leq k$。
> - 特别地，$m=0$ 时，认为 $\sum \limits_{i=0}^{m-1} (x_i'+x_{i \bmod n})$ 和 $\sum \limits_{i=0}^{m-1} (y_i'+y_{i \bmod n})$ 均为 $0$。
> - $1 \le n \le 10^5,1 \le \sum n \le 10^6,|x_i|,|y_i|,|x|,|y| \le 10^8$。

以下令 $x_{c},y_c$ 表示当前的 $x,y$ 值，$x,y$ 特指目标值。

注意到把所有 $|x'|,|y'|$ 的增加放到最后不影响结果，也就是说如果满足 $\sum\limits_{i=0}^{m-1}|x_{i}'|+|y_{i}'| \le mk$，我们 $|x'|,|y'|$ 的增量就是合法的。

- 特殊性质 A：$|x_i|+|y_i| \le k$。

这时答案有单调性，即 $m$ 合法 $m' \ge m$ 的 $m'$ 都合法（你可以通过令 $x'=-x,y'=-y$ 来调整到 $x,y$）。

注意到一个长度为 $n$ 的完整变化序列 $\{x_0,y_0,\ldots,x_{n-1}.y_{n-1}\}$ 对 $x_c,y_c$ 的影响恒为 $sx = \sum x_i,sy = \sum y_i$，如果我们钦定 $m \bmod n = 0$，那么一个 $m$ 的合法条件是 $|m \cdot sx - x|+|m \cdot sy - y| \le m \cdot n \cdot k$，可以解出若干个区间 $m \in [l_i,r_i]$，答案就是 $n \cdot \min \{l_i\} $。

考虑 $m \bmod n \ne 0$ 的情况，此时我们相当于走了一段循环的一个前缀。令 $f = m \bmod n,p = x - \sum \limits_{i=0}^f x_i,q = y - \sum \limits_{i=0}^f y_i$，最后 $f$ 次操作即是从 $x_c = p,y_c = q$ 变成 $x_c = x,y_c = y$，同时还有 $(f+1)k$ 的 $|x'|,|y'|$ 可以使用，也就是我们的不等式为 $|m \cdot sx - p|+|m \cdot sy - q| \le (m \cdot n +f+1) \cdot k$，解出 $m \in [l_i,r_i]$ 后答案是 $n \cdot \min \{l_i\} + f + 1$。

我们枚举 $f$ 的值，预处理 $x_i,y_i$ 的前缀和，即可 $\mathcal O(n)$ 完成单组数据。总时间复杂度 $\mathcal O(\sum n)$。

注意下面代码里下标都从 $1$ 开始，可能式子和上面有一点小区别。

> - 怎么求解不等式 $|m \cdot sx - p|+|m \cdot sy - q| \le (m \cdot n+f+1) \cdot k$？
> - 这是基础初一数学知识喵。分讨 $m \cdot sx - p,m \cdot sy - q$ 的正负即可。

```cpp
/**
 *    author: sunkuangzheng
 *    created: 02.03.2024 16:20:32
**/
#include<bits/stdc++.h>
#ifdef DEBUG_LOCAL
#include <mydebug/debug.h>
#endif
using ll = long long;
using db = long double;
#define int long long
const int N = 1e5+5;
using namespace std;
ll T,n,d,k,x,y,ax[N],ay[N],ans = 9e18;
void los(){
    cin >> n >> k >> x >> y; ans = 9e18;
    for(int i = 1;i <= n;i ++) cin >> ax[i] >> ay[i],ax[i] += ax[i-1],ay[i] += ay[i-1];
    for(int i = 0;i < n;i ++){
        ll p = x - ax[i],q = y - ay[i];
        ll l = 0,r = 1e18;
        auto fk1 = [&](ll x,ll p){
            if(x < 0) l = max(l,(ll)ceil(1.0 * p / (db)x));
            else if(x > 0) r = min(r,(ll)floor(1.0 * p / (db)x));
            else if(0 > p) l = 1e18,r = 0;
        }; 
        auto fk2 = [&](ll x,ll p){
            if(x > 0) l = max(l,(ll)ceil(1.0 * p / (db)x));
            else if(x < 0) r = min(r,(ll)floor(1.0 * p / (db)x));
            else if(0 < p) l = 1e18,r = 0;
        }; 
        auto upd = [&](){
            if(l <= r) ans = min(ans,l * n + i);
            l = 0,r = 1e18;
        };
        fk2(ax[n],p),fk2(ay[n],q),fk1(ax[n] + ay[n] - n * k,k * i + p + q),upd();
        fk1(ax[n],p),fk2(ay[n],q),fk1(-ax[n] + ay[n] - n * k,k * i - p + q),upd();
        fk2(ax[n],p),fk1(ay[n],q),fk1(ax[n] - ay[n] - n * k,k * i + p - q),upd();
        fk1(ax[n],p),fk1(ay[n],q),fk1(-ax[n] - ay[n] - n * k,k * i - p - q),upd();
    }cout << (ans == 9e18 ? -1 : ans) << "\n";
}signed main(){
    ios::sync_with_stdio(0),cin.tie(0);
    for(cin >> T;T --;) los();
}
```

---

## 作者：PTqwq (赞：2)

有惊无险拿到了 $100$ 分。

考虑枚举 $m \bmod n$ 的值，设为 $i$，这样 $m$ 就可以写成 $nM + i(M \geq 0)$ 的形式了，考虑 check。

我们发现所有的 $x'$ 都 $\geq 0$ 或都 $\leq 0$，否则不优，所有的 $y'$ 同理。

设 $\displaystyle X_m = \sum_{i = 0}^{m}x_i, Y_m = \sum_{i = 0}^{m}y_i, sx = X_{n - 1}, sy = Y_{n - 1}$。

利用上面发现的性质，我们发现 $\displaystyle |\sum x'| = |sx \times M + X_i - x|, |\sum y'| = |sy \times M + Y_i - y|$，可以推出充分必要条件 $\displaystyle |\sum x'| + |\sum y'| \leq (nM + i)k$。

现在考虑暴力拆绝对值，因为 $|a| \leq b$ 等价于 $a \leq b$ 且 $-a \leq b$，所以只需要对于任意的 $0 \leq c, d \leq 1$ 满足 $\displaystyle (-1)^c\left(\sum x'\right) + (-1)^d\left(\sum y'\right) \leq (nM + i)k$ 即可。

剩下的就是 $4$ 种情况推一推不等式了，具体可以见代码注释。

剩下唯一的事情就是解 $ax \geq b(a, b \in \mathbb{Z})$ 了，只需要分类讨论下就好，只是细节稍多而已，没啥技术含量。

给出考场代码，自认为写的还行，只写了 40min：

```cpp
#include <bits/stdc++.h>
typedef long long i64;
template < class T > inline void read (T &x) {
	x = 0;
	bool f = false;
	char c = std :: getchar ();
	for ( ; c < '0' || c > '9' ; c = std :: getchar ()) f |= (c == '-');
	for ( ; c >= '0' && c <= '9' ; c = std :: getchar ()) x = (x << 1) + (x << 3) + (c & 15);
	x = (!f) ? x : -x;
	return ;
}
char buf[65];
inline void writeln (__int128 x) {
	int cnt = 0;
	if (x < 0) {
		std :: putchar ('-');
		x = -x;
	}
	if (!x) {
		std :: putchar ('0');
		std :: putchar ('\n');
		return ;
	}
	while (x > 0) {
		buf[++ cnt] = (char) (x % 10 + '0');
		x /= 10;
	}
	for (int i = cnt;i >= 1; -- i) std :: putchar (buf[i]);
	std :: putchar ('\n');
	return ;
}
bool Mbeqwq;
//#define debug(fmt, ...) fprintf(stderr, fmt, ##__VA_ARGS__)
template < class T > void chkmax (T &x, T y) {x = std :: max (x, y); return ;}
template < class T > void chkmin (T &x, T y) {x = std :: min (x, y); return ;}
const int N = 1e5 + 45;
const i64 inf = 4e18;
namespace subtask1 {
	// false -> x >= y
	//  true -> x <= y
	std :: pair < i64, bool > query (i64 a, i64 b) {
//		debug ("%lld * x >= %lld\n", a, b);
		// ax >= b
		if (!a) {
			if (b <= 0) return std :: make_pair (0, false);
			else return std :: make_pair (-1, true);
		}
		if (!b) {
			if (a > 0) return std :: make_pair (0, false);
			else return std :: make_pair (0, true);
		}
		if (a > 0) {
			if (b > 0) return std :: make_pair ((b + a - 1) / a, false);
			else return std :: make_pair (0, false);
		}
		else {
			a = -a;
			b = -b;
			// ax <= b
			if (b > 0) return std :: make_pair (b / a, true);
			else return std :: make_pair (-1, true);
		}
	}
	i64 n, k, x, y, a[N], b[N], suma[N], sumb[N];
	void solve () {
		read (n), read (k), read (x), read (y);
		for (int i = 0;i < n; ++ i) read (a[i]), read (b[i]);
		if (!x && !y) {
			printf ("0\n");
			return ;
		}
		suma[0] = a[0], sumb[0] = b[0];
		for (int i = 1;i < n; ++ i) {
			suma[i] = suma[i - 1] + a[i];
			sumb[i] = sumb[i - 1] + b[i]; 
		}
		i64 tota = suma[n - 1];
		i64 totb = sumb[n - 1];
		bool flag = false;
		__int128 ans = -1;
		for (int i = 0;i < n; ++ i) {
			i64 goalx = x - suma[i];
			i64 goaly = y - sumb[i];
			__int128 d = (__int128) (i + 1);
			i64 D = 0, U = inf;
			// goalx - M * tota + goaly - M * totb <= (M * n + d) * k
			// goalx + goaly - d * k <= M * (nk + tota + totb)
			auto res = query (n * k + tota + totb, goalx + goaly - d * k); 
			if (!res.second) chkmax (D, res.first);
			else chkmin (U, res.first);
			// goalx - M * tota + M * totb - goaly <= (M * n + d) * k
			// goalx - goaly - d * k <= M * (nk - totb + tota)
			res = query (n * k - totb + tota, goalx - goaly - d * k);
			if (!res.second) chkmax (D, res.first);
			else chkmin (U, res.first);			
			// M * tota - goalx + goaly - M * totb <= (M * n + d) * k
			// -goalx + goaly - d * k <= M * (nk - tota + totb)
			res = query (n * k - tota + totb, goaly - goalx - d * k);
			if (!res.second) chkmax (D, res.first);
			else chkmin (U, res.first);		
			// M * tota - goalx + M * totb - goaly <= (M * n + d) * k
			// -goalx - goaly - d * k <= M * (nk - tota - totb)
			res = query (n * k - tota - totb, -goalx - goaly - d * k);
			if (!res.second) chkmax (D, res.first);
			else chkmin (U, res.first);
			if (D <= U) {
				__int128 qwq = (__int128) (D);
				__int128 n_ = (__int128) (n);
				if (!flag) flag = true, ans = qwq * n_ + d;
				else chkmin (ans, qwq * n_ + d);
			}
		}
		writeln (ans);
		return ;
	}
}
bool Medqwq;
signed main () {
//	debug ("%.8lf MB\n", (&Mbeqwq - &Medqwq) / 1048576.0);
	freopen ("wind.in", "r", stdin);
	freopen ("wind.out", "w", stdout);
	int _;
	read (_);
	while (_ --) {
		subtask1 :: solve ();
	}
//	debug ("%.8lf ms\n", 1e3 * clock () / CLOCKS_PER_SEC);
	return 0;
}
// test only          : g++ wind.cpp -o wind -std=c++14 -O2 -Wall -Wextra -Wshadow
// check runtime error: g++ wind.cpp -o wind -std=c++14 -O2 -Wall -Wextra -Wshadow -fsanitize=address,undefined
```

---

## 作者：UniGravity (赞：1)

## Solution P10217 [省选联考 2024] 季风
这是一篇非三分时间复杂度 $O(n)$ 的题解。

在考场上 1h 写出了代码，但是调了 3h 还没调出来，警钟长鸣。

### 题目描述
[题目传送门](https://www.luogu.com.cn/problem/P10217)

这里解释一下形式化题目，你可以理解为小 X 的移动力是 $k$，同时会有周期性的季风对移动进行修正。

### 做法
发现直接求回合数 $m$ 较为困难。

我们想到对于每一个回合 $i$ 分别求出一个 $c$，表示走到这一步时之前经过了多少个周期，那么显然 $m=\min\{n\cdot c_i+i\}$。

对题目给出的 $x_i,y_i$ 进行**前缀和**，记为 $dx_i,dy_i$，意义就是 $i$ 回合的位置。

我们记每一个周期后**总共移动**的值为 $mx,my$，那么可以简单写出回合 $i$ 周期 $c$ 的坐标：

$$(dx_i+c\cdot mx,dy_i+c\cdot my)$$

那么显然我们要求这个满足以下式子的 $c$ 的最小值：

$$\lvert dx_i+c\cdot mx-x\rvert+\lvert dy_i+c\cdot my-y\rvert\le k(c\cdot n+i)$$

绝对值很不美观，我们考虑把它去掉。

记：

$$cx=\lceil\frac{x-dx_i}{mx}\rceil,cy=\lceil\frac{y-dy_i}{my}\rceil$$

当 $c\ge cx$ 时，$\lvert dx_i+c\cdot mx-x\rvert=dx_i+c\cdot mx-x$，反之则 $\lvert dx_i+c\cdot mx-x\rvert=-dx_i-c\cdot mx+x$。

$cy$ 同理，那么我们将题目分成了四种情况。

当 $c\ge cx,c\ge cy$ 时：

$$dx_i+c\cdot mx-x+dy_i+c\cdot my-y\le k(c\cdot n+i)$$

即：

$$c(mx+my-n\cdot k)\le i\cdot k-dx_i-dy_i+x+y$$

记 $a=(mx+my-n\cdot k),b=i\cdot k-dx_i-dy_i+x+y$，条件即为 $c\cdot a\le b$。

当 $a\ge0$ 时，为了防止漏判，直接对 $0,cx,cy$ 三者分别判断。

当 $a<0$ 时，$c$ 的值可能是 $\lceil\frac{b}{a}\rceil,0,cx,cy$，分别判断即可。

其他三种情况同理。

### 代码实现
需要注意的是，由于某些整数除法的特殊性质，$\lceil\frac{b}{a}\rceil$ 需要这么计算：
```cpp
inline int dceil(int a, int b) {
	if (a > 0) return (a - 1) / b + 1;
	else {
		int c = -a;
		return -(c / b);
	}
}
```

注意需要写 `int c = -a;` 考试就是因为这一点挂了，具体原因我也不知道（知道可以私信我）。

丑陋的完整代码：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

inline int read() {
    int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || '9' < ch) {
        if (ch == '-') f = -1;
        ch = getchar();
    }
    while ('0' <= ch && ch <= '9') {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}

const int N = 1000005;

int n, k, x, y;
int posx[N], posy[N];
int dx[N], dy[N], d[N];
int ans;

inline void updans(int v) {
    if (ans == -1 || ans > v) ans = v;
}

inline int dceil(int a, int b) {
	if (a > 0) return (a - 1) / b + 1;
	else {
		int c = -a;
		return -(c / b);
	}
}

inline int dfloor(int a, int b) {
	if (a >= 0) return a / b;
	else return (a + 1) / b - 1;
}

int tcnt = 0, tid = 104;

inline void work() {
	tcnt++;
    n = read();
    k = read();
    x = read();
    y = read();
    posx[0] = posy[0] = dx[0] = dy[0] = 0;
    for (int i = 1; i <= n; i++) {
        posx[i] = read();
        posy[i] = read();
        dx[i] = dx[i - 1] + posx[i];
        dy[i] = dy[i - 1] + posy[i];
    }
    if (x == 0 && y == 0) {
        puts("0");
        return;
    }
    int mx = dx[n], my = dy[n];
    if (mx < 0) {
        x = -x, mx = -mx;
        for (int i = 1; i <= n; i++) {
            posx[i] = -posx[i];
            dx[i] = -dx[i];
        }
    }
    if (my < 0) {
        y = -y, my = -my;
        for (int i = 1; i <= n; i++) {
            posy[i] = -posy[i];
            dy[i] = -dy[i];
        }
    }

    int res, cx, cy, a, b, c;
    ans = -1;
    int cxtag, cytag;
    for (int i = 1; i <= n; i++) {
    	if (mx == 0) {
    		if (dx[i] - x >= 0) cxtag = 1;
    		else cxtag = -1;
    		cx = 0;
		} else {
			cxtag = 0;
			cx = dceil(x - dx[i], mx);
		}
    	if (my == 0) {
    		if (dy[i] - y >= 0) cytag = 1;
    		else cytag = -1;
    		cy = 0;
		} else {
			cytag = 0;
			cy = dceil(y - dy[i], my);
		}

		// ++
		if (cxtag >= 0 && cytag >= 0) {
			a = mx + my - n * k;
			b = i * k - dx[i] - dy[i] + x + y;
			if (a >= 0) {
				c = 0;
				if (b >= 0 && (cxtag || c >= cx) && (cytag || c >= cy) && c >= 0 && c * a <= b) updans(c * n + i);
				c = cx;
				if (b >= 0 && (cxtag || c >= cx) && (cytag || c >= cy) && c >= 0 && c * a <= b) updans(c * n + i);
				c = cy;
				if (b >= 0 && (cxtag || c >= cx) && (cytag || c >= cy) && c >= 0 && c * a <= b) updans(c * n + i);
			} else {
				a = -a, b = -b;
				c = dceil(b, a);
				if ((cxtag || c >= cx) && (cytag || c >= cy) && c >= 0) updans(c * n + i);
				c = 0;
				if ((cxtag || c >= cx) && (cytag || c >= cy) && c >= 0 && c * a >= b) updans(c * n + i);
				c = cx;
				if ((cxtag || c >= cx) && (cytag || c >= cy) && c >= 0 && c * a >= b) updans(c * n + i);
				c = cy;
				if ((cxtag || c >= cx) && (cytag || c >= cy) && c >= 0 && c * a >= b) updans(c * n + i);
			}
		}

		// +-
		if (cxtag >= 0 && cytag <= 0) {
			a = mx - my - n * k;
			b = i * k - dx[i] + dy[i] + x - y;
			if (a >= 0) {
				c = 0;
				if (b >= 0 && (cxtag || c >= cx) && (cytag || c < cy) && c >= 0 && c * a <= b) updans(c * n + i);
				c = cx;
				if (b >= 0 && (cxtag || c >= cx) && (cytag || c < cy) && c >= 0 && c * a <= b) updans(c * n + i);
				c = cy - 1;
				if (b >= 0 && (cxtag || c >= cx) && (cytag || c < cy) && c >= 0 && c * a <= b) updans(c * n + i);
			} else {
				a = -a, b = -b;
				c = dceil(b, a);
				if ((cxtag || c >= cx) && (cytag || c < cy) && c >= 0) updans(c * n + i);
				c = 0;
				if ((cxtag || c >= cx) && (cytag || c < cy) && c >= 0 && c * a >= b) updans(c * n + i);
				c = cx;
				if ((cxtag || c >= cx) && (cytag || c < cy) && c >= 0 && c * a >= b) updans(c * n + i);
				c = cy - 1;
				if ((cxtag || c >= cx) && (cytag || c < cy) && c >= 0 && c * a >= b) updans(c * n + i);
			}
		}

		// -+
		if (cxtag <= 0 && cytag >= 0) {
			a = -mx + my - n * k;
			b = i * k + dx[i] - dy[i] - x + y;
			if (a >= 0) {
				c = 0;
				if (b >= 0 && (cxtag || c < cx) && (cytag || c >= cy) && c >= 0 && c * a <= b) updans(c * n + i);
				c = cx - 1;
				if (b >= 0 && (cxtag || c < cx) && (cytag || c >= cy) && c >= 0 && c * a <= b) updans(c * n + i);
				c = cy;
				if (b >= 0 && (cxtag || c < cx) && (cytag || c >= cy) && c >= 0 && c * a <= b) updans(c * n + i);
			} else {
				a = -a, b = -b;
				c = dceil(b, a);
				if ((cxtag || c < cx) && (cytag || c >= cy) && c >= 0) updans(c * n + i);
				c = 0;
				if ((cxtag || c < cx) && (cytag || c >= cy) && c >= 0 && c * a >= b) updans(c * n + i);
				c = cx - 1;
				if ((cxtag || c < cx) && (cytag || c >= cy) && c >= 0 && c * a >= b) updans(c * n + i);
				c = cy;
				if ((cxtag || c < cx) && (cytag || c >= cy) && c >= 0 && c * a >= b) updans(c * n + i);
			}
		}

		// --
		if (cxtag <= 0 && cytag <= 0) {
			a = -mx - my - n * k;
			b = i * k + dx[i] + dy[i] - x - y;
			if (a >= 0) {
				c = 0;
				if (b >= 0 && (cxtag || c < cx) && (cytag || c < cy) && c >= 0 && c * a <= b) updans(c * n + i);
				c = cx - 1;
				if (b >= 0 && (cxtag || c < cx) && (cytag || c < cy) && c >= 0 && c * a <= b) updans(c * n + i);
				c = cy - 1;
				if (b >= 0 && (cxtag || c < cx) && (cytag || c < cy) && c >= 0 && c * a <= b) updans(c * n + i);
			} else {
				a = -a, b = -b;
				c = dceil(b, a);
				if ((cxtag || c < cx) && (cytag || c < cy) && c >= 0) updans(c * n + i);
				c = 0;
				if ((cxtag || c < cx) && (cytag || c < cy) && c >= 0 && c * a >= b) updans(c * n + i);
				c = cx - 1;
				if ((cxtag || c < cx) && (cytag || c < cy) && c >= 0 && c * a >= b) updans(c * n + i);
				c = cy - 1;
				if ((cxtag || c < cx) && (cytag || c < cy) && c >= 0 && c * a >= b) updans(c * n + i);
			}
		}
    }
	printf("%lld\n", ans);
}

signed main() {
    int T = read();
    while (T--) work();
    return 0;
}
```

---


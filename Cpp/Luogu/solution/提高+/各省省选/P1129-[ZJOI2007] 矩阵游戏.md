# [ZJOI2007] 矩阵游戏

## 题目描述

小 Q 是一个非常聪明的孩子，除了国际象棋，他还很喜欢玩一个电脑益智游戏――矩阵游戏。矩阵游戏在一个 $n \times n$ 黑白方阵进行（如同国际象棋一般，只是颜色是随意的）。每次可以对该矩阵进行两种操作：

- 行交换操作：选择矩阵的任意两行，交换这两行（即交换对应格子的颜色）。
- 列交换操作：选择矩阵的任意两列，交换这两列（即交换对应格子的颜色）。

游戏的目标，即通过若干次操作，使得方阵的主对角线(左上角到右下角的连线)上的格子均为黑色。

对于某些关卡，小 Q 百思不得其解，以致他开始怀疑这些关卡是不是根本就是无解的！于是小 Q 决定写一个程序来判断这些关卡是否有解。


## 说明/提示

#### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $n \leq 7$。
- 对于 $50\%$ 的数据，保证 $n \leq 50$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 200$，$1 \leq T \leq 20$。


## 样例 #1

### 输入

```
2
2
0 0
0 1
3
0 0 1
0 1 0
1 0 0
```

### 输出

```
No
Yes
```

# 题解

## 作者：Night_Aurora (赞：154)

看到下面都有详细的代码也没什么可解释的，说一下推导过程吧

最终状态是（1,1）（2，2）...(n,n)都有一个点

我们把点看成匹配边的话，就是每行和每列都做到了匹配

换言之就是N个行和N个列都有匹配时，一定能转换成最终状态

所以就如S向每行所对应的点连边，每列所对应的点向T连边

每个1的块就是某行和某列的边

再逆过来转换到初始状态，我们发现交换行本质就是交换S向这两行连的边，所以匹配数不变

同理交换列也是

所以只要按照最初状态建二分图跑最大流，就是可能的最终状态的最大流

当且仅当最大流是N的时候可以转换到最终状态


---

## 作者：俾斯麦 (赞：124)

## 详谈二分图最大匹配解法 和 网络流 Dinic解法
#### 1.题目分析
#### 2.匈牙利二分图匹配解法
#### 3.Dinic网络流解法


------------

## 1.题目分析

由题意得，我们可以对**任意两行**或**两列**进行交换操作。初看似乎没有头绪，那先来分析一组简单数据。

```
1
0 0 1
1 0 0
0 1 0
```
我们考虑将每一行的**行数**与该行**黑色方块**所在的**列数**连一条边。

然后可以将它进行如**下图**的变化得到答案

![](http://wx1.sinaimg.cn/mw690/007BSLUzgy1fzj2ax77kuj30ro0n6jte.jpg)

我们可以看出，**右图**中的**每一**行列都**至少**有一个符合的匹配（显然）。

进而我们思考，是否是**每一行列**至少存在一组合法匹配的图形合法呢？
#### 答案是的

因为任意两行或者任意两列之间的交换都不会破坏他们的**平衡性**。
#### 也就是说，任意2个黑色方块，如果它们初始状态时不在同一行（列），那么无论如何交换，它们都不会在同一行（列）。

所以我们可以得到第一种解法 匈牙利二分图匹配解法。


------------

## 2.匈牙利二分图匹配解法


经过上述分析，交换操作并**不会**影响图的**最大匹配**，我们只需判断**每一行是否都可以合法匹配**即可。

那么显然是一道板子似的**二分图最大匹配**。

**AC代码：**

```cpp
#include<bits/stdc++.h>
using namespace std;

const  int  N = 400 + 15 ;//稍微开大一点。

int  head[ N*N ] , to [ N*N ] , next[ N*N ] , tot = 1 ,ans = 0  ;

int  match[ N ] ,  visit[ N ] , n , T  ;

inline int read() //快读
{
    int s = 0,w = 1;
    char g = getchar();
    while(g<'0'||g>'9'){if(g=='-')w*=-1;g = getchar();}
    while(g>='0'&&g<='9'){s = s*10+g-'0';g = getchar();}
    return s*w;
}

void  add( int  x , int  y ){ //前向星建边
    tot++ ;
    to[ tot ] = y ;
    next[ tot ] = head[ x ] ;
    head[ x ] = tot ;
}

bool  dfs( int  x ){ //匹配
    for( int  i = head[ x ] , y  ; i ; i = next[ i ] )
        if( !visit[ y = to[ i ] ] ){
            visit[ y ] = 1 ;
            if( !match[ y ] || dfs(match[ y ] ) ){
                match[ y ] = x ; return true ;
            }
        }
    return  false ;
}

void  clear(){ //多组数据，清零初始化
    T-- ;
    ans = 0 ; 
    for( int  i = 1 ; i<= tot ; i++ )   //这种方式可以避免memset()浪费过多时间
        to[ i ] = head[ i ] = next[ i ] = 0 ;
    tot = 1 ;
    for( int  i = 1 ; i <= 2*n ; i++ ){
        match[ i ] = 0 ;
    }
}

int  main()
{
    T = read() ;
    while( T != 0 ){
        n = read() ;
        for( int  i = 1 ; i <= n ; i++)
            for( int  j = 1 ;  j <= n ; j++ ){//读入并建边
                int  m1 = read() ;
                if( m1 == 1 )
                    add( i , j + n ) ;
            }
        for( int  i = 1 ; i <= n ; i++ ){
            memset( visit , 0 , sizeof(visit) ) ;
            if( dfs(i) )ans ++ ;
        }
        if( ans >= n )printf("Yes\n");//有足够的匹配
        else printf("No\n");
        clear();
    }
    return  0 ;
}
```

**提示：$clear()$ 函数中
清零时用了多少就清零多少，有效节约因$memset()$清零空数组而浪费的时间**



------------

## 3.Dinic网络流解法

如果对**网络流**没有了解的同学可以**参考**[网络流初步详解](https://www.luogu.org/blog/sswcdak/bi-ji-wang-lao-liu-chu-bu)，或其他博客。


对于网络流**有了解**的同学就可以**开心**地用这道题**练习网络流**了。

我们再次观察之前处理的图形，如**下图**。我们发现，求解最大匹配的过程可以演化成**单边容量**为 $1$ 的**网络流**进行求解。



![](http://wx1.sinaimg.cn/mw690/007BSLUzgy1fzj2awrbr0j30nm0f7wg6.jpg)

而我们做的，只需在**虚拟源点**和**行**之间建立**容量为 $1$** 的边，在在**虚拟汇点**和**列**之间建立**容量为 $1$ **的边即可。

同时在读入时建立**行列**之间**容量为 $1$ **的边。

最后跑一遍**$Dinic$算法**。

**$AC$代码**

```cpp
#include<bits/stdc++.h>
using namespace std;

const  int  inf =  0x3f3f3f3 , N = 40000 + 19  ;

int  head[ N*2 ] , d[ N*2 ] , to[ N*10*2 ] , w[ N*10*2 ] , next[ N*10*2 ]  ;

int  n , s, t , tot = 1 , maxflow = 0 , T ;//maxflow记录答案 

inline int read()
{
    int s = 0,w = 1;
    char g = getchar();
    while(g<'0'||g>'9'){if(g=='-')w*=-1;g = getchar();}
    while(g>='0'&&g<='9'){s = s*10+g-'0';g = getchar();}
    return s*w;
}

queue<int> q ;//广搜时采用队列

void  add( int  x , int  y , int  z ){
    tot++; to[ tot ] = y , w[ tot ] = z , next[ tot ] = head[ x ] , head[ x ] = tot;
    tot++; to[ tot ] = x , w[ tot ] = 0 , next[ tot ] = head[ y ] , head[ y ] = tot;
}//建立边和反向边，注意反向边的流量初始为 0 

bool  bfs(){//在残量网络上构造分层图
    memset( d , 0 , sizeof(d) ) ; //将之前的分层清0，继续跑残量网络找可行增广路
    while( q.size() ) q.pop() ; //队列清 0 ;
    q.push( s ) ; d[ s ] = 1 ; //将源点加入队列，层数为 1 ，开始广搜 
    while( q.size() ){
        int  x = q.front() ; q.pop() ;
        for( int  i = head[ x ] ; i ; i = next[ i ])
            if( w[ i ] && !d[ to[i] ] ){//目标边的流量不为0 且 为被遍历分层
                q.push( to[ i ] ) ;
                d[ to [ i ] ] = d[ x ] + 1;
                if( to[ i ] == t )return 1 ; //找到一条可行增广路
            }
    }
    return 0 ;//未找到，不存在增广路
}

int  dinic( int  x , int  flow ){ //在分层图上进行增广
    if( x == t )return flow ;//源点即使汇点，流量不限量
    int  rest = flow , k ;
    for( int  i = head[ x ] ; i && rest ; i = next[ i ] )//当前可流入最大流量不为0 ,
        if( w[ i ] && d[ to [ i ] ] == d[ x ] + 1 ){//目标路径有剩余流量，且不存在环之类神奇的东西
        	k = dinic( to[ i ] , min( rest , w[ i ] ) );//继续搜
        	if( !k )d[ to [ i ] ] = 0 ; //剪枝，如果 k(下一层可流入流量图为 0 )，cut
        	w[ i ] -= k ; 
        	w[ i ^ 1 ] += k ;//占用k流量，注意反边要加上k，不然无法退回
        	rest -= k ; //当前节点的剩余汇入流量-k;
        }
       return flow - rest ; //递归完成
}

void  clear(){
    T-- ; maxflow = 0 ;
    for( int  i = 1 ; i<= tot ; i++ )
        w[ i ] = to[ i ] = head[ i ] = next[ i ] = 0 ;
    tot = 1 ;
}

int  main()
{
    T = read() ;
    while( T != 0 )
    {
        n = read() ; s = 2*n + 1 ; t = 2*n + 2 ;
        for( int  i = 1 ; i <= n ; ++i ){
            add( s , i , 1 ); add( i + n , t , 1 ) ;
        }
        for( int  i = 1 ; i <= n ; ++i )
            for( int  j = 1 ; j <= n ; j++ ){
                int  x = read() ;
                if( x ){
                    add( i , j + n , 1 ) ; 
                }
            }
        int  flow = 0 ; 
        while( bfs() ){//存在增广路
            while( flow = dinic ( s , inf ))maxflow += flow ; 
        }
        if( maxflow >= n )printf("Yes\n");
        else  printf("No\n");
        clear() ;
    }
    return  0 ;
}
```

**再次提示：$clear()$ 函数中
清零时用了多少就清零多少，有效节约因$memset()$清零空数组而浪费的时间**

###  _本文到此结束，若有不足，恳请大佬指出。_ 

 ### _ 如果你喜欢我的文章，请大力点赞支持！感谢。_ 

---

## 作者：cmwqf (赞：61)

![](https://cdn.luogu.com.cn/upload/pic/23073.png)

这是一幅二分图，黑色的点代表行，蓝色的点代表列；

我们给每一行每一列一个id,初始状态下id[i]=i,例如初始状态下的第一列为1，以后不管它变为第几列，它的id就是1，图中的点表示的是行或列的id；

如果第i行第j列是1，就给id[i]和id[j]连一条边；

![](https://cdn.luogu.com.cn/upload/pic/23074.png)

这是将第一列和第三列交换以后的情况，红色的是被改变的边，可以发现，这样的改变只是把两个节点的位置调换了一下，其实和原来的图是一样的，只是蓝色节点3和蓝色节点1位置不同而已，也就是说，这样的交换并不改变整体，不改变最大匹配。

于是，我们便可以按照原来的图找最大匹配ans，若ans=n，即yes,否则，即no；

~~图画的太丑请见谅~~

上代码：


------------
```
#include<cstdio>
#include<cstring>
using namespace std;
const int maxN=500;
int n,ans,t;
int matched[maxN+1];
bool G[maxN+1][maxN+1],vis[maxN+1];
bool dfs(int x)
{
    for(int i=1;i<=n;i++)
            if(G[x][i]&&!vis[i])
            {
                vis[i]=true;
                if(!matched[i]||dfs(matched[i]))
                {
                    matched[i]=x;
                    return true;
                }
            }
    return false;
}
int main()
{
    scanf("%d",&t);
    while(t--)
    {
        memset(matched,0,sizeof(matched));
        memset(G,false,sizeof(G));
        ans=0;
        scanf("%d",&n);
        for(int i=1;i<=n;i++)
           for(int j=1;j<=n;j++) scanf("%d",&G[i][j]);
        for(int i=1;i<=n;i++)
        {
            memset(vis,false,sizeof(vis));
            ans+=dfs(i);
        }
        if(ans==n) printf("Yes\n");
        else printf("No\n");
    }
    return 0;
}
```

---

## 作者：Azuree (赞：49)

[查看原题请戳这里](https://www.luogu.org/problem/P1129)  
首先，题目告诉我们有以下两种操作：  
1. 行交换操作：选择矩阵的任意两行，交换这两行（即交换对应格子的颜色）  

2. 列交换操作：选择矩阵的任意两列，交换这两列（即交换对应格子的颜色

但是，实际上我们只需要进行其中的一种操作就可以了。即我们两种操作混着用其实是没有什么效果的，这一点后文会解释到。  

假设我们只交换行，那么如果有一行是这样的：  
$$0\ 1\ 0\ 0$$
那么很显然，这一列能且只能在第二行上。  
再看一个例子：  
$$0\ 1\ 1\ 0$$
我们发现，这一行既可以放到第二行，也可以放到第三行。  
所以，如果第i行需要在第k列上的颜色为黑色（数字为1），那么我们就将i和k连一条边。注意，这一步看上去是行和列匹配，但实际上则是边和边进行匹配——第i条边可以放到第k条边的位置上。因为对于一个正方形，其左上-右下的对角线会经过第k条边的第k个位置。  
然后我们就可以去跑二分图最大匹配，若匹配数等于边数，则有解，否则无解。  
为什么只考虑一种操作就可以了呢？  
![](https://cdn.luogu.com.cn/upload/pic/72296.png)  
如图，我们发现第3列没有黄格，第2列有2个黄格，但交换了第2、3列以后，第2列就没有黄格了。所以说，在进行一种操作的基础上，进行另一种操作无非是拆东墙，补西墙。  
code：  
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<algorithm>
#define ll long long
#define INF 0x7fffffff
#define re register
#define qwq printf("qwq\n");

using namespace std;

int read()
{
	register int x = 0,f = 1;register char ch;
	ch = getchar();
	while(ch > '9' || ch < '0'){if(ch == '-') f = -f;ch = getchar();}
	while(ch <= '9' && ch >= '0'){x = x * 10 + ch - 48;ch = getchar();}
	return x * f;
}

int n,cnt,x,tot,T,d[100005];
int with[100005],pd[100005];

struct edge{
	int next,to,from;
}e[200005];

void add(int x,int y)
{
	e[++cnt].to = y;
	e[cnt].from = x;
	e[cnt].next = d[x];
	d[x] = cnt;
}

int find(int u)
{
	for(int i = d[u]; i; i = e[i].next)
	{
		int v = e[i].to;
		if(!pd[v])
		{
			pd[v] = 1;
			if(with[v] == 0 || find(with[v]))
			{
				with[v] = u;
				return 1;
			}
		}
	}
	return 0;
}

void cl()
{
	for(int i = 1; i <= cnt; i++) e[i].to = 0;
	cnt = 0;
	tot = 0;
	memset(d,0,sizeof(d));
	memset(with,0,sizeof(with));
}

int main()
{
	T = read();
	while(T--)
	{
		n = read();
		cl();
		for(int i = 1; i <= n; i++)
			for(int j = 1; j <= n; j++)
			{
				x = read();
				if(x) add(i,j);
			}
		for(int i = 1; i <= n; i++) 
		{
			memset(pd,0,sizeof(pd));
			if(find(i)) tot++;
		}
		if(tot == n) printf("Yes\n");
		else printf("No\n");
	}
    return 0;
}
```

---

## 作者：lemir3 (赞：20)

[*获得更好的阅读体验*](https://www.cnblogs.com/Lemir3/p/11104604.html)

[*题面*](https://www.luogu.org/problemnew/show/P1129)

这道题神啊.

看了一下午没有思路,感觉是二分图没有深刻理解,又重新看了一遍蓝书上的二分图,还打了道题练手,然而还是没有想出这道题...

于是恰饭回来决定看下题解,恍然大悟.

同志们可以把每一个点看做一条匹配边,把它的的行数和列数连一条边,会发现整幅图是一组匹配.

在交换行和列的时候,相当于在匈牙利算法中进行协商的过程,所以对最大匹配不变.

如果交换后可以有n个及以上的匹配,就说明一定可以实现题意.

配图如下(图里的字体有点小请见谅):

![配图1.png](https://i.loli.net/2019/06/28/5d160027d19d712932.png)

![配图2.png](https://i.loli.net/2019/06/28/5d160027e78e354573.png)

然后就是跑一个裸的匈牙利,求出匹配个数就可以了.

**代码:**

```cpp

#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>

using namespace std;

struct edge
{
    int to,next;
}e[1000010];

int t,n,size,CommunismParty_cnt;
int head[1000010],match[1000010];
bool flag[1000010];

inline void EdgeAdd(int,int);
inline void Hungary();
inline bool find(int);

int main()
{
    scanf("%d",&t);
    for(int _=1;_<=t;_++)
    {
        scanf("%d",&n);
        CommunismParty_cnt=0;
        size=0;
        memset(head,-1,sizeof(head));
        memset(match,0,sizeof(match));
        memset(e,0,sizeof(e));
        for(int __=1;__<=n;__++)
        {
            for(int ___=1;___<=n;___++)
            {
                int CommunistYouthLeague_color;
                scanf("%d",&CommunistYouthLeague_color);
                if(CommunistYouthLeague_color==1)
                {
                    EdgeAdd(__,___);
                }
            }
        }
        Hungary();
        printf("%s\n",CommunismParty_cnt>=n?"Yes":"No");
    }
return 0;
}

inline void EdgeAdd(int from,int to)
{
    e[++size].to=to;
    e[size].next=head[from];
    head[from]=size;
}

inline void Hungary()
{
    for(int _=1;_<=n;_++)
    {
        memset(flag,false,sizeof(flag));
        if(find(_)==true)
        {
            CommunismParty_cnt++;
        }
    }
}

inline bool find(int from)
{
    for(int _=head[from];_!=-1;_=e[_].next)
    {
        int to=e[_].to;
        if(flag[to]==false)
        {
            flag[to]=true;
            if(match[to]==0||find(match[to])==true)
            {
                match[to]=from;
                return true;
            }
        }
    }
return false;
}

```


---

## 作者：是个汉子 (赞：19)

### Solution

在我看完这道题一筹莫展没有思路的时候，我开始~~玩国际象棋~~手模样例，然后发现了一个小结论：**同行同列的点无论经过多少次变换仍然同行或同列**。

所以题目可转化为：能不能找到 $n$ 个互相不同行同列的点。

那我们可以建一个二分图，左边是行，右边是列，如果一个点是黑色的，就从左边连右边，求最大匹配看等不等于 $n$ 。

如果不用网络流的话，只用二分图的做法，时间复杂度 $O(n^3)$ 。
### 代码

```c++
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>

using namespace std;
const int N=400010;
int to[N],nxt[N],head[N],cnt;
int n,T;

inline int read(){
	int x=0,f=1;
	char ch=getchar();
	while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)){x=x*10+(ch^48);ch=getchar();}
	return x*f;
}

inline void add(int u,int v){
	to[++cnt]=v;
	nxt[cnt]=head[u];
	head[u]=cnt;
}

int tim,vis[N],match[N];
int dfs(int x){
	for(int i=head[x];i;i=nxt[i]){
		int y=to[i];
		if(vis[y]==tim) continue;
		vis[y]=tim;
		if(!match[y]||dfs(match[y])){
			match[y]=x;return 1;
		}
	}
	return 0;
}//最大匹配--匈牙利算法 

inline void init(){
	memset(head,0,sizeof(head));
	memset(nxt,0,sizeof(nxt));
	memset(to,0,sizeof(to));
	memset(match,0,sizeof(match));
	cnt=0;
}

int main(){
	T=read();
	while(T--){
		init();
		n=read();
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++){
				int x=read();
				if(x){
					add(i,j+n);add(j+n,i);
				}
			}
		int ans=0;
		for(int i=1;i<=n;i++) tim++,ans+=dfs(i);
		if(ans==n) puts("Yes");
		else puts("No");
	}
	return 0;
} 
```

---

## 作者：yuy_ (赞：16)

发一篇我认为通俗的理解方式。

因为任意两行都可以互相交换，

所以，对于一个(i,j)上的1，

我们可以认为是：

#### 用第i行第j列的1去作为第j列上的对角线上的1。（通过与第j行交换，达到目的。）

那么只要是能够完美匹配就等价于每个对角线上的1都能通过和某一行交换的方式达成目的。

这是我认为的很容易理解的。（可以尝试多读几遍）

如果对你有帮助的话请点个赞。

```cpp

#include<cstdio>
#include<cstring>
#define LL long long
#define Set(s,v) memset(s,v,sizeof(s))
using namespace std;
inline LL read(){
    LL ans=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-'){f=-1;}ch=getchar();}
    while(ch>='0'&&ch<='9'){ans=(ans<<3)+(ans<<1)+(ch^48);ch=getchar();}
    return ans*f;
}
void write(LL x){
    if(x<0){putchar('-');x=-x;}
    if(x>9){write(x/10);}
    putchar(x%10|48);
}
struct Edge{
    int next,v;
}edge[40005];
int head[205],cnt;
int mark[205],match[205],tim;

inline void add(int u,int v){
    cnt++;
    edge[cnt].next=head[u];
    edge[cnt].v=v;
    head[u]=cnt;
    return;
}
inline void flush(){
    Set(head,0);
    Set(mark,0);
    Set(match,0);
    tim=0;
    cnt=0;
    return;
}
int augment(int u){
    for (int i=head[u];i;i=edge[i].next){
        int v=edge[i].v;
        if(mark[v]==tim) continue;
        mark[v]=tim;
        if(match[v]==0||augment(match[v])){
            match[v]=u;
            return true;
        }
    }
    return false;
}
inline int hungarian(int n){
    int res=0;
    for (int i=1;i<=n;i++){
        tim++;
        if(augment(i)){
            res++;
        }
    }
    return res;
}

int main(){
    int T=read();
    while(T--){
        flush();
        int n=read();
        for (int i=1;i<=n;i++){
            for (int j=1;j<=n;j++){
                int t=read();
                if(t){
                    add(i,j);
                }
            } 
        }
        printf("%s\n",hungarian(n)==n?"Yes":"No");
    }
    return 0;
}

```

---

## 作者：hs_black (赞：10)

## 二分图匹配

[P1129](https://www.luogu.org/problem/P1129)

这个题还是有一定套路的

将黑色格子所在的行和列连边, 跑一边最大匹配, 如果是完美匹配即可(所有点都是匹配点)

why?

在完美匹配的情况下

假如 列1 -> 行5 , 列4 -> 行1 (->表示匹配) 

我们则可以将行5和行1换一下位置, 这样交换 列不会受到影响,  匹配变为列1 -> 行1, 列4 -> 行5

同理, 列2, 列3, 列4也可以通过和别人交换来搞到自己的菜

证毕

代码:

```c++
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int N = 40005;
int h[N], ne[N * 2], to[N * 2];
int tot, T, n;

void add(int x,int y) {
	ne[++tot] = h[x];
	h[x] = tot, to[tot] = y;
}

int read(void) {
	int x = 0;
	char c = getchar();
	while (!isdigit(c)) c = getchar();
	while (isdigit(c)) {
		x = (x << 3) + (x << 1) + c - '0';
		c = getchar();
	}
	return x;
}

int tim, vis[N], match[N];

int dfs(int x) {
	for (int i = h[x]; i; i = ne[i]) {
		int y = to[i];
		if (vis[y] == tim) continue;
		vis[y] = tim;
		if (!match[y] || dfs(match[y])) {
			match[y] = x; return 1;
		}
	}
	return 0;
}

void pre(void) {
	memset(h, 0, sizeof(h));
	memset(ne, 0, sizeof(ne));
	memset(to, 0, sizeof(to));
	memset(match, 0, sizeof(match));
	tot = 0;
}

int main() {
	T = read();
	while (T--) {
		pre();
		n = read();
		for (int i = 1;i <= n; i++) 
		for (int j = 1;j <= n; j++) {
			int x = read();
			if (x) {
				add(i, j + n); add(j + n, i);
			}
		}
		int ans = 0;
		for (int i = 1;i <= n; i++) 
		tim++, ans += dfs(i);
		if (ans == n) printf("Yes\n");
		else printf("No\n");
	}
	return 0;
}
```



---

## 作者：ff_666 (赞：7)

这题，初看题面完全没有想法。。

看了楼下大佬的题解，一画图，顿时茅塞顿开

~~\*不要被题面干扰（显然只考虑黑格即可）——任意行间、列间都可以交换，想想玩魔方，实际上你想让一个格子跑哪，就能让它跑哪（**但会对其他的造成影响！**）\*~~

当然对于本题，可以肯定的是，想让某一行到一个位置，是可以办到的

So，只要让每行有一个黑格配对，且配对的黑格中，每列没有重复的。没有配对的怎么办？就到其他行“借”呗！这样最后将每行排个顺序，不就符合对角线了吗！

那么判断成功与否显然只要看看每行能否都有匹配——二分匈牙利！！

```cpp
    #include<cstdio>
    #include<cstring>
    using namespace std;
    int T,n,lnk[205][205],p[205];bool vis[205];
    int read(){
        int ret=0;char ch=getchar();
        while(ch<'0'||ch>'9') ch=getchar();
        while(ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=getchar();
        return ret;
    }
    bool DFS(int x){
        for(int j=1;j<=lnk[x][0];j++)if(!vis[lnk[x][j]]){
            vis[lnk[x][j]]=1;
            if(!p[lnk[x][j]]||DFS(p[lnk[x][j]])){p[lnk[x][j]]=x;return 1;}
        }
        return 0;
    }
    int main(){
        T=read();bool flg;
        while(T--){
            n=read();
            for(int i=1;i<=n;i++){
                p[i]=lnk[i][0]=0;
                for(int j=1;j<=n;j++) if(read()) lnk[i][++lnk[i][0]]=j;
            }
            flg=1;
            for(int i=1;i<=n;i++){
                memset(vis,0,sizeof vis);
                if(!DFS(i)){puts("No"),flg=0;break;}
            }
            if(flg) puts("Yes");
        }
        return 0;
}
```

---

## 作者：大头冲锋车丶 (赞：6)

为什么题解都这么复杂的感觉。。。

直接这么想：对于一个存在于 $(i,j)$ 的 $1$ ，无论怎样交换这个 $1$ 的行，或者交换列，最后的结果一定是，原本存在于该行的元素一定还在该行（只是顺序不同），原本存在于该列上的元素一定还在该列（只是顺序不同）。

回到题目，要求主对角线上都是 $1$，那么比如已经在 $(1,1)$ 放上一个 $1$了，那么第一行与第一列上的 $1$ 就不可能再通过任何行列变换到其它对角线上。总而言之，对于一个 $1$ ，如果它放在一个对角线上做贡献，那么它所在行与所在列上的 $1$ 都不可能再做贡献。

进而本题就很容易的转化成，求该图上所有的 $1$，行不同且列不同的最多能有多少个，能达到 $n$ 个即可 $Yes$ 。  

二分图最大匹配即可。

```cpp
#include<set>
#include<map>
#include<queue>
#include<stack>
#include<cmath>
#include<vector>
#include<string>
#include<cstring>
#include<iostream>
#include<algorithm>
#define pb push_back
#define first fi
#define second se
#define IO std::ios::sync_with_stdio(false)
typedef long long ll;
const int maxn = 100008;
const ll mod = 1e9+7;
const int inf = 0x3f3f3f3f;
const ll INF = 1e18 + 10;
const double eps = 1e-6;
using namespace std;
int T,n;
int cnt,head[maxn],cx[maxn];
bool vis[maxn];
struct Edge{
	int to;
	int next;
}edge[maxn<<2];
inline void add(int u,int v){
	edge[++cnt].to=v;
	edge[cnt].next=head[u];
	head[u]=cnt;
	return;
}
int dfs(int u){
	for(int i=head[u];i;i=edge[i].next){
		int v=edge[i].to;
		if(!vis[v]){
			vis[v]=true;
			if(cx[v]==0||dfs(cx[v])){
				cx[v]=u;
				return 1;
			}
		}
	}
	return 0;
}
int main()
{
	scanf("%d",&T);
	while(T--){
		scanf("%d",&n);
		cnt=0;
		memset(head,0,sizeof(head));
		memset(cx,0,sizeof(cx));
		int x;
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				scanf("%d",&x);
				if(x) add(i,j);
			}
		}
		int ans=0;
		for(int i=1;i<=n;i++){
			memset(vis,0,sizeof(vis));
			ans+=dfs(i);
		}
		if(ans>=n) printf("Yes\n");
		else printf("No\n");
	}
}
```


---

## 作者：蒟蒻pks (赞：3)

明显的二分图 然而我喜欢用dinic网络流写（看着爽）


```cpp
var a:array[0..401,0..401] of longint;
    boo:array[0..401] of boolean;
    booo:array[0..401] of boolean;
    dinic:array[0..401] of longint;
    b,c,i,d,e,f,n,g,h,j,oo,ans:longint;
function min(a1,a2:longint):longint;
begin
  if a1<a2 then exit(a1);
  exit(a2);
end;
procedure dfs(i:longint);
var j,k,l:longint;
begin
  for j:=1 to n+n+1 do
  if not (boo[j]) and (a[i,j]>0) then
  begin
    dinic[j]:=dinic[i]+1;
    boo[j]:=true;
    dfs(j);
  end;
end;
function bfs(i,o:longint):longint;
var j,k,l:longint;
begin
  k:=0;
  if i=(n+n+1) then exit(o);
  for j:=1 to n+n+1 do
  if (a[i,j]>0) and (not booo[j]) and  (dinic[i]=(dinic[j]-1)) then
  begin
    booo[j]:=true;
    l:=bfs(j,min(o,a[i,j]));
    a[i,j]:=a[i,j]-l;
    a[j,i]:=a[j,i]+l;
    o:=o-l;
    k:=k+l;
    booo[j]:=false;
  end;
  exit(k);
end;
begin
  oo:=10000000;
  readln(b);
  for b:=1 to b do
  begin
    ans:=0;
    readln(n);
    for i:=1 to n do
      for j:=1 to n do
      begin
        read(g);
        if g=1 then
          inc(a[i,j+n]);
      end;
    for i:=1 to n do
      inc(a[0,i]);
    for i:=1 to n do
      inc(a[i+n,n+n+1]);
    for i:=1 to n+n+1 do
      dinic[i]:=oo;
    dfs(0);
    while dinic[i]<>oo do
    begin
      ans:=ans+bfs(0,oo);
      for i:=1 to n+n+1 do
        dinic[i]:=oo;
      fillchar(boo,sizeof(boo),false);
      dfs(0);
    end;
      fillchar(boo,sizeof(boo),false);
    if ans=n then
      writeln('Yes') else writeln('No');
    for i:=0 to n+n+1 do
      for j:=0 to n+1+n do
      a[i,j]:=0;
  end;
end.
```

---

## 作者：zheng_liwen (赞：3)




    
```cpp
//首先我们开一个map[i][j] 
//当map[i][j]为1，那么i与j相同 
//用匈牙利算法(这也是一种玄学算法qaq)求最大（可以自行百度） 
//当最大匹配数等于对角线上的点数就成立则否则不行 
//P.S.:做了一些玄学修改，如果复制你会死的很惨 ！ 
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
inline int read()
{
    char a=getchar();
    int w=0;
    while(a>='0'&&a<='9')
        w=(a-48)+(w<<1)+(w<<3),a=getchar();
    //cin.ignore();
    return w;
```
}//快不了多少的优化
```cpp
int n;
int cr[201];
bool cb[201];
int map[201][201];
bool dfs(int a)
{
    for(int i=1;i<=n;i++)
        if(map[a][i]==1&&!cb[i])
        {
            cb[i]=true;
            if(cr[i]==0||dfs(cr[i]))
            {
                cr[i]=a;
                return true;
            }
        }
    return false;
}
int main()
{
    int T;
    cin>>T;
    while(T--){
        cin>>n;
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                cin>>map[i][j];
        memset(cr,0,sizeof(cr));
        int ans=0;
        for(int i=1;i<=n;i++)
        {
            memset(cb,false,sizeof(cb));
            if(dfs(i))ans++;
        }
        if(ans==n)cout<<"yes"<<endl;
            else cout<<"no"<<endl;
    }
}

```

---

## 作者：xixiup (赞：1)

这道题需要让我们求解将原图的行或列进行交换，使得第（1，1），第（2，2）......第（n，n）都为黑格子

让我们设想对于原图的第j列，如果它的第i行为一个黑格子的话，那么将它转换到第j行，那么第（i，i）个格子就为黑色，反之如果第j行为白格子的话，那么将它转换到第j行，那么第（i，i）个格子就为白色，不符合题目要求

那么对于每一列，可以将它转换到哪一行呢？如果它的第i行为黑，就可以转换到第i列，反之就不行。

于是我们就可以建出一个二分图，左右点集各有n个点，左点集表示原图的每一列，右点集表示更换顺序后的每一列，对于格子（i，j），如果它是黑的，就往左点集的i到右点集的j连一条边，就表示原图的第i列可以更换到第j列去。

对其进行二分图匹配，如果刚好等与n，就找到了可以满足条件的解

我们来看下面这个4行4列的图

![](https://cdn.luogu.com.cn/upload/image_hosting/p6by4cnh.png)

那么我们就可以建出一个二分图：

![](https://cdn.luogu.com.cn/upload/image_hosting/cbfncpx8.png)

我们对其进行二分图匹配，就会发现，这个图的匹配为3，不满足要求。

那么有人就要问了，不是还可以交换行吗？

假设在刚刚那个图中，交换第2，3行，再按之前的方法进行建图，就能建出这样一个图：

![](https://cdn.luogu.com.cn/upload/image_hosting/m3ovdqrk.png)

但如果我们将右点集的第2，3行交换，就变成了这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/cdg5fxgz.png)

其实跟我们第一次建出来的图相比，只有2，3号点在编号上发生了互换，图的~~形态结构，生理功能~~都没有改变，对这个新的图进行匹配，仍然无法改变结果。

AC代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,lj[1010][1010],p[1010],t[1010];
int add(int x){
	for(int y=1;y<=n;y++){
		if(p[y]==0&&lj[x][y]==1){
			p[y]=1;
			if(t[y]==0||add(t[y])==1){
				t[y]=x;
				return 1;
			}
		}
	}
	return 0;
}
int main(){
	int T;
	cin>>T;
	for(int q=1;q<=T;q++){
		cin>>n;
		memset(lj,0,sizeof(lj));
		memset(t,0,sizeof(t));
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				int x;
				scanf("%d",&x);
				lj[i][j]=x;
			}
		}
		int ans=0;
		for(int i=1;i<=n;i++){
			memset(p,0,sizeof(p));
			if(add(i)){
				ans++;
			}
		}
		puts(ans==n?"Yes":"No");
	}
	return 0;
}
```


---

## 作者：GoPoux4 (赞：1)

这道题初看好像没有办法解，因为每一次操作都要带动很多关键的要素（黑方块）运动 ~~要素过多~~。

但是多分析几组样例就会发现：如果要填充对角线上的一个黑方块，那么**矩阵中必然存在一个黑方块当且仅当能通过移动其所在行或所在列使该点到达对角线上待填充的目标点**。当所有目标点能被同时填充时，此矩阵有解。

由于每个关键点（目标点和初始图上的黑点）的行和列都需被考虑，可以将每个关键点拆出两个元素：行和列。由于建立了初始状态和目标状态，可以用二分图匹配求解。

于是可以把行用$1-n$表示，把列用$n+1 - n+n$表示，建图。

代码：

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#define maxn 205
using namespace std;

inline int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') {x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return x*f;
}

struct edge{
	int v,next;
}e[maxn*maxn<<1];

int head[maxn<<1],k;

inline void add(int u,int v)
{
	e[k]=(edge){v,head[u]};
	head[u]=k++;
}

int n;
bool vis[maxn<<1];
int cyx[maxn<<1];

inline bool findpath(int x)
{
	for(int i=head[x];~i;i=e[i].next)
		if(!vis[e[i].v])
		{
			vis[e[i].v]=true;
			if(!cyx[e[i].v]||findpath(cyx[e[i].v]))
			{
				cyx[e[i].v]=x;
				return true;
			}
		}
	return false;
}

inline bool match()
{
	memset(cyx,0,sizeof(cyx));
	for(int i=1;i<=2*n;i++)
	{
		memset(vis,0,sizeof(vis));
		if(!findpath(i)) return false;
	}
	return true;
}

int main()
{
//	freopen("P1129.in","r",stdin);
	int t=read();
	while(t--)
	{
		n=read();
		memset(head,-1,sizeof(head));k=0;
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				if(read()==1)
				{
					add(i,j);
					add(n+j,n+i);
				}
		if(match()) printf("Yes\n");
		else printf("No\n");
	}
	return 0;
}
```


---

## 作者：Plus_Ultra (赞：1)

### 题解：

说句闲话：由于一些 ** 错误，我调了40多分钟。。。

一. 很容易看出这是一个二分图最大匹配问题.

[不懂二分图匹配的童鞋看这里](https://www.luogu.org/blogAdmin/article/edit/163455)

二. 匈牙利算法

  1. 一开始，F 为空。

  2. 枚举 V1 中的点 x，找以 x 为起点的增广路，找到了就增广。

  3. V1 中的点都尝试增广一次后，算法结束。

定理：如果在某一时刻，找不到以 x 为起点的增广路，则增广几轮之后仍不会找到。

时间复杂度：O(nm)

下面分析一下板子：


```
#include<iostream>

using namespace std;

const int V=1000010;
int N,M,E,ans;
int edge[V],head[1010],nxt[V],tot;
int dfn[2020],match[1010],x,y,ti;

void add(int x,int y)//加边
{
	edge[++tot]=y;
	nxt[tot]=head[x];
	head[x]=tot;
}

int dfs(int x,int ti)//ti是时间戳
{
	for(int i=head[x];i;i=nxt[i])
	{
		int j=edge[i];
		if(dfn[j]!=ti)//这一轮还没有遍历到
		{
			dfn[j]=ti;
			if(!match[j]||dfs(match[j],ti))//没有和j点匹配的点或者是找到了一条可增广的路径
			{
				match[j]=i;//i,j匹配
				return 1;
			}
		}
			  
	}
	return 0;
}

int main()
{
	cin>>N>>M>>E;
	for(int i=1;i<=E;i++)
	{
		cin>>x>>y;
		if(x>N||y>M)  continue;
		add(x,y);
	}
	
	for(int i=1;i<=N;i++)
		if(dfs(i,++ti))  ans++;//找到了一条增广路
		
	cout<<ans<<endl;
	
	return 0;
}
```

有了板子之后就很好做了，我们把 行 看作左边点集， 列 看作右边点集，读入时如果该格子是黑色格子，那么就从i向j连一条边，跑二分图最大匹配即可.

正确性：任意2个黑色方块，如果一开始不在同一行或同一列，无论进行什么操作，它们始终都不会在同一行（同一列）.

下面上代码（我知道各位大佬也不需要代码）：

```
#include<iostream>
#include<cstring>

#define N 210

using namespace std;

int T,ma[N][N],vis[N],mat[N],ans,n;

int match(int x)//找增广路 
{
	for(int i=1;i<=n;i++)
		if(ma[x][i]&&!vis[i])//没有被x点遍历过并且有边相连 
		{
			vis[i]=1;//标记 
			if(!mat[i]||match(mat[i]))//这个点还没有被匹配或者能从其匹配点找到替换路 
			{
				mat[i]=x;//匹配 
				return 1;//找到增广路 
			}
		}
	return 0;//没有找到增广路 
}

int main()
{
	cin>>T;
	
	while(T--)
	{
		memset(mat,0,sizeof(mat));
		cin>>n; ans=0;
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)  cin>>ma[i][j];//读入（相当于连边） 
		for(int i=1;i<=n;i++)
			memset(vis,0,sizeof(vis)),ans+=match(i);//记得要初始化哦 
		if(ans==n)  cout<<"Yes"<<endl;//能找到一组解 
		else  cout<<"No"<<endl;
	}
	 
	return 0;
} 
```

### [Plus Ultra!!!](https://www.luogu.org/blog/OnePunchManGO/)

---

## 作者：ShineEternal (赞：1)

# 写在前面：
如想获取更佳阅读效果，请点击[这里](https://blog.csdn.net/kkkksc03/article/details/88854774)，任何疑问欢迎私信作者！

# 题目链接：https://www.luogu.org/problemnew/show/P1129
# 分析：
这道题不是很好想，但只要想的出来，代码不成问题。

### 思路1

举几个例子，我们发现，

对于任何数来说，同一行的永远在同一行，同一列的永远在同一列

进一步研究，发现所有行所有列要有1，且至少要有n个1两两不同行不同列

对于每个$1$，设坐标为$(x,y)$，那么$x$行向$y$列连边

判断是否有完全匹配（都能匹配上），能匹配上就可以

### 思路2

这个就是比较拓展的思路了，如果你学了高等数学的话，应该知道有个叫行列式的东西（百度一下？），我们只需判断行列式是否等于0（每一个矩阵中的数字都乘上除去这一行这一列的其他所有数），即可求得答案。

#### PS：由于作者对此了解有限，讲述不对之处欢迎~~踢~~提出！

# 代码：

```cpp
#include<cstdio>
#include<vector>
#include<cstring> 
using namespace std;
vector<int>e[205];
int link[205];
int vis[205];
int t;
int find(int x)
{
	for(int i=0;i<e[x].size();i++)
	{
		int p=e[x][i];
		if(vis[p]!=t)
		{
			vis[p]=t;
			if(!link[p]||find(link[p]))
			{
				link[p]=x;
				return 1;
			}
		}
	} 
	return 0;
}
int main()
{
	int T,n,tmp,cnt;
	scanf("%d",&T);
	while(T--)
	{
		cnt=0;
		t=0;
		
		memset(vis,0,sizeof(vis));
		memset(link,0,sizeof(link));
		scanf("%d",&n);
		for(int i=1;i<=n;i++)
		e[i].clear();
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=n;j++)
			{
				scanf("%d",&tmp);
				if(tmp==1)
				{
					e[i].push_back(j);
				}
			} 
		} 
		for(int i=1;i<=n;i++)
		{
			t++;
			if(find(i))
			{
				cnt++;
			}
			else
			break;
		}
		if(cnt==n)
		{
			printf("Yes\n");
		} 
		else
		printf("No\n");
	} 
	return 0;
} 
```



---

## 作者：Ajsoabk (赞：1)

# [P1129 [ZJOI2007]矩阵游戏](https://www.luogu.org/problemnew/show/P1129)


行列视为二分图左右部集，值为1的点所在行列连边

发现交换行列就是交换节点编号

且对角线上有编号表现为二分图完全匹配且左节点只与相应的右节点匹配（即i与i+n)

但就算不满足i与i+n匹配而满足完全匹配我也可以通过某些交换节点编号的操作将其转换成i与i+n匹配

而答案又只要求是否存在，不管方案

故求该网络 的最大流，看是否等于n即可


## 建边

s与1~n连容量为1的边，n+1~n+n与t连容量为1的边

值为1的点将其行（i）列（j+n）连容量为1的边

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<queue>
using namespace std;
const int N=200+5,M=82000;
const int inf=0x7fffffff;
template<class T>inline void read(T &num){
    char ch;
    while(!isdigit(ch=getchar()));
    num=ch-'0';
    while(isdigit(ch=getchar()))num=num*10+ch-'0';
}

int hea[N<<1],to[M],nex[M],val[M],tot=1,n,s,t,dep[N<<1];

inline void add_edge(const int x,const int y,const int w){
//printf("%d --> %d(%d)\n",x,y,w);
    to[++tot]=y,nex[tot]=hea[x],hea[x]=tot,val[tot]=w;
}

queue<int> que;
bool bfs(){
//printf("\nbfs()\n"); 
    memset(dep,0,sizeof(dep));
    dep[s]=1;
    while(que.size())que.pop();
    que.push(s);
    int x;
    while(que.size()){
     	x=que.front();que.pop();
//printf("hea[%d]=%d\n",x,hea[x]);
        for(int i=hea[x];i;i=nex[i]){
            int y=to[i];
            if(val[i]&&!dep[y]){
//printf("%d -> %d,t=%d\n",x,y,t); 
             	dep[y]=dep[x]+1;
                if(y==t)return true;
                que.push(y);
            }
        }
    }
//printf("return 0\n");
    return false;
}

int dfs(int x,int flow){
//printf("dfs(%d,%d)\n",x,flow);
    if(x==t)return flow;
//printf("dfs(%d,%d)\n",x,flow);
    int rest=flow,k;
//printf("hea[%d]=%d\n",x,hea[x]);
    for(int i=hea[x];i&&rest;i=nex[i]){
        int y=to[i];
        if(val[i]&&dep[y]==dep[x]+1){
//printf("%d->%d,dep[%d]=%d,dep[%d]=%d\n",x,y,x,dep[x],y,dep[y]); 
            k=dfs(y,min(rest,val[i]));
//printf("k=%d,min(%d,%d)=%d\n",k,rest,val[i],min(rest,val[i])); 
            if(k==0)dep[y]=0;
            val[i]-=k;
            val[i^1]+=k;
            rest-=k;
        }
    }
//printf("   rest=%d,return=%d\n",rest,flow-rest);
    return flow-rest;
}

int dinic(){
    int maxflow=0,flow;
    while(bfs())while(flow=dfs(s,inf))maxflow+=flow;
//printf("%d\n",maxflow); 
    return maxflow;
}

int T;
int main(){
//	freopen("squ.out","w",stdout);
	read(T);
	for(int tt=1;tt<=T;++tt){
		memset(hea,0,sizeof(hea));
		memset(to,0,sizeof(to));
		memset(nex,0,sizeof(nex));
		memset(val,0,sizeof(val));
		tot=1;
		read(n);
		s=n*2+1,t=s+1;
		for(int i=1;i<=n;++i){
			for(int j=1,k;j<=n;++j){
				read(k);
				if(k){
					add_edge(i,j+n,1);
					add_edge(j+n,i,0);
				}
			}
			add_edge(s,i,1);
			add_edge(i,s,0);
			add_edge(i+n,t,1);
			add_edge(t,i+n,0);
		}
		printf("%s\n",dinic()==n?"Yes":"No");
	}
    return 0;
}

```


---

## 作者：Zzh20011004 (赞：1)

看到这题，第一反应搜索。

很明显又难写又没有多少分。

关于这种关于坐标的题就想到网络流，毕竟n=200

好了，画画图猜想下

好似正常坐标连图跑二分图最大匹配只要等于n即可

确实如此

why?
好似其他题解都没说

因为连图时比两列交换就相当于把这两个点的编号(网络流建图中)交换，所连的边不变

很明显因此横纵两列交换，最大流是不会变的

看下最后要求是要n条匹配

因此如果现在的图满足n条匹配

把横纵两列交换，就是把编号改下

一定能满足

因为多组数据记得重置head以及cnt


附上代码

```cpp
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
struct node
{
    int to,next,f;
}    e[400005];
int cnt=1,head[40055],s,t,dep[40055];
using namespace std;
inline void insert(int u,int v,int f)
{
    e[++cnt].to=v;
    e[cnt].next=head[u];
    head[u]=cnt;
    e[cnt].f=f;
}
inline int dfs(int now,int f)
{
    int ret=0;
    if(now==t)    return f;
    for(int i=head[now];i && f;i=e[i].next)
    {
        if(dep[e[i].to]==dep[now]+1 && e[i].f)
        {
            int d=dfs(e[i].to,min(f,e[i].f));
            f-=d;e[i].f-=d;ret+=d;e[i^1].f+=d;
        }
    }
    if(!ret)    dep[now]=-1;
    return ret;
}
inline bool bfs()
{
    memset(dep,0,sizeof(dep));
    queue<int>    q;
    q.push(s);
    dep[s]=1;
    while(!q.empty())
    {
        int now=q.front();q.pop();
        for(int i=head[now];i;i=e[i].next)
        {
            if(!dep[e[i].to] && e[i].f)
            {
                dep[e[i].to]=dep[now]+1;
                q.push(e[i].to);
            }
        }
    }
    return dep[t];
}
inline int dinic()
{
    int ret=0;
    while(bfs())    ret+=dfs(s,1e9+7);
    return ret;
}
int main()
{
    int T,n,op;
    scanf("%d",&T);
    while(T--)
    {
        memset(head,0,sizeof(head));
        cnt=1;
        scanf("%d",&n);
        s=0;t=2*n+1;
        for(int i=1;i<=n;i++)
        {
            insert(s,i,1);
            insert(i,s,0);
            insert(i+n,t,1);
            insert(t,i+n,0);
        }
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
            {
                scanf("%d",&op);
                if(op==1)
                {
                    insert(i,j+n,1);
                    insert(j+n,i,0);
                }
            }
        int mxl=dinic();
        if(mxl==n)    printf("Yes\n");
        else    printf("No\n");
    }
    return 0;
}
```

---

## 作者：牛蛙丶丶 (赞：1)

交换任意两行或是两列，然后我们最终的目标是要达到该方阵的主对角线上的格子均为黑色(即左上角至右下角)的格子均为黑色。

那么我们每次的操作肯定是将每一行某一个位置上的 1 移到上述的这条对角线，最后判断能否成立，在这样的思路的引导下，我们很容易想到二分图匹配，也就是若 $a(i)(j)=1$ ，那么我们就要将 $j$ 与 $i$ 相连，相当于一个匹配。

判断每一行能否合法匹配即可。

#### 代码
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#define F1(i,l,r) for(int i=l;i<=r;++i)
#define F2(i,r,l) for(int i=r;i>=l;--i)
#define sf(i) scanf("%d",&i)
#define pf(i) printf("%d\n",i)
#define N 207
using namespace std;

int n;
int e[2*N][N],d[N];
bool vis[N];

bool find(int u){
	if(vis[u]) return 0;
	vis[u]=1;
	F1(v,1,n)
		if(e[u][v])
			if(!d[v]||find(d[v])){
				d[v]=u;
				return 1;
			}
	return 0;
}

bool work(){
	F1(i,1,n){
		memset(vis,0,sizeof(vis));
		if(find(i)) continue;
		return 0;
	}
	return 1;
}

int main(){
	int T;
	cin>>T;
	while(T--){
		memset(e,0,sizeof(e));
		memset(d,0,sizeof(d));
		sf(n); 
		F1(i,1,n)
			F1(j,1,n){
				int a;sf(a);
				if(a) e[j][i]=1;
			}
		if(work()) printf("Yes\n");
		else printf("No\n");
	}
}
```

多组数据记得清零，我第一次交就因为d数组没有清零爆零了


---

## 作者：IceZero (赞：1)

二分图最大匹配

当map[i][j]为1，即可视为i->j可连成一条边

用匈牙利算法求最大匹配

当最大匹配数等于对角线上的点数（即n）则输出Yes，否则输出No


---

## 作者：⚡114514_zzm⚡ (赞：0)

**思路：**  

将黑色格子所在的行和列连边, 跑一边最大匹配, 如果是完美匹配即可(所有点都是匹配点)                 

在完美匹配的情况下

假如 列1 -> 行5 , 列4 -> 行1 (->表示匹配)

我们则可以将行5和行1换一下位置, 这样交换 列不会受到影响, 匹配变为列1 -> 行1, 列4 -> 行5

```
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int N = 40005;
int h[N], ne[N * 2], to[N * 2];
int tot, T, n;

void add(int x,int y) {
	ne[++tot] = h[x];
	h[x] = tot, to[tot] = y;
}

int read(void) {
	int x = 0;
	char c = getchar();
	while (!isdigit(c)) c = getchar();
	while (isdigit(c)) {
		x = (x << 3) + (x << 1) + c - '0';
		c = getchar();
	}
	return x;
}

int tim, vis[N], match[N];

int dfs(int x) {
	for (int i = h[x]; i; i = ne[i]) {
		int y = to[i];
		if (vis[y] == tim) continue;
		vis[y] = tim;
		if (!match[y] || dfs(match[y])) {
			match[y] = x; return 1;
		}
	}
	return 0;
}

void pre(void) {
	memset(h, 0, sizeof(h));
	memset(ne, 0, sizeof(ne));
	memset(to, 0, sizeof(to));
	memset(match, 0, sizeof(match));
	tot = 0;
}

int main() {
	T = read();
	while (T--) {
		pre();
		n = read();
		for (int i = 1;i <= n; i++) 
		for (int j = 1;j <= n; j++) {
			int x = read();
			if (x) {
				add(i, j + n); add(j + n, i);
			}
		}
		int ans = 0;
		for (int i = 1;i <= n; i++) 
		tim++, ans += dfs(i);
		if (ans == n) printf("Yes\n");
		else printf("No\n");
	}
	return 0;
}

```


---

## 作者：Time_grow (赞：0)

清北学堂青岛DP图论笔记 DAY6  
乍看题意根本没什么思路，后来仔细一想。。。嗯？？行列交换？？对角线要全是黑格子？？想了一会。。。这题不匈牙利二分图匹配么。。。   
把黑格子看成是点，竖着是1~n，横着是1~n，如果某列的某一行的点是黑的，就与这行连一条线，而且不管怎么交换都不会改变颜色状况。   
那这不就成了匈牙利的裸题了吗？   
  话不多说，上代码
  ```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<vector>
#include<cstring> 
using namespace std;
int A[200010] , n , m , T , vis[200010] , ans , x; 
vector<int> vec[200010] ;
bool find(int x){
	for(int i = 0 ; i < vec[x].size() ; i++){
		if(!vis[vec[x][i]]){
			vis[vec[x][i]] = 1;
			if(!A[vec[x][i]] || find(A[vec[x][i]])){
				A[vec[x][i]] = x;//A表示在另一侧的匹配点
				return 1;//匹配到了就返回true
			}
		}
	}
	return 0;//不行就算了
}
int main ( )  {
	scanf("%d",&T);
	while(T--){
		scanf("%d", &n);
		ans = 0;
		for(int i = 1 ; i <= n ; i++){
			vec[i].clear() , A[i] = 0;
		}
		for(int i = 1 ; i <=n ; i++){
			for(int j = 1 ; j <= n ;j++){
				scanf("%d" , &x);
				if(x){
					vec[i].push_back(j);
				}
			}
		}
		for(int i = 1 ; i <= n ;i++){
			memset(vis , 0 ,sizeof(vis));
			ans += find(i);
		}
		puts(ans == n ? "Yes" : "No");
	}
}
```

---

## 作者：muller (赞：0)

补一发题解吧，这题不是裸的二分图匹配吗？

楼上的神仙说的好，就像我们玩魔方一样，我们行列一定可以通过一定的转换达成目标！所以呢，无脑加边即可！

对于二分图匹配问题，可以用匈牙利算法求解，然而笔者用的是最大流dinic算法！

首先，我们考虑如何把此问题转换为最大流。我们要学会拆点！

顾名思义，就是把一个点拆成两个点（以限制每个点（物品）用一次）

记录i拆为i,i+n

我们要单独建一个源点和汇点，然后源点S向i连边，i+n向T连边即可！

memset(...sizeof(fir))居然打成了memset(...sizeof(ecnt))
T了好多发qwq

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1005, M = 100005, INF = 1e9;
int n, ss, tt, l, r, ans, ecnt, depth[N], q[N], fir[N], cur[N], to[M], nxt[M], len[M], inv[M];
bool vis[N];
template <class T> void rd(T &x) {
	char c = getchar(); int f = 1; x = 0;
	for (; !isdigit(c); c = getchar()) if (c == '-') f = -1;
	for (; isdigit(c); c = getchar()) x = x * 10 + c - '0';
	x *= f;
}
void ae(int u, int v, int w) {
	to[++ecnt] = v; nxt[ecnt] = fir[u]; len[ecnt] = w; inv[ecnt] = ecnt + 1; fir[u] = ecnt;
	to[++ecnt] = u; nxt[ecnt] = fir[v]; len[ecnt] = 0; inv[ecnt] = ecnt - 1; fir[v] = ecnt; 
}
bool make_level() {
	int i; memset(vis, false, sizeof(vis));
	for (i = ss; i <= tt; ++i) cur[i] = fir[i];
	vis[q[l = r = 1] = ss] = true; depth[ss] = 1;
	while (l <= r) {
		int u = q[l++];
		for (i = fir[u]; i; i = nxt[i]) {
			int v = to[i], w = len[i];
			if (!vis[v] && w) vis[q[++r] = v] = true, depth[v] = depth[u] + 1;
		}
	} 
	return vis[tt];
}
int dinic(int u, int lim) {
	if (u == tt) return lim;
	int i, ret = 0;
	for (i = cur[u]; i; i = nxt[i]) {
		int v = to[i], w = len[i];
		if (depth[v] == depth[u] + 1 && w) {
			int tmp = dinic(v, min(w, lim));
			len[i] -= tmp; len[inv[i]] += tmp;
			lim -= tmp; ret += tmp;
			if (!lim) {cur[u] = i; return ret;}
		}
	}
	cur[u] = 0; return ret;
}
void solve() {
	int i, j; memset(fir, ecnt = 0, sizeof(fir));
	rd(n); ss = 0; tt = n << 1 | 1; ans = 0;
	for (i = 1; i <= n; ++i)
		for (j = 1; j <= n; ++j) {
			int x; rd(x);
			if (!x) continue;
			ae(i, j + n, 1);
		}
	for (i = 1; i <= n; ++i) ae(ss, i, 1), ae(i + n, tt, 1);
	while (make_level()) ans += dinic(ss, INF);
	if (ans == n) puts("Yes"); else puts("No");
}
int main() {
	int T; rd(T);
	while (T--) solve(); 
	return 0;
}

```

---

## 作者：Lance1ot (赞：0)

~~不知道怎么开头~~

二分图匹配问题。

~~可能是算法级别拉高了难度~~

仔细观察，会发现一条性质。

>同一列的黑块换不出这一列。行也一样    
 根据题目要求，可以得出:一行（或一列）中，只有一个黑块参与了匹配。
 
$So$,剩下的事便是做二分图匹配了。

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<iostream>
#include<queue>
using std::queue;
using std::min;
const int N=310;
const int inf=0x7fffffff;
struct node
{
    int p;
    int f;
    int nxt;
};
node line[N*N*2];
int head[N<<1],tail=-1;
int cur[N<<1];
int dis[N<<1];
void add(int a,int b,int c)
{
    line[++tail].p=b;
    line[tail].f=c;
    line[tail].nxt=head[a];
    head[a]=tail;
    return ;
}
void init()
{
    memset(head,-1,sizeof(head));
    tail=-1;
}
bool bfs(int s,int t)
{
    queue<int>q;
    memset(dis,0,sizeof(dis));
    dis[s]=1;
    q.push(s);
    while(!q.empty())
    {
        int pas=q.front();q.pop();
        for(int i=head[pas];i!=-1;i=line[i].nxt)
            if(!dis[line[i].p]&&line[i].f)
            {
                q.push(line[i].p);
                dis[line[i].p]=dis[pas]+1;
            }
    }
    for(int i=0;i<=t;i++)   cur[i]=head[i];
    return dis[t];
}
int dfs(int now,int aim,int flow)
{
    if(now==aim||!flow) return flow;
    int f,res=0;
    for(int &i=cur[now];i!=-1;i=line[i].nxt)
        if(dis[now]+1==dis[line[i].p]&&(f=dfs(line[i].p,aim,min(line[i].f,flow))))
        {
            res+=f;
            line[i].f-=f;
            line[i^1].f+=f;
            flow-=f;
            if(!flow)   return res;
        }
    return res;
}
int dinic(int s,int t)
{
    int res=0;
    while(bfs(s,t))
        res+=dfs(s,t,inf);
    return res;
}
int main()
{
	/*
    * 0为源点，2*n+1为汇点
    * 1~n为行，n+1~2*n为列
    */
    int t;
    scanf("%d",&t);
    while(t--)
    {
        init();
        int n;
        scanf("%d",&n);
        int a,b;
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
            {
                scanf("%d",&a);
                if(!a)  continue;
                add(i,n+j,1);
                add(n+j,i,0);
            }
        for(int i=1;i<=n;i++)
        {
            add(0,i,1);
            add(i,0,0);
            add(i+n,n*2+1,1);
            add(n*2+1,i+n,0);
        }
        //若匹配数等于n，则可以完成游戏
        if(dinic(0,2*n+1)==n)
            printf("Yes\n");
        else
            printf("No\n");

    }
}

```

---

## 作者：东寺丶闲人 (赞：0)

###题解


看到的第一眼以为是dfs，这个数据显然会T，然后想到这道题让向右下的对角线都为黑色，及对于每一个相等的行数和列数都需要使他们的交点是黑色，才想出来这道题可以搞一搞二分图，具体方案是把行与边进行匹配，因为每一行和每一列需要一一对应，所以显然是二分图匹配，当匹配数与n相等时存在方案，否则无解。


既然是二分图，数据不是很小，于是就用网络流水。~~(网络流大法好)~~


建图：S连每一个横行，每个纵行连T，输入时要是黑棋子则把横行和纵行连上。每条边边权为1。


###代码

```cpp
#include<bits/stdc++.h>
#define maxn 200005
#define inf 214748347
using namespace std;
int n,S,T,m,num_e=1,ans,TT;
int head[maxn],dis[maxn];
int a[205][205];
struct edge{
    int to,nex,rest;
}e[maxn];
void add(int x,int y,int z){
    e[++num_e].to=y;e[num_e].nex=head[x];head[x]=num_e;e[num_e].rest=z;
    e[++num_e].to=x;e[num_e].nex=head[y];head[y]=num_e;e[num_e].rest=0;
}
bool bfs(){
    memset(dis,0,sizeof(dis));
    queue<int> q;
    q.push(S);
    dis[S]=1;
    while(!q.empty()){
        int x=q.front();q.pop();
        for(int i=head[x];i;i=e[i].nex){
            if(!dis[e[i].to]&&e[i].rest){
                q.push(e[i].to);
                dis[e[i].to]=dis[x]+1;
            }
        }
    }
    if(dis[T]) return true;
    return false;
}
int dfs(int x,int minn){
    if(x==T) return minn;
    int sum=0,qaq=0;
    for(int i=head[x];i;i=e[i].nex){
        if(dis[e[i].to]==dis[x]+1&&e[i].rest){
            qaq=dfs(e[i].to,min(minn-sum,e[i].rest));
            sum+=qaq;
            e[i].rest-=qaq;
            e[i^1].rest+=qaq;
            if(sum==minn) return sum;
        }
    }
    if(!sum) dis[x]=0;
    return sum;
}
int dinic(){
    int anss=0;
    while(bfs()) anss+=dfs(S,inf);
    return anss;
}

int main(){
    scanf("%d",&TT);
    while(TT--){
        memset(head,0,sizeof(head));
        scanf("%d",&n);
        num_e=1,S=0,T=n*2+1;
        for(int i=1;i<=n;i++) add(S,i,1),add(i+n,T,1);
        for(int i=1;i<=n;i++){
            for(int j=1;j<=n;j++){
                scanf("%d",&a[i][j]);
                if(a[i][j]) add(i,j+n,1);
            }
        }
        if(dinic()==n) printf("Yes\n");
        else printf("No\n");
    }

    return 0;
}
```

---

## 作者：707001933K (赞：0)

WA了7次，才A，要发个题解反省一下。

这道题折磨了我三个小时，QAQ

我本人不喜欢匈牙利算法，所以打了个dinic网络流建图，顺便熟悉一下dinic，谁知，我曾经的dinic模板中有一个绝世bug，一个小小的数据就能弄成死循环，可是我也不知道那个模板怎么曾在落谷P3386上过了

洛谷有毒，也不发数据，我硬是自己慢慢试QAQ

这里就直接上代码，中间有个地方有句注释，那个bug，那个bug，那个bug真是有毒。

```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cstring>
using namespace std;
const int N=401;
const int INF=0x3f3f3f3f;
struct Edge{
    int to,next,cap;
}e[10*N*N];
int level[10*N*N],a[10*N*N];
int n,T,EdgeCnt=0;
queue<int> Q;
void addedge(int u,int v,int w){
    int p=EdgeCnt;
    e[p].to=v;e[p].next=a[u];e[p].cap=w;
    a[u]=p;EdgeCnt++;
}
bool bfs(int S){
    memset(level,0xff,sizeof(level));
    Q.push(S);
    level[S]=0;
    while (!Q.empty()){
        int u=Q.front();Q.pop();
        int p=a[u];
        while (p!=-1){
            int v=e[p].to;
            if (e[p].cap>0 && level[v]==-1){
                level[v]=level[u]+1;
                Q.push(v);
            }
            p=e[p].next;
        }
    }
    return level[T]>-1;
}
int dfs(int u,int f){
    if (u==T)return f;
    int used=0;
    int p=a[u];
    while (p!=-1){
        int v=e[p].to;
        if (e[p].cap>0 && level[v]==level[u]+1){
            int w=f-used;
            w=dfs(v,min(w,e[p].cap));
            e[p].cap-=w;
            e[p^1].cap+=w;
            used+=w;
            if (used==f)return f;
        }
        p=e[p].next;
    }
    //if (used==0)level[T]=-1;有毒
    return used;
}
int main(){
    int TT;
    scanf("%d",&TT);
    while (TT--){
        scanf("%d",&n);
        memset(a,0xff,sizeof(a));EdgeCnt=0;
        for (int i=2;i<=n+1;i++)
            for (int j=2;j<=n+1;j++){
                int x;
                scanf("%d",&x);
                if (x){
                    addedge(i,n+j,1);
                    addedge(n+j,i,0);
                }
            }
        for (int i=2;i<=n+1;i++){
            addedge(1,i,1);
            addedge(i,1,0);
        }
        for (int i=2;i<=n+1;i++){
            addedge(n+i,2*n+2,1);
            addedge(2*n+2,n+i,0);
        }
        T=2*n+2;
        int ans=0;
        while (bfs(1)){
            ans+=dfs(1,INF);
        }
        if (ans==n)printf("Yes\n");
            else printf("No\n");
    }
    return 0;
}
```
/\*
1
7
0 1 0 1 0 0 1

1 1 0 0 0 1 0

0 0 1 0 0 0 1

0 1 0 0 1 1 0

1 0 0 1 1 0 1

0 1 1 1 0 1 1

0 1 1 0 0 1 0

Yes
\*/

---

## 作者：巨型方块 (赞：0)

二分图的基本建模；

我们发现一个行一个列只要有一个点就好啦；

意味着我们每一行上的多个点其实最多只移动一颗；

所以直接大力二分图，a[i,j]有点i连接j;

表示i行可以有j列移过来；

求最大匹配是不是n

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=205;
struct cs{int to,nxt;}a[N*N*2];
int head[N],ll,link[N];
int n,m,x,ans;
bool vi[N];
void init(int x,int y){
    a[++ll].to=y;
    a[ll].nxt=head[x];
    head[x]=ll;
}
bool dfs(int x){
    for(int k=head[x];k;k=a[k].nxt)
        if(!vi[a[k].to]){
            vi[a[k].to]=1;
            if(!link[a[k].to]||dfs(link[a[k].to])){
                link[a[k].to]=x;return 1;
            }
        }return 0;
}
int main()
{
    scanf("%d",&m);
    while(m--){
        ll=0;memset(head,0,sizeof head);
        ans=0;memset(link,0,sizeof link);
        scanf("%d",&n);
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++){
                scanf("%d",&x);
                if(x)init(i,j);
            }
        for(int i=1;i<=n;i++){
            memset(vi,0,sizeof vi);
            if(dfs(i))ans++;
        }
        if(ans==n)printf("Yes\n");else printf("No\n");
    }
}
```

---

## 作者：magolor (赞：0)

二分图匹配，可以稍微优化一下，每次memset太慢了，使用时间戳优化。


顺便，楼下，N是点数，边是N^2的，1000当然会爆。










```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
#define MAXN 500
#define MAXM 80000
#define X(x) (x)
#define Y(x) ((x)+n)
struct Edge 
{
    int to,nex;
    Edge(){}
    Edge(int _to, int _nex):to(_to),nex(_nex){}
};
Edge e[MAXM+5];
int first[MAXN+5], match[MAXN+5], book[MAXN+5], tot, id, n, T, op;
inline void Add(int a, int b)
{
    e[tot] = Edge(b,first[a]);
    first[a] = tot++;
    return;    
} 
bool DFS(int x)
{
    for(register int u = first[x], v; u+1; u = e[u].nex)
        if(book[v=e[u].to]-id)
        {
            book[v] = id;
            if(!match[v] || DFS(match[v]))
            {
                match[v] = x, match[x] = v;
                return true;
            }
        }
    return false;
}
inline int Hungary()
{
    int ans = 0;
    for(register int i = 1; i <= n; i++)
        id++, ans += DFS(i);
    return ans;
}
int main()
{
    for(scanf("%d",&T); T--; puts(Hungary()-n ? "No" : "Yes"))
    {
        scanf("%d",&n), tot = 0;
        memset(first,-1,sizeof(first)), memset(match,0,sizeof(match));
        for(register int i = 1, j; i <= n; i++)
            for(j = 1; j <= n; j++)
                if(scanf("%d",&op), op) 
                    Add(X(i),Y(j)), Add(Y(j),X(i));
    }
     return 0;
}
```

---

## 作者：Deny_小田 (赞：0)

本题是一道最大匹配的题（废话），用匈牙利算法可以实现。


首先需要构造图，使用向前星方法：

```cpp

void AddEdge(int u,int v){        //利用向前星构造图 
    edges[++count].u = u;
    edges[count].v = v;
    edges[count].next = head[u];
    head[u] = count;
}

```
然后使用匈牙利算法求最大匹配，时间复杂度为O(n^2)

```cpp

bool dfs(int u){        //匈牙利算法 最大匹配 
    for(int p = head[u]; p; p = edges[p].next){
        int v = edges[p].v;
        if(visited[v] == vis_cnt) continue;
        visited[v] = vis_cnt;
        if(!link[v]||dfs(link[v])){
            link[v] = u;
            return true;
        }
    }
    return false;
}

```

然后一个solve()函数解决问题：

```cpp

void solve(){
    memset(link,0,sizeof(link));
    for(int i = 1; i <= n; i++){ vis_cnt++; dfs(i); }
    for(int i = 1; i <= n; i++) if(!link[i]){ cout << "No" << endl; return ; }
    cout << "Yes" << endl;
}

```



**本题超级（此处省略maxint+1个“超级”）重要的一点是：

数组一定（此处省略maxint+1个“一定”）要开大点！

别看着N <= 200就放心了，我开1000都爆蛋！最后开到60000才AC！**


附代码：








    
```cpp
#include <iostream>
#include <cstring>
#define Size 1005
#define MaxN 61005
using namespace std;
struct _edge{
    int u,v,next;
}edges[MaxN];
int n,m,k,a,b,cnt = 0,visited[MaxN],link[MaxN],head[MaxN],count,t,vis_cnt = 0;
void AddEdge(int u,int v){        //利用向前星构造图 
    edges[++count].u = u;
    edges[count].v = v;
    edges[count].next = head[u];
    head[u] = count;
}
bool dfs(int u){        //匈牙利算法 最大匹配 
    for(int p = head[u]; p; p = edges[p].next){
        int v = edges[p].v;
        if(visited[v] == vis_cnt) continue;
        visited[v] = vis_cnt;
        if(!link[v]||dfs(link[v])){
            link[v] = u;
            return true;
        }
    }
    return false;
}
void solve(){
    memset(link,0,sizeof(link));
    for(int i = 1; i <= n; i++){ vis_cnt++; dfs(i); }
    for(int i = 1; i <= n; i++) if(!link[i]){ cout << "No" << endl; return ; }
    cout << "Yes" << endl;
}
int main(){
    ios::sync_with_stdio(false);
    cin >> t;
    while(t--){
        count = 0;
        memset(head,0,sizeof(head));
        cin >> n;
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= n; j++){
                int x;
                cin >> x;
                if(x) AddEdge(i,j);            //构图 
            }
        }
        solve();
    }
    return 0;
}
```

---


# [TJOI2011] 树的序

## 题目描述

众所周知，二叉查找树的形态和键值的插入顺序密切相关。准确的讲： 
1. 空树中加入一个键值 $k$，则变为只有一个结点的二叉查找树，此结点的键值即为 $k$。
2. 在非空树中插入一个键值 $k$，若 $k$ 小于其根的键值，则在其左子树中插入 $k$，否则在其右子树中插入 $k$。

我们将一棵二叉查找树的键值插入序列称为树的生成序列，现给出一个生成序列，求与其生成同样二叉查找树的所有生成序列中字典序最小的那个，其中，字典序关系是指对两个长度同为 $n$ 的生成序列，先比较第一个插入键值，再比较第二个，依此类推。

## 说明/提示

### 数据范围及约定

- 对于 $20\%$ 的数据， $1\le n ≤ 10$。
- 对于 $50\%$ 的数据， $1\le n ≤ 100$。
- 对于 $100\%$ 的数据， $1\le n ≤ 10^5$。

## 样例 #1

### 输入

```
4
1 3 4 2
```

### 输出

```
1 3 2 4```

# 题解

## 作者：_Kenma_ (赞：35)

# P1377 解题报告

## 前言

刚学笛卡尔树，遇到神仙题，写一篇题解加深印象。

如果我对笛卡尔树的认识有偏差，请指出并尽量不要开喷。

## 思路分析

首先简化题意：给定一棵依次插入元素的 BST，最小化 BST 插入元素序列的字典序（下称生成序列）。

考虑在 BST 的每个节点记录插入的权值 $k$，插入的时间戳 $t$，构成二元组 $(k,t)$。这样的一棵 BST 在权值维度满足 BST 的性质，在时间戳维度满足小根堆的性质。所以，题目给出的 BST 是一棵 Treap。

解释一下为什么在时间戳维度满足堆的性质。不难发现，后插入的节点的父亲一定是先插入的节点。其实，所有朴素构建的 BST 都是 Treap。

现在的问题变为，通过重新分配这棵 Treap 的节点的二元组中的 $t$ 的值，使其依然满足堆的性质的同时，最小化生成序列的字典序。

直接说可能有点抽象，我们以样例为例：

给定我们的生成序列为：$1,3,4,2$。

变为二元组：$(1,1),(3,2),(4,3),(2,4)$。

变成 BST：

![](https://cdn.luogu.com.cn/upload/image_hosting/c4pvoque.png)

这样肯定不是最优的，不难发现，我们如果交换 $(3,2)$ 左右儿子的 $t$ 的值，可以使生成序列的字典序变得更小。

像这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/9ru1uen0.png)

此时的生成序列：$1,3,2,4$。

考虑怎样分配时间戳 $t$ 是最优的。

注意到，因为要满足小根堆的性质，所以父亲的 $t$ 的值要大于其后代的 $t$ 的值。

又因为 Treap 满足 BST 的性质，贪心地考虑，将较小的 $t$ 分配给左子树，结果一定优于分配给右子树。

我们总结一下分配顺序：父亲 $>$ 左子树 $>$ 右子树。

注意到这就是对 BST 的前序遍历。

问题在于，按题意模拟构建 BST 的复杂度是 $O(n^2)$ 的，（但是能通过原题数据？），所以我们考虑更为高效的建树方法。

我们联想到，笛卡尔树的建树复杂度是 $O(n)$ 的，并且笛卡尔树也是 Treap，我们考虑怎样将本题中的 BST 转化为笛卡尔树。

考虑笛卡尔树和本题 BST 的区别仅在于二元组的先后顺序不同。具体地，笛卡尔树是权值维度 $k$ 满足堆的性质，时间戳维度 $t$ 满足 BST 的性质。而本题的 BST 恰好相反。所以，我们只需要交换二元组的顺序，就可以仿照笛卡尔树 $O(n)$ 建树了。

具体实现很简洁（至少比我讲的简洁）。考虑正常笛卡尔树的生成序列 $a$，本质上是二元组 $(a_i,i)$，而本题中二元组为 $(i,a_i)$。把序列 $a$ 的下标和值交换就行了。

## 代码实现

代码实现很简洁，只要理解了笛卡尔树和 Treap 的关系，就很容易写出代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,a[100005],ls[100005],rs[100005],vis[100005],flag;
void dfs(int x){
	cout<<x<<' ';
	if(ls[x]) dfs(ls[x]);
	if(rs[x]) dfs(rs[x]);
}
stack<int> s;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0); 
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>x;
		a[x]=i;
	}
	for(int i=1;i<=n;i++){
		flag=0;
		while(s.size() && a[s.top()]>a[i]) flag=s.top(),s.pop();
		if(s.size()) rs[s.top()]=i;
		if(flag) ls[i]=flag;
		s.push(i);
	} 
	for(int i=1;i<=n;i++){
		vis[ls[i]]=1;
		vis[rs[i]]=1;
	}
	for(int i=1;i<=n;i++){
		if(!vis[i]){
			dfs(i);
			break;
		}
	}
	return 0;
}
```
注意到没有任何细节。

## 后记

这是一道考察选手对 Treap 和笛卡尔树理解的思维好题，构造精妙和谐，让人耳目一新。

---

## 作者：ql12345 (赞：26)

# 笛卡尔树
	
#### 通过两个题目更好地理解笛卡尔树
    
## [【模板】笛卡尔树](https://www.luogu.com.cn/problem/P5854)

### Part 1：定义
定义和[Treap](https://www.luogu.com.cn/problem/P3369)相同：（Treap是权值随机的笛卡尔树）

- k满足二叉搜索树性质

- w满足[小根堆](https://www.luogu.com.cn/problem/P3378)性质

本题下标为k，元素为w（题目定义）

正常构建的Treap应该是下标为w，元素为k（可以模拟插入过程理解） 例题：[树的序](https://www.luogu.com.cn/problem/P1377)
（下面有代码）

### Part 2：构建

#### 用[单调栈](https://www.luogu.com.cn/problem/P5788)维护插入的位置

（下标已经单调递增了，所以新插入的点只能是已前面点的右儿子、前面点只能是它的左儿子）
      
- 用单调栈维护一个权值单调递增的下标序列，

- 插入一个点时插入到第一个比它小的点（如果有的话）（作为右儿子）后，如果遇到了比它大的点，将最后一个比它大的点作为左儿子

### code

```cpp
#include<bits/stdc++.h>
#define re register
#define il inline
#define LL long long
using namespace std;
template<typename T>il void read(T &ff){
    T rr=1;ff=0;re char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')rr=-1;ch=getchar();}
    while(isdigit(ch)){ff=(ff<<1)+(ff<<3)+(ch^48);ch=getchar();}
    ff*=rr;
}
const int N=1e7+7;
int n,a[N],stk[N],ls[N],rs[N];
LL L,R;
signed main(){
    read(n);
    for(re int i=1,pos=0,top=0;i<=n;++i){//这是按下标顺序插入元素的代码
        read(a[i]);
        //除了上述的维护左右儿子就是普通单调栈啦
        pos=top;
        while(pos&&a[stk[pos]]>a[i])pos--;
        if(pos)rs[stk[pos]]=i;
        if(pos<top)ls[i]=stk[pos+1];
        stk[top=++pos]=i;
    }
    for(re int i=1;i<=n;++i)L^=1LL*i*(ls[i]+1),R^=1LL*i*(rs[i]+1);
    printf("%lld %lld",L,R);
    return 0;
}
```

## [树的序](https://www.luogu.com.cn/problem/P1377)

### 题意：

给一个生成序列，建出一棵笛卡尔树，求字典序最小的可以得到相同笛卡尔树的生成序列

### 题解

按题意建好树之后输出[先序遍历](https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin)即可

建树略有不同（代码中有注释）

### code

```cpp
复杂度 O(N)
#include<bits/stdc++.h>
#define re register
#define il inline
#define LL long long
using namespace std;
template<typename T>il void read(T &ff){
    T rr=1;ff=0;re char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')rr=-1;ch=getchar();}
    while(isdigit(ch)){ff=(ff<<1)+(ff<<3)+(ch^48);ch=getchar();}
    ff*=rr;
}
const int N=1e5+7;
int n,a[N],stk[N],ls[N],rs[N];
void dfs(re int x){
    if(x)printf("%d ",x),dfs(ls[x]),dfs(rs[x]);
}
signed main(){
    read(n);
    for(re int i=1,x;i<=n;++i)read(x),a[x]=i;//与笛卡尔树模板不同之处
                                            //这里“把权值当做下标，以下标为权值‘输入’a数组”，就转化成板子啦
    for(re int i=1,pos=0,top=0;i<=n;++i){
        pos=top;
        while(pos&&a[stk[pos]]>a[i])pos--;
        if(pos)rs[stk[pos]]=i;
        if(pos<top)ls[i]=stk[pos+1];
        stk[top=++pos]=i;
    }
    dfs(stk[1]);
    return 0;
}
```


---

## 作者：wzj423 (赞：18)

我来讲一讲如何得出所求树就是笛卡尔树的：

这道题其实就是建一颗指定的二叉查找树，由于指定了插入方式，所以这道题目的树有两个限制：值要满足二叉查找树的限制，插入顺序上儿子比父亲晚插入，满足堆得性质。
#### 这不就是笛卡尔树吗！
所以就可以O(NlogN)建树了，其实桶排能到O(N)
>整个过程的第一步是把所有点按照key排序，然后从一个节点开始，按key递增顺序依次插入节点。想象一下，假设已经有一棵笛卡尔树，那么现在我们要插入一个新的节点，而这个节点比这棵树所有节点的key都大，那么应该如何插入呢？假设这个节点已经被插入，那么它的位置肯定是在从根节点开始一直向右走。所以，每次插入新节点的时候，一定插入到最右侧那条路中的某个位置，而原来位置的节点变成了这个新节点的左子树，新插入的点变成最右侧那条路的最后一个节点。

>那么如何确定插入的位置呢？那就要根据这个节点的value值了，因为满足堆的性质，所以一条路从上到下，其value值肯定是递减的。就是因为这个递减的性质，我们可以把最右侧的那条路用一个栈表示，栈底是根，栈顶是最新节点，从底到顶，value值和key值都递增。每次新插入一个节点的时候，就从顶往底一个个看，找到第一个value大于新节点value的节点，作为新节点的父亲即可。因为每个节点最多进栈一次，出栈一次，所以整个构树过程是O(N)的。

```cpp
#include <bits/stdc++.h>
const int MAXN=1e5+10;
using namespace std;
int N;
int ls[MAXN],rs[MAXN],vv[MAXN];
int s[MAXN],top;
struct dat{
    int val,id;
    bool operator <(const dat&d) const {
        return val<d.val;
    }
}a[MAXN];
void dfs(int st) {
	if(!st) return;
	printf("%d ",vv[st]);
    dfs(ls[st]);
    dfs(rs[st]);
}
int main() {
	scanf("%d",&N);
	for(int i=1;i<=N;++i) scanf("%d",&a[i].val),a[i].id=i;
    sort(a+1,a+N+1);
    for(int i=1;i<=N;++i) {
        while(top&&a[s[top]].id>a[i].id) top--;
		vv[i]=a[i].val;
        ls[i]=rs[s[top]];
        rs[s[top]]=i;
        s[++top]=i;
    }
 //   for(int i=0;i<=N;++i) printf("ls[%d]=%d,rs[%d]=%d vv[%d]=%d\n",i,ls[i],i,rs[i],i,vv[i]);
    dfs(rs[0]);
	return 0;
}

```


---

## 作者：wjyyy (赞：11)

安利一下[个人博客](http://www.wjyyy.top/487.html)，虽然可能排版没有这里好看……

虽然这个题正解不是平衡树，不过可以拿平衡树优化一下常数，达到$ O(NlogN)$就能过了。

### 为什么可以用平衡树呢？ 
**平衡树**套用了BST的一种性质，就是某数在插入前（第一个数跳过），要么它的前驱和后继的深度是不同的，要么它没有前驱（此时前驱深度定为0），要么它没有后继（此时后继深度定为0）；**这时候它一定会被插入为较深的那一个的孩子**（下面给出证明）。

### 做法
因此我们只需要存每个点的节点地址，就可以用平衡树求出前驱和后继从而直接访问较深节点并插入，就回避了BST退化成链的情况。~~**用BST优化BST XD**~~


**上述命题证明：**如果遍历过程两个节点都要经过（即在根节点的同侧），那么会去到较深的点。**因为经过较浅的那个节点时，那个节点会把它继续向下插入，直到找到较深的另一个点，这是BST的插入性质。**如果遍历过程不同时经过这两个点（前驱和后继），则不会出现分属两树的情况，因为此时的根节点比前驱大，比后继小，那么前驱和后继求的就是不合法的，因此不会出现这种情况。**原命题得证。**


### 总结
伸展树在这里会用到的功能可能不算多，所以敲起来比较方便也比较迅速。因此在想不到正解而splay可做时，就最好先打个splay上去咯。（~~说不定平衡树是正解啊蛤蛤蛤~~）

### 习惯用指针

## Code：
```cpp
#include<cstdio>
#include<cstring>
#define Root spl::root
#define RooT BST::root
int dpt[101000];//深度
namespace spl//开两个namespace可以用两个node（起名困难症）
{
struct node
{
    int key;
    node *s[2];
    node(int key)
    {
        this->key=key;
        s[0]=NULL;
        s[1]=NULL;
    }
    node()
    {
        s[0]=NULL;
        s[1]=NULL;
    }
    int getd(int x)
    {
        if(x==key)
            return -1;
        return x>key;
    }
};
node *root=NULL;
void Rotate(node *&rt,int d)
{
    node *tmp=rt->s[d];
    rt->s[d]=tmp->s[d^1];
    tmp->s[d^1]=rt;
    rt=tmp;
    return;
}
void splay(node *&rt,int x)
{
    int d1=rt->getd(x);
    if(d1==-1)
        return;
    int d2=rt->s[d1]->getd(x);
    if(d2==-1)
    {
        Rotate(rt,d1);
        return;
    }
    splay(rt->s[d1]->s[d2],x);
    if(d1==d2)
    {
        Rotate(rt,d1);
        Rotate(rt,d1);
        return;
    }
    else
    {
        Rotate(rt->s[d1],d2);
        Rotate(rt,d1);
        return;
    }
}
void Insert(node *&rt,int x)
{
    if(!rt)
    {
        rt=new node(x);
        return;
    }
    Insert(rt->s[rt->getd(x)],x);//没有重复元素
    return;
}
//也没有删除
int getm(node *rt,int d)
{
    if(!rt->s[d])
        return rt->key;
    return getm(rt->s[d],d);
}
}
namespace BST
{
struct node
{
    int v;
    node *ls,*rs;
    node(int v)
    {
        this->v=v;
        ls=NULL;
        rs=NULL;
    }
    node()
    {
        ls=NULL;
        rs=NULL;
    }
}*root=NULL;
node *pla[101000];//存这个节点的指针地址
void Insert(node *&rt,int x,int d)//记得计算深度
{
    if(!rt)
    {
        dpt[x]=d;
        rt=new node(x);
        pla[x]=rt;
        return;
    }
    if(x<rt->v)
        Insert(rt->ls,x,d+1);
    else
        Insert(rt->rs,x,d+1);
    return;
}
void pre_ord(node *rt)
{
    printf("%d ",rt->v);
    if(rt->ls)
        pre_ord(rt->ls);
    if(rt->rs)
        pre_ord(rt->rs);
}
}
using BST::pla;

int main()
{
    memset(dpt,0,sizeof(dpt));
    memset(pla,NULL,sizeof(pla));
    int n,a;
    scanf("%d",&n);
    scanf("%d",&a);
    spl::Insert(Root,a);//第一个是构造根节点要特判
    BST::Insert(RooT,a,1);

    int p,s;//p是pre前驱，s是suc后继
    for(int i=2;i<=n;i++)
    {
        scanf("%d",&a);
        spl::Insert(Root,a);
        spl::splay(Root,a);
        p=0;//这里注意置0，否则下面用到s和p就会GG（紊乱）
        s=0;
        if(Root->s[0])
            p=getm(Root->s[0],1);
        if(Root->s[1])
            s=getm(Root->s[1],0);
        if(dpt[p]>dpt[s])
            BST::Insert(pla[p],a,1);
        else
            BST::Insert(pla[s],a,1);
    }
    BST::pre_ord(RooT);
    return 0;
}
```

---

## 作者：wxzzzz (赞：7)

### 思路

按照题意建立二叉查找树，直接按先序遍历。

这是朴素的建树方式插入一个数 $x$ 的操作：

1. 如果树为空，直接新建一个节点，权值为 $x$。

1. 如果树不为空，从根节点开始遍历，令当前遍历到的节点为 $p$，若 $x$ 的权值比 $p$ 小，则令 $p$ 转移到 $p$ 的左儿子，否则转移到 $p$ 的右儿子。

1. 重复操作 $2$ 直到 $p$ 表示一个空节点，将这个节点的权值赋为 $x$。

```cpp
void insert(int x) {
    if (!idt) {
        t[++idt] = {0, 0, x};
        return;
    }

    int p = 1;

    while (p) {
        if (x < t[p].val) {
            if (!t[p].ls)
                break;

            p = t[p].ls;
        } else {
            if (!t[p].rs)
                break;

            p = t[p].rs;
        }
    }

    if (x < t[p].val) {
        t[p].ls = ++idt;
        t[idt].val = x;
    } else {
        t[p].rs = ++idt;
        t[idt].val = x;
    }
}
```

上面代码的平均复杂度为 $O(\log n)$，但当 $a_i$ 有单调性时，二叉查找树会退化成一条链，insert 的复杂度退化成 $O(n)$。

考虑优化 insert。

可以发现根本没必要从根节点开始遍历，因为 $x$ 最终只可能插到这两个位置：

1. 权值比 $x$ 大的权值最小的节点的左儿子。

1. 权值比 $x$ 小的权值最大的节点的右儿子。

这两个东西都可以用 set 维护。

把 $x$ 放到任意一个有空的位置即可。

注意，朴素遍历方式会优先放位置 $1$，因此在这题要优先放位置 $1$。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, idt, a[100005];
set<pair<int, int>> p;
set<pair<int, int>>::iterator it;
struct node {
    int ls, rs, val;
} t[100005];
void insert(int x) {
    if (!idt) {
        t[++idt] = {0, 0, x};
        p.insert({x, 1});
        return;
    }

    it = p.lower_bound({x, 0});

    if (it == p.end() || t[(*it).second].ls)
        it--, t[(*it).second].rs = ++idt, t[idt].val = x;
    else
        t[(*it).second].ls = ++idt, t[idt].val = x;

    p.insert({x, idt});
}
void dfs(int p) {
    cout << t[p].val << ' ';

    if (t[p].ls)
        dfs(t[p].ls);

    if (t[p].rs)
        dfs(t[p].rs);
}
int main() {
    cin >> n;

    for (int i = 1, x; i <= n; i++) {
        cin >> x;
        insert(x);
    }

    dfs(1);
    return 0;
}
```

---

## 作者：tommymio (赞：4)

原来早在2011年就考线段树优化建BST了（瘫

经过一番思索我们可以发现，插入序列构成的BST的前序遍历即为答案，正确性显然.

但是BST很明显具有不稳定性，直接建树时间复杂度非常假，考虑优化建树，可以使用笛卡尔树建树或线段树优化建树，这里特别记录一下线段树优化建树.

我们发现每次插入一个节点，被插入的节点的父亲和该节点管辖区间会变化，于是我们记录下这些管辖区间，并在这个节点的儿子节点被插入时分别修改这些管辖区间，查询的时候直接查询当前点被哪些管辖区间覆盖，线段树区间覆盖+单点修改即可.

**Show the Code**
```cpp
#include<cstdio>
int n,rt;
int l[100005],r[100005];
int tag[400005],sum[400005],ch[100005][2];
inline int read() {
	register int x=0,f=1;register char s=getchar();
	while(s>'9'||s<'0') {if(s=='-') f=-1;s=getchar();}
	while(s>='0'&&s<='9') {x=x*10+s-'0';s=getchar();}
	return x*f;
}
inline void spread(int p) {if(tag[p]) {tag[p<<1]=tag[p<<1|1]=sum[p<<1]=sum[p<<1|1]=tag[p];tag[p]=0;}}
inline void change(int L,int R,int x,int p=1,int l=1,int r=n) {
	if(L>R) return;
	if(L<=l&&r<=R) {sum[p]=tag[p]=x;return;}
	spread(p);
	int mid=l+r>>1;
	if(L<=mid) change(L,R,x,p<<1,l,mid);
	if(R>mid) change(L,R,x,p<<1|1,mid+1,r);
}
inline int ask(int x,int p=1,int l=1,int r=n) {
	if(l==r) return sum[p];
	spread(p);
	int mid=l+r>>1;
	if(x<=mid) return ask(x,p<<1,l,mid);
	else return ask(x,p<<1|1,mid+1,r);
}
inline void print(int x) {
	printf("%d ",x);
	if(ch[x][0]) print(ch[x][0]);
	if(ch[x][1]) print(ch[x][1]);
}
int main() {
	n=read(),rt=read();
	change(1,n,rt);
	l[rt]=1;r[rt]=n;
	for(register int i=2;i<=n;++i) {
		int x=read(),res=ask(x);
		if(x<res) {
			ch[res][0]=x;
			l[x]=l[res],r[x]=res-1;
			change(l[x],r[x],x);
			if(!ch[res][1]) {l[res]=res+1;}
			else {l[res]=res,r[res]=res;}
		}
		else {//x>=res
			ch[res][1]=x;
			l[x]=res,r[x]=r[res];
			change(l[x],r[x],x);
			if(!ch[res][0]) {r[res]=res-1;}
			else {l[res]=res,r[res]=res;}
		}
	}
	print(rt);
	return 0;
}

```

---

## 作者：Minclxc (赞：3)

正解应该是O(n)建二叉搜索树，因为直接建树可能会退化到O(n^2)（luogu数据不够强）

O(n)建树有两种方法，分别是对排序后的数组建笛卡尔树和倒序连边

第二种比较简单，双向队列维护就好了

每次找最后一个插入的点，将它和前驱、后继中较迟的点连边，然后删去这个点

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
#define fo(a,b,c) for(int a=b;a<=c;a++)
#define go(a,b,c) for(int a=b;a>=c;a--)
#define mp make_pair
int read(){
    int a=0,f=0;char c=getchar();
    for(;c<'0'||c>'9';c=getchar())if(c=='-')f=1;
    for(;c>='0'&&c<='9';c=getchar())a=a*10+c-'0';
    return f?-a:a;
}
const int N=1e5+2;
int a[N],t[N],pre[N],suc[N],lc[N],rc[N];
void dfs(int x){
    if(!x)return;
    printf("%d ",x);
    dfs(lc[x]);dfs(rc[x]);
} 
int main(){
    int n=read();
    fo(i,1,n)
        a[t[i]=read()]=i,
        pre[i]=i-1,suc[i]=i+1; 
    go(i,n,2){
        int pree=pre[t[i]],succ=suc[t[i]];
        if(a[pree]>a[succ])rc[pree]=t[i];
        else lc[succ]=t[i];
        pre[succ]=pree,suc[pree]=succ;
    } 
    dfs(t[1]);
    return 0;
}
```

---

## 作者：__JR_飘摇__ (赞：3)

~~说实在的，这题应该没有提高+难度~~


------------
简单的说，题意就是要你根据生成序列建一颗二叉查找树，然后对它遍历~~

遍历很显然是$O(n)$的，但是如果是一条链，建树会被卡到$O(n^2)$。。

那么我们需要一些数据结构实现。。

这里我用树状数组与二分实现的

## 树状数组为什么能够做？

首先我们知道排序二叉树的 左子树<根节点<右子树 那么我们要对一个新的节点插入，我们肯定就是将它插在二叉树中第一个比它小的右儿子或者第一个比它大的左儿子中。树状数组与二分就实现找到这两个值的位置。

## 要怎么实现呢？

实现其实很简单的，我们用树状数组维护前缀和，既然考虑到前缀和是单调递增，我们就直接对它进行二分查找就行了

代码如下：
```
int findpos(int x)
{
	int l = 1,r = n + 1;
	while(l + 1 < r)
	{
		int mid = (l + r) / 2;
		if(findsum(mid) >= x) r = mid;
		else l = mid; 
	}
	if(findsum(l) != x) return r;//下面注释
	return l;
}
```
为了保证我们查找后的数在这颗树中，我们二分查找的目的是找到第一个比它小的树，但是，当mid指针指向我们要的数时，l指针就不会指到了，所以我们要进行判断。一次查找复杂度是$O(log^2n)$

所以总时间复杂度为$O(n*log^2n)$

虽然相比于其他正解慢了一点，但是思路却不会难想，~~而且能过~~

### 下面贴完整代码
```
#include<bits/stdc++.h>
using namespace std;
int n,i,sum[210000],g,minn;
int lowbit(int x)
{
	return x & (-x);
}
struct node
{
	int ch[2];
}f[210000];
int add(int x)
{
	while(x<=n)
	{
		sum[x] ++;
		x += lowbit(x); 
	}
}
int findsum(int x)
{
	int ans = 0;
	while(x)
	{
		ans += sum[x];
		x -= lowbit(x);
	}
	return ans;
}
int findpos(int x)
{
	int l = 1,r = n + 1;
	while(l + 1 < r)
	{
		int mid = (l + r) / 2;
		if(findsum(mid) >= x) r = mid;
		else l = mid; 
	}
	if(findsum(l) != x) return r;
	return l;
}
int print(int x)
{
	if(x > n || x < 1) return 0;
	printf("%d ", x );
	print(f[x].ch[0]);
	print(f[x].ch[1]);
}
int main()
{
	scanf("%d", &n );
	scanf("%d", &g );
	add(g);minn = g;
	for(i = 2;i <= n;i ++)
	{
		int x;
		scanf("%d", &x);
		int op=findsum(x);//我们的目的就是要找到它是第几大的位置
		int s = findpos(op);//然后进行查找
		if(x < minn) s = minn,minn = x;//如果找出来是0怎么办，这是一个小细节
		int k = (s < x);
		if(!f[s].ch[k]) f[s].ch[k] = x;
		else f[findpos(op + (k ? 1 : -1))].ch[1 ^ k] = x;
		add(x);
	}
	print(g);
} 
```

---

## 作者：冷月冰瞳 (赞：2)

楼下两个题解都要先模拟建树，但是模拟建树是会退化到O(N^2)的，例如插入顺序是1, 2, 3, ..., N。所以我们需要用一个有复杂度保证的方法建树。

设P[i]表示数字i是第几个被插入的，也就是P[ki]=i。因为插入的数字是1...N，那么每一个子树必然是连续的一段自然数（假设为[x, y]），且这个子树的根节点是 x ~ y 中最早被插入的，也就是求 P[x...y] 的最小值。求出最小值之后，假设为 z，我们将 z 设为当前子树的根节点，然后将区间 [x, y] 分成 [x, z-1] 和 [z+1, y] 递归处理，这样就可以在 O(n log n) 时间内将树建出来。

```cpp
int build_tree(int x, int y) { // 传入区间，返回根节点。
  int z = find_min(x, y);
  if (x < z) tree[z].l = build_tree(x, z-1);
  if (z < y) tree[z].r = build_tree(z+1, y);
  return z;
}
```
建完树之后，那么就是直接输出这棵树的先序遍历即可。


---


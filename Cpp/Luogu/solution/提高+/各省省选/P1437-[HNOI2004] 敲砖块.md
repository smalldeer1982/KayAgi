# [HNOI2004] 敲砖块

## 题目背景

无

## 题目描述

在一个凹槽中放置了 $n$ 层砖块、最上面的一层有 $n$ 块砖，从上到下每层依次减少一块砖。每块砖都有一个分值，敲掉这块砖就能得到相应的分值，如下图所示：

```cpp
14 15  4  3  23
 33  33 76  2
   2   13 11
     22 23
       31
```
如果你想敲掉第 $i$ 层的第 $j$ 块砖的话，若 $i=1$，你可以直接敲掉它；若 $i>1$，则你必须先敲掉第 $i-1$ 层的第 $j$ 和第 $j+1$ 块砖。

你现在可以敲掉最多 $m$ 块砖，求得分最多能有多少。

## 样例 #1

### 输入

```
4 5
2 2 3 4
8 2 7
2 3
49```

### 输出

```
19```

# 题解

## 作者：狸狸养的敏敏 (赞：78)

### 题意简述 
      
给出一个$N$行的，第$i$行有$N＋1－i$个数的倒三角形，从其中选取$M$个数,选取条件为当前数的左上角和右上角必须被选取过才能选取，求选取的数字的最大和。 

### 分析：
拿到题目首先找题目的特点，就是和别的题目不同的地方，这题的特点就是：每个数选取条件为左上和右上的数已选。 

通常的思路，数从上往下取，那么这一层的某个数能不能取，只与上一层的数取不取有关。 

极像数字三角形问题的变形。

比较容易想到了Dp，想到的状态表示法为$F[i,j,k]$表示第$(i,j)$个位置，已经选取了$k$个数字的最大值，转移自然是从左上角和右上角（在直角三角形中位正上方和右上方）转移过来。

## 问题：      
>1、如何判断左上角和右上角的状态能否转移到当前状态？即左上与右上都已经选取，则可转移；

>2、如何转移呢？找不出方程。

### 原因： 

本问题符合DP的子结构性质，却不符合DP的无后效性。

(以下关于无后效性的解释来自网络)


------------


所谓无后效性原则，指的是这样一种性质：某阶段的状态一旦确定，则此后过程的演变不再受此前各状态及决策的影响。

也就是说，“未来与过去无关”，当前的状态是此前历史的一个完整总结，此前的历史只能通过当前的状态去影响过程未来的演变。

具体地说，如果一个问题被划分各个阶段之后，阶段$ i$ 中的状态只能由阶段 $i+1$ 中的状态通过状态转移方程得来，与其他状态没有关系，特别是与未发生的状态没有关系，这就是无后效性。


------------

对于$F[i,j,k]$ ，能否转移，与之前的方案是有关的。 即有后效性，为了消除后效性，通常和方法是加记一维，用二进制数表示上一行的选取情况。 

这样，就没有后效性了。而且转移的方法也简单，直接判断上一行所需的两个数是否已经选取了。 

然而，状态数为$N^2*2^N$，这个数量级在$N=50$的时侯是不可承受的。 

看来这条思路已经山穷水尽了。只能回头从别的方面想了。题目中有否可用的信息呢？

## 转换思路

![](https://i.loli.net/2019/03/10/5c84c86091228.png)

分析题目中的选取条件，我们会发现： 

这道题最终解的形态（选中的数字）可以描述成若干个三角形相互连接或重叠，如上图中的红色砖块，由两个蓝色标识的三角形部分重叠而成。 

将最终解的形态（选中的数字）的每列最下层点用线画出（图中的蓝线），可以发现：

```
1、构成的轮廓线是一条锯齿状的折线；
2、轮廓线上的相邻点布局在三角形的相列与相邻行上，即如果从左向右观察列，轮廓线上的点只能从其左列的上方行或下方行连过来；
3、轮廓线上点所在列的上方点一定全部被选中。

```

则把原问题转化为沟画出重叠三角形的锯齿状轮廓折线，找到一条合法的路径，使得围在轮廓线内的数字代价和最大。

另，根据第3点分析，轮廓线上点所在列的上方点一定全部被选中，可将选中的数字压缩到轮廓线上点，问题进一步转化为求轮廓线上点的代价和最大。
    
# 算法：

1、预处理： 

设$cost[i,j]$表示选取第$i$行第$j$个，需要一起选取的其他点的个数。即与这个点同一列，且在这个点之上的点的个数。

2、

$sum[i,j]$表示选取第$i$行第$j$个，需要一起选取的其他点的数值和。即与这个点同一列，且在这个点之上的点的数值之和。 

这样，cost[],sum[]分别记录了走到每个格子本列的数字个数与代价和。 

 3、
 
 因为对于任意一列的任意一个数字，转移到它的前提与之前的方案无关，所以满足了Dp的无后效性。 同时当前列必定要由之前的某个最优状态转移过来，所以又满足了最优子结构的性质。故DP是可行的。
 
  4、重新回到原来的状态表示： 
  
 记$F[i,j,k]$表示(i,j)这个点，已经选取了K个数字的最优值。
 
从左到右进行DP，一个点的最优值则由这个点左列上行的点或左列下行的点转移过来，因为轮廓线是连续的。 

得到了Dp方程：
$F[i,j,k]:=max(F[i-1,j,k-cost[i,j]],F[i+1,j-1,k-cost[i,j]])+sum[i,j] $

Tips:

要额外开一排0排，用来表示每一列一个都不取的情况。 

        
End.

---

## 作者：BJpers2 (赞：78)

这是集百家之长和本蒟蒻的一些小想法的思路，要翻转三角形（~~因为看着顺眼~~）。

首先有Youngsc大佬的原版方程：
```cpp
f[i][j][k]=max(f[i][j][k],f[i-1][t][k-t]+s[i][j]);
//t=j+1~i-1
```
要枚举i,j,k,t,时间为O(MN^3),空间为MN^2

我们发现，其实在求max(f[i-1][t][k-t])的过程中即求一个前缀最大值，于是我们又可以令maxl[i][j][k]=max(f[i][j-1][k],f[i][j][k],...,f[i][i][k])这样转移方程变为：
```cpp
f[i][j][k]=maxl[i-1][j-1][k-j]+s[i][j];
maxl[i][j][k]=max(f[i][j][k],maxl[i][j+1][k]);
//j=i~1
```
而且，改变枚举j的顺序后，还可以去掉i这一维，也即：
```cpp
f[j][k]=maxl[j-1][k-j]+s[i][j];
maxl[j][k]=max(f[j][k],maxl[j+1][k]);
//j=i~1,k=min(j+i*(i-1)/2,m)~j*(j+1)/2
```
因为，在更新maxl[j][k]以后，不会对之后的maxl[j-2][k-j]产生任何影响。这样，时间变为O(MN^2),空间变为NM,几近完美，代码只要二十几行！

**但是，此法有一巨大问题：0**

显然，0的状态不可能从-1那里转移，这就为maxl的转移带来了不便。实际上，在扫完一列的过程中，有一个区间的maxl没有更新。
举个例子：当i=6:j=6,k=21~21;j=5,k=15~20;j=4,k=10~19;...;j=1,k=1~16。不难发现，例如[3][20]和[2][17]这样的地方都没有被maxl找到，因此还要在主要转移之后“补救”。（代码极丑）

而且，对于0而言，即相当于本列一块砖都不打，那么比不受上方砖块的制约，想怎么打就怎么打，因此它的转移方程较为特殊：
```cpp
maxl[0][k]=max(maxl[1][k],maxl[0][k]); 
```
**下面上代码,尽管丑，但短！**
```cpp
#include<iostream>
#include<cstdio>
#define FOR(i,a,b) for(int i=a;i<=b;i++)
#define FOS(i,a,b) for(int i=a;i>=b;i--)
#define N 60
#define M 1400
using namespace std;
int s[N][N],f[N][M],maxl[N][M],ans,n,m,x;
int main(){
	scanf("%d%d",&n,&m);
	FOR(j,1,n)
		FOS(i,n,j) scanf("%d",&x),s[i][j]=s[i][j-1]+x;
	FOR(i,1,n){
		FOS(j,i,1)
			FOS(k,min(j+i*(i-1)/2,m),j*(j+1)/2){
	    		f[j][k]=maxl[j-1][k-j]+s[i][j];
	    		maxl[j][k]=max(maxl[j+1][k],f[j][k]);
	    		ans=max(ans,f[j][k]);
			}  
		FOR(k,i*(i-1)/2+1,i*(i+1)/2)
		    FOS(j,k-i*(i-1)/2-1,0)
		        maxl[j][k]=max(maxl[j+1][k],f[j][k]); 
	    FOR(k,1,i*(i+1)/2)
		    maxl[0][k]=max(maxl[1][k],maxl[0][k]); 
	}   
	printf("%d",ans);
	return 0;
} 
```
并且，这份代码跑完所有数据仅用时20ms。

---

## 作者：YoungLove (赞：49)

[Youngsc](https://youngscc.github.io/)

并没有去旋转三角形。

首先定义$f[i][j][k]$表示从后往前打到第$i$列第$j$个且一共打了$k$次的最大分数。

由于题目中已知，如果我想打一个砖块，那么我必须将他正上方和右上方的砖块都打，所以打到第$i$列第$j$就意味着这一列打掉的砖块为$1,2,\ldots,j$,对于此我们用前缀和去维护$\sum_{1}^j a[i][j]$。

为了避免后效性，我们从后往前枚举列那么状态转移方程就是$f[j][i][k] = Max(f[j+1][t][k-i]+\sum_{1}^j{a[i][j]})$，当然$t$只能从$i-1$到$n-j$。


安利博客  (Youngsc)[http://youngsc.ml/]


## 代码在这里


```cpp
# include <bits/stdc++.h>
# define R register
# define LL long long
using namespace std;

int n,m,a[55][55],ans,f[55][55][3010];

template <typename T> inline void in(R T& a){
    R char c=getchar();R int x=0,f=1;
    while (!isdigit(c)){if(c == '-') f=-1; c=getchar();}
    while (isdigit(c)) x=(x<<1)+(x<<3)+c-'0',c = getchar();
    a=x*f;
}

template <typename T> inline void maxx(R T& a,const T b){a<b? a=b:0;}
template <typename T> inline void minn(R T& a,const T b){a>b? a=b:0;}

int main(){
    // freopen("makechess.in","r",stdin);
    // freopen("makechess.out","w",stdout);
    in(n),in(m);
    memset(f,-127,sizeof(f));//避免不合法状态转移
    f[n+1][0][0] = 0;//初始化合法状态
    for(R int i=1; i<=n; ++i)
        for(R int j=1; j<=n-i+1; ++j)
            in(a[i][j]);

    for(R int j=n; j>=1; --j)
        for(R int i=0,sum=0; i<=n-j+1; ++i,sum+=a[i][j])
            for(R int k=i; k<=m; ++k)
                for(R int l=max(0,i-1); l<=n-j; ++l)
                    maxx(f[j][i][k],f[j+1][l][k-i]+sum);
    for(R int i=1; i<=n; ++i)
        for(R int j=1; j<=n-i+1; ++j)
            maxx(ans,f[i][j][m]);
    printf("%d",ans);
}

```

---

## 作者：__gcd (赞：37)

本篇博文使用 $\operatorname{Typora}$ 完成。

传送门：[[HNOI2004]敲砖块](https://www.luogu.com.cn/problem/P1437)

显然这题是一个动态规划问题。~~因为 dfs 会挂，其他算法也不对。~~

一般 DP 的组成结构是：阶段+状态+决策点。以区间 DP 为例，阶段为每个区间的长度，状态为每个 $(i,j)$，决策点即为 $(i,j)$ 中的断点。

对于这道题，一个显然的思路是：以层数为状态，按层 DP。

由于影响状态的是每一个砖块，还有限制 $k$，所以我们设状态 $dp(i,j,k)$ 为 $(i,j)$ 之前敲 $k$ 个砖块的最大得分。

再来考虑影响这个状态的其他状态。因为状态中有“之前”，所以 $(i,j-1)$ 必定影响这个状态。而且如果要敲掉这个砖块，$(i-1,j)$ 和 $(i-1,j+1)$ 也必须要敲掉，所以它们也是影响这个状态的因素。但是如果要将它们三个联系起来，就会发现我们很难处理 $(i,j-1)$ 和 $(i-1,j),(i-1,j+1)$ 的关系，因为 $(i,j-1)$ 的这个状态的所有决策中是否必定使得 $(i-1,j),(i-1,j+1)$ 被敲掉，我们不能确定。所以这个方法被我们否决。

看到很多题解都写了这种方法有后效性，但是我看了半天也没看出来QAQ。

接下来说说正解。

如果我们仔细观察被打的砖块所组成的形状，就会发现，如果一个砖块被敲掉，那么包含在以它为顶的倒三角形中所包含的所有砖块都必须被敲掉。如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/cg0qwx3t.png)

进一步观察发现，每一列被敲掉的砖块是连续的。换一种说法，如果 $(i,j)$ 被敲掉，那么 $(i-1,j),(i-2,j),\ldots,(1,j)$ 也都会被敲掉，并且如果确定了该列被敲掉的行编号最大的砖块，该列所有砖块的情况都会被确定。这就意味着以列为阶段进行 DP 是一个不错的选择。

用与上类似的方法定义状态：$dp(i,j,k)$ 表示在第 $j$ 列中被敲掉的砖块中，以 $i$ 为最大行编号，并且在这之前总共敲掉 $k$ 块砖的最大得分。

接下来我们要考虑的问题是，一个状态可以从之前的哪个状态转移而来。

比如下图中的状态 $(2,2)$。

![](https://cdn.luogu.com.cn/upload/image_hosting/abun9qo5.png)

那么，显然这种情况是可行的，因为它有可能构成一个完整的倒三角形：

![](https://cdn.luogu.com.cn/upload/image_hosting/9878fin0.png)

但是这种状态就不可行，因为它有一层缺失：

![](https://cdn.luogu.com.cn/upload/image_hosting/1xoffvts.png)

经过尝试，我们得出了前一列所有状态转移的可行性：

![](https://cdn.luogu.com.cn/upload/image_hosting/jvlxkp6j.png)

经过归纳发现：对于状态 $(i,j)$，所有满足 $0\leq t \leq i+1$ 的状态 $(t,j-1)$ 均可转移，否则不可转移。

而一个状态的收益和花费很容易可以得出来。$(i,j)$ 的花费为 $i$，收益为 $\sum\limits_{k=1}^{i}a(k,j)$。

于是得到转移方程：

$$dp(i,j,k)=\max\limits_{0\leq t \leq i+1}(dp(t,j-1,k-i))+\sum\limits_{k=1}^{i}a(k,j)$$

答案为 $\max(dp(1,n,m),dp(0,n,m))$。（最后一列敲或不敲的情况）

使用 DP 求解即可。时间复杂度为 $O(n^4)$。

对比来看，按列 DP 相较按行 DP 的优势是：按列 DP 可以根据一个信息直接确定一行砖块的状态（敲或不敲）。按行 DP 也不是不能做，只是因为它的信息不足，使得必须使用状态压缩才能进行求解，而 $n$ 的范围又过大，所以我们直接否决了这个做法。

代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define db double
using namespace std;
inline ll read()
{
	ll x = 0; bool op = 0;
	char c = getchar();
	while(!isdigit(c))op |= (c == '-'), c = getchar() ;
	while(isdigit(c))x = (x << 1) + (x << 3) + (c ^ 48), c = getchar();
	return op ? -x : x;
}

const int N = 55;
const int M = 1300;
int n, m;
int a[N][N], sum[N][N], dp[N][N][M];

void In()
{
	n = read(); m = read();
	for(int i = 1; i <= n; i++)
	{
		for(int j = 1; j <= n - i + 1; j++)
		{
			a[i][j] = read();
		}
	}
	return ;
}

void Solve()
{
	for(int j = 1; j <= n; j++)
	{
		for(int i = 1; i <= n; i++)
		{
			sum[i][j] = sum[i - 1][j] + a[i][j]; //预处理收益
		}
	}
	for(int j = 1; j <= n; j++)
	{
		for(int i = 0; i <= n; i++)
		{				
			for(int k = i; k <= m; k++)
			{
				for(int t = 0; t <= i + 1; t++)
				{
					dp[i][j][k] = max(dp[i][j][k], dp[t][j - 1][k - i] + sum[i][j]);
				}
			}
		}
	}
	printf("%d", max(dp[1][n][m], dp[0][n][m]));
	return ;
}

int main()
{
	In();
	Solve();
	return 0;
}
```



---

## 作者：荣一鸣 (赞：27)

题目不难理解，而且很容易就能看出要用dp就是不知道状态转移方程要怎么写，很显然第一排有选择的后效型，不能直接写方程，于是我们需要把三角型翻转

利用一下样例数据
	
    14  15  4   3   23
      33  33  76  2
        2   13  11
          22  23
            31
    
我们存下来的时候是这样的
	
    14 15 4  3  23
    33 33 76 2
    2  13 11
    22 23
    31

然后我们将它旋转90度

	23
    3  2
    4  76 11
    15 33 13 23
    14 33 2  22 31
    
虽然本人的程序不是这样转的，但差不多，这时候我们发现，第一列的数都是可以直接取的，而如果你要取第二列，那么第一列的数是一定要取的了，那么我们就可以用i，j来表示第i行取了前j个这一种状态（而且所有状态都可以这样表示），那么显然，如果有了（i，j）就一定要取（i-1，k）k>=j-1，这就可以进行状态转移了。

	f[i][j][k]（i表示第i行，j表示取前j个，k表示共取了k个）来表示搜索到第i行时的状态。

	f[i][j][k]=max(f[i][j][k],f[i-1][q][k-j])(j-1<=q<=i-1)

整个的转移方程可以这么写
```cpp
for(int i=1;i<=n;i++){
	for(int j=0;j<=i;j++){
    	for(int k=(j+1)*j/2;k<=m;k++){
        	for(int p=max(0,j-1);p<min(k-j+1,i);p++){
            	f[i][j][k]=max(f[i][j][k],f[i-1][p][k-j]+sum[i][j]);
                }
            }
        }
    }
```

旋转的代码也很简单就不单独列了
```
#include<iostream>
#include<cstdio>
#include<iomanip>
#include<algorithm>
#include<cmath>
#include<cstring>
using namespace std;

const int maxn=60;
int n,m,ans;
int mark[maxn][maxn],sum[maxn][maxn];
int f[maxn][maxn*10][maxn];

void dp()
{
    memset(f,-1,sizeof(f));
    f[n][1][1]=mark[1][n];
    f[n][0][0]=0;
    
    for (int j=1;j<=n;j++)
        for (int i=1;i<=(n-j+1);i++)
            sum[j][i]=sum[j][i-1]+mark[i][j];
            
    for (int i=n-1;i>=1;i--)
        for (int j=0;j<=m && j<=(n-i+1)*(n-i+2)/2;j++)
            for (int k=0;k<=j && k<=n-i+1;k++)
            {
                for (int p=max(0,k-1);p<=n-i;p++)
                    if (j>=k && p<=j-k && f[i+1][j-k][p]>=0)
                        f[i][j][k]=max(f[i][j][k],f[i+1][j-k][p]);
                    
                if (f[i][j][k]>=0)
                    f[i][j][k]+=sum[i][k];
                
                //cout<<i<<" "<<j<<" "<<k<<" "<<f[i][j][k]<<endl;
                
                ans=max(ans,f[i][j][k]);
            }
}

int main()
{
    
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;i++)
        for (int j=1;j<=(n-i+1);j++)
            scanf("%d",&mark[i][j]);

    dp();
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：I_AM_HelloWord (赞：20)

楼下状态设的反正我是没看明白，我说一说我的做法吧：

首先我们很容易想到对行进行dp，设dp[i][j][k]表示前i行打到第j列，共打了k次所能得到的最大分数。


可是，很快我们就发现，打第i行第j列是和第j+1打的情况有关系，这时就产生了后效性，


但是我们反过来看，如果我们已经计算后了第j+1列打的情况，那么是不是第j列不会有后效性了？其实第j列打的情况和1...j-1列一点关系都没有啊！那么就行了，


我们可以有一个新的思路：倒过来从n开始对列进行dp，设dp[i][j][k]表示后i列，第i列打到第j行，共打了k次所能得到的最大分数。


那么式子就很好推了：


枚举一个t表示第i+1列打到哪个位置（当然，必须至少从j-1开始）


dp[i][j][k]=max(dp[i+1][t][k-j])+a[j][1]+a[j][2]+.....+a[j][i]（至于max后面的式子弄个前缀和优化就行了）


而其实，当我们计算好dp[i+1][][]时，对于一个i，j，k其dp[i][j][k]就是在dp[i+1][j-1][k-j].....dp[i+1][n-i][k-j]中取一个max，我们完全没有必要在计算第i列的时候再枚举去计算了！我们直接在算出第i+1列时，同时把dp[i+1][j][k]与dp[i+1][j+1][k]取一个max覆盖到dp[i+1][j][k]，那么我们转移的时候就是直接的dp[i][j][k]=dp[i+1][j-1][k-j]+sum...而i的那一维还可以用滚动数组直接优化掉，这时时空复杂度都是最优的了。


当然，还要处理一下j=0的情况，j=0即这一列一个都不选，这个部分还是比较好想的。


参考代码：


```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
template<class T>inline void ChkMax(T &a,T b){if (a<b)a=b;}
const int N=61;
const int M=N*(N+1)>>1;
int n,m,a[N][N],dp[2][N][M];
int read(){
    int x=0,f=1;char ch=getchar();
    while (ch<'0' || ch>'9'){if (ch=='-')f=-1;ch=getchar();}
    while ('0'<=ch && ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return x*f;
}
int main(){
    n=read(),m=read();
    for (int i=1;i<=n;i++)
        for (int j=1;j<=n-i+1;j++)
            a[i][j]=read();
    int ans=0;
    for (int i=n;i>=1;i--){
        int cur=i&1,pre=cur^1,sum=0;
        memset(dp[cur],0,sizeof(dp[cur]));
        for (int j=0;j<=n-i+1;j++)sum+=a[j][i];
        for (int j=n-i+1;j>=0;sum-=a[j--][i])
            for (int k=max(2*j-1,0);k<=m;k++){
                int t=max(0,j-1);
                ChkMax(dp[cur][j][k],dp[pre][t][k-j]+sum);
                ChkMax(ans,dp[cur][j][k]);
                ChkMax(dp[cur][j][k],dp[cur][j+1][k]);
            }
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：H_D_NULL (赞：12)

## 经典DP


------------

### 思考过程

首先，经过观察，我们发现如果一块砖头被敲，那么其上一层与其相邻的两块砖头也必须被敲，这两块砖头又会影响与它们相邻的上层砖头......就会形成以下一个三角形：

![](https://cdn.luogu.com.cn/upload/image_hosting/dkic4fp2.png)

这就相当于DP的一个状态，而且可以预处理，不禁让我们想到了用DP的方法求解。

但是，我们发现敲了多个砖头时，多个三角形可能会产生重叠：

![](https://cdn.luogu.com.cn/upload/image_hosting/dngjkmd9.png)

这样就产生了后效性，不符合动态规划的原则。

难道，只有放弃了吗......

振作起来啊！经过观察，我们可以发现即使三角形有重叠，但它们的轮廓线始终保持某种规律，即可看做这几个三角形轮廓线的重叠：

![](https://cdn.luogu.com.cn/upload/image_hosting/z9br9zcw.png)

所以我们可以以每个点为状态，最终构造出一条合法的轮廓线，最终达到DP的目的。

对于一个点，它的状态只能从他的左边，左下和左上转移而来，具体的状态转移方程会在代码中呈现。

值得注意的是，这条轮廓线可能不连续，所以要利用状态0来保存之前的合法轮廓线（具体见代码）。

下面上代码：

```cpp
#include<bits/stdc++.h>
#define re register
using namespace std;

int n,m;
int v[55][55];
int f[55][55][1505];
int ans;

bool vis[55][55][1505];

int main(){
	ios::sync_with_stdio(false);
	cin>>n>>m;
	for(re int i=1;i<=n;i++){
		for(re int j=1;j<=n-i+1;j++){
			cin>>v[i][j];
			v[i][j]+=v[i-1][j];
		}
	}
	for(re int i=1;i<=n;i++){
		vis[i][0][0]=1; //vis数组记录是否合法（也可不用？但用了肯定没错）
		for(re int j=0;j<=n-i+1;j++){ //用0状态来处理不连续的轮廓线
			for(re int p=1;p<=m;p++){
				if(p-j>0){
					if(vis[i-1][j+1][p-j]){
						vis[i][j][p]=1;
						f[i][j][p]=max(f[i][j][p],f[i-1][j+1][p-j]+v[j][i]);
					}
					if(vis[i-1][j][p-j]){
						vis[i][j][p]=1;
						f[i][j][p]=max(f[i][j][p],f[i-1][j][p-j]+v[j][i]);
					}
				}
				if(vis[i][j-1][p-1]){
					vis[i][j][p]=1;
					f[i][j][p]=max(f[i][j][p],f[i][j-1][p-1]+v[j][i]-v[j-1][i]);
				}
			}
		}
	}
	for(re int i=1;i<=n;i++) ans=max(f[i][1][m],ans); //只有最终到达1层的才是合法的结束状态
	printf("%d",ans);
	return 0;
}
```


---

## 作者：I_AM_HelloWord (赞：10)

题目有时候不能想太复杂了。其实没有必要翻转三角形什么的。

首先我们很容易想到对行进行dp，设dp[i][j][k]表示前i行打到第j列，共打了k次所能得到的最大分数。

可是，很快我们就发现，打第i行第j列是和第j+1打的情况有关系，这时就产生了后效性，

但是我们反过来看，如果我们已经计算后了第j+1列打的情况，那么是不是第j列不会有后效性了？其实第j列打的情况和1...j-1列一点关系都没有啊！那么就行了，

我们可以有一个新的思路：倒过来从n开始对列进行dp，设dp[i][j][k]表示后i列，第i列打到第j行，共打了k次所能得到的最大分数。

那么式子就很好推了：

枚举一个t表示第i+1列打到哪个位置（当然，必须至少从j-1开始）

dp[i][j][k]=max(dp[i+1][t][k-j])+a[j][1]+a[j][2]+.....+a[j][i]（至于max后面的式子弄个前缀和优化就行了）

而其实，当我们计算好dp[i+1][][]时，对于一个i，j，k其dp[i][j][k]就是在dp[i+1][j-1][k-j].....dp[i+1][n-i][k-j]中取一个max，我们完全没有必要在计算第i列的时候再枚举去计算了！我们直接在算出第i+1列时，同时把dp[i+1][j][k]与dp[i+1][j+1][k]取一个max覆盖到dp[i+1][j][k]，那么我们转移的时候就是直接的dp[i][j][k]=dp[i+1][j-1][k-j]+sum...而i的那一维还可以用滚动数组直接优化掉，这时时空复杂度都是最优的了。

当然，还要处理一下j=0的情况，j=0即这一列一个都不选，这个部分还是比较好想的。


参考代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
template<class T>inline void ChkMax(T &a,T b){if (a<b)a=b;}
const int N=61;
const int M=N*(N+1)>>1;
int n,m,a[N][N],dp[2][N][M];
int read(){
    int x=0,f=1;char ch=getchar();
    while (ch<'0' || ch>'9'){if (ch=='-')f=-1;ch=getchar();}
    while ('0'<=ch && ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return x*f;
}
int main(){
    n=read(),m=read();
    for (int i=1;i<=n;i++)
        for (int j=1;j<=n-i+1;j++)
            a[i][j]=read();
    int ans=0;
    for (int i=n;i>=1;i--){
        int cur=i&1,pre=cur^1,sum=0;
        memset(dp[cur],0,sizeof(dp[cur]));
        for (int j=0;j<=n-i+1;j++)sum+=a[j][i];
        for (int j=n-i+1;j>=0;sum-=a[j--][i])
            for (int k=max(2*j-1,0);k<=m;k++){
                int t=max(0,j-1);
                ChkMax(dp[cur][j][k],dp[pre][t][k-j]+sum);
                ChkMax(ans,dp[cur][j][k]);
                ChkMax(dp[cur][j][k],dp[cur][j+1][k]);
            }
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：Lynx (赞：7)

首先一定是要旋转的，楼上的几位dalao已经说的很清楚了，旋转后这一行就可以由前一行的状态转移过来。。

设f[i]j[k]表示一定选第i列前j个数，一共选了k个数的最大得分。

因为选一个(i,j)数,一定将第i行的前j个数都取了，所以容易想到前缀和优化。

f[i][j][k]=max(f[i-1][l][k-j]+s[i][j])(j-1=<l<=i-1)

注意i行可以不选，即j从零开始枚举，c党注意判数组是否越界。（这个很不容易像，会坑50分）

（楼上没有判断越界的情况，他rp好，恰巧卡过去了）

考虑优化：开g数组表示f的倒序最大值，就不用枚举l了，少一重循环，会快很多，初始化较繁琐。

贴一下优化后的代码，不优化的楼上有。


```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
const int N=55;
int n,m,ans,a[N][N],c[N][N],s[N][N],f[N][N][N*(N+1)/2],g[N][N][N*(N+1)/2];
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n-i+1;j++)
            scanf("%d",&a[i][j]);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=i;j++)
            c[i][j]=a[j][n-i+1],s[i][j]=s[i][j-1]+c[i][j];
    memset(g,-1,sizeof(g));
    for(int i=0;i<=m;i++)
        g[0][0][i]=0;
    for(int i=1;i<=n;i++)//行数 
        for(int j=i;j>=0;j--)//列数 
            for(int k=j;k<=m;k++)//一共选了k个 
                if(g[i-1][max(0,j-1)][k-j]>=0)
                {
                    f[i][j][k]=g[i-1][max(j-1,0)][k-j]+s[i][j];
                    g[i][j][k]=max(g[i][j+1][k],f[i][j][k]);
                }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=i;j++)
            ans=max(ans,f[i][j][m]);
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：zzzyc (赞：7)

```cpp
#include<iostream>
using namespace std;
int n,m,maxx,a[55][55],f[55][55][2001];
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n-i+1;j++)
            cin>>a[i][j]; // 读入砖块 
    for(int i=n;i>=1;i--) // 因为没有旋转，此重循环是从右边开始往左边 
    {
        int sum=0;
        for(int j=1;j<=n-i+1;j++)
            sum+=a[j][i]; // 加此行的前缀和 
        for(int j=n-i+1;j>=0;j--)
        {
            for(int k=max(2*j-1,0);k<=m;k++) // 击打次数 
            {
                int cur=max(j-1,0);
                f[i][j][k]=max(f[i][j][k],f[i+1][cur][k-j]+sum); // 一下是三个核心方程(自己也不是很明白) 
                maxx=max(maxx,f[i][j][k]); // 总体意思是：从右到左扫描，看是是往下打比较赚。(借鉴了一下Asia代码)
                f[i][j][k]=max(f[i][j][k],f[i][j+1][k]); // 还是打这层比较赚，在更新就好了。(确定正确元素瞎搞的)
            } //转移的方法就是确定了几个元素和无后效性的方法，不断瞎搞such as +1 -1试一试就试出来了，有助于理解 
            sum-=a[j][i];
        }
    }
    cout<<maxx;
}
```

---

## 作者：Max_Leo (赞：3)

[传送门](https://www.luogu.org/problem/P2291)

首先这是一道不折不扣的**DP**题

可以发现这道题和P1216数字三角形差不多 原题是从上往下找一条路使权值最大，初步构造：dp[i][j][k]表示取第i行第j个使共取了k个的最大权值，但我们会发现会有重复节点，不符合无后效性。

so，我们换种思路把原来的三角形逆时针旋转90°，拿样例为例
![](https://cdn.luogu.com.cn/upload/image_hosting/mcz2cr5b.png)

这样就变成了从左往右打,而此时只要保证每行所打到的最后的斜上方(i-1,j-1),已经被打过就好了

所以就可以推出动态转移方程dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-k][p]+sum[i][k])这里sum[i][k]表示第i行前k个数之和

附上AC代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,a[60][60];
int s[60],sum[60][60];
int dp[60][600][60];
int main()
{
    cin >> n >> m;
    int ans=-1;
    for(int i=1;i<=n;i++)
		for(int j=i;j<=n;j++)
			cin >> a[j][i];
    for(int i=1;i<=n;i++)
		for(int j=1;j<=i;j++)
			sum[i][j]=sum[i][j-1]+a[i][j];
    for(int i=1;i<=n;i++)
		s[i]=s[i-1]+i;
    memset(dp,-1,sizeof(dp));
    dp[0][0][0]=0;
    for(int i=1;i<=n;i++)
        for(int j=0;j<=min(m,s[i]);j++)
            for(int k=0;k<=min(i,j);k++)
			{
                for(int p=max(k-1,0);p<i&&s[p]<=j-k;p++)
                    dp[i][j][k]=max(dp[i][j][k],dp[i-1][j-k][p]+sum[i][k]);
                ans=max(ans,dp[i][j][k]);
            }
    cout << ans;
    return 0;
}
```
注：k=0时需要特殊处理

---

## 作者：姬小路秋子 (赞：3)

把读入的矩阵逆时针旋转45度。
如输入样例
```
1 1 1 1
1 2 1
1 1
1
```
就会变成
```
1
1 1
1 2 1
1 1 1 1
```
然后此时你发现，旋转过的矩阵里如果选某一个数那么它左边和左上的数都必选。
所以设f[i][j][k]为到了第i行j列，点了k个技能的最大代价，那么它的转移方程即为f[i][j][k]=max(f[i-1][ii][k-j])+a[i][1..j] (j-1<=ii<=i-1)。
但是j=0的情况坑了我好久T_T
~~这题应该还是挺容易的，毕竟我秒了这题~~
代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,i,j,ii,k,t,a[101][101],ans,f[101][101][501],b[101][101];
int main(){
    scanf("%lld%lld",&n,&m);
    for(i=1;i<=n;i++){
        for(j=1;j<=n-i+1;j++){
            scanf("%lld",&t);
            a[n-j+1][i]=t;
        }
    }
    for(i=1;i<=n;i++)
     for(j=1;j<=i;j++)b[i][j]=b[i][j-1]+a[i][j];
    for(i=1;i<=n;i++)
     for(j=1;j<=n;j++)
      for(k=0;k<=m;k++)
       if(j>i||j*(j+1)>k||i*(i+1)/2-(i-j)<k)f[i][j][k]=-1000000000000; 
    f[0][0][0]=0;   
    for(i=1;i<=n;i++)
     for(j=0;j<=i;j++)
      for(k=j*(j+1)/2;k<=min(m,i*(i+1)/2);k++)
       for(ii=j-1;ii<=i-1;ii++)
        //if(ii*(ii+1)>=k-j&&i*(i-1)/2-(i-1-ii)<=k-j)
         f[i][j][k]=max(f[i][j][k],f[i-1][ii][k-j]+b[i][j]);
    for(i=1;i<=n;i++)
     for(j=1;j<=i;j++)
      for(k=0;k<=m;k++)ans=max(ans,f[i][j][k]);
    printf("%lld",ans);      
}

```

---

## 作者：ysner (赞：2)

咦，我的程序0ms跑过，还是唯一的rank 1?

于是，我高兴的决定过来分享我的思路。。。

这题是动态规划题,它的特殊之处在于它的状态。由于需要先打掉第 i 行第 j 块和第 j+1块壁垒才能摧毁第 i 行第 j 块壁垒,所以与第 i 行第 j 块壁垒有关的并不是单纯的行或列,而是斜行。如上图,我们将 n 层壁垒变成 n 斜行壁垒,那么打掉第 i 斜行第 j 块壁垒就要先打掉第 i 行第 j-1 块壁垒和第 i-1 行第 j-1 块壁垒,因此转移如下 ：

dp[i,j,k]表示摧毁从第 1 斜行到第i 斜行第 j 块中的 k 块,并且第 i 行第 j 块必须被摧毁获得的最大积分,s[j]表示第 1 到 j 块的分数和,dp[i][j][k]=max(dp[i][j+1][k+1]-w[i][j+1],dp[i-1][j-1][k-j]+s[j]);边界是 f[i,0,k]=0。

```cpp
#include<iostream>
#include<cmath>
#include<cstring>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#define il inline
#define re register
#define ll long long
#define fp(i,a,b) for(re int i=a;i<=b;i++)
#define fq(i,a,b) for(re int i=a;i>=b;i--)
using namespace std;
const int N=50+5,M=50*(50+1)/2+5;
int s[N]={},w[N][N]={},dp[N][N][M]={};
il int gi()
{
   int x=0;
   short int t=1;
   char ch=getchar();
  while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();
  if(ch=='-') t=-1,ch=getchar();
  while(ch>='0'&&ch<='9') x=x*10+ch-48,ch=getchar();
  return x*t;
}
int main()
{
    re short n,m;
//    freopen("destroy.in","r",stdin);
//    freopen("destroy.out","w",stdout);
    n=gi(),m=gi();
    fp(i,1,n)
        fp(j,i,n)
          w[j][i]=gi();
    re short mk=0;
    re int ans=0;
    fp(i,1,n)//行数
    {
        fp(j,1,i)//列数
        s[j]=s[j-1]+w[i][j];//前缀和优化
        re short j=i,mk=min(m,short((i-1)*i/2))+j;//看能不能敲到这一行
        do
        {
            fp(k,j*(j+1)/2,mk)//敲不到相当于跑了几个判断
            {
                dp[i][j][k]=max(dp[i][j+1][k+1]-w[i][j+1],dp[i-1][j-1][k-j]+s[j]);
            }
            ans=max(ans,dp[i][j][min(m,mk)]);
        }
        while(--mk,--j);
        fp(k,1,mk)
        dp[i][0][k]=dp[i][1][k+1]-w[i][1];//去重
        ans=max(ans,dp[i][0][min(m,mk)]);//
    }
    printf("%d\n",ans);
//    fclose(stdin);
//    fclose(stdout);
}

```

---

## 作者：H15teve (赞：2)

三角形旋转版cpp代码。

旋转过来之后，只需在上一行的j-1列之后找最大值（反正肯定满足），然后加上这一行的和（前缀和搞定）

j=0的确坑了好久···




```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <cstring>
#include <cmath>
using namespace std;
int n,m,a[51][51],f[52][52][1300],ans=-1;
int main()
{
    scanf("%d%d",&n,&m);
    for (int i=n;i>=1;i--)
        for (int j=1;j<=i;j++)
            scanf("%d",&a[n+1-j][n+1-i]);
    for (int i=1;i<=n;i++)
        for (int j=2;j<=i;j++)
            a[i][j]+=a[i][j-1];
    for (int i=1;i<=n;i++)
        for (int j=0;j<=i;j++)
            for (int k=j*(j+1)/2;k<=i*(i-1)/2+j;k++)
                for (int l=j-1;l<i;l++) if(f[i-1][l][k-j]+a[i][j]>f[i][j][k]) f[i][j][k]=f[i-1][l][k-j]+a[i][j];
    for (int i=1;i<=n;i++)
        for (int j=1;j<=i;j++)
            ans=max(ans,f[i][j][m]);
    printf("%d",ans);
    return 0;
}
```

---

## 作者：66666a (赞：2)

前一封题解的格式好像有些问题，还有个小错误，请管理员帮忙删除

这题真的难

事实上

我们可以这样划分状态

(由于格式问题，请自行推成三角形）

4
3 4
2 3 4
1 2 3 4

（同数字算一个状态，感性理解）

显然，若要取图中第I行自下往上数第j个数，必须要取前一个状态自下往上j-1个数及更多的数

所以，我们可以设f[I][j][k]为前第i个状态，自下往上取了j个，共取了k个

转移方程为f[I][j][k]=max{f[I-1][t][k-j]}+a[n-j+1][i-j+1](max(j-1,0)<=t<=I-1)

在每个状态中找一个最优的即可

代码如下：

```cpp
#include<cstdio>
#include<string.h>
#include<algorithm>
using namespace std;
#define ll long long
#define rt register int
#define reep(i,x,y) for(rt i=(x);i<(y);++i)
#define per(i,x,y) for(rt i=(x);i>=(y);--i)
#define rep(i,x,y) for(rt i=(x);i<=(y);++i)
#define travel(i,x) for(rt i=h[x];i;i=pre[i])
const int N = 52, M = 502;
int n, m, a[N][N], f[N][N][M], ans;
int main() {
    scanf("%d%d", &n, &m);
    per(i, n, 1) rep(j, 1, i) scanf("%d", &a[i][j]), a[i][j] += a[i+1][j+1];
    memset(f, 0xc0, sizeof f);
    f[0][0][0] = 0;
    rep(i, 1, n)
    {
        rep(k, 0, m) f[i][0][k] = f[i-1][0][k];
        rep(j, 0, i) rep(k, j, m){
            rep(t, max(j-1, 0), i-1) f[i][j][k] = max(f[i][j][k], f[i-1][t][k-j]);
            f[i][j][k] += a[n-j+1][i-j+1]; 
            ans = max(ans, f[i][j][k]);
        }
    }
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：lxyguise (赞：0)

把三角形旋转，变成

4

3 7

2 2 3

2 8 2 49

这样条件就变成了取(i,j)时，要取(i,1~j)和(i-1,1~j-1)

用f[i][j][k]表示第i列，第j行的数被取，且共取k个数的最优方案。

这样时间为O(n^2*m)，空间O(n^2*m)，效率很高！效率很高！效率很高！ 

```cpp
#include <bits/stdc++.h>

using namespace std;

int a[51][51], n, m, f[51][51][2501], ans;

int main()
{
    cin >> n >> m;
    
    for (int i = 1; i <= n; i ++)	
    {
        for (int j = n; j >= i; j --)
        cin >> a[j][i];
        
    }
    for (int i = 1; i <= n; i ++)
    {
        for (int j = 1; j <= i; j ++)
        a[i][j] += a[i][j - 1];
    }
    for (int i = 1; i <= n; i ++)
    {
        for (int j = 0; j <= i; j ++)
        {
            for (int k = (j + 1) * j / 2; k <= i * (i - 1) / 2 + j; k ++)
            {
                for (int l = j - 1; l < i; l ++)
                 f[i][j][k] = max(f[i][j][k], f[i - 1][l][k - j] + a[i][j]);
            }
        }
    }
    for (int i = 1; i <= n; i ++)
    	for (int j = 0; j <= i; j ++)
     		ans = max(ans, f[i][j][m]);
   		cout << ans << endl;
    
		return 0;
}
```


---

## 作者：cold_cold (赞：0)

 [安利一波博客](https://www.cnblogs.com/cold-cold/p/10166498.html)

直接用题目中三角形

我们发现无论是从上到下还是从下到上DP都会有后效性

这时我们发现第i列的情况只和第i+1列有关

于是我们产生了从右向左DP的思路

到这为止我的想法，就开始与别人不同了

我用f[i][j][k]表示，敲掉第i行第j列的那个块，和之前的k-1个块所能得到的最大分数

用ji[j][[k]表示，当前列的前一列j-n列敲掉k个块所能得到的最大分数

用滚动数组变为ji[k]方便书写

转移的话就拿``` f[j][i][k]=max(ji[k-j]+s[j][i],f[j][i][k]); ```
来转移

但注意要特殊处理j=0的情况

```cpp
for(int k=0;k<=m;k++) f[0][i][k]=ji[k];
```

总的来说此题细节极多，较好的DP题

实现如下：
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <queue>
#include <stack>
#include <vector> 
using namespace std;
inline int read()
{
    register int a(0),p(1);register char ch=0;
    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
    if(ch=='-') p=-1;
    while(ch>='0'&&ch<='9')a=a*10+ch-48,ch=getchar();
    return a*p;
}
const int N=60,M=2010;
int n,m,a[N][N],s[N][N],f[N][N][M],ji[M],ans=0;
int main()
{
    // freopen("input","r",stdin);
    // freopen("output","w",stdout);
    n=read(),m=read();
    for(int i=1;i<=n;i++) for(int j=n;j>=i;j--) a[i][j]=read();
    for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) s[j][i]=s[j-1][i]+a[j][i];
    memset(f,-1,sizeof(f));
    for(int i=0;i<=n;i++) for(int j=0;j<=m;j++) f[0][i][j]=0;
    for(int i=1;i<=n;i++)
    {
    	memset(ji,0,sizeof(ji));
        for(int j=i;j>=1;j--)
        {
        	for(int k=0;k<=m;k++) ji[k]=max(ji[k],f[j-1][i-1][k]);
        	for(int k=j;k<=m;k++)
				if(f[j-1][i-1][k-j]!=-1)
	            {
	                f[j][i][k]=max(ji[k-j]+s[j][i],f[j][i][k]);
	                ans=max(ans,f[j][i][k]);
	            }
		}
        for(int k=0;k<=m;k++) f[0][i][k]=ji[k];
    }
    printf("%d",ans);
    return 0;
}

```

---

## 作者：翠竹叶飞 (赞：0)

Dp.
将砖块整理成直角三角形

2 2 3 4

8 2 7
2 3
49
则第i行第j列的数可以被取当且仅当第i-1行第j列和第i-1行第j+1列的数都被取。

因此可以从右到左，一列一列的转移状态。

F[i][j][k]表示第i列，第j行的数被取，且共取k个数的最优方案。

F[i][j][k]=max(F[i+1][x][k-j])+sigma(a[1][i]…a[j][i]).(x>=j-1).

注意m的数据范围，较原题修改过。

时间为O(n^3\*m) 这样已经做完了，但仍可以优化。

可以用s[j][i]前缀和优化掉sigma(a[1][i]…a[j][i])

用g[i][j][k]表示max(f[i][j][k]..f[i][n-i+1][k])

这样时间为O(n^2\*m)，空间O(n^2\*m)，效率极高，已无法继续优化。


```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#define INF -0x7f7f7f7f
using namespace std;
int n,m,i,j,k,l,ans;
int a[51][51],s[51][51]; //prefix
int f[51][51][1300],g[51][51][1300]; //1300 > 50*51/2
int main()
{
    memset(f,INF,sizeof(f));
    memset(g,INF,sizeof(g));
    scanf("%d%d",&n,&m);
    for (i=1; i<=n; i++)
      for (j=1; j<=n-i+1; j++)
        scanf("%d",&a[i][j]);
    for (i=1; i<=n; i++)
      for (j=1; j<=n-i+1; j++)
        s[i][j]=s[i-1][j]+a[i][j];
    f[n][1][1]=a[1][n];
    g[n][1][1]=a[1][n]; g[n][0][1]=a[1][n];
    for (i=1; i<=n; i++) g[i][0][0]=0; //init    g数组
    for (i=n-1; i>=1; i--)
      for (k=1; k<=m; k++) //tot num
      {
          f[i][0][k]=g[i+1][0][k];
        for (j=1; j<=n-i+1; j++) //the number in each colume
        {
            if (j>k) break; //judge不可能的情况(一列中的个数>总数)
            int tmp=g[i+1][j-1][k-j];
              if (tmp>INF) f[i][j][k]=tmp+s[j][i];
        }
        g[i][n-i+1][k]=f[i][n-i+1][k];
        for (j=n-i; j>=0; j--)
          g[i][j][k]=max(g[i][j+1][k],f[i][j][k]);
      }      
    for (i=1; i<=n; i++) ans=max(ans,g[i][0][m]);
    printf("%d",ans);
    return 0;
}

```

---

## 作者：Skywalker_David (赞：0)

这个打砖头是很经典的题目。

一开始想着在题目给的形状上dp，结果发现这样的话会有三角形重合现象也就是动规有了后效性。

消除后效性要么转换状态，要么在状态里记录一下取数的情况。记录取数的情况，状压dp？别开玩笑了我直接搞不了。

那么只能转换一下，上网上看了别人的方法，把三角形倒过来了！

比如说样例：

2 2 3 4

8 2 7
2 3
49
倒过来之后——>

4
3 7
2 2 3
2 8 2 49

那么每一点只能由左边的点转移过来，和左上角一直到上一行末尾的数转移过来。

如第四行第2个数可以从第三行的1，2，3个数转移过来。为什么？再回去看看题吧……

那么就可以开状态f[i,j,k]表示取到i,j这个位置，取了k个数的最大得分。

那么如果取这个数，只能是a[i,1]+a[i,2]+...+a[i,j](这个预处理出来)+f[i-1,p,k-j]  其中p取j-1到i-1。如上述。

还应该注意每行都应该计算f[i,0,k]表示这一行不取数的答案。

```delphi

var a:array[0..55,0..55] of longint;    
    i,j,n,m,k,l,max:longint;    
    f:array[-1..55,-1..55,-1..1300] of longint;    
begin    
 readln(n,m);    
 for i:=1 to n do    
  for j:=1 to n-i+1 do    
   read(a[i,j]);    
 for i:=n downto 1 do    
  for j:=0 to n-i+1 do    
   for k:=2*j-1 to m do    
    begin    
     max:=0;    
     for l:=j-1 to n-i+1 do    
      if f[i+1,l,k-j]>max then    
       max:=f[i+1,l,k-j];    
     f[i,j,k]:=max;    
     for l:=1 to j do    
      inc(f[i,j,k],a[l,i]);    
    end;    
 for i:=1 to n do    
  for j:=0 to n-i+1 do    
   if f[i,j,m]>max then    
    max:=f[i,j,m];    
 writeln(max);    
end.  

```

---

## 作者：ZS_FangS (赞：0)

```
/*快乐AC*/
#include<iostream>
#include<cmath>
#include<cstring>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#define il inline
#define re register
#define ll long long
#define fp(i,a,b) for(re int i=a;i<=b;i++)
#define fq(i,a,b) for(re int i=a;i>=b;i--)
using namespace std;
const int N=50+5,M=50*(50+1)/2+5;
int s[N]={},w[N][N]={},dp[N][N][M]={};
il int gi()
{
   int x=0;
   short int t=1;
   char ch=getchar();
  while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();
  if(ch=='-') t=-1,ch=getchar();
  while(ch>='0'&&ch<='9') x=x*10+ch-48,ch=getchar();
  return x*t;
}
int main()
{
    re short n,m;
//    freopen("destroy.in","r",stdin);
//    freopen("destroy.out","w",stdout);
    n=gi(),m=gi();
    fp(i,1,n)
        fp(j,i,n)
          w[j][i]=gi();
    re short mk=0;
    re int ans=0;
    fp(i,1,n)//行数
    {
        fp(j,1,i)//列数
        s[j]=s[j-1]+w[i][j];//前缀和优化
        re short j=i,mk=min(m,short((i-1)*i/2))+j;//看能不能敲到这一行
        do
        {
            fp(k,j*(j+1)/2,mk)//敲不到相当于跑了几个判断
            {
                dp[i][j][k]=max(dp[i][j+1][k+1]-w[i][j+1],dp[i-1][j-1][k-j]+s[j]);
            }
            ans=max(ans,dp[i][j][min(m,mk)]);
        }
        while(--mk,--j);
        fp(k,1,mk)
        dp[i][0][k]=dp[i][1][k+1]-w[i][1];//去重
        ans=max(ans,dp[i][0][min(m,mk)]);//
    }
    printf("%d\n",ans);
//    fclose(stdin);
//    fclose(stdout);
}
```

---


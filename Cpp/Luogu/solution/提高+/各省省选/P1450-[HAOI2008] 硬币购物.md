# [HAOI2008] 硬币购物

## 题目描述

共有 $4$ 种硬币。面值分别为 $c_1,c_2,c_3,c_4$。

某人去商店买东西，去了 $n$ 次，对于每次购买，他带了 $d_i$ 枚 $i$ 种硬币，想购买 $s$ 的价值的东西。请问每次有多少种付款方法。

## 说明/提示

#### 数据规模与约定

* 对于 $100\%$ 的数据，保证 $1 \leq c_i, d_i, s \leq 10^5$，$1 \leq n \leq 1000$。

## 样例 #1

### 输入

```
1 2 5 10 2
3 2 3 1 10
1000 2 2 2 900
```

### 输出

```
4
27
```

# 题解

## 作者：I_AM_HelloWord (赞：217)

好巧妙的一道dp题！

如果我们就赤裸裸的多重背包那么就是O(10^5\*10^5\*1000)

一周的时间都运行不完（手动滑稽）！

那么怎么办呢？如果没有硬币数量的限制那就多好啊？直接一个完全背包预处理，然后O(1)输出就好了

可是有了硬币的限制怎么办？我们先考虑一个简单一点的情况：只有第一个硬币有限制。

如果我们用类似前缀和的思想（术语叫差分），我们先完全背包预处理好无限制的情况，拿dp[tot]减去dp[tot-c[i]\*(d[i]+1)]就是我们所需的方案数。

这是为什么呢？为什么要弄个c[i]\*(d[i]+1)？其实我们可以这样想，无限制的情况就是没有那个di，而有限制时，不应该计入答案的方案数就是把c[i]这个硬币取了超过d[i]次，对吧？那么我们手动先取出d[i]+1个c[i]的硬币，然后剩下的价值弄个完全背包，这时就是我们所不需要的答案， 把它减掉就行了。

那么对于4个（或更多）的硬币有限制，我们就逐一把4个硬币单独限制的方案数减掉，这时可能会减重了（即同时两个硬币有限制的情况减了两次），所以我们再把4个硬币两两同时限制的方案数加上，可能又加重了，再把4个硬币33同时限制减掉，最后加上4个同时限制的方案数就是我们所需的答案。这就是大名鼎鼎的容斥原理啊！写成位运算就很优美了！

方案数会爆int哟。

参考代码（和楼下不太一样，0表示满足限制，1表示不满足限制）：

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#define REP(i,a,b) for (int i=(a);i<=(b);i++)
#define in(a) scanf("%d",&(a))
using namespace std;
const int N=100001;
long long dp[N+10];
int c[5],d[5];
int main(){
    REP(i,1,4)in(c[i]);
    dp[0]=1;
    REP(i,1,4)REP(j,c[i],N)dp[j]+=dp[j-c[i]];
    int T;in(T);
    while (T--){
        int sum;long long res=0;
        REP(i,1,4)in(d[i]);
        in(sum);
        REP(i,0,15){
            long long t=sum;
            int cnt=0;
            REP(j,1,4)if ((i>>(j-1))&1)t-=c[j]*(d[j]+1),cnt^=1;
            if (t<0)continue;
            if (!cnt)res+=dp[t];else res-=dp[t];
        }
        printf("%lld\n",res);
    }
    return 0;
}
```

---

## 作者：LiRewriter (赞：114)

楼下写的蛮清楚的...这里在下再解释一下这个容斥是怎么来的吧

首先，我们把它当成一个完全背包，处理出来一个dp数组存储方案数，转移方程$dp[i] += dp[i - v[i]]$，复杂度是$O(4 \times maxs)$的。

然后不妨来思考一下，这里的完全背包含义是什么？含义是我们可以无限制的放硬币。

那么这里其实差的就是那个限制。所以先来考虑一个弱化版本：

如果只有一种硬币，那么情况如何呢？这里的方案数包含了一部分超过$d$个的。譬如，此时可能求得的结果是带$d + 1$枚，$d + 2$枚...只要把这一部分减去就可以了。因此直接删掉合理的情况，那剩下的就是不合理的，而不合理的情况也就是一个容量$s - (d + 1) \times v$的背包，这个就是不合理的，减去这部分不合理的就是合理的，换言之`ans -= dp[s - (d + 1) \* v`

而多种硬币呢？其实这就是一个容斥问题了。

所以底下这个是一定能过的：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
typedef long long LL;
#define MAXN 100003
LL dp[MAXN], c[5], d[5], s;
inline int f(int id) {
    return c[id] * (d[id] + 1);
}
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    dp[0] = 1;    
    cin>>c[1]>>c[2]>>c[3]>>c[4];
    for(int i = 1; i <= 4; ++i)
        for(int j = c[i]; j <= MAXN; ++j)
                dp[j] += dp[j - c[i]];
    int T;
    cin>>T;
    while(T--) {
        cin>>d[1]>>d[2]>>d[3]>>d[4]>>s;
        LL ans = dp[s];
        if(s >= f(1)) ans -= dp[s - f(1)];
        if(s >= f(2)) ans -= dp[s - f(2)];
        if(s >= f(3)) ans -= dp[s - f(3)];
        if(s >= f(4)) ans -= dp[s - f(4)];
        if(s >= f(1) + f(2)) ans += dp[s - f(1) - f(2)];
        if(s >= f(1) + f(3)) ans += dp[s - f(1) - f(3)];
        if(s >= f(1) + f(4)) ans += dp[s - f(1) - f(4)];
        if(s >= f(2) + f(3)) ans += dp[s - f(2) - f(3)];
        if(s >= f(2) + f(4)) ans += dp[s - f(2) - f(4)];
        if(s >= f(3) + f(4)) ans += dp[s - f(3) - f(4)];
        if(s >= f(1) + f(2) + f(3)) ans -= dp[s - f(1) - f(2) - f(3)];
        if(s >= f(1) + f(2) + f(4)) ans -= dp[s - f(1) - f(2) - f(4)];
        if(s >= f(1) + f(3) + f(4)) ans -= dp[s - f(1) - f(3) - f(4)]; 
        if(s >= f(2) + f(3) + f(4)) ans -= dp[s - f(2) - f(3) - f(4)];
        if(s >= f(1) + f(2) + f(3) + f(4)) ans += dp[s - f(1) - f(2) - f(3) - f(4)];
        cout<<ans<<endl;
    }
    return 0;
}
```
~~打表是一种浪漫，不爽不要看~~

当然这样太不优雅了，看到大佬们的操作才发现前几天好像在lrj上看到一个神奇的东西叫做位运算枚举子集：

`for(int S0 = S; S0; S0 = (S0 - 1)&S)`

这个的含义不理解的话可以去举一个例子手动模拟一下

然后我们可以将while内的部分大大简化：

```cpp
for(int S0 = S; S0; S0 = (S0 - 1) & S) {
            LL qwq = 0, tmp = 0;
            for(int j = 1; j <= 4; ++j) 
                if((S0 >> j - 1) & 1)
                    qwq ^= 1, tmp += f(j);
            if(s >= tmp) 
                ans = qwq ? ans - dp[s - tmp] : ans + dp[s - tmp];
        }
```
嗯，位运算真有趣啊

总之个人感觉这是一道很有趣的DP，也是一个非常神奇的思想。


---

## 作者：Y_B_Y (赞：92)

一道神奇的dp题,注意用longlong

首先如果同多重背包一个一个算是肯定T的 ~~(除非你有神仙的卡常技术)~~ 

我们知道题目是要求我们用**每种种类的个数有限的硬币**来购买s的价值的东西的方法数,那么如果我们换一种思路,我们发现 **满足要求的方法数=无限种的方法数-不满足要求(即超过限制)方法数**(比如无限制有5种方法,其中3种超过了题目的限制,那么满足的就有2种)

我们**先求无限种的方法数**,我们设$f[i]$为个数无限的硬币来购买$i$的价值的东西的方法数,所以**无限种的方法数$f[s]$**

再来求**不满足要求的(即超过限制)方法数**,我们先来看第$1$种硬币超过要求的方法数,我们可以先强制支付$(d[1]+1)$个硬币,那么后面无论怎么支付第$1$种硬币都是超过要求的,我们知道后面要支付的钱为$s-c[1]* (d[1]+1)$元(就是减掉强制支付的),所以可以得到

第$1$种硬币超过要求的方法数=强制支付$(d[1]+1)$个硬币的方法数(只有一种方法)*支付$s-c[1]* (d[1]+1)$元的方法数=支付$s-c[1]* (d[1]+1)$元的方法数

即

**第$1$种硬币超过要求的方法数$=f[s-c[1]* (d[1]+1)]$**

同理,第$2$种硬币超过要求的方法数=$f[s-c[2]* (d[2]+1)]$,以此类推

但是我们直接用$f[s]$减掉他们得出的并不是正确的答案,因为我们看计算第$1$种硬币超过要求的方法数时,对于要支付的$s-c[1]* (d[1]+1)$元来说,并没有要求第二种硬币不超过要求,**所以第一种超过要求时,第二种硬币可能同时也超过要求**,同理,第二种超过要求时,第一种硬币可能同时也超过要求,这样就产生了重复(计算了两次一二同时超过要求的方法数),所以我们要再**加回去一次一二同时超过要求的方法数**

为了方便计算,我们用**A表示第$1$种硬币超过要求的方法的集合**,**B来表示硬币2的**

可能有没了解过集合的同学,所以我在这里简单说一下:

1.集合由一个或多个确定的元素所构成的整体,可以看作是“一堆东西”，集合里的“东西”则称为元素

2.交集：由属于A且属于B的元素组成的集合,就是两集合相交的部分

3.并集：由所有属于集合A或属于集合B的元素所组成的集合,就是A和B所有的元素组成的集合(重复元素的算作一个),如图



![](https://cdn.luogu.com.cn/upload/image_hosting/t7hq1nt4.png)

4.容斥原理:$1.card(A∪B)=card(A)+card(B)-card(A∩B)$(card(X)为X集合元素个数,看图理解)

集合运算满足分配对偶律：A∩(B∪C)=(A∩B)∪(A∩C)；A∪(B∩C)=(A∪B)∩(A∪C),所以

如果我们再加入一个集合C,那么(这里省略card())$2.A∪B∪C=(A∪B)∪C=A+B+C-A∩B-A∩C-B∩C+A∩B∩C$,直接算或看图理解

![](https://cdn.luogu.com.cn/upload/image_hosting/q9j5tny9.png)

看完了上述知识点,我们可以**开始计算**了

**对于第一种和第二种硬币,$f[s]$应该减掉的是$card(A∪B)$即$card(A)+card(B)-card(A∩B)$**

进而对**所有种类的硬币**(将第3,4种硬币设为C,D),根据满足要求的方法数(即**答案)=无限种的方法数-不满足要求(即超过限制)方法数**

所以,

**答案**
$=f[s]-card(A∪B∪C∪D)$

$=f[s]-card(A)-card(B)-card(C)-card(D)$

$+card(A∩B)+card(A∩C)+card(A∩D)+card(B∩C)+card(B∩D)+card(C∩D)$

$-card(A∩B∩C)-card(A∩B∩D)-card(A∩C∩D)-card(B∩C∩D)$

$+card(A∩B∩C∩D)$

其中$card(X∩Y∩...)$的计算方法,设card内共$n$给集合,第$i$个集合代表硬币$i$,**所以令$K=c[1]*(d[1]+1)+c[2]*(d[2]+1)+...+c[n]*(d[n]+1)$,当$k≤s$时$card(X∩Y∩...)=f[s-K]$,$K>s$时,$card(X∩Y∩...)=0$**

我们还可以发现,当card(X∩Y∩...)内集合的个数为**奇数**时前面的符号为$'-'$,为**偶数**时前面的符号为正,所以在程序中我们枚举所有的card()时可以通过这个来**判断符号**

怎么枚举,可以用**二进制数来枚举**(第i位为0表示这个card()中并没有硬币i,为1则有),从1(0001)枚举到15(1111)就可以了,**如果你不会这种方法,直接把所有的算card的算式打上去计算结果也可以**

上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N=1e5+5;
ll f[N],c[10],d[10],s;//变量意义看文章和题目
inline long long read()
{
    char c=getchar();long long sum=0,f=1;
    while(!(c>='0'&&c<='9')) {if(c=='-') f=-1;c=getchar();}
    while(c>='0'&&c<='9') {sum=((sum<<1)+(sum<<3))+(c-'0');c=getchar();}
    return sum*f;
}
int main()
{
	c[1]=read();c[2]=read();c[3]=read();c[4]=read();
	int n=read();
	f[0]=1;
	for(int i=1;i<=4;i++)
	{
		for(int j=c[i];j<=1e5;j++) f[j]+=f[j-c[i]];
	}//完全背包
	while(n--)
	{
		for(int i=1;i<=4;i++) d[i]=read();
		s=read();
		ll ans=f[s];
		for(int i=1;i<=15;i++)//枚举
		{
			ll k=0,num=0;//num用来算card内集合数量
			for(int j=0;j<4;j++)
			{
				if(i&(1<<j)) //判断第j为是否为1
				{
					num++;
					k+=c[j+1]*(d[j+1]+1);//算k
				}
			}
			ll fl=1;
			if(num%2) fl=-1;//判断符号
			if(s>=k) ans+=fl*f[s-k];//如果k满足条件,加(减)上
		}
		printf("%lld\n",ans);//输出
	}
	return 0;
}
```


---

## 作者：FlashHu (赞：61)

我实在是太弱了，第一次正儿八经写背包DP，第一次领会如此巧妙的容斥原理的应用。。。。。。

对每次询问都做一遍多重背包，显然T飞，就不考虑了

关键就在于每次询问如何利用重复的信息

我这么弱，当然是想不到容斥原理的啦

暂且先当成完全背包，每种硬币可使用无限次，预处理$f$数组，$f[i]$等于买价值$i$的东西的总方案数

然后就要从中减去不合法的。首先肯定会有一种硬币超额使用，第$j$中硬币等于说强制选了$d_j+1$个，剩下的依然随便选，那么第
$j$种硬币超额的不合法的方案数等于$f[s-(d_j+1)*c_j]$，于是从答案里减去$\sum_{j=1}^4f[s-(d_j+1)*c_j]$

还要注意，第一种第二种都超额、第一种第三种都超额、第一种第四种都超额、第二种第三种都超额、第二种第四种都超额、第三种第四种都超额的方案在上一步中都被减了两次，所以额外都加一次回来。。。。。。（接着把容斥做下去就不说了）

复杂度降到$O(4maxs+4×2^4tot)$，轻松通过

注意开longlong就好啦
```cpp
#include<cstdio>
#define R register
typedef long long LL;
const int S=100009;
LL f[S]={1ll};
int main(){
	R int c[4],d[4],tot,i,j,k,now,s,ss,tmp;
	R LL ans;
	for(j=0;j<4;++j)scanf("%d",&c[j]);
	scanf("%d",&tot);
	for(j=0;j<4;++j)
		for(i=c[j];i<S;++i)
			f[i]+=f[i-c[j]];//完全背包预处理
	while(tot--){
		for(j=0;j<4;++j)scanf("%d",&d[j]);
		scanf("%d",&s);
		ans=f[s];
		for(ss=1;ss<=15;++ss){//二进制数枚举集合，容斥
			now=s;
			for(tmp=ss,j=k=0;tmp;tmp>>=1,++j)
				if(tmp&1)k^=1,now-=(d[j]+1)*c[j];
                //注意k的作用，判断奇偶
			if(now>=0)k?ans-=f[now]:ans+=f[now];
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：Mathison (赞：38)

第一眼看到显然是一个多重背包

也很显然复杂度不对……

我们可以用另一种思想

## 差分

举一个很简单的例子：区间加减 // ~~其实没有这样的表达但是这样好理解~~

$$[2,+\infty]-(3,+\infty]=[2,3]$$

显然我们只需求出$[2,+\infty]$和$(3,+\infty]$就能算出$[2,3]$

那这道题能不能这样？

我们可以用**完全背包**先预处理出没有钱数限制是的所有情况

再把所有不合法的情况（即某种硬币超过了所给数量）减去，最后得到的就是答案

$$ans=f[s]-\sum^4_{i=1}{f[s-c_i*(d_i+1)]}$$

下面一个问题：$\sum^4_{i=1}{f[s-c_i*(d_i+1)]}$要怎样计算呢？

肯定不是直接累加，因为有可能第1种物品超过限制的同时，第二种物品数量也超过了限制，如果直接累加会把这种情况计算两次，显然是不正确的

所以我们再引入一个原理：

## 容斥原理

>在计数时，先不考虑重叠的情况，把包含于某内容中的所有对象的数目先计算出来，然后再把计数时重复计算的数目排斥出去，使得计算的结果既无遗漏又无重复，这种计数的方法称为容斥原理。

简单来说，就是把**重复计算**的部分**去掉**，把**多去掉**的部分**加回来**

针对本题而言，就是：

不合法数目$=$ $1$超出的部分$+$ $2$超出的部分$+……-$ $1,2$共同超出的部分$-$ $2,3$共同超出的部分$……$ $+$ $1,2,3$共同超出的部分……（后面以此类推）

代码实现就比较容易了

下面有详细注释

```
#include<bits/stdc++.h>
using namespace std;
int T,n,c[5],d[5],s;
long long ans,f[100010];
void pack_pre()
{
	f[0]=1;
	for(int i=1;i<=4;i++)
	    for(int j=c[i];j<=100001;j++)
	        f[j]+=f[j-c[i]];
}
void dfs(int now,int sum,int flag)
//now是现在搜到的硬币种类
//sum是目前还能用的金额数目
//flag是符号（控制+,-符号）
{
	if(sum<0) return;//能用的钱没了就返回
    if(now>4) {ans+=f[sum]*flag;return;}//所有硬币种类都搜完了
	dfs(now+1,sum,flag);//合法的部分
	dfs(now+1,sum-(d[now]+1)*c[now],-flag);//不合法的部分
}
int main()
{
	for(int i=1;i<=4;i++) scanf("%d",&c[i]);
	pack_pre();//完全背包预处理
	scanf("%d",&T);
	while(T--)
	{
		ans=0;//记得清零
		for(int i=1;i<=4;i++) scanf("%d",&d[i]);
		scanf("%d",&s);
		dfs(1,s,1);
		printf("%lld\n",ans);
	}
}

```





---

## 作者：Doubeecat (赞：25)

> [P1450 [HAOI2008]硬币购物](https://www.luogu.com.cn/problem/P1450)
> 
> 共有 $4$ 种硬币。面值分别为 $c_1,c_2,c_3,c_4$。
> 
> 某人去商店买东西，去了 $n$ 次，对于每次购买，他带了 $d_i$ 枚 $i$ 种硬币，想购买 $s$ 的价值的东西。请问每次有多少种付款方法。

<!-- more -->

## 解题思路：

容斥 + DP

挺牛逼的一道题，做了一天学到很多。

首先看到这个问题，根据经验发现可以通过多重背包解决，但是时间复杂度为 $O(ns^2)$，非常离谱。

我们先把问题分割成小问题

> 共有 $1$ 种硬币。面值为$c$ ，不限制使用次数。

那么这就是裸的无限背包，$O(n)$ 即可解决。

加上限制怎么做？直接背包肯定是不行的，我们考虑用总数减去反面。

即 满足条件的方案总数 = 方案总数 - 不满足条件的方案总数

那么问题就转化为了如何求不满足条件的方案总数。我们观察题目性质可以发现，如果我们取了 $d_i + 1$ 个硬币，那么接下来不论怎么取硬币都是非法方案。

所以我们可以想到，强制令体积为 $s - c_i * (d_i + 1)$ 那么所有方案都是非法的，转化为方程也就是

$$ans = f_s - f_{s - c_i * (d_i + 1)}$$

试图扩大下这个问题，发现如果我们直接去掉 $c_i * (d_i + 1)$ 还会把其他部分的合法方案给去掉。这里设第 $i$ 种硬币的不合法方案集合为 $A_i$，那么我们就是要求 

$$|A_1 \cup A_2 \cup A_3 \cup A_4|$$

这就是一个很明显的容斥问题了。

根据容斥原理，我们可以得出

$$
\begin{aligned}
    &|A_1 \cup A_2 \cup A_3 \cup A_4| \\
    &= (|A_1| + |A_2| + |A_3| + |A_4|) \\
    &- (|A_1 \cap A_2| + |A_1 \cap A_3| +|A_1 \cap A_4| + |A_2 \cap A_3|+ |A_2 \cap A_4|+ |A_3 \cap A_4|)\\
    &+ (|A_1 \cap A_2 \cap A_3| + |A_1 \cap A_2 \cap A_4| + |A_2 \cap A_3 \cap A_4|)\\
    &- |A_1 \cap A_2 \cap A_3 \cap A_4|
\end{aligned}
$$

现在还有一个问题，如何求 $|A_1 \cap A_2|$ ?

还是类似刚才的做法，如果要让这种方案成立，我们就强制把两个硬币全部扣去，即 $s - (c_i * (d_i + 1)) - (c_j * (d_j + 1))$ 同样可以拓展到 $n$ 个的情况。

对于这个问题，我们在问题最开始时先预处理一遍没有限制的选择方案 $f$，然后每次求并集直接算 $f_{s - (c_i * (d_i + 1)) - (c_j * (d_j + 1))}$

所以这里我们可以通过枚举子集来快速求解，比如说 5 对应的 4 位二进制表示为 `0110`
，我们就认为这里是要求 $|A_2 \cap A_3|$

代码实现

```cpp
for (int i = 0;i < 16;++i) {
    ll siz = 0,k = 0,tmp = 0,tot = 1;
    ll p = i;
    while (p) {
        if (p & 1) {
            tmp += c[tot] * (d[tot] + 1);
            //计算c_i * (d_i + 1)
            ++siz;
            //统计当前有多少个
        }
        ++tot,p >>= 1;
    }
    if (siz % 2) k = -1;
    else k = 1;
    //奇加偶减
    if (s - tmp < 0) continue;
    //排除非法方案
    ans += k * f[s-tmp];
}
```

于是这题就做完了。

总结：

1. 如果正面思考不通，尝试用整体去掉反面来计算答案
2. 统计方案时出现重复部分，用容斥原理来处理
3. 所谓“奇加偶减”，其实是第 $i$ 项的运算和第 $i-1$ 项运算符相反，主要确定第 1 项是啥
4. 进行第 1 步时，如果发现哪里 RE 了，考虑排查边界问题。

## 代码：

```cpp
	read(c[1],c[2],c[3],c[4],n);
	f[0] = 1;
	for (int i = 1;i <= 4;++i) {
		for (int j = c[i];j <= N;++j) {
			f[j] += f[j - c[i]];
		}
	}
	while (n--) {
		ll ans = 0;
		read(d[1],d[2],d[3],d[4],s);
		for (int i = 0;i < 16;++i) {
			ll siz = 0,k = 0,tmp = 0,tot = 1;
			ll p = i;
			while (p) {
				if (p & 1) tmp += c[tot] * (d[tot] + 1),++siz;
				++tot,p >>= 1;
			}
			if (siz % 2) k = -1;
			else k = 1;
			//printf("%lld\n",tmp);
			if (s - tmp < 0) continue;
			ans += k * f[s-tmp];
		}
		printf("%lld\n",ans);
	}
	return 0;
```


---

## 作者：TianTian2008 (赞：24)

组合、计数问题考虑使用生成函数解决。生成函数是一个包含问题解信息的多项式。由于多项式卷积具有优秀的性质，生成函数在组合、计数问题中起到重要的作用。

此题中，对于生成函数 $f(x)=a_0+a_1x+a_2x^2+a_3x^3+\cdots$，其中 $k$ 次项的系数 $a_k$ 表示支付 $k$ 价值的方案数为 $a_k$。显然，使用第 $k$ 种硬币付款的生成函数 $h_k(x)=1+x^{c_k}+x^{2c_k}+\cdots+x^{d_kc_k}=\frac{1-x^{(d_k+1)c_k}}{1-x^{c_k}}$。

最终答案的生成函数为 $\prod_{k=1}^4h_k(x)=MN$，其中 $M=\prod_{k=1}^4\frac1{1-x^{c_k}},N=\prod_{k=1}^4(1-x^{(d_k+1)c_k})$。

考虑如何计算 $M$，$M=\prod_{k=1}^4\frac1{1-x^{c_k}}=\prod_{k=1}^4(1+x^{c_k}+x^{2c_k}+\cdots)$。由于所有购买中的硬币面值 $c_k$ 都一致，因此所有购买中的 $M$ 都相同，预处理计算一次即可。又因为 $s\leqslant10^5$，故只需关注次数小于等于 $10^5$ 的项，次数高于 $10^5$ 的项可以舍弃。尽管如此，暴力展开仍有 $O(s^2)$ 的时间复杂度。使用 $FFT$ 优化多项式乘法，降低到 $O(s\log s)$ 的时间复杂度。

计算 $N$ 时直接暴力展开统计答案即可。

到此，得出了此题的思路。

```
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;
typedef long long ll;
typedef double db;
ll q,s,c[5],d[5],v[5],n[16]={1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1,-1,1},ans;//n表示N展开后各项的系数
struct cplx
{
	db a,b;
	cplx(db x=0,db y=0){a=x;b=y;}
	inline friend cplx operator+(cplx c1,cplx c2){return cplx(c1.a+c2.a,c1.b+c2.b);}
	inline friend cplx operator-(cplx c1,cplx c2){return cplx(c1.a-c2.a,c1.b-c2.b);}
	inline friend cplx operator*(cplx c1,cplx c2){return cplx(c1.a*c2.a-c1.b*c2.b,c1.a*c2.b+c1.b*c2.a);}
}f[300001],g[300001];
ll rev[300001],m[100001];//m表示M展开后各项的系数
db pi; 
void fft(ll n,cplx* f,ll type)
{
	for(int i=0;i<n;++i) rev[i]=(rev[i>>1]>>1)|(i&1)*(n>>1);
	for(int i=0;i<n;++i)
		if(rev[i]<i)
		{
			cplx tmp=f[i];
			f[i]=f[rev[i]];
			f[rev[i]]=tmp;
		}
	for(int mid=1;mid<n;mid<<=1)
	{
		ll len=mid<<1;
		cplx omg(cos(pi*2/len),type*sin(pi*2/len));
		for(int j=0;j<n-len+1;j+=len)
		{
			cplx cur(1,0);
			for(int k=0;k<mid;++k)
			{
				cplx c1=f[j+k],c2=cur*f[mid+j+k];
				f[j+k]=c1+c2;
				f[mid+j+k]=c1-c2;
				cur=cur*omg;
			}
		}
	}
}
void dft(ll n,cplx* f)
{
	fft(n,f,1);
}
void idft(ll n,cplx* f)
{
	fft(n,f,-1);
	for(int i=0;i<n;++i)
	{
		f[i].a/=n;
		f[i].b/=n;
	}
}
void init()
{
	pi=acos(-1);
	ll n=100000,len=1<<(ll)ceil(log2(n<<1|1));
	f[0].a=1;//初始多项式为1
	for(int i=1;i<=4;++i)
	{
		dft(len,f);
		for(int j=0;j<len;++j) g[j]=cplx();//清空 
		for(int j=0;j<=n;j+=c[i]) g[j].a=1;//第i种硬币的生成函数 
		dft(len,g);
		for(int j=0;j<len;++j) f[j]=f[j]*g[j];
		idft(len,f);
		for(int j=n+1;j<len;++j) f[j]=cplx();//舍弃高次项 
	}
	for(int i=0;i<=100000;++i) m[i]=(ll)(f[i].a+0.5);
}
ll calc(ll x)//计算N的某一项 
{
	ll del=(x&1?v[1]:0)+(x&2?v[2]:0)+(x&4?v[3]:0)+(x&8?v[4]:0);
	if(s<del) return 0;
	return m[s-del]*n[x];
}
int main()
{
	for(int i=1;i<=4;++i) scanf("%lld",&c[i]);
	scanf("%lld",&q);
	init();
	while(q--)
	{
		for(int i=1;i<=4;++i) scanf("%lld",&d[i]);
		scanf("%lld",&s);
		for(int i=1;i<=4;++i) v[i]=c[i]*(d[i]+1);//计算N每一项的次数 
		ans=0;
		for(int i=0;i<16;++i) ans+=calc(i);//暴力展开N 
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：Jμdge (赞：18)

既然没人写扩欧，那我就来一发吧。

扩欧也还好，就是跑的有点慢，然后写的时候还有点烦，不过还是卡过去了。

考场上看到这道题又蒙了。。。
怎么回事第一题又要爆零了？

然后我打了个暴力测了一下极限数据根本过不去（幸好没把电脑整死机）

于是想了又想，整出了个 $ O(s* t)$的扩欧算法（打了一个小时的样子）。

（话说正解好像容斥）

原本搞了下循环展开结果好像会更慢。。。

----

讲一下思路：用扩欧解。

安利扩欧博客：[Judge's Class](https://www.cnblogs.com/Judge/p/9383034.html#_lab2_0_1)


	预处理解之前我们要先用扩欧求出:
    c1*x + c2*y = gcd(c1,c2) 中的 x和y （以及gcd），记录下来，
    然后 c1、c2 除以 gcd(c1,c2)。（会扩欧的话就能懂吧。）
	然后我们先 O(s log s) 预处理用 c1、c2 能拼出 s 的解。
	（即 c1*x1 + c2*y1 = s 中 x1和y1 的解）
    然后我们令 x1 达到最小正整数状态，即 y1 达到最大解。
    这时如果 y1 为负数，则无解，将数组中的值设为-1，break。
    否则我们用数组记录下此时的解。
    
	那么 c3、c4 也是同理这样处理。
    
    这样处理完之后我们发现如果没有 d 数组的限制，y/c2 就是方案数，
    那么我们考虑一下 d1对x1 的限制 以及 d2 对 y1 的限制求出解的方案数。
    然后记录答案在 f 数组里面，至于 c3、c4 就记录进 g 数组。
    然后 O(s) 滚出答案。


```
//by Judge
#include<bits/stdc++.h>
#define rint register int
#define ll long long
using namespace std;
const int M=1e5+5;
#idndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1,*p2;
inline int read(){ int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} int c1,c2,c3,c4,d1,d2,x11,x22,y11,y22,d[5];
int X1[M],X2[M],Y1[M],Y2[M],f[M],g[M];
int ex_gcd(int a,int b,int& x,int& y){ /* 套个板子，忘了就现推 */
	if(!b) return x=1,y=0,a;
	int d=ex_gcd(b,a%b,y,x);
	return y-=a/b*x,d;
}
int main(){
	c1=read(),c2=read();
	c3=read(),c4=read();
	d1=ex_gcd(c1,c2,x11,y11);
	d2=ex_gcd(c3,c4,x22,y22);
	c1/=d1,c2/=d1,c3/=d2,c4/=d2;
	/*  预处理出解  */
	for(rint s=1;s<=1e5;++s){
		rint tmp=s,x=x11,y=y11;
		rint a=c1,b=c2;
		if(tmp%d1){
			X1[s]=Y1[s]=-1;
			continue;
		}
		tmp/=d1,x*=tmp,y*=tmp;
		
		y+=x/b*a,x%=b;
		if(x<0) x+=b,y-=a;
		if(y>=0) X1[s]=x,Y1[s]=y;
		else X1[s]=Y1[s]=-1;
	}
	for(rint s=1;s<=1e5;++s){
		rint tmp=s,x=x22,y=y22;
		rint a=c3,b=c4;
		if(tmp%d2){
			X2[s]=Y2[s]=-1;
			continue;
		}
		tmp/=d2,x*=tmp,y*=tmp;
		
		y+=x/b*a,x%=b;
		if(x<0) x+=b,y-=a;
		if(y>=0) X2[s]=x,Y2[s]=y;
		else X2[s]=Y2[s]=-1;
	}
	for(rint T=read(),S;T;--T){
		ll ans=0;
		for(int i=1;i<=4;++i)
			d[i]=read();
		S=read(),f[0]=g[0]=1;
		/*  考虑限制求出方案数  */
		for(rint s=1;s<=S;++s){
			rint tmp=s,a=c1,b=c2;
			rint x=X1[s],y=Y1[s];
			if(x<0||y<0){
				f[s]=0;
				continue;
			}
			rint maxX=min(x+y/a*b,d[1]);
			
			if(d[2]<y) x+=(y-d[2]+a-1)/a*b;
			if(x>maxX){
				f[s]=0;
				continue;
			}
			f[s]=(maxX-x)/b+1;
		}
		for(rint s=1;s<=S;++s){
			rint tmp=s,a=c3,b=c4;
			rint x=X2[s],y=Y2[s];
			if(x<0||y<0){
				g[s]=0;
				continue;
			}
			rint maxX=min(x+y/a*b,d[3]);
			
			if(d[4]<y) x+=(y-d[4]+a-1)/a*b;
			if(x>maxX){
				g[s]=0;
				continue;
			}
			g[s]=(maxX-x)/b+1;
		}
        /*  O(s) 滚出答案  */
		for(rint i=0;i<=S;++i)
			ans+=1ll*f[i]*g[S-i];
		printf("%lld\n",ans);
	} return 0;
}
```

---

## 作者：Azuree (赞：11)

[查看原题请戳这里](https://www.luogu.org/problem/P1450)

看到这道题，最直观的就是对于每一种情况都跑一遍多重背包，然而这样做的话时间复杂度会变得非常奇妙……

首先，我们可以考虑每种钱的个数没有限制的方案数。很显然，我们可以直接跑一个完全背包。

那么，如果只有一种钱存在个数限制呢？

我们用$f[i]$表示支付金额$i$的方案数，那么$f[s]$就是硬币没有限制时支付的方案数。如果面值为$c[i]$的硬币的数量为$d[i]$，那么只用c[i]可以支付的最大金额就是$c[i]\times d[i]$。那么，如果我们先花掉$d[i]+1$张面额为$c[i]$的钱，然后再用这$4$种钱去支付剩余的金额，那么无论剩余金额的支付方案是什么，这个放案一定会使用至少$d[i]+1$张$c[i]$，即$c[i]$的使用数量一定会超出限制。

我们再来考虑这些钱全部有数量限制时的情况。

如果我们对于每一种钱都按上面的方案处理，那么对于某种即超出$c[i]$的限制，又超出$c[j]$限制的方案数，我们就会减两遍，所以这里我们需要容斥一下。

code:

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>

using namespace std;

long long c[5],d[5],ans,tot,s,f[100005],k;

int main()
{
	for(int i = 1; i <= 4; i++) scanf("%d",&c[i]); scanf("%d",&tot);
	f[0] = 1;
	for(int j = 1; j <= 4; j++)
		for(int i = 1; i <= 100000; i++)
			if(i >= c[j]) f[i] = f[i] + f[i - c[j]];
	while(tot--)
	{
		for(int i = 1; i <= 4; i++) scanf("%d",&d[i]);
		scanf("%d",&s);
		ans = f[s];
		for(int k = 15;k > 0; k--)
		{
			long long u = 0,o = k,now = 0,cnt = 0;
			while(o > 0)
			{
				cnt++;
				if(o & 1)
				{
					now = (d[cnt] + 1) * c[cnt] + now;
					u ^= 1;
				}
				o >>= 1;
			}
			if(now > s) continue;
			if(u) ans -= f[s - now];
			else ans += f[s - now];
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：RainHand (赞：9)

[传送~](https://www.luogu.com.cn/problem/P1450)

这是道经典容斥题。我们要求的是
$$
\sum{c_ix_i} = s \quad ,x_i\leq d_i
$$

的解的个数。

如果没有 $d_i$ 的限制，这就是个完全背包问题，于是我们考虑用所有解减去不符合要求的个数。对于不符合要求的我们也可以得到：

$$
\sum{c_ix_i} = s \quad ,x_i\geq d_i+1
$$

变形一下，得到：

$$
\sum{c_ix_i} = s-\Big(\sum{d_i+1}\Big)
$$

这也是一个完全背包。但因为可以是有一些数满足要求，而另一些不满足，于是就要容斥了。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxs = 1e5;
int c[5], d[5], n, s;
ll f[maxs+10];
int main() {
	for (int i = 1; i <= 4; ++i)
		scanf("%d", &c[i]);
	f[0] = 1;
	for (int i = 1; i <= 4; ++i)
		for (int j = c[i]; j <= maxs; ++j)
			f[j] += f[j-c[i]];
	scanf("%d", &n);
	while (n--) {
		for (int i = 1; i <= 4; ++i)
			scanf("%d", &d[i]);
		scanf("%d", &s);
		ll ans = 0;
		for (int i = 1; i < 16; i++) {
			int m = s, cnt = 0;
			for (int j = 1; j <= 4; j++)
				if (i&(1<<(j-1))) m -= (d[j]+1)*c[j], ++cnt;
			if (m >= 0) ans += (cnt%2*2-1)*f[m];
		}
		printf("%lld\n", f[s] - ans);
	}
	return 0;
}
```

后记：对于这样所有解减去不合法的技巧，在CSP-S 2019 D2T1也用到了

---

## 作者：i207M (赞：6)

## 题目总结

硬币购物一共有4种硬币。面值分别为c1,c2,c3,c4。某人去商店买东西，去了tot次。每次带di枚ci硬币，买si的价值的东西。请问每次有多少种付款方法。

## 数据范围

di,s<=100000

tot<=1000

## 解题思路

假如这道题用多重背包来做，肯定会T炸；

我们考虑容斥：

先计算出不考虑硬币限制的方案数；

减去有一种硬币超过的方案数（是什么？$dp(tot-c[i]*(d[i]+1))$，解释一下，tot-c[i]*(d[i]+1)是指，强制选了d[i]+1个硬币（超标了），剩下的随便选（肯定是超标的方案数））

**但是我们要容斥**

加上两种硬币；

减去三种硬币；

加上四种硬币；

## 易错误区

数组要开对；

## 代码展示

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<string>
#include<algorithm>
#include<vector>
#include<map>
#include<set>
#include<list>
#include<queue>
#include<stack>
#include<bitset>
#include<deque>
using namespace std;
#define ll long long
#define inf 0x3f3f3f3f
#define ri register int
#define il inline
#define fi first
#define se second
#define mp make_pair
#define pi pair<int,int>
#define mem0(x) memset((x),0,sizeof (x))
#define mem1(x) memset((x),0x3f,sizeof (x))
il char gc() {
    static const int BS = 1 << 22;
    static unsigned char buf[BS], *st, *ed;
    if (st == ed) ed = buf + fread(st = buf, 1, BS, stdin);
    return st == ed ? EOF : *st++;
}
#define gc getchar
template<class T>void in(T &x)
{
    x = 0; bool f = 0; char c = gc();
    while (c < '0' || c > '9') {if (c == '-') f = 1; c = gc();}
    while ('0' <= c && c <= '9') {x = (x << 3) + (x << 1) + (c ^ 48); c = gc();}
    if (f) x = -x;
}
#undef gc
void out(int x) {
    if (x < 0) putchar('-'), x = -x;
    if (x > 9) out(x / 10);
    putchar(x % 10 + '0');
}
#define N 100010
#define int ll
int c[5];
int d[5], t, s;
int f[N];
int dp(int x) {
    return x < 0 ? 0 : f[x];
}
signed main() {
    for (ri i = 1; i <= 4; ++i) in(c[i]);
    f[0] = 1;
    for (ri i = 1; i <= 4; ++i)
        for (ri j = c[i]; j <= 100000; ++j) {
            f[j] += f[j - c[i]];
        }
    in(t);
    while (t--) {
        for (ri i = 1; i <= 4; ++i) in(d[i]);
        in(s);
        int ans = f[s];
        for (ri i = 1; i <= 4; ++i) ans -= dp(s - c[i] * (d[i] + 1));
        for (ri i = 1; i <= 4; ++i)
            for (ri j = i + 1; j <= 4; ++j)
                ans += dp(s - c[i] * (d[i] + 1) - c[j] * (d[j] + 1));
        //printf("%lld\n", ans);
        for (ri k = 1; k <= 4; ++k)
            for (ri i = k + 1; i <= 4; ++i)
                for (ri j = i + 1; j <= 4; ++j)
                    ans -= dp(s - c[i] * (d[i] + 1) - c[j] * (d[j] + 1) - c[k] * (d[k] + 1));
        ans += dp(s - c[1] * (d[1] + 1) - c[2] * (d[2] + 1) - c[3] * (d[3] + 1) - c[4] * (d[4] + 1));
        printf("%lld\n", ans);
    }
    return 0;
}
```

---

## 作者：沉辰 (赞：4)

```cpp
#include<iostream>
#include<cstdio>
#define ll long long
using namespace std;
```
/\*
感觉像是正难则反的思路

\*/
/\*答案为 面值S的总的没有硬币限制下的方案数 – 第1种硬币超过限制的方案数 – 第2种硬币超过限制的方案数 – 第3种硬币超过限制的方案数 – 第4种硬币超过限制的方案数 + 第1,2种硬币同时超过限制的方案数 + 第1,3种硬币同时超过限制的方案数 + …… + 第1,2,3,4种硬币全部同时超过限制的方案数。

容斥原理博大精深

\*/
```cpp
int T,c[5],d[5],x;
ll ans,f[100002];
void dfs(int x,int k,int sum)
{
```
/\*
x 第几种硬币

sum目前还能用的金额数目

k&1==1 代表 要减去上一种硬币使用情况是不合法的情况下

换剩下的能用的金额数目的方案数

k&1==0 代表 要加上上一种硬币使用情况是合法的情况下

换剩下的能用的金额数目的方案数

 
\*/
```cpp
    if(sum<0) return;
    if(x==5)
    {
        if(k&1) ans-=f[sum]; 
        else ans+=f[sum];
        return;        
    }
    dfs(x+1,k+1,sum-(d[x]+1)*c[x]);//枚举当前这种硬币不合法的情况，但是要到下一层才会减去他
    dfs(x+1,k,sum); //合法情况
}
int main()
{
    for(int i=1;i<=4;i++) scanf("%d",&c[i]);
    scanf("%d",&T);
    f[0]=1;
    for(int i=1;i<=4;i++)
       for(int j=c[i];j<=100000;j++)
        f[j]+=f[j-c[i]];//完全背包的方案数求法
    while(T--)
    {
        for(int i=1;i<=4;i++) scanf("%d",&d[i]);
        scanf("%d",&x);
        ans=0;
        dfs(1,0,x);//你就开心的搜啊
        printf("%lld\n",ans);
    }
    return 0;
}/*
```
1 2 5 10 2
3 2 3 1 10

1000 2 2 2 900


4
27
\*/

---

## 作者：Infiltrator (赞：3)


# 一个很经典的问题
$$ \sum_{i=1}^n x_i=s$$
其中x是正整数，这个式子的x的解有多少个?  
显然这个可以用背包计算
用dp[k]表示能表示出的和为k的解的数量，正序枚举k
$$ dp[k]=dp[k]+dp[k-money[i]] $$
其中money[i]是硬币的面值

接下来我们给他加上限制，规定第i个x的上界是c[i]  
现在的x的解的总数可以用容斥原理进行计算  

我们要求的东西是
$$ \left | \bigcap a_i\right | $$
a_i为第i个元素满足限制下的解集的集合

也就等于
$$ \left | S \right |-\left | \bigcup {\overline a_i} \right |$$
首先我们计算出所有的可能的情况也就是全集s  
接下来我们把不合法的情况减去  
根据容斥定理显然有答案=总的情况-1个不满足条件的+2个不满足条件的-3个不满足条件的……  
那么如果能很快的求出几个不合法集合的并集的话，这道题就可以很轻松的解决了  

考虑几个不合法集合的并集也是一个等式的形式，不过有的x有下界，有的x没有下界  
那么显然下界那部分对于每一个解都是存在的  
那么我们可以把它减去
也就是这样的
$$\sum x_i=s-sum$$
sum是所有下界的和  
这个玩意的所有解的数量我们已经用dp处理出来了，直接调用即可  

所以最后只需要枚举子集，然后观察一下子集中元素的个数，套上一个容斥系数即可
# CODE
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
#define ll long long
ll mz[5],dp[2000050],c[5];
ll ans,s;
int main()
{
	for(int i=1;i<=4;i++)scanf("%d",&mz[i]);
	dp[0]=1;
	for(int i=1;i<=4;i++)
		for(int k=mz[i];k<=100000;k++)
			dp[k]+=dp[k-mz[i]];
	int t;
	scanf("%d",&t);
	while(t--)
	{
		for(int i=1;i<=4;i++)scanf("%d",&c[i]);	
		scanf("%lld",&s);
		ans=dp[s];
		for(int i=1;i<(1<<4);i++)
		{
			ll tmp=0,js=0;
			for(int j=1;j<=4;j++)if(1<<(j-1)&i)js++,tmp+=(c[j]+1)*mz[j];
			if(tmp>s)continue;
			if(js%2==0)ans+=dp[s-tmp];
			else ans-=dp[s-tmp];
		}
		printf("%lld\n",ans);
	}
	return 0;
} 
```

---

## 作者：RyexAwl (赞：2)

### [HAOI2008]硬币购物
共有四种硬币，其面值分别为$c_1,c_2,c_3,c_4$

$n$次询问，每次给定每种硬币的个数$D_i$和付款金额$S$，问共有多少种付款方式

$n≤10^3,S≤10^5$

#### 暴力做法
我们可以把问题看作做$n$次多重背包，用单调队列优化，最优的复杂度为$O(n4s)$在这里不详细讨论

#### 完全背包+容斥
对于每次询问，相当于给定四个限制，第$i$个限制即只能至多使用$i$个硬币支付。类似于错排，满足限制的方案数=全部方案数-不满足的方案数
（错排的容斥推导可见https://www.luogu.com.cn/blog/maxsama/zuhemath）
而对于全部的方案数，相当于做体积为$S$的完全背包，而$S$至多为$10^5$，因此我们可以$O(4S)$预处理所有$S$。

而对于不满足条件的方案数

类似于错排，若不满足其中一个限制条件，一定是非法的，我们可以设$A_i$为第$i$种硬币不满足限制的方案集合。

那么不满足条件的方案数即
$$
\left|\bigcup_{i=1}^4 A_i\right|
$$
而对于$|A_i|$，我们当前一共要支付$S$个硬币，而对于第$i$种只能支付$D_i$个，那么我们如果先把$D_i+1$个硬币付完剩下的支付方案（即从四种硬币中支付$S-C_i(D_i+1)$的金额）是一定不合法的，因为第$i$个硬币至少需要选零个，而如果选$0$个，最终还是多付了一个。

因此，第$|A_i|=F[S-C_i(D_i+1)]$

因为我们要求集合的并，因此，我们需要考虑容斥，而考虑容斥我们就需要求出集合的交

我们考虑任意最简单的情况：两个集合的交
$$
\left|A_i \bigcap\ A_j\right|
$$
我们从定义出发，$A_i$为第$i$种硬币不满足限制的方案集合，而$A_j$为第$j$种硬币不满足限制的方案集合。

而显然，同时满足$i$种硬币不满足限制与$j$种硬币不满足限制这样的性质的集合，为它们的交。

同样地，我们可以把他们两个的$D_i+1$都先支付出去，那么则有
$$
\left|A_i \bigcap\ A_j\right|=F[S-C_i(D_i+1)-C_j(D_j+1)]
$$

那么
$$
\begin{aligned}
ans&=F[s]-\left|\bigcup_{i=1}^4 A_i\right| \\ 
&=F[s]-\sum_{T \subseteq\{1,2,3,4\}} -1^{|T|-1}\left|\bigcap_{j \in T } A_{j}\right| \\ 
&=F[s]-(-1)^{|T|-1}F[S-\sum_{j \in T} C_{j}\left(D_{j}+1\right)]\\ 
&=F[s]+(-1)^{|T|}F[S-\sum_{j \in T} C_{j}\left(D_{j}+1\right)]
\end{aligned}
$$
那么我们可以状压枚举$T$算出答案。

总的复杂度为$O(4S+16n)$

代码：
```cpp

#include <iostream>

using namespace std;

const int maxn = 10;

int c[maxn],d[maxn];

long long f[100010];

int main(){
	int n;
	cin >> c[1] >> c[2] >> c[3] >> c[4] >> n;
	f[0] = 1;
	for (int i = 1; i <= 4; i++){
		for (int j = c[i]; j <= 100010; j++){
			f[j] += f[j - c[i]];
		}
	}
	while(n--){
		int s;
		cin >> d[1] >> d[2] >> d[3] >> d[4] >> s;
		long long ans = f[s];
		for (int i = 0; i < 1 << 4; i++){
			long long sum = 0,cnt = 0;
			for (int j = 0; j < 4; j++){
				if (i >> j & 1){ 
					sum += c[j + 1] * (d[j + 1] + 1);
					cnt++;
				}
			}
			//cout << sum << endl;
			long long t = s - sum;
			if (cnt % 2 == 0 && t >= 0 && sum != 0) ans += f[s - sum];
			else if (t >= 0 && sum != 0) ans -= f[s - sum];
		}
		cout << ans << endl;
	}
	//system("PAUSE");
	return 0;
}


```


---

## 作者：frank3215 (赞：2)

[博客传送门](https://www.cnblogs.com/topsecret/p/11626423.html)

## 解答

根据**容斥原理**

$$
\left|\bigcap_{i=1}^n \overline{S_i}\right| = |U| - \left|\bigcup_{i=1}^n S_i\right| =
\sum_{0 \le k\le n}(-1)^k\sum_{1\le i_1<\cdots<i_k\le n}\left|\bigcap_{j=1}^k S_{i_j}\right|
$$

其中$S_i$表示第$i$种元素超限的取的方法集合，交的初始值是$U$。（$U$表全集，$\overline A$表$A$在$U$下的补集）

如何求出$\left|\bigcap_{j=1}^k S_{i_j}\right|$？
考虑先求出完全背包的dp值
然后强制将第$i_j$个元素选取超过$d_{i_j}$个。
这样的方案总数为$dp[t]-dp[t-\sum_{j=1}^k(d_i+1)c_i]$。（$dp[]$的负数项为$0$）

然后就可以愉快地容斥了。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int n = 4, mx = 1e5+10, pm[] = {1,-1};
#define int long long

int c[n], d[n], dp[mx] = {1};

signed main() {
	for (int i = 0; i < 4; ++i) {
		cin >> c[i];
		for (int j = c[i]; j < mx; ++j)
			dp[j] += dp[j-c[i]];
	}
	int tot, s;
	cin >> tot;
	while (tot--) {
		for (int i = 0; i < 4; ++i) cin >> d[i];
		cin >> s;
		int res = 0;
		for (int i = 0; i < 16; ++i) {
			int tmp = s, cnt = 0;
			for (int j = 0; j < 4; ++j) {
				if ((i>>j) & 1) {
					cnt++;
					tmp -= (d[j]+1)*c[j];
				}
			}
//			cout << cnt << ' ' << tmp << endl;
			res += pm[cnt%2]*(tmp>=0?dp[tmp]:0);
		}
		cout << res << endl;
	}
}

```

---

## 作者：lcjqwq (赞：2)

### Description

一共有 $4$ 种硬币。面值分别为 $c_1,c_2,c_3,c_4$ 。某人去商店买东西，去了 $tot$ 次。每次带 $d_i$ 枚 $c_i$ 硬币，买 $s$ 的价值的东西。请问每次有多少种付款方法。

<!-- more --> 

### Solution

考虑没有 $d$ 的限制，直接完全背包。$dp_i$ 表示 $i$ 这个面值用 $c_1...c_4$ 凑有多少种方法

加上限制就容斥枚举 $16$ 种情况表示哪几种面值的性质没有被满足。

然后可以观察到，如果对于 $i$ 不满足限制，方案数就是 $dp_{s-(d_i+1)c_i}$ 

所以归纳一下就是 
$$
ans = \sum\limits_{S \subseteq {1,2,3,4}}(-1)^{|S|}dp_{(s-\sum\limits_{x \in S} (d_x+1)c_x)}
$$

### Code
[看代码戳这里](https://acfunction.github.io/2019/03/09/BZOJ1042/#Code)

---

## 作者：GoldenPotato137 (赞：2)

**蒟蒻博客**：[QAQ](https://www.cnblogs.com/GoldenPotato/p/9545340.html)



------------

### Solution

这是一道很有意思的在背包里面做容斥的题目。

 .

首先，我们可以很轻松地想到暴力做背包的做法。

就是对于每一次询问，我们都做一次背包。

复杂度$O(tot*s*log(di))$ (使用二进制背包优化)

显然会T得起飞。

 .

接下来，我们可以换一种角度来思考这个问题。

首先，我们可以假设没有每个物品的数量的限制，那么这样就会变成一个很简单的完全背包问题。

至于完全背包怎么写，我们在这里就不做过多讨论，如有需要，看看代码就能理解了。

完全背包做完后，我们可以得到一个f[i]表示填满i的背包的方案数的数组。

那么，我们接下来可以用容斥来解决不可行的方案的问题。
.
 

假设只有1件物品的使用次数超出了所给的数量，假设这件物品是第x件。

那么可以用  f[s-(d[x]+1)*c[x]] 表示这件物品不可行的方案总数。

因为对于花钱数为 s-(d[x]+1)*c[x] 里面的每一种方法，都可以通过使用购买 d[x]+1件的x物品来超出所给的数量。所以  f[s-(d[x]+1)*c[x]] 可以表示该物品不可行方案总数。


 .

那么答案是四件物品不可行方案总数这和吗？

nope

**因为我们会重复减去一些东西。例如：一种方案即超出了第一件物品的使用数，也超出了第二件物品的使用数，我们却重复扣除了这种方案两次。**

所以说我们这时候就得使用容斥来解决这个问题。

容斥中有一个很基础的定理~~（我不会证）~~：

**对于有n的限制条件的事件，只要其中符合一个条件就算可行，其可行方案总数为：**

**（符合其中0个（条件的方案数，后同）-符合其中1个+符合其中2个-符合其中3个+符合其中4个-符合其中5个+符合其中6个....）**

那么，我们就可以根据这个定理求出不可行的方案总数。

对于这题来说，代码如下:

```cpp
for(a[1]=0;a[1]<=1;a[1]++)
            for(a[2]=0;a[2]<=1;a[2]++)
                for(a[3]=0;a[3]<=1;a[3]++)
                    for(a[4]=0;a[4]<=1;a[4]++)
                    {
                        int cnt=0,t_s=s;
                        for(int j=1;j<=4;j++)
                            if(a[j]==1) cnt++,t_s-=(d[j]+1)*c[j];
                        if(cnt%2==0) cnt=1;
                        else cnt=-1;
                        
                        if(t_s>=0)
                            ans=ans+cnt*f[t_s];
                    }
```
                    
~~这样写绝对不推荐，因为这样写很丑。~~

 

那么，这题就可以AC啦

 



------------
 

### Code
```cpp
//Luogu P1450 [HAOI2008]硬币购物
//Aug,27th,2018
//DP+容斥
#include <iostream>
#include <cstdio>
using namespace std;
long long read()
{
	long long x=0,f=1; char c=getchar();
	while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
	while(isdigit(c)){x=x*10+c-'0';c=getchar();}
	return x*f;
}
const int N=100000+1000;
long long f[N];
int n,m;
long long c[5],d[5];
int main(int argc, char **argv)
{
	for(int i=1;i<=4;i++)
		c[i]=read();
	m=read();
	
	f[0]=1;
	for(int j=1;j<=4;j++)
		for(int i=c[j];i<=100000;i++)
			f[i]+=f[i-c[j]];
	for(int i=1;i<=m;i++)
	{
		for(int j=1;j<=4;j++)
			d[j]=read();
		int s=read(),a[5];
		long long ans=0;
		for(a[1]=0;a[1]<=1;a[1]++)
			for(a[2]=0;a[2]<=1;a[2]++)
				for(a[3]=0;a[3]<=1;a[3]++)
					for(a[4]=0;a[4]<=1;a[4]++)
					{
						int cnt=0,t_s=s;
						for(int j=1;j<=4;j++)
							if(a[j]==1) cnt++,t_s-=(d[j]+1)*c[j];
						if(cnt%2==0) cnt=1;
						else cnt=-1;
						
						if(t_s>=0)
							ans=ans+cnt*f[t_s];
					}
		
		printf("%lld\n",ans);
	}
	return 0;
}

```

---

## 作者：21002tyj (赞：2)

DP预处理+容斥原理。

若用一个01串表示方案种类，第I位为1表示满足D[I]条件，为0表示不满足的话。

那么，我们要求的即是1111。


Pascal Code:






```cpp
Const
  maxs=100001;
Var
  c:array[0..4] of longint;
  d:array[0..4] of longint;
  tot,s,i,j:longint;
  ans:int64;
  dp:array[0..maxs]of int64;
  Procedure pack_dp;
  var i:longint;
  begin
    fillchar(dp,sizeof(dp),0);
    dp[0]:=1;
    for i:=1 to 4 do
      for j:=c[i] to maxs do dp[j]:=dp[j]+dp[j-c[i]];
  end;
  Procedure dfs(now,remain:longint;mark:boolean);
  begin
    if remain<0 then exit;
    if now=5 then
    begin
        if mark then ans:=ans-dp[remain]
                else ans:=ans+dp[remain];
        exit;
    end;
    dfs(now+1,remain-c[now]*(d[now]+1),not mark);
    dfs(now+1,remain,mark);
  end;
  Procedure work;
  var
    i,j:longint;
  begin
    readln(c[1],c[2],c[3],c[4],tot);
    pack_dp;
    for i:=1 to tot do
    begin
      for j:=1 to 4 do read(d[j]);readln(s);
      ans:=0;
      dfs(1,s,false);
      writeln(ans);
    end;
  end;
Begin
  work;
  readln;
End.

```

---

## 作者：yeyyx (赞：2)

容斥+dp楼下已经说得很清楚了，做题的时候无聊画了画图方便大家直观感受下容斥原理emmm

于是答案就是不加限制的方案数-用超一枚的方案数+用超两枚的-用超三枚的+用超四枚的

```cpp
![N6wbn.png](https://s1.ax1x.com/2017/10/22/N6wbn.png)
![N6r5V.png](https://s1.ax1x.com/2017/10/22/N6r5V.png)
![N6DU0.png](https://s1.ax1x.com/2017/10/22/N6DU0.png)
![N6BEq.png](https://s1.ax1x.com/2017/10/22/N6BEq.png)
//感谢leozhudd的图床技术支持qwq
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
long long c[5],d[5],tot,s,ans;
long long f[1000005];
int main(){
    for(int i=1;i<=4;i++)scanf("%lld",&c[i]);
    scanf("%lld",&tot);
    for(int k=1;k<=tot;k++){
        scanf("%lld%lld%lld%lld%lld",&d[1],&d[2],&d[3],&d[4],&s);
        memset(f,0,sizeof f);
        f[0]=1;
        for(int i=1;i<=4;i++){
            for(int j=1;j<=s;j++){
                if(j-c[i]>=0){
                    f[j]=f[j]+f[j-c[i]];
                }
            }
        }
        ans=f[s];
        for(int i=1;i<=4;i++)
            if(s>=(d[i]+1)*c[i])
                ans-=f[s-(d[i]+1)*c[i]];
        for(int i=1;i<=4;i++)
            for(int j=i+1;j<=4;j++)
                if(s>=(d[i]+1)*c[i]+(d[j]+1)*c[j])
                    ans+=f[s-(d[i]+1)*c[i]-(d[j]+1)*c[j]];
        for(int i=1;i<=4;i++){
            long long t=0;
            for(int j=1;j<=4;j++){
                if(i!=j) t+=(d[j]+1)*c[j];
            }
            if(s>=t)
                ans-=f[s-t];
        }
        long long t=0;
        for(int i=1;i<=4;i++)t+=(d[i]+1)*c[i];
        if(s>=t)ans+=f[s-t];
        printf("%lld\n",ans);
    }
    return 0;
}
```

---

## 作者：HH_Halo (赞：1)

### [HH_Halo](https://www.cnblogs.com/hhhhalo/p/13633817.html)
## 思路分析
上去就跑了个暴力，结果直接 T 到飞起，貌似全是大数据

所以如果要跑背包的话，那么时间限制是只允许我们跑一遍的，这时候的答案就需要换一个巧妙的方法来得到
* 每次询问的**不同在于每种硬币的限制个数不同**，所以我们为了避免受其影响，就可以这样计算答案：
      **合法方案数 = 无个数限制的方案数 - 不合法的方案数**
* 对于无个数限制的方案数，就是一个简单的完全背包，直接预处理就好了，关键在于我们如何迅速得出不合法的方案数：
    * 因为只有四种硬币，所以我们可以枚举出，有哪些硬币超过了个数限制从而导致方案不合法
    * 这时可以直接让选出的硬币选 $(d[i]+1)$ 个，即保证超过个数限制，不合法的方案数就是 
    $$f[s-c[i]*(d[i]+1)]$$
    
然而**不同的情况会有交集**，这时候就要用到容斥原理：
   
* 设四个硬币超过个数限制的方案分别为 $A,B,C,D$，依据容斥原理就有 
   $$ f[A∪B] = f[A]+f[B]-f[A∩B] $$
 其中 $f[A] = f[s-c[1]*(d[1]+1)]$，其他同理
   
* 首先 $f[s] -= f[A]+f[B]+f[C]+f[D]$，然而两两之间会出现交集，所以还需要再加上两两的交集，这些交集之间还会有交集，说明加重了，还需要再减去交集的交集，以此类推 ~~(禁止套娃)~~

* 最终用状压枚举所有集合，根据上面的推导可以发现一个性质，**有奇数个元素的集合需要减去，有偶数个元素的需要加上**

## $Code$
```c++
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define N 100010
#define R register
#define int long long
using namespace std;
inline int read(){
	int x = 0,f = 1;
	char ch = getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return x*f;
}
int n,s,c[10],d[10],f[N];
void pre(){
	f[0] = 1;
	for(R int i = 1;i <= 4;i++){
	    for(R int j = c[i];j <= N;j++){
		    f[j] += f[j-c[i]];
	    }
	}
}
void solve(){
    int ans=f[s];
    for(R int i=1;i<=15;i++){//状压枚举集合内元素
	int tot=0,cnt=0;
	for(R int j=0;j<4;j++){
	    if(i&(1<<j)){//在集合内则强制让其超过个数限制
	        cnt++;//记录集合数
		tot+=c[j+1]*(d[j+1]+1);
	    }
	}
	int flag = (cnt%2) ? -1 : 1;
	if(tot<=s) ans+=flag*f[s-tot];
    }
    printf("%lld\n",ans);
}
signed main(){
	c[1] = read(),c[2] = read(),c[3] = read(),c[4] = read();
	n = read();
	pre();
	for(R int i = 1;i <= n;i++){
            for(R int i=1;i<=4;i++) d[i]=read();
            s=read();
 	    solve();
	}
	return 0;
}
```

---

## 作者：G_A_TS (赞：1)

题解同步发布于[blog](https://www.cnblogs.com/wzzorz/articles/10349284.html)  

------------
本题想到多重背包还是很容易的~~(什么?不知道多重背包?)~~  
但是，另一题解已经将时间~~安排~~计算地明明白白  
所以想到**完全背包**(多重背包跟01背包似乎区别不大)  
可以先预处理完全背包的情况，然后~~瞎搞~~**容斥原理**  
不懂容斥原理的看这里：[传送门](https://www.sohu.com/a/198865515_128501)  
想到**完全背包**和**容斥原理**后，剩下的就只是~~打表~~一些简单的实现了  
上代码

------------
```cpp
#include<bits/stdc++.h>
using namespace std;
long long c[5],d[5],dp[100010],tot,s;
long long Q(long long x)//便于打表
{
	return c[x]*(d[x]+1);
}
int main()
{
	for(int i=1;i<=4;i++)
	{
		cin>>c[i];
	}
	cin>>tot;
	dp[0]=1;//初始化，之后预处理
	for(int i=1;i<=4;i++)
	{
		for(int j=c[i];j<=100001;j++)
		{
			dp[j]+=dp[j-c[i]];
		}
	}
	for(int js=1;js<=tot;js++)
	{
		for(int i=1;i<=4;i++)
		{
			cin>>d[i];
		}
		cin>>s;
		long long ans=dp[s];//初始，之后容斥原理代码
		if(s>=Q(1))
			ans-=dp[s-Q(1)];
		if(s>=Q(2))
			ans-=dp[s-Q(2)];		
		if(s>=Q(3))
			ans-=dp[s-Q(3)];
		if(s>=Q(4))
			ans-=dp[s-Q(4)];
		if(s>=Q(1)+Q(2))
			ans+=dp[s-Q(1)-Q(2)];
		if(s>=Q(1)+Q(3))
			ans+=dp[s-Q(1)-Q(3)];
		if(s>=Q(1)+Q(4))
			ans+=dp[s-Q(1)-Q(4)];
		if(s>=Q(2)+Q(3))
			ans+=dp[s-Q(2)-Q(3)];
		if(s>=Q(2)+Q(4))
			ans+=dp[s-Q(2)-Q(4)];
		if(s>=Q(3)+Q(4))
			ans+=dp[s-Q(3)-Q(4)];
		if(s>=Q(1)+Q(2)+Q(3))
			ans-=dp[s-Q(1)-Q(2)-Q(3)];
		if(s>=Q(1)+Q(2)+Q(4))
			ans-=dp[s-Q(1)-Q(2)-Q(4)];
		if(s>=Q(1)+Q(3)+Q(4))
			ans-=dp[s-Q(1)-Q(3)-Q(4)];
		if(s>=Q(2)+Q(3)+Q(4))
			ans-=dp[s-Q(2)-Q(3)-Q(4)];
		if(s>=Q(1)+Q(2)+Q(3)+Q(4))
			ans+=dp[s-Q(1)-Q(2)-Q(3)-Q(4)];//个人认为这个表打得相当美观~
		cout<<ans<<endl;
	}
} 
```

---

## 作者：Caicz (赞：0)

### 温馨提示：[在博客食用效果更佳](https://www.luogu.com.cn/blog/224229/solution-p1450)

本题乍一看，一道分组背包，但一算复杂度，直接暴毙，所以我们不妨从简化版的开始入手。

1. 当硬币数量没有任何限制时，我们可以完全背包先预处理出$dp[i]$表示价值为$i$时的方案数，再$O(1)$对每个询问进行回答

2. 当只有两个硬币时，我们答案即为
$$
ans =dp[i]-(dp[i-(cnt_1+1) * val_1]+dp[i-(cnt_2+1) * val_2])+dp[i-(cnt_1+1) * val_1-(cnt_2+1) * val_2]
$$
即无限制的方案数分别减去硬币1超限的方案数和硬币2超限的方案数，再加上重复减去的为两硬币都超限的方案数

那么现在，对于本题就有一个清晰的解法：

**先求出无限制的方案数，再减去单个硬币超限的情况，然后加上两个硬币超限的情况，再减去三哥硬币超限的情况，最后再加上四个硬币超限的情况，即为最终答案**

而对于硬币超限的情况，我们可以用状态压缩的方法表示该硬币是否超限

>> **_Talk is cheap,show you the code_**

```cpp
#include<stdio.h>
#include<iostream>
#include<cstring>
#include<math.h>
#define ll long long
#define debug(x) printf("debug: %lld\n",x);
using namespace std;
int d[5],c[5],n,s;
int dp[100005];

int read()
{
	int num,sign=1;
	char c;
	while((c=getchar())<'0'||c>'9')
		if(c=='-')sign=-1;
	num=c-'0';
	while((c=getchar())>='0'&&c<='9')
		num=(num<<1)+(num<<3)+c-'0';
	return num*sign;
}

signed main(void)
{
	d[1]=read(),d[2]=read(),d[3]=read(),d[4]=read(),n=read();
	dp[0]=1;
	for(register int i=1;i<=4;++i)
		for(register int j=d[i];j<=100004;++j)
			dp[j]+=dp[j-d[i]];
	while(n--)
	{
		ll ans=0;
		c[1]=read(),c[2]=read(),c[3]=read(),c[4]=read(),s=read();
		for(register int i=0;i<=15;++i)
		{
			ll t=s,cnt=0;
			for(register int j=1;j<=4;++j)
				if((i>>(j-1))&1)t-=(c[j]+1)*d[j],cnt^=1;
			if(t<0)continue;
			ans+=cnt?-dp[t]:dp[t];
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：leozhang (赞：0)

典型的背包+容斥

首先，考虑如果没有个数的限制，那么就是一个完全背包，所以先跑一个完全背包，求出没有个数限制的方案数即可

接下来，如果有个数的限制，那么我们就要利用一些容斥的思想：没有1个超过限制的方案=至少0个超过限制-至少1个超过限制+至少2个超过限制-至少3个超过限制+至少4个超过限制

所以我们用2进制数枚举谁超过了限制，然后加入上面的容斥即可

其中：如果第i种硬币的限制为ni，那么如果i要求超过限制，那么至少要用ni+1个，所以i超过限制的方案数为f[s-（ni+1）ci]（f[s]为全方案数）

```cpp
#include <cstdio>
#include <cmath>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <algorithm>
#include <queue>
#include <stack>
#define ll long long
using namespace std;
ll dp[100005];
int c[5];
int l[5];
int q;
int cot(int sit)
{
    int cnt=0;
    if(sit&1)
    {
        cnt++;
    }
    if(sit&2)
    {
        cnt++;
    }
    if(sit&4)
    {
        cnt++;
    }
    if(sit&8)
    {
        cnt++;
    }
    return cnt;
}
int main()
{
    for(int i=1;i<=4;i++)
    {
        scanf("%d",&c[i]);
    }
    dp[0]=1;
    for(int j=1;j<=4;j++)
    {
        for(int i=1;i<=100000;i++)
        {
            if(i>=c[j])
            {
                dp[i]+=dp[i-c[j]];
            }
        }
    }
    scanf("%d",&q);
    while(q--)
    {
        for(int i=1;i<=4;i++)
        {
            scanf("%d",&l[i]);
        }
        int s;
        scanf("%d",&s);
        ll ans=0;
        for(int i=0;i<16;i++)
        {
            int temp=s;
            if(cot(i)&1)
            {
                for(int j=0;j<4;j++)
                {
                    if((1<<j)&i)
                    {
                        temp-=(l[j+1]+1)*c[j+1];
                    }
                }
                if(temp<0)
                {
                    continue;
                }else
                {
                    ans-=dp[temp];
                }
            }else
            {
                for(int j=0;j<4;j++)
                {
                    if((1<<j)&i)
                    {
                        temp-=(l[j+1]+1)*c[j+1];
                    }
                }
                if(temp<0)
                {
                    continue;
                }else
                {
                    ans+=dp[temp];
                }
            }
        }
        printf("%lld\n",ans);
    }
    return 0;
}

```


---


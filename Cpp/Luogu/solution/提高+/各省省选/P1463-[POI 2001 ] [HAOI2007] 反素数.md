# [POI 2001 ] [HAOI2007] 反素数

## 题目描述

对于任何正整数 $x$，其约数的个数记作 $g(x)$。例如 $g(1)=1$，$g(6)=4$。

如果某个正整数 $x$ 满足：$\forall 0 \lt i \lt x$，都有 $g(x) \gt g(i)$，则称 $x$ 为**反素数**。例如，整数 $1,2,4,6$ 等都是反素数。

现在给定一个数 $N$，你能求出不超过 $N$ 的最大的反素数么？

## 说明/提示

$1 \leq N \leq 2 \times 10^9$

## 样例 #1

### 输入

```
1000```

### 输出

```
840```

# 题解

## 作者：doge233 (赞：314)


如果你很聪明的话一分钟就可以打出来一个表

```cpp
#include<bits/stdc++.h>
using namespace std;
int p[500]={1,2,4,6,12,24,36,48,60,120,180,240,360,720,840,1260,1680,2520,5040,7560,10080,15120,20160,25200,27720,45360,50400,55440,83160,110880,166320,221760,277200,332640,498960,554400,665280,720720,1081080,1441440,2162160,2882880,3603600,4324320,6486480,7207200,8648640,10810800,14414400,17297280,21621600,32432400,36756720,43243200,61261200,73513440,110270160,122522400,147026880,183783600,245044800,294053760,367567200,551350800,698377680,735134400,1102701600,1396755360,2001000000};
int main()
{
    int n;
    freopen("ant.in","r",stdin);
    freopen("ant.out","w",stdout);
    cin>>n;
    int ans;
    for(int i=0;;i++)
    {
        if(p[i]>n) {
            cout<<p[i-1]<<endl;
            return 0;
        }
    }
}
```


打表的过程就是数字较大时会发现都是某个数的倍数，然后就只枚举这个数的倍数暴力判断，一段一段打。最后一个数是用来卡边界的。freopen什么的不要在意吧。

咳咳咳
我来补一个正确的做法。

首先这类数其实叫highly composite number（高合成数）,在51nod上有该题的加强版，数据范围给到了10^200。在讨论区一位dalao给出一个高合成数一定是由另一个高合成数乘一个素数得来的结论。并且我们发现这类数分解质因数，随质因数增大，指数显然单调不增（贪心）。
对于一个高合成数一定是由另一个高合成数乘一个素数得来这个结论可以这样感性理解。比如已经得到一个高合成数$n=2^{k_1}*3^{k_2}*...$，那么想找到比这个数约数个数多的最小的数是$2n$，它的约数个数是n的$\frac{k_1+2}{k_1+1}$，我们可以继续重复这个过程，但是到某一刻会发现乘多个2和乘一个其他的素数得到的数约数个数相同（例如乘$k_1+1$个2和乘一个指数为0的最小质数），但却比那个数数值更大，那么显然可以乘那个质数。大家可以结合wiki上的example给出的表格观察一下。
我们可以使用priority_queue，把1放进去，然后按随质因数增大指数单调不增的性质来入队新的数。


---

## 作者：Atlicd (赞：122)

### 看了看好像都是打表的   
~~我来说一说正解吧~~   
### 1、分析题意   
性质1：  ~~划重点、敲黑板~~   
1~N中的最大的反质数，就是1~N中约数个数最多的数中最小的一个 。  

简证：   
设m是1~N中约数个数最多的数中最小的一个。根据m的定义，m显然满足：   
第一条性质：  
$${\forall}x < m, g(x) < g(m) $$   
第二条性质：  
$${\forall} x > m , g(x) ≤ g(m) $$   
根据反素数的定义，第一条性质说明 m 是反质数，第二条性质说明大于 m 的数都不是反质数，所以 m 即为所求。  


性质2：   ~~再敲黑板~~  
1~N中任何的不同质因子都不会超过10个，且所有质因子的指数总和不超过30。  

简证：~~这个很好证明~~ qwq  
最小的 11 个质数的积   
```2 * 3 * 5 * 7 * 11 * 13 * 17 * 19 * 23 * 29 * 31 ＞ 2 * 10^9 ```   
所以，N ≤ 2 * 10^9 不可能有多于10个不同的质因子。  
即使只包含最小的质数2，仍然有 2 ^ 31 ＞ 2 * 10^9 所以 N ≤ 2 * 10^9 的质因子不会超过30个。

性质3：  ~~累了，不敲了~~  
$${\forall}x ∈ [1,N] $$ 
x为反质数的必要条件是：x分解质因数后可写作2^c1 * 3^c2 * ...... *29 ^ c10，并且c1≥c2≥c3≥......≥c10≥0 。    
通俗的讲，x的质因子是连续的若干个最小的质数，并且质数单调递增。

简证：
采用反证法。由性质2可得，若x的质因数分解式中存在一项p^k（p>29），则必定有一个不超过29的质因子p1不能整除x。根据算数基本定理的推论，x / p^k * p1^k 的约数个数与x的约数个数相等，但前者更小，这与反质数的定义矛盾。故x只包含29以内的质因子。   
同理，若x的质因子不是连续的若干个最小的，或者指数不单调递减，我们也可以通过上述交换质因子的方法，得到一个比x更小、但约数个数相等的整数。因此，假设不成立，原命题成立。

综上所述，我们可以使用DFS尝试搜索前10个质数的指数，并满足指数递减、总乘积不超过N，同时记录约数的个数。   
在这两个限制条件下，搜索量实际非常小，每当搜索出一个满足条件的整数的时候，我们就按照性质一的结论更新答案，最终得到约数个数最多的数中最小的一个。   

~~按理来说应该到了撒花结尾的时刻了，但是我还是打算放上代码~~   

```
#include <algorithm>
#include <iostream>
#include <cstdio>
#define ll long long

using namespace std ;

int pri[15] = {0,2,3,5,7,11,13,17,19,23,29,31};
//最小的11个质数 
ll best = -1 , num = -1 ;
//万一答案是0呢？ 
int n ;

void dfs(ll x  , int rest , int m, int up)
//x为当前数字的大小，m为当前数字约数的个数
//rest为当前质数的编号，up为小于三十的当前指数和
{
    if(m > best || (m == best && x < num))
        num = x , best = m ;
        //根据性质一的更新答案过程 
    ll ans = x ;
    int i = 0 ;
    while(i < up)
    {
        ++ i ;
        if(n / ans < pri[rest]) 
        //保证总乘积不超过N 
            return ;
        int kkk = m * (i + 1 ) ;
        ans *= pri[rest] ;
        if(ans <= n)
            dfs(ans , rest + 1 , kkk , i) ;
            //保证了质数的单调递减 
    }
    //加上这两个搜索的剪枝，就会感到dfs快的飞起  哈哈哈 
}

int main()
//及其卑微的主函数 
{
    scanf("%d" , &n) ;
    dfs(1 , 1 , 1 , 30);
    printf("%lld\n" , num);
}
```
~~看懂再抄谢谢~~

---

## 作者：老K (赞：80)

设$x=\prod{p_i}^{k_i}$，则显然$d(x)=\prod(k_i+1)$

设$p_i$严格递增，并且$k_i=0$也算在内，则如果$k_x< k_y$并且$x< y$，那么显然这个数不可能是反素数，因为交换$k_x$和$k_y$会更好。

所以当$p_i$递增时$k_i$是递减的，这个数x才可能是反素数。

所以我们可以据此搜索。

素数表可以筛一波，也可以这样：

因为前12个素数的积>$2\times 10^9$，所以最多用到12个素数，手动打表。

其实爆搜也很快啊。

可以A掉

```CPP
/*
Author: CNYALI_LK
LANG: C++
PROG: 1463_1.cpp   //这个_1是指第二种方法代码，显然第一种是和前面一样的。
Mail: cnyalilk@vip.qq.com
*/
#include<bits/stdc++.h>
#define debug(...) fprintf(stderr,__VA_ARGS__)
#define DEBUG printf("Passing [%s] in LINE %lld\n",__FUNCTION__,__LINE__)
#define Debug debug("Passing [%s] in LINE %lld\n",__FUNCTION__,__LINE__)
#define all(x) x.begin(),x.end()
using namespace std;
const double eps=1e-8;
const double pi=acos(-1.0);
typedef long long ll;
typedef pair<ll,ll> pii;
template<class T>ll chkmin(T &a,T b){return a>b?a=b,1:0;}
template<class T>ll chkmax(T &a,T b){return a<b?a=b,1:0;}
template<class T>T sqr(T a){return a*a;}
template<class T>T mmin(T a,T b){return a<b?a:b;}
template<class T>T mmax(T a,T b){return a>b?a:b;}
template<class T>T aabs(T a){return a<0?-a:a;}
#define min mmin
#define max mmax
#define abs aabs
ll read(){
    ll s=0,base=1;
    char c;
    while(!isdigit(c=getchar()))if(c=='-')base=-base;
    while(isdigit(c)){s=s*10+(c^48);c=getchar();}
    return s*base;
}
char WritellBuffer[1024];
template<class T>void write(T a,char end){
    ll cnt=0,fu=1;
    if(a<0){putchar('-');fu=-1;}
    do{WritellBuffer[++cnt]=fu*(a%10)+'0';a/=10;}while(a);
    while(cnt){putchar(WritellBuffer[cnt]);--cnt;}
    putchar(end);
}
const ll p[]={0,2,3,5,7,11,13,17,19,23,29,31,37};
ll sc[20],tc[20],tt[20],n,ansx,ansy;
void dfs(ll x){
    for(tt[x]=1,sc[x]=sc[x-1]*p[x],tc[x]=tc[x-1]<<1;tt[x]<=tt[x-1]&&sc[x]<=n;++tt[x],tc[x]+=tc[x-1],sc[x]*=p[x]){
        if(chkmax(ansx,tc[x]))ansy=sc[x];
        else if(ansx==tc[x])chkmin(ansy,sc[x]);
        dfs(x+1);
    }

}
int main(){
#ifdef cnyali_lk
    freopen("1463_1.in","r",stdin);
    freopen("1463_1.out","w",stdout);
#endif
    n=read();
    sc[0]=1;
    tc[0]=1;
    tt[0]=23333;
    ansx=1;ansy=1;
    dfs(1);
    printf("%lld\n",ansy);
    return 0;
}


```


---

## 作者：Goes (赞：73)

秒完之后一想，不对，数据这么大，应该打表！


然后打了一个表，试图找出其中的规律，最后放弃了

看着总觉得其中隐藏着什么不为人知的规律，可是，，，

不过同桌的frf却是天才地一个一个慢慢把答案打了出来(大概可以满分吧。。。。）


放弃了规律，忽然发现这是一道数学题

【注意，正文来了


/\* 神奇的结论

int a[]=质数 ,k[]=指数

n= a[1]^k[1] \* a[2]^k[2] \*…..a[n]^k[n]

约数个数 t=(k[1]+1)(k[2]+1)…..\*(k[n]+1)


枚举每一个质数指数 搜最大答案

转念一想，这虽然比暴力好了许多，不过大概会挂


这时我们就要有一些优化的思路：

这些思路的主旨就是在约数个数相同的情况下尽可能地让当前数小


比如：

1、第一种情况：6=2\*3 10=2\*5

这是一种约数不同的例子，所以我们枚举质数的时候要从小到大枚举

2、第二种情况：12=2^2\*3 18=3^2\*2

这时一种指数不同的例子，所以我们就可以推得较大的质数的指数一定小于较小的质数的指数


\*/





```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int n;
int p[20]={0,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,51};
long long maxn=-1,num=-1;
void get(long long m,int f,int t,int pr)
{//f为当前质数的编号 ,当前指数<pr
//t为当前约数的个数 
    if(t>maxn||(t==maxn&&m<num))
        num=m,maxn=t;
    int j=0,nt;
    long long i=m;
    while(j<pr)
    {
        j++;
        if(n/i<p[f])break;
        nt=t*(j+1);
        i=i*p[f];
        if(i<=n)    get(i,f+1,nt,j);
    }
}
int main()
{
    cin>>n;
    get(1,1,1,30);
    cout<<num;
}
```

---

## 作者：s_r_f (赞：49)

这篇题解之前的一些题解的优化：

1、指数单调不增；

2、用前k个质数搜索。

我们来加两个优化把它优化到0ms.

显然，我们要**限制每个质数的指数**。

对于3，5，7...(这个质数设为p)的指数(设为q)(假设2的指数为q1,下文同上)：

设K(p) = 最小的使2^k(2的k次方)大于p的数字k。

则：2^k > p , 2^(k-1) < p

( 2^q1 )( p^q ) > ( 2^(q1+k-1) ) ( p^(q-1) )

我们要求反质数，所以：

(q1+1)(q+1) < q(q1+k)

化简得到：q < (q+1) / (k-1) [ 注意：这里不是整数除法！！！ ]

就可以限制除了2之外所有质数的指数了。

OK！

那么对于2：

我们设k , ....(见上文,其中的p改为**不出现**在反质数中的质因数的质数)

则：

2^q1 > 2^(q1-k) * p

我们要求反质数，所以：

q1+1 > (q1-k+1) * 2

化简得：

q1 < 2K-1.

于是我们就有了两个强大的剪枝条件。

0msAC代码：

```
#include <bits/stdc++.h>
#define LL long long
using namespace std;

inline LL read(){
    LL x = 0,f = 1; char c = getchar();
    while (c < '0' || c > '9') {if (c == '-') f = -1;c = getchar();}
    while (c <='9' && c >='0') {x = x * 10 + c - '0';c = getchar();}
    return x * f;
}

inline void write(LL x){
    LL k = 0,lx = x;char put[40];
    if (lx ==0) putchar('0');
    if (lx < 0) putchar('-'),lx = -lx;
    while (lx)  put[++k] = (lx % 10) + '0',lx /= 10;
    while (k)   putchar( put[ k-- ] );
    putchar('\n');
}

int K(int x){//K()函数
	int ans = 0;
	for (ans = 0; (1<<ans) <= x; ++ans) ;
	return ans;
}

LL n,ans,mxtot;
const int p[16] = {1,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47};
int limit_p[16],p1;

void dfs(LL i,LL tot,LL now,LL mxw){
     if (now > n) return;
     
     if (i>1){ //limit_p[i] = (long double)1.0 * (p1+1) / (K(p[i]) - 1);
		 if ((p1+1) % (K(p[i]) - 1)) limit_p[i] = (p1+1) / (K(p[i]) - 1) + 1;
		 else limit_p[i] = (p1+1) / (K(p[i]) - 1);
	 }//算出当前的指数限制
	 
     LL num = now * p[i],w = 1,ntot = tot;
     while (num <= n && w <= mxw && w < limit_p[i]){
     	ntot = tot * (w + 1);
     	if (ntot > mxtot) mxtot = ntot,ans = num;
     	if (ntot == mxtot && num < ans) ans = num;
     	
     	if (i == 1) p1 = w;//记录p1
     	
     	dfs(i+1,ntot,num,w);
     	num *= p[i],++w;
     }
}

void work(){//求出p1的限制
	long long x = 1,t = 0;
	for (int i = 1; i <= 15 && x <= n; ++i) x *= p[i],t = i;
	t = K( p[t] ) * 2 - 1;
	limit_p[1] = t;
}

int main(){
    n = read();
    if (n == 1) {//特判（我也不知道这东西有什么用）
    	cout << 1 << endl;
    	return 0;
    }
    
    ans = 1; mxtot = 1;
    
    work();//求出p1的限制
    
    dfs(1,1,1,20);//搜索
    write(ans);
    return 0;
}
```

---

## 作者：shenbear (赞：37)

# 骗分过样例，打表出奇迹

一楼大佬很牛逼强无敌了，和我想法异曲同工

很多人，在一楼疑惑这表怎么打的，我来详细解释一下

首先看暴力打表复杂度O（n^3/2）

理论上来说，假设电脑跑的快，1s1e9那么我们要跑2.828e6次，至少3天

但是我们打一个小一点的表

1,2,4,6,12,24,36,48,60,120,180,240,360,720,840,1260,1680,2520,5040,7560,10080,15120,20160,25200,27720,45360,50400,55440,83160,110880,166320,221760,277200,332640,498960,554400,665280,720720,1081080,1441440,2162160,2882880,3603600,4324320,6486480,7207200,8648640,10810800,14414400,17297280,21621600,

仔细观察，发现

6,12,24,36,48,60

60，120,180,240,360,720,840

**都是以一个差的倍数增加的，所以我们可以先跑5分钟跑一个小表，再用这个倍数来跑真正的表**

1,2,4,6,12,24,36,48,60,120,180,240,360,720,840,1260,1680,2520,5040,7560,10080,15120,20160,25200,27720,45360,50400,55440,83160,110880,166320,221760,277200,332640,498960,554400,665280,720720,1081080,1441440,2162160,2882880,3603600,4324320,6486480,7207200,8648640,10810800,14414400,17297280,21621600,32432400,36756720,43243200,61261200,73513440,110270160,122522400,147026880,183783600,245044800,294053760,367567200,551350800,698377680,735134400,1102701600,1396755360,



------------
代码：

打小表的：
```cpp
#pragma GCC optimize(2)
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n,mx;
inline int f(int x)
{
	int s=0;
	for(int i=1;i*i<=x;i++)
	{
		if(x%i==0) s+=2;
		if(i*i==x) s--;
	}
	return s;
}
inline void print(int x)
{
	if(x>9) print(x/10);
	putchar(x%10+48);
}
main()
{
	freopen("fssa.out","w",stdout);
//	cin>>n;
	scanf("%lld",&n);
//	printf("%d\n",n);
	for(int i=1;i<=n;i++)
	{
		if(f(i)>mx)
		{
			print(i);
			putchar(',');
			mx=f(i);
		}
	//	printf("%d ",i);
	}
	return 0;
}

```
打全表的
```cpp
#pragma GCC optimize(2)
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n,mx;
inline int f(int x)
{
	int s=0;
	for(int i=1;i*i<=x;i++)
	{
		if(x%i==0) s+=2;
		if(i*i==x) s--;
	}
	return s;
}
inline void print(int x)
{
	if(x>9) print(x/10);
	putchar(x%10+48);
}
inline int fuc(int x)
{
	if(x<6) return 1;
	if(x<60) return 6;
	if(x<332640) return 60;
	if(x<720720) return 5040;
	else return 360360;
}
main()
{
	freopen("fssb.out","w",stdout);
//	cin>>n;
	scanf("%lld",&n);
//	printf("%d\n",n);
	for(int i=1;i<=n;i+=fuc(i))
	{
		if(f(i)>mx)
		{
			print(i);
			putchar(',');
			mx=f(i);
		}
	//	printf("%d ",i);
	}
	return 0;
}

```

AC的：
```
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 1e6+6;
ll n,ans;
int a[N]={1,2,4,6,12,24,36,48,60,120,180,240,360,720,840,1260,1680,2520,5040,7560,10080,15120,20160,25200,27720,45360,50400,55440,83160,110880,166320,221760,277200,332640,498960,554400,665280,720720,1081080,1441440,2162160,2882880,3603600,4324320,6486480,7207200,8648640,10810800,14414400,17297280,21621600,32432400,36756720,43243200,61261200,73513440,110270160,122522400,147026880,183783600,245044800,294053760,367567200,551350800,698377680,735134400,1102701600,1396755360};
int main()
{
	cin>>n;
	for(int i=N-1;i>=0;i--)
	{
		if(a[i]&&a[i]<n)
		{
			printf("%d\n",a[i]);
			break;
		}
	}
	return 0;
}

```
小结：

虽然打表不是什么正经的做法，但是能AC就是吼方法，而且这本来就是打表系列的

经过这次打表，我对打表及枚举也有了更深刻的理解

最后祝大家在csp2019中也能出奇迹


---

## 作者：diu· (赞：27)

### emmm~相信大佬们很容易就过了

#### 所以本蒟蒻就直接上代码了

#### 思路之类的-注释里面应该很清楚了（嘿嘿）

```cpp
# include <algorithm>
# include <cstdio>
# include <cstring>
# include <iostream>
using namespace std;
long long qqw,ans=-1,n;                                         //qqw-指数个数,ans-存答案,n-输入数据
int num[20]={0,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47};       //素数(相乘即可超2e9)
//x-对应num数组内素数值,y-计算的次方数,t-当前数值,sum-当前指数的总值
void dfs(long long x,long long y,long long t,long long sum)
{
    if(t > n)  return ;                                         //如果当前值超过n,返回
    if(x > 15) return ;                                         //超过数组内储存的值个数即返回
    if(sum > qqw)
    {
        qqw=sum;
        ans=t;
    }
    else
        if(sum == qqw)
            ans=min(ans,t);

    for(int i = 1;i <= y;i++)
    {
        t*=num[x];
        if(t > n) return ;                                      //如果已经超范围,返回
        dfs(x+1,i,t,sum*(i+1));                                 //枚举乘下一个素数的情况
    }
}

int main()
{
    scanf("%d",&n);
    dfs(1,35,1,1);
    cout<<ans<<endl;
    return 0;
}

><

```

￣ω￣=(说不定有意想不到的作用哦~)

---

## 作者：ミク (赞：16)

#### 既然这道题收在了「省选基础-打表」里，那么我就来写一个打表的做法。

对于这个数据范围 $ (n \leq 2×10^9) $ ，一次性肯定不能把表打出来。所以我们先打一部分进行尝试。先解决 $ (n \leq 5×10^8) $ 的情况。
~~本蒟蒻实在太菜所以打表的算法跑得不是很快。但还是可以在十分钟内跑出来的。~~

```cpp
#include<cstdio>
using namespace std;
short a[500000001];
int main()
{
	for(int i=1;i<=500000000;++i)
		for(int j=i;j<=500000000;j+=i)
			a[j]++;
	int maxn=0;
	for(int i=1;i<=500000000;++i) 
    	if(a[i]>maxn) {maxn=a[i];printf("%d,",i);}
	return 0;
}
```

当打出了 $ 0 $ 到 $ 5×10^8 $ 范围的表之后，我们可以发现打出来的数很少，也就是说此题可以通过打表解。然后，我们可以求出这次打表打出来的最后一个数的约数个数，于是我们可以知道，约数个数不会超过short的范围。

由于short最大可以开到5e8（本机），那么我们可以分四次将表打全。我们可以将上次打表所求出的最后一个数的约数个数作为此次打表的maxn。

这里提供第二次打表的代码：

```cpp
#include<cstdio>
using namespace std;
short a[500000001];
int main()
{
	for(int i=1;i<=1000000000;++i)
		for(int j=(500000000/i)*i+i;j<=1000000000;j+=i)
			a[j-500000000]++;
	short maxn=1152;
	for(int i=1;i<=500000000;++i) if(a[i]>maxn) {maxn=a[i];printf("%d,",i+500000000);}
	return 0;
}
```

于是，我们可以将四次打表的结果组合起来得到一个完整的表。

表打完后用二分或直接暴力找到第一个小于等于n的数即可。

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int a[100001]={1,2,4,6,12,24,36,48,60,120,180,240,360,720,840,1260,1680,2520,5040,7560,10080,15120,20160,25200,27720,45360,50400,55440,83160,110880,166320,221760,277200,332640,498960,554400,665280,720720,1081080,1441440,2162160,2882880,3603600,4324320,6486480,7207200,8648640,10810800,14414400,17297280,21621600,32432400,36756720,43243200,61261200,73513440,110270160,122522400,147026880,183783600,245044800,294053760,367567200,551350800,698377680,735134400,1102701600,1396755360,2000000001};
int main()
{
    int n;
    scanf("%d",&n);
    int num=lower_bound(a,a+68,n)-a-1;
    if(a[num+1]&&a[num+1]<=n) ++num;
    printf("%d",a[num]);
    return 0;
}
```

---

## 作者：Lyrics (赞：13)

这道题实际上是求1~n中因数最多的数中最小的。

因为我们知道，任意一个大于1的整数都可以拆分成多个质数（或质数的幂）相乘

所以我们可以用前几个质数（10几个就够了【标签的打表题应该就是在这里打表了】）构建反素数。

为什么是十几个呢？我们看一下题目的数据范围，一个数N（1<=N<=2,000,000,000）。

【而前9个质数2\*3\*5\*7\*11\*13\*17\*19\*23\*29=6,469,693,230>2,000,000,000】所以实际上只需要前10个质数就可以啦

那么我们每个数S必然可以分解为S=2^x1+3^x2+...+p^xn(p仍旧为质数）

因数的总数cnt=(x1+1)\*(x2+1)\*(x3+1)\*……

我去网上找了个证明：http://blog.csdn.net/baidu\_36786519/article/details/53727982

我们需要构建其中因数最多的。因数最多的若有多个则取最小的其中一个并且输出。

但是x1,x2,x3这样的的数怎么枚举呢？

我们不难发现，x1,x2,x3是严格不上升的。为什么呢？

证明：若存在两个数，a^x1+b^x2,和a^x2+b^x1。a<b,x1>x2。两个数的因数个数相同，但是第一个比较小，所以选择第一个。

所以我们这题就大概这么结束了！

CODE:
```cpp
#include<bits/stdc++.h>
using namespace std;
int num[1000]={0,2,3,5,7,11,13,17,19,23,29,31,33};
long long i,j,n,ans,best;
void dfs (long long x,long long y,int z){
    if (x>best)    {
        best=x;
        ans=y;
    }
    if(x==best&&ans>y)ans=y;
    if(z>11)return; 
    for(int i=1;i<=50;i++){
        if(y*num[z]>n)break;
        dfs(x*(i+1),y*num[z],z+1);
        y*=num[z];
    }
}
int main(){
    scanf("%lld",&n);
    ans=10000000;
    dfs(1,1,1);
    printf("%lld",ans);
}
```

---

## 作者：Ajwallet (赞：13)

设$c(y)$表示有$y$个因数的最小的正整数，当$c(y)<c(y+1),c(y+2),c(y+3),c(y+4)……$时，$c(y)$就是一个反素数

那么现在问题就变成了如何去求$c(y)$，考虑动态规划，
设$f[x,y]$表示有$x$个不同的质因数，因数的个数$\leq y$的最小正整数，那么就可以想到这$x$个不同的质因数一定是连续的最小质数

然后就得到了状态转移方程
## $$f[x,y]=f[x-1,\frac{y}{k+1}]*p_x^k (1<=k<=y)(k+1|y)$$

$p_x$为筛出的质数

现在我们考虑去优化这个方程

方程中有一个很讨厌的$(k+1)|y$，我们想办法把它弄掉

在我们进行动态规划的时候，求$f[x,y]$需要去找$f[x,^…]$，十分浪费时间，因为这些枚举的数很多数都不是$y$的因数，所以我们在处理完$f[x,y]$时，可以把$f[x,y$的倍数$]$顺便算出来，就节约了很多时间

还有就是，在进行动态规划的时候，每次都要去找所有当前质因子中指数最小的那个，太过浪费时间，所以可以用一个$min$去维护

最后我们还可以打滚动数组压缩一下空间

代码很长，估计很少人会用这种方法，但希望管理员给过

# 40$ms$代码
（因为预处理的时候每次耗费的时间都是一样的，所以比较慢）
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cmath>
#define N 170000
#define M 100
#define r(i,a,b) for(int i=a;i<=b;i++)
using namespace std;
int min1[N+1],min2[N+1],ans;
bool vis[M+1];
long long a[300],p[M+1],f[N+1],f1[N+1],m[N+1],t;
long long maxn=9223372036854775807LL,x,l,r;
string name,num,name2;
void make1(int i)//滚动数组1
{
       r(j,1<<(i+1),N) f1[j]=maxn;//这也是初始化
        r(j,1<<i,N)
        {
            if(f[j]==maxn) continue;//超出范围不管它
            m[j]=min(m[j],f[j]);//这其实相当于一个初始化了
            double y=log(maxn/f[j])/log(p[i+1]);
            y=min(y,min((double)(N/(j+1)-1),(double)min1[j]));//计算可以转移到的最大值，因为要保证不越出范围所以要用min
            t=1;
            r(k,1,y)
            {
                t*=p[i+1];
                if(f[j]*t<f1[j*k+j])//动态转移
                {
                    f1[j*k+j]=f[j]*t;//动态转移
                    min2[j*k+j]=k;//动态转移
                }
            }
        }
}
void make2(int i)//滚动数组2，以下做法同上，这里就不给出详细解释了
{
       r(j,1<<(i+1),N) f[j]=maxn;
        r(j,1<<i,N)
        {
            if(f1[j]==maxn) continue;
            m[j]=min(m[j],f1[j]);
            double y=log(maxn/f1[j])/log(p[i+1]);
            y=min(y,min((double)(N/(j+1)-1),(double)min2[j]));
            t=1;
            r(k,1,y)
            {
                t*=p[i+1];
                if(f1[j]*t<f[j*k+j])
                {
                    f[j*k+j]=f1[j]*t;
                    min1[j*k+j]=k;
                }
            }
        }
}
int main()
{
    r(i,2,M)//筛素数的个数
    {
        if(!vis[i]) p[++p[0]]=i;
        r(j,1,p[0])
        {
            if(M/p[j]<i) break;
            vis[i*p[j]]=true;
            if(i%p[j]==0) break;
        }
    }
    f[1]=1;
    r(i,2,62) {f[i]=f[i-1]<<1;min1[i]=i-1;}
    r(i,63,N) f[i]=maxn;
    r(i,2,N) m[i]=maxn;//以上初始化
    r(i,1,16)
    if(i&1) make1(i);else make2(i);//动态转移
    r(i,1<<17,N) m[i]=min(m[i],f[i]);//保存答案
    x=maxn;
    for(int i=N;i>1;i--)//因为是求反素数，所以要倒过来
    if(m[i]<x)//这是反素数
    {
        a[++a[0]]=m[i];//放入数组a
        x=m[i];
    }
    cin>>l>>r;
    r(i,1,a[0]) if(a[i]>=l&&a[i]<=r) ans++;//统计个数
    printf("%d\n",ans);
    for(int i=a[0];i>0;i--) if(a[i]>=l&&a[i]<=r) cout<<a[i]<<' ';//输出
}
```

---

## 作者：Social_Zhao (赞：8)

提供一个随便口胡的证明过程。

## 题目大意

设 $d(n)$ 表示 $n$ 的约数个数，求最大的 $x$ 满足   $\forall i \in (0, x), d(i)<d(x)$。

## 问题的转化

问题可以转化为：

1. 求 $[1, n]$ 因数个数最多的数。

2. 若相同的值有多个，则取最小值。

### 证明

假设 $x$ 为唯一的因数个数最多的数，显然 $x$ 一定是一个反素数。再假设有一个更大的反素数 $y$ 满足 $y > x,d(y) < d(x)$，则与反素数的定义相矛盾，故**因数个数最多的数为区间内最大的反素数**。

如果存在多个相同的最大值，那么显然除了第一个，都不是反素数。

## 解法

根据**唯一分解定理**，我们有：对于任意一个正整数 $x$，它可以写成 $\prod p_i^{a_i}$，其中 $p_i$ 为质数，$a_i \in [0, \infin]$。

根据**乘法原理**，有 $d(x)=\prod(a_i + 1)$。

所以我们可以考虑搜索 $a_i$，求出 $d(x)$。

但是我们知道素数有无穷多个，所以我们需要进一步的推导。

结论：$a_i$ 是单调不升的。

### 证明

设 $x = \prod p_i^{a_i}$ 是反素数，其中 $a_i$ 是无序的。

设 $a_i$ 降序排序后变成了 $b_i$，$y = \prod p_i^{b_i}$，显然 $y < x$ 而 $d(y)=d(x)$。

根据上方**问题转化-2**，我们可以知道，$x$ 不是反素数，与假设相悖。

也就是说，$a_i$ 是有序的。

所以我们只需要前面的少数素数就可以了。

参考 [oeis A002110](https://oeis.org/A002110) 我们发现第 10 个素数的前缀积已经超过了数据范围，因此我们可以只用 10 个素数。

## 代码

根据以上的推理我们可以写出代码。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

const int prime[] = {0,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,51};
int f[20], n, AnsNum, AnsDiv;

//dfs: {Current Depth, Current Number, Current Divisors}

inline void dfs(int dep, int num, int div) {
    if(div > AnsDiv || (div == AnsDiv && num < AnsNum)) AnsNum = num, AnsDiv = div;
    if(dep > 10) return;
    int nxp = 1;
    for(register int i = 1; i <= f[dep - 1]; i++) {
        nxp *= prime[dep];
        f[dep] = i;
        int NewNum = num * nxp, NewDiv = div * (i + 1);
        if(NewNum > n) break;
        dfs(dep + 1, NewNum, NewDiv);
    }
}

signed main() {
    scanf("%lld", &n);
    f[0] = 30;
    dfs(1, 1, 1);
    printf("%lld", AnsNum);
    return 0;
}
```



---

## 作者：LYYY (赞：7)

# 打表
我一开始是打算写正解的，但是看了看dalao们的题解，就扼杀了蒟蒻我写正解的想法，于是自己yy了一种打表

------------
------------
相信不会有比我还快用程序打的表了qwq（其实也不算纯打表，完全可以打表顺便AC）


------------
言归正传




1,2,4,6,12,24,36,48,60,120,180,240,360,720,840,1260

先给出前几个反质数

我们可以发现相邻两个数之间的差值在近似地增大，为什么说近似呢，因为差值：

1,2,2,6,12,12,12,12,60,60,60,120,360,120,420

我们可以发现：360到720增了360，而720到840只增了120，所以大胆猜想：

**相邻两个反质数之间的差值会近似地单调递增，而且数字与差值之间存在一定倍数关系。**

所以我们在枚举（打表）时，不用一个一个地试，可以以之前的差值为单位增加，只尝试以这个差值为倍数的数，使时间复杂度会大大降低。而且合适的取值可以达到2e9内100%的正确率并时间允许。

### 详见代码：

```cpp
#include<cstdio>
#include<iostream>
using namespace std;

int n,last,answer;

int chazhi[300];
//存储差值
int head=50,max_i=30;
//差值存储从50开始避免越界
//代码核心：因为差值并不是严格上升的，所以通过调用很早记下来的差值保证正确率（尽管会慢，但正确率会变高，用时间换正确率）
//ps:max_i的值可自定,2e9的范围100%正确率最小max_i为24，本代码用了30AC，不保险可以用40（但会很慢1min左右，可以先打表再做）
//函数名通俗易懂：求x约数个数
int geshu(int x){
	int ans=1;
	for(int i=2;i*i<=x;i++){
		int tot=1;
		while(x%i==0){
			x/=i;
			tot++;
		}
		ans*=tot;
	}
	if(x!=1)ans<<=1;
	return ans;
}

int main(){
	scanf("%d",&n);
    
	for(int i=1;i<=head;i++) chazhi[i]=1;
    //初始化为1，先以1位单位增长
    
	for(int i=1;i<=n;i+=chazhi[head-max_i]){
    //核心：以往前数第max_i个差值(即chazhi[head-max_i])为单位增长
		int lll=geshu(i); 
        
		if(lll>answer){
        
			chazhi[++head]=i-last;
			answer=lll;
			last=i;
            //更新并存储差值
            
            printf("the %dth answer lower is:%d\n",head-50,last);
            //该输出为打表
		}
	}
	printf("%d",last);//答案
    
	return 0;
}
```

附2e9内反质数表

```cpp
//共68个   1,2,4,6,12,24,36,48,60,120,180,240,360,720,840,1260,1680,2520,5040,7560,10080,15120,20160,25200,27720,45360,50400,55440,83160,110880,166320,221760,277200,332640,498960,554400,665280,720720,1081080,1441440,2162160,2882880,3603600,4324320,6486480,7207200,8648640,10810800,14414400,17297280,21621600,32432400,36756720,43243200,61261200,73513440,110270160,122522400,147026880,183783600,245044800,294053760,367567200,551350800,698377680,735134400,1102701600,1396755360
```

 _谢谢阅览_ 

---

## 作者：Dragon_hao (赞：4)

爆搜dfs。

首先我们要知道任何一个数都可以通过分解质因数，用质数的乘积来表示。而寻找一个数的约数，也就是看这些质数能够组成多少个数。所以一个数被分解成的质数越多，解越优。

观察数据范围，如果将n以内的数分解质因数，然后寻找约数个数，那么最优解一定是质数越小越好，因为这样的话可以组成更多的约数，10个最小的质数的乘积为6469693230，大于n的最大取值，所以我么可以先将这10个最小的质数存起来，然后用这10个质数进行组合，在n以内寻找约数最多的数。

每次枚举当前质数的次数i，直到枚举出的质数的积与当前已经组成的数的乘积大于n。

若当前还未组成一个数，那么这次枚举得到的数的约数为(i+1)，为什么要加1呢？因为1也是它的因数！！！

之后对于已经组成数的情况，他们的约数互不相同，根据乘法原理，可以用已经找出的因数的个数num乘以(i+1)，而这里为什么要加1呢？num * i表示用num个约数，与当前质数的(1,2,3...i)次方组合形成的新的约数，而num * 1表示原来的num个约数。不断更新约数最大的数即可。
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#define ll long long
using namespace std;
int flag,maxn,a[11]={0,2,3,5,7,11,13,17,19,23,29};
ll n,b[11],ans;
ll ksm(int x,int y)
{
	ll kk=1,now;now=x;
	while(y)
	{
		if(y&1) kk*=now;
		y/=2;
		now*=now;
	}
	return kk;
}
void dfs(int dep,ll x,ll now,int num,int time)
{
	if(num>maxn)
	{
		maxn=num;
		ans=now;
	}
	if(num==maxn) ans=min(ans,now);
	if(dep==11) return;
	for(int i=0;;i++)
	{
		ll k=ksm(a[dep],i)*now;
		if(k>x) return;
		else if(i==0) dfs(dep+1,x,now,num,time);
		else if(num==0) dfs(dep+1,x,k,i+1,time+1);
		else dfs(dep+1,x,k,num*(i+1),time);
	}
}
int main()
{
	scanf("%lld",&n);
	ans=1;dfs(1,n,1,0,0);
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：_wkjzyc (赞：4)

### 题意：

求最小的$x\in[1,N]$，使得$x$为$g(x)$最大的数  中最小的一个。

### 分析：

 1.$x$不会有超过$10$个不同质因子。
 
 $2 \times 3\times 5...\times 31>2\times 10^9$
 
 $2\times 3\times 5...\times 29<2\times 10^9$。
 
 $2$至$29$质数刚好$10$个。

 2.质因子指数不会大于$30$。理由：当取最小的质因子$2$时，$231>2\times 1e9$，$230<2\times 10^9$。

 3.若$x=p_1^{c_1}p_2^{c_2}...p_n^{c_n}$，则x的因子个数为$(c_1+1)(c_2+1)...(c_n+1)$。即：$g(x)=(c_1+1)(c_2+1)...(c_n+1)$。

 4.质因子连续。
 
 反证法。若所求$x=p_1^{c_1}p_2^{c_2}...p_n^{c_n}$，且存在$p_{n-1}<p'<p_n$（即质因子不连续），则 
$x_0=p_1^{c_1}p_2^{c_2}...p_{n-1}^{c_{n-1}}p'^c_n<x$
，$g(x_0)=g(x)$，不符合题意。

 5.指数不升
 
若存在$c_n>c_{n-1}$，则将$c_n$，$c_{n-1}$位置交换能使x更小，也不符合题意

综上所述，可以用上述几个约束条件进行搜索剪枝。

代码就是简单的$DFS$。

```cpp
#include<iostream>
#include<vector>
typedef long long ll;
using namespace std;
const ll pa[16]={0,2,3,5,7,11,13,17,19,23,29};
ll n,ans=1,g=0;

void dfs(ll p,ll t,ll now,ll ng)
{
    if(now>n) return;
    if(p>10) return;
    ll temp=ng;
    for(ll i=1;i<=t;i++){
        now*=pa[p];
        ng=temp*(i+1);
        if(now>n) return;
        if(ng>g) ans=now,g=ng;
        if(ng==g) ans=min(now,ans);
        dfs(p+1,i,now,ng);
    }
}

signed main()
{
    cin>>n;
    dfs(1,30,1,1);
    cout<<ans;
    return 0;
}
```
//
$19-3-24$
修改了部分$L^AT_EX$


---

## 作者：AcerMo (赞：4)

先说一些显然的东西，当几个数的因数个数相同时，小的数更符合要求，那么显然的是，把这几个数分解质因数，越小的数的越小的质因子越多，那么可以发现，它的质因子的幂一定是递减的，且根据数据范围 ，我们可以得到在这个范围内，最多可以有不超过12个的质因子，所以直接暴搜就好
```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
int pri[20]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53};
long long int n,ans=1,que=1;
void dfs(int dep,long long int tmp,int tot,int mks)
{
	if (dep==12)
	{
		if (tmp>ans&&tot>que) ans=tmp,que=tot;
		if (tmp<=ans&&tot>=que) ans=tmp,que=tot;
		return ;
	}
	int t=1;
	for (int i=0;i<=mks;i++)
	{
		dfs(dep+1,tmp*t,tot*(i+1),i);
		t*=pri[dep];
		if (tmp*t>n) return ;
	}
	return ;
}
int main()
{
	cin>>n;
	dfs(0,1,1,20);
	cout<<ans;
	return 0;
}
```

---

## 作者：夜枭只会舔fufu (赞：4)

da jia hao wo you lai gei ni men shui ti jie la
------------
说人话！！
------------
（大家好，我又来给你们水题解啦）！！

期中考试考完了，大家都考的怎么样呢？？？

（肯定有满分的大佬吊打我）

```
#include<bits/stdc++.h>//头文件
using namespace std;//命名空间
int i=0;//指针
int a[500001]={1,2,4,6,12,24,36,48,60,120,180,240,360,720,840,1260,1680,2520,5040,7560,10080,15120,20160,25200,27720,45360,50400,55440,83160,110880,166320,221760,277200,332640,498960,554400,665280,720720,1081080,1441440,2162160,2882880,3603600,4324320,6486480,7207200,8648640,10810800,14414400,17297280,21621600,32432400,36756720,43243200,61261200,73513440,110270160,122522400,147026880,183783600,245044800,294053760,367567200,551350800,698377680,735134400,1102701600,1396755360,2001000000};//密密麻麻的表
int main()//主函数
{
    int n;//定义范围
    cin>>n;//输入
    while(111111111111111111111111111111)
    {
        i++;//指针+1
        if(a[i]>n)//当a[i]>n时
        {
            i--;//上一个肯定小于n(指针返回上一个数）
            cout<<a[i]<<endl;//输出这个数
            return 0;//完结撒花
        }
    }
    return 0;//完结撒花
}
```
<<fog<<逃

!0_0

~~大佬们应该懂了把把把把把把把~~

---

## 作者：孤叶残影 (赞：3)

# 约数个数表示法：
### 设M=2^t1×3^t2×……×p^tk（其中p是第k大的质数）,则有m的约数个数s1=(t1+1)(t2+1)(t3+1)...(tk+1)


------------
# 定理:
### 设M=2^t1×3^t2×……×p^tk是Antiprime数,则必有t1>=t2>=t3>=...>=tk>=0

------------
# 证明
### 若不满足,则将ti由大到小排序,形成新有序序列ti',t1'=t2'=t3'=...>=tk'=0。令M'=2^t1'×3^t2'×...×p^tk'
### 显然m'<m，且m与m'的约数个数相同，与Antiprime数定义相违背，顾原命题成立

------------
# 剪枝1：
### 由于2^31=2 147 483 648>n，则递归层数<=31,顾设定层数限定31层

------------
# 剪枝2：
### 由t1>=t2>=t3>=...>=tk>=0得，质因子个数最多为十一个

------------


```cpp
#include<stdio.h>
using namespace std;
int a[20]={0,2,3,5,7,11,13,17,19,23,29};//最多11个质数
long long n,s,sl;
inline void dp(long long x,long long y,long long b,long long z)
{
	if(x==11) return;
	long long i,k=1;
	for(i=1;i<=b;i++)
	{
		k*=a[x];
		if(y*k>n) return;//剪枝2
		if(z*(i+1)==sl&&y*k<s) s=y*k;//质因子个数在1~b间
		if(z*(i+1)>sl) 
		{
			s=y*k;
			sl=z*(i+1);
		}
		dp(x+1,y*k,i,z*(i+1));
	}
}
int main()
{
	scanf("%lld",&n);
	dp(1,1,31,1);
	printf("%lld",s);
	return 0;
}
```


---

## 作者：eros1on (赞：2)

~~[博客食用更佳](https://tle666.github.io/2019/05/17/[HAOI2007]%20%E5%8F%8D%E7%B4%A0%E6%95%B0/)~~

# **Description**

对于一个数 $x$ ，只要它满足对于任意一个 $< x$ 的数 $i$ ，均有 $g(i) < g(x)$，其中 $g(i)$ 表示 $i$ 的约数个数。

[题目连接戳这里](https://www.luogu.org/problemnew/show/P1463)

# **Solution**

设答案为 ans 。则有

$$ans = 2^{\alpha_1} \cdot 3^{\alpha_2} \cdot 5^{\alpha_3} \cdot ... \cdot 31^{\alpha_{11}}$$

我们能够得出结论：若果 ans 为反素数，则 $\alpha_1 \geq \alpha_2 \geq \alpha_3 \geq ... \geq \alpha_{11}$

~~口糊~~ 证明：

对于 ${p_1}^{\alpha_1} \cdot {p_2}^{\alpha_2}$ ，假设 $p_1 < p_2$ 且 $\alpha_1 < \alpha_2$ ，则数 ${p_1}^{\alpha_2} \cdot {p_2}^{\alpha_1}$ 必定 $<{p_1}^{\alpha_1} \cdot {p_2}^{\alpha_2}$

但两数的约数个数相等，矛盾！

比如说 $2^3\cdot3^5$ ，则 $2^5\cdot3^3<2^3\cdot3^5$ 但这两个数的约数和却相等。矛盾！

只需暴力递归即可。

# **Code**

```cpp
#include <bits/stdc++.h>

using namespace std;

#define int long long
const int N = 30;

int n, a[N], p[N] = {0, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31};
int ans, mx;

inline int qpow(int a, int b) { // 不必须的快速幂
  int res = 1;
  while (b) {
    if (b & 1) res *= a;
    a *= a, b >>= 1;
  }
  return res;
}

inline void upd(int cur) { // 更新答案
  int res = 1, tmp;
  for (int i = 1; i <= cur; i++)
  res *= (a[i] + 1);
  tmp = 1;
  for (int i = 1; i <= cur; i++)
    tmp *= qpow(p[i], a[i]);
  if (mx < res) {
    mx = res;
    ans = tmp;
  }
  if(mx == res && ans > tmp) // 注意这种情况！
    ans = tmp;
}

inline void dfs(int cur, int cnt, int last) { // 递归
  for (int i = 0; i <= cnt; i++) {
    if (i) last *= p[cur];
    if (last > n) {
      upd(cur);
      return ;
    }
    a[cur] = i;
    if (!i) upd(cur);
    else dfs(cur + 1, i, last);
  }
}

signed main() {
  scanf("%lld", &n);
  dfs(1, 31, 1);
  printf("%lld\n", ans);
  return 0;
}
```



---

## 作者：TangLongbin (赞：2)

这个题硬确实不好做；
所以本人采用打表；
我具体说一下怎么打表；
首先，我们知道对于任意正整数N；
可以将N进行质因数分解（不知道的去百度）；
可以发现只需要10个质数就能把【1,2e10】的数全部质因数分解；
同时我们知道，N的因数个数就是每个质因数的次方+1后的累积；
那么我们去筛数的时候，只需要记录前面我们记录的最大的G（x），如何判断当前G(x)是否大于max（G(i)）;
若满足条件，就记录下来；
最后我们就会得到一张反素数表；
代码如下：
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
using namespace std;
int pnum[11]={2,3,5,7,11,13,17,19,23,27,29};
int maxx;
int cnt(int n,int k){
	int sum=0;
	if(k==11)return 1;
	while(n%pnum[k]==0){
		sum++;
		n/=pnum[k];
	}
	return (sum+1)*cnt(n,k+1);
}

int main(){
	for(register int i=1;i<=2100000000;i++){
		int now=cnt(i,0);
		if(maxx<now){
			maxx=now;
			printf("%d ",i);
		}
	}
	return 0;
}
```
然后输出就行；
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
using namespace std;
long long int ans[100]={1,2,4,6,12,24,36,48,60,120,180,240,360,720,840,1260,1680,2520,5040,7560,10080,
15120,20160,25200,27720,45360,50400,55440,83160,110880,166320,221760,277200,332640,
498960,554400,665280,720720,1081080,1441440,2162160,2882880,3603600,4324320,
6486480,7207200,8648640,10810800,14414400,17297280,21621600,32432400,36756720,
43243200,61261200,73513440,110270160,122522400,147026880,183783600,245044800,294053760,
367567200,551350800,698377680,735134400,1102701600,1396755360,2001000000};
long long int n;
int main(){
	scanf("%lld",&n);
	for(register int i=0;;i++){
		if(ans[i]>n){
			printf("%lld",ans[i-1]);
			return 0;
		}
	}
}
```


---

## 作者：山水一程_ (赞：2)

数论题。DFS。

测试的时候准备打表。当时的思路是每个反质数的因数比上一个反质数多。于是递推，只得了20分。

正解：
对任意一个数可以分解质因数得到::p=2^t1*3^t2*5^t3*7^t4.....；
其因数的个数为：(t1+1)*(t2+1)*(t3+1)......
于是反质数必然t1>=t2>=t3>=....(若对p'有t3>t2,则有p'大于某个与它因数个数相等的数，故p'非反质数)。
也就是说在因数个数相同的情况下，反质数一定最小。

实现：

反正标程没看懂。代码实现能力太差。
```cpp
#include<iostream>
using namespace std;
int anst,a[15]= {1,2,3,5,7,11,13,17,19,23,29,31}; //当最大指数为1时乘到31就大于2*10~9了；anst记录因子个数。
long long ans,n;
int b[15]= {999}; //保存每个质数的指数，2可以无限增大，其余不大于前一个。
void dfs(int x,long long y,int cnt) { //x:因子个数。y:搜到的数。cnt：指针，表示当前要乘上第几个质数。
	x/=(b[cnt]+1); //若乘上第cnt个质数，因子数就变成 x/(b[cnt]+1)*(b[cnt]+2);
	y*=a[cnt];
	b[cnt]++;
	x*=(b[cnt]+1); //乘a[cnt]
	if(y>n) 
	{
		b[cnt]--;    //注意还原状态（回溯）。
		return;
	}
	if(x<=anst&&y>=ans) 
	{
		b[cnt]--;    //剪枝，若因子较少，且值较大，跳。
		return;
	}
	if(x>=anst) 
	{
		//若x>anst，那必然更新。若等于，则y<ans(由剪枝得）,也更新.
		anst=x;
		ans=y;
	}
	if(b[cnt+1]<b[cnt]) dfs(x,y,cnt+1); //优先枚举因子更大的，因为可以通过anst剪掉很多小因子数如2~8。
	if(b[cnt]<b[cnt-1]) dfs(x,y,cnt);
	b[cnt]--;//回溯
}
int main() 
{
	cin>>n;
	dfs(1,1,1);
	cout<<ans;
}
```
# 感谢观看

---

## 作者：wgyhm (赞：1)

# 浅谈打表

##                                 ——以 *【POI2002】【HAOI2007】* ‘反素数’ 为例

## 1.看题先暴力

$2*1000000000$

暴力不T的 dalao 教我下



## 2.来源定算法

### 题目来自 洛谷——试炼场——省选斗兽场/NOI神殿——省选基础-打表

**说明什么**

### ~~正解是打表啊~~

好吧我正解不会才来打表的



## 3.小打表找规律，大打表做正解

#### 第一步.判断因数个数

我们不妨先写一个不加任何优化的部分判断

```c++
int pd(int x)
{ 	
	for (i=1;i<=x;i++) if (0==x%i) ans++;  
	return ans;
}
```

众所周知，因数可以配对，比如，*10* 的因数，*1* 和*10*，*2*和*5*。所以，找到一个数就可以确定另一个因数,当然，如果此数为完全平方数，就要在所有的计算因数中-1

众多周知，判断素数的基本方法只需进行到 $\sqrt{n}$ (不会的话，自觉学习）

优化代码

```c++
long long pd(long long x)//为之后大数计算做准备
{ 
    double d=sqrt(x);	
    long long ans=0; 
    int i;
    for (i=1;i<=sqrt(x);i++)
	if (0==x%i) ans+=2;  
    if (d==(int)sqrt(x)) ans--;//特判，若为完全平方数时
    return ans;
}
```

既然都到了这个地步，何不开 ***register*** 和 ***inline*** 减小常数呢

```c++
inline long long pd(long long x)
{ 
    double d=sqrt(x);	
    long long ans=0; 
    register int i;
    for (i=1;i<=sqrt(x);i++)
	if (0==x%i) ans+=2;  
    if (d==(int)sqrt(x)) ans--;
    return ans;
}
```

#### 第二步.找规律

''如果某个正整数x满足：***g(x)>g(i) 0<i<x***，则称x为反质数。''我们可以知道，x是<=x 正整数范围中，因数个数最多的，所以我们判断一个数是否是反素数时，只需将这个数与上一个反素数进行比较



##### 不多BB，先打到 10^4

嫌慢的自己手动开个O2（好像不会快到哪里去）

```c++
#include<bits/stdc++.h>
using namespace std;
long long h[501],hh[501],cnt=1;//h数组用来存贮反素数，hh数组用来存储对应反素数的个数
inline long long pd(long long x)
{ 
    double d=sqrt(x);	
    long long ans=0; 
    register int i;
    for (i=1;i<=sqrt(x);i++)
	if (0==x%i) ans+=2;  
    if (d==(int)sqrt(x)) ans--;
    breturn ans;
}
int main()
{
    hh[1]=h[1]=1;
    register long long i;
    long long k;
    for (i=2;i<=10000;i++)
    {
	 k=pd(i);
         if (k>hh[cnt]) cnt++,h[cnt]=i,hh[cnt]=k;
    }
    for (i=1;i<=cnt;i++) 
         printf("h[%lld]=%lld,hh[%lld]=%lld;\n",i,h[i],i,hh[i]);
    return 0;
}
```

打出来结果，

```c++
    h[1]=1,hh[1]=1;
    h[2]=2,hh[2]=2;
    h[3]=4,hh[3]=3;
    h[4]=6,hh[4]=4;
    _______//防抄袭
    h[6]=24,hh[6]=8;
    h[7]=36,hh[7]=9;
    h[8]=48,hh[8]=10;
    _______
    h[10]=120,hh[10]=16;
    h[11]=180,hh[11]=18;
    h[12]=240,hh[12]=20;
    h[13]=360,hh[13]=24;
    _______
    h[15]=840,hh[15]=32;
    h[16]=1260,hh[16]=36;
    h[17]=1680,hh[17]=40;
    h[18]=2520,hh[18]=48;
    h[19]=5040,hh[19]=60;
    h[20]=7560,hh[20]=64;
```

从10开始，发现反素数都是60的倍数

所以之后，就可以 **i+=60** 去找

**真是优化了一大截呢QAQ**





#### 再打25个

```c++
    h[21]=10080,hh[21]=72;
    h[22]=15120,hh[22]=80;
    _______
    h[24]=25200,hh[24]=90;
    _______
    h[26]=45360,hh[26]=100;
    h[27]=50400,hh[27]=108;
    h[28]=55440,hh[28]=120;
    h[29]=83160,hh[29]=128;
    h[30]=110880,hh[30]=144; 
    h[31]=166320,hh[31]=160;
    _______
    h[33]=277200,hh[33]=180;
    h[34]=332640,hh[34]=192;
    h[35]=498960,hh[35]=200;
    h[36]=554400,hh[36]=216;
    _______
    h[38]=720720,hh[38]=240;
    h[39]=1081080,hh[39]=256;
    h[40]=1441440,hh[40]=288;
    h[41]=2162160,hh[41]=320;
    h[42]=2882880,hh[42]=336;
    h[43]=3603600,hh[43]=360;
    h[44]=4324320,hh[44]=384;
    h[45]=6486480,hh[45]=400;
```

到了后面，电脑越来越慢了，毕竟范围大了许多



#### 第三步.gcd找规律

大数的公因数，只能找计算机帮忙了
```cpp

#include<bits/stdc++.h>
using namespace std;
long long gcd(long long a,long long b)
{
    if (b==0) return a;
    return gcd(b,a%b);
}
int main()
{
    long long x,num,n=5;
    scanf("%lld",&x);
    num=x;
    for (int i=1;i<n;i++) scanf("%lld",&x),num=gcd(num,x);
    printf("%lld",num); 
    return 0;
}
```



找5个足矣，其公因数为720720

就这样，打到范围即可



## 4.表后写标程

只需把打的数扔上去，while判断不超过输入数的最大反素数即可（ **69**个数不必二分吧）

```cpp
#include<bits/stdc++.h>
using namespace std;
long long h[101],hh[101],cnt;//hh数组不想删，（谁叫我懒呢）
long long x;
int main()
{
    h[1]=1,hh[1]=1;
    h[2]=2,hh[2]=2;
    h[3]=4,hh[3]=3;
    h[4]=6,hh[4]=4;
    //此处省略打表内容
    h[66]=735134400,hh[66]=1344;
    h[67]=1102701600,hh[67]=1440;
    h[68]=1396755360,hh[68]=1536;
    h[69]=2095133040,hh[69]=1600;//写着方便while，不必特判了
    scanf("%lld",&x);
    while (x>=h[cnt]) cnt++;
    printf("%lld",h[cnt-1]);
    return 0;//养成好习惯
}
```





---

## 作者：wmjlzw1314 (赞：1)

```cpp
//引理一 ： 1 ~ N中最大的反质数就是约数最多的数中最小的一个；
//引理二 : x的质因子必须是连续的，并且指数是单调递减的
//反证法 如果不遵守引理二那么约数个数相等，但是数要比当前这个数小 ， 不遵守引理一；
// 代码如下 ：

   
#include<bits/stdc++.h>
using namespace std;
long long  n ;
long long  ans ;
int s[100200];
int last;
bool vis[1002];
int tot;
int prime[105];
void dfs(int x , int num ,long long  mul){
	if( x > 12 ) return ;// 这里是因为 2 * 3 * 5 * ...... * 29 *31 > 2 * 10^ 9
	//超过了题目范围  
	if(num > last || (num == last && mul < ans)){
	 //约数多  或者 数小更新答案 
      ans = mul;
      last = num;
	 }
     s[x] = 0;//每次变成零 
     while(mul * prime[x] <= n  && s[x]  < s[x - 1]){//满足指数单调递减 
     	mul *= prime[x];
     	s[x] ++;//约数指数++ 
     	dfs(x + 1 , num * (s[x] + 1 ) , mul)  ;// 算数基本定理的推论一个数的约数个数 = （ci为指数）
		 (c1 + 1) * (c2 + 1) ....* (Cm + 1)... 
	 }
}
int main () {
   cin >> n;
   for(int i = 2 ; i  <= 50; i++){
   	  if(vis[i] == 0) prime[++tot] = i;
		 for(int  j = 2 * i ; j <= 50 ; j += i){
		 	vis[j] = 1;
		 } 
   }
   s[0] = 0x3f3f3f3f;
   dfs( 1 , 1 , 1);
   cout << ans ;
   return 0;
 }
```


---

## 作者：multiverse_ (赞：1)

<1> 1~n中最大的反素数，就是1~n中约数个数最多的数中最小的那一个

<2>因为 n∈[1,2×10^9],而2×3×5×7×11×13×17×19×23×29×31>2×10^9,所以
1~n中任何数的不同质因子都不会超过10个

<3>即使只包含最小的质因子2，仍然有2^31>2×10^9,所以
质因子的指数总和不可能超过30

<4>x为反质数的必要条件：可以写成
(2^a)×(3^b)×(5^c)×(7^d)....×(29^j),	  且a>=b>=c>=d...>=j>=0

**即质因子是连续的多干个最小的质数,且指数单调递减**

{证明：
若x有大于29的质因子，则前面2~29的质因子必有一项指数为0(否则乘积>2×10^9)。  
此时，x/（p^k）×（p^j）(k>29,j<=29)与x的约数个数相同，但比x小，x不符合反质数的要求
} 

**综上，可以使用dfs，尝试依次确定前10个质数的指数，并满足单调递减，乘积不超过N**

代码：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n,ans,maxn=0; 
int s[20]={0,2,3,5,7,11,13,17,19,23,29};
int a[100010];
void dfs(int dep,int sum,int num){
	if(dep>10){
		if(num>maxn){//约数个数更大直接更新答案 
			ans=sum;
			maxn=num;
		}else if(num==maxn){//约数个数和当前最大值相等，取最小值 
			ans=min(ans,sum);
		}
		return ;
	}
	for(int i=0;i<=30;i++){
		if(pow(s[dep],i)*sum>n)break;
		if(pow(s[dep],i)*sum<=n&&i<=a[dep-1]){//如果乘积不超过N且满足单减 
			a[dep]=i;
			dfs(dep+1,sum*pow(s[dep],i),num*(i+1));
		}
	}
}
signed main() {
	cin>>n;
	a[0]=1000;
	dfs(1,1,1);
	cout<<ans<<endl;
	return 0;
}
```



---

## 作者：Sakura_梦瑶 (赞：1)

一个正常的搜索(如果素数不算打表的话)

通过观察可以发现最大的反素数就是从小到大依次选一次素数构造因式分解 按照约数和公式构造一个理论数作为开始的边界确定素数个数 

如此构造会发现最多只要用10个数 因为
pr[i]^x*pr[i+1]^j j>x 的情况下j 与x交换肯定才能合法 也就是说指数的大小是不增的

依照这个发现便生成了可行性剪枝，同时我们需要记下当前答案的约数个数和这个答案的大小，只要枚举组合方案然后用合法剪枝即可ac 时间最大复杂度是O(10!)而边界剪枝可以做到些许优化 

之所以是10是因为当几个质数指数极大时这个数一般不可能是反素数。所以我们甚至每个质数的指数选择次数可以再少一点从而降低复杂度
但是正确性就要自己打表验证一下了,这边是选择了10安全一点且时间复杂度也是过得去的
```cpp
#include<bits/stdc++.h>
#define int long long //最大的理论数构造会爆int 大概60W
using namespace std;
int n,x=1,ans=1,aim_p=1,pr[100]={0,2,3,5,7,11,13,17,19,23,29,31,37};
inline int minn(int pos,int res){if(pos>res)return res;else return pos;}
bool dfs(int dep,int pos,int cnt,int rans){
if(cnt>n)return 0;//边界剪枝
if(rans==aim_p)ans=minn(ans,cnt);//如果因子个数相同更新答案
if(aim_p<rans)ans=cnt,aim_p=rans;//用因子更多的数更新答案
	for(int i=1,p=pr[dep];i<=pos&&p*cnt<=n;i++,p*=pr[dep])
	 if(!dfs(dep+1,i,p*cnt,rans*(i+1)))return 1;
	return 1;
} 
signed main(){
	cin>>n;
	while(ans*pr[x]<=n)ans*=pr[x++],aim_p*=2;
	dfs(1,10,1,1),cout<<ans;
}
```

---

## 作者：ttt_TTT (赞：1)

~~这道题坑了我一天……哎……打了个表，过了60~~
言归正传，这道题是一道数论题

一个数约数个数=所有素因子的次数+1的乘积

一个2000000000以内的数字不会有超过12个素因子

较小的数的指数一定大于等于较大的数的指数

然后通过计算得出一个2000000000以内的数字不会有超过12个素因子

```
#include <iostream>
#include <cstdio>
using namespace std;
int p[16] = {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53};
unsigned long long ans,n;
int Max;
 
void dfs(int dep,unsigned long long now,int num)
{
    if(dep >= 16) return; 
    if(num > Max)
    {
        Max = num;
        ans = now;
    }
    if(num==Max&&ans>now)ans=now;
    for(int i=1;i<=63;i++)  
    {
        if(p[dep]*now>n) break;
        dfs(dep+1,now*=p[dep],num*(i+1));
    }
}
 
int main()
{
    cin>>n;
    ans=~0ULL;
    Max=0;
    dfs(0,1,1);
    cout<<ans<<endl;
return 0;
}

```

---

## 作者：Blogggggg (赞：1)

**知识点：  打表、算术基本定理**

**思路：**

设一个数质因数分解后变为：$x=\Pi p_{i}^{k_i}$，对于 $p_i$ 和 $p_{i+1}$，若 $k_{i}<k_{i+1}$，则这个数不是反素数，因为一定会有一个数质因子分解后这两个质因数的指数为 $p_{i}^{k_{i+1}}p_{i+1}^{k_{i}}$，其他质因子都相同，如此这两个数的正因子个数相等，但很明显后者比前者小。

利用上述结论我们可以先用 $dfs$ 筛选出 $[1,2000000000]$ 中所有有可能是反素数的数，然后再在这些数上打出反素数表。在这个表上查询答案即可。

**代码：**
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int maxn=1e5;

LL prim[15]={2,3,5,7,11,13,17,19,23,27,29,31};
LL ans[maxn];
set<LL> vis;
int cnt=0;
void dfs(int pos,int lhave,int have,LL now){
    ans[cnt++]=now;
    vis.insert(now);

    LL t1=now*prim[pos];
    if(t1<=2000000000&&have+1<=lhave&&vis.count(t1)==0)
        dfs(pos,lhave,have+1,t1);
    if(pos<11&&have>=1){
        t1=now*prim[pos+1];
        if(t1<=2000000000&&vis.count(t1)==0)
            dfs(pos+1,have,1,t1);
    }
}

LL realans[maxn];
int has=1;
void init(){
    LL maxx=1;
    realans[0]=1;
    for(int i=1;i<cnt;i++){
        LL have=1,num=ans[i];
        for(int j=0;j<12;j++){
            if(ans[i]%prim[j]==0){
                LL t=1;
                while(ans[i]%prim[j]==0){
                    t++;
                    ans[i]/=prim[j];
                }
                have*=t;
            }
            if(ans[i]==1)   break;
        }

        if(have>maxx){
            maxx=have;
            realans[has++]=num;
        }
    }
}

int main(){
 //   freopen("out.txt","w",stdout);
    dfs(0,maxn,0,1);
    sort(ans,ans+cnt);
    init();
    LL n,ret;
    scanf("%lld",&n);
    for(int i=0;i<has;i++){
        if(realans[i]>n)    break;
        ret=realans[i];
    }
    printf("%lld\n",ret);
    return 0;
}
```

---

## 作者：BLUE_EYE (赞：1)

明显可以知道，$n$可以分解成$2*3*5……pi(pi$为质数$)* $小数。所以$n>2*3*5……pi*((int)$小数$)$。所以就可以对这个小数进行同一番操作，比如$10000$，分解出来是$2*3*5*7*11$；再乘以$4$，则$4$就可以分解成$2*2$或$3$，很明显取$2$；但是，由于$11$这个数字比较大，$(11$可以分解成$2*2*2$或$3*3$或$2*5)$，所以我们可以对$11$单独操作，也就是把前面的式子写成$2*3*5*7=210$，后面数字为$10000/210=47$；对$47$再进行分解，不过这个分解应当包含所有情况而不是对$47$的最优情况$($虽然$47$的最优解是$36$，分解到的$2*2*3*3$也恰好是$36$，但是多试几组会发现不一定，所有不能记录前驱$)$，即枚举$47$的所有可能情况$($包括$2*2*2*2*2,2*2*2*3,2*2*2*5$等等$)$;打个爆搜就好了，但是当N越来越大的时候，爆搜的次数要增多，但是复杂度都是可以接受的$($如果搜$2$次，复杂度最多为分解$27*31$的复杂度,可以接受$)$ 下面给出代码。
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
using namespace std;
typedef long long ll;
const ll N=1e5+5;
ll a[N],b[N],f[N],num,tot,ans[N],maxn,len,real[N],answer;
ll read(){
	char c=getchar();ll all=0,pd=1;
	for(;c>'9'||c<'0';c=getchar()) if(c=='-') pd=-1;
	while(c>='0'&&c<='9'){all=all*10+c-'0';c=getchar();} return all*pd;
} 
void init(ll M){
	b[1]=1;for(ll i=2;i<=M;i++){
		if(!b[i]) b[i]=1,a[++num]=i;
		for(ll j=1;j<=num&&a[j]*i<=M;j++){
			b[a[j]*i]=1;if(i%a[j]==0) break;
		}
	}
}
ll qpow(ll x,ll k){
	ll w=1,j=x;for(ll i=k;i;i>>=1,j=j*j)
	if(i&1) w=w*j;return w;
}
ll pd(){
	ll answ=1;for(ll i=1;i<=len+1;i++) answ*=qpow(a[i],f[i]+ans[i]);return answ;
}
void dfs(ll x,ll top){
	if(top/x==1){
		ll all=1;
		for(ll i=1;i<=len;i++) all=all*(f[i]+ans[i]+1);
		if(ans[2]==2){
			int w=1;
		}
		if(maxn==all){
			ll w=pd();
			if(w<answer){
				for(ll i=1;i<=len+1;i++) real[i]=f[i]+ans[i];
				answer=w;
			}
		}
		if(maxn<all){
			for(ll i=1;i<=len+1;i++) real[i]=f[i]+ans[i];
			maxn=all;answer=pd();
		}return;
	}
	for(ll i=1;i<=num;i++){
		if(x*a[i]<=top){
			ans[i]++;dfs(x*a[i],top);
			ans[i]--;
		}else return;
	}
}
int main(){
	ll n=read();ll x=1,i=0,pisum=1;init(1e4);
	if(n==1){
		printf("1");return 0;
	}
	while(x*a[i+1]<=n){
		i++;f[i]=1;x*=a[i];
		real[i]=1;
	}maxn=qpow(2,len);len=i;dfs(1,n/x);
	len--;x/=a[len+1];f[len+1]=0;
	dfs(1,n/x);
	if(len>=1){
		len--;x/=a[len+1];f[len+1]=0;dfs(1,n/x);
	}
	printf("%lld",answer);
}
```

---

## 作者：LYFer (赞：1)

题目解释放在代码注释里面了~

欢迎吐槽与建议

```cpp
/*
1.
一个数的约数个数=所有素因子的幂次+1的乘积
这个直观的理解就是 2^x*3^y 我能拆出来 
2^0*3^0
2^0*3^1
2^0*3^2
……
2^1*3^0
2^1*3^1
……
2^2*3^0
……
2^x*3^0
……
2^x*3^y
根据乘法原理 2一共有x+1个幂 3有y+1个幂 所以就是(x+1)*(y+1)

2.
写一个暴力跑程序会发现一个2000000000以内的数字不会有超过12个素因子

3.
较小的数的幂次一定大于等于较大的数的幂次

之后就是赤裸裸的DFS暴搜了 


*/

#include <cstdio>
#include <algorithm>

typedef long long ll;
ll n;
int ans=1,num=1;

ll Max,last;
//1的确不是质数 但是x^0需要用到 
int prime[15]={1,2,3,5,7,11,13,17,19,29,31};

//dep的意义是当前的第几个素数 Num是当前数字大小 tot是当前约数的和 limit是上一个素数的幂次对本次的限制约束
void dfs(int dep,ll Num,int tot,int limit){
    if(dep==12){
        //当前值大于记录值  并且约数也比上次那个多 
        if(Num > Max && tot> last){
            Max = Num;
            last = tot;
        }
        //当前值小于记录值  并且约数也比上次那个多  记录值不合法 
        /*这里这个“= ”特别说明一下
        g(x)>g(i) 0<i<x
        当前的值是i 比 x 小满足条件，但是如果g(i)<g(x)或者 g(i)=g(x)都不合法 
        */ 
        if(Num <= Max && tot >= last){
            Max = Num;
            last = tot;
        }
        return;
    }
    int mul =  1;
    for(int i=0;i<=limit;++i){
        dfs(dep+1,Num*mul,tot*(i+1),i);
        mul*=prime[dep];
        if(Num*mul>n) break;
    }
}

int main(){
    scanf("%d",&n);
    dfs(1,1,1,20);
    printf("%lld\n",Max);
    return 0;
}
```

---

## 作者：Anemone (赞：1)

我的题解比较low……是搜索+打表结合的方法。（我的搜索大数据会TLE，不知道什么原因）

但是这个题解主要想强调的是分析问题的方法：如何从打表上升到搜索？

也就是说，实际上这个题目如果没有思路的话，可以先把表打出来再分析。在实际测试中，也是一种相当实用的方法。


第一环节：暴力。可以拿到30·40分。

直接for循环，枚举1到i区间内约数最大的数。


第一环节结束以后，我将1-20000的结果打印下来：

1
2
4
6
12
24
36
48
60
120
180
240
360
720
840
1260
1680
2520
5040
7560
10080
15120

看到这些数据，你应该会发现三位及以上的数字末位全是0。

通过拆分，我们可以发现如下规律：

1  1
2  1\*2
4  2\*2
6  2\*3
12  4\*3

24  12\*2

36  12\*3

48  24\*2

60  12\*5

120  24\*5

180  60\*3

240  120\*2

360  180\*2

720  360\*2

840  120\*7

1260  180\*7

1680  840\*2

2520  360\*7

5040  2520\*2

7560  2520\*3

10080  5040\*2

15120  5040\*3

那么我们是不是可以猜想，每一个反质数都是某一个已求出的反质数与一个质数的乘积？

通过证明，可以发现这个是成立的。（具体的楼下都说得很详细啦。）


第二环节：搜索。

思路：每找到一个反质数，就把这个反质数乘以素数表中的素数，然后继续扩展。

因为没有充分证明素数表中数的个数，我开得比较大，从2一直到71，共20个素数。（也许是TLE的原因？）




```cpp
int check(int x)/*检测因子个数*/
{
    int sum=0;
    for(int i=2;i<=int(sqrt(x));i++)
    if(x%i==0)
    {
        if(i*i==x)sum++;
        else sum+=2;
    }
    return sum+2;
}
void dfs(int k)/*搜索反质数*/
{
    for(int i=1;i<=20;i++)
    if(pri[i]*k<=n)
    {
        int sum=check(pri[i]*k);
        if(vis[sum]==0||vis[sum]>pri[i]*k)
        {
            vis[sum]=pri[i]*k;
            maxv=max(maxv,sum);
            dfs(pri[i]*k);
        }
    }
}
```
不知道为什么这个程序大数据会TLE，所以我在数据超过40000000的时候开始打表。
实际上这些测试点如果时限再宽一些，或者算法再优化一些也是可以全过的。


if(n>=36756720&&n<43243200){cout<<36756720<<endl;return;}

if(n>=43243200&&n<61261200){cout<<43243200<<endl;return;}

if(n>=61261200&&n<73513440){cout<<61261200<<endl;return;}

if(n>=73513440&&n<110270160){cout<<73513440<<endl;return;}

if(n>=110270160&&n<122522400){cout<<110270160<<endl;return;}

if(n>=122522400&&n<147026880){cout<<122522400<<endl;return;}

if(n>=147026880&&n<183783600){cout<<147026880<<endl;return;}

if(n>=183783600&&n<245044800){cout<<183783600<<endl;return;}

if(n>=245044800&&n<294053760){cout<<245044800<<endl;return;}

if(n>=294053760&&n<367567200){cout<<294053760<<endl;return;}

if(n>=367567200&&n<551350800){cout<<367567200<<endl;return;}

if(n>=551350800&&n<698377680){cout<<551350800<<endl;return;}

if(n>=698377680&&n<735134400){cout<<698377680<<endl;return;}

if(n>=735134400&&n<1102701600){cout<<735134400<<endl;return;}

if(n>=1102701600&&n<1396755360){cout<<1102701600<<endl;return;}

if(n>=1396755360){cout<<1396755360<<endl;return;}


---

## 作者：Deny_小田 (赞：1)

好题。

简单的dfs，但是要注意许多地方。题目本身不难，但稍一不注意就会WA或TLE掉。

附代码（赠送注释）：


[codec]

/**************************************************************

Problem: 1053

User: Deny

Language: C++

Result: Accepted

Time:116 ms

Memory:820 kb

****************************************************************/

 
 
 
```cpp
#include <cstdio>
typedef long long LL;
const int size = 10000005;
int prime[] = {-1,2,3,5,7,11,13,17,19,23,29,31,37},n,ans,maxid = 0,a;
void dfs(LL now, int d, int cnt){
    if(d > maxid||(d == maxid&&now < ans)){ ans = now; maxid = d; }
                    //不断更新ans的最小值
    if(cnt == 13) return ;              //cnt到一定程度说明搜索完毕了
    LL a = 1;
```
/********************************************/
```cpp
    //使用生成法构造反素数
    for(int i = 0; ; i++){              
        if(a*now > n) break;
        dfs(now*a, d*(i+1), cnt+1);
        a *= prime[cnt];
    }
```
/********************************************/

}
[/codec]


参考资料：http://blog.csdn.net/loi\_dqs/article/details/50727612  代码比较简便。

参考资料2： http://blog.csdn.net/zhb1997/article/details/37961237 说的比较详细

 
 
```cpp
int main(int argc, char const *argv[]){
    scanf("%d",&n);
    dfs(1, 1, 1);
    printf("%d\n",ans);
    return 0;
}
```
﻿

---

## 作者：jr_tat (赞：1)

这道题在李煜东的算法竞赛进阶指南中讲过思路，我把他总结了一下，并自己码了代码，思路和代码如下

1.1~n中最大的反质数，就是1~n中质数最多的数中最小的

证明：
    设g（i）i的约数的个数，x为1~n里的任意数，
     m为1~n中质数最多的数中最小的一个，则 
     
     1. x<m，g(m)>g(x)
     2. x>m  g(m)>=g(x)

2.1-n中任何数的不同的质因子不会多于10个，质因子的指数不会多于30个 
证明：
1. 2* 3* 5* 7* 11* 13* 17* 19* 23* 29* 31>2*10^9  //最小的连续质数积大于n的最大值
2. 2^31>2*10^9  //最小的质数的31次方大于n的最大值 

反素数m的约数是由 2,3,5...29组成的，且他们的指数"单调递减" 

证明：
1. 若m的约数由一个大于29的质数k组成的，设k'为不大于29的一个质数，
则m/k*k' 和 m 的约数数量相同，而 m/k*k'更小，根据"1."的结论，
m不是反素数。
2. 若m有约数p1,p2且p1<p2,p1的指数<p2的指数
则 m/p2*p1 < m 且它们的约数数量相等 

注释：  m/p2*p1 即让p2的指数-1，p1的指数+1  
综上所述，我们只需要用dfs来确定10个质数的指数，
同时计算它的约数个数就行了 
代码如下
```cpp
#include<bits/stdc++.h>
using namespace std;
int z[11]={0,2,3,5,7,11,13,17,19,23,29};
long long maxx=0,n,p,maxnum=0;

int g(long long x){

	int s=0;       
	long long a=sqrt(x);     
	for(int i=1;i<=a;i++){      
		if(x%i==0)s+=2;      
	}  
	if(a*a==x)s--;    
	return s; 
    
}
void dfs(int zhi,int last,long long sum,int x){

	if(x==10){       
		int b=g(sum);       
		if(b>maxnum){          
			maxnum=b;             
			maxx=sum;
            
		}
		else if(b==maxnum&&sum<maxx){//需要注意取约数最多中的最小的数             
			maxnum=b;             
			maxx=sum;      
		}  
		return;   
	}
	for(int i=0;i<=last;i++){
      p=sum*pow(z[zhi],i);        
		if(p<=n){        
			dfs(zhi+1,i,p,x+1);           
		}        
		else break;     
	}  
}
int main(int argc, char** argv) {

	cin>>n;   
	for(int i=0;i<=30;i++){ 
		 p=pow(z[1],i);        
		 if(p<=n){         
		 	dfs(2,i,p,1);            
		 }   
		 else break;    
	} 
	cout<<maxx<<endl;
	return 0;
}
```



---

## 作者：cold_cold (赞：0)


[安利一波博客](https://www.cnblogs.com/cold-cold/p/10013655.html)


此题以前学习过，此次刷POI又一次碰到了，我们看到要找到不超过N的最大反质数，我们就可以将问题转化。

 
在一开始的时候我将问题转化错了，我将问题转化为找到不大于N的中约数最多的数中的的最大的那个。我们考虑它为什么它不对。

　　令  ∀ x<y<=N 使g(x)=g(y) 
  		那么 那么我们发现对于y来说，当i=x的时候，不满足g(x)>g(i)的要求，若将题设改为找到不大于N的中约数最多的数中的的最小的那个就会满足要求

　　由公式n= a[1]^k[1] \* a[2]^k[2] \*…..a[n]^k[n]，约数个数 t=(k[1]+1)(k[2]+1)…..(k[n]+1)可得出约数个数计算的方法

这里对于我们的搜索有一个小剪枝（不加会TLE，实测有效）：一个数由许多质数的某次方相乘得到，难么满足题设的数所分解的较大的质数的指数一定小于较小的质数的指数

　　证明也很简单：如果较大的质数的指数大于较小的质数的指数，那么我们将两个质数的指数交换会使最终乘起来的数字变小，却不会使该数的约数个数变少，至此原剪枝得证

实现如下


```cpp
#include <algorithm>
#include <iostream>
#include <cmath>
#include <cstring>
#include <map>
#include <string>
#include <vector>
#include <queue>
#include <stack>
#include <cstdio>
#include <cstdlib>
using namespace std;
typedef long long ll;
const ll su[16]={1,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47};
inline ll read()
{
    register ll p(1),a(0);register char ch=getchar();
    while((ch<'0'&&ch>'9')&&ch!='-') ch=getchar();
    if(ch=='-') p=-1,ch=getchar();
    while(ch>='0'&&ch<='9') a=a*10+ch-48,ch=getchar();
    return a*p;
}
inline ll min(ll x,ll y){return x>y?y:x;}
ll n,ans=0x3f3f3f3f,maxn=0,ke=0;
void dfs(ll xx,ll pre,ll num,ll jl)
{
    ll ji=0;
    if(num>maxn) ans=xx,maxn=num;
    else if(num==maxn) ans=min(ans,xx);
    if(pre==16) return;
    while(ji<=jl&&xx<=n)
    {
        dfs(xx,pre+1,num*(ji+1),ji);
        xx*=su[pre];++ji;
    }
}
int main()
{
    n=read();
    dfs(1,1,1,30);
    printf("%lld\n",ans);
    return 0;
}


```


---

## 作者：封禁用户 (赞：0)

测试的时候准备打表。当时的思路是每个反质数的因数比上一个反质数多。于是递推，只得了20分。

正解：

对任意一个数可以分解质因数得到::p=2^t1\*3^t2\*5^t3\*7^t4.....；

其因数的个数为：(t1+1)\*(t2+1)\*(t3+1)......

于是反质数必然t1>=t2>=t3>=....(若对p'有t3>t2,则有p'大于某个与它因数个数相等的数，故p'非反质数)。

也就是说在因数个数相同的情况下，反质数一定最小。

本渣来一个pascal代码。用的是搜索：


```cpp
var
  i:longint;
  p:array[1..11]of integer=(2,3,5,7,11,13,17,19,23,29,31);
  n,ans,kans:qword;
function min(a,b:qword):qword;
begin
  if a>b then exit(b)
  else
    exit(a);
end;
procedure dfs(x,y:longint;v,z:qword);
var
  tmp:int64;
begin
  if v>n then exit;
  if z>=kans then begin
    if kans=z then
    ans:=min(ans,v)
    else
      ans:=v;
      kans:=z;
    if v=n then exit;
    end;
  tmp:=1;
  for i:=1 to x do begin
    tmp:=tmp*p[y];
    dfs(i,y+1,v*tmp,z*(i+1));
    if tmp>n then break;（剪枝怕爆掉。。。）
  end;
end;
begin
  read(n);
  dfs(100000,1,1,1);
  write(ans);
end.

```

---


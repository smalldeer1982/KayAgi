# [SCOI2010] 生成字符串

## 题目描述

lxhgww 最近接到了一个生成字符串的任务，任务需要他把 $n$ 个 $1$ 和 $m$ 个 $0$ 组成字符串，但是任务还要求在组成的字符串中，在任意的前 $k\ (0 \le k \le n+m)$ 个字符中，$1$ 的个数不能少于 $0$ 的个数。现在 lxhgww 想要知道满足要求的字符串共有多少个，聪明的程序员们，你们能帮助他吗？

答案对 $20100403$ 取模。

## 说明/提示

对于 $30\%$ 的数据，保证 $1\leq m\leq n\leq 10^3$。

对于 $100\%$ 的数据，保证 $1\leq m\leq n\leq 10^6$。

## 样例 #1

### 输入

```
2 2```

### 输出

```
2```

# 题解

## 作者：xyz32768 (赞：96)

可以考虑把$1$的个数与$0$的个数的**和**看成$x$坐标，$1$的个数与$0$的个数的**差**看成$y$坐标，那么如下图：

![这里写图片描述](http://img.blog.csdn.net/20170826103642649?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHl6MzI3Njg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

向右上走（$x$坐标加$1$，$y$坐标加$1$）就表示这个字符选择$1$。

向右下走（$x$坐标加$1$，$y$坐标减$1$）就表示这个字符选择$0$。

这样子，如果不考虑限制条件，就表示从$(0,0)$走$n+m$步到达$(n+m,n-m)$，这相当于从$n+m$步中选出$m$步向右下走，也就是$C(n+m,m)$。

考虑限制条件，任意前缀中$1$的个数不少于$0$的个数，也就是这条路径不能经过直线$y=-1$。可以通过对称性发现，从$(0,0)$走到直线$y=-1$上的一点，相当于从$(0,-2)$走到该点。也就是说，路径经过直线$y=-1$的方案数就是从$(0,-2)$走$n+m$步到达$(n+m,n-m)$，这个方案数可以用组合数表示为$C(n+m,m-1)$。

所以最后结果为$C(n+m,m)-C(n+m,m-1)$。对于组合数，可以预处理阶乘后用乘法逆元计算。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
const int N = 2e6 + 5, PYZ = 20100403;
int n, m, fac[N], inv[N];
int qpow(int a, int b) {
    int res = 1;
    while (b) {
        if (b & 1) res = 1ll * res * a % PYZ;
        a = 1ll * a * a % PYZ;
        b >>= 1;
    }
    return res;
}
int C(int x, int y) {
    int z = 1ll * fac[x] * inv[y] % PYZ;
    return 1ll * z * inv[x - y] % PYZ;
}
int main() {
    int i; fac[0] = 1; n = read(); m = read();
    for (i = 1; i <= n + m; i++) fac[i] = 1ll * fac[i - 1] * i % PYZ;
    inv[n + m] = qpow(fac[n + m], PYZ - 2);
    for (i = n + m - 1; i >= 0; i--)
        inv[i] = 1ll * inv[i + 1] * (i + 1) % PYZ;
    printf("%d\n", (C(n + m, m) - C(n + m, m - 1) + PYZ) % PYZ);
    return 0;
}
```

---

## 作者：George1123 (赞：56)

[${\color{#ac0}\text{欢迎拜访我这个蒟蒻的博客}}$](https://www.luogu.org/blog/Wendigo/)

[P1641 【\[SCOI2010\]生成字符串】](https://www.luogu.org/problem/P1641)

### 此题算法: 卡特兰+逆元+组合数

有个经典的问题:一只绿鸟$50$元，一堆人买绿鸟，有人有$100$元，有人有$50$元。绿鸟商$cz$刚开始没有钱，问有几种排队方法，使得$cz$总可以随时找零。

此题中的$0$就是$100$元，$1$就是$50$元，生成的字符串就是排队方案。

大致思路:

>1.$ $先将问题可视化:

![](https://s2.ax1x.com/2019/11/03/KXP9gO.jpg)

>如图，有几种走法?

>2.$ $由于广场过大，不能用标数法$dp$，但可以用概率解题。先取消$1$要随时多于$0$的要求，即把广场左上角补上。此时有$(^{\space\space  m}_{m+n})$种走法(走$m+n$步中向上走$m$步)。

![](https://s2.ax1x.com/2019/11/03/KXZ511.jpg)

>3.$ $如上图，在$a+b$中，$a$表示合法方案，$a+b$表示所有方案，可以观察得出斜线上的合法方案为卡特兰数，并且**不合法方案数**为方案总数的$\frac{j}{i+1}$其中$i$为横轴，$j$为纵轴。

>4.$ $所以得出结论:$f(n,m)=\frac{n-m+1}{n+1}(^{\space\space  m}_{m+n})$，虽无严谨证明，但对于$OI$来说，得出特别正确的结论就够了。

## 以下是代码+注释


```cpp
#include <bits/stdc++.h>
using namespace std;
#define lng long long
const int M=20100403;
lng n,m,ret,dv;
lng Tim(lng &bse,lng x){ //带模自乘法
	bse=(bse*x)%M;
} lng Pow(lng bse,lng x){ //倍增快速幂
	lng ans=1;
	for(;x;x>>=1){
		if(x&1) Tim(ans,bse);
		Tim(bse,bse);
	} return ans;
} void C(){ //分段组合数
	for(int i=n+1;i<=n+m;i++)
		Tim(ret,i);
	for(int i=1;i<=m;i++)
		Tim(dv,i);
} int main(){
	scanf("%lld%lld",&n,&m);
	dv=n+1,ret=dv-m,C();
	ret=(ret*Pow(dv,M-2))%M; //逆元求除法
	printf("%lld\n",ret); //答案开龙龙
	return 0;
}
```
写题解不易，求点赞。

代码中的注释龙龙就是$long\space long$(还不是为了凑字)

谢谢大家! !

![](https://s2.ax1x.com/2019/11/03/KXKowV.jpg)





---

## 作者：Scarlet_Hypoc (赞：40)

发一篇像我一样的蒟蒻们能看得懂的题解

大致的思路和楼上的大犇们差不多，这里再详细的解释一下

首先，将这个字符串抽象成平面直角坐标系，从(0,0)出发，那么每一个1可以看成类似(0,0)->(1,1)这样子走一步，则0就是(0,0)->(1,-1)这样走一步，所以，满足要求的字符串也就是不能走到y=-1的直线上

先撇开这个东西，思考一下满足条件的方案数有多少，直接求不好求，那么可以用总方案数-不满足条件的方案数求得，总方案数其实是很容易求的，我们知道字符串的长度为n+m，一共有n个1，那么只要求在n+m个位置里放置n个1的方案数即可（0就不用管了，放完1剩下的位置放0就好了），也就是求组合数C(n+m,n)

接下来要求的就是不满足条件的方案数，回到这个平面直角坐标系，如果不满足条件，那么一定经过y=-1这一条直线，那么我们将y=-1这条直线上面的翻折下来，见下图：

![](https://cdn.luogu.com.cn/upload/pic/17279.png)

在这个例子中，我只翻折了一部分（也就这一部分需要翻折，也就是从(0,0)开始直到第一次接触y=-1的这一段），那么所有0操作(向右下走)都变成了1(向右上走)，1都变成了0，可以发现，在我圈起来的那一部分之前的部分，0和1的数量持平，所以翻折后他们数量还是一样，但是在我圈起来的地方，0翻成了1，这是只有第一次接触y=-1时才会出现的特殊情况，在 其他时候走到y=-1 时，0和1的数量一定仍然一样，所以，1的数量其实加了1，0的数量减了1，那么同上，只需要求C(n+m,n+1)就好了

所以，答案就是(C(n+m,n)-C(n+m,n+1))%20100403

但是由于n,m较大,且除法不可以直接取模，所以我们需要运用逆元来求解

逆元：若 a b≡1(mod p) ，则b是a在模p意义下的逆元,也就是(a b)%p≡1

（下面的式子若无特殊标记，则都是在模p意义下的式子）

则 a/b=a * b的逆元

那么转换成乘法后，就可以直接取模了

那么逆元怎么求，请参见费马小定理，大致就是若a与p互质，且p是质数时，a^(p-1)≡1 ,并且，a^-1也是a的逆元

那么有
```
a^(p-1)=1=a^-1a
a^(p-1)=a^-1a
a^(p-2)=a^-1
```
所以，a的逆元就是a^(p-2)，至于为什么不用a^-1，是因为它可能是个小数

所以组合数(这只是个例子)
```
          n!
C(n,m)=————————= n! * (m! * (n-m)!)^20100403
       m!(n-m)!
```
注意其中每一步运算都很大，所以每算一步都要模一次

接下来上代码：

```cpp
#include <cstdio>
#include <cstring>
#define intt long long
#define mod 20100403

intt n,m;
intt C(intt x,intt y)
{
	intt a=1;
	for(intt i=2;i<=x;i++)//n!
	a=(a*i)%mod;
	intt b=1;
	for(intt i=2;i<=y;i++)//m!
	b=(b*i)%mod;
	intt c=1;
	for(intt i=2;i<=x-y;i++)//(n-m)!
	c=(c*i)%mod;
	b=(b*c)%mod;
	intt d=1;//存(m!*(n-m)!)的逆元 
	intt p=mod-2;
	while(p>0)//快速幂求逆元 
	{
		if(p%2==1)d=(d*b)%mod;
		b=(b*b)%mod;
		p/=2;
	}
	return (a*d)%mod;
}

int main()
{
	scanf("%lld %lld",&n,&m);
	printf("%lld",(C(n+m,n)-C(n+m,n+1)+mod)%mod);
}
```

---

## 作者：soler (赞：27)

##卡特兰数


###扩展(折线原理)


对于在n位的2进制中，有m个0，其余为1的catalan数为：C（n,m）-C(n,m-1)。证明可以参考标准catalan数的证明。


问题1


描述：有n个1和m个-1（n>m），共n+m个数排成一列，满足对所有0<=k<=n+m的前k个数的部分和Sk > 0的排列数。 问题等价为在一个格点阵列中，从（0，0）点走到（n，m）点且不经过对角线x==y的方法数（x > y）。


考虑情况I：第一步走到（0，1），这样从（0，1）走到（n，m）无论如何也要经过x==y的点，这样的方法数为(( n+m-1,m-1 ));


考虑情况II：第一步走到（1，0），又有两种可能：




a . 不经过x==y的点；（所要求的情况）

b . 经过x==y的点，我们构造情况II.b和情况I的一一映射，说明II.b和I的方法数是一样的。设第一次经过x==y的点是（x1，y1），将（0，0）到（x1，y1）的路径沿对角线翻折，于是唯一对应情况I的一种路径；对于情况I的一条路径，假设其与对角线的第一个焦点是（x2，y2），将（0，0）和（x2，y2）之间的路径沿对角线翻折，唯一对应情况II.b的一条路径。

问题的解就是总的路径数 ((n+m, m)) - 情况I的路径数 - 情况II.b的路径数。

\* ((n+m , m)) - 2((n+m-1, m-1)) 或： ((n+m-1 , m)) - ((n+m-1 , m-1))**


问题2


描述：有n个1和m个-1（n>=m），共n+m个数排成一列，满足对所有0<=k<=n+m的前k个数的部分和Sk >= 0的排列数。


（和问题1不同之处在于此处部分和可以为0，这也是更常见的情况）


问题等价为在一个格点阵列中，从（0，0）点走到（n，m）点且不穿过对角线x==y的方法数（可以走到x==y的点）。


把（n，m）点变换到（n+1，m）点，问题变成了问题1。


方法数为：

((n+m+1, m)) - 2\*((n+m+1-1, m-1)) 

或：((n+m+1-1, m)) - ((n+m+1-1, m-1))


从上述中，可知本题的求解。

建一个n\*m的二维坐标系 1为向右 0为向上 若折线的路径的总数为A=C（n+m，m）或A=C（n+m，n）。

其中经过了直线 y=x（不包括恰在线上）的路径为不合法的。

由折线原理问题1,2 。 可以以y=x+1为对称轴找（0,0）的对称点 （-1,1） 可知 从此点出发到（n,m）的路径为所有不合法的。

所以B=C（n+1+m-1，n+1）或B=C（n+1+m-1，m-1）；即为B=C（n+m，n+1）或B=C（n+m，m-1）。

则ans=（A-B）%20100403；


然而n，m范围很大，因为有分母 边乘边取模是不正确的。

设分母为fm 分子为fz，fm的逆元为ny p=20100403

则 （ny\*fm）%p==1

（fz/fm）%p==（fz\*（pow(fm,-1)））%p;

即（fz\*ny）%p；


所以，在分母求一个逆元即可；


```cpp
#include <iostream>
using namespace std;
#define p 20100403
#define ll long long
ll q,n,m;
ll ans,fz=1,fm=1;
ll gcd(ll a,ll b,ll &gd,ll &x,ll &y)
{
    if(!b)  x=1,y=0,gd=a;
    else    gcd(b,a%b,gd,y,x),y-=x*(a/b);
}
ll work(ll a,ll b)
{
    ll gd,x,y;
    gcd(a,b,gd,x,y);
    if(gd==1)
        return (x+b)%b;
    //else return -1;//某犇的写法  但注释掉没影响
}
int main()
{
    cin>>n>>m;
    fz=n-m+1;
    fm=n+1;
    for(int i=n+1;i<=n+m;i++)
        fz=((fz%p)*(i%p))%p;
    for(int i=2;i<=m;i++)
        fm=((fm%p)*(i%p))%p;
    ll ny=work(fm,p);
    ans=(ny*fz)%p;
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：楚泫 (赞：14)

# 生成字符串解题报告

- ## 本题解为了讲的更加通俗，在叙述上可能会有些繁琐orz


首先我们分析一下题目要求：

- 用n个1和m和0组成字符串，且截至到任意位置，1的个数一定大于等于0的个数。

我们考虑建立一个平面直角坐标系，x坐标轴表示1和0的个数和，y坐标轴表示1和0的个数差。

因此只要选一个新的数字，就是向右走。

- 选择0就是向右下（1的个数减去0的个数变少了一个），

- 选择1就是向右上走（1的个数减去0的个数增加）。

由于直接求合法方案数比较困难，所以先求出全部方案数再减去不合法方案数。

- 全部方案数：从(0,0)点走到(n+m,n-m)点的个数。

	即选择了全部n+m个数字，1的个数比0的个数恰好多了n-m个。
	
    等同于从n+m个数中选择了n个1，方案数位C(n+m,n)或C(n+m,m)。

- 不合法方案数，

	任意一点的 1个数减0个数 小于零，即经过 y=-1 这条线的情况全部不合法。
    
    利用**等效替代法**：

	我们把不合法的情况在经过 y=-1 这条线之前的线以 y=-1 为对称轴向下翻折。
    
    起点就变成了 (0,-2)，终点仍然是 (n+m,n-m)。

	再沿y轴向上平移2个单位，即从(0,0)走到(n+m,n-m+2)，
    
	设选择x个1，y个0，那么x+y=n+m，x-y=n+m-2。两式相加解得x=n+1。
    
	即选择n+1个1，m-1个0。

　　故不合法方案数等于C(n+m,n+1)。

	答案即  C(n+m,n) - C(n+m,n+1)。

---
## 代码如下

```cpp
const int p=20100403;
int n,m;
const int N=1e6+5;
ll jc[N<<1];

inline ll ksm(ll a,ll b)
{
    ll ans=1;
    while(b)
    {
        if(b&1) ans=(ans*a)%p;
        a=(a*a)%p;
        b>>=1;
    }
    return ans;
}

inline ll C(int a,int b)
{
    return jc[a]*ksm(jc[a-b]*jc[b]%p,p-2)%p;
}

int main()
{
    scanf("%d%d",&n,&m);
    jc[1]=1;
    for(int i=2;i<=m+n;i++)
    {
        jc[i]=jc[i-1]*i%p;
    }
    cout<<(C(n+m,m)-C(n+m,m-1)+p)%p;
}
```

---

## 作者：SpeMars (赞：8)

这是一道Catalan+Lucas+乘法逆元+容斥原理の题目

首先我们可以把题意转化为一张图片

![](https://cdn.luogu.com.cn/upload/image_hosting/e8r463jj.png?x-oss-process=image/resize,m_lfit,h_1000,w_1000)

如果我们把向右走看成选择一个 $1$ 那么向上走就要相应的看成选择一个 $0$

那么当我们从 $(0,0)$ 走到 $(n,m)$ 时我们就完成了字符串的生成

那么抛开题目的任意前缀中 $1$ 的个数必须 $\ge$ $0$ 的个数の条件

我们计算一下一共有多少种方案数

显然，对于每一步我们都可以向上或向右。

我们一共需要走 $n+m$ 步才能到达 $(n,m)$ 且其中 $n$ 步必须向右

剩余部分(即剩余 $m$ )步必须向上

所以总的方案数为 $\Large{C^n_{n+m}}$ 或 $\Large{C^m_{n+m}}$ (两者相等)

那么原题目的限制条件又怎么处理呢?

我们不难发现只要任一时刻向右走的次数大于等于向上走的次数

就可以判断该情况是否合法

我们可以把每个零界点标出来，即每个 $(x,x+1)$

that is 每个点的向上走的次数正好比向右走的次数多一(刚刚跨越条件)

我们把这条直线画出来(图中红线)

只要我们的点不经过红线且能到达点 $(n,m)$ 

则该路径生成的字符串一定为合法字符串

我们可以考虑用全部的到达 $(n,m)$ 的方案数减去经过红线但是到达 $(n,m)$ 的方案数

这样就可以求出不经过红线且到达 $(n,m)$ 的方案数了，即为题目所求

我们把经过红线的每条到达 $(n,m)$ 的路径记为 $l_i$

我们可以把每个 $l_i$ 经过红线后的部分翻转这样我们走到的终点不是 $(n,m)$ 

而是 $(m-1,n+1)$ 不懂可以再看看上面图片

那么我们依样画葫芦从点 $(0,0)$ 走到 $(m-1,n+1)$ 的方案数就为

$\Large{C^{n+1}_{n+m}}$ 或 $\Large{C^{m-1}_{n+m}}$ (两者相等)

那么 $ans$ = $\Large{C^n_{n+m}}-\Large{C^{n+1}_{n+m}} $

最后别忘记Lucas和乘法逆元处理取模结果(这里不详细展开了)

code:

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
typedef long long ll;
const ll mod=20100403;
ll n,m;
ll fpow(ll x,ll y){
    ll tot=1,base=x;
    for(;y;y>>=1){
        if((y&1))tot=(tot*base)%mod;
        base=(base*base)%mod;
    }
    return tot%mod;
}
ll C(int n,int m){
    ll sum=1,ni=1;
    for(int i=1;i<=m;++i){
        sum=(sum*(n-i+1))%mod;
        ni=(ni*i)%mod;
    }
    ni=fpow(ni,mod-2);
    return (sum*ni)%mod;
}
ll lcs(ll n,ll m){
    if(m==0)return 1;
    return C(n%mod,m%mod)*lcs(n/mod,m/mod)%mod;
}
int main(){
    scanf("%lld%lld",&n,&m);
    printf("%lld",((lcs(n+m,n)-lcs(n+m,n+1))%mod+mod)%mod);
    return 0;
}
```

---

## 作者：欧鹰 (赞：8)

以前每篇博客前，都先有一波废话，但这次不知道说些什么，所以我们直接开讲。


------------

很明显，作为蒟蒻，一开始看这道题，我并不知道思路，觉得这道题很神仙，之后，点开标签，看到了数论，数论！！！！他怎么能是数论呢！！！！！！实在没有思路后，点开了题解，题解中每位神犇讲的很详细，但我作为数学渣渣，并看不懂。经过一天的理解，才可以站在这里给大家写题解。
**所以我只说几个我不懂的地方，帮助其他题解更好理解，给我们这些蒟蒻理解(~~大佬可以绕开~~)**

------------
第一点，我们要想到一点点的容斥原理，正的不好求，就要想反的，然后拿总的减去即是答案。

第二点，总方案数，很明显就是有n+m个位置，然后挑选n个位置给1，很明显这就是C(n+m,n)，也很明显他与C（n+m，m）相等，（**展开即可证明**）。

第三点，反的方案数，具体我就不画了（请大家移至其他题解）,我就解释一下C(n+m,m−1)中的m-1是从哪里来的，正如其他大佬所说，m即代表（x坐标加1，y坐标减1），所以m少了一，他就会少下降1，并且n会多一，也就是会上升1，这样的就会从-2又到0，
即得出C(n+m,m−1)。
```cpp
#include<bits/stdc++.h>

#define int long long

using namespace std;

const int p=20100403;

int h[2100405],n,m;

int power(int a,int b,int mod)
{	
    int ans=1;

	while(b!=0)
	{
		if(b%2==1) ans=ans*a%mod;
		
		a=a*a%mod;
		
		b=b/2;
	}
	
	return ans;
}

int lucas(int n,int m)
{
	if(m>n) return 0;
	
	return h[n]*power(h[m],p-2,p)%p*power(h[n-m],p-2,p);
}

int query(int n,int m)
{
	if(m==0) return 1;
	
	 return lucas(n%p,m%p)*query(n/p,m/p)%p;
}

signed main()
{
	
    cin>>n>>m;
		
	h[0]=1;
		
	for(int i=1;i<=n+m+1;i++) h[i]=h[i-1]*i%p;
		
	cout<<(query(n+m,n)-query(n+m,n+1)+p)%p<<'\n';
	
	return 0;
	
}
```
谢谢大家。

---

## 作者：tth37 (赞：6)

本题是卡特兰数的一个简单变式。

回忆卡特兰数的推导过程，可以生成的所有字符串共有$C_{n+m}^n$个，其中不合法的字符串有$C_{n+m}^{n+1}$个。最终答案即为$C_{n+m}^{n}-C_{n+m}^{n+1}$。计算组合数前须预处理出阶乘逆元。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int p = 20100403;
int N, M;
int inv[2000005], fac[2000005], facinv[2000005];
int C(int n, int m) {
    return (ll) fac[n] * facinv[m] % p * facinv[n - m] % p;
}
int main() {
    cin >> N >> M;
    inv[1] = 1; fac[0] = fac[1] = 1; facinv[1] = 1;
    for (register int i = 2; i <= N + M; ++i) {
        inv[i] = (ll) (p - p / i) * inv[p % i] % p;
        fac[i] = (ll) i * fac[i - 1] % p;
        facinv[i] = (ll) facinv[i - 1] * inv[i] % p;
    }
    cout << (C(N + M, N) - C(N + M, N + 1) + p) % p;
    return 0;
}
```

---

## 作者：ix35 (赞：4)

大佬们都太厉害了...公式推的很简洁。

不过由于我一开始看卡特兰数的证明就不是这个版本，所以就在这里分享另一个证明（不知是不是殊途同归）。

首先，我们去除那个有关前缀的条件。考虑将$n$个1和$m$个0随意放置的总方案数，我们只要在$n+m$个位置中选出$m$个放0，其余放1即可，所以总方案数为：
$$S_1=C_{n+m}^m$$
然后我们再统计出不符合要求的方案数，减一减就可以了。

首先思考不符合要求是什么情况，也就是存在某个前缀使得0的个数多与1的个数。而且因为0的个数在每一位只会增加1，所以一定存在这样一个临界位置$2p+1$，使得在区间$[1,2p+1]$中恰好有$p$个1和$p+1$个0，也就是0正好比1多一个。（似乎就是对应了大佬们题解里的那条直线）

下面就是重点，我们将$[2p+2,n+m]$这个区间（也就是后半部分）里的所有01全部取反，那么由于前半部分有$p$个1，所以后半部分就有$n-p$个1，取反后就变成了$n-p$个0，再加上前面的$p+1$个0，总共是$n+1$个0。

同样，前半部分有$p+1$个0，所以后半部分有$m-p-1$个0，取反后就变成了$m-p-1$个1，再加上前半部分的$p$个1，总共$m-1$个1。因此将后半部分取反后我们得到了一个含有$n+1$个0和$m-1$个1的序列。而这样的序列的个数是很容易算的，在$n+m$个位置中选$m-1$个放1，其余放0：
$$S_2=C_{n+m}^{m-1}$$
这是不符合要求的方案数，那么符合要求的就是：
$$S_1-S_2=C_{n+m}^m-C_{n+m}^{m-1}$$
注意求一下阶乘的乘法逆元，然后直接用结论计算即可。

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN=2000010,P=20100403;
ll n,m,fac[MAXN],inv[MAXN];
ll qpow (ll a,ll b) {
    ll res=1;
    while (b) {
        if (b&1) {
            res=(res*a)%P;
        }
        a=(a*a)%P;
        b>>=1;
    }
    return res;
}
void init () {
    fac[0]=1;
    for (int i=1;i<=MAXN-10;i++) {
        fac[i]=(fac[i-1]*i)%P;
    }
    inv[MAXN-10]=qpow(fac[MAXN-10],P-2);
    for (int i=MAXN-11;i>=1;i--) {
        inv[i]=(inv[i+1]*(i+1))%P;
    }
    return;
}
ll solve (int n,int m) {
    return (((fac[n]*inv[m])%P)*inv[n-m])%P;
}
int main () {
    init();
    scanf("%d%d",&n,&m);
    printf("%d",(solve(n+m,m)-solve(n+m,m-1)+P)%P);
    return 0;
}
```


---

## 作者：zhoudong (赞：4)

这道题目的答案不难发现就是总的方案数-不合法的方案数，即c(n+m,m)-c(n+m,m-1)。因为n，m很大，所以要用逆元进行计算。而20100403刚好是质数，所以可以直接用费马小定理来求解。

```cpp
#include <iostream>
#include <cstdio>
#define ll long long
using namespace std;
const ll N=20100403;
ll n,m,tot,unf,ans;
inline ll read()
{
    ll f=1,x=0;char c=getchar();
    while (c<'0'||c>'9') {if (c=='-') f=-1;c=getchar();}
    while (c>='0'&&c<='9') {x=x*10+c-'0';c=getchar();}
    return f*x;
}
inline ll pow(ll x,ll y)//快速幂
{
    if (y==0) return 1;
    ll k=1;
    while (y)
    {
        if (y&1) k=k*x%N;
        y/=2;
        x=x*x%N;
    }
    return k;
}
int main()
{
    n=read();m=read();
    tot=unf=1;
    for (ll i=m+1;i<=n+m;i++)
        tot=tot*i%N*pow(i-m,N-2)%N;//总方案数
    for (ll i=m;i<=n+m;i++)
        unf=unf*i%N*pow(i-m+1,N-2)%N;//非法方案数
    ans=((tot-unf)%N+N)%N;
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：Mingoal (赞：4)

这道题难度是唬人的吧，事实上不难，就是卡塔兰数变一下，计算 (n+m)!/(n+1)!/m!\*(n-m+1)%20100403

大部分人用的是扩展欧几里得，但我不是

我是统计n+m，n+1，m这些数的阶乘中各个质因数的个数，相减就行了

可是我偏偏就错了一个点，怎么都过不了（和大神们的程序对拍出来的数据中n+m是质数）

于是我请教了bdf大神，他给我处理了一下特殊情况，详见代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int o=2000003,M=20100403;
int n,k,prime[o],b[o],x,m,i,j;
long long ans=1,_=1;
int calc(int x,int y){  //计算y!中有几个质因数x
    int s=0;
    for (;y>=x;y/=x,s+=y);
    return s;
}
int main(){
    cin>>n>>m;
    for (i=2;i<=n+m;i++){
        if (!b[i]) prime[k++]=i;
        for (j=0;j<k && (long long)i*prime[j]<=n+m;j++){
            b[i*prime[j]]=1;
            if (i%prime[j]==0) break;
        }
    }
    for (i=0;i<k;i++){
        x=calc(prime[i],n+m)-calc(prime[i],n+1)-calc(prime[i],m); 
        for (j=0;j<x;j++) ans=ans*prime[i]%M;
        while(x<0)_*=prime[i],++x;   //特殊情况，自己理解一下
    }
    ans=ans*(n-m+1)/_%M;
    cout<<ans;
} 
```

---

## 作者：_ctz (赞：3)

[安利blog](https://ctz45562.github.io/2019/05/30/洛谷-P1641-SCOI2010-生成字符串/)

[传送门](https://www.luogu.org/problemnew/show/P1641)

一个单次回答$O(n)$的非正解，介于该题数据水所以能过。

总方案数为$C_{m+n}^n$，用总方案数减去不合法的即为答案。

枚举一下第一个不合法的位置$i$。换句话说，枚举一个位置$i$，在它前面的$0,1$数量相等，在该位上放一个$0$，就能产生一种不合法的情况。显然$i$为奇数。

前面$0,1$数量相等就是卡特兰数$C_{i-1}$，后面$n+m-i$个位置放$n-\frac{i-1}{2}$个$1$，有$C_{n+m-i}^{n-\frac{i-1}{2}}$种情况，乘起来就是答案。

其实这个式子应该能化成正解的式子，然而太复杂而且足以通过此题。

因为$n+m$超模数了所以还要再套个卢卡斯，不过这里只是个极小的小常数了。

这个思路还是蛮好想的$QwQ$

代码：

``` cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>

#define maxn 4000005
#define inf 0x3f3f3f3f

const int mod = 20100403;

using namespace std;

inline int read(){
    int x=0,y=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return y?-x:x;
}
int fac[maxn]={1},inv[maxn];
int INV(int x){return x==1?1:1ll*(mod-mod/x)*INV(mod%x)%mod;}
inline int C(int n,int m){
    if(n<m)return 0;
    if(n>=mod)return 1ll*C(n/mod,m/mod)*(n%mod,m%mod)%mod;
    return 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod;
}
inline int Cat(int n){
    return 1ll*fac[n<<1]*inv[n]%mod*inv[n+1]%mod;
}
int main(){
    int n=read(),m=read();
    for(register int i=1;i<=n+m<<1;++i)fac[i]=1ll*fac[i-1]*i%mod;
    inv[n+m<<1]=INV(fac[n+m<<1]);
    for(register int i=(n+m<<1)-1;~i;--i)inv[i]=1ll*inv[i+1]*(i+1)%mod;
    int ans=0;
    for(register int i=1;i<=n+m;i+=2)
        (ans+=1ll*Cat(i-1>>1)*C(n+m-i,n-(i-1>>1))%mod)%=mod;
    printf("%d\n",(C(n+m,n)-ans+mod)%mod);
}
```



---

## 作者：hhhhyq (赞：3)

这个题...题解里都说是卡特兰数，其实可以换种思路来想，这也是一个经典问题——格路问题

 **格路问题：平面直角坐标系中的点与点路径条数（只可向右或向下）** 

1.从(0，0) 到(m,n)的路径数
- 考虑路径长度即走的步数 那么总步数为$m+n(m-0+n-0)$ 
- 每次选择向右或向下走 那么总方案数为$C(m+n,m)=C(m+n,n)$

2.从(x，y）到(m,n)的路径数

考虑路径长度即走的步数 那么总步数为$m-x+n-y$

每次选择向右或向下走 那么总方案数为$C(m-x+n-y,m-x)=C(m-x+n-y,n-y)$


3.从(0，1)到(m,n) 不接触x-y=0的路径数
所有合法的方案数=所有-不合法

所有方案（由2）$=C(m+n-1,m)=C(m+n-1,m)$

不合法方案 考虑_ (0,1)_ 关于_ (x,y)_ 的对称点_ (1,0) _ 其每一条到达_ (m,n)_ 的路径均经过直线_ x-y=0 _ 这些路径关于直线x-y=0的对称路径即为从_ (0,1)_ 到达_ (m,n)_ 的所有不合法路径 方案数为 $C(m+n-1,m-1)$

总方案数$C(m+n-1,m)-C(m+n-1,m-1)=(……)$_ (省略化简，提公因式，balabala)_ $=(1-m/n)*C(m+n-1,m)$

4.从(0，0）到(m,n) 可接触不穿过x-y=0的路径数
问题转化为->不接触$x-y=-1 $的路径数
思路同3（求对称点 得不合法路径数）
$ans=(n+1-m)/(n+1)*C(m+n,n)$

### 5.本题....### 

如果大家认真看完上面的几条，应该会很容易发现，就是问题4

* 注意处理一下组合数，逆元

代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<bitset>

using namespace std;

const int maxn=2000005;
const long long mod=20100403;

typedef long long ll;

ll fac[maxn],inv[maxn];
ll n,m;

ll qpow(ll a,int d){
	ll res=1;
	for(;d;d>>=1,a=(a*a)%mod)if(d&1)res=(res*a)%mod;
	return res;
}

void init(){
	fac[0]=1;
	for(ll i=1;i<=2000000;i++){
		fac[i]=(fac[i-1]*i)%mod;//if(i<=20)cout<<fac[i]<<endl;
	}
	inv[2000000]=qpow(fac[2000000],mod-2)%mod;
	for(ll i=2000000;i>=1;i--){
		inv[i-1]=(inv[i]*i)%mod;
	}
}

int main(){
	init();
	scanf("%lld%lld",&n,&m);
	printf("%lld\n",(n-m+1)%mod*fac[m+n]%mod*inv[m]%mod*inv[n]%mod*qpow(n+1,mod-2)%mod);
}


```


---

## 作者：slothfulxtx (赞：2)

我曾经做过这样一道数学竞赛题，说是有一个收费站，初始时收费站没有钱，前来若干个人交钱，每人都交5元，但是有人带5元，有人带10元，问不会出现无钱可找的概率有多大，突然间联想到了那道题，这道题其实是一样的，当时数学老师是这样讲的：从起点出发，收到5元平行于x轴走一个单位，收到十元平行于y轴走一个单位，保持构成的折线在y=x之下即为合法方案，这道题也可以这样理解，终点为（n,m）。那么如何求合法方案数呢？事实上我们无法很简洁的求出合法方案数，但是可以求出不合法方案数（即穿过y=x的折线），注意到，与y=x有交点不一定就穿过它，所以，为了简化，我们将y=x-->y=x+1，与y=x+1有交点的一定不合法，对于一个不合法的方案，它一定有至少1次与y=x+1相交，我们将这个相交处以前的折线沿y=x+1翻折，易知，翻折前后一一对应，这表示：不合法方案与以（0，0）关于y=x+1的对称点为起点到（n,m）的路径数一一对应，所以总方案数为c(n+m,n),非法方案数为c(n+m,n+1)

```delphi

program p1641;
const mod1=20100403;
var
  n,m,ans:int64;
  i:longint;
procedure gcd(a,b:int64;var d,x,y:int64);
begin
  if b=0 then begin
      d:=a;x:=1;y:=0;
    end else begin
      gcd(b,a mod b,d,y,x);
      y:=y-x*(a div b);
    end;
end;
function inv(a,n:int64):int64;
var d,x,y:int64;
begin
  gcd(a,n,d,x,y);
    if d=1 then exit((x+n)mod n) else exit(-1);
end;
begin

    readln(n,m);
    ans:=1;
  for i:=n+2 to n+m do 
      ans:=ans*i mod mod1;
    ans:=ans*(n-m+1)mod mod1;
    for i:=1 to m do 
      ans:=ans*inv(i,mod1) mod mod1;
  writeln(ans);
end.

```

---

## 作者：BreakPlus (赞：1)

## $\text{Solution}$
看看此题，$1$ 的个数大于 $0$ 的个数，我们不如把这玩意变成栈—— $1$ 表示入栈，$0$ 表示出栈。

``Catalan`` 数都知道吧？它可以解决出栈的方式有几种的问题，如下：

$\text{C}_{2n} ^{n} - C_{2n}^{n-1}$

其中，$2n$ 不就是出栈+入栈的总操作次数吗？$n$ 与 $n-1$ 不就是出栈次数吗？

此题便是：

$\text{C}_{n+m}^{m}-\text{C}_{n+m}^{m-1}$

用费马小定理求得即可。

## $\text{Code}$

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
 
typedef long long ll;
const int maxn=1000010;
const int Mod=20100403;
#define int long long
int n,m;int fac[maxn<<1];
inline int quickpow(int a,int b)
{
    int ans=1,base=a;
    while(b)
    {
        if(b&1) ans=ans*base%Mod;
        base=base*base%Mod;
        b>>=1;
    }
    return ans;
}
inline void init()
{
    fac[1]=1;
    for(register int i=2;i<=n+m;i++) fac[i]=fac[i-1]*i%Mod;
}
inline int C(int N,int M)
{
    int inv1=quickpow(fac[N-M],Mod-2);
    int inv2=quickpow(fac[M],Mod-2);
    return fac[N]*inv1%Mod*inv2%Mod;
}
signed main()
{
    scanf("%lld%lld",&n,&m);
    init();
    printf("%lld\n",(C(n+m,m)-C(n+m,m-1)+Mod)%Mod);
}
```

---

## 作者：keep_ (赞：1)

# 卡特兰数

参考[博客](https://blog.csdn.net/qq_30115697/article/details/88906534)

## 介绍

卡特兰数为组合数学中的一种特殊数列，用于解决一类特殊问题

设$f(n)$为卡特兰数的第n项

其通项公式为 
$$
f(n)=\frac{2n\choose n}{n+1}
$$
关于它的[证明](https://blog.csdn.net/chenf1999/article/details/108740665)

当然也有递推式
$$
f(n)=\sum\limits_{i=0}^{n-1}f(i)\ast f(n-i-1)
$$
最常用的则是对于通项的变形式
$$
f(n)={2n\choose n}-{2n\choose n-1}
$$
在此给出一较易的[证明](https://www.cnblogs.com/GavinZheng/p/11706690.html)

## 例题

我们来看一道例题[洛谷 p1641 生成字符串](https://www.luogu.com.cn/problem/P1641)

比较模板的一道卡特兰数的例题，用上面给出的公式可以直接求解，我们对本题建模，假设m=n,我们建立一个

$n*n$的网格图,把0看作向上走一个单位，把1看作向右走一个单位，我们以$(0,0)$为起点，$(n,n)$为终点，

考虑到本题的限制，即在任意的前 k 个字符中，1 的个数不能少于 0 的个数，所以，每一个合法的路

径都不能越过该网格图的对角线，设直线$l$为将对角线向上平移一个单位所得到的直线，所有经过

$l$的路径都是非法路径，我们用所有路径数减去非法路径数就是合法的路径数，设$x$为一非法路径与

直线$l$的交点，对该路径$x$后的部分以$l$为对称轴对称过去，我们发现，所有非法路径对称后的

终点都为$(n-1,n+1)$因为所有的对称后路径与先前的非法路径都是一一对应的，所以，非法路径个数

就是对称后路径个数，所以，用所有路径减去非法路径就是合法路径个

数，其实答案就是上面第三个公式。

对于$m<=n$,同样的思路，只不过非法路径的终点与$m=n$不一样了，只需

要求出对称点，其余与上相同

如果不是很清楚,建议看一下第三个公式的证明的博客

## 代码

具体求组合数采用卢卡斯定理

注意，在遇到需要取模后输出的题目，算出的答案可能为负数，所以就需要+mod后%mod，本题如果不这样写的话只有70分
.
```c++
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#define int long long
using namespace std;
const int maxn=3e6+10;
const int p=20100403;
int n,m;
int a[maxn];
int power(int x,int t)
{
    if(x==0) return 0;
	x%=p;
    int b=1;
    while(t)
    {
        if(t&1) b=b*x%p;
        x=x*x%p; t>>=1;
    }
    return b;
}
int cm(int a1,int b1){
	if(a1<b1)
		return 0;
	return (a[a1]*power(a[b1],p-2)%p)*power(a[a1-b1],p-2)%p;
}
int lucas(int n,int m,int p){
	if(!m){
		return 1;
	}
	return cm(n%p,m%p)*lucas(n/p,m/p,p)%p;
}
signed main(){
	ios::sync_with_stdio(false);
	cin>>n>>m;
	a[0]=1;
	for(int i=1;i<=n+m+10;i++){
		a[i]=(a[i-1]*i)%p; 
	}
	int nn=m-1;
	int mm=n-nn+m;//(nn,mm)为非法路径的终点
	cout<<(lucas(n+m,n,p)-lucas(nn+mm,nn,p)+p)%p;
	return 0;
}
```

---

## 作者：Jμdge (赞：1)

这是什么神仙题啊。。。

看了差不多一个小时的题解终于看懂了。

题意是说求合法路径数的，那么我们考虑用全方案数-不合法方案数。

全方案数好像，$C(n+m,n)$ 或者 $C(n+m,m)$

然后我们考虑路径其实就是平面直角坐标系上的从$(0,0)$出发的，终点是$(n+m,n-m)$一条连续的折线。

其中 1 就是向右上方移动， 0 就是向右下方移动。

于是不合法的方案必然经过 $y=-1$ 这条平行于 x 轴的直线。

那么我们对这条路径在 **碰到这条直线之前的部分** 考虑上下翻转，

那么我们就得到了一条从 (0,-2) 出发的折线，它的终点同样是 $(n+m,n-m)$。

此时相当于 1 的个数（即向右上方移动的次数+1，右下方移动次数-1）

那么我们只需要求出 $C(n+m,n+1)$ 即为不合法方案数

```cpp
//by Judge
#include<cstdio>
#include<iostream>
#define ll long long
using namespace std;
const int mod=20100407;
ll n,m;
ll C(ll x,ll y){
	ll a=1,b=1,d=1,p=mod-2;
	for(ll i=y+1;i<=x;++i) a=a*i%mod;
	for(ll i=2;i<=x-y;++i) b=b*i%mod;
	for(;p;p>>=1,b=b*b%mod)
		if(p&1) d=d*b%mod;
	return a*d%mod;
}
int main(){ scanf("%lld%lld",&n,&m);
	return !printf("%lld\n",(C(n+m,n)-C(n+m,n+1)+mod)%mod);
}
```
已添加防抄袭手段

---

## 作者：刘心远 (赞：1)

人生中AC的第一道该难度题，发个题解庆祝一下！

PS：我数学还行，看一眼就是卡塔兰，不过n!=m，所以=>本题在算法上讲......

解：有两个难点：1.要计算出通项公式（PS：对着平面直角坐标系傻看了两个小时搞出来的）

2.要做一个逆元（相对简单，不过有好几个细节害得我连着五次0分（WA）！！！）

算法：1.总方案数：C（n+m,m）； //不说了

2.非法方案数：C（n+m,m-1）； //从（-1，1）上走出来必为非法方案

PS：具体说明见soler，这里我不多说了......（太简单，不想说）

PS：其实，（-1，1）并不是真正地与非法方案一一对应，是计算结果恰符合而已

顺便@fnoi2014xtx：你那题我做过，只是我的5元是1元，10元是2元，无语......

顺便PS：不能边乘边模，有涉及除法！！！！！（害我交了三次，另两次为&没打和打成\*）

贴上华丽的标程：

```cpp
#include<iostream>
using namespace std;
const long long p=20100403;
long long n,m,i,ans; long long k1,k2,k3;
void gcd(long long a,long long b,long long &gd,long long &x,long long &y) //逆元
{
    if(!b)  {x=1; y=0; gd=a;}
    else {gcd(b,a%b,gd,y,x); y-=x*(a/b);}
}
long long work(long long a,long long b)
{
    long long gd,x,y; gcd(a,b,gd,x,y);
    if(gd==1)return (x+b)%b;
}
int main()
{
    cin>>n>>m; k1=n-m+1; k2=n+1; //计算方便
    for(i=n+1;i<=n+m;i++)k1=((k1%p)*(i%p))%p;
    for(i=2;i<=m;i++)k2=((k2%p)*(i%p))%p;
    k3=work(k2,p); ans=k1*k3%p;
    cout<<ans<<endl; return 0;
}
```

---

## 作者：LoverBoyInMacau (赞：1)

## $P1641 [SCOI2010]$生成字符串
---

### 前置知识
&ensp;&ensp;&ensp;&ensp;组合数、坐标轴。

### 题目描述

&ensp;&ensp;&ensp;&ensp;以$n$个$1$和$m$个$0$组成字符串，求出满足条件「在任意的前$k$个字符中，$1$的个数不能少于$0$的个数」的字符串数量。

### 解题思路
&ensp;&ensp;&ensp;&ensp;考虑到题目要求的条件「$1$的个数不少于$0$的个数」可以转化为坐标轴内点的横纵坐标。  
&ensp;&ensp;&ensp;&ensp;举例说明：  

![front](https://cdn.luogu.com.cn/upload/image_hosting/aagjhoet.png)

&ensp;&ensp;&ensp;&ensp;第一步：建系。将$x$轴设为$m + n$，y轴设为$m - n$，方案数则可以表示为从点$(0,0)$移动到点$(n + m,n - m)$的折线，每增加一个$1$或$0$代表当前点向$x$轴正半轴移动一单位长度，选择$1$代表向y轴正半轴移动一单位长度，选择$0$代表向$y$轴负半轴移动一单位长度。易得方案总数即为$C(n+m,n)$。  
&ensp;&ensp;&ensp;&ensp;  因为$1$的个数始终不少于$0$的个数，所以折线需保持在第一象限。  

&ensp;&ensp;&ensp;&ensp;第二步：排除不合法情况：$1$的个数少于$0$的个数，即折线在第四象限。  
&ensp;&ensp;&ensp;&ensp;我们考虑将在到达$y = -1$以前的部分全部沿$y = -1$的直线作对称，如下图所示。
![bottom](https://cdn.luogu.com.cn/upload/image_hosting/05e71vep.png)
&ensp;&ensp;&ensp;&ensp;折线的新起点变为$(0,-2)$，总次数还是$n + m$，但上升次数比下降次数多一次，方案数为$C(n+m,m-1)$。  

&ensp;&ensp;&ensp;&ensp;第三步：综合前两步的推导，得出式子：$Ans = C(n + m,n) - C(n + m,m - 1)$。

### 注意事项

&ensp;&ensp;&ensp;&ensp;$1$.注意取模。  
&ensp;&ensp;&ensp;&ensp;$2$.数据范围过大，先预处理逆元，再套用公式求出组合数。
  
### 参考程序
```cpp
#include<bits/stdc++.h>
#define re register
#define il inline
#define ll long long
#define MAXN 1000005
#define MAXM 1000005
#define MOD  20100403
#define rep(i,a,b)  for(re int i = a;i <= b;i ++)
#define drep(i,a,b) for(re int i = a;i >= b;i --)
#define Rep(i,a,b)  for(re int i = a;i < b;i ++)
#define Drep(i,a,b) for(re int i = a;i > b;i --)
#define fin(a)  freopen(#a".in","r",stdin)
#define fout(a) freopen(#a".out","w",stdout)

using namespace std;

il ll read(){
	ll x = 0;
	char ch = 0;
	while(!isdigit(ch)){
		ch = getchar();
	}
	while(isdigit(ch)){
		x = (x << 3) + (x << 1) + (ch ^ 48);
		ch = getchar();
	}
	return x;
}

il void write(ll x){
	if(x > 9){
		write(x / 10);
	}
	putchar(x % 10 + '0');
}

il ll Pow(ll a,ll b){
	ll ans = 1;
	while(b){
		if(b & 1)
			ans = ans * a % MOD;
		a = a * a % MOD;
        b >>= 1;
	}
	return ans % MOD;
}

il ll C(ll n,ll m){
	if(m > n)
		return 0;
	if(m > n - m)
		m = n - m;
	
	ll s1 = 1,s2 = 1;
	Rep(i,0,m){
		s1 = s1 * (n - i) % MOD;
		s2 = s2 * (i + 1) % MOD;
	}
	return s1 * Pow(s2,MOD - 2) % MOD;
}

il ll Lucas(int n,int m){
	if(!m)
		return 1;
	return C(n % MOD,m % MOD) * Lucas(n / MOD,m / MOD) % MOD;
}



int main(){
    #ifndef ONLINE_JUDGE
    fin(1641);
    fout(1641);
    #endif
    
	int n = read(),m = read();
	write((Lucas(n + m,n) % MOD - Lucas(n + m,m - 1) % MOD + MOD) % MOD);
	
	return 0;
}
```


---

## 作者：wsk_1202 (赞：0)

组合数模质数居然没有人写 $Lucas$ ..

关于本题的结果 $C_{n+m}^{m} \ - C_{n+m}^{m-1}$ 大佬们已经证明了，此处不再赘述。卢卡斯定理是用于组合数取模的数学定理，可以帮助我们快速求出答案。

[模板题链接](https://www.luogu.org/problem/P3807)

卢卡斯定理：若 $p$ 为质数，则 $C_{n}^{m} \ mod \ p = C_{n \ mod \ p}^{m \ mod \ p} \ * \ C_{n/p}^{m/p}$，$C_{n/p}^{m/p}$ 这一部分可以使用递归求出。由于本题模数 $20100403$ 为质数，故可以使用卢卡斯定理。核心算法时间复杂度应该是 $O(log_{p}n)$。

关于本定理的证明，有兴趣的小伙伴可以百度一下。

代码：

```cpp
#include <cstdio>
#define int long long //防止中途溢出用了long long
using namespace std;
int n,m;
int f[2000002];
const int mod=20100403;
inline int fpow(int b,int p,int mod)//快速幂不解释
{
	int ans=1,tmp=b;
	while(p)
	{
		if(p&1)ans=ans*tmp%mod;
		tmp=tmp*tmp%mod;
		p>>=1;
	}
	return ans%mod;
}
inline int inv(int a,int mod){return fpow(a,mod-2,mod);}//费马小定理求乘法逆元
inline int c(int n,int m)//求出单个组合数C(n,m)
{
	return (f[n]%mod*inv(f[m],mod)%mod*inv(f[n-m],mod)%mod)%mod;
}
inline int Lucas(int n,int m)//核心代码，使用卢卡斯定理递归求出答案
{
	if(!m)return 1;
	return c(n%mod,m%mod)*Lucas(n/mod,m/mod)%mod;
}
signed main()
{
	f[0]=1;
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n+m;i++)f[i]=f[i-1]*i%mod;//预处理阶乘
	printf("%lld\n",(Lucas(n+m,m)-Lucas(n+m,m-1)+mod)%mod);//不要忘记要加上mod再模，不然会出现负数...
	return 0;
}
```

---

## 作者：小塘空明 (赞：0)

首先我们发现正面计算比较困难，转化成不受限制的方案减去不合法的方案。

考虑建立一个坐标系，x轴表示选了的字符数，y轴表示1与0的差，终点就是(n+m,n-m);

不受限制的方案数就是从原点出发到终点的方案数。

不合法的方案数就是直线会经过y=-1的方案数，这个方案显然无法直接计算，因为它的直接计算无法保证肯定经过y=-1。

根据坐标系的对称性，将原直线与y=-1相交前的部分关于y=-1进行对称，等价于从(0,-2)出发到(n+m,n-m)的方案数,这样就能保证它与直线的相交了。

逆元线性逆处理即可。

---

## 作者：KKarshilov (赞：0)

	这道题我是先考虑的暴力……对于1000以内的数据，一个人O(n ^ 2)的dp是足够的，事实证明确实可行，献上我的暴力dp（30分）：
```cpp
#include <cstdio>
#define LL long long
using namespace std;
int n, m;
LL f[1200][1200];
const int mod = 20100403;
signed main() {
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; i++) f[i][0] = 1;
    for(int i = 1; i <= m; i++) f[0][i] = 1;
    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= i; j++) {
            f[i][j] = f[i][j - 1];
            if(i - 1 >= j) f[i][j] += f[i - 1][j];
            f[i][j] %= mod;
        }
    }
    printf("%lld\n", f[n][m] % mod);
    return 0;
}
```
然后考虑正解，catalan什么的快忘了，所以我是从别的方向推的，题目如果抛去01关系的要求，那么总的方案数就相当于从n+m个1中选取m个变成0的方案数，就是C(n+m,m)，然后？理论上我们应该好好推一推不合法的方案数，相减就是答案对吗？

**不存在的！这辈子都不会正常的做题！**

~~其实是没推出来……~~


但是没关系，我们还有暴力，因为总方案数和组合有关，我们大胆推测答案和组合有关，于是我把杨辉三角画了出来……然后，我们选定了几个n+m的值，然后，用组合算出总的，dp算出合法的，相减就得到不合法的……然后在杨辉三角中比划了几下……诶我好像看出来了……诶是不是C(n+m,m-1)……诶我们拍一拍……诶好像真的是啊

然后我们考虑组合数怎么算，恩，逆元，不过我用的是线性求逆元的方法，O(n)求出所有的，但是在这题意义不大……因为只有一组……难怪这么慢……

交一发……70分，不对不对，有负数，加一个mod再%一下

A了

```cpp
#include <cstdio>
#include <algorithm>
#include <cstdlib>
#include <cstring>
#define LL long long

const int mod = 20100403;
const int MAXN = 2000202;
const int lim = 2000001;
int n, m;

LL fac[MAXN + 3], inv[MAXN + 3];

void init() {
    fac[0] = 1;
    for(int i = 1; i < lim; i++) fac[i] = (long long)fac[i - 1] * i % mod;
    inv[0] = inv[1] = 1;
    for(int i = 2; i < lim; i++) inv[i] = (long long)(mod - mod / i) * inv[mod % i] % mod;
    for(int i = 1; i < lim; i++) inv[i] = (long long)inv[i] * inv[i - 1] % mod;
}

LL C(int a, int b) {
    if(b > a) return 0;
    if(a < mod) return (long long)fac[a] * inv[b] % mod * inv[a - b] % mod;
    return (long long)C(a / mod, b / mod) * C(a % mod, b % mod) % mod;
}

signed main() {
    scanf("%d%d", &n, &m);
    init();
    LL tot = C(n + m, m);
    LL ilg = C(n + m, m - 1);
    printf("%lld\n", (tot - ilg + mod) % mod);
    return 0;
}
```

---

## 作者：diker (赞：0)

[P1641](https://www.luogu.org/problemnew/show/P1641)

~~听说这好像时一道高考题orz~~

#### 思路：
用n代表1的个数，m代表0的个数，设 x=n+m，y=n-m，建立直角坐标系，生成字符串就可以用从（0，0）到（n+m，n-m）的上升n次下降m次的折线表示，所有的情况个数为C(n+m,m)。

要满足任意的前k个字符中，1的个数大于等于0的个数，也就是图像要始终在x轴的上方（n-m>=0）
![](https://cdn.luogu.com.cn/upload/pic/46965.png )

如果图像到了x轴下方则存在k=n+m，n-m<0，1的个数小于0的个数
![](https://cdn.luogu.com.cn/upload/pic/46962.png)

直接求图像在x轴上方的所有情况个数有点困难，根据对称性可以转化一下
图像有在x轴下方的情况可以看作折线到达y=-1
将图像到达y=-1之前的图像关于直线y=-1对称翻折可以得到
![](https://cdn.luogu.com.cn/upload/pic/46960.png)

![](https://cdn.luogu.com.cn/upload/pic/46963.png )

从（0，0）到达y=-1，下降的次数比上升的次数多一次，翻折后，可以看成从（0，-2）到y=-1，上升的次数比下降的次数多一次，这样，所有存在n-m小于0的情况数等于从（0，-2）上升n+1次下降m-1次的折线图像的所有情况个数：C(n+m,m-1)。

所以答案就为C(n+m,m)-C(n+m,m-1)

然后就是处理组合数的问题了，这个数据范围，用杨辉三角打表不现实，只能逆元打表了，之后用公式求组合数
#### 逆元打表
在模质数M下，求1~n的逆元（n<M，M为奇质数）：

   **inv[i] = (M-M/i) * inv[M%i]%M**
##### 板子：
```cpp
const int maxn = 1e6+5;
int inv[maxn];
void inverse(int n,int M){
	inv[1]=1;
	for(int i=2;i<=n;i++){
		inv[i]=(long long)(M-M/i)*inv[M%i]%M;
	}
}
```
推导过程：

由  (M/i) * i + M%i  = 0  (mod M)

=> -(M/i) * i = M%i  (mod M)     两边同时除以((M%i)xi)

即：-(M/i) * inv[M%i] = inv[i]  (mod M)

所以：inv[i]=(M-M/i) * inv[M%i]%M


#### 代码:
```cpp
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <cmath>
#include <algorithm>
#include <vector>
#include <set>
#include <map>
#include <stack>
#include <queue>
#include <cctype>
#include <sstream>
#define LL long long
#define _for(i,j,k) for(int i=j;i<=k;i++)
#define for_(i,j,k) for(int i=j;i>=k;i--)
#define lowbit(x) (x&-x)
#define ls(x) x<<1
#define rs(x) x<<1|1
using namespace std;
const LL M = 20100403;
const int N = 1e6+10;
int inv[N],fac[N],n,m;
void init(int n){
	fac[0]=1;
	for(int i=1;i<=n;i++){
		fac[i]=(LL)fac[i-1]*i%M;
	}
	inv[1]=1;
	for(int i=2;i<=n;i++){
		inv[i]=(LL)(M-M/i)*inv[M%i]%M;
	}
	for(int i=2;i<=n;i++){
		inv[i]=(LL)inv[i]*inv[i-1]%M;
	}
}
int comb(int a,int b){
	if(a==b||b==0) return 1;
	if(b<0||b>a) return 0;
	return (LL)fac[a]*inv[b]%M*inv[a-b]%M;
}
int main(){
	cin>>n>>m;
	init(n+m);
	if(n<m||m+n==0){
		cout<<0;
		return 0;
	} 
	int an=(comb(m+n,m)-comb(m+n,m-1))%M;
	cout<<an;
	return 0;
}
```


---

## 作者：一UNowen一 (赞：0)

第一次看到此题，不难想到DP做法，dp[i,j]表示i个1，j个0的字符串组成方案数，dp[i,j]=dp[i-1,j]+dp[i，j-1]，边界为dp[i,i+1]=0,dp[i,0]=1,但是显然，O(N2)的复杂度在本题显然是行不通的，事实上本题存在一个通项公式，dp[n,m]=(n+m)!\*(n-m+1)/(n+1)!/m!(不要问怎么求出的或者证明，笔者列了六行然后强行找出来的）。求出通项公式后主要的问题就是如何存储大数据以及取模，（n+m）!/(n+1)!\*（n-m+1)的取模结果不难求出，最后m!的处理需要一些技巧，使用快速幂以及逆元才可求出。此算法时间复杂度O（n），空间复杂度O（1），最大点62msAC


---


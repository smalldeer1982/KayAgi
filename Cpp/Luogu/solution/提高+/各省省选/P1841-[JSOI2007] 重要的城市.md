# [JSOI2007] 重要的城市

## 题目描述

参加 jsoi 冬令营的同学最近发现，由于南航校内修路截断了原来通向计算中心的路，导致去的路程比原先增加了近一公里。而食堂门前施工虽然也截断了原来通向计算中心的路，却没有使路程增加，因为可以找到同样长度的路作替代。其实，问题的关键在于，路截断的地方是交通要点。

同样的情况也出现在城市间的交通中。某些城市如果出了问题，可能会引起其他很多城市的交通不便。另一些城市则影响不到别的城市的交通。jsoi 冬令营的同学发现这是一个有趣的问题，于是决定研究这个问题。

他们认为这样的城市是重要的：如果一个城市 $c$ 被破坏后，存在两个不同的城市 $a$ 和 $b$（$a, b$ 均不等于 $c$），$a$ 到 $b$ 的最短距离增长了（或不通），则城市 $c$ 是重要的。

jsoi 冬令营的同学面对着一张教练组交给他们的城市间交通图，他们希望能找出所有重要的城市。现在就请你来解决这个问题。

## 说明/提示

- 对于 $30\%$ 的数据满足 $N\le 20$；
- 对于 $60\%$ 的数据满足 $N\le 100$；
- 对于 $100\%$ 的数据满足 $N\le 200,M\le \frac{N\times (N-1)}{2},0<c\le 10000$。$c$ 即路的长度。

保证不出现重边和自环。

## 样例 #1

### 输入

```
4 4
1 2 1
2 3 1
4 1 2
4 3 2```

### 输出

```
2
```

# 题解

## 作者：Parabola (赞：119)

不得不说


如果我在考场上遇到这题


只能拿50分


一开始做这题的时候


~~哈哈哈哈哈我不在js省且07年我才两岁~~


什么也没想，看200的数据范围我就直接暴力（连复杂度都没算）


于是思路就是模拟


先用Floyd跑一遍所有点都没被炸掉的最短路


然后在把每一个点都炸一遍


例如炸点x


那么我再跑一遍Floyd


如果中转点遇到x


那么我就continue


再把跑完的最短路和一开始跑的最短路比较


如果当中dis[i][j]>炸点x后的dis[i][j]


那么x就是重要的城市


那么时间复杂度就是每个点都跑一个Floyd为n^4



所以代码大致是下面这样


有注释






```c++



      #include<iostream>
      #include<cstdio>
      #include<algorithm>
      #include<queue>
      using namespace std;
      const int INF=2e6;
      int e[205][205],dis[205][205],m,n;//e邻接矩阵存边，dis[i][j]存i到j的最短路
      priority_queue<int> q;//输出最短路时要排序
      //从主程序开始阅读
      bool check(int x)
      {
          int map[205][205];//当炸掉点x时全图最短路
          for(int i=1;i<=n;i++)
              for(int j=1;j<=n;j++)
              {
                      map[i][j]=e[i][j];
              }
      //初始化
          for(int k=1;k<=n;k++)    
              for(int i=1;i<=n;i++)
                  for(int j=1;j<=n;j++)
                  {
                      if(k==x)//如果中转点为x，那么不进行这次循环
                          continue;
                      map[i][j]=min(map[i][j],map[i][k]+map[k][j]);
                  }    
          for(int i=1;i<=n;i++)
              for(int j=1;j<=n;j++)
                  {
                      if(map[i][j]>dis[i][j])
                          return true;//如果炸掉点x后的最短路比原最短路大，证明x是重要的城市
                  }
          return false;//x不是重要的城市
      }
      int main()
      {
          cin>>n>>m;//读入边数m，点数n
          for(int i=1;i<=n;i++)
              for(int j=1;j<=n;j++)
              {
                  if(i==j)
                      e[i][j]=dis[i][j]=0;
                  else
                      e[i][j]=dis[i][j]=INF;
              }
           //初始化
          for(int i=1,x,y,u;i<=m;i++)
          {
              cin>>x>>y>>u;
              e[x][y]=e[y][x]=dis[x][y]=dis[y][x]=u;
          }//读入
          for(int k=1;k<=n;k++)
              for(int i=1;i<=n;i++)
                  for(int j=1;j<=n;j++)
                      dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);//跑一遍Floyd

          for(int i=1;i<=n;i++)
          {
              if(check(i))//检测它是不是重要城市，这个时候把目光转向check函数
                  q.push(-i);//懒得将q改成从小到大，直接推负数进去
          }
          if(q.empty())   cout<<"No important cities.";//队空代表无重要城市   
          else
          {
              while(!q.empty())
              {
                  int v=-q.top();q.pop();
                  cout<<v<<' ';
              }
          }//输出
          return 0;
      }
```






这个时候


[这段代码只能过5个点](https://www.luogu.org/record/show?rid=5483453)







~~开了氧气黑科技可以过七个点~~


那么我们要换一种思路


（我也是想了一个晚上）


设cnt[i][j]表示i到j的最短路径条数


如果点x在i到j的最短路中出现了cnt[i][j]次


即i到j的最短路中每一条都要经过x的话


那么x一定为重要城市


OK

总结一下上面


除了任意两点之间的最短路之外


我们还需要cnt[i][j]和i到j的每一条最短路所经过的点


但是

这很难实现


~~其实是我不会~~


思考一下


第一点


在松弛中


i到j的路径中


如果通过点k可以使路径长度缩小


那么

i到j的最短路一定要经过k


第二点


如果松弛中发现e[i][j]==e[i][k]+e[k][j]


那么一定会不止一条最短路


这个时候我们以前发现经过的点都不一定走


所以

题目的思路就变成了这样


在松弛中




```c++
if(e[i][j]>e[i][k]+e[k][j])
{
    e[i][j]=e[i][k]+e[k][j];                        city[i][j]=k;//k是重要城市
}
```



如果发现i到j不止一条最短路


那么从city[i][j]中移除点k


最后我们还有两步


一是题目要求的排序


二是我们算法的判重


那么两者综合


我们选用桶排序


定义一个bool形的数组


循环i至n和j至n



ans[city[i][j]]=true;

输出时


    

if(ans[i])

    cout<<i;

所以整道题的思路就是这样了


代码我就不打注释了


~~觉得我写的好记得给个赞哦~~~


下为代码






```c++
    #include<iostream>
    #include<cstdio>
    #include<algorithm>
    #include<queue>
    using namespace std;
    const int INF=2e6;
    int e[205][205],city[205][205],m,n;
    bool ans[205],cs;
    int main()
    {
        cin>>n>>m;    
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                if(i!=j)
                    e[i][j]=INF;
        for(int i=1,x,y,u;i<=m;i++)
        {
            cin>>x>>y>>u;
            e[x][y]=e[y][x]=u;
        }
        for(int k=1;k<=n;k++)
            for(int i=1;i<=n;i++)
                if(i!=k)
                    for(int j=1;j<=n;j++)
                        if(i!=j&&j!=k)
                        {
                            if(e[i][j]>e[i][k]+e[k][j])
                            {
                                e[i][j]=e[i][k]+e[k][j];
                                city[i][j]=k;
                            }
                            else if(e[i][j]==e[i][k]+e[k][j])
                                city[i][j]=-1;
                        }
        for(int i=1;i<=n;i++) 
            for(int j=1;j<=n;j++)
                if(city[i][j]!=-1)
                    ans[city[i][j]]=true;    
        for(int i=1;i<=n;i++)
            if(ans[i])
                cout<<i<<' ',cs=true;
        if(!cs)
            cout<<"No important cities.";
        return 0;
    }
```

---

## 作者：木木！ (赞：40)

提供一个比较不同的$\Theta(n^3)$思路。只需要跑一次最短路。

首先看数据范围为$n\leq 200$，可以发现$\Theta(n^3)$的`Floyd`可以碾过。然后不需要记录路径上的点，只需要记录最短路的个数就可以了。

在输出的时候，对于每一个点`i`，如果存在一对点`j`和`k`满足`dist[j][i]+dist[i][k]==dist[j][k]`并且`num[j][i]*num[i][k]==num[j][k]`，则说明`j`到`k`的所有最短路都要经过`i`。时间复杂度为$\Theta(n^3)$。

附AC代码：

```cpp
#include <cstdio>
using namespace std;

inline void chkmin(int& a,int b)
{
	if(b<a)
	{
		a = b;
	}
}

int fi[205][205];
int ki[205][205];

int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	
	for(int i=1; i<=n; ++i)
	{
		for(int j=1; j<=n; ++j)
		{
			fi[i][j] = 0x3f3f3f3f;
		}
		fi[i][i] = 0;
	}

	for(int i=1; i<=m; ++i)
	{
		int a,b,c;
		scanf("%d%d%d",&a,&b,&c);
		chkmin(fi[a][b],c);
		chkmin(fi[b][a],c);
		ki[a][b] = ki[b][a] = 1;
	}

	for(int k=1; k<=n; ++k)
	{
		for(int i=1; i<=n; ++i)
		{
			for(int j=1; j<=n; ++j)
			{
				if(fi[i][k]+fi[k][j] < fi[i][j])
				{
					fi[i][j] = fi[i][k]+fi[k][j];
					ki[i][j] = ki[i][k]*ki[k][j];
				}
				else if(fi[i][k]+fi[k][j] == fi[i][j])
				{
					ki[i][j] += ki[i][k]*ki[k][j];
				}
			}
		}
	}

	for(int i=1; i<=n; ++i)
	{
		fi[i][i] = 0x3f3f3f3f;
	}

	bool flag = 0;
	for(int i=1; i<=n; ++i)
	{
		for(int j=1; j<=n; ++j)
		{
			for(int k=1; k<=n; ++k)
			{
				if(fi[j][k]==fi[j][i]+fi[i][k] && ki[j][k]==ki[j][i]*ki[i][k])
				{
					printf("%d ",i);
					flag = 1;
					goto nxt;
				}
			}
		}

		nxt:;
	}

	if(!flag)
	{
		printf("No important cities.");
	}
}
```

---

## 作者：kai586123 (赞：26)

怎么全都是Floyd...提供一个不一样的思路（可能蒟蒻脑回路清奇，第一思路就这个...）

一个城市x重要，当且仅当去掉它之后可以让s->t的最短路变化（s != t != x)。因为本题的n很小，我们可以枚举n作为s。

当确定s之后，以s为起点跑一次最短路，然后把所有在最短路上的边加入一个新图中。具体做法是：对于一条边，如果它起点处的最短路加上边权等于终点处的最短路，那么就把它加入新图中。

这个新图有一个很好的性质：它是一个DAG。原因很简单，最短路上没环= =。注意到这个最短路DAG记录了s为起点到所有点的最短路。

枚举1~n的每个点。如果存在边x->y，并且y的入度为1，那么删掉x之后y的入度会变成0，显然无法从s到达，即删掉x之后破坏了一些点的最短路。x就是一个关键点。

时间复杂度：枚举$O(n)$次，计算最短路$O(mlogn)$，求点x$O(m)$。所以总复杂度是$O(nmlogn)$。

```cpp
#include <bits/stdc++.h>
using namespace std;

inline int rd() {
    int a = 1, b = 0; char c = getchar();
    while (!isdigit(c)) a = c == '-' ? 0 : 1, c = getchar();
    while (isdigit(c)) b = b * 10 + c - '0', c = getchar();
    return a ? b : -b;
}

const int N = 500, M = N * N;
struct Graph {
    int from, to, nxt, c;
} g[M * 2];
int head[N], tot;

void addedge(int x, int y, int c) {
    g[++tot].to = y, g[tot].from = x, g[tot].c = c,
    g[tot].nxt = head[x], head[x] = tot;
}

int n, m;

priority_queue<pair<int, int> > que;
int dis[N], in[N];
bool vis[N], important[N], mark[M];

void solve(int s) {
    memset(dis, 0x3f, sizeof(dis));
    memset(vis, 0, sizeof(vis));
    dis[s] = 0;
    que.push(make_pair(0, s));
    while (!que.empty()) {
        int x = que.top().second;
        que.pop();
        if (!vis[x]) {
            vis[x] = true;
            for (int i = head[x]; i; i = g[i].nxt) {
                int y = g[i].to;
                if (dis[y] > dis[x] + g[i].c) {
                    dis[y] = dis[x] + g[i].c;
                    que.push(make_pair(-dis[y], y));
                }
            }
        }
    }

    memset(mark, 0, sizeof(mark));
    memset(in, 0, sizeof(in));
    for (int i = 1; i <= tot; ++i) {
        if (dis[g[i].from] + g[i].c == dis[g[i].to]) {
            mark[i] = true;
            ++in[g[i].to];
        }
    }

    for (int i = 1; i <= tot; ++i)
        if (mark[i] && in[g[i].to] == 1 && g[i].from != s)
            important[g[i].from] = true;
}

int main() {
    n = rd(), m = rd();
    for (int i = 1; i <= m; ++i) {
        int x = rd(), y = rd(), c = rd();
        addedge(x, y, c), addedge(y, x, c);
    }
    for (int i = 1; i <= n; ++i)
        solve(i);
    bool ok = false;
    for (int i = 1; i <= n; ++i)
        if (important[i]) {
            cout << i << " ";
            ok = true;
        }
    if (!ok) cout << "No important cities.";
    cout << endl;
    return 0;
}
```


---

## 作者：ButterflyDew (赞：20)

提供一个比较好理解的$O(n^3logn)$的分治算法

在Floyd松弛的过程中，其实哪个点先松弛哪个点后松弛是无所谓的哈

而我们最后拆点走其实就是只有一个点不松弛和所有点都松弛情况的一个对比，看各点的最短路情况有没有改变

对未松弛点集$[l,r]$

我们可以先松弛其中的一半$[l,mid]$，然后去另一半处理子问题，处理完了还原左区间，松弛右区间，再去左边处理问题

这样当区间大小为1时，就只是那个点没有参与松弛，我们对比一下即可

而对每个相同大小的区间构成的集合，它们实际上总共用了每个点松弛了一次，为$O(N^3)$（还原是$O(N^2)$的，算做常数）

一共有$logn$种大小的区间，所以总复杂度为$O(N^3logn)$

**Code:**
```
#include <cstdio>
#include <cstring>
int min(int x,int y){return x<y?x:y;}
const int N=202;
int g[N][N],n,m,flag,ans[N],d[N][N];
void divide(int l,int r)
{
    if(l==r)
    {
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                if(g[i][j]<d[i][j])
                {
                    ans[l]=1;
                    flag=1;
                    return;
                }
        return;
    }
    int tmp[N][N];
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            tmp[i][j]=d[i][j];
    int mid=l+r>>1;
    for(int k=l;k<=mid;k++)
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                d[i][j]=min(d[i][j],d[i][k]+d[k][j]);
    divide(mid+1,r);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            d[i][j]=tmp[i][j];
    for(int k=mid+1;k<=r;k++)
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                d[i][j]=min(d[i][j],d[i][k]+d[k][j]);
    divide(l,mid);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            d[i][j]=tmp[i][j];
}
int main()
{
    scanf("%d%d",&n,&m);
    memset(g,0x3f,sizeof(g));
    memset(d,0x3f,sizeof(d));
    for(int u,v,w,i=1;i<=m;i++)
    {
        scanf("%d%d%d",&u,&v,&w);
        d[u][v]=d[v][u]=g[u][v]=g[v][u]=w;
    }
    for(int k=1;k<=n;k++)
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                g[i][j]=min(g[i][j],g[i][k]+g[k][j]);
    divide(1,n);
    if(!flag) printf("No important cities.\n");
    for(int i=1;i<=n;i++)
        if(ans[i])
            printf("%d ",i);
    return 0;
}

```

---

## 作者：hsfzLZH1 (赞：12)

非常诧异大家为什么那么一致地使用$floyd$算法，这里来一个利用$SPFA$算法实现本题的做法。

$SPFA$算法：初始时将起始点加入队列，到其他节点距离设置为$inf$，每次取出队列头，对队列头的所有出边，判断能否进行松弛操作：
```cpp
if(dist[p[j]]>dist[x]+w[j])
	dist[p[j]]=dist[x]+w[j];
```
其中$dist[i]$代表当前计算到节点i的距离，$w[j]$就是这条出边的边权。

如果可以进行松弛操作，那么说明有节点的计算最短路被更新，将这个节点加入队列，以待以后的更新。注意不能让节点重复入队。

队列为空时，操作结束。

证明：每次松弛操作总会降低$dist[i]$的值。由于所有的边权都是正的（没有负环），所以总会有一个确定的最短路长度，通过更新一定能得到。时间复杂度$O(am)$，$a$和图的形状有关，一般约等于$2$。此外，如果有负权，当一个节点重复进队第$n$次，可以终止操作，此时保证有负环。

在$SPFA$算法中，需要用$O(1)$的较快时间复杂度完成一个节点所有出边每条边的访问，需要使用**链式前向星**，请自行查阅资料，在此不多做赘述。

实现此题，需要一个定义：**最短路树**。最短路树就是每个节点在树上到根节点的边就是其到根节点（就是起始节点，出发点）的最短路（之一）。也就是说，一个节点到根节点的最短路一定有一条是经过最短路树上的父亲节点的。借助这个性质，有了最短路树，我们就可以通过访问每个节点的父亲节点来求得出发点到该节点的最短路。

在这道题中，我们可以每进行一次成功的松弛操作，更新指向节点的父亲节点（也就是当前出队节点），如果是失败的松弛操作，该节点也可以是指向节点在最短路树上的节点，所以可能的路径数量$+1$。计算完这些后，我们对于每个**除根节点以外**的节点，如果在最短路树上有且仅有一个可能的父亲，那么这个节点在最短路树上的父亲节点是一个“重要的节点”，即去掉该点之后当前最短路的起始节点和该节点的子节点的最短路径长度变化。

代码：
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;
const int maxn=210;
const int maxm=40010;//无向图两次存边，数组大小双倍，切记！
const int inf=1e9;//正无穷的值，注意相加不要溢出
int n,m,x,y,z,cur,h[maxn],nxt[maxm],p[maxm],w[maxm],s,dist[maxn],fa[maxn],pa[maxn];//fa是最短路上的父亲，pa是可能的父亲个数
bool tf[maxn],ans[maxn],if_output;
queue<int>q;
inline void add_edge(int x,int y,int z)
{
    cur++;
    nxt[cur]=h[x];
    h[x]=cur;
    p[cur]=y;
    w[cur]=z;
}//链式前向星加边操作
int main()
{
    scanf("%d%d",&n,&m);
    while(m--)scanf("%d%d%d",&x,&y,&z),add_edge(x,y,z),add_edge(y,x,z);
    for(s=1;s<=n;s++)
    {
        for(int i=1;i<=n;i++)dist[i]=inf;
        memset(tf,false,sizeof tf);
        memset(pa,0,sizeof pa);
        memset(fa,0,sizeof fa);//初始化
        dist[s]=0;tf[s]=true;q.push(s);pa[s]=1;
        while(!q.empty()) 
        {
            x=q.front();
            for(int j=h[x];j;j=nxt[j])
            {
                if(dist[p[j]]>dist[x]+w[j])
                {
                    dist[p[j]]=dist[x]+w[j];
                    fa[p[j]]=x;
                    pa[p[j]]=0;
                    if(!tf[p[j]])tf[p[j]]=true,q.push(p[j]);
                }
                if(dist[p[j]]==dist[x]+w[j])pa[p[j]]++;
            }
            q.pop();tf[x]=false;//注意，此时才出队，不能提前出队！
        }
        for(int i=1;i<=n;i++)if(fa[i]!=s&&pa[i]==1)ans[fa[i]]=true;
    }
    for(int i=1;i<=n;i++)if(ans[i])printf("%d ",i),if_output=true;
    if(!if_output)printf("No important cities.");//输出
    printf("\n");
    return 0;
}
```
时间复杂度$O(nm)$，空间复杂度$O(m)$。

---

## 作者：wjyyy (赞：10)

我的blog传送门：[wjyyy](http://www.wjyyy.top/1195.html)

   因为Floyd是一种玄学DP思想，所以它的状态更新来源有很多，在这个题里需要整理出它的阶段性与转移，~~看上去~~十分麻烦。而我们如果把Floyd当作最短路算法中的松弛，就是相当于在把两段最短路拼接在一起，拥有它们合在一起的性质。



### 重要城市
   重要城市就是如果这个点被删掉，那么最短路的长度就会改变。因此这个点一定在最短路上。而当两点间的最短路有多条时，它们上的点不一定都是**重要城市**，经过分析我们可以这样理解：设$(u,v)$间最短路条数为$k$，重要城市为$p$，那么这$k$条最短路一定都经过点$p$。用反例来说明，就是如果不是$k$条最短路都经过点$p$，那么去掉点$p$，还有剩下的最短路可以走，则不合法。



   因此我们可以开一个三维数组$\mathrm{im[i][j][k]}$表示k在$i,j$的几条最短路上。而我们用floyd做最短路计数也比较方便，一旦$k$所在的最短路数量与$(i,j)$间的最短路数量相同，那么$k$就一定是一个重要城市，判断条件为$im[i][j][k]==cnt[i][j]\Rightarrow k$是重要城市。

![](http://www.wjyyy.top/wp-content/uploads/2018/08/201808041607.png)

   在上图中，1→8最短路计数为3，其中除了起点和终点，被经过了3次的点的点有2和7，因此它们是这条路径上的重要城市。



   因为floyd的时间复杂度为$O(N^3)$，而每次更新还要循环一个$N$，因此总时间复杂度为$O(N^4)$。



### bitset优化

   我们在上面提到，状态合并/更新需要额外枚举一个$O(N)$，我们可不可以把这个$N$省掉，或者说优化一点呢



   这时可以考虑$\mathrm{bitset}$，$\mathrm{bitset}$可以使常数优化32倍，这个题的$N$规模才200，优化一个32就快把一个$N$变成一个$\log N$了，这个题的数据规模还是可以承受的。不过$\mathrm{bitset}$存的是二进制啊，可是上面提到的数组存的是计数啊。



   我们可以换一个方式想想，如果这两个点之间已经找到了4条最短路，其中有3条经过点$p$，那此时$p$已经不合法了，就直接把它置为0，以后尽管所有路径都经过$p$，它也不可能是关键城市。



   因此$\mathrm{bitset}$中$\mathrm{im[i][j][k]}$里面存的是，现有状态下，k是不是i到j最短路上的关键城市。当**更新（松弛）最短路**时，关键城市是两段最短路上的关键城市之**并集**；而更新**最短路计数**，也就是找到了一条新的最短路时，如上图，就要取**交集**，因为一个城市只有在两点间任何一条最短路上都存在，才能作为这两点间的关键城市。而交集并集在位运算中就是and(&)和or(|)，而点集有200，普通的位运算完成不了，就让bitset来做。



   在一开始初始化时，把两个连接在一起的点上的关键城市设为两个端点，在floyd“松弛”最短路时，直接把两段最短路的关键城市“拼起来”，就是新的最短路上的关键城市。最后判断用$O(N^3)$遍历，看一个点是否为某两个点之间的关键城市，不过要注意不能与这两个点重合，因为为了方便，一开始我们把起点和终点也定为关键城市（符合关键城市的一般定义）。



   因此这道题的总复杂度为$$O(\frac{N^4}{32}+N^3)$$



## Code：

```cpp
#include<cstdio>
#include<cstring>
#include<bitset>
using std::bitset;
bitset<210> im[210][210];
int f[210][210];
int is[210];
int main()
{
    memset(f,0x3f,sizeof(f));
    int u,v,n,m;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
        f[i][i]=0;
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&u,&v);
        scanf("%d",&f[u][v]);
        f[v][u]=f[u][v];
    }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
        {
            im[i][j][i]=1;//初始化设两端为重要城市
            im[i][j][j]=1;
        }

    for(int k=1;k<=n;k++)
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                if(f[i][k]+f[k][j]==f[i][j])
                    im[i][j]&=(im[i][k]|im[k][j]);//当更新计数时取交集
                else if(f[i][k]+f[k][j]<f[i][j])//当更新最短路时直接赋值为两段的并集
                {
                    f[i][j]=f[i][k]+f[k][j];
                    im[i][j]=im[i][k]|im[k][j];
                }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            for(int k=1;k<=n;k++)
                if(k!=i&&k!=j)//注意特判
                    if(im[i][j][k])
                        is[k]=1;
    int flag=0;
    for(int i=1;i<=n;i++)
        if(is[i])
        {
            flag=1;
            printf("%d ",i);
        }
    if(!flag)//注意判断无解
        puts("No important cities.");
    return 0;
}
```

---

## 作者：tommymio (赞：8)

无意间写到这题，写完后发现楼上各位dalao的方法时间复杂度都不够优，所以本蒟蒻写了这篇题解。

思路很简单：floyed算法每次枚举一个中间点$x$进行松弛，然后对这个中间点进行判断，如果通过这个中间点能够松弛，说明当前$i$->$j$的路径上，$x$是一个重要的城市。可还有一种情况，如果$dis[i][j]$==$dis[i][x]$+$dis[x][j]$，说明至少有两个点能够达到当前的最优解，那么就$i$->$j$的路径上而言，在没有进行下一轮松弛之前，不存在重要的城市。这样就可以在O($n^3$)的时间复杂度内求解。

具体代码实现见代码，其实也很简单的。

```cpp
#include<cstdio>
#include<cstring>
#define min(a,b) ((a)<(b)? (a):(b))
bool b[205];
int ans[205][205],dis[205][205];//ans用于存储i->j路径上重要的城市
inline int read() {
	register int x=0,f=1;register char s=getchar();
	while(s>'9'||s<'0') {if(s=='-') f=-1;s=getchar();}
	while(s>='0'&&s<='9') {x=x*10+s-'0';s=getchar();}
	return x*f;
}
int main() {
	bool flag=0;
	int n=read(),m=read();
	memset(dis,0x3f,sizeof(dis));
	for(int i=1;i<=m;++i) {
		int x=read(),y=read(),z=read();
		dis[x][y]=dis[y][x]=min(dis[y][x],z);
	}
	for(int x=1;x<=n;++x) {
		for(int i=1;i<=n;++i) {
			for(int j=1;j<=n;++j) {
				if(i==j) continue; 
				if(dis[i][j]>dis[i][x]+dis[x][j]) ans[i][j]=x,dis[i][j]=dis[i][x]+dis[x][j];
				else if(dis[i][j]==dis[i][x]+dis[x][j]) ans[i][j]=-1;//当前不存在重要的城市
			}
		}
	}
	for(int i=1;i<=n;++i) {
		for(int j=1;j<=n;++j) {//扫描并记录
			if(i==j||dis[i][j]==0x3f3f3f3f) continue;
			if(ans[i][j]!=-1) b[ans[i][j]]=1;
		}
	}
	for(int i=1;i<=n;++i) {if(b[i]) printf("%d ",i),flag=1;}
	if(!flag) {printf("No important cities.");}
	return 0;
}
```


---

## 作者：lsfer (赞：7)

### 重要的城市


#### 题目大意

给定一张 $n$ 个点(重要城市) $m$ 条边的无向图，输出图中所有的重要城市。定义重要城市为：如果一个城市 $c$ 被破坏后，存在两个不同的城市 $a$ 和 $b$（$a$, $b$均不等于$c$），$a$到$b$的最短距离增长了（或不通），则城市$c$是重要的。

$n\le 200,m\le \frac{n*n(n-1)}{2},0<c\le 10000$，$c$即路的长度。

#### 分析

本题 $\textrm{Floyd}$题解很多，但大都缺少一个合理的证明。这里，我主要说一下这样做为什么是对的。

可以证明，对于任意一个重要城市$x$，那么一定存在一个点对$(u,v)$：

* $u$与$x$有边，$v$与$x$有边，且$u->x->v$为$u$和$v$唯一的最短路；

同时，我们还可以证明到：

* 若我们把$(u,x,v)$作为最短路的基本单位，任意长度的唯一最短路都可以由该三元组拼接而成。

所以，我们就可以在找最短路的时候，记录一下两个点的最短路是由哪一个点更新而来的，同时，如果有多个$k$更新到$(u,v)$的最短路，我们就当做$(u,v)$有多条最短路。

由于$(u,x,v)$的三元组关系，所以$(u,v)$ 的最短路只会由$x$更新到，所以，我们可以保证答案不重不漏。

PS：如果有误，欢迎指出


```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 205, M = 80005;
int n, m, imp[N][N], dist[N][N], ans[N];

template<typename T_>inline void read(T_ &s){
	s = 0 ; int f = 1 ; char ch ;
	do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');
	do{s=s*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');
	s *= f ;
}

void Floyd(){
	for(int k = 1; k <= n; ++k)
		for(int i = 1; i <= n; ++i)
			for(int j = 1; j <= n; ++j)
			if(i != k && j != k && i != j){
				if(dist[i][j] > dist[i][k] + dist[k][j]){
					dist[i][j] = dist[i][k] + dist[k][j] ;
					imp[i][j] = k ;
				}
				else if(dist[i][j] == dist[i][k] + dist[k][j])
					imp[i][j] = -1 ;
			}
				
}

int main(){
	 read(n) , read(m);
	 memset(dist , 0x3f , sizeof(dist)) ;
	 for(int i = 1; i <= n; ++i) dist[i][i] = 0;
	 for(int i = 1; i <= m; ++i){
	 	int u , v , w ;
	 	read(u) , read(v) , read(w) ; 
	 	dist[u][v] = min(dist[u][v], w);
	 	dist[v][u] = dist[u][v];
	 }
	 Floyd();
	 for(int i = 1; i <= n; ++i)
	 	for(int j = 1; j <= n; ++j)
	 		if(imp[i][j] != -1) ans[imp[i][j]] = 1;
	int Flag = 0;
	for(int i = 1; i <= n; ++i)
		if(ans[i]) printf("%d " , i) , Flag = 1;
	if(!Flag) printf("No important cities.");
	return 0 ;
}
/*
4 3
1 2 1
2 3 1
3 4 1
*/
```

---

## 作者：Grussg (赞：6)

# Part One 前置


## 1.1 杂谈

很水一道题，实现很简单（~~除了Floyd好像和DP沾不上边，我是后来才发现的...~~）。

不过觉得思路很新颖，分享一下。

## 1.2 简化题意


给你一张图，N个点，M条边。

我们定义一个概念，重要的点：对于一个点，删掉这个点，如果有任意两个点（除了这个点）的最短路径变长了，这个点即被称为重要的点。

按照顺序输出重要的点的编号

数据范围：

$ N \leq 200\;\; M \leq N(N-1)/2 $

# Part Two 解题

## 2.1 暴力

首先思考如何暴力

很简单，我们先把原来的图跑一遍$Floyd$ ($ Spfa,DJ$显然不必要) 

然后对于每删掉一个点，我们把和它相连的点赋成INF。

再跑$Floyd$ ，再一个个对比。 时间复杂的$O(N^4)$。

显然过不去。

## 2.2 正解

暴力一遍遍$Floyd$显然不可取

我们思考其性质

对于一个点$k$，若它是重要的城市，那么必有至少一对点$i,j$的所有最短路$dis(i,j)$ 上有$k$。对于$i,j$的所有最短路$dis(i,j)$，如果点$k$在其最短路上出现的次数$=$最短路条数，即其为重要的点。

但是这样实现很麻烦。我们不仅需要$i,j$之间最短路的条数，还要他们之间最短路所经过的点

转换角度，我们思考两个点。

1.如果有一中转点$k$，使得$dis(i,j)>dis(i,k)+dis(k,j)$ 那么最短路必须经过点$k$。

2.如果有一中转点$k$，使得$dis(i,j)=dis(i,k)+dis(k,j)$ ，那么$i,j$之间不仅有一条最短路。这个时候我们之前找到点都不会走了。

那么问题就迎刃而解了

我们跑一遍$Floyd$

$if(dis(i,j)>dis(i,k)+dis(k,j)$ 记录 $p(i.j)=k$。

$if(dis(i,j)==dis(i,k)+dis(k,j)$ 记录 $p(i.j)=-1$。

最后处理答案，我们需要去重和按顺序输出。看数据范围直接开一个桶。双重循环记录$p(i.j)$，如果它不为$-1$，$ans[p(i.j)]=true$。

最后循环桶输出就好了。

## 2.3 代码

```
#include<bits/stdc++.h>
using namespace std;
template <class T> inline void read(T&x){
	bool f;char ch=getchar();
	for(f=false;!isdigit(ch);ch=getchar())if(ch=='-')f=true;
	for(x=0;isdigit(ch);x=(x<<1)+(x<<3)+(ch^48),ch=getchar());
	x*=f==1?-1:1;
}
const int INF=2e6;
int mpx[205][205],impo[205][205],m,n;
bool ans[205],flag;
int main(){
    read(n),read(m);    
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            if(i!=j) mpx[i][j]=INF;
    for(int i=1,x,y,u;i<=m;i++){
    	read(x),read(y),read(u);
        mpx[x][y]=mpx[y][x]=u;
    }
    for(int k=1;k<=n;k++)
        for(int i=1;i<=n;i++)
            if(i!=k)for(int j=1;j<=n;j++)
                if(i!=j&&j!=k){
                    if(mpx[i][j]>mpx[i][k]+mpx[k][j]){
                    	mpx[i][j]=mpx[i][k]+mpx[k][j];impo[i][j]=k;
                        }
                    else if(mpx[i][j]==mpx[i][k]+mpx[k][j]) impo[i][j]=-1;
                }
    for(int i=1;i<=n;i++) 
        for(int j=1;j<=n;j++)
            if(impo[i][j]!=-1)ans[impo[i][j]]=true;    
    for(int i=1;i<=n;i++)if(ans[i]) printf("%d ",i),flag=true;
    if(!flag)cout<<"No important cities.";
    return 0;
}
```


# Part Three 写在最后

## 3.1 鸣谢&杂谈

感谢 @ $Parabola$ （UID:55537）的题解在我学习中的帮助

~~思路也还是他的~~

$CSP\; RP\; PLUS\; PLUS$

## 3.2 更新记录

$Vol \; \;1$ $2019/11/3$ 首次提交

---

## 作者：1LoveNozomi (赞：4)

重要城市有三个性质如下：

1.重要城市能对其他两个不同城市的最短路径做出贡献

2.重要城市具有唯一性，如果两不同城市之间的最短路径有两种中间城市情况，那么这两个中间城市可以彼此代替，就都不能成为重要城市

3.重要城市具有替代性，对于两不同城市间的一种最短路径情况，该路径上所有中间城市皆为重要城市；如果出现了一种更优最短路径情况，先前路径上所有中间城市皆非重要城市，更优解者是。

这道题也容易知道是使用弗洛伊德算法。但不是动态规划过程中能够更新路径的城市就是最终解的重要城市，需要从全局的角度来判断，过程中不断记录和更新重要城市。代码如下：

    
    
                    
```cpp
    #include<iostream>
    #include<cstdio>
    #include<cstdlib>
    #include<cmath>
    #include<cstring>
    #include<string>
    #include<iomanip>
    #include<queue>
    #include<set>
    using namespace std;
    int important[250][250];//记录对于一条路径的重要城市 
    bool have[250][250];//一条路径是否有重要城市 
    int g[250][250];//邻接矩阵 
    int n,m;//n个点 m条边 
    set<int> ans; 
    void floyd()
    {
        for(int i=1;i<=n;i++)
            g[i][i] = 0;
        for(int k=1;k<=n;k++)
            for(int i=1;i<=n;i++)
                if(k!=i)
                    for(int j=1;j<=n;j++)
                        if(k!=j && i!=j)
                        {
                            if(g[i][j] > g[i][k]+g[k][j])//性质1：对最短路做出贡献 
                            {
                                have[i][j] = true;
                                important[i][j] = k;//性质3：替代性
                                g[i][j] = g[i][k]+g[k][j];
                            }
                            else if(g[i][j] == g[i][k]+g[k][j])//性质2:唯一性 
                                have[i][j] = false;
                        }
        return;
    }
    void init()
    {
        scanf("%d%d",&n,&m);
        int a,b,v;
        for(int i=1;i<=m;i++)
        {
            scanf("%d%d%d",&a,&b,&v);
            g[a][b] = g[b][a] = v;
        }
        return;
    }
    void print()
    {
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                if(have[i][j] == true)
                    ans.insert(important[i][j]);
        if(!ans.empty())//有重要城市 
            for(set<int>::iterator i=ans.begin();i != ans.end();i++)
                printf("%d ",*i);
        else
            printf("No important cities.");
    }
    int main()
    {
        memset(g,1,sizeof(g));//g中元素值初始化为16843009
        memset(have,false,sizeof(have));//保存两城市i、j间是否有重要城市 
        memset(important,0,sizeof(important));//保存两城市i、j间的一个重要城市 
        ans.clear();//红黑树，自动排序、去重 
        init();
        floyd();
        print();
        return 0;
    }
重要城市并非只保存一个：因为最短路径上的子路径也为最短路径，所以母路径保存了最短路径中终点的前一个作为重要城市，以前一个城市为终点的子路径又会保存前一个城市作为重要城市………这样就可以把一条路径上的所有重要城市保存下来了。
```

---

## 作者：mrsrz (赞：4)

跑Floyd，并记录两点间的一个重要的城市。


如果两个点的距离更新，则重要的城市也更新。


如果两个点的距离在计算时出现与原来结果相等时，就说明可能出现多条最短路，这时删掉重要的城市。


最后枚举两个点，把它们之间的重要的城市去重后记录下来，排序输出即可。


由于在Floyd中，对于每个中点，其他点对都进行过考虑，因此答案是不会出现遗漏的。


时间复杂度$O(n^3)$。


C++ Code：

```cpp
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>
int n,m,d[202][202],s[202][202],ans[202];
bool has[202];
inline int readint(){
    char c=getchar();
    for(;!isdigit(c);c=getchar());
    int d=0;
    for(;isdigit(c);c=getchar())
    d=(d<<3)+(d<<1)+(c^'0');
    return d;
}
int main(){
    n=readint(),m=readint();
    memset(d,0x3f,sizeof d);
    while(m--){
        int x=readint(),y=readint(),z=readint();
        d[x][y]=d[y][x]=z;
    }
    for(int k=1;k<=n;++k)
    for(int i=1;i<=n;++i)
    if(i!=k)
    for(int j=1;j<=n;++j)
    if(i!=j&&j!=k){
        if(d[i][j]>d[i][k]+d[k][j]){
            d[i][j]=d[i][k]+d[k][j];
            s[i][j]=k;
        }else
        if(d[i][j]==d[i][k]+d[k][j])s[i][j]=-1;
    }
    int cnt=0;
    memset(has,0,sizeof has);
    for(int i=1;i<=n;++i)
    for(int j=1;j<=n;++j)
    if(s[i][j]>0&&!has[s[i][j]]){
        has[s[i][j]]=true;
        ans[++cnt]=s[i][j];
    }
    if(cnt==0)return puts("No important cities."),0;
    std::sort(ans+1,ans+cnt+1);
    for(int i=1;i<cnt;++i)printf("%d ",ans[i]);
    printf("%d\n",ans[cnt]);
    return 0;
}
```

---

## 作者：ChenHacker (赞：2)

### [Welcome to my blog](http://ch66.cf/274.html)

## 暴力大法好

首先Floyd算出所有城市都没有问题的最短路存进dis

再枚举每一个出问题的城市，暴力判断即可

## 没有重要的城市记得输出"No important cities."！！！

```
#pragma GCC optimize(1)
#pragma GCC optimize(2)
#pragma GCC optimize(3,"Ofast","inline")
#include<bits/stdc++.h>
using namespace std;

int read() {
    int x=1,ans=0;
    char ch=getchar();
    while(ch<'0'||ch>'9') {
        if(ch=='-')
            x*=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9') {
        ans=ans*10+ch-48;
        ch=getchar();
    }
    return x*ans;
}

int edge[205][205],dis[205][205],n,m,temp[205][205];

int main() {
    n=read();m=read();
    memset(edge,0x3f,sizeof(edge));
    for(int i=1;i<=m;i++) {
        int u=read(),v=read(),val=read();
        edge[u][v]=edge[v][u]=val;
    }
    memcpy(dis,edge,sizeof(edge));
    for(int k=1;k<=n;k++)
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
    for(int wow=1;wow<=n;wow++) {
        memcpy(temp,edge,sizeof(temp));
        for(int k=1;k<=n;k++)
            for(int i=1;i<=n;i++)
                for(int j=1;j<=n;j++)
                    if(k!=wow)
                        temp[i][j]=min(temp[i][j],temp[i][k]+temp[k][j]);
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                if((i!=wow)&&(j!=wow)&&(temp[i][j]>dis[i][j])&&(i!=j)) {
                    printf("%d ",wow);
                    // cout<<i<<' '<<j<<' '<<temp[i][j]<<' '<<dis[i][j]<<endl;
                    i=n+1;j=n+1;
                }
    }
    return 0;
}
```

[复杂度n^4,可是简单的暴力只有80分](https://www.luogu.org/recordnew/show/17661749)

我们用一个三维数组ycl[k]表示先算出前k个城市作为中点所算到一般的最短路状态，枚举的时候zhijei调用即可

这样复杂度可以降到(n^4)/2

[勉强水过](https://www.luogu.org/recordnew/show/17662359)

```
#pragma GCC optimize(1)
#pragma GCC optimize(2)
#pragma GCC optimize(3,"Ofast","inline")
#include<bits/stdc++.h>
using namespace std;

int read() {
    int x=1,ans=0;
    char ch=getchar();
    while(ch<'0'||ch>'9') {
        if(ch=='-')
            x*=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9') {
        ans=ans*10+ch-48;
        ch=getchar();
    }
    return x*ans;
}

int edge[205][205],dis[205][205],n,m,temp[205][205],ycl[205][205][205];
bool ok=true;

int main() {
    n=read();m=read();
    memset(edge,0x3f,sizeof(edge));
    for(int i=1;i<=m;i++) {
        int u=read(),v=read(),val=read();
        edge[u][v]=edge[v][u]=val;
    }
    memcpy(dis,edge,sizeof(edge));
    for(int k=1;k<=n;k++)
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
    memcpy(ycl[0],edge,sizeof(edge));
    for(int k=1;k<=n;k++) { 
        memcpy(ycl[k],ycl[k-1],sizeof(ycl[k-1]));
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                ycl[k][i][j]=min(ycl[k][i][j],ycl[k][i][k]+ycl[k][k][j]);
    }
    for(int wow=1;wow<=n;wow++) {
        memcpy(temp,ycl[wow-1],sizeof(ycl[wow-1]));
        for(int k=wow+1;k<=n;k++)
            for(int i=1;i<=n;i++)
                for(int j=1;j<=n;j++)
                    if(k!=wow)
                        temp[i][j]=min(temp[i][j],temp[i][k]+temp[k][j]);
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                if((i!=wow)&&(j!=wow)&&(temp[i][j]>dis[i][j])&&(i!=j)) {
                    printf("%d ",wow);
                    ok=false;
                    i=n+1;j=n+1;
                }
    }
    if(ok) puts("No important cities.");
    return 0;
}
```






---

## 作者：CR_Raphael (赞：2)

先是朕的做法O(n^3)

具体思路是DIJSTRA求出每两个点间的最短路径长度(dis)和条数(cou)。

若存在三点i、k、j，使

```cpp
G.dis[i][k]+G.dis[k][j] == G.dis[i][j]
G.cou[i][k]*G.cou[k][j] == G.cou[i][j]
```

则k是重要城市。

这么暴力……居然能过……

（别走，后面还有）

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;

const int maxn = 205;
const int maxm = 40005;
int n, m;
int iss[maxn];

struct gra {
	int tm, st[maxn], to[maxm], nex[maxm], l[maxm];
	int dis[maxn][maxn], cou[maxn][maxn];
	bool v[maxn];
	priority_queue <pair<int, int> > qq;
	void adde(int a, int b, int c) {
		tm++;
		to[tm]=b;
		l[tm]=c;
		nex[tm]=st[a];
		st[a]=tm;
		return;
	}
	void dij(int x) {
		int y, i;
		memset(v, 0, sizeof(v));
		memset(dis[x], 0x3f, sizeof(dis[x]));
		memset(cou[x], 0x3f, sizeof(cou[x]));
		dis[x][x]=0;
		cou[x][x]=1;
		qq.push(make_pair(0, x));
		while(!qq.empty()) {
			y=qq.top().second;
			qq.pop();
			if(v[y] == 1) continue;
			v[y]=1;
			for(i=st[y]; i != 0; i=nex[i]) {
				if(dis[x][to[i]] == dis[x][y]+l[i]) {
					cou[x][to[i]] += cou[x][y];
				}
				else if(dis[x][to[i]] > dis[x][y]+l[i]) {
					cou[x][to[i]] = cou[x][y];
					dis[x][to[i]] = dis[x][y]+l[i];
					qq.push(make_pair(-dis[x][to[i]], to[i]));
				}
			}
		}
		return;
	}
} G;

int main() {
	int i, j, k, ta, tb, tc, ans;
	scanf("%d%d", &n, &m);
	for(i=1; i <= m; i++) {
		scanf("%d%d%d", &ta, &tb, &tc);
		G.adde(ta, tb, tc);
		G.adde(tb, ta, tc);
	}
	for(i=1; i <= n; i++) 
		G.dij(i);
	for(i=1; i <= n; i++) {
		for(j=1; j <= n; j++) {
			for(k=1; k <= n; k++) {
				if(i != k && j != k && i != j)
				if(G.dis[i][k]+G.dis[k][j] == G.dis[i][j] && 
				G.cou[i][k]*G.cou[k][j] == G.cou[i][j])
					iss[k]=1;
			}
		}
	}
	
	ans=0;
	for(i=1; i <= n; i++) {
		if(iss[i] == 1) ans++, printf("%d ", i);
	}
	if(ans != 0) printf("\n");
	else printf("No important cities.\n");
	return 0;
}

```

另附上Floyd版：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;

const int maxn = 205;
const int maxm = 40005;
int n, m;
int iss[maxn];

struct gra {
    int tm, st[maxn], to[maxm], nex[maxm], l[maxm];
    int dis[maxn][maxn], cou[maxn][maxn];
    void cle() {
        memset(dis, 0x3f, sizeof(dis));
        memset(cou, 0x3f, sizeof(cou));
	}
    void adde(int a, int b, int c) {
    	if(dis[a][b] == c) {
	    	cou[a][b]++;
		}
    	if(dis[a][b] > c) {
	    	dis[a][b]=c;
	    	cou[a][b]=1;
		}
        return;
    }
    void flo() {
        int i, j, k;
		for(k=1; k <= n; k++) {
			for(i=1; i <= n; i++) {
				for(j=1; j <= n; j++) {
                	if(i != k && j != k && i != j) {
	                	if(dis[i][k]+dis[k][j] == dis[i][j]) {
	                		cou[i][j]+=cou[i][k]*cou[k][j];
						}
	                	if(dis[i][k]+dis[k][j] < dis[i][j]) {
	                		dis[i][j]=dis[i][k]+dis[k][j];
	                		cou[i][j]=cou[i][k]*cou[k][j];
						}
					}
				}
			}
		}
        return;
    }
} G;

int main() {
    int i, j, k, ta, tb, tc, ans;
    scanf("%d%d", &n, &m);
    G.cle();
    for(i=1; i <= m; i++) {
        scanf("%d%d%d", &ta, &tb, &tc);
        G.adde(ta, tb, tc);
        G.adde(tb, ta, tc);
    }
    G.flo();
    for(i=1; i <= n; i++) {
        for(j=1; j <= n; j++) {
            for(k=1; k <= n; k++) {
                if(i != k && j != k && i != j)
                if(G.dis[i][k]+G.dis[k][j] == G.dis[i][j] && 
                G.cou[i][k]*G.cou[k][j] == G.cou[i][j])
                    iss[k]=1;
            }
        }
    }
    
    ans=0;
    for(i=1; i <= n; i++) {
        if(iss[i] == 1) ans++, printf("%d ", i);
    }
    if(ans != 0) printf("\n");
    else printf("No important cities.\n");
    return 0;
}
```

————————————画风分割线——————————————

顺便提供一下本题@nozomi_tojo 神犇的方法中最后一句话的严格证明：

本题即求一个点（重要城市）在某两点间的所有最短路径上出现

考虑弱化问题，

【引理1】：若有A到B最短路径上的子路径，则该子路径就是子路径两端两点C、D间的最短路径。且所有C、D的最短路径都是A到B某条最短路径上的子路径。

由此在微观对较长路径缩小得到，

【推论1】：对于任意一个重要城市A，必然存在两点B、C，使B到C的最短路径为B→A→C。

- 证明：取两点S、E间过A的一条经过的点最多的最短路径。

- 设其为S→···→P→A→Q→···→E。

- 若P、Q间存在最短路经过4个点，P→K→A→Q，则可以替换原来的子路径P→A→Q，则原路径不满足“过A的一条经过的点最多的最短路径”。

- 若P、Q间存在最短路P→K→Q，则A不是重要城市，矛盾。

- 得证。

故其方法必然不会漏去重要城市。

---

## 作者：DD_Bruyne (赞：1)

# 50分
 足了
 思路大家大概和我是一样的
 就是先跑一遍Floyed
 算出所有节点到每一个节点的最小值，也就是建一个二维表，用一个Floyed就可以实现
 然后就去掉每一个点，重新跑n遍Floyed，来比较有没有变化
 本人也是轻松的写了出来，过了样例，兴致勃勃的提交，却只有50分
 代码如下：


------------

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll dp[210][210],ff[210][210],f[210][210],n,m,u[210];//dp是最开始存的表，ff是删除一个数之后跑的表，每次都要更新，f则是记录最开始什么都没有动的表
int main()
{
    memset(dp,0x3f,sizeof(dp));//将所用数组都memset,才可以再后来Floyed时更好比对，更新数据
    memset(f,0x3f,sizeof(f));
    memset(ff,0x3f,sizeof(ff));
    ll i,j,k,x,y,v;
    scanf("%lld%lld",&n,&m);
    for(i=1;i<=m;i++)
    {
        scanf("%lld%lld%lld",&x,&y,&v);
        ff[x][y]=ff[y][x]=f[x][y]=f[y][x]=dp[y][x]=dp[x][y]=v;//输入是将三个数组都定义成一样的，一遍后来Floyed
    }
    for(i=1;i<=n;i++)
    {
        for(j=1;j<=n;j++)
        {
            if(ff[i][j]==0)ff[i][j]=ff[j][i]=-1;
            if(f[i][j]==0)f[i][j]=f[j][i]=-1;
            if(dp[i][j]==0)dp[i][j]=dp[j][i]=-1;//将没有路的标记成-1
        }
    }
    for(i=1;i<=n;i++)
    {
        dp[i][i]=0;
        ff[i][i]=f[i][i]=0;
  //把所有到自身的节点的路径都设为0
    }
    for(k=1;k<=n;k++)
    {
        for(i=1;i<=n;i++)
        {
            for(j=1;j<=n;j++)
            {
                if(dp[i][j]!=-1&&dp[k][i]!=-1&&dp[i][k]!=-1&&dp[k][j]!=-1&&dp[j][k]!=-1&&dp[j][i]!=-1)//判断有没有路径，有才算
                dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);
            }
        }
    }//第一次建dp表,来存最短路
    for(ll l=1;l<=n;l++)//枚举去掉那一个点
    {
        for(i=1;i<=n;i++)
        {
            ff[i][l]=ff[l][i]=-1;
        }
        //把到自己的点的所有路径都删除
        for(k=1;k<=n;k++)
        {
            if(k!=l)
            for(i=1;i<=n;i++)
            {
                if(i!=l)
                for(j=1;j<=n;j++)
                {
                    if(j!=l)
                    if(ff[i][j]!=-1&&ff[k][i]!=-1&&ff[i][k]!=-1&&ff[k][j]!=-1&&ff[j][k]!=-1&&ff[j][i]!=-1)
                    ff[i][j]=min(ff[i][j],ff[i][k]+ff[k][j]);
                }
            }
        }//Floyed
        for(i=1;i<=n;i++)
        {
            for(j=1;j<=n;j++)
            {
                if(ff[i][j]>dp[i][j]||ff[j][i]>dp[j][i]&&i!=l&&j!=l)
                {
                    u[l]=1;
                    break;
                }
            }//如果有一个点改变且不是到去掉的那个点，将这个点标记为重要
        }
        for(i=1;i<=n;i++)
        {
            for(j=1;j<=n;j++)
            {
                ff[i][j]=f[i][j];
            }
        }//更新
    }
    for(i=1;i<=n;i++)
    {
        if(u[i])
        {
            printf("%lld ",i);
        }
    }//按字典序输出
    return 0;
}
```


------------
 提交之后我自己就在想有没有不超时的办法（~~因为我T了五个点~~）
 后来突然反应过来只要有过更改，也就是do时发现比原路径小的点，都是关键点
 但是如果这个点更新，那么上一个确定了的关键点就得取消
 所以得记录在这条路径上上一个改变的点，我就用了past[i][j]存
 还有一个十分关键的地方
 就是如果发现了一条道路有多条相等的路径，一条也不要
 代码如下


------------
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll dp[210][210],n,m,u[210],past[210][210];//dp存最短路，u最后输出，past记录这条边上的上一个改变点
int main()
{
	memset(dp,0x3f,sizeof(dp));//仍然先取最大值
	ll i,j,k,x,y,v;
	scanf("%lld%lld",&n,&m);
	for(i=1;i<=m;i++)
	{
		scanf("%lld%lld%lld",&x,&y,&v);
		dp[y][x]=dp[x][y]=v;//存输入边
	}
	for(i=1;i<=n;i++)
	{
		dp[i][i]=0;//将自己到自己的长度设为0
	}
	for(k=1;k<=n;k++)
	{
		for(i=1;i<=n;i++)
		{
			if(i!=k)
			for(j=1;j<=n;j++)
			{
				if(i==j||k==j)continue;		
				if(dp[i][j]>dp[i][k]+dp[k][j])
				{
					dp[i][j]=dp[i][k]+dp[k][j];
					past[i][j]=k;
  					//将这条路的当前改变点设为现在改变的这个点
				}
				else if(dp[i][j]==dp[i][k]+dp[k][j])
				{
  					//如果出现多个相同边，将这一条边上的关键点清零
					past[i][j]=-1;
					continue;
				}
			}
		}
	}
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=n;j++)
		{
			if(past[i][j]==-1)continue;//如果被清零，不输出且不为关键点
			u[past[i][j]]=1;//将要输出的关键点标记
		}
	}
	for(i=1;i<=n;i++)
	{
		if(u[i])
		{
			printf("%lld ",i);
		}
	}
	return 0;
}
```
### 一百分了！！！好激动
更希望大家支持我也让我得到了学习和复习的机会
 谢谢

---

## 作者：人殇物已非 (赞：1)

### 神似[NOI2007]社交网络

~~**简直本来就是一道题**~~

然后，并不需要什么$O(n^4)$或者$O(n^3logn)$的玄学操作，裸一点跑个$Floyd$ $O(n^3)$就可以过了，$n<=200$裸过，并且，如果你闲的慌，你甚至可以优化到$O(n^2logn)$。

我们开两个二维数组$dis[i][j]$ 和 $edge[i][j]$，$dis[i][j]$保存从$i$到$j$的最短路长度，$edge[i][j]$保存从$i$到$j$的最短路有几条。

那么答案就呼之欲出了。只要我们维护出这两个东西，然后去枚举一下中转点$p$，一旦$dis[i][p]+dis[p][j]==dis[i][j]$就说明通过$p$存在$(i,j)$的最短路，一旦$edge[i][p]*edge[p][j]==edge[i][j]$，就说明$(i,j)$的最短路全部需要通过$p$点，那么$p$就是重要的点。

然后，显然对于不同的$(i,j)$可能都把$p$作为了重要的点，所以输出的时候需要判断$p$是不是已经输出过了，拿个$vis[i]$记一下就好了，避免多次输出同一个$p$。

### $code:$

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
long long dis[300][300];
long long edge[300][300];
bool vis[300];
inline void add(int u,int v,int w){
	if(w<dis[u][v]){
		dis[u][v]=w,edge[u][v]=1;
	}
	else if(w==dis[u][v]){
		edge[u][v]++;
	}
}
int main(){
	memset(dis,0x3f,sizeof(dis));
	cin>>n>>m;
	for(int i=1,u,v,w;i<=m;i++){
		scanf("%d %d %d",&u,&v,&w);
		add(u,v,w),add(v,u,w);
	}
	for(int k=1;k<=n;k++){
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				if(i==j || i==k || k==j) continue;
				if(dis[i][k]+dis[k][j]<dis[i][j]){
					dis[i][j]=dis[i][k]+dis[k][j];
					edge[i][j]=edge[i][k]*edge[k][j];
				}
				else if(dis[i][k]+dis[k][j]==dis[i][j]){
					edge[i][j]+=edge[i][k]*edge[k][j];
				}
			}
		}
	}
	int fl=0;
	for(int p=1;p<=n;p++){
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				if(i==j || i==p || p==j) continue;
				if(vis[p]) continue;
				if(dis[i][p]+dis[p][j]==dis[i][j]){
					if(edge[i][p]*edge[p][j]==edge[i][j]){
						cout<<p<<" ";vis[p]=1;fl=1;
					}
				} 
			}	
		}
	}
	if(!fl){
		printf("No important cities.");
	}
	return 0;
} 
```

---

## 作者：温词 (赞：1)

#### 这道题的主体思路我认为是记录下每两个点之间最短路的条数，然后如果只有一条的话枚举出这路上的所有点（这就是题目中要求的重要城市）。然后这道题n<=200的数据范围让我先写了一遍floyd
### 但请仔细思考，floyd貌似没有办法记录最短路条数......（然而我这个错误的代码居然骗了70.....~~数据好水啊~~）请看70分代码
```
#include<bits/stdc++.h>//这个代码我就不进行解释了，反正是错的
using namespace std;
int cnt[310][310],n,m,dis[310][310];
bool vis[310],flag,debug;
inline void floyd(){
    int i,j,k;
    for(k=1;k<=n;k++){
        for(i=1;i<=n;i++){
            for(j=1;j<=n;j++){
            	if(i==k||i==j||j==k) continue;
                if(dis[i][j]==dis[i][k]+dis[k][j]){
                    cnt[i][j]++;
                }
                if(dis[i][j]>dis[i][k]+dis[k][j]){
                    dis[i][j]=dis[i][k]+dis[k][j];
                    cnt[i][j]=1;
                }
            }
        }
    }
}
inline void check(){
    int i,j,k;
    for(i=1;i<=n;i++){
        for(j=1;j<=n;j++){
            for(k=1;k<=n;k++){
                if(i==k||i==j||j==k) continue;
                if(dis[i][j]==dis[i][k]+dis[k][j]&&cnt[i][j]==1){
                    vis[k]=true;
                }
            }
        }
    }
}
int main(){
    int i,j,k;
    cin>>n>>m;
    memset(dis,0x3f,sizeof(dis));
    for(i=1;i<=n;i++){
        dis[i][i]=0;
    }
    for(i=1;i<=m;i++){
        int x,y,z;
        cin>>x>>y>>z;
        dis[x][y]=z;
        dis[y][x]=z;
    }
    floyd();
    check();
    for(i=1;i<=n;i++){
        if(vis[i]){
        printf("%d ",i);
        flag=true;
        }
    }
    if(!flag){
        cout<<"No important cities."<<endl;
    }
    //debug=true;
    if(debug){
        for(i=1;i<=n;i++){
            for(j=1;j<=n;j++){
                //cout<<i<<" "<<j<<" "<<dis[i][j]<<endl;
                if(cnt[i][j]>1) cout<<i<<" "<<j<<endl;
            } 
        }
    }
    return 0;
}```

#### 再大概明白这个题的思路后.....既然floyd没办法计数，那么dij可以啊既然如此，就有了以下这段代码
```#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int w=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		w=(w<<3)+(w<<1)+ch-48;
		ch=getchar();
	}
	return w*f;
}//快读就不多说了
int head[1000010],dis[310][310],n,m,cntt,cnt[310][310];
bool flag,debug,vis[310];
struct Edge{
	int from,to,next,dis;
}edge[1000010];
inline void addedge(int u,int v,int w){
	cntt++;
	edge[cntt].from=u;
	edge[cntt].to=v;
	edge[cntt].dis=w;
	edge[cntt].next=head[u];
	head[u]=cntt;
}
struct node{
	int num,dis;
	friend bool operator < (node a,node b){
		return a.dis>b.dis;
	}
};
priority_queue<node> q;//到这都是常规操作
inline void dij(int s){//既然是单源最短路，那么我就用一维数组来记录起点
	int i,j,k,u,v,w;
	dis[s][s]=0;
	q.push((node){s,0});
	cnt[s][s]=1;
	while(!q.empty()){
		node front=q.top();
		q.pop();
		u=front.num;
		if(dis[s][u]>front.dis) continue;
		for(i=head[u];i;i=edge[i].next){
			v=edge[i].to;
			w=edge[i].dis;
			if(dis[s][v]==dis[s][u]+w){
				cnt[s][v]+=cnt[s][u];
			}
			if(dis[s][v]>dis[s][u]+w){
				cnt[s][v]=cnt[s][u];
				dis[s][v]=dis[s][u]+w;
				q.push((node){v,dis[s][v]});
			}
		}
	}//这里面的所有操作都和普通的单源最短路一样，只不过加了一维记录起点
}
inline void check(){
	int i,j,k;
	for(k=1;k<=n;k++){
		for(i=1;i<=n;i++){
			for(j=1;j<=n;j++){
				if(i==j||i==k||k==j) continue;
				if(dis[i][j]==dis[i][k]+dis[k][j]&&cnt[i][j]==1){
					vis[k]=true;//若该点在最短路上且最短路只有一条，此点就是重要点（这个可以自行手推一下，蛮容易想到的）
				}
			}
		}
	}
}
int main(){
	n=read();
	m=read();
	memset(dis,0x3f,sizeof(dis));
	int i,j,k;
	for(i=1;i<=m;i++){
		int x,y,z;
		x=read();
		y=read();
		z=read();
		addedge(x,y,z);
		addedge(y,x,z);
	}
	for(i=1;i<=n;i++){
		dij(i);
	}
	//debug=true;
	if(debug){
		for(i=1;i<=n;i++){
			for(j=1;j<=n;j++){
				cout<<i<<" "<<j<<" "<<cnt[i][j]<<endl;
			}
		}
	}//这个就是中间测试用的
	check();
	for(i=1;i<=n;i++){
		if(vis[i]){
			cout<<i<<" ";
			flag=true;//打个tag记录是否有点是重要城市
		}
	}
	if(!flag) cout<<"No important cities."<<endl;
	return 0;
}
```
### emm这道题大概就是这样了，希望大家都能理解我的做法吧！


---

## 作者：zzzyc (赞：1)

对于这个题，简单的用Ford，然后枚举1~n，把城市炸掉。。。。。

特别提示：注意memset和for的运用。。。。。。。尽量用for。。。。

```cpp
#include<iostream>
#include<cstring>
#include <algorithm>
using namespace std;
int main()
{
    int n,m,x,y,z,a[201][201],c[201][201]={0};
    bool b[201][201],ans[201]={0};
    cin>>n>>m;
    for(int i=1;i<=n;i++)
     for(int j=1;j<=n;j++)
     if(i!=j)
     a[i][j]=0x7ffffff;
    for(int i=1;i<=m;i++)
    {
        cin>>x>>y>>z;
        a[x][y]=z;
        a[y][x]=z;
    }
    memset(b,0,sizeof(b));
    for(int k=1;k<=n;++k)
    {
        for(int i=1;i<=n;++i) if(k!=i)
        {
            for(int j=1;j<=n;++j) if(k!=j && i!=j)
            {
                if(a[i][j]>a[i][k]+a[k][j])
                {
                    a[i][j]=a[i][k]+a[k][j];
                    b[i][j]=0;
                    c[i][j]=k;
                }else if(a[i][j]==a[i][k]+a[k][j]) b[i][j]=1;
            } 
        }
    }
    memset(ans,0,sizeof(ans));
    int q[201]={0};
    int tot=0;
    for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=n;j++)
            {
                if(i!=j && b[i][j]==0 && c[i][j]>0 && ans[c[i][j]]==0)
                {
                    ans[c[i][j]]=1;
                    q[++tot]=c[i][j];
                }
            }
        }
    sort(q+1,q+tot+1);
    for(int i=1;i<=tot;++i) cout<<q[i]<<" ";
    if(tot==0) cout<<"No important cities.";
    return 0;
}
```

---

## 作者：功在不舍 (赞：0)

这个题要我们求n个点中有哪些是重要的点。

~~直接把每个点都单独跑一遍floyd~~

这样肯定不行O(n^4)过不了200

考虑能不能在O(n^3)里解出来

这里思路和最短路计数那个题有点像，记num[i][j]为i，j间最短路条数

由于floyd本质是个动态规划，我们可以在求dis的时候把num也求出来

dis[i][j]>dis[i][k]+dis[k][j]的时候，i，j之间的最短路被更新了，num的值则改为i，k之间的最短路条数*k，j之间的最短路条数（乘法原理）

dis[i][j]==dis[i][k]+dis[k][j]的时候，i，j之间最短路保留，把num的值加上i，k之间的最短路条数*k，j之间的最短路条数即可（加法原理）

好了num求出来了怎么判断一个点是不是重要的点呢？

我们枚举i，j，如果存在一组i，j之间所有的最短路都经过k，那k点就是个重要的点了

接下来是代码环节：


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int ok,n,m,x,y,z,dis[201][201],num[201][201],inf=99999999;
int check(int k)
{
	for(int i=1;i<=n;i++)
	   for(int j=1;j<=n;j++)
	       if(dis[i][j]==dis[i][k]+dis[k][j])
	           if(num[i][j]==num[i][k]*num[k][j])
	               return 1;
	return 0;
}
int main()
{
	scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            dis[i][j]=inf,num[i][j]=0;
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		dis[x][y]=dis[y][x]=z;
	    num[x][y]=num[y][x]=1;
    }
	for(int k=1;k<=n;k++)
	   for(int i=1;i<=n;i++)
	       for(int j=1;j<=n;j++)
	           if(dis[i][j]>dis[i][k]+dis[k][j])
               {
               	   dis[i][j]=dis[i][k]+dis[k][j];
	               num[i][j]=num[i][k]*num[k][j];
               }
               else if(dis[i][j]==dis[i][k]+dis[k][j])
                   num[i][j]+=num[i][k]*num[k][j];
    for(int i=1;i<=n;i++)dis[i][i]=inf,num[i][i]=0;//一个小坑
	for(int k=1;k<=n;k++)
	    if(check(k))printf("%d ",k),ok=1;
	if(ok==0)printf("No important cities.");
	return 0;
}
```
~~80分的记得把dis[i][i]=inf,num[i][i]=0;自己不能走到自己！~~


---

## 作者：南方小包 (赞：0)

### 提供一个最短路计数的方法

首先这题很容易就能想到是$Floyd$

之后就是枚举点对$(i,j),$ 再枚举一个中间断点$k$

$(k\not=i)$且$(k\not=j)($这个条件很重要$)$ 

然后就是要判断$k$在不在$i$到$j$的最短路径上

说的更准确一些$,k$是不是一定在$i$到$j$的最短路径上

然后我们记$cnt[i][j]$表示$i$到$j$的最短路的条数

所以说如果$cnt[i][j] = 0$或$cnt[i][j] \geq 2$

那么其实就没有中间节点$k$是重要城市

否则的话任何的$k$

使得$dis[i][j] = dis[i][k] + dis[k][j]$都是重要城市

那么代码如下$,$时间复杂度是$O(n^3)$

```
#include<bits/stdc++.h>
#define LL long long
#define SIZE 205
#define MAX 1LL<<60
#define gc getchar()
using namespace std;
bool ans[SIZE], flag = false;
LL n, m, dis[SIZE][SIZE], cnt[SIZE][SIZE];
inline void up(LL &x, LL y){x = min(x, y);}
inline void read(LL &x)
{
	char ch; LL f = 1; x = 0;
	for(ch = gc; !isdigit(ch); ch = gc)
		if(ch == '-') f = -1;
	for(; isdigit(ch); ch = gc)
		x = (x << 1) + (x << 3) + ch - '0';
	if(f == -1) x = x * (-1);
}
int main()
{
	LL i, u, v, w, j, k;
	read(n); read(m);
	for(i = 1; i <= n; i++)
		for(j = 1; j <= n; j++)
			if(i == j) dis[i][j] = 0;
			else dis[i][j] = MAX;
	for(i = 1; i <= m; i++)
	{
		read(u); read(v); read(w);
		dis[u][v] = min(dis[u][v], w);
		dis[v][u] = min(dis[v][u], w);
		cnt[u][v] = cnt[v][u] = 1;
	}
	for(k = 1; k <= n; k++)
	{
		for(i = 1; i <= n; i++)
		{
			for(j = 1; j <= n; j++)	
			{
				if(dis[i][k] + dis[k][j] == dis[i][j])
					cnt[i][j] = cnt[i][j] + cnt[i][k] * cnt[k][j];
				if(dis[i][k] + dis[k][j] < dis[i][j])
				{
					dis[i][j] = dis[i][k] + dis[k][j];
					cnt[i][j] = cnt[i][k] * cnt[k][j];
 				}
			}
		}
	}
	for(i = 1; i <= n; i++)
	{
		for(j = 1; j <= n; j++)
		{
			if(cnt[i][j] == 0) continue;
			if(cnt[i][j] >= 2) continue;
			for(k = 1; k <= n; k++)
			{
				if(i == k || j == k) continue;
				if(dis[i][j] == dis[i][k] + dis[k][j])
					{ans[k] = true; flag = true;}
			}
		}
	}
	if(flag == false) puts("No important cities.");
	for(i = 1; i <= n; i++) 
		if(ans[i]) printf("%lld ", i);
	return 0;	
}

```

---

## 作者：rediserver (赞：0)

# P1841 [JSOI2007]重要的城市
[原题地址](https://www.luogu.org/problemnew/show/P1841)
[GitHub题解](https://github.com/jerrykcode/luogu)

## 思路

对顶点src，以其为源进行dijkstra，对于除src外的任意顶点v，可以得到src到v的最短距离，以及src到v的最短路径上v的前驱顶点(即最短路径上v的前一个顶点)，也可以知道前驱是否唯一。若前驱唯一，则表示经过前驱到达v是src到v的唯一最短路径，那么只要删除前驱顶点，src到v的最短距离一定会变大(甚至src无法到达v)，也就是说v的唯一前驱是重要城市。若src到达v的最短路径上v的前驱(上一个顶点)不唯一，所以删除v的可能的前驱中的一个，v还可以通过其他前驱到达，所以这些前驱不一定是重要城市。

遍历除src外的所有顶点，若其前驱唯一(且不是src)，那么该前驱是重要城市。

注意若v的唯一前驱是src，若删除唯一前驱src，src已不存在，那么src到v的最短距离已无意义，所以src不能被判断为重要城市。

以每一个顶点分别作为src进行dijkstra，可以得到所有的重要城市。

对于dijkstra中判断前驱是否唯一，并记录唯一前驱：

* 从优先队列中弹出的顶点设为top_v，当前它与src的距离是最小的

* top_v的邻接点设为adj_v

* 若src到top_v的距离加上top_v到adj_v的距离`小于`之前src到adj_v的最短距离，则：

	* 经过top_v到达adj_v为目前src到达adj_v的唯一最短路径，更新top_v为adj_v的唯一前驱

* 若src到top_v的距离加上top_v到adj_v的距离`等于`之前src到adj_v的最短距离，则：

	* adj_v可以经过top_v到达，但也可以走之前的最短路径，此时adj_v有多个前驱(不需要记录前驱，只要记录adj_v有多个前驱即可)


## 代码

```cpp
#include <cstdio>
#include <cstdlib>
#include <vector>
#include <queue>
using namespace std;

typedef unsigned char vertex_t; //顶点类型(输入顶点编号最大200)
typedef unsigned short weight_t; //边权重类型(输入边权最大10000)
typedef unsigned int dist_t; //距离类型(输入边权最大10000, 但两个顶点之间的距离可能超出65535)

//类型可以存储的最大值
#define VERTEX_T_INF 0xff
#define DIST_T_INF 0xffffffff

//邻接点结构体
struct AdjNode {
	vertex_t adj_v; //邻接顶点
	weight_t adj_weight; //邻接边权重
	AdjNode(vertex_t adj_v, weight_t adj_weight) : adj_v(adj_v), adj_weight(adj_weight) {}
};

//重要城市类
class ImportantCities {
public:
	/* 标记出重要城市 
	 @param graph 图
	 @param n 图顶点数量
	 @param is_important_city 数组(传出)，标记顶点是否为重要城市
	 @retrun void
	 */
	void importantCities(vector<AdjNode> * graph, size_t n, bool * is_important_city);
private:
	//dijkstra中优先队列使用的结构体
	struct PriorityNode {
		vertex_t v;
		dist_t dist;
		PriorityNode(vertex_t v, dist_t dist) : v(v), dist(dist) {}

		//优先队列用于比较的结构体
		struct cmp {
			bool operator() (PriorityNode& a, PriorityNode& b) {
				return a.dist > b.dist;
			}
		};
	};
private:
	//成员变量
	dist_t * dist_; //最短距离
	vertex_t * pre_; //前驱顶点
	bool * collected_; //标记顶点是否收录
	priority_queue<PriorityNode, vector<PriorityNode>, PriorityNode::cmp> pq_; //优先队列
private:
	static const vertex_t multi_previous = VERTEX_T_INF; //表示有多个前驱
};

void ImportantCities::importantCities(vector<AdjNode>* graph, size_t n, bool * is_important_city) {
	fill(is_important_city, is_important_city + n, false); //初始化
	dist_ = new dist_t[n];
	pre_ = new vertex_t[n];
	collected_ = new bool[n];
	vertex_t src;	
	for (size_t i = 0; i < n; i++) { //遍历顶点
		src = (vertex_t)i; //以顶点 i 作为源进行dijkstra
		fill(dist_, dist_ + n, DIST_T_INF); //初始化
		fill(collected_, collected_ + n, false); //初始化
		dist_[src] = 0;
		pq_.push(PriorityNode(src, 0));
		vertex_t top_v, adj_v;
		dist_t tmp_dist;
		while (!pq_.empty()) {
			top_v = pq_.top().v; //top_v出队列，是当前与src的最短距离中最小的
			pq_.pop();
			if (collected_[top_v]) continue;
			collected_[top_v] = true;
			for (auto it = graph[top_v].begin(); it != graph[top_v].end(); it++) { //遍历邻接点
				adj_v = it->adj_v; //邻接顶点
				if (!collected_[adj_v]) {
					tmp_dist = dist_[top_v] + (dist_t)it->adj_weight; //经过top_v到达adj_v的距离
					if (tmp_dist < dist_[adj_v]) { //若经过top_v到达adj_v可以减小距离
						dist_[adj_v] = tmp_dist; //更新
						pre_[adj_v] = top_v; //更新top_v为adj_v的前驱，此时src经过top_v到达adj_v是src到adj_v的最短路径，所以top_v是adj_v的唯一的前驱
						pq_.push(PriorityNode(adj_v, tmp_dist));
					}
					else if (tmp_dist == dist_[adj_v]) { //若经过top_v到达adj_v与之前到达adj_v的最短距离相同
						//此时从src到达adj_v的最短路径有多条，可以经过top_v也可以使用其他的路径，所以此时adj_v的前驱不唯一，故记录pre_[adj_v]为multi_previous
						pre_[adj_v] = multi_previous; //multi_previous表示adj_v的前驱有多个
					}
				}
			} //for
		} //while (dijkstra)
		for (size_t j = 0; j < n; j++)
			if (j != i && pre_[j] != multi_previous && pre_[j] != src) {
				//若j的前驱唯一，则若把它的唯一前驱顶点删除，src到j的最短距离一定会变大，故它的唯一前驱为重要城市
				//注意j的唯一前驱为src的情况下，src不算重要城市，因为若删除src，src到j的最短距离已无意义
				is_important_city[pre_[j]] = true; //标记j为重要城市
			}
	} //for
	//释放内存
	free(dist_);
	free(pre_);
	free(collected_);
}

int main() {
	int n, m;
	scanf("%d %d", &n, &m);
	vector<AdjNode> * graph = new vector<AdjNode>[n];
	int v, w, c;
	//插入边
	for (size_t i = 0; i < m; i++) {
		scanf("%d %d %d", &v, &w, &c);
		v--; w--; //顶点改为从0编号
		graph[v].push_back(AdjNode((vertex_t)w, (weight_t)c));
		graph[w].push_back(AdjNode((vertex_t)v, (weight_t)c));
	}
	ImportantCities important_cities;
	bool * is_important_city = new bool[n];
	important_cities.importantCities(graph, n, is_important_city);
	bool flag = true;
	for (size_t i = 0; i < n; i++) 
		if (is_important_city[i]) { //若是重要城市
			flag = false;
			printf("%d ", i + 1);
		}	
	if (flag) printf("No important cities.");
	for (size_t i = 0; i < n; i++)
		vector<AdjNode>().swap(graph[i]);
	free(is_important_city);
	return 0;
}
```


---

## 作者：hehelego (赞：0)

题意:   
求出所有满足这个条件的点:  
设dis(i,j)为原图中i,j的最短路长度  
删除这个点和与这个点连接的边后,存在点对(s,t)实际最短路s->t的长度变长(不联通记也行).  

题目相关: 最短路径树(说是个树,其实是个DAG,有负权/0权可能会导致不是DAG,那个时候最短路径树也没什么意义,或者说不存在).

# 先上代码


```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#include <queue>
using namespace std;

int read(){
	int x=0;char ch;
	do{ch=getchar();}while(ch>'9'||ch<'0');
	do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');
	return x;
}
const int N=500;
const int M=N*N*2;
const int INF=0x3f3f3f3f;
int n,m,a,b,c,tag[N];
struct E{ int v,w;E(){} E(int a,int b){ v=a;w=b; } };
int dis[N],inq[N],cnt[N],from[N];
vector<E> g[N];


// 考虑每个点作为根的最短路径树.这里使用SPFA求出.  
// 复杂度不太对,接近于完全图,O(NM)=O(N^3),建议使用没有堆优化的dijkstra算法来做,但是我很懒,那个年代的大多数出题人还没有卡spfa的意识
void solve(int s){
	for(int i=1;i<=n;i++){
		from[i]=0;
		dis[i]=INF;
		inq[i]=0;
		cnt[i]=0;
      // 这个cnt是关键,表示最短路径树(再次强调其实是个DAG不一定是树)上,dis[v]=dis[u]+w的点的个数,emm就是上一层连向v的点的个数.
	}
	queue<int> q;
	dis[s]=0;inq[s]=1;q.push(s);cnt[s]=1;
//	printf("Source %d\n",s);
	while(!q.empty()){
		int u=q.front();q.pop();inq[u]=0;
		for(int i=0;i<g[u].size();i++){
			int v=g[u][i].v,w=g[u][i].w;
			if(v==from[u]) continue;
        // relax,扔掉原来的最短路径树.
			if(dis[v]>dis[u]+w){
				cnt[v]=1;from[v]=u;
				dis[v]=dis[u]+w;
				//printf("\trelax(%d->%d) d=%d w=%d\n",u,v,dis[v],w);
				if(!inq[v]){ inq[v]=1; q.push(v); }
			}else if(dis[v]==dis[u]+w){
        // 一样长,那么这条边加到最短路径树里面,v的上一层连向它的节点数量增加1个.
				//printf("\t adding (%d->%d) d=%d w=%d\n",u,v,dis[v],w);
				cnt[v]++; from[v]=u;
			}
		}
	}
	//for(int i=1;i<=n;i++)
//		printf("\tdis[%d]=%d,facnt=%d\n",i,dis[i],cnt[i]);
	for(int i=1;i<=n;i++){
		if(i==s) continue;
		if(cnt[i]==1&&from[i]!=s){ tag[from[i]]=1; }
	}
}

int main(){
	n=read();m=read();
	for(int i=0;i<m;i++){
		a=read();b=read();c=read();
		g[a].push_back(E(b,c));
		g[b].push_back(E(a,c));
	}
	for(int i=1;i<=n;i++) solve(i);
	int cnt=0;
	for(int i=1;i<=n;i++)
		if(tag[i]){ printf("%d ",i); cnt++; }
	if(cnt==0) printf("No important cities.");
	puts("");
	return 0;
}

```  


思路:考虑枚举s,求最短路径树,如果某点的父亲只有一个(emm..可能说最短路径树上连向u的点数量是1)那么u的父亲是关键点.

正确性...不会证明但是可以感性理解,对于满足上面条件的节点u.删掉它的父亲,这个点会从最短路径树上脱离开,显然s->u的最短路变长了.


---

## 作者：Holmes (赞：0)

发一个Floyd的题解

根据题意，一个城市是重要城市的条件是两个城市之间最短路的必经点，即通过点s可使d{a,b}更小，由此可以想到spfa和Floyd的状态转移方程：

即dist[a][b]=min{ dist[a][s]+dist[s][b] }    此时可令pre[a][b]=s

但若dist[a][s1]+dist[s1][b]==dist[a][s2]+dist[s2][b] ,则此时s1,s2均不是重要城市，就需对a,b进行标记，我使用vis[i][j]表示i到j的最短路对应的重要城市不重要。

可能有人会质疑，若i到j的最短路上不只有s1和s2，那其他点也有可能是重要城市，那么此时这个点一定存在于其他两个点的最短路上，依然可以被记录，所以证明此算法的正确性

坑：输出答案时应排序

代码如下：

```cpp
#include <cstdio>
#include <iostream>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <algorithm>
using namespace std;
const int maxx=205,inf=0x3f3f3f3f;
int n,m,pre[maxx][maxx];
int mp[maxx][maxx];
bool vis[maxx][maxx];                 //各数组用途已说明
void getint(int &x){
    x=0; char c=' ';
    while(c<'0' || c>'9') c=getchar();
    while(c<='9' && c>='0'){ x=x*10+c-'0'; c=getchar();} 
}
int main()
{
    int x,y,z;
    getint(n); getint(m);
    memset(pre,0,sizeof(pre)); memset(vis,0,sizeof(vis));
    memset(mp,0x3f,sizeof(mp));
    for(int i=1;i<=n;++i) mp[i][i]=0;
    for(int i=1;i<=m;++i){
        getint(x); getint(y); getint(z);
        mp[x][y]=mp[y][x]=z;
    }

    for(int k=1;k<=n;++k){                                //Floyd
        for(int i=1;i<=n;++i) if(k!=i){
            for(int j=1;j<=n;++j) if(k!=j && i!=j){
                if(mp[i][j]>mp[i][k]+mp[k][j]){
                    mp[i][j]=mp[i][k]+mp[k][j];
                    vis[i][j]=false;
                    pre[i][j]=k;
                }else if(mp[i][j]==mp[i][k]+mp[k][j]) vis[i][j]=true;
            } 
        }
    }

    int q[maxx],top=0;          //用来装答案
    bool inq[maxx];                 //一个点可能是多个点的最短路上的重要城市
    memset(inq,0,sizeof(inq));     // 故应避免重复输出
    for(int i=1;i<=n;++i){                    //寻找答案
        for(int j=1;j<=n;++j){
            if(i!=j && !vis[i][j] && pre[i][j] && !inq[pre[i][j]]){
                q[++top]=pre[i][j]; inq[q[top]]=true;
            }
        }
    }
    sort(q+1,q+top+1);        //坑
    for(int i=1;i<=top;++i) printf("%d ",q[i]);
    if(!top) printf("No important cities.");
    printf("\n");
    return 0;
}
```

---


# [AHOI2009] 中国象棋

## 题目描述

这次小可可想解决的难题和中国象棋有关，在一个 $n$ 行 $m$ 列的棋盘上，让你放若干个炮（可以是 $0$ 个），使得没有一个炮可以攻击到另一个炮，请问有多少种放置方法。大家肯定很清楚，在中国象棋中炮的行走方式是：一个炮攻击到另一个炮，当且仅当它们在同一行或同一列中，且它们之间恰好 有一个棋子。你也来和小可可一起锻炼一下思维吧！


## 说明/提示


**样例说明**

除了 $3$ 个格子里都塞满了炮以外，其它方案都是可行的，所以一共有 $2 \times 2 \times 2-1=7$ 种方案。

**数据规模与约定**

- 对于 $30\%$ 的数据，$n$ 和 $m$ 均不超过 $6$。
- 对于 $50\%$ 的数据，$n$ 和 $m$ 至少有一个数不超过 $8$。
- 对于 $100\%$ 的数据，$1 \leq n,m \leq 100$。

题面修改：@syksykCCC。

## 样例 #1

### 输入

```
1 3```

### 输出

```
7```

# 题解

## 作者：顾z (赞：391)

## 题目描述

> 这次小可可想解决的难题和中国象棋有关，在一个N行M列的棋盘上，让你放若干个炮（可以是0个），使得没有一个炮可以攻击到另一个炮，请问有多少种放置方法。大家肯定很清楚，在中国象棋中炮的行走方式是：一个炮攻击到另一个炮，当且仅当它们在同一行或同一列中，且它们之间恰好 有一个棋子。你也来和小可可一起锻炼一下思维吧！

## 40pts

考试遇到了这个题,**玄学打表**得了$40pts$

~~玄学打表吼啊~~

## ~~xjb~~分析

正解竟然是个$DP$? 还有人说是状压$DP$?~~哪里来的状压啊!~~

### 前置知识

考虑到我们的合法状态的话,**每一行每一列的炮的数量$\le 2$**

(炮打隔重山?) 显然 如果一行或者一列有三个炮的话将会不合法.(两个炮可以互相打啊 qwq)

### 如何设状态?

因为**每一行每一列的炮的数量$\leq 2$**

所以我们考虑记数组去存储有几列放了一个炮,有几列放了两个炮.

我们又需要考虑转移?

因此设出状态

　　$f[i][j][k]$代表放了前$i$行,有$j$列是有一个棋子,有$k$列是有2个棋子的合法方案数.

这个时候我们知道全部的列数,又知道一些情况的列数.

所以我们可以求出不放棋子的列数

**单步容斥**：空的=全部的$-$合法的 

**即**空的序列$=m-j-k$

### 确定情况

1. 我们可以在当前第$i$行不放棋子.
2. 我们可以在当前第$i$行放一个棋子
3. 我们可以在当前第$i$行放两个棋子.

接下来就需要分类讨论这些情况.

### 分类讨论

#### 一.不放棋子

我们可以直接继承上面的状态.即
$$f[i][j][k]=f[i-1][j][k]$$

#### 二.放一个棋子

显然我们**不会选择放在有两个棋子的列.**

因此存在情况如下

![](https://i.loli.net/2018/10/04/5bb541376ff9f.png)

##### 解释：

###### 放在一个棋子的列

> 我们在某一个有一个棋子列放置棋子,会使这一列变为有两个棋子.
>
> 即我们要得到$f[i][j][k]$需要在$j+1$个有一个棋子的列放置棋子,变为$j$个有一个棋子的列
>
> 而我们又会得到一个新的有两个棋子的列.因此我们之前必须有$k-1$个有两个棋子的列.

即$f[i-1][j+1][k-1]$的状态可以传递给$f[i][j][k]$

而我们又可以在$(j+1)$中的任何一列放置这一个棋子.

因此我们要$\times (j+1)$

###### 放在没有棋子的列

> 在一个没有棋子的列放置棋子,我们会得到一个新的有一个棋子的列.
>
> 即我们要从$j-1$得到$j$.
>
> 而这个时候,我们有两个棋子的列的数量不会变,所以从$k$传递即可.

即$f[i-1][j-1][k]$的状态可以传递给$f[i][j][k]$

又因为我在空列中的任何一列放置这个棋子.

所以要$\times $ $(m-(j-1)-k)$

#### 三.放两个棋子

这个时候情况会多一个.先请大家自己考虑一下.

这个时候存在情况如下

![](https://i.loli.net/2018/10/04/5bb5415f8bc17.png)

##### 解释

###### 一个放在有一个棋子的列,一个放在没有棋子的列

> 这个时候,我们放置之后 :
>
>  	一个没有棋子的列会变成一个有一个棋子的列,而一个有一个棋子的列会变成一个有两个棋子的列。
>
> 此时我们发现,
>
> ​	有一个棋子的列的数量不会变,因此第二维依旧为$j$，
>
> ​	又因为我们会新增一个有两个棋子的列,所以我们需要从$k-1$转移过来.

又因为我们可以在有一个棋子的列随便放,空列随便放.

根据**乘法原理**,需要$\times j \times (m-j-(k-1))$

###### 都放在没有棋子的列

> 此时我们放置之后
>
> ​	会增加两个新的有一个棋子的列.
>
> 因此我们需要从$j-2$转移过来.
>
> 而两个棋子的列的数量并不会改变,所以依旧为$k$

又因为在空列中我们随便放.

根据**组合数学**,需要$\times C_{m-(j-2)-k}^{2}$

###### 都放在有一个棋子的列

> 我们放置在有一个棋子的列之后：
>
> ​	这两个有一个棋子的列都会变成有两个子的列.
>
> ​	即$j+2$变成$j$，从$k-2$变成$k$

又因为这些有一个棋子的列我们随便选择.

根据**组合数学**,需要$\times C_{j+2}^{2}$

### 分析完毕

我们需要接下来做的就是**判断边界**,一定要判断!!(血的教训!


代码

```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<cctype>
#include<cstring>
#define mod 9999973
#define int long long
#define R register
using namespace std;
inline  void in(int &x)
{
	int f=1;x=0;char s=getchar();
	while(!isdigit(s)){if(s=='-')f=-1;s=getchar();}
	while(isdigit(s)){x=x*10+s-'0';s=getchar();}
	x*=f;
}
int n,m,ans;
int f[108][108][108];
inline int C(int x)
{
	return ((x*(x-1))/2)%mod;
}
signed main()
{
	in(n),in(m);
	f[0][0][0]=1;
	for(R int i=1;i<=n;i++)
	{
		for(R int j=0;j<=m;j++)
		{
			for(R int k=0;k<=m-j;k++)
			{
				f[i][j][k]=f[i-1][j][k];
				if(k>=1)(f[i][j][k]+=f[i-1][j+1][k-1]*(j+1));
				if(j>=1)(f[i][j][k]+=f[i-1][j-1][k]*(m-j-k+1));
				if(k>=2)(f[i][j][k]+=f[i-1][j+2][k-2]*(((j+2)*(j+1))/2));
				if(k>=1)(f[i][j][k]+=f[i-1][j][k-1]*j*(m-j-k+1));
				if(j>=2)(f[i][j][k]+=f[i-1][j-2][k]*C(m-j-k+2));
				f[i][j][k]%=mod;
			}
		}
	}
	for(R int i=0;i<=m;i++)
		for(R int j=0;j<=m;j++)
			(ans+=f[n][i][j])%=mod;
	printf("%lld",(ans+mod)%mod);
}
```



---

## 作者：__stdcall (赞：190)

好像不是很难

首先要想出来，每行最多只能放两个棋子，这是显然的

于是决策就是一行一行地处理

30分的做法就是裸的枚举，暴搜，枚举这一行放哪里，放几个

然后我想到了压位dp，按3进制表示当前棋盘的状态，即某一列没有棋子，或者有一个，两个棋子，能过50分

接着可以发现，棋子的顺序是无所谓的，并不需要准确知道当前棋盘的状态

于是有了100分做法：dp[i][j][k]表示放了前i行，有j列是有1个棋子，有k列有两个棋子

转移显然，分类讨论，乘法和加法原理，代码注释中写的很详细

我居然20min淦了省选题？蛤蛤蛤

蛤蛤蛤居然还是1A





```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
using namespace std;
typedef long long ll;
const int MAXN = 101;
const int MOD = 9999973;
int n,m;
ll dp[MAXN][MAXN][MAXN];
inline int C( int num ) { // 相当于C(num,2)
    return num*(num-1)/2;
}
int main() {
    scanf( "%d%d", &n, &m );
    dp[0][0][0] = 1;
    for( int i = 0; i < n; ++i ) // 放第i+1行
    for( int j = 0; j <= m; ++j ) // 有1个棋子的列数
    for( int k = 0; j+k <= m; ++k ) if( dp[i][j][k] ) { // 有2个棋子的列数
        dp[i+1][j][k] = ( dp[i+1][j][k] + dp[i][j][k] ) % MOD; // 不放
        if( m-j-k >= 1 ) dp[i+1][j+1][k] = ( dp[i+1][j+1][k] + dp[i][j][k]*(m-j-k) ) % MOD; // 放一个，在没有棋子的那一列
        if( j >= 1 ) dp[i+1][j-1][k+1] = ( dp[i+1][j-1][k+1] + dp[i][j][k]*j ) % MOD; // 放一个，在有一个棋子的那一列
        if( m-j-k >= 2 ) dp[i+1][j+2][k] = ( dp[i+1][j+2][k] + dp[i][j][k]*C(m-j-k) ) % MOD; // 放两个，都在没有棋子的两列
        if( m-j-k >= 1 && j >= 1 ) dp[i+1][j][k+1] = ( dp[i+1][j][k+1] + dp[i][j][k]*(m-j-k)*j ) % MOD; // 放两个，一个在没有棋子的列，一个在有一个棋子的列
        if( j >= 2 ) dp[i+1][j-2][k+2] = ( dp[i+1][j-2][k+2] + dp[i][j][k]*C(j) ) % MOD; // 两个，在一个棋子的列
    }
    ll ans = 0;
    for( int i = 0; i <= m; ++i ) // 有1个棋子的列
    for( int j = 0; i+j <= m; ++j ) { // 2个棋子的列
        ans = ( ans + dp[n][i][j] ) % MOD;
    }
    printf( "%lld\n", ans );
    return 0;
}

```

---

## 作者：ljc20020730 (赞：48)

好像这里的题解我都看不明白啊，算了，自己做吧！

其实这题就是状态转移比较多，比较混杂吧。

其实认认真真的想还是有点思路的，

现在我想把我的思路分享给大家，

这可能是本题题解中唯一一篇pas写的但是也是唯一一篇正常蒟蒻看的懂的题解吧？


题目大意：n\*m的棋盘上放若干颗棋子，要求每3颗棋子不共行，不共列求放法总数。

首先大状态：F[i,j,k]前i行 有j列放了一个棋子，k列放了2个棋子的  可能性个数

那么此时没有放棋子的列有：m-j-k 列

状态的种类数：没放棋子（empty）、空行、一列放了1个棋子，一列放了2个棋子，1列空棋子，

所以状态总数：没放棋子、放一个棋子在原有1个棋子上的、放1个棋子在没有放棋子的列上的、放两个棋子都在没有放棋子的列上、两个棋子都放在两个有1个棋子的列上、一个棋子在无棋子列且一个棋子放在有一个棋子的列上。

Sum（求和） {

- 没放棋子 F[i-1,j,k]

explain: Empty，不解释了；

- 放一个棋子在原本有一个棋子列上的 F[i-1,j+1,k-1] \* (j+1)f[i,j,k]

explain: 由于f[i,j,k]是由F[i-1,j+1,k-1]转移而来，所以用过去状态推现在状态，j+1表示1个棋子的列原来要多一个（现在少一个），k-1表示1个棋子的列原来要少一个（现在多一个），乘上(j+1)表示原来可以有j+1个位置可供放。

- 放一个棋子在原本没有棋子列上的 F[i-1,j-1,k] \* (m-(j-1)-k)

explain: 有些东西2中说过了，这里不再赘述，看上面就可以了，其实比较简单。原来没有多出1列有1个棋子的现在多出来了，所以从f[i-1,j-1,k]转移，这里发现一共有(m-(j-1)-k)列是空的（只有这几列能放）

- 放两个棋子，都在没有棋子的列上的 F[i-1,j-2,k]  \* C(m-j-k,2)

explain: 原来1个棋子列现在多了两个，所以从f[i-1,j-2,k]转移，原来一共有(m-j-k)个空位，现在要取其中的两个所以一共的可能性是C(m-j-k,2)

- 都在有一个棋子的列上 F[i-1,j+2,k-2] \* C(j,2)

explain: 原来有1个棋子的列少了2个，有2个棋子的列多了2个，所以从f[i-1,j+2,k-2]推出，原来一共有j个位置可放，现在要放2个棋子，所以可能性是C(j,2)

- 一个放在无棋子列，一个在有一个棋子的列上 F[i-1,j,k-1] \* j\* (m-j-（k-1))

explain: 对于f[i,j,k]中放在有1个棋子的行上的j的数目不变，k的数目增加所以前i行的k的数目要-1，可能性放在有1个棋子的格子上是有j个可能，放在空的格子上有的可能是m-j-(k-1)；


  }
AC的代码：

```cpp
var f:array[0..100,-2..100,-2..100]of   qword;
    n,m,i,j,k,ans:longint;
function ff(x:longint):longint;//求上述的C排列
begin
 exit(x*(x-1) div 2);
end;
begin
 readln(n,m);
 fillchar(f,sizeof(f),0);
 f[0,0,0]:=1;
 for i:=1 to n do
  for j:=0 to m do
   for k:=0 to m-j do
    f[i,j,k]:=(f[i-1,j,k]+f[i-1,j+1,k-1]*(j+1)+
    f[i-1,j-1,k]*(m-j-k+1)+f[i-1,j-2,k]*ff(m-j+2-k)+
    f[i-1,j+2,k-2]*(j+2)*(j+1) div 2+
    f[i-1,j,k-1]*j*(m-j-k+1)) mod 9999973;
 for i:=0 to m do
  for j:=0 to m do
   ans:=(ans+f[n,i,j])mod 9999973;
 writeln(ans);
end.

```

---

## 作者：ycyaw (赞：30)

经过多次爆蛋，还是~~秒~~切了此题。

一道少数没看题解做的题，~~哇居然是紫题我好牛逼~~。

开始~~不~~正经的讲题目：很显然发现这是一道动态规划题，先考虑设计状态。

很容易想到的状态是$dp[i][j]$表示前$i$行放上$j$个炮的方案数。但转移时我们就发现，这个状态所包含的信息太少了，从第$i-1$行转移到第$i$行，好像根本无法判断第$i$行怎么放，辣怎么办哩？

观察到炮的性质：一行或者一列最多只能放两个，放三个就会互相搞~~基~~起来。我们想要以行为层次进行转移，那么很显然我们要保存列的状态。

因为一列最多放一个或者两个，辣么我们用$dp[i][j][k]$表示前$i$行，有$j$列只放了一个，有$k$列放了两个的方案数，这个状态就十分的完美啦，完结撒花~

停停停，这都写了还要讲怎么转移吗？随便$yy$一下就好了啊？

显然根据我们设计的状态，是以$i$为层次进行转移的，辣么如何从第$i-1$行转移到第$i$行？我们欢快的进行分类讨论，发现情况并不多：

#### 1.第$i$行什么都不放。太愚蠢了。
$$
f[i][j][k]=f[i][j][k]+f[i-1][j][k]
$$
#### 2.放1个在空的列。根据状态很容易发现空的列是$m-j-k$。那么方案显然了：
$$
f[i][j][k]=f[i][j][k]+f[i-1][j-1][k]\times(m-(j-1)-k)
$$
#### 3.放1个在有1个的列。
$$
f[i][j][k]=f[i][j][k]+f[i-1][j+1][k-1]\times(j+1)
$$
#### 4.放2个都在空的列。这里就用到排列了，是之前状态乘以$C($之前空的列，$2)$。
$$
f[i][j][k]=f[i][j][k]+f[i-1][j-2][k]\times C(m-(j-2)-k)
$$
#### 5.放1个在空的列,1个在有1个的列。同样乘法原理：
$$
f[i][j][k]=f[i][j][k]+f[i-1][j][k-1]\times j\times (m-j-(k-1))
$$
#### 6.放2个在有1个的列。我一开始愚蠢到忘记考虑这种了。
$$
f[i][j][k]=f[i][j][k]+f[i-1][j+2][k-2]\times C(j+2)
$$
初始化很简单：$f[0][0][0]=1$。

完结撒花~，中途记得取模。

还需要代码吗？我想是的：
```cpp
#include<bits/stdc++.h>
#define ts cout<<"ok"<<endl
#define oo (1e18)
#define int long long
#define hh puts("")
#define mo 9999973
using namespace std;
int n,m,f[105][105][105];
inline int read(){
    int ret=0,ff=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-') ff=-ff;ch=getchar();}
    while(isdigit(ch)){ret=(ret<<3)+(ret<<1)+(ch^48);ch=getchar();}
    return ret*ff;
}
inline int C(int aa){//C(aa,2)
    return (aa*(aa-1)/2)%mo;
}
signed main(){
    n=read(),m=read();
    f[0][0][0]=1;
    for(int i=1;i<=n;i++)
        for(int j=0;j<=m;j++)
            for(int k=0;j+k<=m&&j+k<=2*i;k++){
                f[i][j][k]=(f[i][j][k]+f[i-1][j][k])%mo;//什么都不放 
                if(j>=1) f[i][j][k]=(f[i][j][k]+f[i-1][j-1][k]*(m-(j-1)-k)%mo)%mo;//放1个在空的列 
                if(k>=1) f[i][j][k]=(f[i][j][k]+f[i-1][j+1][k-1]*(j+1)%mo)%mo;//放1个在有1个的列 
                if(j>=2) f[i][j][k]=(f[i][j][k]+f[i-1][j-2][k]*C(m-(j-2)-k)%mo)%mo;//放2个都在空的列 
                if(k>=1) f[i][j][k]=(f[i][j][k]+f[i-1][j][k-1]*j%mo*(m-j-(k-1))%mo)%mo;//放1个在空的列,1个在有1个的列 
                if(k>=2) f[i][j][k]=(f[i][j][k]+f[i-1][j+2][k-2]*C(j+2)%mo)%mo;//放2个在有1个的列 
            }
    int ans=0;
    for(int i=0;i<=m;i++)
        for(int j=0;i+j<=m&&(i+j)<=2*n;j++)
            ans=(ans+f[n][i][j])%mo;
    printf("%lld",ans);
    return 0;
}
```


---

## 作者：zhoukangyang (赞：19)

只有每行每列都只有 $\le 2$ 个炮，才会不能互相攻击

于是对于第 $i$ 行，我们可以记录在这一行和这一行之上的 有一个炮的列数 (记为 $j$) 和有两个炮的列数 (记为 $k$)。让 $dp_{i, j, k}$ 则表示这样放置的方案数

$\to$ 表示转移

## 状态转移 $1$ : 增加 $0$ 个炮
1. $dp_{i-1,j,k} \to dp_{i,j,k}$ 

保持原来的状态

## 状态转移2:增加1个炮
1. $dp_{i-1,j+1,k-1} \times (j+1) \to dp_{i, j, k}$

有一列从一个炮增加到了两个炮

2. $dp_{i-1, j-1, k} \times (m-j-k+1) \to dp_{i, j, k}$

有一列从零个炮增加到了一个炮

## 状态转移3:增加2个炮
1. $dp_{i-1,j-1,k} \times j \times (m - j - k + 1) \to dp_{i,j,k}$

有一列从零个炮增加到了一个炮，有一列从一个跑增加到了两个炮（可以是上一次增加炮的那一列）

2. $dp_{i-1, j-2, k} \times \binom{m-i-k+2}{2} \to dp_{i, j, k}$

有两列从零个炮增加到了一个炮

3. $dp_{i-1,j+2,k-2} \times \binom{j + 2}{2} \to dp_{i, j, k}$

有两列从一个炮增加到了两个炮

### 话不多说，上代码：
```cpp
#include<bits/stdc++.h>
#define mod 9999973
using namespace std;
long long c(int a) {
    return a*(a-1)/2;
}
int n,m;
long long dp[101][101][101];
int main() {
    scanf("%d%d",&n,&m);
    dp[0][0][0]=1;
    for(int i = 1; i <= n; i++) {
        for(int j = 0; j <= m; j++)
            for(int k = 0; k <= m-j; k++)
                dp[i][j][k]=dp[i-1][j][k];
        for(int j = 0; j <= m; j++)
            for(int k = 1; k <= m-j; k++)
                dp[i][j][k]+=dp[i-1][j+1][k-1]*(j+1);
        for(int j = 1; j <= m; j++)
            for(int k = 0; k <= m-j; k++)
                dp[i][j][k]+=dp[i-1][j-1][k]*(m-j-k+1);
        for(int j = 2; j <= m; j++)
            for(int k = 0; k <= m-j; k++)
                dp[i][j][k]+=dp[i-1][j-2][k]*c(m-j-k+2);
        for(int j = 0; j <= m; j++)
            for(int k = 2; k <= m-j; k++)
                dp[i][j][k]+=dp[i-1][j+2][k-2]*c(j+2);
        for(int j = 0; j <= m; j++)
            for(int k = 1; k <= m-j; k++)
                dp[i][j][k]+=dp[i-1][j][k-1]*j*(m-k-j+1);
        for(int j = 0; j <= m; j++)
            for(int k = 0; k <= m-j; k++)
                dp[i][j][k]%=mod;
    }
    int ans=0;
    for(int j = 0; j <= m; j++)
        for(int k = 0; k <= m-j; k++)
            ans=(ans+dp[n][j][k])%mod;
    printf("%lld",ans);
    return 0;
}
```

**祝大家学习愉快！**

---

## 作者：我只能爬 (赞：16)

　　在qbxt学了这个题，虽然也没怎么听明白，但是在改了八次状态转移方程之后，我终于！终于！过了这个题（心塞）

　　那么，用钟长者的话来说，这个题就属于『瞎DP』。

### 思路

　　八九不离十的DP。那么，该怎么表示状态呢？

　　三维数组f[i][j][k]（要不是钟长者我也想不到Orz）

　　i表示已经搞完了几行，j表示有几列放了1个棋子，k表示几列放了2个棋子。为什么要这么表示呢？象棋我觉得大家都会（都比我强orz），如果某一行或者某一列有三个炮的话，两边的炮就会隔着中间的炮打起来。（中间的炮：你们......？）

　　所以，每一列的状态只有可能是：没有炮，一个炮和两个炮。一个炮用j表示，两个炮用k表示，没有炮就用（m - j - k）表示。

　　那么，就开始我们的表演吧！
### 状态转移

```cpp
	f[i + 1][j][k] = (f[i][j][k] + f[i + 1][j][k]) % mod;
	if(j >= 1) f[i + 1][j - 1][k + 1] = (f[i + 1][j - 1][k + 1] + f[i][j][k] * j) % mod;
	if((m - k - j) >= 1) f[i + 1][j + 1][k] = (f[i + 1][j + 1][k] + f[i][j][k] * (m - k - j)) % mod;
	if(j >= 2) f[i + 1][j - 2][k + 2] = (f[i + 1][j - 2][k + 2] + f[i][j][k] * C(j)) % mod;
	if((m - j - k) >= 2) f[i + 1][j + 2][k] = (f[i + 1][j + 2][k] + f[i][j][k] * C(m - j - k)) % mod;
	if((m - k - j) >= 1 && j >= 1) f[i + 1][j][k + 1] = (f[i + 1][j][k + 1] + f[i][j][k] * (m - k -  j) * j) % mod;
```

　　好长，看的眼晕（反正对我来说是这样子......）

　　一句一句来看：

```cpp
f[i + 1][j][k] = (f[i][j][k] + f[i + 1][j][k]) % mod;
```

　　这句的意思就是啥也不放，这样就加上自己本来的状态以及上一行的状态就可以了

```cpp
if(j >= 1) f[i + 1][j - 1][k + 1] = (f[i + 1][j - 1][k + 1] + f[i][j][k] * j) % mod;
```

　　这句就是如果有一列或几列只放了一个炮的话，那我们不就可以往这一列来一（个）炮？这样的话，这一列就变成有两个炮了，所以，有一个炮的列就少了一。所以我们将j减1，k加1.乘以j是因为有j种可能。本来应该是C（1，j），但是这个东西的答案就是j，所以就直接写j了

```cpp
if((m - k - j) >= 1) f[i + 1][j + 1][k] = (f[i + 1][j + 1][k] + f[i][j][k] * (m - k - j)) % mod;
```

　　关于(m - k - j)我们之前也提到过了，就是『没有炮的列』。那么如果有没有炮的列，也可以往上来一炮，那么有一个炮的列就多了一个。

```cpp
	if(j >= 2) f[i + 1][j - 2][k + 2] = (f[i + 1][j - 2][k + 2] + f[i][j][k] * C(j)) % mod;
    if((m - j - k) >= 2) f[i + 1][j + 2][k] = (f[i + 1][j + 2][k] + f[i][j][k] * C(m - j - k)) % mod;
    if((m - k - j) >= 1 && j >= 1) f[i + 1][j][k + 1] = (f[i + 1][j][k + 1] + f[i][j][k] * (m - k -  j) * j) % mod;
```

　　既然前面明白了，这地方也就会好明白的多。就是如果有两个没有炮的列，或者两个有一个炮的列，又或者一个有一个炮的列一个没炮的列，那就可以往上放俩炮，对吧？注意一下相应的列的数量的改变（语言逐渐暴躁）。

　　那么在这里就给出整个程序好啦。那个C表示的是排列组合，下边（还是上边？？）那个数是2.

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;
#define ll long long
#define maxn 110
#define mod 9999973

int n, m;
int C(int _){
    return _ * (_ - 1) / 2;
}
ll f[maxn][maxn][maxn];
//数组表示已求前i行，有j列放了1个炮，有k列放了2个炮
int main(){
    cin >> n >> m;
    f[0][0][0] = 1;
    for(int i = 0; i <= n; ++i)
        for(int j = 0; j <= m; ++j)
            for(int k = 0; j + k <= m; ++k)
                if(f[i][j][k]){
                    f[i + 1][j][k] = (f[i][j][k] + f[i + 1][j][k]) % mod;
                    if(j >= 1) f[i + 1][j - 1][k + 1] = (f[i + 1][j - 1][k + 1] + f[i][j][k] * j) % mod;
                    if((m - k - j) >= 1) f[i + 1][j + 1][k] = (f[i + 1][j + 1][k] + f[i][j][k] * (m - k - j)) % mod;
                    if(j >= 2) f[i + 1][j - 2][k + 2] = (f[i + 1][j - 2][k + 2] + f[i][j][k] * C(j)) % mod;
                    if((m - j - k) >= 2) f[i + 1][j + 2][k] = (f[i + 1][j + 2][k] + f[i][j][k] * C(m - j - k)) % mod;
                    if((m - k - j) >= 1 && j >= 1) f[i + 1][j][k + 1] = (f[i + 1][j][k + 1] + f[i][j][k] * (m - k -  j) * j) % mod;
                }
    ll ans = 0;
    for(int i = 0; i <= m; ++i){
        for(int j = 0; i + j <= m; ++j){
            ans = (ans + f[n][i][j]) % mod;
        }
    }
    cout << ans << endl;
    return 0;
}

```

　　顺便安利我的新视频：[【外传】【初音÷oi】状态转移](https://www.bilibili.com/video/av29799588/)

---

## 作者：hbhz_zcy (赞：6)

不同于其他人的做法，我提出了一种时空复杂度较低的算法，在本题中为 $O(\max(N,M)^2)$。  
考虑 $ f[i][j][k] $ 表示有 $i$ 行 $j$ 列，并且在第 $i$ 行选了 $k$ 个的答案，$0\le k\le 2$ （后面 $k$ 扩展到了 $3$ ）。  
发现两条性质：  
1. 显然有不管在第 $i$ 行选了 $k$ 个，还是在别的行选了 $k$ 个，答案都是一样的。    
2. 显然有“ $i$ 行 $j$ 列且行选 $k$ 个”等价于“ $j$ 行 $i$ 列且列选 $k$ 个”。  

令 $f[i][j]$ 从 $f[i-1][j][...]$ 转移，会发现 $k$ 为 $0$ 或 $1$ 很好维护。  
+  $k=0$ 时，$f[i][j][0]=f[i-1][j][0]+f[i-1][j][1]+f[i-1][j][2]$   


+  $k=1$ 时，所在**列j**必须只选了 $1$ 或 $0$ 个，选的值有 $j$ 个位置去放。进而根据性质：  
	 $f[i][j][1]=j*(f[j][i-1][0]+f[i-1][j][1])$   


+  $k=2$ 时情况比较复杂，组合数计算出位置有 $j*(j-1)/2$ 种方案，每种方案都要求要有两列都选少于两个。**因此引入“** $i$ **行** $j$ **列，有两列都选一个”为** $f[i][j][3]$ ，发现很好搞：  
	 $f[i][j][2]=j*(j-1)/2*(f[j-1][i-1][0]+2* f[j-1][i-1][1]+f[j][i-1][3])$   
   其实还是蛮难理解的， $f[j-1][i-1][0]$ 等于 $i-1$ 行 $j$ 列有两列都选 $0$ 的个数，$f[j-1][i-1][1]$ 等于 $i-1$ 行 $j$ 列有两列选 $01$ 或 $10$ 的个数，故乘 $2$ 。  


+  $k=3$ 时，我们愉快地发现，不用再新加入 $4$ 或 $5$ 等等去维护了！  
	 $f[i][j][3]=j*(j-1)* (f[j-1][i-2][0]+2* f[j-1][i-2][1]+f[j][i-2][3])+j* f[j][i-2][0]$   
   前面一大项是 $2$ 列选两个 $1$ 不同时在同列的个数，后面一小项表示在同列的个数。  

至此，递推式完成了。  
不过会发现递推顺序很奇怪，需要类似先剥洋葱一样遍历 $\min(N,M)^2$ ，然后再遍历余下部分。我比较懒，于是使用了记忆化搜索去搞。  
递推边界： $i<0||j<0$ 时为 $0$，$i=0\&\&j=0$ 时，$k$ 为 $0$ 则为 $1$，否则为 $0$。  
说句闲话，如果每行每列最多放 $3$ 个那就不适用这种算法了（尽管复杂度可以，思路会很复杂）。  
```  
#include<iostream>
#include<cstdio>
#include<cstring>
#define LL long long
#define check(i,j,k)  if(f[i][j][k]==-1){f[i][j][k]=dfs(i,j,k);}
using namespace std;
const int maxn=1010,mod=9999973;
int N,M;LL f[maxn][maxn][4];
int qd(){
	int rt=0;char c=getchar();
	while(c<'0'||c>'9')  c=getchar();
	while('0'<=c&&c<='9')  rt=(rt<<3)+(rt<<1)+c-48,c=getchar();
	return rt;
}
LL dfs(int x,int y,int k){
	if(x==0||y==0)  return f[x][y][k]=(k?0:1);
	if(x<0||y<0)  return 0;
	if(k==0){
		check(x-1,y,0);check(x-1,y,1);check(x-1,y,2);
		f[x][y][k]=(f[x-1][y][0]+f[x-1][y][1]+f[x-1][y][2])%mod;
	}
	if(k==1){
		check(y,x-1,0);check(y,x-1,1);
		f[x][y][k]=y*(f[y][x-1][0]+f[y][x-1][1])%mod;
	}
	if(k==2){
		check(y-1,x-1,0);check(y-1,x-1,1);check(y,x-1,3);
		f[x][y][k]=y*(y-1)/2*(f[y-1][x-1][0]+2*f[y-1][x-1][1]+f[y][x-1][3])%mod;
	}
	if(k==3){
		check(y,x-2,0);check(y-1,x-2,0);check(y-1,x-2,1);check(y,x-2,3);
		f[x][y][k]=(y*(y-1)*(f[y-1][x-2][0]+2*f[y-1][x-2][1]+f[y][x-2][3])+y*f[y][x-2][0])%mod;
	}
//	printf("%d %d %d:%lld\n",x,y,k,f[x][y][k]);
	return f[x][y][k];
}
int main(){
	N=qd(),M=qd();
	memset(f,-1,sizeof(f));
	printf("%lld\n",dfs(N+1,M,0));
	return 0;
}
```

---

## 作者：Gerald_Chen (赞：6)

在[大佬](https://www.luogu.org/space/show?uid=118274)的帮助下解决了此题，先orz为敬。

---
将题意提炼一下。这道题原本是在问：**在一个$n\times m$的棋盘中放置棋子，使任意行与任意列的棋子数均不超过2个的方案数。**

原本想得比较复杂。主要是看到标签中有一条状压，就情不自禁地想用每一行的棋子放置状态DP，但结果可想而知。

忽然有了一点灵感：题目只要求每行每列的**棋子个数**满足一定条件，对棋子究竟是怎么放的没有要求。换句话说，一个合法状态的棋盘满足这样一条性质：**任意交换棋盘的两列或两条，所得的新棋盘与原棋盘状态等效。**

所以在DP时仅需考虑**每行所放置棋子的个数与原状态每列所放置棋子的个数**（因为这个信息将影响新一行棋子的位置）。

> **大胆猜测，无需证明。~~随手一交，全部爆零。~~** _——大佬_

大佬想到了DP时进行转移的状态。数组```f[i][j][k]```表示第$i$行棋盘已经放置完毕，当前所有已扩展行中有$j$列棋盘的棋子数是$0$，$k$列棋盘的棋子数是$1$（只有$0$和$1$的列能继续放棋子）时的方案数。

那么对于第$i+1$行，有这么几个选择：
1. 一个棋子都不放。  
   - 这样的话，$i+1$行的方案数加上第$i$行的就好了。  
   - ```cpp
     f[i + 1][j][k] += f[i][j][k];
     ```
2. 放一个棋子。
   - 这个棋子只能放在$0$个的$j$列$(j>0)$或$1$个的$k$列$(k>0)$中。
   - 放下棋子以后，列数将发生变化。若放在$0$列，$0$列个数减一，$1$列个数加一；若放在$1$列，$1$列个数减一（$2$列个数加一，不过不用反映在数组中）。
   - $i+1$行状态加上$i$行状态乘以放置方法数。
   - ```cpp
     if (j != 0)
         f[i + 1][j - 1][k + 1] += f[i][j][k] * j;
     if (k != 0)
         f[i + 1][j][k - 1] += f[i][j][k] * k;
     ```
3. 放两个棋子。
   1. 两个棋子都放在$0$列$(j>1)$。
      - 放置的方法数有$C_j^2$，即$\frac{j(j-1)}{2}$种。
      - 放下棋子后，$0$列减少$2$，$1$列增加$2$。
      - ```cpp
    	if (j > 1)
            f[i + 1][j - 2][k + 2] += f[i][j][k] * (j - 1) * j / 2;
        ```
   2. 两个棋子都放在$1$列$(k>1)$。
      - 同上。
   3. 一个棋子放在$0$列，一个棋子放在$1$列$(j>0)$。
      - 从代码来看，原来的状态```[j][k]```在放置后变为```[j-1][k-1+1]```即```[j-1][k]```，所以对$k$的大小没有要求。
      - ```cpp
        if (j != 0)
            f[i + 1][j - 1][k] += f[i][j][k] * j * k;
		``` 


初始状态为```f[1][m][0]=1```。

DP部分思路就是这样的。最后将答案统计起来即可。

**注意开```long long```，注意模。**

希望能给各位同学一点帮助。共勉。

上代码：
```cpp
#include <cstdio>
#include <cstdlib>
using namespace std;
const long long MOD = 9999973;
long long f[105][105][105], ans;
int n, m;
inline void calc(long long& x)
{
    x %= MOD;
}
int main()
{
    scanf("%d%d", &n, &m);
    f[1][m][0] = 1;
    for (int i = 1; i <= n; ++i) {
        for (int j = 0; j <= m; ++j)
            for (int k = 0; k <= m - j; ++k) {
                //0 lain
                f[i + 1][j][k] += f[i][j][k], calc(f[i + 1][j][k]);
                //1 lain
                if (j != 0)
                    f[i + 1][j - 1][k + 1] += f[i][j][k] * j, calc(f[i + 1][j - 1][k + 1]);
                if (k != 0)
                    f[i + 1][j][k - 1] += f[i][j][k] * k, calc(f[i + 1][j][k - 1]);
                //2 lain
                if (j > 1)
                    f[i + 1][j - 2][k + 2] += f[i][j][k] * (j - 1) * j / 2, calc(f[i + 1][j - 2][k + 2]);
                if (k > 1)
                    f[i + 1][j][k - 2] += f[i][j][k] * (k - 1) * k / 2, calc(f[i + 1][j][k - 2]);
                if (j != 0)
                    f[i + 1][j - 1][k] += f[i][j][k] * j * k, calc(f[i + 1][j - 1][k]);
            }
    }
    for (int i = 0; i <= m; ++i)
        for (int j = 0; j <= m - i; ++j)
            ans += f[n + 1][i][j], calc(ans);
    printf("%lld", ans);
    return 0;
}
```

最后祝同学们RP++！

---

## 作者：Soulist (赞：6)

一开始看到题目以为是状压$dp$。。。

然而并不是。。。

仔细分析题面发现其实就是给定了每一行和每一列都不能有两个棋子的限制。

所以状态并不难想，记$dp_{i,j,k}$表示当前$dp$到第$i$行，有$j$列为两个，$k$列为一个。

不难发现其实转移的时候与我们前面的棋盘状态如何无关，实际上我们只关注有多少个1个的列，多少个2个的列。

然后考虑转移：

首先$dp_{i,j,k}$可以由 在第$i$行 一个 之前这一列 没有棋子 的位置 放置棋子得到。

即：

$$dp_{i,j,k} = dp_{i,j,k-1}*(m-j-(k-1))$$

类似的还有放置两个空(之前这一列没有棋子的位置)

$$dp[i][j][k] += dp[i - 1][j][k - 2] * ( m - j - k + 2 ) * ( m - j - k + 1 ) / 2$$

把一个放在之前这一列有一个棋子的位置：

$$dp[i][j][k] += dp[i - 1][j - 1][k + 1] * (k + 1)$$

类似的，仍然有放置两个在这一列之前有一个棋子的位置：

$$dp[i][j][k] += dp[i - 1][j - 2][k + 2] * ( k + 2 ) * ( k + 1 ) / 2$$

还有一个把一个放在空的，另一个放在有一个的：

$$dp[i][j][k] += dp[i - 1][j - 1][k] * k * ( m - j - k + 1 )$$

注意转移的边界即可：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 100 + 5;
#define int long long
#define rep( i, s, t ) for( int i = s; i <= t; ++ i )
int n, m, dp[N][N][N];
#define mod 9999973
signed main()
{
	cin >> n >> m;
	dp[0][0][0] = 1;
	rep( i, 1, n )
	    rep( j, 0, m )
	        rep( k, 0, m - j ) {
	        	if( j + k > m ) break;
	            dp[i][j][k] = dp[i - 1][j][k];
	            
                if( k + 1 <= m && j >= 1 )  
                	dp[i][j][k] += dp[i - 1][j - 1][k + 1] * (k + 1); //把一个放在一列的后面 
	            
                dp[i][j][k] %= mod;
	            
                if( k + 2 <= m && j >= 2 )  
                	dp[i][j][k] += dp[i - 1][j - 2][k + 2] * ( k + 2 ) * ( k + 1 ) / 2;//把两个放在两个一列的后面 
	            
                dp[i][j][k] %= mod;
				
                if( k >= 1 ) 
                	dp[i][j][k] += dp[i - 1][j][k - 1] * ( m - j - k + 1 );//把一个放在空的位置 
	            
                dp[i][j][k] %= mod;
				
                if( k >= 2 ) 
                	dp[i][j][k] += dp[i - 1][j][k - 2] * ( m - j - k + 2 ) * ( m - j - k + 1 ) / 2;//把两个放在空的位置 
	            
                dp[i][j][k] %= mod;
				
                if( j >= 1 && k <= m ) 
                	dp[i][j][k] += dp[i - 1][j - 1][k] * k * ( m - j - k + 1 );//把一个放在一列的位置，另一个放在空的位置 
	       		
                dp[i][j][k] %= mod;
			}
	int ans = 0;
	rep( i, 0, m )
		rep( j, 0, m ) {
			if( i + j > m ) break; 
			ans += dp[n][i][j];
			ans %= mod;
		}
	printf("%lld", ans % mod);
	return 0;
}

```

---

## 作者：重回巅峰！ (赞：5)

发个题解，但是我并不打算发程序，下面的程序够详细了，我只是补个思想讲解

F[I][J][K] 表示已经放了前I行，其中有J列是只放了1个炮，有K列放了2个炮的方案数

有：
1〉如果第I行不放，有

F[i][J][K]：=F[I][J][K]+F[I-1][J][K]；

2〉如果第I行放一个棋子，且这个棋子放在已经放了一个棋子的列上，有

F[I][J][K]：=F[I][J][K]+F[I-1][J+1][K-1]\*（J+1）；

3〉如果第I行放一个棋子，且这个棋子放在已放了0个棋子的列上，有：

F[I][J][K]：=F[I][J][K]+F[I-1][J-1][K]\*（M-J-K+1）；

4〉如果第I列放两个棋子，且两个棋子都放在空列上，有：

F[I][J][K]：=F[I][J][K]+F[i-1][J-2][K]\*（M-J+2-K）；

5〉如果第I列放两个棋子，且两个棋子一个放在已经放了一个棋子的列，另一个放在放了0个棋子的列。有

F[I][J][K]：=F[I][J][K]+F[I-1][J+2][K-2]\*（J+2）\*（J+1）DIV 2 ；

6〉如果第I列放两个棋子，且这两个棋子都放在已经放过1个棋子的列上，有：

F[I][J][K]：=F[I][J][K]+F[I-1][J][K-1]\*J\*（M-J-K+1）；

7〉 F[I][J][K] 的每次累计必须mod 9999973；


没了。。。。。。。。。。


---

## 作者：GoldenPotato137 (赞：4)

非markdown连接(可能会美观一些)[蒟蒻博客](http://www.cnblogs.com/GoldenPotato/p/9009040.html)



------------

### Solution

看到这题,我们不妨先看一下数据范围

30pt:n,m<=6

显然搜索,直接爆搜水过

#### 复杂度O(n^m(吧))




.

.



 

50pt: n<=100,m<=8

是状压/网络流的复杂度

当然,这题显然是状压

由题可以得出一个很显然但很重要的废话:**每行每列只能放0~2个棋子**

因此,我们可以考虑写一个3进制的状压DP

**设f[i][j]表示第 i 行,每一列的具体情况以三进制的表达形式存在j里 的方案数**

转移也很显然

分类转移一下

当前这一行放了0个棋子 f[i][j]+=f[i-1][j]

当前这一行放了1个棋子, 枚举一下有可能放的位置k f[i][j]+=xigema f[i-1][k]

当前这一行放了2个棋子 ,枚举一下那两个有可能放的位置,最后表达成k f[i][j]+=xigema f[i-1][k]


初始化f[0][0]=1,最后答案为 xigema f[n][i]

#### 复杂度O(n*(3^m))

.

.

 

 

100pt:n,m<=100

其实之前50分做法离正解已经很接近了

再仔细思考(手玩)一下,**就会发现答案与每一列棋子摆放位置无关**

也就是说我们根本就没必要具体记录每一列的具体情况,**只需要记录有多少列放了1个棋,有多少列放了2个棋**

**设f[i][j][k]表示第i行时有j列放了1个棋,有k列放了2个棋
**

然后转移和上面基本上没什么区别,具体请看代码

 

初始化f[0][0][0]=1.答案为 xigema f[n][i][j]

#### 复杂度O(n*m*m)



------------

### Code
```cpp
//Luogu P2051 [AHOI2009]中国象棋
//May,8th,2018
//状压转网格DP
#include<iostream>
#include<cstdio>
using namespace std;
long long read()
{
	long long x=0,f=1; char c=getchar();
	while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
	while(isdigit(c)){x=x*10+c-'0';c=getchar();}
	return x*f;
}
const int N=100+10;
const int poi=9999973;
long long f[N][N][N];
int n,m;
int main()
{
	n=read(),m=read();
	
	f[0][0][0]=1;
	for(int i=1;i<=n;i++)
		for(int j=0;j<=m;j++)
		{
			int MAX_K=m-j;
			for(int k=0;k<=MAX_K;k++)
			{
				f[i][j][k]+=f[i-1][j][k];//放0个棋子
				if(j>=1) f[i][j][k]=(f[i][j][k]+f[i-1][j-1][k]*(m-k-j+1))%poi;//放1个棋子,且放在原本为0的列
				if(k>=1) f[i][j][k]=(f[i][j][k]+f[i-1][j+1][k-1]*(j+1))%poi;//放1个棋子,且放在原本为1的列
				if(j>=2) f[i][j][k]=(f[i][j][k]+f[i-1][j-2][k]*(((m-j-k+1)*(m-j-k+2))/2))%poi;//放2个棋子,且都放在原本为0的列
				if(j>=1 and k>=1) f[i][j][k]=(f[i][j][k]+f[i-1][j][k-1]*(j*(m-j-k+1)))%poi;//放2个棋子,一个放在0,一个放在1
				if(k>=2) f[i][j][k]=(f[i][j][k]+f[i-1][j+2][k-2]*(((j+1)*(j+2))/2))%poi;//放2个棋子,都放在原本为1的列
			}
		}
		
	long long ans=0;
	for(int i=0;i<=m;i++)
	{
		int MAX_J=m-i;
		for(int j=0;j<=MAX_J;j++)
			ans=(ans+f[n][i][j])%poi;
	}
	printf("%lld",ans);
	return 0;
}

```

---

## 作者：Zarinopl (赞：3)

记忆化.wav

一道多段图（？）dp。

根据炮的性质（我在写点啥）每行、每列不可能放超过两个，可以搜索枚举每行的放法

但是

对后面的行来说，前面放的炮放在哪一列是没有什么关系的。每行可以放2个/1个/0个，只与有多少行放了炮及放了几个有关。比如一行两个炮不管放在哪两列都只意味着这两列少了一个炮的位子（应该很好理解，看代码处理）

就可以设计状态dp[l][r1][r0]

l为当前考虑的行（以下行都已计算）；r1为目前放了1个炮的列数；r0为目前还没放炮的列数

（如果记忆化搜索）目标状态为dp[1][0][m]。

于是上代码
```cpp
#define int long long
const int mod=9999973;
int n,m;
int dp[105][105][105];
//1D:Line
//2D:Row of 1
//3D:Row of 0
int srh(const int& l,const int& r1,const int& r0){
	int& ans=dp[l][r1][r0];
	if(ans) return ans;
	if(l==n+1) return ans=1;//边界
	//Put 0:
	ans+=srh(l+1,r1,r0);//这一行不放炮，只有一种情况
	//Put 1:
	if(r1) ans+=r1*srh(l+1,r1-1,r0);//向只有一个炮的列放一个炮，方案数为r1
	if(r0) ans+=r0*srh(l+1,r1+1,r0-1);//向没炮的列放一个炮，方案数r0
	//Put 2:注意这里有可能爆int
	if(r1>1) ans+=r1*(r1-1)/2*srh(l+1,r1-2,r0);//选择只有一个炮的列放两个炮，方案数为r1中选2即r1*(r1-1)/2
	if(r0>1) ans+=r0*(r0-1)/2*srh(l+1,r1+2,r0-2);//选择没有炮的列放两个炮，方案数为r0中选2即r0*(r0-1)/2 
	if(r1&&r0) ans+=r1*r0*srh(l+1,r1,r0-1);//只有一炮列和没炮列各选一放炮，方案数为r1*r0
	return ans%=mod;//这里取模，就不用在上面取模了
}
signed main(signed argc,char** argv,char** envp){
	scanf("%lld%lld",&n,&m);
	printf("%lld",srh(1,0,m));
    exit(0);
}
```
如果没有注释这道题也就半KB

而且我觉得比递推好理解多了.png

---

## 作者：QWsin (赞：3)

**
唉又是一道省选DP神题  还带组合数= =

我手玩几组数据之后发现行列貌似可以交换的

然后还是不会做  只好求助于各神犇  题解比较少= =凑个热闹

dp[i][j][k]表示在前i行中有j列已经有2个  有k列已经有1个  那么0的个数就是m-j-k个


转移方程看代码


这一行可以不放

那么直接加上dp[i-1][j][k]

放一个的话

可以把一列0变成1

可以把一列1变成2

放两个的话

可以把两列0变成1

可以把两列1变成2

还有 可以把一列0变成1  再把**另外**一列1变成2

关于组合数要说一下。。

放一个好说  直接乘1或0的个数完事（加在任意一个上面都是可以的）

放两个的话  前两个也好弄  直接C（n，2）  （n为可选个数）

最后一个呢  先乘上原来0的个数  再乘上原来1的个数  乘法原理嘛= =

试炼场刷到到这里的应该都懂组合数的吧 （否则请百度）


**
```cpp

#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int maxn=100+10;
const int MOD=9999973;
const int INF=(1<<30);
typedef long long ll;

int n,m;
ll dp[maxn][maxn][maxn];//依次为行 2级列 1级列 

ll C(ll x){return x*(x-1)/2;}

void init_data()
{
    cin>>n>>m;
//    dp[1][0][2]=dp[1][0][1]=dp[1][0][0]=1; 
    dp[0][0][0]=1;
}

ll cal()
{
    ll ret=0;
    for(int j=0;j<=m;j++)
    {
        for(int k=0;k<=m-j;k++)
          ret+=dp[n][j][k];
        ret%=MOD;
    }
    return ret;  
}

void debug()
{
    for(int i=1;i<=n;i++)
      for(int j=0;j<=m;j++)
        for(int k=0;k<=m-j;k++)
          printf("dp[%d][%d][%d]=%lld\n",i,j,k,dp[i][j][k]);
}

int main()
{
//    freopen("std.in","r",stdin);
//    freopen("my.out","w",stdout);
    init_data();
    for(int i=1;i<=n;i++)
      for(int j=0;j<=m;j++)
        for(int k=0;k<=m-j;k++)
        {
            // no chesses
            dp[i][j][k]+=dp[i-1][j][k];
            //one chess 
             if(j>=1)  dp[i][j][k]+=dp[i-1][j-1][k+1]*(k+1);    // 1 to 2 *1 
             if(k>=1)  dp[i][j][k]+=dp[i-1][j][k-1]*(m-j-k+1);  // 0 to 1 *1
              //two chesses
             if(j&&k)  dp[i][j][k]+=dp[i-1][j-1][k]*(m-j-k+1)*k;// 0 to 1 and 1 to 2 *1
             if(j>=2)  dp[i][j][k]+=dp[i-1][j-2][k+2]*C(k+2);   // 1 to 2 *2
            if(k>=2)  dp[i][j][k]+=dp[i-1][j][k-2]*C(m-j-k+2); // 0 to 1 *2
            dp[i][j][k]%=MOD;
        }
//    debug();
    printf("%lld",cal());
    return 0;
}

```

---

## 作者：_Sein (赞：1)

题目大意是这样的:

**无论行与列，都必须满足炮的数量**$\le 2$

所以我们需要设计一个方程来满足这两个条件。

**状态可以描述列的正确性**

**转移可以描述行的正确性**

因此就有状态$f_{i,j,k}$表示前$i$行，有$j$列有一个炮，有$k$列有两个炮，有$m-j-k$列没有炮的方案数。

转移可以描述成，第$i$行不放，放一个，放两个。

具体请自行实现。
```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#include<cmath>
#define ll long long
#define gc getchar()
using namespace std;
const int N=105,mod=9999973;
template<class o>
inline void qr(o &x)
{
	x=0;char c=gc;
	while(c<'0'||c>'9')c=gc;
	while(c>='0'&&c<='9'){x=x*10+(c^48);c=gc;}
}
void qw(ll x)
{
	if(x<0)putchar('-'),x=-x;
	if(x/10)qw(x/10);
	putchar(x%10+48);
}
ll f[N][N][N];
int main()
{
	int n,m;qr(n),qr(m);
	f[0][0][0]=1;
	for(int i=1;i<=n;i++)
		for(int j=0;j<=m;j++)
			for(int k=0;k<=m-j;k++)
			{
				int z=(m-j-k);
				f[i][j][k]=f[i-1][j][k];
				if(j>=1)f[i][j][k]+=f[i-1][j-1][k]*(z+1);
				if(k>=1)f[i][j][k]+=f[i-1][j+1][k-1]*(j+1);
				if(k>=1)f[i][j][k]+=f[i-1][j][k-1]*j*(z+1);
				if(k>=2)f[i][j][k]+=f[i-1][j+2][k-2]*((j+2)*(j+1)/2);
				if(j>=2)f[i][j][k]+=f[i-1][j-2][k]*((z+2)*(z+1)/2);
				f[i][j][k]%=mod;
			}
	ll ans=0;
	for(int j=0;j<=m;j++)
		for(int k=0;k<=m-j;k++)
			ans=(ans+f[n][j][k])%mod;
	qw(ans);puts("");
	return 0;
}
```


---

## 作者：cscy (赞：1)

这个题比较有价值的一点在于状态设计得十分奇葩。一般这种棋盘dp状态设计的核心思想都是记录位置，去想办法表示每一个棋子的位置信息，甚至不惜状压穷举。

但是这道题就反其道而行之，要求设计成记录数量的状态。对于这种比较抽象和陌生的转移方程，为了防止转移出错，当然首选记忆化搜索啦！~~蒟蒻不会限制边界~~

而且也不知为何，这题卡int

```

#include <iostream>
#include <cstdio>
#include <memory.h>
#define rep(i,a,b) for(int i=a; i<=b; i++)
#define dec(i,a,b) for(int i=a; i>=b; i--)
#define INF 0x3f3f3f3f
#define p 9999973
#define int long long

using namespace std;

int n,m;
int dp[110][110][110][2];
int c[110][110];

int C(int a, int b){
	if(b<0 || a>b)return 0;
	if(a==0 || b==0)return 1;
	if(a==b)return 1;
	if(c[a][b])return c[a][b];
	return c[a][b] = C(a, b-1) + C(a-1,b-1);
}

int dfs(int h, int n1, int n2, int n0){
	//printf("%d %d %d %d\n",h,n1,n2,n0);
	if(h==0 && n1 == 0 && n2 == 0 && n0 == m)return 1;
	if(!(n1 >= 0 && n2 >= 0 && n0 >= 0 && h >= 0))return 0;
	if(!(n1 <= m && n2 <= m && n0 <= m && h <= n))return 0;
	if(!(n1 + n2 + n0 == m))return 0;
	if(dp[h][n1][n2][0])return dp[h][n1][n2][1];
	
	int sum = 0;
	
	sum += dfs(h-1, n1, n2, n0) % p;
	
	sum += (dfs(h-1, n1+1, n2-1, n0) % p) * (n1+1);
	sum %= p;
	sum += (dfs(h-1, n1-1, n2, n0+1) % p) * (n0+1);
	sum %= p;
	
	sum += (dfs(h-1, n1-2, n2, n0+2) % p) * (C(2,n0+2) % p);        //00
	sum %= p;
	sum += (dfs(h-1, n1, n2-1, n0+1)%p) * ((n0+1)*(n1) % p);        //01
	sum %= p;
	sum += (dfs(h-1, n1+2, n2-2, n0)%p) * (C(2,n1+2)%p);            //11
	sum %= p;
	
	dp[h][n1][n2][0] = 1;
	dp[h][n1][n2][1] = sum % p;
	return sum;
}

void debug(){
	rep(i,0,n){
		rep(j,0,m){
			rep(k,0,m){
				cout << dp[i][j][k][1] << " ";
 			}
 			cout << endl;
		}
		cout << endl << endl;
	}

}

signed main(){
	scanf("%d %d",&n,&m);
	int res = 0;
	rep(j,0,m){
		rep(k,0,m){
			res += dfs(n,j,k,m-j-k);
			res %= p;
		}
	}
	//debug();
	cout << res << endl;
	return 0;
}

/*
dfs(int h, int n1, int n2, int n0){
	1. n1 >= 0 && n2 >= 0 && n0 >= 0 && h >= 0
	2. n1 <= m && n2 <= m && n0 <= m && h <= n
	3. n1 + n2 + n3 == m
	
	dfs(h-1, n1, n2, n0);
	dfs(h-1, n1+1, n2-1, n0);
	dfs(h-1, n1-1, n2, n0+1);
	
	dfs(h-1, n1-2, n2, n0+2) * c(2,n0+2);            //00
	dfs(h-1, n1, n2-1, n0+1) * (n0+1)*(n1-1);        //01
	dfs(h-1, n1+2, n2-2, n0) * c(2,n1+2);            //11
}
*/
```



---

## 作者：Sweetness (赞：1)

是道好题.jpg√

戳个链接吧：[Luogu P2051 [AHOI2009]中国象棋](https://www.luogu.org/problem/P2051)



### SOLUTION：

首先一定不要被你谷的标签迷惑

![](https://cdn.luogu.com.cn/upload/image_hosting/hakfl4u9.png)

这道题状压撑死算是拿部分分的一个方法（而且即使数据范围很小咱也没想明白怎么状压

这道题数据范围显然不是可以状态压缩的范围

![](https://cdn.luogu.com.cn/upload/image_hosting/su84wppp.png)

还是老老实实考虑正常dp吧：

首先N,M<=100，那么我们可以依据[【五一qbxt】day3 动态规划](https://www.cnblogs.com/zhuier-xquan/p/10794222.html)中，大致推断这是一道$O(N^3)$的做法的题~~（事实也是这样的~~

首先分析可以知道，一行或一列中，最多有2个炮~~要不然肯定会互相攻击~~

然后这个题的状态就感觉很难想

我们设$dp[i][x][y]$表示前i行，有x列的炮的数量为1，y列炮的数量为2（当然剩下的m-x-y列炮的数量为0）时的方案数；

考虑初始只有一行的状态：

显然第一行有三种放法：

1. 不放任何炮，此时方案数为1；$dp[1][0][0]=1$
2. 放一个炮，那么m个位置每个位置都有可能，方案数为m $dp[1][1][0]=m$
3. 放两个炮，这样的方案数应该是$C _m^2$ $dp[1][2][0]=C_m^2$

这也就是初始的状态（~~反正咱是这么写的~~

然后考虑转移：

对于$dp[i][x][y]$

有以下n种可能：

1. 第i行不放“炮“，那么$dp[i][x][y]+=dp[i-1][x][y]$ //有1个棋子的列和有2个棋子的列显然是不改变的
2. 第i行放一个“炮”，那么又分两种可能：
   1. 未放这个棋子的时候，所在一列是空的。那么显然放上这一个棋子之后，炮的数量为1的列会增加1，因此第i-1列的炮的数量为1的列应该是x-1,那么当为第i-1行时，空行的数量为（m-(x-1)-y），我们可以选择任意一个空行操作， 所以$dp[i][x][y]+=dp[i-1][x-1][y]*(m-y-x+1)$
   2. 未放这个棋子的时候，所在的一列已经有一个棋子了。如果放上这一个棋子，那么炮的数量为1的列会减少1，炮的数量为2的列会增加1，因此第i-1行炮的数量为1的列应该是有x+1，炮的数量为2的列应该为y-1，而符合所在一列已经有一个棋子的列数有x+1列，因此$dp[i][x][y]+=dp[i-1][x+1][y-1]*(x+1)$
3. 第i行放两个“炮”，分为三种可能：
   1. 之前的位置是空的。放上棋子后，增加了两个炮的数量为1的列，炮的数量为2的列并没有变化，而选择这两个空行的可能的方案数为$C_{m-y-x+2}^2$，因此$dp[i][x][y]+=dp[i-1][x-2][y]*C_{m-y-x+2}^2$
   2. 之前的位置一个是空一个有棋子。我们仔细推算一下，可以推出i-1的dp状态：$dp[i-1][x][y-1]$而位置的选择为：（m-y-x+1）*x   (空行数量 *炮的数量为1的列数量)，那么$dp[i][x][y]+=dp[i-1][x][y-1] * (m-y-x+1) * x$
   3. 之前的位置都是有棋子的。也就是说，放上棋子之后，炮的数量为1的列减少了2，炮的数量为2的列增加了2，然后符合条件的组合有：$C_{x+2}^2$，则$dp[i][x][y]+=dp[i-1][x+2][y-2]*C_{x+2}^2$

当然以上所有都不能数组越界的，所以要判断x和y的值是否>0,>1；

另外在循环时，因为一共只有m列，因此i+j的值要<=m，所以可以直接将y从m-x开始循环到0而不用从0~m都循环一遍；

### CODE：

```cpp
#include<bits/stdc++.h>

using namespace std;

inline int read() {
	int ans=0;
	char last=' ',ch=getchar();
	while(ch>'9'||ch<'0') last=ch,ch=getchar();
	while(ch>='0'&&ch<='9') ans=(ans<<1)+(ans<<3)+ch-'0',ch=getchar();
	if(last=='-') ans=-ans;
	return ans;
}
const int mod=9999973;
int n,m;
int dp[110][110][110];

long long C(int m,int k) {
	if(m<k) return 0;
	long long ans=1;
	for(int i=m;i>m-k;i--)
		ans=ans*i;
	long long fm=1;
	for(int i=k;i>=2;i--) 
		fm=fm*i;
	ans/=fm;
	return ans%mod;
}

int main() {
	n=read();
	m=read();
	dp[1][0][0]=1;
	dp[1][1][0]=m;
	dp[1][2][0]=C(m,2);
	for(int i=2;i<=n;i++) {
		for(int x=0;x<=m;x++) {
			for(int y=m-x;y>=0;y--) {
				dp[i][x][y]=dp[i-1][x][y];
				if(x>0) 
					dp[i][x][y]=(dp[i][x][y]+dp[i-1][x-1][y]%mod*(m-y-x+1)%mod)%mod;
				if(y>0) {
					dp[i][x][y]=(dp[i][x][y]+dp[i-1][x][y-1]%mod*(m-x-y+1)%mod*x%mod)%mod;
                    dp[i][x][y]=(dp[i][x][y]+dp[i-1][x+1][y-1]%mod*(x+1)%mod)%mod;
                }
                if(x>1) 
					dp[i][x][y]=(dp[i][x][y]+dp[i-1][x-2][y]%mod*C(m-y-x+2,2)%mod)%mod;
				if(y>0)
					
				if(y>1) 
					dp[i][x][y]=(dp[i][x][y]+dp[i-1][x+2][y-2]%mod*C(x+2,2)%mod)%mod;
			}
		}
	}
	long long ans=0;
	for(int x=0;x<=m;x++) 
		for(int y=m-x;y>=0;y--) 
			ans=(ans+dp[n][x][y])%mod;
	printf("%lld",ans);
	return 0;
}
```




---

## 作者：YZL11111 (赞：1)

## 【题目描述】
这次小可可想解决的难题和中国象棋有关，在一个N行M列的棋盘上，让你放若干个炮（可以是0个），使得没有一个炮可以攻击到另一个炮，请问有多少种放置方法。大家肯定很清楚，在中国象棋中炮的行走方式是：一个炮攻击到另一个炮，当且仅当它们在同一行或同一列中，且它们之间恰好 有一个棋子。你也来和小可可一起锻炼一下思维吧！

## 【输入格式】
一行包含两个整数N，M，之间由一个空格隔开。

## 【输出格式】
总共的方案数，由于该值可能很大，只需给出方案数模9999973的结果。

## 【解题思路】
由于每行或每列至多只能放置两个棋子，对每行进行分类讨论，总共三种情况

1.不放   
2.放一个   
3.放两个

对于情况一那么本行的放置方法数为上一行方法数

对于情况二，我们可以选择在已经放置一个棋子或是没有放置棋子的列上放置一个棋子

对于情况三

1.在两个已经放置棋子的列上放置棋子          
2.在已经放置一个棋子和未放置棋子的列上分别放置一个棋子           
3.在两个未放置棋子的列上放置棋子      

则可以使用三维数组dp[i][j][k]表示前i行有j行放置了一个棋子，有k行放置了两个棋子，那么对于每种情况，其状态转移方程为

（注意边界条件）

```cpp
	dp[i][j][k] = (dp[i][j][k] + dp[i - 1][j][k]) % mod;  //不放
	if (k >= 1)dp[i][j][k] = (dp[i][j][k] + (dp[i - 1][j + 1][k - 1] * (j + 1) % mod)) % mod;  //在已经放置一个棋子列上放置一个棋子
	if (j >= 1)dp[i][j][k] = (dp[i][j][k] + (dp[i - 1][j - 1][k] * (m - j - k + 1) % mod)) % mod;//在没有放置棋子的列上放置一个棋子
	if (k >= 2)dp[i][j][k] = (dp[i][j][k] + (dp[i - 1][j + 2][k - 2] * ((j + 2) * (j + 1) / 2) % mod)) % mod;//在两个已经放置棋子的列上放置棋子
	if (k >= 1)dp[i][j][k] = (dp[i][j][k] + (dp[i - 1][j][k - 1] * j * (m - j - k + 1) % mod)) % mod;//在已经放置一个棋子和未放置棋子的列上分别放置一个棋子
	if (j >= 2)dp[i][j][k] = (dp[i][j][k] + ((dp[i - 1][j - 2][k] * ((m - j - k + 2) * (m - j - k + 1) / 2)) % mod)) % mod;//在两个未放置棋子的列上放置棋子
```

注意取模溢出问题~~（我选择开long long）~~

## 【AC代码】
```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
typedef long long ll;
const ll mod = 9999973;
ll n, m;
ll dp[110][110][110];
int main()
{

	scanf("%lld%lld", &n, &m);
	dp[0][0][0] = 1;
	for (register ll i = 1; i <= n; ++i)
	{
		for (register ll j = 0; j <= m; ++j)
		{
			for (register ll k = 0; k <= m - j; ++k)
			{
				dp[i][j][k] = (dp[i][j][k] + dp[i - 1][j][k]) % mod;
				if (k >= 1)dp[i][j][k] = (dp[i][j][k] + (dp[i - 1][j + 1][k - 1] * (j + 1) % mod)) % mod;
				if (j >= 1)dp[i][j][k] = (dp[i][j][k] + (dp[i - 1][j - 1][k] * (m - j - k + 1) % mod)) % mod;
				if (k >= 2)dp[i][j][k] = (dp[i][j][k] + (dp[i - 1][j + 2][k - 2] * ((j + 2) * (j + 1) / 2) % mod)) % mod;
				if (k >= 1)dp[i][j][k] = (dp[i][j][k] + (dp[i - 1][j][k - 1] * j * (m - j - k + 1) % mod)) % mod;
				if (j >= 2)dp[i][j][k] = (dp[i][j][k] + ((dp[i - 1][j - 2][k] * ((m - j - k + 2) * (m - j - k + 1) / 2)) % mod)) % mod;
			}
		}
	}
	ll ans = 0;
	for (register int i = 0; i <= m; ++i)
	{
		for (register int j = 0; j <= m; ++j)
		{
			ans = (ans + dp[n][i][j]) % mod;
		}
	}
	printf("%lld\n", ans);
	return 0;
}
```


---

## 作者：Uniecho1 (赞：1)

# 不可能是状压，这辈子都不会是状压

开玩笑呢，3^100的状压？
~~有这种想法的自己去厕所熏陶一下~~

好了熏陶完了，我们可以发现，**不用关心棋子是放哪里的，只要用乘法原理就可以解决这个问题**

所以只需要**以当前行数（cur）、当前空列的数量（u）、当前有一个炮的列的数量（v）以及当前有两个炮的列的数量（w）（当然其实就等于M-u-v）为状态**来一发**记搜**就可以了！

当然记得开个longlong不然可能只有40pts（别问我怎么知道的），因为u* v* w还是很有可能溢出的

好了接下来很简单了（具体解释见代码）
```cpp
#include<bits/stdc++.h>
using namespace std;

long long N,M,f[105][105][105];

long long dp(long long cur,long long u,long long v,long long w){
	if(cur==N+1)return 1;//出了一组解
	if(f[cur][u][v])return f[cur][u][v];//记搜
	long long ans=dp(cur+1,u,v,w)%9999973;//不放
	if(u>0)ans+=dp(cur+1,u-1,v+1,w)%9999973*u%9999973;//放在一个空列上
	if(v>0)ans+=dp(cur+1,u,v-1,w+1)%9999973*v%9999973;//放在有一个炮的列上
    //以上只放一个棋子，下面是放两个的
	if(u>0&&v>0)ans+=dp(cur+1,u-1,v,w+1)%9999973*u*v%9999973;//一个放在空列，一个放在单炮列
	if(u>1)ans+=dp(cur+1,u-2,v+2,w)%9999973*u*(u-1)/2%9999973;//放两个空列，记得除2去重
	if(v>1)ans+=dp(cur+1,u,v-2,w+2)%9999973*v*(v-1)/2%9999973;//放两个单炮列，同上去重
	f[cur][u][v]=ans%9999973;
	return f[cur][u][v];
}

int main(){
	scanf("%lld%lld",&N,&M);
	printf("%lld",dp(1,M,0,0)%9999973);
	return 0;
}
```
于是就这么结束了、、、

转身抱起狂三百米冲刺闪人（雾）

---

## 作者：Sym_Je (赞：1)

       这又是一道dp题     
       
   [中国象棋](https://www.luogu.org/problemnew/show/P2051#sub)    
   
   这道题其实就是找转移比较难，我们可以发现只要我们一行放少于等于2个棋子，就可以，所以我们就只考虑每一列，而每一行放少于等于2个，再转移就好咯。    
        
  我们开始转移方程，这里一共就有4种状态，就是第几行，放了0个棋的列数有几个，放了1个棋子列的个数，两个棋子列的个数。     
  我们发现可以省略后三个种的一个，只要把总数一减另外两个的值就好咯，然后开始分类讨论。       
  
  
  
 ```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;

long long n,m;

long long dp[200][200][200];

const long long mod=9999973;

int main()
{
    scanf("%lld%lld",&n,&m);
    dp[0][0][0]=1;
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<=m;j++)
        {
            for(int k=0;k+j<=m;k++)
            {
                dp[i+1][j][k]=(dp[i][j][k]+dp[i+1][j][k])%mod;
                //不放 
                dp[i+1][j+1][k]=(dp[i+1][j+1][k]+((m-k-j)*dp[i][j][k])%mod)%mod;
                //放在一列上没有炮的一列上 放1 
                if(j>=1) dp[i+1][j-1][k+1]=(dp[i+1][j-1][k+1]+(j*dp[i][j][k]))%mod;
                //在一列上有一个炮的一列上 放1 
                if(j>=2) dp[i+1][j-2][k+2]=(dp[i+1][j-2][k+2]+((j*(j-1)/2)*dp[i][j][k])%mod)%mod;
                // 分在有1炮的 放1 
                if(m-j-k>=2) 
                dp[i+1][j+2][k]=(dp[i+1][j+2][k]+((m-j-k)*(m-j-k-1)/2*dp[i][j][k])%mod)%mod;
                // 分在在一列上有没有炮的一列上 放2
                if(j>=1) 
                dp[i+1][j][k+1]=(dp[i+1][j][k+1]+(j*(m-j-k)*(dp[i][j][k]))%mod)%mod;
                //分放一个 
            }
        }
    }
    long long ans=0;
    for(int i=0;i<=m;i++)
    {
        for(int j=0;j+i<=m;j++)
        {
            ans=(ans+dp[n][i][j])%mod;
        }
    }
    printf("%lld\n",ans);
    return 0;
}

```  


---

## 作者：i207M (赞：1)

## 题目总结

NxM的棋盘，每行每列放置少于等于2个的棋子，问方案数，取模；

## 数据范围

N，M<=100

## 解题思路

巧妙设计状态，$dp[i][j][k]$表示放了前i行，有j列是有1个棋子，有k列有2个棋子的方案数，讨论一波转移即可，具体看代码；

## 易错误区

~~我才没有把N当成M~~

## 代码展示

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<string>
#include<algorithm>
#include<vector>
#include<map>
#include<set>
#include<list>
#include<queue>
#include<stack>
#include<bitset>
#include<deque>
using namespace std;
#define ll long long
#define inf 0x3f3f3f3f
#define ri register int
#define il inline
#define fi first
#define se second
#define mp make_pair
#define pi pair<int,int>
#define mem0(x) memset((x),0,sizeof (x))
#define mem1(x) memset((x),0x3f,sizeof (x))
il char gc() {
    static const int BS = 1 << 22;
    static unsigned char buf[BS], *st, *ed;
    if (st == ed) ed = buf + fread(st = buf, 1, BS, stdin);
    return st == ed ? EOF : *st++;
}
#define gc getchar
template<class T>void in(T &x)
{
    x = 0; bool f = 0; char c = gc();
    while (c < '0' || c > '9') {if (c == '-') f = 1; c = gc();}
    while ('0' <= c && c <= '9') {x = (x << 3) + (x << 1) + (c ^ 48); c = gc();}
    if (f) x = -x;
}
#undef gc
void out(int x) {
    if (x < 0) putchar('-'), x = -x;
    if (x > 9) out(x / 10);
    putchar(x % 10 + '0');
}
#define int ll
#define N 110
#define md 9999973
il void mod(int &x) {
    while (x < 0) x += md;
    while (x >= md) x -= md;
}
int n, m;
int f[N][N][N]; // i -> line ; j -> one ; k -> two
int ans;
int c(int n) {
    return n * (n - 1) >> 1;
}
signed main() {
    in(n), in(m);
    f[0][0][0] = 1;
    for (ri i = 0; i < n; ++i) {
        for (ri j = 0; j <= m; ++j) {
            for (ri k = 0, t; j + k <= m; ++k) {
                t = f[i][j][k];
                mod(f[i + 1][j][k] += t);  // 不放
                if (j >= 1) mod(f[i + 1][j - 1][k + 1] += j * t % md); // 放1在j
                if (m - j - k >= 1) mod(f[i + 1][j + 1][k] += (m - j - k) * t % md); // 放1在空
                if (m - j - k >= 2) mod(f[i + 1][j + 2][k] += c(m - j - k) * t % md); // 放2在空
                if (m - j - k >= 1 && j >= 1) mod(f[i + 1][j][k + 1] += (m - j - k) * j % md * t % md); // 放1在空，放1在j
                if (j >= 2) mod(f[i + 1][j - 2][k + 2] += c(j) * t % md); // 放2在j
            }
        }
    }
    for (ri j = 0; j <= m; ++j) {
        for (ri k = 0; j + k <= m; ++k) {
            mod(ans += f[n][j][k]);
        }
    }
    /*for (ri i = 0; i <= n; ++i) {
        for (ri j = 0; j <= m; ++j) {
            for (ri k = 0; j + k <= m; ++k) {
                cout << i << j << k << " " << f[i][j][k] << endl;
                //printf("%d %d %d ,%lld \n", i, j, k, f[i][j][k]);
            }
        }
    }*/
    printf("%lld", ans);
    return 0;
}
/*
int f[N];
int find(int x){
    return x==f[x]?x:f[x]=find(f[x]);
}
bool cmpy(int x,int y){
    int fx=find(x),fy=find(y);
    if(fx==fy) return 0;
    if(fy>fx) f[fy]=fx;
    else f[fx]=fy;
    return 1;
}
*/
/*
int v[M], u[M], w[M], nx[M];
int cnt, head[N];
il void add(int uu, int vv, int ww) {
    u[++cnt] = uu, v[cnt] = vv, w[cnt] = ww, nx[cnt] = head[uu];
    head[uu] = cnt;
}
*/
/*
struct Edge {
    int u,v,w,nx;
    Edge() {}
    Edge(int uu,int vv,int ww,int nxt) {
        u=uu,v=vv,w=ww,nx=nxt;
    }
    friend bool operator<(const Edge& a,const Edge& b) {
        return a.w<b.w;
    }
} edge[M];
int cnt,head[M];
il void add(int u,int v,int w) {
    edge[++cnt]=Edge(u,v,w,head[u]);
    head[u]=cnt;
}
*/
```

---

## 作者：Xiefan_Guo (赞：0)

首先可以很容易看出**任意一行或者一列所放棋子数应该小于等于2**。所以有题解如下：

设 $f[i][j][k]$ 表示前 $i$ 行的棋子布局中有 $j$ 列放置一个棋子，$k$ 列放置两个棋子的棋子放置方案总数。对于第 $i + 1$ 行我们有：

* 不放置棋子：$f[i + 1][j][k] = f[i + 1][j][k] + f[i][j][k]$
* 放置一个棋子且放置在前 $i$ 行棋子数为 $0$ 的列：$f[i + 1][j + 1][k] = f[i + 1][j + 1][k] + f[i][j][k] * (m - j - k)$
* 放置一个棋子且放置在前 $i$ 行棋子数为 $1$ 的列：$f[i + 1][j - 1][k + 1] = f[i + 1][j - 1][k + 1] + f[i][j][k] * j$
* 放置两个棋子且均放置在前 $i$ 行棋子数为 $0$ 的列：$f[i + 1][j + 2][k] = f[i + 1][j + 2][k] + f[i][j][k] * C(m - j - k)$
* 放置两个棋子且一个放置在前 $i$ 行棋子数为 $0$ 的列，另一个放置在 $i$ 行棋子数为 $1$ 的列：$f[i + 1][j][k + 1] = f[i + 1][j][k + 1] + f[i][j][k] * (m - j - k) * j$
* 放置两个棋子且均放置在前 $i$ 行棋子数为 $1$ 的列：$f[i + 1][j - 2][k + 2] = f[i + 1][j - 2][k + 2] + f[i][j][k] * C(j)$

```
#include<bits/stdc++.h>

using namespace std;

const int maxn = 105;
const int mod = 9999973;
long long f[maxn][maxn][maxn];
int n, m;
long long ans;

int C(int x)
{
    return x * (x - 1) / 2;
}
int main()
{
    scanf("%d%d", &n, &m);
    f[0][0][0] = 1;
    for(int i = 0; i < n; i++){
        for(int j = 0; j <= m; j++){
            for(int k = 0; k + j <= m; k++){
                f[i + 1][j][k] = (f[i + 1][j][k] + f[i][j][k]) % mod;
                if(m - j - k > 0) f[i + 1][j + 1][k] = (f[i + 1][j + 1][k] + f[i][j][k] * (m - j - k)) % mod;
                if(j > 0) f[i + 1][j - 1][k + 1] = (f[i + 1][j - 1][k + 1] + f[i][j][k] * j) % mod;
                if(m - j - k > 1) f[i + 1][j + 2][k] = (f[i + 1][j + 2][k] + f[i][j][k] * C(m - j - k)) % mod;
                if(m - j - k > 0 && j > 0) f[i + 1][j][k + 1] = (f[i + 1][j][k + 1] + f[i][j][k] * (m - j - k) * j) % mod;
                if(j > 1) f[i + 1][j - 2][k + 2] = (f[i + 1][j - 2][k + 2] + f[i][j][k] * C(j)) % mod;
            }
        }
    }
    ans = 0;
    for(int j = 0; j <= m; j++){
        for(int k = 0; j + k <= m; k++){
            ans = (ans + f[n][j][k]) % mod;
        }
    }
    printf("%lld\n", ans);
    return 0;
}

```

---

## 作者：FREEH (赞：0)

## [【题目】](https://www.luogu.org/problem/P2051) 
![题目](https://cdn.luogu.com.cn/upload/pic/70477.png)

### 【题目大意】
- 一个(n,m)的棋盘，求最多放多少个炮

### 【解题思路】
- 分析炮的特点：
	1. 一行只能放0、1、2个
    1. 一列只能放0、1、2个
- 易得对于每一个特点建一个维，但是发现空间开不下
- 发现可以降维，对于其中一种情况，可以用列数减去另外两维求出
- 所以对于每一行，设$f[i][j][k]$表示前i行，还剩2个棋子可以放的列有j个，还剩1个棋子可以放的列有k个
- 对于每一行进行分类讨论
	1. 放0个
    2. 放1个
    	- 放还剩2个的
        - 还剩1个的
    3. 放2个
    	- 放还剩2个的+还剩一个的
        - 放两个还剩2个的
        - 放两个还剩一个的
- 然后再算出每一种情况的组合数，就可以求出答案

### 【解题反思】
- $if (j-2) ≠ if (j-2>=0)$！！！

### 【参考程序】
```cpp
#include<stdio.h>
typedef long long LL;
#define int LL
int n,m,ans,
	f[105][105][105];
void M(int &x)
{
	x%=9999973;
}
signed main()
{
	scanf("%lld%lld",&n,&m);
	f[0][m][0]=1;
	for (int i=0;i<n;i++)
	{
		for (int j=0;j<=m;j++)
		{
			for (int k=0;k<=m-j;k++)
			{
				M(f[i+1][j][k]+=f[i][j][k]);
				if (j>=1&&k+1<=m)
					M(f[i+1][j-1][k+1]+=f[i][j][k]*j);	
				if (j>=2&&k+2<=m)
					M(f[i+1][j-2][k+2]+=f[i][j][k]*(j*(j-1)/2));
				if (k>=1)
					M(f[i+1][j][k-1]+=f[i][j][k]*k);
				if (j>=1)
				{
					M(f[i+1][j-1][k+1-1]+=f[i][j][k]*j*k);
				}
				if (k>=2)
				{
					M(f[i+1][j][k-2]+=f[i][j][k]*(k*(k-1)/2));
				}
			}
		}
	}
	for (int i=0;i<=m;i++)
		for (int j=0;j<=m-i;j++)
			M(ans+=f[n][i][j]);
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：huanzi (赞：0)

学C++以来终于怼过了第一道紫题我真是嗨到不行啊！！！！！（以指凿颅ing）

首先我们要知道最基本的规则；每一行每一列的~~妻子~~棋子数不可以超过两个。最开始我们想到的便是玄学打表，但是在最大数据量为100x100的情况下就算除模都有792607个方案，而且除模的次数不下二十次，如果一个个方案打表的话必定会TLE。

那该怎么办呢？这时候我们就要将思维给逆转过来 （成步堂龙一脸）

我们所要求的仅仅是方案数（取模后的结果），也就是说我们可以试着在不求出各种方案具体方法的情况下直接得出方案数。

那么该怎么做才能做到只求方案数呢？答；开一个三位数组f[i][j][k]，表示做到第i行/列有j个列/行有一个~~妻子~~棋子，k列/行有两个棋子时的方案数。

之后就是对于方案的讨论，

    不放棋子的时候，我们直接继承上一行的方案数，即f[i][j][k]=f[i-1][j][k]

放一个棋子时有以下方案

    在有一个棋子的一列放，此时方案数f[i][j][k]+=f[i-1][j+1][k-1]*（j+1）
    在没有棋子的一列放，此时方案数f[i][j][k]+=f[i-1][j-1][k]*(m-(j-1)-k)
    
 放两个棋子时有以下方案
   
    两个棋子都分别放在没有棋子和有一个棋子的一列,此时方案数f[i][j][k]+=f[i-1][j][k-1]*(j*(m-j-k+1))
    两个棋子都放在没棋子的列，此时方案数f[i][j][k]+=f[i-1][j-2][k]*(((m-j-k+1)*(m-j-k+2))/2)
    对于乘的这个数，请各位自行回去翻课本找无序数组这一章看看_(:з」∠)_
    两个棋子都放在有一个棋子的列，此时方案数f[i][j][k]+=f[i-1][j+2][k-2]*(((j+1)*(j+2))/2)
    
最后是要注意的几个要点；

    1.数组一定要开longlong，就算你是在算方案过程中除模，也有可能会加到超过int范围的数（我因为这个原因这一题三天40pts所以一定要说）
    2.若是开三层循环，i要从1开始进行，倘若从0进行就会在方案数中加一个f[-1][j][k]，这显然是要出问题的
    3.倘若按我这种思路，数组边界要开到103，因为i=100时我们可能会要加f[100][102][100]，若是只定到101加超界数组是药丸的。
    4.最好在运算时就去取模，虽说这一题没必要，但未来若是出现n,m到1000,10000时可能会有long long也装不下的情况
    5.这题有动规吗？？？？（黑人问号）
    
最后是期待已久的总代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
using namespace std;
int mod=9999973;
//题目所需的膜， -1s-1s-1s-1s..... 
long long f[104][104][104];
//f[i][j][k]第i行有j列一棋子，k列二棋子的方案数  
int n,m;
inline int C(int x)    
{
    return ((x*(x-1))/2)%mod;
}
//数学中的C ,如果不知道什么意思建议回去翻一下高中课本（____________________光速后退________(:з」∠)_ ) 
inline int read()
{
    int ret=0;
    char c=getchar();
    while (c<'0' || c>'9') c=getchar();
    while (c>='0' && c<='9'){
        ret=ret*10+c-'0';
        c=getchar();
    }
    return ret;
} //"简单"的读入优化 
int main()
{
    n=read(),m=read();
    f[0][0][0]=1;
    for (int i=1;i<=n;i++)
    {
        for (int j=0;j<=m;j++)
        {
        	int maxj=m-j;
            for (int k=0;k<=maxj;k++) 
            {
                f[i][j][k]=f[i-1][j][k];
				//一个棋子也不放的情况
                if(j>=1) f[i][j][k]=(f[i][j][k]+f[i-1][j-1][k]*(m-k-j+1))%mod;
				//放置1个棋子，并且此棋子放置在原来有0个棋子的一列上
                if(k>=1) f[i][j][k]=(f[i][j][k]+f[i-1][j+1][k-1]*(j+1))%mod;
				//放置1个棋子，并且此棋子放置在原来有1个棋子的一列上
                if(j>=2) f[i][j][k]=(f[i][j][k]+f[i-1][j-2][k]*(((m-j-k+1)*(m-j-k+2))/2))%mod;
				//放置两个棋子，并且两个棋子都放置在原来有0个棋子的两列上
                if(j&&k) f[i][j][k]=(f[i][j][k]+f[i-1][j][k-1]*(j*(m-j-k+1)))%mod;
				//放置两个棋子，并且两个棋子分别放置在原来有0个棋子的一列和原来有1个棋子的一列上
                if(k>=2) f[i][j][k]=(f[i][j][k]+f[i-1][j+2][k-2]*(((j+1)*(j+2))/2))%mod;
				//放置两个棋子，并且两个棋子都在原来有1个棋子的两列上
                }
            }
    }
    long long ans=0;
    for (int i=0;i<=m;i++)
    {
    	int maxi=m-i;
        for (int j=0;j<=maxi;j++)
        {
            ans=(ans+f[n][i][j])%mod;
        }
    }
    cout<<ans;
    return 0;
}
```

今天瘟疫之星开了吗.....（国际服仓鼠没瘟疫之星要死了....）



---

## 作者：fsq0726 (赞：0)

**题目大意**

给定一个$n * m$的象棋棋盘。

在上面放置炮，要求任意两个炮不能攻击到。

问有多少种放置放置方法。

一个炮也不放算一种方案。

------------

**解题思路**

每一行每一列最多放置两个炮。

设$dp[i][j][k]$为当前放置完前$i$行，有$j$列放置了$1$个炮，有$k$列放置了$2$个炮。

我们设没有炮的列的个数为$kong$，$kong = m-j-k$。


$1$ 在第$i$行一个炮也不放置，那么$dp[i][j][k]=dp[i - 1][j][k]$

$2$ 在第$i$行放置$1$个炮。

$2.1$ 放在没有炮的列：$dp[i][j][k] += dp[i - 1][j - 1][k] * (kong + 1) $

$2.2$ 放在有一个炮的列：$dp[i][j][k] += dp[i - 1][j + 1][k - 1] * (j + 1) $

$3$ 在第$i$行放置$2$个炮。

$3.1$ 都放在没有炮的列：
$dp[i][j][k] += dp[i - 1][j - 2][k] *  C_{kong+2}^{2} $ 

$3.2$ 都放在有一个炮的列：

$dp[i][j][k] += dp[i - 1][j + 2][k - 2] *C_{j+2}^{2}$

$3.3$ 一个放在没有炮的列，另一个放在有一个炮的列：
$ dp[i][j][k] += dp[i - 1][j][k - 1] * j * C_{kong+1}^{2} $



------------
**代码**

```cpp

#include <bits/stdc++.h>
using namespace std;

const long long mod = 9999973;
const int N = 105, M = 105;
int n, m, kong;
long long ans;
long long dp[N][M][M];

long long C(int x) {
	return x * (x - 1) / 2;
}
int main() {
	cin >> n >> m;
	dp[0][0][0] = 1;
	for (int i = 1; i <= n; i++)
		for (int j = 0; j <= m; j++)
			for (int k = 0; k <= m - j; k++) {
				kong = m - j - k;
				dp[i][j][k] = (dp[i][j][k] + dp[i - 1][j][k]) % mod;
				if (k > 0) dp[i][j][k] = (dp[i][j][k] + dp[i - 1][j + 1][k - 1] * (j + 1)) % mod;
				if (j > 0) dp[i][j][k] = (dp[i][j][k] + dp[i - 1][j - 1][k] * (kong + 1)) % mod;
				if (k > 0) dp[i][j][k] = (dp[i][j][k] + dp[i - 1][j][k - 1] * j * (kong + 1)) % mod;
				if (j > 1) dp[i][j][k] = (dp[i][j][k] + dp[i - 1][j - 2][k] * C(kong + 2)) % mod;
				if (k > 1) dp[i][j][k] = (dp[i][j][k] + dp[i - 1][j + 2][k - 2] * C(j + 2)) % mod;
			}
	for (int i = 0; i <= m; i++)
		for (int j = 0; j <= m - i; j++) ans = (ans + dp[n][i][j]) % mod;
	cout << ans << endl;
	return 0;
}

```










---

## 作者：BPM136 (赞：0)

可以暴枚每一行放棋子在那些列，这是可以直接写成for的，然后组合数预处理，就可以跑的飞快辣
```cpp
#include <bits/stdc++.h>

using namespace std;

using ll = long long;

int const MOD = 9999973;

int const N = 105;

int f[N][N][N];
int C[N][N];

int main() {
	C[0][0] = C[1][0] = C[1][1] = 1;
	for (int i = 2; i < N; ++i) {
		C[i][0] = 1;
		for (int j = 1; j < N; ++j) {
			C[i][j] = C[i - 1][j] + C[i - 1][j - 1];
			if (C[i][j] > MOD)
				C[i][j] -= MOD;
		}
	}
	int n, m;
	cin >> n >> m;
	f[0][m][0] = 1;
	for (int i = 0; i < n; ++i) 
		for (int j = 0; j <= 2; ++j) 
			for (int k = 0; k <= 2; ++k)
				if (j + k <= 2) 
					for (int p = j; p <= m; ++p) 
						for (int q = k; q <= m; ++q) 
							if (p + q <= m && f[i][p][q] > 0) {
								ll t = f[i][p][q];
								t = t * C[p][j] % MOD * C[q][k] % MOD;
								int& tuf = f[i + 1][p - j][q - k + j];
								tuf += t;
								if (tuf > MOD)
									tuf -= MOD;
							}

	int ans = 0;
	for (int i = 0; i <= m; ++i)
		for (int j = 0; j <= m; ++j) {
			ans += f[n][i][j];
			if (ans > MOD)
				ans -= MOD;
		}
	ans = (ans % MOD + MOD) % MOD;
	cout << ans << '\n';
}

```


---

## 作者：tiandong123 (赞：0)

一道较好的裸$dp$题目，转移方程也不算复杂，比较适合像我这样的蒟蒻练习$dp$ $QAQ$

## solution

容易发现，每一行和每一列的炮的个数都不能超过3个。

观察数据可得，大概是个$O(n^4)$左右的dp

设出$dp[i][j][k][z]$表示现在扫到了第i行，有$j$个列放了0个炮，$k$个列放了1个炮，$z$个列放了2个炮

对于每一行，我们有三种选择

#### 1.不放

容易得到转移方程
```
dp[i][j][k][z]+=dp[i-1][j][k][z]
```

#### 2.只放一个

考虑这个炮放在只有0个的地方还是1个的地方。
```
dp[i][j][k][z]+=dp[i-1][j+1][k-1][z]*(j+1)//放在0上
dp[i][j][k][z]+=dp[i-1][j][k+1][z-1]*(k+1)//放在1上
```

#### 3.放两个

有三种选择，$(0,0)$ $(1,0)$ $(1,1)$

```
//C(i,j)表示在i个里面选j个
dp[i][j][k][z]+=dp[i-1][j+2][k-2][z]*C(j+2,2)
dp[i][j][k][z]+=dp[i-1][j+1][k][z-1]*k*(j+1)
dp[i][j][k][z]+=dp[i-1][j][k+2][z-2]*C(k+2,2)
```

其实考虑$j+k+z$一定等于$m$的话转移$O(n^3)$就可以了。并且dp还可以减去一维。

因为我比较的菜，用了4维数组，防止爆炸开了滚动数组。~~结果调了一个晚上还没调出来QAQ~~
```
#include<bits/stdc++.h>
using namespace std;
#define maxn 108
#define mod 9999973
#define int long long
int n,m;
int dp[3][maxn][maxn][maxn];
int inv[maxn];
main(){
    scanf("%lld%lld",&n,&m);
    dp[0][m][0][0]=1;
    for(int i=1;i<=n;i++){
        memset(dp[(i&1)],0,sizeof(dp[i&1]));
        for(int j=0;j<=m;j++){
            for(int k=0;k<=m-j;k++){
                int z=m-j-k;
                int now=(i&1);
                int nn=(!now);
                dp[now][j][k][z]+=dp[nn][j][k][z]%mod;
                if(k>=1&&j+1<=m)(dp[now][j][k][z]+=dp[nn][j+1][k-1][z]*(j+1))%mod;
                if(z>=1&&k+1<=m)(dp[now][j][k][z]+=dp[nn][j][k+1][z-1]*(k+1))%mod;
                if(k>=2&&j+2<=m)(dp[now][j][k][z]+=(dp[nn][j+2][k-2][z]*(((j+2)*(j+1))/2)))%=mod;
                if(z>=1&&j+1<=m)(dp[now][j][k][z]+=(dp[nn][j+1][k][z-1]*k*(j+1)))%=mod;
                if(z>=2&&k+2<=m)(dp[now][j][k][z]+=(dp[nn][j][k+2][z-2]*(((k+2)*(k+1))/2)))%=mod;
                
                dp[now][j][k][z]%=mod;
            }
        }
    }
    int ans=0;
    for(int i=0;i<=m;i++){
        for(int j=0;j<=m;j++){
            if(i+j>m)break;
            for(int k=0;k<=m;k++){
                if(i+j+k!=m)continue;
                ans+=dp[n&1][i][j][k];
                ans%=mod;
            }
        }
    }
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：G_A_TS (赞：0)

题解同步发布于[blog](https://www.cnblogs.com/wzzorz/articles/10351126.html)  

------------
此题先用**三进制**的思路推下去，推成dp就是dp[i][j][k]表示放了前i行，有j列是有1个棋子，有k列有2个棋子  
之后就很好理解了，分情况转移  
上代码

------------
```cpp
#include<bits/stdc++.h>
using namespace std;
long long MOD=9999973;
long long n,m;
long long dp[110][110][110];
long long C(long long x)//C(x,2),求组合数
{
	return x*(x-1)/2;
}
int main()
{
	cin>>n>>m;
	dp[0][0][0]=1;
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<=m;j++)
		{
			for(int k=0;k<=m-j;k++)
			{
				dp[i][j][k]=dp[i-1][j][k];
				if(k>=1)
					dp[i][j][k]+=dp[i-1][j+1][k-1]*(j+1);
                if(j>=1&&m-(j-1)-k>=0)
					dp[i][j][k]+=dp[i-1][j-1][k]*(m-j-k+1);
                if(j>=2)
					dp[i][j][k]+=dp[i-1][j-2][k]*C(m-j-k+2);
                if(k>=2)
					dp[i][j][k]+=dp[i-1][j+2][k-2]*C(j+2);
                if(k>=1&&m-j-(k-1)>=0)
					dp[i][j][k]+=dp[i-1][j][k-1]*j*(m-j-k+1);
                dp[i][j][k]%=MOD;
			}
		}
	}
	long long ans=0;
    for (int i=0;i<=m;i++)
    {
    	for (int j=0;j<=m-i;j++)
		{
            ans+=dp[n][i][j];
            ans%=MOD;
        }
    }
	cout<<ans;
}
```

---

## 作者：Ouaoan (赞：0)

题目：[中国象棋](https://www.luogu.org/problemnew/show/P2051#sub)

思路：

这里分子任务看这道题——

首先是30分暴力——
直接dfs就好。
用row[]和col[]存储状态。
```cpp
#include<bits/stdc++.h>
using namespace std;

#define maxn 100
#define read(x) scanf("%d",&x)
#define md 9999973

int n,m;
int rw[maxn+5],col[maxn+5];

int dfs(int x,int y) {
	if(y>m) y=1,x++;
	if(x>n) return 1;
	int ans=0;
	if(rw[x]<2&&col[y]<2) {
		rw[x]++,col[y]++;
		ans=(ans+dfs(x,y+1))%md;
		rw[x]--,col[y]--;
	}
	ans=(ans+dfs(x,y+1))%md;
	return ans;
}

int main() {
	read(n),read(m);
	
	int ans=dfs(1,1);
	printf("%d",ans);
	
	return 0;
}
```
50分暴力——
状压，把每个位置上的棋子数三进制状压一下，作为dp的第二维状态，然后我们的dfs就可以记忆化了。

100分算法——
f[i][j][k]表示前i行，放了1个棋子的有j列，放了2个棋子的有k列的方案数。
转移——
```cpp
在原来没有棋子的列上放一个棋子：
f[i][j][k]=f[i][j][k]+f[i-1][j-1][k]*(m-j-k+1)
在原来有一个棋子的列上放一个棋子：
f[i][j][k]=f[i][j][k]+f[i-1][j+1][k-1]*(j+1)
在原来两条没有棋子的列上各放一个棋子：
f[i][j][k]=f[i][j][k]+f[i-1][j-2][k]*(m-k-j+2)*(m-k-j+1)/2
在原来一条没有棋子的列上和一条有棋子的列上各放一个棋子：
f[i][j][k]=f[i][j][k]+f[i-1][j][k-1]*(m-k-j+1)*j
在原来两条有一个棋子的列上各放一个棋子：
f[i][j][k]=f[i][j][k]+f[i-1][j+2][k-2]*(j+2)*(j+1)/2
```
初始化——
f[0][0][0]=1
f[i][j][k]=f[i-1][j][k]
以及不能忘记每一行只能有两个棋子——
if(i==1&&k>0) continue;
if(j+k*2>i*m) continue;

```cpp
#include<bits/stdc++.h>
using namespace std;

#define maxn 100
#define read(x) scanf("%d",&x)
#define md 9999973
#define ll long long

int n,m;
ll f[maxn+5][maxn+5][maxn+5];

ll dp() {
	f[0][0][0]=1;
	for(int i=1; i<=n; i++)
		for(int j=0; j<=m; j++)
			for(int k=0; k+j<=m; k++) {
				if(i==1&&k>0) continue;
				if(j+k*2>i*m) continue;
				f[i][j][k]=f[i-1][j][k];
				if(j!=0) f[i][j][k]=(f[i][j][k]+f[i-1][j-1][k]*(m-j-k+1))%md;
				if(k!=0&&j+1<=m) f[i][j][k]=(f[i][j][k]+f[i-1][j+1][k-1]*(j+1))%md;
				if(j>1) f[i][j][k]=(f[i][j][k]+(f[i-1][j-2][k]*(m-k-j+2))*(m-k-j+1)/2)%md;
				if(k!=0) f[i][j][k]=(f[i][j][k]+(f[i-1][j][k-1]*(m-k-j+1))*j)%md;
				if(k>1&&j+2<=m) f[i][j][k]=(f[i][j][k]+(f[i-1][j+2][k-2]*(j+2))*(j+1)/2)%md;
			}
	
	ll ans=0;
	for(int j=0; j<=m; j++) {
		for(int k=0; k+j<=m; k++) {
			ans=(ans+f[n][j][k])%md;
		}
	}
	return ans;
}

int main() {
	read(n),read(m);

	int ans=dp();
	printf("%d",ans);

	return 0;
}
```

重点——
写了个打表的代码，本机可过，luogu可能卡掉了它，仅供参考，切勿抄袭——
```cpp
#include<bits/stdc++.h>
using namespace std;

#define maxn 100
#define read(x) scanf("%d",&x)
#define md 9999973
#define ll long long

int n,m;
ll f[maxn+5][maxn+5][maxn+5];

ll dp() {
	memset(f,0,sizeof(f));
	f[0][0][0]=1;
	for(int i=1; i<=n; i++)
		for(int j=0; j<=m; j++)
			for(int k=0; k+j<=m; k++) {
				if(i==1&&k>0) continue;
				if(j+k*2>i*m) continue;
				f[i][j][k]=f[i-1][j][k];
				if(j!=0) f[i][j][k]=(f[i][j][k]+f[i-1][j-1][k]*(m-j-k+1))%md;
				if(k!=0&&j+1<=m) f[i][j][k]=(f[i][j][k]+f[i-1][j+1][k-1]*(j+1))%md;
				if(j>1) f[i][j][k]=(f[i][j][k]+(f[i-1][j-2][k]*(m-k-j+2))*(m-k-j+1)/2)%md;
				if(k!=0) f[i][j][k]=(f[i][j][k]+(f[i-1][j][k-1]*(m-k-j+1))*j)%md;
				if(k>1&&j+2<=m) f[i][j][k]=(f[i][j][k]+(f[i-1][j+2][k-2]*(j+2))*(j+1)/2)%md;
			}
	
	ll ans=0;
	for(int j=0; j<=m; j++) {
		for(int k=0; k+j<=m; k++) {
			ans=(ans+f[n][j][k])%md;
		}
	}
	return ans;
}

int main() {
	freopen("P2051.cpp","w",stdout);
	printf("#include<bits/stdc++.h>\nusing namespace std;\n\nint n,m;\n\n");
	printf("int a[15][15]={{0},");
	for(n=1; n<=100; n++) {
		printf("{0,");
		for(m=1; m<=n; m++) {
			int ans=dp();
			printf("%d",ans);
			if(m!=n) printf(",");
		}
		printf("}");
		if(n!=100) printf(",");
		else printf("};\n\n");
	}
	printf("int main(){\n    scanf(%c%%d%%d%c,&n,&m);\n    printf(%c%%d%c,max(a[n][m],a[m][n]));\n    return 0;\n}",'"','"','"','"');

	return 0;
}
```

---

## 作者：Tiffany_Tendering (赞：0)

   感谢## $tqc$### 大佬的耐心讲解
   
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn = 105;
const int mod = 9999973 ;
long long n,m,f[maxn][maxn][maxn] ;//前i行棋盘里 放一个炮的有j列 两个炮的有k列 
int C(int x) {return x * (x - 1) / 2;}
int main() {
	scanf("%lld%lld",&n,&m) ;
	f[0][0][0] = 1;
	for(int i = 0;i < n ;++i) //因为我们更新的是i + 1行的数据 因此i 从 0 ~ n - 1 
	  for(int j = 0;j <= m ;++j)
	    for(int k = 0;k <= m - j;++k) {  //放一个炮和两个炮的列数相加一定小于m的 
	    	if(!f[i][j][k]) continue ;  //因为我们更新答案的时候 用的是乘法原理 若这个为0 则为无效的 
	    	f[i + 1][j][k] = (f[i + 1][j][k] + f[i][j][k]) % mod ; //初始化de 
	    	if((m - j - k) >= 1) //放一个棋子在没有放棋子的列数  则有一个棋子的列数 + 1 
	    	  f[i + 1][j + 1][k] = (f[i + 1][j + 1][k] + (m - j - k) * f[i][j][k]) % mod;
	    	if( j ) //放一个棋子在有一个棋子的列 则有两个棋子的列数 + 1 一个棋子的 - 1 
	    	  f[i + 1][j - 1][k + 1] = (f[i + 1][j - 1][k + 1] + f[i][j][k] * j) % mod ;
	    	if(j >= 2) //放两个棋子均在两个不同的放一个棋子的列上 则两个棋子的 列数 + 2 一个棋子的 - 2 
	    	  f[i + 1][j - 2][k + 2] = (f[i + 1][j - 2][k + 2] + f[i][j][k] * C(j)) % mod;
	    	if((m - j - k) && j ) //放两个棋子 一个在原来没有棋子的列上 一个在原来有一个棋子的列上 那么有一个棋子的列数 + 1 - 1 有两个棋子的 + 1 
	    	  f[i + 1][j - 1 + 1][k + 1] = (f[i + 1][j - 1 + 1][k + 1] + f[i][j][k] * j * (m - j - k)) % mod ;
	    	if((m - j - k ) >= 2) //放两个棋子在两个原来放一个棋子的列上 那么原来放一个棋子的列数 + 1 
	    	  f[i + 1][j + 2][k] = (f[i + 1][j + 2][k] + f[i][j][k] * C(m - j - k)) % mod ;
		}
	long long ans = 0;
	for(int i = 0;i <= m ;++i)
	  for(int j = 0;j <= m - i;++j)
	    ans = (ans + f[n][i][j]) % mod; //更新最后一行答案相加 
	printf("%lld\n",ans % mod) ;
	return 0;
}
```

---

## 作者：cdcq (赞：0)

首先这题标的tag是DP，但是实际上应该是计数题，算是递推吧  
和楼下mjl（stdcall）相反，这题我好像想了挺久的T_T  
首先需要看出来问题的实质是给一个棋盘，每行每列最多放2个棋子求方案数  
最开始我想的是安格处理，但是发现如果有两个棋子的话状态能储存的信息极少，统计答案非常困难  
再次注意题目中的特殊性：  
最重要的，因为这题要求的是计数，所以每个格子放在那里是不用管的，我们关心的就是方案数  
第二个性质，因为每行每列上限2，所以如果将状态设为每一行里n个格子中，所在列上放了1个，0个的格子有多少个，就可以很方便地用数组表示出来  
这个状态的设计我一开始就有了想法，但是没有注意到第一条的性质，认为最后统计答案会比较麻烦所以放弃了  
再次注意，棋子怎么放是无所谓的，所有的情况都变成了方案数储存在数组里  
这种状态相比状压，优势就在于丢掉了“每个棋子放在那里”这样一个无用的信息，而只关注我们需要的，对于每一种状态，它的方案数是多少  
因为这样设计状态涵盖了所有情况，所以正确性是有保证的  
（好像越描越黑了。。。。。。  
总之明确了状态的设计之后，写出递推式就很容易了  
对于每一行，可以不放棋子，放一个或到所在列有0个棋子的格子上，放一个或到所在列有1个棋子的格子上，两个所在列分别有1个棋子和0个棋子的格子各放一个  
注意还要乘上能放的位置数，Talk is cheap, show you the code：   
$$ f[i][j][k]=f[i-1][j][k]+(j+1)*f[i-1][j+1][k]+(k+1)*f[i-1][j-1][k+1]+(j+2)*(j+1)/2*f[i-1][j+2][k]+(k+2)*(k+1)/2*f[i-1][j-2][k+2]+(j)*(k+1)*f[i-1][j][k+1]  $$
（有点长……  
写出递推式之后就好办了，实现起来比较容易  
没有需要注意的坑，把式子实现出来就能过了  
我也1A了！（开心  
代码：  
```cpp
//去掉了头文件
#define ll long long
const int mo=9999973;
int n,m;
//          1个 0个
ll f[110][110][110];
//f[i][j][k]=f[i-1][j][k]+(j+1)*f[i-1][j+1][k]+(k+1)*f[i-1][j-1][k+1]
//           +(j+2)*(j+1)/2*f[i-1][j+2][k]+(k+2)*(k+1)/2*f[i-1][j-2][k+2]
//           +(j)*(k+1)*f[i-1][j][k+1]
int main(){freopen("ddd.in","r",stdin);
	memset(f,0,sizeof(f));
	cin>>n>>m;  if(m>n)  swap(n,m);
	f[0][0][m]=1;
	for(int i=1;i<=n;++i)for(int j=0;j<=m;++j)for(int k=0;k<=m;++k){
		f[i][j][k]=f[i-1][j][k];
		if(j+1<=m)  f[i][j][k]=(f[i][j][k]+(j+1)*f[i-1][j+1][k])%mo;
		if(k+1<=m && j-1>=0)  f[i][j][k]=(f[i][j][k]+(k+1)*f[i-1][j-1][k+1])%mo;
		if(j+2<=m)  f[i][j][k]=(f[i][j][k]+(j+2)*(j+1)/2*f[i-1][j+2][k])%mo;
		if(k+2<=m && j-2>=0)  f[i][j][k]=(f[i][j][k]+(k+2)*(k+1)/2*f[i-1][j-2][k+2])%mo;
		if(k+1<=m)  f[i][j][k]=(f[i][j][k]+(j)*(k+1)*f[i-1][j][k+1])%mo;
	}
	ll ans=0;
	for(int i=0;i<=m;++i)for(int j=0;j<=m;++j)  ans=(ans+f[n][i][j])%mo;
	cout<<ans<<endl;
	return 0;
}



```

---

## 作者：Tritiger彪 (赞：0)

题目描述
==

这次小可可想解决的难题和中国象棋有关，在一个$N$行$M$列的棋盘上，让你放若干个炮（可以是$0$个），使得没有一个炮可以攻击到另一个炮，请问有多少种放置方法。大家肯定很清楚，在中国象棋中炮的行走方式是：一个炮攻击到另一个炮，当且仅当它们在同一行或同一列中，且它们之间恰好 有一个棋子。你也来和小可可一起锻炼一下思维吧！


----------


输入输出格式
==

输入格式：
--
一行包含两个整数$N$，$M$，之间由一个空格隔开。

输出格式：
--
总共的方案数，由于该值可能很大，只需给出方案数模$9999973$的结果。

输入输出样例
--

输入样例#1： 
--
$1 3$
输出样例#1： 
--
$7$


----------


说明
==

样例说明
--

除了$3$个格子里都塞满了炮以外，其它方案都是可行的，所以一共有$2*2*2-1=7$种方案。


----------


数据范围
==
$100$%的数据中$N$和$M$均不超过$100$

$50$%的数据中$N$和$M$至少有一个数不超过$8$

$30$%的数据中$N$和$M$均不超过$6$


----------


合理分析
==
根据此题的数据范围，是网络流/状态压缩DP的复杂度，显然可以看出这是一个状态压缩DP，因为每列最多只能放0~2个棋子，所以可以考虑敲一个3进制的状态压缩DP，下面附上代码及解决思路

```
#include<cstdio>
#include<iostream>
#define maxn 110
#define mod 9999973
using namespace std;
long long  f[maxn][maxn][maxn];
long long n,m;
int main()
	{
	cin>>n>>m;
	f[0][0][0]=1;
	for(int i=1;i<=n;i++)
		{
			for(int j=0;j<=m;j++)
		{
			int MAX_K=m-j;
			for(int k=0;k<=MAX_K;k++)
				{
				f[i][j][k]=f[i-1][j][k];//一个棋子也不放的情况
				if(j>=1) f[i][j][k]=(f[i][j][k]+f[i-1][j-1][k]*(m-k-j+1))%mod;//放置1个棋子，并且此棋子放置在原来有0个棋子的一列上
				if(k>=1) f[i][j][k]=(f[i][j][k]+f[i-1][j+1][k-1]*(j+1))%mod;//放置1个棋子，并且此棋子放置在原来有1个棋子的一列上
				if(j>=2) f[i][j][k]=(f[i][j][k]+f[i-1][j-2][k]*(((m-j-k+1)*(m-j-k+2))/2))%mod;//放置两个棋子，并且两个棋子都放置在原来有0个棋子的两列上
				if(j&&k) f[i][j][k]=(f[i][j][k]+f[i-1][j][k-1]*(j*(m-j-k+1)))%mod;//放置两个棋子，并且两个棋子分别放置在原来有0个棋子的一列和原来有1个棋子的一列上
				if(k>=2) f[i][j][k]=(f[i][j][k]+f[i-1][j+2][k-2]*(((j+1)*(j+2))/2))%mod;//放置两个棋子，并且两个棋子都在原来有1个棋子的两列上
				}
		}	
		}
	long long ans=0;
	for(int i=0;i<=m;i++)
		{
		int max_n=m-i;
		for(int j=0;j<=max_n;j++)
			{
				ans=(ans+f[n][i][j])%mod;
			}
		}
	cout<<ans<<endl;
	return 0;
	}
```

---


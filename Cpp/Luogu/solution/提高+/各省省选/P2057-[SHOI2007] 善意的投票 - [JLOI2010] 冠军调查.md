# [SHOI2007] 善意的投票 / [JLOI2010] 冠军调查

## 题目描述

幼儿园里有 $n$ 个小朋友打算通过投票来决定睡不睡午觉。

对他们来说，这个问题并不是很重要，于是他们决定发扬谦让精神。

虽然每个人都有自己的主见，但是为了照顾一下自己朋友的想法，他们也可以投和自己本来意愿相反的票。

我们定义一次投票的冲突数为下面两者相加：

* 实际投票不同的好朋友对数。

* 自己实际投票和自己本来意愿不同的人数。

我们的问题就是，每位小朋友应该怎样投票，才能使冲突数最小？

## 说明/提示

对于 $100\%$ 的数据，$2\le n\le300$，$1\le m \le \frac{n(n-1)}2$。

## 样例 #1

### 输入

```
3 3
1 0 0
1 2
1 3
3 2```

### 输出

```
1```

# 题解

## 作者：ReZHUI (赞：131)

#####   题目： 幼儿园里有n个小朋友打算通过投票来决定睡不睡午觉。对他们来说，这个问题并不是很重要，于是他们决定发扬谦让精神。虽然每个人都有自己的主见，但是为了照顾一下自己朋友的想法，他们也可以投和自己本来意愿相反的票。我们定义一次投票的冲突数为好朋友之间发生冲突的总数加上和所有和自己本来意愿发生冲突的人数。每位小朋友应该怎样投票，才能使冲突数最小？


------------


# 算法建模分析

此题的关键是为什么小朋友之间要连双向边(这一点我将一步一步分析）


我们从关系出发，暂且不管冲突的事情
众所周知,图可以表示点与点之间的关系,这种关系即点之间的连线
分析题目可以得出两种关系：
1、好朋友间的关系
2、小朋友与立场的关系（同意或者不同意睡觉）
下面，我们就要依照这两种关系进行建模


## 对于立场的建模
首先,对于是否睡觉的问题，只有两种互斥的情况：**同意**  或者 **不同意**  
显然，我们可以设置两个集合，将同意的小朋友和不同意的小朋友分别放入两个集合里

那么如何与网络流结合起来，就不言而喻了。

我们将同意的小朋友与源点相连


不同意的小朋友与汇点相连
(当然你也可以反过来连）


我们可以这样理解一条单向边的含义：
### 一条从A——>B的边，表示 A 要求 B 同它同立场

那么，如何判断一个小朋友究竟是在哪个集合里呢？
我们将源点和汇点均称为**立场点**

（~~原谅我取名水平有限~~，主要是为了方便大家理解）

### 从立场点出发，凡是能到达的点都应持该立场

（注意，这个看似毫无用处的判断方式，将解决接下来的冲突问题）

## 对于好朋友间的建模

在此时我们引入冲突的概念

为什么要在此时引入冲突呢？

回顾一下题目

#### 为了照顾一下自己朋友的想法，他们也可以投和自己本来意愿相反的票。我们定义一次投票的冲突数为好朋友之间发生冲突的总数加上和所有和自己本来意愿发生冲突的人数

可以发现，发生冲突的两种情况与上述的两种关系是相对应的

 _**1、违背自身的意愿**_ 

 _**2、违背好朋友的意愿**_ 


------------

### **关于第一种冲突，根本上是由于第二种冲突引起的**

试想:假如这群小朋友间不存在好朋友关系，那么就不会存在任何冲突，因为不会违背好朋友的意愿，也不会为了和好朋友的立场保持一致而违背了自身的意愿


------------

### 关于第二种冲突，是由于一对好朋友持不同的立场

换一种理解

(设有一对好朋友，小A 小B）

小A 要求 小B同自己一个立场 ，而小B要求小A同自己一个立场

（~~话说这就是小朋友的友谊啊，总是希望好朋友和自己保持一致~~）

由于小A，小B都要求对方改变立场，是不是就发生了冲突？

------------

现在，我们再回到我们设定的单向边含义

### 一条从A——>B的边，表示 A 要求 B 同它同立场

那么为什么好朋友之间需要连双向边是不是就解决了？.........

 _好朋友互相要求对方同自己一个立场_ 
 
 关于这个问题，我们还可以多角度思考：
 
 这里我们可以倒过来想： _倘若好朋友之间是单向边？那么本身图就是走不通的，也就不存在冲突了,显然不符_ 
 
 也可以从对称性的角度来看： _A 与 B的朋友关系是相对的，单向边显然不符合对称性_ 
 
------------

## 解决冲突
由于，违背自己意愿的冲突根本上是由于好朋友之间的冲突

那么，解决冲突就必须先解决好朋友间的冲突

所以，如何解决好朋友间的冲突呢？——**很简单，改变两人间任意一个人的立场**

（ _即割掉好朋友间的一条边，一个人就不再要求另一个人的立场_ ）

其次，如何解决违背自身的冲突呢？——**无非也是割边，让自己不再被要求持该立场**

如何付出最小的代价，就解决所有的冲突呢？所割的边**容量之和**最小。这就转化成**最小割问题**了。
### 根据最大流最小割定理 最小割等于最大流
(关于此定理的证明，这里不再赘述，~~请问度娘吧~~)

 _所以，建完图后跑一边最大流就完事了_ 
 
######  献上蒟蒻的代码
 
 ```cpp
#include <bits/stdc++.h>
#define inf 0x3f3f3f3f
using namespace std;
const int N=200520;
int n,m,s,t,pos,tot=1,maxflow;
int vis[N],incf[N],pre[N],head[N],Next[N],ver[N],edge[N];
void add(int x,int y,int z){
    ver[++tot]=y;edge[tot]=z;Next[tot]=head[x];head[x]=tot;
    ver[++tot]=x;edge[tot]=0;Next[tot]=head[y];head[y]=tot;
}
bool bfs(){    
    memset(vis,0,sizeof(vis));vis[s]=1;
    queue<int> q;q.push(s);
    incf[s]=inf;
    while(q.size()){
        int x=q.front();q.pop();
        for(int i=head[x];i;i=Next[i])
            if(edge[i]){
            	int y=ver[i];
            	if(vis[y])continue;
            	incf[y]=min(incf[x],edge[i]);
            	pre[y]=i;
            	q.push(y);
            	vis[y]=1;
            	if(y==t)return 1;
        	}
    }
    return 0;
}
void update(){
    int x=t;
    while(x!=s){
        int i=pre[x];
        edge[i]-=incf[t];
        edge[i^1]+=incf[t];
        x=ver[i^1];
    }
    maxflow+=incf[t];
}
int main()
{
    //朋友间建双向边，反对和同意分别与源点和汇点相连，最小冲突即最小割，即最大流 
    ios::sync_with_stdio(false);
    cin>>n>>m;
    s=0,t=n+1;
  	for(int i=1;i<=n;i++){
  		cin>>pos;
  		if(pos)add(s,i,1);
  		else add(i,t,1);
      }
    for(int i=1;i<=m;i++){
        int x,y;
        cin>>x>>y;
        add(x,y,1);
        add(y,x,1); 
    } 
    while(bfs())update();
    cout<<maxflow<<endl;
    return 0;
}

```
本题是我写的网络流第三题（~~不算板子应该是第二题~~）

这也是本蒟蒻的第一篇题解（还真是意义巨大）也废了不少功夫

所以，如果看懂的话不妨点个赞，
算是对我的认可吧，也为了让更多和我一样被毒瘤的网络流困扰的萌新们看到~~~~

##### 溜溜溜_________________________________________________________________________________________________________________________

















---

## 作者：浅色调 (赞：39)

 好久没有写题解了啊～

### 理解下题意：###

题意大致就是有n个人有两种不同的意见并且有许多朋友，需要让朋友间尽可能的统一意见（少发生冲突），如果一个人违反自己的本意也算冲突，求最少的冲突。。。

### 思路：###

明眼人直接发现是最小割，两种意见可以看作源点S和T，我们需要做的是割最少的边使得S和T成为两个不同的集合，解释：割掉的边相当于1次冲突（因为若某边被割走，则显然这条边相连的两个点分别通向了S和T，所以算是一次冲突），当S和T还连通时则必然存在一条路径，这样肯定会有冲突，所以需要使得S和T孤立。

# 实现：

**实现时这样建图：直接将S连向同意的人，T连向不同意的人，若两人是朋友，则在他们之间连一条双向边（这里有些人不理解：若两个人有冲突，则只需要其中任意一个人改变意见就行了，简单说是让a同意b的意见或者b同意a的意见，所以只需割掉一条边满足一种情况就可以了，但是有两种情况，所以建双向边）。最后就是求最小割了，直接套上最大流的模板就ok了。**

代码：

```cpp
    #include<bits/stdc++.h>
    #define il inline
    using namespace std;
    const int N=100005,inf=23333333;
    int n,m,s,t=520,h[N],cnt=1,dis[N],ans;
    struct edge{
    int to,net,v;
    }e[N*4];
    il void add(int u,int v,int w)
    {
        e[++cnt].to=v,e[cnt].net=h[u],e[cnt].v=w,h[u]=cnt;
        e[++cnt].to=u,e[cnt].net=h[v],e[cnt].v=0,h[v]=cnt;
    }
    queue<int>q;
    il bool bfs()
    {
        memset(dis,-1,sizeof(dis));
        q.push(s),dis[s]=0;
        while(!q.empty())
        {
            int u=q.front();q.pop();
            for(int i=h[u];i;i=e[i].net)
            if(dis[e[i].to]==-1&&e[i].v>0)dis[e[i].to]=dis[u]+1,q.push(e[i].to);
        }
        return dis[t]!=-1;
    }
    il int dfs(int u,int op)
    {
        if(u==t)return op;
        int flow=0,used=0;
        for(int i=h[u];i;i=e[i].net)
        {
            int v=e[i].to;
            if(dis[v]==dis[u]+1&&e[i].v>0)
            {
                used=dfs(v,min(op,e[i].v));
                if(!used)continue;
                flow+=used,op-=used;
                e[i].v-=used,e[i^1].v+=used;
                if(!op)break;
            }
        }
        if(!op)dis[u]=-1;
        return flow;
    }
    int main()
    {
        scanf("%d%d",&n,&m);
        int x,y;
        for(int i=1;i<=n;i++){
            scanf("%d",&x);
            if(x==1)add(s,i,1);
            else add(i,t,1);
        }
        for(int i=1;i<=m;i++){
            scanf("%d%d",&x,&y);
            add(x,y,1),add(y,x,1);
        }
        while(bfs())ans+=dfs(s,inf);
        cout<<ans;
        return 0;
}
```

---

## 作者：ChthollyTree (赞：24)


其实这题模拟退火也能过。

模拟退火，一般用于求最优值的问题，

首先设定一个初始温度，在高温状态比较容易接受不是最优解，之后温度降低，较为难接受不优解

这题也是这样

```
#include<bits/stdc++.h>
using namespace std;

#define MAXN 305  
#define db double 

struct aa
{
	int x,y,ls;
}b[MAXN*MAXN*2];
int cnt,t[MAXN];
int n,m,ans;
int a[MAXN],d; 
bool c[MAXN];

void jb(int x,int y)//建边
{
	cnt ++;
	b[cnt].x = x;
	b[cnt].y = y;
	b[cnt].ls = t[x];
	t[x] = cnt;
}

void rd()//输入
{
	scanf("%d%d",&n,&m);
	for(int i = 1; i <= n; i ++)
		cin >> a[i];
	for(int i = 1; i <= m; i ++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		jb(x,y);
		jb(y,x); 
	}
}

db sj()
{
	return ((db)(rand()*rand()%19260817))/(db)19260817;
} 

void mnth(db s,db dt,db tt)//s:现在温度，dt每次降温，tt最终温度，d表示现在
{
	for(s;s >= tt; s *= dt)
	{
		int x = rand()%n+1,ls =d;
		c[x] = !c[x];//改变一个人的选票
		if(c[x] == a[x]) d -= 1;
		else d += 1;//和自己意向不同
		
		for(int i = t[x]; i != 0; i = b[i].ls) 
			if(c[x] == c[b[i].y]) d -= 1;
			else d += 1;//和朋友选票不同
		ans = min(ans,d);
		if(d < ls || exp((d-ls)/s) < sj()*10) 
		{
			;
		}
		else
		{
			c[x] = !c[x];
			d = ls;
		}
	}
	for(int i = 1; i <= 233; i ++)
	{
		int x = rand()%n+1,ls =d;
		c[x] = !c[x];
		if(c[x] == a[x]) d -= 1;
		else d += 1;
		
		for(int i = t[x]; i != 0; i = b[i].ls) 
			if(c[x] == c[b[i].y]) d -= 1;
			else d += 1;
		ans = min(ans,d);
		if(d < ls) 
		{
			;
		}
		else
		{
			c[x] = !c[x];
			d = ls;
		}		
	}	
}

int main()
{
	rd();
	for(int i = 1; i <= n; i ++)
		if(a[i] != 0) 
			ans ++;
	d = ans;

	mnth(1000000000,0.9997,0.0000001);
	if(n < 100)
	{
		mnth(1000000000,0.99997,0.0000001);
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Adove (赞：13)

建模方式如下图↓

![](https://cdn.luogu.com.cn/upload/pic/15953.png)

为了将此题模型抽象化、普遍化，我们称支持睡觉为方案1，反对睡觉为方案2，且两方案互斥。

支持1的连源点，支持2的连汇点，边权都为1，这就代表了**与其方案直接冲突**的代价；同理，朋友之间连双向边，且边权为1，代表**两人协商**的代价。

这样最小割的意义就明确了——每人方案相互冲突或协商**产生代价的最小值**。

代码如下↓

```
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int INF=2e9;

int n,m,s,t,np=1,x,y;
int h[305],cur[305],tp[305],q[60050];
struct rpg{
    int li,nx,ln;
}a[60050];

inline void add(int ls,int nx,int ln){
    a[++np]=(rpg){h[ls],nx,ln};
    h[ls]=np;
}

inline bool bfs(){
    memset(tp,0,sizeof(tp));
    int hd=1,tl=1;
    q[hd]=s;
    tp[s]=1;
    while(hd<=tl){
        int nw=q[hd++];
        for(int i=h[nw];i;i=a[i].li){
            if(a[i].ln&&!tp[a[i].nx]){
                tp[a[i].nx]=tp[nw]+1;
                q[++tl]=a[i].nx;
            }
        }
    }return tp[t];
}

int dfs(int u,int maxn){
    if(u==t||!maxn) return maxn;
    int sum=0;
    for(int& i=cur[u];i;i=a[i].li){
        if(a[i].ln&&tp[a[i].nx]==tp[u]+1){
            int f=dfs(a[i].nx,min(maxn,a[i].ln));
            if(f){
                maxn-=f;
                sum+=f;
                a[i].ln-=f;
                a[i^1].ln+=f;
                if(!maxn) break;
            }
        }
    }return sum;
}

int dnc(){
    int ans=0;
    while(bfs()){
        for(int i=0;i<=t;++i) cur[i]=h[i];
        while(int d=dfs(s,INF)) ans+=d;
    }return ans;
}

int main(){
    scanf("%d%d",&n,&m);t=n+1;
    for(register int i=1;i<=n;++i){
        scanf("%d",&x);
        if(x){
            add(s,i,1);
            add(i,s,0);
        }else{
            add(i,t,1);
            add(t,i,0);
        }
    }for(register int i=1;i<=m;++i){
        scanf("%d%d",&x,&y);
        add(x,y,1);
        add(y,x,1);
    }printf("%d\n",dnc());
    return 0;
}
```

---

## 作者：yybyyb (赞：13)

每个小朋友投同意或者反对

相当于把小朋友们割为两块

那么，考虑最小割

首先，分别将同意和反对的与源点或者汇点连边

如果违反自己意愿，则相当于与这个点割开

同时，每个点与自己的朋友连边

如果割开，相当于与朋友意见不同

最后解决最小割，即求最大流

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<set>
#include<map>
#include<vector>
#include<queue>
using namespace std;
#define MAX 500
#define MAXL 200000
#define INF 20000000
inline int read()
{
    int x=0,t=1;char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
    if(ch=='-')t=-1,ch=getchar();
    while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();
    return x*t;
}
struct Line
{
    int v,next,w;
}e[MAXL];
int h[MAX],cnt;
int ans,S,T,n,m;
inline void Add(int u,int v,int w)
{
    e[cnt]=(Line){v,h[u],w};
    h[u]=cnt++;
    e[cnt]=(Line){u,h[v],0};
    h[v]=cnt++;
}
int level[MAX];
int cur[MAX];
bool BFS()
{
    memset(level,0,sizeof(level));
    level[S]=1;
    queue<int> Q;
    Q.push(S);
    while(!Q.empty())
    {
        int u=Q.front();Q.pop();
        for(int i=h[u];i!=-1;i=e[i].next)
        {
            int v=e[i].v;
            if(e[i].w&&!level[v])
                level[v]=level[u]+1,Q.push(v);
        }
    }
    return level[T];
}
int DFS(int u,int flow)
{
    if(flow==0||u==T)return flow;
    int ret=0;
    for(int &i=cur[u];i!=-1;i=e[i].next)
    {
        int v=e[i].v;
        if(e[i].w&&level[v]==level[u]+1)
        {
            int dd=DFS(v,min(flow,e[i].w));
            flow-=dd;ret+=dd;
            e[i].w-=dd;e[i^1].w+=dd;
        }
    }
    return ret;
}
int Dinic()
{
    int ret=0;
    while(BFS())
    {
        for(int i=S;i<=T;++i)cur[i]=h[i];
        ret+=DFS(S,INF);
    }
    return ret;
}
int main()
{
    memset(h,-1,sizeof(h));
    n=read();m=read();
    S=0,T=n+1;
    for(int i=1;i<=n;++i)
    {
        int k=read();
        if(k)Add(S,i,1);
        else Add(i,T,1);
    }
    for(int i=1;i<=m;++i)
    {
        int u=read(),v=read();
        Add(u,v,1);Add(v,u,1);
    }
    printf("%d\n",Dinic());
    return 0;
}

```

---

## 作者：Tweetuzki (赞：10)

数据真水，我这种非正解的骗分做法竟然也能AC……强烈要求加强数据。

介绍一下我的贪心骗分做法。

由于朋友直接发生冲突数与改变自己的意见是等效的，我们不妨这样贪心：一切随朋友。一个朋友集体内所投的票是一致的，而所投的内容就是这个朋友群中大部分人的意愿。而其产生的冲突值就为支持另一种的人的人数。

这可以简单地用并查集维护。

```cpp
#include <cstdio>
 
const int maxn=300;
int n,m;
int a[maxn+1], fa[maxn+1], res[maxn+1][2];
 
int bcj(int x) {
    if (x==fa[x])
        return x;
    return fa[x]=bcj(fa[x]);
}
 
void init() {
    scanf("%d %d",&n,&m);
    for (int i=1; i<=n; i++)
        fa[i]=i;
    for (int i=1; i<=n; i++)
        scanf("%d",a+i);
}
 
void solve() {
    int x,y;
    for (int i=1; i<=m; i++) {
        scanf("%d %d",&x,&y);
        int p=bcj(x), q=bcj(y);
        if (p!=q)
            fa[p]=q;
    }
    for (int i=1; i<=n; i++) {
        int p=bcj(i);
        res[p][a[i]]++;
    }
}
 
void print() {
    int ans=0;
    for (int i=1; i<=n; i++) {
        if (res[i][0]>res[i][1])
            ans+=res[i][1];
        else
            ans+=res[i][0];
    }
    printf("%d\n",ans);
}
 
int main() {
    init();
    solve();
    print();
    return 0;
}
```

---

## 作者：lyyi2003 (赞：9)

# 其实这题暴搜也能过。。。

暴力枚举每个点的状态，然后枚举每一个与它相邻的点，根据已确定的相邻点的状态计算贡献，然后贪心的选择冲突数较小的状态先搜索，然后再搜另一种，这样加一个最优化减枝可以直接拿到80分。然后再加一个优化，即对于还未确定的相邻点的状态，如果它原来的意愿和当前点选择的不同，先计算1的贡献，之后再减去，这样就能拿到100分了。。。

代码：

```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
using namespace std;
#define N 507
const int inf=1e9;
int a[N],b[N],n,ans;
bool vis[N];
vector<int> e[N];
void adde(int x,int y)
{
	e[x].push_back(y);
	e[y].push_back(x);
}
void dfs(int x,int d)
{
	if(d>=ans)return;
	if(x>n)
	{
		ans=min(ans,d);
		return ;
	}
	if(vis[x])d--;
	int s0=0,s1=0;
	vector<int> d0,d1;
	for(auto u:e[x])
	{
		if(u>x)
		{
			if(!vis[u])
			{
				if(a[u]==1)s0++,d0.push_back(u);
				else s1++,d1.push_back(u);
			}
		}
		else
		{
			if(b[u]==1)s0++;
			else s1++;
		}
	}
	//printf("%d %d\n",d0.size(),d1.size());
	if(a[x]==1)s0++;
	else s1++;
	if(s0<s1)
	{
		for(auto u:d0)vis[u]=true;
		b[x]=0;dfs(x+1,d+s0);
		for(auto u:d0)vis[u]=false;
		for(auto u:d1)vis[u]=true;
		b[x]=1;dfs(x+1,d+s1);
		for(auto u:d1)vis[u]=false;
	}
	else
	{
		for(auto u:d1)vis[u]=true;
		b[x]=1;dfs(x+1,d+s1);
		for(auto u:d1)vis[u]=false;
		for(auto u:d0)vis[u]=true;
		b[x]=0;dfs(x+1,d+s0);
		for(auto u:d0)vis[u]=false;
	}
}
int main()
{
	int m,i,x,y;
	//freopen("data.in","r",stdin);
	//freopen("test.out","w",stdout);
	scanf("%d%d",&n,&m);
	for(i=1;i<=n;i++)scanf("%d",&a[i]);
	for(i=1;i<=m;i++)
	{
		scanf("%d%d",&x,&y);
		adde(x,y);
	}
	ans=inf;
	dfs(1,0);
	printf("%d\n",ans);
	return 0;
}

```


---

## 作者：Yeji_ (赞：6)

## 善意的投票
### 前言
最近学习了网络流，发现在图论上面格外好用，现在来看一看这样的题，拓张一下知识

### 题意
就是让你求小盆友怎么样投票才能够使冲突数最小（~~很显然了~~）

###  思路
自古以来，网络流的板子永远是被oier们所铭记的，但是，如何建模（建边）一直就是一道难题。

所以，这道题我们就主要来讲一下，建模的方法

### 分析
嗯，这道题目的建模可以说是非常基础的了，其实真实难度最多只有一道蓝题。

不扯了，正式开始讲

明眼人直接发现是最小割，两种意见可以看作源点S和T，我们需要做的是割最少的边使得S和T成为两个不同的集合，

解释：割掉的边相当于1次冲突（因为若某边被割走，则显然这条边相连的两个点分别通向了S和T，所以算是一次冲突），

当S和T还连通时则必然存在一条路径，这样肯定会有冲突，所以需要使得S和T孤立。

所以就是求这道题目的最小割，而最小割就等于最大流，所一这道题最大流跑一跑就好了

### 建模
上文也说到，要建一个超级源点以及一个超级汇点，将其他的东西全部连上那么两个点。

这是，网络流里最最最基本的建图方法。所以必须熟悉的掌握

但是，在以后，也会遇到要拆点，而这个东西就比较难了，有一些高难度的题目都需要一些奇奇怪怪的拆点。例如：P1231

### 代码
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<queue>
#define N 2000005
#define INF 23333333
using namespace  std;
struct edge
{
    int v, next, c;
}edge[N];
int st[N], tot, s, t,d[N], n, m;
void add(int u, int v, int c)
{
    edge[tot].v = v;
    edge[tot].c = c;
    edge[tot].next = st[u];
    st[u] = tot ++;
}
void insert(int u, int v, int c)
{
    add(u, v, c);
    add(v, u, 0);
}
int bfs()
{
    memset(d, -1, sizeof d);
    queue<int> q;
    q.push(s);
    d[s] = 0;
    while(q.size())
    {
        int u = q.front(); q.pop();
        for(int i = st[u]; i + 1; i = edge[i].next)
        {
            int v = edge[i].v;
            if(edge[i].c && d[v] == -1)
            {
                d[v] = d[u] + 1;
                q.push(v);
            }
        }
    }
    return d[t] != -1;  
}
int dfs(int u, int flow)
{
    if(u == t) 
        return flow;
    int ret = 0;
    for(int i = st[u]; i + 1; i = edge[i].next)
    {
        int v = edge[i].v;
        if (edge[i].c && d[v] == d[u] + 1)
        {
            int tmst = dfs(v, min(flow, edge[i].c));
            flow -= tmst;
            edge[i].c -= tmst;
            edge[i^1].c += tmst;
            ret += tmst;
            if(!flow) 
                break;
        }
    }
    if(!ret) 
        d[u] = -1;
    return ret;
}
int Dinic()
{
    int maxn=0;
    for(;bfs();) 
        maxn+= dfs(s, INF);
    return maxn;
}
int main()
{
    memset(st,-1,sizeof st);
    tot=0;
    scanf("%d%d", &n, &m);
    s=0;t=n+1;
    int u,v,x;
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&x);
        if(x) 
            insert(i,t,1); 
        else 
            insert(s,i,1);
    }
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&u,&v);
        insert(u,v,1);
        insert(v,u,1);
    }
    printf("%d", Dinic());
}
```


---

## 作者：蒟蒻pks (赞：6)

题解被封的第一个题解

思路是楼下的 对于每对好朋友 建两条相互的边  跑一边最大流 就可以过了

先是80分纯dfs方法


```cpp
const oo=100000000;
var v:array[0..1000,0..1000] of longint;
    dinic:array[0..5000] of longint;
    boo:array[0..10000] of boolean;
    b,c,d,e,n,m,f,ans:longint;
function min(a1,a2:longint):longint;
begin
  if a1>a2 then exit(a2);
  exit(a1);
end;
function dfs(a1,a2:longint):longint;
var i,j,k:longint;
begin
  if a1=b+1 then
    exit(a2);
  for i:=1 to b+1 do
  if v[a1,i]>0 then
    if not boo[i] then
    begin
      boo[i]:=true;
      k:=dfs(i,min(a2,v[a1,i]));
      boo[i]:=false;
      if k>0 then
      begin
        dec(v[a1,i]);
        inc(v[i,a1]);
        exit(k);
      end;
     end;
  exit(0);
end;
procedure add(a1,a2:longint);
begin
  inc(v[a1,a2]);
end;
begin
  assign(input,'1.txt');
  assign(output,'2out.txt');
  reset(input);
  rewrite(output);
  readln(b,c);
  for d:=1 to b do
  begin
    read(f);
    if f=0 then add(0,d) else add(d,b+1);
  end;
  for c:=1 to c do
  begin
    readln(d,f);
    add(d,f);
    add(f,d);
  end;
  f:=dfs(0,oo);
  while f>0 do
  begin
    ans:=ans+f;
    f:=dfs(0,oo);
  end;
writeln(ans);
end.
```
用dinic优化 一次找到多条路径




```cpp
const oo=100000000;
var v:array[0..1000,0..1000] of longint;
    dinic:array[0..500] of longint;
    boo:array[0..1000] of boolean;
    b,c,d,e,n,m,f,ans:longint;
function min(a1,a2:longint):longint;
begin
  if a1>a2 then exit(a2);
  exit(a1);
end;
procedure chushihua;
var i,j:longint;
begin
  for i:=1 to b+1 do
    dinic[i]:=oo;
end;
function dfs(a1,a2:longint):longint;
var i,j,k,h:longint;
begin
  if a1=b+1 then exit(a2);
  k:=0;
  for i:=1 to b+1 do
  if (v[a1,i]>0)and (not boo[i]) and (dinic[i]=dinic[a1]+1) then
  begin
    boo[i]:=true;
    j:=dfs(i,min(a2,v[a1,i]));
    a2:=a2-j;
    boo[i]:=false;
    k:=k+j;
    dec(v[a1,i],j);
    inc(v[i,a1],j);
  end;
  exit(k)
end;
procedure bfs(a1:longint);
var i,j,k:longint;
begin
  for i:=1 to b+1 do
  if v[a1,i]>0 then
   if dinic[i]>(dinic[a1]+1) then
    begin
      dinic[i]:=dinic[a1]+1;
      bfs(i);
    end;
end;
procedure add(a1,a2:longint);
begin
  inc(v[a1,a2]);
end;
begin            {
  assign(input,'1.txt');
  reset(input);
  assign(output,'1out.txt');
  rewrite(output); }
  readln(b,c);
  for d:=1 to b do
  begin
    read(f);
    if f=0 then add(0,d) else add(d,b+1);
  end;
  for c:=1 to c do
  begin
    readln(d,f);
    add(d,f);
    add(f,d);
  end;
  chushihua;
  bfs(0);
  while dinic[b+1]<>oo do
  begin
    ans:=ans+dfs(0,oo);
    chushihua;
    bfs(0);
  end;
  writeln(ans);
end.
```

---

## 作者：zhy137036 (赞：3)

[题目](/problem/P2057)

这算是一个经典（？）的网络流建模题了吧。

写这篇题解主要是想记录一下建模的套路。

下面默认你已经会最大流了。

### 分析

题目求“最小的冲突数”，怎么求？

最大流似乎是用来求最大的，怎么求最小？

根据**最大流最小割定理**，如果残量网络已经没有增广路（即残量网络已经不连通了），那当前流就是最大流，同时也是最小割。

所以考虑建一个图，当这个图被分成至少两部分不连通时，得到最小割，即最小的冲突数。

于是想到，当这个图不连通时，和源点在同一连通子图中的结点，选择睡午觉，其余结点选择不睡午觉。

那可以考虑**给每个自己意愿是睡午觉的结点，连一条边到源点；给自己意愿是不睡午觉的结点，连一条边到汇点。**

这样，如果连向源点的边断了，说明选择不睡午觉，违背了本来的意愿；如果这条边没断，说明选择睡午觉。一次断边对应一次冲突。

那“好朋友”怎么体现呢？

如果一对好朋友，同时选择睡午觉，应该并不会断开一条边；如果一个选择睡午觉，一个选择不睡午觉，就应该断开一条边。

意思是：如果一对“好朋友结点”都和源点连通，应该不会断开一条边；如果这对点一个和源点连通，一个不连通，就应该断开一条边。

建模方法不就出来了吗：**给每对“好朋友结点”连一条边**。如果这对点都和源点连通，这条边就不会断；如果这对点一个连通一个不连通，那这条边肯定会断。

然而这个图也有可能断成三部分、四部分或者更多。

不过根据割的定义，只要**将图的点分成两个集合，源点和汇点分别属于两个集合，且两个集合直接不连通**就行了，并没有要求集合内部是连通的。

比如 $S$ 集合定义为和源点连通的结点，那么其余的结点虽然不一定和汇点连通，但都在 $T$ 集合里，所以不用考虑 $T$ 集合内部断边造成的问题。（$T$ 集合内部断开的边不算进割中）

### 核心代码

（去掉最大流板子）

```cpp
int main(){
	cin>>n>>m; S=n+1; T=n+2;
	//S 表示源点，T 表示汇点
	for(int i=1;i<=n;i++){
		int t; cin>>t;
		if(t) add(S,i,1);//如果本来意愿是睡午觉，就连到源点
		//add(u,v,w) 表示连一条 (u,v) 的边，流量限制是 w
		else add(i,T,1);//如果本来意愿是不睡午觉，就连到汇点
	}
	for(int i=1;i<=m;i++){
		int u,v; cin>>u>>v;
		add(u,v,1); add(v,u,1);//给每对好朋友结点连一条双向边
	}
	n+=2;//将源点和汇点算到 n 里
	//运行最大流
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：tzc_wk (赞：2)

网络流之最小割

安利个人 [blog](https://www.luogu.com.cn/blog/et2006/wang-lao-liu-hao-ti-ti-xie-hui-zong)

这道题有些意思。

建图非常简单：

1. 对于每个同学 $i$，如果他不同意，就连边 $(S,i,1)$，否则连边 $(i,T,1)$。
2. 对于每一对好朋友 $(a,b)$，连边 $(a,b,1)$ 和 $(b,a,1)$。

然后跑最小割即最大流就行了。

为什么这样就对了呢？首先，我们定义如果不割掉 $i$ 与 $S/T$ 之间的边，就表明第 $i$ 个学生的选择与他的意愿相符，否则说明第 $i$ 个学生的选择与他的意愿不符。如果不割掉好朋友之间的边就表明它们的意愿一致，否则说明它们的意愿不一致。

然后我们看一下如果存在 $S$ 到 $T$ 的路径会推出什么矛盾：假设有一条路径 $S \rightarrow i \rightarrow j \rightarrow T$，那么 $i$ 的选择与他的意愿相同，都是不同意，$j$ 的选择与他的意愿也相同，都是同意，而存在 $i \rightarrow j$ 的边，说明 $i$ 与 $j$ 的选择相同，矛盾！

```cpp
/*
数据不清空，爆零两行泪。
多测不读完，爆零两行泪。
边界不特判，爆零两行泪。
贪心不证明，爆零两行泪。
D P 顺序错，爆零两行泪。
大小少等号，爆零两行泪。
变量不统一，爆零两行泪。
越界不判断，爆零两行泪。
调试不注释，爆零两行泪。
溢出不 l l，爆零两行泪。
*/
#include <bits/stdc++.h>
using namespace std;
#define fi			first
#define se			second
#define fz(i,a,b)	for(int i=a;i<=b;i++)
#define fd(i,a,b)	for(int i=a;i>=b;i--)
#define foreach(it,v) for(__typeof(v.begin()) it=v.begin();it!=v.end();it++)
#define put(x)		putchar(x)
#define eoln        put('\n')
#define space		put(' ')
#define y1			y_chenxiaoyan_1
#define y0			y_chenxiaoyan_0
inline int read(){
	int x=0,neg=1;char c=getchar();
	while(!isdigit(c)){
		if(c=='-')	neg=-1;
		c=getchar();
	}
	while(isdigit(c))	x=x*10+c-'0',c=getchar();
	return x*neg;
}
inline void print(int x){
	if(x<0){
		putchar('-');
		print(abs(x));
		return;
	}
	if(x<=9)	putchar(x+'0');
	else{
		print(x/10);
		putchar(x%10+'0');
	}
}
inline int qpow(int x,int e,int _MOD){
	int ans=1;
	while(e){
		if(e&1)	ans=ans*x%_MOD;
		x=x*x%_MOD;
		e>>=1;
	}
	return ans;
}
int head[20005];
struct edge{
	int to,nxt,cap;
} e[3000005];
int ecnt=1;
inline void addedge(int u,int v,int f){
	e[++ecnt].to=v;e[ecnt].cap=f;e[ecnt].nxt=head[u];head[u]=ecnt;
}
int dep[20005];
inline bool bfs(int s,int t){
	queue<int> q;
	memset(dep,-1,sizeof(dep));
	q.push(s);dep[s]=0;
	while(!q.empty()){
		int cur=q.front();q.pop();
		for(int i=head[cur];i;i=e[i].nxt){
			int to=e[i].to;
			if(dep[to]==-1&&e[i].cap){
				dep[to]=dep[cur]+1;
				q.push(to);
			}
		}
	}
	if(dep[t]!=-1)	return 1;
	return 0;
}
inline int dfs(int x,int t,int f){
	if(x==t)	return f;
	int ret=0;
	for(int i=head[x];i;i=e[i].nxt){
		int y=e[i].to;
		if(dep[y]==dep[x]+1&&e[i].cap){
			int w=dfs(y,t,min(f-ret,e[i].cap));
			e[i].cap-=w;
			e[i^1].cap+=w;
			ret+=w;
			if(ret==f)	return f;
		}
	}
	if(ret==0)	dep[x]=-1;
	return ret;
}
inline int Dinic(int s,int t){
	int tot=0;
	while(bfs(s,t))	tot+=dfs(s,t,0x3f3f3f3f);
	return tot;
}
int n=read(),m=read();
signed main(){
	fz(i,1,n){
		int x=read();
		if(x==0)	addedge(0,i,1),addedge(i,0,0);
		else		addedge(i,n+1,1),addedge(n+1,i,0);
	}
	fz(i,1,m){
		int x=read(),y=read();
		addedge(x,y,1);addedge(y,x,0);addedge(y,x,1);addedge(x,y,0);
	}
	cout<<Dinic(0,n+1)<<endl;
	return 0;
}
```

---

## 作者：crescentic (赞：2)


最近做网络流都快做吐了。。。


------------

[善意的投票](https://www.luogu.com.cn/problem/P2057)

常规的最小割问题，只是建边略微有些巧妙。

**题目分析**:

- 第一步，先确定源点和汇点。常规思路：将源点看作**同意**，汇点看作**不同意**；

因为题目要求最小**冲突数**，什么意思呢？分析一下，其实就是让你求建好网络流的最小割。

**原因**: 

因为已经确定了源点为**同意**，汇点为**不同意**，所以连向源点的边意为**同意**，汇点则相反。

那么如果任意一点既可以通向源点，又可以通向汇点，就说明这个点是冲突的（有两种选择）感性理解一下。

因此，要使其不冲突，就要让源点 $s$ 和汇点 $t$ 不联通。所以冲突数就是 $s$ 和 $t$ 之间相互联通的边。那么，**最小割**了解一下？

- 第二步，连边。先将小盆友们本来的意愿连边，同意连向源点，不同意连汇点。然后，如果两个小盆友是好伙伴，说明两人可以**相互**影响，所以在她们之间连一条**无向边**；

- 最后，模板计算最小割。这个不用讲了吧。溜啦~



**完整代码** :

```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cstring>
using namespace std;
#define rt register int
const int N = 310,M = 8e4, inf = 1e9;
struct node {
	int to,nex;
}e[M];
int n,m,s,t,top,ed,dep[N],head[N],cur[N],tot = 1,f[M],q[N];
inline void add(int x,int y,int w,int w2) {
	e[++tot] = (node) {y,head[x]}, f[tot] = w, head[x] = tot;
	e[++tot] = (node) {x,head[y]}, f[tot] = w2, head[y] = tot; 
}
inline bool bfs() {
	memset(dep,-1,sizeof(dep));
	dep[s] = 0, cur[s] = head[s], q[top = 1] = s; ed = 1;
	int now,ver;
	while(top <= ed) {
		now = q[top++];
		for(rt i = head[now]; i; i = e[i].nex) {
			ver = e[i].to;
			if(dep[ver] == -1 && f[i]) {
				dep[ver] = dep[now] + 1, cur[ver] = head[ver];
				if(ver == t) return 1;
				q[++ed] = ver;
			}
		}
	}
	return 0;
}
inline int find(int x,int limit) {
	if(x == t) return limit;
	int flow = 0, tmp, ver;
	for(rt i = head[x]; i && flow < limit; i = e[i].nex) {
		ver = e[i].to;
		if(dep[ver] == dep[x] + 1 && f[i]) {
			tmp = find(ver,min(limit - flow,f[i]));
			if(!tmp) dep[ver] = -1;
			f[i] -= tmp, f[i ^ 1] += tmp, flow += tmp; 
		}
	}
	return flow;
}
inline int dinic() {
	int res = 0, flow;
	while(bfs()) res += find(s,inf);
	return res;
}
inline void read(int &x) {
	x = 0;int ff = 1;
	char s = getchar();
	while(s < '0' || s > '9') {
		if(s == '-') ff = -1;
		s = getchar();
	}
	while(s <= '9' && s >= '0') {x = x * 10 + s - '0', s = getchar(); }
	x *= ff;
}
signed main() {
	read(n), read(m);
	int u,v;
	s = n + 1, t = s + 1;
	for(rt i = 1; i <= n; i ++) {
		read(u);
		if(u) add(s,i,1,0);
		else add(i,t,1,0);
	}
	for(rt i = 1; i <= m; i ++) {
		read(u), read(v);
		add(u,v,1,1);
	}
	printf("%d",dinic());
	return 0;
} 
```



---

## 作者：ysy20021208 (赞：1)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**分析与题解：**我们定义和$S$直接相连的点表示睡午觉，和$T$直接相连的点表示不睡午觉。若第$i$个小朋友意见是睡午觉，我们便把$i$和$S$相连，边权为$0$，把$i+n$和$T$相连，边权为$1$，这样表示这个小朋友要是选择睡午觉便不会对答案贡献$1$，反之会对答案贡献$1$。若第$i$个小朋友意见是不睡午觉，我们便把$i$和$S$相连，边权为$1$，把$i+n$和$T$相连，边权为$0$，这样表示这个小朋友要是选择不睡午觉便不会对答案贡献$1$，反之会对答案贡献$1$。这样我们便把这个小朋友和自己的意愿相反的情况对于答案的贡献处理完毕。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于两个不同的小朋友，我们考虑把他们互相连在一起，因为是只有不同的情况下才会产生贡献，所以$i$和$j+n$连一条边权为$1$的边，$j$和$i+n$连一条边权为$1$的边（$i$和$j$是好朋友）。这样建出来的图就可以处理这个问题了，最小割就是答案。

```c++
// luogu-judger-enable-o2
#include <queue>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
#define N 1010
#define inf 1000000000
int n,m,ans,idx=1,dis[N],cur[N<<1],s,t;
int head[N<<1],to[N*N<<2],val[N*N<<2],nxt[N*N<<2];
void add(int a,int b,int c)
    {nxt[++idx]=head[a],head[a]=idx,to[idx]=b,val[idx]=c;}
bool bfs()
{
    memset(dis,-1,sizeof dis),dis[s]=0;
    queue <int> q; q.push(s);
    while(!q.empty())
    {
        int p=q.front();q.pop();
        if(p==t) return true;
        for(int i=head[p];i;i=nxt[i])
            if(val[i]>0&&dis[to[i]]==-1)
                dis[to[i]]=dis[p]+1,q.push(to[i]);
    } return false;
}
int dfs(int p,int flow)
{
    int now,temp=flow;
    if(p==t) return flow;
    for(int i=cur[p];i;i=nxt[i])
        if(val[i]>0&&dis[to[i]]==dis[p]+1)
        {
            now=dfs(to[i],min(val[i],temp));
            if(!now) dis[to[i]]=-1;
            temp-=now,val[i]-=now,val[i^1]+=now;
            if(val[i]) cur[p]=i;
            if(!temp) break;
        } return flow-temp;
}
void dinic() {while(bfs()) memcpy(cur,head,sizeof(head)),ans+=dfs(s,inf);}
int main()
{
    scanf("%d%d",&n,&m),s=n*2+1,t=n*2+2;
    for(int i=1,a;i<=n;i++)
        scanf("%d",&a),(a==1)?(add(s,i,1),add(i,s,0)):(add(i+n,t,1),add(t,i+n,0));
    for(int i=1,a,b;i<=m;i++)
        scanf("%d%d",&a,&b),add(a,b+n,1),add(b+n,a,0),add(b,a+n,1),add(a+n,b,0);
    dinic();printf("%d\n",ans);
}
```

---

## 作者：lzy再lzy (赞：1)

这道题就是就一个经典的“二者取其一式问题”。每个小朋友若是赞成，建一条（s，i，1）,否则建一条（i,t,1）;对一对朋友i,j而言，建（i,j,1）,(j,i,1),然后跑最大流求个最小割即可。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
#include<queue>
#include<cstdlib>
using namespace std;
const int INF=1e9;
int n,m,str,end;
struct edge{
    int from,to,cap,flow;
};
vector<edge>edges;
vector<int>g[150010];
queue<int>q;
int vis[150010],d[150010],cur[150010],s[310];
void add(int a,int b,int c,int d)
{
    edges.push_back((edge){a,b,c,d});
    edges.push_back((edge){b,a,0,0});
    int t=edges.size();
    g[b].push_back(t-1);
    g[a].push_back(t-2);
}
bool bfs()
{
    memset(vis,0,sizeof(vis));
    q.push(str);vis[str]=1;
    while(!q.empty())
    {
        int x=q.front();
        q.pop();
        for(int i=0;i<g[x].size();i++)
        {
            edge &e=edges[g[x][i]];
            if(e.cap>e.flow&&!vis[e.to])
            {
                vis[e.to]=1;
                d[e.to]=d[x]+1;
                q.push(e.to);
            }
        }
    }
    return vis[end];
}
int dfs(int x,int t)
{
    if(x==end||t==0)return t;
    int flow=0,f;
    for(int &i=cur[x];i<g[x].size();i++)
    {
        edge &e=edges[g[x][i]];
        if(d[e.to]==d[x]+1&&(f=dfs(e.to,min(e.cap-e.flow,t))))
        {
        //    printf("a");
            e.flow+=f;
            edges[g[x][i]^1].flow-=f;
            flow+=f;
            t-=f;
            if(t==0)break;
        }
    }
    return flow;
}
int maxflow()
{
    int flow=0;
    while(bfs())
    {
        memset(cur,0,sizeof(cur));
        flow+=dfs(str,INF);
    }
    return flow;
}
int main()
{
   freopen("2057.in","r",stdin);
   freopen("2057.out","w",stdout);
   scanf("%d%d",&n,&m);
   str=n+1;end=n+2;
   for(int i=1;i<=n;i++)
   {
    scanf("%d",&s[i]);
    if(s[i]==1)
    {
        add(str,i,1,0);
    }
    else
    add(i,end,1,0);
   }
   int a,b;
   for(int i=1;i<=m;i++)
   {
        scanf("%d%d",&a,&b);
        add(a,b,1,0);
        add(b,a,1,0);
   }
   printf("%d\n",maxflow());
   fclose(stdin);
   fclose(stdout);
   return 0;
}

```

---

## 作者：⚡114514_zzm⚡ (赞：0)

#### 题目要求：
让违背意愿的人数+好朋友之间的冲突数，最小。我们考虑让违背意愿的人和冲突的好朋友都付出大小为1的代价，那么只要计算代价的最小值即为答案。

#### 解决办法：
可以建立源点 s 和汇点 t ，我们考虑让最终源点一侧的割集代表选择同意睡觉的人，让汇点一侧的割集代表反对睡觉的人，源点 s 向代表最初同意睡觉的所有人对应的点连容量为1的边，反对睡觉的所有人对应的点向汇点连容量为1的边，好朋友 (i,j) 之间，从 i 向 j 和从 j 向 i 分别连容量为1的边。                 

这样，求s 到 t的最小割，如果两个好朋友之间有边且最初的意愿不同，为了割断 s,t，要么其中一人改变意愿（即割掉其与源点或汇点的边），要么他们之间发生冲突（即割断好朋友之间的一条单边），无论哪种选择都会付出相应的代价。因此最终求出的最小割就是相应的最小代价。          

```
#include<bits/stdc++.h>
#define maxm 100010
#define maxn 400
#define inf (~0U>>1)
using namespace std;
int n,m,source,sink,l,ans;
int last[maxn],other[maxm<<1],len[maxm<<1],pre[maxm<<1],flag[maxn];
int que[maxn],d[maxn];
void connect(int x,int y,int z) {
	pre[++l]=last[x];
	last[x]=l;
	other[l]=y;
	len[l]=z;
}
bool bfs() {
	memset(d,0,sizeof d);
	que[1]=source; d[source]=1;
	int h=0,t=1;
	while (h<t) {
		int cur=que[++h];
		for (int p=last[cur];p;p=pre[p]) {
			if (d[other[p]]) continue;
			if (!len[p]) continue;
			d[other[p]]=d[cur]+1;
			que[++t]=other[p];
			if (other[p]==sink) return 1;
		}
	}
	return 0;
}
int dinic(int x,int flow) {
	if (x==sink) return flow;
	int rest=flow;
	for (int p=last[x];p;p=pre[p]) {
		if (!len[p]) continue;
		if (d[other[p]]!=d[x]+1) continue;
		if (!rest) continue;
		int tmp=dinic(other[p],min(len[p],rest));
		if (!tmp) d[other[p]]=0;
		len[p]-=tmp; len[p^1]+=tmp;
		rest-=tmp;
	}
	return flow-rest;
}
int main() {
	scanf("%d%d",&n,&m);
	source=n+2; sink=source+1; l=1;
	for (int i=1;i<=n;i++) {
		scanf("%d",&flag[i]);
		if (flag[i]) connect(source,i,1),connect(i,source,0); else
		connect(i,sink,1),connect(sink,i,0);
	}
	for (int i=1;i<=m;i++) {
		int x,y; scanf("%d%d",&x,&y);
		connect(x,y,1); connect(y,x,0);
		connect(y,x,1); connect(x,y,0);
	}
	while (bfs()) ans+=dinic(source,inf);
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：muller (赞：0)

其实这题和狼和羊的故事差不多

都是最小割

我们只要对于原图建一个源点，汇点

那道题是

源点向所有狼连流量 oo 的边

所有羊向汇点连流量 oo 的边

所有点向四周能到达连流量为 1 的边。

这道题是

不同意见的连边

好友直接也连边

可以理解一下，消耗一流量可以减少一对冲突，让彼此达成共识

所以也是一个最小割

上代码：

```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
using namespace std;
const int N = 50005, M = N << 4, inf = 1 << 30;
int to[M], nxt[M], len[M], inv[M], fir[N], cur[N], lev[N], q[N];
int S, T, ecnt;
bool vis[N];
void ae(int u, int v, int w) {
    to[++ecnt] = v; nxt[ecnt] = fir[u]; len[ecnt] = w; inv[ecnt] = ecnt + 1; fir[u] = ecnt;
    to[++ecnt] = u; nxt[ecnt] = fir[v]; len[ecnt] = 0; inv[ecnt] = ecnt - 1; fir[v] = ecnt;
}
bool make_level() {
    int l, r, u, v, w, i;
    memset(vis, false, sizeof(vis));
    for (i = S; i <= T; ++i) cur[i] = fir[i];
    q[l = r = 1] = S; lev[S] = 0; vis[S] = true;
    while (l <= r) {
        u = q[l++];
        for (i = fir[u]; i; i = nxt[i]) {
            v = to[i]; w = len[i];
            if (w && !vis[v]) {
                lev[v] = lev[u] + 1;
                vis[q[++r] = v] = true;
            }
        }
    }
    return vis[T];
}
int dinic(int u, int lim) {
    if (u == T) return lim;
    int tmp, ret = 0, v, w, i;
    for (i = cur[u]; i; i = nxt[i]) {
        v = to[i]; w = len[i];
        if (w && lev[v] == lev[u] + 1) {
            tmp = dinic(v, min(w, lim));
            len[i] -= tmp; len[inv[i]] += tmp;
            ret += tmp; lim -= tmp;
            if (!lim) {cur[u] = i; return ret;}
        }
    }
    cur[u] = 0; return ret;
}
int main() {
    int n, m, i, x, y, ans = 0;
    scanf("%d%d", &n, &m);
    S = 0; T = n + 1;
   	for (i = 1; i <= n; ++i) {
   		scanf("%d", &x);
   		if (x == 1) ae(S, i, 1); else ae(i, T, 1);
   	}
   	for (i = 1; i <= m; ++i) {
   		scanf("%d%d", &x, &y);
		ae(x, y, 1); ae(y, x, 1);	
	}
    while (make_level()) ans += dinic(S, inf);
    printf("%d\n", ans);
    return 0;
}

```


---

## 作者：yzhang (赞：0)

### [更好的阅读](https://www.cnblogs.com/yzhang-rp-inf/p/10316523.html )

### [原题传送门](https://www.luogu.org/problemnew/show/P2057)

我们一眼就能看出这是一道最小割的题

我们设不睡觉这种状态为S，睡觉这种状态为T

对于每个人，如果不想睡觉，就从S向这个人连流量为1的边，否则，就从这个人向T连流量为1的边

对于每一对朋友，互相连流量为1的边

最后答案就是这个图的最小割，即最大流（自己画图想一想）

随便写个ISAP就行了

```cpp
#include <bits/stdc++.h>
#define N 305
#define M 90005
#define inf (1<<30)
#define getchar nc
using namespace std;
inline char nc(){
    static char buf[100000],*p1=buf,*p2=buf; 
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++; 
}
inline int read()
{
    register int x=0,f=1;register char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    return x*f;
}
inline void write(register int x)
{
    if(!x)putchar('0');if(x<0)x=-x,putchar('-');
    static int sta[20];register int tot=0;
    while(x)sta[tot++]=x%10,x/=10;
    while(tot)putchar(sta[--tot]+48);
}
inline int Min(register int a,register int b)
{
    return a<b?a:b;
}
struct node{
    int to,next,v;
}e[M<<1];
int head[N],cnt=1;
inline void add(register int u,register int v,register int val)
{
    e[++cnt]=(node){v,head[u],val};
    head[u]=cnt;
} 
int n,m,s,t,maxflow=0;
int dep[N],gap[N],cur[N];
inline void bfs()
{
    memset(dep,-1,sizeof(dep));
    memset(gap,0,sizeof(gap));
    dep[t]=0;
    ++gap[dep[t]];
    queue<int> q;
    q.push(t);
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        for(register int i=head[u];i;i=e[i].next)
        {
            int v=e[i].to;
            if(dep[v]!=-1)
                continue;
            q.push(v);
            dep[v]=dep[u]+1;
            ++gap[dep[v]];
        }
    }
}
inline int dfs(register int u,register int flow)
{
    if(u==t)
    {
        maxflow+=flow;
        return flow;
    }
    int used=0;
    for(register int i=cur[u];i;i=e[i].next)
    {
        cur[u]=i;
        int v=e[i].to;
        if(e[i].v&&dep[v]+1==dep[u])
        {
            int tmp=dfs(v,Min(e[i].v,flow-used));
            if(tmp)
            {
                e[i].v-=tmp;
                e[i^1].v+=tmp;
                used+=tmp;
            }
            if(used==flow)
                return used;
        }
    }
    --gap[dep[u]++]==0?dep[s]=n+1:++gap[dep[u]];
    return used;
}
inline void ISAP()
{
    maxflow=0;
    bfs();
    while(dep[s]<n)
    {
        memcpy(cur,head,sizeof(head));
        dfs(s,inf);
    }
}
int main()
{
    n=read(),m=read();
    s=0,t=n+1;
    for(register int i=1;i<=n;++i)
    {
        int x=read();
        if(x)
            add(i,t,1),add(t,i,0);
        else
            add(s,i,1),add(i,s,0);
    }
    for(register int i=1;i<=m;++i)
    {
        int u=read(),v=read();
        add(u,v,1),add(v,u,1);
    }
    n+=2;
    ISAP();
    write(maxflow);
    return 0;
}
```

---

## 作者：SGColin (赞：0)

解法同 [[SHOI2007]善意的投票](https://www.luogu.org/problemnew/show/P2057) 。

因为每个人最终只会有一个意见，所以**不用拆点。**

直接把认同的给S集，不认同的给T集，朋友之间连正反容量都为 $1$ 的边即可。

割掉连S的代表认同的改成不认同的。

割掉连T的代表不认同的改成认同的。

割掉中间的代表朋友产生矛盾。

注意到朋友边无效当且仅当连接的两点属于一个集合，当一个人改变集合选择时，这条无效边就会有效，而网络流的自我调整性实质上解决了这一点。

```C++
#include<cstdio>
#include<cctype>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<algorithm>
#define N 310
#define M 200010
#define R register
#define gc getchar
#define inf 2000000000
using namespace std;

inline int rd(){
  int x=0; bool f=0; char c=gc();
  while(!isdigit(c)){if(c=='-')f=1;c=gc();}
  while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=gc();}
  return f?-x:x;
}

int n,m,k,sum,S,T,U,V,tot=1,hd[N];

struct edge{int to,nxt,f;}e[M<<1];

inline void add(int u,int v,int f){
  e[++tot].to=v; e[tot].f=f; e[tot].nxt=hd[u]; hd[u]=tot;
  e[++tot].to=u; e[tot].f=0; e[tot].nxt=hd[v]; hd[v]=tot;
}

inline void addu(int u,int v,int f){
  e[++tot].to=v; e[tot].f=f; e[tot].nxt=hd[u]; hd[u]=tot;
  e[++tot].to=u; e[tot].f=f; e[tot].nxt=hd[v]; hd[v]=tot;
}

struct Q{
  int x[N*10],hd,tl;
  inline void pop(){++hd;}
  inline void reset(){hd=1;tl=0;}
  inline int front(){return x[hd];}
  inline bool empty(){return hd>tl;}
  inline void push(int a){x[++tl]=a;}
}q;

bool use[N];

int d[N],h[N];

inline bool bfs(){
  for(R int i=S;i<=T;++i) d[i]=0;
  q.reset(); q.push(S); d[S]=1;
  while(!q.empty()){
    int u=q.front(); q.pop();
    for(R int i=hd[u],v;i;i=e[i].nxt)
      if(e[i].f&&!d[v=e[i].to]){
        d[v]=d[u]+1; q.push(v);
      }
  }
  return d[T]>0;
}

int dfs(int u,int flow){
  if(u==T||!flow) return flow;
  int res=0,tmp;
  for(R int &i=h[u],v;i;i=e[i].nxt)
    if(e[i].f&&d[v=e[i].to]==d[u]+1){
      tmp=dfs(v,min(flow-res,e[i].f));
      if(!tmp){d[v]=-1;continue;}
      res+=tmp; e[i].f-=tmp; e[i^1].f+=tmp;
      if(flow==res) return res;
    }
  return res;
}

inline int dinic(){
  int totf=0;
  while(bfs()){
    memcpy(h,hd,sizeof(hd));
    totf+=dfs(S,inf);
  }
  return totf;
}

int main(){
  n=rd(); m=rd(); S=0; T=n+1;
  for(R int i=1;i<=n;++i)
    rd()>0?add(S,i,1):add(i,T,1);
  for(R int i=1;i<=m;++i) addu(rd(),rd(),1);
  printf("%d\n",dinic());
  return 0;
}

```

---

## 作者：lahlah (赞：0)

##### 额，你们懂的 

这题还是挺有启发性~~（套路）~~的

### 思路
#### 将是否睡午觉分别作为源点和汇点，然后把每个人作为点向他们的选择连容量为1的边，然后py（朋友）之间也连容量为1的边，那么问题可以转换为断掉最少的边（即产生冲突），使得所有点分成两个集合.

#### 这就很明显了，就是最小割嘛

样例如下图
![](https://i.loli.net/2019/01/01/5c2b623314237.png)

```cpp
#include<bits/stdc++.h>
#define N 2000005
#define INF 23333333
using namespace std;
struct edge{
    int v, nxt, c;
}e[N];
int p[N], eid, S, T;
void init(){
    memset(p, -1, sizeof p);
    eid = 0;
}
void add(int u, int v, int c){
    e[eid].v = v;
    e[eid].c = c;
    e[eid].nxt = p[u];
    p[u] = eid ++;
}
void insert(int u, int v, int c){
    add(u, v, c);
    add(v, u, 0);
}
int d[N], n, m;
int bfs(){
    memset(d, -1, sizeof d);
    queue<int> q;
    q.push(S);
    d[S] = 0;
    while(q.size()){
        int u = q.front(); q.pop();
        for(int i = p[u]; i + 1; i = e[i].nxt){
            int v = e[i].v;
            if(e[i].c && d[v] == -1){
                d[v] = d[u] + 1;
                q.push(v);
            }
        }
    }
    return d[T] != -1;	
}
int dfs(int u, int flow){
    if(u == T) return flow;
    int ret = 0;
    for(int i = p[u]; i + 1; i = e[i].nxt){
        int v = e[i].v;
        if(e[i].c && d[v] == d[u] + 1){
            int tmp = dfs(v, min(flow, e[i].c));
            flow -= tmp;
            e[i].c -= tmp;
            e[i^1].c += tmp;
            ret += tmp;
            if(!flow) break;
        }
    }
    if(!ret) d[u] = -1;
    return ret;
}
int Dinic(){
    int ret = 0;
    for(;bfs();) ret += dfs(S, INF);
    return ret;
}
int main(){
    init();
    scanf("%d%d", &n, &m);
    S = 0, T = n + 1;
    for(int i = 1; i <= n; i ++){
        int x;
        scanf("%d", &x);
        if(x) insert(i, T, 1); //如果睡就向源点连边 
        else insert(S, i, 1);//否则向汇点连边 
    }
    for(int i = 1; i <= m; i ++){
        int u, v;
        scanf("%d%d", &u, &v);
        insert(u, v, 1);//py之间连双向边 
        insert(v, u, 1);
    }
    printf("%d", Dinic());//然后跑最大流   最大流 = 最小割 
    return 0;
}
```


---

## 作者：ysy20021208 (赞：0)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**分析与题解：**我们定义和$S$直接相连的点表示睡午觉，和$T$直接相连的点表示不睡午觉。若第$i$个小朋友意见是睡午觉，我们便把$i$和$S$相连，边权为$0$，把$i+n$和$T$相连，边权为$1$，这样表示这个小朋友要是选择睡午觉便不会对答案贡献$1$，反之会对答案贡献$1$。若第$i$个小朋友意见是不睡午觉，我们便把$i$和$S$相连，边权为$1$，把$i+n$和$T$相连，边权为$0$，这样表示这个小朋友要是选择不睡午觉便不会对答案贡献$1$，反之会对答案贡献$1$。这样我们便把这个小朋友和自己的意愿相反的情况对于答案的贡献处理完毕。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于两个不同的小朋友，我们考虑把他们互相连在一起，因为是只有不同的情况下才会产生贡献，所以$i$和$j+n$连一条边权为$1$的边，$j$和$i+n$连一条边权为$1$的边（$i$和$j$是好朋友）。这样建出来的图就可以处理这个问题了，最小割就是答案。

```c++
// luogu-judger-enable-o2
#include <queue>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
#define N 1010
#define inf 1000000000
int n,m,ans,idx=1,dis[N],cur[N<<1],s,t;
int head[N<<1],to[N*N<<2],val[N*N<<2],nxt[N*N<<2];
void add(int a,int b,int c)
    {nxt[++idx]=head[a],head[a]=idx,to[idx]=b,val[idx]=c;}
bool bfs()
{
    memset(dis,-1,sizeof dis),dis[s]=0;
    queue <int> q; q.push(s);
    while(!q.empty())
    {
        int p=q.front();q.pop();
        if(p==t) return true;
        for(int i=head[p];i;i=nxt[i])
            if(val[i]>0&&dis[to[i]]==-1)
                dis[to[i]]=dis[p]+1,q.push(to[i]);
    } return false;
}
int dfs(int p,int flow)
{
    int now,temp=flow;
    if(p==t) return flow;
    for(int i=cur[p];i;i=nxt[i])
        if(val[i]>0&&dis[to[i]]==dis[p]+1)
        {
            now=dfs(to[i],min(val[i],temp));
            if(!now) dis[to[i]]=-1;
            temp-=now,val[i]-=now,val[i^1]+=now;
            if(val[i]) cur[p]=i;
            if(!temp) break;
        } return flow-temp;
}
void dinic() {while(bfs()) memcpy(cur,head,sizeof(head)),ans+=dfs(s,inf);}
int main()
{
    scanf("%d%d",&n,&m),s=n*2+1,t=n*2+2;
    for(int i=1,a;i<=n;i++)
        scanf("%d",&a),(a==1)?(add(s,i,1),add(i,s,0)):(add(i+n,t,1),add(t,i+n,0));
    for(int i=1,a,b;i<=m;i++)
        scanf("%d%d",&a,&b),add(a,b+n,1),add(b+n,a,0),add(b,a+n,1),add(a+n,b,0);
    dinic();printf("%d\n",ans);
}
```

---


# [TJOI2011] 卡片

## 题目描述

桌子上有 $m$ 张蓝色卡片与 $n$ 张红色卡片，每张卡片上有一个大于 $1$ 的整数。现在你要从桌子上拿走一些卡片，分若干次拿。每次只能拿走一组卡片：这组卡片颜色不同，并且两张卡片上面的数字的最大公约数大于 $1$。问：最多可以从桌上拿走多少组卡片。

## 说明/提示

对 $100 \%$ 的数据：$1 \le T \le 100$，$1 \le m, n \le 500$，卡片上的数字大于 $1$，小于 ${10}^7$。

## 样例 #1

### 输入

```
7
4 3
2 6 6 15
2 3 5
2 3
4 9
8 16 32
4 2
4 9 11 13
5 7
5 5
2 3 5 1001 1001
7 11 13 30 30
10 10
2 3 5 7 9 11 13 15 17 29
4 6 10 14 18 22 26 30 34 38
20 20
195 144 903 63 137 513 44 626 75 473
876 421 568 519 755 840 374 368 570 872
363 650 155 265 64 26 426 391 15 421
373 984 564 54 823 477 565 866 879 638
100 100
195 144 903 63 137 513 44 626 75 473
876 421 568 519 755 840 374 368 570 872
363 650 155 265 64 26 426 391 15 421
373 984 564 54 823 477 565 866 879 638
117 755 835 683 52 369 302 424 513 870
75 874 299 228 140 361 30 342 750 819
761 123 804 325 952 405 578 517 49 457
932 941 988 767 624 41 912 702 241 426
351 92 300 648 318 216 785 347 556 535
166 318 434 746 419 386 928 996 680 975
231 390 916 220 933 319 37 846 797 54
272 924 145 348 350 239 563 135 362 119
446 305 213 879 51 631 43 755 405 499
509 412 887 203 408 821 298 443 445 96
274 715 796 417 839 147 654 402 280 17
298 725 98 287 382 923 694 201 679 99
699 188 288 364 389 694 185 464 138 406
558 188 897 354 603 737 277 35 139 556
826 213 59 922 499 217 846 193 416 525
69 115 489 355 256 654 49 439 118 961```

### 输出

```
3
1
0
4
9
18
85```

# 题解

## 作者：YoungLove (赞：16)

数据给的貌似很良心，但事实根本不是这样的。。

正解是网络流，但模型建的不对可能会导致TLE，虽然数据规模看起来是能过的。

以上就是比较简单的网络流，用二分图也能解出来，但是n^2去建边是导致TLE的直接原因，因此我们就要考虑更换一种建模方式。

我们再来考虑，对于两个数字，如果他们的GCD>1，就意味着他们有至少一个共同的质因子，因此我们可以想，能否借助这个性质来建模呢?

我们可以先将每一个数都质因数分解，然后将所有出现过的质数都放在一个集合里，紧接着，对于每一个数字，我们将它与其所有的因子各建一条容量为1的弧(当然，数字颜色不同时弧的方向也是不同的)，然后超级源连向一种颜色，超级汇连向另外一种颜色，按照这样的模型再去跑Dinic，就可以通过了。

详细代码可以参见我的博客[Youngsc](http://youngscc.github.io/2017/10/11/[TJOI2011]%E5%8D%A1%E7%89%87/)。

(减少代码复制，共创美好洛谷)


---

## 作者：闲人 (赞：14)

# 一道网络流的题，重在建图  
[题目传送门](https://www.luogu.com.cn/problem/P2065)  
## 题目分析
首先，我们简化一下题面：  
- 有两堆数。 

- 一次只能在两堆中分别选一个数且不互质。  
- 求最多能取几次。  
- $1 \le n,m\le 500$  
## 错误解
其实比较容易理解，所以我们首先想到了用二分做：  
1. 如果一个蓝色数字和一个红色数字不互质，我们就把它们连起来。  

1. 然后用一个二分跑一遍，求出最大匹配。  

但是实际操作上是要T掉的，因为二分匹配有着 $O(nm)$ 的时间复杂度，加上连线的时间是一定会T掉的。
## 正解
然后啊，我就想到可以用网络流：  
1. 因为蓝色数字和红色数字互质时才可以配对，所以可以看成蓝色的数字和红色的数字是通过它们共同的质因数连接起来的。

1. 由于每一张牌只能用一次，所以每一条流的流量都为1。  
1. 我们把源点和每一个蓝色点连起来，把每一个红色点和汇点连起来，蓝色点和红色点由中间的质数点连起来。  
1. 最后跑一遍网络流就好了。 

其中在算质数点的时候，直接用试除法就可以了，不过感兴趣的同学可以了解一下Pollard's Rho算法。             

[Pollard's Rho](https://zhuanlan.zhihu.com/p/267884783)   

~~(不是我写的)~~  
## 建图
接下来，还有一个问题需要解决，就是我们应该如何给点标号呢？  

这里分享一种方法 ：  

因为中间的质数点个数我们是事先不知道的，所以标号红点应该放在通过蓝点算质数点的操作之后。  
由此可得：  
1. 源点为“0”号点，  

1. 蓝点编号为1到 blue，  
1. 质数点编号为 blue 到 blue + total，  
1. 红点编号为 blue + total 到 blue + total + red，  
1. 汇点编号为 blue + red + total + 1。  

下面是通过样例中第一个数据所建得图：

![1](https://cdn.luogu.com.cn/upload/image_hosting/rh9i74mf.png?x-oss-process=image/resize,m_lfit,h_170,w_225)  

## 代码
最后放上AC代码，希望可以帮助大家理解

Code:
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>

using namespace std;

const int N = 1000010, M = 2000010, INF = 1e9;

long long head[N], edge[M], next_[M], ver[M], tot;
int  q[N], d[N], cur[N];
int n, m, S, T;
int red, blue, total;
int p[35500], b[35500]; 

int min_(int x, int y){
	if(x < y) return x;
	return y;
}

void add(int x, int y, int z){
	ver[tot] = y, edge[tot] = z, next_[tot] = head[x], head[x] = tot ++;
	ver[tot] = x, edge[tot] = 0, next_[tot] = head[y], head[y] = tot ++;
}

void divide(int x, int e){								//用试除法找质数点并连接 
	
	int y = 0;
	for (int o = 2; o <= sqrt(x); o ++){
		if(x % o == 0) {
			p[++ y] = o;
			while (x % o == 0) x /= o;
		}
	}
	if(x > 1) p[++ y] = x;
	for(int o = 1;o <= y; o ++) {
		if(b[p[o]] != 0) add(e, b[p[o]] + red + blue, 1);
		else b[p[o]] = ++ total, add(e, b[p[o]] + red + blue, 1);
	}
	return ;
}

void divide_2(int x,int e){
	int y = 0;
	for (int o = 2; o <= sqrt(x); o ++){
		if(x % o == 0) {
			p[++ y] = o;
			while (x % o == 0) x /= o;
		}
	}
	if(x > 1) p[++ y] = x;
	for(int o = 1;o <= y; o ++) {
		if(b[p[o]] != 0) add(b[p[o]] + red + blue, e, 1);
	}
	return ;
}

bool bfs() {												
	int hh = 0, tt = 0;
	memset(d, -1, sizeof d);
	q[0] = S, d[S] = 0, cur[S] = head[S];
	while (hh <= tt) {
		int t = q[hh++];
		for (int i = head[t]; ~i; i = next_[i]) {
			int ver_ = ver[i];
			if (d[ver_] == -1 && edge[i]) {
				d[ver_] = d[t] + 1;
				cur[ver_] = head[ver_];						 
				if (ver_ == T) return true;
				q[++ tt] = ver_;
			}
		}
	}
	return false;   
}

int find(int u, int limit) {									 
	if(u == T) return limit;
   	int flow = 0;
	for (int i = cur[u]; ~i && flow < limit; i = next_[i]) {
		cur[u] = i;
		int ver_ = ver[i];
		if (d[ver_] == d[u] + 1 && edge[i]) {
			int t = find(ver_, min_(edge[i], limit - flow));
			if (!t) d[ver_] = -1;
			edge[i] -= t, edge[i ^ 1] += t, flow += t;
		}
	}
	return flow;
}

int dinic() {												 //dinic 跑网络流 
	int r = 0, flow;
	while (bfs()) while (flow = find(S, INF)) r += flow;
	return r;
}

int num;

int main(){
	cin >> num;
	
	for(int w = num; w > 0; w --){
		tot = 0;
		memset(head, -1, sizeof head);
		memset(p, 0, sizeof p);
		memset(b, 0, sizeof b);
		total = 0;
		cin >> blue >> red;
		for(int j = 1;j <= blue; j++){					//接点 
			add(0, j, 1);
		}
		for(int j = 1;j <= blue; j++){
			int blue_;
			cin >> blue_;
			divide(blue_, j);
		}
		for(int i = 1; i <= red; i++){
			int red_;
			cin >> red_;
			divide_2(red_, i + blue);
		}
		
		for(int i = 1; i <= red; i++){
			add(i + blue, red + blue + total + 1, 1);
		}
		S = 0;
		T = blue + red + total + 1;
		cout << dinic() << endl;
	}
	return 0;
}

```
## 后记
这道题我改了好久才过，怎么也没有想到是head数组没有初始化“-1”的原因，希望其他同学不要犯同样错误哦！

---

## 作者：LJ07 (赞：5)

## 题目描述
[题目传送门](https://www.luogu.com.cn/problem/P2065)

## 思路简述
+ 注意到拿走一组卡片的要求是：
1. 这组卡片颜色不同。
2. 两张卡片上面的数字的最大公约数大于1。
+ 颜色不同容易想到卡片可以变成一个二分图。具体地，根据颜色分成两个部分，然后根据第二个要求 `两张卡片上面的数字的最大公约数大于1` **暴力建边**。
+ 接下来就容易发现是求二分图最大匹配。使用匈牙利算法。
+ 然后提交，得到 $4$ 个 TLE 的好成绩。。。
+ 想到本算法的时间复杂度是 $O(Tnm)$ 的。而在实际使用中，匈牙利算法的时间复杂度往往是 $O(\texttt{可过})$，那么我们可以考虑**优化建边的过程**。
+ 而第二要求其实也等价于 **两个数能被一个不为1的正整数整除**，也可以等价于 **两个数能被一个相同的质数整除**。
+ 于是建边的做法就很显然了，将 $r[]$ 质因数分解，并且扔到相应的桶里。再将 $b[]$ 质因数分解，在相应的桶里连边。建图可以使用 set 替代 vector 避免重复建边。
+ 显然我们开 $10^7$ 级别个数的 vector 会 MLE, 我们可以使用 map 来开 vector ，即 ```map<int, vector<int> >```。

## 丑陋的代码
码量其实很小。

[click here](https://www.luogu.com.cn/paste/xuvkh0a4)

---

## 作者：斯德哥尔摩 (赞：5)

~~这题有毒啊。。。~~

裸的网络流，但是当你写完之后，你会发现提交可能会TLE*3。。。

为什么？

n^2建边看似能过，但实际不然，总复杂度最多为

O ( 100 × ( 500 × 500 × log500 + 500 × 500 × (边数) + (常数) ) ) ;

大数据肯定TLE啊。。。

于是想优化，怎么办呢？

我们发现，数字是不超过 10^7 的，于是我们可以将其分解质因数，将数字与其质因数连边，从蓝卡连到质因数，再连到红卡，流量为MAX。

再从源点连到蓝卡，红卡连到汇点，流量均为1，建图就完成了。

注意：都是有向边！

然后就可以跑网络流了。

附代码（Dinic）：
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<queue>
#include<cstring>
#define MAXN 100010
#define MAXM 10000010
#define MAX 999999999
using namespace std;
int n,m,k=0,s,t,c;
int x[MAXN],y[MAXN],head[MAXN<<1],deep[MAXN<<1],prime[MAXM];
bool np[MAXM];
struct node{//前向星——网络流就是要开大数组。。。
    int next,to,w;
}a[MAXM/10+9];
inline int read(){//读优
    int date=0,w=1;char c=0;
    while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
    while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}
    return date*w;
}
inline void add(int u,int v,int w){//加边
    a[c].to=v;a[c].w=w;a[c].next=head[u];head[u]=c++;
    a[c].to=u;a[c].w=0;a[c].next=head[v];head[v]=c++;//注意，反向边流量一定为0
}
bool bfs(){//分层图
    int u,v;
    queue<int> q;
    for(int i=s;i<=t;i++)deep[i]=0;
    deep[s]=1;
    q.push(s);
    while(!q.empty()){
        u=q.front();
        q.pop();
        for(int i=head[u];i;i=a[i].next){
            v=a[i].to;
            if(a[i].w&&!deep[v]){
                deep[v]=deep[u]+1;
                if(v==t)return true;//有增广路
                q.push(v);
            }
        }
    }
    return false;//没有增广路
}
int dfs(int x,int limit){//跑增广路
    if(x==t)return limit;
    int v,sum,cost=0;
    for(int i=head[x];i;i=a[i].next){
        v=a[i].to;
        if(a[i].w&&deep[v]==deep[x]+1){
            sum=dfs(v,min(a[i].w,limit-cost));
            if(sum>0){
                a[i].w-=sum;
                a[i^1].w+=sum;
                cost+=sum;
                if(cost==limit)break;
            }
            else deep[v]=-1;
        }
    }
    return cost;
}
int dinic(){//求最大流
    int ans=0;
    while(bfs())ans+=dfs(s,MAX);
    return ans;
}
inline void linkx(int x,int id){//从蓝卡连到质因数
    for(int i=1;i<=k&&prime[i]<=x;i++){
        if(x%prime[i]==0){
            add(id,i+n+m,MAX);
            t=max(t,i+n+m);//标记汇点
            while(x%prime[i]==0)x/=prime[i];
        }
    }
}
inline void linky(int y,int id){//从质因数连到红卡
    for(int i=1;i<=k&&prime[i]<=y;i++){
        if(y%prime[i]==0){
            add(i+n+m,id,MAX);
            t=max(t,i+n+m);//标记汇点
            while(y%prime[i]==0)y/=prime[i];
        }
    }
}
void work(){//读入+预处理+建图
    int u,v,w;
    n=read();m=read();
    for(int i=1;i<=n;i++){
        x[i]=read();
        linkx(x[i],i);
    }
    for(int i=1;i<=m;i++){
        y[i]=read();
        linky(y[i],i+n);
    }
    s=0;t++;//标源汇点
    for(int i=1;i<=n;i++)add(s,i,1);
    for(int i=1;i<=m;i++)add(i+n,t,1);
    printf("%d\n",dinic());
}
inline void init(){//清空图
    c=2;//记得一定从偶数开始，如0,2等
    memset(head,0,sizeof(head));
}
void make(){//线性筛素数
    int x=MAXM-10;
    np[0]=np[1]=true;
    for(int i=2;i<=x;i++){
        if(!np[i])prime[++k]=i;
        for(int j=1;j<=k&&prime[j]*i<=x;j++){
            np[prime[j]*i]=true;
            if(i%prime[j]==0)break;
        }
    }
}
int main(){//主函数So easy!
    int cases=read();
    make();
    while(cases--){
        init();
        work();
    }
    return 0;
}

```

---

## 作者：_yjk (赞：5)

用匈牙利算法水过了~~实际上是我不会网络流~~

很容易看出来可以二分图匹配，但是听说会TLE

所以就把第一组的每一个数质因数分解一下，
用临接表把质因数对应的节点号存起来，
再把另一组质因数分解，
将每个数对应的每个质因数所对应的第一组数的点和它连起来
就可以跑二分图匹配了

（质因数分解可以x^0.5分解出来，但是我太蒟了，从2~x枚举了一遍）

本来想骗点部分分的，然后就谜一样地AC了。。。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<bitset>
#include<cmath>
using namespace std;
int t,m,n,num,prime[100010],pnum,h1[100010],n1,head[100010],mat[100010];
struct Node{
	int to,next;
} p[10000010];
struct NODE{
	int to,next;
} e[10000010];
inline void add1(int x,int y)
{
	p[++n1].to=y;
	p[n1].next=h1[x];
	h1[x]=n1;
}
inline void add(int x,int y)
{
	e[++num].to=y;
	e[num].next=head[x];
	head[x]=num;
}
bitset<1000010> not_prime;
bitset<100010> used;
inline void Get_Prime()
{
	not_prime[1]=1;
	for(int i=2;i<=1000010;i++)
	{
		if(!not_prime[i]) prime[++pnum]=i;
		for(int j=1;j<=pnum&&i*prime[j]<=1000010;j++)
		{
			not_prime[i*prime[j]]=1;
			if(i%prime[j]==0) break;
		}
	}
}
inline bool find(int x)
{
	for(int i=head[x];i;i=e[i].next)
	{
		int v=e[i].to;
		if(!used[v])
		{
			used[v]=1;
			if(mat[v]==0||find(mat[v]))
			{
				mat[v]=x;
				return 1;
			}
		}
	}
	return 0;
}
int main()
{
	scanf("%d",&t);
	Get_Prime();						//筛素数
	while(t--)
	{
		memset(mat,0,sizeof(mat));		//初始化
		memset(h1,0,sizeof(h1));
		memset(head,0,sizeof(head));
		num=0;n1=0;
		scanf("%d%d",&m,&n);
		int x;
		for(int i=1;i<=m;i++)
		{
			scanf("%d",&x);
			for(int j=1;prime[j]<=x;j++)	//分解质因数
			 if(x%prime[j]==0)
			 {
			 	add1(j,i);
			 	while(x%prime[j]==0) x/=prime[j];
			 }
		}
		for(int i=1;i<=n;i++)
		{
			scanf("%d",&x);
			for(int j=1;prime[j]<=x;j++)
			 if(x%prime[j]==0)
			 {
			 	for(int l=h1[j];l;l=p[l].next) add(p[l].to,i);
			 	while(x%prime[j]==0) x/=prime[j];
			 }
		}
		int ans=0;
		for(int i=1;i<=m;i++)		//匈牙利板子
		{
			used.reset();	
			if(find(i)) ans++;
		}
		printf("%d\n",ans);
	}
	return 0;
} 
```

---

## 作者：Engulf (赞：4)

别看数据范围小，直接跑匈牙利会 $\color{blue}\textsf{TLE}$ 三个点。瓶颈其实是在连边上，$\mathcal{O}(n^2)$ 连边显然不优。

此题正解是**网络流**。

题目要求**不互质**的点都要连边，不互质，证明两个点存在一个共同的质因数。

那可以多增加一个点部，对于每个点，对其分解质因数，然后连一条流量为 $1$ 的边，跑一边最大流即可。

需要建立这些点：

- 超级源点 $s$，超级汇点 $t$
- 蓝卡点
- 红卡点
- 质因数点

看一个简单的例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/qb0p6zyx.png)

整个图建出来大概就是这样子，图丑轻喷（

点 $1\sim4$ 是蓝卡，$5\sim8$ 是红卡。

中间两个点就是质因数，整张图的最大流是 $2$。

```cpp
#include <bits/stdc++.h>
#define mst(x) memset(x, 0, sizeof x)
using namespace std;

const int N = 2e6 + 5;
int red, blue, tot;
int a[N];
int maxflow;
int s, t;
int flow[N], dep[N];
struct edge
{
	int to, nxt;
}e[N << 1];
int head[N], idx = 1;
void add(int x, int y, int w)
{
	e[ ++ idx] = {y, head[x]}, head[x] = idx, flow[idx] = w;
	e[ ++ idx] = {x, head[y]}, head[y] = idx, flow[idx] = 0;
}
bool bfs()
{
	memset(dep, 0, sizeof dep);
	queue<int> q;
	dep[s] = 1, q.push(s);
	while (!q.empty())
	{
		int u = q.front(); q.pop();
		for (int i = head[u]; i; i = e[i].nxt)
		{
			int v = e[i].to;
			if (flow[i] && !dep[v])
			{
				dep[v] = dep[u] + 1;
				q.push(v);
			}
		}
	}
	return dep[t];
}
int dfs(int u, int in)
{
	if (u == t) return in;
	int out = 0;
	for (int i = head[u]; i && in; i = e[i].nxt)
	{
		int v = e[i].to;
		if (flow[i] && dep[v] == dep[u] + 1)
		{
			int fl = dfs(v, min(flow[i], in));
			flow[i] -= fl, flow[i ^ 1] += fl;
			in -= fl, out += fl;
		}
	}
	if (!out) dep[u] = 0;
	return out;
}

void link1(int x, int p)
{
	vector<int> primes;
	for (int i = 2; i * i <= x; i ++ )
		if (x % i == 0)
		{
			primes.emplace_back(i);
			while (x % i == 0) x /= i;
		}
	if (x > 1) primes.emplace_back(x);
	for (auto d: primes)
	{
		if (!a[d]) a[d] = ++ tot;
		add(p, a[d] + blue + red, 1);
	}
}
void link2(int x, int p)
{
	vector<int> primes;
	for (int i = 2; i * i <= x; i ++ )
		if (x % i == 0)
		{
			primes.emplace_back(i);
			while (x % i == 0) x /= i;
		}
	if (x > 1) primes.emplace_back(x);
	for (auto d: primes)
		if (a[d]) add(a[d] + blue + red, p, 1);
}

int main()
{
	int tt;
	scanf("%d", &tt);
	while (tt -- )
	{
		mst(head), mst(a), maxflow = tot = 0, idx = 1;
		scanf("%d%d", &blue, &red);
		for (int i = 1; i <= blue; i ++ ) add(0, i, 1);
		for (int i = 1, x; i <= blue; i ++ ) scanf("%d", &x), link1(x, i);
		for (int i = 1, x; i <= red; i ++ ) scanf("%d", &x), link2(x, i + blue);
		s = 0, t = 1 + red + blue + tot;
		for (int i = 1; i <= red; i ++ ) add(i + blue, t, 1);
		while (bfs()) maxflow += dfs(s, 1 << 30);
		printf("%d\n", maxflow);
	}
	return 0;
}
```

---

## 作者：苏联小渣 (赞：3)

写了半个中午 + 半个晚上。。。

这题一眼看上去是个二分图最大匹配，把蓝色卡片看作左边的点，把红色卡片看作右边的点，然后暴力找两边写着整数的 $\gcd$ 不为 $1$ 的点对建边，写个匈牙利算法跑一遍二分图最大匹配，就可以拿到 70 pts 的好成绩。

此时你可能非常自闭，因为 TLE 的三个点时间分别是 1.14s，1.15s，1.16s。你可能尝试卡常，但最终发现是徒劳。

你可能想起老师曾经说过二分图最大匹配可以通过 dinic 跑最大流求得，复杂度将降至 $n \sqrt{e}$。具体的，建一个超级源点 $s$，一个超级汇点 $t$，将 $s$ 和左部点连一条流量为 $1$ 的边，将右部点和 $t$ 连一条流量为 $1$ 的边。此时从 $s$ 到 $t$ 的最大流就是该二分图的最大匹配。此时你依旧可以拿到 70 pts 的好成绩。

你会发现 TLE 的三个点时间都是 1.20s，可能自闭地怀疑自己是否学了一个假的 dinic（？

然而你仔细分析，发现问题并不在 dinic 上，而在建图上。具体的，由于我们建图需要枚举左部、右部点，再求一遍 $\gcd$，复杂度直接飙到了 $O(nm \log{a_i})$，再加个多测不 T 飞就怪了。

所以考虑优化建图，从题目性质出发。两个数最大公约数大于 $1$，就是说两个数至少有一个公共质因数。考虑拆边，引入关键点表示两数的公共质因数，把原来从左部点连向右部点的边拆为两条：从左部点 $i$ 连向表示 $a_i,a_j$ 公共质因子的**中部关键点**的边（可以理解为中转），从关键点连向右部点 $j$ 的边。我们在枚举左部点、右部点时，只需各考虑两者其一。具体的，先求出左部点、右部点的所有数的质因数，将其离散化。然后对于 $i \in [1,n]$，对于 $a_i$ 的每一个质因子 $j$，令表示 $i$ 的点的编号为 $x$，表示 $j$ 的点的编号为 $y$，连一条 $x \to y$，流量为 $1$ 的边。对于右部点，同理，只不过建边的顺序要反过来。此时我们就可以保证 $\forall i\in[1,n],j \in [1,m] \text{ s.t. }\gcd(a_i,a_j)>1,i,j$ 都是联通的，即从 $i$ 可以通过中部的关键点“中转”后到达 $j$，这和我们一开始暴力建边是等效的，并且把时间复杂度缩小了一个量级。此时建边的时间复杂度是 $O(n \sqrt{a_i} \log v),v$ 表示质因子的总个数，是严格优于暴力的。然后再跑一遍 $s \to t$ 的最大流就可以得到答案。

此时我们建的图大概是这个形态的，中间的黑点表示关键点。

![](https://cdn.luogu.com.cn/upload/image_hosting/1cxpfhjb.png)

代码稍微长了一点，一百二十行。

### Code：

```c++
#include <bits/stdc++.h>
using namespace std;
int T, n, m, s, t, p=1, ans, cnt, a[505], b[505], h[2010], dep[2010], pri[2010], id[2010];
int gcd(int x, int y){
	if (!y) return x;
	return gcd(y, x%y);
}
struct node{
	int x, y, z, next;
}d[500010];
void add(int x, int y, int z){
	d[++p].y = y, d[p].z = z, d[p].next = h[x], h[x] = p;
}
int bfs(){
	queue <int> q;
	memset(dep, 0, sizeof(dep));
	dep[s] = 1;
	q.push(s);
	while (!q.empty()){
		int x = q.front(); q.pop();
		for (int i=h[x]; i; i=d[i].next){
			int y = d[i].y;
			if (d[i].z && !dep[y]){
				dep[y] = dep[x] + 1;
				q.push(y);
			}
		}
	}
	return dep[t];
}
int dfs(int x, int flow){
	if (x == t) return flow;
	int out = 0;
	for (int i=h[x]; i; i=d[i].next){
		int y = d[i].y;
		if (dep[y] == dep[x] + 1 && d[i].z){
			int now = dfs(y, min(flow, d[i].z));
			d[i].z -= now, d[i^1].z += now;
			out += now, flow -= now;
		}
	}
	if (!out) dep[x] = 0;
	return out;
}
map <int, int> mp;
map <int, int> :: iterator p2;
int main(){
	scanf ("%d", &T);
	while (T --){
		mp.clear();
		ans = 0;
		cnt = p = 1;
		memset(h, 0, sizeof(h));
		scanf ("%d%d", &n, &m);
		for (int i=1; i<=n; i++){
			scanf ("%d", &a[i]);
			int tmp = a[i];
			for (int j=2; j<=sqrt(a[i]); j++){
				while (tmp % j == 0){
					tmp /= j, mp[j] = 1;
				}
			}
			if (tmp > 1) mp[tmp] = 1;
		}
		for (int i=1; i<=m; i++){
			scanf ("%d", &b[i]);
			int tmp = b[i];
			for (int j=2; j<=sqrt(b[i]); j++){
				while (tmp % j == 0){
					tmp /= j, mp[j] = 1;
				}
			}
			if (tmp > 1) mp[tmp] = 1;
		}
		for (p2=mp.begin(); p2!=mp.end(); p2++){
			mp[p2->first] = ++cnt;
		}
		for (int i=1; i<=n; i++){
			int tmp = a[i];
			for (int j=2; j<=sqrt(a[i]); j++){
				if (tmp % j == 0){
					if (mp[j]) add(i, n+m+mp[j], 1);
					if (mp[j]) add(n+m+mp[j], i, 0);
				}
				while (tmp % j == 0) tmp /= j;
			}
			if (tmp){
				if (mp[tmp]) add(i, n+m+mp[tmp], 1);
				if (mp[tmp]) add(n+m+mp[tmp], i, 0);	
			}
		}
		for (int i=1; i<=m; i++){
			int tmp = b[i];
			for (int j=2; j<=sqrt(b[i]); j++){
				if (tmp % j == 0){
					if (mp[j]) add(n+m+mp[j], n+i, 1);
					if (mp[j]) add(n+i, n+m+mp[j], 0);
				}
				while (tmp % j == 0) tmp /= j;
			}
			if (tmp){
				if (mp[tmp]) add(n+m+mp[tmp], n+i, 1);
				if (mp[tmp]) add(n+i, n+m+mp[tmp], 0);
			}
		}
		for (int i=1; i<=n; i++){
			add(0, i, 1);
			add(i, 0, 0);
		}
		for (int i=1; i<=m; i++){
			add(n+i, n+m+1, 1);
			add(n+m+1, n+i, 0);
		}
		s = 0, t = n + m + 1;
		while (bfs()){
			ans += dfs(s, 1e9);
		}
		printf ("%d\n", ans);
	}
	return 0;
}
```

---

## 作者：ker_xyxyxyx_xxs (赞：3)

[P2065 [TJOI2011]卡片](https://www.luogu.com.cn/problem/P2065)

网络流好题，看着数据很小，实际上非常坑。

卡片分为蓝色和红色，考虑将两个可以一起取的卡片连起来，再将源点和汇点分别与它们连起来，时间复杂度 $ O(n ^ 2 ) $，交上去，$ TLE \  70 \  pts $，没办法只能另外想办法。

接着我们考虑将每个数进行分解质因数，将每个数分别与他们的质因数连起来，边权为 $ \infty $。为什么可以进行这样的转换呢？题目要求两个数不互质，如果这两个数有公共因子就当然不互质了，所以就可以这样转化。最后将源点与蓝卡相连，红卡与汇点相连，边权为 $ 1 $ 跑最大流即可，连边如下图。其实只需要这张图就能够做这道题，此图以样例一为例。

![](https://cdn.luogu.com.cn/upload/image_hosting/cif8ncnx.png)

接下来讲一下代码实现。

由于每张卡片的数值最大为 $ 10 ^ 7 $，我们也不知道最大的质数是多少，所以我选择将所有的质数筛出来。

接着对每张卡片上的数值进行因式分解，然后找出最大的，查找它是第几大的，中间一列就会有多少个点，具体体现为 rk 数组，$ T $ 的计算上。
再进行连边即可。

举个例子，样例一的质因数为 $ 2 $、$ 3 $ 和 $ 5 $，所以中间一列就有三个点。

不懂的见代码，或私信我。

Code

```cpp
# include <bits/stdc++.h>
using namespace std;

int TT;
const int Siz = 500 + 5;
const int N = 1e6 + 1;
const int M = 1e6 + 1;
const int Rk = 1e7 + 5;
const int inf = 1e9;

int n , m , ans;
int gcd(int a , int b) {
	return a % b == 0 ? b : gcd(b , a % b);
}
typedef struct {
	int x , y , z , next;
}Node;
Node edge[M];
int E , elast[N];
int S , T;

void add(int x , int y , int z) {
	E ++ , edge[E].x = x , edge[E].y = y , edge[E].z = z , edge[E].next = elast[x] , elast[x] = E;
}

vector<int> Kikyo[Siz] , Elodie[Siz];
int maxv = -1;
void decompose_Kikyo(int x , int n) {
	for (int i = 2 ; i * i <= n ; i ++) {
		if (n % i == 0) {
			Kikyo[x].push_back(i) , maxv = max(maxv , i);
			while (n % i == 0) n /= i;
		}
	}
	if (n > 1) Kikyo[x].push_back(n) , maxv = max(maxv , n);
}

void decompose_Elodie(int x , int n) {
	for (int i = 2 ; i * i <= n ; i ++) {
		if (n % i == 0) {
			Elodie[x].push_back(i) , maxv = max(maxv , i);
			while (n % i == 0) n /= i;
		}
	}
	if (n > 1) Elodie[x].push_back(n) , maxv = max(maxv , n);
}

int primes[N] , tot = 0 , rk[Rk];
bool st[Rk];
void init(int n) {
	for (int i = 2 ; i <= n ; i ++) {
        if (!st[i]) primes[++ tot] = i;
        for (int j = 1 ; i * primes[j] <= n ; j ++) {
            st[i * primes[j]] = true;
            if (i % primes[j] == 0) break;
        }
    }
	for (int i = 1 ; i <= tot ; i ++) {
		rk[primes[i]] = i;
	}
}

void build() {
	for (int i = 1 ; i <= m ; i ++) {
		add(S , i , 1) , add(i , S , 0);
		for (int j = 0 ; j < Kikyo[i].size() ; j ++) {
			int x = Kikyo[i][j];
			add(i , m + rk[x] , inf) , add(m + rk[x] , i , 0);
		}
    }
    for (int i = 1 ; i <= n ; i ++) {
    	add(m + tot + i , T , 1) , add(T , m + tot + i , 0);
    	for (int j = 0 ; j < Elodie[i].size() ; j ++) {
    		int x = Elodie[i][j];
    		add(m + rk[x] , m + tot + i , inf) , add(m + tot + i , m + rk[x] , 0);
		}
	}
}

int dis[N] , cnt[N];
void bfs(int start) {
    queue<int> q;
    q.push(start);
    dis[start] = 0;
    cnt[S] = 1;
    while (!q.empty()) {
        int cur = q.front();
        q.pop();
        for (int i = elast[cur] ; i ; i = edge[i].next) {
            int v = edge[i].y;
            if (dis[v] != -1) continue;
            dis[v] = dis[cur] + 1;
            q.push(v);
            cnt[dis[v]] ++;
        }
    }
}
int cur[N];
int dfs(int u , int flow) {
    if (u == T) return flow;
    int delta = 0;
    for (int i = cur[u] ; i ; i = edge[i].next) {
        cur[u] = i;
        int v = edge[i].y;
        if (edge[i].z > 0 && dis[u] == dis[v] + 1) {
            int temp = dfs(v , min(flow - delta , edge[i].z));
            edge[i].z -= temp;
            edge[i ^ 1].z += temp;
            delta += temp;
            if (delta == flow) return delta;
        }
    }
    if (dis[S] >= T + 1) return delta;
    cur[u] = elast[u];
    if (-- cnt[dis[u]] == 0) dis[S] = T + 1;
    cnt[++ dis[u]] ++;
    return delta;
}
int Isap() {
    int ans = 0;
    memset(cnt , 0 , sizeof cnt);
    memset(dis , -1 , sizeof dis);
    bfs(T);
    for (int i = 0 ; i <= T ; i ++) {
        cur[i] = elast[i];
    }
    while (dis[S] < T + 1) ans += dfs(S , inf);
    return ans;
}

int main() {
	cin >> TT;
	init(10000000);
	while (TT --) {
	    memset(elast , 0 , sizeof elast);
	    E = 1;
	    maxv = -1;
	    scanf("%d%d" , &m , &n);
	    for (int i = 1 ; i <= m ; i ++) Kikyo[i].clear();
	    for (int i = 1 ; i <= n ; i ++) Elodie[i].clear();
    	for (register int i = 1 ; i <= m ; i ++) {
    		int x;
			scanf("%d" , &x);
    		decompose_Kikyo(i , x);
    	}	
    	for (register int i = 1 ; i <= n ; i ++) {
    		int x;
    		scanf("%d" , &x);
    		decompose_Elodie(i , x);
		}
 		S = 0 , T = m + n + rk[maxv] + 1 , tot = rk[maxv];
		build();
		printf("%d\n" , Isap());
	}
}
```

---

## 作者：zifanwang (赞：2)

看大家建图时中间都连了质数点，发一个不用质数点的解法。

我们可以先从源点向每一个蓝色卡片对应的点连一条边，再从每一个红色卡片对应的点向汇点连一条边。

如果两张卡片可以一起拿走，那就在它们之间连一条边（蓝色连到红色），这些边的最大流量都是 $1$。建好图以后我们就可以直接用 Dinic 求出答案。

但是重点不在这里，如果你直接枚举 $i$ 和 $j$ 然后判断 $\gcd(b_i,r_j)$ 是否大于 $1$，你只能拿到 `70pts`。

我们可以先用线性筛求出每一个数的最小质因子和这个数除去这个最小质因子的几次方以后对应的数。

具体的，我们可以用 $pr[i]$ 表示 $i$ 这个数除去它的最小质因子的几次方以后对应的数，我们用 $d[i]$ 表示 $i$ 的最小质因子。

如果 $d[i]=d[i/d[i]]$，我们就令 $pr[i]=pr[i/d[i]]$，否则 $pr[i]=i/d[i]$。

接下来如果我们要判断两个数 $x$ 和 $y$ 是否有公共的质因子，我们可以先判断 $d[x]$ 是否整除 $y$，然后再令 $x=pr[x]$，回到刚刚的操作，重复直到 $x=1$。

代码：
```cpp
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=a;i<=b;++i)
using namespace std;
inline int read(){
	int x=0;char ch=getchar();
	while(!isdigit(ch))ch=getchar();
	while(isdigit(ch))x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return x;
}
int T,n,m,s,t,l,r,cnt,tot,ans,a[502],b[502],d[1003],q[1003],p[664581],d1[10000002],pr[10000002];
int vr[502000],ed[502000],nx[502000],now[1003],hd[1003];
inline void add(int x,int y,int z){
	vr[++tot]=y,ed[tot]=z,nx[tot]=hd[x],hd[x]=tot;
	vr[++tot]=x,ed[tot]=0,nx[tot]=hd[y],hd[y]=tot;
}
bool bfs(){
	memset(d,0,sizeof(d));
	d[s]=1,now[s]=hd[s];
	l=r=1,q[1]=s;
	while(l<=r){
		int x=q[l++];
		for(int i=hd[x],y;i;i=nx[i])if(ed[i]&&!d[y=vr[i]]){
			d[y]=d[x]+1,now[y]=hd[y];
			if(y==t)return 1;
			q[++r]=y;
		}
	}
	return 0;
}
int dinic(int x,int flow){
	if(x==t)return flow;
	int rest=flow,num,i,y;
	for(i=now[x];i;i=nx[i])if(ed[i]&&d[y=vr[i]]==d[x]+1){
		num=dinic(y,min(rest,ed[i]));
		if(num){
			ed[i]-=num,ed[i^1]+=num;
			rest-=num;
			if(!rest)break;
		}else d[y]=0;
	}
	now[x]=i;
	return flow-rest;
}
inline bool check(int x,int y){
	while(x!=1){
		if(y%d1[x]==0)return 1;
		x=pr[x];
	}
	return 0;
}
signed main(){
	rep(i,2,10000000){
		if(!d1[i])d1[i]=i,p[++cnt]=i;
		pr[i]=d1[i]==d1[i/d1[i]]?pr[i/d1[i]]:i/d1[i];
		rep(j,1,cnt){
			if(p[j]>d1[i]||p[j]>10000000/i)break;
			d1[p[j]*i]=p[j];
		}
	}
	T=read();
	while(T--){
		n=read(),m=read();
		s=0,t=n+m+1;
		tot=1;
		memset(hd,0,sizeof(hd));
		rep(i,1,n)a[i]=read();
		rep(i,1,m)b[i]=read(),add(i+n,t,1);
		rep(i,1,n){
			bool fl=0;
			rep(j,1,m)if(check(a[i],b[j]))add(i,j+n,1),fl=1;
			if(fl)add(0,i,1);
		}
		ans=0;
		while(bfs())ans+=dinic(0,0x7fffffff);
		printf("%d\n",ans);
	}
	return 0;
}
```

---

## 作者：Suzt_ilymtics (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P2065)

### 一道很妙的网络流建图题

> 网络流代码只有普及难度，真正重要的地方在于建图——鲁迅

## Description

> 给你两组卡片，卡片有权值，只有两种颜色不同卡片的最大公约数大于 $1$ 时才可以匹配，问最多能匹配多少对。 $T$ 组数据。

## Solution

用网络流来做应该比较好想。

一种朴素的做法是：

- 源点连向所有的红色卡片，所有蓝色卡片连向汇点，流量为 $1$。表示所有的卡片都能选一次。
- $O(nm)$ 遍历所有卡片对，求出他们的 $\text{gcd}$ 判断，暴力连边。

跑一个最大流就好了。

只能拿 $70 \texttt{pts}$ ~~数据还是水~~。

发现上面的局限在于建图所用的时间是 $O(nm)$，还要加上求 $\gcd$ 的耗时。

考虑到 $\text{gcd}$ 和质因数有关，考虑对每个卡片进行分解质因数。

让每个红色卡片连向它们的所有质因数，让每个蓝色卡片的所有质因数连向它们自己。

连边方式：源点 $\to$ 红色卡片 $\to$ 质因数 $\to$ 蓝色卡片 $\to$ 汇点。

~~所以根本就不用 ISAP。~~

### Tips/Trick

- 质因数要筛到 $10^7$，不要贪图复杂度筛到 $\sqrt{10^7}$。如果有两个大质数你就挂了；
- 源点和汇点的选择不要与中间点重复；
- 多测要清空（显然这道题只需要清空 ```head``` 数组和记录边数的变量。

剩下的看代码吧。

## Code

```cpp
/*
Work by: Suzt_ilymics
Problem: P2065 [TJOI2011]卡片
Knowledge: 网络流Dinic弧优化 
Time: O(能过)
*/
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<queue>
#define LL long long
#define orz cout<<"lkp AK IOI!"<<endl

using namespace std;
const int MAXN = 2e6+5;
const int INF = 1e9+7;
const int mod = 1e9+7;

struct edge{
    int to, w, nxt;
}e[MAXN << 1];
int head[MAXN], num_edge = 1;

int T, n, m, s, t;
int a[MAXN], b[MAXN], tmp[MAXN], Cnt = 0;
int dis[MAXN], cur[MAXN];
bool vis[10000030];

int read(){
    int s = 0, f = 0;
    char ch = getchar();
    while(!isdigit(ch))  f |= (ch == '-'), ch = getchar();
    while(isdigit(ch)) s = (s << 1) + (s << 3) + ch - '0' , ch = getchar();
    return f ? -s : s;
}

int Gcd(int x, int y) { return y ? Gcd(y, x % y) : x; }
void add_edge(int from, int to, int w) { e[++num_edge] = (edge){to, w, head[from]}, head[from] = num_edge; }

bool bfs() {
    memset(dis, -1, sizeof dis);
    queue<int> q;
    q.push(s), dis[s] = 0, cur[s] = head[s];
    while(!q.empty()) {
        int u = q.front(); q.pop();
        for(int i = head[u]; i; i = e[i].nxt) {
            int v = e[i].to;
            if(e[i].w && dis[v] == -1) {
                dis[v] = dis[u] + 1;
                cur[v] = head[v];
                q.push(v);
                if(v == t) return true;
            }
        }
    }
    return false;
}

int dfs(int u, int limit) {
    if(u == t) return limit;
    int flow = 0;
    for(int i = cur[u]; i && flow < limit; i = e[i].nxt) {
        cur[u] = i; int v = e[i].to;
        if(e[i].w && dis[v] == dis[u] + 1) {
            int f = dfs(v, min(e[i].w, limit - flow));
            if(!f) dis[v] = INF;
            e[i].w -= f, e[i ^ 1].w += f;
            flow += f; 
        }
    }
    return flow;
}

int Dinic() {
    int maxflow = 0, flow = 0;
    while(bfs()) while(flow = dfs(s, INF)) maxflow += flow;
    return maxflow;
} 

void clear() {
    for(int i = 1; i <= t; ++i) head[i] = 0; 
    num_edge = 1;
}

void Init(int limit) {
    for(int i = 2; i <= limit; ++i) {
        if(!vis[i]) tmp[++ Cnt] = i;
        for(int j = 1; j <= Cnt && i * tmp[j] <= limit; ++j) {
            vis[i * tmp[j]] = true;
            if(i % tmp[j] == 0) break; 
        }
    }
//    cout<<Cnt<<endl;
}

int main()
{
    Init(10000000);
    T = read();
    while(T--) {
        n = read(), m = read();
        s = Cnt + n + m + 1, t = s + 1;
        for(int i = 1; i <= n; ++i) a[i] = read(), add_edge(s, i, 1), add_edge(i, s, 0);
        for(int i = 1; i <= m; ++i) b[i] = read(), add_edge(i + n, t, 1), add_edge(t, i + n, 0);
        for(int i = 1; i <= n; ++i) {
            for(int j = 1; j <= Cnt && a[i] != 1; ++j) {
                if(a[i] % tmp[j] == 0) {
                    add_edge(i, j + n + m, 1), add_edge(j + n + m, i, 0);
                    while(a[i] % tmp[j] == 0) a[i] /= tmp[j];
                }
            }
        }
        for(int i = 1; i <= m; ++i) {
            for(int j = 1; j <= Cnt && b[i] != 1; ++j) {
                if(b[i] % tmp[j] == 0) {
                    add_edge(j + n + m, n + i, 1), add_edge(n + i, j + n + m, 0);
                    while(b[i] % tmp[j] == 0) b[i] /= tmp[j];
                }
            }
        }
        printf("%d\n", Dinic());
        clear();
    }
    return 0;
}
```

---

## 作者：赵悦岑 (赞：1)

# P2065 [TJOI2011]卡片

[P2065 [TJOI2011]卡片](https://www.luogu.com.cn/problem/P2065)

## 分析

这道题显然可以用最大流来做，将红色卡片放在一边，蓝色卡片放在另一边，从源点 $s$ 向每个红色卡片连一条容量为 $1$ 的边，从每个蓝色卡片向汇点 $t$ 连一条容量为 $1$ 的边，并把所有公约数不为 $1$ 的异色卡片用一条容量为 $1$ 的边连起来，再从源点向汇点跑最大流即可。这道题看似可以这样简单地建图，但是这样其实会 $\color{purple}{TLE}$ ，只有 $70$ 分。分析一下，我们总共有 $n\times m$ 条边，每一次都要跑一边最大公约数，这些数最大是 $1000000$ ，很容易被卡掉。我们需要一个新的建边方法。

![1](https://cdn.luogu.com.cn/upload/image_hosting/hv4womq2.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

我们之前的方法需要 $n\times m$ 条边，如果能找到一种 $n+m$ 次的建边就可以了。建边的标准是两个数的最大公约数不为 $1$ ，也就是两个数存在同样的质因数。这 $n+m$ 个数中对于异色的卡片，所有有质因数 $2$ 的数都相互匹配，有质因数 $3$ 的数都可以相互匹配，等等。如果我们把有质因数 $2$ 的连在一个点上，有质因数 $3$ 的连在一个点上，依此类推，只需要 $n+m$ 次分解质因数即可。其中红色卡片与质因数点的边由红色卡片指向质因数点，蓝色卡片与质因数点的边由质因数点指向蓝色卡片，再连接源汇点就可以了。如图：

![2](https://cdn.luogu.com.cn/upload/image_hosting/pmbt5mfu.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

## code
```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cmath>
using namespace std;
int N,n1,n2,q=0,p=1,s1,s2,t[10001],t0[10001],f[10001],g[10001],d[10000001];
bool u=true;
struct str
{
    int m,q,r;
}a[1000001];
int gcd(int a,int b)
{
    if(b==0) return a;
    return gcd(b,a%b);
}
void road(int x,int y,int r)
{
    a[++p].m=y;
    a[p].q=t[x];
    t[x]=p;
    a[p].r=r;
}
void bfs()
{
    queue<int> Q;
    Q.push(s2);
    f[s2]=1;
    g[1]=1;
    while(!Q.empty())
    {
        int k=Q.front();
        Q.pop();
        for(int i=t[k];i!=0;i=a[i].q)
        {
            if(f[a[i].m]==0)
            {
                f[a[i].m]=f[k]+1;
                ++g[f[a[i].m]];
                Q.push(a[i].m);
            }
        }
    }
}
int dfs(int x,int r)
{
    if(x==s2) return r;
    int s=0;
    for(int i=t0[x];i!=0;i=a[i].q)
    {
        t0[x]=i;
        if(f[x]==f[a[i].m]+1&&a[i].r!=0)
        {
            int z=dfs(a[i].m,min(r,a[i].r));
            if(z!=0)
            {
                a[i].r-=z;
                a[i^1].r+=z;
                r-=z;
                s+=z;
            }
            if(r==0) return s;
        }
    }
    --g[f[x]];
    if(g[f[x]]==0) u=false;
    ++f[x];
    ++g[f[x]];
    return s;
}
void ss1(int k,int x)
{
    for(int i=2;i<=sqrt(x)&&x!=1;++i)
    {
        if(x%i==0)
        {
            if(d[i]==0) d[i]=++q;
            road(k,n1+n2+d[i],1);
            road(n1+n2+d[i],k,0);
        }
        while(x%i==0) x/=i;
    }
    if(x>1)
    {
        if(d[x]==0) d[x]=++q;
        road(k,n1+n2+d[x],1);
        road(n1+n2+d[x],k,0);
    }
}
void ss2(int k,int x)
{
    for(int i=2;i<=sqrt(x)&&x!=1;++i)
    {
        if(x%i==0)
        {
            if(d[i]==0) d[i]=++q;
            road(n1+n2+d[i],k,1);
            road(k,n1+n2+d[i],0);
        }
        while(x%i==0) x/=i;
    }
    if(x>1)
    {
        if(d[x]==0) d[x]=++q;
        road(n1+n2+d[x],k,1);
        road(k,n1+n2+d[x],0);
    }
}
void abc()
{
    scanf("%d%d",&n1,&n2);
    p=1;
    for(int i=1;i<=N;++i) f[i]=g[i]=t[i]=0;
    u=true;
    for(int i=1;i<=n1;++i)
    {
        int x;
        scanf("%d",&x);
        ss1(i,x);
    }
    for(int i=1;i<=n2;++i)
    {
        int x;
        scanf("%d",&x);
        ss2(n1+i,x);
    }
    N=n1+n2+q+2;
    s1=N-1;
    s2=N;
    for(int i=1;i<=n1;++i)
    {
        road(s1,i,1);
        road(i,s1,0);
    }
    for(int i=1;i<=n2;++i)
    {
        road(n1+i,s2,1);
        road(s2,n1+i,0);
    }
    bfs();
    int r=0;
    while(u==true)
    {
        for(int i=1;i<=N;++i) t0[i]=t[i];
        r+=dfs(s1,1e18);
    }
    printf("%d\n",r);
    return;
}
int main()
{
    int T;
    scanf("%d",&T);
    while(T--) abc();
    return 0;
}
```

---

## 作者：water_tomato (赞：1)

## 题意

给定一个二分图，二分图上的每个点都有一个权值。如果一个左部点的权值和一个右部点的权值的 $\gcd$ 大于 $1$，则这两点之间有一条边。求二分图最大匹配。

## 解析

首先我们发现，如果暴力建边的话，我们可能会建 $n^2$ 条边，在 $100$ 组数据的情况下，非常容易 TLE。

我们考虑优化。对于一个左部点的权值和一个右部点的权值的 $\gcd$ 大于 $1$ 这个条件，我们可以理解为这两个点有一个共同的因子。因此我们可以对于每一个点的权值进行分解质因数，然后对于左部点，令这个点连向因子；对于右部点，令因子连向这个点。最后建出连向所有左部边的超级源点和所有右部边连向的超级汇点。

这样的话，一条边就变成了超级原点到左部点到共同因子到右部点再到超级汇点。由于 $\log_210^7<24$，因此每个点连的边就从可能最多的 $500$ 变成了一个不大于 $24$ 的数，我们就成功做到了优化，接着只需要跑一遍网络流就可以了。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int t,m,n;
map<int,int> ma;//开个 map 记录质因数代表的点
struct edge{
	int to,nxt,w;
}e[N<<3];
int head[N],cnt=1;
inline void add(int u,int v,int w){
	e[++cnt].to=v;
	e[cnt].nxt=head[u];
	e[cnt].w=w;
	head[u]=cnt;
}
int tot,ans;
//以下为 Dinic
int dep[N];
inline bool bfs(){
	memset(dep,0,sizeof(dep));
	queue<int> q;q.push(1);dep[1]=1;
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=head[u];i;i=e[i].nxt){
			int v=e[i].to;
			if(e[i].w&&(!dep[v])){
				dep[v]=dep[u]+1;
				q.push(v);
			}
		}
	}
	if(dep[2]) return true;
	return false;
}
inline int dfs(int u,int in){
	if(u==2) return in;
	int out=0;
	for(int i=head[u];i&&in;i=e[i].nxt){
		int v=e[i].to;
		if(e[i].w&&dep[v]==dep[u]+1){
			int tmp=dfs(v,min(in,e[i].w));
			e[i].w-=tmp;e[i^1].w+=tmp;
			in-=tmp;
			out+=tmp;
		}
	}
	if(!out) dep[u]=0;
	return out;
}
//以上为 Dinic
signed main(){
	scanf("%d",&t);
	while(t--){
		scanf("%d%d",&m,&n);ans=0;
		tot=n+m+2;cnt=1;memset(head,0,sizeof(head));ma.clear();
		for(int i=3,x;i<=m+2;i++){
			add(1,i,1);add(i,1,0);//超级源点
			scanf("%d",&x);
			for(int j=2;j<=x;j++){//分解质因数
				if(x%j==0){
					if(!ma[j]){
						tot++;
						add(i,tot,1);add(tot,i,0);
						ma[j]=tot;
					}
					else{
						add(i,ma[j],1);add(ma[j],i,0);
					}
				}
			}
		}
		for(int i=m+3,x;i<=m+2+n;i++){
			add(2,i,0);add(i,2,1);//超级汇点
			scanf("%d",&x);
			for(int j=2;j<=x;j++){//分解质因数
				if(x%j==0){
					if(!ma[j]){
						tot++;
						add(i,tot,0);add(tot,i,1);
						ma[j]=tot;
					}
					else{
						add(i,ma[j],0);add(ma[j],i,1);
					}
				}
			}
		}
		while(bfs()){
			ans+=dfs(1,1e9);
		}
		printf("%d\n",ans);
	}
	return 0;
}
```

---

## 作者：hzy_____ (赞：0)

[P2065 [TJOI2011] 卡片](https://www.luogu.com.cn/problem/P2065)

这里提供一个比较暴力的思路。

## 思路简述
算法：网络流。

我们可以把不互质的蓝色卡片和红色卡片连一条边，再将所有红色点和源点连起来，将所有蓝色点和汇点连起来。每条边的流量都为 $1$。

但是这样做复杂度为 $O((n+m)^3)$，交上去后 TLE 了三个点。

那么我们就需要一些优化。

## 优化
这里我用了一个玄学的优化：

* 将蓝色卡片和红色卡片的数字离散化（设 $wa_i$ 表示蓝色卡片中值为 $i$ 的数量，$wb_i$ 表示红色卡片中值为 $i$ 的数量）。
* 对于蓝色卡片 $i$，将它连到与其不互质的红色卡片上，流量为 $ +\infty$。
* 将源点连到所有蓝色卡片上。对于蓝色卡片 $i$，流量为 $wa_i$。
* 将所有红色卡片连到汇点上。对于红色卡片 $i$，流量为 $wb_i$。

通过这个操作，就能卡过这道题了。

## 代码：
Code:
```cpp
#include<bits/stdc++.h>
//#define int long long
using namespace std;
inline int read(){
	register int x=0,t=1;
	register char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')t=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return x*t;
}
const int N=1010,inf=1e9+7;
int n,m,s,t,T,a[N],b[N],ax[N],bx[N],la,lb,wa[N],wb[N];
struct dc{
	int idx=1,h[N],d[N],cur[N];
	struct edge{int v,w,ne;}e[N*N*2];
	void init(){
		idx=1;
		memset(h,0,sizeof(h));
	}
	void add(int u,int v,int w){
		e[++idx]=(edge){v,w,h[u]};
		h[u]=idx;
		e[++idx]=(edge){u,0,h[v]};
		h[v]=idx;
	}
	bool bfs(){
		memset(d,0,sizeof(d));
		queue<int> q;
		q.push(s),d[s]=1;
		while(!q.empty()){
			int u=q.front();q.pop();
			for(int i=h[u];i;i=e[i].ne){
				int v=e[i].v,w=e[i].w;
				if(d[v]==0&&w){
					d[v]=d[u]+1;
					q.push(v);
				}
			}
		}
		return d[t];
	}
	int dfs(int u,int mf){
		if(u==t)return mf;
		int sum=0;
		for(int i=cur[u];i;i=e[i].ne){
			cur[u]=i;
			int v=e[i].v,w=e[i].w;
			if(d[v]==d[u]+1&&w){
				int f=dfs(v,min(mf,w));
				e[i].w-=f;
				e[i^1].w+=f;
				sum+=f;
				mf-=f;
				if(mf==0)break;
			}
		}
		if(sum==0)d[u]=0;
		return sum;
	}
	int dinic(){
		int flow=0;
		while(bfs()){
			memcpy(cur,h,sizeof(h));
			flow+=dfs(s,1e9);
		}
		return flow;
	}
}A;//dinic
inline bool check(int a,int b){return __gcd(a,b)>1;}
signed main(){
	T=read();
	while(T--){
		A.init();
		memset(wa,0,sizeof(wa));
		memset(wb,0,sizeof(wb));
		n=read(),m=read();
		s=n+m+1,t=n+m+2;
		for(int i=1;i<=n;i++)a[i]=read(),ax[i]=a[i];
		for(int i=1;i<=m;i++)b[i]=read(),bx[i]=b[i];
		sort(ax+1,ax+n+1);
		sort(bx+1,bx+m+1);
		la=unique(ax+1,ax+n+1)-ax-1;
		lb=unique(bx+1,bx+m+1)-bx-1;
		for(int i=1;i<=n;i++)wa[lower_bound(ax+1,ax+la+1,a[i])-ax]++;
		for(int i=1;i<=m;i++)wb[lower_bound(bx+1,bx+lb+1,b[i])-bx]++;
		//for(int i=1;i<=la;i++)printf("a:%d %d\n",ax[i],wa[i]);
		//for(int i=1;i<=lb;i++)printf("b:%d %d\n",bx[i],wb[i]);
		for(int i=1;i<=la;i++)for(int j=1;j<=lb;j++)if(check(ax[i],bx[j]))A.add(i,la+j,w[a]);
		for(int i=1;i<=la;i++)A.add(s,i,wa[i]);
		for(int i=1;i<=lb;i++)A.add(la+i,t,wb[i]);
		printf("%d\n",A.dinic());
	}
}

---

## 作者：BBD186587 (赞：0)

先考虑一个显然的做法。新建一个源点，向所有蓝色卡片连边。新建一个汇点，所有红色卡片向它连边。所有权值不互质的红蓝卡片之间连边。在这张图上跑最大流即可。

但是，这个做法由于边数太多，过不了。故考虑优化边数。

先引入另一个问题：怎么用较少的边数建出一张完全图。

建出一个新点，所有点都向它连边即可。

通过这个问题，可以发现，想要优化边数，可以建出新点。

在原问题中，就可以建出若干个新点，表示权值范围内的所有质数。

对于蓝色卡片，把它的权值质因数分解后，向得到的每种质数对应的点连边。对于红色卡片，把它的权值质因数分解后，由得到的每种质数对应的点向它连边。

这样，边数就大大减少了。（通过计算可得，每张蓝色卡片至多连出 8 条边，红色卡片同理）

直接跑最大流即可。

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<queue>
using namespace std;
const int N=1e6+10;
const int M=1e4+10;
const int L=1e7+10;
const int inf=1e9;
int _,n,m,S,T;
int a[N],b[N];
int cnt=1,hd[M];
int nxt[M],to[M],val[M];
int ans,d[N],mp[L];
int tot,fl[L],pr[N];
queue <int> q;
void add(int x,int y,int z)
{
	to[++cnt]=y,val[cnt]=z;
	nxt[cnt]=hd[x],hd[x]=cnt;
}
int MIN(int x,int y)
{
	return x<y?x:y;
}
void LLL(int n)
{
	fl[1]=1;
	for(int i=2;i<=n;i++)
	{
		if(!fl[i]) pr[++tot]=i,mp[i]=tot;
		for(int j=1;j<=tot&&i*pr[j]<=n;j++)
		{
			fl[i*pr[j]]=1;
			if(i%pr[j]==0) break;
		}
	}
}
bool bfs()
{
	memset(d,0,sizeof(d));
	while(q.size()) q.pop();
	d[S]=1,q.push(S);
	while(q.size())
	{
		int x=q.front();q.pop();
		for(int i=hd[x];i;i=nxt[i])
		{
			int t=to[i],v=val[i];
			if(v<=0||d[t]) continue;
			d[t]=d[x]+1,q.push(t);
			if(t==T) return true;
		}
	}
	return false;
}
int dfs(int x,int flow)
{
	if(x==T) return flow;
	int sum=0;
	for(int i=hd[x];i;i=nxt[i])
	{
		if(!flow) break;
		int t=to[i],v=val[i];
		if(v<=0||d[t]!=d[x]+1) continue;
		int res=dfs(t,MIN(flow,v));
		val[i]-=res,val[i^1]+=res;
		flow-=res,sum+=res;
	}
	if(!sum) d[x]=0;
	return sum;
}
int main()
{
	LLL(L-1);
	scanf("%d",&_);
	while(_--)
	{
		cnt=1,ans=0;
		memset(hd,0,sizeof(hd));
		memset(nxt,0,sizeof(nxt));
		memset(to,0,sizeof(to));
		memset(val,0,sizeof(val));
		scanf("%d%d",&n,&m),S=0,T=n+m+tot+1;
		for(int i=1;i<=n;i++) scanf("%d",&a[i]);
		for(int i=1;i<=m;i++) scanf("%d",&b[i]);
		for(int i=1;i<=n;i++)
		{
			if(mp[a[i]]) add(i,n+m+mp[a[i]],1),add(n+m+mp[a[i]],i,0);
			else
			{
				int x=a[i];
				for(int j=1;j<=tot;j++)
				{
					if(x==1) break;
					if(x%pr[j]==0) add(i,n+m+j,1),add(n+m+j,i,0);
					while(x%pr[j]==0) x/=pr[j];
				}
			}
		}
		for(int i=1;i<=m;i++)
		{
			if(mp[b[i]]) add(n+m+mp[b[i]],n+i,1),add(n+i,n+m+mp[b[i]],0);
			else
			{
				int x=b[i];
				for(int j=1;j<=tot;j++)
				{
					if(x==1) break;
					if(x%pr[j]==0) add(n+m+j,n+i,1),add(n+i,n+m+j,0);
					while(x%pr[j]==0) x/=pr[j];
				}
			}
		}
		for(int i=1;i<=n;i++)
			add(S,i,1),add(i,S,0);
		for(int i=1;i<=m;i++)
			add(n+i,T,1),add(T,n+i,0);
		while(bfs()) ans+=dfs(S,inf);
		printf("%d\n",ans);
	}
	return 0;
}
```

---

## 作者：raincity (赞：0)

## 修改部分
改了 $\LaTeX$。

## 分析
这道题那叫一个坑人。

首先容易想到枚举每一条边，看是否满足 $\gcd\ge2$，满足就加边。跑一边二分图。

然后快乐地 TLE 70pts。

然后想到用 EK 跑二分图（只学过 EK）。

然后快乐地 TLE 70pts。

然后想到用 ISAP 跑二分图。

然后快乐地 TLE 0pts。（自学 ISAP 学废了，浪费一个下午）

然后发现一个快上一万倍的方法。

首先讲一下怎么卡掉上面那个算法：所有的数都是 2 就行。

然后我们发现 $\gcd$ 和质因数有关。

那么建一个超级源点 0 连向 $1\sim m$，建一个超级汇点 $n + m + 1 $连向 $m+1\sim n+m$。把每个点连向自己所有的质因数。容量均为 1。

因为重复的质因数只连一条边，所以边数大大减小。

期间还因为把所有的质因数预处理出来 TLE 了一万年。

## 解决
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <map>

using namespace std;

const int N = 25000, M = 100005;
int n, m, head[N], ver[M], nxt[M], edge[M], tot, maxflow, que[N], pre[N], l, r, increase[N], b[N], R[N], cnt;
char vis[N];
map <int, int> mp;

inline int bfs() {
	l = 1, r = 1, que[1] = 0, increase[0] = 0x3f3f3f3f;
	memset(vis, 0, sizeof(vis)), vis[0] = true;
	while (l <= r) {
		int cur = que[l++];
		for (int i = head[cur]; ~i; i = nxt[i])
			if (edge[i] && !vis[ver[i]]) {
				vis[ver[i]] = 1, pre[ver[i]] = i, increase[ver[i]] = min(increase[cur], edge[i]);
				if (increase[ver[i]])
					que[++r] = ver[i];
				if (ver[i] == n + m + 1)
					return increase[ver[i]];
			}
	}
	return 0;
}

inline void update() {
	maxflow += increase[n + m + 1];
	int cur = n + m + 1;
	while (cur) {
		int last = pre[cur];
		edge[last] -= increase[n + m + 1], edge[last ^ 1] += increase[n + m + 1];
		cur = ver[last ^ 1];
	}
}

inline void EK() {
	while (bfs())
		update();
}

inline void addedge(int u, int v, int w) { ver[++tot] = v, nxt[tot] = head[u], edge[tot] = w, head[u] = tot; }

inline void init() {
	tot = -1, maxflow = 0;
	memset(head, -1, sizeof(head));
    mp.clear();
}

inline void read(int &ret) {
	ret = 0;
	char ch = getchar();
	while (ch < '0' || ch > '9') ch = getchar();
	while (ch >= '0' && ch <= '9') ret = ret * 10 + ch - '0', ch = getchar();
}

int main() {
	int T;
	cin >> T;
	while (T--) {
		cin >> m >> n;
		init();
        cnt = n + m + 1;
		for (int i = 1; i <= m; i++) {
            read(b[i]), addedge(0, i, 1), addedge(i, 0, 0);
            for (int j = 2; j * j <= b[i]; j++)
                if (b[i] % j == 0) {
                    while (b[i] % j == 0) b[i] /= j;
                    if (!mp[j])
                        mp[j] = ++cnt;
                    addedge(i, mp[j], 1), addedge(mp[j], i, 0);
                }
            if (b[i] > 1) {
                if (!mp[b[i]])
                    mp[b[i]] = ++cnt;
                addedge(i, mp[b[i]], 1), addedge(mp[b[i]], i, 0);
            }
        }
		for (int i = 1; i <= n; i++) {
            read(R[i]), addedge(i + m, n + m + 1, 1), addedge(n + m + 1, i + m, 0);
            for (int j = 2; j * j <= R[i]; j++)
                if (R[i] % j == 0) {
                    while (R[i] % j == 0) R[i] /= j;
                    if (!mp[j])
                        mp[j] = ++cnt;
                    addedge(i + m, mp[j], 0), addedge(mp[j], i + m, 1);
                }
            if (R[i] > 1) {
                if (!mp[R[i]])
                    mp[R[i]] = ++cnt;
                addedge(i + m, mp[R[i]], 0), addedge(mp[R[i]], i + m, 1);
            }
        }
		EK();
		cout << maxflow << endl;
	}
	return 0;
}

```

---

## 作者：happy_dengziyue (赞：0)

### 1 思路

一看就是二分图最大匹配，我更习惯于跑 `dinic` 网络流。

但是，如此之大的数据肯定能够把程序 T 飞。

我们可以发现，如果 $2$ 个数不互质，那么必然存在一个质数是它们的公因数。

设蓝卡有 $m$ 张，分别为 $b[1],b[2],b[3],......,b[m]$。

红卡有 $n$ 张，分别为 $r[1],r[2],r[3],......,r[n]$。

先预处理质数，将所有的小于 $10^7$ 的质数存到数组里。设总的质数个数为 $pi$，第 $i\ (1\le i\le pi)$ 个质数为 $pr[i]$。比如 $pr[1]=2,pr[2]=3,pr[3]=5$。

然后，给每张蓝卡标号为 $1\to m$，给每张红卡标号为 $m+1\to m+n$，给第 $i$ 个质数标号为 $i+m+n$。

如果一张蓝卡能整除以一个质数，就**从蓝卡向质数**连容量为“无限”的边。

如果一张红卡能整除以一个质数，就**从质数向红卡**连容量为”无限“的边。

然后，从源点向每个蓝卡连容量为 $1$ 的边，同样，从每个红卡向汇点连容量为 $1$ 的边。

跑一遍网络流即可。

我不知道不吸氧会不会超时，吸氧最慢点 $212$ 毫秒。

### 2 代码与记录

```cpp
#include<cstdio>
#include<cstring>
#include<queue>
#define inf 0x3f3f3f3f//一个很大的数
using namespace std;
int ca;//测试数据组数
bool nop[10000002/*10^7+2*/];//是否为合数
int pr[10000002/*10^7+2*/];//质数
int pi=0;//下标
int m;//蓝卡数
int n;//红卡数
int b[200000/*2*10^5*/];//蓝卡
int r[200000/*2*10^5*/];//红卡
struct E{
	int v,w,a,nx;//端点、流量、反边、下一条
}e[1000002/*10^6+2*/];//边
int ei;//下标
int fir[200000/*2*10^5*/];//开始路径
int s;//源点
int t;//汇点
int de[200000/*2*10^5*/];//深度
int ans;//答案
inline void addedge(int u,int v,int w){
	++ei; e[ei].v=v; e[ei].w=w; e[ei].a=ei+1; e[ei].nx=fir[u]; fir[u]=ei;
	++ei; e[ei].v=u; e[ei].w=0; e[ei].a=ei-1; e[ei].nx=fir[v]; fir[v]=ei;
}
inline int ma(int a,int b){
	return a>b?a:b;
}
inline int mi(int a,int b){
	return a<b?a:b;
}
void unb(int a,int u){
	for(int i=1;i<=pi&&pr[i]<=a;++i){
		if(!(a%pr[i])){
			addedge(u,i+m+n,inf);//连接不同颜色的点是有区别的
			while(!(a%pr[i]))a/=pr[i];
			t=ma(t,i+m+n);
		}
	}
}
void unr(int a,int u){
	for(int i=1;i<=pi&&pr[i]<=a;++i){
		if(!(a%pr[i])){
			addedge(i+m+n,u,inf);//连接不同颜色的点是有区别的
			while(!(a%pr[i]))a/=pr[i];
			t=ma(t,i+m+n);
		}
	}
}
bool bfs(){
	memset(de,0,sizeof(de));
	de[s]=1;
	queue<int>q;
	q.push(s);
	int u;
	while(!q.empty()){
		u=q.front();
		q.pop();
		for(int i=fir[u],v;i;i=e[i].nx){
			v=e[i].v;
			if(e[i].w&&!de[v]){
				de[v]=de[u]+1;//更新深度
				q.push(v);//下一个结点
			}
		}
	}
	return de[t];//是否到达
}
int dfs(int u,int f){
	if(u==t)return f;//到达终点回家
	int res=0;
	for(int i=fir[u],v;i;i=e[i].nx){
		v=e[i].v;
		if(e[i].w&&de[u]+1==de[v]){
			int w=dfs(v,mi(f,e[i].w));
			e[i].w-=w;//用完了流量
			e[e[i].a].w+=w;//反向边更新
			res+=w;//流量又多了呢
			f-=w;//同样用完了流量
		}
	}
	return res;
}
int main(){
	#ifndef ONLINE_JUDGE
	freopen("P2065_1.in","r",stdin);
	freopen("P2065_1.out","w",stdout);
	#endif
	scanf("%d",&ca);
	memset(nop,0,sizeof(nop));
	for(int i=2;i<=10000000;++i){
		if(nop[i])continue;
		pr[++pi]=i;
		for(int j=1;j<=pi&&i*pr[j]<=10000000;++j){
			nop[i*pr[j]]=true;
			if(!(i%pr[j]))break;
		}
	}
	while(ca--){
		scanf("%d%d",&m,&n);//注意输入的顺序
		ei=0;
		memset(fir,0,sizeof(fir));
		s=0;
		t=0;
		for(int i=1;i<=m;++i){
			scanf("%d",b+i);
			unb(b[i],i);//连接蓝点
		}
		for(int i=1;i<=n;++i){
			scanf("%d",r+i);
			unr(r[i],i+m);//连接红点
		}
		++t;//更新汇点
		for(int i=1;i<=m;++i){
			addedge(s,i,1);
		}
		for(int i=1;i<=n;++i){
			addedge(i+m,t,1);
		}
		ans=0;
		while(bfs())ans+=dfs(s,inf);//dinic算法
		printf("%d\n",ans);//输出，搞定
	}
	return 0;
}
```

[记录传送门](https://www.luogu.com.cn/record/56760553)

By **dengziyue**

---

## 作者：LiveZoom (赞：0)

# P2065 [TJOI2011]卡片 题解

刚学网络流，记一篇题解。

## 题意

给你两堆卡片，分蓝的和红的，分别有 $n$ 个和 $m$ 个，然后每个卡片上都有一个数。一个人要拿很多张卡片，每次只能从两堆中各取一个，而且这两个卡片上的 $\gcd>1$，问：最多能拿多少个。

## 思路1

> 这不就是个二分图板子吗，暴力建图然后跑EK不就可以过了吗？

然后：

![](https://cdn.luogu.com.cn/upload/image_hosting/etrcic7o.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

稍微想一下发现建图就 $O(nm)$ 了，再带一堆常数就 T 飞了。

## 思路2

知道是建图慢了，就要去优化建图。

很明显这里不能两边同时建，所以要两边分开建图。

问题来了：怎么建？

这里发现是用 $\gcd$ 连接两边的，那么只要找到中间的一堆“中间商”即可。然后就很容易想到用**质因数**。

先预处理一遍 $1\sim 10^7$ 的质因数，然后对于每个卡片，再向卡片上数字的所有质因数连一条边，然后跑一遍网络流，问题就迎刃而解了。

## 代码(EK)

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 2e4 + 5;
const int M = 1e5 + 5;
const int PRIME = 1e7 + 5;
const int CNT = 6e5 + 5;

int T;
int n, m, s, t, ans;
int b[N], r[N];
int tot, pre[M << 1], to[M << 1], val[M << 1], tail[N];

void addEdge (int u, int v, int w) {
	to[++tot] = v, val[tot] = w, pre[tot] = tail[u], tail[u] = tot;
	to[++tot] = u, val[tot] = 0, pre[tot] = tail[v], tail[v] = tot;
}

int gcd (int m, int n) {
	if (m < n) swap(m, n);
	if (n == 0) return m;
	return gcd(n, m % n);
}

int cnt;
int primes[CNT];
void Prework () { //预处理质数（埃氏筛）
	bool vis[PRIME] = {0};
	for (int i = 2; i * i <= 1e7; ++i)
		if (!vis[i])
			for (int j = i * i; j <= 1e7; j += i)
				vis[j] = true;
	for (int i = 2; i <= 1e7; ++i)
		if (!vis[i]) primes[++cnt] = i;
}

namespace MaxFlow { //网络流
#define INF 0x3f3f3f3f
	int p[N] = {0}, inc[N];
	bool vis[N];
	int q[N];
	void Init () { memset(p, 0, sizeof(p)), memset(inc, 0, sizeof(inc)); }
	bool BFS () {
		memset(vis, false, sizeof(vis));
		int head = 0, back = 1;
		vis[s] = true, inc[s] = INF; q[1] = s;
		while (head < back) {
			int nowfront = q[++head];
			for (int ind = tail[nowfront]; ind; ind = pre[ind]) {
				if (!val[ind]) continue ;
				if (vis[to[ind]]) continue ;
				inc[to[ind]] = min(inc[nowfront], val[ind]);
				vis[to[ind]] = true, q[++back] = to[ind], p[to[ind]] = ind;
				if (to[ind] == t) return true;
			}
		}
		return false;
	}
	void Work () {
		int cur = t;
		while (cur ^ s) {
			int las = p[cur];
			val[las] -= inc[t], val[las ^ 1] += inc[t];
			cur = to[las ^ 1];
		}
		ans += inc[t];
		return ;
	}
}

int main() {
	scanf("%d", &T);
	Prework();
	while (T--) {
		scanf("%d%d", &n, &m); s = n + m + 1, t = n + m + 2;
		memset(pre, 0, sizeof(pre)), memset(tail, 0, sizeof(tail));
		tot = 1; ans = 0;
		for (int i = 1; i <= n; ++i) scanf("%d", &b[i]), addEdge(s, i, 1); //左边的超级源点向i连边
		for (int i = 1; i <= m; ++i) scanf("%d", &r[i]), addEdge(i + n, t, 1); //右边的超级源点向i+n连边（至于为什么是i+n就不用解释了吧）
		for (int i = 1; i <= n; ++i) {
			for (int j = 1; j <= cnt; ++j) {
				if (primes[j] > b[i]) break ;
				if (b[i] % primes[j] == 0) addEdge(i, j + n + m + 2, 1); //找到质因数然后建边
			}
		}
		for (int i = 1; i <= m; ++i) {
			for (int j = 1; j <= cnt; ++j) {
				if (primes[j] > r[i]) break ;
				if (r[i] % primes[j] == 0) addEdge(j + n + m + 2, i + n, 1);
			}
		}
		while (MaxFlow::BFS()) MaxFlow::Work();
		printf("%d\n", ans);
	}
	return 0;
} 
```

至于时间复杂度：不会算。

---


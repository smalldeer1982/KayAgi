# [SDOI2008] 沙拉公主的困惑

## 题目描述

大富翁国因为通货膨胀，以及假钞泛滥，政府决定推出一项新的政策：现有钞票编号范围为 $1$ 到 $N$ 的阶乘，但是，政府只发行编号与 $M!$ 互质的钞票。房地产第一大户沙拉公主决定预测一下大富翁国现在所有真钞票的数量。现在，请你帮助沙拉公主解决这个问题，由于数量可能非常大，你只需计算出答案对 $R$ 取模后的结果即可。 

## 说明/提示

对于 $100\% $ 的数据，$1\leq M\leq N\leq 10^7$，$1\leq T\leq 10^4$，$2\leq R\leq 10^9+10$ 且 $R$ 为质数。

## 样例 #1

### 输入

```
1 11
4 2```

### 输出

```
1
```

# 题解

## 作者：小粉兔 (赞：139)

本题在 [/discuss/show/338087](/discuss/show/338087) 加强数据前的题解有一些是错误的，具体原因下面会说明。

错误的题解存在的问题是，当 $n \ge R$ 时就直接输出 $0$，在原数据下是能 AC 的。

实际上并不是这样的，可以试试这个数据：

```plain
1 3
4 3
```

输出应该是 $2$。但是我见到的大部分题解输出都是 $0$。

为什么呢？

我们先看看这题的公式：$\displaystyle \mathrm{ans} = \frac{n!}{m!} \cdot \varphi(m!)$，其中 $\varphi(x)$ 代表 $x$ 的欧拉函数。

化简：

$$ \begin{aligned} \mathrm{ans} &= \frac{n!}{m!} \cdot \varphi(m!) \\ &= \frac{n!}{m!} \cdot m! \prod_{p \mid m!} \frac{p - 1}{p} \\ &= n! \cdot \frac{\displaystyle \prod_{p \in \mathbb{P} \mathbin{\&} p \le m} (p - 1)}{\displaystyle \prod_{p \in \mathbb{P} \mathbin{\&} p \le m} p} \end{aligned} $$

那么，我们只要处理 $\displaystyle \prod p$ 对 $R$ 的逆元吗？

错了，因为 $n!$ 中的因子 $R$ 还有可能和 $\displaystyle \prod p$ 中的 $R$ 消掉。

正解应该是对 $n \ge R$ 的 $n!$ 消去一个 $R$，对 $m \ge R$ 的 $\displaystyle \prod p$ 同时消去一个 $R$ 才对。

由于 $\displaystyle \prod p$ 中最多含有一个 $R$ 所以不需要多做消去。

代码：

```cpp
#include<cstdio>
#define F(i,a,b) for(int i=(a);i<=(b);++i)
#define F2(i,a,b) for(int i=(a);i<(b);++i)
int T,Mod,n,m;
int primes[664580], pnum=0;
bool isn_prime[10000001];
int pi[664580],inv[10000001];
int in[664580],fct[10000001];
int pos[10000001];
void init(){
	isn_prime[0]=isn_prime[1]=1;
	F(i,2,10000000){
		if(!isn_prime[i]) primes[++pnum]=i;
		for(int j=1;j<=pnum&&primes[j]*i<=10000000;++j){
			isn_prime[primes[j]*i]=1;
			if(i%primes[j]==0) break;
		}
	}
	inv[1]=1; for(int i=2;i<Mod&&i<=10000000;++i)
		inv[i]=1ll*(Mod-Mod/i)*inv[Mod%i]%Mod;
	pi[0]=1; F(i,1,pnum) pi[i]=1ll*pi[i-1]*(primes[i]-1)%Mod;
	in[0]=1; F(i,1,pnum) if(primes[i]!=Mod) in[i]=1ll*in[i-1]*inv[primes[i]%Mod]%Mod; else in[i]=in[i-1];
	fct[0]=1; F(i,1,10000000) if(i!=Mod) fct[i]=1ll*fct[i-1]*i%Mod; else fct[i]=fct[i-1];
	F(i,2,10000000) if(isn_prime[i]) pos[i]=pos[i-1]; else pos[i]=pos[i-1]+1; 
}
int main(){
	scanf("%d%d",&T,&Mod);
	init();
	while(T--){
		scanf("%d%d",&n,&m);
		if(n>=Mod&&m<Mod) puts("0");
		else printf("%d\n",1ll*fct[n]*pi[pos[m]]%Mod*in[pos[m]]%Mod);
	}
	return 0;
}
```

---

## 作者：Isprime (赞：31)

题意简述：给定 $N,M,R$，求 $[1,N!]$ 中与 $M!$ 互质的数的数量。

伟大的欧几里得已经告诉我们该怎么做了。

题目中限定了 $M \leq N$，那么显然 $M! | N!$. 

常识告诉我们，$gcd(a,b)=gcd(a+k\times b,b)$.然而常识很多时候是假的，所以我们考虑证明这个式子。

设 $s=gcd(a,b)$, 则存在 $x,y\in\mathbb{Z}$使得 $a=x\times s,b=y\times s,gcd(x,y)=1$，于是 $gcd(a+b\times k,b)=gcd(x\times s+y\times s\times k,y\times s)=gcd(s\times(x+y\times k),s\times y)=s\times gcd(x+y\times k,y)$.

设 $m|(x+y\times k)$ 且 $m|y$，所以 $m|(y\times k)$，所以 $m|x$.即 $m|x$ 且 $m|y$，又因为 $gcd(x,y)=1$，所以 $gcd(x+y\times k,y)=m=1$，所以 $gcd(a+b\times k,b)=s\times gcd(x+y\times k,y)=s=gcd(a,b)$.

这个式子能说明什么呢？我们令 $b=M!$,显然可以发现：对于 $\forall k\in [1,\frac{N!}{M!}],\forall x\in[1,M!]$ 有 $gcd(k*M!+x,M!)=gcd(x,M!)$.

也就是说，对于 $\forall k\in [1,\frac{N!}{M!}]$, $[(k-1)\times M!+1,k\times M!]$ 中与 $M!$ 互质的数是相等的。

得出这个结论之后就简单了。答案就是 $\frac{N!}{M!}\times \phi(M!)$.

$\phi(M!)$ 又是个不可做的东西。。。吗？

我们知道 $\phi(n)=n\times\Pi_{p|n}(1-\frac{1}{p})$, 设 $phifac_i=\phi(i!)$，我们分两种情况讨论。

$n$ 为素数时，$phifac_i=n\times(1-\frac{1}{n})\times(n-1)!\times\Pi_{p|n!\&p\neq n}(1-\frac{1}{p})=(n-1)\times (n-1)!\times\Pi_{p|(n-1)!}(1-\frac{1}{p})=(n-1)\times phifac_{n-1}$.

$n$ 为合数时，
$phifac_i=n\times(n-1)!\times\Pi_{p|n!}(1-\frac{1}{p})=n\times phifac_{n-1}$.

这样我们就得到了阶乘的欧拉函数的递推式。

预处理出阶乘和欧拉函数，对于每个询问计算 $M!$ 的逆元即可。

但是题目中没有规定 $R\leq N$ 所以有可能会出现 $R|N!$，预处理阶乘和欧拉函数的时候要记得特判如果 $R|i$ 那么要把 $i$ 中的 $R$ 因子全部除掉再计算。

最后特判一下，如果 $\lfloor \frac{N}{R}\rfloor>\lfloor\frac{M}{R}\rfloor$  （即 $N!$ 中 $R$ 因子更多）则答案为 $0$.

```cpp
#include <cstdio>
using namespace std;
inline int read() {
	int res=0,f=1; char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-1; ch=getchar();}
	while(ch>='0'&&ch<='9') {res=res*10+ch-'0'; ch=getchar();}
	return res*f;
}
const int MAXN=10000005;
int T,r,n,m;
int ispr[MAXN];
int pri[MAXN];
int fct[MAXN];
int phi[MAXN];
inline void IsPrImE() {
	int cnt=0;
	ispr[0]=ispr[1]=1;
	for(register int i=2;i<MAXN;++i) {
		if(!ispr[i]) 
			pri[++cnt]=i;
		for(register int j=1;j<=cnt;++j) {
			if(1ll*i*pri[j]>=MAXN) break;
			ispr[i*pri[j]]=1;
			if(!i%pri[j]) break;
		}
	}
}
inline long long qpow(int x,int p) {
	long long res=1;
	while(p) {
		if(p&1) res=1ll*res*x%r;
		p>>=1; x=1ll*x*x%r;
	}
	return res;
}
signed main() {
	IsPrImE();
	T=read(); r=read();
	fct[0]=phi[0]=1;
	for(register int i=1;i<MAXN;++i) {
		int x=i,k=0;
		while(x%r==0) x/=r,++k;
		fct[i]=fct[i-1]*1ll*x%r;
		x=i-1+ispr[i],k=0;
		while(x%r==0) x/=r,++k;
		phi[i]=phi[i-1]*1ll*x%r;
	}
	while(T--) {
		n=read(); m=read();
		long long ans=1ll*fct[n]*phi[m]%r*qpow(fct[m],r-2)%r;
		if(n/r>m/r) ans=0;
		printf("%lld\n",ans);
	}
	return 0;
}
```


---

## 作者：言琢დ (赞：22)

## 题意简述

**本题多测。最高可达 1w 组测试数据。**

求 $1\sim N!$ 中与 $M!$ 互质的数的个数，对 $R$ 取模。

$N,M$ 在线性范围，$R$ 是一个可能很大的素数。

## $\rm Analysis$

#### 引理 $1$

考虑某一个数 $x$，与 $M!$ 互质，即

$$\gcd(x,M!)=1$$

即与每一个因子都互质，即

$$\gcd(x,1),\gcd(x,2),\cdots,\gcd(x,M)$$

均为 $1$。

那么某一个合数因子，必能表示成多个不大于 $M$ 的质数因子的积。

题意即转求

$$\gcd(x,p_1),\gcd(x,p_2),...,gcd(x,p_K)$$

均为 $1$。

其中 $p_{1\cdots K}$ 表示不大于 $M$ 的全体素数。

那么答案即为 $1\sim N!$ 中与 $\{p_K\}$ 互质的数的个数。

#### 引理 $2$

若存在两个数，$x\le y$，答案是要求 $1\cdots x$ 的贡献。

我们也可以通过计算 $1\cdots y$ 的贡献减去 $x+1\dots y$ 的贡献来得到 $1\cdots x$ 的贡献。

#### 最后一击

由引理 $1$ 可知答案是 $1\cdots N!$ 中与 $\{p_K\}$ 互质的数的个数。

由引理 $2$ 可将上面的问题转化为：

$$\begin{aligned}&\text{(1}\sim \text{N! 中与 N! 互质的个数)}\\-&\text{(1} \sim\text{N! 中与 (M+1)*(M+2)*..*(N-1)*N 互质的个数)}\end{aligned}$$

前者，$1\sim N!$ 中与 $N!$ 互质的个数，就是欧拉函数 $\varphi(N!)$。

$$\varphi(N!)=N!\times\dfrac{p_1-1}{p_1}\times\dfrac{p_2-1}{p_2}\times\cdots\times\dfrac{p_K-1}{p_K}$$

后者对答案的贡献是零。

因为若存在因子 $p_i\in(M\sim N)$，与 $N!$ 个数中某些数互质，那 $p_i$ 一定不与 $M!$ 互质。

故不存在贡献。

所以答案即为

$$N!\times\dfrac{(p_1-1)\times(p_2-1)\times\cdots\times(p_k-1)}{(p_1\times p_2\times\cdots\times p_k)}$$

#### Hack 数据原理

当 $R\le M\le N$ 时，$N!$ 中的 $R$ 与分母中的 $R$ 会约去，而直接求逆元会导致答案为 $0$。

考虑 $3$ 种情况：

- $R>N$: 正常该怎么做怎么做。

- $R\in[M,N]$：这时分子 $(N!)$ 中存在 $R$ 因子，分母 $(M!)$ 中不存在 $R$ 因子，答案恰好为 $0$。

- $R<M$：这时分子分母均含有 $R$，若 $\text{(分子\%R*分母逆元\%R)}$ 答案显示应是零，但实际不是零。

如下面这个例子：$\dfrac{2!}{2!}=1$，$\bmod~2$ 意义下正解应为 $1$。

但分子 $2!\bmod 2=0$，再乘上个逆元，不管逆元是多少，模 $2$ 它还是零。这就错了。

解决办法：特判 $R\le M$ 时，分子分母计算的时候都不乘上 $R$ 因子，等于是约分掉了。

```cpp
#include<cstdio>
#include<algorithm>
inline int in();
inline void wr(int);
const int N=(int)1e7+5,M=(int)3e6+5;
int p[M],fac[N],p1[M],p2[M];bool vis[N];
inline void prime();
inline int quick_mod(int,int,int);
int main(int argc,char**argv){
	prime();
	register int T=in(),R=in();
	fac[0]=1;
	for(register int i=1;i<N;++i)
		if(i!=R)fac[i]=fac[i-1]*1ll*i%R;
		else fac[i]=fac[i-1];
		/*特判：约分！*/
	p1[1]=(p[1]-1)%R;p2[1]=p[1];
	for(register int i=2;i<=p[0];++i)
		p1[i]=p1[i-1]*1ll*(p[i]-1)%R,p2[i]=p[i];
	/*p1[i]表示前i个素数-1相乘的结果*/
	for(register int i=1;i<=p[0];++i)
		if(p[i]!=R)p[i]=quick_mod(p[i],R-2,R);
	for(register int i=2;i<=p[0];++i)
		if(p[i]!=R)p[i]=p[i]*1ll*p[i-1]%R;
		else p[i]=p[i-1];
	while(T--){
		register int n=in(),m=in();
		if(m<R&&R<=n)
			{puts("0");continue;}
		register int id=std::upper_bound(p2+1,p2+1+p[0],m)-(p2+1);
		if(id<1)
			wr(fac[n]),putchar('\n');
		else
			wr(fac[n]*1ll*p1[id]%R*1ll*p[id]%R),putchar('\n');
	}
}
inline int quick_mod(int a,int b,int c){
	register int s=1;
	while(b){
		if(b&1)s=(s*1ll*a)%c;
		a=(a*1ll*a)%c;b>>=1;
	}
	return s;
}
inline void prime(){
	for(register int i=2;i<N;++i)
		if(!vis[i]){
			p[++p[0]]=i;
			if(i*1ll*i>=N)continue;
			for(register int j=i*i;j<N;j+=i)
				vis[j]=1;
		}
}
inline int in(){
	register char c=getchar();
	register int x=0,f=1;
	for(;c<'0'||c>'9';c=getchar())
		if(c=='-')f=-1;
	for(;c>='0'&&c<='9';c=getchar())
		x=(x<<1)+(x<<3)+(c&15);
	return x*f;
}
inline void wr(int x){
	if(x<0)putchar('-'),x=-x;
	if(x/10)wr(x/10);
	putchar(x%10+'0');
}
```


---

## 作者：Prean (赞：15)

最优解来写题解啦（

# 题目大意：

多测：
$$ \sum_{i=1}^{n!}[\gcd(i,m!)=1] $$
根据 $ \rm gcd $ 的结论，我们可以得到答案其实是：
$$ \frac {n!} {m!} \times \varphi(m!) $$
恩，然后我们就可以直接做了

预处理 $ n! $ 及其逆元，以及 $ \varphi(n!) $。

那么怎么得到 $ \varphi(n!) $ 呢？考虑从 $ \varphi((n-1)!) $ 递推过来。

注意到 $ n! $ 有一个性质，就是其为所有不大于 $ n $ 的质数的倍数。也就是说 $ \varphi(n!) $ 可以写成：
$$ \prod_p^n \varphi(p^k) $$
其中所有的 $ k $ 一定都不小于 $ 1 $。
分类讨论一下：

1. 当 $ n $ 为质数时，$ \varphi(n!)=\varphi((n-1)!) \times (n-1) $
2. 当 $ n $ 不为质数时，$ \varphi(n!)=\varphi((n-1)!) \times n $

于是可以递推得到 $ \varphi(n!) $。

那么对于前面的那个分数，都知道当 $ n \geq mod $ 并且 $ m \geq mod $ 时是不能直接算的，因为 $ n! $ 中的 $ mod $ 和 $ m! $ 中的 $ mod $ 有可能会抵消掉。

于是在递推阶乘的时候可以特判一下，当 $ i=mod $ 时直接令 $ n!=(n-1)! $。

在计算的时候再判断一下 $ \lfloor \frac n {mod} \rfloor $ 是否等于 $ \lfloor \frac m {mod} \rfloor $ 就可以避免这个问题了。

复杂度为 $ O(n+T) $。

code:
```cpp
#include<cstdio>
typedef __uint128_t L;
typedef unsigned long long ull;
const int M=1e7+5;
int T,P,mx,top,n[10005],m[10005],pri[M],phi[M],fac[M],ifac[M];bool zhi[M];
struct FastMod{
    ull b,m;
    FastMod(ull b):b(b),m(ull((L(1)<<64)/b)){}
    friend inline ull operator%(const ull&a,const FastMod&mod){
        ull q=(L(mod.m)*a)>>64;
        ull r=a-q*mod.b;
        return r>=mod.b?r-mod.b:r;
    }
}mod(2);
signed main(){
	register int i,j,x;
	scanf("%d%d",&T,&P);phi[1]=fac[1]=ifac[1]=1;mod=FastMod(ull(P));
	for(i=1;i<=T;++i)scanf("%d%d",n+i,m+i),mx=n[i]>mx?n[i]:mx,mx=m[i]>mx?m[i]:mx;
	for(i=2;i<=mx;++i){
		if(!zhi[i])pri[++top]=i,phi[i]=1;
		for(j=1;j<=top&&(x=i*pri[j])<=M;++j){
			zhi[x]=true;if(!(i%pri[j]))break;
		}
		phi[i]=i-phi[i];
	}
	for(i=2;i<=mx;++i){
		if(i^P)fac[i]=1ull*fac[i-1]*i%mod,ifac[i]=1ull*(P-P/i)*ifac[P%i]%mod;
		else fac[i]=fac[i-1],ifac[i]=1;
	}
	for(i=2;i<=mx;++i)phi[i]=1ull*phi[i-1]*phi[i]%mod,ifac[i]=1ull*ifac[i-1]*ifac[i]%mod;
	for(i=1;i<=T;++i)printf("%d\n",n[i]-n[i]%P==m[i]-m[i]%P?1ull*fac[n[i]]*ifac[m[i]]%mod*phi[m[i]]%mod:0);
}
```

---

## 作者：yhgalaxy (赞：12)

题意是 $n!$ 以内与 $m!$ 互质的数的个数 $(n\geq m)$。

根据欧几里得算法 $\gcd(a,b)=\gcd(a+kb)$，那么如果 $y|x$，x以内与y互质的数的个数，就是 $\varphi(y)x/y$，此题 $n!$ 是 $m!$ 的倍数，所以答案为
$$\frac{n!\varphi(m)}{m!}=\frac{n!\prod_{i=1}^m(i-isprime(i))}{m!}$$
筛法求出n以内的素数，预处理阶乘和phi，每次询问直接回答。

但注意到题目并没有说明模数R的范围，所以1~n的数中有可能含有R的倍数，式子中有除法，询问时使用逆元可能会出问题。可以将数表示成 $a\times R^k$ 的形式，分别存储a和k，做乘法时a相乘k相加，做除法时a乘逆元k相减，判断一下k是否等于0，即可解决这一问题。
```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <ctime>
#include <cstdlib>
using namespace std;

#define Rep(i,l,r) for (int i = (l); i <= (r); ++ i)
#define RepD(i,r,l) for (int i = (r); i >= (l); -- i)
#define RepG(i,x) for (int i = hd[x]; i; i = e[i].nxt)

typedef long long ll;

const int N = 10000005;

bool np[N];
int mod, n, m, fac[N], phi[N], fac0[N], phi0[N];

ll power (ll x, int n) {
	ll s = 1;
	while (n) {if (n&1) (s *= x) %= mod; (x *= x) %= mod, n >>= 1;}
	return s;
}

int main () {
	int T, lim = 1e7;
	scanf ("%d%d", &T, &mod);
	np[1] = 1;
	Rep(i,2,lim) if (!np[i])
		for (int j = 2*i; j <= lim; j += i) np[j] = 1;
	fac[0] = phi[0] = 1, fac0[0] = phi0[0] = 0;
	Rep(i,1,lim) {
		int x = i, k = 0;
		while (x%mod==0) x /= mod, ++ k;
		fac[i] = 1ll*fac[i-1]*x%mod, fac0[i] = fac0[i-1]+k;
		x = (np[i]? i: i-1), k = 0;
		while (x%mod==0) x /= mod, ++ k;
		phi[i] = 1ll*phi[i-1]*x%mod, phi0[i] = phi0[i-1]+k;
	}
	while (T --) {
		scanf ("%d%d", &n, &m);
		ll ans = 1ll*fac[n]*phi[m]%mod*power (fac[m], mod-2)%mod;
		if (fac0[n]+phi0[m]-fac0[m]) ans = 0;
		printf ("%lld\n", ans);
	}
	return 0;
}

```

---

## 作者：JHR100330 (赞：3)

## 题目大意

题意为求 $n!$ 以内与 $m!$ 互质的数的个数（$n \ge m$）。

## 思路

我们可以发现一个神奇的性质，由于 $n \ge m$，那么 $m! \mid n!$。然后 $m!$ 内与 $m!$ 互质的数的个数为 $\varphi(m!)$，然后 $n!$ 又为 $m!$ 的倍数，这时候就能猜一猜 $n!$ 内与 $m!$ 互质的数的个数为 $\frac{\varphi(m!)n!}{m!}$，然后再严谨证明。

推论 $1$：若 $y \mid x$，则 $1$ 至 $x$ 与 $y$ 互质的正整数个数为 $\frac{\varphi(y)x}{y}$。

证明：

先简化，我们知道 $1$ 至 $y$ 内与 $y$ 互质的数的个数为 $\varphi(y)$。

假设 $i(1 \le i \lt y)$ 与 $y$ 互质，根据 $gcd(a, b) = gcd(a + kb, b)$，将 $i$ 带入 $a$，$y$ 带入 $b$，即 $gcd(i, y) = gcd(i + ky, y)$。

此时 $gcd(i, y) = 1$，即 $gcd(i + ky, y) = 1$，即 $i + ky$ 与 $y$ 互质，即 $i$ 加上任意 $y$ 的倍数均与 $y$ 互质。

再推广，那么 $1$ 至 $x$ 中共有多少个 $i + ky$ 呢？

由于 $i + ky \le x$，即 $0 \le k \le \frac{x - i}{y}$，由于 $k$ 为整数，则共有 $\lfloor \frac{x - i}{y} \rfloor + 1 = \lfloor \frac{x}{y} - \frac{i}{y} \rfloor + 1$ 个 $k$。

由于 $y  \mid x, 1 \le i \lt y$，那么 $\frac{x}{y}$ 为整数且 $0 \lt \frac{i}{y} \lt 1$，$\lfloor \frac{x}{y} - \frac{i}{y} \rfloor + 1 = (\frac{x}{y} - 1) + 1 = \frac{x}{y}$。

所以对于每个 $i$，在 $1$ 到 $x$ 中共有 $\frac{x}{y}$ 个 $i + ky$。

又由于共有 $\varphi(y)$ 个 $i$，则 $1$ 至 $x$ 内共有 $\frac{\varphi(y)x}{y}$ 个数与 $y$ 互质。

你可能会说除了 $i + ky$ 形式的数，可能还有其他的数与 $y$ 互质，我们再来证明一下这不可能成立：

若一个数 $n$ 与 $y$ 互质，那么 $gcd(n, y) = 1$。

根据欧几里得算法，可得 $gcd(n \bmod y, y) = gcd(n, y) = 1$。

这时 $n \bmod y$ 一定为其中一个 $i$，否则 $gcd(n \bmod y, y) \not = 1$。

这就说明一个与 $y$ 互质的数一定可以被写成 $i + ky$ 的形式。

证毕。

回到题目，此时答案即为 $\frac{\varphi(m!)n!}{m!}$，然后我们就可以直接做了，预处理 $n!$ 及其逆元，以及 $\varphi(n!)$。

那么怎么得到 $\varphi(n!)$ 呢？考虑从 $\varphi((n - 1)!)$ 递推过来。

注意到 $n!$ 有一个性质，就是其为所有不大于 $n$ 的质数的倍数。也就是说 $\varphi(n!)$ 可以写成：

$$
\displaystyle \prod_{p \in \mathbb{P},p \mid n} \varphi(p^k)
$$

其中所有的 $k \ge 1$，分类讨论一下：

当 $n \in \mathbb{P}$ 时，$\varphi(n!) = \varphi((n - 1)!) \times (n − 1)$。

当 $n \not \in \mathbb{P}$ 时，$\varphi(n!)=\varphi((n - 1)!) \times n$。

于是可以递推得到 $\varphi(n!)$。

## 细节

预处理后，除法用逆元处理即可，提交以后，恭喜你，炸了。

因为题目中并没有说明 $r \gt m$，所以逆元可能会爆炸！

所以，在预处理时，我们要将所有数写成 $a \times r^b(r \nmid a)$ 的形式，用两个数组分别存储 $a$ 和 $b$。

当两数相乘时将 $a$ 相乘，将 $b$ 相加，当两数相除时用除数的 $a$ 乘上倍数数 $a$ 的逆元，将 $b$ 相减即可。

最后，如果答案的 $b \gt 0$ 那么答案 $ \bmod r$ 的结果即为 $0$，输出 $0$ 即可。

反之，如果答案的 $b = 0$，则输出答案的 $a$ 即可。

## 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

#define ll long long

int qpow(int a, int b, int mod){ // 快速幂 
	int ans = 1, t = a;
	for(; b > 0; b >>= 1){
		if(b & 1) ans = ((ll)ans * t) % mod;
		t = ((ll)t * t) % mod;
	}
	return ans;
}

const int N = 10000050;

int t, r, n, m, u, k;
int phia[N], phib[N]; // phia(i)的a和b
int tmsa[N], tmsb[N]; // i!的a和b 
bool vis[N];

int main(){
	cin >> t >> r;
	vis[1] = 1;
	// 埃氏筛筛质数 
	for(int i = 1; i < N; i ++)
		if(!vis[i])
			for(int j = i; (ll)j * i < N; j ++)
				vis[i * j] = 1;
	// 预处理 
	phia[0] = 1; phib[0] = 0; tmsa[0] = 1; tmsb[0] = 0;
	for(int i = 1; i < N; i ++){
		// 处理阶乘 
		u = i, k = 0;
		while(u % r == 0) u /= r, k ++; // 将i中所有的r除出来 
		tmsa[i] = ((ll)tmsa[i - 1] * u) % r; /*将a相乘*/ tmsb[i] = tmsb[i - 1] + k /*将b相加*/;
		// 处理phi前缀积 
		u = (vis[i] ? i : i - 1), k = 0;
		while(u % r == 0) u /= r, k ++; // 将i中所有的r除出来
		phia[i] = ((ll)phia[i - 1] * u) % r; /*将a相乘*/ phib[i] = phib[i - 1] + k /*将b相加*/;
	}
	while(t --){
		scanf("%d%d", &n, &m);
		int ans = (ll)tmsa[n] * phia[m] % r * qpow(tmsa[m], r - 2, r) % r; // 求出答案的a 
		if(tmsb[n] + phib[m] - tmsb[m] == 0) printf("%d\n", ans); // 若答案的b为零，输出ans的a 
		else printf("0\n"); // 否则答案为r的倍数，输出0 
	}
	return 0;
} 
```

---

## 作者：chenwenmo (赞：1)

看到互质可以考虑欧拉函数。

重要性质：$\gcd(a,b)=\gcd(a+b,b)$。于是我们可以把 $[1,M!]$ 与 $M$ 互质的数扩展到 $[1+k(M!),(k+1)(M!)]$，

> 性质证明：
>
> 设 $\gcd(a,b)=d$，$a=xd$，$b=yd$，$(a,b>0)$
>
> 则 $\gcd(a+b,b)=\gcd((x+y)d,yd)=d\gcd(x+y,y)$，
>
> 接下来只需证 $\gcd(x+y,y)=1$，
>
> 考虑反证，若 $\gcd(x+y,y)=g>1$，设 $y=ng$，$x+y=mg$，则 $x=(m-n)g$，这与 $\gcd(a,b)=d$ 矛盾。
>
> 证毕。

因此答案就是 $\varphi(M!)\times\frac{N!}{M!}$，

化简：

$$
\begin{aligned}
& \varphi(M!)\times\frac{N!}{M!} \\
=&\frac{N!}{M!}\times M!\times\prod\limits_{p\le M,p\in\mathrm{prime}} \frac{p-1}{p} \\
=&N! \times \prod\limits_{p\le M,p\in\mathrm{prime}} \frac{p-1}{p}
\end{aligned}
$$

Corner Case：若直接乘上 $\prod p$ 的逆元，可能会出现 $R\le M$ 的情况，此时 $0$ 不存在逆元，于是会错误地导致答案算成 $0$。正确答案应该是 $R$ 和 $N!$ 中的 $R$ 消掉，然后再进行取模。因此需要判断是否 $N\ge R,M<R$，若是则输出 $0$，否则要提前约分。

---

## 作者：Chenyichen0420 (赞：0)

## 思路分析

显然答案是 $\frac{n!}{m!}\times\varphi(m!)=n!\times\frac{\varphi(m)}{m!}$。

所以我们可以分别预处理出 $n!$ 和 $\frac{\varphi(m)}{m!}$。

但是有一点小问题需要修理一下：有可能 $n!$ 含有质因子 $R$，而且 $\frac{m!}{\varphi(m)}$ 也有。最后乘起来正好抵消掉了。比如 `1 3 4 3`。

所以说在枚举的时候，我们可以特殊处理一下 $i\equiv 0\pmod R$ 的情况。

显然如果 $i=R$，那么我们令 $\frac{\varphi(i)}{i!}=\frac{\varphi(i-1)}{(i-1)!}\times(i-1)$ 而不是 $\frac{i-1}{i}$。相当于我们提前削掉了 $\frac{m!}{\varphi(m)}$ 的一个 $R$。显然他最多也就只会有一个 $R$。

同样的，我们需要在同一个消掉 $n!$ 的一个 $R$。而显然 $n!$ 在 $n=R$ 的时候正好有第一个 $R$。我们在这个地方让 $n!=(n-1)!$ 即可。

那我们怎么知道什么时候应该有 $R$，使得答案为 $0$，什么时候没有呢？显然当且仅当 $n$ 中 $R$ 的因子数比 $m$ 中多时才是 $0$。而显然一个极为简单的判断方式是 $\lfloor\frac{n}{R}\rfloor>\lfloor\frac{m}{R}\rfloor$。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
constexpr bool online = 0;
#define int long long
int t, mod, n, m, p[1000005], pc[10000005], cnt, ans, jc[10000005]; 
bool isp[10000005];
inline int qpow(int a, int b, int p) {
	int ret = 1;
	for (; b; b >>= 1, a = a * a % p)
		(b & 1) && (ret = ret * a % p);
	return ret;
}
inline void tmod(int& l, const int r) { l = (l % mod + mod) % mod; }
inline int calc(int n, int m) {
	if (n / mod > m / mod) return 0;
	return jc[n] * pc[m] % mod;
}
signed main() {
	if (online)
		freopen("b.in", "r", stdin),
		freopen("b.out", "w", stdout);
	ios::sync_with_stdio(0); cin >> t >> mod; isp[1] = 1;
	for (int i = 2; i <= 1e7; ++i) {
		if (!isp[i]) p[++cnt] = i;
		for (int j = 1; j <= cnt && i * p[j] <= 1e7; ++j)
			if (isp[i * p[j]] = 1, i% p[j] == 0) break;
	}
	for (int i = jc[0] = pc[0] = 1; i <= 1e7; ++i)
		if (i != mod) {
			if (!isp[i])
				pc[i] = pc[i - 1] * qpow(i, mod - 2, mod) % mod * (i - 1) % mod;
			else pc[i] = pc[i - 1]; jc[i] = jc[i - 1] * i % mod;
		}
		else
			pc[i] = pc[i - 1] * (i - 1) % mod,
			jc[i] = jc[i - 1] * i / mod % mod;
	while (t--) cin >> n >> m, cout << calc(n, m) << endl;
}
```

---


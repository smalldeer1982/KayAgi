# [HAOI2012] 高速公路

## 题目背景

Y901 高速公路是一条重要的交通纽带，政府部门建设初期的投入以及使用期间的养护费用都不低，因此政府在这条高速公路上设立了许多收费站。

## 题目描述

Y901 高速公路是一条由 $n-1$ 段路以及 $n$ 个收费站组成的东西向的链，我们按照由西向东的顺序将收费站依次编号为 $1 \sim n$，从收费站 $i$ 行驶到 $i+1$（或从 $i+1$ 行驶到 $i$）需要收取 $v_i$ 的费用。高速路刚建成时所有的路段都是免费的，即所有 $v_i = 0$。

政府部门根据实际情况，会不定期地对连续路段的收费标准进行调整，根据政策涨价或降价。

无聊的小 A 同学总喜欢研究一些稀奇古怪的问题，他开车在这条高速路上行驶时想到了这样一个问题：对于给定的 $l,r$，在第 $l$ 个到第 $r$ 个收费站里等概率随机取出两个不同的收费站 $a$ 和 $b$，那么从 $a$ 行驶到 $b$ 将期望花费多少费用呢?


## 说明/提示

#### 数据规模与约定

本题共 $10$ 个测试点，各测试点数据规模如下表所示


| 测试点编号 | $n=$ | $m=$ |
| :------: | :---: | :-: |
|$1$| $10$ |$10$|
|$2$|    $100$ |    $100$ |
|$3$  |  $1000$ |   $1000$|
|$4$   | $10000$ |   $10000$|
|$5$    |$50000$  |  $50000$|
|$6$  |  $60000$   | $60000$|
|$7$   | $70000$ |   $70000$|
|$8$   | $80000$  |  $80000$|
|$9$    |$90000$   | $90000$|
|$10$   | $100000$  |  $100000$|

对于全部的测试点，保证 $1 \leq n, m \leq 10^5$，$op \in \{\texttt C, \texttt Q\}$，$1 \leq l \leq r \leq n$，$-10^4 \leq v \leq 10^4$，在任何时刻，$0\leq v_i \leq 10^4$。

## 样例 #1

### 输入

```
4 5
C 1 4 2
C 1 2 -1
Q 1 2
Q 2 4
Q 1 4
```

### 输出

```
1/1
8/3
17/6
```

# 题解

## 作者：sdgzy (赞：38)

这道题让我们求边,因为题目是一条链,所以直接采用把边编上号.看成序列即可.       
$1$与$2$号点的边连得是. 编号为$1$的点.查询的时候把$r - 1$就好了.    
这里的期望显然就是路径的平均值.    
期望值: $$\dfrac{\sum_{i=l}^r\sum_{j=l}^{r}dis[i][j]}{C_{r-l+1}^2}$$    
下面部分可以直接算出:    
上面这一部分比较难维护.    
考虑每一条边会被走过多少次.    
$$ans = \sum_{i=l}^ra[i]*(r-i+1)(i-l+1)$$    
相当于枚举这个点左右两条路.    
然后拆开.    
再化简一下式子.    
形成下面这个模样.    
$$ans = (r - l + 1 - r * l) * sum1 + (r + l) * sum2 - sum3$$    
其中    
$sum1 = \sum_{i=l}^r a[i]$    
$sum2 = \sum_{i=l}^r a[i]*i$    
$sum3 = \sum_{i=l}^r a[i] * i * i$    
然后我们用线段树维护一下.    
考虑合并.    
$sum1 = lson_{sum1} + rson_{sum1}$    
$sum2 = lson_{sum2} + rson_{sum2}$    
$sum3 = lson_{sum3} + rson_{sum3}$    
合并是比较简单了.    
添加值得时候如何添加?    
设添加的值为$k$    
此时的式子就变成了.    
$sum1$比较简单,直接加上区间的长度乘以$k$即可.    
$sum2$要加上$k*\sum i$然后维护一下区间$i$的和.我们称它为$sum5$,或者考虑等差数列求和的方法也可以.    
$sum3$要加上$k * \sum i ^2$我们这里必须要维护$sum4$,它代表$\sum i^2$    
$sum4$ 和 $sum5$ 是一个定值.在建树的时候更新就行了.    
然后这个题就完成了.    
特别注意的是.由于我们**设边为点**.所以要$r -= 1$
如果直接$r -=1$的话,下面的分母要改成.$C_{r-l + 2}^2$       
## 最后,打个广告:[My blog](https://www.cnblogs.com/tpgzy/)    
CODE:    
```cpp
#include <iostream>
#include <cstdio>
#define lson now << 1
#define rson now << 1 | 1
#define ll long long
const ll maxN = 100000 + 7;

inline ll read() {
    ll x = 0,f = 1;char c = getchar();
    while(c < '0' || c > '9') {if(c == '-')f = -1;c = getchar();}
    while(c >= '0' && c <= '9') {x = x * 10 + c - '0';c = getchar();}
    return x * f;
}

ll gcd(ll a,ll b) {
    return !b ? a : gcd(b,a % b);
}

struct Node {
    ll sum[6];
    ll lazy;
    ll l,r;
}tree[maxN << 2];
ll sum1,sum2,sum3;

void updata(ll now) {
    tree[now].sum[1] = tree[lson].sum[1] + tree[rson].sum[1];
    tree[now].sum[2] = tree[lson].sum[2] + tree[rson].sum[2];
    tree[now].sum[3] = tree[lson].sum[3] + tree[rson].sum[3];
    return ;
}

void build(ll l,ll r,ll now) {
    tree[now].l = l;tree[now].r = r;
    if(l == r) {
        tree[now].sum[4] = l * l;
        tree[now].sum[5] = l;
        return ;
    }
    ll mid = (l + r) >> 1;
    build(l,mid,lson);
    build(mid + 1,r,rson);
    tree[now].sum[4] = tree[lson].sum[4] + tree[rson].sum[4];
    tree[now].sum[5] = tree[lson].sum[5] + tree[rson].sum[5];
    return ;
}

void work(ll now,ll k) {
    tree[now].sum[1] += (tree[now].r - tree[now].l + 1) * k;
    tree[now].sum[2] += k * tree[now].sum[5];
    tree[now].sum[3] += k * tree[now].sum[4];
    tree[now].lazy += k;
}

void pushdown(ll now) {
    work(lson,tree[now].lazy);
    work(rson,tree[now].lazy);
    tree[now].lazy = 0;
    return ;
}

void modify(ll l,ll r,ll now,ll val) {
    if(tree[now].l >= l && tree[now].r <= r) {
        work(now,val);
        return ;
    }
    if(tree[now].lazy) pushdown(now);
    ll mid = (tree[now].l + tree[now].r) >> 1;
    if(mid >= l) modify(l,r,lson,val);
    if(mid < r) modify(l,r,rson,val);
    updata(now);
    return ;
}

void query(ll l,ll r,ll now) {
    if(tree[now].l >= l && tree[now].r <= r)  {
        sum1 += tree[now].sum[1];
        sum2 += tree[now].sum[2];
        sum3 += tree[now].sum[3];
        return ;
    }
    if(tree[now].lazy) pushdown(now);
    ll mid = (tree[now].l + tree[now].r) >> 1;
    if(mid >= l) query(l,r,lson);
    if(mid < r) query(l,r,rson);
    return ;
}

int main()
{   
    ll n,m,l,r,v;
    char s[3];
    n = read();m = read();
    build(1,n,1);
    while(m --) {
        scanf("%s",&s);
        l = read();r = read() - 1;
        if(s[0] == 'C') {
            v = read();
            modify(l,r,1,v);
        }
        else {
            ll a;
            sum1 = sum2 = sum3 = 0;
            query(l,r,1);
            a = (r - l + 1 - r * l) * sum1 + (r + l) * sum2 - sum3;
            ll b = ( r - l + 2 ) * (r - l + 1) / 2;
            ll g = gcd(a,b);
            printf("%lld/%lld\n", a / g,b / g);
        }
    }
    return 0;
}
```

---

## 作者：litble (赞：16)

这道题要求对区间做修改，查询，并且数据范围是1e5。**猜测解法：线段树**

ans=询问的公路区间的所有子区间权值和/有多少子区间。分母可以迅速算出，（即设区间长度为L,分母为$C_L^2$），那么我们用线段树维护分子即可。

那么，主要矛盾就是pushup怎么写，即如何通过左半区间$l$和右半区间$r$的答案得到当前区间的答案。

大力乱推得到我们要维护的东西：答案$ans(x)$，区间权值和$sum(x)$，区间长度$len(x)$，从最左端开始的连续子区间权值和，即$ls(x)=\sum_{r=1}^{len}\sum_{i=1}^rv_i$，从最右端开始的连续子区间和，即$rs(x)=\sum_{l=1}^{len}\sum_{i=l}^{len}v_i$

那么:

$sum(x)=sum(l)+sum(r)$

$len(x)=len(l)+len(r)$

$ls(x)=ls(l)+(ls(r)+sum(l)*len(r))$

$rs(x)=rs(r)+(rs(l)+sum(r)*len(l))$

$ans(x)=ans(l)+ans(r)+rs(l)*len(r)+ls(r)*len(l)$

解释一下最后一个式子，首先考虑全在左半区间的子区间，再考虑全在右半区间的，最后考虑跨越的，这个用一种“贡献”的思想考虑，每个从左半区间右边开始的子区间，都会与右半区间一个右端点结合，右半区间左边开始的子区间同理。

然后就是修改操作了，假设我们要在$x$区间上对每个数加上值$c$，那么：

$sum(x)+=len(x)*c$

$ls(x)+=\frac{len(x)(len(x)+1)}{2}*c$

$rs(x)+=\frac{len(x)(len(x)+1)}{2}*c$

问题来了，$ans(x)$怎么办呢？考虑长度为i的子区间有多少个

$ans(x)+=\sum_{i=1}^{len(x)} i*(len(x)-i+1)*c$

$ans(x)+=(len(x)*\frac{(1+len(x))len(x)}{2}-\sum_{i=1}^{len(x)}(i-1)i)*c$

设$s=\sum_{i=1}^{len(x)}(i-1)$

则$s+\frac{len(x)(len(x)-1)}{2}=\sum_{i=1}i^2=\frac{len(x)(len(x)+1)(2*len(x)+1)}{6}$

所以$ans(x)+=(\frac{(1+len(x))^2len(x)}{2}-\frac{len(x)(len(x)+1)(2*len(x)+1)}{6})*c$

```cpp
#include<bits/stdc++.h>
using namespace std;
int read() {
	int q=0,w=1;char ch=' ';
	while(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();
	if(ch=='-') w=-1,ch=getchar();
	while(ch>='0'&&ch<='9') q=q*10+ch-'0',ch=getchar();
	return q*w;
}
#define RI register int
typedef long long LL;
const int N=100005;
int n,m;LL ls[N<<2],rs[N<<2],sum[N<<2],laz[N<<2],ans[N<<2];

void pd(int s,int t,int i) {//pushdown函数
	int mid=(s+t)>>1,l=i<<1,r=(i<<1)|1;
	LL lc=mid-s+1,rc=t-mid,v=laz[i];
	laz[l]+=v,laz[r]+=v,sum[l]+=lc*v,sum[r]+=rc*v;
	ls[l]+=lc*(lc+1)/2*v,rs[l]+=lc*(lc+1)/2*v;
	ls[r]+=rc*(rc+1)/2*v,rs[r]+=rc*(rc+1)/2*v;
	ans[l]+=((1+lc)*lc/2*(1+lc)-lc*(lc+1)*(2*lc+1)/6)*v;
	ans[r]+=((1+rc)*rc/2*(1+rc)-rc*(rc+1)*(2*rc+1)/6)*v;
	laz[i]=0;
}
void up(int s,int t,int i) {//pushup函数
	int l=i<<1,r=(i<<1)|1,mid=(s+t)>>1;
	sum[i]=sum[l]+sum[r];
	ls[i]=ls[l]+ls[r]+1LL*(t-mid)*sum[l];
	rs[i]=rs[l]+rs[r]+1LL*(mid-s+1)*sum[r];
	ans[i]=ans[l]+ans[r]+1LL*(mid-s+1)*ls[r]+1LL*(t-mid)*rs[l];
}
void chan(int l,int r,int s,int t,int i,LL v) {
	if(l==s&&t==r) {
		laz[i]+=v,sum[i]+=1LL*(t-s+1)*v;LL len=t-s+1;
		ls[i]+=len*(len+1)/2*v,rs[i]+=len*(len+1)/2*v;
		ans[i]+=((1+len)*len/2*(1+len)-len*(len+1)*(2*len+1)/6)*v;
		return;
	}
	int mid=(s+t)>>1;
	if(laz[i]) pd(s,t,i);
	if(r<=mid) chan(l,r,s,mid,i<<1,v);
	else if(mid+1<=l) chan(l,r,mid+1,t,(i<<1)|1,v);
	else chan(l,mid,s,mid,i<<1,v),chan(mid+1,r,mid+1,t,(i<<1)|1,v);
	up(s,t,i);
}
struct node{LL sum,ls,rs,len,ans;};
node query(int l,int r,int s,int t,int i) {
	if(l==s&&t==r) return (node){sum[i],ls[i],rs[i],t-s+1,ans[i]};
	int mid=(s+t)>>1;
	if(laz[i]) pd(s,t,i);
	if(r<=mid) return query(l,r,s,mid,i<<1);
	else if(mid+1<=l) return query(l,r,mid+1,t,(i<<1)|1);
	else {
		node k1=query(l,mid,s,mid,i<<1),k2=query(mid+1,r,mid+1,t,(i<<1)|1),re;
		re.sum=k1.sum+k2.sum;
		re.ls=k1.ls+k2.ls+k1.sum*k2.len;
		re.rs=k1.rs+k2.rs+k2.sum*k1.len;
		re.ans=k1.ans+k2.ans+k1.rs*k2.len+k1.len*k2.ls;
		re.len=k1.len+k2.len;
		return re;
	}
}
LL gcd(LL a,LL b) {return !b?a:gcd(b,a%b);}
int main()
{
	char ch[10];int x,y,z;
	n=read(),m=read();
	while(m--) {
		scanf("%s",ch),x=read(),y=read();
		if(ch[0]=='C') chan(x,y-1,1,n,1,read());
		else {
			node QvQ=query(x,y-1,1,n,1);
			LL ans1=QvQ.ans,ans2=1LL*(y-x+1)*(y-x)/2,kl=gcd(ans2,ans1);
			printf("%lld/%lld\n",ans1/kl,ans2/kl);
		}
	}
    return 0;
}
```

---

## 作者：ComplexPlanck (赞：15)


[题目链接](https://www.luogu.com.cn/problem/P2221)

区间加，区间查询，很容易想到线段树，不过先别急，我们先推导一下在$\,[l,r]\,$收费站中任意选两个不同收费栈期望花费的费用$\,C(l,r)\,$：

不妨枚举题面中的$\,x,y\,$，那么费用就是$\,\sum_{z=x}^{y-1}v_z\,$，而且显然有$\,(r-l+1)(r-l)/2\,$种可能，所以：

$$
C(l,r)=\dfrac{2}{(r-l+1)(r-l)}\left(\sum_{x=l}^{r}\sum_{y=x+1}^{r}\sum_{z=x}^{y-1}v_z\right) 
$$

前面那个$\,\dfrac{2}{(r-l+1)(r-l)}\,$太麻烦了，我们简记为$\,\lambda\,$，然后我们开始推导吧：

$$
\begin{aligned}
C(l,r)&=\lambda\left(\sum_{x=l}^{r}\sum_{y=x+1}^{r}\sum_{z=x}^{y-1}v_z\right)\\
&=\lambda\left(\sum_{x=l}^{r}\sum_{y=x+1}^{r}\left(\sum_{z=l}^{y-1}v_z-\sum_{z=l}^{x-1}v_z\right)\right)&\texttt{将和式拆开}\\
&=\lambda\left(\sum_{x=l}^{r}\sum_{y=x+1}^{r}\sum_{z=l}^{y-1}v_z-\sum_{x=l}^{r}\sum_{y=x+1}^{r}\sum_{z=l}^{x-1}v_z\right)&\texttt{将和式拆开}\\
&=\lambda\left(\sum_{x=l}^{r}\sum_{y=l}^{r}[x+1\leqslant y]\sum_{z=l}^{r}[z\leqslant y-1]v_z-\sum_{x=l}^{r}\sum_{y=l}^{r}[x+1\leqslant y]\sum_{z=l}^{r}[z\leqslant x-1]v_z\right)\\
&\!\!\!\!\!\!\!\!\!\!\!\!//\,\texttt{将含有循环变量的上下界转为真值表达式以及无循环变量的上下界，方便交换求和符号}\\
&=\lambda\left(\sum_{z=l}^{r}v_z\sum_{y=l}^{r}[z\leqslant y-1]\sum_{x=l}^{r}[x+1\leqslant y]\!\!-\!\!\sum_{z=l}^{r}v_z\sum_{x=l}^{r}[z\leqslant x-1]\sum_{y=l}^{r}[x+1\leqslant y]\right)&\texttt{交换求和顺序}\\
&=\lambda\left(\sum_{z=l}^{r}v_z\sum_{y=l}^{r}[z\leqslant y-1]\sum_{x=l}^{y-1}1-\!\!\sum_{z=l}^{r}v_z\sum_{x=l}^{r}[z\leqslant x-1]\sum_{y=x+1}^{r}1\right)&\texttt{将真值表达式转回上下界}\\
&=\lambda\left(\sum_{z=l}^{r}v_z\sum_{y=l}^{r}[z\leqslant y-1](y-l)-\sum_{z=l}^{r}v_z\sum_{x=l}^{r}[z\leqslant x-1](r-x)\right)&\texttt{计算}\\
&=\lambda\left(\sum_{z=l}^{r}v_z\sum_{x=l}^{r}[z\leqslant x-1](x-l)-\sum_{z=l}^{r}v_z\sum_{x=l}^{r}[z\leqslant x-1](r-x)\right)&\texttt{换个变量名}\\
&=\lambda\left(\sum_{z=l}^{r}v_z\sum_{x=l}^{r}[z\leqslant x-1](2x-l-r)\right)&\texttt{乘法分配律合并}\\
&=\lambda\left(\sum_{z=l}^{r}v_z\left(2\sum_{x=l}^{r}[z+1\leqslant x]x-(l+r)\sum_{x=l}^{r}[z+1\leqslant x]\right)\right)&\texttt{乘法分配律拆开}\\
&=\lambda\left(\sum_{z=l}^{r}v_z\left(2\sum_{x=z+1}^{r}x-(l+r)\sum_{x=z+1}^{r}1\right)\right)&\texttt{去掉真值表达式}\\
&=\lambda\left(\sum_{z=l}^{r}v_z((r+z+1)(r-z)-(l+r)(r-z))\right)&\texttt{等差数列求和}\\
&=\lambda\left(\sum_{z=l}^{r}v_z\left(-z^2+z(r+l-1)-r(l-1)\right)\right)&\texttt{拆开括号}\\
&=\lambda\left(-\sum_{z=l}^{r}z^2v_z+(r+l-1)\sum_{z=l}^{r}zv_z-r(l-1)\sum_{z=l}^{r}v_z\right)&\texttt{乘法分配律拆开}\\

\end{aligned} 
$$

其中$\,\sum_{z=l}^{r}z^2v_z$、$\sum_{z=l}^{r}zv_z$、$\sum_{z=l}^{r}v_z\,$都是具有结合律的，可以用线段树维护，剩下的系数都只和$\,l,r\,$有关。

考虑一下增量$\,v$：

$$
\begin{aligned}
\sum_{z=l}^{r}z^2(v_z+v)&=\sum_{z=l}^{r}z^2v+\color{red}{\sum_{z=l}^{r}z^2v_z}\\
&=v\sum_{z=l}^{r}z^2+\color{red}{\sum_{z=l}^{r}z^2v_z}\\
&=v\left(\sum_{z=1}^{r}z^2-\sum_{z=1}^{l-1}z^2\right)+\color{red}{\sum_{z=l}^{r}z^2v_z}\\
&=\color{blue}v\left(\dfrac{1}{6}r(r+1)(2r+1)-\dfrac{1}{6}(l-1)l(2l-1)\right)\color{black}+\color{red}{\sum_{z=l}^{r}z^2v_z}
\end{aligned}
$$

---
$$
\begin{aligned}
\sum_{z=l}^{r}z(v_z+v)&=\sum_{z=l}^{r}zv+\color{red}{\sum_{z=l}^{r}zv_z}\\
&=v\sum_{z=l}^{r}z+\color{red}{\sum_{z=l}^{r}zv_z}\\
&=v\left(\sum_{z=1}^{r}z-\sum_{z=1}^{l-1}z\right)+\color{red}{\sum_{z=l}^{r}zv_z}\\
&=\color{blue}v\left(\dfrac{1}{2}r(r+1)-\dfrac{1}{2}(l-1)l\right)\color{black}+\color{red}{\sum_{z=l}^{r}z^2v_z}
\end{aligned}
$$

---
$$
\begin{aligned}

\sum_{z=l}^{r}(v_z+v)&=\sum_{z=l}^{r}v+\color{red}{\sum_{z=l}^{r}v_z}\\
&=v\sum_{z=l}^{r}1+\color{red}{\sum_{z=l}^{r}zv_z}\\
&=\color{blue}v(r-l+1)\color{black}+\color{red}{\sum_{z=l}^{r}zv_z}
\end{aligned}
$$

其中蓝色的部分是这一个部分的增量，红色部分是原来的结果。求出之后之间按照我们之前的这个式子来计算答案：

$$
C(l,r)=\lambda\left(-\sum_{z=l}^{r}z^2v_z+(r+l-1)\sum_{z=l}^{r}zv_z-r(l-1)\sum_{z=l}^{r}v_z\right)
$$

记得特判$\,l=r\,$的情况，此时分子分母都为$\,0$，直接输出 `0/1`。

---
示例代码:

```cpp
#include <bits/stdc++.h>
using i64 = long long;
using i128 = __int128;

const int N = 100010;
int n, m;
struct SegNode
{
	int l, r;
	i128 sum, timsum, squsum;
	i64 plus;
};
SegNode a[N << 2];

template<typename types>
void read(types &x)
{
	x = 0; int f = 1; char ch = getchar();
	while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();}
	while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
	x *= f; return;
}
template<typename types>
void write(types x)
{
	if (x < 0) putchar('-'), x = -x;
	if (x > 9) write(x / 10);
	putchar(x % 10 + '0'); return;
}
i128 GCD(i128 x, i128 y)
{
	return y ? GCD(y, x % y) : x;
}
void pushup(SegNode &x, const SegNode &y, const SegNode &z)
{
	x.sum = y.sum + z.sum;
	x.timsum = y.timsum + z.timsum;
	x.squsum = y.squsum + z.squsum;
	return;
}
void plusit(int p, i64 x)
{
    a[p].sum += x * (a[p].r - a[p].l + 1);
	a[p].timsum += x * (i128(a[p].l + a[p].r) * (a[p].r - a[p].l + 1) / 2);
	a[p].squsum += x * (i128(a[p].r) * (a[p].r + 1) * (2ll * a[p].r + 1) / 6 - i128(a[p].l - 1) * a[p].l * (2ll * a[p].l - 1) / 6);
	a[p].plus += x;
    return;
}
void pushdown(int p)
{
	if (!a[p].plus) return;
	plusit(p << 1, a[p].plus);
	plusit(p << 1 | 1, a[p].plus);
	a[p].plus = 0; return;
}
void build(int p, int inl, int inr)
{
	a[p].l = inl, a[p].r = inr, a[p].plus = 0;
	if (inl == inr)
	{
		a[p].sum = a[p].squsum = a[p].timsum = 0;
		return;
	}
	int mid = (inl + inr) >> 1;
	build(p << 1, inl, mid),
	build(p << 1 | 1, mid + 1, inr);
	pushup(a[p], a[p << 1], a[p << 1 | 1]); return;
}
void add(int p, int x, int y, int k)
{
	if (x <= a[p].l && a[p].r <= y)
	{
		plusit(p, k); return;
	}
	pushdown(p);
	int mid = (a[p].l + a[p].r) >> 1;
	if (x <= mid) add(p << 1, x, y, k);
	if (y > mid) add(p << 1 | 1, x, y, k);
	pushup(a[p], a[p << 1], a[p << 1 | 1]); return;
}
SegNode ask(int p, int x, int y)
{
	if (x <= a[p].l && a[p].r <= y)
		return a[p];
	pushdown(p);
	int mid = (a[p].l + a[p].r) >> 1;
	if (x <= mid && y > mid)
	{
		SegNode res; pushup(res, ask(p << 1, x, y), ask(p << 1 | 1, x, y));
		return res;
	}
	else if (x <= mid) return ask(p << 1, x, y);
	else if (y > mid) return ask(p << 1 | 1, x, y);
	pushup(a[p], a[p << 1], a[p << 1 | 1]);
	puts("ERROR"); exit(0); SegNode res; return res;
}

int main(void)
{
	read(n), read(m);
	build(1, 1, n);
	int inpl, inpr, inpk; char inpo[2];
	for (int i = 1; i <= m; ++ i)
	{
		scanf("%s", inpo);
		if (inpo[0] == 'C')
		{
			read(inpl), read(inpr), read(inpk);
			add(1, inpl, inpr - 1, inpk);
		}
		else if (inpo[0] == 'Q')
		{
			read(inpl), read(inpr);
			int len = (inpr - inpl + 1);
			if (len == 1) {puts("0/1"); continue;}
			SegNode ans = ask(1, inpl, inpr);
			i128 zi = i128(inpl + inpr - 1) * ans.timsum - i128(inpr) * (inpl - 1) * ans.sum - ans.squsum;
			i128 mu = i128(len) * (len - 1) / 2;
			i128 d = GCD(zi, mu);
			zi /= d, mu /= d;
			write(zi), putchar('/'), write(mu), putchar('\n');
		}
	}
	return 0;
}
```


---

## 作者：jjsnam (赞：14)

# 写在前面

最近期望学的头大。好久没有自己 AC 紫题了，碰巧这道题让我实现了。AC 后打开题解发现 1k 多人提交竟然还没有关闭题解通道？那赶紧来写一发。

## 前置知识

- 线段树
- 期望、概率
- 辗转相除法

## 题目描述（戳这里[查看原题](https://www.luogu.com.cn/problem/P2221)）

- 给定数轴上 $n$ 个点，$n - 1$ 个**相邻点**的线段。$v_i$ 表示线段 $[i, i+1]$ 的值。初始时对于 $\forall i \in [1, n-1]$，$ v_i = 0$。

- 定义如下两个操作（总共 $m$ 次）：

	- **更改**：给定 $l$、$r$、$v$，将 $[l,r]$ 中所有线段的值增加 $v$。
    - **询问**：给定 $l$、$r$，求在 $[l,r]$ **等概率任意**取**不同**两点 $a$、$b$，求 $[a,b]$ **覆盖的线段的值的期望**。

- 对于询问，输出一个**分数**，要求**不能再约分**。
    
- $1 ≤ n, m ≤ 10^5$，保证 $0 ≤ v_i ≤ 10^4$。

# 正文

## 确定方向

对于求期望，我大致总结了 3 种方法：

1. 期望 DP（一般是逆推）
2. 根据期望定义推式子
3. 由期望的线性性，通过结合概率和变量求解

那么对于这道题，第一种方法显然是不行的，只带 $\log$ 的 DP 我做这么多题还没见过。因此我们更多从期望的定义以及其与概率的关系入手此题。

## 分析

根据此题中期望的定义，我们可以尝试求出所有情况的通行费用，并将每种情况乘以其对应的概率得到总期望。   
又由于所有情况都是等概率，我们可以算出所有情况费用总和，乘以同一概率。写出来的式子写出来大概是：
	
  $E(l,r) = \dfrac 1 {P(l,r)} \times Sum_v $
   
先来求 ${P(l,r)}$。询问区间 $[l,r]$ 的长度 $len = r-l+1$。点 $a$ 在区间中等概率选择，$P(a) = \dfrac1 {len}$。$b$ 在剩下的 $len - 1$ 个点中等概率选择，$P(b) = \dfrac1 {len-1}$。因而：

$P(l,r) = P(a)\times P(b) = \dfrac 1 {len\times (len-1)} = \dfrac 1 {(r-l+1)\times (r-l)}$。

因此分母部分就是我们求出答案的**分母**。


------------


再来考虑分子，也就是所有情况的费用和。我们看一看样例的最后一次询问。询问 $[1,4]$。对应 $P(1,4) = \dfrac 1 {12}$。对应的分子，也就是所有情况的总费用，我们通过固定起点找终点，总和为 $34$（**注意正反向**）。因此答案 $E(1,4) = \dfrac {34} {12} = \dfrac {17} 6$。

如何求呢？在我们手动模拟时定起点找终点很麻烦，对于程序来说是 $O(n^2)$ 的，而且有许多不同的区间。我们不妨把问题拆解成**计算每一个相邻线段对答案的贡献**。

![](https://cdn.luogu.com.cn/upload/image_hosting/95diafbf.png)

拿线段 $[1,2]$ 举例。起点为 1，路程覆盖 $3$ 次（蓝色），起点 2、3、4 分别覆盖 $1$ 次（绿色）。所以它对最后得分子贡献了 $6$ 次自己的费用。

继续思考。**在询问区间中**，线段 $[1,2]$ 左侧的端点只有 $1$ **这一个**，右侧总共有**三个点**。正向反向总共 $2\times(1\times 3) = 6$。似乎一条线段对最后总和的贡献只与它左右有多少起终点有关？细想确实合理。我们设线段左侧有 $p$ 个可能的起点，右侧有 $q$ 个可能的终点，根据乘法原理，包含该线段的路径总共有 $p\times q$ 个。考虑正反向再乘以 $2$。带入线段 $[2,3]$ 验证成功。（$8=2\times(2 \times 2)$）

故对于询问区间 $[l,r]$ 的一条相邻线段 $[i,i+1]$，有：

$p = i-l+1$；$q = r-(i+1)+1 = r-i$。（就是区间长度）

所以我们的分子可以表示成每个相邻点线段贡献的次数乘以其费用（注意**右边界**）：

$$ \displaystyle \sum_{i = l}^{r-1} {(i-l+1)\times(r-i)\times v_i} $$


## 实现

对于上述式子，以及数据范围，我们知道最好通过数据结构维护。又有区间加操作，我们考虑线段树。

然而，这个式子里都是乘法，怎么用线段树维护区间和呢？

我觉得大家刚学线段树的时候应该都做过类似维护高次和的线段树题，这题我们也可以这么尝试，毕竟对线段树的暗示已经很强烈了，如果不往下想想太可惜。

既然有乘法，我们就**拆乘法**。合并同次项看看能不能有什么新发现，有：

$$\begin{aligned}
&\displaystyle \sum_{i = l}^{r-1} {(i-l+1)\times(r-i)\times v_i}  \\

&=\displaystyle \sum {(i\times r -i^2-l\times r+i\times l+r-i)\times v_i} \\

&=\displaystyle \sum {[(r-l\times r)+(l+r-1)\times i - i^2]\times v_i}  \\

&=\displaystyle (r-l\times r)\times \sum_{i = l}^{r-1}{v_i} + (l+r-1)\times \sum_{i = l}^{r-1}{i\times v_i} - \sum_{i = l}^{r-1}{i^2\times v_i}
\end{aligned}
$$

这样我们成功将原式分离。对于 $v_i$、$i\times v_i$、$i^2\times v_i$，就可以考虑如何用线段树维护了。

具体的，我们将这三个和分别维护。对于区间 $[l,r]$ 增加 $v$ 的操作：

- **$v_i$**：对于一个节点 $now$ 所维护的和只需要增加区间长度乘以 $v$ 即可，即维护的值增加 $len_{now}\times v$。

- **$i\times v_i$**：这是就不是简单乘以区间长了。每个点实际增加的值是**不同的**，增加的值可表示为：$v\times \sum_{i=l}^{r}{i}$。因此我们要记录每个区间的 $\sum_{i=l}^{r}{i}$，这可以在建树时求出。

- **$i^2\times v_i$**：同理，请读者思考，最终我们在建树时要求得 $\sum_{i=l}^{r}{i^2}$。

这样我们就完全搞通这道题啦！

## 细节与注意

1. 线段树维护的是 $n-1$ 个线段，而不是 $n$ 个点，同样根据定义，在修改和查询时我们使用的区间是 $[l,r-1]$（根据输入的 $l$、$r$）。

2. 注意询问结果输出最简分数，对于求出的分子分母我们可以通过**欧几里得算法**计算公因子，然后同时除掉即可。

3. 考虑一下是否会爆 ```int```。乘积最大应当是 $(\dfrac n 2) ^2 = 2.5\times 10^9$，乘上最大贡献 $1\times 10^4$ 以及最大询问区间大概 $5\times 10^4$，则最后分子的数量级可至 $1\times 10^{18}$。同样分母也会爆。**需要 ```long long```**。（具体何处要开何处不要，请仔细思考，嫌麻烦直接 ```define int long long;``` 也是可以的）。

最终的时间复杂度是 $O(n\log n)$。

# 代码

变量名见注释。（其实这算是很好调的线段树了


```cpp
#include <iostream>
#include <algorithm>
#include <cstring>

#define ls (id << 1)
#define rs (id << 1 | 1)
#define mid ((l + r) >> 1)

using namespace std;
typedef long long ll;//优雅一点不全用long long，就是调的久一点ಥ_ಥ
const int maxn = 100005;

struct SegmentTree{
    ll sum0, sum1, sum2;
    /* 根据乘i的次数命名。sum0就是v[i]*i^0=v[i], sum1就是v[i]*i,sum2就是v[i]*i^2 */
    ll len, tot1, tot2;
    /* len是区间长，tot1/2就是sum{i}和sum{i^2} */
    ll lazy;//懒标记
}tr[maxn << 2];
int n, m;
struct Node{//线段树返回值
    ll sum0, sum1, sum2;

    Node operator + (const Node &b) const{//重载运算符方便返回
        Node res;
        res.sum0 = sum0 + b.sum0;
        res.sum1 = sum1 + b.sum1;
        res.sum2 = sum2 + b.sum2;
        return res;
    }
};

void pushup(int id){//通用 pushup
    tr[id].sum0 = tr[ls].sum0 + tr[rs].sum0;
    tr[id].sum1 = tr[ls].sum1 + tr[rs].sum1;
    tr[id].sum2 = tr[ls].sum2 + tr[rs].sum2;
}

void build(int id, int l, int r){
    tr[id].len = r - l + 1;
    tr[id].lazy = 0;
    if (l == r){
        tr[id].sum0 = tr[id].sum1 = tr[id].sum2 = 0;
        tr[id].tot1 = l, tr[id].tot2 = (ll)l * r;/* 注意爆int问题 */
        return;
    }
    build(ls, l, mid), build(rs, mid+1, r);
    pushup(id);
    /* 额外 pushup 别忘了 */
    tr[id].tot1 = tr[ls].tot1 + tr[rs].tot1;
    tr[id].tot2 = tr[ls].tot2 + tr[rs].tot2;
}

void pushdown(int id){
    if (tr[id].lazy){
        ll temp = tr[id].lazy;
        tr[id].lazy = 0;
        tr[ls].lazy += temp, tr[rs].lazy += temp;
        tr[ls].sum0 += tr[ls].len * temp,
        tr[ls].sum1 += tr[ls].tot1 * temp,
        tr[ls].sum2 += tr[ls].tot2 * temp;
        tr[rs].sum0 += tr[rs].len * temp,
        tr[rs].sum1 += tr[rs].tot1 * temp,
        tr[rs].sum2 += tr[rs].tot2 * temp;
    }
}

void update(int id, int l, int r, int a, int b, int v){
    if (a <= l && r <= b){
        tr[id].sum0 += tr[id].len * v,
        tr[id].sum1 += tr[id].tot1 * v,
        tr[id].sum2 += tr[id].tot2 * v;
        tr[id].lazy += v;
        return;
    }
    pushdown(id);
    if (a <= mid) update(ls, l, mid, a, b, v);
    if (b > mid) update(rs, mid+1, r, a, b, v);
    pushup(id);
}

Node query(int id, int l, int r, int a, int b){
    if (a <= l && r <= b){
        return (Node){tr[id].sum0, tr[id].sum1, tr[id].sum2};
    }
    pushdown(id);
    Node res = (Node){0, 0, 0};
    if (a <= mid) res = res + query(ls, l, mid, a, b);
    if (b > mid) res = res + query(rs, mid+1, r, a, b);
    return res;
}

ll gcd(ll a, ll b){
    return b ? gcd(b, a % b) : a;
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);

    cin >> n >> m;

    build(1, 1, n);

    char op;
    int l, r, v;
    while (m --){
        cin >> op;
        if (op == 'C'){
            cin >> l >> r >> v;
            update(1, 1, n, l, r-1, v);
        }
        else{
            cin >> l >> r;
            ll N, D;//numerator分子, denominator分母
            Node temp = query(1, 1, n, l, r-1);
            N = (r - (ll)l * r) * temp.sum0 + (l + r - 1) * temp.sum1 - temp.sum2;
            N <<= 1;
            D = (ll)(r - l + 1) * (r - l);/* 再次注意爆int问题 */
            ll d = gcd(N, D);
            cout << N/d << '/' << D/d << endl;
        }
    }

    return 0;
}
```

# 总结

主要是学习一下线段树和期望的结合。一定记住期望不只有 DP 一种实现方法。再遇到复杂式子不能直接上线段树时要勇于拆项合并同类项。瞪眼法没有用，只有勇于尝试多种方法，AC 才会到来。

感谢观看！


---

## 作者：Fading (赞：7)

这个题目真的是一个很好的练习自己概率期望的题！

看到什么区间加法，一秒线段树

然后如何维护边之间的和呢？

比如说

```
1号花费2到2号，2号花费4到3号
```

把每一条路的花费作为终点处的点的权值就好了

此时每一个点的权值就是


$$1\rightarrow0,2\rightarrow2,3\rightarrow4$$


这样就可以了。求 $l$ 到 $r$ 的花费就是 $[l+1,r]$ 的和

用线段树做加法也同理

我们记录一个前缀和数组 sum，然后发现 $l$ 到 $r$ 的花费就是 $\text{sum}_r-\text{sum}_l,$连$-1$也没有了~~超舒服~~

根据期望的定义$($~~其实就是平均数~~$)$

答案就是

$$\frac {\sum_{i=l}^r\sum_{j=i}^r(sum[j]-sum[i])}{C_{r-l+1}^{2}}$$

然后呢？下面谁都会求啊，我们考虑上面

用线段树维护这个奇怪的东西

我们根据之前做过的题目，考虑一个套路：

枚举 $[l,r]$ 的每一个位置出现了（被包含了）多少次

比如说区间 $[l,r]$

$l$ 肯定被区间 $[l,l],[l,l+1],...,[l,r]$ 包含

所以 $l$ 出现了 $r-l+1$ 次

$l+1$ 被 $[l+1,l+1],...,[l+1,r]$ 包含

也被 $[l,l+1],...,[l,r]$ 包含

共出现 $r-l+r-l=2(r-l)$

同理，$l+i$ 被 $[l+i,...]$ 开头的 $r-i+1$ 个区间包含
 
也被包含$l+i-1$的$r-i+1$个区间包含 $([l+i-1,l+i],...,[l+i-1,r])$

$......$

也被包含 $l$ 的 $r-i+1$ 个区间包含 $([l,l+i],...,[l,l+r])$

所以我们可以得知第$i$个数被包含的次数为 $(r-i+1)\cdot(i-l+1)$

所以上面的答案转化成了

$$\sum_{i=l}^ra_i\cdot(r-i+1)\cdot(i-l+1)$$

还是不能维护啊

那就拆开吧！

$$=\sum_{i=l}^ra_i\cdot(r-i+1)\cdot(i-l+1)$$

$$=\sum_{i=l}^ra_i\cdot[-i^2+1-lr-l+r+i(l+r)]$$

$$=\sum_{i=l}^ra_i\cdot[-i^2+(r-l-lr+1)+i(l+r)]$$

分离 $\sum$

就 
$$=-\sum_{i=l}^ra_i\cdot i^2+\sum_{i=l}^ra_i(r-l+1-lr)+\sum_{i=l}^ra_ii(l+r)$$
 
$$=-\sum_{i=l}^ra_i\cdot i^2+(r-l+1-lr)\sum_{i=l}^ra_i+(l+r)\sum_{i=l}^ra_ii$$

然后就好像可以用线段树维护了

维护 $a_i$ 的和，设为 sum1

维护 $i\cdot a_i$ 的和，设为 sum2

维护 $i^2\cdot a_i$ 的和，设为 sum3

上面的答案就是$-\text{sum}_3+(l+r)\cdot \text{sum}_2+(1-l+r-lr)\cdot \text{sum}_1$

但是有区间加法，怎么维护这些的和呢？

设某线段树节点控制的区域为 $L,R,$ 这个区间所有 $a$ 都$+=w$ 

有

$$\text{sum}_1+=(R-L+1)\cdot w$$

$$\text{sum}_2+=\sum_{i=L}^R[i\cdot (a_i+w)-i\cdot a_i\ ]$$

即

$$+=w\sum_{i=L}^Ri$$

每一个线段树节点额外记录一个$\sum_{i=L}^Ri$就可以了（这个可以在建树的时候预处理出来，我们设为 sum4)。

$$\text{sum}_3+=\sum_{i=L}^R[i^2\cdot (a_i+w)-i^2\cdot a_i\ ]$$

即
$$+=w\sum_{i=L}^Ri^2$$

每一个线段树节点再额外记录一个$\sum_{i=L}^Ri^2$就可以了（这个可以在建树的时候预处理出来，我们设为 sum5）。

于是这题就做完啦！

最后注意要约分啊！

很容易爆 long long 所以建议多开一些 long long。

```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline ll read(){
    ll x=0,f=1;char ch=getchar();
    while (!isdigit(ch)){if (ch=='-') f=-1;ch=getchar();};
    while (isdigit(ch)){x=(x<<1)+(x<<3)+ch-48;ch=getchar();};
    return x*f; 
}
int n,m;
struct node{
    ll sum1,sum2,sum3,sum4,sum5,lazy;//如上文所述
}g[1000001];
inline void pushup(int rt){
    g[rt].sum1=g[rt<<1].sum1+g[rt<<1|1].sum1;
    g[rt].sum2=g[rt<<1].sum2+g[rt<<1|1].sum2;
    g[rt].sum3=g[rt<<1].sum3+g[rt<<1|1].sum3;
}
void build(int rt,int lb,int rb){
    if (lb==rb){g[rt].sum4=1LL*lb;g[rt].sum5=1LL*lb*lb;return;}//预处理sum4，sum5
    int mid=lb+rb>>1;
    build(rt<<1,lb,mid);build(rt<<1|1,mid+1,rb);
    g[rt].sum4=g[rt<<1].sum4+g[rt<<1|1].sum4;
    g[rt].sum5=g[rt<<1].sum5+g[rt<<1|1].sum5;
}
inline void pushdown(int rt,int lb,int rb){
    if (g[rt].lazy){
        int mid=lb+rb>>1,ls=rt<<1,w=g[rt].lazy,rs=rt<<1|1;
        g[ls].lazy+=1LL*w;g[rs].lazy+=1LL*w;
        g[ls].sum1+=1LL*(mid-lb+1)*w;g[rs].sum1+=1LL*(rb-mid)*w;
        g[ls].sum2+=1LL*w*g[ls].sum4;g[rs].sum2+=1LL*w*g[rs].sum4;
        g[ls].sum3+=1LL*w*g[ls].sum5;g[rs].sum3+=1LL*w*g[rs].sum5;
        g[rt].lazy=0;
    }
}
void update(int rt,int lb,int rb,int l,int r,ll w){
    if (lb>r||rb<l) return;
    if (lb>=l&&rb<=r){
        g[rt].sum1+=1LL*(rb-lb+1)*w;g[rt].sum2+=1LL*w*g[rt].sum4;
        g[rt].sum3+=1LL*w*g[rt].sum5;g[rt].lazy+=1LL*w;return;
    }
    pushdown(rt,lb,rb);
    int mid=lb+rb>>1;
    update(rt<<1,lb,mid,l,r,w);update(rt<<1|1,mid+1,rb,l,r,w);
    pushup(rt);
}
void query(int rt,int lb,int rb,int l,int r,ll &sum1,ll &sum2,ll &sum3){//由于想减少代码量以及常数于是就尝试用void记录答案
    if (lb>r||rb<l) return;
    if (lb>=l&&rb<=r){sum1+=g[rt].sum1;sum2+=g[rt].sum2;sum3+=g[rt].sum3;return;}
    pushdown(rt,lb,rb);
    int mid=lb+rb>>1;
    query(rt<<1,lb,mid,l,r,sum1,sum2,sum3);query(rt<<1|1,mid+1,rb,l,r,sum1,sum2,sum3);
}
int main(){
    n=read(),m=read();
    build(1,1,n);
    while (m--){
        char s[12];ll l,r;scanf("%s",s);l=read(),r=read();
        if (s[0]=='C'){
            ll w=read();
            if (l==r) continue;
            update(1,1,n,l+1,r,w);
        }else{
            ll S1=0,S2=0,S3=0;
            query(1,1,n,l+1,r,S1,S2,S3);
            ll Up=-S3+(l+r+1)*S2+(r-(l+1)-(l+1)*r+1)*S1,Down=(r-l+1)*(r-l)/2;//Up是分子，Down是分母
            ll Gcd=__gcd(Up,Down);
            printf("%lld/%lld\n",Up/Gcd,Down/Gcd);//约分
        }
    }
}
```

---

## 作者：Kelin (赞：6)

## [题意](https://blog.csdn.net/BeNoble_/article/details/79817446)

给你一个序列$,$询问一个区间求从中任选一个子区间的权值和的期望$,$带修改

---

## 题解

设$sum(L,R)=\sum_{i=L}^Rw_i,$可以想到

$$E=\sum_{i=L}^R\sum_{j=i}^R\frac{sum(i,j)}{{R-L+1\choose2}}$$

即所有情况的和除以每种情况的概率

考虑怎么求$\sum_{i=L}^R\sum_{j=i}^Rsum(i,j)$

考虑到每一个$w_i$会存在于$(i-L+1)\times(R-i+1)$个区间中$($分别枚举左右端点$)$

可以得到

$$\sum_{i=L}^R\sum_{j=i}^Rsum(i,j)=\sum_{i=L}^Rw_i(i-L+1)\times(R-i+1)$$

化简得

$$(R+1)(1-L)\sum w_i+(L+R)\sum w_ii-\sum w_ii^2$$

其中那三样东西都可以用线段树维护

特殊的$\sum_{i=1}^ni^2=\frac{(2n+1)n(n+1)}6$

注意这题中的一些细节

把边权化为点权时如果直接$--R$的话那么分母应该是${R-L+2\choose2}$

```
#include<bits/stdc++.h>
#define fp(i,a,b) for(register int i=a,I=b+1;i<I;++i)
#define fd(i,a,b) for(register int i=a,I=b-1;i>I;--i)
#define go(u) for(register int i=fi[u],v=e[i].to;i;v=e[i=e[i].nx].to)
#define file(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
template<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}
template<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}
using namespace std;
char ss[1<<17],*A=ss,*B=ss;
inline char gc(){return A==B&&(B=(A=ss)+fread(ss,1,1<<17,stdin),A==B)?-1:*A++;}
template<class T>inline void sd(T&x){
    char c;T y=1;while(c=gc(),(c<48||57<c)&&c!=-1)if(c==45)y=-1;x=c-48;
    while(c=gc(),47<c&&c<58)x=x*10+c-48;x*=y;
}
char sr[1<<21],z[20];int C=-1,Z;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
template<class T>inline void we(T x){
    if(C>1<<20)Ot();if(x<0)sr[++C]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);sr[++C]='\n';
}
const int N=1e5+5;
typedef int arr[N];
typedef long long ll;
int n,m,tg[N<<2];ll tr[N<<2][3];
#define lc p<<1
#define rc p<<1|1
inline ll calc(int x){return (ll)(x<<1|1)*x*(x+1)/6;}
inline void Tag(int p,int L,int R,int w){
	int x=(R-L+1);tg[p]+=w;
	tr[p][0]+=(ll)w*x;
	tr[p][1]+=(ll)w*x*(L+R)>>1;
	tr[p][2]+=(calc(R)-calc(L-1))*w;
}
inline void down(int p,int L,int R){
	int mid=(L+R)>>1,w=tg[p];tg[p]=0;
	Tag(lc,L,mid,w),Tag(rc,mid+1,R,w);
}
inline void up(int p){fp(i,0,2)tr[p][i]=tr[lc][i]+tr[rc][i];}
void mdy(int p,int L,int R,int a,int b,int w){
	if(a<=L&&R<=b)return Tag(p,L,R,w);
	if(tg[p])down(p,L,R);int mid=(L+R)>>1;
	if(a<=mid)mdy(lc,L,mid,a,b,w);
	if(b>mid)mdy(rc,mid+1,R,a,b,w);up(p);
}
ll qry(int p,int L,int R,int a,int b,int y){
	if(a<=L&&R<=b)return tr[p][y];
	if(tg[p])down(p,L,R);int mid=(L+R)>>1;
	if(b<=mid)return qry(lc,L,mid,a,b,y);
	if(a>mid)return qry(rc,mid+1,R,a,b,y);
	return qry(lc,L,mid,a,b,y)+qry(rc,mid+1,R,a,b,y);
}
int main(){
    #ifndef ONLINE_JUDGE
        file("roadxw");
    #endif
    sd(n),sd(m);--n;
    int L,R;char c;ll x,y,g;
    while(m--){
    	while(c=gc(),c<32);sd(L),sd(R);--R;
    	if(c=='C')sd(x),mdy(1,1,n,L,R,x);
    	else{
    		y=(ll)(R-L+2)*(R-L+1)>>1;
    		x=qry(1,1,n,L,R,0)*(R+1)*(1-L)+qry(1,1,n,L,R,1)*(R+L)-qry(1,1,n,L,R,2);
    		g=__gcd(x,y);we(x/g),sr[C]='/',we(y/g);
    	}
    }
return Ot(),0;
}
```

---

## 作者：1saunoya (赞：5)

[$\texttt{myblog}$](https://www.cnblogs.com/Isaunoya/p/11859320.html)

设 
$A=\sum_{i=l}^{r}\sum_{j=i}^{r} dis_{i,j}$ , $B=  C_{r-l+1}^{2}$

期望值为 $\frac{A}{B}$

我们发现这是一条链所以用一种常用的套路：边权化点权

然后发现这个$dis_{i,j}$ 其实是 $sum_j - sum_i$ 的
($sum_x=\sum_{i=1}^{x}a_i$)

考虑 $[L , R]$ 区间出现 $a_i$ 的个数

我们可以发现其实是 

$$\sum_{i=l}^{r} a_i * (r - i + 1) * (i - l + 1)$$

$$= \sum_{i=l}^{r}a_i*((r *i-r*l+r)-(i^2-i*l+i)+i-l+1)$$

$$=-\sum_{i=l}^{r}a_i*i^2+
(r-l+1-l*r)\sum_{i=l}^{r}a_i
+(l+r)\sum_{i=l}^{r}a_i*i$$

设

$s1=\sum_{i=l}^{r}a_i$,

$s2=\sum_{i=l}^{r}i*a_i$,

$s3=\sum_{i=l}^{r}i^2*a_i$


那么 

$ans =(l + r) * s2 + ((r - l) - l * r + 1) * s1 - s3$

对于区间修改 懒标记以及修改方法

我们发现对 $s1_{rt}$ 的影响是 
$\sum_{i=l}^{r} val$

对 $s2_{rt}$ 的影响是 
$\sum_{i=l}^{r}i*val$

对 $s3_{rt}$ 的影响是 
$\sum_{i=l}^{r}i^2*val$


所以就维护一个静态的 $s4_{rt} = \sum_{i=l}^{r}i$
以及 $s5_{rt} = \sum_{i=l}^{r}i^2$


($\texttt{rt指的是某一段区间…学过线段树的都会(?)}$)


放上人傻常数大的代码


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std ;
inline void read(int & x) {
  register char c = x = 0 ; bool f = 0 ;
  while(! isdigit(c)) { if(c == '-') f = 1 ; c = getchar() ; }
  while(isdigit(c)) { x = (x << 1) + (x << 3) + (c & 15) ; c = getchar() ; }
  if(f) x = -x ;
}
int n , m ;
const int N = 1e5 + 10 ;
int s1[N << 2] , s2[N << 2] , s3[N << 2] , s4[N << 2] , s5[N << 2] , tag[N << 2] ;
inline void pushup(int rt) { s1[rt] = s1[rt << 1] + s1[rt << 1 | 1] ;
  s2[rt] = s2[rt << 1] + s2[rt << 1 | 1] ; s3[rt] = s3[rt << 1] + s3[rt << 1 | 1] ;
}
inline void build(int l , int r , int rt) {
  if(l == r) { s4[rt] = l ; s5[rt] = l * l ; return ; }
  int mid = l + r >> 1 ; build(l , mid , rt << 1) ; build(mid + 1 , r , rt << 1 | 1) ;
  s4[rt] = s4[rt << 1] + s4[rt << 1 | 1] ; s5[rt] = s5[rt << 1] + s5[rt << 1 | 1] ;
}
inline void pushdown(int rt , int l , int r) {
  if(! tag[rt]) return ; int mid = l + r >> 1 ;
  tag[rt << 1] += tag[rt] ; tag[rt << 1 | 1] += tag[rt] ;
  s1[rt << 1] += tag[rt] * (mid - l + 1) ; s1[rt << 1 | 1] += tag[rt] * (r - mid) ;
  s2[rt << 1] += s4[rt << 1] * tag[rt] ; s2[rt << 1 | 1] += s4[rt << 1 | 1] * tag[rt] ;
  s3[rt << 1] += s5[rt << 1] * tag[rt] ; s3[rt << 1 | 1] += s5[rt << 1 | 1] * tag[rt] ;
  tag[rt] = 0 ;
}
inline void upd(int a , int b , int l , int r , int rt , int val) {
  if(a <= l && r <= b) {
    s1[rt] += val * (r - l + 1) ; s2[rt] += val * s4[rt] ;
    s3[rt] += val * s5[rt] ; tag[rt] += val ;
    return ;
  } pushdown(rt , l , r) ;
  int mid = l + r >> 1 ;
  if(a <= mid) upd(a , b , l , mid , rt << 1 , val) ;
  if(b > mid) upd(a , b , mid + 1 , r , rt << 1 | 1 , val) ;
  pushup(rt) ;
}
inline void query(int a , int b , int l , int r , int rt , int & sum1 , int & sum2 , int & sum3) {
  if(a <= l && r <= b) { sum1 += s1[rt] ; sum2 += s2[rt] ; sum3 += s3[rt] ; return ; }
  pushdown(rt , l , r) ; int mid = l + r >> 1 ;
  if(a <= mid) query(a , b , l , mid , rt << 1 , sum1 , sum2 , sum3) ;
  if(b > mid) query(a , b , mid + 1 , r , rt << 1 | 1 , sum1 , sum2 , sum3) ;
}
signed main() {
#ifdef _WIN64
  freopen("0.in" , "r" , stdin) ;
#endif
  read(n) ; read(m) ;
  build(1 , n , 1) ;
  while(m --) {
    char c = getchar() ;
    while(isspace(c)) c = getchar() ;
    if(c == 'C') {
      int l , r , val ;
      read(l) ; read(r) ; read(val) ;
      upd(++ l , r , 1 , n , 1 , val) ;
    } else {
      int l , r ; read(l) ; read(r) ;
      int sum1 , sum2 , sum3 ; sum1 = sum2 = sum3 = 0 ;
      query(l + 1 , r , 1 , n , 1 , sum1 , sum2 , sum3) ;
      int ans = (l + r + 1) * sum2 + ((r - l - 1) - (l + 1) * r + 1) * sum1 - sum3 ;
      int down = (r - l + 1) * (r - l) >> 1 ;
      int gcd = __gcd(ans , down) ;
      cout << ans / gcd << '/' << down / gcd << '\n' ;
    }
  }
  return 0 ;
}
```

---

## 作者：Ginger_he (赞：5)

# 题解
定义收费站 $i$ 和 $i+1$ 之间的路为第 $i$ 条公路。考虑第 $i$ 条路的贡献，只需在 $i$ 的左边和 $i+1$ 的右边分别任选一点即可，所以
$$ans=\sum_{i=l}^ra_i(i-l+1)(r-i)$$
展开可得，
$$ans=\sum_{i=1}^ra_i(ir-i^2-lr+il+r-i)$$
整理可得，
$$ans=(r-lr)\sum_{i=l}^ra_i+(r+l-1)\sum_{i=l}^ria_i-\sum_{i=l}^ri^2a_i$$
观察以上式子，发现只需维护 $\sum\limits_{i=l}^ra_i,\sum\limits_{i=l}^r ia_i$ 和 $\sum\limits_{i=l}^r i^2a_i$。

---

对于区间加操作，

$$\sum_{i=l}^r(a_i+v)=v(r-l+1)+\sum_{i=l}^ra_i$$

$$\sum_{i=l}^ri(a_i+v)=v\sum_{i=l}^ri+\sum_{i=l}^r ia_i$$

上式只需应用等差数列求和公式。

$$\sum_{i=l}^ri^2(a_i+v)=v\sum_{i=l}^ri^2+\sum_{i=l}^ri^2a_i$$

上式只需应用平方和公式。

---

由于是期望，在算完答案后需要除以方案数，即分母为 $\mathrm{C}_{r-l+1}^2$。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define N 400005
ll n,m,u,v,w,ans,res,tmp;
ll a[N],b[N],c[N],p[N];
char op;
ll gcd(ll x,ll y)
{
	ll r;
	while(y)
	{
		r=x%y;
		x=y;
		y=r;
	}
	return x;
}
ll sum(ll x)
{
	return x*(x+1)*(2*x+1)/6;
}
inline void pushup(ll k)
{
	a[k]=a[k<<1]+a[k<<1|1];
	b[k]=b[k<<1]+b[k<<1|1];
	c[k]=c[k<<1]+c[k<<1|1];
}
inline void pushdown(ll l,ll r,ll k)
{
	ll mid=l+r>>1;
	if(p[k])
	{
		p[k<<1]+=p[k];
		p[k<<1|1]+=p[k];
		a[k<<1]+=(mid-l+1)*p[k];
		a[k<<1|1]+=(r-mid)*p[k];
		b[k<<1]+=(l+mid)*(mid-l+1)/2*p[k];
		b[k<<1|1]+=(mid+1+r)*(r-mid)/2*p[k];
		c[k<<1]+=((sum(mid)-sum(l-1)))*p[k];
		c[k<<1|1]+=((sum(r)-sum(mid)))*p[k];
		p[k]=0;
	}
}
void modify(ll x,ll y,ll z,ll l,ll r,ll k)
{
	if(x<=l&&r<=y)
	{
		a[k]+=(r-l+1)*z;
		b[k]+=(l+r)*(r-l+1)/2*z;
		c[k]+=(sum(r)-sum(l-1))*z;
		p[k]+=z;
		return;
	}
	pushdown(l,r,k);
	ll mid=l+r>>1;
	if(x<=mid) modify(x,y,z,l,mid,k<<1);
	if(y>mid) modify(x,y,z,mid+1,r,k<<1|1);
	pushup(k);
}
ll query_a(ll x,ll y,ll l,ll r,ll k)
{
	if(x<=l&&r<=y)
		return a[k];
	pushdown(l,r,k);
	ll mid=l+r>>1,res=0;
	if(x<=mid) res+=query_a(x,y,l,mid,k<<1);
	if(y>mid) res+=query_a(x,y,mid+1,r,k<<1|1);
	return res;
}
ll query_b(ll x,ll y,ll l,ll r,ll k)
{
	if(x<=l&&r<=y)
		return b[k];
	pushdown(l,r,k);
	ll mid=l+r>>1,res=0;
	if(x<=mid) res+=query_b(x,y,l,mid,k<<1);
	if(y>mid) res+=query_b(x,y,mid+1,r,k<<1|1);
	return res;
}
ll query_c(ll x,ll y,ll l,ll r,ll k)
{
	if(x<=l&&r<=y)
		return c[k];
	pushdown(l,r,k);
	ll mid=l+r>>1,res=0;
	if(x<=mid) res+=query_c(x,y,l,mid,k<<1);
	if(y>mid) res+=query_c(x,y,mid+1,r,k<<1|1);
	return res;
}
int main()
{
	scanf("%lld%lld",&n,&m);
	while(m--)
	{
		scanf("\n%c%lld%lld",&op,&u,&v);
		if(op=='C')
		{
			scanf("%lld",&w);
			modify(u,v-1,w,1,n-1,1);
		}
		else
		{
			ans=(v-u*v)*query_a(u,v-1,1,n-1,1)+(u+v-1)*query_b(u,v-1,1,n-1,1)-query_c(u,v-1,1,n-1,1);
			res=(v-u+1)*(v-u)/2;
			tmp=gcd(ans,res);
			printf("%lld/%lld\n",ans/tmp,res/tmp);
		}
	}
	return 0;
}
```

---

## 作者：E_huan (赞：4)

主要讲一下一些推导上可以简化的地方以及实现细节，并且讲一下为什么线段树需要维护的是这几个信息。

### 思路
区间修改 $+$ 区间查询期望，初步判断：线段树 $+$ 概率期望式子。

发现区间修改是区间加，使用线段树应该还是比较好维护的。“等概率随机取出两个不同的收费站 $a$ 和 $b$” 其实就是选择所有站对的和(我们强制只算从左到右）最后除以 $n$ $\times$ $(n-1)/2$。

### 维护
知道收费站个数就能求出“站对”的数量 $n$ $\times$ $(n-1)/2$，**所以维护“所有站对的和”** 即可。

##### 考虑合并两个子树的信息，有 $3$ 种情况：

$1.$ 只选左区间的站：左儿子“所有站对的和”。

$2.$ 右同理。

$3.$ 跨过左右区间：

发现**需要再多维护“强行选左/右端点的费用”才行**。
    
如何维护“强行选左/右端点的费用”：
    
$1.$ 强行选左的费用：
    
**发现还需要多维护区间和**（这个肯定好维护）。
        
强行选左的费用 $=$ 左儿子强行选左的费用 $+$（左儿子的权值和 $\times$ 右儿子的长度 $+$ 右儿子强行选左的费用）
        
        
$2.$ 右同理
        
知道了“强行选左/右端点的费用”，并且**知道左右两段的长度**，这一类情况对答案的贡献就是：`ls.rans*rs.len+ls.len*rs.lans` 
    
    
##### 懒标记下传
懒标记就一个区间加，下放的时候修改自己，可以写个 $add$ 函数简化代码（见后面放的代码吧）。

添加一个数对于区间和等信息的影响很好维护，难点在于对于 $ans$ 的影响(记 $delta$ 为答案的增量）。
计算每个站作为起点的贡献，可以写出对于有 $k$ 个站的一段所有站贡献次数总和：$ delta= \sum_{i=1}^{n} i \times (n-i+1) $ ，这是个 $O(n)$ 的式子，肯定不能在 $pushdown$ 里面求，很多题解都采用了推式子化简，其实还可以直接**无脑预处理**。（ $cnt[i]$ 表示长度为 $i$ 的一段所有站贡献次数总和）。
```cpp
ll now=0;
for(int i=1;i<=n;i++)
{
	now+=1ll*i*(i-1);
	cnt[i]=(1ll*i*i*(i+1)/2)-now;
}
```


### 完整 AC 代码：
``` cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=100010;
int n,m;
ll cnt[N];
ll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}
struct node
{
	ll sum,ans,lans,rans;
	int tag,len;
}tr[N<<2];
void build(int u,int l,int r)
{
	tr[u].len=(r-l+1);
	if(l==r) return;
	int mid=(l+r)>>1;
	build(u<<1,l,mid); build(u<<1|1,mid+1,r);
}
inline void add(int u,int v)
{
	tr[u].sum+=1ll*tr[u].len*v;
	tr[u].tag+=v;
	tr[u].lans+=1ll*(tr[u].len+1)*tr[u].len/2*v;
	tr[u].rans+=1ll*(tr[u].len+1)*tr[u].len/2*v;
	tr[u].ans+=cnt[tr[u].len]*v;
}
inline void pushdown(int u)
{
	if(!tr[u].tag) return;
	add(u<<1,tr[u].tag); add(u<<1|1,tr[u].tag);
	tr[u].tag=0;
}
inline void pushup(node &u,node ls,node rs)//sum,ans,lans,rans;
{
	u.len=ls.len+rs.len;//因为query()也会用到这个，所以必须每次更新len
	u.sum=ls.sum+rs.sum;
	u.ans=(ls.ans+rs.ans+ls.rans*rs.len+ls.len*rs.lans);
	u.lans=ls.lans+(ls.sum*rs.len+rs.lans);
	u.rans=rs.rans+(rs.sum*ls.len+ls.rans);
}
void modify(int u,int l,int r,int ml,int mr,int v)
{
	if(ml<=l&&r<=mr) {add(u,v); return;}
	pushdown(u);
	int mid=(l+r)>>1;
	if(ml<=mid) modify(u<<1,l,mid,ml,mr,v);
	if(mr>mid) modify(u<<1|1,mid+1,r,ml,mr,v);
	pushup(tr[u],tr[u<<1],tr[u<<1|1]);
}
node query(int u,int l,int r,int ql,int qr)
{
	if(ql<=l&&r<=qr) return tr[u];
	pushdown(u);
	int mid=(l+r)>>1;
	if(ql<=mid&&qr>mid) 
	{
		node res={0,0,0,0,0,min(r,ql)-max(l,ql)+1};
		pushup(res,query(u<<1,l,mid,ql,qr),query(u<<1|1,mid+1,r,ql,qr));
		return res;
	}
	if(ql<=mid) return query(u<<1,l,mid,ql,qr);
	else return query(u<<1|1,mid+1,r,ql,qr);
}
int main()
{
	scanf("%d%d",&n,&m);
	build(1,1,n);
	ll now=0;
	for(int i=1;i<=n;i++)
	{
		now+=1ll*i*(i-1);
		cnt[i]=(1ll*i*i*(i+1)/2)-now;
	}
	char ch[5]; int l,r,v;
	while(m--)
	{
		scanf("%s%d%d",ch,&l,&r);
		if(ch[0]=='C') scanf("%d",&v),modify(1,1,n,l,r-1,v);
		else 
		{
			ll son=query(1,1,n,l,r-1).ans,mom=1ll*(r-l+1)*(r-l)/2;
			ll d=gcd(son,mom);
			printf("%lld/%lld\n",son/d,mom/d);
		}
	}
	return 0;
}
```



---

## 作者：xuxinyu (赞：4)

期望值= Σ 可能情况\*出现概率

因为所有概率相等，所以本题可以转化为求 子集和/子集个数

根据组合数，子集个数=C（r-l+1,2）= （r-l+1）\*（r-l）/2

子集和呢

推公式

子集和=Σ (i-l+1)\*(r-i+1)\*cost[i]

其中，(i-l+1)\*(r-i+1) 是每个数用到的次数

拆开，= (l+r)\* Σ i\*cost[i] + (r-l+1-l\*r) \* Σ cost[i] - Σ i\*i\*cost[i]

线段树维护  Σcost[i] ，Σ i\*cost[i]，Σ i\*i\*cost[i]

更新，以+w为例：

Σcost[i] 加了size 个w，所以 Σcost[i] +=size\*w

Σ i\*cost[i] 加了 szie 个Σ i，所以 Σ i\*cost[i] += size\*Σ i

Σ i\*i\*cost[i] 加了 size个 Σ i\*i，所以Σ i\*i\*cost[i] += size \*Σ i\*i

所以线段树需要另外维护 Σi，Σi\*i


代码请转至 http://www.cnblogs.com/TheRoadToTheGold/p/7306066.html


---

## 作者：p878567 (赞：2)

这题还能用树状数组做！

我们可以求出$ans=\frac{\sum_{i=l}^{r-1}(-i^2\cdot dis_i+(l+r-1)\cdot i\cdot dis_i-r(l-1)\cdot dis_i)}{\binom{r-l+1}{2}}$，然后就是要搞出$-i^2\cdot dis_i,i\cdot dis_i,dis_i$的区间和~~（其实还是很套路的）~~

树状数组当然不能直接区间加，所以我们考虑原数组的差分数组$\Delta dis_i$。然后呢？貌似只能做出单点的值。但这是一个树状数组（也就是建很多个树状数组了）。

还是考虑这三个式子的前缀和：

$\sum\limits_{i=1}^ndis_i=\sum\limits_{i=1}^n\sum\limits_{j=1}^i \Delta dis_i$

$\sum\limits_{i=1}^ni\cdot dis_i=\sum\limits_{i=1}^n( i\sum\limits_{j=1}^i\Delta dis_i)$

$\sum\limits_{i=1}^ni^2\cdot dis_i=\sum\limits_{i=1}^n( i^2\sum\limits_{j=1}^i\Delta dis_i)$

竟然有两重求和？要$O(n^2)$？

其实我们考虑1~n中每个数对答案的贡献，于是我们发现：

$\sum\limits_{i=1}^ndis_i=\sum\limits_{i=1}^n\sum\limits_{j=1}^i \Delta dis_i=\sum\limits_{i=1}^n(n+1-i)\Delta dis_i=-\sum\limits_{i=1}^ni\Delta dis_i+(n+1)\sum\limits_{i=1}^n\Delta dis_i$

$\sum\limits_{i=1}^ni\cdot dis_i=\sum\limits_{i=1}^n( i\sum\limits_{j=1}^i\Delta dis_i)=(1+2+\cdots+n)\Delta dis_1+(2+3+\cdots+n)\Delta dis_2+\cdots+n\Delta dis_n=\sum\limits_{i=1}^n(S_n-S_{i-1})\Delta dis_i$

$\sum\limits_{i=1}^ni^2\cdot dis_i=\sum\limits_{i=1}^n( i^2\sum\limits_{j=1}^i\Delta dis_i)=(1^2+2^2+\cdots+n^2)\Delta dis_1+(2^2+3^2+\cdots+n^2)\Delta dis_2+\cdots+n^2\Delta dis_n=\sum\limits_{i=1}^n(\square_n-\square_{i-1})\Delta dis_i$

$\text{这里我们记}S_n=1+2+\cdots+n=\frac{n(n+1)}{2},\square_n=1^2+2^2+\cdots+n^2=\frac{n(n+1)(2n+1)}{6}$

然后拆开下面两个式子：

$\sum\limits_{i=1}^ni\cdot dis_i=\sum\limits_{i=1}^n(S_n-S_{i-1})\Delta dis_i=\sum\limits_{i=1}^n(\frac{n(n+1)}{2}-\frac{i(i-1)}{2})\Delta dis_i=-\frac{1}{2}\sum\limits_{i=1}^ni^2\cdot\Delta dis_i+\frac{1}{2}\sum\limits_{i=1}^ni\cdot\Delta dis_i+(\frac{1}{2}n^2+\frac{1}{2}n)\sum\limits_{i=1}^n\Delta dis_i$

$\sum\limits_{i=1}^ni^2\cdot dis_i=\sum\limits_{i=1}^n(\square_n-\square_{i-1})\Delta dis_i=\sum\limits_{i=1}^n(\frac{n(n+1)(2n+1)}{6}-\frac{i(i-1)(2i-1)}{6})\Delta dis_i=-\frac{1}{3}\sum\limits_{i=1}^ni^3\cdot\Delta dis_i+\frac{1}{2}\sum\limits_{i=1}^ni^2\cdot\Delta dis_i-\frac{1}{6}\sum\limits_{i=1}^ni\cdot\Delta dis_i+(\frac{1}{3}n^3+\frac{1}{2}n^2+\frac{1}{6}n)\sum\limits_{i=1}^n\Delta dis_i$

上面这三个式子（别忘了还有$\sum_{i=1}^ndis_i$）化简后，和$i$有关的式子就只有 $\sum_{i=1}^n\Delta dis_i$，$\sum_{i=1}^ni\cdot\Delta dis_i$，$\sum_{i=1}^ni^2\cdot\Delta dis_i$，$\sum_{i=1}^ni^3\cdot\Delta dis_i$这四个，而且都是前缀和的形式。这样的话，我们就可以建4个树状数组，分别维护这四个信息，算出前缀和，转化为区间和，再从中计算出$ans$。

写代码：我们发现中间过程炸了long long（差分可以是负数，ull也不行），于是不得不用了__int128（还好只卡了一个点）（这东西只能在Linux下用，所以还是在IDE上调试吧）
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
void output(__int128 x)        //__int128不能直接用cin,cout
{
	if (x >= 10) output(x / 10);
	putchar(x%10+'0');
}
__int128 c1[100001], c2[100001], c3[100001], c4[100001];
void add(__int128 x, __int128 num) {
	__int128 x0 = x;
	for (; x <= n; x += x & -x) {
		c1[x] += num;
		c2[x] += x0 * num;
		c3[x] += x0 * x0 * num;
		c4[x] += x0 * x0 * x0 * num;
	}
}
__int128 query1(__int128 x) {
	__int128 ans = 0;
	for (; x; x -= x & -x) ans += c1[x];
	return ans;
}
__int128 query2(__int128 x) {
	__int128 ans = 0;
	for (; x; x -= x & -x) ans += c2[x];
	return ans;
}
__int128 query3(__int128 x) {
	__int128 ans = 0;
	for (; x; x -= x & -x) ans += c3[x];
	return ans;
}
__int128 query4(__int128 x) {
	__int128 ans = 0;
	for (; x; x -= x & -x) ans += c4[x];
	return ans;
}
__int128 ask1(__int128 x) {return (x+1)*query1(x)-query2(x);}
__int128 ask2(__int128 x) {return x*(x+1)/2*query1(x)-(query3(x)-query2(x))/2;}
__int128 ask3(__int128 x) {return x*(x+1)*(2*x+1)/6*query1(x)-(2*query4(x)+query2(x)-3*query3(x))/6;}
__int128 gcd(__int128 a, __int128 b) {
	if (a < b) swap(a, b);
	if (a % b == 0) return b;
	return gcd(b, a % b);
}
void output(__int128 a, __int128 b) {
	if (a == 0) cout << "0/1" << endl;  //谨防a为0
	else output(a/gcd(a,b)),putchar('/'),output(b/gcd(a,b)),putchar('\n');
}
int main() {
	int m;
	cin >> n >> m;
	for (int i = 1; i <= m; i++) {
		char c = getchar();
		while (!isalpha(c)) c = getchar();
		if (c == 'C') {
			__int128 l, r, v;
			cin >> l >> r >> v;
			add(l, v);
			add(r, -v);
		}
		if (c == 'Q') {
			__int128 l, r;
			cin >> l >> r;
			output((l+r-1)*(ask2(r-1)-ask2(l-1))-(ask3(r-1)-ask3(l-1))-r*(l-1)*(ask1(r-1)-ask1(l-1)),(r-l+1)*(r-l)/2);
		}
	}
}
```

---

## 作者：xyz32768 (赞：2)

非常恶心的一道线段树题。为了方便计算，这里每一次修改和询问，先把r的值减1。

首先，了解期望值的概念，期望值=值1\*值1出现的概率+值2\*值2出现的概率+...+值k\*值k出现的概率（保证值1~k出现的概率和为1）。

那么对于这道题里的询问操作，由于询问操作里某个a和b出现的概率是相等的，所以 询问结果=所有可能收费的总和/C(r-l+2, 2)。

而重点就是求所有可能收费的总和。这里设a[i]为从第i到第i+1个收费站的费用。

那么所有可能收费的总和=(a[l]+(a[l]+a[l+1])+(a[l]+a[l+1]+a[l+2])+...+(a[l]+a[l+1]+...+a[r]))+(a[l+1]+(a[l+1]+a[l+2])+(a[l+1]+a[l+2]+a[l+3])+...+(a[l+1]+a[l+2]+...+a[r]))+...+(a[r-1]+(a[r-1]+a[r]))+a[r]=(r-l+1)\*1\*a[l]+(r-l)\*2\*a[l+1]+(r-l-1)\*3\*a[l+2]+...+1\*(r-l+1)\*a[r]。

而这里就需要维护(r-l+1)\*1\*a[l]+(r-l)\*2\*a[l+1]+(r-l-1)\*3\*a[l+2]+...+1\*(r-l+1)\*a[r]的值。这里的难点在于合并左右子区间的答案。为了能够合并左右子区间的答案，我们另外维护三个值：

1、sum0，维护a[l]+a[l+1]+a[l+2]+...+a[r]的值。

2、sum1，维护1\*a[l]+2\*a[l+1]+3\*a[l+2]+...+(r-l+1)\*a[r]的值。

3、sum2，维护(r-l+1)\*a[l]+(r-l)\*a[l+1]+(r-l-1)\*a[l+2]+...+2\*a[r-1]+1\*a[r]的值。

到了这里，合并(r-l+1)\*1\*a[l]+(r-l)\*2\*a[l+1]+(r-l-1)\*3\*a[l+2]+...+1\*(r-l+1)\*a[r]的值的左右子区间答案就变得简单了。实现见代码。

注意long long和最简分数。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define p2 p << 1
#define p3 p << 1 | 1
using namespace std;
typedef long long ll;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
inline char get() {
    char c; while ((c = getchar()) != 'C' && c != 'Q');
    return c;
}
const int N = 4e5 + 5;
int n, m; ll sm0[N], S[N], S1[N], S2[N], T[N], add[N];
void down(int p) {
    add[p2] += add[p]; add[p3] += add[p];
    add[p] = 0;
}
ll sum1(int x) {
    if (x == 0) return 1ll;
    return (x & 1) ? 1ll * (x + 1 >> 1) * x
        : 1ll * (x >> 1) * (x + 1);
}
ll sum2(int x, int y) {
    return sm0[x] + sum1(x) * (y - x);
}
void calc(int l, int r, int p) {
    int mid = l + r >> 1;
    ll v1, v2, v3, v4, v5, v6, v7, v8, c1, c2, c3;
    c1 = sum1(mid - l + 1); c2 = sum1(r - mid);
    c3 = sum1(r - l + 1);
    v1 = S[p2] + add[p2] * (mid - l + 1);
    v2 = S[p3] + add[p3] * (r - mid);
    v3 = S1[p2] + add[p2] * c1; 
    v4 = S1[p3] + add[p3] * (c3 - c1) + S[p3] * (mid - l + 1);
    v5 = S2[p2] + add[p2] * (c3 - c2) + S[p2] * (r - mid);
    v6 = S2[p3] + add[p3] * c2;
    v7 = T[p2] + add[p2] * sum2(mid - l + 1, r - l + 1)
        + S1[p2] * (r - mid);
    v8 = T[p3] + add[p3] * sum2(r - mid, r - l + 1)
        + S2[p3] * (mid - l + 1);
    S[p] = v1 + v2; S1[p] = v3 + v4;
    S2[p] = v5 + v6; T[p] = v7 + v8;
}
void change(int l, int r, int s, int e, int v, int p) {
    if (l == s && r == e) return (void) (add[p] += v);
    int mid = l + r >> 1; down(p);
    if (e <= mid) change(l, mid, s, e, v, p2);
    else if (s >= mid + 1) change(mid + 1, r, s, e, v, p3);
    else change(l, mid, s, mid, v, p2),
        change(mid + 1, r, mid + 1, e, v, p3);
    calc(l, r, p);
}
ll ask(int l, int r, int s, int e, ll s1, ll s2,
ll s3, ll s4, int p) {
    if (l == s && r == e) return (S[p] + add[p] * (r - l + 1))
    * s1 + (S1[p] + add[p] * sum1(r - l + 1)) * s2 +
    (S2[p] + add[p] * sum1(r - l + 1)) * s3 + (T[p]
    + add[p] * sum2(r - l + 1, r - l + 1)) * s4;
    int mid = l + r >> 1; down(p); ll res = 0;
    if (e <= mid) res = ask(l, mid, s, e, s1, s2, s3, s4, p2);
    else if (s >= mid + 1)
        res = ask(mid + 1, r, s, e, s1, s2, s3, s4, p3);
    else res = ask(l, mid, s, mid, s1 + s3 * (e - mid),
    s2 + s4 * (e - mid), s3, s4, p2) + ask(mid + 1, r,
    mid + 1, e, s1 + s2 * (mid - s + 1), s2, s3
    + s4 * (mid - s + 1), s4, p3);
    calc(l, r, p); return res;
}
ll gcd(ll x, ll y) {
    ll r = x % y;
    while (r) x = y, y = r, r = x % y;
    return y;
}
int main() {
    int i, x, y, z; char op;
    for (i = 1; i <= 4e4; i++) sm0[i] = sm0[i - 1] + i;
    for (i = 1; i <= 4e4; i++) sm0[i] += sm0[i - 1];
    n = read() - 1; m = read();
    while (m--) {
        op = get();
        if (op == 'C') {
            x = read(); y = read(); z = read();
            change(1, n, x, y - 1, z, 1);
        }
        else {
            x = read(); y = read();
            ll res = ask(1, n, x, y - 1, 0, 0, 0, 1, 1),
            u = sum1(y - x), v = gcd(res, u);
            printf("%lld/%lld\n", res / v, u / v);
        }
    }
    return 0;
}
```

---

## 作者：cjlak1o1 (赞：1)

这是一道非常适合像蒟蒻一样想提升线段树水平的题目。

[博客食用更佳哦](https://www.cnblogs.com/windseekerblog/p/16543537.html)

[题目链接](https://www.luogu.com.cn/problem/P2221)

### 题目大意

首先，我们要搞清楚让我们求什么，期望非常高大上，但是在这里其实就是求 $l$ 到 $r$ 任意选取两个点的所有方案的代价相加后除以总方案数，取一个平均值。

### 推理式子

接下来，我们细致考虑到每一条边。

例如对于图中的 $i\rightarrow i+1$ 这条边:

![](https://cdn.luogu.com.cn/upload/image_hosting/q2z7jgaq.png)

经过思考以后，我们发现在 $l$ 到 $r$ 这段区间中，它会参与代价的情况是两个收费站一个在 $i$ 以及 $i$ 的左边，同理，另一个在 $i+1$ 以及 $i+1$  的右边。

所以它的贡献就是 $(i-l+1)\times (r-i)\times dis[i][i+1]$ 。

我们在把每一条边的贡献加起来，并以 $i$ 的降幂排序有关将式子转化为我们要的式子。

(由于 $i$ 是我们取的边的左端点，所以 $i$ 从 $l$ 遍历到 $r-1$)

$$\sum\limits_{i=l}^{r-1}(i-l+1)\times (r-i)\times dis[i][i+1]$$
$$\Longrightarrow \sum\limits_{i=l}^{r-1}(-i^2+ri+li-i-lr+r)\times dis[i][i+1]$$
$$\Longrightarrow -\sum\limits_{i=1}^{r-1}i^2\times dis[i][i+1]+(r+l-1)\sum\limits_{i=1}^{r-1} i\times dis[i][i+1]+r(1-l)\sum\limits_{i=1}^{r-1}dis[i][i+1]$$

### 线段树维护 

我们现在已经得到了式子，又因为这道题是区间修改，区间查询，所以我们会联想到线段树。

- 区间修改

我们设 $sum1,sum2,sum3$。 

$sum1=\sum\limits_{i=l}^{r-1}i^2\times dis[i][i+1]$  
$sum2=\sum\limits_{i=l}^{r-1}i\times dis[i][i+1]$   
$sum3=\sum\limits_{i=l}^{r-1}dis[i][i+1]$

$sum3$ 的改变只需要加上长度乘以 $v$。

$sum2$ 的改变利用等差数列求和乘以 $v$。

$sum1$ 的改变利用平方和公式求和乘以 $v$。

具体见代码。

- 区间查询

把对应区间的 $sum1,sum2,sum3$ 求出，然后套式子求出代价和，求其与方案数的 $\gcd$ 输出答案。

### code

```cpp
#include<bits/stdc++.h>
#define int long long
#define ls rt<<1
#define rs rt<<1|1
#define lson ls,l,mid
#define rson rs,mid+1,r
using namespace std;
const int N=1e5+1e3;

int read(){
	int res=0,f=1;char c;
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) res=(res<<1)+(res<<3)+(c^48);
	return res*f;
}

int n,m;
struct TREE{
	int sum1,sum2,sum3;
	int lazy;
}t[N<<2];
char op;

int count1(int l,int r){return (l+r)*(r-l+1)/2;}//等差数列求和
int count2(int l,int r){return (r)*(r+1)*(2*r+1)/6-(l-1)*(l-1+1)*(2*(l-1)+1)/6;}//平方和求和

void push_down(int rt,int l,int r){
	if(t[rt].lazy!=0){
		int mid=(l+r)>>1,v=t[rt].lazy;
		t[ls].lazy+=t[rt].lazy,t[rs].lazy+=t[rt].lazy;
		t[ls].sum1+=(mid-l+1)*v;t[rs].sum1+=(r-mid)*v;
		t[ls].sum2+=count1(l,mid)*v;t[rs].sum2+=count1(mid+1,r)*v;
		t[ls].sum3+=count2(l,mid)*v;t[rs].sum3+=count2(mid+1,r)*v;
		t[rt].lazy=0;
	}
}

void push_up(int rt){
	t[rt].sum1=t[ls].sum1+t[rs].sum1;
	t[rt].sum2=t[ls].sum2+t[rs].sum2;
	t[rt].sum3=t[ls].sum3+t[rs].sum3;
}

void update(int rt,int l,int r,int ul,int ur,int v){
	if(ul<=l&&r<=ur){
		t[rt].sum1+=(r-l+1)*v;
		t[rt].sum2+=count1(l,r)*v;
		t[rt].sum3+=count2(l,r)*v;
		t[rt].lazy+=v;
		return;
	}
	push_down(rt,l,r);
	int mid=(l+r)>>1;
	if(ul<=mid) update(lson,ul,ur,v);
	if(mid<ur) update(rson,ul,ur,v);
	push_up(rt);
}

void query(int rt,int l,int r,int ql,int qr,int &sum1,int &sum2,int &sum3){
	if(ql<=l&&r<=qr){
		sum1+=t[rt].sum1,sum2+=t[rt].sum2,sum3+=t[rt].sum3;
		return;
	}
	push_down(rt,l,r);
	int mid=(l+r)>>1,res=0;
	if(ql<=mid) query(lson,ql,qr,sum1,sum2,sum3);
	if(mid<qr) query(rson,ql,qr,sum1,sum2,sum3);
	return;
}

signed main(){
	n=read(),m=read();
	//build(1,1,n);蒟蒻不太想build
	for(int i=1;i<=m;i++){
		cin>>op;
		if(op=='C'){
			int ul=read(),ur=read(),v=read();
			update(1,1,n,ul,ur-1,v);
		}
		else{
			int ql=read(),qr=read(),sum1=0,sum2=0,sum3=0;
			query(1,1,n,ql,qr-1,sum1,sum2,sum3);
			int sum=(qr-ql+1)*(qr-ql)/2,val=-sum3+(qr+ql-1)*sum2-qr*(ql-1)*sum1;
			int gcd=__gcd(val,sum);
			printf("%lld/%lld\n",val/gcd,sum/gcd);
		}
	}
	return 0;
}
/*
4 5
C 1 4 2
C 1 2 -1
Q 1 2
Q 2 4
Q 1 4
*/
```



---

## 作者：TheShadow (赞：1)

# 闲扯

~~define ll真好用~~

一道比较基础的线段树题，只是前期推式子要注意。

# 题面

[P2221 [HAOI2012]高速公路](https://www.luogu.org/problem/P2221)

# Solution

我们可以先将每条连接 $u,v(u<v)$ 公路都对应到 $u$ 上。

因为是等概率选择，所以我们只需要求出所有情况下费用的和，再除以情况数即可。

考虑怎么计算费用。

这里有两种想法：

1. 统计每一条被计算了几次。
2. 直接计算所有的情况。

根据本人的测试，第一种要好写的多。第二种是维护前缀和，但是有区间加的操作，貌似不好维护~~或者根本没法维护~~。

推式子。

因为对于每一条公路，我们都将它对应到了编号较小的点上，所以我们实际需要统计的只有 $l\sim r-1$ 这一段的答案。
$$
ans=\sum_{i=l}^{r-1}(i-l+1)\cdot(r-i)\cdot w_i\\
=(r-r\cdot l+r\cdot i+l\cdot i-i-i^2)\cdot w_i\\
=(r-r\cdot l)\cdot w_i+(r+l-1)\cdot i\cdot w_i-i^2\cdot w_i
$$
![](https://cdn.luogu.com.cn/upload/image_hosting/zdc4a32p.png)

所以我们只需要维护 $\sum w_i,\sum w_i\cdot i,\sum w_i\cdot i^2$ 这三个变量即可。

对于第一个，我们直接维护就好。

对于第二个，我们可以得出增加量为 $\frac{r\cdot(r+1)}{2}\cdot v-\frac{l\cdot(l-1)}{2}\cdot v$ 。

对于第三个，我们可以得出增加量为 $\frac{r\cdot(r+1)\cdot(2\cdot r+1)}{6}\cdot v-\frac{(l-1)\cdot l\cdot(2\cdot l-1)}{6}\cdot v$ 。

然后上线段树就行。

# Code

```c++
#include<bits/stdc++.h>
#define del(a,i) memset(a,i,sizeof(a))
#define ll long long
#define inl inline
#define il inl void
#define it inl int
#define ill inl ll
#define re register
#define ri re int
#define rl re ll
#define mid ((l+r)>>1)
#define lowbit(x) (x&(-x))
#define INF 0x3f3f3f3f
using namespace std;
template<class T>il read(T &x){
	int f=1;char k=getchar();x=0;
	for(;k>'9'||k<'0';k=getchar()) if(k=='-') f=-1;
	for(;k>='0'&&k<='9';k=getchar()) x=(x<<3)+(x<<1)+k-'0';
	x*=f;
}
template<class T>il _print(T x){
	if(x/10) _print(x/10);
	putchar(x%10+'0');
}
template<class T>il print(T x){
	if(x<0) putchar('-'),x=-x;
	_print(x);
}
ll mul(ll a,ll b,ll mod){long double c=1.;return (a*b-(ll)(c*a*b/mod)*mod)%mod;}
it qpow(int x,int m,int mod){
	int res=1,bas=x%mod;
	while(m){
		if(m&1) res=(1ll*res*bas)%mod;
		bas=(1ll*bas*bas)%mod,m>>=1;
	}
	return res%mod;
}
const int MAXN = 1e5+5;
int n,m,x,y,k;
char opt[2];
#define lc (cur<<1)
#define rc (cur<<1|1)
struct Seg_Tree{
	ll sum[3],tag;
}T[MAXN<<2];
il pushup(int cur){
	T[cur].sum[0]=T[lc].sum[0]+T[rc].sum[0];
	T[cur].sum[1]=T[lc].sum[1]+T[rc].sum[1];
	T[cur].sum[2]=T[lc].sum[2]+T[rc].sum[2];
}
il change(int cur,int l,int r,int k){
	T[cur].tag+=k;
	T[cur].sum[0]+=1ll*(r-l+1)*k;
	T[cur].sum[1]+=1ll*(1ll*r*(r+1)/2-1ll*l*(l-1)/2)*k;
	T[cur].sum[2]+=1ll*(1ll*r*(r+1)*(2*r+1)/6-1ll*l*(l-1)*(2*l-1)/6)*k;
}
il pushdown(int cur,int l,int r){
	if(!T[cur].tag) return ;
	change(lc,l,mid,T[cur].tag);
	change(rc,mid+1,r,T[cur].tag);
	T[cur].tag=0;
}
il updata(int cur,int l,int r,int L,int R,int k){
	if(l>=L&&r<=R) return change(cur,l,r,k),void();
	pushdown(cur,l,r);
	if(mid>=L) updata(lc,l,mid,L,R,k);
	if(R>mid) updata(rc,mid+1,r,L,R,k);
	pushup(cur);
}
ill query(int cur,int l,int r,int L,int R,int ty){
	if(l>=L&&r<=R) return T[cur].sum[ty];
	pushdown(cur,l,r);rl res=0;
	if(mid>=L) res+=query(lc,l,mid,L,R,ty);
	if(R>mid) res+=query(rc,mid+1,r,L,R,ty);
	return res;
}
ill gcd(ll x,ll y){return y==0?x:gcd(y,x%y);}
il Query(int l,int r){
	rl res=0,sum;
	res+=(r-1ll*r*l)*query(1,1,n-1,x,y-1,0);
	res+=(r+l-1)*query(1,1,n-1,x,y-1,1);
	res-=query(1,1,n-1,x,y-1,2);
	ri len=r-l+1;
	sum=1ll*(len-1)*len/2;
	rl d=gcd(sum,res);
	print(res/d),putchar('/'),print(sum/d),puts("");
}
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	read(n),read(m);
	for(ri i=1;i<=m;++i){
		scanf("%s",opt),read(x),read(y);
		if(opt[0]=='C') read(k),updata(1,1,n-1,x,y-1,k);
		if(opt[0]=='Q') Query(x,y);
	}
	return 0;
}
```

# 总结

在做乘法的时候一定要注意会不会爆 $int$ 。

---

## 作者：y2823774827y (赞：1)

[更好的阅读体验](https://www.cnblogs.com/y2823774827y/p/10193345.html)

$n-1$条边，查询点$(l,r)l<r$相当于边$(l,r-1)$
，$dis_{i,j}$表示边$i$~$j$权之和

每次查询边$(l,r)$

$ans=\dfrac{\sum\limits_{i=l}^r\sum\limits_{j=i}^rdis_{i,j}}{C_{r-l+1}^2}=\dfrac{\sum\limits_{i=l}^ra_{i}(r-i+1)(i-l+1)}{((r+1)-l)((r+1)-l+1)}$

我们来看上面这部分，拆开后

$\sum\limits_{i=l}^ra_{i}(ri-rl+r-i^2+il-i+i-l+1)$

$\sum\limits_{i=l}^ra_{i}(ri-rl+r-i^2+il-l+1)$

$\sum\limits_{i=l}^ra_{i}(-i^2+ri+il-rl+r-l+1)$

$\sum\limits_{i=l}^ra_{i}((-i^2)+i(l+r)+(r+1-rl-l)$

$\sum\limits_{i=l}^ra_{i}(r+1-rl-l)+\sum\limits_{i=l}^ra_{i}(i(l+r))+\sum\limits_{i=l}^ra_{i}((-i^2)$


线段树维护$\sum\limits_{i=l}^ra_{i},\sum\limits_{i=l}^ra_{i}*i,\sum\limits_{i=l}^ra_{i}*i*i$三个值就行了


现在考虑区间修改时怎么拆开上面的式子，假设$(l,r)$加上$val$

$sum1+=val(r-l+1)$

$sum2+=val[(l+r)(r-l+1)/2]$

维护$sum3$要用到一个常用公式了，不会自行百度$\sum\limits_{i=1}^ni^2=\dfrac {n(n+1)(2n+1)}{6}$

$sum3+=val\dfrac {r(r+1)(2r+1)-(l-1)[(l-1)+1][2(l-1)+1]}{6}$

其他的就是类似模板的东西了

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<string>
#include<algorithm>
using namespace std;
typedef long long LL;
const LL maxn=1e7+1;
inline LL Read(){
    LL x=0,f=1; char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-') f=-1; c=getchar();
    }
    while(c>='0'&&c<='9')
        x=(x<<3)+(x<<1)+c-'0',c=getchar();
    return x*f;
}
struct node{
    LL lazy;
    LL sum1,sum2,sum3;
    LL son[2];
}tree[maxn];
LL n,m,nod,root;
inline void Update(LL now){
    LL son0=tree[now].son[0]; LL son1=tree[now].son[1];
    tree[now].sum1=tree[son0].sum1+tree[son1].sum1,
    tree[now].sum2=tree[son0].sum2+tree[son1].sum2,
    tree[now].sum3=tree[son0].sum3+tree[son1].sum3;
}
inline void Pushdown(LL now,LL l,LL r){
    if(!tree[now].lazy)
        return;
    LL val=tree[now].lazy;
    if(!tree[now].son[0]) tree[now].son[0]=++nod; LL son0=tree[now].son[0]; 
    if(!tree[now].son[1]) tree[now].son[1]=++nod; LL son1=tree[now].son[1]; 
    LL mid=(l+r)>>1; LL l1=l,r1=mid,l2=mid+1,r2=r;
    tree[son0].lazy+=val,
    tree[son0].sum1+=(r1-l1+1)*val,
    tree[son0].sum2+=(l1+r1)*(r1-l1+1)/2*val,
    tree[son0].sum3+=((r1*(r1+1)*(2*r1+1)-(l1-1)*((l1-1)+1)*(2*(l1-1)+1))/6)*val,
    tree[son1].lazy+=val,
    tree[son1].sum1+=(r2-l2+1)*val,
    tree[son1].sum2+=(l2+r2)*(r2-l2+1)/2*val,
    tree[son1].sum3+=((r2*(r2+1)*(2*r2+1)-(l2-1)*((l2-1)+1)*(2*(l2-1)+1))/6)*val,
    tree[now].lazy=0;
}
void Add(LL &now,LL l,LL r,LL lt,LL rt,LL val){
    if(!now)
        now=++nod;
    if(lt<=l&&rt>=r){
        tree[now].lazy+=val,
        tree[now].sum1+=(r-l+1)*val,
        tree[now].sum2+=(l+r)*(r-l+1)/2*val,
        tree[now].sum3+=((r*(r+1)*(2*r+1)-(l-1)*((l-1)+1)*(2*(l-1)+1))/6)*val;
        return;
    }
    Pushdown(now,l,r);
    LL mid=(l+r)>>1;
    if(lt<=mid)
        Add(tree[now].son[0],l,mid,lt,rt,val);
    if(rt>mid)
        Add(tree[now].son[1],mid+1,r,lt,rt,val);
    Update(now);
}
LL Query(LL &now,LL l,LL r,LL lt,LL rt){
    if(!now)
        now=++nod;
    if(lt<=l&&rt>=r)
        return (rt-lt+1-lt*rt)*tree[now].sum1+(rt+lt)*tree[now].sum2-tree[now].sum3;
    Pushdown(now,l,r);
    LL mid=(l+r)>>1,sum=0;
    if(lt<=mid)
        sum+=Query(tree[now].son[0],l,mid,lt,rt);
    if(rt>mid)
        sum+=Query(tree[now].son[1],mid+1,r,lt,rt);
    return sum;
}
LL Gcd(LL x,LL y){
    if(!y)
        return x;
    return Gcd(y,x%y);
}
int main(){
    n=Read()-1,m=Read();
    while(m--){
        char c; scanf(" %c",&c);
        LL l=Read(),r=Read()-1;
        if(c=='C'){
            LL val=Read();
            Add(root,1,n,l,r,val);
        }else{
            LL mu=Query(root,1,n,l,r),zi=((r+1)-l)*((r+1)-l+1)/2;
            LL g=Gcd(mu,zi);
            printf("%lld/%lld\n",mu/g,zi/g);
        }
    }
    return 0;
}/*
*/
```


---

## 作者：Coros_Trusds (赞：0)

[更好的阅读体验](https://www.cnblogs.com/Coros-Trusds/p/16255536.html)

# 题目大意

给你一个序列，询问一个区间求从中任选一个子区间的权值和的期望。**操作带修。**

# 题目分析

非常容易想到线段树。

**套路一：注意到边权不容易考虑，我们转边权为点权。**

对于询问 $[l,r]$，我们的期望值为 $\sum\limits_{i=l}^r\sum\limits_{j=i}^r\dfrac{dist(i,j)}{{r-l+1}\choose 2}$。下面那个可以轻易求出，我们重点看 $\sum\limits_{i=l}^r\sum\limits_{j=i}^rdist(i,j)$。

这个式子直接求是 $\mathcal{O(n^3)}$ 的，根据数据范围我们需要把它优化到 $\mathcal{O(\log n)}$。我们看看有什么地方可以优化。

首先就是 $dist(i,j)$，可以用前缀和优化，$dist(i,j)$ 和 $sum[j]-sum[i-1]$ 是等价的，其中 $sum[i]=\sum\limits_{j=1}^iv_j$。预处理出 $sum$，单次询问 $\mathcal{O(n^2)}$。

还是不够。

**套路二：直接算不容易，我们不妨计算每个值的贡献。**

换而言之，套两个 $\sum$ 不好求那么我们不如直接算每个 $v_i$ 会被算几次。会被算几次呢？对于 $v_i$，区间总数是 $(r-i+1)\times (i-l+1)$。每次都会被算一次，所以 $v_i$ 会被算 $(r-i+1)\times(i-l+1)$ 次。

式子转化为 $\sum\limits_{i=l}^rv_i\times(r-i+1)\times(i-l+1)$，单次复杂度 $\mathcal{O(n)}$。

接下来推推式子：

$$\sum\limits_{i=l}^rv_i\times(r-i+1)\times(i-l+1)$$

$$=\sum\limits_{i=l}^rv_i\times(r\cdot i-l\cdot r+r-i^2+l\cdot i\color{red}{-i+i}\color{black}-l+1)$$

红色部分抵消掉：

$$=\sum\limits_{i=l}^rv_i\times(r\cdot i-l\cdot r+r-i^2+l\cdot i-l+1)$$

$$=\sum\limits_{i=l}^rv_i\times i\times(l+r)+\sum\limits_{i=l}^rv_i\times(r-l+1-l\cdot r)-\sum\limits_{i=l}^rv_i\times i^2$$

三个部分都可以用线段树来算。

# 代码

线段树中，我们用 $s4,s5$ 分别存储区间和和区间平方和，即 $\sum\limits_{i=l}^ri$ 和 $\sum\limits_{i=l}^ri^2$。用 $s1,s2,s3$ 分别存储 $\sum\limits_{i=l}^rv_i$，$\sum\limits_{i=l}^rv_i\times i$ 和 $\sum\limits_{i=l}^rv_i\times i^2$。

```cpp
//2022/5/10
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <cstdio>
#include <climits>//need "INT_MAX","INT_MIN"
#include <cstring>//need "memset"
#include <numeric>
#include <algorithm>
#define int long long
#define enter putchar(10)
#define debug(c,que) std::cerr << #c << " = " << c << que
#define cek(c) puts(c)
#define blow(arr,st,ed,w) for(register int i = (st);i <= (ed); ++ i) std::cout << arr[i] << w;
#define speed_up() ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)
#define mst(a,k) memset(a,k,sizeof(a))
#define Abs(x) ((x) > 0 ? (x) : (-x))
#define stop return(0)
const int mod = 1e9 + 7;
inline int MOD(int x) {
	if (x < 0) x += mod;
	return x % mod;
}
namespace Newstd {
	char buf[1 << 21],*p1 = buf,*p2 = buf;
	inline int getc() {
		return p1 == p2 && (p2 = (p1 = buf) + fread(buf,1,1 << 21,stdin),p1 == p2) ? EOF : *p1 ++;
	}
	inline int read() {
		int ret = 0,f = 0;char ch = getc();
		while (!isdigit(ch)) {
			if(ch == '-') f = 1;
			ch = getc();
		}
		while (isdigit(ch)) {
			ret = (ret << 3) + (ret << 1) + ch - 48;
			ch = getc();
		}
		return f ? -ret : ret;
	}
	inline void write(int x) {
		if (x < 0) {
			putchar('-');
			x = -x;
		}
		if (x > 9) write(x / 10);
		putchar(x % 10 + '0');
	}
}
using namespace Newstd;

const int N = 2e5 + 5;
int C[N][3];
int n,m,sum1,sum2,sum3;
inline int gcd(int a,int b) {
	return b == 0 ? a : gcd(b,a % b);
}
inline void init() {
	C[0][0] = 1;
	for (register int i = 1;i <= 1e5; ++ i) {
		C[i][0] = 1;
		for (register int j = 1;j <= 2; ++ j) {
			C[i][j] = C[i - 1][j] + C[i - 1][j - 1];
		}
	}
}
struct Segment_Tree {
	struct Node {
		int l,r;
		int tag,s1,s2;
		int s3,s4,s5;
	} node[N << 2];
	#define lson (p << 1)
	#define rson (p << 1 | 1)
	inline void pushup(int p) {
		node[p].s1 = node[lson].s1 + node[rson].s1;
		node[p].s2 = node[lson].s2 + node[rson].s2;
		node[p].s3 = node[lson].s3 + node[rson].s3;
		node[p].s4 = node[lson].s4 + node[rson].s4;
		node[p].s5 = node[lson].s5 + node[rson].s5;
	}
	inline void build(int p,int l,int r) {
		node[p].l = l,node[p].r = r;
		if (l == r) {
			node[p].s4 = l,node[p].s5 = l * l;
			return;
		}
		int mid = l + r >> 1;
		build(lson,l,mid),build(rson,mid + 1,r);
		pushup(p);
	}
	inline void pushdown(int p) {
		if (node[p].tag) {
			node[lson].tag += node[p].tag,node[rson].tag += node[p].tag;
			node[lson].s1 += node[p].tag * (node[lson].r - node[lson].l + 1);
			node[rson].s1 += node[p].tag * (node[rson].r - node[rson].l + 1);
			node[lson].s2 += node[p].tag * node[lson].s4;
			node[rson].s2 += node[p].tag * node[rson].s4;
			node[lson].s3 += node[p].tag * node[lson].s5;
			node[rson].s3 += node[p].tag * node[rson].s5;
			node[p].tag = 0;
		}
	}
	inline void update(int x,int y,int p,int k) {
		pushdown(p);
		if (x <= node[p].l && node[p].r <= y) {
			node[p].tag += k;
			node[p].s1 += k * (node[p].r - node[p].l + 1);
			node[p].s2 += k * node[p].s4,node[p].s3 += k * node[p].s5;
			return;
		}
		int mid = node[p].l + node[p].r >> 1;
		if (x <= mid) update(x,y,lson,k);
		if (y > mid) update(x,y,rson,k);
		pushup(p);
	}
	inline void query(int x,int y,int p) {
		pushdown(p);
		if (x <= node[p].l && node[p].r <= y) {
			sum1 += node[p].s1,sum2 += node[p].s2,sum3 += node[p].s3;
			return;
		}
		int mid = node[p].l + node[p].r >> 1;
		if (x <= mid) query(x,y,lson);
		if (y > mid) query(x,y,rson);
	}
	#undef lson
	#undef rson
} seg;
#undef int
int main(void) {
#ifndef ONLINE_JUDGE
	freopen("in.txt","r",stdin);
#endif
	#define int long long
	std::cin.tie(0),std::cout.tie(0);
	std::cin >> n >> m;
	init();
	seg.build(1,1,n);
	while (m --) {
		char ch[2];
		int l,r;
		std::cin >> ch >> l >> r;
		if (ch[0] == 'C') {
			int k;
			std::cin >> k;
			seg.update(l + 1,r,1,k);
		} else {
			sum1 = sum2 = sum3 = 0;
			seg.query(l + 1,r,1);
			int up = (l + 1 + r) * sum2 + ((r - (l + 1)) + 1 - (l + 1) * r) * sum1 - sum3;
			int down = C[r - l + 1][2];
			int t = gcd(up,down);
			std::cout << up / t << "/" << down / t << '\n';
		}
	}
	
	return 0;
}
```

---

## 作者：ljk123 (赞：0)

# 高速公路题解
我们看一看题，就知道概率是是区间内所有线段的权值和/线段个数。

那么，我们需要动态维护区间的数据结构，

很容易想到线段树，

考虑，如何将两个区间合并：
#### 注:以下线段树上的每个点的$sum$在代码中为$sum2$，仅为方便理解。
不妨设每个区间$[l,r]$内的所有线段权值和为$w$，

$[l,r]$的线段权值为$sum$，

左端点为$l$的所有线段权值和为$lw$，

右端点为$r$的所有线段的权值和为$rw$，

懒标记为$lazy$，区间长度为$lenx=r-l+1$

假如此区间为$x$,左区间为$lc$,右区间为$rc$:

$x$的$w$除去由$lc,rc$各自区间内部的$w$外,

还由经过左右两个区间的线段构成,

画图理解一下：
![](https://img2018.cnblogs.com/blog/1655789/201908/1655789-20190824173603843-1171305639.png)

然后第二个问题来了，如何维护$lw,rw$?
![](https://img2018.cnblogs.com/blog/1655789/201908/1655789-20190824174505341-769792856.png)
至于$sum,lazy$还用说吗？ 线段树模板啊！
```cpp
xd pushup(xd u,xd v){
   xd ans; int len=u.lenx+v.lenx;
   ans.lw=u.lw+v.lw+v.lenx*u.sum2,ans.rw=u.rw+v.rw+u.lenx*v.sum2,ans.lazy=0;
   ans.w=u.w+v.w+u.lenx*v.lw+v.lenx*u.rw,ans.sum2=u.sum2+v.sum2,ans.lenx=len;
   return ans;
}
```

再想想下传标记：

对于每个$x$的$w$，所有线段都加了线段长度$*lazy[x]$;

设$sum[len]$为长度为$len$的区间所有线段的长度和。

由$l-1$每增加一个长度，则每个长度的线段都有一个，即为:
$\sum_{i=1}^{l}=/frac{(l+1)*l}{2}$
递推即可。

```cpp
for(ll i=1;i<=n;++i) sum[i]=sum[i-1]+i*(i+1)/2;
```
所以：
```cpp
t[lc].w+=sum[t[lc].lenx]*t[x].lazy,t[rc].w+=sum[t[rc].lenx]*t[x].lazy;
```
对于$lw$和$rw$：
区间$[l,r]$长度在[1,r-l+1]的线段都有一种：
```cpp
t[lc].lw+=(t[lc].lenx+1)*t[lc].lenx/2*t[x].lazy,t[lc].rw+=(t[lc].lenx+1)*t[lc].lenx/2*t[x].lazy;
t[rc].lw+=(t[rc].lenx+1)*t[rc].lenx/2*t[x].lazy,t[rc].rw+=(t[rc].lenx+1)*t[rc].lenx/2*t[x].lazy;
```
$sum,lenx,lazy$的下传也不讲了。
```cpp
#include<bits/stdc++.h>
#define ll long long 
#define lc x<<1
#define rc x<<1|1
using namespace std;
const int N=1e5+6;
int n,m,t3;
ll sum[N],o,p,q,t1,t2;
char c[12];
struct xd{ll w,lazy,lw,rw,lenx,sum2;}t[N<<2];
inline int read(){
   int T=0,F=1; char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-') F=-1; ch=getchar();}
   while(ch>='0'&&ch<='9') T=(T<<3)+(T<<1)+(ch-48),ch=getchar();
   return F*T;
}
ll gcd(ll u,ll v){return u%v==0?v:gcd(v,u%v);}
void pushdown(int x){
     if(t[x].lazy){
        t[lc].lazy+=t[x].lazy,t[rc].lazy+=t[x].lazy;
        t[lc].w+=sum[t[lc].lenx]*t[x].lazy,t[rc].w+=sum[t[rc].lenx]*t[x].lazy;
        t[lc].lw+=(t[lc].lenx+1)*t[lc].lenx/2*t[x].lazy,t[lc].rw+=(t[lc].lenx+1)*t[lc].lenx/2*t[x].lazy;
        t[rc].lw+=(t[rc].lenx+1)*t[rc].lenx/2*t[x].lazy,t[rc].rw+=(t[rc].lenx+1)*t[rc].lenx/2*t[x].lazy;
        t[lc].sum2+=t[lc].lenx*t[x].lazy,t[rc].sum2+=t[rc].lenx*t[x].lazy;
        t[x].lazy=0;
     }
}
xd pushup(xd u,xd v){
   xd ans; int len=u.lenx+v.lenx;
   ans.lw=u.lw+v.lw+v.lenx*u.sum2,ans.rw=u.rw+v.rw+u.lenx*v.sum2,ans.lazy=0;
   ans.w=u.w+v.w+u.lenx*v.lw+v.lenx*u.rw,ans.sum2=u.sum2+v.sum2,ans.lenx=len;
   return ans;
}
void build(int l,int r,int x){
     t[x].lenx=r-l+1;
     if(l==r) return;
     int mid=l+r>>1;
     build(l,mid,lc),build(mid+1,r,rc);
} 
void update(ll l,ll r,int p,int q,int x,ll y){
     if(p<=l&&r<=q){t[x].lazy+=y,t[x].w+=sum[r-l+1]*y,t[x].lw+=(r-l+1)*(r-l+2)/2*y,t[x].rw+=(r-l+1)*(r-l+2)/2*y,t[x].sum2+=(r-l+1)*y;  return;}
     pushdown(x); int mid=l+r>>1;
     if(p<=mid) update(l,mid,p,q,lc,y);
     if(q>mid) update(mid+1,r,p,q,rc,y);
     t[x]=pushup(t[lc],t[rc]);
}
xd query(int l,int r,int p,int q,int x){
   if(p<=l&&r<=q){return t[x];}
   pushdown(x); int mid=l+r>>1; xd ans;
   if(q<=mid) ans=query(l,mid,p,q,lc);
   else if(p>mid) ans=query(mid+1,r,p,q,rc);
   else ans=pushup(query(l,mid,p,q,lc),query(mid+1,r,p,q,rc));
   return ans;
}
int main(){
    n=read(),m=read(),--n;
    for(ll i=1;i<=n;++i) sum[i]=sum[i-1]+i*(i+1)/2;
    build(1,n,1);
    for(int i=1;i<=m;++i){
        scanf("%s",c); t1=read(),t2=read()-1;
        if(c[0]=='C') t3=read(),update(1,n,t1,t2,1,t3);
        else{
            o=(t2-t1+1)*(t2-t1+2)/2,p=query(1,n,t1,t2,1).w;
            if(p) q=gcd(o,p),o/=q,p/=q;
            else o=1;
            printf("%lld/%lld\n",p,o);
        }
    }
    return 0;
}  
```

---

## 作者：xukuan (赞：0)

## 题目分析：

这里的期望就是平均值

每条路就是一个点

## 先写个O(nm)的暴力：

对于每一个区间，每一个点出现的次数是什么？

首先，对于任意长度相同的区间，处于同一个位置的点，出现的次数相同

那么每一个点出现的次数是？

打个表     

|  横向为区间长度，纵向为所在区间位置（就是区间里的第几个数）|  1|  2|  3|  4|  5|  6|
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
|  1|  1|  |  |  |  |  |
|  2|  2|  2|  |  |  |  |
|  3|  3|  4|  3|  |  |  |
|  4|  4|  6|  6|  4|  |  |
|  5|  5|  8|  9|  8|  5|  |
|  6|  6|  10|  12|  12|  10|  6|

得到式子：$map[L][R]=L*(R-L+1)$,其中$R=r-l,L=i-l,l<=i<r$
                                              
代码：
                                              
```cpp
#include<bits/stdc++.h>
#include<iostream>
#include<cstdio>
#define ll long long
using namespace std;

ll n,m,a[100010];

inline ll read(){
    ll x=0,tmp=1;
    char ch=getchar();
    while(!isdigit(ch)){
        if(ch=='-') tmp=-1;
        ch=getchar();
    }
    while(isdigit(ch)){
        x=(x<<3)+(x<<1)+ch-48;
        ch=getchar();
    }
    return tmp*x;
}

inline void write(ll x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    ll y=10,len=1;
    while(y<=x){
        y=(y<<3)+(y<<1);
        len++;
    }
    while(len--){
        y/=10;
        putchar(x/y+48);
        x%=y;
    }
}

ll gcd(ll x,ll y){
    return x%y==0?y:gcd(y,x%y);
}

int main(){
    n=read(); m=read();
    while(m--){
        string op;
        cin>>op;
        if(op=="C"){
            ll l=read(),r=read(),v=read();
            for(ll i=l; i<r; i++) a[i]+=v;
        }
        if(op=="Q"){
            ll l=read(),r=read(),ans=0,div=(r-l)*(r-l+1)/2;
            for(ll i=l; i<r; i++){
                ll L=i-l+1,R=r-l;
                ans+=a[i]*L*(R-L+1);
            }
            ll gd=gcd(ans,div);
            write(ans/gd); putchar('/');
            write(div/gd); putchar('\n');
        }
    }
    return 0;
}
```
                                             
## 这样可以得到40分，100分的做法是什么？

这一部分有参考 https://www.cnblogs.com/a1b3c7d9/p/10850039.html

我们看题目要我们做什么：

1.区间修改

2.区间查询

不用想了，线段树

首先，原来的求法是$\frac{\sum_{i=l}^{r} \sum_{j=l}^{r} {d[i,j]}} {(r-l+1)(r-l)/2}$

转换后得到$\sum_{i=l}^{r}{a[i](r-i+1)(i-l+1)}$

其中${l<=i<=r}$

即$(r-i+1-lr)sum[1]+(l+r)sum[2]-sum[3]$

其中${sum[x]=\sum_{i=l}^{r} {a[i]}*i^{x-1}}$

那么对于每一个区间，我们要维护的东西有：

l,r,lazymark（常规）

$sum[1-3]$

$\sum_{i=l}^{r} {a[i]}*i^{x}$ ，其中x=2或3

---

## 作者：Thosaka_Forest (赞：0)

对于给定区间[l,r]，考虑计算它的期望费用，就是 总的费用/总的情况数

总的情况数很好确定，我选择规定可以第一次选的比第二次大，所以计算总贡献后要乘2。

然后考虑计算总的费用。

考虑一个点i，$i\in [l,r]$，那么他能产生的贡献就是包含该点的区间数*该点费用，总的费用公式就是下面这个式子：

$\Sigma^{r}_{i=l}v_{i}*(r-i)*(i-l+1)$，然后把括号打开，得到$\Sigma^{r}_{i=l}v_{i}*(r*i-r*l+r-i*i+i*l-i)$

整理一下：
$\Sigma^{r}_{i=l}v_{i}*r*(1-l)+v_{i}*(r+l-1)*i-v_{i}*i*i$


所以很明显了，线段树维护$v_{i},v_{i}*i,v_{i}*i^{2}$。

然后考虑线段树的push_up和push_down，因为每一次修改如果都修改到叶子节点的话时间复杂度太高，所以每个线段树除了记录上述3个的和，由于每次修改的是$v_{i}$，所以记录$i$和$i\times i$的值，每次push_down的时候左区间加上（左区间的1或$i$或$i\times i$） $\times$ 修改值即可。

代码见下：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const LL MAXN=1e5+10;

LL n,q;
LL a[MAXN];
struct Tree{
	LL add;
	LL l,r,pre1,pre2;//pre1为i的和，pre2为i*i的和
	LL sum1,sum2,sum3;
}tr[MAXN<<2];
struct data{
	LL ans1,ans2,ans3;
	data(LL x=0,LL y=0,LL z=0){
		ans1=x,ans2=y,ans3=z;
	}
	friend inline data operator+(const data &a,const data &b){
		return data(a.ans1+b.ans1,a.ans2+b.ans2,a.ans3+b.ans3);
	}
	void init(){
		ans1=ans2=ans3=0;
	}
}ans;//记录三个答案

LL Read(){
	LL i=0,f=1;
	char c;
	for(c=getchar();(c>'9'||c<'0')&&c!='-';c=getchar());
	if(c=='-')
	  f=-1,c=getchar();
	for(;c>='0'&&c<='9';c=getchar())
	  i=(i<<3)+(i<<1)+c-'0';
	return i*f;
}

void push_up(LL root){
	tr[root].sum1=tr[root<<1].sum1+tr[root<<1|1].sum1;
	tr[root].sum2=tr[root<<1].sum2+tr[root<<1|1].sum2;
	tr[root].sum3=tr[root<<1].sum3+tr[root<<1|1].sum3;
}

void push_now(LL root,LL v){
	tr[root].add+=v;
	tr[root].sum1+=v*(tr[root].r-tr[root].l+1);
	tr[root].sum2+=v*tr[root].pre1;
	tr[root].sum3+=v*tr[root].pre2;
}

void push_down(LL root){
	if(tr[root].add!=0){//有可能为负数所以判非0
		push_now(root<<1,tr[root].add);
		push_now(root<<1|1,tr[root].add);
		tr[root].add=0;
	}
}

void build(LL root,LL l,LL r){
	tr[root].l=l,tr[root].r=r;
	if(l==r){
		tr[root].pre1=l;
		tr[root].pre2=l*l;
		return ;
	}
	LL mid=l+r>>1;
	build(root<<1,l,mid);
	build(root<<1|1,mid+1,r);
	push_up(root);
	tr[root].pre1=tr[root<<1].pre1+tr[root<<1|1].pre1;
	tr[root].pre2=tr[root<<1].pre2+tr[root<<1|1].pre2;
}

void update(LL root,LL l,LL r,LL L,LL R,LL key){
	if(l>R||r<L)
	  return ;
	if(L<=l&&r<=R){
		push_now(root,key);
		return ;
	}
	push_down(root);
	LL mid=l+r>>1;
	if(R<=mid)
	  update(root<<1,l,mid,L,R,key);
	else{
		if(L>mid)
		  update(root<<1|1,mid+1,r,L,R,key);
		else
		  update(root<<1,l,mid,L,mid,key),update(root<<1|1,mid+1,r,mid+1,R,key);
	}
	push_up(root);
}

void query(LL root,LL l,LL r,LL L,LL R){
	if(l>R||r<L)
	  return ;
	if(L<=l&&r<=R){
		ans=ans+data(tr[root].sum1,tr[root].sum2,tr[root].sum3);
		return ;
	}
	push_down(root);
	data a;
	LL mid=l+r>>1;
	if(R<=mid){
		query(root<<1,l,mid,L,R);
		return ;
	}
	else{
		if(L>mid){
		  	query(root<<1|1,mid+1,r,L,R);
		  	return ;
		}
		else{
		    query(root<<1,l,mid,L,mid),query(root<<1|1,mid+1,r,mid+1,R);
		    return ;
		}
	}
}

LL gcd(LL x,LL y){
	return x%y?gcd(y,x%y):y;
}

int main(){
	n=Read(),q=Read();
	build(1,1,n-1);
	while(q--){
		char cz[5];
		LL l,r;
		scanf("%s",cz);
		l=Read(),r=Read();
		if(cz[0]=='C'){
			LL key=Read();
			update(1,1,n-1,l,r-1,key);
		}
		else{
			ans.init();
			query(1,1,n-1,l,r-1);
			LL fz=2*(-r*(l-1)*ans.ans1+(r+l-1)*ans.ans2-ans.ans3);//计算答案
			LL fm=(r-l+1)*(r-l);
			LL gc=gcd(fz,fm);
			cout<<fz/gc<<'/'<<fm/gc<<'\n';//化简
		}
	}
	return 0;
}
```

---


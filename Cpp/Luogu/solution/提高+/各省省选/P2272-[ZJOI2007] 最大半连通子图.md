# [ZJOI2007] 最大半连通子图

## 题目描述

一个有向图 $G=\left(V,E\right)$ 称为半连通的 (Semi-Connected)，如果满足：$\forall u,v\in V$，满足 $u\to v$ 或 $v\to u$，即对于图中任意两点 $u,v$，存在一条 $u$ 到 $v$ 的有向路径或者从 $v$ 到 $u$ 的有向路径。

若 $G'=\left(V',E'\right)$ 满足 $V'\subseteq V$，$E'$ 是 $E$ 中端点属于 $V'$ 的所有边，则称 $G'$ 是 $G$ 的一个导出子图。若 $G'$ 是 $G$ 的导出子图，且 $G'$ 半连通，则称 $G'$ 为 $G$ 的半连通子图。若 $G'$ 是 $G$ 所有半连通子图中包含节点数最多的，则称 $G'$ 是 $G$ 的最大半连通子图。

给定一个有向图 $G$，请求出 $G$ 的最大半连通子图拥有的节点数 $K$，以及不同的最大半连通子图的数目 $C$。由于 $C$ 可能比较大，仅要求输出 $C$ 对 $X$ 的余数。

## 说明/提示

对于 $100\%$ 的数据，$N\le 10^5$，$M\le 10^6$，$X\le 10^8$。

## 样例 #1

### 输入

```
6 6 20070603
1 2
2 1
1 3
2 4
5 6
6 4```

### 输出

```
3
3```

# 题解

## 作者：说好不哭 (赞：49)

题解 【ZJOI2007 最大半连通子图】

思路：

因为存在环，所以先缩点，缩完点以后，此时图就变成DAG，然后进行一遍dfs扫描，dfs时注意用记忆化，然后边扫边记录得到求最大值数组和求个数数组，最后统计答案即可。

注意点：

1. 在求个数的时候要时刻取模，取模不能停！
2. 因为要求种类个数，所以要保证不重边（最大值与重边无关，但种类与重边有关）

补充：

对于此代码的组成，主要有三个部分：1.缩点；2.DAG记忆化；3.离散化去重；4.链式前向星。



```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+5,M=1e6+5;

int n,m,MOD,cnt,ans,MAX,k,now1,now2;
int head[N],u[M],v[M];
int col,now,top,dfn[N],low[N],color[N],sta[N],si[N];
int rd[N],cd[N],dep[N],sum[N];
bool f[N];
struct edge{int next,from,to;}e[M];
struct node{int u,v;}C[M],b[M];

inline bool cmp(node a,node b){return (a.u<b.u || a.u==b.u && a.v<b.v|| a.u==b.u && a.v==b.v);}
inline void add(int u,int v){cnt++;e[cnt].next=head[u];e[cnt].to=v;head[u]=cnt;}

inline void tarjan(int u)
{
    dfn[u]=low[u]=++now;
    sta[++top]=u;	
    for (register int i=head[u]; i; i=e[i].next)
    {
        if (!dfn[e[i].to])
        {
            tarjan(e[i].to);
            low[u]=min(low[u],low[e[i].to]);
        }
        else if (!color[e[i].to])
        low[u]=min(low[u],dfn[e[i].to]);
    }
    if (low[u]==dfn[u])
    {
        color[u]=++col;
        si[col]++;
        while (sta[top]!=u) color[sta[top]]=col,si[col]++,top--;
        top--;
    }
}

inline void dfs(int u,int fa)
{
	f[u]=true;
	if (!cd[u]) {dep[u]=si[u]; sum[u]=1; return;}
	for (register int i=head[u]; i; i=e[i].next)
	if (e[i].to!=fa)
	{
		if (!f[e[i].to]) dfs(e[i].to,u);
		if (dep[e[i].to]+si[u]>dep[u]) dep[u]=dep[e[i].to]+si[u],sum[u]=sum[e[i].to]%MOD;
		else if (dep[e[i].to]+si[u]==dep[u]) sum[u]=(sum[u]+sum[e[i].to])%MOD;
	}
}

int main(){
memset(head,0,sizeof(head));
memset(dfn,0,sizeof(dfn));
	scanf("%d%d%d",&n,&m,&MOD);
	for (register int i=1; i<=m; ++i) scanf("%d%d",&u[i],&v[i]),add(u[i],v[i]);
	
//缩点    
    for (register int i=1; i<=n; ++i) if (!dfn[i]) tarjan(i);


//离散化去重
for (register int i=1; i<=m; ++i) 
if (color[u[i]]!=color[v[i]]) k++,C[k].u=color[u[i]],C[k].v=color[v[i]];
sort(C+1,C+k+1,cmp);
cnt=0; 
cnt++; b[cnt].u=C[1].u,b[cnt].v=C[1].v; now1=b[cnt].u,now2=b[cnt].v;
for (register int i=2; i<=k; ++i) if (C[i].u!=now1|| C[i].v!=now2) 
cnt++,b[cnt].u=C[i].u,b[cnt].v=C[i].v,now1=b[cnt].u,now2=b[cnt].v;


//重新建图
	memset(head,0,sizeof(head));
	memset(e,0,sizeof(e));
	for (register int i=1; i<=cnt; ++i) 
	{
	cd[b[i].u]++,rd[b[i].v]++;
	e[i].next=head[b[i].u];
	e[i].from=b[i].u;
	e[i].to=b[i].v;
	head[b[i].u]=i;
	}


//记忆化搜索
	for (register int i=1; i<=col; ++i) if (!rd[i] && !f[i]) dfs(i,0); 



//统计答案
MAX=0,ans=0;	
	for (register int i=1; i<=col; ++i)
	{
		if (dep[i]>MAX) 
		{	
		MAX=dep[i];
		ans=sum[i];
		}
		else
		if (MAX==dep[i])
		ans=(ans+sum[i])%MOD;
	}   
    
    
	printf("%d\n",MAX);
	printf("%d\n",ans);
return 0;
}
```

## 在此，我还想求教一下各位大佬，在最后求和的时候，如果用我此代码中的语句：
```cpp
MAX=0,ans=0;	
	for (register int i=1; i<=col; ++i)
	{
		if (dep[i]>MAX) 
		{	
		MAX=dep[i];
		ans=sum[i];
		}
		else
		if (MAX==dep[i])
		ans=(ans+sum[i])%MOD;
	}   
```
## 就能AC，但是如果不这样写，若在搜索是记录最大值MAX，然后直接写：
```cpp
for (register int i=1; i<=col; ++i) if (dep[i]==MAX) ans=(ans+f[i])%MOD;
```
## 就会WA第一个点。一直没弄明白。
## 这里有我WA第一个点的链接[88分](https://www.luogu.org/recordnew/show/17710939)
## 总结：
### 对于我来说，此题思路较好想到，但是处理起来比较麻烦（对于大佬，不管......）所以建模15min，写代码60min，查错50min。



---

## 作者：xiaofulll (赞：47)

### 我写这篇题解主要是为了两个trick：

**1. Tarjan缩点后的点的排列顺序是逆拓扑序，所以不需要对新图进行拓扑排序**

	可以随机拍几组数据看一下 
   ~~证明过程略~~
   
   ~~主要是我也不会~~

**2. 拓扑序DP下的判重边：**

	只需要记录一下每一个点上一次是由谁转移而来的就好

	如上，缩点后的代码就可以这样写：
    （HEAD、VER、NEXT：新图的前向星；size：每个强
    连通分量包含的点数；f：最大半连通子图的大
    小；g：方案数）
    
 ```cpp
	for(int x=scc;x>=1;x--) {					//缩点后的顺序为逆拓扑序 
		for(int i=HEAD[x];i;i=NEXT[i]) {
			int y=VER[i];
			if(used[y]==x) continue;			//重边 
			used[y]=x;					//记录转移 
			if(f[y]<f[x]+size[y]) {
				f[y]=f[x]+size[y];
				g[y]=g[x];
			}else if(f[y]==f[x]+size[y]) {
				g[y]+=g[x];
				g[y]%=MOD;
			}
		}
	}
```
附最终结果：
![](https://cdn.luogu.com.cn/upload/image_hosting/ut3x9mau.png)
总用时：280ms

其他的就是常规的缩点和答案统计了

最后附上全部代码：

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
const int N=1e5+2,M=2e6+2;
int n,m,tot,MOD,top,num,scc,TOT,Head[N],ver[M],Next[M],dfn[N],low[N],Stack[N],belong[N];
int size[N],HEAD[N],VER[M],NEXT[M],f[N],g[N],used[N];
bool instack[N];
 
inline int read() {
	int x=0;char y='*',z=getchar();
	while(z<'0'||z>'9') y=z,z=getchar();
	while(z>='0'&&z<='9') x=(x<<3)+(x<<1)+(z^48),z=getchar();
	return y=='-'?-x:x;
}
inline void add(int x,int y) {
	ver[++tot]=y;
	Next[tot]=Head[x];
	Head[x]=tot;
}
inline void ADD(int x,int y) {
	VER[++TOT]=y;
	NEXT[TOT]=HEAD[x];
	HEAD[x]=TOT;
}
inline void Tarjan(int x) {
	dfn[x]=low[x]=++num;
	Stack[++top]=x;
	instack[x]=true;
	for(int i=Head[x];i;i=Next[i]) {
		int y=ver[i];
		if(!dfn[y]) {
			Tarjan(y);
			low[x]=min(low[x],low[y]);
		}else if(instack[y]) {
			low[x]=min(low[x],low[y]);
		}
	}
	if(dfn[x]==low[x]) {
		scc++;
		int k=-1;
		while(k!=x) {
			k=Stack[top--];
			belong[k]=scc;
			size[scc]++;
			instack[k]=false;
		}
	}
}
int main() {
//	freopen("test.txt","r",stdin);
	n=read();m=read();MOD=read();
	for(int i=1,x,y;i<=m;i++) {
		x=read(); y=read();
		add(x,y);
	}
	for(int i=1;i<=n;i++) {
		if(!dfn[i]) {
			Tarjan(i);
		}
	}
	for(int x=1;x<=n;x++) {
		f[x]=size[x];
		g[x]=1;
		for(int i=Head[x];i;i=Next[i]) {
			int y=ver[i];
			if(belong[x]==belong[y]) continue;
			ADD(belong[x],belong[y]);
		}
	}
	for(int x=scc;x>=1;x--) {					//缩点后的顺序为逆拓扑序 
		for(int i=HEAD[x];i;i=NEXT[i]) {
			int y=VER[i];
			if(used[y]==x) continue;			//重边 
			used[y]=x;							//记录转移 
			if(f[y]<f[x]+size[y]) {
				f[y]=f[x]+size[y];
				g[y]=g[x];
			}else if(f[y]==f[x]+size[y]) {
				g[y]+=g[x];
				g[y]%=MOD;
			}
		}
	}
	int ans=0,tmp=0;
	for(int i=1;i<=scc;i++) {
		if(f[i]>ans) {
			ans=f[i];
			tmp=g[i];
		}else if(f[i]==ans) {
			tmp+=g[i];
			tmp%=MOD;
		}
	}
	printf("%d\n%d",ans,tmp);
}
```


---

## 作者：Randolph、 (赞：42)

## [P2272 [ZJOI2007]最大半连通子图](https://www.luogu.org/problemnew/show/P2272)

萌新初学Tarjan，在《信息学奥赛一本通-提高篇》中看到这题，看到题解不多，便想发布一篇较为清新简洁的题解。

### 题目大意：

定义最大半连通图：对于图中任意两点u，v,存在一条u到v的有向路径 **或者** 从v到u的有向路径。求一个图中不同的最大半连通子图的数目。

看到题面时大家很容易想到，如果两点互相可以到达，那么它们必是半连通图，所以考虑先Tarjan缩点（[P3387 【模板】缩点（Tarjan缩点+DAGdp）](https://www.luogu.org/problemnew/show/P3387)）

 接着去除重边重新建图，你会发现，**在这个有向无环图（DAG）中，半连通子图都是一条链（可以举反例试试，这条链不可能有分支，否则将有两点无法抵达另一方）**
 
 于是，G的最大半连通子图拥有的节点数K就是最长链长度，不同的最大半连通子图的数目就是最长链个数。
 
(摘自信息学奥赛一本通）最长链可以直接用拓扑排序（topo），最长链个数用一个类似DP的方法，用f【i】表示以 i 为终点的方案数，那么f【i】就等于满足距离为起点到 i 的临时最短距离的点的 f 的和。然后查找距离等于最长链的点，答案为它们的方案数之和
 
 其他题解中已经给出了拓扑的算法，我借鉴大佬的程序用的是搜索，先一直搜到终点再回来更新答案。由于数据范围#7一直RE，后来改为const int N=1e5+5,M=2e6+5;终于AC。。qwq高性能。。
 
 ```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int N=1e5+5,M=2e6+5;

bool f[N];
//f 在搜索中判断是否走过

int n,m,mod,now,d[N],a[N],ans,maxans,ch[N];
//d指从u到终点的最长链距离，a指最长链点数，ch指出度

int h[N],u[M],v[M],r[N],nu[M],cnt;
//h是链式前向星的建边head，u，v保存初始读入的边左右两点，nu存初始时边的编号，r是入度

int top,co,dfn[N],low[N],c[N],s[N],st[N];
//dfn，low，st用于Tarjan，c表所在强连通分量编号，s指所在强连通分量点数

struct edge {
    int h,to;
} e[M];

#define rint register int
#define min(a,b) (a<b? a:b)
#define max(a,b) (a>b? a:b)

inline bool cmp(int a,int b) {
    return u[a]<u[b] || (u[a]==u[b] && v[a]<v[b]);
}//将边排序，方便重新建图

inline void add(int u,int v) {
    e[++cnt].h=h[u],h[u]=cnt,e[cnt].to=v;
}

inline int read() {
    int w=1,ans=0;
    char ch=getchar();
    while(ch>'9'||ch<'0') if (ch=='-') w=-1,ch=getchar();
    while(ch<='9'&& ch>='0') ans=(ans<<3)+(ans<<1)+(ch^48),ch=getchar();
    return ans*w;
}

inline void Tarjan(int u) {
    dfn[u]=low[u]=++now;
    st[++top]=u;
    for (rint i=h[u]; i; i=e[i].h) {
    	int v=e[i].to;
        if (!dfn[v])
            Tarjan(v),low[u]=min(low[u],low[v]);
        else if (!c[v])
            low[u]=min(low[u],dfn[v]);
    }
    if (low[u]==dfn[u]) {
        c[u]=++co,s[co]++;
        while(st[top]!=u)
            s[co]++,c[st[top]]=co,top--;
        top--;
    }
}//标准缩点

inline void dfs(int u) {
    f[u]=1;
    if (!ch[u]) {//如果没有出度，即到头了
        d[u]=s[u],a[u]=1;//距离为点数，以u为起点方案为1
        maxans=max(maxans,d[u]);//更新最长链距离
        return;
    }
    for (rint i=h[u]; i; i=e[i].h) {
    	int v=e[i].to;
        if (!f[v]) dfs(v);//继续搜索链的后面
        if (d[v]+s[u]>d[u])//若以u为起点的链距离可以更长
            d[u]=d[v]+s[u],a[u]=a[v]%mod;//更新
        else if (d[u]==d[v]+s[u])//若最长链距离相同
            a[u]=(a[u]+a[v])%mod;//加上方案数
        maxans=max(maxans,d[u]);
    }
}

int main() {
    n=read(),m=read(),mod=read();
    for (rint i=1; i<=m; i++) u[i]=read(),v[i]=read(),add(u[i],v[i]);
    for (rint i=1; i<=n; i++) if (!dfn[i]) Tarjan(i);

    cnt=0;
    memset(h,0,sizeof h);
    memset(e,0,sizeof e);
    for (rint i=1; i<=m; i++)
        nu[i]=i,u[i]=c[u[i]],v[i]=c[v[i]];

    sort(nu+1,nu+m+1,cmp);//按u，v排序边
    for (rint i=1; i<=m; i++)
    {
    	int num=nu[i];
        if (u[num]!=v[num] && (u[num]!=u[nu[i-1]] || v[num]!=v[nu[i-1]]))//若此边不是自环，且与上一条边不同（去除重边）
           ++ch[u[num]],++r[v[num]],add(u[num],v[num]);}
//出度入度加1，加边
    for (rint i=1; i<=co; i++) if (!r[i] && !f[i]) dfs(i);//入度为0且未搜索过
    for (rint i=1; i<=co; i++) if (d[i]==maxans) ans=(ans+a[i])%mod;//统计答案
    printf("%d\n%d\n",maxans,ans);
}
```


---

## 作者：破壁人 (赞：32)

首先观察到这个图中如果有某个部分是强连通的，那其实可以把这整个部分都看做一个点，这样并不会对结果产生影响。

所以首先对这个图进行tarjan缩点，并记录下每个连通块的大小，和每个点所在的连通块。

缩点之后，会发现这个图变成了一个dag（有向无环图），我们要对这个dag求出最长链的大小和个数。

因为这个图是无环的，所以我们可以按照拓扑序进行DP:f[i]表示到第i个连通块的最长链大小，g[i]表示个数。

很容易就想到了转移的方法：

1.{g[i]=g[i]+g[j]}(条件：f[j]+number[i]==f[i])

2.{g[i]=g[j],f[i]=f[j]+number[i]}(条件：f[j]+number[i]>f[i])。

按照这个转移状态就可以啦。

但是要注意缩点之后会出现大量重边拓扑排序之前要去重。








```cpp
#include<iostream>
#include<vector>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;
struct shittt
{
    int aa;
    int bb;
}x1[1000001];
vector<int>a[100001],s[100001];//vector存边数组
queue<int>rt;//拓扑排序队列
bool v[100001],f[100001];//tanjan用的标记数组
int stack[100001],h,u,cnt,low[100001],dfn[100001],number[100001],b[100001];
//number表示连通块大小，b记录每个点所在的连通块，low和dfn是tanjan用的数组，stack是tarjan用的栈。
int sum[100001],dp[100001],r[100001];//sum表示最长链大小，dp表示个数，r存储连通块的入度
void dfs(int o)//tanjan缩点。
{
    u++;
    low[o]=dfn[o]=u;
    h++;
    stack[h]=o;
    f[o]=true;
    if(!a[o].empty())
        for(int i=0;i<a[o].size();i++)
            if(!v[a[o][i]])
            {
                v[a[o][i]]=true;
                dfs(a[o][i]);
                low[o]=min(low[o],low[a[o][i]]);
            }else if(f[a[o][i]]) low[o]=min(low[o],dfn[a[o][i]]);
    if(low[o]==dfn[o])//找到一个连通块
    {
        cnt++;//新的标号
        while(stack[h]!=o)
        {
            b[stack[h]]=cnt;
            number[cnt]++;//连通块大小++
            f[stack[h]]=false;
            h--;//出栈
        }
        b[stack[h]]=cnt;
        number[cnt]++;
        f[stack[h]]=false;
        h--;
    }
}
bool cmp(shittt a1,shittt b1)//排序条件函数
{
    return((a1.aa<b1.aa)||((a1.aa==b1.aa)&&(a1.bb<b1.bb)));
}
int main()
{
    int n,m,x;
    cin>>n>>m>>x;
    for(int i=1;i<=m;i++)
    {
        int xx,yy;
        cin>>xx>>yy;
        a[xx].push_back(yy);//用vector存边
    }
    memset(v,0,sizeof(v));
    memset(f,0,sizeof(f));
    u=cnt=0;
    for(int i=1;i<=n;i++)
        if(!v[i])//可能原图不是连通的，会有多个块组成。
        {
            v[i]=true;
            dfs(i);
        }
    int re=0;
    for(int i=1;i<=n;i++)
        if(!a[i].empty())
            for(int j=0;j<a[i].size();j++)
                if(b[i]!=b[a[i][j]])
                {
                    x1[++re].aa=b[i];
                    x1[re].bb=b[a[i][j]];
```
}//记录新的边（缩点之后连通块之间的边）
```cpp
    sort(x1+1,x1+re,cmp);//排序去除重边。
    memset(r,0,sizeof(r));
    for(int i=1;i<=re;i++)
    {
        if((x1[i].aa==x1[i-1].aa)&&(x1[i].bb==x1[i-1].bb)) continue;
        s[x1[i].aa].push_back(x1[i].bb);
        r[x1[i].bb]++;
    }
    for(int i=1;i<=cnt;i++)//DP初始化
        if(r[i]==0) 
        {
            rt.push(i);
            sum[i]=number[i];
            dp[i]=1;
        }
    while(!rt.empty())//拓扑排序（用队列存入度为零的点）+DP
    {
        int yu=rt.front();
        rt.pop();
        for(int i=0;i<s[yu].size();i++)
        {
            r[s[yu][i]]--;
            if(r[s[yu][i]]==0)
                rt.push(s[yu][i]);
            if(sum[yu]+number[s[yu][i]]==sum[s[yu][i]]) //转移状态
            {
                dp[s[yu][i]]+=dp[yu];
                dp[s[yu][i]]%=x;
            }else
            if(sum[yu]+number[s[yu][i]]>sum[s[yu][i]])
            {
                dp[s[yu][i]]=dp[yu];
                sum[s[yu][i]]=sum[yu]+number[s[yu][i]];
            }
        }
    }
    int yu=0,k=0;
    for(int i=1;i<=cnt;i++)
        if(sum[i]>sum[yu]){yu=i;k=dp[i];}
            else if(sum[i]==sum[yu]){k+=dp[i];k%=x;}//求出最终值
    cout<<sum[yu]<<endl<<k<<endl;
    return 0;
}
```

---

## 作者：嗯。 (赞：21)

就要氮氧碘磷8102了~~有点慌~~

最近在用某本蓝色的一本通练习tarjan时,看到了这道题,于是现在loj上打开了这道题,题目上给了半连通的定义,和强联通的定义好像啊,然后看这又是tarjan的练习,于是冷静分析,一个强连通分量肯定是一个半连通子图呀.

于是想先缩点再说
```cpp
void tarjan(int t)
{
	//个人喜好用order数组,一般是dfn
	order[t]=low[t]=++timetag;
	zh[++top]=t;b[t]=1;
	int temp;
	for(register int i=headf[t];i;i=edgef[i].next)
	{
		if(!order[edgef[i].to])
		{
			tarjan(edgef[i].to);
			low[t]=min(low[edgef[i].to],low[t]);
		}
		else if(b[edgef[i].to])
		low[t]=min(low[t],order[edgef[i].to]);
	}
	if(low[t]==order[t])
	{
		while((temp=zh[top--]))
		{
			b[temp]=0;
			root[temp]=t;
			++size[t];//统计这个强联通分量(半连通子图)内的点数
			if(t==temp)
			break;
		}
	}
}
```
以上是tarjan常规操作,不懂的没关系先去[缩点](https://www.luogu.org/problemnew/show/P3387)

好,缩完点了.但并不是仅仅只有强联通子图是半连通子图

那我们考虑在DAG(有向无环图)~~已经是了~~上,怎么求半连通图呢?

由半连通图的定义稍稍想一想可知,只要两个点有边相连,那他们就可以放到一个半连通子图里,所以我们只要在缩完点的新图上一直进行这种操作就可以了.

因为新图已经是一个DAG了,那么一直进行这种操作是不会形成环的.那么求最大半连通子图不就是求最长链吗~~美滋滋~~然后题目又要求最大半连通子图的方案数,我们很容易由做缩点这道题的经验想到拓扑排序.
```cpp
void topsort()
{
	//r是用来统计入度,c是用来统计出度的
    //喜欢用首写字母,大佬勿喷
	queue<int> q;
	cnt=0;
	for(register int i=1;i<=n;i++)
	if(root[i]==i&&!r[i])//是强连通分量的根
	q.push(i),dis[i]=size[i],ans[i]=1;
	while(q.size())
	{
		int t=q.front();
		q.pop();
		for(register int i=heads[t];i;i=edges[i].next)
		{
			if(dis[edges[i].to]<dis[t]+size[edges[i].to])
            //更长的链,长度和方案数都直接更新
			dis[edges[i].to]=dis[t]+size[edges[i].to],ans[edges[i].to]=ans[t];
			else if(dis[edges[i].to]==dis[t]+size[edges[i].to])
			ans[edges[i].to]=(ans[edges[i].to]%mo+ans[t]%mo)%mo;
			//相同的长度,直接方案数累加
            --r[edges[i].to];
			if(!r[edges[i].to])//入度为0了就入队
			q.push(edges[i].to);
		}
	}
	for(register int i=1;i<=n;i++)
	if(root[i]==i&&!c[i])
	{
		if(dis[i]==ans1)
		ans2=(ans2%mo+ans[i]%mo)%mo;
		if(dis[i]>ans1)
		ans1=dis[i],ans2=ans[i];
	}
}
```
拓扑排序上稍加变动,和缩点模板题的拓扑排序差不多吧(除了统计方案数)

但是这道题就这样结束了吗?~~不存在的~~

如果这个缩完点之后的图中出现了重边怎么办,那就会使方案数莫名增多.所以对于缩完点后的图还要判重边
```cpp
inline bool cmp(zhzs x,zhzs y)
{return x.x==y.x?(x.y<y.y):(x.x<y.x);}
```
```cpp
for(register int i=1;i<=m;i++)
{
	int x1=root[edgef[i].from];
	int y1=root[edgef[i].to];
	if(x1!=y1)
	{
		e[++num].x=x1;
		e[num].y=y1;
	}
}
sort(e+1,e+num+1,cmp);
```
```cpp
for(register int i=1;i<=num;i++)
if(e[i].x!=e[i-1].x||e[i].y!=e[i-1].y)
{
	adds(e[i].x,e[i].y);
}
```
直接让起点相同的边以终点大小顺序排序,然后只要这条边的起点或者终点与上一条不同就不是重边

所以这道题就弄完了

附上我丑陋的代码:
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;
struct ppp
{int x,y;}e[2000301];
struct node
{int to,from,next;}edgef[2000301],edges[2000301];
int n,m,x,y,top,cnt,num,timetag,mo,ans1,ans2;
int dis[1000001],ans[1000001],headf[1000001],heads[1000001];
int zh[1000001],size[1000001],b[1000001];
int order[1000001],low[1000001],root[1000001],r[1000001],c[1000001];
//别慌,没有炸空间
inline bool cmp(zhzs x,zhzs y)
{return x.x==y.x?(x.y<y.y):(x.x<y.x);}//去重边,排序
inline void addf(int u,int v)//原图加边
{edgef[++cnt].to=v;edgef[cnt].from=u;edgef[cnt].next=headf[u];headf[u]=cnt;}
inline void adds(int u,int v)//新图加边
{edges[++cnt].to=v;edges[cnt].next=heads[u];heads[u]=cnt;}
inline int min(int x,int y)
{return x<y?x:y;}
//没什么用的重载
void tarjan(int t)
{
	order[t]=low[t]=++timetag;//时间戳
	zh[++top]=t;b[t]=1;
	int temp;
	for(register int i=headf[t];i;i=edgef[i].next)
	{
		if(!order[edgef[i].to])
		{
			tarjan(edgef[i].to);
			low[t]=min(low[edgef[i].to],low[t]);
		}
		else if(b[edgef[i].to])
		low[t]=min(low[t],order[edgef[i].to]);
	}
	if(low[t]==order[t])
	{
		while((temp=zh[top--]))//弹栈
		{
			b[temp]=0;
			root[temp]=t;
			++size[t];//统计这个强联通分量(半连通子图)内的点数
			if(t==temp)
			break;
		}
	}
}
void topsort()
{
	queue<int> q;
	cnt=0;
	for(register int i=1;i<=num;i++)
	if(e[i].x!=e[i-1].x||e[i].y!=e[i-1].y)
	{
		adds(e[i].x,e[i].y);
		++r[e[i].y];++c[e[i].x];//统计入度,出度
	}
	for(register int i=1;i<=n;i++)
	if(root[i]==i&&!r[i])
	q.push(i),dis[i]=size[i],ans[i]=1;
	while(q.size())
	{
		int t=q.front();
		q.pop();
		for(register int i=heads[t];i;i=edges[i].next)
		{
			if(dis[edges[i].to]<dis[t]+size[edges[i].to])
			dis[edges[i].to]=dis[t]+size[edges[i].to],ans[edges[i].to]=ans[t];
			else if(dis[edges[i].to]==dis[t]+size[edges[i].to])
			ans[edges[i].to]=(ans[edges[i].to]%mo+ans[t]%mo)%mo;
			--r[edges[i].to];
			if(!r[edges[i].to])
			q.push(edges[i].to);
		}
	}
	for(register int i=1;i<=n;i++)
	if(root[i]==i&&!c[i])
	{
		if(dis[i]==ans1)
		ans2=(ans2%mo+ans[i]%mo)%mo;
		if(dis[i]>ans1)
		ans1=dis[i],ans2=ans[i];
	}
}
int main()
{
	scanf("%d%d%d",&n,&m,&mo);
	for(register int i=1;i<=m;i++)
	{
		scanf("%d%d",&x,&y);
		addf(x,y);
	}
	for(register int i=1;i<=n;i++)
	if(!order[i])//还没有被访问过
	tarjan(i);
	for(register int i=1;i<=m;i++)
	{
		int x1=root[edgef[i].from];
		int y1=root[edgef[i].to];
		if(x1!=y1)//判断是否在同一个强连通分量内
        {
			e[++num].x=x1;
			e[num].y=y1;
		}
	}
	sort(e+1,e+num+1,cmp);
	topsort();
	printf("%d\n%d",ans1,ans2);
	return 0;
}
```

一开始先在loj上A了,就想洛谷上应该有名字这么高级的题吧,于是到洛谷上一找.

我的天! ZJOI 我的天! 紫题,我又要A紫题了.

结果一交上去RE,有点难受,然后看了一下数组~~没毛病啊~~,就一直瞎jb乱调,~~然并卵啊~~,最后还是想把数组开大十倍,碰个运气吧,结果A了,有点舒服

第一篇紫题题解,大佬勿喷,关爱蒟蒻

---

## 作者：fanfansann (赞：6)

**一般用到tarjan算法的题目步骤都非常相似：**
1. **tarjan算法**
2. **缩点，建图（这里要判重）**
3. **按照拓扑序递推（这里缩点以后逆向就已经是拓扑序了）/ 循环遍历新图求解答案。**

导出子图：点是原图的子集，边一定包含与子图中所有点有关的边。
半联通子图：所有的两个点，我要么可以直接一条路过去，要么你可以直接过来。
 显然，对于任意一个强连通分量$S\in G$，它一定一个半连通子图，于是我们可以考虑先缩点。缩点之后，原图变成了一个有向无环图，显然，对于任意一条DAG中的一条单向到达的链，它都是一个半连通子图。

所以答案K就是DAG中最大链的顶点个数，答案C就是DAG中不同的最大链有多少种。
由于整个DAG按顺序已经是一个拓扑序了，所以我们可以直接递推DP线性$O(n)$求答案。 


本题需要判重去重，因为第二问是总的方案数，如果边是一摸一样的那么方案应该是同一种，所以如果不判重就会影响最后的答案。我们直接用一个set判重，顺便用到一个巧妙的hash，因为我们一共就只有100000个点，所以我们直接把所有的点都映射到100000+v即可，不会产生冲突。
需要注意的是建完的图是逆拓扑序,按照拓扑序递推DP,所以必须倒着来循环DP
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<unordered_set>

using namespace std;

const int N = 100007, M = 2000007, INF = 0x3f3f3f3f;

typedef long long ll;
int mod;
int n, m;
int dfn[N], low[N], num;
int ver[M], edge[M], head[N], nex[M], tot;
int h[N];

int Size[N], scc_cnt, scc_id[N];
int stk[N], top, ins[N];

int f[N], g[N];//顶点个数和方案数

void add(int h[],int x,int y){
    ver[tot] = y;
    nex[tot] = h[x];
    h[x] = tot ++ ;
}

void tarjan(int x){
    dfn[x] = low[x] = ++ num;
    stk[ ++ top] = x;
    ins[x] = true;

    for(int i = head[x];~i;i = nex[i]){
        int y = ver[i];
        if(!dfn[y]){
            tarjan(y);
            low[x] = min(low[x],low[y]);
        }
        else if(ins[y]){
            low[x] = min(low[x], dfn[y]);
        }
    }

    if(dfn[x] == low[x]){
        int y;
        ++ scc_cnt;
        do{
            y = stk[top -- ];
            ins[y] = false;
            scc_id[y] = scc_cnt;
            Size[scc_cnt] ++ ;
        }while(x != y);
    }
}

int main()
{
    memset(head,-1,sizeof head);
    memset(h,-1,sizeof h);
    scanf("%d%d%d",&n,&m,&mod);
    while(m -- ){
        int x,y;
        scanf("%d%d",&x,&y);
        add(head,x,y);
    }

    for(int i = 1;i <= n;++i)
        if(!dfn[i])
        tarjan(i);

    unordered_set<ll>st;
    //(u,v) -> u * 1000000 + v;
    //因为一共只有100000个点
    for(int i = 1;i <= n;++i){
        for(int j = head[i];~j;j = nex[j]){
            int k = ver[j];
            int a = scc_id[i], b = scc_id[k];
            ll hash = a * 100000ll + b;
            //建新图并判重
            if(a != b && !st.count(hash)){
                add(h,a,b);
                st.insert(hash);
            }
        }
    }

    for(int i = scc_cnt;i >= 1;-- i){//建完的图是逆拓扑序,按照拓扑序递推,所以必须倒着来
        if(!f[i]){
            f[i] = Size[i];
            g[i] = 1;
        }
        for(int j = h[i];~j;j = nex[j]){
            int k = ver[j];
            if(f[k] < f[i] + Size[k]){
                f[k] = f[i] + Size[k];
                g[k] = g[i];
            }
            else if(f[k] == f[i] + Size[k]){
                g[k] = (g[k] + g[i]) % mod;
            }
        }
    }

    ll maxx = 0,sum = 0;
    for(int i = 1;i <= n;++i){
        if(f[i] > maxx){
            maxx = f[i];
            sum = g[i];
        }
        else if(f[i] == maxx){
            sum = (sum + g[i] ) % mod;
        }
    }
    printf("%lld\n%lld\n",maxx, sum);
    return 0;
}

```


---

## 作者：孤叶残影 (赞：6)

## 强连通分量+拓扑排序+DP ##
~~~~
首先用Tarjan排序，去重边，得到新图，题目就变成求图中最长链及最长链个数
~~~~
最长链可以直接用拓扑排序
~~~~
最长链个数用一个类似于DP的方法
~~~~
用f[i]表示新图中以i为终点的方案数
~~~~
那么f[i]就等于连到i且满足距离等于起点到i的临时最长距离的点的f之和
~~~~
最后查找距离等于最长链的点，答案是它们的方案数之和


------------

```cpp
#include<bits/stdc++.h>
#define N 100000+5
#define M 1000000+5
using namespace std;
struct node{
	int v,next;
}edge[M];
int n,m,mo,num,col,top,cnt,ans,anss,t,w;
int dfn[N],low[N],sz[N],cu[N],sn[N];
int de[N],to[N],head[N],x[N],y[N],ue[N],dis[N],nu[M],e[N];
inline void add_edge(int u,int v)//连边
{
	edge[++cnt].v=v;
	edge[cnt].next=head[u];
	head[u]=cnt;
}
inline void Tarjan(int u)//Tarjan缩点
{
	dfn[u]=low[u]=++num;
	sz[++top]=u;
	for(int i=head[u];i;i=edge[i].next)
	{
		int v=edge[i].v;
		if(!dfn[v])
		{
			Tarjan(v);
			low[u]=min(low[u],low[v]);
		}
		else
		{
			if(!cu[v])
			low[u]=min(low[u],dfn[v]);
		}
	}
	if(low[u]==dfn[u])
	{
		cu[u]=++col;
		++sn[col];
		while(sz[top]!=u)
		{
			++sn[col];
			cu[sz[top]]=col;
			top--;
		}
		top--;
	}
}
inline bool cmp(int a,int b)
{
	if(x[a]!=x[b])
	{
		return x[a]<x[b];
	}
	return y[a]<y[b];
}
inline void Remove()//去重边，否则会对方案的统计有影响
{
	for(int i=1;i<=m;i++)
	{
		nu[i]=i;
		x[i]=cu[x[i]];
		y[i]=cu[y[i]];
	}
	sort(nu+1,nu+1+m,cmp);
}
inline void Build()//缩点并重新建图，并处理入度为Topo排序准备
{
	 cnt=0;
	memset(head,0,sizeof(head));
	for(int i=1;i<=m;i++)
	{
		int z=nu[i];
		if((x[z]!=y[z])&&(x[z]!=x[nu[i-1]]||y[z]!=y[nu[i-1]]))
		{
			++de[y[z]];
			add_edge(x[z],y[z]);
		}
	}
}
inline void Reset()//Topo初始入队
{
	for(int i=1;i<=col;i++)
	{
		if(!de[i])
		{
			ue[++w]=i;
			dis[i]=sn[i];
			e[i]=1;
			if(dis[ans]<dis[i]) ans=i;
		}
	}
}
inline void Topo()//Topo排序及递推
{
	while(t<w)
	{
		int u=ue[++t];
		for(int i=head[u];i;i=edge[i].next)
		{
			int v=edge[i].v;
			--de[v];
			if(dis[v]<dis[u]+sn[v])//临时距离更新，重新统计方案数
			{
				dis[v]=dis[u]+sn[v];
				e[v]=0;
				if(dis[ans]<dis[i]) ans=v;
			}
			if(dis[v]==dis[u]+sn[v])//满足距离条件，累加方案数
			{
				e[v]=(e[v]+e[u])%mo;
			}
			if(!de[v]) ue[++w]=v;
		}
	}
}
inline void Ask()//统计答案
{
	for(int i=1;i<=n;i++)
	{
		if(dis[i]==dis[ans])
		{
			anss=(anss+e[i])%mo;
		}
	}
}
int main()
{
	scanf("%d %d %d",&n,&m,&mo);
	for(int i=1;i<=m;i++)
	{
		scanf("%d %d",&x[i],&y[i]);
		add_edge(x[i],y[i]);
	}
	for(int i=1;i<=n;i++)
	{
		if(!dfn[i])
		Tarjan(i);
	}
	Remove();
	Build();
	Reset();
	Topo();
	Ask();
	printf("%d\n%d",dis[ans],anss);
	return 0;
}
```


---

## 作者：jrzs (赞：5)

# 强连通分量+动态规划
[P2272](https://www.luogu.org/problem/P2272)
在有向图$G$中，如果两个顶点$u_{i}$，$u_{j}$间有一条从$u_{i}$到$u_{j}$的有向路径，同时还有一条从$u_{j}$到$u_{i}$的有向路径，则称两个顶点强连通（strongly connected）。如果有向图$G$的每两个顶点都强连通，称$G$是一个强连通图。有向图的极大强连通子图，称为强连通分量（strongly connected components）。
显然，对于任意一个强连通分量$S\in G$，它都是一个半连通子图，于是我们可以考虑先缩点。缩点之后，原图变成了一个DAG（有向无环图），显然，对于任意一条DAG中的链，它都是一个半连通子图，所以题目中的$K$就是DAG中最大链的顶点个数，$C$就是DAG中不同的最大链有多少个。
设$size(u)$表示顶点$u$代表的强连通分量$S$中的顶点个数，$f(u)$表示从顶点$u$开始延伸的最大链的顶点个数，$d(u)$表示从顶点$u$开始延伸的不同的最大链有多少个，则有：
$f(u)=size(u)+max(f(v))\quad(u\to v)$
$d(u)=\sum d(v)\quad(u\to v,size(u)+f(v)=f(u))$
每次从一个没有被访问过的顶点开始做深度优先搜索，回溯时计算每个顶点的$f$，$d$值。$K$，$C$也可以按照相同的方式进行更新。
```cpp
#include<map>
#include<stack>
#include<cstdio>
#include<iostream>
using namespace std;
const int MAXN=(int)1e5+5,MAXM=(int)1e6+5;
map<int,bool>M[MAXN];
stack<int>S;
int lw[MAXN],siz[MAXN],scc[MAXN],f[MAXN],d[MAXN];
int hed1[MAXN],nxt1[MAXM],to1[MAXM],hed2[MAXN],nxt2[MAXM],to2[MAXM];
bool vis[MAXN];
int x,cnt,tim,scclen,mx,ans;
inline void add1(int a,int b){
	nxt1[++cnt]=hed1[a];
	to1[cnt]=b;
	hed1[a]=cnt;
}
void dfs1(int u){
	int dfn=lw[u]=++tim;
	S.push(u);
	for(register int i=hed1[u];i;i=nxt1[i]){
		if(!lw[to1[i]])
			dfs1(to1[i]);
		if(!scc[to1[i]])
			lw[u]=min(lw[u],lw[to1[i]]);
	}
	if(!(lw[u]^dfn)){
		scclen++;
		while(1){
			int pnt=S.top();
			S.pop();
			siz[scclen]++;
			scc[pnt]=scclen;
			if(!(pnt^u))
				break;
		}
		f[scclen]=siz[scclen];
		d[scclen]=1;
	}
}
inline void add2(int a,int b){
	nxt2[++cnt]=hed2[a];
	to2[cnt]=b;
	hed2[a]=cnt;
}
void dfs2(int u){
	vis[u]=1;
	for(register int i=hed2[u];i;i=nxt2[i]){
		if(!vis[to2[i]])
			dfs2(to2[i]);
		if(f[to2[i]]+siz[u]>f[u]){
			f[u]=f[to2[i]]+siz[u];
			d[u]=d[to2[i]];
		}
		else if(!(f[to2[i]]+siz[u]^f[u]))
			(d[u]+=d[to2[i]])%=x;
	}
	if(f[u]>mx){
		mx=f[u];
		ans=d[u];
	}
	else if(!(f[u]^mx))
		(ans+=d[u])%=x;
}
int main(){
	int n,m;
	scanf("%d%d%d",&n,&m,&x);
	for(register int i=1;i<=m;i++){
		int a,b;
		scanf("%d%d",&a,&b);
		add1(a,b);
	}
	for(register int i=1;i<=n;i++)
		if(!lw[i])
			dfs1(i);
	cnt=0;
	for(register int i=1;i<=n;i++)
		for(register int j=hed1[i];j;j=nxt1[j])
			if(scc[i]^scc[to1[j]]&&!M[scc[i]][scc[to1[j]]]){
				add2(scc[i],scc[to1[j]]);
				M[scc[i]][scc[to1[j]]]=1;
			}
	for(register int i=1;i<=scclen;i++)
		if(!vis[i])
			dfs2(i);
	printf("%d\n%d\n",mx,ans);
	return 0;
}

```

---

## 作者：nihanchu (赞：5)

因为我数组开错了调了很久。。


按照题意来说很明显的是如果是一个环的话它肯定符合条件，而且为了满足最大的条件，环里的点一定是一起取的，所以先用tarjan缩点。


缩点后实质上就是取一条最长链。


然后很明显就可以按照拓扑序来dp了,side[i]表示到当前这个点为止，链的最长的长度是多少？dp[i]表示如果取最长链的话有几种可能性。


然后转移就是，




if (side[i]==side[j]+size[i]) dp[i]+=dp[j];

else if (side[i]<side[j]+size[i]) dp[i]=dp[j];

size[i]表示i这个点在未缩点之前有多少个点，j到i有一条边。


还有一个点就是，我们取的半联通子图是点集，所以要去掉重边，才能让上述dp有效。


```cpp
#include<iostream>
#include<vector>
#include<algorithm>
#include<cstdio>
#include<queue>
#include<stack>
#include<cstdlib>
#define maxn 200009
#define maxm 2000009
using namespace std;
typedef long long ll;
struct ding2{
  int lef,righ;
}bia[maxm];
struct ding{
  int to,next;
}edge[maxm];
queue<int>q;
int num,n,m,ans;
int head[maxn],ru[maxn],side[maxn],size[maxn];
ll mo,dp[maxn],ans2;
int cnt;
void add(int u,int v)
{
  edge[++cnt].to=v;edge[cnt].next=head[u];head[u]=cnt;
}
void tuopu()
{
  while (!q.empty())
  {
      int now=q.front();q.pop();
      ans=max(ans,side[now]);
      for (int i=head[now];i;i=edge[i].next)
      {
        int y=edge[i].to; ru[y]--;
        if (side[y]<size[y]+side[now])
        {
        side[y]=size[y]+side[now];
        dp[y]=dp[now]; 
      }
      else if (side[y]==size[y]+side[now])
      {
       dp[y]=(dp[y]+dp[now])%mo;
      }
        if (ru[y]==0) q.push(y);
    }
  }
}
stack<int>s;
int low[maxn],nod[maxn],dfn[maxn],p=0;
vector<int>g[maxn];
bool in[maxn];
void tarjan(int x)
{
  dfn[x]=low[x]=++p;
  s.push(x);in[x]=true;
  for (int i=0;i<g[x].size();i++)
  {
      int y=g[x][i];
      if (!dfn[y]) tarjan(y),low[x]=min(low[x],low[y]);
      else if (in[y]) low[x]=min(low[x],dfn[y]);
  }
  if (low[x]==dfn[x])
  {
       ++num; 
       while (s.top()!=x)
       {
         nod[s.top()]=num; size[num]++;
       in[s.top()]=false;s.pop();     
     }
     nod[s.top()]=num;size[num]++;in[s.top()]=false;s.pop();
  }
}
bool cmp(ding2 t1,ding2 t2)
{
  return (t1.lef==t2.lef?t1.righ<t2.righ:t1.lef<t2.lef);
}
int main()
{
  //freopen("semi5.in","r",stdin);
  //freopen("haha.out","w",stdout);
  scanf("%d%d%lld",&n,&m,&mo);
  int x,y;
  for (int i=1;i<=m;i++)
  {
      scanf("%d%d",&x,&y);
      bia[i].lef=x;bia[i].righ=y;
      g[x].push_back(y);
  }
  num=0;
//缩点
  for (int i=1;i<=n;i++) if (dfn[i]==0) tarjan(i);
  for (int i=1;i<=m;i++) 
  {
   bia[i].lef=nod[bia[i].lef];
   bia[i].righ=nod[bia[i].righ];
  }
  sort(bia+1,bia+1+m,cmp);
//去重边
  int lastx=0,lasty=0;
  for (int i=1;i<=m;i++)
  {
   int p1=bia[i].lef,p2=bia[i].righ;
   if ((p1!=p2)&&
   (!((p1==lastx)&&(p2==lasty))))
   {add(p1,p2); ru[p2]++;}
   lastx=p1;lasty=p2;
  }
  for (int i=1;i<=num;i++)
  if (ru[i]==0) q.push(i),side[i]=size[i],dp[i]=1;
//dp
  tuopu();
  for (int i=1;i<=num;i++)
  if (side[i]==ans) ans2=(ans2+dp[i])%mo;
//枚举哪些点是链的终点来统计答案
  printf("%d\n%lld\n",ans,ans2);
  return 0;
}

```

---

## 作者：Strong_Jelly (赞：4)

此blog参考@ So_what 巨佬的题解 orz

### 给52分的前排提醒：

@ xiaofulll 巨佬提醒您：记得在Tarjan后去重边，否则方案数会最长链的数量会受到影响

### 题意简化（~~这题的题面太毒瘤了~~）：

给定一个图，求这个图的最长链所包含的节点个数以及最长链的个数

### 思路：

我们先用Tarjan把图进行缩点（及把能够互相到达的一个子图缩成一个点，并记录当前强连通分量的节点数，这样不会对结果进行影响，当搜到这个强连通分量时，我们只需要把当前强连通分量的节点数加上就好了），然后我们对这个缩过点的图重新进行建边（注意：重新建完图后，可能会有重边，需要判重，否则最后最长链的数量会受到影响），最后我们拓扑加dp把最长链的节点的数量和最长链的数量求出，定义dis[i]表示从第i个点开始到达任意点的最长链的节点的个数，cnt[i]表示从i开始可以到达的最长链的数量，并且记录最长链的节点个数。最后枚举1 ~ n，如果dis[i] == 最长链的节点的个数，那么ans就加上当前点可以到达的最长链的数量，并且%MOD，最后先输出最长链的节点的个数，再输出ans。（如何拓扑 + dp在代码中讲）

### 全文 + 代码： 

https://www.cnblogs.com/qqq1112/p/11625728.html

---

## 作者：ivyjiao (赞：2)

算法：Kosaraju。

本文假设你会缩点。

先大力缩点，然后初始化 $dp$ 数组，本文中 $dp_i$ 表示到第 $i$ 个强连通分量时最大半连通子图拥有的节点数，初始值 $dp_i=sz_i$，其中 $sz_i$ 表示第 $i$ 个强连通分量的节点数，$ans_i$ 表示不同的最大半连通子图的数目，初始值 $ans_i=1$。

由于此时图已经是个 DAG 了，所以我们直接大力 DP，DP 式子显然如下（一个很经典的 trick）：

$$
dp_v=
\left\{\begin{matrix}
dp_u+sz_v & dp_v<dp_u+sz_v\\ 
dp_v & dp_v\geq dp_u+sz_v\\
\end{matrix}\right.
$$

$$
ans_v=
\left\{\begin{matrix}
ans_u & dp_v<dp_u+sz_v\\ 
ans_u+ans_v & dp_v=dp_u+sz_v\\
ans_v & dp_v>dp_u+sz_v\\
\end{matrix}\right.
$$

最后就是简单的统计答案环节了。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,p,u,v,sz[100001],col[100001],cnt,dp[100001],ans[100001],ans1,ans2;
vector<int>G[100001],H[100001],I[100001],s;
bool vis[100001],vis2[100001];
void dfs1(int u){
    vis[u]=1;
    for(int i=0;i<G[u].size();i++) if(!vis[G[u][i]]) dfs1(G[u][i]);
    s.push_back(u);
}
void dfs2(int u){
    col[u]=cnt;
    sz[col[u]]++;
    for(int i=0;i<H[u].size();i++) if(!col[H[u][i]]) dfs2(H[u][i]);
}
void kosaraju(){
    for(int i=1;i<=n;i++) if(!vis[i]) dfs1(i);
    for(int i=s.size()-1;i>=0;i--){
        if(!col[s[i]]){
            cnt++;
            dfs2(s[i]);
        }
    }
}
int main(){
    cin>>n>>m>>p;
    for(int i=1;i<=m;i++){
        cin>>u>>v;
        G[u].push_back(v);
        H[v].push_back(u);
    }
    kosaraju();
    for(int i=1;i<=cnt;i++){
        dp[i]=sz[i];
        ans[i]=1;
    }
    for(int i=1;i<=n;i++){
        for(int j=0;j<G[i].size();j++){
            if(col[i]!=col[G[i][j]]) I[col[i]].push_back(col[G[i][j]]);
        }
    }
    for(int i=1;i<=cnt;i++){
        memset(vis2,0,sizeof vis2);
        for(int j=0;j<I[i].size();j++){
            if(vis2[I[i][j]]) continue;
            vis2[I[i][j]]=1;
			if(dp[I[i][j]]<dp[i]+sz[I[i][j]]){
				dp[I[i][j]]=dp[i]+sz[I[i][j]];
				ans[I[i][j]]=ans[i];
			}
            else if(dp[I[i][j]]==dp[i]+sz[I[i][j]]){
				ans[I[i][j]]+=ans[i];
				ans[I[i][j]]%=p;
			}
        }
    }
	for(int i=1;i<=cnt;i++){
		if(ans1<dp[i]){
			ans1=dp[i];
			ans2=ans[i];
		}
        else if(dp[i]==ans1){
			ans2+=ans[i];
			ans2%=p;
		}
	}
    cout<<ans1<<endl<<ans2;
}
```

---

## 作者：Karnage (赞：2)

# [【ZJOI2007】最大半联通子图](https://www.luogu.org/problemnew/show/P2272)

**~~题意不作过多解释~~**

## $Solution$

首先，一个显然的事实是，无向图$G$中的每一个强连通分量为一个半联通子图。

其次，无向图$G$中的每一条链为一个半联通子图。

考虑将$G$缩点， 在缩点后的$DAG$中跑$DP$，本题就切完了。

**一些注意点：**

$1.$跑$DP$时要先拓扑排序，~~这点应该不用说吧。~~

$2.$在缩点后一定要记得**去重!!!** 否则会答案可能会统计多次。

## $Code$

```cpp
#include <cstdio>
#include <algorithm>
#include <queue>

inline int read() {
    int x = 0; char c = getchar();
    for (; c < 48 || c > 57; c = getchar());
    for (; c >= 48 && c <= 57; c = getchar()) x = (x + (x << 2) << 1) + (c ^ 48);
    return x;
}

const int N = 1e5 + 5, M = 1e6 + 5;
int n, m, Mod, num, head[N], top, st[N], tim, dfn[N], low[N], bel[N];
int cnt, Num, Head[N], size[N], du[N], f[N], g[N], ans1, ans2;
bool ins[N], vis[N];
std::queue <int> q;
struct edge {
    int nxt, to;
} e[M], ed[M];

struct Edge {
    int u, v;
    inline bool operator < (const Edge tmp) const {
        return u == tmp.u ? v < tmp.v : u < tmp.u;
    }
} Ed[M];

inline void add(int u, int v) {
    e[++num].nxt = head[u], e[num].to = v, head[u] = num;
}

inline void Add(int u, int v) {
    ed[++num].nxt = Head[u], ed[num].to = v, Head[u] = num;
}

void tarjan(int u) {
    low[u] = dfn[u] = ++tim, st[++top] = u, ins[u] = 1;
    for (int i = head[u], v; i; i = e[i].nxt)
        if (!dfn[v = e[i].to]) tarjan(v), low[u] = std::min(low[u], low[v]);
        else if (ins[v]) low[u] = std::min(low[u], dfn[v]);
    if (dfn[u] == low[u]) {
        int v; ++cnt;
        do {
            v = st[top--];
            bel[v] = cnt, ins[v] = 0;
            ++size[cnt];
        } while (u != v);
    }
}

int main() {
    n = read(), m = read(), Mod = read();
    for (int i = 1; i <= m; ++i) {
        int u = read(), v = read();
        add(u, v);
    }
    for (int i = 1; i <= n; ++i) if (!dfn[i]) tarjan(i);
    for (int u = 1; u <= n; ++u)
        for (int i = head[u], v; i; i = e[i].nxt)
            if (bel[u] != bel[v = e[i].to]) Ed[++Num] = (Edge) {bel[u], bel[v]};
    std::sort(Ed + 1, Ed + 1 + Num), num = 0;
    for (int i = 1; i <= Num; ++i) {
        while (Ed[i].u == Ed[i + 1].u && Ed[i].v == Ed[i + 1].v) ++i;
        Add(Ed[i].u, Ed[i].v), ++du[Ed[i].v];
    }
    for (int i = 1; i <= cnt; ++i) {
        f[i] = size[i], g[i] = 1;
        if (!du[i]) q.push(i);
    }
    while (!q.empty()) {
        int u = q.front(); q.pop();
        // printf("%d ", u);
        for (int i = Head[u], v; i; i = ed[i].nxt)
            if (du[v = ed[i].to]) {
                if (f[v] < f[u] + size[v]) {
                    f[v] = f[u] + size[v];
                    g[v] = g[u];
                } else if (f[v] == f[u] + size[v]) (g[v] += g[u]) %= Mod;
                if (!--du[v]) q.push(v);
            }
    }
    for (int i = 1; i <= cnt; ++i)
        if (f[i] > ans1) ans1 = f[i], ans2 = g[i];
        else if (f[i] == ans1) (ans2 += g[i]) %= Mod;
    printf("%d\n%d\n", ans1, ans2);
    return 0;
}
```

---

## 作者：GKxx (赞：2)

为什么没有人用记忆化搜索呢。。。

一开始Tarjan缩点肯定是要的。注意到半连通的意思是只要这个子图里的任意点对(i, j)满足i可以到达j或者j可以到达i即可，因此一个尽可能大的半连通子图里一定会包含一个强连通分量没有什么问题。然后我们考虑在强连通分量S的基础上扩大这个半连通子图，如图

![luogu](https://cdn.luogu.com.cn/upload/pic/30810.png)

很明显，选择XYS是不行的，因为X中的点和Y中的点不可达，不构成半连通子图。同理GKS也不行。但是像XSK这样就可以保证其中的点可达了，从而构成半连通子图。

于是我们的算法基本上可以确定：先Tarjan缩点，得到新图（一定是DAG），新图的点有点权，就等于它代表的强连通分量中的点的个数。然后设f[x]表示以x为起点的点权之和最大的路径，g[x]表示这样的路径的条数，可以很容易地用记忆化搜索实现。

~~（其实是因为我比较懒不想拓扑排序）~~

```cpp
// C++11
#include <cctype>
#include <cstdio>
#include <climits>
#include <algorithm>
#include <stack>

template <typename T> inline void read(T& t) {
    int f = 0, c = getchar(); t = 0;
    while (!isdigit(c)) f |= c == '-', c = getchar();
    while (isdigit(c)) t = t * 10 + c - 48, c = getchar();
    if (f) t = -t;
}
template <typename T, typename... Args>
inline void read(T& t, Args&... args) {
    read(t); read(args...);
}

#define rep(I, A, B) for (int I = (A); I <= (B); ++I)
#define rrep(I, A, B) for (int I = (A); I >= (B); --I)

const int maxn = 1e5 + 100;
const int maxm = 1e6 + 100;
int head[maxn], sccno[maxn], low[maxn], pre[maxn];
int v[maxm], next[maxm];
int n, m, mod, tot = -1;
int scccnt, dfsClock;
std::stack<int> s;

inline void ae(int x, int y) {
    v[++tot] = y;
    next[tot] = head[x];
    head[x] = tot;
}
void dfs1(int x) {
    pre[x] = low[x] = ++dfsClock;
    s.push(x);
    for (int i = head[x]; ~i; i = next[i]) {
        if (!pre[v[i]]) {
            dfs1(v[i]);
            low[x] = std::min(low[x], low[v[i]]);
        } else if(!sccno[v[i]])
            low[x] = std::min(low[x], pre[v[i]]);
    }
    if (low[x] == pre[x]) {
        ++scccnt;
        while (0207) {
            int t = s.top();
            s.pop();
            sccno[t] = scccnt;
            if (t == x)
                return;
        }
    }
}
inline void findScc() {
    rep(i, 1, n) if (!pre[i]) dfs1(i);
}

int head2[maxn], f[maxn], g[maxn], value[maxn];
int v2[maxm], next2[maxm];
bool vis[maxn];

inline void ae2(int x, int y) {
    v2[++tot] = y;
    next2[tot] = head2[x];
    head2[x] = tot;
}
inline void rebuild() {
    tot = -1;
    rep(i, 1, scccnt) head2[i] = -1;
    rep(i, 1, n)++ value[sccno[i]];
    rep(i, 1, n) for (int j = head[i]; ~j; j = next[j]) if (sccno[i] != sccno[v[j]])
        ae2(sccno[i], sccno[v[j]]);
}
void dfs2(int x) {
    if (vis[x]) return;
    vis[x] = 1;
    f[x] = value[x];
    g[x] = 1;
    bool meet[maxn] = {0};
    for (int i = head2[x]; ~i; i = next2[i]) 
        if (!meet[v2[i]]) {
            meet[v2[i]] = 1;
            dfs2(v2[i]);
            if (f[v2[i]] + value[x] > f[x]) {
                f[x] = f[v2[i]] + value[x];
                g[x] = g[v2[i]];
            } else if (f[v2[i]] + value[x] == f[x]) {
                (g[x] += g[v2[i]]) %= mod;
            }
        }
}

int main() {
    read(n, m, mod);
    rep(i, 1, n) head[i] = -1;
    rep(i, 1, m) {
        int x, y;
        read(x, y);
        ae(x, y);
    }
    findScc();
    rebuild();
    rep(i, 1, scccnt) if (!vis[i]) dfs2(i);
    int ans = 0, maxval = INT_MIN;
    rep(i, 1, scccnt) if (f[i] > maxval) maxval = f[i];
    rep(i, 1, scccnt) if (f[i] == maxval) ans = (ans + g[i]) % mod;
    printf("%d\n%d\n", maxval, ans);
    return 0;
}
```

---

## 作者：swiftc (赞：1)

__排版哪里有问题啊QAQ__

根据题意，一个强连通分量一定是半联通子图，所以多个强联通分量也一定是半联通子图，所以问题就转化成了在一个缩点后的图上找最长链，步骤如下：

### 1.缩点

先用tarjan记录每一个强联通分量的大小和每个点在哪个强连通分量里
```cpp
void tarjan(int now){
	if(vis[now])return;
	dfn[now]=low[now]=++Time;
	tmp.push(now);
	vis[now]=1;
	for(int i=head[now];i;i=nxt[i]){
		if(!dfn[to[i]]){
			tarjan(to[i]);
			low[now]=min(low[now],low[to[i]]);
		}else if(vis[to[i]]){
			low[now]=min(low[now],dfn[to[i]]);
		}
	}
	if(low[now]==dfn[now]){
		_cnt++;
		while(tmp.top()!=now){
			vis[tmp.top()]=0;
			in[tmp.top()]=_cnt;
			siz[_cnt]++;
			tmp.pop();
		}
		tmp.pop();
		vis[now]=0;
		in[now]=_cnt;
		siz[_cnt]++;
	}
}
```

如果有两个有边连接的点不在一个强连通分量里，那么这两个强连通分量之间就有边，我这里直接把缩点后的图新建在另一个前向星里了，注意要去重，即不能在两个强连通分量间建多条边。
```cpp
for(int i=1;i<=n;i++){
	for(int j=head[i];j;j=nxt[j]){
			if(in[i]!=in[to[j]]){
			bool flag=0;
			for(int ii=_head[in[i]];ii;ii=_nxt[ii]){
			if(_to[ii]==in[to[j]])flag=1;
			}
			if(flag)continue;
			_nxt[++__cnt]=_head[in[i]];
			_head[in[i]]=__cnt;
			_to[__cnt]=in[to[j]];
			du[in[to[j]]]++;
		}
	}
}
```

### 2.求最长链

最后用拓扑排序来DP求最长链：先把入度为0的强连通分量放入队列，每次取出第一个开始更新，```num[i]```表示以i为结尾的最长链有几个```ans[i]```表示最长链的长度，更新时如果可以让以这个点结尾的链变得更长,就把```num[i]```设为1，更新```ans[i]```,如果又发现一条和以这个点结尾最长链一样长的链，就把```num[i]+=1```，最后找最大值即可

```cpp
queue<int>q;
	for(int i=1;i<=_cnt;i++){
		if(du[i]==0)q.push(i);
		ans[i]=siz[i];
		num[i]=1;
	}
	while(!q.empty()){
		int now=q.front();
		q.pop();
		for(int i=_head[now];i;i=_nxt[i]){
			if(ans[_to[i]]<ans[now]+siz[_to[i]]){
				ans[_to[i]]=ans[now]+siz[_to[i]];
				num[_to[i]]=num[now];
			}
			else if(ans[_to[i]]==ans[now]+siz[_to[i]]){
				num[_to[i]]=(num[now]%x+num[_to[i]]%x)%x;
			}
			du[_to[i]]--;
			if(du[_to[i]]==0){
				q.push(_to[i]);
			}
		}
	}
```


完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int du[3000001],head[3000001],nxt[3000001],to[3000001],dfn[3000001],low[3000001],vis[3000001],in[3000001],siz[3000001];
int n,m,x,cnt,Time,_cnt,__cnt;
stack<int>tmp;
void tarjan(int now){
	if(vis[now])return;
	dfn[now]=low[now]=++Time;
	tmp.push(now);
	vis[now]=1;
	for(int i=head[now];i;i=nxt[i]){
		if(!dfn[to[i]]){
			tarjan(to[i]);
			low[now]=min(low[now],low[to[i]]);
		}else if(vis[to[i]]){
			low[now]=min(low[now],dfn[to[i]]);
		}
	}
	if(low[now]==dfn[now]){
		_cnt++;
		while(tmp.top()!=now){
			vis[tmp.top()]=0;
			in[tmp.top()]=_cnt;
			siz[_cnt]++;
			tmp.pop();
		}
		tmp.pop();
		vis[now]=0;
		in[now]=_cnt;
		siz[_cnt]++;
	}
}
int _head[3000001],_nxt[3000001],_to[3000001],ans[3000001],num[3000001];
int maxn=-1,id;
int main(){
	scanf("%d%d%d",&n,&m,&x);
	for(int i=1;i<=m;i++){
		int a,b;
		scanf("%d%d",&a,&b);
		nxt[++cnt]=head[a];
		head[a]=cnt;
		to[cnt]=b;
	}
	for(int i=1;i<=n;i++){
		if(!dfn[i])tarjan(i);
	}
	for(int i=1;i<=n;i++){
		for(int j=head[i];j;j=nxt[j]){
			if(in[i]!=in[to[j]]){
				bool flag=0;
				for(int ii=_head[in[i]];ii;ii=_nxt[ii]){
					if(_to[ii]==in[to[j]])flag=1;
				}
				if(flag)continue;
				_nxt[++__cnt]=_head[in[i]];
				_head[in[i]]=__cnt;
				_to[__cnt]=in[to[j]];
				du[in[to[j]]]++;
			}
		}
	}
	queue<int>q;
	for(int i=1;i<=_cnt;i++){
		if(du[i]==0)q.push(i);
		ans[i]=siz[i];
		num[i]=1;
	}
	while(!q.empty()){
		int now=q.front();
		q.pop();
		for(int i=_head[now];i;i=_nxt[i]){
			if(ans[_to[i]]<ans[now]+siz[_to[i]]){
				ans[_to[i]]=ans[now]+siz[_to[i]];
				num[_to[i]]=num[now];
			}
			else if(ans[_to[i]]==ans[now]+siz[_to[i]]){
				num[_to[i]]=(num[now]%x+num[_to[i]]%x)%x;
			}
			du[_to[i]]--;
			if(du[_to[i]]==0){
				q.push(_to[i]);
			}
		}
	}
	int maxn1=-1,maxn2=-1;
	for(int i=1;i<=_cnt;i++){
		if(ans[i]>maxn1){
			maxn1=ans[i];
			maxn2=num[i];
		}
		else if(ans[i]==maxn1){
			maxn2=(maxn2%x+num[i]%x)%x;
		}
	}
	printf("%d\n%d\n",maxn1,maxn2);
	return 0;
}
```


---

## 作者：Frostnova (赞：1)

## 先放一个题目链接 [P2272](https://www.luogu.org/problemnew/show/P2272)


样例：
![](https://cdn.luogu.com.cn/upload/pic/59899.png)

最开始的时候没有考虑到有环的时候，他可以连续跑，就没有进行缩点，结果就只能$ A $第二个点

后来$ wa $掉以后发现如果有环的时候不进行缩点的话，由于两个不相同的半联通子图满足他们至少有一个点不相同。

这样的话我们就必须缩点了，我们先$ tarjan $求强连通分量，然后在进行缩点，对跑出来的新图进行拓扑排序，然后在拓扑排序里面加$ dp $。

```cpp
void tarjan(int u) {
    low[u] = dfn[u] = ++tim;
    st[++top] = u;
    ins[u] = 1;
    for (int i = fte[u], v; i; i = edge[i].next) {
        if (!dfn[v = edge[i].to]) {
            tarjan(v);
            low[u] = min(low[u], low[v]);
        }
        else if (ins[v]) {
            low[u] = min(low[u], dfn[v]);
        }
    }
    if (dfn[u] == low[u]) {
        int v; 
        ++cnt;
        while (u != v) {
            v = st[top--];
            bel[v] = cnt;
            ins[v] = 0;
            ++size[cnt];
        }
    }
}
```


我们先考虑一个问题：在$ tarjan $缩完点以后我们在建新图的时候一定会建出重边来，但是我们要进行拓扑排序的话就不可以有重边，所以我们要在进行缩点后建图的时候一定要判断这条边是否是重边，我们用一个$ map $数组来判断。

然后我们在拓扑排序里面跑$ dp $，为什么要用拓扑排序$ ?? $因为通拓扑排序可以很容易的找出最长链。

怎么$ dp ?? $ 我们在第一部找出它的最大半联通子图的时候，其实找的就是最长链，我们把它最长链里面的权值进行合并就行。

我们用一个$ ans $记录到达当前点的最大权值，用v表示当前节点，用x表示与v连通那个点。

由于我们有好几条路径可以到达$ v $点，而我们要统计的是最大的半连通子图的大小，所以我们在对当前点更新的时候则为$ ans[v] = max(ans[v], ans[x]) $为什么是这样$ ?? $

因为我们对于每一条链的$ ans[x] $是一直在更新的。

这样我们就可以把最大的半联通子图统计出来。 $ ans1 = max（ans1, ans[i]）$ 。

其次我们还要统计方案数。

我们用数组$ dp $记录到当前点的方案数，用数组$ du $记录到当前点的子图的大小， 然后我们判断这个点的deep值是否等于他父节点的$ du $值，如果相等的话就说明出现了另一种方案数，那么$ dp[t] = dp[t] + dp[x] $

如果当前点的$ du $小与其父节点的$ du $那么我们对其$ dp $进行修改，$ dp[t] = dp[x], du[t] = du[x] $

```cpp
#include <bits/stdc++.h>
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define _FOR(i, a, b) for(int i = a; i >= b; i--)
using namespace std;
const int NR = 2e5, MR = 2e6;
int n, m, Mod, gsz, fte[NR];
int top, st[NR], tim, dfn[NR], low[NR], bel[NR];
int cnt, Num, FTE[NR], size[NR], du[NR], f[NR], g[NR], ans1, ans2;
bool ins[NR], vis[NR];
queue <int> q;
struct EDGE {
    int to, next;
} edge[MR], Edge[MR];

struct node {
    int u, v;
    inline bool operator < (const node tmp) const {
        return u == tmp.u ? v < tmp.v : u < tmp.u;
    }
} NODE[MR];

void addedge(int u, int v) {
    edge[++gsz].next = fte[u], edge[gsz].to = v, fte[u] = gsz;
}

void Addedge(int u, int v) {
    Edge[++gsz].next = FTE[u], Edge[gsz].to = v, FTE[u] = gsz;
}

void tarjan(int u) {
    low[u] = dfn[u] = ++tim;
    st[++top] = u;
    ins[u] = 1;
    for (int i = fte[u], v; i; i = edge[i].next) {
        if (!dfn[v = edge[i].to]) {
            tarjan(v);
            low[u] = min(low[u], low[v]);
        }
        else if (ins[v]) {
            low[u] = min(low[u], dfn[v]);
        }
    }
    if (dfn[u] == low[u]) {
        int v; 
        ++cnt;
        while (u != v) {
            v = st[top--];
            bel[v] = cnt;
            ins[v] = 0;
            ++size[cnt];
        }
    }
}

void tpsort() {
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (int i = FTE[u], v; i; i = Edge[i].next) {
            if (du[v = Edge[i].to]) {
                if (f[v] < f[u] + size[v]) {
                    f[v] = f[u] + size[v];
                    g[v] = g[u];
                } 
                else if (f[v] == f[u] + size[v]) {
                    (g[v] += g[u]) %= Mod;
                }
                if (!--du[v]) {
                    q.push(v);
                }
            }
        }
    }
    FOR(i, 1, cnt) {
        if (f[i] > ans1) {
            ans1 = f[i];
             ans2 = g[i];
        }
        else if (f[i] == ans1) {
            (ans2 += g[i]) %= Mod;
        }
    }
}

int main() {
    cin >> n >> m >> Mod;
    FOR(i, 1, m) {
        int x, y;
        cin >> x >> y;
        addedge(x, y);
    }
    FOR(i, 1, n) {
        if (!dfn[i]) {
            tarjan(i);
        }
    }
    FOR(u, 1, n) {
        for (int i = fte[u], v; i; i = edge[i].next) {
            if (bel[u] != bel[v = edge[i].to]) {
                NODE[++Num] = (node) {bel[u], bel[v]};
            }
        }
    }
    sort(NODE + 1, NODE + 1 + Num);
    gsz = 0;
    FOR(i, 1, Num) {
        while (NODE[i].u == NODE[i + 1].u && NODE[i].v == NODE[i + 1].v) {
            ++i;
        }
        Addedge(NODE[i].u, NODE[i].v);
        ++du[NODE[i].v];
    }
    FOR(i, 1, cnt) {
        f[i] = size[i];
        g[i] = 1;
        if (!du[i]) {
            q.push(i);
        }
    }
    tpsort();
    cout << ans1 << endl << ans2;
}
```

附上[缩点板子题](https://www.luogu.org/problemnew/show/P3387)



---

## 作者：非凡 (赞：1)

首先假如这是个DAG，那么就只要求出图中最长链和最长链个数就行了。
所以先用tarjan缩点，然后把重边去掉，求最长链用拓扑排序即可。

最长链个数需要DP，设 f [ i ]表示图中以 i 为终点的最长链个数，则 f [ i ] 等于与 i 连通并且距离是起点到 i 的最长距离的点的 f 值之和。
附上代码：
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int n,m,mx,x[1000001],y[1000001],fir[100001],nex[1000001],ft[100001],inx[100001];
int to[1000001],kt,las[100001],ru[1000001],ins[100001],h,t,ans,f[100001],res;
int DFN[100001],low[100001],st[100001],cn[100001],top,ex,cnt,rst[100001],u;
inline int read(){
	int x=0;char c;
	for(c=getchar();c<'0'||c>'9';c=getchar());
	while(c>='0'&&c<='9')x=x*10+c-'0',c=getchar();
	return x;
}//读入优化
void add(int x,int y){
	kt++;nex[kt]=fir[x];
	fir[x]=kt;to[kt]=y;
}
void tarjan(int x){int v;
	DFN[x]=low[x]=++ex;st[++top]=x;
	for(int p=fir[x];p;p=nex[p]){
		if(!DFN[to[p]]){
			tarjan(to[p]);
			low[x]=min(low[x],low[to[p]]);
		}
		else if(!cn[to[p]])low[x]=min(low[x],DFN[to[p]]);
	}
	if(low[x]==DFN[x]){
		cn[x]=++cnt;ins[cnt]++;
		while(st[top]!=x)cn[st[top]]=cnt,top--,ins[cnt]++;
		top--;
	}
}//ins是强连通分量的大小
bool cmp(int a,int b){if(x[a]!=x[b])return x[a]<x[b];return y[a]<y[b];}
int main(){
	n=read();m=read();mx=read();
	for(int i=1;i<=m;i++)x[i]=read(),y[i]=read(),add(x[i],y[i]);
	for(int i=1;i<=n;i++)if(!DFN[i])tarjan(i);
	for(int i=1;i<=m;i++)ru[i]=i,x[i]=cn[x[i]],y[i]=cn[y[i]];
	sort(ru+1,ru+1+m,cmp);kt=0;memset(fir,0,sizeof(fir));
	for(int i=1;i<=m;i++){
		if((x[ru[i]]!=y[ru[i]])&&(x[ru[i]]!=x[ru[i-1]]||y[ru[i]]!=y[ru[i-1]])){
			ft[y[ru[i]]]++;
			add(x[ru[i]],y[ru[i]]);
		}
	}//以上是去重边，构新图
	for(int i=1;i<=cnt;i++)
	if(!ft[i]){
		rst[++t]=i;f[i]=ins[i];
		inx[i]=1;if(f[ans]<f[i])ans=i;
	}
	while(h<t){
		h++;u=rst[h];
		for(int p=fir[u];p;p=nex[p]){
			ft[to[p]]--;
			if(f[to[p]]<f[u]+ins[to[p]]){
				f[to[p]]=f[u]+ins[to[p]];
				inx[to[p]]=0;if(f[ans]<f[to[p]])ans=to[p];
			}
			if(f[to[p]]==f[u]+ins[to[p]])
			inx[to[p]]=(inx[to[p]]+inx[u])%mx;
			if(!ft[to[p]])rst[++t]=to[p];
		}
	}//拓扑，我用的是队列
	for(int i=1;i<=n;i++)
	if(f[i]==f[ans])res=(res+inx[i])%mx;
	printf("%d\n%d",f[ans],res);return 0;
}
```

---

## 作者：Mosher (赞：0)

### 前景提示空间要开大开大开大

**正文：**

1. 思路：当你读完题后，语文不错的话，就能想到，题意就是求个最长链，且相同的有几条。（语文不好，多读几遍）

2. 算法：tarjan缩点+拓扑排序+bfs

3. 注意：此题有重边，虽然不影响缩点，找出的最长链，但会影响路径统计
	
	处理方式：1.map直接判断，是否连边，来去重 2. 排序去重 3.离散化去重
    
    这三种都行，本人比较懒，所以用map（不过要开O2）
    
4. 重点：bfs的处理，写在代码中

**Code:**
```cpp
#include<bits/stdc++.h>
using namespace std;
#define il inline
const int maxn=1e6+5;
const int maxm=5e6+5;
map<pair<int,int>,bool>mapp;//第一关键字，处理为pair，方便去重
queue<int>q;
int dfn[maxn],low[maxn],dfs_clock,size,tot,head[maxn],n,m,col[maxn],dp[maxn],mod,sz[maxn],x[maxn],y[maxn],rd[maxn],dis[maxn],cnt[maxn],ans_id,ans;
struct node{
	int v,nxt;
}e[maxm];

il int read(){
	int x=0;char a=getchar();
	while(!isdigit(a)) a=getchar();
	while(isdigit(a)) {x=x*10+a-'0';a=getchar();}
	return x;
}

il void add(int u,int v){
	e[++size].v=v;
	e[size].nxt=head[u];
	head[u]=size;
}

stack<int>s;
void tarjan(int u){//常规缩点
	s.push(u);
	dfn[u]=low[u]=++dfs_clock;
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].v;
		if(!dfn[v]){
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}
		else if(!col[v]) low[u]=min(low[u],dfn[v]);
	}
	if(dfn[u]==low[u]){
		int k;++tot;
		do{
			k=s.top();s.pop();
			col[k]=tot;
			sz[tot]++;
		}while(k!=u);
	}
}

il void clear(){
	size=0;
	memset(e,0,sizeof(e));
	memset(head,0,sizeof(head));
}

il void build(){
	for(int i=1;i<=m;++i){
		int nx=col[x[i]],ny=col[y[i]];
		if(nx!=ny&&!mapp[make_pair(nx,ny)]){//map去重，未连边就连起来
			rd[ny]++;//统计入度，为拓扑排序准备
			mapp[make_pair(nx,ny)]=1;
			add(nx,ny);
		}
	}
}

void bfs(){
	while(!q.empty()){
		int u=q.front();q.pop();//取出队列前端
		for(int i=head[u];i;i=e[i].nxt){
			int v=e[i].v;
			--rd[v];//使用，就--,以免多次统计
			if(dis[v]<dis[u]+sz[v]){//若被更新最长
				dis[v]=dis[u]+sz[v];
				cnt[v]=0;//路径数重新计算,清0的话，是因为下方累加
				if(dis[ans_id]<dis[v]) ans_id=v;//下标更新
			}
			if(dis[v]==dis[u]+sz[v]) cnt[v]=(cnt[v]+cnt[u])%mod;//累加
			if(!rd[v]) q.push(v);//继承着跑
		}
	}
}

int main(){
	freopen("semi5.in","r",stdin);
	n=read();m=read();mod=read();
	for(int i=1;i<=m;++i){
		x[i]=read();y[i]=read();
		add(x[i],y[i]);//存下来，二次利用
	}
	for(int i=1;i<=n;++i) if(!dfn[i]) tarjan(i);
	clear();
	build();
	for(int i=1;i<=tot;++i){
		if(!rd[i]){//从入度为0点，所跑出的最长链，一定比不从其跑的长，好好想想
			q.push(i);//放入队列
			dis[i]=sz[i];//更新
			cnt[i]=1;
			if(dis[ans_id]<dis[i]) ans_id=i;
		}
	}
	bfs();
	for(int i=1;i<=n;++i)
		if(dis[i]==dis[ans_id]) ans=(ans+cnt[i])%mod;
	printf("%d\n%d",dis[ans_id],ans);
}
```

rp++

---

## 作者：凌乱 (赞：0)

**大概题意：** 一个图(可能有环)，求其最大半联通子图的的个数以及次点数的半联通子图的个数

**前提：** 我们需要先知道什么是半联通，半联通与强联通类似，只不过强联通需要两点相互到达，而半联通只需要其中一个点能到另一个点就行了

**思路：** 其实半联通图就是一条链(可以性感的理解一下)，当然一个强联通也肯定是半联通(比如 环)，所以我们需要先缩一下点，那么我们得到了一个DAG(有向无环图)，然后就是我们都很擅长的拓扑dp了，注意缩完点后，会有大量重边(比如 这个：)

![](https://cdn.luogu.com.cn/upload/pic/67206.png)

**至于dp的合理性：** 因为我们要在DAG里找链嘛，那么我们dp的路径其实也是一条链，所以就dp啦

**主要步骤：** 1.缩点 2.去重边 3.拓扑dp

**上代码：**
```cpp
# include <iostream>
# include <cstdio>
# include <cstring>
# include <queue>
# include <stack>
# include <algorithm>
# define FOR(i,st,ed) for(int i=st;i<=ed;++i)
# define _FOR(u) for(int v,i=hd[u];i;i=e[i].nt)
# define _V v=e[i].to
using namespace std;
int re(){
	int s=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch)){s=(s<<1)+(s<<3)+ch-'0';ch=getchar();}
	return s*f;
}
const int N=1e5+7;
const int M=1e6+7;
int n,m,mod;
struct edge{
	int to,nt;
}e[M];int hd[N],cnt;
void add_e(int x,int y){
	e[++cnt]=(edge){y,hd[x]};hd[x]=cnt;
}

struct mkt{
	int x,y;
	bool operator < (const mkt&mk) const{return x<mk.x || x==mk.x&&y<mk.y;}
}a[M],b[M];


------------
//下面是缩点模板
int dfn[N],dji,low[N];
stack <int> s;int c[N],cji,cn[N];
void tarjan(int u){
	dfn[u]=low[u]=++dji;s.push(u);
	_FOR(u){
		_V;
		if(!dfn[v]){
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}
		else if(!c[v]) low[u]=min(low[u],dfn[v]);
	} 
	if(dfn[u]==low[u]){
		int p;cji++;
		do{
			p=s.top();s.pop();
			c[p]=cji;cn[cji]++;
		}while(p!=u);
	}
}


------------
//拓扑dp
int ru[N];
int dp[N],sum[N];
queue <int> q;
void tpdp(){
	//FOR(i,1,cji) ;
	FOR(i,1,cji) if(!ru[i]) q.push(i),dp[i]=cn[i],sum[i]=1;
	while(q.size()){
		int u=q.front();q.pop();
		_FOR(u){
			_V;
			if(dp[v]<dp[u]+cn[v]) dp[v]=dp[u]+cn[v],sum[v]=sum[u];
			else if(dp[v]==dp[u]+cn[v]) sum[v]+=sum[u],sum[v]%=mod;
			if(!(--ru[v])) q.push(v); 
		}
	}
	int mk=0,k=0;
	FOR(i,1,cji){
		if(dp[i]>dp[mk]) mk=i,k=sum[i];
		else if(dp[i]==dp[mk]) k+=sum[i],k%=mod;
	}
	cout<<dp[mk]<<endl<<k;
	//FOR(i,1,n) cout<<dp[i]<<' '<<sum[i]<<endl;
	//cout<<endl<<dp[c[1]]<<' '<<sum[c[1]];
}
int main(){
	n=re();m=re();mod=re();
	FOR(i,1,m){
		add_e(a[i].x=re(),a[i].y=re());
	}
	FOR(i,1,n) if(!dfn[i]) tarjan(i);
	//下面是离散化 去重
	memset(e,0,sizeof(e));cnt=0;memset(hd,0,sizeof(hd));
	int k=0;
	FOR(i,1,m){
		int x=a[i].x,y=a[i].y;
		if(c[x]!=c[y]){
			b[++k].x=c[x];b[k].y=c[y];
		}
	}
	sort(b+1,b+k+1);
	FOR(i,1,k){
		int x=b[i].x,y=b[i].y;
		if(x==b[i-1].x&&y==b[i-1].y) continue;
		add_e(x,y);ru[y]++;
	}
	tpdp();
	return 0;
}
```


---


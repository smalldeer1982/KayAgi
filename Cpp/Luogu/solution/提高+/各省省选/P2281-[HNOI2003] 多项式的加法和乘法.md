# [HNOI2003] 多项式的加法和乘法

## 题目描述

今天的数学课上，老师讲了多项式的加法和乘法。然后布置了很多计算题，小明不想花太多时间来做数学作业，于是想编写一个程序来完成这个任务。

比如计算下面两个多项式的和与积：

$xy^2z+31wx^3y^3z^{50}+s^3$  
$v^2+s^3+3wx^3y^3$

假定所有变量都是单个大写字符，所有的系数和指数都是常数，且都是整数。

我们用 `X^3` 表示 $X$ 的三次方，在系数和不同的项之间用空格分隔，例如 `X Y^2` 中，$X$ 和 $Y$ 之间有空格。下面是两个多项式的例子，除此之外没有别的空格。

`X Y^2 Z + 31 W X^3 Y^3 Z^50 + S^3`  
`V^2 + S^3 + 3 W X^3 Y^3`

现在，按照上面的格式给定两个多项式，请你求出这两个多项式的和与积。

## 样例 #1

### 输入

```
A + B
3 A + 4 A B^3 + C
```

### 输出

```
C+B+4A+4AB^3
BC+AC+3AB+4AB^4+3A^2+4A^2B^3
```

# 题解

## 作者：purinliang (赞：7)

**题解：** 学过面向对象的同学就可以知道，按题目要求设计单项式类和多项式类，定义他们的一系列行为，然后让他们自己自动完成。这样是最省事的。

------------

其中加法乘法以及合并同类项的思路都很简单，在代码的注释里写的很清楚。

重点说一下怎么toString和fromString，这应该是我觉得这道题有提高+的难度的原因。

------------

### toString
首先是toString，我的处理方法是，让单项式每次把自己转成带加减符号的string返回，多项式就调用每个单项式的toString拼接，最后加点特判。

其中有一些需要注意的：
- 当单项式不是常数项时，系数的+1和-1是不输出1的。
- 变量的指数可以是负的。
- 系数为0，不输出。
- 当多项式中没有单项式，输出0。
- 当多项式的开头是+号，则去掉+号。
- 合并同类项，并按题目要求排序。

------------

### fromString
然后是巨坑的fromString，调了一晚上。

其中有一些需要注意的：
- 遇到运算符和数字时可以一直读到第一个字母或者运算符或者字符串尾，这些都属于系数。遇到字母表示后面有指数，否则是常数项。
- 没有遇到数字直接遇到字母/遇到运算符后直接遇到字母，系数是暗含的绝对值1。
- 可能同个单项式中存在重复的字母，例如AGAA表示A^3G，没有试过，可能有。
- 遇到字母后立刻判断下一个是不是^符，若是则可以一直读到第一个字母或者运算符或者字符串尾，这些都属于指数，小心负指数。
- 遇到运算符/字符串末尾要立刻保存当前的单项式。
- 一直读入数字时多加的1要减回来，否则会跳过一个字符。

------------

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

struct Mo {
    //单项式由两个部分组成：带符号的系数+字母和带符号的指数
    ll xs;          //单项式的系数
    ll zs[256];     //单项式的指数

    Mo() {
        xs=0;
        memset(zs,0,sizeof(zs));
    }

    //单项式的小于序，按题目要求，从A到Z，从小到大排序
    bool operator<(Mo &m) {
        for(int i='A'; i<='Z'; i++) {
            if(zs[i]!=m.zs[i]) {
                return zs[i]<m.zs[i];
            } else {
                continue;
            }
        }
        //为确定严格的小于序，规定指数相同的按系数排列
        return xs<m.xs;
    }

    //指示两个单项式能否合并同类项
    bool canMerge(Mo &m) {
        //能够合并，前提是指数都相同
        for(int i='A'; i<='Z'; i++) {
            if(zs[i]!=m.zs[i]) {
                return false;
            } else {
                continue;
            }
        }
        return true;
    }

    //单项式的乘法，系数相乘，对应指数相加
    Mo operator*(Mo &m) {
        Mo ret;
        ret.xs=xs*m.xs;
        for(int i='A'; i<='Z'; i++) {
            ret.zs[i]=zs[i]+m.zs[i];
        }
        return ret;
    }

    //单项式的带符号输出，即使在多项式的开头也输出符号
    string toString() {
        if(xs==0) {
            //多项式不应该有系数为0的单项式，都进入这里了直接RE吧，为0的项在读入和加法的时候应被消除
            exit(-1);
            return "";
        }

        string ans="";
        char tmp[25];   //用来把数字转成字符串

        if(xs>0) {
            //系数为正，加入单项式前的加号
            ans+="+";
            if(xs>1) {
                //非1的系数必须打印
                sprintf(tmp,"%lld",xs);
                ans+=string(tmp);
            }
        } else {
            //负数自带符号，但-1不输出那个1，就单输出一个负号
            if(xs==-1) {
                ans+="-";
            } else {
                //非-1的系数必须打印
                sprintf(tmp,"%lld",xs);
                ans+=string(tmp);
            }
        }

        int nozs=1;     //指示这个多项式是否 没有指数非零

        for(int i='A'; i<='Z'; i++) {
            if(zs[i]!=0) {
                nozs=0; //有指数非零
                //指数非0，输出该字母
                ans+=(char)(i);
                if(zs[i]!=1) {
                    //指数非1，额外输出指数，负数也一样可以输出
                    ans+="^";
                    sprintf(tmp,"%lld",zs[i]);
                    ans+=string(tmp);
                }
            }
        }

        if(nozs) {
            //没有指数非零，这个是常数项
            if(abs(xs)==1)
                //常数项的正负1要输出
                ans+="1";
        }
        return ans;
    }
};

struct Poly {
    //存放单项式的向量
    vector<Mo> v;

    Poly() {}

    //加法，两个多项式的单项式堆在一起，合并同类项
    Poly operator+(Poly p) {
        Poly ret;
        for(auto vi:v) {
            ret.v.push_back(vi);
        }
        for(auto vi:p.v) {
            ret.v.push_back(vi);
        }

        ret.Merge();
        return ret;
    }

    //乘法，二维遍历每个单项式，乘在一起，然后堆在一起合并同类项
    Poly operator*(Poly p) {
        Poly ret;
        for(auto vi:v) {
            for(auto vpi:p.v) {
                ret.v.push_back(vi*vpi);
            }
        }
        ret.Merge();
        return ret;
    }

    //合并同类项并排序
    void Merge() {
        //临时向量vt
        vector<Mo> vt;
        for(auto &vi:v) {
            //遍历现有的每个项，在临时向量中找它已经插入的同类项，若找到可以合并的项，系数相加
            int suc=0;
            for(auto &vti:vt) {
                if(vti.canMerge(vi)) {
                    vti.xs+=vi.xs;
                    suc=1;
                    break;
                }
            }
            if(suc==0) {
                //没有同类项，则接在临时向量的后面
                vt.push_back(vi);
            }
        }

        v.clear();
        //清空原向量
        for(auto vti:vt) {
            //遍历临时向量，去除系数为0的项
            if(vti.xs) {
                v.push_back(vti);
            }
        }
        //排序，按单项式定义的顺序排序
        sort(v.begin(),v.end());
    }

    //返回一整个排序好的多项式，并自动去除最前面的正号
    string toString() {
        //多项式中没有单项式，返回一个0
        if(v.size()==0)
            return "0";
        Merge();   //合并同类项并排序
        string ans="";
        for(auto vi:v)
            ans+=vi.toString();

        //前面已经保证多项式至少有一个单项式，而且它至少会输出一个负号，故可以ans[0]

        //去除开头多余的+号
        if(ans[0]=='+') {
            ans=ans.substr(1,ans.length()-1);
        }

        return ans;
    }

    void fromString(string s) {
        int n=s.length();

        ll xs=0;        //带符号系数
        ll zs[256];     //带符号指数
        memset(zs,0,sizeof(zs));

        for(int i=0; i<=n; i++) {
            if(i==n) {
                //到达字符串结尾，保存最后一个单项式
                addMo(xs,zs);
                return;
            }
            if(s[i]=='+'||s[i]=='-'||isdigit(s[i])) {
                //遇到数字，处理到直到遇到下一个字母或者运算符或者结尾
                //算法的逻辑保证遇到的必定是系数而不是指数

                //保存最后一个单项式
                addMo(xs,zs);

                int flag=1;
                if(!isdigit(s[i])) {
                    //当前遇到的是符号
                    //cerr<<"+"<<endl;
                    if(s[i]=='-')
                        flag=-1;
                    i++;
                    //指向符号的下一个字符
                    if(i==n) {
                        //到达字符串结尾，保存最后一个单项式？
                        //符号后面都没有东西，系数是0，不用添加单项式
                        return;
                    }

                    if(isdigit(s[i])) {
                        //下一个是显式指定的数字，处理到第一个非数字
                        while(isdigit(s[i])) {
                            xs=10ll*xs+(s[i]-'0');
                            i++;
                            if(i==n) {
                                //到达字符串结尾，保存最后一个单项式，也就是常数项，当然要注意符号
                                xs*=flag;
                                addMo(xs,zs);
                                return;
                            }
                        }
                        //现在s[i]是非数字，下次for会i++，这里补偿--
                        i--;
                        //保存符号
                        xs*=flag;
                    } else {
                        //符号后面不是数字，系数是隐含的1
                        xs=1;
                        //现在s[i]是非数字，下次for会i++，这里补偿--
                        i--;
                        //保存符号
                        xs*=flag;
                    }
                } else {
                    //没有遇到符号就直接遇到数字，是多项式的开头
                    while(isdigit(s[i])) {
                        xs=10ll*xs+(s[i]-'0');
                        i++;
                        if(i==n) {
                            //到达字符串结尾，保存最后一个单项式，也就是常数项，当然要注意符号，虽然一定是+1
                            xs*=flag;
                            addMo(xs,zs);
                            return;
                        }
                    }
                    //现在s[i]是非数字，下次for会i++，这里补偿--
                    i--;
                    //保存符号，虽然一定是+1
                    xs*=flag;
                }
            } else if(isalpha(s[i])) {
                //遇到字母，处理到直到遇到下一个字母或者运算符或者结尾
                //没有遇到运算符和数字就遇到多项式开头的字母，系数为1
                if(xs==0)
                    xs=1;
                //保存这个字母，名字叫做c
                int c=s[i];
                //cout<<(char)(c)<<"!!!"<<endl;
                //指向下一个字符
                i++;
                if(i==n) {
                    //到达字符串结尾，保存最后一个单项式
                    //先把最后一个字符的1次方加上
                    zs[c]++;
                    addMo(xs,zs);
                    return;
                }
                if(s[i]=='^') {
                    //是指数符号，说明要继续处理
                    i++;
                    //指向下一个数字或者符号

                    int flag=1;
                    if(!isdigit(s[i])) {
                        //当前遇到的是符号
                        if(s[i]=='-')
                            flag=-1;
                        i++;
                        //指向符号的下一个字符
                        if(i==n) {
                            //到达字符串结尾，你符号后面居然没有数？那就认为指数是0吧，舍弃最后一个字母，保存单项式
                            addMo(xs,zs);
                            return;
                        }

                        ll tzs=0;
                        if(isdigit(s[i])) {
                            //下一个是显式指定的数字，处理到第一个非数字
                            while(isdigit(s[i])) {
                                tzs=10ll*tzs+(s[i]-'0');
                                i++;
                                if(i==n) {
                                    //到达字符串结尾，保存最后一个单项式
                                    //保存最后一个字母的指数，记得乘上符号
                                    zs[c]+=tzs*flag;
                                    addMo(xs,zs);
                                    return;
                                }
                            }
                            //现在s[i]是非数字，下次for会i++，这里补偿--
                            i--;
                            //保存符号
                            tzs*=flag;
                            //保存指数
                            zs[c]+=tzs;
                        } else {
                            //符号后面不是数字，系数是隐含的1
                            tzs=1;
                            //现在s[i]是非数字，下次for会i++，这里补偿--
                            i--;
                            //保存符号
                            tzs*=flag;
                            //保存指数
                            zs[c]+=tzs;
                        }
                    } else {
                        //没有遇到符号就直接遇到数字，是正的指数
                        //cerr<<"...\n"<<endl;
                        ll tzs=0;
                        while(isdigit(s[i])) {
                            tzs=10ll*tzs+(s[i]-'0');
                            i++;
                            if(i==n) {
                                //到达字符串结尾，保存最后一个单项式，也就是常数项，当然要注意符号，虽然一定是+1
                                tzs*=flag;
                                zs[c]+=tzs;
                                addMo(xs,zs);
                                return;
                            }
                        }
                        //现在s[i]是非数字，下次for会i++，这里补偿--
                        i--;
                        //保存符号，虽然一定是+1
                        tzs*=flag;
                        //保存指数
                        zs[c]+=tzs;
                    }
                } else {
                    //遇到了字母或运算符，保存指数并补偿--
                    zs[c]++;
                    i--;
                }
            }
        }
    }

    //向多项式中添加一个单项式
    void addMo(ll &xs,ll *zs) {
        if(xs==0)
            return;
        Mo m;
        m.xs=xs;
        memcpy(m.zs,zs,sizeof(m.zs));
        v.push_back(m);
        xs=0;
        //不能sizeof(zs)，因为这里zs不是数组而只是一个指针
        memset(zs,0,sizeof(ll)*256);
    }
};

char s[10005],t[10005],n;

int main() {
#ifdef Yinku
    freopen("Yinku.in","r",stdin);
#endif // Yinku

    fgets(s,10000,stdin);
    n=strlen(s);

    for(int i=0,j=0; i<=n; i++) {
        if(i==n) {
            t[j]='\0';
        }
        if(s[i]!=' '&&s[i]!='\n') {
            t[j++]=s[i];
        }
    }

    Poly A;
    A.fromString(string(t));

    fgets(s,10000,stdin);
    n=strlen(s);

    for(int i=0,j=0; i<=n; i++) {
        if(i==n) {
            t[j]='\0';
        }
        if(s[i]!=' '&&s[i]!='\n') {
            t[j++]=s[i];
        }
    }

    Poly B;
    B.fromString(string(t));

#ifdef Yinku
    cout<<A.toString()<<endl;
    cout<<B.toString()<<endl;
#endif // Yinku

    Poly C=A+B;
    Poly D=A*B;
    cout<<C.toString()<<endl;
    cout<<D.toString()<<endl;
}

```


---

## 作者：Twig_K (赞：5)

~~求求 NOIP 出题人，如果要出字符串大模拟，善待我一些吧/kel~~

用一个结构体封装单项式，一个结构体封装多项式。

### 单项式中要用到的东西：

- 结构体中存系数，以及大小为 26 的数组用于记录每个字母的指数。
- 读入，从字符串转换为单项式。
- 重载运算符小于和等于，用来排序和去重。
- 重载运算符乘号，用于单项式乘法。
- 单项式的输出函数 `printmono`。

### 多项式中要用到的东西：

- 一个 `vector`，存多项式的每一项（每一项类型都是前面的单项式）。
- 获取多项式的函数 `getpoly`。
- 重载运算符加和乘，多项式的加法和乘法。
- `unique` 函数，用于多项式的排序和去重。
- 多项式的输出函数 `print`。

------------------------------

下面是每个函数的具体坑点：

### 单项式：
- 读入，从字符串转换为单项式。
  - 单项式系数：没有读入的话默认绝对值是 $1$，需要考虑**负号**，不清楚有没有系数是 $-1$ 只保留负号的情况。
  - 指数：和系数一样，**有可能为负数，且要注意指数 $1$ 的省略。**
  - 可能存在 `AAA` 这样的指数未合并的情况，所以或许更保险的做法是，每次累加指数而不是直接赋值。
  - 对于有些写法（比如这篇题解），结尾最后的一个字母（和它的指数）不要忘记。
- 重载运算符小于和等于，用来排序和去重。
  - 需要特别考虑系数为 $0$ 的情况，有时候系数为 $0$，后面的指数仍然会有值。所以在比较时如果存在系数为 $0$ 的直接返回。
- 重载运算符乘号，用于单项式乘法。
  - 系数相乘，对应指数相加就可以了。
- 单项式的输出函数 `printmono`。
  - 对于一些写法（不包括这篇题解），如果系数为 $0$，不需要输出。
  - 如果系数绝对值不为 $1$，首先输出系数。
  - 如果系数为 $-1$，首先输出负号。
  - 在遍历完所有指数后，如果所有指数都为 $0$ 且系数绝对值为 $1$ 输出系数。

### 多项式：

- 一个 `vector`，存多项式的每一项。
- 获取多项式的函数 `getpoly`。
  - 通过一些**左右都有空格的**加号或减号，将整行字符串分割成一些子串，扔到单项式的读入函数中。
- 重载运算符加和乘，多项式的加法和乘法。
- `unique` 函数，用于多项式的排序和去重。
  - 在这里面使用单项式中重载的小于和等于，可以像一般的数组那样手动去重。
  - 如果某一项系数为 $0$，就直接丢掉。
  - 函数最后要 `resize` 重设 `vector` 大小。
  - 我在多项式的乘法和加法最后，以及输出函数的最开头，同时调用了 `unique`，但是删去输出函数开头的 `unique` 或者删去运算最后的 `unique`，都会出问题，于是都加上了（不知道为什么，如果看出来的话求评论区解答）。
- 多项式的输出函数 `print`。
  - 如果多项式为空，输出 $0$ 并直接返回。
  - 调用输出单项式的函数，将多项式的每一项输出。
  - 如果不是第一项且系数非负，输出一个加号连接该项和前一项（如果系数为负数的话会在输出单项式的部分输出）。

想不到别的坑点了。

### Code
```cpp
#include<bits/stdc++.h>
#define int long long
#define pb emplace_back
#define Fr(i,il,ir) for(int i=(il);i<(ir);++i)
using namespace std;

struct mono{
    int v,a[26];
    mono(){ v=0;memset(a,0,sizeof(a)); }
    bool operator < (mono rc)const{ if(!v||!rc.v) return v<rc.v; Fr(i,0,26) if(a[i]!=rc.a[i]) return a[i]<rc.a[i];return 0; }
    bool operator == (mono rc)const{ if(!v||!rc.v) return v==rc.v; Fr(i,0,26) if(a[i]!=rc.a[i]) return 0; return 1; }
    mono operator * (mono rc)const{ mono res;res.v=v*rc.v; Fr(i,0,26) res.a[i]=a[i]+rc.a[i]; return res; }
    void printmono(){//输出单项式
        if(abs(v)!=1) printf("%lld",v);
        if(v==-1) putchar('-'),v=1;
        bool printflag=false;
        Fr(i,0,26) if(a[i]){
            printflag=true,putchar('A'+i);
            if(a[i]!=1) printf("^%lld",a[i]);
        }
        if(!printflag&&v==1) printf("%lld",v);
    }
};
mono getmo(string s)//获取单项式
{
    mono ret;int len=s.size();
    //获取系数
    int i,x=0,f=1;bool flag=false;
    for(i=0;i<len&&!isupper(s[i]);i++)
        if(s[i]=='-') f=-f;
        else if(isdigit(s[i])) x=x*10+(s[i]^48),flag=true; 
    ret.v=flag?x*f:f;
    //指数累加
    int nw=-1;x=0,f=1,flag=false;
    for(;i<len;++i)
        if(isupper(s[i])){
            if(~nw) ret.a[nw]+=flag?x*f:f;
            nw=s[i]-'A',x=0,f=1,flag=false;
        }
        else if(s[i]=='^') flag=true;
        else if(s[i]=='-') f=-f;
        else if(isdigit(s[i])) x=x*10+(s[i]^48);
    if(~nw) ret.a[nw]+=flag?x*f:f;
    return ret;
}
struct polyno{
    vector<mono> ve;
    void unique()
    {
        if(!ve.size()) return;
        sort(ve.begin(),ve.end());int tot=-1;
        for(auto x:ve) if(x.v)
            if(~tot&&x==ve[tot]) ve[tot].v+=x.v;
            else ve[++tot]=x;
        ve.resize(tot+1);
    }
    void getpoly(){//获取多项式
        string s,t="";getline(cin,s);
        s=" "+s+" ";int len=s.size();//为了循环中 i-1 和 i+1 不越界，前后各加一个空格。
        Fr(i,0,len)//分割成单项式（string t）加进去
            if((s[i]=='+'||s[i]=='-')&&s[i-1]==' '&&s[i+1]==' '){
                if(t!="") ve.pb(getmo(t)),t="";
                if(s[i]=='-') t=t+s[i];
            }else if(s[i]!=' ') t=t+s[i];
        if(t!="") ve.pb(getmo(t));
        unique();
    }
    polyno operator + (polyno rc)const{
        polyno res;
        for(auto x:ve) res.ve.pb(x);
        for(auto x:rc.ve) res.ve.pb(x);
        res.unique();return res;
    }
    polyno operator * (polyno rc)const{
        polyno res;
        for(auto x:ve) for(auto y:rc.ve) res.ve.pb(x*y);
        res.unique();return res;
    }
    void print(){//多项式输出
        unique();
        if(!ve.size()){ puts("0"); return; }
        Fr(i,0,ve.size()){
            if(i&&ve[i].v>=0) putchar('+');
            ve[i].printmono();
        }putchar('\n');
    }
}A,B,C,D;
signed main(){
    A.getpoly();B.getpoly();
    C=A+B,D=A*B;C.print(),D.print();
    return 0;
}
```

---

## 作者：Night_Aurora (赞：2)

这是一道比较糟的题目

对于一个单项式用一个int保存系数，26个int保存对应每个代数的指数

然后多项式就可以转换成很多个单项式了

多项式加法就是把两个多项式的单项式合并到一块

再把指数都相等的单项式合并起来，并删除系数为0的单项式

对于判断两个单项式的指数是否相等，我们可以用类似字符串的哈希算法

判断两个单项式的指数哈希是否相同，在判断两个单项式指数是不是一样

对于乘法，直接二维枚举单项式然后乘起来加到新的多项式就行了

所以这道题最难的是读入方面....

读入这东西没什么好讲的，就是考编程底力

---
## 最后要说的是数据有点坑

## 前三个点的多项式开头有蜜汁‘+’号

## 大部分点的多项式里面有分式，就是指数位为负数

然后这道题就没有什么其他要说的了

代码:

快三百行的代码贴上有点不美观，就放[链接](http://paste.ubuntu.com/25800768/)吧


---

## 作者：Milthm (赞：1)

~~做对的大模拟里面坑最多的一个，因为比它坑多的还没调出来。~~

注：加粗的全是坑点。

首先发现有两个多项式，然后直接字符串读入就可以。

读入进来之后，将其分成一个个单项式，注意连接的也有可能是**减号**，多项式开头可能有**多余加号**，多个字母可能**不合并指数**，指数**可能是负数**。知道这些之后处理一下就可以。

然后加法和乘法反而很简单，初一内容，加法先直接加起来，乘法双重循环枚举加起来就可以。

然后合并同类项，我是双重循环枚举，如果是同类项直接加上这项的系数并把系数清零。注意如果扫到这项系数没了**直接跳过**。

最后就是输出了，输出也有许许多多的坑。首先就是系数为 $1$ 如果有字母是**不用输出的**，但是如果没有字母是**要输出的**，如果系数为 $-1$ **也一样**。然后就是如果在第一个位置**不用输出加号**。最后就是如果多项式没有东西**输出** $0$。

然后你就愉快的做完了这道不算太大的大模拟。

### AC code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct node{
	int x,power[30];
}A[255],B[255],ans[505],ans2[70005];
string s;
int len=1,len2=1,cnt,cnt2;
bool cmp(node a,node b){
	for(int i=0;i<26;++i){
		if(a.power[i]!=b.power[i])return a.power[i]<b.power[i];
	}
	return 1;
}
void print(node ans[],int cnt){
	for(int i=1;i<=cnt;++i){
		if(ans[i].x==0)continue;
		for(int j=i+1;j<=cnt;++j){
			if(ans[j].x==0)continue;
			int ttq=1;
			for(int k=0;k<26;++k){
				if(ans[i].power[k]!=ans[j].power[k]){
					ttq=0;break;
				}
			}
			if(ttq){
				ans[i].x+=ans[j].x;ans[j].x=0;
				for(int k=0;k<26;++k)ans[j].power[k]=0;ans[j].power[0]=1e9;
			}
		}
	}
	for(int i=1;i<=cnt;++i)if(ans[i].x==0)ans[i].power[0]=1e9;
	sort(ans+1,ans+cnt+1,cmp);
	bool zero=0;
	for(int i=1;i<=cnt;++i){
		if(ans[i].x==0)continue;
		zero=1;
		if(ans[i].x<0){
			bool ttq=0;
			for(int j=0;j<26;++j){
				if(ans[i].power[j]!=0){
					ttq=1;break;
				}
			}
			if(ans[i].x!=-1||ttq==0)cout<<ans[i].x;
			else cout<<"-";
		}
		if(ans[i].x>0){
			if(i!=1)cout<<"+";
			bool ttq=0;
			for(int j=0;j<26;++j){
				if(ans[i].power[j]!=0){
					ttq=1;break;
				}
			}
			if(ans[i].x!=1||ans[i].x==1&&ttq==0)cout<<ans[i].x;
		}
		for(int j=0;j<26;++j){
			if(ans[i].power[j]!=0){
				cout<<char(j+'A');
				if(ans[i].power[j]!=1){
					cout<<"^"<<ans[i].power[j];
				}
			}
		}
	}
	if(!zero)cout<<0;
	cout<<'\n';
}
signed main(){
	getline(cin,s);
	s+="  ";
	int f=1,xishu=0;
	char lst;
	for(int i=0;i<s.size();++i){
		if((s[i]=='+'||s[i]=='-')&&(s[i-1]!='^'||i==0)){
			if(xishu&&A[len].x==0)A[len].x=f;
			++len;xishu=0;
			if(s[i]=='+')f=1;
			else f=-1;
		}
		else if(isupper(s[i])){
			lst=s[i];xishu=1;
			if(s[i+1]!='^')A[len].power[s[i]-'A']++;
		}
		else if(xishu==0&&isdigit(s[i])){
			int num=0;
			while(isdigit(s[i]))num=num*10+s[i]-'0',++i;
			A[len].x=num*f;if(num==0)f=0;
		}
		else if(xishu&&isdigit(s[i])){
			int pf,num=0;
			if(s[i-1]=='-')pf=-1;
			else pf=1;
			while(isdigit(s[i]))num=num*10+s[i]-'0',++i;
			A[len].power[lst-'A']+=num*pf;
		}
	}
	if(xishu&&A[len].x==0)A[len].x=f;
	f=1,xishu=0;
	getline(cin,s);
	s+="  ";
	for(int i=0;i<s.size();++i){
		if((s[i]=='+'||s[i]=='-')&&(s[i-1]!='^'||i==0)){
			if(xishu&&B[len2].x==0)B[len2].x=f;
			++len2;xishu=0;
			if(s[i]=='+')f=1;
			else f=-1;
		}
		else if(isupper(s[i])){
			lst=s[i];xishu=1;
			if(s[i+1]!='^')B[len2].power[s[i]-'A']++;
		}
		else if(xishu==0&&isdigit(s[i])){
			int num=0;
			while(isdigit(s[i]))num=num*10+s[i]-'0',++i;
			B[len2].x=num*f;if(num==0)f=0;
		}
		else if(xishu&&isdigit(s[i])){
			int pf,num=0;
			if(s[i-1]=='-')pf=-1;
			else pf=1;
			while(isdigit(s[i]))num=num*10+s[i]-'0',++i;
			B[len2].power[lst-'A']+=num*pf;
		}
	}
	if(xishu&&B[len2].x==0)B[len2].x=f;
	for(int i=1;i<=len;++i){
		ans[++cnt].x=A[i].x;
		for(int j=0;j<26;++j)ans[cnt].power[j]=A[i].power[j];
	}
	for(int i=1;i<=len2;++i){
		ans[++cnt].x=B[i].x;
		for(int j=0;j<26;++j)ans[cnt].power[j]=B[i].power[j];
	}
	for(int i=1;i<=len;++i){
		for(int j=1;j<=len2;++j){
			ans2[++cnt2].x=A[i].x*B[j].x;
			for(int k=0;k<26;++k){
				ans2[cnt2].power[k]=A[i].power[k]+B[j].power[k];
			}
		}
	}
	print(ans,cnt);print(ans2,cnt2);
	return 0;
}

```


---

## 作者：bluewindde (赞：1)

大坑题一道。

#### 解法

解法是封装单项式 `monomial` 类和多项式 `polynomial` 类。

但有一种数据长这样，你敢相信？

```
in:
+ 5 B B B^-3
+ A

out:
5B^-1+A
5AB^-1
```

*备注：这根本就不是多项式，这是分式。*

开头可以有 `+`，同类项可以不合并，有负数次幂。

当然，也有一般的坑，如多项式为空输出 `0`，省略系数 `1` 但保留常数项的 `1`。（想到这些坑应该是 30 pts）

至于这题评蓝的原因应该就是这几个坑，只要想清楚了代码就好写。

#### 代码

```cpp
#include <algorithm>
#include <ctype.h>
#include <iostream>
#include <map>
#include <set>
#include <string>
#include <vector>

#define int long long

using namespace std;

struct monomial
{
    int factor = 0;       // 系数
    map<char, int> alpha; // 字母和指数
    monomial()
    {
        this->factor = 0;
        this->alpha.clear();
    }
    monomial(const monomial &n)
    {
        this->factor = n.factor;
        this->alpha  = n.alpha;
    }
    monomial operator*(const monomial &n) const
    {
        monomial ret = *this;
        ret.factor *= n.factor;
        for (auto [key, value] : n.alpha) {
            ret.alpha[key] += value;
        }
        return ret;
    }
    bool operator<(monomial &n) // 不能 const
    {
        // 这里不能用遍历 this->alpha
        // 因为可能会漏掉情况
        for (char i = 'A'; i <= 'Z'; ++i) {
            if (this->alpha[i] != n.alpha[i]) {
                return this->alpha[i] < n.alpha[i];
            }
        }
        return this->factor < n.factor;
    }
};
struct polynomial
{
    vector<monomial> vec; // 单项式
    polynomial() {}
    polynomial(const polynomial &n) { this->vec = n.vec; }
    polynomial(const vector<char> str)
    {
        monomial tmp;
        for (int i = 0; i <= str.size(); ++i) {
            if (i == str.size()) {
                if (tmp.factor)
                    this->vec.push_back(tmp);
                return;
            }
            if (str[i] == '+' || str[i] == '-' || isdigit(str[i])) {
                if (tmp.factor) {
                    this->vec.push_back(tmp);
                    tmp = monomial();
                }
                int flag = 1;
                if (!isdigit(str[i])) {
                    if (str[i] == '-') {
                        flag = -1;
                    }
                    ++i;
                    if (i == str.size()) {
                        return;
                    }
                    if (isdigit(str[i])) {
                        while (isdigit(str[i])) {
                            tmp.factor *= 10;
                            tmp.factor += str[i] - '0';
                            ++i;
                            if (i == str.size()) {
                                tmp.factor *= flag;
                                if (tmp.factor)
                                    this->vec.push_back(tmp);
                                return;
                            }
                        }
                        --i;
                        tmp.factor *= flag;
                    } else {
                        tmp.factor = 1;
                        --i;
                        tmp.factor *= flag;
                    }
                } else {
                    while (isdigit(str[i])) {
                        tmp.factor *= 10;
                        tmp.factor += str[i] - '0';
                        ++i;
                        if (i == str.size()) {
                            tmp.factor *= flag;
                            if (tmp.factor)
                                this->vec.push_back(tmp);
                            return;
                        }
                    }
                    --i;
                    tmp.factor *= flag;
                }
            } else if (isalpha(str[i])) {
                if (tmp.factor == 0) {
                    tmp.factor = 1;
                }
                char c = str[i];
                ++i;
                if (i == str.size()) {
                    ++tmp.alpha[c];
                    this->vec.push_back(tmp);
                    return;
                }
                if (str[i] == '^') {
                    ++i;
                    int flag = 1;
                    if (!isdigit(str[i])) {
                        if (str[i] == '-') {
                            flag = -1;
                        }
                        ++i;
                        if (i == str.size()) {
                            if (tmp.factor)
                                this->vec.push_back(tmp);
                            return;
                        }
                        int tt = 0;
                        if (isdigit(str[i])) {
                            while (isdigit(str[i])) {
                                tt *= 10;
                                tt += str[i] - '0';
                                ++i;
                                if (i == str.size()) {
                                    tmp.alpha[c] += tt * flag;
                                    if (tmp.factor)
                                        this->vec.push_back(tmp);
                                    return;
                                }
                            }
                            --i;
                            tt *= flag;
                            tmp.alpha[c] += tt;
                        } else {
                            tt = 1;
                            --i;
                            tt *= flag;
                            tmp.alpha[c] += tt;
                        }
                    } else {
                        int tt = 0;
                        while (isdigit(str[i])) {
                            tt *= 10;
                            tt += str[i] - '0';
                            ++i;
                            if (i == str.size()) {
                                tt *= flag;
                                tmp.alpha[c] += tt;
                                if (tmp.factor)
                                    this->vec.push_back(tmp);
                                return;
                            }
                        }
                        --i;
                        tt *= flag;
                        tmp.alpha[c] += tt;
                    }
                } else {
                    ++tmp.alpha[c];
                    --i;
                }
            }
        }
    }
    void simplify()
    {
        // set<map<char, int>, monomial> s;
        // 不如直接 vector
        vector<monomial> s;
        for (auto i : this->vec) {
            bool append = true;
            for (auto &j : s) { // 这里要写成引用的形式
                bool flag = true;
                for (char key = 'A'; key <= 'Z'; ++key) {
                    if (i.alpha[key] != j.alpha[key]) {
                        flag = false;
                        break;
                    }
                }
                if (flag) {
                    j.factor += i.factor;
                    append = false;
                    break;
                }
            }
            if (append) {
                s.push_back(i);
            }
        }
        this->vec.clear();
        for (auto i : s) {
            if (i.factor) {
                this->vec.push_back(i);
            }
        }
        sort(this->vec.begin(), this->vec.end());
    }
    polynomial operator+(const polynomial &n) const
    {
        polynomial ret = *this;
        for (auto i : n.vec) {
            ret.vec.push_back(i);
        }
        ret.simplify();
        return ret;
    }
    polynomial operator*(const polynomial &n) const
    {
        polynomial ret;
        for (auto i : this->vec) {
            for (auto j : n.vec) {
                ret.vec.push_back(i * j);
            }
        }
        ret.simplify();
        return ret;
    }
    friend ostream &operator<<(ostream &os, polynomial n)
    {
        if (n.vec.empty()) {
            os << '0';
            return os;
        }
        n.simplify();
        bool flag = true;
        for (auto i : n.vec) {
            if (i.factor == 0) { // 系数
                continue;
            }
            if (i.factor > 0) {
                if (!flag) {
                    os << '+';
                }
                if (i.factor > 1) {
                    os << i.factor;
                }
            } else {
                if (i.factor == -1) {
                    os << '-';
                } else {
                    os << i.factor;
                }
            }
            flag       = false;
            bool isnum = true; // 是否没有字母
            for (char key = 'A'; key <= 'Z'; ++key) {
                if (i.alpha[key] != 0) {
                    isnum = false;
                    os << key;
                    if (i.alpha[key] != 1) {
                        os << '^' << i.alpha[key];
                    }
                }
            }
            if (isnum) {
                if (abs(i.factor) == 1) {
                    os << '1';
                }
            }
        }
        return os;
    }
};

static inline vector<char> readline()
{ // 过滤空格
    vector<char> ret;
    char ch = getchar();
    while (ch != '\n') {
        if (ch != ' ' && ch != '\n') {
            ret.push_back(ch);
        }
        ch = getchar();
    }
    return ret;
}

signed main()
{
#ifndef ONLINE_JUDGE
    freopen("data/P2281/P2281.in", "r", stdin);
#endif
    auto s1 = readline();
    auto s2 = readline();
    polynomial a(s1);
    a.simplify();
    polynomial b(s2);
    b.simplify();
    // cout << a << endl;
    // cout << b << endl;
    cout << (a + b) << endl;
    cout << (a * b) << endl;
    return 0;
}
```


---

## 作者：zrt090604 (赞：0)

### 1. 多项式存储方式
对于每一个单项式，我们可以用一个长度为 $27$ 的数组来记录。具体来说，**第一个数字记录系数（如果是负数系数也是负数），后面的 $26$ 个数字分别记录每个字母的指数**。这样就可以保证输出的时候是有序的。

### 2. 合并同类项方法
首先**把这个多项式的所有项存储进一个 $\verb|vector|$ 中**，接下来进行如下步骤：  
1. 取出第一个数组（单项式）。  
1. 向后比较，如果有单项式与取出的单项式可以合并，就把它标记删除，同时进行合并操作。  
1. 把第一个单项式加入答案当中并删除。  
1. 如果 $\verb|vector|$ 中的单项式个数（元素个数）$\ge 2$，就继续执行第 1. 步。  
##### 用代码来实现就是这样：
```cpp
void hebing() {
    int del[155], cnt = 0;
    while(pl.size() >= 1) {
        cnt = 0;
        vector<int> x = pl[0];
        for(int i = 1;i < pl.size();++i)
            if(check(x, pl[i])) x[0] += pl[i][0], del[++cnt] = i;
        ans1.push_back(x);
        pl.erase(pl.begin());
        for(int i = 1;i <= cnt;++i) pl.erase(pl.begin()+del[i]-i);
        for(int i = 0;i < ans1.size();++i)
            if(ans1[i][0] == 0) ans1.erase(ans1.begin()+i);
    }
    return;
}
```

### 3. 输出顺序（sort 条件）
题目说按字母表顺序从小到大排列，也就是说比较两个单项式 $\verb|first|$ 和 $\verb|second|$ 时，比较方法遵循以下规则：  
$
\sum_{i=1}^{26} f(i) = \begin{cases}
\text{first[i] > second[i]}, &1\\
\text{first[i] < second[i]}, &-1\\
\text{first[i] = second[i]}, &0\\
\end{cases}
$  
只要 $f(i)\neq 0$，就直接暂停比较，输出结果。这样总能比出一个不一样的（因为如果一样就可以合并了）。  
实现起来也比较简单：
```cpp
bool cmp(vector<int> a, vector<int> b) {
    for(int i = 1;i <= 26;++i) {
        if(a[i] < b[i]) return true;
        if(a[i] > b[i]) return false;
    }
}
```
你学会了吗？

---


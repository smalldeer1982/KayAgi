# [HNOI2004] 宠物收养场

## 题目背景

题面修缮来自于 [LaDeX](https://www.luogu.com.cn/user/431658)。

## 题目描述

凡凡开了一间宠物收养场。收养场提供两种服务：收养被主人遗弃的宠物和让新的主人领养这些宠物。

每个领养者都希望领养到自己满意的宠物，凡凡根据领养者的要求通过他自己发明的一个特殊的公式，得出该领养者希望领养的宠物的特点值 $a$（$a$ 是一个正整数，$a<2^{31}$），而他也给每个处在收养场的宠物一个特点值。这样他就能够很方便的处理整个领养宠物的过程了，宠物收养场总是会有两种情况发生：被遗弃的宠物过多或者是想要收养宠物的人太多，而宠物太少。

被遗弃的宠物过多时，假若到来一个领养者，这个领养者希望领养的宠物的特点值为 $a$，那么它将会领养一只目前未被领养的宠物中特点值最接近 $a$ 的一只宠物。（任何两只宠物的特点值都不可能是相同的，任何两个领养者的希望领养宠物的特点值也不可能是一样的）如果有两只满足要求的宠物，即存在两只宠物他们的特点值分别为 $a-b$ 和 $a+b$，那么领养者将会领养特点值为 $a-b$ 的那只宠物。

收养宠物的人过多，假若到来一只被收养的宠物，那么哪个领养者能够领养它呢？能够领养它的领养者，是那个希望被领养宠物的特点值最接近该宠物特点值的领养者，如果该宠物的特点值为 $a$，存在两个领养者他们希望领养宠物的特点值分别为 $a-b$ 和 $a+b$，那么特点值为 $a-b$ 的那个领养者将成功领养该宠物。

一个领养者领养了一个特点值为 $a$ 的宠物，而它本身希望领养的宠物的特点值为 $b$，那么这个领养者的不满意程度为 $|a-b|$。

你得到了一年当中，领养者和被收养宠物到来收养所的情况，请你计算所有收养了宠物的领养者的不满意程度的总和。这一年初始时，收养所里面既没有宠物，也没有领养者。

## 说明/提示

样例解释：

注：$|3-2| + |2-4|=3$，
最后一个领养者没有宠物可以领养。

## 样例 #1

### 输入

```
5                  
0 2                      
0 4                         
1 3
1 2
1 5
```

### 输出

```
3
```

# 题解

## 作者：yybyyb (赞：53)

~~我的splay为啥跑得这么快。。。。~~

其实只需要维护一个splay

存一下当前是宠物多还是顾客多，随时在宠物和顾客之间转换

每一次加进来一个宠物时

如果是宠物树就直接插入

否则查找当前顾客的期望的前驱和后继（不是严格的）

拉出来删除，统计答案

反之如果是顾客树，就反着来做就行了

当然，如果你乐意写两个splay（也就复制一下）

那就手动维护顾客树和宠物数就行了

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<queue>
#include<vector>
#include<algorithm>
using namespace std;
#define MAX 200000
#define MOD 1000000
int tot;
inline int read()
{
    register int x=0,t=1;
    register char ch=getchar();
    while(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();
    if(ch=='-'){t=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
    return x*t;
}
struct Node
{
    int ch[2];
    int val;
    int ff;
}t[MAX];
int root;
inline void rotate(int x)
{
    int y=t[x].ff;
    int z=t[y].ff;
    int k=(x==t[y].ch[1]);
    t[z].ch[y==t[z].ch[1]]=x;
    t[x].ff=z;
    t[y].ch[k]=t[x].ch[k^1];
    t[t[x].ch[k^1]].ff=y;
    t[x].ch[k^1]=y;
    t[y].ff=x;
}
inline void splay(int x,int goal)
{
    //if(x==0)return;
    while(t[x].ff!=goal)
    {
        int y=t[x].ff;
        int z=t[y].ff;
        if(z!=goal)
            (t[z].ch[0]==y)^(t[y].ch[0]==x)?rotate(x):rotate(y);
        rotate(x);
    }
    if(goal==0)root=x;
}
inline void insert(int x)
{
    int u=root,ff=0;
    while(u&&t[u].val!=x)
    {
        ff=u;
        u=t[u].ch[t[u].val<x];
    }
    if(u);
    else
    {
        u=++tot;
        if(ff)t[ff].ch[t[ff].val<x]=u;
        t[u].ff=ff;
        t[u].ch[0]=t[u].ch[1]=0;
        t[u].val=x;
    }
    splay(u,0);
}
inline void find(int x)
{
    int u=root;
    if(!u)return;
    while(t[u].ch[x>t[u].val]&&x!=t[u].val)
        u=t[u].ch[x>t[u].val];
    splay(u,0);
}
inline int Next(int x,int f)
{
    find(x);
    int u=root;
    if(t[u].val>=x&&f)return u;
    if(t[u].val<=x&&!f)return u;
    u=t[u].ch[f];
    while(t[u].ch[f^1])u=t[u].ch[f^1];
    return u;
}
inline int Next_une(int x,int f)
{
    find(x);
    int u=root;
    if(t[u].val>x&&f)return u;
    if(t[u].val<x&&!f)return u;
    u=t[u].ch[f];
    while(t[u].ch[f^1])u=t[u].ch[f^1];
    return u;
}
inline void Delete(int x)
{
    int lt=Next_une(x,0);
    int nt=Next_une(x,1);
    splay(lt,0);splay(nt,lt);
    t[nt].ch[0]=0;
}
int main()
{
    int n=read();
    int cnt=0,ans=0;
    insert(+214748364);
    insert(-214748364);
    while(n--)
    {
        int k=read(),x=read();
        if(x==1)
            x=1;
        if(cnt==0)//空树
            insert(x);
        if(cnt>0)//宠物树
        {
            if(k==0)insert(x);
            else//新来顾客
            {
                int a1=t[Next(x,0)].val;//前驱
                int a2=t[Next(x,1)].val;//后继
                if(abs(a1-x)<=abs(a2-x))
                {
                    ans+=abs(a1-x);
                    Delete(a1);
                }
                else
                {
                    (ans+=abs(a2-x))%=MOD;
                    Delete(a2);
                }
            }
        }
        if(cnt<0)//顾客树
        {
            if(k==1)insert(x);
            else//新来宠物
            {
                int a1=t[Next(x,0)].val;
                int a2=t[Next(x,1)].val;
                if(abs(a1-x)<=abs(a2-x))
                {
                    (ans+=abs(a1-x))%=MOD;
                    Delete(a1);
                }
                else
                {
                    (ans+=abs(a2-x))%=MOD;
                    Delete(a2);
                }
            }
        }
        cnt=cnt+(k==0?1:-1);
    }
    printf("%d\n",ans);
    return 0;
}

```

---

## 作者：DaCong (赞：32)

很裸的平衡树，本来想无脑打一个 Treap 的板子过的，但是经同学提醒，说是可以直接用 set 做，思考了一下，发现的确如此。毕竟在很多的 g++ 版本上， set 的实现是使用了 RBT 。所以说，能用 set 的时候，还是尽可能用吧，毕竟代码量小，速度也很快。


下面直接上代码：


    
    
    
```cpp
    #include <cstdio>
    #include <set>
    const int maxn = 1000000;
    const int INF = 1e9;
    int n, ans;
    std::set<int> s;
    void find(int x) {
        std::set<int>::iterator left, right;
        left = --s.lower_bound(x), right = s.lower_bound(x); //lower_boud 在实现的时候使用了二分
        if(x - *left <= *right - x && *left != -INF) {
            ans += x - *left;
            s.erase(left);
        } else {
            ans += *right - x;
            s.erase(right);
        }
        ans %= 1000000;//不要忘记取模
    }
    int main() {
        scanf("%d", &n);
        int cur;
        s.insert( -INF ), s.insert( INF ); //这里主要是防止越界这类莫名的错误，此处参考了黄学长的博客
        for(int i = 1; i <= n; i++) {
            int a, b;
            scanf("%d%d", &a, &b);
            if(s.size() == 2) {
                cur = a; //用 cur 记录当前是人还是狗
                s.insert(b);
            } else if(a == cur) s.insert(b);
            else find(b);
        }
        printf("%d\n", ans);
        return 0;
    }

```

---

## 作者：crpboy (赞：18)

题目要求出一个序列中与x差值最小的数，而且数据保证读入的数值不重复，因此我们用$set$维护。

同一时间呆在收养所中的，要么全是宠物，要么全是领养者。如果读入的是宠物，没有领养者直接$insert$，反之，则肯定有领养者可以和宠物配对。

接下来就可以用$lowerbound$找出领养人的$set$中最接近x的元素，选择 大于$x$的最小值 和 小于$x$的最大值 中最优的情况配对，更新答案，并在领养者的$set$中$erase$掉已经配对的数值。

领养者的情况和宠物完全相同，因此我们可以直接用位运算取反来表示宠物和领养者。

注意特判$x$在边界的情况，防止迭代器越界。

用了set码量还是挺小的qwq

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=1000000,INF=0x7fffffff;
set<int>a[2];
set<int>::iterator it;
int n,ans=0;
int main()
{
    int opt,x;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d",&opt,&x);
        if(a[opt^1].empty()){a[opt].insert(x);continue;}
        
        if(x>*(--a[opt^1].end()))
        {
            ans+=x-*(--a[opt^1].end());ans%=mod;
            a[opt^1].erase(*(--a[opt^1].end()));
        }
        else if(x<*(a[opt^1].begin()))
        {
            ans+=*(a[opt^1].begin())-x;ans%=mod;
            a[opt^1].erase(*(a[opt^1].begin()));
        }
        else
        {
            it=a[opt^1].lower_bound(x);
            int nxt=*it,pre=*(--it);
            if(x-pre<=nxt-x)a[opt^1].erase(pre),ans=(ans+x-pre)%mod;
            else a[opt^1].erase(nxt),ans=(ans+nxt-x)%mod;
        }
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：Jayun (赞：15)

# 感谢 @Cefola_Kiroxs

[**题目链接**](https://www.luogu.org/problem/P2286)

# 前言：

啊看到dalao都用$\texttt{Splay}$啊、$\texttt{fhq Treap}$啊、$\texttt{avl-Tree}$。。。~~这些我都不会~~。

所以我就用$\texttt{旋转式Treap}$了QAQ

# 思路：

如果是学过平衡树的，都可以看出这就是一道水模板，但是坑很大

考虑题目要求我们做什么 :

1. 建立一颗“宠物$\texttt{Treap}$”
1. 插入操作——来一个宠物就把他存入$\texttt{Treap}$里。
1. 前驱、后继——判断当前顾客最想要那个宠物。
1. 删除操作——宠物被顾客带走。

根据上边的要求我们轻松（~~想死~~）地写出了一个~~100多行的~~代码！

![](https://s2.ax1x.com/2019/08/11/ejkZ5D.png)

当你把这段代码提交时你会发现你只有$\color{#ff0000}\texttt{20}$分

Q：$\Large{WHY???}$

因为顾客会赖着直到有宠物或数据结束。。。

顾客：~~没有宠物我就不走啦！！！~~

---

那我们应该咋办呢？？？

在建立一个“$\texttt{顾客Treap}$”，和$\texttt{宠物Treap}$是同一种操作。

如果你聪明，你只用大约170行就可以写完，

但如果你和我一样？~~MDZZ270行（还有复制粘贴时一定不能错啊）~~

[自己看吧，我怕代码长度大，洛谷都炸了。。。](https://www.luogu.org/paste/vfvcan9c)

---

## 作者：_Atyou (赞：13)

## 算法： 平衡树

------------

不难发现题目是找前驱和后继

平衡树能在很优秀的复杂度下( O(logn) )找到前驱和后继

那直接照题意建一棵宠物树和一棵顾客树

来宠物就在顾客树找，来顾客就在宠物树找

但其实宠物树和顾客树每次只会有一棵树中存在节点

所以我们只需要一棵树即可，记录一下当前是宠物多还是顾客多

细节就是前驱后继可能不存在，是需要处理的边界条件

我用的是FHQ-Treap 码量较其他平衡树来说小很多

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;

#define reg register
#define ll long long
const int N = 80000 + 5;
const ll inf = 2ll*0x7fffffff;

struct node {
    ll val;
    int l, r, dat, size;
}t[N];
int tot, root, n;

inline int crepoint(ll val) {
    t[++tot]=(node){val, 0, 0, rand(), 1};
    return tot;
}

inline void update(int p) {
    t[p].size=t[t[p].l].size+t[t[p].r].size+1;
}

inline void split(int p, int &a, int &b, ll val) {
    if (!p) { a=b=0; return; }
    if (t[p].val<=val) a=p, split(t[p].r, t[a].r, b, val);
    else b=p, split(t[p].l, a, t[b].l, val);
    update(p); 
}

inline void merge(int &p, int a, int b) {
    if (!a || !b) { p=a+b; return; }
    if (t[a].dat<t[b].dat) p=a, merge(t[p].r, t[a].r, b);
    else p=b, merge(t[p].l, a, t[b].l);
    update(p);
}

inline ll atrank(int p, int rank) {
    while (t[t[p].l].size+1!=rank)
          if (t[t[p].l].size>=rank) p=t[p].l;
          else rank-=(t[t[p].l].size+1), p=t[p].r;
    return t[p].val;
}

inline void insert(ll val) {
    int x=0, y=0, z=crepoint(val);
    split(root, x, y, val); merge(x, x, z); merge(root, x, y);
}

inline void del(ll val) {
    int x=0, y=0, z=0;
    split(root, x, y, val); split(x, x, z, val-1);
    merge(z, t[z].l, t[z].r); merge(x, x, z); merge(root, x, y);
}

inline int rank(ll val) {
    int x=0, y=0, res;
    split(root, x, y, val-1); res=t[x].size+1; merge(root, x, y);
    return res;
}

inline ll getpre(ll val) {
    int x=0, y=0; ll res;
    split(root, x, y, val); if (!x) return -inf; res=atrank(x, t[x].size); merge(root, x, y);
    return res;
}

inline ll getnxt(ll val) {
    int x=0, y=0; ll res;
    split(root, x, y, val-1); if (!y) return inf; res=atrank(y, 1); merge(root, x, y);
    return res;
}

int flag=0; ll ans;

int main() {
    scanf("%d", &n);
    for (reg int i=1; i<=n; ++i) {
        int a; ll b; scanf("%d%lld", &a, &b);
        if (flag==0) insert(b);
        else if (flag<0) {
           if (!a) insert(b);
           else {
               ll pick1=getpre(b), pick2=getnxt(b);
               if (pick2-b < b-pick1) del(pick2), (ans+=pick2-b)%=1000000;
               else del(pick1), (ans+=b-pick1)%=1000000;
           }
       }
       else if (flag>0) {
           if (a) insert(b);
           else {
               ll pick1=getpre(b), pick2=getnxt(b);
               if (pick2-b < b-pick1) del(pick2), (ans+=pick2-b)%=1000000;
               else del(pick1), (ans+=b-pick1)%=1000000;
           }
       }
       flag+=1*(a?1:-1);
    }
    printf("%lld\n", ans);
    return 0; 
}

```




---

## 作者：Zkxxxv_h (赞：7)

>大家好，这个题我调了很久过了，所以想写题解

>我用的平衡树是AVL树，平衡树界的老爷爷

>这个树并不会很慢，主要是我初学，常数巨大

>而且题目的 $ n = 80000$，可以接受

**$solution$**:

开两颗平衡树，维护宠物和人，过多就插入自己的平衡树，过少就在对立平衡树中删除与 $x$ 相差最小的。

也就是确定前驱后继

代码很长，但是操作是相同的，一半都是在复制粘贴

希望注意传参引用，少写一个调了很长时间

**$code:$**
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N = 80000+50;
const int mod = 1000000;
int ans;
inline void read(int &k) {
	k=0;char ch=getchar();
	while(ch>'9'||ch<'0') ch=getchar();
	while(ch<='9'&&ch>='0') k=k*10+ch-'0',ch=getchar();
}
namespace pet{
	int root,cnt;
	struct node{
		int l,r,val,height,size;
	}avl[N];
	inline void newnode(int &now,int val) {
		avl[now=++cnt].val=val,avl[now].size=1;
	}
	int factor(int now) {
		return avl[avl[now].l].height-avl[avl[now].r].height;
	}
	void update(int now) {
		avl[now].size=avl[avl[now].l].size+avl[avl[now].r].size+1;
		avl[now].height=max(avl[avl[now].l].height,avl[avl[now].r].height)+1;
	}
	void zag(int &now) {
		int r=avl[now].r;
		avl[now].r=avl[r].l;
		avl[r].l=now;
		now=r;
		update(avl[now].l),update(now);
	}
	void zig(int &now) {
		int l=avl[now].l;
		avl[now].l=avl[l].r;
		avl[l].r=now;
		now=l;
		update(avl[now].r),update(now);
	}
	void check(int &now) {
		int bf=factor(now);
		if(bf>1) {
			int lf=factor(now);
			if(lf>0) zig(now);
			else zag(avl[now].l),zig(now);
		}else if(bf<-1) {
			int rf=factor(now);
			if(rf<0) zag(now);
			else zig(avl[now].r),zag(now);
		}else if(now) update(now);
	}
	void ins(int &now,int val) {
		if(!now) newnode(now,val);
		else if(avl[now].val>val) ins(avl[now].l,val);
		else ins(avl[now].r,val);
		check(now);
	}
	int find(int &now,int fa) {
		int tmp;
		if(!avl[now].l) tmp=now,avl[fa].l=avl[now].r;
		else tmp=find(avl[now].l,now),check(now);
		return tmp;
	}
	void del(int &now,int val) {
		if(avl[now].val==val) {
			int l=avl[now].l,r=avl[now].r;
			if(!l||!r) now=l+r;
			else {
				now=find(r,r);
				if(now!=r) avl[now].r=r;
				avl[now].l=l;
			}
		}else if(avl[now].val>val) del(avl[now].l,val);
		else del(avl[now].r,val);
		check(now);
	}
	int getrank(int val) {
		int now=root,rank=1;
		while(now) {
			if(val<=avl[now].val) now=avl[now].l;
			else rank+=avl[avl[now].l].size+1,now=avl[now].r;
		}
		return rank;
	}
	int getnum(int rank) {
		int now=root;
		while(now) {
			if(rank==avl[avl[now].l].size+1) break;
			else if(rank<=avl[avl[now].l].size) now=avl[now].l;
			else rank-=avl[avl[now].l].size+1,now=avl[now].r;
		}
		return avl[now].val;
	}
	int search(int now,int val) {
		if(!now) return false;
		if(val==avl[now].val) return true;
		else if(val<avl[now].val) return search(avl[now].l,val);
		else return search(avl[now].r,val);
		return false;
	}
}
namespace human{
	int root,cnt;
	struct node{
		int l,r,val,height,size;
	}avl[N];
	inline void newnode(int &now,int val) {
		avl[now=++cnt].val=val,avl[now].size=1;
	}
	int factor(int now) {
		return avl[avl[now].l].height-avl[avl[now].r].height;
	}
	void update(int now) {
		avl[now].size=avl[avl[now].l].size+avl[avl[now].r].size+1;
		avl[now].height=max(avl[avl[now].l].height,avl[avl[now].r].height)+1;
	}
	void zag(int &now) {
		int r=avl[now].r;
		avl[now].r=avl[r].l;
		avl[r].l=now;
		now=r;
		update(avl[now].l),update(now);
	}
	void zig(int &now) {
		int l=avl[now].l;
		avl[now].l=avl[l].r;
		avl[l].r=now;
		now=l;
		update(avl[now].r),update(now);
	}
	void check(int &now) {
		int bf=factor(now);
		if(bf>1) {
			int lf=factor(now);
			if(lf>0) zig(now);
			else zag(avl[now].l),zig(now);
		}else if(bf<-1) {
			int rf=factor(now);
			if(rf<0) zag(now);
			else zig(avl[now].r),zag(now);
		}else if(now) update(now);
	}
	void ins(int &now,int val) {
		if(!now) newnode(now,val);
		else if(avl[now].val>val) ins(avl[now].l,val);
		else ins(avl[now].r,val);
		check(now);
	}
	int find(int &now,int fa) {
		int tmp;
		if(!avl[now].l) tmp=now,avl[fa].l=avl[now].r;
		else tmp=find(avl[now].l,now),check(now);
		return tmp;
	}
	void del(int &now,int val) {
		if(avl[now].val==val) {
			int l=avl[now].l,r=avl[now].r;
			if(!l||!r) now=l+r;
			else {
				now=find(r,r);
				if(now!=r) avl[now].r=r;
				avl[now].l=l;
			}
		}else if(avl[now].val>val) del(avl[now].l,val);
		else del(avl[now].r,val);
		check(now);
	}
	int getrank(int val) {
		int now=root,rank=1;
		while(now) {
			if(val<=avl[now].val) now=avl[now].l;
			else rank+=avl[avl[now].l].size+1,now=avl[now].r;
		}
		return rank;
	}
	int getnum(int rank) {
		int now=root;
		while(now) {
			if(rank==avl[avl[now].l].size+1) break;
			else if(rank<=avl[avl[now].l].size) now=avl[now].l;
			else rank-=avl[avl[now].l].size+1,now=avl[now].r;
		}
		return avl[now].val;
	}
	int search(int now,int val) {
		if(!now) return false;
		if(val==avl[now].val) return true;
		else if(val<avl[now].val) return search(avl[now].l,val);
		else return search(avl[now].r,val);
		return false;
	}
}
signed main() {
	int n; cin>> n;
	while(n--) {
		int opt, x;
//		scanf("%lld%lld",&opt, &x);
		read(opt),read(x);
		if(!opt) {
			if(human::avl[human::root].size) {
				if(human::search(human::root,x)) human::del(human::root,x);
				else {
					int pre=human::getnum(human::getrank(x)-1);
					int nxt=human::getnum(human::getrank(x+1));
					if(pre==0) { ans+=nxt-x,ans%=mod,human::del(human::root,nxt);continue;}
					if(nxt==0) { ans+=x-pre,ans%=mod,human::del(human::root,pre);continue;}					
					if(x-pre<=nxt-x) ans+=x-pre,ans%=mod,human::del(human::root,pre);
					else ans+=nxt-x,ans%=mod,human::del(human::root,nxt);
				}
			}else pet::ins(pet::root,x);
		}else {
			if(pet::avl[pet::root].size) {
				if(pet::search(pet::root,x)) pet::del(pet::root,x);
				else {
					int pre=pet::getnum(pet::getrank(x)-1);
					int nxt=pet::getnum(pet::getrank(x+1));
					if(pre==0) { ans+=nxt-x,ans%=mod,pet::del(pet::root,nxt);continue;}
					if(nxt==0) { ans+=x-pre,ans%=mod,pet::del(pet::root,pre);continue;}
					if(x-pre<=nxt-x) ans+=x-pre,ans%=mod,pet::del(pet::root,pre);
					else ans+=nxt-x,ans%=mod,pet::del(pet::root,nxt);
				}
			}else human::ins(human::root,x);			
		}
	}
	cout<<ans;	
	return 0;
}
```

---

## 作者：chen_vvv (赞：5)

用set可以比较方便的实现这道题。

根据题意，我们维护两个set，一个主人s2一个宠物s1，一开始先分别插入一个极大值一个极小值，如果输入的是宠物，价值为b，就在s2中找到两个数t1,t2，分别是比当前b小的数的最大值，比当前b大的最小值。价值差就是
```cpp
max(b-t1,t2-b);
```
然后根据这个来加入更大一点的，如果已经没有可以找的了就把当前要找的存着以后用。

对于怎么找两个值，我们用lower_bound来解决，it是用Lower bound找大于等于b的第一个指针，那么it的前一个
数就是小于b的最大值。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=80005;
const int INF=1e9+10;
const int mod=1000005;
int n,ans;
set<int> s1,s2;
set<int>:: iterator it;
int main()
{
	scanf("%d",&n);
	s1.insert(-INF); s1.insert(INF);
	s2.insert(-INF); s2.insert(INF);
	for(int i=1,a,b;i<=n;i++)

	{
		scanf("%d%d",&a,&b);
		if(a==0)
		{
			if(s2.size()==2)
			{
				s1.insert(b);
				continue;
			}
			it=s2.lower_bound(b);
			int t2=*it,t1=*(--it),x1,x2;
			x1=b-t1; x2=t2-b;
			if(x1<=x2)
			{
				ans=(ans+x1)%mod;
				s2.erase(t1);
			}
			else
			{
				ans=(ans+x2)%mod;
				s2.erase(t2);
			}	
		}
		else
		{
			if(s1.size()==2)
			{
				s2.insert(b);
				continue;
			}
			it=s1.lower_bound(b);
			int t2=*it,t1=*(--it),x1,x2;
			x1=b-t1; x2=t2-b;
			if(x1<=x2)
			{
				ans=(ans+x1)%mod;
				s1.erase(t1);
			}
			else
			{
				ans=(ans+x2)%mod;
				s1.erase(t2);
			}
		}
	}
	printf("%d\n",ans);
	return 0;
}
```


然而这样会全WA。。。

因为当我们找最大值和最小值时，当有找不到的时，我们赋的极值就会影响答案，然后我就打了个看上去似乎挺冗杂的特判
```cpp
	if(t1==-INF)
	{
		ans=(ans+x2)%mod;
		s2.erase(t2);
	}
	else if(t2==INF)
	{
		ans=(ans+x1)%mod;
		s2.erase(t1);
	}
	else if(x1<=x2)
	{
		ans=(ans+x1)%mod;
		s2.erase(t1);
	}
	else if(x1>x2)
	{
		ans=(ans+x2)%mod;
		s2.erase(t2);
	}	
```
这样就OK啦

最后上个完整的码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=80005;
const int INF=1e9+10;
const int mod=1000000;
int n,ans;
set<int> s1;
set<int> s2;
set<int>:: iterator it;
int main()
{
	scanf("%d",&n);
	s1.insert(-INF); s1.insert(INF);
	s2.insert(-INF); s2.insert(INF);
	for(int i=1,a,b;i<=n;i++)
	{
		scanf("%d%d",&a,&b);
		if(a==0)
		{
			if(s2.size()==2)
			{
				s1.insert(b);
				continue;
			}
			it=s2.lower_bound(b);
			int t2=*it,t1=*(--it),x1,x2;
			if(t1==-INF&&t2==INF) continue;
			x1=b-t1; x2=t2-b;
			if(t1==-INF)
			{
				ans=(ans+x2)%mod;
				s2.erase(t2);
			}
			else if(t2==INF)
			{
				ans=(ans+x1)%mod;
				s2.erase(t1);
			}
			else if(x1<=x2)
			{
				ans=(ans+x1)%mod;
				s2.erase(t1);
			}
			else if(x1>x2)
			{
				ans=(ans+x2)%mod;
				s2.erase(t2);
			}	
		}
		else
		{
			if(s1.size()==2)
			{
				s2.insert(b);
				continue;
			}
			it=s1.lower_bound(b);
			int t2=*it,t1=*(--it),x1,x2;
			if(t1==-INF&&t2==INF) continue;
			x1=b-t1; x2=t2-b;
			if(t1==-INF)
			{
				ans=(ans+x2)%mod;
				s1.erase(t2);
			}
			else if(t2==INF)
			{
				ans=(ans+x1)%mod;
				s1.erase(t1);
			}
			else if(x1<=x2)
			{
				ans=(ans+x1)%mod;
				s1.erase(t1);
			}
			else if(x1>x2)
			{
				ans=(ans+x2)%mod;
				s1.erase(t2);
			}
		}
	}
	printf("%d\n",ans%mod);
	return 0;
}
```


---

## 作者：zl_just (赞：5)

[[HNOI2004]宠物收养场](https://www.luogu.org/problemnew/show/P2286)这题就是平衡树的板子  
但是仍有一些小坑  
发出来来让大家注意一下  

### 首先是题意(可能我语文不好,理解错了):
  
我本以为`宠物和人总是在一个时间段`  
指人与宠物之间要找到最优的方案以减少最终答案(那就很恶心了)  
但事实上就是单纯的模拟  
对人来说,如果还剩宠物就按照题意找出最佳的宠物并删除,否则就将人塞到另一颗树中
对宠物来说也是如此
## 也就是我们要有两颗树:

```cpp
    当有人来领宠物的时候
        如果宠物没了，就把人存起来； 
        否则就去找个满足要求的宠物让他领回去。
    当有宠物加入的时候，同理
```
看到有$Dalao$用技巧的,也有说写两颗树的,但我们完全可以利用$C++$写个类封装起来

$Class$如下(这只是要了解类怎么写就好了,$Treap$还是$Splay$看个人喜好,不会平衡树我也就很无奈了,~~不要再吐槽指针和码风了~~)  
注释应该很清晰了
```cpp
#include<cstdlib>

class Treap {
  private:
  //private修饰的话,只能再结构体内部访问
  static const int maxn = 80000;
  static const int INF = 1<<30;   //静态成员变量,一个属于结构体的变量
  int size;
  struct Node {
    int v,r,s;
    Node *ch[2];
    inline int cmp(int x) {  //通过比较函数可以很好的改变树的优先级
      if(x==v) return -1;
      return x>v;
    }
    inline int ch_size(int d) {
      return (ch[d]==NULL)?0:ch[d]->s;
    }
    inline void maintain() {
      s=1+ch_size(0)+ch_size(1);
    }
  }node[maxn];
  Node *root;
  //树根,初始话时为空
  inline void rotate(Node* &o,int d) {
    Node *k=o->ch[d^1]; o->ch[d^1]=k->ch[d]; k->ch[d]=o;
    o->maintain(); k->maintain(); o=k;
   }

  void insert_node(Node* &o,int x) {
    if(o==NULL) {
      o=&node[size++];
      o->v=x; o->r=rand();
      o->s=1;
      o->ch[0]=o->ch[1]=NULL;
    }
    else {
      int d=o->cmp(x);
      insert_node(o->ch[d],x); o->maintain();
      if(o->ch[d]->r > o->r) rotate(o,d^1);
    }
  }
  
  void remove_node(Node* &o,int x) {
    if(o==NULL) return ;
    int d=o->cmp(x);
    if(d==-1) {
      if(o->ch[0]==NULL) o=o->ch[1];
      else if(o->ch[1]==NULL) o=o->ch[0];
      else {
    int d2=(o->ch[0]->r > o->ch[1]->r);
    rotate(o,d2); remove_node(o->ch[d2],x);
      }
    }
    else remove_node(o->ch[d],x);
    if(o!=NULL) o->maintain();
  }

  int get_last(Node* o,int x) {
    int last=-INF;     //没有前驱时返回一个极小值
    while(o!=NULL) {
      if(o->v < x) last=o->v,o=o->ch[1];  //题面没说人和宠物的特点值不会相同,如果允许相同的话应改成 "<=",但玄学AC
      else o=o->ch[0];
    }
    return last;
  }

  int get_next(Node* o,int x) {
    int next=INF;
    while(o!=NULL) {
      if(o->v > x) next=o->v,o=o->ch[0];
      else o=o->ch[1];
    }
    return next;
  }

  public:  //允许在结构体外访问
  Treap() { root=NULL; size=0; }
  inline bool empty() { return root==NULL; }
  //包皮封装
  inline void insert(int x) {
    insert_node(root,x);
  }
  inline void remove(int x) {
    remove_node(root,x);
  }
  inline int last(int x) {
    return get_last(root,x);
  }
  inline int next(int x) {
    return get_next(root,x);
  }
}treap[2];
```
---
## 然后是主程序

了解题意后我们发现人和宠物没有区别 ~~(出题人的想法?)~~  
就可以利用取反运算一致对待了
```cpp
#include<cstdio>
#include<ctime>
const int mod = 1000000;
long long ans=0;

inline void read(int &a) {
    int c,f=1;  a=0;
    while((c=getchar()))  {
        if(c=='-') f=-1;
        if(c>='0'&&c<='9') break;
    }
    do {
        a=a*10+c-'0';
        c=getchar();
    }while(c>='0'&&c<='9');
    a*=f;
}

int main() {
  int n,p,x;
  read(n);
  while(n--) {
    read(p); read(x);
    if(treap[p^1].empty()) treap[p].insert(x);、
    //另一颗树为空,存起来
    else {  //找到符合题意的人(或宠物)并删去
      int a=treap[p^1].last(x),b=treap[p^1].next(x);
      if(x-a<=b-x) {
        ans=(ans+x-a)%mod;
        treap[p^1].remove(a);
      }
      else {
        ans=(ans+b-x)%mod;
        treap[p^1].remove(b);
      }
    }
  }
  printf("%lld\n",ans);
  return 0;
}
```

写起来真的很方便,大家为什么不喜欢指针呢 $QAQ$

---

## 作者：Tyher (赞：5)

我是用splay做的这道题……。

因为题目里面讲到在同一时间段只存在狗狗或人两种情况，所以splay里面只需要我们其实只用一颗splay维护狗狗和人的值就可以了

因为对于每次输入进去的op，它只有0和1两种状态，那么我们考虑用一个变量now，now的取值可以是0或者1,0代表splay里面存的是宠物，1代表里面存的是人

对于每一个输入进去的op，如果“(op^now)==0”，那么说明现在的输入的东西和splay里面的东西是一致的，直接加入就可以了，否则我们需要为他配对，因为题目提到存在相同的（a-b）和（a+b）的时候优先考虑（a-b),所以在配对，也就是删除操作的时候我们优先考虑前驱

至于为什么需要在一开始加入INF和-INF呢，因为在寻找前驱和后继的时候，如果后面（或前面）没有东西了，它好像会一直在里面找啊找（我猜的），所以我们可以现在里面加入两个端点（不会影响结果的）

最后一定要记得取mo



```
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define il inline
#define rg register
#define ll long long
#define N 50010
#define inf 2147483600
#define MOD 1000000
using namespace std;
int n,op,now,tot;//now为当前splay里面是人还是动物，0为宠物1为人
int u,root,ans,cnt;
struct T{
	int ch[2];
	int fa,val,size;
}te[N<<2];
il int read()
{
	rg int data=0,w=1;rg char c=getchar();
	while((c<'0'||c>'9')&&c!='-')c=getchar();
	if(c=='-')w=-1,c=getchar();
	while(c>='0'&&c<='9')data=(data<<3)+(data<<1)+c-'0',c=getchar();
	return w*data;
}
void rotate(rg int x){//splay的旋转操作
	int y=te[x].fa,z=te[y].fa;
	int k=(te[y].ch[1]==x);
	te[z].ch[te[z].ch[1]==y]=x;
	te[x].fa=z;
	te[y].ch[k]=(te[x].ch[k^1]);
	te[te[x].ch[k^1]].fa=y;
	te[x].ch[k^1]=y;
	te[y].fa=x;
}
void splay(rg int x,int goal){//将x转到goal的儿子处
	while(te[x].fa!=goal){
		int y=te[x].fa,z=te[y].fa;
		if(z!=goal)
			(te[z].ch[0]==y)^(te[y].ch[0]==x)?rotate(x):rotate(y);
		rotate(x);													  
	}
	if(!goal)root=x;
}
void find(rg int x){//寻找值为x的数 记得转到根节点处
	int u=root;
	if(!u)return;
	while(te[u].ch[x>te[u].val]&&x!=te[u].val)
		u=te[u].ch[x>te[u].val];
	splay(u,0);
}
void Insert(rg int x)//插入数x
{
	int u=root,fa=0;
	while(u){
		fa=u;
		u=te[u].ch[x>te[u].val];
	}
	u=(++tot);
	if(fa)
		te[fa].ch[x>te[fa].val]=u;
	te[u].ch[0]=te[u].ch[1]=0;
	te[tot].fa=fa,te[tot].val=x;
	te[tot].size=1;
	splay(u,0);
}
int Next(rg int x,rg int f){//寻找前驱和后继，对于f而言 0代表前驱1代表后继
	find(x);
	int u=root;
	if(te[u].val>x&&f)return u;
	if(te[u].val<x&&!f)return u;
	u=te[u].ch[f];
	while(te[u].ch[f^1])
		u=te[u].ch[f^1];
	return u;
}
void Delet(rg int x)//删除操作
{
	int last=Next(x,0),next=Next(x,1);
	splay(last,0),splay(next,last);
	te[next].ch[0]=0;
}
int main()
{
	n=read();
	Insert(-214748364),Insert(2147483607);
    //记得加入inf和-inf
	for(rg int i=1;i<=n;++i)
	{
		op=read(),u=read();
		if(cnt==0)
			now=op,Insert(u),cnt++;
            //如果现在splay内没有任何东西，可能是i=1的情况或者splay离得东西全部被匹配完，此时我们需要更新now来表示现在splay维护的是人还是狗，直接将now=op就可以了
		else if((op^now)==0)//如果splay里的东西和现在加入的东西相同的时候 我们可以直接考虑加入
			Insert(u),cnt++;
		else{//如果不同则需要配对
			int fir=Next(u,0),nex=Next(u,1);
			int q=abs(te[fir].val-u),h=abs(te[nex].val-u);
			if(q<=h)
				ans+=q,Delet(te[fir].val);
			else ans+=h,Delet(te[nex].val);
			cnt--,ans%=MOD;
		}
        //比较前驱和后继与当前的匹配值大小，删除考虑较小值并统计答案，如果相等的时候，优先考虑前驱动（题目要求）
	}
	cout<<ans;
    return 0;
}

```

---

## 作者：CreeperLordVader (赞：5)

### 看到那么多大佬用各种数据结构
##### 然而蒟蒻的我只会用STL set
具体思路~~很简单~~

对宠物和人各开一个集合

遇到人就用lower_bound查出宠物中大于等于他的预期值的第一个元素

这个地址再-1就可以得到小于他的预期值的最后一个元素

这两个值取和预期值最接近的那一个就好了

# sum一定一定要用long long
# 用int只有40分

具体细节看代码，思路已经讲过所以应该很好懂

code:

```cpp
#include<bits/stdc++.h>
using namespace std;
set<int>a;
set<int>b;
int n;
long long sum=0;
int main()
{
	cin>>n;
	for(int i=1; i<=n; i++)
	{
		int x,y;
		cin>>x>>y;
		if(i==1)
		{
			if(x==0)
			{

				a.insert(y);
			}
			else
			{
				b.insert(y);
			}
		}
		else
		{
			if(x==0)
			{
				a.insert(y);
				if(!b.empty())
				{
					if(y>*(--b.end()))
					{
						sum+=abs(y-*(--b.end()));
						a.erase(y);
						b.erase(*(--b.end()));
					}
					else if(y<*b.begin())
					{
						sum+=abs(y-*(b.begin()));
						a.erase(y);
						b.erase(*(b.begin()));
					}
					else
					{
						int k=*(b.lower_bound(y));
						int l=*(--b.lower_bound(y));
						if(abs(y-k)>=abs(y-l))
						{
							sum+=abs(y-l);
							a.erase(y);
							b.erase(l);
						}
						else
						{
							sum+=abs(y-k);
							a.erase(y);
							b.erase(k);
						}
					}
				}
			}
			else
			{
				b.insert(y);
				if(!a.empty())
				{
					if(y>*(--a.end()))
					{
						sum+=abs(y-*(--a.end()));
						b.erase(y);
						a.erase(*(--a.end()));
					}
					else if(y<*a.begin())
					{
						sum+=abs(y-*(a.begin()));
						b.erase(y);
						a.erase(*(a.begin()));
					}
					else
					{
						int k=*(a.lower_bound(y));
						int l=*(--a.lower_bound(y));
						if(abs(y-k)>=abs(y-l))
						{
							sum+=abs(y-l);
							b.erase(y);
							a.erase(l);
						}
						else
						{
							sum+=abs(y-k);
							b.erase(y);
							a.erase(k);
						}
					}
				}
			}
		}
	}
	cout<<sum%1000000<<endl;
}
```


---

## 作者：xxseven (赞：4)

这道题我是拿权值树状数组搭配离散化 $O(n \log n)$ 水过的，码量很小并且只用一棵树。这篇题解里就会讲解这种做法。

### 前言：

**并非所有**需要平衡树的题目都能用权值树状数组代替。

受限于树状数组的性质，如果需要处理本题这样值域较大的数据，需要**先进行离散化**，因此必须离线。如果题目强制要求在线，那么权值树状数组就只能处理**值域较小**的数据了。

### 解法：

以下记树状数组**维护的桶**为 $g$,树状数组为 $t$。

分析题意，发现这道题要实现这么几个操作：插入，删除，求前驱，求后继。

权值树状数组上的插入和删除都很简单，插入即 $g_i \gets g_i+1$，删除即$g_i \gets g_i-1$。

那么，问题的关键在于在 $O(\log n)$ 的复杂度内求出前驱和后继。  

记 $krank(k)$ 为当前树状数组中第 $k$ 小的数，$sum(k)$ 为当前树状数组中权值不大于 $k$ 的数的数量，那么：  
$k$ 的前驱可以表示为 $krank(sum(k-1))$。  
$k$ 的后继可以表示为 $krank(sum(k)+1)$。
![](https://cdn.luogu.com.cn/upload/image_hosting/cy2tjvb3.png)

现在，我们就把求前驱和后继的问题转化为了求一个权值树状数组上第 $k$ 小的问题。  
对于这个问题，可以利用树状数组的性质倍增解决。  
对于一个树状数组上的位置 $x$ ,如果加上一个小于  $\operatorname{lowbit}(x)$ 的 $2^i$ ，那么 $sum(x)$ 增加的值正好就是跳过的一片区域的总权值。  
例如：$sum(6)-sum(4)=g_5+g_6=t_6$。
因此考虑倍增，从 $0$ 开始依次尝试让 $x$ 往后跳 $2^{\log n},2^{\log n-1},2^{\log n-2},...,2^0$，每次跳跃都将一个数加上树状数组对应位置的权值，根据当前数的大小来判断是否能执行本次跳跃。   
给出倍增求 $krank$ 的方法如下，其中 $T= \log_2 n$：
```cpp
int krank(int k){
	int pos=0,val=0;
	for(int i=T,x,y;i>=0;--i){
		x=pos+(1<<i);
		if(x>bn) continue;
		y=val+t[x];
		if(y<k) pos=x,val=y;
	}
	return b[pos+1];
}
```

此外，对于当前树状数组中存储的是宠物还是领养者，可以使用正负数来做处理，这样可以只使用一个树状数组就实现按照题意的模拟。

代码和注释如下：

```cpp
#include<bits/stdc++.h>
#define ID(y) lower_bound(b+1,b+bn+1,y)-b
#define h(x) ((x==1)?-1:1) //用h(x)转换类型，宠物记作1，领养者记作-1
#define int long long 
using namespace std;
const int N=8e4+5,inf=1e12;
int t[N],a[N],b[N],bn,T;
int n,cnt,ans;

struct node{
	int op,v;
}f[N];

int lowbit(int x){
	return x&(-x);
}

void add(int pos,int x){
	while(pos<=bn){
		t[pos]+=x;
		pos+=lowbit(pos);
	}
}

int sum(int pos){
	int res=0;
	while(pos){
		res+=t[pos];
		pos-=lowbit(pos);
	}
	return res;
}

int krank(int k){
	if(k<1) return -inf;
	if(k>abs(cnt)) return inf; //特判不存在前驱或后继的情况
	int pos=0,val=0;
	for(int i=T,x,y;i>=0;--i){
		x=pos+(1<<i);
		if(x>bn) continue;
		y=val+t[x];
		if(y<k) pos=x,val=y;
	}
	return b[pos+1];
}

signed main(){
	cin>>n;
	for(int op,v,i=1;i<=n;++i){
		cin>>op>>v;
		f[i].op=op; f[i].v=v;
		a[++cnt]=v; b[cnt]=v;
	}
	sort(b+1,b+n+1);
	bn=unique(b+1,b+n+1)-b-1; T=log2(bn); cnt=0;
	for(int i=1,x,y,A,B;i<=n;++i){
		x=f[i].op; y=f[i].v;
		if(h(x)*cnt<0){    //根据乘法的性质，两者之积为负数即代表加入元素与树中元素不同类
			A=krank(sum(ID(y)-1)); B=krank(sum(ID(y))+1); 
			if(y-A<=B-y) add(ID(A),-1),ans+=(y-A);
			else add(ID(B),-1),ans+=(B-y);
		}
		else add(ID(y),1);
		cnt+=h(x); //利用cnt的大小和正负存储当前树状数组中元素的类型和个数
	}
	cout<<ans%1000000;
	return 0;
}

```

希望这篇题解能够帮到你！

---

## 作者：Drifterming (赞：4)

```cpp
/*
	这个题一开始只开了一颗treap，但是zbq告诉我说，
	那些没领着宠物的人不会走，
	直到有宠物可以领或者是直到输入完数据也没有宠物可以领，然后失望的回家。
	（其实这是题目里说了的   没get到题目意思） 
	所以我们肯定不能把那些没有领猫的人扔了，我们要把他们存起来，
	所以我们开两颗treap，一颗存宠物，一颗存人。
	
	当有人来领宠物的时候，就判断：
		如果当前没有宠物，就把人存起来； 
		否则就去宠物树里找个满足要求的宠物让他领回去。
	当有宠物加入的时候，就判断：
		如果当前没有人来领养宠物，就把宠物存起来，
		否则就去人树里给它找个最合适的主领回去。
	
	怎么找宠物和主人：
		因为是找最接近要求的人和宠物，
		所以我们按当前的要求x找对应的pre（前驱）和nxt（后继），表示比x小的中最大的那个、比x大的中最小的那个 
		然后判断哪个更优，让答案加上这个最优解的贡献，最后把这个最优解给erase掉。
	
	因为我使用指针写的，自定义的null，所以不能直接扔到结构体里面封装起来做，但是有黑科技叫做namespace， 用namespace开两个空间，
	一个空间一颗treap，然后做就行了。
	
	代码比较长，但是其实有一半的东西是完全一样的 两颗namespace里的东西是完完全全一个样的。 
*/ 
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<ctime>
using namespace std;

const long long N=8e4+5;
const long long mod=1000000;
const long long INF=2147483647;

long long n,opt,x;

long long read()
{
	char c=getchar();long long num=0,f=1;
	for(;!isdigit(c);c=getchar())
		f=c=='-'?-1:f;
	for(;isdigit(c);c=getchar())
		num=num*10+c-'0';
	return num*f;
}

namespace Pet	//宠物树 
{
	struct Node
	{
		Node *son[2];
		long long key;
		long long heap_key;
		long long size;
	}node[N],_null;
	
	typedef Node* Tree;
	Tree null,root,now_node;	//null是自定义的空节点 
	
	void init()		//初始化 
	{
		srand(time(NULL));
		now_node=node;
		null=root=&_null;
		null->son[0]=null->son[1]=null;		//左右儿子等于空节点本身 
	}
	
	Tree newNode(long long key)		//新开节点 
	{
		++now_node;
		now_node->key=key;
		now_node->size=1;
		now_node->heap_key=rand();
		now_node->son[0]=now_node->son[1]=null;		//左右儿子等于空节点 
		return now_node;
	}
	
	void rotate(Tree &root,bool flag)	//旋转 
	{
		Tree tmp=root->son[!flag];
		root->son[!flag]=tmp->son[flag];
		tmp->son[flag]=root;
		root->size=root->son[0]->size+root->son[1]->size+1;
		tmp->size=tmp->son[0]->size+tmp->son[1]->size+1;
		root=tmp;
	}
	
	void insert(Tree &root,long long key)	//插入 
	{
		if(root==null)
			root=newNode(key);
		else
		{
			bool flag=key>root->key;
			insert(root->son[flag],key);
			++root->size;
			if(root->heap_key<root->son[flag]->heap_key)
				rotate(root,!flag);
		}
	}
	
	void erase(Tree &root,long long key)	//delete 用erase是因为、、、我与众不同 
	{
		if(root==null)
			return;
		if(key!=root->key)
		{
			bool flag=key>root->key;
			erase(root->son[flag],key);
			--root->size;
		}
		else
		{
			if(root->son[0]==null)
				root=root->son[1];
			else if(root->son[1]==null)
				root=root->son[0];
			else
			{
				bool flag=root->son[0]->heap_key>root->son[1]->heap_key;
				rotate(root,flag);
				erase(root->son[flag],key);
				--root->size;
			}
		}
	}
	
	long long query_pre(Tree root,long long x)		//查前驱 
	{
		if(root==null)
			return -INF;
		if(root->key==x)
			return x;
		if(x>root->key)
			return max(root->key,query_pre(root->son[1],x));
		return query_pre(root->son[0],x);
	}
	
	long long query_nxt(Tree root,long long x)		//查后继 
	{
		if(root==null)
			return INF;
		if(root->key==x)
			return x;
		if(root->key<x)
			return query_nxt(root->son[1],x);
		return min(root->key,query_nxt(root->son[0],x));
	}
}

namespace Peo	//人树 ，里面的东西是从宠物树里粘的，内容一样 
{
	struct Node
	{
		Node *son[2];
		long long key;
		long long heap_key;
		long long size;
	}node[N],_null;
	
	typedef Node* Tree;
	Tree null,root,now_node;
	
	void init()
	{
		srand(time(NULL));
		now_node=node;
		null=root=&_null;
		null->son[0]=null->son[1]=null;
	}
	
	Tree newNode(long long key)
	{
		++now_node;
		now_node->key=key;
		now_node->size=1;
		now_node->heap_key=rand();
		now_node->son[0]=now_node->son[1]=null;
		return now_node;
	}
	
	void rotate(Tree &root,bool flag)
	{
		Tree tmp=root->son[!flag];
		root->son[!flag]=tmp->son[flag];
		tmp->son[flag]=root;
		root->size=root->son[0]->size+root->son[1]->size+1;
		tmp->size=tmp->son[0]->size+tmp->son[1]->size+1;
		root=tmp;
	}
	
	void insert(Tree &root,long long key)
	{
		if(root==null)
			root=newNode(key);
		else
		{
			bool flag=key>root->key;
			insert(root->son[flag],key);
			++root->size;
			if(root->heap_key<root->son[flag]->heap_key)
				rotate(root,!flag);
		}
	}
	
	void erase(Tree &root,long long key)
	{
		if(root==null)
			return;
		if(key!=root->key)
		{
			bool flag=key>root->key;
			erase(root->son[flag],key);
			--root->size;
		}
		else
		{
			if(root->son[0]==null)
				root=root->son[1];
			else if(root->son[1]==null)
				root=root->son[0];
			else
			{
				bool flag=root->son[0]->heap_key>root->son[1]->heap_key;
				rotate(root,flag);
				erase(root->son[flag],key);
				--root->size;
			}
		}
	}
	
	long long query_pre(Tree root,long long x)
	{
		if(root==null)
			return -INF;
		if(root->key==x)
			return x;
		if(x>root->key)
			return max(root->key,query_pre(root->son[1],x));
		return query_pre(root->son[0],x);
	}
	
	long long query_nxt(Tree root,long long x)
	{
		if(root==null)
			return INF;
		if(root->key==x)
			return x;
		if(root->key<x)
			return query_nxt(root->son[1],x);
		return min(root->key,query_nxt(root->son[0],x));
	}
}

int main()
{
	Pet::init();	//初始化宠物树 
	Peo::init();	//初始化人树 
	long long ans=0;
	n=read();
	while(n--)
	{
		opt=read(),x=read();
		if(opt==0)	//有新宠物 
		{
			if(Peo::root==Peo::null)	//如果没人领 
			{
				Pet::insert(Pet::root,x);	//把宠物搁着 
			}
			else	//找个最合适的主领回去 
			{
				long long a=Peo::query_pre(Peo::root,x);
				long long b=Peo::query_nxt(Peo::root,x);
				if(abs(x-a)<=abs(x-b))		//看看哪个主更合适 
				{
					ans+=abs(x-a);
					Peo::erase(Peo::root,a);	//把这个主删了，表示他已经有宠物了 
				}
				else
				{
					ans+=abs(x-b);
					Peo::erase(Peo::root,b);			
				}
			}
		}
		else	//人，和宠物的一样 
		{
			if(Pet::root==Pet::null)
			{
				Peo::insert(Peo::root,x);
			}
			else
			{
				long long a=Pet::query_pre(Pet::root,x);
				long long b=Pet::query_nxt(Pet::root,x);
				if(abs(x-a)<=abs(x-b))
				{
					ans+=abs(x-a);
					Pet::erase(Pet::root,a);
				}
				else
				{
					ans+=abs(x-b);
					Pet::erase(Pet::root,b);			
				}
			}
		}
	}
	printf("%d",ans%mod);
	return 0;
}
```

---

## 作者：George1123 (赞：3)



# 题解-[HNOI2004]宠物收养场

[$\texttt{read this in blog}$](https://blog.csdn.net/KonnyWen/article/details/104556679)

### $\texttt{Introduction}$
蒟蒻初学平衡树，见此题无妙解，乃记之。

---
### $\texttt{Description}$
> [\[HNOI2004\]宠物收养场](https://www.luogu.com.cn/problem/P2286)

> 有 $n$ 个宠物或主人会来，每个来者都有性格 $a$。如果当前主人有剩余，宠物 $x$ 就会领走一个和它性格最相近的主人 $y$，如果另有主人 $z$ 使 $|a_x-a_y|==|a_x-a_z|$，那么就选 $a$ 小一点的主人。同理，如果宠物有剩余，主人会用相同方法领走宠物。求最后每对宠物-主人的性格差的和 $\mod 1000000$。

> 数据范围：$1\le n\le 80000,1\le a< 2^{31}$。

---
### $\texttt{Solution}$
用平衡树维护“性格最接近”。

如果开两个平衡树分别代表主人和宠物，因为如果主人来时有宠物或者宠物来时有主人，就会直接领走，所以**至多一个平衡树是非空的**。因此，可以标记是哪个平衡树非空，然后用一个平衡树代替非空平衡树。

设标记为 $winner$，如果 $winner==2$，表示两个平衡树都是空的（即没有主人，没有宠物）；如果 $winner=0$ 表示有宠物没有主人，如果 $winner=1$ 表示有主人没有宠物。每次领走主人或领走宠物之后，如果平衡树空了，就设 $winner=2$。思想很简单，只需一个标记和一棵树解决问题，具体看代码。

---
### $\texttt{Code}$

```cpp
#include <bits/stdc++.h>
using namespace std;

//&Start
#define lng long long
const int inf=0x3f3f3f3f;
const lng Inf=1e16;

//&Start
bool open(0);
#define Debug if(open)

//&Splay
template<int N,class T>struct Splaytree{//压行Splay平衡树膜拜
	int sz,rt,sm[N],re[N],fa[N],ch[N][2]; T key[N];
	void clear(int x){key[x]=sm[x]=re[x]=fa[x]=ch[x][0]=ch[x][1]=0;}
	bool dire(int x){return ch[fa[x]][1]==x;}
	void pushup(int x){sm[x]=re[x]+sm[ch[x][0]]+sm[ch[x][1]];}
	void connect(int x,int f,bool d){fa[x]=f,ch[f][d]=x;}
	int newnode(T v,int f){return clear(++sz),key[sz]=v,fa[sz]=f,sm[sz]=re[sz]=1,sz;}
	void rotate(int x){
		int f=fa[x],ff=fa[f],dx=dire(x),df=dire(f);
		connect(ch[x][dx^1],f,dx),connect(f,x,dx^1),connect(x,ff,df),pushup(f),pushup(x);
	}
	void splay(int x){for(int f;(f=fa[x]);rotate(x))if(fa[f]) rotate(dire(x)==dire(f)?f:x); rt=x;}
	void insert(T v){
		if(!rt) return rt=newnode(v,0),void();
		for(int x=rt,f=0;1;){
			if(key[x]==v) return re[x]++,pushup(x),pushup(f),splay(x),void();
			if(!(f=x,x=ch[f][v>key[x]])) return ch[f][v>key[f]]=newnode(v,f),pushup(f),splay(sz),void();
		}
	}
	int find(T v){
		for(int x=rt,res=0;1;){
			if(v<key[x]){x=ch[x][0];continue;} res+=sm[ch[x][0]];
			if(v==key[x]) return splay(x),res+1; res+=re[x],x=ch[x][1];
		}
	}
	T kth(int k){
		for(int x=rt;1;){
			if(k<=sm[ch[x][0]]){x=ch[x][0];continue;} k-=sm[ch[x][0]];
			if(k<=re[x]) return splay(x),key[x]; k-=re[x],x=ch[x][1];
		}
	}
	int pre(){int x=ch[rt][0],rs;while((rs=ch[x][1])) x=rs;return x;}
	int nex(){int x=ch[rt][1],ls;while((ls=ch[x][0])) x=ls;return x;}
	void dest(T v){
		int tmp=find(v);
		if(re[rt]>1) return re[rt]--,pushup(rt),void();
		if(!ch[rt][0]&&!ch[rt][1]) return clear(rt),rt=sz=0,void();
		if(!ch[rt][0]) return tmp=rt,fa[rt=ch[rt][1]]=0,clear(tmp),void();
		if(!ch[rt][1]) return tmp=rt,fa[rt=ch[rt][0]]=0,clear(tmp),void();
		tmp=rt,splay(pre()),connect(ch[tmp][1],rt,1),clear(tmp),pushup(rt);
	}
	int size(){return sm[rt];}
};

//&Main
const int N=8e4+10,mod=1e6;
int n,ans,winner=2;//刚开始时没有宠物，没有主人
Splaytree<80010,lng> F;
//因为数据范围达到了int极限，所以为了方便，开成long long的平衡树
int main(){
	scanf("%d",&n);
	F.insert(-Inf),F.insert(Inf);
	//防止没有前驱或没有后继时平衡树卡bug
	for(int i=1;i<=n;i++){
		int o;lng x,l,r;
		scanf("%d%lld",&o,&x);
		Debug printf("%d\n",winner);
		if(o==winner||winner==2) F.insert(x),winner=o;
		//如果只有同类或没东西，之间进入平衡树
		else {//如果只有异类（配偶）
			F.insert(x),l=F.key[F.pre()],r=F.key[F.nex()],F.dest(x);
			//先把自己放到平衡树中，找个前驱后继（性格最相近的配偶）
			Debug printf("%lld %lld\n",l,r);
			if(x-l<=r-x) (ans+=x-l)%=mod,F.dest(l);//如题
			else (ans+=r-x)%=mod,F.dest(r);
			if(F.size()<=2) winner=2;
			//即平衡树为空，size<=2是因为平衡树中有-inf和inf
		}
	}
	printf("%d\n",ans);
	return 0;
}
```
**祝大家学习愉快！**

---

## 作者：ChenHacker (赞：3)

#### 更新原因：贴错代码

#### 为了您现在及以后获得更好的阅读体验[~~强行安利blog~~](https://ch66.cf/index.php/302)

思路和yybyyb差不多，但还是有区别的，~~没有思路雷同~~ 宠物和主人之间转换巧妙利用异或原理，缩短代码量

yybyyb大佬维护一颗splay，可我只会treap，精华主要还是在主程序啦

```cpp
#include<bits/stdc++.h>
using namespace std;

int read() {
	int x=1,ans=0;char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') x*=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){ans=ans*10+ch-48;ch=getchar();}
	return x*ans;
}

const int N=80008;

struct Node {
	int l,r,val,pri,cnt;
}t[N];

int n,rt,top,ans;

inline void zig(int& k) {int y=t[k].l;t[k].l=t[y].r;t[y].r=k;k=y;}//右旋
inline void zag(int& k) {int y=t[k].r;t[k].r=t[y].l;t[y].l=k;k=y;}//左旋

void add(int& k,int val) {//添加
	if(!k) { k=++top; t[k].val=val; t[k].pri=rand(); t[k].l=t[k].r=0; t[k].cnt=1; return; }
	if(t[k].val==val) {t[k].cnt++; return; }
	if(val<t[k].val) {
		add(t[k].l,val);
		if(t[t[k].l].pri<t[k].pri) zig(k);
	}
	else {
		add(t[k].r,val);
		if(t[t[k].r].pri<t[k].pri) zag(k);
	}
}

void rem(int& k,const int& val) {//删除(remove)
	if(t[k].val==val) {
		if(t[k].cnt>1) t[k].cnt--;
		else if(!t[k].l||!t[k].r) k=t[k].l+t[k].r;
		else if(t[t[k].l].pri<t[t[k].r].pri) zig(k),rem(k,val);
		else zag(k),rem(k,val);
		return;
	}
	if(val<t[k].val) rem(t[k].l,val);
	else rem(t[k].r,val);
}

inline int qpre(const int& val) {//寻找比小于等于val中最大的数
	int k=rt,res=0;
	while(k) {
		if(t[k].val==val) return val;
		if(t[k].val<val) res=t[k].val,k=t[k].r;
		else k=t[k].l;
	}
	return res;
}

inline int qnxt(const int& val) {//寻找大于等于val中最小的数
	int k=rt,res=0;
	while(k) {
		if(t[k].val==val) return val;
		if(t[k].val>val) res=t[k].val,k=t[k].l;
		else k=t[k].r;
	}
	return res;
}

inline int ask(const int& val) {//利用上面两个函数猥琐得出答案
	int l=qpre(val),r=qnxt(val);
	if(l==0) return r;
	if(r==0) return l;
	if(l==val||r==val) return val;
	if(val-l==r-val) return l;
	if(val-l<r-val) return l;
	return r;
}

int main() {
	n=read();
	bool now=0;
	while(n--) {
		bool x=read();int val=read(); 
		if(x^now) add(rt,val);//if判断巧妙异或
		else {
			if(!rt) { now^=1; add(rt,val); continue;}//异或偷懒
			int res=ask(val);
			ans=(ans+abs(res-val))%1000000;//千万不要忘记取模！！！我经常犯这个错误！
			rem(rt,res);
		}
	}
	printf("%d\n",ans);	//华丽output
	return 0;
}

```

---

## 作者：吾王美如画 (赞：3)

# 唔姆
（感觉treap党不多？？？

-----------
看完题目，发现要找差值最小的，这不就是比较平衡树的前驱和后缀吗（~~板子题啊~~）

先开始我是直接两个treap无脑莽过去的

- 如果来了一只宠物，且有顾客等待，就到顾客的树里找前驱后缀比较，看哪个更小，并把这个顾客删掉。顾客反之。
- 如果来了一只宠物，而正巧这是没有顾客等待，那么我们就把这只宠物存到平衡树里，顾客反之。

但等我ac之后突然想到，根本就不用两课treap，因为如果有顾客在等的话，那么现在肯定没有宠物了。那么我们就只要开一个treap就行了。

最后，记得开longlong

```cpp
#include<bits/stdc++.h>
#define MAXN 101000
#define INF 0x3f3f3f3f
using namespace std;
int sum=1,R=0;
int son[MAXN][2],num[MAXN],size[MAXN],tree[MAXN],rd[MAXN],n;
void up(int now){
     size[now]=size[son[now][0]]+size[son[now][1]]+num[now];
}
void rotate(int &now,int d){
     int to=son[now][!d];
     son[now][!d]=son[to][d];
     son[to][d]=now;
     up(now);
     up(to);
     now=to;
}
void change(int &now,int x){
     if (!now){now=++sum;size[now]=num[now]=1;tree[now]=x;rd[now]=rand();return;}
     else if(tree[now]==x){num[now]++;size[now]++;return;}; 
     int tmp=(x>tree[now]);
     change(son[now][tmp],x);
     if (rd[now]>rd[son[now][tmp]])rotate(now,!tmp);
     up(now);
}
void del(int &now,int x){
     if(!now)return;
     if (x==tree[now]){
                       if(!son[now][0]&&!son[now][1]){
                                                      num[now]--;size[now]--;
                                                      if(!num[now])now=0;
                       }
                       else if(son[now][0]&&!son[now][1]){
                                                          rotate(now,1);
                                                          del(son[now][1],x);
                       }
                       else if(!son[now][0]&&son[now][1]){
                                                          rotate(now,0);
                                                          del(son[now][0],x);
                       }
                       else {int tmp=(rd[son[now][0]]>rd[son[now][1]]);
                            rotate(now,tmp);
                            del(son[now][tmp],x);
                       }
     }
     else{
          int tmp=(x>tree[now]);
          del(son[now][tmp],x);
     }
     up(now);
}
int pre(int now,int x){
    if(!now)return -INF;
    if (tree[now]>=x)return pre(son[now][0],x);
    else return max(tree[now],pre(son[now][1],x));
}
int suc(int now,int x){
    if(!now)return INF;
    if (tree[now]<=x)return suc(son[now][1],x);
    else return min(tree[now],suc(son[now][0],x));
}
int main(){
    cin>>n;
    memset(son,0,sizeof(son));
    int cnt[]={0,0};
    int ans=0;
    for(int i=1;i<=n;i++){
            int a,b;
            scanf("%d%d",&a,&b);
            if (cnt[a^1]){
                int x=pre(R,b),y=suc(R,b);
                if (abs(b-x)<=abs(y-b)){
                    ans=(ans+abs(b-x))%1000000;
                    del(R,x);
                    cnt[a^1]--;
                }
                else{
                    ans=(ans+abs(b-y))%1000000;
                    del(R,y);
                    cnt[a^1]--;
                }
            }
            else{
                change(R,b);
                cnt[a]++;
            }
    }
    cout<<ans;
    return 0;
}

```


---

## 作者：chengni (赞：3)

来一个动态开点线段树做法

事实上这题就四个操作，插入，删除，找前驱，找后继

前两个都很简单对吧，那么后两个线段树能做吗？

当然能做

首先我们搞一棵权值线段树，然后要查询 $x$ 的前驱

首先我们肯定不会询问 $l>x$ 的区间，然后我们不会访问没有数的区间

如果他的两个儿子结点都满足条件该怎么办呢

我们先访问右儿子，如果右儿子可以，那么返回值，否则再访问左儿子

因为我们要找的是前驱，右儿子肯定比左儿子要优

找到符合条件的返回就可以了

查询后继同理可得

有了这四个操作后面应该都会了吧，对于宠物树（领养树）维护一下就好了

然后我们就可以用线段树把这道平衡树水过去了

线段树部分代码在下面


```cpp
struct node{
	int ls,rs;
	int l,r;
	int s;
}t[40040400];

int cnt=0,root;

void insert(int &p,int l,int r,int x){//动态开点插入
	if(p==0){
		p=++cnt;
	}
	t[p].s++;
	t[p].l=l;t[p].r=r;
	if(l==r){
		return;
	}
	int mid=l+r>>1;
	if(x<=mid) insert(t[p].ls,l,mid,x);
	else insert(t[p].rs,mid+1,r,x);
}

void del(int &p,int x){//删除
	if(p==0){
		p=++cnt;
	}
	t[p].s--;
	if(t[p].l==t[p].r){
		return;
	}
	int mid=t[p].l+t[p].r>>1;
	if(x<=mid) del(t[p].ls,x);
	else del(t[p].rs,x);
}

int findl(int p,int x){//查询前驱
	if(t[p].l>x) return -1;//不满足条件
	if(t[p].s==0) return -1;//没有数
	if(t[p].l==t[p].r){
		return t[p].l;
	}
	int mid=t[p].l+t[p].r;
	int res=findl(t[p].rs,x);//先访问右边
	if(res!=-1) return res;
	else return findl(t[p].ls,x);//不行的话再左边
}

int findr(int p,int x){//查询后继，和上面差不多
	if(t[p].r<x) return -1;
	if(t[p].s==0) return -1;
	if(t[p].l==t[p].r){
		return t[p].l;
	}
	int mid=t[p].l+t[p].r;
	int res=findr(t[p].ls,x);
	if(res!=-1) return res;
	else return findr(t[p].rs,x);
}

```

~~线段树敲好玩~~

---

## 作者：wrpwrp (赞：2)

看到前驱后继，所以第一，很显然这是个平衡树裸题对吧。。。
然后想到fhqtreap代码量比较小就开写，把板子打好之后突然发现前驱后继不一定存在
~~然后重写~~
所以其实我们只要一开始加入inf和-inf就可以处理边界问题了。然后...就是板子了....
```cpp
#include <cstdio>
#include <cstdlib>
#define R register
#define MAXN 80000+5
#define inf 2147483647/2
#define mod 1000000

int n;

struct fhq_treap
{
	struct Node
	{
		int lson,rson,siz,dat,rnd;
	}t[MAXN];
	int root,tot;
	#define ls(x) t[x].lson
	#define rs(x) t[x].rson
	#define siz(x) t[x].siz
	#define v(x) t[x].dat
	#define rnd(x) t[x].rnd
	
	inline int New(int x)
	{
		tot++;
		v(tot)=x;
		siz(tot)=1;
		rnd(tot)=rand();
		return tot;
	}
	
	inline void update(int x)
	{
		siz(x)=siz(ls(x))+siz(rs(x))+1;
	}
	
	inline int merge(int x,int y)
	{
		if(!x||!y) return x|y;
		if(rnd(x)<rnd(y))
		{
			rs(x)=merge(rs(x),y);
			update(x);return x;
		}
		else
		{
			ls(y)=merge(x,ls(y));
			update(y);return y;
		}
	}
	
	inline void split(int now,int k,int &x,int &y)
	{
		if(!now)
		{
			x=y=0;
			return;
		}
		if(v(now)<=k)
		{
			x=now;
			split(rs(now),k,rs(now),y);
		}
		else
		{
			y=now;
			split(ls(now),k,x,ls(now));
		}
		update(now);
		return;
	}
	
	inline int kth(int now,int k)
	{
		while(1)
		{
			if(k<=siz(ls(now))) now=ls(now);
			else
			{
				if(k==siz(ls(now))+1) return now;
				k=k-(siz(ls(now))+1);
				now=rs(now);
			}
		}
	}
	
	inline void insert(int x)
	{
		int a,b;
		split(root,x,a,b);
		root=merge(merge(a,New(x)),b);
	}
	
	inline void del(int x)
	{
		int a,b,c;
		split(root,x,a,c);
		split(a,x-1,a,b);
		b=merge(ls(b),rs(b));
		root=merge(merge(a,b),c);
	}
	
	inline int pre(int x)
	{
		int a,b,res;
		split(root,x-1,a,b);
		res=v(kth(a,siz(a)));
		root=merge(a,b);
		return res;
	}
	
	inline int suc(int x)
	{
		int a,b,res;
		split(root,x,a,b);
		res=v(kth(b,1));
		root=merge(a,b);
		return res;
	}
	
	inline void build()
	{
		insert(inf);insert(-inf);
	}
	
	inline int size()
	{
		return siz(root)-2;
	}
}T1,T2;

inline int get()
{
	char a=getchar();
	int x=0,f=1;
	for(;a>'9'||a<'0';a=getchar()) if(a=='-') f=-1;
	for(;a>='0'&&a<='9';a=getchar()) x=x*10+a-'0';
	return x*f;
}

int main()
{
	n=get();
	T1.build();
	T2.build();
	R int res=0;
	R int a,b,l,r;
	while(n--)
	{
		a=get();b=get();
		if(a==0)
		{
			if(T2.size()==0) T1.insert(b);
			else
			{
				l=T2.pre(b+1);
				r=T2.suc(b-1);
				if(b-l<=r-b) 
				{
					res+=b-l;res%=mod;
					T2.del(l);
				}
				else
				{
					res+=r-b;res%=mod;
					T2.del(r);
				}
			}
		}
		else
		{
			if(T1.size()==0) T2.insert(b);
			else
			{
				l=T1.pre(b+1);
				r=T1.suc(b-1);
				if(b-l<=r-b) 
				{
					res+=b-l;res%=mod;
					T1.del(l);
				}
				else
				{
					res+=r-b;res%=mod;
					T1.del(r);
				}
			}
		}
	}
	printf("%d\n",res);
	return 0;
}
```


其实我觉得我码风海鑫(✿◡‿◡)
不过为什么我的treap这么慢555

---

## 作者：RPChe_ (赞：2)

此题思路还是很简单的，考虑到同一时间呆在收养所中的，要么全是宠物，要么全是领养者，因此我们只需要用平衡树来维护一下，求一下前驱和后继就行。这里我们就用treap来实现，因为码量小~~而且我不会splay~~。

但是，我发现其他题解在处理数据时写得都很长，大多都分了4类讨论。但实际上，如果我们使用一个栈来维护，代码会简短不少。

刚开始声明一个栈，如果栈为空或栈顶元素跟当前元素种类相同，就直接把当前元素入栈并插入平衡树。

如果栈不为空且栈顶元素跟当前元素种类不相同，就弹出栈顶元素并找当前元素的前驱和后继，累加答案并删除前驱和后继中较优的一个，注意到优先考虑前驱。

这样我们就可以得到一份~~用平衡树维护的~~最短代码。（129行）

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<stdlib.h>
#include<ctime>
#include<stack>
#define maxn 500005
#define up(i,a,b) for(int i=a;i<=b;i++)
#define inf 0x3f3f3f3f
using namespace std;

inline int read() {
	int f=1,x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-f;ch=getchar();}
	while('0'<=ch&&ch<='9') x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
	return x*f;
}

void write(int x) {
	if(x<0) x=-x,putchar('-');
	if(x>9) write(x/10);
	putchar(x%10+'0');
}

struct node{
	int ls,rs,c,siz,pri,v;
	#define ls(x) nod[x].ls
	#define rs(x) nod[x].rs
	#define c(x) nod[x].c
	#define siz(x) nod[x].siz
	#define pri(x) nod[x].pri
	#define v(x) nod[x].v
}nod[maxn];
int n,cnt,rt,x[maxn],y[maxn],cnt1,ans,sig[maxn];
stack<int> s;

void update(int &k) {siz(k)=siz(ls(k))+siz(rs(k))+c(k);}

void zig(int &k) {
	int ls=ls(k);
	ls(k)=rs(ls);
	rs(ls)=k;
	siz(ls)=siz(k);
	update(k);
	k=ls;
}

void zag(int &k) {
	int rs=rs(k);
	rs(k)=ls(rs);
	ls(rs)=k;
	siz(rs)=siz(k);
	update(k);
	k=rs;
}

void insert(int &k,int v) {
	if(!k) {
		k=++cnt;
		c(k)++,siz(k)++,v(k)=v,pri(k)=rand();
		v(k)=v,ls(k)=rs(k)=0;
		return;
	} else siz(k)++;
	if(v(k)==v) c(k)++;
	else if(v<v(k)) {
		insert(ls(k),v);
		if(pri(ls(k))<pri(k)) zig(k);
	} else {
		insert(rs(k),v);
		if(pri(rs(k))<pri(k)) zag(k);
	}
}

void delet(int &k,int v) {
	if(!k) return;
	if(v(k)==v) {
		if(c(k)>1) c(k)--,siz(k)--;
		else if(!ls(k)||!rs(k)) {
			k=ls(k)+rs(k);
		} else if(pri(ls(k))<pri(rs(k))) zig(k),delet(k,v);
				else zag(k),delet(k,v);
		return;
	}
	siz(k)--;
	if(v<v(k)) delet(ls(k),v);
	else delet(rs(k),v);
}

int pre(int k,int v) {
	int res=-inf;
	while(k) {
		if(v(k)<v) res=v(k),k=rs(k);
		else k=ls(k);
	}
	return res;
}

int nex(int k,int v) {
	int res=inf;
	while(k) {
		if(v(k)>v) res=v(k),k=ls(k);
		else k=rs(k);
	}
	return res;
}

signed main() {
	srand(time(0));
	n=read();
	up(i,1,n) {
		int t=read(),tx=read();
		if(s.empty()) s.push(t),insert(rt,tx);
		else if(s.top()==t) s.push(t),insert(rt,tx);
		else {
			int a=pre(rt,tx),b=nex(rt,tx);
			if(abs(tx-a)<=abs(b-tx)) {
				ans=abs(ans+tx-a)%1000000;
				delet(rt,a);
			} else {
				ans=abs(ans+b-tx)%1000000;
				delet(rt,b);
			}
			s.pop();
		}
	}
	write(ans%1000000);
	return 0;
} 
```


---

## 作者：mulberror (赞：2)

# 前言
这一篇题解并不是为了讲什么算法，只是总结一下平衡树在OI考试中的注意事项。
顺便传销一下自己的博客：[【传送门】](https://www.cnblogs.com/chhokmah/p/10643211.html)
# 题意简化（给不想看题目的小伙伴们一点福利）
给你两堆数，每一次给你一个数，每一次在另外一堆数中找到这个数的前缀后继，删去前驱后继中较靠近的，得到了分数为两个数的差的绝对值。请你让这个分数最小。
（题意简化的应该不能在简化了吧qwq）


---
# 做法1&&2&&3（非正常做法）
我们都知道，所有的平衡树的题目都可以用不定长数组`vector`和不允许重复元素的`set`或者是允许重复元素的`muliset`来实现。  
这个东西在考场上是救命的，如果你剩下的时间不多了，那么是在不行就用以上的办法来偏分。  
分析一下`vector`和`set`和`muliset`的优缺点。  
不定长数组`vector`实现起来非常的简单，只要你熟悉指针和`vector`的正常操作。  
但是vector很容易溢出，长度一大，很有可能就RE，那个时候想哭都没时间哭了。
```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
vector<int>v;
int main() {
    scanf("%d",&n);
    for(int i=1;i<=n;i++) {
        int op=0,x=0;
        scanf("%d%d",&op,&x);
        if(op==1) v.insert(upper_bound(v.begin(),v.end(),x),x);
        else if(op==2) v.erase(lower_bound(v.begin(),v.end(),x));
        else if(op==3) printf("%d\n",lower_bound(v.begin(),v.end(),x)-v.begin()+1);
        else if(op==4) printf("%d\n",v[x-1]);
        else if(op==5) printf("%d\n",*--lower_bound(v.begin(),v.end(),x));
        else if(op==6) printf("%d\n",*upper_bound(v.begin(),v.end(),x));
    }
    return 0;
}
```
实现非常的简单，但是需要注意指针的变换。  
但是这一道题目我们用vector，蒟蒻我用了差不多5s才跑出大的数据。（数据从LOJ上来的）  
所以`set`和`muliset`可以更加快速的完成我们的任务。  
`set`差别并不是太大，一个可以实现没有重复的，一个实现有重复的。  
来自chhokmah的实测，set比muliset要快。  
所以总结一下：
* vector好写，但是容易错，不推荐使用。
* set可以实现无重复，推荐使用。
* muliset可以实现有重复，推荐使用。

-----
# 做法4正常的平衡树
这里以treap为例。  
简单介绍一下treap，treap是tree和heap的结合，每一次我们需要用自己给节点附加的`rd`值来维护平衡树的平衡性。    
代码实现非常的简单，但是我打的比较冗长。  
那么再回到这一道题目，如果我们只需要建立两个平衡树。（其实一棵就足够了，因为一棵有节点的时候另外一棵一定是没有节点的。）  
每一次找前驱和后继，判断更加接近的那一个，更新答案，并删除前驱或者是后继。
如果树为空或者是己方的树有节点，那么就直接插入。
```cpp
#include <bits/stdc++.h>
#define N 80005
#define mod 1000000
#define ll long long 
#define inf 0x3f3f3f3f
using namespace std;
template <typename T>
inline void read(T &x) {
    x = 0; T fl = 1; char ch = 0;
    for (; ch < '0' || ch > '9'; ch = getchar())
        if (ch == '-') fl = -1;
    for (; ch >= '0' && ch <= '9'; ch = getchar())
        x = (x << 1) + (x << 3) + (ch ^ 48);
    x *= fl;
}
struct Treap {
    int tot, rt;
    struct Node {
        int cnt, sz, rd, ch[2], val;
        void Init (int Val) { val = Val; ch[0] = ch[1] = 0; cnt = sz = 1; rd = rand() % 100; } 
    } tr[N];
    Treap() { tot = 0; memset(tr, 0, sizeof(tr)); }
    void pushup (int nod) { tr[nod].sz = tr[tr[nod].ch[0]].sz + tr[tr[nod].ch[1]].sz + tr[nod].cnt; }
    void rotate(int &nod, int d) {
        int k = tr[nod].ch[d ^ 1]; tr[nod].ch[d ^ 1] = tr[k].ch[d]; tr[k].ch[d] = nod;
        pushup(nod); pushup(k); nod = k;
    }
    void ins(int &nod, int val) {
        if (!nod) nod = ++ tot, tr[nod].Init(val);
        else if (val == tr[nod].val) tr[nod].sz ++, tr[nod].cnt ++;
        else {
            int d = (val > tr[nod].val);
            ins(tr[nod].ch[d], val); 
            if (tr[nod].rd < tr[tr[nod].ch[d]].rd) rotate(nod, d ^ 1);
            pushup(nod);
        }
    }
    void del(int &nod, int val) {
        if (!nod) return;
        if (val < tr[nod].val) del(tr[nod].ch[0], val);
        else if (val > tr[nod].val) del(tr[nod].ch[1], val);
        else {
            if (!tr[nod].ch[0] && !tr[nod].ch[1]) {tr[nod].sz --, tr[nod].cnt --; if (tr[nod].cnt == 0) nod = 0;}
            else if (tr[nod].ch[0] && !tr[nod].ch[1]) { rotate(nod, 1) ; del(tr[nod].ch[1], val);} 
            else if (!tr[nod].ch[0] && tr[nod].ch[1]) { rotate(nod, 0); del(tr[nod].ch[0], val); }
            else {
                int d = tr[tr[nod].ch[0]].rd > tr[tr[nod].ch[1]].rd;
                rotate(nod, d); del(tr[nod].ch[d], val);
            }
        }
    }
    int pre(int nod, int val) {
        if (!nod) return -inf;
        if (tr[nod].val > val) return pre(tr[nod].ch[0], val);
        else return max(tr[nod].val , pre(tr[nod].ch[1], val));
    } 
    int suc(int nod, int val) {
        if (!nod ) return inf;
        if (tr[nod].val < val) return suc(tr[nod].ch[1], val);
        else return min(tr[nod].val, suc(tr[nod].ch[0], val));
    }
}Pet, Cus;
int n;
ll ans = 0ll;
int main () {
    srand(19260817);
    read(n);
    while (n --) {
        int opt, x; read(opt); read(x);
        if (opt == 0) { // Pet
            if (Cus.rt == 0) Pet.ins(Pet.rt, x);
            else {
                int lst = Cus.pre(Cus.rt, x), nxt = Cus.suc(Cus.rt, x);
                if (abs(x - lst) <= abs(nxt - x))  { Cus.del(Cus.rt, lst); ans = (ans + 1ll * abs(x - lst)) % mod; }
                else { Cus.del(Cus.rt, nxt); ans = (ans + 1ll * abs(nxt - x)) % mod;}
            }
        }
        else { // Customer
            if (Pet.rt == 0) Cus.ins(Cus.rt, x);
            else {
                int lst = Pet.pre(Pet.rt, x), nxt = Pet.suc(Pet.rt, x);
                if (abs(x - lst) <= abs(nxt - x))  { Pet.del(Pet.rt, lst); ans = (ans + 1ll * abs(x - lst)) % mod; }
                else { Pet.del(Pet.rt, nxt); ans = (ans + 1ll * abs(nxt - x)) % mod;}
            }
        }
    }
    printf("%lld\n", ans % mod);
    return 0;
}
```

---

## 作者：减维 (赞：2)

又是一道没有fhq Treap的题解的题。。。


来来来让我补上！


#思路


用一颗fhq Treap维护特殊值，再用一个fla记录这颗平衡树中存的是宠物还是顾客


当树被清空时，fla^=1;


其他就是fhq Treap的基本操作了，求前驱后继和删除什么的


安利博客：[减维](http://www.cnblogs.com/rir1715/)


代码略丑









```cpp
//by 减维
#include<cstdio>
#include<iostream>
#include<cstring>
#include<queue>
#include<cstdlib>
#include<ctime>
#include<cmath>
#include<map>
#include<bitset>
#include<algorithm>
#define ll long long
#define maxn 80005
#define mod 1000000
using namespace std;
int n,m,sz,rt,fla=-1,ans,siz[maxn],pri[maxn],son[maxn][2],val[maxn];
void upda(int x)
{
    siz[x]=siz[son[x][0]]+siz[son[x][1]]+1;
}
int newnode(int x)
{
    siz[++sz]=1;
    pri[sz]=rand();
    val[sz]=x;
    return sz;
}
void spli(int now,int k,int &x,int &y)
{
    if(!now)x=y=0;
    else{
        if(val[now]<=k)
            x=now,spli(son[now][1],k,son[now][1],y);
        else
            y=now,spli(son[now][0],k,x,son[now][0]);
        upda(now);
    }
}
int merge(int x,int y)
{
    if(!x||!y)return x+y;
    if(pri[x]<pri[y])
    {
        son[x][1]=merge(son[x][1],y);
        upda(x);
        return x;
    }else{
        son[y][0]=merge(x,son[y][0]);
        upda(y);
        return y;
    }
}
int suc(int x)
{
    while(son[x][1])x=son[x][1];
    return x;
}
int pre(int x)
{
    while(son[x][0])x=son[x][0];
    return x;
}
int main()
{
    scanf("%d",&n);
    int x,y,z,h,a,b,fr,to,del,delt;
    for(int i=1;i<=n;++i)
    {
        scanf("%d%d",&a,&b);
        if(fla==-1)fla=a;
        if(a==0){
            if(fla==0){
                spli(rt,b,x,y);
                rt=merge(merge(x,newnode(b)),y);
            }else{
                spli(rt,b,x,y);
                fr=0,to=0;
                if(x)fr=suc(x);
                if(y)to=pre(y);
                if(!x||!y)del=fr+to;
                else if(b-val[fr]==val[to]-b)del=fr;
                else if(b-val[fr]<val[to]-b)del=fr;
                else if(b-val[fr]>val[to]-b)del=to;
                delt=val[del];
                rt=merge(x,y);
                spli(rt,delt,x,y);
                spli(x,delt-1,z,h);
                h=merge(son[h][0],son[h][1]);
                rt=merge(merge(z,h),y);
                ans+=abs(delt-b);
                ans%=mod;
            }
        }else{
            if(fla==1){
                spli(rt,b,x,y);
                rt=merge(merge(x,newnode(b)),y);
            }else{
                spli(rt,b,x,y);
                fr=0,to=0;
                if(x)fr=suc(x);
                if(y)to=pre(y);
                if(!x||!y)del=fr+to;
                else if(b-val[fr]==val[to]-b)del=fr;
                else if(b-val[fr]<val[to]-b)del=fr;
                else if(b-val[fr]>val[to]-b)del=to;
                delt=val[del];
                rt=merge(x,y);
                spli(rt,delt,x,y);
                spli(x,delt-1,z,h);
                h=merge(son[h][0],son[h][1]);
                rt=merge(merge(z,h),y);
                ans+=abs(delt-b);
                ans%=mod;
            }
        }
        if(siz[rt]==0)fla^=1;
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：Wall_breaker (赞：1)

~~不容易不容易，本蒟蒻终于学会Splay啦~~

说实在话，很少见到这么模板的模板题了，也只有10年前的题目可能出现。

## 正题：如何找到数列中的前驱后继并删除？

### 1.set
set是绝对的不二选择。毕竟这题只需要寻找前驱后继与这个数本身，不需要区间第K大数，所以拍了平衡树的都是……（pwq）

然而，为了，达到练习（zuosi）的目的，我们仍然选择2.

### **2.splay大法好**
看到前驱和后继，我们就马上明白了：这题可以splay（当然treap和SBT之类的也行）。

splay学习链接恰一发：
(https://baijiahao.baidu.com/s?id=1613228134219334653&wfr=spider&for=pc)

那么，比起正常的splay，我们只需要考虑2个问题。

<1>如何实现分组？<2>如何快速平衡树中并未出现的数的前驱后继？

<1>很好解决，每次纪录一下当前的opt（操作类型），如果平衡树中没有元素，就把树的类型typ改成opt，并插入元素。如果有元素且typ==opt，则插入元素。如果**typ！=opt**，那么就说明狗遇上了主人，转化为<2>。

<2>实际上也很简单。我初学splay时，看了一些大佬的博客后，发现有一种玄妙无比的解法。那就是：**把这个数先插入平衡树，寻找完前驱后继之后再删除**。

虽然常数可能会乘上2甚至3，但我们用简单的操作维护了正确性，真是聪（yu）明（chun）。

上代码：
```c++
#include<bits/stdc++.h>
using namespace std;
template <typename T>
inline void read(T &x) {
	x = 0;
	T f = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') f = -1;
	for (; isdigit(c); c = getchar()) x = (x << 1) + (x << 3) + (c ^ 48);
	x *= f;
}

template <typename T>
inline void w(T x) {
	if (x > 9) w(x / 10);
	putchar(x % 10 + 48);
}
template <typename T>
inline void write(T x, char c) {
	if (x < 0){
		putchar('-');
		x = -x;
	}
	w(x);
	putchar(c);
}
struct info{
	int child[2], cnt, siz, val, fa;
}a[800005];
int rt, tot;
inline void upd(int x) {
	a[x].siz = a[x].cnt + a[a[x].child[0]].siz + a[a[x].child[1]].siz;
}
inline bool ask(int x) {
	return x == a[a[x].fa].child[1];
}
inline void rot(int x) {
	int f = a[x].fa, g = a[f].fa;
	int tmp = ask(x), tnp = ask(f);
	if (g) a[g].child[tnp] = x;
	a[x].fa = g;
	a[f].child[tmp] = a[x].child[tmp ^ 1];
	a[a[x].child[tmp ^ 1]].fa = f;
	a[f].fa = x;
	a[x].child[tmp ^ 1] = f;
	upd(f);
	upd(x);
}
inline void splay(int x) {
	int y, z;
	while(a[x].fa) {
		y = a[x].fa; z = a[y].fa;
		if (z != 0) {
			if (ask(x) == ask(y)) rot(y);
			else rot(x);
		}
		rot(x);
	}
	rt = x;
	upd(rt);
}
inline void ins(int x) {
	int cur = rt, f = 0;
	while(cur) {
		if (a[cur].val == x) break;
		f = cur;
		cur = a[cur].child[x > a[cur].val];
	}
	if (cur) {
		a[cur].cnt ++;
		a[cur].siz ++;
	}
	else {
		cur = ++ tot;
		a[cur].cnt = a[cur].siz = 1;
		a[cur].val = x;
		a[cur].fa = f;
		if (f) a[f].child[x > a[f].val] = cur;
		a[cur].child[1] = a[cur].child[0] = 0;
	}
	splay(cur);
	return;
}
inline void mov(int x) {
	int cur = rt;
	while(cur) {
		if (a[cur].val == x) {
			splay(cur);
			return;
		}
		cur = a[cur].child[x > a[cur].val];
	}
}
inline int prei() {
	int cur = a[rt].child[0];
	if (!cur) return 0;
	while(a[cur].child[1]) cur = a[cur].child[1];
	return cur;
}
inline int sufi() {
	int cur = a[rt].child[1];
	if (!cur) return 0;
	while(a[cur].child[0]) cur = a[cur].child[0];
	return cur;
}
inline void del(int x) {
	mov(x);
	if (a[rt].cnt > 1) a[rt].cnt --;
	else if (a[rt].child[0] + a[rt].child[1] == 0) {
		rt = 0;
	} 
	else if (a[rt].child[0] == 0) {
		rt = a[rt].child[1];
		a[rt].fa = 0;
	}
	else if (a[rt].child[1] == 0) {
		rt = a[rt].child[0];
		a[rt].fa = 0;
	}
	else {
		splay(prei());
		a[rt].child[1] = a[a[rt].child[1]].child[1];
		a[a[rt].child[1]].fa = rt;
		upd(rt);
		return;
	}
}
inline int que(int x) {
	int cur = rt;
	while(cur) {
		if (a[cur].val == x) break;
		cur = a[cur].child[x > a[cur].val];
	}
	return cur;
}
inline int pre(int x) {
	ins(x);
	int ans = a[prei()].val;
	del(x);
	return ans;
}
inline int suf(int x) {
	ins(x);
	int ans = a[sufi()].val;
	del(x);
	return ans;
}
const int mod = 1000000;
int main(){
	int n;
	read(n);
	int opt, typ, sum;
	unsigned int ans = 0;
	for (int i = 1; i <= n; i ++) {
		read(opt); read(sum);
		if (!rt) {
			typ = opt;
			ins(sum);
		}
		else if (opt == typ) ins(sum);
		else {
			int pos = que(sum);
			if (pos) {
				del(pos);
				continue;
			}
			int p = pre(sum), q = suf(sum);
			if (!p) {
				ans = (ans + abs(q - sum)) % mod;
				del(q);					
			}
			else if (!q) {
				ans = (ans + abs(p - sum)) % mod;
				del(p);		
			}
			else if (abs(p - sum) <= abs(q - sum)) {
				ans = (ans + abs(p - sum)) % mod;
				del(p);
			}
			else{
				ans = (ans + abs(q - sum)) % mod;
				del(q);				
			}
		}
	}
	write(ans, '\n');
	return 0;
}
```


---

## 作者：寒冰大大 (赞：1)

看起来没有一个友好的splay的题解，所以来发一波

这道题重要的地方有两个

一个是如果一个领养宠物的没有领养到宠物他会留下来

另一个是如果有两只满足要求的宠物，即存在两只宠物他们的特点值分别为$a-b$和$a+b$，那么领养者将会领养特点值为$a-b$的那只宠物。

也就是像样例那样$3$进去要领养$2$,$2$进去领养$4$
不过好像没有这种数据，所以才导致有人样例炸提交却AC

另外这种频繁地插入/删除操作的话，最好插入一个极小值和一个极大值

自认为我的$splay$马蜂还是比较好的(

怎么头文件又被说太长了

```cpp
#include<touwenjian.h>

#define ls(x) c[x][0]
#define rs(x) c[x][1]

using namespace std;

const int maxn=500100;
const int modp=1000000;
int f[maxn],sz[maxn],cnt[maxn],c[maxn][2],val[maxn];
int rt,tot;
int col=-1,n;

struct ssplay{
	
	inline void pushup(int x){sz[x]=sz[ls(x)]+sz[rs(x)]+cnt[x];}
	inline int pd(int x){return c[f[x]][1]==x;}
	inline void clear(int x){ls(x)=rs(x)=cnt[x]=sz[x]=val[x]=f[x]=0;}
	
	inline void rotate(int x)
	{
		int y=f[x],z=f[y],k=pd(x),m=c[x][!k];
		c[x][!k]=y; c[y][k]=m; f[m]=y; f[y]=x; f[x]=z;
		if(z) c[z][rs(z)==y]=x;
		pushup(y); pushup(x);
	}
	
	inline void splay(int x)
	{
		for(int y=f[x];y=f[x];rotate(x))
		{
			if(f[y]) rotate(pd(x)^pd(y)?x:y);
		}
		rt=x;
	}
	
	inline void ins(int target)
	{
		int nowp=rt,fat=0;
		if(!rt)
		{
			cnt[++tot]++;
			val[tot]=target;
			rt=tot;
			pushup(rt);
			return ;
		}
		while(1)
		{
			if(val[nowp]==target)
			{
				cnt[nowp]++;
				pushup(nowp);
				pushup(fat);
				splay(nowp);
				return ;
			}
			fat=nowp; nowp=c[nowp][val[nowp]<target];
			if(!nowp)
			{
				val[++tot]=target;
				cnt[tot]++;
				f[tot]=fat;
				c[fat][val[fat]<target]=tot;
				pushup(tot);
				pushup(fat);
				splay(tot);
				return ;
			}
		}
	}
	
	inline int rk(int target)
	{
		int nowp=rt,ans=0;
		while(1)
		{
			if(target==val[nowp]) { ans+=sz[ls(nowp)]; splay(nowp); return ans+1;}
			ans+=val[nowp]<target?sz[ls(nowp)]+cnt[nowp]:0;
			nowp=c[nowp][val[nowp]<target];
		}
	}
	
	inline int kth(int k)
	{
		int nowp=rt;
		while(1)
		{
			if(ls(nowp)&&k<=sz[ls(nowp)]) nowp=ls(nowp);
			else 
			{
				k-=sz[ls(nowp)]+cnt[nowp];
				if(k<=0) 
				{
					splay(nowp);
					return val[nowp];
				}
				nowp=rs(nowp);
			}
		}
	 } 
	
	inline int pre()
	{
		int nowp=ls(rt); 
		while(rs(nowp)) nowp=rs(nowp);
		splay(nowp);
		return nowp;
	}
	
	inline int nxt()
	{
		int nowp=rs(rt);
		while(ls(nowp)) nowp=ls(nowp);
		splay(nowp);
		return nowp;
	}
	
	inline void del(int target)
	{
		rk(target);
		int looker;
		int nowp=rt;
		if(cnt[rt]>1) 
		{
			cnt[rt]--;
			pushup(rt);
			return ;
		}
		if(!ls(rt)&&!rs(rt))
		{
			clear(rt);
			rt=0;
			return ;
		}
		if(!ls(rt))
		{
			looker=rt;
			rt=rs(rt);
			clear(looker);
			f[rt]=0;
			pushup(rt);
			return ;
		}
		if(!rs(rt))
		{
			looker=rt;
			rt=ls(rt);
			clear(looker);
			f[rt]=0;
			pushup(rt);
			return ;
		}
		looker=rt;
		nowp=pre();
		splay(nowp);
		f[rs(looker)]=nowp;
		rs(nowp)=rs(looker);
		clear(looker);
		pushup(rt);
		return ;
	}
	
}spl;

int ans;
int cntt;

int main()
{
	ios::sync_with_stdio(false);
	register int i,j;
	cin>>n;
	int cc,x;
	spl.ins(0x3f3f3f3f);
	spl.ins(-0x3f3f3f3f); 
	for(i=1;i<=n;i++)
	{
 		cin>>cc>>x;
		if(cntt==0) spl.ins(x);
		else
		{
			if(cc==(cntt<0)) spl.ins(x);
			else 
			{
				int a,b;
				spl.ins(x);
				a=spl.pre();
				spl.del(x);
				spl.ins(x);
				b=spl.nxt();
				spl.del(x); 
				if(abs(x-val[a])<=abs(val[b]-x)) ans+=abs(val[a]-x),spl.del(val[a]);
				else  ans+=abs(val[b]-x),spl.del(val[b]);
			}
		}
		cntt+=cc==0?1:-1;
		ans%=modp;
	}
	cout<<ans%modp<<endl;
}
```



---

## 作者：solstice23 (赞：1)

[更好的阅读体验](http://abc233.site/archives/138)
## 思路
根据题意，每一个主人到达收养所后，如果有宠物，就会领养。同样地，宠物也是如此，只要有主人就会被领养。这样就能理解题目中 "宠物收养场总是会有两种情况发生：被遗弃的宠物过多或者是想要收养宠物的人太多，而宠物太少"。

如何找到特点值最接近的主人/宠物？找一个集合中最接近 x 的元素，自然就想到了平衡树。我在这道题中使用了 Treap。最接近的 x 特征值就是 x 前驱和后继中更接近 x 的那一个。

所以我们可以开两棵 Treap，分别存储宠物的特点值和主人的特点值。再记录下当前两个 Treap 中分别有多少个元素。

每当一个宠物 x 进入，如果主人的 Treap 不为空，就在主人 Treap 中找 x 的前驱和后继，选择更接近 x 的那个（根据题意如果差值相同就选前驱），并累计不满意度总值，然后从主人 Treap 中删除这个元素。否则如果主人的 Treap 为空，就将 x 加入宠物的 Treap 中，等待下一个主人。

对应地，每当一个主人 y 进入，如果宠物的 Treap 不为空，就在宠物 Treap 中找 y 的前驱和后继，选择更接近 y 的那个，然后删除它（已经被领养了），并累计不满意度总值，然后从宠物 Treap 中删除这个元素。否则如果宠物的 Treap 为空，就将 y 加入主人的 Treap 中，等待下一个宠物。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int q;
struct treap{//封装 Treap
	struct node{
		long long x,y,l,r,size,cnt;
	};
	node s[1000001];
	long long top,root;
	void reset(){
		top=0;
		root=0;
	}
	void update(long long x){
		s[x].size=s[s[x].l].size+s[s[x].r].size+s[x].cnt;
	}
	void rotr(long long &x){
		long long l=s[x].l;
		s[x].l=s[l].r;
		s[l].r=x;
		s[l].size=s[x].size;
		update(x);
		x=l;
	}
	void rotl(long long &x){
		long long r=s[x].r;
		s[x].r=s[r].l;
		s[r].l=x;
		s[r].size=s[x].size;
		update(x);
		x=r;
	}
	void add(long long &x,long long data){
		if (!x){
			x=++top;
			s[x].x=data;
			s[x].y=rand()%19260817;
			s[x].cnt=1;
			s[x].size=1;
			s[x].l=0;
			s[x].r=0;
			return;
		}
		s[x].size++;
		if (s[x].x==data){
			s[x].cnt++;
		}else if (data<s[x].x){
			add(s[x].l,data);
			if (s[x].y>s[s[x].l].y){
				rotr(x);
			}
		}else{
			add(s[x].r,data);
			if (s[x].y>s[s[x].r].y){
				rotl(x);
			}
		}
	}
	void del(long long &x,long long data){
		if (s[x].x==data){
			if (s[x].cnt>1){
				s[x].cnt--;
				s[x].size--;
				return;
			}
			if (!s[x].l||!s[x].r){
				x=s[x].l+s[x].r;
				return;
			}
			if (s[s[x].l].y<s[s[x].r].y){
				rotr(x);
				del(x,data);
			}else{
				rotl(x);
				del(x,data);
			}
			return;
		}
		s[x].size--;
		if (data<s[x].x){
			del(s[x].l,data);
		}else{
			del(s[x].r,data);
		}
	}
	long long pre(long long data){
		long long now=root,res=-2147483647;
		while (now){
			if (s[now].x<data){
				res=s[now].x;
				now=s[now].r;
			}else{
				now=s[now].l;
			}
		}
		return res;
	}
	long long nxt(long long data){
		long long now=root,res=2147483647;
		while (now){
			if (s[now].x>data){
				res=s[now].x;
				now=s[now].l;
			}else{
				now=s[now].r;
			}
		}
		return res;
	}
	long long querykth(long long k){
		long long now=root;
		while (now){
			if (s[s[now].l].size<k&&s[s[now].l].size+s[now].cnt>=k){
				return s[now].x;
			}
			if (s[s[now].l].size>=k){
				now=s[now].l;
			}else{
				k-=s[s[now].l].size+s[now].cnt;
				now=s[now].r;
			}
		}
		return 0;
	}
	long long queryrank(long long data){
		long long now=root,res=0;
		while (now){
			if (data==s[now].x){
				return res+s[s[now].l].size+1;
			}
			if (data<s[now].x){
				now=s[now].l;
			}else{
				res+=s[s[now].l].size+s[now].cnt;
				now=s[now].r;
			}
		}
		return res;
	}
};
long long n,ans=0;//ans 为不满意度总和
treap a,b;//存储宠物和主人特征值
long long A=0,B=0;//分别表示宠物和主人 Treap 中有多少个元素
int main(){
	srand(time(0));
	a.reset();
	b.reset();
	cin>>n;
	for (int i=1;i<=n;i++){
		long long x,y;
		cin>>x>>y;
		if (x==0){//如果是宠物
			if (B>0){//如果主人 Treap 不为空（当前有正在等待的主人）
				long long tar1=b.pre(y);//在主人中找前驱
				long long tar2=b.nxt(y);//找后继
				if (y-tar1>tar2-y){//选取更接近的那个
					ans+=tar2-y;//更新不满意度
					b.del(b.root,tar2);//从主人 Treap 中删除匹配到的主人
				}else{
					ans+=y-tar1;//同上
					b.del(b.root,tar1);
				}
				B--;//主人 Treap 元素总和减 1
			}else{//如果没有在等待的主人
				A++;//宠物 Treap 元素总和加 1
				a.add(a.root,y);//宠物 Treap 插入当前宠物的特征值
			}
		}else{
			if (A>0){//同上，只是这次是主人匹配宠物
				long long tar1=a.pre(y);
				long long tar2=a.nxt(y);
				if (y-tar1>tar2-y){
					ans+=tar2-y;
					a.del(a.root,tar2);
				}else{
					ans+=y-tar1;
					a.del(a.root,tar1);
				}
				A--;
			}else{
				B++;
				b.add(b.root,y);
			}
		}
		ans%=1000000;//取模
	}
	cout<<ans%1000000;
}
```

---

## 作者：cww970329 (赞：1)

题解都是STL和Splay的。

这个数据结构不是很常见

AVL Tree，是平衡树的一种，也是支持左旋和右旋的操作。

每个节点有个平衡因子`balance_factor` 代码里写的是`bf`，

$$bf = depth_{lson} - depth_{rson}$$

当`bf`的绝对值超过1的时候就开始旋转。大致是这个思路，各个函数看名字也挺容易理解的

当年自己数据结构课上完闲来无事敲了一发，顺手一交

```c++
//poj3481 cww97
#include<cstdio>
#include<iostream>
#include<algorithm>
#define INF 0xfffffff
#define BASE 1000000
using namespace std;
int ans=0;
struct Node{
    int x,bf,h;//bf=balance factor,h=height
    Node *l,*r;
};

class AVLTree{
public:
    void Init() { rt = NULL; }
    int H(Node *T){return (T==NULL)?0:T->h;}
    int BF(Node *l,Node *r){//get balance factor
        if (NULL==l && NULL==r) return 0;
        else if (NULL == l) return -r->h;
        else if (NULL == r) return  l->h;
        return l->h - r->h;
    }

    Node *Lrorate(Node *a){//left rorate
        Node *b;
        b=a->r;
        a->r=b->l;
        b->l=a;
        a->h=max(H(a->l),H(a->r)) + 1;
        b->h=max(H(b->l),H(b->r)) + 1;
        a->bf=BF(a->l,a->r);
        b->bf=BF(b->l,b->r);
        return b;
    }
    Node *Rrorate(Node *a){//right rorate
        Node *b;
        b=a->l;
        a->l=b->r;
        b->r=a;
        a->h=max(H(a->l),H(a->r)) + 1;
        b->h=max(H(b->l),H(b->r)) + 1;
        a->bf=BF(a->l,a->r);
        b->bf=BF(b->l,b->r);
        return b;
    }
    Node *LRrorate(Node *a){//left then right
        a->l = Lrorate(a->l);
        Node *c;
        c=Rrorate(a);
        return c;
    }
    Node *RLrorate(Node *a){//right then left
        a->r=Rrorate(a->r);
        Node *c;
        c=Lrorate(a);
        return c;
    }

    void Insert(int x){_Insert(rt,x);}
    void _Insert (Node *&T,int x){
        if (NULL==T){
            T=(Node*)malloc(sizeof(Node));
            T->x=x;
            T->bf=0;T->h=1;
            T->l=T->r=NULL;
            return ;
        }
        if      (x < T->x) _Insert(T->l,x);
        else if (x > T->x) _Insert(T->r,x);
        else return ; //error :the same y

        T->h=max(H(T->l),H(T->r))+1;//maintain
        T->bf=BF(T->l,T->r);

        if (T->bf > 1 || T->bf < -1){//not balanced
            if      (T->bf > 0 && T->l->bf > 0)T=Rrorate(T);
            else if (T->bf < 0 && T->r->bf < 0)T=Lrorate(T);
            else if (T->bf > 0 && T->l->bf < 0)T=LRrorate(T);
            else if (T->bf < 0 && T->r->bf > 0)T=RLrorate(T);
        }
    }

    void GetPet(int x){
        if (NULL==rt){return ;}
        int small=0,large=INF;
        //printf("x=%d\n",x);
        int flag;
        if (Find(rt,x,small,large)){
            printf("find %d\n",x);
            _Delete(rt,x);
        }else if (small==0)flag=1;
        else if (large==INF)flag=0;
        else if (large-x<x-small)flag=1;
        else flag=0;

        if (!flag){//choose large
            //printf("!%d~%d\n",small,large);
            _Delete(rt,small);
            ans=(ans+x-small)%BASE;
        }else {
            //printf("%d~!%d\n",small,large);
            _Delete(rt,large);
            ans=(ans+large-x)%BASE;
        }
        //printf("ans=%d\n",ans);
    }
    bool Find(Node *T,int x,int &small,int &large){
        if (NULL==T)return 0;
        if (x==T->x)return 1;
        if (x<T->x){
            large=min(large,T->x);
            return Find(T->l,x,small,large);
        }else{
            small=max(small,T->x);
            return Find(T->r,x,small,large);
        }
    }
    void _Delete(Node *&T,int x){
        if (NULL==T)return ;
        if       (x < T->x){//y at left
            _Delete(T->l,x);
            T->bf=BF(T->l,T->r);
            if (T->bf<-1){
                if (1==T->r->bf)T=RLrorate(T);
                else T=Lrorate(T);//bf==0 or -1
            }
        }else if (x > T->x){//y at right
            _Delete(T->r,x);
            T->bf=BF(T->l,T->r);
            if (T->bf>1){
                if (-1==T->l->bf)T=LRrorate(T);
                else T=Rrorate(T);//bf==0 or 1
            }
        }else {//here is x
            if (T->l&&T->r){//left &&right
                Node *t=T->l;
                while (t->r)t=t->r;
                T->x=t->x;
                _Delete(T->l,t->x);
                T->bf=BF(T->l,T->r);
                if (T->bf<-1){
                    if (1==T->r->bf)T=RLrorate(T);
                    else T=Lrorate(T);//bf==0 or -1
                }
            }else {//left || right
                Node *t=T;
                if (T->l)T=T->l;
                else if(T->r)T=T->r;
                else {free(T);T=NULL;}
                if (T)free(t);
            }
        }
    }

    //Debug,you will not need it at this problem
    void show(){InOrder(rt);puts("EndShow");}
    void InOrder(Node *T){//print l rt r
        if (NULL==T)return ;
        InOrder(T->l);
        printf("%d ",T->x);
        InOrder(T->r);
    }
    void Free(){FreeTree(rt);}
    void FreeTree(Node *T){
        if (NULL==T)return ;
        FreeTree(T->l);
        FreeTree(T->r);
        free(T);
    }

private:
    Node *rt;//root
};

int main(){
    int n,x,op,a=0,b=0;
    scanf("%d",&n);
    AVLTree T; T.Init();
    for (;n--;){
        scanf("%d%d",&op,&x);
        if (op==0){
            a++;
            if (a>b)T.Insert(x);
            else T.GetPet(x);
        }else{
            b++;
            if (a<b)T.Insert(x);
            else T.GetPet(x);
        }
    }
    printf("%d\n",ans%BASE);
    T.Free();
    return 0;
}
```

---

## 作者：shadowice1984 (赞：1)

splay做法，带垃圾回收，以及100行以内的代码，

话说这玩意真的难搞，会和正常的erase产生奇妙的反应，引起死循环之类的。。。

简单说一下基本操作，

旋转，左右选二合一，更改3对父子关系

splay，只有旋转到根，

insert，bst插入+splay

erase，找前驱后继并同时splay，

然后被删除节点不会出现双子非空，就可做了

release和reuse，用一个类似栈的玩意来维护被删除节点的编号

然后release和erase会产生奇妙的冲突，洗掉不该洗的东西，

写的时候小心一点

上代码~


```cpp
#include<cstdio>
#include<cmath>
using namespace std;
int n;int nowtype[2];int res;//nowtype0总宠物个数，nowtype1总人类个数
struct splaytree
{
    int s[10010][2];int fa[10010];int val[10010];int mem[10010];
    int root;int size;int head;
    inline int get_child(int x)//返回该节点的编号
    {
        return s[fa[x]][1]==x;
    }
    inline void release(int p)//垃圾回收，但是注意第三句是有问题的，如果这个节点有孩子，就会把他父节点的孩子指针断掉
    {
        mem[p]=head;head=p;
        s[fa[p]][get_child(p)]=0;fa[p]=0;
        s[p][0]=0;s[p][1]=0;return;
    }
    inline int reuse()//回收
    {
        if(head==0)return ++size;
        else
        {
            int res=head;head=mem[head];return res;
        }
    }
    inline int successor(int x)//一行找后继~
    {
        int q=0;for(int p=root;p;q=(x<val[p])?p:q,p=(x<val[p])?s[p][0]:s[p][1]);return q;
    }
    inline int predecessor(int x)//一行找前驱~
    {
        int q=0;for(int p=root;p;q=(x<=val[p])?q:p,p=(x<=val[p])?s[p][0]:s[p][1]);return q;
    }
    inline void rotate(int x)//二合一旋转
    {
        int d=fa[x];int p=get_child(x);
        s[d][p]=s[x][p^1],fa[s[x][p^1]]=d,s[x][p^1]=d;
        s[fa[d]][get_child(d)]=x,fa[x]=fa[d],fa[d]=x;
        return;
    }
    inline void splay(int x)//splay到根
    {
        while(fa[x]!=0)
        {
            if(fa[fa[x]]!=0)
            {    
                if(get_child(fa[x])^get_child(x))rotate(x);//zig-zag
                else rotate(fa[x]);//zig-zig
            }rotate(x);
        }return;
    }
    void insert(int x)
    {
        int q=0;for(int p=root;p;q=p,p=(x<val[p])?s[p][0]:s[p][1]);int p=reuse();//一行查找
        val[p]=x;s[q][x>=val[q]]=p;fa[p]=q;splay(p);root=p;return;//一行插入，记得更改根
    }
    inline void bst_del(int x)
    {
        if(s[x][0])s[fa[x]][get_child(x)]=s[x][0],fa[s[x][0]]=fa[x],fa[x]=0;//删除时一定不要忘记最后一句，它可以使release的第一句无效
        if(s[x][1])s[fa[x]][get_child(x)]=s[x][1],fa[s[x][1]]=fa[x],fa[x]=0;//从而保证它祖父的孩子指针不被洗掉
        release(x);return;//如果没有孩子的话让就它放飞自我好了
    }
    void erase(int x)
    {
        int q1=successor(val[x]);int q2=predecessor(val[x]);
        splay(q2);splay(q1);root=q1;bst_del(x);return;//找前驱，找后继，splay，搞定~，同样不要忘记更改根
    }
    splaytree(){this->insert(0x3f3f3f3f),this->insert(-0x3f3f3f3f);}//构造函数，插入哨兵
}spt;
int main()
{
    scanf("%d",&n);
    for(int i=0;i<n;i++)
    {
        int type;int val;
        scanf("%d%d",&type,&val);
        if(nowtype[type]>=nowtype[type^1])spt.insert(val);//如果这个东西多就插入这个东西
        else 
        {
            int q1=spt.successor(val);int q2=spt.predecessor(val);int p;
            if(spt.val[q1]-val>=val-spt.val[q2])p=q2;//有了前驱和后继就不用放绝对值了
            else p=q1;res+=abs(spt.val[p]-val);spt.erase(p);res%=1000000;
        }nowtype[type]++;//这个东西个数++
    }
    printf("%d",res);
        return 0;//拜拜程序~
}

```

---

## 作者：zht467 (赞：1)

### Treap做法

设立一个flag以表示当前是狗的treap还是人的treap，如果treap被清空就更改flag值

其余的就是裸的treap操作，还没有特值点相同的点，更简单。









```cpp
#include <cstdio>
#include <cstdlib>
#include <cmath>
using namespace std;
int n, root, tot, pre, suc, flag = -1, ans;
int son[100001][2], size[100001], rnd[100001], w[100001];
inline void turn(int &k, int x)
{
    int t = son[k][x];
    son[k][x] = son[t][x ^ 1];
    son[t][x ^ 1] = k;
    size[t] = size[k];
    size[k] = size[son[k][0]] + size[son[k][1]] + 1;
    k = t;
}
inline void insert(int &k, int x)
{
    if(!k)
    {
        k = ++tot;
        w[k] = x;
        rnd[k] = rand();
        size[k] = 1;
        return;
    }
    size[k]++;
    if(w[k] < x)
    {
        insert(son[k][1], x);
        if(rnd[k] > rnd[son[k][1]]) turn(k, 1);
    }
    else
    {
        insert(son[k][0], x);
        if(rnd[k] > rnd[son[k][0]]) turn(k, 0);
    }
}
inline void get_pre(int k, int x)
{
    if(!k) return;
    if(w[k] > x) get_pre(son[k][0], x);
    else pre = k, get_pre(son[k][1], x);
}
inline void get_suc(int k, int x)
{
    if(!k) return;
    if(w[k] < x) get_suc(son[k][1], x);
    else suc = k, get_suc(son[k][0], x);
}
inline void del(int &k, int x)
{
    if(!k) return;
    if(w[k] == x)
    {
        if(son[k][0] * son[k][1] == 0) k = son[k][0] + son[k][1];
        else if(rnd[son[k][0]] < rnd[son[k][1]]) turn(k, 0), del(k, x);
        else turn(k, 1), del(k, x);
    }
    else
    {
        size[k]--;
        if(w[k] > x) del(son[k][0], x);
        else del(son[k][1], x);
    }
}
int main()
{
    int i, a, b, x;
    scanf("%d", &n);
    for(i = 1; i <= n; i++)
    {
        scanf("%d %d", &a, &b);
        if(flag == a) insert(root, b);
        else
        {
            if(size[root])
            {
                pre = 0, get_pre(root, b);
                suc = 0, get_suc(root, b);
                if(!pre || !suc) x = pre + suc;
                else if(b - w[pre] <= w[suc] - b) x = pre;
                else x = suc;
                ans = (ans + abs(w[x] - b)) % 1000000;
                del(root, w[x]);
            }
            else flag = a, insert(root, b);
        }
    }
    printf("%d", ans);
    return 0;
}
```

---

## 作者：linz (赞：1)

此题还是很裸的;
什么平衡树，splay。。。~~我都不会~~
蒟蒻同样只会stl,看了一下题解，也有大佬用stl解
但是蒟蒻表示不要这么长的代码，可以精简一点

**
明确用 ： set**

**
可以定义两个 迭代器	it，it2**

**再用其进行操作就简单的多并且对于宠物与领养人来说操作几乎是相同的**

拿宠物来说吧：
	如果没有领养人，即 b 为空，直接insert 
    如果有领养人，就插入宠物的值，并查找它的前驱和后继（注意，这里要判断 y是否是边界，否则会出错），计算最小值，并删除 宠物的值，和这个前驱或后继再累加取模.
 ### 详细见代码:



```cpp
#include <bits/stdc++.h>
using namespace std;
set<int>a;set<int>b; 
set<int>:: iterator it,it2;
int x,y,n;
long long ans,mod=1000000;
int main(){
    cin>>n>>x>>y; 
    if(x==0)a.insert(y);	//特殊处理第一个
    else b.insert(y);
    for(int i=2;i<=n;i++){
        scanf("%d %d",&x,&y);
        if(x==0){//宠物
            if(b.empty()){	a.insert(y);continue;	}
            b.insert(y);	it=b.find(y);	it2=it;
            int minn1=1<<30,minn2=1<<30;
            if(it!=b.begin()){	it--;	//是否为第一个，有没有前驱	minn1=abs(y-*it);	}
            it2++;//是否为最后一个，有没有后继
            if(it2!=b.end())	minn2=abs(y-*it2);
            if(minn1<=minn2)//求得最小值，并删除
            	 b.erase(y),b.erase(*it),ans+=minn1;
            else b.erase(y),b.erase(*it2),ans+=minn2;
            ans%=mod;
        }
        else{//领养人
            if(a.empty()){	b.insert(y);continue;	}
            a.insert(y);	it=a.find(y);	it2=it;
            int minn1=1<<30,minn2=1<<30;
            if(it!=a.begin()){	it--;		minn1=abs(y-*it);	}
            it2++;
            if(it2!=a.end())	minn2=abs(y-*it2);
            if(minn1<=minn2)	a.erase(y),a.erase(*it),ans+=minn1;
            else a.erase(y),a.erase(*it2),ans+=minn2;
            ans%=mod;
        }
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：attack (赞：1)

~~哎呀一不小心拿了个rank1还比第二快9倍呢2333~~

这道题目比较简单

请选择一种数据结构，

支持插入、删除、求前驱后继

splay裸题

有一个小技巧：

在求前驱后继的时候增加两个哨兵节点

这样就不会加爆了

[代码在这里](http://www.cnblogs.com/zwfymqz/p/7895794.html)


---

## 作者：Treaker (赞：0)

$$\color{cornflowerblue}{\mathcal{Treaker}}$$
# 平衡树
## Splay
这个题，很显然是让我们求前驱和后继，当然是Splay了啊

首先，我们要先开一个变量来记录一下当前是宠物多，还是领养者多。

宠物多时，来宠物的话，直接插入；来领养者的话，查前驱和后继，把近的删除了。

领养者多时同理。

Splay一定不要写错了啊（调了两个小时）。

完整代码如下：
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
const int mod = 1000000 , inf = 2147483647;
inline int read()
{
    int x = 0 , f = 1;  char ch = getchar();
    while(ch < '0' || ch > '9') {if(ch == '-')  f = -1; ch = getchar();}
    while(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}
    return x * f;
}
struct Splay
{
	struct node
	{
		node *ch[2] , *fa;
		int val , size;
		node(node *fa = NULL,int val = 0) : fa(fa) , val(val) {ch[0] = ch[1] = NULL;size = 1;}
		inline bool isr() {return this == fa -> ch[1];}
		inline int rk() {return 1 + (ch[0] ? ch[0] -> size : 0);}
		inline void up() {size = 1 + (ch[0] ? ch[0] -> size : 0) + (ch[1] ? ch[1] -> size : 0);}
	}*root;
	Splay() {root = NULL;}
	inline void rot(node *x)
	{
		bool k = x -> isr();
		node *y = x -> fa , *z = y -> fa , *w = x -> ch[!k];
		if(root == y) root = x;
		else z -> ch[y -> isr()] = x;
		x -> fa = z; y -> fa = x;
		x -> ch[!k] = y; y -> ch[k] = w;
		if(w) w -> fa = y;
		y -> up(); x -> up();
	}
	inline void splay(node *x)
	{
		while(x != root)
		{
			if(x -> fa != root) rot(x -> isr() ^ x -> fa -> isr() ? x : x -> fa);
			rot(x);
		}
	}
	node *merge(node *x,node *y,node *fa)
	{
		if(x) x -> fa = fa;
		if(y) y -> fa = fa;
		if(!x || !y) return x ? x : y;
		return x -> ch[1] = merge(x -> ch[1],y,x) , x -> up() , x;
	}
	inline void insert(int val)
	{
		if(!root) return (void)(root = new node(NULL,val));
		node *p = root , *fa = NULL;
		while(p)
		{
			fa = p;
			p = p -> ch[val > p -> val];
		}
		p = new node(fa,val);
		fa -> ch[val > fa -> val] = p;
		splay(p);
	}
	inline void del(int val)
	{
		node *p = root;
		while(p && val != p -> val) p = p -> ch[val > p -> val]; 
		if(!p) return;
		splay(p); root = merge(p -> ch[0],p -> ch[1],NULL);
	}
	inline int pre(int val)
	{
		node *p = root , *lst = NULL;
		while(p)
		{
			if(val > p -> val) lst = p , p = p -> ch[1];
			else p = p -> ch[0];
		}
		if(lst) return splay(lst) , lst -> val;
		return -2147483647;
	}
	inline int nxt(int val)
	{
		node *p = root , *lst = NULL;
		while(p)
		{
			if(val < p -> val) lst = p , p = p -> ch[0];
			else p = p -> ch[1];
		}
		if(lst) return splay(lst) , lst -> val;
		return 2147483647;
	}
	inline bool find(int val)
	{
		node *p = root;
		while(p && val != p -> val) p = p -> ch[val > p -> val];
		if(p) return 1; return 0;
	}
	inline void LOL()
	{
		int n = read() , sum = 0 , ans = 0;
		for(int i = 1 , opt , x;i <= n;i ++)
		{
			opt = read(); x = read();
			if(opt == 0)
			{
				if(sum >= 0) insert(x);
				else 
				{
					int res = pre(x); int tot = nxt(x);
					if((long long)x - res <= (long long)tot - x) del(res) , ans = (int)(((long long)ans + (long long)x - (long long)res) % (long long)mod);
					else del(tot) , ans = (int)(((long long)ans + (long long)(tot - x)) % (long long)mod);
				}
				sum ++;
			}
			else
			{
				if(sum <= 0) insert(x);
				else
				{
					int res = pre(x); int tot = nxt(x);
					if((long long)x - res <= (long long)tot - x) del(res) , ans = (int)(((long long)ans + (long long)x - (long long)res) % (long long)mod);
					else del(tot) , ans = (int)(((long long)ans + (long long)(tot - x)) % (long long)mod);
				}
				sum --;
			}
		}
		printf("%d\n",ans % mod);
	}
}DNF;
int main()
{
	DNF.LOL();
	return 0;
}
```


---

## 作者：苏幕寒 (赞：0)

这题是我同机房大佬叫我写的，我一看这道题，咦？这不是带旋treap的模板题吗？

然后，我就开始了我的表演，原本我是打算建两棵树直接顶过去的，结果写着写着自己晕了，~~大家可以试试，蛮爽的~~呸，大家前往别学我；

好了，下面讲正解，我们可以发现，其实同一时刻只会有人或者狗单独剩下；不然肯定会领走，有了这个结论，我们就可以发现，只需要在有东西来的时候，判定一下他是否和前面来的一样，一样就插到树里去，否则就去树里找前驱和后驱然后比较即可，相信各位大佬都懂，我就不多说了；对了，记得删除，我绝对不是错了才发现的；

然后，插入，旋转，删除，前驱，后驱，nice；

我：大佬，我要A了，hiahiahia；

大佬：inf开大点吧，小心被卡；

我：今天，我XXX要是被卡inf大小；我当场把这个屏幕吃掉！！！;

70分 WA；

咳咳；默默加大inf；然后我们就完美A了此题；
## 上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=80005;
const int mod=1000000;
const int inf=1e9;
int n,ans,a,b,R,sum,num[N];
int ch[N][2],size[N],val[N],rd[N];
void rotate(int &q,int d)
{
	int k=ch[q][d];
	ch[q][d]=ch[k][d^1];
	ch[k][d^1]=q;
	size[k]=size[q];
	size[q]=size[ch[q][0]]+size[ch[q][1]]+1;
	q=k;
}
void ins(int &q,int x)
{
	if(!q)
	{
		q=++sum;
		size[q]=1;val[q]=x;
		rd[q]=rand(); return;
	}
	size[q]++;
	if(val[q]<x)
	{
		ins(ch[q][1],x);
		if(rd[q]>rd[ch[q][1]]) rotate(q,1);
	}
	else
	{
		ins(ch[q][0],x);
		if(rd[q]>rd[ch[q][0]]) rotate(q,0);
    }
}
void del(int &q,int x)
{
	if(!q) return;
	if(val[q]==x)
	{
		if(ch[q][0]==0||ch[q][1]==0) q=ch[q][0]+ch[q][1];
		else if(rd[ch[q][0]]<rd[ch[q][1]]) rotate(q,0),del(q,x);
		else rotate(q,1),del(q,x);
	}
	else
	{
		size[q]--;
		if(val[q]>x) del(ch[q][0],x);
		else del(ch[q][1],x);
	}
}
int qq(int q,int x)
{
	if(!q) return -inf;
	if(val[q]>x) return qq(ch[q][0],x);
	else return max(val[q],qq(ch[q][1],x));
}
int hq(int q,int x)
{
	if(!q) return inf;
	if(val[q]<x) return hq(ch[q][1],x);
	else return min(val[q],hq(ch[q][0],x));
}
int main()
{
	scanf("%d",&n);int c=-1;
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d",&a,&b);
		if(c==a) ins(R,b);
		else if(size[R]){
			int hhh=qq(R,b),ggg=hq(R,b);
			if(b-hhh<=ggg-b) ans=(ans+b-hhh)%mod,del(R,hhh);
			else ans=(ans+ggg-b)%mod,del(R,ggg);
		}
		else c=a,ins(R,b);
	}
	printf("%d",ans);
	return 0;
}
```
代码较丑，请各位大佬见谅；

完结撒花   φ(>ω<*) 


---

## 作者：Mosher (赞：0)

### 看见没有用2个SPLAY的题解，于是我又来水一波rp

**正文：**

解题思路：（老实说完全没有紫题难度。。。）

1. 题干：
	```
	目前未被领养的宠物中特点值最接近a的一只宠物
	那个希望被领养宠物的特点值最接近该宠物特点值的领养者
	```
	明显的提示了要找前驱和后继了qwq
2. 分析：

    合理性：每次宠物与领养者匹配均与前面插入有关，若使其有序（平衡树），即可查找。（毕竟未说最佳匹配，不然估计要dp啦）
    
3. 算法：平衡树或STL

4. PS：坑点：开long long。。。（原因（个人推测）：中间玄学出错，地址乱跳）

	也能避免，比如写成这样：
    a=(a%mod+abs()%mod+mod)%mod;
    //严谨保证，没试，但我觉得可以

**Code（详细讲解在代码中）：**
```cpp
#include<bits/stdc++.h>
using namespace std;
#define il inline
#define ll long long
const ll mod=1000000;
const ll maxn=8e4+5;//80000是够的，当然空间限制大，不怕就20万起步
ll n,op,b,ans;
ll son0[maxn][2],f0[maxn],cnt0[maxn],sz0[maxn],val0[maxn],rt0,ncnt0,tot0;
ll son[maxn][2],f[maxn],cnt[maxn],sz[maxn],val[maxn],rt,ncnt,tot;

il ll read(){
	ll x=0,f=1;char a=getchar();
	while(!isdigit(a)) {if(a=='-') f=-1;a=getchar();}
	while(isdigit(a)) {x=x*10+a-'0';a=getchar();}
	return x*f;
}

/*-------------------------*/
//宠物树：

il bool chk0(ll x){
	return son0[f0[x]][1]==x;
}

il void pushup0(ll x){
	sz0[x]=sz0[son0[x][1]]+sz0[son0[x][0]]+cnt0[x];
}

il void rotate0(ll x){
	ll y=f0[x],z=f0[y],k=chk0(x),w=son0[x][k^1];
	son0[y][k]=w;f0[w]=y;
	son0[z][chk0(y)]=x;f0[x]=z;
	son0[x][k^1]=y;f0[y]=x;
	pushup0(y);pushup0(x);
}

il void splay0(ll x,ll goal=0){
	while(f0[x]!=goal){
		ll y=f0[x],z=f0[y];
		if(z!=goal){
			if(chk0(x)==chk0(y)) rotate0(y);
			else rotate0(x);
		}
		rotate0(x);
	}
	if(!goal) rt0=x;
}

il void find0(ll x){
	ll cur=rt0;
	while(son0[cur][x>val0[cur]]&&x!=val0[cur]) cur=son0[cur][x>val0[cur]];
	splay0(cur);
}

il void insert0(ll x){
	ll cur=rt0,p=0;
	while(cur&&x!=val0[cur]){
		p=cur;
		cur=son0[cur][x>val0[cur]];
	}
	if(cur) cnt0[cur]++;
	else{
		cur=++ncnt0;
		if(p) son0[p][x>val0[p]]=cur;
		son0[cur][1]=son0[cur][0]=0;
		val0[cur]=x;f0[cur]=p;
		sz0[cur]=cnt0[cur]=1;
	}
	splay0(cur);
}

il ll pre0(ll x){
	find0(x);
	if(x>val0[rt0]) return rt0;
	ll cur=son0[rt0][0];
	while(son0[cur][1]) cur=son0[cur][1];
	return cur;
}

il ll succ0(ll x){
	find0(x);
	if(x<val0[rt0]) return rt0;
	ll cur=son0[rt0][1];
	while(son0[cur][0]) cur=son0[cur][0];
	return cur;
}

il void remove0(ll x){
	ll last=pre0(x),nxt=succ0(x);
	splay0(last);splay0(nxt,last);
	ll del=son0[nxt][0];
	if(cnt0[del]>1){
		cnt0[del]--;
		splay0(del);
	}
	else son0[nxt][0]=0;
}

/*-------------------------------------*/
//顾客树:

il bool chk(ll x){
	return son[f[x]][1]==x;
}

il void pushup(ll x){
	sz[x]=sz[son[x][1]]+sz[son[x][0]]+cnt[x];
}

il void rotate(ll x){
	ll y=f[x],z=f[y],k=chk(x),w=son[x][k^1];
	son[y][k]=w;f[w]=y;
	son[z][chk(y)]=x;f[x]=z;
	son[x][k^1]=y;f[y]=x;
	pushup(y);pushup(x);
}

il void splay(ll x,ll goal=0){
	while(f[x]!=goal){
		ll y=f[x],z=f[y];
		if(z!=goal){
			if(chk(x)==chk(y)) rotate(y);
			else rotate(x);
		}
		rotate(x);
	}
	if(!goal) rt=x;
}

il void find(ll x){
	ll cur=rt;
	while(son[cur][x>val[cur]]&&x!=val[cur]) cur=son[cur][x>val[cur]];
	splay(cur);
}

il void insert(ll x){
	ll cur=rt,p=0;
	while(cur&&x!=val[cur]){
		p=cur;
		cur=son[cur][x>val[cur]];
	}
	if(cur) cnt[cur]++;
	else{
		cur=++ncnt;
		if(p) son[p][x>val[p]]=cur;
		son[cur][1]=son[cur][0]=0;
		val[cur]=x;f[cur]=p;
		sz[cur]=cnt[cur]=1;
	}
	splay(cur);
}

il ll pre(ll x){
	find(x);
	if(x>val[rt]) return rt;
	ll cur=son[rt][0];
	while(son[cur][1]) cur=son[cur][1];
	return cur;
}

il ll succ(ll x){
	find(x);
	if(x<val[rt]) return rt;
	ll cur=son[rt][1];
	while(son[cur][0]) cur=son[cur][0];
	return cur;
}

il void remove(ll x){
	ll last=pre(x),nxt=succ(x);
	splay(last);splay(nxt,last);
	ll del=son[nxt][0];
	if(cnt[del]>1){
		cnt[del]--;
		splay(del);
	}
	else son[nxt][0]=0;
}

int main(){
	n=read();
	insert(INT_MAX);insert(-INT_MAX);//边界
	insert0(INT_MAX);insert0(-INT_MAX);
	for(ll i=1;i<=n;++i){
		ll op,x,p,q;
		op=read();x=read();
		if(op==0)
		{//当前宠物是否可以与原先已插入顾客匹配.
			if(!tot) insert0(x),tot0++;//不能：插入宠物树，计数器++；
			else
			{//能：比较前驱，后继，选择更优，当然匹配上了，删除用掉的,计数器--；
				p=val[pre(x)],q=val[succ(x)];
				if(abs(p-x)<=abs(q-x)) (ans+=abs(p-x))%=mod,remove(p),tot--;
				else (ans+=abs(q-x))%=mod,remove(q),tot--;
			}
		}
		else
		{//同理
			if(!tot0) insert(x),tot++;
			else{
				p=val0[pre0(x)],q=val0[succ0(x)];
				if(abs(p-x)<=abs(q-x)) (ans+=abs(p-x))%=mod,remove0(p),tot0--;
				else (ans+=abs(q-x))%=mod,remove0(q),tot0--;
			}
		}
	}
	printf("%lld",(ans%mod+mod)%mod);//假装严谨
}
```
rp++

---

## 作者：FREEH (赞：0)

### 【题目】
![题目](https://cdn.luogu.com.cn/upload/pic/70083.png)

### 【解题思路】
- 记录当前供大于求的生物是人还是宠物
	- 然后如果是同类就把该生物的属性插入Treap，
    - 否则就相当于查找属性的前驱和后继，取较相近值，并删除该点
- 由于如果出现供大于求的生物轮换的情况时，Treap肯定是空的，因此只需一棵Treap即可

### 【时空复杂度】
- $O(nlogn)$

### 【参考程序】
```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iostream>
using namespace std;
int n,SUM,cnt,ans,root=-1;
struct TREAP{
	int ls,rs,x;
	unsigned long long fix;
}treap[100005];
int make_rand()
{
	return rand()*rand()*rand();
}
int Push(int x)
{
	int p=++SUM;
	treap[p].x=x;
	treap[p].ls=treap[p].rs=-1;
	treap[p].fix=make_rand();
	return p;
}
void R_romote(int &p)
{
	int lp=treap[p].ls;
	treap[p].ls=treap[lp].rs;
	treap[lp].rs=p;
	p=lp;
}
void L_romote(int &p)
{
	int rp=treap[p].rs;
	treap[p].rs=treap[rp].ls;
	treap[rp].ls=p;
	p=rp;
}
void Ins(int &p,int x)
{
	if (p==-1)
	{
		p=Push(x);
		return;
	}
	int &lp=treap[p].ls,&rp=treap[p].rs;
	if (x<treap[p].x)
	{
		Ins(lp,x);
		if (treap[lp].fix>treap[p].fix)
			R_romote(p);
	}
	else
	{
		Ins(rp,x);
		if (treap[rp].fix>treap[p].fix)
			L_romote(p);
	}
}
void Del(int &p,int x)
{
	if (treap[p].x==x)
	{
		if (treap[p].ls!=-1&&treap[p].rs!=-1)
		{
			if (treap[treap[p].ls].fix>treap[treap[p].rs].fix)
			{
				R_romote(p);
				Del(treap[p].rs,x);
			}
			else
			{
				L_romote(p);
				Del(treap[p].ls,x);
			}
		}
		else
		if (treap[p].ls==-1&&treap[p].rs!=-1)
			p=treap[p].rs;
		else
		if (treap[p].ls!=-1&&treap[p].rs==-1)
			p=treap[p].ls;
		else
			p=-1;
		return;
	}
	else
	if (x<treap[p].x)
		Del(treap[p].ls,x);
	else
		Del(treap[p].rs,x);
}
#define INF 2000000000
int Nxt(int p,int x)
{
	if (p==-1) return INF;
	if (treap[p].x<x)
		return Nxt(treap[p].rs,x);
	else
		return min(Nxt(treap[p].ls,x),treap[p].x);
}
int Pre(int p,int x)
{
	if (p==-1) return -INF;
	if (treap[p].x>x)
		return Pre(treap[p].ls,x);
	else
		return max(Pre(treap[p].rs,x),treap[p].x);
}

#define Mod 1000000
void mo(int &x)
{
	x%=Mod;
}
int main()
{
	scanf("%d",&n);
	int type=0;
	for (int i=1;i<=n;i++)
	{
		int cmd,x;
		scanf("%d%d",&cmd,&x);
		if (!cnt)
			type=cmd;
		if (cmd==type)
		{
			cnt++;
			Ins(root,x);
		}
		else
		{
			cnt--;
			int a=Pre(root,x),b=Nxt(root,x);
			if (abs(a-x)<=abs(b-x))
			{
				mo(ans+=abs(a-x));
				Del(root,a);
			}
			else
			{
				mo(ans+=abs(b-x));
				Del(root,b);
			}
		}	
	}
	printf("%d",ans);
	return 0;
}
```


---

## 作者：AmadeusSG (赞：0)

伸展树Splay
把前驱和后继求出来进行比较，累加到ans里后就可以再删去

时间复杂度O（nlogn）
```
#include<bits/stdc++.h>
#define mod 1000000
using namespace std;
struct Tree {
	int data,l,r,ln,rn,fa;
} t[100005];
int n,m,root,tot,ans;
void zig(int x) {
	int y=t[x].fa;
	t[y].l=t[x].r;
	if(t[x].r)t[t[x].r].fa=y;
	t[x].fa=t[y].fa;
	if(t[y].fa) {
		if(y==t[t[y].fa].l)t[t[y].fa].l=x;
		else t[t[y].fa].r=x;
	}
	t[y].fa=x;
	t[x].r=y;
	t[y].ln=t[x].rn;
	t[x].rn=t[y].ln+t[y].rn+1;
}
void zag(int x) {
	int y=t[x].fa;
	t[y].r=t[x].l;
	if(t[x].l)t[t[x].l].fa=y;
	t[x].fa=t[y].fa;
	if(t[y].fa) {
		if(y==t[t[y].fa].l)t[t[y].fa].l=x;
		else t[t[y].fa].r=x;
	}
	t[y].fa=x;
	t[x].l=y;
	t[y].rn=t[x].ln;
	t[x].ln=t[y].ln+t[y].rn+1;
}
void Splay(int x) {
	int p;
	while(t[x].fa) {
		p=t[x].fa;
		if(t[p].fa==0) {
			if(x==t[p].l)zig(x);
			else zag(x);
			break;
		}
		if(x==t[p].l) {
			if(p==t[t[p].fa].l)zig(p),zig(x);
			else zig(x),zag(x);
		} else {
			if(p==t[t[p].fa].r)zag(p),zag(x);
			else zag(x),zig(x);
		}
	}
	root=x;
}
int ahead(int x) {
//	find(x);
	//cout<<"---"<<root<<" "<<t[root].data;
	int p=t[root].l;
	while(t[p].r) {
		p=t[p].r;
	}
	if(p)return p;
	return -1;
}
int last(int x) {
//	find(x);
	int p=t[root].r;
	while(t[p].l) {
		p=t[p].l;
	}
	if(p)return p;
	return -1;
}
void erase(int x) {
	Splay(x);
//	cout<<root<<" FS "<<x<<" S ";
	int p=root;
	int ls=t[p].l,rs=t[p].r;
	if(!ls&&!rs) {
		root=0;
//		cout<<root<<" -A"<<endl;
		return;
	}
	if(!ls) {
		root=rs;
//		cout<<root<<" -B"<<endl;
		t[rs].fa=0;
		return;
	}
	if(!rs) {
		root=ls;
		t[ls].fa=0;
//		cout<<root<<" -C"<<endl;
		return;
	}
	p=ls;
	t[ls].fa=0;
	while(t[p].r)p=t[p].r;
	Splay(p);
	t[p].r=rs;
	t[rs].fa=p;
	t[p].rn=t[rs].ln+t[rs].rn+1;
//	cout<<root<<" -D"<<endl;
}
void add(int x) {
	int p=root,f;
	while(p) {
		f=p;
		if(x<=t[p].data) {
			t[p].ln++;
			p=t[p].l;
		} else {
			t[p].rn++;
			p=t[p].r;
		}
	}
	tot++;
	t[tot].data=x;
	t[tot].fa=t[tot].l=t[tot].ln=t[tot].r=t[tot].rn=0;
	if(root==0) {
		root=tot;
		return;
	}
	t[tot].fa=f;
	if(x<=t[f].data)t[f].l=tot;
	else t[f].r=tot;
	Splay(tot);
}
int main() {
	int i,j,pet=0,cost=0;
	cin>>n;
	for(i=1; i<=n; i++) {
		int x,y;
		cin>>x>>y;
		if(x==1) cost++;
		else pet++;
		if(pet!=0&&cost!=0) {
		//	cout<<root<<endl;
			add(y);
			int QQ=ahead(y);
			int HJ=last(y);
			
			int Q,H;
			if(HJ!=-1)
				H=abs(t[HJ].data-y);
			if(QQ!=-1)
				Q=abs(t[QQ].data-y);
			if(QQ==-1) {
				ans+=H;
				ans%=mod;
				erase(root);
				erase(HJ);
				pet--;
				cost--;
//				cout<<QQ<<" FUCK "<<HJ<<" -1- "<<" Q:"<<Q<<" t:"<<y<<" ans-"<<ans<<endl;
				continue;
			}
			if(HJ==-1) {
				ans+=Q;
				ans%=mod;
				erase(root);
				erase(QQ);
				pet--;
				cost--;
//				cout<<QQ<<" FUCK "<<HJ<<" -1- "<<" Q:"<<Q<<" t:"<<y<<" ans-"<<ans<<endl;
				continue;
			}
			if(Q<=H) {
				ans+=Q;
				ans%=mod;
				erase(root);
				erase(QQ);
				pet--,cost--;
//				cout<<QQ<<" - "<<HJ<<" - "<<ans<<endl;
			} else if(Q>H) {
				ans+=H;
				ans%=mod;
				erase(root);
				erase(HJ);
				pet--,cost--;
//				cout<<QQ<<" - "<<HJ<<" - "<<ans<<endl;
			}
		} else add(y);
	}
	cout<<ans%mod;
	return 0;
}
/*
3
1 5
1 7
0 6
*/
```

---

## 作者：Harmony (赞：0)

就是维护一颗平衡树。

但是要注意一点，他这里说客人没有领到宠物的话不会走掉，而是等着宠物再来。那么我们可以开两个平衡树，一个维护等待着的宠物，一个维护等待着的人。

这里用Treap实现平衡树。

code:

```cpp
#pragma G++ optimize (2)
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstring>
#include <cstdlib>
#include <algorithm>
#include <string>
#include <queue>
#define INF 0x3f3f3f3f
#define NO 100005
#define MO 100005
typedef long long ll;
//by Oliver
using namespace std;
inline ll read()
{
    char ch = ' ', last;
    ll ans = 0;
    while (ch < '0' || ch > '9')
        last = ch, ch = getchar();
    while (ch >= '0' && ch <= '9')
        ans = ans * 10 + int(ch - '0'), ch = getchar();
    if (last == '-')
        return -ans;
    return ans;
}
void write(ll x)
{
    if (x >= 10)
        write(x / 10);
    putchar(x % 10 + '0');
}
//head

ll n, cnt, ans;
struct node
{
    ll rnd, val, lson, rson, num, siz;

};
struct TREAP
{
    node pt[NO];
    ll rt, pre, suf;

    void update(int now)
    {
        pt[now].siz = pt[pt[now].lson].siz + pt[pt[now].rson].siz + pt[now].num;
    }
    void lrot(ll &now)
    {
        int rson = pt[now].rson;
        pt[now].rson = pt[rson].lson;
        pt[rson].lson = now;
        pt[rson].siz = pt[now].siz;
        update(now);
        now = rson;
    }
    void rrot(ll &now)
    {
        int lson = pt[now].lson;
        pt[now].lson = pt[lson].rson;
        pt[lson].rson = now;
        pt[lson].siz = pt[now].siz;
        update(now);
        now = lson;
    }
    void insert(ll &now, int val)
    {
        if (!now)
        {
            now = ++cnt;
            pt[now].siz = pt[now].num = 1, pt[now].val = val, pt[now].rnd = rand();
            if (!rt)
                rt = now;
        }
        else
        {
            pt[now].siz++;
            if (pt[now].val == val)
                pt[now].num++;
            else if (val < pt[now].val)
            {
                insert(pt[now].lson, val);
                if (pt[pt[now].lson].rnd > pt[now].rnd)
                    rrot(now);
            }
            else
            {
                insert(pt[now].rson, val);
                if (pt[pt[now].rson].rnd > pt[now].rnd)
                    lrot(now);
            }
        }
    }
    void del(ll &now, int val)
    {
        if (pt[now].val > val)
            pt[now].siz--, del(pt[now].lson, val);
        else if (pt[now].val < val)
            pt[now].siz--, del(pt[now].rson, val);
        else
        {
            if (pt[now].num > 1)
                pt[now].num--, pt[now].siz--;
            else if (pt[now].lson * pt[now].rson == 0)
                now = pt[now].lson + pt[now].rson;
            else
                if (pt[pt[now].lson].rnd > pt[pt[now].rson].rnd)
                    rrot(now), del(now, val);
                else
                    lrot(now), del(now, val);
        }
    }
    void query_suf(int now, int val)
    {
        if (!now)
            return;
        if (val == pt[now].val)
        {
            suf = now;
            return;
        }
        if (val < pt[now].val)
            pre = now, query_suf(pt[now].lson, val);
        else
            query_suf(pt[now].rson, val);
    }
    void query_pre(int now, int val)
    {
        if (!now)
            return;
        if (val == pt[now].val)
        {
            pre = now;
            return;
        }
        if (val > pt[now].val)
            suf = now, query_pre(pt[now].rson, val);
        else
            query_pre(pt[now].lson, val);
    }
}h, m;
//variable

void init()
{
    n = read();
}
//functions

int main()
{
    init();
    for (int i = 1; i <= n; i++)
    {
        int ty = read(), x = read();
        if (ty == 1)
            if (!h.rt)
                m.insert(m.rt, x);
            else
            {
                h.pre = h.suf = h.rt;
                h.query_pre(h.rt, x), h.query_suf(h.rt, x);
                ll vsu = h.pt[h.suf].val, vpr = h.pt[h.pre].val;
                if (abs(x - vpr) > abs(x - vsu))
                    ans += abs(x - vsu), h.del(h.rt, vsu);
                else
                    ans += abs(x - vpr), h.del(h.rt, vpr);
            }
        if (ty == 0)
            if (!m.rt)
                h.insert(h.rt, x);
            else
            {
                m.pre = m.suf = m.rt;
                m.query_pre(m.rt, x), m.query_suf(m.rt, x);
                ll vsu = m.pt[m.suf].val, vpr = m.pt[m.pre].val;
                if (abs(x - vpr) > abs(x - vsu))
                    ans += abs(x - vsu), m.del(m.rt, vsu);
                else
                    ans += abs(x - vpr), m.del(m.rt, vpr);
            }
    }
    cout << ans % 1000000 << endl;
    return 0;
}
//main

```

但是我们可以发现，只有当没有宠物的时候，我们才有人的树，而只有当没有人的时候，我们才有宠物树。所以我们可不可以把两棵树合并呢？

肯定可以！

这样之后我们并没有节省空间。（实际上更大更慢。。）

但是我们可以节省很多代码！（30~40行）

也不用把函数套在结构体里面。（什么m. h. 多麻烦）

所以他是有那么一点用的。。

code:
```cpp
#pragma G++ optimize (2)
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstring>
#include <cstdlib>
#include <algorithm>
#include <string>
#include <queue>
#define INF 0x3f3f3f3f
#define NO 100005
#define MO 100005
typedef long long ll;
//by Oliver
using namespace std;
inline ll read()
{
	char ch = ' ', last;
	ll ans = 0;
	while (ch < '0' || ch > '9')
		last = ch, ch = getchar();
	while (ch >= '0' && ch <= '9')
		ans = ans * 10 + int(ch - '0'), ch = getchar();
	if (last == '-')
		return -ans;
	return ans;
}
void write(ll x)
{
	if (x >= 10)
		write(x / 10);
	putchar(x % 10 + '0');
}
//head

int n, rt, cnt, pre, suf, ans;
bool f;
struct node
{
	int lson, rson, rnd, val, siz, num;
}pt[NO];
//variable

void update(int now)
{
	pt[now].siz = pt[pt[now].lson].siz + pt[pt[now].rson].siz + pt[now].num;
}
void lrot(int &now)
{
	int rson = pt[now].rson;
	pt[now].rson = pt[rson].lson;
	pt[rson].lson = now;
	pt[rson].siz = pt[now].siz;
	update(now);
	now = rson;
}
void rrot(int &now)
{
	int lson = pt[now].lson;
	pt[now].lson = pt[lson].rson;
	pt[lson].rson = now;
	pt[lson].siz = pt[now].siz;
	update(now);
	now = lson;
}
void insert(int &now, int val)
{
	if (!now)
	{
		now = ++cnt;
		pt[now].siz = pt[now].num = 1, pt[now].val = val, pt[now].rnd = rand();
		if (!rt)
			rt = now;
	}
	else
	{
		pt[now].siz++;
		if (pt[now].val == val)
			pt[now].num++;
		else if (pt[now].val > val)
		{
			insert(pt[now].lson, val);
			if (pt[pt[now].lson].rnd > pt[now].rnd)
				rrot(now);
		}
		else
		{
			insert(pt[now].rson, val);
			if (pt[pt[now].rson].rnd > pt[now].rnd)
				lrot(now);
		}
	}
}
void del(int &now, int val)
{
	if (pt[now].val > val)
		pt[now].siz--, del(pt[now].lson, val);
	else if (pt[now].val < val)
		pt[now].siz--, del(pt[now].rson, val);
	else
	{
		if (pt[now].num > 1)
			pt[now].num--, pt[now].siz--;
		else if (pt[now].lson * pt[now].rson == 0)
			now = pt[now].lson + pt[now].rson;
		else
			if (pt[pt[now].lson].rnd > pt[pt[now].rson].rnd)
				rrot(now), del(now, val);
			else
				lrot(now), del(now, val);
	}
}
void getpre(int now, int val)
{
	if (!now)
		return;
	if (pt[now].val <= val)
		pre = now, getpre(pt[now].rson, val);
	else
		getpre(pt[now].lson, val);
}
void getsuf(int now, int val)
{
	if (!now)
		return;
	if (pt[now].val >= val)
		suf = now, getsuf(pt[now].lson, val);

	else
		getsuf(pt[now].rson, val);
}
void init()
{
	n = read();
}
//functions

int main()
{
	init();
	while (n--)
	{
		//cout << f << endl;
		int ty = read(), x = read();
		if (f != ty && rt)//这里就是有一颗和现在不一样的树。那么就去找答案吧。
		{
			pre = suf = rt;
			getpre(rt, x), getsuf(rt, x);
			ll vsu = pt[suf].val, vpr = pt[pre].val;
			if (abs(x - vpr) > abs(x - vsu))
				ans += abs(x - vsu), del(rt, vsu);
			else
				ans += abs(x - vpr), del(rt, vpr);
		}
		else//这里缩了两种情况。一种是没有根，一种是树和现在的ty一样。所以都要insert.
			insert(rt, x), f = ty;
		ans %= 1000000;
	}
	cout << ans << endl;
	return 0;
}
//main

```

题目：[P2286 [HNOI2004]宠物收养场](https://www.luogu.org/problemnew/show/P2286)


---

## 作者：莫问 (赞：0)

~~哎呀呀，要退役惹~~
在做（mo）你赛时碰到的一道题

也不知道为什么刚开始入平衡树时SBT（雾——

看了眼题解~~好像既没有P也没有SBT~~

是时候升华一下自己了（顺便存代码

通常 SBT 的每一个结点包含 key，left，right 和 size 等域。size 是一个额外但是十分有用的数据域，它一直在更新，它在前面已经
定义了。
每一个在 SBT 中的结点 t，我们保证：

性质 a：
s[right [t ]]>s[left [left [t ]]], s[right [left [t ]]]

性质 b：
s[left [t]]>s[right [right [t]]], s[left [right [t]]]

发现不会放图，呃呃呃

           T
         L   R	
        A B C D
       
~~假装这里有图~~：
上述性质在这里表示为：

s[a],s[b]<s[r];

s[c],s[d]<s[l];

那么在插入完之后这些性质就可能无法满足（也就4种情况）
我们可以直接看出伪代码~~(毕竟时重复的）~~：

Maintain (t)

1 If s[left[left[t]]>s[right[t]] then

2 Right-Rotate(t)

3 Maintain(right[t])

4 Maintain(t)

5 Exit

6 If s[right[left[t]]>s[right[t]] then

7 Left-Rotate(left[t])

8 Right-Rotate(t)

9 Maintain(left[t])

10 Maintain(right[t])

11 Maintain(t)

12 Exit

13 If s[right[right[t]]>s[left[t]] then

14 Left-Rotate(t)

15 Maintain(left[t])

16 Maintain(t)

17 Exit

18 If s[left[right[t]]>s[left[t]] then

19 Right-Rotate(right[t])

20 Left-Rotate(t)

21 Maintain(left[t])

22 Maintain(right[t])

23 Maintain(t)

然鹅还有着更简单的maintain（~~删除也是~~）（见程序）

```pascal
label 10;
const inf=233333333;p=1000000;
type int=longint;bo=boolean;
type SBT=object
         tot,root:int;
         key:array[0..400000]of int64;
         a,l,r:array[0..400000]of int;
         procedure clean();
         procedure lt(var x:int);
         procedure rt(var x:int);
         procedure maintain(var x:int;flag:bo);
         procedure ins(var x:int;y:int64);
         function find(x:int;y:int64):bo;
         function delete(var x:int;y:int64):int64;
         function getpre(x:int;y:int64):int64;
         function getsuc(x:int;y:int64):int64;
         end;
         //还少了rank和selete的操作，这题不需要啦啦啦；
procedure SBT.clean();
begin
  tot:=0;root:=0;
  fillchar(key,sizeof(key),0);
  fillchar(a,sizeof(a),0);
  fillchar(l,sizeof(l),0);
  fillchar(r,sizeof(r),0);
end;
procedure SBT.lt(var x:int);
var f:int;
begin
  f:=r[x];
  r[x]:=l[f];
  l[f]:=x;
  a[f]:=a[x];
  a[x]:=a[l[x]]+a[r[x]]+1;
  x:=f;
end;
procedure SBT.rt(var x:int);
var f:int;
begin
  f:=l[x];
  l[x]:=r[f];
  r[f]:=x;
  a[f]:=a[x];
  a[x]:=a[l[x]]+a[r[x]]+1;
  x:=f;
end;
procedure SBT.maintain(var x:int;flag:bo);
begin
  if not flag then
    begin
      if a[l[l[x]]]>a[r[x]] then
        rt(x)
      else
        if a[r[l[x]]]>a[r[x]] then
          begin
            lt(l[x]);
            rt(x);
          end
        else
          exit();
    end
  else
    begin
      if a[r[r[x]]]>a[l[x]] then
        lt(x)
      else
        if a[l[r[x]]]>a[l[x]] then
          begin
            rt(r[x]);
            lt(x);
          end
        else
          exit();
    end;
  maintain(l[x],false);
  maintain(r[x],true);
  maintain(x,false);
  maintain(x,true);
end;
procedure SBT.ins(var x:int;y:int64);
begin
  if x=0 then
    begin
      inc(tot);
      x:=tot;
      a[x]:=1;
      l[x]:=0;
      r[x]:=0;
      key[x]:=y;
    end
  else
    begin
      inc(a[x]);
      if y<key[x] then
        ins(l[x],y)
      else
        ins(r[x],y);
      maintain(x,y>=key[x]);
    end;
end;
function SBT.find(x:int;y:int64):bo;
begin
  if x=0 then
    exit(false);
  if y<key[x] then
    exit(find(l[x],y))
  else
    exit((key[x]=y)or(find(r[x],y)));
end;
function SBT.delete(var x:int;y:int64):int64;
begin
  dec(a[x]);
  if(key[x]=y)or((y<key[x])and(l[x]=0))or((y>key[x])and(r[x]=0))then
    begin
      delete:=key[x];
      if(l[x]=0)or(r[x]=0)then
        x:=l[x]+r[x]
      else
        key[x]:=delete(l[x],key[x]+1);
    end
  else
    if y<key[x] then
      delete:=delete(l[x],y)
    else
      delete:=delete(r[x],y);
end;
function SBT.getpre(x:int;y:int64):int64;
begin
  if x=0 then
    exit(y);
  if y<=key[x] then
    exit(getpre(l[x],y))
  else
    begin
      getpre:=getpre(r[x],y);
      if getpre=y then
        exit(key[x]);
    end;
end;
function SBT.getsuc(x:int;y:int64):int64;
begin
  if x=0 then
    exit(y);
  if y>=key[x] then
    exit(getsuc(r[x],y))
  else
    begin
      getsuc:=getsuc(l[x],y);
      if getsuc=y then
        exit(key[x]);
    end;
end;
var human,pet:SBT;
    i,suc,pre,n,x,y,ans:int;
begin
  human.clean();
  pet.clean();
  pet.clean();
  human.ins(human.root,inf);
  human.ins(human.root,-inf);
  pet.ins(pet.root,inf);
  pet.ins(pet.root,-inf);
  readln(n);
  ans:=0;
  repeat
    dec(N);
    readln(x,y);
    if x=0 then
      begin
        if human.a[human.root]=2 then//是否有人
          begin
            pet.ins(pet.root,y);
            goto 10;
          end;
        if human.find(human.root,y) then//是否有着特点值一样的
          begin
            human.delete(human.root,y);
            goto 10;
          end;
        suc:=human.getsuc(human.root,y);//后继
        pre:=human.getpre(human.root,y);//前驱
        if(suc-y)<(y-pre)then
          begin
            ans:=(ans+suc-y)mod p;
            human.delete(human.root,suc);
          end
        else
          begin
            ans:=(ans+y-pre)mod p;
            human.delete(human.root,pre);
          end;
      end
    else//下同
      begin
        if pet.a[pet.root]=2 then
          begin
            human.ins(human.root,y);
            goto 10;
          end;
        if pet.find(pet.root,y) then
          begin
            pet.delete(pet.root,y);
            goto 10;
          end;
        suc:=pet.getsuc(pet.root,y);
        pre:=pet.getpre(pet.root,y);
        if(suc-y)<(y-pre)then
          begin
            ans:=(ans+suc-y)mod p;
            pet.delete(pet.root,suc);
          end
        else
          begin
            ans:=(ans+y-pre)mod p;
            pet.delete(pet.root,pre);
          end;
      end;
  10:until n=0;
  writeln(ans);
end.
```
似乎有点长。。。。
用了神奇的object和label；
so我很想知道public怎么用（会的私我）！！至今未搞懂QAQ

~~（发现用了pascal总是打；）；~~

---

## 作者：xryjr233 (赞：0)

一道平衡树裸题，我使用的是Splay~~因为太弱了不会Treap~~。

关于Splay->[Splay](https://www.luogu.org/blog/xryjr233/post-20181024splay-shen-zhan-shu-shuo-ju-jie-gou-post)

相当于对于一个不同于目前多余种类(人或狗)的人或狗来到,我们要查找剩余的不同物种中与Ta的特征值最相近的，可以发现这个不同物种的特征值最优可以与Ta的特征值相同，否则要么是Ta的特征值的前驱,要么是Ta的特征值的后继,其中与Ta的差绝对值小的将被领养，相等时领养前驱。

我们采用Splay来维护。

一个数$s$记录目前剩余的种类及数量(多余人为正,多余狗为负)，当读入一个不同种类时进行上述查询，累加答案并删除选中的点。当读入同种类时将它的特征值加入Splay。

code:

共194行。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=1e6;
struct node{//由于没有重复所以不用维护数量
    int f,c[2],v;
}t[80010];
int n,k,s,t1,t2,rt,cnt,a,ans;
void Rotate(int x){//旋转
    int y=t[x].f,z=t[y].f;
    int c=t[y].c[1]==x,gc=t[z].c[1]==y;
    t[z].c[gc]=x;
    t[x].f=z;
    t[y].c[c]=t[x].c[c^1];
    t[t[x].c[c^1]].f=y;
    t[x].c[c^1]=y;
    t[y].f=x;
}
void Splay(int x,int f){//伸展
    while(t[x].f!=f){
        int y=t[x].f,z=t[y].f;
        if(z==f){
            Rotate(x);
        }else{
            int c=t[y].c[1]==x,gc=t[z].c[1]==y;
            if(c==gc){
                Rotate(y);
            }else{
                Rotate(x);
            }
            Rotate(x);
        }
    }
    if(f==0){
        rt=x;
    }
}
void Create(int &x,int f,int v){//新建节点
    x=++cnt;
    t[x].f=f;
    t[x].c[0]=0;
    t[x].c[1]=0;
    t[x].v=v;
}
void Insert(int x){//加入
    if(!rt){
        Create(rt,0,x);
    }else{
        int nw=rt;
        while(nw){
            if(t[nw].v>x){
                if(!t[nw].c[0]){
                    Create(t[nw].c[0],nw,x);
                    nw=t[nw].c[0];
                    break;
                }
                nw=t[nw].c[0];
            }else{
                if(!t[nw].c[1]){
                    Create(t[nw].c[1],nw,x);
                	nw=t[nw].c[1];
					break;
				}
				nw=t[nw].c[1];
			}
		}
		Splay(nw,0);
	}
}
void Find(int x){//查找
	int nw=rt;
	while(nw){
		if(t[nw].v==x){
			break;
		}
		if(t[nw].v>x){
			if(!t[nw].c[0]){
				break;
			}
			nw=t[nw].c[0];
		}else{
			if(!t[nw].c[1]){
				break;
			}
			nw=t[nw].c[1];
		}
	}
	Splay(nw,0);
}
int Next(int x,int op){//前驱/后继
	Find(x);
	if(t[rt].v>x&&op==1){
		return rt;
	}
	if(t[rt].v<x&&op==0){
		return rt;
	}
	int nw=t[rt].c[op];
	while(nw&&t[nw].c[op^1]){
		nw=t[nw].c[op^1];
	}
	return nw;
}
void Delete(int x){//删除
	int lst=Next(t[x].v,0),nxt=Next(t[x].v,1);
	if(lst&&nxt){
		Splay(lst,0);
		Splay(nxt,lst);
		t[t[nxt].c[0]].f=0;
		t[nxt].c[0]=0;
	}else if(lst){
		Splay(lst,0);
		t[t[lst].c[1]].f=0;
		t[lst].c[1]=0;
	}else if(nxt){
		Splay(nxt,0);
		t[t[nxt].c[0]].f=0;
		t[nxt].c[0]=0;
	}else{
		rt=0;
	}
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d%d",&k,&a);
		if(k==1){
			s++;
			if(s<=0){
				Find(a);
				if(t[rt].v==a){//存在相等特征值
					Delete(rt);
				}else{
					t1=Next(a,0);
					t2=Next(a,1);
					if(t1&&t2){
						if(a-t[t1].v<=t[t2].v-a){//由于相等时优先领养小的,所以是<=
							ans+=a-t[t1].v;
							Delete(t1);
						}else{
							ans+=t[t2].v-a;
							Delete(t2);
						}
					}else if(t1){
						ans+=a-t[t1].v;
						Delete(t1);
					}else if(t2){
						ans+=t[t2].v-a;
						Delete(t2);
					}else{//只有一个点
						ans+=abs(t[rt].v-a);
						Delete(rt);
					}
					ans%=mod;
				}
			}else{
				Insert(a);
			}
		}else{//读入狗,类似人
			s--;
			if(s>=0){
				Find(a);
				if(t[rt].v==a){
					Delete(rt);
				}else{
					t1=Next(a,0);
					t2=Next(a,1);
					if(t1&&t2){
						if(a-t[t1].v<=t[t2].v-a){
							ans+=a-t[t1].v;
							Delete(t1);
						}else{
							ans+=t[t2].v-a;
							Delete(t2);
						}
					}else if(t1){
						ans+=a-t[t1].v;
						Delete(t1);
					}else if(t2){
						ans+=t[t2].v-a;
						Delete(t2);
					}else{
						ans+=abs(t[rt].v-a);
						Delete(rt);
					}
					ans%=mod;
				}
			}else{
				Insert(a);
			}
		}
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：bztMinamoto (赞：0)

致敬一下楼下yyb大佬（我的splay基本就是他教的）

先讲一下思路：用一个变量k（0或1）来表示当前的splay中到底存的是顾客还是宠物。如果读入和k一样，直接push，如果不一样，找到之后删除并累加答案

讲几个注意点

1.如果splay为空时，直接更改k

2.找读入宠物（或顾客）的特征值的前缀和后缀时，记得是>=和<=，如果pop用了找前缀和后缀的话（如楼下yyb大佬），记得写两个找前缀和后缀的（因为两个不一样）

4.pop的时候pushup一下（鬼知道我没写pushup的代码怎么过模板的）

3.及时模，及时模，及时膜！！！（因为非常重要所以说三遍）

上代码

```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cctype>
#include<cmath>
using namespace std;
#define getc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<15,stdin),p1==p2)?EOF:*p1++)
char buf[1<<15],*p1=buf,*p2=buf;
const int inf=0x3f3f3f3f,N=100050;
inline int read(){
	#define num ch-'0'
	char ch;bool flag=0;int res;
	while(!isdigit(ch=getc()))
	(ch=='-')&&(flag=true);
	for(res=num;isdigit(ch=getc());res=res*10+num);
	(flag)&&(res=-res);
	#undef num
	return res;
}
struct Splay{
    struct node{
        int v,father,ch[2];
        int sum,recy;
    } e[N];
    int n,root,ans,k=-1;
    void update(int x){
        e[x].sum=e[e[x].ch[0]].sum+e[e[x].ch[1]].sum+e[x].recy;
    }
    int identify(int x){
        return e[e[x].father].ch[1]==x;
    }
    void connect(int x,int f,int son){
        e[x].father=f,e[f].ch[son]=x;
    }
    void rotate(int x){
        int y=e[x].father,z=e[y].father;
        int yson=identify(x),zson=identify(y);
        int b=e[x].ch[yson^1];
        connect(b,y,yson),connect(y,x,(yson^1)),connect(x,z,zson);
        update(y),update(x);
    }
    void splay(int x,int goal){
        while(e[x].father!=goal){
            int y=e[x].father,z=e[y].father;
            if(z!=goal)
            (identify(x)^identify(y))?rotate(x):rotate(y);
            rotate(x);
        }
        if(goal==0) root=x;
    }
    void push(int v){
        int now=root,f=0;
        while(now&&e[now].v!=v){
            f=now;
            now=e[now].ch[v>e[now].v];
        }
        if(now) e[now].recy++;
        else{
            now=++n;
            if(f) e[f].ch[v>e[f].v]=now;
            e[n].ch[0]=e[n].ch[1]=0;
            e[n].father=f,e[n].v=v;
            e[n].recy=e[n].sum=1;
        }
        splay(now,0);
    }
    void find(int v){
        int now=root;
        if(!now) return;
        while(e[now].ch[v>e[now].v]&&v!=e[now].v)
        now=e[now].ch[v>e[now].v];
        splay(now,0);
    }
    int Next(int v,int f){
        find(v);
        int now=root;
        if((e[now].v>v&&f)||(e[now].v<v&&!f)) return now;
        now=e[now].ch[f];
        while(e[now].ch[f^1]) now=e[now].ch[f^1];
        return now;
    }
    int Next2(int v,int f){
        find(v);
        int now=root;
        if((e[now].v>=v&&f)||(e[now].v<=v&&!f)) return now;
        now=e[now].ch[f];
        while(e[now].ch[f^1]) now=e[now].ch[f^1];
        return now;
    }
    void pop(int v){
        int lower=Next(v,0);
        int upper=Next(v,1);
        splay(lower,0),splay(upper,lower);
        int del=e[upper].ch[0];
        if(e[del].recy>1){
            e[del].recy--;
            splay(del,0);
        }
        else e[upper].ch[0]=0;
        update(upper),update(lower);
    }
    void insert(int v){
        int lower=Next2(v,0);
        int upper=Next2(v,1);
        int a=abs(e[lower].v-v),b=abs(e[upper].v-v);
        if(a==b)
        ans=(ans+a)%1000000,pop(e[lower].v);
        else
        ans=(ans+min(a,b))%1000000,pop(e[a<b?lower:upper].v);
	}
    void solve(){
    	int a,b;
    	a=read(),b=read();
    	if(e[root].sum==2){
    		k=a,push(b);return;
		}
		if(k==a){push(b);return;}
		else insert(b);
	}
    void init(){n=root=0;push(inf),push(-inf);}
}F;
int n;
int main(){
	//freopen("testdata.in","r",stdin);
	F.init();n=read();
	for(int i=1;i<=n;i++) F.solve();
	printf("%d",F.ans);
	return 0;
}
```

---

## 作者：远航之曲 (赞：0)

有缩进见[这里](http://www.yhzq-blog.cc/bzoj-1208-hnoi2004宠物收养所/)


题解

对于每一次查询，只有可能一棵splay中全是宠物或人，立一个flag，表示现在树里是宠物还是人，每次查询前驱和后继，找到绝对值小的。


flag更新：root为0


注：没有重复元素，非常良心。。。


代码写得又臭又长




```cpp
#include <cstdio>
#include <cstdlib>
#define Maxn 500000
using namespace std;
int root,sz,siz[Maxn],f[Maxn],ch[Maxn][2],key[Maxn];
int get(int x)
{
    return ch[f[x]][1]==x;
}
void update(int x)
{
    siz[x]=siz[ch[x][0]]+siz[ch[x][1]];
}
void rotate(int x)
{
    int k=get(x),fa=f[x],fafa=f[fa];
    ch[fa][k]=ch[x][!k];f[ch[x][!k]]=fa;
    ch[x][!k]=fa;f[fa]=x;
    f[x]=fafa;
    if (fafa)
        ch[fafa][ch[fafa][1]==fa]=x;
    update(fa);update(x);
}
void Splay(int x)
{
    int now=x;
    for (int fa;fa=f[now];rotate(now))
        if (f[fa])
            rotate(get(fa)==get(now)?fa:now);
    root=now;
}
void create(int v)
{
    sz++;
    ch[sz][0]=ch[sz][1]=f[sz]=0;
    siz[sz]=1;
    key[sz]=v;
}
void insert(int v)
{
    if (!root)
    {
        create(v);
        root=sz;
        return;
    }
    int now=root,fa=0;
    while(1)
    {
        fa=now;
        now=ch[fa][key[fa]<v];
        if (!now)
        {
            create(v);
            f[sz]=fa;
            ch[fa][v>key[fa]]=sz;
            update(fa);
            Splay(sz);
            break;
        }
    }
}
int tree_max(int x)
{
    while(ch[x][1])    x=ch[x][1];
    return x;
}
int tree_min(int x)
{
    while(ch[x][0]) x=ch[x][0];
    return x;
}
int pre(int x)
{
    return tree_max(ch[x][0]);
}
int nex(int x)
{
    return tree_min(ch[x][1]);
}
void Splayv(int v)
{
    int now=root,fa=0；
    while(1)
    {
        if (key[now]==v)
        {
            Splay(now);
            return;
        }
        now=ch[now][v>key[now]];
    }
}
void clear(int x)
{
    ch[x][0]=ch[x][1]=f[x]=siz[x]=key[x]=0;
}
void del(int v)
{
    Splayv(v);
    if (!ch[root][1] && !ch[root][0])
    {
        clear(root);
        root=0;
        return;
    }
//    if (!ch[root][1] || !ch[root][0])
//    {
//        int temp=root,root=!ch[root][1]?ch[root][0]:ch[root][1];
//        f[root]=0;
//        clear(temp);
//        return;
//    }
    if (!ch[root][1])
    {
        int temp=root;
        root=ch[root][0];
        f[root]=0;
        clear(temp);
        return;
    }
    else
    if (!ch[root][0])
    {
        int temp=root;
        root=ch[root][1];
        f[root]=0;
        clear(temp);
        return;
    }
    int pre1=pre(root),temp=root;
    Splay(pre1);
    ch[root][1]=ch[temp][1];
    f[ch[temp][1]]=root;
    clear(temp);
    update(root);
}
int findpre(int v)
{
    insert(v);
    int k=pre(root);
    del(v);
    return k;
}
int findnex(int v)
{
    insert(v);
    int k=nex(root);
    del(v);
    return k;
}
main()
{
    int n,fx,x,flag,ans=0;
    scanf("%d",&n);
    for (int i=1;i<=n;i++)
    {
        scanf("%d%d",&fx,&x);
        if (!root)
            flag=fx;
        if (fx==flag)
            insert(x);
        else
        {
            int p,p1=findpre(x);
            int p2=findnex(x);
            if (!p2||p1&&x-key[p1]<=key[p2]-x) p=p1;
            else
            p=p2;
            ans=(ans+abs(key[p]-x))%1000000;
            del(key[p]);
        }
    }
    printf("%d",ans);
}

```

---

## 作者：斯德哥尔摩 (赞：0)

一道平衡树题，splay 是一个很好的东东，然而我发现 Treap 写的人很少，于是来一发。。。

注：一定要仔细看题，宠物可以等待，人也可以等待。。。（坑了我半小时）

即：要更换树中存储的是 宠物 还是 人。。。

其他的就是打模板了（话说 结构体指针 怎么这么容易 RE。。。）

附代码：

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<ctime>
#define MAX 999999999//最大值
#define MOD 1000000
using namespace std;
int n,m=0,answer=0,pod=0;//pod表示当前存 宠物 还是 人
struct node{
    node* son[2];
    int v,w,s,flag;
    node(){
        son[0]=son[1]=NULL;
        w=rand();
        v=0;
        s=flag=1;
    }
};
node* rt;
inline int read(){//读优。。。
    int date=0,w=1;char c=0;
    while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
    while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}
    return date*w;
}
inline int abs(int a){if(a<0)return -a;return a;}//觉得STL有点不靠谱，于是手写。。。
void maintain(node* &u){//上传
    u->s=u->flag;
    if(u->son[0]!=NULL)u->s+=u->son[0]->s;
    if(u->son[1]!=NULL)u->s+=u->son[1]->s;
}
void turn(node* &u,int f){/旋转
    node* t=u->son[f^1];
    u->son[f^1]=t->son[f];
    t->son[f]=u;
    maintain(u);
    maintain(t);
    u=t;
}
void insert(node* &u,int x){//插入
    if(u==NULL){
        u=new node;
        u->v=x;
        return;
    }
    else if(u->v==x){
        u->flag++;
        maintain(u);
        return;
    }
    int y=x>u->v?1:0;
    insert(u->son[y],x);
    if(u->son[y]->w>u->w)turn(u,y^1);
    else maintain(u);
}
void remove(node* &u,int x){//删除
    if(u==NULL)return;
    if(u->v==x){
        if(u->flag>1)u->flag--;
        else{
            if(u->son[0]==NULL&&u->son[1]==NULL)u=NULL;
            else if(u->son[0]!=NULL&&u->son[1]!=NULL){
                if(u->son[0]->w>u->son[1]->w){
                    turn(u,1);
                    remove(u->son[1],x);
                }
                else{
                    turn(u,0);
                    remove(u->son[0],x);
                }
            }
            else{
                if(u->son[0]==NULL)u=u->son[1];
                else u=u->son[0];
            }
        }
        if(u!=NULL)maintain(u);
    }
    else{
        if(x<u->v)remove(u->son[0],x);
        else if(x>u->v)remove(u->son[1],x);
        if(u!=NULL)maintain(u);
    }
}
void front(node* u,int k,int &ans){//改进版前驱
    if(u==NULL)return;
    if(u->v<k){
        if(u->v>ans)ans=u->v;
        if(u->son[1]!=NULL)front(u->son[1],k,ans);
    }
    else if(u->v==k){//就是这里。。。
        if(u->flag>=1)ans=u->v;
        else if(u->son[0]!=NULL)front(u->son[0],k,ans);
    }
    else if(u->v>k)
    if(u->son[0]!=NULL)front(u->son[0],k,ans);
}
void next(node* u,int k,int &ans){//改进版后继
    if(u==NULL)return;
    if(u->v>k){
        if(u->v<ans)ans=u->v;
        if(u->son[0]!=NULL)next(u->son[0],k,ans);
    }
    else if(u->v==k){//就是这里。。。
        if(u->flag>=1)ans=u->v;
        else if(u->son[1]!=NULL)front(u->son[1],k,ans);
    }
    else if(u->v<k)
    if(u->son[1]!=NULL)next(u->son[1],k,ans);
}
int main(){
    int f,x;
    srand(987);
    n=read();
    for(int cases=1;cases<=n;cases++){//核心
        f=read();x=read();
        if(f==pod){
            insert(rt,x);
            m++;
        }
        else if(m){
            int s1=-MAX,s2=MAX;
            front(rt,x,s1);next(rt,x,s2);
            if(abs(s1-x)>abs(s2-x)){
                answer+=abs(s2-x);
                remove(rt,s2);
                m--;
            }
            else{
                answer+=abs(s1-x);
                remove(rt,s1);
                m--;
            }
        }
        else{
            pod^=1;
            insert(rt,x);
            m++;
        }
        answer%=MOD;
    }
    printf("%d\n",answer%MOD);//输出
    return 0;
}

```

---


# [HNOI2006] 最短母串问题

## 题目描述

给定 $n$ 个字符串 $(S_1,S_2,\dots,S_n)$，要求找到一个最短的字符串 $T$，使得这 $n$ 个字符串 $(S_1,S_2,\dots,S_n)$ 都是 $T$ 的子串。

## 说明/提示

对于 $100\%$ 的数据，$n\leq 12$，每个字符串的长度不超过 $50$。

## 样例 #1

### 输入

```
2
ABCD
BCDABC```

### 输出

```
ABCDABC```

# 题解

## 作者：skydogli (赞：44)

感谢@[Duan2baka](https://www.luogu.org/space/show?uid=21682) 的思路,感觉相当清晰,但是指针稍有不爽,于是就写了个数组版的.

**主要思路**:首先按照平常$AC$自动机的步骤,建出$Trie$图,和各个点的$Fail$指针,这样我们就能通过bfs搜索出所有合法的方案.在建$Trie$图的同时,我们把单词$i$的末节点值$state$为$(1<<i)$,$Bfs$时用当前状态$\color{red} or $遍历到节点的$state$值,当$Bfs$到某个状态等于$(1<<(n)-1)$时,就证明所有的单词的末端点都遍历了一次,那这个搜索到的字符串就是我们想要的答案了.时间复杂度和空间复杂度都是$O(cnt*2^n)$,$cnt$为$Trie$树的节点数,还带$26$的常数

当然,我们把当前搜索到的字符串都存下来是相当消耗空间的,所以我们可以想出$1$个优化:因为所有$Bfs$出的状态都是由前面的状态推导出的,所以我们可以每次搜索时只记录这次搜索的字符和它是由哪个状态推导出的,输出时倒回去统计就行了.

### 看不懂也没关系~~我的表达能力我心里有点$*$数,~~ 程序的注释还是比较多的

#### 另外,$90$分的注意了,可能有相同的字符串,所以设state的初值时也要$or(1<<i)$而不是直接赋值
```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
using namespace std;
#define MN 605
int add[MN][26],fail[MN],state[MN],nod,ans[MN*(1<<12|1)],fa[MN*(1<<12|1)],n,cnt,tot;
//add:Trie树中的地址(address)
bool vis[MN][1<<12|1];
char C[MN],ch[51];
queue<int>Q,Q1,Q2;
void getfail(){
    for(int i=0;i<26;++i)
        if(add[0][i])Q.push(add[0][i]);
    while(!Q.empty()){
        int x=Q.front();
        Q.pop();
        for(int i=0;i<26;++i)
            if(add[x][i]){
                fail[add[x][i]]=add[fail[x]][i];
                state[add[x][i]]|=state[add[fail[x]][i]];//它的fail指针包含的字符串它也包含
                Q.push(add[x][i]);
            }
            else add[x][i]=add[fail[x]][i];
    }
}//AC自动机建fail树
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;++i){
        scanf("%s",ch);
        int now=0,ln=strlen(ch);
        for(int j=0;j<ln;++j){
            if(!add[now][ch[j]-'A'])add[now][ch[j]-'A']=++cnt;
            now=add[now][ch[j]-'A'];
        }
        state[now]|=1<<(i-1);//i-1也不会冲突,省一点空间
        //有重复的,要用|
    }//建trie树
    getfail();
    Q1.push(0);
    Q2.push(0);
    //Q1:在Trie中的位置
    //Q2:状态压缩,表示当前包含了哪些要求的字符串
    vis[0][0]=1;
    int Ti=0;
    while(!Q1.empty()){
        int now=Q1.front(),St=Q2.front();
        Q1.pop();Q2.pop();
        if(St==((1<<n)-1)){
            while(Ti){
                C[++nod]=ans[Ti];
                Ti=fa[Ti];
            }//递归回去求答案
            for(int i=nod;i>0;--i)putchar(C[i]+'A');
            return 0;
        }
        for(int i=0;i<26;++i){
            if(!vis[add[now][i]][St|state[add[now][i]]]){
                vis[add[now][i]][St|state[add[now][i]]]=1;
                Q1.push(add[now][i]);
                Q2.push(St|state[add[now][i]]);
                //找出现新的状态
                fa[++tot]=Ti;
                ans[tot]=i;
                //记录当前搜到的字符,同时建1棵关于答案的树,便于最后查询
            }
        }
        ++Ti;//Ti表示当前的搜索到的编号
    }
    return 0;
}
```

---

## 作者：Duan2baka (赞：31)

[Blog链接](http://blog.csdn.net/waduan2/article/details/79150703)


AC自动机多记录一个$state$表示这个点代表的状态

把所有串插进AC自动机里，串$i$的末尾的$state$就是$2^{i-1}$

构建$Fail$的时候顺便继承所有后缀的$state$


然后从根按字典序bfs，每走到一个点继承他的$state$直到包含所有串就可以啦


贴这么丑的代码真的是对不起大家的眼睛QAQ：

```cpp
#include<cstring>
#include<ctype.h>
#include<cstdio>
#include<queue>
#define N 2500050
#define mp make_pair
#define pr pair<Node*,pair<int,int> >
using namespace std;
inline int read(){
    int x=0,f=1;char c;
    do c=getchar(),f=c=='-'?-1:f; while(!isdigit(c));
    do x=(x<<3)+(x<<1)+c-'0',c=getchar(); while(isdigit(c));
    return x*f;
}
int n,k,cnt,id,state;
int fa[N],a[N];
char s[55];
bool b[1020][1<<12];
struct Node{
    Node *ch[26],*nex;
    int state,id;///这个点包含串的状态，节点编号
    Node():state(0),nex(NULL),id(++cnt){
        for(int i=0;i<26;i++)
            ch[i]=NULL;
    }
}*root=new Node,*node;
void print(int x){
    if(!x) return;
    print(fa[x]);
    printf("%c",a[x]+'A');
}
struct Aho_Corasick_Automaton{
    inline void Insert(char *s,int id){
        int len=strlen(s+1);
        Node *x=root;
        for(int i=1;i<=len;i++){
            if(!x->ch[s[i]-'A']) x->ch[s[i]-'A']=new Node;
            x=x->ch[s[i]-'A'];
        }
        x->state|=1<<id>>1;
    }
    inline void GetFail(){
        queue<Node*>q;
        for(int i=0;i<26;i++)
            if(!root->ch[i]) root->ch[i]=root;
            else root->ch[i]->nex=root,q.push(root->ch[i]);
        while(!q.empty()){
            Node *x=q.front();q.pop();
            for(int i=0;i<26;i++)
                if(x->ch[i]) x->ch[i]->nex=x->nex->ch[i],q.push(x->ch[i]);
                else x->ch[i]=x->nex->ch[i];
            Node *tmp=x->nex;
            while(tmp!=root && !tmp->state) tmp=tmp->nex;
            x->state|=tmp->state;///继承所有后缀的状态
        }
    }
    inline void solve(){
        queue<pr>q;
        q.push(mp(root,mp(root->state,cnt=0)));
        b[root->id][root->state]=true;
        while(!q.empty()){
            pr x=q.front();q.pop();
            id=x.second.second;
            state=x.second.first;
            node=x.first;
            if(state==(1<<n)-1){///找到满足的，输出
                print(id);
                return;
            }
            for(int i=0;i<26;i++){
                k=state|node->ch[i]->state;///新转移出的状态
                if(b[node->ch[i]->id][k]) continue;///不走重复的
                b[node->ch[i]->id][k]=true;
                fa[++cnt]=id;a[cnt]=i;///记录路径
                q.push(mp(node->ch[i],mp(k,cnt)));
            }
        }
    }
}AC;
int main(){
    n=read();
    for(int i=1;i<=n;i++){
        scanf("%s",s+1);
        AC.Insert(s,i);
    }
    AC.GetFail();///搞Fail指针
    AC.solve();
return 0;
}

```

---

## 作者：封禁用户 (赞：21)

这题我是拿最短路写的。

首先看到多串就肯定是AC自动机，容易想到答案就是构造出Trie图上以0为起点的一条最短的到过所有串结尾的路径，因为Trie图中一条边$(s,t)$的意义就是，从s点的前缀后面添加一个这条边对应的字符，t对应的前缀是得到的字符串的一个后缀（不太明白的可以自行理解一下AC自动机的原理）。

然后到没到过某个串的结尾可以用二进制状态来表示，这样我们就把问题转化为了“在一个有向图上找一条以0为起点的最短路，并且使得路径上所有点权或起来等于$2^n-1$”（这里的点权是指，在一个点的Fail链上出现的结尾的集合，到达这个点就相当于到达这些结尾了）。

我们先来考虑怎么求这个的长度，这个比较容易，设$dp[i][S]$为到i点，已经到过的结尾集合为S，的最短长度。然后就以$dp[0][0]$为起点跑个最短路就行了（其实就是普通的bfs，因为每一步代价都是1……）。终点就是S为$2^n-1$的任意点的状态，取个最小的即可。

但是这个方案怎么出来呢？比如我们现在要求以$dp[i][S]$为起点的最短路，为了凑出方案我们需要求出它的下一个状态是多少，那么假如有一条边$(i,j)$，并且$dp[j][S|S[j]]=dp[i][S]+1$，那么可以看做这两个状态发生了转移，$dp[j][S|S[j]]$就可以是下一个状态。但是要想让它成为合法的，就必须保证从这条边走下去能够到达一个$S=2^n-1$的状态并且dp值为我们最短路跑出来的答案长度，那么我们（这个时候我们肯定就得用dfs了）就dfs这个点，并且dfs返回从这个点到一个$S=2^n-1$的状态的最短路，这样我们能够知道走这条边是不是合法的。而且为了使字典序最小，我们可以在dfs的时候从小到大枚举出边的字符，于是答案就出来了。

上代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
short trie[601][26];
short dp[601][4097];
short que1[3000001],que2[3000001];
unsigned char nxt[601][4097];
int ans,n;
int S[601];
int dfs(int pt,int zt){
	if(zt==((1<<n)-1))return(dp[pt][zt]);
	for(register int i=0;i<26;i++){
		if(trie[pt][i]){
			int me=trie[pt][i];if(dp[me][zt|S[me]]==dp[pt][zt]+1){
				int cjr=dfs(me,zt|S[me]);
			//	if(pt==0&&zt==0){
					//printf("(%d,%d)->(%d,%d),%d,%c\n",pt,zt,me,zt|S[me],cjr,i+'A');
			//	}
				if(cjr==ans){
					nxt[pt][zt]=i;return(ans);
				}
			}
		}
	}
	return(-1);
}
char str[100];
short fail[601];
int main(){
	cin>>n;int gn=1;for(register int i=0;i<n;i++){
		int cur=0;cin>>str;int len=strlen(str);for(register int j=0;j<len;j++){
			if(!trie[cur][str[j]-'A']){
				trie[cur][str[j]-'A']=gn;gn++;
			}cur=trie[cur][str[j]-'A'];
		}S[cur]|=(1<<i);
	}register int head=0,tail=0;
	for(register int i=0;i<26;i++){
		if(trie[0][i]){
			fail[trie[0][i]]=0;que1[tail]=trie[0][i];tail++;
		}
	}do{
		int me=que1[head];head++;for(register int i=0;i<26;i++){
			if(trie[me][i]){
				fail[trie[me][i]]=trie[fail[me]][i];que1[tail]=trie[me][i];tail++;
			}else{
				trie[me][i]=trie[fail[me]][i];
			}
		}
	}while(head<tail);
	for(register int i=0;i<gn;i++){
		int ptr=fail[i];while(ptr){
			S[i]|=S[ptr];ptr=fail[ptr];
		}for(register int j=0;j<(1<<n);j++){
			dp[i][j]=32767;
		}
	}dp[0][0]=0;head=0,tail=1;que1[0]=0;que2[0]=0;do{
		int me=que1[head],zt=que2[head];head++;for(register int i=0;i<26;i++){
			if(trie[me][i]){
				int cjr=trie[me][i];if(dp[me][zt]+1<dp[cjr][zt|S[cjr]]){
					dp[cjr][zt|S[cjr]]=dp[me][zt]+1;que1[tail]=cjr;que2[tail]=(zt|S[cjr]);tail++;
				}
			}
		}
	}while(head<tail);
	ans=32767;for(register int i=0;i<gn;i++){
		ans=min(ans,(int)dp[i][(1<<n)-1]);
	}dfs(0,0);
	int cur=0,zt=0;for(register int i=1;i<=ans;i++){
		putchar(nxt[cur][zt]+'A');int cjr=trie[cur][nxt[cur][zt]];
		cur=cjr;zt|=S[cjr];
	}
	return(0);
}
```

---

## 作者：233L (赞：11)

## 1.大致流程

先将 *n* 个字符串存入 *trie* 树中，并求出 *fail* 指针，再对这棵树进行广搜，找到每个字符串为止。

## 2.具体操作
默认大家已经掌握了[AC自动机](https://www.luogu.com.cn/problem/P3808)
。

关于如何判断找到了每个字符串，容易想到用一个二进制数来存储每个字符串是否已找到，用第i为表示第i个字符串是否已找到，如：

假设一共有5个字符串，已经找到了第1、2、4个，用二进制数表示就是 *01011* 

## 3.Code

代码里有注释 ~~所以可能看着很乱~~

```cpp
#include<bits/stdc++.h>
#define N 16
using namespace std;
int n,top;
bool vis[1<<N][N*50];
/* 
vis数组用来作标记，避免重复搜索 
	之所以广搜需要标记数组，是因为trie树的指针
	已经受到fail的污染（大雾），有可能指向前面
	的节点，所以需要标记数组避免重复搜索 
i是状态压缩，表示有哪几个字符串已经找到了
j是trie数上结点的指针 
*/ 
struct trie{
	int son[26];
	int cnt,fail;
	/* 
	cnt为状态压缩用来
	存储当前结点是哪（几）个字符串的结束位置 
	*/ 
}a[N*50];
void insert(string s,int k){
	//trie树的插入操作 
	int f,p=0,len=s.size();
	for(int i=0;i<len;i++){
		f=s[i]-65;
		if(!a[p].son[f])
			a[p].son[f]=++top;
		p=a[p].son[f];
	}
	a[p].cnt|=1<<k;
	/* 
	这里是|= 
	原因其他题解也有提到（我就是在别人题解看到的
	因为可能有相同的字符串插入trie树
	*/ 
}
void getFail(){
	//朴素的getFail 
	queue<int>q;
	for(int i=0;i<26;i++)
		if(a[0].son[i])
			q.push(a[0].son[i]);
	int u,v,fail;
	while(!q.empty()){
		u=q.front();
		fail=a[u].fail;
		q.pop();
		for(int i=0;i<26;i++){
			v=a[u].son[i];
			if(!v)
				a[u].son[i]=a[fail].son[i];
			else{
				a[v].fail=a[fail].son[i];
				q.push(v);
			}
		}
	}
}
struct afa{
	int u,v;
	//u 状态压缩
	//v 指针 
	string s;
	//s 存储路径（其实就是输出 
};
void find(){
	queue<afa>q;
	q.push({0,0,""});
	vis[0][0]=1;
	/*
	广搜用的队列 
	先将根节点入队并做标记 
	*/ 
	int u,v,w;
	int sum,k;
	string s;
	while(!q.empty()){
		u=q.front().u;
		v=q.front().v;
		s=q.front().s;
		q.pop();
		for(int i=0;i<26;i++){
			/* 
			搜索每个孩子 
				0~26的搜索顺序无形中使得输出的字符串一定是
				所有解中字典序排列的第一个 
			*/ 
			w=a[v].son[i];
			if(!vis[u][w]){
				sum=u,k=w;
				while(k){
					sum|=a[k].cnt;
					k=a[k].fail;
				}
				//注意！这里要跳fail（我写的时候就忘了 
				vis[sum][w]=1;
				if(sum+1==1<<n){
					/*
					当sum的每一位（应该是前n位）都是1时 
					每个字符串都被找到了，也就是此时的 s+char(i+65) 包含了每个字符串 
					*/
					//输出 
					cout<<s+char(i+65);
					return;
				}
				q.push({sum,w,s+char(i+65)});
			}
		}
	}
}
int main(){
	//简陋的main 
	string s;
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>s;
		insert(s,i);
	}
	getFail();
	//cout<<"sb";
	find();
}
```

## 4.我想说的话

感觉这题 ~~卡了我好一会~~ 蛮有意思的，就写了篇题解

我的第一篇题解，如有错误（或缺陷）欢迎指出

---

## 作者：ycyaw (赞：9)

看到$n<=12$的数据范围，一眼状压$dp$？随便开始敲了敲，一晚上就没了？

看到题解还有一篇状压，感觉挺麻烦的。这里给出可能稍微方便一点的。

状压状态和方程应该很好想，$f[i][j]$表示状态$i$下，最后的字符串是$j$的最短长度，因为要输出方案，再来一个$g[i][j]$表示长度最短时的字符串。

做过几题字符串接龙状压题，应该很容易写出转移方程：
$$
f[to][k]=min(f[to][k],f[i][j]+chongdie)
$$
$to$显然就是$i\ |\ (1<<(k-1))$，即状态中多接了一个$k$，$chongdie$是$k$接在$j$后面时两个字符串的重叠部分的长度，注意是有顺序的，是$k$接$j$后面。最后，当$f$数组更新时，我们同时也更新$g$数组。

具体分析一下转移：

1、$k$是$j$的子串，可以用$string$的$find$函数轻松解决，$chongdie=0$。

2、$k$不是$j$的子串，我们暴力匹配，枚举$j$从哪一位开始与$k$重叠，非常暴力，可以见代码。

答案显然易见，就是$min(\sum\limits_{i=1}^{n}f[(1<<n)-1][i]))$，然后取出所有长度最小的$g[(1<<n)-1][i]$，排遍序得到最小字典序的答案。

代码里还有部分注释，挺好懂的：
```cpp
#include<bits/stdc++.h>
#define ts cout<<"ok"<<endl
#define ll long long
#define hh puts("")
using namespace std;
int n,f[5005][13],max_status,top;
string s[105],g[5005][13],ans[105];
inline int read(){
    int ret=0,ff=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-') ff=-ff;ch=getchar();}
    while(isdigit(ch)){ret=(ret<<3)+(ret<<1)+(ch^48);ch=getchar();}
    return ret*ff;
}
inline int check(int x,int y){
    if(s[x].find(s[y])!=s[x].npos) return -1;//x包含y 
    for(int i=0;i<s[x].size();i++){//枚举j从哪一位开始与k重叠
        bool fl=1;
        for(int j=i;j<s[x].size();j++){
            if(s[y][j-i]!=s[x][j]){
                fl=0;
                break;
            }
        }
        if(fl) return s[x].size()-i;//返回重叠部分长 
    }
    return 0;
}
signed main(){
    n=read();
    for(int i=1;i<=n;i++) cin>>s[i];
    memset(f,0x3f,sizeof(f));
    f[0][0]=0;
    for(int i=1;i<=n;i++) f[1<<(i-1)][i]=s[i].length(),g[1<<(i-1)][i]=s[i];
    max_status=(1<<n)-1;
    for(int i=0;i<=max_status;i++){
        for(int j=1;j<=n;j++){//以j结尾 
            if(i&(1<<(j-1))){
                for(int k=1;k<=n;k++){//后面接k 
                    if(!(i&(1<<(k-1)))){
                        int to=i|(1<<(k-1));
                        int chong=check(j,k);//重叠部分长度 
                        if(chong==-1){//j包含k 
                            if(f[i][j]<f[to][j]||(f[i][j]==f[to][j]&&g[to][j]>g[i][j])){
                                f[to][j]=f[i][j];
                                g[to][j]=g[i][j];
                            }
                        }
                        else{
                            string t="";
                            for(int p=chong;p<s[k].size();p++) t+=s[k][p];//t是j接上k后多出来的一段字符 
                            t=g[i][j]+t;
                            if((f[i][j]+s[k].size()-chong<f[to][k])||
							(f[i][j]+s[k].size()-chong==f[to][k]&&g[to][k]>t)){
                                f[to][k]=f[i][j]+s[k].size()-chong;
                                g[to][k]=t;
                            }
                        }
                    }
                }
            }
        }
    }
    int minn=1e9;
    for(int i=1;i<=n;i++){
        if(f[max_status][i]<minn){
            minn=f[max_status][i];
            top=1;
            ans[top]=g[max_status][i];
        }
        else if(f[max_status][i]==minn) ans[++top]=g[max_status][i];
    }
    sort(ans+1,ans+top+1);//排序找字典序最小 
    cout<<ans[1];
    return 0;
}
```



---

## 作者：juicyyou (赞：6)

# P2322 [HNOI2006]最短母串问题

拿到此题后，先观察题目中给的数据范围，$n \le 12$，故可以考虑使用一些高复杂度算法解决此题。

在进行 n 个字符串的合并之前，先考虑如果只有两个字符串怎么办？我们可以贪心的去想这个问题。如果一个字符串被另一个字符串包含，则直接取另一个字符串。否则，找出 a 的一个前缀和 b 的一个后缀相等，然后把它从 b 中去掉在将 ab 直接连接起来就可以了。

比如：

$aaaabcd\,\,\,bcdaaa$ $\to$ $aaaabcdaaa$

那么有了这个思路，我们接着考虑如何求解 $n$ 个字符串的情况。

令 $dp_{i, S}$ 表示考虑 S 这个集合中的字符串合并起来且以 $s_i$ 为结尾的字符串中满足题目条件最小的一个母串，那我们可以通过预处理出每对字符串间的公共前后缀，然后就可以进行转移了。

不过需要注意的是，在 dp 前必须把所有被其他字符串包含的字符串去掉，这样 dp 就可以得出结果了。

下面是我的 Code：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
using namespace std;
typedef long long ll;
const ll maxn = (1 << 12) + 5;
string dp[maxn][12];
bool al[maxn][12];
ll ct[12][12];
ll n;
bool vis[maxn];
string s[13];
bool bel(string x, string y){
	if(x == y) return 0;
	if(y.find(x) == string::npos) return 0;
	return 1;
}
string tmp;
ll pub[13][13];
string ccc[13];
ll calc(string x, string y){
	ll l1 = x.size(), l2 = y.size();
	ll ans = 0;
	for(int i = 1;i <= l2 && i <= l1;i++){
		string c1 = y.substr(0, i), c2 = x.substr(l1 - i, i);
		if(c1 == c2) ans = i;
//		cout << c1 << " " << c2 << endl;
	}
//	puts("");
	return ans;
}
int main(){
	cin >> n;
	for(int i = 0;i < n;i++){
		cin >> tmp;
		s[i] = tmp;
	}
	for(int i = 0;i < n;i++){
		for(int j = 0;j < n;j++){
			if(i == j) continue;
			if(bel(s[i], s[j])) vis[i] = 1;
		}
	}
	ll tot = 0;
	for(int i = 0;i < n;i++){
		if(!vis[i]){
			ccc[tot] = s[i];
			tot++;
		}
	}
	for(int i = 0;i < tot;i++) s[i] = ccc[i];
	n = tot;
	for(int i = 0;i < n;i++){
		for(int j = 0;j < n;j++){
			pub[i][j] = calc(s[i], s[j]);
//			cout << pub[i][j] << " ";
		}
//		puts("");
	}
	for(int i = 0;i < n;i++){
		dp[1 << i][i] = s[i];
		al[1 << i][i] = 1;
	}
	for(int i = 1;i < (1 << n);i++){
		for(int j = 0;j < n;j++){
			if(!((i >> j) & 1)) continue;
			if(!al[i][j]) continue;
			for(int k = 0;k < n;k++){
				if((i >> k) & 1) continue;
				ll le = pub[j][k], l3 = s[k].size();
				if(al[i | (1 << k)][k] && dp[i | (1 << k)][k].size() 
				< dp[i][j].size() + l3 - le){
					continue;
				}
				tmp = s[k].substr(le, l3 - le);
				tmp = dp[i][j] + tmp;
				if(!al[i | (1 << k)][k]){
					dp[i | (1 << k)][k] = tmp;
					al[i | (1 << k)][k] = 1;
				}
				if(dp[i | (1 << k)][k].size() == tmp.size()){
					if(dp[i | (1 << k)][k] > tmp){
					    dp[i | (1 << k)][k] = tmp;
					}
				} else {
					dp[i | (1 << k)][k] = tmp;
				}
			}
		}
	}
	string ans;
	ll lee = 0x3f3f3f3f3f;
	for(int i = 0;i < n;i++){
		if(dp[(1 << n) - 1][i].size() < lee || (dp[(1 << n) - 1][i].size() == lee && dp[(1 << n) - 1][i] < ans)){
			ans = dp[(1 << n) - 1][i];
			lee = ans.size();
		}
//		cout << dp[(1 << n) - 1][i] << endl;
	}
	cout << ans << endl;
	return 0;
}
```

复杂度是 $\mathcal O(n^2 \cdot 2^n \cdot |S|)$，可以通过此题。

---

## 作者：skylee (赞：6)

本来高高兴兴写了个DP，然而发现根本无法解决字典序问题，怎么办能？

搜吧。。。。。

我们假设已经正确地写出了DP，从而得出了答案的长度以及一个字典序不怎么优的解，我们还是dfs枚举顺序，保证当前枚举字符串的字典序小于答案。

一个强剪枝：如果当前所有没有选的串的“最少选择增加量”之和加上当前字符串长度大于答案直接break

然后就过了。。。。

maya，以后这类DP题我都会做了！

```cpp

#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<string>
#include<vector>
#include<cassert>
using namespace std;
#define MAXN 13
#define MAXS 55
#define INF 0x3f3f3f3f
char str[20][55];
string res;
int bstans=INF;
namespace task1
{
        string str[MAXN];
        char ss[MAXN][MAXS];
        int len[MAXN];
        int dis[MAXN][MAXN];
        int dp[MAXN][1<<13];
        int rec[MAXN][1<<13][2];
        char res[MAXN*MAXS];
        void deal(int &x,int y)
        {
                if (x>y)x=y;
        }
        bool cmp_str(const string& s1,const string &s2)
        {
                for (int i=1;i<=min(s1.length(),s2.length());i++)
                {
                        if (s1[s1.length()-i]!=s2[s2.length()-i])return s1[s1.length()-i]<s2[s2.length()-i];
                }
                return false;
        }
        int main(int n)
        {
                int m,i,j,k1,k2,k;
                int x,y;
                for (i=0;i<n;i++)
                {
                        str[i]=::str[i];
                }
                for (j=0;j<n;j++)
                        for (i=0;i<n;i++)
                                if (i!=j && str[i].find(str[j])!=-1)
                                {
                                        swap(str[n-1],str[j]);
                                        str[--n]="";
                                        j--;
                                        break;
                                }
                sort(str,&str[n],cmp_str);
                for (i=0;i<n;i++)
                        len[i]=str[i].length(),strcpy(ss[i],str[i].c_str());
                for (i=0;i<n;i++)
                {
                        for (j=0;j<n;j++)
                        {
                                if (i==j)continue;
                                dis[i][j]=len[j];
                                for (k1=0;k1<len[i];k1++)
                                {
                                        bool flag=true;
                                        for (k2=0;k2+k1<len[i] && k2<len[j];k2++)
                                        {
                                                if (ss[i][k1+k2]!=ss[j][k2])
                                                {
                                                        flag=false;
                                                        break;
                                                }
                                        }
                                        if (flag)
                                        {
                                                dis[i][j]=max(0,-(len[i]-k1)+len[j]);
                                                break;
                                        }
                                }
                        }
                }
                memset(dp,INF,sizeof(dp));
                for (i=0;i<n;i++)
                        dp[i][1<<i]=len[i];
                int ii;
                for (ii=0;ii<n;ii++)
                {
                        for (k=0;k<n;k++)
                        {
                                for (j=0;j<(1<<n);j++)
                                {
                                        if (__builtin_popcount(j)!=ii)continue;
                                        for (i=0;i<n;i++)
                                        {
                                                if (dp[i][j]==INF)continue;
                                                if ((j&(1<<k))==0)
                                                {
                                                        if (dp[k][j|(1<<k)]>dp[i][j]+dis[i][k])
                                                        {
                                                                dp[k][j|(1<<k)]=dp[i][j]+dis[i][k];
                                                                rec[k][j|(1<<k)][0]=i;
                                                                rec[k][j|(1<<k)][1]=j;
                                                        }
                                                }
                                        }
                                }
                        }
                }
                int ans=INF;
                for (i=0;i<n;i++)
                        if (ans>dp[i][(1<<n)-1])
                        {
                                ans=dp[i][(1<<n)-1];
                                x=i;
                                y=(1<<n)-1;
                        }
                vector<int> vec;
                int xx,yy;
                for (i=0;i<n;i++)
                {
                        vec.push_back(x);
                        xx=x;yy=y;
                        x=rec[xx][yy][0];
                        y=rec[xx][yy][1];
                }
                for (int i=0;i<vec.size()/2;i++)
                        swap(vec[i],vec[vec.size()-1-i]);
                strcat(res,ss[vec[0]]);
                for (i=1;i<vec.size();i++)
                {
                        strcat(res,ss[vec[i]]+len[vec[i]]-dis[vec[i-1]][vec[i]]);
                }
                ::res=res;
                ::bstans=ans;
        }
}
int cst[20][20];
int len[20];
bool bad[20];
string curs;
int cnt;
int n;
bool cmp_pair(pair<char*,int> p1,pair<char*,int> p2)
{
        return strcmp(p1.first,p2.first)<0;
}
int mncst[22];
int dfs(int now,int status,int tdis,int cnt)
{
        if (tdis>bstans)return 0;
        if (curs>res)return 0;
        int t=0,ret=1;
        for (int i=0;i<n;i++)
        {
                if (!(status&(1<<i)))
                {
                        t+=mncst[i];
                }
        }
        if (t+tdis>bstans)
                return 0;
        if (status==(1<<n)-1)
        {
                if (bstans>tdis)
                {
                        assert(false);
                        res=curs;
                        bstans=tdis;
                }else
                {
                        res=min(res,string(curs));
                }
                return 1;
        }
        pair<char *,int> seq[13];
        int tots=0;
        for (int i=0;i<n;i++)
                if (!(status&(1<<i)))
                        seq[tots++]=make_pair(str[i] + len[i]-cst[now][i],i);
        sort(seq,seq+tots,cmp_pair);
        for (int i=0;i<tots;i++)
        {
                curs+=str[seq[i].second]+(len[seq[i].second]-cst[now][seq[i].second]);
                t=dfs(seq[i].second,status|(1<<seq[i].second),tdis+cst[now][seq[i].second],cnt*2/tots);
                cnt-=t;
                ret+=t;
                curs=curs.substr(0,tdis);
        }
        return ret;
}

int main()
{
        int x,y,z;
        scanf("%d",&n);
        for (int i=0;i<n;i++)
        {
                scanf("%s",str[i]);
                len[i]=strlen(str[i]);
        }
        task1::main(n);
        for (int i=0;i<n;i++)
        {
                if (bad[i])continue;
                for (int j=0;j<n;j++)
                {
                        if (i==j)continue;
                        for (int k=0;k<len[i];k++)
                        {
                                bool flag2=false;
                                for (int k2=0;k+k2<len[i];k2++)
                                {
                                        if (str[i][k2+k]!=str[j][k2])
                                        {
                                                break;
                                        }
                                        if (k2==len[j]-1)
                                        {
                                                flag2=true;
                                                break;
                                        }
                                }
                                if (flag2)
                                        bad[j]=true;
                        }
                }
        }
        x=0;
        for (int i=0;i<n;i++)
        {
                if (!bad[i])
                        strcpy(str[x++],str[i]);
        }
        n=x;
        char tmp[55];
        for (int i=0;i<n;i++)
                for (int j=i;j<n;j++)
                        if (string(str[i])>string(str[j]))
                        {
                                strcpy(tmp,str[i]);
                                strcpy(str[i],str[j]);
                                strcpy(str[j],tmp);
                        }
        for (int i=0;i<n;i++)
                len[i]=strlen(str[i]);
        for (int i=0;i<n;i++)
        {
                for (int j=0;j<n;j++)
                {
                        if (i==j)continue;
                        for (int k=0;k<=len[i];k++)
                        {
                                bool flag=true;
                                for (int k2=0;k2+k<len[i];k2++)
                                {
                                        if (str[i][k2+k]!=str[j][k2])
                                        {
                                                flag=false;
                                                break;
                                        }
                                }
                                if (flag)
                                {
                                        cst[i][j]=len[j]-(len[i]-k);
                                        break;
                                }
                        }
                }
        }
        for (int i=0;i<n;i++)
        {
                int x=INF;
                for (int j=0;j<n;j++)
                {
                        if (i==j)continue;
                        x=min(x,cst[j][i]);
                }
                mncst[i]=x;
        }
        for (int i=0;i<n;i++)
        {
                curs=str[i];
                dfs(i,1<<i,len[i],100000000);
        }
        cout<<res<<endl;
}
```

---

## 作者：cyffff (赞：5)

[$\text{Link}$](https://www.luogu.com.cn/problem/P2322)
## 题意
给出 $n$ 个互不包含的字符串 $a_{1,2,...,n}$，要求你求出一个字符串 $S$，使得 $\forall i\in[1,n],a_i\in S$，求 $\min|S|$。

$|a_i|\le50,1\le n\le 12$.
## 思路
首先我们看到有 $n$ 个字符串，感觉 $\text{KMP}$ 不怎么好做，于是我们考虑 $\text{ACAM}$。

然后这个 $n\le 12$ 非常奇怪，于是考虑状压 $\text{dp}$。

我们给每个节点赋值 $state_i$，若在 $\text{Trie}$ 上 $i$ 串以 $j$ 节点结尾则 $state_j\gets state_j\text{ or }2^{i-1}$，在建出 $\text{Fail}$ 树后，将 $state$ 再 $\text{or}$ 上当前节点的所有后缀。

然后我们从根节点开始 $\text{BFS}$，当按照字典序遍历到一个节点时，将当前状态 $\text{or}$ 上节点的 $statu$，若取到全局则将路径上的字符输出即可。

时间复杂度 $O(2^n\sum|a_i|)$。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
namespace IO{//by cyffff
	
}
const int N=600+10,C=(1<<12)+1,S=N*C;
#define Tr ACAM.ch
int n,ans[S],pre[S],state[N],all;
char str[N];
bool vis[N][C];
struct node{
	int pos,state;
	node(int x=0,int y=0){pos=x,state=y;};
};
queue<node>q;
struct AC_AutoMaton{
	int fail[N];
	int ch[N][26],cnt=0;
	inline void insert(char *s,int n,int x){
		int cur=0;
		for(int i=1;i<=n;i++){
			int x=s[i]-'A';
			if(!ch[cur][x]) ch[cur][x]=++cnt;
			cur=ch[cur][x];
		}
		state[cur]|=1<<x-1;
	}
	inline void getfail(){
		queue<int>q;
		for(int i=0;i<26;i++){
			if(ch[0][i]) q.push(ch[0][i]);
		}
		while(!q.empty()){
			int cur=q.front();
			q.pop();
			for(int i=0;i<26;i++){
				if(!ch[cur][i]){
					ch[cur][i]=ch[fail[cur]][i];
				}else{
					int v=fail[cur];
					fail[ch[cur][i]]=ch[v][i];
					state[ch[cur][i]]|=state[ch[v][i]];
					q.push(ch[cur][i]);
				}
			}
		}
	}
}ACAM;
int main(){
	n=read();
	all=(1<<n)-1;
	for(int i=1;i<=n;i++){
		readstr(str);
		ACAM.insert(str,strlen(str+1),i);
	}
	ACAM.getfail();
	q.push({0,0});
	vis[0][0]=1;
	int cnt=0,now=0;
	while(!q.empty()){
		node cur=q.front();
		q.pop();
		if(cur.state==all){
			stack<char>st;
			while(now){
				st.push(ans[now]+'A');
				now=pre[now];
			}
			while(!st.empty()) putc(st.top()),st.pop();
			return flush(),0;
		}
		for(int i=0;i<26;i++){
			int x=Tr[cur.pos][i],sta=cur.state;
			if(!vis[x][sta|state[x]]){
				vis[x][sta|state[x]]=1;
				q.push({x,sta|state[x]});
				pre[++cnt]=now;
				ans[cnt]=i;
			}
		}
		now++;
	}
}
```


---

## 作者：CherryPockyOvO (赞：3)

做法 ：状压$DP$ + $KMP$

先讲一下我做这题的原来思路

string类型的$DP$

$f_i$ 表示在字符串被选择的情况为 $i$ 时的母串 $(以长度第一关键字,字典序为第二关键字)$

显而易见的转移$f_i = f_j $ + 原子串 $k$ 与 $f_j$ 非重叠部分长度 ($i$ ^ $k$ = $j$)

(若$k$被$f_j$完全包含,则重叠部分为$0$)

用$KMP$将 $k$ 串与 $f_j$ 匹配,取第一次匹配到的,具体实现细节跳过，之后看代码。

满怀欣喜的交上去一发,咕咕咕 $80$。

自己用代码造了数据猛地发现,这样$DP$会导致原本某一状态局部最优，但是在后期更新会把**不如原来的且与其长度相同但字典序大**而被舍去的，**导致整体不优**。(不得不说Luogu数据有点水)。

想了一会,我们发现可以在原来 $DP$ 上加一个维度, $f_{ij}$ 表示状态为 $i$ ,且最后一次合并上去的字串为 $j$ 时的母串。

这样可以保证每一种情况都被考虑到了(请读者自己感性理解一下)

最后的答案会在 $f[(1 << n) - 1][i](i\in[1,n])$ 中取到，直接扫描更新。

话不多说

上代码

```cpp
#include<bits/stdc++.h>
#define debug(x) cerr << #x << " = " << x <<endl;
#define rep(i, a, b) for(int i = (a); i <= (b); ++ i)
using namespace std;
template<typename Tp> void Cmax(Tp &x, Tp y) { x = max(x, y); }
template<typename Tp> void Csum(Tp &x, Tp y) { x = x + y; }
template<typename Tp>
void read(Tp &x){
	x = 0; int f = 1;
	char ch = getchar();
	while(!isdigit(ch)){ if(ch == '-') f = -1; ch = getchar(); }
	while(isdigit(ch)){ x = x * 10 + ch - 48; ch = getchar(); }
	x = x * f;
}
typedef long long LL;
typedef double doub;
const int N = (1 << 13) + 40;
char s[20][100];
string g[N][20];
int KMP[1000], n;
string merge(string S, int pos){
	int len = strlen(s[pos] + 1);
	int j = 0, r = S.size();
	for(int i = 2; i <= len; ++i){
		while(j && s[pos][j + 1] != s[pos][i]) j = KMP[j];
		if(s[pos][j + 1] == s[pos][i]) ++j;
		KMP[i] = j;
	}
	j = 0;
	for(unsigned int i = 0; i < S.size(); ++i){
		while(j && s[pos][j + 1] != S[i])
			j = KMP[j];
		if(s[pos][j + 1] == S[i]) ++j;
		if(j == len){
			r = i; //这里是用来判断是否被完全包含 
			break;
		}
	}
	int f = S.size() - j; //想像一下，如果不被完全包含，那这个S串的部分后缀肯定与字串部分前缀有重合 
	if((unsigned int)r >= S.size()) //如果不被完全包含就要往后暴力更新 
	for(int i = 1; i <= len; ++i){
		if((unsigned int)i + f - 1  >= S.size()) S += 'a'; //这里是将DP里面的串和某一字串合并的操作 
		S[i + f - 1] = s[pos][i];
	}
	return S;
}
string ans;
signed main(){
	read(n);
	rep(i, 1, n)
		scanf("%s", s[i] + 1);
	for(int i = 1; i <= n; ++i){
		string r = "";
		int si = strlen(s[i] + 1);
		for(int j = 1; j <= si; ++j)
			r += s[i][j];
		g[(1 << (i - 1))][i] = r;
	}
	rep(i, 1, (1 << n) - 1)
		rep(j, 1, n)
			if(i & (1 << (j - 1))){
				rep(k, 1, n){
					if(k == j) continue; //已经合并过自己,不能合并 
					int sta = i ^ (1 <<(k - 1));
					if((i & (1 << (k - 1)))){
						string p = merge(g[sta][j], k); //合并 
						if(g[i][k].size() == 0) g[i][k] = p;//下面是更新DP 
						else{
							if(g[i][k].size() > p.size())
								g[i][k] = p;
							else
								if(g[i][k].size() == p.size() && g[i][k] > p)
									g[i][k] = p;
						}
					}
				}
			}
	int tt = (1 << n) - 1;
	for(int i = 1; i <= n; ++i){ //更新答案 
		if(ans.size() == 0) ans = g[tt][i];
		else{
			if(ans.size() > g[tt][i].size())
				ans = g[tt][i];
			else
				if(ans.size() == g[tt][i].size() && g[tt][i] < ans)
				ans = g[tt][i];
		}
	}
	cout << ans <<endl;
	return 0;
}
```
完结撒花



---

## 作者：Celtic (赞：2)

题意：给出$n$个字符串，求一个最短的串使得所有字符串都是这个串的子串。

先把字符串建出$trie$图，问题等价于求一条最小的链，使得这个连经过每个串的结尾。链上的字符即为所求字符串。
    所以我们$bfs$，因为$n\leq 12$所以判断到没到过这个串的结尾可以用二进制，$0$表示没有到过，$1$表示到过。设置到结尾时用按位或$\,|\,$运算。
    最后答案就是第一次状态每一位都为$1$所记录的字符串。

代码
```cpp
#include<bits/stdc++.h>
#define eps 1e-7
#define re register
#define N 3001001
#define MAX 5001
#define inf 1e18
using namespace std;
typedef int ll;
typedef double db;
inline void read(re ll& ret)
{
	ret=0;re ll pd=0;re char c=getchar();
	while(!isdigit(c)){pd|=c=='-';c=getchar();}
	while(isdigit(c)){ret=(ret<<1)+(ret<<3)+(c^48);c=getchar();}
	ret=pd?-ret:ret;
}
ll n,trie[601][26],tot,f[MAX],nxt[MAX];
char s[MAX];
inline void insert(re ll pos)
{
	re ll p=0,len=strlen(s+1);
	for(re int i=1;i<=len;i++)
	{
		re ll c=s[i]-'A';
		if(!trie[p][c])
			trie[p][c]=++tot;
		p=trie[p][c];
	}
	f[p]|=(1<<pos);
}
ll b[MAX],sum;
inline void bfs()
{
	queue<ll>q;
	for(re int i=0;i<26;i++)
		if(trie[0][i])
			q.push(trie[0][i]);
	while(!q.empty())
	{
		re ll p=q.front();
		b[++sum]=p;
		q.pop();
		for(re int i=0;i<26;i++)
		{
			if(!trie[p][i])
				trie[p][i]=trie[nxt[p]][i];
			else
			{
				nxt[trie[p][i]]=trie[nxt[p]][i];
				q.push(trie[p][i]);
			}
		}
	}
}

struct node
{
	ll p,state,fa,data;
	char c;
}ans[1350000];
queue<node>q;
bool vis[601][MAX];
ll top;
int main()
{
	read(n);
	for(re int i=1;i<=n;i++)
	{
		scanf("%s",s+1);
		insert(i);
	}
	bfs();
	for(re int i=sum;i;i--)
		f[i]|=f[nxt[i]];
	re node qwq;
	qwq.p=0;
	qwq.state=f[0];
	qwq.fa=0;
	qwq.c=0;
	qwq.data=++top;
	ans[top]=qwq;
	q.push(qwq);
	while(!q.empty())
	{
	//	if(top>1000000)
	//		cout<<top<<endl;
		qwq=q.front();
		q.pop();
/*		re node tt=qwq;
		re ll cnt=0;
		while(qwq.fa)
			{
				s[++cnt]=qwq.c;
				qwq=ans[qwq.fa];
			}
			for(re int i=cnt;i;i--)
				putchar(s[i]);
			putchar('\n');
		qwq=tt;*/
	//	cout<<qwq.p<<" "<<qwq.data<<" "<<qwq.state<<" "<<qwq.fa<<endl;
		if(qwq.state+2==(1<<n+1))
		{
			re ll cnt=0;
			while(qwq.fa)
			{
				s[++cnt]=qwq.c;
				qwq=ans[qwq.fa];
			}
			for(re int i=cnt;i;i--)
				putchar(s[i]);
			putchar('\n');
			break;
		}
		re ll tmp=qwq.p;
		re node qaq;
		for(re int i=0;i<26;i++)
			if(trie[qwq.p][i])
			{
				qaq.p=trie[qwq.p][i];
				qaq.state=(qwq.state|f[qaq.p]);
				if(vis[qaq.p][qaq.state])
					continue;
				qaq.c=char(i+'A');
	//			cout<<qaq.c<<endl;
				qaq.fa=qwq.data;
				qaq.data=++top;
				ans[top]=qaq;
		//		cout<<qaq.p<<" "<<qaq.data<<" "<<qaq.state<<" "<<qaq.fa<<endl;
				vis[qaq.p][qaq.state]=true;
				q.push(qaq);
			}
	}
    exit(0);
}
```


---

## 作者：_lcy_ (赞：1)

这个题为什么要用AC自动机呢（wtcl  
其实这个题只需要预处理+DP就可以解决  
首先，我们算出来那些字符串是被包含了，被包含的都不再需要考虑了  
```cpp
for(int j=0;j<N;j++){
	bool flag1=true;
	for(int i=0;i<N;i++){
		if(len[j]>len[i] || (len[i]==len[j] && i<j)) continue;
		if(i==j) continue;
		if(strstr(str[i],str[j])!=NULL){
			flag1=false;
			break;
		}
	}
	if(flag1) useful[tot++]=j;
}
```
然后，我们计算出每两个字符串重叠了多少 
```
for(int i=0;i<tot;i++){//这时只需要在有用的里面枚举就可以了
	for(int j=0;j<tot;j++){
		if(i==j) continue;
		for(int l=min(len[useful[i]],len[useful[j]]);l>=0;l--){
			bool flag=true;
			for(int pos2=0;pos2<l;pos2++){
				int pos1=len[useful[i]]-l+pos2;
				if(str[useful[i]][pos1]!=str[useful[j]][pos2]){
					flag=false;
					break;
				}
			}
			if(flag){
				match[i][j]=l;
				break;
			}
		}
	}
}
```
最后我们跑DP  
如果这道题直接求最短的字符串的话相比大家都会做  
令 $f[i][j]$ 表示已经放了 $i$ 这些字符串，最后一个放 $j$ 号字符串时的最短长度  
初值：$f[i][j]=\infty$，$f[1<<(i-1)][i]=0$  
转移：$f[i|(1<<(k-1))][k]=min(f[i|(1<<(k-1))][k],f[i][j]+match[j][k]$  
但是这个题目要求最小字典序，怎么办呢  
其实很简单，再开一个数组看最短长度对应的字典序最小的字符串就好了  
令 $g[i][j]$ 表示已经放了 $i$ 这些字符串，最后一个放 $j$ 号字符串时的最短长度对应的字典序最小的字符串
然后在当两个相等的时候比较字典序就好了

AC代码
```cpp
/***************************************************************************
* File Name: LG2322.cpp
* Author: lcy
* Created Time: 2020年05月27日 星期三 17时34分41秒
***************************************************************************/

#include<bits/stdc++.h>
using namespace std;

const int MAX_N=12,MAX_LEN=52;
int N;
char str[MAX_N][MAX_LEN];
int match[MAX_N][MAX_N];
int len[MAX_N],useful[MAX_N],tot;
void init(){
	for(int j=0;j<N;j++){
		bool flag1=true;
		for(int i=0;i<N;i++){
			if(len[j]>len[i] || (len[i]==len[j] && i<j)) continue;
			if(i==j) continue;
			if(strstr(str[i],str[j])!=NULL){
				flag1=false;
				break;
			}
		}
		if(flag1) useful[tot++]=j;
	}
	for(int i=0;i<tot;i++){
		for(int j=0;j<tot;j++){
			if(i==j) continue;
			for(int l=min(len[useful[i]],len[useful[j]]);l>=0;l--){
				bool flag=true;
				for(int pos2=0;pos2<l;pos2++){
					int pos1=len[useful[i]]-l+pos2;
					if(str[useful[i]][pos1]!=str[useful[j]][pos2]){
						flag=false;
						break;
					}
				}
				if(flag){
					match[i][j]=l;
					break;
				}
			}
		}
	}
}

int f[1<<MAX_N][MAX_N];
char g[1<<MAX_N][MAX_N][MAX_LEN*MAX_N];
char ans[MAX_LEN*MAX_N];
char tmp[MAX_LEN*MAX_N];

int main(){
	scanf("%d",&N);
	for(int i=0;i<N;i++) scanf("%s",str[i]),len[i]=strlen(str[i]);
	init();
	memset(f,0x3f,sizeof(f));
	for(int i=0;i<tot;i++){
		f[1<<i][i]=len[useful[i]];
		memcpy(g[1<<i][i],str[useful[i]],len[useful[i]]);
	}
	for(int s=0;s<(1<<tot);s++){
		for(int i=0;i<tot;i++){
			if(!(s&(1<<i))) continue;
			for(int j=0;j<tot;j++){
				if(s&(1<<j)) continue;
				memcpy(tmp,g[s][i],f[s][i]);
				for(int k=match[i][j];k<len[useful[j]];k++) tmp[f[s][i]+k-match[i][j]]=str[useful[j]][k];
				if(f[s|(1<<j)][j]>f[s][i]+len[useful[j]]-match[i][j]){
					f[s|(1<<j)][j]=f[s][i]+len[useful[j]]-match[i][j];
					memcpy(g[s|(1<<j)][j],tmp,f[s|(1<<j)][j]);
				}
				else if(f[s|(1<<j)][j]==f[s][i]+len[useful[j]]-match[i][j]){
					for(int k=0;k<f[s|(1<<j)][j];k++) {
						if(tmp[k]<g[s|(1<<j)][j][k]){
							memcpy(g[s|(1<<j)][j],tmp,f[s|(1<<j)][j]);
							break;
						}
						else if(tmp[k]>g[s|(1<<j)][j][k]){
							break;
						}
					}
				}
			}
		}
	}
	int ans_length=0x3f3f3f3f;
	for(int i=0;i<tot;i++){
		if(f[(1<<tot)-1][i]<ans_length){
			ans_length=f[(1<<tot)-1][i];
			memcpy(ans,g[(1<<tot)-1][i],ans_length);
		}
		else if(f[(1<<tot)-1][i]==ans_length){
			for(int j=0;j<ans_length;j++) {
				if(ans[j]<g[(1<<tot)-1][i][j]){
					break;
				}
				else if(ans[j]>g[(1<<tot)-1][i][j]){
					memcpy(ans,g[(1<<tot)-1][i],ans_length);
					break;
				}
			}
		}
	}
	if(ans_length>0x3f3f0000){
		puts("");
		return 0;
	}
	ans[ans_length]='\0';
	printf("%s\n",ans);
    return 0;	
}

```


---

## 作者：弦巻こころ (赞：0)

本来想打$dfs$的，但状态实在不好储存就只好打$bfs$了。

大意：这道题与[P2444 [POI2000]病毒](https://www.luogu.org/problem/P2444)正好相反，是让你求一个最小的文本串使其包含所有的模式串

思路：先处理出$trie$树与$fail$指针，因为是求一个包含所有模式串的文本串，但在判断是不好判断结束状态，就设一个$state$数组，并将每个串尾的值设为1<<(Num-1）(此处要用或因为会有重复)并在搜的时候用$st$或上$state[now]$ 当$st=(1<<n)-1$的时候就找出答案了。

但输出还是挺麻烦的，我们就设一个$fa$和$ans$.$fa$就是记录这个字符对应的上个字符（相当于建一颗答案树） $ans$记录答案，输出时直接从叶节点通过跳$fa$输出就$ok$了

需要注意的点如下
#### 1.记得记搜避免出现重复情况
#### 2.记得处理重复字符串的情况
#### 3.记得输出时要倒序输出

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define mn 605
int fail[mn],trie[mn][26],state[mn],ans[6000005],fa[6000005];
bool vis[mn][10005];
int tot=0;
int n,maxn;
char s[mn];
void make_trie(char s[605],int Num)
{
	int now=0,len=strlen(s);
	for(int i=0;i<len;i++)
	{
		int next=s[i]-'A';
		if(!trie[now][next])
		{
			trie[now][next]=++tot;
		}
		now=trie[now][next];
	}
	state[now]|=(1<<(Num-1));
   //这里用或避免被覆盖
}
void getfail()
{
	queue<int> q;
	for(int i=0;i<26;i++)
	{
		if(trie[0][i])
		{
			fail[trie[0][i]]=0;
			q.push(trie[0][i]);
		}
	}
	int now=0;
	while(!q.empty())
	{
		now=q.front();
		q.pop();
		for(int i=0;i<26;i++)
		{
			if(trie[now][i])
			{
				fail[trie[now][i]]=trie[fail[now]][i];
				state[trie[now][i]]|=state[trie[fail[now]][i]];
           //这里也要用或，同样是避免覆盖或多加
				q.push(trie[now][i]); 
				
			}else
			{
				trie[now][i]=trie[fail[now]][i];
			}
		}
	}
}
void dfs()
{
	char s[2005];//储存最终答案的数组
	queue<int> q1,q2;//q1记录now q2记录state。
	q1.push(0),q2.push(0);
	int t=0,cnt=0,qaq=0;
	while(!q1.empty())
	{
		int now=q1.front(),st=q2.front();
		q1.pop(),q2.pop();
		if(st==(1<<n)-1)//如果当前包含了所有模式串 
		{
			while(t)//因为是答案树，所以一直跳到根节点就是答案
			{
				s[++cnt]=ans[t];
				t=fa[t];//找到答案串并赋值 
			}
			for(int i=cnt;i>=1;i--)
			{
				printf("%c",s[i]+'A');//依次输出 
			}
			exit(0);//强制结束
		}
		for(int i=0;i<26;i++)
		{
			if(!vis[trie[now][i]][st|state[trie[now][i]]])
			{
				vis[trie[now][i]][st|state[trie[now][i]]]=1;//防止重复找
				fa[++qaq]=t;
				ans[qaq]=i;
				q1.push(trie[now][i]);
				q2.push(st|state[trie[now][i]]);
			}
		}
		++t;
	} 
}
int main()
{
//	freopen("1.in","r",stdin);
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%s",s);
		make_trie(s,i);
	}
	getfail();
	bfs();
	return 0;
}
```


---

## 作者：nihanchu (赞：0)

其实我写麻烦了。。。


设dp[i][j]表示在i这个状态下，我们连接这些字符串且以第j个字符串为结尾所形成的字符串最短为少，g[i][j]储存这个状态下的字符串是什么。bin[i]=2^i；


那么转移方程就是dp[i|bin[k]][j]=min(dp[i|bin[k]][j],dp[i][j]+(把第k个字符串连到第j个字符串后面所会增加的长度));（j是我们枚举的i状态中已连接的字符串，k是i状态中还未连接的字符串）

很明显，那些连接任意两个字符串所要增加的长度可以事先处理出来。g数组的处理也差不多，只不过加的是把第k个字符串连到第j个字符串后面所会增加的字符串（除去公共部分）。


接下来说一些小细节：


1.首先，如果一个字符串是其他串的子串的话，就直接把它除去，我在程序中判断子串是用kmp的），为了练习一下，其实直接枚举就好了。


2.其次，我们要怎么判断两个字串相连的公共部分最长是多少呢，其实是O（n）扫一遍，这个程序里面详细写。


唔，其他细节程序里写。








```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<string>
#define maxx 100000000
using namespace std;
int ans,len[30][30],dp[6009][30],n,next[30],bin[30];
string a[30],b[30],g[6009][30],len2[30][30];
bool check(string&s1,string&s2)
//检查s1是不是s2的子串，我用了kmp，还是建议枚举。
{
  int l1=s1.size(),l2=s2.size();
  if (l1>l2) return false;
  int now=-1; next[0]=-1;
  for (int i=1;i<l1;i++)
  {
      while ((now!=-1)&&(s1[now+1]!=s1[i])) now=next[now];
      if (s1[now+1]==s1[i]) now++;
      next[i]=now;
  }
  now=-1;
  for (int i=0;i<l2;i++)
  {
      while ((now!=-1)&&(s2[i]!=s1[now+1])) now=next[now];
      if (s2[i]==s1[now+1]) now++;
      if (now==l1-1) return true;
  }
  return false;
}
void calc(int x,int y)
//计算第x和第y的子串，连接他们会增加的长度，和增加的字符串
{
  string s1=a[x],s2=a[y];
  int tot=0,l1=s1.size(),l2=s2.size();
  int h1=l1-1,h2=0;
  string p1,p2;
  while ((h1>=0)&&(h2<l2))
  {
      p1=s1[h1--]+p1; p2=p2+s2[h2++];
      if (p1==p2) tot=max(tot,h2);
  }
  len[x][y]=l2-tot;
  for (int i=tot;i<l2;i++) len2[x][y]=len2[x][y]+s2[i];
//这个是如果连接着两个字符串的话，在第X个字符串后面会增加的字符串是多少
}
int main()
{
  scanf("%d",&n);
  char s[100];
  for (int i=1;i<=n;i++) 
  {
    scanf("%s",s);
    string t;
    for (int j=0;j<strlen(s);j++) t=t+s[j];
    b[i]=t; 
  }
  int cnt=0;
  for (int i=1;i<=n;i++)
  {
   bool fg=false;
   for (int j=1;j<=n;j++)
   if ((i!=j)&&(check(b[i],b[j]))) 
   {
        fg=true;
        break;
   }
   if (!fg) a[++cnt]=b[i];
  }
//删去被别人包含的字符串
  n=cnt;
  if (n==0) cout<<b[1]<<endl;//如果字符串全部相同的话，就不用计算了
  else
  {
   for (int i=1;i<=n;i++)
   for (int j=1;j<=n;j++)
   if (i!=j) calc(i,j);
//计算两个字符串连接后会增加的部分
   bin[0]=1;
   for (int i=1;i<=n;i++) bin[i]=bin[i-1]*2;
   for (int i=0;i<bin[n];i++)
   for (int j=1;j<=n;j++) dp[i][j]=maxx;
   for (int i=1;i<=n;i++) 
   {
    dp[bin[i-1]][i]=a[i].size();
    g[bin[i-1]][i]=a[i];
   } 
//dp
   for (int i=0;i<bin[n];i++)
   for (int j=1;j<=n;j++)
   if ((i&bin[j-1])&&(dp[i][j]!=maxx))
   for (int k=1;k<=n;k++)
   if (!(i&bin[k-1]))
   {
//以下的if语句是为了字典序
      if (dp[i|bin[k-1]][k]==dp[i][j]+len[j][k])
    g[i|bin[k-1]][k]=min(g[i|bin[k-1]][k],g[i][j]+len2[j][k]);
    if (dp[i|bin[k-1]][k]>dp[i][j]+len[j][k])
    {
      dp[i|bin[k-1]][k]=dp[i][j]+len[j][k];
      g[i|bin[k-1]][k]=g[i][j]+len2[j][k];
    }
   }
   ans=maxx; string ans2;
//统计答案
   for (int i=1;i<=n;i++)
   if (dp[bin[n]-1][i]<ans)
   {
      ans=dp[bin[n]-1][i];
      ans2=g[bin[n]-1][i];
   }
   else if (dp[bin[n]-1][i]==ans)
   ans2=min(ans2,g[bin[n]-1][i]);
   cout<<ans2<<endl;
  }
  return 0;
}

```

---


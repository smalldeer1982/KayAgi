# [SCOI2005] 骑士精神

## 题目描述

![](https://cdn.luogu.com.cn/upload/pic/1389.png)


## 说明/提示

![](https://cdn.luogu.com.cn/upload/pic/1390.png)


## 样例 #1

### 输入

```
2
10110
01*11
10111
01001
00000
01011
110*1
01110
01010
00100
```

### 输出

```
7
-1
```

# 题解

## 作者：ZAGER (赞：207)

## 题解

### 题意：给你一个初始棋盘，要求用最少的步数移动马达到如上图的目标状态（要求棋盘中的马只能走“日”）。

传送门：[透彻](https://www.cnblogs.com/ZAGER/p/9768170.html)

咱们先抛开$IDA^*$，先如何优化爆搜；

这里的马和象棋里的马走法相同，但题目中要求让马走，但是要是马的话，搜索分支比较多，所以我们要考虑让空格走（很显然吧）。

### 下面步入正题：

$IDA^*$就是带有迭代加深和估价函数优化的搜索。

可能某些人对以上两个名词很陌生，下面一些前置知识可能会带你透彻一下。

### 前置知识1：迭代加深

#### 定义：

每次限定一个$maxdep$最大深度，使搜索树的深度不超过$maxdep$。

```cpp
	for(R int maxdep=1;maxdep<=题目中给的最大步数;maxdep++){
		dfs(0,maxdep);//0为出入函数中当前步数，maxdep为传入的最大深度。
		if(success)break;//如果搜索成功则会在dfs函数中将success赋值为1。
	}
```

#### 使用范围:

1.在有一定的限制条件时使用（例如本题中“如果能在$15$步以内（包括$15$步）到达目标状态，则输出步数，否则输出$-1$。“）。

2.题目中说输出所以解中的任何一组解。

#### 为什么能够降低时间复杂度：

我们可能会在一个没有解（或解很深的地方无限递归然而题目中要求输出任何的一组解），所以我们限制一个深度，让它去遍历更多的分支，去更广泛地求解，(其实和$BFS$有异曲同工之妙)。

### 前置知识2：估价函数

#### 定义：

$f(n)=g(n)+h(n)$

其中$f(n)$是节点的估价函数，$g(n)$是现在的实际步数，$h(n)$是对未来步数的最完美估价（“完美”的意思是可能你现实不可能实现，但你还要拿最优的步数去把$h(n)$算出来，可能不太好口胡，可以参考下面的实例）。

#### 应用：

```cpp
    void dfs(int dep,int maxdep){
        if(evaluate()+dep>maxdep)return;
        //evaluate函数为对未来估价的函数，若未来估价加实际步数>迭代加深的深度则return。
        if(!evaluate){
            success=1;
            printf("%d\n",dep);
            return;
        }
        ......
    }
```

### 前置知识3：$A^*$和$IDA^*$的区别

$A^*$是用于对$BFS$的优化；

$IDA^*$是对结合迭代加深的$DFS$ 的优化。

本质上只是在$BFS$和$DFS$上加上了一个估价函数。

何时使用因题而定：

$A^*$（[[SCOI2007]k短路](https://www.luogu.org/problemnew/show/P4467)）;$IDA^*$（[[SCOI2005]骑士精神](https://www.luogu.org/problemnew/show/P2324)和[UVA11212 Editing a Book](https://www.luogu.org/problemnew/show/UVA11212)）。

前置知识毕！！！

现在就是要想一个比较好的估价函数（若估价函数不好的话，优化效率就并不高，例如若估价函数一直为0，那就是爆搜）。

我们可以想一下，每次空白格子和黑白棋子交换，最优的情况就是每次都把黑白棋子移动到目标格子。

那么你的估价函数就出来了：

```cpp
    const int goal[7][7]={
        {0,0,0,0,0,0},
        {0,1,1,1,1,1},
        {0,0,1,1,1,1},
        {0,0,0,2,1,1},
        {0,0,0,0,0,1},
        {0,0,0,0,0,0}
    };    
    inline int evaluate(){
        R int cnt=0;
        for(R int i=1;i<=5;i++)
            for(R int j=1;j<=5;j++)
                if(mp[i][j]!=goal[i][j])cnt++;
        return cnt;
    }
```

下面就是爆搜了：

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cctype>
#define ll long long
#define R register
using namespace std;
template<typename T>inline void read(T &a){
    char c=getchar();T x=0,f=1;
    while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}
    while(isdigit(c)){x=(x<<1)+(x<<3)+c-'0';c=getchar();}
    a=f*x;
}
int n,m,t,mp[7][7],stx,sty,success;
char ch;
const int dx[]={0,1,1,-1,-1,2,2,-2,-2};
const int dy[]={0,2,-2,2,-2,1,-1,1,-1};
const int goal[7][7]={
    {0,0,0,0,0,0},
    {0,1,1,1,1,1},
    {0,0,1,1,1,1},
    {0,0,0,2,1,1},
    {0,0,0,0,0,1},
    {0,0,0,0,0,0}
};
inline int evaluate(){
    R int cnt=0;
    for(R int i=1;i<=5;i++)
        for(R int j=1;j<=5;j++)
            if(mp[i][j]!=goal[i][j])cnt++;
    return cnt;
}
inline int safe(R int x,R int y){
    if(x<1||x>5||y<1||y>5)return 0;
    return 1;
}
inline void A_star(R int dep,R int x,R int y,R int maxdep){
    if(dep==maxdep){
        if(!evaluate())success=1;
        return;
    }
    for(R int i=1;i<=8;i++){
        R int xx=x+dx[i];
        R int yy=y+dy[i];
        if(!safe(xx,yy))continue;
        swap(mp[x][y],mp[xx][yy]);
        int eva=evaluate();
        if(eva+dep<=maxdep)
            A_star(dep+1,xx,yy,maxdep);
        swap(mp[x][y],mp[xx][yy]);//回溯
    }
}
int main(){
    read(t);
    while(t--){
        success=0;
        for(R int i=1;i<=5;i++){
            for(R int j=1;j<=5;j++){
                cin>>ch;
                if(ch=='*')mp[i][j]=2,stx=i,sty=j;//记录起点即为空白格子
                else mp[i][j]=ch-'0';
            }
        }
        if(!evaluate()){printf("0\n");continue;}
        for(R int maxdep=1;maxdep<=15;maxdep++){
            A_star(0,stx,sty,maxdep);
            if(success){printf("%d\n",maxdep);goto ZAGER;}
        }
        printf("-1\n");
        ZAGER:;
    }
    return 0;
}
```


---

## 作者：『　』 (赞：57)

本人现在以0ms稳居rank1，普通的迭代加深，加了常数优化，原来代码在每层都用一个5\*5的循环查有多少个不同，8ms；

显然，如果枚举骑士分布，状态巨多，且不好判断空格在哪，所以换个思路，不移骑士，移空格

迭代加深就是每次限制搜索深度，十分广搜

但是，仔细想想，只有四种情况：

1.原来骑士归位了，改完没归位

2.原来骑士没归位，改完归位了

3.原来空位没归位，改完归位了

4.原来空位归位了，改完没归位

```cpp
#include<iostream>
#include<cstdio>
#define f(i,a,b)  for(i=a;i<=b;++i)
using namespace std;
int a[6][6];
int b[6][6]={{},
            {0,1,1,1,1,1},
            {0,0,1,1,1,1},
            {0,0,0,-1,1,1},
            {0,0,0,0,0,1},
            {0,0,0,0,0,0}};//打个表方便之后判断；
int dx[8]={-2,-2,-1,1,-1,1,2,2};
int dy[8]={-1,1,2, 2,-2,-2,-1,1};//顺序很重要，等下可以知道；
int mxd;//maxdeep最大深度
int check(int k,int x,int y,int sum,int la)
{
 //   printf("%d\n",sum);
    if(k+sum>mxd)return 0;//如果超过限制，直接返回0
    if(sum==0)return 1;//全部归位，返回1
    int i,xx,yy,p;
    bool fl=0,fll=0;
    f(i,0,7)
    {
        if(i!=(7-la))//就是这里，7-la就是上一次移动的反方向，防止移回去导致死递归
        {
            xx=x+dx[i];yy=y+dy[i];
            p=sum;//sum是当前未归位数，用p存出来方便修改
            if(xx<=5&&xx>0&&yy<=5&&yy>0)
            {
                if(a[xx][yy]==b[xx][yy]&&a[xx][yy]!=b[x][y])++p;
                if(a[xx][yy]!=b[xx][yy]&&a[xx][yy]==b[x][y])--p;
                if(b[xx][yy]==-1)--p;
                if(b[x][y]==-1)++p;//四种情况判断
                a[xx][yy]^=a[x][y],a[x][y]^=a[xx][yy],a[xx][yy]^=a[x][y];
                fl=check(k+1,xx,yy,p,i);//不能直接返回check的值，只有1才返回；
                if(fl)return 1;
                a[xx][yy]^=a[x][y],a[x][y]^=a[xx][yy],a[xx][yy]^=a[x][y];
            }
        }
    }
    return 0;//都不行，返回0；
}
int main()
{
    int i,j,t;
    char k;
    scanf("%d",&t);
    while(t)
    {
        int mn=0,x,y;
        f(i,1,5)
        f(j,1,5)
        {
            cin>>k;
            if(k=='*')
            {
                a[i][j]=-1;
                x=i;y=j;
            }
            else a[i][j]=k-'0';
            if(a[i][j]!=b[i][j])mn++;//mn是深度最低的，有一个不同就加1，因为归位这个至少1次操作
        }
        bool fl=0;
       // printf("%d\n",mn);
        f(i,mn,16)
        {
            mxd=i;
            if(check(0,x,y,mn,-1))
            {
                printf("%d\n",i-1),fl=1;break;
            }
        }
        if(!fl)
        printf("-1\n");
        t--;
    }
    return 0;
}
```

---

## 作者：Luan_233 (赞：41)

## Solution

+ 额，当我看到大佬们都用的什么迭代加深啊，双向广搜啊，什么的，其实本题是一道非常好的A*入门题，蒟蒻我来简单介绍一下这题启发式搜索的做法。

+ 何为估价函数？
```
if(d+l>16) return ;
```
这一句话看起来很简单对吧。它的含义相信各位巨佬都讲过了，也就是已经移动的步数和完成最终状态最少需要移动的步数。也相信各位大神一眼就能看明白它的原理。判断它的方法十分简单粗暴，直接拿当前状态与最终状态比较一下就好了。至于为什么是16而不是15，这个是因为我把空位也计入了状态，而在最后一步时，我可以一次性恢复两个状态，也就是一个骑士归位，并且空格也移动到了中间。

+ 另外呢，也不算剪枝，只能算是一个小优化，在枚举方向时，我把互为相反数的两组数值放在一维数组的两端，就有
```
-2, -2, -1, -1, 1, 1, 2, 2
-1 , 1, -2,  2,-2, 2,-1, 1 
```
这样有什么用呢？在循环与递归时，可以简单地利用下标加和的数值进行判断，防止跳到一个地方再跳回去，减少枚举量。

+ 虽说这题只用到了上面提到的这两点，但估价函数已经是一个极强的优化了，能够剪掉大量冗余的状态，这也就是启发式搜索的灵魂所在。

### Code

```
#include<cstdio>
#include<iostream> 
#include<cstring>
#define INF 536870912
using namespace std;
char map[6][6];
char check[6][6]={
	'0','0','0','0','0','0',
	'0','1','1','1','1','1',
	'0','0','1','1','1','1',
	'0','0','0','*','1','1',
	'0','0','0','0','0','1',
	'0','0','0','0','0','0',
};
int xm[9]={0,-2,-2,-1,-1,1,1,2,2};
int ym[9]={0,-1,1,-2,2,-2,2,-1,1};
int ans;
inline void swap(char &p1,char &p2){
	char mid=p1; p1=p2; p2=mid;
}
inline int dif(){
	int ret=0;
	for(int i=1;i<=5;i++){
		for(int j=1;j<=5;j++){
			if(map[i][j]!=check[i][j]) ret++;
		}
	}
	return ret;
}
inline void dfs(int x,int y,int d,int f){
	int l=dif();
	if(d+l>16) return ;
	if(d>=ans) return ;
	if(l==0){
		ans=d; return ;
	}
	for(int i=1;i<=8;i++){
		if((x+xm[i]<1)||(x+xm[i]>5)) continue;
		if((y+ym[i]<1)||(y+ym[i]>5)) continue;
		if(f+i!=9){
			swap(map[y+ym[i]][x+xm[i]],map[y][x]);
			dfs(x+xm[i],y+ym[i],d+1,i);
			swap(map[y+ym[i]][x+xm[i]],map[y][x]);
		}
	}
}
inline void init(){
	int x,y;
	for(int i=1;i<=5;i++) cin>>map[i]+1;
	for(int i=1;i<=5;i++){
		for(int j=1;j<=5;j++){
			if(map[i][j]=='*') { x=j; y=i; }
		}
	}
	ans=25;
	dfs(x,y,0,0);
	printf("%d\n",ans==25?-1:ans);
}
int main()
{
	int t;
	scanf("%d",&t);
	while(t--) init();
	return 0;
}
```

---

## 作者：niiick (赞：20)

迭代加深的A*算法

所谓迭代加深就是每次**限制搜索深度**，
这样可以在整个搜索树深度很大而答案深度又很小的情况下大大提高效率

因为最大步数不超过15，
所以直接枚举1到15作为最大步数进行**迭代加深搜索**判断

在这里我们的**A*估价函数**设置为

**当前状态还有多少个位置与目标状态不对应**

若**当前步数+估价函数值>枚举的最大步数**
则直接返回

当然这只是基本思路，搜索还可以有很大优化

我们在搜索中再加入**最优性剪枝**，
显然当前枚举下一个状态时如果**回到上一个状态肯定不是最优**，
所以我们在枚举下一状态时加入对这种情况的判断

将状态数组对称排列会很方便进行这一操作
```
int nxtx[]={1,1,2,2,-2,-2,-1,-1};
int nxty[]={2,-2,1,-1,1,-1,2,-2};
```
********************************

```
#include<iostream>
#include<cstdio>
#include<vector>
#include<queue>
#include<algorithm>
#include<cstring>
using namespace std;

int read()
{
    int f=1,x=0;
    char ss=getchar();
    while(ss<'0'||ss>'9'){if(ss=='-')f=-1;ss=getchar();}
    while(ss>='0'&&ss<='9'){x=x*10+ss-'0';ss=getchar();}
    return f*x;
}

int n;
int ans[6][6]=
{{0,0,0,0,0,0},
 {0,1,1,1,1,1},
 {0,0,1,1,1,1},
 {0,0,0,2,1,1},
 {0,0,0,0,0,1},
 {0,0,0,0,0,0}};
int nxtx[]={1,1,2,2,-2,-2,-1,-1};
int nxty[]={2,-2,1,-1,1,-1,2,-2};
int a[10][10],k;
int judge;

int check()
{
    for(int i=1;i<=5;++i)
    for(int j=1;j<=5;++j)
    if(ans[i][j]!=a[i][j])return 0;
    return 1;
}

int test(int step)
{
    int cnt=0;
    for(int i=1;i<=5;++i)
    for(int j=1;j<=5;++j)
    if(ans[i][j]!=a[i][j]){ if(++cnt+step>k) return 0;}
    return 1;
}

void A_star(int step,int x,int y,int pre)//pre记录上一步怎么到当前状态
{
    if(step==k){ if(check())judge=1; return;}
    if(judge) return;
    for(int i=0;i<8;++i)
    {
        int nx=x+nxtx[i],ny=y+nxty[i];
        if(nx<1||nx>5||ny<1||ny>5||i+pre==7) continue;//加入了上述的最优性剪枝
        swap(a[x][y],a[nx][ny]);
        if(test(step)&&!judge) A_star(step+1,nx,ny,i);//A*估价再向下搜索
        swap(a[x][y],a[nx][ny]);
    }
}

int main()
{
    n=read();
    while(n--)
    {
        int x,y; judge=0;
        for(int i=1;i<=5;++i)
        {
            char ss[7]; scanf("%s",&ss);
            for(int j=0;j<5;++j)
            if(ss[j]=='*') a[i][j+1]=2,x=i,y=j+1;
            else a[i][j+1]=ss[j]-'0';
        }
        for(k=1;k<=15;++k)
        {
            A_star(0,x,y,-1);
            if(judge) { printf("%d\n",k); break;}
        }
        if(!judge)printf("-1\n");
    }
    return 0;
}
//niiick
```

---

## 作者：木木！ (赞：15)

看dalao都用的是`ID-DFS`、`IDA*`或者`A*`，这里贴一篇双向`ID-DFS`的题解。

蒟蒻首先用的是单向`ID-DFS`，然后毫无悬念地T飞，只拿了十分。然后发现样例的第一个部分（`7`）跑得飞快，第二个部分（`-1`）慢到我以为死循环了。试着输出ID-DFS的层级，发现`1-7`这几层几乎瞬间跑完，然后从`9`开始越来越慢，`14`的时候就已经要两秒了。

双向`ID-DFS`的理念和双向`BFS`差不多，都是通过双向搜索来减少搜索树的大小。双向`ID-DFS`就是两个方向交替`ID-DFS`，每个方向`8`层，末一层在`map`里记录一下，相遇时就得到了答案。

最后因为骚操作比较多，搓了一个小时，跑了2.5s多，然后我看着别人`1KB 500ms`的`IDA*`代码思考人生。

附AC代码：

```cpp
#include <map>
#include <cstdio>
using namespace std;

char gc()
{
	char c;
	while((c=getchar())!='0' && c!='1' && c!='*')
	{
		;
	}
	return c;
}

int gox[] = {1,2,-2,-1,-1,-2,2,1};
int goy[] = {2,1,1,2,-2,-1,-1,-2};

int csed[6][6] = {{},{0,1,1,1,1,1},{0,0,1,1,1,1},{0,0,0,0,1,1},{0,0,0,0,0,1},{0,0,0,0,0,0}};

map<int,int> edmmp;
map<int,int> bgmmp;

int bg[6][6];
int ed[6][6];

template<typename T> int bcode(T board) //骚操作，因为发现用不了int[][]和int**以及int(*)[6]，于是干脆弃疗
{
	int res = 0;
	for(int i=1; i<=5; ++i)
	{
		for(int j=1; j<=5; ++j)
		{
			res <<= 1;
			res += board[i][j];
		}
	}
	return res;
}

inline int lcode(int x,int y)
{
	return (x-1)*5+y-1;
}

template<typename T> bool cregis(int wx,int wy,T board,map<int,int>& cmmp,map<int,int>& rmmp)
{
	int chk = cmmp[bcode(board)];
	
	if(chk&(1<<lcode(wx,wy)))
	{
		return true;
	}
	
	int& x = rmmp[bcode(board)];
	
	if(x)
	{
		x |= 1<<lcode(wx,wy);
	}
	else
	{
		x = 1<<lcode(wx,wy);
	}
	
	return false;
}

template<typename T> bool id_dfs(int life,int wx,int wy,T board,map<int,int>& cmmp,map<int,int>& rmmp)
{
	if(!life)
	{
		return cregis(wx,wy,board,cmmp,rmmp);
	}
	for(int i=0; i<8; ++i)
	{
		int nxtwx = wx+gox[i];
		int nxtwy = wy+goy[i];
		
		if(nxtwx>0&&nxtwx<=5&&nxtwy>0&&nxtwy<=5)
		{	
			swap(board[wx][wy],board[nxtwx][nxtwy]);
			if(id_dfs(life-1,nxtwx,nxtwy,board,cmmp,rmmp)) return true;
			swap(board[wx][wy],board[nxtwx][nxtwy]);
		}
	}
	return false;
}

int main()
{
	int t;
	scanf("%d",&t);
	for(int kkk=1; kkk<=t; ++kkk)
	{
		bgmmp.clear(); //记得初始化
		edmmp.clear();
		for(int i=1; i<=5; ++i)
		{
			for(int j=1; j<=5; ++j)
			{
				ed[i][j] = csed[i][j];
			}
		}
		
		int bwx,bwy;
		for(int i=1; i<=5; ++i)
		{
			for(int j=1; j<=5; ++j)
			{
				bg[i][j] = gc();
				if(bg[i][j]=='*')
				{
					bwx = i;
					bwy = j;
					bg[i][j] = 0;
				}
				else
				{
					bg[i][j] ^= '0';
				}
			}
		}
		
		id_dfs(0,3,3,ed,bgmmp,edmmp);
		if(id_dfs(0,bwx,bwy,bg,edmmp,bgmmp)) //特判
		{
			printf("0\n");
			goto ed;
		}
		for(int i=1; i<=15; ++i)
		{
			if(i&1) //交替进行
			{
				if(id_dfs((i+1)>>1,3,3,ed,bgmmp,edmmp))
				{
					printf("%d\n",i);
					goto ed;
				}
			}
			else
			{
				if(id_dfs(i>>1,bwx,bwy,bg,edmmp,bgmmp))
				{
					printf("%d\n",i);
					goto ed;
				}
			}
		}
		
		printf("-1\n");
		
		ed:;
	}
}
```

---

## 作者：_J_C_ (赞：14)

具体怎么做楼上大佬们说的很清楚orz，不过本蒟蒻有一个小小的操作←←。。

本蒟蒻特别喜欢位运算，所以当我看到棋盘只有5\*5的时候，我马上写了个结构体：
```cpp
class state

{
public:
	int map, x, y;
};

```
其中map在二进制下是压缩后的棋盘，1表示黑骑士，0表示白骑士。x,y即空位置的坐标。

举个例子：
对于样例：
10110
01*11
10111
01001
00000

压缩到map里
1011001*11101110100100000

‘*’可以是0或1，因为我们的x，y已经指出它是空位置了，那么这个位置上的值是0还是1是无意义的。

这么压缩有什么用呢？emmm，方便比较，方便赋值，更重要的是它看上去很快OvO


当然了，还要有一个配套的宏。

```cpp
#define ITP(x, y) ((x) * 5 + (y))
```
这个宏用来将棋盘上的坐标(x,y)转换为map在二进制下的位数。



那么我们怎么判断当前状态now是否是最终状态呢?

now为当前状态，dest为预处理的最终状态
```cpp
if (now.x == dest.x && now.y == dest.y)//首先它们空位置要相等
{
	if(now.map == dest.map || (now.map ^ (1 << ITP(now.x, now.y))) == dest.map)//如果两个map直接相等，或者是在空位置取反后相等（因为空位置的0，1被认为是等效的），则状态是相等的
		return 0;//状态相等，估价函数返回0
}
```

基于类似的想法，我的估价函数整个也写的相当朴素(也许粗糙贴切）（当然也不快，开了O2还要500ms），不过AC还是没问题的。

```cpp
int need(state& now)
{
	if (now.x == dest.x && now.y == dest.y)
	{
		if(now.map == dest.map || (now.map ^ (1 << ITP(now.x, now.y))) == dest.map)
			return 0;
	}
	int ret(0);
	int x(now.map ^ dest.map);//取异或的结果就是不在自己该在的位置上的骑士为1（除了空位置的0，1不确定，这点比较粗糙）
	if (x & (1 << ITP(now.x, now.y)))//如果因为空位置导致ret多了1，应该减去，因为我们是乐观的……估价函数，而空位置是可以通过移动一个骑士的同时改变的
	{
		ret = -1;
	}
	while (x)
	{
		if (x & 1) ++ret;
		x >>= 1;
	}
	if (ret == 0) return 1;//这个……粗糙的处理，因为两个状态不可能相等的（已经判断过了），怎么可能ret==0……当然要返回1啦- -
	return ret;
}
```

接下来就是全部代码了T.T，除了上面的操作没有什么值得说的地方

```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>

#define ITP(x, y) ((x) * 5 + (y))

class state
{
public:
	state() : map(0) {}
	state(const state& s) : map(s.map), x(s.x), y(s.y) {}
	int map;
	int x, y;
};

int t;

inline void readchar(char& c)
{
	c = getchar();
	while (c != '0' && c != '1' && c != '*') c = getchar();
}

state dest, now;

void init_dest()
{
	dest.x = dest.y = 2;
	for (int i(0); i != 2; ++i)
	{
		for (int j(i); j != 5; ++j)
		{
			dest.map |= 1 << ITP(i, j);
		}
	}
	for (int i(2); i != 4; ++i)
	{
		for (int j(i + 1); j != 5; ++j)
		{
			dest.map |= 1 << ITP(i, j);
		}
	}
}

int ans;

int need(state& now)
{
	if (now.x == dest.x && now.y == dest.y)
	{
		if(now.map == dest.map || (now.map ^ (1 << ITP(now.x, now.y))) == dest.map)
			return 0;
	}
	int ret(0);
	int x(now.map ^ dest.map);
	if (x & (1 << ITP(now.x, now.y)))
	{
		ret = -1;
	}
	if (x & (1 << ITP(dest.x, dest.y))) --ret;
	while (x)
	{
		if (x & 1) ++ret;
		x >>= 1;
	}
	if (ret == 0) return 1;
	return ret;
}

const int mx[8] = {1, 1, -1, -1, 2, 2, -2, -2};
const int my[8] = {2, -2, 2, -2, 1, -1, 1, -1};

bool dfs(int dep, state& now, int max_dep)
{
	if (dep + need(now)  > max_dep)
	{
		return false;
	}
	if (dep == max_dep)
	{
		return true;
	}
	for (int i(0); i != 8; ++i)
	{
		int nowx(now.x + mx[i]), nowy(now.y + my[i]);
		if (nowx < 0 || nowy < 0 || nowx > 4 || nowy > 4) continue;
		state next(now);
		if (bool(next.map & (1 << ITP(nowx, nowy))) != bool(next.map & (1 << ITP(next.x, next.y))))
		{
			next.map ^= (1 << ITP(next.x, next.y));
		}
		next.x = nowx;
		next.y = nowy;
		if (dfs(dep + 1, next, max_dep)) return true;
	}
	return false;
}

int main()
{
	init_dest();
	scanf("%d", &t);
	for (int i(0); i != t; ++i)
	{
		now.map = 0;
		for (int i(0); i != 5; ++i)
		{
			for (int j(0); j != 5; ++j)
			{
				char c;
				readchar(c);
				switch (c)
				{
				case '0':
					break;
					
				case '1':
					now.map |= 1 << ITP(i, j);
					break;
					
				case '*':
					now.x = i;
					now.y = j;
					break;
				}
			}
		}
		bool bFind(false);
		for (int i(0); i <= 15; ++i)
		{
			if (dfs(0, now, i))
			{
				printf("%d\n", i);
				bFind = true;
				break;
			}
		}
		if (!bFind) printf("-1\n");
	}
	return 0;
}
```

/////////////////////////5.23更新（加特技）

orz本蒟蒻带着无O2 60ms，开O2 0ms的题解回来了……当然，还有更骚的位操作和双向广搜。

这道题的数据十分微妙orz。

我们先把棋盘压缩成一个int，如之前所讲。

例子就是初始状态：

11111

01111

00011

00001

00000

压缩成0000010000110001111011111B（‭33000480D‬）

但这次强制规定：空位置的位必须为0

然后我们发现，坐标x,y的范围是0-4，正好3（\*2）个二进制位……

于是，棋盘位数+坐标位数 == 25 + 6 == 31，正好压在了int的负数位前……

于是我们把初始状态压缩为0100100000010000110001111011111B（604529631D‬）

其中最前面6位表示了x，y，各占三位。

再写一个函数SetXY来帮我们设置x，y值：

```cpp
inline void SetXY(int& state, int x, int y)
{
    state &= 33554431;
    state |= x << 25;
    state |= y << 28;
}
```

后面两句还好理解的。

但第一句出现了一个魔数：33554431。我们将它的二进制写出来：

‭1111111111111111111111111‬B（别数了，二十五个1）

所以任何数字对这个数取与后只剩下前25位了，即之前压缩的map。

再写一个函数取出x，y：

```cpp
inline void GetXY(int& state, int& x, int& y)
{
    x = (state >> 25) & 7;
    y = (state >> 28) & 7;
}
```

右移25和28位大家都懂吧……把x，y的那三位移到最前面

其中又出现了一个魔数7，它的二进制是111B，即取最后3个。

好了，关于状态的说明完了。

然后写一个hash表来帮助双向广搜判断是否出现重复：

```cpp
my_std::unordered_map final, exist;
```

emm，这样就很好啦！让我们双向广搜吧！【读者：这个unordered_map什么鬼】

关于这个unordered_map，定义在下面：

```cpp
namespace my_std
{
	class unordered_map
	{
	protected:
		class item//链表的单个元素——hash冲突采用挂链处理
		{
		public:
			item() : next(0) {}
			int key, val;//键，值
			item*next;
		};
		
	public:
		unordered_map()//初始化头指针为0
		{
			for (int i(0); i != MAX_HASH; ++i) head[i] = 0;
		}
		
		item *newitem()
		{
			return &memory[next++];//内存管理。可能比new快……而且不用回收内存（下文会提到）
		}
		
		bool exist(int a) const//判断是否存在键为a的元素
		{
			int x(hash(a));
			if (head[x] == 0)
			{
				return false;
			}
			item* now(head[x]);
			while (now)
			{
				if (now->key == a) return true;
				now = now->next;
			}
			return false;
		}
		
		int& operator[](int a)//找到键为a的元素并返回其值的引用
		{
			int x(hash(a));
			if (head[x] == 0)
			{
				head[x] = newitem();
				head[x]->key = a;
				head[x]->val = 0;
				return head[x]->val;
			}
			item *now(head[x]), *front;
			while (now)
			{
				if (now->key == a) return now->val;
				front = now;
				now = now->next;
			}
			front->next = newitem();
			front->next->key = a;
			front->next->val = 0;
			return front->next->val;
		}
		
		void clear()//清空hash表
		{
			for (int i(0); i != MAX_HASH; ++i)
			{
				head[i] = 0;
			}
			next = 0;//注意，如果采用new创建元素，还应该遍历hash表delete所有元素以避免内存泄漏
			//当然，如果采用内存池的做法，重置next就好了
		}
		
	protected:
		
		int hash(int x) const { return x % MAX_HASH; }
		
		item *head[MAX_HASH];
		item memory[MAX_HASH];
		int next;//next是下一个可用的、未必为空的item
	};
}
```

好了，然后就该双向广搜了。（其实对于dest的广搜可以打表……而且打出来的表还都是int，非常完美）

双向广搜嘛，用hash表exist代替原来我们常用的bool访问标记，并且记录每个点的搜索深度（即需要走几步到达）如果搜到某个点出现在了final中（即对面广搜过来的状态），那么立即返回两个元素搜索深度之和

代码实现嘛……看下面的全部代码好了←←（本蒟蒻又开始懒了）

```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>

#include <queue>


#define ITP(x, y) ((x) * 5 + (y))

#define MAX_HASH 42333

namespace my_std
{
	class unordered_map
	{
	protected:
		class item
		{
		public:
			item() : next(0) {}
			int key, val;
			item*next;
		};
		
	public:
		unordered_map()
		{
			for (int i(0); i != MAX_HASH; ++i) head[i] = 0;
		}
		
		item *newitem()
		{
			return &memory[next++];
		}
		
		bool exist(int a) const
		{
			int x(hash(a));
			if (head[x] == 0)
			{
				return false;
			}
			item* now(head[x]);
			while (now)
			{
				if (now->key == a) return true;
				now = now->next;
			}
			return false;
		}
		
		int& operator[](int a)
		{
			int x(hash(a));
			if (head[x] == 0)
			{
				head[x] = newitem();
				head[x]->key = a;
				head[x]->val = 0;
				return head[x]->val;
			}
			item *now(head[x]), *front;
			while (now)
			{
				if (now->key == a) return now->val;
				front = now;
				now = now->next;
			}
			front->next = newitem();
			front->next->key = a;
			front->next->val = 0;
			return front->next->val;
		}
		
		void clear()
		{
			for (int i(0); i != MAX_HASH; ++i)
			{
				head[i] = 0;
			}
			next = 0;
		}
		
	protected:
		
		int hash(int x) const { return x % MAX_HASH; }
		
		item *head[MAX_HASH];
		item memory[MAX_HASH];
		int next;
	};
}

my_std::unordered_map final, exist;




int t;

inline void readchar(char& c)
{
    c = getchar();
    while (c != '0' && c != '1' && c != '*') c = getchar();
}

int dest(604529631), now;

inline void SetXY(int& state, int x, int y)
{
    state &= 33554431;
    state |= x << 25;
    state |= y << 28;
}

inline void GetXY(int& state, int& x, int& y)
{
    x = (state >> 25) & 7;
    y = (state >> 28) & 7;
}


const int mx[8] = { 1, 1, -1, -1, 2, 2, -2, -2 };
const int my[8] = { 2, -2, 2, -2, 1, -1, 1, -1 };

void init_dest()
{
    final[dest] = 0;
    std::queue<int> que, dep;
    que.push(dest);
    dep.push(0);
    while (!que.empty())
    {
        int now(que.front());
        int depth(dep.front());
        que.pop();
        dep.pop();
        if (depth == 9)
        {
            continue;
        }
        int nowx, nowy;
        GetXY(now, nowx, nowy);
        for (int i(0); i != 8; ++i)
        {
            int nx(nowx + mx[i]), ny(nowy + my[i]);
            if (nx < 0 || ny < 0 || nx > 4 || ny > 4) continue;
            int next(now);
            if (next & (1<<ITP(nx, ny)))
            {
                next ^= (1 << ITP(nowx, nowy)) | (1 << ITP(nx, ny));
            }
            SetXY(next, nx, ny);
            if (!final.exist(next))
            {
                final[next] = depth + 1;
                que.push(next);
                dep.push(depth + 1);
            }
            else
            {
                next = next + 1 - 1;
            }
        }
    }
}

int ans;

int bfs()
{
    exist.clear();
    exist[now] = 0;
    std::queue<int> que, dep;
    que.push(now);
    dep.push(0);
    while (!que.empty())
    {
        int now(que.front());
        int depth(dep.front());
        que.pop();
        dep.pop();
        if (final.exist(now))
        {
            return depth + final[now];
        }
        if (depth == 6) continue;
        int nowx, nowy;
        GetXY(now, nowx, nowy);
        for (int i(0); i != 8; ++i)
        {
            int nx(nowx + mx[i]), ny(nowy + my[i]);
            if (nx < 0 || ny < 0 || nx > 4 || ny > 4) continue;
            int next(now);
            if (next & (1 << ITP(nx, ny)))
            {
                next ^= (1 << ITP(nowx, nowy)) | (1 << ITP(nx, ny));
            }
            if (next & (1 << ITP(nx, ny))) next ^= (1 << ITP(nx, ny));
            SetXY(next, nx, ny);
            if (!exist.exist(next))
            {
                exist[next] = depth;
                que.push(next);
                dep.push(depth + 1);
            }
        }
    }
    return -1;
}

int main()
{
    init_dest();
    scanf("%d", &t);
    for (int i(0); i != t; ++i)
    {
        now = 0;
        for (int i(0); i != 5; ++i)
        {
            for (int j(0); j != 5; ++j)
            {
                char c;
                readchar(c);
                switch (c)
                {
                case '0':
                    break;

                case '1':
                    now |= 1 << ITP(i, j);
                    break;

                case '*':
                    SetXY(now, i, j);
                    break;
                }
            }
        }
        printf("%d\n", bfs());
    }
    return 0;
}
```




---

## 作者：深巷少年与猫 (赞：11)

题解里的bfs好像大多都是双向搜的，其实单向搜也可以

这道题就是一个A*

我把这个图，跟空格的横纵坐标压成一个string，放在结构体里，每次判断一下是不是到了目标状态，然后用一个map记录一下是否跑过，估价函数就是判断目前状态与目标状态的不同的点的个数，如果这个差距加上目前步数超过了15步，就说明一定跑不到了。

放代码：

```cpp

#include <bits/stdc++.h>
using namespace std;
map<string,int>s;
int mp[6][6],b[6][6],ans[6][6];
string goal;
int dx[9]={0,1,1,2,2,-1,-1,-2,-2};
int dy[9]={0,2,-2,1,-1,2,-2,1,-1};
string get_char(int x){
	if(x==0){
		return "0";
	}
	if(x==1){
		return "1";
	}
	if(x==2){
		return "2";
	}
	if(x==3){
		return "3";
	}
	if(x==4){
		return "4";
	}
	if(x==5){
		return "5";
	}
}
string lock(int a[6][6],int x,int y){
	string res;
	for(int i=1;i<=5;i++){
		for(int j=1;j<=5;j++){
			res+=get_char(a[i][j]);
		}
	} 
	res+=get_char(x);
	res+=get_char(y);
	return res;
}
int get(string res,int step){
	int cnt=0;
	for(int i=1;i<=5;i++){
		for(int j=1;j<=5;j++){
			ans[i][j]=res[(i-1)*5+j-1]-'0';
			if(ans[i][j]!=b[i][j]){
				cnt++;
			}
		}
	}
	if(cnt+step>15){
		return 0;
	}
	else{
		return 1;
	}
}
struct road{
	int step,x,y;
	string sub;
};
void bfs(string fir,int x,int y){
	queue<road>q;
	road st;
	st.step=0;
	st.x=x;
	st.y=y;
	st.sub=fir;
	q.push(st);
	int cnt=0;
	while(!q.empty()){
		road now=q.front();
		q.pop();
		if(now.step>15){
			printf("-1\n");
			return ;
		}
		if(now.sub==goal){
			printf("%d\n",now.step);
			return ;
		}
		if(get(now.sub,now.step)==0) continue;
		for(int i=1;i<=8;i++){
			int nowx=now.x+dx[i];
			int nowy=now.y+dy[i];
			if(nowx<1||nowx>5||nowy<1||nowy>5){
				continue;
			}
			int kkk[6][6];
			for(int i=1;i<=5;i++){
				for(int j=1;j<=5;j++){
					kkk[i][j]=ans[i][j];
				}
			}
			swap(kkk[now.x][now.y],kkk[nowx][nowy]);
			road node;
			node.step=now.step+1,node.x=nowx,node.y=nowy;
			node.sub=lock(kkk,nowx,nowy);
			if(!s[node.sub]){
				s[node.sub]=1;
				q.push(node);
			}
		}
	}
	printf("-1\n");
}
int main(){
	int t;
	scanf("%d",&t);
	b[1][1]=1,b[1][2]=1,b[1][3]=1,b[1][4]=1,b[1][5]=1;
	b[2][1]=0,b[2][2]=1,b[2][3]=1,b[2][4]=1,b[2][5]=1;
	b[3][1]=0,b[3][2]=0,b[3][3]=0,b[3][4]=1,b[3][5]=1;
	b[4][1]=0,b[4][2]=0,b[4][3]=0,b[4][4]=0,b[4][5]=1;
	b[5][1]=0,b[5][2]=0,b[5][3]=0,b[5][4]=0,b[5][5]=0;
	goal=lock(b,3,3);
	while(t--){
		s.clear();
		int sx,sy;
		for(int i=1;i<=5;i++){
			string a;
			cin>>a;
			for(int j=0;j<a.size();j++){
				if(a[j]=='0'){
					mp[i][j+1]=0;
				}
				else if(a[j]=='1'){
					mp[i][j+1]=1;
				}
				else{
					mp[i][j+1]=0;
					sx=i;
					sy=j+1;
				}
			}
		}
		string fir=lock(mp,sx,sy);
		bfs(fir,sx,sy);
	}
	return 0;
}


---

## 作者：狸狸养的敏敏 (赞：8)

看到大家都用 $A*$, $IDA*$,本蒟蒻深深感受到了自己的弱小QAQ

其实这道题可以用$BFS$做，但是不是做$15$步内的$BFS$，而是做$7-8$步的$BFS$

那答案不是错的嘛？

我们从起始状态做一次$BFS$，再从结束状态做一个$BFS$，经过我们的计算~~打表~~，我们发现程序计算$8$步以内的结果非常快，所以我们做两次$BFS$之后，看两次结果序列的交集是否为空，若为空，则说明无解，否则有解

也就是双向$BFS$，感觉有点像$Meet\ in\ Middle$的思想

利用了把地图转换为一个字符串，然后用$map$存储的做法

```
//Copyright (c) 2019 by xiao_mmqueF. All Rights Reserved.
#include<bits/stdc++.h>
#define inl inline
#define reg register
#define INF 0x3f3f3f3f
using namespace std;
inl int read(){ int x=0,f=0; char ch=0; while(!isdigit(ch))f|=(ch=='-'),ch=getchar(); while(isdigit(ch))(x*=10)+=(ch^48),ch=getchar(); return f?-x:x; }
inl void Ot(reg int x) { if(x<0)putchar('-'),x=-x; if(x>=10)Ot(x/10); putchar(x%10+'0'); }
inl void Print(reg int x,char til='\n'){Ot(x);putchar(til);}
inl int Max(reg int x,reg int y){return x>y?x:y;}
inl int Min(reg int x,reg int y){return x<y?x:y;}
inl int Abs(reg int x){return x<0?-x:x;} 
struct Node{
	int x, y;
	string s;
};
map<string, int> mp;
int mv[8][2]={{1,2},{1,-2},{-1,2},{-1,-2},{2,1},{2,-1},{-2,1},{-2,-1}};
string aim="111110111100*110000100000";//目标状态
bool bfs(int x, int y, string s) {
	queue<Node> que;
	que.push((Node){x, y, s});
	mp[s]=1;
	while (!que.empty()) {
		Node h=que.front();
		que.pop();
		if (mp[h.s]==8) break;//8步就停
		if (h.s==aim) {
			Print(mp[h.s]-1);//8步内得到了答案
			return true;
		}
		for (int i=0; i<8; i++) {
			int xx=h.x+mv[i][0], yy=h.y+mv[i][1];
			if (xx<1 || xx>5 || yy<1 || yy>5) continue;
			string tmp=h.s;
			int tmp1=(h.x-1)*5+h.y, tmp2=(xx-1)*5+yy;
			char tmp_c=tmp[tmp1-1];
			tmp[tmp1-1]=tmp[tmp2-1];
			tmp[tmp2-1]=tmp_c;
			if (mp[tmp]==0) {
				mp[tmp]=mp[h.s]+1;
				que.push((Node){xx, yy, tmp});
			}
		}
	}
	return false;
}
void bfss(int x, int y, string s) {
	queue<Node> que;
	map<string, int> mpS;
	mp[s]=1;
	que.push((Node){x, y, s});
    mpS[s]=true;
	while (!que.empty()) {
		Node h=que.front();
		que.pop();
		if (mp[h.s]==9) {//步数到9了，说明总共超过了15步
			Print(-1);//返回无解
			return ;
		}
		for (int i=0; i<8; i++) {
			int xx=h.x+mv[i][0], yy=h.y+mv[i][1];
			if (xx<1 || xx>5 || yy<1 || yy>5) continue;
			string tmp=h.s;
			int tmp1=(h.x-1)*5+h.y, tmp2=(xx-1)*5+yy;
			char tmp_c=tmp[tmp1-1];
			tmp[tmp1-1]=tmp[tmp2-1];
			tmp[tmp2-1]=tmp_c;
			if (mp[tmp]!=0 && !mpS[tmp]) {//如果与第一次有交集
				cout << mp[tmp]-1+mp[h.s] << endl;
				return ;
			}
			if (!mpS[tmp]) {
				mp[tmp]=mp[h.s]+1;
				que.push((Node){xx, yy, tmp});
				mpS[tmp]=true;
			}
		}
	}
}
 
int main() {
	for(reg int T=read();T;T--) {
		mp.clear();
		string tmp, s="";
		int x, y;
		for (int i=1; i<=5; i++) {
			cin>>tmp;
			for (int j=0; j<5; j++)
				if (tmp[j]=='*') 
					x=i, y=j+1;
			s+=tmp;//将开始状态作为字符串存储
		}
		if (!bfs(x, y, s)) bfss(3, 3, aim);
	}
	return 0;
}
```

---

## 作者：wyhwyh (赞：7)

### $IDA^*$ 学习笔记

[具体的预姿势](https://www.cnblogs.com/ZAGER/p/9768170.html)

~~其实我也是现学现卖，就是觉得本人智商太低，参考了挺多资料才理解 IDA* ，想帮助其他像我一样的菜鸡（虽然我这么菜的可能不多）以及以后自己复习用，把抽象的 IDA* 和本题具体的结合起来，自以为可能更好理解一点qwq~~

我们用$g(n)$表示节点的实际步数，就是已经搜了几步。

$h(n)$表示节点的“咕价函数”，顾名思义，咕算大概（从当前节点到终点）还要搜几步， **并且保证实际代价不会比$h(n)$更小。** 在本题中的体现为当前状态与最终状态有多少个不符的。（对了，这是[树剖姐姐](https://www.luogu.org/user/124721)告诉窝的，在此鸣谢qwq

然后令

$$f(n)=g(n)+h(n)$$

那么本题的优化就出来了，$f(n)$显然是$≤15$的，然后搜就好啦！

(其实代码不用看的qwq，懂了思路就直接搜就好啦~

**Code**

```cpp

#include<iostream>
#include<cstdio>

using namespace std;

const int inf = 1e9;
int T,ans;
char map[5][5],fin[5][5]=
{
	{'1','1','1','1','1'},
	{'0','1','1','1','1'},
	{'0','0','*','1','1'},
	{'0','0','0','0','1'},
	{'0','0','0','0','0'}
};

int sx,sy;
int dx[8]={1,1,-1,-1,2,2,-2,-2};
int dy[8]={2,-2,2,-2,1,-1,1,-1};

int f()
{
	int cnt=0;
	for(int i=0;i<5;++i)
		for(int j=0;j<5;++j)
			if(map[i][j]!=fin[i][j])
				++cnt;
	return cnt;
}

void init()
{
	string s[5];
	for(int i=0;i<5;++i) cin>>s[i];
	for(int i=0;i<5;++i)
	{
		for(int j=0;j<5;++j)
		{
			map[i][j]=s[i][j];
			if(map[i][j]=='*') {sx=j;sy=i;}
		}
	}
}

void dfs(int x,int y,int fx,int fy,int g)
// (x,y) means the node where I am now, and g means the distance I have gone 
{
	int h=f();//F=g+h (not f()!!! 
	if(h+g>16) return;//Bao Xian QwQ 
	if(g>=ans) return;
	if(h==0) {ans=g;return;}
	for(int i=0;i<8;++i)
	{
		int nx=x+dx[i],ny=y+dy[i];
		if(nx<0||ny<0||nx>4||ny>4) continue;
		if(nx==fx&&ny==fy) continue;//can't go back 
		swap(map[nx][ny],map[x][y]);
		dfs(nx,ny,x,y,g+1);
		swap(map[nx][ny],map[x][y]);
	}
}

int main()
{
	scanf("%d",&T);
	while(T--)
	{
		init();
		ans=inf;
		dfs(sy,sx,0,0,0);
		if(ans==inf) printf("-1\n");
		else printf("%d\n",ans);
	}
	return 0;
}

```

---

## 作者：Sol1 (赞：6)

why IDA*???

why A*???

~~没想到吧~~，其实一个双端bfs~~加O2~~就够用。。

首先考虑爆搜。这时复杂度为$\Theta(8^{16})=\Theta(2.8\times 10^{14})$，显然太~慢了。

发现$\Theta(8^8)$卡常可以满足要求，所以考虑双端BFS。

双端BFS是从起始状态（即样例给出的状态）和终止状态（即目标棋盘）两个状态开始BFS，如果在中间相遇就没有必要BFS了，可以直接输出。

下面是双端BFS的示意图。

![](https://cdn.luogu.com.cn/upload/image_hosting/5ievjbuj.png)

可以看出，使用双端BFS可以将指数缩小一半。比如这道题，一步扩展8个状态（考虑让空格按照马的规则走），最多扩展16步，复杂度即$\Theta(8^8)=\Theta(1.6\times 10^7)$。

双端BFS有2种实现：1，将起点和终点放进同一个队列中扩展；2，将起点和终点分别放进一个队列，每次从一个队列中取出队头扩展。这里采用第2种实现。

要注意几个细节：1，棋盘用3进制数转换为long long，并用map记录距离；2，输出答案时判断答案是否大于15，如果是则输出-1；3，状态的距离要到16而不是8或9再输出-1；4，注意队列判空

然后就看代码吧~

```cpp
#include <iostream>
#include <cmath>
#include <cstring>
#include <cstdio>
#include <queue>
#include <map>
using namespace std;

const int Next[8][2] = {{1, 2}, {2, 1}, {1, -2}, {2, -1}, {-1, 2}, {-2, 1}, {-1, -2}, {-2, -1}};
struct Board {
	int a[6][6], ex, ey, stp;
};
Board st, ed;
queue <Board> qst, qed;

long long Board2Int(Board b) {
	long long k = 1, sum = 0;
	for (int i = 1;i <= 5;i++) {
		for (int j = 1;j <= 5;j++) {
			sum += b.a[i][j] * k;
			k *= 3;
		}
	}
	return sum;
}

Board Int2Board(long long x) {
	Board b;
	for (int i = 1;i <= 5;i++) {
		for (int j = 1;j <= 5;j++) {
			b.a[i][j] = x % 3;
			x /= 3;
		}
	}
	return b;
}

void Read() {
	string s;
	for (int i = 1;i <= 5;i++) {
		cin >> s;
		for (int j = 0;j < 5;j++) {
			if (s[j] == '*') {
				st.a[i][j + 1] = 2;
				st.ex = i;
				st.ey = j + 1;
			} else st.a[i][j + 1] = s[j] - 48;
		}
	}
	st.stp = 1;
}

void Prefix() {
	ed.a[1][1] = 1; ed.a[1][2] = 1; ed.a[1][3] = 1; ed.a[1][4] = 1; ed.a[1][5] = 1;
	ed.a[2][1] = 0; ed.a[2][2] = 1; ed.a[2][3] = 1; ed.a[2][4] = 1; ed.a[2][5] = 1;
	ed.a[3][1] = 0; ed.a[3][2] = 0; ed.a[3][3] = 2; ed.a[3][4] = 1; ed.a[3][5] = 1;
	ed.a[4][1] = 0; ed.a[4][2] = 0; ed.a[4][3] = 0; ed.a[4][4] = 0; ed.a[4][5] = 1;
	ed.a[5][1] = 0; ed.a[5][2] = 0; ed.a[5][3] = 0; ed.a[5][4] = 0; ed.a[5][5] = 0;
	ed.ex = ed.ey = 3;
	ed.stp = 1;
	qst.push(st); qed.push(ed);
}

void Solve() {
	map <long long, int> dis1;
	map <long long, int> dis2;
	dis1[Board2Int(st)] = 1; dis2[Board2Int(ed)] = 1;
	while (!qst.empty() || !qed.empty()) {
		if (!qst.empty()) {
			Board cur = qst.front();
			qst.pop();
			if (cur.stp >= 16) break;
			for (int i = 0;i < 8;i++) {
				int tx = cur.ex + Next[i][0], ty = cur.ey + Next[i][1];
				if (tx < 1 || tx > 5 || ty < 1 || ty > 5) continue;
				Board tmp = cur;
				swap(tmp.a[tx][ty], tmp.a[tmp.ex][tmp.ey]);
				tmp.ex = tx; tmp.ey = ty;
				tmp.stp = cur.stp + 1;
				long long x = Board2Int(tmp);
				if (dis1[x]) continue;
				if (dis2[x]) {
					if (tmp.stp + dis2[x] - 2 > 15) printf("-1\n");
					else printf("%d\n", tmp.stp + dis2[x] - 2);
					return;
				}
				dis1[x] = tmp.stp;
				qst.push(tmp);
			}
		}
		if (!qed.empty()) {
			Board cur = qed.front();
			qed.pop();
			if (cur.stp >= 16) break;
			for (int i = 0;i < 8;i++) {
				int tx = cur.ex + Next[i][0], ty = cur.ey + Next[i][1];
				if (tx < 1 || tx > 5 || ty < 1 || ty > 5) continue;
				Board tmp = cur;
				swap(tmp.a[tx][ty], tmp.a[tmp.ex][tmp.ey]);
				tmp.ex = tx; tmp.ey = ty;
				tmp.stp = cur.stp + 1;
				long long x = Board2Int(tmp);
				if (dis2[x]) continue;
				if (dis1[x]) {
					if (tmp.stp + dis1[x] - 2 > 15) printf("-1\n");
					else printf("%d\n", tmp.stp + dis1[x] - 2);
					return;
				}
				dis2[x] = tmp.stp;
				qed.push(tmp);
			}
		}
	}
	printf("-1\n");
}

int main() {
	int t;
	scanf("%d", &t);
	while (t--) {
		Read();
		Prefix();
		Solve();
		while (!qst.empty()) qst.pop();
		while (!qed.empty()) qed.pop();
	}
	return 0;
}
```

---

## 作者：pupuvovovovovo (赞：5)

目前本人以3ms代码rank1。

很显然，这题状态数有一大堆，不好的话有3^25种，最少也有25\*2^24种，远远超过了bool或者int下标的最大值。

于是不能记录状态，于是就不能广搜，只能深搜。

看到最大步数有限制，于是果断上IDA\*。

~~                     分                  割                   线                ~~

以下内容dalao勿(bi)报(ao)

IDA\*中，ID是指迭代加深，A\*是对其的一个优化。

迭代加深是对深搜的一个优化。

深搜经过的节点（状态）可以用一颗树来表示。

假设我们的搜索树最大深度很深，但是答案的深度很浅，那么有时候就会做很多无用功。

 ![](https://cdn.luogu.com.cn/upload/pic/6795.png) 

而ID搜索是这么做的：每次找一个深度阈值，如果当前节点的深度大于所设的阈值，就退出，如果在这个阈值下找不到解，就加大阈值，直到找到可行解。这时的可行解也一定就是最优解。

伪代码：

```cpp
void dfs(int maxlen,int cur){
    if (找到解) flag=true,return;①
    if (cur>maxlen+1||重复出现) return;②
    for (枚举下一步可行状态){
        更改状态;
        dfs(maxlen,cur+1);
        if (flag) return;
        恢复状态;
    }
}
```
①②的细节及先后根据个人写法及题目分析。

这样的复杂度：第i层的状态数一般来说大于等于1到i-1个层的状态数之和，因此如果和BFS一样判重的话时间复杂度与普通BFS无异，常数或许稍大，但(如果无法判重)会节约了一大堆空间复杂度。

IDA\*：针对ID，如果我们已经知道当前这个状态无论如何也无法在阈值内转移出解，那么就不必再往下搜索了。其实就是一个有效的剪枝。等价于把上面DFS中cur>maxlen+1变成cur+h()>maxlen+1，其中h()返回当前状态转移到解的估计步数，叫估价函数。

显然，h()可以把答案估优，大不了剪枝少一点，但估劣就会导致错误。

~~                     分                  割                   线                ~~

对本题，一个~~显而易见的~~估价函数就是返回不在自己地盘上的骑士数。

但这可以优化，即返回各个不在自己地盘上的骑士跳回地盘最少需要几步的和。

然后我们就发现这东西不需要每次都统计，只要开一个变量，在更改状态（及恢复状态）时维护一下就可以了。

再然后，不要用STL，函数用inline，交换用^=，开O2就可以了。

（代码不但丑，还有很多不需要的东西，请略过）





```cpp
#if 0
#include<iostream>
#include<cstdio>
#include<string>
#include<cstring>
#include<algorithm>
#include<stdlib.h>
#include<time.h>
#include<map>
#include<queue>
#include<set>
#include<utility>
#else
#include<bits/stdc++.h>
#endif
#if 0
#include<cmath>
#endif
#define REP(x,l,r) for (int x=(l);x<=(r);++x)
#define RREP(x,r,l) for (int x=(r);x>=(l);--x)
#define fr(x) freopen(x,"r",stdin)
#define fw(x) freopen(x,"w",stdout)
#define mem(a) memset(a,0,sizeof(a))
#define memax(a) memset(a,127,sizeof(a))
#define memid(a) memset(a,63,sizeof(a))
#define dbg(x) cout<<#x<<" = "<<(x)<<endl
#define tpn typename
#define fi first
#define se second
#define moIOIAK return
#define xxxm9987dalao 0
typedef long long ll;
typedef unsigned long long ull;
typedef double db;
typedef long double ldb;
using namespace std;
template <tpn A> inline void Swap(A &x,A &y){
    x^=y,y^=x,x^=y;
}
template <tpn A> inline A Max(A &x, A &y) {
    return x > y ? x : y;
}
template <tpn A> inline A Min(A &x, A &y) {
    return x < y ? x : y;
}
template <tpn A> inline void read(A &x){
    char c;
    A neg=1;
    do{
        c=getchar();
        if (c=='-') neg=-1;
    }while (c<'0'||c>'9');
    x=0;
    do{
        x=x*10+c-48;
        c=getchar();
    }while (c>='0'&&c<='9');
    x*=neg;
}
inline bool pos(int a){
    return a>0;
}
inline bool neg(int a){
    return a<0;
}
template <tpn A,tpn B> inline void read(A &x,B &y){read(x);read(y);}
template <tpn A,tpn B,tpn C> inline void read(A &x,B &y,C &z){read(x);read(y);read(z);}
template <tpn A,tpn B,tpn C,tpn D> inline void read(A &x,B &y,C &z,D &dd){read(x);read(y);read(z);read(dd);}
const int w[5][5]={{1,1,1,2,2},{0,1,1,1,1},{0,0,1,1,1},{0,0,0,0,1},{0,0,0,0,0}};//0
const int b[5][5]={{0,0,0,0,0},{1,0,0,0,0},{1,1,1,0,0},{1,1,1,1,0},{2,2,1,1,1}};//1
int ma[5][5];
int T,dif,sx,sy;//dif是用来剪枝的（估价函数？）
char s[5][6];
bool flag;
##inline void dfs(int,int,int);
#inline void push(int nsx,int nsy,int maxlen,int cur,int way,int law){//last way
    if (nsx<0||nsx>4||nsy<0||nsy>4||way==law) return;
    int ydif=dif;
    if (pos(ma[nsx][nsy])) dif+=b[sx][sy]-b[nsx][nsy];
    else dif+=w[sx][sy]-w[nsx][nsy];
    int ysx=sx,ysy=sy;
    Swap(ma[sx][sy],ma[nsx][nsy]);
    sx=nsx,sy=nsy;
    dfs(maxlen,cur+1,way);
    sx=ysx,sy=ysy;
    Swap(ma[sx][sy],ma[nsx][nsy]);
    dif=ydif;
}
inline void dfs(int maxlen,int cur,int way){
    if (!dif){
        flag=1;
        return;
    }
    if (cur+dif>maxlen+1) return;
    push(sx+2,sy+1,maxlen,cur,1,9-way);
    if (flag) return;
    push(sx+1,sy+2,maxlen,cur,2,9-way);
    if (flag) return;
    push(sx-1,sy+2,maxlen,cur,3,9-way);
    if (flag) return;
    push(sx-2,sy+1,maxlen,cur,4,9-way);
    if (flag) return;
    push(sx-2,sy-1,maxlen,cur,8,9-way);
    if (flag) return;
    push(sx-1,sy-2,maxlen,cur,7,9-way);
    if (flag) return;
    push(sx+1,sy-2,maxlen,cur,6,9-way);
    if (flag) return;
    push(sx+2,sy-1,maxlen,cur,5,9-way);
    if (flag) return;
}
###int main(){
    read(T);
    int numT=T;
    while (T--){
        REP(i,0,4) scanf("%s",s[i]);
        REP(i,0,4)
          REP(j,0,4){
              if (s[i][j]=='1') ma[i][j]=1;
              else if (s[i][j]=='0') ma[i][j]=-1;
              else ma[i][j]=0,sx=i,sy=j;
              if (pos(ma[i][j])) dif+=b[i][j];
              if (neg(ma[i][j])) dif+=w[i][j];
          }
        if (!dif){
            printf("0\n");
            continue;
        }
        int tot=0;
        while (!flag&&tot<15){
            tot++;
            dfs(tot,1,0);
        }
        if (flag) printf("%d\n",tot);
        else printf("-1\n");
        flag=dif=0;
    }
    moIOIAK xxxm9987dalao;
}
```

---

## 作者：安好 (赞：4)

/\*
迭代加深dfs经典题！

记录目标状态，然后从起始状态搜索。

爆搜可能超时，要加剪枝

\*/




```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#define limit 15
using namespace std;
int T,ans=20,flag;
int xx[9]={0,-2,-2,-1,-1,1,1,2,2};
int yy[9]={0,-1,1,-2,2,2,-2,1,-1};
int s[10][7],get[10][10];
int target[10][10];
char si;
void get_t()//记录目标状态 
{
    target[1][1]=1;target[1][2]=1;target[1][3]=1;target[1][4]=1;target[1][5]=1;
    target[2][1]=0;target[2][2]=1;target[2][3]=1;target[2][4]=1;target[2][5]=1;
    target[3][1]=0;target[3][2]=0;target[3][3]=2;target[3][4]=1;target[3][5]=1;
    target[4][1]=0;target[4][2]=0;target[4][3]=0;target[4][4]=0;target[4][5]=1;
    target[5][1]=0;target[5][2]=0;target[5][3]=0;target[5][4]=0;target[5][5]=0;
}
int Judge()//计算当前状态与目标状态至少还有多少步 
{
    int ret=0;
    for(int i=1;i<=5;i++)
      for(int j=1;j<=5;j++)
      {
          if(s[i][j]!=target[i][j])
            ret++;
      }
    return ret;
}
void DFS(int now,int x,int y,int sum)
{
    if(flag) return;
    int c=Judge();
    if(now==sum)
    {
        if(c==0)
          flag=1,ans=sum;
    }
    if(now-1+c>sum) return;//最优性剪枝：当前的步数+差异>限制步数 
    for(int i=1;i<=8;i++)
    {
        int nx=x+xx[i];
        int ny=y+yy[i];
        if(nx>0&&nx<=5&&ny>0&&ny<=5)
        {
            swap(s[x][y],s[nx][ny]);
            DFS(now+1,nx,ny,sum);
            swap(s[x][y],s[nx][ny]);
        }
    }
}
int main()
{
    scanf("%d",&T);
    get_t();
    while(T--)
    {
        int x,y;
        for(int i=1;i<=5;i++)
          for(int j=1;j<=5;j++)
          {
              cin>>si;
              if(si=='*'){x=i;y=j;get[i][j]=2;}    
            else get[i][j]=si-'0';
          }
        for(int k=0;k<=limit;k++)//迭代加深限制步数 
        {
            flag=0;ans=20;
            for(int i=1;i<=5;i++)
              for(int j=1;j<=5;j++)
                s[i][j]=get[i][j];
            DFS(0,x,y,k);
            if(ans==k) break;
        }
        if(ans<=15)printf("%d\n",ans);
        else printf("-1\n");
    }
    return 0;
}
```

---

## 作者：k1saki (赞：3)

### 前言：
##### 双向$bfs$，顾名思义，就是从两头一起搜索的$bfs$，  
##### 需要同时知道初始状态和终止状态（当然也可以使用$AStar$算法）， 
##### 可以减少一半的搜索深度，使时间复杂度大大降低，
##### 本题就是典型，终止状态一定，给出初始状态找出最小的移动次数

### 思路：
将读入的矩阵转化为字符串，利用$map$进行判重（有$25$位），进行双向$bfs$,如果遇到从另一端搜索而来的情况已经满足，直接输出即可，当搜索深度$>=8$时不再继续放入队列（$15$步以内），如果无解（$>15$）输出$-1$


### 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int dx[]={-1,1,-1,1,-2,2,2,-2},dy[]={-2,2,2,-2,-1,1,-1,1};
struct node
{
	string x;
	int id,steps;
	node()
	{
	}
	node(string _x,int _id,int _steps)
	{
		x=_x,id=_id,steps=_steps; 
	}
};//x为转化的字符串，id表示从后往前或从前往后搜,steps表示移动次数
map<string,int> mp1,mp2;//利用map进行判重
queue<node> q;
int main()
{
	int t;
	cin>>t;
	string to="1111101111002110000100000",st;//转化为字符串处理
	while(t--)
	{	
		bool flag=1;
		st.clear();
		while(!q.empty()) q.pop();
		mp1.clear(),mp2.clear();//清空先前的状态
		for (int i=1;i<=5;i++)
		{
			for (int j=1;j<=5;j++)
			{
				char x;
				do
				{
					x=getchar();
					//cout<<x;
				}
				while(x!='*'&&!isdigit(x));
				if (x=='*') st+='2';
				else st+=x;
			}
		}
		q.push(node(st,0,0));
		q.push(node(to,1,0));
		while(!q.empty())
		{
			node u=q.front();
			q.pop();
			if (u.id==1)
			{
				if (mp1[u.x]!=0) continue;//已经搜索过，不是最优解
				mp1[u.x]=u.steps;//更新
				if (mp2[u.x]!=0||u.x==st)//如果另一端搜到过，输出答案
				{
					flag=0;
					//cout<<mp2[u.x]<<' '<<mp1[u.x]<<endl;
					if (mp2[u.x]+mp1[u.x]>15)
					{
						puts("-1");
						break;//次数>15，输出-1
					}
					printf("%d\n",mp2[u.x]+mp1[u.x]);//次数<=15，输出答案
					break;
				}
			}
			else
			{
				if (mp2[u.x]!=0) continue;
				mp2[u.x]=u.steps;
				if (mp1[u.x]!=0||u.x==to)
				{
					flag=0;
					//cout<<mp2[u.x]<<' '<<mp1[u.x]<<endl;
					if (mp2[u.x]+mp1[u.x]>15)
					{
						puts("-1");
						break;
					}
					printf("%d\n",mp2[u.x]+mp1[u.x]);
					break;
				}
			}//注意特判一步到位的情况，否则会输出3（开始时map不会被更新）
			int posx,posy;
			for (int i=0;i<25;i++)
			{
				if (u.x[i]=='2')
				{
					posx=i/5+1;
					posy=i%5+1;
					break;
				}
			}//找到空格在字符串中的位置
			if (u.steps>=8) continue;//深度达到8，得到答案一定>15
			u.steps++;
			for (int i=0;i<8;i++)
			{
				int tox=posx+dx[i],toy=posy+dy[i];
				if(tox<1||tox>5||toy<1||toy>5) continue;
				swap(u.x[(tox-1)*5+toy-1],u.x[(posx-1)*5+posy-1]);
           //移动棋子，放入队尾
				q.push(u);
				swap(u.x[(tox-1)*5+toy-1],u.x[(posx-1)*5+posy-1]);
			}
		}
		if (flag) puts("-1");//无解，输出答案
	}
	return 0;
}
```
### 结语：
1.双向$bfs$类似折半枚举，可以减少一半的搜索深度，但必须在知道终止状态的前提下才可使用，但不失为$AStar$以外的另一种方法


2.推荐题目：[P1379 八数码难题](https://www.luogu.org/problem/P1379)

---

## 作者：Heartlessly (赞：3)

## Description

在一个 $5 \times 5$ 的棋盘上有白色和黑色的骑士各 $12$ 个，以及一个空位（每个骑士都可以移动到和它横坐标相差 $2$，纵坐标相差 $1$ 或横坐标相差 $1$，纵坐标相差 $2$ 的空位上）。给定初始棋盘，求出至少移动多少次能得到目标棋盘（如下图）。如果 $15$ 步以内不能得到，输出 $-1$ 。

![E5zvdO.png](https://s2.ax1x.com/2019/05/14/E5zvdO.png)

## Solution

$\rm IDA^*$ 经典题。

不管是 $\rm A^*$ 还是 $\rm IDA^*$，最重要的就是 **估价函数**，定义为：

$$f(n) = g(n) + h(n)$$

其中 $f(n)$ 是节点 $n$ 的估价函数，$g(n)$ 是当前的实际步数，$h(n)$ 是对未来步数的最完美估价。

为什么是这样呢？

假设你觉得到 $n$ 这个状态需要 $f(n)$ 步，你到当前状态已经花了 $g(n)$ 步，现在你想从当前状态到 $n$ 这个状态，在运气最好的情况下还需要 $h(n)$ 步。若 $g(n) + h(n) > f(n)$，则显然当前状态不能再 $f(n)$ 步之内到达 $n$ 这个状态。

如果要让所有马归位，状态数会非常多，所以我们考虑移动空位，即让空位与马交换位置，直到当前状态与目标状态相同。除此之外，这道题有要求 $15$ 步之内完成，所以可以 **迭代加深**，即规定最大深度，超过这个深度就直接退出。换句话说，我们可以把这个最大深度作为 $f(n)$ 。

本题中的 **最完美估价**：

```cpp
const int goal[MAXN + 1][MAXN + 1] = { //目标矩阵 
{ 0, 0, 0, 0, 0, 0 }, 
{ 0, 1, 1, 1, 1, 1 }, 
{ 0, 0, 1, 1, 1, 1 }, 
{ 0, 0, 0, -1, 1, 1 }, 
{ 0, 0, 0, 0, 0, 1 }, 
{ 0, 0, 0, 0, 0, 0 } 
};

inline int h() {//最完美估价
    int cnt = 0;
    for (int i = 1; i <= 5; ++i)
        for (int j = 1; j <= 5; ++j)
            cnt += a[i][j] != goal[i][j];
    //我们统计了当前状态与目标状态不同的位置个数为 cnt，
    //但是我们实际要统计的是不在自己位置上的马的个数，
    //这里我们把空位也算了进去，若所有马都在自己位置上，
    //则此时空位也一定在自己的位置上，由此可得，
    //空位对结果没有影响，所以最后 cnt 要 -1 
    return cnt - 1;
}
```

对于一匹不在自己位置上的马，在最优的情况下，我们只需要一次移动就能使这匹马归位。假设每一匹这样的马都需要移动一次，所以我们统计这样的马的个数即可。

还有一个剪枝，就是记录上一步是空格在哪个位置，下一步再跳回上一步的位置显然不优，这样可以少掉很多无用递归。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

template <class T>
inline void read(T &x) {
    x = 0;
    char c = getchar();
    bool f = 0;
    for (; !isdigit(c); c = getchar()) f ^= c == '-';
    for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);
    x = f ? -x : x;
}

inline void readChar(char &c) {
    for (c = getchar(); c != '0' && c != '1' && c != '*'; c = getchar());
}

template <class T>
inline void write(T x) {
    if (x < 0) {
        putchar('-');
        x = -x;
    }
    T y = 1;
    int len = 1;
    for (; y <= x / 10; y *= 10) ++len;
    for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);
}

const int MAXN = 5;
const int dx[8] = { -2, -1, 2, 1, 2, 1, -1, -2 };
const int dy[8] = { 1, 2, 1, 2, -1, -2, -2, -1 };
const int goal[MAXN + 1][MAXN + 1] = { //目标矩阵，空位标记为 -1 
{ 0, 0, 0, 0, 0, 0 }, 
{ 0, 1, 1, 1, 1, 1 }, 
{ 0, 0, 1, 1, 1, 1 }, 
{ 0, 0, 0, -1, 1, 1 }, 
{ 0, 0, 0, 0, 0, 1 }, 
{ 0, 0, 0, 0, 0, 0 } 
};
int t, sx, sy, a[MAXN + 5][MAXN + 5];
bool sol;

inline int h() {//最完美估价
    int cnt = 0;
    for (int i = 1; i <= 5; ++i)
        for (int j = 1; j <= 5; ++j)
            cnt += a[i][j] != goal[i][j];
    //我们统计了当前状态与目标状态不同的位置个数为 cnt，
    //但是我们实际要统计的是不在自己位置上的马的个数，
    //这里我们把空位也算了进去，若所有马都在自己位置上，
    //则此时空位也一定在自己的位置上，由此可得，
    //空位对结果没有影响，所以最后 cnt 要 -1 
    return cnt - 1;
}

void dfs(int x, int y, int g, int f, int prex, int prey) {
    if (sol || x < 1 || x > 5 || y < 1 || y > 5 || g + h() > f) return;
    if (h() == -1) {//若最完美估价为 -1，说明当前状态与目标状态重合 
        sol = 1;//标记为有解 
        return;
    }
    for (int i = 0; i < 8; ++i) {
        int tx = x + dx[i], ty = y + dy[i];
        if (tx == prex && ty == prey) continue;//保证下一步不与上一步相同 
        swap(a[x][y], a[tx][ty]);//空格与马交换位置 
        dfs(tx, ty, g + 1, f, x, y);//继续搜，当前步数 +1 
        swap(a[x][y], a[tx][ty]);//回溯 
    }
}

int main() {
    for (read(t); t; --t) {
        for (int i = 1; i <= 5; ++i)
            for (int j = 1; j <= 5; ++j) {
                char c;
                readChar(c);
                if (c == '*') {
                    sx = i, sy = j;//空位位置 
                    a[i][j] = -1;//标记为 -1 
                } else a[i][j] = c ^ 48;//字符转成数字 
            }
        int ans = -1;
        for (int i = 0; i <= 15; ++i) {//迭代加深（规定深度搜索） 
            sol = 0;
            dfs(sx, sy, 0, i, 0, 0);
            if (sol) {
                ans = i;//深度为 i 时有解
                break;
            }
        }
        write(ans);
        putchar('\n');
    }
    return 0;
}
```


---

## 作者：封禁用户 (赞：3)

这题没写A\*，结果莫名其妙的17ms过了......

大概是冰砖太快的缘故吧......

我写了纯DFS，注意几个细节

1.用一个变量y存储当前还有几个骑士没有到达应到达的地方，当y=0时输出

2.显然每次移动最多只会有一个骑士到达目的地，所以当x+y>15时可以直接return；

为防止DFS进行不需要的操作，可以用迭代加深来进行优化

我用了last进行优化，防止两次操作返回原处

    

```cpp
#include<iostream>
#include<cstdio>
using namespace std; 
char c[6][6];
string mb[6];
bool judge(int x,int y)
{
    if(x<1||x>5)return false;
    if(y<1||y>5)return false;
    return true;    
}
void print()//调试用，可无视
{
    for(int i=1;i<=5;i++)
    {
        for(int j=1;j<=5;j++)cout<<c[i][j];
        cout<<endl;
    }
    cout<<endl;
}
void swap(char &c1,char &c2)
{
    char c3=c1;c1=c2;c2=c3;
}
int i,j,k,m,n,ans;
void trys(int x,int y,int px,int py,int last)//x是当前搜索层数，y是剩余多少骑士未到达,pxpy是*的位置,last是上层搜索操作
{
    if(x+y>j)return;//剪枝
    if(ans>0)return;//出解后不必继续搜索
    if(y==0)
    {
        ans=x;//print();
        return;
    }
    if(judge(px+2,py+1)&&last!=4)
    {
        int yy=y+(c[px+2][py+1]==mb[px+2][py+1]);
        yy-=(c[px+2][py+1]==mb[px][py]);
        swap(c[px+2][py+1],c[px][py]);
        trys(x+1,yy,px+2,py+1,1);
        swap(c[px+2][py+1],c[px][py]);
    }
    if(judge(px+2,py-1)&&last!=3)
    {
        int yy=y+(c[px+2][py-1]==mb[px+2][py-1]);
        yy-=(c[px+2][py-1]==mb[px][py]);
        swap(c[px+2][py-1],c[px][py]);
        trys(x+1,yy,px+2,py-1,2);
        swap(c[px+2][py-1],c[px][py]);
    }
    if(judge(px-2,py+1)&&last!=2)
    {
        int yy=y+(c[px-2][py+1]==mb[px-2][py+1]);
        yy-=(c[px-2][py+1]==mb[px][py]);
        swap(c[px-2][py+1],c[px][py]);
        trys(x+1,yy,px-2,py+1,3);
        swap(c[px-2][py+1],c[px][py]);
    }
    if(judge(px-2,py-1)&&last!=1)
    {
        int yy=y+(c[px-2][py-1]==mb[px-2][py-1]);
        yy-=(c[px-2][py-1]==mb[px][py]);
        swap(c[px-2][py-1],c[px][py]);
        trys(x+1,yy,px-2,py-1,4);
        swap(c[px-2][py-1],c[px][py]);
    }
    if(judge(px+1,py+2)&&last!=8)
    {
        int yy=y+(c[px+1][py+2]==mb[px+1][py+2]);
        yy-=(c[px+1][py+2]==mb[px][py]);
        swap(c[px+1][py+2],c[px][py]);
        trys(x+1,yy,px+1,py+2,5);
        swap(c[px+1][py+2],c[px][py]);
    }
    if(judge(px+1,py-2)&&last!=7)
    {
        int yy=y+(c[px+1][py-2]==mb[px+1][py-2]);
        yy-=(c[px+1][py-2]==mb[px][py]);
        swap(c[px+1][py-2],c[px][py]);
        trys(x+1,yy,px+1,py-2,6);
        swap(c[px+1][py-2],c[px][py]);
    }
    if(judge(px-1,py+2)&&last!=6)
    {
        int yy=y+(c[px-1][py+2]==mb[px-1][py+2]);
        yy-=(c[px-1][py+2]==mb[px][py]);
        swap(c[px-1][py+2],c[px][py]);
        trys(x+1,yy,px-1,py+2,7);
        swap(c[px-1][py+2],c[px][py]);
    }
    if(judge(px-1,py-2)&&last!=5)
    {
        int yy=y+(c[px-1][py-2]==mb[px-1][py-2]);
        yy-=(c[px-1][py-2]==mb[px][py]);
        swap(c[px-1][py-2],c[px][py]);
        trys(x+1,yy,px-1,py-2,8);
        swap(c[px-1][py-2],c[px][py]);
    }
}
int main()
{
    mb[1]="011111";
    mb[2]="001111";
    mb[3]="000*11";
    mb[4]="000001";
    mb[5]="000000";
    //mb是目标状态
    int t;scanf("%d",&t);
    while(t--)
    {
        k=0;
        for(i=1;i<=5;i++)
        for(j=1;j<=5;j++)
        cin>>c[i][j];
        for(i=1;i<=5;i++)
        for(j=1;j<=5;j++)
        if(c[i][j]!=mb[i][j]&&c[i][j]!='*')k++;//k是有多少骑士不在目的地
        int px,py;
        for(i=1;i<=5;i++)
        for(j=1;j<=5;j++)
        if(c[i][j]=='*')px=i,py=j;
        ans=0;
        for(j=k;j<=15&&ans==0;j++)//迭代加深
        trys(0,k,px,py,0);
        if(ans>0)
        printf("%d\n",ans);
        else 
        printf("%d\n",-1);
    }
}
```

---

## 作者：TimWYZ (赞：2)

# 发一篇简单的启发式广搜题解造福人类
~~主要是懒得写迭代加深和双向广搜~~

 首先说一下启发式广搜
 	
 	我们需要一个优先队列，每次弹出当前步数+估价值最小的点
    
    然后每次对这个点进行扩展，注意的是需要进行方向判重，不能走回它的上一个状态（具体方法在程序里）
    
    最后，如果一个点与标准状态一致，那么我们直接输出它的步数
    
 	但是如果它的步数+估价值已经超过了15，我们就输出-1
    
    个人认为比迭代加深好理解，但是比较慢
    
```cpp
//Copyright ©️ 2017-2019 Yuyi Inc. All rights reserved. Writer: TimMc Luogu P2324 Solution
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <iostream>
#include <queue>
using namespace std;

const int standard[6][6] = { //标准
	{0, 0, 0, 0, 0, 0},
	{0, 1, 1, 1, 1, 1},
	{0, 0, 1, 1, 1, 1},
	{0, 0, 0, 2, 1, 1},
	{0, 0, 0, 0, 0, 1},
	{0, 0, 0, 0, 0, 0},
};
const int delta[8][2] = {{2, 1}, {-2, -1}, {1, 2}, {-1, -2}, {2, -1}, {-2, 1}, {1, -2}, {-1, 2}};
//八向偏移数组，特别地把两个相反的方向写在临近的位置上，这样每个方向相反的方向就是它的编号^1。例如(0,1),(4,5)
int T;
struct Node{
	int d, h, dir, zx, zy, num[6][6]; //d代表步数，h代表估价值，dir代表上一方向，zx、zy代表空的坐标。num代表当前状态
	Node() {
		d = h = 0;
		dir = -1; //初始的没有上一方向
	}
	bool operator < (const Node &x) const {
		return d + h > x.d + x.h; //重定义运算符使得优先队列每次弹出d+h最小的
	}
};

int judge(Node &x) { //估价函数
	int ret = 0;
	for (int i = 1; i <= 5; i++)
		for (int j = 1; j <= 5; j++)
			if (x.num[i][j] != standard[i][j]) ret++; //计算标准和现在差了多少
	return ret;
}

bool ok(int x, int y) {
	if (x < 1 || y < 1 || x > 5 || y > 5) return 0; //判断一个坐标(x,y)是否越界
	return 1;
}

int main()
{
	freopen("luogu.in", "r", stdin);
	freopen("luogu.out", "w", stdout);

	cin >> T;
	while (T--) {
		Node st;
		priority_queue <Node> q; //注意在每组数据晴空优先队列
		for (int i = 1; i <= 5; i++)
			for (int j = 1; j <= 5; j++) {
				char c;
				cin >> c;
				if (c == '0') st.num[i][j] = 0; //0代表白，1代表黑，2代表空位
				else if (c == '1') st.num[i][j] = 1;
				else if (c == '*') {
					st.num[i][j] = 2;
					st.zx = i;
					st.zy = j;
				}
			}
		q.push(st);
		while (!q.empty()) {
			Node now = q.top();
			q.pop();
			
			if (now.d > 15) { //每次弹出的一定是d+h最小的，既然他的d都超过15了，那他后边的一定也超过15了，所以直接判断-1
				cout << -1 << endl;
				break;
			}
			if (!judge(now)) { //judge也可当做判断两个状态是否相等的函数
				cout << now.d << endl;
				break;
			}

			for (int i = 0; i < 8; i++) {
				if (i == now.dir) continue; //不能走上一方向
				Node tmp = now;
				tmp.zx += delta[i][0], tmp.zy += delta[i][1]; //偏移
				if (ok(tmp.zx, tmp.zy)) { //判断越界
					tmp.d++;
					tmp.dir = i ^ 1; //记录上一方向
					swap(tmp.num[now.zx][now.zy], tmp.num[tmp.zx][tmp.zy]); //走空位而非走马
					tmp.h = judge(tmp); //计算估价值
					q.push(tmp); //入队
				}
			}
		}
	}
	return 0;
}
```


 	

---

## 作者：zzr8178541919 (赞：2)

一道很好的练习搜索的题目

可以用到A*和迭代加深的搜索算法。发现用了A_star后的代码，运行效率确实优化了很多

解释都在代码中。
```
//一道很好的A*的模板题：骑士精神

//所谓的估价函数也可以理解为一种最坏或最优的情况。
//也就是在当前搜索的基础上，如果当前的答案加上最好的情况
//都达不到要求，那么就可以跳过。
//其实我觉得估价函数也可以看做剪枝的一种 
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
inline int read()//快速读入
{
	int x=0;
	int f=1;
	char ch=getchar();
	while(ch<'0' || ch>'9')
	{
		if(ch=='-')
		f=-1;
		ch=getchar();
	}
	while(ch>='0' && ch<='9')
	{
		x=x*10+ch-'0';
		ch=getchar();
	}
	return x*f;
}
int mp[15][15];
int flag=0;
int stx;
int sty;
int dx[]={0,1,1,-1,-1,2,2,-2,-2};
int dy[]={0,2,-2,2,-2,1,-1,1,-1};
int goal[7][7]={//将我们的目标状态通过达标的方式打出来。 
    {0,0,0,0,0,0},
    {0,1,1,1,1,1},
    {0,0,1,1,1,1},
    {0,0,0,2,1,1},
    {0,0,0,0,0,1},
    {0,0,0,0,0,0}
}; 
int evaluate()
{
	int cnt=0;
	for(int i=1;i<=5;i++)
	{
		for(int j=1;j<=5;j++)
		{
			if(mp[i][j]!=goal[i][j])
			cnt++;
		}
	} 
	return cnt;//估价函数，也就相当于是最坏情况了。 
}
void A_star(int dep,int x,int y,int maxdep)
{
	if(dep==maxdep)
	{
		if(!evaluate())
		{
			flag=1;			
		}
		return;
	}
	for(int i=1;i<=8;i++)
	{
		int nowx=x+dx[i];
		int nowy=y+dy[i];
		if(nowx<=0 || nowy>5 || nowy<=0 || nowx>5)
		continue;//判断边界 
		swap(mp[x][y],mp[nowx][nowy]);//这里直接用swap交换操作，又快又方便 
		if(dep+evaluate()<=maxdep)
		{
			A_star(dep+1,nowx,nowy,maxdep);
		}
		swap(mp[x][y],mp[nowx][nowy]);//回溯操作。
		//这样能保证所有的状态都能查询到 
	}
}
int main()
{
	int T;
	T=read();
	while(T--)
	{
		flag=0;
		for(int i=1;i<=5;i++)
		{
			for(int j=1;j<=5;j++)
			{
				char ch;
				cin>>ch;
				if(ch=='*')
				{
					mp[i][j]=2;
			    	stx=i;
			    	sty=j;
				}
				else
				mp[i][j]=ch-'0';
			}//把字符转成数字，同时记录起点的坐标 
		}
		if(!evaluate())
		{
			printf("0\n");//特判 
			continue;//如果一开始就搜索正确，那么直接输出答案 
		}
		for(int i=1;i<=15;i++)
		{//这里有可能是个迭代加深的过程，就是在判断当前深度是否可行
		//从而提高了代码的运行速率 
		//真是个好方法 
			A_star(0,stx,sty,i);//按照最大的深度限制就搜索一下 
			if(flag==1)//如果搜索成功就输出答案。 
			{
				printf("%d\n",i);
				break;
			}
		}
		if(flag==0)//搜索不成功就输出-1； 
		printf("-1\n");
	}
	return 0;
} 
```


---

## 作者：syksykCCC (赞：2)

### IDDFS 迭代加深搜索 !!

貌似题解区没人这么写？大家都是A\*,IDA\*,双向BFS啥的，好像还有一位大佬用了二进制？！

orz, orz, orz, orz ……

进入正题

### IDDFS是神马？

在DFS的基础上限制了搜索树的深度，保证第一次搜到的即为最优解，是DFS与BFS的折中,一般用于DFS超时，BFS超空间的情况下，保证搜索树最浅

大概长这样：

```cpp
void iddfs(int u, int d)
{
    if (d < 0) //到达指定深度
        return;
    work(u);
    for (u, v) in edges //枚举每条边
        dfs(v, d - 1);
}
main():
for(int d = 1; d <= MAX_DEPTH; d++)// MAX_DEPTH限制搜索树深度
    iddfs(root, d);
```
这里会涉及到重复搜索的问题，不过节点数一般是指数级别增加的，所以重复搜索对时间影响并不是很大

### 本题

使用IDDFS限制深度搜索，如果在当前深度方案可行，就跳出输出答案

剪枝：当前局面与目标相差棋子数≥剩余步+1 时剪枝（类似于A\*的h()）

结点定义为`*`所在位置的坐标，使用增量数组枚举，因为`马跳到空白位置上`无异于`空白位置移到马的位置上`

正确性显然，吸氧后484ms AC

### Code
```cpp
#include <bits/stdc++.h>
using namespace std;
const char goal[10][10] = { // 目标
    {},
    { ' ', '1', '1', '1', '1', '1' },
    { ' ', '0', '1', '1', '1', '1' },
    { ' ', '0', '0', '*', '1', '1' },
    { ' ', '0', '0', '0', '0', '1' },
    { ' ', '0', '0', '0', '0', '0' } 
};
const int dx[8] = { 1, 1, 2, 2, -1, -1, -2, -2 }; //增量数组
const int dy[8] = { 2, -2, 1, -1, 2, -2, 1, -1 };
char now[10][10], bx, by; // now为当前局面，bx，by为初始时空白位置的横纵坐标
bool ok;
inline int need() // 判断当前局面和目标局面的差距 
{
    int res = 0;
    for (int i = 1; i <= 5; i++)
        for (int j = 1; j <= 5; j++)
            if (now[i][j] != goal[i][j])
                res++;
    return res;
}
inline void iddfs(int p, int q, int d) // IDDFS
{
    if (d <= 0) // 到达
	{
        if (!need()) // 找到答案
            ok = true; // 标记
        return;
    }
    for (int i = 0; i < 8; i++)  // 增量枚举
	{
        int tx = p + dx[i];
        int ty = q + dy[i];
        if (tx >= 1 && tx <= 5 && ty >= 1 && ty <= 5) // 在地图中 
		{
            swap(now[tx][ty], now[p][q]);
            if (need() <= d + 1) // 剪枝
                iddfs(tx, ty, d - 1);
            swap(now[tx][ty], now[p][q]); // 回溯
        }
    }
}
int main() 
{
    int T;
    scanf("%d", &T);
    while (T--) 
	{
        for (int i = 1; i <= 5; i++) 
		{
            scanf("%s", now[i] + 1);
            for (int j = 1; j <= 5; j++) 
			{
                if (now[i][j] == '*') // 找初始时的空白位置
				{
                    bx = i;
                    by = j;
                    break;
                }
            }
        }
        ok = false;
        for (int maxd = 0; maxd <= 15; maxd++) 
		{
            iddfs(bx, by, maxd);
            if (ok) 
			{
                printf("%d\n", maxd);
                break;
            }
        }
        if (!ok)
            puts("-1");
    }
    return 0;
}
```

---

## 作者：miaowey (赞：2)

大家都是写的迭代加深的A\*算法，好厉害啊。。。

并没有想到Ａ\*, 因为只有１５步，又有目标状态和初始状态，所以想到双向ＢＦＳ，

比各位大神的Ａ\*应该慢一些，但是可以过。

下面是双向ＢＦＳ的代码
















        
        
            





        


```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<iostream>
#include<algorithm>
#include<map>
#include<queue>
using namespace std;
#define LL long long
#define pb push_back
#define Set(a, v) memset(a, v, sizeof(a))
#define For(i, a, b) for(int i = (a); i <= (int)(b); i++)
#define Forr(i, a, b) for(int i = (a); i >= (int)(b); i--)
#define MAXN 6
#define MAXZT (2000000+5)
#define INF 0x3f3f3f3f
struct node{
    char m[MAXN][MAXN];
    node(int op = 0){
        Set(m, 0);
        if(!op) return;
        int cnt = 5;
        For(i, 1, 5){
            For(j, 0, cnt-1) m[i][5-j] = 1;
            cnt--;
            if(cnt == 3) cnt--;
        }
        m[3][3] = -1;
    }
    bool operator <(const node &rhs)const{
        For(i, 1, 5) For(j, 1, 5)
            if(m[i][j] != rhs.m[i][j]) return m[i][j] < rhs.m[i][j];
        return false;
    }
};
int mn;
map<node, int> ms;
char r[MAXN];
bool fin;
int vis[2][MAXZT], fx[8][2] = {{-2, -1}, {-1, -2}, {1, -2}, {2, -1}, {2, 1}, {1, 2}, {-1, 2}, {-2, 1}};
node end(0);
void init(){
    fin = false;
    Set(vis, 0);
    ms.clear(); mn = 0;
}
int ID(node tmp){
    if(!ms.count(tmp)) ms[tmp] = ++mn;
    return ms[tmp];
}
bool check(int x, int y){
    if(x <= 0 || y <= 0 || x > 5 || y > 5) return false;
    return true;
}
inline void bfs(node st, bool g){
    queue<node> q;
    queue<int> D;
    q.push(st); D.push(0);
    vis[g][ID(st)] = true;
    int ans = INF;
    while(!q.empty()){
        node now = q.front(); q.pop();
        int num = ID(now), dep = D.front(); D.pop();
        if(!g && num == ID(end)){
            fin = true; printf("%d\n", dep);
            return;
        }
        if(g && vis[0][num]) ans = min(ans, vis[0][num]+dep);
        int ex, ey, nex, ney, nnum;
        For(i, 1, 5) For(j, 1, 5)
            if(now.m[i][j] == -1){ex = i; ey = j; break;}
        node next = now;
        For(i, 0, 7){
            nex = ex+fx[i][0], ney = ey+fx[i][1];
            if(!check(nex, ney)) continue;
            swap(next.m[nex][ney], next.m[ex][ey]);
            nnum = ID(next);
            if(vis[g][nnum]){
                swap(next.m[nex][ney], next.m[ex][ey]);
                continue;
            }
            vis[g][nnum] = g? true: dep+1;
            if(dep < 8){
                q.push(next); D.push(dep+1);
            }
            swap(next.m[nex][ney], next.m[ex][ey]);
        }
    }
    if(!g) return;
    if(ans > 15) printf("-1\n");
    else printf("%d\n", ans);
}
int main(){
    int T;
    scanf("%d", &T);
    while(T--){
        init();
        node begin(1);
        For(i, 1, 5){
            scanf("%s", r+1);
            For(j, 1, 5)
                if(r[j] != '*') end.m[i][j] = r[j]-'0';
                else end.m[i][j] = -1;
        }
        fin = false;
        bfs(begin, 0);
        if(fin) continue;
        bfs(end, 1);
    }
    return 0;
}
```

---

## 作者：ez_lcw (赞：1)

我们先考虑最纯粹的暴力，也就是暴力枚举每次空格调到哪里，并继续递归求解。

然后发现 $O(8^{15}\times5\times5)$ 的复杂度限制了我们的想象。~~同学写了一发好像10分~~

然后既然找不到其它的太好的新算法 ~~我没说剪枝不能过~~，我们就考虑如何优化暴力。

首先，我们考虑用$IDA^*$（启发式迭代加深）来优化这个暴力。

它应该是 $A^*$ 的进阶版。

1. 我们对于现在递归到的棋盘的某种状态，计算它的估价函数 $value()$，也就是**从当前棋盘状态变为目标棋盘状态的估计步数**。

	当然，如果你要保证找到最优解，**这个 $value()$ 必须小于等于真实的步数**，也就是说：如果你的估价函数返回值为$val$，那么你要保证从当前棋盘状态变为目标棋盘状态的真实最优步数至少为 $val$。

	而且，你**这个估价函数 $value()$ 在上面的条件下，还要尽量大**，因为如果估价函数太小，那就和朴素的暴力差不多。

	所以，对于本题的估价函数 $value()$，我们估计最优解是什么。那么显然，如果当前棋盘现在有 $x$ 个白棋不在白棋的位置上，有 $y$ 个黑棋不在黑棋的位置上，由于我们每次操作是交换空格和某个棋子，所以至少需要 $x+y$ 步才能变为目标棋盘，所以我们把估价函数的返回值设为 $x+y$ 。但显然，由于空格能跳跃的位置有限制，真实的最优解可能会大于我们估计的这个最优解。

	不知道有没有更好的估价函数，~~但是这种方法能过我就懒得想了~~

2. 我们可以考虑对原来的暴力限制最大递归步数 $maxdep$ ，那么**当你的步数超过了 $maxdep$ 或者你当前的步数加上估价函数 $value()$ 的估价步数超过了 $maxdep$，我们就$return$（因为估价步数肯定小于等于真实步数）。**

	然后我们从 $1$ 到 $15$ 枚举 $maxdep$，每次进行递归。

	为什么能更快？因为可能的确有一种方法能在$14$步变为目标棋盘，但还有一种方法$2$步就可以变为目标棋盘了。而由于暴力时遍历顺序的原因，我们可能很晚才会遍历到$2$步的方案。所以我们考虑枚举最大步数，进行优化。

所以最后的完整代码如下：

```cpp
#include<bits/stdc++.h>

using namespace std;

int t,stx,sty,a[5][5],ans[5][5]={{1,1,1,1,1},{0,1,1,1,1},{0,0,2,1,1},{0,0,0,0,1},{0,0,0,0,0}};
int fx[]={-2,-1,1,2,2,1,-1,-2},fy[]={1,2,2,1,-1,-2,-2,-1};

int value()//估价函数
{
	int cnt=0;
	for(int i=0;i<5;i++)
		for(int j=0;j<5;j++)
			if(a[i][j]!=ans[i][j])
				cnt++;
	return cnt;
}

bool Astar(int dep,int x,int y,int maxdep)
{
	if(dep==maxdep)
	{
		if(!value()) return true;
		return false;
	}
	for(int i=0;i<8;i++)
	{
		int xx=x+fx[i],yy=y+fy[i];
		if(xx<0||xx>4||yy<0||yy>4) continue;
		swap(a[x][y],a[xx][yy]);
		int val=value();
		if(dep+val<=maxdep)
			if(Astar(dep+1,xx,yy,maxdep))//如果找到方案就直接返回，这样会省去一些时间
				return true;
		swap(a[x][y],a[xx][yy]);
	}
	return false;
}

int main()
{
	scanf("%d",&t);
	while(t--)
	{
		for(int i=0;i<5;i++)
		{
			for(int j=0;j<5;j++)
			{
				char ch=getchar();
				while(ch!='0'&&ch!='1'&&ch!='*')ch=getchar();
				if(ch=='*')
				{
					a[i][j]=2;
					stx=i,sty=j;
				}
				else a[i][j]=ch-'0';
			}
		}
		for(int maxdep=0;maxdep<=15;maxdep++)//枚举maxdep
		{
			if(Astar(0,stx,sty,maxdep))
			{
				printf("%d\n",maxdep);
				goto end;
			}
		}
		puts("-1");
		end:;
	}
	return 0;
}
```

最后来自蒟蒻的一个小小的想法（疑问）：

既然 $maxdep=3$ 的情况我们在 $maxdep=4$ 的时候都会遍历到，但是我们在 $maxdep=3$ 的时候又遍历过了，那么我们可不可以通过某种方式剪掉这些部分呢？（其实也优化不了多少，顶多把原来的 $O(k)$ 优化成了 $O(\frac{k}{25})$，$k$ 是多少我也不知道，毕竟 $A^*$的时间复杂度本来就很玄学）

---

## 作者：盧鋅 (赞：1)

## 题解好多~~IDA*~~，作为**蒟蒻**，我来个最朴素的双向BFS。

#### 首先要说的肯定是状态，那么状态该怎么表示呢？？作为**蒟蒻**我选择用char数组。很明显状态很难转移了!!这时候肯定要用到Hash了。
先放下Hash的编码和解码。
```cpp
long long inhash()
{
	long long ans=0;
	for(int i=1;i<=5;i++)
	for(int j=1;j<=5;j++)
	{
		if(b[i][j]=='1')ans+=pow(3,j+(i-1)*5);
		if(b[i][j]=='*')ans+=2*pow(3,j+(i-1)*5);
	}
	return ans;
 } 
```
```cpp
void outhash(long long k,int &x,int &y)
 {
 	k/=3;
 	for(int i=1;i<=5;i++)
	for(int j=1;j<=5;j++) 
 	{
	    long long u=k%3;
 		if(u==0)a[i][j]='0';
 		if(u==1)a[i][j]='1';
 		if(u==2)
		 {
		 a[i][j]='*';
		 x=i;y=j;	
		 }
		k/=3;
	 }
	 return;
 }
```
显而易见，这是一个很适合我这种**蒟蒻**的写法，编码直接转3进制，解码同理，使用快速幂（pow函数是快速幂，不是库中的pow（））不打表的确是一种很不明智的做法，但是这样写代码会简单点（就是懒）。
```cpp
long long pow(ll a,ll b)
{
	if(b==0)return 1;
	if(b==1)return a;
	ll c=pow(a,b/2);
	if(b%2==0)return c*c;
	else return c*c*a; 
}
```
快速幂，因为longlong不会爆，不%。

**然后说下全局变量的定义**
```cpp
long long rrrrr=3509192766;
char a[6][6],b[6][6];
const int dx[]={-2,-2,-1,-1,1,1,2,2};
const int dy[]={1,-1,2,-2,2,-2,1,-1};
queue<long long>q[2];
int ans,n,rx=0; 
int dis[2][inf],v[2][inf];//inf已宏定义,埋个伏笔。
```
rrrrr是目标棋盘的hash值；char a[][],b[][]两个数组来暂时储存状态；dx[],dy[]枚举马的移动方式；开两个队列q[2]用来存储状态；dis[2][]用来存储hash对应的距离，vis[2][]用来存储搜索情况；ans用来记录结果的步数，rx来判定15步的上界，n没什么可说的。

因为多组数据同时判定所以我们要先初始化一下。（大概就是这个样子）
```cpp
        while(q[1].size())q[1].pop();
	while(q[0].size())q[0].pop();
	memset(a,0,sizeof(a));
	memset(b,0,sizeof(b));
	memset(v,0,sizeof(v));
	memset(dis,0,sizeof(dis));
```
然后a[][],b[][]之前是要复制的，所以我们写一个copy函数（作为一个**蒟蒻**的做法）
```
 void copy()
 {
 	for(int i=1;i<=5;i++)
	for(int j=1;j<=5;j++)
	b[i][j]=a[i][j]; 
 }
```
#### 最后就是BFS了。
先看下拓展队列的函数。
```cpp
int expand(int k)
 {
 	rx++;
 	int t,i,j,x,y,tx,ty,d;
 	memset(b,0,sizeof(b));
 	long long mm=q[k].front();q[k].pop();
 	outhash(mm,x,y);
 	d=dis[k][mm%inf];
 	for(int i=0;i<=8;i++)
 	{
 		tx=x+dx[i];ty=y+dy[i];
 		if(tx<1||ty<1||tx>5||ty>5)continue;
 		copy();
 		swap(b[x][y],b[tx][ty]);
 		long long m=inhash();
		 if(v[k][m%inf]){
		 	swap(b[x][y],b[tx][ty]);
		 	continue;
		 } 
		 v[k][m%inf]=1;
		 q[k].push(m);
		 dis[k][m%inf]=d+1;
		 if(v[1-k][m%inf])
		 {
		 	ans=dis[k][m%inf]+dis[1-k][m%inf];
		 	return 1;
		 }
	 }
	 return 0;
 }
```
其实和单向的BFS没什么区别，就是多了判定另一个方向是否遍历过这一步(if(v[1-k][m%inf]))。

然后是BFS函数
```cpp
void BFS()
 {
 	long long r=inhash();
 	if(r==rrrrr){ans=-1;return;}
 	v[0][r%inf]=1;
 	v[1][rrrrr%inf]=1;
 	while(q[1].size()&&q[0].size()&&rx<15)
 	{
 		if(q[0].size()<q[1].size())if(expand(0))return;
 		if(q[0].size()>=q[1].size())if(expand(1))return;
	 }
	 return; 
 }
```
先特判一下，然后对**队列元素少**的进行拓展。

## **最后放下代码**
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<queue>
#define ll long long
#define inf (自己取) 
using namespace std;
long long pow(ll a,ll b)
void init()
{
	while(q[1].size())q[1].pop();
	while(q[0].size())q[0].pop();
	memset(a,0,sizeof(a));
	memset(b,0,sizeof(b));
	memset(v,0,sizeof(v));
	memset(dis,0,sizeof(dis));
	for(int i=1;i<=5;i++)
	for(int j=1;j<=5;j++)
	cin>>b[i][j];
}
long long inhash()
 void outhash(long long k,int &x,int &y)
 void copy()
 int expand(int k)
 void BFS()
int main()
{
	ios::sync_with_stdio(false);
	cin>>n;
	while(n--)
	{
		init();
		ans=-1;
		q[0].push(inhash());
		q[1].push(rrrrr);
		BFS();
		cout<<ans<<endl;
	}
	return 0;
}
```
函数的代码前面已给出，这里就不赘述了。

#### ~~但是请注意inf是要自己取的,这也就是埋下的伏笔。~~
~~1.inf不能取太大，不然会MLE；                         2.inf要取**特殊**的值，不然会hash冲突，然后WA；
3.inf肯定不是会很容易找到的，这时候可以选择一些避免hash冲突的方法，比如双hash，或者挂链。~~

作为一个蒟蒻写题解不易，求通过。祝大家国庆假期RP++。

---

## 作者：MrBlack (赞：1)

使用堆优化的a_star来做这道题

每次将f=g+h最小的点进行拓展，能优先找到可能的最短步数Min，然后用更新的Min来限制搜索范围，能节省一定时间

这里g是已走过的路程，h是还没有归位的棋子数。由于最后一步能一次归位两个棋子（棋子加空格），所以要f<=Min+1

给出代码如下：

```cpp
#include<iostream>
#include<queue>
#include<string>
using namespace std;

struct pos
{
	int x, y;
	pos operator+(pos& a)
	{
		pos t;
		t.x = x + a.x;
		t.y = y + a.y;
		return t;
	}
};
int map[5][5];
int Min = 16;  //最少步数初始化为16步
pos space;  //空格的位置
int Count;  //不符合位置的个数
int des[5][5] =
{
	{1,1,1,1,1},
	{0,1,1,1,1},
	{0,0,-1,1,1},
	{0,0,0,0,1},
	{0,0,0,0,0}
};

pos p[8] =
{
	{-2,1},{-2,-1},
	{2,1},{2,-1},
	{1,-2},{1,2},
	{-1,2},{-1,-2}
};

struct node
{
	pos p;  //该点的位置
	int g;  //已走的步数
	int h;  //还有几个点没有归位，即预估还要走的步数
	bool operator<(node a) const
	{
		if (g + h == a.g + a.h)
		{
			return g < a.g;
		}
		return g + h > a.g + a.h;
	}
};

int a_star(int g,int h,pos pp)  //当前步数，预估步数和空格位置
{
	if (h == 0)  //全部归位
	{
		return Min = g;
	}
	int flag = -1;  //-1表示拓展失败
	priority_queue<node> q;
	node n, t;
	n.g = g;
	n.h = h;
	n.p = pp;
	for (int i = 0; i < 8; i++)  //八个方向拓展
	{
		t.p = n.p + p[i];
		if (t.p.x < 0 || t.p.x>4 || t.p.y < 0 || t.p.y>4)  //超出地图
		{
			continue;
		}
		int add = 0;  //移动后不归位棋子的变化数
		if (map[n.p.x][n.p.y] == des[n.p.x][n.p.y])  //空格点原来是不是归位了
		{
			add++;
		}
		if (map[t.p.x][t.p.y] == des[t.p.x][t.p.y])  //移动到的点原来是不是归位了
		{
			add++;
		}
		if (map[n.p.x][n.p.y] == des[t.p.x][t.p.y])  //空格点现在是不是归位了
		{
			add--;
		}
		if (map[t.p.x][t.p.y] == des[n.p.x][n.p.y])  //移动到的点现在是不是归位了
		{
			add--;
		}
		if (n.g + 1 + n.h + add >= Min + 1)  
			//预估超出最短步数，是重要的剪枝
		{
			continue;
		}
		t.g = n.g + 1;
		t.h = n.h + add;
		q.push(t);  //满足条件的移动入堆
	}
	while (!q.empty())  //堆不空
	{
		n = q.top(), q.pop();  //取出头结点进行拓展
		if (n.g + n.h <= Min && n.g < Min)  //已走过的步数比最少步数少
		{
			swap(map[pp.x][pp.y], map[n.p.x][n.p.y]);  //改变地图
			if (a_star(n.g, n.h, n.p) != -1)  //拓展成功
			{
				flag = 0;
			}
			swap(map[n.p.x][n.p.y], map[pp.x][pp.y]);  //改回地图
		}
	}
	return flag;
}

int main()
{
	int T;
	cin >> T;
	string s;
	while (T > 0)
	{
		Count = 0;
		for (int i = 0; i < 5; i++)
		{
			cin >> s;
			for (int j = 0; j < 5; j++)
			{
				if (s[j] == '*')
				{
					map[i][j] = -1;
					space.x = i, space.y = j;
				}
				else
				{
					map[i][j] = s[j] - '0';
				}
				if (map[i][j] != des[i][j])  //找到不匹配棋子的个数
				{
					Count++;
				}
			}
		}
		if (Count == 0)
		{
			cout << 0 << endl;
		}
		else if (Count > 16)
		{
			cout << -1 << endl;
		}
		else
		{
			int t = a_star(0, Count, space);
			if (t == -1)
			{
				cout << -1 << endl;
			}
			else
			{
				cout << Min << endl;
			}
			Min = 16;  //重置最短步数
		}
		T--;
	}
	return 0;
}
```

---

## 作者：Right (赞：1)

一道A\*算法题

大体就不多说了

不过，我这里有一些优化

比如最开始的目标数组

```cpp
void clears()
{
    int i,j;
    for (i=1; i<=5; ++i)
    {
        for (j=1; j<=5; ++j)
        {
            if ((j-i>=0 && i<=3) || (j-i>0 && i>3))
              getr[i][j]=1;
             else 
              getr[i][j]=0; 
            //printf("%d",getr[i][j]);   
        }
        //cout<<endl;
    }
    getr[3][3]=2;
}
```
有了这样的过程，就不用再打表了
再者，如果每次换map数组，可以少开一个数组，节省空间

>上代码，思路其中：
    
                 
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
int map[6][6];
int getr[6][6]; 目标
int dx[8]={1,2,2,1,-1,-2,-2,-1};
int dy[8]={-2,-1,1,2,2,1,-1,-2};
int T,ans;
int lit=15;
bool bz;  优化用的
void clears()  开始的
{
    int i,j;
    for (i=1; i<=5; ++i)
    {
        for (j=1; j<=5; ++j)
        {
            if ((j-i>=0 && i<=3) || (j-i>0 && i>3))
              getr[i][j]=1;
             else 
              getr[i][j]=0; 
            //printf("%d",getr[i][j]);   
        }
        //cout<<endl;
    }
    getr[3][3]=2;
}
int Aj() 启发关键
{
    int cnt=0;
    int i,j;
    for (i=1; i<=5; ++i)
    {
        for (j=1; j<=5; ++j)
        {
            if (getr[i][j]!=map[i][j])
            {
                cnt++;
            }
        }
    }
    return cnt; //计算有多少个与目标不同的点，水A* 没有距离好，but 
}
void dfs(int q, int xn, int yn, int lim)
{
    if (bz) return; //bz!=0
    int t=Aj(); //A* judge
    //cout<<t;
    if (q==lim)
    {
        if (t==0) //完全重合
        {
            ans=lim;
            bz=true;
            return;
        } 
    }
    if (q-1+t>lim) return; //cut off
    int i;
    for (i=0; i<8; ++i)
    {
        int a,b;
        a=xn+dx[i];
        b=yn+dy[i];
        if (a>0 && b>0 && a<6 && b<6)
        {
            int right; 看名字
            right=map[a][b]; map[a][b]=map[xn][yn]; map[xn][yn]=right; //change
            dfs(q+1,a,b,lim);
            right=map[a][b]; map[a][b]=map[xn][yn]; map[xn][yn]=right; 
        }
    }
}
void slove()
{
    memset(map,-1,sizeof(map));
    int i,j;
    int x,y;
    char ch;
    for (i=1; i<=5; ++i)
    {
        for (j=1; j<=5; ++j)
        {
            //scanf("%c",&ch);
            cin>>ch;
            if (ch!='*')
                map[i][j]=ch-'0';
              else 
              {
                  x=i;y=j; //record
                map[i][j]=2; 
              }
            //cout<<map[i][j];    
        }
    }
    if (!Aj()) 
    {
        printf("0\n"); return;  如果重合，直接输出
    }
    int k;
    //cout<<"dfs";
    for (k=1; k<=lit; ++k)
    {
        bz=false; ans=18; //if ans>15 !
        //for (i=1; i<=5; ++i)
        dfs(0,x,y,k);
        if (ans==k) break; //find out answer
    }
    if (ans<=lit)  //很重要，避免无解，我就错过一次了啊！ 
        printf("%d\n",ans);
      else 
        printf("-1\n"); 
}
int main()
{
    int i;
    clears();
    scanf("%d",&T);
    for (i=1; i<=T; ++i)
    {
        slove();
    }
}
```

---

## 作者：infinityedge (赞：1)

A\*迭代加深搜索入门题

枚举步数进行深搜，每次根据已走步数和当前棋盘与标准棋盘差异棋子个数来进行剪枝：if(已走步数+差异个数>目标步数）return;

时间复杂度O（2^步数\*T）；

···
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;
const int sttd[5][5]={{2,2,2,2,2},{1,2,2,2,2},{1,1,0,2,2},{1,1,1,1,2},{1,1,1,1,1}};
const int dx[]={-2,-1,1,2,2,1,-1,-2};
const int dy[]={1,2,2,1,-1,-2,-2,-1};
int T,ans=16,mx;
int mp[7][7],mp2[7][7];
bool b=true;
inline int pd(){//找出差异个数
    int cnt=0;
    for(int i=1;i<=5;i++){
        for(int j=1;j<=5;j++){
            if(mp[i][j]!=sttd[i-1][j-1])cnt++;
        }
    }
    return cnt;
}
inline bool can(int x,int y){//判断移动可行性
    if(x>=1&&x<=5&&y>=1&&y<=5)return true;
    return false;
}
void dfs(int x,int cx,int cy){//迭代加深搜索
    if(x>mx)return;
    int bs=pd();
    if(bs==0){
        ans=min(ans,x);
        b=false;
        return;
    };
    if(!b)return;
    if(bs+x-1>mx)return;
    int a1,b1;
    for(int i=0;i<=7;i++){
        a1=cx+dx[i];
        b1=cy+dy[i];
        if(can(a1,b1)){
            swap(mp[a1][b1],mp[cx][cy]);
            dfs(x+1,a1,b1);
            swap(mp[a1][b1],mp[cx][cy]);
        }
    }
}
int main(){
    scanf("%d",&T);
    while(T--){
        memset(mp,-1,sizeof(mp));
        b=true;
        ans=16;        
        for(int i=1;i<=5;i++){
            char ch[10];scanf("%s",ch);
            for(int j=1;j<=5;j++){
                if(ch[j-1]=='*')mp2[i][j]=0;
                else mp2[i][j]=(ch[j-1]-'0'+1);
            }
        }
        int a,b;
        for(int i=1;i<=5;i++){
            for(int j=1;j<=5;j++){
                if(mp2[i][j]==0){
                    a=i;
                    b=j;
                    break;
                }
            }
        }
        for(mx=1;mx<=15;mx++){
            for(int i=1;i<=5;i++){
                for(int j=1;j<=5;j++){
                    mp[i][j]=mp2[i][j];
                }
            }
            dfs(0,a,b);
            if(ans==mx)break;
            if(!b)break;
        }
        if(ans==16){
            printf("-1\n");
        }else printf("%d\n",ans);    
    }
}
···
```

---

## 作者：Honor誉 (赞：1)


这题是一道比较好的$A*$的模板题，$A*$对dfs的优化一般叫$IDA*$。

首先，$A*$有一个定义式叫做：

$f(n)=g(n)+h(n)$

$f(n)$即为一点的估价函数，$g(n)$是这一点实际所用的步数（价值），$h(n)$是对未来的所需步数（代价）的完美预测（接近完美）。

通过这个定义式，只要有h(n)，每次都可以算出一个点的估价，$A*$算法就是通过限制估价，使得在搜索的时候不要在无意义的道路上浪费时间。即，每次限制每个点的估价$maxdep$，一旦估价超过，就停止搜索。

根据定义式，$h(n)$一定要$<=$实际的所需步数。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191228090428540.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MDE5NDY4,size_16,color_FFFFFF,t_70)
像这张图，如果$h(A)$估大了的话，$f(A)$也会相应变大，这样$f(A)$有可能会被maxdep给去掉，从而找不到正确答案。

所以，为了保证答案的正确性，$h(A)$一定要在$<=$实际的所需步数的前提下尽量的大，也就是尽量估得准。

那回到这题，题目要求在15步以内完成才输出步数，否则-1，所以可以将maxdep从0到15枚举，一旦成功找到，那就是答案（最少步数）。

而最优的就是每一次都将不在相应位置上的棋子移到相应的位置上，所以$h(A)$可以是不匹配的棋子数，因为每次最多还原一个，所以$h(A)$一定是$<=$实际的所需步数，正确性得到保证。

$h(A)$：

```cpp
int value()
{
	int ans=0;
	for(int i=0;i<5;i++)
	{
		for(int j=0;j<5;j++)
		{
			if(standard[i][j]!=tu[i][j])
			{
				ans++;
			}
		}
	}
	return ans;
}
```

然后就是时间的剪枝，题目要的是最少步数，所以肯定不能做回头路，还有就是没有找到完成的路径，满足这两点，加上maxdep的限制，才能继续往下搜。

其他就是一个暴力搜索了，没什么好讲的：

```cpp
#include<bits/stdc++.h>
using namespace std;
int standard[5][5]={{1,1,1,1,1},{0,1,1,1,1},{0,0,-1,1,1},{0,0,0,0,1},{0,0,0,0,0}},tu[5][5],f[8][2]={{-2,-1},{-2,1},{1,2},{1,-2},{-1,2},{-1,-2},{2,-1},{2,1}},is,t,xx,yy;
char ch;
int value()//估价函数
{
	int ans=0;
	for(int i=0;i<5;i++)
	{
		for(int j=0;j<5;j++)
		{
			if(standard[i][j]!=tu[i][j])
			{
				ans++;
			}
		}
	}
	return ans;
}
void dfs(int dep,int x,int y,int maxdep,int lastway)//直接搜
{
	if(dep==maxdep)
	{
		if(!value())
		{
			is=1;
		}
		return;
	}
	for(int i=0;i<8;i++)
	{
		int xx=x+f[i][0];
		int yy=y+f[i][1];
		if(xx<0||xx>4||yy<0||yy>4||7-i==lastway)//不走出格，不走回头路
		{
			continue;
		}
		swap(tu[x][y],tu[xx][yy]);
		if(dep+value()<=maxdep&&!is)//估价函数的限制
		{
			dfs(dep+1,xx,yy,maxdep,i);
		}
		swap(tu[x][y],tu[xx][yy]);
	}
}
int main()
{
	scanf("%d",&t);
	while(t--)
	{
		is=0;
		for(int i=0;i<5;i++)
		{
			for(int j=0;j<5;j++)
			{
				cin>>ch;
				if(ch=='*')
				{
					tu[i][j]=-1;
					xx=i;
					yy=j;
				}else{
					tu[i][j]=ch-'0';
				}
			}
		}
		if(!value())
		{
			puts("0");
			return 0;
		}
		for(int i=1;i<=15;i++)//A*
		{
			dfs(0,xx,yy,i,9);
			if(is)
			{
				printf("%d\n",i);
				break;
			}
		}
		if(!is)//没有
		{
			puts("-1");
		}
	}
	return 0;
}
```





---

## 作者：mdzzzzzzzzzz (赞：1)

我看前面的dalao们写的IDA* 好复杂啊，我想，既然我还没有发过IDA* 的题解，那我就水一篇吧。

### 分析题目

看到这道题，你的心里是不是一下就浮现出了那八个滑块。

其实这都是一道题啦，只不过这是加强版。

他们的共同点就是在走一定步数后最后的状态一定相同。

闭上眼睛想想——相同的结局，一定的步数.....

那这时我们就想到了IDA* 辣！

~~其实我是看了算法标签才知道的但这不重要~~

### IDA* 算法

怎么说呢，作者其实是个小蒟蒻，只会借着板子打IDA* 的题。

所以这里就不讲A* 算法了，具体可以百度一下。

而我们今天要讲的IDA* 是A* 的改进版，主要适用于要计算步数的题目。IDA* 与A* 的区别便在于把A* 的bfs算法改为dfs算法,然后在主函数里面枚举dfs深度,也就是题目中的步数。

而IDA* 优化dfs的方法是什么呢？

没错！就是判断可行性（高级可行性剪枝）

### IDA* 的可行性剪枝

按这道题来说，我们要判断的就是我们在已知的步数内能不能达到我们的目标。

我们把所有点判断一遍，在每次操作之后，没有到指定位置的棋子一定要小于剩下的步数，不然的话，剩余的步数是一定不足以完成骑士的归位的。

举个例子：

```
11011
011*1
01111
00000
00100
```
我们随机生成一个棋盘，可以看到，它与最终的棋盘（如下）

```
11111
01111
00*11
00001
00000
```
不一样的有6个点

```
//o表示相同 x表示不同

ooxoo
oooxo
oxxoo
oooox
ooxoo
```
所以，要复原这个棋盘，在忽略骑士的走棋规则的情况下，也需要6步。

进而我们就可以知道，在每一次操作后，我们判定一下这一步走后我们还有没有可能在主函数中规定的步数复原。

判定方式：

```cpp
int test(int step)//step代表已经走过的步数
{
	int pd=0;//pd代表有几个点不一样
	for(int i=1;i<=5;i++)
	for(int j=1;j<=5;j++)
	if(a[i][j]!=ans[i][j])//如果这个点不同
	if(++pd+step>k)//pd每次加一，k是规定步数，如果不同的点的总数+已走步数>规定步数，那一定完不成了。
	return 0;//不合法
	return 1;//合法
}
```
### dfs的方式（最重要的总要放到最后）

因为IDA* 是A* 的改进版，所以其实就是在dfs的函数中放上bfs的代码，但放在函数中有一个非常大的好处那就是我们可以轻松地在任意的几次操作之间~~反复横跳~~。而且，bfs是没有所谓剪枝的，优化的方法也非常难理解（至少本蒟蒻是这么想的）

所以当你看到下面的代码时，你可能会跳起来：“这不就是bfs吗！”请按捺住这种冲动，不然可能会吓到旁边颓废的同学。

```cpp
int check()
{
	for(int i=1;i<=5;i++)
	for(int j=1;j<=5;j++)
	if(a[i][j]!=ans[i][j])
	return 0;
	return 1;
}
void Astar(int step,int x,int y,int pre)//step指走到哪一步了，x、y指的空位的坐标，pre指的上一步的操作是哪一种
{
	if(step==k)//已经走了规定步数
	{
		if(check())//如果现在棋盘已经复原
		{
			vv=1;//表示找到了
			return;
		}
	}
	for(int i=0;i<8;i++)
	{
		int tx=x+ne[i][0];//下一步的坐标
		int ty=y+ne[i][1];
		if(tx<1||tx>5||ty<1||ty>5||pre+i==7)//一个几乎所有bfs都有的东西（最后一个的作用是防止走上一个操作ps：这个可以体现在定义ne数组的时候）
		continue;
		swap(a[x][y],a[tx][ty]);//操作
		if(test(step)&&!vv)
		{
			Astar(step+1,tx,ty,i);//走下一步
		}
		swap(a[x][y],a[tx][ty]);//回溯
	}
	return;
}
```
然后便是主函数

### 主函数

我懒得讲

## AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int k;
char ch[10];
int a[10][10],x,y,t=0,vv;
int ans[6][6]={{0,0,0,0,0,0},{0,1,1,1,1,1},{0,0,1,1,1,1},{0,0,0,2,1,1},{0,0,0,0,0,1},{0,0,0,0,0,0}};//复原后的棋盘
int ne[8][2]={{1,2},{1,-2},{2,1},{-2,1},{2,-1},{-2,-1},{-1,2},{-1,-2}};//八种走法
map<int,int> mapa;
map<int,int>::iterator iter;
int check()
{
	for(int i=1;i<=5;i++)
	for(int j=1;j<=5;j++)
	if(a[i][j]!=ans[i][j])
	return 0;
	return 1;
}
int test(int step)//step代表已经走过的步数
{
	int pd=0;//pd代表有几个点不一样
	for(int i=1;i<=5;i++)
	for(int j=1;j<=5;j++)
	if(a[i][j]!=ans[i][j])//如果这个点不同
	if(++pd+step>k)//pd每次加一，k是规定步数，如果不同的点的总数+已走步数>规定步数，那一定完不成了。
	return 0;//不合法
	return 1;//合法
}
void Astar(int step,int x,int y,int pre)//step指走到哪一步了，x、y指的空位的坐标，pre指的上一步的操作是哪一种
{
	if(step==k)//已经走了规定步数
	{
		if(check())//如果现在棋盘已经复原
		{
			vv=1;//表示找到了
			return;
		}
	}
	for(int i=0;i<8;i++)
	{
		int tx=x+ne[i][0];//下一步的坐标
		int ty=y+ne[i][1];
		if(tx<1||tx>5||ty<1||ty>5||pre+i==7)//一个几乎所有bfs都有的东西（最后一个的作用是防止走上一个操作ps：这个可以体现在定义ne数组的时候）
		continue;
		swap(a[x][y],a[tx][ty]);//操作
		if(test(step)&&!vv)
		{
			Astar(step+1,tx,ty,i);//走下一步
		}
		swap(a[x][y],a[tx][ty]);//回溯
	}
	return;
}
int main()
{
	int t;
	scanf("%d",&t);
	for(int l=1;l<=t;l++)
	{
		k=0;
		vv=0;
		for(int i=1;i<=5;i++)
		{
			scanf("%s",ch+1);
			for(int j=1;j<=5;j++)
			{
				a[i][j]=ch[j]-'0';
				if(ch[j]=='*')//如果是空位记录为2
				x=i,y=j,a[i][j]=2;
			}
		}
		if(check())//判断特殊情况->不用复原
		{
			printf("0\n");
			break;
		}
		while(++k)//规定走k步
		{
			Astar(0,x,y,-1);
			if(k>15)//超过15步
			{
				printf("-1\n");
				break;
			}
			if(vv)
			{
				printf("%d\n",k);
				break;
			}
		}
	}
	return 0;
}
```
不要直接抄，代码里面有坑，专门藏的（我自己都不信）

# 你已经被警告过了

$\textsf{\color{#8B6914}\small{抄了我代码的你 }\color{white}\scriptsize{\colorbox{#8B6914}{ 作弊者 }}}$

---

## 作者：xmdzz (赞：0)


点开题解,发现里面非常热闹!双向广搜以及A* IDE* 的解法都被提到了.

>启发式搜索有一个重要的步骤就是估值判断,这道题里,5x5的棋盘格不大,判断一遍也就比较25次,所以很多题解也就不存储估值结果,直接减枝+爆搜就可以了.

不过我想试试优化一下,把估值结果保存起来,这样以后如果遇到估值运算量比较大,必须存储估值的题,就可以直接拿来用了, 优化完后在洛谷的测试点时间测试,时间也从1.60s降到了439ms,十分开心,于是就有了这个总结.


下面就是这道题解题过程的详细记录:
#### 抽象成树
国际象棋里马只能走八种方向,所以任何一个格子出现变化的步伐只可能有8种.
我们可以用一个数组保存这八种可能下x和y坐标发生的变化,
```c++
//存储骑士的8个移动位置
int dir[8][2] = { {-2,-1},{-2,1},{-1,-2},{-1,2},{1,-2},{1,2},{2,-1},{2,1} };
...
//求解下一步的坐标
int xb = xa + dir[i][0];
int yb = ya + dir[i][1];
```

每走一步都是基于上一步的值得到的,这存在一个递推关系,而如果走完发现不是自己想要的,就要回归;看到递归,就可以想到树这种数据结构,每一步走完有八个可能的方向,我们就可以用八叉树来模拟.

树这种数据结构有很多种存储方式,比较标准的有顺序结构的双亲表示法,孩子表示法,双亲孩子表示法以及各种链式结构.各种讲数据结构的书里都会讲到,给出比较标准的写法.但是具体使用的时候一般是很随心所欲的,可以根据自己的需要改造.

因为顺序结构的随机存取比较方便,所以选择了顺序存储,又因为事前不知道开辟多少个结点,所以采用了STL里面vector来实现动态数组的创建,存多少用多少.虽然vector有不少需要注意的小坑,但注意避免一下,用起来还是很方便的.
```c++
//辅助用的八叉树
//结点结构体
typedef struct CHNode{
       int m;//结点在vector里面的下标
       int eva;//孩子结点的估值;
       int st;//状态码
}CHNode;

typedef struct OTNode
{
       int fm;//父结点在vector里的下标
       int xt, yt;
       CHNode child[8];//8个孩子结点
}OTNode;


//vector下标指针,从1开始,0存根结点,xy值是空格的起始处
//每次push,pnode就加1;
int pnode = 1;
//存储结点的数组,vector变长数组,用多少开多少
vector<OTNode> v;
```

#### 只移动白格子

树已经有啦!但是先移动哪个马呢?24匹马,想想就使人头大,但是如果撇开题目的诱导,可以发现这个棋盘只有一个白色空格!是不是立刻就让人想起小时候玩的这种玩具~~



滑动拼图!
我小时侯超级爱玩的,大家都玩手机游戏以后就没有在卖了(糟糕暴露年龄了).
滑动拼图与这盘棋的区别是,滑动拼图里的格子每次最多只有四个方向可以选择,所以如果模拟的话要用四叉树,但是棋盘的空格每次有八个方向可以选择.


```c++
//空格和它要移动过去的地方的马交换,
//和马移动向它可以移动到的空格,是等价的
swap(mp[xa][ya], mp[xb][yb]);
```

#### 启发式搜索
虽然问题减化了不少,但是计算量还是很大啊.
每步有8种可能,想要模拟所有可能性,15步就是8乘15次,虽然计算机不知疲倦但也不能这样欺负它!我们要想办法帮它减减负.

当当当~!启发式搜索闪亮登场~!

每一步都有待探寻的八个方向,每个结点都有待处理的8个结点,八个点中的每个点还能衍生出更多的点..
这些待探寻或待处理的我们不一定要马上走过去,而是在出发前对它做一个预估.看它值不值得我们走过去,如果不值得就把爪子小心的伸回来.

通常的衡量方式是:
```
F=G+H
```
G是从起点沿着产生的路径,移动到待评估点的移动耗费
H是从待评估点移动到目标结果的预估耗费.(这里就比较迷了,因为我们不可能未卜先知,知道待评估点到目标结果之间的距离,只能根据已有的信息进行推测,这也许就是启发式为什么被称为启发式的原因吧~!)

这里与目标结果的耗费是以多少格棋子还没归位来衡量的.
```c++
//估算函数
int evaluate() {
       int cnt = 0;
       for (int i = 1; i <= 5; i++) {
              for (int j = 1; j <= 5; j++)
                     if (mp[i][j] != goal[i][j])cnt++;
       }
       return cnt;//返回有多少格棋子还没归位
}
```
题目规定了最多走15步,空格每移动一次,只会改变一个马的位置,所以如果走了n步,还有15-n以上个马还没有归位,那空格再怎么用力移动都不可能归位了,所以就有如下减枝:
```c++
//估值
 eva = evaluate();
...
if (eva + dp > 15) {
    v[node].child[i].st = 0;
     swap(mp[xa][ya], mp[xb][yb]);
     continue;
  }
```
这样,一大批结点就被拉近黑名单,节省了计算机的时间.


>通常的启发式搜索其实是会把F,G,H都记录在结点里的,再使用优先队列按照优先顺序进行遍历.而这里根据洛谷其它大佬的智慧直接用了迭代加深,而不是优先队列.没有严格按照启发式搜索来做,(但是你可以试一下,然后告诉我用优先队列来做评估的时间结果会是怎样的,抱住大腿!)

迭代加深部分的代码:
```c++
//从空格处朝八个方向展开搜索,从1-15的深度迭代加深
for (int maxdp = 1; maxdp <= 15 && !flag; maxdp++) 
{
    A_star(0, 0, maxdp);
     if (success)
     {
            cout << maxdp << endl;
             flag = 1;
      }
}
if (!success) {
     cout << "-1" << endl;
 }
```

#### 减枝
除了从启发式搜索迁移来的减枝,超过边界,或者属于回头路的情况,都是可以减枝,拉进黑名单,不再遍历的.这样计算机又少了很多负担,
```c++
//判断边界
 if (xb < 1 || xb>5 || yb < 1 || yb>5) {
     //越界的情况
     v[node].child[i].st = 0;
     swap(mp[xa][ya], mp[xb][yb]);
    continue;
  }
//--------------------------------------------------
  //判断是否回头路
 if (fn != -1 && v[fn].xt == xb && v[fn].yt == yb) {
//走了回头路
    v[node].child[i].st = 0;
     swap(mp[xa][ya], mp[xb][yb]);
    continue;
}
```
因为使用估价函数前是直接把空格和要走的下一步位置交换了,所以continue退出前也要把空格还原回来,不能破坏现场导致下次遍历到这没法玩~

### vector的内存清理问题
其实代码说到这就已经差不多了,最后要注意的一个问题就是vector的clear()函数只会置空vector的size,并不会置空vector所占的内存,测试一下的话,可以看到capacity是不会被清零的!

这种做题的小程序无所谓,不过如果在项目开发里,一定要记得用swap把vector的capacity也归零.
```c++
//对vector的内存进行释放
vector<OTNode>().swap(v);
```

然后下面就是完整的代码了:
```cpp
//#pragma warning(disable:4996)
# include<iostream>
//# include<queue>
# include<string>
# include<cstring>
# include<cctype>//isdigit()函数用到
# include<vector>
# include<iterator>
using namespace std;


typedef struct CHNode{
	int m;
	int eva;
	int st;
}CHNode;

typedef struct OTNode
{
	int fm;
	int xt, yt;
	CHNode child[8];
}OTNode;
vector<OTNode> v;

bool success, flag;

const char goal[7][7] = {
	{'0','0','0','0','0','0'},
	{'0','1','1','1','1','1'},
	{'0','0','1','1','1','1'},
	{'0','0','0','*','1','1'},
	{'0','0','0','0','0','1'},
	{'0','0','0','0','0','0'}
};
char mp[7][7];
int dir[8][2] = { {-2,-1},{-2,1},{-1,-2},{-1,2},{1,-2},{1,2},{2,-1},{2,1} };

int evaluate() {
	int cnt = 0;
	for (int i = 1; i <= 5; i++) {
		for (int j = 1; j <= 5; j++)
			if (mp[i][j] != goal[i][j])cnt++;
	}
	return cnt;
}


void cnode(int node,int xb, int yb) {
	OTNode tp;
	tp.xt = xb;
	tp.yt = yb;
	tp.fm = node;
	for (int i = 0; i < 8; i++) {
		tp.child[i].st = -1;
	}
	v.push_back(tp);
}
/*
st=-1 既没有判断边界和回头路, 也没有判断估值的
st=-2 判断过边界和回头路,  估过值的
st=1 达到继续搜索条件的
st=0 已经越界,15步内不能匹配,或者走回头路被剪掉的
*/

void A_star(int dp, int node, int maxdp)
{
	if (dp >= maxdp)return;
	int xa = v[node].xt;
	int ya = v[node].yt;
	for (int i = 0; i < 8; i++) {
		int cn = v[node].child[i].st;
		int fn = v[node].fm;
		int eva = 0;
		if (cn == 0) continue;
		int xb = xa + dir[i][0];
		int yb = ya + dir[i][1];
		swap(mp[xa][ya], mp[xb][yb]);
		if (cn < 0)
		{
			if (cn == -2) {
				eva = v[node].child[i].eva;
			}
			if (cn == -1) {
				if (xb < 1 || xb>5 || yb < 1 || yb>5) {
					v[node].child[i].st = 0;
					swap(mp[xa][ya], mp[xb][yb]);
					continue;
				}
				if (fn != -1 && v[fn].xt == xb && v[fn].yt == yb) {
					v[node].child[i].st = 0;
					swap(mp[xa][ya], mp[xb][yb]);
					continue;
				}
				eva = evaluate();
				if (!eva) { success = 1; return; }
				if (eva + dp > 15) {
					v[node].child[i].st = 0;
					swap(mp[xa][ya], mp[xb][yb]);
					continue;
				}
				v[node].child[i].eva=eva;
				v[node].child[i].st = -2;
				
			}
			if (eva + dp <= maxdp) {
				//继续搜索前先形成新结点
				cnode(node, xb, yb);
				v[node].child[i].m = pnode;
				v[node].child[i].st = 1;
				pnode++;


				A_star(dp + 1, pnode - 1, maxdp);
			}
		}
		if (cn == 1) {
			int cm = v[node].child[i].m;

			A_star(dp + 1, cm, maxdp);
		}
		swap(mp[xa][ya], mp[xb][yb]);
	}
}



void init() {

	for (int i = 1; i <= 5; i++)cin >> (mp[i] + 1);
	OTNode temp;
	for (int i = 1; i <= 5; i++)
	{
		for (int j = 1; j <= 5; j++)
		{
			if (mp[i][j] == '*') { temp.xt = i; temp.yt = j; }
		}
	}
	for (int i = 0; i < 8; i++) {
		temp.child[i].st = -1;
	}
	temp.fm = -1;
	v.push_back(temp);
}

int main()
{
	int n;
	cin >> n;
	while (n--) {
		init();
		if (!evaluate()) {
			cout << "0" << endl;
			continue;
		}
		for (int maxdp = 1; maxdp <= 15 && !flag; maxdp++) {
			A_star(0, 0, maxdp);
			if (success) {
				cout << maxdp << endl;
				flag = 1;
			}
		}

		if (!success) {
			cout << "-1" << endl;
		}
		v.clear();//记得清空变长数组

		pnode = 1;
		success = 0;
		flag = 0;

	}
	vector<OTNode>().swap(v);

	//system("pause");
	return 0;//返回0
}
```


---

## 作者：PI_AC (赞：0)

# 题目
[骑士精神](https://www.luogu.org/problemnew/show/P2324)
# 题解（IDDFS）
一看这个题，想不出什么神奇的方法，再想一下，直接搜索吧

搜索的顺序很显然，从空地开始，往八个方向进行搜索，如果某一次的操作能得到目标矩阵，就可以退出了

因为题目限制了最多$15$步，就很明显是`IDDFS`了，但如果只是限制一个上限深度还不够，仍然会超时
此时我们就需要用到**乐观估计函数**了，每一道题的乐观估计函数是不同的，针对这道题，如果在当前状态下要还原到目标矩阵，最理想的状态就是每用一步就可以让这个棋子到位，所以我们只需要统计当前矩阵和目标矩阵不同的元素个数来作为乐观估计函数就可以了
# 代码（IDDFS）
```cpp
#include <cstdio>
#include <cstring>

template <class T>
T read() {
    T x = 0; T f = 1; char s = getchar();
    while(s < '0' || s > '9') {if(s == '-') f = -1; s = getchar();}
    while(s >= '0' && s <= '9') {x = (x << 3) + (x << 1) + s - 48; s = getchar();}
    return x * f;
}

template <typename T>
void wri(T x) {
    if(x < 0) {x = -x; putchar('-');}
    if(x / 10) wri(x / 10);
    putchar(x % 10 + 48);
}

template <typename T>
void write(T x, char s) {
    wri(x);
    putchar(s);
}

int n, sx, sy;
int dir[8][2] = {{1, 2}, {1, -2}, {-1, 2}, {-1, -2}, {2, 1}, {2, -1}, {-2, 1}, {-2, -1}};
char a[10][10], s[10][10] = {{'0', '0', '0', '0', '0', '0'}, {'0', '1', '1', '1', '1', '1'}, {'0', '0', '1', '1', '1', '1'}, {'0', '0', '0', '*', '1', '1'}, {'0', '0', '0', '0', '0', '1'}, {'0', '0', '0', '0', '0', '0'}};	//s为目标矩阵
bool f;

int check() {	//乐观估计函数
    int ret = 0;
    for(int i = 1;i <= 5;i ++)
        for(int j = 1;j <= 5;j ++)
            if(a[i][j] != s[i][j])
                ret ++;
    return ret;
}

bool inside(int x, int y) {
    if(x < 1 || x > 5 || y < 1 || y > 5) return 0;
    return 1;
}

void IDDFS(int nowDepth, int maxDepth, int x, int y) {
    if(nowDepth > maxDepth) return ;
    if(check() == 0) {f = 1; return ;}	//如果已经得到目标矩阵
    for(int i = 0;i <= 7;i ++) {
        int tx = x + dir[i][0];
        int ty = y + dir[i][1];
        if(! inside(tx, ty)) continue;
        a[x][y] = a[tx][ty], a[tx][ty] = '*';
        if(nowDepth + check() <= maxDepth)	//如果当前的深度加上最乐观的情况都会超过限制深度则退出，否则进行下一层搜索
            IDDFS(nowDepth + 1, maxDepth, tx, ty);
        a[tx][ty] = a[x][y], a[x][y] = '*';
        if(f) return ;
    }
}

int main() {
    scanf("%d", &n);
    while(n --) {
        f = 0;
        for(int i = 1;i <= 5;i ++) {
            scanf("\n");
            for(int j = 1;j <= 5;j ++)
                scanf("%c", &a[i][j]);
        }
        for(int i = 1;i <= 5;i ++)
            for(int j = 1;j <= 5;j ++)
                if(a[i][j] == '*')
                    sx = i, sy = j;
        for(int i = 0;i <= 15;i ++) {
            IDDFS(0, i, sx, sy);
            if(f) {
                write(i, '\n');
                break;
            }
        }
        if(! f)
            puts("-1");
    }
    return 0;
}
```
# 题解（双向BFS）
正向起点为起始棋盘，反向起点为目标棋盘，这种方法的难点就是判重，如何确定当前状态是否被访问过

由于题目除空格外只有两种棋子，我们可以将其看作是一个二进制数，对每一个位置进行编号（除去空格的位置），然后算出其十进制的值
但这样是会出现重复情况的，例如这样两个棋盘（*号用2代替）：
$\begin{bmatrix} 12111 \\ 11111\\ 11100\\ 00000\\ 00000\end{bmatrix}$和$\begin{bmatrix}11211\\ 11111\\ 11100\\ 00000\\ 00000\end{bmatrix}$

因为我们编号是不算$2$的，所以这样算出来的两个数就会相同，所以我们需要另外开一维数组来记录二的编号
# 代码（双向BFS）
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>
#include <map>
using namespace std;

template <class T>
T read() {
    T x = 0; T f = 1; char s = getchar();
    while(s < '0' || s > '9') {if(s == '-') f = -1; s = getchar();}
    while(s >= '0' && s <= '9') {x = (x << 3) + (x << 1) + s - 48; s = getchar();}
    return x * f;
}

template <typename T>
void wri(T x) {
    if(x < 0) {x = -x; putchar('-');}
    if(x / 10) wri(x / 10);
    putchar(x % 10 + 48);
}

template <typename T>
void write(T x, char s) {
    wri(x);
    putchar(s);
}

template <typename T>
T Max(T x, T y) {return x > y ? x : y;}

template <typename T>
T Min(T x, T y) {return x < y ? x : y;}

template <typename T>
T Fabs(T x) {return x < 0 ? -x : x;}

template <typename T>
void Swap(T &x, T &y) {T t = x; x = y, y = t;}

struct node {
    int f, idxx, idxy;
    int p[10][10];
};
node start, goal;

queue <node> que;

map <int, bool> vis[2][30];
map <int, int> step[2][30];

int n;
int dir[8][2] = {{2, 1}, {2, -1}, {-2, 1}, {-2, -1}, {1, 2}, {1, -2}, {-1, 2}, {-1, -2}};
char s;

int qkpow(int x, int y) {
    int ret = 1;
    while(y) {
        if(y & 1)
            ret = ret * x;
        x = x * x;
        y >>= 1;
    }
    return ret;
}

int getIdx(node x) {	//求出空格的位置
    for(int i = 1;i <= 5;i ++)
        for(int j = 1;j <= 5;j ++)
            if(x.p[i][j] == 2)
                return (i - 1) * 5 + j;
    return 0;
}

int getHash(node x) {	//判重hash
    int ret = 0, sum = 0;
    for(int i = 1;i <= 5;i ++)
        for(int j = 1;j <= 5;j ++) {
            if(x.p[i][j] != 2) sum ++;
            if(x.p[i][j] == 1) ret += qkpow(2, sum);
        }
    return ret;
}

bool inside(int x, int y) {
    if(x < 1 || x > 5 || y < 1 || y > 5) return 0;
    return 1;
}

int DWBFS() {	//双向BFS
    que.push(start);
    que.push(goal);
    int idx1 = getIdx(start), idx2 = getIdx(goal);
    int sum1 = getHash(start), sum2 = getHash(goal);
    vis[start.f][idx1][sum1] = vis[goal.f][idx2][sum2] = 1;
    while(! que.empty()) {
        node t = que.front();
        que.pop();
        idx1 = getIdx(t);
        sum1 = getHash(t);
        if(vis[! t.f][idx1][sum1])
            return step[t.f][idx1][sum1] + step[! t.f][idx1][sum1] <= 15 ? step[t.f][idx1][sum1] + step[! t.f][idx1][sum1] : -1;
        for(int i = 0;i <= 7;i ++) {
            node tmp = t;
            tmp.idxx += dir[i][0];
            tmp.idxy += dir[i][1];
            if(! inside(tmp.idxx, tmp.idxy)) continue;
            Swap(tmp.p[tmp.idxx][tmp.idxy], tmp.p[t.idxx][t.idxy]);
            idx2 = getIdx(tmp);
            sum2 = getHash(tmp);
            if(! vis[tmp.f][idx2][sum2]) {
                vis[tmp.f][idx2][sum2] = 1;
                step[tmp.f][idx2][sum2] = step[t.f][idx1][sum1] + 1;
                if(step[tmp.f][idx2][sum2] < 8)
                    que.push(tmp);
            }
        }
    }
    return -1;
}

int main() {
    goal.p[1][1] = goal.p[1][2] = goal.p[1][3] = goal.p[1][4] = goal.p[1][5] = goal.p[2][2] = goal.p[2][3] = goal.p[2][4] = goal.p[2][5] = goal.p[3][4] = goal.p[3][5] = goal.p[4][5] = 1, goal.p[3][3] = 2;
    goal.f = 0, goal.idxx = 3, goal.idxy = 3;
    scanf("%d", &n);
    while(n --) {
        while(! que.empty()) que.pop();
        for(int i = 0;i <= 1;i ++)
            for(int j = 1;j <= 25;j ++)
                vis[i][j].clear(), step[i][j].clear();
        for(int i = 1;i <= 5;i ++) {
            s = getchar();
            for(int j = 1;j <= 5;j ++) {
                s = getchar();
                if(s == '*') {start.p[i][j] = 2, start.idxx = i, start.idxy = j;}
                else start.p[i][j] = s - 48;
            }
        }
        start.f = 1;
        write(DWBFS(), '\n');
    }
    return 0;
}

```

---

## 作者：王珩030115 (赞：0)

优化1· 每次计算当前状态与目标状态有多少个点不同（记为h），那么如果（已走步数t +h）比15大很多，就剪掉这种状态，但一定不能判断t+h？<=15,因为有可能一步使两个点归位。

------------
优化2· 在常量数组中使相反的两步的i加起来=7；这样就可以方便得判断这一次是不是重复了；

优化3· ~~~~~~~
```cpp
#include<bits/stdc++.h>
using namespace std;
const int d[5][5]={1,1,1,1,1,
                   0,1,1,1,1,
				   0,0,2,1,1,
				   0,0,0,0,1,
				   0,0,0,0,0},
      dx[8]={1,1,2,2,-2,-2,-1,-1},
      dy[8]={-2,2,-1,1,-1,1,-2,2};
int i,j,k,n,m,t,a[6][6],h,x,y,ans;
char c[5];
void dfs(int dep,int h,int x,int y,int la)
{
  if(!h&&dep<=15) {
  	ans=min(ans,dep);
  	exit;
  }
        int tx,ty,th;
        for(int i=0;i<8;i++)
        if(i+la!=7)
        {
        tx=dx[i]+x;
		ty=dy[i]+y;
		if(tx>=0&&ty>=0&&tx<5&&ty<5)
		  {
		  	th=h; int j1=0,j2=0;
		  	if(a[x][y]^d[x][y]) j1=1;
		  	if(a[tx][ty]^d[tx][ty]) j2=1;
		    swap(a[tx][ty],a[x][y]);		    
			if(!(a[tx][ty]^d[tx][ty])) 
		      {
		      	if(j2) th--;
			  } else if(!j2) th++;
			if(!(a[x][y]^d[x][y])) 
			  {
			  	if(j1) th--;
			  } else if(!j1) th++;
		  	if(dep+1+th<=17)
		  	  dfs(dep+1,th,tx,ty,i);
		  	  swap(a[tx][ty],a[x][y]);
	      }
	}
	  }
int main()
{
	scanf("%d\n",&t);
	while(t)
	{
		ans=2000000000;
		h=0;
	    for(i=0;i<5;i++)	
		 {							   
		   scanf("%s",c);
		for(j=0;j<5;j++)
		{
		   if(c[j]=='0') a[i][j]=0;
		     else if(c[j]=='1') a[i][j]=1;
		       else{
			    a[i][j]=2;
			    x=i;y=j;
			}
		
		       if(a[i][j]^d[i][j]) h++;
		   }
  	     }
  	     dfs(0,h,x,y,-1);
  	     if(ans==2000000000)
  	       ans=-1;
  	       printf("%d\n",ans);  	      
		t--;
	}
	return 0;
}
```

---


# [SCOI2005] 王室联邦

## 题目描述

“余”人国的国王想重新编制他的国家。他想把他的国家划分成若干个省，每个省都由他们王室联邦的一个成员来管理。

他的国家有 $N$ 个城市，编号为 $1\ldots N$。

一些城市之间有道路相连，任意两个不同的城市之间有且仅有一条直接或间接的道路。

为了防止管理太过分散，每个省至少要有 $B$ 个城市。

为了能有效的管理，每个省最多只有 $3\times B$ 个城市。

每个省必须有一个省会，这个省会可以位于省内，也可以在该省外。

但是该省的任意一个城市到达省会所经过的道路上的城市（除了最后一个城市，即该省省会）都必须属于该省。

一个城市可以作为多个省的省会。

聪明的你快帮帮这个国王吧！

## 说明/提示

对于 $100\%$ 的数据，$1\le B\leq N\le 10^3$。

感谢 @[FlierKing](/user/9433) 提供 spj。

## 样例 #1

### 输入

```
8 2 
1 2 
2 3 
1 8 
8 7 
8 6 
4 6 
6 5 
```

### 输出

```
3 
2 1 1 3 3 3 3 2 
2 1 8 
```

# 题解

## 作者：Siyuan (赞：77)

[$$\Large\texttt{My Blog}$$](https://hydingsy.github.io/articles/problem-SCOI-2005-Royal-Commonwealth/)

---

## Description

> 题目链接：[Luogu 2325](https://www.luogu.org/problemnew/show/P2325)

“余”人国的国王想重新编制他的国家。他想把他的国家划分成若干个省，每个省都由他们王室联邦的一个成员来管理。他的国家有 $n$ 个城市，编号为 $1\dots n$。一些城市之间有道路相连，任意两个不同的城市之间有且仅有一条直接或间接的道路。

为了防止管理太过分散，每个省至少要有 $B$ 个城市，为了能有效的管理，每个省最多只有 $3B$ 个城市。

每个省必须有一个省会，这个省会可以位于省内，也可以在该省外。但是该省的任意一个城市到达省会所经过的道路上的城市（除了最后一个城市，即该省省会）都必须属于该省。

一个城市可以作为多个省的省会。

数据范围：$1\le n\le 3000$

------

## Solution

我们可以考虑这样一个构造方法：

1. 我们 $\text{DFS}$ 整棵树，处理每个节点时，将其**一部分子节点分块**，将**未被分块的子节点返回到上一层**。
2. 枚举 $u$ 的每个子节点 $v$，递归处理子树后，将每个子节点返回的未被分块的节点添加到集合 $S$ 中，一旦 $\vert S\vert\ge B$ 就把 $S$ 作为一个新的块并将 $u$ 作为**省会**，然后清空 $S$ 并继续枚举 $v$。
3. 处理完所有子树后，将 $u$ 也加入到集合 $S$ 中，此时在 $S$ 中的节点为**未被分块的节点**，将被返回到上一层，显然 $S$ 的大小最大为 $B-1$ 个子树节点 + $u$ 节点本身，即 $\vert S\vert\le B$。
4. 由于**返回的集合的大小最大为 $B$**，对于**一个子树会对集合最多增加 $B-1$ 个节点**，那么每个块的大小最大为 $2B-1$，满足条件。
5. 在 $\text{DFS}$ 结束后，集合 $S$ 中可能还有节点（最多有 $B$ 个），那么我们**把这 $B$ 个节点并入最后一个块**（以根节点为省会的最后一个块）中，那么这个块的大小最大为 $3B-1$，符合条件。

**时间复杂度**：$O(n)$

------

## Code

```cpp
#include <cstdio>

const int N=1e3+5,M=2e3+5;
int n,B,sz,cnt,tot,lnk[N],ter[M],nxt[M],st[N],rt[N],bel[N];

void add(int u,int v) {
	ter[++tot]=v,nxt[tot]=lnk[u],lnk[u]=tot;
}
void dfs(int u,int p) {
	int cnr=sz;
	for(int i=lnk[u];i;i=nxt[i]) {
		int v=ter[i];
		if(v==p) continue;
		dfs(v,u);
		if(sz-cnr>=B) {
			rt[++cnt]=u;
			while(sz>cnr) bel[st[sz--]]=cnt;
		}
	}
	st[++sz]=u;
}
int main() {
	scanf("%d%d",&n,&B);
	for(int i=1;i<n;++i) {
		int u,v;
		scanf("%d%d",&u,&v);
		add(u,v),add(v,u);
	}
	dfs(1,0);
	if(!cnt) rt[++cnt]=1;
	while(sz) bel[st[sz--]]=cnt;
	printf("%d\n",cnt);
	for(int i=1;i<=n;++i) printf("%d%c",bel[i]," \n"[i==n]);
	for(int i=1;i<=cnt;++i) printf("%d%c",rt[i]," \n"[i==cnt]);
	return 0;
}
```



---

## 作者：xMinh (赞：10)

# [luogu 2325 王室联邦](https://www.luogu.org/problemnew/show/2325)

### S1
这道题其实是很尬的。

刚看到这道题的时候第一个想法就是搜，但怎么搜是个问题。第一个想法是枚举子树，之后针对每个子树单独处理，但是想了一会之后发现不好实现。第二个想法是每B个确定一个省，然后最后剩下的归到已经确定好的省里面。这个后来被证实是正解。

**比较尬，最后我用的这两个方法结合起来做的。**

### S2
一开始我就是按照我的第二个想法不加任何修饰地做的，先广搜确定层数，之后从下往上搜B个，是一个省，搜不够就归到旁边的省里面。这个想法其实漏洞百出，特别呲，但是由于SPJ牛逼所以莫名其妙的了80分。

可以被和这组类似的数据卡掉（这组本身并不能）

```cpp
13 4    
1 2    
1 3    
3 4    
4 5    
2 6    
6 7    
7 8    
2 9     
9 10    
9 11    
9 12    
9 13    
```
这种数据的特点是一条链，我的dfs会一路选上去，但是这条链上面的子树都不到B个，最后只能都归到一个省里面，就会GG。实际上应该把这条链一分两半地选。

### S3
针对这种数据，我想起了我的第一个方法，于是我加了一个结构体，然后在广搜的时候单向加边，每搜到一个点，看看它的子树里面没有搜过的够不够B个，最后再单独处理不能组成一个省的城市群。

最后剩下的每一个城市群子树有一个特点，它的根节点的父节点一定被选过（不然就会先枚举它的父节点了），它的所有子孙节点都没有选过。这样可以克服刚才的问题。那么把这个城市群加到根节点的父节点的省里面就可以了。

但是还有一点就是1节点的处理，因为它没有父节点。这也好办，最后一个省肯定是距离1节点最近的一个，所以可以把1节点的城市群加入到最后一个省里面。

然而这样只有90分。

这就很绝望了，我又想了半个小时才想出怎么回事。

可以用这组数据卡掉

```cpp
16 4
1 2    
1 3    
1 4    
1 5    
2 6
2 7
2 8
2 9
2 10
6 11
7 12
8 13
9 14
10 15
13 16
```
这种数据有一个特点，就是以某个节点作为根节点，它的所有子节点为根的子树代表的城市群都不超过B个城市，但是加起来就能超过3B个城市。

一开始我以为这种数据根本就不可能存在，但是事实证明我错了。

### S4
这种数据当然存在，因为题目里面存在这样一句话：

**“一个城市可以作为多个省的省会。”**

这里就产生了一个歧义问题，还好被asia大佬解决了。这个省会到底算作哪个省的呢？答案是，只能算作一个省的，而剩下几个省必须做到出了这个省会有B个城市才行。

解决这个问题倒也简单，**针对一个点为根节点的城市群用while进行多次搜索，只要能搜到B个就继续搜**，这样就能保证绝对正确了。

### 代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define rint register int 
#define inv inline void
#define mc(a,i,x,y,z) for (i=x;i<=y;i++) a[i]=z;
using namespace std;
int cnt,b,h,t,num,n,hh,lst;
int ans[1001],ca[1001],q[1001],team[1001],head[2001],hed[2001],fa[1001];
bool vis[1001],flag;
struct node
{
    int next,to;
}ljb[2001],edg[2001];
inv add(int x,int y)
{
    edg[++cnt].next=hed[x];
    edg[cnt].to=y;
    hed[x]=cnt;
}
inv adn(int x,int y)
{
    ljb[++cnt].next=head[x];
    ljb[cnt].to=y;
    head[x]=cnt;
}
inv bfs()
{
    h=0;t=1;team[1]=1;vis[1]=1;
    while (h<t)
    {
        int x=team[++h];
        for (rint i=hed[x];i;i=edg[i].next)
        {
            int y=edg[i].to;
            if (!vis[y])
            {
                vis[y]=1;
                team[++t]=y;
                fa[y]=x;
                adn(x,y);
            }
        }
    }
}
inv dfs(int x)
{
    q[++cnt]=x;vis[x]=1;
    if (cnt==b) return;
    for (rint i=head[x];i;i=ljb[i].next)
    {
        int y=ljb[i].to;
        if (!vis[y]) dfs(y);
        if (cnt==b) return;
    } 
}
inv color(int x,int c)
{
    ans[x]=c;
    for (rint i=head[x];i;i=ljb[i].next)
    {
        int y=ljb[i].to;
        if (!vis[y]) color(y,c);
    } 
}
int main()
{
    scanf("%d%d",&n,&b);
    for (rint i=1;i<=n-1;i++) 
    {
        int x,y;scanf("%d%d",&x,&y);
        add(x,y);add(y,x);
    }
    cnt=0;bfs();
    mc(vis,hh,1,n,0);
    for (rint i=t;i>=1;i--)
        if (!vis[team[i]])
        {
            cnt=0;mc(q,hh,1,n,0);
            dfs(team[i]);
            while (cnt==b)
            {
                num++;
                for (rint j=1;j<=cnt;j++) ans[q[j]]=num;
                ca[num]=team[i];
                cnt=-1;
                mc(q,hh,1,n,0);
                dfs(team[i]);
            }
            for (rint j=1;j<=cnt;j++) vis[q[j]]=0;
        }
    if (!vis[1]) color(1,num);
    for (rint i=2;i<=t;i++)
        if (!vis[team[i]]) 
            color(team[i],ans[fa[team[i]]]);
    printf("%d\n",num);
    for (rint i=1;i<=n;i++) printf("%d ",ans[i]);
    printf("\n");
    for (rint i=1;i<=num;i++) printf("%d ",ca[i]);    
}
```

---

## 作者：Alkaid_Star (赞：9)

本文同步发表至我的[WordPress博客](https://www.encounter.cool/index.php/2021/01/05/luogu-2325-solution/)，阅读体验~~可能~~更佳。

[原题面](https://www.luogu.com.cn/problem/P2325)

#####  Update On 2021.1.6：更新了代码注释，求不被咕。

### 题意：
> 把一个有 $n$ 个点的树划分成若干个**省**，要求每个省至少要有 $B$ 个城市，最多可以有 $3B$ 个城市。

> 注意：每个省必须有一个省会，这个省会可以位于省内，也可以在该省外。但是该省的任意一个城市到达省会所经过的道路上的城市（除了该省省会）都必须属于该省。另外，一个城市可以作为多个省的省会。

### 思路：
树上分块。我们考虑直接从根开始边跑DFS边划分，**把每个需要划分的点放进一个栈 $Sta$ **。

#### 划分方法：

1. 枚举 $x$ 的每个子节点 $v$，递归处理子树后，将每个子节点返回的未被分块的节点压到栈 $Sta$ 中（后面会讲到），一旦 超过 $B$ 个就把开一个新的块并将 $x$ 作为省会，然后不断弹出 $Sta$ 中加入这个省的元素，并继续枚举 $v$。

2. 处理完所有子树后，将 $x$ 也加入到集合 $Sta$ 中，此时在 $Sta$ 中的节点将被返回到上一层，显然 $Sta$ 的大小最大为 $B−1$ 个子树节点（大于等于 $B$ 时会拆出一个新的省） + $x$ 本身，即 $Sta$ 中结点不超过 $B$ 个。

3. 在 $dfs$ 结束后可能还剩下 不超过 $B$ 个点，并入以根为省会的省份中。

### 合法性说明：
对于每个结点，它向上传回去的结点不超过 $B$ 个，所以对于一个子树会对集合最多增加 $B-1$ 个节点，那么每个块的大小最大为 $2B−1$，满足条件。

在 $dfs$ 结束后，栈中最多有 $B$ 个结点，所以把这 $B$ 个节点并入以根节点为省会的省中，那么此时根节点这个块的大小最大可能为 $3B−1$ ，方法成立。

时间复杂度显然是 $O(n)$ 的（就跑一遍 $dfs$ ，快得飞起）。
虽然我也不知道为什么 $n,m \le 2000$ 。

### Code：
```C++
#include<bits/stdc++.h>
using namespace std;
const int N=2005;

struct Edge{
	int vet,nxt;
}e[N<<1];

int n,B,Top=0,cnt=0,edge=0,head[N];
int sta[N],Belong[N],Root[N];

inline int read(){
	int x=0,f=1; char ch=getchar();
	while (!isdigit(ch)) { if (ch=='-') f=-1; ch=getchar(); }
	while (isdigit(ch)) { x=x*10+ch-'0'; ch=getchar(); }
	return x*f;
}

inline void addedge(int x,int y){
	e[++edge].vet=y;
	e[edge].nxt=head[x];
	head[x]=edge;
}

inline void dfs(int x,int fa){
	int rec=Top; 		//记录栈此时的状态，类似的思想可以在可撤销并查集中见到（可能吧）
	for (int i=head[x];i;i=e[i].nxt){
		int v=e[i].vet;
		if (v==fa) continue;
		dfs(v,x);
		if (Top-rec>=B){		//如果超过 B 个
			Root[++cnt]=x;
			while (Top!=rec)	//把超过部分的结点统计到新的省份中
				Belong[sta[Top--]]=cnt;
		}
	}
	sta[++Top]=x;		//把当前节点 x 放入栈中
}

int main(){
	//freopen("Luogu2325.in","r",stdin);
	//freopen("Luogu2325.out","w",stdout);
	n=read(),B=read();
	for (int i=1;i<=n-1;i++){
		int x=read(),y=read();
		addedge(x,y);
		addedge(y,x);
	}
	dfs(1,0);
	if (cnt==0) Root[++cnt]=1;		//特判，如果一个省份都没有创建，那么以 1 为省会创建一个省份。
	while (Top!=0) Belong[sta[Top--]]=cnt;		//把剩余结点放到 1 为省会的省份中
	printf("%d\n",cnt);
	for (int i=1;i<=n;i++)
		printf("%d ",Belong[i]);
	printf("\n");
	for (int i=1;i<=cnt;i++)
		printf("%d ",Root[i]);
	printf("\n");
	return 0;
}
```

---


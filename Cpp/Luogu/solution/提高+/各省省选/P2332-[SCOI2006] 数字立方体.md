# [SCOI2006] 数字立方体

## 题目描述

有一个立方体被分成 $n\times n\times n$ 的单位，坐标用 $(X,Y,Z)$ 表示 $(1\le X,Y,Z\le n)$。每个单位立方体内有一个绝对值不超过 $10^9$ 的整数。统计有多少个子立方体的所有数之和是 $m$ 的倍数。子立方体即满足 $x_1\le X\le x_2$，$y_1\le Y\le y_2$，$z_1\le Z\le z_2$ 的所有单位立方体集合，其中 $1\le x_1,x_2,y_1,y_2,z_1,z_2\le n$。


## 说明/提示

### 数据范围及约定

- $30\%$ 的数据满足 $1\le n\le 10$。
- $100\%$ 的数据满足 $1\le n\le 40$。

对于所有的数据满足 $1\le m\le 10^6$。


## 样例 #1

### 输入

```
2 5
1 2
3 4
5 6
7 8
```

### 输出

```
5```

# 题解

## 作者：Great_Influence (赞：3)

练前缀和的一道好题。

首先可以考虑暴力做法。直接算前缀和就可以了（然而三维前缀和）。然而发现时间复杂度为O(n^6)不能过。于是可以考虑优化。

然后可以发现，如果一个立方体为所求的立方体的话，那么它的最高平面以下的方块数字和与它最低平面-1以下的方块数字和应该是相等的。所以可以考虑记录后快速加减。这样的话只需要枚举平面与高度就可以了。时间复杂度O(n^5)(其实也是勉强卡过去)

代码：

```cpp
#include<bits/stdc++.h>
#include<cctype>
#include<algorithm>
#include<set>
#define For(i,a,b) for(i=(a);i<=(b);++i)
#define Forward(i,a,b) for(i=(a);i>=(b);--i)
using namespace std;
template<typename T>//快读
inline void read(T &x)
{
    T s=0,f=1;
    char k=getchar();
    while(!isdigit(k)&&(k^'-'))k=getchar();
    if(!isdigit(k))
    {
        f=-1;
        k=getchar();
    }
    while(isdigit(k))
    {
        s=s*10+(k^48);
        k=getchar();
    }
    x=s*f;
}
const int MAXN=50;
int n,m;
long long sum[MAXN][MAXN][MAXN];//前缀和（long long可以不开）
int C[1000010],clean[100],e;//记录数组与清空数组。不这样清空的话时间复杂度为O(n^4m)根本过不了
int main(void)
{
    read(n);
    read(m);
    int i,j,k,x,y,z,ans=0;
    For(i,1,n)
        For(j,1,n)
            For(k,1,n)
            {
                read(sum[i][j][k]);
                sum[i][j][k]%=m;
                sum[i][j][k]=
                    (sum[i-1][j][k]+sum[i][j-1][k]+sum[i][j][k-1]+sum[i][j][k]
```
-sum[i-1][j-1][k]-sum[i][j-1][k-1]-sum[i-1][j][k-1]
+sum[i-1][j-1][k-1]+3\*m)%m;//计算前缀和

```cpp
            }
    For(i,1,n)
        For(j,1,n)
            For(x,1,i)
                For(y,1,j)//枚举平面
                {
                    while(e)C[clean[e--]]=0;//清空之前平面的记录情况。
                    For(k,1,n)
                    {
                        int s=(sum[i][j][k]-sum[x-1][j][k]-sum[i][y-1][k]
                        +sum[x-1][y-1][k]+2*m)%m;//计算方块数字和
                        if(!C[s])clean[++e]=s;//计入清空数组
                        ans+=C[s];//加入答案
                        ++C[s];
                    }
                    ans+=C[0];//记得直接余0的需要再加上去
                }
    printf("%d\n",ans);
    return 0;
}

```

---

## 作者：墨舞灵纯 (赞：2)

这么好的题就两篇题解……补充一篇新方法。

看到现有的两篇题解都用了~~高深莫测的~~容斥，蒟蒻只想默默地说：我不会容斥，但我会更简单的做法！

后面统计答案就不说了，大家可以参考参考另外两篇很好的题解。我主要分享高维前缀和不用容斥的做法。

我们先看看代码。


```
	for(int i=1;i<=n;++i)
		for(int j=1;j<=n;++j)
			for(int k=1;k<=n;++k)
				mo(a[i][j][k],a[i-1][j][k]); 
	for(int i=1;i<=n;++i)
		for(int j=1;j<=n;++j)
			for(int k=1;k<=n;++k)
				mo(a[i][j][k],a[i][j-1][k]);
	for(int i=1;i<=n;++i)
		for(int j=1;j<=n;++j)
			for(int k=1;k<=n;++k)
				mo(a[i][j][k],a[i][j][k-1]); 
```
其中$mo$函数代表手动取模（为了加速），可以直接理解成：$mo(a,b)=(a+b)$%$mod$

看起来是不是很简单呢？这样我们就避开容斥了！减少了错误的发生~~和思考~~，而且很好记。

但是为什么可以这样写呢？

首先我们知道高维前缀和大部分都是利用容斥原理解决的。

然后呢，三维的我们可以轻松容斥，但是如果有五维的就很容易错了。

但我们知道前缀和的主要思想是后面累加前面的，那么我们可以对每一维进行类似一维前缀和的累加。

所以我们可以用n次循环嵌套，每次统计一维的前缀和。

这样就避免了很麻烦的容斥。因为容斥枚举子集是$2^n$的，四维五维六维的很难不写错。

这样大家应该都懂了吧……已经很详细了。



---

## 作者：Erica_N_Contina (赞：2)

## 思路

众所周知我们最多有 $n\times n\times n=40^3=64000$ 个单位。

**一维**

我们先来考虑一个简单的版本：有一个长度为 $n$ 的数组。统计有多少个区间的所有数之和是 $m$ 的倍数。

对于这个问题，我们很容易想到我们计算出数组的前缀和，然后我们 $O(n)$ 枚举区间的长度，然后 $O(n)$ 枚举区间的左端点。假设区间为 $[l,r]$，那么我们只需要考虑 $qzh_{r}-qzh_{l-1}$ 是否是 $m$ 的倍数即可。时间复杂度为 $O(n^2)$。

**二维**

我们先来考虑一个简单一点的版本：有一个平面被分成 $n\times n$ 的单位。每个单位内有一个绝对值不超过 $10^9$ 的整数。统计有多少个矩形的所有数之和是 $m$ 的倍数。

> 我们用 $[(a,b)(x,y)] $ 来表示一个矩形，其左上角坐标为 $(a,b)$，右下角坐标为 $(x,y)$。

对于这个问题，我们照葫芦画瓢，按照上面的思路。不难想到，对于矩形 $[(x,y)(a,b)]$ 我们 $O(n^2)$ 枚举矩形的长，即 $x,a$，然后再扫一遍，枚举 $y,b$，用二维前缀和进行判断。时间复杂度 $O(n^4)$。

我们考虑优化。（这里就那一维来讲）我们需要考虑 $qzh_{r}-qzh_{l-1}$ 是否是 $m$ 的倍数，这个条件可以变成 $qzh_{r}\equiv qzh_{l-1}\pmod m$。所以回到二维，当我们确定好 $x,a$ 时，在从前往后扫描 $y$ 时，我们记录前面有几个矩形 $[(x,1))(a,b)]$ 的和对 $m$ 取模的值为 $i$，我们开一个桶 $ton_i$ 来记录。

后面当我们枚举到一个矩形 $[(x,1))(a,b')]$ 的和对 $m$ 取模的值为 $i$，我们只要把答案加上 $ton_i$ 即可，然后更新 $ton_i$ 的值。

**解决问题**

选择我们来到了三维空间。还是和上面的一样，我们花 $O(n^4)$ 来枚举一下 $x,y$ 轴，对于 $z$ 轴，我们通过同余+桶来优化。时间复杂度为 $O(n^5)$，比暴力少一个 $n$。

本题还有一个知识点，即高维前缀和。我们现在从二维开始考虑。



$qzh_{i,j}=qzh_{i-1,j}+qzh_{i,j-1}-qzh_{i-1,j-1}+a_{i,j}$

三维前缀和也可以推导出来。

$q_{i,j,k}=q_{i-1,j,k}+q_{i,j-1,k}+q_{i,j,k-1}-q_{i-1,j-1,k}-q_{i-1,j,k-1}-q_{i,j-1,k-1}+q_{i-1,j-1,k-1}+a_{i,j,k}$

很容易发现这是容斥原理的应用。不过我们现在还用不到它，等我们要高维前缀和时我们再用容斥。

## 代码

注意多次 `memset()` 复杂度过高！

本题巨卡常，连 `long long` 也开不了（幸好我很快就反应过来了）。

```C++
/*////////ACACACACACACAC///////////
       . Code  by  Ntsc .
       . Earn knowledge .
/*////////ACACACACACACAC///////////

#include<bits/stdc++.h>
//#define int long long
#define db double
#define rtn return
using namespace std;

const int N=1e2+5;
const int M=1e6;
const int Mod=1e5;
const int INF=1e5;

int n,m,p,T,q[N][N][N],a[N][N][N],ton[M],ans;

signed main(){
//	cin>>n>>m;
	 scanf("%d%d",&n,&m); 
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			for(int k=1;k<=n;k++){
//				cin>>a[i][j][k];
				scanf("%d",&a[i][j][k]); 
//				q[i][j][k]=a[i][j][k]+q[i-1][j][k]+q[i][j][k-1]+q[i][j-1][k]-q[i-1][j-1][k]-q[i-1][j][k-1]-q[i][j-1][k-1]+q[i-1][j-1][k-1];
//				q[i][j][k]%=m;
			}
		}
	}
	
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			for(int k=1;k<=n;k++){
				q[i][j][k]=a[i][j][k]+q[i-1][j][k]+q[i][j][k-1]+q[i][j-1][k]-q[i-1][j-1][k]-q[i-1][j][k-1]-q[i][j-1][k-1]+q[i-1][j-1][k-1];
				((q[i][j][k]%=m)+=m)%=m;
			}
		}
	}
	queue<int> que;
	
	for(int x=1;x<=n;x++){
		for(int a=x;a<=n;a++){
			for(int y=1;y<=n;y++){
				for(int b=y;b<=n;b++){
//					memset(ton,0,sizeof ton);
					
					while(que.size()){
						ton[que.front()]=0;
						que.pop();
					}
					
					for(int i=1;i<=n;i++){
						int sum=q[a][b][i]-q[x-1][b][i]-q[a][y-1][i]+q[x-1][y-1][i];
						sum=(sum%m+m)%m;
//						cerr<<"sum="<<sum<<endl;
						if(!sum)ans++;//注意哦,如果当前立方体恰好是m的倍数,那么要加上不减去前面任何立方体这种情况哦! 
						
						if(!ton[sum])que.push(sum);
						
						ans+=ton[sum];ton[sum]++;
					}
				}
			}
		}
	}
	
//	cout<<ans<<endl;
	printf("%d",ans);
	return 0;
}


```




---

## 作者：ddwqwq (赞：1)

我来讲一下如何计算高维前缀和吧。我们可以把一段区间看作一个集合，用和来类比概率，之后套容斥恒等式，就可以解决任意维度的前缀和问题了。
以下是三维前缀和：
```
//s为所有下标满足x2 <= i <= x1, y2 <= j <= y1, z2 <= k <= z1的数的和
s = sum[x1][y1][z1] - (sum[x2][y1][z1] + sum[x1][y2][z1] + sum[x1][y1][z2] 
- sum[x1][y2][z2] - sum[x2][y1][z2] - sum[x2][y2][z1] + sum[x2][y2][z2])
```
对于本题，我用的就是之前那篇题解的思路。代码如下：
```
// luogu-judger-enable-o2
#include <cstdlib>
#include <iostream>
#include <cstdio>
#include <math.h>
#include <cstring>
#include <time.h>
#include <utility>

#pragma warning(disable:4996)
#define INF 2000000//005//2 * 10^9
#define lowbit(a) ((a)&-(a))
inline long long max(long long a, long long b)
{
    return a > b ? a : b;
}
inline long long min(long long a, long long b)
{
    return a < b ? a : b;
}

const int MAXN = 45;
const int MAX = 1000005;

int N, m;
int val[MAXN][MAXN][MAXN];
int sum[MAXN][MAXN][MAXN];

void prepare()
{
    int i, j, k;
    for (i = 1; i <= N; i++)
        for (j = 1; j <= N; j++)
            for (k = 1; k <= N; k++)
                sum[i][j][k] = (sum[i - 1][j][k] + sum[i][j - 1][k]
                - sum[i - 1][j - 1][k] + sum[i][j][k - 1] - (sum[i - 1][j][k - 1]
                + sum[i][j - 1][k - 1] - sum[i - 1][j - 1][k - 1]) + val[i][j][k]) % m;
}

int sumof(int x1, int x2, int y1, int y2, int z1, int z2)
{
    x2--;
    y2--;
    z2--;
    int t = (sum[x1][y1][z1] + sum[x1][y2][z2] + sum[x2][y1][z2] + sum[x2][y2][z1]
        - sum[x2][y1][z1] - sum[x1][y2][z1] - sum[x1][y1][z2] - sum[x2][y2][z2]) % m;
    return t < 0 ? t + m : t;
}

bool judge(int x, int y, int z, int len)
{
    return x + len - 1 <= N&&y + len - 1 <= N&&z + len - 1 <= N;
}

int c[MAX], S[MAX], s;

int main()
{
    int i, j, k;
    int cnt = 0;

    scanf("%d %d", &N, &m);
    for (i = 1; i <= N; i++)
        for (j = 1; j <= N; j++)
            for (k = 1; k <= N; k++)
                scanf("%d", &val[i][j][k]);

    prepare();

    int x1, x2, y1, y2, z;
    for (x1 = 1; x1 <= N; x1++)
        for (x2 = x1; x2 <= N; x2++)
            for (y1 = 1; y1 <= N; y1++)
                for (y2 = y1; y2 <= N; y2++)
                {
                    while (s)
                        c[S[--s]] = 0;
                    for (z = 1; z <= N; z++)
                    {
                        int t = sumof(x2, x1, y2, y1, z, 1);
                        if (!c[t])
                            S[s++] = t;
                        cnt += c[t];
                        c[t]++;
                    }
                    cnt += c[0];
                }

    printf("%d", cnt);

//	system("pause");
    return 0;
}
```

---

## 作者：xinxin2022 (赞：0)

前置知识：[二维前缀和](https://www.luogu.com.cn/article/hcvke5yb)

简单的三维前缀和。

首先不难想出枚举 $x,y,z$，可以做到 $O(n^{9})$。

考虑使用前缀和优化。

令：

$$s_{i,j,k} = \sum_{l=1}^{i} \sum_{r=1}^{j} \sum_{p=1}^{k} a_{l,r,p}$$

那么有：

$$s_{i,j,k}=a_{i,j,k}+s_{i-1,j,k}+s_{i,j-1,k}+s_{i,j,k-1}-s_{i-1,j-1,k-1}$$

因为三维前缀和就是把一堆二维平面加在一起，所以处理方式和二维前缀和的原理一致，加上三个方向前一个位置的前缀和，再减掉重复部分即可，即上面式子。

可以做到 $O(n^6)$。

此时可以先不管第三维，考虑枚举一个二维平面上的矩形四端点。

问题转化为如何 $O(n)$ 求出满足条件的第三维点数的数量。

此时你会发现：不就是[这题](https://www.luogu.com.cn/problem/P3941)嘛！

因为 $m$ 不大，所以可以开桶记录模 $m$ 的余数。

设目前枚举到的矩阵模 $m$ 的值为 $t$，那么令 $ans$ 加上 $cnt_t$ 即可，因为用此时的矩阵削掉以前余数也为 $t$ 的矩阵，其余数必定为 $0$。

此时能做到 $O(n^4(n+m))$，瓶颈在于清空 $cnt$ 数组。

因为 $n$ 是每次枚举第三维最多产生的不同余数数量，考虑开一个 $c$ 数组记录每次产生的余数，每次枚举 $c$ 数组，令 $cnt_{c_i}=0$ 即可。

时间复杂度为 $O(n^5)$。

但实际上跑不满，因为第二维的枚举是受限于第一维的，每个方向期望的枚举数量只有 $\frac{n}{2}$ 次。

$\frac{40^5}{4}=2.56\times 10^7$，过这题还是绰绰有余的。

贴下我的最优解代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,cnt[1000005],a[45][45][45],sum[45][45][45],c[45],ans,all;
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            for(int k=1;k<=n;k++){ 
                cin>>a[i][j][k];
                sum[i][j][k]=a[i][j][k]%m;
                sum[i][j][k]=sum[i][j][k]+sum[i-1][j][k]+sum[i][j-1][k]+sum[i][j][k-1];
                sum[i][j][k]=sum[i][j][k]-sum[i-1][j-1][k]-sum[i-1][j][k-1]-sum[i][j-1][k-1]+sum[i-1][j-1][k-1]+5*m;
                sum[i][j][k]%=m;
            }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            for(int k=i;k<=n;k++)
                for(int l=j;l<=n;l++){
                    for(int r=1;r<=n;r++) cnt[c[r]]=0;
                    for(int r=1;r<=n;r++){
                        all=sum[k][l][r]-sum[i-1][l][r]-sum[k][j-1][r]+sum[i-1][j-1][r]+5*m;
                        all%=m;
                        c[r]=all;
                        ans+=cnt[all];
                        cnt[all]++;
                    }
                    ans+=cnt[0];
                }
    cout<<ans;
    return 0;
}
```

可能是因为我的常数小，用时只有第二名的 $\frac{5}{8}$ 左右。

---

## 作者：zhangjiting (赞：0)

## 题意
给出一个立方体，求有多少个子立方体的和为 $k$ 的倍数。

## 解题思路

暴力做法：$O(n^6)$。

枚举子立方体，考虑只枚举长和宽，为了简化问题，我们可以将问题表示成：“给定一个矩阵，求有多少个子矩阵的和为 $M$ 的倍数。”

我们可以不必枚举宽，仅仅用 $O(n^2)$ 枚举长，然后对于给定的行数，维护一个前缀和 `s[i]`。于是一个子矩阵的和就可以表示为 `s[r]−s[l−1]`。考虑一下何时这个子矩阵是 $M$ 的倍数？用同余方程描述，就是 `s[r]−s[l−1]≡0 (mod M)`，也就是 `s[l−1]≡s[r] (mod M)`。


于是我们只需要维护一个桶表示目前为止 `s[r]==i`的个数就可以了。

推广到立方体，改一下前缀和的计算公式就可以了。

`s[i][j][k]=s[i−1][j][k]+s[i][j−1][k]−s[i−1][j−1][k]+s[i][j][k−1]−s[i−1][j][k−1]−s[i][j−1][k−1]+s[i−1][j−1][k−1]+a[i][j][k]`

## AC代码
```cpp
#include <cstdio>
#include <queue>
#include <cstring>
#include <map>
#include <algorithm>
using namespace std;
typedef long long ll;
const int MAXN = 10010;
const int MAXM = 20010;
const int INF = 1061109567;
inline int Max(const int a, const int b){ return (a > b) ? a : b; }
inline int Min(const int a, const int b){ return (a < b) ? a : b; }
inline int read(){
    int x = 0; int w = 1; register char c = getchar();
    for(; c ^ '-' && (c < '0' || c > '9'); c = getchar());
    if(c == '-') w = -1, c = getchar();
    for(; c >= '0' && c <= '9'; c = getchar()) x = (x<<3) + (x<<1) + c - '0'; return x * w;
}
ll Ans;
int N,M,K;
int a[45][45][45],s[45][45][45],sum[45],cnt[1000010];
int main(){
//	freopen(".in","r",stdin);
	N = read(), M = read();
	for(int i = 1; i <= N; ++i){
		for(int j = 1; j <= N; ++j){
			for(int k = 1; k <= N; ++k){
				a[i][j][k] = read();
				s[i][j][k] = ((s[i-1][j][k] + s[i][j-1][k] - s[i-1][j-1][k] + s[i][j][k-1] - s[i-1][j][k-1] - s[i][j-1][k-1] + s[i-1][j-1][k-1] + a[i][j][k]) % M + M) % M;
			}
		}
	}
	for(int i = 1; i <= N; ++i){
		for(int j = i; j <= N; ++j){
			for(int p = 1; p <= N; ++p){
				for(int q = p; q <= N; ++q){
					cnt[0] = 1;
					for(int k = 1; k <= N; ++k){
						sum[k] = ((s[j][q][k]-s[i-1][q][k]-s[j][p-1][k]+s[i-1][p-1][k]) % M + M) % M;
						Ans += 1ll * cnt[sum[k]];
						cnt[sum[k]]++;
					}
					for(int k = 1; k <= N; ++k) cnt[sum[k]] = 0;		
				}
			}
			
		}
	}
	printf("%lld", Ans);
	return 0;
}
```


---


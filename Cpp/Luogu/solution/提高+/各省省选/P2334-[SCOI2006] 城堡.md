# [SCOI2006] 城堡

## 题目描述

为了救出心爱的公主 Julie，Billy 来到了恶魔的城堡。经过了三天三夜的浴血奋战，魔王殿已近在咫尺。

这是一条狭长的通道，Billy 在位置 $0$，而魔王殿在位置 $n + 1$。在每个单位时间，Billy 可以往左或往右移动一个单位，或者原地不动。每个格子的上方都有石头周期性的往下砸，格子 $i$ 的周期为 $c_i$。

对于格子 $i$ 上方的石头，可以用 $c_i$ 个整数来描述：$h_1, h_2, \cdots, h_{c_i}$，表示在时间 $t = kc_i + x$（$1\leq x\leq c_i$）时处于该格子上将被砸掉 $h_x$ 格血。其中 $h_x = 0$ 表示该时刻没有石头砸下来。

计算 Billy 最少损失多少格血后可以到达魔王殿。假设 Billy 是不会死的。注意从位置 $1$ 也是可以回到位置 $0$ 的，且在位置 $0$ 不损血。


## 说明/提示

对于 $50\%$ 的数据，$n\leq 20$；

对于 $100\%$ 的数据满足：$0\leq n\leq 1000$，$1\leq c_i\leq 10$，$0\leq h_x\leq 100$。

- 2023.4.12 添加一组 hack 数据，不计分。

## 样例 #1

### 输入

```
4
2 1 0
2 0 1
1 2
7 0 1 1 1 1 1 1
```

### 输出

```
2```

# 题解

## 作者：Feyn (赞：3)

[link](https://www.luogu.com.cn/problem/P2334) & [博客园食用](https://www.cnblogs.com/dai-se-can-tian/p/16450595.html)

这种做法需要吸氧才能通过，不是正解，所以只是提供一种题解区还没有的思路。

可以用分层图的思路来做这道题。每次从一个方格转移到另一个方格时时间都发生了改变，时间的改变可以看成是不同层次的图之间的转移，所以只需要按照题意在相邻的两层图之间连边跑最短路即可。显然假如所有方块的周期的最小公倍数是 $lcm$ ，那么所有位置相同、时间模这个公倍数相同的状态在转移上是完全一样的，可以看成是同一个状态，所以第 $lcm-1$ 层图应该向第 $0$ 层图连边。其它有些细节比如建立超级源点（它可以一直呆在最开始节点上不出去）和超级汇点方便敲代码就是分层图的基本操作了。

```cpp
#include<bits/stdc++.h>
//#define feyn
#define p(a,b) (a*(m+2)+b+2)
const int N=3000010;
const int M=1010;
const int R=12;
using namespace std;
inline void read(int &wh){
	wh=0;int f=1;char w=getchar();
	while(w<'0'||w>'9'){if(w=='-')f=-1;w=getchar();}
	while(w<='9'&&w>='0'){wh=wh*10+w-'0';w=getchar();}
	wh*=f;return;
}

inline int gcd(int s1,int s2){
	return s2==0?s1:gcd(s2,s1%s2);
}
inline int lcm(int s1,int s2){
	return s1*s2/gcd(s1,s2);
}

int m,lc=1,num[M],a[M][R];

struct edge{
	int t,v,next;
}e[N*3];
int head[N],esum;
inline void add(int fr,int to,int val){
	e[++esum]=(edge){to,val,head[fr]};head[fr]=esum;
}

int dis[N];
bool vis[N];
struct node{
	int pl,dis;
};
inline bool operator <(node s1,node s2){
	return s2.dis<s1.dis;
}
priority_queue<node>q;

signed main(){
	
	#ifdef feyn
	freopen("in.txt","r",stdin);
	#endif
	
	read(m);
	for(int i=1;i<=m;i++){
		read(num[i]);lc=lcm(lc,num[i]);
		for(int j=0;j<num[i];j++)read(a[i][j]);
	}
	num[0]=num[m+1]=1;
	//0 to 1
	//S to 0
	//m+1 to T
	for(int i=0;i<lc;i++){
		add(0,p(i,0),0);
		add(p(i,(m+1)),1,0);
		int nt=(i+1)%lc;
		add(p(i,0),p(nt,1),a[1][nt%num[1]]);
	}
	for(int i=1;i<=m;i++){
		for(int t=0;t<lc;t++){
			int nt=(t+1)%lc;
			add(p(t,i),p(nt,i),a[i][nt%num[i]]);
			add(p(t,i),p(nt,i+1),a[i+1][nt%num[i+1]]);
			add(p(t,i),p(nt,i-1),a[i-1][nt%num[i-1]]);
		}
	}
	
	memset(dis,0x3f,sizeof(dis));
	dis[0]=0;q.push((node){0,0});
	while(!q.empty()){
		node now=q.top();q.pop();
		int wh=now.pl,nd=now.dis;
		if(vis[wh])continue;vis[wh]=true;
		for(int i=head[wh],th;i;i=e[i].next){
			int nval=dis[wh]+e[i].v;th=e[i].t;
			if(nval<dis[th]){
				dis[th]=nval;q.push((node){th,dis[th]});
			}
		}
	}
	
	printf("%d",dis[1]);
	
	return 0;
}
```

---

## 作者：steambird (赞：1)

## 思路

### Step 1. 确定图论算法

这道题一开始最自然的思路是动态规划。但显然，动态规划的时间、空间复杂度与 Billy 的耗时有关，而这一耗时是不确定的，且由于 Billy 可以后退，最大耗时可能到达 $2 \times 10^5$ 的规模。因此，动态规划算法不能使用。

由周期性，我们可以考虑把每个周期为 $c_i$ 点拆成周期的最小公倍数个点（下面表示成 $(i,j)$）。记在 $t$ 时刻 $i$ 点处掉的血（代价）为 $a_{i,t}$，约定走到某个点时已经计算完这个点处掉的血，则这 $c_i$ 个点都有下面三种边连向其它点：

- 停留在原地，即连接到 $(i,(j+1) \bmod c_i)$，代价（边权，下同）为 $a_{i,(j+1) \bmod c_i}$；
- 向前走（可能没有），即连接到 $(i+1,(j+1) \bmod c_{i+1})$，代价为 $a_{i+1,(j+1) \bmod c_{i+1}}$；
- 向后走（可能没有），即连接到 $(i-1,(j+1) \bmod c_{i-1})$，代价为 $a_{i-1,(j+1) \bmod c_{i-1}}$。

在这样的状态定义下，从 $0$ 号点到 $n+1$ 号点的最小代价即为以 $0$ 号点出发到所有 $(n+1,k)$ 号点最短路距离的最小值。

由于周期满足 $c_i \le 10$，因此只需要取最小公倍数为 $l=2520$（$2520 = 5 \times 7 \times 8 \times 9$）。

整个程序只需要把图建出来，再跑最短路，最后汇总答案即可。

记最大周期为 $c$，则这一算法的时间复杂度 $O(nl \times \log(nl))$，空间复杂度 $O(n \times (l+c))$。

### Step 2. 优化算法的常数

按照上面的思路，可能拿到 $50 \sim 70$ 不等的分数，部分点可能会出现时间或内存超限（主要是后者）。

这里需要引入一个小的优化：我们没有必要把整张图建出来。如果将图的边都存下来，则内存极有可能超限。

将图的边存下来是因为在跑最短路时，我们需要知道有哪些边。事实上，这些边是我们推导而不是输入的，因此不必存下来。只需要改成在跑最短路时推导并直接应用推导结果即可。

这样，空间复杂度可以优化到 $O(nc)$，在不开启编译器优化的情况下也可通过本题。

## 代码

```c++
#include <iostream>
#include <vector>
#include <memory.h>
#include <limits.h>
using namespace std;

inline void train() {
	   ios::sync_with_stdio(false);
	   cin.tie(0);
	   cout.tie(0);
}

inline int mini(int a, int b) {
	return a < b ? a : b;
}

constexpr int N = 3e6+3;
constexpr int WIRE = 2520;
#define wiremod(x) ((x)%WIRE)
int heap[N], referrer[N], dis[N], heaprear = 1;

constexpr int PTR = 1003, K = WIRE+3;
short clen[PTR], c[PTR][13];
inline int assigning(int pid, int kid) {
	return pid*K+kid;
}

inline int decode_pid(int cid) {
	return cid/K;
}

inline int decode_kid(int cid) {
	return cid%K;
}

inline short getstat(int pid, int t) {
	return c[pid][t%clen[pid]];
}

inline void swaps(int &a, int &b) {
	int tmp = a;
	a = b;
	b = tmp;
}

inline void swapos(int a, int b) {
	swap(referrer[heap[a]], referrer[heap[b]]);
	swap(heap[a], heap[b]);
}

void adjust(int x) {
	if (x < 1 || x >= heaprear) return;
	// Can only upfloat -- can't downfloat
	if (((x>>1) >= 1) && dis[heap[x]] < dis[heap[x>>1]]) {
		swapos(x, x>>1);
		adjust(x>>1);
		return;
	}
	bool xhr = (x<<1) < heaprear;
	bool xahr = (((x<<1)|1) < heaprear);
	bool cmphr = xhr ? dis[heap[x]] > dis[heap[x<<1]] : false;
	bool cmpahr = xahr ? dis[heap[x]] > dis[heap[(x<<1)|1]] : false;
	bool ghr = xahr ? dis[heap[x<<1]] < dis[heap[(x<<1)|1]] : true;
	if (cmphr || cmpahr) {
		if (ghr) {
			// Go with LCH
			swapos(x, x<<1);
			adjust(x<<1);
			return;
		} else {
			// Go with RCH
			swapos(x, (x<<1)|1);
			adjust((x<<1)|1);
			return;
		}
	}
}

inline void depart(int source, int ptarget, int ttarget, int state) {
	if (dis[assigning(ptarget, ttarget)] > dis[source] + state) {
		dis[assigning(ptarget, ttarget)] = dis[source] + state;
		adjust(referrer[assigning(ptarget, ttarget)]);
	}
}

int main() {

	train();
	memset(dis, 0x3f, sizeof(dis));
	
	int n;
	cin>>n;
	clen[0] = 1;
	clen[n+1] = 1;
	for (int i = 1; i <= n; i++) {
		cin>>clen[i];
		for (int j = 0; j < clen[i]; j++) cin>>c[i][j];
	}
	dis[assigning(0, 0)] = 0;	// dis[0] = 0;
	heap[heaprear++] = assigning(0, 0);
	for (int i = 0; i <= n+1; i++) {
		for (int t = 0; t < WIRE; t++) {
			int cptr = assigning(i, t);	// 这里不存边，只分配节点
			referrer[cptr] = heaprear;
			heap[heaprear++] = cptr;
		}
	}
	int assigner = heaprear;
	for (int i = 0; i < assigner; i++) {
		int heaptop = heap[1];
		swapos(1, heaprear - 1);
		heaprear--;
		adjust(1);
		int pid = decode_pid(heaptop);
		int kid = decode_kid(heaptop);
      // 跑最短路时直接推导边并用以更新 dis
		if (pid > 0) {
			depart(heaptop, pid-1, wiremod(kid+1), getstat(pid-1, kid+1));
		}
		depart(heaptop, pid, wiremod(kid+1), getstat(pid, kid+1));
		if (pid < n+1) {
			depart(heaptop, pid+1, wiremod(kid+1), getstat(pid+1, kid+1));
		}
	}
	// You can arrive at n+1 at any time
	int ans = INT_MAX;
	for (int t = 0; t < WIRE; t++) {
		ans = mini(ans, dis[assigning(n+1, t)]);
	}
	cout<<ans<<endl;
	
//	cout<<flush;

	return 0;
}
```

---


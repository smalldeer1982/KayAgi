# [SDOI2005] 解环

## 题目背景

拜特兰并不总是一个非常民主的国家，也有一些阴暗的历史。一个美好的日子，拜特将军（该国的统帅）作了一个用以结束长期内战的决定，释放被关押的反对派。然而，他并未让反对派的领袖拜特萨直接自由，而是用一根“拜特链”将拜特萨锁在墙边.该链子由很多环和固定在墙上栅栏组成。尽管环并未和栅栏融合在一起，但想除去它们却非常困难。

“将军，你为什么要用链子将我锁在墙边而不让我自由！”拜特萨大叫道。

“拜特萨，你并未完全被链子锁住，我可以坦率的告诉你，你完全可以从栅栏上解下环。”拜特将军回答，同时他补充说，“但是，你必须在夜里工作，一个小时之内完成，不能弄出任何声音，否则，我将按有关法律治罪。”


## 题目描述

为了帮助拜特萨！链子上的环按整数1,2,…,n进行了编号。我们可以按照以下规则解开环：

    只有一个环时可以被连接到栅栏或从栅栏上拆开。

    第1号环总能进行连接或拆开

    如果1,...,k-1 (1<=k<n)环都被拆开，第k个环被连接时, 此时我们能连接或拆开 第k+1个环.


写一个程序：

输入描述了拜特链的构成,

计算拆除拜特链上全部环的最少操作次数,

将结果输出。


## 样例 #1

### 输入

```
4
1 0 1 0
```

### 输出

```
6```

# 题解

## 作者：revenger (赞：3)

一道找规律的好题【雾

在只有一个环n的时候，我们要拆下来这个环，就要装上环n-1，拆掉n，再拆掉n-1；

装上和拆掉一个环的步数是相同的。设t(n)表示对一个环n进行操作(拆下或者安上)需要的步数，可以得出t(n)=2\*t(n-1)+1,t(1)=1

再归纳总结一下，t(n)=2^n -1;

再观察有两个环的情况：我们设有环a,b(a>b)被连上，在拆下a之前我们一定会安装b，而安装b所需要的步数是t(b)，当b原本就被连接的情况下，我们就能从总步数中省下操作b的步数，所以总步数应为t(a)-t(b)。

观察有三个环的情况：设有环a,b,c(a>b>c)被连上，观察环a,b:根据上一条，原本的步数t(a)中省下了对b进行操作的步数，这里对b进行操作的步数本应为t(b),但是观察b,c我们发现:根据上一条，因为有了c的存在，导致此次对b的操作步数从t(b)变为了t(b)-t(c)。综合一下发现，对三个环a,b,c进行操作所需要的步数为t(a)-(t(b)-t(c))=t(a)-t(b)+t(c)。

对以上进行总结，能够推导出对于若干个环a,b,c,d,e,……(a>b>c>d>e>……)进行操作的步数应为t(a)-t(b)+t(c)-t(d)+t(e)……

预处理一下t数组，然后从后往前按照-和+的变化进行计算。

n<=1000，2^1000-1需要用高精度进行计算。

附代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
struct st{
    int a[1000];
    int len;
}t[1001],ans;
int f[1001],s[1001],n,x,m;
#define max(a,b) a>b?a:b
st rol(st x)
{
    st c=x;
    for(int i=c.len;i;i--)
    {
        c.a[i]<<=1;
        if(c.a[i]>9)
        c.a[i+1]++,c.a[i]-=10; 
    }
    if(c.a[c.len+1]) c.len++;
    return c;
}
st add(st x,st y)
{
    st c=x;
    c.len=max(c.len,y.len); 
    for(int i=1;i<=c.len;i++)
    {
        c.a[i]=c.a[i]+y.a[i];
        if(c.a[i]>9)
        c.a[i+1]++,c.a[i]-=10;
    }
    if(c.a[c.len+1]) c.len++;
    return c;
}
st sub(st x,st y)
{
    st c=x;
    for(int i=1;i<=c.len;i++)
    {
        c.a[i]-=y.a[i];
        if(c.a[i]<0)
        c.a[i]+=10,c.a[i+1]--;
    }
    while(!c.a[c.len]) c.len--;
    return c; 
}
void print(st x)
{
    for(int i=x.len;i>=1;i--)
    printf("%d",x.a[i]);
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&f[i]);
        if(f[i]) m=i;
    }
    x=2;
    for(int i=m;i;i--)
    if(f[i])
    {
        s[i]=x;
        x^=1;
    }
    t[1].len=t[1].a[1]=1;
    for(int i=2;i<=m;i++)
    {
        t[i]=rol(t[i-1]);
        t[i].a[1]++;
    }
    ans=t[m];
    for(int i=m-1;i;i--)
    {
        if(s[i]==2)
        ans=add(ans,t[i]);
        if(s[i]==3)
        ans=sub(ans,t[i]);
    }
    print(ans);
}
```

---

## 作者：qiyichen12 (赞：1)

# 题意简述
有数列 $a$ 可以有以下操作：
1. $a_1 = 1 \oplus a_1$ 即取反。
2. 当 $\sum_{i=0}^{k-1}a_i = 0$ 且 $a_k = 1$ 时 $a_{k+1} = 1 \oplus a_{k+1}$。

求至少几次使 $\sum a_i = 0$。
# 分析
首先分析 $\sum a_i = 1$ 时的次数。设 $a_{k+1} = 1$ 反推以前。

$\because a_k = 1$

$\therefore$ 上一步 $a_{k-1} = 1$

又 $\because \sum_{i=0}^{k-1}a_i = 0$

$\therefore $ 上上步 $a_{k-1} = 1$

$\vdots$

$\therefore2^n-1$ 步前~一切祥和~为初始状态。

~不严格地~得证 $\sum a_i = 1$ 时 $2^n-1$ 步解开。

再考虑 $\sum a_i \not= 1$ 的情况。可以两两分组，因为在取反 $a_i$ 时，$a_{\max\{j|j < i,a_j = 1\}}$ 必定也要被取反。

故省下 $2^{\max\{j|j < i,a_j = 1\}}-1$ 步。

所以，设 $ip_i$ 表示从大到小第 $i$ 个下标使得 $a_{ip_i} = 1$。
则答案为 $\sum_{i = 1}{(2^{a_{ip_i}}+1)\times(-1)^{i+1}}$。

由于数据范围是 $1\leqslant n\leqslant1000$，所以~开高精~用 python。

# AC Code

```python
n = int(input())
r = input().split()
s = 0
cnt = 0
for i in range(n):
    j = n-i-1
    if r[j]  == '1':
        if cnt % 2 == 0:
            s += (2**(j+1)-1)
            cnt += 1
        else:
            s -= (2**(j+1)-1)
            cnt += 1
print(s)
```

---

## 作者：Φρανκ (赞：1)

题意：给定一个长度为 $n$ 的序列和两种操作，求将序列所有项变为 $0$ 的最小操作次数。两种操作是：
- 改变 $a_1$
- 在 $a_1\sim a_{i-1}$ 为 $0$ ， $a_i$ 为 $1$ 时改变 $a_{i+1}$ 

核心思想：递推

解：

令 $f(n)$ 为改变 $n-1$ 个 $0$ 后的一个状态的最小操作数（如 $f(4)=0000\leftrightarrow 0001$ ）， $g(i)$ 为将给定序列的前 $i$ 项变为全 $0$ 的最小操作数。

易知 $f(1)=1$ 且 $\forall i>1,\:f(i)=2f(i-1)+1$ （先把第 $i-1$ 位变成 $1$ ，花一步把第 $i$ 位变成 $0$ ，再把第 $i-1$ 位变回 $0$ ），故 $f(i)=2^i-1$ 。

又可知有 $g(1)=a_1$ ，分类讨论递推方式：
1. 若 $a_i=0$ ，显然有 $g(i)=g(i-1)$ ；
2. 若 $a_i=a_{i-1}=1$ ，有 $g(i)=g(i-2)+1+f(i-1)=g(i-2)+2^{i-1}$ （先变成只有最后两位 $1$ ，再花费 $1+f(i-1)$ 步变成全 $0$ ）；
3. 若 $a_i=1$ 且 $a_{i-1}=0$ ，由于 $0\rightarrow 1$ 和 $1\rightarrow 0$ 在最后一位上是等价的，可以构造序列 $b_i$ 在且仅在 $i-1$ 项与 $a_i$ 相异。则也有 $g_a(i)=g_b(i-1)+1+f(i-1)=g_a(i-2)+2^{i-1}$ （因为 $b_{i-1}=0$ ， $g_b(i-1)=g_b(i-2)=g_a(i-2)$ ）。

对 $a_{i-2}$ 分类讨论可证对于所有序列，都有 $g_a(i-1)+g_b(i-1)=2^{i-1}-1$ ， $g_a(i)=2^{i-1}-1-g_a(i-2)+2^{i-1}=2^i-1-g_a(i-1)$ 。

用任一个递推式解均可。需要高精。

代码：
```
#include <bits/stdc++.h>
using namespace std;
int n, s[1001], a[1001][1001], pw[1001], flag;
int main()
{
	cin>>n;
	for(int i=1; i<=n; i++)
		cin>>s[i];
	if(s[1]==1)
		a[1][0]=1;//初始值
	pw[0]=1;
	for(int i=2; i<=n; i++)
	{
		for(int j=0; j<=1000; j++)
			pw[j]*=2;
		for(int j=0; j<=1000; j++)
		{
			pw[j+1]+=pw[j]/10;
			pw[j]%=10;
		}//计算2的幂
		if(s[i]==0)
			for(int j=0; j<=1000; j++)
				a[i][j]=a[i-1][j];//项为0
		else if(s[i-1]==1)
		{
			for(int j=0; j<=1000; j++)
				a[i][j]=a[i-2][j]+pw[j];
			for(int j=0; j<=1000; j++)
			{
				a[i][j+1]+=a[i][j]/10;
				a[i][j]%=10;
			}
		}//第一个递推式
		else
		{
			for(int j=0; j<=1000; j++)
				a[i][j]=pw[j]*2-a[i-1][j];
			a[i][0]--;
			for(int j=0; j<=1000; j++)
			{
				if(a[i][j]<0)
				{
					a[i][j+1]+=a[i][j]/10-1;
					a[i][j]=a[i][j]%10+10;
				}
				a[i][j+1]+=a[i][j]/10;
				a[i][j]%=10;
			}
		}//第二个递推式
	}
	for(int i=1000; i>=0; i--)
	{
		if(a[n][i]!=0)
			flag=1;
		if(flag==1)
			cout<<a[n][i];
	}//输出
	return 0;
}
```



---

## 作者：紊莫 (赞：0)

同 [P1805 关灯](https://www.luogu.com.cn/problem/P1805)。

这题困惑了我很久，所以写个题解。

首先，注意到这是一个递推的题，首先先考虑怎么把当前位置变掉，那么就需要把前面的数字变成 $00\dots01$ 的形式。

记 $f_n$ 表示前 $n$ 位变成全 $0$ 的操作次数，当前为 $0$ 时不再赘述。

当前为 $1$ 时怎么做呢？

首先要变成上述格式，然后改变当前位，就转化为了改变前 $n-1$ 位的做法，这里涉及到一张重要的图片。

![](https://cdn.luogu.com.cn/upload/image_hosting/r0ghp084.png)

简单模拟就能发现，由全 $0$ 到 $00\dots01$ 的形式一定是最长的变化路径，$f_n$ 的变化一定蕴含其中！

记 $g_n$ 为最长的变化路径长度（全 $0$ 到 $00\dots01$ 的形式所需步数）。

问题转化为求 $g$，考虑如下状态。

![](https://cdn.luogu.com.cn/upload/image_hosting/hhzjzbfo.png)

得到 $g_n=2g_{n-1}+1$，又已知 $g_1=1$，所以可以得到通项公式 $g_n=2^n-1$。

综上所述，得：

第一种情况不用操作 $f_i=f_{i-1}$。

第二种情况 $f_i=g_{i-1}-f_{i-1}+1+g_{i-1}=g_i-1+1-f_{i-1}=g_i-f_{i-1}$。

写到这里加上高精度即可。

[示例代码。](https://www.luogu.com.cn/paste/cs008zbv)


---

## 作者：scp020 (赞：0)

# P2438 [SDOI2005] 解环 题解

很明显的递推题，但是高精度。

## 解法

相信大家都对九连环的游戏有所了解。如果不拆除前面的环，那后面的环也就不能拆除。有依赖解系。

考虑设置状态。

题中要求所有环全部解下所用的步数，所以这里设置状态 $f$，$f_i$ 表示前 $i$ 个环全部解下所用的最少步数。由于第 $i$ 个环可以被操作的前提是前 $i-1$ 个环满足一定条件，所以只能从左到右顺序操作。现在考虑如何转移。

如果第 $i$ 个环本来就是灭的。那这个位置不用操作，$f_i = f_{i-1}$。

如果第 $i$ 个环本来是套上的，那这个位置需要操作。此时已经处理了前 $i-1$ 个环的情况。这里分两种情况讨论。

为了辅助这个过程，我们再设一个状态 $g$，$g_i$ 表示在前 $i$ 个环全部解下的情况下套上第 $i$ 个环所用的最少步数，这里等价于前 $i-1$ 个环全部解下、第 $i$ 个环套上的情况下使前 $i$ 个环全部解下所用的最少步数。题中说编号为 $1$ 的环可以随意解、套，所以 $g_1 = 1$。考虑 $g_2$。$g_2$ 即为套 $1$，套 $2$，解 $1$ 的最少步数，即为 $g_1 \times 2 + 1$。考虑 $g_i$，即为套 $i-1$，套 $i$，解 $i-1$ 的最少步数，即为 $g_i-1 \times 2 + 1$。利用数学归纳法：

$$\begin{aligned} &g_1 = 1 = 2^1 - 1 \\ &g_2 = g_1 \times 2 + 1 = (2^1 - 1) \times 2 + 1 = 2^1 + 1 = 2^2 -1 \\ &g_3 = g_2 \times 2 + 1 = (2^2 -1) \times 2 +1 = 2^3 - 2 + 1 = 2^3 - 1 \\ &g_i = g_{i-1} \times 2 + 1 = (2^{i-1} - 1) \times 2 + 1 = 2^i - 2 + 1 =2^i - 1\end{aligned}$$

得出结论：$g_i = 2^i - 1$。

- 如果第 $i-1$ 个环本来是套上的。则 $f_i = g_{i-1} - f_{i-1} + 1 + g_{i-1} = g_i - f_{i-1}$。
- 如果第 $i-1$ 个环本来是解下的的。则 $f_i = g_{i-1} - f_{i-2} + 1 + g_{i-1} = g_{i-1} - f_{i-2} + 1 + g{i-1} = g_i - f_{i-2} = g_{i} - f_{i-1}$。

综上，$f_i = \begin{cases}f_{i-1}&a_i = 0\\g_i - f_{i-1}&a_i = 1\end{cases}$。

高精度略。

## 代码

```cpp
#include<bits/stdc++.h>
template <typename T>
inline void swap(T &x,T &y)
{
	T tmp=x;
	x=y,y=tmp;
}
class high_accuracy
{
private:
	int len,a[5000];
public:
	inline int &operator[](const int &x)
	{
		return a[x];
	}
	inline int size()
	{
		return len;
	}
	inline high_accuracy()
	{
		len=0,a[0]=a[1]=a[2]=0;
	}
	inline void init(__int128 x)
	{
		len=0;
		if(x==0) len=1,a[1]=0;
		while(x) a[++len]=x%10,x/=10;
	}
	inline void deal(int l)
	{
		for(int i=1;i<=l;i++)
		{
			while(a[i]<0) a[i+1]--,a[i]+=10;
			a[i+1]+=a[i]/10,a[i]%=10;
		}
		len=l;
		while(!a[len]) len--;
	}
	inline void print()
	{
		for(int i=std::max(len,1);i;i--) std::cout<<a[i];
		std::cout<<"\n";
	}
	inline high_accuracy operator+(high_accuracy rhs)
	{
		high_accuracy ret;
		int le=std::max(len,rhs.size());
		for(int i=1;i<=le+3;i++) ret[i]=0;
		for(int i=1;i<=le;i++) ret[i]+=a[i]+rhs[i];
		ret.deal(le+2);
		return ret;
	}
	inline high_accuracy operator-(high_accuracy rhs) // 适用于 *this 比 rhs 大的情况
	{
		high_accuracy ret;
		int le=std::max(len,rhs.size());
		for(int i=1;i<=le+3;i++) ret[i]=0;
		for(int i=1;i<=le;i++) ret[i]+=a[i]-rhs[i];
		ret.deal(le+2);
		return ret;
	}
	inline high_accuracy operator*(high_accuracy rhs)
	{
		high_accuracy ret;
		for(int i=1;i<=len+rhs.size()+5;i++) ret[i]=0;
		for(int i=1;i<=len;i++) for(int j=1;j<=rhs.size();j++) ret[i+j-1]+=a[i]*rhs[j];
		ret.deal(len+rhs.size()+5);
		return ret;
	}
};
high_accuracy f[1010],pw[1010];
int n,a[1010];
int main()
{
	std::cin>>n,pw[0].init(1),pw[1].init(2),f[0].init(0);
	for(int i=1;i<=n;i++) std::cin>>a[i];
	for(int i=2;i<=n;i++) pw[i]=pw[i-1]*pw[1];
	if(a[1]) f[1].init(1);
	for(int i=2;i<=n;i++)
		if(a[i]) f[i]=pw[i]-pw[0]-f[i-1];
		else f[i]=f[i-1];
	f[n].print();
	return 0;
}
```


---

## 作者：Durancer (赞：0)

### P2438 [SDOI]解环

#### 知识点

- 高精

- 递推

#### 思路

手模样例可以得到操作方案

```cpp
step 1 :1 1 1 0
step 2 :0 1 1 0
step 3 :0 1 0 0
step 4 :1 1 0 0
step 5 :1 0 0 0
step 6 :0 0 0 0 
```
通过继续手模样例可以得到一个规律，在一个只有 $i$ 环连接的栅栏上，消去它得到只有 $i-1$ 环连接的栅栏，需要 $2^{i-1}$ 次操作，从一个 $0$ 串变成一个只有 $i$ 环连接的栅栏，也需要 $2^{i-1}$ 次操作。

这个题目的主要难点在于如何把初始状态转化成一个只有 $i$ 串连接的状态，如果转化成功，那么就直接可以？？？

突然发现不对劲，这应该是一个递推式的题目，所以重新找递推关系=_=。

我们发现，可以根据序列的序号进行递推：

$$f_i=\begin{cases} f_{i-1} \ \ (a_i=0)\\ \\2^{i}-f_{i-1}-1\ \ (a_i=1) \end{cases}$$
  
根据上面的规律推推试试就可以出来。
 
最后就是神奇的高精了而且这个高精因为无法进行与整形的运算，所以就直接在处理 $2^i$ 的时候减进去就好了。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<queue>
#include<stack>
#include<map>
using namespace std;
const int N=1509;
const int M=1e4+9;
int a[M];
int f[N][M];
int two[M][M];
int n;
int read()
{
	int f=1,x=0;
	char s=getchar();
	while(s<'0'||s>'9'){if(s=='-')f=-1;s=getchar();}
	while(s>='0'&&s<='9'){x=(x<<1)+(x<<3)+(s^'0');s=getchar();}
	return f*x;
}
void get_two(int a[],int b[])
{
	for(int i=1;i<=a[0];i++)
		b[i]=a[i]*2;
	b[1]++;//因为高精无法和整形减法，所以直接就再高精里做减法了
	for(int i=1;i<=a[0];i++)
	{
		b[i+1]+=b[i]/10;
		b[i]%=10;
	} 
	if(b[a[0]+1]>0) b[0]=a[0]+1;
	else b[0]=a[0];
}
void add(int two[],int f[],int F[])//2^{},fi-1,fi
{
	for(int i=1;i<=two[0];i++)
	{
		F[i]=two[i]-f[i];
	}
	for(int i=1;i<=two[0];i++)
	{
		if(F[i]<0)//易错点：F[i]<0 && F[i+1]>0 显然不对，减法都忘了/kk 
		{
			F[i]+=10;
			F[i+1]--;
		}
	}
	for(int i=two[0];i>=1;i--)
	{
		if(F[i]>0)
		{
			F[0]=i;
			break;
		}
	}
} 
void fu(int f[],int F[])
{
	for(int i=0;i<=f[0];i++)
		F[i]=f[i];
}
void prepare()
{
	two[1][0]=1;
	two[1][1]=1;
	for(int i=2;i<=n;i++)
		get_two(two[i-1],two[i]);
}
int main()
{
	n=read();
	for(int i=1;i<=n;i++)
		a[i]=read();
	prepare();
	if(a[1])
	{
		f[1][0]=1;
		f[1][1]=1;
	}
	for(int i=2;i<=n;i++)
	{
		if(a[i]==1)
			add(two[i],f[i-1],f[i]);
		else fu(f[i-1],f[i]);	
	}
	
	for(int i=f[n][0];i>=1;i--)
		printf("%d",f[n][i]);
	return 0;
}
```

---

## 作者：oneman233 (赞：0)

双倍经验：[P1805 关灯](https://www.luogu.org/problem/P1805)

我是打了个表，发现答案与这个字符串所表示的二进制数字有关系，其中二进制的最低位位于最左边
~~然后上oeis找的下面这个规律：~~

**a[n]=n^n/2^n/4^...^a/(2^m)**

其中：2^m<=n

答案会爆炸大，那么有高精度的地方就会有python！

代码如下：

```python
n=eval(input())
a=[float(n) for n in input().split()]
base=1
ans=0
for i in range(n):
    if a[i]==1:
        ans+=base
    base*=2
#print(ans)
out=0
base=1
while ans>=base:
    out^=ans//base
    base*=2
print(out)
```


---

## 作者：BFSBFSBFSBFS (赞：0)

~~最坏情况下.估计n>=13就因时间不够被治罪了..~~

题意.要想解开第$k$个环.先接上第$k-1$个环.并保证$1->(k-2)$都拆开.

求解开所有环最小步数..

暴力看看前几个..似乎和2进制下的步数有点像...

列出来..

```cpp
   原数   |   步数(B)  | 不1样的位置.. //解环次数.
1 0 0 0 0 | 1 0 0 0 0 | 0 0 0 0 0  //1
1 1 0 0 0 | 0 1 0 0 0 | 1 0 0 0 0  //2
0 1 0 0 0 | 1 1 0 0 0 | 1 0 0 0 0  //3
0 1 1 0 0 | 0 0 1 0 0 | 0 1 0 0 0  //4
1 1 1 0 0 | 1 0 1 0 0 | 0 1 0 0 0  //5
1 0 1 0 0 | 0 1 1 0 0 | 1 1 0 0 0  //6
0 0 1 0 0 | 1 1 1 0 0 | 1 1 0 0 0  //7
0 0 1 1 0 | 0 0 0 1 0 | 0 0 1 0 0  //8
1 0 1 1 0 | 1 0 0 1 0 | 0 0 1 0 0  //9
1 1 1 1 0 | 0 1 0 1 0 | 1 0 1 0 0  //10
0 1 1 1 0 | 1 1 0 1 0 | 1 0 1 0 0  //11
0 1 0 1 0 | 0 0 1 1 0 | 0 1 1 0 0  //12
1 1 0 1 0 | 1 0 1 1 0 | 0 1 1 0 0  //13
1 0 0 1 0 | 0 1 1 1 0 | 1 1 1 0 0  //14
0 0 0 1 0 | 1 1 1 1 0 | 1 1 1 0 0  //15
0 0 0 1 1 | 0 0 0 0 1 | 0 0 0 1 0  //16
注.从左往右由低位到高位.
```
这...不是...原数 = 步数 xor(^) 步数 >> 1 吗...

已知原数求步数....

设步数为$x$.原数为$n$.

看最高位的1.$x$与$n$位置1样的...

那么$x >> 1$第1位.

1定影响的$n$的第2位.0成1.1成0.

$n$第2位+$x >> 1$的第1位又能推出$x$的第2位.

然后又能知道$x >> 1$的第2位......

.....
```cpp
1 1 0 1 0 //原数.
_ _ _ 1 0 //步数.
_ _ 1 0 0 //步数 >> 1.
.
.
1 1 0 1 0 //原数.
_ _ 1 1 0 //步数.
_ 1 1 0 0 //步数 >> 1.
.
.
1 1 0 1 0 //原数.
_ 0 1 1 0 //步数.
0 1 1 0 0 //步数 >> 1.
.
.
1 1 0 1 0 //原数.
1 0 1 1 0 //步数.
0 1 1 0 0 //步数 >> 1.
```
然后得出..

若$x_i = 1$,$x_{i-1} = x_{i-1}\;xor\;1$.其中$i$需要从$n$到$2$枚举.

然后就是高精2进制转10进制了...

时间复杂度不超过$O(300n)$..$O(2n)$的空间..

Diu代码..

```cpp
program P2438;
 var
  a,f:array[0..1001] of longint;           //a为原数..f为步数..
  i,j,n,p:longint;
 begin
  readln(n);
  for i:=1 to n do
   read(a[i]);
  a[0]:=0;                                 //....
  readln;
  for i:=n downto 1 do
   if a[i]=1 then a[i-1]:=a[i-1] xor 1;    //迷之处理算步数.
  p:=1;
  f[p]:=0;
  for i:=n downto 1 do
   begin
    for j:=1 to p do
     f[j]:=f[j]<<1;                       //高精*2.
    j:=1;
    while j<=p do                         
     begin
      if f[j]>=10 then
       begin
        inc(f[j+1],f[j] div 10);
        f[j]:=f[j] mod 10;
        if p=j then inc(p);
       end;
      inc(j);
     end;
    inc(f[1],a[i]);                       //秦九韶....
   end;
  for i:=p downto 1 do
   write(f[i]);
  writeln;
 end.
```
(ಡωಡ).


---


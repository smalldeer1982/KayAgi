# [SDOI2010] 大陆争霸

## 题目背景

在一个遥远的世界里有两个国家：位于大陆西端的杰森国和位于大陆东端的克里斯国。两个国家的人民分别信仰两个对立的神：杰森国信仰象征黑暗和毁灭的神曾·布拉泽，而克里斯国信仰象征光明和永恒的神斯普林·布拉泽。

幻想历 $8012$ 年 $1$ 月，杰森国正式宣布曾·布拉泽是他们唯一信仰的神，同时开始迫害在杰森国的信仰斯普林·布拉泽的克里斯国教徒。

幻想历 $8012$ 年 $3$ 月 $2$ 日，位于杰森国东部小镇神谕镇的克里斯国教徒发动起义。

幻想历 $8012$ 年 $3$ 月 $7$ 日，神谕镇的起义被杰森国大军以残酷手段镇压。

幻想历 $8012$ 年 $3$ 月 $8$ 日，克里斯国对杰森国宣战。由数十万大军组成的克里斯军团开至两国边境，与杰森军团对峙。

幻想历 $8012$ 年 $4$ 月，克里斯军团攻破杰森军团防线进入神谕镇，该镇幸存的克里斯国教徒得到解放。

战争随后进入胶着状态，旷日持久。战况惨烈，一时间枪林弹雨，硝烟弥漫，民不聊生。

## 题目描述

幻想历 $8012$ 年 $5$ 月 $12$ 日深夜，斯普林·布拉泽降下神谕：“Trust me, earn eternal life.”克里斯军团士气大增。作为克里斯军团的主帅，你决定利用这一机会发动奇袭，一举击败杰森国。具体地说，杰森国有 $N$ 个城市，由 $M$ 条单向道路连接。神谕镇是城市 $1$ 而杰森国的首都是城市 $N$。你只需摧毁位于杰森国首都的曾·布拉泽大神殿，杰森国的信仰，军队还有一切就都会土崩瓦解，灰飞烟灭。

为了尽量减小己方的消耗，你决定使用自爆机器人完成这一任务。唯一的困难是，杰森国的一部分城市有结界保护，不破坏掉结界就无法进入城市。而每个城市的结界都是由分布在其他城市中的一些结界发生器维持的，如果想进入某个城市，你就必须破坏掉维持这个城市结界的所有结界发生器。

现在你有无限多的自爆机器人，一旦进入了某个城市，自爆机器人可以瞬间引爆，破坏一个目标（结界发生器，或是杰森国大神殿），当然机器人本身也会一起被破坏。你需要知道：摧毁杰森国所需的最短时间。


## 说明/提示

![](https://cdn.luogu.com.cn/upload/pic/1590.png)

![](https://cdn.luogu.com.cn/upload/pic/1591.png)

对于 $20\%$ 的数据，满足 $N\leq 15$，$M≤50$；

对于 $50\%$ 的数据，满足 $N\leq 500$，$M\leq 6\times 10^3$；

对于 $100\%$ 的数据，满足 $1\leq N\leq 3\times 10^3$，$1\leq M\leq 7\times 10^4$，$1\leq w_i\leq 10^8$。

输入数据保证一定有解，且不会存在维持某个城市结界的结界发生器在这个城市内部。

连接两个城市的道路可能不止一条，也可能存在一个城市自己到自己的道路。

## 样例 #1

### 输入

```
6 6
1 2 1
1 4 3
2 3 1
2 5 2
4 6 2
5 3 2
0
0
0
1 5
0
2 3 5```

### 输出

```
5```

# 题解

## 作者：bits (赞：28)

## 简述题意：

$m$条单向边连接$n$个城市，通过每边要$w_i$单位时间。从$1$开始，依次摧毁城市，**仅仅摧毁不用时间**，直到摧毁$n$结束。部分城市被别的城市保护，只有保护它的城市被摧毁后，才能摧毁这个城市。求结束的最短时间。

~~顺便翻译一下本题中唯一的英文句子：~~
> 神谕：“Trust me, earn eternal life.”

> “相信我，获得永恒的生命。”

**以上结果来自百度翻译。**

## 解法

由题可知，有的城市被保护。设$u$被$v$保护，我们从$v$建一条有向边到$u$，并记录$u$的入度$ind[u]$。广度遍历图，在摧毁$v$时，删去$v$到$u$的边，并更新入度。当$ind[u]=0$时，方可进入城市$u$。

设$arrive[i]$表示到达$i$的时间（可能要在门口等待）。设$into[i]$为进入$i$的时间（即什么时候所有保护$i$的城市被摧毁了）。设$dis[i]$表示摧毁$i$的时间，可得$dis[i]=max(arrive[i],into[i])$。设{ $j_n$ }为$i$的所有前驱，则$into[i]=max$ { $into[j_n]$ } 。

用Dijkstra跑一边最短路即可。

```cpp
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <queue>
using namespace std;

char ss[1<<17],*A=ss,*B=ss;//快读
inline char gc(){
    return A==B&&(B=(A=ss)+fread(ss,1,1<<17,stdin),A==B)?EOF:*A++;
}
template<typename qRead>
inline void qr(qRead &s){
    char c=gc(); 
    s=0;
    for(;c<'0'||c>'9';c=gc());
    for(;c>='0'&&c<='9';c=gc())
        s=(s<<1)+(s<<3)+(c-'0');
}

const int N=3001,M=200001;
//题目中没有说有多少对保护关系，所以开大点
struct Edge{//存储路径
    int node,next,val;
}edge[M];
int heade[N],n,m,tote;
struct Graph{//存储保护关系
    int node,next;
}graph[M];
int headg[N],totg;

struct qnode{
    int key,len;
    friend bool operator < (qnode x,qnode y){
        return x.len<y.len;//负的边权+大根堆，实际就是最短路
    }
};
int dis[N],into[N],ind[N],arrive[N];
bool vis[N];
priority_queue<qnode> q;

void dijkstra(int s){//模板
    for(int i=1;i<=n;i++)
        dis[i]=arrive[i]=1e9;
    dis[s]=into[s]=arrive[s]=0;
    ind[s]=0;
    q.push((qnode){s,0});
    int u,v;
    while(!q.empty()){
        u=q.top().key;
        q.pop();
        if(vis[u])
            continue;
        vis[u]=1;
        for(int k=heade[u];k;k=edge[k].next){
            v=edge[k].node;
            if(dis[u]+edge[k].val<arrive[v]){
                arrive[v]=dis[u]+edge[k].val;
                if(!ind[v]){//记得更新摧毁的时间~~~
                    dis[v]=max(into[v],arrive[v]);
                    q.push((qnode){v,-dis[v]});
                }
            }
        }
        for(int k=headg[u];k;k=graph[k].next){
            v=graph[k].node;
            into[v]=max(into[v],dis[u]);//摧毁当前节点，逐层删去保护关系
            ind[v]--;
            if(!ind[v]){//怎么有点像拓扑排序
                dis[v]=max(into[v],arrive[v]);
                q.push((qnode){v,-dis[v]});
            }
        }
    }
}

int main(){
    qr(n);
    qr(m);
    int x,y,l;
    while(m--){
        qr(x);
        qr(y);
        qr(l);
        edge[++tote].node=y;
        edge[tote].next=heade[x];
        edge[tote].val=l;
        heade[x]=tote;
    }
    for(int i=1;i<=n;i++){
        qr(x);
        while(x--){
            qr(y);
            ++ind[i];//建立保护关系
            graph[++totg].node=i;
            graph[totg].next=headg[y];
            headg[y]=totg;
        }
    }
    dijkstra(1);
    printf("%d\n",dis[n]);
    return 0;
}
```

---

## 作者：顾z (赞：19)

> ### Background
>
> 在一个遥远的世界里有两个国家：位于大陆西端的杰森国和位于大陆东端的克里斯国。两个国家的人民分别信仰两个对立的神：杰森国信仰象征黑暗和毁灭的神曾·布拉泽，而克里斯国信仰象征光明和永恒的神斯普林·布拉泽。
>
> 幻想历8012年1月，杰森国正式宣布曾·布拉泽是他们唯一信仰的神，同时开始迫害在杰森国的信仰斯普林·布拉泽的克里斯国教徒。
>
> 幻想历8012年3月2日，位于杰森国东部小镇神谕镇的克里斯国教徒发动起义。
>
> 幻想历8012年3月7日，神谕镇的起义被杰森国大军以残酷手段镇压。
>
> 幻想历8012年3月8日，克里斯国对杰森国宣战。由数十万大军组成的克里斯军团开至两国边境，与杰森军团对峙。
>
> 幻想历8012年4月，克里斯军团攻破杰森军团防线进入神谕镇，该镇幸存的克里斯国教徒得到解放。
>
> 战争随后进入胶着状态，旷日持久。战况惨烈，一时间枪林弹雨，硝烟弥漫，民不聊生。
>
> ### Description
>
> 幻想历8012年5月12日深夜，斯普林·布拉泽降下神谕：“Trust me, earn eternal life.”克里斯军团士气大增。作为克里斯军团的主帅，你决定利用这一机会发动奇袭，一举击败杰森国。具体地说，杰森国有N个城市，由M条单向道路连接。神谕镇是城市1而杰森国的首都是城市N。你只需摧毁位于杰森国首都的曾·布拉泽大神殿，杰森国的信仰，军队还有一切就都会土崩瓦解，灰飞烟灭。
>
> 为了尽量减小己方的消耗，你决定使用自爆机器人完成这一任务。唯一的困难是，杰森国的一部分城市有结界保护，不破坏掉结界就无法进入城市。而每个城市的结界都是由分布在其他城市中的一些结界发生器维持的，如果想进入某个城市，你就必须破坏掉维持这个城市结界的所有结界发生器。
>
> 现在你有无限多的自爆机器人，一旦进入了某个城市，自爆机器人可以瞬间引爆，破坏一个目标（结界发生器，或是杰森国大神殿），当然机器人本身也会一起被破坏。你需要知道：摧毁杰森国所需的最短时间。
>
> ### Input
>
> 输入文件的landcraft.in的第一行两个正整数N, M。
>
> 接下来M行，每行三个正整数ui, vi, wi，表示有一条从城市ui到城市vi的单向道路，自爆机器人通过这条道路需要wi的时间。
>
> 之后N行，每行描述一个城市。首先是一个正整数li，维持这个城市结界所使用的结界发生器数目。之后li个1~N之间的城市编号，表示每个结界发生器的位置。如果li = 0，则说明该城市没有结界保护，保证l1 = 0 。
>
> ### Output
>
> 输出文件landcraft.out仅包含一个正整数 ，击败杰森国所需的最短时间。

最短路问题,结果因为数组开小改了好久？？？

记录$dis[x]$代表到达$x$的最短时间。

记录$real[x]$代表到达$x$的实际时间。

对于每一个点,我们去更新其相连节点的时候要用$max(dis[x],real[x])$去更新。

然后注意**建立结界保护的边的时候建$li$到$i$的有向边。**

~~因为我搞不清所以直接建双向边~~

然后最后输出答案输出$max(dis[n],real[n])$即可。

``代码``

```c++
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<queue>
#define R register

using namespace std;

const int gz=5e4+8;

inline void in(R int &x)
{
	R int f=1;x=0;char s=getchar();
	while(!isdigit(s)){if(s=='-')f=-1;s=getchar();}
	while(isdigit(s)){x=x*10+s-'0';s=getchar();}
	x*=f;
}

int head[gz],tot,pr[gz],cnt,hd[gz];

struct cod{int u,v,w;}edge[gz<<1],e[gz<<1];

inline void add(R int x,R int y,R int z)
{
	edge[++tot].u=head[x];
	edge[tot].v=y;
	edge[tot].w=z;
	head[x]=tot;
}

inline void ado(R int x,R int y)
{
	e[++cnt].u=pr[x];
	e[cnt].v=y;
	pr[x]=cnt;
}

int dis[gz],real[gz],n,m;

bool vis[gz];

struct hop
{
	int u,d;
	bool operator <(const hop&a)const
	{
		return d>a.d;
	};
};

inline void dij()
{
	for(R int i=1;i<=n;i++)dis[i]=2147483644;
	priority_queue<hop>q;dis[1]=real[1]=0;
	q.push((hop){1,0});
	while(!q.empty())
	{
		R int u=q.top().u;q.pop();
		if(vis[u])continue;
		vis[u]=true;
		R int now=max(dis[u],real[u]);
		for(R int i=head[u];i;i=edge[i].u)
		{
			if(dis[edge[i].v]>now+edge[i].w)
			{
				dis[edge[i].v]=now+edge[i].w;
				if(hd[edge[i].v]==0)
					q.push((hop){edge[i].v,max(dis[edge[i].v],real[edge[i].v])});
			}
		}
		for(R int i=pr[u];i;i=e[i].u)
		{
			hd[e[i].v]--;
			real[e[i].v]=max(real[e[i].v],now);
			if(hd[e[i].v]==0)
				q.push((hop){e[i].v,max(real[e[i].v],dis[e[i].v])});
		}
	}
	printf("%d\n",max(real[n],dis[n]));
}

int main()
{
	in(n),in(m);
	for(R int i=1,x,y,z;i<=m;i++)
	{
		in(x),in(y),in(z);
		if(x==y)continue;
		add(x,y,z);
	}
	for(R int i=1,x;i<=n;i++)
	{
		in(x);hd[i]=x;
		for(R int fk;x;x--)
			in(fk),ado(fk,i),ado(i,fk);
	}
	dij();
}
```



---

## 作者：Mysterious04 (赞：15)

## 题目大意
~~原题目说这么长~~

给定一个有向图，经过每条边需要花费一定时间。每个节点都要在指定的一些节点到达后才可以被摧毁。求1到n花费的最少时间。
## 前置知识
首先我们根据题目求1到n的最短路径可以想到单源最短路径。

那我就来讲讲单源最短路径（Dijkstra方法，已经会了的可以跳过这部分）：

单源最短路径是求某一个点（称为源点）到其他所有点的最短路径。

Dijkstra主要思想是贪心。。。

将源点到其它所有点**目前**的最短路径存在一个dis[ ]数组中，dis[i]表示当前源点到点i的距离。初始时源点（假设为u）到其他点的dis赋为无穷大，dis[u]（也就是到自己的距离）赋为0。

每次选取dis最小的那一个点，拉出来，更新与其相连的所有点，这个操作称为松弛操作。松弛操作用了一个贪心的思想:因为当前dis已经是最小的了，用其他点更新不会比这个值更小对吧（也就是因为这一点这种方法不能处理负权边）。

这样我们就能~~很容易~~写出**纯**单源最短路径的代码（这里我用的STL的优先队列来保证每次取出dis最小的点）：
```cpp
struct node{
	int u;//节点编号
	ll dis;//源点到这个点的距离
	friend bool operator < (const node p,const node q){
		return p.dis>q.dis;//重载小于号，每次弹出dis最小的那个点
	}
};
priority_queue < node > heap;//使用优先队列（也叫堆）维护
void Dijkstra()
{
	while(!heap.empty())
	{//当堆不为空的时候进行松弛操作
		node t=heap.top();heap.pop();
		int now=t.u;
		if(book[now])continue;//已经更新过其他点说明已经确定不会更小了，就不用再更新一遍其他点咯
		book[now]=1;
		for(rint i=head[now];i;i=e[i].nxt)
		{
			int k=e[i].to;
			if(d[now]+e[i].w<d[k])//d[]就是上面说的dis数组
			{
				d[k]=d[now]+e[i].w;
				heap.push(node{k,d[k]});
			}
		}
	}
}
```
## 解法solution
学会了单源最短路径，我们发现这题还有点与众不同，那就是结界发生器！！！

其实对于这点信息，我们需要维护一个indeg数组，记录这个点还有多少重保护，当indeg[i]为0之后我们才能将这个点丢入堆中。期间也有一点需要处理：假设u点保护了i点，那么当我们用u点更新i点时，要将dis[i]赋值为max(dis[i],dis[u])，因为即使dis[i]较小，我们到达i点后也只能在门口等着，等到某个机器人摧毁u点后才能进入i点。所以更新时要将dis[i]赋为max(dis[u],dis[i])，同时将indeg[i]减1，并判断indeg[i]是否为0，若为0就将其丢入堆中。

剩下的细节与具体实现写在代码注释中，

贴上Code：
```cpp
#include<cstdio>
#include<cstring>
#include<queue>
int getmin(int x,int y){return x<y?x:y;}
int getmax(int x,int y){return x>y?x:y;}
//手写min与max函数比算法库<algorithm>中的要快
const int maxn=3000+50;
const int maxm=70000+50;
int n,m;
int son[maxn][maxn];//son[i]表示i所保护的城市编号
//我也不知道当时我为什么没有用vector...
int cnt[maxn];//cnt[i]表示i所保护的城市数量，当然用vector的话这个也不必要...
int indeg[maxn];每个点还受保护的层数
int d[maxn];//就是dis[]数组，因为结构体里重名了所以用的d
bool book[maxn];//这个点已经被用来更新其他点了没有
struct node{
	int u;
	int dis;
	friend bool operator < (const node p,const node q){
		return p.dis>q.dis;
	}
};
std::priority_queue < node > heap;
int rd()
{
	int s=0;
	char ch=getchar();
	while(ch<'0' || ch>'9')ch=getchar();
	while(ch>='0' && ch<='9')
	{
		s=(s<<3)+(s<<1)+(ch^48);
		ch=getchar();
	}
	return s;
}//快读部分，但好像并没有快多少

struct edge{
	int to;
	int nxt;
	int w;
}e[maxm<<1];
int head[maxn],tot;
void add(int x,int y,int z)
{
	tot++;
	e[tot].to=y;
	e[tot].w=z;
	e[tot].nxt=head[x];
	head[x]=tot;
}//链式前向星加边
int main()
{
	n=rd();m=rd();
	int x,y,z;
	for(int i=1;i<=m;i++)
	{
		x=rd();y=rd();z=rd();
		add(x,y,z);//注意是有向边
	}
	int temp;
	for(int i=1;i<=n;i++)
	{
		indeg[i]=rd();
		for(int j=1;j<=indeg[i];j++)
		{
			temp=rd();
			son[temp][++cnt[temp]]=i;//用vector就真的不必要这么复杂的读入了
		}
	}
	memset(d,0x7f7f7f7f,sizeof(d));//注意初始化哦
	d[1]=0;
	heap.push((node){1,0});//将源点丢进堆里，因为初始状态它到自己的距离最短，为0
	while(!heap.empty())
	{
		node nd=heap.top();heap.pop();//取出堆顶元素
		int now=nd.u;
		if(book[now])continue;
		book[now]=1;
		for(int i=head[now];i;i=e[i].nxt)
		{
			int k=e[i].to;
			if(d[now]+e[i].w<d[k])
			{
				d[k]=d[now]+e[i].w;
				if(indeg[k]==0)heap.push(node{k,d[k]});
			}
		}
		for(int i=1;i<=cnt[now];i++)
		{
			int sn=son[now][i];
			indeg[sn]--;
			d[sn]=getmax(d[sn],d[now]);//这就是此题的亮点
			if(indeg[sn]==0)heap.push((node){sn,d[sn]});//不受任何保护后才能将其丢入堆
		}
	}
	printf("%d",d[n]);
}
```

------------

P.S.真的非常推荐大家使用vector（也叫不定长数组）来替换掉上面的son[ ]数组与cnt[ ]数组，会方便许多，同时也可以省下一定空间（因为它是不定长的）。vector的主要操作如下：
1. vector.push_back(x)，将元素x插入vector中。
2. vector.size()读取数组的大小，也就是我代码中的cnt[ ]数组的作用。
3. vector也可以和静态数组一样直接使用下标读取，如vector[i]。但是注意一下，vector的下标是从0开始的，到vector.size()-1结束。

关于vector的代码实现在此就不多说了，留给大家自行思考。

---

## 作者：OIer_hsy (赞：11)

这道题，我看到许多julao用SPFA跑的，但本蒟蒻只会堆优化的Dij；

中心思想：除了dist数组以外，我们需要多开另外两个数组——reach[i] 表示到达这座城市的时间，really[i]表示实际能进入这座城市的时间；还有，用shd[i]表示一座城市上有多少盾，当shd[i]==0时，才可以进行更新操作；

复杂度 ~~其实我也不知道~~大概就是堆优化Dij的复杂度；

Dij代码在此 其实跟普通Dij差不多，只是需要再处理一次打破盾之后的更新，要用到盾之间的连边，前向星存，比较容易。
```
void dij(){
	FOR(i,1,n) dist[i]=reach[i]=inf;
	dist[1]=0,reach[1]=0,shd[1]=0,really[1]=0;//一定要初始化，
    //我最开始就忘了，结果卡死在样例
	q.push(make_pair(0,1));
	ll u,v,w;//u为当前堆中新取出的节点编号 v为每次用以更新的节点
    //w用处不大，但还是开了，意思自己看
	while(!q.empty()){
		do {
            u=q.top().second;
            q.pop();
        }while (!q.empty() && vis[u]);
        if (vis[u]) break;//已经到过的就不再处理
		vis[u]=1;
		for (int i=head[u];i;i=h[i].next){//遍历所有边
			v=h[i].to;
			w=dist[u]+h[i].w;
			if (w<reach[v]){
				reach[v]=w;
				if (shd[v]==0){//当护盾已经破了
					dist[v]=max(reach[v],really[v]);
					q.push(make_pair(-dist[v],v));
                    //把dist数组以负数存入，可以直接起到小根堆的作用
                    //无需另外的操作
				}
			}
		}
		for (int i=hp[u];i;i=nexp[i]){
			v=pro[i];
			really[v]=max(really[v],dist[u]);
			shd[v]--;//盾要减少一个
			if (shd[v]==0){
				dist[v]=max(reach[v],really[v]);
				q.push(make_pair(-dist[v],v));
			}//更新操作
		}
	}
	if (dist[n]!=inf) cout<<dist[n];
	else cout<<"Mission Failed";//诸位忽略这里，这是我们考试时写的，
    //题目有些不一样，但大致差不多，写上不会错。
}
```
好了，核心代码就长这样，理解之后也不是很难，如果你会了，就开始吧，别看下面了 ~~为我代码的丑陋掩面哭泣~~

下面放完整代码
```
#include<bits/stdc++.h>
#define FOR(i,a,b) for (register int i=a;i<=b;i++)
#define ROF(i,a,b) for (register int i=a;i>=b;i--)
#define inf 2147483647
#define ll long long
using namespace std;
struct edge{
	int next,to,w;
}h[200005];
priority_queue<pair<ll,ll> >q;
ll head[10005],tot,dist[10005];
ll pro[200050],cnt,hp[10050],nexp[200050],shd[10050];
ll reach[10050],really[10050],dis[10050];//请巨佬别看我丑陋的数组
bool vis[10005];
void add(int u,int v,int w){
	h[++tot].to=v;
	h[tot].w=w;
	h[tot].next=head[u];
	head[u]=tot;
}//前向星标准操作
//ps:如果不会，建议学一下，几乎所有图论题都能做。
int n,m;
void dij(){
	FOR(i,1,n) dist[i]=reach[i]=inf;
	dist[1]=0,reach[1]=0,shd[1]=0,really[1]=0;
	q.push(make_pair(0,1));
	ll u,v,w;
	while(!q.empty()){
		do {
            u=q.top().second;
            q.pop();
        }while (!q.empty() && vis[u]);
        if (vis[u]) break;
		vis[u]=1;
		for (int i=head[u];i;i=h[i].next){
			v=h[i].to;
			w=dist[u]+h[i].w;
			if (w<reach[v]){
				reach[v]=w;
				if (shd[v]==0){
					dist[v]=max(reach[v],really[v]);
					q.push(make_pair(-dist[v],v));
				}
			}
		}
		for (int i=hp[u];i;i=nexp[i]){
			v=pro[i];
			really[v]=max(really[v],dist[u]);
			shd[v]--;
			if (shd[v]==0){
				dist[v]=max(reach[v],really[v]);
				q.push(make_pair(-dist[v],v));
			}
		}
	}
	if (dist[n]!=inf) cout<<dist[n];
	else cout<<"Mission Failed";
}

int main(){
	scanf("%d%d",&n,&m);
	int u,v,w;
	FOR(i,1,m){
		scanf("%d%d%d",&u,&v,&w);
		add(u,v,w);//前向星存图，一开始以为是无向图，但其实是有向的
//		add(v,u,w);
	}
	FOR (i,1,n) {
        scanf("%d",&w);
		FOR(j,1,w) {
			scanf("%d",&u);
			shd[i]++;pro[++cnt]=i;
			nexp[cnt]=hp[u];hp[u]=cnt;//给盾的关系连边，也是前向星
            //只有一点不同，但不想再写函数了。
        }
	}
	dij();//出发了！！！
	return 0;
}
```

第一篇题解，求过！orz

---

## 作者：7KByte (赞：7)

这里提供一个不同的思维过程


观察题面，我们很容易想到一个暴力的贪心
>先把没有结界且能到达的城市炸了，同时破坏一些城市结界，再炸没有结界且能到达的城市，一直循环下去直到炸掉首都

显然时间复杂度是$O(N*(N+M)logN)$，不能很好的解决问题

考虑优化

我们没有必要一定按照顺序：先炸能炸的，再拆结界，再炸，再拆……

我们把炸和拆一起做，用堆按照时间顺序维护事件集合

定义$d[x]$表示城市$x$最早在时刻$d[x]$被炸

最开始$1$号城市被炸

每次从堆中取出时间最早的。首先$Check$一下在该城结界发生器被摧毁后哪些城市没有了结界保护（记录入度即可），没有保护之后机器人是否能到达（看该城的有入边的城市是否已经被炸），如果能到达，$d[x]=min(d[x],max(d[in]+val,d[now]))$，其中$now$表示堆中取出的城市，$x$表示失去保护的城市，$in$表示一个被炸的城市且有边$in->x$

然后扫描$now$的每条出边，如果有没有保护且没有被炸的城市就直接把它炸了$d[y]=min(d[y],d[x]+val)$

注意被炸的城市要压到堆里

---------------

等等，我发现了什么，这不就是$Dij$的过程吗，取$min$的过程不就是松弛的过程

于是我们切题了

$O((N+M)logN)$

```cpp
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define N 3005
using namespace std;
int n,m,h[N],tot;
struct edge{
	int to,nxt,val;
}e[80008];
vector<int>a[N];
vector<pair<int,int> >u[N];
void add(int x,int y,int z){
	e[++tot].to=y;e[tot].val=z;e[tot].nxt=h[x];h[x]=tot;
	u[y].push_back(make_pair(x,z));
}
int in[N],d[N],v[N];
priority_queue<pair<int,int> >q;
void dij(){
	memset(d,0x3f,sizeof(d));
	q.push(make_pair(0,1));d[1]=0;
	while(!q.empty()){
		int x=q.top().second;q.pop();
		v[x]=1;
		rep(i,0,(int)(a[x].size()-1)){
			int y=a[x][i];
			in[y]--;
			if(!in[y]){
				rep(j,0,(int)(u[y].size()-1))
				  d[y]=min(d[y],max(d[u[y][j].first]+u[y][j].second,d[x]));
				q.push(make_pair(-d[y],y));
			}
		}
		for(int i=h[x];i;i=e[i].nxt)
		  if(!v[e[i].to]&&!in[e[i].to])
		    if(d[e[i].to]>d[x]+e[i].val)
		      d[e[i].to]=d[x]+e[i].val,q.push(make_pair(-d[e[i].to],e[i].to));
		while(!q.empty()&&v[q.top().second])q.pop();
	}
}
int main(){
	scanf("%d%d",&n,&m);
	rep(i,1,m){
		int x,y,z;scanf("%d%d%d",&x,&y,&z);
		add(x,y,z);
	}
	rep(i,1,n){
		int t;scanf("%d",&t);
		rep(j,1,t){
			int x;scanf("%d",&x);
			a[x].push_back(i);
			in[i]++;
		}
	}
	dij();
	printf("%d\n",d[n]);
	return 0;
}
```

---

## 作者：Durancer (赞：6)

## 上图理解极佳

![](https://cdn.luogu.com.cn/upload/image_hosting/yr9ugmqz.png)

因为想象力有限，只能借助原图和我卑微的画技了（如有不妥请dalao们提出）

### 1、思路

首先，这个题与正常的最短路问题就是它的部分点多了好几个屏障；
因为机器人是无数的，所以我们不需要考虑这个问题，每次都看作无限机器人就可以了

自己的思路：在输入屏障的时候，把城市的保护膜数量以及某一个城市保护的每个城市的序号（二维数组存）存下来，在每一次有保护城市的时候进行爆破-1就可以了（不理解的话代码中有详细解释）

### 2、细节

因为有屏障的限制,我们每次放进队列里进行松弛操作的数也会有限制，那么在这里我们会有一种思想，当一个城市被爆破完之后，机器人可以立刻进入（假设机器人是在屏障外面等着的）那么在摧毁屏障的时候顺便更新一下到达已经完全消除屏障的城市时间也就是（dis）。而且要注意如果机器人率先到达并且破坏了屏障，这个时候我们要取到达时间最大的！

### 3、样例演示（此处按照时间顺序来演示）

当time=1时，机器人到达2 此时更新dis[2]为1,

当time=2时，机器人到达3 此时更新dis[3]为2，此时在3点进行爆破，炸掉了6的一层屏障，更新dis[6]为2

当time=3时，机器人到达4,5，此时更新dis[4],dis[5]为3，然后在5这个点进行爆破
炸掉了4的屏障（释放了），然后对比一下到达4，和5的时间取最大值更新dis[4]然鹅还是3，6的屏障被炸掉了一层，释放；

当time=5时（因为当时松弛操作5->3时没有成立，3没有被放进队列中），6点没有屏障可以到达（也就是到达了它的中心），然后更新此时的dis[6]为5

最后输出5

（在代码中先更新的dis[6]为5，然后与dis[3]比较取最大值的）；

#### 注意点：样例解释的时候有一些在队列里运行的顺序是不同的，在这里用这个更加实际的例子来解释一下代码的功能实现，具体解释在代码中
------------

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#include<stack>
#include<queue>
#include<cmath>
using namespace std;
int n,m;
int cnt[100009],boom[3009][3009],e_num,head[100009],ind[100009],v[100009];
//cnt 是指第i个城市保护的城市的数量，boom表示的是第i个城市保护的第j个城市的序号
//ind是指这个城市还有没有被保护？？如果入度为0则不会被保护了；,v就是dij的标配了，这里不做解释 
int dis[100009];
struct node{
	int diss;
	int x;
	inline bool operator<(const node &x)const
	{
		return diss>x.diss; 
	} 
}; //dij的堆优化，重载运算符，我太弱了，只能背上去； 
struct edge{
	int dis,last,to; 
}e[70009]; 
int Edge(int from,int to,int dis)//链式前向星存边！！！ 
{
	e[++e_num].last=head[from];
	e[e_num].to=to;
	e[e_num].dis=dis;
	head[from]=e_num;
}
int djstm()//忽略我可爱的函数名字 
{
	memset(dis,0x3f3f3f3f,sizeof(dis));//先把所有的距离都赋上一个极大值 
	dis[1]=0;//把到第一个点的时间设为0 
	priority_queue<node> q;//优先队列存储 
	q.push((node){0,1});//dij的堆优化的模板！，这个就不详细解释啦 
	while(!q.empty())
	{
		node pak=q.top();
		q.pop();
		int u=pak.x;
		if(v[u]==1) continue;
		v[u]=1;
		for(int i=head[u];i;i=e[i].last)
		{
			int go_=e[i].to;
			if(dis[go_]>dis[u]+e[i].dis)
			{
				dis[go_]=dis[u]+e[i].dis;//注意这个点，大家应该有疑惑，如果go_这个点没有完全破坏完结节点，为什么还会被赋值呢？
				//这就涉及到下面一个处理了，在下面我会解释 
				if(ind[go_]==0)//当这个城市没有被保护的时候那么就把他放进队列里，继续找 
				{
					q.push((node){dis[go_],go_});
				}
			}	
		}
		for(int i=1;i<=cnt[u];i++)//找当前点是否有结界 
		{
			ind[boom[u][i]]--;//搜索当前堆里的最前的点，然后枚举他的每一一个保护的结界 （因为机器人可以无限多，所以可以无限破坏） 
			int kk=boom[u][i];
			dis[kk]=max(dis[kk],dis[u]);//这里注意，当一个点的结界没有被破坏时，我们在上面的处理中可能会给他赋过值
			//因为在现实情况下没有破坏结界的城市是不能到达的，所以机器人只能在哪里等着，那么我们现在就可以取当前的最大值给他赋值
			//这样就符合实际情况了 
			if(ind[boom[u][i]]==0)
			{
				q.push((node){dis[kk],kk});//这上面已经赋值了，相当于做了最短路的优化，所以就直接把没有结界的城市放进去就完事了
				//因为这是dij堆优化，答案一定是最优的，所以不用考虑其他问题 
			}
		}
	}
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int x,y,z;
		cin>>x>>y>>z;
		if(x!=y)
		{
			Edge(x,y,z);	
		}//建边，这个判断防止hack数据 
	}
	for(int i=1;i<=n;i++)
	{
		cin>>ind[i];//输入每个城市被多少城市所保护 
		
		for(int j=1;j<=ind[i];j++)//输入每个城市的编号 
		{
			int to_;
			cin>>to_;
			boom[to_][++cnt[to_]]=i;//表示to_保护的第cnt[to_]个城市的编号；
		} 
	}
//	for(int i=1;i<=n;i++)
//	{
//		cout<<"i="<<i<<endl;
//		for(int j=1;j<=cnt[i];j++)
//		{
//			cout<<boom[i][j]<<" ";
//		}
//		cout<<endl;
//	}调试的代码 
	djstm(); 
	cout<<dis[n];//最后输出就可！ 
	return 0;//完结！！ 
}
```


---

## 作者：MloVtry (赞：6)

为了满足限制，我们需要知道一个点，最早能到达的时间 以及 最早能进入的时间

具体的：

d1，最短路，表示    最早能到达的时间


d2，其前驱节点中d1（为了方便描述，实际上是D）的max，表最早能进入


那么D（表示实际最短时间）=max（d1，d2）

（d2应该由D推出）

可以用迪杰斯特拉来操作

每一次选择D最小的点，用它来更新它相连的节点的d1，以及它能打开的点的d2

记录每一个节点的度，表示打开这个节点要炸几个前驱节点

那么当一个点度为0之后，才可以用来更新，才能放进堆里

到这里就结束了，贴一下堆优化的代码

```cpp
#include<iostream>
#include<cstring>
#include<vector>
#include<cstdio>
#define M 70010
#include<queue>
#define N 3010
using namespace std;
struct node
{
    int id;
    int d;
    bool operator < (const node &rhs) const
    {
        return rhs.d<d;
    }
};
priority_queue<node> q;
int n,m,head[N],to[M],e,len[M],Next[M];
void buid(int u,int v,int l)
{
    Next[++e]=head[u];head[u]=e;
    to[e]=v;len[e]=l;
}
int s[N][N],vis[N];
int d1[N],d2[N],d[N]; 
void dj()
{
    d1[1]=0;
    q.push((node){1,max(d1[1],d2[1])});
    while(!q.empty())
    {
        node top=q.top();q.pop();
        if(vis[top.id]) continue;
        if(top.d!=max(d1[top.id],d2[top.id])) continue;
        for(int i=head[top.id];i;i=Next[i])
        {
            int j=to[i];
            if(d1[j]>top.d+len[i])
            {
                d1[j]=top.d+len[i];
                if(!d[j]) q.push((node){j,max(d1[j],d2[j])});
            }
        }
        for(int i=1;i<=s[top.id][0];++i)
        {
            d[s[top.id][i]]--;
            if(!d[s[top.id][i]])
            {
                d2[s[top.id][i]]=top.d;
                q.push((node){s[top.id][i],max(d1[s[top.id][i]],d2[s[top.id][i]])});
            }
        }
    }
    printf("%d",max(d1[n],d2[n]));
}
int main()
{
    scanf("%d%d",&n,&m);
    memset(d1,20,sizeof(d1));
    for(int i=1;i<=m;++i)
    {
        int u,v,l;scanf("%d%d%d",&u,&v,&l);
        buid(u,v,l);
    }
    for(int i=1;i<=n;++i)
    {
        scanf("%d",&d[i]);
        for(int j=1;j<=d[i];++j)
        {
            int it;scanf("%d",&it);
            s[it][++s[it][0]]=i;
        }
    }
    dj();
    return 0;
}
//这次活动不是打德国佬吗？47呢47呢=，=
//今天也依旧没有捞到岛风厌战47呢
//甚至还把弹弹打没了

```

---

## 作者：Cry_For_theMoon (赞：5)

&emsp;&emsp;[传送门](https://www.luogu.com.cn/problem/P2446)

&emsp;&emsp;如果 $v$ 被 $u$ 保护，就连一条 $u->v$ 的边。如果点 $i$ 会影响最后的答案，那么点 $i$ 一定不处于环上，否则就无解了（攻破自己得先攻破自己）；如果不会影响，那么视作无环也没关系，因为对最后的答案一点影响也没有，综上所述，我们大体可以认为这张图是 DAG

&emsp;&emsp;既然攻破一个点，得先攻破它的所有前驱，先设 1 至 $i$ 的最短路为 $dis_i$，则显然攻破一个点的时间 $dest_i = max(max(dest_j),dis_i)$，$j$ 是 $i$ 的前驱。所以显然而然就会最短路板子+拓扑+DP。

&emsp;&emsp;所以你就会获得10分的好成绩（还可能爆零

&emsp;&emsp;考虑错误的原因：一个点的 $dest$ 和它的 $dis$ 有关，假设这条最短路径经过了这个点保护的某个点，实际上你是不可以走这条路径的，但是你走了，因此答案会被你搞的很小（因为实际上需要花更多的时间绕路）

&emsp;&emsp;不过转移方程肯定一点错误都没有。因为是正权图，所以你会发现对于一条边 $j->i$， $dest_j < dest_i$，这个显然易得，那么首先我们改成按照 $dest_i$ 从小到大转移。你说按 $dest_j$ 转移 $dis$ 不会有误？事实上我们已经发现 $dis_i$ 的定义已经变了，合法的路径变成了不包括 $i$ 保护（或 $i$ 保护的点保护的点...）的点，且权值变成了 $dest$（因为如果有护罩你得先摧毁才能走） 被保护点的时间。因此每次选用最小的 $dest_j$ 去转移的时候，保证了不会出现 $i$ 保护的（或者间接保护的）点，同时又保证所有可能对一个点的 $dis_i$ 造成影响的与 $i$ 相连的 $j$ 都被考虑到，因为如果 $dest_j >= dest_i$，那么花费 $dest_j$ 摧毁第 $j$ 个点再走过来的时候，已经不是 $dest_i$ 了。所以本题应该按 $dest_j$ 从小到大转移。

&emsp;&emsp;再来具体讲讲转移方法。设 $safe_i$ 是可以进入点 $i$（即攻破点 $i$ 的所有保护城市的时间），则 $safe_i = max(dest_j)$，$j$ 是 $i$ 的前驱（保护城市）。

&emsp;&emsp;原来的方程就变成了 $dest_j = max(safe_j,dis_j)$，转移 $i$ 的时候枚举 $i$ 的后继对其更新 $safe$，如果一个点的前驱全都转移过了（这个转移的时候顺带计算），那么直接推 $dest$ 并且加入堆中（本来尝试 $O(n)$ 扫 $dest$ 发现好像初始化有点问题？）

&emsp;&emsp;$dest$ 的方程不仅和 $safe$ 有关，还和 $dis$ 有关，此时能推 $dest$ 的条件（在转移 $dis$时）一样：前驱都转移过了，即 $safe$ 已经推出了，所以每次更新 $dis$ 的时候，如果这个点推出来了 $safe$，就再推一遍 $dest$ 然后加入堆中。

&emsp;&emsp;大概就这样（你也可以看作对第一篇题解的详细说明？？？），于是一个既像拓扑又像最短路的题就出来了： 

```cpp
//SDOI,2010
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;
const int MAXN=3e3+10,MAXM=7e4+10,MAXM2=1e6+10;
const long long INF=1e14;
struct Edge{
	int u,v;
	long long w;
}edge1[MAXM],edge2[MAXM2];
int first1[MAXN],next1[MAXM],first2[MAXN],next2[MAXM2],tot1,tot2,cnt[MAXN];
long long safe[MAXN],dest[MAXN]; 
long long dis[MAXN];
bool vis[MAXN];
int n,m;
struct Node{
	int u;long long v;
	bool operator<(const Node& n2)const{
		return v > n2.v;
	}
};
priority_queue<Node>h; 
inline void addedge(int pos,int u,int v,long long w){
	if(pos==1){
		edge1[++tot1].u=u;edge1[tot1].v=v;edge1[tot1].w=w;
		next1[tot1] = first1[u];first1[u] = tot1;
	}else{
		edge2[++tot2].u=u;edge2[tot2].v=v;edge2[tot2].w=w;
		next2[tot2] = first2[u];first2[u] = tot2;
	}
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1,u,v,w;i<=m;i++){
		scanf("%d%d%d",&u,&v,&w);
		addedge(1,u,v,w);
	}
	for(int i=1,l,fa;i<=n;i++){
		scanf("%d",&l);
		for(int j=1;j<=l;j++){
			scanf("%d",&fa);
			addedge(2,fa,i,0);
		}
		cnt[i] = l;
	}
	for(int i=2;i<=n;i++){
		dis[i] = dest[i] = INF;
	}
	h.push((Node){1,0});
	while(!h.empty()){
		Node now = h.top();h.pop();
		int u = now.u;
		if(vis[u])continue;
		vis[u] = 1;
		for(int j=first1[u];j;j=next1[j]){
			int v = edge1[j].v;
			if(dis[v] > dest[u] + edge1[j].w){
				dis[v] = dest[u] + edge1[j].w;
				dest[v] = max(safe[v],dis[v]);
				if(!cnt[v]){
					dest[v] = max(safe[v],dis[v]);
					h.push((Node){v,dest[v]});
				}
			}
		}
		for(int j=first2[u];j;j=next2[j]){
			int v = edge2[j].v;
			safe[v] = max(safe[v],dest[u]);
			cnt[v]--;
			if(!cnt[v]){
				dest[v] = max(safe[v],dis[v]);
				h.push((Node){v,dest[v]});
			}
		}
	}
	printf("%lld",dest[n]);
	return 0;
}
```

&emsp;&emsp;总结：关于 DP 的大体思路其实来点开这道紫题的都不难想，然后只要发现 $dis$ 不是裸的最短路，计算的是 $dest$ 的最短路，然后发现对一个点的 $dest$ 影响的点的 $dest$ 都比它小，那么用类似 Dijkstra 堆优化的做法就可以过去了



---

## 作者：ModestCoder_ (赞：4)

**连接两个城市的道路可能不止一条，也可能存在一个城市自己到自己的道路。**

接下来M行，每行三个正整数ui, vi, wi，表示有一条从城市ui到城市vi的**单向道路**，自爆机器人通过这条道路需要wi的时间。

好了，以上是本题坑点

一看不是特别好做，想到最短路

记录两个量$dis,open$分别表示最短路与将所有保护自己的结界摧毁所需最短时间
那么对于一个点真正的最短路=$max(dis,open)$

用$dij$分别求$dis$与$open$就行了

注意一个点入队的条件是所有保护它的结界都已摧毁

Code：

```cpp
#include <bits/stdc++.h>
#define maxn 100010
using namespace std;
struct Edge{
	int to, next, len;
}edge[maxn << 1], e[maxn << 1];
int num, head[maxn], Num, Head[maxn], vis[maxn], dis[maxn], open[maxn], in[maxn], n, m;
struct node{
	int val, len;
	bool operator < (const node &x) const{ return x.len < len; }
};
priority_queue <node> q;

inline int read(){
	int s = 0, w = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') w = -1;
	for (; isdigit(c); c = getchar()) s = (s << 1) + (s << 3) + (c ^ 48);
	return s * w;
}

void addedge(int x, int y, int z){ edge[++num] = (Edge){y, head[x], z}, head[x] = num; }
void add(int x, int y){ e[++Num] = (Edge){y, Head[x], 0}, Head[x] = Num; }

int main(){
	n = read(), m = read();
	for (int i = 1; i <= m; ++i){
		int x = read(), y = read(), z = read();
		if (x == y) continue;
		addedge(x, y, z);
	}
	for (int i = 1; i <= n; ++i){
		in[i] = read();
		for (int j = 1; j <= in[i]; ++j) add(read(), i);
	}
	for (int i = 2; i <= n; ++i) dis[i] = 2e9;
	q.push((node){1, 0});
	while (!q.empty()){
		node tmp = q.top(); q.pop();
		int u = tmp.val, d = max(dis[u], open[u]);
		if (vis[u]) continue;
		vis[u] = 1;
		for (int i = head[u]; i; i = edge[i].next){
			int v = edge[i].to;
			if (dis[v] > d + edge[i].len){
				dis[v] = d + edge[i].len;
				if (!in[v]) q.push((node){v, max(dis[v], open[v])});
			}
		}
		for (int i = Head[u]; i; i = e[i].next){
			int v = e[i].to;
			--in[v], open[v] = max(open[v], d);
			if (!in[v]) q.push((node){v, max(dis[v], open[v])});
		}
	}
	printf("%d\n", max(dis[n], open[n]));
	return 0;
}
```


---

## 作者：Taduro (赞：3)

这题用dijkstra做。

思路：当我们要到一个点时，首先要把保护它的点全部炸掉，不然即使它离得再近也无法到达，炸保护它的点的事情和去这个点可以同时做，所以到达或炸掉一个点的时间为到这个点的最短路径和到保护它的点的最短路径之间的最大值。入队时先将没有被保护且距离最近的点入队，用它更新它保护的点的距离。

具体实现见代码
```
#include<iostream>
#include<cmath>
using namespace std;
struct node{
	int next,to,v;
}w[140001];
int i,j,k,n,m,x,y,z,s[3001];//s就是dis啦
int head[3001],b[3001][3001],o[3001],f[3001][3001];
//f表示一个点保护的点（后继），b表示保护这个点的点（前驱）
//点i的后继（前驱）个数存在f[i][0](b[i][0])中
//o用来存点是否入队
int main(){
	cin>>n>>m;
	for (i=1; i<=m; i++){
		cin>>x>>y>>z;
		w[i].to=y; w[i].v=z;
		w[i].next=head[x];
		head[x]=i;
	}
	for (i=1; i<=n; i++){
		cin>>b[i][0];
		for (j=1; j<=b[i][0]; j++){
			cin>>b[i][j];
			f[b[i][j]][0]++;
			f[b[i][j]][f[b[i][j]][0]]=i;//存后继，思路比较扭曲
            //b[i][j]的第f[b[i][j]][0]个后继是i
		} 
	}
	for (i=0; i<=n; i++) s[i]=1e17;
	s[1]=0; o[1]=1; k=1;
	while (k!=0&&k!=n){//算法主题
		for (j=head[k]; j; j=w[j].next){
			if (s[w[j].to]>s[k]+w[j].v){
				s[w[j].to]=s[k]+w[j].v;
			}
		}
		for (j=1; j<=f[k][0]; j++){
			b[f[k][j]][0]--;       //k的第j个后继的前驱数-1，比较扭曲
			s[f[k][j]]=max(s[f[k][j]],s[k]);
		}
		o[k]=1; k=0;
		for (j=1; j<=n; j++){
			if (s[j]<s[k]&&!o[j]&&b[j][0]==0) k=j;
		}
	}
	cout<<s[n];
	return 0;
}```

---

## 作者：dz_ice (赞：2)

这题的n的范围有点小，我的dijkstra~~不加堆优化都能过~~

看完题目你会发现，到达一个城市有一个先决条件，就是要摧毁所有维持这个城市结界的所有结界发生器，那么到达这座城市的最短路径便为
###### **到达最后一个被摧毁的结界发生器所在城市的最短路径与到达这座城市的最短路径的最大值**

知道了这最重要的一点，其他的也就是写一遍dijkstra，代码也就呼之欲出了

还要注意！！题目给的是有向边！！而且还要开long long

下面是我的代码，挺短的，应该挺好理解
```
#include<bits/stdc++.h>
using namespace std;
long long n,m,x,y,w;
long long min1,t,a,gen,dis[3003],sum[3003],vis[3003]; //sum[i]表示i节点的结界数量，全部被摧毁才能走到 
vector<long long>l[3003],l1[3003],jie[3003]; //l数组和l1数组存图，jie[i]用来表示i节点用结界保护着哪些城市 
int main()
{
	cin>>n>>m;  
	for(long long i=1; i<=m; i++)
	{
		cin>>x>>y>>w;
		if(x!=y)
			l[x].push_back(y),l1[x].push_back(w); //vector存图 
	}
	for(long long i=1; i<=n; i++)
	{
		dis[i]=1e16; //顺便初始化一下 
		cin>>sum[i];
		for(long long j=1; j<=sum[i]; j++)
		{
			cin>>a;
			jie[a].push_back(i); //a节点保护着i节点 
		}
	}
	dis[1]=0;
	for(long long i=1; i<=n; i++)
	{
		min1=1e16;
		for(long long j=1; j<=n; j++)
			if(dis[j]<min1&&vis[j]==0&&sum[j]==0) //结界发生器全部被摧毁才能到这座城市 
				min1=dis[j],t=j; //找最小的点，这里可以加堆优化，不过数据不大没必要 
		vis[t]=1;
		for(long long j=0; j<l[t].size(); j++)
			dis[l[t][j]]=min(dis[l[t][j]],dis[t]+l1[t][j]); //扩展 
		for(long long j=0; j<jie[t].size(); j++)
		{
			gen=jie[t][j],sum[gen]--;
			if(sum[gen]==0&&dis[gen]!=1e16)
				dis[gen]=max(dis[t],dis[gen]); //重点！到这座城市必须先破坏完结界发生器 
		}
	}
	cout<<dis[n];
	return 0;
}
```


---

## 作者：Adove (赞：2)

手写堆吼啊~~（虽然我调了两个小时发现手写堆写残了~~

用堆优化看上去像SPFA的Dijkstra~~就得到了SPkstra~~

手写堆优化的技巧在于

1. 用`id[]`代替优先队列的`vis[]`并提供点在堆中的编号
2. 用`up(id[a[i].nx])`避免反复入堆并对堆进行维护从而优化常数
3. ~~这东西好像能和SPFA一样找负环~~

```cpp
#include"cstdio"
#include"cstring"
#include"iostream"
#include"algorithm"
using namespace std;

const int MAXN=3005;
const int MAXM=7e4+5;

int n,m,np[2];
int h[2][MAXN],ln[2][MAXN],hp[MAXN],id[MAXN],idg[MAXN];
struct rpg{
	int li,nx,ln;
}a[2][MAXM];

int read()
{
	int x=0;char ch=getchar();
	while(ch<'0'||'9'<ch) ch=getchar();
	while('0'<=ch&&ch<='9') x=(x<<3)+(x<<1)+(ch^'0'),ch=getchar();
	return x;
}

void add(int kd,int ls,int nx,int ln){a[kd][++np[kd]]=(rpg){h[kd][ls],nx,ln};h[kd][ls]=np[kd];}
int Dis(int x){return max(ln[0][x],ln[1][x]);}

void up(int x)
{
	for(int i=x,j=i>>1;j;i=j,j>>=1){
		if(Dis(hp[i])<Dis(hp[j])) swap(hp[i],hp[j]),swap(id[hp[i]],id[hp[j]]);
		else break;
	}return;
}

void push(int x)
{
	hp[++hp[0]]=x;
	id[x]=hp[0];
	up(hp[0]);
	return;
}

void pop()
{
	id[hp[1]]=0;id[hp[hp[0]]]=1;
	hp[1]=hp[hp[0]--];
	for(int i=1,j=2;j<=hp[0];i=j,j<<=1){
		if(j<hp[0]&&Dis(hp[j])>Dis(hp[j+1])) ++j;
		if(Dis(hp[i])>Dis(hp[j])) swap(hp[i],hp[j]),swap(id[hp[i]],id[hp[j]]);
		else break;
	}return;
}

void SPkstra()
{
	for(int i=2;i<=n;++i) ln[0][i]=2147483647;
	ln[0][1]=0;push(1);
	while(hp[0]){
		int nw=hp[1];pop();int c=Dis(nw);
		for(int i=h[0][nw];i;i=a[0][i].li){
			if(ln[0][a[0][i].nx]>c+a[0][i].ln){
				ln[0][a[0][i].nx]=c+a[0][i].ln;
				if(!id[a[0][i].nx]&&!idg[a[0][i].nx]) push(a[0][i].nx);
				else if(!idg[a[0][i].nx]) up(id[a[0][i].nx]);
			}
		}for(int i=h[1][nw];i;i=a[1][i].li){
			ln[1][a[1][i].nx]=max(ln[1][a[1][i].nx],c);
			if(!--idg[a[1][i].nx]) push(a[1][i].nx);
		}
	}return;
}

int main()
{
	n=read(),m=read();
	for(int i=1;i<=m;++i){int x=read(),y=read(),z=read();add(0,x,y,z);}
	for(int i=1;i<=n;++i){
		int t=idg[i]=read();
		while(t--){int x=read();add(1,x,i,0);}
	}SPkstra();printf("%d\n",Dis(n));
	return 0;
}
```

---

## 作者：GNAQ (赞：1)

这种访问次序恰巧符合Dijkstra的特点，因为每个点只会走一次。

记录一下点权，先访问点权为0的点，再检查结界生成器可以使哪些点的点权减小

顺便当某个点的点权减小为0的时候讨论机器人到了城市但是有结界，需要等候的情况。

最后直接一波Dijkstra最短路就好了

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<string>
#include<algorithm>
using namespace std;

//graph
struct ed
{
    int pre,to,w;
}edge[100010]={0};
int edgenum,nodenum,pointer[3010]={0},fx,tx,wx;
//dijkstra
int dis[3010]={0},wpoint,minway,prex;
bool vised[3010]={false};
int nodev[3010]={0},limits[3010][3010]={0},limnum[3010];

void Insert(int at)
{
    edge[at].pre=pointer[fx];
    edge[at].to=tx;
    edge[at].w=wx;
    pointer[fx]=at;
}

int main()
{
    scanf("%d%d",&nodenum,&edgenum);
    for (int i=1;i<=edgenum;i++)
    {
        scanf("%d%d%d",&fx,&tx,&wx);
        Insert(i);
    }
    for (int i=1;i<=nodenum;i++)
    {
        scanf("%d",&nodev[i]);
        int cache1=0;
        for (int j=1;j<=nodev[i];j++)
        {
            scanf("%d",&cache1);
            limnum[cache1]++;
            limits[cache1][limnum[cache1]]=i;
        }
    }
    
    memset(dis,0x3f,sizeof(dis));
    dis[1]=0;
    for (int i=1;i<=nodenum;i++)
    {
        minway=1e8;
        for (int j=1;j<=nodenum;j++)
        {
            if (!nodev[j] && !vised[j] && dis[j]<minway)
            {
                minway=dis[j];
                wpoint=j;
            }
        }
        vised[wpoint]=true;
        prex=pointer[wpoint];
        if (limnum[wpoint]) for (int k=1;k<=limnum[wpoint];k++) 
        {
            nodev[limits[wpoint][k]]--;
            if (!nodev[limits[wpoint][k]])
            {
                if (dis[limits[wpoint][k]]<dis[wpoint]) dis[limits[wpoint][k]]=dis[wpoint];
            }
        }
        while (prex)
        {
            if (dis[wpoint]+edge[prex].w<dis[edge[prex].to])
            {
                dis[edge[prex].to]=dis[wpoint]+edge[prex].w;
            }
            prex=edge[prex].pre;
        }
    }    
    printf("%d\n",dis[nodenum]);
    return 0;
}

---

## 作者：Mys_C_K (赞：1)

题目大意：给定一张有向带权图，但是到达一个点之前必须访问另一些点。

求从点1到点n的最短路径。

题解：

用一个“伪状态转移方程”来描述（之所以是说伪，是因为这是个图而不是个树，所以仅仅用来表示逻辑）

dist[x]=max{d[from[x]],min{dist[pre[x]]+e[i].wgt}}。

这个意思是：到达一个点的真正用时，是在到达它之前必须到达的点的用时的最大值，和所有到达它路径中最短的那一条的最小值取最大值。

说的好乱，最好画个图，例如原题中的图，以第六个点为例，

首先要保证3和5都被访问过了，因此取最大值；

同时要计算出访问4的真正时间再+wgt(4,6)。

然后这二者求个最大值就好了，我觉得到这为止应该就比较明白了。

然后好像由于代码写得太丑并没有用堆优化也过了（复杂度O(n^2+m)）。

代码如下（注：d[x]表示访问存储x的结界发生器的城市的最大值，dist[x]则表示访问x的前驱结点的最小值，

辣么说答案就是max{d[n],dist[n]}辣！）：

```cpp
//SDOI 2010
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<climits>
#define MAXN 3010
#define MAXM 70010
#define INF LLONG_MAX
#define ull unsigned long long int
using namespace std;
struct edge{
    int from,to,wgt,pre;
}e[MAXM];
int h[MAXN],cnt[MAXN],etop,n,m;
ull dist[MAXN],d[MAXN];
vector<int> pro[MAXN];
bool vis[MAXN];
int add_edge(int u,int v,int w)
{
    etop++;
    e[etop].from=u;
    e[etop].to=v;
    e[etop].wgt=w;
    e[etop].pre=h[u];
    h[u]=etop;
    return 0;
}
int main()
{
    scanf("%d%d",&n,&m);
    etop=0;
    for(int i=1;i<=m;i++)
    {
        int u,v,w;
        scanf("%d%d%d",&u,&v,&w);
        if(u!=v) add_edge(u,v,w);
    }
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&cnt[i]);
        for(int j=1;j<=cnt[i];j++)
        {
            int pr;scanf("%d",&pr);
            pro[pr].push_back(i);
        }
    }
    for(int i=0;i<=n;i++)
        dist[i]=INF,d[i]=0;
    int s;dist[s=1]=0;
    memset(vis,false,sizeof(vis));
    for(int i=1;i<=n;i++)
    {
        int mink=0;
        for(int j=1;j<=n;j++)
            if(!vis[j]&&!cnt[j]&&max(dist[j],d[j])<max(dist[mink],d[mink]))
                mink=j;
        //if(mink==0) return 0;
        vis[mink]=true;
        for(int j=h[mink];j;j=e[j].pre)
            if(!vis[e[j].to]&&dist[e[j].to]>max(dist[mink],d[mink])+e[j].wgt)
                dist[e[j].to]=max(dist[mink],d[mink])+e[j].wgt;
        for(int j=pro[mink].size()-1;j>=0;j--)
        {
            cnt[pro[mink][j]]--;
            if(d[pro[mink][j]]<max(dist[mink],d[mink]))
                d[pro[mink][j]]=max(dist[mink],d[mink]);
        }
    }
    printf("%lld\n",max(dist[n],d[n]));
    return 0;
}
```

---

## 作者：xcyy (赞：1)

**此题是一道有限制的最短路问题，其实思路比较好想，就是计算出1到n的实际最短路，再与实际值对比，这个实际值就是炸掉去n的路径上有保护的城市的保护它城市的时间后（貌似有点绕口。。），说白了就是机器人去炸那个能保护别的城市的时间可能会多于直接到n的时间，那么为什么我有思路写不出呢，看题解后发现，这题貌似只能用dijkstra，不能用spfa，我这个spfa打天下的就只能苦逼了，虽然最短路算法大同小异，但是灵活运用起来，如果不够熟悉的话还是会出岔子的**

然后就是网上找了一波题解看了一下，就直接上一下简短60行代码吧

```c
#include<cstdio>
#include<cmath>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<queue>
#include<vector>
using namespace std;
#define N 3002
#define M 70004
#define ll long long 
#define pr pair<ll, int>
#define inf 0x3f3f3f3f
vector<int > p[N];
priority_queue<pr> q;
int head[N],to[M],nxt[M],c[N],vis[N];
ll len[M],f[N],g[N];
int tot;
inline void add(int x,int y,int z)
{
	to[++tot]=y;
	nxt[tot]=head[x];
	len[tot]=z;
	head[x]=tot;
}
int main()
{
	int n,m,i,j,x,y;
	ll z;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		scanf("%d%d%lld",&x,&y,&z);
		add(x,y,z);
	}
	memset(g,inf,sizeof(g));
	memset(f,inf,sizeof(f));
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&c[i]);
		for(int j=1;j<=c[i];j++)
		{
			scanf("%d",&x);
			p[x].push_back(i);
		}
		if(!c[i])g[i]=0;
	}
	f[1]=0;q.push(pr(0,1));
	while(q.size())
	{
		z=-q.top().first,x=q.top().second,q.pop();
		if(vis[x])continue;
		vis[x]=1;
		for(int i=head[x];i;i=nxt[i])
		{
			int v=to[i];
			if(f[v]>z+len[i])
			{
			f[v]=z+len[i];
			if(!c[v])q.push(pr(-max(f[v],g[v]),v));	
			}
		}
		for(int i=0;i<p[x].size();i++)
		{
			c[p[x][i]]--;
			if(!c[p[x][i]])
			g[p[x][i]]=z,q.push(pr(-max(f[p[x][i]],g[p[x][i]]),p[x][i]));
		}
	}
	printf("%lld\n",max(f[n],g[n]));
	return 0;
}
```


其实也就多了一个g[n]的时间处理。

---

## 作者：Patrickpwq (赞：0)

(谁告诉我这是个分层最短路来着的？？？)

进入一个城市必须要这个城市所有结界都打破才能进 

那我们可以边炸边走 也就是说 我们可以维护d1数组:走到的时间(结界可能没炸完) d2数组:可进入的时间(结界都被炸完了) d数组:真实的到达时间

容易发现d[i]=max(d1[i],d2[2])

那我们就用dijkstra维护d数组 每次都要更新当前点所保护的城市的可进入时间  以及当前点连的城市的到达时间 当一个城市的结界全部被炸了 就入堆

注意 这种有限制的最短路最好用dijkstra 因为每个点只会走一次

```cpp
#include<bits/stdc++.h>
#define N 3005
#define M 70005
using namespace std;
template<class T>
inline void read(T &x)
{
	x=0;
	static char ch=getchar();
	while(ch<'0'||ch>'9')	ch=getchar();
	while(ch>='0'&&ch<='9')	x=x*10+ch-'0',ch=getchar();
}
struct Edge
{
	int to,next,val;
}edge[M];
int n,m,tot,first[N],a[N][N],pro[N],p[N];//pro:每个城市保护多少城市	p:每个城市受多少城市保护 
inline void addedge(int x,int y,int z)
{
	tot++; edge[tot].to=y; edge[tot].next=first[x]; edge[tot].val=z; first[x]=tot;
}
typedef pair<int,int> Pair;
priority_queue<Pair,vector<Pair>,greater<Pair> > heap;
bool vis[N];
int d1[N],d2[N],d[N];//d1:到达时间 d2:可进入时间 
void Dijkstra()
{
	memset(d,63,sizeof(d)); memset(d1,63,sizeof(d1));
	heap.push(make_pair(0,1)); 
	d1[1]=0; d[1]=0;
	while(!heap.empty())
	{
		int now=heap.top().second; heap.pop();
		if(vis[now]) continue; 
		vis[now]=true;
		for(int u=first[now];u;u=edge[u].next)
		{
			int v=edge[u].to;
			if(d[now]+edge[u].val<d1[v])	//到达时间 
			{
				d1[v]=d[now]+edge[u].val;
				d[v]=max(d1[v],d2[v]);
				if(!p[v])	heap.push(make_pair(d[v],v));
			}
		}
		for(int i=1;i<=pro[now];i++)	//更新保护城市 
		{
			int v=a[now][i];
			p[v]--,d2[v]=max(d2[v],d[now]),d[v]=max(d1[v],d2[v]);
			if(!p[v])	heap.push(make_pair(d[v],v));
		}
	}
	cout<<d[n]<<endl;	
}
int main()
{
	read(n); read(m);
	for(int i=1,u,v,w;i<=m;i++)	
	{
		read(u); read(v); read(w);
		addedge(u,v,w);
	}
	for(int i=1;i<=n;i++)
	{
		read(p[i]);
		for(int j=1,x;j<=p[i];j++)
		{
			 read(x);
			 a[x][++pro[x]]=i;
		}
	}
	Dijkstra();
	return 0;
}
```

---


# [SDOI2010] 外星千足虫

## 题目描述

公元 $2333$ 年 $2$ 月 $3$ 日，在经历了 $17$ 年零 $3$ 个月的漫长旅行后，“格纳格鲁一号”载人火箭返回舱终于安全着陆。此枚火箭由美国国家航空航天局（NASA）研制发射，行经火星、金星、土卫六、木卫二、谷神星、“张衡星”等 $23$ 颗太阳系星球，并最终在小行星“杰森星”探寻到了地外生命。宇航员在“杰森星”地表岩层下 $45.70$ 米位置发现一批珍贵的活体生命样本，并将其带回检测。

在带回的活体样本中，最吸引人的当属这些来自外星的千足虫了。这些虫子身躯纤长，身体分为若干节。受到触碰时，会将身体卷曲成圆环形，间隔一段时间后才会复原活动。

有趣的还不止如此。研究人员发现，这些虫子的足并不像地球千足虫成对出现、总共偶数条——它们每节身体下方都有着不定数量的足，但足的总数一定是奇数条！

虽然从外观难以区分二者，但通过统计足的数目，科学家们就能根据奇偶性判断出千足虫所属的星球。

![](https://cdn.luogu.com.cn/upload/pic/1592.png)

作为 J 国派去 NASA 的秘密间谍，你希望参加这次研究活动以掌握进一步的情报，而 NASA 选拔的研究人员都是最优秀的科学家。于是 NASA 局长 Charles Bolden 出了一道难题来检测你的实力：

现在你面前摆有 $1\ldots N$ 编号的 $N$ 只千足虫，你的任务是鉴定每只虫子所属的星球，但不允许亲自去数它们的足。

Charles 每次会在这 $N$ 只千足虫中选定若干只放入“昆虫点足机”（the Insect Feet Counter, IFC）中，“点足机”会自动统计出其内所有昆虫足数之和。Charles 会将这个和数 $\bmod$ $2$ 的结果反馈给你，同时告诉你一开始放入机器中的是哪几只虫子。

他的这种统计操作总共进行 $M$ 次，而你应当尽早得出鉴定结果。

![](https://cdn.luogu.com.cn/upload/pic/1593.png)

假如在第 $K$ 次统计结束后，现有数据就足以确定每只虫子的身份，你就还应将这个 $K$ 反馈给 Charles，此时若 $K<M$，则表明那后 $M-K$ 次统计并非必须的。

如果根据所有 $M$ 次统计数据还是无法确定每只虫子身份，你也要跟 Charles 讲明：就目前数据会存在多个解。

## 说明/提示

### 评分标准

对于每一个测试点，如果你的输出文件与答案文件完全相同，该测试点得满分。

否则，对于存在唯一解的测试点，如果你正确回答所有千足虫的身份，将得到 $50\%$ 的分数；

其他情况，该测试点得零分。

### 数据规模和约定

对于 $20\%$ 的数据，满足 $N=M\leq 20$；

对于 $40\%$ 的数据，满足 $N=M\leq 500$；

对于 $70\%$ 的数据，满足 $N\leq500$，$M\leq 10^3$；

对于 $100\%$ 的数据，满足 $1\leq N\leq 10^3$，$1\leq M\leq 2\times 10^3$。

## 样例 #1

### 输入

```
3 5
011 1
110 1
101 0
111 1
010 1```

### 输出

```
4
Earth
?y7M#
Earth```

## 样例 #2

### 输入

```
5 7
01100 1
11000 1
10100 0
11100 1
00011 1
00000 0
11111 0```

### 输出

```
Cannot Determine```

# 题解

## 作者：qwq自动机 (赞：54)

~~吐槽一句：SDOI2010 真的魔幻……共计 12 题，上能[外星捉虫](/problem/P2447)，下能[帮猪打牌](/problem/P2482)（逃~~

---
## Step1 审题 + 题意转化
由于“昆虫点足机”返回的是虫子腿总数 $\text{mod}\ 2$ 的值，又考虑到昆虫腿数仅有奇偶的差异，不妨令地球虫子的腿数为 $0$，外星虫子的腿数为 $1$（因为这样不会影响结果）。那么问题就可以转化为求解如下方程组：

$$
\begin{cases}
\sum\limits_{i=1}^na_{1,i}\cdot x_i&=b_1 \pmod 2&&(1)\\
\sum\limits_{i=1}^na_{2,i}\cdot x_i&=b_2 \pmod 2&&(2)\\
\cdots&\cdots&&\cdots\\
\sum\limits_{i=1}^na_{m,i}\cdot x_i&=b_m \pmod 2&&(m)
\end{cases}
$$

其中 $a_{i,j}$ 表示输入的第 $i$ 次测量是否将第 $j$ 条虫放入机器（放入为 $1$，未放入为 $0$），$b_i$ 表示第 $i$ 次测量的结果。

考虑到在正整数的情况下，模 $2$ 可以转化为取二进制下的最低位，那么方程组的等号右边只会用到左边的最低位，所以我们对于方程组的左边可以不考虑高位，只考虑低位。既然不需要考虑高位，我们就可以采用**异或**（二进制下的不进位加法），将上面的方程组转化为“异或同余方程组”（我自己起的名字）：

$$
\begin{cases}
a_{1,1}x_1 \operatorname{xor} a_{1,2}x_2\operatorname{xor}\cdots\operatorname{xor}a_{1,n}x_n &\equiv b_1 \pmod 2&&(1)\\
a_{2,1}x_1 \operatorname{xor} a_{2,2}x_2\operatorname{xor}\cdots\operatorname{xor}a_{2,n}x_n&\equiv b_2 \pmod 2&&(2)\\
\cdots&\cdots&&\cdots\\
a_{m,1}x_1 \operatorname{xor} a_{m,2}x_2\operatorname{xor}\cdots\operatorname{xor}a_{m,n}x_n&\equiv b_m \pmod 2&&(m)
\end{cases}
$$

~~众所周知，~~ 同余方程组一般情况下比较棘手，那么我们有没有可能将她转化为普通的方程组呢？我们知道，这里的每一条方程中所有参数（如 $a_{i,j}$ 与 $b_i$）均在 $\{0,1\}$ 中，且我们上面也令了 $x_i\in\{0,1\}$。由于异或运算的特性，每条方程的“$\equiv$”左右两边在二进制表示下均仅含一位（即最低位）；而我们的模 $2$ 运算也可以转化为取最低位的运算（奇数低位为 $1$，偶数低位为 $0$）。所以我们就可以把这个同余方程组转化为普通的**异或方程组**了！

总而言之，我们就成功的将题意转化为了：

1. 求解异或方程组
2. 输出最少用的方程数

（另外多嘴说一句：为什么要转化为异或方程组呢？因为这样我们就可以用 C++ 中的 `std::bitset` 与一些二进制优化的方法**极大地**减小我们的常数 ~~（简称高级卡常）~~，甚至可以做到 $\text{TLE}\to\text{AC}$！）

## Step2 解题思路

转化为异或方程组之后我们又能对她进行什么操作呢？我们知道，异或运算是符合**交换律**和**结合律**，所以可以使用类似**高斯消元法**的方法解决这个异或方程组。具体来说，我们可以在每一次选取一条方程消元时将方程间的加减消元改为异或消元，并且由于 $\forall i\in\mathbb{Z}\cap[1,m],j\in\mathbb{Z}\cap[1,n]$，有 $ a_{i,j}\in\{0,1\}$，所以我们在消元的时候可以不用对方程进行乘除操作，直接异或就可以了！当然，在消元过程中如果碰到了多解的情况，记得输出 $\texttt{Cannot Determine}$！

解决了如何求解这个方程组，接下来我们就要解决如何求出最少的方程使用数。实际上，我们可以在每一次消元寻找该元系数非零时找一个编号最小的（即输入顺序最靠前的），然后更新答案取最大值。

分析一下复杂度。首先空间复杂度自然是存增广矩阵的复杂度 $O(nm)$。而时间复杂度有点奇怪：裸的高斯消元~~显然~~是 $O(n^2m)$ 的，明显无法通过此题。

考虑一下用 `std::bitset` 优化大常数。我们知道 `bitset` 的异或操作是 $O(\dfrac n\omega)$ 的，那么用一个 `bitset` 数组来表示增广矩阵，总的时间复杂度就是 $O(\dfrac{n^2m}\omega)$。稍微计算一下， 在 $n=10^3$ 且 $m=2\times 10^3$，评测机为 $32$ 位（即 $\omega=32$）且数据为最坏情况时，式中的$\dfrac{n^2m}\omega\leq 7\times10^7$，完全可以通过此题。

## Step3 码

~~嗯？你为什么露出这么期待的表情？~~

那么有了思路就可以开始写代码了。实际上此题对码力的要求并没有[看猪打牌](/problem/P2482)这一题这么高，有了思路基本就可以写出来了。

AC 代码：

```cpp
#include <iostream> 
#include <cstdio> 
#include <bitset>
#include <cctype>
// 使用宏定义使程序更清晰（虽然也没有清晰多少）
#define ALIEN "?y7M#"
#define EARTH "Earth"
char buffer[1010];
std::bitset<1010> matrix[2010]; // matrix[1~n]：增广矩阵，0 位置为常数
int GaussElimination(int n, int m) // n 为未知数个数，m 为方程个数，返回 0 表示多解，否则返回最少用到的方程数 
{
    int ans = -1; // 方程使用数
    for (int i = 1; i <= n; i++) // 循环消去第 i 个元
    {
        int cur = i;
        while (cur <= m && !matrix[cur].test(i))
            cur++;
        if (cur > m) // 第 i 个元的所有系数均为 0，有多解
            return 0;
        ans = std::max(ans, cur); // 更新 ans
        if (cur != i)
            swap(matrix[cur], matrix[i]); // 交换方程
        for (int j = 1; j <= m; j++)
            if (i != j && matrix[j].test(i)) // 可以消元
                matrix[j] ^= matrix[i];     // 异或消元
    }
    return ans;
}
int main()
{
    int n, m;
    scanf("%d%d", &n, &m);
    for (int i = 1, res; i <= m; i++)
    {
        scanf("%s%d", buffer, &res);
        for (int j = 0; j < n; j++)
            matrix[i].set(j + 1, buffer[j] == '1'); // 增广矩阵赋值系数
        matrix[i].set(0, res); // 常数
    }
    int ret = GaussElimination(n, m); // 高斯消元
    if (ret)
    {
        printf("%d\n", ret);
        for (int i = 1; i <= n; i++)
            printf("%s\n", matrix[i].test(0) ? ALIEN : EARTH);
    }
    else printf("Cannot Determine\n");
    return 0;
} 
```

---

## 作者：YoungNeal (赞：21)

题解在博客[食用](https://www.cnblogs.com/YoungNeal/p/9260782.html)效果更佳哦~


## Solution

显然要高斯消元解异或方程组。

这题 $N$ 有点大，可以用 $bitset$ 优化。

最开始想的是二分找这个满足要求的最小的 $K$，无奈复杂度过不去。

考虑高斯消元的过程，假设当前在消第 $i$ 列，第 $j$ 行，那么一定是从第 $j$ 行向下找一个最小的 $p$ ，满足 $a[p][i]=1$。这里的**最小的**就已经满足题目要求了，不必要在二分了。也就是说，每次 $swap$ 时取一个 $\max$ 即可。

其他就跟高斯消元一模一样了。

## Code

```cpp
#include<cstdio>
#include<cctype>
#include<bitset>
#define N 1005
#define M 2005
#define bi std::bitset<N>
#define max(A,B) ((A)>(B)?(A):(B))

int n,m;
bi a[M];

int getint(){
	int x=0;char ch=getchar();
	while(!isdigit(ch)) ch=getchar();
	while(isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return x;
}

void swap(bi &x,bi &y){bi t=x;x=y;y=t;}

signed main(){
	n=getint(),m=getint();
	for(int i=1;i<=m;i++){
		int x;
		for(int j=1;j<=n;j++){
			scanf("%1d",&x);
			a[i][j]=x;
		}
		x=getint();a[i][n+1]=x;
	}
	int now,ans=0;
	for(int i=1;i<=n;i++){
		now=i;
		while(now<=m and !a[now][i])
			now++;
		if(now==m+1){
			printf("Cannot Determine");
			return 0;
		}
		ans=max(ans,now);
		if(now!=i)
			swap(a[now],a[i]);
		for(int j=1;j<=m;j++){
			if(j==i)
				continue;
			if(!a[j][i])
				continue;
			a[j]^=a[i];
		}
	}
	printf("%d\n",ans);
	for(int i=1;i<=n;i++){
		if(a[i][n+1])
			printf("?y7M#\n");
		else
			printf("Earth\n");
	}
	return 0;
}
```



---

## 作者：leozhang (赞：18)

高斯消元解异或方程组裸题

首先介绍一下异或方程组：异或方程组是形如$x_1$^$x_2$^...^$x_n$=$1(或0)$($x_i\in{0,1}$)的一组方程，我们的目的是求出x_i的值

乍一看，这好像并不好做，最暴力的方法是$O(2^n)$枚举

但是有了高斯消元，我们就可以不这么暴力了，而是可以借助高斯消元的思想来解了

举个例子：

现在我们有一个方程组长这样：

$x_1$^$x_3$=$0$

$x_1$^$x_2$=$0$

$x_1$^$x_2$^$x_3$=$1$

（当然，给出的例子是很简单的了）

但是我们可以借助这种思想：我们首先观察第一个方程：我们希望只有这一个方程中含有$x_1$（这也是高斯消元的思想），这样在其他变量已知的情况下我们就可以求出$x_1$了

那么根据异或的性质，我们用第一个方程逐个与下面含有$x_1$的方程异或，就可以消去下面所有的$x_1$！

于是做出来的结果就长这样：

$x_1$^$x_3$=$0$

$x_2$^$x_3$=$0$

$x_2$=$1$

接下来就是第二个方程：我们要把下面的$x_2$消掉，于是我们的方法同上

最后结果长这样：

$x_1$^$x_3$=$0$

$x_2$^$x_3$=$0$

$x_3$=$1$

最后一个方程，发现已经结束了，那么到这里结束，我们向上回代即可

而回代的原理，也很简单：

$a$^$b$=$c$可以推出$a$=$c$^$b$（两边异或b即得证）

所以我们算出$x_3$后将所有有$x_3$的等式两侧异或$x_3$即可，于是方程就变成了这样：

$x_1$=$1$

$x_2$=$1$

$x_3$=$1$

是不已经解出来了？

这就是高斯消元解异或方程组的过程及原理

 但是这里会出现一个问题：“自由元”问题

按道理，给出n个方程组应该是可以解出每个答案的，但是由于异或运算特殊的性质，有时n个方程是难以解出每个值的

为什么？

举个例子：

$x_1$^$x_2$=1

$x_2$^$x_3$=1

$x_1$^$x_3$=0

不难发现，这组方程本身解就不唯一（显然，$(1,0,1)$与$(0,1,0)$都是该方程组的解）

（如果去探索本质的原因：上面的异或方程在逻辑上等同于以下两个方程：$x_1==x_3$且$x_1!=x_2$，那么考虑取值的方式，不难发现解不是唯一的）

那么如果用正常的方式来解，最后会变成这种形式：

$x_1$^$x_2$=1

$x_2$^$x_3$=1

这也能看出来，因为丢失了一个方程啊！

这时我们就称$x_3$是一个自由元，也就是他的值既可以为0又可以为1，此时该异或方程组有很多组解！

对于自由元问题，目前仅有的办法就是dfs，枚举每个自由元的状态然后回代求解

但是对于这道题，我们没有必要这么做

由于对于解不唯一的情况，他只要求输出一句话，所以我们只需在解不唯一的情况下（也就是解了全部方程仍不能得到唯一解时）特判即可

接下来我们就可以研究如何输出最小方程数了

首先有个显而易见的事情：至少需要n个方程才能解出所有未知数

那我们就先拿出n个方程去解，看看是否存在自由元，如果存在的话就再加入一个，直到解出唯一解或用完所有方程为止

要记录所有自由元的位置

然后就结束了

```cpp
#include <cstdio>
#include <cmath>
#include <cstring>
#include <cstdlib>
#include <algorithm>
#include <queue>
#include <stack>
using namespace std;
int n,m;
int a[2005][1005];
char ch[2005];
bool vis[2005];
int Gauss()
{
	int ret=0;
	for(int i=1;i<=n;i++)
	{
		int temp=i;
		while(!a[temp][i]&&temp<=n)temp++;
		if(temp==n+1){ret++;continue;}
		vis[i]=1;
		if(i!=temp)for(int j=i;j<=n+1;j++)swap(a[temp][j],a[i][j]);
		for(int j=i+1;j<=n;j++)
		{
			if(!vis[j]&&a[j][i])for(int k=i;k<=n+1;k++)a[j][k]^=a[i][k];
		}
	}
	return ret;
}
inline int read()
{
	int f=1,x=0;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
int main()
{
	n=read(),m=read();
	for(int i=1;i<=m;i++)
	{
		scanf("%s",ch+1);
		a[i][n+1]=read();
		for(int j=1;j<=n;j++)a[i][j]=ch[j]-'0';
	}
	int now=n;
	while(Gauss())
	{
		for(int i=1;i<=n;i++)
		{
			if(!vis[i])
			{
				now++;
				if(now>m)
				{
					printf("Cannot Determine\n");
					return 0;
				}
				swap(a[now],a[i]);
			}
		}
	}
	for(int i=n;i>=1;i--)for(int j=i-1;j>=1;j--)if(a[j][i])a[j][n+1]^=a[i][n+1];
	printf("%d\n",now);
	for(int i=1;i<=n;i++)
	{
		if(a[i][n+1])printf("?y7M#\n");
		else printf("Earth\n");
	}
	return 0;
}
```


---

## 作者：Karry5307 (赞：10)

### 题意

给定 $n$ 个变量和 $m$ 个异或方程，求最少需要多少个才能确定每个变量的解。

$\texttt{Data Range:}1\leq n\leq 10^3,1\leq m\leq 2\times 10^3$

### 题解

[不一定更好的阅读体验](https://www.cnblogs.com/Karry5307/p/13877352.html)

高斯消元解异或方程组。

求解这个东西可以直接高斯约旦法，主要问题是第一问。

注意，第一问不等同于求矩阵的秩，因为要求是选一段前缀，矩阵的秩是可以任意选的。

这个时候考虑对选主元过程进行贪心，每一次拿那个位置最前面并且满足条件的当主元来消即可。因为拿靠后的那个方程来消并不能够使答案变得更优，所以贪心策略是正确的。

但是暴力校园是 $O(n^3)$ 的，感觉跑不过（但是为什么 $\textsf{t\color{red}ommy0103}$ 就跑过去了），于是可以考虑一下 bitset 优化，这下复杂度就变成了 $O(\frac{n^3}{\omega})$，实测开 O2 跑得飞快。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef int ll;
typedef long long int li;
const ll MAXN=1e3+51;
bitset<MAXN>mat[MAXN*2];
ll n,m,pivot,mx;
ll v[MAXN*2],id[MAXN*2];
char ch[MAXN];
inline ll read()
{
    register ll num=0,neg=1;
    register char ch=getchar();
    while(!isdigit(ch)&&ch!='-')
    {
        ch=getchar();
    }
    if(ch=='-')
    {
    	neg=-1;
    	ch=getchar();
	}
    while(isdigit(ch))
    {
        num=(num<<3)+(num<<1)+(ch-'0');
        ch=getchar();
    }
    return num*neg;
}
int main()
{
	n=read(),m=read(),id[m+1]=m+1;
	for(register int i=1;i<=m;i++)
	{
		scanf("%s",ch+1),v[i]=read(),id[i]=i;
		for(register int j=1;j<=n;j++)
		{
			mat[i][j]=ch[j]-'0';
		}
	}
	for(register int i=1;i<=n;i++)
	{
		pivot=m+1;
		for(register int j=i;j<=m;j++)
		{
			mat[j][i]&&id[pivot]>id[j]?pivot=j:1;
		}
		if(pivot==m+1)
		{
			return puts("Cannot Determine"),0;
		}
		mx=max(mx,id[pivot]),swap(mat[i],mat[pivot]);
		swap(v[i],v[pivot]),swap(id[i],id[pivot]);
		for(register int j=1;j<=m;j++)
		{
			i!=j&&mat[j][i]?mat[j]^=mat[i],v[j]^=v[i]:1;
		}
	}
	printf("%d\n",mx);
	for(register int i=1;i<=n;i++)
	{
		puts(v[i]?"?y7M#":"Earth");
	}
}
```

---

## 作者：GIFBMP (赞：10)

### 正题

我们发现，在 $\bmod\ 2$ 意义下的加法刚好对应了位运算中的异或。

于是这题就被转化成了异或方程组求解。

我们在消元的时候，利用异或的性质解决即可（具体实现见代码）

这题还让我们求最少需要用前几个方程组才能求解，我们只要在交换行时更新答案即可。

本题 $n\le 10^3$，需要用 bitset 优化。

时间复杂度：$\Theta(\dfrac{n^2m}{w})$

Code:

```cpp
#include <cstdio>
#include <bitset>
using namespace std ;
const int MAXN = 2e3 + 10 ;
bitset <MAXN> a[MAXN] ;
int n , m , x , ans , flag ;
char ch[MAXN] ;
void swap (bitset <MAXN> &x , bitset <MAXN> &y) {
	bitset <MAXN> t = x ; x = y ; y = t ;
}
void Gauss () {
	for (int i = 1 ; i <= n ; i++) {
		int now = i ;
		for (; now <= m && !a[now][i] ; now++) ;
		if (now == m + 1) {flag = 1 ; return ;}
		if (now > ans) ans = now ;
		if (now != i) swap (a[now] , a[i]) ;
		for (int j = 1 ; j <= m ; j++)
			if (i != j && a[j][i]) a[j] ^= a[i] ;
	}
}
int main () {
	scanf ("%d %d" , &n , &m) ;
	for (int i = 1 ; i <= m ; i++) {
		scanf ("%s %d" , ch + 1 , &x) ;
		for (int j = 1 ; j <= n ; j++)
			a[i][j] = (ch[j] == '1') ;
		a[i][n + 1] = x ;
	}
	Gauss () ;
	if (flag) return !printf ("Cannot Determine");
	printf ("%d\n" , ans) ;
	for (int i = 1 ; i <= n ; i++)
		printf (a[i][n + 1] ? "?y7M#\n" : "Earth\n") ;
	return 0 ;
}
```

---

## 作者：hylhyl (赞：8)

# 线性基求解异或方程组
用高斯消元求解时不难发现消元的过程实际是对两个方程的对应系数异或
那么是否可以用线性基求解呢？答案是肯定的。
- - -
## 插入操作
把每个01串插入p中，常数项建议用另一个数组w分开存（方便查询）其插入步骤与p同步
- - - 
## 查询操作
查询每个消元后的二进制01串是否存在。如n=4时查询1000,0100,0010,0001即可。
- - -
## 判断是否有解
易得p必须插满才能保证每个01串都能通过异或得到。记录已插入的数量和最后插入的01编号，在此之后插入的都是无用的数据。
```cpp
#include<stdio.h>
#include<string.h>
#include<algorithm>
#include<cmath>
#include<bitset>
using namespace std;
bitset<1005> p[1005];
bitset<1005> a;
int w[1005],ans[1005],n,m;
int main()
{
	char ss[1005];
	scanf("%d %d",&n,&m);
	int q,v,cnt=0;
	for(int i=1;i<=m;i++)
	{
		scanf("%s",ss);scanf("%d",&v);
		for(int j=0;j<n;j++) a[j]=ss[j]-'0';
		for(int j=n-1;j>=0;j--)
		{
			if(!a[j]) continue;
			if(p[j]==0)
			{
				p[j]=a;
				w[j]=v;//记录常数
				q=i;//记录最后插入的编号
				cnt++;//记录插入的数量
				break;
			}
			a^=p[j];
			v^=w[j];//常数和p一起异或
		}
	}
	if(cnt!=n)
	{
		printf("Cannot Determine");
		return 0;
	}
	printf("%d\n",q);
	for(int i=0;i<n;i++)
	{
		for(int j=0;j<n;j++) a[j]=0;a[i]=1;
		for(int j=i;j>=0;j--)
		{
			if(a[j]==1)
			{
				a^=p[j];
				ans[i]^=w[j];//将w异或进ans数组。
			}
		}
		if(ans[i]==0) printf("Earth\n");
		else printf("?y7M#\n");
	}
	return 0;
}
```

---

## 作者：chenxia25 (赞：7)

你们贪心你们的，我来讲一个动态高斯消元的小 trick。

首先容易想到二分，然后列异或方程组，`bitset` 优化对吧，复杂度 $\mathrm O\!\left(\dfrac{n^2m}w\log\right)$，过不去，把 $\log$ 去掉就能过了。

类似动态 dinic 那样，我们尝试把方程一个个添加进去，实时维护当前增广矩阵的简化阶梯型性，试图做到均摊总三方，也就是添加一次平方。然后每次就看秩有没有到 $n$，有的话就输出。

考虑把新的方程组添加到上一时刻的简化阶梯型的最下面，然后按普通步骤重新高斯消元。那么从左往右枚举主元列，当还没枚举到最后一行的时候，一定是前面的非零行并且行号递增，而且由于前面已经简化阶梯型了，要消主元位置所在列的其它非零元素是 $\mathrm O(1)$ 次的（只有新加行咯），从这点来说没有辜负我们对平方复杂度的期望。

然后到最后一行的主元的时候，就 swap 上来并且消一下该列其它非零元素，复杂度不用担心。然后后面不断有上面的跟最后一行换，当然这个对换变换复杂度也不用担心就是了，因朴素高消对换操作次数本来就缩水。而且之后上面非零行的消非零也都是 $\mathrm O(1)$ 次的，很满意。

适当简化一下过程，不想对换那么多次。那就先对上面的非零行消一下新加行的非零元素，然后反客为主，最后把新加行插入到适当的位置，不难证明这样做的正确性。由于是动态的，可以用 `vector<bitset>` 存矩阵，`insert` 函数用的很方便。代码很好写，1k 都不到，跑的也很快，孩子很喜欢。

```cpp#include<bits/stdc++.h>
using namespace std;
const int N=1010;
int n,m;
vector<bitset<N> > a;
int main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		string str;
		cin>>str;
		bitset<N> nw;
		for(int j=1;j<=n;j++)nw[j]=str[j-1]^48;
		cin>>str;
		nw[n+1]=str[0]^48;
		for(int j=0;j<a.size();j++)if(a[j].any()){
			int x=a[j]._Find_first();
			if(nw[x])nw^=a[j];
		}
		if(nw.any()){
			int x=nw._Find_first();
			for(int j=0;j<a.size();j++)if(a[j][x])a[j]^=nw;
			for(int j=0;j<=a.size();j++){
				int y=j<a.size()&&a[j].any()?a[j]._Find_first():n+2;
				if(y>x){a.insert(a.begin()+j,nw);break;}
			}
		}
//		for(int j=0;j<a.size();j++)for(int k=1;k<=n+1;k++)cout<<a[j][k]<<" \n"[k==n+1];
		if(a.size()==n){
			cout<<i<<"\n";
			for(int j=1;j<=n;j++)puts(a[j-1][n+1]?"?y7M#":"Earth");
			return 0;
		}
	}
	puts("Cannot Determine");
	return 0;
}
```

---

## 作者：StudyingFather (赞：6)

原题即让我们解下面的方程组：

$$
\begin{cases}
a_{1,1}x_1 + a_{1,2}x_2 + \ldots a_{1,n}x_n \equiv b_1 \pmod 2\\
a_{2,1}x_1 + a_{2,2}x_2 + \ldots a_{2,n}x_n \equiv b_2 \pmod 2\\
\vdots\\
a_{m,1}x_1 + a_{m,2}x_2 + \ldots a_{m,n}x_n \equiv b_m \pmod 2\\
\end{cases}
$$

模 $2$ 意义下的线性方程组的求解要比一般情况简单很多。容易发现，这恰好对应位运算中的异或操作。于是上面这个线性方程组就转化为异或方程组。

异或方程组的求解与常规的线性方程组大致相同，还是运用“初等行变换”将矩阵化为简化阶梯形。当然，这里的“初等行变换”是异或意义下的行变换，即用一行与另外一行取异或。

到这里方程组的求解部分就结束了。问题在于，最少要用到的方程数量怎么求呢？

注意到我们在将矩阵化为阶梯形的过程中，对于第 $i$ 个未知数 $x_i$，消元的过程如下：

1. 从第 $i$ 行出发，找到第一个 $x_i$ 系数不为零的行（如果不存在该行，说明方程组系数矩阵的秩 $r < n$，方程组有无穷多解（原题保证有解））。
2. 将该行与第 $i$ 行交换位置。

观察最后的简化阶梯形，只有主元所在的行对方程组的求解是关键的。因为其他行都可以只用主元所在的行“异或”表示（不然也就不会被消成零行了），它们对于方程组的求解没有提供任何额外信息。

因此我们只需要统计主元所在的行分别是哪几行，其中行号的最大值即为所求。

时间复杂度 $O(n^2m)$，没用 bitset 优化但不知道为啥还是过了。

```cpp
// Problem: P2447 [SDOI2010]外星千足虫
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P2447
// Memory Limit: 125 MB
// Time Limit: 1000 ms
//
// Powered by CP Editor (https://cpeditor.org)

#include <algorithm>
#include <cstdio>
using namespace std;
int n, m;
int a[2005][1005];
int main() {
  scanf("%d%d", &n, &m);
  for (int i = 1; i <= m; i++) {
    for (int j = 1; j <= n; j++) scanf("%1d", &a[i][j]);
    scanf("%d", &a[i][n + 1]);
    a[i][0] = i;
  }
  for (int i = 1; i <= n; i++) {
    bool flag = false;
    for (int j = i; j <= m; j++) {
      if (a[j][i]) {
        flag = true;
        swap(a[i], a[j]);
        break;
      }
    }
    if (!flag) {
      puts("Cannot Determine");
      return 0;
    }
    for (int j = i + 1; j <= m; j++)
      if (a[j][i])
        for (int k = i; k <= n + 1; k++) a[j][k] ^= a[i][k];
  }
  for (int i = n; i; i--) {
    for (int j = i - 1; j; j--)
      if (a[j][i])
        for (int k = i; k <= n + 1; k++) a[j][k] ^= a[i][k];
  }
  int ans = a[1][0];
  for (int i = 1; i <= n; i++) ans = max(ans, a[i][0]);
  printf("%d\n", ans);
  for (int i = 1; i <= n; i++) puts(a[i][n + 1] ? "?y7M#" : "Earth");
  return 0;
}
```

---

## 作者：lprer (赞：3)

 [P2447 [SDOI2010]外星千足虫](https://www.luogu.com.cn/problem/P2447)


------------
写的应该算比较具体了，对于异或下的高斯消元做了详细介绍，如要错误欢迎指出。

------------

### 一、题意描述

给定由 $m$ 条异或方程构成的异或方程组，要求求解 $n$ 个未知数的解（$0$ 或 $1$），同时要求求出最少根据前几条方程即能得出所有解。

若 $m$ 条方程无法解出 $n$ 个未知数的**定解**，则输出 `Cannot Determine`。

方程保证有解。

PS：话说 $n\leq 1000,m\leq 2000$，$O(n^2m)$ 能直接刚过去？bitset 有点猛。

### 二、异或高斯消元

对于异或运算，它其实就是**二进制下的不进位加法**，满足交换律和结合律，所以它满足高斯消元的条件，可以使用高斯消元进行求解。

如样例 $1$：

```
3 5
011 1
110 1
101 0
111 1
010 1
```

可构造出方程（$\oplus$ 表示异或）：

$$\left\{\begin{matrix}
 x_2 \oplus x_3=1\\
 x_1 \oplus x_2=1\\
 x_1 \oplus x_3=0\\
 x_1 \oplus x_2 \oplus x_3=1\\
 x_2=1

\end{matrix}\right.$$

我们希望得到类似于 $x_i=0/1$ 的式子（即高斯消元的思想，使得只有一个式子含有 $x_i$）。

如我们想要消去除第一个含有 $x_1$ 的方程外的其他方程中的 $x_1$，那么我们可以将第一个含有 $x_1$ 的方程与下面所有含有 $x_1$ 的方程进行异或,这样除了这个方程，所有的方程中的 $x_1$ 都被消掉了。

**要注意的是，对于一个已经被拿来消其他元的方程，不能再次选择它作为消元方程（但仍然会被消）**。

如上消去 $x_1$，得到（标红为已使用）：

$$\left\{\begin{matrix}
 x_2 \oplus x_3=1\\
 {\color{red}x_1 \oplus x_2=1}\\
 x_2 \oplus x_3=1\\
 x_3=0\\
 x_2=1

\end{matrix}\right.$$


同理，消去 $x_2$ 后得到：

$$\left\{\begin{matrix}
 {\color{red} x_2 \oplus x_3=1}\\
 {\color{red}x_1 \oplus x_3=0}\\
 0=0\\
 x_3=0\\
 x_3=0

\end{matrix}\right.$$

同理，消去 $x_3$ 得到：

$$\left\{\begin{matrix}
 {\color{red} x_2=1}\\
 {\color{red}x_1=0}\\
 0=0\\
 {\color{red}x_3=0}\\
 0=0

\end{matrix}\right.$$

得到解：

$$\left\{\begin{matrix}
x_1=0\\
x_2=1\\
x_3=0
\end{matrix}\right.$$

如上，我们已经得到了一种解出多元一次异或方程组的方式。

那么，怎么才能求出最少需要几条方程能解出解呢，又如何判定该方程有多组解呢？

#### 多解情况：

如果我们无法在消任意一个未知数的时候，找不到任何一个未使用方程含有这一个未知数，那么该方程有多组解，即该元为**自由元**，不受任何条件约束。

#### 最少方程数量：

我们在整个消元过程中选择的所有用来消元方程的最后一个所在位置，就是最少的方程数量，因为若想要完全消完这 $n$ 个未知数，一定要到这里，并且到达这里，所有元肯定已经被消掉了。

对于样例，在最后消 $x_3$ 时，我们使用了第四条方程，所以最少方程数量是 $4$。

### 三、代码实现

若使用朴素的高斯消元，则我们的时间复杂度应当是 $O(n^2m)$，在该题数据规模下是无法通过的，但对矩阵的行的异或操作可以使用 bitset 对每一行进行表示，从而得到一个 $O(\dfrac{n^2m}
{32})$ 的算法。

实测不吸氧 200ms。

我们进行一层 $1\dots n$ 的循环，每次寻找第一个未选择的含有 $x_i$ 的方程，用它对每一个含有 $x_i$ 的方程进行异或。

为了方便，我们可以将被选择的方程换到上面，这样既方便输出，也可以使寻找第一个未选择的方程更加方便。

具体代码如下：

```cpp
#include<cstdio>
#include<bitset>
using namespace std;
int n,m,x,b[2005],id[2005],ans;
bitset<1005> s[2005];
char c[1005];
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m+1;i++)//将每个方程的id记录，即它在原先位置是第几条方程
		id[i]=i;
	for(int i=1;i<=m;i++){
		scanf("%s %d",c+1,&x);
		for(int j=1;j<=n;j++)
			s[i][j]=(c[j]=='1');
		b[i]=x;
	}
	for(int i=1;i<=n;i++){
		int tmp=m+1;
		for(int j=i;j<=m;j++)
			if(s[j][i]&&id[tmp]>id[j])//第1到i-1条方程都是被使用的方程。
				tmp=j;//所以从i开始寻找id最小且含有xi的方程
		if(tmp==m+1){
			printf("Cannot Determine");//若无法找到任意一个未使用方程含有xi，则多解
			return 0;
		}
		ans=max(ans,id[tmp]);swap(s[i],s[tmp]);//取选择的id最大值，即最少需要几条方程
		swap(b[i],b[tmp]);swap(id[i],id[tmp]);//将已使用方程调换到上面
		for(int j=1;j<=m;j++)
			if(i!=j&&s[j][i])//看该方程是否含有xi
				s[j]^=s[i],b[j]^=b[i];//含有则将选择方程与该方程异或
	}
	printf("%d\n",ans);//输出答案
	for(int i=1;i<=n;i++)
		if(b[i])
			printf("?y7M#\n");
		else
			printf("Earth\n");
}
```


---

## 作者：tommymio (赞：2)

简单的转化，异或消元，

我们使用约旦-高斯消元法的异或消元版，无回带直接食用。

时间复杂度是 $O(n^3)\approx O(2\times 10^9)$？暴力消元都能草过 $1s$ 数据？使用 $\text{bitset}$ 优化即可，时间复杂度降至 $O(\frac{n^3}{\omega})$。

~~但是 $O(n^3)$ 的真的草过去了~~

太懒了只写了 $O(n^3)$ 的写法（逃

```cpp
#include<cstdio>
char s[2005];
int id[2005],a[2005][2005],val[2005];
inline int max(const int &x,const int &y) {return x>y? x:y;}
inline void swap(int &x,int &y) {int tmp=y;y=x;x=tmp;}
int main() {
    int n,m,mx=0,tot=0;
    scanf("%d%d",&n,&m); id[m+1]=m+1;
    for(register int i=1;i<=m;++i) {
        id[i]=i; scanf("%s%d",s+1,&val[i]);
        for(register int j=1;j<=n;++j) a[i][j]=s[j]-'0';
    }
    for(register int i=1;i<=n;++i) {
        int tmp=m+1;
        for(register int j=i;j<=m;++j) {if(a[j][i]&&id[tmp]>id[j]) tmp=j;}
        if(tmp==m+1) {printf("Cannot Determine\n");return 0;} mx=max(mx,id[tmp]);
        for(register int j=1;j<=n;++j) swap(a[i][j],a[tmp][j]); swap(val[i],val[tmp]); swap(id[i],id[tmp]);
        for(register int j=1;j<=m;++j) {
            if(j==i||!a[j][i]) continue;
            for(register int k=i;k<=n;++k) a[j][k]^=a[i][k];
            val[j]^=val[i];
        }
    }
    printf("%d\n",mx);
    for(register int i=1;i<=n;++i) printf("%s\n",val[i]? "?y7M#":"Earth");
    return 0;
}
```

---

## 作者：灯芯糕 (赞：2)

## 高斯消元 + bitset 简介：

高斯消元其实就是以加减消元为核心求唯一解。这道题还是比较裸的，可以快速判断出来。我们将每一只虫子看作一个未知数，这样根据它给出的 m 组方程我们可以高斯消元得出每一只虫子的归属地。如果你还不清楚高斯消元的原理可以移步[此处](https://www.luogu.org/problemnew/solution/P3389)

如果你只是以为这是一道板子题自信提交，那么恭喜你，你将会获得TLE的好成绩。为什么呢？我们知道高斯消元是 $n^3$ 复杂度的，而本题数据范围 $ n \leq 1000$，$ m \leq 2000$，明显会卡出TLE。

于是乎，bitset登场了，先介绍一下：

bitset是一种专门用来储存二进制的数组，使用前要先调用函数库。

他的每一个元素只占 1 bit空间，你可以将它当作bool类型的高精度。

他的优点很多，你可将他整体使用，也可单个访问，例如：

```cpp
bitset<4> a (string("1001"));
bitset<4> b (string("0011"));
//注：bitset后面那对尖括号里的数表示a数组的大小
a+=b;
//此时a数组为1100
a[3]=1;
a[1]=0;
//此时a数组为1001

```
你不访问它单个的值是，bitset的运算就像一个普通的整数一样，可以进行与(&)、或(|)、异或(^)、左移(<<)、右移(>>)等操作。同时你还可以对这个数里的任意一位赋值修改。

这样我们就可以将高斯消元降为二维，将每一个方程用一个bitset维护，在用异或运算进行消元即可。

## 代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<iomanip>
#include<algorithm>
#include<bitset>//调用bitset函数库

#define ll long long
#define db double
#define inf 0x7fffffff

using namespace std;

bitset<1005> s[2001];
int n,m,ans,now=1;

inline int qr(){//快读
	char ch;
	while((ch=getchar())<'0'||ch>'9');
	int res=ch^48;
	while((ch=getchar())>='0'&&ch<='9')
		res=(res<<1)+(res<<3)+(ch^48);
	return res;
}

inline int rd(){
	char ch;
	while((ch=getchar())<'0'||ch>'9');
	return ch^48;//每次只读一个
}

int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	n=qr()+1,m=qr();
	for(int i=1;i<=m;++i)//读入
		for(int j=1;j<=n;++j)
			s[i][j]=rd();
	for(int i=1;i<n;now=++i){
		while(!s[now][i]&&now<=m)++now;
		ans=max(ans,now);//更新 k 值
		if(now==m+1){
			printf("Cannot Determine\n");
			return 0;
		} //方程不构成唯一解
		if(now!=i)swap(s[i],s[now]);
		for(int j=1;j<=m;j++){
			if(i==j)continue; //不消自己
			if(!s[j][i])continue;//不是1就不用消
			s[j]^=s[i];//用异或消去系数 1
		}//消去其他方程的系数
	}
	printf("%d\n",ans);
	for(int i=1;i<n;++i)
		if(s[i][n])printf("?y7M#\n");
		else printf("Earth\n");
	return 0;
}
```

bitset除了可以整体运算外还有很多功能：
```cpp
foo.size()  	返回大小（位数）
foo.count() 	返回1的个数
foo.any()   	返回是否有1
foo.none()  	返回是否没有1
foo.set()   	全都变成1
foo.set(p)  	将第p + 1位变成1
foo.set(p, x)   将第p + 1位变成x
foo.reset() 	全都变成0
foo.reset(p)    将第p + 1位变成0
foo.flip() 	 全都取反
foo.flip(p) 	将第p + 1位取反
foo.to_ulong()  返回它转换为unsigned long的结果，如果超出范围则报错
foo.to_ullong() 返回它转换为unsigned long long的结果，如果超出范围则报错
foo.to_string() 返回它转换为string的结果
```

---

## 作者：FourteenObsidian (赞：1)

在这里提供一个跑得较慢但特别直接的做法。

直接跑高斯消元，在更新其他方程是加上对2取模就好了。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 10010;
struct Research
{
    int a[N];
}re[N];
int n, m, an = 0;
double ch;
int ans[N], a[N][N];
bool vis[N];
char s[N];
inline bool solve(int x)
{
    int now;
    bool flag = 0;
    for(register int i = 1; i <= m; ++i)
    {
        if(vis[i]) continue;
        if(re[i].a[x] != 0)
        {
            flag = 1;
            vis[i] = 1;
            an = max(an, i);
            now = i;
            break;
        }
    }
    if(!flag) return 0;
    double yz = re[now].a[x];
    for(register int i = x; i <= n + 1; ++i)
        re[now].a[i] /= yz;
    for(register int i = 1; i <= m; ++i)
    {
        if(vis[i]) continue;
        yz = re[i].a[x];
        if(!yz) continue; //如果这个方程中当前未知数的系数为零，就没必要消了
        for(register int j = x; j <= n + 1; ++j)
            re[i].a[j] -= re[now].a[j] * yz, re[i].a[j] = abs(re[i].a[j]) % 2; //对2取模
    }
    for(register int i = 1; i <= n + 1; ++i)
        a[x][i] = re[now].a[i]; //将解出的未知数记录到矩阵中
    return 1;       
}
int main()
{
    scanf("%d%d", &n, &m);
    for(register int i = 1; i <= m; ++i)
    {
        scanf("%s%d", s + 1, &re[i].a[n + 1]);
        for(int j = 1; j <= n; ++j)
           re[i].a[j] = s[j] - '0'; //存入
    }
    for(register int i = 1; i <= n; ++i)
        if(!solve(i)) //如果有一个未知数系数都为零
        {
            puts("Cannot Determine");
            return 0;
        }
    for(register int i = n; i >= 1; --i)
    {
        for(int j = i + 1; j <= n; ++j)
            a[i][n + 1] -= a[i][j] * ans[j];
        ans[i] = a[i][n + 1];
    } //解出每个未知数的值
    printf("%d\n", an);
    for(register int i = 1; i <= n; ++i)
    {
        if(ans[i] % 2) puts("?y7M#");
        else puts("Earth");
    }
    return 0;
}
```

跑得较慢，开 $O2$ 可过。

---

## 作者：yzhang (赞：1)

[更好的阅读](https://www.cnblogs.com/yzhang-rp-inf/p/11173034.html)

[原题传送门](https://www.luogu.org/problemnew/show/P2447)

根据题意，题目给的每个操作就相当于异或上选中的那几只虫子的足数（mod 2）等于0/1

这是一个异或方程组，珂以用高斯消元解出每个虫子的足数（mod 2）、所需最小次数或判断有多解

但是看题目数据范围$n \leq 1000,m \leq 2000$，如果直接高斯消元$O(n^2m)$的话超时无疑

观察这题的个性：方程组中要通过上下行异或进行消元，这是位运算，一定珂以用bitset优化

我们对每一行开一个bitset，这样消元时直接把两行的bitset异或起来，复杂度为$O(\frac{n^2m}{\omega})$

```cpp
#include <bits/stdc++.h>
#define N 1005 
#define M 2005
#define getchar nc
using namespace std;
inline char nc(){
    static char buf[100000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
inline int read()
{
    register int x=0,f=1;register char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    return x*f;
}
inline void write(register int x)
{
    if(!x)putchar('0');if(x<0)x=-x,putchar('-');
    static int sta[20];register int tot=0;
    while(x)sta[tot++]=x%10,x/=10;
    while(tot)putchar(sta[--tot]+48);
}
inline int Max(register int x,register int y)
{
	return x>y?x:y;
}
bitset<N> b[M];
int n,m,now,ans;
int main()
{
	n=read(),m=read();
	for(register int i=1;i<=m;++i)
		for(register int j=1;j<=n+1;++j)
		{
			char ch=getchar();
			while(ch!='0'&&ch!='1')
				ch=getchar();
			b[i][j]=ch-'0';
		}
	for(register int i=1;i<=n;++i)
	{
		now=i;
		while(now<=m&&!b[now][i])
			++now;
		if(now==m+1)
		{
			puts("Cannot Determine");
			return 0;
		}
		ans=Max(ans,now);
		if(now!=i)
			swap(b[i],b[now]);
		for(register int j=1;j<=m;++j)
		{
			if(i==j||!b[j][i])
				continue;
			b[j]^=b[i];
		}
	}
	write(ans),puts("");
	for(register int i=1;i<=n;++i)
		if(b[i][n+1])
			puts("?y7M#");
		else
			puts("Earth");
	return 0;
}
```

---

## 作者：magolor (赞：1)

来一发题解：

高斯消元裸题，只不过是在mod 2意义下。

稍微改一改高斯消元模板代码就是了：

正常求解：一个解，访问过的最大行数就是答案，然后M[I][n+1]就是解

无解：即某行1……n全0但n+1有数（即0x+0y+0z…… = 某非零数，显然不可能），本题没有这种情况

无数解：即某行全0（即0x+0y+0z…… = 0，显然xyz可以任取）

无解和有无穷解都是false,如果两种情况都有需要特判该行第n+1个数，当然，本题不需要特判。


由于高斯消元是O(n^3)的，n和m又特别大，必须用bitset压位，否则就TLE：

**卡aaaaaaaaaaaaaaaaaaaaaa常angangangangangangangangangang数uuuuuuuuuuuuuuuuuu！**






```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <bitset>
#include <cmath>
using namespace std;
#define MAXN 1000
#define MAXM 2000
#define gc() getchar()
inline int read(int ans = 0, int sgn = ' ', int ch = gc())
{
    for(;ch < '0' || ch > '9'; sgn=ch,ch=gc());
    for(;ch >='0' && ch <='9'; (ans*=10)+=ch-'0',ch=gc());
    return sgn-'-' ? ans : -ans;
}
bitset<MAXN+6> M[MAXM+5];
char s[MAXN+5];
int n, m, row;
bool Gauss()
{
    int maxm = 0, t;
    for(register int k = 1, i, j, maxi; k <= n; maxm = 0, k++)
    {
        for(i = k; i <= m; i++)
            if(maxm |= M[i][k])
            {
                maxi = i;
                break;
            }
        row = max(row,maxi);
        if(fabs(maxm) < 1e-7)
            return false;
        if(maxi-k)
            swap(M[k],M[maxi]); 
        for(i = (k-1?1:2); i <= m; i++, i+=(i==k))
            if(M[i][k])
                M[i] ^= M[k];
    }
    return true;
}
int main()
{
    n = read(), m = read();
    for(register int i = 1, j; i <= m; M[i][n+1] = read(), i++)
        for(scanf("%s",s+1), j = 1; j <= n; M[i][j] = s[j]-'0', j++);
    if(Gauss())
    {
        printf("%d\n",row);
        for(register int i = 1; i <= n; puts(M[i][n+1] ? "?y7M#" : "Earth"), i++);
    }
    else
        puts("Cannot Determine");
    return 0;
}
```

---

## 作者：Jμdge (赞：0)

好题！码量又小思路又清晰！（这次连题解区都没点开过...）

总之看看这个题目就是能用高斯解的

就和那个[灯泡](https://www.luogu.org/problemnew/show/P2962)差不多（甚至做起来更轻松）

这道题就考虑压位就好了（没错是压位）

因为我们考虑到这是个异或矩阵，运算的常数非常小，
但高斯消元复杂度比较高（$O(n^3)$）

那么我们发现如果将多个 bit 压成一个 int 的话能省下近 $Blo=30$ 倍的复杂度

所以说我们只需要构造好矩阵然后压位就好了

但是 bool -> int 还是太麻烦了，于是我们用bitset...

那么这样来说第二问是能轻松解决，但是第一问呢？

其实我们只需要在进行消元的时候将 swap 到的最大的行记录进 ans 就好了

然后 ans 可以初始成 n （因为**至少**要 n 个方程才能确定一组 n 个未知数,当然这还是在线性不相关的情况下，比如这道题就....要判无解）

```
//by Judge
#include<cstdio>
#include<bitset>
#include<iostream>
using namespace std;
const int M=1005;
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline void cmax(int& a,int b){a=a>b?a:b;}
inline int read(){ int x=0,f=1; char c=getchar();
    for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
    for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} inline int cread(){ char c=getchar();
    for(;!isdigit(c);c=getchar()); return c-48;
} int n,m,ans; bitset<M> A[M<<1];
inline bool Gauss(){
    for(int i=1,j;i<=n;++i){ for(j=i;j<=m&&!A[j][i];++j);
        if(j>m) return 0; //看这里发现线性相关，即某个未知数的值无法确定，就 break 了
        cmax(ans,j),swap(A[i],A[j]); //这里更新了ans
        for(j=1;j<=m;++j) if(i^j&&A[j][i]) A[j]^=A[i]; //bitset 多方便
    } printf("%d\n",ans);
    for(int i=1;i<=n;++i)
        puts(A[i][n+1]?"?y7M#":"Earth");
    return 1;
}
int main(){ ans=n=read(),m=read(); //讲道理， ans 不初始化是没关系的
    for(int i=1;i<=m;++i) for(int j=1;j<=n+1;++j) A[i][j]=cread(); //bitset 读的很轻松
    if(!Gauss()) return !puts("Cannot Determine");
}
```


---

## 作者：zhengzhi726 (赞：0)

本题是高斯消元求解异或方程组和好题（模板）
由于数据不够强 不用bitset可以过
高斯消元的板子如果的家都会了的话
这个题只需要愣头修改消元时的减号为异或号即可。
具体地说
由于异或方程满足多元方程的合并性 所以可以消元。
消元和普通高消一样 分为两部分 变成上三角矩阵和变成对角矩阵。
高斯消元法的应用许多
求解行列式也是其一 应当noip前学会使用
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=2010;
int a[maxn][maxn],n,m,ans;
char ch[maxn];
void Gauss(){ans=0;
    for (int r,i=1;i<=n;i++) {
        r=i;
        while(!a[r][i] && r<=m) r++;
        if(r==m+1) {ans=0;return;}
        ans=max(ans,r);
        if (r!=i) for (int j=1;j<=n+1;j++) swap(a[i][j],a[r][j]);
        for (int j=1;j<=m;j++) if (j!=i && a[j][i]) {
            for (int k=i;k<=n+1;k++) a[j][k]^=a[i][k];
        }
    }if(!ans)return ;
    for(int i=n;i;i--){
    	for(int j=1;j<i;j++){
    		if(a[j][i])a[j][n+1]^=a[i][n+1];
    	}
    }
}int main(){
    scanf("%d%d",&n,&m);
    for (int x,i=1;i<=m;i++) {
        scanf("%s%d",ch,&x);
        for (int j=0;j<n;j++) a[i][j+1]=ch[j]-'0';
        a[i][n+1]=x;
    }Gauss();
    if(ans==0)puts("Cannot Determine");
    else{printf("%d\n",ans);
        for (int i=1;i<=n;i++) {
            if (a[i][n+1]) puts("?y7M#");
            else puts("Earth");
        }
    }return 0;
}
```


附赠高消板子

```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxn 105
int n,m;
double mp[maxn][maxn],ans[maxn];
int main(){cin>>n;
	for(int i=1;i<=n;i++)for(int j=1;j<=n+1;j++)cin>>mp[i][j];
	for(int i=1;i<=n;i++){int now=-1;
		for(int j=i;j<=n;j++)
		if(mp[j][i]!=0){
			now=j;break;
		}if(now==-1)continue;
		if(now!=i)swap(now,i);
		for(int j=i+1;j<=n;j++){
			double div=mp[j][i]/mp[i][i];
			for(int k=i;k<=n+1;k++){
				mp[j][k]-=div*mp[i][k];
			}
		}
	}for(int i=n;i;i--){
		if(mp[i][i] == 0){cout<<"No Solution"; return 0;}
		ans[i]=mp[i][n+1]/mp[i][i];
		for(int j=i-1;j;j--){
			mp[j][n+1]-=mp[j][i]*ans[i];mp[j][i]=0;
		}
	}for(int i=1;i<=n;i++)printf("%.2f\n",ans[i]);
}
```


---


# [SDOI2005] 遗传代码

## 题目描述

抽象的 primitivus（Primitivus 循环）的遗传代码是一系列自然数 $K=(A_1,A_2,\cdots,A_n)$。我们所说的 primitivus 的特征是一个数对 $(l,r)$，表示 $l,r$ 在 $A$ 中**连续出现**。即存在一个 $i$，使得 $A_i=l$，$A_{i+1}=r$。在 primitivus 的遗传代码中没有 $(p,p)$ 特征。

### 任务

写一个程序：

1. 从文本文件读特征列表；
2. 计算所给特征的最短遗传代码长度；
3. 输出答案。


## 说明/提示

### 样例解释

以下是一种符合题意的最短的遗传代码。它符合输入数据中给出的所有的特征：

$(8, 5, 1, 4, 2, 3, 9, 6, 4, 5, 7, 6, 2, 8, 6) $

### 数据范围及约定

对于全部数据，满足 $0 \le l \le 1000$，$0 \le  r \le  1000$。

## 样例 #1

### 输入

```
12
2 3
3 9
9 6
8 5
5 7
7 6
4 5
5 1
1 4
4 2
2 8
8 6
```

### 输出

```
15```

# 题解

## 作者：olegekei (赞：2)

### update：
- 2.6 优化了马蜂。
- 2.7 考虑到数据中有 0 的存在，修改代码为下标从 0 开始枚举，update 部分添加句末句号，“update”与汉字之间新增空格。

[~~自作孽不可活~~](https://www.luogu.com.cn/discuss/567811)

---
## 思路：并查集+特判环
题目要求给定的点对 $(x,y)$ 要保证 $x$ 在 $y$ 前面，不难发现如果情况理想的话给定的点对可以形成多条链。

那么我们可以考虑用并查集去维护每一条链。但是容易出现多条链的链头是同一个数。例如下面这组数据：
```
4
2 1
3 2
4 1
5 1
```
发现 $1$ 被作为链头三次，此时一种符合题意的最短遗传代码：$(3,2,1,4,1,5,1)$。这时我们需要另开一个 $cnt$ 数组记录链的个数，每次对 $cnt$ 进行处理，最后答案处理的时候加上 $cnt$（这组数据中 $cnt_1=3$）。

但是 $cnt$ 容易计算错误，例如刚才那组数据如果错误的将 $2$ 当作链头的话会使答案产生误差，使得 $cnt_2=1$，而实际上 $2$ 并不作为链头，所以在给每个 $cnt_y$ 加一的时候也对 $cnt_x$ 做减一处理。

但是如果出现环的情况，环上所有的点 $cnt$ 都为 $0$，会导致统计答案时使答案偏小（一个环对答案的贡献为 $size+1$），所以我们可以特判一下环的情况，如果当前并查集不是孤点且 $cnt=0$ 的话说明是环，$ans \gets ans+1$。

代码：
```cpp
#include<iostream>
using namespace std;
int fa[1001],cnt[1001],cnt2[1001],size[1001];
int getfa(int x)
{
	return fa[x]==x?x:fa[x]=getfa(fa[x]);
}
void init()
{
	for(int i=0; i<=1000; i++) {
		fa[i]=i,size[i]=1;
	}
}
int main()
{
	init();
	int n;
	cin>>n;
	int m=n;
	while(m--) {
		int x,y;
		cin>>x>>y;
		cnt[x]--;
		cnt[y]++;
		int fx=getfa(x),fy=getfa(y);
		if(fx==fy) {
			continue;
		}
		fa[fx]=fy;
		size[fy]+=size[fx];
		size[fx]=0;
	}
	for(int i=0; i<=1000; i++) {
		if(cnt[i]<=0) {
			continue;
		}
		cnt2[getfa(i)]+=cnt[i];
	}
	int ans=0;
	for(int i=0; i<=1000; i++) {
		if(!size[i]) {
			continue;
		}
		ans+=cnt2[i];
		if(size[i]>1 && cnt2[i]==0) {
			ans++;
		}
	}
	cout<<ans+n ;
	return 0;
}
```

---

## 作者：ivyjiao (赞：1)

一本通提高篇的题居然还能写题解。

三倍经验：P2451，P5921，SP211。

题目很明显是让我们求：

对于给定的有向图，加多少边能够存在欧拉路径？

首先我们考虑，怎样才能存在欧拉路径？

不会的[去这里](https://oi-wiki.org/graph/euler/)。

有向图是半欧拉图当且仅当：
- 非零度顶点是弱连通的。
- 至多一个顶点的出度与入度之差为 $1$。
- 至多一个顶点的入度与出度之差为 $1$。
- 其他顶点的入度和出度相等。

对于第一个要求：显然如果在有向图中弱连通，在无向图中就是强联通的。图可能不连通，点可能不连续存在，要用并查集维护。

第二、三个要求：对于每个子图，容易发现因为有向图中边的入度和出度相等，如果一个有向图中只有一个点出度与入度之差为 $1$，那么必有一个其他节点入度与出度之差为 $1$。那么很明显，我们每加一条边，都能让所有节点的入度与出度之差的绝对值的和（$\sum_{i \text{存在}} |in_i-out_i|$）减 $2$，那么当 $\sum_{i \text{存在}} |in_i-out_i|=2$ 时，就存在欧拉回路了。加边的数量为 $\dfrac{\sum_{i \text{存在}} |in_i-out_i|-2}{2}$。

第四个要求：在满足第二、三个要求时此要求必满足。

那么再把每个子图连起来，只需要把上个子图的终点到下个子图的起点连起来，答案为子图的数量 $-1$。

答案即为：

$$子图个数-1+\sum_{\text{子图存在}}\max(0,\dfrac{\sum_{i \text{存在}} |in_i-out_i|-2}{2})$$

又因为本题还需要有 $n+1$ 长度的初始序列来保证包括所有 $(l,r)$，所以最终答案即为：

$$n+子图个数+\sum_{\text{子图存在}}\max(0,\dfrac{\sum_{i \text{存在}} |in_i-out_i|-2}{2})$$

代码：

```cpp
#include<bits/stdc++.h>
#define PII pair<int,int>
using namespace std;
const int N=1e3+1;
int n,u,v,d[N],fa[N],cun[N],s[N],cnt;
int find(int x){
    return x==fa[x]? x:fa[x]=find(fa[x]);
}
int main(){
	for(int i=0;i<N;i++) fa[i]=i;
    cin>>n;
	for(int i=1;i<=n;i++){
		cin>>u>>v;
		d[u]++;
        d[v]--;
		cun[u]=1,cun[v]=1;
        u=find(u),v=find(v);
        fa[v]=u;
	}
	for(int i=0;i<N;i++){
		if(cun[i]) s[find(i)]+=abs(d[i]);
    }
	for(int i=0;i<N;i++){
		if(cun[i]&&find(i)==i) cnt+=max(0,(s[i]-2)/2)+1;
	}
	cout<<n+cnt;
}
```

---

## 作者：elonzhang (赞：0)

# [P2451 \[SDOI2005\] 遗传代码](https://www.luogu.com.cn/problem/P2451)

## 题意简述

给出 $m$ 个前后关系，让我们构造出一个最短的序列，使得其可以包含所有的前后关系（可重复出现同一数字）。

## 思路

如果把这输入看成一个图，那么题目的意思就是：要求我们遍历每一条边，每条边只访问一次，对于节点 $i$，入边的数量 $in_i$ 和出边 $ou_i$，$\max(in_i,ou_i)$ 意味着会经过点 $i$ 的普通路径数量对于每一条路径点 $i$ 会被作为端点描述一次，因此最终的描述点 $i$ 出现的次数为 $\max(in_i,ou_i)$ 因此答案就是 $\sum^{i\le n}_{i=1} {\max(in_i,ou_i)}$。随后我们发现可以过样例了仔细思考之下，发现若他不是个欧拉回路还要再多以一个起点来处理，也就是答案加一。最后时间复杂度是 $O(n+m)$。

## 实现

先将输入进来的**有向边**进行处理，统计存在的点和每个点的出度和入度。然后统计答案就是 $ans+max(in[i],ou[i])\to ans$。搜寻欧拉回路就用一个递归搜索这个以 $i$ 起点连通分量里是否有 $in_i \ne ou_i$，如果没有就可以使答案加一。

## ACcode

```
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define endl '\n'
const int N=1001;
int m,ans,in[N],ou[N],fl;
bitset<N> f,vis;
vector<int> a,g[N];

void dfs(int u){
	vis[u]=1;
	if(in[u]^ou[u]) fl=0;//标记不是欧拉回路
	for(int i = 0;i<g[u].size();++i) if(!vis[g[u][i]]) dfs(g[u][i]);
}

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
//↑以上为初始化 ↑
//------------------------------
	cin >> m;
	for(int i = 1;i<=m;++i){
		int u,v;
		cin  >> u >> v;
		g[u].push_back(v);
		g[v].push_back(u);
		if(!f[u]) a.push_back(u);
		if(!f[v]) a.push_back(v);
		ou[u]++,in[v]++,f[u]=f[v]=1;
	}
	for(int u:a){//只遍历存在的点
		ans+=max(in[u],ou[u]);//统计答案
		if(!vis[u])	fl=1,dfs(u),ans+=fl;
	}
	cout << ans << endl;
	return 0;
}
```

---


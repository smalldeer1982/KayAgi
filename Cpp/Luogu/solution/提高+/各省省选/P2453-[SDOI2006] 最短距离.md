# [SDOI2006] 最短距离

## 题目描述

一种 EDIT 字母编辑器，它的功能是可以通过不同的变换操作可以把一个源串 $X[l\cdots m]$ 变换为新的目标串 $Y[1\cdots n]$。EDIT 提供的变换操作有：

- 删除源串首个字符（delete）；
- 替换源串首个字符放到目标串末尾（replace）。replace 操作可以替换为与原来相同的字符；
- 移动源串首个字符放到目标串末尾（copy）；
- 向目标串插入单个字符（insert）；
- 交换源串中的两个相邻字符，并移动到目标串末尾中去（twiddle）；
- 在完成其它所有操作之后，源串中余下的全部后缀就可用删至行末的操作删除（kill）。

例如，将源 `algorithm` 转换成目标串 `altruistic` 的一种方法是采取下面的操作序列：

| 操作 | 目标串 | 原串 |
| :----------: | :----------: | :----------: |
| 初始 | （空） | `algorithm` |
| `copy a` | `a` | `lgorithm` |
| `copy l` | `al` | `gorithm` |
| `replace g to t` | `alt` | `orithm` |
| `delete o` | `alt` | `rithm` |
| `copy r` | `altr` | `ithm` |
| `insert u` | `altru` | `ithm` |
| `insert i` | `altrui` | `ithm` |
| `insert s` | `altruis` | `ithm` |
| `twiddle it into ti` | `altruisti` | `hm` |
| `replace h to c` | `altruistic` | `m` |
| `kill` | `altruistic` | （空） |



要达到这个结果还可能有其它一些操作序列。

操作 delete、replace、copy、insert、twiddle 和kill中每一个都有一个相联系的代价 cost。例如：

```plain
cost(delete) =3;
cost(replace)=6;
cost(copy)   =5;
cost(insert) =4;
cost(twiddle)=4;
cost(kill) = 被删除的串长 * cost(delete) - 1;
```

一个给定的操作序列的代价为序列中各操作代价之和。
例如上述操作序列的代价为

$$\begin{aligned}&3\times \mathrm{cost}(\mathtt{copy})+2\times \mathrm{cost}(\mathtt{replace})+\mathrm{cost}(\mathtt{delete})+3\times \mathrm{cost}(\mathtt{insert}) \\ &+\mathrm{cost}(\mathtt{twiddle}) +\mathrm{cost}(\mathtt{kill}) \\
=\ & 3\times 5+2\times 6+3+3\times 4+4+1\times 3-1\\
=\ &48\end{aligned}$$

**编程任务**

给定两个序列 $X[1\cdots m],Y[1\cdots n]$ 和一些操作代价集合，$X$ 到 $Y$ 的最短距离为将 $X$ 转化为 $Y$ 的最小的转换序列的代价。请给出一个算法来找出 $X[1\cdots m]$ 至 $Y[1\cdots n]$ 的最短距离。


## 说明/提示

### 数据范围及约定

对于全部数据，满足 $1\le n,m\le 200$，且所有代价均为不大于 $100$ 的非负整数。

## 样例 #1

### 输入

```
algorithm
altruistic
3 6 5 4 4```

### 输出

```
48```

# 题解

## 作者：LingFengGold (赞：19)

[LingFengGold博客](https://blog.csdn.net/qq_42386465/article/details/82854199)

宣传一下博客~~~

[P2453 [SDOI2006]最短距离](https://www.luogu.org/problemnew/show/P2453)

**状态**：f[i][j]表示初始串初始串删除到第i个字符，目标串完成到第j个字符；

初始串为s1,len1；

目标串为s2,len2；

**边界**：

c[i][0]=cost(delet)*i；（目标串没有字符，初始串只能全删了）

c[0][j]=cost(insert)*j；（初始串一个字符都没有，目标串只能用insert一个一个插进去）

枚举i，枚举j

**Copy**：当a[i]==b[j]时（此条件需要判断），一样的话就copy就好；

c[i][j]=min(c[i][j],c[i-1][j-1]+cost[copy]);

**Repalce**：当a[i]!=b[j]时（此条件无需判断），就把初始串的删了，目标串填一个；

c[i][j]=min(c[i][j],c[i-1][j-1]+cost[replace]);

**Delet**：是删除一个初始串的，对于目标串无影响；

c[i][j]=min(c[i][j],c[i-1][j]+cost[delet]);

**Insert**：给目标串多完成一个，对初始串无影响；

c[i][j]=min(c[i][j],c[i][j-1]+cost[insert]);

**Twiddle**：当a[i-1]==b[j]&&a[i]==b[i-1]&&i>=2&&j>=2时（此条件需要判断），就twiddle；

c[i][j]=min(c[i][j],c[i-2][j-2]+cost[twiddle]);

枚举结束！


------------

**Kill**：单独拿出来，枚举当目标串已经完成的情况下（i=len2)，初始串要清零的最小值

c[len1][len2]=min(c[len1][len2],c[i][len2]+cost[delet]*(len1-i)-1);

**结果**：f[len1][len2]。

上面解释的很清楚，附上代码。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<queue>
#include<stack>
#define inf 1e18+5
#define ll long long
using namespace std;
ll inline read()
{
    ll x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
char a[2050],b[2050];
ll c[2050][2050];
ll cost[6];
int main()
{
    scanf("%s%s",a+1,b+1);
    for(int i=1;i<=5;i++){
        cost[i]=read();
    }
    //1=delet,2=replace,3=copy,4=insert,5=twiddle
    int len1=strlen(a+1),len2=strlen(b+1);
    if(len1==0&&len2==0){
        printf("0");
        return 0;
    }
    if(len1==0&&len2!=0){
        printf("%lld",len2*cost[4]);
        return 0;
    }
    if(len1!=0&&len2==0){
        printf("%lld",len1*cost[1]);
        return 0;
    }
    for(int i=1;i<=len1;i++){
        for(int j=1;j<=len2;j++){
            c[i][j]=inf;
        }
    }
    c[0][0]=0;
    for(int i=1;i<=len1;i++){
        c[i][0]=i*cost[1];
    }
    for(int i=1;i<=len2;i++){
        c[0][i]=i*cost[4];
    }
    for(int i=1;i<=len1;i++){
        for(int j=1;j<=len2;j++){
            if(a[i]==b[j]){
                c[i][j]=min(c[i][j],c[i-1][j-1]+cost[3]);
            }
            c[i][j]=min(c[i][j],c[i-1][j-1]+cost[2]);
            c[i][j]=min(c[i][j],c[i-1][j]+cost[1]);
            c[i][j]=min(c[i][j],c[i][j-1]+cost[4]);
            if(i>=2&&j>=2&&a[i-1]==b[j]&&a[i]==b[j-1]){
                c[i][j]=min(c[i][j],c[i-2][j-2]+cost[5]);
            }
        }
    }
    for(int i=1;i<len1;i++){
        c[len1][len2]=min(c[len1][len2],c[i][len2]+cost[1]*(len1-i)-1);
    }
    printf("%lld",c[len1][len2]);
    return 0;
}
```

---

## 作者：Sweetie_Liu (赞：13)

# 这道题第一眼看上去对于我这种蒟蒻来说好像不可做。
于是，我们本着把考试做到日常的想法去做这道题，在真正的考试下我们肯定要尽量不择手段的拿分。
## 我们先从暴力开始。
一个很容易证明的是我们每此操作要么不更新目标串，要么我们必定要让这一位符合目标串，不存在我们把这一位搞成与目标串不相符的字符。
#### 大力穷举
当$a_{i}=b_{j}$时我们才能用copy，当$a_{i}=b_{j+1}$&&$a_{i+1}=b_{j}$时才能用twiddle。
除此之外的3种操作是任意情况下都可以使用的。

接着我们考虑搜索的结束条件，**第一种**情况时题目种明确说了的，达到了目标且原串还剩着就全部删掉，**第二种**是我们已经把原串用完了但还没有达到目标，我们只能把剩下的未达到的目标字符全部insert进去。

### Code：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 201;
string a,b;
int pay[5],ans=0x3f3f3f3f;
inline void Init(){
    cin>>a>>b;
    for(int i=0;i<5;i++)
    cin>>pay[i];
}
void dfs(int len1,int len2,int pays){
    if(len1==a.size()){
        ans=min(ans,pays+(int)(b.size()-len2)*pay[3]);
        return;
    }
    if(len2==b.size()){
        ans=min(ans,pays+(int)(a.size()-len1)*pay[0]-1);
        return;
    }
    if(a[len1]==b[len2])
    dfs(len1+1,len2+1,pays+pay[2]);
    if(a[len1]==b[len2+1]&&a[len1+1]==b[len2])
    dfs(len1+2,len2+2,pays+pay[4]);
    dfs(len1+1,len2,pays+pay[0]);
    dfs(len1+1,len2+1,pays+pay[1]);
    dfs(len1,len2+1,pays+pay[3]);
}
int main(){
    Init();
    dfs(0,0,0);
    printf("%d",ans);
    return 0;
}
```

然后我观察了一会这个爆搜，发现我们的更新好想只和字符串的长度有一点关系，我们可以两串的长度为状态想LCS一样去DP。

#### 于是我们直接改成记搜

### Code:
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 201;
string a,b;
int pay[5],ans=0x3f3f3f3f;
inline void Init(){
	cin>>a>>b;
	for(int i=0;i<5;i++)
	cin>>pay[i];
}
int dp[MAXN][MAXN];
int dfs(int len1,int len2){
	if(dp[len1][len2]!=0x3f3f3f3f)return dp[len1][len2];
	if(len1==a.size())
		return (int)((b.size()-len2)*pay[3]);
	if(len2==b.size())
		return (int)((a.size()-len1)*pay[0]-1);
	if(a[len1]==b[len2])
	dp[len1][len2]=min(dp[len1][len2],dfs(len1+1,len2+1)+pay[2]);
	if(a[len1]==b[len2+1]&&a[len1+1]==b[len2])
	dp[len1][len2]=min(dfs(len1+2,len2+2)+pay[4],dp[len1][len2]);
	dp[len1][len2]=min(dfs(len1+1,len2)+pay[0],dp[len1][len2]);
	dp[len1][len2]=min(dfs(len1+1,len2+1)+pay[1],dp[len1][len2]);
	dp[len1][len2]=min(dp[len1][len2],dfs(len1,len2+1)+pay[3]);
	return dp[len1][len2];
}
int main(){
	Init();
	memset(dp,0x3f,sizeof(dp));
	cout<<dfs(0,0);
	return 0;
}
```
### 到此为止我们AC掉了这道题，但我们从这道题要获得一些经验。
## 平时AC并不是我们的最终目的，AC的数目并不能全面体现你的实力。这道题虽然我做出来了，发了题解了，但一看时间已经过去了2h，放到NOIP顶多DAY1T2的难道不到，如果是考场上妥妥的凉凉。
# 考场上最重要的速度和正确率，而这时平常我们做题经常忽略的东西。
## 目标是500，就要从快准狠的暴力开始。

---

## 作者：revenger (赞：6)

关于这种序列匹配的问题，思路都是一样的。

设f[i][j]表示目标串已经完成了前i位，初始串已经删除了j位。

边界：

f[0][j]=cost(delete)\*j（因为目标串一位都没有，所以初始串只能删）

f[i][0]=cost(insert)\*i（因为初始串一位也没动过，所以只能往目标串里添加）

对于每种操作：（设目标串为s2,初始串s1）

```cpp
delete->f[i][j]=min(f[i][j],f[i][j-1]+cost(delete))
replace->f[i][j]=min(f[i][j],f[i-1][j-1]+cost(replace))
copy->f[i][j]=min(f[i][j],f[i-1][j-1]+cost(copy))(s2[i]==s1[j])
insert->f[i][j]=min(f[i][j],f[i-1][j]+cost(insert))
twiddle->f[i][j]=min(f[i][j],f[i-2][j-1]+cost(triddle))(s2[i]==s1[j-1]&&s2[i-1]==s1[j])
```
然后转移就好了，时间复杂度O(len(s1)\*len(s2))
最后枚举f[len(s2][j](0<=j<len(s1)),把答案加上(len(s1)-j)\*del-1;

然后和f[len(s2)][len(s1)]比较，所有的值里面取最小值。

附代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int cop,tri,del,ins,rep;
char s1[1001],s2[1001];
int f[202][202];
int ans;
inline int min(int a,int b)
{
    return a<b?a:b;
}
int main()
{
    memset(f,127,sizeof(f));
    scanf("%s",s1+1);
    scanf("%s",s2+1);
    f[0][0]=0;
    scanf("%d%d%d%d%d",&del,&rep,&cop,&ins,&tri);
    int m=strlen(s1+1),n=strlen(s2+1);
    for(int i=1;i<=n;i++)
    f[i][0]=i*ins;
    for(int i=1;i<=m;i++)
    f[0][i]=i*del;
    for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
    {
        f[i][j]=min(f[i][j],f[i][j-1]+del);
        f[i][j]=min(f[i][j],f[i-1][j-1]+rep);
        if(s2[i]==s1[j])
        f[i][j]=min(f[i][j],f[i-1][j-1]+cop);
        f[i][j]=min(f[i][j],f[i-1][j]+ins);
        if(i>1&&j>1&&s2[i-1]==s1[j]&&s2[i]==s1[j-1])
        f[i][j]=min(f[i][j],f[i-2][j-2]+tri);
    }
    ans=0x7fffffff;
    for(int i=1;i<m;i++)
    ans=min(ans,f[n][i]+(m-i)*del-1);
    ans=min(ans,f[n][m]);
    printf("%d",ans);
}
```

---

## 作者：ZORO (赞：5)

提供一个比较独特的做法：最短路

![MetL4J.png](https://s2.ax1x.com/2019/11/09/MetL4J.png)

~~话说题目中不都暗示了嘛~~

其实很多状态压缩类动态规划可以转换成最短路问题，只需要将状态压缩为一个点就行，一般处理变换操作可以使用这种方法。

实际上最短路问题就是在图上跑$DP$，但由于$DP$转移受顺序限制需要在拓扑序上跑，而$dijkstra$只需要指定从起点到终点就行。

在这类题中，我们建出来的图就是一个状态转移图，而一般的状压$DP$就是在图上跑$DP$，和$dijkstra$是等效的。

对于这个题，关键点在于如何设计状态和连边建图

# $Solution$
这道题有一个比较显然的性质：就对于最优变换方案，每个时刻目标串一定是最终串的前缀，源串一定是起始串的后缀。

证明：假设当前目标串不是最终串的前缀，那么有两种可能：
$1.$长度超过最终串：那就必须删除，这和在插入前删除是等效的
$2.$目标串有字符不匹配最终串，那么之后还需要$delete$或者按之前的路修改回去，不如提前就修改或者直接$delete$

有了这个性质，状态就比较好表示了，只有$(lena+1)\times(lenb+1)$种状态

![Me0ip4.png](https://s2.ax1x.com/2019/11/09/Me0ip4.png)

状态计算函数就是这个
```
int id(int x,int y)//x是目标串长度,y是源串长度 
{
	return x*(lena+1)+y+1;
}
```
考虑如何连边

操作一、二、四是比较显然的，操作三要注意判断一下，相同才能连边，操作五同理，对于操作清空要特别注意，如果你直接$id(i,j)->id(i,0)$是错误的，假设$j$是$0$，那么根据题面就可以不断删除，而代价是$-1$，所以要特别判断这个情况

```
void link()
{
	for(re int i=0;i<=lenb;++i)
	 for(re int j=0;j<=lena;++j)
	 {
	 	if(j>=1) add(id(i,j),id(i,j-1),w[1]);//del
	 	if(j>=1&&i<lenb)
	 	{
	 		add(id(i,j),id(i+1,j-1),w[2]);//replace任何情况都行 
	 		if(B[i+1]==A[lena-j+1]) add(id(i,j),id(i+1,j-1),w[3]);//相等则可以直接copy 
		}
		if(i<lenb)
		{
			add(id(i,j),id(i+1,j),w[4]);
		}
		if(j>=2&&i<=lenb-2)
		{
			if(B[i+1]==A[lena-j+2]&&B[i+2]==A[lena-j+1])
			add(id(i,j),id(i+2,j-2),w[5]);//判断 
		}
		if(i==lenb&&j!=0)//这里一定要注意 
		{
			add(id(i,j),id(i,0),j*w[1]-1);
		}
	 }
}
```

然后加个$dijkstra$从$id(0,lena)$跑到$id(lenb,0)$即可

完整代码
# $Code$
```
#include<cstdio>
#include<iostream>
#include<cstring>
#include<queue>
#include<algorithm>
#define re register
#define maxn 200010
#define INF 0x3f3f3f3f
using namespace std;
inline int read()
{
	int x=0,f=1; char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
struct Edge{
	int v,w,nxt;
}e[maxn<<2];
int w[101],cnt,head[maxn],vis[maxn];
char A[220],B[220];
int lena,lenb,T,S,dis[maxn];
int id(int x,int y)//x是目标串长度,y是源串长度 
{
	return x*(lena+1)+y+1;
}
inline void add(int u,int v,int w)
{
	e[++cnt].v=v;
	e[cnt].w=w;
	e[cnt].nxt=head[u];
	head[u]=cnt;
}
struct node{
	int u,d;
	bool operator <(const node&rhs) const{
		return rhs.d<d;
	}
};
priority_queue<node> q;
void dijkstra(int s)
{
	while(!q.empty()) q.pop();
	q.push((node){s,0});
	memset(dis,INF,sizeof(dis));
	dis[s]=0;
	while(!q.empty())
	{
		node now=q.top();
		q.pop();
		if(vis[now.u]) continue;
		vis[now.u]=1;
		for(int i=head[now.u];i;i=e[i].nxt)
		{
			int ev=e[i].v;
			if(dis[ev]>dis[now.u]+e[i].w)
			{
				dis[ev]=dis[now.u]+e[i].w;
				q.push((node){ev,dis[ev]});
			}
		}
	}
}
void link()
{
	for(re int i=0;i<=lenb;++i)
	 for(re int j=0;j<=lena;++j)
	 {
	 	if(j>=1) add(id(i,j),id(i,j-1),w[1]);//del
	 	if(j>=1&&i<lenb)
	 	{
	 		add(id(i,j),id(i+1,j-1),w[2]);//replace任何情况都行 
	 		if(B[i+1]==A[lena-j+1]) add(id(i,j),id(i+1,j-1),w[3]);//相等则可以直接copy 
		}
		if(i<lenb)
		{
			add(id(i,j),id(i+1,j),w[4]);
		}
		if(j>=2&&i<=lenb-2)
		{
			if(B[i+1]==A[lena-j+2]&&B[i+2]==A[lena-j+1])
			add(id(i,j),id(i+2,j-2),w[5]);//判断 
		}
		if(i==lenb&&j!=0)//这里一定要注意 
		{
			add(id(i,j),id(i,0),j*w[1]-1);
		}
	 }
}

int main()
{
    cin>>A+1,lena=strlen(A+1);
    cin>>B+1,lenb=strlen(B+1);
    for(re int i=1;i<=5;++i) w[i]=read();
    S=id(0,lena);
    T=id(lenb,0);
    link();
    dijkstra(S);
    printf("%d\n",dis[T]);
	return 0;
}

```

---

## 作者：G_A_TS (赞：1)

dp的定义见代码注释  
变量c_xxx意为cost_xxx  
之后的dp方程就很清晰了，萌新似乎也能看懂~~(初学OI系列)~~  
**kill**放到最后统一处理，把各种情况kill到零，比较输出最大值即可  
**注意！dp[lena][lenb]必须在外面处理**，因为ta**不用kill**，所以**不用-1**  
~~(我一开始就被坑了，我还是太菜)~~  
M_sea太强啦!!!  

------------
```cpp
#include<bits/stdc++.h>
using namespace std;
int dp[210][210],lena,lenb,ans;//dp[i][j]表示a删i个,b到j个的最小值 
int c_delete,c_replace,c_copy,c_insert,c_twiddle;
char a[210],b[210];
int main()
{
	cin>>a>>b;
	lena=strlen(a);
	lenb=strlen(b);
	cin>>c_delete>>c_replace>>c_copy>>c_insert>>c_twiddle;
	for(int i=1;i<=max(lena,lenb);i++)
	{
		dp[0][i]=c_insert*i;
		dp[i][0]=c_delete*i;
	}
	for(int i=1;i<=lena;i++)
	{
		for(int j=1;j<=lenb;j++)
		{
			dp[i][j]=999999999;//初始化
		}
	}
	for(int i=1;i<=lena;i++)
	{
		for(int j=1;j<=lenb;j++)
		{
			dp[i][j]=min(dp[i][j],dp[i-1][j]+c_delete);
			dp[i][j]=min(dp[i][j],dp[i-1][j-1]+c_replace);
			if(a[i-1]==b[j-1])//我是从0读入的，所以减1
			{
				dp[i][j]=min(dp[i][j],dp[i-1][j-1]+c_copy);
			}
			dp[i][j]=min(dp[i][j],dp[i][j-1]+c_insert);
			if(i>=2&&j>=2&&a[i-1]==b[j-2]&&a[i-2]==b[j-1])//不判前两个会炸
			{
				dp[i][j]=min(dp[i][j],dp[i-2][j-2]+c_twiddle);
			}
		}
	}
	ans=dp[lena][lenb];
	for(int i=0;i<lena;i++)
	{
		ans=min(ans,dp[i][lenb]+(lena-i)*c_delete-1);
	}
	cout<<ans;
}
```

---

## 作者：0x3F (赞：0)

纯纯的 dp。

记源串 $s$ 长为 $n$，目标串 $t$ 长为 $m$，五种代价分别为 $a,b,c,d,e$。

类似于 lcs，可以记 $dp_{i,j}$ 为源串删掉前 $i$ 个字符，目标串有前 $j$ 个字符时的最小代价，边界为 $dp_{0,0}=0$，答案为 $dp_{n,m}$。

对于 `delete` 操作，由于 `kill` 可以将代价减 $1$，可以等价地认为：如果最后一次操作为 `delete`，那么代价减 $1$。转移为：$dp_{i,j}\gets dp_{i-1,j}+a-[i=n\land j=m]$。

对于 `replace` 操作，转移为：$dp_{i,j}\gets dp_{i-1,j-1}+b$。

对于 `copy` 操作，要求 $s_i=t_j$，转移与 `replace` 类似。

对于 `insert` 操作，转移为：$dp_{i,j}\gets dp_{i,j-1}+d$。

对于 `twiddle` 操作，要求 $s_i=t_{j-1}$ 且 $s_{i-1}=t_j$，转移为：$dp_{i,j}\gets dp_{i-2,j-2}+e$。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int _ = 210;
char s[_], t[_];
int n, m, a, b, c, d, e, dp[_][_];
int main() {
	scanf("%s%s", s+1, t+1);
	n = strlen(s + 1);
	m = strlen(t + 1);
	scanf("%d%d%d%d%d", &a, &b, &c, &d, &e);
	memset(dp, 0x3F, sizeof(dp));
	for (int i = 0; i <= n; i++) {
		for (int j = 0; j <= m; j++) {
			if (i == 0 && j == 0) {
				dp[i][j] = 0;
			} else {
				if (i >= 1) {
					dp[i][j] = min(dp[i][j], dp[i-1][j] + a - (i == n && j == m));
				}
				if (i >= 1 && j >= 1) {
					dp[i][j] = min(dp[i][j], dp[i-1][j-1] + b);
				}
				if (i >= 1 && j >= 1 && s[i] == t[j]) {
					dp[i][j] = min(dp[i][j], dp[i-1][j-1] + c);
				}
				if (j >= 1) {
					dp[i][j] = min(dp[i][j], dp[i][j-1] + d);
				}
				if (i >= 2 && j >= 2 && s[i] == t[j-1] && s[i-1] == t[j]) {
					dp[i][j] = min(dp[i][j], dp[i-2][j-2] + e);
				}
			}
		}
	}
	printf("%d\n", dp[n][m]);
	return 0;
}
```


---

## 作者：wanghanjun (赞：0)

先吐槽一句：这题跟状压有什么关系。。

好，现在来看题。观察一下题目里举的例子，在操作的过程中，目标串必然是"altruistic"的一个前缀；源串必然是"algorithm"的一个后缀。于是我们设f[i][j]为源串删除了i个，目标串写出了j个所需的最小价格。

然后因为题目里说要求最短路，所以我们要把它转化成最短路 ~~（掩盖我我不会记搜的事实）~~ ，对于每一个操作连一条边，具体连法看下面的代码。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>
using namespace std;

const int MAXN=114514,MAXM=233333;
struct node{
	int v,c;
	node*next;
}*h[MAXN],pool[MAXM];
int dis[MAXN],s,t,n=1,m=1,tot=0,del,rep,cop,ins,twi;
bool vis[MAXN];
char a[233],b[233];

struct que{
	int id,dis;
	bool operator<(const que p)const
	{
		return dis>p.dis;
	}
}tmp;
priority_queue <que> q;

void addedge(int u,int v,int c){
	node*p=&pool[++tot];
	p->v=v;p->c=c;p->next=h[u];h[u]=p;
}

void dijkstra(){
	memset(dis,0x3f,sizeof(dis));
	tmp.dis=0;tmp.id=s;
	dis[s]=0;
	q.push(tmp);
	while(!q.empty()){
		tmp=q.top();q.pop();
		int u=tmp.id;
		if(vis[u]){
			continue;
		}
		vis[u]=1;
		for(node*p=h[u];p;p=p->next){
			if(dis[p->v]>dis[u]+p->c&&!vis[p->v]){
				dis[p->v]=dis[u]+p->c;
				tmp.id=p->v;tmp.dis=dis[p->v];
				q.push(tmp);
			}
		}
	}
}//dijkstra求最短路

int pos(int x,int y){
	return x*(m+1)+y+1;
}

int main(){
	scanf("%s%s",a+1,b+1);
	scanf("%d%d%d%d%d",&del,&rep,&cop,&ins,&twi);
	for(;a[n];n++);
	for(;b[m];m++);
	s=pos(0,0);
	n--;m--;
	for(int i=0;i<=n;i++){
		for(int j=0;j<=m;j++){
			if(i<n){
				addedge(pos(i,j),pos(i+1,j),del);//单个删除操作，源串必须有字母
				addedge(pos(i,j),pos(n,j),del*(n-i)-1);//全部删除操作，源串必须有字母
			}
			if(i<n&&j<m&&a[i+1]==b[j+1]){
				addedge(pos(i,j),pos(i+1,j+1),cop);//复制操作，源串必须有字母，目标串没满，下两个字母相同
			}
			if(i<n&&j<m){
				addedge(pos(i,j),pos(i+1,j+1),rep);//替换操作，源串必须有字母，目标串没满
			}
			if(j<m){
				addedge(pos(i,j),pos(i,j+1),ins);//插入操作，目标串没满
			} 
			if(i<n-1&&j<m-1&&a[i+1]==b[j+2]&&a[i+2]==b[j+1]){
				addedge(pos(i,j),pos(i+2,j+2),twi);//交换并复制，留给读者自己思考
			}
		}
	}
	dijkstra();
	printf("%d\n",dis[pos(n,m)]);
	return 0;
}
```


---

## 作者：Ehuo_ovo (赞：0)

##### [>>原题链接](https://www.luogu.com.cn/problem/P2453)

## 核心算法：记忆化搜索

- ### 开题思路及部分 pts：

题意非常清晰，将一个串转化成另一个串。

于是想到**搜索**，根据题面十分钟打了暴力的 dfs。

```cpp
#include<bits/stdc++.h>
using namespace std;

string s;
string aim;
int n,m;
int w[10];

int ans=1e9;
void dfs(int lu,int lv,int sum){
//	cout<<lu<<" "<<lv<<endl;
	if(lv==n&&lu==m){
		ans=min(ans,sum);return;
	}
	if(lu==m){
		ans=min(ans,sum+w[4]*(n-lv));return;
	}
	if(lv==n){
		ans=min(ans,sum+w[1]*(m-lu)-1);return;
	}
	
	dfs(lu+1,lv,sum+w[1]);//delete
	dfs(lu+1,lv+1,sum+w[2]);//replace
	if(s[lu]==aim[lv]) dfs(lu+1,lv+1,sum+w[3]);//copy
	dfs(lu,lv+1,sum+w[4]);//insert
	if(s[lu]==aim[lv+1]&&s[lu+1]==aim[lv]) dfs(lu+2,lv+2,sum+w[5]);//twiddle
	
	return;
}

int main(){
	cin>>s>>aim; 
	s='@'+s;aim='@'+aim;
	m=s.size(),n=aim.size();
	for(int i=1;i<=5;i++) cin>>w[i];
	dfs(1,1,0);
	cout<<ans<<endl;
}
```
然后喜提 20pts。


------------
- ### 正解部分：

导致超时的原因不难想到，**反复的调用** dfs 函数导致时间复杂度达到了恐怖的 $O(5^n)$，于是我们需要找一些优化时间的手段，首当其冲的就是**记忆化**。

首先建立 $mem$ 数组，记录当此时原串和目标串长度为 $lu$ 和 $lv$ 时，直到**变换结束所需的最小的代价**。

其次，如果此时可以变换到最终状态，将 $vis$ 数组更新为true，当下次搜索到 $lu$ 和 $lv$ 时，**直接返回记忆值即可**。

最后我们只需要求得原串和目标串**长度为 1** 时，直到变换结束所需的最小的代价即可，这样做理论时间复杂度为 $O(mn)$，观察数据范围，**远低于**规定时限。

于是获得 100pts 好成绩。

------------


- ### 代码部分：

```cpp
#include<bits/stdc++.h>
using namespace std;

#define minn(b) mem[lu][lv]=min(mem[lu][lv],b)

string s;
string aim;
int n,m;
int w[10];
int mem[205][205];
bool vis[205][205];
bool no_copy;

int ans;
int dfs(int lu,int lv){
//	cout<<lu<<" "<<lv<<endl;
	if(vis[lu][lv]) return mem[lu][lv];
	if(lv==n&&lu==m) return 0;
	if(lu==m) return w[4]*(n-lv);
	if(lv==n) return w[1]*(m-lu)-1;
	
	minn(dfs(lu+1,lv)+w[1]);//delete
	minn(dfs(lu+1,lv+1)+w[2]); //replace
	if(!no_copy&&s[lu]==aim[lv]) minn(dfs(lu+1,lv+1)+w[3]);//copy
	minn(dfs(lu,lv+1)+w[4]);//insert
	if(s[lu]==aim[lv+1]&&s[lu+1]==aim[lv]) minn(dfs(lu+2,lv+2)+w[5]);//twiddle
	
	if(mem[lu][lv]<0x3f3f3f3f) vis[lu][lv]=1;
	return mem[lu][lv];
}

int main(){
	cin>>s>>aim; 
	s='@'+s;aim='@'+aim;
	m=s.size(),n=aim.size();
	for(int i=1;i<=5;i++) cin>>w[i];
	if(w[2]<w[3]) no_copy=1;
	memset(mem,0x3f,sizeof mem);
	ans=dfs(1,1);
	cout<<ans<<endl;
}
```

------------

- ### 细节部分：

有一个非常小的优化，当 replace 的代价小于 copy 的代价时，我们是不需要执行 copy 操作的，于是时间上又优化掉了一点点 （ 真的是一点点啊 ）。


---


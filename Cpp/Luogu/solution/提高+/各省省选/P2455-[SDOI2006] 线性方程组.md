# [SDOI2006] 线性方程组

## 题目描述

已知 $n$ 元线性一次方程组。

$$ \begin{cases} a_{1, 1} x_1 + a_{1, 2} x_2 + \cdots + a_{1, n} x_n = b_1 \\ a_{2, 1} x_1 + a_{2, 2} x_2 + \cdots + a_{2, n} x_n = b_2 \\ \cdots \\ a_{n,1} x_1 + a_{n, 2} x_2 + \cdots + a_{n, n} x_n = b_n \end{cases}$$

请根据输入的数据，编程输出方程组的解的情况。

## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1 \le n \le 50$。对于 $\forall 1\le i, j \le n$，有 $|a_{i, j}| \le 100$，$|b_i| \le 300$。

## 样例 #1

### 输入

```
3
2 -1 1 1
4 1 -1 5
1 1 1 0```

### 输出

```
x1=1.00
x2=0.00
x3=-1.00
```

# 题解

## 作者：Piwry (赞：102)

作为刚刚刷完模板题想来练练手的蒟蒻，还没摆脱模板题top1题解的影响，于是就想拿  _高斯-约旦消元法_  来过这道题。

然而当我读完题后，才发现 _高斯-约旦消元法_  那美妙的"\\"字形在这题并不能体现，于是~~菜的不行的~~窝就去翻题解...

遗憾的是，当时我只找到了一篇来自~~小~~**诗乃**的[**题解**](https://www.luogu.com.cn/blog/asadashino/solution-p2455)，可这篇题解的代码也有很多**冗余的计算**。

最后，我就只好自力更生了

---
- 我们先来回顾一下用于消元的工具 **增广矩阵** ；以及它的两种变换：交换行，对两行数字做加减。这两种变换后得到的矩阵从求解方程的意义上**是没有变化的**

- 现在再来回顾  _高斯-约旦消元法_  （**假设有唯一解**）的步骤：

1. 以列遍历，从一侧到另一侧；为了方便操作，通常从上至下遍历行，将操作行转移至当前行
2. 先从当前操作行及尚未操作的行找到一个主元（通常取当前列系数最大的，可以证明这样精度误差最小（~~虽然我不会证~~ 简略解释可见文章结尾）），再从除该行的所有行里消去这个元
3. 重复 `2.`，直至遍历完毕

如果你手推过或仔细观察过它的过程，你会发现这个算法**有两点重要的性质**（为了描述方便，以下均默认用上文描述为“_通常_”的操作方式）：

- 每次消元完后，当前列只有当前行不为 $0$
- 当前列左边的数均为 $0$

---
现在我们回到这道题；因为有唯一解的情况可以直接用裸的  _高斯-约旦消元法_  做出，显然其难点就在于**无解**和**无穷解**的判定

而无解和无穷解情况的**不同**就在于，做到某一行你会找不到主元（即当前及下面的行的该列**均为** $0$）

假设当我们**第一次**遇到找不到主元的情况时

我们可以发现：

- 当前列左边的数仍均为 $0$
- 当前操作列及其下面的数均为 $0$

于是便想到**转而处理下一列，操作行不变**，以**维持**这样的性质

---

现在我们对所有找不到主元的情况**都**按上述方法进行处理，当我们遍历完了所有列，当前矩阵也仍满足性质：

- 每次操作列左边的数均为 $0$
- 每次操作列从那次操作行下面一行开始全为 $0$

于是发现它就是一个“**坡度不一”的“倒三角**”（不考虑等式右边常数项），对于**未操作的行**（即“三角”下面的行），**其中的系数全为 $0$！**

这样的“**倒三角**”中可以确定最下面的一个未知数（或可能已经给出解），**往上一一带回一定可以求解**；
\
也就是说**只要判定下面未操作行是否会导出矛盾**就可以对整个方程组做出判定了！

那么就好办了，反正**系数全为** $0$，常数项只要都为 $0$ 就是**无穷解**，否则就是**无解**

（至于**不**存在找不到主元的情况，直接按通常的 _高斯-约旦消元法_ 做就可以了，一定是**存在唯一解**的）

---
$\color{#ffb464}\texttt{顺便推下我的}$[$\color{#32dddd}\texttt{博客}$](https://www.luogu.com.cn/blog/105254/)

---
### 参考代码
```cpp
#include <cstdio>
#include <cmath>
#include <iostream>
using namespace std;

double A[50][51];
int N;

double Abs(double x){
	if(x < 0) return -x;
	else return x;
}

bool eq(double x, double y){// 因为存在微小的精度误差，两数的相差值在一定范围内即可视为相等 
	return (Abs(x-y) < 1e-9);
}

int main(){
	scanf("%d", &N);
	for(int i =0; i < N; ++i) for(int j =0; j < N+1; ++j)
		scanf("%lf", &A[i][j]);
	int nwline =0;
	// k 指主元序号（列）
	for(int k =0; k < N; ++k){// 需要考虑无穷解，循环到N 
		int maxi =nwline;
		for(int i =nwline+1; i < N; ++i)
			if(Abs(A[i][k]) > Abs(A[maxi][k])) maxi =i;
		if(eq(A[maxi][k], 0))
			continue;
		for(int j =0; j < N+1; ++j)
			swap(A[nwline][j], A[maxi][j]);
		for(int i =0; i < N; ++i){
			if(i == nwline)
				continue;
			double mul =A[i][k]/A[nwline][k];
			for(int j =k; j < N+1; ++j)
				A[i][j] -=A[nwline][j]*mul;
		}
		++nwline;
	}
	if(nwline < N){// 存在找不到主元的情况
		while(nwline < N)
			if(!eq(A[nwline++][N], 0))
				return puts("-1") && 0;
		putchar('0');
	}
	else
		for(int i =0; i < N; ++i)
			printf("x%d=%.2lf\n", i+1, A[i][N]/A[i][i]);
}
```

### upd at 20240227_0113

诈尸修了下判断浮点数相等处的万年老锅（具体见代码中 `eq` 函数），以及重新润写了下文章正文；

另外上文提到的：

> 2. 先从当前操作行及尚未操作的行找到一个主元（**通常取当前列系数最大的**，可以证明这样精度误差最小（~~虽然我不会证~~ 简略说明可见文章结尾）），再从除该行的所有行里消去这个元

这里的原理和误差传播有关；简单来说，输入误差相同时，大数字除小数字比起小数字除大数字结果误差更大。于是“取当前列系数最大的”可以有效减少后面代码中 `mul` 变量的精度误差

想更深入了解的读者可以以“误差传播”为关键词在互联网上搜索

---

## 作者：Rui_R (赞：50)

狠题。

题意：在高斯消元的基础上，判断是正常的还是“无解”还是“有无数解”。

简述一下高斯消元的思想：让第 $i$ 个式子对应第 $i$ 元，并用第 $i$ 个式子消去其它式子上的第 $i$ 元，最终使方程组呈现出类似一条对角线的样子，即第 $i$ 个式子只在第 $i$ 元和等式右边有值，其余都是0。

一般的高斯消元每次会选择该项系数绝对值最大的来对应第 $i$ 元。这样，如果发现有一元系数为0，就能说明方程没有正常的解了。

那么我们来研究，没有正常的解，究竟是“无解”还是“有无数解”。

一个naive的想法是，在完成消元后枚举每一项，如果发现系数是0则讨论等式右边：如果为0，则有无数解；如果不为0，则无解。其中**无解优先级更高**，即如果一个方程有一项无解且有一项有无数解，那么判定无解。

交上去喜提90。

存在漏洞：以 hehe_zhou 大佬的hack数据为例：

```
2
0 2 3
0 0 0
```

答案显然是0，但是我们的程序会说这是-1。

我们发现，我们可以根据第一个式子来求出第二元，但是程序会用它来算第一元，并且以后算第二元的时候**不会再考虑该式**，因为我们认为它已经对应第一元了！

也就是说，**我们的答案受到消元顺序影响**。

题解里部分选手当场召唤玄学势力，把消元顺序随机乱改，大概率能出正解。

这里提供一种新的做法。

注意到，我们的症结在于把还有用的式子放到了用不上它的地方，并且以后也不来看它是否可用。

那么，我们就来看它是否可用。

原本的高斯消元中，我们认为只有 $i$ 之后的式子是可用的，因为我们不用管无解还是无数解，系数为0直接判掉。

但这里，我们有可能会在系数为0之后继续做下去。**这就是受到消元顺序影响的原因。**

那么，**可用的就不仅仅是之后的式子，还有之前系数为0的式子。**

于是解决了。

```
#include <cstdio>

const int maxn=55;const double eps=1e-6;

int n;double a[maxn][maxn];

template<typename T> inline void swap(T &a,T &b){
	T temp=a;a=b;b=temp;
}

template<typename T> inline T abs(T val){
	return val>0?val:-val;
}

void Gauss(){//高斯消元
	for(int i=1;i<=n;i++){
		int maxx=i;
		for(int j=1;j<=n;j++){//把枚举范围从i->n改成了1->n
			if(abs(a[j][j])>eps&&j<i) continue;//若在i前，且的确已对应一项系数，不可用
			if(abs(a[j][i])>abs(a[maxx][i])){
				maxx=j;
			}
		}
		for(int j=1;j<=n+1;j++) swap(a[maxx][j],a[i][j]);
		if(abs(a[i][i])<=eps) continue;
		for(int j=1;j<=n;j++){
			if(i==j) continue;
			double delta=a[j][i]/a[i][i];
			for(int k=i;k<=n+1;k++){
				a[j][k]-=delta*a[i][k];
			}
		}
	}
}

int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n+1;j++){
			scanf("%lf",&a[i][j]);
		}
	}
	Gauss();int key=1;
	for(int i=1;i<=n;i++){
		// for(int j=1;j<=n+1;j++) printf("%.2lf ",a[i][j]);
		// printf("\n");
		if(abs(a[i][i])<=eps){
			if(abs(a[i][n+1])>eps) key=-1;//无解优先级更高
			else if(key!=-1) key=0;
		}
	}
	if(key!=1) printf("%d\n",key);
	else for(int i=1;i<=n;i++) printf("x%d=%.2lf\n",i,abs(a[i][n+1]/a[i][i])<=eps?0:a[i][n+1]/a[i][i]);//防止出现-0.00这种令人郁闷的情况，虽然对于本题数据无所谓
	return 0;
}
```

如果hack掉了，请告知这个白痴。

---

## 作者：zqiceberg (赞：26)

#### 通过初等行列变换得到的线性方程组，如果是
1. 完美阶梯型，唯一解
2. 零 = 非零，无解
3. 零 = 零， 无穷多组解

#### 面对一个线性方程组，通过行列变换，依次变换成下面三个状态：

1. 把对角线左下部分的都消掉
2. 把对角线右上部分的都消掉
3. 只剩下对角线上的系数

#### 就可以这样行列变换

1. 把某一行乘一个非零的数
2. 交换某两行
3. 把某行的若干倍加到另一行上去

#### 通过这种方式，把只保留对角线上的系数，且系数是1，就得到了答案
------------


#### 参考代码如下：

```cpp

#include <iostream>
#include <algorithm>
#include <cmath>

using namespace std;

const int N = 110;
const double eps = 1e-6;

int n;
double a[N][N];

//debug代码的方式
void out()
{
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < n; j++) printf("%10.2lf", a[i][j]);
    }
}

int gauss()
{
    int c, r;
    for (c = 0, r = 0; c < n; c++)
    {
        int t = r;
        for (int i = r; i < n; i++)         //找到当前这一列绝对值最大的这一行
            if (fabs(a[i][c]) > fabs(a[t][c]))  //fabs是double的，abs是整形的
            t = i;

        if (fabs(a[t][c]) < eps) continue;   //小于eps时，认为是0

        for (int i = c; i < n + 1; i++) swap(a[t][i], a[r][i]);  //把这一行交换到第一行上去
        for (int i = n; i >= c; i--) a[r][i] /= a[r][c];         //倒着来，最后更新第一个数，把第一个数变成1

        for (int i = r + 1; i < n; i++)                          //把下面所有行的这列都消成0
            if (fabs(a[i][c]) > eps)                             //已经是0就不用消了
                for (int j = n; j >= c; j--)                     //从后往前消
                    a[i][j] -= a[r][j] * a[i][c];

        //out();

        r++;
    }

    if (r < n)   //r不是n，就不是唯一解
    {
        for (int i = r; i < n; i++)
            if (fabs(a[i][n]) > eps)
                return 2;       //无解， 0 = !0)

        return 1;               //无穷多组解   0 = 0
    }

    for (int i = n - 1; i >= 0; i--)                          //倒着把方程消一遍，把每i行第j列的系数保留1外，都消成0
        for (int j = i + 1; j < n; j++)
            a[i][n] -= a[j][n] * a[i][j];                     //a[j][n], 就是xj的值。a[i][n]，当前这一行的xi的值
                                                              //下面一行已经求出xj的值，只需模拟，当前i行的第n列，-= a[i][j] * xj

    return 0;  //唯一解
}


int main()
{
    cin >> n;
    for (int i= 0; i < n; i++)
        for (int j = 0; j < n + 1; j++)
            cin >> a[i][j];

    int t = gauss();

    if (t == 0)
    {
        for (int i = 0; i < n; i++) printf("%.2f\n", a[i][n]);
    }
    else if (t == 1) puts("0");
    else puts("-1");

    return 0;
}

```

---

## 作者：djwj223 (赞：22)

讲讲神奇的「高斯-约旦消元法」。

不能不说题解区里已经有不少用「高斯-约旦消元法」做的题解了，那么我这次想申请再加一篇题解是否多余呢？

1. 不得不说几篇题解都说的比较模糊，给人的感觉是“修改”算法本身来使这个算法处理无解和无穷解的判定。
2. 大家的说法都是还是对整个矩阵做「高斯-约旦消元法」，于是把最后那些系数全为 0 的行说的很玄学。

觉得说的生硬，没全说在点子上。

下面说我的理解。

我认为这题可以沿用高斯-约旦消元法的思路，但是一大障碍是方程组不一定有唯一解，无法确保一行中是否一定存在主元。

此算法本身是必须要每行选出不同的主元，然后把其他行的这个未知数的系数变为 $0$，最后每行都能化成 $k_{a,c}x_c=y_a$ 的形式。

但是当方程组不一定有唯一解的时候问题来了，当一行所有未当过主元的未知数的系数全为 $0$ 怎么办呢？

首先这个地方如果最后这个方程右侧的值不为 $0$，可以直接返回无解，这个比较显然。

否则我们就不把这一行包括进高斯-约旦消元法要处理的增广矩阵，自然那处理的增广矩阵还得少一列，显而易见的，就是那一列到时候多出来的，一个没有当过主元的未知数的系数。

我们先在这个方程组一定有唯一解的子增广矩阵上做高斯-约旦消元法再说，把那些没当过主元的东西全部移到右边去。

要是左边每个柿子不是 $k_{a,c}x_c(k_{a,c}\ne 0)$ 的形式的话我们或许还会一筹莫展，但是这个形式能帮到我们很多。你发现，不管移到柿子右边的那些未知数取多少都没关系，都可以算出值 $x_c$ 。所以这时候我们只需要输出无穷解就够了。

最后，如果子增广矩阵就是原增广矩阵，那么方程组有唯一解，$O(1)$ 解一下 $k_{a,c}x_c=y_a$ 的柿子，然后所有的 $x$ 就都算出来了。

这样这道题就可以用「高斯-约旦消元法」完美解决了。

---

## 作者：Pecco (赞：9)

由线性代数知识，我们知道，对于$n$元线性方程组$\boldsymbol{AX}=\boldsymbol{\beta}$，它的解的情况为：
- 若$\mathrm R(\boldsymbol A,\boldsymbol \beta)=\mathrm R(\boldsymbol A)=r$，且$r=n$时，原方程有唯一解
- 若$\mathrm R(\boldsymbol A,\boldsymbol \beta)=\mathrm R(\boldsymbol A)=r$，且$r<n$时，原方程有无穷多解
- 若$\mathrm R(\boldsymbol A,\boldsymbol \beta)\not =\mathrm R(\boldsymbol A)$时，原方程无解

然后我们直接模拟即可，用高斯-约旦消元法把增广矩阵化成行最简形矩阵。

我这里写了一个class封装了一下，利用了STL中的`valarray`。另外代码中含有不少C++11+的特性，在NOIP等环境需要把`auto`换成相应的类型。
```cpp
template <typename T>
class mat
{
    int r, c; // 行，列
    bool simplified = false; // 记录是否已化简
    valarray<T> data; // 用valarray存储数据

public:
    mat(int r, int c) : r(r), c(c), data(r * c) {}
    // M(i, j)可取第i行第j列的元素
    T &operator()(int i, int j) { return data[i * c + j]; }
    // M[i]可取第i行的切片
    auto operator[](int i) { return data[slice(i * c, c, 1)]; }
    // M(i)可取第i列的切片
    auto operator()(int i) { return data[slice(i, r, c)]; }
    // 交换两行
    void rswap(int r1, int r2)
    {
        for (int i = 0; i < c; ++i)
            swap((*this)(r1, i), (*this)(r2, i));
    }
    // 接下来是重点，进行行变换，把矩阵变成行最简形矩阵
    mat<T> &simplify()
    {
        int curr = 0; // 当前行
        auto &M = *this;
        for (int i = 0; i < c && curr < r; ++i) // 枚举列
        {
            int maxr = curr; // 找到该列（剩余的）最大元素所在的行
            for (int j = curr + 1; j < r; ++j)
                if (M(j, i) > M(maxr, i))
                    maxr = j;
            if (M(maxr, i) == 0) // 该列剩余元素全为0，跳到下一列
                continue;
            rswap(maxr, curr); // 把最大元素所在行交换到当前行处
            M[curr] /= valarray<T>(M(curr, i), c); // 令最大元素归一
            valarray<T> line = M[curr];
            for (int j = 0; j < r; ++j) // 用当前行对其余行进行消元
                if (j != curr)
                    M[j] -= line * M(j, i);
            curr++;
        }
        simplified = true;
        return *this;
    }
    // 从第L列到第R列（左闭右开）的子矩阵的秩
    int rank(int L, int R)
    {
        // 如果还未化为行最简形矩阵，就复制一下当前矩阵，并化简
        mat &M = (simplified ? *this : mat(*this).simplify());
        int cnt = 0;
        for (int i = 0; i < r; ++i) // 统计非0行
        {
            bool allzero = true;
            for (int j = L; j < R; ++j)
                if (M(i, j) != 0)
                    allzero = false;
            cnt += !allzero;
        }
        return cnt;
    }
    int rank() { return rank(0, c); }
};
```

主函数就不写了，按照上面给出的定理很容易实现。只是有个细节可以注意一下：输出的时候可能会输出`-0.00`，所以可以把要输出的数加上一个很小的实数（如`1e-6`）再输出。

---

## 作者：asmend (赞：7)

讨论区里两个Hack插不掉的方法，欢迎插。

1.高斯消元转化成阶梯矩阵。

2.再反着消元转使每一列只有最多一个非零值。

3.若某一行出现$0,0,...,0,x$的情况则无解。

4.若不为三角矩阵的情况则多解。

```cpp
#include <iostream>
#include <algorithm>
#include<cmath>
#include<cstring>
#include<cstdio>
#include<cstdlib>
#include<vector>
#include<iomanip>
#define sqr(x)(x)*(x)
#define fz1(i,n) for (i=1;i<=n;i++)
#define fd1(i,n) for (i=n;i>=1;i--)
#define fz0g(i,n) for (i=0;i<=n;i++)
#define fd0g(i,n) for (i=n;i>=0;i--)
#define fz0k(i,n) for (i=0;i<n;i++)
#define fd0k(i,n) for (i=(long long)(n-1);i>=0;i--)
#define fz(i,x,y) for (i=x;i<=y;i++)
#define fd(i,y,x) for (i=y;i>=x;i--)
#define ff(c,itr) for (__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)
#define rdst(st,len){char ss[len];scanf("%s",ss);(st)=ss;}
using namespace std;
double xs[55][55],ans[55];
int n,m,i,j,k;
bool f1=0,f2=0;
int main()
{
	scanf("%d",&n);
	fz1(i,n)
	{
		fz1(j,n+1)
		{
			scanf("%lf",&xs[i][j]);
		}
	}
	int c=1;
	fz1(i,n)
	{
		if (c>n) break;
		fz(j,i,n)
		{
			if (abs(xs[j][c])>abs(xs[i][c]))
			{
				fz1(k,n+1) swap(xs[i][k],xs[j][k]);
			}
		}
		if (abs(xs[i][c])<1e-8)
		{
			f2=1;
			c++;
			i--;
			continue;
		}
		fz(j,i+1,n)
		{
			double t=xs[j][c]/xs[i][c];
			fz(k,c,n+1)
			{
				xs[j][k]-=xs[i][k]*t;
			}
		}
		c++;
	}
	c=n; 
	fd1(i,n)
	{
		if (c<1) break;
		if (abs(xs[i][c])<1e-8) continue;
		fz1(j,i-1)
		{
			double t=xs[j][c]/xs[i][c];
			fz(k,c,n+1)
			{
				xs[j][k]-=xs[i][k]*t;
			}
		}
		c--;
		if (abs(xs[i][c])>1e-8) i++;
	}
	fd1(i,n)
	{
		f1=0;
		fz1(j,n) if (abs(xs[i][j])>1e-8)
		{
			f1=1;
		}
		if (f1==0&&abs(xs[i][n+1])>1e-8)
		{
			puts("-1");
			return 0;
		}
		if (abs(xs[i][i])>1e-8) if (!f2) ans[i]=xs[i][n+1]/xs[i][i];
	}
	if (f2==1)
	{
		puts("0");
		return 0;
	}
	fz1(i,n)
	{
		if (abs(ans[i])<5e-3) printf("x%d=0\n",i); else printf("x%d=%.2f\n",i,ans[i]);
	}
	return 0;
}
```

---

## 作者：woshishabi1145144444 (赞：5)

**注：本代码可通过讨论区所有hack数据。**

高斯消元主要基于矩阵的三种初等变换：

1、交换两行

2、将一行同时乘上（或除以）同一个数。

3、将一行的所有数加（或减）另一行的若干倍。

我们将所有未知数的系数和每个方程的值放到一个矩阵里，通过不断地消元，最后回代来求出方程组的解。

这道题是高斯消元模板题加上了对无解和无数组解的判断。无解的优先级最高，只要出现未知数系数均为 $0$ 且方程的值大于 $0$ 时，就是无解。然后再判断如果自由变量（即系数均为 $0$ 的未知数）至少存在一个，那么有无数组解，否则回代求出解。


```cpp
#include<bits/stdc++.h>
using namespace std;
const double eps=1e-7;//由于double存在精度误差，用fabs(x)<=eps来判断x=0 
int n;
double a[55][55];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n+1;j++){
			cin>>a[i][j];
		}
	}
	int rk=1;//主元行 
	/*
	这样处理有一个好处：
	对于样例：
	4
	0 0 2 1 2
	0 0 0 1 1
	0 0 0 0 0
	0 0 1 1 1 
	这样处理可以跳过前两列，让第一行的主元变为x3而不是对角线上的x1
	*/ 
	for(int j=1;j<=n;j++){//枚举当前所在的列 
		//第j列绝对值最大的行h 
		int h=rk;
		for(int i=rk;i<=n;i++){
			if(fabs(a[i][j])>fabs(a[h][j])){
				h=i;
			}
		}
		//如果这一列全是0（即自由变量），跳过
		if(fabs(a[h][j])<eps){ 
			continue;
		}
		//变换1，交换两行
		for(int l=1;l<=n+1;l++){
			swap(a[rk][l],a[h][l]); 
		}
		//系数化为1，即变换2，将第rk（主元）行同时除以a[rk][j] 
		double div=a[rk][j];
		for(int l=j;l<=n+1;l++){
			if(fabs(a[rk][l])>eps){
				a[rk][l]/=div;
			}
		}
		//将当前列除了主元行全部化为0，即变换3，将i行（除rk）同时减去rk行的a[i][j]倍 
		for(int i=1;i<=n;i++){
			double tmp=a[i][j];
			if(i==rk){
				continue;
			}
			for(int l=j;l<=n+1;l++){
				a[i][l]-=a[rk][l]*tmp;
			}
		}
		//非自由变量，即当前处理到的行数 
		rk++;
	}
	//由于剩下的行的系数全为0，所以只用判断方程的值是否为0
	for(int i=rk;i<=n;i++){ 
		if(fabs(a[i][n+1])>eps){
			cout<<-1;
			return 0;
		}
	}
	//最后会多加一行，如果没有自由变量的话，rk=n+1，所以要取等
	if(rk<=n){ 
		cout<<0;
		return 0;
	}
	//回代 
	for(int i=n;i>=1;i--){
		for(int j=i+1;j<=n;j++){
			a[i][n+1]-=a[i][j]*a[j][n+1];//当前方程的值要减去其余的未知数乘系数的值 
		}
	}
	for(int i=1;i<=n;i++){
		printf("x%d=%.2lf\n",i,a[i][n+1]);
	}
	return 0;
} 
```

---

## 作者：LoongPig (赞：3)

## 高斯-约旦消元法

### 基本操作：
对于一个有 $m$ 个一次方程，$n$ 个变量的线性方程组可以表示为一个增广矩阵。

**举个栗子：**

$$\begin{cases}
3x_1+7x_2-5x_3=47\\
x_1+4x_2+x_3=58\\
8x_1-3x_2+9x_3=88
\end{cases}\Rightarrow\left [
\begin{array}{c|c}
\begin{matrix}
3&7&-5\\
1&4&1\\
8&-3&9
\end{matrix}&
\begin{matrix}
47\\
58\\
88
\end{matrix}
\end{array}
\right ]$$

增广矩阵的 $3$ 种变换，称为初等变换：

- 交换某两行的位置。
- 用一个非 0 的常数 $k$ 乘某个方程。
- 把某一行乘 $k$ 然后加到另一行上。

应该不用举栗子了吧。

### 解的情况

线性方程组的解有 $3$ 种情况：

1. **有唯一解：**

$$\begin{cases}
3x_1+7x_2-5x_3=47\\
x_1+4x_2+x_3=58\\
8x_1-3x_2+9x_3=88
\end{cases}\Rightarrow\left [
\begin{array}{c|c}
\begin{matrix}
3&7&-5\\
1&4&1\\
8&-3&9
\end{matrix}&
\begin{matrix}
47\\
58\\
88
\end{matrix}
\end{array}
\right ]$$

首先把左边的方程组写成右边的增广矩阵，然后反复使用初等变换，得：
$$\left [
\begin{array}{c|c}
\begin{matrix}
3&7&-5\\
1&4&1\\
8&-3&9
\end{matrix}&
\begin{matrix}
47\\
58\\
88
\end{matrix}
\end{array}
\right ]\Rightarrow\left [
\begin{array}{c|c}
\begin{matrix}
3&7&-5\\
1&4&1\\
0&35&-1
\end{matrix}&
\begin{matrix}
47\\
58\\
376
\end{matrix}
\end{array}
\right ]\Rightarrow\left [
\begin{array}{c|c}
\begin{matrix}
3&7&-5\\
0&5&8\\
0&35&-1
\end{matrix}&
\begin{matrix}
47\\
127\\
376
\end{matrix}
\end{array}
\right ]\Rightarrow\left [
\begin{array}{c|c}
\begin{matrix}
3&7&-5\\
0&5&8\\
0&0&57
\end{matrix}&
\begin{matrix}
47\\
127\\
513
\end{matrix}
\end{array}
\right ]\Rightarrow\left [
\begin{array}{c|c}
\begin{matrix}
3&7&-5\\
0&5&8\\
0&0&1
\end{matrix}&
\begin{matrix}
47\\
127\\
9
\end{matrix}
\end{array}
\right ]\left [
\begin{array}{c|c}
\begin{matrix}
3&7&-5\\
0&5&0\\
0&0&1
\end{matrix}&
\begin{matrix}
47\\
55\\
9
\end{matrix}
\end{array}
\right ]\left [
\begin{array}{c|c}
\begin{matrix}
3&7&-5\\
0&1&0\\
0&0&1
\end{matrix}&
\begin{matrix}
47\\
11\\
9
\end{matrix}
\end{array}
\right ]\Rightarrow\left [
\begin{array}{c|c}
\begin{matrix}
1&0&0\\
0&1&0\\
0&0&1
\end{matrix}&
\begin{matrix}
5\\
11\\
9
\end{matrix}
\end{array}
\right ]$$

最后解得 $x_1=5$，$x_2=11$，$x_3=9$。这是唯一解，称最后得矩阵为**简化梯形矩阵**，特征是左半部分是一个单位矩阵。

2. **有无穷多解：**
   
$$\begin{cases}
3x_1+7x_2-5x_3=47\\
x_1+4x_2+x_3=58\\
2x_1+3x_2-6x_3=-11
\end{cases}\Rightarrow
\left [
\begin{array}{c|c}
\begin{matrix}
3&7&-5\\
1&4&1\\
2&3&-6
\end{matrix}&
\begin{matrix}
47\\
58\\
-11
\end{matrix}
\end{array}
\right ]\Rightarrow
\left [
\begin{array}{c|c}
\begin{matrix}
3&7&-5\\
0&5&8\\
0&0&0
\end{matrix}&
\begin{matrix}
47\\
127\\
0
\end{matrix}
\end{array}
\right ]$$

最后的矩阵出现了一个全都是 $0$ 的行，说明这一行无效。$3$ 个未知数，却只有两个方程，所以有无穷多个解。

3. **无解：**

$$\begin{cases}
3x_1+7x_2-5x_3=47\\
x_1+4x_2+x_3=58\\
2x_1+3x_2-6x_3=5
\end{cases}\Rightarrow
\left [
\begin{array}{c|c}
\begin{matrix}
3&7&-5\\
1&4&1\\
2&3&-6
\end{matrix}&
\begin{matrix}
47\\
58\\
5
\end{matrix}
\end{array}
\right ]\Rightarrow
\left [
\begin{array}{c|c}
\begin{matrix}
3&7&-5\\
0&5&8\\
0&0&0
\end{matrix}&
\begin{matrix}
47\\
127\\
16
\end{matrix}
\end{array}
\right ]$$

最后的矩阵出现了 $0x_1+0x_2+0x_3=16$ 的矛盾方程，说明该方程组无解。

### 具体实现方法

1. 从第一行开始，选择一个非 $0$ 的系数（一般选择绝对值最大的系数，避免转换其他系数时产生过大的数值）所在的行，把这一行与第 $1$ 行交换。此时 $x_1$ 是主元；
2. 把 $x_1$ 的系数转换为 $1$；
3. 利用主元 $x_1$ 的系数，把其他行的这一列的主元消去；
4. 重复上述步骤，直到该增广矩阵变为简化梯形矩阵。

---

## 作者：Carl170679 (赞：2)

## **核心思路**
~~python是个好东西~~

`numpy.linalg.solve(A,B)`直接求解线性方程组。
如果求解失败（抛出 `LinAlgError`），进一步计算矩阵的**秩**：

**无解**：`rank(A)<rank([A|B])`。

**无穷多解**：`rank(A)==rank([A|B])` 且 `rank(A)<n`。

| 函数 | 作用 |
|------|------|
|`numpy.linalg.solve(A,B)`|解线性方程组|
|`numpy.linalg.matrix_rank(M)`|计算矩阵的秩|
|`numpy.column_stack((A,B))`|构造增广矩阵|
---

## **最终代码**
```python
from numpy import *
n=int(input())
A=[]
B=[]
for _ in range(n):
    r=input().split()
    r=[float(x)for x in r]
    B.append(r.pop())
    A.append(r)
try:
    X=linalg.solve(A,B)
    for i in range(len(X)):
        print("x%d=%.2f"%(i+1,round(X[i],2)))
except:
    rA=linalg.matrix_rank(A)
    AB=column_stack((A,B))
    rAB=linalg.matrix_rank(AB)
    if rA<rAB:
        print(-1)
    else:
        print(0)
```

---

## 作者：luckyyunji (赞：2)

## 高斯消元法

首先题目意思很简单，就是 $n$ 元一次方程。

模仿初中生的做法，只不过就是标准化了一点。

1. 先转化为系数矩阵。
2. 用加减将矩阵化为每行只有一个字母系数为 $1$ 矩阵（有解时）。

加减的意思是：

- 把某一行乘 $k$ 然后加到另一行上，使得某个字母系数被消为 $0$。

样例解释：

$$
\begin{bmatrix}
 4 & 1 & -1 & 5 \\
 2 & -1 & 1 & 1 \\
 1 & 1 & 1 & 0
\end{bmatrix}
\Rightarrow
\begin{bmatrix}
 1 & 0.25 & -0.25 & 1.25 \\
 2 & -1 & 1 & 1 \\
 1 & 1 & 1 & 0
\end{bmatrix}
\Rightarrow
\begin{bmatrix}
 1 & 0.25 & -0.25 & 1.25 \\
 0 & -1.5 & 1.5 & -1.5 \\
 0 & 0.75 & 1.25 & -1.25 
\end{bmatrix}
\Rightarrow
\begin{bmatrix}
 1 & 0.25 & -0.25 & 1.25 \\
 0 & 1 & -1 & 1 \\
 0 & 0.75 & 1.25 & -1.25 
\end{bmatrix}
\Rightarrow
\begin{bmatrix}
 1 & 0 & 0 & 1 \\
 0 & 1 & -1 & 1 \\
 0 & 0 & 2 & -2
\end{bmatrix}
\Rightarrow
\begin{bmatrix}
 1 & 0 & 0 & 1 \\
 0 & 1 & -1 & 1 \\
 0 & 0 & 1 & -1
\end{bmatrix}
\Rightarrow
\begin{bmatrix}
 1 & 0 & 0 & 1 \\
 0 & 1 & 0 & 0 \\
 0 & 0 & 1 & -1
\end{bmatrix}
$$

~~我相信你肯定会了。~~

最后，只要结束的时候，发现：

$$
0x_1+0x2+0x3+\dots+0x_n=0
$$

则有无穷解。

发现：

$$
0x_1+0x2+0x3+\dots+0x_n \ne 0
$$

则无解。

**注意无解的优先级更高，说明要先判断无解再判断有解。**

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 110;
const double eps = 1e-6;  // 设置无穷小
double a[MAXN][MAXN];	  // 系数矩阵
int n;
void print() {
	for (int i = 0; i < n; i++) {
		for (int j = 0; j <= n; j++) {
			printf("%.2f ", a[i][j]);
		}
		printf("\n");
	}
	printf("\n");
}
int solve() {
	int curr = 0;
	for (int cur = 0; cur < n; cur++) {
		int maxx = curr;
		for (int i = curr; i < n; i++) {  // 操作最大值减小误差
			if (fabs(a[i][cur]) > fabs(a[maxx][cur])) {
				maxx = i;
			}
		}
		swap(a[curr], a[maxx]);
		if (fabs(a[curr][cur]) < eps) {
			continue;  // 直接跳过（必然不是一般情况）
		}
		for (int i = n; i >= cur; i--) {
			a[curr][i] /= a[curr][cur];	 // 使主元系数化为 1
		}
		for (int i = 0; i < n; i++) {
			if (i == curr) {
				continue;
			}
			for (int j = 0; j <= n; j++) {
				if (j == cur) {
					continue;
				}
				a[i][j] -= a[i][cur] * a[curr][j];	// 进行加减
			}
			a[i][cur] = 0;
		}
		curr++;
		// print();
	}
	if (curr < n)  // 判断有无解
	{
		for (int i = curr; i < n; i++) {
			if (fabs(a[i][n]) > eps) {
				return 1;
			}
		}
		return 0;
	}
	return 2;
}
int main() {
	// cin>>n;
	scanf("%d", &n);
	int tt;
	for (int i = 0; i < n; i++) {
		for (int j = 0; j <= n; j++) {
			scanf("%d", &tt);
			a[i][j] = (double)tt;
		}
	}
	// print();
	int t = solve();
	if (t == 0) {
		printf("0");
	} else if (t == 1) {
		printf("-1");
	} else {
		for (int i = 0; i < n; i++)	 // 按顺序输出
		{
			printf("x%d=%.2f\n", i + 1, a[i][n]);
		}
	}
	return 0;
}
```

---

## 作者：Wt_sister (赞：1)

这个题和[P3389](https://www.luogu.com.cn/problem/P3389)基本一样。除了一点：我们需要考虑方程解的情况。

首先如果这是一个正常的对角线矩阵那就有唯一解；如果出现了$~0x = a~$那就是无解；如果出现了$~0x = 0~$那就是无数解

换句话说，由于可能有无数个解，我们不能在消元过程中草率地判断无解了。但是我们可以把之前系数已经为$~0~$的式子继续进行使用，到最后再进行无解的判断。

具体如何实现可以看代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const long double eps = 1e-9; 
int n, flag = 1;
long double a[105][105];
void gauss() {
	for(int i=1;i<=n;i++) { // 目的是把第i行第i个数变为1，其余变为0 
		int maxx = i;
		for(int j=1;j<=n;j++) {//从1开始
			if(fabs(a[j][j]) > eps && j < i) continue; // 如果前面行已经消完了就不动
			if(fabs(a[j][i]) > fabs(a[maxx][i])) maxx = j;
		}
		if(maxx != i)
			for(int j=1;j<=n+1;j++) swap(a[i][j], a[maxx][j]);
		if(fabs(a[i][i]) < eps) // 第i行第i个系数为0，说明第i个方程里未知数系数为0 
			continue;//不能直接输出无解，有可能无数解
		for(int j=n+1;j>=i;j--) a[i][j] /= a[i][i];
		for(int j=1;j<=n;j++) {
			if(j != i) {
				double t = a[j][i];
				for(int k=i;k<=n+1;k++) a[j][k] -= a[i][k] * t;
			}
		} 
	}
}
int main() {
	cin >> n;
	for(int i=1;i<=n;i++) {
		for(int j=1;j<=n+1;j++)
			cin >> a[i][j];
	}
	gauss();
	for(int i=1;i<=n;i++) {
		if(fabs(a[i][i]) < eps) {
			if(fabs(a[i][n+1]) > eps) flag = -1;
			else if(flag != -1) flag = 0;
		}//关于无解和无数解的判断，有大坑！
	}//无解优先级更高，所以不能找到一行无解或无数解就输出，有可能出现这一行无数解下一行无解的情况，所以用flag记录，扫完再输出
    if(flag != 1) cout << flag << '\n';
    else {
    	for(int i=1;i<=n;i++) 
    		cout << "x" << i <<  "=" << a[i][n+1] + eps << '\n';//防止出现-0.00，给它加上一个极小值。
    }
	return 0;
}
```

---

## 作者：baokun (赞：1)

# P2455 [SDOI2006] 线性方程组 题解
# 题意
在原有的[高斯消元模板](https://www.luogu.com.cn/problem/P3389?contestId=257014)上，增加了判断无解和无数解的判断。
# 思路
先使用高斯消元正常消元，没有唯一解的情况有两种，第一种是**消元后矩阵**第 $i$ 行的前 $n$ 项全为零，第 $n+1$ 项不为零，显然这是无解的，因为零乘任何数都得零，此时出现了 $0 = k (k \neq 0)$ 显然不可能。第二种是**消元后矩阵**主对角线上出现零（排除第一种情况后）。此时我们直接暴力判断，就出现了[一百分求调](https://www.luogu.com.cn/record/223470684)的结果。

为什么呢？造了个样例发现存在几列有值但是消不了，类似这样：

$
\begin{bmatrix}
   0 & 0 & 1 & -1\\
   0 & 0 & 1 & 2 \\
   0 & 0 & 0 & 0
\end{bmatrix}
$

此时应该是无解，但是却输出无数解的结论。因为我们消元时只考虑向下，没有考虑到上面消不掉的情况，导致上述矩阵消元前后结果相同。于是我们可以通过判断上方第 $j$ 行主对角线上是否有值来判断是否可以交换第 $i$ 和第 $j$ 行，有则不能换（[~~老师想出的好办法~~](https://www.luogu.com.cn/user/393419)）。这样就能使其消元完全，不影响接下来的判断。
# 代码

```cpp
#include<bits/stdc++.h>
#define int unsigned long long
constexpr int N = 1e6+5;
constexpr int mod = 2147483647;
constexpr double eps = 1e-9;
using namespace std;
int n;bool f=0;
double a[60][60];
inline int read(){
	int x=0,f=1;
	char ch=getchar();
	while(!isdigit(ch)){
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return x*f;
}
void gauss_mao(){
	for(int i=1;i<=n;i++){
		int id = i;
		for(int j=1;j<=n;j++){//↓判断是否可以交换，若是在其对应对角线上有值则不能换 
			if(fabs(a[j][j]) > eps && j < i)continue;//存在上面（列）无法消元的情况时 
			if(fabs(a[j][i]) > fabs(a[id][i])){ 
				id = j;
			} 
		}
		swap(a[id],a[i]);
		if(fabs(a[i][i]) < eps){
			f=1;
			continue;
		}
		for(int j=n+1;j>=i;j--){
			a[i][j] /= a[i][i];
		}
		for(int j=1;j<=n;j++){
			if(j == i) continue;
			double t = a[j][i] / a[i][i]; 
			for(int k=1;k<=n+1;k++){
				a[j][k] -= t*a[i][k];
			}
		}
	} 
	if(!f){
		for(int i=1;i<=n;i++){
			printf("x%d=%.2lf\n",i,a[i][n+1]);
		}
	} 
	else{
		for(int i=1;i<=n;i++){
			bool flag = 0;
			for(int j=1;j<=n;j++){
				if(fabs(a[i][j]) > eps){
					flag = 1;
					break;
				}
			} 
			if(!flag && fabs(a[i][n+1]) > eps){
				printf("-1\n");
				return; 
			}
		}
		printf("0\n");
	}
}
signed main(){
	n = read();
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n+1;j++){
			a[i][j]=read();
		}
	}
	gauss_mao();
	return 0;
} 
```

---

## 作者：cwxcplh (赞：1)

这道题其实跟[这道板子题](https://www.luogu.com.cn/problem/P3389)很像，但既然出题人把它出成了两道题，那我还是~~勉为其难地~~讲一下我的做法（~~滑稽~~）：

1. 确定一个主元。
2. 确定一个方程。
3. 把这个方程中主元的系数化成 $1$。
4. 用这个方程消掉其他方程中主元。
5. 重复上述操作，直到直接得到答案为止。

~~然后就没有然后了。~~

反映在矩阵上是什么样呢？

一句话来讲：就是把某一行的某个数变成 $1$ 再消掉那一列的数。

举个例子：

$$\begin{bmatrix}1&1&1&6\\5&3&2&17\\2&3&1&11\end{bmatrix}$$

首先选定第一行，选定其中一个数字（这里就用第一个数字了）。然后把这个数字变成 $1$，第一个数字本来就是 $1$，因此不用变，然后用这个数字消掉那一列的数字，指用第一行的第一个数字消掉第一列所有数字（除它之外）。

根据矩阵的性质：任何一行数减去另一行的 $k$ 倍，原矩阵的值不变，可知：我们可以用第二行减去第一行的 $5$ 倍，用第三行减去第一行的 $2$ 倍以消掉第一列除第一行的数之外的其他数，于是这个矩阵变成了这样：

$$\begin{bmatrix}1&1&1&6\\0&-2&-3&-13\\0&1&-1&-1\end{bmatrix}$$

然后重复上面的操作就行了。

最终，这个矩阵会变成这样：

$$\begin{bmatrix}1&0&0&1\\0&1&0&2\\0&0&1&3\end{bmatrix}$$

那么右边那一列就是未知数的解，对应到左边的值上，当前这一行上哪一位是 $1$，那一位所对应的未知数的解就是这一行最后一列的值。

对于判断无解，很简单，只要有一行前面的数全是 $0$ 但最后一个数不是 $0$ 就无解，相应的，只要有一行前面全是 $0$ 最后一个数也是 $0$ 就无数解。

~~代码过分简单，就不在此展示了。~~

**代码实现：**

```cpp
#include<bits/stdc++.h>
#define int long long
#define code using
#define by namespace
#define plh std
code by plh;
int n,vis[56],h[56],bh[56];
const double eps=1e-7;
double a[56][56],f[56];
void Gauss()
{
	for(int i=1;i<=n;i++)
	{
		int id=0;
		for(int j=1;j<=n;j++)
		{
			if(fabs(a[i][j])>eps&&!vis[j])
			{
				id=j;
				break;
			}
		}
		if(id)
		{
			vis[id]=1;
			bh[i]=id;
			h[id]=i;
			for(int j=1;j<=n;j++)
			{
				if(j!=id)
				{
					a[i][j]/=a[i][id];
				}
			}
			f[i]/=a[i][id];
			a[i][id]=1;
			for(int j=1;j<=n;j++)
			{
				if(j!=i)
				{
					for(int k=1;k<=n;k++)
					{
						if(k!=id)
						{
							a[j][k]-=a[i][k]*a[j][id];
						}
					}
					f[j]-=f[i]*a[j][id];
					a[j][id]=0;
				}
			}
		}
		else
		{
			if(fabs(f[i])>eps)//判无解
			{
				cout<<-1;
				n=0;
				return;
			}
		}
	}
}
signed main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			cin>>a[i][j];
		}
		cin>>f[i];
	}
	Gauss();
	if(!n)
	{
		return 0;
	}
	for(int i=1;i<=n;i++)//判无数解
	{
		if(!vis[i])
		{
			cout<<0;
			return 0;
		}
	}
	for(int i=1;i<=n;i++)
	{
		printf("x%lld=%0.2lf\n",i,f[h[i]]);
	}
	return 0;
}
```

---


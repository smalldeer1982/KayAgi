# [SDOI2006] 二进制方程

## 题目描述

一个形如：

X1X2…Xn=Y1Y2..Ym 

的等式称为二进制方程。

在二进制方程的两边：Xi和Yj （1<=i<=n；1<=j<=m）是二进制数字（0、1）或者一个变量（小写字母）。每个变量都是一个有固定长度的二进制代码，他可以在等式中取代变量的位置，称这个长度为变量的长度。为了解一个二进制方程，需要给其中的变量赋予适当的二进制代码，使得我们用他们替代等式中的相应的变量后（等式的两边都变成二进制代码），这个等式成立。

编程任务：

对于每一个给出的方程，计算一共有多少组解。已知变量最多有26个（26个英文小写字母），且等式的每一端的数字和变量的长度之和不超过10000。


## 说明/提示

样例一：4组解

1 、a=1001； b=00

2、 a=1011； b=01

3、 a=1101； b=10

4、 a=1111； b=11）

样例二：K=5，变量：a,b,c,d,e。长度分别为：4 2 4 4 2。等式是：1bad1= acbe

输出16，即变量a,b,c,d,e共有16组解。



## 样例 #1

### 输入

```
2
4 2
1b1
a
```

### 输出

```
4```

## 样例 #2

### 输入

```
5
4 2 4 4 2
1bad1
acbe
```

### 输出

```
16```

# 题解

## 作者：李白莘莘学子 (赞：5)

安利~~蒟蒻~~的博客园：（https://www.cnblogs.com/lbssxz/）
# 正解开始：


------------

首先读懂题意我们知道，每一个字母都代表一个式子，且把每一个字母替换成数字后可以使得左右两个式子相等。

**本人思路来源**：先进行 过样例式的枚举：

考虑这种情况：假如左边式子第1位是a，右边式子第一位是1，一个数字，一个字母，因为题意要满足对应位相等，所以我们可以确定字母a的第一位为1。但是，因为整个字符串中可能有多个a，那么我们找到字符串中的其他的a，把它们第一位对应的位数赋值为1.

然而a的第一位的对应位确定，那么等号另一边的对应位也能确定了，而它又是一个字母，于是我们把这个字母的对应位也找出来进行赋值。。。。。。这么下去，解法逐渐明朗：**并查集**。

具体来说，我们可以按照这种方法，把所有的能遍历到的位置按照并查集处理，并看做一种情况。最后，看还剩几种情况，我们把答案高精度乘为2的几次方就OK了（因为每一位有0，1两种方法）

qwq。

code:

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
const int maxn=10003;

int n,m,k,sum;
int num[maxn],fa[maxn],x[maxn],y[maxn];

inline int find(int x)
{
	if(x==fa[x])return x;
	fa[x]=find(fa[x]);
	return fa[x];
}

int main() {
    num[1]=2; 
    scanf("%d",&k);
    for(int i=2,x;i<=k+1;++i)
	{
        scanf("%d",&x);
        num[i]=num[i-1]+x;
        sum+=x;//记录总不同的个数 
    }
    char zfc[maxn];
    scanf("%s",zfc);
    for(int i=0;zfc[i];++i)
	{
        if(zfc[i]>='a'&&zfc[i]<='z')
		{
            int c=zfc[i]-'a'+1;//获取他是num数组第几个 
            for(int j=num[c];j<num[c+1];++j)x[++n]=j;//按位置赋值 
        }
		else x[++n]=zfc[i]-'0';//数字的话 
    }
    scanf("%s",zfc);
    for(int i=0;zfc[i];++i)
	{
        if(zfc[i]>='a'&&zfc[i]<='z')
		{
            int c=zfc[i]-'a'+1;
            for(int j=num[c];j<num[c+1];++j)y[++m]=j;//字母 
        } else y[++m]=zfc[i]-'0';//数字 
    }
    if(n!=m)//连左右长度都不相等 
	{
        printf("0");return 0;//直接输出零 
    }
    for(int i=1;i<maxn;++i)fa[i]=i;//初始化并查集找父亲 
    for(int i=1;i<=n;++i)
	{
        int dx=find(x[i]),dy=find(y[i]);
        if(dx+dy==1)
		{
            printf("0");
            return 0;
        }
        if(dx!=dy)
		{
            fa[max(dx,dy)]=min(dx,dy);
            sum--;
        }
    }
    int big[maxn]={1},top=1;
    for(int i=sum;i>=1;i--)
	{
        for(int i=0;i<top;++i)big[i]<<=1;
        for(int i=0;i<top;++i)if(big[i]>=10) {
            big[i+1]+=big[i]/10,big[i]%=10;
        }
        for(;big[top];++top) {
            big[top+1]+=big[top]/10,big[top]%=10;
        }
    }
    for(int i=top-1;i>=0;--i) printf("%d",big[i]);
    return 0;
}
```
完结。

---

## 作者：_HLLY_ (赞：5)

apio也有一个用并查集统计方案数的题，但这个题是弱化版。。而且网上竟然一份题解都没有


首先两个串能完全匹配，及说明相对应的两个位置有相等关系，在填0还是1的时候就只能填一次，所以就用并查集把相等的连到一起，统计答案时只统计fu【o】==o的部分，\*2

串中的0和1单独处理，特判即可


码：
`
      


```cpp
#include<iostream>  
#include<cstdio>  
#include<cstring>  
using namespace std;  
#define N 10007  
int fu[N],qsum[200],lena,lenb,za,zb,i,j,n,l[N],f1,f2,wza[N],wzb[N],ans[999999];  
char cha[N],chb[N];  
int find(int o)  
{  
    if(fu[o]!=o)fu[o]=find(fu[o]);  
    return fu[o];  
}  
void c2()  
{  
    int i,jw=0;  
    for(i=1;i<=ans[0];i++)  
    {  
int     o=ans[i]*2+jw;  
    ans[i]=o%10;  
    jw=o/10;  
    }  
    while(jw)ans[++ans[0]]=jw%10,jw/=10;  
}  
int main()  
{  
    scanf("%d",&n);  
    for(i=int('a');i<=int('a')+n-1;i++)  
    scanf("%d",&l[i]),qsum[i]+=l[i-1]+qsum[i-1];  
scanf("%s",cha);  
scanf("%s",chb);  
lena=strlen(cha);  
lenb=strlen(chb);  
l[int('1')]=1;l[int('0')]=1;  
for(i=1;i<=10005;i++)fu[i]=i;  
za=0;zb=0;  
while(za<lena)  
{  
    wza[za]++;  
    wzb[zb]++;  
    if(cha[za]=='1')  
    {  
        f1=10001;  
    }else if(cha[za]=='0')  
    {  
        f1=10002;  
    }else f1=find(qsum[cha[za]]+wza[za]);  
    if(chb[zb]=='1')  
    {  
        f2=10001;  
    }else if(chb[zb]=='0')  
    {  
        f2=10002;  
    }else f2=find(qsum[chb[zb]]+wzb[zb]);  
    if(f1>10000&&f2>10000&&f1!=f2)  
    {  
        printf("0");  
        return 0;  
    }  
    if(f1!=f2)  
    {  
    if(f1>10000)fu[f2]=f1;  
    else fu[f1]=f2;  
    }  
    if(wza[za]==l[cha[za]])za++;  
    if(wzb[zb]==l[chb[zb]])zb++;      
}  
    ans[0]=1;  
    ans[1]=1;  
    for(i='a';i<='a'+n-1;i++)  
    {  
        for(j=1;j<=l[i];j++)  
        {  
            if(find(qsum[i]+j)==qsum[i]+j)c2();  
        }  
    }  
    for(i=ans[0];i>=1;i--)  
    printf("%d",ans[i]);  
}  
`
```

---

## 作者：0xFF (赞：4)

## 正解思路
首先考虑将 $X$ 串和 $Y$ 串拆成每个数位：
将 $k$ 个字母按长度拆成每个数位，然后对应于 $X$ 和 $Y$ 串每个数位的位置，这里需要注意存在 $0$ 和 $1$ 这 $2$ 个数字，因此每个字母对应的数位需要向右移动 $2$ 位。（意思就是说标号需要从2开始标因为存在0和1这两个数字）

### 按照我们上面给出的思路：
a,b 长度分别为 $4,2$ ，则 $a$ 用  $c(2,3,4,5)$ 表示，$b$ 用  $c(6,7)$ 表示。则 串 “ $1b1$ ” 即拆成 $c(1, 6,7, 1)$; 串 ”$a$” 拆成 $c(2,3,4,5)$。
这样 $X$ 和 $Y$ 串对应的位置就应该相同。
即 

$1=c[2]$, $c[6]=c[3]$, $c[7]=c[4]$, $1=c[5]$。

计算方案数我们可以用并查集去处理，首先假设所有字母的长度和为 $tot$，则初始有 $tot$ 个数位可以取值，(实际上是 $2^{tot}$种方案）。
然后每次处理 $X$、$Y$ 串对应数位，相当于并查集合并操作，如果进行了合并操作，则 $tot--$。
最后需要高精度计算 $2^{tot}$ 并输出。
时间复杂度为 $O(k*n)$.

剩下的代码里都说了
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int a[28];
int x[10010],y[10010];
int b[10000];
int p[28];
int f[10010];
int k,n=0,m=0,tot=0;
string s;
int find(int x){//路径压缩 
	return f[x]==x?x:find(f[x]);
} 
int calc(){
	for(int i=0;i<=10000;i++)f[i]=i;
	for(int i=1;i<=n;i++){
		int fx=find(x[i]);
		int fy=find(y[i]);
		if(fx+fy==1)return -1;//两位上一个是0，一个是1说明不相等，直接返回-1 
		if(fx!=fy){
			if(fx<fy)f[fy]=fx;
			else f[fx]=fy;
			tot--;
		}
	}
	return tot;
}
void Print(int k){//高精度输出 
	b[1]=1;
	int m=1;
	for(int i=1;i<=k;i++){
		for(int j=1;j<=m;j++)b[j]*=2;
		for(int j=1;j<=m;j++){
			b[j+1]+=b[j]/10;
			b[j]=b[j]%10;
		}
		if(b[m+1]>0)m++;
	}
	for(int i=m;i>=1;i--)cout<<b[i];
	cout<<endl;
}
int main(){
//	freopen("row.in","r",stdin);
//	freopen("row.out","w",stdout);
	cin>>k;
	for(int i=1;i<=k;i++){
		cin>>a[i];
		tot+=a[i];
	}
	p[1]=2;
	for(int i=2;i<=k+1;i++)p[i]=p[i-1]+a[i-1];
	cin>>s;
	for(int i=0;i<s.size();i++){
		if(s[i]>='a'&&s[i]<='z'){
			int c=s[i]-'a'+1;
			for(int j=p[c];j<p[c+1];j++)x[++n]=j;
		}
		else x[++n]=s[i]-'0';
	}
	cin>>s;
	for(int i=0;i<s.size();i++){
		if(s[i]>='a'&&s[i]<='z'){
			int c=s[i]-'a'+1;
			for(int j=p[c];j<p[c+1];j++)y[++m]=j;
		}
		else y[++m]=s[i]-'0';
	}
	if(n!=m)cout<<0<<endl;
	else{
		int ans=calc();
		if(ans==-1)cout<<0<<endl;
		else Print(ans);
	}
	return 0;
}
```

---

## 作者：Gokix (赞：3)

[P2456](https://www.luogu.com.cn/problem/P2456)

感觉做出这题挺有成就感的，所以写一篇题解比较详细记录一下。

------------

首先可以考虑到的就是把两个方程抻成**一样长**的，这样就好做许多了。

方法很简单。假如对于一个长度为 $len_a$ 的未知数 $a$，我们把它分解成 $a_1,a_2,a_3,... ,a_{len_a}$。如此，我们就把多个长度不同的变量变成了长度为一的元素。

然后你发现如果抻长后两个方程长度不一样，那你就可以直接输出无解了。

如果长度一样，那么对于长度为 $m$ 的两个方程 $A,B$，有 $m$ 个等式：$A_i=B_i,1 \le i \le m$。这暗示我们可以用**并查集**做。

我们把相同的两个未知量合并到同一个并查集里。同时，如果某个未知量对应的是 $0$ 或 $1$，我们把它的值存到一个 $w$ 数组中。所有未知量合并完之后统计每个元素所在并查集的值即可确定该元素的值。

注意在并查集的时候如果某个元素或并查集的值既是 $0$ 又是 $1$，那直接无解。

最后我们判断有多少个元素无法确定值，记有 $cnt$ 个，则答案就是 $2^{cnt}$。

------------

最后说几个实现的细节：

抻长元素的时候可以用标号法避免二维并查集。由于每个字母最多被抻长成 $10000$ 位的，所以我们可以对于 $R_i$（$R$ 为任意字母）标号为 $(R-a) \times 10000+i$。这样每一个元素都有一维的对应标号。

但与此同时我们最后判断哪些元素的值无法确定时要当心某个标号是否根本就不在方程中。（比如说 $a$ 的长度是 $5$，则标号 $6$ 就是不存在原方程中的，这时候就不能统计上 $6$）

答案输出的时候需要高精，最大是 $2^{10000}$，有 $3100$ **多**位。

------------

CODE：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;

long long n,m,len[30],a[300010],ha,b[300010],hb,f[300010],w[300010],vis[30][10010],cnt;
const long long maxl=10000;
string s,t;

struct BIG{
	long long d[5000]; 
}ans;
BIG operator *(BIG A,long long B){
	long long i,j=0;
	BIG C;
	C.d[0]=A.d[0]+1;
	for(i=1;i<=C.d[0];i++){
		C.d[i]=A.d[i]*B+j;
		if(C.d[i]>=10){
			j=C.d[i]/10;
			C.d[i]%=10;
		}
		else{
			j=0;
		}
	}
	while(C.d[C.d[0]]==0) C.d[0]--;
	return C;
}
void printBIG(BIG A){
	long long i;
	for(i=A.d[0];i>=1;i--){
		cout<<A.d[i];
	}
	cout<<endl;
}

long long ed(long long u,long long v){
	if(u%v==0) return u/v-1;
	return u/v;
}
long long em(long long u,long long v){
	if(u%v==0) return v;
	return u%v;
}

long long find(long long u){
	if(u==f[u]) return u;
	return f[u]=find(f[u]);
}
void merge(long long u,long long v){
	long long uu=find(u),vv=find(v);
	if(uu!=vv) f[uu]=vv;
}

int main(){
	memset(w,-1,sizeof(w));
	long long i,j,u,v,lens,lent,k;
	cin>>n;m=n*maxl;
	for(i=1;i<=m;i++) f[i]=i;
	for(i=1;i<=n;i++){
		cin>>len[i];
	}
	cin>>s>>t;
	lens=s.size(); lent=t.size();
	for(i=0;i<lens;i++){//抻长方程1
		if('a'<=s[i] && s[i]<='z'){
			for(j=1;j<=len[s[i]-'a'+1];j++){
				a[++ha]=(s[i]-'a')*maxl+j;//标号转化
			}
		}
		else if(s[i]=='1'){
			a[++ha]=-1;
		}
		else{
			a[++ha]=0;
		}
	}
	for(i=0;i<lent;i++){//抻长方程2
		if('a'<=t[i] && t[i]<='z'){
			for(j=1;j<=len[t[i]-'a'+1];j++){
				b[++hb]=(t[i]-'a')*maxl+j;//标号转化
			}
		}
		else if(t[i]=='1'){
			b[++hb]=-1;
		}
		else{
			b[++hb]=0;
		}
	}
	if(ha!=hb){//方程长度不同，无解
		cout<<0<<endl;
		return 0;
	}
	for(i=1;i<=ha;i++){
		if(a[i]<=0){
			if(b[i]<=0){
				if(a[i]!=b[i]){
					cout<<0<<endl;
					return 0;
				}
			}
			else{
				k=-a[i];
				if(w[b[i]]>-1 && w[b[i]]!=k){//元素值冲突，无解
					cout<<0<<endl;
					return 0;
				}
				else{
					w[b[i]]=k;
				}
			}
		}
		else if(b[i]<=0){
			if(a[i]<=0){
				if(a[i]!=b[i]){
					cout<<0<<endl;
					return 0;
				}
			}
			else{
				k=-b[i];
				if(w[a[i]]>-1 && w[a[i]]!=k){//同上无解
					cout<<0<<endl;
					return 0;
				}
				else{
					w[a[i]]=k;
				}
			}
		}
		else{
			merge(a[i],b[i]);//合并元素
		}
	}
	for(i=1;i<=m;i++){
		if(w[i]>-1){
			u=find(i);
			if(w[u]>-1){
				if(w[u]!=w[i]){
					cout<<0<<endl;
					return 0;
				}
			}
			else{
				w[u]=w[i];
			}
		}
	}
	for(i=1;i<=m;i++){//查询每个元素的值
		if(w[i]==-1){
			w[i]=w[find(i)];
		}
	}
	for(i=1;i<=m;i++){//统计还有多少个元素的值无法确定
		if(f[i]==i && w[i]==-1){
			u=ed(i,maxl)+1;//注意这里标号的转化，并不是直接除和直接模
			v=em(i,maxl);//比如说10000是a10000，而非b0
			if(len[u]>=v){
				vis[u][v]=1;
			}
		}
	}
	for(i=1;i<=n;i++){//统计还有多少个元素的值无法确定
		for(j=1;j<=len[i];j++){
			if(vis[i][j]) cnt++;
		}
	}
	ans.d[0]=1;//高精度
	ans.d[1]=1;
	while(cnt--){
		ans=ans*2;
	}
	printBIG(ans);
	return 0;
}
```


---

## 作者：lalaji2010 (赞：2)

# P2456

## 分析

首先要把题意搞明白。等式两边都是由 $0$ 或 $1$ 构成的，在其中有一些小写字母，代表一定长度的二进制串，最终则是要求解有多少种。

等式两边的串一定是完全相同的，也就是说两边长度要一致并且对应位置的数字要相等。那么对于每个不确定的位置都可以有两种取值 $0$ 或 $1$，但是对于等式两边处于相同的数位的两个不确定的位置取值应该相同，应将其放在同一个取值集合里。设最终的集合有 $k$ 个，那么答案就应该是 $2^k$。

说到这里，这道题的做法应该是呼之欲出了。最初数字不确定的位置数量 $k$ 应该是所有字母长度的总和。我们再将两字符串里的字母展开并对于每个位置进行编号，比较位数是否相同。如果相同则使用并查集按位依次将等式两边相同数位的数放在一个集合里，统一认代表的数值小的点为父亲，保证最终的并查集内根一定是 $0$ 和 $1$。最终数字不确定的位置减少一个。如果发现将放进同一个集合的两个数分别处于 $0$ 的集合和 $1$ 的集合里，则矛盾，解的数量为 $0$。否则最后输出前面所说的 $2^k$ 即可。

 
$2^k$ 会很大，**记得写高精度**。

## AC Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int k,sum=0,n=0,m=0;
int a[30],cnt[35],s1[10005],s2[10005],h[10005];
string s;
int fa[10005];
int find(int k){
	if(fa[k]==k) return fa[k];
	return fa[k]=find(fa[k]);
}
void check(){
	for(int i=0;i<=10002;i++) fa[i]=i;
	for(int i=1;i<=n;i++){
		int x=s1[i],y=s2[i];
		int fx=find(x),fy=find(y);
		if(fx+fy==1){
			sum=-1;
			return ;
		}
		if(fx!=fy){
			if(fx<fy){
				fa[fy]=fx;
			}else{
				fa[fx]=fy;
			}
			sum--;
		}
	}
}
void haa_print(int tot){
	int cnt1=1;
	h[1]=1;
	for(int i=1;i<=tot;i++){
		for(int j=1;j<=cnt1;j++){
			h[j]*=2;
		}
		for(int j=1;j<=cnt1;j++){
			h[j+1]+=h[j]/10;
			h[j]=h[j]%10;
		}
		if(h[cnt1+1]>0) cnt1++;
	}
	for(int i=cnt1;i>=1;i--){
		cout<<h[i];
	}
	cout<<"\n";
}
int main(){
	cin>>k;
	for(int i=1;i<=k;i++){
		cin>>a[i];
		sum+=a[i];
	}
	cnt[1]=2;//cnt[i]表示字符i+'a'-1前面已经编好号的个数
	for(int i=2;i<=k+1;i++){
		cnt[i]=cnt[i-1]+a[i-1];
	}
	cin>>s;
	for(int i=0;i<s.size();i++){
		if(s[i]>='a'&&s[i]<='z'){
			int num=s[i]-'a'+1; 
			for(int j=cnt[num];j<cnt[num+1];j++){
				s1[++n]=j;
			}
		}else{
			s1[++n]=s[i]-'0';
		}
	}
	cin>>s;
	for(int i=0;i<s.size();i++){
		if(s[i]>='a'&&s[i]<='z'){
			int num=s[i]-'a'+1; 
			for(int j=cnt[num];j<cnt[num+1];j++){
				s2[++m]=j;
			}
		}else{
			s2[++m]=s[i]-'0';
		}
	}
	if(n!=m){
		cout<<0<<"\n";//长度不同无解
		return 0;
	}
	check();
	if(sum==-1){
		cout<<0<<"\n";//方程不成立无解
		return 0;
	}
	haa_print(sum);
	return 0;
} 
```

---

## 作者：MC_dmAC (赞：1)

[一个奇怪的隧道](https://www.luogu.com.cn/problem/P2456)

~~感觉这题像并查集模板~~

**大致思路**：先将左右两侧的字符串对齐，每一位用并查集合并，最后寻找有 $ans$ 位的数不受其他数影响，答案即为 $2^{ans}$。

### 对齐
首先将题目第二行所给长度记作 $var_i$，每个变量拉伸为 $var_i$ 长度。

**eg.** 以样例一为例，可拉伸为如下形式
$$
|1|b_1|b_2|1|\\
|a_1|a_2|a_3|a_4|
$$

### 合并
由题意我们可以知道，等号两边对印位置的数字相等，因此我们可以用并查集 $f_i$ 将它们关联起来。

**eg.** 同样以样例一为例， $f_i$ 对印关系如下。
$$
|f_0|f_1|f_2|f_3|f_4|f_5|f_6|f_7|\\
|0\ |1\ |a_1|a_2|a_3|a_4|b_1|b_2|
$$
然后，我们按位让等号两边对应位相等（合并并查集，最好将根节点较大的合并到较小的，这样比较方便 [doge]），可得到如下的 $f_i$ 。
$$
|f_0|f_1|f_2|f_3|f_4|f_5|f_6|f_7|\\
|\ 0\ |\ 1\ |\ 1\ |\ 3\ |\ 4\ |\ 1\ |\ 3\ |\ 4\ |
$$

### 答案
当我们把等号两侧的信息合并为一个并查集 $f_i$ 后，显然只有 $f_i=i$ 的位才不会受到其他位的影响，并且与其他有相同性质的位相互独立。 $f_i$ 中除 $f_0$ 和 $f_1$ 以外，共 $ans$ 位符合 $f_i=i$ 的性质。

通过乘法原理，答案即为 $2^{ans}$。

### Code

```cpp
#include<iostream>
#include<cstring>
#include<cmath>
using namespace std;
#define f(n) for(int i=1;i<=n;i++)
int var[27],n,f[270010],ans;
string l,r;
string cl(string x)//拉伸等号两侧 
{
	string ls;
	ls.clear();
	f(x.length())
		if(x[i-1]=='1'||x[i-1]=='0')ls+=x[i-1];
		else for(int j=1;j<=var[x[i-1]-'a'];j++)ls+=x[i-1];
	return ls;
}
int fd(int now)//合并并查集 
{
	if(f[now]==now)return now;
	return f[now]=fd(f[now]);
}
void d(int now,int nw)//将每个var转为记录对应变量在f中第一位的位置 
{
	if(now==n+1)
	{
		n=nw-1;//end
		return;
	}
	d(now+1,var[now]+nw);
	var[now]=nw;
}
int v(char c)//统一处理字符到f的转换 
{
	if(c=='1'||c=='0')return c-'0';
	return var[c-'a'];
}
int high[1000001]={0,1},hl=1;//高精度 
int main()
{
	f(270009)f[i]=i;
	ios::sync_with_stdio(0);
	cin>>n;
	f(n)cin>>var[i-1];
	cin>>l>>r;
	l=cl(l);
	r=cl(r);
	d(0,2);
	//下方为 
	int ls=0,rs=0,lf,rf;
	//ls记录当前位是对应变量中的第几位，rs同理但是记录等号右侧 
	f(l.length())
	{
		if(i>1)
		{
			if(l[i-1]==l[i-2])ls++;
			else ls=0;
			if(r[i-1]==r[i-2])rs++;
			else rs=0;
		}
		lf=fd(v(l[i-1])+ls);
		rf=fd(v(r[i-1])+rs);
		//lf，rf为两方所在并查集根节点 
		if(lf+rf==1)//以防万一存在无解情况 
		{
			cout<<0;
			return 0;
		}
		if(lf<rf)f[rf]=f[lf];
		else f[lf]=f[rf];
	}
	//计算独立位的数量 
	f(n-1)if(f[i+1]==i+1)ans++;
	//高精度 
	int jc;
	f(ans)
	{
		jc=0;
		for(int j=1;j<=hl;j++)
    	{
			high[j]=high[j]*2+jc;
			jc=high[j]/10;
			high[j]%=10;
		}
		if(jc!=0)high[++hl]=jc;
	}
	f(hl)cout<<high[hl-i+1];
	return 0;
}
```

---

## 作者：SamHJD (赞：1)

## [P2456 [SDOI2006] 二进制方程](https://www.luogu.com.cn/problem/P2456)

### 题意

有至多 $26$ 个未知二进制变量，每个变量有一个长度 $len_i$。给你两个字符串，仅包含 $0,1$ 与小写字母变量，你可以把一个变量的所有出现位置替换为一个长为 $len_i$ 的二进制，求有多少种替换方法可以使两个字符串相等。

### 解法

观察样例 $2$，我们先将所有变量扩展开，变为：

```cpp
s:1bbaaaadddd1
t:aaaaccccbbee
```

因为要使上下一样，我们便可以确定一些字符的数，如所有 $a$ 的第一位必为 $1$，因为第一个串的第一位为 $1$，而对应的第二个串的第一个为 $a$ 的第一位。

于是我们将所有固定下来的字符替换为 $0,1$：

```cpp
s:1bb1aa1dddd1
t:1aa1cc1cbbe1
```
再观察上面两个字符串，对于某一个字符，我们可以找到一些字符与他的量必须相等。例如我们以 $t_2$ 的 `a` 视作一个变量（这里下标从 $1$ 开始），那么 $s_2,t_5$ 必须都和 $t_2$ 相等。

于是我们尝试处理出哪些字符集必为同一个量，最终每个字符集都会有两种取值可能，输出 $2$ 的字符集数量次方即可。可以用并查集上下 `merge()`，亦可以建边跑连通块。这里用的是并查集写法。

------------

接下来一步步实现，首先我们将原字符串扩张：

```cpp
void expand(){
	//aa,bb为输入的原串，我们扩展后存入a,b
	for(int i=0;i<aa.size();++i){
		if(aa[i]=='1'||aa[i]=='0') a+=aa[i];
		//数字位直接放入
		else for(int j=1;j<=len[aa[i]-'a'+1];++j) a+=aa[i];
		//否则放入len次
	}
	for(int i=0;i<bb.size();++i){//b同理
		if(bb[i]=='1'||bb[i]=='0') b+=bb[i];
		else for(int j=1;j<=len[bb[i]-'a'+1];++j) b+=bb[i];
	}
	//注意可能长度不同，要将短的那个补上0
	if(a.size()>b.size()) swap(a,b);
	while(a.size()<b.size()) a='0'+a;
	l=a.size();
	//最终长度
}
```

接下来我们要为并查集做预处理，我们要将每个变量的每一位设置一个 $id$，注意每一个变量可能在不同位置出现很多次，但是它的第 $i$ 位的 $id$ 是同一个值。

```cpp
void getid(string &s,int typ){
	//将s进行预处理id，typ=1他就是第一个字符串，否则是第二个字符串
	for(int i=0;i<l;++i){
		if(i==0||s[i]!=s[i-1]) cnt=1;
		//cnt为当前这个变量扩张后在i时是第几位
		if(mp[{s[i]-'a'+1,cnt}]) id[typ][i]=mp[{s[i]-'a'+1,cnt}];
		//已经被标记了一个id，存在map中，直接调取
		else mp[{s[i]-'a'+1,cnt}]=++tot,id[typ][i]=tot;
		//否则设置一个新的id
		cnt++;
	}
	//最终有tot个不同的id
}
```

然后是求解答案，我们分成三部分：

首先将能固定下来的字符标记 $0,1$。

```cpp
memset(know,-1,sizeof(know));
//know：固定下来的位置的数
for(int i=0;i<l;++i){
	if(isdigit(a[i])) know[id[1][i]]=a[i]-'0';
	if(isdigit(b[i])) know[id[2][i]]=b[i]-'0';
}
//每个数字肯定是能固定的
bool flag=1;
while(flag){
	//while直到没有位置能被固定
	flag=0;
	for(int i=0;i<l;++i){
		if(know[id[1][i]]!=-1&&know[id[2][i]]!=-1&&know[id[1][i]]!=know[id[2][i]]){
			//两个对应位置都被固定，数却不一样，无解
			printf("0");
			exit(0);
		}
		else if(know[id[1][i]]!=-1&&know[id[2][i]]==-1) know[id[2][i]]=know[id[1][i]],flag=1;
		else if(know[id[2][i]]!=-1&&know[id[1][i]]==-1) know[id[1][i]]=know[id[2][i]],flag=1;
		//将没有固定的位置的数设为固定了的那个对应位置的数
	}
}
```

然后对没有固定的位置上下合并，找出不同祖先的个数，每个祖先下的所有位置必为同一个量。

```cpp
for(int i=1;i<=tot;++i) f[i]=i;
for(int i=0;i<l;++i){
	if(know[id[1][i]]==-1&&know[id[2][i]]==-1){
		//都没有固定，合并两个数的id，它们俩必为同一个量
		merge(id[1][i],id[2][i]);
	}
}
for(int i=0;i<l;++i){
	if(know[id[1][i]]==-1&&know[id[2][i]]==-1){
		int fath=getfa(id[1][i]);
		if(!mp1[fath]) ans++,mp1[fath]=1;
	}
}
```

最后高精计算答案。

```cpp
//每次乘2的高精，注意别开小数组
int lth=1;res[lth]=1;
for(int i=1;i<=ans;++i){
	for(int j=1;j<=lth;++j) res[j]*=2;
	//先乘
	for(int j=1;j<=lth;++j) while(res[j]>=10) res[j]-=10,res[j+1]++;
	//进位
	if(res[lth+1]) lth++;
	//最大一位进位了，长度+1
}
for(int j=lth;j>=1;--j) cout<<res[j];
```

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+10;
int k,len[N],f[N],id[5][N],cnt,l,tot,ans,res[N];
map<pair<int,int>,int> mp;
map<int,int> mp1;
string aa,bb,a,b;
int getfa(int x){
	if(f[x]==x) return x;
	else return f[x]=getfa(f[x]);
}
void merge(int x,int y){
	f[getfa(x)]=getfa(y);
}
void expand(){
	for(int i=0;i<aa.size();++i){
		if(aa[i]=='1'||aa[i]=='0') a+=aa[i];
		else for(int j=1;j<=len[aa[i]-'a'+1];++j) a+=aa[i];
	}
	for(int i=0;i<bb.size();++i){
		if(bb[i]=='1'||bb[i]=='0') b+=bb[i];
		else for(int j=1;j<=len[bb[i]-'a'+1];++j) b+=bb[i];
	}
	if(a.size()>b.size()) swap(a,b);
	while(a.size()<b.size()) a='0'+a;
	l=a.size();
}
int know[N];
void solve(){
	memset(know,-1,sizeof(know));
	bool flag=1;
	for(int i=0;i<l;++i){
		if(isdigit(a[i])) know[id[1][i]]=a[i]-'0';
		if(isdigit(b[i])) know[id[2][i]]=b[i]-'0';
	}
	while(flag){
		flag=0;
		for(int i=0;i<l;++i){
			if(know[id[1][i]]!=-1&&know[id[2][i]]!=-1&&know[id[1][i]]!=know[id[2][i]]){
				printf("0");
				exit(0);
			}
			else if(know[id[1][i]]!=-1&&know[id[2][i]]==-1) know[id[2][i]]=know[id[1][i]],flag=1;
			else if(know[id[2][i]]!=-1&&know[id[1][i]]==-1) know[id[1][i]]=know[id[2][i]],flag=1;
		}
	}
    
	//--------
    
	for(int i=1;i<=tot;++i) f[i]=i;
	for(int i=0;i<l;++i){
		if(know[id[1][i]]==-1&&know[id[2][i]]==-1){
			merge(id[1][i],id[2][i]);
		}
	}
	for(int i=0;i<l;++i){
		if(know[id[1][i]]==-1&&know[id[2][i]]==-1){
			int fath=getfa(id[1][i]);
			if(!mp1[fath]) ans++,mp1[fath]=1;
		}
	}
    
	//--------
    
	int lth=1;res[lth]=1;
	for(int i=1;i<=ans;++i){
		for(int j=1;j<=lth;++j) res[j]*=2;
		for(int j=1;j<=lth;++j) while(res[j]>=10) res[j]-=10,res[j+1]++;
		if(res[lth+1]) lth++;
	}
	for(int j=lth;j>=1;--j) cout<<res[j];
}
void getid(string &s,int typ){
	for(int i=0;i<l;++i){
		if(i==0||s[i]!=s[i-1]) cnt=1;
		if(mp[{s[i]-'a'+1,cnt}]) id[typ][i]=mp[{s[i]-'a'+1,cnt}];
		else mp[{s[i]-'a'+1,cnt}]=++tot,id[typ][i]=tot;
		cnt++;
	}
}
int main(){
	scanf("%d",&k);
	for(int i=1;i<=k;++i) scanf("%d",&len[i]);
	cin>>aa>>bb;
	expand();
	getid(a,1);
	getid(b,2);
	solve();
	return 0;
}
```


---

## 作者：_zzzzzzy_ (赞：1)

## 题意
给出两个等式，由 $1,0$ 和小写字母组成，然后给出 $k$ 个未知的二进制数。

然后 $k$ 个整数，然后给出每个未知二进制数的位数。

最后判断二进制数有几组解。

## 思路

是一道比较不错的并查集题目。

可以先把每一个未知数具体到每一位，我们再把的长度为 $x$ 二进制数 $a$ 拆分成 $a_1,a_2,a_3\dots a_{x-1},a_{x}$ 的样子。

然后我们把两个等式都拆分好后如果长度不一样，就直接输出 $0$，如果两个等式有 $0$ 和 $1$ 在同一位上，那么也输出 $0$。

接下来把等式相同位的未知位合并起来，如果是数字和未知位在一起一定要把未知位合并到数字上，因为那个未知位是已经确定了的。

然后找还可以选择的二进制位，设为 $tot$。

最后答案就是 $2^{tot}$，这个 $tot$ 最大有 $10000$ 所以要用高精度，[这是](https://www.luogu.com.cn/paste/fr1c34j5)我的高精度板子，代码中只显示主函数部分。

## 代码

```cpp
int n,m,k,sum,f[maxn],fa[maxn],x[maxn],y[maxn];
char s1[maxn],s2[maxn];
inline int F(int x) {return x==fa[x]?x:fa[x]=F(fa[x]);}
signed main() {
	cin>>k;
	f[1]=2;
	for(int i=1,x; i<=k; i++) {
		cin>>x;
		f[i+1]=f[i]+x,sum+=x;
	}
	cin>>(s1+1);
	for(int i=1; i<=(int)strlen(s1+1); i++) {
		if(s1[i]=='1'||s1[i]=='0')
			x[++n]=s1[i]-'0';
		else
			for(int j=f[s1[i]-'a'+1]; j<f[s1[i]-'a'+2]; ++j)
				x[++n]=j;
	}
	cin>>(s2+1);
	for(int i=1; i<=(int)strlen(s2+1); i++) {
		if(s2[i]=='1'||s2[i]=='0')
			y[++m]=s2[i]-'0';
		else
			for(int j=f[s2[i]-'a'+1]; j<f[s2[i]-'a'+2]; j++)
				y[++m]=j;
	}
	if(n!=m)return cout<<0,0;
	for(int i=0;i<=maxn-5;i++)fa[i]=i;
	for(int i=1;i<=n;i++){
		int fx=F(x[i]);
		int fy=F(y[i]);
		if(fx+fy==1)return cout<<0,0;//一0一1的情况
		if(fx!=fy){//合并同位的未知位
			if(fx<fy)fa[fy]=fx;//保证未知数和数字合并时让数字在顶
			else fa[fx]=fy;
			sum--;
		}
	}
	cout<<lll(2).pow(sum);
	return 0;
}
```

---

## 作者：YHASDY (赞：1)

新人发的第一篇题解，请关照。。。

显然还是先将长短不一的字符串转换成长度一样的表达式后处理才方便。

处理完成后，发现会有很多相等的关系。对于每个相等的关系，我们可以用一条边表示。将表达式的每个位置看做一个点。对于两个相等的位置，将两个位置对应的两个点连双向边就好。

在考虑一下相等的关系都有哪些：

      首先在两个表达式中位置相等的元素必然相同，连一连。
      然后在同一个字母变量中位置相等的元素必然相同，连一连。

这样，整体的复杂的相等关系就被分成不重不漏的两种了。第一种很容易连边，说一下第二种连边怎么实现。

只要两个元素在同一连通块中，他们就是相等的。因此可以记录每个字母变量每个位置上最后出现的元素x，用类似链表连接的方式连边就OK啦。

连完边后，所有相等关系就全部被表示出来了。我们可以从所有已知点权的点（即一开始就知道是0还是1的元素）出发跑BFS，将能到达的点（包括自身）全部标记为已到达。若到达了一个点，这个点的点权已知，但是不等于此次BFS起点的点权，说明有矛盾，输出0后结束程序就完事儿了。

若在上文的BFS都结束后还有点没被遍历到，且程序未结束，说明这些点都是靠一开始的0和1无法确定的点。这些点的形式应该为连通块们，且不同连通块相互不影响。每个连通块都会贡献一个“方案数乘2”，于是我们再做BFS求出所有连通块的个数，最后做一遍高精快速幂就AC了。

好像还有个问题：为什么所有元素取值的方案数就是解的个数？一个变量可能包括很多元素啊。其实可以发现，这两种情况都是用乘法原理计算的，先算所有变量的取值情况的话，较求所有元素的取值方案数只是多了些括号罢了，并不影响答案。

最后再谈一下时间复杂度。整体算法的平均复杂度约为O(n）级别，要比（楼上/楼下）并查集快不少。实际还能优化：可以把高精度计算的压位级别增高、BFS中不用给未知点权的点赋值等等。（不过真不知道第一快的0ms是怎么跑出来的）

看看代码吧：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring> 
#include<queue>

using namespace std;

int n,lm[30];//每个字母长度
int tolen;//真正表达式长度 
int maxnode,quan[20008];
long long toans;//贡献答案用的连通块的个数/快速幂的指数 

char s[2][10008];

struct equation{//存表达式 
	bool isnum;
	int mu,wei;
}equ[3][10008];

inline int init(int k)//字符串转表达式 
{
	int l=strlen(s[k]),step=1,m,w,r;
	for(int i=0;i<l;++i)
	{
		if(s[k][i]=='0'||s[k][i]=='1')
		{
			equ[k][step].isnum=1;
			equ[k][step++].mu=s[k][i]=='1';
		}
		else
		{
			m=s[k][i]-'a'+1;
			r=step+lm[m]-1,w=1;
			for(;step<=r;step++)
			{
				equ[k][step].mu=m;
				equ[k][step].wei=w++;
			}
		}
	}
	return step-1;
}

#define xb(k) equ[k][step].mu][equ[k][step].wei

int	fina[30][10008],lst[20008],nxt[100000],cnt,to[100000];

inline void addedge(int u,int v)
{
	nxt[++cnt]=lst[u];
	lst[u]=cnt;
	to[cnt]=v;
}

void ADDEDGE()
{
	int len=1;
	int *p;
	for(int step=1;step<=tolen;step++,len++)
	{
		addedge(len,len+tolen);
		addedge(len+tolen,len);
		if(!equ[1][step].isnum)
		{
			p=&fina[xb(1)];
			if(*p==0)
				*p=len;
			else
			{
				addedge(*p,len);
				addedge(len,*p);
				*p=len;
			}
		}
		else
			quan[len]=equ[1][step].mu;
		
	}
	for(int step=1;step<=tolen;step++,len++)
	{
		if(!equ[2][step].isnum)
		{
			p=&fina[xb(2)];
			if(*p==0)
				*p=len;
			else
			{
				addedge(*p,len);
				addedge(len,*p);
				*p=len;
			}
		}
		else
			quan[len]=equ[2][step].mu;
	}
	maxnode=len-1;
}

bool vis[20008];

queue<int>q;

inline int bfs(int sta,int key)
{
	vis[sta]=1;
	q.push(sta);
	int head,t;
	while(!q.empty())
	{
		head=q.front();
		q.pop();
		for(int e=lst[head];e;e=nxt[e])
		{
			t=to[e];
			if(!vis[t])
			{
				if(quan[t]!=-1&&(quan[t]!=key))
					return 1;
				quan[t]=key;
				vis[t]=1;
				q.push(t);
			}
		}
	}
	return 0;
}

const int P=10000;

struct gaojing{
	long long num[2600];
	int len;
	void qingling()
	{
		memset(num,0,sizeof num);
		len=0;
	}
}endans,c,with,di;

inline gaojing operator *(const gaojing &a,const gaojing &b)
{
	c.qingling();
	int ll;
	for(int i=1;i<=b.len;i++)
		for(int j=1;j<=a.len;j++)
		{
			c.num[i+j-1]+=b.num[i]*a.num[j];
		}
	for(ll=1;ll<=b.len+a.len;ll++)
	{
		if(c.num[ll]>=P)
		{
			c.num[ll+1]+=c.num[ll]/P;
			c.num[ll]%=P;
		}
	}
	while(ll>1&&c.num[ll]==0) --ll;
	c.len=ll;
	return c;
}

gaojing ksm(int mi)//高精快速幂 
{
	di.len=1;
	di.num[1]=1;
	with.len=1;
	with.num[1]=2;
	while(mi)
	{
		if(mi&1) di=di*with;
		with=with*with;
		mi>>=1;
	}
	return di;
}

void print(const gaojing &a)
{
	printf("%d",a.num[a.len]);
	int x;
	for(int i=a.len-1;i>=1;--i)
	{
		x=a.num[i];
		if(x<1000) putchar('0');//注意中间的0不能省略 
		if(x<100) putchar('0');
		if(x<10) putchar('0');
		printf("%d",x);
	}
}

int main()
{
	cin>>n;
	for(int i=1;i<=n;i++) cin>>lm[i];
	cin>>s[1]>>s[2];
	if(n<=0)
	{
		cout<<0;
		return 0;
	}
	tolen=init(1);
	if(tolen!=init(2))
	{
		cout<<0;
		return 0;
	}
	memset(quan,-1,sizeof quan);
	ADDEDGE();
	for(int i=1;i<=maxnode;i++)
		if(!vis[i]&&(quan[i]==1||quan[i]==0))
		{
			if(bfs(i,quan[i]))
			{
				cout<<0;
				return 0;
			}
		}
	int mi=0;
	for(int i=1;i<=maxnode;i++)
		if(!vis[i])
		{
			mi++;
			bfs(i,-1);
		}
	endans=ksm(mi);
	print(endans);
	return 0;
}                                                           
```
欢迎提问/挑刺

---

## 作者：Wei_Han (赞：0)

一开始思路就是将已有的数字对应到串内，可是两字符串数字，字母的数量均不确定，下标处理很麻烦，不如换个思路，考虑将原串拓展，记录每个字母是原字母拆分后第几个出现的。

此时两个串的每个字母就能做到一一对应了，而上下两字代表值是相同的，也就是具有传递关系，自然能够想到并查集。

考虑二维并查集，记录 $fa_{i,j}$ 表示字母 $i$ 拆分后第 $j$ 个小字母对应的值，逐个合并即可，合并时优先将已经确定对应值为 $1$ 或 $0$ 的值当做祖先与对应位置进行合并。

对于不合法情况，需要分类讨论：

- 当某一拆分后字母 $x$ 同时能够对应 $1$ 和 $0$ 时不合法。（如果第八个点过不去需注意）
- 当两个串的某一位置分别为 $0$ 和 $1$ 时不合法。
- 当一拆分后字母 $x$ 已经对应 $1$ 和 $0$，可是另一串对应位置出现数字相异时不合法
- 当两原字符串拆分之后长度不符，不合法。

最后统计并查集个数即可，每个并查集代表一位可以随意取的字符，如果这样的位有 $ans$ 个，那么答案就为 $2^{ans}$，由于 $ans$ 可能达到 $10000$，需要高精度进行运算。

时间复杂度取决于最后高精写法。
### Code
```cpp
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f3f3f3f3f
#define pr printf("\n")
#define pp printf(" ")
#define pii pair<ll,ll>
#define mem(aa,bb) memset(aa,bb,sizeof(aa))
#define fo(a,i,b) for(ll i = a ; i <= b ; i ++ )
#define Fo(a,i,b) for(ll i = a ; i >= b ;-- i  )
#define bug(x,y) (x<1||y<1||x>15||y>15)
using namespace std;
typedef long long ll;
typedef double db;
const int N=1e6+5,M=1e7+5;
inline void read(ll &opp){ll x=0,t=1;char ch;ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-'){t=-1;}ch=getchar();}while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}opp=x*t;return; }
inline void wr(ll x){if(x<0){putchar('-');x=-x;}if(x>9){wr(x/10);}putchar(x%10+'0');}
map<pii,pii > fa;
map<pii,ll  > vis;
ll n,m,k,len[N],answ[M],lenth=1;
string s1,s2,s3,s4;
inline pii Find(pii x){return fa[x]=fa[x]==x?x:Find(fa[x]);}
inline void Link(pii x,pii y){pii xx=Find(x),yy=Find(y);if(xx==yy) return;fa[xx]=yy;}
inline void init(){
	s3=s4="";
	fo(0,i,s1.size()-1){
		s3+=s1[i];
		if(s1[i]=='0'||s1[i]=='1') continue;
		fo(1,j,len[s1[i]-'a'+1]-1) s3+=s1[i]; 
	}
	fo(0,i,s2.size()-1){
		s4+=s2[i];
		if(s2[i]=='0'||s2[i]=='1') continue;
		fo(1,j,len[s2[i]-'a'+1]-1) s4+=s2[i];
	}
	s1=s3,s2=s4;
}
inline void Get(){
	fo(1,i,lenth) answ[i]*=2;
	fo(1,i,lenth) answ[i+1]+=answ[i]/10,answ[i]%=10;
	lenth++;
	while(answ[lenth]) answ[lenth+1]+=answ[lenth]/10,answ[lenth]%=10,lenth++;
	lenth--;
}
signed main(){
	read(m);k=m;
	fo(1,i,m) read(len[i]);
	fo(1,i,m) fo(1,j,len[i]) fa[{i,j}]={i,j};fa[{m+1,1}]={m+1,1},fa[{m+1,0}]={m+1,0};
	cin>>s1>>s2;
	init();if(s1.size()!=s2.size()){wr(0);return 0;}
	ll cnt1=1,cnt2=1;
	s3=s1,s4=s2;
	s3=" "+s3;s4=" "+s4;
	fo(1,i,s3.size()-1){
		if(s4[i]==s4[i-1]) cnt2++;else cnt2=1;
		if(s3[i]==s3[i-1]) cnt1++;else cnt1=1;
		if((s3[i]=='1'&&s4[i]=='0')||(s3[i]=='0'&&s4[i]=='1')){wr(0);return 0;}
		if(s3[i]=='1'){
			if(s4[i]=='1') continue;
			if(s4[i]=='0'){wr(0);return 0;}
			Link({s4[i]-'a'+1,cnt2},{m+1,1});
		}
		if(s3[i]=='0'){
			if(s4[i]=='0') continue;
			if(s4[i]=='1'){wr(0);return 0;}
			Link({s4[i]-'a'+1,cnt2},{m+1,0});
		}
		if(s4[i]=='1'){
			if(s3[i]=='1') continue;
			if(s3[i]=='0'){wr(0);return 0;}
			Link({s3[i]-'a'+1,cnt1},{m+1,1});			
		}
		if(s4[i]=='0'){
			if(s3[i]=='0') continue;
			if(s3[i]=='1'){wr(0);return 0;}
			Link({s3[i]-'a'+1,cnt1},{m+1,0});
		}	
		if(s3[i]!='0'&&s3[i]!='1'&&s4[i]!='1'&&s4[i]!='0'){
			pii xx=Find({s3[i]-'a'+1,cnt1}),yy=Find({s4[i]-'a'+1,cnt2});
			pii x1={m+1,1},x0={m+1,0};
			if(xx==yy) continue;
			if((xx==x1&&yy==x0)||(xx==x0&&yy==x1)){wr(0);return 0;}
			if(xx==x1||xx==x0) Link({s4[i]-'a'+1,cnt2},xx);
			else if(yy==x1||yy==x0) Link({s3[i]-'a'+1,cnt1},yy);
			else Link(yy,xx);
		}	
	}
	ll ans=0;cnt2=1;cnt1=1;
	fo(1,i,s3.size()-1){
		if(s3[i]==s3[i-1]) cnt1++;else cnt1=1;
		if(s4[i]==s4[i-1]) cnt2++;else cnt2=1;
		if(s4[i]=='1'||s4[i]=='0') continue;
		pii nw={s4[i]-'a'+1,cnt2};pii xx=Find(nw),x1={m+1,1},x0={m+1,0},yy=Find({s3[i]-'a'+1,cnt1});
		if((xx==x1&&yy==x0)||(xx==x0&&yy==x1)){wr(0);return 0;}
		if(xx==x1||xx==x0) continue;
		if(!vis[xx]) ans++,vis[xx]=1;
	}
	answ[1]=1;
	if(Find({m+1,1})==Find({m+1,0})){wr(0);return 0;}
	while(ans) Get(),ans--;
	Fo(lenth,i,1) wr(answ[i]);
	return 0;
}
``````

---

## 作者：hanzhongtlx (赞：0)

题目链接：[P2456 [SDOI2006]二进制方程](https://www.luogu.com.cn/problem/P2456)   

一道不错的并查集题目。   

开始看一头雾水，不过当你对整个式子展开时，就豁然开朗了。  

比如说样例 $2$：  

展开后等式两边就成了这个：  

$1,b_1,b_2,a_1,a_2,a_3,a_4,d_1,d_2,d_3,d_4,1$  

和：  

$a_1,a_2,a_3,a_4,c_1,c_2,c_3,c_4,b_1.b_2,e_1,e_1$   

然后你就可以轻松的找到每一位上的对应关系，比如：  

$$a_2=b_1=c_1=d_2$$    

然后你给每个字母的第 $i$ 位编个号，然后用并查集来维护即可。  

这里要注意是否有同一组字母同时对应着 $0$ 和 $1$ 。  

最后补上高精即可。  

```
#include"iostream"
#include"cstdio"
#include"cmath"
#include"algorithm"
#include"cstring"
using namespace std;

#define read(x) scanf("%d",&x)
#define MAXN 10005
#define ll unsigned long long

int k;
int f[MAXN],vis[MAXN],l[30],be[30];
int a[MAXN],b[MAXN];
char s[MAXN];
int cnt=0,sum=0;
int v[30],c=0;
int ans[100005],li=1;

void init(int n){for(int i=1;i<=n;i++) vis[i]=0,f[i]=i;}

int getf(int u){return f[u]=(f[u]==u)?u:getf(f[u]);}

void merge(int u,int v){int t1=getf(u),t2=getf(v);if(t1!=t2) f[t2]=t1;}

int tran(char c){return c-'a'+1;}

int main()
{
    read(k),be[1]=0;
    for(int i=1;i<=k;i++) read(l[i]),be[i+1]+=be[i]+l[i];
    scanf("%s",s);
    int lens=strlen(s);
    for(int i=0;i<lens;i++)
    {
        if(s[i]=='0') a[++cnt]=-1;
        else if(s[i]=='1') a[++cnt]=0;
        else
        {
            int op=tran(s[i]);
            for(int j=1;j<=l[op];j++) a[++cnt]=be[op]+j;
        }
    }
    int to=cnt;
    cnt=0;
    scanf("%s",s);
    lens=strlen(s);
    for(int i=0;i<lens;i++)
    {
        if(s[i]=='0') b[++cnt]=-1;
        else if(s[i]=='1') b[++cnt]=0;
        else
        {
            int op=tran(s[i]);
            for(int j=1;j<=l[op];j++) b[++cnt]=be[op]+j;
        }
    }
    if(cnt!=to) return puts("0"),0;
    init(be[k]+l[k]);
    for(int i=1;i<=cnt;i++)
    {
        if((a[i]==0&&b[i]==-1)||(a[i]==-1&&b[i]==0)) return puts("0"),0;
        else if((a[i]>=-1&&a[i]<=0)||(b[i]>=-1&&b[i]<=0)) continue;
        merge(a[i],b[i]);
    }
    for(int i=1;i<=cnt;i++)
    {
    	if(a[i]>=-1&&a[i]<=0&&b[i]>=-1&&b[i]<=0) continue;
        if(a[i]==0)
        {
            int now=getf(b[i]);
            if(vis[now]==1) return puts("0"),0;
            vis[now]=2;
        }
        else if(a[i]==-1)
        {
        	int now=getf(b[i]);
            if(vis[now]==2) return puts("0"),0;
            vis[now]=1;
         }
        else if(b[i]==-1)
        {
            int now=getf(a[i]);
            if(vis[now]==2) return puts("0"),0;
            vis[now]=1;
        }
        else if(b[i]==0)
        {
            int now=getf(a[i]);
            if(vis[now]==1) return puts("0"),0;
            vis[now]=2;
        }
    }
    for(int i=1;i<=be[k]+l[k];i++) if(f[i]==i&&!vis[i]) sum++;
	ans[1]=1;
	for(int i=1;i<=sum;i++)
    {
    	for(int j=1;j<=li;j++)
    	{
    		ans[j]*=2;
		}
		for(int j=1;j<=li;j++)
		{
			if(ans[j]>=10) ans[j+1]+=ans[j]/10,ans[j]%=10;
		}
		if(ans[li+1]>0) li++;
		while(ans[li]>=10) ans[li+1]+=ans[li]/10,ans[li]%=10,li++;
	}
	for(int i=li;i>=1;i--) printf("%d",ans[i]);
    cout<<endl;
    return 0;
}
/*
4
5 4 4 1
1adb0
11bdc0
32
*/
```

---

## 作者：homoDXH_ny (赞：0)

#### P1：分析过程
分类讨论：

（1）$ X_i $，$ Y_i $  都是数字，但是不相同，此时无解；

（2）$ X_i $，$ Y_i $   都是数字，相同，唯一填法；

（3）$ X_i $，$ Y_i $  一个是数字，一个是字母，唯一填法；

（4）$ X_i $，$ Y_i $   都是字母，颜色不同，那么一旦在该颜色对应的位置上填了一个数字，对应的另一种颜色，或者是该颜色在其他区域的对应位置也填上了这个数字；

所以我们就把同一种颜色的方块用并查集联系起来。

另外要用**高精度**！

#### P2：some code
```cpp
int find(int x) {
	return fa[x]==x?x:fa[x]=find(fa[x]);
}
void X() {
	c[0]*=2;
	for(int i=1; i<lc; i++) {
		c[i]=c[i]*2+c[i-1]/10;
		c[i-1]%=10;
	}
	while(c[lc-1]>=10) {
		c[lc]=c[lc-1]/10;
		c[lc-1]%=10;
		lc++;
	}
}
int main() {
	k=read();//快读
	num[1]=2;
	for(int i=2,u; i<=k+1; i++) {
		u=read();
		num[i]=num[i-1]+u;
		sum+=u;
	}
	scanf("%s",s);
	int len=strlen(s);
	for(int i=0; i<len; i++) {
		if(s[i]>='a'&&s[i]<='z') {
			int v=s[i]-'a'+1;
			for(int j=num[v]; j<num[v+1]; j++) x[++t1]=j;
		} else x[++t1]=s[i]-'0';
	}
	scanf("%s",s);
	len=strlen(s);
	for(int i=0; i<len; i++) {
		if(s[i]>='a'&&s[i]<='z') {
			int v=s[i]-'a'+1;
			for(int j=num[v]; j<num[v+1]; j++) y[++t2]=j;
		} else y[++t2]=s[i]-'0';
	}
	if(t1!=t2) {
		//自己想
	}
	for(int i=0; i<=num[k+1]; i++) fa[i]=i;

	for(int i=1; i<=t1; i++) {
		int f1=find(x[i]),f2=find(y[i]);
		if(f1+f2==1) {
			//自己想
		}
		if(f1!=f2) {
			fa[max(f1,f2)]=min(f1,f2);
			sum--;
		}
	}
	c[0]=1;
	lc=1;
	for(int i=sum; i>=1; i--)
		X();
	//输出自己想
}

```

---


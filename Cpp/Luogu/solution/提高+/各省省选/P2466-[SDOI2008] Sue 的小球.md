# [SDOI2008] Sue 的小球

## 题目描述

Sue 和 Sandy 最近迷上了一个电脑游戏，这个游戏的故事发在美丽神秘并且充满刺激的大海上，Sue 有一支轻便小巧的小船。然而，Sue 的目标并不是当一个海盗，而是要收集空中漂浮的彩蛋，Sue 有一个秘密武器，只要她将小船划到一个彩蛋的正下方，然后使用秘密武器便可以在瞬间收集到这个彩蛋。然而，彩蛋有一个魅力值，这个魅力值会随着彩蛋在空中降落的时间而降低，Sue 要想得到更多的分数，必须尽量在魅力值高的时候收集这个彩蛋，而如果一个彩蛋掉入海中，它的魅力值将会变成一个负数，但这并不影响 Sue 的兴趣，因为每一个彩蛋都是不同的，Sue 希望收集到所有的彩蛋。

然而 Sandy 就没有 Sue 那么浪漫了，Sandy 希望得到尽可能多的分数，为了解决这个问题，他先将这个游戏抽象成了如下模型：

将大海近似的看做 $x$ 轴建立一个竖直的平面直角坐标系，Sue 所在的初始位置在 $x$ 轴上。

一开始空中有 $N$ 个彩蛋，对于第 $i$ 个彩蛋，他的初始位置用整数坐标 $(x_{i}, y_{i})$ 表示，游戏开始后，它匀速沿 $y$ 轴负方向下落,速度为 $v_{i}$ 单位距离/单位时间。Sue 的初始位置为 $(x_{0}, 0)$，Sue 可以沿 $x$ 轴的正方向或负方向移动，Sue 的移动速度是 $1$ 单位距离/单位时间，使用秘密武器得到一个彩蛋是瞬间的，得分为当前彩蛋的 $y$ 坐标的千分之一。

现在，Sue 和 Sandy 请你来帮忙，为了满足 Sue 和 Sandy 各自的目标，你决定在收集到所有彩蛋的基础上，得到的分数最高。

## 说明/提示

对于 $30\%$ 的数据， $N\leq 20$。

对于 $60\%$ 的数据， $N\leq 100$。

对于 $100\%$ 的数据，$-10^4 \leq x_{i},y_{i},v_{i} \leq 10^4$，$N \leq 1000$

## 样例 #1

### 输入

```
3 0
-4 -2 2
22 30 26
1 9 8
```

### 输出

```
0.000```

# 题解

## 作者：Bartholomew (赞：71)

##对一类动态规划问题的研究
###(摘自)湖南省长沙市第一中学 徐源盛 论文  By Bartholomew
当前决策对未来“行动”的费用影响只与当前决策有关
**好久没有写博客了,最近准备攻一波集训队论文(慌**


>**引自论文:**
>在常规动态规划问题中，我们面临当前状态时“行动”造成的花费往往与这个
状 态 是 同 时 计 算 的 。 例 如 在 经 典 的 石 子 合 并 问 题 中 ， 规 划 方 程 为
$$f[i][j]=max{f[i][k]+f[k+1][j]}+w(i,j)$$当我们计算 $f[i][j]$时，才会把将 i 到 j 的石子全部
合并到一起这一“行动”的费用加进去。这很符合我们的思维习惯。
然而近年来频繁出现一类动态规划问题，在这类问题中，当前“行动”的费用
的一部分需要在之前决策时被计算并以状态的形式对当前状态造成影响。造成这
一独特的计算的原因就是当前的决策会对未来的“行动”费用造成影响。这类问题
构造方程往往比较困难，需要仔细分析原题，找到矛盾所在。

那么简单来说就是**现在的决策内容会对之后的计算价值产生影响**

那么我们怎么办:简单,如果这个影响是我们能够求的,那么我们就**当前计算**就好了!

##题解
$1.$
先把所有的点包括起点按 $x$ 值排序，这样题目就变成从起点出发，每次可以
向左或向右走到最近的某个彩蛋，将其射落，设每个彩蛋第一次走到的时刻为 $t_i$，
答案就是 $$∑(y_i-t_i*v_i)max$$

$2.$
很容易想到用 $f[1][i][j]$、$f[2][i][j]$分别表示从起点出发已射落 i 到 j 这一段彩蛋，当前停留在 i 点、j 点的最大得分.
考虑 $f[1][i][j]$,即点 i 是当前射击的彩蛋，射击的得分与当前时刻挂钩，但
是当前的时刻是不能从 $f[1][i][j]$的状态中表示出来的。
我们发现上述方法的矛盾其实就在于**曾经的行走花费的时间会对当前的得分产生影响**，
我们可以进一步考虑 $f[1][i][j]$的求解，由于射击 i 的得分是 $yi-t*vi$，而 t
等于之前**每一步决策移动的时间总和**，这样我们就可以把$t*v_i$在之前的移动中就计算，也就是说每次移动都要把**未来会减少的得分计算在内**。
比如说从 $f[1][i][j]$推到 $f[1][i-1][j]$，即从 i 走到 i-1 时除了 i 到 j 这一段彩蛋
外，其它的彩蛋都在下落，将这丢失的分数一并计算到从 i 走到 i-1 中。由于-t*vi
已经在之前决策时计算，所以射击时加上 yi 即可。

用 $$w[i][j]=\sum_{i=0}^n v_i - \sum_{k=i}^jv_k$$

即除了 i 到 j 这一段的彩蛋外的
所有彩蛋下落速度和，那么很容易得到方程：

$$f1[i][j]=y[i]+max(f1[i+1][j]-(xi+1-xi)*w[i+1][j],f2[i+1][j]-(xj-xi)*w[i+1][j])$$
$$f2[i][j]=y[j]+max(f2[i][j-1]-(xj-xj-1)*w[i][j-1],f1[i][j-1]-(xj-xi)*w[i][j-1])$$
答案就是$$\frac{max(f1[1][n],f2[1][n])}{1000}$$
算法的时间复杂度为 $O(n^2)$。至此问
题已得到完全解决。

所以我们应该记住：对于当前决策影响未来的问题->就是现在算将来的影响再进行DP


```cpp
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#pragma GCC optimize("inline")
#include <cstdio>
#include <cmath>
#include <cstring>
#include <iostream>
#include <algorithm>
#define N 1005
#define INF 0x3f3f3f3f
using namespace std;

int n, leftn, rightn;
double m, f[2][N][N], w[N][N], sum[N], getn;

struct node
{
    double x, y, v;
} a[N];

inline bool cmp(node A, node B)
{
    return A.x < B.x;
}

int main(int argc, char const *argv[])
{
    scanf("%d%lf", &n, &m);
    a[1] = node{m, 0.0, 0.0};
    for(int i = 2; i <= n + 1; i++)
        scanf("%lf", &a[i].x);
    for(int i = 2; i <= n + 1; i++)
        scanf("%lf", &a[i].y);
    for(int i = 2; i <= n + 1; i++)
        scanf("%lf", &a[i].v), getn += a[i].v;
    sort(a + 1, a + 2 + n, cmp);
    for(int i = 1; i <= n + 1; i++)
    {
        sum[i] = sum[i - 1] + a[i].v;
        if(fabs(a[i].x - m) <= 1e-15 && fabs(a[i].y - 0.0) <= 1e-15)
        {
            leftn = rightn = i;
        }
    }
    memset(f, -INF, sizeof f);
    f[0][leftn][leftn] = f[1][rightn][rightn] = 0.00;
    for(register int k = 1; k <= n + 1; ++k)
    {
        for(register int i = 1; i + k <= n + 1; ++i)
        {
            int j = i + k;
            f[0][i][j] = a[i].y + max(f[0][i + 1][j] - (a[i + 1].x - a[i].x) * (sum[n + 1] + sum[i] - sum[j]),
                                      f[1][i + 1][j] - (a[j].x - a[i].x) * (sum[n + 1] + sum[i] - sum[j]));
            f[1][i][j] = a[j].y + max(f[1][i][j - 1] - (a[j].x - a[j - 1].x) * (sum[n + 1] + sum[i - 1] - sum[j - 1]) ,
                                      f[0][i][j - 1] - (a[j].x - a[i].x) * (sum[n + 1] + sum[i - 1] - sum[j - 1]));
        }
    }
    printf("%.3lf\n", max(f[1][1][n + 1], f[0][1][n + 1]) / 1000.0);
    return 0;
}

```



---

## 作者：学哥 (赞：31)

说实话 这题我是看了各位大佬题解并询问班上大佬同学

写出来的。

这题要用区间动规，也就是用f[i][j] 表示一段区间的状态 然后进行状态转移。

首先思考 ***下标 i、j是表示横坐标吗？***

显然，如果维护横坐标，那么数组开不下。

那么，就只能维护第几个小球。即先把小求按横坐标排序，再标上序号（相当于离散化）

然后思考 **维护什么，怎么转移**

1. 如果维护这段区间得分，那么，显然，当你要区间合并时，你无法合并，因为这段区间的得分在随着时间变化，你不会知道当你合并时，它还剩多少得分
1. 那么如果维护这段区间走过时，它旁边的小球失去了多少分呢？我们这样想 :合并时,用小区间合并小区间，即多个不重叠的 并且连续的 小区间 合并成一个大区间;小区间维护, 走完这段区间后, 它旁边的小球失去了多少分 那么, 这样, 在合并时, 则不受别的区间干扰;


现在，解决了，dp维护什么 的问题;

****接着，让我们模拟走的过程（就是dp方程）。****

如果我们要走i到j这段连续的小球（注意 i、j不是起点与终点，是范围），我们有许多走法，但总结起来，就是由两种走法组成

1. 从i走到j（反向同理）
1. 从i走到j，并且从j回到i（反向同理）

所有的走法，均由这两种重复形成。

***如果考虑更细，我们发现***

1. 从i走一步，到j;
1. 从i返回，到之前的一点

***构成了所有走法***

dp思路隐约出来了

dp[i][j],会有两种意思：

1. 从i到j这一段的蛋全捡了，而且，我在i
处
1. 从i到j这一段的蛋全捡了，而且，我在j
处

为了避免歧义，用两个方程，解释。


f[i][j] ：走完i到j，在i处

g[i][j] ：走完i到j，在j处

**怎么转移**

  试想:f[i][j]怎么来的？
  你可能会说:i到j的走法那么多，得到的方法太多了。回想刚刚说的，就两种
  1. 上一步为f[i-1][j],
  往左边走一步，得到f[i][j]。
  2. 
     上一步为g[i-1][j],往左跨过这段区间，走到i
  得到f[i][j];
  
  
  同理，g[i][j];
  
  **转移代码f[i][j]**
  
 `````
 f[i][j]=min(f[i][j],f[i+1][j]+(js(1,i)+js(j+1,n))*(ball[i+1].x-ball[i].x));
 f[i][j]=min(f[i][j],g[i+1][j]+(js(1,i)+js(j+1,n))*(ball[j].x-ball[i].x));
 
 `````
  **转移代码g[i][j]**
  
  ````
  g[i][j]=min(g[i][j],g[i][j-1]+(js(1,i-1)+js(j,n))*(ball[j].x-ball[j-1].x));
  g[i][j]=min(g[i][j],f[i][j-1]+(js(1,i-1)+js(j,n))*(ball[j].x-ball[i].x));
  ````
  
  代码中js(a,b) 函数指a到b这一段小球的下落速度之和（事先用前缀和维护）
  乘上移动距离的位置差（就是时间差）,得到f[i][j]这一段丧失的得分
  
  ******

__***最后，附上代码*** __ 

******
```````
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdlib>
#define MAXN 1005
#define rg register
using namespace std;
struct zjy{
    int x,y,v;
}ball[MAXN];
int f[MAXN][MAXN],g[MAXN][MAXN],tot;
int x0,n,pre[MAXN];
bool cmp(zjy x,zjy y){return x.x<y.x;}
int js(int l,int r){return pre[r]-pre[l-1];}
int main(){
    memset(f,0x3f,sizeof(f));
    memset(g,0x3f,sizeof(g));
    ios::sync_with_stdio(false);
    cin>>n>>x0;
    for(rg int i=1;i<=n;++i)cin>>ball[i].x;
    for(rg int i=1;i<=n;++i)cin>>ball[i].y,tot+=ball[i].y;
    for(rg int i=1;i<=n;++i)cin>>ball[i].v;
    ball[++n].x=x0;
    sort(ball+1,ball+n+1,cmp);
    for(rg int i=1;i<=n;++i)pre[i]=pre[i-1]+ball[i].v;
    for(rg int i=1;i<=n;++i)if(ball[i].v==0&&ball[i].x==x0)f[i][i]=0,g[i][i]=0;
    for(rg int k=1;k<n;++k)for(rg int i=1,j=i+k;i<=n&&j<=n;++i,j=i+k){
        f[i][j]=min(f[i][j],f[i+1][j]+(js(1,i)+js(j+1,n))*(ball[i+1].x-ball[i].x));
        f[i][j]=min(f[i][j],g[i+1][j]+(js(1,i)+js(j+1,n))*(ball[j].x-ball[i].x));
        g[i][j]=min(g[i][j],g[i][j-1]+(js(1,i-1)+js(j,n))*(ball[j].x-ball[j-1].x));
        g[i][j]=min(g[i][j],f[i][j-1]+(js(1,i-1)+js(j,n))*(ball[j].x-ball[i].x));
    }
    printf("%.3lf",(tot-min(f[1][n],g[1][n]))/1000.0);
}
```````
  

---

## 作者：Ofnoname (赞：22)

提高试炼场有一道[P1220 关路灯](https://www.luogu.org/problemnew/show/P1220)和这个几乎一模一样，今天考了这道题，我才发现就是原题。

显然我们应该直接把初始y值加起来，然后减去最小的损耗以使答案最大，`y`累加以后就没有用了，记得把点从左往右排序。我们让`f0[L][R]`表示从`R`直接走到`L`的最小损耗值，用`f1[L][R]`表示从`L`和`R`中间一个点先走到`R`再掉头回来的最小损耗值（肯定不会掉两次头，亏）。

小区间可以推出大区间，所以要先枚举区间长度再枚举区间起点，如果是从`f0[L+1][R]`走到`f0[L][R]`（即从R直接到L+1，然后再往左一格），那么损耗就该是`L+1`到`L`的距离乘以$[L,R]$以外所有点的损耗值。同理是从`f1[L+1][R]`走到`f0[L][R]`（即中间一点走到R，然后再往左到L），那么损耗就该是`R`到`L`的距离乘以$[L,R]$以外所有点的损耗值。

推出`f1[L][R]`的方法类似。而两点的距离可以直接计算，$[L,R]$以外所有点的损耗值可以用前缀和推得，这样就是$O(N^2)$。

边界：初始点不一定有球，我们可以在初始点设置一个损耗为0的球，与其他球一起排序，然后初始点编号为i的话就让`f0[i][i] = f1[i][i] = 0`即可（表示第一步没有损耗），其余值随意，最好设为`inf`，最后`min(f0[1][N], f1[1][N])`就是最小损耗，记得除以1000.

```cpp
#include <bits/stdc++.h>
#define MAX (1000 + 7)
using namespace std;

struct Node{
	int x, y, v;
	int operator <(Node b) const {
		return x < b.x;
	}
} a[MAX];

int N, x0, ans, f0[MAX][MAX], f1[MAX][MAX];

int main()
{
	scanf("%d%d", &N, &x0), a[N+1].x = x0;//在初始点新建小球 
	memset(f0, 0x3f, sizeof f0);
	memset(f1, 0x3f, sizeof f1);
	for (int i = 1; i <= N; i++)
		scanf("%d", &a[i].x);
	for (int i = 1; i <= N; i++)
		scanf("%d", &a[i].y), ans += a[i].y;//计算初始答案 
	for (int i = 1; i <= N; i++)
		scanf("%d", &a[i].v);
	N++;
	sort(a + 1, a + N + 1);
	for (int i = 1; i <= N; i++)
		if (a[i].x == x0)
		{
			f0[i][i] = f1[i][i] = 0;//寻找初始点 
			break;
		}
	for (int i = 1; i <= N; i++)
		a[i].v += a[i-1].v;//求前缀和 
	for (int i = 1; i <= N; i++)
	for (int L = 1, R = L + i; R <= N; L++, R++)
	{//区间DP 
		f0[L][R] = min(f0[L+1][R] + (a[L+1].x-a[L].x) * (a[L].v+a[N].v-a[R].v),
					   f1[L+1][R] + (a[R].x - a[L].x) * (a[L].v+a[N].v-a[R].v));
		f1[L][R] = min(f0[L][R-1] + (a[R].x - a[L].x) * (a[L-1].v+a[N].v-a[R-1].v),
					   f1[L][R-1] + (a[R].x-a[R-1].x) * (a[L-1].v+a[N].v-a[R-1].v));
	} printf("%.3lf\n", (ans - min(f0[1][N], f1[1][N])) / 1000.0);
}

```

---

## 作者：是个汉子 (赞：19)

[洛谷传送门](https://www.luogu.com.cn/problem/P2466)

这个题真的和[关路灯](https://www.luogu.com.cn/problem/P1220)很像，可以去看看。

### Solution

有很多题解都没提到怎么看出来的区间DP，这里说一下。(有人做了一些题，就有思路，说不定有没做啥题的)

首先可以明确的是， Sue 不可能经过一个彩蛋不收集，也就是收集的彩蛋的编号应该是连续的。因为路过不收，~~这不zz？~~不就是看着彩蛋价值变低吗

再思考， Sue 肯定在某个连续的区间**中**收集的~~是显然的~~，在外面和上面是冲突的。再具体，因为要外扩展答案的，所以 Sue 是在区间左端或者右端的。

那么对于一个区间 $(l,r)$ ，我们得到了最优解，再往外转移必定是最优的，然后就能将求区间最优转化为子问题递归求解。

现在思考不要 Sue 的位置，只保留左右端点的值。发现是不行的，因为 Sue 的位置不同对下一步转移的代价也是不同的。

那么一个一个彩蛋收集，此时 Sue 就有 4 种情况：

1.对于 $l-1$ 这个彩蛋， Sue 可以从 $l$ 或 $r$ 过去收集。

2.对于 $r+1$ 这个彩蛋， Sue 可以从 $l$ 或 $r$ 过去收集。

其实这就可以作为转移方程了。

设 $f_{l,r,0/1}$ 表示收集完这个区间， Sue 在左/右端点的**最小损耗值**，可得：
$$
f_{l,r,0}=\min\{f_{l+1,r,0}+(pos_{l+1}-pos_l)\times (sum_{1,l}+sum_{r+1,n}),f_{l,r,0}\}\\
f_{l,r,0}=\min\{f_{l+1,r,1}+(pos_{r}-pos_l)\times (sum_{1,l}+sum_{r+1,n}),f_{l,r,0}\}\\
f_{l,r,1}=\min\{f_{l,r-1,0}+(pos_{r}-pos_l)\times (sum_{1,l-1}+sum_{r,n}),f_{l,r,0}\}\\
f_{l,r,1}=\min\{f_{l,r-1,1}+(pos_{r}-pos_{r-1})\times (sum_{1,l-1}+sum_{r,n}),f_{l,r,0}\}
$$
其中  $sum_i$ 为前 $i$ 个数的 $v$ 和，是为了求区间的代价，需要预处理。

注意：千分之一在答案的时候处理即可。因为求的是损耗，所以答案要加上所有初始的 $y$ ，最后减去 $\min(f_{1,n,0},f_{1,n,1})$ 。

### Code

```c++
#include<bits/stdc++.h>

using namespace std;
const int N=1010;
struct node{
    int x,y,v;
    bool operator < (node b) const {
        return x<b.x;
    } 
}a[N];
int n,x0,ans,f[N][N][2];

int main(){
    scanf("%d%d",&n,&x0),a[n+1].x=x0;
    memset(f,0x3f,sizeof(f));
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i].x);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i].y),ans+=a[i].y;
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i].v);
    n++;
    sort(a+1,a+n+1);
    for(int i=1;i<=n;i++)
        if(a[i].x==x0){
            f[i][i][0]=f[i][i][1]=0;
            break;
        }
    for(int i=1;i<=n;i++)
        a[i].v+=a[i-1].v;
    for(int i=1;i<=n;i++)
        for(int l=1,r=l+i;r<=n;l++,r++){
            f[l][r][0]=min(f[l+1][r][0]+(a[l+1].x-a[l].x)*(a[l].v+a[n].v-a[r].v),
                            f[l+1][r][1]+(a[r].x-a[l].x)*(a[l].v+a[n].v-a[r].v));
            f[l][r][1]=min(f[l][r-1][0]+(a[r].x-a[l].x)*(a[l-1].v+a[n].v-a[r-1].v),
                            f[l][r-1][1]+(a[r].x-a[r-1].x)*(a[l-1].v+a[n].v-a[r-1].v));
        }
    printf("%.3lf\n",(ans-min(f[1][n][0],f[1][n][1]))/1000.0);
    return 0;
}
```



---

## 作者：QwQcOrZ (赞：8)

首先有个很 naïve 的想法是设 $dp_{l,r,0/1}$ 表示收集了 $l$ 到 $r$ 这段区间中的所有彩蛋后，最后到了区间左端点/区间右端点获得的最高分数（千分之一不管它，最后乘上去即可）

于是就能得到这么一个转移方程：

$dp_{l,r,0}=max(dp_{l+1,r,0}-(y_l-(time_{l+1,r,0}+x_{l+1}-x_l)),dp_{l+1,r,1}-(y_l-(time_{l+1,r,1}+x_r-x_l)))$

$dp_{l,r,1}=max(dp_{l,r-1,1}-(y_r-(time_{l,r-1,1}+x_r-x_{r-1})),dp_{l,r-1,0}-(y_r-(time_{l,r-1,0}+x_r-x_l)))$

然后我们会发现显然没法转移，因为要知道当前彩蛋的分值还需要知道已经花的时间

然而显然不能在保证 $dp$ 最优的同时保证 $time$ 最优

那么考虑改变一下 $dp_{l,r}$ 表示的意义：设 $dp_{l,r}$ 表示收集了 $l$ 到 $r$ 这段区间中的所有彩蛋后，最后到了区间左端点/区间右端点获得的最高贡献

此处贡献的含义是：当前 $[l,r]$ 这段区间内获得的分数减掉此段区间操作后会对全局产生的影响

也就是贡献$=$分数$-$所有彩蛋在当前时刻内且未被收集时下降的高度和

为什么这样是对的？因为我们发现我们把本应该再用一个状态表示的「时间」压到了「贡献」这个状态里；把一段区间局部的影响转化到了一段区间对全局的影响

此时我们会发现转移时就不需要知道之前所花的时间了，只需要知道转移这一步移动所要花的时间即可

你可以理解为在计算当前彩蛋分值之前已经把会减少的分数在答案中减掉了

理解了这个状态之后转移方程就很好推了：

$dp_{l,r,0}=max(dp_{l+1,r,0}-(x_{l+1}-x_l)\times(Lsum_l+Rsum_{r+1}),dp_{l+1,r,1}-(x_r-x_l)\times(Lsum_l+Rsum_{r+1}))+y_l$

$dp_{l,r,1}=max(dp_{l,r-1,1}-(x_r-x_{r-1})\times(Lsum_{l-1}+Rsum_r),dp_{l,r-1,0}-(x_r-x_l)\times(Lsum_{l-1}+Rsum_r))+y_r$

其中 $Lsum_i,Rsum_i$ 分别表示 $y_i$ 的前缀和与后缀和

然后处理一下细节就好辣

$Code\ Below$

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e3+5;
const int inf=LONG_LONG_MAX/2;

inline int read()
{
	register int s=0;
	register char c=getchar(),lc='+';
	while (c<'0'||'9'<c) lc=c,c=getchar();
	while ('0'<=c&&c<='9') s=s*10+c-'0',c=getchar();
	return lc=='-'?-s:s;
}
void write(register int x)
{
	if (x<0)
	{
		putchar('-');
		x=-x;
	}
	if (x<10) putchar(x+'0');
	else
	{
		write(x/10);
		putchar(x%10+'0');
	}
}
inline void print(const register int x,const register char c='\n')
{
	write(x);
	putchar(c);
}
struct node
{
	int x,y,v;
	bool operator <(const node &a)const
	{
		return x<a.x;
	}
}a[N];
int dp[N][N][2],L[N],R[N];

signed main()
{
	int n=read(),x=read();
	for (int i=1;i<=n;i++) a[i].x=read();
	for (int i=1;i<=n;i++) a[i].y=read();
	for (int i=1;i<=n;i++) a[i].v=read();
	a[++n].x=x;
	a[n].y=a[n].v=0;
	sort(a+1,a+1+n);
	for (int i=0;i<=n+1;i++)
	for (int j=0;j<=n+1;j++) dp[i][j][0]=dp[i][j][1]=-inf;
	for (int i=1;i<=n;i++)
	if (a[i].x==x) dp[i][i][0]=dp[i][i][1]=a[i].y;
	L[0]=R[n+1]=0;
	for (int i=1;i<=n;i++) L[i]=L[i-1]+a[i].v;
	for (int i=n;i>=1;i--) R[i]=R[i+1]+a[i].v;
	for (int i=2;i<=n;i++)
	for (int j=1;i+j-1<=n;j++)
	{
		int l=j,r=i+j-1;
		dp[l][r][0]=max(dp[l+1][r][0]-(a[l+1].x-a[l].x)*(L[l]+R[r+1]),dp[l+1][r][1]-(a[r].x-a[l].x)*(L[l]+R[r+1]))+a[l].y;
		dp[l][r][1]=max(dp[l][r-1][1]-(a[r].x-a[r-1].x)*(L[l-1]+R[r]),dp[l][r-1][0]-(a[r].x-a[l].x)*(L[l-1]+R[r]))+a[r].y;
	}
	printf("%.3lf",max(dp[1][n][0],dp[1][n][1])/1000.0);

	return 0;
}
```

---

## 作者：FjswYuzu (赞：7)

考虑先将彩蛋按 $x$ 排序。现在我们从起点出发，此时 $n$ 个彩蛋会以一定速度往下坠。射下一个彩蛋的分数是这个彩蛋被射下时的高度，自己的速度为 $1$，射击时间不计。问能够得到的最大分数。

首先，很显然的，因为射击不需要时间，所以说最优方案一定不会出现类似于 $l \to r \to x(l < x< r)$ 的射击顺序。所以说在最优状态下，我们不会跳过没有被射下来的彩蛋去得到下一个彩蛋的分数，并且可以证明在最优状态的结束，我们一定停留在 $1$ 或者 $n$。

于是考虑定义 $dp_{l,r,0 \operatorname{or} 1}$ 为当前已得到了 $[l,r]$ 彩蛋的分数，如果第三个数为 $0$，则我们停留在 $l$，否则停留在 $r$……呃，等等。我们是有时间的，如果将时间这一维加进去，时间不就显然爆炸了吗？

分析一下上面的状态，可以发现我们可以确定已经被收集掉了的彩蛋有哪些。而我们在拓展收集另外一个彩蛋的时候确确实实可以知道哪些彩蛋没有被收集。那么我们能不能将还没有收集的彩蛋下降的分数先加入我们的状态定义呢？

这样是可行的。因为我们能够发现彩蛋下降只会跟当前的时间有关系，所以可以将未来彩蛋下降的负贡献先加入到状态中，这样是没有问题的。

然后再想想怎么转移。对于一个区间 $[l,r]$ 的状态，能够转移到这个区间的区间有 $[l+1,r]$ 和 $[l,r-1]$。分类讨论取最大值即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
struct Egg{
	LL x,y,v;
	Egg(){x=y=v=0;}
	Egg(LL X,LL Y,LL V){x=X,y=Y,v=V;}
	bool operator < (Egg ano) const {return x<ano.x;}
}egg[1005];
LL Abs(LL x){return x<0?-x:x;}
LL dp[1005][1005][2],sum[1005][1005],n,firx,totv;
int main(){
	memset(dp,128,sizeof dp);
	scanf("%lld %lld",&n,&firx);
	for(LL i=1;i<=n;++i)	scanf("%lld",&egg[i].x);
	for(LL i=1;i<=n;++i)	scanf("%lld",&egg[i].y);
	for(LL i=1;i<=n;++i)	scanf("%lld",&egg[i].v),totv+=egg[i].v;
	sort(egg+1,egg+1+n);
	for(LL i=1;i<=n;++i)	for(LL j=i;j<=n;++j)	sum[i][j]=sum[i][j-1]+egg[j].v;
	for(LL i=1;i<=n;++i)	dp[i][i][0]=dp[i][i][1]=egg[i].y-Abs(firx-egg[i].x)*totv;
	for(LL dis=2;dis<=n;++dis)
	{
		for(LL l=1,r=dis;r<=n;++l,++r)
		{
			dp[l][r][0]=max(dp[l+1][r][0]-(totv-sum[l+1][r])*(egg[l+1].x-egg[l].x),dp[l+1][r][1]-(totv-sum[l+1][r])*(egg[r].x-egg[l].x))+egg[l].y;
			dp[l][r][1]=max(dp[l][r-1][0]-(totv-sum[l][r-1])*(egg[r].x-egg[l].x),dp[l][r-1][1]-(totv-sum[l][r-1])*(egg[r].x-egg[r-1].x))+egg[r].y;
		}
	}
	printf("%.3f",double(max(dp[1][n][0],dp[1][n][1]))/1000.0);
	return 0;
}
```

---

## 作者：封禁用户 (赞：6)

# 蓝名蒟蒻的题解
我是一个蒟蒻，那么接下来献丑了。
(管理dalao说我图丑.....)
(确实挺丑的，所以我就换了几张稍微好点的)

------------

这道题跟关路灯那道题目基本上是一样的，就是一道普普通通的区间DP
(https://www.luogu.com.cn/problem/P1220)

首先根据区间dp所具有的特性，我们设f[i][j]表示把[i,j]（i,j均指该小球的数组下标）这个区间中所有的球都收集到的时候所要损失的魅力值。

从下图中可以看到，Sue所在的位置可能有两种，在这个区间的左端点或者是右端点，所以我们自然而然的也就要在f数组后加上一维，f[i][j][0]表示sue在区间左端点（也就是i处）时收集完[i,j]中所有球时要损失掉的魅力值。f[i][j][1]也就是在右端点（也就是j处）所要损失掉的魅力值。
![](https://cdn.luogu.com.cn/upload/image_hosting/yrupola4.png)
## 预处理
根据Sue初次所在的位置，我们可以求出只收集到一个球时所损失的魅力值，
也就是f[i][i][0],f[i][i][1]的值

代码如下
```cpp
	for(int i=1;i<=n;i++)
	{
		f[i][i][0]=f[i][i][1]=abs(c-d[i].x)*tot;
	}
```
d[i].x是数组下标为i的小球的横坐标，c是Sue所在的最初的位置，abs（c-d[i].x）也就是Sue移动的这个点的时间。
## 状态转移
#### 情况1

![](https://cdn.luogu.com.cn/upload/image_hosting/met878h2.png)
蓝色箭头表示Sue目前所在的位置，绿色箭头表示Sue要到达的位置
所以我们可以得到第一个状态转移方程
```cpp
	f[i][j][1]=min(f[i][j][1],f[i][j-1][1]+(d[j].x-d[j-1].x)*(tot-(qzh[j-1]-qzh[i-1])));
```

tot代表所有球都下坠时的所损失的魅力值速度，

qzh[j-1]-qzh[i-1]代表i到j-1这个闭区间的球下坠的速度，也就是魅力值损失的速度。

这样就能得出Sue在移动时剩余的球所损失的魅力值。


d[j].x代表绿色箭头的坐标，d[j-1].x代表蓝色箭头的坐标，相减也就是Sue所要移动的距离，又因为Sue的速度为1m/s，所以这也就是Sue移动所要消耗的时间。剩下的应该也就好理解了吧。
### 情况2

![](https://cdn.luogu.com.cn/upload/image_hosting/sh1i8tkc.png)
这次绿色箭头指的是Sue当前所在的位置，棕色是Sue要到达的位置
```cpp
f[i][j][0]=min(f[i][j][0],f[i+1][j][1]+(d[j].x-d[i].x)*(tot-(qzh[j]-qzh[i])));
```

棕色箭头指的是Sue所要到达的位置，
不难看出又一个状态转移方程。
（后面的tot，qzh解释同上）
### 情况3

![](https://cdn.luogu.com.cn/upload/image_hosting/e1k5qvp6.png)
```cpp
	f[i][j][0]=min(f[i][j][0],f[i+1][j][0]+(d[i+1].x-d[i].x)*(tot-(qzh[j]-qzh[i])));
```
### 情况4

![](https://cdn.luogu.com.cn/upload/image_hosting/3krqchbn.png)

```cpp
f[i][j][1]=min(f[i][j][1],f[i][j-1][0]+(d[j].x-d[i].x)*(tot-(qzh[j-1]-qzh[i-1])));
```
我相信各位奆佬就不需要我这个大蒟蒻解释情况3和情况4了。

最后一些细节问题（但也不容忽视）
代码中见
```cpp
#include<bits/stdc++.h>
using namespace std;
int f[1005][1005][3];
int qzh[100005],tot;
struct asd{
	int x,y,speed;
}d[100005];
inline int read()
{
   int s=0,w=1;
   char ch;
   ch=getchar();
   while(ch>'9'||ch<'0')
   {
	  if(ch=='-')
	 {
	   w=-1;
	 }
	   ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
	  s=(s<<1)+(s<<3)+(ch^48);
	  ch=getchar();}
	  return s*w;
}
inline bool cmp(asd a,asd b)
{
	return a.x<b.x;
}
int main()
{
	double ans;
	memset(f,8,sizeof(f));
	int n,c;
	n=read();
	c=read();
	for(int i=1;i<=n;i++)
	{
		d[i].x=read();	
	}
	for(int i=1;i<=n;i++)
	{
		d[i].y=read();
	}
	for(int i=1;i<=n;i++)
	{
		d[i].speed=read();	
		ans+=d[i].y/1000.0;//处理出所有小球在未下坠时初始拥有的魅力值 
	}
	sort(d+1,d+1+n,cmp);//排序，按照从x轴上位置从左到右排序 
	for(int i=1;i<=n;i++)
	{
		tot+=d[i].speed;//所有小球共同下坠时损失魅力值的速度 
		qzh[i]=qzh[i-1]+d[i].speed;//前缀和处理区间小球损失魅力值速度 
	}
	for(int i=1;i<=n;i++)
	{
		f[i][i][0]=f[i][i][1]=abs(c-d[i].x)*tot;//根据Sue初始位置预处理边界 
	}
	for(int len=1;len<n;len++)
	{
		for(int i=1;i+len<=n;i++)
		{
			int j=i+len;
			f[i][j][0]=min(f[i][j][0],f[i+1][j][0]+(d[i+1].x-d[i].x)*(tot-(qzh[j]-qzh[i])));
			f[i][j][0]=min(f[i][j][0],f[i+1][j][1]+(d[j].x-d[i].x)*(tot-(qzh[j]-qzh[i])));
			f[i][j][1]=min(f[i][j][1],f[i][j-1][0]+(d[j].x-d[i].x)*(tot-(qzh[j-1]-qzh[i-1])));
			f[i][j][1]=min(f[i][j][1],f[i][j-1][1]+(d[j].x-d[j-1].x)*(tot-(qzh[j-1]-qzh[i-1])));
		}
	}
	double minn=min(f[1][n][0],f[1][n][1]);//得到把所有小球都收集到时所损失的最小魅力值 
	ans-=minn/1000.0;//注意最后要的答案是最高的分数 
	printf("%.3lf",ans);
	return 0;

}



```
如果本蒟蒻的代码/题解有问题 ，恳请各位大佬指出来，~~你们可不能自私，我们要互帮互助，共同提高/xyx~~



---

## 作者：JRhdj (赞：6)

可以用区间dp解决

用f[i][j]表示取从i到j的彩蛋并且停留在i所失去的最小价值

用g[i][j]表示取从i到j的彩蛋并且停留在j所失去的最小价值

那么最后的答案就是 总价值 - min(f[1][n], g[1][n])

这样子的话转移就很简单了 细节看代码

```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
using namespace std;
const int M = 1005;
int f[M][M], g[M][M], n, x0, pre[M], tc;
struct point
{
    int x, y, v;
}w[M];
bool cmp(point a, point b)
{
    return a.x < b.x;
}
int q(int l, int r)
{
    return pre[r] - pre[l-1];
}
int main()
{
    memset(f, 0x3f, sizeof f); memset(g, 0x3f, sizeof g);
    scanf("%d%d", &n, &x0);
    for(int i=1; i<=n; ++i) scanf("%d", &w[i].x);
    for(int i=1; i<=n; ++i) scanf("%d", &w[i].y), tc+=w[i].y;
    for(int i=1; i<=n; ++i) scanf("%d", &w[i].v);
    w[++n] = (point){x0, 0, 0};
    sort(w+1, w+n+1, cmp);
    for(int i=1; i<=n; ++i) pre[i] = pre[i-1] + w[i].v;
    for(int i=1; i<=n; ++i) if(w[i].x == x0 && w[i].v == 0) f[i][i]=0, g[i][i]=0;
    for(int k=1; k<n; ++k) for(int i=1; i<=n; ++i)
    {
        int j = i+k;
        if(j>n) break;
        f[i][j] = min(f[i][j], f[i+1][j]+(w[i+1].x-w[i].x)*(q(1, i)+q(j+1, n)));
        f[i][j] = min(f[i][j], g[i+1][j]+(w[j].x-w[i].x)*(q(1, i)+q(j+1, n)));
        g[i][j] = min(g[i][j], g[i][j-1]+(w[j].x-w[j-1].x)*(q(1, i-1)+q(j, n)));
        g[i][j] = min(g[i][j], f[i][j-1]+(w[j].x-w[i].x)*(q(1, i-1)+q(j, n)));
    }
    printf("%.3f\n", (tc-min(f[1][n], g[1][n]))/1000.0);
    return 0;
}
```

---

## 作者：猪小屁 (赞：5)

 具体怎么做各种大佬都讲清楚了，本蒟蒻来补充一些细节

 首先，这道题为什么是区间dp。
 
 ~~题做多了自然就知道了~~
 
 首先dp很明显，**选择这个球会让其他球的价值都减少，当前决策会影响到后面决策**
 
 （也是大佬们说的影响未来，后面会提到这一点）
 
 以下是解释，适合我这种入门区间dp的蒟蒻看，大佬请跳过啊
 

------------

 1.**对于球i到球j**
 
 首先我们可以看出，你从i跑到j，可以把中间所有的球都射了
 
 而射下来最后一颗球时肯定停留在i或者j（假如不是的话，你就要多跑好多冤枉路）
 
 
 我们可以从i直接跑到j
 
 也可以从i+1跑到j再跑回来
 
 也可以从i+1跑到i+n，再跑到i，再跑到j...
 
 这样的选择很多，所以我们可以把他缩成一个东西，这个东西**代表着这个区间所有决策的最优值**。这个东西就是dp数组啦（石子合并也是如此，你不知道他这段区间是怎么合并的）
 
所以状态就出来了：  _**dp[i][j][0]代表着第i个球到第j个球都射下来并最终停留在i的最优值，dp[i][j][1]则是停留在j的最优值**_  

为什么不以横坐标为区间呢？因为太多没用状态了，又可能有一段区间里面一个球都没有，而我们用球当区间，球之间的距离也可以O（1）算出来

2.**对于一个区间[i,j]**

dp[i][j][0]它可以由走完区间[i+1,j]，停留在i+1，向左走到球i转移过来，也可以由走完区间[i+1,j]，停留在j，向左走到球i转移

反之，dp[i][j][1]也可以这样子推

所以，**这些区间可以由子区间转移过来**，符合区间dp的要求

综上，区间dp成立（可能很啰嗦，说了很多重复的，请大佬勿喷啊qwq）

所以，在我们推这道题的做法的时候，我们其实已经有了转移方程的模板：[i,j]由[i+1,j]和[i,j+1]转移过来

我们推一推，可以发现，最后的答案是所有球的y值之和减去ti * vi 之和，ti是从出发射到这个球的时间，vi是这颗球的速度

所有，我们要让ti * vi之和越小越好，我们就拿dp数组去维护他

dp方程也就自然而然推出来啦

代码里也有注释qwq 后面还有内容哦


```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=1e3+5;
struct pyf{
	int x,y,llw;
	friend bool operator <(pyf l,pyf f){
		return l.x<f.x;
	}
}a[maxn];
int n,x0;
int dp[maxn][maxn][2],sum[maxn];
int main(){
	scanf("%d%d",&n,&x0);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i].x);
	}
	long long ans=0;
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i].y);
		ans+=a[i].y;
	}
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i].llw);
	}
	memset(dp,0x3f,sizeof(dp));
	sort(a+1,a+1+n);//保证相邻编号是相邻的球，好转移
	for(int i=1;i<=n;i++){//一定要先排序再求前缀和...血的教训 
		sum[i]=sum[i-1]+a[i].llw;
	} 
	int pos;
	if(a[1].x>=x0){
		dp[1][1][1]=dp[1][1][0]=(a[1].x-x0)*(sum[n]);
	} 
	else if(a[n].x<=x0){
		dp[n][n][1]=dp[n][n][0]=(x0-a[n].x)*(sum[n]);
	}
	else{
		for(int i=1;i<=n;++i){
			if(a[i].x<=x0&&a[i+1].x>=x0){
				pos=i;
				break;
			}
		}
		dp[pos][pos][0]=dp[pos][pos][1]=(x0-a[pos].x)*(sum[n]);
		dp[pos+1][pos+1][0]=dp[pos+1][pos+1][1]=(a[pos+1].x-x0)*(sum[n]);
	}//把离原来位置最近的球赋上初值	
	for(int len=2;len<=n;len++){//len从1开始的话，全是非法的（除了一开始可以走的最近的点） 
		for(int i=1;i+len-1<=n;i++){
			int j=i+len-1;
			dp[i][j][0]=min(dp[i+1][j][0]+(a[i+1].x-a[i].x)*(sum[i]+sum[n]-sum[j]),dp[i+1][j][1]+(a[j].x-a[i].x)*(sum[i]+sum[n]-sum[j]));
			dp[i][j][1]=min(dp[i][j-1][0]+(a[j].x-a[i].x)*(sum[i-1]+sum[n]-sum[j-1]),dp[i][j-1][1]+(a[j].x-a[j-1].x)*(sum[i-1]+sum[n]-sum[j-1]));
		}
	}
	printf("%.3f\n",(ans-min(dp[1][n][0],dp[1][n][1]))/1000.000);
	return 0;
}
/*
3 0
-4 -2 2
22 30 26
1 1 8
*/
```
还有就是，我们需要把离出发点最近的点的dp值初始化一下。

### 整个dp过程可以看成一个小区间从出发点向左右拓展，并覆盖完所有的球

对于一些明显不是最优区间，我们还是转移的一个巨大的0x3f，所以遍历到他还是不会影响答案。

比如有四个球，1，2，3，4编号，x1=-4，x2=-2，x3=2，x4=6，x0=4

对于dp[1,2]他是非法，因为不经过3号球就只打1，2号
很蠢，我们完全可以在途中把3号打了。

最后记得排下序，好转移，再对速度求个前缀和

（按球的横坐标排序，让相邻编号的球之间没有球，不然就会出现上述的很多没用区间的情况，转移方程也会失效）

---

## 作者：Mys_C_K (赞：3)

费用提前计算相关的dp。

转移的时候考虑会损失多少。

然后不能用llf输出【逃

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<vector>
#define inf -1000000000000.0
#define N 1010
#define debug(x) cerr<<#x<<"="<<x
#define sp <<" "
#define ln <<endl
using namespace std;
vector<int> vec;
int x[N],y[N],v[N],xid[N],n,pos[N];
double spd[N],hgt[N],dp[N][N][2],pre[N];
inline int getid(int x)
{
    return lower_bound(vec.begin(),vec.end(),x)-vec.begin()+1;
}
inline int gabs(int x)
{
    return (x>0)?x:-x;
}
inline double get_s(int l,int r)
{
    return pre[r]-pre[l-1];
}
inline double calc(int s,int t,int l,int r)
{
    return gabs(pos[t]-pos[s])*(get_s(1,l-1)+get_s(r+1,n));
}
int main()
{
    int x0;scanf("%d%d",&n,&x0);
    for(int i=1;i<=n;i++) scanf("%d",&x[i]);
    for(int i=1;i<=n;i++) scanf("%d",&y[i]);
    for(int i=1;i<=n;i++) scanf("%d",&v[i]);
    for(int i=1;i<=n;i++) vec.push_back(x[i]);
    vec.push_back(x0);sort(vec.begin(),vec.end());
    vec.erase(unique(vec.begin(),vec.end()),vec.end());
    for(int i=1;i<=n;i++) xid[i]=getid(x[i]);
    int x0id=xid[++n]=getid(x0);v[n]=0;hgt[n]=0;x[n]=x0;
    for(int i=1;i<=n;i++) spd[xid[i]]+=v[i]/1000.0;
    for(int i=1;i<=n;i++) pre[i]=pre[i-1]+spd[i];
    for(int i=1;i<=n;i++) pos[xid[i]]=x[i];
    for(int i=1;i<=n;i++) hgt[xid[i]]+=y[i]/1000.0;
    for(int i=1;i<=n;i++) dp[i][i][0]=dp[i][i][1]=inf;
    dp[x0id][x0id][0]=dp[x0id][x0id][1]=hgt[x0id];
    for(int len=2;len<=n;len++)
        for(int i=1;i+len-1<=n;i++)
        {
            int j=i+len-1;if(i>x0id||j<x0id) { dp[i][j][0]=dp[i][j][1]=inf;continue; }
//            debug(calc(i+1,i,i+1,j))sp,debug(calc(j,i,i+1,j))ln;
            dp[i][j][0]=max(dp[i+1][j][0]-calc(i+1,i,i+1,j),dp[i+1][j][1]-calc(j,i,i+1,j))+hgt[i];
            dp[i][j][1]=max(dp[i][j-1][1]-calc(j-1,j,i,j-1),dp[i][j-1][0]-calc(i,j,i,j-1))+hgt[j];
//            debug(i)sp,debug(j)sp,debug(dp[i][j][0])sp,debug(dp[i][j][1])ln;
        }
    printf("%.3lf\n",max(dp[1][n][0],dp[1][n][1]));return 0;
}
```

---

## 作者：Azazеl (赞：2)

### Sue的小球 题解

#### 题意  

> $~~~~$ 给了 $n$ 个小球，第 $i$ 个小球在 $x_i$ 初始分值为 $y_i$ ，同时它会以 $\dfrac{v_i}{1000}$ 每单位时间的速度降低。（可以降低为负数）从初始位置开始，每个单位时间可以移动 $1$ 单位长度。收集小球不需要时间，求收集所有小球后能获得的最大分值。

----

#### 题解

$~~~~$ 首先，可以想到对每个球按位置从小到大排序。由于总的得分固定，我们可以求最小损失，然后考虑：对于两个小球 $l,r (x_l<x_r)$ ，若它们都被收集了，则小球  $x\in[l,r]$ 也被收集一定是最优方案：  

$~~~~$ **证明**:~~显然。~~ 每个小球被收集，一定是从起始点走到过该小球的，则此时顺手收集路上的小球一定不会使答案变劣，因为收集不需要时间。  

$~~~~$     所以，我们考虑已经收集了 $[l,r]$ 的小球时，下一步一定是扩展到 $l-1$ 或 $r+1$ ，不难想到定义 $\texttt{DP}$ 状态：令 $dp_{i,j}$ 表示已经收集 $[l,r]$ 的所有小球时的最小损失。考虑 $\texttt{DP}$ 转移时需要当前的位置，因此增加一维，用来记录最后停留在 $i$ 或者 $j$ （当然也可以定义两个数组）。  

$~~~~$ 发现还是有问题， $\texttt{DP}$ 转移还需要记录当前的时间，可是如果我们把时间也加在 $\texttt{DP}$ 维度上，时间就爆了。  

$~~~~$ 这时就轮到这道题的精髓了——提前计算。我们是可以算出每一次转移时的时间的，那如果我们把每次转移时其他小球损失的分数也加上去，既然每个小球都将会被收集，那么最后的效果其实是一样的。  

$~~~~$ 具体来说，如果有小球 $[l,r]$ 已经被收集，则下一次转移时 $[1,l)$ 与 $(r,n]$ 的所有会被消耗的分数都可以直接加在下一次。  

$~~~~$ 然后再综合上前面的 $\texttt{DP}$ 推导就得到最终的方程了。

$~~~~$ 注意处理初始值时可以增加一个小球使得它的 $x=x_0，y=0,v=0$ ，初始化时就令这个小球为 $0$ 即可。

---

#### 代码

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#define ll long long
using namespace std;
template<typename T>void read(T &x)
{
    T f=1;x=0;char s=getchar();
    while(s<'0'||s>'9'){if(s=='-')f=-1;s=getchar();}
    while(s>='0'&&s<='9') {x=x*10+s-'0';s=getchar();}
    x*=f;
}
struct node{
	int x,y,v;
}b[1005];
inline bool cmp(node x,node y) {return x.x<y.x;}
ll dp1[1005][1005],dp2[1005][1005],w[1005];
inline int Abs(int x){return x>0?x:-x;}
int calc(int l,int r){return w[r]-w[l-1];}
int main() {
	int n,x;
	ll tot=0;
	read(n);read(x);
	for(int i=1;i<=n;i++) read(b[i].x);
	for(int i=1;i<=n;i++) read(b[i].y),tot+=b[i].y;
	for(int i=1;i<=n;i++) read(b[i].v);
	b[++n].x=x;
	sort(b+1,b+n+1,cmp);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++) dp1[i][j]=dp2[i][j]=1e18;
	}
	for(int i=1;i<=n;i++)
	{
		w[i]=w[i-1]+b[i].v;
		if(b[i].v==0&&b[i].x==x) dp1[i][i]=dp2[i][i]=0;
	}
	//dp1[i][j] 收集了第 i个 至 第 j个彩蛋 最后停留在 i
	//dp2[i][j]··················· j
	for(int len=2;len<=n;len++)
	{
		for(int i=1;i+len-1<=n;i++)
		{
			int j=i+len-1;
			dp1[i][j]=min(dp1[i][j],dp1[i+1][j]+Abs(b[i+1].x-b[i].x)*(calc(1,i)+calc(j+1,n)));
			dp1[i][j]=min(dp1[i][j],dp2[i+1][j]+Abs(b[ j ].x-b[i].x)*(calc(1,i)+calc(j+1,n)));
			dp2[i][j]=min(dp2[i][j],dp1[i][j-1]+Abs(b[ i ].x-b[j].x)*(calc(1,i-1)+calc(j,n)));
			dp2[i][j]=min(dp2[i][j],dp2[i][j-1]+Abs(b[j-1].x-b[j].x)*(calc(1,i-1)+calc(j,n)));
		}
	}
//	printf("%d %d %d\n",tot-min(dp1[1][n],dp2[1][n]),dp1[1][n],dp2[1][n]);
	printf("%.3lf",(tot-min(dp1[1][n],dp2[1][n]))/1000.0);
	return 0;
}

```



$~~~~$ 

---

## 作者：love_luke (赞：2)

要做这道题，先要弄明白P1220关路灯。然后这道题的解决也就不差多少了。

先弄明白这道题与关路灯的区别。第一，它输入的数据是无序的。第二，起始点上不一定有彩蛋。

动态转移方程与关路灯相似。
```cpp
f[i][j][0]=a[i].y+max(f[i+1][j][0]-(a[i+1].x-a[i].x)*(s[i]+s[n]-s[j]),f[i+1][j][1]-(a[j].x-a[i].x)*(s[i]+s[n]-s[j]));
f[i][j][1]=a[j].y+max(f[i][j-1][1]-(a[j].x-a[j-1].x)*(s[i-1]+s[n]-s[j-1]),f[i][j-1][0]-(a[j].x-a[i].x)*(s[i-1]+s[n]-s[j-1]));
```
其中f[i][j][0]表示将i到j区间内，人在i时的最大分数，f[i][j][1]表示将i到j区间内，人在j时的最大分数。

至于千分之一，只要在输出时处理一下就行了。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct lyx//因数据无序，用结构体存储，方便排序
{
    int x,y,v;
}a[1002];
int f[1002][1002][2],s[1002];
bool cmp(lyx x,lyx y)
{
    return x.x<y.x;
}
int main()
{
    int n,x0,i,j,l;
    cin>>n>>x0;
    for (i=1;i<=n;++i)
    {
        cin>>a[i].x;
    }
    for (i=1;i<=n;++i)
    {
        cin>>a[i].y;
    }
    for (i=1;i<=n;++i)
    {
        cin>>a[i].v;
    }
    a[++n].x=x0;//将起始点加入，无价值与损耗
    sort(a+1,a+n+1,cmp);
    for (i=1;i<=n;++i)
    {
        s[i]=s[i-1]+a[i].v;
    }
    memset(f,-0x3f,sizeof(f));//要求最大值，且数据有负值，数组附成极小值
    for (i=1;i<=n;++i)//找起始点初始化
    if ((a[i].v==0)&&(a[i].x==x0))
    {
        f[i][i][1]=f[i][i][0]=0;
    }
    for (l=2;l<=n;++l)//核心代码
    for (i=1;i+l-1<=n;++i)
    {
        j=i+l-1;
        f[i][j][0]=a[i].y+max(f[i+1][j][0]-(a[i+1].x-a[i].x)*(s[i]+s[n]-s[j]),f[i+1][j][1]-(a[j].x-a[i].x)*(s[i]+s[n]-s[j]));
        f[i][j][1]=a[j].y+max(f[i][j-1][1]-(a[j].x-a[j-1].x)*(s[i-1]+s[n]-s[j-1]),f[i][j-1][0]-(a[j].x-a[i].x)*(s[i-1]+s[n]-s[j-1]));
    }
    printf("%.3lf",max(f[1][n][1],f[1][n][0])/1000.0);//输出处理
    return 0;
}
```


---


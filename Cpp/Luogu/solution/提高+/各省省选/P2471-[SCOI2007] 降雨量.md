# [SCOI2007] 降雨量

## 题目描述

我们常常会说这样的话：“$X$ 年是自 $Y$ 年以来降雨量最多的”。它的含义是 $X$ 年的降雨量不超过 $Y$ 年，且对于任意 $Y < Z < X$，$Z$ 年的降雨量严格小于 $X$ 年。例如 2002、2003、2004 和 2005 年的降雨量分别为 $4920$、$5901$、$2832$ 和 $3890$，则可以说“2005 年是自 2003 年以来最多的”，但不能说“2005 年是自 2002 年以来最多的”由于有些年份的降雨量未知，有的说法是可能正确也可以不正确的。


## 说明/提示

$100 \%$ 的数据满足：$1 \le n \le 50000$，$1 \le m \le 10000$，$-10^9 \le y_i \le 10^9$，$1 \le r_i \le 10^9$，$-10^9 \le X, Y \le 10^9$。

数据保证 $Y < X$。

## 样例 #1

### 输入

```
6
2002 4920
2003 5901
2004 2832
2005 3890
2007 5609
2008 3024
5
2002 2005
2003 2005
2002 2007
2003 2007
2005 2008
```

### 输出

```
false
true
false
maybe
false
```

# 题解

## 作者：xyz32768 (赞：123)

这里yea[i]表示第i个降雨量已知的年份，val[i]为第i个降雨量已知的年份的降雨量。

对于每一次询问，先求出从Y年开始往右查找最早能达到降雨量已知的年份编号u（之后的年份降雨量全部未知则为n+1），

如已知降雨量的年份分别为45 47 49 56 58 79，那么50年和56年对应的编号都是4（56在序列中的位置为4），

对于X年也求出往右查找最早能达到降雨量已知的年份编号v。由于年份是单调的，所以可用二分查找。

这样，求M年的降雨量是否已知，只需要先求出从M年开始往右查找最早能达到降雨量已知的年份编号s，

然后判断s != n + 1 && M == yea[s]。

分4种情况：

1、Y年和X年的降雨量都已知：

第一步，如果val[u] < val[v]，就说明不满足“X年的降雨量不超过Y年”这个条件，输出false并continue。

第二步，在v == u + 1的情况下，如果X == Y + 1就输出true（Y和X之间（不包括Y和X）没有整数）并continue，否则输出maybe并continue（Y和X之间存在降雨量未知的年份）。

第三步，查询[u + 1, v - 1]之间的最大值max（可用线段树或ST表维护），如果max >= val[v]，就说明不满足“对于任意

Y＜Z＜X，Z年的降雨量严格小于X年”这个条件，输出false并continue。

第四步，判断是否X - Y == v - u，如果为真就输出true（Y年和X年之间没有任何降雨量未知的年份），否则输出maybe（反之）。

2、Y年的降雨量未知，X年的降雨量已知：

第一步，如果u == v，输出maybe（Y年和X年之间年份的降雨量全部未知）并continue。

第二步，查询[u, v - 1]之间的最大值max，如果max >= val[v]，就说明不满足“对于任意Y＜Z＜X，Z年的降雨量严格小于X年”这个条件，输出false，否则输出maybe（Y年和X年的降雨量只要有一个未知就不能确定这句话是否一定为真）。

3、Y年的降雨量已知，X年的降雨量未知：

第一步，如果v == u + 1，输出maybe（Y年和X年的降雨量只要有一个未知就不能确定这句话是否一定为真）并continue。

第二步，查询[u + 1, v - 1]之间的最大值max，如果val[u] <= max，就说明X年的降雨量M不管为多少都无法同时满足M > max和 M <= val[u]，输出false，否则输出maybe（Y年和X年的降雨量只要有一个未知就不能确定这句话是否一定为真）。

4、Y年和X年的降雨量都未知：输出maybe（Y年和X年的降雨量只要有一个未知就不能确定这句话是否一定为真）。


---

## 作者：浅色调 (赞：95)

### Solution:

　　本题题目出的是真的好（鬼）。。。`～`这两天调得我——快要吐血的万恶之源……

　　首先我们对于判断时的顺序做一个调整，按情况的可能性从多到少，先判断$false$，再判断$maybe$，最后剩下的才是$true$。

　　题目中会用到某段区间的最大值进行判断，所以我们可以用一棵线段树去维护（至于区间连续性就没必要用线段树维护了，有更好的方法，亏我开始傻乎乎用线段树去写`～`）。

　　因为读入时的年份是保证递增的，所以对于每次询问$x,y$（**当$x\geq y$直接输$false$**），我们可以先二分找出第一个不小于$x$的位置，和$y$的位置，不妨假设为$st$和$ed$，然后判断边界的年份是否相等，并查询出$st+1$到$ed-1$的最大值（**因为要取出中间一段的最大值，用其和两端比较，注意判断左端点年份不确定时要查询$st$到$ed-1$的最大值**）。

　　判断时：

　　　　**先判$false$：**

　　　　　　1、当右端点年份确定，且中间年份最大降雨量大于等于右端点降雨量  

　　　　　　2、当左端点年份确定，且中间年份最大降雨量大于等于左端点降雨量 

　　　　　　3、当左右端点年份都确定，且左端点降雨量小于等于右端点降雨量

　　　　**再判$maybe$:**

　　　　　　1、当左右端点之差不等于左右端点年份之差（等价于年份不连续，也就是我前面所说的更好的判断区间连续的方法）

　　　　　　2、左端点年份不确定

　　　　　　3、右端点年份不确定

　　　　　　（因为已经切掉$false$的情况了，那么剩下的情况中可以直接照上面的判断！）

　　　　**最后判断$true$:**
    $\;\;$若上面情况都不满足，那么肯定是$true$
	
$\quad\;\;$不得不说，本题很值得做，需要考虑很全面，至少我还不够稳，同时感谢巨佬$old-fish$提供的方法。

$\quad\;\;$欢迎来踩博客：[five20](https://www.cnblogs.com/five20/p/9123773.html)（蒟蒻写题解不易，转载请注明出处，万分感谢！）

### 代码：
```cpp
#include<bits/stdc++.h>
#define il inline
#define lson l,m,rt<<1
#define rson m+1,r,rt<<1|1
#define For(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)
#define Max(a,b) ((a)>(b)?(a):(b))
using namespace std;
const int N=200005;
int n,m,num[N],ls[N],rs[N];
int ye[N],co[N];
bool f[N];
struct node{
    int ans,f;
};

il int gi(){
    int a=0;char x=getchar();bool f=0;
    while((x<'0'||x>'9')&&x!='-')x=getchar();
    if(x=='-')x=getchar(),f=1;
    while(x>='0'&&x<='9')a=(a<<3)+(a<<1)+x-48,x=getchar();
    return f?-a:a;
}

il void pushup(int rt){
    if(rs[rt<<1]==ls[rt<<1|1]-1)f[rt]=f[rt<<1]&f[rt<<1|1];
    rs[rt]=rs[rt<<1|1];ls[rt]=ls[rt<<1];
    num[rt]=Max(num[rt<<1],num[rt<<1|1]);
}

il void build(int l,int r,int rt){
    if(l==r){rs[rt]=ls[rt]=ye[l],num[rt]=co[l],f[rt]=1;return;}
    int m=l+r>>1;
    build(lson),build(rson);
    pushup(rt);
}

il node query(int L,int R,int l,int r,int rt){
    if(L<=l&&R>=r){
        node tmp;
        tmp.ans=num[rt],tmp.f=f[rt];
        return tmp;
    }
    int m=l+r>>1;
    node tmp;
    tmp.ans=0,tmp.f=1;
    if(L<=m){
        node x=query(L,R,lson);
        tmp.ans=Max(tmp.ans,x.ans);
        tmp.f&=x.f;
    }
    if(R>m){
        node x=query(L,R,rson);
        tmp.ans=Max(tmp.ans,x.ans);
        tmp.f&=x.f;
    }
    return tmp;
}

int main(){
    n=gi();
    For(i,1,n)ye[i]=gi(),co[i]=gi();
    build(1,n,1);
    m=gi();
    int x,y;
    while(m--){
        x=gi(),y=gi();
        if(x>=y){printf("false\n");continue;}
        int st=lower_bound(ye+1,ye+n+1,x)-ye,ed=lower_bound(ye+1,ye+n+1,y)-ye;
        bool fl,fr;int op=0;
        fl=ye[st]==x,fr=ye[ed]==y;
        if(!fl)st--;
        if(st+1<=ed-1)op=query(st+1,ed-1,1,n,1).ans;
        if((op>=co[ed]&&fr)||(co[st]<co[ed]&&fl&&fr)||(op>=co[st]&&fl))printf("false\n");
        else if(ed-st!=ye[ed]-ye[st]||!fr||!fl)printf("maybe\n");
        else printf("true\n");
    }
    return 0;
}
```



---

## 作者：雪风舞者 (赞：44)

- 看到这个题时：
哇这个紫题看起来好简单啊！我要切掉！
- 调试时：
天啊这里为什么错了，这里为什么又错了？啊啊啊啊！~~于是不断交不断WA~~
- AC后：
吐血。。。

_以上真实写照$\Uparrow$_

各位大佬对于解法讲的挺详细了，我再补充下独立思考的过程（没看题解的！）。共能分五种情况：
1. $y>=x$无解，出$false$
2. $y$和$x$均未知，$maybe$
3. 有一个未知，判断另一个与区间的大小关系$maybe$或$false$
4. $y$和$x$均已知但中间有未知的，按题意判断$maybe$或$false$
5. 包括$y$和$x$的整个区间都已知，按题意判断$true$或$false$

至于区间最值，~~暴力啊！（稳TLE的）~~可以用线段树或st表维护。本蒟蒻选择的是st表~~因为懒~~。离散化的处理当然也得有，既然都用stl了干脆用map多棒呢~~还是懒~~！
#### 代码如下
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<map>
using namespace std;
int st[50005][20];
int n,m;
map<int,int> id;
//建st表
void build(){
	for(int j=1;1<<j<=n;j++)
		for(int i=1;i+(1<<j)-1<=n;i++)
			st[i][j]=max(st[i][j-1],st[i+(1<<(j-1))][j-1]);
}
//查询
inline int RMQ(int l,int r){
	int k;
	for(k=0;1<<(k+1)<=(r-l+1);k++);
	return max(st[l][k],st[r-(1<<k)+1][k]);
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		int y;
		scanf("%d%d",&y,&st[i][0]);
		id[y]=i;//map插入，自动离散化了
	}
	build();
	scanf("%d",&m);
	while(m--){
		int x,y;
		scanf("%d%d",&y,&x);
		if(y>=x){
			printf("false\n");
			continue;
		}//情况1
		bool kx=id.count(x),ky=id.count(y),flag;
		if(!kx&&!ky){
			printf("maybe\n");
			continue;
		}//情况2
		int xx,yy;
		map<int,int>::iterator itx,ity;
		ity=id.lower_bound(y);
		itx=id.lower_bound(x);
		if(ity==id.end()){
			printf("maybe\n");
			continue;
		}
		yy=ity->second;
		xx=itx==id.end()?id.size()+1:itx->second;
		if(!ky) yy--;
		int rmq=yy+1<=xx-1?RMQ(yy+1,xx-1):0;
		if(!ky) flag=rmq<st[xx][0];//情况3-1
		else if(!kx) flag=st[yy][0]>rmq;//情况3-2
		else flag=st[yy][0]>=st[xx][0]&&st[xx][0]>rmq;
        //情况4和5可以类比处理
		if(ky&&kx&&yy-xx==y-x){
			if(flag) printf("true\n");
			else printf("false\n");
		}
		else{
			if(flag) printf("maybe\n");
			else printf("false\n");
		}
	}
	return 0;
}
```
最后~~厚颜无耻地~~欢迎各位大佬来踩[本蒟蒻的博客](https://www.luogu.org/blog/xuefengwuzhe/)

---

## 作者：小菜鸟 (赞：40)

写给平衡树信仰玩家的一篇题解。  

这题如果用线段树写，需要如离散化等诸多奇技淫巧。但平衡树相对线段树，拥有更加灵活的结构，更适合解决复杂的区间问题。  

于是，考虑对平衡树进行魔改。我们发现离散化的本质，是将范围极大的年份映射进了一个较小的范围。  

映射是什么？~~就是std::map呀~~  

那么我们效仿map，将平衡树写成键-值对的形式（年份为键，降雨量为值），便可以对巨大的年份区间进行查询。  

至于代码实现，用文艺平衡树即可。  

这里采用$fhqTreap$来实现文艺平衡树，代码中有更详细的注释。  

```cpp
#include<cstdio>
#include<cstdlib>
#include<algorithm>
using namespace std;
struct Node
{
    int year;//以年份作为键
    int water;//以降雨量作为值
    int max_water;//子树中最大降雨量
    int s;//子树大小
    Node *lc,*rc;
    int pri;
    Node(int y,int w):
        year(y),
        water(w),
        max_water(w),
        s(1),
        lc(NULL),
        rc(NULL),
        pri(rand()) {}
    void maintain()//维护子树信息
    {
        s=1;
        max_water=water;
        if(lc!=NULL)
        {
            s+=lc->s;
            if(max_water<lc->max_water)max_water=lc->max_water;
        }
        if(rc!=NULL)
        {
            s+=rc->s;
            if(max_water<rc->max_water)max_water=rc->max_water;
        }
    }
};
Node *_root;
Node *merge(Node *l,Node *r)//fhqTreap常规操作，不多说
{
    if(l==NULL)return r;
    if(r==NULL)return l;
    if(l->pri<r->pri)
    {
        l->rc=merge(l->rc,r);
        l->maintain();
        return l;
    }
    else
    {
        r->lc=merge(l,r->lc);
        r->maintain();
        return r;
    }
}

void split(Node *nroot,int k,Node *&l,Node *&r)
//将以nroot为根的子树分为年份小于k、大于等于k的部分
{
    if(nroot==NULL)
    {
        l=NULL;
        r=NULL;
        return;
    }
    if(nroot->year<k)
    {
        l=nroot;
        split(l->rc,k,l->rc,r);
    }
    else
    {
        r=nroot;
        split(r->lc,k,l,r->lc);
    }
    nroot->maintain();
}

int query(int l,int r)//true返回1，false返回0，maybe返回-1
{
    Node *ptr1,*ptrl,*ptr,*ptrr,*ptr2;
    split(_root,l,ptr1,ptrl);
    split(ptrl,l+1,ptrl,ptr);
    split(ptr,r,ptr,ptrr);
    split(ptrr,r+1,ptrr,ptr2);
    //按l、r将整棵树拆成5部分
    if(ptrl!=NULL&&ptrr!=NULL)//首尾两年都知道
    {
        if(ptrl->water<ptrr->water)//判断尾年降雨量是否大于首年
        {
            _root=merge(merge(ptr1,ptrl),merge(merge(ptr,ptrr),ptr2));
            return 0;
        }
        if(ptr!=NULL&&ptr->max_water>=ptrr->water)//判断尾年是否为最大
        {
            _root=merge(merge(ptr1,ptrl),merge(merge(ptr,ptrr),ptr2));
            return 0;
        }
        if((ptr==NULL?0:ptr->s)<r-l-1)//判断首尾两年间是否所有年份都已知
        {
            _root=merge(merge(ptr1,ptrl),merge(merge(ptr,ptrr),ptr2));
            return -1;
        }
        _root=merge(merge(ptr1,ptrl),merge(merge(ptr,ptrr),ptr2));//如果都正确就是对的
        return 1;
    }
    if(ptrl==NULL&&ptrr!=NULL)//首年未知，尾年已知
    {
        if(ptr!=NULL&&ptr->max_water>=ptrr->water)//判断尾年是否最大
        {
            _root=merge(merge(ptr1,ptrl),merge(merge(ptr,ptrr),ptr2));
            return 0;
        }
    }
    if(ptrl!=NULL&&ptrr==NULL)//首年已知，尾年未知
    {
        if(ptr!=NULL&&ptr->max_water>=ptrl->water)
        //若首尾两年之间有某年降雨量大于等于首年，则无论如何不满足条件
        {
            _root=merge(merge(ptr1,ptrl),merge(merge(ptr,ptrr),ptr2));
            return 0;
        }
        _root=merge(merge(ptr1,ptrl),merge(merge(ptr,ptrr),ptr2));
        return -1;
    }
    _root=merge(merge(ptr1,ptrl),merge(merge(ptr,ptrr),ptr2));//若都不行，则结论无从知晓
    return -1;
}
int main()//主程序相当简单，不解释
{
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;++i)
    {
        int y,w;
        scanf("%d%d",&y,&w);
        _root=merge(_root,new Node(y,w));
    }
    int m;
    scanf("%d",&m);
    for(int i=1;i<=m;++i)
    {
        int l,r;
        scanf("%d%d",&l,&r);
        int ans(query(l,r));
        if(ans==1)
        {
            puts("true");
            continue;
        }
        if(ans==0)
        {
            puts("false");
            continue;
        }
        if(ans==-1)
        {
            puts("maybe");
            continue;
        }
    }
}
```



---

## 作者：ailanxier (赞：25)

> [听说博客观看效果更佳](https://www.cnblogs.com/ailanxier/p/13408783.html)

&emsp;&emsp;这道题是比较经典的 $RMQ$ 问题,找到X和Y年间的最值来进行判断真假 , 用线段树维护是比较简单好写的。然而这只是一个小判断，比较难的是判断 
 $maybe$ 。如果没有想好直接打代码会调很久（~~没错就是我~~）。怎么维护查询区间最大值我就不再这里赘述了，不懂线段树的先去入门（此题也是线段树入门题）。我讲几个很坑的点（~~比较坑我的点~~）：

&emsp;&emsp;1.询问的X年降雨量不超过Y，但是中间年份降雨量一定小于X（注意X和Y顺序）。

&emsp;&emsp;2.X可能等于Y+1年，也就是不用考虑中间年份。

&emsp;&emsp;3.区间查询最值的操作要留意范围，不同情况下查询的范围是不一样的，这点需要自己理解。

&emsp;&emsp;4.错的最多的 $maybe$ 和 $false$ 的判断，要清楚知道哪个是已知量，哪个是未知量（特别是X和Y是未知量的时候）。

&emsp;&emsp;本题中我分了四种情况分析，还有众多 $if$ 和 $else$ ,需要格外小心。我对输出进行简化，应该会更加直观一点。

## $Code$
```
#include<bits/stdc++.h>
using namespace std;
#define For(i,sta,en) for(int i = sta;i <= en;i++)
#define lowbit(x) x&(-x)
#define mid (l+r)/2
#define ls(x) x<<1
#define rs(x) x<<1|1
#define speedUp_cin_cout ios::sync_with_stdio(false);cin.tie(0); cout.tie(0);
typedef long long ll;
typedef __int128 lll;
const int maxn = 2e5+9;
int t[maxn],n,m;  //t 记录区间最大值
int year[maxn],rain[maxn];

void update(int now,int l,int r,int pos,int value){
    if(l == r) {t[now] = value;return;}
    if(pos <= mid) update(ls(now),l,mid,pos,value);
    else update(rs(now),mid+1,r,pos,value);
    t[now] = max(t[ls(now)],t[rs(now)]);  //维护区间最大值
}

int query(int now,int l,int r,int x,int y){  //询问x到y区间最大值
    if(x <= l&&r <= y) return t[now];
    int an = 0;
    if(x <= mid) an = query(ls(now),l,mid,x,y);
    if(y > mid) an = max(an,query(rs(now),mid+1,r,x,y));
    return an;
}
int main(){
    speedUp_cin_cout  //读写优化
    #define maybe cout<<"maybe"<<endl;continue;//让输出没这么难看
    #define false cout<<"false"<<endl;continue;
    #define true cout<<"true"<<endl;continue;
    cin>>n;
    int y,r;
    For(i,1,n)  {
        cin>>y>>r;
        year[i] = y;
        rain[i] = r;
        update(1,1,n,i,r);
    }
    cin>>m;
    int Y,X,p1,p2,f1,f2; //p1 p2是在数组的位置,f1 f2两个标记记录X Y是否已知降水量
    For(i,1,m){
        cin >> Y >> X;
        p1 = lower_bound(year+1,year+1+n, Y) - year; //year在输入时保证是有序的
        p2 = lower_bound(year+1,year+1+n, X) - year;
        f1 = (p1 == n + 1|| year[p1] != Y) ? 0 : 1;
        f2 = (p2 == n + 1 ||year[p2] != X) ? 0 : 1;
        //两年都不知道,可以不管中间如何，都是未知的
        if(!f1 && !f2) {maybe}
        //两年都知道
        if(f1 && f2) {
            if(rain[p1] < rain[p2]) {false}        //X年降水量多于Y年，错
            if(Y + 1 == X ) {true}                 //X = Y+1年，中间没有其他年份，而X年降水量一定不大于Y，对
            if(p1 + 1 == p2) {maybe}               //X不是Y后一年,但是X和Y年间都不知道降雨量，未知
            int maxGap = query(1,1,n,p1+1,p2-1);   //X和Y间存在已知降水量的年份，在其中找到降雨量最大值
            if(maxGap >= rain[p2]) {false}         //大于等于都满足严格小于，错
            if(p2 - p1 == X - Y) {true}            //满足严格小于后再判断X和Y间每年降雨量是否都已知
            else maybe                             //不是都已知，即未知
        }
        //后一年不知道，p2 一定大于 p1,只可能是maybe或者false
        else if(f1){
            if( p1 + 1 == p2 ) {maybe}
            int maxGap = query(1,1,n,p1+1,p2-1);   //注意查询范围
            if(maxGap >= rain[p1]) { false }
            else maybe
        }
        //前一年不知道，p1 有可能等于 p2,只可能是maybe或者false
        else{
            if(p1  == p2 ) {maybe}
            int maxGap = query(1,1,n,p1,p2-1);    //注意查询范围
            if(maxGap >= rain[p2]) { false }
            else { maybe }
        }
    }
    return 0;
}
```
**希望大家都能一次AC这道题<(￣︶￣)↗[GO!]**

---

## 作者：a2956331800 (赞：20)

## ~~凭什么是个紫题啊瞎讨论下就过了~~

## ~~应该就是个蓝啊~~

来来来开始讨论

首先记$Y$为$l$，记$X$为$r$（这样比较直观）

以下提到的$y[i],r[i]$与题目中的意义相同
```cpp
如果第$r$年降水量未知
{
	如果第$l$年降水量也未知
       maybe//r[l]<r[y]时为false，r[l]>=r[r]>max{r[x],l<x<r}时为true
    否则(第$l$年降水量已知)
    {
       如果r[l]>max{r[x],l<x<r}
         maybe //l年的降水量满足条件，但r年的不一定
       否则为 false//true的条件是r[l]>=r[r]>max{r[x],l<x<r}
       		   //如果r[l]<=max{r[x],l<x<r}
                  //上面那个式子显然不能成立
    }
}
否则(第$r$年降水量已知)
{
	如果第$l$年降水量已知
    {
    	如果r[l]<r[r]
          false//明显不满足题目条件（X年的降雨量不超过Y年）
        如果max{r[x],l<x<r}>=r[r]
          false//同理还是不满足给定条件
               //（对于任意Y<Z<X，Z年的降雨量严格小于X年）
        如果r-l==pos[r]-pos[l]（pos[i]表示i在y数组中的下标）
          true//l-r之间每一年降水量都已知且满足条件（前两个判断排除了不满足的情况）
        maybe//已知的年份都满足，但未知的年份可以不满足
    }
    如果第$l$年降水量未知
    {
    	如果r[r]<=max{r[x],l<x<r}
          false//已知年份有不满足条件的
        maybe//已知的年份都满足，但未知的年份可以不满足
    }
}
```
~~理解了之后把上面的翻译成代码就行了~~

- 如何判断年份是否出现 如何求$pos[i]$

开一个$map$，读入$y[i]$时顺便$mp[y[i]]=i$，这样$mp[i]$就是$pos[i]$，如果$mp[i]$不存在就是$i$年没有出现

- 如何求$max\left\{r[x],l<x<r\right\}$

用$st$表对$r[i]$维护区间最大值，查的时候如果$l,r$存在就直接查，不存在就在$y[i]$上**二分**出第一个 大于$l$/小于$r$ 的位置）

代码：（上面那一段讨论就是对着代码写的）

（$True,False,Maybe$都是宏，输出完就$continue$处理下一个询问，省去一堆$else$）
```cpp
#include<iostream>
#include<cstdio>
#include<map>
#define True {printf("true\n");continue;}
#define False {printf("false\n");continue;}
#define Maybe {printf("maybe\n");continue;}
using namespace std;

int n,m,y[50005],r[50005],i,L,R;

map<int,int> mp;

int st[17][50005],log2[50005],mi[20];
void build_st()
{
	for(int i=2;i<=n;i++)
	  log2[i]=log2[i/2]+1;
	mi[0]=1;
	for(int i=1;i<20;i++)
	  mi[i]=mi[i-1]*2;
	for(int i=1;i<=16;i++)
	  for(int j=1;j<=n;j++)
	    st[i][j]=max(st[i-1][j],st[i-1][j+mi[i-1]]);
}
inline int ask(int l,int r)
{
	if(l>r)
	  return 0;
	return max(st[log2[r-l+1]][l],st[log2[r-l+1]][r-mi[log2[r-l+1]]+1]);
}

int fl(int x)//二分出第一个不大于x的位置
{
	int L=0,R=n+1,mid;
	while(L<R)
	{
		mid=(L+R+1)>>1;
		if(y[mid]<x)
		  L=mid;
		else R=mid-1;
	}
	return L;
}

char Getchar()
{
	return getchar();
	static char buff[1000000],*p,*end=p;
	if(p==end)
	  end=buff+fread(p=buff,1,1000000,stdin);
	return *(p++);
}
template<typename T>void read(T &x)
{
	static char rc;static int flag;
	x=0;rc=Getchar();flag=1;
	while(!isdigit(rc))
	  flag=(rc=='-'?-1:1),rc=Getchar();
	while(isdigit(rc))
	  x=x*10+rc-'0',rc=Getchar();
	x*=flag;
}

int main()
{
	read(n);
	for(i=1;i<=n;i++)
	  read(y[i]),read(r[i]),mp[y[i]]=i,st[0][i]=r[i];
	read(m);
	build_st();
	for(i=1;i<=m;i++)
	{
		read(L);read(R);
		if(mp.find(R)==mp.end())
		{
			if(mp.find(L)==mp.end())
			  Maybe;
			if(ask(mp[L]+1,fl(R))<r[mp[L]])
			  Maybe;
			False;
		}
		else if(mp.find(L)!=mp.end())
		{
			if(r[mp[L]]<r[mp[R]])
			  False;
			if(ask(mp[L]+1,mp[R]-1)>=r[mp[R]])
			  False;
			if(R-L==mp[R]-mp[L])
			  True;
			Maybe;
		}
		else
		{
			if(ask(fl(L)+1,mp[R]-1)>=r[mp[R]])
			  False;
			Maybe;
		}
	}
	return 0;
}
```

---

## 作者：1261687299kid (赞：18)

昨天刚看完《天气之子》突然看到这道题，就想做一下

看了一下所有题解，竟然没有暴力的。

n<=50000,m<=10000,再加上判为false的时候可以直接退出

所以O(nm)的方法的期望运行次数小于2.5亿，显然是可以水过的。

我们先用map存下每个年份的位置，每次暴力从y扫到x。

一共有4种情况(以下大于小于号皆为比较降雨量)

1.y,x都未知，直接输出maybe

2.y未知,x已知,若y到x中有数>=x，则输出false，否则为maybe

3.y已知,x未知，若y到x中有数>=y,则输出false，否则为maybe

4.y,x都已知，若x>y或y到x中有数>=x,则输出false，否则若y到x中所有年份的降雨量都已知，则输出true，否则输出maybe

代码如下
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=50010;
map<int,int> mp;
int n,m,a[N],r[N];
int main()
{
	scanf("%d",&n);	
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d",a+i,r+i);
		mp[a[i]]=i;
	}
	mp[1e9+7]=n+1;
	scanf("%d",&m);
	for(int i=0;i<m;i++)
	{
		int y,x;
		scanf("%d%d",&y,&x);
    if(mp.find(y)==mp.end()&&mp.find(x)==mp.end())
		{
			printf("maybe\n");
			continue;
		}
		if(mp.find(y)==mp.end())
		{
			int k=mp.upper_bound(y)->second;
			int j=mp.find(x)->second;
			bool flag=true;
			while(k<j&&flag)
				if(r[k++]>=r[j]) flag=false;
			if(flag) printf("maybe\n");
			else printf("false\n");
			continue;
		}
		if(mp.find(x)==mp.end())
		{
			int k=mp.upper_bound(x)->second-1;
			int j=mp.find(y)->second;
			bool flag=true;
			while(j<k&&flag)
				if(r[k--]>=r[j]) flag=false;
			if(flag) printf("maybe\n");
			else printf("false\n");
			continue;
		}
		bool flag=true;
		int j=mp.find(y)->second;
		int k=mp.find(x)->second;
		if(r[k]>r[j]) flag=false;
		for(int p=j+1;p<k&&flag;p++)
			if(r[p]>=r[k]) flag=false;
		if(flag) if(k-j==x-y) printf("true\n");
				 else printf("maybe\n");
		else printf("false\n");
	}
	return 0;
}
```
没加任何优化，最慢的点跑了944ms，暴力卡着过。

---

## 作者：vani_prcups (赞：13)

降雨量——人生中第三道省选/NOI-……

耗时三天，提交30多次，我终于AC了这道看似简单实则很烦人的省选题。

题目在这里

试试线段树？用两个线段树分别维护最小值、最大值，对每个询问l,r区间判断条件，得出答案:

不过问题来了：年份如何处理？

所以：离散化。

初始年份设为1；如果相邻两个年份差大于1，则把他们的差设为2，否则为1，这样只需要开100005元素数组即可。

查找的时候找年份怎么办呢？疯狂的我竟然想到了二分……

题解就是这样。第一份代码3天前就完成了。之后3天，是各种改错：

1.二分边界问题必须知道。

2.边有负权，有0权（这简直是要我死）。所以最初值要设为-0x7fffffff……

3.先判false，再判maybe，都不是则true。注意最小边之类（这里最烦了）：

```cpp
if (v-u==1)//我不知道有没有这样的坑数据，X,Y相邻…… 
{
      if (a[u]==low||a[v]==low)printf("maybe\n");
      else if (a[u]>=a[v])printf("true\n");
      else printf("false\n");
}
else if ((a[u]!=low&&a[u]<=mx(1,u+1,v-1,1,len))||(a[u]!=low&&a[u]<a[v])||(a[v]!=low&&mx(1,u+1,v-1,1,len)>=a[v]))printf("false\n");//判断false的情况，注意a[u,v]!=0，否则会WA得很惨 
else if (a[u]==low||a[v]==low||mn(1,u+1,v-1,1,len)==low)printf("maybe\n");//判断可能的情况 
else printf("true\n");
```

代码如下：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
struct node
{
    int y,pt;
}b[50005];
const int low=-0x7fffffff/2;
int n,m,a[100005],t1[400005],t2[400005],fyr=low,len;//a：位置离散化后的原始数组；b：年份->a数组位置转换数组；t1、t2：线段树 
void build(int root,int s,int e)
{
    if (s==e)
    {
        t1[root]=t2[root]=a[s];
        return;
    }
    int mid=(s+e)/2;
    build(root*2,s,mid);
    build(root*2+1,mid+1,e);
    t1[root]=max(t1[root*2],t1[root*2+1]);
    t2[root]=min(t2[root*2],t2[root*2+1]);
}
int mn(int root,int s,int e,int ts,int te)
{
    if (ts>e||te<s)return 0x7fffffff/2;
    if (ts>=s&&te<=e)return t2[root];
    int mid=(ts+te)/2;
    return min(mn(root*2,s,e,ts,mid),mn(root*2+1,s,e,mid+1,te));
}
int mx(int root,int s,int e,int ts,int te)
{
    if (ts>e||te<s)return low;
    if (ts>=s&&te<=e)return t1[root];
    int mid=(ts+te)/2;
    return max(mx(root*2,s,e,ts,mid),mx(root*2+1,s,e,mid+1,te));
}
int reval(int year)//获得年份在线段树数组上的位置 
{
    if (year<b[1].y)return 0;
    if (year>b[n].y)return len+1;
    int l=1,r=n,mid;
    while (l<=r)//二分，注意边界值，mid落在不大于year的位置 
    {
        mid=(l+r)>>1;
        if (b[mid].y<year)l=mid+1;
        else r=mid-1;
    }
    if (b[l].y!=year)return b[l].pt-1;
    return b[l].pt;//如果没有这个年份，就指向空年份 
}
int main()
{
    scanf("%d",&n);
    int year,val;
    for (int i=1;i<=n;i++)//处理年份与位置的转化 
    {
        scanf("%d %d",&year,&val);
        if (fyr==low||year-fyr==1)fyr=year,a[++len]=val;
        else fyr=year,a[++len]=low,a[++len]=val;//不相邻的年份，无论年份之间相隔多少，全部离散化为2 
        b[i].y=year;
        b[i].pt=len;
    }
    a[len+1]=a[0]=low;
    build(1,1,len);
    scanf("%d",&m);
    int x,y,u,v;
    for (int i=1;i<=m;i++)
    {
        scanf("%d %d",&x,&y);
        u=reval(x);
        v=reval(y);
        if (v-u==1)//我不知道有没有这样的坑数据，X,Y相邻…… 
        {
            if (a[u]==low||a[v]==low)printf("maybe\n");
            else if (a[u]>=a[v])printf("true\n");
            else printf("false\n");
        }
        else if ((a[u]!=low&&a[u]<=mx(1,u+1,v-1,1,len))||(a[u]!=low&&a[u]<a[v])||(a[v]!=low&&mx(1,u+1,v-1,1,len)>=a[v]))printf("false\n");//判断false的情况，注意a[u,v]!=0，否则会WA得很惨 
        else if (a[u]==low||a[v]==low||mn(1,u+1,v-1,1,len)==low)printf("maybe\n");//判断可能的情况 
        else printf("true\n");
    }
}
```

---

## 作者：ADay (赞：9)

[更好的阅读体验](https://aday526.github.io/%E9%A2%98%E8%A7%A3%20P2471%20%E3%80%90%5BSCOI2007%5D%E9%99%8D%E9%9B%A8%E9%87%8F%E3%80%91/)

貌似没有人用分块维护最大值诶qwq

那我来发题解吧...

首先说一下~~其他题解的大佬讲过无数次的~~判断条件：

我们设两个年份分别为$px$和$py$，$(px,py)$中降雨量的最大值$maxget$，以及它们在已知年份中的排名$p_{px}和p_{py}$（用map实现），若不存在则为$0$  

**[**注：下面的每一条判断条件基于之前所有的错误条件**]**

#### ·$py$不确定时

- 若$px$也不确定，则无法判断$px,py$的大小，显然为maybe
- 若$px$的降雨量$\le maxget$，则$maxget$的年份才符合题意，是false
- 若以上都不满足，我们没法确定关系，为maybe

#### ·$px$也确定时

- 若$px的降雨量\le py的降雨量$，则显然为false
- 若$maxget\ge py的降雨量$，则$py$不是$px$后的最多，为false
- 若$py-px=p_{py}-p_{px}$，它等价于**px~py间的年份都是已知的**，为true(啊终于有个true了awa
- 若以上都不满足，我们没法确定关系，为maybe

#### ·其他，即$py确定px不确定$

- 若$py的降雨量\le maxget$，又因为$maxget$的年份比$py$出现的早，为false
- 若以上都不满足，我们没法确定关系，为maybe

代码如下

```cpp
px=read();py=read();
if(px>=py)False
rg int maxget=getmax(px+1,py-1);
if(!p[py])
{
    if(!p[px])Maybe
    if(r[p[px]]<=maxget)False
    Maybe
}
if(p[px])
{

    if(r[p[px]]<r[p[py]])False
    if(maxget>=r[p[py]])False
    if(py-px==p[py]-p[px])True
    Maybe
}
if(r[p[py]]<=maxget)False
Maybe
```



### 那么，怎么求$maxget$呢？

我选择用分块求(~~因为分块我最熟悉~~因为分块最好理解)，显然要把$r$数组（即降雨量数组）分成$\sqrt n$个块，记为$num$，而用$bl_i$记录$y_i$所属的块编号，用$mx_i$记录第$i$块的最大值，用一个map：$p_i$记录$y_i$的$i$。这些在输入时可以一起解决：

```cpp
for(rg int i=1;i<=n;i++)
{
    y[i]=read();
    r[i]=read();
    p[y[i]]=i;
    bl[i]=(i-1)/num+1;
    mx[bl[i]]=max(mx[bl[i]],r[i]);
}
```

那么求$[l,r]$间的最大值，枚举三种情况

- 左边不完整的块，可以暴力比较，得到最大值
- 右边不完整的块，依然暴力比较，得到最大值
- 中间完整的块，比较$mx_i$即可，因为$mx_i$是此块最大

但是要注意，若$l或r$是不确定的年份，我们二分查找范围内最近确定的年份代替它即可

每次查询$\mathcal O(\sqrt n)$

代码:

```cpp
int getmax(int ll,int rr)
{
	if(ll>rr)return -1;//显然不存在
    rg int res=-1;
    //二分
    if(!p[ll])
    {
    	int pos=lower_bound(y+1,y+n+1,ll)-y;
    	if(pos<1||pos>n)ll=1e9+5;
        else ll=y[pos];
    }
    if(!p[rr])
    {
    	int pos=upper_bound(y+1,y+n+1,rr)-y-1;
    	if(pos<1||pos>n)rr=-1e9-5;
        else rr=y[pos];
    }
    if(ll>rr)return -1;//显然不存在
    for(rg int i=ll;i<=rr&&i<=y[min(bl[p[ll]]*num,n)];i=y[p[i]+1])//左边不完整的块
    {
    	res=max(res,r[p[i]]);
    	if(p[i]==n)break;
    }
    if(bl[p[ll]]!=bl[p[rr]])
        for(rg int i=y[min((bl[p[rr]]-1)*num+1,n)];i<=rr;i=y[p[i]+1])//右边不完整的块
        {
            res=max(res,r[p[i]]);
            if(p[i]==n)break;
        }
    for(rg int i=bl[p[ll]]+1;i<bl[p[rr]];i++)
        res=max(res,mx[i]);//中间完整的块
    return res;
}
//对了，若不存在返回-1是因为那样不会影响下面的判断
```

总复杂度$\mathcal O(m\sqrt n)$,本来应该能过，但map常数巨大，我们可以使用`unordered_map`，要`c++11`，再吸氧快到飞起~



---

## 作者：45dino (赞：7)

一道倍增和模拟的合并题。

如果没有"maybe"这个选项，就可以用倍增完成。

但现在有"maybe"，其实只需要特判以下情况
1. 该年没有提到，即不知道起始年或终止年的降雨量。
1. 离散化之后两个**下标差**不等于**年份差**（即不连续）

针对第二种情况，使用以下样例
```
6
1 100
2 200
4 300
6 400
7 500
8 600
2
1 4
6 7
```
如果把离散化后的情况画出来，就是这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/881ua396.png)

1和4的年份差是3，但下标差是2，所以不连续。

6和7的年份差是1，下标差也是1，符合要求。

注意：特判要在连续的基础上，所以先要判断是否连续，即是不是"false"。

喜闻乐见的代码：
```
#include<bits/stdc++.h>
#define ff {cout<<"false"<<endl;continue;}
#define mm {cout<<"maybe"<<endl;continue;}
using namespace std;
long long year[50001],rain[50001],mx[50001][17],n,q;
int main()
{
    scanf("%d",&n);
    for(long long i=1;i<=n;i++)
    {
        cin>>year[i]>>rain[i];
        mx[i][0]=rain[i];
    }
    for(long long i=0;i<16;i++)
        for(long long l=1;l+(1<<(i+1))-1<=n;l++)
            mx[l][i+1]=max(mx[l][i],mx[l+(1<<i)][i]);
    scanf("%d",&q);
    for(long long i=1;i<=q;i++)
    {
        long long x,y;
        cin>>x>>y;
        if(x>=y)
            ff
        bool a=0,b=0;
        long long xx=lower_bound(year+1,year+n+1,x)-year;
        long long yy=lower_bound(year+1,year+n+1,y)-year;
        if(year[xx]==x)
            a=1;
        if(year[yy]==y)
            b=1;
        if(a==0)
            xx--;
        long long k=log2(yy-xx-1);
        long long ans=0;
        if(xx+1<=yy-1)
            ans=max(mx[xx+1][k],mx[yy-(1<<k)][k]);
        if(a&&ans>=rain[xx])
            ff
        if(b&&ans>=rain[yy])
            ff
        if(a&&b&&rain[xx]<rain[yy])
            ff
        if(a==0||b==0)
        {
            mm
        }
        if(year[yy]-year[xx]!=yy-xx)
        {
            mm
        }
             
        cout<<"true"<<endl;
    }
    return 0;
}
```


---

## 作者：木木！ (赞：7)

看到大多都是线段树或者`st`表的……这里贴一个单调队列的题解。

~~可持久化单调队列？你值得拥有！~~

首先，在单调队列（队列内节点不增，即非严格递减）里面处理一个询问十分简单。根据右端点的位置和是否已知，只需要对左端点进行分类讨论就可以了。依据单调队列的性质，可以做得非常好。

但是我们需要知道左端点在单调队列里的位置。由于我们按照年份顺序插入，可以直接二分。但是我嫌麻烦，就用了一个`map`来记录年份和单调队列里的位置的对应关系。当然可以离线排序左端点$\Theta(n+m)$挂链预处理，但是由于离线排序这一步已经有一只$\log$了，就没有兴趣去做（可以用基排做到$\Theta(n)$排序qwq）

具体做法是，先离线排序右端点，然后边单调队列边处理。依照已知条目的年份依次插入单调队列，然后在$y_{i+1}>query_r$的时候进行处理。分类讨论（也可略过直接看代码）：

+ $y_i==query_r$，即右端点已知
  + 左端点已知，为单调队列里的第$j$项
    + `j==i-1||j==i`，如果这两项连续，则返回$true$，否则返回$maybe$
    + 其他情况，由于单调队列内其他值大于右端点，返回$false$
  + 左端点已知，已经出队
    + 由于其已经出队，一定在左端点和右端点之间有一个点大于左端点，返回$false$
  + 左端点未知
    + 如果左端点的年份比单调队列里的前一项大，则返回$maybe$
    + 否则，由于单调队列上一项一定大于等于这一项，左端点的年份必须大于单调队列上一项的年份，这种情况下返回$maybe$，否则返回$true$。
+ 右端点未知
  + 左端点已知，已经出队
    + 返回$false$
  + 左端点已知，为单调队列中的第$j$项
    + 如果第$j+1$项的降雨量等于第$j$项的降雨量，返回$false$，否则只要使右端点的降雨量等于左端点的降雨量，返回$maybe$
  + 左端点未知
    + 肯定为$maybe$

时间复杂度为$\Theta(m\log m+n+m\log n)$，总体时间复杂度为$\Theta(n\log n)$级别。如果加上基排和左端点预处理可以做到$\Theta(n+m)$（口糊，可能算错qwq）。

如果本题强制在线的话，可以使用可持久化单调队列。单调队列十分容易可持久化，并且空间消耗为$\Theta(n)$。

附AC代码：

```cpp
#include <map>
#include <cstdio>
#include <algorithm>
using namespace std;

int yi[50005];
int ri[50005];

struct query
{
	int id;
	int li;
	int ri;
	int ans;
};

query qi[10005];

bool cmp(query a,query b)
{
	return a.ri<b.ri;
}

bool pmc(query a,query b)
{
	return a.id<b.id;
}

int q[50005];

int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1; i<=n; ++i)
	{
		scanf("%d%d",yi+i,ri+i);
	}
	
	map<int,int> mmp;
	
	int qn;
	scanf("%d",&qn);
	for(int i=1; i<=qn; ++i)
	{
		scanf("%d%d",&qi[i].li,&qi[i].ri);
		qi[i].id = i;
	}
	
	yi[n+1] = 0x7f7f7f7f;
	sort(qi+1,qi+1+qn,cmp);
	
	int qtop = 1;
	int head = 0;
	int conn = 0; //conn维护连续的段
	for(int i=1; i<=n; ++i)
	{
		while(head && ri[q[head]]<ri[i])
		{
			mmp[yi[q[head]]] = -1;
			--head;
		}
		++head;
		q[head] = i;
		mmp[yi[i]] = head;
		
		if(i==1 || yi[i-1]!=yi[i]-1)
		{
			conn = 0;
		}
		else
		{
			++conn;
		}
		
		while(qi[qtop].ri<yi[i+1] && qtop<=qn)
		{
			if(qi[qtop].ri==yi[i])
			{
				int stt = mmp[qi[qtop].li];
				if(stt==-1)
				{
					qi[qtop].ans = -1;
				}
				else if(stt==head || (head!=1 && stt==head-1))
				{
					qi[qtop].ans = (conn>=qi[qtop].ri-qi[qtop].li);
				}
				else if(stt)
				{
					qi[qtop].ans = -1;
				}
				else
				{
					qi[qtop].ans = -(head!=1 && yi[q[head-1]]>qi[qtop].li); //略有点骚
				}
			}
			else
			{
				int stt = mmp[qi[qtop].li];
				if(stt==-1)
				{
					qi[qtop].ans = -1;
				}
				else if(!stt)
				{
					qi[qtop].ans = 0;
				}
				else
				{
					qi[qtop].ans = -(stt<head && ri[q[stt]]==ri[q[stt+1]]);
				}
			}
			++qtop;
		}
	}
	
	sort(qi+1,qi+1+qn,pmc);
	
	for(int i=1; i<=qn; ++i)
	{
		printf("%s\n",qi[i].ans==-1?"false":(qi[i].ans?"true":"maybe"));
	}
}
```

---

## 作者：天命之路 (赞：6)

前言：

首先，这篇题解是利用平衡树+线段树来进行操作，虽然题解区中有许多平衡树题解，但本蒟蒻的题解有较大拓展。

首先，先说一下解题思路：
1. 建立一个序列 $liang[N]$ 保存降雨量，建立一个平衡树 she 维护年份与序列下标的对应关系，建立一个线段树维护 liang 序列的区间最大值
1. 当输入询问年份 $\color{blue}{t1,t2}$ 时,利用平衡树映射到序列中的下标 $\color{blue}{x1,x2}$ ,再分情况讨论。
	+ 当 t1,t2 的降雨量均已知时，
         1. 如果 $liang[x1]<liang[x2]$ 输出 false,下面的不管
         1. 如果 $x2-x1=t2-t1=1$ (即 x1,x2 之间没有年份）输出 true (x1,x2 本身的比较在上面已考虑），下面的不管
         1. 如果 $\max[x1+1,x2-1] \ge liang[x2]$ (最大值可用线段树维护）, 输出 false，下面的不管
         1. 如果 $x1+1=x2$ 且 $t1+1 \ne t2$ ，输出 maybe(即 t1,t2 间有多个年份，但这中间全部未知）（降雨量本身的比较在上面已考虑）
         1. 如果 $t2-t1==x2-x1$(即中间所有年份全部已知），输出 true(降雨量的比较已在上面考虑）
         
         
         这里贴个图，方便理解：
         ![](https://cdn.luogu.com.cn/upload/image_hosting/exc3gbqy.png?x-oss-process=image/resize,m_lfit,h_510,w_675)
     + 当 t1 降雨量未知，t2 降雨量已知时
     	  1. 找出 t1 在年份中的后继（即严格大于 t1 的最小数）（可用平衡树实现），令其为 $Suf(t1)$，并映射出其在序列中的位置 h1。
          1. 若 $h1=x2$ ,(即 $t1$ 和 $t2-1$ 间的年份全部未知，$(t1,t2)$ 的区间最大值可取任意值，$liang[x1]$ 也可取任意值，故输出 maybe
          1. 若 $\max(h1,x2-1) \lt liang[x2]$ (因为 h1 的年份比 t1 大，故不用加1）,输出 maybe(因为起始年降雨量未知）
          1. 若以上都不满足，输出 false
          
          贴个图，把第2、3种情况解释一下：
          ![](https://cdn.luogu.com.cn/upload/image_hosting/1fs9gnj6.png?x-oss-process=image/resize,m_lfit,h_510,w_675)
      + 当 t1 降雨量已知,t2 降雨量未知
          1.这时情况比上一种复杂些，先找出 t2 在年份中的前驱 ，令其为 $pre(t2)$,在序列中的位置为 h2
          1.若 $x1=h2$,输出 maybe (因为 t1+1 至 t2 的年份全部未知)
          1.这一步需要一定的推导，我们知道，$liang[x2] \le liang[x1],\max(x1+1,h2) \lt liang[x2]$(降雨量的两个性质），所以 $\max(x1+1,h2) \lt liang[x1]$,如果不满足，即 $\max(x1+1,h2) \ge liang[x1]$，输出 false
          1.以上都不满足，输出 maybe
     + 当 t1,t2 降雨量都未知时，输出 maybe(他们可以取任意值）
     
~~(所以为啥说这题紫呢？分类讨论都写了十多种情况）~~

看到这里，神犇们就可以去打代码了，不会平衡树的继续往下看（这篇题解就是写给不会平衡树的人的）：

这里介绍一种比较简单的平衡树:Treap ，可以用它来实现映射，找前驱，找后继，插入，删除（虽然对于这道题你可以用二分查找，但我们必须会的更多，如果数据无序且强制在线的话，大部分题解都没饭吃，当然对于这种情况就不能仅仅用下面的思路了）。

首先，我们要了解平衡树的前身，二叉查找树。

它的定义如下：

1. 每个结点都有一个可比较大小的权值
1. 对于每个结点，它的左儿子的权值小于它的权值
1. 对于每个结点，它的右儿子的权值大于它的权值
1. 左右子树分别为二叉查找树

一般来说，对于每个结点，左子树权值的最大值小于该结点权值，右子树权值的最小值大于该结点权值。

他可以实现时间为 O(树高)（n为总结点个数） 的查找，插入，删除，取最小值，取最大值。树高一般为 $log_2n$

~~（这里就不说它怎么实现的了，这并不重要。）~~

但是，我们会发现，在极端情况下（比如这道题），它会退化成一条链，因为所有数据有序，那么每次查找的复杂度将达到 $O(n)$,我们无法承受。

所以，平衡树就是对二叉查找树进行改进，使其既满足二叉查找树性质，又能尽量把树高平均为 $O(log_2n)$的数据结构

接下来开始正式介绍 Treap:

变量声明：
$lson(k),rson(k)$ 是 k 的左、右儿子,$val(k)$ 是 k 的权值，$pos(k)$ 是 k 的优先级

Treap 的改进方法是给每个结点赋予一个优先级（值随机），并使该树权值满足二叉查找树性质时，优先级满足小根堆性质。

我们知道，随机数据有序的概率很小，故我们能把树高控制在 $O(log_2n)$

那我们怎么维护这两个性质呢？要借助旋转操作：

回忆我们维护二叉小根堆时，如果碰到不符合性质的父子，我们怎么办？
```cpp
swap(h[now],h[now/2]);
```
是的，我们把两个节点交换，但这样做会破坏二叉查找树性质（以下简称 BST 性质），我们该怎么办呢？

我们依旧考虑交换结点 k 和 $fa[k]$ 的父子关系，但是左右要改变（即如果 k 是 $fa[k]$ 的右儿子，则交换后,$fa[k]$ 就是 k 的左儿子），这就要通过旋转了。

旋转分为两种，左旋（Zag）和右旋(Zig)。先介绍右旋。

若右旋以 k 为根子树，那么 k 的左子结点是子树的新根，k 将成为新根的右子结点。

大概，像这样：
![](https://cdn.luogu.com.cn/upload/image_hosting/bd18rvan.png?x-oss-process=image/resize,m_lfit,h_510,w_675)

可以证明，右旋后依然满足 BST 性质：

因为 $val(k)\gt val(rson(lson(k))) \gt val(lson(k))$(BST 性质），所以 $val(k) \gt lson(k)$，红边上的两点满足性质，同理，蓝边上的两点满足性质。

代码实现如下：
```cpp
struct node{
	int lc,rc,pos,val,cnt;
}t[N];
#define lc(x) t[x].lc
#define rc(x) t[x].rc
#define p(x) t[x].pos
#define v(x) t[x].vis
#define c(x) t[x].cnt  //加一个属性，记录重复结点的个数
void zig(int &k)
{
	int y=lc(k);   //子树新根
    lc(k)=rc(y);   // 对上图蓝边的操作
    rc(y)=k;       //把 k 变为新根的右子节点
    k=y;           //因为加了引用，所以旋转完后 k 会指向子树的新根
}
```
看到这里，有人就会问了，旋转完后你不应该让 k 的父节点的儿子变为 y 吗？其实，因为我们加了引用 &,所以k 的寄存器与平衡树的某个节点的儿子（注意不是某个节点！根结点除外）（或根结点）相同，故改变 k 的值，也就改变了 k 的父亲的儿子的值。（这里将在接下来得到体现，还没看懂的不急）

左旋（Zag）呢？把上图的箭头反过来就好了，这里不再赘述，上代码：
```cpp
void zag(int &k)
{
	int y=rc(k);
    rc(k)=lc(y);
    lc(y)=k;
    k=y;
}
```
接下来讲插入：

一般来说，我们通过结点权值的大小关系来找到一个适合插入的位置，将新节点插入，但插入时随机产生的优先级可能会破坏堆序。所以在回溯时要进行适当的旋转。

比如说，某个结点和它的左子结点的优先级破坏了堆序，我们就要把它的左子结点转上去，把那个结点转下来，还记得这是什么操作吗？对，就是右旋以那个结点为根的子树（不理解的可以返回去看上面的图）。

反之，如果说某个节点和它的右子节点破坏堆序，那就左旋以该结点为根的子树。

关于如何查找位置.....如果目前结点值大于当前结点值，就到左子树找（往小了找），反之到右子树去找（往大了找）。

上代码吧！
```cpp
void insert(int &k,const int vi) //k 是目前结点,vi 是待插入权值
	            				 //注意到这里也加了引用
{
	if(!k) //已找到合适位置
    {
    	k=++cnt;
        v(k)=vi; //所有 define 同旋转时的代码
        p(k)=rand();
        lc(x)=rc(x)=0;
        c(k)=1;
     }
     if(v(k)==key)++c(k);
     if(v(k)>vi)
     {
     	insert(lc(k),vi);  //递归在左子树中寻找
                           //如果在这个递归中发生了修改，那么相应地，lc(k) 的值也会改变（加了引用）
        if(p(k)>p(lc(k))) zig(k);  //相对应地，这一层也可能是另外一层递归而来，所以在这里改变 k ，就是改变了 lson/rson(father(k))
                          //因此，在旋转函数中就不用另外处理父节点了(貌似指针版的更好理解）
      }
      else
      {
      		insert(rc(k),vi);
            if(p(k)>p(rc(k))) zag(k);
      }
}
```

在平衡树里删除一个结点，又要怎么做呢？（虽然这道题中并未涉及）

类似于插入，我们要通过结点权值的大小关系找到那个带删除的结点，如果这个结点只有一个儿子，或没有儿子，那就让它的儿子来代替它，像这样：
![](https://cdn.luogu.com.cn/upload/image_hosting/j7az967x.png?x-oss-process=image/resize,m_lfit,h_510,w_675)

如果有两个儿子，Treap 采取的策略是通过旋转，让其变为能直接删除的结点。

怎么旋转呢？

在该结点的两个儿子中，如果左儿子的优先级较小，则右旋该结点（把左儿子旋上来），反之左旋该结点，如此递归，直到该结点可以被直接删除。

这样就有人会问了，不会破坏堆序吗？其实并不会。

如果旋转次数为偶数，那么该结点经过的地方可被视为有限个下图模型的结合。
![](https://cdn.luogu.com.cn/upload/image_hosting/8a8duikb.png?x-oss-process=image/resize,m_lfit,h_510,w_675)

如果旋转次数为奇数，那么该结点经过的地方可被视为有限个下图模型的结合加上一个三角（即一个有3个节点，高为2的子树），依旧满足堆序。

BST性质就不用说了，转成什么样都是满足的。

上代码：
```cpp
void Delete(int &k,const int vi)
{
	if(v(k)==vi)
    {
    	if(c(k)==1)
        {
        if(!lc(k)||!rc(k)) k=lc(k)+rc(k);  //相当于 lc(k)?lc(k):rc(k);
        else if(p(lc(k))<p(rc(k)))    //不能直接删除时，旋转调整     zig(k),Delete(k,vi);
        else zag(k),Delete(k,vi);
        }
        else --c(k);
        return;
     }
     if(v(k)>vi) Delete(lc(k),vi);
     else Delete(rc(k),vi);
}
```

查找前驱和后继：

前驱：在序列中小于某个数的数中的最大值

后继：在序列中大于某个数的数中的最小值

首先，我们要明确，前驱并不等于这个数本身，所以我们走到的结点等于这个数时，不要记录答案。

对于走到的每个结点，如果该结点的权值严格小于要查找的数，就往右子树走（往大了找），否则往左子树走。

代码如下：
```
int querypre(const int vi)
{
	int x=rt,res=0;  //rt是个变量，初值为0，储存根结点的编号，insert 和 delete 的递归起始处也为 rt
    while(x)
    {
    if(v(x)<vi) res=v(x),x=rc(x);
    else x=lc(x);
    }
}
```
查找后继同理。

（每道题对前驱和后继的定义不同，如果包括本身，查找~~二分~~时加个等号就行）

其实，平衡树还可以查找元素的排名和某个排名上的元素，这需要维护以每个结点为根的子树中有多少个节点，笔者不再赘述，大家自己琢磨。

上这道题的 AC code 吧！
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=50001;
int n,m;
int liang[N],top=0; //保存降雨量，下标是映射出的值，不是年份
struct Treap{   //平衡树讲过了，不讲
	struct node{
		int lc,rc,pos, vis,vis2;  //其实用平衡树映射并不难，一个节点上弄俩权值就好
	}t[N];
	int jie,rt; //要用一个变量保存根，即 rt，因为引用有可能会改变根编号
	#define lc(x) t[x].lc
	#define rc(x) t[x].rc
	#define p(x) t[x].pos
	#define v(x) t[x].vis
	#define v2(x) t[x].vis2
	Treap(int val=0)
	{
		for(int x=1;x<=n;x++) lc(x)=rc(x)=p(x)=v(x)=0,v2(x)=val;
		
		jie=rt=0;
	}
	inline void zig(int &k)
	{
		int y=lc(k);
		 lc(k)=rc(y);
		 rc(y)=k;
		 k=y;
	}
	inline void zag(int &k)
	{
		int y=rc(k);
		rc(k)=lc(y);
		lc(y)=k;
		k=y;
	}
	inline void insert(int &k,const int vi,const int vi2);
	inline int find(const int vi) //查找自己理解
	{
		int x=rt;
		while(x)
		{
			if(v(x)>vi) x=lc(x);
			else if(v(x)<vi) x=rc(x);
			else if(v(x)==vi) return v2(x);
		}
		return -1;
	}
	int operator [](const int vi)   //重载运算符，作用相当于查找
	{
		return find(vi);
	}
	inline void print(const int k);
	inline int querypre(const int k)
	{
		int x=rt,res=0;
		while(x)
		{
			if(v(x)<k) res=v(x),x=rc(x);
			else x=lc(x);
		}
		return res;
	}
	inline int querysuf(const int k)
	{
		int x=rt,res=0;
		while(x)
		{
			if(v(x)>k) res=v(x),x=lc(x);
			else x=rc(x);
		}
		return res;
	}
};
inline void Treap::insert(int &k,const int vi,const int vi2)
{
	if(!k)
	{
		k=++jie;
		v(k)=vi;p(k)=rand();lc(k)=rc(k)=0;v2(k)=vi2; 
		return;
	}
	 if(v(k)>vi)
	{
		insert(lc(k),vi,vi2);
		if(p(k)>p(lc(k))) zig(k);
	}
	else if(v(k)<vi)
	{
		insert(rc(k),vi,vi2);
		if(p(k)>p(rc(k))) zag(k);
	}
}
inline void Treap::print(const int k)
{
	if(!k) return;
	print(lc(k));
	printf("%d %d\n",v(k),v2(k));
	print(rc(k));
}
Treap she(0);
inline void clear()  //读入
{
	scanf("%d",&n);
	int last=0;
	for(int i=1;i<=n;i++)
	{
		int t1,t2;
		scanf("%d%d",&t1,&t2);
		liang[++top]=t2;
		she.insert(she.rt,t1,top); //用平衡树映射
		
	}
}
struct line_tree{   //线段树常规操作，不讲
	int Max[N<<2];
	int *array; 
	
	line_tree(int *t)
	{
		array=t;
		memset(Max,128,sizeof Max);
}
	inline void build(int k,int l,int r)
	{
		if(l==r)
		{
			Max[k]=array[l];
			return;
		}
		int mid=l+r>>1;
		build(k<<1,l,mid);
		build(k<<1|1,mid+1,r);
		Max[k]=max(Max[k<<1],Max[k<<1|1]);
	}
	inline int query(int k,int l,int r,int x,int y)
	{
		if(l>y||r<x) return INT_MIN;
		if(x<=l&&r<=y) return Max[k];
		int mid=l+r>>1;
		return max(query(k<<1,l,mid,x,y),query(k<<1|1,mid+1,r,x,y));
	}
	inline void print(int k,int l,int r);
};
inline void line_tree::print(int k,int l,int r)   //Debug 用的
{
	if(l==r)
	{
		return;
	}
	int mid=l+r>>1;
	print(k<<1,l,mid);
	printf("%d %d %d\n",l,mid,Max[k<<1]);
	printf("%d %d %d\n",l,r,Max[k]);
	printf("%d %d %d\n",mid+1,r,Max[k<<1|1]);
	print(k<<1|1,mid+1,r);
}
inline void work()
{
	line_tree anss(liang); //线段树 anss 维护降雨量   
	anss.build(1,1,top);
	scanf("%d",&m);
	for(int i=1;i<=m;i++)
	{
		int t1,t2;
		scanf("%d%d",&t1,&t2);
		int x1=she[t1],x2=she[t2];  //找不到就返回 -1
		if(x1==-1&&x2==-1)     //判定（我太南了）
		{
			printf("maybe\n");continue;
		}
		else if(x1==-1&&x2!=-1)
		{
			int h1=she[she.querysuf(t1)];
			if(anss.query(1,1,top,h1,x2-1)<liang[x2]||she[she.querysuf(t1)]==x2) printf("maybe\n");
			else printf("false\n");
			continue;
		}
		else if(x1!=-1&&x2==-1)
		{
			int h2=she[she.querypre(t2)];
			if(x1+1==she[she.querysuf(t2)]) printf("maybe\n");
			else
			if(anss.query(1,1,top,x1+1,h2)>=liang[x1]) printf("false\n");
			else printf("maybe\n");
			continue;
		}
		else{

			if(liang[x1]<liang[x2]) {puts("false");continue;}
			if(x1+1==x2&&t1+1==t2) {puts("true");continue;}
			if(anss.query(1,1,top,x1+1,x2-1)>=liang[x2]) {puts("false");continue;}
			if(x1+1==x2&&t1+1!=t2){puts("maybe");continue;}
			if(t1-t2==x1-x2){puts("true");continue;}
			puts("maybe");
			continue;
		}
	
	}

}
int main()   //主函数莫名简单
{ 
	clear();
	work();
	return 0;
}
```
其实，平衡树妙就妙在它和二分的性质完美契合（用复杂度较低的判断排除半数的可能值）~~~

这是我呕心沥血3天的题解呀！只要你们能看进去我就不亏了。

---

## 作者：FC_Viiiiictor_K (赞：5)

翻了一圈没看见动态开点线段树，于是给动态开点线段树信仰玩家贡献一篇题解

众所周知动态开点线段树可以维护更广阔的值域，但是年份有可能有负数，于是我们直接暴力给每一个年份加一个大小为1e9+9的常量shift，把负数平移成正数，然后把值域开两倍；

然后就是维护区间最大值、最小值、连续性，各种特判即可，其他题解中已经讲得很清楚了。

需要注意的是，在我的写法中，询问的x和y是反的，而且区间查询涉及到\[x+1,y-1\]这个区间，所以还要多特判一下x紧挨着y的情况，防止区间查询出锅。

```cpp
#define INL inline
#define REG register
#define M (int)(((long long)l+r)>>1)
#define LS tre[pos].lson
#define RS tre[pos].rson//动态开点线段树需要的宏定义
#include <cstdio>
#include <iostream>
using namespace std;
INL int read(){
    REG int sum=0,sign=1;
    REG char tmp=getchar();
    while(tmp<'0'||tmp>'9'){
        if(tmp=='-'){
            sign=-1;
        }
        tmp=getchar();
    }
    while(tmp>='0'&&tmp<='9'){
        sum=(sum<<1)+(sum<<3)+(tmp-'0');
        tmp=getchar();
    }
    return sum*sign;
}//快读
const int maxn=114514,shift=1e9+9/*就是这个常量把负数年份变成了正数*/;
int n,m;
struct node{
    int lson,rson,maxv,minv;//左儿子，右儿子，区间最大、最小
    bool sure;//区间连续性，连续为1，不连续为0
}tre[maxn<<6];
int cntr=2;
INL void insert(REG int tar,REG int x){
    REG int l=1,r=shift<<1,pos=1;
    while(l!=r){//普通线段树单点操作的非递归写法
        //cout<<l<<' '<<r<<endl;
        tre[pos].maxv=max<int>(tre[pos].maxv,x);
        tre[pos].minv=min<int>(tre[pos].minv,x);
        tre[pos].sure=1;
        if(tar<=M){
            if(!LS){
                LS=cntr++;//动态开点
            }
            r=M;
            tre[pos].sure&=tre[RS].sure;//我写题解的时候才发现我不确定这样维护区间连续性是不是对的，反正是过了，大家老老实实的递归写上推就好
            pos=LS;
        }
        else{
            if(!RS){
                RS=cntr++;//还是动态开点
            }
            l=M+1;
            tre[pos].sure&=tre[LS].sure;
            pos=RS;
        }
    }
    tre[pos].maxv=tre[pos].minv=x;
    tre[pos].sure=1;
}
INL int query(REG int tar){//单点查询值
    REG int l=1,r=shift<<1,pos=1;
    while(l!=r){
        if(tar<=M){
            r=M;
            pos=LS;
        }
        else{
            l=M+1;
            pos=RS;
        }
    }
    return tre[pos].maxv;
}
INL bool check(REG int al,REG int ar,REG int x,REG int l,REG int r,REG int pos){//询问区间最大值是否小于某数
    if(!pos){
        return 1;//不确定的情况默认为可行
    }
    if(al<=l&&ar>=r){
        return tre[pos].maxv<x;
    }
    REG bool able=1;
    if(al<=M){
        able&=check(al,ar,x,l,M,LS);
    }
    if(ar>M){
        able&=check(al,ar,x,M+1,r,RS);
    }
    return able;
}
INL bool rcheck(REG int al,REG int ar,REG int x,REG int l,REG int r,REG int pos){//询问区间最小值是否大于某数
    if(!pos){
        return 1;//同上个函数
    }
    if(al<=l&&ar>=r){
        return tre[pos].minv>x;
    }
    REG bool able=1;
    if(al<=M){
        able&=check(al,ar,x,l,M,LS);
    }
    if(ar>M){
        able&=check(al,ar,x,M+1,r,RS);
    }
    return able;
}

INL bool getsure(REG int al,REG int ar,REG int l,REG int r,REG int pos){//查询区间连续性
    if(al<=l&&ar>=r){
        return tre[pos].sure;
    }
    REG bool ans=1;
    if(al<=M){
        ans&=getsure(al,ar,l,M,LS);
    }
    if(ar>M){
        ans&=getsure(al,ar,M+1,r,RS);
    }
    return ans;
}
int main(){
    freopen("SCOI2007D1T2.in","r",stdin);
    n=read();
    for(REG int i=0;i<n;i++){
        REG int key=read()+shift/*把可能为负的年份移到必定正数*/,val=read();
        insert(key,val);
    }
    m=read();
    for(REG int i=0;i<m;i++){
        REG int x=read()+shift,y=read()+shift;
        REG int linex=query(x),liney=query(y);
        if(x>=y){
            printf("false\n");
            continue;
        }
        else if(x==y-1){//关于x紧挨y的特判
            if(linex&&liney){
                if(linex>=liney){
                    printf("true\n");
                }
                else{
                    printf("false\n");
                }
            }
            else{
                printf("maybe\n");
            }
            continue;
        }
        if(linex&&liney){//往下就是各种特判了，写的贼乱
            if(linex>=liney&&check(x+1,y-1,liney,1,shift<<1,1)){
                if(getsure(x+1,y-1,1,shift<<1,1)){
                    printf("true\n");
                }
                else{
                    printf("maybe\n");
                }
            }
            else{
                printf("false\n");
            }
        }
        else if(linex){
            if(rcheck(x+1,y-1,linex,1,shift<<1,1)){
                printf("maybe\n");
            }
            else{
                printf("false\n");
            }
        }
        else if(liney){
            if(check(x+1,y-1,liney,1,shift<<1,1)){
                printf("maybe\n");
            }
            else{
                printf("false\n");
            }
        }
        else{
            printf("maybe\n");
        }
    }
    return 0;
}
```


---

## 作者：TheLostWeak (赞：5)

[在博客查看](https://www.cnblogs.com/chenxiaoran666/p/BZOJ1067.html)

**大致题意：**请你判断“$x$年是自$y$年以来降雨量最多的”这句话的真假。

### 离散化/$lower\_bound$

首先，考虑到年份的范围非常大，便可以离散化。

而我比较懒，反正题目中说了年份是递增的，因此我直接用了$C++$自带的$lower\_bound$。

### $RMQ$

这题还需要使用的一个算法便是$RMQ$。

这应该是一个比较基础的算法吧，这里就不多加介绍了。

至于哪里需要使用，后面你就知道了。

### 分类讨论

考虑如果是$false$，则无非有$3$种情况：

1. 左边界的降雨量已知且小于等于左右边界间的最大降雨量。
2. 右边界的降雨量已知且小于等于左右边界间的最大降雨量。
3. 左、右边界降雨量皆已知且左边界降雨量小于右边界降雨量。

这里要求区间最大降雨量，就需要使用前面提到过的$RMQ$了。

注意$RMQ$查询的区间边界的设定。假设$dx,dy$分别为$x,y$离散化后的值，则我们求最大值时不能把左右边界算在内。

对于$dx$，若其恰好在左边界上，则查询时须加$1$，否则其位置必大于左边界，无需加$1$。

对于$dy$，若其恰好在有边界上，则查询时须减$1$，否则其位置必大于右边界，同需减$1$。可得结论，$dy$必减$1$。

在确保不是$false$的前提下，考虑如果是$Maybe$，有$2$种情况：

1. 左边界降雨量未知或右边界降雨量未知。
2. 左右边界间存在降雨量未知。

其中第$2$种情况我们可以通过比较左右边界离散化前后的差值是否一样，从而进行判断。

如果不是$false$也不是$maybe$，则自然就是$true$。

### 代码

```cpp
#include<bits/stdc++.h>
#define Tp template<typename Ty>
#define Ts template<typename Ty,typename... Ar>
#define Reg register
#define RI Reg int
#define Con const
#define CI Con int&
#define I inline
#define W while
#define N 50000
#define max(x,y) ((x)>(y)?(x):(y))
#define GetPos(x) (lower_bound(s+1,s+n+1,data(x))-s)
#define Maybe {puts("maybe");continue;}
#define False {puts("false");continue;}
#define True {puts("true");continue;}
using namespace std;
int n;
struct data 
{
    int Year,Rain;I data(CI x=0,CI y=0):Year(x),Rain(y){}
    I bool operator < (Con data& t) const {return Year^t.Year?Year<t.Year:Rain<t.Rain;}
}s[N+5];
class FastIO
{
    private:
        #define FS 100000
        #define tc() (A==B&&(B=(A=FI)+fread(FI,1,FS,stdin),A==B)?EOF:*A++)
        #define tn (x<<3)+(x<<1)
        #define D isdigit(c=tc())
        int f;char c,*A,*B,FI[FS];
    public:
        I FastIO() {A=B=FI;}
        Tp I void read(Ty& x) {x=0,f=1;W(!D) f=c^'-'?1:-1;W(x=tn+(c&15),D);x*=f;}
        Ts I void read(Ty& x,Ar&... y) {read(x),read(y...);}
}F;
class RMQ//RMQ求区间最值
{
    private:
        static const int SZ=N,Log=16;int Log2[SZ+5],Max[SZ+5][Log+5];
    public:
        I void Init(CI n,data* s)//初始化
        {
            RI i,j;for(i=1;i<=n;++i) Max[i][0]=s[i].Rain;for(i=2;i<=n;++i) Log2[i]=Log2[i>>1]+1;
            for(j=1;(1<<j)<=n;++j) for(i=1;i+(1<<j)<=n;++i) Max[i][j]=max(Max[i][j-1],Max[i+(1<<j-1)][j-1]);
        }
        I int GetMax(CI l,CI r) {if(l>r) return 0;RI k=Log2[r-l+1];return max(Max[l][k],Max[r-(1<<k)+1][k]);}//区间求Max
}R;
int main()
{
    RI Qtot,i,x,y,dx,dy,dv;for(F.read(n),i=1;i<=n;++i) F.read(s[i].Year,s[i].Rain);//读入数据
    R.Init(n,s),F.read(Qtot);W(Qtot--)//处理询问
    {
        F.read(x,y),dx=GetPos(x),dy=GetPos(y),dv=R.GetMax(s[dx].Year^x?dx:dx+1,dy-1);//读入x,y，dx,dy表示离散化后的位置，dv表示左右边界间的最大降雨量
        if(!(s[dx].Year^x)&&s[dx].Rain<=dv) False;if(!(s[dy].Year^y)&&s[dy].Rain<=dv) False;//判断左、右边界的降雨量已知且小于等于左右边界间的最大降雨量的情况
        if(!(s[dx].Year^x)&&!(s[dy].Year^y)&&s[dx].Rain<s[dy].Rain) False;//判断左、右边界降雨量皆已知且左边界降雨量小于右边界降雨量的情况
        if(s[dx].Year^x||s[dy].Year^y||(y-x)^(dy-dx)) Maybe;True;//判断左边界降雨量未知或右边界降雨量未知或左右边界间存在降雨量未知的情况
    }return 0;
}
```

---

## 作者：封禁用户 (赞：5)

这题很恶心，需要注意的细节很多。

难怪省选/NOI-难度。

RMQ用ST表维护。

思路其实和楼下差不多，提供AC代码:

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <queue>
#include <set>
#include <map>
#include <vector>
#include <stack>
#include <list>
#define rep(i,m,n) for(int i=m;i<=n;i++)
#define dop(i,m,n) for(int i=m;i>=n;i--)
#define lowbit(x) (x&(-x))
#define ll long long
#define INF 2147483647
#define re register
#define Open(s) freopen(s".in","y",stdin);freopen(s".out","f",stdout);
#define Close fclose(stdin);fclose(stdout);
using namespace std;
inline int read(){
    int s=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
    return s*f;
}
const int maxn=100010;
int Log[maxn],f[maxn][22],ad[maxn],q,ans,n,m,a,b,tmp,num,MAX;
inline int Max(int a,int b){return a>b?a:b;}
inline int Min(int a,int b){return a<b?a:b;}
inline int Getad(int x){return lower_bound(ad+1,ad+n+1,x)-ad;}
inline int QueryMax(int x,int y){
    if(x>y) return -INF;
    int k=Log[y-x+1];
    return Max(f[x][k],f[y-(1<<k)+1][k]);
}
int main(){
    n=read();
    Log[0]=-1;
    rep(i,1,n) ad[i]=read(),f[i][0]=read();
    rep(i,1,n) Log[i]=Log[i/2]+1;
    rep(i,1,20)
       for(int j=1;j+(1<<i)-1<=n;j++)
          f[j][i]=Max(f[j][i-1],f[j+(1<<(i-1))][i-1]);
    m=read();
    while(m--){
      a=read();b=read();
      int x=Getad(a),y=Getad(b);
      bool nl=(x<=n && ad[x]==a), nr=(y<=n && ad[y]==b);
      if(nl){
        if(nr){
          q=QueryMax(x+1,y-1);
          if(f[x][0]<f[y][0]) ans=0;
          else if(q<f[y][0]){
            if(y-x==b-a) ans=1;
            else ans=-1;
          }
          else ans=0;
        }
        else{
          q=QueryMax(x+1,y-1);
          if(q<f[x][0]) ans=-1;
          else ans=0;
        }
      }
      else{
        if(nr){
          q=QueryMax(x,y-1);
          if(q<f[y][0]) ans=-1;
          else ans=0;
        }
        else ans=-1;
      }
      if(ans==1) puts("true");
      else if(ans==-1) puts("maybe");
      else puts("false");
    }
    return 0;
}
```

---

## 作者：LengChu (赞：4)

**解题思路和数组意义参照[xyz32768的题解](https://www.luogu.org/blog/user29936/solution-p2471)**



------------


第一篇题解写的很好了 这里主要讲一下他的思路怎么去实现的问题

~~dalao请自觉无视这篇题解谢谢~~

题解里有这么一句话“先求出从Y年开始往右查找最早能达到降雨量已知的年份编号u”

注意到输入的年份是有序的 也就是说可以二分查找

手打二分查找？太麻烦惹qwq

stl是个好东西

lower_bound(头指针,尾指针,参数) 注意查询的应该是有序的区间

意义就是在两个指针之间的部分进行二分查找 返回指向第一个大于等于x的元素的位置的迭代器

设这个迭代器为it吧 那么查找到的值就是*it

但是我们要查的不是年份 而是年份的编号啊

在有序int数组(元素存放在下标1~n)中查找大于等于x的最小整数的下标：

	v=lower_bound(yea+1,yea+n+1,x)-yea;

v是下标 yea是数组的名字 x是要查询的年份

------------

这道题主要分为三个部分 第一个部分刚才已经说了 第二是查询区间最大值 然后就是细节问题

查询区间最大值 打线段树 代码长度就太长了

这道题是不带修改的 所以可以用st表 就很简单 关于st表的建立 可以去做做模板题

（但是这道题主要的代码长度都是在细节处理啊qwq

具体的解题思路就不说啦 dalao们已经说的很清楚了

就当给dalao的思路补份代码吧

    #include<bits/stdc++.h>
    using namespace std;
    int n,q,val[50010],yea[50010];
    int ma[50010][18];//st表的max数组 
    void prework()//st表 
    {
        for(int i=1;i<=n;i++) ma[i][0]=val[i];
        int k=log2(n);
        for(int i=1;i<=k;i++)
            for(int j=1;j+(1<<i)-1<=n;j++) 
                ma[j][i]=max(ma[j][i-1],ma[j+(1<<(i-1))][i-1]);
    }
    int getmax(int l,int r)//简单的查询啊 
    {
        int k=log2(r-l+1);
        return max(ma[l][k],ma[r-(1<<k)+1][k]);
    }
    void workq()
    {
        scanf("%d",&q); 
        for(int i=1;i<=q;i++)
        {
            int x,y,u,v;
            scanf("%d%d",&y,&x);
            if(y>=x) { printf("false\n"); continue; }
            u=lower_bound(yea+1,yea+n+1,y)-yea;//yea数组是有序的 用二分查找大于等于x的最小整数的下标 
            v=lower_bound(yea+1,yea+n+1,x)-yea;
            if(y==yea[u]&&x==yea[v])//都已知 
            {
                if(val[u]<val[v]) printf("false\n");
                else if(v==u+1)
                {
                    if(x==y+1) printf("true\n");
                    else printf("maybe\n");//Y和X之间存在降雨量未知的年份
                }
                else
                {
                    int w=getmax(u+1,v-1);//寻找Y和X之间的最大降雨量
                    if(w>=val[v])  printf("false\n"); //不满足“对于任意Y＜Z＜X，Z年的降雨量严格小于X年”这个条件
                    else
                    {
                        if(x-y==v-u) printf("true\n");//Y年和X年之间没有任何降雨量未知的年份
                        else printf("maybe\n");
                    }
                }
            }
            else if(y!=yea[u]&&x==yea[v])//Y年的降雨量未知，X年的降雨量已知
            {
                if(u==v) printf("maybe\n");//Y年和X年之间年份的降雨量全部未知
                else
                {
                    int w=getmax(u,v-1);
                    if(w>=val[v]) printf("false\n");
                    else printf("maybe\n");
                }
            }
            else if(y==yea[u]&&x!=yea[v])//Y年的降雨量已知，X年的降雨量未知
            {
                if(v==u+1) printf("maybe\n");
                else
                {
                    int w=getmax(u+1,v-1);
                    if(val[u]<=w) printf("false\n");
                    else printf("maybe\n");
                }
            }
            else if(y!=yea[u]&&x!=yea[v]) printf("maybe\n");
        }
    } 
    int main()
    {
        scanf("%d",&n);
        for(int i=1;i<=n;i++) scanf("%d%d",&yea[i],&val[i]); 
        yea[n+1]=0x7f7f7f7f;//方便二分查找 
        prework(); //预处理 
        workq(); //处理询问 
        return 0;
    }


---

## 作者：zhangjiacheng (赞：3)

# 此题AC注意事项！！！
## 1、特别注意映射数组与原数据的区别 。
### 2、注意情况的完整讨论，可以画韦恩图来确保所有情况都在考虑范围内。
### 3、注意特殊情况：当右区间未知但是左区间已知仍可导出false！
## 4、注意边界，保险起见应作特殊处理。 
```c++
#include<bits/stdc++.h>
#define MAXN 50005
using namespace std;
int tree[MAXN<<2];
int ref[MAXN+3],top;
int w[MAXN+3];
int n,m;
int max(int a,int b)
{
    return a>b?a:b;
}
int query(int ask_L,int ask_R,int now_L,int now_R,int dot)
{
    if (ask_L==now_L&&ask_R==now_R) return tree[dot];
    int M=(now_L+now_R)>>1;
    if (ask_R<=M) return query(ask_L,ask_R,now_L,M,dot<<1);
    if (ask_L>M) return query(ask_L,ask_R,M+1,now_R,dot<<1|1);
    if (ask_L<=M&&ask_R>M) return (max(query(ask_L,M,now_L,M,dot<<1),query(M+1,ask_R,M+1,now_R,dot<<1|1)));
}
void build (int l,int r,int dot)
{
    if (l==r)
    {
        tree[dot]=w[l];
        return;
    }
    int m=(l+r)>>1;
    build (l,m,dot<<1);
    build (m+1,r,dot<<1|1);
    tree[dot]=max(tree[dot<<1],tree[dot<<1|1]);
}
int ef(int l,int r,int aim)
{
    if (l==r) return l;
    int m=(l+r)>>1;
    if (aim<=ref[m]) return ef(l,m,aim);
    else return ef(m+1,r,aim);
}
int main()
{
    scanf("%d",&n);
    for (int i=1;i<=n;i++) w[i]--;
    for (int i=1;i<=n;i++)
    {
        int a,b;
        scanf("%d%d",&a,&b);
        top++;
        ref[top]=a;
        w[top]=b;
    }
    build (1,n,1);
    scanf("%d",&m);
    for (int i=1;i<=m;i++)
    {
        int a,b;
        scanf("%d%d",&a,&b);
        if (b<=ref[1]&&a<b) 
        {
            printf("maybe\n");
            continue;
        }
        if (a>=ref[n]&&b>a)
        {
            printf("maybe\n");
            continue;
         }
        int l=ef(1,n,a);
        int r=ef(1,n,b);
        if (ref[r]!=b)//先将右区间未知的情况全部处理完 
        {
            if (l==r) 
            {
                printf("maybe\n");
                continue;
            }
            if (b<=ref[r]) r--;
            if (ref[l]==a)
            {
                if (l==r)
                {
                    printf("maybe\n");
                    continue;
                }
                int t=query(l+1,r,1,n,1);
                if (w[l]<=t) 
                {
                    printf("false\n");
                    continue;
                }
                else 
                {
                    printf("maybe\n");
                    continue;
                }
            }
            if (ref[l]!=a)
            {
                printf("maybe\n");
                continue;
            }
        }
        if (ref[l]==a)
        {
            if (w[r]>w[l])
            {
                printf("false\n");
                continue;
            }
            if (b==a+1)
            {
                printf("true\n");
                continue;
            }
            l++;
            a++;
            if (l==r)
            {
                printf("maybe\n");
                continue;
            }
            int t=query(l,r-1,1,n,1);
            if (t<w[r])
            {
                if (ref[r]-ref[l-1]==r-l+1) printf("true\n");
                else printf("maybe\n");
            }
            else (printf("false\n"));
            continue;
        }
        if (ref[l]!=a)
        {
            if (l==r)
            {
                printf("maybe\n");
                continue;
            }
            int t=query(l,r-1,1,n,1);
            if (t<w[r]) printf("maybe\n");
            else (printf("false\n"));
        }
    }
    return 0;
}
```
其他的没啥了，本人一蒟蒻，请大佬勿喷。。。

---

## 作者：__JR_飘摇__ (赞：3)

 一道紫题，这是第一次，不容易啊~~
 蒟蒻并不会什么高深算法，所以这题我打得特奇怪
 （模拟过省选）~~qaq
 - 至少空间很小，时间也很快~~

------------
**###### **总之就是乱搞一通啦！！！


------------
- (这里设f[i]为年份的降雨量)
- -先看看题目，
很明显的,对于每一个y（这里我把x和y对调了，也就是y>=x）都最多只可能有1个x使答案为true，就是这个年份之前的第一个f[x]>=f[y].(如果是所有f[x]>=f[y],那么第一个f[x]>f[y]会使得不符合题意)，所以我们记t[y]=x。
- 那么年份怎么办？我定义了一个map<int,int>a和数组p来储存，这样就可以把下标与年份互相转化了。
```cpp
for(i=1;i<=n;i++)
{
    cin>>k>>f[i];
    a[k]=i;p[i]=k;
}
```
这样以后就可以用啦（这个应该够简单吧）
- 接下来最恶心的就是判断maybe,false,true。（要不是有无穷无尽的bug，我也不会调试辣么久~~）【这个直接看代码注释】
- 这边发一波代码
```
#include<bits/stdc++.h>
using namespace std;
int n,m,i,f[50001],j,w,k,x,y,tt,min1,max1,t[50001],v,p[50001],l,r;//min1,max1指最小年份和最大年份 
map <int,int> a;
struct qu
{
	int id,mu;
}q[50001];
bool go(int pp)
{
	if(p[pp]==x) return true;
	if(t[pp]<=0) return false;
	if(f[pp]==f[t[pp]])//没有这句就会被bug10分 
	{
		if(t[t[pp]]<=0) return false;
		if(!go(t[t[pp]])) return false;
		else return true;
	}
	else if(!go(t[pp])) return false;
	else return true;
}
int pd()//本函数是被一步一步坑出来的~~ 
{
	if(x==y){printf("true\n");return 0;}
	//if(x>y){printf("false\n");return 0;}
	if(!a.count(x)&&!a.count(y)){printf("maybe\n");return 0;}//如果x,y都是未知降雨量，那么一定是maybe（y=无穷大，x=无穷大+1） 
	if(!a.count(y))//x为已知降雨量，y未知 
	{
		//这里不好解释，代码写完再做注释 
		if(y>max1)l=n;
		else
		{
			l=1,r=n;
	        while(l+1<r)//加了个二分求距离未知y最前的年份 
	        {
		        int mid=(l+r)/2;
		        if(p[mid]<=y) l=mid;
		        else r=mid; 
        	}
		}
		if(go(l)==true) {printf("maybe\n");return 0;}
		else {printf("false\n");return 0;}
	}
	if(!a.count(x))
	{
		if(t[a[y]]<=0||p[t[a[y]]]<=x) {printf("maybe\n");return 0;}
		//如果年份y前年份x后没有f[x]>f[y]，那么 当然是maybe 
		else{printf("false\n");return 0;}//有的话就不可能了 
	}
	if(y-x!=a[y]-a[x])//此语句代表年份x到y之间的年份非全部已知 
	{
		if(t[a[y]]!=a[x]) {printf("false\n");return 0;}
		//x到y中一定有f[z]>f[y] 
		{printf("maybe\n");return 0;}
	}
	if(t[a[y]]!=a[x]){printf("false\n");return 0;}
	printf("true\n");return 0;//写到这里我就有点解放了（好像事实并非如此） 
}
int main()
{
	scanf("%d",&n);
	for(i=1;i<=n;i++)
	{
		scanf("%d%d",&k,&f[i]);
		a[k]=i;p[i]=k;
		if(i==1) min1=k;
		if(i==n) max1=k; 
	}
	q[1].id=1;q[1].mu=f[1];w=1;
	for(i=2;i<=n;i++)
	{
		while(w&&q[w].mu<f[i]) w--;
		if(!w) t[i]=0;
		else t[i]=q[w].id;
		w++;
		q[w].id=i;q[w].mu=f[i];
	}//单调队列简简简化版求t 
	scanf("%d",&m);
	for(i=1;i<=m;i++)
	{
		scanf("%d%d",&x,&y);
		pd();  
	}
}
```
- 解释一下x已知y未知的情况：
- 这时我们找到一个年份f[j]代表<y的最大年份；
如果x~j之间任意已知降雨量i满足f[i]<f[j]<f[x],
那么答案就是maybe（这里可以想一想~~）
- 这种模拟法最适合我这种蒟蒻了~祝大家AC

---

## 作者：opened (赞：3)

这题一句话
难受 难受 真难受
------------
~~隔壁老王~~wpx大佬使用了ST表，但本蒟蒻表示RMQ只用线段树，于是。。比TA运行快了几百毫秒，ac慢了一小时。                   
。                                  
。                         
。
Talk is cheap, show me the code.
------------

    #include<iostream>
    #include<cstdio>
    using namespace std;
    const int maxn=5001;
    int n,m,a[maxn],b[maxn],tree[maxn<<2];
    inline int read(){
        int x=0,f=0;char ch=0;
        while(!isdigit(ch)){f|=ch=='-';ch=getchar();}
        while(isdigit(ch)) x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
        return f?-x:x;
    }
    inline int binary(int k){
        int l=1,r=n;
        while(l<r){
            int mid=(l+r)>>1;
            if(a[mid]<k) l=mid+1;
            else r=mid;
        }
        return l;
    }
    inline void build(int x,int l,int r){
        if(l==r){
            tree[x]=b[l];
            return;
        }
        int mid=(l+r)>>1,l1=x<<1,r1=l1|1;
        build(l1,l,mid);
        build(r1,mid+1,r);
        tree[x]=max(tree[l1],tree[r1]);
    }
    inline int search(int l,int r,int l2,int r2,int x){
        if(l2>r2) return -1e9;
        if(l==l2&&r==r2) return tree[x];
        int mid=(l+r)>>1,l1=x<<1,r1=l1|1,ans=-1e9;
        if(l2<=mid) ans=max(ans,search(l,mid,l2,min(r2,mid),l1));
        if(r2>mid) ans=max(ans,search(mid+1,r,max(l2,mid+1),r2,r1));
        return ans;
    }
    int main(){
        n=read();
        a[0]=-1e9-1;
        a[n+1]=1e9+1;
        for(int i=1;i<=n;i++) a[i]=read(),b[i]=read();
        build(1,1,n);
        int x,y,z,l,r;
        m=read();
        for(int i=1;i<=m;i++){
            y=read(),x=read();
            l=binary(y);
             while(a[l]<=y) l++;
            r=binary(x);
             while(a[r]>=x) r--;
            z=search(1,n,l,r,1);
            if((a[r+1]==x&&z>=b[r+1])||(a[l-1]==y&&z>=b[l-1])||(a[l-1]==y&&a[r+1]==x&&b[l-1]<b[r+1])) puts("false");
            else if(r-l+1==x-y-1&&a[l-1]==y&&a[r+1]==x) puts("true");
            else puts("maybe");
        }
        return 0;
    }

---

## 作者：HomuraCat (赞：2)

有一种打法叫做暴力讨论美学

首先你根据$Z,X,Y$是否确定记录$bool$值$fx,fy,fz$，显然$fx,fy,fz$总共就$8$种情况，全部讨论一遍就行了233333

虽然代码比较长但是这样是最不需要动脑子的

```cpp
#include<bits/stdc++.h>
#define fo(i, a, b) for(int i = (a); i <= (b); ++i)
#define N 100005
#define inf 1000000005
#define ls t[u].s[0]
#define rs t[u].s[1]
#define pb push_back
int A, B, Q, n, m, cnt;
std::map<int, int> mp;
struct node{
    int max, sum, s[2];
    friend node operator + (node x, node y)
    {
        return (node) {std::max(x.max, y.max), x.sum + y.sum};
    }
}t[N << 2];
inline void modify (int &u, int L, int R, int pos, int val)
{
    if (!u) u = ++cnt;
    if (L == R)
    {
        t[u].sum = 1; t[u].max = val;
        return; 
    }
    int mid = L + R >> 1;
    if (pos <= mid) modify(ls, L, mid, pos, val);
    else modify(rs, mid + 1, R, pos, val);
    t[u].max = std::max(t[ls].max, t[rs].max);
    t[u].sum = t[ls].sum + t[rs].sum;
}
inline node query (int u, int L, int R, int l, int r)
{
    node ret = (node) {-inf, 0};
    if (!u) return ret;
    if (l <= L && R <= r)
    {
        return t[u];
    }
    int mid = L + R >> 1;
    if (l <= mid) {ret = ret + query(ls, L, mid, l, r);}
    if (mid < r) {ret = ret + query(rs, mid + 1, R, l, r);}
    return ret;
}
int main ()
{
    int T;
    scanf("%d", &n);
    fo (i, 1, 4 * n) t[i].max = -inf;
    int rt = 0;
    fo (i, 1, n) 
    {
        int x, y;
        scanf("%d %d", &x, &y);
        mp[x] = y;
        modify(rt, -inf, inf, x, y);
    }
    scanf("%d", &Q);
    while (Q--)
    {
        int x, y, vx = -inf, vy = -inf;
        bool fx = 0, fy = 0, fz = 0;
        scanf("%d %d", &y, &x);
        if (mp.find(x) != mp.end())
        {
            vx = mp[x];
            fx = 1;
        }
        if (mp.find(y) != mp.end())
        {
            vy = mp[y];
            fy = 1;
        }
        if (x + 1 == y)
        {
            if (fx && fy)
            {
                if (vx <= vy)
                    printf("true\n");
                else
                    printf("false\n");
            }
            else
            printf("maybe\n");
            continue;
        }
        --x; ++y;
        node ans = (node) {-inf, 0};
        int now = 0;
        if (y <= x)
            ans = query(1, -inf, inf, y, x);
        if (ans.sum == x - y + 1)
            fz = 1;
        int vz = ans.max;
        if (!fz && !fx && !fy)
        {
            printf("maybe\n");
            continue;
        }
        if (fz && !fx && !fy)
        {
            printf("maybe\n");
            continue;
        }
        if (!fz && fx && !fy)
        {
            if (vz >= vx)
                printf("false\n");
            else
                printf("maybe\n");
            continue;
        }
        if (!fz && !fx && fy)
        {
            if (vz >= vy)
                printf("false\n");
            else
                printf("maybe\n");
            continue;
        }
        if (fz && fx && !fy)
        {
            if (vz >= vx)
                printf("false\n");
            else
                printf("maybe\n");
            continue;
        }
        if (fz && !fx && fy)
        {
            if (vz >= vy)
                printf("false\n");
            else
                printf("maybe\n");
            continue;
        }
        if (!fz && fx && fy)
        {
            if (vx > vy)
            {
                printf("false\n");
                continue;
            }
            if (vx <= vz)
            {
                printf("false\n");
                continue;
            }
            printf("maybe\n");
            continue;
        }
        if (fz && fx && fy)
        {
            if (vy >= vx && vx > vz)
            {
                printf("true\n");
            }
            else
            {
                printf("false\n");
            }
        }
    }
    return 0;
}
```

---

## 作者：斯德哥尔摩 (赞：2)

思路楼上几位巨神已经讲的很清楚的了，这里提供一种 结构体线段树+宏定义 的做法。。。

宏定义是个好东西啊，为什么只有少数人用呢。。。

附代码：

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#define LSON rt<<1//以下为线段树宏
#define RSON rt<<1|1
#define DATA(x) a[x].data
#define LSIDE(x) a[x].l
#define RSIDE(x) a[x].r//以上为线段树宏
#define MAXN 50010
using namespace std;
int n,m,d=1;
int year[MAXN],val[MAXN];//年份，降雨量
struct node{//线段树
    int data,l,r;
}a[MAXN<<2];
inline int read(){//读优。。。
	int date=0,w=1;char c=0;
	while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
	while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}
	return date*w;
}
inline void pushup(int rt){//上传
    DATA(rt)=max(DATA(LSON),DATA(RSON));
}
void buildtree(int l,int r,int rt){//建树
    int mid;
    LSIDE(rt)=l;
    RSIDE(rt)=r;
    if(l==r){
        DATA(rt)=0;//初值为0
        return;
    }
    mid=l+r>>1;//分左右子树
    buildtree(l,mid,LSON);
    buildtree(mid+1,r,RSON);
    pushup(rt);
}
void update(int l,int r,int c,int rt){//修改
    int mid;
    if(l<=LSIDE(rt)&&RSIDE(rt)<=r){
        DATA(rt)=c;
        return;
    }
    mid=LSIDE(rt)+RSIDE(rt)>>1;
    if(l<=mid)update(l,r,c,LSON);
    if(mid<r)update(l,r,c,RSON);
    pushup(rt);
}
int query(int l,int r,int rt){//求最大值
    if(l>r)return 0;//记得加这句。。。
    int mid,ans=0;//初值为0
    if(l<=LSIDE(rt)&&RSIDE(rt)<=r)
    return DATA(rt);
    mid=LSIDE(rt)+RSIDE(rt)>>1;
    if(l<=mid)ans=max(ans,query(l,r,LSON));
    if(mid<r)ans=max(ans,query(l,r,RSON));
    return ans;
}
int get_id(int x){//二分找编号
    int l=1,r=n,mid;
    while(l<=r){
        mid=l+r>>1;
        if(year[mid]>=x)r=mid-1;
        else l=mid+1;
    }
    return l;
}
void work(){//处理问题
    int x,y,k;
    m=read();
    while(m--){
        x=read();y=read();
        int idx=get_id(x),idy=get_id(y);
        k=query(idx+1,idy-1,1);
        bool flag1=(year[idx]==x?true:false),flag2=(year[idy]==y?true:false);
        if(flag1){//分了4种情况
            if(flag2){
                if(val[idx]<val[idy])printf("false\n");
                else if(k<val[idy]){
                    if(idy-idx==y-x)printf("true\n");
                    else printf("maybe\n");
                }
                else printf("false\n");
            }
            else{
                if(k<val[idx])printf("maybe\n");
                else printf("false\n");
            }
        }
        else{
            if(flag2){
                k=query(idx,idy-1,1);
                if(k<val[idy])printf("maybe\n");
                else printf("false\n");
            }
            else printf("maybe\n");
        }
    }
}
void init(){//读入+预处理
    n=read();
    buildtree(1,n,1);
    for(int i=1;i<=n;i++){
        year[i]=read();val[i]=read();
        update(i,i,val[i],1);
    }
}
int main(){//主函数So easy!
    init();
    work();
	return 0;
}

```

---

## 作者：Zenurik (赞：1)

# 让我们想象魔改一下这道题

有$n$个操作，其中$I$ $x$ $y$表示$x$年的降雨量为$y$，$A$ $x$ $y$表示询问“$y$年是$x$年以来降雨量最多的”这句话的正确性（不保证所有$A$操作均在$I$操作之后）。

可以发现，虽然只是魔改了一点点，但$ST$表和普通的线段树已经无法完成这道题。

于是我们考虑使用另一种数据结构：平衡树。

**平衡树的优点：应用更加灵活，能维护的问题更加复杂，不需要离散化，常数~~一般~~更小**

这里以$fhqTreap$为例，对于树上的每个节点维护三个值：$year,rain,Max$分别表示年份、降雨量和以其为根的子树中的最大降雨量。按照年份将树$split$成五个部分：$[...,x),x,(x,y),y,(y,...]$。按照题意分三类进行讨论即可。

（分类讨论部分详见代码注释）

```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#define Merge root=merge(merge(merge(ll,l),mid),merge(r,rr))
using namespace std;
static const int Size = 5e4+10;
int n, m, tot, root;

class FHQ_Treap {
    private:
        int year[Size], rain[Size], Max[Size], rnd[Size], siz[Size], son[Size][2];
        int New(int y, int w) {
            siz[++tot] = 1;
            rain[tot] = w;//降雨量 
            year[tot] = y;//年份 
            Max[tot] = w;//子树中最大降雨量 
            rnd[tot] = rand();
            return tot;
        }
        void update(int x) {
            siz[x] = siz[son[x][0]] + siz[son[x][1]] + 1;
            Max[x] = rain[x];//同时维护子树最大值 
            if(son[x][0]) Max[x] = max(Max[x], Max[son[x][0]]);
            if(son[x][1]) Max[x] = max(Max[x], Max[son[x][1]]);
        }
        void split(int now, int k, int &x, int &y) {//按照年份split 
            if(!now) return void(x = y = 0);
            if(year[now] < k) x = now, split(son[now][1], k, son[now][1], y);
            else y = now, split(son[now][0], k, x, son[now][0]);
            update(now);
        }
        int merge(int x, int y) {
            if(!x || !y) return x+y;
            if(rnd[x] < rnd[y]) { son[x][1] = merge(son[x][1], y); update(x); return x; }
            else { son[y][0] = merge(x, son[y][0]); update(y); return y; }
        }
    public:
        void Ins(int yr, int w) {
            int x, y;
            split(root, yr, x, y);
            root = merge(merge(x, New(yr, w)), y);
        }
        int query(int lft, int rgt) {//大型分类讨论现场 
            int ll, l, mid, r, rr;//分别表示区间[...,x),x,(x,y),y,(y,...] 
            split(root, lft, ll, l);
            split(l, lft+1, l, mid);
            split(mid, rgt, mid, r);
            split(r, rgt+1, r, rr);
			if(l && r) {//x年和y年的降雨量均已知 
				if(rain[r] > rain[l]) { Merge; return 0; }//y>x,不符合题意 
				if(Max[mid] >= rain[r]) { Merge; return 0; }//中间最大值>y,不符合题意 
				if(siz[mid] < rgt-lft-1) { Merge; return -1; }//中间有年份未知,无法确定 
				Merge;
				return 1;//反之则正确 
			}
			if(!l && r) if(Max[mid] >= rain[r]) { Merge; return 0; }//x年降雨量未知,中间最大值>y,不符合题意
			if(l && !r) {//y年降雨量未知 
				if(Max[mid] >= rain[l]) { Merge; return 0; }//中间最大值>x,一定不符合题意 
				Merge;
				return -1;//反之不能确定 
			}
			Merge;
			return -1;//反之不能确定 
        }
}Tree;

int main() {
	scanf("%d", &n);
	for(int i = 1, y, w; i <= n; i++) {
		scanf("%d%d", &y, &w);
		Tree.Ins(y, w);
	}
	scanf("%d", &m);
	for(int i = 1, x, y, ans; i <= m; i++) {
		scanf("%d%d", &x, &y);
		ans = Tree.query(x, y);
		if(ans == 1) printf("true\n");
		else if(ans == 0) printf("false\n");
		else printf("maybe\n");
	}
    return 0;
}
```


---

## 作者：drophell (赞：1)


做这种题没有什么可说的，就是细节，代码吧

```cpp
#include<set>
#include<map>
#include<ctime>
#include<queue>
#include<cmath>
#include<cstdio>
#include<vector>
#include<cstring>
#include<cstdlib>
#include<iostream>
#include<algorithm>

#define mem(a,b) memset(a,b,sizeof(a))
using namespace std;
#define ll long long 
const int MAXN=100000+20;
struct node
{
    int l,r,ly,ry,ex,mx;
}tr[MAXN*2];
int n,m;
void upp(int p)
{
    tr[p].mx=max(tr[p<<1].mx,tr[p<<1|1].mx);
    tr[p].ly=tr[p<<1].ly;
    tr[p].ry=tr[p<<1|1].ry;
}
void build(int p,int l,int r)
{
    if(l==r){scanf("%d%d",&tr[p].ly,&tr[p].mx);tr[p].ry=tr[p].ly;tr[p].ex=1;return;}
    int mid=((l+r)>>1);
    build(p<<1,l,mid);
    build(p<<1|1,mid+1,r);
    tr[p].ex=(tr[p<<1].ex&&tr[p<<1|1].ex);
    if(tr[p<<1].ry+1!=tr[p<<1|1].ly)tr[p].ex=0;
    upp(p);
}
int gety(int p,int x)
{
    if(tr[p].ly==tr[p].ry)
    {
        if(tr[p].ly!=x)return 0;
        return tr[p].mx;
    }
    if(x<=tr[p<<1].ry) return gety(p<<1,x);
    else if(x>=tr[p<<1|1].ly) return gety(p<<1|1,x);
    return 0;
}

int getlast(int p,int x)//输入的不一定是存在的年份，但返回已知的上一年
{
    if(tr[p].ly==tr[p].ry)return tr[p].ly;
    if(x>tr[p<<1|1].ly) return getlast(p<<1|1,x);//大于右的最左，那么可以在右区间找到上一年
    else return getlast(p<<1,x);//
}
int getnext(int p,int x)//输入的不一定是存在的年份，但返回已知的下一年
{
    if(tr[p].ly==tr[p].ry)return tr[p].ly;
    if(x<tr[p<<1].ry)return getnext(p<<1,x);
    else return getnext(p<<1|1,x);
}
//要义：不破坏x，y
int qry(int p,int x,int y,int num)
{
    bool f=0;
    if(x<tr[p].ly){x=tr[p].ly;f=1;} //内部确切区间不在范围内，那么不可能一定
    if(x==tr[p].ly&&tr[p].ry==y)
    {
    	if(tr[p].mx>=num)return 0;//有年份比要求年份降雨量大，那么就错
    	//不可能错
    	else if(tr[p].ex&&!f)return 1;//如果区间连续确切,并且内部确切区间在范围内，那么这个区间没比num大的降水量，对于这一区间一定对
    	else return 2;//然后就有可能吧
    }
    if(y<=tr[p<<1].ry) return qry(p<<1,x,y,num);
    else if(x>=tr[p<<1|1].ly) return qry(p<<1|1,x,y,num);
    else 
    {
    	int t1=qry(p<<1,x,tr[p<<1].ry,num);
    	int t2=qry(p<<1|1,tr[p<<1|1].ly,y,num);
    	if(!t1||!t2)return 0;//有一个不对那么不对
    	//子区间都合理（排除错误）
    	else if(tr[p<<1].ry+1!=tr[p<<1|1].ly)return 2;//区间不连续则可能
    	return 1;//区间连续则一定
    }
}
//确切已知降水量的年份，确切年份
int main()
{
    scanf("%d",&n);
    build(1,1,n);
    scanf("%d",&m);
    for(int i=1,x,y;i<=m;i++)
    {
        scanf("%d%d",&x,&y);
        if(x>y){printf("false\n");continue;}
       	int lnum=gety(1,x),rnum=gety(1,y);
       	if(!lnum&&!rnum){printf("maybe\n");continue;}//都未知，那么可能
        else
        {
        	int s=getnext(1,x),t=getlast(1,y);//获得左右年份内的最大确切年份
        	if(!lnum)//左不确定右确定
        	{
        		if(s>t||y==t){printf("maybe\n");continue;}//中间无确切年份或者右确定
        		//确切年份成为合理区间
        		int f=qry(1,s,t,rnum);
        		if(f==0)printf("false\n");
        		else printf("maybe\n");
        	}
        	else if(!rnum)//左确定右不确定
        	{
        		if(s>t||x==s){printf("maybe\n");continue;}
        		int f=qry(1,s,t,lnum);
        		if(f==0)printf("false\n");
        		else printf("maybe\n");
        	}
        	else//都确定
        	{
        		if(rnum>lnum){printf("false\n");continue;}//左降水量就大于右降水量，那么不论中间降雨量是多少，都是不可能的
        		//右降水量大于左降水量
        		if(s>t)//中间无确切年份，意味着不可能错
        		{
        			if(x+1==y)printf("true\n");//两年份相邻，则一定对
        			else printf("maybe\n");//还有未知年份，则可能对
        			continue; 
        		}
        		//中间有确切年份
        		int f=qry(1,s,t,rnum);
        		if(f==0)printf("false\n");//不可能就错
        		else if(f==1)//内部区间确切
        		{
        			
        			if(x+1==s&&y-1==t)printf("true\n");//恰好接住确切年份
        			else printf("maybe\n");	//还有未知年份
        		}
        		else if(f==2)printf("maybe\n");
        	}
        }
    }
return 0;
}

```
~~只是把黄学长的代码加了个注释~~



---

## 作者：SuperSASS (赞：1)

**参照了@xyz32768神犇的题解，并且讲的十分清楚很感谢**，这里给出具体代码实现并且稍微精简了几步判断：


反正具体要满足**Y>=X>Z (Z∈(X,Y))**【指的降雨量】这个不等式



```cpp
#include<bits/stdc++.h>
#define MAX 50000
#define Mid ((l+r)>>1)
using namespace std;
int Year[MAX],Rain[MAX],n;
inline int Read()
{
    char t=getchar();  
    int num=0,f=1;  
    while (t<'0' || t>'9') f=t=='-'?-1:1,t=getchar();  
    while (t>='0' && t<='9') num=num*10+t-'0',t=getchar();  
    return num*f;  
}
struct ST{
/*
采用ST表来寻找区间最大，如不了解ST表可参照
http://blog.csdn.net/qq_31029725/article/details/78818469
看看我写的ST表总结【虽然我知道我的语言和代码你们几乎完全看不懂orz……
*/
    int F[MAX][30],Log[MAX];
    void InitLog()
    {
        Log[1]=0,Log[2]=1;
        for (int i=3; i<=MAX; i++) Log[i]=Log[i>>1]+1;
    }
    
    void Init()
    {
        InitLog();
        for (int i=1; i<=n; i++) F[i][0]=Rain[i];
        for (int i=2; i<=n; i++)
        {
            F[i][1]=max(F[i-1][0],F[i][0]);
            for (int j=2; j<=Log[i]; j++) F[i][j]=max(F[i][j-1],F[i- (1<<(j-1))][j-1]);
        }
    }
    
    int Find(int l, int r)
    {
        if (l>r) return -1;
        int k=Log[r-l+1];
        return max(F[r][k],F[l+(1<<k)-1][k]);
    }
}ST;
int Find(int x)        //二分查找出最右边第一个存在的年份的下标
{
    int l=1,r=n,k=Mid;
    while (!(Year[k-1]<x && Year[k]>=x))
    {
        if (l==r) break;                //这里注意，因为年份可能为负数，不加特判在找到1时Year[Mid-1]<x会出错，当然你也可以将Year[0]=-INF; 
        if (Year[k]>=x) r=k,k=Mid; else l=k+1,k=Mid;        //并且这里Year[k]要为>=，找到1的时候会bug 
    }
    return k;
}
bool Known(int x, int &r)        //判断是否为存在年份
{
    return x==Year[r=Find(x)]?1:0;
}
int main()
{
    n=Read();
    for (int i=1; i<=n; i++) Year[i]=Read(),Rain[i]=Read();
    ST.Init();
    int q=Read();
    for (int i=q; i-->0;)
    {
        int Y=Read(),X=Read(),s,e,ife=Known(X,e),ifs=Known(Y,s);        //这里用s代表起点即Y，e代表终点即X
        e+=Year[e]<X?1:0;    //这里要注意如果终年超过已知最大年份查找返回的是n，在处理e未知的时候e-1会有bug 
        //根据每一年已知情况，并根据Y>=X>Z (Z∈(X,Y))这个不等式讨论
        if (ife && ifs)
        {
            if (Rain[s] < Rain[e]) {printf("false\n"); continue;}            //X的降雨量>Y的降雨量
            if (ST.Find(s+1,e-1) >= Rain[e]) {printf("false\n"); continue;}        //Z>=X
            if (e-s == X-Y) {printf("true\n"); continue;} else {printf("maybe\n"); continue;}        //e-s == Y-X 即中间没有未知年份
            //这里解释一波:
            //如果没有未知年份，则可以按分块思想来说，一个年一块，所以e-s == Y-X
            //而当有未知年份，则将会把未知年份压缩成一块，即至少两个年一块，所以e-s <= Y-X【每有一个未知年份则e-s的值变会少一
        }
        else if (ifs) if (ST.Find(s+1,e-1) >= Rain[s]) printf("false\n"); else  printf("maybe\n");        //如果当中没有Z>=Y则maybe【只要X or Y未知则必maybe
        else if (ife) if (ST.Find(s,e-1) >= Rain[e]) printf("false\n"); else printf("maybe\n");        //同上只不过是Z>=X了 
        else printf("maybe\n");        //两年都不存在，肯定maybe
    }
}
```


写的代码和注释是真的丑orz不明白可以私信我吧……


---


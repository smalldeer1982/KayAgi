# [SDOI2011] 打地鼠

## 题目描述

2020.4.29 数据更新。

打地鼠是这样的一个游戏：地面上有一些地鼠洞，地鼠们会不时从洞里探出头来很短时间后又缩回洞中。玩家的目标是在地鼠伸出头时，用锤子砸其头部，砸到的地鼠越多分数也就越高。

游戏中的锤子每次只能打一只地鼠，如果多只地鼠同时探出头，玩家只能通过多次挥舞锤子的方式打掉所有的地鼠。你认为这锤子太没用了，所以你改装了锤子，增加了锤子与地面的接触面积，使其每次可以击打一片区域。如果我们把地面看做 $m\times n$ 的方阵，其每个元素都代表一个地鼠洞，那么锤子可以覆盖 $r\times c$ 区域内的所有地鼠洞。但是改装后的锤子有一个缺点：每次挥舞锤子时，对于这的区域中的所有地洞，锤子会打掉恰好一只地鼠。也就是说锤子覆盖的区域中，每个地洞必须至少有 $1$ 只地鼠，且如果某个地洞中地鼠的个数大于 $1$，那么这个地洞只会有 $1$ 只地鼠被打掉，因此每次挥舞锤子时，恰好有$r\times c$ 只地鼠被打掉。由于锤子的内部结构过于精密，因此在游戏过程中你不能旋转锤子（即不能互换 $r$ 和 $c$）。

你可以任意更改锤子的规格(即你可以任意规定 $r$ 和 $c$ 的大小)，但是改装锤子的工作只能在打地鼠前进行(即你不可以打掉一部分地鼠后，再改变锤子的规格)。你的任务是求出要想打掉所有的地鼠，至少需要挥舞锤子的次数。

Hint：由于你可以把锤子的大小设置为 $1\times 1$，因此本题总是有解的。

## 说明/提示

【样例说明】

使用 $2\times 2$ 的锤子，分别在左上、左下、右上、右下挥舞一次。

【数据规模和约定】

对于 $30\%$ 的数据，$m$, $n\leq 5$ ；

对于 $60\%$ 的数据，$m$, $n\leq 30$ ；

对于 $100\%$ 的数据，$1\leq m$, $n\leq 100$ ，其他数据不小于 $0$，不大于 $10^5$ 。


## 样例 #1

### 输入

```
3 3
1 2 1
2 4 2
1 2 1
```

### 输出

```
4```

# 题解

## 作者：SzTC (赞：16)

[推荐本蒟蒻的博客](https://www.luogu.com.cn/blog/mSzTCm/)

附下AC代码，代码的解释都写在注释里了


------------

```cpp
#include<bits/stdc++.h>			//懒人专用头文件 
using namespace std;
int n,m,cnt;
int a[111][111],b[111][111];	//为了防止损坏a数组，判断的操作应在b数组内执行 
bool f(int r,int c)				//判断长为r，宽为c的锤子是否能够刚好砸完地鼠 
{
	if(cnt%(r*c))return false;	//可行性剪枝：如果地鼠的数量不能被一次砸的地鼠数量整除，那么最后一定不能刚好砸完 
	else
	{
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=m;j++)
			{
				b[i][j]=a[i][j];//复制a数组至b数组
			}
		}	
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=m;j++)//枚举所有的点，一个一个砸下去 
			{	
				if(b[i][j])		//如果b[i][j]不为空，那么就将范围内的地鼠数量全都减去它,实现以i，j为左上角砸b[i][j]次锤子 
				{
					int x=b[i][j];
					for(int k=1;k<=r;k++)
					{
						for(int l=1;l<=c;l++)//枚举锤子的范围，将范围内的地鼠都减去b[i][j] 
						{
							if(i+k-1>n || j+l-1>m)return false;	//如果锤子的范围超出了n*m，那么返回假 
							b[i+k-1][j+l-1]-=x;	 				//减去b[i][j] 
							if(b[i+k-1][j+l-1]<0)return false;	//如果锤子将一个位置的地鼠数量砸成了负数，那么也返回假 
						}
					}
				}
			}
		}
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=m;j++)
			{
				if(b[i][j])
				{
					return false;			//在所有位置的地鼠都砸了一遍过后，如果还有位置有地鼠留下，那么同样返回假
				}
			}
		}
		return true;						//最后，返回真 
	}
}		
int main()
{
	cin>>n>>m;								//输入n与m 
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			cin>>a[i][j];					//输入每个位置的地鼠数量 
			cnt+=a[i][j];					//统计地鼠一共的数量 
		}
	}	
	int ans=INT_MAX;						//将ans初始化为一个很大的数 
	for(int i=1;i<=n;i++)					//枚举锤子的长 
	{
		for(int j=1;j<=m;j++)				//枚举锤子的宽 
		{
			if(f(i,j))						//判断长为i，宽为j的锤子是否能够刚好砸完地鼠 
			{
				ans=min(ans,(cnt)/(i*j));	//需要砸的次数等于地鼠一共的数量除以一次砸的地鼠数量，最后取最小值 
			}
		}
	}
	cout<<ans;								//最后输出答案 
	return 0;
}
```


------------

### 蒟蒻第一次提交题解，欢迎在评论区提出建议！

---

## 作者：囧人232 (赞：10)

难度标签偏高，实际就是pj+（然而本蒟蒻还是调了半天qwq

大概思路：

数据范围只有100,所以，面向数据编程的我们，打个暴力就好了

从1->100分别枚举r和c

判断可行不可行

最后取r\*c最大的值==

当然只有这样容易t，所以我们还要剪枝！！！

因为每次都能打掉r\*c只地鼠，所以所有地鼠的sum一定是r\*c的倍数；

每次枚举前判断sum是不是r\*c的倍数，如果不是直接跳过

最后就a辣==

下面就是我的代码

```cpp
#include<cstdio>
#include<algorithm>
#include<iostream>
using namespace std;
int g[101][101],a[101][101];
int n,m,sum=0;
bool check(int r,int c)//判断r*c是否可行
{
    if((sum%(r*c)))return false;//可行性剪枝
    else{
        for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
        a[i][j]=g[i][j];
        for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
        if(a[i][j])
        {
            int t=a[i][j];
            for(int q=1;q<=r;q++)
            for(int w=1;w<=c;w++)
            {
                if(i+q-1>n||j+w-1>m)return false;
                a[i+q-1][j+w-1]-=t;
                if(a[i+q-1][j+w-1]<0)
                return false;
            }
        }
        for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
        if(a[i][j])return false;
        return true;
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
    scanf("%d",&g[i][j]),sum+=g[i][j];
//    cout<<check(1,1)<<endl;
    int ans=10000086;
    for(int r=1;r<=n;r++)
    for(int c=1;c<=m;c++)
    if(check(r,c)){
        ans=min(ans,(sum)/(r*c));
    }
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：__stdcall (赞：9)

### Prelude


为什么洛谷上所有的题解都是剪枝做的啊！就没有人写复杂度靠谱的算法吗！

传送到洛谷：[(￣、￣)](https://www.luogu.org/problemnew/show/P2484)

传送到BZOJ：[( ´･･)ﾉ(.\_.`)](http://www.lydsy.com/JudgeOnline/problem.php?id=2241)

本篇博客地址：[o(><；)oo](http://www.cnblogs.com/mlystdcall/p/8075591.html)


---

### Solution


首先$O(n^6)$，或者是$O(n^4 \log^2 n)$的模拟非常好想，枚举锤子的长宽，然后从左上角开始挨个砸就可以了。

枚举的复杂度是$O(n^2)$的，模拟一次的复杂度是$O(n^4)$的，也可以用BIT做到一次模拟$O(n^2 \log^2 n)$。

仔细想了想发现似乎没法合理枚举，那就只能发掘性质了。

直觉告诉我似乎是行列无关的。

具体来说，我们首先固定锤子的长为1，然后枚举锤子的宽，求出当长为1的时候最大可行的宽，叫做$c$。

然后再固定锤子的宽为1，枚举锤子的长，求出当宽为1的时候最大可行的长，叫做$r$。

上面两步可以用$O(n^4)$的暴力模拟来做，或者是用BIT做到$O(n^3 \log n)$。

那么这个$r$和$c$就是最终答案。

试着证明了一下，确实是这样的，具体证明我没有仔细想，大概感觉是从“每个格子被敲打的次数是行列无关的”这条入手？

然后就A掉了。

因为我比较懒，所以写的是$O(n^4)$的方法，毕竟这个模拟常数小嘛，$O(n^4)$过100肯定没问题啦。


---

### Code


```cpp
#include <cstring>
#include <algorithm>
#include <cstdio>

using namespace std;
const int MAXN = 110;
int _w;

int n, m, a[MAXN][MAXN], tot;
int r, c, b[MAXN][MAXN];
int t[MAXN][MAXN];

bool check( int x ) {
    for( int i = 1; i <= r; ++i )
        for( int j = 1; j <= c; ++j )
            t[i][j] = b[i][j];
    for( int i = 1; i <= r; ++i )
        for( int j = 1; j <= c-x+1; ++j )
            for( int k = j+x-1; k >= j; --k )
                t[i][k] -= t[i][j];
    for( int i = 1; i <= r; ++i )
        for( int j = 1; j <= c; ++j )
            if( t[i][j] ) return false;
    return true;
}

void solve() {
    r = n, c = m;
    for( int i = 1; i <= r; ++i )
        for( int j = 1; j <= c; ++j )
            b[i][j] = a[i][j];
    for( int x = c; x >= 1; --x )
        if( check(x) ) {
            tot /= x;
            break;
        }
    r = m, c = n;
    for( int i = 1; i <= r; ++i )
        for( int j = 1; j <= c; ++j )
            b[i][j] = a[j][i];
    for( int y = c; y >= 1; --y )
        if( check(y) ) {
            tot /= y;
            break;
        }
    printf( "%d\n", tot );
}

int main() {
    _w = scanf( "%d%d", &n, &m );
    tot = 0;
    for( int i = 1; i <= n; ++i )
        for( int j = 1; j <= m; ++j ) {
            _w = scanf( "%d", &a[i][j] );
            tot += a[i][j];
        }
    solve();
    return 0;
}
```

---

## 作者：zzzyc (赞：7)

本题为三个人所做，两个大佬加我一个蒟蒻。。。。。。

三个人一起做的！！！！！！！！！！！！！！！！！！



```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int a[1010][1010],f[1010][1010],ans,sum=0,n,m,maxn=0;
void dalaotaiqiangla(int i,int j)
{
    for(int x=1;x<=m;x++)
        for(int y=1;y<=n;y++)
            f[x][y]=a[x][y]; //复制数组 
    for(int x=1;x<=m;x++)
        for(int y=1;y<=n;y++)
            if(f[x][y]!=0)
            {
                int hh=f[x][y];
                if((m-x-i+1)<0 && (n-y-j+1)<0) return; //防止一锤子砸出界。。。毕竟伤人要赔钱。。。 
                else for(int z1=x;z1<=x+i-1;z1++)
                         for(int z2=y;z2<=y+j-1;z2++)
                        {
                            if(f[z1][z2]<f[x][y]) return; //重点思路，枚举每个点为锤子范围内最左边的点，范围内没有比这个点大的，便可以 
                            else f[z1][z2]-=hh;           //再使范围内其他点都减去这个点 ，这样貌似就可以了。 
                        }
            }
    ans=min(ans,sum/(i*j));
}
int main()
{
    cin>>m>>n;
    for(int i=1;i<=m;i++)
        for(int j=1;j<=n;j++)
        {
            cin>>a[i][j]; //输入 
            sum+=a[i][j]; //算总和 
            maxn=max(maxn,a[i][j]); //最大的点 
        }
    ans=sum; //普通锤子 1*1 的情况 
    for(int i=1;i<=m;i++)
        for(int j=1;j<=n;j++)
            {
                if(i*j>sum || sum%(i*j)!=0 || sum/(i*j)>ans || sum/(i*j)<maxn) continue; //剪枝，加了前两个AC，加了四个跑的更快，全不加会TLE四个点。 
                dalaotaiqiangla(i,j); //丧心病狂的函数名。。。 
            }
    cout<<ans;
    return 0;
}
```
此处外加一个水过了三个点的代码，为最初思想，打了上面的暴力后过了。。。。。。
看懂这个后或许有助于理解上面的程序。。。。。。

```cpp
#include<iostream>
using namespace std;
int m,n,a[1001][1001],sum,ans=9999999;
int main()
{
    cin>>m>>n;
    for(int i=1;i<=m;i++)
        for(int j=1;j<=n;j++)
        {
            cin>>a[i][j];
            sum+=a[i][j];
        }
    for(int r=1;r<=m;r++)
        for(int c=1;c<=n;c++)
        {
            int area=r*c;
            if(sum%area!=0) continue;
            else ans=min(ans,sum/area);
        }
    cout<<ans;
    return 0;
}
```

---

## 作者：noreply06 (赞：6)

ps：都说这题是模拟，为何我做的时候总觉得是递推

楼下代码主程序不难，本题解是对楼下模拟部分的一些补充

具体代码见楼下

考虑到锤子不能旋转，我们可以从 左上角 开始推

不难看出敲掉左上角只有一种方法

 ![](https://cdn.luogu.com.cn/upload/pic/4398.png) 

左上角开始r\*c范围都至少需要敲 左上角的次数

```cpp
for x:=r-1 downto 0 do       //r*c的矩形范围
 for y:=c-1 downto 0 do
  begin
   dec(f[i+x,j+y],f[i,j]);          //范围内的每一个均减少左上角的次数
   if f[i+x,j+y]<0 then exit(false);     //若不够减说明方法不对
  end;
```
敲完之后，我们不难发现最上面一行最左边的位置还是只能有一种方法

 ![](https://cdn.luogu.com.cn/upload/pic/4404.png) 

因此我们只要依次枚举各个点递推下去即可

```cpp
for i:=1 to m-r+1 do     //第一行开始       枚举r*c矩形的每一个左上顶点
   for j:=1 to n-c+1 do       //左边开始
```
最后，若可以枚举完（中途没有退出）则说明可行

于是在末尾加上exit(true);


---

## 作者：xryjr233 (赞：6)

如果我们确定了$r$和$c$,事实上也确定了打地鼠的方案。

因为所有$r\times c$的矩形中,只有1个能覆盖当前还有地鼠的位置组成的图形的角落上的那个洞,所以我们只能在那个角落上砸。

比如,我们目前剩下的地鼠分布为

0 0 0 0

0 0 **1** 2

0 2 1 2

2 2 3 1

那么我们只能以第二行的第三个位置(那个加粗的1)为左上角砸1次。

### 做法1

于是我们可以$O(nm)$枚举$r$,枚举$c$,然后$O(nm)$从左到右,从上到下枚举点,然后$O(rc)$给以当前点为左上角的矩形内的数减去当前点剩下的地鼠数量,寻找$r\times c$的最大值。

然而这样做是$O(n^3m^3)$的。

我们可以做一下二维差分,然后省去了最后给矩形内点减去当前点剩下的地鼠数量的步骤。

二维差分:给一个左上端点为$(x_1,y_1)$,右下端点为$(x_2,y_2)$的矩形加上$v$,需要在差分数组的$s_{x_1,y_1}$和$s_{x_2+1,y_2+1}$加上$v$,给$s_{x_1,y_2+1}$给$s_{x_2+1,y_1}$减去$v$,那么左上端点为$(1,1)$,右下端点为$(x,y)$的矩形的和就是点$(x,y)$上的实际值了。

时间复杂度$O(n^2m^2)$。

code:

```cpp
#include<bits/stdc++.h>
#define Add(u,l,d,r,v) (sum[u][l]+=v,sum[d+1][r+1]+=v,sum[u][r+1]-=v,sum[d+1][l]-=v)
using namespace std;
int n,m,num[110][110],sum[110][110],ans,t,SUM;
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;++i)for(int j=1;j<=m;++j)scanf("%d",&num[i][j]),SUM+=num[i][j];
    for(int r=1;r<=n;++r){
        for(int c=1;c<=m;++c){
            for(int i=1;i<=n;++i)for(int j=1;j<=m;++j)sum[i][j]=0;
            for(int i=1;i<=n;++i){
                for(int j=1;j<=m;++j){
                    sum[i][j]+=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1];
                    if(sum[i][j]>num[i][j])goto END;
                    if(sum[i][j]<num[i][j]){
                        if(i+r-1>n||j+c-1>m)goto END;
                        t=num[i][j]-sum[i][j],Add(i,j,i+r-1,j+c-1,t);
                    }
                }
            }
            ans=max(ans,r*c);
            END:
            ;
        }
    }
    printf("%d",SUM/ans);
    return 0;
}
```



### 做法2

我们枚举$r$,假定$c=1$,计算最大的合法的$r$;

然后假定$r=1$,枚举$c$,计算最大的合法的$c$;

那么$r\times c$锤子一定是可行的。

为什么呢?

证明:

我们每次锤的点是目前地鼠数非0的位置组成的图形中最上一行最左一列的点，我们设这个点还有$x$只地鼠。

首先,以这个点为左上端点,锤一个$1\times c$的矩形$x$次是合法的;

其次,以这一行前$c$个点每一个为左上端点,各锤一个$r\times 1$的矩形$x$次是合法的。

所以这个$r\times c$矩形也就是合法的了。

时间复杂度$O((n+m)nm)$。

code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,num[110][110],sum[110][110],r,c,t,SUM;
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;++i)for(int j=1;j<=m;++j)scanf("%d",&num[i][j]),SUM+=num[i][j];
    for(r=n;r>=1;--r){
        for(int i=1;i<=n;++i)for(int j=1;j<=m;++j)sum[i][j]=0;
        for(int i=1;i<=n;++i)for(int j=1;j<=m;++j){
            sum[i][j]+=sum[i-1][j];
            if(sum[i][j]>num[i][j])goto END1;
            if(sum[i][j]<num[i][j]){
                if(i+r-1>n)goto END1;
                else t=num[i][j]-sum[i][j],sum[i][j]+=t,sum[i+r][j]-=t;
            }
        }
        break;
        END1:
        ;
    }
    for(c=n;c>=1;--c){
        for(int i=1;i<=n;++i)for(int j=1;j<=m;++j)sum[i][j]=0;
        for(int i=1;i<=n;++i)for(int j=1;j<=m;++j){
            sum[i][j]+=sum[i][j-1];
            if(sum[i][j]>num[i][j])goto END2;
            if(sum[i][j]<num[i][j]){
                if(j+c-1>m)goto END2;
                else t=num[i][j]-sum[i][j],sum[i][j]+=t,sum[i][j+c]-=t;
            }
        }
        break;
        END2:
        ;
    }
    printf("%d",SUM/(r*c));
    return 0;
}
```

---

## 作者：Diogenes (赞：4)

这道题最好可以做到$n^{2.5}$，但由于数据弱可以让一些错误的$n^2$算法AC

将行和列分开考虑。

枚举每个点时用前缀和记录要减去的数（见注释）

枚举行数（列数）时使用每一行（列）的和的gcd的约数。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<map>
#define ll long long
#define N 1010
#define max(x,y) ((x)>(y) ? (x) : (y))
#define min(x,y) ((x)<(y) ? (x) : (y))
using namespace std;

inline int getint() {
	int p,t=0;
	char ch=getchar();
	for(;ch!='-' && !(ch>='0' && ch<='9');ch=getchar());
	if(ch=='-') ch=getchar(),p=-1;
	else p=1;
	for(;ch>='0' && ch<='9';ch=getchar()) {
		t=t*10+ch-48;
	}
	return t*p;
}

int n,m,a[N][N],r,p[N],cnt,g[N],c;
ll rs,cs;

inline ll gcd(ll a,ll b) {
	ll r=a%b;
	while(r) {a=b,b=r,r=a%b;}
	return b;
}

int main() {
//	freopen("shrew.in","r",stdin);
//	freopen("shrew.out","w",stdout);
	n=getint();m=getint();
	ll tot=0;
	for(int i=1;i<=n;i++) {
		for(int j=1;j<=m;j++) {
			tot+=a[i][j]=getint();
		}
	}
	rs=0;
	for(int i=1;i<=n;i++) {
		ll sum=0;
		for(int j=1;j<=m;j++) {
			sum+=a[i][j];
		}
		rs=(rs==0 ? sum : gcd(rs,sum));//每一行的和的gcd
	}
	int RS=min(rs,m);
	cnt=0;
	for(int i=1;i<=RS;i++) {
		if(rs%i==0) {
			g[cnt++]=i;//枚举约数
		}
	}
	for(int ir=cnt-1;ir>=0;ir--) {
		r=g[ir];
		bool f=true;
		for(int i=1;i<=n;i++) {
			memset(p,0,sizeof p);//前缀和
			for(int j=1;j<=m;j++) {
				p[j]=p[j-1];
				if(j>r) {
					if(a[i][j]<p[j]-p[j-r] || (j==m && a[i][j]!=p[j]-p[j-r])) {f=false;break;}
                    //p[j]-p[j-r]是当前点要减去的数
					else p[j]=a[i][j]+p[j-r];
                    //p[j]+=a[i][j]-(p[j]-p[j-r]);
				} else {
					if(a[i][j]<p[j] || (j==m && a[i][j]!=p[j])) {f=false;break;}
					else p[j]=a[i][j];
				}
			}
			if(!f) break;
		}
		if(f) break;
	}
//	printf("%d\n",r);
	cs=0;
	for(int j=1;j<=m;j++) {
		ll sum=0;
		for(int i=1;i<=n;i++) {
			sum+=a[i][j];
		}
		cs=(cs==0 ? sum : gcd(cs,sum));
	}
	int CS=min(cs,n);
	cnt=0;
	for(int i=1;i<=CS;i++) {
		if(cs%i==0) {
			g[cnt++]=i;
		}
	}
	for(int ic=cnt-1;ic>=0;ic--) {
		c=g[ic];
		bool f=true;
		for(int j=1;j<=m;j++) {
			memset(p,0,sizeof p);
			for(int i=1;i<=n;i++) {
				p[i]=p[i-1];
				if(i>c) {
					if(a[i][j]<p[i]-p[i-c] || (i==n && a[i][j]!=p[i]-p[i-c])) {f=false;break;}
					else p[i]=a[i][j]+p[i-c];
				} else {
					if(a[i][j]<p[i] || (i==n && a[i][j]!=p[i])) {f=false;break;}
					else p[i]=a[i][j];
				}
			}
			if(!f) break;
		}
		if(f) break;
	}
	printf("%lld\n",tot/r/c);
	return 0;
}
```

---

## 作者：BigJoker (赞：3)

# 0x00 思路

思路很简单，直接暴力枚举边长，然后模拟即可，中间有一些小优化，不然会超时。

# 0x01 暴力&模拟

既然求的是最少的挥舞次数，那么肯定能挥舞，不然无法计算，所以我们写一个 $ \texttt c  \texttt h  \texttt e \texttt c  \texttt k$ 函数，里面传入 $x,y$ 表示能否用长为 $x$ 和宽为 $y$ 的锤子锤完所有的地鼠。由于 $ \texttt a$ 数组随时有可能被更改，所以我们用一个辅助数组 $ \texttt b$ 来存储当前每个格子的地鼠数量，我们需要依次枚举每一个格子，如果这个格子没有地鼠，跳过即可，如果有地鼠，那么需要枚举以 $x$ 为长，$y$ 为宽的，并且左上角为 $(i,j)$ 的长方形，由于每个格子必须要锤，所以这个长方形的内格子必须要不为零且必须大于等于 $b[i][j]$，不然就返回 0，弄完之后就返回 1。

# 0x02 优化

存储一下总共地鼠的数量，看一下如果总地鼠的数量模这个长方形的大小，如果不为 0，就可以完全不管。

# 0x03 代码

```cpp
#include<bits/stdc++.h>
#define rep(i,l,r) for(int i=l;i<=r;i++)
#define dep(i,r,l) for(int i=r;i>=l;i--)
#define INF 0x3f3f3f3f
using namespace std;
int n,m,a[105][105],b[105][105],ds,ans=INF;
bool check(int x,int y){
	rep(i,1,n)
		rep(j,1,m) b[i][j]=a[i][j];
	rep(i,1,n)
		rep(j,1,m){
			if(!b[i][j]) continue;
			rep(l,i,i+x-1)
				rep(r,j,j+y-1){
					if(l==i && r==j) continue;
					if(l>n || r>m || b[l][r]<b[i][j]) return 0;
					b[l][r]-=b[i][j];
				}
			b[i][j]=0;
		}
	return 1;
}
int main(){
	scanf("%d %d",&n,&m);
	rep(i,1,n)
		rep(j,1,m) scanf("%d",&a[i][j]),ds+=a[i][j];
	rep(i,1,n)
		rep(j,1,m)
			if(!(ds%(i*j)) && check(i,j)) ans=min(ans,ds/(i*j));
	printf("%d",ans);
	return 0;
}
```


---

## 作者：单曦增 (赞：3)

今天学了一天的数论，感觉头昏脑胀，快点刷道题清醒清醒。

这道题$O(n^6)$的算法并不难想，因为如果我们先枚举锤子的大小r，c后，在从左上角开始枚举，最左上角的一定要被先打掉，所以就多打几下，打完后再打新出现的左上角，以此类推，如果中间出现某个洞被打成了负的，就无解。我们可以从最大的锤子开始枚举，如果可行，那么输出就行了。

但这样一定是过不了的，所以我们必须考虑优化。

最开始，我想到的是二维树状数组，时间复杂度$O(n^4log^2n)$，但是很显然，这样还是过不了的。

进一步观察，我们可以发现，我们只需要顺序加数，并不需要删除，那我们可以用前缀和加容斥优化到$O(n^4)$，顺利A过。

代码：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int Maxn=110;
typedef long long ll;
void read(ll &a)
{
	char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')a=(a<<3)+(a<<1)+ch-'0',ch=getchar();
}
struct node
{
	ll x,y,size;
}b[Maxn*Maxn];//用来存锤子
int cmp(node a,node b)
{
	return a.size>b.size;
}
ll a[Maxn][Maxn],c[Maxn][Maxn];
//a是原数组，c是前缀和。
ll n,m,totn,tot;
bool solve(ll x,ll y)
{
	memset(c,0,sizeof(c));
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
	{
		ll temp=c[max(0ll,i-x)][max(0ll,j-y)]+c[i][j-1]-c[i-1][j-1]-c[i][max(0ll,j-y)]+c[i-1][j]-c[max(0ll,i-x)][j];
        //令人望而生畏的容斥
		if(temp>a[i][j])
			return false;
		else
			c[i][j]=c[i-1][j]+c[i][j-1]-c[i-1][j-1]+a[i][j]-temp;
	}
	return true;
}
int main()
{
	read(n);read(m);
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
	{
		read(a[i][j]);
		totn+=a[i][j];
	}
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
	{
		if(totn%i*j!=0)
			continue;
		b[++tot].size=i*j;
		b[tot].x=i;
		b[tot].y=j;
	}
	sort(b+1,b+tot+1,cmp);//排序后从大到小枚举，第一个就是答案。
	for(int i=1;i<=tot;i++)
	{
		ll temp=b[i].size;
		if(solve(b[i].x,b[i].y))
		{
			printf("%lld\n",totn/temp);
			return 0;
		}
	}
	return 0;//似乎并不需要...
}
```

---

## 作者：TernaryTree (赞：1)

模拟赛出这题，我暴力剪枝 $n^6$ 过了。颠覆我认知。

考虑朴素算法。枚举 $r,c$，将所有 $r\times c$ 的矩形减去左上角值，最后判断能不能全消成 $0$。

剪枝 $1$：设 $\sum a_{i,j}=tot$。若 $r\times c\nmid tot$ 则跳过。每次总和减去 $r\times c$，则剪枝正确性显然。

剪枝 $2$：若任何时刻矩阵出现负数则退出。矩阵内数只减不增。

剪枝 $3$：若当前要减去的矩阵左上角为 $0$ 则不进行任何操作。

这样我们可以轻松地通过。

```cpp
#include <bits/stdc++.h>
#define int long long

using namespace std;

const int maxn = 1e2 + 10;

int n, m, tot, ans = 1145141919810ll;
int a[maxn][maxn];
int b[maxn][maxn];

bool check(int r, int c) {
	if (tot % (r * c) != 0) return false;
	bool flag = true;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			a[i][j] = b[i][j];
		}
	}
	for (int i = 1; i <= n - r + 1; i++) {
		for (int j = 1; j <= m - c + 1; j++) {
			int x = a[i][j];
			if (!x) continue;
			for (int p = i; p < i + r; p++) {
				for (int q = j; q < j + c; q++) {
					if (a[p][q] - x >= 0) a[p][q] -= x;
					else {
						flag = false;
						break;
					}
				}
				if (!flag) break;
			}
			if (!flag) break;
		}
		if (!flag) break;
	}
	if (!flag) return false;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			if (a[i][j]) return false;
		}
	}
	return true;
}

signed main() {
//	freopen("shrew.in", "r", stdin);
//	freopen("shrew.out", "w", stdout);
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			cin >> b[i][j];
			tot += b[i][j];
		}
	}
	for (int r = 1; r <= n; r++) {
		for (int c = 1; c <= m; c++) {
			if (!check(r, c)) continue;
			ans = min(ans, tot / (r * c));
		}
	}
	cout << ans;
	return 0;
}
```



---

## 作者：if_OF (赞：1)

# P2484 [SDOI2011]打地鼠 题解

## 题目

[P2484 [SDOI2011]打地鼠 题解](https://www.luogu.com.cn/problem/P2484)

## 分析

锤子每次只能将每个洞里打掉一只地鼠，所以对于每次击打，都会打掉 $r\times c$ 只地鼠。而每次击打的范围内的每个洞里必须都要有地鼠，所以地鼠的总数必须被 $r\times c$ 整除。

因为每只地鼠都需要被干掉，所以如果当前方案成立，总可以通过不断在地图左上角寻找有地鼠的洞，再以这个洞为锤子击打的范围的左上角进行击打来打完所有地鼠。

而如果在打地鼠的时候发现击打范围内有已经没有地鼠的洞或者会打到地图外面的话，当前方案就不成立。

## 思路

由于地图只是个 $100\times 100$ 的矩形，所以我们完全可以枚举 $r$ 和 $c$，只要锤子覆盖的区域大小即 $r\times c$ 能整除地图中的地鼠总数就进行尝试。

根据上文的分析，我们只需要在整个地图左上角找到一个还剩的有地鼠的洞，设这个洞的坐标为 $(x,y)$，然后进行以下操作：

1. 判断 $(x+r-1,y+c-1)$ 是否在地图外面。在的话说明这个锤子不满足题意，结束，否则进行下一步。
2. 判断$(x,y)$ 到 $(x+r-1,y+c-1)$ 范围内有没有空地鼠洞。如果有的话，说明这个锤子不满足题意，结束，否则进行下一步。
3. 将 $(x,y)$ 到 $(x+r-1,y+c-1)$ 范围内的地鼠数量减一。
4. 将这个锤子的击打总次数加一。
5. 回到第 $1$ 步操作直到所有地鼠洞为空。

因为 $(x+y)$ 的地鼠在锤子大小满足题意的情况下再怎么样都会被打完，所以我们也可以直接将 $(x,y)$ 到 $(x+r-1,y+c-1)$ 范围内的地鼠数量减 $(x,y)$ 里的地鼠数量（相当于连续打 $(x,y)$ 里的地鼠数量次），判断减之后有没有为负的洞，有说明锤子不满足题意，没有的话将锤子总击打次数加上 $(x,y)$ 里的地鼠数量，然后继续尝试。这算是个小优化。

最后就输出所有可行的锤子中击打次数最小的值就好了。更详细的解释请参阅代码里的注释。

## 代码

```cpp
#pragma GCC optimize(2)
#include <cstdio>
using namespace std;
int n, m, tot = 0;
long long ans = 1145141919810;
int maze[105][105];
int tmaze[105][105]; //因为要尝试多次且每次尝试都会修改地鼠洞内地鼠的数量，
                     //我们需要在每次尝试前复制原始的地图
long long Min(long long a, long long b)
{
    return a > b ? b : a;
}
inline bool findfirst(int &x, int &y) //从地图左上角找到第一个有地鼠的地鼠洞，返回是否找到
{
    for (register int i = 1; i <= n; i++)
    {
        for (register int j = 1; j <= m; j++)
        {
            if (tmaze[i][j])
            {
                x = i, y = j; //找到就将这个洞的坐标传回去
                return 1;
            }
        }
    }
    return 0;
}
inline void dfs(int r, int c, int cnt) //参数表示锤子大小和花费
{
    int x, y;             //用x,y表示目前在左上角找到的地鼠洞为(x,y)
    if (!findfirst(x, y)) //如果没找到有地鼠的洞说明找完了，更新答案并结束
    {
        ans = Min(ans, 1ll * cnt);
        return;
    }
    if (x + r - 1 > n || y + c - 1 > m || cnt >= ans) //操作1，如果要打左上角的地鼠
                                                      //洞锤子会超过地图，说明这组
                                                      //方案不成立
        return;
    int red = tmaze[x][y]; //操作3，将(x,y)到(x+r-1,y+c-1)内的地鼠数量都减去(x,y)内的地鼠数
    for (register int i = x; i <= x + r - 1; i++)
    {
        for (register int j = y; j <= y + c - 1; j++)
        {
            tmaze[i][j] -= red;
            if (tmaze[i][j] < 0) //操作2，如果这个洞里的地鼠数量为负说明这组方案不成立
                return;
        }
    }
    dfs(r, c, cnt + red); //操作4、5，加上操作次数，继续打剩下的地鼠
    return;
}
void cpymaze()
{
    for (register int i = 1; i <= n; i++)
        for (register int j = 1; j <= m; j++)
            tmaze[i][j] = maze[i][j]; //复制原始的地图
}
signed main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            scanf("%d", &maze[i][j]);
            tot += maze[i][j]; //记录地鼠总数
        }
    }
    for (int r = 1; r <= n; r++)
    {
        for (int c = 1; c <= m; c++)
        {
            if (tot % (r * c) == 0) //分析中所说的，只有锤子的覆盖大小能整除地鼠总数才行
            {
                cpymaze();
                dfs(r, c, 0);
            }
        }
    }
    printf("%lld\n", ans);
}
```

---

## 作者：Super_Cube (赞：1)

# 题目大意：

给你一个 $n \times m$ 的矩阵，每次可以让 $r \times c$ 大小的子矩阵里的所有值 $-1$，只有最后整个矩阵的所有值都为 $0$ 时 $r$ 和 $c$ 才是合法的。

问如何选择合法的 $r$ 和 $c$ 的值使得让矩阵全部变为 $0$ 的次数最少。

---

# 思路：

我们直接暴力枚举 $r$ 和 $c$ 的长度，每次判断一下当前的 $r$ 和 $c$ 是否合法，并且更新答案(最小值)就可以了。

更新的方法就是：`if(check(r,c))ans=min(ans,sum/r/c);`

其中 $ans$ 是答案，$sum$ 是地鼠总数。

以下是我的判断函数，打了注释的，方便大家理解。
```cpp
bool check(int x,int y){//传进来的参数就是r和c,不过个人习惯比较爱用x和y
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			b[i][j]=a[i][j];//由于原数组的值不能修改,需要拷贝一份
		}
	}
	for(int i=1;i<=n-x+1;i++){//长为x只用循环到n-x+1
		for(int j=1;j<=m-y+1;j++){//宽为y只用循环到m-y+1
			if(b[i][j]){//在当前位置有地鼠时我们需要不断敲打至此元素为0
				int z=b[i][j];
				for(int k=0;k<x;k++){
					for(int l=0;l<y;l++){
						b[i+k][j+l]-=z;//每个元素都会被敲打z次
						if(b[i+k][j+l]<0)return 0;//如果有元素敲打至负数说明这个规格不合法
					}
				}
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(b[i][j])return 0;//如果有不为0的元素也是不合法的
		}
	}return 1;
}
```

这种超暴力的时间复杂度为 $O(n^6)$。

因为 $n \le 100$，跑跑洛谷的评测机看上去是有一点点小小的问题的。
~~(毕竟我没有尝试过。)~~

所有，我们需要一波小小的优化。


对于一个 $r$ 和 $c$ 的长度，为了让矩阵上的地鼠全部变为 $0$，那么地鼠总数 $sum$ 模 $r \times c$ 肯定为 $0$，要不然你肯定会剩下一些元素不为 $0$。所以当模下来不为 $0$ 时我们直接判断为不合法情况。

还有在上一个优化成立时，如果地鼠总数 $sum$ 除以 $r \times c$ 的值 $\ge$ 之前的最小值 $ans$，我们直接略过这个 $r$ 和 $c$，因为就算这个 $r$ 和 $c$ 是合法的，也对我们的答案不会产生影响。

这样优化下来的 $O(n^6)$ 并不慢，目前为提交最优解的第六。

---

# Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[105][105],b[105][105],n,m,ans,sum;
//a是输入数组,b为拷贝数组
bool check(int x,int y){//check我前面打过注释了,这里就算了吧
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			b[i][j]=a[i][j];
		}
	}
	for(int i=1;i<=n-x+1;i++){
		for(int j=1;j<=m-y+1;j++){
			if(b[i][j]){
				int z=b[i][j];
				for(int k=0;k<x;k++){
					for(int l=0;l<y;l++){
						b[i+k][j+l]-=z;
						if(b[i+k][j+l]<0)return 0;
					}
				}
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(b[i][j])return 0;
		}
	}return 1;
}
int main(){
	ios_base::sync_with_stdio(0);//黑科技加速
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>a[i][j];sum+=a[i][j];//统计总和
		}
	}ans=sum;//最大也就敲打sum下,为1*1的锤子
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(sum%(i*j)==0&&sum/i/j<ans){//上文提到的优化
				if(check(i,j))ans=sum/i/j;
			}
		}
	}cout<<ans;
	return 0;
}
```

---

## 作者：IcyFoxer_XZY (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P2484)

### 题目思路分析

考虑到这题数据很小，我们可以直接暴力枚举加模拟过掉这道题。

对于锤子的大小，我们可以枚举。然后模拟对要砸的部分进行操作，对该区域减去砸的地方左上角的数，如果小于零就可以直接返回 false 了。这样会节省许多时间。

我们可以从大到小枚举锤子，并且只有所有地洞地鼠之和为锤子体积的倍数时才进行操作。

令地鼠和为 $x$，锤子体积为 $v$，已得到答案最小值为 $ans$，那么当且仅当 $x\div v\le ans$ 时才砸。

代码：

```cpp
#include<bits/stdc++.h>
#define re register int//常数优化 
using namespace std;
int m,n,a[101][101],b[101][101],ans,sum,minn=1e9,w;
inline bool hit(int r,int c){//模拟过程 
	ans=0;
	for(re i=1;i<=m-r+1;++i)
		for(re j=1;j<=n-c+1;++j){
			w=b[i][j];
			for(re x=i;x<=i+r-1;++x)
				for(re y=j;y<=j+c-1;++y){
					if(b[x][y]-w<0)return false;//小于零直接return false 
					else b[x][y]-=w;
				}
			ans+=w;
		}
	for(re i=1;i<=m;++i)
		for(re j=1;j<=n;++j)
			if(b[i][j]!=0)
				return false;
	return true; 
}
inline void copy(){
	for(re i=1;i<=m;++i)
		for(re j=1;j<=n;++j)
			b[i][j]=a[i][j];
}
int main(){
	scanf("%d%d",&m,&n);
	for(re i=1;i<=m;++i)
		for(re j=1;j<=n;++j){
			scanf("%d",&a[i][j]);
			sum+=a[i][j];
		}
	copy();
	for(re r=m;r>=1;--r){
		for(re c=n;c>=1;--c){
			if(sum%(r*c)!=0)continue;
			if(sum/(r*c)>minn)continue;
			copy();
			if(hit(r,c)==true)minn=min(minn,sum/(r*c));
		}
	}
	printf("%d",minn);
	return 0;
}
```
Bye！

---

## 作者：Kiloio (赞：0)

## 简述题意：  
给一个 $ n \times m $ 的矩阵，可以选取一个 $ r \times c $ 的子矩阵，让这个范围内的数 $ -1 $ 。  
要求如何设定 $ r $ 和 $ c $ 的值，使操作次数最小。  
  
## 题目分析：  
先看数据范围： $ 1 \leq m , n \leq 100 $ ,搜索是没有问题的。  

我们枚举**每个** $ r $ 和 $ c $ ，再模拟“敲地鼠”（即上述操作）的过程。  
模拟完后，看经操作后的数组是否都为零，是则可行。  
  
当确认 $ r \times c $ 这种情况可行后，就要统计答案。（**深搜不能保证第一次搜到的就是最小答案**）。   
 
要使矩阵最后**全为** $ 0 $ ，操作次数是**固定**的。  

记录**每个元素的总和** $ sum $ 。每次操作，减去的值**始终**为 $ r \times c $ ,设操作次数为 $ times $ 次，则：  

$ times \times ( r \times c ) = sum $   

再移项可得答案 $ times = sum \div ( r \times c ) $ 。    

        
还可据此进行**可行性优化**。在每次验证前**先判断** $ sum \% ( r \times c ) $ **是否为** $ 0 $ ，是的话再验证。   
  
## 代码：  
```
#include <bits/stdc++.h>
using namespace std;
long long n,m,a[114][114],s[114][114],sum,ans=10e10;//ans赋值要大 
bool find(int r,int c) {
	for(int i=1; i<=n; i++) {
		for(int j=1; j<=m; j++) {
			s[i][j]=a[i][j];//s数组是为了方便操做，保证a数组不变。 
		}
	}
	for(int i=1; i<=n; i++) {
		for(int j=1; j<=m; j++) {			
			if(!s[i][j]){//如果当前s[i][j]这个元素已经为0了，就不操作了。 
				continue;
			}
			int op=s[i][j];
			for(int x=1; x<=r; x++) {
				for(int y=1; y<=c; y++) {
					if(i+x-1>n || j+y-1>m) {//判断边界 
						return 0;
					}
					s[i+x-1][j+y-1]-=op;
					if(s[i+x-1][j+y-1]<0) {
						return 0;
					}
				}
			}
		}
	}
	for(int i=1; i<=n; i++){
		for(int j=1; j<=m; j++){
			if(s[i][j]) {//最后看能不能 
				return 0;
			}
		}
	}
	return 1;
}
int main() {
	cin>>n>>m;
	for(int i=1; i<=n; i++) {
		for(int j=1; j<=m; j++) {
			scanf("%lld",&a[i][j]);
			sum+=a[i][j];//算的总和 
		}
	}
	for(int i=1; i<=n; i++) {
		for(int j=1; j<=m; j++) {
			if(sum%(i*j)==0) {//可行性优化 
				if(find(i,j)==1) {
					ans=min(ans,sum/(i*j));
				}
			}
		}
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：flrs (赞：0)

[P2484 [SDOI2011]打地鼠](https://www.luogu.org/problemnew/show/P2484)

打这道题是因为~~没想到这道题可以用一维差分来做~~没练过二维差分，想试试手，结果发现大问题。

开始拿80分怎么都找不到错，80分代码如下：
```cpp
#include<iostream>
#include<cstdio>
#define rg register
#define il inline
using namespace std;
const int Maxans=1000000005;
int m,n,ans=Maxans,count;
int mice[105][105];
int copym[105][105];
il int check(int r,int c)
{
	int ans=0;
	if(count%(r*c)!=0) return Maxans;
	for(rg int i=1;i<=m;++i) for(rg int j=1;j<=n;++j) mice[i][j]=copym[i][j];
	for(rg int i=1;i<=m-r+1;++i) for(rg int j=1;j<=n-c+1;++j)
	{
		if(mice[i][j]<0) return Maxans;
		else if(mice[i][j]==0) continue;
		else{
			ans+=mice[i][j]; //cout<<i<<' '<<j<<' '<<' '<<mice[i][j]<<endl;
			mice[i+r][j+c]-=mice[i][j];
			mice[i+r][j]+=mice[i][j];
			mice[i][j+c]+=mice[i][j];
			mice[i][j]=0;
		}
	}
	for(rg int i=1;i<=m;++i)
	for(rg int j=n-c+2;j<=n;++j)
	if(mice[i][j]) return Maxans;
	for(rg int i=m-r+2;i<=m;++i)
	for(rg int j=1;j<=n-c+2;++j)
	if(mice[i][j]) return Maxans;
	return ans;
}
int main(void)
{
	scanf("%d%d",&m,&n);
	for(rg int i=1;i<=m;++i) for(rg int j=1;j<=n;++j)
	scanf("%d",&mice[i][j]),count+=mice[i][j],copym[i][j]=mice[i][j];
	for(rg int i=m;i>=1;--i)
	for(rg int j=n;j>1;--j)
	copym[i][j]-=copym[i][j-1];
	for(rg int j=n;j>=1;--j)
	for(rg int i=m;i>1;--i)
	copym[i][j]-=copym[i-1][j];
	for(rg int r=1;r<=m;++r) for(rg int c=1;c<=n;++c)
	ans=min(ans,check(r,c));
	printf("%d\n",ans);
}
```
怎么说呢犯错可能和本人有强迫症有关，在check最后检验时愿检验多的点，严格限制了边界（实际上我还是多检验了一个点，就是后文说的越界的点）。
```cpp
	for(rg int i=1;i<=m;++i)
	for(rg int j=n-c+2;j<=n;++j)
	if(mice[i][j]) return Maxans;
	for(rg int i=m-r+2;i<=m;++i)
	for(rg int j=1;j<=n-c+2;++j)
	if(mice[i][j]) return Maxans;
	return ans;
 ```
 但实际上，我并没有注意到当c=1时，第二个for循环中j会越界（第一个因为设置的上界所以不会有问题，越界也进不去）。
 
 后来我虽然发现了，但因为我的数组大小不是卡线的，所以我并不认为越界会有影响。但在和wdc大佬的严谨分析后，我发现犯此错误的根本原因在于对二维差分的本质理解不够透彻。
 
 且看我差分代码：
 ```cpp
    for(rg int i=m;i>=1;--i)
	for(rg int j=n;j>1;--j)
	copym[i][j]-=copym[i][j-1];
	for(rg int j=n;j>=1;--j)
	for(rg int i=m;i>1;--i)
	copym[i][j]-=copym[i-1][j];
 ```
 我从前认为即使越界了，越界的部分的数值也应该是0，因为整个数组最后每个值的前缀和应该都为0。但是我在处理差分时并没有对这一部分的数据进行差分，而后却在修改区间的过程中用到了这些数，所以实际上越界的数据是不一定为零的。
因此我WA了点1和点7。

据此，我们可以得到两种改法：

其一：改边界

其二：在差分的时候多往后处理一位，如下：
```cpp
	for(rg int i=m+1;i>=1;--i)
	for(rg int j=n+1;j>1;--j)
	copym[i][j]-=copym[i][j-1];
	for(rg int j=n+1;j>=1;--j)
	for(rg int i=m+1;i>1;--i)
	copym[i][j]-=copym[i-1][j];
```
然后注意在初始化的时候记得也把范围改了就好了。

总结上述错误，学习算法应时深入了解其本质才能尽量在实现中避免犯玄学错误。

最后放上正确代码祭，希望以后不要再犯qwq：

```cpp
#include<iostream>
#include<cstdio>
#define rg register
#define il inline
using namespace std;
const int Maxans=1000000005;
int m,n,ans=Maxans,count;
int mice[105][105];
int copym[105][105];
il int check(int r,int c)
{
    int ans=0;
    if(count%(r*c)!=0) return Maxans;
    for(rg int i=1;i<=m;++i) for(rg int j=1;j<=n;++j) mice[i][j]=copym[i][j];
    for(rg int i=1;i<=m-r+1;++i) for(rg int j=1;j<=n-c+1;++j)
    {
        if(mice[i][j]<0) return Maxans;
        else if(mice[i][j]==0) continue;
        else{
            ans+=mice[i][j];
            mice[i+r][j+c]-=mice[i][j];
            mice[i+r][j]+=mice[i][j];
            mice[i][j+c]+=mice[i][j];
            mice[i][j]=0;
        }
    }
    for(rg int i=1;i<=m;++i)
    for(rg int j=n-c+2;j<=n;++j)
    if(mice[i][j]) return Maxans;
    for(rg int i=m-r+2;i<=m;++i)
    for(rg int j=1;j<=n-c+1;++j)
    if(mice[i][j]) return Maxans;
    return ans;
}
int main(void)
{
    scanf("%d%d",&m,&n);
    for(rg int i=1;i<=m;++i) for(rg int j=1;j<=n;++j)
    scanf("%d",&mice[i][j]),count+=mice[i][j],copym[i][j]=mice[i][j];
    for(rg int i=m;i>=1;--i)
    for(rg int j=n;j>=1;--j)
    copym[i][j]-=copym[i][j-1];
    for(rg int j=n;j>=1;--j)
    for(rg int i=m;i>=1;--i)
    copym[i][j]-=copym[i-1][j];
    for(rg int r=1;r<=m;++r) for(rg int c=1;c<=n;++c)
    ans=min(ans,check(r,c));
    printf("%d\n",ans);
}
```

最后sincerely感谢这道题的测试数据，助我发现错误【捂脸】。

全文终。

---

## 作者：aiyougege (赞：0)

我都有点怀疑是不是数据太水了, 因为我竟然写一写就过了.
#### Solution
　　首先发现这道题不存在单调性.举个例子如果$3\times 3$的锤子能全打完, 但是$2\times 2$的锤子却不能打完, 因此不能通过二分锤子的长和宽来做.

　　但是我发现如果$4\times 4$的锤子能全部打完, 那么$2\times 2$的锤子肯定也行, 因为$4\times 4$包含$2\times 2$.而且发现如果一行有$k$个石子, 那么长度为$d$的锤子只有当$d|k$的时候才可能可以.

　　**行列的无关性**: 即如果每一行都能被$r\times 1$的锤子搞掉, 每一列都能被$1\times c$的锤子搞掉, 那么整个图一定能被$r\times c$的锤子搞掉.这个东西我也不会严格证明……
　　于是可以这么做:
- 找出所有行石子数目的最大公约数, 锤子的长度肯定是它的约数.
- 找出所有列石子数目的最大公约数, 锤子的宽度肯定是它的约数.
- 从大到小枚举所有行石子数目的最大公约数的约数, 判断能否搞掉所有行.
- 列同上.

　　**如何判断一行能否被$r\times 1$的锤子消去?**:第一个位置必须被消去, ……, 直到不足$r$个位置.
  
#### Code
```c++
#include<cstdio>
#include<cmath>
#define N 105
using namespace std;

int map[N][N];
int h[N],l[N];
int n,m;

int gcd(int i,int j){return j?gcd(j,i%j):i;}

bool XiaoHang(int ha,int te){
    int temp[N];
    for(int i=1;i<=m;++i)temp[i]=map[ha][i];
    for(int i=1;i<=m-te+1;++i){
        if(temp[i]<0)return false;
        int jian=temp[i];
        for(int j=i;j<=i+te-1;++j)
            temp[j]-=jian;
    }
    for(int i=m-te+2;i<=m;++i)
        if(temp[i])return false;
    return true;
}

bool XiaoLiee(int li,int te){
    int temp[N];
    for(int i=1;i<=n;++i)temp[i]=map[i][li];
    for(int i=1;i<=n-te+1;++i){
        if(temp[i]<0)return false;
        int jian=temp[i];
        for(int j=i;j<=i+te-1;++j)
            temp[j]-=jian;
    }
    for(int i=n-te+2;i<=n;++i)
        if(temp[i])return false;
    return true;
}

int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;++i)
        for(int j=1;j<=m;++j)
            scanf("%d",&map[i][j]);
    int ans=0;
    for(int i=1;i<=n;++i)
        for(int j=1;j<=m;++j)
            h[i]+=map[i][j],l[j]+=map[i][j],ans+=map[i][j];
    int H=h[1],L=l[1];
    for(int i=2;i<=n;++i)H=gcd(H,h[i]);
    for(int i=2;i<=n;++i)L=gcd(L,l[i]);

    int te,flag,ans1,ans2;
    for(int q=1;q<=sqrt(H);++q)if(H%q==0){
        te=H/q,flag=true;
        for(int i=1;i<=n&&flag;++i)
            if(!XiaoHang(i,te))flag=false;
        if(flag){ans1=te;break;}
    }
    for(int q=1;q<=sqrt(L);++q)if(L%q==0){
        te=L/q,flag=true;
        for(int i=1;i<=m&&flag;++i)
            if(!XiaoLiee(i,te))flag=false;
        if(flag){ans2=te;break;}
    }
    printf("%d",ans/(ans1*ans2));
    return 0;
}

```

---

## 作者：Mogician (赞：0)

#pascal题解

本题其实就是模拟，但如果暴力n\*m枚举r、c再判断顶多60。通过观察题目发现每次必定打掉r\*c只地鼠，所以当地鼠总数mod(r\*c)=0时才判断（可行性剪枝），还有当打击次数小于已经得出的答案时才判断（最优性剪枝），还是比较水的一道题。

```cpp
var a:array[0..200,0..200] of longint;
    i,j,k,t,m,n,p,ans,r,c:longint;
function pd(r,c:longint):boolean;//判断
var f:array[0..200,0..200] of longint;
    i,j,x,y:longint;
begin
 f:=a;
 for i:=1 to m-r+1 do
  for j:=1 to n-c+1do
   for x:=r-1 downto 0 do
    for y:=c-1 downto 0 do//暴力模拟
     begin
      dec(f[i+x,j+y],f[i,j]);
      if f[i+x,j+y]<0 then exit(false);
     end;
 exit(true);
end;
begin
 assign(input,'233.in');
 reset(input);//关联文件便于调试
 readln(m,n);
 for i:=1 to m do for j:=1 to n do begin read(a[i,j]); inc(t,a[i,j]); end;
 for r:=m downto 1 do
  for c:=n downto 1 do
   if (t mod (r*c)=0)and(r*c>ans) then//剪枝
    if pd(r,c) then ans:=r*c;
 writeln(t div ans);
end.
```

---


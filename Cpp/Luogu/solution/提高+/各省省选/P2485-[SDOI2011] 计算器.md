# [SDOI2011] 计算器

## 题目背景

2024-8-11 update: 新增一组 hack。

## 题目描述

你被要求设计一个计算器完成以下三项任务：

1. 给定 $y,z,p$，计算 $y^z \bmod p$ 的值；
2. 给定 $y,z,p$，计算满足 $xy \equiv z \pmod p$ 的最小非负整数 $x$；
3. 给定 $y,z,p$，计算满足 $y^x \equiv z \pmod p$ 的最小非负整数 $x$。

为了拿到奖品，全力以赴吧！


## 说明/提示

测试点共分为三类，各类测试点占总测试点的比例如下：

| $K=$ | 测试点占比 |
| :--: | :--------: |
| $1$  |   $20\%$   |
| $2$  |   $35\%$   |
| $3$  |   $45\%$   |

所有数据均满足：$1 \leq y,z,p \leq 10^9$，$p$ 是质数，$1 \leq T \leq 10$。

## 样例 #1

### 输入

```
3 1
2 1 3
2 2 3
2 3 3
```

### 输出

```
2
1
2
```

## 样例 #2

### 输入

```
3 2
2 1 3
2 2 3
2 3 3
```

### 输出

```
2
1
0
```

## 样例 #3

### 输入

```
4 3
2 1 3
2 2 3
2 3 3
2 4 3
```

### 输出

```
0
1
Orz, I cannot find x!
0
```

# 题解

## 作者：VenusM1nT (赞：6)

前两问都不难，这个$BSGS$还是比较难的……

我从隔壁的模板题复制的代码，所以写的是$ExBSGS$，比较冗长，虽然泛用性会更高，但是这题没有$P$点用……

对于第一问，直接套快速幂就行，$BSGS$要用到，就顺手解决了

对于第二问，扩欧求解，套费马小定理，数论渣表示一脸懵

对于第三问，$BSGS$硬上就行……

代码比较丑，凑合着看吧……

主程序还是挺简洁的$233$

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
map <ll,ll> m;
ll QuickPow(ll x,ll y,ll p)
{
	ll sum=1;
	while(y)
	{
		if(y&1) sum=sum*x%p;
		x=x*x%p;
		y>>=1;
	}
	return sum%p;
}
ll Gcd(ll x,ll y)
{
	return !x ? y : Gcd(y%x,x);
}
ll ExGCD(ll a,ll b,ll &x,ll &y)
{
	if(!b)
	{
		x=1;
		y=0;
		return a;
	}
	ll g=ExGCD(b,a%b,x,y);
	ll t=x;
	x=y;
	y=t-y*(a/b);
	return g;
}
ll BSGS(ll a,ll b,ll p,ll d)
{
	m.clear();
	b%=p;
	ll t=sqrt(p)+1,now=b,sum=d;
	for(int i=1;i<=t;i++)
	{
		now=now*a%p;
		m[now]=i;
	}
	now=QuickPow(a,t,p);
	for(int i=1;i<=t;i++)
	{
		sum=sum*now%p;
		if(m.count(sum)) return t*i-m[sum];
	}
	return -1;
}
int ExBSGS(int a,int b,int p)
{
	if(p==1) return 0;
	a%=p;
	b%=p;
	if(b==1) return 0;
	if(a==0)
	{
		if(b==0) return 1;
		return -1;
	}
	ll sum=1,tot=0;
	for(ll i=Gcd(a,p);i!=1;i=Gcd(a,p))
	{
		if(b%i) return -1;
		b/=i;
		p/=i;
		sum=sum*(a/i)%p;
		tot++;
		if(b==sum) return tot;
	}
	a%=p;
	ll cnt=BSGS(a,b,p,sum);
	if(cnt==-1) return -1;
	else return cnt+tot;
}
void Solve1()
{
	ll a,b,p;
	scanf("%lld %lld %lld",&a,&b,&p);
	printf("%lld\n",QuickPow(a,b,p));
}
void Solve2()
{
	ll a,b,p,x,y;
	scanf("%lld %lld %lld",&a,&b,&p);
	ll gcd=ExGCD(a,p,x,y);
	if(!(b%gcd))
	{
		ll t=p/gcd;
		x=(((x*b)/gcd)%t+t)%t;
		printf("%lld\n",x);
	}
	else printf("Orz, I cannot find x!\n");
}
void Solve3()
{
	ll a,b,p;
	scanf("%lld %lld %lld",&a,&b,&p);
	ll ans=ExBSGS(a,b,p);
	if(ans==-1) printf("Orz, I cannot find x!\n");
	else printf("%lld\n",ans);
}
int main()
{
	int Time,opt;
	scanf("%d %d",&Time,&opt);
	while(Time--)
	{
		if(opt==1) Solve1();
		else if(opt==2) Solve2();
		else if(opt==3) Solve3();
	}
	return 0;
}
```

---

## 作者：似水年华 (赞：6)

##算法分析

很明显的数论问题。

对于第一种操作，就是简单的快速幂取模运算。

对于第二种操作，扩展欧几里得算法的典型应用。

对于第三种操作，求的是离散对数，需要用到BabyStepGiantStep算法。

##参考程序

```cpp
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <cmath>
#include <cstring>
#include <map>
#define M 100000
#define mul_mod(a,b,c) (((a%c)*(b%c))%c)
using namespace std;
typedef long long LL;
/*FUNCTION*/
LL ksm(LL a,LL k,LL p)
{
    //(a^k)%p;
    if (k==0)
        return 1;
    if (k%2==0)
    {
        LL temp=ksm(a,k/2,p);
        return (temp*temp)%p;
    }
    else
    {
        LL temp=ksm(a,k/2,p);
        return ((temp*temp)%p*(a%p))%p;
    }

}
void gcd(LL a,LL b,LL *d,LL *xx,LL *yy)
{
    //ax+by=gcd(a,b);
    if (b==0)
    {
        *d=a;
        *xx=1;
        *yy=0;
    }
    else
    {
        gcd(b,a%b,d,yy,xx);
        *yy-=*xx*(a/b);
    }
}
LL base_gcd(LL a,LL b)
{
    while (b!=0)
    {
        LL temp=a;
        a=b;
        b=temp%b;
    }
    return a;
}
LL inverse(LL a,LL n)
{
    //To calculate the inverse of a in the mod of P
    //This is used for prime P
    //return ksm(a,p-2,p);
    LL d,x,y;
    gcd(a,n,&d,&x,&y);
    return d==1?(x+n)%n:-1;
}
LL log_mod(LL a,LL b,LL n)
{
    LL m,v,e=1,i;
    m= (LL) sqrt(n+0.5);
    v=inverse(ksm(a,m,n),n);
    map<int,int> x;
    x[1]=0;
    for (i=1;i<m;i++)
    {
        e=mul_mod(e,a,n);
        if(!x.count(e))
            x[e]=i;
    }
    for (i=0;i<m;i++)
    {
        if (x.count(b))
            return i*m+x[b];
        b=mul_mod(b,v,n);
    }
    return -1;
}
void slove1(LL y,LL z,LL p)
{
    cout<<ksm(y,z,p)<<endl;
}
void slove2(LL a,LL b,LL p)
{
    LL e=base_gcd(a,p);
    if (b%e!=0)
    {
        cout<<"Orz, I cannot find x!"<<endl;
        return;
    }
    a=a/e;b=b/e;p=p/e;
    LL x=mul_mod(inverse(a,p),b,p);
    cout<<x<<endl;
}
void slove3(LL y,LL z,LL p)
{
    z=z%p;
    LL ans=log_mod(y,z,p);
    if(ans==-1)
        cout<<"Orz, I cannot find x!"<<endl;
    else
        cout<<ans<<endl;
}
int main()
{
    LL y,z,p,t;
    int kind;
    int i;
    cin>>t>>kind;
    for (i=1;i<=t;i++)
    {
        cin>>y>>z>>p;
        if (kind==1)
            slove1(y,z,p);
        if (kind==2)
            slove2(y,z%p,p);
        if (kind==3)
            slove3(y,z,p);
    }
    return 0;
}
```

---

## 作者：追梦_Chen (赞：6)

**## 这题考察的是对同余已经拓展欧几里得定理的理解和运用，顺带一个模板快速幂**
# 前置姿势
1.快速幂

2.拓展欧几里得定理

3.baby_step_giant_step算法求高次同余方程


------------

# 对于1号操作，我们用快速幂直接求解

```cpp
long long pow_mod(long long a,long long b,long long p){
	long long ans=1;
	while(b){
		if(b&1){
			ans=(long long)ans*a%p;
		}
		a=(long long)a*a%p;
		b=b/2;
	}
	return ans;
}
```

# 对于2号操作，就是一个拓展欧几里得定理的运用

```cpp
long long exgcd(long long a,long long b,long long &x1,long long &y2){
	if(b==0){
		x1=1,y2=0;
		return a;
	}
	long long d=exgcd(b,a%b,x1,y2);
	long long z=x1;x1=y2;y2=z-y2*(a/b);
	return d;
}
特别注意，根据提议要求，我们要先判断z%gcd(y,p)是否为0，若不为0，则说明z不能整除gcd(y,p)，不满足裴蜀定理，方程误解
```

# 对于3号操作，，其实就是高次同余方程求解，我们可以用baby_step_giant_step算法


```cpp
long long baby_step_giant_step(long long a,long long b,long long p){
	map<long ,long>hash;
	hash.clear();
	b%=p;
	int t=(int)sqrt(p)+1;
	for(int j=0;j<t;j++){
		int val=(long long)b*pow_mod(a,j,p)%p;
		hash[val]=j;
	}
	a=pow_mod(a,t,p);
	if(a==0){
		if(b==0){
			return 1;
		}else{
			return -1;
		}
	}
	for(int i=0;i<=t;i++){
		int val=pow_mod(a,i,p);
		int j=hash.find(val)==hash.end()?-1:hash[val];
		if(j>=0&&i*t-j>=0){
			return i*t-j;
		}
	}
	return -1;//无解时返回-1
}
```

##### ##### ###### 嗯！前置姿势准备好了，我们就可以直接贴代码了！

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <cstdlib>
#include <map>
using namespace std;
long long pow_mod(long long a,long long b,long long p){
	long long ans=1;
	while(b){
		if(b&1){
			ans=(long long)ans*a%p;
		}
		a=(long long)a*a%p;
		b=b/2;
	}
	return ans;
}//快速幂求解 
long long exgcd(long long a,long long b,long long &x1,long long &y2){
	if(b==0){
		x1=1,y2=0;  
		return a; 
	}
	long long d=exgcd(b,a%b,x1,y2);
	long long z=x1;x1=y2;y2=z-y2*(a/b);
	return d;
}//拓展欧几里得算法 
long long baby_step_giant_step(long long a,long long b,long long p){
	map<long ,long>hash;
	hash.clear();
	b%=p;
	int t=(int)sqrt(p)+1;
	for(int j=0;j<t;j++){
		int val=(long long)b*pow_mod(a,j,p)%p;
		hash[val]=j;
	}
	a=pow_mod(a,t,p);
	if(a==0){
		if(b==0){
			return 1;
		}else{
			return -1;
		}
	}
	for(int i=0;i<=t;i++){
		int val=pow_mod(a,i,p);
		int j=hash.find(val)==hash.end()?-1:hash[val];
		if(j>=0&&i*t-j>=0){
			return i*t-j;
		}
	}
	return -1;
}//求高次同余方程 
int main(){
	long long t,k,z,y,p;
	scanf("%lld %lld",&t,&k);  //注意要开long long 类型，否则会溢出 
	while(t--){
		if(k==1){
			scanf("%lld%lld%lld",&y,&z,&p);
			printf("%lld\n",pow_mod(y,z,p));
		}else if(k==2){
			scanf("%lld%lld%lld",&y,&z,&p);
			long long x=0,yy=0,gcd=0;
			gcd=exgcd(y,p,x,yy);	
			if(z%gcd==0){
				long long tmp=p/gcd;
				x=(((x*z)/gcd)%tmp+tmp)%tmp;  //对x进行处理 
				printf("%lld\n",x);
			}else{
				printf("Orz, I cannot find x!\n");
			}	
		}else if(k==3){
			scanf("%lld%lld%lld",&y,&z,&p);
			long long ans=baby_step_giant_step(y,z,p);
			if(ans==-1){  //方程无解 
				printf("Orz, I cannot find x!\n");
			}else{
				printf("%lld\n",ans);
			}
		}
	}
	return 0;
}
```

---

## 作者：hjyowl (赞：5)

### 思路

本题是一个比较模板化的题目。

#### 一操作

考虑使用快速幂。

快速幂，只需要把 $k$ 变成二进制即可实现 $\Theta(\log k)$ 的时间复杂度。

实现方法：

```cpp
long long qmi(long long a,long long k,long long p){
	long long res = 1;
	while (k){
		if (k & 1){
			res = (res * a) % p;
		}
		a = (a * a) %p;
		k >>= 1;
	}
	return res;
}
```

### 二操作

考虑使用乘法逆元，除一个数等于乘上那个数的逆元，当 $p$ 为质数时，$x$ 的逆元为 $x^{p-2}$。

计算 $x^{p-2}$ 也可以使用快速幂。

### 三操作

考虑使用 BSGS 算法来进行计算，具体实现代码如下：

```cpp
long long bsgs(long long a,long long b,long long p){
	unordered_map<long long,long long>mp;
	if (1 % p == b % p){
		return 0;
	}
	long long k = sqrt(p) + 1;
	for (long long i = 0,j = b % p; i < k; i ++ ){
		mp[j] = i;
		j = (long long)j * a % p;
	}
	long long t = 1 % p;
	for (long long i = 0; i < k; i ++ ){
		t = (long long)t * a % p;
	}
	for (long long i = 1,j = t; i <= k; i ++ ){
		if (mp.count(j)){
			return (long long)i * k - mp[j];
		}
		j = (long long)j * t % p;
	}
	return -1;
}
```

### 最终代码

只需要把给出的那些东西合并起来即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
long long qmi(long long a,long long k,long long p){
	long long res = 1;
	while (k){
		if (k & 1){
			res = (res * a) % p;
		}
		a = (a * a) %p;
		k >>= 1;
	}
	return res;
}
long long bsgs(long long a,long long b,long long p){
	unordered_map<long long,long long>mp;
	if (1 % p == b % p){
		return 0;
	}
	long long k = sqrt(p) + 1;
	for (long long i = 0,j = b % p; i < k; i ++ ){
		mp[j] = i;
		j = (long long)j * a % p;
	}
	long long t = 1 % p;
	for (long long i = 0; i < k; i ++ ){
		t = (long long)t * a % p;
	}
	for (long long i = 1,j = t; i <= k; i ++ ){
		if (mp.count(j)){
			return (long long)i * k - mp[j];
		}
		j = (long long)j * t % p;
	}
	return -1;
}
int main(){
	long long n,T;
	cin >> n >> T;
	if (T == 1){
		for (long long i = 1; i <= n; i ++ ){
			long long a,b,p;
			cin >> a >> b >> p;
			cout << qmi(a,b,p) << endl;
		}
	} 
	else if (T == 2){
		for (int i = 1;  i<= n; i ++ ){
			int a,b,p;
			cin >> a >> b >> p;
			a %= p,b %= p;
			if (a == 0 && b != 0){
				cout << "Orz, I cannot find x!" << endl;
			}
			else{
				cout << qmi(a,p - 2,p) * b % p << endl;
			}
		}
	}
	else{
		for (long long i = 1; i <= n; i ++ ){
			long long a,b,p;
			cin >> a >> b >> p;
			if (a % p == b % p){
				cout << 1 << endl;
				continue;
			}
			a %= p;
			long long t = bsgs(a,b,p);
			if (a == 0 && b == 0){
				cout << 1 << endl;
			}
			else if (a == 0 && b != 0){
				cout << "Orz, I cannot find x!" << endl;
			}
			else{
				if (t == -1){
					cout << "Orz, I cannot find x!" << endl;
				}
				else{
					cout << t << endl;
				}
			}
		}
	}
	return 0;
}
```

---

## 作者：TJB_LHY (赞：2)

# 思路

题目大意：有三项任务：第一个任务直接套用[快速幂模板](https://www.luogu.com.cn/problem/P1226)，该任务时间复杂度为 $O(\log_2 z)$；第二个任务就是求 $x \equiv \frac{z}{y} \pmod p$，使用 $y$ 在[模 $p$ 意义下的乘法逆元](https://www.luogu.com.cn/problem/P3811)乘以 $z$ 即可（注意！答案需要取模），若使用 Exgcd 求逆元，该任务时间复杂度为 $O(\log_2\max(p,y))$；第三个任务才是压轴，我们讲细点。

首先，我们考虑暴力求解，因为 $p$ 为质数，根据费马小定理可知 $a^{p-1}\equiv1 \pmod p$，所以当 $x> p-1$ 时重复 $a^x\pmod p$ 的计算是无意义的，复杂度即是 $O(p)$，不可以通过此题。接下来，我们需要一段神秘的~~咒语~~算法 [BSGS](https://www.luogu.com.cn/problem/P3846)：我们现将 $x$ 拆为 $a\times b-c$，变形同余式得 $y^{a\times b-c} \equiv z \pmod p$。

同余式两边同时乘以 $y^c$ 得：$y^{a\times b} \equiv z\times y^{c} \pmod p$; 推出式子后，我们设 $a=\sqrt p$（此时枚举复杂度最少），然后使用映射标记所有 $z\times y^c$（由上面的推理可知：当 $c> p-1$ 时重复 $y^c\pmod p$ 的计算是无意义的，所以只需映射 $0\le c<p$ 的即可）。

最后枚举 $b$ 查找 $y^{a\times b} \pmod p$ 是否存在映射值就完成啦～（注意事项：有几种情况是需要特判的，代码中说明）由于两次枚举的上限都是 $\sqrt p$，所以该任务时间复杂度为 $O(\sqrt p)$。

### 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
#define U unsigned
using namespace std;
ll y,z,p,k;
ll sqr(ll a,ll b){
    ll num=1;
    a%=p;
    while(b){
        if(b&1)num=num*a%p;
        a=a*a%p;
        b>>=1;
    }
    return num;
}//快速幂
ll res,ans;
ll exgcd(ll a,ll b,ll &x,ll &y){
	if(b==0){
		x=1;
		y=0;
		return a;
	}
	res=exgcd(b,a%b,y,x);
	y-=a/b*x;
	return res;
}//拓展欧几里得算法
map<ll,ll>vis;
ll find(){
    vis.clear();
    ll a,b=ceil(sqrt(p)),c,k=z%p,num=1;
    for(c=0;c<b;c++,k=y*k%p)vis[k]=c;//映射
    for(a=1;a<=b;a++){//枚举查找
        num=sqr(y,a*b);
        if(vis.count(num)){
            return a*b-vis[num];
        }
    }
    return -1;
}//BSGS算法
int main() {
	cin.tie(0)->sync_with_stdio(0);//快读
    ll t,a,b;
    cin>>t>>k;
    while(t--){
        cin>>y>>z>>p;
        if(k==1)cout<<sqr(y,z)<<'\n';//任务一
        else if(k==2){//求逆元
            exgcd(y,p,a,b);
            if(z%res!=0)cout<<"Orz, I cannot find x!\n";
            else cout<<(a*z/res%p+p)%p<<'\n';
        }
        else{
            if(y%p==0){//特判
                if(z%p==0)cout<<"1\n";//0的0次方没有意义，所以为1
                else cout<<"Orz, I cannot find x!\n";//所有y的x次方都为0，无解
            }
            else if(z%p==1)cout<<"0\n";//答案必定为0
            else if(y%p==z%p)cout<<"1\n";//答案必定为1，其他前面特判掉了
            else {
                ans=find();
                if(ans!=-1)cout<<ans<<'\n';
                else cout<<"Orz, I cannot find x!\n";
            }
        }
    }
	return 0;
}
```

完结撒花，求通过。

---

## 作者：cqsunny (赞：1)

这道题主要是考察几个数论的模板。

首先你要保证 $y$ 和某些 $z$（不包括在指数上的）都要模 $p$，保证。

---

**询问类型 1**：计算 $y^z \bmod p$ 的值。显然，这是一个快速幂的模板。

具体过程：求 $y^z \bmod p$，若 $z$ 是偶数，就可以转化为 ${y^{z/2}}^2$，若 $z$ 是奇数，则将其转化为偶数的形式。时间复杂度为 $O(\log z)$。

```cpp
long long qpow(long long x, int y, const int p){
    long long s = 1;
    while(y){
    if(y & 1){
        s = s * x % p;
    }
    x = x * x % p;
    y >>= 1;
    }
    return s;
}
```

**询问类型 2**：计算满足 $x y \equiv z \pmod p$ 的最小非负整数 $x$。这就是求乘法逆元，$x = z \times y^{p - 2} \bmod p$。

具体推导如下：由费马小定理可知，$x^{p - 1} \equiv 1 \pmod p$。因此，在原式左右两边同时乘上 $y^{p - 2}$，把左边的 $y$ 消去，得到 $x = z \times y^{p - 2} \pmod p$。

注意求出值后带回原式进行验证。

```cpp
long long inv(long long x, long long y, const int p){
    return y * qpow(x, p - 2, p) % p;
}
```

**询问类型 3**：计算满足 $y^x \equiv z \pmod p$ 的最小非负整数 $x$。这个就是 BSGS 算法。

首先考虑暴力做法，枚举 $x$ 判断是否满足。由欧拉定理可知，$x < \varphi(p) < 2 \times p$。时间复杂度为 $O(p)$，显然过不了。

考虑把 $x$ 表示成 $n \cdot t - m$。原式变为 $y^{n \cdot t - m} \equiv z \pmod p$。左右两边同时乘上 $y^{m}$，得到 $y^{n \cdot t} \equiv z \times y^m \pmod p$，其中 $m \in [0, t-1], n \in [1, t]$。

根据上面的式子，我们可以固定 $t = \lceil \sqrt{p} \rceil$，先枚举 $m$，将计算出的值存在哈希表内（相同值存最大的 $m$），再枚举 $n$ 计算 $y^{n \cdot t}$，在哈希表中查找。若找到则更新 $x = n \cdot t - m$ 的最小值。如果无解返回 -1。

最后注意特判：

- 当 $z \bmod p = 1$ 时，$x = 0$ 是解。

- 当 $y \bmod p = 0$ 时，若 $z \bmod p = 0$ 则 $x = 1$，否则无解。

- 当 $y \bmod p = z \bmod p$ 时，$x = 1$ 是解。

```cpp
map<long long, long long> mp;
long long bsgs(long long a, long long b, const int p) {
    a %= p, b %= p;
    if(b == 1) return 0;// a^0 ≡ 1
    if(a == 0){
        if(b == 0) return 1;// 0^k≡0 (k>=1)
        return -1;
    }
    if(a == b) return 1;// a^1 ≡ a
    mp.clear();
    long long t = ceil(sqrt(p));
    long long s = b;
    for(long long m = 0; m < t; ++ m){
        mp[s] = m;
        s = s * a % p;
    }
    long long tt = 1;
    long long base = qpow(a, t, p);
    long long ans = -1;
    for(long long n = 1; n <= t; ++ n){
        tt = tt * base % p;
        if(mp.count(tt)){
            long long m = mp[tt];
            long long x = n * t - m;
            if(qpow(a, x, p) == b){
                if(ans == -1 || x < ans) ans = x;
            }
        }
    }
    return ans;
}
```

完整代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
map<long long, long long> mp;
long long qpow(long long x, int y, const int p){
    long long s = 1;
    while(y){
    if(y & 1){
        s = s * x % p;
    }
    x = x * x % p;
    y >>= 1;
    }
    return s;
}
long long inv(long long x, long long y, const int p){
    return y * qpow(x, p - 2, p) % p;
}
long long bsgs(long long a, long long b, const int p) {
    a %= p, b %= p;
    if(b == 1) return 0;// a^0 ≡ 1
    if(a == 0){
        if(b == 0) return 1;// 0^k≡0 (k>=1)
        return -1;
    }
    if(a == b) return 1;// a^1 ≡ a
    mp.clear();
    long long t = ceil(sqrt(p));
    long long s = b;
    for(long long m = 0; m < t; ++ m){
        mp[s] = m;
        s = s * a % p;
    }
    long long tt = 1;
    long long base = qpow(a, t, p);
    long long ans = -1;
    for(long long n = 1; n <= t; ++ n){
        tt = tt * base % p;
        if(mp.count(tt)){
            long long m = mp[tt];
            long long x = n * t - m;
            if(qpow(a, x, p) == b){
                if(ans == -1 || x < ans) ans = x;
            }
        }
    }
    return ans;
}
int main(){
    int T, x;
    scanf("%d %d", &T, &x);
    while(T --){
        int y, z, p;
        scanf("%d %d %d", &y, &z, &p);
        if(x == 1){
            y %= p;
            printf("%lld\n", qpow(y, z, p));
        }
        else if(x == 2){
            y %= p, z %= p;
            long long t = inv(y, z, p);
            if (t * y % p == z){
                printf("%lld\n", t);
            }
            else{
                printf("Orz, I cannot find x!\n");
            }
        }
        else{
            long long t = bsgs(y, z, p);
            if(t == -1){
                printf("Orz, I cannot find x!\n");
            }
            else{
                printf("%lld\n", t);
            }
        }
    }
    return 0;
}
```

---

## 作者：fish_love_cat (赞：1)

原题三合一。

+ 当 $K=1$，左转 P1226。
+ 当 $K=2$，$x=\frac{z}{y}\pmod p$，右转 P2613。
+ 当 $K=3$，右转 P3846。

嗯做完了。

---

但是这题一般是被当做 BSGS 例题来讲的~~根本原因我认为是因为 P3846 数据太弱了~~，所以讲几个容易写挂的地方吧。

首先输入顺序不要挂了。有个用户名里包含 Sunset 的同学因此虚空调试 BSGS 长达 1h，我不知道是不是在写这题。

取根号时要向上取整！！！不然会 TLE on #2，警钟长鸣。

填数只填一次，不要覆盖掉已经填好的数。

大常数选手用 `unordered_map` 跑的比 `map` 快。

打标记一定不要打个 `0` 上去，虽然答案是这样的但是这样打标记读不出来的。最好是加个一进去，返回时减一。

本题虽然 $p$ 是质数但不一定最大，要提前取模并把非互质情况判掉。

嗯差不多这些吧。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define flc_INF LLONG_MAX
int qpow(int a,int b,int p=flc_INF){
	int ans=1;
	if(b==0)return 1;
	while(b){
		if(b&1)ans*=a,ans%=p;
		a*=a,b>>=1,a%=p;
	}
	return ans;
}
int ni(int a,int p){return qpow(a,p-2,p);}
int BSGS(int x,int n,int p){
    if(n==1)return 0;
    if(x%p==n%p)return 1;
    if(x%p==0)return -1;
    n%=p,x%=p;
    int inx=ni(x,p);
    int B=sqrt(p)+1;
    int Bb=qpow(x,B,p);
    unordered_map<int,int>mp;
    for(int i=0,flc=n;i<B;i++,flc=flc*inx%p)
        if(!mp[flc])mp[flc]=i+1;
    for(int i=0,flc=1;i<=B;i++,flc=flc*Bb%p)
        if(mp[flc])return (i*B+mp[flc]-1)%p;
    return -1;
}
signed main(){
    int t,k;
    cin>>t>>k;
    while(t--){
        int y,z,p;
        cin>>y>>z>>p;
        if(k==1)cout<<qpow(y,z,p);
        else if(k==2){
            if(y%p==0)cout<<"Orz, I cannot find x!";
            else cout<<z*ni(y,p)%p;
        }else{
            int ans=BSGS(y,z,p);
            if(ans==-1)cout<<"Orz, I cannot find x!";
            else cout<<ans;
        }
        puts("");
    }
    return 0;
}
```

Upd：把自己 hack 了。

---

## 作者：dread (赞：1)

- 这道题算是比较综合的一道数论的题目。
- 输入1时可以直接用快速幂解决 ~~（别告诉我你连快速幂都不会）~~
下面就是代码:

```cpp
ll quickmul(ll a, ll b, ll mod) {//快速乘 
	ll re = 0;
	while(b) {
		if(b & 1)	re += a;
		re %= mod;
		b >>= 1;
		a += a;
		a %= mod;
	}
	return re;
}

ll quickpow(ll a, ll b, ll mod) {//快速幂 
	ll re = 1;
	while(b) {
		if(b & 1)	re = quickmul(re, a, mod);
		re %= mod;
		b >>= 1;
		a = quickmul(a, a, mod);
		a %= mod;
	}
	return re;
}

```


- 输入2时用一个扩展gcd解决：把$x*y ≡ z\mod p$转换成$xy + kp = z$	就可以解决了。
下面是代码：
```cpp
ll exgcd(ll a, ll b, ll &x, ll &y) {
	if(b == 0) {
		x = 1;
		y = 0;
		return a;
	}
	ll d = exgcd(b, a % b, x, y);
	ll z = x;
	x = y;
	y = z - (a / b) * y;
	return d;
}
```

- 输入3时就变成了一个离散对数问题，但是这道题的p是质数不用考虑合数的算法，主要思想是分块:
设$x = A*\sqrt{p} + B$
$a^ {A*\sqrt{p} + B}≡b\mod p$
$a^ A*\sqrt{p}≡b * a^ {-B}\mod p$
求出$A,B$就能算出$x$
复杂度为O($\sqrt{p}$)；
最后上整个程序：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

int t, type;
ll a, b, p;
map<ll, ll> mp;

ll read() {
	ll s = 0, f = 1;
	char ch;
	for(; ch < '0' || ch > '9'; ch = getchar()) if(ch == '-') f = -1;
	for(; ch >= '0' && ch <= '9'; ch = getchar()) s = (s << 1)+(s << 3) + ch - '0';
	return s * f;
}

ll quickmul(ll a, ll b, ll mod) {
	ll re = 0;
	while(b) {
		if(b & 1)	re += a;
		re %= mod;
		b >>= 1;
		a += a;
		a %= mod;
	}
	return re;
}

ll quickpow(ll a, ll b, ll mod) {
	ll re = 1;
	while(b) {
		if(b & 1)	re = quickmul(re, a, mod);
		re %= mod;
		b >>= 1;
		a = quickmul(a, a, mod);
		a %= mod;
	}
	return re;
}

ll exgcd(ll a, ll b, ll &x, ll &y) {
	if(b == 0) {
		x = 1;
		y = 0;
		return a;
	}
	ll d = exgcd(b, a % b, x, y);
	ll z = x;
	x = y;
	y = z - (a / b) * y;
	return d;
}

ll gcd(ll xx, ll yy) {
	return !yy ? xx : gcd(yy, xx % yy);
}

int main() {
	freopen ("calc.in", "r", stdin);
	freopen ("calc.out", "w", stdout);
	scanf("%d%d", &t, &type);
	while(t--) {
		ll x, y;
		a = read();
		b = read();
		p = read();
		if(type == 1) {
			printf("%lld\n", quickpow(a, b, p));
		}
		if(type == 2) {
			ll d = exgcd(a, p, x, y);
			if(b % d)	puts("Orz, I cannot find x!");
			else {
				ll temp = p / d;
				while(x < 0)	x += temp;
				printf("%lld\n", ((x * b / d) % temp + temp) % temp); 
			}
		}
		if(type == 3) {
			bool flag = 0;
			if(b % gcd(a, p)) {
				puts("Orz, I cannot find x!");
				continue;
			}
			a %= p;
			b %= p;
			mp.clear();
			int m = ceil(sqrt(p));
			for(int i = 0; i < m; ++i, b = quickmul(b, a, p))	mp[b] = i;
			for(int i = 1, j = a = quickpow(a, m, p); i <= m ; ++i, j = quickmul(j, a, p)) {
				if(mp.count(j) && i * m >= mp[j]) {
					flag = 1;
					printf("%lld\n", i * m - mp[j]);
					break;
				}	
			}
			if(!flag)	puts("Orz, I cannot find x!");
		}
	}
	return 0;
}
```

---

## 作者：ZORO (赞：1)

# 题意：


操作一：快速幂

操作二：$Exgcd$

操作三：$BSGS$

至于$BSGS$是什么怎么写，关于这方面的题解已经烂大街了

安利一下我的$BSGS$博客[传送门](https://www.cnblogs.com/Liuz8848/p/11373392.html)

为了让这篇题解突出特色~~其实是为了通过~~，这篇博客主要针对$BSGS$的特判讲。相信很多人写$BSGS$模板都会拿到$75pts$的好成绩。如果把鼠标放到$WA$上面会发现希望你输出$'0'$。

仔细看不对，发现其实是期望你输出$O$，也就是无解的情况。
其实你只要加上“如果$gcd(y,p)!=1$则无解”的特判，那么你就$AC$了。

# $Solution$
**这道题有三个特判，注意顺序**

首先你可以将左右两边$a%c,b%c$，这样性质不会改变

$BSGS$的前提是$a^x\equiv b(mod\ c),gcd(a,c)==1$

这道题保证了$p$是质数，但是并没有提到给出的$y< p$，所以当且仅当$y$是$p$的倍数时，$BSGS$无解。这时候经过取模操作，$a=0$，直接求$gcd$若不等于$1$则无解就可以了

有人说扩展$BSGS$不是可以解决吗，（没有学过的可以看我上面的博客~~厚颜无耻~~），但是你考虑一个数的倍数多少次方模另一个数还是$0$

哎？发现问题了，那$0$的情况怎么办

**对了，实际上这道题有一个$bug$，就是$0^0$**

**为什么这么说呢，在正常情况下$0^0$是无意义的，但在取模运算下有可能取模后变成了$0$，所以$0^0$是有意义的，需要特判**

1.我们先分两种情况考虑，$a$本来就是$0$或者$a$本来不是$0$，若$a$本来就是$0$则只有$b=1$时有解，$x_min=1$，但因为这道题保证$a\geq1$所以只用考虑第二种情况

2.$a$取模后是$0$，这说明$a$在取模前是$c$的倍数，再考虑$b$。

3.当$b$是$0$时，显然$a^x(x!=0)$取模后一定是$0$，所以取最小值$1$输出即可。

4.当$b$是$1$时，只有$a^0$取模后是$1$,这时$0^0$有意义是因为未取模前是成立的。

这两种情况外，方程无解
--
综上，这道题在判无解前要考虑这两种特殊情况

按照以下顺序特判

**特判1：if(a==0&&b==0) return 1;**

**特判2：if(b==1) return 0;**(任何数的0次方都是1，0除外)

因为这道题保证不为$0$，而且要求输出最小解，所以直接返回$0$

**特判3:if(gcd(a,b)！=1)return -1;**

你们的$75pts$

--------------
最后提供一组$Hack$数据

1 3

3 3 3

$Code$
--
```
#include<cstdio>
#include<iostream>
#include<cstring>
#include<map>
#include<cmath>
#define ll long long 
#define re register
#define MOD 76543
using namespace std;
int T,aa,bb,cc,K;
int top,hs[MOD],id[MOD],head[MOD],next[MOD];
ll x,y;
map<int,int> a;
void insert(int x, int y)
{
    int k = x%MOD;
    hs[top] = x, id[top] = y, next[top] = head[k], head[k] = top++;
}
int find(int x)
{
    int k = x%MOD;
    for(int i = head[k]; i != -1; i = next[i])
        if(hs[i] == x)
            return id[i];
    return -1;
}

ll quickPow(ll a,ll b,ll mod)
{
	ll ans=1;
	while(b)
	{
		if(b&1)
		ans=(ans*a)%mod;
		a=(a*a)%mod;
		b>>=1;
	}
	return ans%mod;
}
ll exgcd(ll a,ll b)
{
	if(!b)
	{
		x=1,y=0;
		return a;
	}
	ll t2= exgcd(b,a%b);
	ll t=x;
	x=y;
	y=t-a/b*y;
	return t2;
}

int gcd(int a,int b)
{
	return b==0?a:gcd(b,a%b);
}
ll BSGS(ll a,ll b,ll c)
{
	a%=c,b%=c;//一定别忘了取模    1
	if(a==0&&b==0) return 1;//最小整数解 2
	if(b == 1)
        return 0; // 3
	if(gcd(a,c)!=1) return -1;// 4 因为题目保证是质数，不互质的话一定是倍数关系，扩展大步小步也无解
    memset(head, -1, sizeof(head));//数组不清空，爆零两行泪 
    top = 1;

    int m = sqrt(c*1.0), j;
    long long x = 1, p = 1;
    for(int i = 0; i < m; ++i, p = p*a%c)
        insert(p*b%c, i);//存的是(a^j*b, j)
    
    for(long long i = m; ;i += m)//此时p为a^m 
    {
        if( (j = find(x = x*p%c)) != -1 )
            return i-j;  //a^(ms-j)=b(mod c)
        if(i > c)
            break;
    }
    return -1;
}


int main()
{
	scanf("%d%d",&T,&K);
	while(T--)
	{
		scanf("%d%d%d",&aa,&bb,&cc);
		if(K==1)
		{
			printf("%lld\n",quickPow(aa,bb,cc));
		}
		else if(K==2)
		{
			ll tmp=exgcd(aa,cc);
			x=(x%cc+cc)%cc;
			if(bb%tmp)
			{
				printf("Orz, I cannot find x!\n");
				continue;
			}
			x=x*(bb/tmp)%cc;
			printf("%lld\n",x);
		}
		else if(K==3)
		{
            ll ans=BSGS(aa,bb,cc);
            //
            if(ans!=-1 )
			{
				ans=(ans%cc+cc)%cc;
				printf("%lld\n",ans);
			}
            else
			 printf("Orz, I cannot find x!\n");
        }
	}

	
	return 0;
} 
```

---

## 作者：hzxphy (赞：1)

## 题意
要求实现三种操作计算的代码。
1. 给定 $y,z,p$，计算 $y^z \bmod p$ 的值；
2. 给定 $y,z,p$，计算满足 $xy \equiv z \pmod p$ 的最小非负整数 $x$；
3. 给定 $a,b,p$，计算满足 $a^x \equiv b \pmod p$ 的最小非负整数 $x$。
## 前置芝士
拓展欧几里得和同余有关，考虑如下函数（拓展欧几里得）：
```cpp
void exgcd(ll a,ll b,ll &x,ll &y){
	if(b==0){
		x=1,y=0;d=a;
		return;
	}
	exgcd(b,a%b,x,y);
	ll tmp=x;
	x=y;
	y=tmp-a/b*y;
	return;
}
```
## 思路
### 第一小问
直接快速幂即可。
### 第二小问
事实上我们可以通过逆元得到结论 $zy^{p-2}$，此时我们可以直接输出。

但是这真的对吗？

首先先判定不定方程是否有解，显然当 $p\mid y$ 的时候显然会无解。

可以通过约简使用如上费马小定理。
### 第三小问
**考虑 Baby Step，Giant Step 算法。**

因为判定 $[\gcd(a,p)=1]$ 如果成立则必然有解，所以可以在模 $p$ 意义下执行关于 $a$ 的乘、除法运算。

设 $x=it-j$ 其中 $t=\lceil\sqrt{p}\rceil$，$0\le j\le t-1$，则方程变为 $a^{it-j}\equiv b\pmod{p}$。即 ${(a^t)}^i\equiv ba^j\pmod{p}$。

对于所有的 $j\in[0,t-1]$，把 $ba^j\bmod p$ 插入一个 Hash 表。

枚举所有 $i$ 的可能取值，即 $i\in [0,t]$，计算出 ${(a^t)}^i\bmod p$，在 Hash 表中查找是否存在对应的 $j$，更新答案即可。时间复杂度为 $O(\sqrt{n})$，可以通过。
### main 函数
不多说，整合一下即可。
## AC code
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll qpow(ll a,ll b,ll p){
	ll res=1%p;
	while(b){
		if(b&1)res=res*a%p;
		a=a*a%p;
		b>>=1;
	}
	return res;
}
int exgcd(int a,int b,int &x,int &y){
	if(b==0){
		x=1,y=0;
		return a;
	}
	int gcd=exgcd(b,a%b,x,y);
	int tmp=x;
	x=y;
	y=tmp-a/b*y;
	return gcd;
}
void Ask2(int y,int z,int p){
	if(y%p==0)puts("Orz, I cannot find x!");
	else{
		cout<<z*qpow(y,p-2,p)%p<<"\n";
	}
	return;
}
int autocalc(int y,int z,int p){
	map<int,int>hst;hst.clear();
	z%=p;
	int t=(int)sqrt(p)+1;
	for(int i=0;i<t;i++){
		int val=1ll*z*qpow(1ll*y,1ll*i,1ll*p)%p;
		hst[val]=i;
	}
	y=qpow(y,t,p);
	if(!y)return !z?1:-1;
	for(int i=0;i<=t;i++){
		int val=qpow(y,i,p);
		int j=hst.find(val)==hst.end()?-1:hst[val];
		if(j>=0&&i*t-j>=0)return i*t-j;
	}
	return -1;
}
void babystepgiantstep(int y,int z,int p){
	int ans=autocalc(y,z,p);
	if(ans==-1)puts("Orz, I cannot find x!");
	else printf("%d\n",ans);
	return;
}
int main(){
	int T,K;scanf("%d%d",&T,&K);
	while(T--){
		int y,z,p;scanf("%d%d%d",&y,&z,&p);
		if(K==1)printf("%lld\n",qpow(y,z,p));
		else if(K==2)Ask2(y,z,p);
		else babystepgiantstep(y,z,p);
	}
	return 0;
}
```

---

## 作者：PPXppx (赞：0)

题目描述

你被要求设计一个计算器完成以下三项任务：

1、给定y、z、p,计算y^z mod p 的值；

2、给定y、z、p,计算满足x*y ≡z(mod p)的最小非负整数x；

3、给定y、z、p，计算满足y^x ≡z(mod p)的最小非负整数x。

为了拿到奖品，全力以赴吧！

输入输出格式

输入格式：

输入文件calc.in 包含多组数据。

第一行包含两个正整数T、K，分别表示数据组数和询问类型（对于一个测试点内的所有数据，询问类型相同）。

以下T行每行包含三个正整数y、z、p，描述一个询问。

输出格式：

输出文件calc.out 包括T 行.

对于每个询问，输出一行答案。

对于询问类型2 和3，如果不存在满足条件的，则输出“Orz, I cannot find x!”。

---
分析：

就是一道数论三合一吧，三个类型之间没有联系，都是单独的一个算法；

类型一：普普通通的快速幂模板

类型二：扩展欧几里得算法求解同余方程组的模板

类型三：高次同余方程，BSGS算法模板

三道模板，证毕；


```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll a,b,p,d;
void solve1(){//快速幂模板，非递归实现
    ll ret=1;
    while(b){
    	if(b%2==1) ret=ret*a%p;
    	a=a*a%p;
    	b=b/2;
    }
    printf("%lld\n",ret);
}
ll gcd(ll a,ll b){//最大公约数模板
    if(b==0) return a;
    return gcd(b,a%b);
}
void exgcd(ll a,ll b,ll &x,ll &y){
    if(b==0){d=a;x=1;y=0;return;}
    exeuclid(b,a%b,x,y);
    ll t=x;x=y;y=t-a/b*y;
}//扩展欧几里得算法模板
void solve2(){//扩展欧几里得算法求解同余方程组模板
    ll x,y;
    exgcd(a,p,x,y);
    if(b%d!=0){
    	printf("Orz, I cannot find x! \n");
    	return;
    }
    printf("%lld\n",(x*(b/d)%(p/d)+(p/d))%(p/d));
}
map <ll,ll> Map;//map容器
void solve3(){//BSGS模板
    ll tmp,i,j,t,x,y,m;
    Map.clear();//清空操作
    t=0;a=a%p;
    m=ceil(sqrt(p));
    tmp=1;Map[1]=m+1;　　//一系列初始化操作
    for(j=1;j<=m;j++){//将a^b%p存入map
    	tmp=tmp*a%p;
    	if(!Map[tmp]) Map[tmp]=j;
    }
    t=1;
    for(i=0;i<=m;i++){
    	exgcd(t,p,x,y);
    	t=t*tmp%p;
    	if(b%d!=0) continue;
    	j=Map[(x*(b/d)%(p/d)+(p/d))%(p/d)];
    	if(j){
        	if(j==m+1) j=0;
        	printf("%lld\n",i*m+j);
        	return;
    	}
	}
    printf("Orz, I cannot find x! \n");
}
int main(){
    int T,k;
    scanf("%d%d",&T,&k);//T组数据，k询问类型
    while(T--){
    scanf("%lld%lld%lld",&a,&b,&p);
    if(k==1) solve1();//计算y^z mod p 的值
    if(k==2) solve2();//计算满足xy ≡z(mod p)的最小非负整数x
    if(k==3) solve3();计算满足y^x ≡z(mod p)的最小非负整数x
    }
    return 0;
}


```

---

## 作者：little_sun (赞：0)

# 题解 P2485 【[SDOI2011]计算器】

第一问快速幂不讲了

第二问要你求的是$$x*y \equiv z \mod p$$
即 $$x*y-k*p=z$$
即 $$y*x+p*(-k)=z$$
就转换为$exgcd$的标准形式了（这个相信大家都会吧）

第三问BSGS模板题

有兴趣可以看P4195 exBSGS模板（我的bsgs参考了第二篇题解）

注意$b$有可能大于$p$，所以要膜一下
```cpp
#include <bits/stdc++.h>
#define ll long long
#define int ll
std::unordered_map<int, int> h;
int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }
inline int mul(int a, int b, int p)
{
    ll ret = 0;
    while(b)
    {
        if (b & 1)
            ret = (ret + a) % p;
        a = (a + a) % p;
        b >>= 1;
    }
    return ret;
}
void exgcd(int a, int b, int &x, int &y)
{
    if (b == 0)
    {
        x = 1, y = 0;
        return;
    }
    exgcd(b, a % b, x, y);
    int t = x;
    x = y, y = t - (a / b) * y;
}
int solve1(int a, int b, int p)
{
    ll ret = 1;
    while (b)
    {
        if (b & 1)
            ret = mul(ret, a, p);
        a = mul(a, a, p);
        b >>= 1;
    }
    return ret;
}

int solve2(int a, int b, int p)
{
    int x = 0, y = 0;
    int g = gcd(a, p);
    if (b % g)
        return -1;
    exgcd(a, p, x, y);
    x *= (b / g);
    x = (x % p + p) % p;
    return x;
}
int solve3(int a, int b, int p)
{
    if (b == 1)
        return 0;
    int cnt = 0, d, k = 1;
    while ((d = gcd(a, p)) ^ 1)
    {
        if (b % d)
            return -1;
        b /= d, p /= d, ++cnt;
        k = mul(k, a / d, p);
        if (k == b)
            return cnt;
    }
    int t = sqrt(p) + 1, tmp = 1;
    h.clear();
    for (int i = 0; i < t; i++)
    {
        h[mul(tmp, b, p)] = i;
        tmp = mul(tmp, a, p);
    }
    k = mul(k, tmp, p);
    for (int i = 1; i <= t; i++)
    {
        if (h.find(k) != h.end())
            return i * t - h[k] + cnt;
        k = mul(k, tmp, p);
    }
    return -1;
}
signed main()
{
    int T, op;
    scanf("%lld%lld", &T, &op);
    while (T--)
    {
        int a, b, p;
        scanf("%lld%lld%lld", &a, &b, &p);
        
        if (op == 1)
            printf("%lld\n", solve1(a, b, p));
        if (op == 2)
        {
            b %= p;
            int ans = solve2(a, b, p);
            if (ans == -1)
                printf("Orz, I cannot find x!\n");
            else
                printf("%lld\n", ans);
        }
        if (op == 3)
        {
            b %= p;//注意这个！
            int ans = solve3(a, b, p);
            if (ans == -1)
                printf("Orz, I cannot find x!\n");
            else
                printf("%lld\n", ans);
        }
    }
    return 0;
}
```

---

## 作者：2018LZY (赞：0)

```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
typedef long long ll;

//1
ll power_mod(ll a,ll b,ll c)
{
	ll ans=1%c;a%=c;
	while(b>0)
	{
		if(b&1)ans=ans*a%c;
		a=a*a%c;b=b>>1;
	}
	return ans;
}

//2
ll d;
void exgcd(ll a,ll b,ll &x,ll &y)
{
	if(!a)
	{
		d=b;x=0;y=1;
		return;
	}
	exgcd(b%a,a,y,x);
	x-=b/a*y;
}

//3
const int mod=70001;
int hash[mod],e[mod],next[mod],len,v[mod],ts;
void add(int x,int ex)
{
	int k=x%mod;
	if(v[k]==ts)
	{
		while(1)
		{
			if(hash[k]==x){e[k]=ex;return;}
			if(next[k]==-1)break;
			k=next[k];
		}
		while(v[len]==ts)++len;
		next[k]=len;k=len++;
	}
	hash[k]=x;e[k]=ex;next[k]=-1;v[k]=ts;
}
int find_exp(int x)
{
	int k=x%mod;
	if(v[k]!=ts)return -1;
	while(~k)
	{
		if(hash[k]==x)return e[k];
		k=next[k];
	}
	return -1;
}
ll gcd(ll a,ll b){return !a?b:gcd(b%a,a);}
ll BSGS(ll a,ll b,ll c)
{
	if(b==1||c==1)return 0;
	len=0;++ts;
	ll D=1,tot=0,t=1;
	while((d=gcd(a,c))>1)
	{
		if(b%d)return -1;
		D=D*a/d%c;b/=d;c/=d;
		++tot;
		if(D==b)return tot;
	}
	int m=ceil(sqrt(c));
	for(int i=0;i<m;i++)
	{
		add(t*b%c,i);
		t=t*a%c;
	}
	D=D*t%c;
	for(int i=1;i<=m;i++)
	{
		int j=find_exp(D);
		if(~j)return i*m-j+tot;
		D=D*t%c;
	}
	return -1;
}
int main()
{
	int t,op,a,b,c,k;ll x,y;
	while(~scanf("%d%d",&t,&op))
	{
		switch(op){
			case 1:
				while(t--)
				{
					scanf("%d%d%d",&a,&b,&c);
					printf("%lld\n",power_mod(a,b,c));
				}
				continue;
			case 2:
				while(t--)
				{
					scanf("%d%d%d",&a,&k,&b);k%=b;
					exgcd(a,b,x,y);
					if(k%d)puts("Orz, I cannot find x!");
					else
					{
						x*=k/d;
						y=b/d;
						x=(x%y+y)%y;
						printf("%lld\n",x);
					}
				}
				continue;
			case 3:
				while(t--)
				{
					scanf("%d%d%d",&a,&b,&c);b%=c;
					x=BSGS(a,b,c);
					if(~x)printf("%lld\n",x);
					else puts("Orz, I cannot find x!");
				}
				continue;
		}
	}
	return 0;
}
```


---


# [HAOI2006] 旅行

## 题目描述

Z 小镇是一个景色宜人的地方，吸引来自各地的观光客来此旅游观光。Z 小镇附近共有 $n$ 个景点（编号为 $1,2,3,\ldots,n$），这些景点被 $m$ 条道路连接着，所有道路都是双向的，两个景点之间可能有多条道路。

也许是为了保护该地的旅游资源，Z 小镇有个奇怪的规定，就是对于一条给定的公路 $r_i$，任何在该公路上行驶的车辆速度必须为 $v_i$。

速度变化太快使得游客们很不舒服，因此从一个景点前往另一个景点的时候，大家都希望选择行驶过程中最大速度和最小速度的比尽可能小的路线，也就是所谓最舒适的路线。

## 说明/提示

对于 $100\%$ 的数据，$1 \le x,y \le n \le 500$，$1 \le v < 3 \times 10^4$，$1 \le m \le 5 \times 10^3$，$x \ne y$。

## 样例 #1

### 输入

```
4 2
1 2 1
3 4 2
1 4```

### 输出

```
IMPOSSIBLE```

## 样例 #2

### 输入

```
3 3
1 2 10
1 2 5
2 3 8
1 3```

### 输出

```
5/4```

## 样例 #3

### 输入

```
3 2
1 2 2
2 3 4
1 3```

### 输出

```
2```

# 题解

## 作者：dailt (赞：36)

这个题可以用**最小生成树**做

    这个题是让我们找一条s,t的路径 ,使得这条路上的最大边和最小边的比值最小

    那我们可以先固定一条最大边，然后不断向其中添加小边直到s，t联通

    由于我们可以将小边从大到小枚举，每次判断s,t是否联通
    
    那s,t一旦联通，此时的最大边和最小边就是一组可能的解啦

    然后我们枚举所有最大边，将所有可行解找到，然后将他们比较一下就得出最优解啦
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm> 
#define re register		//放在循环前可以让你的循环更快一点 
using namespace std;
int n,m,fa[1010],s,t,rn,cnt,ansnum,vis[1010];
double ans=50000;
struct edge{int u,v,w;}e[10100];
struct anss{int maxx,minn;}aa[200000];
int gcd(int a,int b){		//最大公约数 约分用的~ 
	if(b==0)	return a;
	else return gcd(b,a%b); 
}
int getf(int a){	//找爹  顺便路径压缩一下 
	if(fa[a]==a)	return a;
	return fa[a]=getf(fa[a]);
} 
int cmp(edge a,edge b){return a.w<b.w;}
int main(){
	scanf("%d%d",&n,&m);
	for(re int i=1;i<=n;++i)	fa[i]=i,vis[i]=1;
	for(re int i=1;i<=m;++i){
		int u,v,w;
		scanf("%d%d%d",&u,&v,&w);
		e[i].u=u,e[i].v=v,e[i].w=w;
		int fu=getf(u),fv=getf(v);//先把所有边连起来看看 s 和 t 是否联通 
		if(fu!=fv)	fa[fu]=fv;
	}
	scanf("%d%d",&s,&t);
	if(getf(s)!=getf(t)){			//判断是否联通 
		cout<<"IMPOSSIBLE";
		return 0;
	}
	int fs=getf(s);
	for(re int i=1;i<=n;++i)
		if(getf(i)!=fs)	vis[i]=0;		//去掉没用的点（就是和s,t不连通的点 
	for(re int i=1;i<=n;++i)	fa[i]=i;	
	sort(e+1,e+m+1,cmp);
	for(re int i=1;i<=m;++i){			//固定最大边 
		if(!vis[e[i].u]||!vis[e[i].v])	continue;	//既然和s,t不连通那就不用这条边 
		for(re int j=1;j<=n;++j)	fa[j]=j; //记得初始化fa哦 
		for(re int j=i;j>=1;j--){		//寻找使s,t联通的最小边 
			int u=e[j].u,v=e[j].v;
			if(!vis[u]||!vis[v])	continue;
			int fu=getf(u),fv=getf(v);
			if(fu!=fv){
				fa[fu]=fv;
				int fs=getf(s),ft=getf(t);
				if(fs==ft){				//找到最小边 
					aa[++cnt]=(anss){e[i].w,e[j].w};//添加到可行解中 
					break;	 
				} 
			}
		}
	}
	for(re int i=1;i<=cnt;++i){   //寻找并记录最优解 
		if(((double)aa[i].maxx/(double)aa[i].minn)<ans){
			ans=((double)aa[i].maxx/(double)aa[i].minn);
			ansnum=i;
		} 
	}
	if((aa[ansnum].maxx%aa[ansnum].minn)==0){//最优解是整数 
		cout<<aa[ansnum].maxx/aa[ansnum].minn;
	}
	else{//最优解不是整数 
		int a1=aa[ansnum].maxx/gcd(aa[ansnum].maxx,aa[ansnum].minn);
		int a2=aa[ansnum].minn/gcd(aa[ansnum].maxx,aa[ansnum].minn);
		cout<<a1<<"/"<<a2;
	}
	return 0;
}
```

---

## 作者：人殇物已非 (赞：25)

说实话，第一次做用类似最小生成树的模型来枚举的，看到正解让人眼前一亮，解法确实妙啊！

刚开始做的时候写了个裸暴力枚举所有可行的路线，复杂度爆炸而且计算不出具体复杂度，只能大概想到这个复杂度下来最坏情况是个指数级别，路线由于乘法原理算下来会非常非常多。然后即使我加上了可行性剪枝和最优性剪枝，两个剪枝带来的效果只是从$20pts$多了$10$分变成了$30pts$，然后剩下7个点全部爆栈（不爆也超时）。

#### 正解可以说是理解之后，又好想，又好写。

首先，判断起点能不能到达终点可以用并查集维护，复杂度$O(α(m))$，比$Floyd$的$O(n^3)$和$dfs$的$O(n+m)$都优秀了不少。

然后，我们只需要把所用的边排序，然后，枚举一下最大边和最小边，这样，最大边和最小边中间的所有边都不会影响答案，都可以选到路线里面，把这些边的端点用并查集维护起来，如果起点和终点在一个集合，成功找到路线。

在这个基础上，每次用当前最大边和最小边去更新答案，由于单调性，还可以在合适的地方加上$break$。

显然，如果所有边都选上了，起点和终点还不在一个集合里，那么就$"IMPOSSIBLE"$。

**PS：** 看到有些题解里去删掉了和起点终点不连通的点，拿了个$vis$记录下来特判了，其实完全不必要。首先你的删点只是记录下来而没有去改$n$的值，循环次数不变，总体复杂度没有优化；其次你加了大量的判断，常数大了很多，这些判断还是很耗时间的。**这真的完全是个负优化。**

### $code:$
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=510;
const int maxm=5100;
struct edge{
	int form,to,next,w;
}e[maxm*2];
int n,m;
int fa[maxn];
int find(int x){return fa[x]==x? x : fa[x]=find(fa[x]);}
void unionn(int a,int b){fa[find(a)]=find(b);}
int cnt=0;
inline void add(int u,int v,int w){
	cnt++;
	e[cnt].form=u;
	e[cnt].to=v;
//	e[cnt].next=last[u];
//	last[u]=cnt;
	e[cnt].w=w;
}
inline bool cmp(edge &a,edge &b){
	return a.w>b.w;
}
int st,en;
double ans=1e10;
int a,b;
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++) fa[i]=i;
	for(int i=1,u,v,w;i<=m;i++){
		cin>>u>>v>>w;
		add(u,v,w);
		unionn(u,v);
	} 
	cin>>st>>en;
	if(find(st)!=find(en)){
		cout<<"IMPOSSIBLE";
		return 0;
	}
	sort(e+1,e+1+cnt,cmp);
	for(int i=1;i<=m;i++){
		for(int k=1;k<=n;k++) fa[k]=k;
		for(int j=i;j<=m;j++){
			int u=e[j].form,v=e[j].to;
			unionn(u,v);
			if(find(st)==find(en)){
				double tmp=(1.0*e[i].w)/(1.0*e[j].w);
				if(tmp<ans) a=e[i].w,b=e[j].w,ans=tmp;
				break;
			}
		}
	} 
	if(a/b*b==a){
		cout<<a/b;
	}
	else cout<<a/__gcd(a,b)<<"/"<<b/__gcd(a,b);
	return 0;
} 
```

---

## 作者：a2540729803 (赞：10)

先按边长排序，假设s与t连通，那么我们可以枚举s与t的路径中最短的一条边，通过类似与kruskal的方法找到s与t的路径在当前最小边权情况下尽量小的最大边权，用这个比值更新答案。


特别的，我们对于某一情况，如果循环完边之后s与t不连通可以跳出。在确定了最小边找完最大边的时候，不必要继续枚举最小边+1，可以从最大边开始向前加边，找到最大的边保证s，t连通，且最大边为刚才求得的，更新答案，从这个边继续枚举。这两个为优化。

 
 
 
 
 
 
 
```cpp
#include <cstdio>
#include <algorithm>
#define maxn 600
#define maxm 5010
using namespace std;
int n,m,s,t;
int father[maxn];
int ans1,ans2;
struct rec
{
    int a,b,len;
} c[maxm];
bool cmp(rec a,rec b)
{return (a.len<b.len);}
int getfather(int x)
{
    if (father[x]==x) return x;
    return father[x]=getfather(father[x]);
}
int gcd(int x,int y)
{
    if (y>x) return gcd(y,x);
    if (!y) return x;
    return gcd(y,x%y);
}
int main()
{
    scanf("%d%d",&n,&m);
    for (int i=1;i<=m;i++) scanf("%d%d%d",&c[i].a,&c[i].b,&c[i].len);
    scanf("%d%d",&s,&t);
    sort(c+1,c+1+m,cmp);
    for (int i=1;i<=m;i++)
    {
        int j;
        for (j=1;j<=n;j++) father[j]=j;
        for (j=i;j<=m;j++)
        {
            int fa,fb;
            fa=getfather(c[j].a); fb=getfather(c[j].b);
            if (fa==fb) continue;
            father[fa]=fb;
            if (getfather(s)==getfather(t)) break;
        }
        if ((i==1)&&(getfather(s)!=getfather(t))) 
        {
            printf("IMPOSSIBLE\n");
            return 0;
        }
        if (getfather(s)!=getfather(t)) break;  
        if (ans1*c[i].len>=ans2*c[j].len) ans1=c[j].len,ans2=c[i].len;
    }
    int x=gcd(ans1,ans2);
    if (x==ans2) printf("%d\n",ans1/ans2); else printf("%d/%d\n",ans1/x,ans2/x);
    return 0;
}
```

---

## 作者：Sol1 (赞：6)

给出一个 $O(nm+m\sqrt m\alpha(m))$ 的做法，比大部分人的 $O(m^2)$ 算法优。

将边排序后分为 $\sqrt m$ 块，枚举每两块之间，维护出这一段的并查集。

这一部分的复杂度是 $O(n\times \sqrt m\times\sqrt m)=O(nm)$ 的。

然后考虑到对于最小边权是 $l$，最大边权是 $r$ 的情况，如果此时 $s$ 与 $t$ 连通，那么加大 $r$ 必然仍然连通。所以可以双指针。

这样，当最小边权是 $l$，最大边权是 $r$ 的时候，利用刚才的分块，可以做到 $O(\sqrt m)$ 次并查集操作计算出 $s,t$ 间的连通性。

由于双指针只需要计算 $O(m)$ 次，所以这一部分的复杂度是 $O(m\sqrt m\alpha(m))$。

故总复杂度是 $O(nm+m\sqrt m\alpha(m))$。

```cpp
#include <iostream>
#include <cmath>
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <stack>
using namespace std;

#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1 << 21], *p1 = buf, *p2 = buf;

inline int qread() {
	register char c = getchar();
	register int x = 0, f = 1;
	while (c < '0' || c > '9') {
		if (c == '-') f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = (x << 3) + (x << 1) + c - 48;
		c = getchar();
	}
	return x * f;
}

inline int Abs(const int& x) {return (x > 0 ? x : -x);}
inline int Max(const int& x, const int& y) {return (x > y ? x : y);}
inline int Min(const int& x, const int& y) {return (x < y ? x : y);}

const int S = 71, N = 505, M = 5005;
int n, m, f[S + 5][S + 5][N], s, t, tmp[N], pos[M], bl[M], br[M];
struct Edge {
	int u, v, w;
	Edge() {}
	Edge(int u, int v, int w) : u(u), v(v), w(w) {}
	bool operator < (const Edge& b) const {
		return w < b.w;
	}
};
Edge e[M];

inline void Read() {
	n = qread(); m = qread();
	for (int i = 1;i <= m;i++) {
		e[i].u = qread(); e[i].v = qread(); e[i].w = qread();
	}
	s = qread(); t = qread();
}

inline void Init() {
	for (int i = 1;i <= n;i++) tmp[i] = i;
}

inline int GetRoot(int v) {
	if (tmp[v] == v) return v;
	return tmp[v] = GetRoot(tmp[v]);
}

inline void Merge(int x, int y) {
	int u = GetRoot(x), v = GetRoot(y);
	tmp[v] = u;
}

inline void Prefix() {
	for (int i = 1;i <= m;i++) pos[i] = (i - 1) / S + 1;
	for (int i = 1;i <= pos[m];i++) {
		bl[i] = (i - 1) * S + 1;
		br[i] = i * S;
	}
	br[pos[m]] = m;
	for (int i = 1;i <= pos[m];i++) {
		Init();
		for (int j = bl[i];j <= m;j++) {
			Merge(e[j].u, e[j].v);
			if (j == br[pos[j]]) memcpy(f[i][pos[j]], tmp, sizeof(f[i][pos[j]]));
		}
	}
}

inline bool Judge(int l, int r) {
	if (pos[l] + 1 >= pos[r]) {
		Init();
		for (int i = l;i <= r;i++) Merge(e[i].u, e[i].v);
	} else {
		memcpy(tmp, f[pos[l] + 1][pos[r] - 1], sizeof(tmp));
		for (int i = l;i <= br[pos[l]];i++) Merge(e[i].u, e[i].v);
		for (int i = bl[pos[r]];i <= r;i++) Merge(e[i].u, e[i].v);
	}
	return GetRoot(s) == GetRoot(t);
}

inline long long gcd(long long m, long long n) {
	long long r = m % n;
	while (r) {
		m = n;
		n = r;
		r = m % n;
	}
	return n;
}

inline void Solve() {
	int l = 1, r = 1;
	while (!Judge(l, r) && r <= m) r++;
	if (r > m) {
		puts("IMPOSSIBLE");
		return;
	}
	long long a = e[l].w, b = e[r].w;
	while (r <= m) {
		if (a * e[r].w < e[l].w * b) {
			a = e[l].w;
			b = e[r].w;
		}
		l++;
		while (!Judge(l, r) && r <= m) r++;
	}
	long long g = gcd(a, b);
	b /= g; a /= g;
	if (a == 1) printf("%lld", b);
	else printf("%lld/%lld", b, a);
}

int main() {
	Read();
	sort(e + 1, e + m + 1);
	Prefix();
	Solve();
	#ifdef CFA_44
	while (1);
	#endif
	return 0;
}
```

---

## 作者：Doqin07 (赞：5)


#### 给出一张无向图，给出一个s，t使得这条路上最大值和最小值的比值最最小，并且输出既约分数（即最简分数）


------------


#### 并查集做法：
#### 枚举最小值，找最大值。每次加入直到可以联通，这时比较ans大小，能更新则更新。
#### ans更新时是分数比大小，直接两个分子乘上互相的分母即可。

------------

# Code：
```c
#include <bits/stdc++.h>
using namespace std;
int f[1000005],n,m,x,y,z,s,t,ans1=30001,ans2=1;bool flag=false;
struct edge{
	int u,v,w;
} e[100005];
// 结构体存图，u,v:两条边，w:权值 
inline void init(int n){for(int i=1;i<=n;++i)f[i]=i;}//并查集初始化 
inline int find(int x){return f[x]==x?x:f[x]=find(f[x]);}//查询操作 
inline bool cmp(edge x,edge y){return x.w<y.w;}//cmp比较函数，按照权值大小进行升序排序 
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;++i){
		scanf("%d%d%d",&x,&y,&z);
		e[i].u=x,e[i].v=y,e[i].w=z;
		//输入图 
	}
	scanf("%d%d",&s,&t);
	sort(e+1,e+1+m,cmp);
	//排序 
	for(int min_index=1;min_index<=m;++min_index){
		//枚举最小值下标 
		init(n);flag=false;//flag代表每次是否更新ans 
		int max_index=min_index;
		for(max_index=min_index;max_index<=m;++max_index){
			//最大值下标 
			int p=find(e[max_index].u),q=find(e[max_index].v);
			if(p!=q)f[p]=q;
			// 将两个元素合并，效果等于奆佬们常写的merge 
			if(find(s)==find(t))
			{flag=true;break;}
			//假如两个点联通，又因为升序排了权值，所以此时的解必然是当前min_index和max_index里的最小值 
		}
		if(flag)if(ans1*e[min_index].w>ans2*e[max_index].w)ans1=e[max_index].w,ans2=e[min_index].w;
		// 分数比大小 
	}
	if(ans1==30001)puts("IMPOSSIBLE");
	// 假如ans没有被更新，则没有联通，输出"IMPOSSIBLE" 
	else{
		int com=__gcd(ans1,ans2);
		ans1/=com,ans2/=com;
		// 即约分数，化简分数 
		if(ans2==1)printf("%d\n",ans1);
		// 若分母为1，直接输出分子 
		else printf("%d/%d\n",ans1,ans2);
	}
	return 0;
}




```
## 求过QWQ


---

## 作者：loaky (赞：5)

emmmmmm，很难的说，这道题开始看的时候觉得还行，应该就是图论吧，然后确实是个图论，首先我们肯定先记录每段间的速度，不加优化，从最小的速度开始，构造最小生成树知道起点与终点联通，那么此时的△v一定是当前的最小值，顺次从排序后的每一条边为起点构造最小生成树，更新minans，最后得到答案，最后分数化简部分建议大佬们用gcd，蒟蒻忘记了板子，于是就只好暴力化简，解决！
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int maxn=1e4+5;
int n,m,s,t,f[maxn],up,down;
int f1,f2;
double fs=1e4;
struct node{
	int a,b,v;
}e[maxn*2];
bool cmp(node x,node y){
	return x.v<y.v;
}
int get(int x){
	if(x==f[x]) return x;
	else return f[x]=get(f[x]);
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		scanf("%d%d%d",&e[i].a,&e[i].b,&e[i].v);
	}
	scanf("%d%d",&s,&t);
	sort(e+1,e+m+1,cmp);
	for(int i=1;i<=m;i++){
		f1=e[i].v,f2=e[i].v;
		int fl=0;
		for(int j=1;j<=m;j++) f[j]=j;
		for(int j=i;j<=m;j++){
			if(get(e[j].a)!=get(e[j].b)){
				f[get(e[j].a)]=f[get(e[j].b)];
				f2=e[j].v;
			}
			if(get(s)==get(t)){
				fl=1;
				break;
			}
		}
		if(fl==1&&double(f2)/double(f1)<fs){
			up=f2;
			down=f1;
			fs=double(f2)/double(f1);
		}
	}
	if(f1==0||f2==0||fs==10000) cout<<"IMPOSSIBLE";
	else if((fs-int(fs))>0){
		for(int i=2;i<min(up,down);i++){
			if(up%i==0&&down%i==0){
				up/=i;
				down/=i;
			}
		}
		cout<<up<<"/"<<down;
	}
	else if((fs-int(fs))==0) cout<<fs;
	return 0;
}
```

---

## 作者：人间凡人 (赞：4)

#### 题意：

一个有 $n$ 个点 $m$ 条边的无向图,求从 $s$ 到 $t$ 的路径中边权最大值与边权最小值的比值最小可以是多少? (如果不是整数则输出一个最简分数,没有则输出 $IMPOSSIBLE$ )

#### 思路：

最小生成树，$kruskal$算法

因为边数只有 $5000$ ，所以可以考虑复杂度为 $O(m^2)$ 的算法。首先对边排序，枚举最小边，然后每次从小往大加边，每加入一条边检查 $s$ ，$t$ 是否联通,若联通则更新答案并 $break$ 。对于每一个最小边所算出的答案取 $min$ , 取最小公约数以输出化简后答案。

问：如何合并? 答：并查集中的 $merge$ 函数，将两个点合并到同一个集合中。

$Code:$

```cpp
#include<bits/stdc++.h>
#define N 5005
using namespace std;
int n,m,ans1,ans2;
double num,ans;
struct node{
	int x,y,w;
};
node a[N];
int fa[N],s,t;
bool cmp(node a1,node a2){
	return a1.w<a2.w;
}
int find(int x){
	if(x==fa[x])return x;
	return fa[x]=find(fa[x]);
}
void merge(int x,int y){
	fa[find(x)]=find(y);
}
void Init(){
	for(int i=1;i<=n;i++)fa[i]=i;
}
int gcd(int x,int y){
	if(y==0)return x;
	return gcd(y,x%y);
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		scanf("%d%d%d",&a[i].x,&a[i].y,&a[i].w);
	}
	scanf("%d%d",&s,&t);
	sort(a+1,a+m+1,cmp);
	ans1=10005;ans2=1;ans=10005.0;
	for(int i=1;i<=m;i++){
		Init();
		for(int j=i;j<=m;j++){
			merge(a[j].x,a[j].y);
			if(find(s)==find(t)){
				num=(double)(a[j].w*1.0/(a[i].w*1.0));
				if(num<ans){
					ans1=a[j].w;
					ans2=a[i].w;
					ans=num; 
				} 
				break;
			}
		}
	}
	if(ans1==10005&&ans2==1)printf("IMPOSSIBLE\n"); 
	else if(ans1%ans2==0)printf("%d\n",ans1/ans2);
	else printf("%d/%d\n",ans1/gcd(ans1,ans2),ans2/gcd(ans1,ans2));
	return 0;
}
```


---

## 作者：艾萨克·牛顿 (赞：3)

本蒟蒻第一次发题解，求过QWQ

------------

链接 [HAOI2006旅行](https://www.luogu.org/problem/P2502)


------------

介个题。。。我一开始看还以为要打最短路之类的（x）

结果打不出来。。。（我太蒻了）

然后洗了把脸冷静了一下，

如果要让起点和终点联通，可以贪心一下，先将边排序，在图中随便选一条边作为最长边，再将比它边权小（就是速度小啦）的边依次选择加入图中，直到起点和终点联通，（注意：此时加入的最小边权值一定是满足题目要求的最小边的最大值~~有点绕~~）记录下来此时的最大速度与最小速度比值、最大速度、最小速度，再继续枚举一开始选定的最长边，最后找最大速度与最小速度比值的最小情况即为答案（貌似没错吧）

具体实现的话，判断起点终点是否联通我们可以搞一个并查集来维护，两点联通就并起来，

诶等等。。。这貌似就是魔改的kruskal！

（如果还没学过kruskal和并查集，建议先自学一下，打两道模板再来A掉这道（我太懒了就不发链接了QWQ））

（ps.一开始输入边的时候就可以用并查集合并点，如果到最后起点和终点都没并到一起直接IMPOSSIBLE）

ac代码（初学压行，码风诡异勿喷）
```
#include<bits/stdc++.h>
#define int long long
//#pragma GCC optimize(2)
using namespace std;
const int N=1009,M=100009;
int can[N],last[N],f[N];//can是一个优化，last邻接表操作
struct edge{int from,to,nxt,val;
}e[M];
int en=0;
void addedge(int x,int y,int z){
	en++,e[en].val=z;e[en].to=y,e[en].nxt=last[x],last[x]=en,e[en].from=x;
}//邻接表
int find(int x){
	if(f[x]!=x) f[x]=find(f[x]);
	return f[x];
}
void unionn(int x,int y){
	int xx=find(x),yy=find(y);if(xx!=yy) f[xx]=yy;
}//这俩是并查集操作
int gcdd(int x,int y){
	return !y? x:gcdd(y,x%y);
}//辗转相除求最大公因数，最后有用（没学数论的小盆友可以看底部链接）
int cmp(edge x,edge y){
	return x.val>y.val;
}//按边权从大到小排

signed main(){
	ios::sync_with_stdio(0);cin.tie(0);
	int n,m,t,s;
	cin>>n>>m;
	for(int i=1;i<=n;i++) f[i]=i//初！！始！！化！！;
	for(int i=1;i<=m;i++){
		int x,y,v;cin>>x>>y>>v;
		addedge(x,y,v);
		unionn(x,y);//并查集判IMPOSSIBLE
	}
	cin>>s>>t;
	if(find(s)!=find(t)){
		cout<<"IMPOSSIBLE";return 0;
	}//一开始就用并查集判能否到达
	else{
		/*for(int i=1;i<=n;i++){
			if(fs!=find(i)) can[i]=1;
		}12Ms玄学优化*/
		sort(e+1,e+1+m,cmp);
		double minn=0x7fffffff;int a,b;//比值最小值，此时最大速度与最小速度
		for(int i=1;i<=m;i++)//枚举最长边
		{
			/*if(can[e[i].from]||can[e[i].to]) continue;玄学优化*/
			for(int j=1;j<=n;j++) f[j]=j;//初始化！！！！！
			for(int j=i;j<=m;j++){//克鲁斯卡尔最大生成树2333
				unionn(e[j].from,e[j].to);//这个不是真的最小生成树，不用判环，直接并就行。
				if(find(s)==find(t)) {//找到满足条件的最小边的最大情况
					double tmp=(1.0*e[i].val)/(1.0*e[j].val);
					if(tmp<minn) a=e[i].val,b=e[j].val,minn=tmp;
					break;//更新
				}
			}
		}
		if(a/b*b==a){
        	cout<<a/b;
    	}
	    else cout<<a/gcdd(a,b)<<"/"<<b/gcdd(a,b);
		}//最后输出要注意要求，整数直接输出，分数的话，用最大公因数约分
	}
	
	
	


```
ps.（看前面的题解有大佬说can数组是个负优化，但我亲测好像是能玄学12Ms（大雾），所以我都注释掉，大家闲着没事可以亲测一下）

ps.[辗转相除](https://www.cnblogs.com/newpanderking/archive/2011/07/25/2116323.html)

最后友情提醒：

并查千万条，初始第一条，
忘记初始化，爆零两行泪！

---

## 作者：Adove (赞：2)

这题可以枚举边权然后跑堆优化SPkstra来实现

对于当前枚举到的边权，维护一个不大于当前边权的最大值

然后更新答案

最后除以GCD就可以了

时间复杂度$\Theta(m^2 \log n)$

```cpp
#include"cstdio"
#include"cstring"
#include"iostream"
#include"algorithm"
using namespace std;

const int MAXN=505;
const int MAXM=5005;
const int MAXV=3e4+5;

int n,m,np,s,t,mx,mi,mxv;
int h[MAXN],val[MAXN],f[MAXN],hp[MAXN],id[MAXN];
bool cup[MAXV],vis[MAXN];
struct rpg{
	int li,nx,ln;
}a[MAXM<<1];

int find(int x){return f[x]==x?x:f[x]=find(f[x]);}
void un(int a,int b){int fa=find(a),fb=find(b);if(fa!=fb) f[fa]=fb;}

void add(int ls,int nx,int ln)
{
	a[++np]=(rpg){h[ls],nx,ln};h[ls]=np;
	a[++np]=(rpg){h[nx],ls,ln};h[nx]=np;
}

void up(int x)
{
	for(int i=x,j=i>>1;j;i=j,j>>=1){
		if(val[hp[i]]>val[hp[j]]) swap(hp[i],hp[j]),swap(id[hp[i]],id[hp[j]]);
		else break;
	}return;
}

void ins(int x)
{
	hp[++hp[0]]=x;
	id[x]=hp[0];
	up(hp[0]);
	return;
}

void pop()
{
	id[hp[1]]=0;
	hp[1]=hp[hp[0]--];
	id[hp[1]]=1;
	for(int i=1,j=2;j<=hp[0];i=j,j<<=1){
		if(j<hp[0]&&val[hp[j+1]]>val[hp[j]]) ++j;
		if(val[hp[i]]<val[hp[j]]) swap(hp[i],hp[j]),swap(id[hp[i]],id[hp[j]]);
		else break;
	}return;
}

void SPkstra(int s,int v)
{
	memset(val,-1,sizeof(val));
	memset(hp,0,sizeof(hp));
	memset(id,0,sizeof(id));
	val[s]=mxv;ins(s);
	while(hp[0]){
		int nw=hp[1];pop();
		for(int i=h[nw];i;i=a[i].li){
			if(a[i].ln>v) continue;
			if(val[a[i].nx]<min(a[i].ln,val[nw])){
				val[a[i].nx]=min(a[i].ln,val[nw]);
				if(id[a[i].nx]) up(id[a[i].nx]);
				else ins(a[i].nx);
			}
		}
	}return;
}

int gcd(int a,int b){return !b?a:gcd(b,a%b);}

int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i) f[i]=i;
	for(int i=1;i<=m;++i){
		int x,y,z;scanf("%d%d%d",&x,&y,&z);
		cup[z]=1;add(x,y,z);un(x,y);
		mxv=max(mxv,z);
	}scanf("%d%d",&s,&t);mi=1,mx=mxv;
	if(find(s)!=find(t)){puts("IMPOSSIBLE");return 0;}
	for(int i=1;i<=mxv;++i){
		if(cup[i]){
			SPkstra(s,i);
			if(i*mi<mx*val[t]) mx=i,mi=val[t];
		}
	}int c=gcd(mx,mi);mx/=c,mi/=c;
	if(mi==1) printf("%d\n",mx);
	else printf("%d/%d\n",mx,mi);
	return 0;
}
```

---

## 作者：Dispwnl (赞：2)

哇好久以前在codevs上AC的一道题

于是拿到luogu上发题解装逼（划掉）好好理解

其实就是最小生成树的思路

枚举每一条边

从这条边往后枚举建最小生成树

同时记录最大最小值

连通起点和终点就退出

更新答案

至于为什么从这条边开始枚举（xmdalao的讲解）

1.按克鲁斯卡尔排序，保证边从小到大

2.最优解肯定只会在后面出现，因为如果前面有边可以连通起点和终点，只有后面的边能出更优的答案

3.用时少

c++
```cpp
# include<iostream>
# include<algorithm>
using namespace std;
struct p{
    int x,y,dis;
}c[100001];
int n,m,minn,maxn,s,t;
int f[501];
bool cmp(p a,p b)
{
    return a.dis<b.dis;
}
int find(int x)
{
    if(f[x]!=x) f[x]=find(f[x]);
    return f[x];
}
int gcd(int x,int y)
{
    int ff=x,fff=y;
    int r=x%y;
    while(r)
    {
        ff=fff;
        fff=r;
        r=ff%fff;
    }
    return fff;
}
int main()
{
    double ss=999999;
    cin>>n>>m;
    for(int i=1;i<=m;i++)
      {
          int x,y,dis;
          cin>>x>>y>>dis;
          c[i].x=x,c[i].y=y,c[i].dis=dis;
      }
    sort(c+1,c+1+m,cmp);
    cin>>s>>t;
    for(int i=1;i<=m;i++)
      {
          bool ffff=0;
          int m1=c[i].dis,m2=c[i].dis;
          for(int j=1;j<=n;j++)
            f[j]=j;
          for(int j=i;j<=m;j++)
            {
                if(find(c[j].x)!=find(c[j].y))
                {
                    f[find(c[j].x)]=find(c[j].y);
                    m2=c[j].dis;
            }
            if(find(s)==find(t))
            {
                ffff=1;
                break;
            }
          }
        if(double(m2)/double(m1)<ss&&ffff) minn=m1,maxn=m2,ss=double(m2)/double(m1);
      }
    if(!minn)
    {
        cout<<"IMPOSSIBLE";
        return 0;
    }
    if(ss-int(ss))
    {
        int x=gcd(maxn,minn);
        cout<<maxn/x<<"/"<<minn/x;
    }
    else cout<<ss;
    return 0;
}
```

---

## 作者：hulean (赞：1)

思路楼上楼下已经给的很清楚了，这里就随便提一下

由于此题边数比较小，所以可以先给边排个序，然后跑m遍最小生成树，每跑一次删除一条边，找最优解。

- 防TLE技巧

把边按从小到大的顺序排好，那么只要当前无法联通，那么后面也无法联通

- 最优解找法
```cpp
double tmp=(1.0*e[i].w)/(1.0*e[j].w);
//因为边是有序的，所以当前的第一条边是最大的，保证能联通的最后一条边就是最小的（详细的自己理解）
if(tmp<ans) a=e[i].w,b=e[j].w,ans=tmp;
//与当前的最优解进行比较
```

- 分数的处理技巧

设a和b是最后的结果，那么当b能整除a时，直接输出商

否则就求一遍最大公约数，把a与b分别除以这个最大公约数，输出结果

代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=500+10;
const int MAXM=5000+10;
int n,m,s,t;
struct Node
{
	int u,v,w;
}edge[MAXM];
int f[MAXN];
int ans1,ans2;
inline int find(int k)
{
	if(f[k]==k)return k;
	else return f[k]=find(f[k]);
}
inline bool cmp(Node u,Node v)
{
	return u.w<v.w;
}
inline void init()//每次的并查集初始化
{
	for(int i=1;i<=n;i++)f[i]=i;
}
inline int read()
{
	int tot=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9')
	{
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')
	{
		tot=tot*10+c-'0';
		c=getchar();
	}
	return tot*f;
}
inline int gcd(int x,int y)//求最大公约数
{
	if(y>x)return gcd(y,x);
	if(y==0)return x;
	return gcd(y,x%y);
}
int main()
{
	n=read();m=read();
	for(int i=1;i<=m;i++)
	{
		edge[i].u=read();
		edge[i].v=read();
		edge[i].w=read();
	}
	s=read();t=read();
	sort(edge+1,edge+1+m,cmp);
	int now;
	for(int i=1;i<=m;i++)
	{
		init();
		/*for(int i=1;i<=n;i++)cout<<f[i]<<" ";
		cout<<endl;*/
		for(now=i;now<=m;now++)
		{
			int fx=find(edge[now].u),fy=find(edge[now].v);
			//cout<<fx<<" "<<fy<<endl;
			if(fx==fy)continue;
			f[fx]=fy;
			if(find(s)==find(t))break;
		}
		/*for(int i=1;i<=n;i++)cout<<f[i]<<" ";
		cout<<endl;*/
		if(i==1&&find(s)!=find(t))
		{
			cout<<"IMPOSSIBLE\n";
			return 0;
		}
		if(find(s)!=find(t))break;
		if(ans1*edge[i].w>=ans2*edge[now].w)ans1=edge[now].w,ans2=edge[i].w;
	}
	//cout<<ans1<<" "<<ans2<<endl;
	if(ans2%ans1==0)
	{
		cout<<ans2/ans1<<endl;
		return 0;
	}
	int gcdd=gcd(ans1,ans2);
	cout<<ans1/gcdd<<"/"<<ans2/gcdd<<endl;
	return 0;
}
```

---

## 作者：lots_of_laugh (赞：1)

发一个超级菜的解法。。。
时间复杂度（MNlog(M)）勉强过

思路：枚举最大边，二分求最小边最大，打擂

但是裸着来会TLE

所以我们优化：
若对于最大边值为maxn时最小边值最大为minn，则对于最大边值为maxn+1最小边值为minn时一定能够从s走到t

所以我们对边权排序，对于每一个maxn，二分下界可以设成上次得到的最大minn

又因为边权已经有序了，所以我们可以直接对边排序后的编号而不是边权来二分（虽然log30000也没比log5000大多少QAQ）

最后要注意二分的特判，不然第一个点会wa
最后

每遍dfs后一定要重置vis数组！！

（也许用spfa求最小边最大快些？）
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ri register int
int Head[510],Next[10010],V[10010],W[10010],tot;
int vis[510],line[10010];
int n,m,s,t;
struct bi{int bg,sm;}tmp,ans;
void add(int u,int v,int w)
{V[++tot]=v;W[tot]=w;Next[tot]=Head[u];Head[u]=tot;}
bool operator < (bi x,bi y)
{
	double numx=(double)x.bg/(double)x.sm;
	double numy=(double)y.bg/(double)y.sm;
	return numx<numy;
}
bool dfs(int u,int fa,int maxn,int minn)
{
	if(u==t)return 1;
	vis[u]=1;int v,w;bool flag=0;
	for(ri i=Head[u];i;i=Next[i])
	{
		v=V[i];w=W[i];
		if(fa==v||w>maxn||w<minn||vis[v])continue;
		flag|=dfs(v,u,maxn,minn);
		if(flag)return flag;
	}
	return flag;
}
int work(int maxn,int l,int r)
{
	memset(vis,0,sizeof(vis));
	if(l==r)
	{
		if(dfs(s,-1,maxn,line[l]))return l;
		else return l-1;
	}
	int mid=(l+r)/2;
	if(dfs(s,-1,maxn,line[mid]))return work(maxn,mid+1,r);
	else return work(maxn,l,mid);
}
void print(bi x)
{
	if(x.bg%x.sm)
	{
		for(ri i=2;i*i<=line[m];i++)
		while(!(x.bg%i)&&!(x.sm%i))
		{x.bg/=i;x.sm/=i;}
		printf("%d/%d",x.bg,x.sm);
	}	
	else printf("%d",x.bg/x.sm);
	return;
}
int main()
{
	int u,v,w;
	scanf("%d%d",&n,&m);
	for(ri i=1;i<=m;i++)
	{
		scanf("%d%d%d",&u,&v,&w);
		add(u,v,w);add(v,u,w);line[i]=w;
	}
	sort(line+1,line+m+1);
	int max,min,loc,lloc=1,st=1;ans.bg=30010;ans.sm=1;
	scanf("%d%d",&s,&t);
	if(!dfs(s,-1,30010,-1))
	{printf("IMPOSSIBLE");return 0;}
	memset(vis,0,sizeof(vis));
	while(!dfs(s,-1,line[st],0))
	{
		memset(vis,0,sizeof(vis));
		st++;
	}
	for(ri i=st;i<=m;i++)
	{
		if(line[i]==line[i-1])continue;
		max=line[i];
		loc=work(max,lloc,i);min=line[loc];
		tmp.bg=max;tmp.sm=min;
		if(tmp<ans)ans=tmp;
		lloc=loc;
	}
	print(ans);
	return 0;
}
```


---

## 作者：MuYC (赞：0)

这道题的解法为：并查集+排序

#### 主要做法

其实这道题感觉上就是$Kruscal$？

因为$m$比较小，所以给出可以$m^2$进行枚举。

题目要求最大边与最小边的比值最小，所以我们不妨可以枚举最小边 $or$ 最大边，这里我选择的是枚举最小边，然后我们枚举确定最小边后，我们要干嘛？

不要忘记我们的目标是最小化最大边与最小边的比值！

因为此刻我们通过枚举已经确定的最小边，所以我们现在要**最小化最大边**。

#### 为什么要用Kruscal算法

众所周知，通过$Kruscal$生成树算法生成的最小生成树是一个瓶颈生成树。（瓶颈生成树即所有生成树里面**最大边最小**的一个）

于是我们想到用$Kruscal$同样的思路，先把边排序，然后从小到大枚举每一条边作为最小边的情况，然后不停的加边，倘若起点与终点已经联通，我们就停止加边，因为是**无向图**，判断连通性用并查集即可。

这时候得到的最大那一条边即可对答案做出贡献。因为是已经排序好了的，所以最后一次加入的边即是最大边。

然后用枚举到的最大边除以最小边去更新答案，如果比答案更优，就记录下此时的最大边权和最小比权，到最后输出答案即可。

我在这里判断答案是否更优，用了一个$longdouble$类型的数，因为这道题对于精度的要求不是特别高，可以直接用小数去判断，其实更严格的做法应该是用当前的答案分数比较大小。

如何比较两个分数的大小？我们也没必要求$LCM$，两个分数交叉相乘即可。

是因为这里的$v$边权较小，并不需要开$long long$，所以交叉相乘更方便。

对于此题的分析到此结束。

给出代码：**仅供参考**

### Code
```cpp
#include <bits/stdc++.h>
using namespace std;

int n , m , cnt = 0,Ansa = 0 ,Ansb = 10000000;
int fa[505],s,t;
long double pd = 10000000;//初始化一个很大的数值

struct Edge {
	int from,to,w;
} edge[10005];//双向边，开两倍空间

int find(int x)
{
	if(fa[x] != x) fa[x] = find(fa[x]);
	return fa[x];//路径压缩版的并查集
}

void add(int from,int to,int w)
{
	cnt ++;
	edge[cnt].from = from;
	edge[cnt].to = to;//这里是没有链式结构的前向星（因为我们不需要）
	edge[cnt].w = w;
	return ;
}

int gcd(int x,int y)
{
	if(x % y == 0)return y;
	else return gcd(y,x % y);
}

int cmp(Edge A, Edge B){return A.w < B.w;}

int main()
{
	cin >> n >> m;
	for(int i = 1 ; i <= n ; i ++)fa[i] = i;
	for(int i = 1 ; i <= m ; i ++)
	{
		int u , v , w;
		cin >> u >> v >> w;
		add(u,v,w);
		add(v,u,w);
		fa[find(u)] = find(v);//先合并，为了判断s，t的连通性
	}
	cin >> s >> t;
	if(find(s) != find(t))
	{
		cout << "IMPOSSIBLE";//如果在图中不连通，显然无解
		return 0;
	}
	else 
	{
		if(s == t){cout << 0 ;return 0;}
		sort(edge + 1 , edge + 1 + cnt , cmp);
		for(int i = 1 ; i < cnt ; i ++)//枚举最小边
		{
			for(int j = 1 ; j <= n ; j ++)fa[j] = j;//联通情况赋初值
			int k,flag = 0;
			for(int j = i ; j <= cnt ; j ++)
			{
				if(find(s) == find(t)){flag = 1 ; break;}
				k = j;
				fa[find(edge[j].from)] = find(edge[j].to);
			}
			if(!flag)break;
			if((long double)(edge[k].w) /(long double)(edge[i].w) < pd)
			pd = (long double)(edge[k].w) /(long double)(edge[i].w),Ansa = edge[k].w , Ansb = edge[i].w;
		}
			if(Ansa % Ansb == 0)cout << Ansa / Ansb;
			else cout << Ansa / gcd(Ansa,Ansb) << "/" << Ansb / gcd(Ansa,Ansb);//计算答案
	}
	return 0;
}
```

---

## 作者：abandentsky (赞：0)

题意：给你给出一张图，然后给出起点和到达点，问你从起点到到达点的过程中
      边权的最大值和最小值的比值最小是哪两个值。
思路：第一次直接暴力搜索结果过了三个点。给出代码：

```c
#include<bits/stdc++.h>
#pragma GCC optimize(2)
#define MAXN 5010
#define MAXP 55
#define maxnode 50010
#define sigma_size 26
#define mod 1000000007
#define INF 0x3f3f3f3f
#define lc  (id<<1)
#define rc  (id<<1|1)
using namespace std;
typedef long long LL;

int n,m,s,t;
int Maxn,Minn;
double pp;
struct Edge
{
    int from,to,dist;
    Edge(int from=0,int to=0,int dist=0):from(from),to(to),dist(dist){};
};
vector<Edge> edges;
vector<int> G[MAXN];
bool vis[MAXN];

void dfs(int u,int maxn,int minn)
{
    if(u==t)
    {
        if((maxn*1.0/minn)<pp)
        {
            Maxn=maxn,Minn=minn;
            pp=maxn*1.0/minn;
        }
        return ;
    }
    vis[u]=true;
    for(int i=0;i<G[u].size();i++)
    {
        Edge &e=edges[G[u][i]];
        if(!vis[e.to])
            dfs(e.to,max(maxn,e.dist),min(minn,e.dist));
    }
    vis[u]=false;
}

int gcd(int aa,int bb)
{
    while(bb)
    {
        int cc=aa%bb;
        aa=bb;
        bb=cc;
    }
    return aa;
}

int main()
{
    scanf("%d %d",&n,&m);
    int u,v,w;
    for(int i=1;i<=m;i++)
    {
        scanf("%d %d %d",&u,&v,&w);
        edges.push_back({u,v,w});
        edges.push_back({v,u,w});
        int mm=edges.size();
        G[u].push_back(mm-2);
        G[v].push_back(mm-1);
    }
    memset(vis,false,sizeof(vis));
    scanf("%d %d",&s,&t);
    pp=INF;
    dfs(s,0,INF);
    if(pp==INF)
        printf("IMPOSSIBLE\n");
    else
    {
        int pop=gcd(Maxn,Minn);
        if(Minn/pop!=1)
           printf("%d/%d\n",Maxn/pop,Minn/pop);
        else
            printf("%d\n",Maxn/pop);
    }
    return 0;
}

```
考虑能不能利用以及搜索过的信息。从s到t的边会构成一个集合。是不是可以用最小生成树呢？构造成最小生成然后利用LCA查询s和t之间的最大值和最小值。发现wrong了。想想二分，好像也不太行。翻了翻题解，发现需要枚举最小值。然后就写了一份代码：枚举最小值，然后只要能使得s和t连通，就可以得到一组可行解，最后在这些可行解里面找最优解就好了。
所以简单来说就是枚举+检查联通性
给出AC代码：

```c
#include<bits/stdc++.h>
#pragma GCC optimize(2)
#define MAXN 5010
#define MAXP 55
#define maxnode 50010
#define sigma_size 26
#define mod 1000000007
#define INF 0x3f3f3f3f
#define lc  (id<<1)
#define rc  (id<<1|1)
using namespace std;
typedef long long LL;

int n,m,maxn,minn;
double pp;
struct Edge
{
    int from,to,dist;
    Edge(int from=0,int to=0,int dist=0):from(from),to(to),dist(dist){};
};
Edge edges[MAXN];
int fa[MAXN],s,t;

bool comp(Edge A,Edge B)
{
    return A.dist<B.dist;
}

int Find(int x)
{
    return fa[x]==x?x:fa[x]=Find(fa[x]);
}

void init(int nn)
{
    for(int i=0;i<=nn;i++)
        fa[i]=i;
}

int krustral(int w)    //用最小生成树（并不是完整的最小生成树）来搞连通，
{                                    //这里面只要让s和t连通就好了
    for(int i=w;i<m;i++)
    {
        int xx=Find(edges[i].from);
        int yy=Find(edges[i].to);
        if(xx==yy)
           continue;
        fa[xx]=yy;
        if(Find(s)==Find(t))
            return edges[i].dist;
    }
    return -1;
}

int gcd(int a,int b)
{
    while(b)
    {
        int c=a%b;
        a=b;
        b=c;
    }
    return a;
}

int main()
{
    scanf("%d %d",&n,&m);
    for(int i=0;i<m;i++)
    {
        scanf("%d %d %d",&edges[i].from,&edges[i].to,&edges[i].dist);
    }
    scanf("%d %d",&s,&t);
    sort(edges,edges+m,comp);
    pp=INF*1.0;
    for(int i=0;i<m;i++)
    {
        init(n);
        int kk=krustral(i);
        if(kk==-1)
            break;
        if(kk*1.0/edges[i].dist<pp)
        {
            pp=kk*1.0/edges[i].dist;
            maxn=kk,minn=edges[i].dist;
        }
    }
    if(pp==INF)
    {
        printf("IMPOSSIBLE\n");
        return 0;
    }
    int pop=gcd(maxn,minn);
    if(minn/pop==1)
        printf("%d\n",maxn/pop);
    else
        printf("%d/%d\n",maxn/pop,minn/pop);
    return 0;
}
```


---

## 作者：黄汝鹏 (赞：0)

题目大意：这道题是让我们在一条s到t的路径中，找一条路使得边的最大值与最小值的差最小

我的思路与楼上大佬的思路类似：


------------
```cpp
找到s与t的路径在当前最小边权情况下尽量小的最大边权，用这个比值更新答案。
```
摘自楼上某位大佬

在循环过程中，我们可以每次都判断一次操作后，s与t是否联通，如果不连通则跳出循环，并且不断更新边的值（如果认为我讲的不清楚，可以参考其他大佬题解）

对了，最后还要求最大公约数，可以用gcd，我用了辗转相除法（原理一样，样子不同）
好了，上代码吧(⊙o⊙)：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<string>
#include<algorithm>
#include<bits/stdc++.h>
using namespace std;
const int max1=500+10;
const int max2=5000+10;
int n,m,s,t,cnt1,cnt2;
int fa[max1];
struct Edge
{
	int x,y;
	int z;
}edge[max2*2];
bool cmp(Edge a,Edge b)
{
	return a.z<b.z;
}
int gcd(int a,int b)//辗转相除法
{
	int r;
	while(b)
	{
		r=a%b;
		a=b;
		b=r;
	}
	return a;
}
int father(int a)//找爸爸
{
	if(a==fa[a]) return a;
	fa[a]=father(fa[a]);
	return fa[a];
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	    scanf("%d%d%d",&edge[i].x,&edge[i].y,&edge[i].z);
	cin>>s>>t;
	sort(edge+1,edge+m+1,cmp);
	for(int i=1;i<=m;i++)
	{
		int j;
		for(j=1;j<=n;j++) fa[j]=j;
		for(j=i;j<=m;j++)//类似克鲁斯卡尔
		{
			int aa=father(edge[j].x);
			int bb=father(edge[j].y);
			if(aa==bb) continue;
			fa[aa]=bb;
			if(father(s)==father(t)) break;
		}
		if((i==1)&&(father(s)!=father(t)))//说明s与t之间没毛关系
		{
			cout<<"IMPOSSIBLE";
			return 0;
		}
		if(father(s)!=father(t)) break;//不连通
		if(cnt1*edge[i].z>=cnt2*edge[j].z) cnt1=edge[j].z,cnt2=edge[i].z;
		//更新答案
	}
	int js=gcd(cnt1,cnt2);
	if(js==cnt1)
	   cout<<cnt2/js;
	else 
	   if(cnt2==js)
	      cout<<cnt1/js;
	   else
	       cout<<cnt1/js<<"/"<<cnt2/js;
	return 0;
}
```
祝大家愉快开学

---

## 作者：kkxhh (赞：0)

开始没想到什么比较好的做法，然后看到标签里有暴力，就写了个暴力，然后就过了qwq

主要思路是每次枚举最小边权，然后二分出可以使 $s$ 和 $t$ 连通的最小最大边权，然后更新答案就行了

一点小小的优化是每次二分时先缩小一下 $r$ 的范围（即去掉一定比答案更劣的情况），然后再判断一下 $r$ 这个位置是否可行，如果不行直接 $continue$

每次 $check$ 的复杂度是 $O(m\alpha(m))$，于是总复杂度大概是 $O(m^{2}\alpha(m)logv)$

代码：
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

int gcd(int a,int b) {return !b?a:gcd(b,a%b);}

typedef struct edge{
    int from,to,v;
    bool operator < (const edge &x) const {return v<x.v;}
}edge;

typedef struct data{
    int a,b;
    data(int _a,int _b){
        int g=gcd(_a,_b);
        a=_a/g; b=_b/g;
    }
    bool operator < (const data &x) const {return a*x.b<b*x.a;}
    bool operator > (const data &x) const {return a*x.b>b*x.a;}
    bool operator == (const data &x) const {return a*x.b==b*x.a;}
    void print() {printf("%d",a); if(b!=1) printf("/%d",b);}
}data;

edge e[5010];
data ans(100000,1);
int n,m,s,t,fa[510],rnk[510];

inline int read(){
    int num=0,k=1; char c=getchar();
    while(c>'9' || c<'0') k=(c=='-')?0:k,c=getchar();
    while(c>='0' && c<='9') num=num*10+c-'0',c=getchar();
    return k?num:-num;
}

int find(int x){
    if(fa[x]!=x) return find(fa[x]);
    return x; 
}

void merge(int x,int y){
    x=find(x); y=find(y);
    if(x==y) return;
    if(rnk[x]<rnk[y]) swap(x,y);
    fa[y]=x; rnk[x]=max(rnk[x],rnk[y]+1);
}

void init() {for(int i=1;i<=n;i++) fa[i]=i,rnk[i]=1;}

bool check(int l,int r){
    init();
    for(int i=l;i<=r;i++) merge(e[i].from,e[i].to);
    return find(s)==find(t);
}

void solve(){
    sort(e+1,e+1+m);
    for(int i=1;i<=m;i++) if(e[i].v!=e[i-1].v){
        int l=i-1,r=m+1,mid=(l+r)>>1;
        while(data(e[mid].v,e[i].v)>ans) r=mid,mid=(l+r)>>1;
        if(!check(i,r)) continue;
        while(l+1<r){
            mid=(l+r)>>1;
            if(check(i,mid)) r=mid;
            else l=mid;
        }
        if(data(e[r].v,e[i].v)<ans) ans=data(e[r].v,e[i].v);
    }
}

int main(){
    n=read(); m=read();
    for(int i=1;i<=m;i++) e[i].from=read(),e[i].to=read(),e[i].v=read();
    s=read(); t=read();
    solve();
    if(ans.a==100000) printf("IMPOSSIBLE");
    else ans.print();
    return 0;
}

```

---


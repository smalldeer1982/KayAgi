# [HAOI2008] 木棍分割

## 题目描述

有 $n$ 根木棍，第 $i$ 根木棍的长度为 $L_i$，$n$ 根木棍依据编号次序（即最左边是第 $1$ 根木棍，然后是第 $2$ 根木棍，以此类推）连接在一起，总共有 $n-1$ 个连接处。现在允许你**最多**砍断 $m$ 个连接处，砍完后 $n$ 根木棍被分成了很多段，要求满足总长度最大的一段长度最小。

输出总长度最大的一段长度的最小值，并且输出使总长度最大的一段长度最小的方案总数除以 $10007$ 的余数。

## 说明/提示

### 样例解释

可以砍 $1$ 下分成 $1,1$ 和 $10$ 两个部分，也可以砍 $2$ 下分成 $1$、$1$ 和 $10$ 三个部分。

### 数据范围

对于所有的数据，$n \le 50000,\ 0\le m\le \min(n-1,1000),\ 1\le L_i\le 1000$。

## 样例 #1

### 输入

```
3 2                           
1 
1
10```

### 输出

```
10 2```

# 题解

## 作者：niiick (赞：35)

首先**最大的一段长度最小**显然能马上想到**二分**，
先二分出这个长度，再DP求解方案数

假设求解出的长度为$x$，
设$dp[i][j]$表示**前**$j$**个木棍，分成**$i$**组的方案数**(注意是**分**$i$**组**，不是切$i$下)

先初始化$dp[1][i]=[sum[i]<=x]$

$dp[i][j]=\sum_{l=k}^{j-1}dp[i-1][l]$其中$k$为满足$sum[j]-sum[k]<=x$的最小的$k$

$ans=\sum_{i=1}^{m+1}dp[i][n]$

这样的方程复杂度$O(n^3)$，~~实测一个点都过不了~~

我们发现每次找到第一个$sum[j]-sum[k]<=x$的$k$后，由于$sum$单调性，对于后面的一定也满足条件。
所以可以用**前缀和**维护$dp$数组，即$sum[i][j]=\sum_{k=0}^jdp[i][k]$

那么方程变为$dp[i][j]=sum[i-1][j]-sum[i-1][k-1]$

但是到这里我们还是发现狂T不止，原因出在我们对于相同的$j$重复去找$k$，这显然不必要

我们一开始先预处理对于每个$j\in[1,n]$，满足$sum[j]-sum[k]<=x$的第一个$k$是什么
```cpp
int k=0;
for(int i=1;i<=n;++i)
for(;k<i;++k)
if(sum[i]-sum[k]<=x){ rem[i]=k; break;}
```
再次注意这里由于**sum的单调性**，$k$**不用每次置0**，~~否则你还是狂T不止~~

到这里就结束了吗，还没！

我们发现每次转移$dp[i][]$的时候都只用到$sum[i-1][]$， 显然造成了不必要的空间浪费，
可以直接滚掉$dp$和$sum$的第一维

**************

```cpp
//niiick
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
#include<cmath>
using namespace std;

int read()
{
    int x=0,f=1;
    char ss=getchar();
    while(ss<'0'||ss>'9'){if(ss=='-')f=-1;ss=getchar();}
    while(ss>='0'&&ss<='9'){x=x*10+ss-'0';ss=getchar();}
    return x*f;
}

const int mod=10007;
const int maxn=50010;
int n,m,mx,ans;
int a[maxn],sum[maxn];
int dp[maxn],S[maxn];
int rem[maxn];

int check(int x)
{
    int tot=0,len=0;
    for(int i=1;i<=n;++i)
    {
        if(len+a[i]>x) tot++,len=a[i];
        else len+=a[i];
        if(tot>m) return 0;
    }
    return tot<=m;
}

int DP(int x)
{
    int k=0;
    for(int i=1;i<=n;++i)
    for(;k<i;++k)
    if(sum[i]-sum[k]<=x){ rem[i]=k; break;}
    
    int res=(sum[n]<=x);
    for(int i=1;i<=n;++i)
    {
    	if(sum[i]<=x) dp[i]=1;
    	S[i]=(S[i-1]+dp[i])%mod;
    }
    
    for(int i=2;i<=m+1;++i)
    {
        for(int j=1;j<=n;++j)
        {
            dp[j]=S[j-1];
            if(rem[j]-1>=0) dp[j]=((dp[j]-S[rem[j]-1])%mod+mod)%mod;//注意减法出现负数
        }
        for(int j=1;j<=n;++j)
        S[j]=(S[j-1]+dp[j])%mod;
        
        res=(res+dp[n])%mod;
    }
    return res;
}

int main()
{
    n=read();m=read();
    for(int i=1;i<=n;++i) 
    a[i]=read(),sum[i]=sum[i-1]+a[i],mx=max(mx,a[i]);
    
    int L=mx,R=sum[n],mid;
    while(L<R)
    {
        mid=L+R>>1;
        if(check(mid)) ans=mid,R=mid;
        else L=mid+1;
    }
    printf("%d %d",ans,DP(ans));
    return 0;
}
```
最后还是想再吐槽一下这题数据范围完全不科学啊

$O(nm)$的DP+$O(nlog(n*L_i))$的二分，大概出题人~~感性~~觉得能过就这样了吧

---

## 作者：金爷爷哈哈 (赞：27)

还是看没有题解。。。蒟蒻再来水一水。

感觉本题常数卡的特别厉害，，，我交了又改，改了又交最后终于过了（常数是个很迷的问题，有些看起来很2B的写法实则跑的特别快，而一些看起来很紧凑很快的代码则不然。。。）

 
不多扯了赶紧说题，第一问是最简单的二分答案，就不说了。

第二问则要用到dp中的隔板法，对于本题就是找到一个节点i能到达的最左端lef[i]（连续子段和<=第一问中的答案）

f[i][j]代表前i个数分成j块的方案数,则f[i][j]=Σ f[k][j-1]  (k>=lef[i]&&k<i) ，而因为空间问题，是不可以开1000x50000

个数组的， 而本题正好要用到前缀和，甚至连滚动数组都不用开，直接一个数组f记录当前j的所有i的答案，而s记录j-1的所有i的答案的前缀和。

每次求完本轮之后再更新s。

时间复杂度（N\*M）


code:

```cpp
#include<bits/stdc++.h>
#define ll int
using namespace std;
inline void read(ll&x){
    x=0;char ch=getchar();
    while(!isdigit(ch)) ch=getchar();
    for(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';
}
const ll ha=10007;
ll n,m,l,r,mid,ans;
ll a[50005],s[50005],f[50005],tmp=0;
ll lef[50005],now;
inline bool work(ll x){
    ll k=0,t=1;
    for(ll i=1;i<=n;i++)if(a[i]>x) return false;
    else if(k+a[i]>x){
        t++,k=a[i];
        if(t>m) return false;
    }    else k+=a[i];
    return true;
}
int main(){
    read(n),read(m);
    m++;
    for(ll i=1;i<=n;i++) read(a[i]);
    l=1,r=50000000;
    while(l<=r){
        mid=l+r>>1;
        if(work(mid)) ans=mid,r=mid-1;
        else l=mid+1;
    }
    cout<<ans<<' ';
    now=0;
    for(ll i=1;i<=n;i++){
      a[i]+=a[i-1];
      while(a[i]-a[now]>ans) now++;
      lef[i]=now;
    }
    memset(f,0,sizeof(f));
//    f[0]=1;
    fill(s,s+n+1,1);
    for(ll i=1;i<=m;i++){
        for(ll j=1;j<=n;j++) f[j]=(s[j-1]-s[lef[j]-1])%ha;
        s[0]=0;
        for(ll j=1;j<=n;j++) s[j]=f[j]+s[j-1];
        tmp=(tmp+f[n])%ha;
    }
    cout<<tmp;
    return 0;
}
```

---

## 作者：奇米 (赞：12)

# $\mathrm{[HAOI2008]}$ 木棍分割

### 吐槽环节
* 为什么一分部分分不给啊，一开始写了个$n^3$，居然直接爆蛋。
* 前缀和优化$DP$还要滚存

###  **题目意思**

* [题目传送门](https://www.luogu.com.cn/problem/P2511)

### $\mathrm{Sol}$

* 前置知识：**前缀和优化DP**

* 对于第一问就是个$hh$问题，直接二分就可以了。这个没什么好讲，看看代码：

```cpp
inline bool check(int mid) 
{
	int sum=0,all=0;
	//mid:二分的答案，sum：分的组数，all：当前组的总长
	for ( int i=1;i<=n;i++ ) 
	{
		if(a[i]>mid) return false;//有一段大于mid显然不合理
		if(all+a[i]>mid) 
			all=a[i],sum++;
		else all+=a[i];
	}
	return (sum<=m);//判断需要分的最小组数<=m
}
```

* 对于第二问我们可以用$DP$来解决。首先我们会显而易见的想到$f_{i,j}$表示到第$i$根木棒，分成$j$组的方案数。然后就是直接$n^3$做：$f_{i,j}=\sum_{k=1}^{i-1} f_{k,j-1}[sum(i)-sum(k)\leq x]$。我们再来看看$n^3$的代码（不要以为你会有分，就是爆蛋）

```cpp
inline int n_three_dp(int x)//函数名就是n^3，多好
{
	for ( int i=1;i<=n;i++ ) 
		if(sum[i]<=x) f[i][0]=1;//初始化（不用分能将连续几根分在一起）
	for ( int j=1;j<=m;j++ ) //枚举组数
		for ( int i=1;i<=n;i++ )
			for ( int k=0;k<i;k++ ) 
				if(sum[i]-sum[k]<=x) //dp转移
					Add(f[i][j],f[k][j-1]); 
	int ans=0;
	for ( int i=0;i<=m;i++ ) Add(ans,f[n][i]);//统计答案
	return ans;
}
```

* 到现在我们还是$0$分，我们考虑用前缀和优化。$pre_{i,j}=\sum_{k=1}^{j}f_{i,k}$，然后我们用前缀和去更新$f_{i,j}$，就是$f_{i,j}=pre_{i-1,j}-pre_{i-1,k-1}$。然后我们再交一下，发现还是$0$分（qwq.... 
* 那我们仔细观察这个转移发现对于一个固定的$j$我们去枚举若干个$k$会浪费时间。于是我们记录第一个$k$满足$sum_i-sum_k\leq x$的位置为$P_i$。这里有点像容斥（就是总方案数减去不合法方案数）。
* 对于每个$P_i$我们考虑到$sum$的单调性，不需要$O(n^2)$计算。看看代码

```cpp
for ( int i=1;i<=n;i++ ) 
		for ( ;j<i;j++ ) //利用sum的单调性
			if(sum[i]-sum[j]<=x) 
			{
				ed[i]=j;
				break;
			}
```

* 这样我们时空都是$O(n\times m)$，空间不行，考虑滚存（后面就是简单套路了，$f[],pre[]$互相更新即可。
* 具体看代码，这样我们就成功把空间降到$O(n)$，能过

### $\mathrm{Code}$

```cpp
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#pragma GCC optimize("inline")
#pragma GCC optimize("-fgcse")
#pragma GCC optimize("-fgcse-lm")

#include <bits/stdc++.h>
#define pb push_back
//#define int long long
using namespace std;

inline int read()
{
	int sum=0,ff=1; char ch=getchar();
	while(!isdigit(ch))
	{
		if(ch=='-') ff=-1;
		ch=getchar();
	}
	while(isdigit(ch))
		sum=sum*10+(ch^48),ch=getchar();
	return sum*ff;
}

const int N=5e4+5;
const int mo=10007;

int n,m,ans,a[N],sum[N],f[105][1005],g[N],pre[N],ed[N],ret;

inline bool check(int mid,int &s) 
{
	int sum=0,all=0;
	for ( int i=1;i<=n;i++ ) 
	{
		if(a[i]>mid) return false;
		if(all+a[i]>mid) 
			all=a[i],sum++;
		else all+=a[i];
	}
	s=sum+(all!=0);
	return (sum<=m);
}

inline void Add(int &x,int y)
{
	x+=y;
	if(x>=mo) x%=mo;
}

inline int n_three_dp(int x)
{
	for ( int i=1;i<=n;i++ ) 
		if(sum[i]<=x) f[i][0]=1;
	for ( int j=1;j<=m;j++ ) 
		for ( int i=1;i<=n;i++ )
			for ( int k=0;k<i;k++ ) 
				if(sum[i]-sum[k]<=x) 
					Add(f[i][j],f[k][j-1]); 
	int ans=0;
	for ( int i=0;i<=m;i++ ) Add(ans,f[n][i]);
	return ans;
}

inline int dp(int x)
{
	for ( int i=1;i<=n;i++ ) 
	{
		if(sum[i]<=x) g[i]=1;
		pre[i]=pre[i-1]+g[i];
	}
	int j=0;
	for ( int i=1;i<=n;i++ ) 
		for ( ;j<i;j++ ) if(sum[i]-sum[j]<=x) 
			{
				ed[i]=j;
				break;
			}
	for ( int j=2;j<=m+1;j++ ) 
	{
		for ( int i=1;i<=n;i++ ) 
		{
			g[i]=pre[i-1];
			if(ed[i]>=1) g[i]=(g[i]-pre[ed[i]-1]+mo)%mo;
		}
		pre[0]=0;
		for ( int i=1;i<=n;i++ ) 
			pre[i]=(pre[i-1]+g[i])%mo;
		Add(ret,g[n]);
	}
	ret+=(sum[n]<=x);
	return (ret+mo)%mo;
}
			
signed main()
{
	n=read();
	m=read();
	int mx=0;
	for ( int i=1;i<=n;i++ ) 
	{
		a[i]=read();
		mx=max(mx,a[i]);
		sum[i]=sum[i-1]+a[i];
	}
	int l=mx,r=sum[n];
	ret=0;
	while(l<=r)
	{
		int mid=(l+r)/2;
		int s=0;
		if(check(mid,s)) 
			ans=mid,r=mid-1;
		else l=mid+1;
	}
	if(n<=100) 
		printf("%d %d\n",ans,n_three_dp(ans));
	else 
		printf("%d %d\n",ans,dp(ans));
	return 0;
}
```


---

## 作者：无咕_ (赞：10)

## 题解索引
1. **题目大意**
2. **Solution**
3. **AC code**
4. **类似题型**

代码类型： C++（cpp）

是否吸氧：否

不压行代码长度：38

------------

## 题目大意
题面：[<传送门>](https://www.luogu.com.cn/problem/P2511)

题意：有 $n$ 条线段，给出 $n$ 条线段的长度。线段初始是连接在一起的，现要求你切断 **最多** $m$ 处，要求求出：

1. 切割后，**总长度最大且长度值最短** 的值对 $10007$ 取模的结果。

2. 输出 **满足第一问** 的方法数。

~~术语理解：前缀和优化dp。~~

## Solution

~~第一次用紫题骗咕值，好鸡冻~~

声明：本题解中有一些部分确实借鉴了楼上楼下大佬们的部分内容，不过还是可以保证部分的原创性 ~~因为我不会写sigma，更不知道多个sigma连在一起对不对，有错见谅~~ 。

首先，我们可以看到这道题有一个特点：

切割时，只能切 **原有的分段连接处**。

我们按问题来吧，题目有两问，我们从第一问开始。

### 第一问：切割后，总长度最大且长度值最短的值对10007取模的结果

这个问题灰常简单，既然是找最合适的答案，无疑是 **二分答案** 最合适了。

做二分，首先确定数据所在的范围。第一问的答案范围无疑是 $0$ ~ $(50000*1000)$ ~~（这么点数据用模拟就行）~~ 。

二分的基础思路就是假设，假设这个答案能行，代入进去算一遍看行不行。

我们假设的是最长长度，那么要求是首先不能有单一一段比他大的值，再一个就是分组的问题，分段的原则是 **能少分就少分** 。

最后分完段，再判断能不能分这么多段就行了。

### 第二问：输出满足第一问的方法数

其实说真的，楼上楼下的DALAO们都写了好多长串的公式，本人学问浅薄，不会写那些复杂的式子/fad。

#### n^3做法：黑 魔 法

~~按照楼上楼下大佬们写的~~ 按照我们平常的思路，一般都会想到这个dp：

设 $f[i][j]$ 表示前 $i$ 根木棍分 $j$ 组的方案数，

$\sum_{j=1}^{m+1} \sum_{i=1}^{n}\sum_{k=0}^{i}f[i][j]+f[k][j-1]$ ，

前提是 ```sum[i]-sum[k]<=ans1//ans1代表第一问的答案``` 。

其意义为枚举 $k$ 为分割点， $i$ 为木棍总数的枚举， $j$ 为分割点总数的枚举。

这里的 $m$ 是加了一的，因为割 $m$ 下分了 $m+1$ 段。

因其时间复杂度为 $O(n^3)$ 所以会 ~~学会黑魔法~~ T掉。

#### n*m做法：能 省 就 省

从上面的黑魔法我们了解到，靠三重循环是会T掉的。但当我们时间压到死之后又会发现， $f[50000][1000]$ 的数组是开不起的（我电脑太差还是）。

当然也可以用楼上楼下大佬的方法：用 ```short``` 建数组。

可我觉得这对数组不公平/dk

于是我写了一种只用一维数组去维护的方法。

首先，我们不论如何最终都是要求 $n$ 段分 $m+1$ 段，我们就可以直接压掉前面的那一维，没有必要了。

这样下来，都不需要滚动数组了。 ~~其实是我不会写~~

好的好的，正式开始讲了：

~~根据题目标签~~ 我们可以先建一个前缀和数组，用于存储前缀和，

```
sum[i]表示分成i组的方案总数的前缀和
```

然后写出dp数组，

```
f[i]表示分成i组的方案总数
```

根据一维前缀和数组的原理（此处是例子，不是此题答案），

```
sum[i]-sum[i-1]表示i的值
```

但我们如果原样套上的话，是错误的（因为他并不是 $i$ 的前缀和，而是分成 $i$ 组的方案总数的前缀和，所以我们应该将数组下标改成分成 $i$ 组的，即改成分成 $i$ 组的方案总数的起始点和结束点）。

于是为便于计算分成 $i$ 组的方案总数的起始点，又一个新数组诞生了：

```
zuo[i]表示i如果靠左分组i所能到达的最远结点
```

我们统计最靠左的结点时需要看具体值才能找出最合适的值，但求数组中一段的和最快最简便的还是前缀和数组，于是我们又有了一个数组：

```
for(int i=1;i<=n;i++){
    a[i]+=a[i-1];//将a数组变成前缀和数组，因为a数组已经没用了（其实是我懒）
}
```

然后对于每个不同的 $i$ ，

```
while(a[i]-a[now]>ans1)now++;
zuo[i]=now;
```

这样就能找到合适的点了，那么我们计算分成 $i$ 组的方案总数就是：

```
sum[i]-sum[zuo[i]-1]
```

然后我们初始化数组，注意 $sun[i]$ 首先先全部为 $1$ （因为 $f[i]$ 还没算），$f[i]$ 初始化为 $0$ 。

接着是友善的dp方程，然后是更新前缀和，记录答案 ```ans2``` 

最后输出，这么愉快的结束了

当然还有一点我要讲，对于计算时的取模运算，一定要复制原题中的数字，不然很容易打错。 ~~要不是我因为10007写成了1007……这题解还能年轻一小时~~

## AC code
首先说下，具体的代码注释我都写在里面了。拒绝抄袭，从我做起（主要懂了就能写出来，没必要抄代码，不然还拿个棕名）

```cpp
#include<iostream>
#include<cstdio>
#define mods 10007
using namespace std;
const int MAX=5e5+9;
int n,m,a[MAX],ans1,ans2=0,sum[MAX],f[MAX],now=0,zuo[MAX];
bool check(int x){
    /***********************
    思路：假设x成立，那么开始分组，每次当前组的总长度加上当前枚举的长度超过了x时，就重新分一个组（尽量少分组），最后分完看看这些组成不成立 
    ************************/
    int len=0,num=1;//当前分组的总长度，当前总分的组数 
    for(int i=1;i<=n;i++){ 
        if(a[i]>x)return false;//如果成立则x不成立 
        len+=a[i];//加入当前组 
        if(len>x)num++,len=a[i];//如果加入此组后大于了x，那么重新分一个组，并将a[i]作为新组的初始长度
    }return num<=m;//看看这个最长是不是成立
}int main(){
    scanf("%d%d",&n,&m);m++;
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
    }int l=1,r=50000000;
    while(l<=r){
        int mid=(l+r)/2;
        if(check(mid))ans1=mid,r=mid-1;
        else l=mid+1;
    }cout<<ans1<<" ";
    for(int i=1;i<=n;i++){
        //a数组后面没用处了所以直接霍霍就行 
        a[i]+=a[i-1];//将a数组变成前缀和数组 
        while(a[i]-a[now]>ans1)now++;//寻找最左点
        zuo[i]=now;//记录最左结点 
    }for(int i=0;i<=n;i++)f[i]=0,sum[i]=1;//初始化
    zuo[0]=1;//因为后面zuo[0]-1变成-1，越界了，所以变成1 
    for(int i=1;i<=m;i++){//段数（砍i-1段） 
        for(int j=1;j<=n;j++)f[j]=(sum[j-1]-sum[zuo[j]-1])%mods;//分成j块的分法总数等于j-1到zuo[j]的合理范围总数
        if(i==1)sum[0]=0;////为了完善后一句，不让后一句出错
        for(int j=1;j<=n;j++)sum[j]=f[j]+sum[j-1];//前缀和赋值（分成j块的分法总数的前缀和=分j块数的分法总数+分j-1块的前缀和） 
        ans2=(ans2+f[n])%mods;//更新答案（砍法+=分n块的总数） 
    }cout<<ans2<<endl;
    return 0;
}
```
AC记录[<传送门>](https://www.luogu.com.cn/record/47413398)

## 类似题型

[P1043 [NOIP2003 普及组] 数字游戏](https://www.luogu.com.cn/problem/P1043)



---

## 作者：zac2010 (赞：6)

### 思路

这道题是一个比较经典的题，特别是通过一个问题的约束去求解下一个问题的这个思维。

对于第一问，由于是要求总长度最大的那一段最小，不难发现其具有单调性，我们可以采用二分解决。我们二分最大的那段的长度 $len$，贪心地去选取：每一段只要不超过 $len$，长度越大越好，合法性的话只要判断最后的段数是否小于等于 $m+1$ 即可（题目说最多切 $m$ 刀，也就等价于最多切成 $m+1$ 段）。

第二问，我们采用动态规划算法。首先对原数组做一个前缀和，得到 $sum_i$ 表示前 $i$ 根木棍的总长度。我们设 $f_{i,j}$ 为前 $j$ 根木棍分成 $i$ 组的方案数，那么有：
$$
f_{i,j} = \sum^{j-1}_{k=t} f_{i-1,k}
$$
其中 $t$ 为满足 $sum_j-sum_t$ 的最左边的 $t$，而 $t$ 可以通过预处理计算，预处理可以采用二分的形式（我的代码里用的是 $O(n)$ 的方法，对于逐渐增大的 $j$，变量 $t$ 是递增的）。

最后的答案就是 $\sum^{m+1}_{i=1} f_{i,n}$，时间复杂度 $O(n^3)$。

我们发现转移过来的是连续的一段区间，所以我们采用前缀和优化，用 $g$ 数组表示前缀和，有 $g_{i,j} = \sum^{j}_{k=1}f_{i,k}$。

那么转移式子变成了：
$$
f_{i,j} = g_{i-1,j-1} - g_{i-1,k-1}
$$

#### 思路要点

1. 要你求多个不同的问题时，不妨看看能否先求出其中任意一个，再通过这一个求出其它的。

   像这一题就是先求出第一问，再通过第一问的约束求出第二问。

2. 动态规划需要较低的转移时间且能转移过来的是一段区间的话，可以试一下能否用前缀和优化。

### 代码

```cpp
#include <bits/stdc++.h>
#define re register
#define L(i, a, b) for(re int i = a; i <= b; i++)
#define R(i, a, b) for(re int i = a; i >= b; i--)
using namespace std;
const int N = 50010, M = 1010, mod = 10007;
int n, m, ans, len, a[N], p[N], sum[N], f[N], g[N];//f和g两数组第一维没用，优化掉了
void upd(int &x, const int y){
    x = y;
    if(x < 0) x += mod;//加法比取模快多了，等价于 x %= mod
    if(x >= mod) x -= mod;//减法比取模快多了，等价于 x = (x % mod + mod) % mod
}
bool check(const int x){
	re int cnt = 0, sum = 0;
	L(i, 1, n){
		if(a[i] > x) return 0;
		if(sum + a[i] > x) sum = a[i], cnt++;
		else sum += a[i];
	}
	return cnt < m;//等价于cnt + 1 <= m，因为最后一段没算进去，所以cnt要加1
}
int main(){
	scanf("%d%d", &n, &m), m++;
	L(i, 1, n) scanf("%d", &a[i]);
	re int l = 1, r = 1e9, id = 1;
	while(l <= r){
		int mid = l + r >> 1;
		if(check(mid)) r = mid - 1, len = mid;//len为第一问答案
		else l = mid + 1;
	}
	L(i, 1, n){
		sum[i] = sum[i - 1] + a[i];
		if(sum[i] <= len) f[i] = 1;
		while(id <= n && sum[i] - sum[id] > len) id++;
		p[i] = id;
	}
	L(j, 1, n) upd(g[j], g[j - 1] + f[j]);
	upd(ans, ans + f[n]);
	L(i, 2, m){
		L(j, 1, n) upd(f[j], g[j - 1] - (p[j] - 1 < 0? 0 : g[p[j] - 1]));
		L(j, 1, n) upd(g[j], g[j - 1] + f[j]);
		upd(ans, ans + f[n]);
	}
	printf("%d %d\n", len, ans);
	return 0;
}
```

---

## 作者：y2823774827y (赞：5)

一眼题系列，本题似乎没有暴力分~~整个题就是暴力~~

$(1)$二分解决

$(2)$ 1. 二分预处理$let[i]$ 为能与第$i$个组成块的最左边位置，不过本题没卡$O(n^2)$也可过

$~~~~~~$2.$dp[i][j]$为第$i$个为第$j$块结尾的方案数：

$~~~~~~~~dp[i][j]=\sum\limits_{k=let[i]}^idp[k-1][j-1]$显然空间时间都会爆

$~~~~~~~~$改成滚动数组，套个前缀和

取模和$long long$这里注意一下不开O2也能过~~本人太懒~~

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const LL maxn=50009,p=10007;
LL n,m,sum,ans,num,now,lst;
LL a[maxn],let[maxn],dp[2][maxn],pre[2][maxn];
inline bool Check(LL x){
	LL len(0),ret(1);
	for(LL i=1;i<=n;++i){
		if(a[i]>x) return false;
		len+=a[i];
		if(len>x) ++ret,len=a[i];
	}
	return ret<=m?true:false;
}
int main(){
	scanf("%lld%lld",&n,&m); ++m;
	for(LL i=1;i<=n;++i) scanf("%lld",a+i),sum+=a[i];
	LL l(1),r(sum);
	while(l<=r){
		LL mid(l+r>>1);
		if(Check(mid)) r=mid-1,ans=mid;
		else l=mid+1;
    }
	for(LL i=1;i<=n;++i){
		LL len(0);
		for(LL j=i;j>=1;--j){
			len+=a[j];
			if(len>ans){
				let[i]=j+1;
				break;
			}
		}
		if(!let[i]) let[i]=1;
	}
	now=0,lst=1;
	for(LL i=0;i<=n;++i) pre[0][i]=1;
	for(LL j=1;j<=m;++j){
		now^=1,lst^=1;
		memset(pre[now],0,sizeof(pre[now]));
		memset(dp[now],0,sizeof(dp[now]));
	    for(LL i=1;i<=n;++i){
	    	if(i<j) 
			    dp[now][i]=0;
	    	else if(let[i]-2>=0)
	    	    dp[now][i]=(pre[lst][i-1]-pre[lst][let[i]-2]+p)%p;
	    	else 
			    dp[now][i]=pre[lst][i-1];
	        pre[now][i]=(pre[now][i-1]+dp[now][i])%p;
	    }
	    num=(num+dp[now][n])%p;
	}
	printf("%lld %lld",ans,num);
	return 0;
}
```

---

## 作者：xyin (赞：4)

下面写的大概是自己在做这道题的思路历程。

## PART 1

最开始拿到这道题的时候直接就开始了无脑 DP，设 $f_{i,k}$ 表示考虑了前 $i$ 个数划分成 $k$ 段时最小的最大值，转移为：
$$f_{i,k}=\min\limits_{0\le j<i}\left\{\max(f_{j,k-1},s_i-s_j)\right\}$$
发现答案还需要求解方案数，设 $g_{i,k}$ 表示考虑了前 $i$ 个数，划分成 $k$ 段且最大值最小时的方案数，转移为：

$$g_{i,k}=\sum\limits_{0\le j<i} g_{j,k-1}[\max(f_{j,k-1},s_i-s_j)=f_{i,k}]$$

综上，时间复杂度为 $O(n^3)$，而且这玩意儿又有取 min 又有取 max，用前缀和优化也不好维护。

## PART 2

我们回过头去再仔细读题（大家不要像我一样，最开始的时候就要仔细读好题），这次脑子提取关键词：**最小的最大值**。看到这儿然后就开始想二分：二分一个最大值，每次只需判断这个最大值是否合法，这样就可以简化我们的 DP 任务了。

设 $f_{i,k}$ 表示考虑了前 $i$ 个数划分成 $k$ 段且每段大小不超过 $res(res=mid)$ 的方案数，转移为：

$$f_{i,k}=\sum\limits_{0\le j<i} f_{j,k-1}[s_i-s_j<=res]$$

发现每次转移的都是一个后缀，考虑用前缀和优化。设 $g_{i,k}=\sum\limits_{0\le j<i} f_{j,k-1}[s_i-s_j<=res]$，则 $f_{i,k}=g_{i,k}$（好像可以省去 $f_{i,k}$ 这个数组，但我懒得想了）。算了一下内存，爆空间啦！但是你用滚动数组滚一轮就好啦。最后的答案 $ans=\sum\limits_{k=1}^n f_{n,k}$，如果 $ans\neq 0$ 则该二分答案合法，否则不合法。

$g_{i,k}$ 的转移可以用队列和一个 $sum$ 变量维护，具体的：

1. 如果 $s_i-s_{q[head]}>res$，则 $sum\leftarrow (sum-f_{q[head]})$，弹出队头。

2. 更新 $g_{i,k}$：$g_{i,k}\leftarrow sum$。

3. 加入 $i$：$sum\leftarrow(sum+f_i)$，将 $i$ 入队。

看到还有一种写法是对每个 $i$ 预处理出 $l_i$ 表示第一个能转移的点，$g_{i,k}=\sum\limits_{0\le j<i} f_{j,k}$，转移为 $f_{i,k}=g_{i-1,k}-g_{l_i-1,k}$。

时间复杂度为 $O(nm\log M)$，其中 $M$ 为二分的值域，得分 $20$ 分。

## PART 3

就在我以为还有什么神秘做法的时候，瞄一眼题解，怎么他们的 check 函数不是 DP？好吧，之前是我唐氏了。二分 check 的时候直接贪心判断即可：能不划就不划，判断最后的划分次数是否超过 $m$，时间复杂度 $O(n)$。综上，二分+DP+前缀和优化，总时间复杂度为 $O(n\log M+nm)$，得分 $100$ 分。

总结：别拿到一道题就开始莽，得先好好读题，仔细分析题目性质。能有更简单还更优的你怎么没想到呢？

**[code](https://www.luogu.com.cn/paste/1wzkgpkk)**

---

## 作者：Day_Dreamer_H (赞：4)

# P2511 题解

## 思路

首先第一问肯定是二分处理，每次判断长度为 $mid$ 时截断可不可以，统计即可，答案储存于 $l$ 中。 

对于第二问，我们首先有一个想法，就是将 $dp_{i,j}$ 为从 $1$ 到 $i$ 的木棍拆分成 $j$ 组。

那么我们发现前 $i$ 节分 $j$ 组可以从前 $1$ 节到 $i-1$ 节分 $j-1$ 组转移（前提是长度不能超过第一问的答案）。 

两段之间的长度肯定是前缀和求解，不如储存于 $pre$ 数组内 。 

那可以列出一个式子 $dp_{i,j}=\sum^{i-1}_{k=1} dp_{k,j-1}\times[pre_i-pre_{k}\le l]$ 其中中括号内若为真则为 $1$，否则为 $0$。 

显然，这里我们要三重 `for` 循环分别处理 $i,j,k$。

那么怎么优化呢？

我们发现一个很有意思的事情，其实我们不一定每次都要枚举 $k$，因为中括号中内容并不受 $j$ 影响，而 $dp_{k,j-1}$ 我们其实可以用第二个前缀和数组储存，每次重新更新即可。

那我们可以预处理出 $k$ 相关的东西，而这是 $O(n^2)$ 的。 

目前我们的算法时间复杂度已经是 $O(n^2)$ 的，勉强够用。 

然后我们发现 MLE 了。 

不过这里其实你已经也发现了，我们的 $dp_{i,j}$ 只跟 $pre$ 和上一列相关。 

那我们为什么要存那么多没用的东西？没错，滚动数组。

自认为说的很清楚了，详细见代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MOD = 10007;
int n,m,result;
int a[50005],pre[50005],predp[50005],dp[50005],pos[50005];
bool check(int x){
	int pre = 0,counter = 0;
	for(int i = 1;i<=n;i++){
		if(a[i]>x)return false;
		if(pre+a[i]>x){
			pre = 0;
			counter++;
		}
		pre+=a[i];
	}
	return (counter<=m);
}
int main(){
	cin>>n>>m;
	for(int i = 1;i<=n;i++){
		cin>>a[i];
		pre[i] = pre[i-1]+a[i];
	}
	int l = 1,r = 1e9;
	while(l<r){
		int mid = (l+r)>>1;
		if(check(mid)){
			r = mid;
		}else{
			l = mid+1;
		}
	}
	for(int i = 1;i<=n;i++){
		if(pre[i]<=l){
			dp[i] = 1;
		}
		predp[i]+=predp[i-1]+dp[i]; 
	}//第一节特殊处理
	for(int i = 1;i<=n;i++){
		for(int j = 0;j<i;j++){
			if(pre[i]-pre[j]<=l){
				pos[i] = j;
				break;//之后的肯定也符合条件 
			}
		}
	}
	for(int j = 2;j<=m+1;j++){
		for(int i = 1;i<=n;i++){
			dp[i] = predp[i-1];
			if(pos[i]>=1){
				dp[i] = (dp[i]-predp[pos[i]-1]+MOD)%MOD;
			}
		}
		predp[0] = 0;
		for(int i = 1;i<=n;i++){
			predp[i] = (predp[i-1]+dp[i])%MOD;
		}
		result = (result+dp[n])%MOD;
	}
	if(pre[n]<=l)result++;//一整条都可以的特殊处理 
	cout<<l<<" "<<result;
}
```

---

## 作者：Grussg (赞：4)

# Part One 背景&闲谈
------------
## 1.1题面
 [题目戳这里](https://www.luogu.org/problem/P2511)

## 1.2由来
蒟蒻的【某算法（不泄露算法）】是真的垃圾 

教练威逼之下要找个题来讲。准备了蛮久，也做了PPT。就顺便做个题解，为了 ~~（刷个咕值）~~ 可以帮助一些对【某算法（不泄露算法）】不了解的同学。

# Part Two 解题
------------
## 2.1 思路

从题目中看来，问题可以分为两个子问题。我们分为两个部分来解决。

### 2.1.1 子问题1
找一个最大值最小，基本可以锁定二分。简单二分即可解决

### 2.1.2 子问题2 
其实一开始也是一脸懵逼，如果是数据结构数论啥的我也不会来这里写题解。贪心啥的实在是太难想（口胡一下）因为这道题实在是太极限，正解也是压着1个亿的时间复杂度的。好吧是DP  ~~（极其毒瘤）~~

先想一想二维DP ~~（二维肯定是开不下，先想一想好不好！）~~

先提一个小tips 相对于考虑把哪一个节点割开，考虑哪些木棍接在一起会更加容易思考一些呢？

然后再思考 

定义一个二维DP数组 $ f[i][j]$     
     
存的是前i个棍子分成了j块的方案数

枚举一个k，k的范围是左边的能和这根棍子组成一块的，枚举每个k $f[i][j]= \sum f[k][j-1] $

我们可以预处理一个$ left[i] $ 来存每个i值对应**最左边**的木棍编号 (刚好能组成一段的和$ <=$第一问的答案）

最后的DP方程式可以视为

> $f[i][j]= \sum_{k \in [left[i],i)} f[k][j-1] $

## 2.2 优化
看了一眼数据范围，二维数据范围显然是无法开的下来的。

想一想如何滚掉一维。

对于$i$所代表的位置事实上是不必要的。显然的，对于同一层$ f[i][j] $, 随着$ j $的递增，$f[i][j]$也是随着其递增的。所以我们可以利用前缀和的思想，开一个数组 $s$来存$left[j]-j-1$的方案数值，再开一个一维的数组$f$来存答案。每次更新完$f$后再更新$s$。**特别注意，代码里i是循环分成多少组，j循环的是位置**

## 2.3 代码

```cpp
#include<bits/stdc++.h>
#define ri register int 
#define ll long long
#define mid (l+r)/2
using namespace std;
const ll mod=10007;
ll n,m,l,r,ans,sum,now;
ll a[50005],f[50005],s[50005],lef[50005];
template <class T> inline void read(T&x){
	bool f;char ch=getchar();
	for(f=false;!isdigit(ch);ch=getchar())if(ch=='-')f=true;
	for(x=0;isdigit(ch);x=(x<<1)+(x<<3)+(ch^48),ch=getchar());
	x*=f==1?-1:1;
}

inline bool check(int x){
	ll had=0,t=1;
	for(ri i=1;i<=n;i++){
		if(a[i]>x) return false;
		else if(had+a[i]>x){
			t++,had=a[i];
			if(t>m) return false;
		}
		else had+=a[i];
	} 
	return true;
}

inline ll tr_half(){
	l=0,r=50000000;
	while(l<=r){
		if(check(mid)) ans=mid,r=mid-1;
	  else l=mid+1;
	}
	cout<<ans<<" ";
}
int main(){
	read(n),read(m);m++;
	for(ri i=1;i<=n;i++) read(a[i]);
    tr_half();//基本二分
	for(ri i=1;i<=n;i++) {
		a[i]+=a[i-1];
		while(a[i]-a[now]>ans) now++;
		lef[i]=now;
	} //for(int i=1;i<=n;i++) cout<<a[i]<<" *";
	fill(s,s+n+1,1);//cout<<m<<"*";
	for(ri i=1;i<=m;i++){
		for(ri j=1;j<=n;j++){
        		if(lef[j]-1>=0)f[j]=(s[j-1]s[lef[j]-1])%mod;
				  else f[j]=(s[j-1])%mod;
        		}
		s[0]=0;//for(int j=1;j<=n;j++) //cout<<f[j]<<" ";cout<<endl;
		for(ri j=1;j<=n;j++) s[j]=f[j]+s[j-1];
		sum+=f[n];//结合上面语言看，其实很好懂，i，j换位要注意。
		sum%=mod;
	}
	cout<<sum%mod;
	return 0;
}
```
# Part Three 写在最后

## 3.1 杂谈
感谢 @金爷爷哈哈 （UID：31377）的题解对我在学习中的帮助

CSNY出品

CSP 2019 Rp++

希望对大家有帮助，有问题也可以私戳我

## 3.2 更新记录

### $Vol1 $    2019.10.30 首次提交

### $updata1 $ 2019.10.31 同机房 @$rack$奆佬使用强大的$Linux$看出了一个锅


```cpp
for(ri j=1;j<=n;j++) f[j]=(s[j-1]-s[lef[j]-1])%mod;
```
这里$lef[i]-1$ 是有可能到-1的，而数组下标不可能为负

~~谁知道强大的Windows检测不出来还给我过了~~

所以只用加一个特判就好了

```cpp
	if(lef[j]-1>=0)f[j]=(s[j-1]-s[lef[j]-1])%mod;
	else f[j]=(s[j-1])%mod;
```
在前面的代码里已经修改






---

## 作者：xyz32768 (赞：3)

第一问，二分答案即可求出最优值res。

第二问DP。

预处理出木棍长的前缀和sum[]。

用两个指针l, r扫一遍，求出对于所有的i满足sum[i]-sum[k-1]<=res的最小的k值存进nxt[]中。

然后设f[i][j]为前第i个木棍，分成j块（注意不是切j次）的方案数，

则有f[i][1]=(sum[i]<=res)，f[i][j]=sigma(f[k][j-1], nxt[i]-1<=k<i)，最后答案为sigma(f[n][j], 1<=j<=m+1)。

但是这样时空复杂度都是无法承受的。

考虑优化。对于空间优化，由于第二维j只与j-1有联系，所以在这里滚动第二维。

对于时间优化，先调换循环的层次，即第一层循环j，第二层循环i。

对于每一个j，在计算出对应的f[][j]时，同时计算出f[][j]的前缀和供下一个j使用（实现见代码）。

这样空间复杂度O(n)，时间复杂度O(nm)，可以承受。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
const int N = 5e4 + 5, PYZ = 1e4 + 7;
int n, m, a[N], sm[N], f[2][N], nxt[N];
bool check(int mid) {
    int i, sum = 0, tot = 1;
    for (i = 1; i <= n; i++)
        if (sum + a[i] <= mid) sum += a[i];
        else {
            if (a[i] <= mid) sum = a[i], tot++;
            else return 0;
            if (tot > m) return 0;
        }
    return tot <= m;
}
int solve() {
    int l = 1, r = 5e7, mid;
    while (l <= r) {
        mid = l + r >> 1;
        if (check(mid)) r = mid - 1;
        else l = mid + 1;
    }
    return l;
}
int main() {
    int i, j, res, ans; n = read(); m = read() + 1;
    for (i = 1; i <= n; i++) a[i] = read(), sm[i] = sm[i - 1] + a[i];
    printf("%d ", res = solve());
    for (i = 1, j = 1; i <= n; i++) {
        while (j < i && sm[i] - sm[j - 1] > res) j++;
        nxt[i] = j;
    }
    for (i = 1; i <= n; i++) f[1][i] = f[1][i - 1] + (sm[i] <= res);
    ans = sm[n] <= res;
    for (j = 2; j <= m; j++) {
        int op = j & 1; f[op][j - 1] = 0;
        for (i = j; i <= n; i++) {
            f[op][i] = (f[op ^ 1][i - 1] - (nxt[i] == 1 ? 0 :
            f[op ^ 1][nxt[i] - 2]) + PYZ) % PYZ;
            if (i == n) (ans += f[op][n]) %= PYZ;
            (f[op][i] += f[op][i - 1]) %= PYZ;
        }
    }
    cout << ans << endl;
    return 0;
}
```

---

## 作者：VitrelosTia (赞：2)

首先第一问直接二分答案贪心 check 就行了，记二分出来的答案为 $x$。

然后第二问考虑设 $f_{i, j}$ 表示考虑到 $i$ 已经分了 $j$ 段。记 $\displaystyle L(x, y) = \sum_{i=x}^{y}l_i$，这个可以用前缀和求出。然后枚举上一个断点在哪里，暴力转移就是

$$\displaystyle f_{i,j}=\sum_{k=1}^{i-1}f_{k,j-1}[L(k+1,i)\le x]$$

复杂度无法接受，需要优化。考虑这是一个和式，自然想前缀和优化，但是还有一个限制。发现 $x$ 是固定的，而对于一个 $i$，可以转移的区间显然是一段后缀，那就可以双指针/二分先预处理 $p_i$ 表示最左边满足 $L(k+1,i)\le x$ 的 $k$ 的位置，这样转移变成

$$\displaystyle f_{i,j}=\sum_{k=p_i}^{i-1}f_{k,j-1}$$

然后 $j$ 这一维可以滚掉，$i$ 这一维是显然的前缀和形式，直接做就可以了，实现的时候为了方便把 $i,j$ 换了一下。答案是 $\displaystyle \sum_{j=1}^{m+1}f_{n,j}$，时间复杂度 $O(nm)$。

```cpp
const int N = 5e4 + 5, M = 1005, mod = 10007;
int n, m, x, l[N], s[N];
int p[N], f[N], g[N];

signed main() {
    ios::sync_with_stdio(false); cin.tie(nullptr);
    cin >> n >> m; int mx = 0;
    for (int i = 1; i <= n; i++) cin >> l[i], mx = max(mx, l[i]), s[i] = s[i - 1] + l[i];
    auto check = [&](int x) {
        int now = 0, cnt = 0;
        for (int i = 1; i <= n; i++) {
            if (now + l[i] > x) now = l[i], cnt++;
            else now += l[i];
        }
        return cnt <= m;
    };
    for (int l = mx, r = s[n], mid; mid = (l + r) >> 1, l <= r; check(mid) ? r = mid - 1, x = mid : l = mid + 1);
    for (int i = 1, j = 1; i <= n; i++) { while (s[i] - s[j - 1] > x) j++; p[i] = j - 1; }
    for (int i = 1; i <= n; i++) { if (s[i] <= x) f[i] = 1; (g[i] = g[i - 1] + f[i]) % mod; } int ans = f[n];
    for (int i = 2; i <= m + 1; i++) {
        for (int j = 1; j <= n; j++) f[j] = (g[j - 1] - g[p[j] - 1] + mod) % mod;
        for (int j = 1; j <= n; j++) g[j] = (g[j - 1] + f[j]) % mod;
        (ans += f[n]) %= mod;
    }
    cout << x << ' ' << ans;
    return 0;
}
```

---

## 作者：sinsop90 (赞：2)

题意:

$n$ 个木棍连在了一起, 其中第 $i$ 个木棍长度为 $l_i$, 总共有 $n-1$ 个连接处

现在在这 $n-1$ 个连接处中最多断开 $m$ 处, 试求断开后各个段长度的最大值的最小值 , 并输出有多少种方案使得各个段长度的最大值达到最小值。

题解:

将这个问题转化为两个子问题:

1.求出断开后各个段长度的最大值的最小值。

2.有多少种方案使得各个段长度的最大值达到最小值。

显然第二个子问题依赖于第一个子问题的解,即不能在不求出第一个子问题的解前求出第二个子问题的解。

对于第一个子问题,能看出来这是一个二分的模板,~~直接把P1182的代码复制过来~~

我们对我们要求的解进行二分，于是代码如下:

```
bool check(int x) {
	int k = 0, cut = 0;
	for(int i = 1;i <= n;i++) {
		k += mps[i];
		if(k > x) cut ++, k = mps[i];
	}
	if(cut > m) return false;
	return true;
}

while(l <= r) {
	int mid = (l + r) >> 1;
	if(check(mid)) {
		ans = mid;
		r = mid - 1;
	}
	else l = mid + 1;
}
```

接着我们得出了第一个子问题的解 $ans$, 我们考虑设计 $dp$ 方程解出第二个方程的解:

我们设 $f_{i,j}$ 为将前 $j$ 个数分成 $i$ 段的解的个数, 有方程:

$f_{i,j}=\sum_{k=1}^{i-1}f_{i-1,k}$

又因为我们不能让每一段的和超过 $ans$, 正确的方程如下:

$f_{i,j}=\sum_{k=1}^{i-1}f_{i-1,k}\sum_{p=k+1}^{i-1}l_p≤ ans]$

我们~~仔细观察~~不难发现 $l_p$ 的值从不改变, 因此我们可以用前缀和 $pre $ 维护 $l$ 数组

于是我们的方程变成了这样:

$f_{i,j}=\sum_{k=1}^{i-1}f_{i-1,k}[{pre_{i-1}-pre_k}≤ans]$

我们~~又仔细观察~~不难发现 $pre$ 数组是单调递增的, 因此如果我们设:

$q = $ 满足 $pre_{i-1}-pre_{p} ≤ ans$ 的最小的 $p$

则对于任意的 $p\ (q ≤ p ≤ i-1)$ 一定有 $pre_{i-1}-pre_{p} ≤ ans$

因此我们发现可以用一个前缀和维护:

$\sum_{k=q}^{i-1}f_{i-1,k}$

我们 ~~再一次仔细观察~~ 发现对于一个 $i$, 它意义下的 $q$ 永远不变, 因此我们可以预处理出来。

于是复杂度降为了 $O(nm)$, 但是空间复杂度可能会爆炸。

我们发现在每一次更新 $f$ 数组时, 我们只动用了 $f_{i-1}$, 因此我们可以滚掉 $f$ 的一位。

对于 $f$ 的前缀和也同理, 这样就可以过了。代码如下:

```
#include <bits/stdc++.h>
#define maxn 50005
const int mod = 1e4 + 7;
using namespace std;
int n, m, mps[maxn], maxk, f[maxn], q[maxn << 4], l, r, pre[maxn], nxt[maxn], sum[maxn], ans;
bool check(int x) {
	int k = 0, cut = 0;
	for(int i = 1;i <= n;i++) {
		k += mps[i];
		if(k > x) cut ++, k = mps[i];
	}
	if(cut > m) return false;
	return true;
}
int main() {
	scanf("%d%d", &n, &m);
	for(int i = 1;i <= n;i++) {
		scanf("%d", &mps[i]);
		maxk = max(maxk, mps[i]);
	}
	int l = maxk, r = 1000005;
	while(l <= r) {
		int mid = (l + r) >> 1;
		if(check(mid)) {
			ans = mid;
			r = mid - 1;
		}
		else l = mid + 1;
	}
	for(int i = 1;i <= n;i++) pre[i] = pre[i - 1] + mps[i];
	for(int i = 1;i <= n;i++) {
		if(pre[i] <= ans) f[i] = 1;
		sum[i] = sum[i - 1] + f[i];
		sum[i] %= mod;
	}
	for(int i = 1, p = 1;i <= n;i++) {
		while (pre[i] - pre[p - 1] > ans) p++;
		nxt[i] = p - 1;
	}
	int res = (pre[n] <= ans);
	for(int i = 2;i <= m + 1;i++) {
		for(int j = 1;j <= n;j++) {
			f[j] = sum[j - 1] - sum[nxt[j] - 1];
			f[j] = (f[j] % mod + mod) % mod;
		}
		for(int j = 1;j <= n;j++) sum[j] = (sum[j - 1] + f[j]) % mod;
		res += f[n];
		res %= mod;
	}
	cout << ans << " " << res << endl;
}
```




---

## 作者：I_will_AKIOI (赞：1)

看到题解区很多的 dp 转移过程的代码都比较繁琐，我自己写了下发现不用这么麻烦，并且 $\LaTeX$ 都很老旧，因此给大家献上一篇题解。

首先不需要求方案数，这道题就是一个二分答案，因此先用二分求出答案再考虑，设这个答案为 $r$。

对于求方案数，有一个显然 dp 思路，设 $f_{i,j}$ 表示点到了第 $i$ 根木棍切了 $j$ 次的方案数，转移也很简单，尝试枚举 $k<i$（不能取等号是因为不能分割自己），然后就把 $[k,i]$ 这部分的木棍视为一段，如果这一段的长度 $\le x$，就说明合法，可以转移，求区间长度可以先预处理出前缀和 $b$。转移方程就是 $f_{i,j}=\displaystyle\sum_{k=0,b_i-b_k\le r}^{i-1}f_{k,j-1}$，时间复杂度为 $O(n^2m)$，根据题意，答案为 $\displaystyle\sum_{i=1}^m f_{n,i}$ 核心代码如下，

```cpp
for(int i=1;i<=n;i++) f[i][0]=(b[i]<=r);
for(int j=1;j<=m;j++)
{
  for(int i=2;i<=n;i++)  for(int k=0;k<i;k++) if(b[i]-b[k]<=r) f[i][j]=(f[i][j]+f[k][j-1])%mod;
  ans=(ans+f[n][j])%mod;
}
```

接着考虑优化。发现满足 $b_i-b_k\le r$ 的 $k$ 一定是一段区间，因此可以用双指针预处理出 $pre_i$，表示满足 $b_i-b_k\le r$ 的 $k$ 的最小值，然后用前缀和优化 dp，用 $sum_i$ 存 $\displaystyle\sum_{i=1}^m f_{i,j}$（$j$ 已经在最外层枚举出来了），转移时就可以直接用 $sum_{i-1}-sum_{pre_i-1}$ 来代替 $f_{i,j}$，时间复杂度为 $O(nm)$。但是空间开不下，所以需要滚动数组优化。

```cpp
#include<bits/stdc++.h>
#define mod 10007
#define N 50005
using namespace std;
int n,m,maxx,ans,a[N],f[N],b[N],pre[N],sum[N];
bool check(int x)
{
  int len=a[1],cnt=0;
  for(int i=2;i<=n;i++)
  {
    if(len+a[i]>x) len=a[i],cnt++;
    else len+=a[i];
  }
  return cnt<=m;
}
int main()
{
  ios::sync_with_stdio(0);
  cin>>n>>m;
  for(int i=1;i<=n;i++) cin>>a[i],maxx=max(maxx,a[i]),b[i]=b[i-1]+a[i];
  int l=maxx,r=1e9,mid,j=0;
  while(l<r)//二分答案，r表示结果
  {
    mid=l+r>>1;
    if(check(mid)) r=mid;
    else l=mid+1;
  }
  for(int i=1;i<=n;i++) sum[i]=sum[i-1]+(b[i]<=r);
  for(int i=1;i<=n;i++) while(j<n&&b[j+1]-b[i]<=r) pre[++j]=i;//预处理pre[i]
  for(int j=1;j<=m;j++)
  {
    for(int i=2;i<=n;i++) f[i]=sum[i-1]-sum[pre[i]-1];//状态转移
    ans=(ans+f[n])%mod;
    for(int i=1;i<=n;i++) sum[i]=(sum[i-1]+f[i])%mod;//更新新的sum数组
  }
  cout<<r<<" "<<(ans+mod)%mod;
  return 0;
}
```

---

## 作者：ny_jerry2 (赞：1)

本题有两个问题，我们可以一个一个来。

第一个问题：显然，通过**总长度最大的一段长度最小**这个字眼，可以非常容易得看出用二分来解决。因此，我们可以二分最大长度，然后用函数判定一下就好了。~~没什么难的~~。

第二个问题：如何求方案？  
这才是本题的难点，我们用 dp 来统计方案。

下面设二分出来的值为 $w$。

设 $f_{i,j}$ 表示将前 $i$ 个木棍分为 $j$ 组。在每组总长度不大于我们二分出来的值的情况下，方案数是多少。

转移：$f_{i,j} = \sum f_{k,j-1}$，其中 $k$ 要满足 $sum_i - sum_k \le w$。

对于这个转移，我们显然可以前缀和优化。

---

## 作者：songzhixin (赞：1)

### 题目大意

将一根木棍分为至多 $m+1$ 段，求总长度最大的最小值及其方案数。

### 解题思路

我们每个小问分别看，对于第一小问，它要求求出最大段的最小值，我们可以直接联想到**二分答案**。我们不需要直接求这个值，而是通过枚举看是否符合要求，最后不断缩小区间得到答案。

至于判断这一个是否符合要求，我们通过贪心可以知道最有情况就是如果在加上下一段就要超过目标了，就在这切一刀，这样可以保证切的刀数最小，最后和 $m$ 比较就可以。

第二小问，我们统计方案数，想到**动态规划**。首先设计状态，我们发现设两维就可以递推，设 $f_{i,j}$ 表示前 $i$ 段木棍，砍 $j$ 刀且符合每一段最大值最小的方案数。

我们可以只要保证这一段的长度小于第一问求出来的值就可以，因此枚举一个 $k$，若 $\sum_{l=k+1}^{i-1}$ 是小于等于我们第一小问求出的值的，$f_{i,j}$ 就可以加上 $f_{k,j-1}$，因为你可以在 $k$ 后面切一刀。

这样子时间复杂度 $O(n^3)$，考虑优化，我们首先发现 $k$ 一定是一个数 $lastt$ 到 $i-1$ 的连续区间，因为我们的和一定是单调递增的。但随着 $i$ 的增大，$lastt$ 一定是不可能变小的，因为你加入了越来越多的数。这样可以从上一个数开始枚举，预处理出来。

但这样子还是会超时，我们是求一段区间和，可以考虑前缀和，用一个 $s$ 数组记录前面一段的前缀和，最后直接用 $sum_{i-1}-sum_{lastt-1}$ 就可以求出，优化为 $O(nm)$。

这样交上去空间会爆，我不太会用直接用以前的，只好退而求其次，用交替滚动，可以把空间优化成 $O(n)$，能够通过此题。

### 正确代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=50005;
const int M=1005;
const int mod=10007;
int a[N];
int sum[N];
int f[N][2];
int n,m;
int s[N][2];
int lastt[N];
bool check(int x) {
	int len=0;
	int cnt=0;
	for(int i=1; i<=n; i++) {
		if(len+a[i]>x) {
			cnt++;
			len=a[i];
			if(cnt>m) {
				return false;
			}
		} else {
			len+=a[i];
		}
	}
	if(cnt>m||len>x) {
		return false;
	}
	return true;
}
int main() {
	scanf("%d%d",&n,&m);
	for(int i=1; i<=n; i++) {
		scanf("%d",&a[i]);
	}
	int l=0,r=1e9;
	while(l<r) {
		int m=(l+r)>>1;
		if(check(m)) {
			r=m;
		} else {
			l=m+1;
		}
	}
	printf("%d ",l);
	bool flag=false;
	for(int i=1; i<=n; i++) {
		sum[i]=sum[i-1]+a[i];
		if(sum[i]<=l) {
			f[i][0]=1;
		}
		s[i][0]=s[i-1][0]+f[i][0];
		f[i][0]%=mod;
		s[i][0]%=mod;
	}
	int ans=f[n][0];
	int cnt=1;
	for(int i=1; i<=n; i++) {
		while(cnt<n) {
			if(sum[i]-sum[cnt]>l) {
				cnt++;
			} else {
				lastt[i]=cnt;
				break;
			}
		}
	}
	for(int j=1; j<=m; j++) {
		for(int i=1; i<=n; i++) {
			f[i][j&1]=(s[i-1][(j+1)&1]-s[lastt[i]-1][(j+1)&1]+mod);
			f[i][j&1]%=mod;
			f[i][j&1]+=mod;
			f[i][j&1]%=mod;
			s[i][j&1]=s[i-1][j&1]+f[i][j&1];
			s[i][j&1]%=mod;
		}
		ans+=f[n][j&1];
		ans%=mod;
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：lytqwq (赞：1)

代码一个地方时间复杂度错了，现在改了。



------------


求最小的最大长度 $M$，我们可以二分答案一个$log$ 做。

现在问题是求方案数，$n\le50000,m\le 1000$。

我们设 $f_{i,j}$ 表示前 $i$ 根木棍，分成 $j$ 段的方案数，125.00MB我们开不下int，但是结果 $mod 10007$，我们可以勉强开下short。

有：

$$
f_{i,j}=\sum_{k<i,\sum_{v=k+1}^{i}L_v\le M}^{} f_{k,j-1} 
$$

直接做 $O(nm^2)$ ~~可能会有分吧（~~ 。



------------


第二个限制和 $j$ 无关，记录一下最多到哪就完了 ， 那样的话我们可以搞一个前缀和 ：

$$
g_{i,j}=\sum_{k=0}^{i} f_{k,j-1}
$$

这样的话，$f_{i,j}$ 每次转移就是 $O(1)$ 的了 。

但是我们发现两个数组开不下short了，但是每次的转移都是从 $j-1$ 转移来的，我们滚动数组就完了，总复杂度 $O(nm+nlogS)$，其中 $S$表示所有木棍的总长度。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=50010,mod=10007;
int n,m,L[N],S[N],f[N],g[N],now[N];
int beff[N],befg[N];
bool check(int x){
	int res=0,used=1;
	for(int i=1;i<=n;i++){
		if(L[i]>x)return 0;
		if(res+L[i]>x){
			used++;
			res=L[i];
		}
		else{
			res+=L[i];
		}
	}
	return used<=m+1;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)scanf("%d",&L[i]),S[i]=S[i-1]+L[i];
	int l=1,r=S[n],mid;
	while(l<r){
		mid=(l+r)>>1;
		if(check(mid))r=mid;
		else l=mid+1;
	}
	int k=0;
	for(int i=1;i<=n;i++){
		while(S[i]-S[k]>l&&k<=i)k++;
		now[i]=k;
	}
	beff[0]=1;
	int ans=0;
	for(int i=0;i<=n;i++)befg[i]=1;
	for(int j=1;j<=m+1;j++){
		for(int i=0;i<=n;i++){
			f[i]=befg[i-1]-(now[i]==0?0:befg[now[i]-1]);
			g[i]=g[i-1]+f[i];
			g[i]%=mod;
			f[i]%=mod;
		}
		for(int i=0;i<=n;i++){
			beff[i]=f[i];
			befg[i]=g[i];
			f[i]=g[i]=0;
		}
		ans+=beff[n];
	}
	printf("%d %d\n",l,(ans%mod+mod)%mod);
}
```







---

## 作者：suxxsfe (赞：1)

[来我的博客查看](https://www.cnblogs.com/suxxsfe/p/13068939.html)  

[https://www.luogu.com.cn/problem/P2511](https://www.luogu.com.cn/problem/P2511)  
[https://darkbzoj.tk/problem/1044](https://darkbzoj.tk/problem/1044)  

dp+前缀和优化  
人傻常数大，最后一个点跑了0.8秒/jk  

第一问，直接二分，然后贪心来判断是否可行就好，记求出的答案（最大长度最小值）为 $len$  
~~我一菜鸡在这一问就调了好长时间~~  

预处理出一个 $p_i$，表示的是，能与 $i$ 构成一个区间的最左端的一个点是什么  
比如 $p_i=j$，也就是 $[j,i]$ 区间是符合要求的。$[j-1,i]$ 就不是了，也就是它比 $len$ 大  
这个也可以简单的用二分求出  

然后开始dp，设 $f_{i,j}$ 为前 $i$ 个木棍，**恰好**分成 $j$ **段**（不是切 $j$ 刀），有多少方案  
至于为什么是恰好[这位大佬讲的](https://www.luogu.com.cn/blog/105254/solution-p2511)挺详细了  
那么，$f_{i,j}$ 由 $f_{k,j-1}$ 推出，也就是考虑给已经分成 $j-1$ 段的每个情况，再加上一些木棍，更具体就是：  

$$f_{i,j}=\sum_{k=p_i-1}^{i-1} f_{k,j-1}$$  

也就是从 $p_i-1$ 开始，可以为之前的状态加上 $[p_i,i]$ 的木棍，来推出当前状态，直到枚举上限，就是加区间 $[i,i]$ 的木棍  
发现这样转移是 $n^3$ 的，但是由于是区间求和的方式来转移，所以用一下前缀和优化  
维护一个 $sum$  
每次把 $f_{i-1,j-1}$ 加入 $sum$ 中，然后从 $sum$ 中把所有 $f_{x,j-1},x<p_i-1$ 减去  
所以当前的 $f_{i,j}$ 就等于 $sum$ 了，复杂度 $n^2$  
前缀和优化写的不熟，处理起边界来真的烦  

然后数组要用滚动数组，答案是 $\sum_{i=1}^{len} f_{n,i}$  

```cpp  
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<cmath>
#include<map>
#include<iomanip>
#include<cstring>
#define reg register
#define EN std::puts("")
#define LL long long
inline int read(){
	register int x=0;register int y=1;
	register char c=std::getchar();
	while(c<'0'||c>'9'){if(c=='-') y=0;c=std::getchar();}
	while(c>='0'&&c<='9'){x=x*10+(c^48);c=std::getchar();}
	return y?x:-x;
}
#define mod 10007
int a[50005];
int n,m,len;
int f[50005][2];//f[i][j] 前 i 个，分成 j 段，并符合最大长度的限制，的方案数 
int sum[50005],p[50005];
inline int check(int max){
	for(reg int i=1;i<=n;i++)if(a[i]>max) return 0;
	for(reg int num=0,now,i=1;i<=n;){
		now=0;
		while(now<=max&&i<=n) now+=a[i],i++;
		if(now>max) i--;
		if(++num>m) return 0;
	}
	return 1;
}
inline int get(){
	reg int l=1,r=sum[n],mid,ret;
	while(l<=r){
		mid=(l+r)>>1;
		if(check(mid)) r=mid-1,ret=mid;
		else l=mid+1;
	}
	return ret;
}
inline int pre(int x){
	reg int l=1,r=x,ret,mid;
	while(l<=r){
		mid=(l+r)>>1;
		if(sum[x]-sum[mid-1]<=len) ret=mid,r=mid-1;
		else l=mid+1;
	}
	return ret;
}
inline int dp(){
	for(reg int i=1;i<=n;i++) p[i]=pre(i);
	for(reg int i=1;i<=n;i++)if(sum[i]<=len) f[i][1]=1;
	int ans=f[n][1];
	for(reg int tail,sum,j=2;j<=m;j++){
		tail=p[2]-1;sum=f[p[2]-1][(j-1)&1];
		for(reg int i=2;i<=n;i++){
			sum=(sum+f[i-1][(j-1)&1])%mod;
			while(tail<p[i]-1) sum=(sum-f[tail++][(j-1)&1]+mod)%mod;
			f[i][j&1]=sum;
		}
		ans=(ans+f[n][j&1])%mod;
	}
	return ans;
}
int main(){
	n=read();m=read()+1;
	for(reg int i=1;i<=n;i++) a[i]=read(),sum[i]=sum[i-1]+a[i];
	len=get();
	std::printf("%d ",len);
	std::printf("%d",dp());
	return 0;
}
```

---

## 作者：Piwry (赞：1)

话说有一个 dp 很重要的（定义）细节都没人讲到...坑的我调了半天（

问题就出在 dp 式的定义中：其它题解应该是默认 $f[i][j]$ 代表取到第 $j$ 个，**严格**分 $i$ 块的方案数，并对每种块数的 $f[n]$ 求和统计答案。但我一开始思路~~比较清奇~~有点不一样：设 $f[i][j]$ 代表取到第 $j$ 个，**最多**分 $i$ 块的方案数，最后直接输出 $f[m+1][n]$ 就行了。

具体的来说，程序是（已按其他题解的方式优化，命名方式都差不多可以理解下...）：

```cpp
/*K[j] 表示最小的 k 满足 sum[j]-sum[k] < limit*/
for(int i =2; i <= m+1; ++i){
	for(int j =1; j <= n; ++j){
		/*k+1 到 j 都可以取并做一块，所以有可能用到 dp[i-1][k] 的情况，对应前缀和要再 -1*/
		if(K[j]-1 > 0) dp[j] =(sdp[j]/*注意这里不是 j-1*/-sdp[K[j]-1 /*<-*/]+M)%M;
		else dp[j] =sdp[j];
	}
	for(int j =1; j <= n; ++j) sdp[j] =(sdp[j-1]+dp[j]+M)%M;/*求 dp 前缀和*/
}
printf("%d", dp[n]);
```


虽然表面上看 dp 转移式可能看不太出来 ~~（或者我的 "表面" 想得太少了（~~ ：$f[i][j]$ 是最多分 $i$ 块，所以当然可以不分并继承 $f[i-1][j]$。

于是答案就**多**了~~亿点点~~。

**呐这究竟错在哪里呢？**

实际上，这种 dp 方式会将**实质相同**的不划分方案重复计数：例如 $f[i][j]$ 继承 $f[i-1][j]$ 的方案，就相当于在所有原方案上**再分一块 $(j, j+1)$** 的空集。因这些空集的位置不同，这种 dp 方式也会将这些**仅仅是空集（可能多个）位置不同的方案算作不同的方案计数**。（有点绕，可以多读几次理解下）

---

（样例数据：）

```
3 2                           
1 
1
10
```

具体地来讲，取样例数据（可见上）,当循环完 $i=2$ 时，$f[2][.]$ 的数组内容是 $0, 1, 2, 1$（下标从 $0$ 开始），这时还没问题。

而当计算 $i=3$ 时，对于 $f[3][3]$，按上面的 dp 转移式,它应该为 $f[2][2]+f[2][3]$。

此时 $f[2][2]$ 的方案为 $\{(1)(1), (1,1)()\}$；

而 $f[2][3]$ 的方案为 $\{(1,1)(10)\}$；

至于 $f[3][3]$ 的方案就是 $\{(1)(1)(10), (1,1)()(10), (1,1)(10)()\}$。

可以发现因为计算了有不同的空集位置的方案，导致答案增多了。

---

另外可能有人想到，如果是严格分为 $i$ 块的话，为什么（我下面的以及其他题解的）程序没有特判 $i > j$ 时的贡献？

对于一个不合法的 $f[i][j]$ 满足 $i > j$，设它能取到的贡献 $f[i-1][j']$，一定有 $j'<j$，也就是说有 $j'<i-1$。由此我们可以知道，**不合法的方案一定是由不合法的方案转移而来的，其贡献全由不合法的方案组成**。

而对于一个合法的方案 $f[i][j]$ 满足 $i \leqslant j$，设它能取到的贡献 $f[i-1][j']$，是有可能有 $i-1>j'$ 的。也就是说，**合法的方案有可能由不合法的方案转移而来，其贡献可能含有不合法的方案**。

因此我们只需关心**最初的不合法方案**，也就是 $f[1][0]$。它的缺省值应该是 $0$，于是我们就可以保证不合法的方案不会产生贡献。（可以去调试一下验证看看）

~~（这件事告诉我们将 dp 数组缺省设为 $0$ 可以省多少事...（bushi~~

~~（上面那句话有点结果主义...（~~

## CODE

```cpp
#include <cstdio>
#include <iostream>
using std::min;

const int MAXN =5e4+50, M =10007;

int n, m;
int dp[MAXN], sdp[MAXN], sum[MAXN], K[MAXN];

inline int read(){
	int x =0; bool f =0; char c =getchar();
	while(c < '0' || c > '9') (c == '-') ? f =1, c =getchar() : c =getchar();
	while(c >= '0' && c <= '9') x = (x<<3) + (x<<1) + (48^c), c =getchar();
	return (f) ? -x : x;
}

inline bool calc(int limit){
	int cnt =0, Sum =0;
	for(int i =1; i <= n; ++i){
		if(Sum+sum[i]-sum[i-1] > limit) Sum =0, ++cnt;
		if(cnt > m) return 0;
		Sum +=sum[i]-sum[i-1];
	}
	if(Sum > limit) return 0;/*考虑单个元素大于 limit*/
	else return 1;
}

int main(){
	n =read(), m =read();
	for(int i =1; i <= n; ++i) sum[i] =read(), sum[i] +=sum[i-1];
	int l =0, r =sum[n], limit =0x7fffffff;
	while(l <= r){
		int mid =(l+r)>>1;
		if(calc(mid)) limit =min(limit, mid), r =mid-1;
		else l =mid+1;
	}
	for(int j =1, k =0; j <= n; ++j){
		while(sum[j]-sum[k] > limit) ++k;/*k+1 至 j 的元素可以取并作为一块*/
		K[j] =k;
	}
	for(int j =1; j <= n; ++j) sdp[j] =(sum[j] <= limit)+sdp[j-1];
	int ans =(sdp[n]-sdp[n-1])%M;
	for(int i =2; i <= m+1; ++i){
		for(int j =1; j <= n; ++j){/*k+1 至 j 的元素，所以 f[i-1][k] 的贡献也要算，那么前缀和就要 -1*/
			if(K[j]-1 > 0) dp[j] =(sdp[j-1]-sdp[K[j]-1 /*<-*/]+M)%M;
			else dp[j] =sdp[j-1];
		}
		for(int j =1; j <= n; ++j) sdp[j] =(sdp[j-1]+dp[j]+M)%M;
		(ans +=dp[n])%=M;
	}
	printf("%d %d", limit, ans);
}
```


---

## 作者：封禁用户 (赞：1)

一道 dp 好题

本题考查前缀和优化 dp

#### 思路

首先呢第一个问题是一道经典二分。

展示部分代码

```
bool check(int x) {
    int cnt = 1, now = 0;
    for (int i = 1; i <= n; ++i) {
        if (a[i] > x) return 0; // 假如单个大于当前二分值肯定不行
        now += a[i];
        if (now > x) { // 如果某一段超过二分值则新开一段
            ++cnt;
            now = a[i];
        } 
    }   
    return (cnt <= m);
}
```
然后二分后呢我们就可以得到题目要求的最大值的最小值。

我们设其为 $ans$

然后就有一个显然的 $O(n^2m)$ dp：

$dp[i][j]$ 表示前 $i$ 个数分成 $j$ 个段

转移：$dp[i][j] = \sum dp[k][j-1]$ 

然后你兴高采烈的打完这份代码后，会发现你爆蛋了（亲身尝试）

原因就是这个算法是 $O(n^2m)$ 的，但是 $n \leq 50000$ 

可以想到 $\sum dp[k][j-1]$ 应该是可以用前缀和优化的，但是要满足 $sum[i]-sum[k]\leq ans$

然后这个题看到 $1 \leq l_i \leq 1000$，显然满足单调性，可以想到通过预处理直接得到枚举范围。这个是可以通过二分或者双指针发求出来的。双指针复杂度 $O(n)$ 二分复杂度 $ O(n\log n)$

而且我认为双指针好写所以我写了双指针：

```

for (int i = 1; i <= n; ++i) {
   while (s[i] - s[L] > ans) ++L;
   pre[i] = L;
}
```

然后得到 $pre$ 数组后呢就可以快乐的前缀和优化了。

但是呢有可能会爆空间，所以就只用 dp 保存上一个需要的，然后做前缀和优化。

### 代码

```
#include <bits/stdc++.h>
using namespace std;
#define int long long 
const int N = 50005;
const int mod = 10007;
int n, m, a[N], dp[N], s[N], pre[N], sum[N];
bool check(int x) {
    int cnt = 1, now = 0;
    for (int i = 1; i <= n; ++i) {
        if (a[i] > x) return 0;
        now += a[i];
        if (now > x) {
            ++cnt;
            now = a[i];
        } 
    }   
    return (cnt <= m);
}
signed main() {
    scanf("%lld%lld", &n, &m);
    ++m;
    for (int i = 1; i <= n; ++i) scanf("%lld", &a[i]), s[i] = s[i - 1] + a[i];
    int l = 0, r = 5e9, ans;
    while (l <= r) {
        int mid = (l + r) >> 1;
        if (check(mid)) r = mid - 1, ans = mid;
        else l = mid + 1;
    }
    int L = 0;
    for (int i = 1; i <= n; ++i) {
    	while (s[i] - s[L] > ans) ++L;
    	pre[i] = L;
	}
	for (int i = 0; i <= n; ++i) sum[i] = 1; 
	int tot = 0;
    for (int i = 1; i <= m; ++i) {
        for (int j = 1; j <= n; ++j) dp[j] = ((sum[j - 1] - sum[pre[j] - 1]) % mod + mod) % mod;
		if (i == 1) sum[0] = 0;
        for (int j = 1; j <= n; ++j) sum[j] = (sum[j - 1] + dp[j]) % mod;
        tot = (tot + dp[n]) % mod;
    }
    printf("%lld %lld", ans, tot);
    return 0;
}
```

### 谢谢您的观看！！！

---

## 作者：Huah (赞：1)

对于第一问二分答案ans，对于第二问动态规划，dp[j][i]表示到第i个位置有j段符合条件的子序列。那么转移方程：如果sum[i]-sum[k]<=ans,那么dp[j-1][k]就可以转移到dp[j][i]（相当于在k位置后面接了一个和为sum[i]-sum[k]的子段）。那么可以发现可以转移到j的dp数组是一个前缀。即可以使用前缀和优化。

那么我们可以二分搜索这个k位置，sum[i]-sum[k]<=ans-->sum[k]>=sum[i]-ans

(sum表示前缀和)那么位置k=lower_bound(sum,sum+1+n)-sum

为什么不是lower_bound(sum+1,sum+1+n)？因为我们搜的是前缀和，So所以有sum[i]-sum[0]<=ans的情况，所以sum[0]也要包括进来。(wo就是因为这里疯狂wa)

如果在把dp[j][i]做成前缀和的话，那么转移方程就变成了

	dp[j][i]=dp[j-1][i-1]-dp[j-1][k-1]+dp[j][i-1]
    
那么就做完了。。。Q:等等，你这MLE了呀

A:模数这么小，我们用short类型就好了，用short的范围是(-32768~32767)，对于这个模数够用了。占的内存是int的一半，并且运算花的时间也更快。int是32位，那么它做一次加法运算次数是32，short是16位，做一次加法运算次数是16，int做一次乘法运算次数是32\*32，short是16\*16,这个题没用到乘法，但是速度也是比int快很多了，尤其是常数比较大的时候
```
#include<bits/stdc++.h>
using namespace std;
const int N=50005,mod=10007;
int n,m,a[N];
int sum[N],pre[N];
short dp[1005][N];
bool judge(int mid)
{
    int ans=0,now=0;
    for(int i=1;i<=n;i++)
    {
        if(a[i]>mid) return false;
        if(now+a[i]<=mid) now+=a[i];
        else now=a[i],ans++;
    }
    return ans<=m;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]),sum[i]=sum[i-1]+a[i];
    int l=1,r=1000000,ans;
    while(l<=r)
    {
        int mid=l+r>>1;
        if(judge(mid)) ans=mid,r=mid-1;
        else l=mid+1;
    }
    for(int i=1,now=0;i<=n;i++)
    {
        while(sum[i]-sum[now]>ans) now++;
        pre[i]=now-1;
        //pre[i]=lower_bound(sum,sum+1+n,sum[i]-ans)-sum-1;
    }
    short res=0;
    for(int i=0;i<=n;i++)
        dp[0][i]=1;
    for(int j=1;j<=m+1;j++)
    {
        for(int i=1;i<=n;i++)
        {
            if(i<j)
                dp[j][i]=dp[j][i-1];
            else if(pre[i]>=0) dp[j][i]=(dp[j-1][i-1]-dp[j-1][pre[i]]+dp[j][i-1])%mod;
            else dp[j][i]=(dp[j-1][i-1]+dp[j][i-1])%mod;
        }
        res=(res+dp[j][n]-dp[j][n-1])%mod;
    }
    printf("%d %d\n",ans,(res+mod)%mod);
}

```


---

## 作者：forever516 (赞：0)

## 题意
有
$n$
根木棍, 第
$i$
根木棍的长度为
$L_i$,$n$
根木棍依次连结了一起, 总共有
$n-1$
个连接处. 现在允许你最多砍断
$m$
个连接处, 砍完后
$n$
根木棍被分成了很多段,要求满足总长度最大的一段长度最小, 并且输出有多少种砍的方法使得总长度最大的一段长度最小. 并将结果模
$10007$。
## 解法
第一问，可以用二分答案求出最优值

第二问用动规，预处理木棍长的前缀和
$sum_i$。

再用双指针扫一遍，求出对于所有的满足
$sum_i-sum_{k-1}\le res$
的最小值存进数组中。

然后设
$f_{i,j}$
为前第
$i$
个木棍，分成
$j$
块的方案数,最后答案为
$f_{n,j}$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 5e4 + 5, K = 1e4 + 7;
int n, m, a[N], sm[N], f[2][N], nxt[N],i, j, res, ans;
bool check(int mid) {
    int i, sum = 0, tot = 1;
    for (i = 1; i <= n; i++)
        if (sum + a[i] <= mid) sum += a[i];
        else {
            if (a[i] <= mid) sum = a[i], tot++;
            else return 0;
            if (tot > m) return 0;
        }
    return tot <= m;
}
int solve() {
    int l = 1, r = 5e7, mid;
    while (l <= r) {
        mid = l + r >> 1;
        if (check(mid)) r = mid - 1;
        else l = mid + 1;
    }
    return l;
}
int main() {
	cin>>n>>m;
	m+=1;
    for (i = 1; i <= n; i++){
    	cin>>a[i];
		sm[i] = sm[i - 1] + a[i];
	} 
    printf("%d ", res = solve());
    for (i = 1, j = 1; i <= n; i++) {
        while (j < i && sm[i] - sm[j - 1] > res){
			j++;
		}
        nxt[i] = j;
    }
    for (i = 1; i <= n; i++)
		f[1][i] = f[1][i - 1] + (sm[i] <= res);
    ans = sm[n] <= res;
    for (j = 2; j <= m; j++) {
        int op = j & 1; f[op][j - 1] = 0;
        for (i = j; i <= n; i++) {
            f[op][i] = (f[op ^ 1][i - 1] - (nxt[i] == 1 ? 0 :
            f[op ^ 1][nxt[i] - 2]) + K) % K;
            if (i == n) (ans += f[op][n]) %= K;
            (f[op][i] += f[op][i - 1]) %= K;
        }
    }
    cout << ans << "\n";
    return 0;
}
```

---

## 作者：chenruikai (赞：0)

## 题意
有 $n$ 个数，**最多**分成 $m$ 组，问：
1. 总长度最大的一段最小是多少？答案**不用模**。
2. 在上面的基础上，有多少种分法？**答案需要模**。

上述内容中加粗的特别特别的需要注意~~但出题官题目叙述的有点模糊~~。

## 题解
这道题第一小问一眼二分，$check()$ 用贪心写 $O(n)$ 就搞定了，没得多讲。

### 第二小问
设 $f(a , b)$ 为在 $[0,a]$ 内**切** $b$ 下所得的方法数，则易得
$$
\begin{aligned}
f(a,b)=\sum_{c = b}^{a\text{ and }len[c,a]\le lim} f(c-1,b-1)
\end{aligned}
$$
上述公式其实就是枚举最近的一个区域的左下标。

#### 优化1
很明显，由于 $f(a,b)$ 只与 $f(x,b-1)$ 有关，故可以滚掉第二维。

#### 优化2
上优化过后，复杂度整整有 $O(n^3)$，如果这样提交上去，那就恭喜你荣获 $0pts$ 的优秀成绩。

细看代码~~没写的先写了~~我们可以发现，计算某个值时，假设 $f(x)$ 扫描了区间 $[a,x]$，计算 $f(x-1)$ 时扫描了区间 $[b,x-1]$，我们可以发现，两区间有重叠部分，重叠部分大可不必扫描两次，通过该原理，可以成功降维时间复杂度。

代码来咯。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int cmod = 10007;
int cut_lim = 0;
int num_num = 0;
int num[50000];
int num_sum[50000];
int mem[50000];
int len_lim;
bool check(int lim)
{
    int len = num[0] , times = 0;
    for(int i = 1;i < num_num;i++)
    {
        if(len + num[i] > lim)
        {
            len = num[i];
            times++;
            if(times > cut_lim)return false;
        }
        else
        {
            len += num[i];
        }
    }
    return true;
}
int compute_len()
{
    int l = 0 , r = 0 , mid;
    for(int i = 0;i < num_num;i++)
        r += num[i];
    for(int i = 0;i < num_num;i++)
        l = max(l , num[i]);
    while(l < r)
    {
        mid = (l + r) >> 1;
        if(check(mid) == true)r = mid;
        else l = mid + 1;
    }
    return l;
}
#define compute_sum(a , b) ((a) == 0 ? num_sum[(b)] : num_sum[(b)] - num_sum[(a) - 1])
int compute_times()
{
    for(int i = 0;i < num_num;i++)
        if(compute_sum(0 , i) <= len_lim)
            mem[i] = 1;
        else break;
    int ans = mem[num_num - 1];
    for(int use_times = 1;use_times <= cut_lim;use_times++)
    {
        int before_index = num_num - 1;
        mem[num_num - 1] = 0;
        for(int l_index = num_num - 1;l_index >= use_times && compute_sum(l_index , num_num - 1) <= len_lim;
            l_index--)
        {
            mem[num_num - 1] += mem[l_index - 1];
            mem[num_num - 1] %= cmod;
            before_index = l_index - 1;
        }
        for(int index = num_num - 2;index >= use_times;index--)
        {
            if(before_index < index)
            {
                mem[index] = mem[index + 1] - mem[index];
                mem[index] %= cmod;
            }
            else mem[index] = 0;
            before_index = min(before_index , index);
            for(int l_index = before_index;l_index >= use_times && compute_sum(l_index , index) <= len_lim;
                l_index--)
            {
                mem[index] += mem[l_index - 1];
                mem[index] %= cmod;
                before_index = l_index - 1;
            }
        }
        ans += mem[num_num - 1];
        ans %= cmod;
    }
    return ans;
}
int main()
{
    cin >> num_num >> cut_lim;
    for(int i = 0;i < num_num;i++)
        cin >> num[i];
    len_lim = compute_len();
    printf("%d " , len_lim);
    num_sum[0] = num[0];
    for(int i = 1;i < num_num;i++)
        num_sum[i] = num_sum[i - 1] + num[i];
    cout << compute_times() << endl;
    return 0;
}
```
本题结束。

玥玥月月如今朝。

---


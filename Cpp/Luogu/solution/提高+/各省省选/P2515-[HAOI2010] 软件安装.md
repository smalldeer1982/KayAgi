# [HAOI2010] 软件安装

## 题目描述

现在我们的手头有 $N$ 个软件，对于一个软件 $i$，它要占用 $W_i$ 的磁盘空间，它的价值为 $V_i$。我们希望从中选择一些软件安装到一台磁盘容量为 $M$ 计算机上，使得这些软件的价值尽可能大（即 $V_i$ 的和最大）。

但是现在有个问题：软件之间存在依赖关系，即软件 $i$ 只有在安装了软件 $j$（包括软件 $j$ 的直接或间接依赖）的情况下才能正确工作（软件 $i$ 依赖软件 $j$)。幸运的是，一个软件最多依赖另外一个软件。如果一个软件不能正常工作，那么它能够发挥的作用为 $0$。


我们现在知道了软件之间的依赖关系：软件 $i$ 依赖软件 $D_i$。现在请你设计出一种方案，安装价值尽量大的软件。一个软件只能被安装一次，如果一个软件没有依赖则 $D_i=0$，这时只要这个软件安装了，它就能正常工作。

## 样例 #1

### 输入

```
3 10
5 5 6
2 3 4
0 1 1```

### 输出

```
5```

# 题解

## 作者：lcjqwq (赞：48)

### Description

现在我们的手头有$N$个软件，对于一个软件$i$，它要占用$W_i$的磁盘空间，它的价值为$V_i$。我们希望从中选择一些软件安装到一台磁盘容量为$M$计算机上，使得这些软件的价值尽可能大（即$V_i$的和最大）。

但是现在有个问题：软件之间存在依赖关系，即软件$i$只有在安装了软件$j$（包括软件j的直接或间接依赖）的情况下才能正确工作（软件$i$依赖软件$j$)。幸运的是，一个软件最多依赖另外一个软件。如果一个软件不能正常工作，那么它能够发挥的作用为$0$。

我们现在知道了软件之间的依赖关系：软件$i$依赖软件$D_i$。现在请你设计出一种方案，安装价值尽量大的软件。一个软件只能被安装一次，如果一个软件没有依赖则$D_i=0$，这时只要这个软件安装了，它就能正常工作。

### Solution

明显是树形dp。设$dp[i][j]$为以$i$号点为根的子树中用不超过$j$的空间的最大价值。

但是这道题所给出的条件不能直接构成一棵树，比如$d[1]=2,d[2]=3,d[3]=1$这时$1,2,3$便形成一个独立的联通块并且构成环。又由于这个环也很特殊：要么都选，要么都不选，所以可以用tarjan将环缩点。新点的$w=\sum\limits_{e \in \text{该环}}w[e]$，$v=\sum\limits_{e \in \text{该环}}v[e]$。

缩点后将原来的联通块之间的边连好后再从$0$向每一个加完边后入度为$0$的点连一条边，此时就将原图转换为一颗以$0$为根的树，然后就可以愉快的树形dp辣。

举个栗子：

如果最开始图是这样的

![](http://mpic2.lzhaofu.cn/u/14/2018/07/26/e5ec8545.png)

然后缩点，将$1,2,3$缩为$14$，$10,11,12,13$缩为$15$，然后让$0$向几个联通块连边：

![](http://mpic2.lzhaofu.cn/u/14/2018/07/26/f1b84548.png)

这时原图被转换成对答案等价的一棵树，然后$dfs$用上述方程进行简单的树上背包就解决了。

### code 

```cpp
#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <algorithm>

using namespace std;
const int MAXN = 505;
int n, m, cnt, w[MAXN], a[MAXN], d[MAXN]; 
int dfn[MAXN], low[MAXN], bel[MAXN], tot, scc, ins[MAXN], sta[MAXN], top; 
int W[MAXN], V[MAXN], indeg[MAXN], dp[MAXN][MAXN];
struct edge {
    int v;
    edge *next;
}pool[MAXN * 2], *head[MAXN];
inline void addedge(int u, int v) {
    edge *p = &pool[++cnt];
    p->v = v, p->next = head[u], head[u] = p; 
}
void tarjan(int u) {
    dfn[u] = low[u] = ++tot; sta[++top] = u; ins[u] = 1;
    for(edge *p = head[u]; p; p = p->next) {
        int v = p->v;
        if(!dfn[v]) {
            tarjan(v); 
            low[u] = min(low[u], low[v]);
        } else if(ins[v]) 
            low[u] = min(low[u], dfn[v]);
    }
    if(dfn[u] == low[u]) {
        ++scc;
        while(sta[top + 1] != u) {
            bel[sta[top]] = scc;
            W[scc] += w[sta[top]]; 
            V[scc] += a[sta[top]];
            ins[sta[top--]] = 0;
        }
    }
}
void solve(int u) {
    for(int i = W[u]; i <= m; i++)
        dp[u][i] = V[u];
    for(edge *p = head[u]; p; p = p->next) {
        int v = p->v;
        solve(v); int k = m - W[u];
        for(int i = k; i >= 0; i--) 
            for(int j = 0; j <= i; j++)
                dp[u][i + W[u]] = 
                max(dp[u][i + W[u]], 
                dp[v][j] + dp[u][i + W[u] - j]);
    }
}
int main()
{
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; i++) scanf("%d", &w[i]);
    for(int i = 1; i <= n; i++) scanf("%d", &a[i]);
    for(int i = 1; i <= n; i++) {
    	scanf("%d", &d[i]); if(d[i]) addedge(d[i], i);
    }
    for(int i = 1; i <= n; i++)    
        if(!dfn[i]) tarjan(i);
    for(int i = 0; i <= n; i++) head[i] = NULL; cnt = 0;
    for(int i = 1; i <= n; i++)
    	if(bel[d[i]] != bel[i]) {
    		addedge(bel[d[i]], bel[i]);
    		indeg[bel[i]]++;
        }
    for(int i = 1; i <= scc; i++) 
        if(!indeg[i]) addedge(0, i);
    solve(0);
    printf("%d\n", dp[0][m]);
 	return 0;
}

```


---

## 作者：day_dream (赞：40)

来一篇O(nm)的题解。

其实前面没有什么区别，我们先按照依赖关系连边，然后把相互依赖的一些软件缩点。

缩完点后，再建一遍图，注意第二次建图要用缩完点后的编号，第二次建出来的图肯定是棵树，那么我们就可以先跑一遍dfs，处理出每个节点的dfs序，在dfs序上DP。

i表示dfs序，dfn表示dfs序为i的节点，sum[i]表示i节点的占用空间，val[i]表示选i节点的价值

>选当前节点：dp[i+1][j+sum[dfn[i]]=max(dp[i][j]+val[dfn[i]])

>不选当前节点：dp[i+siz[dfn[i]][j]=max(dp[i][j]);

因为我们要保证选这个节点的时候它依赖的节点(包括直接和间接依赖)都选了我们要记录它所有祖先的sum的和。

```cpp
#include<algorithm>
#include<cstdio>
#define mxn 110
using namespace std;
int n,m,K,sl,ans,w[mxn],s[mxn],d[mxn],siz[mxn],pre[mxn],sum[mxn],val[mxn],dp[mxn][510];
int tim,top,id[mxn],stk[mxn],vis[mxn],dfn[mxn],low[mxn];
int t,h[mxn];
struct edge
{
    int fr,to,nxt;
}e[mxn];
inline char gc()
{
    static char buf[1<<16],*S,*T;
    if(S==T){T=(S=buf)+fread(buf,1,1<<16,stdin);if(S==T)return EOF;}
    return *S++;
}
inline int rd()
{
    sl=0;
    char ch=gc();
    while(ch<'0'||'9'<ch) ch=gc();
    while('0'<=ch&&ch<='9') sl=sl*10+ch-'0',ch=gc();
    return sl;
}
inline void add(int u,int v) {e[++t]=(edge){u,v,h[u]};h[u]=t;}
void tarjan(int u)
{
    dfn[u]=low[u]=++tim;
    stk[++top]=u;
    vis[u]=1;
    int v;
    for(int i=h[u];i;i=e[i].nxt)
        if(!dfn[v=e[i].to])
            tarjan(v),low[u]=min(low[u],low[v]);
        else if(vis[v]) low[u]=min(low[u],dfn[v]);
    if(dfn[u]==low[u])
    {
        ++K;
        do
        {
            v=stk[top--];
            sum[K]+=w[v];
            val[K]+=s[v];
            vis[v]=0;
            id[v]=K;
        }while(u!=v);
    }
}
void dfs(int u)
{
    int v;dfn[++tim]=u;siz[u]=1;
    for(int i=h[u];i;i=e[i].nxt)
        pre[v=e[i].to]=pre[u]+sum[u],
        dfs(v),siz[u]+=siz[v];
}
inline void upd(int &x,int y) {if(y>x) x=y;}
int main()
{
    n=rd();m=rd();int x;
    for(int i=1;i<=n;++i) w[i]=rd();
    for(int i=1;i<=n;++i) s[i]=rd();
    for(int i=1;i<=n;++i)
    {
        x=rd();
        if(x) add(x,i);
    }
    for(int i=1;i<=n;++i)
        if(!dfn[i])
            tarjan(i);
    top=t;t=0;fill(h+1,h+K+1,0);
    for(int i=1;i<=top;++i)
        if(id[e[i].fr]!=id[e[i].to])
            d[id[e[i].to]]++,add(id[e[i].fr],id[e[i].to]);
    for(int i=1;i<=K;++i)
        if(!d[i])
            add(0,i);
    tim=0;dfs(0);
    for(int i=1;i<=tim;++i)
    {
        for(int j=pre[dfn[i]];j<=m-sum[dfn[i]];++j)
            upd(dp[i+1][j+sum[dfn[i]]],dp[i][j]+val[dfn[i]]);
        for(int j=pre[dfn[i]];j<=m;++j)
            upd(dp[i+siz[dfn[i]]][j],dp[i][j]);
    }
    printf("%d\n",dp[tim+1][m]);
    return 0;
}
```

---

## 作者：KevinYu (赞：29)

这一题真是无限次苦苦挣扎得出的产物啊。     
我们来一步步地分析题面:     
1.这一道题乍一看像是一个树上背包的问题，我们于是得出程序的主要框架:树形dp。     
我们先建图，用```up[i]```来存储i的先决条件(注意:x,i不要搞反了)。
```cpp
for(int i=1;i<=n;i++)
    {
        int x;
        scanf("%d",&x);
		up[i]=x;
        if(x!=0)addedge(x,i);
    }
```
但是，题目描述中并没有说这个东西一定是一棵树,它有可能是一张带环图，也可能是一个森林。    
例如，考虑这样的一个依赖关系:
```cpp
4 9
3 3 3 1 
2 3 4 6
2 3 1 1
```
我们发现:这个图建完后是一个带环图。1，2，3号节点互为依赖条件。一旦有其中任何一个点没有被选择，整个环里面的所有内容都无法被使用。        
我们重新观察这张图，我们发现1，2，3号节点的共性：我们可以对它整个选择，也可以对它整个不选择，对其中的任何一个真子集都没有意义。    
对于环中点有共性的图，我们考虑用缩点来解决问题(本题中以tarjan算法为例)。   
2.缩点过程(会tarjan的可以跳过):      
tarjan算法基于时间戳与dfs实现，我们将一个点被发现的时间存入dfn数组中，然后将一个点够追溯到的最早的栈中节点的次序计入low数组中。        
我们来过一遍算法流程：
1.初始化:
```cpp
void tarjan(int u)
{
    low[u]=dfn[u]=++now;
    hep[++top]=u;vis[u]=1;
```
我们可以发现，tarjan的初始化中要完成2个工作:     
①.更新时间戳与low数组      
②.将节点压栈并打上标记       
2.tarjan主过程:
```cpp
    for(int i=head[u];i!=-1;i=a[i].next)
    {
		int v=a[i].to;
		if(!dfn[v]){tarjan(v);low[u]=min(low[u],low[v]);}
        	else if(vis[v])low[u]=min(low[u],dfn[v]);
    }
```
我们来慢慢分析它：    
我们首先遍历每一条边，然后对能到达的点进行访问:     
```cpp
    for(int i=head[u];i!=-1;i=a[i].next)
    {
		int v=a[i].to;
```
我们需要分出三种v点：     
1.从没访问过的     
对于这个点，我们将它作为下一个点，递归地进行tarjan过程。    
在tarjan结束后，更新它的low数组。      
你可以把更新的过程理解成从tarjan过程里回传来了它的low值，我们将它的low值与现在这个节点的low值比较，并取较小值。
```cpp
		if(!dfn[v])
		{
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}
```
2.访问过，并在栈里的       
这种节点是可以到达当前节点的，我们发现了这样一个点，就是发现了一个强连通分量，于是我们对当前点的low值进行更新
```cpp
        else if(vis[v])low[u]=min(low[u],dfn[v]);
```
3.访问过，但不在栈里的          
都不能到达你，跟你有什么关系吗，直接忽视掉就行了。      
3.退栈:
```cpp
    if(dfn[u]==low[u])
    {
        ++tot;
        vis[u]=0;
        while(hep[top+1]!=u)
        {
            fa[hep[top]]=tot;
            vis[hep[top--]]=0;
        }
    }
}
```
整个退栈过程就是记录强连通分量的过程，下面我就来详细解释一下。         
退栈的条件是```dfn[u]==low[u]```，代表着我们的遍历过程已经触底，并且回溯回来了。      
在我们当前点上方的都是什么点呢？都是在同一个强连通分量中的点。所以我们将其全部取出，并记录进一个强连通分量中(一般管这个叫“染色”)。       
tarjan缩点过程完整代码:
```cpp
void tarjan(int u)
{
    low[u]=dfn[u]=++now;
    hep[++top]=u;vis[u]=1;
    for(int i=head[u];i!=-1;i=a[i].next)
    {
		int v=a[i].to;
		if(!dfn[v])
		{
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}
        else if(vis[v])low[u]=min(low[u],dfn[v]);
    }
    if(dfn[u]==low[u])
    {
        ++tot;
        vis[u]=0;
        while(hep[top+1]!=u)
        {
            fa[hep[top]]=tot;
            vis[hep[top--]]=0;
        }
    }
}
```
3.重新建图:       
我们通过缩点，将这个图变成一个有向无环图(树或森林)，我们需要重新建一个图(注意起点和终点的顺序):      
```cpp
    for(int i=1;i<=n;i++)
    {
        val[fa[i]]+=v[i];cost[fa[i]]+=w[i];
        if(fa[i]!=fa[up[i]]&&up[i]!=0)
		{
			addag(fa[up[i]],fa[i]);
			usd[fa[i]]++;
		}
    }
```
我们为了将其转换成一棵树，将这个图每一个根节点都连到一个点上:
```cpp
	int s=tot+1;
	for(int i=1;i<=tot;i++)if(!usd[i])addag(s,i);
	cost[s]=0;val[s]=0;
```
4.树形dp:     
我们用dfs来描述dp过程     
规定dfs(u)表示进行到了当前节点，```f[i][j]```代表当前节点是i，还剩j的空间。    
算法流程如下:    
1.初始化
```cpp
    for(int i=cost[u];i<=m;i++)f[u][i]=val[u];
```
我们将每一个大于当前点花费的f数组初始化为u的价值。        
2.遍历每一条边:
```cpp
    for(int i=hag[u];i!=-1;i=dag[i].next)
    {
		int v=dag[i].to;
```
3.根据转移方程完成算法：     
我们取了下一个点，并意识到：我们可以选当前点，也可以不选当前点，若不选当前点，其所有子节点都无法被选择。
依此我们得到状态转移方程：
```cpp
f[u][j+cost[u]]={max(f[u][j+cost[u]],f[u][j+cost[u]-q]+f[v][q]);}
```
就是取子节点中的最优解，并加上当前节点的权值。   
```cpp
        dfs(v);
        for(int j=m-cost[u];j>=0;j--)
        {
            for(int q=0;q<=j;q++)
            {
                f[u][j+cost[u]]=max(f[u][j+cost[u]],f[u][j+cost[u]-q]+f[v][q]);
            }
        }
    }
}
```
dfs过程就此结束。     
完整代码:
```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<cstdlib>
#include<climits>
#include<ctime>
#include<algorithm>
#include<complex>
#include<iostream>
#include<map>
#include<queue>
#include<vector>
#define INF 0x3f3f3f3f
#define ll long long
using namespace std;
struct edge
{
    int to,next;
}a[1010],dag[1010];
int hag[1010];
int head[1010];
int v[1010];
int w[1010];
int cost[1010];
int val[1010];
int f[1010][5050];
int low[1010];
int dfn[1010];
int now(0);
int hep[1010];
int top(0);
int vis[1010];
int fa[1010];
int up[1010];
int usd[1010];
int cnt(0);
int cal(0);
int tot(0);
int n,m;
void addedge(int xi,int yi)
{
    a[cnt].to=yi;
    a[cnt].next=head[xi];
    head[xi]=cnt++;
}
void addag(int xi,int yi)
{
    dag[cal].to=yi;
    dag[cal].next=hag[xi];
    hag[xi]=cal++;
}
void tarjan(int u)
{
    low[u]=dfn[u]=++now;
    hep[++top]=u;vis[u]=1;
    for(int i=head[u];i!=-1;i=a[i].next)
    {
		int v=a[i].to;
		if(!dfn[v])
		{
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}
        else if(vis[v])low[u]=min(low[u],dfn[v]);
    }
    if(dfn[u]==low[u])
    {
        ++tot;
        vis[u]=0;
        while(hep[top+1]!=u)
        {
            fa[hep[top]]=tot;
            vis[hep[top--]]=0;
        }
    }
}
void dfs(int u)
{
    for(int i=cost[u];i<=m;i++)f[u][i]=val[u];
    for(int i=hag[u];i!=-1;i=dag[i].next)
    {
		int v=dag[i].to;
        dfs(v);
        for(int j=m-cost[u];j>=0;j--)
        {
            for(int q=0;q<=j;q++)
            {
                f[u][j+cost[u]]=max(f[u][j+cost[u]],f[u][j+cost[u]-q]+f[v][q]);
            }
        }
    }
}
int main()
{
    memset(head,-1,sizeof(head));
    memset(hag,-1,sizeof(hag));
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)scanf("%d",&w[i]);
    for(int i=1;i<=n;i++)scanf("%d",&v[i]);
    for(int i=1;i<=n;i++)
    {
        int x;
        scanf("%d",&x);
		up[i]=x;
        if(x!=0)addedge(x,i);
    }
    for(int i=1;i<=n;i++)if(!dfn[i])tarjan(i);
    for(int i=1;i<=n;i++)
    {
        val[fa[i]]+=v[i];cost[fa[i]]+=w[i];
        if(fa[i]!=fa[up[i]]&&up[i]!=0)
		{
			addag(fa[up[i]],fa[i]);
			usd[fa[i]]++;
		}
    }
	int s=tot+1;
	for(int i=1;i<=tot;i++)if(!usd[i])addag(s,i);
    cost[s]=0;val[s]=0;
    dfs(s);
    printf("%d",f[s][m+cost[s]]);
    return 0;
}
```



---

## 作者：zfz04 (赞：13)

# [HAOI2010\][软件安装 ](https://www.luogu.com.cn/problem/P2515) 

## O(nm)泛化物品优化写法

[泛化物品优化详细解释请看----国家集训队2009论文集浅谈几类背包题(第十面)](https://wenku.baidu.com/view/8ab3daef5ef7ba0d4a733b25.html#)

代码片段：

```c++
void dfs(int x,int sum)
{
	if(sum<=0) return ;
	for(re int i=0,t;i<_e[x].size();i++)
	{
		t=_e[x][i];
		for(re int j=0;j<=sum-sum_v[t];j++)/为v预留空间
			dp[t][j]=dp[x][j];
		dfs(t,sum-sum_w[t]);//对于v的现有空间
		for(re int j=sum_w[t];j<=sum;j++)
			dp[x][j]=max(dp[x][j],dp[t][j-sum_w[t]]+sum_v[t]);//背包
	}
}
```

发现其实和01背包很像，只是在01背包的基础上限制了条件——捆绑关系；

而我对泛化物品优化的感性理解就是：**"预留空间"**——为在 $u$ 到到根节点的路径上的点预留空间。

这样就可以在对$u$DP的时候保证**他所依赖的物品预先算进去了**；

$dp[u][j]$的意思就是在预留$u$及其到根节点的路径上的点的空间后，还剩下$j$的空间的最大价值;

再结合上面的代码，我相信大家应该都可以理解。

code:

```c++
#include<iostream>
#include<cstdio>
#include<vector>
#define re register
using namespace std;

const int N=101;

int n,m;

vector<int> e[N];
vector<int> _e[N];

int sum_w[N],sum_v[N],du[N];

int w[N],v[N],dp[N][501];

int low[N],dfn[N],tot,tim,s[N],top,c[N];

inline int read()
{
	int res;
	char ch=getchar();
	while(ch<'0'||ch>'9') ch=getchar();
	res=ch-'0';
	ch=getchar();
	while(ch>='0'&&ch<='9') res=(res<<1)+(res<<3)+ch-'0',ch=getchar();
	return res;
}

inline void tarjan(int x)
{
	dfn[x]=low[x]=++tim;
	s[++top]=x;
	for(re int i=0,t;i<e[x].size();i++)
	{
		t=e[x][i];
		if(!dfn[t])
		{
			tarjan(t);
			low[x]=min(low[x],low[t]);
		}
		else if(!c[t]) low[x]=min(low[x],dfn[t]);
	}
	if(dfn[x]==low[x])
	{
		++tot;
		while(s[top+1]!=x)
		{
			c[s[top]]=tot;
			sum_v[tot]+=v[s[top]];
			sum_w[tot]+=w[s[top]];
			top--;
		}
	}
}

inline void dfs(int x,int sum)
{
	if(sum<=0) return ;
	for(re int i=0,t;i<_e[x].size();i++)
	{
		t=_e[x][i];
		for(re int j=0;j<=sum-sum_w[t];j++)
			dp[t][j]=dp[x][j];
		dfs(t,sum-sum_w[t]);
		for(re int j=sum_w[t];j<=sum;j++)
			dp[x][j]=max(dp[x][j],dp[t][j-sum_w[t]]+sum_v[t]);
	}
}

int main()
{
	n=read(),m=read();
	for(re int i=1;i<=n;i++) w[i]=read();
	for(re int i=1;i<=n;i++) v[i]=read();
	for(re int i=1,a;i<=n;i++) {a=read();if(a) e[a].push_back(i);}
	for(re int i=1;i<=n;i++) if(!dfn[i]) tarjan(i);
	for(re int i=1;i<=n;i++)
		for(re int j=0,u,v;j<e[i].size();j++)
		{
			u=c[i],v=c[e[i][j]];
			if(u==v) continue;
			du[v]++;
			_e[u].push_back(v);
		}
	for(re int i=1;i<=tot;i++)
		if(!du[i]) _e[0].push_back(i);
	dfs(0,m);
	printf("%d",dp[0][m]);
	return 0;
}

```

再安利一下我的[树型DP学习笔记](https://www.cnblogs.com/Wednesday-zfz/p/12209729.html)

---

## 作者：xyz32768 (赞：13)

强连通分量+树形$DP$。

首先对于每个$i$，从$i$向$Di$建一条有向边。

在这里我们发现，依赖关系可以形成环。对于一个环，里面的节点要么都选，要么都不选。

所以，这里先$Tarjan$强连通分量缩点，构成一个新图，这样新图里的每个节点可以看成一个整体考虑（因为对应的原图里的节点要么都选要么都不选）。然后新建一个虚拟节点，向新图里所有的入度为$0$的节点建一条有向边，构成一棵树，以虚拟节点作为根。

建树完毕后，在构成的树上做$DP$。

以下$cost[i]$和$val[i]$分别为树上每个节点的费用和价值，设$f[u][i]$为在节点$u$的子树内，费用限制为$i$的条件下能取到的最大价值，此时对于每个$u$，首先把$f[u][i]$（$cost[u]<=i<=m$）设为$val[u]$。

然后如果第一层循环$u$的子节点$v$，第二层**倒序**循环$i$（从$m-cost[u]$到$0$），第三层**顺序**循环节点$v$的子树的费用限制$j$（从$0$到$i$），则转移方程为：$f[u][i+cost[u]]=max(f[u][i+cost[u]],f[u][i+cost[u]-j]+f[v][j])$。

最后答案为$f[虚拟节点][m]$。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
const int N = 105, M = 505;
int n, m, W[N], V[N], f[N][M], ecnt, nxt[M], adj[N], go[M], top,
sta[N], dfn[N], low[N], times, num, bel[N], cost[N], val[N], ecnt2,
nxt2[M], adj2[N], go2[M], d[N];
bool ins[N], G[N][N];
void add_edge(int u, int v) {
    nxt[++ecnt] = adj[u]; adj[u] = ecnt; go[ecnt] = v;
}
void add_edge2(int u, int v) {
    nxt2[++ecnt2] = adj2[u]; adj2[u] = ecnt2; go2[ecnt2] = v;
}
void Tarjan(int u) {
    dfn[u] = low[u] = ++times;
    sta[++top] = u; ins[u] = 1;
    for (int e = adj[u], v; e; e = nxt[e])
        if (!dfn[v = go[e]]) {
            Tarjan(v);
            low[u] = min(low[u], low[v]);
        }
        else if (ins[v]) low[u] = min(low[u], dfn[v]);
    if (dfn[u] == low[u]) {
        int v; bel[u] = ++num; ins[u] = 0;
        while (v = sta[top--], v != u) bel[v] = num, ins[v] = 0;
    }
}
void dp(int u) {
    int i, j;
    for (i = cost[u]; i <= m; i++) f[u][i] = val[u];
    for (int e = adj2[u], v; e; e = nxt2[e]) {
        dp(v = go2[e]);
        for (i = m - cost[u]; i >= 0; i--) for (j = 0; j <= i; j++)
            f[u][i + cost[u]] = max(f[u][i + cost[u]],
                f[u][i + cost[u] - j] + f[v][j]);
    }
}
int main() {
    int i, j, x; n = read(); m = read();
    for (i = 1; i <= n; i++) W[i] = read();
    for (i = 1; i <= n; i++) V[i] = read();
    for (i = 1; i <= n; i++) if (x = read()) add_edge(x, i);
    for (i = 1; i <= n; i++) if (!dfn[i]) Tarjan(i);
    for (i = 1; i <= n; i++) {
        cost[bel[i]] += W[i]; val[bel[i]] += V[i];
        for (int e = adj[i]; e; e = nxt[e])
            if (bel[i] != bel[go[e]]) G[bel[i]][bel[go[e]]] = 1,
                d[bel[go[e]]]++;
    }
    for (i = 1; i <= num; i++) for (j = 1; j <= num; j++)
        if (G[i][j]) add_edge2(i, j);
    for (i = 1; i <= num; i++) if (!d[i])
        add_edge2(num + 1, i);
    printf("%d\n", (dp(num + 1), f[num + 1][m]));
    return 0;
}
```

---

## 作者：Flandre_495 (赞：12)

#### 来一份写起来简单一点的代码吧~。感觉别的题解都这么冗长。

~~虽然不知道我的码为什么跑起来这么慢。。。~~

一道树形背包的入门题，蒟蒻调了半天，太菜了~

____________


此题就是[选课](https://www.luogu.org/problem/P2014)这题的~~花里胡哨~~版。没做过[选课](https://www.luogu.org/problem/P2014)的可以回去看一下，双倍经验~

本题多了一个地方就是环，既然不保证是一颗树，我们就把它缩点缩成树。

而我没有用tarjan~ ， 这样看起来代码漂亮一些，也短一些。

我是直接拓扑，拓扑完之后只剩下环，就可以直接缩点了。记得把缩完后的点跟 $0$ 再连边，这样才能保证是棵树。

树形背包就不用再说了吧，不会的去做[选课](https://www.luogu.org/problem/P2014)。

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#define QWQ cout<<"QwQ"<<endl;
#define ll long long 
#include<vector>
#include<queue>
#include<stack>
#include<map>
using namespace std;
const int N=101010;
const int qwq=303030;
const int inf=0x3f3f3f3f;
int n,m;
int cnt;
int a[N];
bool vis[N];
int belong[N];
int w[N],v[N];
int fa[N],ru[N];
int dp[234][678];
vector <int> e[N];
vector <int> d[N];

inline int read() {
	int sum = 0, f = 1; char c = getchar();
	while(c<'0' || c>'9') { if(c=='-') f = -1; c = getchar(); }
	while(c>='0'&&c<='9') { sum = sum * 10 + c - '0'; c = getchar(); }
	return sum * f;
}

void DFS(int u) {
	vis[u] = 1;
	for(int i=0;i<e[u].size();i++) {
		int to = e[u][i];
		if(vis[to]) continue;
		ru[to]--;
		if(!ru[to]) DFS(to);
	}
}

void DP(int u) {
	for(int i=0;i<=m;i++) dp[u][i] = (i>=w[u]) ? v[u] : -inf;
	for(int i=0; i<d[u].size(); i++) {
		int to = d[u][i]; DP(to);
		for(int j=m;j>=w[u];j--)
		for(int k=w[to];k<=j;k++)
		dp[u][j] = max(dp[u][j],dp[u][j-k]+dp[to][k]);
	}
}

int main() {
	n = read(); m = read(); cnt = n;
	for(int i=1;i<=n;i++) w[i] = read();
	for(int i=1;i<=n;i++) v[i] = read();
	for(int i=1;i<=n;i++) {
		belong[i] = i;
		fa[i] = read();
		ru[fa[i]]++;
		e[i].push_back(fa[i]);
	}
	for(int i=1;i<=n;i++) 
	if(!ru[i] && !vis[i]) DFS(i);
	for(int i=1;i<=n;i++) {
		if(vis[i]) continue;
		cnt ++; d[0].push_back(cnt);
		int now = i;
		while(!vis[now]) {
			belong[now] = cnt;
			vis[now] = 1;
			w[cnt] += w[now];
			v[cnt] += v[now];
			now = fa[now];
		}
	}
	for(int i=1;i<=n;i++) 
	if(belong[i]==i)
	d[belong[fa[i]]].push_back(i);
	DP(0);
	printf("%d",dp[0][m]);
	return 0;
}


```


---

## 作者：da32s1da (赞：7)

这个题看起来是个缩点+树规，但是只要分析一下数据就会发现：

如果有环的话缩完点上面只能连接虚拟0点，而有环的话下面不可能有环。

因为数据较小，所以于是输入数据的时候暴力处理一下，在树规就可以了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,w[111],v[111],vis[111][555],f[111][555],lc[111],rc[111];
int a,b,c,d,bh[111],fa[111],fat[111],fath[111],rw[111],rv[111];  //此方法多加了这点东西 
int dfs(int p,int q)
{
    if(p==-1||q==0) return 0;
    if(vis[p][q]) return f[p][q];
    vis[p][q]=1;
    f[p][q]=dfs(rc[p],q);
    for(int i=0;i<=q-rw[p];i++)
    f[p][q]=max(f[p][q],dfs(lc[p],i)+dfs(rc[p],q-rw[p]-i)+rv[p]);
    //状态转移方程:左孩子所在树分i个体积，右孩子分(q-根体积-i)个体积 
    return f[p][q];
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++) cin>>w[i],fa[i]=i;
    for(int i=1;i<=n;i++) cin>>v[i];    //读入 
    for(int i=1;i<=n;i++)
    {
        cin>>a;fa[i]=a;
        if(bh[a]==0&&a!=0)    //父亲不在环中 
        {
            c=a;d=0;
            while(c!=0)     //找是否有环 
            {
                c=fa[c];d++;
                if(c==i||d==111) break;
            }
            if(c==i)    //是环的话标记 
            {
                b++;rw[b]=w[i];rv[b]=v[i];bh[i]=b;
                while(a!=i) rw[b]+=w[a],rv[b]+=v[a],bh[a]=b,a=fa[a];
            }
        }
    }
    for(int i=1;i<=n;i++)
    if(bh[i]==0) b++,rw[b]=w[i],rv[b]=v[i],bh[i]=b; //将没标记的标记 
    for(int i=1;i<=n;i++) if(bh[i]!=bh[fa[i]]) fath[bh[i]]=bh[fa[i]];  //父亲更改 
    for(int i=0;i<=b;i++) lc[i]=-1,rc[i]=-1;
    for(int i=1;i<=b;i++)    //多叉树转二叉树 
    {
        if(lc[fath[i]]>0) rc[i]=lc[fath[i]];
        lc[fath[i]]=i;
    }
    cout<<dfs(0,m);    //树规 
    return 0;
}
/*
3 16
5 5 6
2 3 4
3 1 2
*/
```

---

## 作者：__Iron (赞：6)

~~**不知道有没有和我一样看不懂题解的，若没有，请跳过此篇题解。（逃~）**~~

### 理解题意 
~~**这很重要。**~~

**①：** 现在我们的手头有N个软件， 对于一个软件i， 它要占用W_i的磁盘空间， 它的价值为V_i， 我们希望从中选择一些软件安装到一台磁盘容量为M计算机上， 使得这些软件的价值尽可能大（即V_i的和最大）。

~~（不难发现）~~ 第一段告诉我们这好像是一个**背包问题。**

**②：** 软件之间存在依赖关系 ， 即软件i只有在安装了软件j（包括软件j的直接或间接依赖）的情况下才能正确工作（软件i依赖软件j)。

存在 **依赖性 的背包？** 

**③：** 幸运的是，一个软件最多依赖另外一个软件。如果一个软件不能正常工作，那么它能够发挥的作用为0。

好像是**基环森林。**

总结题意：
 
 ①：依赖性背包。
 
 ②：基环森林。
 
###  solution：
 
 ①：建图，我们首先处理基环森林。
 
 我们在 **d[i] --> i** 连一条边。
 
 可以发现要安装软件i ，i的父节点一直到i的祖先节点（即i的父节点到根节点）必须都安装。
 
 若构成环，那么要不都安装，要不都不安装。
 
 所以我们缩点（Tarjan）。
 
 缩完点图可能会不连通，所以我们建一个虚拟节点。将每一个连通块入度为0的点，连一条 **虚拟节点 --> 入度为零的点。**

 建完图，构成一个以虚拟节点为根的**树**。
 
 **树上依赖性背包问题**。
 
 如果你没做过这类题型，可能不会处理，这里主要说一下  dp的转移。
 
 设dp[ i ] [ j ] 表示第i个节点，用不超过j的空间的最大价值。
 
 初始化：
 
 ```cpp
for(register int i=sw[x];i<=m;i++) dp[x][i]=sv[x];

```
注： sw为缩完点后一个环内总空间，sv为缩完点后一个环内总价值。

转移：

```cpp
inline void dfs(int x){ //当前搜索到x
   for(register int i=sw[x];i<=m;i++) dp[x][i]=sv[x];
   for(register int i=hed1[x];i;i=net1[i]){
   	  int v1=to1[i];
   	  dfs(v1);
   	  for(register int j=m-sw[x];j>=0;j--)
   	   for(register int k=0;k<=j;k++)
   	    dp[x][j+sw[x]]=max(dp[x][j+sw[x]],dp[x][j+sw[x]-k]+dp[v1][k]);
   }	
}
```
 ```cpp
dp[x][j+sw[x]]=max(dp[x][j+sw[x]],dp[x][j+sw[x]-k]+dp[v1][k]);
```
 父亲节点用 j+sw[x] 空间的最大价值，是子节点用 k 空间，父亲节点用 j+sw[x]-k 空间的最大价值之和。
  
 j倒序枚举的原因是： **01背包**。
 
 由于每个子节点只能选一次，如果正序枚举的话，显然，dp[ x ][ j+sw[x]-k ]就可能已经选了子节点，而由它转移而来，有可能再选一次。（即正向枚举是一个完全背包，每个可以选多次。）

你可能会有 **疑问** ：

 **为什么可以先处理子节点，且能转移到父节点 ，依赖性的处理呢，不应该父节点选了，才能选子节点吗？**
 
 注意枚举的大小：j+sw[ x ]的最小值为 sw[ x ], **dp[x][ j+sw[x] ]** ，x至少用 sw[ x ] 的空间，且只能由 **dp[x][ sw[x] ]+dp[v1][0]** 转移而来，而 dp[ v1 ][0] 显然为子节点没选，价值为0 。而 **j+sw[ x ]-k** 的最小值也为 sw[x]。即 **sw[ x ]必选**！
 
 子节点可选可不选，父节点必选，满足前面依赖性的要求。
 
**Code：**

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
inline int read(){
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=x*10+ch-'0';
		ch=getchar();
	}
	return x*f;
}
const int N=1e2+7;
int n,m,w[N],v[N],d[N];
int num,hed[N],to[N],net[N],fl[N];
inline void add(int x,int y){
	num++;
	to[num]=y;
	net[num]=hed[x];
	hed[x]=num;
}
int dfn[N],low[N],cnt,co[N],col,st[N],top;
inline void tarjan(int u){
	dfn[u]=low[u]=++cnt;
	top++;
	st[top]=u;
	for(register int i=hed[u];i;i=net[i]){
		int v1=to[i];
		if(!dfn[v1]){
			tarjan(v1);
			low[u]=min(low[u],low[v1]);
		}else if(!co[v1])
		       low[u]=min(low[u],dfn[v1]);
	}
	if(dfn[u]==low[u]){
		col++;
		co[u]=col;
		while(st[top]!=u){
			co[st[top]]=col;
			top--;
		}
		top--;
	}
}
int num1,hed1[N],to1[N],net1[N];
inline void add1(int x,int y){
	num1++;
	to1[num1]=y;
	net1[num1]=hed1[x];
	hed1[x]=num1;
}
int sv[N],sw[N],dp[N][510],size[N];
inline void dfs(int x){
   for(register int i=sw[x];i<=m;i++) dp[x][i]=sv[x];
   for(register int i=hed1[x];i;i=net1[i]){
   	  int v1=to1[i];
   	  dfs(v1);
   	  for(register int j=m-sw[x];j>=0;j--)
   	   for(register int k=0;k<=j;k++)
   	    dp[x][j+sw[x]]=max(dp[x][j+sw[x]],dp[x][j+sw[x]-k]+dp[v1][k]);
   }	
}
int main(){
	n=read();m=read();
	for(register int i=1;i<=n;i++) w[i]=read();
	for(register int i=1;i<=n;i++) v[i]=read();
	for(register int i=1;i<=n;i++) d[i]=read(),
	add(d[i],i);
	for(register int i=0;i<=n;i++)
	 if(!dfn[i]) tarjan(i);
	for(register int i=1;i<=n;i++)
	 if(co[d[i]]!=co[i]){
	 	add1(co[d[i]],co[i]);
	 	fl[co[i]]=1;
	 } 
	for(register int i=1;i<=col;i++)
		if(fl[i]==0) add1(0,i);
	for(register int i=1;i<=n;i++)
		sv[co[i]]+=v[i],sw[co[i]]+=w[i];
	dfs(0);
	printf("%d",dp[0][m]);
	return 0;
}
```


 
 
   

---

## 作者：Eziotao (赞：5)

**考试爆炸很绝望.jpg**

~~别告诉我只有我忘了缩点~~

	每个软件只直接依赖另一个（不依赖的就假设依赖0嘛）。画图，三分钟后。
    树上的背包问题嘛，好说。对于每个节点，选了它才能选它的子节点，那我们设f[i][j]表示到i号点了,用j这样大的空间能得到的最大价值。设d是i的子节点，那么f[d][j]可以从f[i][j-w[d]-w[i]]+v[i]得到(为什么要减w[i],加v[i]?因为你必须选了它的父亲节点，才能选到它，对吧)，那么我找出每个子树用一定数量的空间能到的最大价值，分别枚举每种情况(d1用多少，d2用多少...)，统一在i里，统计一下，答案好像就出来了（如果不是很懂，在下自以为注释写得还行,,）。然后我愉快的打完了板子（好像还出锅了？）,继续往后做。
    这时看起来似乎没什么不对。
    直到考完后，大仙(fyj)问我：“你tarjan怎么打的？”我：一脸懵逼。看看题目，没有说不能成环啊，如果成环，要么都不选，要么都选，是吧。于是我愉快的RE了。再看看题，如果成环,那么这个环一定不依赖任何点（仿佛说了句废话,每个点只能依赖最多一个，依赖成环了环里哪来的空的点依赖别的）,继续想，变成一个森林了。树根不依赖怎么办呢？反正0无贡献无占位，那就把树根都置为连到0好了。然后，就可以愉快的再打一个板子了(tarjan)。
```cpp
//果断树形dp，结果忘了一个很重要的东西,, 
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#include<queue>
#include<deque>
#include<iostream>
#define ll long long 
#define re register
#define inf 0x7f7f7f7f
#define inl inline
#define debug printf("debug\n");
//#define eps 1e-8
//#pragma comment(linker, "/STACK:1024000000,1024000000")
//#pragma GCC optimize (2)
//#pragma G++ optimize (2)
using namespace std;
//const ll mod;(同学看到头文件风格就知道是我2333 )
inl ll read() {
    re ll x = 0; re int f = 1;
    char ch = getchar();
    while(ch<'0'||ch>'9') { if(ch== '-' ) f = -1; ch = getchar(); }
    while(ch>='0'&&ch<='9') {x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
    return x * f;
}
inl void write(ll x){
    if(x>=10)write(x/10);
    putchar(x%10+'0');
}
inl void writeln(ll x){
    if(x<0) {x=-x;putchar('-');}
    write(x); puts("");
}
inl void FR(){
	freopen("software.in","r",stdin);
	freopen("software.out","w",stdout);
} 
inl void FC(){
	fclose(stdin);
	fclose(stdout);
}//考试题,, 
ll cnt,head[105];
struct Node{
	ll u,v,nxt;
}e[105<<1],en[105<<1];//有可能循环依赖，必须缩点
ll w[105],v[105],n,m;//en是重建的图 ，w,v原权值和原花费 
void adde(ll u,ll v){
	e[++cnt].u=u;e[cnt].v=v;
	e[cnt].nxt=head[u];
	head[u]=cnt;
}
ll head2[105];
void adden(ll u,ll v){
	en[++cnt].u=u;en[cnt].v=v;
	en[cnt].nxt=head2[u];
	head2[u]=cnt;
} 
ll d[105];//dfsn
ll f[105][505];//一维处理到几号店，第二维花费多少 
ll ssw[105],ssv[105];//缩点后每个点的花费和权值 
ll tot=0;
void dfs(ll x){
	d[++tot]=x;
	if(!head2[x]){
		for(re ll i=ssw[x];i<=m;i++){
			f[x][i]=ssv[x];
		}
		return ;
	}//没有子节点，自己返回美滋滋 
	for(re ll i=head2[x];i;i=en[i].nxt) dfs(en[i].v);//有子节点先看子节点 
	for(re ll i=head2[x];i;i=en[i].nxt){
        re ll y=en[i].v;//枚举子节点 
        for(re ll tow=m;tow>=0;tow--){//在这个子节点分配的 
            for(re ll j=0;j<=tow;j++){//剩余的(分配到其他子节点的，自己的在后面加) 
                f[x][tow]=max(f[x][tow],f[x][tow-j]+f[y][j]);//大仙我不是故意打出fyj的！！ 
            }
        }
    }
    for(re ll i=m;i>=0;i--){
        if(i>=ssw[x]) f[x][i]=f[x][i-ssw[x]]+ssv[x];//可以选 
        else f[x][i]=0;// 不能选，玩蛇皮 
    }
}
vector<ll>S[105];//tarjan用 
ll low[105],dfn[105],cmt,pre[105],bel[105];//好像不需要开这么多（管他呢反正不卡空间 ） 
ll in[105];//(tarjan：在不在栈里   重置后：有无依赖) 
stack<ll>Q;//tarjan大法好,,, 
void dfs1(ll x){
	dfn[x]=++tot;low[x]=tot;pre[tot]=x;Q.push(x);
	in[x]=1;
	for(re ll i=head[x];i;i=e[i].nxt){
		re ll sv=e[i].v;
		if(!dfn[sv]) {
			dfs1(sv);
			low[x]=min(low[x],low[sv]);
		}
		else if(in[sv]){
			low[x]=low[sv];
		}
	}
	if(low[x]==dfn[x]){
		++cmt;
		ll ssx;
		do{
			ssx=Q.top();
			S[cmt].push_back(ssx);
			bel[ssx]=cmt;
			in[ssx]=0;
			Q.pop();
		}while(ssx!=x);
	}
}//tarjan自觉套模板（太久没看打到泪奔） 

inl void tarjan(){
	for(re ll i=1;i<=n;i++){
		if(!dfn[i]) dfs1(i);
	}
}//写出来感觉好看一点, 
int main(){
//	FR(); 
	n=read(),m=read();
	for(re ll i=1;i<=n;i++) w[i]=read();
	for(re ll i=1;i<=n;i++) v[i]=read();
	w[0]=0;v[0]=0;//0号点无花费（也无贡献,,） 
	for(re ll i=1;i<=n;i++){
		ll x=read();adde(x,i);
	}//加边,, 
	tarjan();//缩点 
	memset(in,0,sizeof(in));//缩完了，忙完了这阵子，in就可以忙下阵子了 
	cnt=0;
	for(re ll i=1;i<=n;i++) {
		for(re ll j=head[i];j;j=e[j].nxt){
			re ll x=e[j].u,y=e[j].v;
			if(bel[x]==bel[y]) continue ;
			adden(bel[x],bel[y]);
			in[bel[y]]++;
		}//重构图，貌似没什么问题吧,,（出锅了请联系fyj,他教我的！） 
	}
	for(re ll i=1;i<=cmt;i++){
		if(!in[i]) adden(0,i);//把没有依 赖的设为依赖0，就可以一次树形跑完了 
		for(re ll j=0;j<S[i].size();j++){
			ssw[i]+=w[S[i][j]];
			ssv[i]+=v[S[i][j]];
		}//缩点后各点权值及花费 
	}
	tot=0;
	dfs(0);//dp一波 
	writeln(f[0][m]);//输出 
//	FC();
    return 0;
}
```

---

## 作者：Minclxc (赞：4)

没写tarjin过了。

直接在原图上建树，毕竟每棵子树的环最多一个。

vis[]深搜过，ins[]在栈中，bel[]属于哪个节点

详见代码过程dfs

```cpp
#include<stdio.h>
#include<string.h>
#include<iostream>
#include<stack>
using namespace std;
#define fi(a,b) for(int i=a;i<=b;i++)
const int maxn=102,maxm=501;
int n,m,w[maxn],v[maxn],d[maxn];//标准输入
int vis[maxn],ins[maxn],bel[maxn];//建树
int son[maxn],bro[maxn],f[maxn][maxm];//动规，son[]子节点，bro[]父亲的其他子节点，多叉树改二叉树
stack<int>sta;
int min(int a,int b){return a<b?a:b;}
int max(int a,int b){return a>b?a:b;}
void init(){
    scanf("%d%d",&n,&m);fi(1,n)scanf("%d",&w[i]);
    fi(1,n)scanf("%d",&v[i]);fi(1,n)scanf("%d",&d[i]);
    memset(vis,0,sizeof(vis));memset(ins,0,sizeof(ins));
    memset(son,0,sizeof(son));memset(bro,0,sizeof(bro));
    memset(f,-1,sizeof(f));fi(1,n)bel[i]=i;
}//输入、初始化
void add(int u,int v){
    if(!son[u])son[u]=v;
    else{
        int x=son[u];while(bro[x])x=bro[x];
        bro[x]=v;
    }
}//加边
void dfs(int s){
    vis[s]=1;int t=bel[d[s]];//下一个点
    if(!d[s]){add(n+1,s);return;}//如果没父亲指向根
    ins[s]=1;sta.push(s);
    if(vis[t])//如果下一个点深搜过
        if(ins[t]){//且还在栈中
            for(int x=sta.top();x!=t;sta.pop(),x=sta.top()){//环里所有点属于下一个点（即环第一个遍历到的）
                bel[x]=t;w[t]+=w[x];v[t]+=v[x];ins[x]=0;
            }
            ins[t]=0;sta.pop();
            add(n+1,t);//加一条到跟的边
        }
        else add(t,s);//下一个点访问过且不在栈中，那么当前点在下一个点的子树中
    else{dfs(t);if(ins[s])add(t,s);}//没访问则访问
    ins[s]=0;
}
int dp(int n,int m){
    if(!n||!m)return 0;
    if(f[n][m]!=-1)return f[n][m];
    int t=dp(bro[n],m);
    fi(0,m-w[n])t=max(t,v[n]+dp(son[n],i)+dp(bro[n],m-w[n]-i));
    f[n][m]=t;
    return t;
}
int main(){
    init();//输入、初始化
    fi(1,n)if(!vis[i])dfs(i);//建树
    printf("%d\n",dp(n+1,m));//动规
    return 0;
}
```

---

## 作者：TLE自动机 (赞：3)


一、P2515

因为每个软件一来的软件只有一个（即：每个节点最多只有一个父亲节点），所以这个N个软件形成了森林结构，因为可能有多个软件是可以独立安装的。

为方便处理，我们可以为所有树增加一个虚拟根0，其wi=0，vi=0。

用f[u][j]代表为节点u为根的子树分配体积为j时这棵子树所能得到的最大收益。设u的儿子为集合v={v1，v2，v3…}，儿子个数记为p。当安装了u这个软件后，考虑v1，我们可以为v1为根的子树分配体积k1，为v2子树分配体积k2,……∑ki=j-1。

f[u][j]=max{f[v][ki]}+val[x]  (ki>=0,∑ki=j-1)

f[u][0]=0


二、其实本问题也是一个 
#### “分组背包模型”。
分组背包：有N件物品和一个容量为V的背包，第i件物品的费用是w[i]，价值是c[i]。这些物品被划分为若干组，每组中的物品互相冲突，最多选一件。求解将哪些物品装入背包可以使获得的价值最大。

问题分析：这个问题即对于某组物品的选择策略是要么选某一件，要么都不选。

#### 状态：f[i][j]代表前i组物品选取体积为j的物品装入背包的最大价值。

#### 状态转移：f[i][j]=max{ f[i-1][j],f[i-1][j-w[k]]+c[k]) w[k] 物品k属于第i组

![](https://cdn.luogu.com.cn/upload/pic/45981.png)

~~图片大小怎么改啊QAQ~~

为更好地理解这个背包模型，我们将f[u][j]状态修改为f[u][i][j]，表示在安装了软件u后，从u的前i个儿子选出体积为j的物品装入背包时所能得到的最大价值。

u的p个儿子就是p个分组，对u的某个儿子v1，只可能由一种状态转移至u（也即为v分配的体积要么是0，要么是1，要么是2…要么是j-1），也就是v1这一组里面共j件物品且互相冲突，只能选取一件。

f[u][i][j]=max{ f[u][i-1][j],f[u][i-1][j-w[k]]+c[k]) w[k] 物品k属于第i组

##### *f[u][i-1][j]:f[u][i-1][j]也即第i组物品选0这种策略。

##### *f[u][i-1][j-w[k]]+c[k]:第i组第k件物品的w[k]=k,c[k]=f[v][pv][k],pv是v的儿子节点个数。

#### 优化：状态表示中，i这一维度可以省略，但循环体积v时，就要采用倒序循环。

### 代码实现&&赠送数据QwQ：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<stack>
using namespace std;
struct node{
    int next,to;
};
int w[1005],val[1005],f[1005][505];
int n,m;
//原图 
node edge[105];
int head[105],cnt=0;
void add_edge(int from,int to){
    cnt++;
    edge[cnt].next=head[from];
    edge[cnt].to=to;
    head[from]=cnt;
}
//新图 
int h[1005],ct=0;
node eg[1005];
bool query(int u,int v){
    for(int i=h[u];i!=0;i=eg[i].next){
        if(eg[i].to==v)return true;
    }
    return false;
}
void in(int u,int v){
    ct++;
    eg[ct].next=h[u];
    eg[ct].to=v;
    h[u]=ct;
}
//缩点 
int ti=0,dfn[105],low[1005],color[1005],c=0,wx[1005],vx[1005];
stack<int>s;
bool instack[105];
void tarjan(int u){
    ti++;
    dfn[u]=low[u]=ti;
    s.push(u);
    instack[u]=true;//标记该点在栈中 
    for(int i=head[u];i!=0;i=edge[i].next){
        int v=edge[i].to;
        if(!dfn[v]){
            tarjan(v);
            low[u]=min(low[u],low[v]);
        }
        else if(instack[v]){
            low[u]=min(low[u],dfn[v]);
        }
    }
    if(dfn[u]==low[u]){
        c++;//将同一个强联通分量缩点为c 
        while(s.top()!=u){
            color[s.top()]=c;
            wx[c]+=w[s.top()];//体积累计 
            vx[c]+=val[s.top()];//价值累计 
            instack[s.top()]=false;
            s.pop();
        }
        color[s.top()]=c;
        wx[c]+=w[s.top()];
        vx[c]+=val[s.top()];
        instack[s.top()]=false;
        s.pop();
    }
}
//背包 
void dfs(int u){
    f[u][0]=0;
    for(int i=h[u];i!=0;i=eg[i].next){
        int v=eg[i].to;
        dfs(v);
        for(int j=m;j>=0;j--){
            for(int k=0;k<=j;k++){
                f[u][j]=max(f[u][j],f[u][j-k]+f[v][k]);
            }
        }
    }
    for(int j=m;j>=0;j--){
		if(j-wx[u]>=0)f[u][j]=f[u][j-wx[u]]+vx[u];
		else f[u][j]=0xcfffffff;
    } 
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    cin>>w[i];
    for(int i=1;i<=n;i++)
    cin>>val[i];
    for(int i=1;i<=n;i++){
        int p;
        cin>>p;
        if(p==0)continue;
        add_edge(p,i);
    }
    memset(f,0xcf,sizeof(f));
    for(int i=1;i<=n;i++)
        if(!dfn[i])tarjan(i);//缩点 
    int du[105]={0};
    for(int u=1;u<=n;u++){//遍历原图的每一条边重新建图 
        
        for(int i=head[u];i!=0;i=edge[i].next){
            int v=edge[i].to;
            if(color[u]==color[v])continue;
            if(!query(color[u],color[v])){
                in(color[u],color[v]);
                du[color[v]]++;
            }
        } 
    }
    
    for(int u=1;u<=c;u++){
        if(du[u]==0)in(0,u);
    }
    
    dfs(0);
    int ans=-1;
    for(int j=m;j>=0;j--)ans=max(ans,f[0][j]);
    cout<<ans<<endl;
    return 0;
}
/*
3 10
0 10 0
2 3 4
0 1 1


5 10
2 2 2 2 2
1 2 3 4 5
3 1 2 0 4

6 10
1 1 1 1 1 1
1 2 3 4 5 6
2 3 1 1 2 3

6 10
0 0 0 0 0 0
1 2 3 4 5 6
2 3 1 1 2 3
*/

```




---

## 作者：zzzc18 (赞：2)

##Tarjan+树形DP


[[HAOI2010]软件安装](https://www.luogu.org/problem/show?pid=2515)

根据题意，如果依赖关系构成一个环，那只有环里所有软件都安装才能使其价值不为0；

    
在入度为0的点之上加一个点，这样可以一下DP完


然后用树状DP解决，注意到如果下面的点的占用空间超过m，其价值在DP数组中直接化为0；其实是一个树上的01背包


----
```cpp
#include<iostream>
#include<cstdio>
#include<stack>
using namespace std;

stack<int> s;
int n,m,weight[200],value[200];
bool indegree[600];
int LOW[600],DFN[600],steps,total;
bool instack[600];
int dp[200][600];

struct E{
    int next,to,from;
}edge[600],newedge[600];
int head[600],nhead[600],edge_num,newedge_num;
struct S{
    int w,v;
}scc[600];
int belong[600];

void addedge(int x,int y,int z){
    if(z==1){
        edge[++edge_num].next=head[x];
        edge[edge_num].to=y;
        edge[edge_num].from=x;
        head[x]=edge_num;
    }
    if(z==2){
        newedge[++newedge_num].next=nhead[x];
        newedge[newedge_num].to=y;
        newedge[newedge_num].from=x;
        nhead[x]=newedge_num;
    }
}

void Tarjan(int x){
    int i;
    s.push(x);instack[x]=true;
    DFN[x]=LOW[x]=++steps;
    for(i=head[x];i;i=edge[i].next){
        if(!DFN[edge[i].to]){
            Tarjan(edge[i].to);
            LOW[x]=min(LOW[x],LOW[edge[i].to]);
        }
        if(instack[edge[i].to])
            LOW[x]=min(LOW[x],DFN[edge[i].to]);
    }
    if(LOW[x]==DFN[x]){
        int t;
        total++;
        do{
            t=s.top();s.pop();
            instack[t]=false;
            belong[t]=total;
            scc[total].v+=value[t];
            scc[total].w+=weight[t];
        }
        while(t!=x);
    }
}

void Newmap(){
    int i,j;
    for(i=1;i<=n;i++){
        for(j=head[i];j;j=edge[j].next){
            if(belong[i]!=belong[edge[j].to]){
                indegree[belong[edge[j].to]]=true;
                addedge(belong[i],belong[edge[j].to],2);
            }
        }
    }
//    for(i=1;i<=edge_num;i++){
//        if(belong[edge[i].from]!=belong[edge[i].to]){
//            indegree[belong[edge[i].to]]=true;
//            addedge(belong[edge[i].from],belong[edge[i].to],2);
//        }
//    }
}


//此处DP为树上01背包 
void DP(int x){//树上DP ，x为当前(根)节点 
    int i,j,k;
    for(i=nhead[x]; i ;i=newedge[i].next){//节点x连接的每一条边 
        DP(newedge[i].to);//从延伸出去的点继续DFS 
        for(j=m-scc[x].w;j>=0;j--){// scc[x].w为当前节点的空间值(是题目中的“空间”的含义) 
            //m -scc[x].w就是刨除该节点不算，可以供安装的剩余空间 
            for(k=0;k<=j;k++){
                //这里是递推
                //k为选择的空间量，j-k是仍可供选择的空间 
                dp[x][j]=max(dp[x][j],dp[x][k]+dp[newedge[i].to][j-k]);
            }
        }
    }
    //上面搞完了，或者上面没有连到节点的边
    //到底了的情况很自然就是这样
    //要是没到底，如果 scc[x].w 超过 j ，就说明 j 的容量不足以安装下面的子树，以x为根的树价值为0 
    for(j=m;j>=0;j--){
        if(j>=scc[x].w)
            dp[x][j]=dp[x][j-scc[x].w]+scc[x].v;
        else
            dp[x][j]=0;
    }
}

int main(){
    freopen("2515.in","r",stdin);
    scanf("%d%d",&n,&m);
    int i;
    for(i=1;i<=n;i++)
        scanf("%d",&weight[i]);
    for(i=1;i<=n;i++)
        scanf("%d",&value[i]);
    for(i=1;i<=n;i++){
        int k;
        scanf("%d",&k);
        if(k==0) continue;
        addedge(k,i,1);
    }
    for(i=1;i<=n;i++){
        if(!DFN[i])
            Tarjan(i);
    }
    Newmap();
    for(i=1;i<=total;i++){
        if(!indegree[i]){
            indegree[i]=true;
            addedge(total+1,i,2);
        }
    }
    DP(total+1);
    printf("%d",dp[total+1][m]);
    return 0;
}
```

---

## 作者：rainygame (赞：1)

这个题解主要是用于解释状态转移方程及说明一些坑点。

~~貌似没有题解细讲树上背包 DP。~~

首先用 Tarjan 对这个有向图进行[缩点](https://www.luogu.com.cn/problem/P3387)，因为如果成强连通分量，那么其中所有的点要么全选，要么全不选。因此我们可以直接把这个强连通分量的价值或代价设为其中所有点的价值或代价之和。

因为每个点都最多只有一个依赖点，所以缩完点后必定呈一个森林，建立超级源点 $0$（价值和代价均为 $0$）连接所有入度为 $0$ 的强连通分量即可形成一棵树。

定义状态：$f_{i,j}$ 表示到第 $i$ 个子树，背包容量为 $j$ 时的最大价值和。

首先，边界条件为 $f_{i,j}=v_i(m \ge j \ge w_i)$。注意这里不能只赋值 $f_{i,w_i}$，而是全部都要赋值。

然后我们考虑像背包一样进行状态转移方程，我们现在已经知道 $u$ 是必选的，所以背包的大小不能小于 $w_u$。再考虑枚举其子结点 $v$ 的情况，我们枚举它的容量 $k$，其中 $0 \le k \le j-w_u$（这个 $j-w_u$ 是因为 $u$ 点是必选的，所以必须用在 $u$ 上，剩下 $j-w_u$）。然后 $f_{u,j}\leftarrow\max\{f_{u,j},f_{u,j-k}+f_{v,k}\}$。具体可以参考代码。

时间复杂度应该是 $O(nm^2)$ 的吧，反正可以过。

注意几个点：

- 边界条件必须要全部赋值。
- 注意可能没有任何一个点不依赖。
- 注意背包的第一层循环是逆序的。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define MAXN 505

int n, m, su, sv, x, cnt, ssum;
int v[MAXN], w[MAXN], f[MAXN][MAXN];
int dfn[MAXN], low[MAXN], scc[MAXN], sccv[MAXN], sccw[MAXN];
vector<int> e[MAXN], g[MAXN];
bitset<MAXN> vis, rt;
stack<int> st;

void tarjan(int x){
	dfn[x] = low[x] = ++cnt;
	vis.set(x);
	st.push(x);
	for (auto i: e[x]){
		if (!dfn[i]){
			tarjan(i);
			low[x] = min(low[x], low[i]);
		}else if (vis.test(i)) low[x] = min(low[x], dfn[i]);
	}
	
	if (dfn[x] == low[x]){
		scc[x] = ++ssum;
		while (st.top() != x){
			vis.reset(st.top());
			scc[st.top()] = ssum;
			sccv[ssum] += v[st.top()];
			sccw[ssum] += w[st.top()];
			st.pop();
		}
		sccv[ssum] += v[x];
		sccw[ssum] += w[x];
		vis.reset(x);
		st.pop();
	}
}

void dfs(int x){
	for (int i(sccw[x]); i<=m; ++i) f[x][i] = sccv[x];
	for (auto i: g[x]){
		dfs(i);
		for (int j(m); j>=sccw[x]; --j){
			for (int k(0); k<=j-sccw[x]; ++k) f[x][j] = max(f[x][j], f[x][j-k]+f[i][k]);
		}
	}
}

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    cin >> n >> m;
    for (int i(1); i<=n; ++i) cin >> w[i];
    for (int i(1); i<=n; ++i) cin >> v[i];
    for (int i(1); i<=n; ++i){
    	cin >> x;
    	if (x) e[x].push_back(i);
	}
	
	for (int i(1); i<=n; ++i){
		if (!dfn[i]) tarjan(i);
	}
	
	for (int i(0); i<=n; ++i){
		su = scc[i];
		for (auto j: e[i]){
			sv = scc[j];
			if (su != sv){
				g[su].push_back(sv);
				rt.set(sv);
			}
		}
	}
	
	for (int i(1); i<=ssum; ++i){
		if (!rt.test(i)) g[0].push_back(i);
	}
	
	dfs(0);
	cout << f[0][m];

    return 0;
}

```


---

## 作者：神眷之樱花 (赞：1)

# 题意
一个裸的树形背包问题
# 解析
### 缩点
从某个物品依赖的物品向这个物品连边，得到一个有向图。

这时我们会发现，在一个强连通分量里，如果想要有价值的话，必须全部选，根据贪心的思想，对于一个强联通分量，要么全部选，要么全部不选，所以我们可以把这幅有向图进行缩点。

因为每个物品只有一个依赖关系，所以每个强连通分量最多只会有一个父节点，也就是说，缩点后我们得到了森林。

为了方便进行树形背包，我们可以建一个根节点 $0$ 号节点，把森林转化为一棵树。

### 背包
#### 状态
树形背包的老套路:
$dp[i][j]$ 表示以 $i$ 为根的子树，背包容量为 $j$ 时的最大价值。

当前节点的状态（体积 $v$），自然是由当前节点较小的背包（体积 $v_1$），加上子节点的背包（体积 $v_2$）。满足：
$$ v = v_1 + v_2$$
定义合法状态：
$w[x] \leq v$
#### 阶段
当前节点的背包容量，和子节点的背包容量。

注意外侧当前节点的背包容量采取倒叙循环，避免状态的重复转移。
#### 决策
判断当前阶段是否合法，取最大值。


------------

最后的答案自然就在 $dp[0][m]$ 中了，背包体积越大，自然价值就会相对更大。
# 代码
```cpp
#include<cstdio>
#include<iostream>
using std:: min;
using std:: max;
const int N = 1e2 + 5,M = 5e2 + 5;
struct edge {
	int next,to;
}a[N];
int head[N],n,m,a_size = 1,wei[N],v[N];
inline void add(int u,int v) {
	a[++a_size] = (edge){head[u],v};
	head[u] = a_size;
}
int dfn[N],low[N],val[N],w[N],c[N],sta[N],top = 0,cnt = 0,num = 0;
bool ins[N];
void tarjan(int x) {
	dfn[x] = low[x] = ++num;
	sta[++top] = x; ins[x] = true;
	for(int i = head[x]; i; i = a[i].next) {
		int y = a[i].to;
		if(!dfn[y]) {
			tarjan(y);
			low[x] =  min(low[x],low[y]); 
		}
		else if(ins[y]) 
			low[x] = min(low[x],dfn[y]);
	}
	if(dfn[x] == low[x]) {
		cnt++; int y;
		do {
			y = sta[top--],ins[y] = false;
			c[y] = cnt; w[cnt] += wei[y]; val[cnt] += v[y];
		}while(x != y);
	}
}
struct New {
	int next,to;
}e[N];
int hc[N],e_size = 1,deg[N];
inline void add_c(int u,int v) {
	e[++e_size] = (New){hc[u],v};
	hc[u] = e_size;
} int dp[N][M];
void dfs(int x) {
	for(int i = w[x]; i <= m; i++)
		dp[x][i] = val[x];
	for(int i = hc[x]; i; i = e[i].next) {
		int y = e[i].to; dfs(y);
		for(int j = m; j >= w[x]; j--)
			for(int k = w[y]; k <= j; k++)
			if(j - k >= w[x]) dp[x][j] = max(dp[x][j],dp[x][j - k] + dp[y][k]);
	}
}
inline int read() {
	int x = 0,flag = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9'){if(ch == '-')flag = -1;ch = getchar();}
	while(ch >='0' && ch <='9'){x = (x << 3) + (x << 1) + ch - 48;ch = getchar();}
	return x * flag;
}
int main() {
	n = read(),m = read();
	for(int i = 1; i <= n; i++)
		wei[i] = read();
	for(int i = 1; i <= n; i++)
		v[i] = read();
	for(int i = 1; i <= n; i++) {
		int u = read();
		if(u) add(u,i);
	}
	for(int i = 1; i <= n; i++)
		if(!dfn[i]) tarjan(i);
	for(int x = 1; x <= n; x++)
		for(int i = head[x]; i; i = a[i].next) {
			int y = a[i].to;
			if(c[x] == c[y]) continue;
			add_c(c[x],c[y]); deg[c[y]]++;
		}
	for(int i = 1; i <= cnt; i++)
		if(!deg[i]) add_c(0,i);
	dfs(0); printf("%d",dp[0][m]);
	return 0;
}
```


---

## 作者：AxDea (赞：1)

[题面](https://www.luogu.com.cn/problem/P2515)

本文主要来记录一个没见过的树形背包 DP 写法

这题是个裸的 tarjan 缩点和树形背包 DP 

显然循环依赖就缩成一点再进行 DP 即可

设 $f(i,j)$ 为 dfs 序中第 i 个点及以后占用磁盘空间为 j 的连通块的最大价值

有 $f(i,j)=\max f(i+1,j-W[i])+V[i],f(i+size_{dfn_i},j)$

时间复杂度 $\mathcal{O}(n\times m)$

Code(C++):
```cpp
#include<bits/stdc++.h>
#define forn(i,s,t) for(int i=(s);i<=(t);++i)
#define form(i,s,t) for(int i=(s);i>=(t);--i)
using namespace std;
const int N = 105,M = 505,INF = 1e9+7;
template<typename T>
inline void chkmax(T &A,T B) {A=A>B?A:B;}
struct List {
	int dir,nxt;
}E[N],T[N];
int G[N],cnt,cntt,GT[N],dT[N];
inline void Add(int u,int v) {
	E[++cnt].dir = v,E[cnt].nxt = G[u],G[u] = cnt;
}
inline void AddT(int u,int v) {
	T[++cntt].dir = v,T[cntt].nxt = GT[u],GT[u] = cntt,dT[v] ++ ;
}
int n,m,w[N],v[N],d[N],dn[N],stk[N],h,ord,clr[N],col,W[N],V[N];
bool vis[N];
int tarjan(int u) {
	int low = dn[u] = ++ord;
	stk[++h] = u,vis[u] = 1;
	for(int i=G[u];i;i=E[i].nxt) {
		int v = E[i].dir;
		if(!dn[v]) low = min(tarjan(v),low);
		else if(vis[v]) low = min(low,dn[v]);
	}
	if(low == dn[u]) {
		++col;
		do clr[stk[h]]=col,W[col]+=w[stk[h]],V[col]+=v[stk[h]],vis[stk[h]]=0;
		while(stk[h--]!=u);
	}
	return low;
}
int f[N][M],sz[N],rk[N];
void dfs(int u) {
	sz[u] = 1,rk[++ord] = u;
	for(int i=GT[u];i;i=T[i].nxt) {
		int v = T[i].dir;
		dfs(v),sz[u] += sz[v];
	}
}
int main() {
	scanf("%d%d",&n,&m);
	forn(i,1,n) scanf("%d",&w[i]);
	forn(i,1,n) scanf("%d",&v[i]);
	forn(i,1,n) scanf("%d",&d[i]),d[i]?(Add(d[i],i),0):0;
	forn(i,1,n) if(!dn[i]) tarjan(i);
	forn(u,1,n) for(int i=G[u];i;i=E[i].nxt) {
		int v = E[i].dir;
		if(clr[u]!=clr[v]) AddT(clr[u],clr[v]);
	}
	forn(u,1,col) if(!dT[u]) AddT(0,u);
	ord = 0,dfs(0);
	form(i,ord,1) { int u = rk[i];
		forn(j,0,m) {
			chkmax(f[i][j],f[i+sz[u]][j]);
			if(j>=W[u]) chkmax(f[i][j],f[i+1][j-W[u]]+V[u]);
		}
	}
	printf("%d\n",f[1][m]);
	return 0;
}
```

---

## 作者：JA_yichao (赞：1)

## 题目考点判断
- 有依赖的背包问题

## 解决过程
1. 判环
2. 缩点
3. dfs 套 DP

### 1.判环
Floyd 判环,如果 $k$ 到 $i$ 有一条路径且 $i$ 到 $j$ 有一条路径,就代表 $i$ 和 $j$ 是联通的。

```cpp
for(int i=1; i<=n; i++)   //以i为转载点
	 for(int j=1; j<=n; j++)
	  for(int k=1; k<=n; k++)
	   if(mapp[k][i]==1&&mapp[i][j]==1)
	     mapp[k][j]=1;
```
### 2. 缩点

#### 情况1.

 点 $i$ 所在的环之前没有判断过，是**新环**。
 那么，我们将这个新环放到**数组最后**，即新加一个点，
 然后让这两个点的空间标记为**负值** $tmpw$，且 $tmpw+tmpn$（新点的**下标**）**等于原来的点数**，
 这样，我们就可以通过某个点的空间迅速找到他所在的新点。
 像钥匙一样**一一对应**；

```cpp
if(mapp[i][j]==1&&mapp[j][i]==1&&i!=j&&w[j]>0&&w[i]>0)
 {
	jsn++;
	v[jsn]=v[i]+v[j];  //统计空间，价值
	w[jsn]=w[i]+w[j];
	jsw--;
	w[i]=jsw,w[j]=jsw;
 }
```

#### 情况2. 
点 $i$ 所在的环之前已经判断过了，
是**旧环（已合成新点）**，且 $i$ 是环的一部分。
那么我们就把 $i$ 也加到这个新点里面，
即**体积，价值相加**即可；
```cpp
  if(mapp[d[j]][j]==1&&mapp[j][d[j]]==1&&w[j]>0&&w[d[j]]<0)
	{
	  w[n-w[d[j]]]+=w[j]; //将当前点加入它依赖点所在的环
	  v[n-w[d[j]]]+=v[j];
	  w[j]=w[d[j]];
   }
```


#### 情况3. 
点 $j$ 所在的环是旧环，
但是 $i$ 不是环的一部分

`（例如1依赖2，2依赖3,3依赖1。4也依赖1，那么，4所在的是个环，但4不属于环的一部分）`。

那么，把 $j$ 的**父亲转到新点**上 $d[j]= n-w[d[j]]$。
```cpp
if(w[j]>0&&w[d[j]]<0)
 if((mapp[d[j]][j]==0&&mapp[j][d[j]]==1)||(mapp[d[j]][j]==1&&mapp[j][d[j]]==0))
	 d[j]=n-w[d[j]];
```


### 3.树形DP
以上缩点的工作做完之后，
剩下的就是**一棵树**。
就可以在这上面动规了：

先将其转换成一棵**左孩子右兄弟的二叉树**，
之后**记忆化**。

如果 $i$ 的孩子不取 ，则：

$f[b[x]][k]=dfs(b[x],k)$;

如果 $i$ 的孩子取，则：

$f[c[x]][y-i]=dfs(c[x],y-i);$

$f[b[x]][i]=dfs(b[x], i);$

$f[x][k]=\max(f[x][k],v[x]+f[c[x]][y-i]+f[b[x]][i]);$

最后答案是 $f[c[0]][m]$ （从没有依赖的点开始）


---

## 作者：suxxsfe (赞：1)

[欢迎到我的blog中参观](https://www.cnblogs.com/suxxsfe/p/12737529.html)  

tarjan+树上背包  

## 题目描述  

现在我们的手头有 $N$ 个软件，对于一个软件 $i$，它要占用 $W_i$ 的磁盘空间，它的价值为 $V_i$。我们希望从中选择一些软件安装到一台磁盘容量为 $M$ 计算机上，使得这些软件的价值尽可能大（即 $V_i$ 的和最大）。  
但是现在有个问题：软件之间存在依赖关系，即软件 $i$只有在安装了软件 $j$（包括软件 $j$ 的直接或间接依赖）的情况下才能正确工作（软件 $i$ 依赖软件 $j$ )。  
幸运的是，一个软件最多依赖另外一个软件。如果一个软件不能正常工作，那么它能够发挥的作用为 $0$。  
我们现在知道了软件之间的依赖关系：软件 $i$ 依赖软件 $D_i$。  
现在请你设计出一种方案，安装价值尽量大的软件。一个软件只能被安装一次，如果一个软件没有依赖则 $D_i=0$，这时只要这个软件安装了，它就能正常工作。  

-----------  

把依赖关系想象成有向边，由被依赖的软件指向依赖它的软件  
那么一个点能被选到的条件就是，它的祖先被选  
然后每个点都只有一个入度，还是有向边，所以如果没有环的话，这就是一个树！直接树上背包就能行了  

那么考虑用 tarjan 缩点，每个强连通分量中，每两个点都可以互相到达，而这个“互相到达”，放在这个题里就是**互相直接或间接的依赖**  
所以强连通分量里的点，如果**选就都选，不选就都不选**，这点很好理解  
那么缩点后的图就是树了吗？  

是的，对于一个强连通分量来讲，很显然，想要满足每两个点互相到达的要求，每个点都必须有它所在的这个强连通分量中，其它的点连过来的边（废话），那么，此时它的入度已经为一了，就不会再有这个强连通分量以外的点向这个点连边了  
所以，只有可能是这个强连通分量向外连边，而且是连到那种只有一个点的强连通分量中  

此时要把图缩完点的情况，每个强连通分量作为节点，重新连边  
那么同时构建一个虚拟节点，由它向没有入度的强联通分量连边，这个虚拟点的 $v,w$ 均为 $0$  
直接以这个虚拟节点为根做树上背包dp 就行了  

---------------  

简单说一下树上背包咋做  
$f_{u,i}$ 表示在 $u$ 这个点，用 $i$ 的硬盘限制，能获得的最大价值  
初始是 $f_{u,i}=v_u,i\in [w_u,m]$  
再分别枚举 $j\in [0,m-w_u]$ 表示对 **所有** 子树的限制，$k\in[0,k]$ 表示对 **当前** 子树的限制  

$$f_{u,j+w_u}=\max(f_{u,j+w_u},f_{v,k}+f_{u,j+w_u-k})$$  

这个转移方程也就很好理解了  

另外这个 $0-w_u<0$ 是有可能的，然后我用 `~j` 来判断它是不是等于 $-1$ 来结束循环节爆炸了  
~~我再也不用位运算了~~  

```cpp  
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<cmath>
#include<map>
#include<iomanip>
#include<cstring>
#define reg register
#define EN std::puts("")
#define LL long long
inline int read(){
	register int x=0;register int y=1;
	register char c=std::getchar();
	while(c<'0'||c>'9'){if(c=='-') y=0;c=std::getchar();}
	while(c>='0'&&c<='9'){x=x*10+(c^48);c=std::getchar();}
	return y?x:-x;
}
#define N 106
#define M 506
int fir[N],nex[N],to[N],tot;
int fir_[N],nex_[N],to_[N],tot_;
int dfn[N],low[N],dfscnt;
int scc[N],scccnt,indeg[N],sum_w[N],sum_v[N];
int stack[N],top;
int val[N],w[N];
int n,m;
int f[N][M];
inline void add(int u,int v){
	to[++tot]=v;
	nex[tot]=fir[u];fir[u]=tot;
}
inline void add_(int u,int v){
	to_[++tot_]=v;
	nex_[tot_]=fir_[u];fir_[u]=tot_;
}
void tarjan(int u){
	stack[top++]=u;low[u]=dfn[u]=++dfscnt;
	for(reg int v,i=fir[u];i;i=nex[i]){
		v=to[i];
		if(!dfn[v]){
			tarjan(v);
			low[u]=std::min(low[u],low[v]);
		}
		else if(!scc[v]) low[u]=std::min(low[u],dfn[v]);
	}
	if(dfn[u]==low[u]){
		scccnt++;
		do{
			scc[stack[--top]]=scccnt;
			sum_w[scccnt]+=w[stack[top]];sum_v[scccnt]+=val[stack[top]];
		}while(stack[top]!=u);
	}
}
inline void rebuild(){
	for(reg int i=1;i<=n;i++){
		for(reg int j=fir[i];j;j=nex[j])if(scc[i]!=scc[to[j]])
			add_(scc[i],scc[to[j]]),indeg[scc[to[j]]]=1;
	}
	for(reg int i=1;i<=scccnt;i++)if(!indeg[i]) add_(scccnt+1,i);
}
void dfs(int u){
	for(reg int i=sum_w[u];i<=m;i++) f[u][i]=sum_v[u];
	reg int v,mm;
	for(reg int i=fir_[u];i;i=nex_[i]){
		v=to_[i];mm=m-sum_w[u];
		dfs(v);
		for(reg int j=mm;j>=0;j--){//j对 所有 子树的限制 
			for(reg int k=0;k<=j;k++)//k是对 当前 子树的限制 
				f[u][j+sum_w[u]]=std::max(f[u][j+sum_w[u]],f[v][k]+f[u][j+sum_w[u]-k]);
		}
	}
}
int main(){
	n=read();m=read();
	for(reg int i=1;i<=n;i++) w[i]=read();
	for(reg int i=1;i<=n;i++) val[i]=read();
	for(reg int i=1,x;i<=n;i++){
		x=read();
		if(x) add(x,i);
	}
	for(reg int i=1;i<=n;i++)if(!dfn[i]) tarjan(i);
	rebuild();
//		EN;
//		for(reg int i=1;i<=scccnt;i++) std::printf("%d : %d	",i,fir_[i]);EN;
//		std::puts("new : ");
//		for(reg int i=1;i<=scccnt;i++){
//			std::printf("%d : ",i);
//			for(reg int j=fir_[i];j;j=nex_[j]) std::printf("%d ",to_[j]);
//			EN;
//		}
//		for(reg int i=1;i<=scccnt;i++) std::printf("%d %d\n",sum_v[i],sum_w[i]);
	dfs(scccnt+1);
	std::printf("%d",f[scccnt+1][m]);
	return 0;
}
```

---

## 作者：bugaile (赞：1)

题目大意:给你一个$n$物品,满足一些依赖关系,每个点有一个重量,以及一个价值,求在给定的重量之内所能得到的最大价值.

看题意,就是一个背包$dp$,再加上依赖关系,所以可以知道本题应该用树形背包$dp$来解决.

但这道题有一些不同,就是其给的依赖关系不一定构成一棵森林,而可能是一棵基环外向树森林.

但分析题意可知,对于一个环上的所有点,要么全部选,要么全不选,所以可以先跑一遍$Tarjan$算法将一个环缩成一个点来处理,再跑一遍树形背包dp即可.

时间复杂度:$O(NM^2)$,细节见代码注释.

``` cpp
#include<map>
#include<cstdio>
#include<iostream>
#define mp make_pair
using namespace std;
const int N=202;
const int M=505;

map<pair<int,int>,int>vi;

int w[N],v[N],b[N],f[N][M];

int n,m,dfn[N],low[N],cnt,cont;

int sta[N],vis[N],dg[N],tot,wei[N],val[N];

struct edge{
	int tt,to[N],nex[N],head[N];
	inline void add(int x,int y){
		to[++tt]=y;
		nex[tt]=head[x];
		head[x]=tt;
		return ;
	}
}po,sc;

void tarjan(int g){//tarjan跑强连通分量;
	dfn[g]=low[g]=++tot;
	sta[++cont]=g;
	vis[g]=1;
	for(int i=po.head[g],u;i;i=po.nex[i]){
		u=po.to[i];
		if(!dfn[u]){
			tarjan(u);
			low[g]=min(low[u],low[g]);
		}
		else
			if(vis[u])
				low[g]=min(low[g],dfn[u]);
	}
	if(dfn[g]==low[g]){
		int y;
		++cnt;
		do{
			y=sta[cont--];
			w[cnt]+=wei[y];//得到缩点后的新点的占用空间和价值;
			v[cnt]+=val[y];
			b[y]=cnt;
			vis[y]=0;
		}while(y!=g);
	}
	return ;
}

void dfs(int g){
	for(int i=sc.head[g],u;i;i=sc.nex[i]){
		u=sc.to[i];
		dfs(u);
		for(int j=m;j>=0;--j)
			for(int k=j;k>=0;--k)
				f[g][j]=max(f[g][j],f[g][j-k]+f[u][k]);//将子节点信息传递到当前点;
	}
	for(int i=m;i>=w[g];--i)
		f[g][i]=f[g][i-w[g]]+v[g];//只有当前点选,才能获得这棵子树的权值;
	for(int i=w[g]-1;i>=0;--i)
		f[g][i]=0;//对于无法选的部分要清空;
	return ;
}

int main(){
	
	cin>>n>>m;
	
	for(int i=1;i<=n;++i)
		cin>>wei[i];
	
	for(int i=1;i<=n;++i)
		cin>>val[i];
	
	int x;
	
	for(int i=1;i<=n;++i){
		cin>>x;
		if(x)
			po.add(x,i);
	}
	
	for(int i=1;i<=n;++i)
		if(!dfn[i])
			tarjan(i);
	
	for(int i=1;i<=n;++i){//缩点;
		for(int j=po.head[i],u;j;j=po.nex[j]){
			u=po.to[j];
			if(b[u]!=b[i]&&!vi[mp(b[i],b[u])]){//其实对于此题,并不需要判重边;
				sc.add(b[i],b[u]);
				++dg[b[u]];
				vi[mp(b[i],b[u])]=1;
			}
		}
	}
	
	for(int i=1;i<=cnt;++i)
		if(!dg[i])//将森林连成一棵树;
			sc.add(0,i);
	
	dfs(0);
	
	int ans=0;
	
	for(int i=0;i<=m;++i)
		ans=max(ans,f[0][i]);
	
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：木木！ (赞：1)

题解里好像都没有说明缩点后重建出来的图一定是一颗树qwq，我来感性证明一下。

首先，如果图是有向图，且每个节点入度都为1的话，那么最终形成的图一定是一个外向基环树森林。

感性证明一下，因为边数比点数多，最后一定有一个环（可能是自环），而这个环上的点都不可能被其他的点连（因为入度已经满了），所以必然是这个环上的点连其他的点（或者都不连，单独一个环算退化的基环树），被连的其他的点也必然不能被其他的点连（同样，入度也满了），所以必须继续连其他的或者不连。所以，最终形成的图必然是一颗外向的基环树。

但是这一题的`0`点没有入度（因为0不依赖任何软件），那么我们给`0`随机选择一条边连上去，形成一个外向基环树森林，然后分情况讨论：

1. `0`在某颗基环树的环上面，将边拆掉，基环树的环的剩余部分可以作为树上的一条链，就成为了以`0`为根的一颗外向树，特别的，自环也算（链的长度为`0`）
2. `0`在某颗基环树里面，将边拆掉，`0`及其子树部分单独形成一颗外向树。

所以，缩点前的图必然是一颗以`0`为根的外向树与若干外向基环树组成的森林。（几乎啥都可以退化，比如以`0`为根的外向树退化成单点之类的）

缩点后，所有环都被缩成一个点，于是形成了一个外向树森林。然后将所有除`0`之外的根节点连到`0`上，就形成了一颗大外向树，然后就可以愉快地树形`DP`了。

顺便一提，这样我们还可以导出一个骚操作，就是不记录度数，直接按强连通分量的大小决定是否连`0`，可以得到强连通分量内点数`>1`的入度一定为`0`（反之亦然，不过没啥用

附AC代码：

```cpp
#include <cstdio>
using namespace std;

void chkmax(int& a,int b)
{
	if(b>a)
	{
		a = b;
	}
}

void chkmin(int& a,int b)
{
	if(a>b)
	{
		a = b;
	}
}

int beg[105];
int cbeg[105];
int ed[205];
int nxt[205];
int top;

void addedge(int* beg,int a,int b)
{
	++top;
	ed[top] = b;
	nxt[top] = beg[a];
	beg[a] = top;
}

int dfn[105];
int low[105];
int stk[105];
int ins[105];
int ci[105];
int dfntop;
int stktop;
int ctop;

void tarjan(int x)
{
	++dfntop;
	++stktop;
	ins[x] = 1;
	stk[stktop] = x;
	low[x] = dfn[x] = dfntop;

	for(int p=beg[x]; p; p=nxt[p])
	{
		if(!dfn[ed[p]])
		{
			tarjan(ed[p]);
			chkmin(low[x],low[ed[p]]);
		}
		else if(ins[ed[p]])
		{
			chkmin(low[x], low[ed[p]]);
		}
	}

	if(low[x] == dfn[x])
	{
		++ctop;
		while(stk[stktop] != x)
		{
			ci[stk[stktop]] = ctop;
			ins[stk[stktop]] = 0;
			--stktop;
		}
		ci[x] = ctop;
		ins[x] = 0;
		--stktop;
	}
}

int wi[105];
int vi[105];

int m;
int dp[105][505];

int cwi[105];
int cvi[105];
int cinum[105];

int tmp[505];

void tdp(int x)
{
	if(cwi[x]>m)
		return;

	for(int p=cbeg[x]; p; p=nxt[p])
	{
		tdp(ed[p]);
	}

	for(int j=0; j<=m; ++j)
	{
		tmp[j] = 0;
	}

	for(int p=cbeg[x]; p; p=nxt[p])
	{
		for(int j=0; j<=m; ++j)
		{
			for(int k=0; k+j<=m; ++k)
			{
				chkmax(dp[x][j+k], tmp[j]+dp[ed[p]][k]);
			}
		}
		for(int i=0; i<=m; ++i)
		{
			tmp[i] = dp[x][i];
		}
	}

	for(int i=m; i>=cwi[x]; --i)
	{
		dp[x][i] = dp[x][i-cwi[x]]+cvi[x];
	}
	for(int i=cwi[x]-1; i>=0; --i)
	{
		dp[x][i] = 0;
	}
}

int main()
{
	int n;
	scanf("%d%d",&n,&m);
	for(int i=1; i<=n; ++i)
	{
		scanf("%d",wi+i);
	}
	for(int i=1; i<=n; ++i)
	{
		scanf("%d",vi+i);
	}
	for(int i=1; i<=n; ++i)
	{
		int x;
		scanf("%d",&x);
		addedge(beg,x,i);
	}

	for(int i=1; i<=n; ++i)
	{
		if(!dfn[i])
		{
			tarjan(i);
		}
	}

	for(int i=1; i<=n; ++i)
	{
		cwi[ci[i]] += wi[i];
		cvi[ci[i]] += vi[i];
		++cinum[ci[i]];

		for(int p=beg[i]; p; p=nxt[p])
		{
			if(ci[ed[p]] != ci[i])
			{
				addedge(cbeg,ci[i],ci[ed[p]]);
			}
		}
	}
	for(int i=1; i<=ctop; ++i)
	{
		if(cinum[i] > 1)
		{
			addedge(cbeg,0,i);
		}
	}
	for(int p=beg[0]; p; p=nxt[p])
	{
		addedge(cbeg,0,ci[ed[p]]);
	}

	tdp(0);

	printf("%d\n",dp[0][m]);
}
```

---

## 作者：k，火魂 (赞：1)

因为题目中限制了每个文件最多依赖一个文件，所以可以证明（这个东西读者自证不难,嘿嘿）：从每个文件的D[i]向i连一条有向边，要么形成一个圈，要么形成一个树。（这个可以使我们重建图的时候少一些考虑情况），这样首先tarjan缩点，所有的圈都变成一个点，而树没有变。从0点向每一个入度为0的点建一条有向边之后就是一个很典型的树形背包问题（如果不会树形背包请移步，当然我的博客里也有树形背包的很简短的解释）。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int N=110;
bool ins[N];
int st[N],dfn[N],low[N],bl[N];
int w[N],val[N];
int v1[N],v2[N];
int ver[2*N],hea[N],nex[2*N];
int n,m,num,tot,top,cnt,ans;
int dp[N][1010];
int size[N],du[N];
int x[N],p[N];

inline void clear(){
	memset(hea,0,sizeof(hea));
	tot=0;
}

inline void add(int x,int y){
	ver[++tot]=y;nex[tot]=hea[x];hea[x]=tot;
}

inline void tr(int x){
	dfn[x]=low[x]=++cnt;
	st[++top]=x;ins[x]=1;
	for(int i=hea[x];i;i=nex[i]){
		int y=ver[i];
		if(!dfn[y]){
			tr(y);
			low[x]=min(low[y],low[x]);
		}
		else if(ins[y])low[x]=min(low[x],low[y]);
	}
	if(dfn[x]==low[x]){
		num++;
		while(st[top+1]!=x){
			int y=st[top--];
			ins[y]=0;bl[y]=num;
			v2[num]+=v1[y];val[num]+=w[y];
		}
	}
}

inline void tp(int x){
	for(int i=hea[x];i;i=nex[i]){
		int y=ver[i];
		add(x,y);tp(y);
	}
}

inline void dfs(int x){
	size[x]=p[x]=val[x];dp[x][val[x]]=v2[x];dp[x][0]=0;
	for(int i=hea[x];i;i=nex[i]){
		int y=ver[i];
		dfs(y);
		for(int j=min(size[x],m);j>=p[x];j--){
			for(int k=0;k<=size[y]&&j+k<=m;k++){
				dp[x][j+k]=max(dp[x][j]+dp[y][k],dp[x][j+k]);
			}
		}
		size[x]+=size[y];
	}
}

int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){scanf("%d",&w[i]);}
	for(int i=1;i<=n;i++){scanf("%d",&v1[i]);}
	for(int i=1;i<=n;i++){
		int xx;scanf("%d",&xx);
		if(xx==0)continue;
		add(xx,i);x[i]=xx;
	}
	for(int i=1;i<=n;i++){
		if(!dfn[i])tr(i);
	}
	clear();
	for(int i=1;i<=n;i++){
		if(x[i]==0)continue;
		int fx=bl[x[i]],fy=bl[i];
		if(fx==fy)continue;
		else {
			add(fx,fy);
			du[fy]++;
		}
	}
	for(int i=1;i<=num;i++){
		if(du[i]==0){
			add(0,i);
		}
	}
	memset(dp,0xcf,sizeof(dp));
	dfs(0);
	for(int i=0;i<=min(m,size[0]);i++){
		ans=max(ans,dp[0][i]);
	}
	printf("%d",ans);
	return 0;
}
```


---

## 作者：leozhang (赞：1)

非常好的一道题，可以说是树形dp的一道基础题

首先不难发现，：如果我们把有关系的两个点用有向边相连，那么就会形成一个接近树的结构。如果这是一棵完美的树，我们就可以直接在树上打背包了

但是这并不是一棵完美的树，甚至并不是一棵树，因为：

首先，由于题中有n个点，还有n条边，所以有很大的几率出现环！

而且，如果出现了环，那么很有可能整个图并不连通，这样一来根本无法跑dp

所以我们要采取一些策略：

首先，对于出现环的情况，根据题意，此时环中的所有点要么都选，要么都不选，所以我们可以进行tarjan缩点，然后在新图上进行dp

至于整个图不连通的情况，我们可以虚拟一个超级原点向所有入度为0的点连边，这样就可以形成一棵真正的树，这样跑树形dp就可以了。

```cpp
#include <cstdio>
#include <cmath>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <algorithm>
#include <queue>
#include <stack>
using namespace std;
struct Edge
{
    int next;
    int to;
}edge[105],e[105];
int head[105];
int h[105];
int cot=1;
int cnt=1;
void init()
{
    memset(head,-1,sizeof(head));
    memset(h,-1,sizeof(h));
    cnt=1;
    cot=1;
}
void adde(int l,int r)
{
    e[cot].next=h[l];
    e[cot].to=r;
    h[l]=cot++;
}
void add(int l,int r)
{
    edge[cnt].next=head[l];
    edge[cnt].to=r;
    head[l]=cnt++;
}
int n,m;
int w[105];
int v[105];
int nv[105];
int nw[105];
int posi[105];
int src_cnt=0;
int src_num[105];
int my_stack[105];
int dfn[105];
int low[105];
int dp[105][505];
int tot=0;
int ttop=0;
bool used[105];
int s[105];
void tarjan(int rt)
{
    my_stack[++ttop]=rt;
    dfn[rt]=low[rt]=++tot;
    for(int i=head[rt];i!=-1;i=edge[i].next)
    {
        int to=edge[i].to;
        if(!dfn[to])
        {
            tarjan(to);
            low[rt]=min(low[rt],low[to]);
        }else if(!posi[to])
        {
            low[rt]=min(low[rt],dfn[to]);
        }
    }
    if(dfn[rt]==low[rt])
    {
        int t=0;
        src_cnt++;
        while(t!=rt)
        {
            t=my_stack[ttop--];
            posi[t]=src_cnt;
            src_num[src_cnt]++;
            nv[src_cnt]+=v[t];
            nw[src_cnt]+=w[t];
        }
    }
}
void dfs(int x)
{
    s[x]=nw[x];
    dp[x][nw[x]]=nv[x];
    for(int i=h[x];i!=-1;i=e[i].next)
    {
        int to=e[i].to;
        dfs(to);
        for(int j=s[x];j>=nw[x];j--)
        {
            for(int k=0;k<=s[to];k++)
            {
                if(j+k>m)
                {
                    break;
                }
                dp[x][j+k]=max(dp[x][j+k],dp[x][j]+dp[to][k]);
            }
        }
        s[x]+=s[to];
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    init();
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&w[i]);
    }
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&v[i]);
    }
    for(int i=1;i<=n;i++)
    {
        int f;
        scanf("%d",&f);
        if(f)
        {
            add(f,i);
        }
    }
    for(int i=1;i<=n;i++)
    {
        if(!dfn[i])
        {
            tarjan(i);
        }
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=head[i];j!=-1;j=edge[j].next)
        {
            int to=edge[j].to;
            if(posi[to]!=posi[i])
            {
                adde(posi[i],posi[to]);
                used[posi[to]]=1;	
            }
        }
    }
    for(int i=1;i<=src_cnt;i++)
    {
        if(!used[i])
        {
            adde(0,i);
        }
    }
    dfs(0);
    int ans=0;
    for(int i=0;i<=m;i++)
    {
        ans=max(ans,dp[0][i]);
    }
    printf("%d\n",ans);
    return 0;
}

```


---

## 作者：JustinRochester (赞：1)

因为个人原因，不是很爱开很多全局变量，因此不是很爱用 tarjan ......

~~嗯，真香~~

---

**【分析】**
--

题目中说的应该挺清楚了，就是有的软件需要安装了它的依赖软件才有意义

根据贪心策略，显然，要安装了它的依赖软件再考虑安装这个软件才有意义

那我们这么考虑：把每个软件抽象成一个点，它有依赖的软件就连一条从依赖软件指向自己的边

你会发现，如果数据恰巧凑好的话(比如样例)，这就是一棵树

而且根据这个树的性质，我们一定要对父节点安装了，对它的子节点的安装才有意义

你以为这就完了吗......

我当时还真这么以为......

考虑到一个特殊情况

三个软件 $a,b,c$，满足 $a\to b,b \to a,c \to a$

显然，这就是符合题目条件的

但是，这个时候，安装 $a$ 则必然要安装 $b$ ，安装 $b$ 则必然要安装 $a$

那对于这种情况，我们可以直接理解为，要么 $a,b$ 都安装，要么都不安装

那实际上 $a,b$ 就已经是一个整体了，我们可以用缩点把它们当成一个点考虑

根据这种性质，题目中说不定会给定多个强连通分量，导致我们缩点后变成森林

那我们可以这么处理：

正如样例中，没有依赖软件的 $D$ 值为 $0$ ，那我们就假设所有强连通分量的 $D$ 值也为 $0$。(每个软件只有一个依赖软件，因此强连通分量不存在指出边)

接着，我们把 $0$ 视为一个 $W=0,V=0$ 的节点

这样，所有原本的根就都变为了 $0$ 这个节点的子节点

只要以 $0$ 为根，做一次 树形$DP$ 就好了

---

**【代码】**
--

那本蒟蒻就放~~我那码风极丑的~~代码了

有看不懂的可以直接艾特我

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
#define f(a,b,c) for(register int a=b;a<=c;a++)
#define g(a,b,c) for(register int a=b;a>=c;a--)
#define Max(a,b) ((a>b)?a:b)
#define Min(a,b) ((a<b)?a:b)
typedef long long int ll;
typedef unsigned long long int ull;
const int MAXN=110;
typedef ll ar[MAXN];
inline ll read(){
    register ll ans=0;register char c=getchar();register bool neg=0;
    while((c<'0')|(c>'9')) neg^=!(c^'-'),c=getchar();
    while((c>='0')&(c<='9')) ans=(ans<<3)+(ans<<1)+(c^'0'),c=getchar();
    return neg?-ans:ans;
}//以上都是条件反射的结果 
int N=0,M,Cnt=0,Cur=0;
ar Low,DFN,Set,Stack;
bool Ins[MAXN];
//N 强连通分量数，M 磁盘内存 ，Cur 栈的指针
//Set 属于的强连通分量序号，Ins 是否在栈中，其他应该都好理解 
struct Edge{
	int To;
	Edge *Next;
	Edge(int To,Edge *Next):To(To),Next(Next) {}
}*E[MAXN];
struct Node{
	int W,V,Pa,Kid,Bro;//Bro 兄弟 
	Node() { W=V=Pa=0; Kid=Bro=-1; }
}Tree[MAXN];
void tarjan(int p){//缩点 
	Stack[++Cur]=p;
	Low[p]=DFN[p]=++Cnt;
	for(Edge *Vec=E[p];Vec;Vec=Vec->Next)
		if(Set[Vec->To]) continue;
		else if(Ins[Vec->To]) Low[p]=Min(Low[p],Low[Vec->To]);
		else{
			Ins[Vec->To]=1;
			tarjan(Vec->To);
			Ins[Vec->To]=0;
			Low[p]=Min(Low[p],Low[Vec->To]);
		}
	if(Low[p]==DFN[p]){
		N++;
		while(Stack[Cur]!=p)
			Set[Stack[Cur]]=N,Cur--;
		Set[p]=N;
		Cur--;
	}
}
void pre(){
	int tmpN;
	ar tmpW,tmpV,tmpD;
	memset(tmpW,0,sizeof(tmpW));
	memset(tmpV,0,sizeof(tmpV));
	memset(tmpD,0,sizeof(tmpD));
	tmpN=read(); M=read();
	f(i,1,tmpN) tmpW[i]=read();
	f(i,1,tmpN) tmpV[i]=read();
	f(i,1,tmpN) tmpD[i]=read(),E[tmpD[i]]=new Edge(i,E[tmpD[i]]);//连边 
	f(i,1,tmpN) if(!Set[i]) Ins[i]=1,tarjan(i),Ins[i]=0;
	f(i,1,tmpN){
		//将强连通分量归为一个整体 
		Tree[Set[i]].W+=tmpW[i];
		Tree[Set[i]].V+=tmpV[i];
		if(!tmpD[i]) continue;
		//有的点本身 D 值就为 0 ，特判掉，不然会出错 
		if(Set[tmpD[i]]!=Set[i]){
			Tree[Set[i]].Pa=Set[tmpD[i]];
			Tree[Set[i]].Bro=Tree[Set[tmpD[i]]].Kid;
			Tree[Set[tmpD[i]]].Kid=Set[i];
		}
	}
	//森林变为树 
	f(i,1,N) if(!Tree[i].Pa){
		Tree[i].Bro=Tree[0].Kid;
		Tree[0].Kid=i;
	}
}
int Dp[110][510]={0};
void dp(int p){
	if(Tree[p].Kid>0) dp(Tree[p].Kid); 
	if(Tree[p].Bro>0) dp(Tree[p].Bro);
	//先遍历孩子和兄弟 
	f(i,0,M){
		if(Tree[p].Bro>0) Dp[p][i]=Dp[ Tree[p].Bro ][i];//不安装自己的情况 
		f(j,Tree[p].W,i){//安装自己的情况 
			int tmpk=(Tree[p].Kid>0)?Dp[ Tree[p].Kid ][ j-Tree[p].W ]:0;
			int tmpb=(Tree[p].Bro>0)?Dp[ Tree[p].Bro ][ i-j ]:0;
			Dp[p][i]=Max(Dp[p][i],tmpk+tmpb+Tree[p].V);
		}
	}
}
int main(){
	pre();
	dp(0);
	printf("%d",Dp[0][M]);
	return 0;
}
```

---

## 作者：aiyougege (赞：1)

#### OOP
emm……实际上这种树形dp(背包)的题目都比较套路.

但是写一个缩点重构图在加上一个树形dp, 各种变量搞的我头都大了, 以前经常有调各种写错的变量名很长时间的经历.
(以前都用`namespace`.

于是, 我写了一个**假的**OOP（面向对象）, 强行封装.
- 这个对象和**继承**可能不是很好理解, 可以baidu一下看看.
- 没写虚函数, 因为不是太会而且没必要.
- 中间还涉及到一些例如类指针,分配空间的事情.

这个东西的缺点比较显然就是**效率比较差**.

(~~**我的代码吸收了OOP的缺点并抛弃了它的优点**~~)

1. 写了一个类`Graph`, 有图的各种变量和加边函数和打印图的函数.
2. 写了一个类`Graph1`从`Graph`继承过来, 负责缩点重构图.
3. 写了一个类`Tree1`从`Graph`继承过来, 负责做树形dp(背包)的活.

#### Solution
我们发现所有的依赖关系构成一张图, 其中$u$到$v$的边意味着安装$v$代表的软件必须安装$u$.

但是注意可能有也就是安装$u$必须安装$v$同时安装$v$必须安装$u$的情况……

扩展一下, 可能会遇到一种更神奇的情况, 例如$u\rightarrow v,v\rightarrow w,\cdots,p\rightarrow u$.这种情况下构成了一个环, 这种情况就需要环上的软件全部安装.

那么就可以将图**缩点重构**这样图就变成了一个$DAG$（无根树）, 然后将所有单独的联通块的**根**(入度为0的点)连到一个0上.这样就可以利用树形dp去解决了.

类似的树形dp还有[https://www.luogu.org/problemnew/show/P2014](选课)
#### Code
代码写的很丑请见谅
```c++
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#define N 105
#define M 505
using std::min;
using std::max;
using std::fill;

void* operator new(size_t sz){
    return (void*)malloc(sz);
}
struct Edge{int v,nxt;};
class Graph{
    public:
    Edge e[M<<2];
    int n,head[N],tot;
    void AddEdge(int a,int b){
        e[++tot]=(Edge){b,head[a]},head[a]=tot;
    }
    void print(){
        printf("This a Graph\n");
        printf("The number of Point: %d\n",n);
        for(int i=1;i<=n;++i){
            printf("%d: ",i);
            for(int j=head[i];j;j=e[j].nxt)
                printf("%d ",e[j].v);
            printf("\n");
        }
        printf("\n");
    }
};
class Tree1:public Graph{
    public:
    int val[N],v[N];
    Tree1(int _n=0){
        n=_n,tot=0;
        fill(head,head+N,0);
        fill(v,v+N,0);
        fill(val,val+N,0);
    }
    void GetSon(int x);
    int BagProOnTheTree1();
}t;
class Graph1:public Graph{
    public:
    Graph1(int _n){
        n=_n,tot=col_=tim=top=0;
        fill(head,head+N,0);
        fill(dfn,dfn+N,0);
    }
    int dfn[N],low[N],tim;
    int vis[N],top,que[N];
    int col[N],col_;
    void Tarjan(int x){
        dfn[x]=low[x]=++tim,
        que[++top]=x,vis[x]=true;
        for(int i=head[x];i;i=e[i].nxt){
            if(!dfn[e[i].v])
                Tarjan(e[i].v),low[x]=min(low[x],low[e[i].v]);
            else if(vis[e[i].v])
                low[x]=min(low[x],dfn[e[i].v]);
        }
        if(dfn[x]==low[x]){
            col[x]=++col_,vis[x]=false;
            while(que[top]!=x)
                vis[que[top]]=false,col[que[top--]]=col_;
            --top;
        }
    }
    Tree1* NewGraph();
};
int val[N],v[N],du[N];
Tree1* Graph1::NewGraph(){
    for(int i=1;i<=n;++i)
        if(!dfn[i])
            Tarjan(i);
    Tree1* o=new Tree1;
    o->n=col_;
    for(int i=1;i<=n;++i)
        o->v[col[i]]+=v[i],
        o->val[col[i]]+=val[i];
    for(int i=1;i<=n;++i)
        for(int j=head[i];j;j=e[j].nxt)
            if(col[i]!=col[e[j].v])
                o->AddEdge(col[i],col[e[j].v]),++du[col[e[j].v]];
    for(int i=1;i<=col_;++i)
        if(!du[i])
            o->AddEdge(0,i);
    return o;
}
int m;
int f[N][M];
void Tree1::GetSon(int x){
    for(int i=v[x];i<=m;++i)f[x][i]=val[x];
    for(int i=head[x];i;i=e[i].nxt){
        GetSon(e[i].v);
        for(int j=m-v[x];j>-1;--j)
            for(int l=0;l<=j;++l)
                f[x][j+v[x]]=max(f[x][j+v[x]],
                f[x][j+v[x]-l]+f[e[i].v][l]);
    }
}
int Tree1::BagProOnTheTree1(){
    int ans=0;
    GetSon(0);
    for(int i=1;i<=m;++i)
        ans=max(f[0][m],ans);
    return ans;
}
int main(){
    int n,t;
    scanf("%d%d",&n,&m);
    Graph1 G=Graph1(n);
    for(int i=1;i<=n;++i)
        scanf("%d",&v[i]);
    for(int i=1;i<=n;++i)
        scanf("%d",&val[i]);
    for(int i=1;i<=n;++i){
        scanf("%d",&t);
        G.AddEdge(t,i);
    }
    Tree1* T=G.NewGraph();
    printf("%d",T->BagProOnTheTree1());
    return 0;
}
```

---

## 作者：Maktub (赞：1)

这个题是很有意思的，乍一看就是道树形背包，仔细一想有环。有环的时候环中的软件要么都安要么都不安，很容易想到tarjan缩点。

我们在读入数据后先缩点，然后建立新图，在建新图的时候统计入度，将入度为0的点与虚点0连边，这样构成一棵树，进行树形背包操作就可以。

注意：一定要在缩点后再与虚点0连边，否则会出错，得40分。
因为在读入数据的时候连的话，环就不会如虚点连边的。

代码：

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
#define ll long long
inline int read(){
    int x=0,f=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-f;c=getchar();
    }
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();
    }
    return x*f;
}
const int mx=1001;
int h[mx],a[mx],s[mx],w[mx],W[mx],de[mx];
int dfn[mx],low[mx],co[mx],st[mx];
int top,col,p,n,m,num;
int h1[mx],p1;
int f[111][555];
struct edge{
    int next , v;
}e[mx],e1[mx];
inline void add(int a,int b){
    p++;e[p].next=h[a];h[a]=p;e[p].v=b;
} 
inline void add1(int a,int b){
    p1++;e1[p1].next=h1[a];h1[a]=p1;e1[p1].v=b;
}
//-------
inline void tarjan(int u){
    dfn[u]=low[u]=++num;
    st[++top]=u;
    for(int i=h[u];i;i=e[i].next){
        int v=e[i].v;
        if(!dfn[v]){
            tarjan(v);
            low[u]=min(low[u],low[v]);
        }
        else if(!co[v]){
            low[u]=min(low[u],dfn[v]);
        }
    }//ok
    
    if(low[u]==dfn[u]){
        ++col;
        while(st[top+1]!=u){
            co[st[top]]=col;
            s[col]+=a[st[top]];
            W[col]+=w[st[top]];
            top--;
        }
    }//ok
}
inline void dp(int u){
    for(int i=0;i<=W[u];i++)f[u][i]=0;
    for(int i=h1[u];i;i=e1[i].next){
        int v=e1[i].v;
        dp(v);
        for(int t=m;t>=W[v];t--){
            for(int j=t;j>=W[v];j--){
                f[u][t]=max(f[u][t],f[u][t-j]+f[v][j]);
            }
        }
    }
    if(u!=0){
        for(int t=m;t>=W[u];t--)f[u][t]=f[u][t-W[u]]+s[u];
    }
}
int main(){
    n=read();m=read();
    for(int i=1;i<=n;i++)w[i]=read();
    for(int i=1;i<=n;i++)a[i]=read();
    for(int i=1,u;i<=n;i++){
        u=read();
        if(u==0)continue;
        add(u,i);
    }//ok
    
    for(int i=1;i<=n;i++)if(!dfn[i])tarjan(i);//ok
    //for(int i=1;i<=col;i++)cout<<W[i]<<' ';return 0;
//	cout<<h[0];return 0;
    for(int i=1;i<=n;i++){
        for(int j=h[i];j;j=e[j].next){
            int v=e[j].v;
            if(co[i]!=co[v])add1(co[i],co[v]),de[co[v]]++;
        }
    }
    for(int i=1;i<=col;i++){
        if(!de[i])add1(0,i);
    }
    dp(0);
    printf("%d\n",f[0][m]);return 0;
}

```


---

## 作者：安好 (赞：1)

/\*
开始一看这不是个基础的树型动规吗?(知道基础,但我不会啊),但是一看还有环嘞,苦逼了...

根据依赖关系可以画出来一张图，有三种可能的情况：

1.依赖关系构成一棵树。

2.依赖关系构成一个环。

3.依赖关系构成一个环下面吊着一棵树。

因为有2,3这些情况，所以要先有tarjan预处理一下，缩环为点，重新建图。

对于建好的图，跑一边树形背包即可，思想类似于01背包

f[x][tot]表示以x为根，容量为tot的最大收益。把x的各个子树看成物品

再枚举每个子树所分给的容量,tot从大到小转移。

\*/






```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int n,m,cnt,scc,ind,top,num;
int v[105],w[105];
int sv[105],sw[105];bool in_stack[105];
int dfn[105],low[105],belong[105];
int stack[105],f[105][505],in[505],head[505],head2[505];
struct node
{
    int from;
    int to;
    int next;
}e[1010],e2[1010];
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
inline void insert(int from,int to)
{
    e[++num].from=from;
    e[num].to=to;
    e[num].next=head[from];
    head[from]=num;
}
inline void insert2(int from,int to)
{
    in[to]=1;
    e2[++num].from=from;
    e2[num].to=to;
    e2[num].next=head2[from];
    head2[from]=num; 
}
void Tarjan(int u)
{
    int now=0;
    dfn[u]=low[u]=++ind;
    stack[++top]=u;
    in_stack[u]=1;
    for(int i=head[u];i;i=e[i].next)
    {
        int v=e[i].to;
        if(!dfn[v])
        {
            Tarjan(v);
            low[u]=min(low[u],low[v]);
        }
        else if(in_stack[v]) low[u]=min(low[u],dfn[v]);
    }
    if(low[u]==dfn[u])
    {
        scc++;
        while(now!=u)//统计环 
        {
            now=stack[top--];in_stack[now]=0;
            belong[now]=scc;
            sw[scc]+=w[now];
            sv[scc]+=v[now];
        }
    }
}
void rebuild()//重建图 
{
    num=0;
    for(int x=1;x<=n;x++)
      for(int i=head[x];i;i=e[i].next)
      {
          int v=e[i].to;
          if(belong[v]!=belong[x])
            insert2(belong[x],belong[v]);
      }
}
void dp(int x)
{
    for(int i=head2[x];i;i=e2[i].next)
    {
        dp(e2[i].to);
        for(int j=m-sw[x];j>=0;j--) 
        {
            for(int k=0;k<=j;k++)//枚举子树的的限制。
                f[x][j]=max(f[x][j],f[x][k]+f[e2[i].to][j-k]);        
        }
    }
    for(int j=m;j>=0;j--)//完全背包 
    {
        if(j>=sw[x])f[x][j]=f[x][j-sw[x]]+sv[x];
        else f[x][j]=0;
    }
}
int main()
{
    n=read();m=read();
    for(int i=1;i<=n;i++)w[i]=read();
    for(int i=1;i<=n;i++)v[i]=read();
    for(int i=1;i<=n;i++)
    {
        int x=read();
        if(x)insert(x,i);
    }
    for(int i=1;i<=n;i++)
        if(!dfn[i])Tarjan(i);
    rebuild();
    for(int i=1;i<=scc;i++)
        if(!in[i])
            insert2(scc+1,i);//这个地方要加1,因为根节点属于新的环。（不确定） 
    dp(scc+1);
    printf("%d\n",f[scc+1][m]);
    return 0;
}
```

---

## 作者：Jerrywang09 (赞：0)

这题出得很好，考察的内容很多样。

容易把本题与“选课”相联系，都是树上背包。

但是需要注意一个问题：题中给定的依赖关系是一个基环树森林！如果要安装一个环中的任意一个软件，则这个环上所有软件都要安装了。因此可以强连通缩点。由于原图是一个基环树森林，因此缩点后的 DAG 其实是一棵树。先缩点，然后再建出虚点 $0$，连向每棵树的树根。

考虑树形背包 DP，设 $f(i,j)$ 表示以 $i$ 为根的子树，$i$ 上的软件必须要安装，一共安装的存储是 $j$ 的最大收益。首先，先加入每个点上的软件；然后再向子树 DP，背包合并各子树的状态。注意这里最好开辅助数组 `tmp`，这是一个好习惯，因为这样能绝对保证转移的有序性，而且不用考虑正着循环或是倒着循环！

```cpp
// P2515 [HAOI2010] 软件安装
#include <cstdio>
#include <iostream>
#include <vector>
#include <cstring>
#define ll long long
#define rep(i, s, t) for(int i=s; i<=t; ++i)
#define debug(x) cerr<<#x<<":"<<x<<endl;
const int N=105, M=505; int inf=0x3f3f3f3f;
using namespace std;
char buf[1<<21], *p1=buf, *p2=buf;
#define gc() (p1==p2 && (p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
inline int read()
{
    int x=0, f=1; char c=gc();
    while(c<'0' || c>'9') c=='-' && (f=-1), c=gc();
    while('0'<=c && c<='9') x=(x<<3)+(x<<1)+c-'0', c=gc();
    return x*f;
}

int n, W, w[N], v[N], Ws[N], Vs[N];
vector<int> g[N], g1[N];
int f[N][M], tmp[M], indeg[N];
void dfs(int u, int fa)
{
    if(Ws[u]<=W) f[u][Ws[u]]=Vs[u];
    for(int v:g1[u]) if(v!=fa)
    {
        dfs(v, u);
        rep(i, 0, W) tmp[i]=f[u][i];
        rep(i, 0, W) rep(j, 0, W-i)
            tmp[i+j]=max(tmp[i+j], f[u][i]+f[v][j]);
        rep(i, 0, W) f[u][i]=tmp[i];
    }
}

int dfn[N], low[N], tim, scc, stk[N], top, c[N]; bool in[N];
void tarjan(int u)
{
    dfn[u]=low[u]=++tim, stk[++top]=u, in[u]=1;
    for(int v:g[u])
    {
        if(!dfn[v]) tarjan(v), low[u]=min(low[u], low[v]);
        else if(in[v]) low[u]=min(low[u], dfn[v]);
    }
    if(dfn[u]==low[u])
    {
        int v=-1; ++scc;
        while(v!=u)
        {
            v=stk[top--], in[v]=0;
            c[v]=scc, Ws[scc]+=w[v], Vs[scc]+=::v[v];
        }
    }
}

int main()
{
#ifdef Jerrywang
    freopen("E:/OI/in.txt", "r", stdin);
#endif
    n=read(), W=read();
    rep(i, 1, n) w[i]=read();
    rep(i, 1, n) v[i]=read();
    rep(i, 1, n)
    {
        int fa=read(); if(fa) g[fa].push_back(i);
    }
    rep(i, 1, n) if(!dfn[i]) tarjan(i);
    rep(u, 0, n)
    {
        for(int v:g[u]) if(c[u]!=c[v])
            g1[c[u]].push_back(c[v]), ++indeg[c[v]];
    }
    rep(i, 1, scc) if(!indeg[i]) g1[0].push_back(i);
    memset(f, -0x3f, sizeof f);
    dfs(0, -1);
    int res=-inf;
    rep(i, 0, W) res=max(res, f[0][i]);
    printf("%d", res);

    return 0;
}
```

---

## 作者：BeautyYu言醴 (赞：0)

如果不考虑依赖关系环的话本题可以得到40分

具体做法就是在树上做一次背包dp.引用`<背包九讲>`的`泛化物品`概念,物品本身可以视作一个`weight`对应`value`的函数.只要枚举为每件物品提供的`weight`后取最优即可.本题中'物品'指的就是树上的一颗子树

接着考虑依赖关系环的问题.对于一个环要么全部取走,获得全部价值和,消耗全部费用和 ; 要么一个都不取.显然这里应该`tarjan`缩点.因为保证每个点的入度为1,所以**一个环缩点之后一定是树上的根**.最后将森林上的每个根都挂向`0`节点,形成一颗树即可

代码如下.蒻的英语不好请见谅

```c++
//by:beautyyu
#include <iostream>
#include <cstdio>
#include <string>
#include <cstring>
#include <algorithm>
#include <cmath>
#define ull unsigned long long
using namespace std;
struct edge
{
	int v, nxt;
}e[5000];
int head[5000],memf[5000][1000],memd[5000][1000];
//'memd' -- memory for function 'd','memf' -- memory for function 'f'
int w[5000],v[5000];
int d(int al,int be);
int f(int al,int be);
//tarjan begin
int sta[5000],top = 0;bool insta[5000];//stack
int dfn[5000],low[5000],bl[5000],bcnt = 0,c = 0;
void tarjan(int k){
	dfn[k] = low[k] = ++ c;
	insta[sta[++ top] = k] = 1;
	for (int i = head[k];i;i = e[i].nxt){
		int &ev = e[i].v;
		if (!dfn[ev]){
			tarjan(ev);
			low[k] = min(low[k],low[ev]);
		}
		else if (insta[ev])
			low[k] = min(low[k],dfn[ev]);
	}
	if (low[k] == dfn[k]){
		++ bcnt;
		do insta[sta[top]] = 0,bl[sta[top --]] = bcnt;
		while(sta[top + 1] != k);
	}
	return ;
}
//tarjan end

int main (){
	int n,m;
	//read gragh
	cin >> n >> m;
	int de[5000],be[5000],ge[5000];
	for (int i = 1;i <= n;++ i)
		scanf("%d",&de[i]);
	for (int i = 1;i <= n;++ i)
		scanf("%d",&be[i]);
	int al,cnt = 0;
	for (int i = 1;i <= n;++ i){
		scanf("%d",&al);
		ge[i] = al;
		e[++ cnt] = edge{i,head[al]};
		head[al] = cnt;
	}
	//read gragh end
	for (int i = 1;i <= n;++ i)
		if(!dfn[i]) tarjan(i);
	//build new tree
	for (int i = 1;i <= n;++ i)
		w[bl[i]] += de[i],
		v[bl[i]] += be[i];
	memset(head,0,sizeof(head));
	memset(e,0,sizeof(e));
	cnt = 0;
	bool havefather[5000];
	for (int i = 1;i <= n;++ i)
		if (bl[i] != bl[ge[i]])
			e[++ cnt] = edge{bl[i],head[bl[ge[i]]]},
			head[bl[ge[i]]] = cnt,
			havefather[bl[i]] = 1;
	n = bcnt;
	for (int i = 1;i <= n;++ i)
		if(!havefather[i])
			e[++ cnt] = edge{i,head[0]},
			head[0] = cnt;
	//build new tree end
	memset(memd,-1,sizeof(memd));
	memset(memf,-1,sizeof(memf));
	memset(memf[0],0,sizeof(memf[0]));
	cout << d(0,m);
	return 0;
}
int d(int rt,int wei){
//most value porduced by the tree 'rt' with weight'wei'
	if (memd[rt][wei] != -1) return memd[rt][wei];
	if (wei < w[rt]) return memd[rt][wei] = 0;
	return memd[rt][wei] = f(head[rt],wei - w[rt]) + v[rt];
}
int f(int i,int wei){
//most value porduced by the list begins from 'i' with weight'wei'
	if (memf[i][wei] != -1) return memf[i][wei];
	int ev = e[i].v;
	int ans = 0;
	for (int j = 0;j <= wei;++ j)
		ans = max(ans,d(ev,j) + f(e[i].nxt,wei - j));
	return memf[i][wei] = ans;
}
```

---

## 作者：沧澜 (赞：0)

一眼题，秒出思路：是tarjin+树形DP。

先跑一遍tarjin，缩去所有的点，然后的思路就和一个叫“选课”的题目很像了。

先把树转化成二叉树，然后跑一边树形DP，这个题是个很经典的树形DP的模型。

```cpp
#include<map>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define N 10001
#define M 2501
using namespace std;
map<int,int>ma[N];
int n,m,K;
int tot,top;
int tim,sum,sumcol;
int col[N],kk[N],vval[N];
int to[N],net[N],head[N];
int k[N],val[N],f[N][M],dp[M];
int dad[N],lchild[N],rchild[N];
int vis[N],dis[N],low[N],stack[N],visstack[N];
void add(int u,int v){
    to[++tot]=v;net[tot]=head[u];head[u]=tot;
}
void tarjin(int now){
    dis[now]=low[now]=++tim;
    vis[now]=1;
    stack[++top]=now;
    visstack[now]=1;
    for(int i=head[now];i;i=net[i])
        if(visstack[to[i]])
            low[now]=min(low[now],dis[to[i]]);
        else if(!vis[to[i]]){
            tarjin(to[i]);
            low[now]=min(low[now],low[to[i]]);
        }
    if(low[now]==dis[now]){
        sumcol++;
        col[now]=sumcol;
        while(stack[top]!=now){
            col[stack[top]]=sumcol;
            visstack[stack[top]]=0;
            top--;
        }
        visstack[now]=0;
        top--;
    }
}
int dfs(int i,int j){
    if(i>n||i<1||j>K||j<1)    return 0;
    if(f[i][j])    return f[i][j];
    for(int kkk=0;kkk<=j-kk[i];kkk++)
        f[i][j]=max(f[i][j],dfs(lchild[i],kkk)+dfs(rchild[i],j-kkk-kk[i])+vval[i]);
    f[i][j]=max(f[i][j],dfs(rchild[i],j));
    return f[i][j];
}
int main(){
    //freopen("T1.in","r",stdin);
    //freopen("T1.out","w",stdout);
    scanf("%d%d",&n,&K);
    for(int i=1;i<=n;i++)    scanf("%d",&k[i]);
    for(int i=1;i<=n;i++)    scanf("%d",&val[i]);
    for(int i=1;i<=n;i++){
        int x;
        scanf("%d",&x);
        if(x!=0)    add(x,i);
    }
    for(int i=1;i<=n;i++)
        if(!vis[i])    tarjin(i);
    for(int i=1;i<=n;i++)
        for(int j=head[i];j;j=net[j])
            if(col[i]!=col[to[j]])
                if(ma[col[i]].find(col[to[j]])==ma[col[i]].end()){
                    ma[col[i]][col[to[j]]]=1;
                    dad[col[to[j]]]=col[i];
                }
    for(int i=1;i<=sumcol;i++){
        int fa=dad[i];
        if(!lchild[fa])    lchild[fa]=i;
        else{
            fa=lchild[fa];
            while(rchild[fa])    fa=rchild[fa];
            rchild[fa]=i;
        }    
    }
    for(int i=1;i<=n;i++){
        kk[col[i]]+=k[i];
        vval[col[i]]+=val[i];
    }
    cout<<dfs(lchild[0],K);
}
```

---

## 作者：_sry (赞：0)


如果没有环的话其实就是一个比较水的树形背包。但是现在有环，并且当我们选择环中任何一点时其他环上的点也都要被选择，然后就可以缩点解决环的问题。

然后缩点后会形成一个森林，我们建虚点$0$连向各自联通块的根，然后做一个树上背包即可
```
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cstdio>
using namespace std;
inline int read(){
    int f=1,ans=0;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){ans=ans*10+c-'0';c=getchar();}
    return f*ans;
}
const int MAXN=1001;
struct node{
    int u,v,nex;
}x[MAXN<<1];
struct node1{
    int u,v;
}E[MAXN];
int dfn[MAXN],uu[MAXN<<1],CNT,low[MAXN],cnt,n,w,num,col[MAXN],co,head[MAXN],v[MAXN],W[MAXN];
void add(int u,int v){
    x[cnt].u=u,x[cnt].v=v,x[cnt].nex=head[u],head[u]=cnt++;
}
int sta[MAXN],tot;
int ww[MAXN],vv[MAXN];
void tarjan(int f,int fath){
    dfn[f]=low[f]=++num;sta[++tot]=f;
    for(int i=head[f];i!=-1;i=x[i].nex){
        int v=x[i].v;
        if(!dfn[v]) tarjan(v,f),low[f]=min(low[f],low[v]);
        else if(!col[v]) low[f]=min(low[f],dfn[v]);
    }
    if(low[f]==dfn[f]){
        col[f]=++co;
        while(sta[tot]!=f){
            col[sta[tot]]=co;
            ww[co]+=W[sta[tot]],vv[co]+=v[sta[tot]];
            tot--;
        }
        ww[co]+=W[sta[tot]],vv[co]+=v[sta[tot]];
        tot--;
    }return;
}
int f[MAXN];
bool cmp(node1 x1,node1 x2){
    if(x1.u==x2.u) return x1.v<x2.v;
    return x1.u<x2.u;
}
int find(int xx){
    if(f[xx]==xx) return xx;
    return f[xx]=find(f[xx]);
}
void merge(int x1,int x2){
    int t1=find(x1),t2=find(x2);
    f[t2]=t1;
    return;
}
int group[MAXN][MAXN],size[MAXN];
void dfs(int f){
    size[f]=1;
    for(int i=head[f];i!=-1;i=x[i].nex){
        dfs(x[i].v);
        size[f]+=size[x[i].v];
    }return;
}
int _MAXN[MAXN],root[MAXN];
void build(){
    for(int i=1;i<=co;i++) f[i]=i;
    for(int i=1;i<=CNT;i++)
        E[i].u=col[E[i].u],E[i].v=col[E[i].v];
    sort(E+1,E+CNT+1,cmp);
    memset(head,-1,sizeof(head)),cnt=0;
    for(int i=1;i<=CNT;i++){
        if((E[i].u!=E[i].v)&&(E[i].u!=E[i-1].u||E[i].v!=E[i-1].v)){
            merge(E[i].u,E[i].v);
            add(E[i].u,E[i].v);
        }
    }
    memset(root,-1,sizeof(root));
    for(int i=1;i<=co;i++) f[i]=find(f[i]);
    for(int i=1;i<=co;i++){
        memset(size,0,sizeof(size));
        dfs(i);
        if(size[i]>_MAXN[f[i]]){
            _MAXN[f[i]]=size[i];
            root[f[i]]=i;
        }
    }
    for(int i=1;i<=co;i++)
        if(root[i]!=-1)add(0,i);
    ww[0]=1,vv[0]=0;
    w++;
}
int dp[MAXN][MAXN];
void dp_tree(int f,int fath){
    for(int k=head[f];k!=-1;k=x[k].nex){
        int v=x[k].v;
        dp_tree(v,f);
        for(int i=w;i>=0;i--){
            for(int j=i;j>=0;j--) if(i-j>=ww[v]) {
                dp[f][i]=max(dp[f][i],dp[f][j]+dp[v][i-j]);
            }
        }
    }
    for(int i=w;i>=ww[f];i--) dp[f][i]=dp[f][i-ww[f]]+vv[f];
}
int main(){
    memset(head,-1,sizeof(head));
    n=read(),w=read();
    for(int i=1;i<=n;i++) W[i]=read();
    for(int i=1;i<=n;i++) v[i]=read();
    for(int i=1;i<=n;i++){
        int u=read();
        if(u) {
            E[++CNT].u=u,E[CNT].v=i;
            add(u,i); 
        }
    }
    for(int i=1;i<=n;i++)
        if(!dfn[i]) tarjan(i,0);
    build();
    dp_tree(0,0);
    cout<<dp[0][w];
}
```

---


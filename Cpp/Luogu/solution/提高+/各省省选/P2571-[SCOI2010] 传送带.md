# [SCOI2010] 传送带

## 题目描述

在一个 $2$ 维平面上有两条传送带，每一条传送带可以看成是一条线段。两条传送带分别为线段 $\text{AB}$ 和线段 $\text{CD}$。lxhgww 在 $\text{AB}$ 上的移动速度为 $P$，在 $\text{CD}$ 上的移动速度为 $Q$，在平面上的移动速度 $R$。现在 lxhgww 想从 $\text A$ 点走到 $\text D$ 点，他想知道最少需要走多长时间。


## 说明/提示

对于 $100\%$ 的数据，$1\le A_x,A_y,B_x,B_y,C_x,C_y,D_x,D_y\le10^3$，$1\le P,Q,R\le10$。

## 样例 #1

### 输入

```
0 0 0 100
100 0 100 100
2 2 1
```

### 输出

```
136.60```

# 题解

## 作者：XZYQvQ (赞：69)

//安利一下自己的博客啦：[http://www.k-xzy.xyz/archives/4979](http://www.k-xzy.xyz/archives/4979)

Ps：几万年前退役的我看了看评论发现居然还有人看这篇文章，并且提出博客地址有误的问题。啊，确实如此，我退役当天博客就关闭啦，但是我的一位好心的同学 Remmina 要走了网站数据并且一直当自己的博客开着，我的文章也都能在里面找到，地址是 [https://www.mina.moe](https://www.mina.moe)。因此这篇文章也可以在[https://www.mina.moe/archives/4979](https://www.mina.moe/archives/4979)上找到。在此也特别感谢 Remmina 同学，也感谢各位耐心阅读一个早就凉透的OIer在最美好的时光写下的这篇“不务正业”的文章。

# 1. 题目

[传送门=￣ω￣=](https://remmina.github.io/BZPRO/JudgeOnline/1857.html)

# 2. 题解

网上基本上所有Dalao都是写的“三分套三分”Orz

（好像WJMZBMR写的是模拟退火，为啥我一开始写模拟退火挂了呢QvQ可能我太弱了）

先讲下这题吧。

首先lxhgww的路径一定是从$A$点上传送带$AB$，走$x$个单位时间($0\leq x\leq \frac{AB}{P}$)，再下$AB$传送带，徒步走上$CD$传送带（不一定是在$C$点上传送带），走$y$个单位时间到达$D$点($0\leq y\leq \frac{CD}{Q}$)

设用时为$f(x,y)$（$x,y$的意义见上文）

则：

设$f1(t)$表示从$A$点出发，沿着$AB$走$t$个单位时间后到达的坐标。

设$f2(t)$表示从$D$点出发，沿着$DC$走$t$个单位时间后到达的坐标。

那么：

$$f(x,y)=\frac{dis(f1(x),f2(y))}{R} + x + y$$

（$dis$表示求两点之间的欧几里得距离）

好的，现在这个问题已经转化为了**求一个二元函数的最小值**

可以把函数放到三维空间里看成一个物体，要在一个矩形区域内找物体的最低点。

。。。

写挂模拟退火以后我就写了个**粒子群优化算法**。。。

这算法真NB啊，什么数学推导都不需要，完全把函数当做随机函数看都能过掉！

这个算法是模仿生物（鸟类）捕食的过程。把一堆粒子随机撒在函数定义域内，然后每次找出所有粒子中所在位置对应的函数值最优的粒子，并且让大家都**尽量向这里加速**。

每个粒子都是有自己的**惯性**的，这样可以增加随机性，以免卡在局部最优解导致答案错误。

总之就是模拟真实的自然界啦。。。

具体很难说清楚，可以去网上搜一下这个算法，很玄妙的QvQ

但是好像网上很少有（或者说可能根本没有）把粒子群优化算法这种人工智能算法应用于OI竞赛的，所以这里发一下代码，里面会写上注释的，还是看代码比较好懂=。=（其实是手缝针啦打字有点不舒服）

另外实验结果表明，粒子群算法更注重粒子个数。。。像我一开始那样开20个粒子就冲上去爆〇的做法真的不可取QvQ

代码：
```cpp
#include <bits/stdc++.h>

#define BS (505)//粒子数组大小
#define eps (1e-8)

using namespace std;

const int cnt = 500;//粒子个数

struct vec//向量
{
	double x, y;
	vec operator + (const vec oth) const
	{
		return (vec){x + oth.x, y + oth.y};
	}
	vec operator - (const vec oth) const
	{
		return (vec){x - oth.x, y - oth.y};
	}
	vec operator * (const double d) const
	{
		return (vec){x * d, y * d};
	}
	vec operator / (const double d) const
	{
		return (vec){x / d, y / d};
	}
};

vec A, B, C, D, P1, P2;

double P, Q, R, rx, ry;

vec f1(double x) {return A + P1 * x;}//和上文定义的f1意义相同

vec f2(double x) {return D + P2 * x;}//和上文定义的f2意义相同

double Squ(double a) {return a * a;}

double dis(vec a, vec b)//求a,b的欧几里得距离
{
	return sqrt(Squ(a.x - b.x) + Squ(a.y - b.y));
}

double f(double x, double y)//和上文定义的f意义相同
{
	return x + y + dis(f1(x), f2(y)) / R;
}

double Rand() {return (double)rand() / RAND_MAX;}//返回一个[0,1]的随机实数

struct Bird {double vx, vy, x, y, f, pb, pbx, pby;} b[BS];//粒子们

//vx,vy是速度向量，x,y是位置向量，f是当前位置的函数值，pb是该粒子历史最优值

double w = 1, gb = 1e233, gbx, gby;

//w是精度权重， gb是全局目前最优值， gbx,gby是取到全局最优值时的自变量x,y

void Update(int a)//更新粒子a的状态，这里具体原理请见算法实现原理
{
	b[a].vx = b[a].vx * w + Rand() * w * (gbx + b[a].pbx - b[a].x * 2);
	b[a].vy = b[a].vy * w + Rand() * w * (gby + b[a].pby - b[a].y * 2);
	//b[a].v * w是因为有惯性，另外的项则是尽量像更优解靠近
	b[a].x += b[a].vx, b[a].y += b[a].vy;//更新位置向量
	//下面4行是防止粒子出界，出界则反弹回来（这里我没在网上找到相关资料介绍如何处理出界，所以是自己YY的）
	if (b[a].x < 0) b[a].x = 0, b[a].vx = -b[a].vx;
	if (b[a].y < 0) b[a].y = 0, b[a].vy = -b[a].vy;
	if (b[a].x > rx) b[a].x = rx, b[a].vx = -b[a].vx;
	if (b[a].y > ry) b[a].y = ry, b[a].vy = -b[a].vy;
	b[a].f = f(b[a].x, b[a].y);//计算当前位置函数值
	if (b[a].f < b[a].pb)//更新局部最优解
		b[a].pbx = b[a].x, b[a].pby = b[a].y, b[a].pb = b[a].f;
}

int main(int argc, char const* argv[])
{
	scanf("%lf%lf%lf%lf", &A.x, &A.y, &B.x, &B.y), P1 = B - A;
	scanf("%lf%lf%lf%lf", &C.x, &C.y, &D.x, &D.y), P2 = C - D;
	scanf("%lf%lf%lf", &P, &Q, &R), srand(P + Q + R);
	rx = dis(B, A) / P, ry = dis(D, C) / Q;
	if (!rx) P1.x = P1.y = 0; else P1 = P1 / rx;//特判传送带是一个点的情况
	if (!ry) P2.x = P2.y = 0; else P2 = P2 / ry;
	for (int i = 1; i <= cnt; i += 1)//随机撒点
	{
		b[i].x = b[i].pbx = Rand() * rx, b[i].y = b[i].pby = Rand() * ry;
		b[i].f = b[i].pb = f(b[i].x, b[i].y);
		b[i].vx = b[i].vy = 0;
		if (gb > b[i].pb) gbx = b[i].pbx, gby = b[i].pby, gb = b[i].pb;
	}
	for (int p = 1; p <= 900; p += 1, w *= 0.99)//迭代900次，0.99的900次方已经对答案无影响
		for (int i = 1; i <= cnt; i += 1)
			if (Update(i), gb > b[i].pb)
				gbx = b[i].pbx, gby = b[i].pby, gb = b[i].pb;//更新全局最优解
	printf("%.2f\n", gb);
	return 0;
}
```

---

## 作者：bztMinamoto (赞：56)

表示蒟蒻并不会楼下的什么三分套三分退火啊粒子群啊……只能暴力了……

我是这样做的，把每一条线段平均拆成5000个点，然后两条线段上的点对之间两两匹配，取时间最小的

~~然后之后我交了一发三分竟然WA了~~

~~所以暴力才是最正确的方法~~

```
//minamoto
#include<bits/stdc++.h>
using namespace std;
const int N=5005;
double x[N+5],y[N+5],xx[N+5],yy[N+5];
double t1[N+5],t2[N+5];
inline double dis(int i,int j){return sqrt((x[i]-xx[j])*(x[i]-xx[j])+(y[i]-yy[j])*(y[i]-yy[j]));}
double Ax,Ay,Bx,By,Cx,Cy,Dx,Dy,p,q,r,ans=1e18;
int main(){
//	freopen("testdata.in","r",stdin);
//	freopen("transporter.in","r",stdin);
//	freopen("transporter.out","w",stdout);
    cin>>Ax>>Ay>>Bx>>By>>Cx>>Cy>>Dx>>Dy>>p>>q>>r;
    double dx=(Bx-Ax)/N,dy=(By-Ay)/N;
    for(int i=0;i<=N;++i){
        x[i]=Ax+dx*i,y[i]=Ay+dy*i;
        t1[i]=sqrt(dx*i*dx*i+dy*i*dy*i)/p;
    }
    dx=(Dx-Cx)/N,dy=(Dy-Cy)/N;
    for(int i=0;i<=N;++i){
        xx[i]=Dx-dx*i,yy[i]=Dy-dy*i;
        t2[i]=sqrt(dx*i*dx*i+dy*i*dy*i)/q;
    }
    for(int i=0;i<=N;++i)for(int j=0;j<=N;++j)
    ans=min(ans,t1[i]+t2[j]+dis(i,j)/r);
    printf("%.2lf\n",ans);return 0;
}
```

---

## 作者：AThousandSuns (赞：52)

这是一道三分的模板题。

~~其实我瞥了一眼题解才发现是三分~~

至少学会了一个套路。

AC后看了看题解，5篇中就2篇是三分，结果一篇没有 $\LaTeX$ 真不爽，一篇就一点点代码……

不多说了，开始。

---
题目大意：

你要从 $A$ 点到 $D$ 点。有两条传送带：第一条从 $A$ 到 $B$，速度为 $p$，第二条从 $C$ 到 $D$，速度为 $q$。不走传送带时速度为 $r$。求从 $A$ 到 $D$ 的最少时间。

明显这条路径应该是三条线段组成的：$AE+EF+FD$。其中 $E$ 在 $AB$ 上，$F$ 在 $CD$ 上。

（以下设 $dis(X,Y)$ 为 $X$ 和 $Y$ 的距离）

那么答案就是 $dis(A,E)/p+dis(E,F)/r+dis(F,D)/q$。

这实际上是一个二元函数，想要求最小值还比较麻烦。

假设我们把其中一个元（这里取 $E$）当做参数会怎么样？

那么就是要找一点 $F$ 使得 $dis(E,F)/r+dis(F,D)/q$ 最小。

（以下设 $f(X)=(dis(X,F)/r+dis(F,D)/q)_{min}$）

容易发现这是个单峰或者单调函数。

有几何画板或者GeoGebra的自己试一下吧，我也说不太清楚……

反正就是 $f(E)$ 是可以通过三分 $F$ 得到最小值的。

但是其实 $E$ 也是个未知量啊！那怎么取得 $dis(A,E)/p+f(E)$ 的最小值呢？

我们发现这也是个单峰或单调函数。可以再三分 $E$ 得出这个最小值，也就是答案。

综上：这题就是三分套三分。

---
上代码：（详细注释）
```cpp
#include<bits/stdc++.h>
using namespace std;
const double eps=1e-8;	//我一般喜欢把eps设为1e-8，当然对于这题1e-6足够了
double ax,ay,bx,by,cx,cy,dx,dy,p,q,r;
double dis(double x_1,double y_1,double x_2,double y_2){	//P1和P2的距离
	double xdis=x_1-x_2,ydis=y_1-y_2;
	return sqrt(xdis*xdis+ydis*ydis);
}
double f(double x_1,double y_1,double x_2,double y_2){	//上文中提到的f(P1)在当F是P2时的值
	return dis(x_1,y_1,x_2,y_2)/r+dis(x_2,y_2,dx,dy)/q;
    //第一个是dis(E,F)/r，第二个是dis(F,D)/q
}
double calc1(double x,double y){	//内层三分F（这个给定的参数是固定E是这个点）
	double lx=cx,ly=cy,rx=dx,ry=dy;	//在CD上三分
	while(dis(lx,ly,rx,ry)>eps){	//还没有重合成一点
		double tmpx=(rx-lx)/3,tmpy=(ry-ly)/3;
		double lmidx=lx+tmpx,rmidx=rx-tmpx,lmidy=ly+tmpy,rmidy=ry-tmpy;	//(lmidx,lmidy)是左等分点，(rmidx,rmidy)是右等分点
		double ans1=f(x,y,lmidx,lmidy),ans2=f(x,y,rmidx,rmidy);	//左等分点和右等分点的值
		if(ans2-ans1>eps) rx=rmidx,ry=rmidy;	//左边更小，舍弃右边
		else lx=lmidx,ly=lmidy;	//右边更小，舍弃左边
	}
	return f(x,y,lx,ly);	//返回这个最小值
}
double calc(){	//外层三分E
	double lx=ax,ly=ay,rx=bx,ry=by;	//在AB上三分
	while(dis(lx,ly,rx,ry)>eps){
		double tmpx=(rx-lx)/3,tmpy=(ry-ly)/3;
		double lmidx=lx+tmpx,rmidx=rx-tmpx,lmidy=ly+tmpy,rmidy=ry-tmpy;	//以上同理
		double ans1=calc1(lmidx,lmidy)+dis(ax,ay,lmidx,lmidy)/p,ans2=calc1(rmidx,rmidy)+dis(ax,ay,rmidx,rmidy)/p;	//左等分点和右等分点的值（在这里套了内层三分）
		if(ans2-ans1>eps) rx=rmidx,ry=rmidy;
		else lx=lmidx,ly=lmidy;	//同理
	}
	return calc1(lx,ly)+dis(ax,ay,lx,ly)/p;	//返回最小值，也就是答案
}
int main(){
	scanf("%lf%lf%lf%lf%lf%lf%lf%lf%lf%lf%lf",&ax,&ay,&bx,&by,&cx,&cy,&dx,&dy,&p,&q,&r);
	printf("%.2lf\n",calc());	//这就是答案
}
```

---

## 作者：zhangjianweivv (赞：24)

这道题真的很难想到思路，但是想到了也很难实现，最后是以一种很神奇的思路搞定的、、

---
[传送门](https://loj.ac/problem/10017)

其实一开始真的想不到，是看了大佬的题解才想出来的。思路其实不难理解，目前我接触到了三种思路。

## 一、三分 
### 1.三分坐标
这是最常见的思路了，很多大佬都是用三分坐标的（包括猴子大佬），因为很好理解。

![](https://cdn.luogu.com.cn/upload/pic/46203.png)

我们进行三分套三分，把线段$ab$三分寻找转折点后从转折点跑向线段$cd$，然后再在线段$cd$上三分寻找抵达地点跑向点$d$。

具体三分方法在图里有说。代码详见[loj评测](https://loj.ac/submissions?problem_id=10017)找zhangjianjunab。

---
### 2.三分比例
这是我的思路了、、虽然好像没什么人用、、

我原本的思路是三分与$a$点（$c$点）的距离的，但是后来发现这个距离根本无法确定该点的坐标。

后来上网看了大佬的博客，发现可以三分比值。具体如下：

![](https://cdn.luogu.com.cn/upload/pic/46184.png)

我们现在已知线段$AB$，假设现在在$AB$上已找到一点$F$，我们要去计算$F$与另一条线段的距离，这个$F$的坐标怎么求呢？

以$AB$为斜边，作一个$Rt$△$ABE$。作$FH$⊥$AC$，此时我们可以发现，△$AFH$和△$ABE$是相似三角形（$∠A$为公共角，$∠FHA=∠E=90$°）

所以$AF$和$AB$有一定的比值，即$\frac{AF}{AB}=k\left(0\le k\le1\right)$。

所以我们可以直接三分$k$，然后就可以求出$F$的坐标了。

同样的方法三分线段$CD$，用三分套三分（同三分坐标的方法）。

贴个代码、、
```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
using namespace std;
struct node
{
	double x,y;
}a,b,c,d;double p,q,r;
double gougu(node n1,node n2)
{
	return sqrt((n1.x-n2.x)*(n1.x-n2.x)+(n1.y-n2.y)*(n1.y-n2.y));
}
node find(node xx,node yy,double k)
{
	node no;no.x=(yy.x-xx.x)*k+xx.x;no.y=(yy.y-xx.y)*k+xx.y;
	return no;
}
double checkplus(double x,double y)
{
	node n1=find(a,b,x),n2=find(c,d,y);
	return gougu(a,n1)/p+gougu(n1,n2)/r+gougu(n2,d)/q;
}
double check(double x)
{
	double l=0.0,r=1.0;
	while(r-l>=0.0000001)
	{
		double mid1=l+(r-l)/3.0,mid2=r-(r-l)/3.0;
		if(checkplus(x,mid1)>checkplus(x,mid2))l=mid1;
		else r=mid2;
	}
	return checkplus(x,l);
}
int main()
{
	scanf("%lf%lf%lf%lf",&a.x,&a.y,&b.x,&b.y);
	scanf("%lf%lf%lf%lf",&c.x,&c.y,&d.x,&d.y);
	scanf("%lf%lf%lf",&p,&q,&r);
	double l=0.0,r=1.0;
	while(r-l>=0.0000001)
	{
		double mid1=l+(r-l)/3.0,mid2=r-(r-l)/3.0;
		if(check(mid1)>check(mid2))l=mid1;
		else r=mid2;
	}
	printf("%.2lf",check(l));
	return 0;
}
```
（~~当然，由于懒，所有inline都没有加、、~~）

---
## 二、模拟退火
我也不知道这是什么（太菜了、、），可以上网搜一搜。

---
## 三、暴力搜
这个好像也能过几个点？不过两位小数，的确也可以暴力找。也有大佬是先暴力在$AB$上找点，然后再三分$CD$的（因为三分$AB$的我还证不出其为单峰函数），会慢一点，但是也可以过，而且保险很多。

---
## 三分单峰函数证明
今天上午才听猴子证了这个，觉得自己学算法还是太浅了，要知道为什么可以用三分才行。

首先，我们画一个图。假设上面的点为线段$AB$上的某一点，它到线段$CD$的所有路径中，选出了$a$和$b$两条，设$a$为最优解。我们可以画出以下图片：

![](https://i.loli.net/2018/12/15/5c1459cc3e7b3.png)

而$b$肯定是比$a$要长的，所以我们可以再画出下面这个：

![](https://i.loli.net/2018/12/15/5c1459e71f226.png)

我们可以看出，$b$路径和$a$路径唯一的区别就是在于$b-a$这一段和$c$这一段。我们不妨求出它们的时间：

$b=\frac{a}{r}+\frac{b-a}{r}+\frac{c}{q}$

$a=\frac{a}{r}$

但是一般来说，$c$这段路程是走得比$b$快的，即$q>r$，所以$b$有可能在$c$超车，我们要判断是否存在这种情况，即$\frac{b-a}{r}<\frac{c}{q}$，$b$就可以超车，反之亦然。

所以我们可以找到一条路径，使其左边的都为$\frac{b-a}{r}<\frac{c}{q}$且右边的都为$\frac{b-a}{r}>\frac{c}{q}$而且都成递增或递减。这样就能证其为单峰函数了（~~因为懒不想证~~）

好就写到这里（~~累死我了~~）

---

## 作者：浅色调 (赞：18)

### Solution：
$\;\;\quad$**思路**：模拟退火

　　本题正解是三分法，然而不会用，考试时随便打了个模拟退火水了70分，后面调了一下就AC了。

　　退火的思路就比较简单，预处理出初值$ans$为四条路径中的最小值：$(1)A\rightarrow D\;(2)A\rightarrow B\rightarrow D\;(3)A\rightarrow C\rightarrow D\;(4)A\rightarrow B\rightarrow C\rightarrow D$。

　　然后对于四种路径，我们都能固定一条边而在另一边中枚举点。比如在$AB$中枚举中点，每次就算出答案后更新，若不优于当前解，则有一定概率还是往该方向移动，至于移动的具体方向，我也不知道，所以就强行rand了（什么鬼？跳点完全随机，这样子都能A），每次都找中点，直到两个边界点特别接近（弄个exp）。

　　最后再强行退火100次，就好了（退火太玄学，反正AC就是正解）。

$\;\;\quad$欢迎来踩博客：[five20](https://www.cnblogs.com/five20/p/9317547.html)（蒟蒻写题解不易，转载请注明出处，万分感谢！）

### 代码：
```cpp
#include<bits/stdc++.h>
#pragma GCC optimize(2)
#define il inline
#define ll long long
#define For(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)
#define Bor(i,a,b) for(int (i)=(b);(i)>=(a);(i)--)
using namespace std;
const double R=0.98,Exp=1e-5;
double ax,ay,bx,by,cx,cy,dx,dy,p,q,r,ans;

int main(){
    srand(time(0));
    scanf("%lf%lf%lf%lf",&ax,&ay,&bx,&by);
    scanf("%lf%lf%lf%lf",&cx,&cy,&dx,&dy);
    scanf("%lf%lf%lf",&p,&q,&r);
    double ab=sqrt((ax-bx)*(ax-bx)+(ay-by)*(ay-by));
    double cd=sqrt((cx-dx)*(cx-dx)+(cy-dy)*(cy-dy));
    double ac=sqrt((ax-cx)*(ax-cx)+(ay-cy)*(ay-cy));
    double bc=sqrt((bx-cx)*(bx-cx)+(by-cy)*(by-cy));
    double ad=sqrt((ax-dx)*(ax-dx)+(ay-dy)*(ay-dy));
    double bd=sqrt((bx-dx)*(bx-dx)+(by-dy)*(by-dy));
    ans=ad/r;
    ans=min(ans,ab/p+bd/r);
    ans=min(ans,ab/p+bc/r+cd/q);
    ans=min(ans,ac/r+cd/q);
    For(i,1,100){
    double tx=ax,ty=ay,px=bx,py=by,mx,my,T=5201314;
    while(sqrt((tx-px)*(tx-px)+(ty-py)*(ty-py))>0.01){
        mx=(tx+px)/2,my=(ty+py)/2;
        double fu=sqrt((mx-ax)*(mx-ax)+(my-ay)*(my-ay))/p+sqrt((mx-dx)*(mx-dx)+(my-dy)*(my-dy))/r;
        if(fu<ans){
            ans=fu;
            if(rand()%2) tx=mx,ty=my;
            else px=mx,py=my;
        }
        else {
            if(rand()<T) {
                if(rand()%2)tx=mx,ty=my;
                else px=mx,py=my;
                T*=R;
            }
        }
    }
    tx=cx,ty=cy,px=dx,py=dy,T=5201314;
    while(sqrt((tx-px)*(tx-px)+(ty-py)*(ty-py))>0.01){
        mx=(tx+px)/2,my=(ty+py)/2;
        double fu=sqrt((mx-ax)*(mx-ax)+(my-ay)*(my-ay))/r+sqrt((mx-dx)*(mx-dx)+(my-dy)*(my-dy))/q;
        if(fu<ans){
            ans=fu;
            if(rand()%2) tx=mx,ty=my;
            else px=mx,py=my;
        }
        else {
            if(rand()<T) {
                if(rand()%2)tx=mx,ty=my;
                else px=mx,py=my;
                T*=R;
            }
        }
    }
    tx=ax,ty=ay,px=bx,py=by,mx,my,T=5201314;
    while(sqrt((tx-px)*(tx-px)+(ty-py)*(ty-py))>0.01){
        mx=(tx+px)/2,my=(ty+py)/2;
        double fu=sqrt((mx-ax)*(mx-ax)+(my-ay)*(my-ay))/p+sqrt((mx-cx)*(mx-cx)+(my-cy)*(my-cy))/r+cd/q;
        if(fu<ans){
            ans=fu;
            if(rand()%2) tx=mx,ty=my;
            else px=mx,py=my;
        }
        else {
            if(rand()<T) {
                if(rand()%2)tx=mx,ty=my;
                else px=mx,py=my;
                T*=R;
            }
        }
    }
    tx=cx,ty=cy,px=dx,py=dy,T=5201314;
    while(sqrt((tx-px)*(tx-px)+(ty-py)*(ty-py))>0.01){
        mx=(tx+px)/2,my=(ty+py)/2;
        double fu=sqrt((mx-bx)*(mx-bx)+(my-by)*(my-by))/r+sqrt((mx-dx)*(mx-dx)+(my-dy)*(my-dy))/q+ab/p;
        if(fu<ans){
            ans=fu;
            if(rand()%2) tx=mx,ty=my;
            else px=mx,py=my;
        }
        else {
            if(rand()<T) {
                if(rand()%2)tx=mx,ty=my;
                else px=mx,py=my;
                T*=R;
            }
        }
    }
    }
    printf("%.2lf",ans);
    return 0;
}
```

---

## 作者：Untitled10032 (赞：11)

想到了一种 $O(1)$ 做法（如果开根算 $O(1)$ 的话）。但是这种方法讨论的情况有点多，题目测试点又不多，所以有可能存在点问题。欢迎 hack。

## 思路

**分情况讨论并通过一些数学运算求解。**

------------

易得至少存在一条最优路径，满足其可以分解为三条线段，即在线段 $AB$ 上走一段、在平面的其它地方走一段、在线段 $CD$ 上走一段。

### 先考虑一个简单一点的问题：

![](https://cdn.luogu.com.cn/upload/image_hosting/kc52nglv.png)

从 $A$ 点经 $C$ 点到 $D$ 点，其中在直线 $CD$ 上移动一个单位长度需要 $Q$ 的时间，在平面内其它位置移动一个单位长度需要 $R$ 的时间，保证 $R>Q>0$。**（注意这里为了方便，将题面中的 $\frac{1}{P}$ 记为 $P$，$\frac{1}{Q}$ 记为 $Q$，$\frac{1}{R}$ 记为 $R$，与题面有一定差异。）**

其中 $h$、$l$ 为定值，设路径耗时为 $f(x)$，求 $x$ 为何值时，$f(x)$ 最小与对应的最小值。

$$f(x)=R\sqrt{h^2+x^2}+Q(l-x)$$

经过一些[计算](https://www.luogu.com.cn/paste/qyej6r1k)，可以发现 $f(x)$ 是单峰函数，$f(x)$ 最小时，$x=\frac{Qd}{\sqrt{R^2-Q^2}}$，此时 $f(x)_{min}=\sqrt{R^2-Q^2}h+Ql$

**为了叙述简便，下文中将上述路径称为点到传送带的最优路径。**

------------

### 另一个简单一点的问题：

如果题目中的传送带不是线段而是直线，证明：存在最优路径，满足它可以被划分为不多于两个线段。也就是说不会既在 $AB$ 上走一段、在平面中其它位置走一段，又在 $CD$ 上走一段，三者至多有其二。

**首先考虑两条直线相交的情况：**

![](https://cdn.luogu.com.cn/upload/image_hosting/baylvap8.png)

考虑路径 $A \to E \to D$ 和 $A \to M \to N \to D$，后者对比前者，可以理解为用路径 $M \to N$ 代替了路径 $M \to E \to N$。如图作 $M'N' // MN$， 若 $M \to N$ 比 $M \to E \to N$ 用时更短，由相似可知 $M' \to N'$ 比 $M' \to E \to N'$ 用时更短，且两路径用时差值增大，所以路径 $A \to M' (\to N') \to D$ 比 $A \to M \to N \to D$ 更优，且以此方式作出的最优路径一定能被划分成不多于两个线段。

**再考虑两条直线平行的情况：**

这样的情况下，你在直线 $AB$ 上和 $CD$ 上走相同的距离产生的位移是相同的，那明显在更快的传送带上走更省时间，慢一点的传送带干脆别走了，这样才能达到最优解。两个传送带，你只能走一个，路径肯定能被分成不多于两个线段。

得出这个结论后，你可以以 $A, B, C, D$ 四个点分别为起点，做四次三分，而不用三分套三分了。（我试了从四个起点开始做四次暴力，可以过。）

### 原题思路

由上面两个问题得出，最优解的可能无非就是：$A \to B \to C \to D, A \to B \to D, A \to C \to D, A \to D$ 或者先走到 $A, B, C, D$ 中的某个点，之后走第一个小问题推出来的最优路径到对面的传送带，再走到对面的终点（正着走和倒着走都需要考虑）。

需要注意最优路径走出来的拐点有时候不在线段上，这时候需要舍弃。

把上述所有方案枚举一遍即可。

计算最优路径时如果硬算可能有些麻烦，我采取的方案是以 $\vec{AB}$ 为 $x$ 轴正方向重新建系（或者也可以理解为把坐标系平移旋转一下），算出最优路径出发点的新坐标，这样整个图形就被正过来了，好算了很多。

## 代码

```cpp
#include <algorithm>
#include <iostream>
#include <iomanip>
#include <cmath>

using namespace std;

// 数学里的向量，和坐标是近义词，和变长数组不是近义词
struct Vector {
    double x, y;
    //向量加
    Vector operator+(const Vector b) {
        return { x + b.x, y + b.y };
    }
    //向量减
    Vector operator-(const Vector b) {
        return { x - b.x, y - b.y };
    }
    //向量数量积
    double operator*(const Vector b) {
        return x * b.x + y * b.y;
    }
    //向量模长
    double len() {
        return sqrt(x * x + y * y);
    }
};

double p, q, r; //题目中的速度，但为了方便被修改成了题面中的 1/p, 1/q, 1/r
double ans;

/// @brief 计算最优路径的函数。
/// @param l 传送带的起点 L（A 点或 D 点）。
/// @param lr 传送带对应的向量 LR。
/// @param p 最优路径起始点（题解图中的 A）。
/// @param len 向量 LR 的模长（之前算过了，所以为了让程序跑得快一点就不重新算一遍了）。
/// @param t 在传送带上走一个单位长度所需的时间（p 或 q）。
/// @return 最优路径长度，若最优路径不合法，则返回 INFINITY（正无穷）。
double calc(Vector l, Vector lr, Vector p, double len, double t) {
    if (len == 0 || t >= r)
        return INFINITY;
    const Vector new_x({ lr.x / len, lr.y / len }); //指向新坐标系的 x 方向的单位向量
    const Vector new_y({ new_x.y, -new_x.x });      //指向新坐标系的 y 方向的单位向量
    const Vector new_p({ (p - l) * new_x, abs((p - l) * new_y) });  //p 点在新坐标系中的坐标（若 y 坐标是负的则轴对称一下，保证它在第一或二象限）
    if (new_p.x <= 0)
        return INFINITY;    //若在第二象限，则最优路径不合法（默认最优路径是向左的，因为传送带末端在起点的右边）。
    const double inflexion = new_p.x - t * new_p.y / sqrt(r * r - t * t);    //最优路径拐点 x 坐标。
    if (inflexion <= 0 || inflexion >= len)
        return INFINITY;    //若拐点不在传送带上，则最优路径不合法。
    return sqrt(r * r - t * t) * new_p.y + t * new_p.x; //返回最优路径长度。
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    Vector a, b, c, d;  //题目中的 A, B, C, D。
    cin >> a.x >> a.y >> b.x >> b.y >> c.x >> c.y >> d.x >> d.y >> p >> q >> r;
    p = 1 / p, q = 1 / q, r = 1 / r;
    Vector ab = b - a, dc = c - d;
    const double l_ab = ab.len(), l_dc = dc.len();
    ans = min({
        l_ab * p + l_dc * q + (c - b).len() * r,
        l_ab * p + (d - b).len() * r,
        l_dc * q + (a - c).len() * r,
        (d - a).len() * r
    }); //A, B, C, D 四个点连线的四种情况取最优解。
    //从 A, B, C, D 开始走最优路径的情况取最优解。
    ans = min(ans, calc(a, ab, d, l_ab, p));
    ans = min(ans, calc(d, dc, a, l_dc, q));
    ans = min(ans, calc(a, ab, c, l_ab, p) + l_dc * q);
    ans = min(ans, calc(d, dc, b, l_dc, q) + l_ab * p);
    cout << fixed << setprecision(2) << ans << '\n';
    return 0;
}
```

------------

这题好像是以前一次训练赛的赛题，当时尝试推导过数学做法但是失败了。退役之后偶然翻到以前的草稿纸，于是继续研究，凑出来了这种方法。

---

## 作者：Memorize (赞：9)

这道题简单一点的话来说就是三分套三分（难道是九分！...） 首先三分AB上的点 这个点设为E 然后通过点E三分CD上的点F 这样不断地缩小范围就可以了 至于距离就很简单了 那就是AE/p + EF/r +FD/q 至于三分区间时 怎么缩小范围这个问题嘛.... 留给你们去思考一下 可以从简单的二次函数开始思考 说不定会有新的发现哦（提示一下 里面的数基本上都是double 我就因为定义的int调了一个小时0.0）

```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#include<cmath>
using namespace std;
const double dec=0.00001;
double xa,ya,xb,yb,xc,yc,xd,yd;
double q,p,r;
double count(double xe,double ye,double xf,double yf)
{
  return ((sqrt((xe-xa)*(xe-xa)+(ye-ya)*(ye-ya)))/p)+((sqrt((xf-xe)*(xf-xe)+(ye-yf)*(ye-yf)))/r)+((sqrt((xd-xf)*(xd-xf)+(yd-yf)*(yd-yf)))/q);
}
double narrow(double x,double y)
{
  double fcx=xc,fdx=xd,fcy=yc,fdy=yd;double minn;
  while(fabs(fcx-fdx)>dec||fabs(fcy-fdy)>dec)
  {
     double midx=(fcx+fdx)/2,midy=(fcy+fdy)/2;
     double remidx=(midx+fdx)/2,remidy=(midy+fdy)/2;
     double ans1=count(x,y,midx,midy),ans2=count(x,y,remidx,remidy);
     if(ans1>ans2)  fcx=midx,fcy=midy;
     else fdx=remidx,fdy=remidy;
     minn=min(ans1,ans2);
  }      
  return minn;
}
int main()
{
    scanf("%lf%lf%lf%lf%lf%lf%lf%lf%lf%lf%lf",&xa,&ya,&xb,&yb,&xc,&yc,&xd,&yd,&p,&q,&r);
    double fax=xa,fbx=xb,fay=ya,fby=yb;double minn;
    while(1)
    {
      double midx=(fax+fbx)/2,midy=(fay+fby)/2;
      double remidx=(midx+fbx)/2,remidy=(midy+fby)/2;
      double ans1=narrow(midx,midy),ans2=narrow(remidx,remidy);
      if(ans1>ans2) fax=midx,fay=midy;
      else fbx=remidx,fby=remidy;   
      minn=min(ans1,ans2);   
      if(fabs(fax-fbx)<dec&&fabs(fay-fby)<dec) break;
    }
    printf("%.2lf",minn);
    return 0;
}
```

---

## 作者：ZQYZQY (赞：8)

其实很容易看出来是三分，因为用了坐标来表示，又要算距离，所以就先吧总的距离公式打出来，就会发现是一个二元的方程

A=（sqrt(pow((F.x-D.x),2)+pow((F.y-D.y),2))/Q+sqrt(pow((F.x-E.x),2)+pow((F.y-E.y),2))/R+sqrt(pow((E.x-A.x),2)+pow((E.y-A.y),2))/P;
}）

看起来比较恶心，但A,B,C,D,P,Q,R都是已知的如果把剩下的二元（E，F）中的一个看为参数，就可以证明剩下函数的单峰性了:

证明：

sqrt(pow((F.x-D.x),2)+pow((F.y-D.y),2))/Q+sqrt(pow((F.x-E.x),2)+pow((F.y-E.y),2))/R为单峰函数

<--->首先证明确定一点的欧几里得距离为单峰函数（以E为参数）

//a==E.x,b=E.y

<--->sqrt(x-a)^2+(y-b)^2

then:知道了F是C，D（俩已知点）这条直线上的点，所以y就可以用由C，D构成的一次函数（用f(x)=kx+b就行了用C，D表示太麻烦）表示
然后就可以吧原来的函数解压成一个根号+二次函数的式子，根号不会影响二次函数

然后就比上面的重要那么一丢丢了：知道了dis（F，E）是单峰的函数，剩下的（F，D）呢？不能用同理可证，本弱就痴心妄想用求导暴力证明俩个a相等的根号二次函数
是单峰的，但是显然顶峰不一定一样所以是互相影响的所以很难证明，~~显然不是大佬把导函数写给我然后就放弃了~~，所以在L姓大佬的启发下，发现（F,D）是一个根号一次函数？！

首先为什么证明F，D之间有小Mimi：

因为F是在CD上的，所以FD之间是有联系的，求解他们是【自然的】（@某欧阳老师）

但是如果直接把F设成由C，D一次函数构成坐标形式就太麻烦并且是不对称的了，所以既然知道C,D坐标不如就用CD表示<---> k=FC/CD 

F(C.x+k*(D.x-C.x),C.y+k*(D.y-C.y))//对称

用距离公式+化简-->dis(F,D)=(1-k)*sqrt((D.x-C.x)^2+(D.y-C.y)^2)

sqrt((D.x-C.x)^2+(D.y-C.y)^2)看起来是含元的但显然C，D都是已知的，所以得证dis（F,D）是一次函数（k是自变量）

所以本身dis（F，E）是单峰的，再加上一个一次函数也不会影响他是凹函数--->得证（同理于E）

~~说是这样证，但做题的时候应该也没有哪个会证明的，一切凭感觉靠玄学~~


------------


上码（标准的三分，只是转个弯三分套三分）：
```cpp
#include<bits/stdc++.h>
using namespace std;
int const maxn=1e3+5;
double P,Q,R;
struct X{
	double x,y;
}A,B,C,D;
double  Js(X E,X F){
	return  sqrt(pow((F.x-D.x),2)+pow((F.y-D.y),2))/Q+sqrt(pow((F.x-E.x),2)+pow((F.y-E.y),2))/R+sqrt(pow((E.x-A.x),2)+pow((E.y-A.y),2))/P;
}
double SFen(X k){
	double dlt=1e-8,minl;
	X L=C,R=D;
	while(fabs(L.x-R.x)>dlt||fabs(L.y-R.y)>dlt){
		X mid,Tir;
		mid.x=L.x+(R.x-L.x)/3,mid.y=L.y+(R.y-L.y)/3;
	   Tir.x=R.x-(R.x-L.x)/3,Tir.y=R.y-(R.y-L.y)/3;
		if(Js(k,mid)+dlt>Js(k,Tir))  L=mid;
		else   R=Tir;
		minl=min(Js(k,mid),Js(k,Tir));
	}
	return minl;
}
int main(){
	scanf("%lf%lf%lf%lf%lf%lf%lf%lf%lf%lf%lf",&A.x,&A.y,&B.x,&B.y,&C.x,&C.y,&D.x,&D.y,&P,&Q,&R);
	double  dlt=1e-8,minn;
	X L1=A,R1=B;
	   do	{
		X mid1,Tir1;
		mid1.x=L1.x+(R1.x-L1.x)/3,mid1.y=L1.y+(R1.y-L1.y)/3;
	   Tir1.x=R1.x-(R1.x-L1.x)/3,Tir1.y=R1.y-(R1.y-L1.y)/3;
		if(SFen(mid1)>SFen(Tir1))  L1=mid1;
		else   R1=Tir1;
		minn=min(SFen(mid1),SFen(Tir1));
	}while(fabs(L1.x-R1.x)>=dlt||fabs(L1.y-R1.y)>=dlt);//一定要do while不然如果有一开始就满足while条件的就直接输出了，不会计算时间，会Wa两个点
	printf("%.2lf",minn);
	return 0;
} 
```

感谢审核大佬

---

## 作者：一只小H (赞：7)

## 题意简述

求从A点到D点的最短时间。

输入：

* A、B、C、D这4个点的坐标。
* 在AB上的速度 $P$、在CD上的速度 $Q$、在平面的移动速度 $R$。

输出：

* 输出最短时间。
* 保留两位小数。

## 题目分析

首先来看看样例。

点 E 为线段 AB 上的任意一点，点 F 为线段 CD 上的任意一点，从 A 到 D 所用时间最短的路线显然就是 $\frac{AE}{P}+\frac{DF}{Q}+\frac{EF}{R}$ 的最小值。

![草图](https://cdn.luogu.com.cn/upload/image_hosting/2x8jgdyo.png)

假如 E 是定点，那么要找最优的 F 点，很容易就能想到三分。

而现在 E 点也是动点，所以我们对点 E 也使用三分，即三分套三分，这样即可找到最优解。

那么该如何进行三分呢？

首先三分需要 $midl$ 和 $midr$ ，这里使用的 $midl$、$midr$ 有些特别。为了便于计算距离以及对区间进行三等分，需要记录点的坐标，当 $midl$ 与 $midr$ 横纵坐标都相同时才停止三分。为了避免 B 在 A 的左边这样的问题，在做减法的时候需要使用```fabs```。

在寻找点 E 的时候，缩小范围时判断 $midl$ 与 $midr$ 哪个能找到更优的 F，而在寻找点 F 时，缩小范围则要判断哪个所用的时间最少。

详情请见代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
double ax, ay, bx, by, cx, cy, dx, dy;                           //A、B、C、D点的坐标
double P, Q, R;                                                  //速度
inline double getDis(double x1, double y1, double x2, double y2) //用于获取两点距离
{
    return sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
}
inline double getTime(double x1, double y1, double x2, double y2) //获取所需的时间
{
    double a = getDis(x1, y1, ax, ay); //E点到A点的距离
    double b = getDis(x2, y2, dx, dy); //F点到D点的距离
    double c = getDis(x1, y1, x2, y2); //E点到F点的距离
    return a / P + b / Q + c / R;      //计算时间
}
double searchCD(double xx, double yy) //枚举CD上的点F
{
    double lx, rx, ly, ry;                                 //当前左右端点的横纵坐标
    double midlx, midrx, midly, midry;                     //即midl和midr的横纵坐标
    lx = cx, rx = dx, ly = cy, ry = dy;                    //左边界设置为C的坐标，右边界设置为D的坐标
    while (fabs(rx - lx) > 1e-10 or fabs(ry - ly) > 1e-10) //横纵坐标都相同才停止
    {
        /*三等分横纵坐标*/
        midlx = lx + (rx - lx) / 3.f;
        midrx = rx - (rx - lx) / 3.f;
        midly = ly + (ry - ly) / 3.f;
        midry = ry - (ry - ly) / 3.f;

        if (getTime(xx, yy, midlx, midly) < getTime(xx, yy, midrx, midry)) //左边的的更优就向左
        {
            rx = midrx;
            ry = midry;
        }
        else //否则向右
        {
            lx = midlx;
            ly = midly;
        }
    }
    return getTime(xx, yy, midlx, midry); //返回当前的最优解
}
double searchAB() //枚举AB上的点E
{
    double lx, rx, ly, ry;                                 //当前左右端点的横纵坐标
    double midlx, midrx, midly, midry;                     //即midl和midr的横纵坐标
    lx = ax, rx = bx, ly = ay, ry = by;                    //左边界设置为A的坐标，右边界设置为B的坐标
    while (fabs(rx - lx) > 1e-10 or fabs(ry - ly) > 1e-10) //横纵坐标都相同才停止
    {
        /*三等分横纵坐标*/
        midlx = lx + (rx - lx) / 3.f;
        midrx = rx - (rx - lx) / 3.f;
        midly = ly + (ry - ly) / 3.f;
        midry = ry - (ry - ly) / 3.f;

        if (searchCD(midlx, midly) < searchCD(midrx, midry)) //左边的的更优就向左
        {
            rx = midrx;
            ry = midry;
        }
        else //否则向右
        {
            lx = midlx;
            ly = midly;
        }
    }
    return searchCD(lx, ly); //返回得到的结果
}
int main()
{
    /*输入*/
    cin >> ax >> ay >> bx >> by >> cx >> cy >> dx >> dy;
    cin >> P >> Q >> R;

    /*输出*/
    printf("%.2f\n", searchAB());
    return 0;
}
```


---

## 作者：MSqwq (赞：4)

## 芝士点：三分
题意：  
现在有两条传送带：$A \to B$、$C \to D$  
然后我现在从 $A$ 要走到 $D$ ，问所需的时间最小  
在 $A \to B$ 上的速度是 $P$ ， $C \to D$ 是 $Q$ ，其他不在传送带的时间为 $R$  
思路：  
我们把整个过程换一种方式来表达  
$A \to P$、$P \to Q$、$Q \to D$  
（ $P$ 在 $AB$ 上， $Q$ 在 $CD$ 上）  
然后发现有两个元，不好模拟，所以先假设已知一个元，这个元为系数  
然后直接设函数：$f(x)=time(x \to Q)+time(Q \to D)$最小  
易证这是一个单峰函数  
所以可以用三分求到 $F(P)$ 的最小值  
接下来就是求$time(A \to P)+F(P)$最小  
就还是一个单峰函数  
再次三分  
所以就是三分套三分  
代码如下：  
```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
double p,q,r;
struct qwe{
	double x,y;
}a,b,c,d;
double qqq(qwe a,qwe b)
{
	return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
}
double solve(qwe ab,double x)
{	
	qwe cd;
	cd.x=c.x+(d.x-c.x)*x;
	cd.y=c.y+(d.y-c.y)*x;
	return qqq(ab,cd)/r+qqq(cd,d)/q;
}
double work(double x)
{
	qwe ab;
	ab.x=a.x+(b.x-a.x)*x;
	ab.y=a.y+(b.y-a.y)*x;
	double l2=0,r2=1;
	while(r2-l2>=0.0000001)
	{
		double midl=(r2+l2*2)/3.0;
		double midr=(r2*2+l2)/3.0;
		if(solve(ab,midl)<solve(ab,midr))r2=midr;
		else l2=midl;
	}
	return solve(ab,r2)+qqq(a,ab)/p;
}
int main()
{
	scanf("%lf%lf%lf%lf%lf%lf%lf%lf%lf%lf%lf",&a.x,&a.y,&b.x,&b.y,&c.x,&c.y,&d.x,&d.y,&p,&q,&r);
	double l1=0,r1=1;
	while(r1-l1>=0.0000001)
	{
		double midl=(r1+l1*2)/3.0;
		double midr=(r1*2+l1)/3.0;
		if(work(midl)<work(midr))r1=midr;
		else l1=midl;
	}
	printf("%.2lf\n",work(r1));
}
```


---

## 作者：Utilokasteinn (赞：3)

### [P2571 [SCOI2010]传送带](https://www.luogu.com.cn/problem/P2571)

思路：三分线段 $AB$  找到两点 $lmid$ 和 $rmid$ 。分别以这两个点为目标点，三分线段 $CD$ 找到 $lmid'$ 和 $rmid'$ 。最终找到与目标点花费时间的最小值，然后判断缩小范围。

注意事项：精度不要定太高， $10^{-3}$ 即可，否则可能会WA。

代码如下：
```cpp
#include<bits/stdc++.h>
#define eps 1e-3//精度 
using namespace std;
struct node{
	double x,y;
    node(double xx=0,double yy=0){x=xx,y=yy;}
}a,b,c,d;
double p,q,s;
double dist(node a,node b)//求两点之间的距离 
{
	return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
}
void input()//输入 
{
	scanf("%lf%lf%lf%lf",&a.x,&a.y,&b.x,&b.y);
    scanf("%lf%lf%lf%lf",&c.x,&c.y,&d.x,&d.y);
    scanf("%lf%lf%lf",&p,&q,&s);
}
double check(node mid)//三分 BC 
{
    node l(c.x,c.y),r(d.x,d.y);//左端点和右端点 
    while(fabs(l.x-r.x)>eps||fabs(l.y-r.y)>eps)
	{
        node lmid(l.x+(r.x-l.x)/3,l.y+(r.y-l.y)/3);//三分 
		node rmid(r.x-(r.x-l.x)/3,r.y-(r.y-l.y)/3);
        double dis_l=dist(lmid,d)/q+dist(lmid,mid)/s;//求时间 
        double dis_r=dist(rmid,d)/q+dist(rmid,mid)/s;
        if(dis_l<dis_r)//找时间较小的点 
            r.x=rmid.x,r.y=rmid.y;
        else l.x=lmid.x,l.y=lmid.y;
    }
    return dist(l,d)/q+dist(l,mid)/s+dist(mid,a)/p;//返回所需时间 
}
node solve()//三分 AB 
{
	node l(a.x,a.y),r(b.x,b.y);//左端点和右端点 
	while(fabs(l.x-r.x)>eps||fabs(l.y-r.y)>eps) 
	{
        node lmid(l.x+(r.x-l.x)/3,l.y+(r.y-l.y)/3);
		node rmid(r.x-(r.x-l.x)/3,r.y-(r.y-l.y)/3);//三分 
        if(check(lmid)<check(rmid))//找时间较小的点 
            r.x=rmid.x,r.y=rmid.y;
        else l.x=lmid.x,l.y=lmid.y;
    }
    return l;
}
int main()
{
	input();
	node ans=solve();
    printf("%.2lf",check(ans));
    return 0;
}
```
PS：本代码中的 $s$ 即为 $R$ 。

谢谢观赏。

---

## 作者：Honor誉 (赞：3)

Description

题目描述：

    在一个二维平面上有两条传送带，每一条传送带可以看成是一条线段。两条传送带分别为线段AB和线段CD。小y在AB上的移动速度为P，在CD上的移动速度为Q，在平面上的移动速度R。现在，小y想从A点走到D点，请问他最少需要走多长时间。

输入格式：

第一行是4个整数，表示A和B的坐标，分别为Ax，Ay，Bx，By。

第二行是4个整数，表示C和D的坐标，分别为Cx，Cy，Dx，Dy。

第三行是3个整数，分别是P，Q，R。

输出格式：

    输出一行一个数，表示小y从A点走到D点的最短时间，保留到小数点后2位。

样例输入：

0 0 0 100

100 0 100 100

2 2 1

样例输出：

136.60

数据范围：

对于30%的数据满足：

1<=Ax,Ay,Bx,By,Cx,Cy,Dx,Dy<=10

1<=P,Q,R<=5

对于100%的数据满足：

1<=Ax,Ay,Bx,By,Cx,Cy,Dx,Dy<=1000

1<=P,Q,R<=10

因为本题的取点所对答案产生的影响不满足单调性，所以我们考虑三分。

因为AB上要取一个点，CD上要取一个点，所以用三分套三分。

第一个三分AB上的点，第二个三分CD上的点使得在取第一次三分出来的点的情况下点A到点D的距离最小。

两个点皆取最优即可得到全局最优。

代码：

```cpp
#include<bits/stdc++.h>
#define eps 0.0000001
using namespace std;
double p,q,r;
struct data
{
	double x,y;
}a,b,c,d;
double dis(data a,data b)
{
	return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
}
double getdis(data ab,double x)//求从第一次三分出来的点到第二次三分出来的点在到点D的距离
{
	data cd;
	cd.x=c.x+(d.x-c.x)*x;
	cd.y=c.y+(d.y-c.y)*x;
	return dis(ab,cd)/r+dis(cd,d)/q;
}
double work(double x)
{
	data ab;
	ab.x=a.x+(b.x-a.x)*x;
	ab.y=a.y+(b.y-a.y)*x;
	double l2=0,r2=1;
	while(r2-l2>eps)//第二次三分
	{
		double midl=(r2+l2*2)/3.0,midr=(r2*2+l2)/3.0;
		if(getdis(ab,midl)<getdis(ab,midr))
		{
			r2=midr;
		}else{
			l2=midl;
		}
	}
	return getdis(ab,r2)+dis(a,ab)/p;
}
int main()
{
	scanf("%lf%lf%lf%lf%lf%lf%lf%lf%lf%lf%lf",&a.x,&a.y,&b.x,&b.y,&c.x,&c.y,&d.x,&d.y,&p,&q,&r);
	double l1=0,r1=1;
	while(r1-l1>eps)//第一次三分
	{
		double midl=(r1+l1*2)/3.0,midr=(r1*2+l1)/3.0;
		if(work(midl)<work(midr))
		{
			r1=midr;
		}else{
			l1=midl;
		}
	}
	printf("%.2lf\n",work(r1));//输出答案
	return 0;
}
```

---

## 作者：brealid (赞：2)

## 4727: 「一本通 1.2 练习 4」传送带

### 题解之前（经验）

三分正确性显然，但是如何想到三分是关键。考场上明显没必要进行正确性证明，但应该写一个程序模拟选择线段上一个点对答案的贡献。意即：你需要打表来做数学题。

---

**引理** 若有三点 $A,B,C$ ，要在 $BC$ 上找一点 $P$，使 $\frac{AP}{v_1} + \frac{PC}{v_2}$ 最小，那么 $\frac{AP}{v_1} + \frac{PC}{v_2}$ 是关于 $BP$ 的单谷函数。（求最小值可以用“三分”解决）  
证明：不会证，但比较显然，可以手动模拟。

**延伸定理** 若有四点 $A,B,C,D$，要在 $AB$ 上找一点 $P$，在 $CD$ 上找一点 $Q$，使 $\frac{AP}{v_1} + \min\{\frac{PQ}{v_2} + \frac{QD}{v_3}\}$ 最小，那么 $\frac{AP}{v_1} + \min\{\frac{PQ}{v_2} + \frac{QD}{v_3}\}$ 是关于 $AP$ 的单谷函数。（$\min\{\frac{PQ}{v_2} + \frac{QD}{v_3}\}$ 即引理求得的结果）（求最小值可以亦用“三分”解决）    
证明：跟引理差不多，也是不会证。如果证出引理，则延伸定理正确性显然。

因此，原问题可以转化为**三分套三分**

---

现在考虑精度问题。由于题目要求保留 2 位小数，$eps$ 可以设为 $10^{-5}$

**套路** 对于一题要求保留 $k$ 位小数，eps 应当精确到 $\operatorname{ceil}(\max\{1.2k, k+3\})$ 位小数以保证通过。 

### 代码

已略去头文件 & I/O优化

```cpp
//     自己选择的路，跪着也要走完。朋友们，虽然这个世界日益浮躁起来，只
// 要能够为了当时纯粹的梦想和感动坚持努力下去，不管其它人怎么样，我们也
// 能够保持自己的本色走下去。                               ——陈立杰
/*************************************
 * @problem:      4727: 「一本通 1.2 练习 4」传送带.
 * @user_id:      1677.
 * @user_name:    zhaoyi20(brealid).
 * @time:         2020-06-01.
 * @language:     C++.
 * @upload_place: XOJ.
*************************************/ 

int p, q, R;

struct point {
    double x, y;
    void readln() {
        x = read<int>();
        y = read<int>();
    }
    point operator + (const point ot) {
        return (point){x + ot.x, y + ot.y};
    }
    point operator / (const double k) {
        return (point){x / k, y / k};
    }
    bool operator == (const point ot) {
        return abs(x - ot.x) < 1e-6 && abs(y - ot.y) < 1e-6;
    }
} A, B, C, D;

bool cmp(point a, point b) {
    return abs(a.x - b.x) < 1e-4 && abs(a.y - b.y) < 1e-4;
}

double dist(point p, point q, int speed) {
    return sqrt((p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y)) / speed;
}

double sol(point a, point mid, point b, int am, int mb) {
    // printf("sol({%.2lf, %.2lf}, {%.2lf, %.2lf}, {%.2lf, %.2lf}, %d, %d) = %.2lf\n", 
    //         a.x, a.y, mid.x, mid.y, b.x, b.y, am, mb, dist(a, mid, am) + dist(mid, b, mb));
    return dist(a, mid, am) + dist(mid, b, mb);
}

double solve(point a, point b, point t, int ab) {
    point m1, m2, l = a, r = b;
    double ans = 1e9;
    while (!cmp(l, r)) {
        m1 = (l + l + r) / 3;
        m2 = (l + r + r) / 3;
        if (sol(a, m1, t, ab, R) < sol(a, m2, t, ab, R)) r = m2, ans = min(ans, sol(a, m1, t, ab, R));
        else l = m1, ans = min(ans, sol(a, m2, t, ab, R));
    }
    return ans;
}

double work(point m) {
    return dist(A, m, p) + solve(D, C, m, q);
}

#define min4(a, b, c, d) min(min(a, b), min(c, d))

signed main() {
    A.readln(); B.readln();
    C.readln(); D.readln();
    p = read<int>();
    q = read<int>();
    R = read<int>();
    if (A == B && C == D)  {
        printf("%.2lf\n", dist(A, D, R));
        return 0;
    }
    if (A == B) {
        printf("%.2lf\n", solve(D, C, A, q));
        return 0;
    }
    if (C == D) {
        printf("%.2lf\n", solve(A, B, D, p));
        return 0;
    }
    point m1, m2, l = A, r = B;
    double ans = 1e9, r1, r2;
    while (!cmp(l, r)) {
        m1 = (l + l + r) / 3;
        m2 = (l + r + r) / 3;
        r1 = work(m1); r2 = work(m2);
        if (r1 < r2) r = m2, ans = min(ans, r1);
        else l = m1, ans = min(ans, r2);
    }
    printf("%.2lf\n", ans);
    return 0;
}

// Create File Date : 2020-06-01
```

---

## 作者：CangMing (赞：2)

正确思路：
# 三分

既然是~~毒瘤~~那么当然不会是三分解法……而且在众多三分题解中，我的算法就像是一股泥石流。

这道题是我做模拟赛的时候做到的，当时也没有想到分治，所以直接写了线段上暴力循环取点……考虑枚举横坐标，计算纵坐标，复杂度是$O(N^2)$。

当然也考虑过离开线段的坐标可以是非整数（详见其他三分 $dalao$ 的题解中给出的证明），所以想过 $+0.1$，但是这样就变成 $O(100N^2)$ 常数是一点都不优秀，害怕,惊惧 $TLE$.（话说 $N=1000$ 的数据，怕什么，~~$O(N^3)$说不定都能过！~~）

代码如下

```cpp
int minabx=min(ax,bx),maxabx=max(ax,bx);//判断A，B的左右上下位置
int mincdx=min(cx,dx),maxcdx=max(cx,dx);//同上
for(int i=minabx;i<=maxabx;i++)
        for(int j=mincdx;j<=maxcdx;j++)
```

所以抱着~~必死的决心~~，测评之后90！！！
然后想到坐标的问题，所以~~加个精度~~？？？把 $++$ 换成 $+0.1$.

$AC$ ……~~一度怀疑是数据太水(大雾)~~.

$Uapate:2019_{11_{7}}$ 仔细想想 三分[三分] 是 $O(N^2\log^2{N})$~~我不知道~~.

以下是 $AC$ 代码

```cpp
#include<cstdio>
#include<cmath>
#include<iostream>
#include<algorithm> 
using namespace std;
double ans=0x3f3f3f3f;
double js(double,double);
double cd(double,double,double,double);//线段长 
void zx();//直线方程 
double abk,abh;
double cdk,cdh;
int ax,ay,bx,by;
int cx,cy,dx,dy;
int p,q,r;
int flag1=0,flag2=0;//常规线段 
int main()
{
    //freopen("closer.in","r",stdin);
    //freopen("closer.out","w",stdout);
    cin>>ax>>ay>>bx>>by;
    cin>>cx>>cy>>dx>>dy;
    cin>>p>>q>>r;
    zx();
    //cout<<abk<<" "<<abh<<" "<<cdk<<" "<<cdh<<endl;
    double minabx=min(ax,bx),maxabx=max(ax,bx);
    double mincdx=min(cx,dx),maxcdx=max(cx,dx); 
    double ans=cd(ax,ay,dx,dy)/r;
    if(flag1==1)
        minabx=min(ay,by),maxabx=max(ay,by);
    if(flag2==1)
        mincdx=min(cy,dy),maxcdx=max(cy,dy);
    for(double i=minabx;i<=maxabx;i+=0.1)
        for(double j=mincdx;j<=maxcdx;j+=0.1)
        	ans=min(js(i,j),ans);
    printf("%.2lf",ans);
    return 0;
}
double js(double x1,double x2)
{
    double ans;
    double y1=x1*abk+abh;
    double y2=x2*cdk+cdh;
    if(flag1==1)
        y1=x1,x1=ax;
    if(flag2==1)
        y2=x2,x2=cx;
    double s1=cd(ax,ay,x1,y1)/p;
    double s2=cd(x1,y1,x2,y2)/r;
    double s3=cd(x2,y2,dx,dy)/q;
    ans=s1+s2+s3;
    return ans;
}
void zx()
{
    if(ax==bx)
        flag1=1,abk=0;//特判，平行于y轴 
    else
    	abk=1.0*(by-ay)/(bx-ax);
    if(cx==dx)
        flag2=1,cdk=0;
    else    
        cdk=1.0*(dy-cy)/(dx-cx);
    if(ay==by)
        abk=0,abh=ay;//特判，平行于x轴 
    else
        abh=ay-abk*ax;
    if(cy==dy)
        cdk=0,cdh=cy;
    else
        cdh=cy-cdk*cx;
    return;
}
double cd(double a,double b,double x,double y)
{
    double l=sqrt((a-x)*(a-x)+(b-y)*(b-y));
    return l;
}
```

当然线段平行于$y$轴的情况要特判，不然会出现 $\div0$ 的监介. 话说~~C++可以除(double)0~~.

后来和其他$OIer$讨论，得知有和我一样的思路(出现了**混分巨兽**)，但是是枚举线段长度（这样就要$+=0.01$），$O(10000N^2)$，直接就 $TLE$ 了.才发现我能做对~~真的是毒瘤~~.

严谨分析之后发现：

坐标为整数，所以线段长度至少为$1$（长度为$0$没有计算的意义）.所以枚举坐标带来的误差相对于正确答案可以忽略不计？？？

不过还是建议写正解，虽然可以
###### ~~面向数据编程~~

溜~~~

---

## 作者：aiyougege (赞：2)

### Solution
设路径为$A\rightarrow E,E\rightarrow F,F\rightarrow D$
那么发现整个路径所花时间为$|AE|,|FD|$的二元函数.

如果我们固定$|AE|$的长度, 那么发现路径长度为$|FD|$的函数并且是一个二次函数的形式.这个东西是一个单峰函数.(写出式子来发现的)

所以我们可以求出当$|AE|$固定时路径的最小值.

然后转化为怎么求出$|AE|$为何值时会取得路径最小值.

可以感性的理解一下它也是一个单峰函数的形式(不会证明)

然后就可以结合[三分法](https://www.luogu.org/problemnew/show/P3382)这道模板题求出答案了.
![](https://cdn.luogu.com.cn/upload/pic/22558.png)
### 具体实现
三分法这个东西我一直都不会, 从我还不知道有三分法这个东西的时候就在用**二分导函数零点**的方式水三分法能做的东西了……233333

具体**二分导函数零点**可以看[我的blog](https://www.luogu.org/blog/aiyoupass/solution-p3382)

**哦, 对了, 数据比较坑会出现直线长度为0的情况这时候就需要特判一下啦!**
~~卡了我好长时间啊~~

### Code
```c++
#include<cmath>
#include<cstdio>
#include<stdlib.h>
#include<iostream>
#define eps 1e-9
using namespace std;

struct Point{
    double x,y;Point(){}Point(double _x,double _y){x=_x,y=_y;}
    Point operator+(const Point& o)const{return Point(x+o.x,y+o.y);}
    void input(){scanf("%lf%lf",&x,&y);}
};
struct Line{
    Point a,b;double dx,dy,s,c,l;
    Line(){}Line(Point _a,Point _b){
        a=_a,b=_b;
        dy=b.y-a.y,dx=b.x-a.x;
        l=sqrt(dx*dx+dy*dy),s=dy/l,c=dx/l;
    }
};
Point haha(Line& a,double b){if(!a.l)return a.a;return Point(a.a.x+b*a.c,a.a.y+b*a.s);}

Point a,b,c,d,e,f;
double p,q,r;int n;
Line ab,cd,ef;


double Check(double x){
    f=haha(cd,x),ef=Line(e,f);
    return ef.l/q+(cd.l-x)/r;
}

double check(double x){
    e=haha(ab,x);
    double L=0,R=cd.l,mid;
    for(int i=1;i<=50;++i){
        mid=(L+R)/2;
        if(Check(mid+eps)-Check(mid-eps)>0)R=mid;
        else L=mid;
    }
    return x/p+Check(L);
}

int main(){
    a.input(),b.input(),c.input(),d.input(),
    ab=Line(a,b),cd=Line(c,d);
    scanf("%lf%lf%lf",&p,&r,&q);
    double l=0.0,R=ab.l,mid;
    if(ab.l>eps)
    for(int i=1;i<=50;++i){
        mid=(l+R)/2;
        if(check(mid+eps)-check(mid-eps)>0)R=mid;
        else l=mid;
    }
    printf("%.2f",check(l));
    return 0;
}
```

---

## 作者：Durancer (赞：1)

#### 题目分析

给定二维坐标系上的两条线段，及上面的速度，还有在正常情况下的行走速度，求两个点之间如何行走时间是最短的

#### 思路

市面上很多三分套三分，模拟退火，粒子群优化算法什么的反正我不会QWQ,看看这个题目的数据范围还是可以枚举暴力的，而且这个思路的复杂度不会因为距离而改变

首先，我们可以想到的是，我们肯定要先从$AB$上走上一段路程（或者不走），然后再在平地中走上一段（或者不走），最后在$CD$上走上一段路程(或者不走)

那么，我们就可以分成老多老多个小的线段来求解即可，用千分来求解这个问题

一开始的时候，先设定一个固定的分段数，然后，把每一条线的横纵坐标都平均的分配成$N$份来求解，这样就可以满足上面的思想，并且可以简单的通过枚举来求得答案

那么先上图理解一下吧

![](https://cdn.luogu.com.cn/upload/image_hosting/0233q6ba.png)

这个就是其中的一种情况，我们先以$A$为起点，一直到$B$的每一个断点所连接成的线段的长度。

然后再以$D$为起点，分别算出从$D$到$C$的每一个断点雨$D$所练成的线段的长度，并且再处理一下时间

枚举的时候，再加上再空白处行走消耗的时间，取一个最小值即可

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<queue>
#include<stack>
#include<map>
using namespace std;
const int N=3000;
struct node{
	double x,y;
};
node a,b,c,d;
double P,Q,R;
double ABx,ABy,CDx,CDy; 
double strx[N+10],stry[N+10];//两条线段上的点分别都进行拆分，然后每个点分别寻找匹配的，A-i~~~~j-B；
//分为三段过程，一段走AB,一段走平地,一段走CD  
double endx[N+10],endy[N+10]; 
double cost1[N+10],cost2[N+10];//AB,CD,线段上的走的距离所消耗的时间 
double ans=1e10;
double gougu(int a,int b)//求两点距离 
{
	return sqrt((strx[a]-endx[b])*(strx[a]-endx[b])+(stry[a]-endy[b])*(stry[a]-endy[b]));//求两点的公式距离 
}
void prepare()
{
	//不需要取绝对值，因为这个可能是一个反向斜着的，所以顺其自然即可 
	ABx=(b.x-a.x)/N;
	ABy=(b.y-a.y)/N;
	CDx=(d.x-c.x)/N;
	CDy=(d.y-c.y)/N;//算出每一个段的长度 
//	printf("%.2lf %.2lf\n",ABx,ABy);
//	printf("%.2lf %.2lf\n",CDx,CDy);
}
int main()
{
	scanf("%lf%lf%lf%lf",&a.x,&a.y,&b.x,&b.y);
	scanf("%lf%lf%lf%lf",&c.x,&c.y,&d.x,&d.y);
	scanf("%lf%lf%lf",&P,&Q,&R);
	prepare();
	for(int i=0;i<=N;i++)//原点也是一个点 
	{
		strx[i]=a.x+ABx*i;
		stry[i]=a.y+ABy*i;
		cost1[i]=sqrt(ABx*i*i*ABx+ABy*i*i*ABy)/P;
		//cout<<"start x= "<<strx[i]<<" start y= "<<stry[i]<<" cost1= "<<cost1[i]<<endl; 
	}
	for(int i=0;i<=N;i++)//必须是从0开始找，把原点也包进去 
	{
		endx[i]=d.x-CDx*i;
		endy[i]=d.y-CDy*i;//sb错误 endx[i]=d.y-CDy*i
		cost2[i]=sqrt(CDx*i*i*CDx+CDy*i*i*CDy)/Q;
		//cout<<"end x= "<<endx[i]<<" end y= "<<endy[i]<<" cost2= "<<cost2[i]<<endl; 
	}
	for(int i=0;i<=N;i++)
		for(int j=0;j<=N;j++)
		{
			double k=cost1[i]+cost2[j]+(gougu(i,j)/R);
			ans=min(ans,k);
			//printf("%.2lf\n ",k);
		}
	printf("%.2lf\n",ans);
	return 0;
}
```


---

## 作者：swiftc (赞：1)

~~这道题用什么三分套三分、模拟退火算法啊，明明暴力都可以过~~

很显然，从A走到D的最短路一定是在AB上走一段，在平面上走一段，再在CD上走一段，所以我们就可以枚举在AB走上的长度和在CD走上的长度

所以我们之间把AB和CD分成5000段，枚举走了几段就可以了

另外还要注意A，B点可能重合

__代码：__

```cpp
#pragma GCC optimize(2)
#include<bits/stdc++.h>
#define min(a,b) a>b?b:a
using namespace std;
int ax,ay,bx,by,cx,cy,dx,dy,p,q,r;
double ll1,ll2;
inline double dis(double x1,double x2,double yyy,double y2){
	return sqrt((x1-x2)*(x1-x2)+(yyy-y2)*(yyy-y2));
	//计算两点间的欧几里得距离 
} 
inline double getVaule(double l1,double l2){
	double x=double(ax)+l1/ll1*double(bx-ax),y=double(ay)+l1/ll1*double(by-ay); 
	double xx=double(cx)+(ll2-l2)/dis(cx,dx,cy,dy)*double(dx-cx),yy=double(cy)+(ll2-l2)/ll2*double(dy-cy);
	if(bx==ax)x=0,y=0;//防止A,B点重合的情况 
	return l1/double(p)+dis(x,xx,y,yy)/double(r)+l2/double(q);
	//计算需要的时间 
}
#define gv getVaule
int main(){
	scanf("%d%d%d%d",&ax,&ay,&bx,&by);
	scanf("%d%d%d%d",&cx,&cy,&dx,&dy);
	scanf("%d%d%d",&p,&q,&r);
	ll1=dis(ax,bx,ay,by);
	ll2=dis(cx,dx,cy,dy);
	double l1=dis(ax,bx,ay,by)/5000,l2=dis(cx,dx,cy,dy)/5000,ans=1e8;
	for(register int i=0;i<=5000;i++){
	for(register int j=0;j<=5000;j++){
		ans=min(ans,getVaule(double(i)*l1,double(j)*l2));
	}
	}
	//分成5000段然后枚举 
	printf("%0.2lf",ans);
	return 0;
} 
```


---

## 作者：crashed (赞：1)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[洛谷题目](https://www.luogu.org/problem/P2571)。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[校内OJ](http://61.186.173.89:1024/contest/159/problem/3)。
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们可以确定，lxhgww的最优移动一定满足规律——  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先从$A$沿着$AB$上走一截，再离开$AB$直线走到$CD$上，最后沿着$CD$走到$D$点。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设lxhgww在$AB$上走了$x$，$CD$上走了$y$；从$A$出发沿着$AB$走$a$到达$G(a)$，从$D$出发沿着$CD$走$b$到达$H(b)$。平面上两点$(x_1,y_1),(x_2,y_2)$间的距离为$dis((x_1,y_1),(x_2,y_2))$则他花费的时间为：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$\displaystyle f(x,y)=\frac x P + \frac{dis(G(x),H(y))}{R}+\frac{y}{Q}$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然的，这个函数只跟$x$和$y$有关。假设我们已经确定了$x$的值，我们怎么找到最优的$y$呢？我们不难想到用三分（不会证明，感受一下吧）。当$x$不确定的时候，我们同样可以通过三分找到最优的$x$，进而计算出答案。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意线段可能会退化成点，数据中有这样的两组需要特殊处理。  
# 代码
```cpp
#include <cmath>
#include <cstdio>
#include <iostream>
using namespace std;

//#define double long double

const double eps = 1e-11;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

template<typename _T>
_T ABS( const _T a )
{
	return a < 0 ? -a : a;
}

bool equal( const double a, const double b )
{
	return ABS( a - b ) <= eps;
}

//浮点数误差判等

struct point
{
	double x, y;
	point(){}
	point( const double X, const double Y ){ x = X, y = Y; }
	point operator + ( const point & other ) const { return point( x + other.x, y + other.y ); }
	bool operator == ( const point & other ) const { return equal( x, other.x ) && equal( y, other.y ); }
};

double dist( const point &x, const point &y )
{
	return sqrt( ( x.x - y.x ) * ( x.x - y.x ) + ( x.y - y.y ) * ( x.y - y.y ) );
}

struct segment
{
	point st, en;
	segment(){}
	segment( const double sx, const double sy, const double ex, const double ey ){ st = point( sx, sy ), en = point( ex, ey ); }
	segment( const point x, const point y ){ st = x, en = y; }
	double length() const { return dist( st, en ); }
	point pos( const double len ) const
	{
		double l = length(), k = len / l;
		return point( st.x + ( en.x - st.x ) * k, st.y + ( en.y - st.y ) * k );
	}
	bool isPoint() const { return st == en; }
}AB, CD;

double P, Q, R;

double cal( const point ABPos, const point CDPos )
{
	return dist( ABPos, AB.st ) / P + dist( CDPos, ABPos ) / R + dist( CDPos, CD.en ) / Q;
}

double E( const point ABPos )
{
	if( CD.isPoint() ) return cal( ABPos, CD.st );
	point lPos, rPos;
	double l = 0, r = CD.length(), lmid, rmid;
	while( r - l > eps )
	{
		lmid = ( l * 2 + r ) / 3, rmid = ( l + r * 2 ) / 3;
		lPos = CD.pos( lmid ), rPos = CD.pos( rmid );
		if( cal( ABPos, lPos ) < cal( ABPos, rPos ) ) r = rmid;
		else l = lmid;
	}
	return cal( ABPos, CD.pos( l ) );
}

int main()
{
	scanf( "%lf %lf %lf %lf", &AB.st.x, &AB.st.y, &AB.en.x, &AB.en.y );
	scanf( "%lf %lf %lf %lf", &CD.st.x, &CD.st.y, &CD.en.x, &CD.en.y );
	scanf( "%lf %lf %lf", &P, &Q, &R );
	if( AB.isPoint() ) return ! printf( "%.2lf\n", E( AB.st ) );
	point lPos, rPos;
	double l = 0, r = AB.length(), lmid, rmid;
	while( r - l > eps )
	{
		lmid = ( l * 2 + r ) / 3, rmid = ( l + r * 2 ) / 3;
		lPos = AB.pos( lmid ), rPos = AB.pos( rmid );
		if( E( lPos ) < E( rPos ) ) r = rmid;
		else l = lmid;
	}
	printf( "%.2lf\n", E( AB.pos( l ) ) );
	return 0;
}
```

---

## 作者：Erina (赞：1)

## 思路:SA模拟退火

## ~~复杂度$O(1)$~~

### 为什么是SA?

首先一看不受到整数影响(整数域上SA是要死人的)

SA在解决二维问题是尤其的高效.就算是单峰函数也是如此......因为SA同时对二维进行影响.

然后强制SA就行了......

为什么另一位SA大佬代码那么长......

```cpp
#include<iostream>
#include<cstdlib>
#include<iomanip>
#include<cmath>
using namespace std;
double ax,bx,ay,by,cx,cy,dx,dy,p,q,r,ans=0x7fffffff;
const double deta=0.97;
double dis(double x1,double y1,double x2,double y2){return sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));}
double rd(double x1,double y1,double x2,double y2){return dis(ax,ay,x1,y1)/p+dis(x1,y1,x2,y2)/r+dis(x2,y2,dx,dy)/q;}
double rng(){return 2*rand()-RAND_MAX;}//随机函数加负数
void SA(){//这一片都是板子
	double lab=0.5,lcd=0.5;
	double temp=2000;
	while(temp>1e-7){
		double ab=lab+rng()*0.00003*temp,cd=lcd+rng()*0.00003*temp;
		ab=min(ab,1.0),ab=max(ab,0.0),cd=min(cd,1.0),cd=max(cd,0.0);
		double x1=ax+(bx-ax)*ab, y1=ay+(by-ay)*ab,x2=cx+(dx-cx)*cd,y2=cy+(dy-cy)*cd,as=rd(x1,y1,x2,y2);
		if(as<ans)ans=as,lab=ab,lcd=cd;
		temp*=deta;
	}
}
int main(){
	srand(19260817);//暴力膜蛤不可避
	cin>>ax>>ay>>bx>>by>>cx>>cy>>dx>>dy>>p>>q>>r;
	SA();
	cout<<fixed<<setprecision(2)<<ans;
}
```

---

## 作者：一只书虫仔 (赞：0)

#### Description

> 给定两条线段 AB，CD，在 AB 上移动速度为 $p$，在 CD 上移动速度为 $q$，其他地方移动速度为 $r$，求从 A 到 D 需要的最小速度。

#### Solution

定义 $d(X,M)$ 为点 X 与点 M 之间的距离。

首先一个显然的结论，在 AB 上找一点 P，在 CD 上找一点 Q，答案即为 $\frac{d(A,P)}p+\frac{d(P, Q)}r+\frac{d(Q, D)} q$。

我们假设 P 点坐标是确定的，那么也就是我们要去找 $\frac{d(P, Q)}r+\frac{d(Q, D)} q$ 的最小值，假设这是一个函数，用  Geogebra 画一下图试试，不难发现会存在一个值（或者边界）是最值，也就是他符合区间内二次函数的性质。

那我们回到 P 不固定的情况下，对于一个点 ，我们去找 $\frac{d(A,P)}p+\left(\frac{d(P, Q)}r+\frac{d(Q, D)} q\right)$ 的最小值，括号内的可以通过我们发现的性质三分得到，而上面这个东西，也满足二次函数区间内的性质，也就是说，我们可以外层三分 P，然后 check 函数里三分 Q 即可。

上面说的比较反，下面正着梳理一遍：三分 P，check 函数的过程中 $\frac{d(P, Q)}r+\frac{d(Q, D)} q$ 可以通过三分 Q。

由于作者不怎么会证明凸性，因此文中只能通过画图的方法。

---


# [TJOI2012] 防御

## 题目描述

在一个塔防小游戏中，有很多防线。每条防线由一排 $n$ 个独立的防御体 $[1 : n]$ 进行防御。

游戏过程中，会不断有敌人对防线进行攻击，每次攻击会指定防御体 $[l : r]$ 进行攻击力为 $a$ 的攻击。第一防线具有护甲，护甲承受攻击后，对应的防御体所受到的伤害为攻击力，但护甲承受的伤害总量到达一定程度后就会破碎，此时防御体所受的伤害加倍。目前第一防线的力量充足，玩家致力于对后面的防线的建设，不过为确认游戏进度和第一防线的情况，玩家会不时地将鼠标移动到第一防线的某个防御体上，以查看其所受到的伤害。


## 说明/提示

**【样例解释】**

3/0 1/0 4/0 1/0 2/0

[A 1 3 2]

1/2 2 2/2 1/0 2/0

[Q 2] ! 2

[A 1 4 1]

3 4 1/3 1 2/0

[Q 1] -> 3

[A 1 4 1]

5 6 4 3 2/0

[Q 2] -> 6

[Q 1] -> 5

**【数据范围】**

$30 \%$ 的数据， $q \le 10^3$。

$100 \%$ 的数据，$1 \le n \le 10^5$，$1 \le q \le 10^5$，$0 \le p_i \le 10^6$，$0 \le a \le 10^4$。


## 样例 #1

### 输入

```
5 7
3 1 4 1 2
A 1 3 2
Q 2
A 1 4 1
Q 1
A 1 4 1
Q 2
Q 1```

### 输出

```
16```

# 题解

## 作者：Minclxc (赞：7)

下面的题解管理员可以删了，改题了。

如果对于盾没爆前或者盾都是0的情况，一个线段树就可以了

现在问题是盾可以挡多少伤害（样例中2号1的盾可以挡2伤害）

这个可以直接在线段树上向下搜，因为每个叶子节点最多只会盾爆一次，所以效率是O(nlgn)的

具体操作是维护min，修改的时候区间减（需要lazy），每次找会爆盾的子树，爆盾的min改为maxint就好了

查询就是查路径上的伤害总和\*2-盾挡的伤害或者伤害总和（盾没爆）

维护sum，不用下放（不用lazy），查询的时候统计即可

```cpp
#include<cstdio>
using namespace std;
#define fo(a,b,c) for(int a=b;a<=c;a++)
#define LL long long
int read(){
    int a=0,f=0;char c=getchar();
    for(;c<'0'||c>'9';c=getchar())if(c=='-')f=1;
    for(;c>='0'&&c<='9';c=getchar())a=a*10+c-'0';
    return f?-a:a;
}
int min(int a,int b){return a<b?a:b;}
const int N=1e5+1,mo=1e9+9;//模数是1e9+9不是1e9+7
LL sum[N<<2],lazy[N<<2],boom[N],d[N],minx[N<<2];
void pushup(int rt){
    minx[rt]=min(minx[rt<<1],minx[rt<<1^1]);
}
void pushdown(int rt){
    if(minx[rt<<1]!=2e9)minx[rt<<1]-=lazy[rt];
    if(minx[rt<<1^1]!=2e9)minx[rt<<1^1]-=lazy[rt];
    lazy[rt<<1]+=lazy[rt],lazy[rt<<1^1]+=lazy[rt];
    lazy[rt]=0;
}
void build(int l,int r,int rt){
    if(l==r){
        d[l]=read(); 
        minx[rt]=d[l]?d[l]:2e9;
        return;
    }
    int m=l+r>>1;
    build(l,m,rt<<1);
    build(m+1,r,rt<<1^1);
    pushup(rt);
}
void change(int l,int r,int rt,int s){//除了这个函数都是线段树的函数，这个函数就是搜爆盾的函数
    if(l==r){d[l]=d[l]-minx[rt]+s;minx[rt]=2e9;boom[l]=1;return;}//记录盾挡的伤害和爆炸标记
    int m=l+r>>1;
    if(lazy[rt])pushdown(rt);
    if(s>=minx[rt<<1])change(l,m,rt<<1,s);
    if(s>=minx[rt<<1^1])change(m+1,r,rt<<1^1,s);
    pushup(rt);
}
void add(int l,int r,int rt,int L,int R,int c,LL s){
    if(L<=l&&r<=R){
        sum[rt]+=c;
        if(minx[rt]<=c)change(l,r,rt,c);
        if(minx[rt]!=2e9)minx[rt]-=c,lazy[rt]+=c;
        return;
    }
    s+=sum[rt];
    if(lazy[rt])pushdown(rt);
    int m=l+r>>1;
    if(L<=m)add(l,m,rt<<1,L,R,c,s);
    if(m<R)add(m+1,r,rt<<1^1,L,R,c,s);
    pushup(rt);
}
int query(int l,int r,int rt,int p){
    if(l==r)return sum[rt]%mo;
    int m=l+r>>1;
    if(p<=m)return(sum[rt]+query(l,m,rt<<1,p))%mo;
    else return(sum[rt]+query(m+1,r,rt<<1^1,p))%mo; 
}
int main(){
    int n=read(),q=read();LL ans=0;
    build(1,n,1);
    fo(i,1,q){
        scanf("\n");
        if(getchar()=='A'){
            int L=read(),R=read(),c=read();
            add(1,n,1,L,R,c,0);
        }
        else{
            int x=read();
            if(boom[x])ans=(ans+query(1,n,1,x)*2-d[x]+mo)%mo;
            else ans=(ans+query(1,n,1,x))%mo; 
        }
    }
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：ForwardStar (赞：4)

**不用线段树、平衡树、分块**  
离线处理+树状数组+二分查找+优先队列。  
我们可以离线处理这些询问，从左到右依次计算每个防御体询问对答案的贡献。  
![pic](https://cdn.luogu.com.cn/upload/image_hosting/848ygapd.png)  
首先分析样例，我们先将目光放在第一个防御体那一列，其中有两次询问，一次在第二次攻击后，一次在第三次攻击后。我们发现，每次询问对答案作出的贡献就是破甲前的伤害总和加上破甲到询问时的总和的二倍。  
设 $sum[i]$ 为这个防御体前 $i$ 次攻击收到的伤害之和， 第 $k$ 次攻击时破甲，这次询问时的上一次攻击是 $j$，则这次询问的贡献为 $2\times sum[j]-sum[k]$，如果所有攻击没破甲，贡献为 $sum[j]$。  
破甲的这个位置可以使用二分查找快速找出，因为这里的前缀和满足单调性。
那我们如何计算接下来的防御体呢？我们发现第一、二两个防御体受到的伤害完全一样，前一个防御体的伤害前缀和是可以直接搬过来的，但第四个防御体和第三个不一样，因为有一个伤害区间到第三截止了，此时我们要退出的伤害区间减回来，同时也是要加入新进入的伤害区间。  
按照每个区间左端点排序，可以按顺序依次加入区间。区间的退出可以用优先队列维护，这些修改操作可以使用树状数组维护，此时二分查找也需要变为树状数组上的二分查找了，具体实现看代码。  
时间复杂度 $O(n\log n)$。
```cpp
#include<iostream>
#include<cmath> 
#include<queue>
#include<algorithm>
#define int long long 
using namespace std;
const int N = 1e5 + 55, mod = 1e9 + 9, M = 1 << 17;
int n, qq, idx;
int ap[N];
int tr[N << 2];
vector<int> ask[N];
priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > q;
struct djx {
	int l, r, val, id;
} a[N];
//树状数组模板 
int lowbit(int x) {
	return x & (-x);
}
void update(int x, int p) {
	while (p <= M) {
		tr[p] += x;
		p += lowbit(p); 
	}
}
int gets(int p) {
	int res = 0;
	while (p) {
		res += tr[p];
		p -= lowbit(p);
	}
	return res;
}
//树状数组上的二分查找 
int find(int k) {
	int res = 0, sum = 0;
	for (int i = 17; i >= 0; i--) {
		if(sum + tr[(res + (1 << i))] < k) {
			res += (1 << i);
			sum += tr[res];	
		}
	}
	return res + 1; 
}
bool cmp(djx x, djx y) {
	return x.l < y.l;
}
signed main() {
	scanf("%lld%lld", &n, &qq);	
	for (int i = 1; i <= n; i++) scanf("%lld", &ap[i]);
	for (int i = 1; i <= qq; i++) {
		char op[3];
		scanf("%s", op);
		if (op[0] == 'A') {
			idx++;
			scanf("%lld%lld%lld", &a[idx].l, &a[idx].r, &a[idx].val);
			a[idx].id = idx;
		}
		else {
			int x;
			scanf("%lld", &x);
			//vector存储询问 
			ask[x].push_back(idx);
		}
	}
	int ans = 0;
	int now = 1;
	sort(a + 1, a + 1 + idx, cmp);
	for (int i = 1; i <= n; i++) {
		//加入区间 
		while (a[now].l == i) {
			update(a[now].val, a[now].id);
			q.push({a[now].r, now});
			now++;
		}
		//退出区间 
		while (q.size() && q.top().first < i) {
			int id = q.top().second;
			update(a[id].val * -1, a[id].id);
			q.pop();
		}
		if (ask[i].empty()) continue;
		int k = find(ap[i]);
		for (int j = 0; j < ask[i].size(); j++) {
			if (k >= ask[i][j]) ans += gets(ask[i][j]);
			else ans += gets(ask[i][j]) * 2 - gets(k);
			ans %= mod;
		} 
	}
	printf("%lld\n", ans);
}

```


---

## 作者：MspAInt (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P2667)

大力分块万岁！

考虑分块，记录块内最小盾值以及全块伤害。

对于完整块：一旦发现全块伤害超过最小盾值直接重构（有至少一个盾破了），其中破盾状态盾值标记为 $\infty$。

对于不完整块：重构然后更新数值。

询问的话重构完直接返回。

正确性显然。

这时候就会有人问了：你这复杂度不对啊，要是每一次修改每个块总是破一个盾，那不就卡到 $\Theta(n)$ 了吗？

然而一个块至多只会重构 $\sqrt{n}$ 次（毕竟只有这么多防御体），所以总共只能卡到 $\Theta(n\sqrt n)$，剩下的操作仍然是 $\Theta(\sqrt n)$，所以事实上总复杂度为 $\Theta(q\sqrt n+n\sqrt n)=\Theta(n\sqrt n)$（$n$ 和 $q$ 同阶）。

详见代码：

```cpp
#include<bits/stdc++.h>
#define inf 1e9
using namespace std;
const int N=1e5+10,M=1e3+10,mod=1000000009;
int n,q,len,cnt,ans,a[N],d[N],tag[M],Min[M],st[M],ed[M],bar[N];
void build(int k){//重构块
	Min[k]=inf;
	for(int i=st[k];i<=ed[k];i++){
		if(d[i]==inf)a[i]+=tag[k]*2;
		else if(d[i]-tag[k]<=0)d[i]=inf,a[i]+=tag[k];
		else d[i]-=tag[k],a[i]+=tag[k];
		Min[k]=min(Min[k],d[i]);
	}
	tag[k]=0;
	return;
}
void attack(int x,int y,int z){
	int l=bar[x],r=bar[y];
	if(l==r){
		build(l);
		for(int i=x;i<=y;i++){
			if(d[i]==inf)a[i]+=z*2;else a[i]+=z,d[i]-=z;
			if(d[i]<=0)d[i]=inf;
			Min[l]=min(Min[l],d[i]);
		}
		return;
	}
	for(int i=l+1;i<=r-1;i++){//完整块
		tag[i]+=z;
		if(tag[i]>=Min[i])build(i);
	}
	build(l);//不完整块
	for(int i=x;i<=ed[l];i++){
		if(d[i]==inf)a[i]+=z*2;else a[i]+=z,d[i]-=z;
		if(d[i]<=0)d[i]=inf;
		Min[l]=min(Min[l],d[i]);
	}
	build(r);
	for(int i=st[r];i<=y;i++){
		if(d[i]==inf)a[i]+=z*2;else a[i]+=z,d[i]-=z;
		if(d[i]<=0)d[i]=inf;
		Min[r]=min(Min[r],d[i]);
	}
	return;
}
int query(int k){
	build(bar[k]);
	return a[k];
}
signed main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	scanf("%d%d",&n,&q);
	for(int i=1;i<=n;i++){
		scanf("%d",&d[i]);
		if(!d[i])d[i]=inf;
	}
	len=sqrt(n);cnt=n/len+bool(n%len);
	for(int i=1;i<=cnt;i++){
		st[i]=ed[i-1]+1;ed[i]=min(n,i*len);
		Min[i]=inf;
		for(int j=st[i];j<=ed[i];j++)
			bar[j]=i,Min[i]=min(Min[i],d[j]);
	}
//	for(int j=1;j<=cnt;j++){
//		for(int k=st[j];k<=ed[j];k++){
//			printf("%d,%d ",a[k],d[k]==inf?0:d[k]);
//		}
//		printf("(%d)|",tag[j]);
//	}
//	puts("");
	for(int i=1;i<=q;i++){
		char ch;int x,y,z;
		cin>>ch;
		if(ch=='A')scanf("%d%d%d",&x,&y,&z),attack(x,y,z);
		else if(ch=='Q')scanf("%d",&x),(ans+=query(x))%=mod;
//		if(ch=='Q')printf("%d\n",query(x));
//		else{
//			for(int j=1;j<=cnt;j++){
//				for(int k=st[j];k<=ed[j];k++){
//					printf("%d,%d ",a[k],d[k]==inf?0:d[k]);
//				}
//				printf("(%d)|",tag[j]);
//			}
//			puts("");
//		}
	}
	printf("%d\n",ans);
    return 0;
}
```

[record](https://www.luogu.com.cn/record/108632633)

---

## 作者：iyaang (赞：3)

# 【TJOI2012】防御

[题目链接](https://www.luogu.com.cn/problem/P2667)

小清新数据结构题，题解区为啥清一色两棵线段树。

考虑分块，维护两个数组：$tag$ 和 $minx$ 分别记录整块的累计伤害和当前护盾最小值。当发现有护盾值为负数时，将它赋值为 $INF$，然后暴力重新扫块内并下放 $tag$，对于盾值为 $INF$ 的累加 $tag \times 2$，否则就累加 $tag$ 即可。

对于一个点最多重扫一次，重扫一次复杂度为 $O(\sqrt N)$ ，总复杂度为 $O(N \sqrt N)$，事实上因为一次块内重扫可能将多个盾值标记为 $INF$，所以实际跑起来一般达不到上界。

需要注意的地方是对盾值做减法的时候要先判断当前盾值与 $tag$ 的关系，如果已经爆盾了只不过伤害还寄存在 $tag$ 里，就应该先下放 $tag$。

~~跑的比某些线段树还要快吗？~~

$Code$ 
```cpp
#include<bits/stdc++.h>
#define int long long
#define MAX 100010
#define INF 999999999
#define mod 1000000009
using namespace std;

inline int read()
{
	int s=0;
	char c=getchar();
	while(!isdigit(c)) c=getchar();
	while(isdigit(c)) s=(s<<1)+(s<<3)+(c^48),c=getchar();
	return s;
}

int n,m;
char op;
int blo,bn;
int a[MAX],l[MAX],r[MAX],pos[MAX],tag[MAX],minx[MAX];

inline void block()
{
	n=read(),m=read();
	memset(minx,0x3f,sizeof minx);
	for(int i=1;i<=n;i++)
	{
		a[i]=read();
		if(a[i]==0) a[i]=INF;
	}
	blo=sqrt(n);bn=(n-1)/blo+1;
	for(int i=1;i<=bn;i++)
		l[i]=(i-1)*blo+1,r[i]=i*blo;
	r[bn]=n;
	for(int i=1;i<=bn;i++)
		for(int j=l[i];j<=r[i];j++)
			pos[j]=i,minx[i]=min(minx[i],a[j]);
	return;
}

int ans[MAX];
inline void spread(int x)
{
	minx[x]=INF;
	for(int i=l[x];i<=r[x];i++)
	{
		if(a[i]==INF) ans[i]+=2*tag[x];
		else ans[i]+=tag[x],a[i]-=tag[x];
		if(a[i]<=0) a[i]=INF;
		minx[x]=min(minx[x],a[i]);
	}
	tag[x]=0;
	return;
}
inline void change(int L,int R,int k)
{
	int p=pos[L],q=pos[R];
	if(p==q)
	{
		if(minx[p]<=tag[p]+k) spread(p);   //先判断是否需要下放!!!
		for(int i=L;i<=R;i++)
		{
			if(a[i]==INF) ans[i]+=2*k;
			else a[i]-=k,ans[i]+=k;	
			minx[p]=min(minx[p],a[i]);			
			if(a[i]<=0) a[i]=INF;
		}
		if(minx[p]<=tag[p]) spread(p);
	}
	else
	{
		for(int i=p+1;i<=q-1;i++)
		{
			if(minx[i]<=tag[i]+k) spread(i);
			tag[i]+=k;
		}
		if(minx[p]<=tag[p]+k) spread(p);
		for(int i=L;i<=r[p];i++)
		{
			if(a[i]==INF) ans[i]+=2*k;
			else a[i]-=k,ans[i]+=k;
			minx[p]=min(minx[p],a[i]);
			if(a[i]<=0) a[i]=INF;
		}
		if(minx[p]<=tag[p]) spread(p);
		if(minx[q]<=tag[q]+k) spread(q);
		for(int i=l[q];i<=R;i++)
		{
			if(a[i]==INF) ans[i]+=2*k;
			else a[i]-=k,ans[i]+=k;
			minx[q]=min(minx[q],a[i]);
			if(a[i]<=0) a[i]=INF;
		}
		if(minx[q]<=tag[q]) spread(q);
	}
	return;
}
inline int getsum(int x)
{
	int p=pos[x];
	if(a[x]==INF) return ans[x]+2*tag[p];
	return ans[x]+tag[p];
}

int x,y,k;
int answer;
inline void work()
{
	for(int i=1;i<=m;i++)
	{
		cin>>op;
		switch(op)
		{
			case 'A':x=read(),y=read(),k=read();change(x,y,k);break;
			case 'Q':x=read();answer+=getsum(x);break;
		}
	}
	cout<<answer%mod;
	return;
}

signed main()
{
	block();
	work();
	return (0-0);
}
```

---

## 作者：GNAQ (赞：3)

考虑使用两颗线段树

一颗维护每个塔当前剩余多少甲，序列区间 `min` 和区间减法。

一颗维护累积伤害，区间加法单点查。

每次 `A` 之后，如果第一颗里面有 $\leqslant 0$ 的塔，就把第二颗里这个塔当前的累积伤害提取出来，然后在这个树上把这个塔的累积伤害清零，然后把这个塔标为破甲。

然后回答的时候直接在第二颗里查，如果破甲，把查询结果 $\times 2$ 再加上提取过的累积伤害。

思路很清楚，也挺好写的，但是由于很多地方要重复码，所以码量很大，不过这个做法可以把两棵树分开调试，所以总体是不难调的。

如果你开 `long long` ，树上信息其实不会爆，随便取取模就行。

```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<cstdlib>
#define ll long long
using namespace std;

int n,m,opt,seq[100010];
int mul2[100010]; ll dat[100010],allans;

template<typename int_t>
void readx(int_t& x)
{
	x=0; int_t k=1; char ch=0;
	while (ch<'0' || ch>'9') { ch=getchar(); if (ch=='-') k=-1; }
	while (ch>='0' && ch<='9') { x=x*10+ch-'0'; ch=getchar(); }
	x*=k;
}

namespace SGT1
{
	#define LCH (inx<<1)
	#define RCH (inx<<1|1)
	
	struct Seg_Tree
	{
		ll minv,tag;
		int l,r,mid;
	}tree[400010];
	int _val,_pos,lx,rx;
	
	void BuildTree(int inx,int lxx,int rxx,int* seq)
	{
		tree[inx].l=lxx; tree[inx].r=rxx; tree[inx].mid=(lxx+rxx)>>1;
		if (lxx==rxx)
		{
			tree[inx].minv=seq[lxx];
			return;
		}
		BuildTree(LCH,lxx,tree[inx].mid,seq);
		BuildTree(RCH,tree[inx].mid+1,rxx,seq);
		tree[inx].minv=min(tree[LCH].minv,tree[RCH].minv);
	}
	
	void Pushdown(int inx)
	{
		int tmp=tree[inx].tag; tree[inx].tag=0;
		tree[LCH].tag+=tmp; tree[RCH].tag+=tmp;
		tree[LCH].minv+=tmp;
		tree[RCH].minv+=tmp;
	}
	
	void Upd(int inx)
	{
		if (tree[inx].l>=lx && tree[inx].r<=rx)
		{
			tree[inx].minv+=_val;
			tree[inx].tag+=_val;
			return;
		}
		if (tree[inx].tag) Pushdown(inx);
		if (lx<=tree[inx].mid) Upd(LCH);
		if (rx>tree[inx].mid) Upd(RCH);
		tree[inx].minv=min(tree[LCH].minv,tree[RCH].minv);
	}
	
	int Qry_Min_Pos(int inx)
	{
		if (tree[inx].l==tree[inx].r) 
		{
			tree[inx].minv=20000000000000000LL;
			return tree[inx].l;
		}
		if (tree[inx].tag) Pushdown(inx);
		int ret;
		if (tree[LCH].minv<=0) ret=Qry_Min_Pos(LCH);
		else ret=Qry_Min_Pos(RCH);
		tree[inx].minv=min(tree[LCH].minv,tree[RCH].minv);
		return ret;
	}
	
	#undef LCH
	#undef RCH
};

namespace SGT2
{
	#define LCH (inx<<1)
	#define RCH (inx<<1|1)
	const ll mod=1000000009;
	
	struct Seg_Tree
	{
		ll val,tag;
		int l,r,mid;
	}tree[400010];
	int _val,_pos,lx,rx;
	
	void BuildTree(int inx,int lxx,int rxx)
	{
		tree[inx].l=lxx; tree[inx].r=rxx; tree[inx].mid=(lxx+rxx)>>1;
		if (lxx==rxx) return;
		BuildTree(LCH,lxx,tree[inx].mid);
		BuildTree(RCH,tree[inx].mid+1,rxx);
	}
	
	void Pushdown(int inx)
	{
		ll tmp=tree[inx].tag; tree[inx].tag=0;
		tree[LCH].tag+=tmp; tree[RCH].tag+=tmp;
		tree[LCH].val=(tree[LCH].val+(tree[LCH].r-tree[LCH].l+1)*tmp)%mod;
		tree[RCH].val=(tree[RCH].val+(tree[RCH].r-tree[RCH].l+1)*tmp)%mod;
	}
	
	void Upd(int inx)
	{
		if (tree[inx].l>=lx && tree[inx].r<=rx)
		{
			tree[inx].tag+=_val;
			tree[inx].val=(tree[inx].val+_val*(tree[inx].r-tree[inx].l+1))%mod;
			return;
		}
		if (tree[inx].tag) Pushdown(inx);
		if (lx<=tree[inx].mid) Upd(LCH);
		if (rx>tree[inx].mid) Upd(RCH);
		tree[inx].val=(tree[LCH].val+tree[RCH].val)%mod;
	}
	
	void Clear(int inx)
	{
		if (tree[inx].l==_pos && tree[inx].r==_pos)
		{
			dat[_pos]=tree[inx].val;
			tree[inx].val=0; return;
		}
		if (tree[inx].tag) Pushdown(inx);
		if (_pos<=tree[inx].mid) Clear(LCH);
		else Clear(RCH);
		tree[inx].val=(tree[LCH].val+tree[RCH].val)%mod;
	}
	
	int Qry(int inx)
	{
		if (tree[inx].l==_pos && tree[inx].r==_pos) return tree[inx].val%mod;
		if (tree[inx].tag) Pushdown(inx);
		int ret;
		if (_pos<=tree[inx].mid) ret=Qry(LCH);
		else ret=Qry(RCH);
		tree[inx].val=(tree[LCH].val+tree[RCH].val)%mod;
		return ret;
	}
	
	#undef LCH
	#undef RCH
};

int main()
{
	readx(n); readx(m); char comm=0; int lx,rx,val;
	for (int i=1;i<=n;i++) readx(seq[i]);
	
	SGT1::BuildTree(1,1,n,seq);
	SGT2::BuildTree(1,1,n);
	
	while (m--)
	{
		comm=0; while (comm<'A' || comm>'Z') comm=getchar();
		if (comm=='A') 
		{
			readx(lx); readx(rx); readx(val);
			SGT1::lx=lx; SGT1::rx=rx; SGT1::_val=-val;
			SGT1::Upd(1);
			
			SGT2::lx=lx; SGT2::rx=rx; SGT2::_val=val;
			SGT2::Upd(1);
			
			while (SGT1::tree[1].minv<=0)
			{
				int pos=SGT1::Qry_Min_Pos(1);
				mul2[pos]=1;
				SGT2::_pos=pos; SGT2::Clear(1);
			}
		}
		else 
		{
			readx(lx); ll ans;
			SGT2::_pos=lx; ans=SGT2::Qry(1);
			if (mul2[lx])
				ans=(ans*2+dat[lx])%1000000009LL;
			allans=(allans+ans)%1000000009LL;
		}
	}
	printf("%lld\n",allans);
}
```

---

## 作者：WrongAnswer_90 (赞：2)

### Page 0

为什么都没有分块的题解啊。

题目感觉难度不是绿题，建议升蓝。

### Page 1

看到这题，我首先想到的是线段树，然后感觉不可做。

~~我果然太菜了~~

一看数据范围：$10^5$，分块好像能过。

这道题最大的问题是攻击了一次打了大标记后可能有一些盾碎掉了，下一次应该造成双倍伤害，但是却没有及时标记。

考虑维护块内最小值（下文记作 $minn$），如果区间攻击的 $tag < minn$，那么一定不会有盾被打碎。

如果 $tag \geq minn$ 那么就把这一个整块的标记都下传，进行暴力重构。

有些人可能会觉得时间复杂度不对，但是其实是正确的。

因为每一个盾只会碎一次，所以每一个盾的复杂度加成最多是 $\sqrt n$，所以碎盾的复杂度总和最多是 $O(n \times  \sqrt n)$ 级别。

对于散块，注意更改了之后维护 $minn$，代码中用 $a$ 来维护盾的血量，当一个盾被打破后，把它的血量设置成无限大。

然后就是基本操作了。

注意，假如盾的血量是 $1$，然后它收到了 $114514$ 点伤害，它也只是受到 $114514$ 点伤害的，而不是 $229018$ 点或其他，所以要注意处理 $tag$ 和当前攻击伤害的关系。

这道题开了 `long long` 之后好像不需要中间取模，最后再取模就可以。

具体实现细节见代码：

~~码风略丑，勿喷~~


```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#define int long long
using namespace std;
//a 是盾的血量，tg 是伤害标记， minn 是块内最小值，b是答案
int a[1000001],tg[1000001],all,minn[10001],b[1000001],x,t,n,m,l,r,k;
inline int read()
{
	int ans=0;char ch=getchar();
	while((ch>'9')||(ch<'0'))ch=getchar();
	while((ch>='0')&&(ch<='9'))ans=ans*10+ch-'0',ch=getchar();
	return ans;
}
char opt;
signed main()
{
	n=read();m=read();t=sqrt(n);
	for(int i=1;i<=n;i++)a[i]=read();
	for(int i=1;i<=n;i++)if(a[i]==0)a[i]=9999999999999999;
	for(int i=1;i<=n;i+=t)minn[(i-1)/t+1]=9999999999999999;
	for(int i=1;i<=n;i++)minn[(i-1)/t+1]=min(minn[(i-1)/t+1],a[i]);
	//不要忘记初始化，a一开始可能就是0
	while(m--)
	{
		cin>>opt;
		if(opt=='Q')
		{
			x=read();
			if(a[x]==9999999999999999)all=(all+(b[x]+tg[(x-1)/t+1]*2)%1000000009)%1000000009;
			else all=(all+(b[x]+tg[(x-1)/t+1])%1000000009)%1000000009;
			//cout<<all<<endl;
		}
		else
		{
			l=read();r=read();x=read();
			if((l-1)/t+1==(r-1)/t+1)//如果在同一块内
			{
				bool minf=0;//minf 表示当前块是否需要重构 ，以下同上 
				for(int i=l;i<=r;i++)
				{
					if(a[i]==9999999999999999)b[i]+=2*x;//如果盾已经碎了 
					else b[i]+=x;
					if(a[i]!=9999999999999999)
					a[i]-=x;
					minn[(l-1)/t+1]=min(minn[(l-1)/t+1],a[i]);//不要忘记维护 minn 
					if(a[i]<=tg[(l-1)/t+1])minf=1;
				}
				if(minf)
				{
					minn[(l-1)/t+1]=9999999999999999;
					for(int i=(l-1)/t*t+1;i<=min((l-1)/t*t+t,n);i++)
					{
						if(a[i]==9999999999999999)b[i]+=2*tg[(l-1)/t+1];
						else b[i]+=tg[(l-1)/t+1];
						if(a[i]!=9999999999999999)
						a[i]-=tg[(l-1)/t+1];
						if(a[i]<=0)a[i]=9999999999999999;
						minn[(l-1)/t+1]=min(minn[(l-1)/t+1],a[i]);
					}
					tg[(l-1)/t+1]=0;//tag 不要忘记清空 
				}
			}
			else
			{
				//处理左边散块 
				bool minf=0;
				for(int i=l;i<=min(((l-1)/t+1)*t,n);i++)
				{
					if(a[i]==9999999999999999)b[i]+=x*2;
					else b[i]+=x;
					if(a[i]!=9999999999999999)
					a[i]-=x;
					minn[(l-1)/t+1]=min(minn[(l-1)/t+1],a[i]);
					if(a[i]<=tg[(l-1)/t+1])minf=1;
				}
				if(minf)
				{
					minn[(l-1)/t+1]=9999999999999999;
					for(int i=(l-1)/t*t+1;i<=min(((l-1)/t+1)*t,n);i++)
					{
						if(a[i]==9999999999999999)b[i]+=tg[(l-1)/t+1]*2;
						else b[i]+=tg[(l-1)/t+1];
						if(a[i]!=9999999999999999)
						a[i]-=tg[(l-1)/t+1];
						if(a[i]<=0)a[i]=9999999999999999;
						minn[(l-1)/t+1]=min(minn[(l-1)/t+1],a[i]);
					}
					tg[(l-1)/t+1]=0;
				}
				//中间整块 
				for(int i=(l-1)/t+2;i<(r-1)/t+1;i++)
				{
					tg[i]+=x;
					if(tg[i]>=minn[i])
					{
						minn[i]=9999999999999999;
						for(int j=(i-1)*t+1;j<=min((i-1)*t+t,n);j++)
						{
							if(a[j]==9999999999999999)b[j]+=tg[i]*2;
							else b[j]+=tg[i];
							if(a[j]!=9999999999999999)
							a[j]-=tg[i];
							if(a[j]<=0)a[j]=9999999999999999;
							minn[i]=min(minn[i],a[j]);
						}
						tg[i]=0;
					}
				}
				minf=0;
				//右边散块 
				for(int i=(r-1)/t*t+1;i<=r;i++)
				{
					if(a[i]==9999999999999999)b[i]+=x*2;
					else b[i]+=x;
					if(a[i]!=9999999999999999)
					a[i]-=x;
					minn[(r-1)/t+1]=min(minn[(r-1)/t+1],a[i]);
					if(a[i]<=tg[(r-1)/t+1])minf=1;
				}
				if(minf)
				{
					minn[(r-1)/t+1]=9999999999999999;
					for(int i=(r-1)/t*t+1;i<=min((r-1)/t*t+t,n);i++)
					{
						if(a[i]==9999999999999999)b[i]+=tg[(r-1)/t+1]*2;
						else b[i]+=tg[(r-1)/t+1];
						if(a[i]!=9999999999999999)
						a[i]-=tg[(r-1)/t+1];
						if(a[i]<=0)a[i]=9999999999999999;
						minn[(r-1)/t+1]=min(minn[(r-1)/t+1],a[i]);
					}
					tg[(r-1)/t+1]=0;
				}
			}
		}
	}
	printf("%lld",all%1000000009);
	return 0;
}
```


---

## 作者：chichichichi (赞：2)

QAQ日常被绿题血虐 wtcl

## 分析题目

首先根据题面描述，需要支持区间减法和单点查询， ~~（再根据绿题标签），~~ 判断显然线段树模板。于是我快乐地种了一棵带 $lazy$ 标记的小树，却发现过不去样例orz。

再仔细看样例解释，发现 $2$ 号防御体的护盾在第一次攻击的时候就爆掉了，并且有溢出，但溢出的攻击并没有加倍。 ~~（好盾当赏）~~

## 思路
看完样例之后意识到，我们需要知道每次攻击都有哪些盾爆掉了，并在**之后**的每次攻击中使其受到的伤害翻倍。只用一棵带 $lazy$ 标记的树来操作的话显然无法做到。因为可能出现这样的情况：

第一次操作是对区间 $[1,3]$ 进行修改。节点$ [1,3]$被打上了 $lazy$ 标记，此时 $2$ 号防御体已经爆盾了。

第二次操作是对区间 $[1,4]$ 进行修改。节点 $[1,3]$ 的 $lazy$ 标记叠加。但2号防御体受到的攻击应当翻倍。

第三次操作是查询 $2$ 号防御体受到的伤害。在向下查询的过程中 $lazy$ 标记下放。我们此时可以知道 $2$号防御体的盾爆了，但不知道是一次攻击造成的还是多次攻击造成的，不能对其进行正确的更新。

如果种一棵不带 $lazy$ 标记的树呢？每次受到攻击都进行判断。显然可以得到正确答案，但是时间复杂度还没有暴力优……

我们思考后发现，对于一次修改操作的区间 $[l,r]$，我们可以对其分为两次操作，一次对未爆盾的防御体进行修改，一次是对爆盾的防御体进行修改。并在操作完成后进行未爆盾到爆盾的更新。我们可以想到种两颗树，分别维护未爆盾序列和爆盾序列，并进行更新，在询问时到对应的序列中去查询即可。并且这样分开来就可以快乐$lazy$了。

$tree 0$：维护未爆盾序列。

在初始时，所有防御体都在该树中，当有防御体爆盾后，将其移出该树。

$tree 1$：维护爆盾序列。

当有防御体的盾爆后，将其放入该树。

两颗树的区间操作和普通线段树一样，只是修改的值不同。我们主要思考，如何将一个防御体进行序列间的转移。

- 判断是否需要更新

在$tree0$中，每次区间操作完成后要判断哪些防御体爆盾了，需要移出序列。爆盾的标准是：**受到的伤害大于等于承受能力**。我们可以作差，得到 $w=$承受能力-受到的伤害，当 $w\le0$ 时，表示该防御体的盾爆了。想知道每次操作后有没有爆盾的防御体，就看整个序列中最小的 $w$ 是否大于$0$。若 $w_{min}>0$，则没有出现爆盾的，不需要更新；若 $w_{min}\le0$，则进行更新，直到$w_{min}>0$。

- 进行更新

	- 定位
    
    根据$w$的大小我们可以得知是否需要更新。那么在更新时我们需要 $w_{min}$ 所在的位置，对其操作。所以我们还需要维护$w_{min}$ 的位置信息 $pos$。
    
	- 移出$tree0$
    
    对于 $pos$，它被移出序列，需要保证之后的所以更新不会再次更新这个位置，因此将$rtee0$中此位置的 $w$ 赋值为 _**INF**_ 。
    
    - 放入 $tree1$
	
    将 $tre1$ 中 $pos$的值改为 $w$，具体原因在下面询问讲。
	
- 询问

刚才提到在询问时要到对应的序列去查询，那么就需要知道需要查询的 $x$ 在哪个序列中，因此我们**设一个标记数组**，来表示其在哪个序列中。更新时也要将对应的标记进行修改。

一次询问的结果为：$ans=p[x]-w_{x}$

因为$w_{x}=p[x]-sum_{x}$，其中 $sum_{x}$ 为 $x$ 受到的伤害总和。

将每次询问的答案累加起来，记得取模。



~~(为了写这个题解修了好多次代码，提交了好多次，害怕.jpg~~）

### $code$
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
const int maxn=100100;
#define mod 1000000009
#define INF 0x3f3f3f3f
int n,p[maxn],q,ans,vis[maxn];
struct node{
	int l,r;
	int f;
	int w,pos;
}c[maxn<<2][2];

void up(int w,int op)//维护 w 和 pos 
{
	if(c[w<<1][op].w<c[w<<1|1][op].w)
	{
		c[w][op].w=c[w<<1][op].w;
		c[w][op].pos=c[w<<1][op].pos;
	}
	else{
		c[w][op].w=c[w<<1|1][op].w;
		c[w][op].pos=c[w<<1|1][op].pos;
	}
	return ;
}
void build(int l,int r,int w,int op)//种树 
{
	c[w][op].l=l,c[w][op].r=r;
	if(l==r)
	{
		c[w][op].w=p[l];
		c[w][op].pos=l;
		return ;
	}
	
	int mid=(l+r)>>1;

	build(l,mid,w<<1,op);
	build(mid+1,r,w<<1|1,op);
	
	up(w,op);
	return ;
}

void spread(int w,int op)//下放 lazy 
{
	if(c[w][op].f)
	{
		int x=c[w][op].f;
		c[w][op].f=0;
		c[w<<1][op].w+=x;
		c[w<<1|1][op].w+=x;
		c[w<<1][op].f+=x;
		c[w<<1|1][op].f+=x;
	}
}

void change(int l,int r,int k,int w,int op)//区间修改 
{
	if(c[w][op].l>=l&&c[w][op].r<=r)
	{
		c[w][op].w+=k;
		c[w][op].f+=k;
		return ;
	}
	int mid=(c[w][op].l+c[w][op].r)>>1;
	spread(w,op);
	
	if(l<=mid)
	change(l,r,k,w<<1,op);
	if(r>mid)
	change(l,r,k,w<<1|1,op);
	
	up(w,op);
	return ;
}
void change1(int l,int w,int k,int op)//更新 
{
	if(c[w][op].l==c[w][op].r)
	{
		c[w][op].w=k;
		return ;
	}
	
	int mid=(c[w][op].l+c[w][op].r)>>1;
	spread(w,op);
	
	if(l<=mid)
	change1(l,w<<1,k,op);
	if(l>mid)
	change1(l,w<<1|1,k,op);
	
	up(w,op);
	return ;
}
int ask(int id,int w,int op)//查询 
{
	if(c[w][op].l==c[w][op].r)
	return c[w][op].w;
	
	int mid=(c[w][op].l+c[w][op].r)>>1;
	spread(w,op);
	
	if(id<=mid)
	return ask(id,w<<1,op);
	else
	return ask(id,w<<1|1,op);
}
int main(){
	scanf("%d%d",&n,&q);
	for(int i=1;i<=n;i++)
	scanf("%d",p+i);
	build(1,n,1,0);
	build(1,n,1,1);
	for(int i=1;i<=q;i++)
	{
		char qe[3];
		int l,r,k;
		scanf("%s%d",qe,&l);
		if(qe[0]=='A')
		{
			scanf("%d%d",&r,&k);
			change(l,r,-k,1,0);
			change(l,r,-2*k,1,1);
			while(c[1][0].w<=0)//需要更新 
			{
				int id=c[1][0].pos;
				vis[id]=1;
				int now=ask(id,1,0);
				change1(id,1,INF,0);
				change1(id,1,now,1);
			}
		}
		if(qe[0]=='Q')
		{
			if(!vis[l])
			{
				ans+=p[l]-ask(l,1,0);
				ans%=mod;
			}
			else{
				ans+=p[l]-ask(l,1,1);
				ans%=mod;
			}
		}
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：Celebrate (赞：1)

这一题不是很难，但是十分恶心

比如说一个位置的盾只剩下1，然后造成99999的伤害，题目的意思是然盾爆掉，然后物体受到99999的伤害，没有翻倍

一开始我是想用树状数组+差分来做的，但是发现上面这种情况无法处理，于是就只能用线段树了

因为是区间造成伤害，所以需要用到lazy标记

为了知道在一次造成伤害以后是否会有物体的盾爆掉，所以我打了一个minp[rt]数组来表示rt的子树中护甲剩下最小的叶子节点

如果一次攻击打爆了护盾，就把爆护盾的叶子节点记录一下本次的伤害，并且多打一个函数来维护，每一个节点logn，因为盾最多爆一次，所以总维护时间为O(nlogn)


代码见：[MyBlog](https://blog.csdn.net/zsyzClb/article/details/85011530)

---

## 作者：不存在之人 (赞：0)

题意很坑。

需要枚举题意：如果护甲被打爆，那个这次被打爆不会计算两倍答案

设$a$数组记录打爆前的答案$flag$表示是否打爆，每个节点维护$min$ $id$分别表示最小值和、最小值来自哪里

然后每次修改以后检查全局是否存在$<=0$的节点，如果存在就暴力$while$循环更改$id$这个点的情况，直到没有
```cpp
#include<cstdio>
#include<cctype>
#include<algorithm>
#define lc (x<<1)
#define rc (x<<1|1)
using namespace std;
const int mod=1e9+9;
const int N=1e5+10;
const int inf=0x3f3f3f3f;
struct node
{
    int mn,tag,id,v;
}tree[N<<2];
inline char gc()
{
    static char now[1<<16],*S,*T;
    if (T==S)
	{
		T=(S=now)+fread(now,1,1<<16,stdin);
		if (T==S) return EOF;
	}
    return *S++;
}
inline int read()
{
    int x=0,f=1;char ch=gc();
    while(!isdigit(ch))
	{
		if (ch=='-') f=-1;
		ch=gc();
	}
    while(isdigit(ch)) x=x*10+ch-'0',ch=gc();
    return x*f;
}
inline void update(int x)
{
    tree[x].mn=inf;
    if(tree[lc].mn<tree[x].mn) tree[x].mn=tree[lc].mn,tree[x].id=tree[lc].id;
    if(tree[rc].mn<tree[x].mn) tree[x].mn=tree[rc].mn,tree[x].id=tree[rc].id;
}
inline void build(int x,int l,int r)
{
    if (l==r)
	{
		tree[x].mn=read();
		tree[x].id=l;
		return;
	}
	int mid=l+r>>1;
    build(lc,l,mid);
	build(rc,mid+1,r);
	update(x);
}
int n,q,a[N],ans;bool flag[N];
inline void doa(int x,int v)
{
    tree[x].v+=v;
	tree[x].tag+=v;tree[x].mn-=v;
}
inline void pushdown(int x)
{
    if (!tree[x].tag) return;
	static int tag;
    tag=tree[x].tag;
	tree[x].tag=0;
	doa(lc,tag);
	doa(rc,tag);
}
inline void modify(int x,int l,int r,int l1,int r1,int v)
{
    if (l1<=l&&r1>=r)
	{
		doa(x,v);
		return;
	}
	int mid=l+r>>1;
	pushdown(x);
    if (l1<=mid) modify(lc,l,mid,l1,r1,v);
    if (r1>mid) modify(rc,mid+1,r,l1,r1,v);
	update(x);
}
inline void query(int x,int l,int r,int p)
{
    if (l==r)
	{
		flag[l]=1;
		a[l]=tree[x].v;
		tree[x].v=tree[x].tag=0;
		tree[x].mn=inf;
		return;
	}
    int mid=l+r>>1;
	pushdown(x);
    if (p<=mid) query(lc,l,mid,p);
	else query(rc,mid+1,r,p);
	update(x);
}
inline int qr(int x,int l,int r,int p)
{
    if(l==r)
	{
		return tree[x].v+a[l]+tree[x].v*flag[l];
	}
	int mid=l+r>>1;
	pushdown(x);
    if (p<=mid) return qr(lc,l,mid,p);
	else return qr(rc,mid+1,r,p);
}
inline void inc(int &x,int v)
{
	x=x+v>=mod?x+v-mod:x+v;
}
int main()
{
    n=read();
	q=read();
	build(1,1,n);
    while(q--)
	{
        char ch=gc();
		while(ch!='A'&&ch!='Q') ch=gc();
        if(ch=='A')
		{
			static int l,r,x;
            l=read();r=read();x=read();
            modify(1,1,n,l,r,x);
            while(tree[1].mn<=0) query(1,1,n,tree[1].id);
        }
        if(ch=='Q') inc(ans,qr(1,1,n,read()));
    }
	printf("%d\n",ans);
    return 0;
}
```


---

## 作者：henry_y (赞：0)

两个线段树维护

第一个线段树维护区间和和区间min以及叶节点的id，这个线段树放还有护甲的

每次修改时，区间减，单点查询，然后查询min有没有小于等于0的。有的话就设为inf然后标记一下，放到第二个线段树里。

第二个线段树区间直接减2倍即可。放进去的时候是单点覆盖。

不膜，在统计的时候才膜，不然没法做

大概就是细节注意一下就好了，挺码的一题...

```cpp
#include <bits/stdc++.h>
using namespace std;

namespace io {
char buf[1<<21], *p1 = buf, *p2 = buf;
inline char gc() {
    if(p1 != p2) return *p1++;
    p1 = buf;
    p2 = p1 + fread(buf, 1, 1 << 21, stdin);
    return p1 == p2 ? EOF : *p1++;
}
#define G getchar

#ifndef ONLINE_JUDGE
#undef G
#define G getchar
#endif

template<class I>
inline void read(I &x) {
    x = 0; I f = 1; char c = G();
    while(c < '0' || c > '9') {if(c == '-') f = -1; c = G(); }
    while(c >= '0' && c <= '9') {x = x * 10 + c - '0'; c = G(); }
    x *= f;
}

template<class I>
inline void write(I x) {
    if(x == 0) {putchar('0'); return;}
    I tmp = x > 0 ? x : -x;
    if(x < 0) putchar('-');
    int cnt = 0;
    while(tmp > 0) {
        buf[cnt++] = tmp % 10 + '0';
        tmp /= 10;
    }
    while(cnt > 0) putchar(buf[--cnt]);
}

#define in(x) read(x)
#define outn(x) write(x), putchar('\n')
#define out(x) write(x), putchar(' ')

} using namespace io;

#define ll long long
const int N = 100010;
const int mod = 1000000009;
const int inf = 0x3f3f3f3f;

/*
两个线段树维护
第一个线段树维护区间和和区间min以及叶节点的id，这个线段树放还有护甲的
每次修改时，区间减，单点查询，然后查询min有没有小于等于0的。有的话就设为inf然后标记一下，放到第二个线段树里。
第二个线段树区间直接减2即可。放进去的时候是单点覆盖。
不膜，在统计的时候才膜，不然没法做
 */

int n, m;
int a[N];
bool vis[N];

struct tree {
    ll mn, sum, tag;
    int id, l, r;
} t[N<<2][2];

#define lc (rt << 1)
#define rc (rt << 1 | 1)

void up(int rt, int op) {
    t[rt][op].mn = min(t[lc][op].mn, t[rc][op].mn);
    t[rt][op].sum = (t[lc][op].sum + t[rc][op].sum);
}

void build(int l, int r, int rt, int op) {
    t[rt][op].l = l; t[rt][op].r = r;
    if(l == r) {
        t[rt][op].sum = t[rt][op].mn = a[l];
        t[rt][op].id = l;
        if(op) t[rt][op].sum = t[rt][op].mn = 0;
        return;
    }
    int mid = (l + r) >> 1;
    build(l, mid, lc, op);
    build(mid + 1, r, rc, op);
    up(rt, op);
}

#define l (t[rt][op].l)
#define r (t[rt][op].r)
#define mid ((l + r) >> 1)

void down(ll ln, ll rn, int rt, int op) {
    if(t[rt][op].tag) {
        ll x = t[rt][op].tag; t[rt][op].tag = 0;
        t[lc][op].mn = (t[lc][op].mn + x); 
        t[rc][op].mn = (t[rc][op].mn + x);
        t[lc][op].sum = (t[lc][op].sum + ln * x); 
        t[rc][op].sum = (t[rc][op].sum + rn * x);
        t[lc][op].tag = (t[lc][op].tag + x); 
        t[rc][op].tag = (t[rc][op].tag + x);
    }
}

void upd(int L, int R, int rt, ll c, int op) {
    if(L <= l && r <= R) {
        t[rt][op].sum += (r - l + 1) * c; t[rt][op].mn += c;
        t[rt][op].tag += c;
        return;
    }
    down(mid - l + 1, r - mid, rt, op);
    if(L <= mid) upd(L, R, lc, c, op);
    if(R > mid) upd(L, R, rc, c, op);
    up(rt, op);
}

void upd_new(int pos, int rt, ll c, int op) {
    if(l == r) {
        t[rt][op].sum = t[rt][op].mn = c;
        return;
    }
    down(mid - l + 1, r - mid, rt, op);
    if(pos <= mid) upd_new(pos, lc, c, op);
    else upd_new(pos, rc, c, op);
    up(rt, op);
}

ll query_sum(int pos, int rt, int op) {
    if(l == r) return t[rt][op].mn;
    down(mid - l + 1, r - mid, rt, op);
    if(pos <= mid) return query_sum(pos, lc, op);
    else return query_sum(pos, rc, op);
}

int query_id(int rt, int op) {
    if(l == r) return t[rt][op].id;
    down(mid - l + 1, r - mid, rt, op);
    if(t[rt][op].mn == t[lc][op].mn) return query_id(lc, op);
    else return query_id(rc, op);
}

#undef lc
#undef rc
#undef l
#undef r
#undef mid

int main() {
    in(n), in(m);
    for(int i = 1; i <= n; ++i) in(a[i]);
    build(1, n, 1, 0); build(1, n, 1, 1);
    
    char s[2];
    int l, r, x;
    ll ans = 0;
    
    for(int i = 1; i <= m; ++i) {
        scanf("%s", s);
        if(s[0] == 'A') {
            in(l), in(r), in(x);
            upd(l, r, 1, -x, 0);
            upd(l, r, 1, -2 * x, 1);
            while(t[1][0].mn <= 0) {
                int id = query_id(1, 0);
                vis[id] = 1;
                ll now = query_sum(id, 1, 0);
                upd_new(id, 1, inf, 0);
                upd_new(id, 1, now, 1);
            }
        } else {
            in(x);
            if(!vis[x]) {
                ans += a[x] - query_sum(x, 1, 0);
                ans %= mod;
            } else {
                ans += a[x] - query_sum(x, 1, 1);
                ans %= mod;
            }
        }
    }
    outn(ans);
}
```

---

## 作者：Rainybunny (赞：0)

~~这道题真灵性~~

附一组数据：

input

3 10

24 97 50

A 1 3 56

A 1 3 25

A 1 3 80

A 1 2 98

Q 3

A 3 3 64

Q 1

A 1 3 11

Q 2

A 2 2 58

output

1107

全WA的小朋友是不是输出701呢w？~~滑稽~~

这道题看似是线段树板题，其实要复杂一些。如果单用普通线段树思想，如果攻击操作A一直经行，懒标记会把它们的伤害加在一起，但是可能在这一连串攻击的中途，某建筑的盾已经破了。如上面的数据，在第一次A时，三号建筑已经破盾了，不过由于没有询问，懒标记缓存了操作，后面的两次A并没有加倍伤害（我就这样调了一上午，还是对拍发现的qaq）。这就是本题玄学所在咯！

看来我们还应该在每次攻击后找到已经破盾的建筑，如何效率更高呢？线段树！这样一来，我们就需要维护两颗树，一颗Armor记录护甲还能承受伤害的最小值（破盾的当然更小），一颗Building维护受击状态，难点是怎么区分正常伤害与双倍伤害呢？代码见w（第一次写题解不会高亮不好意思啦，有没有小哥哥教我）
#
```cpp
// by.luogu P2667

//#define _DEBUG

#include <cstdio>

namespace Optimize { // 风骚的优化模板 
	#define Eps 1e-8
	#define Inf 0x3f3f3f3f
	#define Int register int
	#define LL long long int
	#define Type template<typename _T>
	#define FileClose() fclose ( stdin ), fclose ( stdout )
	#define FileOpen( fname ) freopen ( fname".in", "r", stdin ), freopen ( fname".out", "w", stdout )
	Type inline _T Max ( const _T a, const _T b ) { return a > b ? a : b; }
	Type inline _T Min ( const _T a, const _T b ) { return a < b ? a : b; }
	Type inline _T Abs ( const _T x ) { return x < 0 ? -x : x; }
	Type inline _T rint () {
		_T x = 0; int f = 1; char s = getchar ();
		while ( s < '0' || '9' < s ) f = s == '-' ? -1 : 1, s = getchar ();
		while ( '0' <= s && s <= '9' ) x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar ();
		return x * f;
	}
	Type inline void wint ( _T x ) {
		if ( x < 0 ) putchar ( '-' ), x = ( ~ x ) + 1;
		if ( 9 < x ) wint ( x / 10 );
		putchar ( x % 10 + '0' );
	}
}

using namespace Optimize;

const int Mod = 1000000009, MAXN = 100000;
int n, q, p[MAXN + 5] = {};
int Unbreak[MAXN + 5] = {}; // 破盾前，建筑承伤 
bool Breaked[MAXN + 5] = {}; // 破盾标记 

struct Building_Segment_Tree { // 这是维护建筑的树 
	struct Node {
		int l, r;
		LL Damage, Lazy; // Damage: 损伤(by百度翻译) 
	} *Tree;
	inline void Build ( const int i, const int l, const int r, const int SizeofTree = 0 ) { // 建树 
		if ( i == 1 ) Tree = new Node[SizeofTree] ();
		Tree[i].l = l, Tree[i].r = r, Tree[i].Lazy = Tree[i].Damage = 0;
		if ( l == r ) return ;
		int Mid = ( l + r ) >> 1;
		this -> Build ( i << 1, l, Mid );
		this -> Build ( i << 1 | 1, Mid + 1, r );
	}
	inline void Spread ( const int i ) { // 懒标记下传 
		if ( ! Tree[i].Lazy ) return ;
		Tree[i << 1].Lazy += Tree[i].Lazy;
		Tree[i << 1 | 1].Lazy += Tree[i].Lazy;
		if ( Tree[i << 1].l == Tree[i << 1].r ) { // 因为只用询问叶子，只对叶子经行维护咯 
			Tree[i << 1].Damage += Tree[i].Lazy;
		}
		if ( Tree[i << 1 | 1].l == Tree[i << 1 | 1].r ) {
			Tree[i << 1 | 1].Damage += Tree[i].Lazy;
		}
		Tree[i].Lazy = 0;
	}
	inline void Attack ( const int i, const int l, const int r, const LL Aggress ) { // 攻击 
		if ( r < Tree[i].l || l > Tree[i].r ) return ; // 与该区间无关，返回 
		if ( l <= Tree[i].l && Tree[i].r <= r ) { // 完全包含区间 
			Tree[i].Lazy += Aggress; // 懒标记 
			if ( Tree[i].l == Tree[i].r ) { // 若是叶节点，update 
				Tree[i].Damage += Aggress;
			}
			return ;
		}
		this -> Spread ( i ); // 记得传标记 
		this -> Attack ( i << 1, l, r, Aggress );
		this -> Attack ( i << 1 | 1, l, r, Aggress );
	}
	inline LL Query ( const int i, const int Target ) { // 询问伤害 
		if ( Target < Tree[i].l || Target > Tree[i].r ) return 0;
		if ( Tree[i].l == Target && Tree[i].r == Target ) {
			return Tree[i].Damage;
		}
		this -> Spread ( i );
		LL lchret = this -> Query ( i << 1, Target );
		LL rchret = this -> Query ( i << 1 | 1, Target );
		return lchret + rchret; // 左右必有一个为0，不过因为我懒x，直接加吧 
	}
	inline void ClearBreaked ( const int i, const int Target ) { // 难点来了！！！ 
		/*
		Target是通过Armor树找到的破盾建筑物，
		此时，我们把其对应的结点在破盾前受到的伤害保存在Unbreak并清零，
		在计算时，通过Breaked判断建筑是否破盾，有两种情况：
		1.破盾，ans = 破盾前(Unbreak) + 2 * 破盾后(Query)
		2.未破盾，ans = 破盾前(Query)
		很简单吧？"保存并清零" 就完美区分了两种伤害。 
		*/
		if ( Target < Tree[i].l || Target > Tree[i].r ) return ;
		if ( Tree[i].l == Target && Tree[i].r == Target ) {
			Unbreak[Tree[i].l] = Tree[i].Damage;
			Tree[i].Damage = 0;
			return ;
		}
		this -> Spread ( i ); // 记得也要传标记哦 
		this -> ClearBreaked ( i << 1, Target );
		this -> ClearBreaked ( i << 1 | 1, Target );
	}
} Building_SegTree;

struct Armor_Segment_Tree { // 破盾树，维护区间最小值，以找到破盾建筑 
	struct Node {
		int l, r, SectionMin, Lazy; // SectionMin就是区间最小值 
	} *Tree;
	inline void Build ( const int i, const int l, const int r, const int* LeafInfor, const int SizeofTree = 0 ) { // 建树 
		if ( i == 1 ) Tree = new Node[SizeofTree] ();
		Tree[i].l = l, Tree[i].r = r, Tree[i].Lazy = 0;
		if ( l == r ) {
			Tree[i].SectionMin = LeafInfor[l];
			return ;
		}
		int Mid = ( l + r ) >> 1;
		this -> Build ( i << 1, l, Mid, LeafInfor );
		this -> Build ( i << 1 | 1, Mid + 1, r, LeafInfor );
		Tree[i].SectionMin = Min ( Tree[i << 1].SectionMin, Tree[i << 1 | 1].SectionMin ); // 左右子区间最小值的min就是当前区间最小值 
	}
	inline void Spread ( const int i ) { // 下传懒标记 
		if ( ! Tree[i].Lazy ) return ;
		Tree[i << 1].Lazy += Tree[i].Lazy;
		Tree[i << 1 | 1].Lazy += Tree[i].Lazy;
		Tree[i << 1].SectionMin += Tree[i].Lazy;
		Tree[i << 1 | 1].SectionMin += Tree[i].Lazy;
		Tree[i].Lazy = 0;
	}
	inline void Attack ( const int i, const int l, const int r, const int Aggress ) { // 维护受击后的区间最小值 
		if ( r < Tree[i].l || l > Tree[i].r ) return ;
		if ( l <= Tree[i].l && Tree[i].r <= r ) {
			Tree[i].Lazy += Aggress;
			Tree[i].SectionMin += Aggress;
			return ;
		}
		this -> Spread ( i );
		this -> Attack ( i << 1, l, r, Aggress );
		this -> Attack ( i << 1 | 1, l, r, Aggress );
		Tree[i].SectionMin = Min ( Tree[i << 1].SectionMin, Tree[i << 1 | 1].SectionMin );
	}
	inline int Query_SectionMin ( const int i ) { // 返回整个区间最小值的index，它将被...改变为破盾状态 
		if ( Tree[i].l == Tree[i].r ) {
			Tree[i].SectionMin = Inf; // 找到最小值了，该建筑从此不用被维护，置为Inf 
			return Tree[i].l;
		}
		this -> Spread ( i );
        int ret;
        if ( Tree[i << 1].SectionMin <= 0 ) {
        	ret = Query_SectionMin ( i << 1 );
		} else {
			ret = Query_SectionMin ( i << 1 | 1 );
		}
        Tree[i].SectionMin = Min ( Tree[i << 1].SectionMin, Tree[i << 1 | 1].SectionMin ); // 因为最小值变为Inf，重新维护最小值 
        return ret;
    }
} Armor_SegTree;

inline void Work () {
	#define rint rint<int>() // 声明快读读入类型int 
	n = rint, q = rint;
	for ( Int i = 1; i <= n; ++ i ) {
		p[i] = rint;
	} // 以上是输入 
	Building_SegTree.Build ( 1, 1, n, n << 2 );
	Armor_SegTree.Build ( 1, 1, n, p, n << 2 ); // 初始化两棵树 
	LL Ans = 0;
	while ( q -- ) {
		char Cmd = getchar ();
		if ( Cmd == 'A' ) {
			int l = rint, r = rint, a = rint;
			Armor_SegTree.Attack ( 1, l, r, -a ); // 注意哦，函数里是+=，这里取负 
			Building_SegTree.Attack ( 1, l, r, a ); // 攻击 
			while ( Armor_SegTree.Tree[1].SectionMin <= 0 ) { // 循环清理所有破盾建筑(放心啦不会TLE) 
				int Breakedpos = Armor_SegTree.Query_SectionMin ( 1 ); // 获取破盾建筑index 
				Breaked[Breakedpos] = true; // 标记为破盾 
				Building_SegTree.ClearBreaked ( 1, Breakedpos ); // 在Building树中保存它受伤值，并重置(重置后的值就是双倍伤害啦) 
			}
		} else if ( Cmd == 'Q' ) {
			int x = rint;
			LL ret = Building_SegTree.Query ( 1, x ) % Mod;
			if ( Breaked[x] ) { // 破盾建筑，ans = 破盾前 + 2 * 破盾后
				ret = ( ( ret << 1 ) % Mod + Unbreak[x] ) % Mod; // 线段树里基本不用取模，这里最好取模哟 
			}
			#ifdef _DEBUG // 调试用来输出阶段答案 
			wint ( ret ), putchar ( '\n' );
			#endif
			Ans = ( Ans + ret ) % Mod;
		} else { // 读到神奇的字符(万一数据有丧心病狂的行末空格)，不计入操作总数 
			++ q;
		}
	}
	wint ( Ans % Mod ), putchar ( '\n' );
}

int main () {
//	FileOpen ( "" );
	Work ();
//	FileClose ();
	return 0;
}

// end. 我的代码风格好不好看？(夸我夸我)
// 教练大大让我们写题解，所以将会高产哦！ 
```

---


# [CQOI2014] 通配符匹配

## 题目描述

几乎所有操作系统的命令行界面（CLI）中都支持文件名的通配符匹配以方便用户。最常见的通配符有两个，一个是星号（```*```），可以匹配 0 个及以上的任意字符：另一个是问号（```?```），可以匹配恰好一个任意字符。现在需要你编写一个程序，对于给定的文件名列表和一个包含通配符的字符串，判断哪些文件可以被匹配。


## 说明/提示

对于 $100 \%$ 的数据

- 字符串长度不超过 $100000$
- $1 \le n \le 100$
- 通配符个数不超过 $10$


## 样例 #1

### 输入

```
*aca?ctc
6
acaacatctc
acatctc
aacacatctc
aggggcaacacctc
aggggcaacatctc
aggggcaacctct```

### 输出

```
YES
YES
YES
YES
YES
NO```

# 题解

## 作者：Orion545 (赞：90)

# 广告

[蒟蒻のblog](http://www.cnblogs.com/dedicatus545/p/8919383.html)

# 思路

## 0x01 KMP

一个非常显然而~~优秀~~的想法：把模板串按照'\*'分段，然后对于每一段求$next$，'?'就当成可以对于任意字符匹配就行了

对于每个文本串，从前往后找第一个可以匹配的地方，可以证明，一段字符越靠左，结果一定越优

找到了一个匹配位置以后往后跳，同时换成更新的一段模板串，一直匹配到模板串没有了为止

听起来很不错，是吗？代码看着也很简fu洁za：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int cmp(char l,char r){
    if(l=='?'||r=='?') return 1;
    return l==r;
}
void getfail(char s[],int fail[]){
    int len=strlen(s),i,j=0;
    fail[0]=fail[1]=0;
    for(i=1;i<len;i++){
        while(j&&!cmp(s[i],s[j])) j=fail[j];
        j+=cmp(s[i],s[j]);fail[i+1]=j;
    }
}
int match(char b[],char a[],int fail[],int l,int r,int m,int n){
    int i,j=0;
    for(i=l;i<=r;i++){
        while(j&&!cmp(b[j],a[i])) j=fail[j];
        j+=cmp(b[j],a[i]);
        if(j==m) return i;
    }
    return -1;
}
void empty(){}
char s[100010],b[15][100010],a[100010];int n,m,cnt,p1,p2,fail[15][100010],tot;
int main(){
    scanf("%s",s);int i,j,tmp,Q,k,l,r,ans=0;n=strlen(s);
    p1=(s[0]!='*');p2=(s[n-1]!='*');
    for(i=0;i<n;i++){
        if(s[i]=='*') continue;
        j=i;tmp=0;cnt++;b[cnt][tmp]=s[j];
        while(s[j+1]!='*'&&j<n) j++,tmp++,b[cnt][tmp]=s[j];
        i=j;
    }
    for(i=1;i<=cnt;i++) getfail(b[i],fail[i]),tot+=strlen(b[i]);
    if(cnt==0){
        scanf("%d",&Q);
        for(j=1;j<=Q;j++){
            scanf("%s",a);puts("YES");
        }
    }
    if(cnt==1&&p1&&p2){
        scanf("%d",&Q);
        for(j=1;j<=Q;j++){
            scanf("%s",a);m=strlen(a);
            if(m!=strlen(b[1])) continue;
            l=match(b[1],a,fail[1],0,m-1,strlen(b[1]),m);
            if(l==m-1) puts("YES");
            else puts("NO");
        }
        return 0;
    }
    scanf("%d",&Q);
    for(j=1;j<=Q;j++){
        scanf("%s",a);m=strlen(a);bool flag=0;
        if(m<tot) goto end;
        l=p1*strlen(b[1]);r=m-p2*strlen(b[cnt])-1;
        if(p1)
            for(i=0;i<strlen(b[1]);i++) 
                if(!cmp(b[1][i],a[i])) goto end;
        if(p2)
            for(i=0;i<strlen(b[cnt]);i++) 
                if(!cmp(b[cnt][i],a[m-strlen(b[cnt])+i])) goto end;
        for(k=p1+1;k<=cnt-p2;k++){
            l=match(b[k],a,fail[k],l,r,strlen(b[k]),strlen(a));
            if(l==-1) goto end;
            l++;
        }
        puts("YES");flag=1;
        end:if(!flag) puts("NO");
    }
}
```

![](http://images.cnblogs.com/cnblogs_com/dedicatus545/1199264/o_1.PNG)

凉！凉！

为什么呢？好像我们把'?'当成通配符处理，也没有违背$next$数组的意义啊？

是的，这个做法的确没有违背，但是有一点：我们无法通过传统的$O\left(n\right)$方法求出$next$数组

我们看一下求$next$的代码：
```cpp
bool cmp(char l,char r){//带通配符情况下判断相等
	if(l=='?'||r=='?') return 1;
    return l==r;
}
```
```cpp
j=0;fail[0]=fail[1]=0;//fail就是next
for(i=1;i<len;i++){
	while(j&&!cmp(s[i],s[j])) j=fail[j];
    j+=cmp(s[i],s[j]);fail[i+1]=j;
}
```

这其中，为什么变量$j$可以直接不更新直接使用？（其他版本的$KMP$的$j$本质上其实也没有更新）

因为这里的“公共前后缀”有一个前提条件：每个字符的意义不变，这样才能满足我们一次一次往后推的过程中，利用的都是最长的已知公共前后缀；如果中间出现意义不统一的字符的话，就会导致$WA$

但是'?'这个字符显然不满足这一条件——它可能在$next[5]$中作为'a'，但是在$next[6]$中作为'b'，这就会导致$j$不能直接继续调用，所以在本题中，这个求$next$的方法是错误的（20分已经是出题人怜悯我们了）

那么怎么办？难道暴力求$next$吗？那样可是$O\left(n^3\right)$的，还不如暴力匹配呢......

别急，我们考虑优化这个$KMP$的正确性

## 0x02 优化の$KMP$

分段这个思想，在上一步中并未出现任何问题

那我们考虑把分段贯彻到底——把'?'也分开！

这样我们会得到一堆不包含任何通配符的字符串，依旧是按照上面的方法，我们分段求$next$，求最靠左的匹配......

代码如下：

```cpp
// luogu-judger-enable-o2
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int fail[15][100010],n,m,cnt=0,jump[15],stl[15];
char b[15][100010],a[100010];
void getfail(char s[],int len){
    int i,j=0;fail[cnt][0]=fail[cnt][1]=0;stl[cnt]=len;
    for(i=1;i<len;i++){
        while(j&&(s[i]!=s[j])) j=fail[cnt][j];
        j+=(s[i]==s[j]);fail[cnt][i+1]=j;
    }
}
char s[100010];
int main(){
    scanf("%s",s);int i,j,len,k,l;m=strlen(s);
    for(i=0;i<m;i++){
        if(s[i]=='*') continue;
        if(s[i]=='?'){jump[cnt]++;continue;}
        j=i;cnt++;len=0;
        while(s[j]!='*'&&s[j]!='?'&&j<m) b[cnt][len]=s[j],j++,len++;
        getfail(b[cnt],len);
        i=j;
    }
    scanf("%d",&n);
    for(l=1;l<=n;l++){
        scanf("%s",a);len=strlen(a);
        i=jump[0];bool flag=1;
        for(k=1;k<=cnt;k++){
            j=0;
            for(;i<len;i++){
                while(j&&(a[i]!=b[k][j])) j=fail[k][j];
                j+=(a[i]==b[k][j]);
                if(j==stl[k]) break;
            }
            if(j<stl[k]){
                puts("NO");flag=0;break;
            }
            i+=jump[k];
        }
        if(flag) puts("YES");
    }
}
```

![](http://images.cnblogs.com/cnblogs_com/dedicatus545/1199264/o_2.PNG)

怎么还是$WA!!!!$

等等，这个算法......有一个问题：靠左的匹配，现在一定是最优的了么？

不是！

我们考虑一个例子：

模板串是$\ast aca?ctc$

文本串是$acaacaactc$

那么，显然第一个分段$aca$的第一个匹配就是最左边的那个，但是在这种情况下，我们的算法会显示没有匹配——因为'?'只能匹配一个字符，所以这时可能靠右才是更好的选择

这样来看，$KMP$好像走到死胡同了，接下来怎么办呢......

## 0x03 $dp$

$KMP$行不通了，我们来想想一个更基础的做法：$dp$

题目中说了，本题的通配符只有10个最多，这意味着我们可以以通配符为界，设定$dp$状态（其实上面的两个$KMP$算法都没有考虑到这个问题......省选题可不是忽略了一个条件也能轻松$AC$的）

设$dp[i][j]$表示文本串的前$j$个字符匹配了模式串第$i$个通配符（包括这个通配符）前面的所有字符，值为0代表不能，值为一代表不行

那么，显然有两种转移：第$i+1$个通配符是'\*'或者'?'

转移的条件，是从第$j+1$个字符开始的一段字符串可以与第$i$个和第$i+1$个通配符之间的模板串字符匹配

设这一段模板串长度为$k$

如果是'?'，那么$dp[i+1][j+k+1]=1$

如果是'\*'，那么$dp[i+1][j+k...strlen(s)]=1$

这个递推貌似是对的，但是有一个问题：

**怎么足够快地知道，从第$j+1$个字符开始的一段字符串，与第$i$个和第$i+1$个通配符之间的模板串字符，可不可以匹配？？？**

## 0x04 字符串$hash$

古话说的好，转换思路是最重要的（貌似不是古话？=_=）

我们看，如果想知道两个字符串，而且在这种情况下是两个已知的字符串，那么怎么判断他们是否匹配（等价于是否相等）？

$hash$一下！

我们如果知道了这两段字符串的$hash$值，那么判断它们是否相等不是轻而易举了？

先别急着高兴，因为求一段未知字符串的$hash$值也是$O\left(n\right)$的......

然而我们的程序需要在这一步上只能有$O\left(1\right)$的时间开销

怎么办？

## 0x05 $hash+$前缀和

想一想，我们在需要$O\left(1\right)$知道一段区间的和（就是$hash$值）的时候，是怎么做的？

前缀和啊！

但是，$hash$值，真的可以前缀和吗？

完全大丈夫！

我们考虑一个字符串的常见$hash$过程：

以字符串的第i项，作为$x^i$的系数，然后把选定的$x$（比如19260817）代入得到$hash$值，中间通过mod一个数或者Unsigned类型的自然溢出来减小范围

也就是说这个过程实际上是多项式求值，秦九韶算法优化下可以达到$O\left(n\right)$

再考虑一个已知字符串$s$，设它的长度为$len$

那么，它的前缀$pre[i]$的字符串$hash$的值，就是这样的一个表达式：

### $hash[i]=\sum_{j=0}^is[j]\ast x^{i-j}$

考虑另一个$hash$值$hash[p]$，算法也是一样的（设$p>i$）

那么怎么求$i+1$到$p$这段字符串的$hash$值呢？

我们令$tmp=hash[p]-hash[i]\ast x^{p-i}$，把$hash[p]$和$hash[i]$展开，就会得到：

### $tmp=\sum_{j=i+1}^ps[j]\ast x^{p-j}$

把子串$s[i+1...p]$提取出来作为$ss$，长度$llen=p-i$

那么：

### $tmp=\sum_{j=0}^ps[j]\ast x^{llen-j}$

正好就是这个子串的$hash$值

因此我们把输入的文本串的前缀的$hash$值预处理好，同时预处理出$x$的幂，就可以$O(1)$完成判断了

代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ll unsigned long long
ll key=19260817ll;//膜法数字
using namespace std;
ll pre[100010],mul[100010],h[20];int n,cnt,sp[20],stl[20],dp[15][100010];
//sp表示通配符类型，stl就是strlen（表示某一段的长度），h是模板串某一段的hash值
char b[15][100010],a[100010],tmp[100010];
ll gethash(char s[],int len){//秦九韶算法求hash
    ll re=0;int i;
    for(i=0;i<len;i++) re*=key,re+=(ll)s[i];
    return re;
}
int main(){
    scanf("%s",a);int i,j,k,l,len=strlen(a);ll t1;
    mul[0]=1;
    for(i=1;i<=100000;i++) mul[i]=mul[i-1]*key;
    if(a[0]=='*'||a[0]=='?') h[++cnt]=gethash(b[cnt],stl[cnt]=0);
    for(i=0;i<len;){//预处理每一段
        if(a[i]=='*'||a[i]=='?'){sp[cnt]=(sp[cnt]||(a[i]=='*'));i++;}
        j=0;cnt++;
        while(a[i]!='*'&&a[i]!='?'&&i<len) b[cnt][j]=a[i],i++,j++;
        h[cnt]=gethash(b[cnt],stl[cnt]=j);
    }
    len++;
    if(a[len-2]=='*'||a[len-2]=='?') cnt++,sp[cnt]=stl[cnt]=h[cnt]=0;
    else sp[cnt]=0;
    scanf("%d",&n);
    for(l=1;l<=n;l++){
        memset(a,0,sizeof(a));
        scanf("%s",a);a[strlen(a)]='$';
        memset(dp,0,sizeof(dp));dp[0][0]=1;
        len=strlen(a);
        for(i=0;i<len;i++) pre[i+1]=pre[i]*key+(ll)a[i];//求前缀和
        for(j=0;j<=len;j++){
            for(i=0;i<=cnt;i++){
                if(!dp[i][j]) continue;
                t1=pre[j+stl[i+1]]-pre[j]*mul[stl[i+1]];
                if(t1==h[i+1]){//hash值相等，匹配成功
                    if(sp[i+1]) for(k=j+stl[i+1];k<=len;k++) dp[i+1][k]=1;
                    else dp[i+1][j+stl[i+1]+1]=1;
                    //这里分情况递推
                }
            }
        }
        if(dp[cnt][len]) puts("YES");
        else puts("NO");
    }
}
```

![](http://images.cnblogs.com/cnblogs_com/dedicatus545/1199264/o_3.PNG)

$WTF!!!!!$

难道这个算法还是错的？？？？

## 0x06 最后的优化

不能放弃希望

我们观察写出的代码——没有任何一个地方会造成死循环，那么就是常规循环导致它$TLE$了，究竟是哪一段呢？
```cpp
if(t1==h[i+1]){
    if(sp[i+1]) for(k=j+stl[i+1];k<=len;k++) dp[i+1][k]=1;
    else dp[i+1][j+stl[i+1]+1]=1;
}
```

没错，正是这个万恶的$for$循环！

这个$for$循环的作用，是在$sp[i+1]=1$，也就是下一个通配符为'\*'的时候，用来一路更新下去的

但是这样更新来更新去，一定会导致$TLE$

那我们需要一个优化，让这个循环的过程分散到遍历$dp[i][j]$的时候去，省去一层$n$的复杂度

这里，我们考虑使用不同的值来表示$dp[i][j]$的不同意义：

当$dp[i][j]=-1$的时候，说明这个节点没有访问过，continue

当$dp[i][j]=0$的时候，说明这个节点被且仅被一个'?'往后的递推访问过，这时我们令$dp[i][j]=2,dp[i][j+1]=2$，并continue（因为当前节点并没有意义，只是访问过，不能继续递推）

当$dp[i][j]=1$的时候，说明这个节点是被'\*'访问过的，这时我们令$dp[i][j+1]=1$，并且这个点有意义，可以往下递推

当$dp[i][j]=2$的时候，说明这个节点被'?'访问过的节点更新到了2，这时直接从这个节点往后递推，不需要更新值

最后，当$dp[i][j]=3$的时候——这个是一个非常特殊的情况

我们发现，上述的-1到2的值里面，1的优先级最高，0次之，2最低，-1可以被它们随便覆盖

但是我们的确会出现这样的情况：一个0延伸出来的2，覆盖到了另一个0

此时这个0不仅会令$dp[i][j]=dp[i][j+1]=2$，它自身也需要往下递推，而不是直接continue（因为上一个过来的2说明它有这个意义）

所以我们令这种情况下的$dp[i][j]$的值为3，此时令$dp[i][j+1]=2$，并且从当前节点递推

初始化的时候，全部设为-1，$dp[0][0]=2$

最后如果dp\[模板串的段数\]\[文本串长度\]不是-1的话，就输出YES，否则NO

代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ll unsigned long long
ll key=19260817ll;
using namespace std;
ll pre[100010],mul[100010],h[20];int n,cnt,sp[20],stl[20],dp[15][100010];
char b[15][100010],a[100010],tmp[100010];
ll gethash(char s[],int len){
    ll re=0;int i;
    for(i=0;i<len;i++) re*=key,re+=(ll)s[i];
    return re;
}
int main(){
    scanf("%s",a);int i,j,k,l,len=strlen(a);ll t1;
    mul[0]=1;
    for(i=1;i<=100000;i++) mul[i]=mul[i-1]*key;
    if(a[0]=='*'||a[0]=='?') h[++cnt]=gethash(b[cnt],stl[cnt]=0);
    for(i=0;i<len;){
        if(a[i]=='*'||a[i]=='?'){sp[cnt]=(sp[cnt]||(a[i]=='*'));i++;}
        j=0;cnt++;
        while(a[i]!='*'&&a[i]!='?'&&i<len) b[cnt][j]=a[i],i++,j++;
        h[cnt]=gethash(b[cnt],stl[cnt]=j);
    }
    len++;
    if(a[len-2]=='*'||a[len-2]=='?') cnt++,sp[cnt]=stl[cnt]=h[cnt]=0;
    else sp[cnt]=0;
    scanf("%d",&n);
    for(l=1;l<=n;l++){
        memset(a,0,sizeof(a));
        scanf("%s",a);
        len=strlen(a);a[len]='$';len++;
        memset(dp,-1,sizeof(dp));dp[0][0]=2;pre[0]=0;
        for(i=0;i<len;i++) pre[i+1]=pre[i]*key+(ll)a[i];
        for(j=0;j<=len;j++){
            for(i=0;i<=cnt;i++){//只有这里有差别
                if(dp[i][j]==-1) continue;
                if(dp[i][j]==1) dp[i][j+1]=1;
                if(!dp[i][j]){
                    dp[i][j]=2;
                    if(dp[i][j+1]==-1) dp[i][j+1]=2;
                    if(dp[i][j+1]==0) dp[i][j+1]=3;//判断赋2还是3
                    continue;
                }
                if(dp[i][j]==3){
                    dp[i][j]=2;
                    if(dp[i][j+1]==-1) dp[i][j+1]=2;
                    if(dp[i][j+1]==0) dp[i][j+1]=3;//判断赋2还是3
                }
                t1=pre[j+stl[i+1]]-pre[j]*mul[stl[i+1]];
                if(t1==h[i+1]){
                    dp[i+1][j+stl[i+1]]=max(dp[i+1][j+stl[i+1]],sp[i+1]);
                }
            }
        }
        if(dp[cnt][len]!=-1) puts("YES");
        else puts("NO");
    }
}
```

![](http://images.cnblogs.com/cnblogs_com/dedicatus545/1199264/o_4.PNG)

Finally，这道题目告一段落

# 0x07 总结

一没注意，题解就写了两百多行了

这的确做起来是道麻烦但是有趣的题目，最后算法返璞归真，用最基础的、洛谷上普及-的字符串哈希就做完了

但是整个做题的过程却非常耐人寻味：KMP为什么是错的？怎么$O\left(1\right)$实现一个看起来不可能的过程？为什么$hash$满足前缀和？怎么保证时间复杂度的情况下把递推正确性保证......

虽然最后的代码跑的很慢，但是这并不意味着做完这道题我的收获就小

恰恰相反，那长达一整页的提交记录才是真正得到的、最珍贵的**思维**

[The Way To ACCEPTED](https://www.luogu.org/recordnew/lists?uid=27753&pid=P3167&status=&sort=0)

---

## 作者：letitdown (赞：22)

Upd in 12.21:

由于没有判一个串能匹配的最小长度所以被 hack 了。。。

修改了 latex，改了一下马蜂，补了一下锅。~~(之前的马蜂过于丑了)~~

具体就体现在下面新添加的 $cntc$ 变量。

## 题意

本题的意思就是给出一段带有 $?$ 与 $*$ 的字符串(在下面称为 $s$)，$?$ 必须占据一个字符位置，$*$ 可以占据任意位置，
求下面给出几段(在下面称为 $ss$)中能够匹配的字符串。

## 思路
------------


#### 前言

本题最可恶的一点是，如果 s 的第一段/最后一段是字符，那么 ss 中最开始/最后也必须是一样的字符。

另外，本题我使用了 hash + 前缀，如果不太熟悉的话可以了解一下～[传送门](https://www.luogu.com.cn/problem/P3370)
举个栗子～

如样例，s 为 *aca?ctc，我们就可以将它分为

$*$ ，aca， $?$ ，ctc 共四段。

对于每一段，我们用一个 $add$ 数组来判断它的种类，

用 $co$ 记录它的段数，字符串对应 2,$*$ 对应 1,$?$ 对应 0：
```cpp

	scanf("%s",s+1);lens=strlen(s+1);
	if(s[1]<'a'||s[1]>'z')co=0;else add[1]=2;
	for(register int i=1;i<=lens;i++){
		if((s[i]>='a'&&s[i]<='z')||(s[i]=='?'))cntc++;
		if(s[i]>='a'&&s[i]<='z'){
			len[co]++;
			f[co]=f[co]*131+s[i];
		}
		else if(s[i]=='*') {add[++co]=1;if(i!=lens&&s[i+1]>='a'&&s[i+1]<='z')add[++co]=2;}
		else{co++;if(i!=lens&&s[i+1]>='a'&&s[i+1]<='z')add[++co]=2;}
	}
```
注意，由于开头字符不好判断，所以这里加了一个特判，
来记录开头是字符串的情况。


#### 判断

预处理好了，那么，如何进行判断呢？

首先，我们需要算出原串最少要匹配多少字符，如果询问串长度比这个还要小就直接判否。

这里，我用了 $doit$ 与 $ask$ 两个自定义函数，

doit 用来对可以自由匹配的字符种类进行判断处理，

ask 用来对“ ？ ”后的字符进行判断处理。

两个函数中都使用了 key，k 两个参数，
key 记录了到哪个字符（指针），k 记录了到第几段。

对于 doit：
```cpp

inline void doit(int key,int k){
	if(k>co){can=1;return;}
	if(add[k]==2){
		for(register int i=key+len[k]-1;i<=le;i++)
		if(ff[i]-ff[i-len[k]]*p[len[k]]==f[k])
		{doit(i+1,k+1);if(can)return;}
		return;
	}
	if(add[k]==1){
		doit(key,k+1);
		if(can)return;
		return;
	}
	if(add[k]==0){
		ask(key+1,k+1);return;
	}
}
```
对于 ask：
```cpp

inline void ask(int key,int k){
	if(k>co){can=1;return;}
	if(add[k]==2){
		if(ff[key+len[k]-1]-ff[key-1]*p[len[k]]==f[k])doit(key+len[k],k+1);
	}
	else{
		if(add[k]==1){if(add[k+1]==0){for(register int i=key+2;i<=le;i++)if(ff[i+len[k+2]-1]-ff[i-1]*p[len[k+2]]==f[k+2])doit(i+len[k+2],k+3);}doit(key,k+1);}
		else ask(key+1,k+1);
	}
}
```



#### 收尾

到这里，万事俱备，只欠东风，进行我们华丽的结束吧～

接下来就该读入与判断了：
```cpp
	p[0]=1;
	for(register int i=1;i<=100000;i++)p[i]=p[i-1]*131;
	int n=read();
	while(n--){
		can=0;
		scanf("%s",ss+1);le=strlen(ss+1);
		if(cntc>le){puts("NO");continue;}
		for(register int i=1;i<=le;i++)ff[i]=ff[i-1]*131+ss[i];
		if(add[1]==2)if(ff[len[1]]-ff[0]*p[len[1]]!=f[1]){printf("NO\n");continue;}
		if(add[co]==2)if(ff[le]-ff[le-len[co]]*p[len[co]]!=f[co]){printf("NO\n");continue;}
		doit(1,1);
		if(can)printf("YES\n");else printf("NO\n");
	}
```

## CODE
------------

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
using namespace std;
namespace EMT{
	#define ull unsigned long long
	inline int read(){int x=0;char ch=getchar();while(ch<'0'||ch>'9')ch=getchar();while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();return x;}
	char s[100005],ss[100005];
	int lens,len[25],co=1,le,k,key,cnt,add[25];bool can;
	ull f[25],ff[100010],p[100010];
	int cntc;
	inline void ask(int,int);
	inline void doit(int,int);
		inline void ask(int key,int k){
			if(k>co){can=1;return;}
			if(add[k]==2){
				if(ff[key+len[k]-1]-ff[key-1]*p[len[k]]==f[k])doit(key+len[k],k+1);
			}
			else{
				if(add[k]==1){if(add[k+1]==0){for(register int i=key+2;i<=le;i++)if(ff[i+len[k+2]-1]-ff[i-1]*p[len[k+2]]==f[k+2])doit(i+len[k+2],k+3);}doit(key,k+1);}
				else ask(key+1,k+1);
			}
		}
	inline void doit(int key,int k){
		if(k>co){can=1;return;}
		if(add[k]==2){
			for(register int i=key+len[k]-1;i<=le;i++)
			if(ff[i]-ff[i-len[k]]*p[len[k]]==f[k])
			{doit(i+1,k+1);if(can)return;}
			return;
		}
		if(add[k]==1){
			doit(key,k+1);
			if(can)return;
			return;
		}
		if(add[k]==0){
			ask(key+1,k+1);return;
		}
	}
	inline short main(){
		scanf("%s",s+1);lens=strlen(s+1);
		if(s[1]<'a'||s[1]>'z')co=0;else add[1]=2;
		for(register int i=1;i<=lens;i++){
			if((s[i]>='a'&&s[i]<='z')||(s[i]=='?'))cntc++;
			if(s[i]>='a'&&s[i]<='z'){
				len[co]++;
				f[co]=f[co]*131+s[i];
			}
			else if(s[i]=='*') {add[++co]=1;if(i!=lens&&s[i+1]>='a'&&s[i+1]<='z')add[++co]=2;}
			else{co++;if(i!=lens&&s[i+1]>='a'&&s[i+1]<='z')add[++co]=2;}
		}
		p[0]=1;
		for(register int i=1;i<=100000;i++)p[i]=p[i-1]*131;
		int n=read();
		while(n--){
			can=0;
			scanf("%s",ss+1);le=strlen(ss+1);
			if(cntc>le){puts("NO");continue;}
			for(register int i=1;i<=le;i++)ff[i]=ff[i-1]*131+ss[i];
			if(add[1]==2)if(ff[len[1]]-ff[0]*p[len[1]]!=f[1]){printf("NO\n");continue;}
			if(add[co]==2)if(ff[le]-ff[le-len[co]]*p[len[co]]!=f[co]){printf("NO\n");continue;}
			doit(1,1);
			if(can)printf("YES\n");else printf("NO\n");
		}
		return 0;
	}
}
int main(){return EMT::main();}
```



#### 结语

这道题我也调了有好久了，甚至都有些舍不得了，所以写下了本篇题解，也是我的第一篇题解

如果对你有帮助，求个赞qwq

---

## 作者：yqbylty (赞：19)

### 解题思路：

网上题解好像都是哈希和$KMP$的，但其实$AC$自动机也是可以做的(因为这是我$AC$自动机做题列表里的题...)

对于通配符 $ * $ ，我们只需要把包含通配符的字符串以 $ * $ 分开就好了，然后除了最后一段其他尽量匹配靠前的原串子串就好了，因为这样子匹配的话，如果中间夹杂其他字符是可以直接用 $ * $ 代替的，这个思路也是哈希和 $ KMP $ 做法中的一种。

那么对于通配符 $ ? $ ，我们也仿照 $ * $ ，根据 $ ? $ 分段，将分段之后的字符串丢到$AC$自动机里，然后用$vector$存下每段字符串在原串中的位置，其实也就是用$vector$存$end$数组，因为分段的串可能会重复。

举个例子，对于串$abcd?abc?cd?abcd$，建出来的$Trie$树如下：

![](https://luvwgyx.com/wp-content/uploads/2019/03/out.jpg)

其中绿色(我也不知道是啥颜色)的节点是结束节点，旁边标注的数字则是以它结尾的字符串们在原串中的位置，建$fail$指针和正常的$AC$自动机建法是一样的。

我们用一个$cnt$数组，下标对应原串中的每一位，然后在$AC$自动机上跑，如果匹配到结束节点，那么就让$cnt[pos-ed[p][j]+1]++$，其中$pos$为当前匹配位置，$ed[p]$则是上述的$vector$数组。

这样处理之后，我们再遍历一遍，如果有一个$cnt$值等于段数，那么它就可以作为这整个串的匹配的起点。

就如之前的串$abcd?abc?cd?abcd$，每一个这样子处理之后，只有第一个$abcd$的$a$节点是满足$cnt$等于段数，那么它就是这次能够匹配的最靠前的位置了。

#### Code：

```cpp
/*Program from Luvwgyx*/
#include<queue>
#include<vector>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=1e5+10;
int n,m,num;bool Beg,End;char s[maxn],t[maxn];
int read(){
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
void print(int x){
    if(x<0)putchar('-'),x=-x;
    if(x>9)print(x/10);
    putchar(x%10+'0');
}
void write(int x){print(x);puts("");}
struct AC_automaton{
    vector<int >ed[maxn];queue<int >q;
    int tot,root,cnt[maxn],seq[maxn],fail[maxn],trie[maxn][26];
    int newnode(){
        tot++;fail[tot]=0;ed[tot].clear();
        for(int i=0;i<26;i++)trie[tot][i]=-1;
        return tot;
    }
    void insert(int l,int r,int id){
        int p=root;
        for(int i=l;i<=r;i++){
            int ch=t[i]-'a';
            if(trie[p][ch]==-1)trie[p][ch]=newnode();
            p=trie[p][ch];
        }ed[p].push_back(id);
    }
    void make_fail(){
        for(int i=0;i<26;i++)
            if(trie[root][i]!=-1){
                fail[trie[root][i]]=root;
                q.push(trie[root][i]);
            }else trie[root][i]=root;
        while(!q.empty()){
            int x=q.front();q.pop();
            for(int i=0;i<(int)ed[fail[x]].size();i++)ed[x].push_back(ed[fail[x]][i]);
            for(int i=0;i<26;i++){
                if(trie[x][i]!=-1){
                    fail[trie[x][i]]=trie[fail[x]][i];
                    q.push(trie[x][i]);
                }else trie[x][i]=trie[fail[x]][i];
            }
        }
    }
    bool find(int l,int r,bool fir,bool las){
        tot=0;root=newnode();
        memset(cnt,0,sizeof(cnt));
        int bel=0;
        for(int i=l,pos=i;i<=r;i++,pos=i)
            if(t[i]!='?'){
                while(pos<=r&&t[pos]!='?')pos++;
                pos--;insert(i,pos,pos-l+1);
                i=pos;bel++;
            }
        make_fail();int p=root;
        for(int i=1;i<=n;i++){
            int ch=s[i]-'a';p=trie[p][ch];
            for(int j=0;j<(int)ed[p].size();j++)
                if(i-ed[p][j]+1>0)cnt[i-ed[p][j]+1]++;
        }
        for(int i=1;i<=n;i++)
            if(cnt[i]==bel){
                if(!num){
                    if(!Beg&&fir&&i!=1)continue;
                    if(!End&&las&&i+r-l!=n)continue;
                    seq[++num]=i+r-l;
                    return 1;
                }else {
                    if(i<=seq[num])continue;
                    if(!End&&las&&i+r-l!=n)continue;
                    seq[++num]=i+r-l;
                    return 1;
                }
            }
        return 0;
    }
}AC;
int main(){
    scanf("%s",t+1);int T=read();m=strlen(t+1);
    while(T--){
        scanf("%s",s+1);n=strlen(s+1);num=0;
        Beg=t[1]=='*';End=t[m]=='*';int len=m;
        while(len&&t[len]=='*')len--;
        if(!len){puts("YES");continue;}
        int bel=0;bool flag=0;
        for(int i=1;i<=m;i++)
            if(t[i]!='*'){
                int pos=i;
                while(pos<=m&&t[pos]!='*')pos++;pos--;
                if(!AC.find(i,pos,bel==0,pos==len)){flag=1;break;}
                i=pos;bel++;
            }
        puts(flag?"NO":"YES");
    }
    return 0;
}
```

---

## 作者：Porsche (赞：19)

# 震惊！没看明白楼下玄学思路
### 什么各种KMP，DP，HASH，各种玄学疯狂操作，码长震惊，本蒟蒻表示并没有看懂怎么办（呆呆的吃手指~）
#### 那怎么办啊，我又不想呆呆的看着他WA0，可怕
#### 玄学思路突现脑中，爆搜？差不多
```cpp
#include<bits/stdc++.h>
using namespace std;
char ch[100001],wzc[100001];
int n;
bool _doudou(int x,int y)//开始爆搜，从后往前搜，避免有的点故意卡你，其实也是为了方便 
{
    if(y==0)//如果匹配串到头了 
    {
        if(x==0)return 1;//通配符串也被吃完了，肯定没问题 
        for(int i=x;i>0;i--)//开始爆搜剩下的'*' 
            if(ch[i]!='*')return 0;//如果还有，肯定不行 
        return 1;//没了，就没问题 
    }
    if(!x)return 0;//如果通配符串先挂完了，就肯定挂了 
    if(ch[x]=='*')//如果搜到了一个'*' 
    {
        for(int i=y;i>=0;i--)//就从剩下的所有的位置开始搜，时间复杂度看起来很高，但是试想几乎所有的情况在搜了一下之后就会跳出，其实也并不复杂 
            if(_doudou(x-1,i))return 1;
    }
    else
    {
        if(wzc[y]==ch[x]||ch[x]=='?')return _doudou(x-1,y-1);//如果是一个'?'，就让两个串都向前走一位 
        else return 0;//挂喽 
    }
}
int main()
{
    scanf("%s%d",ch+1,&n);//读入,QwQ~ 就是想卖个萌 
    int len=strlen(ch+1);
    while(n--)
    {
        scanf("%s",wzc+1);
        if(_doudou(len,strlen(wzc+1)))printf("YES\n");//没为题就输出YES 
        else printf("NO\n");//否则NO 
    }
    return 0;//祝你幸福~ 
}
```
#### 我感觉码长还可以，而且跑的飞快（自我感觉良好）
#### 而且比较适合初学者叭?

---

## 作者：K8He (赞：16)

# 「题解报告」[P3167 [CQOI2014]通配符匹配](https://www.luogu.com.cn/problem/P3167)

[更好的阅读体验](https://www.cnblogs.com/Keven-He/p/16578002.html)

[推销博客](https://www.cnblogs.com/Keven-He/)

## 思路

`*` 和 `?` 显然无法直接匹配，但是可以发现「通配符个数不超过 $10$」，那么我们可以考虑分段匹配。

我们首先把原字符串分成多个以一个通配符开头的字符串，如将 `happy*birthdey?xingchen` 分成：

```
happy
*birthday
?xingchen
```

然后设原串有 $m$ 个通配符， $op_i$ 表示分出来的第 $i$ 个串前的通配符（$0$ 没有，$1$ 是`?`，$2$ 是`*`），$len_i$ 表示分出来的第 $i$ 个串的长度，$f_{i,j}$ 表示分出来的第 $i$ 个串的结尾能否匹配上当前查询的字符串的位置 $j$。

则转移方程显然为：

$$
f_{i,j}=
\begin{cases}
f_{i-1,j-len_i}&op_i=0\\
f_{i-1,j-len_i-1}&op_i=1\\
\sum_{k=0}^{j-len_i}f_{i-1,k}&op_i=2\\
\end{cases}
$$

能否转移直接用 Hash $\Theta(1)$ 比较即可。

初始状态 $f_{0,0}=1$，答案为 $f_{m,\left|S\right|}$，时间复杂度 $\Theta(mn\left|S\right|)$。

## 代码

```cpp
const ll N=1e5+10,inf=1ll<<40;
ll T,n,m=1,ln,ans;
ll a1[20],a2[20],len[20],op[20];
ll f[20][N],sm[N];
char s[N],t[N];
class Hash{
public:
	const ll P1=315716521,P2=475262633;
	ll h1[N],h2[N],z1[N],z2[N];
	inline void Init(char *s){
		z1[0]=z2[0]=1;
		ll length=strlen(s+1);
		_for(i,1,length){
			z1[i]=z1[i-1]*233%P1;
			z2[i]=z2[i-1]*233%P2;
			h1[i]=(h1[i-1]*233+s[i]-'a'+1)%P1;
			h2[i]=(h2[i-1]*233+s[i]-'a'+1)%P2;
		}
		return;
	}
	inline ll GetHash1(ll l,ll r){return (h1[r]-h1[l-1]*z1[r-l+1]%P1+P1)%P1;}
	inline ll GetHash2(ll l,ll r){return (h2[r]-h2[l-1]*z2[r-l+1]%P2+P2)%P2;}
}b;
namespace SOLVE{
	inline ll rnt(){
		ll x=0,w=1;char c=getchar();
		while(!isdigit(c)){if(c=='-')w=-1;c=getchar();}
		while(isdigit(c))x=(x<<3)+(x<<1)+(c^48),c=getchar();
		return x*w;
	}
	inline ll GetA1(char *awa){
		ll hash_val=0;
		ll length=strlen(awa+1);
		_for(i,1,length)hash_val=(hash_val*233+awa[i]-'a'+1)%b.P1;
		return hash_val;
	}
	inline ll GetA2(char *awa){
		ll hash_val=0;
		ll length=strlen(awa+1);
		_for(i,1,length)hash_val=(hash_val*233+awa[i]-'a'+1)%b.P2;
		return hash_val;
	}
	inline void Pre(){
		char qwq[N];
		_for(i,1,n){
			if(s[i]=='?'||s[i]=='*'){
				if(i==1)--m;
				a1[m]=GetA1(qwq);
				a2[m]=GetA2(qwq);
				memset(qwq,0,sizeof(qwq));
				op[++m]=(s[i]=='?')?1:2;
			}
			else qwq[++len[m]]=s[i];
		}
		a1[m]=GetA1(qwq);
		a2[m]=GetA2(qwq);
		return;
	}
	inline bool Check(ll a,ll i){
		if(a1[a]!=b.GetHash1(i-len[a]+1,i))return 0;
		if(a2[a]!=b.GetHash2(i-len[a]+1,i))return 0;
		return 1;
	}
	inline void PP(){
		f[0][0]=1;
		_for(i,0,ln)sm[i]=1;
		_for(i,1,m){
			_for(j,0,ln)f[i][j]=0;
			for_(j,ln,len[i]){
				if(Check(i,j)){
					if(op[i]==0)f[i][j]=f[i-1][j-len[i]];
					else if(op[i]==1)f[i][j]=f[i-1][j-len[i]-1];
					else f[i][j]=sm[j-len[i]];
				}
			}
			sm[0]=0;
			_for(j,1,ln)sm[j]=sm[j-1]|f[i][j];
		}
		return;
	}
	inline void In(){
		scanf("%s",s+1);
		n=strlen(s+1),Pre();
		T=rnt();
		while(T--){
			scanf("%s",t+1);
			b.Init(t),ln=strlen(t+1);
			PP(),puts(f[m][ln]?"YES":"NO");
		}
		return;
	}
}
```

Update 2023/3/1：更改了错误的转移方程。

顺便一提，星尘生日是 8.12，去年手欠发早了。

---

## 作者：_Diu_ (赞：13)

[通配符匹配](https://www.luogu.com.cn/problem/P3167)

这一道题听说可以用AC自动机来做

但是我觉得我们可以让AC自动机去AC别的题目，用最简单的

### 字符串哈希

就可以了

当然还是要跑$dp$的~~qwq~~

---

我们可以设定$bool$型的$f[i][j]$表示

#### 前面原字符串的前$i$个字符与待匹配的字符串的前$j$个字符匹配

如果当前通配符是'*'的话，只要当前匹配了，那么后面所有的都可以匹配

如果在两个通配符之间的字符全部匹配（用$hash$处理）

都可以打标记

但如果当前通配符是'?'的话，不能给当前字符打标记，要跳到下一个

因为'?'只能匹配一个字符

初始化的话

就是$f[0][0]=1$

因为一个字符都没有的两个空串是匹配的

## 关于代码

我的码风十分奇怪，能看得懂就行

其中$tpf$，顾名思义，就是通配符

两个$h$分别表示原字符串和待处理字符串的哈希前缀和

另外，我是用字符串存的，为了方便处理，我在每个字符串前都加上个空格

还有一个比较重要的

如果原字符串最后一个字符不是通配符的话

后面的字符是匹配不到的

所以我在原字符串后面加了一个'?'，为了不改变字符串值，所以在每一个待处理字符串前都要加上任意一个字符

## code

```cpp
#include<bits/stdc++.h>
#define ull unsigned long long
using namespace std;
const int N=100010;
int n,m,k,tpf[50],cnt,ans;
ull h1[N],h2[N],t[N],b=1331;
string s,str;
bool f[20][N];
int main(){
	cin>>s;
	s=' '+s+'?';
	n=s.size()-1;
	t[0]=1;
	for(int i=1;i<N;i++)t[i]=t[i-1]*b;
	for(int i=1;i<=n;i++){
		h1[i]=h1[i-1]*b+s[i];
		if(s[i]=='*'||s[i]=='?')tpf[++cnt]=i;
	}
	scanf("%d",&k);
	while(k--){
		cin>>str;
		str=' '+str+'a';
		m=str.size()-1;
		for(int i=1;i<=m;i++)h2[i]=h2[i-1]*b+str[i];
		memset(f,0,sizeof(f));
		f[0][0]=1;
		for(int i=0;i<=cnt;i++){
			if(s[tpf[i]]=='*')for(int j=1;j<=m;j++)if(f[i][j-1])f[i][j]=1;
			for(int j=0;j<=m;j++){
				if(!f[i][j])continue;
				register int lt=tpf[i]+1,rt=tpf[i+1]-1,ls=j+1,rs=j+(rt-lt+1);
				if(h1[rt]-h1[lt-1]*t[rt-lt+1]==h2[rs]-h2[ls-1]*t[rs-ls+1])
					f[i+1][rs+(s[tpf[i+1]]=='?')]=1;
			}
		}
		puts(f[cnt][m]?"YES":"NO");
	}
}
```

另外，这一道题和[病毒检测](https://www.luogu.com.cn/problem/P2536)也很相似，大家也可以去$A$一下

---

## 作者：longgod (赞：7)

额，其实知道是哈希以后就还好啦

尤其是，当你已经做过病毒检测这道题的时候

不过，当我们对比两题的数据范围之后，我们很快就意识到了一个严肃的问题

显然，这题不可能像之前那样放在一颗Trie树上跑，100000\*100，连插入Trie树都不太可能！

不过，但我们注意到，n<=100且通配符数量<=10这个条件的时候，我们就应该迅速想到一个模糊的思路

以通配符为界，把T(就是一开始的模板串)拆成若干个串，然后一个一个的和文本串去匹配即可，

时间复杂度大致是10\*100\*100000=一亿，似乎要超时啊？不过没事，要有梦想，接着往下想先 

既然通配符有着神奇的性质，那么我们先看通配符两端能不能匹配，最后再考虑万能的通配符。

问题又来了，怎么快速得出两端能否匹配呢？

kmp？

其实，还有更简单的，？Hash！

万能的hash

把模板串和文本串依次hash，就可以快速匹配了

那我们怎么知道当前匹配到了什么地方，下一步该怎么办呢？

仔细想想，这是一个如何“转移”的问题,

转移，

想到了什么，

没错，

DP！

我们设dp\[i\]\[j\]表示，第i个通配符（包括自己）前所有字符已经与文本串中的前j个字符是否匹配

有true or false来表示  

接下来考虑转移，i向i+1转移，检测这一段的字符是否能和文本串匹配，

这一段位置变化就是(loc\[i+1\]-1)-（loc\[i\]+1）+1

那么j也要向前走这么多

若能匹配，

且，第i+1个通配符为'?'的话，那我们二话不说，再往前走一步，

也就是,i+1与j+位置变化+1

如果不是，那么由于\*的性质，我们可以忽略掉这个通配符，也就是不变

等等……

那\*是不是就没用了？

诶，此言差矣，我们每次dp之前，都可以先检测一下当前位置的i和j-1

如果俩能匹配的话，且当前通配符是\*的话，那我们就往下走一步，即if(dp\[i\]\[j-1\]==true) dp\[i\]\[j\]=true

当然，你从j到j+1好像也没什么不行的。

那么经过一轮递归之后，我们就可以看dp\[通配符的个数\]\[文本串长度\]是不是为真，

来判断输出YES还是NO了 

这样也解决了我们先前所担心的超时问题，dp有很多状态达不到，就不担心超时的问题啦！

额，下面代码中用了点小技巧，把模式串末尾补一个'?'，然后文本串末尾随便加一个字符，这样的话会方便一些。 

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define ll unsigned long long
using namespace std;
char T[100005];
char tmp[100005];
bool dp[15][100005];
int loc[15];
ll jz[100005];
ll hash[100005][2],base=131;
int n;
int cnt=0;
inline void dohash(char *s,int k)
{
	register int i,len=strlen(s+1);
	hash[0][k]=0;
	for(i=1;i<=len;i++)
	hash[i][k]=hash[i-1][k]*base+(ll)s[i];
}
inline ll gethash(int l,int r,int k)
{
	if(r<l) return -1;
	return hash[r][k]-jz[r-l+1]*hash[l-1][k];
}
int main()
{
	scanf("%s",T+1);
	register int i,j,k,len,Len=strlen(T+1);
	jz[0]=1;
	for(i=1;i<=100000;i++)
	jz[i]=jz[i-1]*base;
	dohash(T,0);
	for(i=1;i<=Len;i++)
	if(T[i]=='?'||T[i]=='*')
	loc[++cnt]=i;
	Len++;
	loc[++cnt]=Len;T[Len]='?';
	scanf("%d",&n);
	while(n--)
	{
		scanf("%s",tmp+1);
		len=strlen(tmp+1);
		tmp[++len]='&';
		dohash(tmp,1);
		memset(dp,false,sizeof dp);
		dp[0][0]=true;
		for(i=0;i<=cnt;i++)
		{
			if(T[loc[i]]=='*')
			for(j=1;j<=len;j++)
			if(dp[i][j-1]) dp[i][j]=true;
			for(j=0;j<=len;j++)
			{
				if(dp[i][j]&&gethash(j+1,j+(loc[i+1]-1)-(loc[i]+1)+1,1)==
				gethash(loc[i]+1,loc[i+1]-1,0))
				{
					if(T[loc[i+1]]=='?')
					dp[i+1][j+(loc[i+1]-1)-(loc[i]+1)+1+1]=true;
					else
					dp[i+1][j+(loc[i+1]-1)-(loc[i]+1)+1]=true;
				}
			}
		}
		if(dp[cnt][len]) puts("YES");
		else puts("NO");
	}
	return 0;
}
```

---

## 作者：_J_C_ (赞：6)

**其实……不用动态规划。**

很容易想到的是，按照"\*"将模板串分段，那么每一段其实都是相互独立的——只要在询问串中能**相继**找到这些段即可。（我语文不好...以下你可能会看到不太合语文语法的"段"，意指按照'\*'分隔出来的字符串）

比如：
```cpp
*abc*bcd*efg* -> abc, bcd, efg
```
分成三段。只要这三段都能在询问里先后找到即合法。而且显然的是，找到的越前面就越优（**找到越前意味着留给后面的选择越多**，毕竟‘\*’可以任意跳，实在不行把多出来的交给‘\*’跳过就好了）。当然，收尾如果不是通配符就要直接比较一下，因为首尾固定了不能动。

那么想想怎么找。。。

首先最好想到的当然是KMP，把'?'跟任何一个字符都认为相等就好了嘛。**你看这个复杂度，它多么优秀啊！**走，KMP！

（这么想的同学**转到楼下大佬的题解**。。我模拟赛时打的也是KMP。。。）

没了KMP，我们能快速匹配字符串的方法好像只有**hash**了。

（原理，懂的同学可以跳过）令数组hash[i]表示**str[i] + str[i + i] \* base + str[i + 2] \* base ^ 2 + ... + str[n] * base ^ (n - i)**，其中str[i]表示第i位字符，base为任意指定的正整数，**hash[n]本质上相当于以一个base进制数表示1到n这段的字符串**

那么有**hash[i] = hash[i + 1] \* base + str[i]**，我们可以O(n)递推出一个字符串的hash数组。

而且对于其中一个子串[x, x + len]，它的hash值我们可以通过对hash数组作减法得到：
```cpp
son_hash(begin, length) = hash[begin] - hash[begin + length] * base ^ length
```
只要我们再预处理出所有base^i，上面的式子就是O(1)可得的了。

也就是说，O(n)的预处理后，对于一个给定的字符串中的任意子串，我们可以用O(1)的时间求出其hash值。

一般来说，我们都不会希望一个数字"爆int"，"爆long long"，所以会给它加上一个取模。但对于hash值来说，我们可以不必去模它，而是使用unsigned long long让它自然溢出，这样做比取模要快很多。虽然这样是可能被卡掉的（因为这样就是%2^63次），但一般不会有恶毒的出题人特意来卡自然溢出。


**来说说具体的。**

首先明确一下问题，原问题已经转化成了给定一个带‘?’的字符串，求在给定字符串中出现的最早位置。（不停的做这个问题，就能处理完所有段了）

显然的是，**如果把'?'的值算在hash值里面，我们之前关于hash值比较的一大段话就全当放屁了**。（把‘？’的算入hash值，能相等才怪——相等了反倒就是hash冲突了。。）

**所以'?'要被单独**~~约谈~~**处理**。对于已经按照'\*'分隔出来的每一段，我们再把它按照'?'单独分开来，一段一段的找。注意这里和'\*'的不同之处：**'\*'可以不连续，但'?'只能抵掉一个字符**。

那么我们要比较按照'\*'分隔的段，比较的大概就是下面这种东西：
```cpp
hash_val1, ?, ?, hash_val2, ?, hsah_val3, ……
```
比较hash值的时候比去就好了，如果碰到'?'就把询问串的起始指针（下标）往后移动一位，因为'?'匹配且只匹配一个字符。

当然，如果匹配到后面发现匹配不上，就要把询问串的指针往前回溯，回溯到之前的位置+1。**听起来很复杂，但实际上写成多个函数就好多了。**

我的代码实现未必和上述吻合，但思路是一致的，实现就见仁见智吧。

代码里面会加一小点注释，读者可以细细品味。

```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>

#include <vector>

namespace my {
	typedef unsigned long long ull;
	const int maxn(112345);
	const ull base(23);//选择的进制数
	ull power[maxn];//power[i] = base ^ i，其中'^'表示幂
	inline void init_power() {
		power[0] = 1;
		for (int i(1); i != maxn; ++i) {
			power[i] = power[i - 1] * base;
		}
	}
	class string {//自己写的string，封装了一下hash相关的函数
		public:
			string() : end(0) {}
			char& operator[](int p) {
				return str[p];
			}
			void clear() { end = 0; }
			void read() {//读入
				end = 0;
				char c(getchar());
				while (c < 'a' || c > 'z') c = getchar();
				str[end++] = 'a';//在字符串收尾统一加入相同字符不会影响答案，且避免了结尾、开头是通配符的情况。
				do {
					str[end++] = c;
					c = getchar();
				} while (c >= 'a' && c <= 'z');
				str[end++] = 'a';
				init_hash();
			}
			bool empty() const { return end == 0; }
			int size() const { return end; }
			void push_back(char c) {//向该string中加入字符
				if (c == '?') pos.push_back(end);//pos记录了该string所有'?'的位置（原因是我在分段时只调用这个函数向string中加入字符）
				str[end++] = c;
			}
			void init_hash() {//初始化hash，原理如上所述
				hash[end] = 0;
				for (int i(end - 1); i >= 0; --i) {
					hash[i] = hash[i + 1] * base + str[i];
				}
			}
			ull gethash(int beg, int len) const {//获得其中某一段的hash值
				return hash[beg] - hash[beg + len] * power[len];
			}
			ull gethash() const {//获得整段的hash值，程序中似乎没有用到
				return hash[0];
			}
			std::vector<int> pos;//pos记录所有'?'的位置
		protected:
			char str[maxn];
			ull hash[maxn];
			int end;
	}seg[20], head, tail, dest;//四者分别是：模板串分出来的每一段，模板串的首，模板串的尾，目标串（询问串）
	char str[maxn];
	int endseg, lenstr;//endseg即分出来的段数
	void init_seg(int len) {//把模板串分段
		int left(0), right(len - 1);
		while (left <= right) {//先处理首
			if (str[left] == '*') break;
			head.push_back(str[left++]);
		}
		head.init_hash();
		int pos(right);
		while (left <= pos) {//由于尾串大小不定，先找到起始点
			if (str[pos] == '*') break;
			--pos;
		}
		for (int i(pos + 1); i <= right; ++i) {
			tail.push_back(str[i]);
		}
		tail.init_hash();
		++left; right = pos;
		while (left <= right) {//处理出所有的段
			if (str[left] == '*') {//每段间的分隔符
				if (!seg[endseg].empty())//为避免ab******c的情况，判断一下是否为空
					seg[endseg].init_hash(), ++endseg;//非空，初始化hash值
				++left;
				continue;
			} else {
				seg[endseg].push_back(str[left++]);//加入段中
			}
		}
		if (!seg[endseg].empty()) ++endseg;//如果endseg中有元素，++endseg使其指向超出末端下一位
	}
	
	inline bool match(int s, int beg) {//常识将段seg[s]与目标串beg处开始的字符串进行匹配
		int front(0);
		for (int i(0); i != seg[s].pos.size(); ++i) {//枚举'?'间的字符串
			int len(seg[s].pos[i] - front);
			if (seg[s].gethash(front, len) != dest.gethash(beg, len)) {//hash值不相等，一定没对上
				return false;
			}
			beg += len + 1;
			front += len + 1;//匹配上了，那么继续匹配下一个。+1是表示这里跳了一个字符(即'?')
		}
		int len(seg[s].size() - front);
		if (seg[s].gethash(front, len) != dest.gethash(beg, len)) return false;//最后没有'?'之后可能还有一段需要比较 
		return true;
	}
	inline bool com_seg(int s, int& left, int right) {
		while (left <= right) {//尝试将段seg[s]与dest在[left, right]间的子串进行匹配
			if (match(s, left)) {
				left += seg[s].size();//如果成功匹配，left就往后跳到下一个需要匹配的起始位置
				return true;
			}
			++left;//匹配失败，尝试++left继续匹配
		}
		return false;
	}
	inline bool cmpstr(string& a, int x, string& b, int y, int len) {//比较a从x处的长度为len的字符串是否与b从y处开始的长度为len的字符串相等
		for (int i(0); i != len; ++i) {
			if (a[x + i] != b[y + i] && a[x + i] != '?' && b[y + i] != '?') return false;
		}
		return true;
	}
	void compare() {//整体的匹配
		int left(0), right(dest.size() - 1);
		if (head.size() > dest.size() || tail.size() > dest.size()) {//首、尾串大小对不上，一定错了。
			printf("NO\n");
			return;
		}
		if (!cmpstr(head, 0, dest, 0, head.size())) {//由于插入了'a'，模板串的首串一定不是通配符，一定要与目标串的开头匹配。
			printf("NO\n");
			return;
		} else {
			left = head.size();
		}
		if (!cmpstr(tail, 0, dest, right - tail.size() + 1, tail.size())) {//与上同理，匹配尾串
			printf("NO\n");
			return;
		}
		else {
			right = right - tail.size();
		}
		for (int i(0); i != endseg; ++i) {
			if (!com_seg(i, left, right)) {尝试将段seg[i]与left到right的字符串匹配（可以跳跃，因为段的收尾都是被抹去的'\*'）
				printf("NO\n");
				return;
			}
		}
		printf("YES\n");
	}
	
	int main() {
		init_power();//一些初始化和函数调用
		int T;
		scanf("%s%d", str + 1, &T);
		str[0] = 'a';
		str[lenstr = ::strlen(str)] = 'a';
		init_seg(++lenstr);
		while (T--) {
			dest.read();
			compare();
		}
		return 0;
	}
}

int main() {
	return my::main();
}

```

---

## 作者：_maze (赞：3)

在[这里](https://www.cnblogs.com/closureshop/p/16882153.html)食用更佳哦。

想了两种做法，第一种拿到了 10 分的好成绩。

而第二种做法不用前缀和，而且还跑的飞快。目前最优解第三~~尝试卡进最优解未果~~。

不得不说这是一道好题，做完对 KMP 有了更深的理解。

# 1.（本人的） KMP 究竟哪里错了

首先，看到匹配，第一眼想到 KMP。接着就能发现实际上分隔符 ```*``` 实际上就是把一整个字符串分成了若干个小串，匹配完一个才能匹配下一个。

然后有一个显而易见的结论：每一个小串能完全匹配时就要匹配，因为之后的 ```*``` 可以匹配任意长的字符串（但要注意匹配最后一个小串终点的特判）。 

于是我们可以口胡出一个看起来很对的做法：对每个小串做 KMP，遇到问号直接当做匹配，然后在询问串上跑匹配完一个小串就进入下一个小串。时间复杂度线性。

正如前言所说，你可以在我的提交记录看到夺目的 10 分。为什么错了呢？

考虑这样一个串：```aca?c``` 。按照 KMP 数组的定义，求出的失配指针应该为 $0,0,1,2,2$。但实际上，如果我们按照上述步骤来求，答案会是这样：$0,0,1,2,0$。

为什么呢？设字符串为 $s$，当前自匹配到 $j$，失配数组为 $fail$，那么当我们循环到最后一个字符时，我们要将 $s_{j+1}$ 也就是 $s_3$ 与 $s_5$ 比较。发现不行，这时我们的 $j$ 会回跳到 $fail_j$ 也就是 $s_0$ 处。这似乎是一个正常的 KMP 过程。

但是 KMP 的优化在此时会默认本来为 ```?``` 的 $s_4$ 为 ```a``` 。因为计算机会认为既然 $s_2$ 与 $s_4$ 相匹配，那么 $s_4 = s_2$ 也是理所因当的。这时失配指针往回跳时就没有考虑 $s_4$ 发生变化的情况，它只会憨憨地认为 ```ac``` 与 ```cc``` 不匹配，所以应该跳回起点。

至此，我们的问号直接跳计划宣告破产。

# 2.跑的飞快的哈希做法

一个串与一个串匹配，除了 KMP ，我们还可以想到哈希。在以 ```*``` 为分隔将大串分割为小串后，每一个小串的长度固定。于是可以直接扫询问的字符串，每次提取出当前小串长度的字符串 $O(1)$ 求哈希值。

说具体点，你首先从起点提取出小串长度的字符串，顺便记录一下最左边乘了几次哈希的单位，然后转移时删除最左边的权值乘最左边乘过的哈希单位就行。

下面是一张图，假设小串长度为 3：

![](https://cdn.luogu.com.cn/upload/image_hosting/zx90qpfh.png)

不许说我字丑！

那问号怎么办呢？我们把问号的权值置为 0，动态记录当前询问串中哪几个串与问号对应，将这些点的权值强制赋为 0（方法可参照减去最左端权值的方法），向后推进时暴力转移，将所有与问号对应的下标加一即可。

由于问号最多只有 10 个，所以复杂度就是 $O(n)$ 带了个 10 的常数。

这一道题还有一些小细节需要注意：

1. 开头除非有一个 ```*``` 挡着，否则第一个小串一定要与询问串前缀匹配。所以要特判，否则会在第三个点 WA。
2. 到最后除非有一个 ```*``` 挡着，否则最后一个串一定要与询问串后缀匹配。如果最后一个串匹配了却不是与后缀匹配的，那么就不能结束，还要继续比较。
3. 每一次向后推进时，先加上原先串被强制赋为 0 的点的权值，再减去最左边的权值乘上它的幂，（详情参照上图）并加上下一位权值，最后再将当前与问号匹配的点强制赋为 0。如果第一二步顺序乱掉的话会导致被开头是 ```?``` 的数据 hack 掉。因为此时最左边的权值减了两遍。

```cpp
#include <bits/stdc++.h>
#define ull unsigned long long
using namespace std;
#define rep(i,a,b) for(int i =(a);i <= (b);i ++)
const int maxn = 1e5 + 5;
const ull base = 19260817;
int len[maxn], tot;
bool pd[15];
string s, p[maxn];
ull H[maxn];
bool hjl, hzh;
ull qpow(ull u, ull v)
{
    ull ans = 1;
    while(v)
    {
        if(v & 1) ans *= u;
        u *= u;
        v >>= 1;
    }
    return ans;
}
void solve()
{
	int n = s.size();
	s = ' ' + s;
    ull ha = 0, now = 1;
    bool pd = 0;
    ull en[12], st = -1, cnt = 0, mi[12], big = 0;//st为最左边的下标，en与cnt存储与问号匹配的点，mi统计与问号对应的点乘了几次base，big统计最左端乘了几次base
    rep(i, 1, n)
    {
        int li = i;
        if(pd == 0)
        {
            st = i;
            int m = p[now].size() - 1;
            cnt = 0;big = 1;ha = 0;
            rep(j, 0, m)
            {
                ha *= base;
                if(j > 0) big *= base;
                if(p[now][j] != '?') 
                {
                    ha += (ull)(s[i] - 'a' + 1);
                }
                else
                {
                    en[++ cnt] = i;//顺便记录每个?的初始对应位置
                    mi[cnt] = qpow(base, m - j);
                }
                i ++;
            }
            pd = 1;
            if(ha == H[now]) //一开始提取出的串也要进行匹配 
            {
                int o = 0;
                if(now < tot) now ++, pd = 0, o = 1;
                if(o == 0 && (i >= n || hzh == 1))//即使所有串匹配完了也不一定完全匹配，具体参照上文提醒
                {
                    cout << "YES" << endl;
                    return;
                }
            }
            else if(hjl == 0 && li == 1)
            {
                cout << "NO" << endl;
                return ;
            }
            i --;
            continue;
        }
        rep(j, 1, cnt) ha += (ull)(s[en[j]] - 'a' + 1) * mi[j], en[j] ++;
        ha -= (ull)(s[st] - 'a' + 1) * big;
        ha *= base;
        ha += (ull)(s[i] - 'a' + 1);
        st ++;
        rep(j, 1, cnt) ha -= (ull)(s[en[j]] - 'a' + 1) * mi[j];//注意顺序
        if(ha == H[now])
        {
            int o = 0;
            if(now < tot) now ++, pd = 0, o = 1;
            if(o == 0 && (i >= n || hzh == 1))
            {
                cout << "YES" << endl;
                return;
            }
        }
    }
    cout << "NO" << endl;
    return ;
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin >> s;
	int n = s.size();
	string c = "";
    rep(i, 0, n - 1)
	{
		if(s[i] == '*') 
		{
            if(i == 0) hjl = 1;
            if(i == n - 1) hzh = 1;//如果开头结尾有*，那么没有匹配前后缀的字符串也能视作完全匹配
			if(c != "") p[++ tot] = c, c = "";
		}
		else c = c + s[i];
	}
	if(c != "") p[++ tot] = c;
    rep(i, 1, tot)
    {
        int m = p[i].size();
        rep(j, 0, m - 1)
        {
            H[i] *= base;
            if(p[i][j] != '?') H[i] += (ull)(p[i][j] - 'a' + 1);
        }
    }
	int Q;
	cin >> Q;
	while(Q --)
	{
		cin >> s;
		solve();
	}
}
```

本篇题解就到这里了，考虑考虑点个推荐，然后去把本菜鸡从最优榜上挤下去？

---


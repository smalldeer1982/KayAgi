# [JLOI2016/SHOI2016] 侦察守卫

## 题目描述

小 R 和 B 神正在玩一款游戏。这款游戏的地图由 $N$ 个点和 $N-1$ 条无向边组成，每条无向边连接两个点，且地图是连通的。换句话说，游戏的地图是一棵有 $N$ 个节点的树。

游戏中有一种道具叫做侦查守卫，当一名玩家在一个点上放置侦查守卫后，它可以监视这个点以及与这个点的距离在 $D$ 以内的所有点。这里两个点之间的距离定义为它们在树上的距离，也就是两个点之间唯一的简单路径上所经过边的条数。在一个点上放置侦查守卫需要付出一定的代价，在不同点放置守卫的代价可能不同。

现在小 R 知道了所有 B 神可能会出现的位置，请你计算监视所有这些位置的最小代价。


## 说明/提示

对于所有的数据，$N \le 5 \times 10 ^ 5,D \le 20$。

## 样例 #1

### 输入

```
12 2
8 9 12 6 1 1 5 1 4 8 10 6
10
1 2 3 5 6 7 8 9 10 11
1 3
2 3
3 4
4 5
4 6
4 7
7 8
8 9
9 10
10 11
11 12```

### 输出

```
10```

# 题解

## 作者：xuxinyu (赞：37)

假设当前到了x的子树，现在是合并 x的第k个子树

 

f[x][j] 表示x的前k-1个子树该覆盖的完全覆盖，而且还能向上覆盖j层的最小代价

这个向上是针对x来说的，即可以向x的祖先方向再覆盖j层

对于第k个子树的意义就是，兄弟子树放置的守卫可以帮x的第k个子树覆盖前j层（第1层为x的子节点）

那么相应的就要有一个状态来表示这个 可以让兄弟子树 帮忙覆盖 的前j层

 

g[x][j] 表示还需要覆盖x的前k个子树中的前j层，且第j层以下该覆盖的完全覆盖（第1层为x）的最小代价

 

状态转移：

设x的第k个子节点为y

向x的上方覆盖j层，只需要x的子节点中有一个子节点z能向上覆盖j+1层 即可

所以f的转移有两种：z是前k-1个子节点中的，z是第k个子节点

f[x][j]=min（f[x][j]+g[y][j] ，f[y][j+1]+g[x][j+1]）

g[x][j]+=g[y][j-1]

 

但是有可能x 再向上恰好覆盖j层的代价要小于再向上恰好覆盖j-1层的代价

即覆盖的更多代价反而要小

所以将f的状态定义改为 向上覆盖至少j层的最小代价

同理，g的状态定义改为还需要覆盖至多j层的最小代价

对f[x][]做一个后缀最小值，g[x][]做一个前缀最小值

代码[http://www.cnblogs.com/TheRoadToTheGold/p/8544819.html](http://www.cnblogs.com/TheRoadToTheGold/p/8544819.html)

---

## 作者：zcysky (赞：29)

首先我认为**楼上的动态规划方程是错的**，状态不倒序存的话难道数量不会爆炸？


题意：每个点有一个覆盖半径，求覆盖完整棵树的最小代价。


定义状态：


$f[i][j]$ 表示在子树$i$ 中，向下还有深度$j$ 没有被覆盖的最小代价。


$g[i][j]$子树$i $已经被完全覆盖，向上已经覆盖了$j $层所需要的最小代价。


那么如果我们到了第$x $个节点，开始枚举第$u $个子树，我们需要的方程是：


$f[x][j]=min(min(f[x][j]+g[u][j],g[x][j+1]+f[u][j+1]),f[x][j-1])$


$g[x][0]=f[x][0]$


$g[x][i]=min(g[x][i-1],g[x][i]+g[u][i-1])$


所以代码如下：


```cpp
#include<bits/stdc++.h>
#define N 500005
#define inf 100000007
using namespace std;
struct Edge{int u,v,next;}G[N*2];
int n,m,d;
int val[N],head[N],f[N][25],g[N][25],tot=0;
bool vis[N];
inline void addedge(int u,int v){
    G[++tot].u=u;G[tot].v=v;G[tot].next=head[u];head[u]=tot;
    G[++tot].u=v;G[tot].v=u;G[tot].next=head[v];head[v]=tot;
}
void dfs(int u,int fa){
    if(vis[u])f[u][0]=g[u][0]=val[u];
    for(int i=1;i<=d;i++)g[u][i]=val[u];
    g[u][d+1]=inf;
    for(int i=head[u];i;i=G[i].next){
        int v=G[i].v;if(v==fa)continue;
        dfs(v,u);
        for(int j=d;j>=0;j--)g[u][j]=min(g[u][j]+f[v][j],g[v][j+1]+f[u][j+1]);
        for(int j=d;j>=0;j--)g[u][j]=min(g[u][j],g[u][j+1]);
        f[u][0]=g[u][0];
        for(int j=1;j<=d+1;j++)f[u][j]+=f[v][j-1];
        for(int j=1;j<=d+1;j++)f[u][j]=min(f[u][j],f[u][j-1]);
    }
}
inline int read(){
    int f=1,x=0;char ch;
    do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');
    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');
    return f*x;
}
int main(){
    freopen("observer.in","r",stdin);
    freopen("observer.out","w",stdout);
    n=read();d=read();
    for(int i=1;i<=n;i++)val[i]=read();
    m=read();int x;
    for(int i=1;i<=m;i++){int x=read();vis[x]=true;}
    for(int i=1;i<n;i++){
        int u=read(),v=read();addedge(u,v);
    }
    dfs(1,0);
    printf("%d\n",f[1][0]);
}
```

---

## 作者：redegg (赞：28)

这题不是几个转移方程那么简单的（至少本菜鸡理解了整整半天...）。


设$f[x][i]$表示包括$x$点的$x$的子树中所有关键点被全部覆盖，并且**至少**还可以继续往$x$父亲节点方向覆盖$i$个点的最小代价。

设$g[x][i]$表示往下距离$x$点深度$i$的所有关键点被覆盖，剩下距离$x$点距离不超过$i$的（包括$x$）的是否覆盖**随意**的情况下的最小代价。

设$e$是$u$的子节点，以下是两个基本的转移方程。

$$f[u][i]=min(f[u][i]+g[e][i],g[u][i+1]+f[e][i+1])$$

$$g[u][i]=\sum g[e][i-1]$$

然后，根据我在状态中的定义（特别是加黑的地方，没用但可以帮助理解），我们还可以得到这两个：

$$f[u][i]=min(f[u][i],f[u][i+1])$$

$$g[u][i]=min(g[u][i],g[u][i-1])$$

然后转移方程列出来了后，我们还需要区分一下关键点和普通点的初始状态，因为关键点必选，普通点选不选没关系，可以得到：

$f[x][0]=cost[x],f[y][0]=0$，$x$是关键点，$y$是普通点，这样定义只是初始状态的设置，然后在后期转移中是会和子树合并重新计算的（这个地方需要结合其他部分一起理解）。

当然，还有一个初始状态，无论是关键点还是普通点，初始状态下我要覆盖其他点的时候一定说明我在我这里建了一个哨站。

那么$f[x][i]=cost[x](0<i\le d)$。

我们合并子树时，我们先算$f$，再算$g$，因为当时的$u$还没有和$e$子树合并，而我们第一个转移方程中的$g$的含义也恰恰是在不考虑$u$的$e$子树情况下的$g$，如果先算了$g$就和第一个转移方程中的$g$不同了，所以为了正确的转移$f$，我们需要先算$f$。

然后对于$g[x][0]$，相当于至少覆盖$x$子树的最小代价，而$f[x][0]$也是这个含义，所以我们开始算$g$的时候，让$g[x][0]=f[x][0]$。为什么？因为$g[x][0]$是无法通过第二个转移式计算的。

然后就是按照第二个转移式计算，最后在按照第三个和第四个，这就是树形$DP$转移的全部过程了。

```
#include <bits/stdc++.h>
using namespace std;

const int MAXN=5e5+5;

int n,d,m;
int cost[MAXN];
bool vis[MAXN];
vector<int> q[MAXN];

int f[MAXN][31];
int g[MAXN][31];

void dfs(int x,int pr)
{
    if(vis[x])
        f[x][0]=g[x][0]=cost[x];
    else f[x][0]=0,g[x][0]=0;
    for(int i=1;i<=d;i++)
        f[x][i]=cost[x];
    for(int i=0;i<q[x].size();i++)
    {
        int nx=q[x][i];
        if(nx==pr)continue;
        dfs(nx,x);
    }
    for(int i=0;i<q[x].size();i++)
    {
        int nx=q[x][i];
        if(nx==pr)continue;
        for(int j=d;j>=0;j--){
            f[x][j]=min(min(f[x][j]+g[nx][j],g[x][j+1]+f[nx][j+1]),f[x][j]+f[nx][j+1]);
        }
        for(int j=d;j>=0;j--)
            f[x][j]=min(f[x][j+1],f[x][j]);
        g[x][0]=f[x][0];
        for(int j=1;j<=d+1;j++)
            g[x][j]=g[x][j]+g[nx][j-1];
        for(int j=1;j<=d+1;j++)
            g[x][j]=min(g[x][j],g[x][j-1]);
    }
    for(int j=d;j>=0;j--)
        f[x][j]=min(f[x][j+1],f[x][j]);
    for(int j=1;j<=d+1;j++)
        g[x][j]=min(g[x][j],g[x][j-1]);
}

int main()
{
    scanf("%d%d",&n,&d);
    for(int i=1;i<=n;i++)
        scanf("%d",&cost[i]);
    scanf("%d",&m);
    for(int i=1;i<=m;i++){
        int x;scanf("%d",&x),vis[x]=1;
    }
    for(int i=1;i<n;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        q[x].push_back(y);
        q[y].push_back(x);
    }
    memset(f,0x3f,sizeof(f));
    dfs(1,1);
    int ans=1e9;
    for(int i=0;i<=d;i++)
        ans=min(f[1][i],ans);
    printf("%d\n",ans);
    return 0;
}

```


---

## 作者：shadowice1984 (赞：14)

正常向的树形dp，转移方程难度适中
______________________

## 本题题解

我们直接上树形dp的一般套路，设$dp_{i,xxx}$表示决策到第$i$个点，有了xxx限制之后的最小花费，然后一条边一条边的去合并每一个子树

那么我们发现一个子树和外界的唯一联系就是这个子树的根节点，换句话说里面无论怎么填最后外面的眼要进来必须经过根节点，里面的眼想出去也必须经过根节点

那么我们的第二维基本就能定下来了$dp_{i,j}$表示决策到第i个点，i子树中的排布情况等价于点i处插了一个视野为j的眼时的最小花费

同时我们发现可能光设计这样一个状态并不能转移的，因为我们可能会出现一个眼观察了并非它祖先也并非它子树中的点的情况(就是绕过去观察点了)

所以我们额外设计一个状态$fdp_{i,j}$表示决策到第$i$个点，$i$处插了一个视野为$j$的眼的时候i子树中的所有点**可以**被照亮的最小花费(这里不是恰好，换句话说可能会存在视野更小也全部照亮的情况，不然后边转移方程没法理解了)

那么对于树形dp的话，我们推转移方程的时候只需要考虑在(u,v)间连一条边时的转移(其中u是v的父亲)

那么我此时的转移方程就~~并不显然了~~

### case1:求dp(u,k)

那么我们发现$dp(u,k)$的转移只有一种选择就是u这个位置去插眼，因此转移方程是


$$dp(u,k)=dp(u,k)+min(\min_{i=0}^{k}dp(v,k),\min_{i=0}^{k-1}fdp(v,k))$$

这个方程的意思是v子树中的东西随便选，因为我是在u这个位置插的眼

### case2:求dp(u,j)

这两种情况取$min$就是$dp(u,j)$的值

$$dp(u,j)=dp(u,j)+min(\min_{i=0}^{j-1}fdp(v,i),\min_{i=0}^{k}dp(v,i))$$

$$dp(u,j)=dp(v,j+1)+min(\min_{i=0}^{j}fdp(u,j),\min_{i=0}^{k}dp(u,j))$$

也十分好理解，就是枚举这个眼是插在了u里面还是v里面

### case3:求fdp(u,0)

$fdp(u,0)$也只有一种选择就是$u$本身是个关键点并且没插眼，同时他的子树必须能够管到自己

$$fdp(u,0)=fdp(u,0)+\min_{i=0}^{k}dp(v,i)$$

这个方程的意思就是v这个子树必须能够管到自己

___________________

## 边界条件

除了以下几个特殊的dp值其他东西的dp值全部初始化为正无穷

1.对于任意的点$u$,$dp(u,k)=w_{u}$

2.对于一个需要被照亮的点$u$,$fdp(u,0)=0$

3.对于一个不需要被照亮的点$u$,$dp(u,0)=0$

这样设置边界条件也十分简单，因为定义就是如此

然后接下来的事情就是模拟转移方程了……

上代码~

```C
// luogu-judger-enable-o2
#include<cstdio>
#include<algorithm>
using namespace std;const int N=5*1e5+10;const int M=22;
int n;int m;int k;int dp[N][M];int fdp[N][M];int w[N];bool imp[N];
int v[2*N];int x[2*N];int ct;int al[N];int tru[M];int trv[M];
inline void add(int u,int V){v[++ct]=V;x[ct]=al[u];al[u]=ct;}
inline void rs(int& x){x=min(x,0x3f3f3f3f);}
inline void dfs(int u,int f)
{
    for(int j=al[u];j;j=x[j])//这里有个trick是把后缀最小值的表打出来
    {
         if(v[j]==f)continue;int V=v[j];dfs(V,u);
         tru[0]=dp[u][0];for(int i=1;i<=k;i++)tru[0]=min(tru[0],dp[u][i]);
         for(int i=1;i<=k;i++)tru[i]=min(tru[i-1],fdp[u][i-1]);
         trv[0]=dp[V][0];for(int i=1;i<=k;i++)trv[0]=min(trv[0],dp[V][i]);
         for(int i=1;i<=k;i++)trv[i]=min(trv[i-1],fdp[V][i-1]);
         for(int i=0;i<k;i++)dp[u][i]=min(dp[u][i]+trv[i],dp[V][i+1]+tru[i+1]),rs(dp[u][i]);
         for(int i=1;i<=k;i++)fdp[u][i]=min(fdp[u][i]+trv[i],fdp[V][i-1]+tru[i]),rs(fdp[u][i]);
         dp[u][k]=dp[u][k]+trv[k];fdp[u][0]=fdp[u][0]+trv[0];rs(dp[u][k]);rs(fdp[u][0]);
    }	
}
int main()
{
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;i++)scanf("%d",&w[i]);
    for(int i=1;i<=n;i++)for(int j=0;j<=k;j++)dp[i][j]=0x3f3f3f3f;
    for(int i=1;i<=n;i++)for(int j=0;j<=k;j++)fdp[i][j]=0x3f3f3f3f;
    scanf("%d",&m);for(int i=1,t;i<=m;i++)scanf("%d",&t),imp[t]=true;
    for(int i=1,u,v;i<n;i++)scanf("%d%d",&u,&v),add(u,v),add(v,u);
    for(int i=1;i<=n;i++)dp[i][k]=w[i],(imp[i]?fdp[i][0]:dp[i][0])=0;
    dfs(1,0);int res=0x3f3f3f3f;
    for(int i=0;i<=k;i++)res=min(res,dp[1][i]);printf("%d",res);return 0;//拜拜程序~
}
```

---

## 作者：M_seа (赞：10)

##题面

[luogu](https://www.luogu.org/problemnew/show/P3267)

##题解

树形$dp$

$f[x][y]$表示x的y层以下的所有点都已经覆盖完，还需要覆盖上面的y层的最小代价。

$g[x][y]$表示x子树中所有点都已经覆盖完，并且x还能向上覆盖y层的最小代价。

对于 $u->v$, $u$为$v$的父亲:


$g[u][j] = min(g[u][j]+f[v][j], g[v][j+1]+f[u][j+1])$

$f[u][j] = Σf[v][j-1]$

$g[u][j] = min(g[u][j], g[u][j+1])$

$f[u][j] = min(f[u][j], f[u][j-1])$

##Code
```cpp
#include<bits/stdc++.h>

#define LL long long
#define RG register

using namespace std;
template<class T> inline void read(T &x) {
    x = 0; RG char c = getchar(); bool f = 0;
    while (c != '-' && (c < '0' || c > '9')) c = getchar(); if (c == '-') c = getchar(), f = 1;
    while (c >= '0' && c <= '9') x = x*10+c-48, c = getchar();
    x = f ? -x : x;
    return ;
}
template<class T> inline void write(T x) {
    if (!x) {putchar(48);return ;}
    if (x < 0) x = -x, putchar('-');
    int len = -1, z[20]; while (x > 0) z[++len] = x%10, x /= 10;
    for (RG int i = len; i >= 0; i--) putchar(z[i]+48);return ;
}
const int N = 500010, INF = 1e9;
int n, d, w[N];
struct node {
    int to, next;
}G[N<<1];
int last[N], gl;
bool vis[N];
void add(int x, int y) {
    G[++gl] = (node) {y, last[x]};
    last[x] = gl;
}
int f[N][22], g[N][22];
void dfs(int u, int fa) {
    if (vis[u]) f[u][0] = g[u][0] = w[u];
    for (int i = 1; i <= d; i++) g[u][i] = w[u];
    g[u][d+1] = INF;
    for (int i = last[u]; i; i = G[i].next) {
        int v = G[i].to;
        if (v == fa) continue;
        dfs(v, u); 
    }
    for (int i = last[u]; i; i = G[i].next) {
        int v = G[i].to;
        if (v == fa) continue;
        for (int j = 0; j <= d; j++) g[u][j] = min(g[u][j]+f[v][j], f[u][j+1]+g[v][j+1]);
        for (int j = d; j >= 0; j--) g[u][j] = min(g[u][j], g[u][j+1]);
        f[u][0] = g[u][0];
        for (int j = 1; j <= d; j++) f[u][j] += f[v][j-1];
        for (int j = 1; j <= d; j++) f[u][j] = min(f[u][j], f[u][j-1]);
    }
    return ;
}

int main() {
    read(n); read(d);
    for (int i = 1; i <= n; i++) read(w[i]);
    int m; read(m);
    for (int i = 1; i <= m; i++) {
        int x; read(x);
        vis[x] = 1;
    }
    for (int i = 1; i < n; i++) {
        int x, y; read(x); read(y);
        add(x, y); add(y, x);
    }
    dfs(1, 0);
    printf("%d\n", g[1][0]);
    return 0;
}

```

---

## 作者：Nekroz (赞：7)

# $Description$

给定一个 $n$ 个结点的二叉树 $T$ ，并给出 $m$ 个需要覆盖的点，每个结点可以花费 $w_i$ 去覆盖以它为中心距离不大于 $d$ 的所有结点，求最小花费。

# $Solution$

树形 DP

我个人觉得这道题最难的部分是定状态。当 $d = 0$ 的时候就是树的最大独立集问题，我们当时用 $f_{i,0/1}$ 表示在 $i$ 子树中（取不取 $i$ 由 $0/1$ 决定）最大点数。

但这道题 $d$ 不等于 $0$ ，我们要定义 $f_{i,j}$ 表示在子树 $i$ 被完全覆盖中，并向上覆盖 $j$ 层的最小代价（向上只是一个方向，$j$ **允许** 为负数，此时表示子树 $i$ 中向下还有 $j$ 层没有被覆盖）。

先讲初始化，$f_{u, 0} = w_u$ 当且仅当 $u$ 需要被覆盖。对 $i \in [1, d]$ ，有 $f_{u, i} = w_u$ 。且 $f_{u, d + 1} = \infty$ 。不用过多解释吧。

我们注意到 $f_{i,-j} (j \geq 0)$ 这个状态可以通过在 $i$ 点放置守卫从而转移到 $f_{i,j}$ 。

于是，对 $u$ 及它的子树 $v$，我们有 ：
$$
\begin{aligned}
f_{u,j} = & \min_{v \in son(u)}\{ f_{u,j} + f_{v, -j}, f_{v, j + 1} + f_{u, -(j+1)}\}  \\
f_{u,-j} =& \sum_{v \in son(u)} f_{v, -(j- 1)}
\end{aligned}
$$
第一个式子表示两种决策，一种是能向上覆盖 $j + 1$ 层的结点 $t$ （为了达到 $f_{u,j}$）不在当前处理的范围内，另一种是 $z$ 恰好就是 $v$ 。这个比较难以理解，需要自己多画图加以理解。

第二个式子比较好理解，每个 $v$ 都不放守卫，就直接累加就可以了。

另外对 $j > 0$ 的情况需要做后缀最小值，对 $j < 0$ 的情况需要做前缀最小值。这很好理解，我们拿 $j>k$ 的情况简单说明一下，假如有 $f_{i,j} < f_{i,k}$ ，这就说明状态 $f_{i,k}$ 覆盖层数少还花费高，在 $f_{i,j}$ 面前就只能淘汰了。

程序具体实现的时候由于 $C++$ 不支持负下标而且为了方便，我们将 $j \leq 0$ 的情况用 $g_{i,j}$ 存储（具体意义在前文已经有所提及）。据此重写的状态转移方程如下：
$$
\begin{aligned}
f_{u,j} =& \min_{v \in son(u)} \{ f_{u,j} + g_{v, j}, f_{v, j + 1} + g_{u, j + 1} \} \\
g_{u,j} = & \sum_{v \in son(v)} g_{v, j - 1}
\end{aligned}
$$


# $Code$

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define N 500005
#define D 21
#define infty 1e9
struct edgeType {
    int to, next;
} edge[N << 1];
int head[N];
inline void addEdge(int from, int to) {
    static int cnt = 0;
    edge[++cnt] = (edgeType){to, head[from]};
    head[from] = cnt;
}
bool cover[N];
int n, d, m;
int w[N], f[N][D], g[N][D];
inline void solve(int u, int p) {
    if (cover[u] == true) f[u][0] = g[u][0] = w[u];
    for (int i= 1; i <= d; i++) f[u][i] = w[u]; f[u][d + 1] = infty;
    for (int i = head[u]; i; i = edge[i].next) {
        int v = edge[i].to;
        if (v == p) continue;
        solve(v, u);
        for (int j = d; j >= 0; j--) {
            f[u][j] = std::min(f[u][j] + g[v][j], g[u][j + 1] + f[v][j + 1]);
            f[u][j] = std::min(f[u][j], f[u][j + 1]);
        }
        g[u][0] = f[u][0];
        for (int j = 1; j <= d + 1; j++) {
            g[u][j] += g[v][j - 1];
            g[u][j] = std::min(g[u][j], g[u][j - 1]);
        }
    }
}
int main() {
    scanf("%d%d", &n, &d);
    for (int i = 1; i <= n; i++) scanf("%d", &w[i]);
    scanf("%d", &m);
    for (int i = 1; i <= m; i++) {
        int x;
        scanf("%d", &x);
        cover[x] = true;
    }
    for (int i = 1; i < n; i++) {
        int u, v;
        scanf("%d%d", &u, &v);
        addEdge(u, v);
        addEdge(v, u);
    }
    solve(1, 0);
    printf("%d\n", f[1][0]);
    return 0;
}


```





---

## 作者：温词 (赞：6)

### 哇在切掉这道有趣的树形dp之后，我一定要说点什么~~大力吐槽~~言归正传，我自己没有很看明白其他题解的写法.....然后我自己脑补了一下整个过程，来分享一下自己的思路
### 首先我们设g[u][i]代表以u为根的子树已经被全部覆盖并且还能向上覆盖i层.......f[u][i]表示以u为根的子树还有i层没有覆盖......这个可以自行画图理解一下。此处划一个重点g[u][i]表示的是目前已经遍历过的子树所需的步数，有可能只更新了前x个子树，第x+1个子树还没有考虑到，但可以向上拓展j层，那么只要考虑覆盖x+1个子树的比j层更深的就好了....当理解了这个之后，这道题的思路也就比较清晰了，在更新到新的子树的时候g和f都要适当的更新一下
```cpp
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f
using namespace std;
inline int read(){
	int w=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		w=(w<<3)+(w<<1)+ch-48;
		ch=getchar();
	}
	return w*f;
} 
int val[500050],g[500050][25],f[500050][25],tot,head[1000010],n,m,d,cnt;//g[u][i]代表以u为根的子树已经被全部覆盖并且还能向上覆盖i层.......f[u][i]表示以u为根的子树还有i层没有覆盖......
bool debug,vis[500050];
struct Edge{
	int from,to,next;
}edge[1000010];
inline void addedge(int u,int v){
	cnt++;
	edge[cnt].from=u;
	edge[cnt].to=v;
	edge[cnt].next=head[u];
	head[u]=cnt;
}
inline void dfs(int u,int fa){//g[u][i]代表以u为根的子树已经被全部覆盖并且还能向上覆盖i层.......f[u][i]表示以u为根的子树还有i层没有覆盖......
    if(vis[u]) g[u][0]=f[u][0]=val[u];//如果这个点需要监视，那么只选择这一层的代价就是val[u]
    int i,j,k;
    for(i=1;i<=d;i++){
    	g[u][i]=val[u];
	}//如果选了u这个点插眼，在d的范围内都可以更新为val[u]
	g[u][d+1]=INF;
	for(i=head[u];i;i=edge[i].next){
		int v=edge[i].to;
		if(v==fa) continue;
		dfs(v,u);//转移方程划重点！！！
		for(j=d;j>=0;j--){
			g[u][j]=min(g[u][j]+f[v][j],g[v][j+1]+f[u][j+1]); 
		}//这棵新的子树还需要f[v][j]的代价来完全覆盖，或者将u，v反过来，选其中更优的进行更新
		for(j=d;j>=0;j--){
			g[u][j]=min(g[u][j],g[u][j+1]);
		}//我可以选择用覆盖更多层还更便宜的更新层数少的
		f[u][0]=g[u][0];//覆盖本身的代价是一样的
		for(j=1;j<=d+1;j++){
			f[u][j]+=f[v][j-1];
		}//将新的子树的大小加入到f中
		for(j=1;j<=d+1;j++){
			f[u][j]=min(f[u][j],f[u][j-1]);
		}//可以选择更少层数还需要覆盖的来更新更多层数需要覆盖的
	}
	return;
}
int main(){
	n=read();
	d=read();
	int i,j,k;
	for(i=1;i<=n;i++){
		val[i]=read();
	}
	m=read();
	int x,y;
	for(i=1;i<=m;i++){
		x=read();
		vis[x]=true;
	}
	for(i=1;i<n;i++){
		x=read();
		y=read();
		addedge(x,y);
		addedge(y,x);
	}
	dfs(1,0);
	int ans=f[1][0];
	cout<<ans<<endl;
	return 0;
}
```
### 在这样合理的思路下，我们就顺利地切掉了这道题(逃

---

## 作者：ccsc (赞：6)

我透！

是只有我想不到合理的状态么？卑微……

看题：

我们设两个极其优秀的状态：

>f[x][y]表示x子树中所有点都已经覆盖完，并且x还能向上覆盖y层的最小代价。

>g[x][y]表示x的y层以下的所有点都已经覆盖完，还需要覆盖上面的y层的最小代价。

反正这个状态极其优秀，（这个状态我不知道怎么想的，正在学……会努力的）

>首先，对于必覆盖点，初始化就是f[i][0]=g[i][0]=val[i]
注意当j≥1时，f覆盖的范围是不包括当前点的（j层未覆盖），但是g包括了（i向外j全覆盖）
所以g[i][j]也要初始化一下
考虑转移
对于f，显然有f[x][j]=min{f[x][j−1]}
还有就是子树统计f[x][j]+=f[y][j−1]
对于g，显然有g[x][i]=min{g[x][i+1]}
还有，就是考虑x的外面由哪个子树覆盖，这个覆盖包括了x子树内部，g[y][j]覆盖了f[x][j]未覆盖的j层
g[x][j]=min{f[x][j+1]+g[y][j+1],f[y][j]+g[x][j]}


显然答案就是f[1][0]    	

^_^

code 嘛（随意找题解都是一个模样，就不放了）

---

## 作者：cirnovsky (赞：4)

###### （重新排版后）

## 题意简述

给你一棵树，放置守卫在某个点上面需要一定代价和一定的有效范围。让你覆盖若干指定点，求最小代价

## 题解

#### 算法标签：
##### $\ \ \ \ \ \ \ \ \ $ 树DP

#### DP状态定义:

$\ \ \ \ \ \ \ \ \ $ 说实话这道题定状态不好定。

$\ \ \ \ \ \ \ \ \ $ 那么我们从头来看，当 $d =0$ 的时候，我们就是在求树的最大独立集，定义显而易见。

$\ \ \ \ \ \ \ \ \ $ $d\neq 0$ 我们可以照搬原来的定义，把它扩展一下。

--------------

$\ \ \ \ \ \ \ \ \ $ $f_{i,j}$ 表示以 $i$ 为根结点的子树已经完全被覆盖让然后还能向上覆盖 $j$ 层的最小代价

$\ \ \ \ \ \ \ \ \ $ $g_{i,j}=$ 表示以 $i$ 为根结点的子树还有 $j$ 层没有覆盖的最小代价

--------------

$\ \ \ \ \ \ \ \ \ $ 需要注意的是 $j$ 本质上是带有方向性的，可以类比向量的概念。

$\ \ \ \ \ \ \ \ \ $ 边界条件很显然，$f_{i,0}=val_{i}$ 此时当前结点需要被覆盖。

$\ \ \ \ \ \ \ \ \ $ 其他情况(这里不是我不打LaTeX是题解的渲染出了问题)：

$\ \ \ \ \ \ \ \ \ $ $\ \ \ \ \ \ \ \ \ $ f[i][j]=val[i],j ∈ [1,d]

$\ \ \ \ \ \ \ \ \ $ $\ \ \ \ \ \ \ \ \ $ f[i][j]=∞,j=d+1


$\ \ \ \ \ \ \ \ \ $ 状态转移方程倒是比较好想，这里就不再赘述。

```cpp
#include <cstdio>
#include <algorithm>
#include <queue>

char buf[1 << 21], *p1 = buf, *p2 = buf;
#ifndef ONLINE_JUDGE
#define gc() getchar()
#else
#define gc() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++)
#endif
#define is_number (ch >= '0' && ch <= '9')

template < typename Type >
void read(Type& a) {
	a = 0; bool f = 0; char ch;
	while (!(ch = gc(), is_number)) if (ch == '-') f = 1;
	while (is_number) a = (a << 3) + (a << 1) + (ch ^ '0'), ch = gc();
	a = (f ? -a : a);
}

template < typename Type, typename... Args >
void read(Type& t, Args&... args) {
	read(t), read(args...);
}

int val[500005], f[500005][25];
int g[500005][25], vis[500005];
int n, m, d, tot, head[500005];
int nxt[1000005], to[1000005];
std::vector < std::vector < int > > G(500005);

void add(int x, int y) {
	to[++tot] = y;
	nxt[tot] = head[x];
	head[x] = tot;
	G[x].push_back(y);
	G[y].push_back(x);
}

void DP(int x, int fa) {
	if (vis[x]) g[x][0] = f[x][0] = val[x];
	for (int i = 1; i <= d; ++i) f[x][i] = val[x];
	f[x][d + 1] = 0x3f3f3f3f;
	for (int i = head[x]; i; i = nxt[i]) {
		int y = to[i];
		if (y ^ fa) {
			DP(y, x);
			for (int j = d; j >= 0; --j)
				f[x][j] = std::min(f[y][j + 1] + g[x][j + 1], f[x][j] + g[y][j]);
			for (int j = d; j >= 0; --j)
				f[x][j] = std::min(f[x][j + 1], f[x][j]);
			g[x][0] = f[x][0];
			for (int j = 1; j <= d + 1; ++j)
				g[x][j] += g[y][j - 1];
			for (int j = 1; j <= d + 1; ++j)
				g[x][j] = std::min(g[x][j - 1], g[x][j]);
		}
	}
}

signed main() {
	read(n, d);
	for (int i = 1; i <= n; ++i) read(val[i]);
	read(m);
	for (int i = 0, x; i < m; ++i) read(x), vis[x] = 1;
	for (int i = 1, x, y; i < n; ++i) read(x, y), add(x, y), add(y, x);
	DP(1, 0);
	printf("%d\n", g[1][0]);
}
```

---

## 作者：Jμdge (赞：4)

树形动规 好题...

首先我们看到这题的数据范围，估计就是 $O (n)$ 级别的

再看到 D 比较小，那么可能复杂度还要乘个 D ，反正是不能带 $log~ n$ 的，那么树形 dp 基本就是跑不掉了

于是我们考虑怎么去 $O(n)$ 或者 $O(nD)$ 去完成一个树形 dp

----

我们设置状态肯定是 $f[i][j]$ 的两维度数组，以及一个 $g[i][j]$ 的两维数组

然后我们考虑令


>$f[i][j]$ 表示 i 号点，下面离它最远的点距离为 $j$ 时的最小代价

>$g[i][j]$ 表示 i 号点，下面离它最近的标记点距离为 $D-j+1$ （即 i 号点可以让上面离他距离为 j 的点被覆盖）时的最小代价

当然你让 $g[i][j]$ 中 $j$ 表示 距离为 $j$ 也可以，但这样转移会变得更加麻烦...


----


那么我们就可以进行转移了

我们首先让所有的 $g[u][i]$ （除了 g[u][0]）为 $a[u]$ ，表示选择了该点，至于为什么不是只让 $g[u][D-1]=$，我们考虑距离为 i 的点能覆盖，那么 i-1 也能覆盖，以此类推


然后我们考虑某个点本身被标记的情况

其实我们只需要多让 $f[u][0]=g[u][0]=a[u]$ 就行了，分别表示自当前点以下的点全部被覆盖需要最小代价就是 $a[u]$ 以及不向上覆盖的最小代价为 $a[u]$


然后转移就是每个点对于子节点进行贡献的累加了...


>$g[u][i]=Min(g[u][i]+f[v][i] ,f[u][i+1]+g[v][i+1])$ 

表示当前点要么就是加上子节点未覆盖点最远距离不大于 i 的点，要么就是让下面的标记点来覆盖当前点

>$cmin(g[u][i],g[u][i+1])$

代码里有讲

>$f[u][0]=g[u][0]$ 

原因是他们两个东西等价...

>$f[u][i]+=f[v][i-1]$

是说下面的未覆盖点传递到上面

>$cmin(f[u][i],f[u][i-1])$ 

代码里有讲




# code

代码里面的注释可能具体些

```cpp
//by Judge
#include<bits/stdc++.h>
#define Rg register
#define fp(i,a,b) for(Rg int i=(a),I=(b)+1;i<I;++i)
#define fd(i,a,b) for(Rg int i=(a),I=(b)-1;i>I;--i)
#define go(u) for(Rg int i=head[u],v=e[i].to;i;v=e[i=e[i].nxt].to)
using namespace std;
const int M=5e5+3;
typedef int arr[M];
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline void cmin(int& x,int y){if(x>y)x=y;}
inline int Min(int x,int y){return x<y?x:y;}
inline int read(){ int x=0,f=1; char c=getchar();
    for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
    for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} int n,m,d,pat,f[M][23],g[M][23]; // f[i][j] 下面最远的未覆盖点距离为 j 的最小代价 
// g[i][j] 选择的最近点距离为 j 的最小代价 
arr a,head,flg;
struct Edge{ int to,nxt; }e[M<<1];
inline void add(int u,int v){
	e[++pat]=(Edge){v,head[u]},head[u]=pat;
	e[++pat]=(Edge){u,head[v]},head[v]=pat;
}
void dfs(int u,int fa){
	if(flg[u]) f[u][0]=g[u][0]=a[u];
	fp(i,1,d) g[u][i]=a[u];
	g[u][d+1]=1e9; //边界 
	go(u) if(v^fa) dfs(v,u);
	
	go(u) if(v^fa){
		fp(i,0,d) g[u][i]=Min(g[u][i]+f[v][i],f[u][i+1]+g[v][i+1]);
		fd(i,d,0) cmin(g[u][i],g[u][i+1]);  //能覆盖更深的点的，少一些深度的也能覆盖 
		f[u][0]=g[u][0];
		fp(i,1,d) f[u][i]+=f[v][i-1];  // f[v] 已取 min  
		fp(i,1,d) cmin(f[u][i],f[u][i-1]);  //浅的点没被覆盖，可以看做更深的点未被覆盖 
	}
}
int main(){
	n=read(),d=read();
	fp(i,1,n) a[i]=read();
	m=read(); Rg int x,y;
	fp(i,1,m) flg[read()]=1;
	fp(i,2,n) x=read(),y=read(),add(x,y);
	return dfs(1,0),!printf("%d\n",g[1][0]);
}
```

---


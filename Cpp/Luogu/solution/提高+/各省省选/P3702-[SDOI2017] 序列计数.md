# [SDOI2017] 序列计数

## 题目描述

Alice 想要得到一个长度为 $n$ 的序列，序列中的数都是不超过 $m$ 的正整数，而且这 $n$ 个数的和是 $p$ 的倍数。

Alice 还希望，这 $n$ 个数中，至少有一个数是质数。

Alice 想知道，有多少个序列满足她的要求。

## 说明/提示

对 $20\%$ 的数据，$1\leq n,m\leq100$。


对 $50\%$ 的数据，$1\leq m \leq 100$。


对 $80\%$ 的数据，$1\leq m\leq 10^6$。


对 $100\%$ 的数据，$1\leq n \leq 10^9,1\leq m \leq 2\times 10^7,1\leq p\leq 100$。

## 样例 #1

### 输入

```
3 5 3```

### 输出

```
33```

# 题解

## 作者：sky_of_war (赞：26)

我觉得这篇题解下很多矩阵解法没有写清楚矩阵怎么构造...所以我来详细地写一下

同步更新于我的博客：[「LUOGU P3702」[SDOI2017]序列计数](https://www.skyofwar.net/2019/04/19/128.html)

首先这个形式显然非常不好计算，容斥一波：$\text{ans}=\text{满足和为}p\text{的倍数的方案数}-\text{满足和为}p\text{的倍数且不含质数的方案数}$

我们很容易得到$20\rm pts$的优秀做法：令$f_{i,j}$表示$i$个数$\mod p$等于$j$的方案数，则转移为$f_{i,j} = \sum_{k} f_{i-1,k} \times \text{cnt}_{(j - k + p)\bmod \; p}$，其中$\text{cnt}_i$表示$1\sim m$中$\bmod P$为$i$的个数。令$g_{i,j}$表示$i$个**合数**$\mod p$等于$j$的方案数，则转移为$g_{i,j} = \sum_{k} g_{i-1,k} \times \text{compo}_{(j - k + p)\bmod \; p}$，其中$\text{compo}_i$表示$1\sim m$中的**合数**$\bmod P$为$i$的个数。
考虑用矩阵乘法优化。对于$f$，矩阵如下所示：
$$\mathbf P = \begin{bmatrix} \text{cnt}_0 & \text{cnt}_{p-1} & \text{cnt}_{p-2} & \text{cnt}_{p-3} & \text{cnt}_{p-4} & ... & \text{cnt}_1 \\ \text{cnt}_1 & \text{cnt}_0 & \text{cnt}_{p-1} & \text{cnt}_{p-2} & \text{cnt}_{p-3} & ... & \text{cnt}_2 \\ \text{cnt}_2 & \text{cnt}_1 & \text{cnt}_0 & \text{cnt}_{p-1} & \text{cnt}_{p-2} & ... & \text{cnt}_3 \\ \text{cnt}_3 & \text{cnt}_2 & \text{cnt}_1 & \text{cnt}_0 & \text{cnt}_{p-1} & ... & \text{cnt}_4 \\ ... & ... & ... & ... & ... & ... & ...\\ \text{cnt}_{p-1} & \text{cnt}_{p-2} & \text{cnt}_{p-3} & \text{cnt}_{p-4} & \text{cnt}_{p-5} & ... & \text{cnt}_0 \end{bmatrix}$$
向量长这样：
$$\mathbf V = \begin{bmatrix} \text{cnt}_0 \\ \text{cnt}_1 \\ \text{cnt}_2 \\ ... \\ \text{cnt}_{p-1} \end{bmatrix}$$
最后答案矩阵为$\mathbf F = \mathbf P ^ {n-1}\times \mathbf V$。
对于$g$，矩阵如下所示：
$$\mathbf Q = \begin{bmatrix} \text{compo}_0 & \text{compo}_{p-1} & \text{compo}_{p-2} & \text{compo}_{p-3} & \text{compo}_{p-4} & ... & \text{compo}_1 \\ \text{compo}_1 & \text{compo}_0 & \text{compo}_{p-1} & \text{compo}_{p-2} & \text{compo}_{p-3} & ... & \text{compo}_2 \\ \text{compo}_2 & \text{compo}_1 & \text{compo}_0 & \text{compo}_{p-1} & \text{compo}_{p-2} & ... & \text{compo}_3 \\ \text{compo}_3 & \text{compo}_2 & \text{compo}_1 & \text{compo}_0 & \text{compo}_{p-1} & ... & \text{compo}_4 \\ ... & ... & ... & ... & ... & ... & ...\\ \text{compo}_{p-1} & \text{compo}_{p-2} & \text{compo}_{p-3} & \text{compo}_{p-4} & \text{compo}_{p-5} & ... & \text{compo}_0 \end{bmatrix}$$
向量长这样：
$$\mathbf W = \begin{bmatrix} \text{compo}_0 \\ \text{compo}_1 \\ \text{compo}_2 \\ ... \\ \text{compo}_{p-1} \end{bmatrix}$$
最后答案矩阵为$\mathbf G = \mathbf Q ^ {n-1}\times \mathbf W$。
最终答案为$\mathbf F_{1,1} - \mathbf G_{1,1}$
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1e2 + 10, mo = 20170408, MAXM = 2e7 + 10;
struct mat
{
	int m, n, ma[MAXN][MAXN];
	mat() {}
	mat(int _m, int _n) :
		m(_m), n(_n)
	{
		memset(ma, 0, sizeof(ma));
	}
	friend inline mat operator * (mat a, mat b)
	{
		mat res = mat(a.m, b.n);
		for(int i = 1; i <= res.m; i++)
			for(int j = 1; j <= res.n; j++)
				for(int k = 1; k <= a.n; k++)
					res.ma[i][j] = (res.ma[i][j] + 1ll * a.ma[i][k]
									* b.ma[k][j] % mo) % mo;
		return res;
	}
	friend inline mat operator ^ (mat a, int b)
	{
		mat c = a, res = mat(a.m, a.n);
		for(int i = 1; i <= res.m; i++)
			res.ma[i][i] = 1;
		while(b)
		{
			if(b & 1) res = res * c;
			c = c * c;
			b >>= 1;
		}
		return res;
	}
} P, Q, V, W;
int n, m, p, cnt[MAXN], compo[MAXN];
bool prime[MAXM];
int pr[MAXM];
template <class T>
inline void _read(T &x)
{
	x = 0;
	char t = getchar();
	while(!isdigit(t) && t != '-') t = getchar();
	if(t == '-')
	{
		_read(x);
		x *= -1;
		return ;
	}
	while(isdigit(t))
	{
		x = x * 10 + t - '0';
		t = getchar();
	}
}
int ptot = 0;
int main()
{
	_read(n), _read(m), _read(p);
	for(int i = 0; i < p; i++) cnt[i] = m / p;
	for(int i = 1; i <= m % p; i++) cnt[i]++;
	P = mat(p, p);
	P.ma[1][1] = cnt[0];
	for(int i = 2; i <= p; i++) P.ma[1][i] = cnt[p - i + 1];
	for(int i = 2; i <= p; i++)
	{
		for(int j = 2; j <= p; j++)
			P.ma[i][j] = P.ma[i - 1][j - 1];
		P.ma[i][1] = P.ma[i - 1][p];
	}
	memset(prime, 1, sizeof prime);
	prime[1] = false;
	for(int i = 2; i <= m; i++)
	{
		if(prime[i] == true)
			pr[++ptot] = i;
		for(int j = 1; i * pr[j] <= m && j <= ptot; ++j)
		{
			prime[i * pr[j]] = false;
			if(i % pr[j] == 0)
				break;
		}
	}
	for(int i = 1; i <= m; i++)
		if(!prime[i]) compo[i % p]++;
	Q = mat(p, p);
	Q.ma[1][1] = compo[0];
	for(int i = 2; i <= p; i++) Q.ma[1][i] = compo[p - i + 1];
	for(int i = 2; i <= p; i++)
	{
		for(int j = 2; j <= p; j++)
			Q.ma[i][j] = Q.ma[i - 1][j - 1];
		Q.ma[i][1] = Q.ma[i - 1][p];
	}
	for(int i = 1; i <= p; i++)
		for(int j = 1; j <= p; j++)
			P.ma[i][j] %= mo, Q.ma[i][j] %= mo;
	V = mat(p, 1);
	W = mat(p, 1);
	for(int i = 1; i <= p; i++) V.ma[i][1] = cnt[i - 1] % mo;
	for(int i = 1; i <= p; i++) W.ma[i][1] = compo[i - 1] % mo;
	P = (P ^ n - 1) * V;
	Q = (Q ^ n - 1) * W;
	printf("%d\n", (P.ma[1][1] - Q.ma[1][1] + mo) % mo);
	return 0;
}
```

---

## 作者：LJC00118 (赞：18)

[原文](https://www.cnblogs.com/LJC00118/p/9904982.html)食用效果更佳qwq

https://www.luogu.org/problemnew/show/P3702

题目让我们在 $ [1, m] $ 从中选出 $ n $ 个数，当中要有 > $ 0 $ 个质数，和是 $ p $ 的倍数，直接求是很难求的，我们可以用所有方案减去不含素数的方案，这样求出来的东西就是答案

现在我们考虑如何计算出和是 $ p $ 的倍数的方案

我们令 $ f (x) $ 表示当前选出的数的和模 $ p $ 是 $ x $ 的方案数，把两个这样的多项式进行卷积

设两个多项式分别为 $ f1 $ 和 $ f2 $

$ Ans[i + j - 1] $ 这一项的值包含 $ f1[i] * f2[j] $ 的值，而其他项不包含

我们把下标 $ -1 $ 后

$ Ans[i + j - 2] $ 这一项的值包含 $ f1[i - 1] * f2[j - 1] $ 的值，而其他项不包含

再回到多项式的定义，我们发现，$ Ans[i + j - 2] += f1[i - 1] * f2[j - 1] $ 的意义就是选出的和模 $ p $ 是 $ i - 1 $ 的情况和选出的和模 $ p $ 是 $ j - 1 $ 合在一起，即选出来的数的和模 $ p $ 是 $ i + j - 2 $ 的方案数

所以我们可以先构造出初始的多项式 $ f $，求出 $ f^n(p) $  的值，即为方案数

然后答案就是所有方案减去不含素数的方案

卷积可以写一个三模 NTT，当然这题数据范围小，直接暴力卷积也可以（跑的比 NTT 还快），但是 FFT 会爆精度（至少我爆了精度），建议暴力卷积

我的代码中有三种卷积方法的实现，可以作为参考

1. NTT

```cpp
#include <bits/stdc++.h>
#define double long double
#define CIOS ios::sync_with_stdio(false);
#define For(i, a, b) for(register int i = a; i <= b; i++)
#define Rof(i, a, b) for(register int i = a; i >= b; i--)
#define DEBUG(x) cerr << "DEBUG" << x << " >>> ";
using namespace std;

typedef unsigned long long ull;
typedef long long ll;

template <typename T>
inline void read(T &f) {
    f = 0; T fu = 1; char c = getchar();
    while(c < '0' || c > '9') {if(c == '-') fu = -1; c = getchar();}
    while(c >= '0' && c <= '9') {f = (f << 3) + (f << 1) + (c & 15); c = getchar();}
    f *= fu;
}

template <typename T>
void print(T x) {
    if(x < 0) putchar('-'), x = -x;
    if(x < 10) putchar(x + 48);
    else print(x / 10), putchar(x % 10 + 48);
}

template <typename T>
void print(T x, char t) {
    print(x); putchar(t);
}

const int N = 405, mod = 20170408;
inline int mul(int x, int y) { return (int)(1ll * x * y % (ll)mod); }

int r[N], n, m, p, len = 1, tot = 0;
ll A[N], B[N], C[N], ans[N], a[N], b[N], c[N], d[N];

const int P[3] = {469762049, 998244353, 167772161}, G = 3, Gi[3] = {P[0] / G + 1, P[1] / G + 1, P[2] / G + 1};

ll fpow(ll x, ll y, ll p) {
    ll ans = 1;
    while(y) {
        if(y & 1) ans = ans * x % p;
        y >>= 1; x = x * x % p;
    }
    return ans;
}

void NTT(ll *a, int tp, int t) {
    for(register int i = 1; i < len; i++) if(i < r[i]) swap(a[i], a[r[i]]);
    for(register int mid = 1; mid < len; mid <<= 1) {
        ll wn = fpow(tp == 1 ? G : Gi[t], (P[t] - 1) / (mid << 1), P[t]);
        for(register int i = 0; i < len; i += (mid << 1)) {
            ll w = 1;
            for(register int j = 0; j < mid; j++, w = w * wn % P[t]) {
                ll x = a[i + j], y = a[i + j + mid] * w % P[t];
                a[i + j] = (x + y) % P[t]; a[i + j + mid] = (x - y + P[t]) % P[t];
            }
        }
    }
    if(tp == -1) {
        ll inv = fpow(len, P[t] - 2, P[t]);
        for(register int i = 0; i < len; i++) a[i] = a[i] * inv % P[t];
    }
}

ll inv(ll x, ll y) { return fpow(x, y - 2, y); }

ll times(ll x, ll y, ll p) {
    ll ans = 0;
    while(y) {
        if(y & 1) ans = (ans + x) % p;
        y >>= 1; x = (x + x) % p;
    }
    return ans;
}

void mul(ll *A, ll *B, ll *ans) {
    for(register int i = 1; i <= p; i++) A[i - 1] = A[i], B[i - 1] = B[i]; A[p] = B[p] = 0;
    len = 1; tot = 0;
    while(len <= (p << 1)) len <<= 1, tot++;
    for(register int i = 1; i < len; i++) r[i] = (r[i >> 1] >> 1) | ((i & 1) << (tot - 1));
    memcpy(a, A, sizeof(a)); memcpy(b, A, sizeof(b)); memcpy(c, A, sizeof(c));
    memcpy(d, B, sizeof(d)); NTT(a, 1, 0); NTT(d, 1, 0); for(register int i = 0; i < len; i++) a[i] = a[i] * d[i] % P[0]; NTT(a, -1, 0);
    memcpy(d, B, sizeof(d)); NTT(b, 1, 1); NTT(d, 1, 1); for(register int i = 0; i < len; i++) b[i] = b[i] * d[i] % P[1]; NTT(b, -1, 1);
    memcpy(d, B, sizeof(d)); NTT(c, 1, 2); NTT(d, 1, 2); for(register int i = 0; i < len; i++) c[i] = c[i] * d[i] % P[2]; NTT(c, -1, 2);
    for(register int i = 0; i <= (p << 1); i++) {
        ll p = 1ll * P[0] * P[1];
        ll s = times(a[i], times(P[1], inv(P[1], P[0]), p), p) + times(b[i], times(P[0], inv(P[0], P[1]), p), p); s %= p;
        ll k = (c[i] % P[2] - s % P[2] + P[2]) % P[2] * inv(p % P[2], P[2]) % P[2];
        ll Ans = (s + (k * P[0] % mod * P[1] % mod)) % mod;
        ans[i + 1] = Ans;
    }
    for(register int i = 1; i <= p; i++) ans[i] = (ans[i] + ans[i + p]) % mod, ans[i + p] = 0;
    for(register int i = p; i >= 1; i--) A[i] = A[i - 1], B[i] = B[i - 1]; A[0] = B[0] = 0;
}

int fpow(int x, int y) {
    int ans = 1;
    while(y) {
        if(y & 1) ans = mul(ans, x);
        y >>= 1; x = mul(x, x);
    }
    return ans;
}

int pri[5000000], plen;
bool isp[20000005];

void init_pri(int n, ll *a) {
    isp[1] = 1;
    for(register int i = 2; i <= n; i++) {
        if(!isp[i]) { pri[++plen] = i; }
        for(register int j = 1; j <= plen && i * pri[j] <= n; j++) {
            isp[i * pri[j]] = 1;
            if(i % pri[j] == 0) break;
        }
    }
    for(register int i = 1; i <= p; i++) a[i] = 0;
    for(register int i = 1; i <= n; i++) if(isp[i]) ++a[i % p + 1];
}

int main() {
    read(n); read(m); read(p); init_pri(m, A); int t = n;
    ans[1] = 1;
    while(n) {
        if(n & 1) {
            memcpy(B, ans, sizeof(B));
            mul(A, B, ans);
        }
        n >>= 1;
        memcpy(B, A, sizeof(B));
        memcpy(C, A, sizeof(C));
        mul(B, C, A);
    }
    int fir = ans[1];
    memset(ans, 0, sizeof(ans));
    memset(A, 0, sizeof(A));
    for(register int i = 1; i <= m; i++) ++A[i % p + 1];
    ans[1] = 1; n = t;
    while(n) {
        if(n & 1) {
            memcpy(B, ans, sizeof(B));
            mul(A, B, ans);
        }
        n >>= 1;
        memcpy(B, A, sizeof(B));
        memcpy(C, A, sizeof(C));
        mul(B, C, A);
    }
    cout << (ans[1] - fir + mod) % mod << endl;
    return 0;
}
```

2.FFT & 暴力卷积（当然 FFT 是错误的）

```cpp
#include <bits/stdc++.h>
#define CIOS ios::sync_with_stdio(false);
#define For(i, a, b) for(register int i = a; i <= b; i++)
#define Rof(i, a, b) for(register int i = a; i >= b; i--)
#define DEBUG(x) cerr << "DEBUG" << x << " >>> ";
using namespace std;

typedef unsigned long long ull;
typedef long long ll;

template <typename T>
inline void read(T &f) {
    f = 0; T fu = 1; char c = getchar();
    while(c < '0' || c > '9') {if(c == '-') fu = -1; c = getchar();}
    while(c >= '0' && c <= '9') {f = (f << 3) + (f << 1) + (c & 15); c = getchar();}
    f *= fu;
}

template <typename T>
void print(T x) {
    if(x < 0) putchar('-'), x = -x;
    if(x < 10) putchar(x + 48);
    else print(x / 10), putchar(x % 10 + 48);
}

template <typename T>
void print(T x, char t) {
    print(x); putchar(t);
}

const int N = 405, P = 20170408;
inline int mul(int x, int y) { return (int)(1ll * x * y % (ll)P); }

/*const double PI = acos(-1.0);

struct cp {
    double x, y;
    cp (double xx = 0, double yy = 0) {
        x = xx; y = yy;
    }
}a[N], b[N];

cp operator + (const cp a, const cp b) { return cp(a.x + b.x, a.y + b.y); }
cp operator - (const cp a, const cp b) { return cp(a.x - b.x, a.y - b.y); }
cp operator * (const cp a, const cp b) { return cp(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); }*/

int r[N], n, m, p, len = 1, tot = 0;
int A[N], B[N], C[N], ans[N];

/*void FFT(cp *a, int d) {
    for(register int i = 1; i < len; i++) if(i < r[i]) swap(a[i], a[r[i]]);
    for(register int mid = 1; mid < len; mid <<= 1) {
        cp wn = cp(cos(PI / mid), sin(PI / mid) * d);
        for(register int i = 0; i < len; i += (mid << 1)) {
            cp w = cp(1.0, 0.0);
            for(register int j = 0; j < mid; j++, w = w * wn) {
                cp x = a[i + j], y = a[i + j + mid] * w;
                a[i + j] = x + y; a[i + j + mid] = x - y;
            }
        }
    }
}*/

/*void mul(int *A, int *B, int *ans) {
    len = 1, tot = 0;
    while(len <= (p << 1)) len <<= 1, tot++;
    for(register int i = 1; i <= len; i++) r[i] = (r[i >> 1] >> 1) | ((i & 1) << (tot - 1));
    for(register int i = 1; i <= len; i++) a[i - 1] = cp(A[i], 0), b[i - 1] = cp(B[i], 0);
    FFT(a, 1); FFT(b, 1);
    for(register int i = 0; i < len; i++) a[i] = a[i] * b[i];
    FFT(a, -1);
    for(register int i = 1; i <= len; i++) ans[i] = (int)((ll)(a[i - 1].x / (double)len + 0.5) % (ll)P);
    for(register int i = 1; i <= p; i++) ans[i] = (ans[i] + ans[i + p]) % P, ans[i + p] = 0;
}*/

/*void mul(int *A, int *B, int *ans) {
    for(register int i = 1; i <= p << 1; i++) A[i - 1] = A[i], B[i - 1] = B[i], ans[i] = 0; ans[0] = 0;
    for(register int i = 0; i < p; i++) {
        for(register int j = 0; j < p; j++) {
            ans[i + j] += mul(A[i], B[j]);
            if(ans[i + j] >= P) ans[i + j] -= P;
        }
    }
    for(register int i = p << 1; i >= 1; i--) ans[i] = ans[i - 1], A[i] = A[i - 1], B[i] = B[i - 1]; A[0] = B[0] = 0;
    for(register int i = 1; i <= p; i++) ans[i] = (ans[i] + ans[i + p]) % P, ans[i + p] = 0;
}*/

void mul(int *A, int *B, int *ans) {
    memset(ans, 0, (N + 1) * 4);
    for(register int i = 1; i <= p; i++) {
        for(register int j = 1; j <= p; j++) {
            ans[i + j - 1] += mul(A[i], B[j]);
            ans[i + j - 1] %= P;
        }
    }
    for(register int i = 1; i <= p; i++) ans[i] = (ans[i] + ans[i + p]) % P, ans[i + p] = 0;
}

int fpow(int x, int y) {
    int ans = 1;
    while(y) {
        if(y & 1) ans = mul(ans, x);
        y >>= 1; x = mul(x, x);
    }
    return ans;
}

int pri[5000000], plen;
bool isp[20000005];

void init_pri(int n, int *a) {
    isp[1] = 1;
    for(register int i = 2; i <= n; i++) {
        if(!isp[i]) { pri[++plen] = i; }
        for(register int j = 1; j <= plen && i * pri[j] <= n; j++) {
            isp[i * pri[j]] = 1;
            if(i % pri[j] == 0) break;
        }
    }
    for(register int i = 1; i <= p; i++) a[i] = 0;
    for(register int i = 1; i <= n; i++) if(isp[i]) ++a[i % p + 1];
}

int main() {
    read(n); read(m); read(p); init_pri(m, A); int t = n;
    ans[1] = 1;
    while(n) {
        if(n & 1) {
            memcpy(B, ans, sizeof(B));
            mul(A, B, ans);
        }
        n >>= 1;
        memcpy(B, A, sizeof(B));
        memcpy(C, A, sizeof(C));
        mul(B, C, A);
    }
    int fir = ans[1];
    memset(ans, 0, sizeof(ans));
    memset(A, 0, sizeof(A));
    for(register int i = 1; i <= m; i++) ++A[i % p + 1];
    ans[1] = 1; n = t;
    while(n) {
        if(n & 1) {
            memcpy(B, ans, sizeof(B));
            mul(A, B, ans);
        }
        n >>= 1;
        memcpy(B, A, sizeof(B));
        memcpy(C, A, sizeof(C));
        mul(B, C, A);
    }
    cout << (ans[1] - fir + P) % P << endl;
    return 0;
}
```

---

## 作者：cmd2001 (赞：14)

生成函数 快速幂

首先这题显然补集转化，就是用全部方案减去不含任何质数的方案。

然后怎么做呢?

考虑m比较小，我们能大力把<=m的质数全都筛出来。

发现n很大，要么倍增要么快速幂......

发现p相当小，所以我们能在mod p的同余系下做啊。


一看到同余系下求方案数立刻想到卷积和生成函数......

假设我们有一个多项式f(x)，其中x^i的系数为a个数的序列mod p为i的方案数(a为我们引入的变量)。

同时我们有另一个多项式g(x),其中x^i的系数为b个数的序列mod p为i的方案数(b为我们引入的变量)。

那么，我们如果让f(x)和g(x)做卷积的话，新的多项式x^i的系数就是(a+b)个数的序列mod p为i的方案数的说。

这就是生成函数了。

回到这个题，我们先初始化多项式f(x)，令x^i的系数为为1个数mod p为i的方案数。

然后我们求出这个多项式的n次方，就是我们需要的答案了。

发现这道题的p很小，我们连FFT都不用，直接用一个多项式类暴力快速幂就行了。复杂度O(m+p^2logn)，跑的飞起。

话说为什么p才100啊，如果修改一下模数然后NTT的话，可以做到p为1e5级别，n为1e18级别的。

代码:

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define debug cout
typedef long long int lli;
using namespace std;
const int maxn=1e2+1e1,maxl=2e7+1e2,lim=2e7;
const int mod=20170408;

bool vis[maxl];
int p,m;

struct Poly {
    lli dat[maxn];
    Poly() {
        memset(dat,0,sizeof(dat));
    }
    lli& operator [] (const int &x) {
        return dat[x];
    }
    const lli& operator [] (const int &x) const {
        return dat[x];
    }
    friend Poly operator * (const Poly &a,const Poly &b) {
        Poly ret;
        for(int i=0;i<p;i++) for(int j=0;j<p;j++) {
            ( ret[(i+j)%p] += a[i] * b[j] % mod ) %= mod;
        }
        return ret;
    }
}full,oly;

inline void sieve() {
    static int prime[maxl],cnt;
    vis[1] = 1;
    for(int i=2;i<=m;i++) {
        if( !vis[i] ) prime[++cnt] = i;
        for(int j=1;j<=cnt&&(lli)i*prime[j]<=m;j++) {
            vis[i*prime[j]] = 1;
            if( ! ( i % prime[j] ) ) break;
        }
    }
}

inline void init() {
    for(int i=1;i<=m;i++) {
        full[i%p]++;
        if( vis[i] ) oly[i%p]++;
    }
}

inline Poly fastpow(Poly base,int tim) {
    Poly ret = base; --tim;
    while( tim ) {
        if( tim & 1 ) ret = ret * base;
        if( tim >>= 1 ) base = base * base;
    }
    return ret;
}

int main() {
    static int n;
    static lli ans;
    scanf("%d%d%d",&n,&m,&p) , sieve();
    init();
    full = fastpow(full,n) , oly = fastpow(oly,n);
    ans = ( full[0] - oly[0] + mod ) % mod;
    printf("%lld\n",ans);
    return 0;
}

```





---

## 作者：kal0rona (赞：11)

为啥你们都写得那么复杂？其实发现容斥+DP就可以比较轻松的做出来了。我们发现先算和为$p$的倍数的任意方案数，然后再减去只用质数的方案数就是答案。

### 第一部分

第一部分的式子并不难，设置$dp[i][j]$为前$i$个数的和在模意义下为$j$的方案数，那么转移如下：
$$
dp[i][j] = \sum_{k = 0}^{p - 1} dp[i - 1][(j - k) \bmod p] \times c_k
$$
其中$c_k$就是在$m$的值域内选模意义下为$k$的方案数。根据题意，$c_k$也比较显然：
$$
c_k = \begin{cases} \lfloor \frac{m}{p} \rfloor, k = 0 \\ \lfloor \frac{m - k}{p} \rfloor + 1, k < m \\ 1, k = m \\ 0, k > m \end{cases}
$$
因为序列长度很长，那么我们可以考虑构建矩阵来优化之：
$$ \begin{aligned} dp'[0][j] &= \sum_{k = 0}^{p - 1} dp[0][j - k \bmod p] \times c_k \\ &= \sum_{k = 0}^{p - 1} dp[0][k] \times c_{(j - k \bmod p)} \end{aligned}
$$
再参考矩阵乘法的意义：
$$
A[i][j] = \sum_{k = 0}^{p - 1} B[i][k] \times C[k][j]
$$
那么我们的矩阵其实就很好构造：
$$
trans[k][j] = c_{(j - k \bmod p)}
$$

### 第二部分

第二部分差不多，我们需要线性筛把$m$内的质数筛出来，然后在桶里计数：$bucket[i \bmod p]++$。之后在$trans$矩阵内减去这些质数的方案数，做一遍即可。

### 代码

```cpp
// P3702.cpp
#include <bits/stdc++.h>

using namespace std;

const int MAX_N = 110, MAX_M = 2e7 + 200, mod = 20170408;

int primes[MAX_M], tot, n, m, p, table[MAX_N];
bool vis[MAX_M];

struct matrix
{
    int mat[MAX_N][MAX_N];

    matrix() { memset(mat, 0, sizeof(mat)); }

    int *operator[](const int &rhs) { return mat[rhs]; }

    matrix operator*(const matrix &rhs)
    {
        matrix ret;
        for (int i = 0; i < p; i++)
            for (int j = 0; j < p; j++)
                for (int k = 0; k < p; k++)
                    ret[i][j] = (1LL * ret[i][j] + 1LL * mat[i][k] * rhs.mat[k][j] % mod) % mod;
        return ret;
    }

    matrix operator^(const int &rhs)
    {
        int tim = rhs;
        matrix ret, bas = *this;
        for (int i = 0; i < p; i++)
            ret[i][i] = 1;
        while (tim)
        {
            if (tim & 1)
                ret = ret * bas;
            bas = bas * bas;
            tim >>= 1;
        }
        return ret;
    }
} dp, trans;

void sieve()
{
    for (int i = 2; i <= m; i++)
    {
        if (!vis[i])
            primes[++tot] = i;
        for (int j = 1; j <= tot && 1LL * i * primes[j] <= m; j++)
        {
            vis[i * primes[j]] = true;
            if (i % primes[j] == 0)
                break;
        }
    }
    for (int i = 1; i <= tot; i++)
        table[primes[i] % p]++;
}

int main()
{
    scanf("%d%d%d", &n, &m, &p);
    sieve();
    for (int c = 0; c < p; c++)
        for (int b = 0; b < p; b++)
        {
            int delta = (c - b + p) % p;
            if (delta == 0)
                trans[b][c] = m / p;
            else if (delta < m)
                trans[b][c] = int((m - delta) / p) + 1;
            else if (delta == m)
                trans[b][c] = 1;
            else
                trans[b][c] = 0;
            trans[b][c] %= mod;
        }
    dp[0][0] = 1, dp = dp * (trans ^ n);
    int ans = dp[0][0];
    memset(dp.mat, 0, sizeof(dp.mat));
    memset(trans.mat, 0, sizeof(trans.mat));
    for (int c = 0; c < p; c++)
        for (int b = 0; b < p; b++)
        {
            int delta = (c - b + p) % p;
            if (delta == 0)
                trans[b][c] = m / p;
            else if (delta < m)
                trans[b][c] = int((m - delta) / p) + 1;
            else if (delta == m)
                trans[b][c] = 1;
            else
                trans[b][c] = 0;
            trans[b][c] = (trans[b][c] + mod - table[delta]) % mod;
        }
    dp[0][0] = 1, dp = dp * (trans ^ n);
    ans = (ans + mod - dp[0][0]) % mod;
    printf("%d\n", ans);
    return 0;
}
```



---

## 作者：xyz32768 (赞：9)

设在1~m的数中，模p为0,1,2,...,p-1的数分别有cnt[0],cnt[1],cnt[2],...,cnt[p-1]，模p为0,1,2,...,p-1的非素数分别有cnt0[0],cnt0[1],cnt0[2],...,cnt0[p-1]个（可用筛法求出），dp[i][j]表示到序列的第i个数，和模p为j的方案数

dp0[i][j]表示到序列的第i个数，和模p为j并且没有素数的方案数，便容易得到

dp[i][j]=sigma(dp[i-1][(j-k+p)%p]\*cnt[k]) dp0[i][j]=sigma(dp0[i-1][(j-k+p)%p]\*cnt0[k])。

边界条件dp[1][j]=cnt[j] dp0[1][j]=cnt0[j]，此时答案为dp[n][0]-dp0[n][0]。

考虑到n的范围，根据递推式，构造四个矩阵（P和Q为p\*p矩阵，V和W为p\*1矩阵）：

[  cnt[0] cnt[p-1] cnt[p-2] cnt[p-3] cnt[p-4] ... cnt[1]  ]

[  cnt[1] cnt[0]    cnt[p-1] cnt[p-2] cnt[p-3] ... cnt[2]  ]

P = [  cnt[2] cnt[1]    cnt[0]     cnt[p-1] cnt[p-2] ... cnt[3]  ]

[ cnt[3] cnt[2]     cnt[1]    cnt[0]     cnt[p-1] ... cnt[4]  ]

[ .............................                                                       ]

[ cnt0[p-1] cnt0[p-2] cnt0[p-3] cnt0[p-4] cnt0[p-5] ... cnt0[0] ]



[  cnt0[0] cnt0[p-1] cnt0[p-2] cnt0[p-3] cnt0[p-4] ... cnt0[1]  ]

[  cnt0[1] cnt0[0]    cnt0[p-1] cnt0[p-2] cnt0[p-3] ... cnt0[2]  ]

Q = [  cnt0[2] cnt0[1]    cnt0[0]     cnt0[p-1] cnt0[p-2] ... cnt0[3]  ]

[ cnt0[3] cnt0[2]     cnt0[1]    cnt0[0]     cnt0[p-1] ... cnt0[4]  ]

[ .............................                                                       ]

[ cnt0[p-1] cnt0[p-2] cnt0[p-3] cnt0[p-4] cnt0[p-5] ... cnt0[0] ]



[ cnt[0]   ]               [ cnt0[0]   ]

[ cnt[1]   ]               [ cnt0[1]   ]

V = [ cnt[2]   ]       W = [ cnt0[2]   ]

[ ...          ]               [ ...            ]

[ cnt[p-1] ]              [ cnt0[p-1] ]

则令矩阵F=P^(n-1)\*V     G=Q^(n-1)\*W

最后答案为F[1][1]-G[1][1]。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 105, CYX = 20170408, M = 2e7 + 5;
struct cyx {
    int m, n, v[N][N];
    cyx() {}
    cyx(int _m, int _n) :
        m(_m), n(_n) {memset(v, 0, sizeof(v));}
    friend inline cyx operator * (cyx a, cyx b) {
        cyx res = cyx(a.m, b.n);
        int i, j, k;
        for (i = 1; i <= res.m; i++)
            for (j = 1; j <= res.n; j++)
                for (k = 1; k <= a.n; k++)
                    res.v[i][j] = (res.v[i][j] + 1ll * a.v[i][k]
                        * b.v[k][j] % CYX) % CYX;
        return res;
    }
    friend inline cyx operator ^ (cyx a, int b) {
        cyx c = a, res = cyx(a.m, a.n);
        int i, j; for (i = 1; i <= res.m; i++)
            res.v[i][i] = 1;
        while (b) {
            if (b & 1) res = res * c;
            c = c * c;
            b >>= 1;
        }
        return res;
    }
} P, Q, V, W;
int n0, m0, p0, cnt[N], cnt0[N];
bool prime[M];
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
int main() {
    int i, j; n0 = read(); m0 = read(); p0 = read();
    for (i = 0; i < p0; i++) cnt[i] = m0 / p0;
    for (i = 1; i <= m0 % p0; i++) cnt[i]++;
    P = cyx(p0, p0); P.v[1][1] = cnt[0];
    for (i = 2; i <= p0; i++) P.v[1][i] = cnt[p0 - i + 1];
    for (i = 2; i <= p0; i++) {
        for (j = 2; j <= p0; j++)
            P.v[i][j] = P.v[i - 1][j - 1];
        P.v[i][1] = P.v[i - 1][p0];
    }
    memset(prime, true, sizeof(prime));
    prime[0] = prime[1] = 0;
    for (i = 2; i <= m0; i++) {
        if (!prime[i]) continue;
        if (i * i > m0) break;
        for (j = i * i; j <= m0; j += i)
            prime[j] = 0;
    }
    for (i = 1; i <= m0; i++)
        if (!prime[i]) cnt0[i % p0]++;
    Q = cyx(p0, p0); Q.v[1][1] = cnt0[0];
    for (i = 2; i <= p0; i++) Q.v[1][i] = cnt0[p0 - i + 1];
    for (i = 2; i <= p0; i++) {
        for (j = 2; j <= p0; j++)
            Q.v[i][j] = Q.v[i - 1][j - 1];
        Q.v[i][1] = Q.v[i - 1][p0];
    }
    for (i = 1; i <= p0; i++) for (j = 1; j <= p0; j++)
        P.v[i][j] %= CYX, Q.v[i][j] %= CYX;
    V = cyx(p0, 1); W = cyx(p0, 1);
    for (i = 1; i <= p0; i++) V.v[i][1] = cnt[i - 1] % CYX;
    for (i = 1; i <= p0; i++) W.v[i][1] = cnt0[i - 1] % CYX;
    P = (P ^ n0 - 1) * V; Q = (Q ^ n0 - 1) * W;
    printf("%d\n", (P.v[1][1] - Q.v[1][1] + CYX) % CYX);
    return 0;
}
```

---

## 作者：shadowice1984 (赞：8)

这里介绍一下矩阵快速幂的进阶技巧——双矩阵快速幂

矩阵快速幂优化dp转移是一个非常暴力的手段，通过矩阵快速幂我们可以将原来$O(NM)$的复杂度偏移至$O(M^{3}logN)$在M和N差距甚大的情况下真的是再好不过了

## 前置芝士：矩阵快速幂优化dp

这里为了避免萌新不懂矩阵快速幂所以先讲下优化原理和构造注意事项

~~(熟练的诸位可以自行跳过)~~

(在此之前先百度下矩阵和矩阵乘法的定义)

首先有些时候假设我们有一个二维的计数dp，而且可以滚动数组优化

那么我们的dp方程如果恰好长这样，其中$Tr_{i,j}$表示i状态是否可以转移到j的话。

## $Dp_{i,j}=\sum_{k=0}^{n}Dp_{i-1,k}Tr_{k,j}$

我们会发现这个东西和矩阵乘法(假设$a×b=c$)的式子非常像

## $C_{i,j}=\sum_{k=0}^{n}A_{i,k}B_{k,j}$

非常像，更准确的说，如果把dp数组的某一行看做方阵的第一行(毕竟没啥人会认真的写非方阵乘法)的话

那么我们可以列出这样的矩阵乘法式子$Dp=Dp×Tr$就可以完成一次转移

那么如果我们进行了n次转移的话，就相当于$Dp=Dp×Tr^{n}$

然后根据矩阵乘法的结合律，$Tr^{n}$可以快速幂计算

这个就是矩阵快速幂的原理

通过上述的推导不难发现，**在一次转移中**:如果状态i有k种方式转移到状态j的话，我们会发现$Tr_{i,j}=k$因为tr数组此时替代了一般dp转移过程的判定是不是合法转移的判断语句的作用

当然在计数dp中因为乘法原理的关系，有些时候转移需要乘上一定的系数，而这个作用也被Tr数组包了

刚才说了这么多，就是希望大家意识到，我们的转移矩阵是**单向的转移关系**，并且每次转移严格的由**行状态转移到列状态**，构造的时候请务必注意

____________________

# 本题题解

这道题如果是去掉必须有质数的限制的话是非常简单的

直接$DP_{i,j}$表示长度为i的序列，且序列各元素和%p为j的方案数

然后显然如果状态p1需要转移到p2的话，有($m/p+(p2-p1)$是否大于$m\%p$)种方法此时直接矩阵快速幂硬莽过去就可以了,最后的答案当然是$Dp_{n,0}$了

但是问题是我们有质数的限制啊……，此时的情况就会变得非常辣手

观察到m<=2\*1e7，这是什么？这是卡掉埃式筛放欧拉筛过的数据！(尽管这样的话O(NloglogN)和O(N)也不是特别好卡)

所以先上一个欧拉筛筛出质数再说

然后我们为了方便起见，设$zhimo_{i}$表示%p为i，且小于等于m的质数有多少个

此时我们发现，其实只需要在刚才的dp中加一维k，($k∈\{0,1\}$)表示有无质数就可以转移了

怎么转移呢？如果0状态要转移到0状态的话，那么必须放非质数，如果1状态需要转移到1状态的话，当然是随便放了，如果是0状态要转移到1状态的话是只可以放质数的，如果是1状态转移到0状态的话，当然是不可以转移的

所以如果(0，p1)这个状态需要转移到(0,p2)的话，转移系数当然是(%p=p2-p1的数-$zhimo_{p2-p1}$)啦

同理转移(0,p1)到(1,p2)的话，转移系数就是$zhimo_{p2-p1}$了

转移(1,p1)到(1,p2)的话，转移系数和没有质数限制的时候一样

此时我们发现，我们可以开一个200×200的转移矩阵

前一半是$Dp_{0,j}$后一半是$Dp_{1,j}$然后按照上述的算法转移就可以了

对了由于是正整数，所以需要把0减掉

就酱……

上代码~

```C
#include<cstdio>
#include<algorithm>
using namespace std;const int M=2*1e7+10;const int N=210;typedef long long ll;const ll mod=20170408;
int n;int m;int p;int zhi[M];int book[M];int ct;int t[N][N];int siz;
int mo[N];int zmo[N];int nzmo[N];int del[N][N];
struct martix//矩阵类
{
	ll mp[N][N];
	void operator *=(const martix& b)
	{
		for(int i=0;i<siz;i++){for(int j=0;j<siz;j++){t[i][j]=0;}}
		for(int i=0;i<siz;i++)
			for(int j=0;j<siz;j++)
				for(int k=0;k<siz;k++)
				{t[i][j]=(t[i][j]+mp[i][k]*b.mp[k][j])%mod;}
		for(int i=0;i<siz;i++){for(int j=0;j<siz;j++){mp[i][j]=t[i][j];}}
	}
}st,tr,res;
int main()
{
	scanf("%d%d%d",&n,&m,&p);siz=2*p;
	for(int i=2;i<=m;i++)//线性筛素数
	{
		if(!book[i]){zhi[++ct]=i;}
		for(int j=1;j<=ct&&zhi[j]*i<=m;j++)
		{book[zhi[j]*i]=true;if(i%zhi[j]==0){break;}}
	}
	for(int i=1;i<=ct;i++){zmo[zhi[i]%p]++;}//处理出来素数%p为i的方案数
	for(int i=0;i<=m%p;i++){mo[i]=m/p+1;}//然后处理%p为i的方案数
	for(int i=m%p+1;i<p;i++){mo[i]=m/p;}
	mo[0]--;//正整数，去掉0
	for(int i=0;i<p;i++){nzmo[i]=mo[i]-zmo[i];}//%p为i且非质数
	for(int p1=0;p1<p;p1++)
	{for(int p2=0;p2<p;p2++){del[p1][p2]=(p2+p-p1)%p;}}
	for(int p1=0;p1<p;p1++)//0->0
 	{
		for(int p2=0;p2<p;p2++)
		{tr.mp[p1][p2]=nzmo[del[p1][p2]];}
 	}
 	for(int p1=0;p1<p;p1++)//1->1
 	{
 		for(int p2=0;p2<p;p2++)
 		{tr.mp[p+p1][p+p2]=mo[del[p1][p2]];}
	}
	for(int p1=0;p1<p;p1++)//0->1
	{
		for(int p2=0;p2<p;p2++)
		{tr.mp[p1][p+p2]=zmo[del[p1][p2]];}
	}
	for(int i=0;i<siz;i++){res.mp[i][i]=1;}//矩阵快速幂不解释
	for(int i=n;i;i>>=1,tr*=tr){if(i&1){res*=tr;}}
	st.mp[0][0]=1;st*=res;printf("%lld",st.mp[0][p]);return 0;//拜拜程序~
}
```















---

## 作者：Soulist (赞：4)

这道题非常的迷幻

首先我们要容斥

考虑记$dp[i][j]$表示前$i$位$\%p=j$的方案数

$g[i][j]$表示前$i$位只用合数$\%p=j$的方案数

于是可以考虑最暴力的$dp$是$O(nm^*p)$的

但是并没必要

我们可以提前处理$1-m$这些数$\%p$的值，用这些值来转移就好了

也就是额外记一个$cnt[i]$表示$\%p$为$i$的数量和$comp[i]$表示$\%p$为$i$的合数的数量

于是就没必要枚举$1-m$转移了

复杂度变成$O(np^2)$

实际上这个序列的生成与位置无关

也就是说我们可以倍增的处理

$dp[n][j]$可以由$dp[n/2][j]$来直接转移

于是递归做就好了

复杂度$O(p^2\log n)$

然而因为转移的形式是一个卷积的模样

所以是可以做到$O(p\log p\log n)$的

但是出题人又不卡，就没写...

```cpp
#include<bits/stdc++.h>
using namespace std;
#define rep( i, s, t ) for( register int i = s; i <= t; ++ i )
#define re register
#define int long long
int read() {
	char cc = getchar(); int cn = 0, flus = 1;
	while(cc < '0' || cc > '9') {  if( cc == '-' ) flus = -flus;  cc = getchar();  }
	while(cc >= '0' && cc <= '9')  cn = cn * 10 + cc - '0', cc = getchar();
	return cn * flus;
}
const int P = 20170408 ; 
const int N = 2000000 + 5 ;
const int M = 100 + 5 ; 
const int R = 2 * 1e7 + 5 ; 
int n, m, p, dp[2][M], g[2][M], cnt[M], comp[M], Ed ; 
int pr[N], top;
bool isp[R];
void Init() {
	isp[1] = 1 ; 
	for( int i = 2; i <= m; ++ i ) {
		if( !isp[i] ) pr[++ top] = i, isp[i] = 0 ;
		for(int j = 1; j <= top; ++ j ) {
			if ( pr[j] * i > m ) break ;
			isp[pr[j] * i] = 1 ;
			if( i % pr[j] == 0 )  break;
		}
	}
}
void F( int x,  int w ) {
	if( x == 1 ) {
		rep( i, 0, ( p - 1 ) ) dp[w][i] = cnt[i], g[w][i] = comp[i] ; 
		return ; 
	}
	F( x / 2, w ^ 1 ) ;
	rep( j, 0, Ed ) dp[w][j] = 0, g[w][j] = 0 ;  
	rep( j, 0, Ed ) rep( k, 0, Ed ) 
	dp[w][j] = ( dp[w ^ 1][k] * dp[w ^ 1][(p + j - k) % p] % P + dp[w][j] ) % P ;
	rep( j, 0, Ed ) rep( k, 0, Ed ) 
	g[w][j] = ( g[w ^ 1][k] * g[w ^ 1][(p + j - k) % p] % P + g[w][j] ) % P ;
	if( x & 1 ) {
		rep( j, 0, Ed ) dp[w ^ 1][j] = dp[w][j], g[w ^ 1][j] = g[w][j] ;
		rep( j, 0, Ed ) dp[w][j] = 0, g[w][j] = 0 ;  
		rep( j, 0, Ed ) rep( k, 0, Ed )
		dp[w][j] = ( dp[w ^ 1][k] * cnt[(p + j - k) % p] % P + dp[w][j] ) % P ;
		rep( j, 0, Ed ) rep( k, 0, Ed ) 
		g[w][j] = ( g[w ^ 1][k] * comp[(p + j - k) % p] % P + g[w][j] ) % P ;
	}
}
signed main()
{
	n = read(), m = read(), p = read() ; isp[1] = 1, Init() ; 
	rep( i, 1, m ) cnt[i % p] ++, comp[i % p] += isp[i] ;
	 Ed = p - 1 ; F( n, 0 ) ;
	printf("%d\n", ( dp[0][0] - g[0][0] + P ) % P ) ; 
	return 0;
}

```

---

## 作者：pengyule (赞：3)

## 题意
Alice 想要得到一个长度为 $n$ 的正整数序列 $\{a_i\}$，满足：
- $a_i\le m$
- $p|\sum a_i$
- $\exists i\in[1,n]$，使 $a_i$ 是质数

Alice 想知道，有多少个序列满足她的要求。

## 朴素
由于题目有【$n$ 个数】【和】【有否质数】这三个主要限制，因此：
设 $F(i,j,1/0)$ 表示前 $i$ 个数，和为 $j$，是否有了一个质数。
列出朴素 dp 方程：

$$
F(i,j,0)=\sum_{1\le k\le m}F(i-1,j-k,0)\times [k \text{ isn't prime}]\\
F(i,j,1)=\sum_{1\le k\le m}F(i-1,j-k,1)+F(i-1,j-k,0)\times [k\text{ is prime}]
$$

所求即为 $\sum_{p|i,i\le nm}F(n,i,1)$。

发现具体的【和】不重要，因为只关心【和 $\bmod p$】，所以 $j,k$ 均可在 $\pmod p$ 意义下枚举。
设 $A_k,B_k,C_k$ 分别表示 $\mod p=k$ 的质数、非质数、数的个数。

$$
F(i,j,0)=\sum_{1\le k\le m}F(i-1,j-k,0)\times B_k\\
F(i,j,1)=\sum_{1\le k\le m}F(i-1,j-k,1)\times C_k+F(i-1,j-k,0)\times A_k
$$

所求即为 $F(n,0,1)$。

## 矩阵加速

每次转移在做一样的事情，所以矩阵快速幂可以用来加速转移。

dp 矩阵：

$$
\left[
\begin{matrix}
F_{0,0}\ F_{1,0}\ F_{2,0}\ \cdots\ F_{p-1,0}\ F_{0,1}\ \cdots \ F_{p-1,1}
\end{matrix}
\right]\\
$$

转移矩阵：

| 编号   | 1    | 2    | p    | 1    | 2    | p    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | A0   | A1   | …    | B0   | B1   | …    |
| 2    | Ap-1 | A0   | …    | Bp-1 | B0   | …    |
|      | …    | Ap-1 | …    | …    | Bp-1 | …    |
|      | …    | …    | …    | …    | …    | …    |
|      | A3   | …    | …    | …    | …    | …    |
|      | A2   | A3   | …    | …    | …    | …    |
| p    | A1   | A2   | …    | B1   | B2   | …    |
| p+1  | C0   | C1   | …    | 0    | …    | …    |
|      | Cp-1 | C0   | …    | 0    | …    | …    |
|      | …    | Cp-1 | …    | …    | …    | …    |
|      | …    | …    | …    | …    | …    | …    |
|      | …    | …    | …    | …    | …    | …    |
|      | …    | …    | …    | 0    | …    | …    |
| 2p   | C1   | C2   | …    | 0    | …    | …    |

这样就可以利用 $O(p^3\log n)$ 时间得到，其中 $\log n$ 为快速幂，$p^3$ 为两个 $(2p)^2$ 的矩阵的乘法。[可以通过此题。](https://www.luogu.com.cn/record/68998129)

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=205,M=2e7+5,mod=20170408;
int n,m,p,tot,a[N][N],f[N],prime[M],A[N],B[N],C[N];
bool v[M];
void mul(int f[N],int a[N][N]){
	int c[N];memset(c,0,sizeof(c));
	for(int i=1;i<=2*p;i++)
		for(int j=1;j<=2*p;j++)
			c[i]+=1ll*f[j]*a[j][i]%mod,c[i]%=mod;
	memcpy(f,c,sizeof(c));
}
void mul2(int a[N][N],int b[N][N]){
	int c[N][N];memset(c,0,sizeof(c));
	for(int i=1;i<=2*p;i++)
		for(int j=1;j<=2*p;j++)
			for(int k=1;k<=2*p;k++)
				c[i][j]+=1ll*a[i][k]*b[k][j]%mod,c[i][j]%=mod;
	memcpy(a,c,sizeof(c));
}
void qp(int a[N][N],int b){
	int c[N][N];memset(c,0,sizeof(c));
	for(int i=1;i<=2*p;i++)c[i][i]=1;
	while(b){
		if(b&1)mul2(c,a);
		b>>=1,mul2(a,a);
	}
	memcpy(a,c,sizeof(c));
}
int main(){
	cin>>n>>m>>p;
	v[1]=1;
	for(int i=2;i<=m;i++){
		if(!v[i])prime[++tot]=i;
		for(int j=1;j<=m&&prime[j]*i<=m;j++){
			v[prime[j]*i]=1;
			if(i%prime[j]==0)break;
		}
	}
	for(int i=1;i<=m;i++)A[i%p]+=!v[i],B[i%p]+=v[i],C[i%p]++;
	for(int i=1;i<=p;i++)for(int j=1;j<=p;j++)a[i][j]=B[(p-i+j)%p];
	for(int i=1;i<=p;i++)for(int j=1;j<=p;j++)a[i][j+p]=A[(p-i+j)%p];
	for(int i=1;i<=p;i++)for(int j=1;j<=p;j++)a[i+p][j+p]=C[(p-i+j)%p];
	f[1]=1;
	qp(a,n);
	mul(f,a);
	cout<<f[p+1];
}
```

### 进一步优化

$p$ 再大一点就过不了了，但其实完全可以再优化。

观察转移矩阵，其实我们是知道的，第 $a_{1,2}...a_{p,2}$ 其实就是 $a_{1,1}...a_{p,1}$ 向下平移一格（环状平移）得到的。其它三个矩形区域也是类似。**即便在做了快速幂之后，这种格局也是不会改变的**。考虑将这些很类似的列中只取一个 $p\times 1$ 的列作为代表进行计算这样只用 $O(p^2)$，并再用 $O(p^2)$ 进行复制、平移。具体地，按原来矩乘方式计算结果矩阵中 $(1,1)...(p,1);(p+1,1)...(2p,1);(1,p+1)...(p,p+1);(p+1,p+1)...(2p,p+1)$ 这些元素的值，然后按照规则填充空白部分。复杂度 $O(p^2\log n)$。[更加可以通过。](https://www.luogu.com.cn/record/69001317)

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=205,M=2e7+5,mod=20170408;
int n,m,p,tot,a[N][N],f[N],prime[M],A[N],B[N],C[N];
bool v[M];
void mul(int f[N],int a[N][N]){
	int c[N];memset(c,0,sizeof(c));
	for(int i=1;i<=2*p;i++)
		for(int j=1;j<=2*p;j++)
			c[i]+=1ll*f[j]*a[j][i]%mod,c[i]%=mod;
	memcpy(f,c,sizeof(c));
}
void mul2(int a[N][N],int b[N][N]){
	int c[N][N];memset(c,0,sizeof(c));
	for(int i=1;i<=2*p;i++)
		for(int j=1;j<=2*p;j++)
			c[i][1]+=1ll*a[i][j]*b[j][1]%mod,c[i][1]%=mod;
	for(int i=1;i<=2*p;i++)
		for(int j=1;j<=2*p;j++)
			c[i][p+1]+=1ll*a[i][j]*b[j][p+1]%mod,c[i][p+1]%=mod;
	for(int j=2;j<=p;j++){
		for(int i=1;i<=p;i++)c[i][j]=c[(i-2+p)%p+1][j-1];
		for(int i=1;i<=p;i++)c[i+p][j]=c[(i-2+p)%p+1+p][j-1];
	}
	for(int j=p+2;j<=2*p;j++){
		for(int i=1;i<=p;i++)c[i][j]=c[(i-2+p)%p+1][j-1];
		for(int i=1;i<=p;i++)c[i+p][j]=c[(i-2+p)%p+1+p][j-1];
	}
	memcpy(a,c,sizeof(c));
}
void qp(int a[N][N],int b){
	int c[N][N];memset(c,0,sizeof(c));
	for(int i=1;i<=2*p;i++)c[i][i]=1;
	while(b){
		if(b&1)mul2(c,a);
		b>>=1,mul2(a,a);
	}
	memcpy(a,c,sizeof(c));
}
int main(){
	cin>>n>>m>>p;
	v[1]=1;
	for(int i=2;i<=m;i++){
		if(!v[i])prime[++tot]=i;
		for(int j=1;j<=m&&prime[j]*i<=m;j++){
			v[prime[j]*i]=1;
			if(i%prime[j]==0)break;
		}
	}
	for(int i=1;i<=m;i++)A[i%p]+=!v[i],B[i%p]+=v[i],C[i%p]++;
	for(int i=1;i<=p;i++)for(int j=1;j<=p;j++)a[i][j]=B[(p-i+j)%p];
	for(int i=1;i<=p;i++)for(int j=1;j<=p;j++)a[i][j+p]=A[(p-i+j)%p];
	for(int i=1;i<=p;i++)for(int j=1;j<=p;j++)a[i+p][j+p]=C[(p-i+j)%p];
	f[1]=1;
	qp(a,n);
	mul(f,a);
	cout<<f[p+1];
}
```

---

## 作者：Gauss0320 (赞：3)

考虑没有第二条限制怎么做.

设$f_{i,j}$为$i$个数（在$1$到$m$之间），和对$p$取模为$j$的序列个数.

显然有转移方程$f_{i,j}=\sum_{k}f_{i-1,k}v_{j-k}$，其中$v_{i}$为$1$到$m$之间，$i$的同余等价类的大小，可以预处理，总时间复杂度$O(nm)$.

接下来考虑矩乘优化，由递推式易知
$$\begin{bmatrix}v_0&v_{p-1}&\cdots&v_1\\v_1&v_0&\cdots&v_2\\\vdots&\vdots&\ddots&\vdots\\v_{p-1}&v_{p-2}&\cdots&v_0\end{bmatrix}\begin{bmatrix}f_{i-1,0}\\f_{i-1,1}\\\vdots\\f_{i-1,p-1}\end{bmatrix}=\begin{bmatrix}f_{i,0}\\f_{i,1}\\\vdots\\f_{i,p-1}\end{bmatrix}$$
又易知$(f_{1,0},f_{1,1},\cdots,f_{1,p-1})'=(v_0,v_1,\cdots,v_{p-1})'$，于是我们可以用矩阵快速幂在$O(p^3\log n)$的时间解决.

考虑上第二条限制，实际上只需要将合数取出来做个类似的dp，容斥即可.

做到这里已经可以通过本题了，但是还有进一步的优化空间

上式左边那个矩阵满足下一行都是由上一行右移一位得来的，在线性代数中，我们称它为**循环矩阵**.

循环矩阵有一个性质，两个同级的循环矩阵的和与积都为循环矩阵，所以欲求一个循环矩阵的$n$次幂，我们仅需知道它的$n$次幂的**第一行**即可.

设$f_i$和$g_i$分别为两个$n$级循环矩阵第一行第$i$列的元素，由矩阵乘法的定义，它们的乘积的第一行第$i$列为
$$h_i=\sum_{j+k\equiv i\pmod{n}}f_j g_k$$
这是一个循环卷积，于是可以将上述方法优化到$O(p^2\log n)$，用MTT做这个循环卷积可以优化到$O(p\log p\log n)$.

给出两份我写的代码

直接矩乘的做法

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>

using namespace std;
const int N = 1e9;
const int M = 2e7;
const int mod = 20170408;
int n, m, p, tot, cnt[100 + 1], compo[100 + 1], prime[M + 1];
bool check[M + 1];
struct Matrix
{
	int a[100 + 1][100 + 1];
	Matrix()
	{
		memset(a, 0, sizeof a);
	}
	Matrix operator * (const Matrix& o) const
	{
		Matrix ret;
		for(int i = 0; i < p; i++)
		{
			for(int j = 0; j < p; j++)
			{
				for(int k = 0; k < p; k++)
				{
					ret.a[i][j] = (1ll * ret.a[i][j] + 1ll * a[i][k] * 1ll * o.a[k][j]) % mod;
				}
			}
		}
		return ret;
	}
}F, G, P, Q, V, W, I;

Matrix pow(Matrix a, int b)
{
	Matrix ret = I;
	for(; b; b >>= 1, a = a * a)
		if(b & 1) ret = ret * a;
	return ret;
}
void sieve()
{
	for(int i = 2; i <= M; i++)
	{
		if(!check[i]) prime[++tot] = i;
		for(int j = 1; j <= tot && i * prime[j] <= M; j++)
		{
			check[i * prime[j]] = 1;
			if(i % prime[j] == 0)
				break;
		}
	}
}
void init()
{
	for(int i = 0; i < p; i++)
		cnt[i] = m / p;
	for(int i = 1; i <= m % p; i++)
		cnt[i]++;
	check[1] = 1;
	for(int i = 1; i <= m; i++)
		if(check[i]) compo[i % p]++;
	for(int i = 0; i < p; i++)
	{
		P.a[0][i] = cnt[(p - i) % p];
		Q.a[0][i] = compo[(p - i) % p];
		V.a[i][0] = cnt[i];
		W.a[i][0] = compo[i];
		I.a[i][i] = 1;
	}
	for(int i = 1; i < p; i++)
	{
		for(int j = 0; j < p; j++)
		{
			P.a[i][j] = P.a[i - 1][(j - 1 + p) % p];
			Q.a[i][j] = Q.a[i - 1][(j - 1 + p) % p];
		}
	}
}
int main()
{
	sieve();
	scanf("%d %d %d", &n, &m, &p);
	init();
	F = pow(P, n - 1) * V, G = pow(Q, n - 1) * W;
	printf("%d\n", (F.a[0][0] - G.a[0][0] + mod) % mod);
	return 0;
}
```

MTT的做法
```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <vector>
#include <algorithm>

using namespace std;
const int m1 = 469762049;
const int m2 = 998244353;
const int m3 = 1004535809;
const int N = 1e9;
const int M = 2e7;
const int mod = 20170408;
int n, m, p, tot, rev[400 + 1], cnt[100 + 1], compo[100 + 1], prime[M + 1];
bool check[M + 1];
struct Matrix
{
	int a[100 + 1][100 + 1];
	Matrix()
	{
		memset(a, 0, sizeof a);
	}
	Matrix operator * (const Matrix& o) const
	{
		Matrix ret;
		for(int i = 0; i < p; i++)
		{
			for(int j = 0; j < p; j++)
			{
				for(int k = 0; k < p; k++)
				{
					ret.a[i][j] = (1ll * ret.a[i][j] + 1ll * a[i][k] * 1ll * o.a[k][j]) % mod;
				}
			}
		}
		return ret;
	}
}F, G, V, W;
long long mul(long long a, long long b, long long mod)
{
	long long ret = 0;
	for(; b; b >>= 1, a = (a + a) % mod)
		if(b & 1) ret = (ret + a) % mod;
	return ret;
}
int pow(int a, int b, int mod)
{
	int ret = 1;
	for(; b; b >>= 1, a = 1ll * a * 1ll * a % mod)
		if(b & 1) ret = 1ll * ret * 1ll * a % mod;
	return ret;
}
struct poly
{
	vector<int> a;
	int mod;
	poly(int x = 0)
	{
		if(x) a.push_back(x);
	}
	int size()
	{
		return a.size();
	}
	void resize(int x)
	{
		a.resize(x); 
	}
	void shrink()
	{
		for(; !a.empty() && !a.back(); a.pop_back());
	}
	int operator[](const int& x) const
	{
		if(x < 0 || x >= a.size())
			return 0;
		return a[x];
	}
	void NTT(int type = 1)
	{
		static const int g = 3;
		int n = size();
		for(int i = 0; i < n; i++)
			if(i < rev[i]) swap(a[i], a[rev[i]]);
		for(int mid = 1; mid < n; mid <<= 1)
		{
			int step = pow(g, (mod - 1) / (mid << 1), mod);
			for(int i = 0; i < n; i += (mid << 1))
			{
				for(int j = 0, omega = 1; j < mid; j++, omega = 1ll * omega * 1ll * step % mod)
				{
					int x = a[i + j], y = 1ll * a[i + j + mid] * 1ll * omega % mod;
					a[i + j] = (1ll * x + 1ll * y) % mod;
					a[i + j + mid] = (1ll * x - 1ll * y + 1ll * mod) % mod;
				}
			}
		}
		if(type == -1)
		{
			reverse(a.begin() + 1, a.end());
			int inv = pow(n, mod - 2, mod);
			for(int i = 0; i < n; i++)
				a[i] = 1ll * a[i] * 1ll * inv % mod;
		}
	}
	friend inline poly operator * (poly f, poly g)
	{
		int lim = 1, mod = f.mod;
		for(; lim < f.size() + g.size() - 1; lim <<= 1);
		for(int i = 0; i < lim; i++)
		{
			rev[i] = rev[i >> 1] >> 1;
			if(i & 1)
				rev[i] |= lim >> 1;
		}
		f.resize(lim), g.resize(lim);
		f.NTT(), g.NTT();
		for(int i = 0; i < lim; i++)
			f.a[i] = 1ll * f[i] * 1ll * g[i] % mod;
		f.NTT(-1);
		for(int i = p; i < lim; i++)
			f.a[i % p] = (1ll * f.a[i % p] + 1ll * f.a[i]) % mod, f.a[i] = 0;
		f.shrink();
		return f;
	}
};
poly MTT(poly f, poly g)
{
	poly p[3], q[3], ans;
	p[0].resize(f.size()), p[1].resize(f.size()), p[2].resize(f.size());
	q[0].resize(g.size()), q[1].resize(g.size()), q[2].resize(g.size());
	p[0].mod = q[0].mod = m1;
	p[1].mod = q[1].mod = m2;
	p[2].mod = q[2].mod = m3;
	for(int i = 0; i < f.size(); i++)
	{
		p[0].a[i] = p[1].a[i] = p[2].a[i] = f[i];
		p[0].a[i] %= m1, p[1].a[i] %= m2, p[2].a[i] %= m3;
	}
	for(int i = 0; i < g.size(); i++)
	{
		q[0].a[i] = q[1].a[i] = q[2].a[i] = g[i];
		q[0].a[i] %= m1, q[1].a[i] %= m2, q[2].a[i] %= m3;
	}
	p[0] = p[0] * q[0], p[1] = p[1] * q[1], p[2] = p[2] * q[2];
	ans.resize(p[0].size());
	long long M = 1ll * m1 * 1ll * m2;
	for(int i = 0; i < ans.size(); i++)
	{
		long long A, k;
		A = (mul(1ll * p[0][i] * 1ll * m2, pow(m2 % m1, m1 - 2, m1), M)
		   + mul(1ll * p[1][i] * 1ll * m1, pow(m1 % m2, m2 - 2, m2), M)) % M;
		k = ((1ll * p[2][i] - A) % m3 + m3) % m3 * pow(M % m3, m3 - 2, m3) % m3;
		ans.a[i] = (A % mod + (k % mod) * (M % mod) % mod) % mod;
	}
	return ans;
}
poly pow(poly f, int b)
{
	poly ret(1);
	for(; b; b >>= 1, f = MTT(f, f))
		if(b & 1) ret = MTT(ret, f);
	return ret;
}
void sieve()
{
	check[1] = 1;
	for(int i = 2; i <= M; i++)
	{
		if(!check[i]) prime[++tot] = i;
		for(int j = 1; j <= tot && i * prime[j] <= M; j++)
		{
			check[i * prime[j]] = 1;
			if(i % prime[j] == 0)
				break;
		}
	}
}
poly f, g;
void init()
{
	for(int i = 0; i < p; i++)
		cnt[i] = m / p;
	for(int i = 1; i <= m % p; i++)
		cnt[i]++;
	for(int i = 1; i <= m; i++)
		if(check[i]) compo[i % p]++;
	f.resize(p), g.resize(p);
	for(int i = 0; i < p; i++)
		f.a[i] = cnt[(p - i) % p], g.a[i] = compo[(p - i) % p];
}
int main()
{
	sieve();
	scanf("%d %d %d", &n, &m, &p);
	init();
	f = pow(f, n - 1), g = pow(g, n - 1);
	for(int i = 0; i < p; i++)
	{
		F.a[0][i] = f[i], G.a[0][i] = g[i];
		V.a[i][0] = cnt[i], W.a[i][0] = compo[i];
	}
	for(int i = 1; i < p; i++)
	{
		for(int j = 1; j < p; j++)
		{
			F.a[i][j] = F.a[i - 1][(j - 1 + p) % p];
			G.a[i][j] = G.a[i - 1][(j - 1 + p) % p];
		}
	}
	F = F * V, G = G * W;
	printf("%d\n", (1ll * F.a[0][0] - 1ll * G.a[0][0] + 1ll * mod) % mod);
	return 0;
}
```

在此感谢一位博主（教会了我循环矩阵快速幂）

[浅谈循环矩阵及其快速幂](https://www.luogu.com.cn/blog/water-mi/2333333-233333)

其实循环矩阵有很多优美的性质，比如说

[知乎回答：如何求n级循环矩阵的行列式？](https://www.zhihu.com/question/22013474/answer/1770995621)



---

## 作者：cheng2010 (赞：2)

# 序列计数

考虑一个朴素的暴力 dp：

设 $f_{i,j}$ 为前 $i$ 个点，和对 $p$ 取模为 $j$ 时的方案数，**不考虑质数**。

设 $g_{i,j}$ 为前 $i$ 个点，和对 $p$ 取模为 $j$ 时的方案数，**只考虑合数**。

设 $cnt1_{i}$ 为 $1\sim m$ 中的数 $\mod p$ 后为 $i$ 的数的数量。

设 $cnt2_{i}$ 为 $1\sim m$ 中的数 $\mod p$ 后为 $i$ 的**合数**的数量。



转移：

$\displaystyle\ \sum_{i=1}^{n} \sum_{j=0}^{p-1} f_{i,j}=\sum_{k=0}^{p-1} f_{i-1,k} \times cnt1_{j-k}$

$\displaystyle\ \sum_{i=1}^{n} \sum_{j=0}^{p-1} g_{i,j}=\sum_{k=0}^{p-1} g_{i-1,k} \times cnt2_{j-k}$

时间复杂度：$O(np^2)$，显然爆炸。


考虑优化，~~我会矩阵快速幂！~~，其实有一个更优秀的做法。

发现，序列的与顺序无关，所以，显然的，前 $\lfloor \frac{n}{2} \rfloor$ 的答案与后 $\lfloor \frac{n}{2} \rfloor$ 的答案一模一样，所以，可以分治
地处理 $\lfloor \frac{n}{2} \rfloor$ 的答案再合并即可，注意特判 $n$ 为奇数的情况，时间：$O(p^2\log n +m)$，爆踩矩阵快速幂。

## code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e7+7;
const int Mod=20170408;
int f[2][107],g[2][107];
int n,m,p;
bool not_su[N];
int su[N],cnt;
int cnt1[N];
int cnt2[N];
inline void solve(int id,bool opt)
{
	if(id==1)
	{
		for(int i=0;i<p;i++) f[opt][i]=cnt1[i],g[opt][i]=cnt2[i];
		return;
	}
	solve(id>>1,opt^1);
	for(int i=0;i<p;i++) f[opt][i]=g[opt][i]=0;
	for(int i=0;i<p;i++)
	{
		for(int j=0;j<p;j++)
		{
			f[opt][i]+=f[opt^1][j]*1ll*f[opt^1][(p+i-j)%p]%Mod;
			f[opt][i]%=Mod;
			
			g[opt][i]+=g[opt^1][j]*1ll*g[opt^1][(p+i-j)%p]%Mod;
			g[opt][i]%=Mod;
		}
	}
	if(id&1)
	{
		for(int i=0;i<p;i++)
		{
			f[opt^1][i]=f[opt][i];
			g[opt^1][i]=g[opt][i];
			f[opt][i]=0;
			g[opt][i]=0;
		}
		for(int i=0;i<p;i++)
		{
			for(int j=0;j<p;j++)
			{
				f[opt][i]+=f[opt^1][j]*1ll*cnt1[(p+i-j)%p]%Mod;
				f[opt][i]%=Mod;
				
				g[opt][i]+=g[opt^1][j]*1ll*cnt2[(p+i-j)%p]%Mod;
				g[opt][i]%=Mod;
			}
		}
		
	}
}
int main()
{
	not_su[1]=1;
	cin>>n>>m>>p;
	for(int i=2;i<=m;i++)
	{
		if(!not_su[i])
		{
			su[++cnt]=i;
		}
		for(int j=1;j<=cnt;j++)
		{
			int v=su[j];
			if(i*1ll*v>m) break;
			not_su[i*v]=1;
			if(i%v==0) break;
		}
	}
	for(int i=1;i<=m;i++) cnt1[i%p]++,cnt2[i%p]+=not_su[i];
	solve(n,0);
	cout<<(f[0][0]-g[0][0]+Mod)%Mod;
}
```

---

## 作者：nixi (赞：2)

/\*本题目的原始状态转移方程为f[i][j]+=f[i-1][(j-k+p)%p],又因为n，m非常大而

p很小，所以考虑有矩阵乘法进行优化。矩阵中的ans[i][j]表示i-1余i的状态可以通过加

多少个数转移到i余j的状态，然后进行矩阵快速幂，再加入一些容斥就可以了。\*/


   
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<cstdlib>
#define LL long long 
using namespace std;
const int MAXN=200;
const int mod=20170408;
struct node{
    LL ans[MAXN][MAXN];
};
node mul,ans;
LL N,M,P,jieguo1,jieguo2;
int prime[20000007];
bool vis[20000007];
LL rest[MAXN];
inline node cheng(node a,node b)
{
     node p;
     for(int i=0;i<105;++i)
      for(int j=0;j<105;++j) 
        p.ans[i][j]=0;
     for(int i=0;i<P;++i)
      for(int j=0;j<P;++j)
       for(int k=0;k<P;++k)
        p.ans[i][j]=(p.ans[i][j]+a.ans[i][k]*b.ans[k][j])%mod;
     return p;
}
void quickmatrix(LL b)
{
     while(b)
     {
          if(b%2)
           ans=cheng(ans,mul);
          b=b/2;
          mul=cheng(mul,mul);
     }
}
void pre()
{
     //注意1既不是合数也不是质数 
     for(int i=2;i<=M;++i)
      {
           if(vis[i]==0)
            rest[i%P]++,prime[++prime[0]]=i;
         for(int j=1;prime[j]*i<=M&&j<=prime[0];++j)
          {
               vis[i*prime[j]]=1;
               if(i%prime[j]==0) break;
          }
      }
}
int main()
{
   cin>>N>>M>>P;
   for(int i=0;i<P;++i)
    for(int j=0;j<P;++j)
     {
        if(i==j)
         {
             mul.ans[i][j]=(mul.ans[i][j]+M/P)%mod;
         }
        else 
         {
             if(M%P>=(j-i+P)%P) mul.ans[i][j]++;
            mul.ans[i][j]=(mul.ans[i][j]+M/P)%mod;
         }
     }
   pre();
//for(int i=0;i<P;++i)
//{
// for(int j=0;j<P;++j)
//  printf("%lld ",mul.ans[i][j]);
// cout<<endl;
//}
  ans.ans[0][0]=1;   //注意dp的边界需要用矩乘的初始值来控制 
   quickmatrix(N);
   for(int i=0;i<P;++i)
    jieguo1=(jieguo1+ans.ans[i][0])%mod;//接下来容斥 
 //  printf("%lld\n",jieguo1); 
   for(int i=0;i<P;++i)
    for(int j=0;j<P;++j)
     {
         ans.ans[i][j]=0;
         mul.ans[i][j]=0;
     }
   ans.ans[0][0]=1;
   for(int i=0;i<P;++i)     //接下来别忘记筛素数表然后判断矩阵转移时不含素数的条件 
    for(int j=0;j<P;++j)
     {
        if(i==j)
         {
             mul.ans[i][j]=(mul.ans[i][j]+M/P-rest[0]+2*mod)%mod; 
          }
        else 
         {
             if(M%P>=(j-i+P)%P) mul.ans[i][j]++;
            mul.ans[i][j]=(mul.ans[i][j]+M/P-rest[(j-i+P)%P]+2*mod)%mod;
         }
     }
//for(int i=0;i<P;++i)
//{
// for(int j=0;j<P;++j)
//  printf("%lld ",mul.ans[i][j]);
// cout<<endl;
//}
 quickmatrix(N);
 for(int i=0;i<P;++i)
   jieguo2=(jieguo2+ans.ans[i][0])%mod;
 jieguo1=(jieguo1-jieguo2+2*mod)%mod;  //容斥：所有情况-一个质数也不含的情况=至少含一个质数的情况
 cout<<jieguo1<<endl;
   return 0;     
}
```

---

## 作者：Planetary_system (赞：1)

## 题面解释：
找出长度为 $n$，每个数之和是 $p$ 的倍数，每个数不超过 $m$ 且有质数的序列个数。

## 思路分析：
正难则反，可以把有质数转换成所有的减去无质数的情况数，这样就可以进行序列型`DP`。设计状态为 $f_{i,j}$ 表示前 $i$ 个数，和对 $p$ 取模为 $j$ 的方案数，最终结果为 $f_{n,0}$。

这样就很好转移了，转移方程：

$$f_{i,j}=\sum_{k=1}^{p-1} f_{i-1,k}\times cnt_{(j-k+p)\mod p}$$

其中 $cnt_i$ 表示 $1$ 到 $m$ 中对 $p$ 取模为 $i$ 的数的个数，所以只要一样的转移方程对是否删去质数的 $cnt$ 做差就好了（这里需要欧拉筛）。

但是，这样只能拿到 $20\%$ 的分数，然后经过观察可以发现，对于每个 $f_{i,j}$ 其实只有 $f_{i-1,k}$ 对他有后效性，而且每次转移过程完全相同，所以我们可以使用一个矩阵优化。

对于每次从 $i-1$ 到 $i$ 的转移，我们建立一个矩阵 $W$。

$$W=\begin{bmatrix}
 cnt_0 & cnt_{p-1} & ... & cnt_1\\
 cnt_1 & cnt_0 & ... & cnt_2\\
 ... & ... & ... & ...\\
 cnt_{p-1} & cnt_{p-2} & ... & cnt_0
\end{bmatrix}$$

然后使用矩阵快速幂，把代码优化成 $ O(p^3\log{n}+m)$。
## Code
```cpp
#include<bits/stdc++.h>
#define int long long 
#define mod 20170408
using namespace std;
int n,p,m,tot,pr[2000010],cnt1[110],cnt2[110];
bool b[20000010];
struct mt{
	int d[110][110];
	mt(){memset(d,0,sizeof(d));}
}w1,w2,o1,o2;
const mt operator *(const mt &a,const mt &b){
	mt c;
	for(int i=0;i<p;i++)
		for(int j=0;j<p;j++)
			for(int l=0;l<p;l++)
				c.d[i][j]=(c.d[i][j]+a.d[i][l]*b.d[l][j]%mod)%mod;
	return c;
}
void init() {
	memset(b,1,sizeof(b));
	b[1]=0;
	for(int i=2; i<=m; i++) {
		if(b[i])pr[++tot]=i;
		for(int j=1; j<=tot&&i*pr[j]<=m; j++) {
			b[i*pr[j]]=0;
			if(i%pr[j]==0)break;
		}
	}
}
signed main(){
	scanf("%lld%lld%lld",&n,&m,&p);
	for(int i=1;i<=m;i++)
		cnt1[i%p]++;
	init();
	for(int i=1;i<=m;i++)
		if(!b[i])cnt2[i%p]++;
	for(int i=0;i<p;i++)
		for(int j=0;j<p;j++)
			w1.d[i][j]=cnt1[(i-j+p)%p],
			w2.d[i][j]=cnt2[(i-j+p)%p];
	for(int i=0;i<p;i++)
		o1.d[i][0]=cnt1[i],
		o2.d[i][0]=cnt2[i];
	int t=n-1;
	while(t){
		if(t&1)o1=w1*o1,o2=w2*o2;
		t>>=1,w1=w1*w1,w2=w2*w2;
	}
	printf("%lld",(o1.d[0][0]-o2.d[0][0]+mod)%mod);
	return 0;
}
```

谢谢！

---

## 作者：_Vix_ (赞：1)

[原题链接](https://www.luogu.com.cn/problem/P3702)

---

## 分析

首先简单容斥，答案就是**所有数**组成序列的方案数减去**非质数**组成序列的方案数。

发现可以分开来 DP。先记下 $all_i$ 表示模 $p$ 为 $i$ 的数的个数，$oup_i$ 表示模 $p$ 为 $i$ 的非质数的个数。用 $f_{i,j}$ 表示选完前 $i$ 个数，选的数和为 $j$ 且选的数是**所有数**的方案数，$g_{i,j}$ 表示选完前 $i$ 个数，选的数和为 $j$ 且选的数是**非质数**的方案数。

枚举第 $i$ 个数选的是 $k$，那么转移是简单的：

$$f_{i,j}=\sum f_{i-1,(j-k+p)\bmod p}\times all_k$$
$$g_{i,j}=\sum g_{i-1,(j-k+p)\bmod p}\times oup_k$$

边界： $f_{0,0}=g_{0,0}=1$，答案就是 $f_{n,0}-g_{n,0}$。

这样子是 $O(np^2)$ 的，显然过不了。

## 优化

观察 DP 式子，发现是矩阵乘法优化 DP 的模样。对于 $f$ 的转移矩阵 $A$，显然有 $A[i][j]=all[(j-i+p)\bmod p]$，$g$ 这边也同理。

时间复杂度来到了 $O(p^3 \log n)$。

## Code
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 110, M = 3e6 + 10, mod = 20170408;
int prime[M], cnt;
int n, m, p, all[N], oup[N];
bool vis[M << 3];

struct Matrix {
	int a[N][N];
	Matrix() {
		memset(a, 0, sizeof a);
	}
	void e() {
		for (int i = 0; i < p; i++) a[i][i] = 1;
	}
	Matrix operator* (Matrix t) {
		Matrix res;
		for (int i = 0; i < p; i++)
			for (int j = 0; j < p; j++)
				for (int k = 0; k < p; k++)
					res.a[i][j] = (res.a[i][j] + 1ll * a[i][k] * t.a[k][j] % mod) % mod;
		return res;
	}
} A, B;

void init(int n) {
	vis[1] = true;
	for (int i = 2; i <= n; i++) {
		if (!vis[i]) prime[++cnt] = i;
		for (int j = 1; j <= cnt && i <= n / prime[j]; j++) {
			vis[i * prime[j]] = true;
			if (i % prime[j] == 0) break;
		}
	}
}

Matrix pwr(Matrix A, int k) {
	Matrix res; res.e();
	while (k) {
		if (k & 1) res = res * A;
		A = A * A;
		k >>= 1;
	}
	return res;
}

int main() {
	scanf("%d%d%d", &n, &m, &p);
	init(m);
	for (int i = 1; i <= m; i++) {
		all[i % p]++;
		if (vis[i]) oup[i % p]++;
	}
	for (int i = 0; i < p; i++)
		for (int j = 0; j < p; j++) {
			A.a[i][j] = all[(j - i + p) % p];
			B.a[i][j] = oup[(j - i + p) % p];
		}
	A = pwr(A, n); B = pwr(B, n);
	int ans = (A.a[0][0] - B.a[0][0] + mod) % mod;
	printf("%d", ans);
	return 0;
}
```


---

## 作者：issue_is_fw (赞：1)

[传送门](https://www.luogu.com.cn/problem/P3702)

首先容易想到容斥

先算用任意数满足条件,再算只用和数满足条件

相减就是答案.

令$f[i][j]$表示前$i$个数模$p$为$j$的方案数

预处理一个数组$v[i]$表示小于$m$的数中对$p$求余为$i$的个数

那么$f[i][j]=\sum\limits_kf[i-1][k]*v[(j+p-k)\%p]$

那么发现每个转移都一样,可以用矩阵快速幂来优化

初始矩阵是$chu1=[1,0,0,0,0,0,0...]$

构造矩阵$all$是

$$
\begin{bmatrix}
over_0&over_1&over_2...&over_{p-1}\\
over_{p-1}&over_0&over_1...&over_{p-2}\\
.....&.......&........&.......\\
over_1&over_{2}&over_3...&over_{0}
\end{bmatrix}
$$

其中$over_i$表示小于等于$m$的数模$p$余$i$的有几个

然后算只用合数的合法方案也是一样的,就把$over_i$换一下即可

这样,矩阵快速幂$chu_1*all^n$

最左侧的元素就是答案

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxm = 2e7+10;
const int maxn = 2e6+10;
const int mod = 20170408;
int n,m,p,prime[maxn],top,over[109],even[109];
bool vis[maxm];
void make_prime()
{
	for(int i=2;i<=maxm;i++)
	{
		if( !vis[i] )	prime[++top] = i;
		for(int j=1;j<=top&&prime[j]*i<=maxm;j++)
		{
			vis[prime[j]*i] = 1;
			if( i%prime[j]==0 )	break;
		}
	}
	vis[1] = 1;
	for(int i=1;i<=m;i++)
		over[i%p]++, even[i%p]+=vis[i];
}
struct rce{
	ll m[109][109];
	rce(){ memset( m,0,sizeof m); }
};
rce init()
{
	rce ans;
	for(int i=0;i<=p-1;i++)	ans.m[i][i]=1;
	return ans;
}
rce operator * (rce a,rce b)
{
	rce ans;
	for(int i=0;i<=p-1;i++)
	for(int j=0;j<=p-1;j++)
	{
		for(int k=0;k<=p-1;k++)
			ans.m[i][j] = ( ans.m[i][j]+a.m[i][k]*b.m[k][j]%mod )%mod;		
	}
	return ans;
}
rce quick(rce x,int n)
{
	rce ans = init();
	for( ; n ; n>>=1,x=x*x )
		if( n&1 )	ans = ans*x;
	return ans;
}
int main()
{
	cin >> n >> m >> p;
	make_prime();
	rce all,he;
	for(int i=0,start=0;i<=p-1;i++,start--)//枚举每一行 
	{
		if( start<0 )	start+=p;
		for(int j=0,now=start;j<=p-1;j++,now=(now+1)%p)
		{
			all.m[i][j] = over[now];//所有的数字
			he.m[i][j] = even[now];
		}
	}
	rce chu1,chu2;
	chu1.m[0][0]=1,chu2.m[0][0]=1;
	chu1 = chu1*quick(all,n), chu2 = chu2*quick(he,n);
	cout << ((chu1.m[0][0]-chu2.m[0][0])%mod+mod)%mod;
}
```

---

## 作者：yangshurong (赞：1)

用f[i][j]表示长度为i的序列，这个序列的和%p为j。然后立马得到转移：

**f[i][j]=sum(x,0,j){f[i>>1][x]*f[i>>1][y]}**

一看是个标准的卷积。
然后就可以跑多项式相乘了。

提前预处理：
因为还要考虑到必须要有质数的情况，因此可以用容斥：
**全部的**减去**没有质数的**

全部的：枚举m里每一个数，然后记录：f[1][j%p].
没有质数的同理。

然后多项式快速幂相乘。
多项式相乘的话：p很小，可以直接暴力相乘。
这是一份暴力相乘的代码：
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<stack>
#include<algorithm>
#include<cstring>
#include<vector>
#include<ctime>
#include<map>
#include<cstdlib>
#include<cmath>
#define r(i,a,b) for(int i=a;i<=b;i++)
#define rr(i,a,b) for(int i=a;i>=b;i--)
#define inf 0x3f3f3f3f
#define mem(a) memset(a,0x3f,sizeof(a))
#define re(a) a=read()
#define pr(a) printf("%d\n",a)
#define me(a) memset(a,0,sizeof(a))
#define in inline
#define ll long long
#define db double
using namespace std;
const int N=507;
const int md=20170408;
const int M=sqrt(md);
const int NN=2e7+7;
const db pi=acos(-1.0);
inline int read(){
	char ch=getchar();
	int w=1,x=0;
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0',ch=getchar();}
	return x*w;
}
bool vis[NN];
int n,m,p,tot=0,nop[N],all[N],pri[NN];
in void init(){
	me(vis),me(nop),me(all);
	vis[1]=1;
	r(i,2,m){
		pri[++tot]=i;
		for(int j=1;j<=tot&&pri[j]*i<=m;j++){
			vis[pri[j]*i]=1;
			if(i%pri[j]==0)break;
		}
	}
	r(i,1,m){
		all[i%p]++;
		if(vis[i])nop[i%p]++;
	}
}
in void deal(int *a,int *b,int *res){
	static int tmp[N];
	me(tmp);
	r(i,0,p-1){
		r(j,0,p-1){
			tmp[(i+j)%p]=(tmp[(i+j)%p]+1ll*a[i]*b[j]%md)%md;
		}
	}
	r(i,0,p-1)res[i]=tmp[i];
}
in void mul(int *a,int b){
	b--;
	static int res[N];
	r(i,0,p-1)res[i]=a[i];
	for(;b;b>>=1,deal(a,a,a))if(b&1)deal(res,a,res);
	r(i,0,p-1)a[i]=res[i];
}
int main(){
	re(n),re(m),re(p);
	init();
	mul(nop,n),mul(all,n);
	printf("%d\n",(all[0]-nop[0]+md)%md);
	return 0;
}



```
当然用FFT也可以。

设h[i]表示两个多项式相乘后，的结果多项式，的第i项的系数（帮语文不好的断一下句）
此时别忘了将h[i+p]加到h[i]上：
h[i]+=h[i+p].

这样做后依然能得到正确结果的原因是：
i的范围已知是小于p的，
此时i=(i+p)%p

然后就可以直接写FFT了。

```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<stack>
#include<algorithm>
#include<cstring>
#include<vector>
#include<ctime>
#include<map>
#include<cstdlib>
#include<cmath>
#define r(i,a,b) for(int i=a;i<=b;i++)
#define rr(i,a,b) for(int i=a;i>=b;i--)
#define inf 0x3f3f3f3f
#define mem(a) memset(a,0x3f,sizeof(a))
#define re(a) a=read()
#define pr(a) printf("%d\n",a)
#define me(a) memset(a,0,sizeof(a))
#define in inline
#define ll long long
#define db double
using namespace std;
const int N=507;
const int md=20170408;
const int M=sqrt(md);
const int NN=2e7+7;
const db pi=acos(-1.0);
inline int read(){
	char ch=getchar();
	int w=1,x=0;
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0',ch=getchar();}
	return x*w;
}
bool vis[NN];
int n,m,p,tot=0,nop[N],all[N],pri[NN],limit=1,cnt=0,inv[N];
struct node{db x,y;}w[N],a1[N],a2[N],b1[N],b2[N];
node operator*(node a,node b){return (node){a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x};}
node operator+(node a,node b){return (node){a.x+b.x,a.y+b.y};}
node operator-(node a,node b){return (node){a.x-b.x,a.y-b.y};}
in void init(){
	me(vis),me(nop),me(all);
	vis[1]=1;
	r(i,2,m){
		pri[++tot]=i;
		for(int j=1;j<=tot&&pri[j]*i<=m;j++){
			vis[pri[j]*i]=1;
			if(i%pri[j]==0)break;
		}
	}
	r(i,1,m){
		all[i%p]++;
		if(vis[i])nop[i%p]++;
	}
}
in void ftt(node *t,int type){
	r(i,0,limit-1){
		if(i<inv[i])swap(t[i],t[inv[i]]);
	}
	for(int mid=1;mid<limit;mid<<=1){
		for(int R=mid<<1,j=0;j<limit;j+=R){
			r(k,0,mid-1){
				node wn=(node){w[limit/mid*k].x,w[limit/mid*k].y*type};
				node x=t[j+k],y=wn*t[j+k+mid];
				t[j+k]=x+y,t[j+k+mid]=x-y;
			}
		}
	}
	if(type==1)return;
	r(i,0,limit-1)t[i].x/=1.0*limit;
}
in void deal(int *a,int *b,int *res){
	r(i,0,limit)a1[i]=a2[i]=b1[i]=b2[i]=(node){0,0};
	r(i,0,p-1){
		a[i]%=md,b[i]%=md;
		a1[i].x=1.0*(a[i]/M);
		b1[i].x=1.0*(a[i]%M);
		a2[i].x=1.0*(b[i]/M);
		b2[i].x=1.0*(b[i]%M);
	}
	ftt(a1,1),ftt(a2,1),ftt(b1,1),ftt(b2,1);
	r(i,0,limit-1){
		node tmp1=a1[i]*a2[i],tmp2=b1[i]*b2[i];
		a1[i]=a1[i]*b2[i],a2[i]=a2[i]*b1[i];
		a2[i]=a1[i]+a2[i];
		a1[i]=tmp1,b1[i]=tmp2;
	}
	ftt(a1,-1),ftt(a2,-1),ftt(b1,-1);
	static int tmp[N];
	r(i,0,(p-1)<<1){
		tmp[i]=0;
		tmp[i]=(tmp[i]+1ll*(ll)(a1[i].x+0.5)%md*M%md*M%md)%md;
		tmp[i]=(tmp[i]+1ll*(ll)(a2[i].x+0.5)%md*M%md)%md;
		tmp[i]=(tmp[i]+1ll*(ll)(b1[i].x+0.5)%md)%md;
		tmp[i]=(tmp[i]+md)%md;
	}
	r(i,0,p-1)res[i]=(tmp[i]+tmp[i+p])%md;
}
in void mul(int *a,int b){
	b--;
	static int res[N];
	r(i,0,p-1)res[i]=a[i];
	for(;b;b>>=1,deal(a,a,a))if(b&1)deal(res,a,res);
	r(i,0,p-1)a[i]=res[i];
}
int main(){
	re(n),re(m),re(p);
	init();
	while(limit<=(p<<1))limit<<=1,cnt++;
	r(i,0,limit-1)inv[i]=(inv[i>>1]>>1)|((i&1)<<(cnt-1));
	for(int i=1;i<=limit;i<<=1){
		r(k,0,i-1)w[limit/i*k]=(node){cos(pi*k/i),sin(pi*k/i)};
	}
	mul(nop,n),mul(all,n);
	printf("%d\n",(all[0]-nop[0]+md)%md);
	return 0;
}



```
~~只不过这FFT跑的比暴力要慢~~
~~谁让虚数的运算慢的~~

不过如果本题数据范围变成1<p<=1e5
那结果就不一样了，~~暴力直接去死把~~
但考场上还是能打暴力打暴力，~~尽量少用高级算法~~

另说一句:如果模数是质数，那最好用NTT，这个可不是一般的快，p<=1e5的话......

---

## 作者：mrclr (赞：1)

这题有那么难？？？？

~~提供一个吊打std的做法~~

直接令$dp[i][j][0/1]$表示前$i$个数的和模$p$为$j$，且这$i$个数中没有/有质数的方案数。
先想一下暴力，枚举第$i$个数是哪一个，然后根据这个数是否是质数转移即可。复杂度$O(nmp)$。

优化：
发现$n \leqslant 10 ^ 9$，就能想到多项式快速幂，转移的时候分四种情况讨论。因为$p$很小，暴力乘就能过，复杂度$O(m +  p^ 2 logn)$（$O(m)$是筛质数复杂度）。

这&emsp;题&emsp;就&emsp;没&emsp;了。

（真的希望有更多的人能看到这个简单的做法）
```c++
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<cstdlib>
#include<cctype>
#include<queue>
#include<vector>
#include<ctime>
#include<assert.h>
using namespace std;
#define enter puts("")
#define space putchar(' ')
#define Mem(a, x) memset(a, x, sizeof(a))
#define In inline
#define forE(i, x, y) for(int i = head[x], y; (y = e[i].to) && ~i; i = e[i].nxt)
typedef long long ll;
typedef double db;
const int INF = 0x3f3f3f3f;
const db eps = 1e-8;
const int maxs = 105;
const int maxm = 2e7 + 5;
const int maxp = 105;
const ll mod = 20170408; 
In ll read()
{
	ll ans = 0;
	char ch = getchar(), las = ' ';
	while(!isdigit(ch)) las = ch, ch = getchar();
	while(isdigit(ch)) ans = (ans << 1) + (ans << 3) + ch - '0', ch = getchar();
	if(las == '-') ans = -ans;
	return ans;
}
In void write(ll x)
{
	if(x < 0) putchar('-'), x = -x;
	if(x >= 10) write(x / 10);
	putchar(x % 10 + '0');
}
In void MYFILE()
{
#ifndef mrclr
	freopen("ha.in", "r", stdin);
	freopen("ha.out", "w", stdout);
#endif
}

int n, m, p;

In ll inc(ll a, ll b) {return a + b < mod ? a + b : a + b - mod;}

int prm[maxm], v[maxm];
In void init()
{
	for(int i = 2; i < maxm; ++i)
	{
		if(!v[i]) v[i] = i, prm[++prm[0]] = i;
		for(int j = 1; j <= prm[0] && i * prm[j] < maxm; ++j)
		{
			v[i * prm[j]] = prm[j];
			if(i % prm[j] == 0) break;
		}
	}
}

ll f[maxp][2], g[maxp][2], c[maxp][2];
In void mul(ll a[][2], ll b[][2], bool flg)
{
	Mem(c, 0);
	for(int i = 0; i < p; ++i)
		for(int j = 0; j < p; ++j)
		{
			int t = i + j < p ? i + j : i + j - p;
			c[t][0] = inc(c[t][0], a[i][0] * b[j][0] % mod);
			c[t][1] = inc(c[t][1], a[i][1] * b[j][0] % mod);
			c[t][1] = inc(c[t][1], a[i][0] * b[j][1] % mod);
			c[t][1] = inc(c[t][1], a[i][1] * b[j][1] % mod);
		}
	memcpy(a, c, sizeof(c));
}
In ll Quickpow(int n)
{
	f[0][0] = 1;
	for(int i = 1; i <= m; ++i) ++g[i % p][v[i] == i];
	for(; n; n >>= 1, mul(g, g, 0))
		if(n & 1) mul(f, g, 1);
	return f[0][1];
}

int main()
{
//	MYFILE();
	init();
	n = read(), m = read(), p = read();
	write(Quickpow(n)), enter;
	return 0;
}
```

---

## 作者：GoldenPotato137 (赞：1)


~~不是很会用Markdown,请大家见谅~~

非markdown排版地址:[戳我传送](http://www.cnblogs.com/GoldenPotato/p/8810695.html)

------------


看到这道题,我们不妨先考虑一下20分怎么搞

想到暴力,本蒟蒻第一反应就是dfs,想法也很简单:

枚举n个数中的每一个数,枚举完每一种情况都判断一下是否满足要求

复杂度**O（n^m）**


显然,这样的复杂度一分都得不到,但是可以作为对拍用的暴力程序

 
 

------------


既然dfs行不通了,那我们换个想法吧,考虑一下用dp来搞这个问题

设 f[i][j] 表示选到第i个数,前i个数的总和%p为j

转移也很好写

我们枚举一下上一个数字是啥就好


#### f[i][j]= sigma f[i-1][((j-k)%p+p)%p]   k:[1,m] i:[1,n] j:[0,p-1] 

注意一下: j-k有可能是负数,所以要用负数取模的方法

初始化 **f[0][0]=1** (没有数字时,仅有总和为0的情况有一种可行方法)

题目要求的有质数用一个简单的容斥就可以了

我们再做一个没有质数的dp,转移方程跟上面一样,仅需要保证 k 不为质数就行

最后将两者的i为n,j为0的状态相减就是最后答案了.

时间复杂度 **O(n*p*m)**,20分

 

------------


接下来,我们可以考虑一个很妙的优化

我们发现上面的转移方程

f[i][j]= sigma f[i][((j-k)%p+p)%p]   k:[1,m]

i:[1,n] j:[0,p-1] 

**j是从0~p-1的,而k是从1~m的**

这说明了,f[i-1][j]中的某些项是会**重复计算**到下一个状态的

这样子,我们可以考虑做一个预处理,减少重复计算造成的时间的浪费

考虑这样做:

我们通过一个O(m)的预处理,计算出每一个从0~p-1的数可能从多少个1~m中的数%p计算而得

用一个tot[k]存储下来,tot[k]的意义为:1~m的数%p为k的有多少个

那么这样子,我们的转移方程可优化成这样子

#### f[i][j]= sigma f[i][((j-k)%p+p)%p]*tot[k]   k:[0,p-1]

#### i:[1,n] j:[0,p-1] 

因为 (j-k)%p = j%p - k%p;

所以说,每一个f[i-1][j%p - k%p]被算的次数仅与有多少个 K1%p=K2%p=K3%p=....有关

我们可以设K1%p=K2%p=K3%p=...=y

原式就可以变为f[i][j]=sigma f[i][j%p-y]*tot[y] 

而tot[y]已在前面的预处理解决了

这样,时间复杂度就成功的降为了:**O(np^2)
**

~~然而并没有什么卵用,因为出题者并没有设计这一档的分~~
 

我们再考虑一个优化

f[i][j]= sigma f[i][((j-k)%p+p)%p]*tot[k]   k:[0,p-1]

i:[1,n] j:[0,p-1] 

原转移式是不是有一个特征?对,那就是式子是固定死的,这意味着我们可以用矩阵优化至**O(p^3log n)**

这种类型的转移矩阵我称为"一层层"的转移,可以考虑这样列转移矩阵

![转移矩阵](https://cdn.luogu.com.cn/upload/pic/17319.png)



然后就OK啦


------------
#### 以及写得很丑的Code
```cpp
//Luogu P3702 [SDOI2017]序列计数
//Apr,11th,2018
//矩阵加速DP
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
long long read()
{
	long long x=0,f=1; char c=getchar();
	while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
	while(isdigit(c)){x=x*10+c-'0';c=getchar();}
	return x*f;
}
const int P=100+10;
const int M=20000000+100;
const int poi=20170408;
struct MAT
{
	int x,y;
	long long a[P][P];
	MAT (int tx,int ty)
	{
		x=tx,y=ty;
		memset(a,0,sizeof a);
	}
	friend MAT operator * (MAT A,MAT B)
	{
		MAT ans=MAT(B.x,A.y);
		for(int i=1;i<=ans.y;i++)
			for(int j=1;j<=ans.x;j++)
				for(int k=1;k<=A.x;k++)
				{
					ans.a[i][j]+=A.a[i][k]*B.a[k][j];
					if(ans.a[i][j]>=poi) ans.a[i][j]%=poi;
				}
		return ans;
	}
};
MAT FastPow(MAT a,int b)
{
	if(b==1) return a;
	MAT ans=FastPow(a,b/2);
	ans=ans*ans;
	if(b%2==1) ans=ans*a;
	return ans;
}
int n,m,p,tot[P];
bool IsPrime[M];
int prime[M],p_tot;
void GetPrime()
{
	memset(IsPrime,1,sizeof IsPrime);
	IsPrime[0]=IsPrime[1]=0;
	for(int i=2;i<=m;i++)
	{
		if(IsPrime[i]==true) prime[++p_tot]=i;
		for(int j=1;j<=p_tot and prime[j]*i<=m;j++)
		{
			IsPrime[prime[j]*i]=false;
			if(i%prime[j]==0) break;
		}
	}
}
int main()
{
	n=read(),m=read(),p=read();
	
	for(int i=1;i<=m;i++)
		tot[i%p]++;
	GetPrime();
	MAT A=MAT(p,p);
	for(int i=1;i<=p;i++)
		for(int j=1;j<=p;j++)
			A.a[i][j]=tot[((i-j)%p+p)%p];
	MAT B=MAT(1,p);
	for(int i=1;i<=p;i++)
		B.a[i][1]=tot[i-1];
	long long ans=(FastPow(A,n-1)*B).a[1][1];
	
	memset(tot,0,sizeof tot);
	for(int i=1;i<=m;i++)
		if(IsPrime[i]==false)
			tot[i%p]++;
	for(int i=1;i<=p;i++)
		for(int j=1;j<=p;j++)
			A.a[i][j]=tot[((i-j)%p+p)%p];
	for(int i=1;i<=p;i++)
		B.a[i][1]=tot[i-1];
	ans-=(FastPow(A,n-1)*B).a[1][1];
	
	printf("%lld",(ans%poi+poi)%poi);
	return 0;
}

```



---

## 作者：zhoumurui (赞：0)

## 前置知识

动态规划

[矩阵快速幂](https://www.luogu.com.cn/problem/solution/P3390)

[矩阵快速幂加速递推](https://www.luogu.com.cn/problem/solution/P1962)

## 题面展示

求满足下列条件的数列的数量：

- 长度为 $n$；
- 每个数均为正整数，且在 $[1,m]$ 区间内。
- 所有数的和是 $p$ 的倍数。
- 数列中有至少一个质数。

## 题目思路

数据范围中 $n \le 10^9$，似乎难以下手，让我们先从朴素做法入手。

容易想到动态规划。

**设计状态：**

设 $f_{i,j}$ 为满足下列条件的数列的数量：
- 长度为 $i$；
- 每个数均为正整数，且在 $[1,m]$ 区间内；
- 所有数的和在模 $p$ 意义下同余于 $j$。

设 $g_{i,j}$ 为满足下列条件的数列的数量：
- 长度为 $i$；
- 每个数均为正整数，且在 $[1,m]$ 区间内；
- 所有数的和在模 $p$ 意义下同余于 $j$；
- 区间中没有质数。

显然，我们想要的答案是 $f_{n,0} - g_{n,0}$。

**初始状态：**

$f_{1,i} = \sum \limits_{k=1}^m [k \equiv i]  \pmod p$

$g_{1,i} = \sum \limits_{k=1}^m [k \notin \mathbb P][k \equiv i] \pmod p$

这两个式子由定义就可以得到：

我们取第一个数，显然直接取一个模 $p$ 同余于 $i$ 的整数不就好了。



**状态转移：**

以 $f_{i,j}$ 的转移为例，假设我们把前 $i-1$ 位都处理好了，我们第 $i$ 位显然要放一个 $[1,m]$ 中的正整数，放的数称为 $k$。

那么既然我们放了一个 $k$ 以后，数列之和模 $p$ 的值变成了 $j$，那么前 $i-1$ 位之和模 $p$ 的值必然是 $(j-k)\mod p$。

（因为 $j-k$ 可能是负数，代码里需要写成 `((j-k)%p+p)%p`。）

因此我们就可以得出转移方程：

$$f_{i,j}=  \sum \limits_{k=1}^m f_{i-1,(j-k)\mod p}$$

同理地 $g_{i,j}$ 的转移方程是：

$$g_{i,j}=  \sum \limits_{k=1}^m [k \notin \mathbb P]g_{i-1,(j-k)\mod p}$$

这样朴素地 dp 可以得到 $20$ 分。

**优化1：**

（这个优化不能多拿分，它的目的是方便后续处理）

注意到当 $m$ 远大于 $p$ 时，$f_{i-1,x}$ 会在数组中出现很多次，我们可以将它们整合起来。

我们可以预处理出：

$\text{total}_i = \sum \limits_{k=1}^m [k \equiv i] \pmod p$

$\text{compo}_i = \sum \limits_{k=1}^m [k \notin \mathbb P][k \equiv i] \pmod p$

$\text{total}_i$ 的意义为：$[1,m]$ 的整数中，模 $p$ 余 $i$ 的数的数量。

$\text{compo}_i$ 的意义为：$[1,m]$ 的整数中，模 $p$ 余 $i$ 的**非质数**的数量。

这两个数组预处理起来比较方便，预处理完以后，状态转移方程可以变成下面这个看着更舒服的样子：

$$f_{i,j}=  \sum \limits_{k=0}^{p-1} f_{i-1,k} \times \text{total}_{(j-k)\mod p}$$

$$g_{i,j}=  \sum \limits_{k=0}^{p-1} g_{i-1,k} \times  _{(j-k)\mod p}$$

当然初始状态也简化了，非常清爽：

$f_{1,i} = \text{total}_i$

$g_{1,i} = \text{compo}_i$

没反应过来的可以往前翻初始状态，和两个数组的定义对照一下。

**优化2：**

由于 $n$ 实在是太大了，我们不禁可以联想到**矩阵快速幂加速递推**。当然这里应该叫**矩阵快速幂加速** **dp** 了。

首先，我们形象地把 $f$ 数组和 $g$ 数组的每一行形象地转化成一个行向量（现阶段我们可以这样形象地理解：行向量就是只有 $1$ 行的矩阵）：

定义 $F_i = \begin{bmatrix} f_{i,0} & f_{i,1} & \dots & f_{i,p-1} \end{bmatrix}$，

$G_i = \begin{bmatrix} g_{i,0} & g_{i,1} & \dots & g_{i,p-1} \end{bmatrix}$。

接下来，我们可以变形一下状态转移方程，将数组 $\text{total}$ 和 $\text{compo}$ 都变成矩阵，顺便下标里的 $(j-k)\mod p$ 没了，转移方程也会更加清爽：

定义 $\text{Total}_{i,j} = \text{total}_{(j-i) \mod p}$，

$\text{Compo}_{i,j} = \text{compo}_{(j-i) \mod p}$。

这样以后，我们就可以重新梳理 dp 的初始状态了：

$$F_1 = \begin{bmatrix} \text{total}_0 & \text{total}_1 & \dots & \text{total}_{p-1} \end{bmatrix}$$

$$G_1 = \begin{bmatrix} \text{compo}_0 & \text{compo}_1 & \dots & \text{compo}_{p-1} \end{bmatrix}$$

转移方程方面，我们先整理一下原方程：

$$f_{i,j}=  \sum \limits_{k=0}^{p-1} f_{i-1,k} \times \text{Total}_{k,j}$$

$$g_{i,j}=  \sum \limits_{k=0}^{p-1} g_{i-1,k} \times  \text{Compo}_{k,j}$$

这不就是矩阵乘法的公式吗！

用矩阵的方法写就是这个令人舒适的式子了：

$$F_i=  F_{i-1} \times \text{Total}$$

$$G_i= G_{i-1} \times  \text{Compo}$$

矩阵的通项公式是：

$$F_n=  F_{1} \times \text{Total}^{n-1}$$

$$G_n= G_{1} \times  \text{Compo}^{n-1}$$

最后别忘了我们要的是什么：$f_{n,0} - g_{n,0}$，它们分别就是 $F_n$ 和 $G_n$ 的首项。

## 核心代码展示

- 矩阵 & 快速幂

```cpp
struct Matrix{
    int a[105][105];
    Matrix(){memset(a,0,sizeof(a));}
    int* operator [](int index){
        return a[index];
    }
    Matrix operator *(Matrix b){
        Matrix ans;
        for (int i=0;i<100;i++){
            for (int j=0;j<100;j++){
                for (int k=0;k<100;k++){
                    ans[i][j]+=a[i][k]*b.a[k][j]%M;
                    ans[i][j]%=M;
                }
            }
        }
        return ans;
    }
}F,G,T,C;

Matrix qpow(Matrix a,int b){
    if (b==1)return a;
    if (b&1)return qpow(a,b^1)*a;
    Matrix tmp=qpow(a,b>>1);
    return tmp*tmp;
}
```

- 预处理

```cpp
void init(){
    //预处理出质数
    for (int i=2;i<=m;i++){
        ispr[i]=true;
    }
    for (int i=2;i<=m;i++){
        if (ispr[i]){
            for (int j=i*i;j<=m;j+=i){
                ispr[j]=false;
            }
            //if (i>=100000)cout<<i<<" "<<i*i<<endl;
        }
    }
    for (int i=1;i<=m;i++){
        ++total[i%p];
        if (!ispr[i])++compo[i%p];
    }
}
void initMatrix(){
    for (int i=0;i<p;i++){
        for (int j=0;j<p;j++){
            T[i][j]=total[(j-i+p)%p];
            C[i][j]=compo[(j-i+p)%p];
        }
        F[0][i]=total[i];
        G[0][i]=compo[i];
    }
}
```

- 主函数

```
cin>>n>>m>>p;
init();
initMatrix();
if (n==1)cout<<(F[0][0]-G[0][0]+M)%M<<endl;
if (n>=1)cout<<((F*qpow(T,n-1))[0][0]-(G*qpow(C,n-1))[0][0]+M)%M<<endl;
return 0;

---

## 作者：qczrz6v4nhp6u (赞：0)

### Solution

首先是经典容斥，将【至少一个质数出现】转化为【无限制】减【无质数出现】。

然后考虑 DP。设 $f_{i,j}$ 表示前 $i$ 个数，$(\sum_{1\le k\le i}a_k)\bmod p=j$ 的方案数，设 $g_i$ 表示 $[1,n]$ 中合法且 ${}\bmod p=i$ 的方案数。有转移：

$$f_{i,j}=\sum_{k=0}^{p-1}f_{i-1,(j-k)\bmod p}\times g_k$$

不难发现 $f_i$ 为 $f_{i-1}$ 和 $g$ 的循环卷积。设 $F_i(z)=\sum_{j=0}^{p-1}f_{i,j}z^j$，$G(z)=\sum_{i=0}^{p-1}g_iz^i$，有：

$$F_i(z)=G^i(z)\bmod(x^p-1)$$

朴素的多项式快速幂求模可以做到 $O(p^2\log n)$，使用 FFT/MTT 可以做到 $O(p\log p\log n)$。

### Code

$O(p^2\log n)$ 的实现。跑得飞快，目前是本题最优解（237ms）。

```cpp
#include<bits/stdc++.h>
#include<bits/extc++.h>
using namespace std;
using ui=unsigned int;
using ll=long long;
using ull=unsigned long long;
using i128=__int128;
using u128=__uint128_t;
using pii=pair<int,int>;
constexpr int N=2e7+5,P=105,mod=20170408;
int n,p,m;
int pri[N],plen;bool v[N];
void sieve(int n){
	for(int i=2;i<=n;i++){
		if(!v[i])pri[++plen]=i;
		for(int j=1;i*pri[j]<=n;j++){
			v[i*pri[j]]=1;
			if(i%pri[j]==0)break;
		}
	}
}
ll f[P],g[P],h[P];
void Mul(ll *f,ll *g,int n){
	memset(h,0,sizeof h);
	for(int i=0;i<n;i++)
		for(int j=0;j<n;j++)
			h[(i+j)%n]=(h[(i+j)%n]+f[i]*g[j])%mod;
	memcpy(f,h,sizeof h);
}
void Pow(ll *f,int n,int k){
	memset(g,0,sizeof g);g[0]=1;
	for(;k;k>>=1,Mul(f,f,n))
		if(k&1)Mul(g,f,n);
	memcpy(f,g,sizeof g);
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n>>m>>p;
	sieve(m);
	for(int i=0;i<p;i++)f[i]=((m-i)/p+(i&&i<=m))%mod;
	Pow(f,p,n);
	ll w1=f[0];
	for(int i=0;i<p;i++)f[i]=((m-i)/p+(i&&i<=m))%mod;
	for(int i=1;i<=plen;i++)f[pri[i]%p]=(f[pri[i]%p]-1+mod)%mod;
	Pow(f,p,n);
	ll w2=f[0];
	cout<<(w1-w2+mod)%mod<<'\n';
	return 0;
}
```

---

## 作者：封禁用户 (赞：0)

分析：

　　首先可以容斥掉，用总的减去一个质数也没有的。

　　然后可以 ```dp``` 了，$f[i][j]$ 表示到第 $i$ 个数，和在模 $p$ 下是 $j$ 的方案数，矩阵快速幂即可。

　　另一种方法：设 $T[1]$ 是一个生成函数，为选了一个数，和在模 $p$ 是多少的的方案数，那么 $T[1]\cdot T[1]$ 即选了 $2$ 个的方案数，这是一个卷积的形式，但是 $p$ 特别小，直接暴力计算即可，然后外面套上快速幂。

```
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<iostream>
#include<cmath>
#include<cctype>
#include<set>
#include<queue>
#include<vector>
#include<map>
using namespace std;
typedef long long LL;

inline int read() {
    int x=0,f=1;char ch=getchar();for(;!isdigit(ch);ch=getchar())if(ch=='-')f=-1;
    for(;isdigit(ch);ch=getchar())x=x*10+ch-'0';return x*f;
}

const int N = 20000005, mod = 20170408;
int pri[N], n, m, p, tot;
bool nopri[N];

struct Poly{
    int a[105];
    Poly() { memset(a, 0, sizeof(a)); }
}A, B;
Poly operator * (const Poly &A, const Poly &B) {
    Poly C;
    for (int i = 0; i < p; ++i) 
        for (int j = 0; j < p; ++j) 
            (C.a[(i + j) % p] += (1ll * A.a[i] * B.a[j]) % mod) %= mod;
    return C;
}
void init(int n) {
    nopri[1] = true;
    for (int i = 2; i <= n; ++i) {
        if (!nopri[i]) pri[++tot] = i;
        for (int j = 1; j <= tot && pri[j] * i <= n; ++j) {
            nopri[i * pri[j]] = true;
            if (i % pri[j] == 0) break;
        }
    }
}
Poly ksm(Poly A,int b) {
    Poly res = A; b --;
    while (b) {
        if (b & 1) res = res * A;
        A = A * A;
        b >>= 1;
    }
    return res;
}
int main() {
    n = read(), m = read(); p = read();
    init(m);
    for (int i = 1; i <= m; ++i) {
        A.a[i % p] ++;
        if (nopri[i]) B.a[i % p] ++;
    }
    A = ksm(A, n); B = ksm(B, n);
    cout << (A.a[0] - B.a[0] + mod) % mod;
    return 0;
}
```

---

## 作者：cirnovsky (赞：0)

### Description

Alice 想要得到一个长度为 $n$ 的序列，序列中的数都是不超过 $m$ 的正整数，而且这 $n$ 个数的和是 $p$ 的倍数。


Alice 还希望，这 $n$ 个数中，至少有一个数是质数。


Alice 想知道，有多少个序列满足她的要求。

### Analysis

一个复杂度 $O(p^{2}\log_{2}n+m)$ 的 rubbish 做法。

首先肯定把答案序列放在模 $p$ 意义下。

然后给出原问题的生成函数：$G(x)$ 的 $x^{i}$ 系数为 $n=1$ 时 $\bmod p=i$ 的答案，然后 $G^{n}(x)$ 就为答案的生成函数了。

由于这题的 $p$ 小飞了所以直接暴力乘法即可连 NTT 都不用……

```cpp
#include <cstdio>
#include <cstring>
#define mod ( 20170408 )

typedef long long LL;

const int MAXM = 2e7 + 5, MAXP = 100 + 5;

int add ( const int a, const int b, const int p ) { return a + b < p ? a + b : a + b - p; }
int sub ( const int a, const int b, const int p ) { return a - b < 0 ? a - b + p : a - b; }
int mul ( const LL a, const LL b, const int p ) { return a * b % p; }

struct Poly { int as[MAXP]; Poly () { memset ( as, 0, sizeof ( as ) ); } } ar, ia;

int n, m, p;
bool tag[MAXM];

Poly times ( const Poly a, const Poly b ) {
	Poly ret;
	for ( int i = 0; i < p; ++ i ) {
		for ( int j = 0; j < p; ++ j )	ret.as[(i + j) % p] = add ( ret.as[(i + j) % p], mul ( a.as[i], b.as[j], mod ), mod );
	}
	return ret;
}

void sieve ( const int L ) {
	static int pSet[MAXM], psc;
	tag[1] = 1;
	for ( int i = 2; i <= L; ++ i ) {
		if ( ! tag[i] )	pSet[++ psc] = i;
		for ( int j = 1; j <= psc && ( LL )i * pSet[j] <= L; ++ j ) {
			tag[i * pSet[j]] = 1;
			if ( i % pSet[j] == 0 )	break;
		}
	}
}

Poly cpow ( Poly bas, int idx ) {
	Poly res = bas;
	while ( idx ) {
		if ( idx & 1 )	res = times ( res, bas );
		if ( idx >>= 1 )	bas = times ( bas, bas );
	}
	return res;
}

int main () {
	scanf ( "%d%d%d", &n, &m, &p ), sieve ( m );
	for ( int i = 1; i <= m; ++ i ) {
		ar.as[i % p] ++;
		if ( tag[i] )	ia.as[i % p] ++;
	}
	printf ( "%d\n", sub ( cpow ( ar, n - 1 ).as[0], cpow ( ia, n - 1 ).as[0], mod ) );
	return 0;
}
```

---

## 作者：crashed (赞：0)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.com.cn/problem/P3702)看题目。  
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;直接计算答案的话很难，所以考虑计算全部方案之后减去不合法的方案，也就是只有合数的方案。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然可以使用$DP$解决这样的问题。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$f(i,j)$：长度为$i$的数列中满足和模$p$为$j$的**总数量**。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$g(i,j)$：长度为$i$的数列中满足和模$p$为$j$且**数字全为合数总数量**。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设$P$为质数集。预处理出$h(i)=\sum_{j=1}^m[j\equiv i\mod p],q(i)=\sum_{j=1}^m[j\equiv i\mod p\land j\not\in P]$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;转移即为：  
$$f(i,j)=\sum_{k=0}^ph((j-k)\mod p)f(i-1,k)$$  
$$g(i,j)=\sum_{k=0}^pq((j-k)\mod p)g(i-1,k)$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;暴力做是$O(np^2)$的，铁定超时。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑$DP$优化。以下有三种方法：  
### 矩阵加速  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看到$p$很小而$n$很大，我们便想到了矩阵加速的做法。以$f$的转移为例，构造初始矩阵为：  
$$\begin{bmatrix}f(0)\\f(1)\\f(2)\\\vdots\\f(p-1)\end{bmatrix}$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;转移矩阵为：  
$$\begin{bmatrix}h(0)&h(1)&h(2)&\dots&h(p-1)\\h(p-1)&h(0)&h(1)&\dots&h(p-2)\\h(p-2)&h(p-1)&h(0)&\dots&h(p-3)\\\vdots&\vdots&\vdots&\ddots&\vdots\\h(1)&h(2)&h(3)&\dots&h(0)\end{bmatrix}$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$g$的初始矩阵和转移矩阵类似。时间是$O(p^3\log_2n)$。  

### 暴力卷积  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;发现转移和卷积比较类似。但是它们的区别在于循环的上界不同。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑把$f$和$h$卷起来的时候，我们会得到一个$2\times p-1$项的向量。然而，实际上$[p,2\times p-1]$的部分的结果在真正的转移中应该被累加回$[0,p)$这个范围去。于是我们只需要自己动手把超出范围的项累加回去即可。外面套上去一个快速幂，时间就是$O(p^2\log_2n)$。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~~所以矩阵加速意义不明呀......~~  

### $FFT/NTT$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看到了向量的卷积之后，我们把暴力的部分换成$FFT/NTT$。$FFT$是一次运算完之后进行取模，$NTT$写任意模数。一次卷积完了之后同样要把超出范围的项累加回去。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;外面套一个快速幂，时间是$O(p\log_2p\log_2n)$。  
# 代码
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只有矩阵加速的......
```cpp
#include <cstdio>
#include <cstring>

const int mod = 20170408;
const int MAXP = 105, MAXM = 2e7 + 5;

template<typename _T>
void read( _T &x )
{
    x = 0;char s = getchar();int f = 1;
    while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
    while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
    x *= f;
}

template<typename _T>
void write( _T x )
{
    if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
    if( 9 < x ){ write( x / 10 ); }
    putchar( x % 10 + '0' );
}

struct matrix
{
	int mat[MAXP][MAXP], n, m;
	matrix() { n = m = 0, memset( mat, 0, sizeof mat ); }
	matrix( const int N, const int M ) { n = N, m = M, memset( mat, 0, sizeof mat ); }
	int * operator [] ( const int indx ) { return mat[indx]; }
	matrix operator * ( matrix b ) const
	{
		matrix ret( n, b.m );
		for( int i = 1 ; i <= ret.n ; i ++ )
			for( int j = 1 ; j <= ret.m ; j ++ )
				for( int k = 1 ; k <= m ; k ++ )
					ret[i][k] = ( ret[i][k] + 1ll * mat[i][j] * b[j][k] % mod ) % mod;
		return ret;
	}
}A, B, C;

int buk[MAXP], comb[MAXP];
int prime[MAXM], pn;
int N, M, P;
bool isPrime[MAXM];

int fix( const int x, const int m ) { return ( x % m + m ) % m; }
matrix I( const int n ) { matrix ret = matrix( n, n ); for( int i = 1 ; i <= n ; i ++ ) ret[i][i] = 1; return ret; }

void EulerSieve( const int siz )
{
	isPrime[1] = true;
	for( int i = 2 ; i <= siz ; i ++ )
	{
		if( ! isPrime[i] ) prime[++ pn] = i;
		for( int j = 1 ; j <= pn && 1ll * i * prime[j] <= siz ; j ++ )
		{
			isPrime[i * prime[j]] = true;
			if( ! ( i % prime[j] ) ) break;
		}
	}
}

matrix qkpow( matrix base, int indx )
{
	matrix ret = I( base.n );
	while( indx )
	{
		if( indx & 1 ) ret = ret * base;
		base = base * base, indx >>= 1;
	}
	return ret;
}

signed main()
{
	read( N ), read( M ), read( P );
	EulerSieve( M );
	A = matrix( 1, P );
	A[1][1] = 1;
	B = C = matrix( P, P );
	for( int i = 1 ; i <= M ; i ++ ) 
		buk[i % P] = ( buk[i % P] + 1 ) % mod, comb[i % P] = ( comb[i % P] + isPrime[i] ) % mod;
	for( int i = 1 ; i <= P ; i ++ ) 
		for( int j = 1 ; j <= P ; j ++ )
			B[i][j] = buk[fix( j - i, P )],
			C[i][j] = comb[fix( j - i, P )];
	matrix partB = qkpow( B, N ), partC = qkpow( C, N );
	int a = ( A * partB )[1][1], b = ( A * partC )[1][1];
	write( fix( a - b, mod ) ), putchar( '\n' );
	return 0;
}
```

---

## 作者：zhengzhi726 (赞：0)

矩乘可以写成循环矩阵 这样矩乘少一个维度
o(p^2*logn+m)这应当说是dp矩阵优化的最优做法（没找到更优的）
```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxn 105
#define N 20000005 
#define ll long long
#define mod 20170408
struct matrix{ll a[maxn][maxn],n,m;};
ll n,m,prime[10000000],cnt[maxn],cnt0[maxn],sum=0,cx[maxn],p;bool isprime[N];
matrix jc(matrix u,matrix v){
    matrix c;c.n=u.n,c.m=v.m;memset(c.a,0,sizeof(c.a));
    for(int i=1;i<=u.m;i++)for(int k=1;k<=u.n;k++)c.a[1][i]+=u.a[k][i]*v.a[1][k],c.a[1][i]%=mod;
    for(int i=2;i<=c.n;i++){for(int j=2;j<=c.m;j++)c.a[i][j]=c.a[i-1][j-1];c.a[i][1]=c.a[i-1][p];}
    return c;
}
matrix ksm(matrix a,ll x){
    matrix ans;ans.n=a.n,ans.m=a.m;memset(ans.a,0,sizeof(ans.a));for(int i=1;i<=a.n;i++)ans.a[i][i]=1;
    for(;x;x>>=1){
        if(x&1)ans=jc(ans,a);
        a=jc(a,a);
    }return ans;
}
void shai(){
    for(int i=2;i<N;i++){
        if(!isprime[i])prime[++sum]=i;
        for(int j=1;j<=sum&&i*prime[j]<N;j++){
            isprime[i*prime[j]]=1;
            if(i%prime[j]==0)break;
        }
    }
}
int main(){shai();isprime[1]=1;
    cin>>n>>m>>p;
    for(int i=1;i<=m;i++){
        cnt[i%p]++;if(isprime[i])cnt0[i%p]++;
    }matrix x,y,u,v;x.n=p,y.n=p,y.m=1,x.m=1;memset(u.a,0,sizeof(u.a));memset(y.a,0,sizeof(y.a));memset(x.a,0,sizeof(x.a));memset(v.a,0,sizeof(v.a));
    u.n=u.m=v.n=v.m=p;
    for(int i=1;i<=p;i++)x.a[i][1]=cnt[i-1];
    for(int i=1;i<=p;i++)y.a[i][1]=cnt0[i-1];
    for(int i=2;i<=p;i++)u.a[1][p-i+2]=cnt[i-1];u.a[1][1]=cnt[0];
    for(int i=2;i<=p;i++){for(int j=2;j<=p;j++)u.a[i][j]=u.a[i-1][j-1];u.a[i][1]=u.a[i-1][p];}
    for(int i=2;i<=p;i++)v.a[1][p-i+2]=cnt0[i-1];v.a[1][1]=cnt0[0];
    for(int i=2;i<=p;i++){for(int j=2;j<=p;j++)v.a[i][j]=v.a[i-1][j-1];v.a[i][1]=v.a[i-1][p];}
    v=ksm(v,n-1);u=ksm(u,n-1);
    x=jc(x,u),y=jc(y,v);
    cout<<(x.a[1][1]-y.a[1][1]+mod)%mod<<endl;
    return 0;
}
```


---

## 作者：斯茂 (赞：0)

# 一个优化

此题p<=100,用O(m+p^3logn) 的算法是能过的

但是如果p<=1000呢？

注意到，用来做快速幂的矩阵有一个特点：

第i行的数是由第i-1行向右移动一格得到的

所以我们可以用p^2的时间算出第一行，然后再用p^2时间把第一行移到整个矩阵。
这样，单次乘法时间是p^2,总时间O(m+p^2logn)。


详情见代码：




```
struct matrix
{
  int n, m;
  long long s[105][105];
}
matrix kmatmul(matrix a, matrix b)
{
  int i, j, k, n = a.n;
  matrix ans;
  ans.n = ans.m = n;
  for(i = 1; i <= n; i++)
    for(j = 1; j <= n; j++)
      ans.s[i][j] = 0;
  for(i = 1; i <= n; i++)
    for(k = 1; k <= n; k++)
      ans.s[1][i]  = (ans.s[1][i] + a.s[1][k] * b.s[k][i]) % 20170408;
  for(i = 2; i <= n; i++)
    for(j = 1; j <= n; j++)
      ans.s[i][j] = ans.s[i - 1][(j - 2 + n) % n + 1];
  return ans;
}
```

注意：
（1）此方法只对于有上述性质的矩阵使用

（2）p=1000时，一个matrix的数据量达到了1e6,无法放在函数内，作为函数返回值，作为函数参数等。（这和递归爆栈是一个原理）。所以要把kmatmul函数定义为
```
void kmatmul()
```
然后再外面用全局变量做修改。

---

## 作者：zhangxiaoyu008 (赞：0)

[>题面链接<](/problem/P3702)

更佳观感：[ $$\mathtt{My \ Blog}$$ ——题解：P3702 [SDOI2017] 序列计数](https://www.luogu.com.cn/article/1qjccrpt)

首先看到“至少有一个数是质数”就觉得不好算，一眼容斥成 $n$ 个数的和是 $p$ 的倍数的方案数减去 $$n$$ 个非质数的和是 $p$ 的倍数的方案数。

那我们就考虑 $n$ 个数的和是 $p$ 的倍数的方案数怎么求（另一个再加个筛素数就可以了）。

状态定义： $f_{i,j}$ 表示 $i$ 个数的和模 $p$ 为 $j$ 的方案数。

转移：
定义 $\text{cnt}_x = \displaystyle\sum_{i \in [1..m]}\big[i \bmod p = x\big]$

那么 $f_{i,j} = \displaystyle\sum_{k \in [0..p)} f_{i - 1, k} \cdot \text{cnt}_{j - k}$

我们发现这个东西好像可以矩阵快速幂！

因为 $f_{1, i} = \displaystyle \text{cnt}_i$，所以构造
$\mathbf{A} = \begin{bmatrix} \text{cnt}_0 \\ \text{cnt}_1 \\ \vdots \\ \text{cnt}_{p-1} \\ \end{bmatrix}_{n \times 1}$

随后假设已经求出来了 $\begin{bmatrix} f_{i-1,0} \\ f_{i-1,1} \\ \vdots \\ f_{i-1,p-1} \\ \end{bmatrix}_{n \times 1}$

那么相应的就应构造

$\mathbf{B} = \begin{bmatrix} \text{cnt}_{0 - 0} & \text{cnt}_{0 - 1} & \cdots & \text{cnt}_{0 - (p-1)} \\ \text{cnt}_{1 - 0} & \text{cnt}_{1 - 1} & \cdots & \text{cnt}_{1 - (p-1)} \\ \cdots & \cdots & \cdots & \cdots \\ \text{cnt}_{(p - 1) - 0} & \text{cnt}_{(p - 1) - 1} & \cdots & \text{cnt}_{(p - 1) - (p - 1)}\end{bmatrix}_{n \times n}$

同理将 $\text{cnt}$ 换成 $\text{cnt}_x = \displaystyle\sum_{i \in [1..m]}\big[i \bmod p = x \land \text{is\_not\_prime}(i) \big]$ 可以求出  $$n$$ 个非质数的和是 $p$ 的倍数的方案数。

然后写✍代码~~~

## 代码

**$$\textbf{\tiny{如直接复制代码CE后果自负}}$$**

```cpp
#include <bits/stdc++.h>‍‌
using namespace std;‭‌
typedef long long LL;‭‌
const int N = 100 + 10, M = 2e7 + 10, mod = 20170408;‭‌
int n, m, p, primes[M], cnt, cnt1[N], cnt2[N];‌
bool st[M];‭‌
struct Matrix{‭‌
	int m, n, mat[N][N];‌
	Matrix(‭) {‭}‌
	Matrix(int _m, int _n) {‭
		m = _m, n = _n;‍‌
		memset(mat, 0, sizeof mat);‍‌
	}‭‍‌
	inline Matrix operator * (Matrix b) {‭
		if(n != b.m) throw "Invalid Matrix Operation.";‍‌
		Matrix res(Matrix(m, b.n));‍‍‌‌
		for(int i = 0; i < m; i ++)‍‍‌‌
			for(int j = 0; j < b.n; j ++)‍‍‌‌
				for(int k = 0; k < n; k ++)‍‍‌‌
					res.mat[i][j] = (res.mat[i][j] + (LL)mat[i][k] * b.mat[k][j] % mod) % mod;‍‌
		return res;‍‍‌‌
	}‭
	inline Matrix operator ^ (int k) {‭
		if(m != n) throw "Invalid Matrix Operation.";
		Matrix tmp(*this), res(Matrix(m, n));‭
		for(int i = 0; i < m; i ++) res.mat[i][i] = 1;‭
		while(k) {‭
			if(k & 1) res = res * tmp;
			tmp = tmp * tmp;
			k >>= 1;
		}‭‍‌
		return res;‍‌
	}‭
}A, B;‭‍‌
int get_ans(int *cnt) {‭
	A = Matrix(p, p);‭
	for(int i = 0; i < p; i ++)‭
		for(int j = 0; j < p; j ++)‭
			A.mat[i][j] = cnt[(i - j + p) % p];‭
	B = Matrix(p, 1);‭
	for(int i = 0; i < p; i ++) B.mat[i][0] = cnt[i];‭
	return ((A ^ (n - 1)) * B).mat[0][0];‭
}
int main(‍‌)‍‍‌‌
{‍‌
	scanf("%d%d%d", &n, &m, &p);‭
	for(int i = 1; i <= m; i ++) cnt1[i % p] ++;
	st[1] = true;‭ // 自然1不是质数
	for(int i = 1; i <= m; i ++) {‭
		if(!st[i]) primes[++ cnt] = i;‭
		for(int j = 1; j <= cnt && primes[j] <= m / i; j ++) {‭
			st[i * primes[j]] = true;
			if(!(i % primes[j])) break;
		}‭
	}‭
	for(int i = 1; i <= m; i ++)
		if(st[i])‭
			cnt2[i % p] ++;‭
	printf("%d\n", (get_ans(cnt1) - get_ans(cnt2) + mod) % mod);‭
	return 0;‭
}‭
```

---


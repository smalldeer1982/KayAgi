# [HAOI2014] 走出金字塔

## 题目描述

在探险的过程中，考古学家 Dr. Kong 无意地被困在一个金字塔中。金字塔中的每个房间都是三角形。Dr. Kong 可以破壁走到相邻的房间去。例如，如果他目前处于三角形 $(2,2)$ 房间，那么他可以破壁走到三角形 $(2,1)$、$(2,3)$ 或 $(1,1)$ 房间。但破壁一面墙需要花费 $K$ 分钟时间，而考古学家 Dr. Kong 的体能只能支持他 $S$ 分钟。


好在 Dr. Kong 手中有这个金字塔地图，他发现金字塔有许多出口，一旦他进入一个有出口的三角形房间，他再用 $1$ 分钟就可以走出金字塔。

现在，你能否帮助 Dr. Kong 找到一个走出金字塔花费时间最少的出口？若能，输出 Dr. Kong 走出金字塔后还剩下的体能时间（应当大于或等于 $0$）；若不能，输出 $-1$。

![](https://cdn.luogu.com.cn/upload/pic/5208.png)


## 说明/提示

### 数据范围及约定

对于全部数据，$1 \le N \le 10^6$，$0\le M\le 10^4$，$0<K\le 20$，$10\le S\le 10^4$。

所有的数据都是整数，且数据之间有一个空格。


## 样例 #1

### 输入

```
4 2 2 10
2 1
3 5
4 4```

### 输出

```
3```

# 题解

## 作者：qwaszx (赞：7)

作为一个蒟蒻我找了两个小时的规律才调出来emmmm

好像我的做法不是很一样

如果知道两个点，可以直接求出其距离

设$A(x_1,y_1),B(x_2,y_2)$且$x_1\leq x_2$

先把$B$平移到$A$所在层，这一步用了$2(x_2-x_1)$

接下来考虑平移后$B$在水平方向延伸的最大距离

可以看出这个距离是$x_2-x_1$

如果$A$和$B'$的距离不在这个范围内，我们就要给答案加上这个差

注意水平距离计算时要补成正方形来算

也就是$ans+=max(|y_1-y_2+x_2-x_1|-x_2+x_1,0)$

否则的话，还要考虑奇偶性

容易~~打表~~看出答案需要加上$y_2\ mod\ 2\ -\ y_1\ mod\ 2$

这样子就可以得到最终答案了

但是距离明明应该是对称的算出来的这个式子却不对称~~好气啊~~我也不知道为什么

代码还是挺简单的

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int n,m,k,s,x,y,ans=1e9+7;
int abs1(int x){return x>0?x:-x;}
int dis(int x1,int y1,int x2,int y2)
{
	if(x1>x2)swap(x1,x2),swap(y1,y2);
	int ans=(x2-x1)<<1,t=abs1(y1-y2+x2-x1)+x1-x2;
	ans+=t>0?t:(y2&1)-(y1&1);
	return k*ans;
}
int getin()
{
	int x=0;char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')x=x*10+ch-48,ch=getchar();
	return x;
}
int main()
{
	n=getin(),m=getin(),k=getin(),s=getin(),x=getin(),y=getin();
	for(int i=1;i<=m;i++)
	{
		int xx=getin(),yy=getin();
		ans=min(ans,dis(x,y,xx,yy)+1);
	}
	if(ans<=s)cout<<s-ans<<endl;
	else cout<<-1<<endl;
}
```
~~找规律是不可能的，这辈子都不可能找规律的~~

---

## 作者：wuzhoupei (赞：5)

这个题啊，真是流弊  
我一开始是蒙圈的  

然后就猜测一些性质，比如令(x,y)为当前的坐标  
那我们会发现这样的性(gui)质(lv) :  

**首先所有 y 为偶数的三角形是反着的(顶点向下)，同理 y 为奇数的三角是正着的  **

**然后，两个三角的相对位置不变，距离则不变**

**再然后，任何一个三角都可以通过对称移动到(x,1)  **

**最后任何一个(x,1)形式的三角和(1,1)之间的距离是(x-1)<<1  **
  
根据上面的性质，我们就可以发现，把任何一个三角的横纵坐标做一些处理，使之成为(x,1)的形式，并且此时将起始坐标点转化为(1,1),这样就好求了许多  

在此之前，由于可能三角是倒着的，那么我们就将他们正过来  

还有可能是起始点的坐标在询问点的下面，我们要将他们交换  

而且翻转时会对 ans 产生一定影响，而且要先交换再翻转  
至于原因，请(wo)读(lan)者(de)自(qu)行(jie)考(shi)虑(le)(画个图就好了的)  

-------------------

```cpp
#include <bits/stdc++.h>
#define II int
#define IL inline
#define R register
#define I 123546
using namespace std;

template < typename T > IL void of(R T &a) {
	R char c=getchar (); R T w=1, p=0;
	while (!isdigit(c)) { if(c=='-') w=-1; c=getchar (); }
	while (isdigit(c)) { p=p*10+c-'0'; c=getchar (); }
	a=w*p;
}

/* -------------------- Peipei -------------------- */

II n,m,k,s,nx,ny;	

int main()
{
	of(n); of(m); of(k); of(s); of(nx); of(ny);
	R II ans=1e9, now=0;
	for(R II i=1,x,y;i<=m;i++) {
		R II xx=nx, yy=ny;
		now=0;
		of(x); of(y);
		if(nx>x) swap(x,nx), swap(y,ny);
		if(!(ny&1)) nx--, ny--, now--;
		if(!(y&1)) x--, y--, now++;
		
		x-=nx-1; y-=ny-1;
		if(y>x*2-1) now+=y-(x*2-1);
		if(y<1) now+=1-y;
		y=1;
		now+=(x-1)*2;
		ans=min(ans,now);
		nx=xx; ny=yy;
	}
	ans*=k; ans++;
	
	if(ans>s) ans=-1;
	else ans=s-ans;
	printf("%d\n",ans);
	exit(0);
}
```
---------------------------

---

## 作者：dummyummy (赞：4)

~~萌新一个，第一次发题解，dalao勿喷~~~~

一看到这个题，我就想 bfs ，但看了看数据，发现bfs会GG。想了半天，再加上高人指点，终于发现这个金字塔比较特殊，因为**如果知道两点坐标，可以直接把他们的最短距离求出来。**

然后，我们就要把规律找出来。

### 首先，我们考虑两个坐标所代表的三角形都为顶角朝上或顶角朝下的情况（因为每一个三角形只有这两种情况）。

不妨设起点坐标为(sx, sy), 出口坐标为(dx, dy)，其中sx <= dx（因为从终点走到起点的距离与从起点走到终点相等）.

**CASE 1. 若两个三角形在同一列（这里的列是斜着的）**

就像两点之间线段最短一样，这是我们一定会直接朝着终点走过去，不难发现，此时的最短距离为 ** _2×(dx-sx)_ **。

**CASE 2. 若两个三角形在同一行**

走法同上，此时最短距离为 ** _|dy-sy|_ **。

**CASE 3. 若两个三角形不满足条件1和条件2**

我们该怎么办呢？因为走直线一定是最短的，我们来考虑平移。若是能把它们平移到同一行或同一列上，岂不美哉？

同时，因为我们假设终点在起点下方，所以不难证明，先将它们移到同一列的距离最短。

将平移操作分解，我们会发现就是先将终点处三角形平移到同一行的某一个三角形(mx, my)上，再平移到起点处。所以，我们只需要求出mx和my就可以了。

该怎么求呢？此时，我们又发现两个结论:

1.在像“/”这样的斜列上，任意两三角形的y坐标相等

2.在像“\”这样的斜列上，任意两三角形(x1, y1), (x2, y2)，其中x1 <= x2，则有 **_y2-y1 = 2×(x2-x1)_** 

然后，有上面两条性质，我们就不难求出mx和my了。由上式可得：

1.若dy < sy, 则有** _mx = dx，my = sy_ **

2.若dy > sy+2×(dx-sx)，则有** _mx = dx，my = sy+2×(dx-sx)_ **

于是中间点(mx, my)就求出来了。接着我们分别运用**CASE 2**和**CASE 1**的结论，就可以把最短距离求出来了。

### 其次，我们考虑两个三角形一个顶角朝上，一个顶角朝下的情况。

对于这种情况，我们可以将它们都翻转到一个方向。不难得出，每次翻转的代价都为k。然后我们就把它们变成同一个方向了，可以运用上面的结论求解。

**注意！**翻转上方的三角形和下方的三角形的代价是不一样的，一个为k，一个为-k（ _~~想一想，为什么~~_ ）

上代码（不会快读-__-|）

```cpp
#include <bits/stdc++.h>

using namespace std;

int n, m, k, s;

int calc(int sx, int sy, int dx, int dy) {
    int ans = 0;
    if(sx > dx) swap(sx, dx), swap(sy, dy); //调整位置
    if(!(sy & 1)) sx--, sy--, ans--;
    if(!(dy & 1)) dx--, dy--, ans++; //翻转操作
    if(dy > sy + (dx - sx << 1)) ans += dy - (sy + (dx - sx << 1)); //注意运算符优先级!
    if(dy < sy) ans += sy - dy;
    ans += dx - sx << 1;
    return ans * k + 1; //别忘记乘k后加1
}

int main() {
    int sx, sy, ans = 0x8f8f8f8f;
    scanf("%d%d%d%d", &n, &m, &k, &s);
    scanf("%d%d", &sx, &sy);
    for(int i = 1, dx, dy; i <= m; i++) {
        scanf("%d%d", &dx, &dy);
        int c = calc(sx, sy, dx, dy);
        if(c <= s) ans = max(ans, s - c);
    }
    if(ans == 0x8f8f8f8f) printf("-1");
    else printf("%d", ans);
    return 0;
}
```

---

## 作者：Tracy_Loght (赞：2)

## 题目大意：

求多点在三角字形塔中的距离。

## 分析：

找规律，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/6es4ablb.png)

~~（你看看我多好，还不点个赞）~~

有一个容易得到的结论:

![](https://cdn.luogu.com.cn/upload/image_hosting/uuka1c9e.png)

比如我们要从 $6$，$6$ 走到 $4$ 行的任意一个位置，则一定可以用三到四步之间走到。

- $3$ 步：第二个坐标为奇数。

- $4$ 步：第二个坐标为偶数。

映射到所有的情况，从 $a$，$b$ 到 $x$，$y$ 且 $(a>x)$，则 $y$ 如果在区间 $[b-(a-x) \times 2，b]$ 内只需要 $(a-x) \times 2$ 或 $(a-x) \times 2 +1$ 次破壁，具体看奇偶性。

如果不在这个区间内呢？

答案是两点之间，直线最短，计算区间里目标的最短距离即可（直线上不需要说了吧）。

## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,k,s,x,y,jl=99999999;
int dpzc_jf(int a,int b,int x,int y){
	int l,r,p=(a-x)*2;
	if(b%2==1) {l=b-p;r=b;}
	else {l=(b+1)-p;p--;r=b-1;}
	if(l<=0) l=1; if(r>x*2-1) r=x*2-1;
	if(l<=y&&y<=r) return y%2==1?p:p+1;
	else return y>r?p+y-r:p+l-y;
}
int main(){
	ios::sync_with_stdio(0);
	std::cin.tie(0);
	std::cout.tie(0); 
	cin>>n>>m>>k>>s>>x>>y;
	while(m--){
		long long a,b,as;cin>>a>>b;
		if(a>x) as=dpzc_jf(a,b,x,y);
		else as=dpzc_jf(x,y,a,b);
		jl=min(jl,as*k+1);
	}
	if(jl>s) cout<<-1;else cout<<s-jl;
	return 0;
}

```

---


# [TJOI2007] 球赛

## 题目背景

超级球迷 H 每周六晚上都会坐在电视前看球，从不错过一场比赛。

但是上周末，H 突然有一个重要的约会，于是他只能教他三岁的弟弟小 H 记录所有比赛

的比分。但是当他约会回来时，他发现小 H 不仅认真的记录了每一场比赛的最终比分，还

把一些比赛的中间比分也记录下来，而更糟糕的是，小 H 并没有区分比赛的两个队，同一

场比赛的比分可能被记录成 1-2，也可能是 2-1。因此，若是有一场比赛的最终得分是 5-3，

可能实际上被小 H 记录的分数有

1-0 3-2 2-3 3-4 5-3


## 题目描述

现在 H 已经拿到了小 H 记录的所有比分，他想知道，在这个周末他由于约会至少错过

了多少场比赛。注意小 H 记录的比分是没有先后顺序的。


## 说明/提示

在第一组输入数据中，两场比赛对应的比分可能是 1-0 2-0 0-3 和 2-1。

在第二组输入数据中，三场比赛对应的比分可能是 0-0 5-0、3-1 和 2-2。

100%的数据中 n ≤ 5，s ≤ 1 000，每一场比赛的比分都在 longint(Pascal) / long(C++)

（2147483647）范围内。


## 样例 #1

### 输入

```
2
4
1-0
2-0
0-3
2-1
4
5-0
1-3
2-2
0-0```

### 输出

```
2
3```

# 题解

## 作者：Ajwallet (赞：9)

# 本题第二个AC，第一篇题解
思路啊，就是贪心+离散化

乍看一下似乎是最大匹配，好像可以用导弹拦截的$70$分做法去做，但是时间复杂度为$O(n^3)$会超时，就打了一个贪心$O(n^2)$

要求的是最少的次数，那么我们可以发现，如果把每个比分都分成较大的较小的两部分，那么这样会使比赛更少。

如果要减少关键字的话，那就把大的积分排个序吧！这样就保证大积分不会干扰小积分的比赛数统计了（当然也可以排小积分）

这个时候小积分就构成了一个熟悉的题目：导弹拦截

# 代码
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define zero(a) memset(a,0,sizeof(a))
#define r(i,a,b) for(int i=a;i<=b;i++)
using namespace std;
int t,n,x,y,f[1001],ans,p;
struct node
{
	int a,b;
}s[1001];//结构体
bool cmp(node x,node y){return x.b<y.b||x.b==y.b&&x.a<y.a;}//排序
int main()
{
	scanf("%d",&t);//输入
	while(t--)
	{
		zero(s);zero(f);//初始化
		scanf("%d",&n);//输入
		r(i,1,n)
		{
			scanf("%d-%d",&x,&y);//输入，scanf就是好
			s[i].b=max(x,y);//取下大积分
			s[i].a=min(x,y);//取下小积分
		}
		sort(s+1,s+n+1,cmp);//排个序
		ans=0;f[++ans]=s[1].a;//初始化
		r(i,2,n)
		{
			p=0;
			r(j,1,ans)
			 if(s[i].a>=f[j]&&f[p]<=f[j]) p=j;//比较丑的贪心
			if(!p)f[++ans]=s[i].a;else f[p]=s[i].a;//把它放进去
		}
		printf("%d\n",ans);//然后就输出
	}
}
```

---

## 作者：When (赞：2)

#### 前置芝士

$Dilwoth$定理$or$你已经做了[导弹拦截](https://www.luogu.com.cn/problem/P1020)

什么是$Dilworth$定理？

> 对于任意有限偏序集，其最大反链中元素的数目必等于最小链划分中链的数目.   


或许你可以通过[这篇博客](https://www.cnblogs.com/Rothen/p/13789904.html)学习一下。

事实上，对于本题而言，所有的比分信息就是偏序集，而我们要求的就是最小链划分，即为最大反链长度，更具体的，就是**最长严格下降子序列的长度**

#### 思路

首先，我们将所有信息按照$y$或者$x$排序，这样就保证了其中一维的有序，然后根据另一维求一遍最长下降子序列就可以了。

#### Tips

其实本题最优秀的复杂度应为$n\log n$，但是本题只要求$n^2$，为了提升水平~~打最优解~~，建议用$n\log n$算法求最长下降子序列。本题解中也是用的这个复杂度的算法。

#### 代码

```cpp
#include <cstdio>
#include <algorithm>
#define LL long long

using namespace std;

const int maxn = 2020;
int n,top;
LL b[maxn];
struct Gam{
    LL x,y;
}g[maxn];

bool cmp(Gam a, Gam b){return a.x == b.x ? a.y < b.y : a.x < b.x;}

int main(){
    int T; scanf("%d", &T);
    while(T--){
        top = 0;
        scanf("%d", &n);
        for(int i = 1; i <= n; ++ i){
            scanf("%lld-%lld", &g[i].x, &g[i].y);
            if(g[i].x > g[i].y) swap(g[i].x, g[i].y);
        } sort(g + 1, g + 1 + n, cmp);
        b[++top] = g[1].y;
        for(int i = 2; i <= n; ++ i){
            if(g[i].y < b[top]) b[++top] = g[i].y;
            else{
                int h = top, l = 1;
                while(h >= l){
                    int mid = (h + l) >> 1;
                    if(b[mid] <= g[i].y) h = mid - 1;
                    else l = mid + 1;
                } b[h + 1] = g[i].y; //printf("%d\n", h + 1);
            }
        } printf("%d\n", top);
    }
    return 0;
}
```



---

## 作者：Aliya_Hyacinth (赞：1)

## 思路
因为得分是单调不减的，故可以把一边的分数统一排序，再看另一边。对于另一边，要求最少比赛数，就是找最少的不合逻辑的比赛，那么就是寻找最长单调不上升子序列的个数。注意：因为没有区分两个队，所以操作之前还得比较，让大的比分全在一边，看代码理解吧。
```cpp
#include<bits/stdc++.h>
using namespace std;

struct node{
	int x,y;
}cy[1001];
int n,s,ans,sum[1001];
char k;

bool cmp(node a,node b){
	if(a.x==b.x)
		return a.y<b.y;
	return a.x<b.x;
}

int main(){
	scanf("%d",&n);
	while(n--){
		ans=0;
		scanf("%d",&s);
		memset(sum,-1,sizeof(sum));
		for(int i=1;i<=s;i++){
			init();
			if(cy[i].x<cy[i].y)
				swap(cy[i].x,cy[i].y);
		}
		sort();
		for s 1 --
		{
			if(sum[ans]<cy[i].y)
			{
				ans++;
				sum[ans]=cy[i].y;
			}
			else
			{
				int op=lower_bound(sum+1,sum+ans+1,cy[i].y)-sum;//好用的查找函数
				sum[op]=cy[i].y;
			}
		}
		print();
	}
	return 0;
}
```

---

## 作者：happybob (赞：1)

考虑不妨设每个 $(x,y)$ 都有 $x \leq y$，容易发现规定顺序没有影响。

考虑 $(x_1,y_1)$ 和 $(x_2,y_2)$，什么时候可以比较。当且仅当 $x_1 \leq x_2 \land y_1 \leq y_2$，或者 $x_1 \geq x_2 \land y_1 \geq y_2$。

注意到我们要求的其实是偏序集上的最小链覆盖，根据 Dilworth 定理知就等价于最长反链。

不妨考虑反链是 $(x_1,y_1),(x_2,y_2),\cdots,(x_k,y_k)$，且 $x$ 已经不降排序了，那么容易发现对于任意 $i < j$，都有 $y_i > y_j$，于是将 $x$ 排序后求 $y$ 的最长下降子序列即可。

范围很小，$O(n^2)$ DP 即可。

注意 $x$ 相同时只能取一个 $y$。

代码：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <string>
#include <queue>
#include <vector>
#include <utility>
using namespace std;

const int N = 1005;

int n, x[N], y[N], t;
int ans;

pair<int, int> a[N];
int f[N];

int main()
{
	scanf("%d", &t);
	while (t--)
	{
		ans = 1;
		scanf("%d", &n);
		for (int i = 1; i <= n; i++)
		{
			scanf("%d-%d", &x[i], &y[i]);
			if (x[i] > y[i]) swap(x[i], y[i]);
			a[i] = make_pair(x[i], y[i]);
		}
		sort(a + 1, a + n + 1);
		for (int i = 1; i <= n; i++)
		{
			f[i] = 1;
			for (int j = 1; j < i; j++)
			{
				if (a[j].second > a[i].second) f[i] = max(f[i], f[j] + 1);
			}
			ans = max(ans, f[i]);
		}
		printf("%d\n", ans);
	}
	return 0;
}
```

---

## 作者：CG__HeavenHealer (赞：1)


### 题意

$n$ 个比分，格式为 $a-b$，每场比赛的得分可能为 $a-b$，也可能为 $b-a$，求至少有多少场比赛。

---

### 解法

首先我们可以先把大的（或小的）都放在同一侧，之后排个序，保证某一方的得分单调。

由于同一场比赛中，一方的得分肯定是单调增的，所以最少的比赛数其实就等于**求单调上升子序列的个数**。

而根据 $\text{dilworth}$ 引理，最小链划分等于最长反链，可以得到：**单调上升子序列个数=最长单调下降子序列长度**。

最长下降子序列可以 $n^2$，也可以 $n\log n$ 求，具体做法这里不讲。

要注意的是如果 $n\log n$ 求并且用的是 ```std::lower_bound``` 的话需要重载一下小于号。

目前是洛谷最优解。

---

### Code：

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <utility>
using namespace std;
const int N = 1e5 + 10;
int stk[N], top, n, T;
pair<int, int> a[N];
int main() {
    scanf("%d", &T);
    while (T --> 0) {
        scanf("%d", &n);
        for (int i = 1; i <= n; i++) {
            scanf("%d-%d", &a[i].first, &a[i].second);
            if (a[i].first > a[i].second) swap(a[i].first, a[i].second);
        }
        sort(a + 1, a + n + 1);
        memset(stk, 0, sizeof(stk));
        top = 0;
        for (int i = 1; i <= n; i++) {
            if (!top || a[i].second < stk[top]) 
                stk[++top] = a[i].second;
            else 
                *lower_bound(stk + 1, stk + top + 1, a[i].second, [](const int &x, const int &y) -> bool {
                    return x > y;
                }) = a[i].second;
        }
        printf("%d\n", top);
    }
    return 0;
}
```



---

## 作者：Dream_poetry (赞：0)

### 题意简述：
给定 $n$ 个二元组 $(x,y)$，通过翻转或不翻转的操作后，找出所组成最少的**不降序列**的个数。必须保证 **$x$ 和 $y$ 均不降**。

### 思路：

题目还是比较~~不~~明显地提示了：通过维持 $y$ 的单调性，来比较 $x$ 的大小就行了。

但这玩意是可翻转的，所以，我们还需要维持一个条件 $x \le y$。

总结一下，方法就是：

1. 确保 $y$ 单调不降。
2. 确保 $x \le y$。
3. 求不降子序列。

### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int lbj;
int n;
struct zzy{
    int le,ri;
}a[415411];

int f[1919810];


bool cmp(zzy x,zzy y){
    if (x.ri!= y.ri)
        return x.ri<y.ri;
    return x.le<y.le;
}
signed main(){
    cin>>lbj;
    while (lbj--){
        cin>>n;
        for (int i=1;i<=n;i++){
            scanf("%d-%d",&a[i].le,&a[i].ri);
            if (a[i].ri<a[i].le){
                swap(a[i].ri,a[i].le);
            }
        }
        sort(a+1,a+n+1,cmp);
        int ans=1;
        memset(f,0,sizeof(f));
        f[1]=a[1].le;
        for (int i=2;i<=n;i++){
        	if (a[i].le<f[ans]){
        		f[++ans]=a[i].le;	
			}
        	else{
        		int l=0,r=ans+1,m;
        		while (l+1<r){
        			m=(l+r)/2;
        			if (a[i].le<f[m]) l=m;
        			else r=m;
				}
				f[r]=a[i].le;
			}
		}
		cout<<ans<<endl;
    }
    return 0;
}
```


---

## 作者：analysis (赞：0)

又随机跳了一道题。

想着题时思路算是比较清晰的。

## Simplify

给定 $n$ 个二元组 $(u,v)$，你可以翻转它或不翻转。

求它最小组成多少个不降序列（不降需要满足 $u$、$v$ 均不降）。

## Solution

根据题目中的描述有两个大小比较（大于）条件，我们可以排序维护单调性（这里假设第一关键字为 $u$，即先保证了 $u$ 的单调性）。

然后题目就变成了关于仅 $v$ 的大小比较。

对于不满意的二元组，我们可以使用翻转操作改变其位置。

但翻转后 $v$ 可能变小也可能变大，过于麻烦。

我们可以钦定 $u \leq v$，这样翻转后必定变小。

再考虑一个值翻转后的贡献：

显然，由于 $u \leq v$，所以反转过后仍然无法并入不降子序列中，所以翻转不优。

于是，最终做法就是：

- 保证 $u \leq v$。

- 保证 $u$ 单调。

- 暴力加入不降子序列。

```cpp
#include<bits/stdc++.h>
#define pii pair<int,int>
#define mp make_pair
using namespace std;
pii p[1005];
int n;
int vis[1005],cnt;
signed main()
{
    int _;
    cin>>_;
    while(_--)
    {
        memset(vis,0,sizeof vis);
        cnt=0;
        cin>>n;
        for(int i=1;i<=n;i++)
        {
            scanf("%d-%d",&p[i].first,&p[i].second);
            if(p[i].first > p[i].second)swap(p[i].first,p[i].second);
        }
        sort(p+1,p+1+n);
        for(int i=1;i<=n;i++)
        {
            int fl = 0;
            for(int j=1;j<=cnt;j++)
            {
                if(vis[j] <= p[i].second)
                {
                    vis[j] = p[i].second;
                    fl = 1;
                    break;
                }
            }
            if(!fl)
            {
                vis[++cnt] = p[i].second;
            }
        }
        cout<<cnt<<endl;
    }
    return 0;
}
```

---

## 作者：xiezheyuan (赞：0)

[也许有更好的阅读体验](https://www.cnblogs.com/zheyuanxie/p/p3845.html)

## 简要题意

$T$ 组数据，每一组数据给出 $n$ 个数对 $(a,b)$。你需要将其分为几组，使得组单调不降。求最小组数。

## 思路

模拟赛考的题。

先来介绍 Dilworth 定理：

> 对于任意有限偏序集，其最大反链中元素的数目必等于最小链划分中链的数目。

这个定理似乎可以运用到这道题！

如果这样子，本题就被转换成了求最长下降子序列，可以 $O(n\log n)$ 求。

最后讲一下如何求最长下降子序列，我们可以钦定 $(a,b)$ 中 $a>b$。然后按照 $a,b$ 双关键字排序后 二分优化 DP 求最长下降子序列即可。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

bool flag=0;
const int N = 100005;

struct couple{
	int a,b;
	bool operator<(const couple &x) const {
		bool ret=a==x.a?b<x.b:a<x.a;
		if(flag)return !ret;
		else return ret;
	}
} p[N];

int f[N];
int n,t,tot;

signed main(){
// 	ios::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);
// 	freopen("line.in","r",stdin);freopen("line.out","w",stdout);
	cin>>t;
	while(t--){
		cin>>n;
		for(int i=1;i<=n;i++){
			scanf("%lld-%lld",&p[i].a,&p[i].b);
			if(p[i].a>p[i].b)swap(p[i].a,p[i].b);
		}
		sort(p+1,p+n+1);
		f[1]=p[1].b;
		tot=1;
		for(int i=2;i<=n;i++){
			if(f[tot]>p[i].b){
				f[++tot]=p[i].b;
			}
			else{
				f[lower_bound(f+1,f+tot+1,p[i].b,greater<int>())-f]=p[i].b;
			}
		}
		cout<<tot<<'\n';
	}
	return 0;
}
```

---

## 作者：kkxhh (赞：0)

我们假设每一个记录的比分为 **x** 和 **y** 。在读入的时候稍加处理使 **y>=x** 。然后排序一下**使y更小的排在前面，y相同时就将x更小的排在前面**。

此时在靠后的比分在**y**这一维上一定能覆盖前面的比分，于是我们就可以将问题转换成**求在x这一维上最少要用几个不下降序列覆盖全部的比分**。

如果你之前做过 [P1020 导弹拦截](https://www.luogu.org/problemnew/show/P1020) 的话，想必你已经知道了某个神奇的定理。求最少要用几个不下降序列覆盖一个数列等价于**求这个数列中最长严格下降数列的长度**。

于是我们就可以用那个  **O(nlogn)** 的贪心算法啦

代码如下

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;

typedef struct game{int x,y;}game;

game g[1010];
int t,n,a[1010];

inline int read(){
    int num=0; char c=getchar();
    while(c>'9' || c<'0') c=getchar();
    while(c>='0' && c<='9') num=(num<<3)+(num<<1)+c-'0',c=getchar();
    return num;
}

bool cmp(game a,game b){return (a.y!=b.y)?a.y<b.y:a.x<b.x;}

int main(){
    t=read();
    while(t--){
        n=read();
        for(int i=1;i<=n;i++){
            int x=read(),y=read();
            if(y<x) swap(x,y);
            g[i].x=x; g[i].y=y;
        }
        sort(g+1,g+1+n,cmp);
        memset(a,0,sizeof(a));
        int k=1; a[1]=g[1].x;
        for(int i=2;i<=n;i++){
            if(g[i].x<a[k]) a[++k]=g[i].x;
            else{
                int l=0,r=k+1,mid;
                while(l+1<r){
                    mid=(l+r)>>1;
                    if(a[mid]>g[i].x) l=mid;
                    else r=mid;
                }
                a[r]=g[i].x;
            }
        }
        printf("%d\n",k);
    }
    return 0;
}
```

---

## 作者：OMITW (赞：0)

# 前言

这么水的基础离散化加贪心居然没有足够多人交题解，**喜**！！！

# 思路推导

对于两个比分 $ xi:yi $ 和 $ xj:yj $。

仅当 $ xi \le xj $ 且 $ yi \le yj $ 或者 $ xi \le yj $ 且 $ yi \le xj $ 的时候满足 $ xi:yi $ 和 $ xj:yj $ 是可以在同一场比赛出现的。

所以我们可以先把所有比分 $ xi:yi $ 变为满足 $ xi \le yi $ 。再按找先满足 $ xi \le xj $，再满足 $ yi \le yj $ 的方式进行排序。

然后进行离散化，把比分缩小。最后运用贪心的思想，如果一个比分可以代替之前的比分，那就直接代替。否者就加入新的比分。

# Code
```cpp
#include<bits/stdc++.h>
using namespace std;
struct str
{
	int x,y;
}a[10005];
bool cmp(str q,str w)
{
	if(q.x==w.x)return q.y<w.y;
	return q.x<w.x;
}
int t,n,k,m,b[10005];
string s;
vector<int> g;
int main()
{
	cin>>t;
	while(t--)
	{
		cin>>n;
		for(register int i=1;i<=n;++i)
		{
			a[i].x=a[i].y=0;
			cin>>s;
			for(int j=0;j<s.size();j++)
			{
				if(s[j]=='-')
				{
					k=1;
					continue;
				}
				if(k)a[i].x=a[i].x*10+s[j]-'0';
				else a[i].y=a[i].y*10+s[j]-'0';
			}
			if(a[i].x>a[i].y)swap(a[i].x,a[i].y);
			b[i*2-1]=a[i].x;
			b[i*2]=a[i].y;
			k=0;
		}
		sort(a+1,a+1+n,cmp);
		sort(b+1,b+1+n*2);
		m=unique(b+1,b+1+n*2)-b-1;
		for(register int i=1;i<=n;++i)
		{
			a[i].x=lower_bound(b+1,b+1+m,a[i].x)-b;
			a[i].y=lower_bound(b+1,b+1+m,a[i].y)-b;
		}
		g.push_back(1);
		for(register int i=2;i<=n;++i)
		{
			int sum=0;
			for(register int j=0;j<g.size();++j)
			{
				if(a[g[j]].x<=a[i].x&&a[g[j]].y<=a[i].y)
				{
					g[j]=i;
					sum=1;
					break;
				}
			}
			if(!sum)g.push_back(i);
		}
		cout<<g.size()<<"\n";
		g.clear();
	}
	return 0;
}
```

---


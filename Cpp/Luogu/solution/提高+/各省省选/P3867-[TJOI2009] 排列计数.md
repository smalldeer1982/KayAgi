# [TJOI2009] 排列计数

## 题目描述

我们知道，1,2,...,N这个N个数的排列共有N!种情况。现在你的任务是，求出在这N!种排列中，任意相邻两数之差不超过K的排列共有多少个。

因为结果可能很大，你只需输出结果对1000000007取模后的值即可。


## 说明/提示

在30%的数据中，N ≤ 12

在100%的数据中，N ≤ 50，K ≤ 4

每个测试点时限10秒


## 样例 #1

### 输入

```
4 2```

### 输出

```
12```

# 题解

## 作者：L2_sheep (赞：4)

做了一道OI省选题，题目很短，题意求1到N的全排列，有多少个排列满足所有相邻两项之差都不超过K(N≤50，K≤4).

这道题让我想起以前做过的一题（URAL1260）。那题要求K=2，排列开头必须是1.当时，我从N=1，开始枚举，并且用了递推的方法（从N-1的序列推到N的序列。如果N-1序列不是符合要求的，那么无论把N插入N-1序列的任意位置，N序列都是不符合要求的。那也就是说，符合要求的N序列，是从符合要求的N-1序列推出的。），解决了那道题，递推公式并不复杂。这道题显然情况更复杂。我还是先尝试K=2的情况。

对于K=2，要从N-1序列生成N序列，其实只要考虑N-1序列中N-1和N-2的位置，当它们在序列的两端或者它们是相连的，就可以插入N，得到符合要求的N序列，再记录N和N-1的位置关系的种数（注意这时候N-2已经没用了，要把它删除掉，只记录N和N-1的位置关系）。当N≤2时，所有序列都符合，N＞2时，可以记录各种情况的种数，最后把所有情况累加起来就是答案。

对于K=3和K=4的情形，其实也是一样的。分成2^(K+1)\*(K!)种情况。代码很复杂，写了好久，供大家参考：





    
    
    
```cpp
#include <stdio.h>
#include <algorithm>
using namespace std;
int m = 1000000007;
int b2[6] = {1, 2, 4, 8, 16, 32};
int f[5] = {1, 1, 2, 6, 24};
int c[32][5] = {0}, p[24][4];
int s[5][51][24][32] = {0};
int solve(int n, int k)
{
    if(n <= k) return f[n];
    int i, ic, t, ip, j, d = 4 - k, tm = b2[k + 1] - 1, l, l0, ipp, icc;
    int tp[4], tc[5], ttp[5], ttc[6], ans = 0;
    for(i = 0; i < f[k]; i++){
        s[k][k][i][tm] = 1;
    }
    for(i = k + 1; i <= n; i++){
        for(ip = 0; ip < f[k]; ip++){
            for(j = 0; j < k; j++) tp[j] = p[ip][j + d] - d;
            for(ic = 0; ic <= tm; ic++){
                if(!s[k][i - 1][ip][ic]) continue; 
                for(j = 0; j <= k; j++) tc[j] = c[ic][j];
                for(j = 0; j <= k; j++){
                    if(!tc[j]) continue;
                    for(l = 0; l < j; l++) ttc[l] = tc[l], ttp[l] = tp[l];
                    for(l = k; l >= j; l--) ttc[l + 1] = tc[l];
                    for(l = k - 1; l >= j; l--) ttp[l + 1] = tp[l];
                    ttc[j] = 1, ttp[j] = k;
                    for(l0 = 0; ttp[l0]; l0++);
                    for(l = l0; l < k; l++) ttp[l] = ttp[l + 1];
                    for(l = l0; l <= k; l++) ttc[l] = ttc[l + 1];
                    ttc[l0] = 0;
                    for(l = 0; l < k; l++) --ttp[l];
                    for(l = icc = 0; l <= k; l++) icc += b2[l] * ttc[l];
                    int h[4] = {0}, ch;
                    for(l = 0, t = k - 1, ipp = 0; t >= 0; l++, t--){
                        for(ch = 0, l0 = 0; l0 < ttp[l]; l0++) ch += (h[l0] == 0);
                        h[ttp[l]] = 1;
                        ipp += ch * f[t];
                    }
                    s[k][i][ipp][icc] += s[k][i - 1][ip][ic];
                    if(s[k][i][ipp][icc] >= m) s[k][i][ipp][icc] -= m;
                }
            }
        }
    }
    for(ip = ans = 0; ip < f[k]; ip++){
        for(ic = 0; ic <= tm; ic++){
            ans += s[k][n][ip][ic];
            if(ans >= m) ans -= m;
        } 
    }
    return ans;
}
int main() 
{
    int n, k, i, j, t;
    int tp[4] = {0, 1, 2, 3};
    for(i = 1; i < 32; i++){
        t = i, j = 0;
        while(t){
            c[i][j] = t & 1;
            t >>= 1;
            j++;
        }
    }
    for(i = 0; i < 24; i++){
        for(j = 0; j < 4; j++) p[i][j] = tp[j];
        next_permutation(tp, tp + 4);
    }
    scanf("%d%d", &n, &k);
    printf("%d\n", solve(n, k));
    return 0;
}
```

---

## 作者：operator_ (赞：1)

# P3867 [TJOI2009] 排列计数

[题目传送门](https://www.luogu.com.cn/problem/P3867)

## 题解

$k$ 很小，不是分讨就是突破口。如果我们用这种方式生成排列：将 $1$ 到 $n$ 按顺序插入当前状态，那么你会发现当前的数 $x$ 的插入被很大程度的限制住了，我们只需记录当前 $x-k$ 到 $x-1$ 的位置即可枚举出所有可能的下一状态，因此我们可以使用更新式 $dp$。

状态 $f_{i,S}$ 表示长度为 $i$ 的排列，当前 $x-k$ 到 $x-1$ 的位置为 $S$ 的方案数，其中的 $S$ 本质上是一个 $k$ 维数组。

对于状态 $f_{i,S_1,S_2,\cdots,S_k}$：如果 $S$ 中有一个数在位置 $1$，那就说明 $i+1$ 可以被插入在 $1$，因此更新 $f_{i+1,1,S_1+1,S_2+1,\cdots,S_{k-1}+1}$。末尾同理。如果存在 $S_l=S_r-1$，那么 $i+1$ 可以被插入在 $S_r$，因此更新 $f_{i+1,S_r,S_1',S_2',\cdots,S_{k-1}'}$，其中的 $S'$ 需要考虑插入后会不会后移一位。

空间 128MB 可能会爆，把第一维滚动掉就好了。这样空间复杂度 $O(n^k)$，时间复杂度 $O(n^{k+1})$。

好像就是这样了，虽然代码比较长，不过其实不难写。马蜂很乱，我也不准备解释了，如果你真的想看的话：

```cpp
/*
 * @Author: operator_ 
 * @Date: 2024-01-16 13:50:22 
 * @Last Modified by: operator_
 * @Last Modified time: 2024-01-16 14:44:53
 */
#include<bits/stdc++.h>
using namespace std;
inline int rd() {
    int s=0,m=0;char ch=getchar();
    while(!isdigit(ch)) {if(ch=='-')m=1;ch=getchar();}
    while( isdigit(ch)) s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
    return m?-s:s;
}
const int M=1e9+7;
#define U2 f[!i][p][a1+(a1>=p)]=(f[!i][p][a1+(a1>=p)]+f[i][a1][a2])%M
#define U3 f[!i][p][a1+(a1>=p)][a2+(a2>=p)]=(f[!i][p][a1+(a1>=p)][a2+(a2>=p)]+f[i][a1][a2][a3])%M
#define U4 f[!i][p][a1+(a1>=p)][a2+(a2>=p)][a3+(a3>=p)]=(f[!i][p][a1+(a1>=p)][a2+(a2>=p)][a3+(a3>=p)]+f[i][a1][a2][a3][a4])%M
int n,k,p,tmp[55],Ans;
signed main(){
    cin>>n>>k;
    if(k==1) return cout<<min(n,2),0;
    if(k==2) {
        int f[2][51][51];memset(f,0,sizeof(f));
        f[1][1][0]=1;
        for(int ii=1;ii<n;ii++) {
            int i=ii&1;memset(f[!i],0,sizeof(f[!i]));
            for(int a1=0;a1<=ii;a1++) {
                for(int a2=0;a2<=ii;a2++) {
                    tmp[a1]++,tmp[a2]++,tmp[0]=0;
                    if(tmp[a1]<2&&tmp[a2]<2) {
                        if(tmp[1]) p=1,U2;
                        if(tmp[ii]) p=ii+1,U2;
                        if(tmp[a1]&&tmp[a1+1]) p=a1+1,U2;
                        if(tmp[a2]&&tmp[a2+1]) p=a2+1,U2;
                    }
                    tmp[a1]--,tmp[a2]--;
                }
            }
        }
        for(int a1=0;a1<=n;a1++)
            for(int a2=0;a2<=n;a2++)
                Ans=(Ans+f[n&1][a1][a2])%M;
        return cout<<Ans,0;
    }
    if(k==3) {
        int f[2][51][51][51];memset(f,0,sizeof(f));
        f[1][1][0][0]=1;
        for(int ii=1;ii<n;ii++) {
            int i=ii&1;memset(f[!i],0,sizeof(f[!i]));
            for(int a1=0;a1<=ii;a1++) {
                for(int a2=0;a2<=ii;a2++) {
                    for(int a3=0;a3<=ii;a3++) {
                        tmp[a1]++,tmp[a2]++,tmp[a3]++,tmp[0]=0;
                        if(tmp[a1]<2&&tmp[a2]<2&&tmp[a3]<2) {
                            if(tmp[1]) p=1,U3;
                            if(tmp[ii]) p=ii+1,U3;
                            if(tmp[a1]&&tmp[a1+1]) p=a1+1,U3;
                            if(tmp[a2]&&tmp[a2+1]) p=a2+1,U3;
                            if(tmp[a3]&&tmp[a3+1]) p=a3+1,U3;
                        }
                        tmp[a1]--,tmp[a2]--,tmp[a3]--;
                    }
                }
            }
        }
        for(int a1=0;a1<=n;a1++)
            for(int a2=0;a2<=n;a2++)
                for(int a3=0;a3<=n;a3++)
                    Ans=(Ans+f[n&1][a1][a2][a3])%M;
        return cout<<Ans,0;
    }
    if(k==4) {
        int f[2][51][51][51][51];memset(f,0,sizeof(f));
        f[1][1][0][0][0]=1;
        for(int ii=1;ii<n;ii++) {
            int i=ii&1;memset(f[!i],0,sizeof(f[!i]));
            for(int a1=0;a1<=ii;a1++) {
                for(int a2=0;a2<=ii;a2++) {
                    for(int a3=0;a3<=ii;a3++) {
                        for(int a4=0;a4<=ii;a4++) {
                            tmp[a1]++,tmp[a2]++,tmp[a3]++,tmp[a4]++,tmp[0]=0;
                            if(tmp[a1]<2&&tmp[a2]<2&&tmp[a3]<2&&tmp[a4]<2) {
                                if(tmp[1]) p=1,U4;
                                if(tmp[ii]) p=ii+1,U4;
                                if(tmp[a1]&&tmp[a1+1]) p=a1+1,U4;
                                if(tmp[a2]&&tmp[a2+1]) p=a2+1,U4;
                                if(tmp[a3]&&tmp[a3+1]) p=a3+1,U4;
                                if(tmp[a4]&&tmp[a4+1]) p=a4+1,U4;
                            }
                            tmp[a1]--,tmp[a2]--,tmp[a3]--,tmp[a4]--;
                        }
                    }
                }
            }
        }
        for(int a1=0;a1<=n;a1++)
            for(int a2=0;a2<=n;a2++)
                for(int a3=0;a3<=n;a3++)
                    for(int a4=0;a4<=n;a4++)
                        Ans=(Ans+f[n&1][a1][a2][a3][a4])%M;
        return cout<<Ans,0;
    }
    return 0;
}
```

其实想简化的话办法也很多，一个最可行的是直接存 $S$ 的哈希值，不过我懒了。

---


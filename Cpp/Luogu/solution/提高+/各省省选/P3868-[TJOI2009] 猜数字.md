# [TJOI2009] 猜数字

## 题目描述

现有两组数字，每组 $k$ 个。

第一组中的数字分别用 $a_1,a_2,\cdots ,a_k$ 表示，第二组中的数字分别用 $b_1,b_2,\cdots ,b_k$ 表示。

其中第二组中的数字是两两互素的。求最小的 $n\in \mathbb{N}$，满足对于 $\forall i\in [1,k]$，有 $b_i | (n-a_i)$。

## 说明/提示

对于 $100\%$ 的数据：

$1\le k \le 10$，$|a_i|\le 10^9$，$1\le b_i\le 6\times 10^3$，$\prod_{i=1}^k b_i\le 10^{18}$。

每个测试点时限 $1$ 秒。

注意：对于 ```C/C++``` 语言，对 $64$ 位整型数应声明为 ```long long```。

若使用 ```scanf```，```printf``` 函数（以及 ```fscanf```，```fprintf``` 等），应采用 ```%lld``` 标识符。

## 样例 #1

### 输入

```
3
1 2 3
2 3 5
```

### 输出

```
23```

# 题解

## 作者：niiick (赞：50)

####明明是中国剩余定理裸题竟然没有中国剩余定理题解

[中国剩余定理讲解](https://blog.csdn.net/niiick/article/details/80229217)

由题意知


 $$\left\{\begin{aligned}(n-a_1)\mid b_1 \\ (n-a_2)\mid b_2\\ ...\\ (n-a_k)\mid b_k\end{aligned}\right.$$ 

变换成同余方程组得

$$\left\{\begin{aligned}n-a_1\equiv 0(\mod b_1) \\ n-a_2\equiv 0(\mod b_2)\\ ...\\ n-a_k\equiv 0(\mod b_k)\end{aligned}\right.$$ 

根据同余式变换法则，

如果有$a\equiv b(\mod m)$，
则$a+c\equiv b+c(\mod m)$成立

将上述方程组变形得
\begin{cases}
n\equiv a_1(\mod b_1)\quad \\
n\equiv a_2(\mod b_2)\quad \\
...\quad \\
n\equiv a_k(\mod b_k)\quad \\
\end{cases}

 $$\left\{\begin{aligned}n\equiv a_1(\mod b_1)\\ n\equiv a_2(\mod b_2)\\ ...\\ n\equiv a_k(\mod b_k)\end{aligned}\right.$$ 

到这里就是裸得中国剩余定理了
不过要注意计算前要将所有$a[i]=(a[i]\mod b[i]+b[i])\mod b[i];$

另外这题出题人用(sang)心(xin)良(bing)苦(kuang)
要用快速乘，不然最后一个点爆long long
**********************

```
#include<iostream>
#include<cstdio>
#include<vector>
#include<queue>
#include<algorithm>
#include<cstring>
using namespace std;
typedef long long lt;

lt read()
{
    lt f=1,x=0;
    char ss=getchar();
    while(ss<'0'||ss>'9'){if(ss=='-')f=-1;ss=getchar();}
    while(ss>='0'&&ss<='9'){x=x*10+ss-'0';ss=getchar();}
    return x*f;
}

int k;
lt a[20],b[20];

lt qmul(lt a,lt b,lt mod)
{
    lt ans=0;
    while(b>0)
    {
        if(b&1) ans=(ans+a)%mod;
        a=(a+a)%mod;
        b>>=1;
    }
    return ans;
}

void exgcd(lt a,lt b,lt &x,lt &y)
{
    if(b==0){ x=1; y=0; return;}
    exgcd(b,a%b,x,y);
    int tp=x;
    x=y; y=tp-a/b*y;
}

lt china()
{
    lt ans=0,lcm=1,x,y;
    for(int i=1;i<=k;++i) lcm*=b[i];
    for(int i=1;i<=k;++i)
    {
        lt tp=lcm/b[i];
        exgcd(tp,b[i],x,y);
        x=(x%b[i]+b[i])%b[i];
        ans=(ans+qmul(qmul(tp,x,lcm),a[i],lcm))%lcm;//记得快速乘
    }
    return (ans+lcm)%lcm;
}

int main()
{
    k=read();
    for(int i=1;i<=k;++i) a[i]=read();
    for(int i=1;i<=k;++i) b[i]=read();
    for(int i=1;i<=k;i++) a[i]=(a[i]%b[i]+b[i])%b[i];
    cout<<china();
    return 0;
    //niiick
}
```

---

## 作者：lahlah (赞：45)

我扔：https://www.luogu.org/problemnew/show/P3868



# [在blog体验好很多哦（真的）](https://blog.csdn.net/qq_38944163/article/details/85677874)


### 题意
![233](https://i.loli.net/2019/01/03/5c2d6f94bdd9b.png)


就是求这个 $x$

裸的中国剩余定理，什么？你不知道中国剩余定理。好吧，我讲讲。

首先，看上面那一坨式子，要满足

#### $m_1, m_2, m_3, ...., m_k$两两互质 

那么我们设

$M = m1 \times m2 \times m3 \times .... \times mk$

$M_i = M / m_i$

则对于$x \equiv  a_i  (\mod  m_i)$, 我们可以先求出

$M_i$ 在 $\mod m_i$ 意义下的逆元（扩欧就行了）

设逆元为$M_i^{-1}$

可得$M_i \times M_i^{-1} \equiv  1 (\mod m_i)$ 

所以$a_i \times M_i \times M_i^{-1} \equiv  a_i (\mod m_i)$

又因为 $M_i = M / m_i$

所以对于所有的 $j \neq i$ ($j$ 不等于 $i$）

 $a_i \times M_i  \times M_i^{-1} \equiv 0(\mod m_j)$
 
 所以只需要把所有的 $a_i \times M_i \times M_i^{-1}$ 加起来就是答案了
 

```cpp
int crt(){
    int M = 1, x, y, ans = 0;
    for(int i = 1; i <= n; i ++) M = M * b[i]; //求M
    for(int i = 1; i <= n; i ++){
        int m = M / b[i]; //即Mi
        exgcd(b[i], m, x, y); //求逆元，求得为y
        ans =(ans + y * m * a[i]) % M;//累加答案
    }
    if(ans < 0) ans += M;//判断一下
    return ans;
}
```
那对于这题呢？

~~Ctrl + c  + Ctrl + v~~ 

直接套板子?

## ${\color{red} WA \ on \ \#10}$
## ${\color{white} WTF??}$
 # ？？？？
 注意题目中的一句话
 #### 所有数据中，第一组数字的绝对值不超过$10^9$（可能为负数），第二组数字均为不超过$6000$的正整数，且第二组里所有数的乘积不超过$10^{18}$
 # $10^{18}$ ??!!  乘起来不就 $10^{36}$ 爆long long辣
 
 那怎么办
 
 于是就~~翻题解~~学习了一个叫做快速乘的东西。
 
快速乘就是用来处理在爆long long ~~的边缘来回试探~~ 的乘法下要取模的一种~~骚~~操作

~~其实应该叫做龟速乘~~

核心思想就是把一个数按二进制拆分，然后一位一位对应乘。

看代码感性理解一下吧：
```cpp
int ksc(int a, int b, int mod){
	int ans = 0;
	for(;b; b >>= 1, a = (a + a) % mod) if(b&1) ans = (ans + a) % mod;
	//解释一下, 是把 b 按二进制位拆分， a = a + a 就是每次将 a 乘 2（b每次除2， a肯定要对应乘2嘛）
	//如果b当前位为1，就对答案有贡献
	return ans;
}
```
然后这题就解决了

# ${\color{red} ma?}$

## ${\color{blue} TLE \ on \ \# 2}$
# ${\color{white} WTF???}$
哦，忘记说了，~~由于出题人太毒瘤~~ 输入的$a_i$可能为负数，所以在做快速乘之前要把它转为正数


没了？

没了。

等等忘记贴代码了：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int exgcd(int a, int b, int &x, int &y){//扩欧 
	if(!b) {x = 1, y = 0; return a;}
	int d = exgcd(b, a % b, x, y);
	int t = x;
	x = y;
	y = t - a / b * y;
	return d;
}
int ksc(int a, int b, int mod){//快速乘 
	int ans = 0;
	for(;b; b >>= 1, a = (a + a) % mod) if(b&1) ans = (ans + a) % mod;
	return ans;
}
int a[15], b[15], n;
int crt(){
	int M = 1, x, y, ans = 0;
	for(int i = 1; i <= n; i ++) M = M * b[i];//算 M 
	for(int i = 1; i <= n; i ++){
		int m = M / b[i];
		exgcd(b[i], m, x, y);//求逆元 
		y = (y % b[i] + b[i]) % b[i];
		ans =(ans + ksc(y, ksc(m, (a[i] + M) % M, M), M) + M) % M;//快速乘，记得a[i]要转为正数 
	}
	if(ans < 0) ans += M;
	return ans;
}
 main(){
	scanf("%lld", &n);
	for(int i = 1; i <= n; i ++) scanf("%lld", &a[i]);
	for(int i = 1; i <= n; i ++) scanf("%lld", &b[i]);
	printf("%lld", crt());
	return 0;
}
```

## ${\color{white} enough?}$

 ~~我是不会告诉你们空白的地方还有字的~~


---

## 作者：cyffff (赞：14)

# P3868 [TJOI2009]猜数字
#### [_传送门_](https://www.luogu.com.cn/problem/P3868)

$\texttt{CRT}$ 的题怎么能不来乱搞呢？

这种写法很简单，思维难度也不高，也不需要用到快速乘。
## 思路
我们可以将题目中的要求转化为一个线性同余方程组：
$$\begin{cases}n\equiv a_1(\mod b_1)\\n\equiv a_2(\mod b_2)\\n\equiv a_3(\mod b_3)\\...\\n\equiv a_k(\mod b_k)\end{cases}$$
注意这里的 $a_i$ 要先对 $b_i$ 取模.

由于 $b_i$ 两两互质，我们~~显然地~~可以使用 $\texttt{CRT}$，但是不想写怎么办？

于是我们来乱搞。

我们依次处理每个同余条件，设现在处理到第 $i$ 个条件，最小的满足前 $i$ 条条件是数为 $s$.

显然，当 $i=1$ 时，$s=a_1$.

现在考虑推进至 $i=2$，如果 $s$ 已经与 $a_2$ 在模 $b_2$ 意义下同余，就不操作，继续跳到 $i=3$；否则，我们需要更新 $s$ 以满足条件 $2$，此时我们仍然要满足条件 $1$，于是我们就只能将 $s$ 加上 $b_1$ 的整数倍以满足条件 $2$.

同理当 $i=3$ 且 $s$ 不满足条件 $3$ 时，只能加上一个数 $l\equiv a_1(\mod b_1)$ 且 $l\equiv a_2(\mod b_2)$ 的整数倍.

所以，当处理第 $i$ 个条件时，$s$ 所能加上的只能是 $\texttt{lcm}(b_1,b_2,b_3,...,b_{i-1})$。因为 $\gcd(b_1,b_2,b_3,...,b_{i-1})=1$，所以 $\texttt{lcm}(b_1,b_2,b_3,...,b_{i-1})=\prod\limits_{j=1}^{i-1}b_j$.

由于满足条件时加数的次数不清楚（~~其实是我不会证~~），时间复杂度为 $O\texttt{(玄学能过)}$ .

接下来给出代码。

$Code:$
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
namespace IO{
	//read()
}using namespace IO;
ll a[11],b[11];
int main(){
	int n=read();
	for(int i=1;i<=n;i++){
		a[i]=read();
	}
	for(int i=1;i<=n;i++){
		b[i]=read();
		a[i]=(a[i]%b[i]+b[i])%b[i];
	}
	ll sum=b[1],ans=a[1];
	for(int i=2;i<=n;i++){
		for(;ans%b[i]!=a[i];ans+=sum);
		sum*=b[i];
	}
	printf("%lld",ans);
}
```
不过这种做法只能解决 $b$ 数组互质的情况，$b$ 数组不互质就只能安心写 $\texttt{EXCRT}$ 了。

再见了 $qwq$~

---

## 作者：FlashHu (赞：8)

90分WA第二个点的看过来！

简要介绍一下中国剩余定理

中国剩余定理，就是用来求解这样的问题：

假定以下出现数都是自然数，对于一个线性同余方程组（其中$\forall i,j\in[1,k],i\neq j,b_i$与$b_j$互质）

$\begin{cases}n\equiv a_1(\mod b_1)\\n\equiv a_2(\mod b_2)\\......\\n\equiv a_k(\mod b_k)\end{cases}$

设$lcm=\prod_{i=1}^kb_i$，那么此方程组在模$lcm$意义下有且仅有一个解$\sum_{i=1}^ka_ix_i\frac{lcm}{b_i}$，其中$\frac{lcm}{b_i}x_i\equiv1(\mod b_i)$

证明思路什么的看别的大佬的吧

那么就可以直接用扩欧或欧拉定理求$x_i$，轻松地得到结果。

由于直接乘的时候会爆longlong，所以要写快速乘，及时取模

可是还WA第二个点是怎么回事？

原来题目里说了$a_i$可能为负数！真是用(sang)心良(bing)苦(kuang)啊！

既然是模$b_i$意义下的，可以很快把它转成正数。
```
#include<cstdio>
#define LL long long
#define in(x) scanf("%lld",x)
#define add(a,b) a=(a+b)%s
LL k,a[11],b[11],i,x,y,t,s=1,ans=0;
void exgcd(LL a,LL b){//扩欧
	if(!b){x=1;y=0;return;}
	exgcd(b,a%b);
	t=x;x=y;y=t-a/b*y;
}
LL mul(LL a,LL b){//快速乘
	LL r=0;
	while(b){
		if(b&1)add(r,a);
		add(a,a);
		b>>=1;
	}
	return r;
}
int main(){
	in(&k);
	for(i=1;i<=k;++i)in(a+i);
	for(i=1;i<=k;++i)in(b+i),s*=b[i];//求lcm
	for(i=1;i<=k;++i){
		exgcd(s/b[i],b[i]);
		x=(x%b[i]+b[i])%b[i];//求xi最小非负整数解
		add(ans,mul(s/b[i]*x,(a[i]%b[i]+b[i])%b[i]));//别忘处理ai
	}
	printf("%lld\n",ans);
	return 0;
}
```
以上的main函数里，蒟蒻把$x_i,a_i$都化成了最小非负整数。实际上，同余的性质很好，用不着化来化去的。最精简的写法是这样
```
	for(i=1;i<=k;++i){
		exgcd(s/b[i],b[i]);
		add(ans,mul(s/b[i]*x,a[i]%b[i]+b[i]));
	}
```

---

## 作者：SIXIANG32 (赞：4)

一道中国剩余定理也就是 CRT 的裸题，但是出题人很 bjwd 搞出了奇奇怪怪的坑/baojin  
闲话少说，切入正题——  

---
题目求一个最小的满足以下这些约束条件的 $n$，且 $b$ 两两互质。
$$\begin{cases}b_1|(n - a_1)\\b_2|(n-a_2)\\\dots\\b_k|(n-a_k)\end{cases}$$


那么显然，对于每个条件 $b_i | (n - a_i)$，可以将其改写成 $b_i \times g + a_i = n$。  
我们不难把这个式子改成一个取余的式子。  
关系也就出来了，$n \equiv a_i \pmod{b_i}$。  
然后这个条件就能写成——  
$$\begin{cases} n \equiv a_1 \pmod{b_1}\\n\equiv a_2 \pmod{b_2}\\\dots\\n\equiv a_k \pmod{b_k} \end{cases}$$    
$b$ 两两互质。  
诶这不是 CRT 板子吗？  
然后我们就可以用 CRT 板子愉快的切掉这道水题。  

---
切了？不不不想多了。  
首先如果你把 P1495 这道题的代码改个输入搞进去会 WA on 10，因为最后一个点爆 long long 了，所以我们要用龟速乘。  
然后你就会发现单纯的用龟速乘改写计算式子后会 TLE 8 个点，因为 exgcd 求出的 $x$ 可能是负数。。。  
然后你仅仅把 $x$ 改成 $[(x \mod M + M) + M]\mod M$ 后发现会 T 掉一个点，最后你发现了一个条件——  

> $\left| a_i \right| \le 10 ^9$  

诶不是，绝对值，这个 $a_i$ 可能是个负数然后龟速乘的时候炸掉了？f***  
出题人，bjwd  
~~你的决心碎了一地~~

---
代码很简单，完全就是 CRT 板子。只要注意几个龟速乘的小细节就好了。  

```cpp
#include <cstdio>
#define int long long//long long，我懒所以 define 了一下
#define MAXN 100000
using namespace std;
int a[MAXN + 10], m[MAXN + 10], n;
int exgcd(int a, int b, int &x, int &y) {//exgcd 板子用于 CRT 求逆元
	if(!b) {
		x = 1, y = 0;
		return a;
	}
	else {
		int ret, temp;
		ret = exgcd(b, a % b, x, y);
		temp = x, x = y, y = temp - a / b * y;
		return ret;
	}
}
int mul(int a, int b, int M) {//万恶之源龟速乘
	int ans = 0;
	while(b) {
		if(b & 1) ans = (ans + a) % M;
		a = (a + a) % M, b >>= 1;
	}
	return ans;
}
int CRT(int n) {//CRT 板子
	int M = 1, x, y, ans = 0;
	for(int p = 1; p <= n; p++)
		M *= m[p];
	for(int p = 1; p <= n; p++) {
		x = y = 0;
		exgcd(M / m[p], m[p], x, y);
		int M_ = M / m[p]; x = ((x % M + M) + M) % M;//x 可能是负数
		ans = (ans + mul(mul(M_, a[p], M), x, M) + M) % M;//龟速乘改写后的式子
	}
	return (ans + M) % M;
}
signed main() {
	scanf("%lld", &n);
	for(int p = 1; p <= n; p++)
		scanf("%lld", &a[p]);
	for(int p = 1; p <= n; p++)
		scanf("%lld", &m[p]), a[p] = ((a[p] % m[p] + m[p]) + m[p]) % m[p];//a 也可能是负数
	printf("%lld", CRT(n));
}
```

---

## 作者：Isprime (赞：4)

中国剩余定理板子题。

由题意得 $\begin{cases}b_1 | (n-a_1)\\b_2 | (n-a_2)\\.......\\b_k | (n-a_k)\end{cases}$.

即 $\begin{cases}n-a_1\equiv 0(mod \; b_1)\\n-a_2\equiv 0(mod \; b_2)\\......\\n-a_k\equiv 0(mod \; b_k)\end{cases}$.

由此可得 $\begin{cases}n\equiv a_1(mod\; b_1)\\n\equiv a_2(mod\; b_2)\\......\\n\equiv a_k(mod\; b_k)\end{cases}$.

这不就是中国剩余定理模板吗？

但是此题有两个坑点，$a_i$ 可能为负数，也就是说，我们需要先预处理 $a_i$ 使得 $a_i>0$，根据mod的性质我们知道 $a_i\;mod\;b_i+b_i$一定为正数，也就是说，我们需要把每个 $a_i$ 处理为 $a_i\;mod\;b_i+b_i$，这样就解决了负数的问题。

第二，我们注意到本题的数据范围，如果求解时乘完后再取模会爆 `long long` ，这里我们用一种类似快速幂的算法快速乘（？龟速乘）来解决这个问题。我们知道快速幂的原理是将指数拆成若干 $2$ 的幂的和，再把这些乘积相乘得到结果。类似地，我们可以把一个因数拆成若干 $2$ 的幂的和，依次乘以另一个因数并取模，即可避免爆 `long long`。

这里不建议用 `__int128`，因为 N O I P 显然是用不了的。

Code

```cpp
#include <cstdio>
#define MAXK 15
#define int long long
using namespace std;
int k,m=1,ans;
int a[MAXK],b[MAXK],mi[MAXK];
inline int mul(int a,int b) {//快速乘
	int r=0;
	while(b) {//通过每次计算都取模来解决溢出问题
		if(b&1) r=(r+a)%m;
		a=(a+a)%m;
		b>>=1;
	}
	return r;
}
inline int exgcd(int a,int b,int &x,int &y) {//扩展欧几里得算法
	if(!b) {x=1; y=0; return a;}
	int d=exgcd(b,a%b,x,y);
	int z=x; x=y; y=z-y*(a/b);
	return d;
}
signed main() {
	scanf("%lld",&k);
	for(register int i=1;i<=k;++i) scanf("%lld",a+i);
	for(register int i=1;i<=k;++i) scanf("%lld",b+i),m*=b[i];
    for(register int i=1;i<=k;i++)
        a[i]=(a[i]%b[i]+b[i])%b[i];//a[i]可能为负数，需要预处理
	for(register int i=1;i<=k;++i) {//中国剩余定理
		mi[i]=m/b[i];
		int x=0,y=0;
		exgcd(mi[i],b[i],x,y);
        x%=b[i];
		if(x<0) x+=b[i];
		ans=(ans+mul(a[i],mi[i]*x))%m;
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：灵乌路空 (赞：3)

Updated on 2020.11.11：感谢 [@1lgorithm](https://www.luogu.com.cn/user/287355) 提出错误，并调整了初学 OI 时期的魔鬼排版。

$b_i$ 之间两两互质，可以用中国剩余定理求解，这里介绍使用扩展中国剩余定理求解。
   
[P4777 【模板】扩展中国剩余定理（EXCRT）](https://www.luogu.org/problemnew/show/P4777)
   
要解如下的同余方程组 ：
   
$$\begin{cases}x \equiv a_1\pmod {b_1}\\x \equiv a_2\pmod {b_2}\\......\\x \equiv a_n\pmod {b_n}\\\end{cases}$$
   
其中 , $a_i,b_i$为非负整数 ， $b_1,b_2,...,b_n$ 不一定互质
   
## 求解
   
假设已经求出了前 $k-1$ 个方程的解 $x_{k-1}$，设 $M=\operatorname{lcm}_{i=1}^{k-1} b_i$ , 即 $M$ 为前 $k-1$ 个模数 $b$ 的最小公倍数。   
则对于前 $k-1$个方程, 都满足$x_{k-1}+tM\equiv a_i\pmod {b_i}\ \ (t\in Z)$，即前 $k-1$ 个方程 , 通解为 $x_{k-1}+tM\ \ (t\in Z)$。
     
欲求得第 $k$ 个方程的解，并且求得的解，也满足前 $k-1$ 个方程，则需要使第 $k$ 个方程的解为前 $k-1$ 的方程的通解的同时，也满足第 $k$ 个方程的条件。
    
设第 $k$ 个方程的解 $x_k = x_{k-1}+tM\ \ (t\in Z)$，将此解代入第 $k$ 个方程中，可得：
$$x_{k-1}+tM\equiv a_k\pmod{b_k}$$   
即：  
$$tM\equiv a_k-x_{k-1}\pmod{b_k}$$

其中 $M,a_k,x_{k-1},b_k$ 都是已知的，使用 exgcd 解出此同余方程，即可以得到 $t$ 的值。    
将 $t$ 的值代回 $x_k = x_{k-1}+tM\ \ (t\in Z)$ ，就可得到$x_k$的值。进行 $k$ 次上述操作后 ，便可得到 方程组的解 。
     
## 本题坑点
 
如果只是开 `long long` 的话，取余时无论如何都会炸掉。   
为了避免变量爆破，要用一种叫做快速乘取余的奇(ba)妙(ka) 算法。   
其本质与快速幂取余类似，都是二进制的拆分应用。   
         
假设有 $k$ 个 $a$ 相乘，快速乘 将其分解成了 $a+ 2a + 4a+ ....$ 的形式，这样就可以边乘边取余，来防止变量爆破。    
但是却将乘法的时间复杂度 拉到了 $O(\log n)$ 级别。  

```cpp
ll mul(ll A,ll B,ll mod) //快速乘取余 模板
{
 	ll ans=0;
	while(B>0)
	{
		if(B & 1) ans=(ans+A%mod)%mod;
		A=(A+A)%mod;
		B>>=1;
	}
	return ans;
}
```

---

$a_i$ 可能为负数。  
      
扩展中国剩余定理只适用于  $a_i,b_i$ 非负的情况，要先将 $a_i$ 都转化为非负整数，只需要加这么一步操作即可：
       
```cpp
for(int i=1;i<=n;i++) a[i]=(a[i]+b[i])%b[i];
```
根据同余的性质，正确性显然。  
  
## 代码实现

```cpp
//扩展中国剩余定理模板 
//详见注释 
#include<cstdio>
using namespace std;
typedef long long ll;
ll n;
ll a[100010],b[100010]; 
ll mul(ll A,ll B,ll mod) //快速乘取余 模板
{
    ll ans=0;
    while(B>0)
      {
        if(B & 1) ans=(ans+A%mod)%mod;
        A=(A+A)%mod;
        B>>=1;
      }
    return ans;
}
ll exgcd(ll A,ll B,ll &x,ll &y) //扩展欧几里得 模板
{
    if(!B)
      {
        x=1,y=0;
        return A;
      }
    ll d=exgcd(B,A%B,x,y);
    ll tmp=x;
    x=y , y=tmp-A/B*y;
    return d;
}
ll lcm(ll A,ll B) //求最小公倍数
{
    ll xxx,yyy;
    ll g=exgcd(A,B,xxx,yyy);
    return (A/g*B);
}
ll excrt() //重点:求解同余方程组
{
    ll x,y;
    ll M=b[1],ans=a[1]; //赋初值 
    //M为前k-1个数的最小公倍数，ans为前k-1个方程的通解
    for(int i=2;i<=n;i++)
      {
        ll A=M,B=b[i];
        ll C=(a[i]-ans%B+B)%B; //代表同余方程 ax≡c(mod b) 中a,b,c

        ll g=exgcd(A,B,x,y);
        //求得A,B的最大公约数，与同余方程ax≡gcd(a,b)(mod b)的解，

        if(C%g) return -1; //无解的情况

        x=mul(x,C/g,B); //求得x的值,x即t 
        ans+=x*M;  //获得前k个方程的通解
        M=lcm(M,B); //更改M的值
        ans=(ans%M+M)%M;
      }
    return ans;
}
int main()
{
    scanf("%lld",&n);
    for(int i=1;i<=n;i++)
      scanf("%lld",&a[i]);
    for(int i=1;i<=n;i++)
      scanf("%lld",&b[i]);
    for(int i=1;i<=n;i++)
      a[i]=(a[i]+b[i])%b[i];
    ll ans=excrt();
    printf("%lld",ans);
}
```

---

## 作者：rain_forest (赞：2)

**题目大意**

给定整数序列$(a_i)_{i=1}^k,(b_i)_{i=1}^k$且
$$\forall i\ne j,\ \gcd(b_i,b_j)=1$$
求最小的自然数$n$使得对于所有的$i$均有$b_i|(n-a_i)$。

**解法**

依题意我们能得到一个同余方程组
$$\begin{cases}n-a_1\equiv 0\pmod {b_1}\\n-a_2\equiv 0\pmod {b_2}\\\qquad\vdots\\n-a_k\equiv 0\pmod {b_k}\end{cases}$$
稍加变形即有
$$\begin{cases}n\equiv a_1\pmod {b_1}\\n\equiv a_2\pmod {b_2}\\\qquad\vdots\\n\equiv a_k\pmod {b_k}\end{cases}$$
假设$n$能被表示为$\displaystyle\sum_{i=1}^kc_i$的形式，其中$c_i$满足$c_i \bmod b_i=a_i$且
$$\forall j\ne i,\ c_i \bmod b_j=0$$
于是我们自然而然地想到了$M=\displaystyle\prod_{i=1}^k b_i$的一些性质，显然$M_i=\frac{M}{b_i}$能够满足我们需要的第二条性质且所有以$M_i$为因子的数均能满足第二条性质，故我们可以令
$$c_i=a_iM_i[M_i]_{b_i}^{-1}$$
可以发现它能满足我们的需求。

这样我们就得到了上述同余方程组的一个特解，而我们不难发现$x$是该同余方程组的一个解的充要条件为
$$n-x\equiv 0\pmod M$$
于是这样我们就得到了这个同余方程组的所有解，而所求的$n$即为
$$n=(\sum_{i=1}^na_iM_i[M_i]_{b_i}^{-1})\bmod M$$

```cpp
#include<bits/stdc++.h>
#define ll long long
const int NR=11;
using namespace std;
ll mod(ll a,ll b)
{
    return (a%b+b)%b;//防止出负数
}
ll mul(ll a,ll b,ll m)//快速幂
{
    ll res=0,base=a;
    while(b){
        if(b&1)
            res=(res+base)%m;
        base=2*base%m;
        b>>=1;
    }return res;
}
ll exgcd(ll a,ll b,ll &x,ll &y)//扩欧求逆元
{
    if(!b){
        x=1,y=0;
        return 1;
    }ll X,Y;
    exgcd(b,a%b,X,Y);
    x=Y,y=X-(a/b)*Y;
    return x;
}
ll n,M=1,x,y,ans,a[NR],b[NR];
int main()
{
    scanf("%lld",&n);
    for(int i=1;i<=n;++i)
        scanf("%lld",a+i);
    for(int i=1;i<=n;++i)
        scanf("%lld",b+i),M*=b[i],a[i]=mod(a[i],b[i]);//先模一遍对答案不会有影响
    for(int i=1;i<=n;++i)
        ans=mod((ans+mul(mul(a[i],(M/b[i]),M),mod(exgcd(M/b[i],b[i],x,y),M),M)),M);//求答案
    printf("%lld\n",ans);
    return 0;
}
```


---

## 作者：loceaner (赞：2)

## 思路

> 中国剩余定理 + 快速乘

题目要求找到最小的$n$，满足对于$\forall i\in [1,k]$，有$b_i | (n-a_i)$

我们试着来转化一下这个式子

$b_i|(n-a_i)$，也就是说$(n-a_i)$在模$b_i$意义下同余$0$，即$n - a_i\equiv 0(\text{mod}\ b_i)$，进一步转化，就能得到$n\equiv a_i(\text{mod}\ b_i)$

这个式子是不是很眼熟？没错，就是中国剩余定理的式子，因为题目中已经保证了$b_i$两两互素，所以我们就可以直接套中国剩余定理的板子了

设$N=\prod_{i=1}^nb_i$，$Mi=N/b_i$，$x_i$是线性同余方程$M_ix_i≡1(\text{mod}\ b_i)$的一个解(即$Mi$的逆元)，最后的解即为$ans=\sum\limits_{i=1}^ka_iM_ix_i$

那么这样就完了嘛？

~~此题终结~~其实不然

这样交上去之后，会发现只有九十分，最后一个点$WA$了，因为这题要用快速乘，于是写上快速乘

那么这样就完了嘛？

~~此题终结~~其实也不然

又交上去之后，发现还是九十分，不过这次错的点是第二个了。

这是为什么呢？

看题目条件：$∣a_i∣≤10^9$

什么意思呢？意思就是$a_i$可能是负的！（出题人真是用心良苦

处理的方法就是：快速乘传参时取模

那么这样就完了嘛？

~~兴冲冲的~~交上去，终于满分了，没错，这次真完了

## 代码

```cpp
/*
Author:loceaner
中国剩余定理板子题 
*/
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define int long long
using namespace std;

const int A = 5e5 + 11;
const int B = 1e6 + 11;
const int mod = 1e9 + 7;
const int inf = 0x3f3f3f3f;

inline int read() {
	char c = getchar(); int x = 0, f = 1;
	for( ; !isdigit(c); c = getchar()) if(c == '-') f = -1;
	for( ; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);
	return x * f;
}

int n, N = 1, b[A], a[A], ans;

inline int mul(int n, int m, int mod) {
	int res = 0;
	while (m) {
		if (m & 1) res = (res + n) % mod;
		n = (n + n) % mod, m >>= 1;
	}
	return res;
}

inline void exgcd(int a, int b, int &x, int &y) {
	if (!b) x = 1, y = 0;
	else exgcd(b, a % b, y, x), y -= a / b * x;
}

signed main() {
	n = read();
	for (int i = 1; i <= n; i++) a[i] = read();
	for (int i = 1; i <= n; i++) b[i] = read(), N *= b[i];
	for (int i = 1; i <= n; i++) {
		int x, y, Mi = N / b[i];
		exgcd(Mi, b[i], x, y);
		ans = (ans + mul(mul(Mi, x % N + N, N), a[i] % N + N, N) % N + N) % N; 
	}
	cout << ans % N << '\n';
	return 0;
}
```



---

## 作者：xh2010 (赞：2)

一道经典的数论题，解线性同余方程组。

虽然数据量很小（估计爆搜也能过），但我还是写了一大段破破烂烂的代码。

回归主题，设s[i]为b[1],……,b[i]的最小公倍数，n[i]为前i个方程组的最小解，故

n[i]=n[i-1]+t\*s[i-1]与a[i]模b[i]同余，故要求t的最小值。

设phi(x)为欧拉函数，令y=phi(b[i])，由费马小定理知，t为(a[i]-n[i-1])\*(s[i-1]^(y-1))模b[i]的最小剩余数（可能有点绕，看代码就知道了）。

为防止越界和超时，我使用了快速幂和快速乘。

以下是我的代码：





    
    
```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<stack>
#include<queue>
#include<map>
#include<list>
#include<functional>
#include<vector>
#include<set>
#include<cctype>
#include<ctime>
#include<cstdlib>
#include<algorithm>
#define ll long long
using namespace std;
int k;
ll n[20],s[20],a[20],b[20];
ll phi(ll x)                                                  //计算欧拉函数
{
    int f[100];
    ll ans=1,t,i=1;
    while (x>1)
    {
        i++;
        if ((x%i)==0)
        {
            t=1;
            while ((x%i)==0)
            {
                t*=i;
                x/=i;
            }
            ans*=(t-t/i);
        }
    }
    return ans;
}
ll ji(ll u,ll v,ll w)                                    //快速乘
{
    ll t=0,y=u;
    while (v>0)
    {
        if ((v&1)==1) t=(t+y)%w;
        y=(y+y)%w;
        v>>=1;
    }
    return t;
}
ll mi(ll u,ll v,ll w)                                         //快速幂
{
    ll t=1,y=u;
    while (v>0)
    {
        if ((v&1)==1) t=ji(t,y,w);
        y=ji(y,y,w);
        v>>=1;
    }
    return t;
}
int main()
{
    scanf("%d",&k);
    for (int i=1;i<=k;i++)
        scanf("%lld",&a[i]);
    for (int i=1;i<=k;i++)
        scanf("%lld",&b[i]);
    memset(s,0,sizeof(s));
    memset(n,0,sizeof(n));
    s[0]=1;
    for (int i=1;i<=k;i++)
    {
        s[i]=s[i-1]*b[i];
        a[i]%=b[i];
        if (a[i]<0) a[i]+=b[i];
    }
    n[1]=a[1];
    for (int i=2;i<=k;i++)
    {
        ll x=a[i]-n[i-1];
        x%=b[i];
        if (x<0) x+=b[i];
        ll y=phi(b[i]);
        ll t=mi(s[i-1],y-1,b[i]);
        t*=x;
        t%=b[i];
        n[i]=n[i-1]+t*s[i-1];
    }
    printf("%lld",n[k]);
}

```

---

## 作者：Aw顿顿 (赞：1)

一道中国剩余定理的板子。

题目告诉我们对于任何一组 $b_i,b_j$ 都满足 $\gcd(b_i,b_j)=1$，所以我们应当敏感地想到这实际上应该是可以转化为同余方程的形式，而下文的 $b_i|(n-a_i)$ 更强化了这个理解。

于是我们可以把这个式子转化为 $n-a_i\equiv 0\pmod{b_i}$，进行简单的移项得到 $n\equiv a_i\pmod{b_i}$。列成同余方程组的形式就是：

$$\begin{cases}n\equiv a_1\pmod{b_1}\\n\equiv a_2\pmod{b_2}\\n\equiv a_3\pmod{b_3}\\\cdots\cdots\\n\equiv a_k\pmod{b_k}\\\end{cases}$$

你一看，发现这是[中国剩余定理 CRT](https://www.luogu.com.cn/blog/LinearExpectation/CRT-ExCRT)的裸题！

那么我们按照链接文章所示，写出代码提交，你会发现只能拿到 $90$ 分，实际上最后一个点爆了 `long long` 我们可能得使用龟速乘解决，并且在使用龟速乘的时候要注意一下 $a_i$ 可能为负数，因为题目给的数据范围是 $|a_i|\le 10^9$。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,a[99],m[99],al[99],mul=1,ans;
int gsc(int a,int b,int mod){
	int ans=0;
	while(b>0){
		if(b&1)ans=(ans+a)%mod;
		a=(a+a)%mod;
		b>>=1;
	}return ans;
}int Exgcd(int a,int b,int &x,int &y){
    if(!b){
        x=1,y=0;
        return a;
    }int d=Exgcd(b,a%b,x,y),t=x;
    x=y;
    y=t-(a/b)*y;
    return d;
}signed main(){
    scanf("%lld",&n);
    for(int i=1;i<=n;i++){
    	scanf("%lld",&a[i]);
    }for(int i=1;i<=n;i++){
    	scanf("%lld",&m[i]);
    	mul=mul*m[i];
    }for(int i=1;i<=n;i++){
        al[i]=mul/m[i];
        int x=0,y=0;
        Exgcd(al[i],m[i],x,y);
        if(x<0)x+=m[i];
        ans=(ans+gsc(x,gsc(
				al[i],(a[i]+mul)%mul,
			mul),mul)+mul)%mul;
    }printf("%lld\n",ans%mul);
    return 0;
}
```

---

## 作者：ListenSnow (赞：1)

### 题意
解线性同余方程组


$\left\{\begin{matrix} 
  x-a_1\equiv 0 \pmod {b_1}\\  
  x-a_2\equiv 0 \pmod {b_2}\\
  x-a_3\equiv 0 \pmod {b_3}\\
  ...\\
  x-a_k\equiv 0 \pmod {b_k}
\end{matrix}\right.$

### 思路

根据同余式变换法则:
如果 $a\equiv b\pmod m$成立，那么$a+c\equiv b+c\pmod m$也成立。
故可将方程组左右两边同时$+a_i$，得

$\left\{\begin{matrix} 
  x\equiv a_1 \pmod {b_1}\\  
  x\equiv a_2 \pmod {b_2}\\
  x\equiv a_3 \pmod {b_3}\\
  ...\\
  x\equiv a_k \pmod {b_k}
\end{matrix}\right.$

于是本题就成为了[中国剩余定理](https://www.luogu.com.cn/problem/P1495)的模板题。

### 细节

如果直接提交板子题的代码，会发现最后一个测试点一直过不去，那是因为~~良心出题人~~将数据特别大，以至于溢出了long long。。。于是本题需要运用龟速乘来防止溢出。具体使用技巧见代码。

### code:
```cpp
#include<cstdio>
using namespace std;
const int N=12;
#define int long long
int a[N],b[N],k,x,y,ans,M=1;
int exgcd(int &x,int &y,int a,int b)
{
	if(b==0)
	{
		x=1,y=0;
		return a;
	}
	int d=exgcd(x,y,b,a%b);
	int t=x;
	x=y,y=t-a/b*y;
	return d;
}
int gsc(int a,int b,int mod)
{
	int res=0;
	while(b)
	{
		if(b&1) res=(res+a)%mod;
		a=(a+a)%mod;
		b>>=1;
	}
	return res;
}
signed main()
{
	scanf("%lld",&k);
	for(int i=1;i<=k;i++) scanf("%lld",&a[i]);
	for(int i=1;i<=k;i++) scanf("%lld",&b[i]),M*=b[i];
	for(int i=1;i<=k;i++)
	{
		int m=M/b[i];
		x=0,y=0;
		exgcd(x,y,m,b[i]);
		x=(x%b[i]+b[i])%b[i];
		ans=(ans+gsc(gsc(a[i],m,M),x,M))%M;//这里用龟速乘就可以AC了 
	}
	printf("%lld\n",ans%M);
	return 0;
}
```


---

## 作者：Caicz (赞：1)

## [[TJOI2009]猜数字](https://www.luogu.com.cn/problem/P3868)

### 温馨提示：[在博客食用更佳](https://www.luogu.com.cn/blog/224229/solution-p3868)

本题所需算法：
> 中国剩余定理----[模板](https://www.luogu.com.cn/problem/P1495)

> 龟速乘

以下部分主要为[扩展中国剩余定理](https://www.luogu.com.cn/problem/P4777)的推导过程(与本题无关，不想看的可以直接跳过)
------------
首先我们要知道中国剩余定理的使用要求

即题目要求中可以化为一下方程组
$$
\left\{ 
\begin{array}{c}
x\equiv b_1(mod(a_1)) \\ 
x\equiv b_2(mod(a_2)) \\ 
x\equiv b_3(mod(a_3)) \\
 \dots\dots\dots  \\
x\equiv b_n(mod(a_n))
\end{array}
\right. 
$$

对于每对方程，我们可以得到
$$
	\left\{
	\begin{array}{c}
    x=b_a+k_a*a_a \\
    x=b_b+k_b*a_b
   \end{array}
   \right.
$$
联立化简一下
$$
    k_a*a_a+k_b*a_b=b_b-b_a
$$
对于这个式子，我们可以用exgcd 求出 满足要求的关于$x$特解$x_0$,那么可以得到以下式子
$$	
\left\{
	\begin{array}{c}
    x_0=b_a+k_a*a_a \\
    x=b_a+k_i*a_a \\
    k_i=n*\frac{a_b}{gcd(a_a,a_b)}+k_a(n\in Z)
   \end{array}
   \right.
	
$$
那么可以得到
$$
x=n*\frac{a_b*a_a}{gcd(a_a,a_b)}+k_a*a_a+b_a=n*lcm(a_a,b_a)+x_0(n\in Z)
$$
最后两个同余式就可以合并为
$$
	x\equiv x_0(mod(lcm(a_a,a_b))
$$

**回到中国剩余定理**，

由于模数 $P_i$都为质数，我们可以设
$n_i$是满足下面两个式子的最小正整数
$$

	\left\{
	\begin{array}{c}
    n_i\equiv b_i(mod(a_i))\\
    \frac{\prod_{j=1}^{k}{a_j}}{a_i}\mid n_i
   \end{array}
   \right.
$$
那么$\sum_{i=1}^k{n_i}$一定是满足条件一个解。
但是这并不是满足条件的最小值，所以我们还要在此基础上对$\prod_{j=1}^{k}{a_j}$取模

那么怎么计算$n_i$呢？
我们可以运用exgcd求出满足
$n_i\equiv 1(mod(a_i))$的$n_i$,那么可以得出 
$$
b_i*n_i\equiv b_i(mod(a_i)
$$
所以我们答案为


$$

	\left\{
	\begin{array}{c}
    ans=\sum_{i=1}^k{n_i*b_i}\\
    n_i\equiv 1(mod(a_i))
   \end{array}
   \right.
$$

代码实现
```cpp
inline ll china()
{
	ll W=1,k,z,w,ans=0;
	for(int i=1;i<=n;++i)W*=a[i];
	for(int i=1;i<=n;++i)
	{
		w=W/a[i];
		exgcd(w,a[i],k,z);
		ans=(ans+slow(slow(w,k,W),b[i],W))%W;
	}
	return ans=(ans+W)%W;
}
```


 ### 龟速乘

将乘法进行二进制拆分，分步取模防止单次乘法溢出,代码类似于快速幂，只需要将其中的乘法换成加法

代码实现
```cpp
inline ll slow(ll a,ll b,ll mod)
{
	ll ans=0;
	if(b<0)b=(b%mod+mod)%mod;\\如果 b 为负数，龟速乘可能会炸掉，所以先取模将b改为正整数
	while(b)
	{
		if(b%2)ans=(ans+a)%mod;
		b=b>>1;
		a=(a<<1)%mod;
	}
	return ans;
}
```
>> **Thanks for your reading**

---

## 作者：Lates (赞：1)

## 刚学CRT，来发一篇题解。

切入正题

很显然，对于每个
$$ b_i | (n-a_i)$$
都等价于
$$ n \equiv a_i \ (mod\ b_i)$$

所以这$k$个式子，就转化成了中国剩余定理的模型。

套板子即可。

然后你会发现WA90

因为所有$b_i$乘起来最大是$10^{18}$，所以再乘其他数就会爆long long。

怎么破？

可以用`__int128` 或 快（龟）速乘。

由于我懒（其实是不会龟速乘）,就打了`_int128`。

$Code$:

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
#define int __int128
template<class T>inline void read(T &x){
	x=0;
	register int f=0,ch=getchar();
	while('0'>ch||ch>'9')f^=ch=='-',ch=getchar();
	while('0'<=ch&&ch<='9')x=(x<<3)+(x<<1)+(ch^'0'),ch=getchar();
	x=f?-x:x;
}
template<class T>inline void print(T x){
	if(x<0)putchar('-'),x=-x;
	if(x>9)print(x/10);
	putchar(x%10+'0');
}
const int MAX=15; 
int n,M=1,m,p[MAX],a[MAX],inv,ans;
void exgcd(int a,int b,int &x,int &y){
	if(b==0){x=1,y=0;}
	else {
		exgcd(b,a%b,x,y);
		register int t=x;x=y;y=t-a/b*y;
	}
}
int res;
int x,y;
inline int CRT(){
	for(register int i=1;i<=n;++i){
		m=M/p[i];x=y=0;
		exgcd(m,p[i],x,y);
		ans=(ans+m%M*x%M*a[i]%M)%M;
	}
	ans=(ans%M+M)%M;
	return ans;
}
signed main(){
	read(n);
	for(register int i=1;i<=n;++i)read(a[i]);
	for(register int i=1;i<=n;++i)read(p[i]),M*=p[i];
	print(CRT()%M);
	return 0;
}


```


---

## 作者：noble_ (赞：1)

本题确实是中国剩余定理的裸题，但坑点在于本题最后一个点爆long long
那么蒟蒻就来发一个__int128的题解。

__int128数据范围是差不多 $ 2^{127} $左右，适合处理一下比long long大一点的数据。但是__int128不支持输入输出，输入一般就直接把题目给的数据强制转换一下，输出就自己手写一个。


但蒟蒻不是很懂__int128 noip 省选 noi可不可以用，有没有dalao愿意在评论里评论一下。。。。



---
## 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef __int128 ll;
const int maxn=1000000;
ll m[maxn], a[maxn];
void print(__int128 a){
	if(!a) return;
	print(a/10); putchar(a%10+'0');
}
void exgcd(ll a,ll b,ll& x,ll& y){
	if(!b){x=1;y=0;return;}
	else{ exgcd(b,a%b,y,x); y-=(a/b)*x; }
}
ll CRT(int n){
	ll M=1,ans=0;
	for(int i=1;i<=n;i++) M*=m[i];
	for(int i=1;i<=n;i++){
		ll q=M/m[i], x=0, y=0;
		exgcd(q,m[i],x,y); 
		ans=(ans+q%M*x%M*a[i]%M+M)%M;
	}
	return ans;
}
ll cal(ll a,ll b){
	while(a<0){ a+=b; }
	return (a+b)%b;
}
int main(){
	int n;scanf("%d",&n); long long z;
	for(int i=1;i<=n;i++){ scanf("%lld",&z);a[i]=(ll)z; }
	for(int i=1;i<=n;i++){ scanf("%lld",&z);m[i]=(ll)z; }
	for(int i=1;i<=n;i++){ a[i]=cal(a[i],m[i]); }
	__int128 x=CRT(n); 
	if(x!=0) print(CRT(n));  else puts("0");
	return 0;
}
```

来自蒟蒻noble_，我的博客：[传送门](http://www.cnblogs.com/noblex/)

---

## 作者：rsdbk_husky (赞：0)

## 零. 安利：

[安利一下我的博客。](https://rsdbkhusky.github.io/)

## 一. 思路

首先拿道题看到条件给出两组数，其中一组互素，让猜一个数字。自然而然往 **crt** 上想。但为什么是 **crt** 呢？

$\forall i \in [1,k]$，有 $b_i \mid (n - a_i)$，这句话可以化为一组同余方程，再移项可得标准的 **crt** 格式：
$$~~~~~~~~~~~~~~\begin{cases}n - a_1 \equiv 0 &(\operatorname{mod}~b_1) \\n - a_2 \equiv 0 &(\operatorname{mod}~b_2) \\\cdots \\n - a_k \equiv 0 &(\operatorname{mod}~b_k) \\\end{cases}$$

$$\Longrightarrow\begin{cases}
n \equiv a_1 &(\operatorname{mod}~b_1) \\
n \equiv a_2 &(\operatorname{mod}~b_2) \\
\cdots \\
n \equiv a_k &(\operatorname{mod}~b_k) \\
\end{cases}$$
然后 **crt** 求解就好了。**crt** ——中国剩余定理就是提供了一个解同余方程组 $\begin{cases}x \equiv a_1 &(\operatorname{mod}~m_1) \\ x \equiv a_2 &(\operatorname{mod}~m_2) \\ \cdots \\ x \equiv a_n &(\operatorname{mod}~m_n) \\ \end{cases}$ 的公式，即 $x = \sum\limits_{i = 1}^{n} \{ a_i \times M_i \times t_i \}$，其中 $M_i = \dfrac{\prod\limits_{j = 1}^{n}m_j}{m_i}$， $t_i = \operatorname{inv}(M_i)$。公式的推导详见 [OI-Wiki](https://oi-wiki.org/math/crt/)。

## 二. 坑点

交代码上去一看，为什么只有 90 分？最后一个点 WA 掉了，并且显示第一行第一列输出了减号。看来是爆 long long 了。所以需要~~龟速~~快速乘防止爆 long long。（本蒟蒻不会long double）

## 三. 代码

```cpp
#include<cstdio>
#define int long long
#define re register
const int MAXn = 10;

template <typename T>
inline T qmul(T x, T y, T mod) {
    if (x == 0 || y == 0) return 0;
    T ret = 0;
    while (y) {
        if (y & 1) ret = ((ret % mod) + (x % mod)) % mod;
        y >>= 1;
        x = ((x % mod) + (x % mod)) % mod;
    }
    return ret;
}

int exgcd(int a, int b, int &x, int &y) {
	if (!b) {
		x = 1; y = 0;
		return a;
	} else {
		int d = exgcd(b, a % b, y, x);
		y -= a / b * x;
		return d;
	}
}

int inv(int a, int m) {
	int k, inv;
	exgcd(a, m, inv, k);
	return (inv % m + m) % m;
}

int crt(int cnta, int *a, int *m) {
	int prod = 1, ans = 0;
	for (re int i = 1; i <= cnta; ++i) {
		prod *= m[i];
	}
	for (re int i = 1, M; i <= cnta; ++i) {
		M = prod / m[i];
		ans = (ans + qmul(qmul(a[i], M, prod), inv(M, m[i]), prod)) % prod;
	}
	return ans;
}

int n, a[MAXn + 10], m[MAXn + 10];
signed main() {
	scanf("%lld", &n);
	for (re int i = 1; i <= n; ++i) {
		scanf("%lld", &a[i]);
	}
	for (re int i = 1; i <= n; ++i) {
		scanf("%lld", &m[i]);
	}	
	printf("%lld\n", crt(n, a, m));
}
```



---

## 作者：Citnaris (赞：0)

# P3868 猜数字

**题目**

求最小的 $ans$ 使

$$m\left\{\begin{matrix} 
  \equiv a_1\ (mod\ m_1)\\  
  \equiv a_2\ (mod\ m_2)\\
  ......\\
  \equiv a_n\ (mod\ m_n)
\end{matrix}\right. $$

**分析**

设

$$T\ =\ \prod_{i\ =\ 1}^{n} m_i\ ,\ t_i\ (i \in [1,n])\ = \ T \ \div\ m_i$$ 

则根据 $\texttt{exgcd}$ ，我们可以构造出

$$∀\ e_i\ (i \in [1,n])\ \times\ t_i\ \equiv\ 1\ (mod\ m_i)$$

显然 

$$e_i\ \equiv\ 0\ (mod\ m_j)\ (∀\ i \ne j)$$

所以当

$$ans\ = \sum_{i\ =\ 1}^{n} a_i\times e_i\times t_i\ mod\ T$$

时，满足题目中的要求。

**Code**

```cpp
#include <cstdio>
#include <algorithm>

using namespace std;

const int NR = 15;
long long n, a[NR], m[NR], res;
long long T, t[NR], e[NR], MOD[NR];

inline long long __lcm(long long a, long long b)
{
	return a / __gcd(a, b) * b; 
}

inline long long EXGCD(long long a, long long b, long long &x, long long &y)
{
	if (b == 0)
	{
		x = 1, y = 0;
		return a;
	}
	long long x1, y1;
	long long d = EXGCD(b, a % b, x1, y1);
	x = y1, y = x1 - a / b * y1;
	return d;
}

inline long long MUL(long long x, long long y, long long p)
{
	if (x == 0 || y == 0) return 0;
	long long res = 0;
	for (; y; y >>= 1, x = (x << 1) % p)
	    if (y & 1)
		    res = (res + x) % p;
    return res;
}

inline long long CRT()
{
	long long tmp = MUL(MUL(a[1] % T, t[1] % T, T), e[1] % T, T);
	for (int i = 2; i <= n; i++)
	{
		long long p = MUL(MUL(a[i] % T, t[i] % T, T), e[i] % T, T);
		tmp = (tmp + p) % T;
	}
	return tmp;
}

inline void gets()
{
	long long x = 0, y = 0;
	T = 1, MOD[0] = 1;
	for (int i = 1; i <= n; i++)
	    T = __lcm(T, m[i]);
	for (int i = 1; i <= n; i++)
	    t[i] = T / m[i], EXGCD(t[i], m[i], x, y), e[i] = (x % m[i] + m[i]) % m[i], x = y = 0;
	return;
}

inline void read()
{
	scanf("%lld", &n);
	for (int i = 1; i <= n; i++)
	    scanf("%lld", &a[i]);
    for (int i = 1; i <= n; i++)
	    scanf("%lld", &m[i]);
	return;
}

int main()
{
    read();
	gets();
	res = CRT();
	printf("%lld\n", res);
	return 0;
}
```

---

## 作者：Zxsoul (赞：0)

EXCRT板子题目

前端知识：exgcd(Euclid扩展)

我的博客[数论知识](https://zxshetzy.blog.luogu.org/shuo-lun)

这里简单的证明一下扩展中国剩余定理（EXCRT）

方程组
$$

\begin{cases}
x\equiv a_1(\mod m_1)\\
x\equiv a_2(\mod m_2)
\end{cases}
$$


核心方程：

$a=um_1+a_1=vm_2+a_2$

$m=\operatorname{lcm}(m_1,m_2)$ ，$x\equiv a(\mod m)$

证明上面的式子（为什么是 $\operatorname{lcm}$）

令 $x=km+a$ ，$\because x\equiv a_1(\mod m_1) $ 并且 $a=um_1+a_1$ 

代换得
$$
km+um_1+a_1\equiv a_1(\mod m_1)
$$
  $\because$ 上述式子成立

所以 $km$ 满足 $km\equiv0（\mod m_1）$ ， 同理可证 $km=0(\mod m_2)$

所以 $km$ 是 $m1,m2$ 的倍数，不妨取$\operatorname{lcm}(m1.m2)$

即：$x\equiv a(\mod m)$

**如何求 $a$**

扩展欧几里得：$ um_1-vm_2=a_2-a_1$

mul(龟速加)

```c
ll mul(int a,int b,int p)
{
    int ret=0;
    for (;b;b>>=1,a=(a+a)%p)
        if (b&1) 
            ret=(ret+a)%p;
    return ret;
}
```
注/ 答案最后需要取摸，否则会不定时wa
```c
#include <cmath>
#include <queue>
#include <cstdio>
#include <vector>
#include <cstring>
#include <iostream>
#include <algorithm>
#define int long long
using namespace std;

//const int A = 1e7+10;
//const int B = 1e6+10;
const int LL = 1e7 + 7;
const int inf = 0x3f3f3f3f;

inline int read() {
  char c = getchar();
  int x = 0, f = 1;
  for ( ; !isdigit(c); c = getchar()) if (c == '-') f = -1;
  for ( ; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);
  return x * f;
}

int l[LL],b[LL],d,M,n,k,u,v,A,a,m;

void exgcd(int a,int b,int &d,int &x,int &y)
{
	if (b) exgcd(b,a%b,d,y,x),y-=x*(a/b);
	else d=a,x=1,y=0; 
}

int mul(int a,int b,int p)
{
	int res=0;
	for (;b;b>>=1,a=(a+a)%p)
		if (b&1) res=(res+a)%p;
	return res;
}

main()
{
	k=read();
	for (int i=1;i<=k;i++) l[i]=read();
	for (int i=1;i<=k;i++) b[i]=read();
	M=b[1],A=l[1];
	int cnt=2;
	while (cnt<=k)
	{
		a=l[cnt],m=b[cnt++];
		int B=((a-A)%m+m)%m;
		exgcd(M,m,d,u,v);
		u=mul(u,B/d,m);
		A+=M*u;
		M=M/d*m;
		A=(A+M)%M; 
	}
	printf("%lld",A%M);
}
```

---

## 作者：UnyieldingTrilobite (赞：0)

几乎是双倍经验······

由原式直接转化为$n\equiv a_i\pmod {b_i}$.

然后就是中国剩余定理板子。

**但窝不会。**

其实这种题还有另一种思路（提供一下）：分治（其实是伪的，一个一个算也可以）。

详细的可以见窝的[曹冲养猪](https://www.luogu.com.cn/blog/2007100723874wxz/solution-p1495)。

简要概述一下，先算前半部分，再算后半部分，最后两个式子合并。

要合并，只要求出两个膜数互相的逆元（为什么？见链接好了，或者自己思考，这并不难）。

逆元怎么算？欧拉定理，只需要求出膜数的欧拉函数值就珂以了。

线性筛肯定跑不够long long范围，怎么办？

~~凉拌。~~

每个膜数初始还不到10000（好像是？），珂以线性筛每个初始膜数的逆元。

然后维护欧拉函数，因为膜数都互质，缩以新欧拉函数就是原来的欧拉函数直接相乘。

Over.

并不是很详细，珂以见链接。

这种思路的代码（略长，但是分解下来每一步都很好写，而且没细节）：
```cpp
//快速幂会爆ll缩以上__int128
#include<bits/stdc++.h>
#define int __int128
using namespace std;
int Phi[1000009],prime[1000009],tot;
bool vis[1000009];
signed n;
int qpow(const int&a,const int&p,const int&tomod){
	if(!p)return 1;
	int h=qpow(a,p>>1,tomod);
	h=h*h%tomod;
	if(p&1)h=h*a%tomod;
	return h;
}
struct bind{
	int mod;
	int lft;
	int phi;
	friend bind operator * (const bind &x,const bind &y){
		int k=x.mod*y.mod,ret1=qpow(x.mod,y.phi,k),ret2=qpow(y.mod,x.phi,k);
		return (bind){k,(ret1*y.lft%k+ret2*x.lft%k)%k,x.phi*y.phi};
	}
}input[1000009];
void ola(){
	Phi[1]=1;
	for(int i=2;i<=1000000;++i){
		if(!vis[i])prime[++tot]=i,Phi[i]=i-1;
		for(int j=1;j<=tot&&prime[j]*i<=1000000;++j){
			vis[i*prime[j]]=1;
			if(i%prime[j])Phi[i*prime[j]]=Phi[i]*(prime[j]-1);
			else{
				Phi[i*prime[j]]=Phi[i]*prime[j];
				break;
			}
		}
	}
}
bind solve(const signed&l,const signed&r){
	return l==r?input[l]:solve(l,l+r>>1)*solve((l+r>>1)+1,r);
}
void write(int x){
	if(x>9)write(x/10);
	putchar(x%10|48);
}
signed main(){
	ola();
	cin>>n;
	for(signed i=1,j;i<=n;++i)cin>>j,input[i].lft=j;
	for(signed i=1,j;i<=n;++i)cin>>j,input[i]=(bind){j,input[i].lft%j,Phi[j]};
	write(solve(1,n).lft);
	putchar('\n');
    return 0;
}
```

---

## 作者：wyhwyh (赞：0)

# [TJOI2009]猜数字

## 中国剩余定理+龟速乘

这个大概就是中国剩余定理的板子题了啊。。。

## 中国剩余定理：

### 问题：

若$m_1,m_2...m_n,$是两两互质的正整数，

求解线性同余方程组：

$$f(n)=\begin{cases}
x\equiv a_1\pmod {m_1}\\
x\equiv a_2\pmod {m_2}\\
... ...\\
x\equiv a_n\pmod {m_n}\\
\end{cases}$$

的解$x$。

### 解法：

设$M=\prod_{i=1}^n,M_i=M/m_i$

$t$是同余方程$M_it_i\equiv 1\pmod {m_i}$的一个解

[关于怎么解同余方程](https://www.luogu.org/blog/wyhwyh/gcd-exgcd)

然后答案就是

$$x=\sum_{i=1}^n a_im_it_i$$

### 证明：

因为$M_i$是处$m_i$外所有数的倍数，所以

$$\forall k\not=i,a_iM_it_i\equiv 0\pmod {m_k}$$

而且

$$a_iM_it_i\equiv a_i\pmod {m_i}$$
$$x=\sum_{i=1}^na_iM_it_i$$

原方程成立。

### 通解：

$$x=\sum_{i=1}^n a_im_it_i$$

是问题的一个特殊解，通解为

$$x+kM(k\in Z)$$

#### 证明：

显然（大雾）

## 龟速乘：

$O(logn)$的其他题解里都有，很好理解，就不说了。

### $O(1)$的龟速乘：

当两个数乘起来爆 long long 的时候，需要用快速乘，虽然O(1)的比O(logn)的快了许多，但是他还是没有普通乘快，所以我叫他龟速乘qwq

**Code**

```cpp

inline ll qmul(ll x,ll y,ll mod)
{
    x%=mod;y%=mod;
    return ((x*y-(ll)(((long double)x*y+0.5)/mod)*mod)%mod+mod)%mod;
}

```

这个。。。也挺好理解啊，而且也没法解释啊qwq~~可意会不可言传~~

然后就是打板子了emmmm

**Code**

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
using namespace std;

typedef long long ll;
typedef long double ld;

const int N = 1e5+1;
ll n,ans;
ll M=1,Mi,a[N],m[N];

inline void file()
{freopen("text.in","r",stdin);freopen("text.out","w",stdout);}
inline void closefile()
{fclose(stdin);fclose(stdout);}

inline void readx(ll &x)
{
	x=0;int s=1;char ch=getchar();
	while(ch<'0'||ch>'9')
	{if(ch=='-') s=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')
	{x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
	x*=s;
}

inline ll qmul(ll x,ll y,ll mod)
{
    x%=mod;y%=mod;
    return ((x*y-(ll)(((long double)x*y+0.5)/mod)*mod)%mod+mod)%mod;
}

inline void exgcd(ll a,ll b,ll &x,ll &y)
{
	if(b==0) {x=1;y=0;return;}
	exgcd(b,a%b,y,x);
	y=y-a/b*x;
}

inline void china()
{
	for(ll i=1;i<=n;++i) readx(a[i]);
	for(ll i=1;i<=n;++i)
	{
		readx(m[i]);
		a[i]=(a[i]%m[i]+m[i])%m[i];
		M*=m[i];
	}
	for(ll i=1;i<=n;++i)
	{
		Mi=M/m[i];
		ll x,y;
		exgcd(Mi,m[i],x,y);
		x=(x%m[i]+m[i])%m[i];
		ans=((ans+qmul(qmul(a[i],x,M),Mi,M)%M)+M)%M;
	}
	ans=(ans+M)%M;
	printf("%lld\n",ans);
}

int main()
{
//	file();

	readx(n);
	china();

//	closefile();
	return 0;
}

```

---

## 作者：eee_hoho (赞：0)

**中国剩余定理的裸题**

题目要求的是最小的非负整数$n$满足$b_{i}|n-a_{i}(1\le i\le k)$

将其转化成同余问题的方程组

$\begin{cases}n&\equiv &a_{1}(mod\ b_{1})\\n&\equiv &a_{2}(mod\ b_{2})\\n&\equiv &a_{3}(mod\ b_{3})\\…&…&\\n&\equiv &a_{k}(mod\ b_{k})\end{cases}$

那么如何去求呢，这就要用到**中国剩余定理**了

我们设$M=\prod_{i=1}^{n}b_{i}$，$m_{i}=M/b_{i}$

$x_{i}$是方程$m_{i}\times x_{i}\equiv 1(mod\ b_{i})$的一个解，可以由扩展欧几里得算法求得

那么答案$n$就为$\sum_{i=1}^{n}a_{i}\times m_{i}\times x_{i}$

为什么呢，我们来证明一下

因为$m_{i}=M/b_{i}$是除了$b_{i}$之外的所有$b$的积

所以$\forall k\ne i,a_{i}\times m_{i}\times x_{i}\equiv 0(mod\ m_{k})$

由$t_{i}$是方程$m_{i}\times x_{i}\equiv 1(mod\ b_{i})$，的一个解得$a_{i}\times m_{i}\times x_{i}\equiv a_{i}(mod\ b_{i})$

代入$n=\sum_{i=1}^{n}a_{i}\times m_{i}\times x_{i}$，原方程组成立。

而我们要求的是最小非负整数解，那么只需要将$n$取模$M$使其落在0~M-1的范围内即可。

这道题的坑点在于直接相乘的话会爆$long\ long$，那么就需要用到快速乘了，思想跟快速幂一样，写起来也很简单

还有一点就是对于负数的情况要加上$M$再模$M$

**Code**
``` cpp
#include <iostream>
#include <cstdio>
#define int long long
using namespace std;
int k,a[20],b[20],M=1,ans;
void exgcd(int a,int b,int &x,int &y) //扩展欧几里得算法求线性同余方程的解
{
	if (!b)x=1,y=0;
	else
	{
		exgcd(b,a%b,x,y);
		int t=x;
		x=y;
		y=t-a/b*y;
	}
}
int cc(int x,int y)  //快速乘
{
	int s=0;
	x=(x%M+M)%M;    
	y=(y%M+M)%M;    //先将负数转化为正数
	while (y)
	{
		if (y&1)s=(s+x)%M;
		x=x*2%M;
		y>>=1;
	}
	return s;
}
signed main()
{
	cin>>k;
	for (int i=1;i<=k;i++)
		cin>>a[i];
	for (int i=1;i<=k;i++)
		cin>>b[i],M*=b[i];
	for (int i=1;i<=k;i++)
	{
		int m=M/b[i],x=0,y=0;
		exgcd(m,b[i],x,y);
		ans=(ans+cc(cc(a[i],m),x))%M;		
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：newbiechd (赞：0)

CRT模板。其他用CRT写的大佬似乎要么用了手写×，要么用了int__128。我只是想说不要忘了unsigned long long。零风险，常数小，还省事，适合追(xi)求(huan)卓(tou)越(lan)的oier们！
```cpp
#include<cstdio>
#include<cctype>
#define R register
#define I inline
#define L unsigned long long
using namespace std;
const int S=13;
char buf[1000000],*p1,*p2;
I char gc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,S,stdin),p1==p2)?EOF:*p1++;}
I int rd(){
	R int f=0,b=1; R char c=gc();
	while((c<48||c>57)&&c!=45) c=gc();
	if(c==45) b=0,c=gc();
	while(c>47&&c<58) f=f*10+(c^48),c=gc();
	return b?f:~f+1;
}
int a[S],b[S],k;
void exgcd(L a,L b,L &x,L &y){
	if(b) exgcd(b,a%b,y,x),y-=a/b*x;
	else x=1,y=0;
}
L crt(){
	L o=0,p=1,t,x,y;
	R int i;
	for(i=1;i<=k;++i)
		p=p*b[i];
	for(i=1;i<=k;++i)
		t=p/b[i],exgcd(t,b[i],x,y),x=(x+b[i])%b[i],o=(o+t*x%p*a[i])%p;
	return (o+p)%p;
}
int main(){
	R int i;
	for(k=rd(),i=1;i<=k;++i)
		a[i]=rd();
	for(i=1;i<=k;++i)
		b[i]=rd(),a[i]=(a[i]+b[i])%b[i];
	printf("%lld",crt());
	return 0;
}

```

---


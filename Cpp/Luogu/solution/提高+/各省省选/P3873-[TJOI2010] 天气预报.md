# [TJOI2010] 天气预报

## 题目描述

A 公司的天气预报系统的原理如下：用一个大于等于 $0$，小于等于 $4146$ 的整数来表示这一天的天气情况，在预测未来某一天的天气情况时，要根据此前 $n$ 天的天气情况来预测，如果用 $w_i$ 表示第 $i$ 天的天气情况（$i>n$），那么 $w_i=(a_1\times w_{i-1}+a_2\times w_{i-2}+\cdots+a_{n}\times w_{i-n})\mod4147$，其中 $a_1,a_2,\cdots ,a_n$ 是已知常数。现给出前 $n$ 天的天气情况，问第 $m$ 天的天气预测结果是什么。

## 说明/提示

$1\le n\le 100$，$n<m\le10^7$，$0\le a_i,w_i\le 4146$。

每个测试点时限 1.5 秒

## 样例 #1

### 输入

```
2 3
4 5
6 7
```

### 输出

```
59```

# 题解

## 作者：ZqlwMatt (赞：10)

题意：给定常数$a_{i}$，$w_{i}$ $(i=1$~$n)$，及递推式：$w_{k}=\sum_{i=1}^{n} a_{i}×w_{k-i}$ 给出一个$m$求$a_{m}$。

**说句~~废话~~**：然而前3个过这道题的都是同机房的（#逃。

---

**解法一：**

>构造矩阵+矩阵快速幂

- 矩阵构造如下：（我们可以将递推式转换一下......

$\begin{pmatrix}w_{n} & w_{n-1} & ... & ... & w_{i+1} & w_{i}\end{pmatrix}×\begin{pmatrix}a_{1} & 1 & 0 & 0 & 0 & 0\\ a_{2} & 0 & 1 & 0 & 0 & 0\\ ... & 0 & 0 & ... & 0 & 0\\ ... & 0 & 0 & 0 & ... & 0\\a_{n-1} & 0 & 0 & 0 & 0 &1\\ a_{n} & 0 & 0 & 0 & 0 & 0\end{pmatrix}=\begin{pmatrix}w_{n+1} & w_{n} & ... & ... & w_{i+2} & w_{i+1}\end{pmatrix}$


将递推式转换成矩阵，然后利用快速幂可以大大优化递推效率。。。

时间复杂度：Θ$(n^{3}×log$ $m)$

[评测详情:R6166875](https://www.luogu.org/record/show?rid=6166875)

**Time: 340ms / Memory: 2089KB**

```cpp
// luogu-judger-enable-o2
#include<cstdio>
#include<cstring>
#define re register int
#define rep(i,a,b) for(re i=(a);i<=(b);++(i))
const int N=101,p=4147;
int n,m,w[N],x;
struct Matrix{
    int k[N][N];
    Matrix(){
        memset(k,0,sizeof(k));
    }
    inline void Memset(){rep(i,1,n)k[i][i]=1;}
}res;
Matrix operator *(Matrix a,Matrix b){
    Matrix rhy;
    rep(i,1,n)
        rep(j,1,n){
            rep(z,1,n)
      			rhy.k[i][j]+=a.k[i][z]*b.k[z][j];
      		rhy.k[i][j]%=p;
      	}
    return rhy;
}
Matrix qmod(Matrix a,int k){
    Matrix tmp;
    tmp.Memset();
    while(k){
        if(k&1)	tmp=tmp*a;
        a=a*a;
        k>>=1;
    }
    return tmp;
}

int main(){
    scanf("%d%d",&n,&m);
    rep(i,1,n)	scanf("%d",w+i);
    rep(i,1,n-1)	res.k[i][i+1]=1;
    rep(i,1,n){
        scanf("%d",&x);
        res.k[i][1]=x;
    }
    res=qmod(res,m-n);
    int ans=0;
    rep(i,1,n)
        ans=(ans+res.k[i][1]*w[i])%p;
    printf("%d\n",ans);
}
```

解法二：

> 暴力递推+吸氧优化（#一本正经

时间复杂度：Θ$(n×m)$

[评测详情:R6158787](https://www.luogu.org/record/show?rid=6158787)

**Time: 10968ms / Memory: 39878KB**

```cpp
// luogu-judger-enable-o2
#include<cstdio>
#define re register int
#define rep(i,a,b) for(re i=(a);i<=(b);++(i))
int n,m,a[102],w[10000002];
int main(){
    scanf("%d%d",&n,&m);
    rep(i,1,n)	scanf("%d",w+n+1-i);
    rep(i,1,n)	scanf("%d",a+i);
    rep(i,n+1,m){
        rep(z,1,n)
            w[i]+=a[z]*w[i-z];
        w[i]%=4147; 
    }
    printf("%d",w[m]);
}
```

---

---

## 作者：黑影洞人 (赞：1)

题目已经描述的很清楚了，唯一要注意的是 $w$ 数组读入倒序，后面要处理一下。

切入正题：

本题是求递推式第 $m$ 项，我们直接根据题意模拟，可以打出 $O(nm)$ 暴力，即使开 O2 可以水过，但是这样不好玩。

于是我们用矩阵加速来做这道题。

状态矩阵由题意可知：

$\begin{bmatrix} 
	w_1 
\\  w_2
\\  w_3
\\  ...
\\  w_{n-1}
\\  w_n
\end{bmatrix}\quad$

进行一次乘法，将得到以下矩阵：

$\begin{bmatrix}  
   w_2
\\  w_3
\\  w_4
\\  ...
\\  w_n
\\  w_{n+1}
\end{bmatrix}\quad$

最后一行就是本题给的递推式：

$w_{n+1}=\sum_{i=1}^{n}a_i \times w_{n-i}$

再根据矩乘的定义，推导出转移矩阵：

$\begin{bmatrix} 
	0 & 1 & 0 & ... & 0
\\	0 & 0 & 1 & ... & 0
 \\  ...& ...&...&...&...
 \\	a_n & a_{n-1} & a_{n-2} & ... & a_1
\end{bmatrix}\quad$

为了方便读者调试，下面给出关键的构造矩阵的代码：(我把矩阵包装在结构体里了，所以略显怪异)

```cpp
void set1(){//转移矩阵
	memset(m,0,sizeof(m));
	for(int i=1;i<n;i++)m[i][i+1]=1;
	for(int i=1;i<=n;i++)m[n][i]=a[n-i+1];
}
void set2(){//初始状态
	memset(m,0,sizeof(m));
	for(int i=1;i<=n;i++)m[i][1]=w[n-i+1];
}
```
完结撒花

管理员同志审核题解辛苦了

---

## 作者：rui_er (赞：1)

已知 $a_{1\cdots n}$ 和 $w_{1\cdots n}$，定义 $w_i=\sum\limits_{j=1}^na_jw_{i-j}\bmod 4147\ (i>n)$，求 $w_m$。

看着感觉很像广义斐波那契那种东西，考虑对递推式进行转化，构造矩阵出来用快速幂加速。

发现求出 $w_i$ 需要 $w_{i-1\cdots i-n}$，这些东西肯定要放到行向量中，那么行向量就是：

$$
W_{i-1} = \begin{pmatrix}
w_{i-1} & w_{i-2} & \cdots & w_{i-n}
\end{pmatrix}
$$

那么我们需要构造 $A$ 使得 $W_{i-1}A=W_i$，对着上面递推式和矩阵乘法的运算规则，可以写出下式：

$$
\begin{pmatrix}
w_{i-1} & w_{i-2} & \cdots & w_{i-n}
\end{pmatrix}
\begin{pmatrix}
a_1 & 1 & 0 & \cdots & 0 & 0 \\
a_2 & 0 & 1 & \cdots & 0 & 0 \\
a_3 & 0 & 0 & \cdots & 0 & 0 \\
\vdots & \vdots & \vdots & \ddots & \vdots & \vdots \\
a_{n-1} & 0 & 0 & \cdots & 0 & 1\\
a_n & 0 & 0 & \cdots & 0 & 0
\end{pmatrix}
=
\begin{pmatrix}
w_i & w_{i-1} & \cdots w_{i-n+1}
\end{pmatrix}
$$

也就是 $W_{i-1}A=W_i$。我们已知 $W_n$，所以 $W_m=W_nA^{m-n}$，套矩阵快速幂即可。

```cpp
// Problem: P3873 [TJOI2010]天气预报
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P3873
// Memory Limit: 125 MB
// Time Limit: 1500 ms
// 
// Powered by CP Editor (https://cpeditor.org)

//By: OIer rui_er
#include <bits/stdc++.h>
#define rep(x,y,z) for(int x=(y);x<=(z);x++)
#define per(x,y,z) for(int x=(y);x>=(z);x--)
#define debug printf("Running %s on line %d...\n",__FUNCTION__,__LINE__)
#define fileIO(s) do{freopen(s".in","r",stdin);freopen(s".out","w",stdout);}while(false)
using namespace std;
typedef long long ll;
const int N = 105, mod = 4147;

int n, m;
template<typename T> void chkmin(T& x, T y) {if(x > y) x = y;}
template<typename T> void chkmax(T& x, T y) {if(x < y) x = y;}
struct Matrix {
	int n, m, a[N][N];
	Matrix(int x=0, int y=0) : n(x), m(y) {
		memset(a, 0, sizeof(a));
	}
	void e() {
		assert(n == m);
		rep(i, 1, n) a[i][i] = 1;
	}
	friend Matrix operator * (const Matrix& a, const Matrix& b) {
		assert(a.m == b.n);
		Matrix c(a.n, b.m);
		rep(i, 1, a.n) {
			rep(j, 1, b.m) {
				rep(k, 1, a.m) {
					c.a[i][j] += a.a[i][k] * b.a[k][j] % mod;
					c.a[i][j] %= mod;
				}
			}
		}
		return c;
	}
	friend Matrix operator ^ (Matrix a, int k) {
		assert(a.n == a.m);
		Matrix ans(a.n, a.m);
		ans.e();
		for(;k;k>>=1,a=a*a) if(k & 1) ans = ans * a;
		return ans;
	}
};

int main() {
	scanf("%d%d", &n, &m);
	Matrix w(1, n), a(n, n);
	rep(i, 1, n) scanf("%d", &w.a[1][i]);
	rep(i, 1, n) scanf("%d", &a.a[i][1]);
	rep(i, 2, n) a.a[i-1][i] = 1;
	a = a ^ (m - n);
	w = w * a;
	printf("%d\n", w.a[1][1]);
	return 0;
}
```

---

## 作者：123hh2 (赞：1)

[传送门](https://www.luogu.com.cn/problem/P3873)

---

### 前言

**大家写矩阵的时候一定要记得先初始化，不然会出蹦些奇怪的 WA。**

[更好的阅读体验](https://lvjianqiang.blog.luogu.org/#)

---

### 题目大意

给了你 $w[i]$ 和 $a[i]$ 的前 $n(n \le 100)$ 项，并给了你一个递推关系 $w[i] = \sum_{j = i - n} ^ {i - 1} w[i] \times a[j + n - i + 1] $

求第 $m(m \le 10^7)$ 项模 $4147$ 的结果。

---

### 分析

首先考虑一下暴力。

递推求解第 $m$ 项，每次枚举 $2 \times n$ 个数。

复杂度为 $O(nm)$。

显然过不去（可能我的常数太大，没过去，但是题解区有人暴力 + 吸氧过了。

然后发现既然 $m$ 这么大， $n$ 也还小，可以考虑一下矩阵加速递推。

考虑这样一个矩阵：

$$
\begin{bmatrix}
	w_n & w_{n-1} & \cdots & w_{1}\\
\end{bmatrix}
$$

现在我们要用他推出

$$
\begin{bmatrix}
	w_{n+1} & w_n & \cdots & w_2\\
\end{bmatrix}
$$

那么可以构利用 题目大意 中的递推式，构造一个 $n \times n$ 的 递推矩阵。

大概长这样：

$$
\begin{bmatrix}
	a_1 & 1 & 0 &0\\
    \vdots & 0 & \ddots & 0\\
    \vdots & 0 & 0 & 1\\
    a_n & 0 & \cdots & 0
\end{bmatrix}
$$

用语言文字描述就是该矩阵的第一列的第 $i$ 行为 $a_i$，第 $j$ 行的第 $j+1$ 列为 $1$，其中 $i \in [1,n],j \in [1,n-1]$。

然后如果我们要求第 $m$ 的话，因为是从第 $n$ 项开始递推的，所以我们只需要求递推矩阵的 $m-n$ 次方就行了。

特殊的，对于 $m \le n$ 的 情况，直接输出就好了。

----

### 代码

代码很好写，就是矩阵快速幂板子。


```cpp
//you have no way to return
#include<bits/stdc++.h>
// #include<Windows.h>
#define int long long
#define ri register
using namespace std;
inline int read()
{
	int x=0,f=1;char ch=getchar();while(ch>'9'||ch<'0') {if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') {x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}return x*f;
}
inline void write(int x) {if(x<0) {x=-x;putchar('-');}if(x>9) write(x/10);putchar(x%10+'0');}
const int maxn=101,mod=4147;int n,m;
struct A {int awa[maxn][maxn];}bg,base;
A operator *(const A &a,const A &b)
{
	A ans;int r=0;
	for(ri int i=1;i<=n;i++) for(ri int j=1;j<=n;j++) ans.awa[i][j]=0;
	for(ri int i=1;i<=n;i++)
	{
		for(ri int k=1;k<=n;k++)
		{
			r=a.awa[i][k];
			for(ri int j=1;j<=n;j++)
			{
				ans.awa[i][j]+=r*b.awa[k][j],ans.awa[i][j]%=mod;
			}
		}
	}
	return ans;
}
A operator ^(const A &a,int k)
{
	A res;
	for(ri int i=1;i<=n;i++) for(ri int j=1;j<=n;j++) res.awa[i][j]=0;
	for(ri int i=1;i<=n;i++) res.awa[i][i]=1;
	while(k)
	{
		if(k&1) res=res*base;
		base=base*base,k>>=1;
	}
	return res;
}
signed main()
{
	n=read(),m=read();m=max(0ll,m-n);
	for(ri int i=1;i<=n;i++) for(ri int j=1;j<=n;j++) bg.awa[i][j]=base.awa[i][j]=0;
	for(ri int i=1;i<=n;i++) bg.awa[1][i]=read();
	for(ri int i=1;i<=n;i++) base.awa[i][1]=read();
	for(ri int i=2,j=1;i<=n;i++,j++) base.awa[j][i]=1;
	base=base^m;bg=bg*base;
	write(bg.awa[1][1]);
	return 0;
}
```


---

## 作者：Leap_Frog (赞：1)

# P3873[TJOI2010]天气预报（题解）

## PS.
**这是一道经典的卡常好题，没错，你没有听错，这道题用卡常是完全能卡过去的！！！**  
时间复杂度$\texttt{O(n*m)}$，竟然能卡过去，有图有真相，（不要在意奇怪的主题）  
用$\texttt{O(2)}$优化：  
![](https://cdn.luogu.com.cn/upload/image_hosting/8gqwfaga.png)  
不用$\texttt{O(2)}$优化：  
![](https://cdn.luogu.com.cn/upload/image_hosting/uwfs719q.png)  
用$\texttt{O(3)}$优化
![](https://cdn.luogu.com.cn/upload/image_hosting/thjfiwwi.png)  

## Solution.
暴力$\texttt{O(n*m)}$模拟，按照题中所给的公式做。  

## Coding.
```cpp
#include<bits/stdc++.h>
#pragma GCC optimize(2)
#define ri register int		//卡常1：加rigister
using namespace std;
int n,m,a[105],w[10000005];
int main()
{
	scanf("%d%d",&n,&m);
	for(ri i=1;i<=n;i++) scanf("%d",w+n+1-i);
	for(ri i=1;i<=n;i++) scanf("%d",a+i);
	for(ri i=n+1;i<=m;i++)
	{
		for(ri j=1;j<=n;j++) w[i]+=a[j]*w[i-j];
		w[i]%=4147;		//卡常2：尽量少mod
	}
	return printf("%d\n",w[m]),0;
}
```

---

## 作者：Zijun_Xu (赞：1)

- 此题虽然N只有10^2，但是M有10^7。
- 如果用暴力，则时间复杂度为O(nm),最多O(10^9),而电脑1s内只能执行k * 10^8个a=a的语句(k大约为2)。每个测试数据都很~~小~~大，暴力开臭氧O3全部超时(应该数据加强~~或自己运气不好~~)。

- 回想到因为兔子数列有明确的递推式\
F(n)=F(n-1)+F(n-2)能用矩阵完成，于是……
-------------------------------------------------------
# **矩阵快速幂**
-------------------------------------------------------
#### 闪亮登场!
1. 推算矩阵:由题意得\
\
**w[i] = (a[1] * w[i-1] + a[2] * w[i-2] + … +a[n] * w[i-n]) % 4147**\
\
是对应的关系并汇集在一点，就是矩阵乘法。于是我们就可以把w[i-1]~w[i-n]从上往下写，a[1]~a[n]从左往右写，以上两条直线的交点即为w[i]。剩下的就是把w[i-2]~w[i-n]变成w[i-1]~w[i-n+1]了。方法：依次对应，要留下的填1，否则填0。{mat[i+1][i]=1}
2. 以上矩阵的(m-n)次方再乘w的那一列输出左上角的那一个就完了。(注意顺序)\
听说其他人都重载过运算符，可是我没有具体学过，就AC了。
## CODE:
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[105],w[105],n,m;
struct matrix{
	int mat[110][110];
}matr,ix;
matrix cheng(matrix p,matrix q)
{
	matrix e;
	int ii,jj,kk;
	memset(e.mat,0,sizeof(e.mat));
	for(ii=1;ii<=n;ii++)
	{
		for(jj=1;jj<=n;jj++)
		{
			for(kk=1;kk<=n;kk++)
			{
				e.mat[ii][jj]+=p.mat[ii][kk]*q.mat[kk][jj];
				e.mat[ii][jj]%=4147;
			}
		}
	}
	return e;
}
matrix quickpow(matrix x,int y)
{
	matrix ans;
	int ll;
	for(ll=1;ll<=n;ll++) ans.mat[ll][ll]=1;
	while(y)
	{
		if(y&1)ans=cheng(ans,x);
		x=cheng(x,x);
		y>>=1;
	}
	return ans;
}
int main()
{
	scanf("%d%d",&n,&m);
	int i;
	for(i=1;i<=n;i++)
	{
		scanf("%d",&w[n-i+1]);
		ix.mat[i][1]=w[n-i+1];
	}
	for(i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		matr.mat[1][i]=a[i];
	}
	for(i=1;i<=n-1;i++) matr.mat[i+1][i]=1;
	matr=quickpow(matr,m-n);
	ix=cheng(matr,ix);
	printf("%d\n",ix.mat[1][1]);
	return 0;
}
                       
```
- 时间复杂度O( n^3 * log2 m )最多0.24亿，不用担心超时的问题。
### 预祝大家七夕节快乐。

---

## 作者：TheShadow (赞：1)

- ~~这题输入数据好坑啊。。~~
### 本题解是给像我一样的蒟蒻写的，可能略显啰嗦，已经懂了的大佬可以出门右转，~~去切掉IOI~~
- 我们先分析题目，将每一个$w_i$，它的计算方式写成如下方式：
- $w_i=a_1*w_{i-1}+a_2*w_{i-2}+\cdots+a_n*w_{i-n}$
- 再注意到题中的这句话：
#### a1, a2, ..., an是已知常数
- 所以这是一个常系数的线性递推方程。很自然的，对于这种方程，我们可以想到直接$O(nm)$递推（每个数都要乘n次）。
- 继续看题。这时候我们惊讶的发现了下面这个东西：
#### $1\leq n\leq 100,n < m\leq 10000000$
- 很好，跑满的时间复杂度为$O(10^9)$，这绝对不会是这道题的正解~~不然怎么会是蓝题呀~~！
- 这怎么办呢？看起来好像没有什么优秀的办法来优化啊~~怎么可能，没有怎么做题~~。
### 这时候，就该我们神奇的矩阵快速幂（或称矩阵加速）出场了！
# 矩阵快速幂
- 前置知识：[矩阵乘法](https://baike.baidu.com/item/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/5446029?fr=aladdin)、[快速幂](https://www.luogu.org/problemnew/show/P1226)。
- 数学姿势：
	+ 1.矩阵满足结合律
   + 2.矩阵不满足交换律（这就要求了我们进行快速幂运算的时候必须要注意乘的顺序）
- 由以上两点我们就可以得出一个很好用的结论：当一个矩阵乘上$k$次另一个矩阵的时候，我们可以看做是乘上这个矩阵的$k$次方，而矩阵可以像数一样用二进制的方式进行快速幂运算。
- 由此我们就推出了矩阵快速幂的基本原理。
### 我们先来举个栗子：
- 斐波那契数列大家应该都很熟悉吧？它的递推式如下：$F_n=F_{i-1}+F_{i-2}$。
- 在一定的范围以内，很显然可以$O(n)$递推的，但是n很大呢？
- 我们可以考虑矩阵快速幂。
- 相信很多同学们都知道斐波那契数列的转移矩阵是这个形式的：

![](https://cdn.luogu.com.cn/upload/pic/58847.png)

- 但是为什么是这样的可能有些人却不太了解，这里给出解释。
- 我们考虑两个矩阵相乘：

![](https://cdn.luogu.com.cn/upload/pic/58848.png)

- 由矩阵乘法的定义我们可以知道：$a=a_1*a_2+b_1*c_2$
- 我们将上方矩阵补齐为$2*2$的：

![](https://cdn.luogu.com.cn/upload/pic/58843.png)

- 那么当$n=3$时，我们有:
- $F_3=1*F_2+1*F_1=2$
- $F_2=1*F_2+0*F_1=1$
- 继续向下推，我们惊奇的发现，对每一个新得到的表示$F_n$的矩阵，都是由这两个式子推过来的：
- $F_n=1*F_{n-1}+1*F_{n-2}$
- $F_{n-1}=1*F_{n-1}+0*F_{n-2}$
- 我们发现它很神奇的符合了斐波那契数列的递推式，但是为什么？
- 假设我们有形式这样一个等式：

![](https://cdn.luogu.com.cn/upload/pic/58844.png)

- 我们进行类似的分析可以发现:对于每一个左边的目标矩阵中的$F_i$,它都满足这样一个形式：（$j$代表$F_i$这个数所对应的矩阵中的那一行）
- $F_i=F_{n-1}*j_1+F_{n-2}*j_3+\dots+F_{n-m}*j_m$
- 因为斐波那契数列只和后两位有关，所以可以用一个$2*2$的矩阵来表示转移过程中的$bas$矩阵（中间那个），然后将$F_i$和$F_{i-1}$写成上面最左边的一列，而$F_{i-1}$和$F_{i-2}$写成最右边的然后依次对应着将系数填入$bas$，就得到了这个斐波那契数列的矩阵形式的转移方程。
### 好了矩阵快速幂的介绍差不多就到这里，当然，听机房大佬说二维的好像也可以？？？？这里就不管了 ~~因为我不会啊~~ ，我们来说一下这道题。
- 我们看最开始给出的那个递推式，我们将它写成矩阵形式：

![](https://cdn.luogu.com.cn/upload/pic/58845.png)

- 因为我们要求第$m$天，所以我们需要在基础矩阵的基础上乘上$bas$矩阵的$m-n$次方（因为要推这么多次）。状态转移如下：

![](https://cdn.luogu.com.cn/upload/pic/58846.png)

- 准备工作已经做好了（DP的题基本也就一个推方程吧。。），剩下的就是记板子上代码了。
## AC Code：
```cpp
#include<bits/stdc++.h>
#define del(a,i) memset(a,i,sizeof(a))
#define ll long long
#define inl inline
#define il inl void
#define it inl int
#define ill inl ll
#define re register
#define ri re int
#define rl re ll
#define mid ((l+r)>>1)
#define lowbit(x) (x&(-x))
#define INF 0x3f3f3f3f
#define mod 4147
using namespace std;
template<class T>il read(T &x)
{
	int f=1;char k=getchar();x=0;
	for(;k>'9'||k<'0';k=getchar()) if(k=='-') f=-1;
	for(;k>='0'&&k<='9';k=getchar()) x=(x<<3)+(x<<1)+k-'0';
	x*=f;
}
const int MAXN = 105;
int n,m,w[MAXN],a[MAXN];
struct Matrix{    //矩阵快速幂模板
	int val[MAXN][MAXN];
	Matrix(){del(val,0);}
	int *operator [](int x){return val[x];}
	Matrix operator *(Matrix t){
		Matrix res;
		for(ri i=1;i<=n;i++)
			for(ri j=1;j<=n;j++)
				for(ri k=1;k<=n;k++)
					res[i][j]=(res[i][j]+val[i][k]*t[k][j])%mod;
		return res;
	}
}ans,bas;
il init(){     //准备工作：构建矩阵
	for(ri i=1;i<=n;i++) ans[i][1]=w[n-i+1];
	for(ri i=1;i<=n;i++) bas[1][i]=a[i];
	for(ri i=2;i<=n;i++) bas[i][i-1]=1;
}
it qpow(int w){   //形式和快速幂一毛一样
	while(w){
		if(w&1) ans=bas*ans;//这里要注意，就像前面说的，矩阵不具有交换性，一定是bas在前！！这一点很重要
		bas=bas*bas;w>>=1;
	}
	return ans[1][1];
}
int main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	read(n),read(m);
	for(ri i=n;i;i--) read(w[i]);
	for(ri i=1;i<=n;i++) read(a[i]);
	init();
	printf("%d\n",qpow(m-n));
	return 0;
}
```

---

## 作者：Supor__Shoep (赞：0)

分析一下题目，大致意思就是给定一组常数 $a_i$，然后有一个递推式 $w_i=\sum _{j=1}^{n} w_{i-j}\times a_{j}$，让你求出 $w_m$ 对于 $4147$ 取模的值。

根据这个 $1\leq m\leq 10^7$ 的恐怖范围，姑且算到了 $O(m)$ 的时间复杂度。但是观察一下这个递推式，发现 $O(m)$ 跑不出来。于是乎我们自然就想到了使用**矩阵快速幂**优化。

我们先构造出初始矩阵：

$$
st=
\left(
\begin{matrix}
w_n & w_{n-1} & \dots & w_2 & w_1
\end{matrix}
\right)
$$

接着我们需要将其进行转移，得到新的 $w_{n+1}$ 的值，最后使用快速幂求出 $w_{m}$ 的值。那么很明显，对于这个转移矩阵的第一列肯定是从 $w_n$ 到 $w_{n+1}$ 的所有常数 $a_i$，而后面的 $n-1$ 项我们只需要直接赋值就可以了。整个式子差不多就是这个样子：

$$
\left(
\begin{matrix}
w_{n+1} & w_{n} & \dots & w_3 & w_2
\end{matrix}
\right)
=
\left(
\begin{matrix}
w_n & w_{n-1} & \dots & w_2 & w_1
\end{matrix}
\right)
\times 
\left(
\begin{matrix}
a_1 & 1 & 0 & \dots & 0 & 0 \\
a_2 & 0 & 1 & \dots & 0 & 0 \\
\vdots & \vdots & \vdots & \ddots & \vdots & \vdots \\
a_{n-2} & 0 & 0 & \dots & 1 & 0 \\
a_{n-1} & 0 & 0 & \dots & 0 & 1 \\
a_n & 0 & 0 & \dots & 0 & 0
\end{matrix}
\right)
$$

然后我们根据快速幂，把最后的矩阵直接算出来：

$$
\left(
\begin{matrix}
w_m & w_{m-1} & \dots & w_{m-n+2} & w_{m-n+1}
\end{matrix}
\right)
=
\left(
\begin{matrix}
w_n & w_{n-1} & \dots & w_2 & w_1
\end{matrix}
\right)
\times 
\left(
\begin{matrix}
a_1 & 1 & 0 & \dots & 0 & 0 \\
a_2 & 0 & 1 & \dots & 0 & 0 \\
\vdots & \vdots & \vdots & \ddots & \vdots & \vdots \\
a_{n-2} & 0 & 0 & \dots & 1 & 0 \\
a_{n-1} & 0 & 0 & \dots & 0 & 1 \\
a_n & 0 & 0 & \dots & 0 & 0
\end{matrix}
\right)
^{m-n+1}
$$

这样我们取这个矩阵的 $w_m$ 输出来就可以了。

代码如下：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int MOD=4147;
const int MAXN=105; 
int n,m;
int st[MAXN],a[MAXN];
int fr[MAXN][MAXN];
void mul(long long f[105],long long a[105][105])
{
    long long c[105];
    memset(c,0,sizeof(c));
    for(int j=0;j<n;j++)
    {
        for(int k=0;k<n;k++)    c[j]=(c[j]+(long long)f[k]*a[k][j])%MOD;
    }
    memcpy(f,c,sizeof(c));
}
void mulself(long long a[105][105])
{
    long long c[105][105];
    memset(c,0,sizeof(c));
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<n;j++)
        {
            for(int k=0;k<n;k++)    c[i][j]=(c[i][j]+(long long)a[i][k]*a[k][j])%MOD;
        }
    }
    memcpy(a,c,sizeof(c));
}
signed main()
{
	cin>>n>>m;
	for(int i=0;i<n;i++)	cin>>st[n-i-1];
	for(int i=0;i<n;i++)	cin>>a[i];
	for(int i=1;i<n;i++)	fr[i][i-1]=1;
	for(int i=0;i<n;i++)	fr[i][n-1]=a[n-i-1];
	int sum=m-n;
	while(sum)
	{
		if(sum&1)	mul(st,fr);
		sum>>=1;
		mulself(fr);
	}
	cout<<st[n-1];
	return 0;
}
```

---

## 作者：Utilokasteinn (赞：0)

[Link](https://www.luogu.com.cn/problem/P3873)

一道矩阵快速幂水体。

题目大意：知道前 $n$ 天的天气，第 $i$ 天的天气可以由它前 $n$ 天的天气得知。求第 $m$ 天的天气。

刚入门也可看出 $O(nm)$ 的暴力递推解法，但由于 $m$ 很大，所以不可以这样做。考虑矩阵快速幂。

因为可以由前 $i$ 天的天气推出第 $i+1$ 天的天气，所以矩阵的构造也很简单，如 $n=5$ 时的单位矩阵如下（不会用Latex……)：

```cpp
0 ,1 ,0 ,0 ,0		w1		w2
0 ,0 ,1 ,0 ,0		w2		w3
0 ,0 ,0 ,1 ,0	*	w3	=	w4
0 ,0 ,0 ,0 ,1		w4		w5
a5,a4,a3,a2,a1		w5		w6
```

代码也就很好写了（时间复杂度 $O(n^3\log m)$）：

```cpp
#include<bits/stdc++.h>
#define mod 4147
using namespace std;
inline int read()
{
	int s=0,f=1;char c=getchar();
	for(;!isdigit(c);c=getchar())
		if(c=='-')f=-1;
	for(;isdigit(c);c=getchar())
		s=s*10+c-'0';
	return s*f;
}
int n,m,w[105],a[105];
struct matrix{
	int a[105][105];
	matrix(){memset(a,0,sizeof(a));}
}res,base,num;
matrix operator *(const matrix &a,const matrix &b)
{
	matrix c;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			for(int k=1;k<=n;k++)
				c.a[i][j]=(c.a[i][j]+a.a[i][k]*b.a[k][j])%mod;
	return c;
}
void init()
{
	for(int i=1;i<n;i++)
		base.a[i][i+1]=1;
	for(int i=n;i>=1;i--)
		base.a[n][n-i+1]=a[i]%mod;
	for(int i=1;i<=n;i++)
		res.a[i][i]=1;
	for(int i=1;i<=n;i++)
		num.a[i][1]=w[i]%mod;
}
void qpow(int k)
{
	init();
	while(k)
	{
		if(k&1)res=res*base;
		k>>=1,base=base*base;
	}
	res=res*num;
}
int main()
{
	n=read(),m=read();
	for(int i=n;i>=1;i--)
		w[i]=read();
	for(int i=1;i<=n;i++)
		a[i]=read();
	qpow(m-n);
	printf("%d",res.a[n][1]);
	return 0;
}

```
谢谢观赏。

---


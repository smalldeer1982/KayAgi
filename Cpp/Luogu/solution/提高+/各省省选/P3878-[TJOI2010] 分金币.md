# [TJOI2010] 分金币

## 题目描述

现在有 $n$ 枚金币，它们可能会有不同的价值，第 $i$ 枚金币的价值为 $v_i$。

现在要把它们分成两部分，要求这两部分金币数目之差不超过 $1$，问这样分成的两部分金币的价值之差最小是多少？



## 说明/提示

#### 数据规模与约定

- 对 $30\%$ 的数据，保证 $1 \leq v_i \leq 1000$
- 对于 $100\%$ 的数据，保证 $1 \leq T \leq 20$，$1 \leq n \leq 30$，$1 \leq v_i \leq 2^{30}$。

## 样例 #1

### 输入

```
2
3
2 2 4
4
1 2 3 6
```

### 输出

```
0
2
```

# 题解

## 作者：Yeji_ (赞：33)

## 分金币
### 前言
模拟退火，好东西。
### 思路
#### 历程
这道题一看就感觉是暴力枚举啊！！！

但是不出人意料的，过不了。

所以开始思考正解，所以开始了漫长的思考时间。

one hour......

two hour......

a long long time......

想不出来怎么办啊？？？？

还是看题解吧！！！

#### 正解
折半状压？这是什么，赶紧脑补一波

按个数为第一关键字，权值为第二关键字对刚刚记录的方案排序，

这样对于选的数个数相同的方案就会被放在一起形成一个个有序的区间，

同时记录每个区间的左端点。
				——取自 star_city

我怎么没有想到！！！

但是，本篇详解的是模拟退火

#### 水分神器——模拟退火
因为本题是要求平分，所以我们先锁边乱搞一下，分成两个组别，

每次在把一个组和另一个组的金币交换

显然，这一个过程可以用模拟退火来实现

一定是随机的，如果不会模拟退火，那么日报里也有大佬讲的模拟退火非常详细，值得一看。

#### 代码
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#define inf 2147483647
#define re register
using namespace std;
int n,ans=inf,a[1005];
int get()
{
    int sum1=0,sum2=0;
    for (re int i=1;i<=(n+1)/2;i++)
     	sum1+=a[i];
    for (re int i=(n+1)/2+1;i<=n;i++)
     	sum2+=a[i];
    return abs(sum1-sum2);
}
void SA()
{
    double beginT=5000,endT=1e-10,changeT=0.9112;
    for (re double T=beginT;T>endT;T*=changeT)
    {
       	int x=rand()%n+1, y=rand()%n+1;
        swap(a[x],a[y]);
        int sum=get();
        if (sum<ans)
        	 ans=sum;
        else 
            if (exp((ans-sum)/T)<(double(rand())/RAND_MAX))
         		swap(a[x],a[y]);
    }
}
int main()
{
    srand(rand());
    int T;
    cin>>T;
    while (T--)
    {
        cin>>n;
    	for(int i=1;i<=n;i++)
     		cin>>a[i];
        int ctrl=1000;
        while(ctrl--)
        	SA();
        cout<<ans<<endl;
        ans=inf;
    }
} 
```


---

## 作者：star_city (赞：23)

折半状压，其他题解的神仙有讲到，不过不用set。

（所以n可以开40）

首先，把前15个组成的所有方案存下来，记录每种方案选的数个数以及这些数的和，也就是折半状压的基本思想

然后按个数为第一关键字，权值为第二关键字对刚刚记录的方案排序，这样对于选的数个数相同的方案就会被放在一起形成一个个有序的区间，同时记录每个区间的左端点（右端点其实就是下一个区间的左端点）。

然后，我们就可以用后15个的所有方案在对应的区间二分了。

比如说，所有数的和为1000，我们当前在后15个数中枚举到了4个，它们的和为150，那么我们就要在记录的个数为11的区间中二分去找最接近350的数。在n为奇数时同理。

```cpp
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cstdio>

const int maxn = 1 << 15 | 7;

using namespace std;

int a[17];
int l[17];
int cnt[maxn];
struct mp {
    int c, w;
    inline int operator < (const mp &a) const {
        return c == a.c ? w < a.w : c < a.c;
    }
} b[maxn];
int tmp[maxn];

inline int cmp(mp a, mp b)
{
    return a.w < b.w;
}

inline int calc(int x, int t)
{
    int ans = 0;
    for (int i = 0; i < 15; i++) ans += x >> i & 1 ? a[i + t] : 0;
    return ans;
}

int main(void)
{
    for (int i = 0; i < 1 << 15; i++) cnt[i] = cnt[i >> 1] + (i & 1);
    int t;
    cin >> t;
    while (t--) {
        int n, sum = 0, ans = 1e9;
        cin >> n;
        int m = n >> 1, k = n - m;
        for (int i = 0; i < n; i++) cin >> a[i], sum += a[i];
        for (int i = 0; i < 1 << m; i++) b[i] = {cnt[i], calc(i, 0)};
        sort(b, b + (1 << m));
        for (int i = 0; i < 1 << m; i++) tmp[i] = b[i].w;
        l[0] = 0;
        l[m + 1] = 1 << m;
        for (int i = 1; i < 1 << m; i++) if (b[i].c != b[i - 1].c) l[b[i].c] = i;
        for (int i = 0; i < 1 << k; i++) {
            int c = m - cnt[i], x = calc(i, m), pos;
            if (~c) {
                pos = lower_bound(tmp + l[c], tmp + l[c + 1], sum / 2 - x) - tmp;
                if (pos < l[c + 1]) ans = min(ans, abs(2 * (tmp[pos] + x) - sum));
                if (pos > l[c]) ans = min(ans, abs(2 * (tmp[pos - 1] + x) - sum));
            }
        }
        cout << ans << endl;
    }
    
    return 0;
}
```

---

## 作者：封禁用户 (赞：9)

# 分金币
这里有一名5年级pj省一蒟蒻。

蒟蒻第一次写题解

跪求管理大大给过。

0:前言

首先想到的是暴力，then 仔细一看数据范围，哇，可以暴力搜索！！！

但貌似容易超时，一番思考后。

half hour......

one hour......

~~无耻的看了看标签~~，啊，~~随机乱搞~~模拟退火！！！

又觉得 吊打xxx 不适合做模拟退火的模板。

于是乎就有了这篇详(wu)细(chi)的题解.

1:模拟退火简介

模拟退火算法来源于固体退火原理，是一种基于概率的算法，将固体加温至充分高，再让其徐徐冷却，加温时，固体内部粒子随温升变为无序状，内能增大，而徐徐冷却时粒子渐趋有序，在每个温度都达到平衡态，最后在常温时达到基态，内能减为最小。
(摘自百度百科)~~(废话)~~

2:算法

先理解算法

初始通过随机数，让答案乱跳

一旦发现较优解，就靠近它。

最后稳定在最优解附近。

就是这样：

![](https://upload.wikimedia.org/wikipedia/commons/d/d5/Hill_Climbing_with_Simulated_Annealing.gif)

从M_sea这位巨佬的博客中抱来的图。

代码流程

(1):设置T_begin=1000~100000，T_end=1e10~1e15 or 0.0001,delta=一个接近1的数;

(2)T_begin*=delta,使用随机数，让答案乱跳，就例如此题，随机选择两边的数，交换它们。

(3)设now=现在的答案，Δ=now比ans优多少

如果now优于ans，ans=now。

否则，以e的Δ*T_now）接受

### 注意在“否则，以e的Δ*T_now接受” 这里接受时，不改变ans，ans要存的是最优解。

不然就会[这样](https://www.luogu.com.cn/record/32118922)

有时使用模拟退火会WA，就调一调参数，或者多跑几遍模拟退火。

配合模板食用更佳:
```
void SA(){
	T_begin=5000/*x,100000<x>=1000*/,T_end=0.0001/*1e-10 or 1e-15*/;
	for(;T_begin>T_end;T_begin*=delta){
		//生成交换的两数 :
		ll l=rand()%k+1,r=rand()%k+k+1;
		//交换 :
		swap(a[l],a[r]);
		//生成新的ans，记录差值 :
		ll now=get(),detla=ans-now;
		//如果更优，则接受 :
		if(detla>0)ans=now;
		//否则，以e的detla*T次方接受，ans保存最优解，so 不改动ans :
		else if(exp(detla*T_begin)>(rand()*1.0/RAND_MAX))swap(a[l],a[r]);
	}
}
```
有了上面这些，应该容易写出代码了。

给出代码：


```cpp
/*      西江月·证明
	即得易见平凡，仿照上例显然。
   留作习题答案略， 读者自证不难。 

	反之亦然同理，推论自然成立。 
	略去过程QED，由上可知证毕。*/
#include<set>
#include<map>
#define mod 10
#include<list>
#include<cmath>
#include<queue>
#include<ctime>
#include<stack>
#include<ctime>
#include<bitset>
#include<memory>
#include<cstdio>
#include<string>
#include<sstream>
#include<utility>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<algorithm>
#define rg register
#define bll __int128
#define ll long long
#define inf 2147348909832ll
#define ull unsigned long long
#define debug() cout<<"SOSOSOSOSOSOSOS!!!!!!!!!"
using namespace std;
ll read(){
	ll ans=0,f=1;char a=getchar();while(a>'9'||a<'0'){if(a=='-')f=(-1);a=getchar();}
	while(a>='0'&&a<='9')ans=(ans<<3)+(ans<<1)+(a^48),a=getchar();return ans*f;
}//一条long long的黄金分割线---------------------------------------------------------------------------------------------
double t0,t1,delta;
ll T=read(),n,a[35],sum1,sum2,ans=inf,k;
ll get(){
	sum1=sum2=0;
	for(int i=1;i<=n/2;i++)sum1+=a[i];
	for(int i=n/2+1;i<=n;i++)sum2+=a[i];
	return abs(sum1-sum2);
}
void jw(){
	t0=rand()%5000,t1=0.0000001,delta=0.9623415;
	for(;t0>t1;t0*=delta){
		ll l=rand()%k+1,r=rand()%(n-k)+k+1;
		if(l>n||r>n)continue;
		swap(a[l],a[r]);
		ll now=get();
		ll detla=ans-now;
		if(detla>0)ans=now;
		else if(exp(detla/t0)<double(rand())/RAND_MAX)swap(a[l],a[r]);
	}
}
void SA(){
	ll k=300;
	for(int i=1;i<=k;i++)jw();
}
int main()
{
	srand(time(NULL));
	while(T--){
		k=(n=read())/2;
		for(int i=1;i<=n;i++)a[i]=read();
		if(n==1){cout<<a[1]<<endl;continue;}
		ans=get();
		SA();
		cout<<ans<<endl;
	}
    return 0;
}
```
有疑问可以随时在评论区留言，我会至少每2天看一次。

## 谢谢观赏。

---

## 作者：skydogli (赞：8)

### 前（che)言（dan）
比较良心的模拟退火模板（~~主要是数据水~~），写一发题解加深记忆。
模拟退火的原理[百度](https://baike.baidu.com/item/退火/1039313?fr=aladdin)吧，其运用到信息学的精髓就是随机，每一次随机出一个解，判断是否比当前更优，如果是则替换，否则以一个与温度和与最优解的差距相关的概率（温度越高、与最优解差距越小，接受概率越大），每一次都降低一定温度，温度极小时就停止，考试时用于骗分，遇到最优解（DP）之类的问题都可以试试，如果很欧的话说不定就A了（然而我交了好几次）

### 本题思路
因为这题必须平分的性质，所以金币只能被分成1~n/2和n/2+1~n，于是我们可以随机选择2个金币交换，如果更优则交换金币并更新最优解，否则以一定概率交换。
### 代码&注释
```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define dt 0.999
int T,n,mid;
ll a[35],s1,s2,ans,odd;
void SA(){//模拟退火的英文
	double Ti=2004;//温度你喜欢，大于1000就问题不大
	while(Ti>1e-15){//当温度极低时停止
		ll x=(int)(rand())%mid+1,y=n-((int)(rand())%(mid+odd));
        //x为前1/2的一个金币，y为后1/2的一个金币
        //注意这里要判断一下奇偶性，不然可能到不了边界
		ll dis=abs(s1-(a[x]<<1)+(a[y]<<1)-s2);
        //s1-a[x]+a[y]-(s2-a[y]+a[x])合并同类项
		double D=dis-ans;
		if(D<0){//优与当前最优解
			ans=dis;
			s1=s1-a[x]+a[y];
			s2=s2-a[y]+a[x];
			swap(a[x],a[y]);//注意先改s1s2后交换！
		}
		else if(exp((D/Ti))<rand()%32768){s1=s1-a[x]+a[y];s2=s2-a[y]+a[x];swap(a[x],a[y]);}//以随机的概率接受
		Ti*=dt;//降温
	}
}
int main(){
	srand(725901);//定个种子
	srand(rand());
	scanf("%d",&T);
	while(T--){
		scanf("%d",&n);
		mid=n/2;
		odd=n%2;
		s1=s2=0;
		for(int i=1;i<=n;++i){
			scanf("%lld",&a[i]);
			if(i<=mid) s1+=a[i];
				else s2+=a[i];
		}
		if(n==1){printf("%lld\n",a[1]);continue;}
		ans=abs(s1-s2);
		for(int i=1;i<20;++i)SA();//别超时（最慢跑了700ms），提交之前先洗把脸拜拜佛
		printf("%lld\n",ans);
	}
	return 0;
}

```


---

## 作者：benny (赞：8)

本题是一道搜索题

每个金币有取和不取2种状态，最多30个金币，深搜需2^30的时间。然而可以优化：
- 按价值从大到小排序，你一不小心取的价值太大会被剪枝

- 最多取n/2个金币，你取得太多是要被剪枝的

贴代码：

```c
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;//这里是一个简写 
const LL maxn=1e40;
LL a[300];
LL H[300];//前缀和 
int i,j,n,m,s,T;
LL h(int l,int r)//前缀和 
{
	return(H[r]-H[l-1]);
}
//f表示最小差(即答案），x是第一堆个数，X是第一堆总价值；y是第二堆同理 
LL f(int c,int x,LL X,int y,LL Y) 
{
	//你取太多了！ 
	if(x>n/2||y>n/2) return maxn;
	//X最大仍小于Y，第一堆取太便宜了！ 
	LL XX=X+h(c,c+(n/2-x)-1); 
	if(XX<=s-XX) return(s-XX-XX);
	//X最小仍大于Y，第一堆取太贵了！ 
	XX=X+h(n-(n/2-x)+1,n);
	if(XX>=s-XX) return(XX-(s-XX));
	 
	int p=f(c+1,x+1,X+a[c],y,Y);//放第一堆 
	int q=f(c+1,x,X,y+1,Y+a[c]);//放第二堆 
	if(p<q) return p;else return q;
}
int main()//主 
{
	cin>>T;
	while(T--)
	{
		cin>>n;
		for(i=1;i<=n;i++) cin>>a[i];
		s=0;
		for(i=1;i<=n;i++) s+=a[i];
		if(n&1){n++;a[n]=0;}//小细节：金币个数为奇数时补一个0，使之偶数 
		sort(a+1,a+1+n,greater<int>());//从大到小 
		H[0]=0;
		for(i=1;i<=n;i++) H[i]=H[i-1]+a[i];
		cout<<f(1,0,0,0,0)<<endl;
	}
}
```

---

## 作者：7KByte (赞：6)

事实证明深度优先搜索+剪枝可以AC

首先对金币从小到大排序，然后求前缀和

定义状态$F(i,j,k)$，表示当前正在决策第$i$个金币，已经选出总价值$j$的金币，和已经选出$k$个金币


### Part1 暴搜

转移
$F(i,j,k)\rightarrow \begin{cases} F(i+1,j+a_i,k+1)\ \ \ \ \ \ \  \text{选第i个金币}  \\F(i+1,j,k) \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \text{不选第i个金币}  \end{cases}$  

边界$F(1,0,0)$,答案为$F(n/2,?,?)$中的差值最小值


程序实现比较简单

$Code:30Points$

```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
typedef long long ll;
using namespace std;
int n;ll a[40],ans,all;
void dfs(int now,ll sum,int cnt){
    if(!(cnt^(n>>1)))ans=min(ans,abs(sum-(all-sum)));
    if(now>n)return;
    if(cnt>=(n>>1))return;
    dfs(now+1,sum,cnt);
    dfs(now+1,sum+a[now],cnt+1);
}
signed main()
{
    int T;scanf("%d",&T);
    while(T--){
        scanf("%d",&n);all=0;
        memset(a,0,sizeof(a));
        for(int i=1;i<=n;i++)scanf("%lld",&a[i]),all+=a[i];
        sort(a+1,a+n+1);ans=1e18;
        dfs(1,0,0);
        printf("%lld\n",ans);
    }
    return 0;
}
```


### Part2 初步剪枝

为减小搜索树的"宽度"，我们优先考虑价值大的金币

转移
$F(i,j,k)\rightarrow \begin{cases} F(i-1,j+a_i,k+1)\ \ \ \ \ \ \  \text{选第i个金币}  \\F(i-1,j,k) \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \text{不选第i个金币}  \end{cases}$  

边界$F(n,0,0)$  

上下界剪枝:
  - 当前已经选出超过$n/2$个金币，再选不符合题意，剪掉
  - 当前选的金币数加剩下的所有金币个数仍然小于$n/2$，不可能成立，剪掉
  
  
$Code:30Points$

```cpp
#include<bits/stdc++.h>
typedef long long ll;
using namespace std;
int n;ll a[40],ans,all;
void dfs(int now,ll sum,int cnt){
    if(!(cnt^(n>>1)))ans=min(ans,abs(sum-(all-sum)));
    if(!now)return;
    if(cnt>(n>>1))return;
    if(cnt+now<(n>>1))return;
    dfs(now-1,sum,cnt);
    dfs(now-1,sum+a[now],cnt+1);
}
signed main()
{
    int T;scanf("%d",&T);
    while(T--){
        scanf("%d",&n);all=0;
        for(int i=1;i<=n;i++)scanf("%lld",&a[i]),all+=a[i];
        sort(a+1,a+n+1);ans=1e18;
        dfs(n,0,0);
        printf("%lld\n",ans);
    }
    return 0;
}
```

### Part3 最优性剪枝1

以当前搜出的最优答案为标准
- 如果当前价值总和$j$加上剩下数中最小的$i$个数之和仍比当前最优答案大，剪枝
- 如果当前价值总和$j$加上剩下数中最大的$i$个数之和仍比当前最优答案小，剪枝

$Code:60Points$

```cpp
#include<bits/stdc++.h>
typedef long long ll;
using namespace std;
int n;ll a[40],ans,all,s[40],nd;
void dfs(int now,ll sum,int cnt){
    if(!(cnt^nd))ans=min(ans,abs(sum-(all-sum)));
    if(!now)return;
    if(cnt>nd)return;
    if(cnt+now<nd)return;
    if(sum+s[nd-cnt]>=(all+ans)>>1)return;
    if(sum+s[now]-s[now-(nd-cnt)]<=((all-ans)>>1))return;
    dfs(now-1,sum,cnt);
    dfs(now-1,sum+a[now],cnt+1);
}
signed main()
{
    int T;scanf("%d",&T);
    while(T--){
        scanf("%d",&n);all=0;nd=(n>>1);
        memset(a,0,sizeof(a));memset(s,0,sizeof(s));
        for(int i=1;i<=n;i++)scanf("%lld",&a[i]),all+=a[i];
        sort(a+1,a+n+1);ans=1e18;
        for(int i=1;i<=n;i++)s[i]=s[i-1]+a[i];
        dfs(n,0,0);
        printf("%lld\n",ans);
    }
    return 0;
}
```


### Part4 最优性剪枝2 

最优性剪枝1的扩展

- 如果当前价值总和$j$加上剩下数中最小的$i$个数之和仍比另一部分大，显然这个状态能够扩展出的所有状态中，差值最小为$j$加上最小的$i$个数之和减去剩下的部分
- 同理，如果当前价值总和$j$加上剩下数中最大的$i$个数之和仍比另一部分小，显然这个状态能够扩展出的所有状态中，差值最小为剩下的部分减去$j$与最大的$i$个数之和

可能会比较绕口，具体参见代码

$Code:100Points$

```cpp
#include<bits/stdc++.h>
typedef long long ll;
using namespace std;
int n;ll a[40],ans,all,s[40],nd;
void dfs(int now,ll sum,int cnt){
	int next=s[now]; 
	if(!(cnt^nd))ans=min(ans,abs(sum-(all-sum)));
	if(!now)return;
	if(cnt>nd)return;
	if(cnt+now<nd)return;
	if(sum+s[nd-cnt]>=(all+ans)>>1)return;
	if(sum+s[now]-s[now-(nd-cnt)]<=((all-ans)>>1))return;
	if(sum+s[nd-cnt]>=all-(sum+s[nd-cnt])){
	    ans=min(ans,2*(sum+s[nd-cnt])-all);return;
	}
	if(sum+s[now]-s[now-(nd-cnt)]<=all-(sum+s[now]-s[now-(nd-cnt)])){
		ans=min(ans,all-2*(sum+s[now]-s[now-(nd-cnt)]));return;
	}
	dfs(now-1,sum,cnt);
	dfs(now-1,sum+a[now],cnt+1);
}
signed main()
{
	int T;scanf("%d",&T);
	while(T--){
		scanf("%d",&n);all=0;nd=(n>>1);
		memset(a,0,sizeof(a));memset(s,0,sizeof(s));
		for(int i=1;i<=n;i++)scanf("%lld",&a[i]),all+=a[i];
		sort(a+1,a+n+1);ans=1e18;
		for(int i=1;i<=n;i++)s[i]=s[i-1]+a[i];
		dfs(n,0,0);
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：Luan_233 (赞：6)

## Solution

+ 折半状压了解一下？状压有些时候真是吼东西啊！

+ 首先序列折半，分为前半部分与后半部分，$2^{15}$大力搞一下，令二进制位中$0$为放入集合一，$1$为放入集合二，记录一下放到两个集合内的数的权值差值，以及状态表示中$0$的个数与$1$的个数之差；然后把这些值存入$set$备用，$set$的下标即为元素数目的差值。这里为了防止出现负下标，将它们都加上$n$。

+ 紧接着，后半部分在枚举时依然记录上面提到的差值，若$n$为偶数，则两个集合内选出来的数的数目必须相等，反之则一定会差1，即$cnt1+cnt2=\pm 1$，$cnt$指两部分枚举时放入集合一的元素个数减去放入集合二内的。利用上式直接去三个$set$里前后二分，将组合后的值取绝对值的最小值就可以了。

+ 复杂度约为$O(t\times(15 \times 2^{15}))$，我比较虚$STL$的常数，所以开了氧气，跑的挺快的。

## Code

```
// luogu-judger-enable-o2
#include<set>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<algorithm>

#define N 105
#define R register
#define maxn 1<<15
#define INF 2147483647

using namespace std;

set<int> _set[105];

int t,n,mid,w[N],ans;

int f1[maxn],f2[maxn],cnt1[maxn],cnt2[maxn];

inline void solve(){
    cin>>n;
    for(R int i=1;i<=n;++i) cin>>w[i];
    mid=(1+n)>>1;
    for(R int i=0;i<=100;++i) _set[i].clear();
    for(R int i=0;i<(1<<mid);++i){
        cnt1[i]=f1[i]=0;
        for(R int j=1;j<=mid;++j){
            if(i&(1<<(j-1))) f1[i]+=w[j],++cnt1[i];
            else f1[i]-=w[j],--cnt1[i];
        }
        _set[cnt1[i]+n].insert(f1[i]);
    }
    ans=INF;
    for(R int i=0;i<(1<<(n-mid));++i){
        cnt2[i]=f2[i]=0;
        for(R int j=1;j<=n-mid;++j){
            if(i&(1<<(j-1))) f2[i]+=w[j+mid],++cnt2[i];
            else f2[i]-=w[j+mid],--cnt2[i];
        }
        if(((n&1)^1)&&(_set[n-cnt2[i]].size())){
            set<int>::iterator it1=_set[n-cnt2[i]].lower_bound(-f2[i]);
            set<int>::iterator it2=_set[n-cnt2[i]].upper_bound(-f2[i]);
            if(it1!=_set[n-cnt2[i]].end()) ans=min(ans,abs(*it1+f2[i]));
            if(it2!=_set[n-cnt2[i]].end()) ans=min(ans,abs(*it2+f2[i]));
        }
        if((n&1)&&(_set[n-cnt2[i]+1].size())){
            set<int>::iterator it1=_set[n-cnt2[i]+1].lower_bound(-f2[i]);
            set<int>::iterator it2=_set[n-cnt2[i]+1].upper_bound(-f2[i]);
            if(it1!=_set[n-cnt2[i]+1].end()) ans=min(ans,abs(*it1+f2[i]));
            if(it2!=_set[n-cnt2[i]+1].end()) ans=min(ans,abs(*it2+f2[i]));
        }
        if((n&1)&&(_set[n-cnt2[i]-1].size())){
            set<int>::iterator it1=_set[n-cnt2[i]-1].lower_bound(-f2[i]);
            set<int>::iterator it2=_set[n-cnt2[i]-1].upper_bound(-f2[i]);
            if(it1!=_set[n-cnt2[i]-1].end()) ans=min(ans,abs(*it1+f2[i]));
            if(it2!=_set[n-cnt2[i]-1].end()) ans=min(ans,abs(*it2+f2[i]));
        }
    }
    cout<<ans<<endl;
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    cin>>t;
    while(t--) solve();
    return 0;
}
```

---

## 作者：1saunoya (赞：5)

模拟退火的做法


``现在要把它们分成两部分，要求这两部分金币数目之差不超过1``

显然 我们可以用一个mid


~~~
int mid = 1 + n >> 1;
~~~
那么就满足这个条件

直接模拟退火乱搞 就可以AC了

~~~
inline LL get() {
	LL tmp1 = 0 ; 
	LL tmp2 = 0 ;
	for(register int i=1;i<=mid;i++) tmp1 += v[i] ;
	for(register int i=mid+1;i<=n;i++) tmp2 += v[i] ;
	return abs(tmp1 - tmp2) ;
}
inline void Mnth() {//模拟退火
	for(register double T = 5000 ; T >= 1e-10; T *= 0.998) {
		int x = (rand()) % n + 1 ;
		int y = (rand()) % n + 1 ;
		swap(v[x] , v[y]) ;
		tmp = get() ;
		if(tmp < ans) ans = tmp ;
		else if(exp((ans-tmp)/T)<(double(rand())/RAND_MAX)) swap(v[x] , v[y]) ;
	}
	return ;
}
~~~
反正我这一段跑了十遍就过了呢

~~~
for(register int t = 10 ; t -- ; ) Mnth() ;
~~~


别说了我永远喜欢模拟退火

---

## 作者：SIGSEGV (赞：3)

~~模拟退火杀人事件~~

本题使用超级骗分大法（模拟退火）~~想不出正解啊~~

没有学过模拟退火的右转[吊打XXX](https://www.luogu.org/problemnew/show/P1337)

每次随机选2个组别不同的数，交换它们的组别

看代码吧
```cpp
#include <bits/stdc++.h> 
using namespace std;
int n,v[35],sum1,sum2,grp[3][35],ans,len1,len2;//grp[i][j]:第i组的第j个数
const double D = 0.99551748,E = 1e-8;
inline int calc() //计算答案
{
    return abs(sum1 - sum2);
}
inline void swap_grp(int g1,int g2) //交换组别
{
    sum1 -= grp[1][g1];sum2 += grp[1][g1];
    sum2 -= grp[2][g2];sum1 += grp[2][g2];
    swap(grp[1][g1],grp[2][g2]);
}
void SA()
{
    double T = 3000;
    int cur_ans = ans;
    while (T > E)
    {
        int x = rand() % len1 + 1,y = rand() % len2 + 1;//随机获取位置
        swap_grp(x,y);int nans = calc(),diff = nans - cur_ans;
        if (diff < 0)
        {
            cur_ans = nans;if (ans > cur_ans) ans = cur_ans;
        }
        else if (exp(-diff / T) * RAND_MAX > rand()) //接受更差的新的解
            cur_ans = nans;
        else swap_grp(x,y);
        T *= D;//降温
    }
}
int main ()
{
    srand(time(0));
    int T;
    scanf("%d",&T);
    while (T--)
    {
        scanf("%d",&n);
        sum1 = sum2 = 0;//sum:组内的数的和
        len1 = n / 2;len2 = n - len1;//len:分组的长度
        for (int i = 1;i <= n;i++)
        {
            scanf("%d",&v[i]);//默认前半部分分一组，后一半分一组
            if (i <= len1) {grp[1][i] = v[i];sum1 += v[i];} 
            else {grp[2][i - len1] = v[i];sum2 += v[i];}
        }
        ans = calc();
        if (n == 1) //此处要特判，不然len1会为0 取模时会报RE 我被坑了11次
        {
            printf("%d\n",ans);continue;
        }
        for (int i = 1;i <= 15;i++) SA();
        printf("%d\n",ans);
    }
    return 0;
}
```

---

## 作者：nofind (赞：2)

题意：https://www.luogu.org/problemnew/show/P3878

不知为什么题解一堆模拟退火~

折半状压,类似折半搜索(蓝书上的例题):

http://contest-hunter.org:83/contest/0x20「搜索」例题/2401%20送礼物

我们先将前一半的金币的状态dp出来,存在set里面,set的下标是产生的数量差cnt,存的是价值差tot

之后我们再dp后一半,直接与前一半状态拼接,复杂度为O(T*(N*2^(N/2)))

拼接状态:

n是偶数:数量差为0

n为奇数:数量差为正负1

在对应的set里二分即可

dp:

状态i:0表示在集合1中,1表示在集合2中。

枚举物品j,cnt是数量差,tot是价值差:
```

if(i&(1<<(j-1))) cnt++,tot+=a[j]/a[n/2+j]
else cnt--,tot-=a[j]/a[n/2+j]
```
code:
```
#include<bits/stdc++.h>
using namespace std;
const int maxn=100;
int T,n,ans;
int a[maxn];
set<int> s[110];
void dfs1()
{
	for(int i=0;i<=109;i++) s[i].clear();
	ans=0x3f3f3f3f;int m=n/2;
	for(int i=0;i<(1<<m);i++)
	{
		int cnt=0,tot=0;
		for(int j=1;j<=m;j++)
		{
			if(i&(1<<(j-1))) cnt++,tot+=a[j];
			else cnt--,tot-=a[j];
		}
		s[cnt+n].insert(tot);
	}
}
int check(int x,int y)
{
	int ans=0x3f3f3f3f;
	set<int>::iterator p=s[x].lower_bound(y);
	if(p!=s[x].end()) ans=min(ans,abs(*p-y));
	return ans; 
}
void dfs2()
{
	int m=n-n/2;
	for(int i=0;i<(1<<m);i++)
	{
		int cnt=0,tot=0;
		for(int j=1;j<=m;j++)
		{
			if(i&(1<<(j-1))) cnt++,tot+=a[n/2+j];
			else cnt--,tot-=a[n/2+j];
		}
		cnt=n-cnt;
		if(n&1) ans=min(ans,min(check(cnt-1,-tot),check(cnt+1,-tot)));
		else ans=min(ans,check(cnt,-tot));
	}
}
int main()
{
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d",&n);
		for(int i=1;i<=n;i++) scanf("%d",&a[i]);
		dfs1();dfs2();
		printf("%d\n",ans);
 	}
 	return 0;
}
```



---

## 作者：BriMon (赞：2)

[戳这里](https://www.cnblogs.com/BriMon/p/9615451.html)看原文，食用效果更佳。

其实...

数据范围小的可怜也就懒得想正解。

满脑子都是乱搞，我感觉我的noip完了。

我可能也就只会这种乱搞题了。

模拟退火想必大家都~~听说过~~。

模拟退火就是一种可以在错误的贪心下有较大概率找到最优解的算法，想要了解更深可以去做 吊打XXX 那道题。

其实这题直接随机就行了，在这个题里模拟退火一点用都没有，但是我因为比较**菜**  ，所以比较~~闲~~，就敲了这个。

dalao请轻喷。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cstdlib>
#include <ctime>
#include <cmath>
using namespace std;
#define reg register 
inline int read() {
    int res = 0;char ch=getchar();bool fu=0;
    while(!isdigit(ch)) {if(ch=='-')fu=1;ch=getchar();}
    while(isdigit(ch)) res=(res<<3)+(res<<1)+(ch^48), ch=getchar();
    return fu?-res:res;
}

int T, n;
int a[35];
int ans;

inline int Calc() 
{
	int res1 = 0, res2 = 0;
	for (reg int i = 1 ; i <= n ; i ++)
		if (i <= (n + 1) / 2) res1 += a[i];
		else res2 += a[i];
	return abs(res1 - res2);
}

inline void SA()
{
	double T = 2333.0;
	while(T > 1e-9)
	{
		int x = rand() % ((n + 1) / 2) + 1, y = rand() % ((n + 1) / 2) + ((n + 1) / 2);
		if (x <= 0 or x > n or y <= 0 or y > n) continue;
		swap(a[x], a[y]);
		int newans = Calc();
		int dert = ans - newans;
		if (dert > 0) ans = newans;
		else if (exp((double)((double)dert/T)) * RAND_MAX <= rand()) swap(a[x], a[y]);
		T *= 0.998;
	}
}

int main()
{
	T = read();
	srand((unsigned)time(NULL));
	while(T--)
	{
		n = read();
		for (reg int i = 1 ; i <= n ; i ++) a[i] = read();
		ans = 1e9;
		for (int i = 1 ; i <= 50 ; i ++) SA();
		cout << ans << endl;
	}
	return 0;
}
```

---

## 作者：孙子隆 (赞：1)

# 大好题
由经机房大佬推荐。

看到题目首先注意到的应该是n的最大范围是30，可以想一下n/2是15。是状压的范围，考虑折半状压。

### 注意：此题解需要用到set，接下来是set的使用。
set约等于vector，但是他内部是有序的，从小到大的排列。然后又函数lower_bound，二分查找返回下标。

思路就是先进行折半，将前15个数记录状态，插入到set里边，然后在

后面的15个数里边寻找满足条件的状态。

详细的东西都在代码里边（借鉴楼上神仙题解）




```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<set>
using namespace std;
#define maxn 1010
int T,n,ans;
int a[maxn];
set<int >s[101];
//set一个排好序的集合 

inline int read()
{
	int x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9')
	{
		if(c=='-')
		f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')
	x=(x<<3)+(x<<1)+c-'0',c=getchar();
	return x*f;
}


void dfs1()
{
	for(int i=0;i<=100;i++)s[i].clear();
	ans=0x3f3f3f3f;
	int m=n/2;//必须是下取整 
	for(int i=0;i<(1<<m);i++)
	{
		int cnt=0,tot=0;
		for(int j=1;j<=m;j++)
		{
			if(i&(1<<(j-1)))cnt++,tot+=a[j];
			else 
			cnt--,tot-=a[j];
			//注意这里cnt和tot直接记录的差值 
		}
		s[cnt+n].insert(tot); 
		//如果cnt为负数根本不现实 
		//+n的目的是为了更好的查询，防止出现负数情况//见下边70行 
	}
}

int check(int x,int y)
{
	int ans=0x3f3f3f3f;
	set<int>::iterator p=s[x].lower_bound(y);
	if(p!=s[x].end()) ans=min(ans,abs(*p-y));
	//*p表示在set集合中的元素大小 
	return ans;
}

void dfs2()
{
	int m=n-n/2;//约等于上取整 
	for(int i=0;i<(1<<m);i++)
	{
		int cnt=0,tot=0;
		for(int j=1;j<=m;j++)
		{
			if(i&(1<<(j-1))) cnt++,tot+=a[n/2+j];
			else cnt--,tot-=a[n/2+j];//此处为处理下一部分要加n/2 
		}
		cnt=n-cnt;//因为cnt记录的差值并且见44行 
		if(n&1)//n为基数绝对存在差值为1 //时刻注意cnt和tot维护的是差值 
		ans=min(ans,min(check(cnt-1,-tot),check(cnt+1,-tot)));
		//cnt+1与cnt-1是指元素差值
		else 
		ans=min(ans,check(cnt,-tot));
	}
}

int main()
{
    T=read();
    while(T--)
    {
        n=read();
        for(int i=1;i<=n;i++)
        a[i]=read();
        dfs1();dfs2();
        cout<<ans<<endl;
    }
} 
```


---

## 作者：little_sun (赞：1)

### 题目大意

将$n$个数分成两半，使得这两半的差尽量小

### 题解
 
我们首先先把这$n$个数按下标顺序分成两半，然后每次随机选取前半段和后半段的两个数将其交换，如果更优的话就更新$ans$,否则就以$e^{\frac{-de}{t}}$（$de=$当前解-最优解）的概率接受该交换(其实就是模拟退火的基本套路)

### 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
const int MaxN = 50;
const double delta = 0.993;
ll n, a[MaxN], ans;
ll abs(ll x){ return (x > 0) ? x : (-x);}
inline ll calc()
{
    ll sum1 = 0, sum2 = 0;
    for (int i = 1; i <= n; i++)
    {
        if(i <= (n + 1) / 2)
            sum1 += a[i];
        else sum2 += a[i];
    }
    return abs(sum1 - sum2);
}
inline void sa()
{
    double t = 10000000;
    while (t > 1e-14)
    {
        int x = rand() % ((n + 1) / 2) + 1, y = rand() % ((n + 1) / 2) + ((n + 1) / 2);
        std::swap(a[x], a[y]);
        int now = calc();
        int de = now - ans;
        if (de < 0)
            ans = now;
        else if (exp(-de / t) * RAND_MAX <= rand())
            std::swap(a[x], a[y]);
        t *= delta;
    }
}
int main()
{
    int T;
    srand(time(NULL));
    scanf("%d", &T);
    while (T--)
    {
        scanf("%lld", &n);
        for (int i = 1; i <= n; i++)
            scanf("%lld", &a[i]);
        ans = 1e9;
        for (int i = 1; i <= 50; i++)
            sa();
        printf("%lld\n", ans);
    }
    return 0;
}

```

---

## 作者：Hexarhy (赞：0)

~~题解怎么少？明明一道很裸的模拟退火就能水过去……~~

## 主要思路：模拟退火

先放一张经典的动图：

![](https://upload.wikimedia.org/wikipedia/commons/d/d5/Hill_Climbing_with_Simulated_Annealing.gif)

由于篇幅有限，没学过模拟退火的同学请参考[【洛谷日报#60】](https://m-sea.blog.luogu.org/qian-tan-SA)。

当我们进行模拟退火的时候，初始温度不用太高，5000就行了，否则会TLE。

不过要注意，模拟退火的次数不用太多，50~125次就够了，否则就会跟我一样TLE好几个点。

求解过程很简单，直接分成两半，遍历一遍，算出两边的价值之差。

如果对于下面这句话有疑问的同学，就看看[这篇文章](https://www.luogu.org/blog/80049/solution-p2210)。

```cpp
else if(exp((ans-tmp)/T)<(double(rand())/RAND_MAX))
	swap(a[x],a[y]);
```

剩下的就是套模拟退火的板子，没什么好讲的。`srand()`看人品吧。



------------


其实你会发现有些紫题黑题正解很难，但是模拟退火可以骗到很多分，甚至AC，俗话说：

> 用模拟退火做难题就是对它的不敬！

因此大家要学好模拟退火哟！



------------

奉上程序：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstdlib>
#include<ctime>
#include<climits>
using namespace std;

const int MAXN=105;
int n,ans=INT_MAX;//别忘了设初始值
int a[MAXN];

void input(void)
{
	cin>>n;
	for(int i=1;i<=n;i++)
	 cin>>a[i];
}

int get(void)//直接分成两半，算出价值差
{
	int tmp1=0,tmp2=0;
	for(int i=1;i<=(n+1)/2;i++)//+1是为了防止奇数除以2
	 tmp1+=a[i];
	for(int i=(n+1)/2+1;i<=n;i++)
	 tmp2+=a[i];
	return abs(tmp1-tmp2);
}

void SA(void)//套模拟退火的板子
{
	const double beginT=5000.0,endT=1e-10,changeT=0.98;//温度调参自己看心情吧
	for(double T=beginT;T>endT;T*=changeT)
	{
		const int x=rand()%n+1;
		const int y=rand()%n+1;
		swap(a[x],a[y]);
		const int tmp=get();
		if(tmp<ans)
		 ans=tmp;//更新最优解
		else if(exp((ans-tmp)/T)<(double(rand())/RAND_MAX))
		 swap(a[x],a[y]);//概率性的不接受当前较差解
	}
}

int main()
{
	srand(rand());
	int T;
	cin>>T;
	while(T--)
	{
		input();
		int ctrl=125;
		while(ctrl--)//次数不要太多，防止TLE
		 SA();
		cout<<ans<<endl;
		ans=INT_MAX;//别忘了初始值
	}
	return 0;
 } 
```


---


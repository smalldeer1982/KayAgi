# [GDOI2014] 拯救莫莉斯

## 题目描述

莫莉斯·乔是圣域里一个叱咤风云的人物，他凭借着自身超强的经济头脑，牢牢控制了圣域的石油市场。

圣域的地图可以看成是一个 $n\times m$ 的矩阵。每个整数坐标点 $(x, y)$ 表示一座城市（$1\le x\le n,1\le y\le m$）。两座城市间相邻的定义为：对于城市 $(A_x, A_y)$ 和城市 $(B_x, B_y)$，满足 $(A_x - B_x)^2 + (A_y - B_y)^2 = 1$。

由于圣域的石油贸易总量很大，莫莉斯意识到不能让每笔石油订购单都从同一个油库里发货。为了提高效率，莫莉斯·乔决定在其中一些城市里建造油库，最终使得每一个城市 $X$ 都满足下列条件之一：

1. 该城市 $X$ 内建有油库.
2. 某城市 $Y$ 内建有油库，且城市 $X$ 与城市 $Y$ 相邻。

与地球类似，圣域里不同城市间的地价可能也会有所不同，所以莫莉斯想让完成目标的总花费尽可能少。如果存在多组方案，为了方便管理，莫莉斯会选择建造较少的油库个数。


## 说明/提示

对于 $30\%$ 数据满足 $n \times m \le 25$;   
对于 $100\%$ 数据满足 $n \times m \le 50,0 \le F_{i, j} \le 10 ^ 5$。


## 样例 #1

### 输入

```
3 3
6 5 4
1 2 3
7 8 9```

### 输出

```
3 6```

# 题解

## 作者：喵仔牛奶 (赞：7)

$nm\leq50,m\leq n$ 说明 $m\leq7$，一眼状压。

设 $f_{i,j,k}$ 为第 $i$ 行状态为 $j$，$i-1$ 行状态为 $k$ 且 $1$ 至 $i-1$ 行全部有油库相邻的最小代价， $dp_{i,j,k}$ 为最小个数。

那么 $f$ 的转移方程显然：

$$f_{i,j,k}=\min_{0\leq l<2^m}\{f_{i-1,k,l}+sum_{i,j}\text{ }(\#)\}$$

其中 $sum_{i,j}$ 是第 $i$ 行状态为 $j$ 的花费， $dp$ 跟着 $f$ 转移一下就可以了。

$\#$ 是转移的条件，上面挤不下了，这里来写：

对于 $f_{i-1,k,l}$，第 $1$ 行至第 $i-2$ 行一定全部有油库相邻，只要考虑第 $i-1$ 列，所以 $\#$ 是 ```(j|k|l|k<<1|k>>1)```。

代码实现如下：

```cpp
#include <bits/stdc+.h>
using namespace std;
const int N = 10, M = 55;
int f[M][1 << N][1 << N], dp[M][1 << N][1 << N], sum[M][1 << N], a[M][N], n, m, ans1 = INT_MAX, ans2 = INT_MAX;
int main() {
	cin >> n >> m;
	memset(f, 0x3f, sizeof f);
	for (int i = 1; i <= n; i ++)
		for (int j = 1; j <= m; j ++)
			cin >> a[i][j];
	for (int i = 1; i <= n; i ++)
		for (int j = 0; j < 1 << m; j ++)
			for (int k = 0; k < m; k ++)
				if (j & 1 << k) sum[i][j] += a[i][k + 1];
	for (int i = 0; i < 1 << m; i++)
		f[1][i][0] = sum[1][i], dp[1][i][0] = __builtin_popcount(i);
	for (int i = 2; i <= n; i ++)
		for (int j = 0; j < 1 << m; j ++)
			for (int k = 0; k < 1 << m; k ++)
				for (int l = 0; l < 1 << m; l ++)
					if (((j | k | l | k << 1 | k >> 1) & (1 << m) - 1)== (1 << m) - 1) {
						int t = f[i - 1][k][l] + sum[i][j], p = dp[i - 1][k][l] + __builtin_popcount(j);
						if (f[i][j][k] > t || f[i][j][k] == t && dp[i][j][k] > p)
							f[i][j][k] = t, dp[i][j][k] = p;
					}
	for (int i = 0; i < 1 << m; i ++)
		for (int j = 0; j < 1 << m; j ++)
			if (((i | j | i << 1 | i >> 1) & (1 << m) - 1) == (1 << m) - 1)
				if (ans1 > f[n][i][j] || f[n][i][j] == ans1 && dp[n][i][j] < ans2)
					ans1 = f[n][i][j], ans2 = dp[n][i][j];
	cout << ans2 << ' ' << ans1 <<'\n';
    system("pause")
	return 0;
}
```

---

## 作者：Pine (赞：6)

# 状压DP

看数据范围$n*m \le 50$&&$m\le n$ 我们发现$m \le 7$完全可以状压

而第i行只会受第i-1和i+1行的影响所以我们只记录两行状态即可

令$f[i][j][k]$表示第$i$行状态为$j$第$i-1$行状态为$k$且前$i-1$都已经完全覆盖的最小总花费

令$g[i][j][k]$则表示所需的最小油库

令$cost(i+1, p) \rightarrow$在第i+1行放p的状态所需的花费，预处理一下就可以了

$f[i+1][p][j] = f[i][j][k] + cost(i+1, p)$

$f[i][j][k]$转移到$f[i+1][p][j]$的条件为:

$$j|k|p|(j\ll1)|(j\gg1)\&(2^m-1) == (2^m-1)$$

表示第i行被完全覆盖

在更新$f$数组的同时顺便更新一下$g$数组就可以了

$ans1=Min\{f[n+1][0][x]\}(x\in[0, 2^m-1])$

ans1为最小花费，而最小油库数则是在最小花费的基础上对于$g$数组取$min$即可

# 代码
```
#include <bits/stdc++.h>
#define R register
#define eps 1e-12
#define INF (1<<30)
#define LL long long
#define LINF (1ll<<60)
#define MM(x, y) memset(x, y, sizeof x)
#define Fo(i, x, y) for(R int i=x; i<=y; ++i)
#define Ro(i, x, y) for(R int i=x; i>=y; --i)
using namespace std;
template<typename T> inline T Max(R T x, R T y) {return x > y ? x : y;}
template<typename T> inline T Min(R T x, R T y) {return x < y ? x : y;}
template<typename T> inline void in(R T &x)
{
	static int ch; static bool flag;
	for(flag=false, ch=getchar(); ch<'0'||ch>'9'; ch=getchar()) flag |= ch=='-';
	for(x=0; ch>='0'&&ch<='9'; ch=getchar()) x = (x<<1) + (x<<3) + ch - '0';
	x = flag ? -x : x;
}
/*************************************Samle*************************************/

int n, m, A[55][55], M, sum[55][130], ss[130];
int f[55][130][130], g[55][130][130];

int main()
{
	in(n); in(m); Fo(i, 1, n) Fo(j, 1, m) in(A[i][j]);
	M = (1<<m)-1;
	Fo(i, 1, n)
	{
		Fo(j, 0, M)
		{
			sum[i][j] = 0; R int fl = 0;
			Fo(k, 1, m) if(j&(1<<(k-1)))
			{
				sum[i][j] += A[i][k]; ++fl;
			}
			ss[j] = fl;
		}
	}
	MM(f, 127/3); MM(g, 127/3);
	Fo(i, 0, M) f[1][i][0] = sum[1][i], g[1][i][0] = ss[i];
	Fo(i, 2, n+1)
	{
		Fo(j, 0, M) Fo(k, 0, M) // j->i-1  k->i-2
		{
			Fo(p, 0, M) if(((j | k | p | (j<<1) | (j>>1)) & M) == M)
			{
				if(f[i-1][j][k] + sum[i][p] < f[i][p][j])
				{
					f[i][p][j] = f[i-1][j][k] + sum[i][p];
					g[i][p][j] = g[i-1][j][k] + ss[p];
				}
				else if(f[i-1][j][k] + sum[i][p] == f[i][p][j])
				{
					g[i][p][j] = Min(g[i][p][j], g[i-1][j][k] + ss[p]);
				}
			}
		}
	}
	R int ans = INF, oo = INF;
	Fo(i, 0, M) if(f[n+1][0][i] < ans) ans = f[n+1][0][i], oo = g[n+1][0][i]; else if(f[n+1][0][i] == ans) oo = Min(oo, g[n+1][0][i]);
	printf("%d %d\n", oo, ans);
	return 0;
}
```

---

## 作者：asuldb (赞：3)

可能我的状态比较鬼畜，应该没有人这么写

设$dp[i][j][k]$表示在第$i$行，放置油库的状态为$j$，实际上周围已经有油库或者本身有油库的状态为$k$的时候的最小花费

由于我们是按照行来$dp$的，所以这里的周围有油库只有三种可能

1. 上一行的这个位置有油库

1. 这个位置本身有油库

1. 同一行上相邻位置有油库

显然如果上一行的某一个状态里，有一些位置周围没有油库，那么就说明接下来这一行的对应位置就必须都放上油库，其余剩下的位置可以放油库也可以不放

于是我们可以枚举子集进行转移

代码

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#define re register
#define lowbit(x) ((x)&(-x))
#define min std::min
int n,m;
int map[51][51];
int dp[51][129][129],s[51][129][129];
int val[51][129],num[129];
inline int read()
{
	char c=getchar();
	int x=0;
	while(c<'0'||c>'9') c=getchar();
	while(c>='0'&&c<='9')
		x=(x<<3)+(x<<1)+c-48,c=getchar();
	return x;
}
inline int logg(int x)
{
	int tot=0;
	while(x) tot++,x>>=1;
	return tot;
}
inline int cnt(int x)
{
	int tot=0;
	while(x) tot++,x-=lowbit(x);
	return tot;
}
int M;
inline int solve(int x)
{
	return M&(((x<<1)|x)|((x>>1)|x));
}
inline void merge(int a,int b,int c,int v,int t,int x,int y,int z)
{
	if(dp[a][b][c]+v>dp[x][y][z]) return;
	if(dp[a][b][c]+v<dp[x][y][z])
	{
		dp[x][y][z]=dp[a][b][c]+v;
		s[x][y][z]=s[a][b][c]+t;
		return;
	}
	s[x][y][z]=min(s[x][y][z],s[a][b][c]+t);
}
int main()
{
	n=read(),m=read();
	for(re int i=1;i<=n;i++)
		for(re int j=1;j<=m;j++)
			map[i][j]=read();
	M=(1<<m)-1;
	for(re int i=1;i<=n;i++)
		for(re int j=1;j<=M;j++)
			val[i][j]=val[i][j-lowbit(j)]+map[i][logg(lowbit(j))];
	for(re int i=1;i<=M;i++) num[i]=cnt(i);
	memset(dp,20,sizeof(dp));
	for(re int i=0;i<=M;i++)
		dp[1][i][solve(i)]=min(dp[1][i][solve(i)],val[1][i]),s[1][i][solve(i)]=num[i];
	for(re int i=2;i<=n;i++)
	{
		for(re int j=0;j<=M;j++)
		{
			int p=M^j;
			for(re int k=p;k;k=(k-1)&p)
			{
				if(dp[i-1][j][k|j]==336860180) continue;
				int d=k|j,s=M^d;
				for(re int t=d;t;t=(t-1)&d)
					merge(i-1,j,d,val[i][s]+val[i][t],num[s]+num[t],i,t|s,j|solve(t)|solve(s));
				merge(i-1,j,d,val[i][s],num[s],i,s,j|solve(s));
			}
			for(re int k=0;k>-1;k--)
			{
				if(dp[i-1][j][k|j]==336860180) continue;
				int d=k|j,s=M^d;
				for(re int t=d;t;t=(t-1)&d)
					merge(i-1,j,d,val[i][s]+val[i][t],num[s]+num[t],i,t|s,j|solve(t)|solve(s));
				merge(i-1,j,d,val[i][s],num[s],i,s,j|solve(s));
			}
		}
	}
	int ans=999999999;
	for(re int i=0;i<=M;i++)
		ans=min(ans,dp[n][i][M]);
	int T=999999999;
	for(re int i=0;i<=M;i++)
	if(dp[n][i][M]==ans) T=min(T,s[n][i][M]);
	printf("%d %d\n",T,ans);
	return 0;
}
```

---

## 作者：nytyq (赞：1)

## 1.算法

状态压缩，DP。

## 2.解法

出题人不想让你一眼切，于是搞了一个奇葩的范围，$n \times m \le 50 $，$m \le n$，易知 $m \le 7$，小数据，考虑状压 dp。

题目中有一个很醒目的坐标勾股条件，实际上就是上下左右包括自己中只要有一个有油库就可以满足条件。

这道题和[互不侵犯](https://www.luogu.com.cn/problem/P1896)这道题有一点相似，考虑设计状态时使用三维设计，且其设计包含当前行状态，上一行状态。

令 $f_{i,j,k}$ 表示第 $i$ 行状态为 $j$，第 $i-1$ 行状态为 $k$，且 $1$ 至 $i-1$ 都已经填得满足条件。

考虑到上一行为 $f_{i-1,k,l}$，其中 $l$ 表示 $i-2$ 行的状态，如果要更新当前这一行，则考虑上一行的状态合不合法。只需要考虑一个点上下左右和自己有没有即可，用二进制可表示为 ```k|l|i|(k>>1)|(k<<1)```，如果满足条件，即可转移。

考虑转移，由于题目中有花费最小值和数量最小值，则有一个花费数组 $f$ 和数量数组 $dp$，其中 $f$ 的转移我们已经考虑，现考虑 $dp$ 的转移，易得为 $dp_{i-1,k,l}+\text{count}(i)$，其中 $\text{count}(i)$ 表示状态 $i$ 中有多少个 $1$。

总时间复杂度为 $O(n2^{3m})$，因为要枚举三层，由于 $m \le 7$，时间复杂度最大 $10^7$，正确。

小 tips：初始化是一个优化时间复杂度的好东西。

## Code:

```
#include<bits/stdc++.h>
using namespace std;


const int M=1<<9,N=51;

int n,m;

int a[N][N];

int f[N][M][M];//价格
//f i,j,k 第i行状态为j,i-1行状态为k,1~i-1全部都填充的满足条件 
int dp[N][M][M];//数量

int c[N][M];//预处理 

int cal(int i,int st){
	int res=0;
	for(int j=0;j<m;j++){
		if(st>>j&1){
			res+=a[i][j+1];
		}
	}
	return res;
} 

int count(int st){
	int cnt=0;
	for(int i=0;i<m;i++){
		if(st>>i&1) cnt++;
	}
	return cnt;
}

int main(){
	cin.tie(nullptr)->sync_with_stdio(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>a[i][j];
		}
	}
	for(int i=1;i<=n;i++){
		for(int st=0;st<(1<<m);st++){
			c[i][st]=cal(i,st);
		}
	}
	memset(f,0x3f,sizeof f);
	for(int st=0;st<(1<<m);st++){
		f[1][st][0]=c[1][st];
		dp[1][st][0]=count(st);
	}
	for(int i=2;i<=n;i++){
		for(int j=0;j<(1<<m);j++){
			for(int k=0;k<(1<<m);k++){
				for(int l=0;l<(1<<m);l++){
					if((((j|k|l|(k>>1)|(k<<1)) & ((1<<m)-1)) == (1<<m)-1) ){
						//只需要上下左右和自己有一个即可 
						/*为什么判断 i-1
						在 1~i-2 中所有的油田都被填充好了， 只有 i-1 的油田未判断  若所有的 i-1 的油田都可以了，则转移 */ 
						int Cost=f[i-1][k][l]+c[i][j],Count=dp[i-1][k][l]+count(j);
						if(f[i][j][k]>Cost || (f[i][j][k]==Cost && dp[i][j][k]>Count)){
							f[i][j][k]=Cost;
							dp[i][j][k]=Count;
						}
					}
				}
			}
		}
	}
	int ans=0x3f3f3f3f,ans1=0x3f3f3f3f;
	for(int i=0;i<(1<<m);i++){
		for(int j=0;j<(1<<m);j++){
			if(((i|j|i>>1|i<<1)&((1<<m)-1))==(1<<m)-1){
				if(f[n][i][j]<ans || (f[n][i][j]==ans && dp[n][i][j]<ans1)){
					ans=f[n][i][j];
					ans1=dp[n][i][j];
				}
			}
		}
	}
	cout<<ans1<<" "<<ans;
	return 0;
}
```

---

## 作者：Mobius127 (赞：1)

~~这种萌萌题给个蓝就差不多了，出题人你说是不是？~~

[题传](https://www.luogu.com.cn/problem/P3888)

这个题我一开始还以为是计算几何（

$(A_x-B_x)^2 + (A_y-B_y)^2=1$ 表示的是以 $(A_x, A_y)$ 的点为圆心，半径为 1 的圆上所有的 $B$ 点，但放在网格图上显然就是上下左右四个位置了。

发现 $nm \le 50 \wedge m \le n$，那么 $m$ 大概到 $7$，直接状压。

显然某一行的状态只与上下两层有关，设 $f_{x, T, G}$ 为第 $x$ 层状态为 $T$，第 $x-1$ 层状态为 $S$ 的最少花费，那么状态转移方程为：

$$f_{x, T, G}=\min_{S|T|G=R} f_{x-1, S, T}+cost(x, G)$$

至于最少放置个数什么的，多加一维即可。

考虑到最后一层的边界问题，直接在 $n+1$ 层多进行一次 DP，最终情况就是 $\min f_{n+1, S, 0}$。

复杂度 $O(n2^{2m})$。

### Code：

```cpp
#include <stdio.h>
#include <algorithm>
#include <string.h>
#include <cctype>
#include <cmath>
using namespace std;
typedef long long ll;
const int INF=0x3f3f3f3f;
inline int read(){
	char ch=getchar();int x=0, f=1;
	while(!isdigit(ch)){if(ch=='-') f=-1; ch=getchar();}
	while(isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return x*f;
}
inline void write(int x){
    if(x<0) putchar('-'), x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
const int N=55;
const int MxS=1<<7;
int n, m, a[N][N], R;
int cnt[MxS], cost[N][MxS];
int f[N][MxS][MxS], ans[N][MxS][MxS];
int Mncost=INF, Mncnt=INF;
bool check(int S, int T, int G){
	if((((S|T|G|(T>>1)|(T<<1)))&(R-1))==R-1) return 1;
	return 0;
}
void DP(int x, int S, int T, int G){
	if(f[x][T][G]>f[x-1][S][T]+cost[x][G])
		f[x][T][G]=f[x-1][S][T]+cost[x][G],
		ans[x][T][G]=ans[x-1][S][T]+cnt[G];
	else if(f[x][T][G]==f[x-1][S][T]+cost[x][G])
		ans[x][T][G]=min(ans[x][T][G], ans[x-1][S][T]+cnt[G]);
}
signed main(){
	memset(f, 127, sizeof(f));
	memset(ans, 127, sizeof(ans));
	n=read(), m=read(), R=1<<m;
	for(int i=1; i<=n; i++)
		for(int j=1; j<=m; j++)
			a[i][j]=read();
	for(int S=0; S<R; S++)
		cnt[S]=cnt[S>>1]+(S&1);
	for(int i=1; i<=n; i++)
		for(int S=0; S<R; S++)
			for(int j=0; j<m; j++)
				if(S&(1<<j))
					cost[i][S]+=a[i][j+1];
			
	for(int S=0; S<R; S++)
		f[1][0][S]=cost[1][S], ans[1][0][S]=cnt[S];
	for(int i=2; i<=n+1; i++)
		for(int S=0; S<R; S++)//i-2
			for(int T=0; T<R; T++)//i-1
				for(int G=0; G<R; G++)//i
					if(check(S, T, G))
						DP(i, S, T, G);				
	for(int S=0; S<R; S++)
		if(f[n+1][S][0]<Mncost) 
			Mncost=f[n+1][S][0], Mncnt=ans[n+1][S][0];
		else if(f[n+1][S][0]==Mncost) 
			Mncnt=min(Mncnt, ans[n+1][S][0]);
	printf("%d %d\n", Mncnt, Mncost);
	return 0;
}


```


---

## 作者：潘德理2010 (赞：0)

:::warning[注意]
本题解包含两种做法（状压 dp 和搜索）。

其中搜索做法不一定能通过数据范围内的所有数据。
:::

## 做法一：状压 dp

看到数据范围 $n\times m\le 50$ 和 $m\le 7$，想到状压 dp。

将前两行的状态进行压缩（总共 $2^{2m}$ 种），然后预处理出所有可能的转移（至多 $2^m$ 种），然后进行状压 dp 即可。时间复杂度 $O(n\times 2^{3m})$，可以通过。注意实现细节。

:::info[状压 dp 代码]
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[55][10];
int f[55][135][135],g[55][135][135];
vector<int> r[135][135];
int rep(int x,int pos){// x 的二进制在第 pos 位的值 
	return (x>>(pos-1))&1;
}
bool ck(int x,int y,int z){// 检查转移可行性 
	int ks,ok=1;
	for(int i=1;i<=m;i++){
		ks=0;
		if(rep(y,i)||rep(x,i)||rep(z,i)) ks=1;
		if(i!=m&&rep(y,i+1)) ks=1;
		if(i!=1&&rep(y,i-1)) ks=1;
		if(!ks){
			ok=0;
			break;
		}
	}
	return ok;
}
void init(){// 预处理转移 
	for(int i=0;i<(1<<m);i++){
		for(int j=0;j<(1<<m);j++){
			for(int k=0;k<(1<<m);k++){
				if(ck(i,j,k)) r[i][j].push_back(k)/*,printf("%d %d %d\n",i,j,k)*/;
			}
		}
	}
}
int sum(int lt,int x){// 第 lt 行状态为 x 增加的费用 
	int res=0;
	for(int i=1;i<=m;i++){
		res+=rep(x,i)*a[lt][i];
	}
	return res;
}
int num(int x){// 状态为 x ，增加的数量（x 二进制下各位数字之和） 
	int res=0;
	for(int i=1;i<=m;i++){
		res+=rep(x,i);
	}
	return res;
}
int main(){
	scanf("%d%d",&n,&m);//输入 
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			scanf("%d",&a[i][j]);
		}
	}
	init();//预处理 
	memset(f,0x3f,sizeof(f));
	f[0][(1<<m)-1][0]=0;// 注意 dp 数组的预处理（*） 
	for(int i=1;i<=n;i++){
		for(int j=0;j<(1<<m);j++){
			for(int k=0;k<(1<<m);k++){
				for(int l=0;l<(int)r[j][k].size();l++){
					int u=r[j][k][l];// j k u
					int v=sum(i,u),w=num(u);
					if(f[i-1][j][k]+v<f[i][k][u]){
						f[i][k][u]=f[i-1][j][k]+v;
						g[i][k][u]=g[i-1][j][k]+w;
					}
					else if(f[i-1][j][k]+v==f[i][k][u]&&g[i-1][j][k]+w<g[i][k][u]){
						g[i][k][u]=g[i-1][j][k]+w;
					}
				}
			}
		}
	}
	int ans=1<<30,ag=0;//统计答案 
	for(int i=0;i<(1<<m);i++){
		for(int j=0;j<(1<<m);j++){
			if(!ck(i,j,0)) continue;//扔掉不可行的解 （*） 
			if(f[n][i][j]<ans){
				ans=f[n][i][j];
				ag=g[n][i][j];
			}
			else if(f[n][i][j]==ans&&g[n][i][j]<ag){
				ag=g[n][i][j];
			}
		}
	}
	printf("%d %d\n",ag,ans);
}
```

:::

## 做法二：搜索

爆搜出奇迹。看到这是 2014 年的题想必数据不是很强，再加上 $n\times m\le 50$ 的数据范围，搜索也不失为一种可行的方法。

搜索的过程就不讲了（不会可以看代码），讲一下如何剪枝：

- 最优性优化。如果当前答案已经不优于全部填完的最优解，直接剪掉。
- 搜索顺序优化。为使其尽可能先得到最优解，进行如下操作：

  我们不难发现，选出的位置的数量大概占所有位置数量的 $1/3$。我们预处理出矩阵中第 $\frac{nm}{3}$ 小的数，记为 $a$。搜索时，如果当前数大于 $a$，则优先执行令其不选的的情况。否则，优先执行令其选的情况。

- 卡时。搜索时，如果时间限制马上要到了，输出当前最优解并退出程序。

:::warning[注意]
以上优化均为常见搜索优化，适用于大部分搜索题，绝非所谓的“玄学优化”。
:::

可以通过此题（[提交记录](https://www.luogu.com.cn/record/228869004)）。实现时仍然需要注意细节。

:::info[搜索代码]
```cpp
#include<bits/stdc++.h>
using namespace std;
int cx[4]={1,-1,0,0},cy[4]={0,0,1,-1};
int n,m,a[55][10],r[55][10],k[55][10];
int avr,ans=1e9,ag;
bool ck_tim(){// 时间函数 
	return clock()<CLOCKS_PER_SEC*0.998;
}
void pr(){//输出 
	printf("%d %d\n",ag,ans);
	exit(0);
}
bool in(int x,int y){// x,y 在矩阵内 
	if(1<=x&&x<=n&&1<=y&&y<=m) return 1;
	return 0;
}
bool ck_pos(int x,int y){// 当前位置及其旁边是否有 1 
	if(!in(x,y)) return 1;
	for(int l=0;l<4;l++){
		int tx=x+cx[l],ty=y+cy[l];
		if(!in(tx,ty)) continue;
		if((!k[tx][ty])||r[tx][ty]) return 1;
	}
	if(r[x][y]) return 1;
	return 0;
}
int ch(int x,int y,int z){// x,y 位置填 z 是否合法 
	k[x][y]=1;
	r[x][y]=z;
	if(ck_pos(x,y-1)&&ck_pos(x-1,y)) return 1;
	return 0;
}
void cb(int x,int y){// 回溯 
	k[x][y]=r[x][y]=0;
}
void dfs(int x,int y,int sum,int sg){// 搜索函数 
	if(!ck_tim()) pr();//卡时 
	if(ans<sum||(ans==sum&&ag<=sg)) return;
	if(y==m+1){
		if(x==n){
			if(!ck_pos(n,m)) return;// 去掉不合法解 
			ans=sum;
			ag=sg;
			return ;
		}
		x++;
		y=1;
	}
	if(a[x][y]<avr){// 小于 avr 的，先执行选的情况 
		if(ch(x,y,1)) dfs(x,y+1,sum+a[x][y],sg+1); 
		cb(x,y);
		if(ch(x,y,0)) dfs(x,y+1,sum,sg);
		cb(x,y);
	}
	else{// 大于等于 avr 的，先执行不选的情况 
		if(ch(x,y,0)) dfs(x,y+1,sum,sg);
		cb(x,y);
		if(ch(x,y,1)) dfs(x,y+1,sum+a[x][y],sg+1); 
		cb(x,y);
	}
}
int main(){
	scanf("%d%d",&n,&m);//输入 
	vector<int> v;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			scanf("%d",&a[i][j]);
			v.push_back(a[i][j]);
		}
	}
	sort(v.begin(),v.end());
	avr=v[n*m/3];
	dfs(1,1,0,0);
	pr();
}
```

:::

---

## 作者：liangbowen (赞：0)

[problem](https://www.luogu.com.cn/problem/P3888) & [blog](https://www.cnblogs.com/liangbowen/p/17664121.html)。

这怎么评到紫上去的啊？差不多就个上位绿吧 /qd。

---

首先出题人非常 low。为什么这样说呢？因为 $nm\le 50,m\le n$ 就是在说 $m\le 7$，出题人为了不让你一眼秒掉这一题，就用这种猥琐的方法写数据范围，是不是很傻逼呢。

然后就是状压 DP 板板题了，判断合法状态只需要知道当前行与上一行的选择情况，于是 $dp_{i,s,t}$ 表示当前是第 $i$ 行，当前行状态为 $s$，上一行状态为 $t$，答案（同时记录代价和个数）。

对于连续的三行 $s,t,p$，合法转移即：中间行的任意数，要么自己选了，要么相邻的四个位置选了。具体转移
+ $dp_{i,s,t}=\min\limits_{p}\{dp_{i-1,t,p}+(\text{*})\}$。
+ 转移最小花费时 $(\text{*})=\sum\limits_{\text{select j}}^{\text{in line }i} a_{i,j}$（显然可以预处理）。
+ 转移最小个数时 $(\text{*})=\sum\limits_{\text{select j}}^{\text{in line }i} 1$（即二进制下 $1$ 的个数）。

初始化 $+\infty$，第一行直接算出来，后面 DP，统计答案时枚举最后一行的合法状态，求最优决策即可。

[code](https://www.luogu.com.cn/paste/eznqkzzn)，时间复杂度 $O(n2^{3m})$。由于 $n,m$ 呈反比例关系，所以 $n,m$ 显然不可能同时取到最大值，因此很轻松就跑过去啦。


---

## 作者：louhao088 (赞：0)

# 题意
在一矩阵中，选取和尽量小的数，使其满足每个位置上下左右中至少有一个选。

## 思路

由于$n*m<=50$,$n>=m $,易证 $m<=7$。

故选用状压DP

f[i][j][k]表示第i-1行状态为j第i行状态为k的方案。

## 注意 

1. 判断时有可能会超过$2^m$,所以对其判断要&($2^m$-1).


2. 最后统计时也要判断

3. 数组第一维要超过50不然会$RE$

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[55][55],f[55][(1<<8)+1][(1<<8)+1],s[55][(1<<8)+1][(1<<8)+1],ans=0x3f3f3f3f,size;
int getsum(int i,int x)//求花费 
{
	int sum=0,t=0;
	while(x)
	{
		t++;
		if(x%2==1)sum+=a[i][t];
		x=x/2;
	}
	return sum;
}
int gets(int x)//求个数 
{
	int sum=0,t=0;
	while(x)
	{
		t++;
		if(x%2==1)sum++;
		x=x/2;
	}return sum;
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			cin>>a[i][j];
	memset(f,0x3f,sizeof f);
	for(int i=0;i<(1<<m);i++)
		f[1][0][i]=getsum(1,i),s[1][0][i]=gets(i);
	for(int i=2;i<=n;i++)
	{
		for(int j=0;j<(1<<m);j++)//第i-2行状态 
		{
			for(int k=0;k<(1<<m);k++)//第i-1行状态 
			{
				if(f[i-1][j][k]==0x3f3f3f3f)continue;
				for(int l=0;l<(1<<m);l++)//第i行状态 满足前i-1行成立 
				{
					if((k|l|j|(k>>1)|(k<<1)&((1<<m)-1))==((1<<m)-1))//上一行，下一行，本行左右,
					{
						if(f[i][k][l]>f[i-1][j][k]+getsum(i,l))//转移
						{
							f[i][k][l]=f[i-1][j][k]+getsum(i,l);
							s[i][k][l]=s[i-1][j][k]+gets(l);
						}
						else if(f[i][k][l]==f[i-1][j][k]+getsum(i,l))
						{
							s[i][k][l]=min(s[i][k][l],s[i-1][j][k]+gets(l));
						}
					} 
				}
			}
		}
	}
	for(int i=0;i<(1<<m);i++)
		for(int j=0;j<(1<<m);j++)
		{
			if((i|j|(j>>1)|(j<<1)&((1<<m)-1))==((1<<m)-1))//判断
			{
				if(ans>f[n][i][j])ans=f[n][i][j],size=s[n][i][j];
				else if(ans==f[n][i][j])size=min(size,s[n][i][j]);
			}
		}
	cout<<size<<" "<<ans<<endl;
    return clock();
}
```




---


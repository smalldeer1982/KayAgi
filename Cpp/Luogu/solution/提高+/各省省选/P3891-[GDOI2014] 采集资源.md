# [GDOI2014] 采集资源

## 题目描述

魔兽争霸 3 中，战略资源的采集通过使用农民、苦工、小精灵以及寺僧来进行。

在魔兽争霸 4 的开发中，玻璃渣觉得这种模式太过单一，于是他们想添加更多的单位来使采集的模式更加丰富。

在新的模式中，玩家可以建造更多种类的“苦工”，不同的“苦工”的工作效率不同，同时，建造不同的“苦工”所需要的资源也是不一样的。

玻璃渣出品的游戏以追求平衡著称，所以为了测试这种新的模式的平衡性，他们设计了一套检测的方法：在各种族的起始资源相同时，测量达到某一资源数量的时间，如果相同则可以认为设计是平衡的。

他们将数据给你，希望你能测试出设计是否平衡。

## 说明/提示

对于 $30\%$ 的数据，$N\le 10$，$M,T \le  300$；

对于 $100\%$ 的数据，$N\le 100$，$M,T \le1000$，$A,B\le 2^{31}$。

数据保证有解。

## 样例 #1

### 输入

```
1 1 8
1 1
```

### 输出

```
4```

## 样例 #2

### 输入

```
2 1 8
1 1
2 8
```

### 输出

```
3```

# 题解

## 作者：xyzfrozen (赞：9)

# P3891 [GDOI2014]采集资源

考虑完全背包

$f_{i,j}$ 考虑前 $i$ 种矿工，达到资源 $j$ 的最小时间

每次考虑买不买，枚举 $f_{i,k}$ 转移，剩下的当前矿工产生

这个是错误滴，因为每次只考虑了一个矿工所产生的，相当于是每次时间一直累加，但其实上时间应该是有交集的

所以我们发现必须要把时间这一个变量带进去，重新设计 $dp$ 状态

$f_{i,j}$ 当前时间 $i$，单位效率 $j$ 能达到的最大资源

当前时间可以买矿工，赚钱，我们先考虑买矿工，然后向后转移（向前转移不好算），保证用到的状态一定被更新完

每个时间点枚举所有种类矿工即可

$$f_{i,j} \leftarrow f_{i,j-val_{i.se}}-val_{i.fi}$$

$$f_{i,j} \rightarrow f_{i+1,j}+j$$

```cpp
const int N=110,M=1e3+10;
int n,m,t;
int f[M][M];
pi val[N];

signed main()
{
	n=fr(),m=fr(),t=fr();
	if(m>=t) {puts("0");return 0;}
	//买它的价格 它的效率
	for(int i=1;i<=n;i++) val[i]={fr(),fr()};
	
	memset(f,-0x3f,sizeof f);
	f[0][0]=m;
	
	for(int i=0;i<=t;i++)
	{
		for(int j=0;j<=t;j++)
		{
			for(int k=1;k<=n;k++)
				if(j>=val[k].se && f[i][j-val[k].se]>=val[k].fi) f[i][j]=max(f[i][j],f[i][j-val[k].se]-val[k].fi);
			if(f[i][j]>=t) {fw(i);return 0;}
			f[i+1][j]=f[i][j]+j;
		}
	}
	
	return 0;
}
```

---

## 作者：csyakuoi (赞：8)

使用动态规划算法解决本题。

因为单位时间内购买苦工的数量没有限制，所以我们设$dp1[i]$表示单位时间内花费$i$资源购买苦工能取得的最大生产力，那么$dp1[i]$可以用完全背包求出。

设$dp2[i][j]$表示$i$单位时间后剩下$j$资源能拥有的最大生产力。我们可以枚举时间$i$，拥有的资源量$j$，以及在第$i$单位时间用于购买苦工的资源量。利用$dp1[i]$，我们可以$O(1)$进行转移$($从下往上递推$)$，当拥有的资源数到达或超过$T$时，输出答案。

$AC$代码：
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

int n,m,t;
int kga[100],kgb[100];
int dp1[1000],dp2[1000][1000];

int main(void)
{
	scanf("%d%d%d",&n,&m,&t);
	if(m>=t){
		printf("0\n");
		return 0;
	}
	for(int i=0;i<n;i++)
		scanf("%d%d",&kga[i],&kgb[i]);
	memset(dp1,-1,sizeof(dp1));	dp1[0]=0;
	for(int i=0;i<n;i++)
		for(int j=1;j<1000;j++)
			if(j>=kga[i]&&dp1[j-kga[i]]!=-1)
				dp1[j]=max(dp1[j],dp1[j-kga[i]]+kgb[i]);
	//		完全背包计算dp1数组
    
    //		-1表示无法到达状态
	memset(dp2,-1,sizeof(dp2));	dp2[0][m]=0;
	for(int i=0;i<=1000;i++){
		if(dp2[i][t]!=-1){
			printf("%d\n",i);
			return 0;
		}//		到达t资源
		for(int j=0;j<=t;j++){
			if(dp2[i][j]==-1)
				continue;
			for(int k=0;k<=j;k++){
            	
            	//拥有j资源，花费k资源买苦工
                //则下一时刻拥有j-k+dp1[k]+dp2[i][j]资源
                
				if(dp1[k]==-1)
					continue;
				if(j-k+dp1[k]+dp2[i][j]>=t){
					printf("%d\n",i+1);
					return 0;
				}//		到达t资源
				if(dp2[i+1][j-k+dp1[k]+dp2[i][j]]<dp2[i][j]+dp1[k])
					dp2[i+1][j-k+dp1[k]+dp2[i][j]]=dp2[i][j]+dp1[k];
			}//		转移
		}
	}
	return 0;
}
```

---

## 作者：intel_core (赞：6)

考虑当前决策的几个影响因素：

* 当前手中资源数。

* 当前单位时间产量。

设 $f_{T,i}$ 表示时间为 $T$ ，单位时间产量为 $i$ 时资源数的最大值。

那么很自然地，有：

* $f_{T,i}=max_{j=1}^n\{f_{T,i-b[j]}-a[j] \}$ （购买苦力）

* $f_{T+1,i}=f_{T,i}+i$ （模拟一个单位时间）

最劣复杂度 $O(nMT)$ ，我还害怕跑不过写了滚动数组，实际效率 $\text{rk1}$。

（使用 $\text{int}$ 的同学们不要忘了 $2^{31}-1+k$ 可能越界。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int NR=1e3+10;
int n,s,t,ans=1000,a[NR],b[NR],f[2][NR];

int main(){
	cin>>n>>s>>t;
	for(int i=1;i<=n;i++)cin>>a[i]>>b[i];
	if(s>=t){
		puts("0");
		return 0;
	}
	memset(f[0],-999999,sizeof(f[0]));f[0][0]=s;
	for(int i=0;i<ans;i++){
		int now=i&1,pre=now^1;
		for(int j=0;j<=t;j++)
			for(int k=1;k<=n;k++)
				if(f[now][j]>=a[k]){
					if(j+b[k]<=t)f[now][j+b[k]]=max(f[now][j+b[k]],f[now][j]-a[k]);
					else ans=i+1;
				}
		memset(f[pre],-9999999,sizeof(f[pre]));
		for(int j=0;j<=t;j++)
			if(f[now][j]+j>=t)ans=i+1;
			else f[pre][j]=f[now][j]+j;
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：Withershine (赞：5)

看到大家都是两个动态规划的写法，来给大家讲一下只用一次动态规划的写法。

## 思路
设 $f_{i,j}$ 表示工作效率为 $i$，获取 $j$ 点资源所需的最短时间，不以苦工设状态是因为苦工会因为后面购买而改变，不太现实。$tme$ 表示答案，即到达 $t$ 点资源所需的最短时间。

从 $0$ 到 $t$ 枚举 $i$ 和 $j$，接着枚举每一种苦工，用 $k$ 表示第 $k$ 种苦工，需要 $a_k$ 的资源，效率为 $b_k$。像完全背包那样子推。具体的 `f[i + b[k]][j - a[k]] = min(f[i + b[k]][j - a[k]] , f[i][j])`，表示招募一个苦工，但注意这个苦工所需资源不能超过 $j$，很容易理解，由于目前状态只要求达到 $j$ 点资源，当能够购买 $b_k \ge j$ 的第 $k$ 种苦工之前，就至少有了 $j$ 点资源，就没必要再买了。

买了苦工后，自然效率变为 $i+b_k$，而资金只有 $j-a_k$，这时的最小时间要么是 $f_{i+b_k,j-a_k}$，要么就是 $f_{i,j}$。这应该是很容易便能想明白的。（因此，$f$ 数组初始都设为极大值）

如果此时 $i+b_k \ge t$，说明此时如果买苦工的话效率就已经超过所需的 $t$ 点资源了，那么 $tme$ 就需要更新答案，与 $f_{i,j}+1$ 求一个较小值。为什么是与 $f_{i,j}+1$ 而不是 $f_{i+b_k,j-a_k}$ 呢？

首先，$f_{i+b_k,j-a_k}$ 可能越界。其次，效率超过 $t$ 时其实就已经没有必要再买了，因为再等待一个单位时间后，现有的资源就变为 $i+j$ 就会超过 $t$，感兴趣的同学可以自己去验证一下，所以 $tme$ 与 $f_{i,j}$ 取最小值。（这其实也是一个优化，即 $i+b_k<t$ 才需要更新 $f$ 数组）

在每次枚举完苦工种类后，也需要考虑如果此后一直不买苦工是否会需要更少的时间就能达到 $t$ 点资源，即
```cpp
if(i)
{
	tme = min(tme , (t - j + i - 1) / i + f[i][j]);
}
```
明显，当 $i=0$ 时无论如何都不会到达 $t$，所以从 $i=1$ 开始判断。同时也要注意当 $m$ 一开始就大于 $t$ 时直接输出 $0$ 即可。

对于每一个 $f_{i,i+j}$，明显可以由 $f_{i,j}$ 经过一个时间单位得到，这里也需要对 $f_{i,i+j}$ 进行更新，即
```cpp
if(i + j < t)
{
	f[i][i + j] = min(f[i][i + j] , f[i][j] + 1);
}
```
复杂度 $O(nt^2)$，能过。

请原谅我拙劣的表达，真的尽力了。
## 代码
```cpp
#include<bits/stdc++.h>
#define ll long long
#define mod 1000000007
#define fr(i , a , b) for(ll i = a ; i <= b ; ++i)
#define fo(i , a , b) for(ll i = a ; i >= b ; --i)
using namespace std;
inline ll QuickPow(ll a , ll b)
{
	if(b == 0)
	{
		return 1;
	}
	ll k = QuickPow(a , b>>1);
	if(b & 1)
	{
		return (k * k * a) % mod;
	}
	return (k * k) % mod;
}
ll n , m , t;
ll tme = 0x3f3f3f3f;
ll a[10000] , b[10000];
ll f[1001][1001];
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> m >> t;
	memset(f , 0x3f3f3f3f , sizeof(f));
	if(m >= t)
	{
		cout << 0;
		return 0;
	}
	fr(i , 1 , n)
	{
		cin >> a[i] >> b[i];
	}
	fr(i , 1 , m)
	{
		f[0][i] = 0;
	}
	fr(i , 0 , t)
	{
		fr(j , 0 , t)
		{
			fr(k , 1 , n)
			{
				if(a[k] < j)
				{
					f[i + b[k]][j - a[k]] = min(f[i + b[k]][j - a[k]] , f[i][j]);
					if(i + b[k] >= t)
					{
						tme = min(tme , f[i][j] + 1);
					}
				}
			}
			if(i)
			{
				tme = min(tme , (t - j + i - 1) / i + f[i][j]);
			}
			if(i + j < t)
			{
				f[i][i + j] = min(f[i][i + j] , f[i][j] + 1);
			}
		}
	}
	cout << tme;
	return 0;
}
```

---

## 作者：xztxzt (赞：3)

**题目描述**

魔兽争霸3中，战略资源的采集通过使用农民、苦工、小精灵以及寺僧来进行。

在魔兽争霸4的开发中，玻璃渣觉得这种模式太过单一，于是他们想添加更多的单位来使采集的模式更加丰富。

在新的模式中，玩家可以建造更多种类的“苦工”，不同的“苦工”的工作效率不同，同时，建造不同的“苦工”所需要的资源也是不一样的。

玻璃渣出品的游戏以追求平衡著称，所以为了测试这种新的模式的平衡性，他们设计了一套检测的方法：在各种族的起始资源相同时，测量达到某一资源数量的时间，如果相同则可以认为设计是平衡的。

他们将数据给你，希望你能测试出设计是否平衡。


------------

**输入格式**

第一行三个数，N, M, T, 表示苦工的种类、开始时拥有的资源数量以及需要达到的资源的数量。

接下来N行，每行2个数A, B, 表示生产这种苦工所需要的资源，以及这个苦工的效率，效率即为单位时间内产生的资源的数量。


------------

**输出格式**

一个数字，表示资源数量达到T时的最少时间。

注意：与魔兽争霸3不同，魔兽争霸4中，生产苦工不需要时间。并且资源的采集并不连续，亦即如果一个苦工的效率为2，他会在时间为1的时候收获2点资源，而并不会在时间为0.5的时候收获1点资源。




------------


因为这道题的标签是dp，所以我就写了一个dp的代码

首先，我们可以定义f1[i]为在单位时间内拥有i个资源所能达到的最大生产量。

由于苦工有无限个，所以就可以用完全背包做这道题。

```
for(int i=0;i<=t;i++)f1[i]=-1;
f1[0]=0;
for(int i=1;i<=n;i++){//枚举苦工的种类
	for(int j=1;j<=t;j++){
		if(j-r[i]<0)continue;
		if(f1[j-r[i]]==-1)continue;
		f1[j]=max(f1[j],f1[j-r[i]]+f[i]);
	}
}
```


------------

接下来，我们可以定义一个f2[i][j]为在第i个单位时间里拥有j个资源所能达到的最大生产量。

所以，第一个循环可以枚举当前的时间，第二个循环枚举当前的资源，第三个循环枚举花费多少个资源去购买苦工
最后再判断一下目前资源超过t了没有，有就立刻输出，不然会超时。


------------

代码君：
```cpp
#include<iostream>
using namespace std;
int n,m,t;
int f1[1010],f2[1010][1010];
int r[110],f[110];
int main(){
	cin>>n>>m>>t;
	if(m>=t){
		cout<<0<<endl;
		return 0;
	}
	for(int i=1;i<=n;i++){
		cin>>r[i]>>f[i];
	}
    //初始化
	for(int i=1;i<=t;i++){
		f1[i]=-1;
	}
	for(int i=0;i<=t;i++){
		for(int j=0;j<=t;j++){
			f2[i][j]=-1;
		}
	}
	f2[0][m]=0;
    //计算f1数组
	for(int i=1;i<=n;i++){
		for(int j=1;j<=t;j++){
			if(j-r[i]<0)continue;
			if(f1[j-r[i]]==-1)continue;
			f1[j]=max(f1[j],f1[j-r[i]]+f[i]);
		}
	}
	for(int i=0;i<=1000;i++){
		if(f2[i][t]!=-1){
			cout<<i<<endl;
			return 0;
		}
		for(int j=0;j<=t;j++){
			if(f2[i][j]==-1)continue;
			for(int k=0;k<=j;k++){
				if(f1[k]==-1)continue;
                		//因为下一个单位时间的生产量为j-k+f[1]+f2[i][j]
				if(j-k+f1[k]+f2[i][j]>=t){
					cout<<i+1<<endl;
					return 0;
				}
                		//更新f2数组
				f2[i+1][j-k+f1[k]+f2[i][j]]=max(f2[i+1][j-k+f1[k]+f2[i][j]],f2[i][j]+f1[k]);
			}
		}
	}
	return 0;
}
```



---

## 作者：红色OI再临 (赞：3)

题目有点小复杂，大概是问你要你用手上的价值赚到规定的价值所用的最小天数，可以在其中购买苦力，苦力无限购买。

因为能无限购买苦力，我们就可以先跑一遍完全背包，`f[i]`表示用i个资源能买到的最大的野人效率，将每个野人当成一件物品就能求出f数组

但是这样还是不够，我们仍然无法判断是否有足够多的价值，于是考虑2次dp

设`dp[i][j]`表示当前是第`i`个时间，有`j`个资源能买到的最大的野人效率，考虑枚举一个`k`表示花费`k`的资源能买到的最大野人效率，这个也就是我们之前求过的`f`，这个时候我们就可以表示第`i+1`个时间的收益，也就是以当前状态工作一秒后的收益

$$w=(j-k)+f[k]+dp[i][j]$$

翻译一下就是：`1s`后收益`=1s`后剩余的资源+新买的+原来就会贡献的

此时判断一下w是否大于t，若大于输出即可

若不大于，但我们的状态可以被更新：

$$ dp[i+1][w]=max(f[k]+dp[i][j],dp[i+1][w]);$$

跟上面的w求法很相似

于是本题大体就做完了。

几个坑点：

1. 一开始有的m>t直接输出

2. 貌似有a[i]=0的情况？？？，k要从0开始枚举



这大概也是我在2019CSP-S前发的最后一篇题解了，


祝大家


# **CSP2019RP++**







```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#define re register int
#define ll long long
#define tmaxn 1005
#define maxn 200
using namespace std;
int f[tmaxn];
//f[i]表示用i个资源能买到的最大的野人效率
int dp[tmaxn][tmaxn];
//dp[i][j]表示当前是第i个时间，有j个资源能买到的最大的野人效率
int n,m,t;
int a[maxn],b[maxn];
int main(){
	scanf("%d%d%d",&n,&m,&t);
	for(re i=1;i<=n;i++)
		scanf("%d%d",&a[i],&b[i]);
	for(re i=1;i<=n;i++)
		for(re j=a[i];j<=1000;j++)
			f[j]=max(f[j],f[j-a[i]]+b[i]);
	if(m>=t){
		printf("0\n");
		return 0;
	}
	memset(dp,-1,sizeof(dp));
	dp[0][m]=0;
		for(re i=0;i<=1000;i++)
		{
			//printf("%d ",i);
			if(dp[i][t]!=-1){
				printf("%d\n",i);
				return 0;
			}
			for(re j=0;j<=t;j++){
			//枚举资源
			//	printf("%d %d\n",dp[i][j]);
				if(dp[i][j]==-1)continue;

				for(re k=0;k<=j;k++){
				//枚举花多少买苦力
					if(f[k]==0)continue;
					int w=(j-k)+f[k]+dp[i][j];
					//1s后剩余的资源+新买的+原来就会贡献的
					if(w>=t){
						printf("%d",i+1);
						return 0;
					}
					dp[i+1][w]=max(f[k]+dp[i][j],dp[i+1][w]);
				}
			}
		}
	
	

	return 0;
}
```



---

## 作者：Konnyaku_ljc (赞：3)

### 不可多得的两个DP  
做多了DP，就会发现，这个题， ~~很水~~ 需要两个DP  
第一个DP，是一个完全背包——求现在可获得的最大价值，和[这个题](https://www.luogu.com.cn/problem/P1616)一模一样。  
然后就比较麻烦了。  
动态转移方程——  
```cpp
for ( int i = 1; i <= n; i++ )//完全背包DP 
	for ( int j = 1; j <=t; j++ )
	    if ( a[i] <= j && f[j-a[i]] != -1 )
```
根据我的推断，因为每个“苦工”最少会创造价值1，所以会在时间t内创造出价值t  
继续枚举在时间i时创造的价值，若 dp [i][j] 被赋过值，则用dp[i][j]枚举求出dp [i+1][ j - k + f[k] + dp[i][j] ] (k<=j) ;  
则动态转移方程为——  
```cpp
for ( int k = 0; k <= j; k++ )//可以造兵 
{//动态转移 
    if ( f[k] == -1 ) continue;
    int sum = j - k + f[k] + dp[i][j];
    if ( t <= sum ) cout << i , exit(0);//符合要求 
    dp[i+1][sum] = max (dp[i+1][sum],dp[i][j]+f[k]);
}
```
当 j - k + f[k] + dp [i][j] 成立时，直接输出 i （此时时间）。\
完整代码：
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>//誓死不用万能头！！！
using namespace std;
int n,m,t,a[1005],b[1005];//题目要求 
int f[1005],dp[1005][1005];//两次DP 
int main()
{
	cin >> n >> m >> t;//输入 
	if (m > t) cout << 0 ,exit(0);
	for ( int i = 1; i <= n; i++ ) cin >> a[i] >> b[i];
	for ( int i = 1; i <= t; i++ ) f[i] = -1;
	for ( int i = 1; i <= n; i++ )//完全背包DP 
	    for ( int j = 1; j <=t; j++ )
	        if ( a[i] <= j && f[j-a[i]] != -1 )
			    f[j] = max (f[j],f[j-a[i]]+b[i]);
	memset (dp,-1,sizeof(dp)) , dp[1][m] = 0;
    for ( int i = 0; i <= t; i++ )//时间 
    	for ( int j = 0; j <= t; j++ )//价值 
        {
        	if( dp[i][j] == -1 ) continue;//没被赋值 
        	for ( int k = 0; k <= j; k++ )//可以造兵 
        	{//动态转移 
        		if ( f[k] == -1 ) continue;
        		int sum = j - k + f[k] + dp[i][j];
        		if ( t <= sum ) cout << i , exit(0);//符合要求 
        		dp[i+1][sum] = max (dp[i+1][sum],dp[i][j]+f[k]);
			}
		}
	return 0;
}
```
谢谢观赏~~  
##### 另：必须判m>t，不然90pt,qwq

---

## 作者：bssmessi (赞：1)

我们设 $f_{i,j}$ 为经过了 $i$ 个单位时间当前单位效率为 $j$ 时的最大资源数，$v_{k}$ 与 $w_{k}$ 分别为第 $k$ 种短工的效率和价格，所以我们考虑枚举买每种短工对当前状态的贡献，我们有：
$$f_{i,j}=\max{f_{i,j-v_{k}}-w_{k}}$$
而我们枚举时，因为第二维是单位效率，由上一个单位效率转移而来，因此上一个状态可能是包含此时买了这种短工的方案，所以不用枚举一次买单种短工的个数，这样时间复杂度就在 $O(n^{3})$。

需要注意的是我们还要考虑当前不买短工的转移。
```cpp
#include<bits/stdc++.h>
#define int long long
#define w first 
#define v second 
using namespace std;
const int N=1010;
int n,m,t,f[N][N];
pair<int,int> a[N];
signed main(){
	cin>>n>>m>>t;
	for(int i=1;i<=n;i++) cin>>a[i].w>>a[i].v;
	memset(f,-0x3f,sizeof(f));
	f[0][0]=m;
	for(int i=0;i<=t;i++){
		for(int j=0;j<=t;j++){
			for(int k=1;k<=n;k++){
				if(f[i][j-a[k].v]-a[k].w>=0&&j-a[k].v>=0) f[i][j]=max(f[i][j],f[i][j-a[k].v]-a[k].w);
			}
			if(f[i][j]>=t){
				cout<<i;
				return 0;
			}
			f[i+1][j]=f[i][j]+j;
		}
	}
	return 0;
}
```

---

## 作者：jiazhichen844 (赞：1)

## 题意
你初始有 $m$ 块钱，每一秒，你可以从 $n$ 种苦工里选**一些，可以重复**，每个花 $a_i$ 块钱购买，或者什么也不做，然后，每个苦工会给你 $b_i$ 元，包括刚买的，问你至少多少秒才能使钱数 $\ge T$。
## 思路
### Step 1
一眼丁真，鉴定为 dp。

设 $dp_{i,j}$ 为当前钱数为 $i$，每秒得到钱数为 $j$，钱数要 $\ge T$ 的最小秒数。考虑枚举这一秒干了什么，如果什么也没干，则 $dp_{i,j}=dp_{i+j,j}+1$。如果买了第 $k$ 种苦工，则 $dp_{i,j}=dp_{i-a_k,j+b_k}$。枚举顺序也很显然，先从大到小枚举 $j$，其他的随便枚举。答案为 $dp_{m,0}$。

于是，你就华丽的 MLE 了……
### Step 2
考虑最坏情况下，第二维的大小为 $100 \times 2^{31} \approx 2 \times 10^{11}$，空间过大，考虑优化。

观察到 $T \le 1000$，也易发现当每秒钟可以获得的钱数 $\ge T$ 时，只需 $1$ 秒即可结束，于是理所当然的把第二维压成 $O(T)$ 的，总空间复杂度 $O(T^2)$。

转移时，略加判断即可，时间复杂度 $O(nT^2)$，可以卡过。
## code
```cpp
#include<bits/stdc++.h>
using namespace std;
long long dp[1005][1005];
long long a[105],b[105];
int main()
{
	int n,m,t;
	cin>>n>>m>>t;
	memset(dp,31,sizeof(dp));
	for(int i=0;i<=t;i++)
		dp[t][i]=0;
	for(int i=1;i<=n;i++)
		cin>>a[i]>>b[i];
	for(int j=t;j>=0;j--)
		for(int i=t;i>=0;i--)
		{
			if(i==t)
				continue;
			if(j+i<=t)
				dp[i][j]=dp[i+j][j]+1;
			else
			    dp[i][j]=1;
			for(int k=1;k<=n;k++)
			{
				if(i-a[k]>=0&&j+b[k]<=t)
					dp[i][j]=min(dp[i-a[k]][j+b[k]],dp[i][j]);
				else if(i-a[k]>=0)
					dp[i][j]=min(dp[i][j],1LL);
			}
		}
	long long minn=LLONG_MAX;
	for(int i=0;i<=m;i++)
		minn=min(minn,dp[i][0]);
	cout<<minn;
}
```

---

## 作者：yzy4090 (赞：1)

[原题链接](https://www.luogu.com.cn/problem/P3891)  

显然当 $t\le m$ 时需求已经满足，需要特判。我们可以发现，只有效率和资源决定了时间。所以我们可以建立一个二维数组 $f$，设 $f_{i,j}$ 表示效率为 $i$，当前资源为 $j$ 的最小时间。    不难发现如下等式：  
$$f_{i+b_k,j-a_k}=\min(f_{i+b_k,j-a_k},f_{i,j})$$  
$$f_{i,i+j}=\min(f_{i,i+j},f_{i,j}+1)$$  
第一个等式描述了购买第 $k$ 个苦工的状态转移方程，第二个等式描述了不购买任何苦工时的状态转移方程。最终答案就是 
$$\underset{0\le i\le t}{\min}f_{i,t}$$

至此可以写出代码，时间复杂度为 $O(t^2k)$：  
```
#include<iostream>
#include<cstring>
#include<cmath>
using namespace std;
const int N=105;
int n,m,t,o,a[N],b[N],f[1005][1005],ans=0x7f7f7f7f;
int main(){
	scanf("%d%d%d",&n,&m,&t);
	if(t<=m)puts("0"),exit(0);
	long long c,d;
	for(int i=1;i<=n;i++){
		scanf("%lld%lld",&c,&d);
		if(c>=t)continue;
		a[++o]=(int)c;
		b[o]=min(t,(int)d);
	}
	memset(f,0x7f,sizeof f);
	for(int i=0;i<=m;i++)
		f[0][i]=0;
	for(int i=0;i<=t;i++){
		for(int j=0;j<=t;j++){
			if(f[i][j]==0x7f7f7f7f)continue;
			if(i){
				int now=min(i+j,t);
				f[i][now]=min(f[i][now],f[i][j]+1);
			}
			for(int k=1;k<=o;k++)
				if(j-a[k]>=0){
					int now=min(t,i+b[k]);
					f[now][j-a[k]]=min(f[now][j-a[k]],f[i][j]);
				}
		}
		ans=min(ans,f[i][t]);
	}
	printf("%d",ans);
	return 0;
}
```
注：不适合设 $f_{i,j}$ 表示当前资源为 $i$，效率为 $j$ 的最小时间，因为效率只增不减，适合从小到大遍历；而资源量则没有这样的性质，因为它可能会上下波动。

---

## 作者：wangyibo201026 (赞：0)

## solution

还算不错的一个 DP 题。

发现你买苦力会消耗资源，苦力又会生产资源，以资源总量为状态显然不合适。

注意到当固定一个时刻时，我们只关心此时总苦力的生产效率，也就是单位时间生产的资源，于是我们的状态需要和生产效率挂钩。

注意到无论资源怎么变，时间永远都是增加的，考虑对于时间 DP。设 $f_{i, j}$ 为到第 $i$ 个时刻，总生产效率为 $j$ 的最大资源总数，那么初始状态显然有 $f_{0, 0} = m$。

转移分两种，对于买苦力的有：

$$f_{i, j} = f_{i, j - b_k} - a_k$$

注意到买苦力不耗费时间，所以 $i$ 不边，而且每个苦力无限，所以采用类似完全背包的方式顺序枚举 $j$。

还有就是我从一个时刻转移到下一个时刻，生产效率不会变，但是资源总量会变，即：

$$f_{i, j} = f_{i - 1, j} + j$$

按照如上两种转移即可。

---

## 作者：Liuboom (赞：0)

# P3891 [GDOI2014] 采集资源

## 题意简述：

开始时你有数量为 $m$ 的资源，有 $n$ 种“苦工”可以**不限次数**地建造，每种苦工都有一个花费 $a$ ，和一个效率 $b$ ，要求最小化资源数量到达 $t$ 的时间


## Solution：
我们考虑先对于每一种花费 $i$ 最大化它的“单位时间内产生的资源的数量”，记为 $w_i$ 这可以用完全背包解决。

然后我们记状态 $f[d][k]$ 为在第 $d$ 天时,拥有 $k$ 的资源时的最大效率，然后我们就可以对于每一个状态 $(d,k)$ 去枚举花费 $j$ 然后维护第 $d+1$ 天的 $f$ 数组。状态转移方程为：

$f[d+1][k-j+w[j]+f[d][k]]=\max(f[d+1][k-j+w[j]+f[d][k]],f[d][k]+w[j])$

然后判断结束的标志就是要么 $f[d][t]$ 合法，要么是在转移时 $f[d+1][k-j+w[j]+f[d][k]]$ 合法且 $k-j+w[j]+f[d][k]\ge t$ 

时间复杂度 $O(ans*t^2)$ 而且跑不满。

# Code:

```cpp
#include<bits/stdc++.h>
const int N=105;
const int M=1005;
int w[M],f[N][M];
using namespace std;
int n,m,t;
inline void init()
{
    for(int i=0;i<N;i++)for(int j=0;j<M;j++)f[i][j]=-1;
}
inline void Max(int &x,int y)
{
    x = x>y ? x : y;
}
inline int Min(int x,int y)
{
    return x<y ? x : y;
}
void work()
{
    cin>>n>>m>>t;
    if(m>=t){cout<<0;return ;}
    for(int i=1,x,y;i<=n;i++)
    {
        scanf("%d%d",&x,&y);
        x=Min(x,1000);
        y=Min(y,1000);
        for(int j=x;j<=t;j++)
        {
            Max(w[j],w[j-x]+y);
        }
    }
    int d=0;
    init();
    f[0][m]=0;
    while(d<=1000)
    {
        if(~f[d][t]){cout<<d;return;}
        for(int k=0;k<=t;k++)if(~f[d][k])
        for(int j=0;j<=k;j++)
        {
            if(k-j+w[j]+f[d][k]>=t){cout<<d+1;return;}
            Max(f[d+1][k-j+w[j]+f[d][k]],f[d][k]+w[j]);
        }
        d++;
    }
}
int main()
{
    //freopen("P3891.in","r",stdin);
    //freopen("P3891.out","w",stdout);
    work();
    return 0;
}
```

---

## 作者：AzureHair (赞：0)

看到题目首先想到背包，但是如何背包成了问题。

我们可以先用完全背包 $dp_{i,j}$ 预处理出花 $j$ 资源可以达到最大的生产速度是多少。

随后问题就来到了如何求最短时间，我们可以设 $f_{i,j}$ 表示 $i$ 时间剩余 $j$ 资源可以达到的最大生产速度。

于是状态转移方程就很好写了。

```cpp
f[i+1][j-k+dp[n][k]+f[i][j]]=max(f[i+1][j-k+dp[n][k]+f[i][j]],dp[n][k]+f[i][j]);
```

于是这道题就迎刃而解了。

还有就是有一些细节需要注意。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,t,w[110],v[110],dp[110][1010],f[1010][1010];//dp为完全背包,f为i时间j剩余的最大生产速度 
signed main()
{
	cin>>n>>m>>t;
	if(m>=t) 
	{
		cout<<0<<endl;
		return 0;
	}
	for(int i=1;i<=n;i++)
	{
		cin>>w[i]>>v[i];
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=t;j++)
		{
			dp[i][j]=-1;
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=t;j++)//完全背包 
		{
			if(j-w[i]>=0)
			{
				dp[i][j]=max(dp[i-1][j],dp[i][j-w[i]]+v[i]);
			}
			else
			{
				dp[i][j]=dp[i-1][j];
			}
		}
	}
	memset(f,-1,sizeof(f));
	f[0][m]=0;
	for(int i=0;i<=1000;i++)//最多就1000时间 
	{
		if(f[i][t]!=-1)
		{
			cout<<i<<endl;
			return 0;
		}
		for(int j=0;j<=t;j++)
		{
			if(f[i][j]==-1) 
			{
				continue;
			}
			for(int k=0;k<=j;k++)
			{
				if(dp[n][k]==-1)
				{
					continue;
				}
				if(j-k+dp[n][k]+f[i][j]>=t)
				{
					cout<<i+1<<endl;//愉快AC 
					return 0;
				}
				f[i+1][j-k+dp[n][k]+f[i][j]]=max(f[i+1][j-k+dp[n][k]+f[i][j]],dp[n][k]+f[i][j]);//向i+1转移 
			}
		}
	}
	return 0;
} 
```


---


# [TJOI2013] 单词

## 题目描述

小张最近在忙毕设，所以一直在读论文。一篇论文是由许多单词组成的，但小张发现一个单词会在论文中出现很多次，他想知道每个单词分别在论文中出现了多少次。

## 说明/提示

### 数据规模与约定

- $30\%$ 的数据，单词总长度不超过 $10^3$。
- $100\%$ 的数据，$1 \leq n \leq 200$，单词总长度不超过 $10^6$。

## 样例 #1

### 输入

```
3
a
aa
aaa```

### 输出

```
6
3
1
```

# 题解

## 作者：D_14134 (赞：76)

首先，我们都知道fail树就是在跑ac机中把失配指针所指向的值与失配指针所表示的边重新建出来的树。有这个思想，那么这道题就很简单了。

跑一遍AC自动机，每一个节点保存一下属于多少字符串，为它的权值。然后一个节点表示的字符串在整个字典中出现的次数相当于其在Fail树中的子树的权值的和。

# code

```
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define N 1100005
using namespace std;
int n,a[N],h[N],cnt,last,ch[N][26],sz[N],fail[N];
char s[N];
struct ac{
	void ins(int x){
		scanf("%s",s+1);int now=0,len=strlen(s+1);
		for(int i=1;i<=len;i++){
			int u=s[i]-'a';
			if(!ch[now][u]) ch[now][u]=++cnt;
			now=ch[now][u];
			sz[now]++;
		}
		a[x]=now;
	}
	void build(){
		int i,head=0,tail=0;
		for(i=0;i<26;i++) if(ch[0][i]) h[++tail]=ch[0][i];
		while(head<tail){
			int x=h[++head],y;
				for(i=0;i<26;i++) if(y=ch[x][i]){
				h[++tail]=y;
				fail[y]=ch[fail[x]][i];
			}
			else ch[x][i]=ch[fail[x]][i];
		}
	}
	void solve(){
		for(int i=cnt;i>=0;i--) sz[fail[h[i]]]+=sz[h[i]];
		for(int i=1;i<=n;i++) printf("%d\n",sz[a[i]]);
	}
}ac;
int main(){
	//freopen("word.in","r",stdin);
	//freopen("word.out","w",stdout);
	scanf("%d",&n);
	for(int i=1;i<=n;i++) ac.ins(i);
	ac.build();ac.solve();
	return 0;
}
```


---

## 作者：月がきれい (赞：37)

看着这道题第一感觉，好像find可以过

默默花20分钟写出来，AC

find大法好

find用法见[find](https://www.cnblogs.com/zpcdbky/p/4471454.html)

话不多说，贴代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
string st[205];
int read()
{
    int X=0,w=0; char ch=0;
    while(!isdigit(ch)) {w|=ch=='-';ch=getchar();}
    while(isdigit(ch)) X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
    return w?-X:X;
}
void write(int x)
{
     if(x<0) putchar('-'),x=-x;
     if(x>9) write(x/10);
     putchar(x%10+'0');
}
int main(){
	n=read();
	for(int i=1;i<=n;i++)
		cin>>st[i];
	for(int i=1;i<=n;i++)
	{
		int ans=0;
		for(int j=1;j<=n;j++)
		{
			int k=0,l=st[j].find(st[i],k);
			while(l!=-1)
			{
				k=l+1;
				l=st[j].find(st[i],k); 
				ans++;
			}
		}
		write(ans);
		putchar('\n');
	}
	return 0;
}

```

突然发现我常数写得真的很小

[AC记录](https://www.luogu.org/record/show?rid=14774441)

---

## 作者：poorpool (赞：20)

蒟蒻也能写出来的[AC代码](http://www.cnblogs.com/poorpool/p/7997731.html)！这题是AC自动机模板题。插入单词时用一个没出现过的字符隔开就行了。


一些细节请看注释


300ms，效率一般吧


```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <queue>
using namespace std;
char a[1000005], b[1000205];//b数组要开这么大，因为要在所有单词拼起来之外再加n个#号
int n, len, mp[205], all, cnt[205];
queue<int> d;
struct ACzdj{
    int siz, s[1000005][26], val[1000005], lst[1000005], fai[1000005];
    int u, v;
    void ins(int k){
        u = 0;
        len = strlen(a);
        for(int i=0; i<len; i++)
            b[all+i] = a[i];
        all += len;
        b[all++] = '#';
        for(int i=0; i<len; i++){
            v = a[i] - 'a';
            if(!s[u][v])    s[u][v] = ++siz;
            u = s[u][v];
        }
        if(!val[u])    val[u] = k;
        mp[k] = val[u];//mp[k]记录的是与第k号单词相同的单词的最小编号，这样可以解决重复单词。
    }
    void getFail(){
        for(int i=0; i<26; i++)
            if(s[0][i])
                d.push(s[0][i]);
        while(!d.empty()){
            u = d.front();
            d.pop();
            for(int i=0; i<26; i++){
                v = s[u][i];
                if(v){
                    fai[v] = s[fai[u]][i];
                    lst[v] = val[fai[v]]?fai[v]:lst[fai[v]];
                    d.push(v);
                }
                else    s[u][i] = s[fai[u]][i];
            }
        }
    }
    void query(){
        u = 0;
        for(int i=0; i<all; i++){
            if(b[i]=='#'){
                u = 0;//记得置零
                continue;
            }
            u = s[u][b[i]-'a'];
            if(val[u])    cnt[val[u]]++;
            v = lst[u];
            while(v){
                cnt[val[v]]++;
                v = lst[v];
            }
        }
        for(int i=1; i<=n; i++)
            printf("%d\n", cnt[mp[i]]);
    }
}ac;
int main(){
    cin>>n;
    for(int i=1; i<=n; i++)
        scanf("%s", a), ac.ins(i);
    ac.getFail();
    ac.query();
    return 0;
}
```

---

## 作者：HMP_Haoge (赞：20)

## KMP

看见这么多dalao用AC自动机，昨天才开始了解AC自动机的蒟蒻表示很淦，于是他掏出了~~暴力得发指~~KMP来氵一篇题解。

用KMP没有任何思路和码力的困难，时间900ms，不愧是暴力

具体的注意事项在码里面注明，于是......

上码！

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ri register int

int n,len[210],ans1,nxt[1000010];
char s[210][1000010];

inline int gi(char *s)//字符串快读，还能返回字符串长度，香！ 
{
	int x=0;
	while((s[++x]=getchar())!='\n'&&s[x]!=' '&&s[x]!='\377');
	return x-1;
}
template< typename T > inline void read(T &x)
{
	int f=1;
	char c=getchar();
	x=0;
	for(; !isdigit(c); c=getchar()) if(c=='-') f=-1;
	for(; isdigit(c); c=getchar()) x=((x<<3)+(x<<1)+(c^48));
	x*=f;
}
template< typename T > inline void write(T x)
{
	if(x<0) putchar('-'),x=-x;
	if(x>9) write(x/10);
	putchar(x%10+'0');
}
inline void kmp(char *a,int l)//KMP板子 
{
	nxt[1]=0;
	for(ri i=2,j=0; i<=l; ++i)
	{
		while(j>0&&a[i]!=a[j+1]) j=nxt[j];
		if(a[i]==a[j+1]) ++j;
		nxt[i]=j;
	}
}
inline void findd(char *a,char *target,int l)
{
	for(ri i=1,j=0; target[i]; ++i)
	{
		while(j&&target[i]!=a[j+1]) j=nxt[j];
		if(target[i]==a[j+1]) ++j;
		if(j==l) ++ans1;
	}
}

int main()
{
	read(n);
	for(ri i=1; i<=n; ++i)
		len[i]=gi(s[i]);
	for(ri i=1; i<=n; ++i)
	{
		ans1=0;
		for(ri j=1; j<=n; ++j)
		{
			if(i==j) ++ans1;	       //小优化：当i=j时直接ans1++ 
			else if(len[i]<=len[j])    //小优化，当长度更小时必定没有匹配串，直接溜
			{
				kmp(s[i],len[i]);
				findd(s[i],s[j],len[i]);
			}
		}
		write(ans1);
		putchar('\n');
	}
}
```


---

## 作者：DQYdqy (赞：14)

乍一看，这是一道AC自动机的板子题，只要把AC自动机建好，再来匹配就好了

然后，你就WA了。。。

为什么呢？

我们发现，它的输入单词里是会有相同的单词的，所以当成板子题来做的话，就会由于建tire树的覆盖而导致答案出错，那么怎么来解决这个问题呢？

我们定义一个same数组，end数组只记录最早的编号，每次如果要覆盖，便把令该节点的same值为这个位置上的end的值，查询时每个都查询一遍，输出答案就输出ans[same[i]]

你兴冲冲的码完之后，提交，本以为能够AC，结果，在你A了9个点之后，TLE。。。

怎么办呢？

既然有重复的，那么我们显然不需要把每个都扫一遍，而是只扫一次，再通过现有的答案来得出正确答案，我们只需要解决如何扫描一次后的答案来得出正确答案就可以了

定义两个数组，apr和vis，apr记录在AC自动机上每一个节点被覆盖的次数，vis记录当前节点在统计答案时有没有被扫过。

在统计答案时，若当前节点是某个单词的末尾且没有被扫过，说明它能够为该单词有贡献，就将该单词的答案加上apr[now]。每次扫到AC自动机上的一个节点，就把它的vis标记变成1，这样子就能得出正确答案了，详见代码。

#### **Code:**
```
#include<bits/stdc++.h>
#define N 100001
using namespace std;
int n,cnt,Len,ans[201];
char ch[201][N];
namespace AC_Automaton{
    queue<int> q;
    int same[N],apr[N*27],vis[N*27];
    int trie[N*27][26],ed[N*27],fail[N*27];
    void ins(int x){
        int now=0,len=strlen(ch[x]+1);
        for(int i=1;i<=len;i++){
            int num=ch[x][i]-'a';
            if(!trie[now][num]) trie[now][num]=++cnt;
            now=trie[now][num];apr[now]++;
        }
        if(ed[now]) same[x]=ed[now];
        else ed[now]=x;
    }
    void makefail(){
        for(int i=0;i<26;i++)
            if(trie[0][i]) q.push(trie[0][i]);
        while(!q.empty()){
            int x=q.front();q.pop();
            for(int i=0;i<26;i++)
                if(trie[x][i]) fail[trie[x][i]]=trie[fail[x]][i],q.push(trie[x][i]);
                else trie[x][i]=trie[fail[x]][i];
        }
    }
    void query(char *s){
        int now=0,len=strlen(s+1);
        for(int i=1;i<=len;i++){
            int num=s[i]-'a';
            now=trie[now][num];
            for(int j=now;j;j=fail[j])
                if(ed[j]&&!vis[now]) ans[ed[j]]+=apr[now];
            vis[now]=1;
        }
    }
}
int main(){
    scanf("%d",&n);  
    using namespace AC_Automaton; 
    for(int i=1;i<=n;i++){
        scanf("%s",ch[i]+1);
        ins(i);
    }
    makefail();
    for(int i=1;i<=n;i++)
        if(!same[i]) query(ch[i]);
    for(int i=1;i<=n;i++)
       if(!same[i]) printf("%d\n",ans[i]);
       else printf("%d\n",ans[same[i]]);
    return 0;
}
```

---

## 作者：Zzxpy (赞：12)

最近我们在学ac自动机

~~于是我用kmp水过了这道题~~

机房里面各位大佬都用的ac自动机...但是如果没完全理清自动机的思路的话，就会~~听取wa声一片~~

**因为普通的ac自动机是不可以做相同字符串的！！！！**

所以在效率满足的情况下为什么不同kmp呢。

代码如下

```cpp
#define ITC_TL
#include<bits/stdc++.h>
using namespace std;
#define ll long long int
ll n;
char mob[210][1123456];
int p[4123456];
void pre(char *s,int v){
	int h=strlen(s+1);
	for(int i=1,j=0;i<h;i++){
		while(j>0&&s[i+1]!=s[j+1]) j=p[j];
		if(s[i+1]==s[j+1]) ++j;
		p[i+1]=j;
	}
}
ll kmp(char* b,char* a,int v){
	ll ans=0,j=0,n1=strlen(a+1),m1=strlen(b+1);
	for(int i=0;i<n1;i++){
		while(j>0&&b[j+1]!=a[i+1]) j=p[j];
		if(b[j+1]==a[i+1]) j++;
		if(j==m1) ans++,j=p[j];
	}
	return ans;
}
int main(){
//	freopen("word.in","r",stdin);
//	freopen("word.out","w",stdout);
	cin>>n;
	for(int i=1;i<=n;i++) {		
		scanf("%s",mob[i]+1);
	}
	ll sum1=1;
	for(int i=1;i<=n;i++){
		sum1=0;
		pre(mob[i],i);
		for(int j=1;j<=n;j++){
	//		if(i!=j){
				sum1+=kmp(mob[i],mob[j],i);	
//			}
		}
		cout<<sum1<<endl;
	}
}
```


---

## 作者：warzone (赞：11)

## 题目大意

给出n个单词和n个与之相同的模式串进行匹配,

求出各个单词匹配的出现次数

____________________________________________

以下给出两种方法:

### 法一:AC自动机

既然是多模匹配,那么自然是用AC自动机

我们可以在存各个单词的同时把它们存入字典树

然后就是喜闻乐见的AC自动机匹配了~

注意可能有重复,我们应用一个vector[]指向字典树上的节点

于是得到如下代码

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
int n;
char s[1000010];
class QUEUE{//求fail用的队列 
    private:
    	int *list;
		int head,tail,size;
	public:
		QUEUE(const int &length){
			size=length;
			list=new int[size+1];
			head=tail=0;
		}
		~QUEUE(){delete[] list;}
		inline void push(const int&in){
			list[tail]=in;
			if(tail==size) tail=0;
			else tail++;
		}
		inline void pop(){
			if(head==size) head=0;
			else head++;
		}
		inline int top(){return list[head];}
		inline bool empty(){return head==tail;}
}; 
class Trie{
	private:
		struct point{
			unsigned int next[26],fail;
			unsigned int floor,count;
		}*all;
		unsigned int *vector,size,p_size;
		unsigned int *tail;
	public:
		Trie(const int&SIZE,const int&P_SIZE){//字典树初始化  
			size=p_size=0;
			all=new point[SIZE+1];
			vector=new unsigned int[P_SIZE+1];
			tail=new unsigned int[SIZE+1];
			tail[0]=0;
			memset(all,0,sizeof(point)*(SIZE+1));
		}
		~Trie(){
			delete[] all;
			delete[] vector;
			delete[] tail;
		}
		inline void read(){//输入模式串并存入字典树 
			register int p=0;
			register int i=tail[p_size]+1; 
			s[i]=getchar();//同时记录待匹配串 
			while('a'>s[i]||s[i]>'z') s[i]=getchar();
			for(;'a'<=s[i]&&s[i]<='z';s[i]=getchar()){
				s[i]-='a';
				if(all[p].next[s[i]]==0){
					size++;
					all[p].next[s[i]]=size;
					all[size].floor=all[p].floor+1;
				}
				p=all[p].next[s[i]];
				i++;
			}
			p_size++;
			vector[p_size]=p;//记录各个单词指向的节点
			tail[p_size]=tail[p_size-1]+all[p].floor;
			//记录待匹配串末尾 
		}
		inline void getfail(){//求fail指针 
			QUEUE q(p_size);
			for(register int i=0;i<26;i++){
				if(all[0].next[i]!=0){
					all[all[0].next[i]].fail=0;
					q.push(all[0].next[i]);
				}
			}
			register int p;
			while(!q.empty()){
				p=q.top();
				q.pop();
				for(register int i=0,nextfail;i<26;i++){
					nextfail=all[all[p].fail].next[i];
					if(all[p].next[i]==0){
                        all[p].next[i]=nextfail;
                        continue;
                    }
					all[all[p].next[i]].fail=nextfail;
					q.push(all[p].next[i]);
				}
			}
		}
		inline void AC_auto(){
			for(register int i=1;i<=p_size;i++){//匹配 
                register int p=0;
				for(register int j=tail[i-1]+1;j<=tail[i];j++){
					p=all[p].next[s[j]];
					for(register int k=p;k!=0;){
                        all[k].count++;
                        k=all[k].fail;
                    }
				}
			}
			for(register int i=1;i<=p_size;i++){//输出 
				printf("%d\n",all[vector[i]].count);
			}
		}
};
int main(){
	scanf("%d",&n);
	Trie tree(1e6,n);
	for(register int i=0;i<n;i++) tree.read();
	tree.getfail();
	tree.AC_auto();
	return 0;
}
```

差不多了,交吧!

?!(90分,TLE) [提交记录](https://www.luogu.org/record/21974180)

### 法二:AC自动机+fail指针统一处理

我们理应需要一些优化

[P5357 【模板】AC自动机（二次加强版）](https://www.luogu.org/problem/P5357)

在这道题中,我们使用了一种优化方法:

**先只记录AC自动机扫描到的位置,**

**然后在fail指针树上递归统计匹配次数**

这里我们可以使用相同方法,而且

**由于模式串与待匹配的串相同,**

**我们可以在存入字典树的同时记录扫描位置,而不用额外进行匹配**

(这样也省去了额外存储待匹配串的麻烦)

**法二AC代码(不开O2,731ms,118.15MB)**

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
int n;
class QUEUE{//求fail用的队列 
    private:
		int *list;
		int head,tail,size;
	public:
		QUEUE(const int &length){
			size=length;
			list=new int[size+1];
			head=tail=0;
		}
		~QUEUE(){delete[] list;}
		inline void push(const int&in){
			list[tail]=in;
			if(tail==size) tail=0;
			else tail++;
		}
		inline void pop(){
			if(head==size) head=0;
			else head++;
		}
		inline int top(){return list[head];}
		inline bool empty(){return head==tail;}
}; 
class Trie{
	private:
		struct point{
			unsigned int next[26],fail;
			unsigned int floor,count;
		}*all;
		unsigned int *vector,size,p_size;
		unsigned int *head,*tail,*next;
		inline void dfs_count(int id){//递归统计匹配次数 
			for(register int i=head[id];i!=0;i=next[i]){
				dfs_count(i);
				all[id].count+=all[i].count;
			}
		}
	public:
		Trie(const int&SIZE,const int&P_SIZE){//字典树初始化  
			size=p_size=0;
			all=new point[SIZE+1];
			vector=new unsigned int[P_SIZE+1];
			head=new unsigned int[SIZE+1];
			tail=new unsigned int[SIZE+1];
			next=new unsigned int[SIZE+1];
			memset(all,0,sizeof(point)*(SIZE+1));
			memset(head,0,(SIZE+1)<<2);
		}
		~Trie(){
			delete[] all;
			delete[] vector;
			delete[] head;
			delete[] tail;
			delete[] next;
		}
		inline void read(){//输入模式串并存入字典树 
			register int p=0;
			register char c=getchar();
			while('a'>c||c>'z') c=getchar();
			for(;'a'<=c&&c<='z';c=getchar()){
				c-='a';
				if(all[p].next[c]==0){
					size++;
					all[p].next[c]=size;
					all[size].floor=all[p].floor+1;
				}
				p=all[p].next[c];
				all[p].count++;//同时记录扫描位置  
			}
			p_size++;
			vector[p_size]=p;//记录各个单词指向的节点  
		}
		inline void getfail(){//求fail指针 
			QUEUE q(p_size);
			for(register int i=0;i<26;i++){
				if(all[0].next[i]!=0){
					all[all[0].next[i]].fail=0;
					
					if(head[0]==0) head[0]=all[0].next[i];
					else next[tail[0]]=all[0].next[i];
					tail[0]=all[0].next[i];
					next[all[0].next[i]]=0;
					//同时用邻接表记录fail树的儿子节点 
					q.push(all[0].next[i]);
				}
			}
			register int p;
			while(!q.empty()){
				p=q.top();
				q.pop();
				for(register int i=0,nextfail;i<26;i++){
					nextfail=all[all[p].fail].next[i];
					if(all[p].next[i]==0){
                        all[p].next[i]=nextfail;
                        continue;
                    }
					all[all[p].next[i]].fail=nextfail;
						
					if(head[nextfail]==0)
						head[nextfail]=all[p].next[i];
					else next[tail[nextfail]]=all[p].next[i];
					tail[nextfail]=all[p].next[i];
					next[all[p].next[i]]=0;
					//同上 
					q.push(all[p].next[i]);
				}
			}
		}
		inline void AC_auto(){
			dfs_count(0);
			for(register int i=1;i<=p_size;i++){//输出 
				printf("%d\n",all[vector[i]].count);
			}
		}
};
int main(){
	scanf("%d",&n);
	Trie tree(1e6,n);
	for(register int i=0;i<n;i++) tree.read();
	tree.getfail();
	tree.AC_auto();
	return 0;
}
```

---

## 作者：戦艦はるな (赞：7)

**基本的Hash**

主要思路是Hash+前缀和(参考CQOI2014 通配符匹配)。当然，空间开的非常友好

把所有的单词粘在一起，中间用特殊符号（例如#）隔开，然后$O(n*len)$Hash判一遍是否出现即可。

友情提示：最后一个点请注意边界问题TaT

恶心的Code：

```cpp
#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <cstring>
#define f(x,y,z) for(int x=y;x<=z;x++)
#define F(x,y,z,v) for(int x=y;x<=z;x+=v)
using namespace std;
const int MAXN=1000005;
char a[205][MAXN],b[MAXN<<1];
unsigned long long hash1[205],hash2[MAXN<<1],divi[MAXN<<1];
int stl[205];
const int BASE=131;
unsigned long long getsum(int l,int r)
{
	return hash2[r]-hash2[l-1]*divi[r-l+1];
}
int main()
{
	int n;
	scanf("%d",&n);
	int cnt=-1,len;
	f(i,1,n)
	{
		b[++cnt]='#';
		scanf("%s",&a[i]);
		len=strlen(a[i]);
		stl[i]=len;
		f(j,0,len-1)
		{
			b[++cnt]=a[i][j];
			hash1[i]*=BASE;
			hash1[i]+=a[i][j];
		}
	}
	len=strlen(b);
	hash2[0]=b[0];
	divi[0]=1;
	f(i,1,len-1)
	{
		hash2[i]=hash2[i-1]*BASE+b[i];
		divi[i]=divi[i-1]*BASE;
	}
	f(i,1,n)
	{
		int tcnt=0;
		f(j,1,len-stl[i])
			if(hash1[i]==getsum(j,j+stl[i]-1))
				tcnt++;
		printf("%d\n",tcnt);
	}
	return 0;
}
//防叉用的自然溢出
```

---

## 作者：attack (赞：7)

自己xjb YY了一个做法居然1Ahhh

首先应该一眼就能看出是AC自动机可以搞。

那么我们先把所有串的AC自动机搞出来，然后记录下他们拼起来的串，用随便一个字符分隔

暴力枚举每一个串，把经过的路径上的权值$+1$，表示该位置代表的串又多出现了一次。

这样我们就统计出了与它一模一样的串的出现次数。

还有一种情况，即当它作为某些串的后缀出现。

此时，根据AC自动机的性质不难发现，我们要求的答案即为该节点在$fail$树上子树的和

然后直接暴力把$fail$树建出来，树形DP统计答案即可

~~就是跑的有点慢~~

```cpp
// luogu-judger-enable-o2
// luogu-judger-enable-o2
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
const int MAXN = 1e6 + 100, B = 28;
int T;
char s[MAXN], a[MAXN];
int fail[MAXN], ch[MAXN][28], val[MAXN], tot = 0, root = 0;
void insert(char *s) {
    int N = strlen(s + 1);
    int now = root;
    for(int i = 1; i <= N; i++) {
        int x = s[i] - 'a';
        if(!ch[now][x]) ch[now][x] = ++tot;
        now = ch[now][x];
        val[now]++;
    }
}   
vector<int> v[MAXN];
void GetFail() {
    queue<int> q; 
    for(int i = 0; i < B; i++) if(ch[root][i]) q.push(ch[root][i]);
    while(!q.empty()) {
        int p = q.front(); q.pop();
        for(int i = 0; i < B; i++) {
            if(ch[p][i]) fail[ch[p][i]] = ch[fail[p]][i], q.push(ch[p][i]);
            else ch[p][i] = ch[fail[p]][i];
        }
        v[fail[p]].push_back(p);
    }
}
void GetVal(int x) {
    for(int i = 0; i < v[x].size(); i++)
        GetVal(v[x][i]), val[x] += val[v[x][i]];
}
void GetAns(char *s) {
    int N = strlen(s + 1), now = root, ans = 0;
    for(int i = 1; i <= N; i++) {
        int x = s[i] - 'a';
        if(x == 26) printf("%d\n", val[now]), now = root, ans = 0;
        now = ch[now][x];
    }
    printf("%d", val[now]);
}
int main() {
    //freopen("a.in", "r", stdin); 
    scanf("%d", &T);
    for(int i = 1; i <= T; i++) {
        scanf("%s", s + 1);
        insert(s);
        s[0] = 'z' + 1;
        strcat(a, s);
    }
    GetFail();
    GetVal(0);
    GetAns(a); 
    return 0;
}
```

---

## 作者：elijahqi (赞：5)

复习一下昨天的二分查找，但是复杂度感觉是玄学，还不如暴力跑得快

就是找到最长的满足区间内height都大于等于Len 求这个最大长度，分别在左右二分就可以了

把所有单词连在一起，SA求出h数组，对于每一个单词看做一个询问，暴力往前往后扫，看有几个暴力统计即可

(http://www.elijahqi.win/2017/08/26/bzoj3473/)

nlogn 2628 ms

```cpp
#include<cstdio>
#include<cstring>
#define N 1100000
#define N1 220
int n,n1,a[N],m,k,rank[N<<1],rank1[N],sa[N],count[N],tmp[N],height[N],Log[N],fmin[N][20];
char str1[N];
struct node{
    int st,len;
}data[N1];
inline int min(int x,int y){return x<y?x:y;}
inline int lcp(int x,int y){
    x++;int t=Log[y-x+1];
    return min(fmin[x][t],fmin[y-(1<<t)+1][t]);
}
void check(int st,int len){
    int l1,r1;
    if (height[st]<len) l1=st;else{
        int l=1,r=st-1;
        while (l<=r){
            int mid=(l+r)>>1;
            if(lcp(mid,st)>=len) r=mid-1;else l=mid+1;
        }
        l1=l;
    }
    if (height[st+1]<len) r1=st;else{
        int l=st+1,r=n;
        while (l<=r){
            int mid=(l+r)>>1;
            if (lcp(st,mid)>=len) l=mid+1;else r=mid-1;
        }
        r1=r;
    }
    printf("%d\n",r1-l1+1);
}
int main(){
    freopen("bzoj3172.in","r",stdin);
    scanf("%d",&n1);n=1;m=30;
    for (int i=1;i<=n1;++i) {
        scanf("%s",str1);int nn=strlen(str1);data[i].len=nn;data[i].st=n;
        for (int j=0;j<nn;++j) a[n+j]=str1[j]-'a'+1;n+=nn;a[n++]=m++;
    }n-=1;
    //for (int i=1;i<=n;++i) printf("%d ",a[i]);
    //for (int i=1;i<=n1;++i) printf("%d %d\n",data[i].st,data[i].len);
    for (int i=1;i<=n;++i) count[a[i]]=1;
    for (int i=1;i<=255;++i) count[i]+=count[i-1];
    for (int i=1;i<=n;++i) rank[i]=count[a[i]];
    k=0;
    for (int p=1;k!=n;p<<=1,m=k){
        for (int i=1;i<=m;++i) count[i]=0;
        for (int i=1;i<=n;++i) count[rank[i+p]]++;
        for (int i=1;i<=m;++i) count[i]+=count[i-1];
        for (int i=n;i>=1;--i) tmp[count[rank[i+p]]--]=i;
        for (int i=1;i<=m;++i) count[i]=0;
        for (int i=1;i<=n;++i) count[rank[i]]++;
        for (int i=1;i<=m;++i) count[i]+=count[i-1];
        for (int i=n;i>=1;--i) sa[count[rank[tmp[i]]]--]=tmp[i];
        memcpy(rank1,rank,sizeof(rank)>>1);
        rank[sa[1]]=k=1;
        for (int i=2;i<=n;++i){
            if (rank1[sa[i]]!=rank1[sa[i-1]]||rank1[sa[i-1]+p]!=rank1[sa[i]+p]) ++k;
            rank[sa[i]]=k;
        }
    }
//    for (int i=1;i<=n;++i) printf("%d ",rank[i]);
    k=0;
    for (int i=1;i<=n;++i){
        if (rank[i]==1) continue;
        k=k==0?0:k-1;
        while (a[i+k]==a[sa[rank[i]-1]+k]) ++k;
        height[rank[i]]=k;
    }    
    //for (int i=1;i<=n;++i) printf("%d ",height[i]);
    Log[0]=-1;
    for (int i=1;i<=n;++i) Log[i]=Log[i>>1]+1;
    for (int i=1;i<=n;++i) fmin[i][0]=height[i];
    for (int j=1;j<=Log[n];++j){
        for (int i=1;i<=n-(1<<j)+1;++i){
            fmin[i][j]=min(fmin[i][j-1],fmin[i+(1<<(j-1))][j-1]);
        }
    }
    for (int i=1;i<=n1;++i)
        check(rank[data[i].st],data[i].len);
    return 0;
}
```
暴力
1384 ms

```cpp
#include<cstdio>
#include<cstring>
#define N 1100000
#define N1 220
int n,n1,a[N],m,k,rank[N<<1],rank1[N],sa[N],count[N],tmp[N],height[N];
char str1[N];
struct node{
    int st,len;
}data[N1];
int main(){
    freopen("bzoj3172.in","r",stdin);
    scanf("%d",&n1);n=1;m=30;
    for (int i=1;i<=n1;++i) {
        scanf("%s",str1);int nn=strlen(str1);data[i].len=nn;data[i].st=n;
        for (int j=0;j<nn;++j) a[n+j]=str1[j]-'a'+1;n+=nn;a[n++]=m++;
    }n-=1;
    //for (int i=1;i<=n;++i) printf("%d ",a[i]);
    //for (int i=1;i<=n1;++i) printf("%d %d\n",data[i].st,data[i].len);
    for (int i=1;i<=n;++i) count[a[i]]=1;
    for (int i=1;i<=255;++i) count[i]+=count[i-1];
    for (int i=1;i<=n;++i) rank[i]=count[a[i]];
    k=0;
    for (int p=1;k!=n;p<<=1,m=k){
        for (int i=1;i<=m;++i) count[i]=0;
        for (int i=1;i<=n;++i) count[rank[i+p]]++;
        for (int i=1;i<=m;++i) count[i]+=count[i-1];
        for (int i=n;i>=1;--i) tmp[count[rank[i+p]]--]=i;
        for (int i=1;i<=m;++i) count[i]=0;
        for (int i=1;i<=n;++i) count[rank[i]]++;
        for (int i=1;i<=m;++i) count[i]+=count[i-1];
        for (int i=n;i>=1;--i) sa[count[rank[tmp[i]]]--]=tmp[i];
        memcpy(rank1,rank,sizeof(rank)>>1);
        rank[sa[1]]=k=1;
        for (int i=2;i<=n;++i){
            if (rank1[sa[i]]!=rank1[sa[i-1]]||rank1[sa[i-1]+p]!=rank1[sa[i]+p]) ++k;
            rank[sa[i]]=k;
        }
    }
//    for (int i=1;i<=n;++i) printf("%d ",rank[i]);
    k=0;
    for (int i=1;i<=n;++i){
        if (rank[i]==1) continue;
        k=k==0?0:k-1;
        while (a[i+k]==a[sa[rank[i]-1]+k]) ++k;
        height[rank[i]]=k;
    }    
    //for (int i=1;i<=n;++i) printf("%d ",height[i]);

    for(int i=1;i<=n1;++i){
        int x=rank[data[i].st];
        int l=x,r=x+1;
        while(height[l]>=data[i].len) --l;
        while(height[r]>=data[i].len) ++r;--r;
        printf("%d\n",r-l+1);
    }
    return 0;
}
```

---

## 作者：nianheng (赞：4)

这道题应该是后缀数组的套路题啊，把单词连接起来，中间用没有出现过且互不相同的字符来分隔开，求一下$height$数组。

对于一个单词来说，设单词长$len$，所在的后缀为$i$，如果某后缀$j$满足$lcp(i,j)==len$，则$j$的前缀与这个单词相等。因为和$i$的$lcp$大小是从$i$向两边递减的，所以可以分别从后往前，从前往后两遍单调栈找出左右最远能满足条件的后缀$l,r$，区间大小$l-r+1$就是总数

吐槽一下这题我开始交了两遍R炸了，原因竟是加分隔符的时候加入了一些奇怪的字符...，把$s$改成$int$就好了...

[安利一下blog](https://www.cnblogs.com/nianheng/)

```cpp
#include<map>
#include<cmath>
#include<queue>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=2e6+100;
struct SA{
    int sa[maxn],tp[maxn],tax[maxn],rk[maxn],h[maxn],n,m,len[300],bj[maxn];
    int siz[300],st[maxn],top,tot,s[maxn];
    void Qsort(){
        for(int i=0;i<=m;i++) tax[i]=0;
        for(int i=1;i<=n;i++) tax[rk[i]]++;
        for(int i=1;i<=m;i++) tax[i]+=tax[i-1];
        for(int i=n;i>=1;i--)
            sa[tax[rk[tp[i]]]--]=tp[i];
    }
    void getsa(){
        m=1000;
        for(int i=1;i<=n;i++)
            rk[i]=s[i],tp[i]=i;
        Qsort();
        for(int p=1,w=1;p<n;w<<=1,m=p){
            p=0;
            for(int i=1;i<=w;i++) tp[++p]=n+i-w;
            for(int i=1;i<=n;i++) if(sa[i]>w) tp[++p]=sa[i]-w;
            Qsort();
            swap(tp,rk);
            rk[sa[1]]=p=1;
            for(int i=2;i<=n;i++)
                rk[sa[i]]=tp[sa[i]]==tp[sa[i-1]]&&tp[sa[i]+w]==tp[sa[i-1]+w]?p:++p;
        }
    }
    void geth(){
        for(int i=1,j,p=0;i<=n;h[rk[i++]]=p)
        for(p?p--:p,j=sa[rk[i]-1];s[j+p]==s[i+p];p++);
    }
    void ycl(){
        h[0]=-0x7fffffff,top=0;
        for(int i=1;i<=n;i++){
            while(h[st[top]]>=h[i]) top--;
            if(bj[sa[i]]&&h[i]==len[bj[sa[i]]])
                siz[bj[sa[i]]]=i-st[top];
            st[++top]=i;
        }
        h[n+1]=-0x7fffffff,st[0]=n+1,top=0;
        for(int i=n-1;i>=1;i--){
            while(h[st[top]]>=h[i+1]) top--;
            if(bj[sa[i]]&&h[i+1]==len[bj[sa[i]]]) siz[bj[sa[i]]]+=st[top]-i-1;
            st[++top]=i+1;
        }
    }
}sa;
int n,m;
char a[maxn];
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%s",a+1);
        m=strlen(a+1);
        sa.bj[sa.n+1]=i;
        sa.len[i]=m;
        for(int j=1;j<=m;j++)
            sa.s[++sa.n]=a[j]; 
        sa.s[++sa.n]='z'+i;
    }
    sa.getsa(),sa.geth(),sa.ycl();
    for(int i=1;i<=n;i++)
        printf("%d\n",sa.siz[i]+1);
    return 0;
}

```

---

## 作者：bztMinamoto (赞：4)


统计单词出现次数……为啥大家都是写AC自动机的嘞……明明后缀自动机也能做的说……

统计出现次数这个就直接按长度排序然后做个dp就好，这是SAM的板子的要求啊，不提了

然后考虑怎么让所有串之间隔开。本来打算建个广义SAM后来发现没办法处理子串重复的情况……然后就按题解里的方法在每两个串之间加入一个新字符然后直接对整个串建好了
```
//minamoto
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int N=4e6+5;
int fa[N],ch[N][27],l[N],cnt[N],last=1,tot=1;
char s[N>>1],t[N>>1];int len[N>>1],c[N],a[N],k,ans[N],n;
void ins(int c){
	int p=last,np=++tot;last=np,l[np]=l[p]+1,cnt[np]=1;
	for(;p&&!ch[p][c];p=fa[p]) ch[p][c]=np;
	if(!p) fa[np]=1;
	else{
		int q=ch[p][c];
		if(l[q]==l[p]+1) fa[np]=q;
		else{
			int nq=++tot;l[nq]=l[p]+1;
			memcpy(ch[nq],ch[q],sizeof(ch[q]));
			fa[nq]=fa[q],fa[q]=fa[np]=nq;
			for(;ch[p][c]==q;p=fa[p]) ch[p][c]=nq;
		}
	}
}
inline void calc(){
	for(int i=1;i<=tot;++i) ++c[l[i]];
	for(int i=1;i<=tot;++i) c[i]+=c[i-1];
	for(int i=1;i<=tot;++i) a[c[l[i]]--]=i;
	for(int i=tot;i;--i) cnt[fa[a[i]]]+=cnt[a[i]];
}
int main(){
//	freopen("testdata.in","r",stdin);
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		scanf("%s",t+1);len[i]=strlen(t+1);
		for(int j=1;j<=len[i];++j) ins(s[++k]=t[j]-'a');
		ins(s[++k]=26);
	}
	calc();k=0;
	for(int i=1,x,j;i<=n;++i){
		for(j=1,x=1;j<=len[i];++j)
		x=ch[x][s[++k]];
		ans[i]=cnt[x];
		++k;
	}
	for(int i=1;i<=n;++i) printf("%d\n",ans[i]);
	return 0;
}
```

---

## 作者：litble (赞：3)

介绍一种后缀数组的做法吧。

首先将所有的字符串粘成一个巨大的字符串，中间用**不同**的特殊字符分隔开。然后进行后缀排序，获得了后缀数组和$Height$数组。

对于每一个单词，我们找到它的首字母在后缀数组中的位置，只要能够找到一个包含当前位置的区间，使得其中的$Height$最小值依然不小于当前单词的长度，这个区间的大小就是答案。

可以考虑二分查找这个区间的左右端点最多可以扩展到哪。

至于怎么得到区间$Height$最小值，可以使用$rmq$

令$L$为单词总长，则该算法复杂度应该是$O(L log L)$的，虽然不及AC自动机的做法那么优秀，但是还是很直观的。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2000005;
int n,tpm=26,tn;
char s[N];int len[N],pos[N],a[N],x[N],y[N],T[N],SA[N],Hei[N];
void Rsort() {//基数排序
	for(int i=0;i<=tpm;++i) T[i]=0;
	for(int i=1;i<=tn;++i) ++T[x[y[i]]];
	for(int i=1;i<=tpm;++i) T[i]+=T[i-1];
	for(int i=tn;i>=1;--i) SA[T[x[y[i]]]--]=y[i];
}
int cmp(int i,int j,int num) {return y[i]==y[j]&&y[i+num]==y[j+num];}
void getSA() {//获得后缀数组
	for(int i=1;i<=tn;++i) x[i]=a[i],y[i]=i;
	Rsort();
	for(int km=1,num=1;km<tn;num+=num,tpm=km) {
		km=0;
		for(int i=tn-num+1;i<=tn;++i) y[++km]=i;
		for(int i=1;i<=tn;++i) if(SA[i]>num) y[++km]=SA[i]-num;
		Rsort(),swap(x,y),km=x[SA[1]]=1;
		for(int i=1;i<=tn;++i) x[SA[i]]=cmp(SA[i],SA[i-1],num)?km:++km;
	}
	for(int i=1;i<=tn;++i) x[SA[i]]=i;
}
void getHei() {//获得Height数组
	int lcp=0;
	for(int i=1;i<=tn;++i) {
		if(lcp) --lcp;
		int j=SA[x[i]-1];
		while(j+lcp<=tn&&i+lcp<=tn&&a[j+lcp]==a[i+lcp]) ++lcp;
		Hei[x[i]]=lcp;
	}
}
int f[N][22],Log[N],bin[22];
void init() {//预处理rmq
	bin[0]=1;for(int i=1;i<=21;++i) bin[i]=bin[i-1]<<1;
	for(int i=2;i<=tn;++i) Log[i]=Log[i>>1]+1;
	for(int i=tn;i>=1;--i) {
		f[i][0]=Hei[i];
		for(int j=1;j<=Log[tn-i+1];++j)
			f[i][j]=min(f[i][j-1],f[i+bin[j-1]][j-1]);
	}
}
int rmq(int l,int r) {int t=Log[r-l+1];return min(f[l][t],f[r-bin[t]+1][t]);}
//O(1)获得一个区间的Height最小值
int findl(int l,int r,int lim) {//二分查找左端点最多扩展到哪
	int re;
	while(l<=r) {
		int mid=(l+r)>>1;
		if(rmq(mid,r)>=lim) re=mid,r=mid-1;
		else l=mid+1;
	}
	return re;
}
int findr(int l,int r,int lim) {//二分查找右端点最多扩展到哪
	int re;
	while(l<=r) {
		int mid=(l+r)>>1;
		if(rmq(l,mid)>=lim) re=mid,l=mid+1;
		else r=mid-1;
	}
	return re;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;++i) {
		scanf("%s",s),len[i]=strlen(s),pos[i]=tn+1;
		for(int j=0;j<len[i];++j) a[++tn]=s[j]-'a'+1;
		a[++tn]=++tpm;//特殊字符隔开
	}
	getSA(),getHei(),init();
	for(int i=1;i<=n;++i) {
		int l,r,xx=x[pos[i]];
		if(xx==1||Hei[xx]<len[i]) l=xx;//特判左右端点不能扩展的情况
		else l=findl(2,xx,len[i])-1;
		if(xx==tn||Hei[xx+1]<len[i]) r=xx;
		else r=findr(xx+1,tn,len[i]);
		printf("%d\n",r-l+1);
	}
	return 0;
}
```

---

## 作者：Flowery (赞：2)

提供一种kmp的思路啦（当然大佬们一定可以用AC自动机的）

思路：用kmp暴力匹配（因为本题范围N<=200）,所以如果优化写得好是不会T掉的  

优化1：字符串快读  

优化2：get next数组只需要循环n次（如果每次匹配都get_nxt就会TLE,亲测过）  

优化3：如果字符t长度等于字符s长度，ans直接++,如果字符t长度大于字符s长度，直接continue  

# Code:
```cpp
#define Flowery
#define maxn 1000100
#define rg register int
#include<bits/stdc++.h>
using namespace std;
int nxt[maxn],n,ans,len;
char s[maxn],gy[210][maxn];
inline int re_s(char *s,int cnt)//字符串快读
{
	int x=0;
	while((s[++x]=getchar())!=' '&&s[x]!='\n'&&s[x]!='\377')gy[cnt][x]=s[x];
	return x-1;
}
inline void get_nxt(char *t)//get next数组
{
	int lent=strlen(t+1);
	memset(nxt,0,sizeof(nxt));
	for(rg i=2,j=0;i<=lent;i++)
	{
		while(j&&t[i]!=t[j+1])j=nxt[j];
		if(t[i]==t[j+1])j++;
		nxt[i]=j;
	}
}
inline int kmp(char *t,char *s)//kmp字符串匹配
{
	int ret=0;
	int lent=strlen(t+1),lens=strlen(s+1);
	if(lent>lens)return ret;//优化3
	for(rg i=1,j=0;i<=lens;i++)
	{
		while(j&&s[i]!=t[j+1])j=nxt[j];
		if(s[i]==t[j+1])j++;
		if(j==lent) {j=nxt[j];ret++;}
	}
	return ret;
}
int main()
{
	scanf("%d\n",&n);
	for(rg i=1;i<=n;i++)len=re_s(s,i);
	for(rg i=1;i<=n;i++)
	{
		ans=0;
		get_nxt(gy[i]);//一定要放外面
		for(rg j=1;j<=n;j++) 
		{
			if(i==j) {ans++;continue;}//优化3
			ans+=kmp(gy[i],gy[j]);
		}
		printf("%d\n",ans);
	}
	return 0;
}
```
——>[my blog](https://www.luogu.com.cn/blog/flowery/)

---

## 作者：万弘 (赞：2)

为啥我没用特殊字符隔开字符串,好慌啊 ~~我的做法是不是假的啊~~

一开始没看懂题,想着直接map记录串出现次数不就没了?复杂度不对就搞个Trie就可以线性了(当时读错的题意是,求串完整地出现了几次)

后来发现样例都对不上,仔细看题才明白是指"每个单词分别在论文中出现了多少次",也就是如果某个串是另一个串的字串,也是有贡献的.  
那这就是个AC自动机裸题了,每次读入一个串直接插入,所有经过的点标记$val[u]++$,在结尾节点标记$num[dex]=u$(dex是当前串的编号)

但$val[u]$此时还不表示以$u$为结尾的串出现了几次.  
别着急,先把AC自动机的fail指针建好.  
由fail的定义,可得:**fail[u]表示的以fail[u]为结尾的串一定是以u结尾的串的后缀**,也就是以fail[u]为结尾的串会在以u结尾的串中出现.

那么,建立fail树,求子树和即为最终答案.**时间复杂度线性.**

代码封装了建立fail树的ac自动机,所以应该不会太难看吧.
```cpp
//省略了快读
/**********/
#define MAXN 1000011
char a[MAXN];
struct ACM
{
    ll t[27][MAXN],num[MAXN],fail[MAXN],val[MAXN];
    struct Edge
    {
        ll v,nxt;
    }e[MAXN];
    ll Ecnt,last[MAXN];
    void adde(ll u,ll v)
    {
        e[++Ecnt].v=v;
        e[Ecnt].nxt=last[u],last[u]=Ecnt;
    }
    ll cnt;
    ACM()
    {
        Ecnt=0;
        cnt=0;
    }
    void insert(char* a,ll dex)//插入
    {
        ll n=strlen(a+1),u=0;
        for(ll i=1;i<=n;++i)
        {
            ll &v=t[a[i]-'a'][u];
            if(!v)v=++cnt;
            u=v;
            ++val[u];
        }
        num[dex]=u;
    }
    void dfs(ll u)//求fail树子树和
    {
        for(ll i=last[u];i;i=e[i].nxt)
        {
            ll v=e[i].v;
            dfs(v);
            val[u]+=val[v];
        }
    }
    void build()//求fail指针并构造fail树
    {
        std::queue<ll>q;
        for(ll i=0;i<26;++i)
            if(t[i][0])
            {
                fail[t[i][0]]=0;
                adde(0,t[i][0]);
                //printf("add 0 to %lld\n",t[i][0]);
                q.push(t[i][0]);
            }
        while(!q.empty())
        {
            ll u=q.front();q.pop();
            for(ll i=0;i<26;++i)
            {
                ll &v=t[i][u];
                if(v)
                {
                    fail[v]=t[i][fail[u]];
                    adde(fail[v],v);
                    //printf("add %lld to %lld\n",fail[v],v);
                    q.push(v);
                }
                else v=t[i][fail[u]];
            }
        }
        dfs(0);
    }
    ll getf(ll x)//询问串x的出现次数
    {
        return val[num[x]];
    }
}ac;
int main()
{
    ll n=read();
    for(ll i=1;i<=n;++i)
    {
        scanf("%s",a+1);
        ac.insert(a,i);
    }
    ac.build();
    for(ll i=1;i<=n;++i)
        printf("%lld\n",ac.getf(i));
    return 0;
}
```

---

## 作者：LightningUZ (赞：2)

提供一种完全不一样的思路。我今天刚刚做完二次加强版的模板，代码还在这，就想着怎么套这个模板，懒得改了。

然后就有了这样的方法：把每个字符串接起来，然后中间用一个特殊字符插入一下。这个字符不是$[a,z]$中的任意一个。这样就保证了我们找到的匹配不会跨过多个单词，仅限在一个单词内。然后这样的话就直接套那个模板即可。

当然，讲一下具体的实现。这个字符就是ASCII码表中的$'z'+1$。经过输出我们发现这个字符是左大括号```{```。然后我们在写$AC$自动机的时候就稍微改一下，把所有的$26$改成$27$就好了。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
namespace Flandre_Scarlet
{
	#define N 212345

	#define F(i,l,r) for(int i=l;i<=r;++i)
	#define D(i,r,l) for(int i=r;i>=l;--i)
	#define Fs(i,l,r,c) for(int i=l;i<=r;c)
	#define Ds(i,r,l,c) for(int i=r;i>=l;c)
	#define Tra(i,u) for(int i=G.Start(u);~i;i=G.Next(i))
	#define MEM(x,a) memset(x,a,sizeof(x))
	#define FK(x) MEM(x,0)

	int id[N];
	class AC_Automaton
	{
	public:
		int tr[N][27];
		int tot;

		void Init()
		{
			FK(tr);
			tot=1;
		}
		int Insert(char s[])
		{
			int pos=1;
			F(i,0,INT_MAX)
			{
				if (!s[i]) break;

				int c=s[i]-'a';
				if (!tr[pos][c])
				{
					tr[pos][c]=++tot;
				}
				pos=tr[pos][c];
			}
			return pos;
		}

		int fail[N];
		queue<int> Q;
		vector<int> G[N];void Add(int u,int v){G[u].push_back(v);}
		void BuildFail()
		{
			while(!Q.empty()) Q.pop();

			F(i,0,26) tr[0][i]=1;
			Q.push(1);
			while(!Q.empty())
			{
				int u=Q.front();Q.pop();

				F(i,0,26)
				{
					if (tr[u][i])
					{
						fail[tr[u][i]]=tr[fail[u]][i];
						Q.push(tr[u][i]);
					}
					else tr[u][i]=tr[fail[u]][i];
				}
			}

			F(i,2,tot) Add(fail[i],i);
		}

		int size[N];
		void DFS(int u)
		{
			F(i,0,(int)G[u].size()-1)
			{
				int v=G[u][i];
				DFS(v);
				size[u]+=size[v];
			}
		}
		void Query(char s[])
		{
			int pos=1;
			F(i,0,INT_MAX)
			{
				if (!s[i]) break;

				int c=s[i]-'a';
				pos=tr[pos][c];
				++size[pos];
			}
			DFS(1);
		}
	}AC;

	int n;
	char s[N];
	char T[N*10];
	void Input()
	{
		scanf("%d",&n);
		AC.Init();
		FK(T);
		F(i,1,n)
		{
			scanf("%s",s);
			id[i]=AC.Insert(s);
			strcat(T,s);
			strcat(T,"{");//{='z'+1
		}
	}
	void Soviet()
	{
		// printf("T=%s\n",T);
		AC.BuildFail();
		AC.Query(T);
		F(i,1,n)
		{
			printf("%d\n",AC.size[id[i]]);
		}
	}
	void IsMyWife()
	{
		Input();
		Soviet();
	}
}
int main()
{
	Flandre_Scarlet::IsMyWife();
	getchar();getchar();
	return 0;
}
```

---

## 作者：maomao9173 (赞：2)

### 数据加强，直接跳$Fail$指针逐个统计的写法已经$gg$。如果你的程序$TLE$了请不用担心，它没有出错，它只是单纯的复杂度有问题而已。
#### [题目链接  $Click$  $Here$](https://www.luogu.org/problemnew/show/P3966)

本题$AC$自动机写法的正解之一是$Fail$树上跑$DP$。

$AC$自动机是$Trie$树和$Fail$树共存的结构，前者可以方便地处理前缀问题，而在后者中，一个节点的子节点，**代表以当前字符串为后缀的所有字符串节点**（根节点外向$Fail$树）。我们最初给每个串的所有前缀计数$+1$，后期统计时，在该前缀的所有后缀上（$Fail$树上的祖先节点上），将其自身答案累加上去，就是总共出现的次数。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1000010;

struct AC_Auto {
	int top, sta[N];
	long long sum[N];
	int cnt, ch[N][26], pre[N], fail[N];

	AC_Auto () {
		cnt = top = 0;
		memset (ch, 0, sizeof (ch));
		memset (sum, 0, sizeof (sum));
		memset (pre, 0, sizeof (pre));
		memset (fail, 0, sizeof (fail));
	}

	void add_str (char *s) {
		int l = strlen (s), now = 0;
		for (int i = 0; i < l; ++i) {
			if (!ch[now][s[i] - 'a']) {
				ch[now][s[i] - 'a'] = ++cnt;
			}
			pre[ch[now][s[i] - 'a']] = now;
			now = ch[now][s[i] - 'a'];
			sum[now]++;
		}
		sta[++top] = now;
	}

	queue <int> q;
	
	void build () {
		for (int i = 0; i < 26; ++i) {
			if (ch[0][i]) {
				q.push (ch[0][i]);
			}
		}
		while (!q.empty ()) {
			int u = q.front (); q.pop ();
			for (int i = 0; i < 26; ++i) {
				if (ch[u][i]) {
					q.push (ch[u][i]);
					fail[ch[u][i]] = ch[fail[u]][i];
				} else {
					ch[u][i] = ch[fail[u]][i];
				}
			}
		}
	}

	int _cnt, head[N];

	struct edge {
		int nxt, to;
	}e[N];

	void add_edge (int from, int to) {
		e[++_cnt].nxt = head[from];
		e[_cnt].to = to;
		head[from] = _cnt;
	} 

	void dp (int u) {
		for (int i = head[u]; ~i; i = e[i].nxt) {
			dp (e[i].to);
			sum[u] += sum[e[i].to];
		}
	}
	
	void get_ans () {
		_cnt = 0;
		memset (head, -1, sizeof (head));
		for (int i = 1; i <= cnt; ++i) {
			add_edge (fail[i], i);
		}
		dp (0);
		for (int i = 1; i <= top; ++i) {
			cout << sum[sta[i]] << endl;
		}
	}
	
	
	
	
}AC;

int n; char s[N];

int main () {
	cin >> n;
	for (int i = 1; i <= n; ++i) {
		scanf ("%s", s);
		AC.add_str (s);
	}
	AC.build ();
	AC.get_ans ();
}

```
$UPD:$新增了后缀数组$+ST$表$+$倍增写法
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 2000010;

char tmp[N];
int n, len, ban = 'z', s[N], id[N], sa[N], tp[N], rk[N], _rk[N], bin[N], _len[N], height[N];

void get_height (int n) {
	int k = 0;
	for (int i = 1; i <= n; ++i) {
		if (k != 0) --k;
		int j = sa[rk[i] - 1];
		while (s[i + k] == s[j + k]) ++k;
		height[rk[i]] = k;
	}
}

void base_sort (int n, int m) {
	for (int i = 0; i <= m; ++i) bin[i] = 0;
	for (int i = 1; i <= n; ++i) bin[rk[tp[i]]]++;
	for (int i = 1; i <= m; ++i) bin[i] += bin[i - 1];
	for (int i = n; i >= 1; --i) sa[bin[rk[tp[i]]]--] = tp[i];
}

void suffix_sort (int n, int m) {
	for (int i = 1; i <= n; ++i) {
		tp[i] = i, rk[i] = s[i];
	}
	base_sort (n, m);
	for (int w = 1; w <= n; w <<= 1) {
		int cnt = 0;
		for (int i = n - w + 1; i <= n; ++i) tp[++cnt] = i;
		for (int i = 1; i <= n; ++i) if (sa[i] > w) tp[++cnt] = sa[i] - w;
		base_sort (n, m);
		memcpy (_rk, rk, sizeof (rk));
		rk[sa[1]] = cnt = 1;
		for (int i = 2; i <= n; ++i) {
			rk[sa[i]] = (_rk[sa[i - 1]] == _rk[sa[i]]) && (_rk[sa[i - 1] + w] == _rk[sa[i] + w]) ? cnt : ++cnt; 
		}
		if (cnt == n) break;
		m = cnt;
	}
}

int fa[N][25];

int query (int l, int r) {
	if (l >= r) return 0; l++;
	int mx = log2 (r - l + 1);
	return min (fa[l][mx], fa[r - (1 << mx) + 1][mx]);
}

void get_STlist (int n) {
	int mx = log2 (n);
	for (int i = 1; i <= n; ++i) fa[i][0] = height[i];
	for (int i = 1; i <= mx; ++i) {
		for (int j = 1; j <= n - (1 << i) + 1; ++j) {
			fa[j][i] = min (fa[j][i - 1], fa[j + (1 << (i - 1))][i - 1]);
		}
	}
}

int main () {
	cin >> n;
	for (int i = 1; i <= n; ++i) {
		scanf ("%s", tmp);
		int l = strlen (tmp);
		id[i] = len + 1;
		_len[i] = l;
		for (int j = 0; j < l; ++j) {
			s[++len] = tmp[j];
		}
		s[++len] = ++ban;
	}
	suffix_sort (len, ban);
	get_height (len);
	get_STlist (len);
	for (int i = 1; i <= n; ++i) {
		int l = rk[id[i]], r = rk[id[i]];
		for (int j = 24; j >= 0; --j) {
			int tol = l - (1 << j);
			int tor = r + (1 << j);
			if (tol >= 1   && query (tol, rk[id[i]]) >= _len[i]) l = tol;
			if (tor <= len && query (rk[id[i]], tor) >= _len[i]) r = tor;
		}
		printf ("%d\n", r - l + 1);
	}
}

```

---

## 作者：creed_ (赞：2)

这道题最直接的想法居然不是树上差分qwq

考虑一个暴力的想法

把AC自动机建出来后，对于依次查询每一个单词，暴力跳fail指针

对经过的单词节点+1。

考虑优化这个过程

注意到fail指针构成了fail树，这个操作本质上等价于对从把一个

点到根的路径上的所有点加一。这个操作可以用树上差分来优化。

复杂度O(∑len)。
```
#include<iostream>
#include<cctype>
#include<cstdio>
#include<cstring>
#include<string>
#include<cmath>
#include<ctime>
#include<queue>
#include<cstdlib>
#include<algorithm>
#define N 1500000
#define eps 1e-7
#define inf 1e9+7
#define ll long long
using namespace std;
inline int read()
{
	char ch=0;
	int x=0,flag=1;
	while(!isdigit(ch)){ch=getchar();if(ch=='-')flag=-1;}
	while(isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return x*flag;
}
const int mo=inf;
struct node
{
	int f,v,nxt[27];
}t[N];
string s,T;
queue<int>q; 
int root=1,size=1,times,p[N],dp[N];
void insert()
{
	int x=root,len=s.size();
	for(int i=0;i<len;i++)
	{
		int k=s[i]-'a';
		if(!t[x].nxt[k])t[x].nxt[k]=++size;
		x=t[x].nxt[k];
	}
	t[x].v=true;p[++times]=x;
}
void build()
{
	q.push(root);
	while(!q.empty())
	{
		int x=q.front();
		q.pop();
		for(int i=0;i<27;i++)
		{
			if(t[x].nxt[i])
			{
				if(x!=root)t[t[x].nxt[i]].f=t[t[x].f].nxt[i];
				else t[t[x].nxt[i]].f=root;
				q.push(t[x].nxt[i]);
			}
			else
			{
				if(x!=root)t[x].nxt[i]=t[t[x].f].nxt[i];
				else t[x].nxt[i]=root;
			}
		}
	}
}
void solve()
{
	int x=root,len=T.size();
	for(int i=0;i<len;i++)
	x=t[x].nxt[T[i]-'a'],dp[x]++;	
}
struct edge
{
	int to,nxt;
}e[N];
int num=-1,head[N];
inline void add(int x,int y)
{
	e[++num]=(edge){y,head[x]};head[x]=num;
}
int dfs(int x)
{
	for(int i=head[x];i!=-1;i=e[i].nxt)
	{
		int to=e[i].to;
		dp[x]+=dfs(to);
	}
	return dp[x];
}
int main()
{
	int n=read();
	for(int i=1;i<=n;i++)
	cin>>s,insert(),T+=s+"{";
	build();solve();
	memset(head,-1,sizeof(head));
	for(int i=2;i<=size;i++)add(t[i].f,i);
	dfs(1);
	for(int i=1;i<=n;i++)printf("%d\n",dp[p[i]]);
	return 0;
}
```

---

## 作者：stargre (赞：1)

###### 蒟蒻的题解

虽然这是紫题
实际上弄懂Ac自动机也就很好做了啊

~~不懂的话还是先看书吧~~

不过暴力AC自动机会TLE 所以蒟蒻就加了一个玄学优化

为了防止每次找都浪费很多时间 开一个数组先统计次数 
最后再一起加起来比较快 ~~语文不好还是看代码吧~~
### 代码
```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
using namespace std;
int n,m,l,tot = 1,u;
char s[1000015],ma[1000500];
int ch[3000001][28],nxt[1000001],que[1000001];
int b[1000005],qwq[1000001],ovo[1000001],ans[1000001]; //小心太小RE 太大MLE 
void ca(int x) //正常插入操作 
{
	u = 1;
	for(int i = 1;i <= l;i++) {
		int a = s[i] - 'a';
		if(!ch[u][a]) ch[u][a] = ++tot;
		u = ch[u][a];
	}
	b[x] = u; //记录第i个单词的末尾 方便后面查询 
}
void bfs()//求fail指针 
{
	for(int i = 0;i <= 25;i++) ch[0][i] = 1;//建立虚拟节点 并使节点到每个字母都为1 
	que[1] = 1; nxt[1] = 0;
	for(int q1 = 1,q2 = 1;q1 <= q2;++q1) {
		int u = que[q1];
		for(int i = 0;i <= 25;i++) {
			if(!ch[u][i]) ch[u][i] = ch[nxt[u]][i];//奇怪的优化 
			else {
				que[++q2] = ch[u][i]; //加入队列 
				nxt[ch[u][i]] = ch[nxt[u]][i];
			}
		}
	}
}
void find() {
	u = 1;
	for(int i = 1;i <= m;i++) {
		int a = ma[i] - 'a';
		if(a == 26) {//如果碰到间隔的地方 
			u = 1;
			continue;
		}
		int k = ch[u][a];
		ovo[k] ++;//在最开始的地方统计起来 最后再一起加 
		qwq[k] = -1;//标记 
		u = ch[u][a]; 
	}
}
int main()
{
	scanf("%d",&n);
	for(int i = 1;i <= n;i++)
	{
		scanf("%s",s + 1);
		l = strlen(s + 1);
		for(int j = 1;j <= l;j++) ma[++m] = s[j];//合成母串 
		ma[++m] = 'z' + 1;//单词中间间隔一下 
		ca(i);
	}
	bfs();
	find();
	for(int i = 1;i <= 1000000;i++) if(!~qwq[i]) { //统一加起来 
		int k = i;
		while(k) {//标记及其前面 nxt[]对应的地方也加 
			ans[k] += ovo[i];//一次性加 免得一次一次浪费时间 
			k = nxt[k];
		}
	}
	for(int i = 1;i <= n;i++) printf("%d\n",ans[b[i]]);//单词末尾对应的ans值就是答案 
}

```


---

## 作者：SSerxhs (赞：1)

后缀树模板题。

把字符串连起来并用%隔开，然后在最后加一个&，然后按照ukk法建出后缀树，则求每个字符串出现次数只需要在后缀树上匹配这个字符串然后输出包含的叶子节点（即后缀）的个数。

```cpp
#include <stdio.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N=1e6+210,M=2e6+420;
int t[M],f[M],c[M][28],zd[M],s[N],siz[M],lj[M],nxt[M],fir[M],fa[M],lf[M];
int n,ds=1,i,j,k,x,y,z,cc,ad,point,edge,r,bs,fbs,remain,m;
inline void add(int x,int y)
{
	lj[++fbs]=y;
	nxt[fbs]=fir[x];
	fir[x]=fbs;
}
inline void add(int a,int b,int cc,int d)
{
	zd[++bs]=b;f[bs]=cc;t[bs]=d;c[a][s[cc]]=bs;
}
void dfs(int x)
{
	if (!fir[x]) {siz[x]=1;return;}
	int i,v;
	for (i=fir[x];i;i=nxt[i])
	{
		lf[v=zd[c[x][lj[i]]]]=i;
		dfs(v);
		siz[x]+=siz[v];
	}
}
int main()
{
	scanf("%d",&n);
	for (i=1;i<=n;i++)
	{
		cc=getchar();
		while ((cc<'a')||(cc>'z')) cc=getchar();
		while ((cc>='a')&&(cc<='z'))
		{
			s[++m]=cc-'a';cc=getchar();
		}
		s[++m]=26;
	}s[++m]=27;
	fa[1]=point=1;
	for (i=1;i<=m;i++)
	{
		ad=0;++remain;
		while (remain)
		{
			if (r==0) edge=i;
			if ((j=c[point][s[edge]])==0)
			{
				fa[++ds]=1;
				fa[ad]=point;
				add(ad=point,ds,edge,m);
				add(point,s[edge]);
			}
			else
			{
				if ((t[j]!=m)&&(t[j]-f[j]+1<=r))
				{
					r-=t[j]-f[j]+1;
					edge+=t[j]-f[j]+1;
					point=zd[j];
					continue;
				}
				if (s[f[j]+r]==s[i]) {++r;fa[ad]=point;break;}
				fa[fa[ad]=++ds]=1;
				add(ad=ds,zd[j],f[j]+r,t[j]);
				add(ds,s[i]);add(ds,s[f[j]+r]);fa[++ds]=1;
				add(ds-1,ds,i,m);
				zd[j]=ds-1;t[j]=f[j]+r-1;
			}
			--remain;
			if ((r)&&(point==1))
			{
				--r;edge=i-remain+1;
			} else point=fa[point];
		}
	}
	dfs(1);
	for (j=i=1;i<=m;i++) if (s[i]==26)
	{
		x=1;r=0;
		for (k=j;k<i;k++)
		{
			if (r==0) edge=c[x][s[k]];++r;
			if (f[edge]+r>t[edge]) {x=zd[edge];r=0;}
		}if (r) x=zd[edge];
		j=i+1;
		printf("%d\n",siz[x]);
	}
}
```


---

## 作者：温词 (赞：1)

## BZOJ3172&&lg3966 TJOI单词(广义后缀自动机) ##
### 题面
自己找去
### HINT
给出多个文本串，让你查找每个文本串一共出现了多少次，广义后缀自动机建出parent tree然后上推就好了鸭，感觉代码也没有什么细节，写就完事了。
```cpp
#include<bits/stdc++.h>
#include<set>
using namespace std;
const int maxn=200010;
inline int read(){
    int w=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        w=(w<<3)+(w<<1)+ch-48;
        ch=getchar();
    }
    return w*f;
}
int n,m;
bool debug;
set<int> s[maxn];
set<int>::iterator it;
int size[2000010];
struct SUFFIXAUTOMATON{
    struct Node{
        int len,fa;
        map<int,int> ch;
    }node[2000010];
    int lst,tot,root;
    inline void init(){
        lst=tot=root=1;return;
    }
    inline void extend(int now){
        int p=lst;tot++;lst=tot;int np=tot;
        node[np].len=node[p].len+1;size[np]=1;
        while(p&&!node[p].ch[now]){
            node[p].ch[now]=np;
            p=node[p].fa;
        }
        if(!p) node[np].fa=1;
        else{
            int q=node[p].ch[now];
            if(node[q].len==node[p].len+1){
                node[np].fa=q;
            }
            else{
                int nq=++tot;node[nq]=node[q];
                node[nq].len=node[p].len+1;
                node[q].fa=nq;node[np].fa=nq;
                while(p&&node[p].ch[now]==q){
                    node[p].ch[now]=nq;
                    p=node[p].fa;
                }
            }
        }
    }
}SAM;
string ch[210];
int cnt,head[2000010];
struct Edge{
    int from,to,next;
}edge[5000010];
inline void addedge(int u,int v){
    cnt++;
    edge[cnt].from=u;
    edge[cnt].to=v;
    edge[cnt].next=head[u];
    head[u]=cnt;
}
inline void dfs(int u){
    for(int i=head[u];i;i=edge[i].next){
        int v=edge[i].to;dfs(v);
        size[u]+=size[v];
    }
    return;
}
int main(){
    n=read();SAM.init();
    for(int i=1;i<=n;i++){
        cin>>ch[i];int len=ch[i].length();
        for(int j=0;j<len;j++){
            SAM.extend(ch[i][j]-'a'+1);
        }
        SAM.lst=1;
    }
    for(int i=2;i<=SAM.tot;i++){
        addedge(SAM.node[i].fa,i);
    }
    dfs(1);
    for(int i=1;i<=n;i++){
        int u=1;int len=ch[i].length();
        for(int j=0;j<len;j++){
            u=SAM.node[u].ch[ch[i][j]-'a'+1];
        }
        printf("%d\n",size[u]);
    }
    return 0;
}
```

---

## 作者：asuldb (赞：1)

发现暴力$AC$机硬上好像会$T$?

那就暴力$kmp$硬上吧

发现$n<=200$那不就是$kmp$随便过的题了

没什么思维难度了，直接暴力枚举每一个字符串，之后去和每一个字符串搞一个单串匹配就好了

复杂度是$O(n\times|S|)$

代码

```

#include<iostream>
#include<cstdio>
#include<cstring>
#define LL long long
#define min(a,b) ((a)<(b)?(a):(b))
#define max(a,b) ((a)>(b)?(a):(b))
#define re register
#define maxn 1000006 
inline int read()
{
	char c=getchar();
	int x=0;
	while(c<'0'||c>'9') c=getchar();
	while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+c-48,c=getchar();
	return x;
}
std::string S[201];
int nx[maxn];
std::string s;
int n;
inline void get_nx(int x)
{
	int len=S[x].size();
	for(re int i=1;i<len;i++)
		nx[i]=0;
	nx[1]=0;
	for(re int i=2;i<len;i++)
	{
		int p=nx[i-1];
		while(p&&S[x][p+1]!=S[x][i]) p=nx[p];
		if(S[x][p+1]==S[x][i]) nx[i]=p+1;
			else nx[i]=0;
	}
}
inline int query(int x)
{
	int now=0;
	int p=0;
	int len=S[x].size();
	for(re int i=1;i<len;i++)
	{
		while(p&&s[p+1]!=S[x][i]) p=nx[p];
		if(s[p+1]==S[x][i]) ++p;
			else p=0;
		if(p==s.size()-1) now++,p=nx[p];
	}
	return now;
}
int main()
{
	scanf("%d",&n);
	for(re int i=1;i<=n;i++) std::cin>>S[i],S[i]="#"+S[i];
	for(re int t=1;t<=n;t++)
	{
		get_nx(t);
		s=S[t];
		int ans=0;
		for(re int j=1;j<=n;j++)
		if(t!=j) ans+=query(j);
		printf("%d\n",ans+1);
	}
	return 0;
}

```


---

## 作者：Celtic (赞：1)

题意：给出$n$个单词，求每个单词在这$n$个单词中出现的次数。

概念：$fail$ 树：AC自动机中每个$fail$指针的反向边作为一条有向边，因为每个点只有$1$个$fail$指针，所以每个点入度为$1$，所以图是树形的。

那么对于这道题我们可以建出$fail$树，设$siz_i$表示有多少个单词经过i节点，所以每个节点的表示的字符串的出现次数应为该节点的$fail$树中子树的$siz$的和。

AC代码

```cpp
#include<bits/stdc++.h>
#define N 201001
#define MAX 2001
#define re register
using namespace std;
typedef long long ll;
typedef double db;
inline void read(re ll &ret)
{
    ret=0;re char c=getchar();re bool pd=false;
    while(!isdigit(c)){pd|=c=='-';c=getchar();}
    while(isdigit(c)){ret=(ret<<1)+(ret<<3)+(c&15);c=getchar();}
    ret=pd?-ret:ret;
    return;
}
ll n,trie[N][30],tot,nxt[N],num[N],ans,tt,siz[N],b[N],top;
char s[N][101],t[N*10];
ll f[N];
inline void insert(re ll pos)
{
    re ll len(strlen(s[pos]+1)),p(0),c;
    for(re int i(1);i<=len;++i)
    {
        c=s[pos][i]-'a';
        if(!trie[p][c])
            trie[p][c]=++tot;
        p=trie[p][c];
        siz[p]++;
    }
    f[pos]=p;
    return;
}
inline void bfs()
{
    queue<ll>q;
    for(re int i=0;i<26;i++)
        if(trie[0][i])
            q.push(trie[0][i]);
    re ll p;
    while(!q.empty())
    {
        p=q.front();
        b[++top]=p;
        q.pop();
        for(re int i(0);i<26;++i)
        {
            if(!trie[p][i])trie[p][i]=trie[nxt[p]][i];
            else
            {
                q.push(trie[p][i]);
                nxt[trie[p][i]]=trie[nxt[p]][i];
            }
        }
    }
    return;
}
inline void AC()
{
    re ll len(strlen(t+1)),p(0),c,k;
    for(re int i(1);i<=len;++i)
    {
        c=(t[i]-'a');
        p=trie[p][c];
        if(f[p])
        {
        	for(re int j=p;j;j=nxt[j])
        	{
        		num[f[j]]++;
       			ans=max(ans,f[j]?num[f[j]]:0);
			}
		}
    }
    return;
}
main()
{
	read(n);
	if(!n)exit(0);
   	for(re int i(1);i<=n;i++)
   	{
  		scanf("%s",s[i]+1);
       	insert(i);
    }
   	bfs();
   	for(re int i=tot;i>=0;i--)
   		siz[nxt[b[i]]]+=siz[b[i]];
   	for(re int i=1;i<=n;i++)
   		printf("%lld\n",siz[f[i]]);
	exit(0);
}
```


---

## 作者：Mihari (赞：0)

~~实在不知道为什么这是一道省选题，或许是 $\sout{T1}$ 难度吧~~

一道 $AC$ 自动鸡的板题。

模式串就是输入的那些字符串，用那些模式串建一只鸡即可。

而文本串可能要想一会——将模式串之间用一些特别的字符隔开，再拼起来，得到的最终的串就是我们的文本串。

至于剩下的，或许就是 $AC$ 自动鸡的模板了。

如果有 $AC$ 自动鸡不懂的，可以问度娘。

此处代码使用拓扑优化 $AC$ 自动鸡，安利一位大佬关于 $AC$ 自动鸡的讲解[sto hyfhaha](https://www.cnblogs.com/hyfhaha/p/10802604.html)

```cpp
#include<cstdio>
#include<cstring>
#include<vector>
#include<queue>
using namespace std;

#define rep(i,__l,__r) for(signed i=__l,i##_end_=__r;i<=i##_end_;++i)
#define fep(i,__l,__r) for(signed i=__l,i##_end_=__r;i>=i##_end_;--i)
#define writc(a,b) fwrit(a),putchar(b)
#define mp(a,b) make_pair(a,b)
#define ft first
#define sd second
#define LL long long
#define ull unsigned long long
#define uint unsigned int
#define pii pair< int,int >
#define Endl putchar('\n')
// #define FILEOI
// #define int long long
// #define int unsigned

#ifdef FILEOI
# define MAXBUFFERSIZE 500000
    inline char fgetc(){
        static char buf[MAXBUFFERSIZE+5],*p1=buf,*p2=buf;
        return p1==p2&&(p2=(p1=buf)+fread(buf,1,MAXBUFFERSIZE,stdin),p1==p2)?EOF:*p1++;
    }
# undef MAXBUFFERSIZE
# define cg (c=fgetc())
#else
# define cg (c=getchar())
#endif
template<class T>inline void qread(T& x){
    char c;bool f=0;
    while(cg<'0'||'9'<c)f|=(c=='-');
    for(x=(c^48);'0'<=cg&&c<='9';x=(x<<1)+(x<<3)+(c^48));
    if(f)x=-x;
}
inline int qread(){
    int x=0;char c;bool f=0;
    while(cg<'0'||'9'<c)f|=(c=='-');
    for(x=(c^48);'0'<=cg&&c<='9';x=(x<<1)+(x<<3)+(c^48));
    return f?-x:x;
}
template<class T,class... Args>inline void qread(T& x,Args&... args){qread(x),qread(args...);}
template<class T>inline T Max(const T x,const T y){return x>y?x:y;}
template<class T>inline T Min(const T x,const T y){return x<y?x:y;}
template<class T>inline T fab(const T x){return x>0?x:-x;}
inline int gcd(const int a,const int b){return b?gcd(b,a%b):a;}
inline void getInv(int inv[],const int lim,const int MOD){
    inv[0]=inv[1]=1;for(int i=2;i<=lim;++i)inv[i]=1ll*inv[MOD%i]*(MOD-MOD/i)%MOD;
}
template<class T>void fwrit(const T x){
    if(x<0)return (void)(putchar('-'),fwrit(-x));
    if(x>9)fwrit(x/10);
    putchar(x%10^48);
}
inline LL mulMod(const LL a,const LL b,const LL mod){//long long multiplie_mod
    return ((a*b-(LL)((long double)a/mod*b+1e-8)*mod)%mod+mod)%mod;
}

struct node{
    int u,fail;char cr;
    node(const int U=0,const int F=0,const char C='\0'):u(U),fail(F),cr(C){}
};

const int MAXK=27;
const int MAXN=200;
const int MAXSIZE=1e6+MAXN;
const char spc='z'+1;

int trie[MAXSIZE+5][MAXK+5],fail[MAXSIZE+5],enz[MAXN+5],N,ncnt=1;
int in[MAXSIZE+5],tot[MAXSIZE+5];

char T[MAXSIZE+5];

inline void Insert(const char* ss,const int id){
    int p=1;
    for(int i=0,siz=strlen(ss),v;i<siz;++i){
        v=ss[i]-'a';
        if(!trie[p][v])trie[p][v]=++ncnt;
        p=trie[p][v];
    }
    enz[id]=p;
}

inline void Getfail(){
    rep(i,0,MAXK)trie[0][i]=1;
    queue<int>Q;Q.push(1),fail[1]=0;
    while(!Q.empty()){
        int u=Q.front();Q.pop();
        for(int i=0,v,ff=fail[u];i<MAXK;++i){
            v=trie[u][i];
            if(!v){trie[u][i]=trie[ff][i];continue;}
            fail[v]=trie[ff][i],++in[trie[ff][i]];
            Q.push(v);
        }
    }
}

inline void Compare(const char* ss){
    for(int i=0,len=strlen(ss),p=1;i<len;++i){
        p=trie[p][ss[i]-'a'];
        ++tot[p];
    }
}

inline void Runtopu(){
    queue<int>Q;
    rep(i,1,ncnt)if(!in[i])Q.push(i);
    while(!Q.empty()){
        int u=Q.front();Q.pop();
        tot[fail[u]]+=tot[u];
        --in[fail[u]];
        if(!in[fail[u]])Q.push(fail[u]);
    }
}

signed main(){
#ifdef FILEOI
    freopen("file.in","r",stdin);
    freopen("file.out","w",stdout);
#endif
    qread(N);
    for(int i=1,prelen=0;i<=N;++i){
        prelen=strlen(T);
        if(i!=1)T[prelen]=spc,++prelen;
        scanf("%s",T+prelen);
        Insert(T+prelen,i);
    }
    Getfail();
    Compare(T);
    Runtopu();
    rep(i,1,N)writc(tot[enz[i]],'\n');
    return 0;
}

```

---

## 作者：nbnhzbw (赞：0)

**这道题可以用字符串的find做，虽然代码易打，但还是有要注意的地方：**

1：每次查找位置以后，下一次查找的位置是以上一次查找的位置加1，否则就会死循环。

2：当find查找不到的时候，似乎会返回一个很大的值，所以，查找的位置小于字符串长度即可。

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
int n,ans;
string s[210];
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);//一个优化
	cin>>n;
	for(register int i=1; i<=n; ++i) cin>>s[i];
	for(register int i=1; i<=n; ++i) {
		ans=0;
		for(register int j=1; j<=n; ++j) {
			int k=0,kk=s[j].find(s[i],k);
			while(kk<s[j].length()) {
				k=kk+1;
				kk=s[j].find(s[i],k);
				++ans;
			}
		}
		cout<<ans<<endl;
	}
	return 0;
}
```


---


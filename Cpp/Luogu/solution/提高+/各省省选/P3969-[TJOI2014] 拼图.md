# [TJOI2014] 拼图

## 题目描述

小Z最近迷上了拼图游戏,然而智商有限,他总是无法拼出完整图案。游戏是这样的：首先小Z会得到一些拼图碎片,然后他试着重新排列这些碎片使得它们组成一个大小为4\*4的正方形。如下图。注意小Z不能旋转或者翻转这些碎片。

 ![](https://cdn.luogu.com.cn/upload/pic/10988.png) 

小Z得到如图1的碎片,然后经过重新排列得到图2的正方形。

由于小Z实在太笨了,聪明的你请写一个程序帮助他来解决这个问题吧。


## 说明/提示

### 数据范围

对于 30% 的数据，N < 5

对于 100% 的数据，N ≤ 16


## 样例 #1

### 输入

```
4
2 3
111
101
4 2
01
01
11
01
2 1
1 1
3 2
10
10
11
4
1 4
1111
1 4
1111
1 4
1111
1 4
1111
4
1 4
1111
1 4
1111
1 4
1111
2 3
111
001```

### 输出

```
Yes, only one!
1112
1412
3422
3442
Yes, many!
No solution```

# 题解

## 作者：seac_blue (赞：5)

主要算法是搜索，注意实现细节。

### 思路

1. 读入并处理每一块拼图

2. dfs 每一块拼图放在哪里

- 2.1. 判断能否放置

- 2.2. 如果能，将拼图对应的相对坐标覆盖到版面的绝对坐标上

- 2.3. 重复 2.

- 2.4. 回溯，将拼图对应的相对坐标从版面的绝对坐标抠出来

3. 每次 bfs 判断是否覆盖满

- 3.1 开一个答案数组和答案个数记录

- 3.2 如果答案个数 $=0\to$ `No solution`

- 3.3 如果答案个数 $=1\to$ `Yes, only one!`

- 3.4 如果答案个数 $=2\to$ `Yes, many!` 并且直接退出。

### 实现

步骤 1 使用结构体存储。

步骤 2.1 可以用一一对应的方式写个判断函数。

步骤 2.2 和 2.4 可以写个覆盖函数，参数稍作修改，不需要写两次。

步骤 3 需要写个判断是否填满的函数。

总体框架见上，依旧注意实现细节。

（感觉这题难度标高了，建议绿）

### 代码

代码省略了头文件和快读。变量和函数都写有一定的注释解释。

```cpp
using namespace std;
typedef long long ll;

ll read(){/* 快读 */}
ll reads(){/* 读入一个数字 0/1 */}

ll n;
ll f[5][5];// 操作版面
ll restime;// 答案个数
ll res[5][5];// 答案版面
bool allret;// 如果 allret=true 那么 dfs() 全部返回

struct Puzzle{
	ll w,h;
	bool p[5][5];
}a[20];

bool allFill(){// 版面是否填满
	for(ll i=1;i<=4;++i){
		for(ll j=1;j<=4;++j){
			if(!f[i][j])return false;
		}
	}
	return true;
}
bool check(ll id,ll x,ll y){// 是否可以以 (x,y) 为左上角放置拼图 id
	for(ll i=1;i<=a[id].w;++i){
		for(ll j=1;j<=a[id].h;++j){
			if(!a[id].p[i][j])continue;
			ll px=x+i-1,py=y+j-1;
			if(px>4 || py>4)return false;
			if(f[px][py])return false;
		}
	}
	return true;
}
void set(ll id,ll x,ll y,ll fillOper){// 以 (x,y) 为左上角放置 id
	for(ll i=1;i<=a[id].w;++i){
		for(ll j=1;j<=a[id].h;++j){
			if(!a[id].p[i][j])continue;
			ll px=x+i-1,py=y+j-1;
			f[px][py]=fillOper;
		}
	}
}

void dfs(ll k){
	bool p=allFill();
	if(p || k>n){// 边界条件
		if(p){// 版面填满
			if(restime){
				allret=true;
				restime=2;
				return;
			}else{
				restime=1;
				for(ll i=1;i<=4;++i){
					for(ll j=1;j<=4;++j){
						res[i][j]=f[i][j];
					}
				}
				return;
			}
		}
		return;
	}
	for(ll i=1;i<=4;++i){
		for(ll j=1;j<=4;++j){
			if(check(k,i,j)){
				set(k,i,j,k);
				dfs(k+1);
				if(allret)return;
				set(k,i,j,0);
			}
		}
	}
	dfs(k+1);// 选择不要这块拼图，但是似乎所有拼图都会用上……？
}

int main(){
	while(scanf("%lld\n",&n)!=EOF){
		for(ll i=1;i<=n;++i){
			a[i].w=read();a[i].h=read();
			for(ll j=1;j<=a[i].w;++j){
				for(ll k=1;k<=a[i].h;++k){
					a[i].p[j][k]=reads();
				}
			}
		}
		allret=false;restime=0;
		for(ll i=1;i<=4;++i){
			for(ll j=1;j<=4;++j){
				f[i][j]=0;
			}
		}
		dfs(1);
		if(restime==2){
			printf("Yes, many!\n");
		}if(restime==0){
			printf("No solution\n");
		}if(restime==1){
			printf("Yes, only one!\n");
			for(ll i=1;i<=4;++i,putchar('\n')){
				for(ll j=1;j<=4;++j){
					printf("%lld",res[i][j]);
				}
			}
		}
	}
	return 0;
}
```

---

## 作者：名字好难取144 (赞：4)

## 写在前面

~~虽然它是一道蓝题，但是它确实很难~~

我用了将近半天的时间来思考（同机房大佬半个小时解决了）

## 思路

扯完了，开始讲思路。

看到题目，相信大家第一个想到的是**搜索**吧，**枚举每一个拼图可能放置的位置，如果 $4\times4$ 的方格可以被填满就让答案加 $1$。如果答案大于 $2$，就可以结束搜索了。**

那么，我们应该怎么搜索呢？

首先先解决存数据的问题。我们可以开一个结构体，里面开一个二维数组来存放拼图，再开两个变量来存储这个拼图的大小。

接下来，我们以剩余的格子为阶段进行搜索，每个阶段寻找没有使用过的格子来放置拼图。当没有使用过的格子为 $0$ 的时候就检查答案的个数，如果答案为 $0$，存储当前每个格点上的拼图的编号并让答案加 $1$；如果答案为 $1$，答案加 $1$ 后就可以退出搜索了。

## 几个要注意的点

- 在开始下一轮的搜索时，记得清空数组

- 注意边界

- 在回溯的时候，注意要把拼图还原

- 注意输出是否正确

- **理清楚思路**


## 代码

接下来是代码时间~ 

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<queue>
#include<cstring>
#define ll long long
using namespace std;
const int N=1e5+10;

struct puz{   //存拼图
    int ma[100][100];
    int r,c,sum;
}p[20];

int a[100][100];//拼图板
int b[100][100];//记录答案的
bool vis[30];

int n,ans,cnt;

inline int read()  //这是快读 
{
    int s=0,w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9') {if(ch=='-') w=-1; ch=getchar();}
    while(ch>='0'&&ch<='9') {s=s*10+ch-'0';ch=getchar();}
    return s*w;
}


bool judge(int x,int y,int pos)  //judge函数，检查拼图是否可以放置在该位置 
{
	if(x+p[pos].r-1>4||y+p[pos].c-1>4) return 0;
	for(int i=x,ii=1;i<x+p[pos].r;++i,++ii) 
	{
		for(int j=y,jj=1;j<y+p[pos].c;++j,++jj)
		{
			if( p[pos].ma[ii][jj]==1 && a[i][j] ) return 0;
		}
	}//(i,j)：当前拼图板被检查的位置； (ii,jj)：当前拼图被检查的位置 下同
	return 1;
}

bool check_ans() //检查当前答案是否和现有的答案相同 
{
	for(int i=1;i<=4;++i)
	{
		for(int j=1;j<=4;++j)
		{
			if(a[i][j]!=b[i][j]) return 1;
		}
	}
	return 0;
}

void puts(int x,int y,int pos) //put函数，用于放置拼图。 
{
	for(int i=x,ii=1;i<x+p[pos].r;++i,++ii)
	{
		for(int j=y,jj=1;j<y+p[pos].c;++j,++jj)
		{
			if(p[pos].ma[ii][jj]==1) a[i][j]=pos;
		}
	}
}

void paste(int x,int y,int pos) //paste函数，用于还原拼图原来的状态。 
{
	for(int i=x,ii=1;i<x+p[pos].r;++i,++ii)
	{
		for(int j=y,jj=1;j<y+p[pos].c;++j,++jj)
		{
			if(p[pos].ma[ii][jj]==1) a[i][j]=0;
		}
	}
}

void dfs(int ok)
{
	if(ans==2) return ; //如果答案大于2，直接回头 
    if(ok==0)
    {
    	if(!ans)
    	{
    		ans++;
    		for(int i=1;i<=4;++i)
    		{
    			for(int j=1;j<=4;++j)
    			{
    				b[i][j]=a[i][j];
				}
			}
		}
		else
		{
			if(check_ans()) ans++;
		}
		return ;
	}
	for(int i=1;i<=4;++i)
	{
		for(int j=1;j<=4;++j)
		{
			if(!a[i][j])
			{
				for(int k=1;k<=n;++k)
				{
					if(!vis[k]&&judge(i,j,k))  //回溯 
					{
						vis[k]=1;
						puts(i,j,k);
						ok-=p[k].sum;
						dfs(ok);
						ok+=p[k].sum;
						paste(i,j,k);
						vis[k]=0;
					}
				}
			}
		}
	}
}



int main()
{
    freopen("q.in","r",stdin);  //防复制粘贴 
    freopen("q.out","w",stdout); 
    while(scanf("%d",&n)!=EOF)
    {
        ans=0; cnt=0;
        memset(a,0,sizeof(a));memset(b,0,sizeof(b));memset(p,0,sizeof(p));  //记得清空 
        int sum1=0,sum2=0;
        for(int k=1;k<=n;++k)
        {
            int r=read(),c=read();
            p[k].r=r;p[k].c=c;
            for(int i=1;i<=r;++i)
            {
                string s;
                cin>>s;
                for(int j=1;j<=c;++j)
                {
                    p[k].ma[i][j]=s[j-1]-'0';
                    if(s[j-1]-'0'==1) p[k].sum++,sum1++;
                }
            }
        }
        if(sum1<16) printf("No solution\n");
        memset(vis,0,sizeof(vis));
        dfs(16);
        if(ans==0) printf("No solution\n");
        else if(ans==1)
        {
            printf("Yes, only one!\n");
            for(int i=1;i<=4;++i)
            {
                for(int j=1;j<=4;++j)
                {
                    printf("%d",b[i][j]);
                }
                printf("\n");
            }
        }
        else if(ans>=2) printf("Yes, many!\n"); 
    }
    return 0;
}
```


---

## 作者：EityDawn (赞：1)

## 思路
搜索！！！

步骤：

- 判断是否能放进去。

- 放进去。

- 回溯时删掉。

- 到达目标记录答案。

直接上 code：

```cpp
#include<iostream>
#include<cmath>
#include<cstring>
using namespace std;
const int N=30;
const int a=4;
char use[N][N][N];
int ma[N][N];
int ans[N][N];
int n;
int len[N],wid[N];
int cnt=0;
bool canput(int x,int y,int id)//可不可以放
{
	if(x+wid[id]-1>4||y+len[id]-1>4) return false;//超出边界，肯定放不了
	for(int i=x;i<=x+wid[id]-1;i++)
		for(int j=y;j<=y+len[id]-1;j++)
			if(ma[i][j]!=0&&use[id][i-x+1][j-y+1]!='0') return false;
        //与之前放的有冲突，不行
	return true;
} 
void fill(int x,int y,int id)//放进去
{
	for(int i=x;i<=x+wid[id]-1;i++)
		for(int j=y;j<=y+len[id]-1;j++)
			if((use[id][i-x+1][j-y+1]!='0')) ma[i][j]=id;
	return;
}
void erase(int x,int y,int id)//擦掉
{
	for(int i=x;i<=x+wid[id]-1;i++)
		for(int j=y;j<=y+len[id]-1;j++)
			if((use[id][i-x+1][j-y+1]!='0')) ma[i][j]=0;
	return;
} 
void dfs(int step)
{
	if(step==n+1){
	    for(int i=1;i<=a;i++)
	        for(int j=1;j<=a;j++)
	            if(!ma[i][j]) return;//没放满，不行
		++cnt;//记录个数
		for(int i=1;i<=a;i++)
			for(int j=1;j<=a;j++)
				ans[i][j]=ma[i][j];//更新答案
		return;
	}
	for(int i=1;i<=a;i++)
	{
		for(int j=1;j<=a;j++)
			if(canput(i,j,step))
			{
				fill(i,j,step);
				dfs(step+1);
				if(cnt>1) return;//很重要的优化
                //有 1 个以上的答案直接退出
				erase(i,j,step);
			} 	
	}
	return;
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	while(cin>>n)
	{
 		memset(ma,0,sizeof(ma));
 		memset(ans,0,sizeof(ans))
     //OIers 都知道，多测要清空
		cnt=0;
		int p=0;
		for(int i=1;i<=n;i++)
		{
			cin>>wid[i]>>len[i];
			for(int k=1;k<=wid[i];k++)
				cin>>use[i][k]+1;
		}
		dfs(1);
		if(!cnt){
			cout<<"No solution\n";
		}
		else {
			if(cnt>1){
				cout<<"Yes, many!\n";
			}
			else {
				cout<<"Yes, only one!\n";
				for(int i=1;i<=a;cout<<'\n',i++)
					for(int j=1;j<=a;j++) cout<<ans[i][j];
			}
		}
	}
	
	return 0;
}
```
然后呢？就 AC 啦！

---

## 作者：2c_s (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P3969)

## 思路

一道挺好的 dfs 模拟题。

读入一组数据后进行深搜，每次找一个**还没放在图上且有地方放进图**的拼图，并把它放入图中，计数器 $+1$。之后标记它已经用过并进行回溯搜索（也就是记得再把它从图中拿出）。

如果计数器 $=n$，也就是所有的拼图都放进去了，就判断这种情况是否拼成过了。如果没拼过就让答案数 $+1$，**记录**下这种情况。

全部的搜索完成之后统计答案数。

- 答案数为 $1$，输出 ``Yes, only one!`` 并输出这个唯一答案。

- 答案数为 $0$，输出 ``No solution``。

- 答案数为 $2$ 及以上，输出 ``Yes, many!``。

### 难点

本题的难点在于判断当前这块拼图能否放入图中。

我们可以采用大图 $2$ 重循环 $+$ 拼图 $2$ 重循环的判断方法，找到这块拼图能放入大图的什么位置。如果大图的这个位置和拼图的这个位置**都有值**（也就是若干拼图重合）的时候，跳出循环。

注意四重循环的两组参数**不一样**，一组是绝对坐标参数，一组是相对坐标参数，需要用绝对值较大的值 $-$ 绝对值较小的值 $+1$ 的这个公式，把绝对坐标转化为相对坐标，再进行计算。

#### 部分代码

```cpp
inline bool check(node k,int id){
	for(int i=1;i<=4;++i){
		for(int j=1;j<=4;++j){
			bool flag=1;
			for(int x=1;x<=k.r;++x){
				if(x+i-1>4){//纵坐标越界，拼不上。
					flag=0;
					break;
				}
				for(int y=1;y<=k.c;++y){
					if(y+j-1>4){//横坐标越界，拼不上。
						flag=0;
						break;
					}
					if(g[i+x-1][j+y-1]!=0&&k.mp[x][y]==1){//拼图重合，拼不上。
						flag=0;
						break;
					}
				}
				if(!flag)break;
			}
			if(flag){//如果能拼上就拼。
				for(int x=1;x<=k.r;++x){
					for(int y=1;y<=k.c;++y){
						if(!g[i+x-1][j+y-1]&&k.mp[x][y])g[i+x-1][y+j-1]=id;
                //把不重合的地方染色。
					}
				}
				return 1;//可以拼。
			}
		}
	}
	return 0;//循环完都没找到能拼的地方，就说明不能拼。
}
```

### 剪枝技巧

- 当**已经找到了 $2$ 种答案**，后面的搜索就不用进行了（因为没有要求输出答案数），直接 ``return`` 即可。

- 当**计数器 $=n$** 后，后面的搜索就不用进行了（因为没有剩余的拼图了），直接 ``return`` 即可。

### 注意事项

- 有多组测试数据且没有给定具体数量，需要用到 ``scanf("%d",&n)!=EOF`` 判断接下来还有没有数据读入。

- 多测记得清空数组及变量。

## AC 代码

```cpp
#include<bits/stdc++.h>//万能头省心。
#define ll long long
#define ull unsigned long long
#define pb push_back
#define pf push_front
#define pob pop_back
#define pof pop_front
#define pii pair<int,int>
#define pli pair<ll,int>
#define pll pair<ll,ll>
#define pil pair<int,ll>
#define fi first
#define se second
using namespace std;
inline ll read(){//快读。
	ll k=0,flag=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-')flag=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		k=(k<<1)+(k<<3)+(c^48);
		c=getchar();
	}
	return k*flag;
}
inline void print(ll x){//快写。
    if(x<0){
        putchar('-');
        x=-x;
    }
    ll y=10,len=1;
    while(y<=x){
        y=(y<<1)+(y<<3);
        len++;
    }
    while(len--){
        y/=10;
        putchar(x/y+48);
        x%=y;
    }
}
inline char readc(){//字符快读。
	char c=getchar();
	while(c=='\n'||c==' ')c=getchar();
	return c;
}
const int N=20;
int n,g[N][N],cnt,ans,res[N][N];
map<string,bool>tom;
struct node{
	int r,c,mp[N][N];
   //r 是拼图的宽。
   //c 是拼图的长。
   //mp 记录拼图的形状。
	bool use;//是否被拼过。
}a[N];
/*
tom 记录不同方案；
g 记录当前图的状态；
cnt 是上文提到的计数器；
ans 记录方案总数；
res 记录唯一方案。
*/
inline bool check(node k,int id){//判断能否放入大图及修改大图。
	for(int i=1;i<=4;++i){
		for(int j=1;j<=4;++j){
			bool flag=1;
			for(int x=1;x<=k.r;++x){
				if(x+i-1>4){
					flag=0;
					break;
				}
				for(int y=1;y<=k.c;++y){
					if(y+j-1>4){
						flag=0;
						break;
					}
					if(g[i+x-1][j+y-1]!=0&&k.mp[x][y]==1){
						flag=0;
						break;
					}
				}
				if(!flag)break;
			}
			if(flag){
				for(int x=1;x<=k.r;++x){
					for(int y=1;y<=k.c;++y){
						if(!g[i+x-1][j+y-1]&&k.mp[x][y])g[i+x-1][y+j-1]=id;
					}
				}
				return 1;
			}
		}
	}
	return 0;
}
inline void del(int id){//删除图中的这块拼图。
	for(int i=1;i<=4;++i){
		for(int j=1;j<=4;++j){
			if(g[i][j]==id)g[i][j]=0;
		}
	}
}
inline string change(){//把数组转化为 string 类型存储。
	string s="";
	for(int i=1;i<=4;++i){
		for(int j=1;j<=4;++j){
			s+=(char)g[i][j];
		}
	}
	return s;
}
inline void dfs(){//搜索。
	if(ans>=2)return ;//剪枝 1。
	if(cnt==n){//如果拼图拼完了。
		string s=change();
		if(!tom[s])++ans;//没记录过就记录。
		tom[s]=1;
		if(ans==1){
			for(int i=1;i<=4;++i){
				for(int j=1;j<=4;++j)res[i][j]=g[i][j];//存图。
			}
		}
		return ;//剪枝 2。
	}
	for(int i=1;i<=n;++i){
		if(a[i].use)continue;//在图上就不能用了。
		if(check(a[i],i)){//可以拼就继续搜。
			a[i].use=1;
			cnt++;
			dfs();
			a[i].use=0;//回溯。
			cnt--;
			del(i);
		}
	}
}
inline void clean(){//清空变量。
	ans=0,cnt=0;
	memset(res,0,sizeof res);
	memset(g,0,sizeof g);
	tom.clear();
}
int main(){
	while(scanf("%d",&n)!=EOF){//读入。
		for(int k=1;k<=n;++k){
			a[k].r=read(),a[k].c=read();
			for(int i=1;i<=a[k].r;++i){
				for(int j=1;j<=a[k].c;++j)a[k].mp[i][j]=readc()-'0';
			}
		}
		clean();
		dfs();
		if(!ans)puts("No solution");//答案数为 0。
		else if(ans==1){//答案数为 1。
			puts("Yes, only one!");
			for(int i=1;i<=4;++i){
				for(int j=1;j<=4;++j)print(res[i][j]);
				putchar('\n');
			}
		}
		else puts("Yes, many!");//答案数为 2 及以上。
	}
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/123678695)

---

## 作者：Thunder_S (赞：1)

## Solution

因为最后只需要拼成 $4\times 4$ 的正方形，说明拼图片数最大只有 16，因此可以直接暴力。

用结构体记录好每片拼图的构成，然后对于每片拼图，遍历左上角放的位置，判断能否放置，如果能放就放。最后判断这个正方形是否被填满。

具体的判断过程：枚举这块拼图的每一个位置，如果所有是 1 的位置，在原图中为 0，就说明当前这个块可以放在这个位置。

一点点小的优化：因为当结果超过 1 时，不要求总方案数，因此当我们得到两种方案后，就可以直接结束递归了。

当然这题也是可以用状压的。

## Code

```cpp
#include<cstdio>
#define N 20
using namespace std;
struct node
{
    int r,c,p[5][5];
}a[N];
int n,ansnum,ans[5][5],d[5][5];
bool flag;
char s[5];
bool ful()
{
    for (int i=1;i<=4;++i)
        for (int j=1;j<=4;++j)
            if (!d[i][j]) return false;
    return true;
}
bool check(int x,int y,int id)
{
    for (int i=1;i<=a[id].r;++i)
        for (int j=1;j<=a[id].c;++j)
        {
            if (!a[id].p[i][j]) continue;
            if (x+i-1>4) return false;
            if (y+j-1>4) return false;
            if (d[x+i-1][y+j-1]) return false;
        }
    return true;
}
void setin(int x,int y,int id,int num)
{
    for (int i=1;i<=a[id].r;++i)
        for (int j=1;j<=a[id].c;++j)
        {
            if (!a[id].p[i][j]) continue;
            d[x+i-1][y+j-1]=num;
        }
}
void dfs(int x)
{
    if (flag) return;
    bool k=ful();
    if (k||x>n)
    {
        if (k)
        {
            if (ansnum)
            {
                ++ansnum;
                flag=true;
            }
            else
            {
                ansnum=1;
                for (int i=1;i<=4;++i)
                    for (int j=1;j<=4;++j)
                        ans[i][j]=d[i][j];
            }
        }
        return;
    }
    for (int i=1;i<=4;++i)
        for (int j=1;j<=4;++j)
        {
            if (check(i,j,x))
            {
                setin(i,j,x,x);
                dfs(x+1);
                setin(i,j,x,0);
            }
        }
    dfs(x+1);
}
int main()
{
    freopen("puzzle.in","r",stdin);
    freopen("puzzle.out","w",stdout);
    while (scanf("%d",&n)!=EOF)
    {
        for (int i=1;i<=n;++i)
        {
            scanf("%d%d",&a[i].r,&a[i].c);
            for (int j=1;j<=a[i].r;++j)
            {
                scanf("%s",s+1);
                for (int k=1;k<=a[i].c;++k)
                    a[i].p[j][k]=s[k]-'0';
            }
        }
        ansnum=0;
        flag=false;
        for (int i=1;i<=4;++i)
            for (int j=1;j<=4;++j)
                ans[i][j]=d[i][j]=0;
        dfs(1);
        if (ansnum==0) printf("No solution\n");
        else if (ansnum>=2) printf("Yes, many!\n");
        else
        {
            printf("Yes, only one!\n");
            for (int i=1;i<=4;++i)
            {
                for (int j=1;j<=4;++j)
                    printf("%d",ans[i][j]);
                printf("\n");
            }
        }
    }
    return 0;
}
```



---

## 作者：wwwwwza (赞：1)

这道题就是**深搜加剪枝**，再用一点点**暴力枚举**，非常适合练手。虽然是一道蓝题，但想到了思路就很简单。    
### 思路：  

1、输入数据，使用结构体内套字符数组的方式输入每一块拼图的基础信息，因为题目说了一定要拼成边长为四的正方形，所以不用特判拼成正方形拼图的边长，注意看清数据范围，小心爆空间。  
2、深搜遍历，可以枚举每一块拼图的左上角的顶点，使用 $paint$ 函数判断在每个点放某块拼图的左上角顶点可不可行。如果可行，继续向下遍历。  
3、终止深搜，当搜索到第 $n+1$ 块拼图时，意味着终止搜索，遍历存储拼图的数组，如果有一格没被遍历，那么这个拼图就不成立。  
4、回溯遍历，使用 $white$ 函数清空该块拼图，然后继续遍历。  
5、输出答案，若存储答案的变量 $cnt$ 等于零，表示没有答案。若 $cnt$ 等于一，表示只有一种答案，再输出唯一的拼图放法。若 $cnt$ 大于等于二，表示有多种答案（其实可以在深搜遍历时判断 $cnt$ 是否大于等于二，如果成立，就退出深搜）。

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
using namespace std;
const int N=1e3+10;
int n,sum=0,p[N][N],anss[N][N],k,cnt=0;
bool ans;
char c[N][N];
struct node{
	int x,y;
	char ch[N][N];
}a[20];
bool paint(int x,int y,int dep){//放入拼图 
	for(int i=x+1;i<=x+a[dep].x;i++){
		for(int j=y+1;j<=y+a[dep].y;j++){
			if(p[i][j]!=0&&a[dep].ch[i-x][j-y]=='1')return false;
			else if(p[i][j]==0&&a[dep].ch[i-x][j-y]=='1')p[i][j]=dep;
		}
	}
	return true;
}
void white(int x,int y,int dep){//拿出拼图 
	for(int i=x+1;i<=x+a[dep].x;i++){
		for(int j=y+1;j<=y+a[dep].y;j++){
			if(p[i][j]==dep)p[i][j]=0;
		}
	}
}
void dfs(int dep){//深搜 
	if(cnt==2)return;//剪枝 
	if(dep==n){
		for(int i=1;i<=k;i++){
			for(int j=1;j<=k;j++){
				if(p[i][j]==0){
					return;
				}
			}
		}
		cnt++;
		for(int i=1;i<=k;i++){//存储答案 
			for(int j=1;j<=k;j++){
				anss[i][j]=p[i][j];
			}
		}
		return;
	}
	dep++;
	for(int i=0;i<=k-a[dep].x;i++){//枚举每块拼图 
		for(int j=0;j<=k-a[dep].y;j++){
			if(paint(i,j,dep))dfs(dep);
			white(i,j,dep);
		}
	}
	return;
}
signed main(){
	while(scanf("%d",&n)!=EOF){
		sum=0;cnt=0;//一定要初始化 
		memset(p,0,sizeof(p));
		for(int i=1;i<=n;i++){//输入 
			cin >>a[i].x>>a[i].y; 
			for(int j=1;j<=a[i].x;j++){
				for(int k=1;k<=a[i].y;k++){
					cin >>a[i].ch[j][k];
				}
			}
		}
		k=4;//正方形的边长 
		dfs(0);
		if(cnt==0){//输出 
			cout <<"No solution"<<endl;
		}else if(cnt==1){
			cout <<"Yes, only one!"<<endl;
			for(int i=1;i<=k;i++){
				for(int j=1;j<=k;j++)cout <<anss[i][j];
				cout <<endl;
			}
		}else{
			cout <<"Yes, many!"<<endl;
		}
	}
	return 0;
}
```

---

## 作者：Hamburger999 (赞：0)

#### 前置芝士：

------------

* 搜索
* 剪枝


------------

考虑把碎片一个一个放进去。

每次放时选择枚举满足 $i\leq4-R_i+1,j\leq4-C_i+1$ 的点对 $(i,j)$ 作为拼图左上角的坐标，检验是否能把拼图放进去，当碎片被用完时，先检验是否符合条件（拼图已被拼满，无重复），则 $ans \leftarrow ans+1$。

**剪枝**：当 $ans=2$ 时直接返回并输出`Yes, many!`。

**注意**：
+ 可能搜到相同的答案（所以要去重）。
+ 代码千万条，读题第一条。多测不清空，爆零两行泪。

代码如下：
------------
```cpp
#include<iostream>
#include<cstring>
using namespace std;

struct puzzle{
	int r,c;
	char f[10][10];
}puz[17];
int h[6][6],ans,n,res[6][6];
bool cheak(puzzle a,int r,int c){//检查是否能放置 
	for(int i=1;i<=a.r;i++){
		for(int j=1;j<=a.c;j++){
			if(a.f[i][j]=='1'&&h[i+r-1][j+c-1])return 0;
		}
	}
	return 1;
}

void push_in(puzzle a,int n,int r,int c){//放置拼图 
	for(int i=1;i<=a.r;i++){
		for(int j=1;j<=a.c;j++){
			if(a.f[i][j]=='1'){h[i+r-1][j+c-1]=n;}
		}
	}
}

void pop_out(puzzle a,int r,int c){//拿出拼图 
	for(int i=1;i<=a.r;i++){
		for(int j=1;j<=a.c;j++){
			if(a.f[i][j]=='1')h[i+r-1][j+c-1]=0;
		}
	}
}

void print(){//打印 
	for(int i=1;i<=4;i++){
		for(int j=1;j<=4;j++){
			cout<<res[i][j];
		}
		cout<<endl;
	}
}

void dfs(int k){//搜索  
	if(ans==2)return;//答案超过了就返回 
	if(k>n){
		for(int i=1;i<=4;i++){//检查盘面是否填满(好像没用,去掉也能AC)
			for(int j=1;j<=4;j++){
				if(h[i][j]==0)return;
			}
		}
		bool flag=0;//检测是否与当前答案相同 
		for(int i=1;i<=4;i++){
			for(int j=1;j<=4;j++){
				if(h[i][j]!=res[i][j])flag=1;
			}
		}
		if(flag){
			ans++;
			for(int i=1;i<=4;i++){
				for(int j=1;j<=4;j++){
					res[i][j]=h[i][j];
				}
			}
		}
		return;
	}
	for(int i=1;i<=4-puz[k].r+1;i++){//逐一放置 
		for(int j=1;j<=4-puz[k].c+1;j++){
			if(cheak(puz[k],i,j)){
				push_in(puz[k],k,i,j);
				dfs(k+1);
				pop_out(puz[k],i,j);
			}
		}
	}
}

int main(){//主程序 
	while(cin>>n){
		memset(h,0,sizeof(h));
		memset(res,0,sizeof(res));
		ans=0;
		for(int i=1;i<=n;i++){
			cin>>puz[i].r>>puz[i].c;
			for(int j=1;j<=puz[i].r;j++){
				for(int k=1;k<=puz[i].c;k++){
					cin>>puz[i].f[j][k];
				}
			}
		}
		dfs(1);
		if(ans==1){
			cout<<"Yes, only one!"<<endl;
			print();
		}
		else if(ans>=2)cout<<"Yes, many!"<<endl;
		else cout<<"No solution"<<endl;
	}
   return 0;
}
```

---

## 作者：qinmingze (赞：0)

### [题目传送门](https://www.luogu.com.cn/problem/P3969)

### 思路

看完题目，我们肯定不难想到这题需要用搜索实现。

因为 $N \le 16$，所以在搜索函数中，我们只需要对每一个拼图放置的位置进行枚举即可，同时记录当前放入的拼图的个数。

#### 难点

- 对于图形的存储，可以使用一个三维数组，将每个图的信息都记录在数组中。

- 注意**对坐标的转换**，因为当前的放置坐标和三维数组中图的坐标是**不同**的，因此需要对坐标进行转换。

#### 注意

- 在搜索的过程中，如果当前**记录可行方案的个数的变量已经等于 $2$ 了**，那么就可以**直接输出** ``Yes, many!`` 就可以了。

- 当图中已经放了 $n$ 块拼图时，就不用再搜索了，因为所有的拼图都放置好了。

### 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

const int N = 10;

int ans = 0, n;

int x[N * 2], y[N * 2], ans_mp[N][N];

int mp[N * 2][N][N];//存储地图信息。

bool vis[N * 2], flag = false;

int mp_vis[N * 2][N * 2];

void fill(){
	for(int i = 1; i <= 4; i++){
		for(int j = 1; j <= 4; j++){
			ans_mp[i][j] = mp_vis[i][j];//填充答案。
		}
	}
	return ;
}

void print(){//输出答案。
	for(int i = 1; i <= 4; i++){
		for(int j = 1; j <= 4; j++){
			cout << ans_mp[i][j];
		}
		cout << endl;
	}
	return ;
}

bool in(int x, int y){return x >= 1 && x <= 4 && y >= 1 && y <= 4;}//是否在图内。

bool check(int sx, int sy, int k){//检查是否能放置。
	for(int i = sx; i <= sx + x[k] - 1; i++){
		for(int j = sy; j <= sy + y[k] - 1; j++){
		    if(!in(i, j))return false;
		    if(!mp[k][i - sx + 1][j - sy + 1])continue;
			if(mp_vis[i][j])return false;
		}
	}
	return true;
}

void put(int sx, int sy, int k){//放置。
	for(int i = sx; i <= sx + x[k] - 1; i++){
		for(int j = sy; j <= sy + y[k] - 1; j++){
			if(!mp[k][i - sx + 1][j - sy + 1])continue;
			mp_vis[i][j] = k;
		}
	}
	return ;
}

void afterput(int sx, int sy, int k){//回溯。
	for(int i = sx; i <= sx + x[k] - 1; i++){
		for(int j = sy; j <= sy + y[k] - 1; j++){
			if(!mp[k][i - sx + 1][j - sy + 1])continue;
			mp_vis[i][j] = 0;
		}
	}
	return ;
}

void dfs(int k){
	if(flag)return ;
	if(k == n + 1){
		ans++;
		if(ans == 2)flag = true;
		fill();
		return ;
	}
	if(!vis[k]){//没有用过。
		for(int i = 1; i <= 4; i++){
			for(int j = 1; j <= 4; j++){
				if(check(i, j, k)){//是否可以放置。
					put(i, j, k);//放置。
					vis[k] = true;//使用过了。
					dfs(k + 1);
					afterput(i, j, k);//回溯。
					vis[k] = false;
			    }
			}
		}
	}
}

int main(){
	while(cin >> n){
		int cnt = 0;
		for(int k = 1; k <= n; k++){
			int r, c;
			cin >> r >> c;
			x[k] = r; y[k] = c;//当前拼图的大小。
			for(int i = 1; i <= r; i++){
				for(int j = 1; j <= c; j++){
					char c;
					cin >> c;
					mp[k][i][j] = c - '0';
					if(mp[k][i][j])cnt++;
					//cout << mp[k][i][j];
				}
			}
		}
		//cout << cnt << endl;
		if(cnt != 16){
			puts("No solution");
			continue;
		}
		flag = false;
		ans = 0;
		memset(vis, 0, sizeof vis);
		memset(mp_vis, 0, sizeof mp_vis);
		dfs(1);
		if(ans >= 2)puts("Yes, many!");//多个答案。
		else if(ans == 1){//一种方式。
			puts("Yes, only one!");
			print();
		}else puts("No solution");//没有。
	}
}
```

---

## 作者：Redshift_Shine (赞：0)

# [[TJOI2014](https://www.luogu.com.cn/problem/P3969)] 拼图

目前最优解作者来发一篇题解。

注意到拼图的大小只有 $4\times 4$ ，考虑使用位运算优化搜索过程。

在这种情况下，每个形状的拼图都可以用一个唯一的长度不超过 $16$ 的二进制串表示。具体表示方式见代码。

此外，注意到在无解或多解情况下不需要输出详细拼图方法，所以我们只需要在有多解的情况下直接退出搜索过程即可。

代码如下。

```c++
#include<iostream>
#include<cstring>
using namespace std;
using ll=int;
const int N=1e2+10;
const ll ret=(1<<16)-1;
int n,tn[N],tm[N];
ll msk[N];
int res[N][N],tres[N][N];
bool tag,mtag;
inline int mp(int x,int y){
    return (x<<2)|y;
}
void dfs(int id,ll tmsk){
    if(id==n){
        if(tmsk!=ret)return;
        if(tag){
            mtag=true;
            return;
        }
        memcpy(tres,res,sizeof res);
        tag=true;
        return;
    }
    for(int i=0;i<=4-tn[id];i++){
        for(int j=0;j<=4-tm[id];j++){
            if(tmsk&(msk[id]<<mp(i,j)))continue;
            for(int k=0;k<tn[id];k++){
                for(int l=0;l<tm[id];l++){
                    if((msk[id]>>mp(k,l))&1)
                        res[i+k][j+l]=id+1;
                }
            }
            dfs(id+1,tmsk|(msk[id]<<mp(i,j)));
            if(mtag)return;
        }
    }
}
void run(){
    tag=mtag=false;
    for(int ti=0;ti<n;ti++){
        scanf("%d%d",tn+ti,tm+ti);
        msk[ti]=0;
        for(int i=0;i<tn[ti];i++){
            for(int j=0,k;j<tm[ti];j++){
                scanf("%1d",&k);
                if(!k)continue;
                msk[ti]|=(1<<mp(i,j));
            }
        }
        // printf("%lld\n",msk[ti]);
    }
    dfs(0,0);
    if(mtag){
        puts("Yes, many!");
        return;
    }
    if(!tag){
        puts("No solution");
        return;
    }
    puts("Yes, only one!");
    for(int i=0;i^4;i++){
        for(int j=0;j^4;j++){
            printf("%d",tres[i][j]);
        }
        puts("");
    }
}
int main(){
    while(~scanf("%d",&n))run();
}
```

---

## 作者：RyanCh (赞：0)

这道题题意很清晰，这里不做赘述。

观察数据，我们可以发现可以用深度优先搜索这一算法来解决这道问题。

我们要解决如下集中操作：

- 覆盖
- 删除
- 查看是否填满
- 统计答案
- 检查是否填满

凭借以上集中操作，我们可以轻松的去进行搜索。

核心代码如下：

```cpp
void dfs(int id, int x, int y) {
    if(id > n) return ;
    put(id, x, y);
    if(!check(id) || cnt > 1) { del(id, x, y); return ; }
    if(full()) { cover(); cnt++; del(id, x, y); return ; }
    for(int x = 1; x <= 4; x++)
    for(int y = 1; y <= 4; y++)
        dfs(id + 1, x, y);
    del(id, x, y);
}
```

注意几点易犯错误：

- 覆盖时要检查是否会有出界
- 搜索时按位搜索，避免重复记录
- 输出为拼图的编号

注意以上几点其实代码写起来很容易。

如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 20;
int n, r[N], c[N], mp[N][5][5], ret[N][N], ans[N][N], id[N][N], cnt, maxn, sum[N];
bool vis[N];
bool check(int now) {
	int cnt = 0;
	for(int i = 1; i <= 4; i++)
	for(int j = 1; j <= 4; j++)
	if(ret[i][j] >= 2) return 0;
	else cnt += ret[i][j];
	if(cnt != sum[now]) return 0;
	return 1;
}
bool full() {
	for(int i = 1; i <= 4; i++)
	for(int j = 1; j <= 4; j++)
	if(ret[i][j] == 0) return 0;
	return 1;
}
void cover() {
	for(int i = 1; i <= 4; i++)
	for(int j = 1; j <= 4; j++)
	ans[i][j] = id[i][j];
	return ;
}
void put(int t, int x, int y) {
	for(int i = 1; i <= r[t]; i++)
	for(int j = 1; j <= c[t]; j++) {
	if(i + x - 1 > 4) return ;
	if(j + y - 1 > 4) return ;
	ret[i + x - 1][j + y - 1] += mp[t][i][j];
	if(mp[t][i][j] == 1) id[i + x - 1][j + y - 1] += t;
	}
}
void del(int t, int x, int y) {
	for(int i = 1; i <= r[t]; i++)
	for(int j = 1; j <= c[t]; j++) {
	if(i + x - 1 > 4) return ;
	if(j + y - 1 > 4) return ;
	ret[i + x - 1][j + y - 1] -= mp[t][i][j];
	if(mp[t][i][j] == 1) id[i + x - 1][j + y - 1] -= t;
	}
}
void print() {
	for(int i = 1; i <= 4; i++, printf("\n"))
	for(int j = 1; j <= 4; j++, printf(" "))
	printf("%d", ret[i][j]);
}
void dfs(int id, int x, int y) {
	if(id > n) return ;
	put(id, x, y);
//	print();
	if(!check(id) || cnt > 1) { del(id, x, y); return ; }
	if(full()) { cover(); cnt++; del(id, x, y); return ; }
	for(int x = 1; x <= 4; x++)
	for(int y = 1; y <= 4; y++)
		dfs(id + 1, x, y);
	del(id, x, y);
}
int main() {
	while(~scanf("%d", &n)) {
		maxn = cnt = 0;
		for(int i = 1; i <= n; i++) {
			scanf("%d %d", &r[i], &c[i]);
			for(int j = 1; j <= r[i]; j++)
				for(int k = 1; k <= c[i]; k++) {
					char y; cin >> y;
					mp[i][j][k] = (y == '1');
					maxn += (y == '1');
				}
			sum[i] = maxn;
		}
//		if(maxn != 16) { printf("No solution\n"); continue; }
		for(int x = 1; x <= 4; x++)
			for(int y = 1; y <= 4; y++) 
				dfs(1, x, y);
		if(cnt == 0) printf("No solution\n");
		if(cnt == 1) {
			printf("Yes, only one!\n");
			for(int i = 1; i <= 4; i++, printf("\n"))
			for(int j = 1; j <= 4; j++)
			printf("%d", ans[i][j]);
		}
		if(cnt > 1) printf("Yes, many!\n");
	}
	return 0;
}
```


---

## 作者：Milthm (赞：0)

## P3969 题解

### 前置知识

- 搜索

- 剪枝

### 题目解法

拿到题目，发现整个格子只有 $4\times4$ 的大小，果断选择我们的深搜。

深搜流程大概是这样的：

- 每次搜索，枚举 $4\times4$ 的每一个位置。

- 对于每次循环，判断所有拼图。如果该拼图未被使用过，且可以以此处为左上角放下该拼图，那么把这里放下这个拼图，并打上标记。

- 回溯，把拼图再拿出来。

然后直接爆搜容易超时，考虑剪枝。如果当前答案数量已经是 $2$ 了，那就不用再搜下去了，直接返回就行了。

还有个坑点，答案有可能搜重复，还要与上一次的答案进行比对，去重。

然后就没有什么难的了，具体看代码。

### AC 代码

```cpp
#include<iostream>
using namespace std;
int t,n[20],m[20],ans,vis[20];
char a[20][20][20],b[20][20],cnt[20][20];
void dfs(){
    if(ans==2)return;//剪枝
    int f=1;
    for(int i=1;i<=4;++i){//判断是不是满了
        for(int j=1;j<=4;++j){
            if(b[i][j]=='0')f=0;
        }
    }
    if(f){
        f=0;
        for(int i=1;i<=4;++i){
            for(int j=1;j<=4;++j){
                if(cnt[i][j]!=b[i][j])f=1;
            }
        }
        if(!f)return;//判断是否重复
        ++ans;//答案加一
        for(int i=1;i<=4;++i){
            for(int j=1;j<=4;++j){
                cnt[i][j]=b[i][j];//更新答案数组
            }
        }
        return;//记得返回
    }
    for(int x=1;x<=4;++x){
        for(int y=1;y<=4;++y){
            for(int i=1;i<=t;++i){
                if(x+n[i]-1>4||y+m[i]-1>4||vis[i])continue;
                for(int j=1;j<=n[i];++j){
                    for(int k=1;k<=m[i];++k){
                        if(a[i][j][k]=='1'&&b[x+j-1][y+k-1]!='0')goto R;//如果放不了就不要放
                    }
                }
                for(int j=1;j<=n[i];++j){
                    for(int k=1;k<=m[i];++k){
                        if(a[i][j][k]=='1')b[x+j-1][y+k-1]=i+'0';//放得下就放上
                    }
                }
                vis[i]=1;//标记
                dfs();
                vis[i]=0;//回溯
                for(int j=1;j<=n[i];++j){
                    for(int k=1;k<=m[i];++k){
                        if(a[i][j][k]=='1')b[x+j-1][y+k-1]='0';//把图案再拿出来
                    }
                }
                R:;
            }
        }
    }
}
int main(){
    while(cin>>t){
        ans=0;
        for(int i=1;i<=4;++i){
            for(int j=1;j<=4;++j){
                cnt[i][j]=b[i][j]='0';//多测要清空
            }
        }
        for(int i=1;i<=t;++i){
            vis[i]=0;
            cin>>n[i]>>m[i];
            for(int j=1;j<=n[i];++j){
                for(int k=1;k<=m[i];++k){
                    cin>>a[i][j][k];
                }
            }
        }
        dfs();
        if(ans==0){
            cout<<"No solution\n";
        }
        else if(ans==1){
            cout<<"Yes, only one!\n";
            for(int i=1;i<=4;++i){
                for(int j=1;j<=4;++j){
                    cout<<cnt[i][j];
                }
                cout<<'\n';
            }
        }
        else cout<<"Yes, many!\n";
    }
    
    return 0;
}
```


---

## 作者：冷笑叹秋萧 (赞：0)

## 题意
给你 $n(n \le 16)$ 块拼图，拼图不可旋转，询问是否可以拼成一个 $4 \cdot 4$ 的拼图，并判断方案是否唯一。
## Solution
看到数据范围非常小，我们可以考虑直接使用搜索解决本题。

枚举每块拼图，再枚举当前有哪个位置可以放进这块拼图的，能放就放。枚举之前判断有没有拼满，如果搜到两种不同的拼满的方法就退出即可。

注意可能会搜到重复的拼法，要与当前存的答案进行对比去重。
## CODE
```cpp
#include<bits/stdc++.h>
#define N 20
using namespace std;
int r, c, a[N][5][5], pu[N][2], n, ans[5][5], f[5][5];
bool bz[N], flag1, flag2;
void dg() {
	if (flag2) return;//搜到两种方法直接退出
	bool flag = 1;
	for (int i = 1; i <= 4; ++i) {
		for (int j = 1; j <= 4; ++j)
			if (!f[i][j]) {
				flag = 0; break;
			}
		if (!flag) break;
	}//判断是否拼满
	if (flag) {
		if (!flag1) {
			for (int i = 1; i <= 4; ++i)
				for (int j = 1; j <= 4; ++j) ans[i][j] = f[i][j];
			flag1 = 1;
		}
		else {
			flag = 0;
			for (int i = 1; i <= 4; ++i) {
				for (int j = 1; j <= 4; ++j)
					if (f[i][j] != ans[i][j]) {
						flag = 1; break;
					}
				if (flag) break;
			} if (flag) flag2 = 1; //判断是否是重复的拼法
		}
		return;
	}
	for (int i = 1; i <= n; ++i)
		if (!bz[i]) {
			for (int j = 1; j <= 4; ++j)
				for (int k = 1; k <= 4; ++k) {
					if (j + pu[i][0] - 1 > 4 || k + pu[i][1] - 1 > 4) break;
					flag = 1;
					for (int x = 1; x <= pu[i][0]; ++x) {
						for (int y = 1; y <= pu[i][1]; ++y)
							if (f[j + x - 1][k + y - 1] && a[i][x][y]) {
								flag = 0; break;
							}
						if (!flag) break;
					}
					if (flag) {
						bz[i] = 1;
						for (int x = 1; x <= pu[i][0]; ++x)
							for (int y = 1; y <= pu[i][1]; ++y)
								if (!f[j + x - 1][k + y - 1])  f[j + x - 1][k + y - 1] = a[i][x][y] ? i : 0;
						dg(); bz[i] = 0;
						for (int x = 1; x <= pu[i][0]; ++x)
							for (int y = 1; y <= pu[i][1]; ++y)
								if (a[i][x][y]) f[j + x - 1][k + y - 1] = 0;
						if (flag2) return;//多加几个退的更快
					}
				} 
		}
}
int main() {
	freopen("puzzle.in", "r", stdin); freopen("puzzle.out", "w", stdout);
	while (scanf("%d", &n) != EOF) {
		memset(ans, 0, sizeof(ans)); memset(f, 0, sizeof(f));//别忘了初始化
		for (int i = 1; i <= n; ++i) {
			scanf("%d%d", &r, &c); pu[i][0] = r; pu[i][1] = c;
			for (int j = 1; j <= r; ++j) {
				char ch = getchar(); while (ch != '1' && ch != '0') ch = getchar();
				int k = 1; a[i][j][k] = ch - 48; ch = getchar();
				while (ch == '1' || ch == '0') a[i][j][++k] = ch - 48, ch = getchar();
			}
		}
		flag1 = flag2 = 0; dg();
		if (!flag1 && !flag2) printf("No solution\n");
		else if (flag1 && !flag2) {
			printf("Yes, only one!\n");
			for (int i = 1; i <= 4; ++i) { 
				for (int j = 1; j <= 4; ++j)
					printf("%d", ans[i][j]);
				printf("\n");
			}
		}
		else printf("Yes, many!\n");
	}
}
```


---

## 作者：miaokehao (赞：0)

看到矩阵的大小固定为4*4，随便打暴力，直接dfs，通过特判给定矩阵中1的数量来优化程序速度，复杂度O(能过)
```
#include <bits/stdc++.h>
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize(4)
#pragma GCC optimize("Ofast,no-stack-protector")
#define res register int
#define N 5
#define M 20
using namespace std;
int n,ans,r[M],c[M],a[M][N][N],sum[M],total,H[N][N],now[N][N];
bool used[M],pd;
inline int read()
{
  int X=0,w=0;
  char ch=0;
  while(!isdigit(ch))
  {
    w|=ch=='-';
    ch=getchar();
  }
  while(isdigit(ch)) X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
  return w?-X:X;
}
inline bool judge(int x,int y,int k)
{
  if(x+r[k]-1>4) return 0;
  if(y+c[k]-1>4) return 0;
  for(res i=x; i<=x+r[k]-1; i++)
    for(res j=y; j<=y+c[k]-1; j++)
      if(a[k][i-x+1][j-y+1]&&now[i][j])
        return 0;
  return 1;
}
inline void fill(int x,int y,int k)
{
  for(res i=x; i<=x+r[k]-1; i++)
    for(res j=y; j<=y+c[k]-1; j++)
      if(a[k][i-x+1][j-y+1])
        now[i][j]=k;
}
inline void unfill(int x,int y,int k)
{
  for(res i=x; i<=x+r[k]-1; i++)
    for(res j=y; j<=y+c[k]-1; j++)
      if(a[k][i-x+1][j-y+1])
        now[i][j]=0;
}
inline void print()
{
  for(res i=1; i<=4; i++,puts(""))
    for(res j=1; j<=4; j++)
      printf("%d",H[i][j]);
}
inline void dfs(int last)
{
  if(pd) return;
  if(!last)
  {
    if(!ans)
    {
      ans++;
      memcpy(H,now,sizeof(now));
      //print();
    }
    else
    {
      bool flag=0;
      for(res i=1; i<=4; i++)
      {
        for(res j=1; j<=4; j++)
          if(H[i][j]!=now[i][j])
          {
            flag=1;
            break;
          }
        if(flag) break;
      }
      if(flag) ans++,pd=1;
    }
    return ;
  }
  for(res i=1; i<=4; i++)
    for(res j=1; j<=4; j++)
      if(!now[i][j])
        for(res k=1; k<=n; k++)
          if(!used[k]&&judge(i,j,k))
          {
            used[k]=1;
            fill(i,j,k);
            dfs(last-sum[k]);
            used[k]=0;
            unfill(i,j,k);
          }
}
int main()
{
  while(scanf("%d",&n)!=EOF)
  {
    total=ans=pd=0;
    memset(sum,0,sizeof(sum));
    memset(H,0,sizeof(H));
    memset(used,0,sizeof(used));
    for(res i=1; i<=n; i++)
    {
      r[i]=read(),c[i]=read();
      for(res j=1; j<=r[i]; j++)
        for(res k=1; k<=c[i]; k++)
        {
          register char ch=getchar();
          while(ch!='0'&&ch!='1') ch=getchar();
          a[i][j][k]=ch-'0';
          if(a[i][j][k]) sum[i]++;
        }
      total+=sum[i];
    }
    if(total!=16)
    {
      puts("No solution");
      continue;
    }
    memset(now,0,sizeof(now));
    dfs(16);
    if(ans==1)
    {
      puts("Yes, only one!");
      print();
    }
    else if(ans>1)
      puts("Yes, many!");
    else
      puts("No solution");
  }
  return 0;
}
```
但是听说网上有更快的算法，dancing-link-x算法，专用于进行矩阵密填；

[dancing-link-X算法介绍](http://www.cnblogs.com/grenet/p/3145800.html)

[题解](https://blog.csdn.net/qq_35866453/article/details/65936890)


---


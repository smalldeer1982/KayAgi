# [SHOI2013] 发微博

## 题目描述

刚开通的 SH 微博共有 $n$ 个用户（$1\sim n$ 标号），在这短短一个月的时间内，用户们活动频繁，共有 $m$ 条按时间顺序的记录：

```plain
! x 表示用户 x 发了一条微博；
+ x y 表示用户 x 和用户 y 成为了好友
− x y 表示用户 x 和用户 y 解除了好友关系
```
当一个用户发微博的时候，所有他的好友（直接关系）都会看到他的消息。

假设最开始所有人之间都不是好友关系，记录也都是合法的（即 `+ x y` 时 $x$ 和 $y$ 一定不是好友，而 `− x y` 时 $x$ 和 $y$ 一定是好友）。

问这 $m$ 条记录发生之后，每个用户分别看到了多少条消息。


## 说明/提示

对于 $100\%$ 的数据，$n\leq 200000$, $m\leq 500000$

## 样例 #1

### 输入

```
2 8
! 1
! 2
+ 1 2
! 1
! 2
- 1 2
! 1
! 2```

### 输出

```
1 1```

# 题解

## 作者：午夜飘雪 (赞：24)

考虑一个用户x发微博的时候，他会对所有x当前的好友y产生一点答案贡献

于是从xy成为好友，一直到xy解除好友关系，x对y产生的总贡献一共是（解除好友关系时x的微博数-成为好友时x的微博数）

那么我们记录一个cnt[x]，表示到目前为止x共发了多少条微博

对于每个点建立一个set记录x的当前好友集合

每次加（减）点的同时，把ans[x]减去（加上）cnt[y]~~（有点像差分？）~~

但是因为只有在解除好友的时候贡献才会被完整统计，所以最后要手动解除所有人的好友关系，即遍历一遍每个人的set

时间复杂度O(mlogn)，具体实现见代码


```cpp
    #include<iostream>
    #include<cstdio>
    #include<set>
    using namespace std;
    const int N=200009;
    int n,m,cnt[N],ans[N];
    set<int>s[N];
    set<int>::iterator it;
    int main(){
        ios::sync_with_stdio(0);
        cin>>n>>m;
        for(int i=1;i<=m;++i){
            char opt;cin>>opt;
            if(opt=='!'){
                int x;cin>>x;
                ++cnt[x];
            }
            if(opt=='+'){
                int x,y;cin>>x>>y;
                ans[x]-=cnt[y];ans[y]-=cnt[x];
                s[x].insert(y);s[y].insert(x);
            }
            if(opt=='-'){
                int x,y;cin>>x>>y;
                ans[x]+=cnt[y];ans[y]+=cnt[x];
                s[x].erase(y);s[y].erase(x);
            }
        }
        for(int i=1;i<=n;++i)
        for(it=s[i].begin();it!=s[i].end();++it){
            ans[i]+=cnt[*it];
        }
        for(int i=1;i<=n;++i)cout<<ans[i]<<" ";
        return 0;
    }
```
------------

做完之后一想，总觉得这个set大材小用了，能不能不用啊

于是……开始考虑这个set到底起了什么作用

归根结底就是因为最后需要手动解除一遍所有人的好友关系，才需要用set来维护每个人的好友集合，这样可以知道每个人剩下的好友都是谁

那么能不能让他们到最后所有人都没有好友关系呢？

反着处理所有操作就可以啦，因为一开始所有人都没有好友关系

```cpp
    #include<iostream>
    #include<cstdio>
    using namespace std;
    const int N=200009,M=500009;
    int n,m,data[M][2],cnt[N],ans[N];
    char opt[M];
    int main(){
        ios::sync_with_stdio(0);
        cin>>n>>m;
        for(int i=1;i<=m;++i){
            cin>>opt[i];
            if(opt[i]=='!')cin>>data[i][0];
            if(opt[i]=='+')cin>>data[i][0]>>data[i][1];
            if(opt[i]=='-')cin>>data[i][0]>>data[i][1];
        }
        for(int i=m;i;--i){
            if(opt[i]=='!')++cnt[data[i][0]];
            if(opt[i]=='+'){
                ans[data[i][0]]+=cnt[data[i][1]];ans[data[i][1]]+=cnt[data[i][0]];
            }
            if(opt[i]=='-'){
                ans[data[i][0]]-=cnt[data[i][1]];ans[data[i][1]]-=cnt[data[i][0]];
            }
        }
        for(int i=1;i<=n;++i)cout<<ans[i]<<" ";
        return 0;
    }
```
这样只用O(m)就解决了问题
~~虽然mlogn就能过~~

[顺手安利一发博客](http://www.cnblogs.com/ck666/p/8039488.html)


---

## 作者：傅思维666 (赞：10)


## 题解：

~~2019双十模拟赛（蒟蒻正在文化课月考的考场上瑟瑟发抖）~~

后来7哥@littleseven带我做了这道题...

当时只想出了50分的暴力思路，非常容易想，就是开一个数组$f[i] [j]$（开bool数组，可以节约一些空间，让其能开到$10^8$），表示$i$，$j$是不是朋友。然后每次有人发消息，就把它的所有朋友的答案$+1$。

**50pts代码**如下：

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int n,m;
bool f[10000][10000];
int ans[10000];
int main()
{
    // freopen("qq.in","r",stdin);
    // freopen("qq.out","w",stdout);
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        int x,y;
        char ch;
        cin>>ch;
        if(ch=='+')
        {
            scanf("%d%d",&x,&y);
            f[x][y]=1,f[y][x]=1;
        }
        else if(ch=='-')
        {
            scanf("%d%d",&x,&y);
            f[x][y]=0,f[y][x]=0;
        }
        else
        {
            scanf("%d",&x);
            for(int j=1;j<=n;j++)
                if(f[x][j])
                    ans[j]++;
        }
    }
    for(int i=1;i<=n;i++)
        printf("%d ",ans[i]);
    return 0;
}
```

然后介绍一下正解。

其实我上面的暴力思路如果再深入一下也就是正解了，思路都是：**记录朋友，累加答案**。那么，为什么上面的代码叫暴力，下面的代码叫正解，就是因为复杂度不一样。正解可以跑更大的数据。所以通过这道题，还能教会我们在考场上的一个答题技巧：当我们只能想出暴力思路的时候，想一想怎么通过已知手段优化暴力算法，说不定搞一搞正解就出来了。

闲话少叙，直奔主题：

我们已经得出了暴力的思路：记录朋友，累加答案。我们刚刚采用的记录朋友的办法是开矩阵数组。但这样肯定开不下空间（$n\le 2\times 10^5$）。于是我们开始想：什么东西可以使得我们对$1-n$每个人都记录一个序列，同时做到方便地加入和删除呢？

$STL$大法：$set$容器。

使用了$set$的代码就变成了80分，剩下的两个点$TLE$了。

**80pts代码**如下：

```cpp
#include<cstdio>
#include<iostream>
#include<set>
using namespace std;
const int maxn=2*1e5+1;
int n,m;
set<int> s[maxn];
set<int>::iterator it;
int ans[maxn];
char *p1,*p2,buf[100000];
#define nc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++)
int read()
{
    int x=0,f=1;
    char ch=nc();
    while(ch<48){if(ch=='-')f=-1;ch=nc();}
    while(ch>47)    x=x*10+ch-'0',ch=nc();
    return x*f;
}
int main()
{
    n=read();m=read();
    for(int i=1;i<=m;i++)
    {
        int x,y;
        char ch=nc();
        if(ch=='+')
        {
            x=read();y=read();
            s[x].insert(y);
            s[y].insert(x);
        }
        else if(ch=='-')
        {
            x=read();y=read();
            s[x].erase(y);
            s[y].erase(x);
        }
        else
        {
            x=read();
            for(it=s[x].begin();it!=s[x].end();it++)
                ans[*it]++;
        }
    }
    for(int i=1;i<=n;i++)
        printf("%d ",ans[i]);
    return 0;
}
```

加了读入优化，然而并没有用......

那我们继续去想......

因为$TLE$了，那么显然是统计答案时出的问题。80分的思路统计答案的时候使用迭代器从头到尾给$x$的每个答案$+1$，这种复杂度差不多是$O(n\times m)$显然是不行的。

那么我们这样考虑：既然一次加一个不行，我们就一次加一堆。

具体实现的原理是这样的：

设想一下，现在你是个包工头，有一个人要给你打工，工钱每天一块钱。然后有一天这个人不干了，于是你把他这些天的工钱一起结算给他，你们愉快地一拍两散~

迁移到这道题：当你每次更博的时候，就相当于工地干了一天活，你要给你的工人们（朋友）发一块钱的工资。你觉得一天一结算太麻烦，于是你记录下来了每个工人第一天来上班的日子和退休的日子，然后一起把钱结算给它们。

这是个差分思想么！

我们开一个数组$cnt[i]$，表示截止到目前，$i$已经发了多少条微博。当一个人加了$i$的好友，那么就记录这个人什么时候加的$i$，具体实现方法是把$cnt[i]$减掉，什么时候删除了$i$的好友，再把删除时的$cnt[i]$加回来。这样，$cnt[i_1]$和$cnt[i_2]$的差就代表了这个人成为$i$的好友的这一段时间内接收的微博数量。

当然，这样处理完$m$个询问的时候，还会有一些人仍然是其他人的好友。而我们的这个算法只在删除好友的时候统计答案。这就相当于工地有一天倒闭了，但是有一些工人仍在跟着你，你就算当裤子也必须得给他们发钱。

这道题不需要我们当裤子，只需要在处理完$m$个操作之后再加双层$for$循环强制统计答案即可。

（个人认为这个比喻好形象啊，如果你认为这对你的理解有所帮助，那我顺手求个推荐和好评~）

**100pts代码**如下：

```cpp
#include<cstdio>
#include<set>
#include<iostream>
using namespace std;
const int maxn=2*1e5+1;
int n,m;
int cnt[maxn],ans[maxn];
set<int> s[maxn];
set<int>::iterator it;
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        char opt;
        cin>>opt;
        int x,y;
        if(opt=='!')
        {
            scanf("%d",&x);
            cnt[x]++;
        }
        else if(opt=='+')
        {
            scanf("%d%d",&x,&y);
            ans[x]-=cnt[y];
            ans[y]-=cnt[x];
            s[x].insert(y);
            s[y].insert(x);
        }
        else
        {
            scanf("%d%d",&x,&y);
            ans[x]+=cnt[y];
            ans[y]+=cnt[x];
            s[x].erase(y);
            s[y].erase(x);
        }
    }
    for(int i=1;i<=n;i++)
        for(it=s[i].begin();it!=s[i].end();it++)
            ans[i]+=cnt[*it];
    for(int i=1;i<=n;i++)
        printf("%d ",ans[i]);
    return 0;
}
```



---

## 作者：Refun (赞：3)

感觉现在做数据结构做傻了……一看到类似操作就往数据结构上艹

后来发现唯一能搞的lct好像还搞不了emmm……

然后又想着能不能离线搞，发现+x y  -x y 只有他们之间的一段才会有贡献

每个点单独开一个set，计算和其相连的人 

当为叹号的时候cnt++ 

那么我们就在加的时候把当前cnt减掉，然后在后面减的时候再加上新的cnt，

这一段区间内的贡献就都被考虑进去了 

最后再遍历一遍set把过程中没有减掉的贡献算上就行了 

[代码](http://www.cnblogs.com/refun/p/8685664.html)

---

## 作者：little_sun (赞：1)

很明显我们可以只在删除一堆好友时统计答案。

设$C_{x,y}$为加入$(x,y)$时$x$的发微博次数，$C_{y,x}$定义类似
  $D_{x,y}$为删除$(x,y)$时$x$的发微博次数，$D_{y,x}$定义类似

则每次删除一对$(x,y)$时,

$\Delta_{ans[x]}=D_{y,x}-C_{y,x}$，$\Delta_{ans[y]}=D_{x,y}-C_{x,y}$

又$C$数组我们可以用`std::map`维护，$D$数组可以直接用数组维护

这样我们就得到了一个时间复杂度为$O(n\log_2{n})$的算法，足够通过此题

另外，最后可能有些对好友没有被删除，所以我们要手动帮他们删除并统计答案

`Code:`

```cpp
#include <bits/stdc++.h>

#define R register
#define ll long long
#define mp(i, j) std::make_pair(i, j)
#define sum(a, b, mod) ((a + b) % mod)

const int MaxN = 2e5 + 10;

int n, m;
int a[MaxN], ans[MaxN];

std::map<std::pair<int, int>, int> map;

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; i++)
    {
        char op;
        int x, y;
        std::cin >> op;
        if (op == '!')
            scanf("%d", &x), a[x]++;
        else if (op == '+')
            scanf("%d%d", &x, &y), map[mp(x, y)] = a[x], map[mp(y, x)] = a[y];
        else
        {
            scanf("%d%d", &x, &y);
            ans[y] += (a[x] - map[mp(x, y)]), ans[x] += (a[y] - map[mp(y, x)]);
            map.erase(mp(x, y)), map.erase(mp(y, x));
        }
    }
    for (std::map<std::pair<int, int>, int>::iterator it = map.begin(); it != map.end(); it++)
        ans[it->first.second] += (a[it->first.first] - it->second);
    for (int i = 1; i <= n; i++)
        printf("%d ", ans[i]);
    return 0;
}

```

---

## 作者：daqirui (赞：1)

###### ~~好像还没有用vector的题解，自己发一篇~~

### 这道题我用的是 _午夜飘雪_ 的想法（见前几篇题解），利用了近似差分的思想，从而让统计答案的时间复杂度降到O(1)

# 但是！

### vector插入虽快（O(1)），但不能用像set一样O(logN)的删除，它删边的速度为O(n)，所以这道题如果是最差的情况，我这个算法就完了，O(M*N)；但是set的插入和删除都很快

# 其他都一样啦！

```cpp
#include<stdio.h>
#include<vector>
using namespace std;
inline int read(){
    register int s=0,f=1;
    register char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        s=s*10+ch-'0';
        ch=getchar();
    }
    return s*f;
}
inline void write(register int x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    if(x>9)write(x/10);
    putchar(x%10+'0');
}
const int MAXN=200001,MAXM=500001;
int n,m,cnt[MAXN],ans[MAXN];
vector<int> a[MAXN];
void addFriend(register int u,register int v){
	a[u].push_back(v);
	a[v].push_back(u);
	ans[u]-=cnt[v];
	ans[v]-=cnt[u];
}
void delFriend(register int u,register int v){
	register vector<int>::iterator it;
	for(it=a[u].begin();it!=a[u].end();++it){
		if((*it)==v){
			a[u].erase(it);
			break;
		}
	}
	for(it=a[v].begin();it!=a[v].end();++it){
		if((*it)==u){
			a[v].erase(it);
			break;
		}
	}
	ans[u]+=cnt[v];
	ans[v]+=cnt[u];
}
void sendMsg(register int u){
	++cnt[u];
}
int main(){
	n=read();
	m=read();
	while(m--){
		char cmd;
		register int x,y;
		cmd=getchar();
		x=read();
		if(cmd=='+'||cmd=='-'){
			y=read();
		}
		if(cmd=='+'){
			addFriend(x,y);
		}
		if(cmd=='-'){
			delFriend(x,y);
		}
		if(cmd=='!'){
			sendMsg(x);
		}
	}
	for(int i=1;i<=n;++i){
		for(register int j=0;j<a[i].size();++j){
			ans[i]+=cnt[a[i][j]];
		}
		write(ans[i]);
		putchar(' ');
	}
    return 0;
}

```


---

## 作者：s_a_b_e_r (赞：1)

#####30分?

暴力模拟。

我们记录在当前x点现在可以产生$cnt_x$的贡献

对于每一次加边,记录它所到达的点,并记录当前这个点出现贡献次数为dis

然后单次删除到x的边

就是找到这个边,答案就会产生$cnt_x-dis$的贡献

这样单次查找到这个点的复杂度是$O(n)$，结合m次的操作

大概就能过30%

#####100分

对于上面的进行一个优化。

对于每一个x点所到的点都可以看成一个集合,这样上面的做法是暴力查找集合中所有的元素。

显然这一步可以用数据结构暴力搞,比如set,map,使查找维持在logn,但我们不用这样

我们只需要集合中元素单调,就可以二分找到。

于是每一次加点就找到一个满足的位置,使加入这个点,集合中元素依旧单调。

删除就在vector中删,剩下的自动补充。

每一个点开一个vector维护dis和所到达的位置

直接在线搞出来就可以

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio> 
#include<map> 
#include<vector>
using namespace std;
const int maxn=200000+233;
vector< pair<int,int> >v[maxn];
vector< pair<int,int> >::iterator it;
int ans[maxn];
int n,m;
char ch;
int cnt[maxn];
int x,y;
int main(){
    ios::sync_with_stdio(0);
    cin>>n>>m;
    for(;m;m--){
        cin>>ch;
        if(ch=='!'){
            cin>>x;
            cnt[x]++;
        }
        else{
            cin>>x>>y;
            if(ch=='+'){
                v[x].insert(lower_bound(v[x].begin(),v[x].end(),make_pair(y,-2333)),make_pair(y,cnt[y]));
                v[y].insert(lower_bound(v[y].begin(),v[y].end(),make_pair(x,-2333)),make_pair(x,cnt[x]));
            }
            else{
                it=lower_bound(v[x].begin(),v[x].end(),make_pair(y,-2333));
                ans[x]+=cnt[y]-(it->second);
                v[x].erase(it);
                it=lower_bound(v[y].begin(),v[y].end(),make_pair(x,-2333));
                ans[y]+=cnt[x]-(it->second);
                v[y].erase(it);
            }
        }
    }
    for(int i=1;i<=n;i++){
    for(it=v[i].begin();it!=v[i].end();++it)
    ans[i]+=cnt[it->first]-(it->second); 
    cout<<ans[i]<<" ";
    }
    return 0;
}
```
但是其实可以离线从后往前减,这样做是$O(m)$的

~~应该没有人会在这里卡常数的~~


---

## 作者：Drinkkk (赞：1)

/\*
P3998 题解

技巧的运用


$50$分思路：用一个二维$bool$数组$hy$来表示两人是否是好友，即当$hy[x][y]=true$时表示$x$和$y$为好友，反之则不是好友，当$x$发微博时，将$x$的好友的$ans+1$。


$60$分思路：用一个邻接表来存储$SH$微博里的好友关系，当$x$和$y$互相加了好友后，建一条从$x$到$y$的双向边，当$x$和$y$解除了好友关系时，将这一条从$x$到$y$的双向边删除掉，但是要注意当$x$与$y$加好友时，要先解除$x$和$y$的好友关系，否则就只能够得到$10$分，并且当$x$发微博时，将$x$的好友的$ans+1$。


$100$分思路：

从第$m$条消息到第$1$条消息开始判断，并且我们用一个一维数组$cnt$来表示当前$SH$微博的用户发微博的情况，即用$cnt[x]$来表示当前第$x$个用户发了几条微博，当$x$与$y$成为了好友，就将$ans[x]$加上$cnt[y]$，并将$ans[y]$加上$cnt[x]$，当$x$与$y$解除了好友关系时，我们就将$ans[x]$减去$cnt[y]$，并将$ans[y]$减去$cnt[x]$。

\*/
/\*
$50$分代码：

\*/
```cpp
#include <cstdio>
#include <cstring>
bool hy[10001][10001];
int ans[1000001];
int main()
{
    memset(hy,false,sizeof(hy));
    int n=0,m=0;
    scanf("%d %d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        int x=0,y=0;
        char ch;
        scanf("\n%c",&ch);
        if(ch=='!')
        {
            scanf("%d",&x);
            for(int j=1;j<=n;j++)
            {
                if(hy[x][j]==true || hy[j][x]==true)
                {
                    ans[j]++;
                }
            }
        }
        else if(ch=='+')
        {
            scanf("%d %d",&x,&y);
            hy[x][y]=true,hy[y][x]=true;
        }
        else if(ch=='-')
        {
            scanf("%d %d",&x,&y);
            hy[x][y]=false,hy[y][x]=false;
        }
    }
    for(int i=1;i<=n;i++)
    {
        printf("%d ",ans[i]);
    }
    return 0;
}
```
/\*
$60$分代码：

\*/
```cpp
#include <cstdio>
#include <cstring>
struct nodeb{ int x,y; } b[1000001];
int ans[1000001],len=0;
void br(int x,int y)
{
    len++;
    b[len].x=x;
    b[len].y=y;
}
int main()
{
    int n=0,m=0;
    scanf("%d %d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        int x=0,y=0;
        char ch;
        scanf("\n%c",&ch);
        if(ch=='!')
        {
            scanf("%d",&x);
            for(int j=1;j<=len;j++)
            {
                if(b[j].x==x)
                {
                    ans[b[j].y]++;
                }
            }
        }
        else if(ch=='+')
        {
            scanf("%d %d",&x,&y);
            for(int j=1;j<=len;j++)
            {
                if(b[j].x==x && b[j].y==y)
                {
                    b[j].x=-1,b[j].y=-1;
                }
                if(b[j].y==x && b[j].x==y)
                {
                    b[j].x=-1,b[j].y=-1;
                }
            }
            br(x,y),br(y,x);
        }
        else if(ch=='-')
        {
            scanf("%d %d",&x,&y);
            for(int j=1;j<=len;j++)
            {
                if(b[j].x==x && b[j].y==y)
                {
                    b[j].x=-1,b[j].y=-1;
                }
                if(b[j].y==x && b[j].x==y)
                {
                    b[j].x=-1,b[j].y=-1;
                }
            }
        }
    }
    for(int i=1;i<=n;i++)
    {
        printf("%d ",ans[i]);
    }
    return 0;
}
```
/\*
$100$分代码：

\*/
```cpp
#include <cstdio>
int ans[1000001],cnt[1000001],fh[1000001],x[1000001],y[1000001];
int main()
{
    int n=0,m=0;
    scanf("%d %d\n",&n,&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%c",&fh[i]);
        if(fh[i]=='!')
        {
            scanf("%d\n",&x[i]);
        }
        else
        {
            scanf("%d %d\n",&x[i],&y[i]);
        }
    }
    for(int i=m;i>=1;i--)
    {
        if(fh[i]=='!')
        {
            cnt[x[i]]++;
        }
        else if(fh[i]=='+')
        {
            ans[x[i]]+=cnt[y[i]];
            ans[y[i]]+=cnt[x[i]];
        }
        else if(fh[i]=='-')
        {
            ans[x[i]]-=cnt[y[i]];
            ans[y[i]]-=cnt[x[i]];
        }
    }
    for(int i=1;i<=n;i++)
    {
        printf("%d ",ans[i]); 
    }
    return 0;
}
```

---

## 作者：Link_Space (赞：0)

第一眼看到以为是一道奇怪的数据结构题，想了一下发现好像没有什么数据结构可以做，于是开始往其他方面想。

题目已经提示得很到位了，我们可以很轻松地想到：一个人接收到他其中一位好友的微博个数等于他与这个好友删好友时这个好友发的微博总数减去他与这个好友加好友时这个好友发的微博总数。这不显然就是前缀和！！！

那么思路就很清晰了，开一个ans数组统计答案，再开一个cnt数组作为前缀和数组，那么对于一对好友a,b来说，b对a的贡献即为在他们删好友时的cnt[b]减去他们加好友时的cnt[b]，接下来就只需要顺顺利利打出来即可。

然后我们就会意识到一个问题：万一有某对好友自始至终没有互删的话怎么处理？对于这个问题我们就得另开一个容器来储存每个人的好友，这样就会变得麻烦许多，其实也有一个更简单的做法（取自 [午夜飘雪](/user/25852) ）
：

只需要倒过来处理每个询问即可，为什么这样可行呢？因为你不希望看到的情况是最后有好友没有互删，而题目中提到最开始时彼此都不是好友，那么倒过来处理的话到最后每个人都彼此不是好友，即达到了全部互删的目的。同时需要注意的是，既然我们倒过来处理，那么我们对于一对好友a,b就是先删好友再加好友，我们统计答案时同样需要变化。

以下是代码：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int N = 1e6 + 5;
int ans[N];
int cnt[N];
int ask[N][3];
char query[N];
int main()
{
    int n, m;
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m;i++)
    {
        char op;
        cin >> op;
        query[i] = op;
        if(op=='!')
            scanf("%d", &ask[i][1]);
        else if(op=='+')
            scanf("%d%d", &ask[i][1], &ask[i][2]);
        else
            scanf("%d%d", &ask[i][1], &ask[i][2]);
    }
    for (int i = m; i >= 1;i--)
    {
        int a = ask[i][1];
        int b = ask[i][2];
        if(query[i]=='!')
            cnt[a]++;
        else if(query[i]=='+')
            ans[b] += cnt[a], ans[a] += cnt[b];
        else
            ans[b] -= cnt[a], ans[a] -= cnt[b];
    }
    for (int i = 1; i <= n; i++)
        printf("%d ", ans[i]);
    puts("");
    return 0;
}
```


---

## 作者：Great_Influence (赞：0)

这道题充分说明了数据结构学多了会阻碍人的思考方向。。。

刚看题，发现需要维护通断，第一反应LCT。然后仔细一看，只有直接关系。。。然后就想到了主席树维护区间情况。殊不知，其实只要STL就可以了。

具体做法是用set维护朋友关系，在开数组cnt和ans分别记录发微博条数和答案。当建立朋友关系时，只需要双方的ans分别减去此时对方的cnt。删除朋友关系时只需要双方再加上就可以了。最后记得将剩下朋友关系的答案统计就可以了。

代码：

```cpp
    #include<bits/stdc++.h>
    #include<cctype>
    #define For(i,a,b) for(i=(a),i##end=(b);i<=i##end;++i)
    #define Forward(i,a,b) for(i=(a),i##end=(b);i>=i##end;--i)
    #define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)
    #define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;--i)
    using namespace std;
    template<typename T>inline void read(T &x){
        T s=0,f=1;char k=getchar();
        while(!isdigit(k)&&k^'-')k=getchar();
        if(!isdigit(k)){f=-1;k=getchar();}
        while(isdigit(k)){s=s*10+(k^48);k=getchar();}
        x=s*f;
    }
    void file(void){
        #ifndef ONLINE_JUDGE
        freopen("P3998.in","r",stdin);
        freopen("P3998.out","w",stdout);
        #endif
    }
    const int MAXN=201001;
    static int n,m,cnt[MAXN],ans[MAXN];
    static char opt;
    static set<int>G[MAXN];
    inline void get(char &x){for(x=getchar();!isgraph(x);x=getchar());}
    void work()
    {
        read(n);read(m);
        static int u,v;
        Rep(i,1,m)
        {
            get(opt);
            read(u);
            switch(opt)
            {
                case '!':++cnt[u];break;
                case '+':read(v);ans[u]-=cnt[v];ans[v]-=cnt[u];G[u].insert(v);G[v].insert(u);break;
                case '-':read(v);ans[u]+=cnt[v];ans[v]+=cnt[u];
                         G[u].erase(G[u].lower_bound(v));G[v].erase(G[v].lower_bound(u));break;
            }
        }
        Rep(i,1,n)while(!G[i].empty())ans[i]+=cnt[*G[i].begin()],G[i].erase(G[i].begin());
        Rep(i,1,n)printf("%d ",ans[i]);putchar('\n');
    }
    int main(void){
        file();
        work();
        return 0;
    }

```

---


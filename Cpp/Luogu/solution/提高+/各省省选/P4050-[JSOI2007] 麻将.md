# [JSOI2007] 麻将

## 题目描述

麻将是中国传统的娱乐工具之一。麻将牌的牌可以分为字牌（共有东、南、西、北、中、发、白七种）和序数牌（分为条子、饼子、万子三种花色，每种花色各有一到九的九种牌），每种牌各四张。

在麻将中，通常情况下一组和了的牌（即完成的牌）由十四张牌组成。十四张牌中的两张组成对子（即完全相同的两张牌），剩余的十二张组成三张一组的四组，每一组须为顺子（即同花色且序数相连的序数牌，例如条子的三、四、五）或者是刻子（即完全相同的三张牌）。一组听牌的牌是指一组十三张牌，且再加上某一张牌就可以组成和牌。那一张加上的牌可以称为等待牌。

在这里，我们考虑一种特殊的麻将。在这种特殊的麻将里，没有字牌，花色也只有一种。但是，序数不被限制在一到九的范围内，而是在 $1$ 到 $n$ 的范围内。同时，也没有每一种牌四张的限制。一组和了的牌由 $3m + 2$ 张牌组成，其中两张组成对子，其余 $3m$ 张组成三张一组的 $m$ 组，每组须为顺子或刻子。现给出一组 $3m + 1$ 张的牌，要求判断该组牌是否为听牌（即还差一张就可以和牌）。如果是的话，输出所有可能的等待牌。

## 样例 #1

### 输入

```
9 4
1 1 2 2 3 3 5 5 5 7 8 8 8```

### 输出

```
6 7 9```

# 题解

## 作者：Jesselrj (赞：12)

# 麻将（[JSOI2007]）
原题链接：[luogu P4050][9]

## 解题思路：
这可是民间国粹啊！~~虽然我不会打~~

这题如果会打麻将的同学就可以很快的理解题意，像我这种不会的，得搞很久才明白。

由于胡要必定有一个对子，所以，我们可以枚举每一种可能性，使其凑成对子以上个数。然后继续进行各种刻子和顺子的判断。

## AC代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;

int n,m,t[4001],a[4001];
bool bj;

bool check()
{
	for(int i=1;i<=n;i++)
	{
		if(t[i]>=2)//只有凑成对子以上个数时才能胡牌。
		{
			bool ok=1;//进行标记是否找到。
			t[i]-=2;//将其当做对子。
			for(int j=1;j<=n+2;j++)a[j]=t[j];//不能改变原来数组的值。
			for(int j=1;j<=n+2;j++)
			{
				if(a[j]<0)//如果小于0则代表不能胡牌，直接退出循环，进行下一个对子的判断。
				{
					ok=0;
					break;
				}
				a[j]%=3;//刻子
				a[j+1]-=a[j];//顺子
				a[j+2]-=a[j];//顺子
			}
			t[i]+=2;
			if(ok)return 1;
		}
	}
	return 0;
}

int main()
{
	cin>>n>>m;
	for(int i=1,x;i<=m*3+1;i++)cin>>x,t[x]++;//用桶来存储麻将个数。
	for(int i=1;i<=n;i++)
	{
		t[i]++;
		if(check())bj=1,cout<<i<<" "; //只要找到一个解就标记找到了，并输出解。
		t[i]--;
	}
	if(!bj)cout<<"NO";
	return 0;
}
```
[9]:https://www.luogu.org/problemnew/show/P4050

---

## 作者：javalyc (赞：8)

[此题博客传送门 qwq](https://www.cnblogs.com/LLTYYC/p/11433012.html)

怎么好像没什么人写 $dp$ ...？

设 $f[i][j][k][0/1]$ 表示当前处理完前 $1$ 到 $i$ 的数，上一位开始的顺子有 $j$ 个，当前位开始的顺子有 $k$ 个，是否已经有雀头，的情况下能不能胡

因为连续三个顺子其实等价于三个刻字，所以我们只要考虑顺子小于 $3$ 的情况，即 $j,k$ 都小于 $3$

然后枚举下一位的顺子数量并把当前位的顺子补好，剩下的全做刻字，顺便处理一下雀头就行

然后枚举每种可能的听牌，跑一遍 $dp$ 看看有没有解

具体怎么 $dp$ 也挺好想的，看代码注释吧...

复杂度 O(不会算)，反正跑得飞快，目前 $luogu$ 第一

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<vector>
using namespace std;
typedef long long ll;
inline int read()
{
	int x=0,f=1; char ch=getchar();
	while(ch<'0'||ch>'9') { if(ch=='-') f=-1; ch=getchar(); }
	while(ch>='0'&&ch<='9') { x=(x<<1)+(x<<3)+(ch^48); ch=getchar(); }
	return x*f;
}
const int N=507;
int n,m,a[N];
int f[N][3][3][2];
bool work()
{
	memset(f,0,sizeof(f));
	f[0][0][0][0]=1;
	for(int i=0;i<n;i++)//当前处理完第i位,考虑下一位
		for(int j=0;j<3;j++)//以上一位开头有j个顺子
			for(int k=0;k<3;k++)//当前为开头有k个顺子
				for(int p=0;p<2;p++)//当前是否有雀头
				{
					if(!f[i][j][k][p]) continue;//剪枝
					for(int l=0;l<=min(a[i+1]-j-k,2);l++)//枚举下一位顺子数量
						if((a[i+1]-j-k-l)%3==0)//剩下的全做刻字
							f[i+1][k][l][p]=1;
					if(!p)//考虑留两个做雀头
						for(int l=0;l<=min(a[i+1]-j-k-2,2);l++)//同上
							if((a[i+1]-j-k-l-2)%3==0)
								f[i+1][k][l][1]=1;
				}
	return f[n][0][0][1];//看看最后有没有解
}
vector <int> ans;
int main()
{
	n=read(),m=read();
	for(int i=1;i<=m*3+1;i++) a[read()]++;
	for(int i=1;i<=n;i++)//枚举听牌
	{
		a[i]++;
		if(work()) ans.push_back(i);
		a[i]--;
	}
	int len=ans.size();
	if(!len) { printf("NO\n"); return 0; }
	for(int i=0;i<len;i++) printf("%d ",ans[i]);
	printf("\n");
	return 0;
}
```


---

## 作者：qhztz (赞：6)

## [题目传送门](https://www.luogu.com.cn/problem/P4050)
## 思路
用桶储存，先匹配对子，刻子，再匹配顺子，然后检验胡牌可能性。


------------

具体如代码所示：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int f[410],s[410],ans[410];
bool j(){
    bool bo;//相当于check
    for(int i=1;i<=n;i++){
        if(s[i]>=2){
            bo=1;
            s[i]-=2;//组对子
            for(int j=1;j<=n+2;j++){//从1到n+2都赋值s数组 因为我们最大访问的个数为n+2。
                f[j]=s[j];
            }
            for(int j=1;j<=n+2;j++){
                if(f[j]<0){//如果胡牌时，此数为负数 
                    bo=0;//记得清零
                    break;
                }
                f[j]%=3;//能组刻子就组刻子 
                f[j+1]-=f[j];//组顺子 
                f[j+2]-=f[j];
            }
            s[i]+=2;
            if(bo)//检验刻子 
            return 1;
        }
    }
    return 0;
}
int main(){
    int num=0,x;
    cin>>n>>m;
    for(int i=1;i<=3*m+1;i++){
        cin>>x;
        s[x]++;//用桶来储存 
    }
    for(int i=1;i<=n;i++){
        s[i]++;
        if(j()){//检验抽到 i 是否胡牌 
            num++;
            ans[num]=i;//存储答案
        }
        s[i]--;//回溯 
    }
    if(num==0){//如果胡牌的可能为0 
        cout<<"NO"<<endl;//输出“NO” 
        return 0;
    }
    for(int i=1;i<=num;i++){
        cout<<ans[i]<<" ";//输出每一个能胡牌的数 
    }
    cout<<endl;//
    retrun 0；//完结撒花！！！ 
}
```
求管理过qaq

---

## 作者：Drinkkk (赞：5)

这道题对于不会打麻将的人来说还是有点难理解规则的，~~我没说过我会打麻将，~~这里是[题目链接](https://www.luogu.org/problemnew/show/4050)。

$20$分思路，利用深搜来寻找答案，我们先枚举每一张听牌，那么很显然，时间复杂度就是$O(n)$，再用深搜来判断可否胡牌。首先，我们用$t[x]$来表示数值为$x$的牌出现了多少次。那么我们就从$1$到$n$枚举对子，再枚举刻子和顺子。那么深搜的时间复杂度约是$O(2n^2)$，合起来就是$O(2n^3)$。因为$9<=n<=400$，所以会超时。但是不能够同时枚举多个顺子。

$100$分思路：

还是先枚举听牌，然后再枚举对子，接着枚举多对刻子，最后再枚举顺子。

如果我们设$e$数组是当前的牌的状态，那么关键代码就是：

```cpp
e[j]%=3;
e[j+1]-=e[j];
e[j+2]-=e[j];
```
那么当$e[j]<0$时就说明这张牌不是听牌。

这种方法的时间复杂度为$O(n^3)$。和前面的方法的时间复杂度相比就是$\frac{O(n^3)}{O(2n^3)}$，相当于$\frac{1}{2}$。

下面给一组数据用于对拍：

数据输入：


```
9 4
1 2 3 3 4 4 5 6 8 8 9 9 9
```

数据输出：

```
2 5
```

$20$分代码：

```cpp
#include <cstdio>
#include <cstring>
int t[10001],e[10001];
bool flag=false;
int ans=0,n=0,m=0;
bool dfs(int l)
{
    int gc=0,x=0;
    for(int i=1;i<=n;i++)
    {
        if(e[i]!=0)
        {    
            gc++,x=e[i];
        }
    }
    if(gc==1 && x==2)
    {
        ans=l;
    }
    for(int i=1;i<=n;i++)
    {
        if(e[i]>=1 && e[i+1]>=1 && e[i+2]>=1)
        {
            e[i]--,e[i+1]--,e[i+2]--;
            dfs(l);
            e[i]++,e[i+1]++,e[i+2]++;
        }
        if(e[i]>=3)
        {
            e[i]-=3;
            dfs(l);
            e[i]+=3;
        }
    }
}
int main()
{
    scanf("%d %d",&n,&m);
    for(int i=1;i<=3*m+1;i++)
    {
        int x=0;
        scanf("%d",&x);
        t[x]++;
    }
    for(int i=1;i<=n;i++)
    {
        e[i]=t[i];
    }
    for(int i=1;i<=n;i++)
    {
        ans=0;
        e[i]++;
        dfs(i);
        if(ans!=0)
        {
            flag=true;
            printf("%d ",ans);
        }
        e[i]--;
    }
    if(flag==false)
    {
        printf("NO");
    }
    return 0;
}
```
$100$分代码：
```cpp
#include <cstdio>
#include <cstring>
int t[10001],e[10001];
bool flag=false;
int n=0,m=0;
bool check()
{
    for(int i=1;i<=n;i++)
    {
        if(t[i]>=2)
        {
            bool ju=true;
            t[i]-=2;
            for(int j=1;j<=n+2;j++)
            {
                e[j]=t[j];
            }
            for(int j=1;j<=n+2;j++)
            {
                if(e[j]<0)
                {
                    ju=false;
                    break;
                }
                e[j]%=3;
                e[j+1]-=e[j];
                e[j+2]-=e[j];
            }
            t[i]+=2;
            if(ju==true)
            {
                return true;
            }
        }
    }
    return false;
}
int main()
{
    scanf("%d %d",&n,&m);
    for(int i=1;i<=3*m+1;i++)
    {
        int x=0;
        scanf("%d",&x);
        t[x]++;
    }
    for(int i=1;i<=n;i++)
    {
        t[i]++;
        memset(e,0,sizeof(e));
        if(check()==true)
        {
            flag=true;
            printf("%d ",i);
        }
        t[i]--;
    }
    if(flag==false)
    {
        printf("NO");
    }
    return 0;
}
```

---

## 作者：MaxDYF (赞：3)

这题，老实说吧，不会打国粹，还真的不好做（没有快速找听牌的方法）。但是，认真读题，还是能做出来的。

一开始，写的是一个dfs爆搜，枚举每一种情况，复杂度极高，自然而然的TLE。

又认真读题，因为数字的范围比较小(n<=400)，所以，我们考虑先枚举听牌。然后，检查是否构成和牌。如果是和牌，则直接输出听牌。

在check中，我们也可以先枚举对子，再去判断各种刻子与顺子。

最后，我们可以先优先判断是否刻子，在判断顺子，这样就能解出答案了。时间复杂度O(n^3)(枚举听牌+枚举对子+判断顺子与刻子)

AC代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
int bj[500],n,a[500];
bool check()
{
	for(int j=1;j<=n;j++)
	{
		if(bj[j]>=2)//枚举当前牌为对子 
		{
			bj[j]-=2;
			bool ok=1;
			for(int i=1;i<=n+2;i++) a[i]=bj[i];//原数组不能更改，所以复制到新数组中操作 
			for(int i=1;i<=n+2;i++)
			{
				if(a[i]<0)//如果a[i]<0,说明上一次循环中被减去了，凑不齐一组顺子 
				{
					ok=0;
					break;//凑不齐就直接跳出，减少循环次数 
				}
				a[i]%=3;//如果a[i]大于2，说明可以凑成一组刻子（3个相同） 
				a[i+1]-=a[i];//剩下的因为已经去除了对子，所以剩下的一定是顺子。 
				a[i+2]-=a[i];//同上 
			}
			bj[j]+=2;
			if(ok) return 1;
		}
	}
	return 0;
}
int main()
{
	int x,m,ok=1;
	cin>>n>>m;
	for(int i=1;i<=m*3+1;i++) 
	{
		cin>>x;
		bj[x]++;
	}
	for(int i=1;i<=n;i++)
	{
		bj[i]++;
		if(check()) ok=0,cout<<i<<' ';
		bj[i]--;
	}
	if(ok) puts("NO");//如果没有听牌，则输出NO 
}
```

---

## 作者：Aleph1022 (赞：2)

最近麻将题写上瘾了……（

显然地考虑枚举听的那张牌，然后判定是否可以和牌。  
考虑 DP，设 $f_{i,0/1,j,k}$ 表示考虑了前 $i$ 种牌，无 / 有雀头，除去做面子的牌还有 $j$ 组 $(i-1,i)$，$k$ 张 $i$ 的情况下最多可以做多少面子。  
则枚举第 $i$ 种牌预留多少张，即可转移。  
每次转移的时候考虑拿 $2$ 张出来组雀头就行了。

最后因为刚好是 $3m+2$ 张，所以肯定不会有多的 $(n-1,n)$ 或单独的 $n$，故只有 $f_{n,1,0,0} = m$ 时才算和牌。

代码：
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
const int N = 400;
const int M = 1e3;
int n,m,a[N + 5],flag;
int f[N + 5][2][3][3];
inline int dp()
{
    memset(f,-0x3f,sizeof f),f[0][0][0][0] = 0;
    for(register int i = 1;i <= n;++i)
        for(register int j = 0;j < 3;++j)
            for(register int k = 0;k < 3;++k)
            {
                for(register int l = 0;l < 3 && j + k + l <= a[i];++l)
                    f[i][0][k][l] = max(f[i][0][k][l],f[i - 1][0][j][k] + j + (a[i] - j - k - l) / 3),
                    f[i][1][k][l] = max(f[i][1][k][l],f[i - 1][1][j][k] + j + (a[i] - j - k - l) / 3);
                if(a[i] >= 2)
                    for(register int l = 0;l < 3 && j + k + l <= a[i] - 2;++l)
                        f[i][1][k][l] = max(f[i][1][k][l],f[i - 1][0][j][k] + j + (a[i] - 2 - j - k - l) / 3);
            }
    return f[n][1][0][0] >= m;
}
int main()
{
    scanf("%d%d",&n,&m);
    int x;
    for(register int i = 1;i <= 3 * m + 1;++i)
        scanf("%d",&x),++a[x];
    for(register int i = 1;i <= n;++i)
        ++a[i],dp() && (flag |= 1,printf("%d ",i)),--a[i];
    !flag && puts("NO");
}
```

---

## 作者：codesonic (赞：2)

和其他题解都不太一样的写法

是一道有点技巧的搜索。

因为原题的描述不太友好窝复读一遍题意

一副和牌有十四张牌，由一个雀头（对子）和四组面子组成

雀头是两张一样的牌。

面子分为刻子和顺子，刻字就是三张相同的牌，顺子是三张连续的牌

平时的手牌有13张，让你判断是否听牌（差一张牌就和牌），然后输出差哪张牌就能和牌

然后因为简化了题意，只有n种数字牌。

因为差一张牌就和牌，考虑枚举差哪张牌，然后把这张牌加入手牌中

接下来枚举什么呢？如果您打过麻将，在打麻将过程中我们总是优先凑雀头（两个原因，1.先凑出雀头，听的牌如果是顺子就可能有两张听牌 2.~~确定雀头容易确定怎么处理役牌~~确定雀头容易确定自己的面子要怎么拼凑），因此我们考虑先枚举雀头（说了这么多还不是容易枚举）

枚举雀头后，因为剩下的都是三张三张的面子，就容易枚举了，直接考虑刻子和顺子的两种情况即可

时间复杂度$O(n^3)$，绰绰有余

（但是鄙人认为应该还有更快的解法/优化，求指点）

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<string>
#include<cstdio>
#include<cmath>
#include<queue>
#include<map>
#include<set>

using namespace std;

inline int read(){
    int res=0,fh=1;char ch=getchar();
    while((ch>'9'||ch<'0')&&ch!='-')ch=getchar();
    if(ch=='-')fh=-1,ch=getchar();
    while(ch>='0'&&ch<='9')res=res*10+ch-'0',ch=getchar();
    return fh*res;
}

const int maxn=3050;
int n,m,t[maxn],tmp[maxn];

inline bool work(int x){//加入x是不是能和牌
	++t[x];
	for(int i=1;i<=n;i++){
		if(t[i]<2) continue;//雀头
		memcpy(tmp,t,sizeof tmp);
		tmp[i]-=2;
		bool flag=1;
		for(int j=1;j<=n;j++){
			if(tmp[j]<0){
				flag=0;
				break;
			}
			tmp[j]%=3,tmp[j+1]-=tmp[j],tmp[j+2]-=tmp[j];//凑成刻子和面子
		}
		if(tmp[n+1]<0||tmp[n+2]<0)
			flag=0;
		if(flag){
			--t[x];
			return 1;
		}
	}
	--t[x];
	return 0;
}

int main()
{
	n=read(),m=read();
	for(int i=1;i<=(m<<1)+m+1;i++)
		++t[read()];//放到桶里，更容易处理
	bool flag=0;
	for(int i=1;i<=n;i++)
		if(work(i)) flag=1,printf("%d ",i);//依次判断
	if(!flag)return puts("NO"),0;
	return 0;
}
```
推荐游戏：[雀魂](https://majsoul.union-game.com/0/)

推荐观看视频：[一姬：杠！杠！杠！](https://www.bilibili.com/video/av38213503)

（大雾）

---

## 作者：Huah (赞：1)

动态规划
先用桶排序将麻将排序

dp[x][i][j][k]表示第x个麻将排剩余i个，第x-1个麻将牌剩余j个，k表示特殊的两个麻将是否被用过了，0表示没用过，1表示用过了。dp只有两个值true或false,true表示这个状态存在，false表示不存在。

每次枚举加入哪张牌，然后dp判断是否合法。

由于麻将数量最大只有3\*m+2个,所以有些i，j的状态是不必要的，枚举不必要的i,j会使复杂度达到(3\*m+2)^2\*n\*n，而剪掉这些i,j复杂度就可以降低了，可以用set或者开一个栈来维护这些状态。

转移方程很简单，每次都转移都必须把j这个数量删为0，因为后面的牌加入不会再影响到前面的了，如果没法删除j，状态就是不合法的。

然后优化剪枝一下，瞎搞就过了（因为set复杂度比较高)，开个栈维护哪些状态存在，不剪枝应该也能过。
set法（慢）
```
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int n,m,vis[455],a[N];
struct node
{
    int x,y,z;
    node(){};
    node(int x,int y,int z):x(x),y(y),z(z){}
    bool operator<(const node&o)const
    {
        if(x==o.x)
        {
            if(y==o.y) return z<o.z;
            return y<o.y;
        }
        return x<o.x;
    }
};
set<node>dp[2];
set<node>::iterator it;
vector<int>v;
bool judge()
{
    memset(vis,0,sizeof(vis));
    dp[0].clear();dp[1].clear();
    for(int i=1;i<=3*m+2;i++)
        vis[a[i]]++;
    int p=0;
    node t;
    for(int i=0;i<=vis[1];i+=3)
        dp[p].insert(node(vis[1]-i,0,0));
    for(int i=0;i+2<=vis[1];i+=3)
        dp[p].insert(node(vis[1]-2-i,0,1));
    for(int k=2;k<=n;k++)
    {
        for(it=dp[p].begin();it!=dp[p].end();it++)
        {
            int x=it->x,y=it->y,z=it->z;
            for(int i=0;i<=vis[k];i+=3)
                {
                    if(vis[k]-i-y>=0&&vis[k]-i-y>=x-y)
                        dp[p^1].insert(node(vis[k]-i-y,x-y,z));
                }
            if(z==0)
            {
                for(int i=0;i+2<=vis[k];i+=3)
                {
                    if(vis[k]-i-2-y>=0&&vis[k]-i-2-y>=x-y)
                        dp[p^1].insert(node(vis[k]-i-2-y,x-y,z^1));
                }
            }
        }
        dp[p].clear();
        p^=1;
        if(dp[p].size()==0) return false;
    }
    return dp[p].count(node(0,0,1));
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=3*m+1;i++)
        scanf("%d",&a[i]);
    for(int i=1;i<=n;i++)
    {
        a[3*m+2]=i;
        if(judge()) v.push_back(i);
    }
    if(v.size()==0) printf("NO\n");
    else for(int i=0;i<v.size();i++)
        printf(i==v.size()-1?"%d\n":"%d ",v[i]);
}

```
栈法（快）
```
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int n,m,vis[455],a[N];
struct node
{
    int x,y,z;
    node(){};
    node(int x,int y,int z):x(x),y(y),z(z){}
    bool operator<(const node&o)const
    {
        if(x==o.x)
        {
            if(y==o.y) return z<o.z;
            return y<o.y;
        }
        return x<o.x;
    }
};
vector<int>v;
bool vv[455][455][2];
int top[2];
node s[2][N<<1];
bool judge()
{
    memset(vis,0,sizeof(vis));
    for(int i=1;i<=3*m+2;i++)
        vis[a[i]]++;
    int p=0;
    node t;
    for(int i=0;i<=vis[1];i+=3)
        if(!vv[vis[1]-i][0][0])
    {
        vv[vis[1]-i][0][0]=true;
        s[p][++top[p]]=node(vis[1]-i,0,0);
    }
    for(int i=0;i+2<=vis[1];i+=3)
        if(!vv[vis[1]-2-i][0][1])
    {
        vv[vis[1]-2-i][0][1]=true;
        s[p][++top[p]]=node(vis[1]-2-i,0,1);
    }
    for(int k=2;k<=n;k++)
    {
        for(int i=1;i<=top[p];i++)
        {
            int x=s[p][i].x,y=s[p][i].y,z=s[p][i].z;
            vv[x][y][z]=false;
        }
        for(int i=1;i<=top[p];i++)
        {
            int x=s[p][i].x,y=s[p][i].y,z=s[p][i].z;
            for(int i=0;i<=vis[k];i+=3)
                {
                    if(vis[k]-i-y>=0&&vis[k]-i-y>=x-y&&!vv[vis[k]-i-y][x-y][z])
                    {
                        vv[vis[k]-i-y][x-y][z]=true;
                        s[p^1][++top[p^1]]=node(vis[k]-i-y,x-y,z);
                    }
                }
            if(z==0)
            {
                for(int i=0;i+2<=vis[k];i+=3)
                {
                    if(vis[k]-i-2-y>=0&&vis[k]-i-2-y>=x-y&&!vv[vis[k]-i-2-y][x-y][z^1])
                    {
                        vv[vis[k]-i-2-y][x-y][z^1]=true;
                        s[p^1][++top[p^1]]=node(vis[k]-i-2-y,x-y,z^1);
                    }
                }
            }
        }
        top[p]=0;
        p^=1;
        if(top[p]==0) return false;
    }
    return vv[0][0][1];
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=3*m+1;i++)
        scanf("%d",&a[i]);
    for(int i=1;i<=n;i++)
    {
        a[3*m+2]=i;
        if(judge()) v.push_back(i);
    }
    if(v.size()==0) printf("NO\n");
    else for(int i=0;i<v.size();i++)
        printf(i==v.size()-1?"%d\n":"%d ",v[i]);
}

```


---


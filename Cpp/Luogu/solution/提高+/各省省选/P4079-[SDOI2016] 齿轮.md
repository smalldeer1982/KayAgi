# [SDOI2016] 齿轮

## 题目描述

现有一个传动系统，包含了 $N$ 个组合齿轮和 $M$ 个链条。每一个链条连接了两个组合齿轮 $u$ 和 $v$，并提供了一个传动比 $x:y$，即如果只考虑这两个组合齿轮，编号为 $u$ 的齿轮转动 $x$ 圈，编号为 $v$ 的齿轮会转动 $y$ 圈。传动比为正表示若编号为 $u$ 的齿轮顺时针转动，则编号为 $v$ 的齿轮也顺时针转动。传动比为负表示若编号为 $u$ 的齿轮顺时针转动，则编号为 $v$ 的齿轮会逆时针转动。若不同链条的传动比不相容，则有些齿轮无法转动。我们希望知道，系统中的这 $N$ 个组合齿轮能否同时转动。

**这个传动系统可能不连通。** 也就是说，不保证任意两个齿轮都被链条直接或间接地连接。

## 说明/提示

### 数据范围

* $1\leq T\leq 32$；
* $1\leq N\leq 1000$；
* $1\leq M\leq 10^4$；
* $1\leq x,|y|\leq 100$。

## 样例 #1

### 输入

```
2
3 3
1 2 3 5
2 3 5 -7
1 3 3 -7
3 3
1 2 3 5
2 3 5 -7
1 3 3 7```

### 输出

```
Case #1: Yes
Case #2: No```

# 题解

## 作者：aiyougege (赞：14)

可算是被我自己的sb并查集水平给坑了 ~~用并查集做只是因为这个题的标签中有并查集的标签~~
#### Solution
　　如果将齿轮看做点, 链条看做边, 那么发现当其不形成环时总是合法的; 换言之, 只要形成了环, 我们就要判断是否合法.

　　发现传动比具有传递性, 即如果$a,b$的传动比为$w$,$b,c$的传动比为$e$, 那么$a,c$的传动比为$we$.

　　考虑并查集的做法: 
- 若用链条联通$a,b$两个齿轮
- 如果未联通, 则用并查集合并
- 若联通, 设从$a$经过一系列路径传动到$b$的传动比为$\alpha$, $a$和$b$直接联通的传动比为$\beta$, 若$\alpha\ne\beta$则不合法.

　　如何求出两个齿轮**间接连接**的传动比呢? 可以这么做:
- 用$g_i$表示$i$于其集合的祖先的传动比.
- 那么$g_i/g_j$就是两个点$i,j$之间的传动比.

　　至于如何利用并查集维护这个$g_i$, 请学习所谓的"**带权并查集**".~~反正我自己写过的带权并查集都是YY出来的~~.

不得不说带权并查集真的好多细节, 而普通并查集不用管那么多……

#### Code
```c++
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<cmath>
#define N 1005
#define eps 1e-9
using namespace std;

int f[N];double g[N];

int find(int x){
    if(f[x]==x)return x;
	int temp=find(f[x]);
	g[x]*=g[f[x]];
    return f[x]=temp;
}

bool equal(double a,double b){return fabs(a-b)<=eps;}

int main(){
    int T,n,m,a,b;double x,y;bool flag=0;
    scanf("%d",&T);
    for(int t=1;t<=T;++t){
        scanf("%d%d",&n,&m);flag=0;
        for(int i=1;i<=n;++i)f[i]=i;
        for(int i=1;i<=n;++i)g[i]=1;
        for(int i=1;i<=m;++i){
            scanf("%d%d%lf%lf",&a,&b,&x,&y);
			int f1=find(a),f2=find(b);
            if(f1==f2){
                if(!equal(x/y,g[a]/g[b])){flag=true;}
            }
            else f[f2]=f1,g[f2]*=g[a]/g[b]*y/x;
        }
        if(flag)printf("Case #%d: No\n",t);
        else printf("Case #%d: Yes\n",t);
    }
    return 0;
}
```

---

## 作者：7KByte (赞：8)

省选签到题

-----------

观察题面，我们发现如果图中没有环一定是满足条件的


如果出现了环不一定满足条件，显然如果环上的边权之积为$1$时满足条件，否则一定不满足条件


很好理解，我们任意取环上一点使之转动一周，经过环的传动回到自己这里一定还是只转一周


既然我们知道如何判断真伪，如何处理这些复杂的关系


处理点之间的关系，并查集是个不错的选择，本题不仅要处理是否成环，还要求出环上的边权积，带权并查集则能够很好的完成这个任务


对于并查集，我们定义$fa[i]$表示节点$i$的祖先，$k[i]$表示从节点$i$到$fa[i]$的传动比之积

对于每个链条$(u,v,x,y)$，如果$(u,v)$在一个联通块中，显然连了$u-v$后会成环，我们用$K=k[u]/k[v]$得到$u-v$的链上的传动比之积，如果$K==x/y$则满足条件，否则整个传动装置是不合法的

如果$(u,v)$不在一个联通块中，我们则需要在$u-v$之间连一条边权$t$边，使得$t*k[u]/k[v]==x/y$,解方程得到$t=(x*k[v])/(y*k[u])$


需要特别注意的是精度问题，实测$eps=10^{-10}$能过


细节见代码

```cpp
#include<bits/stdc++.h>
const double eps = 0.0000000001;
using namespace std;
int T,n,m;
int fa[1005];double k[1005];
int get(int x){
	if(x==fa[x])return x;
	int pa=get(fa[x]);
	k[x]*=k[fa[x]];
	return fa[x]=pa;
}
int main()
{
	scanf("%d",&T);
	for(int now=1;now<=T;now++){
		scanf("%d%d",&n,&m);
		bool ans=true;
		for(int i=1;i<=n;i++)fa[i]=i,k[i]=1.00;
		for(int i=1;i<=m;i++){
			int u,v;double x,y;
			scanf("%d%d%lf%lf",&u,&v,&x,&y);
			int p=get(u),q=get(v);
			if(p!=q){
				fa[p]=q;
				k[p]*=x*k[v]/(y*k[u]);
			}
			else{
				double sl=k[u]/k[v];
				if(abs(sl-x/y)>eps)ans=false;
			}
		}
		if(ans)printf("Case #%d: Yes\n",now);
		else printf("Case #%d: No\n",now);
	}
	return 0;
}
```

---

## 作者：Chenyichen0420 (赞：2)

## 思路分析

很简单，就不停的从不同的地方假定转速是 $1$，并暴搜检验是否满足要求就行了。说实话值不到蓝。

但是显然，如果我们直接拿 `long double` 等的去暴力维护的话，很容易就爆精度了。

所以有两种解法：一种是多找几个大质数，用逆元等的等价分数类来比较，另一种是使用 $\log$，把乘法“降阶”为加法。我采用的是第二种。

注意处理符号，代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int t, n, m;
struct node {
	int p, t; double v;
	node(int pi, double vi, int ty) :p(pi), v(vi), t(ty) {};
}; vector<node>son[1005];
double ras[1005]; bool tas[1005], vis[1005];
inline bool eq(double l, double r) {
	return abs(r - l) <= 1e-6;
}
inline void dfs(int p, double v, bool ty) {
	ras[p] = v; tas[p] = ty; vis[p] = 1;
	for (const node& sp : son[p])
		if (!vis[sp.p]) dfs(sp.p, v + sp.v, ty ^ sp.t);
		else if ((ty ^ sp.t) != tas[sp.p] || !eq(ras[sp.p], sp.v + v)) {
			throw 114514;
		}
}
inline double mylog(int v) {
	return log(abs(v)) * 1000;
}
signed main() {
	ios::sync_with_stdio(0); cin >> t;
	for (int tt = 1; tt <= t; ++tt) {
		cin >> n >> m;
		for (int i = 1, l, r, a, b; i <= m; ++i)
			cin >> l >> r >> a >> b,
			son[l].emplace_back(r, mylog(b) - mylog(a), a * b < 0),
			son[r].emplace_back(l, mylog(a) - mylog(b), a * b < 0);
		memset(vis, 0, sizeof vis);
		try {
			for (int i = 1; i <= n; ++i)
				if (!vis[i]) dfs(i, 0, 0);
			cout << "Case #" << tt << ": Yes\n";
		}
		catch (...) {
			cout << "Case #" << tt << ": No\n";
		}
		for (int i = 1; i <= n; ++i) son[i].clear();
	}
}
```

---

## 作者：attack (赞：2)

$N$这么小肯定直接上暴力呀，但是肯定要优雅一点。

对于初始的$N$个点，每加一条限制实际上就是合并了两个联通块。

那么我们预处理出$val[i]$表示的是$i$节点所在的联通块根节点转了$1$圈，该节点会转多少圈

并查集维护联通性以及联通块大小，直接启发式合并就可以了

~~跑的好像还挺快~~

```cpp
#include<bits/stdc++.h>
#define siz(v) ((int)v.size())
using namespace std;
const int MAXN = 2001;
const double eps = 1e-9;
inline int read() {
    char c = getchar(); int x = 0, f = 1;
    while(c < '0' || c > '9') {if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
    return x * f;
}
int N, M, fa[MAXN], siz[MAXN];
double val[MAXN];
vector<int> v[MAXN];
void init() {
    for(int i = 1; i <= N; i++) fa[i] = i, v[i].clear(), siz[i] = 1, val[i] = 1;
}
int find(int x) {
    return fa[x] == x ? fa[x] : fa[x] = find(fa[x]);
}
bool dcmp(double x) {
    return fabs(x) < eps;
}
void mem(int x, int fa, double va) {
    for(int i = 0; i < siz(v[x]); i++) {
        int to = v[x][i];
        if(to == fa) continue;
        val[to] *= va;
        mem(to, x, va);
    }
}
bool solve() {
    N = read(); M = read(); bool flag = 0;   
	init();
    for(int i = 1; i <= M; i++) {
        int x = read(), y = read(), fx = find(x), fy = find(y); double vx = read(), vy = read();
        if(flag) continue;
        if(fx == fy) {if(!(dcmp(val[x] / val[y] - vx / vy))) flag = 1; continue;}
        if(siz[fx] > siz[fy]) swap(x, y), swap(vx, vy), swap(fx, fy);
        val[fx] = vx / vy * val[y] / val[x];
        mem(fx, 0, val[fx]); fa[fx] = fy; v[y].push_back(fx);
        siz[fy] += siz[fx]; siz[fx] = 0;
    }
    return flag ^ 1;
}
int main() {
#ifndef ONLINE_JUDGE
	freopen("a.in", "r", stdin);
#endif
    int T = read();
    for(int i = 1; i <= T; i++) {
        printf("Case #%d: ", i);
        puts(solve() ? "Yes" : "No");
    }
    return 0;
}
```

---

## 作者：Teddy_Di (赞：1)

嗯这题据说double会爆精度，暴力乘会爆longlong。。

所以就暴力取模一发

方法是用dfs，正常算比例是乘上vt除以vf(vt,vf定义见代码)，然后因为要取模所以除法变成算逆元

然后如果是个无环图那就应该没问题，如果是个有环图（一个点能被dfs到不止一次）那就特判一下，看两次遍历的结果是否一致，不一致说明不行

具体见代码

```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<vector>
using namespace std;
typedef long long ll;
const int maxn = 3e3 + 5;
const int maxm = 2e4 + 5;
struct Edge
{
    int from, to;
    ll vt, vf;
    Edge() {}
    Edge(int f, int t, ll _vt, ll _vf)
    {
        from = f, to = t, vt = _vt, vf = _vf;
    }
}e[maxm];
struct Edge1
{
    int from, to;
    ll c;
    Edge1() {}
    Edge1(int f, int t, ll _c)
    {
        from = f, to = t, c = _c;
    }
};
//vector存边
vector<Edge>edge[maxn];
int n, m;
ll node[maxn];
bool vis[maxn];
//本题有负数，取模需要对其加到正后再取，C++负数取模比较诡异
inline ll mod(ll a, ll p)
{
    return ((a%p) + p) % p;
}
void Init()
{
    for (int i = 1; i <= n; i++)
        edge[i].clear();
    memset(vis, 0, sizeof(vis));
    memset(node, 0, sizeof(node));
}
//快速幂，用于算逆元
ll getn(ll a, ll p)
{
    ll ans = 1, b = mod(a, p);
    ll z = p - 2;
    while (z != 0)
    {
        if (z & 1)
        {
            ans *= b;
            ans %= p;
        }
        b *= b;
        b %= p;
        z >>= 1;
    }
    return ans;
};
bool dfs(int u, ll z, ll p)
{
    vis[u] = 1, node[u] = z;
    bool ands = 1;
    bool gg[maxn] = { 0 };
    int sz = edge[u].size();
    for (int i = 0; i < sz; i++)
    {
        int v = edge[u][i].to;
        //已经遍历的情况，并且两次遍历结果一致，说明该点暂时可行
        if (vis[v] && node[v] == (z*edge[u][i].vf % p)*edge[u][i].vt % p)
            gg[i] = 1;
        //如果没被遍历过就往下遍历
        else if (!vis[v])
            gg[i] = dfs(v, (z*edge[u][i].vf % p)*edge[u][i].vt % p, p);
    }
    //必须所有子结点点都可行才可行
    for (int i = 0; i < sz; i++)
        if (gg[i] == 0)
            ands = 0;
    return ands;
}
bool work_work(ll p)
{
    Init();
    for (int i = 1; i <= m; i++)
    {
        //建立无向图
        edge[e[i].from].push_back(Edge(e[i].from, e[i].to, getn(e[i].vf, p), mod(e[i].vt, p)));
        edge[e[i].to].push_back(Edge(e[i].to, e[i].from, getn(e[i].vt, p), mod(e[i].vf, p)));
    }
    int flag = 1;
    //图不一定连通，需要判定每一个连通的部分是否可行
    for (int i = 1; i <= n; i++)
        if (!vis[i])
            flag = ((dfs(i, 1, p) == true) ? flag : false);
    return flag;
}
void work(int i)
{
    memset(e, 0, sizeof(e));
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; i++)
        scanf("%d%d%lld%lld", &e[i].from, &e[i].to, &e[i].vf, &e[i].vt);
    bool ans = (work_work(1e9 + 7) && work_work(1e9 + 9));
    printf("Case #%d: ", i);
    if (ans)
        printf("Yes\n");
    else
        printf("No\n");
}
int main()
{
    int t;
    scanf("%d", &t);
    for (int i = 1; i <= t; i++)
        work(i);
    return 0;
}
```

---

## 作者：_Sein (赞：0)

考虑$|x_i|$那么小，不如暴力枚举它们的质因数吧!

就是把一个数拆成$\prod p_i^{c_i}$的形式。

这么一个小trick可以使暴力乘得以实现233。

其实再分析一些小性质

**只有环对答案有贡献**，

那么在环上相邻两点，至少有两条路径可以互相到达。

也就是说如果环有问题，那么在环上的任意一对$(x,y)$的运行也有问题。

所以只要求出$(x,y)$的任意一条路径，之后再比较不在这条路径上的这条的边就可以判断是否影响运行了。

其实从这个结论可以发现，

**只要我们遍历一棵树，就可以完美解决此问题**。

对于根，定义它的旋转次数为$1$

那么对于$x$，$y$的旋转次数就是$\frac{w_x*e_{k_1}}{e_{k_2}},\frac{e_{k_1}}{e_{k_2}}$即为题面中的$\frac{x}{y}$，再转化成质因数形式即可。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<cstdlib>
#define gc getchar()
#define ll long long
#define ull unsigned long long
#define file(s) freopen(s".in","r",stdin);freopen(s".out","w",stdout)
#define I inline 
using namespace std;
const int N=1e3+5,M=1e4+5;const ull G=31;
const int P[30]={0,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97};
template<class o>I void qr(o &x)
{
	char c=gc;int f=1;x=0;
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=gc;}
	while(c>='0'&&c<='9'){x=x*10+(c^48);c=gc;}
	x*=f;
}
template<class o>I void qw(o x)
{
	if(x<0)x=-x,putchar('-');
	if(x/10)qw(x/10);
	putchar(x%10+48);
}
ll gcd(ll a,ll b){return !b?a:gcd(b,a%b);}
struct edge{int x,y,next,w1,w2;}a[M<<1];int len,last[N];
void ins(int x,int y,int w1,int w2){a[++len]=(edge){x,y,last[x],w1,w2};last[x]=len;}
int cnt[N][27],lg[105][27],op[N];
bool ve[M<<1],vis[N];
void dfs(int x,int lst)
{
	vis[x]=1;
	for(int k=last[x],y;k;k=a[k].next)
		if(lst!=(k^1))
		{
			y=a[k].y;
			if(vis[y]){ve[k]=ve[k^1]=1;continue;}
			for(int i=1;i<=25;i++)
				cnt[y][i]=cnt[x][i]-lg[abs(a[k].w1)][i]+lg[abs(a[k].w2)][i];
			if(a[k].w1<0||a[k].w2<0)op[y]=op[x]*-1;
			else op[y]=op[x];
			dfs(y,k); 
		}
}
int main()
{
	int T;qr(T);
	for(int i=2;i<=100;i++)
	{
		int x=i;
		for(int j=1;j<=25;j++)
			if(x%P[j]==0)
				while(x%P[j]==0)x/=P[j],++lg[i][j];
	}
	for(int Case=1;Case<=T;Case++)
	{
		memset(last,0,sizeof(last));len=1;
		memset(ve,0,sizeof(ve));memset(vis,0,sizeof(vis));
		memset(cnt,0,sizeof(cnt));memset(op,0,sizeof(op));
		int n,m;qr(n),qr(m);
		for(int i=1,x,y,w1,w2;i<=m;i++)qr(x),qr(y),qr(w1),qr(w2),ins(x,y,w1,w2),ins(y,x,w2,w1);
		for(int i=1;i<=n;i++)
			if(!vis[i])
			{
				op[i]=1;
				dfs(i,0);
			}
		bool bk=1;
		for(int i=1;i<=len;i++)
			if(ve[i])
			{
				ve[i]=ve[i^1]=0;
				int x=a[i].x,y=a[i].y,w1=a[i].w1,w2=a[i].w2;
				int flag=1;
				if(w1<0||w2<0)flag*=-1;
				if(op[x]*flag!=op[y]){bk=0;break;}
				for(int j=1;j<=25;j++)
					if(cnt[x][j]-lg[abs(w1)][j]+lg[abs(w2)][j]!=cnt[y][j])
					{
						bk=0;break;
					}
				if(!bk)break;
			}	
		printf("Case #%d: ",Case);
		if(!bk)puts("No");
		else puts("Yes");
	}
	return 0;
}
```

---


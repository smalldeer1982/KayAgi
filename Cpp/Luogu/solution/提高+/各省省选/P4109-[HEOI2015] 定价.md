# [HEOI2015] 定价

## 题目描述

在市场上有很多商品的定价类似于 999 元、4999 元、8999 元这样。它们和 1000 元、5000 元和 9000 元并没有什么本质区别，但是在心理学上会让人感觉便宜很多，因此也是商家常用的价格策略。不过在你看来，这种价格十分荒谬。于是你如此计算一个价格 $p$（$p$ 为正整数）的荒谬程度：

1. 首先将 $p$ 看做一个由数字组成的字符串（不带前导 $0$）；
2. 然后，如果 $p$ 的最后一个字符是 $0$，就去掉它。重复这一过程，直到 $p$ 的最后一个字符不是 $0$；
3. 记 $p$ 的长度为 $a$，如果此时 $p$ 的最后一位是 $5$，则荒谬程度为 $2a - 1$；否则为 $2a$。

例如，$850$ 的荒谬程度为 $3$，而 $880$ 则为 $4$，$9999$ 的荒谬程度为 $8$。

现在，你要出售一样闲置物品，你能接受的定价在 $[L, R]$ 范围内，你想要给出一个荒谬度最低的价格。

## 说明/提示

- 对于 $20\%$ 的数据，$L, R \leq 2000$；
- 对于 $100\%$ 的数据，$T \leq 100$，$1 \leq L \leq R \leq 10^9$。

## 样例 #1

### 输入

```
3
998 1002
998 2002
4000 6000```

### 输出

```
1000
1000
5000```

# 题解

## 作者：fyfy (赞：41)

这是今天的考试题，我来发一波～

看L和R的范围，显然不能一个一个加，这样会有很多重复情况，会超时，只要看该数有多少个后导0，就把L加上10的多少次方。

很容易可以想到价格后面尽可能多0,在此基础上需要尽量最后一个数字是5。 那么我们可以想到每次更新的时候尽量跳10^N。

用一重while循环，从L开始往R找，因为题目要输出最小的一个值，还有当ANS为1是，代码会跑的飞快，嘿嘿～

我的代码短，希望能通过审核～

```
#include <bits/stdc++.h>
using namespace std;

long long l,r,T;
long long mn=999999999999,ans;

int main()
{
	freopen("price.in","r",stdin);
	freopen("price.out","w",stdout);
	cin>>T;
	while (T--) {
		scanf("%lld%lld",&l,&r);
		while (l<=r) {
			long long x=l,cnt=0;
			while (x%10==0) x/=10,++cnt;
			long long y=x,len=0,f=x%10;
			while (y) y/=10,++len;
			long long p=0;
			if (f==5) --p;
			p+=2*len;
			if (mn>p) mn=p,ans=l;
			l+=pow(10,cnt);
		}
		printf("%lld\n",ans);
		mn=999999999999;
	}
	return 0;
}
```

---

## 作者：浅色调 (赞：16)

### Solution:

　　本题贼有意思，直接打表找下规律，然后直接数列分块就好了。

　　打表思路就直接照题目求每个数的过程模拟。

　　我们打表不难发现，当每次隔$100000$个数统计一次答案时，只有$[1,100000]$答案为$5$，其余的均为整十万（比如$[100001,200000]$答案为$200000$，$[200001,300000]$答案为$300000$等等），然后缩小范围每次隔$10000$、$1000$、$100$，都只有第一次的答案为$5$，其余的分别为整万、整千、整百。

　　于是，数列分块的思路就比较清晰了。

　　本着大段维护小段暴力的思路，我选择每$10000$个数一个块，每次读入的区间若相差小于$50000$就直接暴力枚举，否则的话就搞分块思想，两端多出来的两个非完整的块暴力枚举求出最优解，然后枚举求出区间包含的块内的最优解并更新答案，输出就好了。

　　最坏情况就是100组数据均为$[1,10^9]$，这样就得跑五千多万次，反正能过。

　　当然按$\sqrt n$ 分块更合理，复杂度也更加理想。

$\;\;\quad$欢迎来踩博客：[five20](https://www.cnblogs.com/five20/p/9323079.html)（蒟蒻写题解不易，转载请注明出处，万分感谢！）

### 代码：
```cpp
#include<bits/stdc++.h>
#pragma GCC optimize(2)
#define il inline
#define ll long long
#define For(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)
#define Bor(i,a,b) for(int (i)=(b);(i)>=(a);(i)--)
using namespace std;
int T,n,m;
int s[100005];

il int gi(){
    int a=0;char x=getchar();
    while(x<'0'||x>'9')x=getchar();
    while(x>='0'&&x<='9')a=(a<<3)+(a<<1)+x-48,x=getchar();
    return a;
}

il int check(){
    int p,t,h,minn=0x7fffffff,ans;
    For(i,n,m) {
        p=i,t=0;
        while(p%10==0)p/=10;
        h=p%10;
        while(p) p=p/10,t++;
        if(h%5==0){
            if(minn>t*2-1)ans=i,minn=t*2-1;
        }
        else {
            if(minn>t*2)ans=i,minn=t*2;
        }
    }
    return ans;
}

int main(){
    s[0]=5;
    For(i,1,100000) s[i]=(i+1)*10000;
    T=gi();int p,t,h,minn,ans;
    while(T--){
        n=gi(),m=gi();
        if(m-n<=50000) printf("%d\n",check());
        else {
            int l=n/10000+1,r=m/10000-1;
            minn=0x7fffffff;
            For(i,n,l*10000){
                p=i,t=0;
                while(p%10==0)p/=10;
                h=p%10;
                while(p) p=p/10,t++;
                if(h%5==0){
                    if(minn>t*2-1)ans=i,minn=t*2-1;
                }
                else {
                    if(minn>t*2)ans=i,minn=t*2;
                }
            }
            For(i,r*10000+1,m){
                p=i,t=0;
                while(p%10==0)p/=10;
                h=p%10;
                while(p) p=p/10,t++;
                if(h%5==0){
                    if(minn>t*2-1)ans=i,minn=t*2-1;
                }
                else {
                    if(minn>t*2)ans=i,minn=t*2;
                }
            }
            For(i,l,r){
                p=s[i],t=0;
                while(p%10==0)p/=10;
                h=p%10;
                while(p) p=p/10,t++;
                if(h%5==0){
                    if(minn>t*2-1)ans=s[i],minn=t*2-1;
                }
                else {
                    if(minn>t*2)ans=s[i],minn=t*2;
                }
            }
            printf("%d\n",ans);
        }
    }
    return 0;
}
```

---

## 作者：_Lemon_ (赞：9)

根据题意，很容易可以想到价格后面尽可能多0,在此基础上需要尽量最后一个数字是5。
那么我们可以想到每次更新的时候尽量跳10^N(就算是10，10^9/10=10^8也大概可以卡过)并且因为需要输出最小的，所以要从小开始找
PS：判断ANS=1会很快。
```
#include<bits/stdc++.h>
using namespace std;
long long deal(long long k)
{
	int len=0;
	while(k>0)
	{
		k/=10;
		len++;
	}
	long long Lemon=1;
	for(int i=1;i<len;i++)
		Lemon*=10;
	return Lemon;
}
int get(long long k)
{
	int Lemon=0,answer=0;
	while(k%10==0) k/=10;
	if(k%10==5) Lemon=1;
	while(k>0)
	{
		k/=10;
		answer++;
	}
	return answer*2-Lemon;
}
void solve()
{
	int ans=1000005;
	long long l,L,R,cha,ansnum;
	scanf("%lld%lld",&L,&R);
	cha=R-L;
	cha=min(cha,L);
	long long Lemon=deal(cha);
	l=L-(L%Lemon);
	while(1)
	{
		if(l>=L) 
			if(ans>get(l)) 
				{
					ans=get(l);
					ansnum=l;
				}
		l+=Lemon;
		if(l>R) break ;
		if(ans==1) break ;//记得特判一
	}
	printf("%lld\n",ansnum);
	return ;
}
int main()
{
	int T;
	cin>>T;
	for(int cao=1;cao<=T;cao++)
		solve();
	return 0;
}
```

---

## 作者：luozhichen (赞：7)

[题目直通车](https://www.luogu.com.cn/problem/P4109)

## 题目大意：

让你在一个区间内选一个数，使得这个数荒谬度最小。

**荒谬度**：把那个数的末尾的 0 全部消掉之后的长度的两倍。如果删完后的末尾是 5 的话，就再减个 1。

## 思想：

先看它的位数，让 $ans$ 的初始值位 $l$ 的最高位，然后在后面加上很多 0（就是 $cj$ )，直到和 $l$ 的位数相等。此时，让 $ans$ 最高位持续加 1，如果到了 $l$ 到 $r$ 中的话那就看一下除了 0 后最后一位能不能是 5。如果 $ans$ 一次都加不了的话那就将 $cj$ 减个 0。

举例1：

998 1002

$ans$ 初始为 900，后变为 1000，发现不能变为 5000，所以答案为 1000。

举例2：

3999 6000

$ans$ 初始为 3000，后变为 4000，发现可以为 5000，所以答案为 5000。

举例3：

123 129

$ans$ 初始为 100，发现不能加 100，于是就看能不能加 10，加到 120 后，发现也加不了，就只能加 1。加到 123 后发现可以了，结果发现可以为 125。于是，最后输出 125。

## 代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t;
int l,r;
int ws2,ans,wss,cj = 1;
int cont;
signed main(){
	cin >> t;
	for(int i = 1;i <= t;i++){
		cin >> l >> r;
		wss = 0;//注意要初始化，这害的我检查了30min 
		ws2 = 0;
		cont = 0;
		cj = 1;
		ans = 1;
		int ll = l;
		while(ll > 0){//判断l位数 
			if(ll <= 9 && ll >= 1){
				ans = ll;
				cj *= 10;
			}
			ll /= 10;
			cj *= 10;
			wss++; 
		}
		cj /= 100;//后有多少0 
		int rr = r;
		while(rr > 0){//判断r位数 
			rr /= 10;
			ws2++;
		}
		ans *= cj;//ans初始化 
		if(5 * cj <= r && 5 * cj >= l){//判断是否能直接为5后面加0 
			cout << 5 * cj << endl;
		}else{
			while(ans <= r){//在r以内 
				if(ans < l){//还没符合要求 
					ans += cj;
					if(ans > r){//发现一加上就超了 
						ans -= cj;//减回去 
						cont = ans;
						cj /= 10;//cj去个0再继续加 
					}
				}else if(ans >= l && ans <= r){//在范围内 
					int ij = wss;
					int cjj = cj;
					int pd = 0;
					while(ij <= ws2){//判断是否可以为5 
						if((cjj * 5 + cont ) <= r && (cjj * 5 + cont) >= l){//可以的话就输出 
							cout << cjj * 5 + cont << endl;
							pd = 1;
							break;
						}
						ij++;
						cjj *= 10;//如果不行就继续增大看 
					}
					if(pd == 1){
						break;
					}else{//否则就输出原来的 
						cout << ans << endl;
						break;
					}
				}
			}
		}
	}
	return 0;
}
```

写题解不易，点个赞再走吧！！！

---

## 作者：Su_Zipei (赞：6)

由于思维僵化所以上来就莽了数位$DP$

考虑到荒谬度的取值很少，所以可以直接枚举荒谬度然后使用 $DP$ 检验。

$DP$ 过程中，只考虑末尾的 $0$ 和末尾的连续数字即可，通过记忆化避免重复搜索一个状态，只要搜到一个可行解直接退出循环。

挺板子的，也十分好写，并且不用动脑子。。。

```
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=35;
#define rint register int
bool f[N][N][N][2];
int num1[N],num2[N],tt,tot,now;
void chai(rint *a,int x){
	tt=0;
	while(x){
		a[++tt]=x%10;
		x/=10;
	}
	tot=max(tot,tt);
}
bool dfs(rint hh,rint lim1,rint lim2,rint qdl,rint s1,rint s2,rint fiv,rint x){
	if(!hh){
		rint val=s1*2-fiv;
		if(val==now){
			printf("%d\n",x);
			return 1;
		}else return 0;
	}
	if(!qdl&&!lim1&&!lim2&&f[hh][s1][s2][fiv])return 0;
	rint Min=lim1?num1[hh]:0,Max=lim2?num2[hh]:9;
	for(rint i=Min;i<=Max;i++){
		if(qdl){
			if(i==0){
				if(dfs(hh-1,lim1&&i==Min,lim2&&i==Max,1,0,0,0,0))return 1;
			}else {
				if(dfs(hh-1,lim1&&i==Min,lim2&&i==Max,0,s1+1+s2,0,i==5,x*10+i))return 1;
			}
		}else {
			if(i==0){
				if(dfs(hh-1,lim1&&i==Min,lim2&&i==Max,0,s1,s2+1,fiv,x*10))return 1;
			}else {
				if(dfs(hh-1,lim1&&i==Min,lim2&&i==Max,0,s1+1+s2,0,i==5,x*10+i))return 1;
			}
		}
	}
	if(!qdl&&!lim1&&!lim2)f[hh][s1][s2][fiv]=1;
	return 0;
}
int main(){
	rint T;
	scanf("%d",&T);
	while(T--){
		memset(num1,0,sizeof(num1));
		memset(num2,0,sizeof(num2));
		rint L,R;tot=0;
		scanf("%d%d",&L,&R);
		chai(num1,L);chai(num2,R);
		for(now=1;;now++){
			memset(f,0,sizeof(f));
			if(dfs(tot,1,1,1,0,0,0,0))break;
		}
	}
	return 0;
}


```


---

## 作者：moosssi (赞：4)

首先，这道题暴力枚举是要超时的，一个一个跳太慢了，运用分块思想，我们就可以把区间划分成一段一段的，这时，我们就要去想每段大概多长：

一般的分块区间长度都是$\sqrt{n}$，但这道题这样分不好做，由题目规定的荒谬值计算规则，我们可以发现尾数零越多越好（可以打表观察），我就把每段长度设为了10000，刚好不会超时，每次跳的时候只管能整除10000的数，对于l，r相差较小的可以直接枚举，代码如下
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,len;
int han(int x){//计算荒谬值的函数 
	int res=0,last;
	while(x&&x%10==0)x/=10;
	last=x%10;
	while(x){
		res+=2;
		x/=10;
	}
	if(last==5)res--;
	return res;
}
int find(int l,int r){
	int ans,minn=0x3f3f3f3f;
	if(r-l<=len){//区间长度小的，暴力枚举 
		for(int i=l;i<=r;i++){
			int x=han(i);
			if(x<minn)minn=x,ans=i;
		}
	}
	else {
		int i=l,j=r;
		while(i%len)i++;//先把区间两边都跳到len的整数倍 
		while(j%len)j--;
		for(int k=l;k<i;k++){//两边多余的暴力计算 
			int x=han(k);
			if(x<minn)minn=x,ans=k;
		}
		for(int k=i/len;k<=j/len;k++){//中间每次跳len的长度，只用看len整数倍的数 
			int x=han(k);
			if(x<minn)minn=x,ans=k*len;
		}
		for(int k=j+1;k<=r;k++){
			int x=han(k);
			if(x<minn)minn=x,ans=k;
		}
	}
	return ans;
}
int main(){
	scanf("%d",&n);
	len=10000;
	int l,r;
	for(int i=1;i<=n;i++){
		scanf("%d%d",&l,&r);
		printf("%d\n",find(l,r));
	}
	return 0;
} 
```


---

## 作者：龙翔凤翥 (赞：4)

#### 一个一个模拟就行
注意可以优化，比如当算完１０００的时候，１００１～１９９９都没必要算了，肯定没１０００的优秀
```cpp
#include<bits/stdc++.h>
using namespace std;
#define RN register int
int t;
int f[101];
int ans;
inline int read()
{
    int k=1;int x=0;
    char c=getchar();
    while ((c<'0'||c>'9')&&c!='-')c=getchar();
    if(c=='-')
        k=-1,c=getchar();
    while(c>='0'&&c<='9')
        x=x*10+c-'0',c=getchar();
    return k*x;
}
inline int gett(int x)
{
	while(x%10==0)
		x/=10;
	int t=x%10;
	int len=0;
	while(x)
		x/=10,len++;
	return (t==5)?2*len-1:2*len;
}
inline int size(int x)
{
	int sum=0;
	while(x%10==0)
		x/=10,sum++;
	return sum;
}
int main()
{

	f[0]=1;
	for(RN i=1;i<=9;i++)
	{
		f[i]=f[i-1]*10;
	}
	t=read();
	while(t--)
	{
		int l,r,minn=0x7fffffff;
		l=read(),r=read();
		for(RN i=l;i<=r;i+=f[size(i)])
		{
			//	cout<<i<<endl;
			if(minn>gett(i))
				minn=gett(i),ans=i;
		}
		printf("%d\n",ans);
	}
	return 0;
}

```

---

## 作者：Zack_zhu (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P4109)  
## 前言  
本题有多种解法，此题解为分块做法。
## 题目分析  
这个题就是求一个数 $x$ ，$x$ $\in$ $[L , R]$ ，这个数要保证末尾 $0$ 最多，然后尽量保证去掉 $0$ 后结尾为 $5$ 。  
其实这道题我拿到后第一个想法是数位 $dp$ ，但我找到这道题的目的是练分块，所以我就拿分块做了。  
经枚举或玄学推法可知，在 $[1,10000]$ 中 $5$ 是最优解，$[10000,20000]$ 中 $10000$ 是最优解，$[20000,30000]$ 中 $20000$ 是最优解。  
于是盲猜**在以 $10000$ 为块长分块时，范围的左边端点为答案。（ $[1,10000]$ 除外，为5）。**  
## 证明  
1. 因为这中间的数（不包括端点）的荒谬度一定大于2（把后置 $0$ 去完至少为两位数），所以**中间的数的荒谬度一定大于左右端点**。  
我们又要求最低的价格，左边小于右边，所以选左端点。  
1. 为什么选$10000$为块长？~~因为它跑出来最快啊~~，其实块长只要是 $5 * 10 ^ {x}$ 的**同长度因数** ( $eg$ : $1 * 10 ^ {x}$ ，$2.5 * 10 ^ {x}$  )。  
但 $200$ 就不行，因为 $200$ 不是 $500$ 的因数。[错误示范](https://www.luogu.com.cn/record/50509945)    
建议选 $10000$ ，接近 $\sqrt{1e9}$ 且满足题意，其他~~奇奇怪怪~~的块长可能会 $TLE$。  
## 代码
```cpp
	#include <cstdio>
	#include <iostream>
	#include <cstring>
	#include <algorithm>
	#include <cmath>
	using namespace std;
	int ans,num,now;
	template <typename T>
	inline void read(T &s)
	{
		s = 0;
		bool w = false;
		char ch = getchar();
		while(ch < '0'||ch > '9')
		{
			if(ch == '-')
				w = true;
			ch = getchar();
		}
		while(ch >= '0'&&ch <= '9')
		{
			s = (s<<3)+(s<<1)+(ch^48);
			ch = getchar();
		}
		s = w == true ? -s:s;
		return;
	}
	inline int qpow(int x,int y)
	{
		int ans = 1;
		while(y)
		{
			if(y & 1)
				ans *= x;
			x *= x;
			y >>= 1;
		}
		return ans;
	} 
	inline int cl(int x)//暴力处理（按题意模拟） 
	{
		while(x % 10 == 0)
		{
			x /= 10;
		}
		int i = 1;
		while(qpow(10,i) <= x)
			i++;
		if(x % 10 != 5)
			return i*2;
		else
			return i*2-1;
	} 
	int main()
	{
		int t,l,r;
		read(t);
		int block = 10000;
		while(t--)
		{
			read(l);
			read(r);
			ans = 0x3f3f3f3f;
			if(l / block == r / block)//在同一块内暴力处理 
			{
				for(int i = l;i <= r;i++)
				{
					now = cl(i);
					if(ans > now)
					{
						ans = now;
						num = i;
					}
				}
			}
			else
			{
				for(int i = l;i < ((l + block) / block) * block;i++)//块前的暴力处理 
				{
					now = cl(i);
					if(ans > now)
					{
						ans = now;
						num = i;
					}
				}
				for(int i = ((l + block) / block) * block;i <= (r / block) * block;i += block)//连续块的处理 
				{
					now = cl(i);
					if(ans > now)
					{
						ans = now;
						num = i;
					}
				}
				for(int i = (r / block) * block;i <= r;i++)//块后的处理 
				{
					now = cl(i);
					if(ans > now)
					{
						ans = now;
						num = i;
					}
				}
			}
			printf("%d\n",num);
		}
		return 0;
	}
```


---

## 作者：灯芯糕 (赞：3)

### 分类讨论大法好！

### $solution:$

先说一下我对这个题目的态度：

首先这一题是贪心，这个十分明显，看了一眼其他题解都是十分优秀的贪心，可是大家都没有想过吗：你们贪心都是在区间$[l,r]$上枚举的贪心，虽然每一次可以直接加上 10 的阶乘，但你们毕竟是用的$int$，$long long$　啊！。这一题得正解复杂度是$log_{10}(n)$的，不得不说题目的数据范围给的太小了只有$10^9$ ，如果按照复杂度，数据范围甚至可以到$10^{10000000}$级别，这个时候你们难道还能在区间$[l,r]$上枚举吗？（高精怕都要超时！）

所以虽然分类讨论十分麻烦，甚至代码很长，但它才应该是真正意义上的正解啊！（当然，考场见机行事）

#### 好的，不做“推销”了，我们进入正文。

首先这一题，我们可以用字符串的方式读入两个端点值。然后如果我们仔细读题，就可以发现一些**贪心方案**：

1. 我们要让最终的价格数的高位上不是0的数尽可能的少！（当然，要在末尾全是0的基础上）
2. 只有当不是0的数确定下来，我们再来判断最后一个不是0的数能否为5！
3. 如果最后一个不是0的数不能为5，我们就要让最后一个不是0的数尽可能的小！
4. 让最终得到的价格数尽可能的小！

开始讨论之前先让你们有个思维准备：先看看下面代码有多少个$continue$，我们大概就要讲多少种情况。首先我们准备一个快写函数：将字符串$s$前$j-1$位输出，然后将第$j$为换成字符$k$，再输出$n$个0

然后为了涵盖多种情况，我们发现如果两个数的长度不一样，是很难讨论的。于是我们分三种情况：（两个数长度差了2位或以上）（两个数的长度差为1）（两个数长度相同）

**两个数长度差了2位或以上**：（这个想一下，我们发现只有两种情况

1. 如果较小的数的最高位比5小，就换成5输出（要特判5,50,500,5000......）
2. 否则将较小的数的最高位换成5，再乘上10输出。

**两个数的长度差为1**：（比上面要多一种情况）

1. 如果较小的数的最高位比5小，就换成5输出（要特判5,50,500,5000......）
2. 如果较大的数的最高位大于等于5，将较大的数的最高位换成5，输出。
3. 将较小的的数的最高位上的数加1，然后全接0.（要特判如10,60,300等（高位不用加1））

**两个数长度相同**：这个我们仔细想一下就会发现如果这两个数的高位相同，那么这些相同的高位可以直接输出了，所以我们放个循环$O(n)$找到不同的那一位，然后我们发现这一位后面的数可以忽略了（一定会被填成0的，因为贪心第一点：要让最终的价格数的高位上不是0的数尽可能的少）而针对这一位能否填成5，我们又有四中情况：

1. 这两个数完全相同，这个直接输出
2. 较小的数的这一位小于5，较大的数的这一位大于5，将这一位改成5输出（不需要特判5,50...这个归到下一类）
3. 较小的数这一位后面全是0，直接输出
4. 较小的数这一位后面不全是0，将这一位+1，然后输出。

##### 凭心而论：这一题情况并不算多（详见猪国杀）

对了，我们上文有提到一些需要特判的东西，这个只需要，在开始时用一个变量$f$来记录较小的数从那一位开始之后全是0即可！

### $code:$

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define rg register int

using namespace std;

int t,a,b,f;
char l[11];
char r[11];

inline void qw(char s[],int j,char k,int n){//有这个函数输出就方便多了
	for(rg i=0;i<j;++i)putchar(s[i]);
	k>'9'?printf("10"):putchar(k);
	for(rg i=1;i<=n;++i)putchar('0');
	puts("");
}

int main(){ cin>>t;
    //freopen("Price.in","r",stdin);
    //freopen("Price.out","w",stdout);
    while(t--){
        cin>>l>>r;
		f=a=strlen(l)-1;
		b=strlen(r)-1;
		while(l[f]=='0')--f;//记录从那一位开始后面全是0
		if(b-a>1){//差一位以上
			if(l[0]<'5'||(l[0]=='5'&&f==0)){qw(l,0,'5',a);continue;}
			qw(l,0,'5',a+1);continue;
		}if(b-a>0){//差一位
			if(l[0]<'5'||(l[0]=='5'&&f==0)){qw(l,0,'5',a);continue;}
			if(r[0]>='5'){qw(l,0,'5',b);continue;}
			if(f==0){qw(l,0,l[0],a);continue;}
			qw(l,0,l[0]+1,a);continue;
		}int i=0;while(l[i]==r[i]&&i<=a)++i;//找到不同的哪一位
		if(i>a||f<i){qw(l,a,l[a],0);continue;}
		if(l[i]<'5'&&r[i]>='5'){qw(l,i,'5',a-i);continue;}
		if(f==i){qw(l,i,l[i],a-i);continue;}
		qw(l,i,l[i]+1,a-i);
    }
    return 0;
}

```

情况都是按上文顺序写的，但本人还是很菜可能思虑不周，欢迎大家来hack（hack成功了麻烦提醒一下，O(∩_∩)O谢谢）

---

## 作者：SisconHL (赞：2)

为了题号的信仰把这道题给过了，一开始还被虚高的难度和吓着了。

这个东西直接模拟是刚好要炸的，但是优化也很简单。

举个很简单的例子，当前最好的是 $100$，那 $101\sim499$ 的我都能不管了，因为它们又贵又荒谬。

所以说如果找到了末尾是 $0$ 的就把前面那些更加荒谬的跳过了。

但是你还是保证每次循环价格要增加啊，所以如果不符合就跳到下一个整除 **5** 的。

代码也就半 k：

```cpp
#include<iostream>
#define Orika std
using namespace Orika;
int stOrika(int x){while(x%10==0)x/=10;int res=0;if(x%10==5)res--;while(x)x/=10,res+=2;return res;}
void work(){
    int a,b;
    cin>>a>>b;
    int Min=419,booky,cur=a;
    while(cur<=b){
        if(stOrika(cur)<Min)booky=cur,Min=stOrika(cur);
        if(cur%10){cur=(cur/5+1)*5;continue;}
        for(int i=1e5;i>=10;i/=10)if(cur%i==0){cur=(cur/i+1)*i;break;}
    }
    cout<<booky<<endl;
}
int main(){
    int T;cin>>T;
    while(T--)work();
}
```

---

## 作者：G_A_TS (赞：1)

此题乍看会超时  
但是我考试时本想暴力骗分  
结果优化着优化着发现好像不超了，~~**于是A掉**~~


------------
本题暴力递归（贪心）可做  
至于优化，想通一个点即可：  
**为什么不加指数？**  
想到**10的幂**就好办了  

------------

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,L,R,minn=0,res=1,cs=1,pd;
long long pdd(long long x,long long y)
{
	for(long long i=x;i<=y;i++)
	{
		if(i%10==0||i%10==5)
		{
			return 0;
		}
	}
	return 1;
}
long long ws(long long x)
{
	long long tot=0;
	for(long long i=1;i<=x;i*=10)//*=10重要！
	{
		tot++;
	}
	return tot;
}
long long Cmp(long long x,long long y)
{
	for(;;)
	{
		if(x%10==0)
		{
			x/=10;
		}
		if(y%10==0)
		{
			y/=10;
		}
		if(x%10!=0&&y%10!=0)
		{
			if(ws(x)<ws(y))
			{
				return 1;
			}
			else
			{
				if(ws(x)==ws(y))
				{
					if(y%10==5)
					{
						return 0;
					}
					if(x<y||x%10==5)
					{
						return 1;
					}
					else
					{
						return 0;
					}
				}
				else
				{
					return 0;
				}
			}
		}
	}
}
long long findd(long long x,long long y)
{
	if(x>y)
	{
		return 0;
	} 
	if(Cmp(x,res))
	{
		res=x;
	}
	if(x%(cs*10)==0)
	{
		cs*=10;
	}
	findd(x+cs,y);
	return 0; 
}
int main()
{
	//freopen("price.in","r",stdin);
	//freopen("price.out","w",stdout);
	cin>>n;
	for(int js=1;js<=n;js++)
	{
		cin>>L>>R;
		if(R-L<10)
		{
			int tmppdd;
			tmppdd=pdd(L,R);
			if(tmppdd==1)
			{
				cout<<L<<endl;
				continue;
			}
		}
		res=L;
		pd=0;
		cs=1;
		findd(L,R);
		cout<<res<<endl;
	}
	//cout<<0;
}
```

---

## 作者：伟大的王夫子 (赞：1)

其实，本题根本没有传说中的提高+/省选-难度，也没有用的着什么高级的算法，只需要从简单的枚举，进行一步步优化即可。

首先，很容易想到暴力，就是枚举区间$[L,R]$里的所有正整数，计算出每个数的荒谬值，更新答案即可。

在这里，我们每次枚举时，变量的值只会加一。

那么，有没有办法让每次枚举时加的数变得更多呢？

那么一定会用到一个引理：长度相同的数中，末尾$0$越多的，荒谬值越少。

引理的证明是显然的。

于是，假设我们现在的答案末尾有$x$个$0$，那么我们每次只需枚举时加上$10^x$即可。

那万一加了之后变高了一位怎么办？

如果这样，则设目前枚举的数$i = a \cdot10^x ,x = \max\limits_{x \in \mathbf {N}, 10^x|i} {x}$。

则该操作相当于把$a$加上一。

若$i$变多了一位，则$a$一定也变多了一位。

因为$a$是一个个加变高一位的，所以$a$必定可以被表示为$10$的方幂，那么显然该数的荒谬值不可能比原来的数大。

得证。

code

```cpp
#include <bits/stdc++.h>
using namespace std;
int l, r, val, ans;
int count(int x) {
	int cnt = 0;
	while (x) {
		++cnt;
		x /= 10;
	}
	return cnt;
}
int v(int x) {
	while (!(x % 10)) {
		x /= 10;
	}
	return x % 10 == 5 ? 2 * count(x) - 1 : 2 * count(x);
}
int main() {
	int t;
	cin >> t;
	while (t--) {
		ans = 1e9;
		cin >> l >> r;
		int a = count(l), b = count(r);
		int p = 1;
		for (register int i = l; i <= r; i += p) {
			if (v(i) == 1) {
				val = i;
				break;
			} else {
				int c = v(i);
				if (c < ans) {
					ans = c;
					val = i;
				}
			}
			int z = 0, tmp = i;
			while (!(tmp % 10)) ++z, tmp /= 10;
			p = max(p, (int)pow(10, z));
		}
		printf("%d\n", val);
	}

}
```

个人认为这篇题解还是蛮详细的，毕竟有详细的证明过程。即使是做简单的题，也得养成严谨的解题习惯。

---

## 作者：llmmkk (赞：0)

##### 前言：

提供另一种分块做法。

---

##### 链接：

[P4109](https://www.luogu.com.cn/problem/P4109)

---

##### 题意：

给出一个数荒谬程度的定义：

> 首先将 $p$ 看做一个由数字组成的字符串（不带前导 $0$）；
> 然后，如果 $p$ 的最后一个字符是 $0$，就去掉它。重复这一过程，直到 $p$ 的最后一个字符不是 $0$；
> 记 $p$ 的长度为 $a$，如果此时 $p$ 的最后一位是 $5$，则荒谬程度为 $2a-1$，否则为 $2a$。

有 $T(T\leq100)$ 次询问，每次询问 $[l,r](1\leq l\leq r\leq 10^9)$ 中荒谬程度最低的数。

---

##### 分析：

考虑分块，设块长为 $B$，块两边的数直接暴力算。考虑中间块怎么做。对于一个 $[2000,6000]$ 的询问，我们发现只需要处理 $a*10^3$ 的这几个数，他们一定比其余的数更优。受到启发我们将块长设成 $10^k$，此时对于中间块，我们就可以直接除以 $10^k$ 缩小范围，之后就可以递归求解。

设暴力算数的荒谬程度的时间复杂度为 $O(p)$。则时间复杂度 $O(\log_B{(r-l+1)}*B*p*T)$。由于我们需要将块长设为 $10^k$，手玩一下发现设块长为 $10$ 比较优。

---

##### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int T;
inline int p(int n){
	if(n==0)return 0x7fffffff;//特判无解
	int tn=n,l=0;
	while(tn)l++,tn/=10;
	while(n%10==0)l--,n/=10;
	if(n%10==5)return l*2-1;
	return l*2;
}
inline int lbin(int l){return (l+9)/10*10;}
inline int rbin(int r){return r/10*10;}//中间块边界
inline int solve(int l,int r){
	if(l>r)return 0;//特判无解
	if(l==r)return l;
	int tl=lbin(l),tr=rbin(r),tans,tp=0x7fffffff;
	for(int i=l,v=p(i);i<min(r,tl);i++,v=p(i))
		if(v<tp)tp=v,tans=i;
	for(int i=max(l,tr+1),v=p(i);i<=r;i++,v=p(i))
		if(v<tp)tp=v,tans=i;
	tl/=10,tr/=10;
	int temp=solve(tl,tr)*10;
	if(p(temp)<tp)tans=temp;
	return tans;
}
signed main(){
	cin>>T;
	while(T--){
		int l,r;cin>>l>>r;
		cout<<solve(l,r)<<'\n';	
	}
	return 0;
}
```

---


---

## 作者：FutaRimeWoawaSete (赞：0)

因为最近要收一些分块题来讲所以就到处乱做了~       

备选 $T1$ 。

此题大概有两种解法，对于一个数我们先拆成最长的后缀 $0$ 部分和其他部分，假设后缀 $0$ 部分长为 $len$ ，令原数为 $a$ ，易证 $[a , a + 10 ^ {len})$ 这一区间的数的荒谬度严格不大于 $a$ 这个数的荒谬度。               

所以我们考虑从 $l$ 枚举，每一次向后枚举都加上 $10 ^ {len}$ 即可。这样做可以保证每至多枚举 $10$ 个数 $len$ 就要 $+1$ ，然后边枚举边更新答案即可，时间复杂度 $O(90T)$。          

然而通过上述的结论也不难想到一种分块做法：我们考虑给一个为 $10$ 的幂次的阈值 $T$，那么每 $T$ 个数分一块，比如阈值为 $10 ^ 5$ 那么就是 $[1 , 10 ^ 5] , [10 ^ 5 + 1 , 2 \times 10 ^ 5] ......$ 这么分块，用上述结论可以知道整块的答案一定为左端点的荒谬度，那么整块 $O(1)$ 散块 $O(\sqrt n)$ 查就可以 $O(9 T \sqrt n)$ 通过此题了。         

```cpp
#include "bits/stdc++.h"
using namespace std;
const int Len = 1e5 + 5;
int n,m,t,qpow[Len],L,R,ans,val;
int F(int x)
{
	int res = 0;
	while(x % 10 == 0)
	{
		x = x / 10;
		res ++;
	}
	return (x % 10 == 5);
}
int nums(int x)
{
	int res = 0;
	while(x % 10 == 0)
	{
		x = x / 10;
		res ++;
	}	
	return res;
}
int rem(int x)
{
	int res = 0 , Zero = nums(x);
	while(x)
	{
		x = x / 10;
		res ++;
	}	
	return res - Zero;
}
int qqpow(int a,int b)
{
	int res = 1;
	while(b)
	{
		if(b & 1) res = res * a;
		a = a * a;
		b = b >> 1;
	}
	return res;
}
int main()
{
	int t;scanf("%d",&t);
	while(t --)
	{
		scanf("%d %d",&L,&R);int gap = 1;ans = 114;
		for(int i = L ; i <= R ; i += gap)
		{
			int w = rem(i) * 2 - F(i);
			if(w < ans) 
			{
				ans = w;
				val = i;
			}
			gap = max(gap , qqpow(10 , nums(i)));
		}
		printf("%d\n",val);
	}
	return 0;
}
```

---

## 作者：joy2010WonderMaker (赞：0)

本蒟蒻第19篇题解

这道题根本不是提高+/省选-难度，只是一道从模拟出发，用了一定数学知识而已。

### 题目分析

首先，在 $[L,R]$ 区间里肯定是 $0$ 越多越好，在满足 $0$ 最多的情况下 $5$ 在除 $0$ 外最低位荒谬度一定最小。

如果我们末尾有 $temp$ 个 $0$，那么每次 $L$ 就可以加上 $10^{temp}$。

如果加上了 $10^{temp}$ 变多了一位也没事，因为荒谬值是不会变的。

### AC Code

```cpp
#include<cstdio>
#include<cmath>
long long ans,sum=1e9,t;
int main(){
    scanf("%lld",&t);
    while(t--){
       long long l,r;
       scanf("%lld %lld",&l,&r);
       while(l<=r){
           long long temp=l,cnt=0;
           while(temp%10==0){//删除前导0
               temp/=10;
	       cnt++;	
	   }
	   long long m=temp%10,f0w=0,hmd=0;
           while(temp){//统计非0位个数
               temp/=10;
               f0w++;
	   }
	   if(m==5)hmd--;//算荒谬度
	   hmd+=2*f0w;
	   if(sum>hmd)sum=hmd,ans=l;
	       l+=pow(10,cnt);//加上一个数
	   }
	   printf("%lld\n",ans);
	   sum=1e9;
    }
    return 0;
}
```


---

## 作者：LightningUZ (赞：0)

## 一篇非常暴力的解法

这个题是我的 [考试题](http://noi.ac/problem/327)，题意还被毒瘤出题人魔改了亿下，所以一时间没找到原题 qaq。

然后就开始讲思路了。

### 主思路

1. 如果 $[l,r]$ 长度 $\le 5\times 10^5$，直接暴力
2. 否则，$[l,r]$ 中一定会有 $10^5$ 的倍数。我们只要逐个检查所有在 $[l,r]$ 内的 $10^5$ 的倍数，就能找到“荒谬度”最小的

#### 第二条中，为啥一定有解？

##### 引理一

设 $len(x)$ 表示 $x$ **去掉后缀 $0$ 后的长度**。

我们要保证，$len(x)$ 最短是第一优先，是不是 $5$ 是第二优先。因为 $2x$ 和 $2x-1$，显然小于 $2(x+1)$ 和 $2(x+1)-1$。

##### 引理二
设 $up(x)$ 表示 $\ge x$ 的最小的 $10^5$ 的倍数，$down(x)$ 表示 $\le x$ 的最大的 $10^5$ 的倍数。然后把 $[l,r]$ 变成 $[up(l),down(r)]$ 不会影响解。

证：

因为显然 $[l,up(l)]$ 之间所有数的 $len$ 都 $\le len(up(l))$。所以，令 $l=up(l)$ 不会错失掉更优的解，$r=down(r)$ 同理。

##### 进入证明

注意上面第二种情况里有一个“否则”，所以此时 $[l,r] \ge 5\times 10^5$。然后显然有 $[up(l),down(r)]\ge 3\times 10^5$。

现在相当于要证明，如果某个数 $x$ 在 $[l,r]$ 之间，并且它不是 $10^5$ 的倍数，那么一定会有一个数是 $10^5$ 的倍数，并且比 $x$ 更优。然后你会发现，$down(x)$ 和 $up(x)$ 肯定有一个在 $[l,r]$ 之间，比 $x$ 更优，并且是 $10^5$ 的倍数。

综上，当 $[l,r]\ge 5\times 10^5$ 时，$[l,r]$ 中最优的解，一定是 $10^5$ 的倍数。

#### 证毕

然后就可以暴力的写代码了。

然后 $100\times 5\times 10^5$ 有点卡，加点小优化 （如果答案为 $1$，这显然是最小的可能答案了，直接退出即可）

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
namespace Flandre_Scarlet
{
    #define int long long
    #define F(i,l,r) for(int i=l;i<=r;++i)
    #define D(i,r,l) for(int i=r;i>=l;--i)
    #define Fs(i,l,r,c) for(int i=l;i<=r;c)
    #define Ds(i,r,l,c) for(int i=r;i>=l;c)
    #define MEM(x,a) memset(x,a,sizeof(x))
    #define FK(x) MEM(x,0)
    #define Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i))
    #define p_b push_back
    #define sz(a) ((int)a.size())
    #define all(a) a.begin(),a.end()
    #define iter(a,p) (a.begin()+p)
    int I()
    {
        int x=0;char c=getchar();int f=1;
        while(c<'0' or c>'9') f=(c=='-')?-1:1,c=getchar();
        while(c>='0' and c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar();
        return (x=(f==1)?x:-x);
    }
    void Rd(int cnt,...)
    {
        va_list args; va_start(args,cnt);
        F(i,1,cnt) {int* x=va_arg(args,int*);(*x)=I();}
        va_end(args);
    }

    int l,r;
    void Input()
    {
        Rd(2,&l,&r);
    }

    int len(int x) // x 的长度 (这里保证 x 已经经过了去 0 处理)
    {
        int ans=0; while(x) x/=10,++ans;
        return ans;
    }
    int calc(int x) // 计算 x 的“荒谬度”
    {
        while(x%10==0) x/=10;
        return (x%10==5)?2*len(x)-1:2*len(x);
    }
    void Soviet()
    {
        if (r-l<=5e5) // 如果长度 <=5e5，直接暴力
        {
            int ans=2e9,ansk;
            F(i,l,r)
            {
                int cur=calc(i);
                if (cur<ans) ans=cur,ansk=i;
                if (ans==1) break; // ans==1 直接 break
            } 
            printf("%lld\n",ansk); 
            return;
        }
        else
        {
            int ans=2e9,ansk;
            F(i,0,1e4) // 枚举 1e5 的 i 倍
            {
                if (l<=i*1e5 and i*1e5<=r) // 判断它是否在 [l,r] 内 
                {
                    int cur=calc(i);
                    if (cur<ans) ans=cur,ansk=i*1e5; // 更新下答案~
                }
            }
            printf("%lld\n",ansk);
            return;
        }
    }

    #define Flan void
    Flan IsMyWife()
    {
        int t=I();
        F(i,1,t)
        {
            Input();
            Soviet();
        }
    }
    #undef int //long long
}
int main()
{
    Flandre_Scarlet::IsMyWife();
    getchar();getchar();
    return 0;
}
```

---

## 作者：木木！ (赞：0)

$\Theta(logn)$贪心，比别家的`continue`少了些qwq……

不得不说，这题还是挺恶心的qwq

首先，可以发现我们要末尾尽量多的0，在此基础上，结尾尽量为5。所以就很容易想到贪心。如果离l最近的$5\times10^x$形式的数比r小的话，就输出那个数。如果$y\times 10 ^x$形式的数比r小的话，输出那个数。

否则呢？

否则的话，答案的第一位一定是l的第一位，可以将那一位输出，然后l和r都变为其剩余位。这就完成了一次转化。可以证明，这样的转化是正确的。

注意，将l和r变为剩余位的时候，还要记录一个变量表示“前导0”的数量。细节……也就那么些。毕竟我平生最讨厌特判，代码中并列`if`超过3个就受不了qwq。

附AC代码，欢迎hack

```cpp
#include <cstdio>
using namespace std;

#define int long long //七年OI一场空，不开long long见祖宗

int digit(int x) //求位数，logn的复杂度
{
	int d = 0;
	while(x)
	{
		++d;
		x /= 10;
	}
	return d;
}

int headd(int x) //求第一个数，用于迭代的时候输出
{
	while(x/10)
	{
		x /= 10;
	}
	return x;
}

int fived(int x,int dig) //求离x最近的整5数（dig表示算上前导0后的位数）
{
	if(digit(x)==dig)
	{
		int res = 0;
		int tmp = 1;
		while((x+4)/10)
		{
			res += x%10;
			tmp *= 10;
			x /= 10;
		}
		if(x==5)
		{
			if(res)
			{
				return 50*tmp;
			}
			else
			{
				return 5*tmp;
			}
		}
		return 5*tmp;
	}
	else
	{
		int tmp = 1;
		for(int i=1; i<dig; ++i)
		{
			tmp *= 10;
		}
		return 5*tmp;
	}
}

int lastd(int x) //求x去掉第一位后剩余的数
{
	int res = 0;
	int tmp = 1;
	while(x/10)
	{
		res += (x%10)*tmp;
		tmp *= 10;
		x /= 10;
	}
	return res;
}

int minid(int x,int dig) //求离x最近的整y数（dig与fived含义一样）
{
	if(digit(x)==dig)
	{
		int res = 0;
		int tmp = 1;
		while(x/10)
		{
			res += x%10;
			tmp *= 10;
			x /= 10;
		}
		if(res)
		{
			return (x+1)*tmp;
		}
		else
		{
			return x*tmp;
		}
	}
	else
	{
		int tmp = 1;
		for(int i=1; i<dig; ++i)
		{
			tmp *= 10;
		}
		return tmp;
	}
}

signed main()
{
	int t;
	scanf("%lld",&t);
	for(int asdfg=1; asdfg<=t; ++asdfg)
	{
		int l,r;
		scanf("%lld%lld",&l,&r);
		int digl = digit(l);
	
		run:
		if(fived(l,digl) <= r)
		{
			printf("%lld\n",fived(l,digl));
			continue;
		}
		else if(minid(l,digl) <= r)
		{
			printf("%lld\n",minid(l,digl));
			continue;
		}
		
		if(digit(l)==digl)
		{
			putchar(headd(l)+'0');
			l = lastd(l);
			r = lastd(r);
		}
		else
		{
			putchar('0');
			if(digit(r)==digl)
			{
				r = lastd(r);
			}
		}
		--digl;
		
		if(l&&r)
		{
			goto run; //用goto实现循环qwq
		}
	}
}
```

---


# [BJOI2012] 算不出的等式

## 题目背景

曾经有一个老掉牙的游戏放在我面前，我没有珍惜。直到这个游戏停产才追悔莫及。人世间最痛苦的事情莫过于此，如果上天给我一个再玩一次的机会，我一定要，通关！

## 题目描述

如果你真的很想玩这个游戏，那么就先看看我的题目吧，搞不定这些的话是没办法通关的哟。第一关其实很简单，只有一个关闭的有密码锁的大门。这大门上写着一个奇怪的算式，估计是要你利用它算出密码来开门吧（果然是老掉牙的情节）。

传说中这个式子中的 $p$ 和 $q$ 是两个奇质数，等号右边算出来应该就是密码了吧，你是真的算不出来么？


$$
\sum_{k=1}^{\frac{p-1}{2}} \biggl\lfloor\frac{kq}{p}\biggr\rfloor+\sum_{k=1}^{\frac{q-1}{2}} \biggl\lfloor\frac{kp}{q}\biggr\rfloor
$$

## 说明/提示

$p,q<2^{32}$。

## 样例 #1

### 输入

```
5 7```

### 输出

```
6```

# 题解

## 作者：一只书虫仔 (赞：22)

#### Description

> 给定两个奇质数 $p,q$，求：
> $$\sum\limits_{i=1}^{\frac{p-1}{2}}\left\lfloor\dfrac{iq}{p}\right\rfloor+\sum\limits_{j=1}^\frac{q-1}{2}\left\lfloor\dfrac{jp}{q}\right\rfloor$$

#### Solution 1

类欧几里得算法。

我们知道类欧的基本式子为：

$$\sum\limits_{i=0}^n\left\lfloor\dfrac{ai+b}{c}\right\rfloor$$

然后题目作者良心的帮我们省掉了 $b$，所以我们只需要将 $b=0$ 代进去即可。

代码就不放了（其实是写锅了 /kk）

#### Solution 2

类欧明显不配蓝题，所以这题还有找规律做法。

比如我们看样例，$\dfrac{p-1}{2}=2$，$\dfrac{q-1}{2}=3$，$2 \times 3=6$，所以我们能猜到输出 $\dfrac{p-1}{2} \times \dfrac{q-1}{2}$ 即可。

#### Code 2

```cpp
#include <bits/stdc++.h>

using namespace std;

int main () {
	long long p, q;
	scanf("%lld%lld", &p, &q);
	p = (p - 1) / 2;
	q = (q - 1) / 2;
	printf("%lld", p * q);
	return 0;
}
```

然后你会发现只有 $90$ 分，有一个点 WA 掉了。

#### Solution 2 - For Addition

$p=q$ 的时候要特判，这个时候的答案应该是 $\dfrac{p^2}{4}$。

#### Code 2 - For Addition

```cpp
#include <bits/stdc++.h>

using namespace std;

int main () {
	long long p, q;
	scanf("%lld%lld", &p, &q);
	if (p == q) {
		printf("%lld", p * p / 4);
		return 0;
	}
	p = (p - 1) / 2;
	q = (q - 1) / 2;
	printf("%lld", p * q);
	return 0;
}
```

然后就会 A 了。

---

## 作者：feecle6418 (赞：17)

数学题。

设两个数为$p,q$。如下图（$p=7,q=11$）：

![](https://cdn.luogu.com.cn/upload/pic/14245.png)

如图，斜线下方的整点有$\sum_{k=1}^5[k\times\frac{3}{5}]$个。（$[]$表示向下取整）

把图颠倒来看：

![](https://cdn.luogu.com.cn/upload/pic/14246.png)

这个图下方的整点有$\sum_{k=1}^3[k\times\frac{5}{3}]$个。

所以，该式两部分分别是一个$(\frac{p-1}{2},\frac{q-1}{2})$方格图主对角线分成的两部分的整点数。

又因为$p,q$都是质数，所以这两部分的整点数之和就等于整个图的整点数。

所以，$p=7,q=11$时，答案就是$3\times5=15$。

但是要特判$p=q$的情况！答案为$(1+(p-1)\div2)\times(p-1)\div2\div2\times2=(p^2-1)\div 4$。（但是$p,q$是奇数，所以直接输出$p^2\div4$即可）



---

## 作者：一念之间、、 (赞：11)

看题解区无非是打表找规律（我觉得没必要放到题解）或者是发现是一个类欧几里得算法板子，这里介绍一种不用类欧几里得和打表的做法。

以下假设 $p$ $q$不相等

首先根据定义写出式子

$$\sum_{k=1}^{\frac{p-1}{2}} \biggl\lfloor\frac{kq}{p}\biggr\rfloor+\sum_{k=1}^{\frac{q-1}{2}} \biggl\lfloor\frac{kp}{q}\biggr\rfloor$$

令 $T=\frac{p-1}{2}$


$$=\sum_{k=1}^{T} (\frac{kq}{p}-\frac{kq\mod p}{p})+\sum_{k=1}^{\frac{q-1}{2}} \biggl\lfloor\frac{kp}{q}\biggr\rfloor$$

将$\sum_{k=1}^{T} (\frac{kq\mod p}{p})$提出来化简

根据 $T$ 的定义我们知道 $T<p$ 

将$\sum_{k=1}^{T} (\frac{kq\mod p}{p})$写出来

$(q-a_1p)+(2q-a_2p)+(3q-a_3p)……+(kq-a_kp) $

发现a序列非降，于是拆成一些后缀的形式

设 $w$ 满足 $wp>kq$ 则最小的 $w$ 的为 $\lfloor\frac{kp}{q}\rfloor+1$ （由于 $p$ $q$ 不等且都为奇质数，所以不存在 $wp=kq$ 当 $w<T$ 时）

这里$(T-\lfloor\frac{kp}{q}\rfloor)$表示大于 $kp$ 的有几个，

$$\sum_{k=1} a_kp=\sum_{k=1} (p\times(T-\lfloor\frac{kp}{q}\rfloor))$$

这里我们需要明确一下上界，$\frac{kp}{q}\leq T$ 即 $k\leq \frac{Tq}{p}$

发现 $\frac{Tq}{p}=\frac{\frac{p-1}{2}q}{p}=\frac{q-1}{2}$

代入可得

$$\sum_{k=1}^{T} (\frac{kq\mod p}{p})=\frac{\sum_{k=1}^{T} kq-\sum_{k=1}^{\frac{q-1}{2}} (p\times(T-\lfloor\frac{kp}{q}\rfloor))}{p}$$
$$=\sum_{k=1}^{T} \frac{kq}{p}-\sum_{k=1}^{\frac{q-1}{2}} (T-\lfloor\frac{kp}{q}\rfloor)$$


代入最初的式子

$$\sum_{k=1}^{T} (\frac{kq}{p}-\frac{kq\mod p}{p})+\sum_{k=1}^{\frac{q-1}{2}} \biggl\lfloor\frac{kp}{q}\biggr\rfloor$$
$$=\sum_{k=1}^T\frac{kq}{p}-(\sum_{k=1}^{T} \frac{kq}{p}-\sum_{k=1}^{\frac{q-1}{2}} (T-\lfloor\frac{kp}{q}\rfloor))+\sum_{k=1}^{\frac{q-1}{2}} \biggl\lfloor\frac{kp}{q}\biggr\rfloor$$
$$=\sum_{k=1}^{\frac{q-1}{2}}T$$
$$=\frac{p-1}{2}\times\frac{q-1}{2}$$

我们就得到了答案，当然这是在大前提 $p$ $q$ 不相等的情况，

考虑 $p$ $q$ 相等时因为 $p/q=1$ 所以答案就很好算了，是$\frac{p^2-1}{4}$

至此，我们在不用类欧或者打表的方式得到了正确的结论。

---

## 作者：lqhsr (赞：11)

这篇题解主要是为了造福众多看不懂另一篇题解的~~未来的巨佬~~


# 思路：

首先观察到 

$ \sum_{i=1}^{\frac{p-1}{2}}{[\frac{kq}{p}]}$和$ \sum_{i=1}^{\frac{q-1}{2}}{[\frac{kp}{q}]}$

发现ｋ的上界为$\frac{p-1}{2}$和$\frac{q-1}{2}$

又有ｐ和ｑ一定，ｋ在变化，~~(自然地)~~想到是一次函数

于是构造函数ｆ（ｘ）＝$\frac{q}{p}$x和ｇ（ｘ）＝$\frac{p}{q}$x

接着注意到是向下取整，就是把所有在函数范围之内的整数ｘ的函数值分别向下取整，发现这就是在找函数图像之下的整点个数

用https://www.luogu.org/blog/rc-tianbu/solution-p4132　中的例子

设两个数为p,q。如下图（p=7,q=11）
![](https://cdn.luogu.com.cn/upload/pic/14245.png)

这就是g(x)的图像


f(x)的同理

![](https://cdn.luogu.com.cn/upload/pic/14246.png)

但我们可以发现两个图像拼在一起就是整个矩形！！！

但你可能会问两个图形拼在一起顶点会不会多算或少算

这正是下面的重点

注意到ｐ，ｑ互质，这说明$\frac{q}{p}$和$\frac{p}{q}$均不为整数，所以不用计算，$\frac{q}{p}$和$\frac{p}{q}$为整数只有在ｘ＝ｐ的倍数和ｘ＝ｑ的倍数时，但这都超过了$\frac{p-1}{2}$和$\frac{q-1}{2}$

所以拼在一起不会存在点少算或多算（简单讲就是函数值不为整数）

所以此时有整点$$\frac{p-1}{2}\cdot\frac{q-1}{2}$个。

## 但是！！！，这并不是绝对正确的

当ｐ＝＝ｑ时$\frac{q}{p}$和$\frac{p}{q}$均为１，公式瞬间凉凉


这时f(x)=g(x)=x，所以函数值就是ｘ的值，所以在取值范围之内函数值可以为整数

那就一起算再加上重复的点不就ＯＫ了么

取ｐ＝ｑ＝７为例

ａｎｓ＝((p-1)/2)*((p-1)/2)+(p-1)/2;

((p-1)/2)*((p-1)/2)是矩形中的点数，后面是重复的点（有((p-1)/2)*((p-1)/2)个点就有(p-1)/2)个点在对角线上，拼起来会重合）

提出(p-1)/2就是($p^2$−1)/4，ｐ为奇数，平方减一是偶数除以４与本身除以４同效（整数会自动舍弃小数位）

代码（第一篇提高＋题解，喜欢请点赞）

```
#include<bits/stdc++.h>
using namespace std;
int main()
{
    long long x,y;
    cin>>x>>y;
    if(x!=y)cout<<((x-1)/2)*((y-1)/2);
    else　cout<<x*x/4;
    return 0;
}
```

１０行ＡＣ一道省选题，爽不

讲了大家有些不懂的地方，管理大大求通过～～～

---

## 作者：chaichunyang (赞：4)

[Beijing wc2012]算不出的算式
###### [题目](https://www.luogu.com.cn/problem/P4132)
 $$\sum_{k=1}^\frac{p-1}{2} [\frac {kq}{p} ]+\sum_{l=1}^\frac{q-1}{2} [\frac {lp}{q} ]$$

### 算法简介：
#### 思维题 ___无算法___
### 思维思路：
##### 开始大数据：
| q/p | 1 | 3 | 5 | 7 | 9 |
| :-: | :-: | :-: | :-: | :-: | :-: |
| 1 | 0 | 0 | 0 | 0 | 0 |
| 3 | 0 | 2 | 2 | 3 | 4 |
| 5 | 0 | 2 | 6 | 6 | 8 |
| 7 | 0 | 3 | 6 | 12 | 12 |
| 9 | 0 | 4 | 8 | 12 | 20 |
#### 可以很明显的看出  

##### p!=q时
$$\sum_{k=1}^\frac{p-1}{2} [\frac {kq}{p} ]+\sum_{l=1}^\frac{q-1}{2} [\frac {lp}{q} ]=\frac{q-1}{2}* \frac{p-1}{2}=\frac{(q-1)(p-1)}{4}$$ 
```cpp
	printf("%lld\n",((p-1)*(q-1)/4));		
```

##### p==q时

$$\sum_{k=1}^\frac{p-1}{2} [\frac {kq}{p} ]+\sum_{l=1}^\frac{q-1}{2} [\frac {lp}{q} ]=\frac{(q-1)(p-1)}{4}+\frac{q(p)-1}{2}$$
```cpp
	printf("%lld\n",((p-1)*(q-1)/4)+(q-1)/2));			
```

#### 合并大法：

```cpp
	printf("%lld\n",((p-1)*(q-1)/4)+(q==p?(q-1)/2:0));	
```
### 完整代码
```cpp
#include<bits/stdc++.h>
long long q,p;
int main() {
	scanf("%lld%lld",&p,&q);
	printf("%lld\n",((p-1)*(q-1)/4)+(q==p?(q-1)/2:0));
}
```

---

## 作者：nekko (赞：3)

然而这题并不需要分析什么……显然这就是个直线下数整点个数……

类欧几里得板子啊！

可以从这里看到完整的[类欧几里得（入门版）算法](https://www.luogu.org/blog/KingSann/lei-ou-ji-li-dei-ru-men-post)

``` cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

ll f(ll a, ll b, ll c, ll n) {
    if(n <= 0) return 0;
    return n * (n - 1) / 2 * (a / c) + n * (b / c) + f(c, (a * n + b) % c, a % c, (a % c * n + b % c) / c);
}

int main() {
    ll p, q; cin >> p >> q;
    cout << f(q, 0, p, (p - 1) / 2 + 1) + f(p, 0, q, (q - 1) / 2 + 1) << endl;
}
```

---

## 作者：Rubyonly (赞：1)

类欧几里得板子题，直接套用式子做就行了

**类欧几里得**常用与处理类似于下面式子的问题

$$F(n,a,b,c)=\sum_{i=0}^{n}\left \lfloor \frac{ai+b}{c} \right \rfloor$$

对于 $a\geq c$ 或者 $b \geq c$ 有

$$F(n,a,b,c)=\frac{n(n+1)}{2} \left \lfloor \frac{a}{c} \right \rfloor + (n + 1) \left \lfloor \frac{b}{c} \right \rfloor + F (n, a \bmod c, b \bmod c, c)$$

对于 $a<c$ 且 $b<c$ 有

$$m=\left \lfloor \frac{a*n+b}{c} \right \rfloor$$

$$F(n,a,b,c)=nm-F(m-1,c,c-b-1,a)$$

这样可以在 $\log n$ 的复杂度内求解

或者打表找出规律，答案是 

$$\frac{p-1}{2}\times\frac{q-1}{2}$$

特判一些情况也能过

这里贴一个类欧几里得的代码

```c++
#include <cstdio>
#include <cstring>

#define ll long long
#define rint register int 

using namespace std;

const int maxn = 1e5 + 50;

int p, q;

inline ll F (rint n, rint a, rint b, rint c) {
	if (! a) return 1ll * (n + 1) * (b / c);
	if (a >= c || b >= c) {
		rint val1 = a / c, val2 = b / c;
		return 1ll * n * (n + 1) / 2 * val1 + 1ll * (n + 1) * val2 + F (n, a % c, b % c, c);
	} else {
		rint m = (1ll * a * n + b) / c;
		return 1ll * n * m - F (m - 1, c, c - b - 1, a);
	}
}

int main () {
	scanf ("%d%d", &p, &q);
	printf ("%lld\n", F ((p - 1) / 2, q, 0, p) + F ((q - 1) / 2, p, 0, q));
	return 0;
}
```

---

## 作者：dz_ice (赞：1)

看到题解里一些大佬写了数学证明，那我就来讲讲我是如何通过暴力算法打表出来找出规律并推导出正确公式的。

暴力代码
```
#include<bits/stdc++.h>
using namespace std;
long long p,q,ans;
int main()
{
	cin>>p>>q;
	for(long long i=1; i<=(p-1)/2; i++)
		ans+=(i*q)/p;
	for(long long i=1; i<=(q-1)/2; i++)
		ans+=(i*p)/q;
	cout<<ans;
	return 0;
}
```

首先先枚举p或q等于3的情况
```
p  q   ans
3  3   2
3  5   2
3  7   3
3  11   5
3  13   6
3  17   8
3  19   9

```
我们发现似乎当p!=q时（这种情况后面再考虑），ans都等于(q-1)/2*1

p或q为5的情况
```
p  q   ans
5  3   2
5  5   6
5  7   6
5  11   10
5  13   12
5  17   16
5  19   18
```
同样也是p！=q时，ans等于(q-1)/2*2，似乎有那么一点规律？

继续来，p或q为7的情况
```
p  q   ans
7  3   3
7  5   6
7  7   12
7  11   15
7  13   18
7  17   24
7  19   27
```
p！=q时，ans=(q-1)/2*3

~~凭借感觉~~，已经可以发现规律，当p！=q时,ans=(q-1)/2*(p-1)*2

再来验证一下
```
p  q   ans
11  3   5
11  5   10
11  7   15
11  11   30   
11  13   30
11  17   40
11  19   45
```
那么当p=q时，又有什么规律呢？继续打表
```
p  q   ans
3  3   2
5  5   6
7  7   12
11  11  30
13  13  42
17  17  72
19  19  90
```
那么规律就很明显了，ans=(p*q-1)/4（向下取整）

接下来是AC代码
```
#include<bits/stdc++.h>
using namespace std;
long long ans,p,q,n,m;
int main()
{
	cin>>p>>q;
	if(p!=q)
		cout<<((p-1)/2)*((q-1)/2);
	else
		cout<<(p*q-1)/4;
	return 0;
}
```
虽然这种方法没有什么证明，但是在考场上这也是一种既省时间有省思考的好方法，可以很快速的找到规律

---

## 作者：gwx123456 (赞：1)

这应该是一道思路最直接，代码最短的题解了。

我们先看下样例：5 7

结果是 3+3=6

可以看到3是5的一半向下取整，3是7的一半向下取整。

再自己列举7 11

结果是 3+5=8

可以看到3是7的一半向下取整，5是11的一半向下取整。那是不是所有的都是q、p的一半呢？

再看：7 7

自己的结果：3+3=6；正确：12。

可以发现p、q一样就不行了，那就特殊处理

仔细观察后发现（7*7-1）/4=12

发现规律了！

上代码：
```
#include <bits/stdc++.h>//万能头
using namespace std;
long long p,q;//要开long long
int main(){
	cin>>p>>q;//输入
	if(p==q)cout<<(p*q-1)/4;//一样的话就特殊处理
	else cout<<(p/2)*(q/2);//不一样就按规律输出
	return 0;
}
```
原谅我这个蒟蒻，只会找规律，不会证明


---

## 作者：Aw顿顿 (赞：0)

## 题目大意

给定两个奇质数 $p$ 和 $q$，求：

$$\large\sum_{x=1}^{\frac{p-1}{2}} \left\lfloor\frac{xq}{p}\right\rfloor+\sum_{x=1}^{\frac{q-1}{2}} \left\lfloor\frac{xp}{q}\right\rfloor$$


## 如何解答

看上去就是类欧，然后就直接套板子了。

众所周知，类欧的基本模式如下：

给定 $a,b,c,n$，求 $f(a,b,c,n)=\sum_{x=0}\limits^{n-1}\left\lfloor\dfrac{ax+b}{c}\right\rfloor$

然后你会发现题目的式子里根本没有 $b$，所以就直接赋值为 $b=0$。

然后大家也知道类欧的结果是：

$$f(c,(an+b)\bmod c,a\bmod c,\left\lfloor\dfrac{a\bmod c\cdot n+b\bmod c}{c}\right\rfloor-1)$$

于是核心代码就特别短：

```cpp
long long f(long long a,long long b,long long c,long long n){
    if(n<=0)return 0;
    return n*(n-1)/2*(a/c)+n*(b/c)+f(c,(a*n+b)%c,a%c,(a%c*n+b%c)/c);
}
```

于是可以解决。

---

## 作者：Yyxxxxx (赞：0)

## $Description$
给出 $p,q$ ，求：
$$\sum\limits_{i=1}^{\frac{p-1}{2}}\lfloor\dfrac{qi}{p}\rfloor+\sum\limits_{i=1}^{\frac{q-1}{2}}\lfloor\dfrac{pi}{q}\rfloor$$
## $Solotion$
我们知道 $i=0$ 时， $\lfloor\dfrac{qi}{p}\rfloor=\lfloor\dfrac{pi}{q}\rfloor=0$   
所以原式可以转化为：    

$$\sum\limits_{i=0}^{\frac{p-1}{2}}\lfloor\dfrac{qi}{p}\rfloor+\sum\limits_{i=0}^{\frac{q-1}{2}}\lfloor\dfrac{pi}{q}\rfloor$$    
 我们知道，类欧几里得算法可以在 $\Theta(\log n)$ 计算形如:     
 $f(a,b,c,n)=\sum\limits_{i=0}^n\lfloor\dfrac{ai+b}{c}\rfloor$ 的式子。    
 所以我们将结果化为:    
 $$f(q,0,p,\dfrac{p-1}{2})+f(p,0,q,\dfrac{q-1}{2})$$    
 那么我们应该如何计算呢？既然有取整符号我们就讨论下：   
 - $a=0$  
$f(a,b,c,n)=\sum\limits_{i=0}^n\lfloor\dfrac{b}{c}\rfloor=(n+1)\lfloor\dfrac{b}{c}\rfloor$
- $a\ge c \lor b\ge c$    
$\forall N\in\mathbb{Z},r\in\mathbb{R},\lfloor r+N\rfloor=\lfloor r\rfloor+N$   

引理$1.1: \lfloor\dfrac{Ax}{y}\rfloor=\lfloor\dfrac{A(x\mod y)}{y}\rfloor+A\lfloor\dfrac{x}{y}\rfloor$   
证明：   

$\begin{aligned}
\lfloor\dfrac{Ax}{y}\rfloor
&=
\lfloor\dfrac{Ax}{y}\rfloor-A\lfloor\dfrac{x}{y}\rfloor+A\lfloor\dfrac{x}{y}\rfloor\\
&=\lfloor\dfrac{A(x)}{y}-A\lfloor\dfrac{x}{y}\rfloor\rfloor+A\lfloor\dfrac{x}{y}\rfloor\\
&=\lfloor\dfrac{A(x-\lfloor\dfrac{x}{y}\rfloor\cdot y)}{y}\rfloor+A\lfloor\dfrac{x}{y}\rfloor\\
&=\lfloor\dfrac{A(x\mod y)}{y}\rfloor+A\lfloor\dfrac{x}{y}\rfloor\\
\end{aligned}$   
推论：  $\lfloor\dfrac{ai+b}{c}\rfloor=\lfloor\dfrac{(a\mod c)i+(b\mod c)}{c}\rfloor+\lfloor\dfrac{a}{c}\rfloor i+\lfloor\dfrac{b}{c}\rfloor$     
证明：    

$\begin{aligned}
\lfloor\dfrac{ai+b}{c}\rfloor
&=\lfloor\dfrac{ai+b}{c}\rfloor-\lfloor\dfrac{a}{c}\rfloor i-\lfloor\dfrac{b}{c}\rfloor+\lfloor\dfrac{a}{c}\rfloor i +\lfloor\dfrac{b}{c}\rfloor\\
&=\lfloor\dfrac{(a-\lfloor\dfrac{a}{c}\rfloor\cdot c)i+(b-\lfloor\dfrac{b}{c}\rfloor\cdot c)}{c}\rfloor+\lfloor\dfrac{a}{c}\rfloor i+\lfloor\dfrac{b}{c}\rfloor\\
&=\lfloor\dfrac{(a\mod c)i+(b\mod c)}{c}\rfloor+\lfloor\dfrac{a}{c}\rfloor i+\lfloor\dfrac{b}{c}\rfloor\\
\end{aligned}$  
$\begin{aligned}
\therefore f(a,b,c,n)
&=\sum\limits_{i=0}^n\lfloor\dfrac{ai+b}{c}\rfloor\\
&=\sum\limits_{i=0}^n(\lfloor\dfrac{(a\mod c)i+(b\mod c)}{c}\rfloor+\lfloor\dfrac{a}{c}\rfloor i+\lfloor\dfrac{b}{c}\rfloor)\\
&=\sum\limits_{i=0}^n\lfloor\dfrac{(a\mod c)i+(b\mod c)}{c}\rfloor+\dfrac{n(n+1)}{2}\lfloor\dfrac{a}{c}\rfloor+(n+1)\lfloor\dfrac{b}{c}\rfloor\\
\end{aligned}$  
$\therefore f(a,b,c,n)=f(a\mod c,b\mod c,c,n)+\dfrac{n(n+1)}{2}\lfloor\dfrac{a}{c}\rfloor+(n+1)\lfloor\dfrac{b}{c}\rfloor$

- $a<c \land b<c$    
$\begin{aligned}
f(a,b,c,n)
&=\sum\limits_{i=0}^n\lfloor\dfrac{ai+b}{c}\rfloor\\
&=\sum\limits_{i=0}^n\sum\limits_{j=1}^{\lfloor\frac{an+b}{c}\rfloor}[j\le\lfloor\dfrac{ai+b}{c}\rfloor ]\\
&=\sum\limits_{i=0}^n\sum\limits_{j=0}^{\lfloor\frac{an+b}{c}\rfloor-1}[j+1<\dfrac{ai+b+1}{c}]\\
&=\sum\limits_{i=0}^n\sum\limits_{j=0}^{\lfloor\frac{an+b}{c}\rfloor-1}[jc+c<ai+b+1]\\
&=\sum\limits_{j=0}^{\lfloor\frac{an+b}{c}\rfloor-1}\sum\limits_{i=0}^n[ai>jc+c-b-1]\\
&=\sum\limits_{j=0}^{\lfloor\frac{an+b}{c}\rfloor-1}\sum\limits_{i=0}^n[i>\lfloor\dfrac{jc+c-b-1}{a}\rfloor]\\
&=\sum\limits_{j=0}^{\lfloor\frac{an+b}{c}\rfloor-1}n-\lfloor\dfrac{jc+c-b-1}{a}\rfloor\\
&=\lfloor\dfrac{an+b}{c}\rfloor n-\sum\limits_{j=0}^{\lfloor\frac{an+b}{c}\rfloor-1}\lfloor\dfrac{jc+c-b-1}{a}\rfloor\\
&=\lfloor\dfrac{an+b}{c}\rfloor n-f(c,c-b-1,a,\lfloor\dfrac{an+b}{c}\rfloor-1)
\end{aligned}$    

 $f(a,b,c,n)=\begin{cases}
 (n+1)\lfloor\dfrac{b}{c}\rfloor&a=0\\
 f(a\mod c,b\mod c,c,n)+\dfrac{n(n+1)}{2}\lfloor\dfrac{a}{c}\rfloor+(n+1)\lfloor\dfrac{b}{c}\rfloor&a\ge c\lor b\ge c\\
 \lfloor\dfrac{an+b}{c}\rfloor n-f(c,c-b-1,a,\lfloor\dfrac{an+b}{c}\rfloor-1)& otherwise
 \end{cases}$
## $Code$
```
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll f(ll a,ll b,ll c,ll n)
{
		if(a==0)return (n+1)*(b/c);
		if(a>=c||b>=c)return n*(n+1)/2*(a/c)+(n+1)*(b/c)+f(a%c,b%c,c,n);
		return (a*n+b)/c*n-f(c,c-b-1,a,(a*n+b)/c-1);
}
int main()
{
		ll p,q;
		scanf("%lld%lld",&p,&q);
		ll ans=f(q,0,p,(p-1)/2)+f(p,0,q,(q-1)/2);
		printf("%lld\n",ans);
		return 0;
}
```


---

## 作者：loceaner (赞：0)

~~题意显而易见，不用描述~~

## 思路

>思路题+数学函数

### 30pts

按题意暴力枚举，简单粗暴

### 100pts

代码极短，但是想好久也想不出来= =，果然是思路题

当$p\neq q$时：

构造函数$f(x)=\lfloor\frac{xq}{p}\rfloor$

思考函数$g(x)=\lfloor x\rfloor$的几何意义：在坐标系中横坐标为$x$，纵坐标小于等于$x$的整数个数

那么$f(x)$就表示：在坐标中横坐标为$x$，纵坐标小于等于$\frac{xq}{p}$的数的个数

那么$\sum\limits_{k=1}^{\frac{p-1}{2}}f(k)$就表示所有$\in[1,\frac{p-1}{2}]$的整数所形成的的函数图像中所有的整数点，如下图

![](https://img2020.cnblogs.com/blog/1648498/202007/1648498-20200707141638610-1080591941.png)

答案即为右下角三角内的整数点个数

同理令$t(k)=\lfloor\frac{kp}{q} \rfloor$，则$\sum\limits_{k=1}^{\frac{q-1}{2}}t(k)$就表示所有$\in[1,\frac{q-1}{2}]$的整数所形成的的函数图像中所有的整数点

容易发现这两部分一起组成了一个矩形，所以我们只需要考虑矩形$A(0,0),B(\frac{p-1}{2},0),C(\frac{p-1}{2},\frac{q-1}{2}),D(0,\frac{q-1}{2})$

所以最后答案就是$\frac{(p-1)}{2}\times\frac{(q-1)}{2}$

当$p=q$时：

$$\sum\limits_{k=1}^\frac{p-1}{2} \lfloor\frac {kq}{p} \rfloor+\sum\limits_{k=1}^\frac{q-1}{2}  \lfloor\frac {kp}{q}\rfloor=2\times\sum\limits_{k=1}^{\frac{p -1}{2}}k=2\times\frac{(\frac{p-1}{2}+1)\times \frac{p-1}{2}}{2}=\frac{(p-1)(p+1)}{4}$$

## 代码

### 30pts

```cpp
/*
Author:Loceaner
*/
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define int long long
using namespace std;

const int A = 5e5 + 11;
const int B = 1e6 + 11;
const int mod = 1e9 + 7;
const int inf = 0x3f3f3f3f;

inline int read() {
  char c = getchar(); int x = 0, f = 1;
  for ( ; !isdigit(c); c = getchar()) if (c == '-') f = -1;
  for ( ; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);
  return x * f;
}

int p, q, ans;

signed main() {
  p = read(), q = read();
  int up1 = (p - 1) / 2, up2 = (q - 1) / 2;
  for (int k = 1; k <= up1; k++) 
    ans += (int)k * q / p;
  for (int k = 1; k <= up2; k++) 
    ans += (int)k * p / q;
  cout << ans << '\n';
  return 0;
}
```

### 100pts

```cpp
/*
Author:Loceaner
*/
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define int long long
using namespace std;

const int A = 1e6 + 11;
const int B = 1e6 + 11;
const int mod = 1e9 + 7;
const int inf = 0x3f3f3f3f;

inline int read() {
	char c = getchar();
	int x = 0, f = 1;
	for ( ; !isdigit(c); c = getchar()) if (c == '-') f = -1;
	for ( ; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);
	return x * f;
}

int p, q, ans;

signed main() {
	p = read(), q = read();
	if (p == q) return cout << (p - 1) * (p + 1) / 4 << '\n', 0;
	cout << (p - 1) * (q - 1) / 4 << '\n';
	return 0;
}
```

---


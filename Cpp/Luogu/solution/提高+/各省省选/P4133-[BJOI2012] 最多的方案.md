# [BJOI2012] 最多的方案

## 题目描述

第二关和很出名的斐波那契数列有关，地球上的 OIer 都知道：  
$$F_n = \begin{cases} 1 & (n \le 2) \\ F_{n-1}+F_{n-2} & (n \ge 3) \end{cases}$$ 
每一项都可以称为斐波那契数。  

现在给一个正整数 $n$，它可以写成一些斐波那契数的和的形式。如果我们要求不同的方案中不能有相同的斐波那契数，那么对一个 $n$ 最多可以写出多少种方案呢？


## 说明/提示

Hint：16=3+13=3+5+8=1+2+13=1+2+5+8

【数据范围】   
对于 $30\%$ 的数据，$n \le 256$；  
对于 $100\%$ 的数据，$n \le 10^{18}$。


## 样例 #1

### 输入

```
16```

### 输出

```
4```

# 题解

## 作者：我好蒻呀 (赞：20)

**分析**

- 这题出得真是妙。
- 首先我们可以证明，任意自然数都能被不相同的斐波那契数之和表示：

> 具体的可以参考：[Zeckendorf's theorem](https://en.wikipedia.org/wiki/Zeckendorf%27s_theorem)
> 
> 简单证明：
> 
> 可以考虑归纳，显然对于 $n \leq 3$ 这个结论是成立的。
>
> 令 $f_k$ 表示斐波那契数列的第 $k$ 项，假设对于满足 $n < f_{k}$ 的自然数都能被不相同的斐波那契数表示，那么对于 $n=f_k$ 显然可以直接用 $f_k$ 表示。
> 
> 对于满足 $f_k<n<f_{k+1}$ 的整数 $n$，因为 $n<f_{k+1}\leq 2f_{k}$，因此 $n-f_k<f_k$，所以 $n-f_k$ 的斐波那契数表示中肯定不包含 $f_k$，我们可以考虑用 $n-f_k$ 的斐波那契数表示加上 $f_k$，从而得到 $n$ 的斐波那契数表示。

- 而斐波拉契数列的递推公式 $f[i]=f[i-1]+f[i-2](i>2)$告诉我们了一个性质：**数列中的任何一项（非第一第二项）能且只能分解为前两项之和，也只有相邻两项能够合并成下一项**。
- 于是我们先倒过来想，将方案中所有能合并的不断合并，得到一个没有相邻两项的方案，而这个方案显然可以通过贪心，不断从大往小取得到。
- 我们将这个贪心得到的数列中第 $i$ 个数在斐波拉契数列中的编号记为 $pos[i]$，将这个方案所用元素个数记为 $cnt$。
- 则 $n=\sum \limits_{i=1}^{cnt}f[pos[i]]$。
- 根据前面的分解方式和得到的结论，我们能且只能找到一个这样不相邻的表示法（可以形象地理解，一种不相邻方案与另一种不相邻方案之间，其中一种的最大值比另一种的所有元素和还要来得大）。
- 接下来我们又反过来想，尝试在这个方案的基础上分解。
- 显然直接做是不可能的。
- 我们前面发现不相邻表示法是唯一的，这样我们可以考虑分阶段分解，想到DP。
- 令 $g[i][0/1]$ 表示将 $1...i$ 的元素进行变换后，恰好组成 $\sum \limits_{j=1}^{i}f[pos[j]]$ 的方案数，第二维的 $0/1$ 表示是/否分解第 $i$ 个元素，且第 $i$ 个阶段必须组成 $f[pos[i]]$，的方案数。
- 首先明确，若不分解第 $i$ 个元素，则 $(pos[i-1],pos[i])$ 的元素都不用，下一阶段只能用 $(pos[i],pos[i+1]])$ 的元素分解。
- 否则若分解第 $i$ 个元素，则用到 $(pos[i-1],pos[i])$ 或 $[pos[i-1],pos[i])$ 的元素（取决于 $i-1$ 有没用上），下一阶段就能用 $[pos[i],pos[i+1]])$ 的元素分解。
- 而分解一个元素，需要它前两项的和，若这个和还能分解，则分解的必须是前一项。由此得到，分解一次需要两项是空出来的。
- 于是转移方程显然：

$g[i][1]=g[i-1][1]+g[i-1][0] $
$g[i][0]=g[i-1][1]*((pos[i]-pos[i-1]-1)\ div\ 2)+g[i-1][0]*((pos[i]-pos[i-1])\ div\ 2)$

- 初值也显然：$g[1][1]=1,\ g[1][0]=(pos[1]-1)\ div\ 2$

**代码：**
```cpp
#include <cmath>
#include <cstdio>
#include <cctype>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>

typedef long long ll; 

const int MaxN = 110; 

ll n, f[MaxN]; 
int m, cnt, pos[MaxN]; 
int g[MaxN][2]; 

int main()
{
	std::cin >> n; 
	f[1] = 1, f[2] = 2; 
	for (m = 3; f[m - 1] <= n; ++m)
		f[m] = f[m - 1] + f[m - 2]; 
	--m; 
	for (int i = m; i >= 1; --i)
		if (n >= f[i])
		{
			n -= f[i]; 
			pos[++cnt] = i; 
		}
	std::sort(pos + 1, pos + cnt + 1); 
	g[1][1] = 1, g[1][0] = pos[1] - 1 >> 1; 
	for (int i = 2; i <= cnt; ++i)
	{
		g[i][1] = g[i - 1][0] + g[i - 1][1]; 
		g[i][0] = g[i - 1][1] * (pos[i] - pos[i - 1] - 1 >> 1) + g[i - 1][0] * (pos[i] - pos[i - 1] >> 1);  
	}
	
	printf("%d\n", g[cnt][0] + g[cnt][1]);  
	
	return 0; 
}
```

---

## 作者：WhiteSunFlower (赞：13)

~~第一篇紫题解好激动~~

[更好的阅读体验](https://www.luogu.com.cn/blog/WhiteSunflower/solution-p4133)
### 分析
- 首先我们知道任意自然数都可以表示为 $n$ 个不相同斐波那契数的和。

具体的可以参考
[知乎：是否任意自然数都能被不相同的斐波那契数之和表示?](https://www.zhihu.com/question/68360587/answer/262536718)

~~通过打表得知~~，对于一个正整数 $n$ ，每次减去小于 $n$ 的第一个斐波那契数，按照此方法分解 $n$ 可以保证把 $n$ 表示为数量尽可能少的斐波那契数的和。即为我们接下来操作的基础。

### 核心内容
根据斐波那契的定义： 
 $F_1=1 , F_2=1 , F_n=F_{n-1}+F_{n-2}$

我们发现：如果我们新开一个数组 $B$ ,用 $0/1$ 来表示 $F_i$ 有没有被选用，那么
![](https://cdn.luogu.com.cn/upload/image_hosting/1eohgvah.png)

上表中的 $(1)$ 和 $(2)$ 方案所表示的数是一样的，于是我们就可以得到一个思路：

求所有 

 $B_i=1,B_{i-1}=B_{i-2}=0 \rightarrow B_i=0,B_{i-1}=B_{i-2}=1$

的方案数。

简单找找规律，我们可以发现：对于 B 中的每一个形如 $00…1$ 的块：

![](https://cdn.luogu.com.cn/upload/image_hosting/xai6o7ly.png)

假设前面共有 $N$ 个 $0$，那么共计 $N/2$ 种方案，而且 $B_i$ 被分解后  $B_{i-1}$ 不可分解，即 $B$ 中每个$1$  对答案的贡献仅和前面 $0$ 的数量有关系。要注意的是，假如一个 $1$ 被分解了，那么他原本的位置就会空出一个 $0$ 来，对下一个 $1$ 的分解方案数产生影响。

综上，我们设置状态： 
>$dp [i][0]$ 表示 $B$ 中第 $i$ 个 $1$ 不分解的方案数。

>$dp [i][1]$ 表示 $B$ 中第 $i$ 个 $1$ 分解的方案数。

我们用 $A_i$ 表示第 $i$ 个 $1$ 和第 $i-1$ 个 $1$ 之间 $0$ 的数量（ $i=1$ 则为第一个 $1$ 前面 $0$ 的数量，注意 $F_1=F_2$ ，所以实际上从 $F$ 的第二个 $1$ 开始计数）。

#### 真正的核心
初始化：

```cpp
dp[1][0]=1,dp[1][1]=a[1]/2; 
```
状态转移：

```cpp
dp[i][0]=dp[i-1][0]+dp[i-1][1];
```
>注： $0$ 为不分解，故等于第 $i-1$ 个 $1$ 的方案数。


```cpp
dp[i][1]=dp[i-1][0]*(a[i]>>1)+dp[i-1][1]*((a[i]+1)>>1);
```
>注：第 $i-1$ 个不分解, $0$ 的数量为 $a[i]$ ，方案数乘 $(a[i]/2)$ ；$i-1$ 个分解，$0$ 的数量为 $a[i]+1$ ,方案数乘 $((a[i]+1)/2)$ 。

最后输出 $dp[a\_len][0] + dp[a\_len][1]$ 就好辣！

---
#### $AC$ $Code$：

```cpp
#define WhiteSunflower int main()
#include <bits/stdc++.h>
#define ll long long
using namespace std;

ll f[100];//打标得知 10^18 分解最多约为 88 个
void init(){//斐波那契数打表预处理 
	f[1]=f[2]=1;
	for(int i=3;i<=90;i++)
		f[i]=f[i-1]+f[i-2];
}

ll t,n,a[100],dp[100][2],al;
bool b[100];

WhiteSunflower{
	init();
	cin >> n;
	int i=90;
	while(n&&i--)if(n>=f[i])n-=f[i],b[i]=1;
   //从大往小分解可以保证不重复 
   
	int cnt=0;
	for(int i=2;i<=90;++i){
		if(b[i]) a[++al]=cnt,cnt=0;
      //统计 b 数组中每段连续 0 的长度 
		else ++cnt;
	}
    
	dp[1][0]=1,dp[1][1]=a[1]>>1; 
	for(int i=2;i<=al;++i){
		dp[i][0]=dp[i-1][0]+dp[i-1][1];
		dp[i][1]=dp[i-1][0]*(a[i]>>1)+dp[i-1][1]*((a[i]+1)>>1);
	}
    
	cout << dp[al][0]+dp[al][1] << '\n';
	return 0;
}
```



---

## 作者：TheLostWeak (赞：11)

发现这道题可以直接记搜过掉，甚至拿到了目前最优解。。。

搜索状态可以表示为当前数为$x$，考虑到了第$m$个斐波那契数（$m$从大到小枚举）。

由于斐波那契数增长得很快，一个直观的感觉就是暴搜状态并不多。

然后只要加上一个显然的剪枝：如果$x$大于前$m-1$个斐波那契数之和，则$Fib(m)$必选。

然后就过了？

### 代码：$O($能过$)$

```cpp
#include<bits/stdc++.h>
#define Tp template<typename Ty>
#define Ts template<typename Ty,typename... Ar>
#define Reg register
#define RI Reg int
#define Con const
#define CI Con int&
#define I inline
#define W while
#define LL long long
using namespace std;
LL n,Fib[100],S[100];map<pair<LL,int>,LL> p;
I LL dfs(Con LL& x,CI m)//记忆化搜索
{
	if(!x||!m) return !x;pair<int,int> s=make_pair(x,m);if(p.count(s)) return p[s];
	if(x<Fib[m]) return p[s]=dfs(x,m-1);if(x>S[m-1]) return p[s]=dfs(x-Fib[m],m-1);//剪枝
	return p[s]=dfs(x,m-1)+dfs(x-Fib[m],m-1);//暴搜
}
int main()
{
	RI i;for(Fib[0]=Fib[1]=S[0]=1,S[1]=i=2;i<=87;++i) S[i]=S[i-1]+(Fib[i]=Fib[i-1]+Fib[i-2]);//预处理斐波那契数及其前缀和
	return scanf("%lld",&n),printf("%lld\n",dfs(n,87)),0;//直接输出
}
```


---

## 作者：封禁用户 (赞：11)

暴力出奇迹。

首先一个暴力的dp思路就是设$dp[i][j]$为把i拆成$f_1$到$f_j$之间的数的方案数，这个就是普通的背包计数而已。然而n$<=10^{18}$……数组开不下。

然后另外一个数组能开下的暴力思路就是用递归直接拆n，从高到低（这个最大可以到达$f_{86}$）用$f$进行拆分，但是会T。

其实可以把这两种方法结合一下，我们能想到记忆化搜索，但是那个还得开数组，不过我们可以只算用前一部分的$f$拼凑成的一些比较小的数的答案，部分记忆化一下。可能有人会说这样搜索量不还是很大吗？别忘了这是斐波那契数列，增长率极快，用n减去后面的$f$（这个时候$f$已经很大了）就会把n的规模缩小很多，所以并不会很慢。这个部分记忆化可以计算到$dp[28][514229]$（循环次数大概是10000000的，能扛得过去）。

上代码：

```cpp
// luogu-judger-enable-o2
// luogu-judger-enable-o2
#include<iostream>
#include<cstdio>
#include<cstring>
#define int long long
using namespace std;
int f[100];
int sum[100];
unsigned char bv[100];
int dp[514230][29];
int dfs(int n,int i){//Calc n With Count of F2~i
    if(n<=514229)return(dp[n][min(i,28ll)]);
    if(n>sum[i]&&bv[i]==0)return(0);
    if(n<f[i])return(dfs(n,i-1));
    return(dfs(n,i-1)+dfs(n-f[i],i-1));
}
signed main(){int n;cin>>n;
    dp[0][0]=1;
    f[0]=1;f[1]=1;for(register int i=2;i<=86;i++){
        f[i]=f[i-1]+f[i-2];
    }
    for(register int i=1;i<=86;i++){
        if(sum[i-1]+f[i]<0){
            sum[i]=sum[i-1];bv[i]=1;
        }else{
            sum[i]=sum[i-1]+f[i];
        }
    }
    for(register int i=1;i<=28;i++){
        if(f[i]>n){
            cout<<dp[n][i-1]<<endl;return(0);
        }
        for(register int j=min(sum[i],514229ll);j>=f[i];j--){
            dp[j][i]=dp[j][i-1]+dp[j-f[i]][i-1];
        }for(register int j=f[i]-1;j>=0;j--){
            dp[j][i]=dp[j][i-1];
        }
    }
    cout<<dfs(n,86)<<endl;
    return(0);
}
```

---

## 作者：Pengzt (赞：5)

[P4133](https://www.luogu.com.cn/problem/P4133)

[双倍经验](https://www.luogu.com.cn/problem/P8565)

发现斐波那契数列增长极快，不到 $100$ 项就超过了 $10^{18}$，搜索树也极为稀疏，可以考虑搜索。

爆搜肯定会超时，考虑优化：

1. 可行性剪枝。

2. 记忆化，去除重复的计算。

3. 改变搜索的顺序，因为先考虑小元素的话，会有较多的无用的搜索，且小元素较灵活，更容易凑到 $x$，故可以从大到小的考虑。

加上这三个优化即可通过此题。

时间复杂度：$\mathcal{O}$（可过）

[评测记录](https://www.luogu.com.cn/record/100203310)

---

## 作者：7KByte (赞：5)

数位 DP。[**更好的阅读体验**](https://www.cnblogs.com/7KByte/p/16551041.html)。

> 定理：我们可以将任意一个数拆分成若干个不相邻的斐波那契数之和。

简单证明一下：

> 我们从小到大枚举 $f_i$，如果 $n\ge f_i$ 就将 $f_i$ 拆分出来。因为 $f_i\le n <f_{i+1} = f_{i} + f_{i-1}$，所以拆分后一定不会选 $f_{i-1}$，归纳一下即可证明。

对于这道题我们先将 $n$ 拆分成若干个斐波那契数，然后写成 $0/1$ 串的形式，每次我们可以进行操作 $100\to 011$。原串我们记作 $s$。

那么我们直接从高位到低位 DP，记 $f_{i,op},op\in\{0,1\}$ 表示考虑到第 $i$ 位，是否有 $>i$ 位的位置对第 $i$ 位产生贡献。

接下来思路就很清晰了，如果 $op + s_i = 0$，那么 $f_{i,0} = f_{i - 1, 0}$，如果 $op + s_i = 1$，则 $f_{i,1} = f_{i-1,0} + f_{i-2,1}$，最后一种情况 $op+s_i= 2$，此时 $f_{i,1} = f_{i-2,1}$。

时间复杂度 $\mathcal{O}(\log n)$，看了一圈发现这个 DP 比题解区的更简单，所以写一篇题解。

```cpp
#define N 150
LL n, f[N], p[N][2]; int m, u[N];
LL calc(int x,int op){
	if(~p[x][op])return p[x][op];
	if(u[x] && op){
		if(x <= 2 || u[x - 1])return p[x][op] = 0;
		return p[x][op] = calc(x - 2, 1);
	}
	if(x == 1)return p[x][op] = 1;
	if(!u[x] && !op)return p[x][op] = calc(x - 1, 0);
	p[x][op] = calc(x - 1, 0);
	if(x > 2 && !u[x - 1])p[x][op] += calc(x - 2, 1);
	return p[x][op];
}
int main() {
	read(n);
	f[0] = f[1] = m = 1;
	while(f[m] < n)f[m + 1] = f[m] + f[m - 1], m++;
	pr(i, m){
		if(n >= f[i])u[i] = 1, n -= f[i];
	}
	memset(p, ~0, sizeof(p));
	printf("%lld\n", calc(m, 0));
	return 0;
}
```



---

## 作者：Mr_Wu (赞：4)

# 题意

给定正整数 $n (1\le n\le 10^{18})$，定义斐波那契数列 $F_1=1, F_2=2, F_n=F_{n-1}+F_{n-2} (n\ge 3)$，请求出满足如下条件的集合 $A=\{a_1,a_2,\cdots,a_m\} (a_1<a_2<\cdots<a_m)$ 的个数：

$$ \sum_{i=1}^m F_{a_i}=n $$

# 简述题解

首先借助样例分析，我们先把一个集合写成二进制形式，比如 $16=F_3+F_6$ 就写成 100100。

我们看看 $16$ 的四种表示：100100，011100，100011，011011。我们能够发现两件事：

- 除去 100100，其它的表示都会有相邻的 1。
- 11100，100011，011011 这些都是由 100100 做如下操作得到：选一个 1，变成 0，并将它右边两个数变成 1。也即 $F_i\rightarrow F_{i-1}+F_{i-2}$。

因此我们猜测：所有的表示法都是由 100100 这种没有相邻 1 的方案做上面的操作得到的。

我们先求出一个表示法吧。结合一些关于二进制的知识，我们可以这样求出首位最大的表示法：

```cpp
for (int i = MAX; i >= 1; --i)
    if (F[i] <= N) S.push_back(i), N -= F[i];
```

每次找到最大的，然后加进去。

幸运的是，我们碰巧找到了没有相邻 1 的方案！解释很简单，如果 $i, i+1$ 都在 $A$ 中，那么加入之前， $F_i+F_{i+1}=F_{i+2}\le n$ 肯定是成立的，这说明我们会先加入 $i+2$，$i,i+1$ 同时加入是不可能的！

我们用它来生成所有的方案，首先我们会尝试这样分段：对方案 100100，分成``[100][100]``，每个段有两种分别是 100 和 011，乘起来是 4。更扩展一些，若分成 ``[10000][100][1000]`` 这样的段，一段的长度是 $l$，则对答案贡献 $\lfloor \frac{l+1}{2}\rfloor$（乘在答案上）。

这对样例是正确的，但会遇到一个问题：``10100->01111``，这是因为后面的会给前面的”让位“。有了”让位“的情况，计算变得稍微棘手，因此我们采用 dp 解决。

设 $f_{i,0/1}$ 表示我们考虑到了第 $i$ 位（也就是 $F_i$），是否对它进行操作。若上一个 1 是 $j$ 位，我们很容易写出如下方程：

$$ \left\{ \begin{aligned} & f_{i,0}=f_{j,0}+f_{j,1} \\ & f_{i,1}=\lfloor\frac{i-j-1}{2}\rfloor f_{j,0}+\lfloor \frac{i-j}{2}\rfloor f_{j,1} \end{aligned} \right. $$

意义明显，若不操作，$f_{i,0}$ 直接由上一个操作/不操作转移，若 $i$ 操作，当 $j$ 不操作时，这一段长度为 $i-j$，贡献是 $\lfloor \frac{i-j+1}{2}\rfloor-1=\lfloor \frac{i-j-1}{2}\rfloor$。若 $j$ 操作同理。

这样就能以 $O(\log n)$ 的复杂度求出答案了。

# 严谨题解

### 定义

称满足题目条件的集合 $A=\{a_1,a_2,\cdots,a_m\} (a_1<a_2<\cdots<a_m) $ 为 $n$ 的 "Fib表示"，若 $\forall i\in [2,n], a_i-a_{i-1}>1$，则称其为 $n$ 的 "Fib真表示"，也可以称为一个 "Fib真表示"。

我们主要研究如下问题：

- 一个 $n$ 有几个 "Fib真表示"？
- "Fib表示" 和 "Fib真表示" 的关系？
- 题目解法

### Theorem 1

设 $S_n (n\in \mathtt{N}^*)$ 为所有 $a_m=n$ 的 "Fib真表示" 构成的集合，我们证明映射法则 $f(A)=\sum\limits_{i=1}^m F_{a_i}$ 是从 $S_n$ 到 $[F_n,F_{n+1}-1]$ 的双射。

首先由如下算法：（$x\in [F_n,F_{n+1}-1]$）

1. 找到最大的 $F_i$ 满足 $F_i\le x$。

2. 将 $F_i$ 加入 $A$。

3. 将 $x$ 减去 $F_i$，并回到第 1 步，直到 $x=0$。

可以得到一个 $x$ 的 "Fib真表示" $A$，且 $A\in S_n$，证明：

- 首先这个算法是可以结束的，因为不能结束当且仅当第一步找不到，考虑到 $F_1=1$ 是最小的正整数，这是不可能的。
- 下面证明 $A$ 应该是一个集合，假设不是（$A$ 是可重集），则找到最大的 $i$ 在 $A$ 中出现 $k(k>1)$ 次，考虑到在加入它们之前的 $x$ 满足 $\lfloor \frac{k}{2}\rfloor F_{i+1}<kF_i\le x$，因此算法会先减去 $\lfloor \frac{k}{2}\rfloor$ 个 $F_{i+1}$，这一定会使 $i$ 出现的次数减少，矛盾。我们证明了 $A$ 是一个 “Fib表示"。
- 下面证明 $A$ 是一个 "Fib真表示"，假设不是，找到最大的 $i$ 满足 $i,i+1\in A$，则 $i+2\not\in A$ （$i$ 的最大性），而在加入 $i,i+1$ 之前算法会优先选择 $i+2$，矛盾。
- 最后证明 $A\in S_n$，这很显然啊，因为 $x\in [F_n,F_{n+1}-1]$。

因此 $f$ 是一个满射。

其次，考虑若存在 $A_1,A_2$ 都是 $x$ 的 "Fib真表示"，找到最大的 $p$ 使得 $[p\in A_1]\not= [p\in A_2]$，不妨设 $p\in A_1$ 且 $p\not\in A_2$，易证 $\sum_{i=1}^{p-1} [i\in A_2]F_i<F_1+F_3+\cdots+F_{2\lfloor \frac{p}{2}\rfloor-1}=F_{2\lfloor \frac p2\rfloor}-1<F_p-1$，这说明 $f(A_1)=f(A_2)$ 是不可能成立的。

因此 $f$ 是一个单射，结合其是满射的事实，证毕。

因此，所有 "Fib真表示" 和所有正整数都是 “一一对应” 的。

### Theorem 2

$n$ 的所有 "Fib表示" 都是由其 "Fib真表示" $A$ 通过如下操作得到的：随便找一个 $i$ 满足 $i\in A, i-2\not\in A$，删掉 $i$，将 $i-1,i-2$ 加入到 $A$ 中。

证明很简单，通过一个 "Fib表示" $B$，一定可以找到一个 "Fib真表示" $C$ 进行若干次操作得到它，具体操作就是每次找到一个 $i$ 满足 $i, i+1\in B, i+2\not\in B$，将 $i,i+1$ 删了把 $i+2$ 放进去。考虑到 $C=A$，因此证毕。

### 题目解法

找到 $n$ 的 "Fib真表示" $A$，设 $f_{i,0/1}$ 表示对 $a_1,a_2,\cdots,a_i$ 操作能够有多少方案，并钦定 选择/不选择 $a_i$。

转移方程十分简单：

$$ \left\{ \begin{aligned} & f_{i,0}=f_{i-1,0}+f_{i-1,1} \\ & f_{i,1}=\lfloor\frac{a_i-a_{i-1}-1}{2}\rfloor f_{i-1,0}+\lfloor \frac{a_i-a_{i-1}}{2}\rfloor f_{i-1,1} \end{aligned} \right. $$

时间复杂度 $O(\log n)$。

# 代码

```cpp
#include <cstdio>

typedef long long ll;
ll read()
{
    ll ret = 0; char c = getchar();
    while (c < '0' || c > '9') c = getchar();
    while (c >= '0' && c <= '9') ret = ret * 10 + c - '0', c = getchar();
    return ret;
}

ll F[100], N, dp[100][2];
int a[100];

int main()
{
    scanf("%lld", &N);
    F[1] = 1, F[2] = 2; int i, j;
    for (i = 3; i <= 86; ++i) F[i] = F[i - 1] + F[i - 2];
    ll NN = N;
    for (i = 86; i >= 1; --i)
    {
        if (F[i] <= NN) a[i] = 1, NN -= F[i];
        else a[i] = 0;
    }
    j = 0; dp[0][0] = 1;
    for (i = 1; i <= 86; ++i)
    {
        if (!a[i]) { dp[i][0] = dp[i][1] = 0; continue; }
        dp[i][0] += dp[j][0] + dp[j][1];
        dp[i][1] += dp[j][0] * ((i - j - 1) / 2) + dp[j][1] * ((i - j) / 2);
        if (a[i]) j = i;
    }
    printf("%lld\n", dp[j][0] + dp[j][1]);
    return 0;
}
```





---

## 作者：MornStar (赞：3)

# [BJOI2012]最多的方案
蒟蒻第一篇紫题题解好激动！！！

一句话题意：
求一个整数被分成不同斐波那契数的方案数。

接下来我们开始一步步分析。
## 暴力 30pts
看到这道题，首先想到的应该是暴力。

很明显，暴力也应该有方式，比如 DFS。

预先求出斐波那契数列，$10^{18}$ 到 $89$ 便已足够。

很明显，时间是不够的。

因此，我们可以再加上一点优化。
## 记忆化搜索 100pts
至于为什么会想到记搜，可能是想一条路走到黑吧。

所谓 DFS，最强的肯定还是剪枝。

首先，DFS 中途的情况肯定还是分两种。

减 or 不减。

若目前减后还剩的数为 $x$ ，要减去第 $m$ 个斐波那契数。

如果 $x<fib_m$ ，那么肯定不会减去，否则会变成负数，直接 DFS $(x$ , $m-1)$。

如果 $x$ 大于前 $m-1$ 个斐波那契数之和,那么到了后面怎么也不会减到 $0$ ，所以必须减去 $fib_m$ ，则 DFS $(x-fib_m$ , $m-1)$。

同时我们也要记录斐波那契数的前缀和。

如果两个条件同时满足，那么 DFS $(x$ , $m-1)$ 和 $(x-fib_m$ , $m-1)$。

带上记忆化，就可以 AC 了。

还有。

>十年OI一场空 不开long long见祖宗。

代码放这了。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long fib[105]={1,1},sum[105]={1,2},n;
map< pair< long long , int >,long long > m;
long long dfs(long long x,long long y){
	if(!x||!y)	return !x;
	pair<long long,int> p=make_pair(x,y);//记录状态
	if(m.find(p)!=m.end())	return m[p];//记忆化搜索
	else if(x<fib[y]){
		m[p]=dfs(x,y-1);//剪枝
		return m[p];
	}else if(x>sum[y-1]){
		m[p]=dfs(x-fib[y],y-1)//剪枝;
		return m[p];
	}else{
		m[p]=dfs(x,y-1)+dfs(x-fib[y],y-1);
		return m[p];
	}
}
int main(){
	cin.tie(0),cout.tie(0);
		for(int i=2;i<=89;i++){
			sum[i]=sum[i-1]+(fib[i]=fib[i-1]+fib[i-2]);//压行小技巧
		}
	cin>>n;
	cout<<dfs(n,89);
}
```

---

## 作者：喵仔牛奶 (赞：3)

虽然 $n\leq10^{18}$ 很吓人，但是照斐波那契数列的增长速度，还是没有很大的。

设 $f_{i,j}$ 是使用斐波那契数列前 $i$ 项拼成 $j$ 的方案数。但是第二项用数组显然存不下。那就先看一眼转移方程：

$$f_{i,j}=f_{i-1,j}+f_{i-fib_j,j}$$

$fib_j$ 指斐波那契数列的第 $j$ 项。我们最终需要的是 $f_n$。

我们发现 $fib_j$ 超级大！这个搜索树超级稀疏！

那么我们就可以用 `map` 保存这个数组，然后逆向记忆化搜索。

<https://www.luogu.com.cn/record/85465020>

然而 T 了后面 $7$ 个点。

那我们就需要~~玄学~~优化了！

我们可以保存一个前缀和，记为 $sum_i$，表示斐波那契数列前 $i$ 项之和。

设当前搜索到剩下 $n$，做到第 $m$ 项。如果 $n>sum_{m-1}$，那么当前不选 $m$ 就直接没戏了，肯定得选。

加完剪枝就 AC 了。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1005;
map<ll, ll> f[N];
ll fib[N], sum[N], n;
ll dfs(ll n, int m) {
	if (n < 0) return 0; // 负数，不行
	if (!m || !n) return !n ? 1 : 0; // 选完或中途剩下 0 就返回
	if (f[m].count(n)) return f[m][n]; // 记忆化
	if (n >= sum[m - 1]) return f[m][n] = dfs(n - fib[m], m - 1); // 剪枝qwq
	return f[m][n] = dfs(n, m - 1) + dfs(n - fib[m], m - 1); // 不选/选
}
int main() {
	cin >> n, fib[0] = fib[1] = sum[0] = 1, sum[1] = 2;
	for (int i = 2; i <= 86; i ++) // 86 项差不多了
		fib[i] = fib[i - 1] + fib[i - 2], sum[i] = sum[i - 1] + fib[i];
	cout << dfs(n, 86) << '\n';
	return 0;
}

```


---

## 作者：KesdiaelKen (赞：3)

这一题其实可以用记忆化水过啊，也是0毫秒……

$map[i][j]$表示和为i的情况下，只用前j个数（斐波那契数列的前j项，从1、2、3、5开始）的方案总数。注意i很大，状态要用map存储。

预处理出$f_i$和它的前缀和$s_i$，然后进行dfs。因为$f_i$和$s_i$大于$n$的项没有意义，所以我们可以仅处理$f_i$的前$91$项和$s_i$的前89项，因为$n_{max}<f_{91},s_{89}<maxlonglong$。注意要让$s_{90}=s_{91}=\inf$

对于一个状态$(i,j)$，我们要求它对应的方案数$map[i][j]$。我们现在需要找到所有能够转移到$map[i][j]$的状态总数。先列出递推式：$$map[i][j]=\sum_kmap[i-f_k][k-1]$$

让我们来尝试理解一下这个递推式。因为题目要求输出的方案数是无序的（$1+3+8$和$8+3+1$在此题意义下是一致的），所以我们可以让$n$先被一个较大的$f_i$减去，然后再减去一个较小的$f_i$，这样一直减下去，直到$n$被减成$0$。这样，就可以保证$n$被分解的同一种方法不会被重复计算（分解的顺序已经确定，从大到小）。

那么，对于$map[i][j]$，我们可以找到所有满足条件的$f_k(f_k<f_j)$。对于每一个$f_k$，我们将$i$减去$f_k$，然后统计$map[i-f_k][k-1]$，意义是所有可以组成$i-f_k$的方案，都可以通过加上一个$f_k$得到$i$。又因为我们要保证$i$被分解的顺序，并且题目说$n$的分解中不能有相同的数，所以我们让$i-f_k$的状态有一个$k-1$的限制。

现在的问题就变成，如何求出所有满足条件的$f_k$？注意到我们之前求得的$s$序列。如果$s_k<i$，那么因为我们的分解顺序，即使将$f_1$到$f_j$加起来，都无法达到$i$。所以，我们要使$s_k>=i$。因为$s_k$有单调性，我们可以二分答案，得到最小的满足条件的$s_k$。注意$k$还有上限$j$。然后我们枚举$k$进行转移，最后输出答案，这道题就做完了。

总结一下，这道题目思维难度和代码难度都不大，主要是要注意细节。

代码如下：
```cpp
#include<cstdio> 
#include<algorithm>
#include<cmath>
#include<iostream>
#include<cstring>
#include<string>
#include<queue>
#include<map>
using namespace std;
map<long long,long long>ma[100];
long long arr[1000];
long long qzh[1000];
void dfs(long long n,int sg)
{
    if(ma[sg].count(n))return;//记忆化
    ma[sg][n]=0;
    int zuo=1,you=91,mid;
    while(zuo!=you)//二分
    {
        mid=(zuo+you)>>1;
        if(qzh[mid]<n)zuo=mid+1;
        else you=mid;
    }
    for(int i=zuo;i<=sg;i++)//枚举k
    {
        if(n-arr[i]<0)break;
        dfs(n-arr[i],i-1);
        ma[sg][n]+=ma[i-1][n-arr[i]];
    }
}
int main()
{
    for(int i=0;i<=91;i++)ma[i][0]=1;
    long long n;scanf("%lld",&n);
    arr[1]=1;arr[2]=2;qzh[0]=0;qzh[1]=1;qzh[2]=3;
    for(int i=3;i<=91;i++)arr[i]=arr[i-1]+arr[i-2];
    for(int i=3;i<=89;i++)qzh[i]=qzh[i-1]+arr[i];//求f_i和s_i
    qzh[90]=qzh[91]=4e18;//注意s_90和s_91要赋inf
    dfs(n,91);//91即可以选取全体f_i
    printf("%lld\n",ma[91][n]);//注意要输出map[91][n]
    return 0;
}
```

---

## 作者：0zhouyq (赞：2)

### P4133 题解

[传送门](https://www.luogu.com.cn/problem/P4133)

### 思路：

记忆化搜索再加上剪枝就能过。

这题深搜的参数就有两个，一个是要分解的数 $last$，另一个是分解出的 $fib_i$ 的上限 $maxn$（也就是 $i$ 的上限）。

先求 $fib$ 数组，再把它的前缀和记录到 $sum$ 数组中。

在搜索过程中：如果 $fib_i=last$，也就是 $last$ 本身就是 $fib$ 数组的一个，$ans$ 加一；否则如果 $sum_i=last$，也就是把剩下的数全取了刚好为 $last$，$ans$ 也加一。如果 $fib_i<last$ 且 $sum[i]>last$ ，就向下深搜。

最后记忆化一下就好了，结果存在 $map$ 里面。

### AC Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int fib[90],n,ans,sum[90];
map<pair<int,int>,int> mp;
void dfs(int last,int maxn){
	if(mp.find(make_pair(last,maxn))!=mp.end()){ans+=mp[make_pair(last,maxn)];return ;}
	int ml=ans;
	for(int i=maxn;i;i--){
		if(fib[i]==last) ans++;
		else if(sum[i]==last) ans++;
		if(fib[i]<last&&sum[i]>last){
			dfs(last-fib[i],i-1);
		}
	}
	mp.insert(make_pair(make_pair(last,maxn),ans-ml));
}
signed main(){
	scanf("%lld",&n);
	fib[0]=1;
	fib[1]=1;
	for(int i=2;i<=89;i++) fib[i]=fib[i-1]+fib[i-2];
	for(int i=1;i<=89;i++) sum[i]=sum[i-1]+fib[i];
	dfs(n,89);
	printf("%lld",ans);
	return 0;
}
```

[AC记录](https://www.luogu.com.cn/record/91094540)

---

## 作者：KokiNiwa (赞：2)

# 题解 [BJOI2012]最多的方案

## 解法1

首先有一个非常好想的$dp$算法，设$dp_{i,j}$表示把$i$这个数分成$\le fib_j$的斐波那契数之和。

其次还有一个非常简单的搜索算法，$dfs(num, maxFib)$的结果为把$num$分为不大于$maxFib$的所有斐波那契数之和一共有多少种分法。

两种方法相结合，预处理一部分答案，然后在计算一部分答案。预处理通过$dp$，剩下的搜索解决。当然我们还可以通过记忆话搜索解决。当然这只是考试的时候的骗分算法。

## 解法2

单纯从$dp$的角度出发，上面的$dp$肯定已经不行了，这显然需要一个数位$dp$类似的东西。但是如何数位呢？总不可能在$10$进制下一位一位地搞吧……但有一个问题，就是首先不知道目前的和是多少，总不能再记录一维表示但前的和为拆完之后的所有数之和是多少吧。**我们考虑找一个基准类似的东西，就是所有拆法都能通过某一种特定拆法变换得到。**找哪一个特定拆法作为基准，进行什么变换呢？至于拆法，我们可以把一个数拆成没有任何相邻的两个斐波那契数存在的一大堆斐波那契数之和。变换呢，我们可以通过把一位往前两位推的方式来完成。至此，把**记录目前的和=>记录前$i$位。**于是我们可以设$f_i$表示前$i$个$1$，一共有多少种拆法。对于一个斐波那契数列的第$i$项而言，找规律可以发现有$\lfloor\frac{i}{2}\rfloor$种拆法。比如$00001$（这是一个数拆成斐波那契数的形式，该位为$1$则表示再拆分中有这个数，另外，从左向右数的第$i$项的值为第$i+1$个斐波那契数，这是因为一开始有两个$1$，要去掉一个）。但是根据上一位拆不拆，中间剩下的可以供来拆当前这一位的位数就不一样了。就比如$000010000001$，第一个$1$可以如果拆，那么第二个$1$可以拆的位数就多了一位。于是设$f_{i,0/1}$表示前$i$位，最后一位为$0$则不拆，$1$则拆的方案数。然后转移即可。

## 知识点

+ 注意把一个数拆成斐波那契数的拆法，必定能拆出相邻两项不相邻的拆法。这要作为与斐波那契数列相关的题目的重要技巧。
+ $dp$的时候可以找一个类似于基准之类的东西，类似于[[六省联考2017]分手是祝愿](https://www.luogu.com.cn/problem/P3750)这道题的状态设置（那道题相当于以一个最优方案为基准的状态设置）。

## 代码

[暴力](https://paste.ubuntu.com/p/c3gVfptpFd/)，[巧妙的$dp$](https://paste.ubuntu.com/p/qCW8Qxptvp/)

---

## 作者：1234567890sjx (赞：2)

容易发现斐波那契数列增长是非常快的，在 $100$ 项之前就爆了 `long long`。

并且斐波那契数列 $f_i=f_{i-1}+f_{i-2}$，所以加起来会有很多重复的值。

也就是说如果暴力的设 $f_{i,j}$ 表示前 $i$ 个数选择的和为 $j$ 的时候的方案数，那么合法的状态数量是非常非常的少的。

所以记忆化搜索，用 `map` 来维护 $f$ 这个状态数组，直接做即可。

时间复杂度比较玄学。

---

## 作者：bifanwen (赞：2)

[博客园同步](https://www.cnblogs.com/bifanwen/p/15846546.html)

[原题链接](https://www.luogu.com.cn/problem/P4133)

简要题意：

设 $f$ 表示斐波那契数列。给定一个 $n$ ，求将 $n$ 分解为 $f$ 中若干个 **不同** 的数的和的方案数。

$n \leq 10^{18}$. 时间限制 $0.5s$.

这题想给大家分享一个能简单过掉的办法。

先把 $f$ 写出来：

$$\begin{cases}
f_n = 1 \space \space \space\space \space \space\space \space \space\space \space \space\space \space \space\space \space \space\space \space (n \leq 2) \\
f_n = f_{n-1} + f_{n-2} \space \space \space (n > 2) \\
\end{cases}$$

写一个小程序验证一下，你就会发现，$f_{88} = 1100087778366101931$ 已经超过了 $10^{18}$！

所以实际参与分解的只可能是 $f_1 - f_{87}$.

注意到有 $30 \%$ 的数据，$n \leq 256$，肯定是直接爆搜 $f$ 取和不取。但实际上，$n \leq 10^{18}$ 又为什么不能？

考虑暴力。

以 $(x,p)$ 作为一个状态，表示现在在决策 $f_x$ 取或不取，和为 $p$.

暴力考虑 $f_x$ 取或不取。

加几个剪枝。我们可以取 $s$ 作为 $f$ 的前缀和，那么如果 $p \geq s_x$，可以直接得出答案，防止连续不选太多导致大量冗余搜索。

于是我们可以得到第一份代码。

（注意：题目里有个细节，取的是 $f$ 中不同的数，也就是不能取两个 $1$，这点需要稍微弄一下）

[Link](https://paste.ubuntu.com/p/yzjQcVrCwX/plain/).

尽管本机对于一些极限数据需要跑到 $0.55s$ 左右，但在洛谷的评测机之下，毫无疑问，这通过了。

我们希望有一种更优的方法。

我们会发现，对于 $(x,p)$ 状态的个数其实是极为有限的。如果你用 `map` 计数的话，会发现即使对于 $n = 10^{18}$ 看起来极为复杂的这一种情况，其实状态个数也没有超过 $250$.

于是我们自然而然地想到了：记忆化搜索。

在暴力的基础上加一个 `map`，对于冗余的状态直接跳过。

时间复杂度：$\mathcal{O}(\texttt{wys})$.

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 88;
typedef long long ll;

ll f[N],s[N],n;

map<pair<ll,ll>,ll> q;

inline ll dfs(register ll x , register ll p) {
    if(q[make_pair(x,p)]) return q[make_pair(x,p)];
	if(!x) return 0;
	if(!p) return 1;
	if(p > s[x]) return 0;
	if(p == s[x]) return 1;
    ll ans = 0;
	if(p >= f[x]) ans += dfs(x - 1 , p - f[x]);
	ans += dfs(x - 1 , p);
    return q[make_pair(x,p)] = ans;
}

int main() {
	f[0] = f[1] = 1;
	s[0] = 0 , s[1] = 1;
	for(int i = 2; i < N; i++) {
		f[i] = f[i - 1] + f[i - 2];
		s[i] = s[i - 1] + f[i];
	}
	scanf("%lld",&n);
	printf("%lld\n",dfs(86,n));
	return 0;
}
```

---

## 作者：rq_kyz (赞：1)

# 【题解】最多的方案

### 传送门

[P4133 [BJOI2012] 最多的方案](https://www.luogu.com.cn/problem/P4133)

---

### 题意

给定一个整数 $n$，问将它分解成若干个不同的斐波那契数之和的方案数。

---

### 分析

众所众知，斐波那契数列的增长速度是指数级别的，所以就算 $n\le10^{18}$，$10^{18}$ 次方以内的斐波那契数也就一两百个（经过本蒟蒻的调试，小于等于 $10^{18}$ 的斐波那契数只有 $87$ 个）。所以大家直接先循环打表，再 DFS 就行了。

但在 DFS 时你会发现还是会超时，所以我们需要剪枝（这一步我认为才是整道题最难的地方）。

我们先来整理一下 DFS 的过程。DFS 会传进去两个参数，分别表示当前的数字和当前还剩的斐波那契数（的个数），我们就用 $n$ 和 $m$ 来表示；另外，我们设 $f_i$ 为第 $i$ 个斐波那契数。当前我们需要判断第 $m$ 个斐波那契数是否要选。如果要，就应该将 $DFS_{n,m}$ 更新为 $DFS_{n-a_m,m-1}$ ；否则就更新为 $DFS_{n,m-1}$。所以方案数总和就应该为上述两种情况的方案数之和（如果 $n<a_m$，就不加 $DFS_{n-a_m,m-1}$ 的方案数）。

我们先来一个最简单的剪枝，就是在进入 $DFS_{n,m}$ 时就先判断这种方案是否可行。具体方法是记录 $f_i$ 的前缀和数组 $s_i$，当 $n>s_m$ 时就直接返回 $0$。

但这种力度的剪枝明显还不够，只要是学过一点点动态规划的 OIer 都知道，在现在的做法之下，还会有大量的重复。所以我们需要一个数组来记录每一种状态，有点类似于动态规划和记忆化搜索。但是传入参数中的 $n\le10^{18}$，直接开一个 $n\times m$ 的数组必死无疑。这时，我们可以想到，正因为斐波那契数列的增长速度是指数级别的，所以在 DFS 的过程中 $n$ 下降的速度也是指数级别的。如果我的 $n$ 在前面几轮 DFS 的过程里一直都没有下降也没有关系，因为这样的话它很快就会被上面的那条约束条件所中止递归。而经过作者本人的调试，需要记录的 $n$ 一共只有不到 $1000$ 个。

我们整理一下思路，整道题的核心思想就是先打表，再 DFS。在 DFS 时，我们需要有两个约束条件：

- 当 $n$ 大于斐波那契数列的前 $m$ 个数之和时，直接返回 $0$。

- 用一个数组记录每种状态，防止重复计算。开的空间应该为 $1000\times87$（第一维的 $n$ 用 map 离散化）。

好的，到这里，本题的思路就讲完了（可喜可贺）。

---

本蒟蒻的 AC 代码：

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll f[87],s[87],cd=2;
ll dp[1001][87];
map<ll,ll> ma;
ll xb=0;
ll dfs(ll n,ll m){
	if(!n || !m)
		return (n?0:1);
	if(n>s[m])
		return 0;
	if(dp[ma[n]][m]>=0)
		return dp[ma[n]][m];
	ma[n]=++xb;
	ll sum=dfs(n,m-1);
	if(n>=f[m])
		sum+=dfs(n-f[m],m-1);
	return dp[ma[n]][m]=sum;
}
int main(){
	for(ll i=0;i<=1000;i++)
		for(ll j=0;j<=86;j++)
			dp[i][j]=-1;
	ll n;
	scanf("%lld",&n);
	f[0]=1;
	f[1]=1;
	s[0]=1;
	s[1]=2;
	while(f[cd-1]+f[cd-2]<n){
		f[cd]=f[cd-1]+f[cd-2];
		s[cd]=s[cd-1]+f[cd];
		cd++;
	}
	printf("%lld",dfs(n,cd-1));
	return 0;
}
```

---

## 作者：封禁用户 (赞：1)

#  分析


### 第一步

首先，我们得证明：任意自然数都可以用不同的斐波那契数所表示：

具体看[这里](https://www.zhihu.com/question/68360587)。

### 第二步

我们将数字 $n$ 暴力拆分，用一个记忆化搜索 $dp[i][j]$ 表示 用前 $j$ 个斐波那契数字将 $i$ 分解有几种分发，我们可以总结出两种状态：

1. 不用 $f[j]$，使用前 $j - 1$ 种，则状态为： $dp[i][j] = dp[i][j - 1]$。

2. 用 $f[j]$，则原拆分就是将 $n - f[j]$ 用前 $j - 1$ 个数，则状态为： $dp[i][j] =dp[n - f[j]][j -1]$。

### 第三步

如果我们直接判断，可能会 TLE,所以我们要一些优化：

1. 若 $n=0$，则答案就是 $1$。

2. 若 $j=0$，则答案就是 $0$。

3. 若当前的 $i$ 比斐波那契前 $j-1$ 和还要大，那么就必须选 $f[j]$。

那么这题就愉快的完成了。

## AC 代码

```cpp
/*****************************************
备注：
******************************************/
#include<queue>
#include<math.h>
#include<stack>
#include<stdio.h>
#include<iostream>
#include<vector>
#include<iomanip>
#include<map>
#include<string.h>
#include<algorithm>
#include<set>
using namespace std;
#define int long long
const int MAXN = 1e6 + 10;
const int MR = 10 + 5;
const int INF = 0x3f3f3f3f;
const int MOD = 1e6 + 33;
int pre[MAXN],f[MAXN];
int n;
map<pair<int, int>, int> dp;//记录sum用前num个斐波那契数列表示有几种
int dfs(int sum,int num)
//将sum用前num个斐波那契数列表示有几种 
{
	if(!sum)return !sum;
	if(sum < 0 || !num)return 0;
	pair<int, int> t = make_pair(sum, num);
	if(dp.count(t))
	{
		return dp[t];//记搜 
	}
	if(sum >= pre[num - 1])
	{
		dp[t] = dfs(sum - f[num], num - 1);
		return dp[t];
	}
	dp[t] = (dfs(sum, num - 1) + dfs(sum - f[num], num - 1));
	return dp[t];
}
void prework()
{
	f[0] = f[1] = 1;
	pre[0] = 1;
	pre[1] = 2;
	for(int i = 2;i <= 87; i++)
	{
		f[i] = f[i - 1] + f[i - 2];
		pre[i] = pre[i - 1] + f[i];
	}
}
signed main()
{
	cin >> n;
	prework();
	cout << dfs(n, 87);
	return 0;
}
```

---

## 作者：arkerny (赞：1)

考虑记忆化搜索：

对于数 $n$：

从大到小枚举上界 $lim$（从小到大枚举显然可以预先计算一部分更小的结果，故复杂度有较大优化）。

对于斐波那契数 $Fib_m$ 当 $n$ 大于 $\sum\limits_{k=1}^{m-1}Fib_k$ 时选择 $Fib_k$ 显然优于其他方案，故使用前缀和与二分来对下界枚举的复杂度进行优化。

加上这两个优化以后就可以过了。

``` cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define lowbit(_x) (_x&-_x)
#define clr(_arr,_val) memset(_arr,_val,sizeof(_arr));

ll fib[110];
ll sum[110];
ll n;

map<pair<ll,int>,ll> mem;   //记忆化数组

ll dfs(ll n,int lim)
{
    if(n==0)
    {
        return 1;
    }
    if(mem[make_pair(n,lim)])
    {
        return mem[make_pair(n,lim)];
    }
    ll ans=0;
    int pos=lower_bound(sum+1,sum+88,n)-sum;
    for(int i=pos;i<=lim;i++)
    {
        if(fib[i]<=n)
        {
            ans+=dfs(n-fib[i],i-1);
        }
        else
        {
            break;
        }
    }
    mem[make_pair(n,lim)]=ans;
    return ans;
}

void init()
{
    fib[0]=fib[1]=1;
    for(int i=2;i<=90;i++)
    {
        fib[i]=fib[i-1]+fib[i-2];
    }
    for(int i=1;i<=90;i++)
    {
        sum[i]=sum[i-1]+fib[i];
    }
    return ;
}

int main()
{
    init();
    scanf("%lld",&n);
    printf("%lld",dfs(n,87));   //打表可知与第一的超过 1e18 的斐波那契数位于数列第 88 个
    return 0;
}
```

---

## 作者：COsm0s (赞：1)

## 思路

+ 任意自然数都可以表示为 $n$ 个不相同斐波那契数的和。

+ 转移方程：令 $f_{i,j}$ 是用前 $i$ 项拼成 $j$ 的总方案数。即：

	$F_{i,j}=F_{i-1,j}+F_{i-a_j,j}$

+ 再看数据：$n \leq 10^{18}$，那毫无疑问，数组超限。但是，c++ 有个神器——`map`。我们可以用 `map` 装大数，再用记忆化搜索解决这个问题。

+ 但是，这样做还是会 T 几个点。我们注意到题目只是让我们求总和，求线性总和可用到前缀和预处理优化，在搜索中省掉一重循环，这样，就可以过了。

## Code：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
inline int read() {
	int x = 0, m = 1;
	char ch = getchar();
	while(!isdigit(ch)) {
		if(ch == '-') m = -1;
		ch = getchar();
	}
	while(isdigit(ch)) {
		x = x * 10 + ch - 48;
		ch = getchar();
	}
	return x * m;
}
inline void write(int x) {
	if(x < 0) {
		putchar('-');
		write(-x);
		return;
	}
	if(x >= 10) write(x / 10);
	putchar(x % 10 + '0');
}
//快读快输
const int N = 1e3 + 10;
map<int, int> f[N];
int a[N], sum[N];
int n;
inline void init() {
	n = read();
	a[0] = a[1] = sum[0] = 1;
	sum[1] = 2;
	for (int i = 2; i <= 90; i ++) {
		a[i] = a[i - 1] + a[i - 2];
		sum[i] = sum[i - 1] + a[i];//前缀和操作
	}
}
int dfs(int n, int m) {
	if (n < 0) return 0;
	if (m == 0 || n == 0)
		if(n == 0) return 1;
			else return 0;
	if (f[m].count(n)) return f[m][n];//记忆化
	if (n > sum[m - 1] - 1) f[m][n] = dfs(n - a[m], m - 1), return f[m][n];
	f[m][n] = dfs(n, m - 1) + dfs(n - a[m], m - 1);
	return f[m][n];
}

signed main() {
	init();//初始化
	write(dfs(n, 90));//10^18最多跑到90项
	return 0;
}
```


---

## 作者：到底几只鱼呢 (赞：1)

题目传送门：[link](https://www.luogu.com.cn/problem/P4133)

首先读题，我们发现虽然 $n$ 很大，但由于是斐波那契数列，增长速度呈指数级，所以可选的数并不多，考虑DP。

首先，斐波那契数列的性质有：**任意自然数都能被不相同的斐波那契数之和表示。**

接下来，贪心地想：假定有一个满足的排列，那么我们可以对其合并，由于 $a[i]=a[i-1]+a[i-2]$，所以这个序列一定可以合并为不含**相邻项**的序列，我们可以用这个**个数最少**的序列作拆分，一定可以得到其它合法方案。

所以可得预处理：即求出每个不相邻斐波那契数的位置，使其凑成 $n$。

那么，如何转移？

还是考虑贪心。每次拆分最大的数，最好处理，也是最优的。

设 $dp[i][0/1]$ 表示第 $i$ 个数是否拆分，我们要保证的是每次拆分最大的。

由于要保证最大，设当前最大的数为 $i$。

分两种情况：

- $i$ 不拆：前面的不受影响，拆或不拆直接继承；
- $i$ 拆分：考虑用 $i$ 前面的来凑第 $i$ 个数，则使用的区间为前一个数的位置到 $i$ 之间的位置，由于上述性质，则设区间长为 $x$，可行的方案数即为 $x/2$。唯一的区别在与前一个数是否取（区间长 $-1$ ）。
如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/85bd3256.png)

- 取 $stack[i+1]$ ，区间为 $B$ 区间
- 不取 $stack[i+1]$ ，区间为 $A+B$ 区间
- $A$ 区间即为 $stack[i+1]$ 表示的数

综上，dp方程：
##### 注：由于是倒着入栈的，$i$ 对应的数大于 $i+1$ 对应的，遍历的时候也应该倒序,即从小往大扩展。

$$
dp[i][1]=dp[i+1][0]+dp[i+1][1]
$$

$$
dp[i][0]=dp[i+1][0] * ((stack[i]-stack[i+1])/2)+dp[i+1][1] * ((stack[i]-stack[i+1]-1)/2)
$$
### Code：

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <cstdlib>
#include <queue>
using namespace std;

const int maxn=105;
long long n,a[maxn],i;
long long stack[maxn],top;
long long dp[maxn][2];

int main() {
	cin>>n;
	a[1]=1;a[2]=2;
	for(i=3;a[i-1]+a[i-2]<=n;i++) {
		a[i]=a[i-1]+a[i-2];
	}
	for(i--;i&&n;i--) {
		if(n>=a[i]) {
			n-=a[i];
			stack[++top]=i;
		}
	}
	dp[top][0]=(stack[top]-1)/2;
	dp[top][1]=1;
	for(int i=top-1;i;i--) {
		dp[i][1]=dp[i+1][0]+dp[i+1][1];
		dp[i][0]=dp[i+1][0]*((stack[i]-stack[i+1])/2)+dp[i+1][1]*((stack[i]-stack[i+1]-1)/2);
	}
	cout<<dp[1][0]+dp[1][1];
	return 0;
}
```


---

## 作者：wangruibo20 (赞：0)

## 思路
首先，我们需要证明任何正整数都可以被不相同的斐波拉契数之和来表示。

简略证明一下:

令 $n$ 为某一正整数。
- 当 $n$ 为斐波拉契数中的某项时，显然 $n$ 能被表示；

- 不是时，取一整数 $k$，使得 $f_{k} < n < f_{k+1}$。令 $m=n-f_{k}$，则 $m < f_{k+1}-f_{k}=f_{k-1}$，所以用于表示 $m$ 的斐波拉契数中不可能有 $f_{k}$，所以 $n$ 一定能被 $f_{k}$ 与 $m$ 的斐波拉契数表示出来。

经过一番~~严谨的~~证明后，我们就有了一些思路：直接用暴搜枚举第 $i$ 个斐波拉契数选还是不选。

经过实践，此方法可行。（因为即使是 $10^{18}$，枚举到第 $87$ 项（$f_{87} \approx 1.1 \times 10^{18}$）也足够了）

当然，如果不剪枝，就会 TLE 成这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/loaa6msb.png)

###### （终于知道不加记忆化搜索会多么T了）
还有一个小细节：当现枚举到的 $n$ 比前 $m-1$ 个斐波拉契数还要大时，必须要选 $f_{m}$。
###### （要不然就会莫名 RE???）
![](https://cdn.luogu.com.cn/upload/image_hosting/v80yg4g4.png)

## 代码
###### ~~你们最喜欢的代码环节到了~~
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll n,f[95],s[95],a[10005][95],i=2,c;
map<ll,ll>x;
inline ll dfs(ll n,ll m){
	if(n==0)return 1;
	if(m==0)return 0;
	if(a[x[n]][m])return a[x[n]][m];
	x[n]=++c;
	if(n>s[m-1])return a[x[n]][m]=dfs(n-f[m],m-1);
	return a[x[n]][m]=(n>=f[m]?dfs(n-f[m],m-1):0)+dfs(n,m-1);
}int main(){
	scanf("%lld",&n);
	f[1]=f[0]=s[0]=1,s[1]=2;
	for(;f[i-1]<=n;i++)s[i]=s[i-1]+(f[i]=f[i-1]+f[i-2]);
	printf("%lld",dfs(n,i-1));
	return 0;
}
```

---


# [SCOI2006] 整数划分

## 题目描述

从文件中读入一个正整数 $n$（$10 \le n \le 31000$）。要求将 $n$ 写成若干个正整数之和，并且使这些正整数的乘积最大。

例如，$n=13$，则当 $n$ 表示为 $4+3+3+3$（或 $2+2+3+3+3$）时，乘积 $=108$ 为最大。

## 说明/提示

### 数据范围及约定

对于全部数据，$10 \le n \le 31000$，同时保证最大乘积的位数不超过 $5000$ 位。

## 样例 #1

### 输入

```
13```

### 输出

```
3
108
```

# 题解

## 作者：劉子颺 (赞：22)

定理：对于给定的正整数n>2，为了将n写成若干个正整数之和，并且使这些正整数的乘积最大。只须将 n写成若干个2与3的和，并满足：

 2p+3q=n.

其中， 

q=(n-2p)/3.

    定理的证明：设a是将n做最大乘积分解（简称最优分解）后的任一项，下面证2≤a≤4。

1. 若a=1，设b是将n做最优分解后的另一项，则 a\*b=1\*b=b<1+b，即把a,b合并为一项后，总乘积会更大，故必有2≤a。
2. 若a≥5，则容易证明这时成立：a<3(a-3)，即把a分解为两项：3与a-3之后，总和不变，而总乘积会更大，故必有a≤4。
3. 由于4=2\*2=2+2，因此最优分解中，可用2个2代替1个4。又由于2+2+2=3+3，而2\*2\*2<3\*3，因此3个2应该用2个3代替。证毕。


补充下面证明实现的代码
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<vector>
using namespace std;
int n;
class Big{
public:
    vector<int> bits;
    int cnt;
    void clear(){
    	cnt=0;
    	bits.push_back(1);
    }
    void mul(int n){
        for(int i=0;i<=bits.size();i++){
			bits[i]*=n;
        }
        for(int i=0;i<bits.size();i++){
            if(bits[i]>=10){
                if(i+1<bits.size())
                    bits[i+1]+=bits[i]/10;
                else{
                	bits.push_back(bits[i]/10);
                }
                bits[i]%=10;
            }
        }
    }
    void print(){
		for(int i=bits.size()-1;i>=0;i--){
    		putchar('0'+bits[i]);
    	}
    	printf("\n");
    }
    void re(){
    	reverse(bits.begin(),bits.end());
    }
    int siz(){
    	return bits.size();
    }
    void choose_print(int len){
    	int tot=0;
		for(int i=bits.size()-1;i;i--){
			tot++;
			putchar('0'+bits[i]);
			if(tot==len){
				break;
			}
		}
		printf("\n");
    }
}ans;
int main(){
	cin>>n;
	ans.clear();
//	cout<<21378<<endl;
	while(n>4){
		ans.mul(3);
		n-=3;	
	}	
	if(n==4){
		ans.mul(4);
	}
	if(n==3){
		ans.mul(3);
	}
	if(n==2){
		ans.mul(2);
	}
	cout<<ans.siz()<<endl;
	if(ans.siz()<=100){
		ans.print();
	}
	else{
		ans.choose_print(100);
	}
//	ans.print();
}
```

---

## 作者：pufanyi (赞：15)

以下纯口胡，如果问题求私信我。

根据均值不等式（证明在最下面）：
$$\prod_{i=1}^n x_i\le \left(\frac{\sum_{i=1}^nx_i}{n}\right)^n$$
先不考虑整数的限制，我们应将一个数均匀地分成$k$份，每个数为$x$，那么有：
$$n=kx$$

另乘积为$y$，有：
$$y=x^k=x^{\frac{n}{x}}=(x^{\frac{1}{x}})^n$$

于是问题就变成了求$y=x^{\frac{1}{x}}$在$x>0$上的极值。

两边同取对数：
$$\ln y = \frac{1}{x}\ln x$$
两边同时关于$x$求导：
$$\frac{y'}{y}=-\frac{1}{x^2}\ln x+\frac{1}{x^2}=\frac{1-\ln x}{x^2}$$

右边应该没问题，那左边为什么不是$\frac{1}{y}$呢？

因为$y$是个因变量，其导数不一定就是$1$，即$x$增加$\mathrm{d}x$，$y$不一定增加$\mathrm{d}x$。

但我们有：
$$f[g(x)]=f'(x)g'(x)$$
于是：

$$y'=\frac{1-\ln x}{x^2}y=\frac{1-\ln x}{x^2}x^{\frac{1}{x}}$$

当$y'=0$时：
$$\frac{1-\ln x}{x^2}x^{\frac{1}{x}}=0$$
由于$x>0$：
$$1-\ln x=0$$
即：
$$x=e$$
但$e$不是整数，由于$\lfloor e\rfloor=2,\lceil e\rceil=3$，且

$$2^{\frac{1}{2}}\approx1.4142135623730950488016887242097$$
$$3^{\frac{1}{3}}\approx1.4422495703074083823216383107801$$

所以
$$2^{\frac{1}{2}}<3^{\frac{1}{3}}$$

因此应该尽量取$3$，多出来的取$2$。

下面给出均值不等式的一种证法：

有一种叫“反向归纳法”的东西，它是从$n$到$n-1$来证明命题。

我们令原命题为$P(n)$。

首先，$n=2$时显然为真：
$$\sqrt{ab}\le \frac{a+b}{2}$$
然后证明$P(n)$和$P(2)$蕴涵着$P(2n)$：

因为：
$$\prod_{i=1}^n x_i\le \left(\frac{\sum_{i=1}^nx_i}{n}\right)^n$$
$$\prod_{i=n+1}^{2n} x_i\le \left(\frac{\sum_{i=n+1}^{2n}x_i}{n}\right)^n$$
两式相乘：
$$\prod_{i=1}^{2n} x_i\le \left(\frac{\sum_{i=1}^{n}x_i}{n}\right)^n\times\left(\frac{\sum_{i=n+1}^{2n}x_i}{n}\right)^n\le \left(\frac{\sum_{i=1}^{2n}x_i}{2n}\right)^{2n}$$
最后证明$P(n)$蕴涵着$P(n-1)$：

令$x_n=\frac{\sum_{i=1}^{n-1}x_i}{n-1}$即$x_n$为前$n-1$项的平均值，我们发现这$n$项的平均值为前$n-1$项的平均值，即：
$$\prod_{i=1}^{n-1} x_i\times\frac{\sum_{i=1}^{n-1}x_i}{n-1}\le \left(\frac{\sum_{i=1}^{n-1}x_i}{n-1}\right)^n$$
两边同除$\frac{\sum_{i=1}^{n-1}x_i}{n-1}$：
$$\prod_{i=1}^{n-1} x_i \le \left(\frac{\sum_{i=1}^{n-1}x_i}{n-1}\right)^{n-1}$$

---

## 作者：zhaotiensn (赞：6)

(竟然没有人写c++的题解，果然c++的高精相比与Python和Java实在是太麻烦了)

一开始看到这题还以为是**DP**，像是**划分一个序列**一样，但是怎么想都想不出来，主要是时间上承受不起，高精乘高精有n^2,高精乘单精也要有n的复杂度，再算上DP的复杂度想都不用想一定TLE。FFT的高精乘我这个蒟蒻不会，乘法没有办法优化，所以只能想别的办法了。

划分序列主要是将一个序列划分为k段，但这题没有要求数被划分的部分数，也没有限制是否相同，显然肯定是**划分的越平均，它们总的积越大**(这个就不用解释了吧，毕竟连我这个蒟蒻都知道)，所以可以来**枚举划分的部分数或每一部分的值**。

**枚举**代码：
```cpp
#include<iostream>
#include<cstdio>
#define ll long long
using namespace std;

int n,ans;

inline int power(int x,int p) {//快速幂 
	if(p==0)return 1;
	ll ans=1;
	while(p) {
		if(p&1) {
			ans*=x;
		}
		x*=x;
		p/=2;
	}
	return ans;
}

int main() {
	scanf("%d",&n);
	for(int i=2; i<=n; i++) {//枚举每一份的值
		ans=max(ans,power(i,n/i)*max(1,(n%i)));//特判余数
		ans=max(ans,power(i,n/i-1)*(n%i+i));//余数为1的时候要加上，乘以1的话1没有任何贡献
	}
	printf("%d\n",ans);
	return 0;
}
```

不过这样还是有点慢，所以要继续优化。可以近似的看出这是一个**单峰**的函数，然后就可以用**三分**来优化，可以跑的稍微快一点。

**三分**代码：
```cpp
#include<iostream>
#include<cstdio>
#define ll long long
using namespace std;

int l,r,midl,midr,n,ans;

inline int power(int x,int p) { //快速幂
	if(p==0)return 1;
	ll ans=1;
	while(p) {
		if(p&1) {
			ans*=x;
		}
		x*=x;
		p/=2;
	}
	return ans;
}

inline int calc(int k) { //计算每一份值为k时的答案
	return max(power(k,n/k)*max(1,(n%k)),power(k,n/k-1)*(n%k+k));
}//特判余数，因为余数为1的时候要加上，乘以1的话1又没有任何贡献

int main() {
	scanf("%d",&n);
	l=1;
	r=n;
	while(l<r) { //三分每一份的值
		int block=(r-l)/3;
		midl=l+block;
		midr=r-block;
		if(calc(midl)>=calc(midr)) {
			r=midr-1;
		} else {
			l=midl+1;
		}
	}
	printf("%d\n",calc(l));
	return 0;
}
```

但是三分仍然不是正解，它还是不够快。

因为划分的越平均，它们总的积越大，所以说划分出来的大多数数其实是一样的，这题最后的结果可以近似的写为(n/k)^k，然而这个(n/k)大多数的情况都是3，这显得很神奇，但其实这是必然的，如果(n/k)可以为浮点数，那么三分这个(n/k)会不断的逼近**2.71828**,这个数想必大家都认识吧，也就是**e**的近似值，所以说(n/k)越接近e，最终的值越大。(所以说上面的方法都是废话，什么用都没有，只是我自己弱，没有想到而已，**函数y=x^(1/x)的最大值在x=e时得**大概也就我这个蒟蒻不知道了)因为要是整数，而3是最接近e的整数，所以要尽量把每一份分成3。知道了这一点后就很水了，只要每份分成3，然后特判一下余数。然后写个高精乘单精，或者用高精乘高精(这样可以用快速幂),然后就能水过了。

**AC代码**：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define ll long long
using namespace std;

struct bigint { //结构体存高精
	int mark,size,num[20005];
	inline bigint operator=(const bigint& x) { //重载赋值符号
		memset(num,0,sizeof num);
		mark=x.mark;
		size=x.size;
		for(int i=1; i<=x.size; i++) {
			num[i]=x.num[i];
		}
		return *this;
	}
};

inline void change(bigint &x) { //检查前导零
	while(x.num[x.size]==0) {
		x.size--;
	}
	if(x.size<=0)x.size=1,x.num[1]=0;
}

inline void write(bigint x) { //输出高精数
	change(x);
	if(x.mark==1) {
		putchar('-');
	}
	for(int i=x.size; i>=max(1,x.size-99); i--) { //限制为100位
		putchar(x.num[i]+'0');
	}
	putchar('\n');
}

inline bigint tobigint(ll a) { //将整形转化为高精数
	bigint c;
	memset(c.num,0,sizeof c.num);
	if(a<0) {
		a=-a;
		c.mark=1;
	} else c.mark=0;
	c.size=0;
	while(a>0) {
		c.num[++c.size]=a%10;
		a=a/10;
	}
	change(c);
	return c;
}

inline bigint operator*(bigint a,bigint b) { //高精乘高精(本人蒟蒻，不会用FFT)
	bigint c;
	memset(c.num,0,sizeof c.num);
	if(a.mark==b.mark) {
		c.mark=0;
	} else {
		c.mark=1;
	}
	c.size=a.size+b.size-1;
	for(int i=1; i<=a.size; i++) {
		for(int j=1; j<=b.size; j++) {
			c.num[i+j-1]+=a.num[i]*b.num[j];
			if(c.num[i+j-1]>9) {
				c.num[i+j]+=c.num[i+j-1]/10;
				c.num[i+j-1]%=10;
				if(i+j>c.size)c.size++;
			}
		}
	}
	change(c);
	return c;
}

inline bigint operator*(bigint a,int b) { //高精乘单精
	return a*tobigint(b);//偷了个懒，直接转化乘高精进行计算
}

int n,p,l;
bigint ans;

inline bigint pow(bigint x,int p) { //高精快速幂
	if(p==0) {
		return tobigint(1);
	}
	bigint ans=tobigint(1);
	while(p) {
		if(p&1)ans=ans*x;
		x=x*x;
		p/=2;
	}
	return ans;
}

int main() {
	scanf("%d",&n);
	l=n%3;//l存余数
	if(l==1) { //余数为1特判
		l=l+3;
		p=n/3-1;
	} else { //同上
		p=n/3;
	}
	ans=pow(tobigint(3),p)*max(l,1);//计算
	printf("%d\n",ans.size);
	write(ans);
	return 0;
}
```
(本人实在是太渣了，高精写的太丑，其实不用那么长)

---

## 作者：Shikita (赞：6)

# 又是高精度的题目，但是这次我不用模板，选择拆分之后简单化

要求整数划分，且积越大，就如同矩形周长划分求面积最大，那么就是正方形最大，即越平均答案越大。
于是，将一个数划分，就是不断分成两份的过程，如果是奇数则为n/2和n/2+1，偶数则为n/2和n/2，最终结果必定是x个3和y个2。
由于2^3=8,2+2+2=6，而3^2=9,3+3=6，如果遇到3个2则用两个三替换

## 题目的小坑点
1:3与2的替换
2：进位的计算
3：关于替换之后的残留问题
### 代码
```
#include<iostream>
#include<queue>
#include<cstring>
#include<cstdio>
#include<cctype>
#include<algorithm>
using namespace std;
long long n;
queue<long long>q;
int f[50005],cnt=1;//储存原数
int a[50005];//进位数组
int c2,c3;
void change(int x)
{
    for(int i=1;i<cnt;++i)
    {
        f[i]*=x;
        if(f[i]>=10)
        {
            a[i+1]=f[i]/10;
            f[i]=f[i]%10;
        }
    }//第一次乘和进位处理，一定要开一个数组不然会把进位的数一起做下一次乘法
    f[cnt]*=x;
    if(f[cnt]>=10)
    {
      
        a[cnt+1]=f[cnt]/10;
        f[cnt]=f[cnt]%10;
        cnt++;
    }//当超出当前最大位数时要加特判进位，并更新最大位数cnt
    for(int i=1;i<=cnt;++i)
    {
    	f[i]=a[i]+f[i];
    	if(f[i]>=10)
    	{
    		f[i+1]+=f[i]/10;
    		f[i]=f[i]%10;
    		if(i==cnt) cnt++;
    	}	
    } //加上进位的数，并且也要判断是否需要进位
    memset(a,0,sizeof(a));//用完清零
}
int main()
{
    scanf("%d",&n);
    q.push(n);
    while(!q.empty())
    {
        int x=q.front();q.pop();
        if(x==2||x==3)
        {
        	(x==2)?c2++:c3++;
            continue;
        }
        q.push(x/2);
        q.push(x-x/2);
    }//队列分解因数
    if(c2>=3)
    {
    	c3+=c2/3*2;
    	c2=c2%3;
    }//用3替换2
    f[1]=1;//初值不能为0
    for(int i=1;i<=c3/2;++i)
    change(9); //由于我的算法为一位乘多位，3也是乘，9也是乘，不如用9替换3可以节约一点时间
    if(c3%2!=0)
    	change(3);//多出的3要乘回
    if(c2!=0)//这里一定要特判，在下因为没特判碰见3的倍数就全部输出0
    change(c2*2);
    cout<<cnt<<endl;
    reverse(f+1,f+cnt+1);//数组翻转，其实无所谓，只不过看起来舒服
    for(int i=1;i<=min(100,cnt);i++)
    	cout<<f[i];
}
```
其实这题直接拿一个模板做也非常简单，只不过既然都拆分开了又乘回去感觉挺烦的，而且一位乘多位代码实现也比多位乘多位简单易懂的多，于是就多多指教吧。

---

## 作者：critnos (赞：3)

可以简单的用 python 做：

根据大眼观察法，我们发现，  $n$ 只能拆成一堆 $2$ 和 $3$ 的和。而且 $3$ 要尽量多。

那么分类讨论：

*  $n \bmod 3 =0$ 直接把 $n$ 拆成 $\dfrac n 3$ 个 $3$ 。

*  $n \bmod 3 =1$ 因为没有办法直接把 $n$ 拆成 $\dfrac n 3$ 个 $3$，所以先减去两个 $2$ ，剩下的 $n \bmod 3 =0$ ，同上。

* $n \bmod 3 =2$ 用同样的方法，减去 $1$ 个 $2$ 就可以使剩下的 $n \bmod 3 =0$ 。

```python
n=int(input())
n=int(n)
if n%3==0:
    ans=3**(int(n/3))
if n%3==1:
    ans=3**(int((n-4)/3))*4
if n%3==2:
    ans=3**(int((n-2)/3))*2
ans=str(ans)
print(len(ans))
i=0
while i<len(ans) and i<100:
    print(ans[i],end='')
    i=i+1
```


---

## 作者：_jimmywang_ (赞：3)

# 第二篇蓝题题解

让我们想一想，n划分成什么最优？

~~（首先一定要保证划分出来的数接近）~~

来暴搜枚举一下：
```
n=1:1=1
n=2:2=2
n=3:3=3
n=4:4=2*2
n=5:6=2*3
n=6:9=3*3
n=7:12=3*2*2
n=8:18=3*3*2
n=9:27=3*3*3
...... 
```
都是2或3呢~~~

所以得到~~贪心~~数学策略：取3取到n<3或n=4

进一步：
```
if(n%3==0)ans=pow(3,n/3);
if(n%3==1)ans=pow(3,n/3-1)*4
if(n%3==2)ans=pow(3,n/3)*2
```
所以有了30分代码：
```
#include<bits/stdc++.h>
using namespace std;
long long n;
long long ans;
int cmp;
inline long long read(){
	long long x=0,f=1;
	char c=getchar();
	if(c=='-')f=-1;
	else x=x*10+c-'0';
	c=getchar();
	while(c>='0'&&c<='9')x=x*10+c-'0',c=getchar();
	return x*f;
}
int main(){
	n=read();
	if(n%3==0)ans=pow(3,n/3);
	if(n%3==1)ans=pow(3,n/3-1)*4;
	if(n%3==2)ans=pow(3,n/3)*2;
	long long aans=ans;
	while(aans)aans/=10,cmp++;
	cout<<cmp<<endl;
	cout<<ans;
	return 0;
}

```

# ？？？？ 方法错了？？？？

### 提示：在给定的范围内，最大乘积的位数不超过5000位。----by P4157[SCOI2006]整数划分



~~(眼瞎*1)~~

加高精~~

```
#include<bits/stdc++.h>
using namespace std;
long long n;
int a[5010];
void mul(int x){
	int q=0;
	for(int i=1;i<=a[0]+1;i++){
		a[i]=a[i]*x+q;
		q=a[i]/10;
		a[i]%=10;
	}
	if(a[a[0]+1])a[0]++;
}
inline long long read(){
	long long x=0,f=1;
	char c=getchar();
	if(c=='-')f=-1;
	else x=x*10+c-'0';
	c=getchar();
	while(c>='0'&&c<='9')x=x*10+c-'0',c=getchar();
	return x*f;
}
int main(){
	cin>>n;
	a[0]=1,a[1]=1;
	if(n%3==0){
		for(int i=1;i<=n/3;i++)mul(3);
		cout<<a[0]<<endl;
		for(int i=a[0];i>=1;i--)cout<<a[i];
		return 0;
	}
	if(n%3==1){
		for(int i=1;i<=n/3-1;i++)mul(3);
		mul(4);
		cout<<a[0]<<endl;
		for(int i=a[0];i>=1;i--)cout<<a[i];
		return 0;
	}
	if(n%3==2){
		for(int i=1;i<=n/3;i++)mul(3);
		mul(2);
		cout<<a[0]<<endl;
		for(int i=a[0];i>=1;i--)cout<<a[i];
		return 0;
	}
	return 0;
}


```
# 50？？？

### 第2行输出最大乘积的前100位，如果不足100位，则按实际位数输出最大乘积。----by P4157[SCOI2006]整数划分


~~(眼瞎*2)~~

##### 再抢救一下吧……

```
#include<bits/stdc++.h>
using namespace std;
long long n;
int a[5010];
void mul(int x){
	int q=0;
	for(int i=1;i<=a[0]+1;i++){
		a[i]=a[i]*x+q;
		q=a[i]/10;
		a[i]%=10;
	}
	if(a[a[0]+1])a[0]++;
}
inline long long read(){
	long long x=0,f=1;
	char c=getchar();
	if(c=='-')f=-1;
	else x=x*10+c-'0';
	c=getchar();
	while(c>='0'&&c<='9')x=x*10+c-'0',c=getchar();
	return x*f;
}
int main(){
	cin>>n;
	a[0]=1,a[1]=1;
	if(n%3==0){
		for(int i=1;i<=n/3;i++)mul(3);
		cout<<a[0]<<endl;
		for(int i=a[0];i>=max(a[0]-99,1);i--)cout<<a[i];
		return 0;
	}
	if(n%3==1){
		for(int i=1;i<=n/3-1;i++)mul(3);
		mul(4);
		cout<<a[0]<<endl;
		for(int i=a[0];i>=max(a[0]-99,1);i--)cout<<a[i];
		return 0;
	}
	if(n%3==2){
		for(int i=1;i<=n/3;i++)mul(3);
		mul(2);
		cout<<a[0]<<endl;
		for(int i=a[0];i>=max(a[0]-99,1);i--)cout<<a[i];
		return 0;
	}
	return 0;
}


```
终于AC了


---

## 作者：da32s1da (赞：3)

最近再练**FFT**，一看这个题，是个结论题，即尽可能多取3。

然后是个高精了，但是我这里用FFT实现。
```
#pragma GCC optimize(3)
#include<cstdio>
#include<cmath>
#include<iostream>
using namespace std;
typedef double D;
const int N=16500;
const D pai=3.141592653589793238462643383279;
struct cox{
    D x,y;
    cox(D xx=0,D yy=0){x=xx;y=yy;}
}a[N],b[N];
cox operator + (const cox &u,const cox &v){
    return cox(u.x+v.x,u.y+v.y);
}
cox operator - (const cox &u,const cox &v){
    return cox(u.x-v.x,u.y-v.y);
}
cox operator * (const cox &u,const cox &v){
    return cox(u.x*v.x-u.y*v.y,u.x*v.y+u.y*v.x);
}
int n,rnk[N],c[N],len=16384,cn=13;
void fft(cox *t,int op){
    for(int i=0;i<len;i++)if(i<rnk[i])swap(t[i],t[rnk[i]]);
    for(int i=1;i<len;i<<=1){
        cox wn(cos(pai/i),op*sin(pai/i));
        for(int j=0,jj=i<<1;j<len;j+=jj){
            cox w(1,0);
            for(int k=0;k<i;k++,w=w*wn){
                cox r=t[j+k],rr=w*t[i+j+k];
                t[j+k]=r+rr;
                t[i+j+k]=r-rr;
            }
        }
    }
}
//FFT
void po(int op){
    if(op){
        fft(a,1);fft(b,1);
        for(int i=0;i<=len;i++)a[i]=a[i]*b[i];
        for(int i=0;i<=len;i++)b[i]=b[i]*b[i];
        fft(a,-1);fft(b,-1); //处理乘法
        
        for(int i=0;i<=len;i++)c[i]=(int)(a[i].x/len+0.5);
        for(int i=0;i<=len;i++)
        if(c[i]>=10)c[i+1]+=c[i]/10,c[i]%=10;
        for(int i=0;i<=len;i++)a[i].x=c[i],a[i].y=0,c[i]=0;//处理进位
        
        for(int i=0;i<=len;i++)c[i]=(int)(b[i].x/len+0.5);
        for(int i=0;i<=len;i++)
        if(c[i]>=10)c[i+1]+=c[i]/10,c[i]%=10;
        for(int i=0;i<=len;i++)b[i].x=c[i],b[i].y=0,c[i]=0;//处理进位
    }else{
        fft(b,1);
        for(int i=0;i<=len;i++)b[i]=b[i]*b[i];
        fft(b,-1);  //处理乘法
        
        for(int i=0;i<=len;i++)c[i]=(int)(b[i].x/len+0.5);
        for(int i=0;i<=len;i++)
        if(c[i]>=10)c[i+1]+=c[i]/10,c[i]%=10;
        for(int i=0;i<=len;i++)b[i].x=c[i],b[i].y=0,c[i]=0;  //处理进位
    }
}//快速幂
int main(){
    scanf("%d",&n);
    if(n==1){puts("1");return 0;}
    if(n==2){puts("2");return 0;}
    if(n%3==1)a[0]=4,n-=4;
    else if(n%3==2)a[0]=2,n-=2;
    else a[0]=1;
    b[0]=3;n/=3;
    for(int i=0;i<len;i++)rnk[i]=(rnk[i>>1]>>1)|((i&1)<<cn);//预处理
    for(;n;n>>=1)po((n&1)?1:0);//快速幂
    int i;
    for(i=len;a[i].x==0;i--);
    printf("%d\n",i+1);
    if(i<=99)for(;i>=0;i--)printf("%d",(int)a[i].x);
    else for(int j=100;j;j--,i--)printf("%d",(int)a[i].x);//输出
}
```

---

## 作者：piuke (赞：2)

话说这是我第一篇数论方面的题解啊……如有不足，请大佬们给予指导
# 题目描述
[~同样的小网址~](https://www.luogu.org/problemnew/show/P4157)
# 题意分析
给出一个数$n$，把这个数分解成很多个正整数的和，然后把分解出来的这些数撑起来，求最大的积
# 数学分析
按照那句老话，数学上来先打表，所以
1. 排除（浪费）
2. 最大积$\ =2$
3. 最大积$\ =3$
4. 最大积$\ =2*2=4$
5. 最大积$\ =2*3=6$
6. 最大积$\ =3*3=9$
7. 最大积$\ =2*2*3=12$
8. 最大积$\ =2*3*3=18$
………………

诶？列举了这么多(哪里多了)，都是分解成2和3？那是不是就可以按照这个规律，全部都分解成2和3呢？
答案是肯定的。

为什么呢？~~因为这是一个结论题。~~

尽可能将这个数分成两半来解决。如果是偶数，那么分成$n/2+n/2$；如果是奇数，那么分成$n/2+(n/2+1)$。这样分下来，一定会分到2和3，也就是很小的奇数和偶数。

为什么不分到1呢？上面已经很好的用一个词说明了——浪费。减了一个1，结果一点变化也没有
 
再来说，2和3，优先分哪个？

因为$2+2+2=3+3$，而此时$2*2*2<3*3$，所以应该多选3。

所以，就可以针对$n$除以3的余数进行分类讨论。特别地，如果余数为1，应该少分一个3，转化成$2*2$。

最后，如果你不会高乘高，请~~练习Python~~[右转这道题](https://www.luogu.org/problemnew/show/P1303)
# 代码
我的模板写真的Very Ugly，而且太蒟了，还不会FFT，如果您觉得不好看，敬请谅解
```cpp
#include<map>
#include<set>
#include<list>
#include<queue>
#include<deque>
#include<stack>
#include<ctime>
#include<cmath>
#include<vector>
#include<bitset>
#include<cstdio>
#include<cctype>
#include<string>
#include<cstdlib>
#include<cstring>
#include<climits>
#include<iomanip>
#include<iostream>
#include<algorithm>
using namespace std;
#define reg register
inline bool OpenFile() {
    freopen("divide.in","r",stdin);
    freopen("divide.out","w",stdout);
    return 1;
}
//bool _Open=OpenFile();
template <typename T>
inline T read() {
    T a=0; char c=getchar(),f=1;
    while(c<'0'||c>'9') {
        if(c=='-') f=-f;
        if(c==-1) return c;
        c=getchar();
    }
    while(c>='0'&&c<='9') a=(a<<1)+(a<<3)+(c^48),c=getchar();
    return a*f;
}
template <class T>
inline int write(T x) {
    if(x<0) x=(~x)+1, putchar('-');
    if(x/10) write(x/10);
    return putchar(x%10|48);
}
template <class T>
inline int write(T x,char c) {
    return write(x)&&putchar(c);
}
template <class T>
inline T Max(T a,T b) { return a>b?a:b; }
template <class T>
inline T Min(T a,T b) { return a<b?a:b; }
template <class T>
inline T Abs(T a) { return a<0?-a:a; }
struct bigint{
    int a[10001];
    inline bigint& operator = (const char *s) {
        memset(a,0,sizeof a);
        int len=strlen(s);
        a[0]=len;
        for(reg int i=0,j;(j=len-i)&&i<len;i++)
            a[j]=s[i]^48;
        return *this;
    }
    inline bigint& operator = (const int &a) {
        char s[5001];
        sprintf(s,"%d",a);
        return *this=s;
    }
    inline bigint() {}
    inline bigint(const char *s) { *this=s; }
    inline bigint(const int &a) { *this=a; }
    inline void input() {
        char s[5001];
        scanf("%s",s); *this=s;
    }
    inline void output() {
        for(reg int i=a[0];i>=1;i--) write(a[i]);
    }
    inline bigint operator * (const bigint & b) {
        bigint c; c=0;
        c.a[0]=a[0]+b.a[0];
        for(reg int i=1;i<=a[0];i++)
            for(reg int j=1;j<=b.a[0];j++) {
                c.a[i+j-1]+=a[i]*b.a[j];
                c.a[i+j]+=c.a[i+j-1]/10;
                c.a[i+j-1]%=10;
            }
        while(!c.a[c.a[0]]) c.a[0]--;
        if(!c.a[0]) c.a[0]=1;
        return c;
    }
}ans;
inline bigint piow(bigint a,int b) {//反正只是2和3相乘起来，3的幂直接快速幂解决
    bigint ans=1;
    while(b) {
        if(b&1) ans=ans*a;
        a=a*a;
        b>>=1;
    }
    return ans;
}
int main() {
    int n=read<int>();
    int t=n/3,t1=n%3;
    if(t1==0) ans=piow(3,t);
    else if(t1==1) ans=piow(3,t-1)*4;
    else ans=piow(3,t)*2;
    write(ans.a[0],'\n');
    for(reg int i=ans.a[0],j=1;i>=1&&j<=100;i--,j++)//输出前一百位
        write(ans.a[i]);
}
```

---

## 作者：Great_Influence (赞：2)

结论题。

首先，答案一定是$3^k$或者$2*3^k$或者$4*3^k$（取决于余数），原因是3最靠近e，至于为什么，写个函数推一推极大值就可以了。


然后就是位数了。计算方法就是取对数，具体来说：



$digits=Ln(ans)=\frac{log_2ans}{log_2 10}=\frac{(0/1/2)+klog_2 3}{log_2 10}$


然后第二问显然是高精。为了偷懒就用python3了。


代码:

```py
from math import log
x=int(input())
a=x%3;x//=3
if(a==1):
    x=x-1
    a=a+1
else:
    if(a==2):
        a=1
d=pow(2,a)*pow(3,x)

x=int(log(d)/log(10))+1
print(x)
if(x<=100):
    print(d)
else:
    d//=pow(10,x-100)
    print(int(d))
```

---

## 作者：xy_xw_for_2024 (赞：1)

可以推出3^n大于等于n^3，然后写个高精乘就出来了

原理请见：[3^n≥n^3](https://blog.csdn.net/qq_43890190/article/details/86145567)

其实也可以用dp做，但状态转移方程还没想出来

以下是代码：
```
#include<cstdio>
inline void read(int &x) {
    x=0;
    int f=1;
    char s=getchar();
    while(s<'0'||s>'9') {
        if(s=='-')
            f=-1;
        s=getchar();
    }
    while(s>='0'&&s<='9') {
        x=x*10+s-48;
        s=getchar();
    }
    x*=f;
}
inline void pr(int x) {
    if(x<0) {
        putchar('-');
        x=-x;
    }
    if(x>9)
        pr(x/10);
    putchar(x%10+48);
}//快读快输不解释
int i,n,j,k,x,cnt=1,a[5005]={1},o;//cnt表示位数
inline void cheng(int x) {//高精乘
    for(i=cnt-1;i>=0;i--) {//从高位往低位乘
        a[i]*=x;
        if(i==cnt-1&&a[i]>10)//最高位的进位操作
            cnt++;
        a[i+1]+=a[i]/10;//处理进位
        a[i]=a[i]%10;
    }
}
int main() {
    read(n);
    while(n>5) {//3^n>n^3，尽量乘3
        cheng(3);
        n-=3;
    }
    if(n==3)//剩三乘三
        cheng(3);
    else if(n==4)//剩四乘四
        cheng(4);
    else if(n==5)//剩五乘六，2*3=6
        cheng(6);
    for(i=0;i<cnt;i++) {//从低位到高位处理一遍进位，一定要从低位到高位
        if(i==cnt-1&&a[i]>=10)//最高位
            cnt++;
        a[i+1]+=a[i]/10;
        a[i]=a[i]%10;
    }
    pr(cnt),putchar('\n');
    if(cnt>=100)//前100位
        for(i=cnt-1,o=0;o<100;i--,o++)
            pr(a[i]);
    else
        for(i=cnt-1;i>=0;i--)
            pr(a[i]);
}
```
  [我的博客链接](https://blog.csdn.net/qq_43890190/article/details/86144757 )

---

## 作者：RainFestival (赞：1)

数学，贪心，高精

用多3少2无1策略

为什么呢？？？

假设n为要划分的数

先说无1 如果n=(n-1)+1 不如n=n

因为1×(n-1)=n-1<n

再说多3

如果n=6

多2 6=2+2+2 2×2×2=8

多3 6=3+3 3×3=9

9>8

那为什么不用多4甚至多更大的数的策略呢？

如果n=12

多3 12=3+3+3+3 3×3×3×3=81

多4 12=4+4+4 4×4×4=64

多6 12=6+6 6×6=36

多大于4的数，它们甚至比多2还差

多2 12=2+2+2+2+2+2 2×2×2×2×2×2=64

64>36

先分成尽量多的3

如果余数0 刚刚好直接乘就行了

如果余数1 少一个3，多两个2（3×1<2×2）

如果余数2 就用2乘

不存在余数>=3的情况（余数小于除数3）

再高精乘就行了（没谁不会高精，而且还是高精乘单精还来做蓝题吧，不然回到橙题去吧，或者赶紧百度一下）

下面是代码，有点长，~~因为蒟蒻水平不行~~：

```cpp
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<cstdio>
using namespace std;
int a[10005];
int main()
{
    int n,p=0,l=0;
    cin>>n;
    if (n==1)
     {
     	cout<<1<<endl;
     	cout<<1<<endl;
     	return 0;
     }
    int b=0;
    for (int i=0;i<=10005;i++)
      a[i]=0;
    do
    {
        if (n==4)
          {
          	b=2;
          	break;
          }
        if (n==2)
          {
            b=1;
            break;	
          }
        if (n>4||n==3)
          {
          	p++;
          	n=n-3;
          }
    }while (n>0);
    //cout<<b<<' '<<p<<endl;
    if (b==1)
      {
      	a[1]=2;
      	l=1;
      }
    if (b==0)
      {
      	a[1]=1;
      	l=1;
      }
    if (b==2)
      {
      	a[1]=4;
      	l=1;
      }
    //cout<<l<<endl;
    for (int i=1;i<=p;i++)
      {
        for (int j=1;j<=l;j++)
      	  a[j]=a[j]*3;
      	for (int j=1;j<=l;j++)
      	  {
      	  	a[j+1]=a[j]/10+a[j+1];
      	  	a[j]=a[j]%10;
          }
        if (a[l+1]!=0) l++;	
      }
    cout<<l<<endl;
    if (l<=100)
    {
        for (int i=l;i>=1;i--)
          cout<<a[i];
    }
    else
    {
        for(int i=l;i>=l-99;i--)
          cout<<a[i];
    }
    cout<<endl;
    return 0;
}
```
谢谢巨佬们的欣赏！！！











---


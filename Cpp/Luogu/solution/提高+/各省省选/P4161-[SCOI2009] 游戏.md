# [SCOI2009] 游戏

## 题目描述

windy 学会了一种游戏。

对于 $1$ 到 $N$ 这 $N$ 个数字，都有唯一且不同的 $1$ 到 $N$ 的数字与之对应。

最开始 windy 把数字按顺序 $1,2,3,\cdots,N$ 写一排在纸上。

然后再在这一排下面写上它们对应的数字。

然后又在新的一排下面写上它们对应的数字。

如此反复，直到序列再次变为 $1,2,3,\cdots,N$。

如：$1\ 2\ 3\ 4\ 5\ 6$

对应的关系为：$1\to 2$，$2\to 3$，$3\to 1$，$4\to 5$，$5\to 4$，$6\to 6$。

windy 的操作如下：

`1 2 3 4 5 6`

`2 3 1 5 4 6`

`3 1 2 4 5 6`

`1 2 3 5 4 6`

`2 3 1 4 5 6`

`3 1 2 5 4 6`

`1 2 3 4 5 6`

这时，我们就有若干排 $1$ 到 $N$ 的排列，上例中有 $7$ 排。

现在 windy 想知道，对于所有可能的对应关系，有多少种可能的排数。

## 说明/提示

$30\%$ 的数据，满足 $1 \le n\le 10$。

$100\%$ 的数据，满足 $1 \le n\le 1000$。

## 样例 #1

### 输入

```
3```

### 输出

```
3```

## 样例 #2

### 输入

```
10```

### 输出

```
16```

# 题解

## 作者：灵乌路空 (赞：46)

先无良宣传一下博客 $wwwwww$    
[文章列表 - 地灵殿 - 洛谷博客](https://www.luogu.org/blog/koishikoishi/)

---

## 知识点: 问题转化 , 背包DP   

- ### 原题面:
	[P4161 [SCOI2009]游戏](https://www.luogu.org/problem/P4161)
  ```
  对于1到N这N个数字，都有唯一且不同的1到N的数字与之对应。  
  最开始 把数字按顺序1，2，3，……，N写一排在纸上。  
  然后再在这一排下面写上它们对应的数字。   
  然后又在新的一排下面写上它们对应的数字。  
  如此反复，直到序列再次变为1，2，3，……，N。  

  对于所有可能的对应关系，有多少种可能的排数。  
  ```

  原题面非常神仙不可做,   
  考虑对题目进行转化. 

---

- ### 一次转化 :  
	从图的角度 , 对题面进行转化:     
	- 有 $n$ 个点和 $n$ 条有向边        
	  点从$1 \sim n$ 进行编号    
      每个点只有一条入边和一条出边 , (允许自环),          
	  每个点按照出边的方向进行转移.        
      
      边可以任意连接,        
      不同的连接方式 , 回到原状态的步数不等  
      求回到原状态需要的 不同的步数 的数量 .      

	再次分析:     
	- 即在图中构建 环        
	  使每个点都位于 一个环 中       
	  
    - 设 $i$ 点所在环的环长为 $circle\_length[i]$   
      最后回到原状态的步数   
	  显然,即 : $\operatorname{lcm}(circle\_length[i]) \ \ (i\in [1,n])$ ;   
      
    - 现在 原题面要求得的 "排数" ,    
      即 转化后要求的 不同的步数 的数量,     
	  即 不同的 环长的 $\operatorname{lcm}$ 数 
      
---

- ### 二次转化 :     
	从数学角度进行思考:  
	
	- 因为只有 $n$ 条边,   
      显然有 , $\sum\limits_{i=1}^{n}(circle\_length[i]) = n$  
      即: 所有环长之和 $=n$ (包括 环长为1 的自环)     
      
    - 则问题可进一步转化:    
	  构造 若干 和为 $n$ 的数    
	  使其不同的 $\operatorname{lcm}$ 数尽可能地多      

	考虑怎样才能使 $\operatorname{lcm}$ 数尽可能多:    
	- 如果 每次构造时,    
	  都使这些数全都 互质    
	  那么他们的 $\operatorname{lcm}$ 每次都是不同的.    

	怎样使这些数全部互质 ?  
	- 显然, 可以将他们构造成 不同质数的幂    
      即: $\large p^k$ 的形式 $\ (k\in N \ \text{且有}\ p^k\le n) $  
      ($N$ 为自然数集)

---

- ### 三次转化:
	由于要使构造的数 和为 $n$  
	则可以选择的质数 $p \in [2,n]$ ,  
	且有 $(k\in N\ \text{且有}\ p^k\le n)$   

	于是问题继续转化:   
	- 对于 $[2,n]$ 中的质数,  
	  每个质数可选择其任意次幂 (包括$0$次幂) ,   
	  并选择任意多个   
	  求其总和为 $n$ 的方案数  

	考虑对 $0$ 次幂进行处理 :
	- 对于任何一种总和 $<n$ 的情况  
	  在添加若干 $1$ 后 , 都会变成 $n$  

	- 所以考虑 忽略掉所有的 $1$      
	  将 求总和为 $n$ 的方案数变为:    
	  求 $\sum\limits_{i=1}^{n} \text{(总和为}i\text{的方案数)}$

---

- ### 最终转化结果:
	对于 $[2,n]$ 中的质数,  
	每个质数可选择其任意非 $0$ 次幂 ,   
	并选择任意多个   
	求 $\sum\limits_{i=1}^{n} \text{(总和为}i\text{的方案数)}$

	变成了一个完全背包问题.  
	也就是说,只要你会简单的完全背包  
	就可以做出这么 ~~Naive~~ 神仙的题   

---

附代码:
```cpp
#include<cstdio>
#include<ctype.h>
const int MARX = 1010;
//=============================================================
int n,num , prime[MARX];
bool vis[MARX];
long long ans,f[MARX]={1}; 
//=============================================================
inline int read() 
{
    int s=1, w=0; char ch=getchar();
    for(; !isdigit(ch);ch=getchar()) if(ch=='-') s =-1;
    for(; isdigit(ch);ch=getchar()) w = w*10+ch-'0';
    return s*w;
}
void get_prime()//埃氏筛筛出<=n的素数
{
	for(int i=2;i<=n;i++)
	{
	  if(!vis[i]) prime[++num]=i;
	  for(int j=1;i*j<=n;j++) vis[i*j]=1;
	} 
}
void dp()//完全背包 
{
	for(int i=1;i<=num;i++)//将每个质数拿出,作为物品 
	  for(int k=n;k>=prime[i];k--)//枚举背包容量 
	    for(int mul=prime[i];mul<=k;mul*=prime[i])//枚举 
	      f[k]+=f[k-mul];
}
//=============================================================
signed main()
{
	n=read();
	get_prime();
	dp();
	for(int i=1;i<=n;i++) ans+=f[i];//获得各容量的方案数 
	printf("%lld",ans+1);//答案 = 总方案数 + 容量为0的方案 
}
```
---



---

## 作者：4526_ (赞：46)

[题目链接](https://www.luogu.org/problemnew/show/P4161)

这题对分析和综合运用能力要求比较高，不愧是一道紫题

#### 主要思想：DP，数论(?)

大致思路：

1、把原序列按照转化关系分组，由题面可以发现(1,2,3)在三行之后回到原状态，而(4,5)需要四行，(6)需要一行，得到小结论：**由n个数构成的相互转化关系，其对应序列需要n行回到原状态**

2、如何确定一个数经过转化后能够回到原数？注意题目原文有一句：**对于1到N这N个数字，都有唯一且不同的1到N的数字与之对应**，也就是说，如果构建一张图，以数字为点，转化关系为边，共有n个点n条边，且每个点入度和出度均为1，即每个点只与另外两个点相连，又得到小结论：**这是一张由环（或单独的点）构成的图**，那么一个数必定能转化回原数

3、不难看出，由两个含有m1,m2个数字的可转化序列（2中的环）所组成的序列，**回到原状态需要LCM（m1,m2）（最小公倍数）行**，而数字在序列中的位置关系不影响答案，如{(1->3,3->5,5->1),(2->4,4->2)}和{(1->2,2->3,3->1),(4->5,5->4)}是等价的

4、现在问题可抽象为：**共有n个元素，将它分为m个集合，求每个集合元素个数的LCM可能出现的情况**

5、对于每个LCM，可将它分解为质因数的乘积，L=(p1^k1)* (p2^k2)* ······* (pi^ki)，而它的每个质因子都来自“集合中的元素个数”，要用有限的元素个数得到尽可能多的LCM，就要使“集合中的元素个数”互质，这样LCM即为它们的乘积，不需要除以GCD导致损失，因此**这个L能被凑出，当且仅当p1^k1+p2^k2+······+pi^ki<=n**，注意可以将一个数单独分组，所以和可以小于n

6、用素数筛预处理出不大于n的素数

7、用f[i][j]表示前i个质数总和为j的情况数，得到转移方程**f [i] [j] = Σ f [i-1] [j-pi^k] (k>=0 && j-pi^k>=0)**

8、因为没有用第i个质数也是一种情况，所以**f [i] [j] 一定包含f [k] [j] (0<=k<=i)的所有情况**，可以把数组压缩到一维，即f [j] 表示总和为j的情况数

9、由于每一个i对应的f [j] 都由i-1对应的f [k] (k<=j)推得，**循环j时需要从后向前**

10、初始化f [0]=1

AC代码：

```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;

int n,k=1,tmp;
int pri[200]={0,2};
long long  ans[1010];

int main(){
	scanf("%d",&n);
	if(n==1){//特判一下
		printf("1");
		return 0;
	}
	for(int i=3;i<=n;i+=2){//预处理素数,数据范围较小,就直接暴力了
		pri[++k]=i;
		for(int j=2;j<k;++j){
			if(i%pri[j]==0){
				k--;
				break;
			}
		}
	}
	ans[0]=1;//初始化
	//DP
	for(int i=1;i<=k;++i){//枚举用了i个质因子
		for(int j=n;j>=pri[i];--j){//枚举用完j个数字
			tmp=pri[i];
			while(tmp<=j){
				ans[j]+=ans[j-tmp];
				tmp*=pri[i];
			}
		}
	}
	ans[0]=0;//节约空间233
	for(int i=1;i<=n;++i) ans[0]+=ans[i];//统计答案,即用完n个数可能出现的情况总数
	printf("%lld",ans[0]+1);//最后加上第一行
	return 0;
}

```

欢迎来[我的blog](https://www.luogu.org/blog/4526-Au/#)看看

---

## 作者：时光 (赞：23)

~~入门，这难度有毒~~

#####  数学分析：

1 2 3 4 5 6

2 3 1 5 4 6

3 1 2 4 5 6

1 2 3 5 4 6

2 3 1 4 5 6

3 1 2 5 4 6

1 2 3 4 5 6

把操作分开，发现这是个循环 （1 2 3）（4 5）（6）并且长度总和为n

然后抛开这个问题，我们来讨论一下循环：

显然 一个长度为m的循环 经过k\*m次操作又会回来

-> 排数为循环节长度的LCM

所以问题转换成了求把n分成若干个和为n的数，这些数的LCM的种数

因为1不影响LCM，所以和可以不为n（剩下的用1填满）

因为若干个数的LCM是这些数中出现过的质因数中最高幂的乘积，质数的幂彼此不同，所以这个问题最后转化成了背包问题...

### CODE

```cpp
#include<cstdio>
#include<cstring>
#include<string>
#include<cmath>
#include<algorithm>
#include<iostream>
#include<vector>
#include<queue>
#define rep(x,a,b) for (int x=int(a);x<=(int)(b);x++)
#define drp(x,a,b) for (int x=int(a);x>=(int)(b);x--)
#define rep_(x,a,b) for (int x=int(a);x<=(int)(b);++x)
#define drp_(x,a,b) for (int x=int(a);x>=(int)(b);--x)
#define cross(x,a) for (int x=hd[a];~x;x=nx[x])
#define ll long long
using namespace std;
int n,tot;
ll p[200],f[2000],ans;
int main()
{
   scanf("%d",&n);
   rep(i,2,1000)
   {
       bool g=true;
         rep(j,2,trunc(sqrt(i)))
         {
             if (i%j==0) 
             {
                 g=false;
                 break;
             }
         }
         if (g) tot++,p[tot]=i;
   }//筛素数，我比较懒，文末我会放个欧拉筛
   f[0]=1;
   rep_(i,1,tot)
  // if (p[i]<=n)
     drp_(j,n,p[i])
       for(int k=p[i];k<=j;k*=p[i]) f[j]+=f[j-k];
   rep_(i,0,n) ans+=f[i];
   printf("%lld",ans);
   return 0;
}
```

### 附（欧拉筛）:

```cpp
    v[1]=1;
    tot=0;
    rep(i,2,n)
    {
        if (! v[i])  prime[++tot]=i;
        for (int j=1;j<=tot&&prime[j]*i<=n;j++)
        {
            v[i*prime[j]]=1;
            if (i%prime[j]==0) break;
        }
    }

```

---

## 作者：由比滨丶雪乃 (赞：8)

# 毒瘤


好吧其实是蒟蒻一开始做不出来（~~自闭一晚上和同班巨佬才讨论出来的题，但真的想了好久QAQ~~）

____


## 题目大意

**将n个数按一定排列，再置换，求所有可能不同排列的个数**


**1、首先，单理解题意，这道题似乎很难从正面下手，那我们换一个角度来思考问题，每次将数列置换，最后会变回原来的数列，这样的话，我们很容易想到一个环。那么问题中将数列的置换就变成一个环了。**
#### 2、那么，进一步讲问题转换，原题目中所要求的排列数，即为求所有可能大小环的 最小公倍数 的个数（这个可以自己举例画一下图，想一想）

#### 3、继续问题转化，原题目就变成，将n个数分成m个集合，求这些集合个数所有可能的  最小公倍数  的个数

#### 4、由于最小公倍数可以拆成若干个质因子的乘积，显然，当每个数可以用p的k次方表示是最优情况，所以最终所要求的为  （因为形如10，可以分成4和6，也可以分成，3,4,1,1,1但两者的最小公倍数是相同的，情况归为一种）
#### 5、最终问题的转化为：求和小于等于n的多个数所有可能  最小公倍数  的个数（因为有些数可以自成一个环\集合，不影响结果）
#### 6、那么问题渐渐明了，接下来设计状态，我们设f[i][j]表示前i个质数，总和为j的方案数（形如背包，p的k次方为代价）
#### 7、状态设计出来了，方程也随之而出
### 即
## f [i] [j] = Σ f [i-1] [j-pi^k] (k>=0 && j-pi^k>=0)


#### 8、最后就是时间复杂度和空间复杂度，都为O(N^2),完全符合题目的小范围qwq （其实一开始想打表的说。。。。。）


##### 附一下样例解释

##### <=10的素数都有  2,3,5,7；
#####  所以可选的数为
| 2 | 3 |5  | 7 |
| :----------- | :----------- | :----------- | :----------- |
| 4 | 9 |  |  |
| 8 |  |  |  |
##### 选0个数（不选，即为原数列） 方案数为1
##### 选1个数  方案数为7
##### 选2个数  所有方案为：（2,3）（2,5）（2,7）（4,3）（4,5）（3,5）（3,7）方案数为7
##### 选3个数  方案为（2,3,5） 方案数为1
##### 所以  1+7+7+1=16


##### 上代码（~~我知道你们只看这个qwq~~）




```cpp
#include <iostream>
#include <cstdio>
#include <iomanip>
#include <algorithm>
#include <cstring>
#include <cstdlib>
#include <cmath>
#include <queue>
#include <map>
#define ll long long
#define maxn 10000010

using namespace std;

bool prime[maxn];
int sum[maxn];
int x;
ll f[1005][10005];
int cnt;
int k;

inline void primes(int n)//素数筛求出前比n小的所有素数
{
	memset(prime,false,sizeof(prime));
    prime[1]=true;
    for(int i=2;i<=n;i++)
    {
    	if(!prime[i])
    	{
    		sum[++cnt]=i;
		}
		for(int j=1;j<=cnt&&i*sum[j]<=n;j++)
		{
			prime[sum[j]*i]=true;
			if(i%sum[j]==0) break;
		}
	}
 } 
 
int main()
{
	scanf("%d",&x);
	primes(x);
	f[0][0]=1;//初始化
	for(int i=1;i<=cnt;i++)//枚举所有小于x的素数
	{
		for(int j=0;j<=x;j++)//dp
		{
			f[i][j]+=f[i-1][j];
			k=sum[i];
			while(j>=k)
			{
				f[i][j]+=f[i-1][j-k];//转移方程
				k*=sum[i];
			}
		}
	}
		ll ans=0;//注意是longlong   不然会WA5个点
		for(int i=1;i<=x;i++)   ans+=f[cnt][i];
		printf("%lld",ans+1);//由于不选的代价为0，所以要加一，当然也可以从i=0开始循环
		return 0;
	
}
```



---

## 作者：kyel (赞：4)

## 标签：质数，DP ~~（没想到吧）~~
这道题看上去非常吓人，题目中的**置换**以及**统计总数**看上去非常的**Burnside**。

然而仔细的分析一下，题目中要求“再次出现1,2,3...N的排列”，或者也就是问要进行多少次“置换操作”得到原排列，而我们知道任何置换都是可以写成**循环乘积**的形式的。

也就是比如对于下面的置换
```cpp
1->3
2->4
3->1
4->5
5->2
```
我们可以把它化简为：
```cpp
(1 3)(2 4 5)
其含义是
(1->3,3->1)(2->4,4->5,5->2)
```
而对于一个给定置换，问它要多少次才能再次得到原排列，显然只有这个置换分解出的的**各个循环的长度**是我们关心的。比如对于上例中的置换，我们只需要直到它分解出两个循环，长度为2与3即可断定其只需6次即可得到原排列。**也就是所有循环的长度的最小公倍数次**。而且显然，同一长度的循环多次出现是没有意义的。

但是这好像还是没有什么用，因为如果我们枚举所有长度然后求最小公倍数的话，那不就是暴力吗？

这个时候考虑**唯一分解定理**，我们把循环的长度分解为质数之积，那么所有长度的**最小公倍数就是每个质数的最大幂之积**。

听上去很拗口。试试下面的例子：
```cpp
12960 = 2^5 * 3^4 * 5^1
36450 = 2^1 * 3^6 * 5^2
两者LCM为2^5 * 3^6 * 5^2
```
那么，我们要暴力就干脆枚举每个质数的指数，看看最后有多少不同的结果。

当然，其实到了这一步**已经不需要暴力了**：令dp[n][m]表示从第m个质数往后，值至多为n的方案数，dp就好了。

```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>

#include <algorithm>

int prime[1123], end;
void init() {
	for (int i(2); i <= 1000; ++i) {
		bool fail(false);
		for (int j(2); j < i; ++j) if (i % j == 0) fail = true;
		if (!fail) prime[end++] = i;
	}
}
int n;
bool vis[1123][212];
long long dp[1123][212];
long long dfs(int n, int now) {
	if (n < 0) {
		n = 0;
	}
	if (vis[n][now]) return dp[n][now];
	if (n == 0 || prime[now] > n || now == end) return 1;
	vis[n][now] = true;
	dp[n][now] = dfs(n, now + 1);
	long long mul(1);
	for (int i(1); mul * prime[now] <= n; ++i) {
		mul *= prime[now];
		dp[n][now] += dfs(n - mul, now + 1);
	} return dp[n][now];
}
int main() {
	init();
	scanf("%d", &n);
	printf("%lld\n", dfs(n, 0));
	return 0;
}
```

---

## 作者：新手村村长 (赞：3)

首先可以发现一个规律

每个数会在经历一个循环之后变回这个数

同时一组对应关系的行数就是每个数的循环长度的最小公倍数

一个数字可以与一个循环中的其他数字构成一个环形结构

一个环中的每个数字都会经历相同的变化次数

且这个变化次数等于这个循环中数字的个数

所以每种方案把N拆成若干个数，总行数就是所有数的最小公倍数

一组拆分方式的最小公倍数可以唯一分解成若干质数之积

所以先处理出一到一千的所有的质数，再用这些质数来组合就可以表示所有的方案

这些表示就可以DP来求了

f[i]表示拆分成的数和为i的方案数

因为总和不够的可以用循环1来凑

所以要把f[0]到f[n]全部加起来求和

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,ans,cnt,s[101],v[1001],f[1001];
long long power(long long x,long long m)
{
	long long ret=1;
	while(m)
	{
		if(m&1)
			ret*=x;
		x*=x;
		m>>=1;
	}
	return ret;
}
int main()
{
	cin>>n;
	for(int i=2;i<=1000;i++)
	{
		if(!v[i])
		{
			s[++cnt]=i;
			for(int j=i*2;j<=1000;j+=i)
				v[j]=1;
		}
	}
	f[0]=1;
	for(int i=1;i<=cnt;i++)
	for(int k=n;k>=1;k--)
	for(int j=1;power(s[i],j)<=k;j++)
		f[k]+=f[k-power(s[i],j)];
	for(int i=0;i<=n;i++)
		ans+=f[i];
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：zzw4257 (赞：3)

考虑$1$是可以放随意多个，因此转化问题为和小于等于$n$数中不同$LCM$数

但考虑$LCM$其实是在求什么，我们是在把每个质因子次幂取$\max$

设$\displaystyle{lcm=\prod_{i=1}^k p_i^{k_i}}$

对于${a_i}$,有情况$\displaystyle{a_1=\prod_{i=1}^k p_i^{c_{1,i}},~~a_2=\prod_{i=1}^k p_i^{c_{2,i}}~\cdots~ a_d=\prod_{i=1}^k p_i^{c_{n,i}}}$

其中$\displaystyle{k_i=\max_{j=1}^{d}\{c_{j,i}\}}$

易证明$\displaystyle{\sum_{i=1}^d}a_i
~\ge ~\sum_{i=1}^k p_i^{k_i} $

考虑到贡献$lcm$这个答案的可以是$\{a_i\}$也可以是和更小的$\{a'_i=p_i^{k_i}\}$,因此对不同的$n$贡献个数如果$\{a_i\}$可以，$\{a'_i=p_i^{k_i}\}$一定也可以

因此我们只用求为和小于等于$n$数中**只有一个质因数的**不同$LCM$数

因此就可以背包了

用$f_{i,j}$表示和小于等于$i$数中只有第$1\rightarrow j$个质数不同$LCM$数

则$f_{i,j}=\displaystyle{\sum_{k=1}[pri_j^{~k}\le i]f_{i-pri_j^{~k},j-1}}$

滚动数组加反向枚举一下就可以了

```cpp
#include<bits/stdc++.h>
#define re register
#define N 1005
using namespace std;
typedef long long ll;
int pri[N],n;
char vis[N];
ll dp[N];
inline void Solve(void){
	re int i,j,tmp;
	dp[0]=1;
	for(i=1;i<=*pri;++i){
		for(j=n;j>=pri[i];--j){
			tmp=pri[i];
			while(tmp<=j){dp[j]+=dp[j-tmp];tmp*=pri[i];} 
		}
	}
	for(i=1;i<=n;++i)dp[i]+=dp[i-1];
	printf("%lld\n",dp[n]);
}
inline void Sieve(void){
	re int i,j;
	for(i=2;i<=1000;++i){
		if(!vis[i])pri[++*pri]=i;
		for(j=1;j<=*pri;++j){
			if(i*pri[j]>1000)break;
			vis[i*pri[j]]=1;
			if(!(i%pri[j]))break;
		}
	} 
}
int main(void){
	//freopen("game.in","r",stdin);
	//freopen("game.out","w",stdout);
	Sieve();scanf("%d",&n);Solve();
	return 0;
}
```

---

## 作者：yyxmy (赞：0)

对于一个排列Ａ，他的需要的次数  
$x$ = $lcm(a_1, a_2, a_3, a_4, ..., a_m)$  
其中m为这个排列置换的个数，$a_1$,$a_2$,$a_3$...为每个置换的大小，
至于为什么是这样，　应该比较容易理解吧。　  
举个栗子:  
$n=5$ $A$ = {$3,1,2,5,4$}  
那么它的两个置换分别为{$3,1,2$}, {$5,4$}；
对于第一个置换每三次会还原一次，　对于第二个置换每两次会还原一次，　那么这个排列对应的次数就应该是lcm(2,3) = 6;  
所以现在题目可以转化成，  
有多少不同的$sum$, 选若干个数，使它们的$lcm = sum$,  且和$<n$；　　

那么对于一个$sum$，我们只需要找到使lcm等于它的最小的和，　如果这个值$\leq n$, $sum$ 就是$OK$的。　这个最小的和是比较好求的
对$sum$质因数分解：　sum = $p_1^{a_1} * p_2^{a_2}...*p_m^{a_m}$，　最小和即为 $p_1^{a_1}+p_2^{a_2}+...+p_m^{a_m}$, 这个应该是比较显然的。
那么我们对每一个质数分别考虑贡献就行了，　具体的dp细节可以参考代码，十分好写
```cpp
#include<bits/stdc++.h>
#define int long long
#define reg register
#define maxn 300001
using namespace std;
int n, mod, prime[maxn], not_prime[maxn], cnt, f[maxn],  g[maxn], ans;
signed main(){
   // freopen("exercise.in", "r", stdin);
   // freopen("exercise.out", "w", stdout);
    cin >> n;
    for(int i = 2; i <= n; i++){
        if(!not_prime[i]) prime[++cnt] = i;
        for(int j = 1; j <= cnt && prime[j] * i <= n; j++){
            not_prime[i * prime[j]] = 1;
            if(i % prime[j] == 0) break;
        }
    }
    f[0] = 1;
    for(int i = 1; i <= cnt; i++){
        for(int j = prime[i]; j <= n; j = j * prime[i])
            for(int k = j; k <= n; k++) g[k] += f[k - j];  
        for(int j = 0; j <= n; j++) f[j] += g[j], g[j] = 0;
    }
    for(int i = 0; i <= n; i++) ans += f[i];
    cout << ans << endl; return 0;
}
```



---

## 作者：huangwux (赞：0)

（没过pj组的）蒟蒻的第一篇题解

不多说，进入正题

### DP+数论（主要是质数） 

首先（个人感觉）这就是思维难度 省选 知识点提高 代码的dp题

 观察一下题面，要求不同的可能排列数有几种，~~（一开始蒙蔽好久以为是求不同的对应排列）~~
 
然后思考一下排数有什么含义，可以发现排数实际上就是多少次变化后可以变回原来的序列~~（这不是废话吗）~~

 然后变化次数又是什么？我们考虑一组替换什么情况下会变回原来的顺序
如果a—>b，那么b一定可以经过某几次变换再变成a，那么a——>b——>...最后回到a的过程

如果我们将一个数连一条边到它对应的数字上，那么可以替换的n个数就会组成一个n元环

那么成环后排数会变成什么？，很显然一个n元环变换n次后会还原。那全部还原的变换次数显然就是每个环中点的个数的lcm（最小公倍数）。而且需要注意的是，每个点可以自己组成一个1元环

而且这个一元环对lcm不会产生任何影响，所以题目等价于<=n的数拆分后可以形成多少种不同的lcm。根据唯一分解定理我们求这些数可能拆分的lcm时，将每个数拆成k个p^r幂的积显然是最优的

因为n个数的lcm实际上就是它们的质因数中取最高次幂再相乘，全部分解质因数才能保证我们组成的lcm尽可能的多，而如果分解出合数很显然会浪费掉可能的组合数

其实这样我们就将这个问题转化成了一个背包问题，背包容量从1~n，选数，累加起来就好了

我们可以用f[i][j]表示使用前i个质数，和为j的方案数，那么转移如下：

## **f[i][j]=Σk(f[i-1][j-pi^k])**

预处理一下前n个数中的质数~~（反正n小于等于1000随便暴力）

~~简单的埃氏筛好像就足够了~~ （~~总感觉我的埃氏筛哪里有锅~~）

剩下的好像也没有什么了？下面是代码

```cpp

#include<bits/stdc++.h>
using namespace std;
bool a[2004]; 
int p[2004],cnt,logo;
long long int dp[1010]={1};
int main(){
	a[1]=a[0]=1;// 求素数 
	int n;
	cin>>n;
	if(n==1) {//直接输出掉 
		cout<<1;
		return 0;
	}
	if(n==2) {//同上 
		cout<<2; 
		return 0;
	}
	for(int i=2;i<=n;i++)//个人感觉好像有锅？ 
	  if(!a[i])
	  for(int j=2*i;j<=n*2;j+=i)
	   a[j]=1;
	for(int i=1;i<=n;i++)
	 if(!a[i]) p[++cnt]=i;//奇葩素数表 
	for(int i=1;i<=cnt;i++) //枚举使用的素数个数 
		for(int j=n;j>=p[i];j--)   //使用第i个素数 
			for(int logo=p[i];logo<=j;logo*=p[i])// logo不能大于当前差的数 
				dp[j]+=dp[j-logo];
		
		long long int f=0;
		for(int i=0;i<=n;i++)
		f+=dp[i];
        cout<<f;
	    return 0;
} 
```

```


---

## 作者：Paranoid丶离殇 (赞：0)

### 题目描述

windy学会了一种游戏。

对于1到N这N个数字，都有唯一且不同的1到N的数字与之对应。

最开始windy把数字按顺序 1，2，3，…… ，N写一排在纸上。

然后再在这一排下面写上它们对应的数字。

然后又在新的一排下面写上它们对应的数字。

如此反复，直到序列再次变为 1，2，3，……，*N*
。

如： 1 2 3 4 5 6

对应的关系为

1->2 2->3 3->1 4->5 5->4 6->6

windy的操作如下

1 2 3 4 5 6

2 3 1 5 4 6

3 1 2 4 5 6

1 2 3 5 4 6

2 3 1 4 5 6

3 1 2 5 4 6

1 2 3 4 5 6

这时，我们就有若干排1到N的排列，上例中有7排。

现在windy想知道，对于所有可能的对应关系，有多少种可能的排数。

### 输入格式

一个整数，N。

### 输出格式

一个整数，可能的排数。

### 输入输出样例

**输入 #1**

```
3
```

**输出 #1**

```
3
```

**输入 #2**

```
10
```

**输出 #2**

```
16
```

### 说明/提示

30%的数据，满足 $1<=N<=10$。

100%的数据，满足 $1<=N<=1000$。

### 题解

通过 ~~手玩~~ 一番样例，将每个数向它下一轮所变换的数连一条边发现：

所连成的图一定为环，而这个环大小所代表的含义为：环上所有数进行变换所经过的排数。

因最小公倍数是所有形成这个最小公倍数的倍数，所以进一步推知排数是所有环大小的最小公倍数。

至此，问题可以转化为求 和为 n 的多个数 有多少种可能的最小公倍数，即为有多少种可能的排数。

线性筛质数。

设$f[i][j]$为第 $i$ 个质数， 前面最小公倍数为 $j$ 方案总数。

则$f[i][j]=\sum{f[i-1][j-p_{k_i}]}$

根据方程可将数组压成一维。

时间复杂度$O(n^2)$, 空间复杂度$O(n^2)$

### code:

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
typedef long long LL;
const int N = 1e3 + 5;
int read() {
    int x = 0, f = 1; char ch = getchar();
    while(! isdigit(ch)) f = (ch=='-')?-1:1, ch = getchar();
    while(isdigit(ch)) x = (x<<3)+(x<<1)+(ch^48), ch = getchar();
    return x * f;
}
int n, pri[N], cnt;
LL f[N], ans;
bool vis[N];
void Prime() {
    vis[0] = vis[1] = 1;
    for(int i = 2;i <= N;i ++) {
        if(vis[i] == 0) pri[++ cnt] = i;
        for(int j = 1;j <= cnt&&i * pri[j] <= N;j ++) {
            vis[i * pri[j]] = 1;
            if(i % pri[j] == 0) break;
        }
    }
}
int main() {
    Prime();
    if((n = read()) == 1) { printf("1\n"); return 0; }
    f[0] = 1;
    for(int pos = 1;pos <= cnt;pos ++) {
        for(int j = n;j >= pri[pos];j --) {
            int tmp = pri[pos];
            while(tmp <= j) f[j] += f[j - tmp]， tmp *= pri[pos];
        }
    }
    for(int i = 1;i <= n;i ++) ans += f[i];
    printf("%lld\n", ans + 1);
    return 0;
}
```

---


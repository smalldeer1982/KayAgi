# [SCOI2009] 最长距离

## 题目描述

windy 有一块矩形土地，被分为 $N\times M$ 块 $1\times 1$ 的小格子。 有的格子含有障碍物。 如果从格子 A 可以走到格子 B，那么两个格子的距离就为两个格子中心的欧几里德距离。 如果从格子 A 不可以走到格子 B，就没有距离。如果格子 X 和格子 Y 有公共边，并且 X 和 Y 均不含有障碍物，就可以从 X 走到 Y。 如果 windy 可以移走 $T$ 块障碍物，求所有格子间的最大距离。保证移走 $T$ 块障碍物以后，至少有一个格子不含有障碍物。


## 说明/提示

- $20\%$ 的数据，满足  $1 \le N,M \le 30 $，$ 0 \le T \le 0 $。
- $40\%$ 的数据，满足  $1 \le N,M \le 30 $，$ 0 \le T \le 2 $。
- $100\%$ 的数据，满足 $1 \le N,M \le 30 $，$ 0 \le T \le 30$。


## 样例 #1

### 输入

```
3 3 0
001
001
110```

### 输出

```
1.414214```

## 样例 #2

### 输入

```
4 3 0
001
001
011
000```

### 输出

```
3.605551```

## 样例 #3

### 输入

```
3 3 1
001
001
001```

### 输出

```
2.828427```

# 题解

## 作者：Nightsky_Stars (赞：17)

### 思路：
给你一张 $n \times m$ 的图，其中 $a_{ij} = 1$ 表示有障碍，否则没有障碍，其中可以消除 $t$ 个障碍，求所有格子的最大距离。

#### 暴力建图+最短路
建完图后，去看哪个 $d_i$ 小于 $t$，去算起点到的格子中心的距离，取个 $\max$ 就行了。
```
#include<bits/stdc++.h>
using namespace std;
int d[50][50],dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};
bool vis[50][50];
double ans=-1e9;
char a[50][50];
struct edge{
    int u,v,w;
};
vector<edge>e[50][50];
struct node{
    int sx,sy,val;
    bool operator<(const node &b) const{
        return val>b.val;
    }
};
priority_queue<node> q;
void dijkstra(int x,int y){
    memset(vis,0,sizeof(vis));
    memset(d,0x3f3f3f,sizeof(d));
    d[x][y]=0;
    q.push((node){x,y,0});
    while(q.empty()==0){
        int u=q.top().sx,v=q.top().sy;
        q.pop();
        if(vis[u][v]==1) continue;
        vis[u][v]=1;
        for(int i=0;i<e[u][v].size();i++){
            edge s=e[u][v][i];
            if(d[s.u][s.v]>d[u][v]+s.w){
                d[s.u][s.v]=d[u][v]+s.w;
                q.push((node){s.u,s.v,d[s.u][s.v]});
            }
        }
    }
    return ;
}
int main(){
	int n,m,t;
    cin>>n>>m>>t;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin>>a[i][j];
        }
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            for(int k=0;k<4;k++){
                int nx=i+dx[k],ny=j+dy[k];
                if(nx>=1&&nx<=n&&ny>=1&&ny<=m){//建图
                	int s;
                	if(a[nx][ny]=='1'){
                		s=1;
					}else s=0;
                    e[i][j].push_back((edge){nx,ny,s});
                }
            }
        }
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            dijkstra(i,j);
            int s;
            if(a[i][j]=='1'){
           		s=1;
			}else s=0;
            for(int k=1;k<=n;k++){
                for(int h=1;h<=m;h++){
                    if(k==i&&h==j) continue;
                    if(d[k][h]+s<=t) ans=max(ans,sqrt((k-i)*(k-i)+(h-j)*(h-j)));
                }
            }
        }
    }
    printf("%.6lf",ans);
    return 0;
}
```


---

## 作者：弱弱弱 (赞：13)

这道题本质是最短路。

~~题目不是说是最长距离吗？~~

看看样例就大概知道欧几里德距离指的是两点的直线距离，
不一定是步数越少，直线距离越短，怎么感觉和最短路更没关系了？

再回到题目，最先想到的就是用搜索把障碍一个个搬了，再找联通两点间的距离。

但想都不用想就知道会T一堆。

但我们换个思路，先看两点之间是否可以通过搬t个内的箱子联通，再求距离，此时就可以通过最短路判断两点间是否满足要求，经过障碍物的边边权为1，其余为0，最后判一下从一个点到其他点的最短路小于t的计算欧几里德距离，每个点都这样做一次，因为有过多不必要的运算，所以最短路只能用SPFA跑。

也可以用剪枝+记忆化dfs~~（因为太懒不想打SPFA）~~：

```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#include<math.h>
#include<cstdio>
using namespace std;
int n,m,t,a[35][35],dis[35][35],ans;
int tx[4]={-1,1,0,0},
    ty[4]={0,0,-1,1};
void dfs(int,int,int);
int main()
{
    cin>>n>>m>>t;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
        {
            char temp;//题面要读入的是字符串
            cin>>temp;//要特殊处理
            a[i][j]=temp-'0';
        }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
        {
            memset(dis,127,sizeof(dis));
            int temp=a[i][j]==1?1:0;//可以从障碍物出发
            dfs(i,j,temp);
            for(int ii=1;ii<=n;ii++)
                for(int jj=1;jj<=m;jj++)
                    if(dis[ii][jj]<=t)
                        ans=max(ans,(ii-i)*(ii-i)+(jj-j)*(jj-j));//先不开方，保证精度
        }
    printf("%.6f",sqrt(ans));
}
void dfs(int x,int y,int sum)
{
    if(sum>t)return;//剪枝，记忆化缺一不可
    if(sum>=dis[x][y])return;
    dis[x][y]=sum;
    for(int i=0;i<4;i++)
    {
        int nx=x+tx[i],ny=y+ty[i];
        if(nx<=n&&nx>=1&&ny<=m&&ny>=1)dfs(nx,ny,sum+a[nx][ny]);
    }
}

```

---

## 作者：LengChu (赞：6)

楼下已经说过用spfa怎么做了 但是没给代码 ~~这里我就直接放代码了~~

主要是有一些细节要注意

我是把矩阵上的每一个点标号 然后重建图跑spfa ~~当然各位大佬爱怎么搞怎么搞~~

对于每一个点 向周围的四个点连边 如果周围的点权值为1 边权就为1

然后对于每个点跑spfa 如果dist<=t就可以更新答案

注意如果起点就有障碍 dist要+1（start数组的意义所在）

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,t;
char s[40][40];
int ne[4][2]={{0,1},{1,0},{0,-1},{-1,0}};
double d[1010][1010],maxx;
int dist[1010];
int start[1010];
bool book[1010];
struct node
{
	int to,next,w;
}edge[1234567];
int head[1010],k;
void adde(int u,int v,int w) { edge[++k].to=v; edge[k].w=w; edge[k].next=head[u]; head[u]=k; }
int id(int x,int y) { return n*(x-1)+y; }//得到这个点的编号
void spfa(int s)
{
	queue<int> q;
	for(int i=1;i<=n*m;i++) dist[i]=99999999,book[i]=0;
	dist[s]=start[s]; book[s]=1; q.push(s);
	while(!q.empty())
	{
		int u=q.front(); q.pop(); book[u]=0;
		maxx=max(maxx,d[s][u]);
		for(int i=head[u];i;i=edge[i].next)
		{
			int v=edge[i].to;
			if(dist[v]>dist[u]+edge[i].w) 
			{
				dist[v]=dist[u]+edge[i].w;
				if(!book[v]&&dist[v]<=t) q.push(v),book[v]=1;
			}
		}
	}
}
int main()
{
	scanf("%d%d%d",&n,&m,&t);
	for(int i=1;i<=n;i++) scanf("%s",s[i]+1);
	for(int i=1;i<=n;i++)//预处理两点之间的欧几里得距离
		for(int j=1;j<=m;j++)
			for(int k=1;k<=n;k++)
				for(int l=1;l<=m;l++)
					d[id(i,j)][id(k,l)]=sqrt((i-k)*(i-k)+(j-l)*(j-l));	
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(s[i][j]=='1') start[id(i,j)]=1;
			for(int k=0;k<4;k++)
			{
				int tx=i+ne[k][0],ty=j+ne[k][1];
				if(tx<1||ty<1||tx>n||ty>m) continue;
				int w=s[tx][ty]-'0';
				adde(id(i,j),id(tx,ty),w);
			}
		}
	}
	for(int i=1;i<=n*m;i++) spfa(i);
	printf("%.6f",maxx);
	return 0;
}
```

---

## 作者：Cypher_404 (赞：5)

[题目传送门](https://www.luogu.com.cn/problem/P4162)

这是本蒟蒻的第一篇题解，请大家多多包涵。

学校集训的时候考到了，考场上还没做对。。。

下面开始正题：

先理解题意：

在一个 $N\times M$ 的矩阵中，挑选两个点，使得这两个点的距离最长，而且在两个点连通的路径上不能有大于 $T$ 个 $1$（包括端点）

我使用的是 BFS 的方法  

~~毕竟 $30^5$ 也不会炸~~

先上代码：
```cpp
#include<bits/stdc++.h>
#define MAXN 32
using namespace std;
template< typename T > inline void read(T &x)
{
	char c=getchar();x=0;int f=0;
	for(;!isdigit(c);c=getchar()) f|=(c=='-');
	for(;isdigit(c);c=getchar()) x=((x<<3)+(x<<1)+(c^48));
	x=f?-x:x;
}
int n,m,t,vis[MAXN][MAXN],dis[MAXN][MAXN],a[MAXN][MAXN];
double ans=0.0;
int dx[5]={0,1,0,-1,0};
int dy[5]={0,0,-1,0,1};
struct node
{
	int x,y;
};
queue<node>que;
void bfs(int x,int y)
{
	memset(dis,0x3f,sizeof(dis));
	memset(vis,0,sizeof(vis));
	dis[x][y]=a[x][y];
	que.push({x,y});
	while(!que.empty())
	{
		int x=que.front().x;
		int y=que.front().y;
		que.pop();
		if(vis[x][y])
		{
			continue;
		}
		vis[x][y]=1;
		for(int i=1;i<=4;i++)
		{
			int nx=x+dx[i];
			int ny=y+dy[i];
			if(nx<1||nx>n||ny<1||ny>m)
			{
				continue;
			}
			if(dis[nx][ny]>dis[x][y]+a[nx][ny])
			{
				dis[nx][ny]=dis[x][y]+a[nx][ny];
				vis[nx][ny]=0;
				que.push({nx,ny});
			}
		}
	}
}
double calc(int x,int y,int xx,int yy)
{
	int aa=abs(xx-x);
	aa*=aa;
	int bb=abs(yy-y);
	bb*=bb;
	return sqrt(aa+bb);
}
int main()
{
	freopen("dis.in","r",stdin);
	freopen("dis.out","w",stdout);
	read(m);
	read(n);
	read(t);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			char c;
			c=getchar();
			while(c!='0'&&c!='1')
			{
				c=getchar();
			}
			a[i][j]=c-48;
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			bfs(i,j);
			for(int k=1;k<=n;k++)
			{
				for(int l=1;l<=m;l++)
				{
					if(dis[k][l]>t)
					{
						continue;
					}
					double xxx=calc(i,j,k,l);
					if(xxx>ans)
					ans=xxx;
				}
			}
		}
	}
	printf("%.6lf",ans);
	return 0;
}
```
下面，我将详细地为您介绍每一个函数：

`read` 函数就是普通的快读。

`node` 是定义的结构体，方便 BFS，不知道 bfs 的同学建议先学习前置芝士

BFS 传入的参数是起始点的坐标，做法类似于最短路，即求一个点到另一个点路过的 $1$ 的数量的最小值

`calc` 即是计算两个点的距离（使用勾股定理）

主函数部分使用了 `getchar` 进行输入，可以一次获取一个字符，如果不是 $1$ 或者 $0$ 就继续获取字符。

中间的四层循环枚举了每一个起点与终点，如果合法就与最大值比较，否则不合法就舍去

最后保留 $6$ 位小数后输出。

如果发现我有哪些做的不好的地方，或者解释错误的地方，欢迎指正。

如果没发现的话就点个赞吧~

---

## 作者：hcywoi (赞：4)

## 题解
$\text{dis}_{i, j}$ 为到了 ${i, j}$ 这个点最少需要搬的障碍物。

因为如果要让答案越大，那么让所有的点搬的障碍物越少，到的点也就可以越多，答案就越大。

$\text{dis}_{i, j}$ 可以通过 spfa 来求。

求好了 $\text{dis}_{i, j}$，如果 $\text{dis}_{x, y} \leq T$，那么说明从 ${i, j}$ 开始到 ${x, y}$ 是一条合法的路径。我们就把答案更新 $\Leftrightarrow \text{ans} = \min\{\text{ans}, \sqrt{|x-i|^2+|y-i|^2}\}$。

因为 $n, m \leq 30$，所以 ${x, y}$ 可以通过暴力枚举出来。

## spfa
spfa 是 bellman-Ford 的优化。

所以我们先来看一下 bellman-Ford 的过程。
### bellman-Ford 的过程
- 扫描所有边 $(x, y, z)$，若 $\text{dis}_y > \text{dis}_x + z$，则更新 $\text{dis}_y$ $\Leftrightarrow$ $\text{dis}_y = \text{dis}_x + z$。
- 重复上述步骤，知道没有更新操作发生
- 时间复杂度 $\mathcal O(nm)$，其中 $n$ 为点数， $m$ 为边数。

spfa 就是 bellman-Ford 的队列优化
### spfa 的过程
- 建立一个队列，最初队列只有一个元素起点；
- 取出队头结点$x$，扫描$x$的所有出边 $(x, y, z)$，若  $\text{dis}_y > \text{dis}_x + z$，则使用 $\text{dis}_x + z$ 更新   $\text{dis}_y \Leftrightarrow \text{dis}_y = \text{dis}_x + z$。同时，若 $y$ 不在队列中，则把 $y$ 入队；
- 重复上述步骤，直到队列为空；
- 时间复杂度 最坏情况 $\mathcal O(nm)$，其中 $n$ 为点数，$m$ 为边数，一般时间复杂度 $\mathcal O(km)$，其中 $k$ 为常数，一般为 $2-3$，$m$为边数。

## 时间复杂度
- 枚举每个点 $\mathcal O(nm)$；
- spfa 最坏时间复杂度 $\mathcal O(4(nm)^2)$；
- 枚举每个点 $\mathcal O(nm)$；
- 总时间复杂度为 $\mathcal O(4(nm)^3+(nm)^2)$，可以过。

## 代码
```cpp
#include <bits/stdc++.h>

#define x first
#define y second
#define MP make_pair

using namespace std;

typedef long long LL;
typedef pair<int, int> PII;
typedef unsigned long long ULL;

const int N = 40, INF = 0x3f3f3f3f;
const double eps = 1e-8;

int n, m, k;
PII q[N * N]; // 这里我用的是循环队列
int dist[N][N];
bool st[N][N];
char g[N][N];

int spfa(int x, int y, int w) // spfa
{
    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
    int hh = 0, tt = 0;
    memset(dist, 0x3f, sizeof dist);
    dist[x][y] = w;
    q[tt ++ ] = MP(x, y);

    while (hh != tt)
    {
        PII t = q[hh ++ ];
        if (hh == N * N) hh = 0;
        st[t.x][t.y] = false; // 把这个点标记为不在队列里
        
        for (int i = 0; i < 4; i ++ ) // 枚举这个点的所有邻点
        {
            int a = t.x + dx[i], b = t.y + dy[i];
            if (a < 0 || a >= n || b < 0 || b >= m) continue; // 判断是否越界
            int w = g[a][b] == '1' ? 1 : 0; // 计算权值
            if (dist[a][b] > dist[t.x][t.y] + w)
            {
                dist[a][b] = dist[t.x][t.y] + w;
                if (!st[a][b])
                {
                    q[tt ++ ] = MP(a, b);
                    st[a][b] = true; // 标记为已经在队列里
                    if (tt == N * N) tt = 0;
                }
            }
        }
    }
}

int main()
{
    cin >> n >> m >> k;
    for (int i = 0; i < n; i ++ ) cin >> g[i];
    double res = 0;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < m; j ++ ) // 枚举把那个点做为起点
        {
            int w = g[i][j] == '1' ? 1 : 0; // 计算权值
            if (w > k) continue; // 如果已经不合法了就不用执行了
            spfa(i, j, w);
            for (int x = 0; x < n; x ++ )
                for (int y = 0; y < m; y ++ )
                    if (dist[x][y] <= k)
                        res = max(res, sqrt(abs(x - i) * abs(x - i) + abs(y - j) * abs(y - j))); // 求最大值
        }
    
    printf("%.6lf\n", res); // 输出答案
	return 0;
}
```

---

## 作者：Accoty_AM (赞：4)

~~是不是把这道题想难了。。。。~~
## 分层图最短路

	如果当前点（x）能通向的点（y）是0 就在t个层建 x到y的边

	如果当前点（x）能通向的点（y）是1 就在t-1个层建 x到下一层y的边
   
	bfs判断是否联通。。。
   
	每次枚举i,j,il,ij,看能否从(i,j)到(il,jl)

时间复杂度 n * m * t * n * m.....反正过了

```cpp
#include<bits/stdc++.h>
using namespace std;
char mp[35][35];
int head[30010],ver[200010],nxt[200010],tot;
int vis[30010];
int n,m,t;
inline void add(int x,int y){
	ver[++tot]=y;
	nxt[tot]=head[x];
	head[x]=tot;
}
int dx[]={0,0,1,-1},dy[]={1,-1,0,0};
double get(int x,int y,int xl,int yl){
	return sqrt((double)(xl-x)*(xl-x)+(double)(yl-y)*(yl-y));
}
double ans;
void bfs(int s){
	queue<int> q;
	q.push(s);
	memset(vis,0,sizeof vis);
	vis[s]=1;
	while(!q.empty()){
		int x=q.front();q.pop();
		for(int y,i=head[x];i;i=nxt[i]){
			y=ver[i];
			if(!vis[y]) q.push(y),vis[y]=1;
		}
	}
}
int main(){
	cin>>n>>m>>t;
	for(int i=1;i<=n;++i) scanf("%s",mp[i]+1);
	for(int xl,yl,i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			for(int p=0;p<4;++p){
				xl=j+dx[p];yl=i+dy[p];
				if(xl<1||yl<1||xl>m||yl>n) continue;
				if(mp[yl][xl]=='0'){
					for(int k=0;k<=t;++k){
						add(n*m*k+(i-1)*m+j,n*m*k+(yl-1)*m+xl);
					}
				}else{
					for(int k=0;k<t;++k){
						add(n*m*k+(i-1)*m+j,n*m*(k+1)+m*(yl-1)+xl);
					}
				}
			}
		}
	}
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			if(mp[i][j]=='1') continue;
			bfs((i-1)*m+j);
			for(int il=1;il<=n;++il){
				for(int jl=1;jl<=m;++jl){
					for(int k=0;k<=t;++k){
						if(vis[n*m*t+(il-1)*m+jl]) {
							ans=max(ans,get(j,i,jl,il));
							break;
						}
					}
				}
			}
		}
	}
	printf("%.6lf",ans);
	return 0;
}
```


---

## 作者：FISH酱 (赞：3)

## 前言

本题做法有很多，本篇题解介绍一种简单的方法 Floyd，另外本题难度是假的，可以当作黄题。

## 前置知识

Floyd 是多源最短路算法，通过枚举中转点和起点终点进行最短路更新计算，其时间复杂度可以在本题限制下完美通过，下面是一个简单的 Floyd 模板代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

#define ll long long
#define ld long double
#define inf 1007483647
#define endl '\n'

int n,m,ans;
int dp[5007][5007]; // 开个数组存储最短路答案，dp[i][j] 表示从 i 点到 j 点的最短路长度

int main(){
  // 初始化最短路数组
	for(int i=1;i<=1000;i++){
		for(int j=1;j<=1000;j++){
			dp[i][j]=inf; // inf 之所以不是 2147483647，是因为设成 2147483647 的话加起来会炸 int
		}
    // 下面这句位置一定要对，放前面的话会被覆盖
		dp[i][i]=0; // 自己到自己的距离显然是 0
	}

	cin >> n >> m; // 输入，有 n 个点，有 m 条边

	for(int i=1;i<=m;i++){
		int x,y,z;cin>>x>>y>>z; // 输入起点、终点、权值（距离）
		dp[x][y]=dp[y][x]=z; // 建立双向边
	}

	for(int k=1;k<=n;k++){ // 枚举中转点
		for(int i=1;i<=n;i++){ // 枚举起点
			for(int j=1;j<=n;j++){ // 枚举终点
				if(i!=j&&j!=k&&i!=k){ // 不能相等
					dp[i][j] = min(dp[i][j],dp[i][k]+dp[k][j]); // 查询通过 k 作为中转点时的最短路长度，并更新最短路长度
				}
			}
		}
	}

	for(int i=1;i<=n;i++) ans = max(ans,dp[1][i]); // 按照题意寻找答案
	cout<<ans; // 输出答案

	return 0; // 完结撒花
}
```

Floyd 算法的讲解到此为止，接下来进入下一部分。

## 思路

本题的题意已经足够清晰，故不再解释。

开始之前我们要记得先初始化最短路答案数组，并且设好记录最长距离的变量的初始值。

输入矩阵时我们要注意只读入一格宽的数字：

```cpp
scanf("%1d",&mp[i][j]); // scanf读入一格宽的数字，记得加取地址符
```

像这种没有空格分开的格式，一定要多注意。读入以后我们开始建图，有公共边就能到达，那我们就可以使用偏移量数组，加上边界判断和建图即可，建图时，如果需要移走障碍物才能走到下一个位置，就把边权设为 $1$，否则设为 $0$。

这里的每个点是由两个坐标值组成的，存储到最短路答案数组时非常不方便，下标很难处理，如果是一个整数就会比较简单，这里采用简单哈希函数进行处理：

```cpp
int hash1(int a,int b){ // 如果你用了万能头，请不要使用 hash 进行命名，会冲突
	return (a-1)*m+(b-1)+1; // 简单的哈希函数
}
```

建图完成后我们开始 Floyd 算法求解，每个点的编号是由哈希函数生成的，简单推断即可得知范围，我们在范围内进行三重循环，找中转点、起点、终点，并更新，注意这里的最短路数组实际上存储的是最少需要移走多少块障碍物：

```cpp
s = n*m+1; // 估算哈希函数生成的点编号的最大范围
for(int k=1;k<=s;k++){ // 枚举中转点
  for(int i=1;i<=s;i++){ // 枚举起点
    for(int j=1;j<=s;j++){ // 枚举终点
      if(dp[i][j]>dp[i][k]+dp[k][j]){ // 判断使用中转点是否更优
        dp[i][j] = dp[i][k]+dp[k][j]; // 更新
      }
    }
  }
}
```

弄完以后我们只需要四重循环暴力枚举，找到任意两个起点和终点，查询在最少需要移走的障碍物个数是否满足题目所述条件，如果满足就计算距离并且更新最长距离的答案值：

```cpp
for(int i=1;i<=n;i++){ // 枚举起点坐标
  for(int j=1;j<=m;j++){ // 枚举起点坐标
    for(int k=1;k<=n;k++){ // 枚举终点坐标
      for(int l=1;l<=m;l++){ // 枚举终点坐标
        double juli=sqrt(abs(i-k)*abs(i-k)+abs(j-l)*abs(j-l)); // 使用公式计算距离
        if(dp[hash1(i,j)][hash1(k,l)]+mp[i][j]<=t && juli>maxn){ // 判断是否符合障碍物个数限制，和是否比当前最长距离更长
          maxn = juli; // 更新答案
        }
      }
    }
  }
}
```

## 代码

注意一下细节就可以了，总的来说没什么难点。

```cpp
#include <bits/stdc++.h>

using namespace std;

#define ll long long
#define ld long double
#define inf 2147483647
#define endl '\n'

int n,m,t,s; // 定义各种变量
double maxn; // 存储最长距离的变量，记得 double
int mp[1000][1000]; // 存题目输入的矩阵
int dp[1000][1000]; // 存最短路答案，即最少需要移走多少个障碍物
int dx[4]={0,1,-1,0}; // 偏移量
int dy[4]={1,0, 0,-1}; // 偏移量

int hash1(int a,int b){
	return (a-1)*m+(b-1)+1; // 简单的哈希函数，不必过于认真的写
}

int main(){
	memset(dp,0x3f,sizeof(dp)); // 初始化最短路数组，设为 inf
	memset(mp,0,sizeof(mp)); // 好习惯，清空矩阵数组
	maxn=0.0; // 初始化最长距离答案变量
	
	cin >> n >> m >> t; // 读入
	s=n*m+1; // 提前估算哈希函数返回的最大点编号

	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			scanf("%1d",&mp[i][j]); // 读入一格宽数字，注意 scanf 用法
		}
	}

  // 对每个点进行操作
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			for(int x=0;x<4;x++){ // 通过偏移量枚举可能的连接位置
				int nx=i+dx[x],ny=j+dy[x]; // 计算位置
				if(1<=nx&&nx<=n&&1<=ny&&ny<=m){ // 判断边界
					dp[hash1(i,j)][hash1(nx,ny)] = mp[nx][ny]; // 建一条边，如果走到下一个点需要移走障碍物，那么边权为 1，否则为 0
				}
			}
		}
	}
	
	for(int k=1;k<=s;k++){ // 枚举中转点
		for(int i=1;i<=s;i++){ // 枚举起点
			for(int j=1;j<=s;j++){ // 枚举终点
				if(dp[i][j]>dp[i][k]+dp[k][j]){ // 如果使用中转点的方案更优
					dp[i][j] = dp[i][k]+dp[k][j]; // 更新
				}
			}
		}
	}
	
  for(int i=1;i<=n;i++){ // 枚举起点坐标
    for(int j=1;j<=m;j++){ // 枚举起点坐标
      for(int k=1;k<=n;k++){ // 枚举终点坐标
        for(int l=1;l<=m;l++){ // 枚举终点坐标
          double juli=sqrt(abs(i-k)*abs(i-k)+abs(j-l)*abs(j-l)); // 使用公式计算距离
          if(dp[hash1(i,j)][hash1(k,l)]+mp[i][j]<=t && juli>maxn){ // 判断是否符合障碍物个数限制，和是否比当前最长距离更长
            maxn = juli; // 更新答案
          }
        }
      }
    }
  }
	
	cout << fixed << setprecision(6) << maxn; // 输出答案，注意保留 6 位小数

	return 0; // 完结撒花
}
```

---

## 作者：Chester (赞：3)

~~（我认为是双端队列的裸题~~  
从每个点进行 bfs， 如果下一步有障碍， 就是cost+1, 加入到队尾。  下一步没有障碍， 加入队首 cost不变。  
可以保证 从出发点到每个节点所移除的障碍物最少  
计算可以到达的点到出发点的距离的最大值即可  
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<deque>
#define h first //只是简化代码， 毕竟first 5个字母QuQ
#define l second
#define cl(a) memset(a, 0, sizeof(a))
using namespace std;
typedef pair<int,int> P; //pair 封装点坐标

const int N = 35;
int dx[4] = {0, 0, -1, 1}, dy[4] = {1, -1, 0, 0};
int vis[N][N], MP[N][N], n, m, t, cost[N][N];
char s[N];
deque<P> qu; //双端队列
double MAX;

double cal(P a, P b) { //计算距离
	int x = a.h - b.h, y = a.l - b.l;
	return sqrt((double)x*x + (double)y*y);
}

void bfs(P x) {
	qu.clear();
	vis[x.h][x.l] = 1;
	if(MP[x.h][x.l]) cost[x.h][x.l] = 1;
	qu.push_back(x);
	while(!qu.empty()) {
		P now = qu.front(); qu.pop_front();
		if(cost[now.h][now.l] > t)return;
		for(int i = 0; i < 4; ++i) {
			if(now.h + dx[i] > n || now.h + dx[i] < 1) continue;
			if(now.l + dy[i] > m || now.l + dy[i] < 1) continue;
			P nt(now.h + dx[i], now.l + dy[i]);
			if(vis[nt.h][nt.l]) continue;
			if(!MP[nt.h][nt.l]) {
				qu.push_front(nt);
				cost[nt.h][nt.l] = cost[now.h][now.l];
				vis[nt.h][nt.l] = 1;
				MAX = max(MAX, cal(x, nt));
			}
			else {
				if(cost[now.h][now.l] + 1 > t)continue;
				cost[nt.h][nt.l] = cost[now.h][now.l] + 1;
				vis[nt.h][nt.l] = 1;
				qu.push_back(nt);
				MAX = max(MAX, cal(x, nt));
			}
		}
	}
}

int main()
{
	scanf("%d%d%d",&n,&m,&t);
	for(int i = 1; i <= n; ++i) {
		scanf("%s",s);
		for(int j = 0; j < m; ++j) MP[i][j+1] = s[j] - '0';
	}
	for(int i = 1; i <= n; ++i)
	for(int j = 1; j <= m; ++j) {
		bfs(P(i,j));
		cl(cost); cl(vis);
	}
	printf("%.6f\n",MAX);
}

```

---

## 作者：Saber_Master (赞：2)

[P4162 [SCOI2009]最长距离](https://www.luogu.com.cn/problem/P4162)

题意：给你一个$n*m$的棋盘，有些点有障碍，通过费用为$1$,有些点无障碍，免费通过.给你$K$的代价，问你从任意一点到达另一点的最大距离.

这题我们不难想出一个暴力：先固定一个点，然后从这个点往外扫，扫描在剩余代价内能遍历到的最远的点.由于$n,m$都很小，所以理论复杂度能过，瓶颈在于如何求出在剩余代价内能否到达对应的点.

注意到障碍点通过是有代价的，于是乎容易联想到最短路，扫描时每次用$spfa$扫出当前点到其它点的最小代价即可.

$O((n\cdot m)^2log(n\cdot m))$

核心代码

```cpp
ll n, m, K;

char c[31][31];
bool mp[31][31];

ll dis[31][31];
bool vis[31][31];
queue<pair<ll, ll> > q;

const ll dx[4]={0, 0, 1, -1}, dy[4]={1, -1, 0, 0};

inline void spfa(ll Sx, ll Sy){
	memset(dis, 0x3f, sizeof dis);
	dis[Sx][Sy]=mp[Sx][Sy];
	q.push(make_pair(Sx, Sy));
	while (q.size()){
		ll x=q.front().first, y=q.front().second;
		vis[x][y]=false;
		q.pop();
		for (R ll i=0, nx, ny; i<4; i++){
			nx=x+dx[i]; ny=y+dy[i];
			if (nx<=0 || nx>n || ny<=0 || ny>m) continue;
			if (dis[nx][ny]>dis[x][y]+mp[nx][ny]){
				dis[nx][ny]=dis[x][y]+mp[nx][ny];
				if (!vis[nx][ny]){
					q.push(make_pair(nx, ny));
					vis[nx][ny]=true;
				}
			}
		}
	}
}

dl res;
int main(){
	read(n); read(m); read(K);
	for (R ll i=1; i<=n; i++) scanf("%s", c[i]+1);
	for (R ll i=1; i<=n; i++)
		for (R ll j=1; j<=m; j++)
			mp[i][j]=(c[i][j]=='1');
	for (R ll i=1; i<=n; i++)
		for (R ll j=1; j<=m; j++){
			spfa(i, j);
			for (R ll k=1; k<=n; k++)
				for (R ll l=1; l<=m; l++)
					if (dis[k][l]<=K) chkmax(res, sqrt(1.0*(k-i)*(k-i)+1.0*(l-j)*(l-j)));
		}
	printf("%.6lf\n", res);
}
```


---

## 作者：VioletIsMyLove (赞：2)

其实这道题有一个思维障碍，就是读完题之后不知道该如何移石头。

但其实很简单，把题抽象成模型后发现这就是个最短路，

把有石头的值标为1，没石头的标为0，最后每个格子刷一趟，看最短路是否小于等于T。

最后用公式求一下最小的ans就可以了。

Code:

```
#include<bits/stdc++.h>
using namespace std;
const int w[4][2]={{-1,0},{0,1},{1,0},{0,-1}};
struct ZS{
	int x,y;
}q[100005];
int n,m,t,ans;
int f[35][35],mp[35][35];
void BFS(int x,int y){
	memset(f,127,sizeof f);f[x][y]=mp[x][y];
	int hed=0,til=0;q[++til]=(ZS){x,y};
	while(hed<=til){
		hed++;\\最短路
		for(int i=0;i<=3;i++)if(q[hed].x+w[i][0]>=1&&q[hed].x+w[i][0]<=n&&q[hed].y+w[i][1]>=1&&q[hed].y+w[i][1]<=m&&f[q[hed].x+w[i][0]][q[hed].y+w[i][1]]>f[q[hed].x][q[hed].y]+mp[q[hed].x+w[i][0]][q[hed].y+w[i][1]])f[q[hed].x+w[i][0]][q[hed].y+w[i][1]]=f[q[hed].x][q[hed].y]+mp[q[hed].x+w[i][0]][q[hed].y+w[i][1]],q[++til]=(ZS){q[hed].x+w[i][0],q[hed].y+w[i][1]};
	}
}
int make(int x,int y,int xx,int yy){
	return (x-xx)*(x-xx)+(y-yy)*(y-yy);\\注意这里先不要开方，确保精度没问题，最后输出的时候再开方就OK了
}
inline int read(){
	int ret=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-f;ch=getchar();}
	while(isdigit(ch)){ret=ret*10+ch-'0';ch=getchar();}
	return ret*f;
}
int main(){
	freopen("maxl.in","r",stdin);
	freopen("maxl.out","w",stdout);
	n=read();m=read();t=read();
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++)mp[i][j]=getchar()-'0';
		getchar();
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++){
			BFS(i,j);
			for(int ii=1;ii<=n;ii++)
			for(int jj=1;jj<=m;jj++)if(f[ii][jj]<=t)ans=max(ans,make(i,j,ii,jj));
	}
	printf("%.6lf\n",sqrt(ans));
	return 0;
}
```
蒟蒻的第一篇题解，希望能通过

---

## 作者：Wy_x (赞：1)

题目传送门：[P4162 [SCOI2009] 最长距离](https://www.luogu.com.cn/problem/P4162)


以 $O(n^5)$ 暴力碾过，开 O2 拿到[最优解](https://www.luogu.com.cn/record/list?pid=P4162&orderBy=1&status=&page=1) 75 ms。

------------


### 解法：

**容易发现，从没有障碍的点开始枚举一定优于从有障碍的点开始枚举。**
这个剪枝优化效果十分明显。

对于每个没有障碍的点，从这个点进行一次广搜。

然后暴力枚举从这个点开始可以到的点的最短距离的平方，取 $\max$。

枚举结束后，把这个最大值开根号，输出，然后就没有然后了。

**如果地图全为 $1$，需要特判。**

------------

### 代码：
```cpp
#include<bits/stdc++.h>
#define reg register
#define int long long
using namespace std; 

const int fx[4]={1,-1,0,0};
const int fy[4]={0,0,1,-1};
//每次扩展可以到的点
bool vis[35][35];
bool mp[35][35];//输入的地图
int n,m,T;

queue<pair<int,int> > q,q2;

void copy_queue()
{
	while(q.size()) q.pop();
	while(q2.size())
		q.push(q2.front()),vis[q2.front().first][q2.front().second]=1,q2.pop();
//拷贝的同时把 vis 数组也更新。

}

void bfs(int cnt)//清除 cnt 个障碍后可以到的边
{
	copy_queue();//拷贝
	
	while(q.size())
	{
		int x=q.front().first;
		int y=q.front().second;
		q.pop();
		
		for(int i=0;i<4;i++)
		{
			int xx=x+fx[i];
			int yy=y+fy[i];
			
			if(vis[xx][yy]) continue;
			if(xx<1||yy<1||xx>n||yy>m) continue;
			//不合法
			if(mp[xx][yy])//有障碍
			{
				q2.push(make_pair(xx,yy));
				//把这个坐标推入下一次广搜的初始队列
			}
			else//没有障碍
			{
				vis[xx][yy]=1;//推入点，更新 vis 数组
				q.push(make_pair(xx,yy));
			}
		}
	}
	if(cnt<T) bfs(cnt+1);//如果没有清除到 T 个障碍
	else//清除到了
	{
		while(q2.size()) q2.pop();
		//把 q2 清空，防止下次搜索出错
	}
}

int DIS(int x,int y,int i,int j)
//求两点之间距离的平方
{
	return (x-i)*(x-i)+(y-j)*(y-j);
}

signed main()
{
	cin>>n>>m>>T;
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
	{
		char c;
		cin>>c;
		mp[i][j]=c=='1';//输入
	}
	
	int ans=0;
	
	for(int i=1;i<=n;i++)//枚举每一个点
	for(int j=1;j<=m;j++)
	{
	//	if(T==0&&mp[i][j]) continue;
		if(mp[i][j]) continue;//剪枝
		memset(vis,0,sizeof(vis));//初始化 0
		vis[i][j]=1;
		q2.push(make_pair(i,j));
		bfs(mp[i][j]);//开始广搜
		//等价于 bfs(0);
		for(int x=1;x<=n;x++)
		for(int y=1;y<=m;y++)
		{
			if(!vis[x][y]) continue;
			ans=max(ans,DIS(i,j,x,y));
		}//更新最大值
	}
	if(ans==0)//如果地图全为 1
	{//特判
		//让 (1,1) 与某个点之间的障碍消除一定最优
		for(int i=1,j=T;i<=T;i++,j--)
		{
			if(i<=n&&j<=m) ans=max(ans,DIS(1,1,i,j));
			if(i<=m&&j<=n) ans=max(ans,DIS(1,1,j,i));
		}
	}
	printf("%.6lf",sqrt(ans));
	//需要把 ans（距离的平方）开根才是答案
	
	return 0;
}
```


---

## 作者：Z1qqurat (赞：1)

暴力建图+最短路。

### 思路

题意磨人。就是说如果格子 $a$ 和 $b$ 之间按格子走需要经过的障碍物数量少于 $t$ 就说明 $a$ 和 $b$ 可以互相到达，距离为俩格子中心的直线距离。

不要盯着要你求的那个什么最长距离看，转化一下，先把所有格子弄一个暴力建图：

```cpp
int nx,ny,v;
for(int i=1;i<=n;i++){
    for(int j=1;j<=m;j++){
        for(int k=0;k<4;k++){
            nx=i+dx[k],ny=j+dy[k];
            if(nx>=1&&nx<=n&&ny>=1&&ny<=m){
                v=c[nx][ny]=='1'?1:0;
                G[i][j].push_back((node){nx,ny,v});
            }
        }
    }
}
```

然后对着这个图跑一个最短路，这里需要把 $dis[i]$ 设为由起点到 $i$ 需要经过的障碍物的数量的最小值即可，就是最短路班子了对吧，单源。

然后去看哪些 $dis[i]$ 小于 $t$ 去算起点到 $i$ 的格子中心的距离，比一个最小值就可以了。

### 注意点

1.有多个起点，多次调用最短路函数，记得清理数组。

2.在算 $dis[i]$ 的时候记得看看起点有没有障碍物。

3.距离是指格子中心的直线距离，别写成奇奇怪怪的东西了。

上面的坑我至少踩了四个。

### 代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<vector>
#include<queue>
using namespace std;
const int MAXN=31,inf=2147483647;
int n,m,t,dis[MAXN][MAXN];
bool vis[MAXN][MAXN];
double ans=-1e9;
char c[MAXN][MAXN];
int dx[]={0,1,0,-1};
int dy[]={1,0,-1,0};
struct node{
    int x,y,val;
};
vector <node> G[MAXN][MAXN];
struct Node{
    int ax,ay,dist;
    bool operator<(const Node &b) const{
        return dist>b.dist;
    }
};
priority_queue <Node> pq;

void Dijkstra(int sx,int sy){
    memset(vis,0,sizeof(vis));
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            dis[i][j]=inf;
        }
    }
    dis[sx][sy]=0;
    pq.push((Node){sx,sy,0});
    int bx,by;
    while(pq.empty()==0){
        bx=pq.top().ax,by=pq.top().ay;
        pq.pop();
        if(vis[bx][by]==1)continue;
        vis[bx][by]=1;
        for(int i=0;i<G[bx][by].size();i++){
            node nxt=G[bx][by][i];
            if(dis[nxt.x][nxt.y]>dis[bx][by]+nxt.val){
                dis[nxt.x][nxt.y]=dis[bx][by]+nxt.val;
                pq.push((Node){nxt.x,nxt.y,dis[nxt.x][nxt.y]});
            }
        }
    }
    return ;
}

int main(){
    cin>>n>>m>>t;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin>>c[i][j];
        }
    }
    int nx,ny,v;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            for(int k=0;k<4;k++){
                nx=i+dx[k],ny=j+dy[k];
                if(nx>=1&&nx<=n&&ny>=1&&ny<=m){
                    v=c[nx][ny]=='1'?1:0;
                    G[i][j].push_back((node){nx,ny,v});
                }
            }
        }
    }
    double tmp;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            Dijkstra(i,j);
            v=c[i][j]=='1'?1:0;
            for(int k=1;k<=n;k++){
                for(int l=1;l<=m;l++){
                    if(k==i&&l==j)continue;
                    if(dis[k][l]+v<=t){
                        tmp=sqrt((k-i)*(k-i)+(l-j)*(l-j));
                        ans=ans>tmp?ans:tmp;
                    }
                }
            }
        }
    }
    printf("%.6lf",ans);
    return 0;
}
```

---

## 作者：iranai (赞：0)

# 思路
观察数据范围，发现最多不过九百个点，即使每个点都跑一次 dijkstra 也不会超时，所以可以硬暴力。

建图时，由于每次向
```1```
连边都会消耗一次移走障碍物的机会，所以向
```1```
连的边权值为 $1$，其余为 $0$。

既然建好了图，那就可以开跑 dijkstra 了！我们先定义一个 $ans$ 来存储最长距离，然后每一个点都跑一遍 dijkstra，如果一个点到起点的最短路距离小于等于 $T$，则说明可以通过移走若干障碍物到达这个点，这个点到起点的欧几里得距离就可以参与到答案的比较中。最后输出 $ans$ 就好。

# 代码

```
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> PII;

char a[40][40];
int n,m,op;

int h[10000];
int to[100000];
int w[100000];
int nt[100000];
int idx;
void add(int x,int y,int z){
	to[idx]=y;
	w[idx]=z;
	nt[idx]=h[x];
	h[x]=idx++;
}

int d[10000];
bool v[10000];

int dx[4]={0,0,+1,-1};
int dy[4]={+1,-1,0,0};

double ans;

void dijkstra(int u){
	memset(d,0x3f,sizeof(d));
	memset(v,0,sizeof(v));
	priority_queue<PII,vector<PII>,greater<PII> > hp;
	d[u]=0;
	hp.push((PII){0,u});
	while(!hp.empty()){
		PII top=hp.top();
		hp.pop();
		int t=top.second;
		if(!v[t]){
			v[t]=true;
			for(int i=h[t];i!=-1;i=nt[i]){
				int j=to[i];
				if(d[j]>d[t]+w[i]){
					d[j]=d[t]+w[i];
					hp.push((PII){d[j],j});
				}
			}
		}
	}
}
double getdist(int x,int y,int s,int t){
	return sqrt((x-s)*(x-s)+(y-t)*(y-t));
}
int main(){
	memset(h,-1,sizeof(h));
	
	scanf("%d%d%d",&n,&m,&op);
	
	for(int i=1;i<=n;i++){
		scanf("%s",a[i]+1);
	}
	
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			for(int k=0;k<4;k++){
				int x=i+dx[k];
				int y=j+dy[k];
				if(1<=x&&x<=n&&1<=y&&y<=m){
					if(a[x][y]=='1'){
						add((i-1)*m+j,(x-1)*m+y,1);
					}else{
						add((i-1)*m+j,(x-1)*m+y,0);
					}
				}
			}
		}
	}
	
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			dijkstra((i-1)*m+j);
			for(int x=1;x<=n;x++){
				for(int y=1;y<=m;y++){
					if(x==i&&y==j) continue;
					if(a[i][j]=='1') d[(x-1)*m+y]++;
					if(d[(x-1)*m+y]<=op){
						ans=max(ans,getdist(i,j,x,y));
					}
				}
			}
		}
	}
	printf("%.6lf",ans);
	return 0;
}

```

---

## 作者：fanminghao000 (赞：0)

建图的思路十分显然，把有障碍的地方看做点权为 1。两个点想要能到达，要保证路径上不能经过超过 $t$ 个障碍。所以很自然就转化到了求最短路上：如果两点间最短路大于 $t$，也就是要经过大于 $t$ 个障碍才能到达，那就不能到达，反之就可以到达。

看到这美妙的数据范围 $nm\le900$，不禁让我想到了一个十分暴力且好写的算法：floyd。时间复杂度 $O(n^3m^3)$，在洛谷强大的评测机上稳稳通过，~~喜提全场第三劣解~~。

值得注意的是有障碍的地方也可以当做起点，但 floyd 计算最短路的时候并没有考虑起点的点权，所以判断障碍数时要加上这个点权。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

const int inf=1e9;
int n,m,t;
int cal(int x,int y){
	return (x-1)*m+y;
}
int ans=0;
void dist(int x1,int y1,int x2,int y2){
	ans=max(ans,(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
}
int a[35][35],f[910][910];
int main(){
	ios::sync_with_stdio(0);
	cin>>n>>m>>t;
	for(int i=1;i<=n;i++){
		string s;cin>>s;s=' '+s;
		for(int j=1;j<=m;j++) a[i][j]=s[j]-'0';
	}
	for(int i=1;i<=n*m;i++){
		for(int j=1;j<=n*m;j++) f[i][j]=inf;
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
           //建图注意越界问题
			if(i+1<=n) f[cal(i,j)][cal(i+1,j)]=a[i+1][j];
			if(i-1>=1) f[cal(i,j)][cal(i-1,j)]=a[i-1][j];
			if(j+1<=m) f[cal(i,j)][cal(i,j+1)]=a[i][j+1];
			if(j-1>=1) f[cal(i,j)][cal(i,j-1)]=a[i][j-1];
		}
	}
	for(int k=1;k<=n*m;k++){
		for(int i=1;i<=n*m;i++){
			for(int j=1;j<=n*m;j++){
				f[i][j]=min(f[i][j],f[i][k]+f[k][j]);
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			for(int p=1;p<=n;p++){
				for(int q=1;q<=m;q++){
					if(f[cal(i,j)][cal(p,q)]+a[i][j]<=t){//记得加上点权
						dist(i,j,p,q); 
					}
				}
			}
		}
	}
	printf("%.6lf",sqrt(ans));
	return 0;
}
```

---

## 作者：AzureHair (赞：0)

题干花里胡哨，但是仔细一看发现可以把题干转化一下，即求两点间的最少移走障碍物数，然后判断是否在规定范围内，并更新最大值。具体实现直接暴力建图，暴力最短路最后暴力得出结论。

本题细节多，慢慢食用，切莫着急。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,t,a[40][40],mov[4][2]={{1,0},{0,-1},{-1,0},{0,1}},dis[40][40],vis[40][40];
double ans=-1e9;
struct node//存边
{
	int x,y,v;
	node(int x,int y,int v):x(x),y(y),v(v) {}
};
struct node1//最短路食用
{
	int x,y,s;
	node1(int x,int y,int s):x(x),y(y),s(s) {}
	bool operator <(const node1 p) const
	{
		return s>p.s;
	}
};
priority_queue <node1> q;
vector <node> mp[40][40];
void djs(int x,int y)//最短路
{
	memset(vis,0,sizeof(vis));//清空数组
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			dis[i][j]=2147483647;
		}
	}
	dis[x][y]=0;
	q.push(node1(x,y,0));
	while(!q.empty())
	{
		int xx=q.top().x,yy=q.top().y;
		q.pop();
		if(vis[xx][yy])
		{
			continue;
		}
		vis[xx][yy]=1;
		for(int i=0;i<mp[xx][yy].size();i++)//更新dis
		{
			if(dis[xx][yy]+mp[xx][yy][i].v<dis[mp[xx][yy][i].x][mp[xx][yy][i].y])
			{
				dis[mp[xx][yy][i].x][mp[xx][yy][i].y]=dis[xx][yy]+mp[xx][yy][i].v;
				q.push(node1(mp[xx][yy][i].x,mp[xx][yy][i].y,dis[mp[xx][yy][i].x][mp[xx][yy][i].y]));
			}
		}
	} 
	return ;
}
int main()
{
	cin>>n>>m>>t;
	for(int i=1;i<=n;i++)
	{
		string x;
		cin>>x;
		for(int j=0;j<m;j++)
		{
			a[i][j+1]=x[j]-'0';
		}
	}
	for(int i=1;i<=n;i++)//存图
	{
		for(int j=1;j<=m;j++)
		{
			for(int o=0;o<=3;o++)
			{
				int xx=i+mov[o][0],yy=j+mov[o][1];
				if(xx>=1&&xx<=n&&yy>=1&&yy<=m)
				{
					mp[i][j].push_back(node(xx,yy,(a[xx][yy]==1)));
				}
			}
		}
	}
	for(int i=1;i<=n;i++)//更新答案
	{
		for(int j=1;j<=m;j++)
		{
			djs(i,j);
			for(int k=1;k<=n;k++)
			{
				for(int l=1;l<=m;l++)
				{
					if(i==k&&j==l)
					{
						continue;
					}
					if(dis[k][l]+(a[i][j]==1)<=t)
					{
						ans=max(ans,(double)sqrt((i-k)*(i-k)+(j-l)*(j-l)));
					}
				}
			}
		}
	}
	printf("%.6lf",ans);//愉快AC
	return 0;
}
```


---

## 作者：_szs9601 (赞：0)

### 题意
这题虽然是道蓝题，但本质上就是最短路，不要想得太复杂。
### 思路
首先，我们用 bfs 求出两个点之间需要移动多少障碍才能到达。接着，我们直接暴力枚举两个点，判断是否能到达，最后求两点直线距离的最大值就可以了。
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int tag[4][2]={0,1,1,0,0,-1,-1,0};
double ma;
int n,m,k,i,j,i1,j2,x,y,I,J,xx,yy,a[50][50],f[1000][1000],e[1000];
queue<int>q1,q2;
int s(int x,int y){return (x-1)*m+y;}//这里我用一个数字代替一个点，但打完之后发现没什么用
int read(){
	int x=0;char ch=getchar();
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9') x=x*10+ch-48,ch=getchar();
	return x;
}
int main(){
	n=read();m=read();k=read();
	for(i=1;i<=n;i++)
		for(j=1;j<=m;j++) scanf("%1d",&a[i][j]);
	for(i=1;i<=n;i++)
		for(j=1;j<=m;j++){
			memset(e,64,sizeof(e));
			I=s(i,j);
			if(a[i][j]) e[I]=1;
			else e[I]=0;
			q1.push(i);q2.push(j);
			while(!q1.empty()){
				x=q1.front();y=q2.front();
				for(i1=0;i1<4;i1++){
					xx=x+tag[i1][0];yy=y+tag[i1][1];
					if(xx<1||yy<1||xx>n||yy>m) continue;
					J=s(xx,yy);
					if(e[J]>e[s(x,y)]+a[xx][yy]){
						q1.push(xx);q2.push(yy);
						e[J]=e[s(x,y)]+a[xx][yy];
					}
				}
				q1.pop();q2.pop();
			}
			for(i1=1;i1<=n;i1++)
				for(j2=1;j2<=m;j2++) f[I][s(i1,j2)]=e[s(i1,j2)];
		}//bfs求两点之间需要移动的障碍数
	for(i=1;i<=n;i++)
		for(j=1;j<=m;j++)
			for(i1=1;i1<=n;i1++)
				for(j2=1;j2<=m;j2++)
					if(f[s(i,j)][s(i1,j2)]<=k&&sqrt((i1-i)*(i1-i)+(j2-j)*(j2-j))>ma)
						ma=sqrt((i1-i)*(i1-i)+(j2-j)*(j2-j));//暴力枚举两点，求欧几里德距离最大值
	printf("%.6lf\n",ma);
	return 0;
}
```


---

## 作者：BzhH (赞：0)

[博客内观看](https://www.cnblogs.com/A2484337545/p/15439367.html)

这题暴力建图再加个最短路就可以过。

对于一个点 $x$，我们给它和它相邻的点之间连一条有向边，若相邻的点为石头，则边权为 $1$，反之，则为 $0$。

然后大力枚举每一个点 $x$，对于每一个点都跑一遍 Dijskra 算法，这时候，我们就已经求出了点 $x$ 到其他所有点需要经过的石头的数量的最小值，然后再枚举终点更新答案即可，时间复杂度 $\Theta(n^4)$。

代码
```
#include<iostream>
#include<cstdio>
#include<queue>
#include<cmath>
#include<cstring>
#define get(x, y) ((x - 1) * n + y)
using namespace std;
const int N = 1e6 + 5;
typedef pair<int, int> PII;

char sq[35][35];
int dis[905];
int head[N], ver[N], net[N], edge[N], idx;
bool vis[905];

void add(int a, int b, int c)
{
    net[++idx] = head[a], ver[idx] = b, edge[idx] = c, head[a] = idx;
}

void Dij(int s, int d)
{
    memset(dis, 0x3f, sizeof(dis));
    memset(vis, 0, sizeof(vis));
    dis[s] = d;
    priority_queue<PII, vector<PII>, greater<PII> > q;
    q.push({d, s});
    while (!q.empty())
    {
        int u = q.top().second;
        q.pop();
        if (vis[u])
            continue;
        vis[u] = true;
        for (int i = head[u]; i; i = net[i])
        {
            int v = ver[i];
            if (dis[v] > dis[u] + edge[i])
            {
                dis[v] = dis[u] + edge[i];
                q.push({dis[v], v});
            }
        }
    }
}

double get_dis(int x, int y, int xx, int yy)
{
    return sqrt((x - xx) * (x - xx) + (y - yy) * (y - yy)); 
}

int main()
{
    int n, m, t;
    scanf("%d%d%d", &n, &m, &t);
    for (int i = 1; i <= n; i++)
        scanf("%s", sq[i] + 1);
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            if (i > 1)
                add(get(i, j), get(i - 1, j), sq[i - 1][j] == '1');
            if (i < n)
                add(get(i, j), get(i + 1, j), sq[i + 1][j] == '1');
            if (j > 1)
                add(get(i, j), get(i, j - 1), sq[i][j - 1] == '1');
            if (j < m)
                add(get(i, j), get(i, j + 1), sq[i][j + 1] == '1');
        }
    }
    double ans = 0;
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            Dij(get(i, j), sq[i][j] == '1');
            for (int x = 1; x <= n; x++)
            {
                for (int y = 1; y <= m; y++)
                {
                    if (dis[get(x, y)] <= t)
                        ans = max(ans, get_dis(i, j, x, y));
                }
            }
        }
    }
    printf("%.6lf", ans);
    return 0;
}

```

---

## 作者：Usmireko (赞：0)

为啥我这题RE爆0了啊QAQ
------------------ -----------
首先来个栗子：          
![](https://cdn.luogu.com.cn/upload/pic/71732.png)     
$T=2$

这道题的难点在于如何处理障碍物（废话，数据范围都告诉你了）

枚举或搜索搬走哪些障碍物再处理是肯定会T掉的

那么，让我们思考如何处理障碍物     

当我们移走一块障碍物时，发生了什么变化呢？    

![](https://cdn.luogu.com.cn/upload/pic/71738.png)        

我们发现当付出1代价时，可以到达更远的点(1,3),(2,3)

也就是说，当我们将所有点连起来时,(1,1)到(1,3),(2,3)的最短路长度为1（无障碍的点之间边权为0）

那么，一个点可以通过搬走t个障碍物到达另一个点在这个思路下等同于这两个点间的最短路长度小于等于t，当大于t时这个点则不能到达         

接下来枚举每一个点u，求出最短路，判断所有最短路小于等于t的点中到u的最大距离即可。用spfa或搜索+剪枝均可      

复杂度 $O(n^{4}logn)$        

代码:    
```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<vector>
using namespace std;
int t,n,m;
class node{
    public:
    int x,y;
};
int mm[101][101],diss[101][101];
int dx[7]={0,1,-1,0,0};
int dy[7]={0,0,0,1,-1};

void dfs(int x,int y,int sum){
    if(sum>t)return;//在前往下一个点的路上就已经搬了t个障碍物     
    if(sum>=diss[x][y])return;//某个点已经被走过
    diss[x][y]=sum;
    for(int i=1;i<=4;i++){
        int new_x=x+dx[i];
        int new_y=y+dy[i];
        if(new_x>0&&new_x<=n&&new_y>0&&new_y<=m){
            dfs(new_x,new_y,sum+mm[new_x][new_y]);
        }
    }
}

int main(){
    scanf("%d%d%d",&n,&m,&t);
    for(int i=1;i<=n;i++){
        char ch[32];
        scanf("%s",ch);
        for(int j=0;j<m;j++){
            mm[i][j+1]=ch[j]-'0';
        }
    }
    int ans=0;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            memset(diss,127,sizeof(diss));//初始化最短路
            dfs(i,j,mm[i][j]);
            for(int l=1;l<=n;l++){
                for(int r=1;r<=m;r++){
                    if(diss[l][r]<=t)//到达(l,r)点需要搬走的障碍物数小于等于t
                    ans=std::max(ans,(l-i)*(l-i)+(r-j)*(r-j));
                }
            }
        }
    }
    printf("%.6lf\n",(double)sqrt(ans));
}
```


---

## 作者：Celebrate (赞：0)

```
100%的数据，满足 1 <= N,M <= 30 ； 0 <= T <= 30 。
```

很显然，这一题直接用搜索就可以过

枚举每一个点，并且将这个点搜索一次，找出所有可以到达的点，并在搜索的时候顺便求出最长欧几里得距离



最坏情况下这个代码的时间复杂度是 （ n^4log(n^2) ) ，理论上是过不了的^_^，   但是数据比较水，所以......

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <queue>
#include <cmath>

using namespace std ;

const int N = 31 ;

const int dx[4] = { 0 , 0 , -1 , 1 } ;
const int dy[4] = { -1 , 1 , 0 , 0 } ;

int n , m , T ;

int map[N][N] ;

double maxx = 0.0 ;

inline double get ( int x1 , int y1 , int x2 , int y2 ) {
	if ( x1 == x2 ) return double ( abs ( y1-y2 ) ) ;
	if ( y1 == y2 ) return double ( abs ( x1-x2 ) ) ;
	return sqrt ( double ( ( x1-x2 ) * ( x1-x2 ) + ( y1-y2 ) * ( y1-y2 ) ) ) ;
}

struct node {
	int x , y , k ;
	inline bool operator < ( const node &kk ) const {
		return k < kk.k ;
	}
};
priority_queue <node> q ;
int dis[N][N] ;
void Dijkstra ( int sx , int sy ) {
	if ( T == 0 && map[sx][sy] == 1 ) return ;
	q.push ( (node){ sx , sy , map[sx][sy] } ) ;
	memset ( dis , 63 , sizeof ( dis ) ) ; dis[sx][sy] = map[sx][sy] ;
	while ( !q.empty() ) {
		node x = q.top() ; q.pop() ;
		if ( x.k > dis[x.x][x.y] ) continue ;
		maxx = max ( maxx , get ( sx , sy , x.x , x.y ) ) ;
		for ( int i = 0 ; i <= 3 ; i ++ ) {
			int xx = x.x + dx[i] , yy = x.y + dy[i] ;
			if ( !( 1 <= xx && xx <= n && 1 <= yy && yy <= m ) ) continue ;
			if ( map[xx][yy] == 1 && x.k + 1 > T ) continue ;
			if ( dis[xx][yy] > x.k + map[xx][yy] ) {
				dis[xx][yy] = x.k + map[xx][yy] ;
				q.push( (node){ xx , yy , x.k + map[xx][yy] } ) ;
			}
		}
	}
	return ;
}
		
int main() {
	cin >> n >> m >> T ; char st[31] ;
	for ( int i = 1 ; i <= n ; i ++ ) {
		scanf ( "%s" , st+1 ) ;
		for ( int j = 1 ; j <= m ; j ++ )
			if ( st[j] == '1' ) map[i][j] = 1 ;
	}
	for ( int i = 1 ; i <= n ; i ++ ) 
		for ( int j = 1 ; j <= m ; j ++ )
			Dijkstra ( i , j ) ;
	printf ( "%.6lf\n" , maxx ) ; return 0 ;
}
```

---

## 作者：thh_loser (赞：0)

# P4162 [SCOI2009] 最长距离

[题目链接](https://www.luogu.com.cn/problem/P4162)

写完后逛了一圈题解（其实我发现是我写的太慢了想康康大佬的），发现都是用的 dijkstra、spfa 和 bfs，于是有了一种新思路。

## FLOYD

$n$，$m$ 这么小，又是求全源距离，不会首先想到 floyd 吗？

首先 $n$，$m$ 之积也不过 $900$ 说明算法是可行的 ~~（但是太慢了）~~ 。因此我们可以硬连边，对于矩阵中两个相邻的点，如果两个均为 $0$ ，两点之间距离为 $0$ ，每有一个 $1$ 则将两点之间距离增加 $1$。显然这里需要**双向建边**，否则来回距离就不同了，但双向也有一个的细节需要处理，暂且不提。

建好图后就是 floyd 的模板了，求出全源最短路。最后就是最重要的判断，这里有一个上文提到过的小细节。对于两个距离不为 $0$ 的点，这个距离的贡献一定来自于路径上的一个点，这个点我们需要分成两种情况讨论。

第一种就是两个端点均为 $0$ ，譬如 $0110$，那么贡献距离的点都在中间，而对于这个点（抽象的点，可以是一串 $1$），往两端一定有两个 $0$，而这一个点被前端的点解锁后到后端的点是不需要再次解锁的，但 floyd 是不能判断这一点的，因此我们将得到的距离**去重**，即除以 $2$ 就是真实距离。

第二种是端点包含 $1$ ，譬如 $110$。其他点和第一种情况中的一样，不同的是对于两端的端点在计算中原本就只经过了一次，是**不需要**去重的，所以先去重后再加上为 $1$ 的端点数量就是真实距离。

将每次合法的距离与 $ans$ 比较大小即可。

这比起 dijkstra 慢的不知道到哪去了，但也不失为一种解题方法。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,t,N,ans;
const int maxn=0x3f3f3f3f;
int d[955][955];
int dx[4]={1,0,-1,0},dy[4]={0,-1,0,1};
char s[55][55];
int mak(int x,int y){//通过x，y坐标变成一个点 
	return (x-1)*m+y;
}
int fun(int x,int y){//可以先求平方和，最后输出时再开根 
	return x*x+y*y;
}
int main(){
//	freopen("dis.in","r",stdin);
//	freopen("dis.out","w",stdout);
	scanf("%d%d%d",&n,&m,&t);
	N=n*m;//点的个数 
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>s[i][j];
		}
	}
	memset(d,0x3f,sizeof(d));
	for(int i=1;i<=n;i++){//建边
		for(int j=1;j<=m;j++){
			int do1=mak(i,j);
			for(int k=0;k<4;k++){
				int rx=i+dx[k],ry=j+dy[k];
				if(rx>n||rx<1||ry>m||ry<1){
					continue;
				}
				int do2=mak(rx,ry);//两个点 
				if(s[rx][ry]=='1'){//是1 
					if(d[do1][do2]==0x3f3f3f3f){//第一次访问 
						d[do1][do2]=1;
					}
					else{
						d[do1][do2]++;//两个都是1 
					}
					if(d[do2][do1]==0x3f3f3f3f){
						d[do2][do1]=1;
					}
					else{
						d[do2][do1]++;
					}
				}
				else{//0 
					d[do1][do2]=(d[do1][do2]==maxn? 0 : d[do1][do2]);
					d[do2][do1]=(d[do2][do1]==maxn? 0 : d[do2][do1]);
				}
			}
		}
	}
	for(int k=1;k<=N;k++){
		for(int i=1;i<=N;i++){
			for(int j=1;j<=N;j++){
				d[i][j]=min(d[i][j],d[i][k]+d[k][j]);
			}
		}
	}//floyd模板 
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			int do1=mak(i,j),k=(s[i][j]=='1'?1:0);
			for(int ii=1;ii<=n;ii++){
				for(int jj=1;jj<=m;jj++){
					int do2=mak(ii,jj);
					d[do1][do2]/=2;//去重 
					d[do1][do2]+=k+(s[ii][jj]=='1'?1:0);//判断端点为1 
					if(d[do1][do2]<=t){
						ans=max(fun(abs(i-ii),abs(j-jj)),ans);
					}
				}
			}
		}
	}
	printf("%.6lf",(double)(sqrt(ans))); 
	return 0;
}
```

感谢观看

---

## 作者：Empty_Dream (赞：0)

### P4162 解题报告

#### 题意

给你一张 $n \times m$ 的图，其中 $a_{i,j}=1$ 表示有障碍，否则没有障碍，其中可以消除 $t$ 个障碍，求所有格子的**最大**距离。

#### 分析

这其实就是一道搜索的版子题。

根据数据范围很容易想到可以枚举起点，然后通过广搜遍历起点到每一个点的距离和需要消除障碍的个数。遍历完之后枚举终点，求出消除障碍个数小于 $t$ 的节点距离起点的最大的距离。

注意，在求最大距离的时候不要先开方，保持精度，等到输出的时候再开方。

#### 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int dx[] = {0, 1, 0, -1};
const int dy[] = {1, 0, -1, 0};
int n, m, s, dis[105][105], a[105][105];
double maxn;
struct node{int x, y;};
void bfs(int x, int y){//搜索版子
	queue<node> q;
	q.push((node){x, y});
	dis[x][y] = a[x][y];
	while (!q.empty()){
		node t = q.front();
		q.pop();
		for (int i = 0; i < 4; i++){
			int nx = t.x + dx[i], ny = t.y + dy[i];
			if (nx > 0 && nx <= n && ny > 0 && ny <= m && dis[nx][ny] > dis[t.x][t.y] + (a[nx][ny] == 1)){
				dis[nx][ny] = dis[t.x][t.y] + (a[nx][ny] == 1);//记录需要消除的障碍个数
				q.push((node){nx, ny});
			}
		}
	}
}
signed main(){
	scanf("%lld%lld%lld", &n, &m, &s);
	for (int i = 1; i <= n; i++){
		for (int j = 1; j <= m; j++) scanf("%1lld", &a[i][j]);//这样可以直接一位一位输入整数
	}
	memset(dis, 0x3f, sizeof dis);
	bfs(1, 1);
	for (int i = 1; i <= n; i++){
		for (int j = 1; j <= m; j++){//枚举起点
			memset(dis, 0x3f, sizeof dis);
			bfs(i, j);//遍历到每个节点的距离
			for (int k = 1; k <= n; k++){
				for (int l = 1; l <= m; l++){//枚举终点
					if (dis[k][l] <= s) maxn = max(maxn, (double)(k - i) * (k - i) + (l - j) * (l - j));
				}
			} 
		}
	}
	printf("%.6lf", sqrt(maxn));
	return 0;
}
```

---

## 作者：Jesselrj (赞：0)

# 最长距离 [SCOI2009]

原题链接：[luogu P4612](https://www.luogu.org/problemnew/show/P4162)

这道题，第一眼觉得是最短路的衍生~~（最长路）~~，后来经过思考，以及同学的解释，发现其实真的是一道最短路，而且也能过，但是懒，不想打~~（fú zhì）~~ Dijkstra 或 SPFA ，所以就写的dfs。

读完题后，可以想到：可以枚举每一个点，对其进行dfs。

数据范围为：$1 <= M,N <= 30$，而T的数据范围实际上是与时间复杂度无关的。

所以只要会一点剪枝以及可以想到这题可以dfs，就可以做出这道题。

接下来就是 **电风扇（dfs）** 时间：

### AC代码如下
```cpp
#include<bits/stdc++.h>
using namespace std;

int n,m,T,hinder[31][31],ans,t;
int dx[4]={0,-1,0,1};
int dy[4]={1,0,-1,0};
bool mp[31][31];char ch;

void dfs(int x,int y,int num,int sy)
{
	if(t-num<sy)return;//可行性剪枝,搜不到，就没有必要了
	if(num>T)return;//限制条件
	if(num>=hinder[x][y])return;//最优化剪枝,当走到同一个位置，而另一个方法更优时，就没有必要进行下去了
	hinder[x][y]=num;//记忆化搜索
	for(int i=0;i<4;++i)
	{
		int nx=x+dx[i],ny=y+dy[i];
		if(nx>=1&&nx<=n&&ny>=1&&ny<=m)
		dfs(nx,ny,num+mp[nx][ny],sy-mp[nx][ny]);
	}
}

int main()
{
    cin>>n>>m>>T;
    for(int i=1;i<=n;++i)
    for(int j=1;j<=m;++j)
    {
    	scanf("%c",&ch);
    	if(ch=='\n'){j--;continue;}
    	if(ch=='1')t++;//记录障碍数，以便剪枝。
    	mp[i][j]=ch-'0';
    }
    for(int i=1;i<=n;++i)
    for(int j=1;j<=m;++j)
    {
    	for(int x=1;x<=n;++x)
   		for(int y=1;y<=m;++y)
    	hinder[x][y]=2147483647;//赋值极大值，之所以不用 memset ，是因为时间复杂度高。 
    	
    	dfs(i,j,mp[i][j],t);//电风扇 
    	for(int x=1;x<=n;++x)
    	for(int y=1;y<=m;++y)
    	if(hinder[x][y]<=T)ans=max(ans,(x-i)*(x-i)+(y-j)*(y-j));//求最优解，不开方先，防止精度溢出。 
	}
	printf("%.6lf",sqrt(ans)); //输出答案。 
    return 0;
}
```

---


# [JSOI2010] 满汉全席

## 题目描述

满汉全席是中国最丰盛的宴客菜肴，有许多种不同的材料透过满族或是汉族的料理方式，呈现在数量繁多的菜色之中。由于菜色众多而繁杂，只有极少数博学多闻技艺高超的厨师能够做出满汉全席，而能够烹饪出经过专家认证的满汉全席，也是中国厨师最大的荣誉之一。世界满汉全席协会是由能够料理满汉全席的专家厨师们所组成，而他们之间还细分为许多不同等级的厨师。

为了招收新进的厨师进入世界满汉全席协会，将于近日举办满汉全席大赛，协会派遣许多会员当作评审员，为的就是要在参赛的厨师之中，找到满汉界的明日之星。

大会的规则如下：每位参赛的选手可以得到 $n$ 种材料，选手可以自由选择用满式或是汉式料理将材料做成菜肴。

大会的评审制度是：共有 $m$ 位评审员分别把关。每一位评审员对于满汉全席有各自独特的见解，但基本见解是，要有两样菜色作为满汉全席的标志。如某评审认为，如果没有汉式东坡肉跟满式的涮羊肉锅，就不能算是满汉全席。但避免过于有主见的审核，大会规定一个评审员除非是在认为必备的两样菜色都没有做出来的状况下，才能淘汰一位选手，否则不能淘汰一位选手。

换句话说，只要参赛者能在这两种材料的做法中，其中一个符合评审的喜好即可通过该评审的审查。如材料有猪肉，羊肉和牛肉时，有四位评审员的喜好如下表： 

```
评审一 评审二 评审三 评审四 
满式牛肉 满式猪肉 汉式牛肉 汉式牛肉 
汉式猪肉 满式羊肉 汉式猪肉 满式羊肉 
```

如参赛者甲做出满式猪肉，满式羊肉和满式牛肉料理，他将无法满足评审三的要求，无法通过评审。而参赛者乙做出汉式猪肉，满式羊肉和满式牛肉料理，就可以满足所有评审的要求。

但大会后来发现，在这样的制度下如果材料选择跟派出的评审员没有特别安排好的话，所有的参赛者最多只能通过部分评审员的审查而不是全部，所以可能会发生没有人通过考核的情形。

如有四个评审员喜好如下表时，则不论参赛者采取什么样的做法，都不可能通过所有评审的考核： 

```
评审一 评审二 评审三 评审四 
满式羊肉 满式猪肉 汉式羊肉 汉式羊肉 
汉式猪肉 满式羊肉 汉式猪肉 满式猪肉 
```

所以大会希望有人能写一个程序来判断，所选出的 $m$ 位评审，会不会发生没有人能通过考核的窘境，以便协会组织合适的评审团。

## 样例 #1

### 输入

```
2
3 4
m3 h1
m1 m2
h1 h3
h3 m2
2 4
h1 m2
m2 m1
h1 h2
m1 h2```

### 输出

```
GOOD
BAD```

# 题解

## 作者：niiick (赞：65)

~~这么裸的2-SAT楼上怎么全是拆四个点这么麻烦=_=，~~
~~实在忍不住了来一波只拆两个点的题解~~

对于每样材料$i\  $**拆成两个点**，
结点$i$表示**满式**做法，结点$i+n$表示**汉式**

每个评委的限制条件都可以看做**或**的形式

1.$m_i,m_j$——
连边$i+n$到$j$，表示若$i$为汉式，则$j$必须为满式；
连边$j+n$到$i$，表示若$j$为汉式，则$i$必须为满式

2.$m_i,h_j$——
连边$i+n$到$j+n$，表示若$i$为汉式，则$j$必须为汉式；
连边$j$到$i$，表示若$j$为满式，则$i$必须为满式

3.$h_i,h_j$——
连边$i$到$j+n$，表示若$i$为满式，则$j$必须为汉式；
连边$j$到$i+n$，表示若$j$为满式，则$i$必须为汉式

4.$h_i,m_j$——
连边$i$到$j$，表示若$i$为满式，则$j$必须为满式；
连边$j+n$到$i+n$，表示若$j$为汉式，则$i$必须为汉式

建图后tarjan求强连通分量，
判断$i$和$i+n$**是否属于同一个强连通分量**即可

```
//niiick
#include<iostream>
#include<stack>
#include<algorithm>
#include<queue>
#include<cstring>
#include<cstdio>
using namespace std;
typedef long long lt;
 
int read()
{
    int f=1,x=0;
    char ss=getchar();
    while(ss<'0'||ss>'9'){if(ss=='-')f=-1;ss=getchar();}
    while(ss>='0'&&ss<='9'){x=x*10+ss-'0';ss=getchar();}
    return f*x;
}
 
const int maxn=400;
int t,n,m;
struct node{int v,nxt;}E[4010];
int head[maxn],tot;
int low[maxn],dfn[maxn],cnt,judge;
int col[maxn],ins[maxn],colnum;
stack<int> st;
char s1[5],s2[5];
 
void add(int u,int v)
{
    E[++tot].nxt=head[u];
    E[tot].v=v;
    head[u]=tot;
}
 
void tarjan(int u)
{
    low[u]=dfn[u]=++cnt;
    st.push(u); ins[u]=1;
    for(int i=head[u];i;i=E[i].nxt)
    {
        int v=E[i].v;
        if(!dfn[v]){ tarjan(v); low[u]=min(low[u],low[v]);}
        else if(ins[v])
        low[u]=min(low[u],dfn[v]);
    }
    if(low[u]==dfn[u])
    {
        int v; colnum++;
        do{
            v=st.top();
            st.pop(); ins[v]=0;
            col[v]=colnum;
        }
        while(v!=u);
    }
}
 
void init()
{
    judge=tot=cnt=colnum=0;
    memset(head,0,sizeof(head)); 
    memset(col,0,sizeof(col));
    memset(low,0,sizeof(low));
    memset(dfn,0,sizeof(dfn));
    //memset(ins,0,sizeof(ins));
}
 
int main()
{
    t=read();
    while(t--)
    {
        init();
        n=read();m=read();
        for(int i=1;i<=m;++i)//h-1,m-0
        {
            scanf("%s%s",&s1,&s2);
            int u=0,v=0,k;
            k=1; while(s1[k]>='0'&&s1[k]<='9')u=u*10+s1[k++]-'0';
            k=1; while(s2[k]>='0'&&s2[k]<='9')v=v*10+s2[k++]-'0';
            if(s1[0]=='m')
            {
                if(s2[0]=='h')add(u+n,v+n),add(v,u);
                else if(s2[0]=='m')add(u+n,v),add(v+n,u);
            }
            else if(s1[0]=='h')
            {
                if(s2[0]=='h')add(u,v+n),add(v,u+n);
                else if(s2[0]=='m')add(u,v),add(v+n,u+n);
            }
        }
     
        for(int i=1;i<=n<<1;++i)
        if(!dfn[i])tarjan(i);
     
        for(int i=1;i<=n;++i)
        if(col[i]==col[i+n]){judge=1;break;}
     
        if(judge) printf("BAD\n");
        else printf("GOOD\n");
    }
    return 0;
}
```



---

## 作者：SuperJvRuo (赞：26)

蒟蒻AC的第一道2-SAT

建图方法：将每种材料的每种做法拆成选与不选，在“不选汉式做法”和“选满式做法”间连边，在“不选满式做法”和“选汉式做法”间连边，对于每个评委的要求，从“不做第一道菜”向“做第二道菜”连边，从“不做第二道菜”到“做第一道菜”连边。tarjan之后，看是否有同一种材料的“选汉式做法”和“选满式做法”在同一个SCC中，是否有同一种材料的同一道做法的“选”与“不选”在同一SCC中。
```
#include<cstdio>
#include<cctype>
#include<algorithm>
#include<stack>

using namespace std;

struct Edge
{
	int to,next;
}edge[2500];
int head[405],etot;

inline void add_edge(int a,int b)
{
	edge[++etot]=(Edge){b,head[a]};
	head[a]=etot;
}

int Read()
{
	int x=0;
	char c=getchar();
	while(!isdigit(c))
	{
		c=getchar();
	}
	while(isdigit(c))
	{
		x=(x<<3)+(x<<1)+(c^48);
		c=getchar();
	}
	return x;
}

void input(int &res)
{
	res=0;
	char c;
	while(c=getchar(),c!='h'&&c!='m');
	res=Read();
	res=(res-1)*2;
	if(c=='m')
	{
		res|=1;
	}
}

int belong[405],low[405],dfn[405],inStack[405];
int index,SCC;
stack<int> S;

void Tarjan(int x)
{
	low[x]=dfn[x]=++index;
	inStack[x]=1;
	S.push(x);
	for(int i=head[x];i;i=edge[i].next)
	{
		int to=edge[i].to;
		if(!dfn[to])
		{
			Tarjan(to);
			low[x]=min(low[x],low[to]);
		}
		else if(inStack[to])
		{
			low[x]=min(low[x],dfn[to]);
		}
	}
	if(low[x]==dfn[x])
	{
		SCC++;
		
		int top;
		while(!S.empty()&&S.top()!=x)
		{
			top=S.top();
			inStack[top]=0;
			belong[top]=SCC;
			S.pop();
		}
		inStack[x]=0;
		belong[x]=SCC;
		S.pop();
	}
}

int main()
{
	int t=Read();
	while(t--)
	{
		etot=0;
		int n=Read(),m=Read();
		n<<=1;
		index=SCC=0;
		for(int i=0;i<(n<<1);i++)
		{
			head[i]=inStack[i]=dfn[i]=0;
            //初始化
		}
        /*
        * 对于第i种材料
        * i<<1：选汉式做法
        * i<<1|1：选满式做法
        * (i<<1)+n：不选汉式做法
        * (1<<1|1)+n：不选满式做法
        */
		for(int i=0;i<m;i++)
		{
			int a,b;
			input(a);
			input(b);
			add_edge(a+n,b);//不选第一道，一定选第二道
			add_edge(b+n,a);//不选第二道，一定选第一道
		}
		for(int i=0;i<n;i++)//对于每种材料的每种做法
		{
			add_edge(i+n,i^1);//不选这种做法，一定选另一种
			add_edge(i^1,i+n);
		}
		for(int i=0;i<(n<<1);i++)
		{
			if(!dfn[i])
			{
				Tarjan(i);
			}
		}
		
		bool flag=0;
		for(int i=0;i<n;i++)
		{
			if(belong[i]==belong[i+n]||belong[i]==belong[i^1])
			{
				flag=1;
				break;
			}
		}
		if(!flag)
		{
			puts("GOOD");
		}
		else
		{
			puts("BAD");
		}
	}
	return 0;
}
```

图片与题解无关
![](https://cdn.luogu.com.cn/upload/pic/15339.png )

---

## 作者：TonyYin (赞：9)

#### upd

2021.07.71：原来的代码给错了

2021.08.27：修改了分析部分的笔误

## 题意

题面比较长，先概括一下。如果感觉题目没有完全看懂，建议先看一下下面的要点概括。

题目给定了 $n$ 种**食材**，对于每种食材，有两种**制作方法**。对于每一种食材，只能用一次，也就是必须**恰好选择一种**制作方法。一道**菜品**的信息，同时包括食材和制作方法。

题目给定了 $m$ 条限制，每条限制包含**两个**菜品的信息。对于每条限制，限制被满足，当且仅当：在给出的两个菜品中，至少有一个菜品被制作出来。

题目问：是否存在一种菜品制作方法，使得每条限制都被满足。

题目有多组询问，询问次数 $T\leq 50$，食材个数 $n\leq 100$，限制条数 $m\leq 1000$.

## 分析

看到每种食材必须在两种制作方法中，恰好选择一种，想到 **2-SAT** 算法。

对于每种食材，将两种制作方式拆成两个点。具体地，代表满式做法的点编号为 $[1, n]$，代表汉式做法的点编号为 $[n + 1, 2n]$.

因为要用到 **2-SAT**，我们需要找到**形如 $a \land b = 0$ 且 $a \lor b = 1$** 的关系。

对于限制条件给定的两个菜品 $u, v$，通过分类讨论，可以找到其中这样的关系。

1. 限制内容：**$u$ 为满式，$v$ 为满式**。关系：
   - 若 $u$ 为汉式，则 $v$ 必为满式；
   - 若 $v$ 为汉式，则 $u$ 必为满式。
2. 限制内容：**$u$ 为满式，$v$ 为汉式**。关系：
   - 若 $u$ 为汉式，则 $v$ 必为汉式；
   - 若 $v$ 为满式，则 $u$ 必为满式。
3. 限制内容：**$u$ 为汉式，$v$ 为满式**。关系：
   - 若 $u$ 为满式，则 $v$ 必为满式；
   - 若 $v$ 为汉式，则 $u$ 必为汉式。
4. 限制内容：**$u$ 为汉式，$v$ 为汉式**。关系：
   - 若 $u$ 为满式，则 $v$ 必为汉式；
   - 若 $v$ 为满式，则 $u$ 必为汉式。

这样建图之后，直接跑 **2-SAT** 即可。如果你不会 **2-SAT**，可以参考：[Anguei 的博客 - 2-SAT 问题](https://anguei.blog.luogu.org/solution-p4782)。

## 代码


```cpp
#include <bits/stdc++.h>

using namespace std;
const int MAXN = 208, MAXM = 2008;
struct Edge{
	int to, nxt;
} edge[MAXM];
int head[MAXN], cnt = 0;
void add_edge(int u, int v) {
	edge[++cnt].to = v;
	edge[cnt].nxt = head[u];
	head[u] = cnt;
}
int T, n, m;
string in1, in2;
int dfn[MAXN], low[MAXN], tot = 0, st[MAXN], top = 0, vis[MAXN], col[MAXN], scc = 0;
void Tarjan(int x) {
	dfn[x] = low[x] = ++tot;
	st[++top] = x; vis[x] = true;
	for(int i = head[x]; i; i = edge[i].nxt) {
		int v = edge[i].to;
		if(!dfn[v]) {
			Tarjan(v); low[x] = min(low[x], low[v]);
		} else if(vis[v]) {
			low[x] = min(low[x], dfn[v]);
		}
	}
	if(dfn[x] == low[x]) {
		col[x] = ++scc;
		int y;
		do {
			y = st[top--]; vis[y] = false;
			col[y] = scc;
		} while(x != y);
	}
}
int main() {
	scanf("%d", &T);
	while(T--) {
		tot = top = scc = cnt = 0;
		memset(head, 0, sizeof(head));
		memset(dfn, 0, sizeof(dfn)); memset(low, 0, sizeof(low));
		memset(vis, 0, sizeof(vis)); memset(col, 0, sizeof(col));
		scanf("%d%d", &n, &m);
		for(int i = 1; i <= m; i++) {
			cin >> in1 >> in2;
			int x = 0, y = 0;
			for(int j = 1; j < in1.length(); j++) x = x * 10 + in1[j] - '0';
			for(int j = 1; j < in2.length(); j++) y = y * 10 + in2[j] - '0';
			if(in1[0] == 'm' && in2[0] == 'm') {
				add_edge(x + n, y); add_edge(y + n, x);
			} else if(in1[0] == 'm' && in2[0] == 'h') {
				add_edge(x + n, y + n); add_edge(y, x);
			} else if(in1[0] == 'h' && in2[0] == 'm') {
				add_edge(x, y); add_edge(y + n, x + n);
			} else {
				add_edge(x, y + n); add_edge(y, x + n);
			}
		}
		for(int i = 1; i <= (n << 1); i++) {
			if(!dfn[i]) Tarjan(i);
		}
		bool noans = false;
		for(int i = 1; i <= n; i++) {
			if(col[i] == col[i + n]) {
				cout << "BAD\n"; noans = true; break;
			}
		}
		if(!noans) cout << "GOOD\n";
	}
	return 0;
}
```

---

## 作者：George1123 (赞：7)

[${\color{#eea000}\text{欢迎拜访我这个蒟蒻的博客}}$](https://www.luogu.org/blog/Wendigo/)

[P4171 【\[JSOI2010\]满汉全席】](https://www.luogu.org/problem/P4171)

### 此题算法:2-sat

大致思路:

>1.$ $输入约束条件，其中$i$，$a$，$j$，$b$表示第$i$种肉必须用$a$做法或第$j$种肉必须用$b$做法，注意$n\geq 10$

```cpp
char f=getchar();
int i,a,j,b;
while(f!='m'&&f!='h')
	f=getchar();
a=(f=='m');
scanf("%d",&i);
f=getchar();
while(f!='m'&&f!='h')
	f=getchar();
b=(f=='m'); 
scanf("%d",&j);
```


>2.$ $如$($满式羊肉$or$汉式牛肉$)$这样一个要求，可以看成$($汉式羊肉$->($箭头表示"则必须"$)$汉式牛肉$)$以及$($满式牛肉$->$满式羊肉$)$两个条件，并以文中$->$为边建图。

![](https://s2.ax1x.com/2019/11/07/MALJnP.jpg)

>图中有$2\times n$个点，$($要求$\times 2)$条边。其中汉式点编号$1$...$n$，满式点编号$n+1$...$2\times n$。


```cpp
//加边
if(a&&b){
	add(j+n,i);
	add(i+n,j);
} else if(!a&&b){ //这是如上情况
	add(i,j);
	add(j+n,i+n);
} else if(a&&!b){
	add(i+n,j+n);
	add(j,i);
} else if(!a&&!b){
	add(i,j+n);
	add(j,i+n);
}
```

>而下面的代码与上面的是等价的。



```cpp
//简化
add(i+n*(a&1),j+n*(b^1));
add(j+n*(b&1),i+n*(a^1));
```

>3.$ $建好图后，开始Tarjan求强连通分量。可知，**同一强联通分量中的菜不能包括同种肉的两种做法，否则，答案为BAD**。所以求出强连通分量后，求可以立刻得出答案。

![](https://s2.ax1x.com/2019/11/08/MEa7sf.jpg)

>上图为样例一的建图，答案为$GOOD$。


## 以下是代码+注释

 
 
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=2019; //2n个节点
int t,n,m;
struct edge{
	int adj,nex;
}e[N<<1];//4n条边
int g[N],top;
void add(int x,int y){
	e[++top]=(edge){y,g[x]};
	g[x]=top;
}
int ind,cnt,dfn[N],low[N],val[N];
bool vst[N];
stack<int> pos;
void tarjan(int x){ //tarjan缩点
	dfn[x]=low[x]=++ind;
	pos.push(x),vst[x]=1;
	for(int i=g[x];i;i=e[i].nex){
		int to=e[i].adj;
		if(!dfn[to]){
			tarjan(to);
			low[x]=min(low[x],low[to]);
		} else if(vst[to])
			low[x]=min(low[x],dfn[to]);
	}
	if(low[x]==dfn[x]){
		int tmp=0;
		cnt++;
		while(tmp!=x){
			tmp=pos.top();
			pos.pop();
			val[tmp]=cnt;
			vst[tmp]=0;
		}
	}
}
void sat2(){ 
	scanf("%d%d",&n,&m);
	cnt=ind=top=0;
	for(int i=1;i<=2*n;i++)
		vst[i]=g[i]=dfn[i]=low[i]=0;
	//初始化必须彻底
	for(int t=1;t<=m;t++){
		char f=getchar();
		int i,a,j,b;
		while(f!='m'&&f!='h')
			f=getchar();
		a=(f=='m');
		scanf("%d",&i);
		f=getchar();
		while(f!='m'&&f!='h')
			f=getchar();
		b=(f=='m');  //n>=10
		scanf("%d",&j);		
		add(i+n*(a&1),j+n*(b^1));
		add(j+n*(b&1),i+n*(a^1));
//		建图
	}
	for(int i=1;i<=2*n;i++)
		if(!dfn[i])
			tarjan(i);
	for(int i=1;i<=n;i++)
		if(val[i]==val[i+n]){
			puts("BAD");
			return;
		}
	puts("GOOD");
}
int main(){
	scanf("%d",&t); //多组测试数据
	while(t--) sat2();
	return 0;
}

```

注意双倍点，4倍边。

谢谢大家! !


---

## 作者：硫代硫酸钠 (赞：6)

我们注意到:

1.一个厨师不会做同一种菜肴的满式和汉式做法.

2.一个厨师必须要做同一种菜肴的满式和汉式做法二者之一.

对于n个菜肴我们拆4n个点.

具体地,对于第i种菜肴:

$2\cdot i-1$ 表示第i种菜肴采取满式做法

$2\cdot i$ 表示第i种菜肴采取汉式做法

$2\cdot i-1+2\cdot n$ 表示第i种菜肴不采取满式做法

$2\cdot i+2\cdot n$ 表示第i种菜肴不采取汉式做法

那么 如果一种菜肴不用汉式做就必须用满式做,

如果一种菜肴不用满式做就必须用汉式做.

现在我们来考虑$m$个限制.

如果$a,b$是原题中说明的两个限制.

那么如果不选$a,b$的其中一个,一定要选另一个来满足限制.

剩下的就是2-sat好戏了


蒟蒻的代码:

```
#include<algorithm>
#include<cctype>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<map>
#include<queue>
#include<stack>
#include<vector>
#define size 500010
#define opp(x) (x>(n<<1)?x-(n<<1):x+(n<<1))
#define clr(x) memset(x,0,sizeof(x))
#define gc getchar()
#define tp to[p]
#define ll long long
#define rep(i,s,n) for (register int i=s;i<=n;i++)
#define drep(i,n,s) for (register int i=n;i>=s;i--)
#define il inline
using namespace std;

il ll r()
{
	char c; ll x,f=1;
	for (c=gc;!isdigit(c);c=gc) if (c=='-') f=-1; x=c-'0';
	for (c=gc;isdigit(c);c=gc) x=(x<<1)+(x<<3)+c-'0';
	return f*x;
}

il int set()
{
	char c; int res; while (c=gc,c!='m'&&c!='h');res=r();
	if (c=='m') return 2*res-1; else return 2*res; 
}

int head[size],to[size],nxt[size],num,dfn[size],low[size];
int s[size],top,scc[size],scc_num,dfn_num,n,m;
bool ins[size];

void add(int x,int y) {num++; to[num]=y;nxt[num]=head[x];head[x]=num;}// printf("#%d %d\n",x,y);}

void Tarjan(int x)
{
	dfn[x]=low[x]=++dfn_num; s[++top]=x; ins[x]=1;
	for (int p=head[x];p;p=nxt[p])
		if (!dfn[tp]) Tarjan(tp),low[x]=min(low[x],low[tp]);
			else if (ins[tp]) low[x]=min(low[x],dfn[tp]);
	if (low[x]==dfn[x])
	{
		scc[x]=++scc_num; ins[x]=0; int v;
		while (v=s[top--],v!=x) ins[v]=0,scc[v]=scc_num;
	}
}

bool pd()
{
	for (int i=1;i<=(n<<2);i++) if (!dfn[i]) Tarjan(i);
	rep(i,1,(n<<1)) if (scc[i]==scc[opp(i)]) return 0;
	rep(i,1,n) if (scc[i*2]==scc[i*2-1]) return 0;  return 1;
}

void solve()
{
	clr(head); clr(dfn); clr(ins);clr(low); top=num=dfn_num=scc_num=0;
	n=r(); m=r(); 
	rep(i,1,n<<1) 
	{
		add(opp(2*i-1),2*i); add(opp(2*i),2*i-1); 
	}
	rep(i,1,m)
	{
		int a=set(),b=set(); 
		add(opp(a),b); add(opp(b),a);
	}
	bool B=pd(); 
	if (B) cout<<"GOOD"; else cout<<"BAD"; cout<<endl;
}

int main()
{
	int T=r();
	while (T--) solve();
	return 0;
}

```



---

## 作者：KEBrantily (赞：4)

题目很长，废话很多，但是很板

## Description

给出 $n$ 个数，$m$ 个条件

每个数有两种类型，只能选择其中一种类型

每组条件包含两个，每个要求一种类型的数字

问这 $n$ 个数能不能符合所有的条件


## Solution

问所有数字能否满足所有的条件，显然是适定性问题

首先要明确一点，每组的条件至少满足一个，也就是说可以全部满足

但要想让答案最优，选择满足其中一个就好，因为这样能用更少的数字满足更多的条件

那每次两个条件满足其一，显然选择 2-SAT 求解

考虑如何建边

由于题目中有 每种材料只能做一种菜式 的限制，所以我们对于每组条件的每一个，向另一种条件的对立事件建边

假设 $a,b$ 处于同一组条件，$A,B$ 分别是他们的另一种类型

那我们建有向边 $(a,B)$，$(b,A)$，表示选择 $a$ 必须选择 $B$，选择 $b$ 必须选择 $A$，同时满足上面的最优性说明

之后跑强连通分量，判断在同一个 SCC 内是，否有两个条件处于同一组，无则成立，有则不成立

## Code
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#define maxn 100100
#define rr register 
#define INF 0x3f3f3f3f
//#define int long long
#define debug cout<<"lkp ak ioi"<<endl

using namespace std;

string s1,s2;
bool vis[maxn],flag;
int k,n,m,top,tot,t,cnt; 
int low[maxn],head[maxn],dfn[maxn],num[maxn],zhan[maxn];
struct edge{int fr,to,nxt;}e[maxn<<1];

inline int read(){
    int s=0,w=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') s=(s<<1)+(s<<3)+ch-'0',ch=getchar();
    return s*w;
}

void add(int fr,int to){
    e[++tot].to=to;e[tot].fr=fr;
    e[tot].nxt=head[fr];head[fr]=tot;
}

int Turn(string s){
    int ans=0;
    for(int i=1;i<s.length();i++)
	ans*=10,ans+=s[i]-'0';	
    if(s[0]=='h') return ans;
    return ans+n;
}

int No(string s){
    int ans=0;
    for(int i=1;i<s.length();i++)
        ans*=10,ans+=s[i]-'0';	
    if(s[0]=='h') return ans+n;
    return ans;
}

void clear(){
    tot=top=t=cnt=flag=0;
    memset(dfn,0,sizeof dfn);
    memset(low,0,sizeof low);
    memset(num,0,sizeof num);
    memset(vis,0,sizeof vis);
    memset(head,0,sizeof head);
}

void tarjan(int u){
    dfn[u]=low[u]=++cnt;
    vis[u]=1;zhan[++top]=u;
    for(int i=head[u];i;i=e[i].nxt){
        int to=e[i].to;
        if(!dfn[to]) tarjan(to),low[u]=min(low[u],low[to]);
        else if(vis[to]) low[u]=min(low[u],dfn[to]);
    }
    if(dfn[u]==low[u]){
        int pre=zhan[top--];
        num[pre]=++t;vis[pre]=0;
        while(pre!=u){
            pre=zhan[top--];
            num[pre]=t;vis[pre]=0;
        }
    }
}

int main(){
    k=read();
    while(k--){
        clear();n=read();m=read();
        for(int i=1;i<=m;i++){
            cin>>s1>>s2;
            add(Turn(s1),No(s2));
            add(Turn(s2),No(s1));
        }
        for(int i=1;i<=n*2;i++)if(!dfn[i])tarjan(i); 
        for(int i=1;i<=n;i++)if(num[i]==num[i+n]){printf("BAD\n");flag=1;break;}
        if(!flag) printf("GOOD\n");
    }
    return 0;
} 
```


---

## 作者：Suzt_ilymtics (赞：4)

## 写在前面

~~不会吧不会吧，这么裸的2-SAT都看不出来？~~ 经验题

## Solution

### 2-SAT处理

关于什么是[2-SAT](https://oi-wiki.org/graph/2-sat/)，详见Oiwiki

简单来说，2-SAT问题的形式是给一堆条件，每个条件中有两个小条件，不过只需要满足其中一种

题目中说评委的两个条件只需要满足一个即可，然后每种材料又有满式和汉式两种选择

这不显然让我们打2-SAT？~~可能也有其他神仙做法~~

而2-SAT主要考察建图这一块，我们用 $0 \sim n$ 表示满式，用 $n+1 \sim 2n$ 表示汉式，用 $x^{-1}$ 表示 $x$ 的另一种菜式

那么对于任意一个条件 $(a_i,b_i)$，

- 首先让我们满足 $a_i$ 而不满足 $b_i$ ，那就从 $a_i$ 向 $b_i^{-1}$ 连一条边

- 然后让我们满足 $b_i$ 而不满足 $a_i$ ，那就从 $b_i$ 向 $a_i^{-1}$ 连一条边

~~（别搞混了调半天）~~

### 字符串处理

暴力处理即可，判断第一个字符确定满式还是汉式

扫一遍字符串取出是第几号菜，然后按上面的方式加边

### 答案判断

用强连通分量缩点

缩点后，如果存在同一菜品出现在同一强联通分量里，那就不能满足

否则就可以满足

大体思路就这些，看代码吧

## Code

```cpp
/*
Work by: Suzt_ilymics
Knowledge: ??
Time: O(??)
*/
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define LL long long
#define orz cout<<"lkp AK IOI!"<<endl

using namespace std;
const int MAXN = 1e5+5;
const int INF = 1e9+7;
const int mod = 1e9+7;

struct edge{
	int to, nxt;
}e[MAXN << 1];
int head[MAXN], num_edge = 0;

int T, n, m;
int dfn[MAXN], low[MAXN], cnt = 0, stc[MAXN], sc = 0;
int num[MAXN], t = 0;
bool vis[MAXN];

int read(){
	int s = 0, f = 0;
	char ch = getchar();
	while(!isdigit(ch))  f |= (ch == '-'), ch = getchar();
	while(isdigit(ch)) s = (s << 1) + (s << 3) + ch - '0' , ch = getchar();
	return f ? -s : s;
}

void add_edge(int from, int to){ e[++num_edge] = (edge){to, head[from]}, head[from] = num_edge; }

void tarjan(int u){
	stc[++sc] = u, dfn[u] = low[u] = ++cnt, vis[u] = true;
	for(int i = head[u]; i; i = e[i].nxt){
		int v = e[i].to;
		if(!dfn[v]){
			tarjan(v), low[u] = min(low[u], low[v]);
		}
		else if(vis[v]) low[u] = min(low[u], dfn[v]);
	}
	if(low[u] == dfn[u]){
		int pre; ++t;
		do{
			pre = stc[sc--];
			vis[pre] = false;
			num[pre] = t;
		}while(pre != u);
	}
}

int main()
{
	T = read();
	while(T--){
		memset(head, 0, sizeof head);
		memset(vis, false, sizeof vis);
		memset(dfn, 0, sizeof dfn);
		num_edge = t = sc = cnt = 0;
		n = read(), m = read();
		char u[9], v[9];
		for(int i = 1; i <= m; ++i){
//			top = 0;
//			while(true){
//				ch = getchar();
////				cout<<ch<<endl;
//				if(ch == ' ') break;
//				else u[++top] = ch;
//			}
//			top = 0;
//			while(true){
//				ch = getchar();
//				if(ch == '\n') break;
//				else v[++top] = ch;
//				cout<<ch<<" ";
//			}
			cin >>(u + 1)>>(v + 1);
//			cout<<(u + 1)<<" "<<(v + 1)<<endl;;
			int u_ = 0, v_ = 0;
			for(int j = 2; j <= (int)strlen(u + 1); ++j) u_ = (u_ << 1) + (u_ << 3) + (int)(u[j] ^ 48);
			for(int j = 2; j <= (int)strlen(v + 1); ++j) v_ = (v_ << 1) + (v_ << 3) + (int)(v[j] ^ 48);
			if(u[1] == 'm' && v[1] == 'm') add_edge(u_, v_ + n), add_edge(v_, u_ + n);	
			if(u[1] == 'h' && v[1] == 'm') add_edge(u_ + n, v_ + n), add_edge(v_, u_);
			if(u[1] == 'm' && v[1] == 'h') add_edge(u_, v_), add_edge(v_ + n, u_ + n);
			if(u[1] == 'h' && v[1] == 'h') add_edge(u_ + n, v_), add_edge(v_ + n, u_);
		}
		for(int i = 1; i <= 2 * n; ++i){
			if(!dfn[i]) tarjan(i);
		}
		int flag = false;
		for(int i = 1;  i <= n; ++i){
			if(num[i] == num[i + n]){
				flag = true;
			}
		}
		if(flag) printf("BAD\n");
		else printf("GOOD\n");
	}
	return 0;
}
```

如果有什么问题，请在评论区指正

---

## 作者：HansLimon (赞：4)

# $2-SAT$的模板
## \>1.1
在说及实现之前，让我们来理解什么是**2-SAT**，已经知晓的可以跳至**1.2**

现在我们有6个布尔变量 $a,b,c,d,e,f$ ，现在给出如下关系：

- 若 $a$ 的值为0，则 $b$ 必须为1
- 若 $c$ 的值为1，则 $d$ 必须为1，且反之成立(即若 $d$ 的值为1，则 $c$ 必须为1，下同)
- 若 $e$ 的值为1，则 $f$ 必须为0
- 若 $a$ 的值为1，则 $e$ 必须为0，且反之成立
- 若 $d$ 的值为1，则 $e$ 必须为1，且反之成立

请给 $a$~$f$ 合理的值使得上述条件成立。无需多加思考，自然能发现一组合理的 a~f 为 0,1,0,0,0,1

但如果变量有30个，要求也不再仅仅是这5个。自然就要困难许多。

**我们可以考虑借助图的性质来达到这些要求**。

比如 **_对于编号为1~10的有着不同关系的布尔变量，我们可以考虑建一个有20个点的图。其中，点1~10用于对应上述变量为1的情况，点11~20用于对应上述变量为0的情况。_** 将每一个关系连接的两个变量之间建一条单向边，比如说：

![TJ-WinterVacation 1](https://s2.ax1x.com/2020/01/20/1ixenP.png)

这里点1对应变量1为1时，点12对应变量2为0时。

单项边由点1指向点12，表示“点1成立时，点12成立”。

也就表达了图中文字的意思。

## \>1.2
现在开始说2-SAT的具体实现，已经知晓的请跳至1.3以了解本题思路。

首先，我们需要把变量表示为点，两两间的关系表示为单向边。

假使我们的输入格式为 $int1$ $int2$ $int3$ $int4$ ，分别 表示$int1$为$int2$时，$int3$必须为$int4$。

**这里仍以1.1加斜部分为例作讲解**

那么我们可以使用邻接表这样操作：

```cpp
struct edges{
	int v, next;
}edge[27];//10个变量，对应20个点

inline void add_edge(int u, int v){//邻接表的操作，不再赘述
	edge[++ cnt] = (edges){v, first[u]};
	first[u] = cnt;
}
void inst2edge(){
	register int x, y, a, b;
	scanf("%d %d %d %d", &x, &y, &a, &b);//x为y时，a必须为b
	add_edge(y?x:x + 10, b?a:a + 10);
    	//因为是布尔变量，仅有两值，因此采用三步运算符
}
```

很好理解，现在图建完了，怎么做呢？

首先，我们需要满足**所有的**条件。其次，我们知道对于任意变量$i$而言，点$i$和$i + 10$不能被这些条件(也就是边)所置于同一个连通块。很快能想到，我们能$Tarjan$对点染色。然后判定点$i$和点$i + 10$颜色是否相同。若相同，则无法满足，反之则能满足。若需要输出一组合理的解，我们只需要把这一颜色的点对应的值返回来，而没被染上这个颜色的，就去任意值。

由于$Tarjan$实现不难，因此不作讲解。

## \>1.3
现在，看到题目。我们能够毫不费力的想到把满式、汉式作为布尔值的两种表达。

然后每个评委的要求可以被看作是“或”的表达，因此转为“必”的表达。

- 比如说：评审一要求的是m1或h7，那么我们可以转化为h1时必h7，和m7时必m1

注意建边时单向边。因为是A时B成立而非B时A成立。

这样我们就建好了图。使用Tarjan对所有点染色，查看是否存在对于任意的食材i，hi和mi有着一样的颜色。若有，则为BAD，反之则为GOOD。

额外的，为了方便读入，我给出了如下代码：

```cpp
inline bool SP_read(int &goal){//对快读稍加改动
	goal = 0;
	register char now;register bool state;//state表示m或h，这里我选用的是h为true
	while (now = getchar(), now != 'h' && now != 'm')continue;//吃掉所有的其他输入
	state = now == 'h';
	while (now = getchar(), now < '0' || now > '9')continue;//这主要是为了避免输入不规范
	while ('0' <= now && now <= '9'){
		goal = (goal<<1) + (goal<<3) + (now^48);//逐步赋值
		now = getchar();
	}
	return state;
}
```

最后，注意有多组数据，你需要初始化。

---

## 作者：PragmaGCC (赞：3)

比较裸的 2-SAT 的模板，建完图这题基本上就结束了

把 汉/满 看作布尔值。

考虑一组 $a, b$，表示 $a$ 或 $b$ 中必须有一个成立。

那么，我们可以得到：

- 若不选 $b$ 选 $a$ ，则必选 $b'$ 
- 若不选 $a$ 选 $b$ ，则必选 $a'$

其中 $x'$表示 `!x` ，即 非x 。

我们可以令 x 为满式， x + n 为汉式 ，可以建立一个 2-SAT 模型。对根据上面两个原则建**单向边**

最后，如果同一个材料的“不同做法”在同一个 SCC 中，就输出`BAD` ， 否则 `GOOD` 。

```cpp
#include <cstdio>
#include <cstring>
#define min(x, y) x < y ? x : y
using namespace std;
const int N = 210, M = 2010;
int T, n, m;
struct Edge { //基本链式前向星
    int to, next;
} e[M];
int head[N], ecnt;
void addedge(int from, int to) {
    e[++ecnt] = (Edge){to, head[from]};
    head[from] = ecnt;
}

int read(char *opt) {//处理读入的材料编号
    int res = 0;
    int i = 1;
    while (opt[i] >= '0' && opt[i] <= '9') {
        res = res * 10 + opt[i] - '0';
        i++;
    }
    return res;
}
//tarjan板子
int dfn[N], low[N], color[N], tt, scc, top, sta[N];
bool ins[N];
void tarjan(int u) {
    dfn[u] = low[u] = ++tt;
    sta[++top] = u;
    ins[u] = 1;
    for (int i = head[u]; i; i = e[i].next) {
        const int v = e[i].to;
        if (!dfn[v]) {
            tarjan(v);
            low[u] = min(low[u], low[v]);
        } else if (ins[v])
            low[u] = min(low[u], dfn[v]);
    }
    if (low[u] == dfn[u]) {
        int tp;
        scc++;
        do {
            tp = sta[top];
            top--;
            ins[tp] = 0;
            color[tp] = scc;
        } while (tp != u);
    }
}

void solve() {
    //记得初始化
    ecnt = tt = scc = 0;
    memset(head, 0, sizeof(head));
    memset(color, 0, sizeof(color));
    memset(low, 0, sizeof(low));
    memset(dfn, 0, sizeof(dfn));
    memset(ins, 0, sizeof(ins));
    bool NaOH_Frog_AK_IOI = 0;
    scanf("%d%d", &n, &m);
    for (int x = 1; x <= m; x++) {
        char opt[5], opt2[5];
        scanf("%s%s", opt, opt2);
        int i = read(opt), j = read(opt2);
        // cout << x << ' ' << y << endl;
        if (opt[0] == 'm') {
            if (opt2[0] == 'm')
                addedge(i + n, j), addedge(j + n, i);
            else
                addedge(i + n, j + n), addedge(j, i);
        } else {
            if (opt2[0] == 'm')
                addedge(i, j), addedge(j + n, i + n);
            else
                addedge(i, j + n), addedge(j, i + n);
        }
    }
    for (int i = 1; i <= n << 1; i++)
        if (!dfn[i])
            tarjan(i);
    for (int i = 1; i <= n; i++) {
        if (color[i] == color[i + n]) {//两种做法在同一个 SCC 里
            NaOH_Frog_AK_IOI = 1;
            break;
        }
    }
    if (NaOH_Frog_AK_IOI)
        printf("BAD\n");
    else
        printf("GOOD\n");
}
int main() {
    scanf("%d", &T);
    while (T--)
        solve();
    return 0;
}
```

---

## 作者：LevenKoko (赞：3)

$$\Large\href{https://www.cnblogs.com/zhenglw/p/11627289.html}{\textcolor{red}{My Blog}}$$


## 显然是2-SAT的题目


### 很多题解写的好烦啊...也不是烦，就是很复杂，看的不明白，哪个点对应的哪个序号很容易弄错


------------


### 所以这里建议开一个数组表示当前这个点选或者不选的编号，这样之后自己理思路也会清楚一点


------------


~~然而我调了一个小时才发现我是Tarjan写错了......~~

 

------------


这道题对于每一个菜分两种情况讨论，每一种情况又有选和不选两种方案

所以相当于每一个菜可以拆成4个点 
```

1.    做法M-选

2.    做法M-不选

3.    做法H-选

4.    做法H-不选

 ```

显然题目里给的条件是**或**，但是不只是有题目里给的条件，还有**隐含条件**：一道菜只能有一种做法！

然后按照2-sat的套路就好了

代码里bb[i][j][k]数组表示当前是第i道菜，做法是j:1/2，选或者不选是k:0/1

这样之后加边的时候会很简洁明了


```cpp
#include<bits/stdc++.h>
#define writeln(x)  write(x),puts("")
#define writep(x)   write(x),putchar(' ')
using namespace std;
inline int read(){
    int ans=0,f=1;char chr=getchar();
    while(!isdigit(chr)){if(chr=='-') f=-1;chr=getchar();}
    while(isdigit(chr)){ans=(ans<<3)+(ans<<1)+chr-48;chr=getchar();}
    return ans*f;
}void write(int x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}const int M = 2e4+5;
int head[M],nxt[M],ver[M],tot,T,n,m,bb[M][3][3],dfn[M],low[M],ins[M],sta[M],top,color,col[M];
char s1[M],s2[M];
struct Judge{int type[2],x[2];}J[M];//裁判给的条件
inline void add(int x,int y){ver[++tot]=y,nxt[tot]=head[x],head[x]=tot;}
void Tarjan(int x){
    dfn[x]=low[x]=++T;ins[x]=1;sta[top++]=x;
    for(int i=head[x];i;i=nxt[i]){
        if(!dfn[ver[i]])Tarjan(ver[i]),low[x]=min(low[x],low[ver[i]]);
        else if(ins[ver[i]]==1) low[x]=min(low[x],dfn[ver[i]]);
    }if(low[x]==dfn[x]){++color;
        do{    col[sta[--top]]=color;
            ins[sta[top]]=-1;
        }while(sta[top]!=x);
    }return;
}inline void Init(){
    memset(low,0,sizeof(low)),memset(dfn,0,sizeof(dfn)),memset(ins,0,sizeof(ins));
    memset(col,0,sizeof(col)),memset(head,0,sizeof(head));tot=T=color=0;
    n=read(),m=read();
    for(int i=1;i<=m;i++){
        scanf("%s%s",s1,s2);
        int l1=strlen(s1),l2=strlen(s2);
        if(s1[0]=='m')J[i].type[0]=1;else J[i].type[0]=2;
        if(s2[0]=='m')J[i].type[1]=1;else J[i].type[1]=2;
        int p=1,ans=0;
        while(isdigit(s1[p])&&p<=l1){ans=(ans<<3)+(ans<<1)+s1[p]-48;++p;}
        J[i].x[0]=ans;p=1,ans=0;
        while(isdigit(s2[p])&&p<=l2){ans=(ans<<3)+(ans<<1)+s2[p]-48;++p;}
        J[i].x[1]=ans;
    }return;//条件处理
}inline void Make_Graph(){
    for(int i=1;i<=n;i++)bb[i][1][1]=i,bb[i][1][0]=n+i,bb[i][2][1]=2*n+i,bb[i][2][0]=3*n+i;//预处理每种情况对应的点号
    for(int i=1;i<=m;i++){
        int x=J[i].type[0],a=J[i].x[0],y=J[i].type[1],b=J[i].x[1];
        add(bb[a][x][0],bb[b][y][1]),add(bb[b][y][0],bb[a][x][1]);//题目给的条件
        add(bb[i][1][1],bb[i][2][0]),add(bb[i][2][1],bb[i][1][0]);//隐含条件
    }
}inline void Solve(){
    for(int i=1;i<=n*4;i++)if(!dfn[i])Tarjan(i);
    for(int i=1;i<=n;i++)if(col[bb[i][1][0]]==col[bb[i][1][1]]||col[bb[i][2][1]]==col[bb[i][2][0]])return puts("BAD"),void();
    puts("GOOD");//2-SAT套路操作
}int main(){
    int T=read();
    while(T--)Init(),Make_Graph(),Solve();
    return 0;
}
```

---

## 作者：Sangber (赞：2)

#### 前言
由于蒟蒻才刚开始学 $\text{2-SAT}$，所以题解中有的地方可能不够精炼，望多包涵！  
### 题目描述
题目意思很简单，标准的$\text{2-SAT}$问题模型。那么我们就先来介绍一下 $\text{2-SAT}$ （以下是个人的小小概括）  
$\text{2-SAT}$ 问题，抽象化一下，是这样的：  
给出 $n$ 个布尔变量 $\{x_n\}$，以及 $m$ 个命题 $(a,aa,b,bb)$，一个命题成立的条件是$[x_a=aa]\lor[x_b=bb]$  
现在就是要判断是否一种方案，将$\{x_n\}$中的每个元素赋一个值，使所有的$m$个命题成立  
对于这种问题，我们用一下方法来建立图的模型：  
对于 $n$ 个不同变量 $x$，我们将其拆成两个点，分别表示 $x$ 为真和 $x$ 为假（可以用 $i$ 表示 $x_i$ 为真，$i+n$ 表示 $x_i$ 为假）  

接下来对于每一条有向边 $(a,b)$，我们赋予它这样的意义：若 $a$ 应该被满足，则 $b$ 也必须被满足  

这样一来，我们就可以用如下的方法判定有无解：

+ 有解的情况：$\forall\ i\in n$, $i$ 和 $i+n$ 不属于同一个强连通分量。
+ 无解的情况：$\exists\ i\in n$, $i$ 和 $i+n$ 属于同一个强连通分量。

因为按照我们上面的建边方法，属于同一个强连通分量的两个点他们所代表的命题是要同时为真的。  
而因为同一个布尔变量 $x$ 不会同时有两种值，所以以上判断方法的正确性是显然的。  
那么我们就只需建好图，跑一遍 $\text{Tarjan}$ 再按照上述方法判断即可。  
那么，接下来就是最重要的一步：如何建图？  
其实这并不难，只要能抽象出 $\{x_n\}$ 和 $m$ 个命题就好，以这道题为例，加深一下理解。

----
### 基本思路
我们把$n$样食材抽象成$\{x_n\}$，第 $i$ 样食材做成汉式表示 $x_i$ 为真（点 $i$），反之表示 $x_i$ 为假（点 $i+n$）  
然后对于每一位评审的需求，也类似地按照上面的方法抽象一下  
然后对于每一项需求给出的两个命题 $p,q$，我们连两条边 $(\lnot p,q)$ 和 $(\lnot q, p)$  
（至于这里的 $p$ 和 $q$是什么，可以自己思考一下）

----
### 细节注意事项
+ 由于我们的 $n$ 样食材会被拆成两个点，所以点的空间要开两倍。  
+ 由于我们的 $m$ 项需求会产生两条边，所以边的空间也要开两倍。
+ 每一次初始化时，如果用$\text{for}$循环清空数组，千万要注意枚举的上界（见上两条）。

----
### 参考代码
可能我写的不是很好，没有看明白的话可以结合我的代码理解~~给个好评吧啊啊啊~~
```cpp
/*--------------------------------
  Code name: meal.cpp
  Author: The Ace Bee
  This code is made by The Ace Bee
--------------------------------*/
#include <cstdio>
#include <cstring>
#define rg register
#define fileopen(x)								\
	freopen(x".in", "r", stdin);				\
	freopen(x".out", "w", stdout);
#define fileclose								\
	fclose(stdin);								\
	fclose(stdout);
const int MAXN = 233;
const int MAXM = 2333;
inline int min(int a, int b) { return a < b ? a : b; }
inline int read() {
	int s = 0; bool f = false; char c = getchar();
	while (c < '0' || c > '9') f |= (c == '-'), c = getchar();
	while (c >= '0' && c <= '9') s = (s << 3) + (s << 1) + (c ^ 48), c = getchar();
	return f ? -s : s;
}
int tot, head[MAXN], nxt[MAXM], ver[MAXM];
inline void Add_edge(int u, int v)
{ nxt[++tot] = head[u], head[u] = tot, ver[tot] = v; }
int n, num, dfn[MAXN], low[MAXN];
int st[MAXN], top, co[MAXN], col;
inline void tarjan(int u) {
	dfn[u] = low[u] = ++num, st[++top] = u;
	for (rg int v, i = head[u]; i; i = nxt[i]) {
		if (!dfn[v = ver[i]])
			tarjan(v), low[u] = min(low[u], low[v]);
		else
			if (!co[v]) low[u] = min(low[u], dfn[v]);
	}
	if (dfn[u] == low[u]) {
		++col;
		do co[st[top]] = col, --top;
		while (st[top + 1] != u);
	}
}
inline void init() {
	tot = col = num = top = 0;
	memset(co, 0, sizeof co);
	memset(dfn, 0, sizeof dfn);
	memset(low, 0, sizeof low);
	memset(head, 0, sizeof head);
}
int main() {
//	fileopen("meal");
	char sa[10], sb[10];
	for (rg int T = read(); T; --T) {
		init();
		int n = read();
		for (rg int m = read(); m; --m) {
			scanf("%s%s", sa, sb);
			int a = 0, lena = strlen(sa);
			for (rg int i = 1; i < lena; ++i)
				a = (a << 3) + (a << 1) + (sa[i] ^ 48);
			int b = 0, lenb = strlen(sb);
			for (rg int i = 1; i < lenb; ++i)
				b = (b << 3) + (b << 1) + (sb[i] ^ 48);
			if (sa[0] == 'h' && sb[0] == 'h')
				Add_edge(a + n, b), Add_edge(b + n, a);
			else if (sa[0] == 'h' && sb[0] == 'm')
				Add_edge(a + n, b + n), Add_edge(b, a);
			else if (sa[0] == 'm' && sb[0] == 'h')
				Add_edge(a, b), Add_edge(b + n, a + n);
			else if (sa[0] == 'm' && sb[0] == 'm')
				Add_edge(a, b + n), Add_edge(b, a + n);
		}
		for (rg int i = 1; i <= n << 1; ++i)
			if (!dfn[i]) tarjan(i);
		int flag = 1;
		for (rg int i = 1; i <= n; ++i)
			if (co[i] == co[i + n]) { flag = 0; break; }
		puts(flag ? "GOOD" : "BAD");
	}
//	fileclose;
	return 0;
}

```

**完结撒花 $qwq$**

---

## 作者：ff_666 (赞：2)

### 这题题解好神奇啊。。
难道不就是最裸的2-SAT问题吗~~（虽然我数组开小崩了N次）~~

对于每个点，拆成$2i$与$2i+1$分别表示$x_i$为1/0（汉式/满式）
那么每个条件就是相当于
> #### $x_i$为1或$x_j$为1

那么

> 不选$x_i$选$x_{i}^{'}$就必选$x_j$

> 不选$x_j$选$x_{j}^{'}$就必选$x_i$

然后套2-SAT模板就好了

```java
#include<bits/stdc++.h>
#define gt() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++)
#define pt(ch) (Top<1000000?St[Top++]=ch:(Out(),St[(Top=0)++]=ch))
#define Out() (fwrite(St,1,Top,stdout))
using namespace std;
int Top;static char St[1000000],buf[1000000],*p1=buf,*p2=buf;
const int maxn=205,maxE=(2e3)+5;
int T;
int read(){
	int ret=0;char ch=gt();
	while(ch<'0'||ch>'9') ch=gt();
	while(ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=gt();
	return ret;
}
char red(){char ch=gt();while(ch!='m'&&ch!='h') ch=gt();return ch;}
void write(int x){if(x<0) x=-x,pt('-');if(x>9) write(x/10);pt(x%10+'0');}
struct TwoSAT{
	int N,M,NN,top,stk[maxn];bool vis[maxn];
	int tot,lnk[maxn],nxt[maxE],son[maxE];
	void add_e(int x,int y){son[++tot]=y,nxt[tot]=lnk[x],lnk[x]=tot;}
	void inti(){
		N=read(),M=read(),NN=N<<1;
		for(int i=1;i<=NN+1;i++) lnk[i]=vis[i]=0;tot=0;
		while(M--){
			char x_=red();int x=(read()<<1)|(x_=='h');
			char y_=red();int y=(read()<<1)|(y_=='h');
			add_e(x^1,y),add_e(y^1,x);
		}
	}
	bool Dfs(int x){
		if(vis[x]) return 1;
		if(vis[x^1]) return 0;
		vis[x]=1,stk[++top]=x;
		for(int j=lnk[x];j;j=nxt[j]) if(!Dfs(son[j])) return 0;
		return 1;
	}
	void solve(){
		for(int i=2;i<=NN;i+=2)if(!vis[i]&&!vis[i^1]){
			top=0;
			if(!Dfs(i)){
				while(top) vis[stk[top--]]=0;
				if(!Dfs(i^1)) return (void)(puts("BAD"));
			}
		}
		return (void)(puts("GOOD"));
	}
}P;
int main(){
	#ifdef hhh
	freopen("data.in","r",stdin);
	freopen("data.out","w",stdout);
	#endif
	T=read();while(T--) P.inti(),P.solve();
    return 0;
}
```


---

## 作者：Yaha (赞：1)

### $2-SAT$

好裸......

题意： $n$ 个点，每个点两种决策 $0$ 和 $1$ ，需要满足 $m$ 条限制，问是否有解。

 $m$ 条限制，形如：$(i,p,j,q)$ ，表示： $i$ 为 $p$ 或者 $j$ 为 $q$ 。其中 $p,q\in \{0,1\}$。
 


转化为：若 $i$ 选 $1-p$ ，则 $j$ 必选 $q$ ；若 $j$ 选 $1-q$ ， $i$ 必选 $p$ ，然后就是板子了。

代码：

```cpp
#include<bits/stdc++.h>

using namespace std;

const int amou=2e5+90;

int n,m;
int dfn[amou],low[amou],timestamp;
int stac[amou],top,in_stac[amou];
int col[amou],scc_cnt;
int nxt[amou],head[amou],ver[amou],cnt;

void add(int a,int b){
	nxt[++cnt]=head[a],head[a]=cnt,ver[cnt]=b;
}

void init(){
	cnt=scc_cnt=timestamp=top=0;
	memset(head,0,sizeof head);
	memset(nxt,0,sizeof nxt);
	memset(dfn,0,sizeof dfn);
}

int opp(int i){
	if(i>n) return i-n;
	return i+n;
}

void Tarjan(int i){
	dfn[i]=low[i]=++timestamp;
	stac[++top]=i,in_stac[i]=1;
	for(int io=head[i];io;io=nxt[io])
	{
		int v=ver[io];
		if(!dfn[v])
		{
			Tarjan(v);
			low[i]=min(low[i],low[v]);
		}
		else if(in_stac[v]) low[i]=min(low[i],dfn[v]);
	}
	if(dfn[i]==low[i])
	{
		scc_cnt++;
		int p;
		do
		{
			p=stac[top--];
			in_stac[p]=0;
			col[p]=scc_cnt;
		}while(p!=i);
	}
}

int main(){
	int t;
	scanf("%d",&t);
	while(t--)
	{
		init();
		scanf("%d%d",&n,&m);
		for(int i=1;i<=m;i++)
		{
			char a,c;int b,d;
			cin>>a>>b>>c>>d;//m为决策0，编号1~n；h为决策1，编号n+1~2n
			if(a=='h') b+=n;
			if(c=='h') d+=n;
			add(b,opp(d));add(d,opp(b));
		}
		for(int i=1;i<=2*n;i++)
			if(!dfn[i]) Tarjan(i);
		bool fl=0;
		for(int i=1;i<=n;i++)
			if(col[i]==col[i+n]) fl=1;
		if(fl) printf("BAD\n");
		else printf("GOOD\n");
	}
	
	return 0;
}
```


---

## 作者：SUNCHAOYI (赞：1)

说白了，这就是一个 $\texttt{2-SAT}$ 的模板题，大致可以分成三个部分。

首先是对于数据的处理。每一个评审员的输入都是两个**字符串**，而每个字符串都是由字母 $h/m$ 再加上材料编号组成的。因此只需要将其用 `%s` 读入后分开处理就行了。

然后就是建图的过程。我们可以把汉与满分别看成 $0$ 和 $1$，然后根据两个条件只要满足其一(也就是**或**)的原则进行**建图**。举个例子，若 $a,b$ 两个数的值均为 $1$，也就是说 $a,b$ 至少有一个数的值为 $1$。所以我们可以确定建出的两条边是 $a = 0$ 推出 $b = 1$ 与 $b = 0$ 推出 $a = 1$。

最后就是使用 $\texttt{tarjan}$ 算法求出**强连通分量**，然后判断在一个强连通分量中是否存在一种材料的值既有 $0$ 又有 $1$。若出现这种状态，就说明该材料既需要做成汉式，也需要做成满式，因此条件存在矛盾，所以这种情况要输出的是 `BAD`；否则输出 `GOOD`。

代码如下：

```
#include <iostream>
#include <cstdio>
#include <stack>
#include <cstring>
#define init(x) memset (x,0,sizeof (x))
using namespace std;
const int MAX = 1e3 + 5;
stack <int> s;
bool ok;
int n,m,t,cnt,times,scc_cnt;
int head[MAX << 1],nxt[MAX << 1],to[MAX << 1],dfn[MAX << 1],low[MAX << 1],scc[MAX << 1];
void pre ();
void build (int num1,bool ty1,int num2,bool ty2);
void _add (int u,int v);
void tarjan (int u);
int main ()
{
	//freopen (".in","r",stdin);
	//freopen (".out","w",stdout);
	scanf ("%d",&t);
	while (t--)
	{
		pre ();//初始化很重要
		scanf ("%d%d",&n,&m);
		//汉 0 满 1 
		for (int i = 1;i <= m;++i)
		{
			char da[1000],db[1000];
			int a = 0,b,c = 0,d;
			scanf ("%s %s",da,db);
			if (da[0] == 'h') b = 0;
			else b = 1;
			if (db[0] == 'h') d = 0;
			else d = 1;
			for (int i = 1;i < strlen (da);++i) a = a * 10 + da[i] - '0';
			for (int i = 1;i < strlen (db);++i) c = c * 10 + db[i] - '0';
			build (a,b,c,d);
		} 
		for (int i = 1;i <= 2 * n;++i)	
			if (!dfn[i]) tarjan (i);
		for (int i = 1;i <= n;++i)//是否存在矛盾
		{
			if (scc[i] == scc[i + n])
			{
				ok = 0;
				break;
			}
		}
		if (ok) puts ("GOOD");
		else puts ("BAD"); 
	}
	return 0;
}
void pre ()
{
	cnt = times = scc_cnt = 0;
	ok = 1;
	init (head);init (nxt);init (to);
	init (dfn);init (low);init (scc);
}
void build (int num1,bool ty1,int num2,bool ty2)//建图过程
{
	if (!ty1 && !ty2)// the first one is false or the second one is false
	{
		_add (num1,num2 + n);// we know the first one is true so we can infer the second one is false
		_add (num2,num1 + n);
	}
	if (!ty1 && ty2)// the first one is false or the second one is true
	{
		_add (num1,num2);// we know the first one is true so we can infer the second one is true
		_add (num2 + n,num1 + n);
	}
	if (ty1 && !ty2)// the first one is true or the second one is false
	{
		_add (num1 + n,num2 + n);// we know the first one is false so we can infer the second one is false
		_add (num2,num1);
	}
	if (ty1 && ty2)// the first one is true or the second one is true
	{
		_add (num1 + n,num2);// we know the first one is false so we can infer the second one is true
		_add (num2 + n,num1);
	}
} 
void _add (int u,int v)//连边
{
	to[++cnt] = v;
	nxt[cnt] = head[u];
	head[u] = cnt;
}
void tarjan (int u)//强连通分量
{
	dfn[u] = low[u] = ++times;
	s.push (u);
	for (int i = head[u];i;i = nxt[i])
	{
		int v = to[i];
		if (!dfn[v])
		{
			tarjan (v);
			low[u] = min (low[u],low[v]);
		}
		else if (!scc[v]) low[u] = min (low[u],dfn[v]);
	}
	if (low[u] == dfn[u])
	{
		++scc_cnt;
		while (1)
		{
			int x = s.top ();
			s.pop ();
			scc[x] = scc_cnt;
			if (x == u) break; 
		}
	}
}
```

---

## 作者：FREEH (赞：1)

### 【题目大意】
- 有n种材料，有m个评委，每一个评委都有他的喜好，选手的菜必须含有所有评委的两个喜好之一，否则就算不通过。问会不会出现不可能有人通过的情况。

### 【解题思路】
- 使用2-sat思路。
- 对于每个评委的每个喜好，要么是满要么是汉，那就是选或不选，因此满足2-sat的性质。所以可以对于每个评委的每个喜好如果不满足就要满足另一个喜好，也就是这个喜好的“相反菜”（如果是汉就变满，反之亦然；反正就是不满足喜好）与另一个喜好相连（注意是有向边）。
- 跑一波Floyd。
- 最后如果存在一种材料两种做法（即每种材料的汉和满能相连），那么说不可以；反之则可以。

### 【参考程序】
```cpp
#include <cstdlib>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
using namespace std;

int n,m,n2;
int Map[444][444];
int inv[444];

int read()
{
	char ch=getchar();
	for (;ch!='m'&&ch!='h';ch=getchar());
	char ch2=getchar();
	int t=0;
	for (;ch2>='0'&&ch2<='9';ch2=getchar()) t=t*10-'0'+ch2;
	if (ch=='m') t+=n;
	return t;
}

void work()
{
	int i,j,k,u,v;
	scanf("%d%d",&n,&m);
	n2=n<<1;
	for (i=1;i<=n2;i++)
		for (j=1;j<=n2;j++)
			Map[i][j]=0;
	for (i=1;i<=n;i++)
	{
		inv[i]=i+n;
		inv[i+n]=i;
	}
	for (i=1;i<=m;i++)
	{
		u=read(); v=read();
		Map[inv[u]][v]=1;
		Map[inv[v]][u]=1;
	}
	for (k=1;k<=n2;k++)
		for (i=1;i<=n2;i++)
			for (j=1;j<=n2;j++)
				if (Map[i][k]&&Map[k][j])
					Map[i][j]=1;
	for (i=1;i<=n;i++)
		if (Map[i+n][i]&&Map[i][i+n])
			break;
	if (i<=n)
		printf("BAD\n");
	else
		printf("GOOD\n");
}

int main()
{
	int t;
	scanf("%d",&t);
	while (t--)
		work();
}
```

---

## 作者：BMTXLRC (赞：0)

## 题目分析

一道很明显 2-SAT 的题。

## 逐步实现

#### Part1：输入

一个英文字母加一个数字，很明显 $\texttt{getchar}$。

```cpp
bool get_char(){
	char ch=getchar();
	while(ch!='m'&&ch!='h') ch=getchar();
	return ch=='m'?true:false;
}
int read(){
	char ch=getchar();
	int s=0;
	while(ch>'9'||ch<'0') ch=getchar();
	while(ch<='9'&&ch>='0') s=(s<<1)+(s<<3)+(ch-'0'),ch=getchar();
	return s;
}
```


#### Part2：建图

满式和汉式相对立，拆成两个点就好。

我给大家推荐一个新的建图方式，比四个 $\texttt{if}$ 简洁（

```cpp
for(register int i=1;i<=m;i++){
	bool u=get_char();int x=read();
	bool v=get_char();int y=read();
	add(x+n*(u&1),y+n*(v^1));
	add(y+n*(v&1),x+n*(u^1));
}
```

**注意邻接表要初始化！**

#### Part3：$\texttt{Tarjan}$

既然是 2-SAT，就打强连通分量。

直接套板子就好（我是手打的封装栈（常数小又适应自己平常的打法））。

```cpp
struct Stack{
	int stack[N],top;
	void push(int x){stack[++top]=x;}
	void pop(){top--;}
	int front(){return stack[top];}
	void init(){memset(stack,0,sizeof(stack)),top=0;}
}st;
void tarjan(int x){
	dfn[x]=low[x]=++tot;
	st.push(x),vis[x]=true;
	for(register int i=head[x];i;i=a[i].nxt){
		int y=a[i].to;
		if(!dfn[y]) tarjan(y),low[x]=min(low[x],low[y]);
		else if(vis[y]) low[x]=min(low[x],dfn[y]);
	}
	if(low[x]==dfn[x]){
		ans++;
		while(1){
			int s=st.front();
			st.pop();
			from[s]=ans;
			vis[s]=false;
			if(s==x) break;
		}
	}
}
```
#### Part4：输出

遍历一遍，如果 $i$ 与 $i+n$ 属于一个强连通分量，就有选手无法通过。

如果没有上述情况，就可以。

**一定要记得多组数据初始化！！**

## 总代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e4+5;
bool vis[N];
int T,n,m,head[N],cnt,tot,ans,from[N],dfn[N],low[N];
struct edge{
	int to,nxt;
	void init(){to=0,nxt=0;}
}a[N];
struct Stack{
	int stack[N],top;
	void push(int x){stack[++top]=x;}
	void pop(){top--;}
	int front(){return stack[top];}
	void init(){memset(stack,0,sizeof(stack)),top=0;}
}st;
void add(int x,int y){
	a[++cnt].to=y;
	a[cnt].nxt=head[x];
	head[x]=cnt;
}
bool get_char(){
	char ch=getchar();
	while(ch!='m'&&ch!='h') ch=getchar();
	return ch=='m'?true:false;
}
int read(){
	char ch=getchar();
	int s=0;
	while(ch>'9'||ch<'0') ch=getchar();
	while(ch<='9'&&ch>='0') s=(s<<1)+(s<<3)+(ch-'0'),ch=getchar();
	return s;
}
void tarjan(int x){
	dfn[x]=low[x]=++tot;
	st.push(x),vis[x]=true;
	for(register int i=head[x];i;i=a[i].nxt){
		int y=a[i].to;
		if(!dfn[y]) tarjan(y),low[x]=min(low[x],low[y]);
		else if(vis[y]) low[x]=min(low[x],dfn[y]);
	}
	if(low[x]==dfn[x]){
		ans++;
		while(1){
			int s=st.front();
			st.pop();
			from[s]=ans;
			vis[s]=false;
			if(s==x) break;
		}
	}
}
void init(){
	st.init();cnt=0,tot=0,ans=0;
	memset(dfn,0,sizeof(dfn));
	memset(low,0,sizeof(low));
	memset(from,0,sizeof(from));
	memset(vis,false,sizeof(vis));
	memset(head,0,sizeof(head));
}
int main(){
	scanf("%d",&T);
	while(T--){
		init();
		scanf("%d %d",&n,&m);
		for(register int i=1;i<=m;i++){
			bool u=get_char();int x=read();
			bool v=get_char();int y=read();
			add(x+n*(u&1),y+n*(v^1));
			add(y+n*(v&1),x+n*(u^1));
		}
		for(register int i=1;i<=2*n;i++) if(!dfn[i]) tarjan(i);
		bool c=false;
		for(register int i=1;i<=n;i++){
			if(from[i]==from[i+n]){
				puts("BAD");
				c=true;
				break;
			}
		}
		if(c==false) puts("GOOD");
		for(register int i=1;i<=cnt;i++) a[i].init();
	}
}
```


---

## 作者：银河AI (赞：0)

### 解题思路

每一种材料有两种状态，满式和汉式。

而且，每个评委会对其中的两个材料做出自己的要求（选择一个状态）

很容易想到 2-SAT。

首先先规定，状态为满式的食材，记作 `1`,状态为汉式的食材，记为 `0`。

从模板[2-SAT 问题](https://www.luogu.com.cn/problem/P4782)入手。

一个评委会对 $x_i$ 和 $x_j$ 这两个食材做出要求。

先判断评委对两个食材的要求是满式还是汉式（即 `0` 或 `1`）

以样例为例：

```
m3 h1
m1 m2
h1 h3
h3 m2
```
我们按模板题的输入方式。

第一个评委： $x_3$  $1$ 或 $x_1$  $0$

第二个评委：  $x_1$  $1$ 或 $x_2$  $1$

第三个评委： $x_1$  $0$ 或 $x_3$  $0$

第四个评委： $x_3$  $0$ 或 $x_2$  $1$

显然这就是一个 2_SAT 模板，直接上板子就好了。

**注意**：因为每种食材有两种状态，所以数组要开二倍空间。

对于无解的情况，就是两种状态在同一个联通块里，输出 `BAD` 就好了。

**记得初始化**

### AC代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e2+1,M=4e4+1;
int k;
int n,m;
struct edge{
	int to,ne;
}e[M];
int adj[N],l;
int dfn[N],low[N],vis[N],st[N],top,bel[N];
int cnt,le,trap;
inline void add(int x,int y){e[++l].to=y,e[l].ne=adj[x],adj[x]=l;}
void dfs(int x){
	dfn[x]=low[x]=++cnt;
	vis[x]=1;
	st[++top]=x;
	for(int i=adj[x];i;i=e[i].ne){
		int y=e[i].to;
		if(!dfn[y]) dfs(y),low[x]=min(low[x],low[y]);
		else if(vis[y]) low[x]=min(low[x],dfn[y]);
	}
	if(low[x]==dfn[x]){
		le++;
		while(top){
			int nx=st[top--];
			vis[nx]=0;
			bel[nx]=le;
			if(nx==x) break;
		}
	}
}
inline int get(){
	char ch=getchar();
	while(ch!='m'&&ch!='h') ch=getchar();
	if(ch=='m') return 1;
	return 0;
}
inline int read(){
	char ch=getchar();int s=0;
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9') s=(s<<1)+(s<<3)+ch-'0',ch=getchar();
	return s; 
}
inline void init(){
	memset(adj,0,sizeof(adj));
	l=cnt=le=trap=0;
	memset(dfn,0,sizeof(dfn));
	memset(vis,0,sizeof(vis));
	memset(bel,0,sizeof(bel));
	memset(st,0,sizeof(st));
}
signed main(){
	scanf("%lld",&k);
	while(k--){
		init();
		scanf("%lld%lld",&n,&m);
		for(int i=1;i<=m;i++){
			int a,b,x,y;
			a=get();//x的状态 
			x=read();
			b=get();//y的状态 
			y=read();
			if(a==1){
				if(b==1) add(x,y+n),add(y,x+n);
				else add(x,y),add(y+n,x+n);
			}
			else{
				if(b==1) add(x+n,y+n),add(y,x);
				else add(x+n,y),add(y+n,x);
			}
		}
		for(int i=1;i<=n<<1;i++) if(!dfn[i]) dfs(i);
		for(int i=1;i<=n;i++) if(bel[i]==bel[i+n]){printf("BAD\n");trap=1;break;}
		if(!trap) printf("GOOD\n");
	}
}

```


---

## 作者：xfrvq (赞：0)

[原题链接](https://www.luogu.com.cn/problem/P4171)

[博客食用](https://www.luogu.com.cn/blog/368107/solution-p4171)

---

**前言**

阅读本文，你需要掌握的算法如下：

+ 图的存储&遍历

+ ***DFS***

~~对没错真就只有这两条~~

---

本题是一道2-SAT裸题

$\to$[2-SAT模板](https://www.luogu.com.cn/problem/P4782)$\gets$

---

1. ***2-SAT*** 介绍

***2-SAT*** 问题指的是**给定一些布尔变量，以及它们的关系（比如 $a$ 为真或 $b$ 为假），要你求出解存不存在，存在就构造出一组解**。

那么我们怎么解决这个问题呢？

~~还真就是dfs~~

---

2. 普通2-SAT解法：

STEP 1：把问题转化到一个图上

我们先建立一个图包含 $2\times n$ 个点，用于存下第 $i$ 个点为 $true$ 或 $false$ 的情况

这里我用 $0 \dots n-1$ 代表 $n$ 个点，第 $i$ 个点的 $false$ 情况对应图里的第 $2 \times i$ 个点，$true$ 情况对应图里的第 $2 \times i + 1$ 个点

这样就可以用 $i$ `^` $1$取到编号一样但真假值与 $i$ 相反的点。

好的，开始建图

以条件 $a$ 为真或 $b$ 为假举例：

+ 如果 $a$ 为真，则 $b$ 必定也为真
+ 如果 $b$ 为假，则 $a$ 必定也为假
- 如果 $a$ 为假，推不出任何东西
- 如果 $b$ 为真，推不出任何东西

那么就应该是：
```cpp
if(!a && !b){
	G[i << 1].push_back(j << 1 | 1);
	G[j << 1].push_back(i << 1 | 1);
} else if(a && !b){
	G[i << 1 | 1].push_back(j << 1 | 1);
	G[j << 1].push_back(i << 1);
} else if(!a && b){
	G[j << 1 | 1].push_back(i << 1 | 1);
	G[i << 1].push_back(j << 1);
} else if(a && b){
	G[i << 1 | 1].push_back(j << 1);
	G[j << 1 | 1].push_back(i << 1);
}
```

---

STEP 2：DFS

DFS的时候，我们开一个 $vis$ 数组标记**图上**第 $i$ 个点是否被标记（标记表示我们暂时选这个点，如果后面发现行不通了就取消标记）

那如果点 $2 \times i$ 被标记了并且点 $2 \times i + 1$ 也被标记了，那么就直接一路取消标记

我们开一个数组装下所有被标记了的点的编号以方便我们后面取消标记

代码（注释在里面）：
```cpp
bool dfs(int u){
	if(vis[u ^ 1]) return false;  // 如果这个点真假值相反的情况被标记了，那么矛盾，不能再DFS下去
	if(vis[u]) return true; // 如果曾经DFS过这个点并且把它标记上了，就不用再DFS下去了，直接反回
	vis[u] = true; // 标记上
	a[len++] = u; // 存入数组
	for(int i = 0;i < G[u].size();++i)
		if(!dfs(G[u][i])) return false; // 任何一个v失败就不能再DFS下去了
	return true;
}
```

---

STEP 3：**2-SAT**函数

我们用一个`_2_SAT`函数来完成操作

代码（注释在里面）：
```cpp
bool _2_SAT(){
	for(int i = 0;i < 2 * n;i += 2){
		if(vis[i] == false && vis[i + 1] == false){ // 如果这个点没有访问过
			len = 0; // DFS前清零
			if(!dfs(i)){ // 如果DFS失败
				while(len > 0) vis[a[--len]] = false; // 沿路清空标记
				if(!dfs(i + 1)) return false; // 这个时候尝试另一种可能，如果还是失败，就彻底失败，不可能存在可行解
			}
		}
	}
	return true;
}
```

---

3. 本题解法

相比起模板题，本题只是建图方式不同，DFS和_2_SAT函数都可以照搬模板。

大概就是把满式看作 $false$ ，汉式看作 $true$

因为这题读入方式实在是太奇怪了，~~字符偏和数字连在一起~~

所以我们用一个getchar()读入字符，再用scanf读入数字

代码：
```cpp
int T;
scanf("%d",&T);
while(T--){
	scanf("%d%d",&n,&m);
	for(int i = 1;i <= m;++i){
		char c1,c2; // 两种菜色的料理方式（'m'或'h'）
		int x1,x2; // 两种菜色所用到的食材编号
		getchar(); // 读入换行
		c1 = getchar();
		scanf("%d",&x1);
		getchar(); // 读入空格
		c2 = getchar();
		scanf("%d",&x2);
		bool v1 = c1 == 'h',v2 = c2 == 'h'; // 将满式看作 false ，汉式看作 true
		--x1,--x2; // 题目要求 1~n，而我们的表示方式为 0~n-1，所以减一
		if(v1 && v2) G[x1 << 1 | 1].push_back(x2 << 1),G[x2 << 1 | 1].push_back(x1 << 1); // 建图和模板题无太大差距
		else if(v1 && !v2) G[x1 << 1 | 1].push_back(x2 << 1 | 1),G[x2 << 1].push_back(x1 << 1);
		else if(!v1 && v2) G[x2 << 1 | 1].push_back(x1 << 1 | 1),G[x1 << 1].push_back(x2 << 1);
		else if(!v1 &&!v2) G[x1 << 1].push_back(x2 << 1 | 1),G[x2 << 1].push_back(x1 << 1 | 1);
	}
}
```

4. 本题代码

```cpp
#include<stdio.h>
#include<string.h>
#include<vector>
std::vector<int> G[401];
int n,m,a[401],len = 0;
bool vis[401];
bool dfs(int u){
	if(vis[u ^ 1]) return false;
	if(vis[u]) return true;
	vis[u] = true;
	a[len++] = u;
	for(int i = 0;i < G[u].size();++i)
		if(!dfs(G[u][i])) return false;
	return true;
}
bool _2_SAT(){
	for(int i = 0;i < 2 * n;i += 2){
		if(vis[i] == false && vis[i + 1] == false){
			len = 0;
			if(!dfs(i)){
				while(len > 0) vis[a[--len]] = false;
				if(!dfs(i + 1)) return false;
			}
		}
	}
	return true;
}
int main(){
	int T;
	scanf("%d",&T);
	while(T--){
		scanf("%d%d",&n,&m);
		for(int i = 1;i <= m;++i){
			getchar();
			char c1 = getchar(),c2;
			int x1,x2;
			scanf("%d",&x1);
			getchar();
			c2 = getchar();
			scanf("%d",&x2);
			bool v1 = c1 == 'h',v2 = c2 == 'h';
			--x1,--x2;
			if(v1 && v2) G[x1 << 1 | 1].push_back(x2 << 1),G[x2 << 1 | 1].push_back(x1 << 1);
			else if(v1 && !v2) G[x1 << 1 | 1].push_back(x2 << 1 | 1),G[x2 << 1].push_back(x1 << 1);
			else if(!v1 && v2) G[x2 << 1 | 1].push_back(x1 << 1 | 1),G[x1 << 1].push_back(x2 << 1);
			else if(!v1 &&!v2) G[x1 << 1].push_back(x2 << 1 | 1),G[x2 << 1].push_back(x1 << 1 | 1);
		}
		if(_2_SAT()) puts("GOOD");
		else puts("BAD");
		for(int i = 0;i <= n;++i) G[i].clear(),vis[i] = false; // 多测记得清空
	}
	return 0;
}
```

---

## 作者：OIerAlbedo (赞：0)

# 前言
如果你学过2-SAT，那你应当会这道题。
# 题意
给你 $ m $ 个约束条件，要你决定 $ n $ 个材料是汉式还是满式，使 $ m $ 个条件都能满足至少一个。
# 思路
将第 $ i $ 道菜选汉式定为 $ i $ ,选满式定为 $ i+n $ ,那么对于评委的要求就可以连边了，具体情况如下。


1. $ i $ 为满式或 $ j $ 为汉式----若 $ i $ 为汉式，则 $ j $ 为汉式；若 $ j $ 为满式则 $ i $ 为满式-----连 $ i $ 与 $ j $ 和 $ j+n $ 与 $ i+n $ 。

2. $ i $ 为满式或 $ j $ 为满式----若 $ i $ 为汉式，则 $ j $ 为满式；若 $ j $ 为汉式则 $ i $ 为满式-----连 $ i $ 与 $ j+n $ 和 $ j $ 与 $ i+n $ 。

3. $ i $ 为汉式或 $ j $ 为汉式----若 $ i $ 为满式，则 $ j $ 为汉式；若 $ j $ 为满式则 $ i $ 为汉式-----连 $ i+n $ 与 $ j $ 和 $ j+n $ 与 $ i $ 。

4. $ i $ 为汉式或 $ j $ 为满式----若 $ i $ 为满式，则 $ j $ 为满式；若 $ j $ 为汉式则 $ i $ 为汉式-----连 $ i+n $ 与 $ j+n $ 和 $ j $ 与 $ i $ 。

连好边之后，我们可以发现在一个强连通分量内的点状态是一样的，我们用Tarjan求出强联通分量，然后判断 $ i $ 与 $ i+n $ 是否在同一个强联通分量内，因为一道菜不可能既是满式又是汉式。

# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int f[2000000],a[2000000],b[2000000],d[2000000],stak[2000000],dfn[2000000],low[2000000];
bool u[2000000];
int j,T,n,m,cnt,tt,id,tot,i,xx,yy,x,y;
bool flag;
string s1,s2;
void add(int x,int y)
{
	cnt++;a[cnt]=y;b[cnt]=d[x];d[x]=cnt;
}
void tarjan(int x)
{
	tt++;dfn[x]=tt;low[x]=dfn[x];id++;stak[id]=x;u[x]=true;
	for (int i=d[x];i;i=b[i])
	     {
	     	if (dfn[a[i]]==0) 
	     	    {
	     	    	tarjan(a[i]);
	     	    	low[x]=min(low[x],low[a[i]]);
				 }
			else if (u[a[i]]) low[x]=min(low[x],dfn[a[i]]);
		 }
	if (low[x]==dfn[x])
	     {
	     	tot++;
	     	while (1)
	            {
	            	f[stak[id]]=tot;
	            	u[stak[id]]=false;id--;
	            	if (stak[id+1]==x) break;
				}
		 }
	return;
}
int main()
{
	cin>>T;
	for (;T;T--)
	   {
	   	tt=0;id=0;tot=0;cnt=0;
	   	for (i=1;i<=2*n;i++) dfn[i]=0,low[i]=0,d[i]=0,u[i]=0,f[i]=0;
	cin>>n>>m;
	for (i=1;i<=m;i++)
	     {
	     	cin>>s1>>s2;
	     	x=0;y=0;
	     	if (s1[0]=='m') xx=0;else xx=1;
	     	if (s2[0]=='m') yy=0;else yy=1;
	     	for (j=1;j<s1.size();j++) x=x*10+(s1[j]-'0');
	     	for (j=1;j<s2.size();j++) y=y*10+(s2[j]-'0');
	     	if ((xx==0)&(yy==0)) {add(x+n,y);add(y+n,x);}
	     	if ((xx==1)&(yy==1)) {add(x,y+n);add(y,x+n);}
	     	if ((xx==1)&(yy==0)) {add(x,y);add(y+n,x+n);}
	     	if ((xx==0)&(yy==1)) {add(x+n,y+n);add(y,x);}
		 }
	for (i=1;i<=2*n;i++)
	    if (dfn[i]==0) tarjan(i);
	flag=true;
	for (i=1;i<=n;i++)
	    if (f[i]==f[i+n])
	        flag=false;
	if (flag==false) puts("BAD");
	else puts("GOOD");
         }
	return 0;
}
```


---

## 作者：crh1272336175 (赞：0)

### 2-SAT问题

## 建边+$tarjan$

注：本题和P4272【模板】2-SAT 问题几乎一模一样。未做的读者可以先做模板题

此题是很裸的一个2-SAT问题，建边的时候分四种情况讨论：
```cpp
if(x=='m' && y=='m') add(a+n,b),add(b+n,a);
else if(x=='m' && y=='h') add(a+n,b+n),add(b,a);
else if(x=='h' && y=='m') add(a,b),add(b+n,a+n);
else add(a,b+n),add(b,a+n);
```
其中的x,y是字符'm'或者'h'，a,b是数字，读入的时候需要进行小处理

接下去tarjan一波，得到c[x]表示节点x属于第c[x]个SCC，易证c[x]越大，拓扑序反而越小。但是本题更水，只要判断是否矛盾即可，我们只要看c[x]和c[x+n]是否在同一个SCC中即可

AC代码：

```cpp
#include<bits/stdc++.h>
#pragma GCC opitimize(2)
using namespace std;
const int N=1005;
namespace Read
{
    inline int read()
    {
        int s=0,f=1; char ch=getchar();
        while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
        while(isdigit(ch)) s=s*10+(ch^48),ch=getchar();
        return s*f;
    }
}using namespace Read;
namespace Gragh
{
	int n,m,tot=0;
	int head[N],Next[N<<1],des[N<<1];
	inline void add(int a,int b)
	{
		Next[++tot]=head[a]; des[tot]=b; 
		head[a]=tot;
	}
}using namespace Gragh;
namespace Tarjan
{
	int num=0,cnt=0;
	int low[N],dfn[N],ins[N],c[N];
	stack<int> stk;
	void tarjan(int x)
	{
		low[x]=dfn[x]=++num;
		stk.push(x); ins[x]=1;
		for(int i=head[x]; i; i=Next[i])
		{
			int y=des[i];
			if(!dfn[y])
			{
				tarjan(y);
				low[x]=min(low[x],low[y]);
			} 
			else if(ins[y]) low[x]=min(low[x],dfn[y]);
		}
		if(dfn[x]==low[x])
		{
			int y; cnt++;
			do
			{
				y=stk.top(); stk.pop(); ins[y]=0;
				c[y]=cnt; 
			}while(y!=x);
		}
	}
}using namespace Tarjan;
inline void init()
{
	tot=num=cnt=0;
	memset(head,0,sizeof head);
	for(int i=1; i<=N; i++)
		dfn[i]=c[i]=low[i]=ins[i]=0; 
	while(!stk.empty()) stk.pop();
}
inline void solve()
{
	n=read(),m=read();
	init();
	for(int i=1,k; i<=m; i++)
	{
		string s,t; cin>>s>>t; char x=s[0],y=t[0];
		int a=0,b=0;
		k=1; while(s[k]>='0' && s[k]<='9') a=a*10+s[k++]-'0';
		k=1; while(t[k]>='0' && t[k]<='9') b=b*10+t[k++]-'0';
		if(x=='m' && y=='m') add(a+n,b),add(b+n,a);
		else if(x=='m' && y=='h') add(a+n,b+n),add(b,a);
		else if(x=='h' && y=='m') add(a,b),add(b+n,a+n);
		else add(a,b+n),add(b,a+n);
	} 
	for(int i=1; i<=2*n; i++)
	    if(!dfn[i]) tarjan(i);
	for(int i=1; i<=n; i++)
	    if(c[i]==c[i+n]){puts("BAD"); return;}
	puts("GOOD");
}
int main()
{
	int t=read();
	while(t--) solve();
	return 0;
}
```



---

## 作者：破忆 (赞：0)

### 【题目大意】
有n个选择，每个选择有2个选项。有m个约束条件，a和b至少存在一个。

问是否可行。

------------
### 【分析】

不难发现这是[2-SAT](https://www.luogu.com.cn/problem/P4782)的裸题。

#### 算法步骤

选择i可以拆成两个点i与i+n，分别表示两个选项，且这两个选项互为反点（暂且这么称呼），记作i与i'。

约束条件看成边。

a与b至少存在一个，化开分析。

若选择了a'则必定选择b，连边a'->b。

若选择了b'则必定选择a，连边b'->a。

然后这2n个点构成了一个有向图。

#### 考虑无解的情况

选择i，经过推导如果得出必须选择i'，就会产生矛盾。

在图上的表现为，i通过某些路径到达了i'，同理i'也能到达i。

i与i'能互相到达，即在同一个强联通分量中。

#### 如何选择~~虽然这题不用考虑~~

要尽量选择优先级高的，即拓扑序小的。

运用Tarjan得到每个点所在的强连通分量的标号，是按照拓扑序来的，所以选择标号小的更优。

------------

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=105,maxt=maxn<<1,maxe=2e3+5;
int k,n,m,nn;
int tot,lnk[maxt];
int st[maxt],top;
int dfn[maxt],low[maxt],id[maxt],cir,cnt; 
struct edge{
	int to,nxt;
}e[maxe];
int read(){
	int ret=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}
void clear(){
	tot=cnt=cir=0;
	memset(lnk,0,sizeof lnk);
	memset(dfn,0,sizeof dfn);
	memset(id,0,sizeof id);
	memset(low,0,sizeof low);
}
void add_e(int x,int y){
	e[++tot]=(edge){y,lnk[x]};
	lnk[x]=tot;
}
void Tarjan(int x){//Tarjan板子
	st[++top]=x;
	dfn[x]=low[x]=++cnt;
	for(int j=lnk[x];j;j=e[j].nxt){
		int y=e[j].to;
		if(!dfn[y]){
			Tarjan(y);
			low[x]=min(low[x],low[y]);
		}
		else if(!id[y]) low[x]=min(low[x],dfn[y]);
	}
	if(dfn[x]==low[x]){
		cir++;
		while(st[top]!=x){
			id[st[top--]]=cir;
		}
		top--;
		id[x]=cir;
	}
}
int main(){
 	freopen("P4171.in","r",stdin);
 	freopen("P4171.out","w",stdout);
	k=read();
	while(k--){
		clear();
		n=read(),m=read();
		for(int i=1;i<=m;i++){
			char ch;
			int x,a,y,b;
			ch=getchar();
			while(ch!='m'&&ch!='h') ch=getchar();
			a=(ch=='m');
			x=read();
			ch=getchar();
			while(ch!='m'&&ch!='h') ch=getchar();
			b=(ch=='m');
			y=read();
			add_e(x+n*(a^1),y+n*b);
			add_e(y+n*(b^1),x+n*a);
            //此处为建边,^1就是取反点
		}
		nn=n<<1;
		for(int i=1;i<=nn;i++) if(!dfn[i]) Tarjan(i);
		bool flg=0;
		for(int i=1;i<=n;i++) if(id[i]==id[i+n]){flg=1;break;}//判断是否在同一个强连通分量内
		printf("%s\n",flg?"BAD":"GOOD");
	}
	return 0;
}
```


---

## 作者：lhm_ (赞：0)

考虑$2-SAT$。

将汉式看作$0$状态，满式看做$1$状态，将每个材料拆成$01$两个状态。

从$a$向$b$连有向边表示的意义为选了$a$后必须选$b$。

那么每次连边的方式如下：

$add(x_{a \oplus 1},y_b),add(y_{b \oplus 1},x_a)$（$x_a$和$y_b$为评审员的要求，$x$和$y$表示材料，$a$和$b$表示状态）

意义为若没有满足评审员的其中一个要求，则另一个要求必须满足。

连边后缩点，若发现$x_a$和$x_{a \oplus 1}$在同一强连通分量中，则无解。

其他的一些实现的处理，就看代码吧。

$code:$
```cpp
#include<bits/stdc++.h>
#define maxn 4000010
using namespace std;
template<typename T> inline void read(T &x)
{
	x=0;char c=getchar();bool flag=false;
	while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}
	while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
	if(flag)x=-x;
}
int t,n,m;
char str[5];
struct edge
{
    int to,nxt;
}e[maxn];
int head[maxn],edge_cnt;
void add(int from,int to)
{
    e[++edge_cnt]=(edge){to,head[from]};
    head[from]=edge_cnt;
}
int dfn_cnt,co_cnt,top;
int dfn[maxn],low[maxn],co[maxn],st[maxn];
bool vis[maxn];
void tarjan(int x)
{
    dfn[x]=low[x]=++dfn_cnt;
    st[++top]=x;
    vis[x]=true;
    for(int i=head[x];i;i=e[i].nxt)
    {
        int y=e[i].to;
        if(!dfn[y])
        {
            tarjan(y);;
            low[x]=min(low[x],low[y]);
        }
        else if(vis[y])
            low[x]=min(low[x],dfn[y]);
    }
    if(low[x]==dfn[x])
    {
        co_cnt++;
        int now;
        do
        {
            now=st[top--];
            vis[now]=false;
            co[now]=co_cnt;
        }while(now!=x);
    }
}
bool check()
{
    for(int i=1;i<=2*n;++i)
        if(!dfn[i])
            tarjan(i);
    for(int i=1;i<=n;++i)
        if(co[i]==co[i+n])
            return false;
    return true;
}
void clear()
{
    top=dfn_cnt=co_cnt=edge_cnt=0;
    memset(co,0,sizeof(co));
    memset(dfn,0,sizeof(dfn));
    memset(low,0,sizeof(low));
    memset(vis,0,sizeof(vis));
    memset(head,0,sizeof(head));
}
int main()
{
	read(t);
    while(t--)
    {
        clear();
        read(n),read(m);
        while(m--)
        {
            int x,y,a,b,len;
            scanf("%s",str);
            if(str[0]=='h') a=0;
            else a=1;
            x=0,len=strlen(str);
            for(int i=1;i<len;++i) x=x*10+str[i]-'0';
            scanf("%s",str);
            if(str[0]=='h') b=0;
            else b=1;
            y=0,len=strlen(str);
            for(int i=1;i<len;++i) y=y*10+str[i]-'0';
            add(x+(a^1)*n,y+b*n),add(y+(b^1)*n,x+a*n);
        }
        if(check()) puts("GOOD");
        else puts("BAD");
    }
	return 0;
}
```


---

## 作者：钱逸凡 (赞：0)

很明显的2-SAT，[建议先看看2-SAT模板](https://www.luogu.org/problemnew/show/P4782)

每种食材有两个状态：汉式或满式。这对应了2-SAT模版里的真或假。

只要參赛者能在这兩种材料的做法中，其中一个符合评审的喜好即可通过该评审的审查。

每个评审员对应2-SAT模版里的一个条件：a为真/假或b为真/假满足其中之一。

然后这就是一道2-SAT的模板了。

建图：如果某评审为m3 ，h1（m3对应条件a，h1对应条件b）（样例第一个数据），我们可以这样连边：h3连向h1，m1连向m3（非a连向b，非b连向a）。

然后像2-SAT一样，跑tarjan判强联通分类即可。

注意：多组数据清空数组

代码：
```
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;
int T,n,m;
int head[1010],top;
struct Node{
	int v;
	int next;
}node[2020];
inline void addedge(int u,int v){
	node[++top].v=v;
	node[top].next=head[u];
	head[u]=top;
}
int taj,cnt,t,belong[1010],dfn[1010],low[1010],st[1010];
bool inst[1010];
int a1,a2;
inline void Read(int &a){
	a=0;
	int f=0;
	char c=getchar();
	while(c!='m'&&c!='h')c=getchar();
	if(c=='h')a=n;//i代表满式，i+n代表汉式
	c=getchar(); 
	while(c>='0'&&c<='9')f=f*10+c-'0',c=getchar();
	a+=f;
}//读入对应食材 
void tarjan(int u){
	dfn[u]=low[u]=++t;
	st[cnt++]=u;
	inst[u]=1;
	for(int i=head[u];i;i=node[i].next){
		int d=node[i].v;
		if(dfn[d]==-1){
			tarjan(d);
			low[u]=min(low[u],low[d]);
		}
		else if(inst[d])low[u]=min(low[u],low[d]);
	}
	if(dfn[u]==low[u]){
		taj++;
		int now;
		do{
			now=st[--cnt];
			inst[now]=0;
			belong[now]=taj;
		}while(now!=u);
	}
}
int main(){
	scanf("%d",&T);
	int fa1,fa2;
	register int i;
	while(T--){
		scanf("%d %d",&n,&m);
		taj=cnt=t=top=0;
		memset(dfn,-1,sizeof(dfn));
		memset(low,-1,sizeof(low));
		memset(head,0,sizeof(head));
		memset(node,0,sizeof(node));
		memset(st,0,sizeof(st));
		memset(inst,0,sizeof(inst));
		memset(belong,0,sizeof(belong));
		for(i=1;i<=m;i++){
		Read(a1),Read(a2);
		fa1=a1<=n?a1+n:a1-n;//非a1 
		fa2=a2<=n?a2+n:a2-n;//非a2 
		addedge(fa1,a2);
		addedge(fa2,a1);
		}
		bool f=0;
		for(i=1;i<=n*2;i++)if(dfn[i]==-1)tarjan(i);
		for(i=1;i<=n;i++){
			if(belong[i]==belong[i+n]){
				f=1;
				break;
			}
		}
		if(f==0)printf("GOOD\n");
		else printf("BAD\n");
	}
	return 0;
}
```

---

## 作者：ww3113306 (赞：0)

做的第一道2-Sat的题emmm。。。

一开始看了题解发现一直写不出来，

因为下面说拆4个点，但是每次都是不做什么向做什么连边，

如果这样的话， 做什么 就永远没有出边，

那也就意味这每个点都是一个极大强连通分量

于是就判不出来了，也不知道是不是我理解有误。。。。

后来咨询某位大佬发现，应该要拆2个点，

因为不做某道菜就意味这做另一道菜，所以不再是不做什么--->做什么

而是做什么--->做什么

比如说一个评委要求m1,m2，

那么不做m1就意味着做h1,所以h1 --- > m2

同理，h2 --- > m1

这样就只用拆两个点了

连边应该还有更方便的写法，只不过我懒得想就手动模拟了

这样应该是比拆4个点要简单的

```cpp
#include<bits/stdc++.h>
using namespace std;
#define R register int
#define AC 450
#define ACway 4500
#define D printf("line in %d\n",__LINE__);
int T,n,m;
int dfn[AC],low[AC],belong[AC],cnt;
int date[ACway],Next[ACway],Head[AC],tot;
int q[AC],top,timer;
char c1[5],c2[5];
bool z[AC];

inline void add(int f,int w)
{
//	printf("%d --- > %d\n",f,w);
    date[++tot]=w,Next[tot]=Head[f],Head[f]=tot;
}

inline void upmin(int &a,int b)
{
    if(b<a) a=b;
}
//拆成4个点，i --- > 选汉式,i+n --- >选满式 
void pre()
{
    R x1,x2;
    scanf("%d%d",&n,&m);
    for(R i=1;i<=m;i++)
    {
        scanf("%s%s",c1+1,c2+1);
        x1=x2=0;
        int l=2;
        while(c1[l] <= '9' && c1[l] >= '0') x1=x1*10+c1[l]-'0',++l;
        l=2;
        while(c2[l] <= '9' && c2[l] >= '0') x2=x2*10+c2[l]-'0',++l;//得到菜的编号
        if(c1[1] == 'm') //不满足x1,满足x2,此时x1是'm',所以不加
        {
            if(c2[1] == 'm') add(x1,x2+n);//x1不做满式（做汉式） --- > x2 做满式
            else add(x1,x2);//x1做汉式，x2做汉式
        }
        else//不满足x1,满足x2,此时x1是h，所以加
        {
            if(c2[1] == 'm') add(x1+n,x2+n);//如果x2是m的话
            else add(x1+n,x2);//是h的话error!!!别打错了啊！！！是不满足x1啊
        }
        if(c2[1] == 'm') //满足x1,不满足x2,此时x2是'm',所以不加
        {
            if(c1[1] == 'm') add(x2,x1+n);//此时x1是m，所以加
            else add(x2,x1);//此时x1是h，所以不加
        }
        else//满足x1,不满足x2,此时x2是h,所以加
        {
            if(c1[1] == 'm') add(x2+n,x1+n);//此时x1是m,所以加
            else add(x2+n,x1);//x1是h，所以不加
        }
    }	
}

void tarjan(int x)
{
    R now;
    dfn[x]=low[x]=++timer;
    q[++top]=x,z[x]=true;
    for(R i=Head[x]; i ;i=Next[i])
    {
        now=date[i];
        if(!dfn[now])
        {
            tarjan(now);
            upmin(low[x],low[now]);
        }
        else if(z[now])
            upmin(low[x],low[now]);
    }
    if(dfn[x] == low[x])
    {
        z[x]=false,++cnt;
        now=0;
        while(now != x)//因为回到这里的时候已经操作完了
        {
            now=q[top--];//--放后面可以保证top不被忽略
            z[now]=false;
            belong[now]=cnt;
        }
    }
}

void work()
{
    bool flag;
    scanf("%d",&T);
    while(T--)
    {
        flag=false;
        memset(Head,0,sizeof(Head));
        memset(dfn,0,sizeof(dfn));//因为是用dfn判断有无访问的，所以memset dfn就可以了
        memset(z,0,sizeof(z));
        tot=timer=cnt=0;
        pre();
        int all=4*n;
        for(R i=1;i<=all;i++)
            if(!dfn[i]) tarjan(i);
        for(R i=1;i<=n;i++)
        {
            if(belong[i] == belong[n + i])//不能既选h又选m 
            {
                flag=1;
                break;
            }
        }
        //for(R i=1;i<=2*n;i++) printf("%d ",belong[i]);
        if(!flag) printf("GOOD\n");
        else printf("BAD\n");
    }
}

int main()
{
//	freopen("in.in","r",stdin);
    work();
//	fclose(stdin);
    return 0;
}
```

---


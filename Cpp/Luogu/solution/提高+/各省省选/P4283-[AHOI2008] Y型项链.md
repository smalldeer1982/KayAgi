# [AHOI2008] Y型项链

## 题目描述

欢乐岛上众多新奇的游乐项目让小可可他们玩的非常开心。现在他们正在玩比赛串项链的游戏，谁串的最快就能得到优厚的奖品。

这可不是普通的项链，而是一种 Y 型项链，项链的最中间有一颗大珍珠作为结合点，从大珍珠上连出来 3 条由各种宝石串起来的链子。

比赛的规则是这样的：每次可以从三条链子中某一条的一端取下来一个宝石，或者安上去一个宝石，称为一次操作，经过若干次操作，最终使得三条链子完全相同。想要赢得比赛，那么只能使用尽量少的操作次数。

假设每种宝石都有无数多个以供使用，且链子足够长。你能帮助小可可赢得比赛吗？

注：由于对 Y 型项链的宝石数没有特殊的要求，所以即使你把所有宝石都取下来，也是一个可以接受的方案（三根没有串宝石的绳子也是完全一样的）。

## 说明/提示

对于 $50\%$ 的数据，$N\leq 20$。

对于 $100\%$ 的数据，$1\le N\le 50$。

## 样例 #1

### 输入

```
3 CAT
3 TAC
5 CATCH```

### 输出

```
8

```

# 题解

## 作者：leoljx (赞：2)

这是本人的第一篇题解，也是我第一道 AC 的蓝题！

说实在的，我认为这题不应该被评为蓝。

1. 最长公共前缀：考虑有两个字符串（以下简称串），它们的最长公共前缀就是它们前缀的最长部分 ~~（有些偏废话了）~~。

2. 思路：三个串两两匹对，找到任意两个串的最长公共前缀，比较选出中最长的公共前缀（如样例中：一串与三串的最长公共前缀为 `CAT` ，这是三种两两匹配方案的串中最长的前缀，这就是我们的目标串），找到后只需计算将三个串都更新成目标串所用的步数即可（如样例中将三个串更新成 `CAT` 就是最少的步数）。

3. 特别的，如果查找后三种可能的公共前缀均为空（即三者两两匹配后没有公共前缀部分），那么把三串清空就是最少的步数。

4. 以下是 AC 代码（目前是全题解区中最简洁代码)：

```cpp
#include<bits/stdc++.h>
using namespace std;
int nx,ny,nz,mxy,mxz,myz,maxn;
int n;
char x[100],y[100],z[100];//三个串
int main()
{
	cin>>nx>>x>>ny>>y>>nz>>z;
	while(x[mxy]==y[mxy]&&mxy<nx&&mxy<ny) mxy++;//mxy是指x串与y串的最长公共前缀的长度
	while(x[mxz]==z[mxz]&&mxz<nx&&mxz<nz) mxz++;//同理于上
	while(y[myz]==z[myz]&&myz<ny&&myz<nz) myz++;
	maxn=max(max(mxy,mxz),myz);//maxn是指最长的最长公共前缀的长度，即目标串的长度
	if(maxn==mxy) n=(nx-mxy)+(ny-mxy)+(nz-mxy)+(maxn-mxz)*2;
	else if(maxn==mxz) n=(nx-mxz)+(ny-mxz)+(nz-mxz)+(maxn-mxy)*2;
	else if(maxn==myz) n=(nx-myz)+(ny-myz)+(nz-myz)+(maxn-mxz)*2;//以上是计算更新成目标串所用的步数
	cout<<n;
    return 0;//good habit
}
``````

通俗易懂，简约大方。希望大家能给蒟蒻一些鼓励，有不足之处请放宽直言。

---

## 作者：youdu666 (赞：2)

### 思路：爆搜

真的不到蓝吧，大概就黄的难度。

最终肯定是某一个串的一个前缀，或者全部删掉。第二个答案非常简单，对于第一个，直接搜每个串的前缀，然后去跟三个串比较。比较时，刨去两个序列相同的前缀，随后把后面的长度都加上就是从其中一个变成另一个的代价，就做完了。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
string s[3],x;
int n[3];
inline int chk(string s,string x)//算从s变成x的代价
{
	int tp=0;
	while(s[tp]==x[tp] and tp<s.size() and tp<x.size())tp++;
	return s.size()-tp+x.size()-tp;
}
signed main()
{
	ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    for(int i=0;i<3;i++)
    	cin>>n[i]>>s[i];
    int ans=n[1]+n[2]+n[0];
    for(int i=0;i<3;i++)
    {
    	for(int j=1;j<=n[i];j++)
    	{
    		x=s[i].substr(0,j);
    		int cnt=0;
    		for(int u=0;u<3;u++)
    			cnt+=chk(s[u],x);
    		ans=min(ans,cnt);
    	}
    }
    cout<<ans<<'\n';
}
```


---

## 作者：liaohaoping (赞：1)

第一眼觉得是大难题，仔细想了下其实比较水。

由于只能再顶端加减宝石，很容易想到最长公共前缀，又因为要求最少的操作次数，所以我们先两两求出最长公共前缀，再找出最长公共前缀最长的两个串。

很明显，最长公共前缀最长的两个串需要修改的是最少的，那么我们是应该把两串非公共部分都删掉，还是删掉其中一串非公共部分，再补成另一串的样子呢？

通过观察可发现，两种方案虽然操作次数一样，但对于第三段却有很大区别，很明显，第三段只有一种操作方案，即把第三串与一二串非公共部分删去（由于一二串是最长公共前缀最长的两个串，所以第三串和一二串的最长公共前缀是一样的），再补成一二串的样子，明显是补得越少越好，所以一二串只需要把两串非公共部分都删掉。

最后算出操作次数就好了。

```cpp
#include <cstdio>
#include <cstring>
using namespace std;
inline int read()
{
	int x=0,w=0;char ch=getchar();
	while(ch<'0'||ch>'9')w|=ch=='0',ch=getchar();
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return w?-x:x;
}
char s1[60],s2[60],s3[60];
char ss1[60],ss2[60],ss3[60];
int main()
{
	int n1=read();scanf("%s",s1+1);
	int n2=read();scanf("%s",s2+1);
	int n3=read();scanf("%s",s3+1);
	int m,mm,m1,m2,m3;
	for(m1=0; s1[m1+1]==s2[m1+1] && m1<n1 && m1<n2 ;++m1);
	for(m2=0; s1[m2+1]==s3[m2+1] && m2<n1 && m2<n3 ;++m2);
	for(m3=0; s2[m3+1]==s3[m3+1] && m3<n2 && m3<n3 ;++m3);
	if(m1>m2&&m1>m3) strcpy(ss1+1,s1+1),strcpy(ss2+1,s2+1),strcpy(ss3+1,s3+1),m=m1,mm=m2;
	else if(m2>m1&&m2>m3) strcpy(ss1+1,s1+1),strcpy(ss2+1,s3+1),strcpy(ss3+1,s2+1),m=m2,mm=m3;
	else strcpy(ss1+1,s2+1),strcpy(ss2+1,s3+1),strcpy(ss3+1,s1+1),m=m3,mm=m1;
	n1=strlen(ss1+1),n2=strlen(ss2+1),n3=strlen(ss3+1);
	printf("%d",n1+n2+n3-m-mm*2);
	return 0;
}
```

---

## 作者：big_news (赞：0)

不理解为什么要写最长公共前缀

实际上不写也行啊，这题又没那么难。。。n这么小，瞎搞搞不就好了。

首先有一个很zz的贪心思路就是说：如果不考虑把三串项链都摘下来，并且按照最优策略操作，那么最后得到的相同的三串项链一定是某一串项链的前缀。

然后暴力的去枚举这三串项链的所有前缀不就好了么......剩下的问题只是统计把三串项链都变成这个前缀串需要多少步，对于同一个串这个东西总是一定的啊。

最后再特判一下把三串项链都摘下来。然后就没什么了，一发交AC可还行。

代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
using namespace std;

const int CN = 150;

char s1[CN],s2[CN],s3[CN];
int n,ans,l1,l2,l3;

int main()
{
    scanf("%d",&l1);
    for(int i=1;i<=l1;i++) cin>>s1[i];
    scanf("%d",&l2);
    for(int i=1;i<=l2;i++) cin>>s2[i];
    scanf("%d",&l3);
    for(int i=1;i<=l3;i++) cin>>s3[i];
    
    ans = l1+l2+l3; //remove all
    
    for(int len=1;len<=l1;len++){ //s1
        int cost = l1-len; bool del = false;
        for(int j2=1;j2<=min(len,l2);j2++){
            if(del){
                cost += 1;
                continue;
            }
            if(s1[j2] != s2[j2]){
                cost += l2-j2+2;
                del = true;
            }
        }
        if(l2 != len){
            if(l2>len && !del) cost += l2-len;
            if(len > l2) cost += len-l2;
        }
        
        del = false;
        for(int j3=1;j3<=min(len,l3);j3++){
            if(del){
                cost += 1;
                continue;
            }
            if(s1[j3] != s3[j3]){
                cost += l3-j3+2;
                del = true;
            }
        }
        if(l3 != len){
            if(l3>len && !del) cost += l3-len;
            if(len > l3) cost += len-l3;
        }
        
        ans = min(ans, cost);
    }
    
    for(int len=1;len<=l2;len++){ //s2
        int cost = l2-len; bool del = false;
        for(int j1=1;j1<=min(len,l1);j1++){
            if(del){
                cost += 1;
                continue;
            }
            if(s1[j1] != s2[j1]){
                cost += l1-j1+2;
                del = true;
            }
        }
        if(l1 != len){
            if(l1>len && !del) cost += l1-len;
            if(len > l1) cost += len-l1;
        }
        
        del = false;
        for(int j3=1;j3<=min(len,l3);j3++){
            if(del){
                cost += 1;
                continue;
            }
            if(s2[j3] != s3[j3]){
                cost += l3-j3+2;
                del = true;
            }
        }
        if(l3 != len){
            if(l3>len && !del) cost += l3-len;
            if(len > l3) cost += len-l3;
        }
        
        ans = min(ans, cost);
    }
    
    for(int len=1;len<=l3;len++){ //s3
        int cost = l3-len; bool del = false;
        for(int j1=1;j1<=min(len,l1);j1++){
            if(del){
                cost += 1;
                continue;
            }
            if(s1[j1] != s3[j1]){
                cost += l1-j1+2;
                del = true;
            }
        }
        if(l1 != len){
            if(l1>len && !del) cost += l1-len;
            if(len > l1) cost += len-l1;
        }
        
        del = false;
        for(int j2=1;j2<=min(len,l2);j2++){
            if(del){
                cost += 1;
                continue;
            }
            if(s2[j2] != s3[j2]){
                cost += l2-j2+2;
                del = true;
            }
        }
        if(l2 != len){
            if(l2>len && !del) cost += l2-len;
            if(len > l2) cost += len-l2;
        }
        
        ans = min(ans, cost);
    }
    
    printf("%d",ans);
    
    return 0;
}
```

---

## 作者：zhl001 (赞：0)

### 考试原题，真的没那么难。。。

思路：

一共有三个项链，所以两两比较，只需要三个for循环比较公共前缀长度，找出两个公共前缀长度最长的，作为“基底”，之后就可以枚举时保留0...公共前缀的长度，看操作数是不是最少；

#### 注意：

不是最长公共前缀的那一串在计算时要先删到最长公共前缀，在开始补成相同的；公共前缀就要删掉多余部分；

AC代码：

```
#include<bits/stdc++.h>
using namespace std;
int lena,lenb,lenc,n,m,tot1,tot2,tot3,lenx,final=0x7f7f7f7f,x,y,z,ans=-1;
string a,b,c;
int main()
{
//	freopen("necklace.in","r",stdin);
//	freopen("necklace.out","w",stdout);
	cin>>lena>>a;
	cin>>lenb>>b;
	cin>>lenc>>c;
	for(int i=0;i<lena&&i<lenb;i++)
	{
		if(a[i]==b[i]) tot1+=1;
		else
		break;
	}
	for(int i=0;i<lenb&&i<lenc;i++)
	{
		if(b[i]==c[i]) tot2+=1;
		else
		break;
	}
	for(int i=0;i<lena&&i<lenc;i++)
	{
		if(a[i]==c[i]) tot3+=1;
		else
		break;
	}
	if(ans<tot1)
	{
		ans=tot1;
		x=lena,y=lenb,z=tot3,lenx=lenc;
	}
	if(ans<tot2)
	{
		ans=tot2;
		x=lenb,y=lenc,z=tot1,lenx=lena;
	}
	if(ans<tot3)
	{
		ans=tot3;
		x=lena,y=lenc,z=tot2,lenx=lenb;
	}
	for(int i=0;i<=ans;i++)
	{
		final=min(final,(x-i)+(y-i)+(lenx-z)+(i-z));
	}
	printf("%d",final);
	return 0;
}
```


---

## 作者：VenusM1nT (赞：0)

枚举。首先观察数据范围，仅仅是 $n\leq50$，这个范围能够承受 $\text{O}(n^4)$ 的时间复杂度，所以我们直接枚举目标串，即每个串每个位置每个长度枚举，时间复杂度 $\text{O}(3n^2)$，然后再分别计算每个串的操作次数，复杂度是 $\text{O}(3n)$，所以总时间复杂度是 $\text{O}(9n^3)$ ，完全没有压力，轻松 $\text{AC}$。

（不过我还是 $\text{WA}$ 了两次，因为一些智障错误。）

```cpp
#include<bits/stdc++.h>
using namespace std;
int n[5],tot,ans=2e9;
string s[5],g;
int Calc(int id)
{
	int len=0;
	for(int i=1;i<=min(tot,n[id]);i++) if(g.substr(0,i)==s[id].substr(0,i)) len=i;
	int res=n[id]-len+tot-len;
	return res;
}
int main()
{
	for(int i=1;i<=3;i++) cin>>n[i]>>s[i];
	for(int i=1;i<=3;i++)
	{
		for(int j=0;j<=n[i];j++)
		{
			for(int k=0;k<n[i]-j+1;k++)
			{
				g=s[i].substr(k,j);
				tot=j;
				int res=Calc(1)+Calc(2)+Calc(3);
				ans=min(ans,res);
			}
		}
	}
	ans=min(ans,n[1]+n[2]+n[3]);
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Celebrate (赞：0)

这一题中 N <= 50 是什么东西？我来发一波O (N) 的题解

我们先要知道怎么找最小值

首先不用想都知道不会出现一些没用的步数

因此我们先枚举每一个项链的一个长度，就以这一段为标准看一下需要花费多少步来完成

这样子的时间是O(N^2)，如果想要在优化，我们可以与处理一下每两串之间的最长前缀

代码请见 [我的博客](https://blog.csdn.net/zsyzClb/article/details/85195744)

---


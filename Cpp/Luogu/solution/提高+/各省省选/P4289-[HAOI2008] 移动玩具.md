# [HAOI2008] 移动玩具

## 题目描述

在一个 $4 \times 4$ 的方框内摆放了若干个相同的玩具，某人想将这些玩具重新摆放成为他心中理想的状态。规定移动时只能将玩具向上下左右四个方向移动，并且移动的位置不能有玩具。请你用最少的移动次数将初始的玩具状态移动到某人心中的目标状态。

## 样例 #1

### 输入

```
1111
0000
1110
0010 

1010
0101
1010
0101```

### 输出

```
4```

# 题解

## 作者：Createsj (赞：32)

### [博客食用效果更佳~](https://createsj.blog.luogu.org/solution-p4289)

让我们先来看看题目：
### 题目描述
在一个 $4*4$ 的方框内摆放了若干个相同的玩具，某人想将这些玩具重新摆放成为他心中理想的状态，规定移动时只能将玩具向上下左右四个方向移动，并且移动的位置不能有玩具，请你用最少的移动次数将初始的玩具状态移动到某人心中的目标状态。
### 输入输出格式
#### 输入格式：
前 $4$ 行表示玩具的初始状态，每行 $4$ 个数字 $1$ 或 $0$，$1$ 表示方格中放置了玩具，$0$ 表示没有放置玩具。接着是一个空行。接下来4行表示玩具的目标状态，每行 $4$ 个数字 $1$ 或 $0$，意义同上。
#### 输出格式：
一个整数，所需要的最少移动次数。

事实上，当看到 $4\times4$ 和 $1$ 或 $0$ 时，就应该想到状压了，因为只有 $4\times 4 =16$ 个方格，而每个方格只有 $1$ 或 $0$ 两种状态，所以总共只有 $2^{16}=65536$ 种状态（由于玩具的个数是一定的，所以状态数还要小得多，不过状压到 $65536$ 种已经够用了），一个 unsigned short 就可以储存下来了。为了方便起见，这里我为 unsigned short 取一个别名 ushort。
```cpp
typedef unsigned short ushort;
```
接下来我们来写输入函数用于输入起始和目标状态：
```cpp
inline bool getbool()//输入一个bool值（即 0 或 1）
{
	char c;
	do
		c=getchar();
	while(c!='1' && c!='0');
	return c&1;
}
ushort input()
{
	ushort num=0;
	for(ushort i=0;i<16;++i)
		num=(num<<1)|getbool();//num 左移一位后在后面插入一个bool值（0或1）
	return num;
}
```
接下来就是解决移动玩具的问题了。

比如样例的初始状态为：

$1\quad1\quad1\quad1$

$0\quad0\quad0\quad0$

$1\quad1\quad1\quad0$

$0\quad0\quad1\quad0$

按照我给出的输入函数，初始状态被保存为二进制数

$1111000011100010$

我们想要第 $0$ 行第 $0$ 列的玩具向下移动，即使初始状态变为：

$0\quad1\quad1\quad1$

$1\quad0\quad0\quad0$

$1\quad1\quad1\quad0$

$0\quad0\quad1\quad0$

保存为

$0111100011100010$

很显然，这相当于交换两位数。

可以想到，我们可以先用 $0$ 覆盖掉移动的位置，再将 $1$ 插入，这一方法我们可以用位运算的方式实现。

先定义一个数组  $f$：

```cpp
const int f[4][4]= {{15,14,13,12},{11,10,9,8},{7,6,5,4},{3,2,1,0}};
```
这样会方便我们做位移之类的位运算操作。

~~另外利用该数组友情赠送 output 函数来输出状态（调试用）：~~
```cpp
void output(const ushort num)
{
    for(int i=0;i<4;putchar('\n'),++i)
        for(int j=0;j<4;++j)
            putchar(((num>>f[i][j])&1)|'0');
}
```

用 $now$ 来表示当前要移动的状态，$x$ 和 $y$ 表示移动的位置，bool 值 $next$ 为真表示为上下移动，否则表示为左右移动。我们先用 $t1$ 和 $t2$ 储存移动前的位置和移动后的位置的状态（有无玩具）：

```cpp
const ushort t1=now&(1<<f[x][y]),t2=now&(1<<f[x+next][y+(!next)]);
```
然后覆盖的操作如下：

```cpp
now=now&(~t1)&(~t2);
```

然后插入操作如下：
```cpp
now=now|(t1>>f[x][y]<<f[x+next][y+(!next)])|(t2>>f[x+next][y+(!next)]<<f[x][y])；
```

两个操作合起来就是：
```cpp
(now&(~t1)&(~t2))|(t1>>f[x][y]<<f[x+next][y+(!next)])|(t2>>f[x+next][y+(!next)]<<f[x][y]);
```

我们只需要用一个 $\operatorname{move}$ 函数返回它的值即可:
```cpp
inline ushort move(const ushort now,const ushort x,const ushort y,const bool next)
{
    const ushort t1=now&(1<<f[x][y]),t2=now&(1<<f[x+next][y+(!next)]);
    return (now&(~t1)&(~t2))|(t1>>f[x][y]<<f[x+next][y+(!next)])|(t2>>f[x+next][y+(!next)]<<f[x][y]);
}
```

解决了状态的储存和处理后，就来思考如何求出最少移动次数吧！

不难想到，我们可以用广搜来找出这个最少移动次数。首先从初始状态开始找交换一次后的所有状态，再继续找，直到出现目标状态，再输出次数，另外还要筛掉已经出现过的状态。

用一个结构体数组来储存一种状态是否出现过且出现在第几次：
```cpp
struct st
{
    ushort step;//储存出现次数
    bool book;//储存是否出现过
}a[65536];
```

再来一些变量：
```cpp
queue<ushort> q;//队列，广搜必需，储存状态
ushort end;//储存目标状态
```

自己写个 $\operatorname{Push}$ 函数，其实就是在入队的时候做些特殊处理：
```cpp
inline bool Push(const ushort x,const ushort y,const bool next)//参数与 move 函数的后三个参数相同
{
    ushort t=move(q.front(),x,y,next);//t 储存移动后状态
    if(t==end)//如果移动后为目标状态
    {
        printf("%d",a[q.front()].step+1);//输出移动步数
        return true;//返回真，表示已经搜索到了目标状态
    }
    if(a[t].book)//如果该状态没有被标记过（即没有搜索到过）
        return false;//返回假，表示没有搜索到目标状态
    q.push(t);//入队
    a[t].step=a[q.front()].step+1;//移动次数比原来多1
    a[t].book=true;//给该状态打上标记
    return false;//返回假，表示没有搜索到目标状态
}
```

$\operatorname{bfs}$ （广搜）函数如下：
```cpp
inline void bfs()
{
    q.push(input());//输入初始状态并入队
    a[q.front()].book=true;//打上标记
    end=input();//输入目标状态
    if(q.front()==end)//判断初始状态与目标状态是否相同，有一个测试点就是这样
    {
        putchar('0');//毋庸置疑，移动次数肯定为0
        return;
    }
    //广搜代码（应该不需要多讲了吧？）
    do{
        for(ushort i=0; i<4; ++i)
            for(ushort j=0; j<3; ++j)
            {
                if(Push(i,j,false))
                    return;
                else if(Push(j,i,true))
                    return;
            }
        q.pop();
    }while(!q.empty());
}
```

这样，整个问题就解决了！完整代码如下：
```cpp
#include <queue>
#include <cstdio>
using namespace std;
typedef unsigned short ushort;
const int f[4][4]={{15,14,13,12},{11,10,9,8},{7,6,5,4},{3,2,1,0}};
inline bool getbool()//输入一个bool值（即 0 或 1）
{
	char c;
	do
		c=getchar();
	while(c!='1' && c!='0');
	return c&1;
}
ushort input()
{
	ushort num=0;
	for(ushort i=0;i<16;++i)
		num=(num<<1)|getbool();//num 左移一位后在后面插入一个bool值（0或1）
	return num;
}
inline ushort move(const ushort now,const ushort x,const ushort y,const bool next)
{
    const ushort t1=now&(1<<f[x][y]),t2=now&(1<<f[x+next][y+(!next)]);
    return (now&(~t1)&(~t2))|(t1>>f[x][y]<<f[x+next][y+(!next)])|(t2>>f[x+next][y+(!next)]<<f[x][y]);
}
struct st
{
    ushort step;//储存出现次数
    bool book;//储存是否出现过
}a[65536];
queue<ushort> q;//队列，广搜必需，储存状态
ushort end;//储存目标状态
inline bool Push(const ushort x,const ushort y,const bool next)//参数与 move 函数的后三个参数相同
{
    ushort t=move(q.front(),x,y,next);//t 储存移动后状态
    if(t==end)//如果移动后为目标状态
    {
        printf("%d",a[q.front()].step+1);//输出移动步数
        return true;//返回真，表示已经搜索到了目标状态
    }
    if(a[t].book)//如果该状态没有被标记过（即没有搜索到过）
        return false;//返回假，表示没有搜索到目标状态
    q.push(t);//入队
    a[t].step=a[q.front()].step+1;//移动次数比原来多1
    a[t].book=true;//给该状态打上标记
    return false;//返回假，表示没有搜索到目标状态
}
inline void bfs()
{
    q.push(input());//输入初始状态并入队
    a[q.front()].book=true;//打上标记
    end=input();//输入目标状态
    if(q.front()==end)//判断初始状态与目标状态是否相同，有一个测试点就是这样
    {
        putchar('0');//毋庸置疑，移动次数肯定为0
        return;
    }
    //广搜代码（应该不需要多讲了吧？）
    do{
        for(ushort i=0; i<4; ++i)
            for(ushort j=0; j<3; ++j)
            {
                if(Push(i,j,false))
                    return;
                else if(Push(j,i,true))
                    return;
            }
        q.pop();
    }while(!q.empty());
}
int main()
{
    bfs();
    return 0;
}
```
还有一道类似的题目，A掉此题后也可以去做一做哦：

[P1225 黑白棋游戏](https://www.luogu.org/problemnew/show/P1225)

---

## 作者：z13881681022 (赞：17)

非状压题解,复杂度O（5^4）~~（貌似是O（1）？）~~。

首先，我们要了解一个性质：

对于已经匹配好的点，我们直接把他赋值为0；

**原理：**

1.对于用这个点去匹配其他点，肯定不如直接有这个点已匹配的点更优。

2.如果另一个点的某条转移路径需要路过这个点，我们可以转换为：把这个点先转移到目标点，然后再把另一个点转移过来。

得到这个结论就简单多了。我们只需要求得未匹配点到未匹配目标点的最短距离即可。
这个用数学方式：两点x坐标差的绝对值+两点y坐标的绝对值。

最后用深搜暴力求解即可。

上代码
------------

```c
#include<iostream>
#include<cmath>
using namespace std;
struct zb{
	int x,y;
}c[26];//结构体，x，y表示未匹配点的坐标。
int a[5][5];
int b[5][5];
int w[5][5][5][5];//前两个下标表示未匹配点坐标，后两个下标为待匹配点坐标，保存值为未匹配点到待匹配点的最短距离 
bool used[5][5];
int sum=0;
int minn=0x7fffffff;
void search(int pos,int v)//深搜找答案。 
{
	if(pos>sum)
	{
		minn=min(minn,v);
		return ;
	}
	for(int i=1;i<=4;i++)
	 for(int j=1;j<=4;j++)
	  if(w[c[pos].x][c[pos].y][i][j]!=0&&!used[i][j])
	  {
	  	used[i][j]=true;
	  	search(pos+1,v+w[c[pos].x][c[pos].y][i][j]);
	  	used[i][j]=false;
	  }
}
int main()
{
	char ee;
	for(int i=1;i<=4;i++)
	 for(int j=1;j<=4;j++)
	  {cin>>ee;
	  a[i][j]=ee-'0';
	  }
	for(int i=1;i<=4;i++)
	 for(int j=1;j<=4;j++)
	  {
	  cin>>ee;
	  b[i][j]=ee-'0';
	  if(a[i][j]==b[i][j])
	   a[i][j]=b[i][j]=0;//处理已匹配点 
      }
    for(int i=1;i<=4;i++)
	 for(int j=1;j<=4;j++)
	  if(a[i][j]==1)
	  {
	  	c[++sum].x=i;
	  	c[sum].y=j; 
	  	for(int k=1;k<=4;k++)
	      for(int kk=1;kk<=4;kk++)
	       if(b[k][kk]==1)
	       {
	       	w[i][j][k][kk]=abs(i-k)+abs(j-kk);//数学方式求最短距离 
		   }
	  }
	search(1,0);
	printf("%d",minn);
	return 0;
}
```

---

## 作者：Achtoria (赞：13)

# 双向BFS

~~本题其实并不难~~ 本蒟蒻还是调了很久QAQ

其实具体思路其他大佬已经讲过了，但好像木有双向BFS的，于是蒟蒻来水一波STO。

#### 对于一个棋盘状压成2进制然后bfs+判重即可，至于那些操作如何用位运算比较~~猥琐~~（大家可以手动模拟一下orz)，下面的具体看代码，中间会有解释。



```cpp
#include<bits/stdc++.h>

using namespace std;

#define maxn 20
#define maxm (1 << 16) + 5
#define file(a) freopen(#a".in","r",stdin); freopen(#a".out","w",stdout);
typedef long long ll;

int v[2][maxm], q[2][maxm];
int s, e, h[2], t[2], now, u, k, f;
char c;

int read(){
	char orz; int tql = 0, qwq = 1;
	orz = getchar();
	while(orz > '9' || orz < '0'){
		if(orz == '-') qwq = -1;
		orz = getchar();
	}
	while(orz >= '0' && orz <= '9'){
		tql = (tql << 3) + (tql << 1) + orz - '0';
		orz = getchar();
	}
	return tql * qwq;
}

void init(){
	for(int i = 1; i <= 16; i++){
		cin >> c;//getchar会更快
		s = (s << 1) + c - '0';
	}
	for(int i = 1; i <= 16; i++){
		cin >> c;
		e = (e << 1) + c - '0';
	}
}

void expand(int m, int b){
	if(now & (1 << m)) return;//要换的位置有玩具 
	int k = now + (1 << m);//换后的棋盘 
	if(v[b][k]) return;//判重 
	if(v[b ^ 1][k]){//对方搜过则直接输出 
		printf("%d", v[b ^ 1][k] + v[b][u] - 1);
		f = 1;
		return;
	}
	v[b][k] = v[b][u] + 1;//步数+1 
	q[b][++t[b]] = k;//入队 
}

void bfs(){
	h[0] = t[0] = h[1] = t[1] = 1;
	q[0][h[0]] = s; v[0][s] = true;
	q[1][h[1]] = e; v[1][e] = true;
	if(s == e){
		printf("0");
		return;
	}//特判一下 
	while(h[0] <= t[0] && h[1] <= t[1]){
		u = q[0][h[0]++];
		for(int i = 15; i >= 0; i--){
			if(! (u & (1 << i))) continue;//当前位木有玩具 
			now =  u ^ (1 << i);//当前位有玩具变没玩具，没玩具变有玩具 
			if(i / 4 < 3) expand(i + 4, 0); if(f) return;//最后一行不可以向下移 
			if(i / 4 > 0) expand(i - 4, 0); if(f) return;//第一行不可以向上移 
			if(i % 4 != 3) expand(i + 1, 0); if(f) return;//最后一列不可向右移 
			if(i % 4 != 0) expand(i - 1, 0);  if(f) return;//第一列不可以左移 
		}
		u = q[1][h[1]++];
		for(int i = 15; i >= 0; i--){
			if(! (u & (1 << i))) continue;
			now =  u ^ (1 << i);
			if(i / 4 < 3) expand(i + 4, 1); if(f) return;
			if(i / 4 > 0) expand(i - 4, 1); if(f) return;
			if(i % 4 != 3) expand(i + 1, 1); if(f) return;
			if(i % 4 != 0) expand(i - 1, 1);  if(f) return;
		}
	}
}

int main(){
	//file(date);
	init();
	bfs();
	return 0;
}
```

大家可以去练一练[P1225 黑白棋游戏](https://www.luogu.org/problemnew/show/P1225)

---

## 作者：ChenHacker (赞：11)

看到没有bitset的题解，我来一发

首先安利一下我的blog [http://ch66.cf/](http://ch66.cf/)

[当然在我的博客观看效果更佳](http://ch66.cf/300.html)

思路下面那些大佬已经讲的很清楚了，具体操作看注释

```
#include<bits/stdc++.h>
#define id(x,y) ((x-1)*4+y-1)//将二维转化为一维空间
#define Node bitset<16>//开个宏定义方便些
#define n 4
using namespace std;

int read() {//快速读入
	int x=1,ans=0;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')x*=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){ans=ans*10+ch-48;ch=getchar();}
	return x*ans;
}

int da[]={0,-1};//为避免枚举到重复情况，只往上和往左
int db[]={-1,0};//同上
bitset<65536> vis;//避免重复搜索

int main() {
	Node t,s;
	char tmp[10];//tmp数组下面读入要用到
	for(int i=1;i<=n;i++) {
		for(int j=1;j<=n;j++)
			s[id(i,j)]=getchar()-'0';//字符强制转化
		gets(tmp);//过滤行末乱七八糟的东西
	}
	gets(tmp);//同上
	for(int i=1;i<=n;i++) {
		for(int j=1;j<=n;j++)
			t[id(i,j)]=getchar()-'0';//同上
		gets(tmp);//同上
	}
	if(s==t) puts("0"),exit(0);//当前状态和预期状态相同时特判
	queue<pair<Node,int> > w;//
	w.push(make_pair(s,0));vis[s.to_ulong()]=true;//bitset.to_ulong()这个函数是把bitset转化为整形
	while(w.size()) {//普通广搜
		Node u=w.front().first;int step=w.front().second;w.pop();
		for(int x=1;x<=n;x++) {
			for(int y=1;y<=n;y++) {
				for(int k=0;k<2;k++) {//枚举坐标和方向
					int xx=x+da[k],yy=y+db[k];
					if(xx<=0||xx>n||yy<=0||yy>n) continue;
					if((u[id(xx,yy)]==0&&u[id(x,y)]==0)||(u[id(xx,yy)]==1&&u[id(x,y)]==1)) continue;//只有在两个位置有且只有一个1时才可以交换
					bool temp=u[id(x,y)];u[id(x,y)]=u[id(xx,yy)];u[id(xx,yy)]=temp;//手动模拟交换比stl的swap函数快
					if(u==t) printf("%d\n",step+1),exit(0);//到达目的地输出结束
					if(!vis[u.to_ulong()]) w.push(make_pair(u,step+1)),vis[u.to_ulong()]=true;//若当前状态没有入队过就push
					temp=u[id(x,y)];u[id(x,y)]=u[id(xx,yy)];u[id(xx,yy)]=temp;
				} 
			}
		}
	}
	return 0;//这句好像在这题是废话，以防万一还是加上
} 
```

蒟蒻写的博客应该所有人都可以看懂吧

---

## 作者：Drinkkk (赞：8)

【题目描述】

在一个$4 \times 4$的方框内摆放了若干个相同的玩具，某人想将这些玩具重新摆放成为他心中理想的状态，规定移动时只能将玩具向上下左右四个方向移动，并且移动的位置不能有玩具，请你用最少的移动次数将初始的玩具状态移动到某人心中的目标状态。

【输入输出格式】

- 输入格式

前$4$行表示玩具的初始状态，每行$4$个数字$1$或$0$，$1$表示方格中放置了玩具，$0$表示没有放置玩具。接着是一个空行。接下来$4$行表示玩具的目标状态，每行$4$个数字$1$或$0$，意义同上。

- 输出格式

一个整数，所需要的最少移动次数。

【输入输出样例】

- 输入样例
```
1111
0000
1110
0010
1010
0101
1010
0101
```

- 输出样例
```
4
```

由于换行的显示问题，这里的样例没有换行，若有需要可以在[这里](https://www.luogu.org/problemnew/show/P4289)查看样例哦~

$100$分（满分）思路：

这道题目和经典的[八数码难题](https://www.luogu.org/problemnew/show/P1379)类似，当然八数码难题也可以用一些空间复杂度高的方法过掉，具体可以看一下我的[八数码难题的题解](https://www.luogu.org/blog/zzj/ti-xie-p1379-ba-shu-ma-nan-ti-post)~~，当时我太Simple了，不会哈希（Hash），所以就用了这种办法做。~~当然这题也可以这样子做啦~但我们在这里只考虑用哈希来判重的这种做法。

什么是哈希？

> 哈希（Hash），一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。

有哪几种方法取哈希值？

> 下面是几种常用的取哈希值的方法：

> 1. 直接取余法  
$Hash(xn)=xn\;mod\;p$，其中$p$为大质数。

> 2. 转换进制法  
$Hash(xn(2))=xn(10)$。

上面的引用部分的内容摘抄/借鉴自[百度百科](https://baike.baidu.com/)，选录时有删改。

本题我使用了进制转换法，我先用了一个函数$read()$来读入数据，如下。

```
void read()
{
	scanf("%s",dq+1);
	st[1]=dq[1],st[2]=dq[2],st[3]=dq[3],st[4]=dq[4];
	scanf("%s",dq+1);
	st[5]=dq[1],st[6]=dq[2],st[7]=dq[3],st[8]=dq[4];
	scanf("%s",dq+1);
	st[9]=dq[1],st[10]=dq[2],st[11]=dq[3],st[12]=dq[4];
	scanf("%s",dq+1);
	st[13]=dq[1],st[14]=dq[2],st[15]=dq[3],st[16]=dq[4];

	scanf("%s",dq+1);
	ed[1]=dq[1],ed[2]=dq[2],ed[3]=dq[3],ed[4]=dq[4];
	scanf("%s",dq+1);
	ed[5]=dq[1],ed[6]=dq[2],ed[7]=dq[3],ed[8]=dq[4];
	scanf("%s",dq+1);
	ed[9]=dq[1],ed[10]=dq[2],ed[11]=dq[3],ed[12]=dq[4];
	scanf("%s",dq+1);
	ed[13]=dq[1],ed[14]=dq[2],ed[15]=dq[3],ed[16]=dq[4];
}
```

然后，我用了一个函数$Hash()$来去一个字符串的哈希值，如将$101$转换为$5$，$1000$转换为$8$（也即我们把状态看成是一个二进制的数字，然后再将其 转换为十进制）。函数的实现如下~然后取七点和重点的哈希值。再将起点的哈希值存入队列的头。

```
int Hash(char nu[10001])
{
	int da=0;
	for(int i=0;i<=15;i++)
	{
		if(nu[i]=='1')
		{
			da+=pow(2,16-i-1);
		}
	}
	return da;
}
```

在在这里我用了一个数组$h[]$，我用$h[i]$来表示哈希值为$i$的状态最后一次出现的位置。由于本体的哈希值是惟一的，所以无需使用链表来判重。我还用了一个步数$zb[]$，我用$zb[i]$来表示队列里的第$i$个状态的步数。由于我使用了宽搜（宽度优先搜索），所以找到的第一个答案一定是最优解，我们只需要直接打印第一个找到的答案韩后返回即可。在这里我用了一个函数$bfs()$来实现宽搜函数。宽搜函数还是比较简单的，希望大家能够自行理解。

```
void bfs()
{
	int tou=1,wei=2;
	h[dl[1]]=1,zb[1]=0;
	while(tou<wei)
	{
		zh(dl[tou]);
		for(int i=1;i<=16;i++)
		{
			if(ch[i]=='0')
			{
				int x=0,y=0;
				if(i%4==0)
				{
					x=i/4;
				}
				else
				{
					x=i/4+1;
				}
				y=i%4;
				if(y==0)
				{
					y=4;
				}
				int k=(x-1)*4+y;
				for(int j=0;j<=3;j++)
				{
					int nx=x+dx[j];
					int ny=y+dy[j];
					if(nx>=1 && nx<=4 && ny>=1 && ny<=4 && ch[(nx-1)*4+ny]=='1')
					{
						int nk=(nx-1)*4+ny;
						char now[101];
						for(int t=1;t<=16;t++)
						{
							now[t]=ch[t];
						}
						now[k]='1';
						now[nk]='0';
						int xn=Hash(now+1);
						if(xn==js)
						{
							printf("%d",zb[tou]+1);
							return ;
						}
						if(h[xn]==0)
						{
							dl[wei]=xn;
							h[xn]=wei;
							zb[wei]=zb[tou]+1;
							wei++;
						}
					}
				}
			}
		}
		tou++;
	}
}
```

在宽搜里我使用了一个函数$zh()$，我用$zh(i)$来还原该状态的哈希值为$i$的状态。在这里我用了位运算，((1<<i-1)&t)>0可以判断一个数$t$的第$i$位是否不为$0$，方法借鉴自洛谷春令营教材哦，然后再将结果存到一个数组$ch[]$里即可哦~我的$zh()$函数的实现如下。

```
void zh(int t)
{
	char yc[10001];
	for(int i=1;i<=16;i++)
	{
		if(((1<<i-1)&t)>0)
		{
			yc[i]='1';
		}
		else
		{
			yc[i]='0';
		}
	}
	for(int i=1;i<=16;i++)
	{
		ch[i]=yc[16-i+1];
	}
}
```

下面上AC代码~

```
#include <cmath>
#include <cstdio>
#include <cstring>
char ch[10001];
char st[10001],ed[10001],dq[10001];
int dl[1000001],zb[1000001],h[1000001];
int dx[4]={1,0,-1,0};
int dy[4]={0,1,0,-1};
int js=0;
void read()
{
	scanf("%s",dq+1);
	st[1]=dq[1],st[2]=dq[2],st[3]=dq[3],st[4]=dq[4];
	scanf("%s",dq+1);
	st[5]=dq[1],st[6]=dq[2],st[7]=dq[3],st[8]=dq[4];
	scanf("%s",dq+1);
	st[9]=dq[1],st[10]=dq[2],st[11]=dq[3],st[12]=dq[4];
	scanf("%s",dq+1);
	st[13]=dq[1],st[14]=dq[2],st[15]=dq[3],st[16]=dq[4];

	scanf("%s",dq+1);
	ed[1]=dq[1],ed[2]=dq[2],ed[3]=dq[3],ed[4]=dq[4];
	scanf("%s",dq+1);
	ed[5]=dq[1],ed[6]=dq[2],ed[7]=dq[3],ed[8]=dq[4];
	scanf("%s",dq+1);
	ed[9]=dq[1],ed[10]=dq[2],ed[11]=dq[3],ed[12]=dq[4];
	scanf("%s",dq+1);
	ed[13]=dq[1],ed[14]=dq[2],ed[15]=dq[3],ed[16]=dq[4];
}
int Hash(char nu[10001])
{
	int da=0;
	for(int i=0;i<=15;i++)
	{
		if(nu[i]=='1')
		{
			da+=pow(2,16-i-1);
		}
	}
	return da;
}
void zh(int t)
{
	char yc[10001];
	for(int i=1;i<=16;i++)
	{
		if(((1<<i-1)&t)>0)
		{
			yc[i]='1';
		}
		else
		{
			yc[i]='0';
		}
	}
	for(int i=1;i<=16;i++)
	{
		ch[i]=yc[16-i+1];
	}
}
void bfs()
{
	int tou=1,wei=2;
	h[dl[1]]=1,zb[1]=0;
	while(tou<wei)
	{
		zh(dl[tou]);
		for(int i=1;i<=16;i++)
		{
			if(ch[i]=='0')
			{
				int x=0,y=0;
				if(i%4==0)
				{
					x=i/4;
				}
				else
				{
					x=i/4+1;
				}
				y=i%4;
				if(y==0)
				{
					y=4;
				}
				int k=(x-1)*4+y;
				for(int j=0;j<=3;j++)
				{
					int nx=x+dx[j];
					int ny=y+dy[j];
					if(nx>=1 && nx<=4 && ny>=1 && ny<=4 && ch[(nx-1)*4+ny]=='1')
					{
						int nk=(nx-1)*4+ny;
						char now[101];
						for(int t=1;t<=16;t++)
						{
							now[t]=ch[t];
						}
						now[k]='1';
						now[nk]='0';
						int xn=Hash(now+1);
						if(xn==js)
						{
							printf("%d",zb[tou]+1);
							return ;
						}
						if(h[xn]==0)
						{
							dl[wei]=xn;
							h[xn]=wei;
							zb[wei]=zb[tou]+1;
							wei++;
						}
					}
				}
			}
		}
		tou++;
	}
}
int main()
{
	read();
	dl[1]=Hash(st+1);
	js=Hash(ed+1);
	if(dl[1]==js)
	{
		printf("0");
		return 0;
	}
	bfs();
	return 0;
}
```

---

## 作者：Sai0511 (赞：7)

并不知道省选考这种爆搜题有什么意义。。     
### 正文部分：     
观察题目中只有12个数，每个数只有0和1，明显所以状态的数量为$2^{12}=4096$，那岂不是爆搜随便做？       
**对于1个状态hash:**
我们将现在这12位数打包成一个字符串，用$map$记录一下这个字符串是否出现过。     

**对于1个状态的unhash**,我们将这个字符串转到1个矩阵里，就是当前的状态。     
于是我们就可以轻松的得到每种情况的状态。  
**对于Bfs过程**，我们对unhash完的矩阵进行操作，每次选取其中为1的点，分4个方向向外扩散，然后压成1个新的状态，如此继续。         
### My Code:   
```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
#define il inline
#define gc getchar
using namespace std;
string S,T;
char x;
map<string,bool> vis;
int n,m,i,j,k;
int dir[4][2] = {{0,-1},{0,1},{-1,0},{1,0}};
int tmp[5][5];
struct Bfs {
    string zt;int step;
};
il int read() {
    int res = 0;char c;bool sign = 0;
    for(c = gc();!isdigit(c);c = gc()) sign |= c == '-';
    for(;isdigit(c);c = gc()) res = (res << 1) + (res << 3) + (c ^ 48);
    return sign ? -res : res;
}  
il void unhash(string s,int a[5][5]) {
    int i,j,id = 0;
    for(i = 1;i <= 4;i++) {
        for(j = 1;j <= 4;j++) {
            a[i][j] = s[id];id++;
        }
    }
    return;
}
il string hash(int a[5][5]) {
    int i,j;string res = "";
    for(i = 1;i <= 4;i++) {
        for(j = 1;j <= 4;j++) {
            res += a[i][j];
        }
    }return res;
}
il void print(int a[5][5]) {
    int i,j;
    for(i = 1;i <= 4;i++) {
        for(j = 1;j <= 4;j++) {
            printf("%d%c",a[i][j],j == n ? '\n' : ' ');
        }	
    }
}
il void bfs(string s,string t) {
    queue<Bfs> Q;while(!Q.empty()) Q.pop();
    Q.push((Bfs){s,0});vis[s] = 1;
    while(!Q.empty()) {
        string zt = Q.front().zt;int step = Q.front().step;
        Q.pop();
        if(zt == T) {
            printf("%d",step);
            exit(0);
        }
        unhash(zt,tmp);int i,j,k;
    //	print(tmp);
        for(i = 1;i <= 4;i++) {
            for(j = 1;j <= 4;j++) {
                if(!tmp[i][j]) continue;
                for(k = 0;k < 4;k++) {
                    int nx = i + dir[k][0];
                    int ny = j + dir[k][1];
                    if(nx < 1 || nx > 4 || ny < 1 || ny > 4) continue;
                    if(tmp[nx][ny]) continue;
                    tmp[nx][ny] = 1;tmp[i][j] = 0;
                    string new_zt = hash(tmp);
                    if(!vis[new_zt]) {
                        vis[new_zt] = 1;
                        Q.push((Bfs){new_zt,step + 1});
                    }
                    tmp[nx][ny] = 0;tmp[i][j] = 1;
                }
            }
        }
    }
}
int main() { S = T = "";
    for(i = 1;i <= 4;i++) {
        for(j = 1;j <= 4;j++) {
            scanf("%c",&x);
            while(!isdigit(x)) scanf("%c",&x);
            S += x - 48;
        }
    }
    for(i = 1;i <= 4;i++) {
        for(j = 1;j <= 4;j++) {
            scanf("%c",&x);
            while(!isdigit(x)) scanf("%c",&x);
            T += x - 48;
        }
    }	
    bfs(S,T);	
    return 0;
}
```


---

## 作者：Huami360 (赞：7)

其实这题可以不用状压。。

提供一种新思路。

我们在读入目标棋盘的时候，把当前位置的数和当前棋盘进行比较，如果不一样，如果当前是$1$，目标是$0$，那么我们就把当前位置加入$needmove$队列里去，否则加入$needgot$队列里去。

然后我们两遍循环，对这两个队列两两匹配，构成一个操作，表示把$needmove$里的一个位置上的$1$移到$needgot$里的一个位置上去，同时保存该操作需要的步数，就是这两个位置的曼哈顿距离。

然后进行$DFS$，枚举所有操作，若这两个位置都没变成目标状态，那么标记一下，进行这个操作，然后回溯。

还可以加一个最优性剪枝，降低时间复杂度。

这样，总能得到最优的方案。
时间复杂度也比较优秀。
码量也很少。

```cpp
#include <cstdio>
#define Open(s) freopen(s".in","r",stdin);freopen(s".out","w",stdout);
#define Close fclose(stdin);fclose(stdout);
int abs(int x){
    return x > 0 ? x : -x;
}
struct Node{
    int from, to, dis;
}e[4000];
int a[5][5], b[5][5];
int needmove[20], needgot[20], nm, ng, num, vism[4000], visg[4000], ans = 2147483647;
inline int read(){
    char ch = getchar();
    while(ch < '0' || ch > '9') ch = getchar();
    return ch - '0';
}
void dfs(int sum, int fi, int last){
    if(sum > ans) return;
    if(fi == nm){ ans = sum; return; }
    for(int i = last; i <= num; ++i)
       if(!vism[e[i].from] && !visg[e[i].to]){
         vism[e[i].from] = 1;
         visg[e[i].to] = 1;
         dfs(sum + e[i].dis, fi + 1, i + 1);
         vism[e[i].from] = 0;  //回溯
         visg[e[i].to] = 0;
       }
}
int main(){
  //Open("move");
  for(int i = 1; i <= 4; ++i)
     for(int j = 1; j <= 4; ++j)
        a[i][j] = read();
  for(int i = 1; i <= 4; ++i) //得到两个队列
     for(int j = 1; j <= 4; ++j){
        b[i][j] = read();
        if(a[i][j] != b[i][j])
          if(a[i][j] == 1)
            needmove[++nm] = i * 10 + j;
          else
            needgot[++ng] = i * 10 + j;
     }
  for(int i = 1; i <= nm; ++i)  //两两匹配记录所有可能的操作
     for(int j = 1; j <= ng; ++j)
        e[++num].from = needmove[i], e[num].to = needgot[j], 
        e[num].dis = abs(needmove[i] / 10 - needgot[j] / 10) + abs(needmove[i] % 10 - needgot[j] % 10);
  dfs(0, 0, 1);
  printf("%d\n", ans);
  //Close;
  return 0;
}

```

---

## 作者：蓝彡 (赞：7)

详情请见博客[走你](https://www.cnblogs.com/lcccAngelo/p/9882555.html)
```cpp
#include<cstdio>
#include<cstring>
#include<string>
#include<cmath>
#include<iostream>
#include<algorithm>
#include<queue>
using namespace std;
int tx[]={1,-1,0,0};//四联通图 
int ty[]={0,0,1,-1};//四联通图，注意要坐标要一一对应 
int ans; 
int f[4][4],map[4][4],ans1[4][4],ans2,vis[100010],dis[100010];
int dd(int map1[4][4])//加密 
{
	int kk=0;
	for(int i=0;i<4;i++)
	{
		for(int j=0;j<4;j++)
		{
			kk+=map1[i][j]*(1<<(i*4+j));
		}
	}
	return kk;//返回加密之后的数字，代表这种图 
}
void ff(int x)//解密 
{
	for(int i=0;i<4;i++)
	{
		for(int j=0;j<4;j++)
		{
			f[i][j]=(x>>(i*4+j))&1;//解密后存在f数组里，f就是你要的图 
		}
	}
}
void bfs(int x)
{
	queue<int>q;
	q.push(x);
	vis[x]=1;//bfs判断是否在队列里的标记，1就是在队列里，0就是不在队列里 
	dis[x]=0;//记录移动步数的变量 
	while(!q.empty())
	{
		int now=q.front();//每次从队列里取出头，就是接下来要操作的图（已经加密的） 
		q.pop();
		if(now==ans2)//判断这个图跟我们最终要的图是不是同一种的 
		{
			ans=dis[now];//记录答案，因为bfs是一圈一圈遍历的，所以最先找到的一定是最小的 
			return ;//退出bfs 
		}
		ff(now);//解密，解密后的图在f数组里 
		for(int i=0;i<4;i++)
		{
			for(int j=0;j<4;j++)
			{
				if(f[i][j]==1)//找到能够移动的点（玩具） 
				{
					for(int k=0;k<=3;k++)//四联通图遍历四个方向 
					{
						int dx=i+tx[k];
						int dy=j+ty[k];
						if(dx>=0&&dy>=0&&dx<=3&&dy<=3&&f[dx][dy]==0)//优先判断边界，判断是否（dx，dy）这个点能走 
						{
							f[dx][dy]=1;//修改 
							f[i][j]=0;//修改 
							int aa=dd(f);//加密 
							if(vis[aa]==0)//判断是否在队列里
							{
								vis[aa]=1;//不在就加入队列，vis数组标记为1 
								dis[aa]=dis[now]+1;//记录移动步数 
								q.push(aa);//加入队列 
							}
							f[dx][dy]=0;//还原，因为我们始终就用一个图，当然也可以再开一个图来存 
							f[i][j]=1;//还原 
						}
					}
				}
			}
		}
	}
}
int main()
{
	for(int i=0;i<4;i++)//读入处理 
	{
		string s;
		cin>>s;
		for(int j=0;j<s.size();j++)
		{
			map[i][j]=s[j]-'0';
			f[i][j]=map[i][j];
		}
	}
	for(int i=0;i<4;i++)//读入处理 
	{
		string s;
		cin>>s;
		for(int j=0;j<s.size();j++)
		{
			ans1[i][j]=s[j]-'0';
		}
	}
	ans2=dd(ans1);//加密，得到数值ans2，用来判断 
	int ff=dd(map);//初始的图要加密 
	bfs(ff);//bfs从初始的图开始 
	printf("%d\n",ans);//输出答案，程序结束 
	return 0;
}
```

---

## 作者：浅色调 (赞：7)

### Solution：

　　本题~~比较水~~，但是我写得快炸心态了。（因为变量名的问题，弄错了好几个变量，唉～太菜了～！）

　　从某一状态转移到另一状态，且给定了转移方法，那么不难想到，一般直接广搜就$OK$了。

　　关键如何判重和记录状态，此时由于每个状态是一个$16$位$0/1$字符串，很自然想到了状态压缩：用$1$到$2^{16}=65536$来记录每个状态，爆搜就$AC$了。至于如何转移就直接模拟好了！（本人较蠢，方法比较繁琐，话说手推了一波转移过程，～滑稽～）
  
  $\quad\;\;$欢迎来踩博客：[five20](http://www.cnblogs.com/five20/p/9043026.html)（蒟蒻写题解不易，转载请注明出处，万分感谢！）
### 代码：
```cpp
#include<bits/stdc++.h>
#define For(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)
using namespace std;
const int N=65560;
int st,ed,op[20],opt,mp[N],ans;
int dx[17][4]={
	0,0,0,0, 
	1,4,0,0, 
	-1,1,4,0, 
	-1,1,4,0, 
	-1,4,0,0, 
	-4,4,1,0, 
	-1,1,4,-4, 
	-1,1,4,-4,
	-4,4,-1,0,
	-4,4,1,0,
	-1,1,4,-4,
	-1,1,4,-4,
	-4,4,-1,0,
	-4,1,0,0,
	-4,-1,1,0,
	-4,-1,1,0,
	-4,-1,0,0
};
queue<int>q;
char s;
bool vis[N];
int main(){
	ios::sync_with_stdio(0);
	For(i,1,16)cin>>s,st=(st<<1)+s-'0';
	For(i,1,16)cin>>s,ed=(ed<<1)+s-'0';
	q.push(st);vis[st]=1;
	while(!q.empty()){
		int u=q.front();q.pop();int p=u;
		if(u==ed)break;
		For(i,1,16){op[17-i]=p%2,p>>=1;}
		For(i,1,16) For(j,0,3)
		if(dx[i][j]!=0){
			if(op[i+dx[i][j]]!=op[i]){
				swap(op[i+dx[i][j]],op[i]);
				opt=0;
				For(k,1,16) opt=(opt<<1)+op[k];
				if(!vis[opt]){
					vis[opt]=1,q.push(opt),mp[opt]=mp[u]+1;
				}
				swap(op[i+dx[i][j]],op[i]);
			}
		}
	}
	cout<<mp[ed];
	return 0;
}
```

---

## 作者：_xqy_ (赞：6)

大概说一下思路

**1.贪心**

两个图都为１时这一点按兵不动,这里蒟蒻开始认为这个贪心有问题,例如这个数据.

初: 
 
    1 0 1 1
    1 1 1 1
    0 1 0 0
    0 0 0 0
 
末: 

	1 1 1 1
    1 1 1 1
    0 0 0 0
    0 0 0 0
    
这样看初状态(3,2)的1按照上面的贪心似乎走不了,只能(2,2)的１走动,(3,2)的

1再走.其实我们可以认为(3,2)的1可以走在(2,2)的上面再走.这就与上面"按兵

不动的贪心不违背.

**2.d j**

将初位置不重复的点放入q1,末位置不重复的点放入q2

再用~~迪杰斯特拉~~跑网状图得到q1,q2两两对应最短路径的矩阵.

ps:蒟蒻最后发现没必要用dj,因为每两点的路径一定,直接dfs或bfs.

**3.d f s**

在2得到的矩阵上ｄｆｓ行与列在唯一两两对应的上的最小值.

code:

```cpp
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<queue>
using namespace std;
#define R register
long long ans=1e9+1;
int len1,len2,len3,tap,cnt,head[110],dis[110],w[20],check[110],fmap[10][10],emap[10][10],val[20][20],vis[10][10],id[10][10],dx[5]={0,-1,1,0,0},dy[5]={0,0,0,-1,1};
struct dl1{
	int x,y;
}q1[110];
struct dl2{
	int x,y;
}q2[110];
struct bian{
	int to,next,v;
}len[110];
void add(int from,int to,int v)
{
	len[++cnt].v=v;
	len[cnt].to=to;
	len[cnt].next=head[from];
	head[from]=cnt;
}
void dj(int s)
{
	for(R int k=1;k<=16;++k)
		dis[k]=19260817,check[k]=0;
	priority_queue<pair<int,int> >q;
	q.push(make_pair(0,s));
	dis[s]=0;
	while(q.size())
	{
		int now=q.top().second;
		q.pop();
		if(check[now]) continue;
		check[now]=1;
		for(R int k=head[now];k;k=len[k].next)
		{
			int to=len[k].to,v=len[k].v;
			if(dis[to]>dis[now]+v)
			{
				dis[to]=dis[now]+v;
				q.push(make_pair(-dis[to],to));
			}
		}
	}
}
void dfs(int x,long long step)
{
	if(x==len1+1)
	{
		ans=min(ans,step);
		return;
	}
	for(R int k=1;k<=len1;++k)
		if(!w[k])
		{
			w[k]=1;
			long long nowstep=step+val[x][k];
			dfs(x+1,nowstep);
			w[k]=0;
		}
}
int main()
{	
	//freopen("New.in","r",stdin);
	//freopen("New.out","w",stdout);
	for(R int i=1;i<=4;++i)
		for(R int j=1;j<=4;++j)
		{
			scanf("%1d",&fmap[i][j]);
			id[i][j]=++tap;
		}
	for(R int i=1;i<=4;++i)
		for(R int j=1;j<=4;++j)
		{
			scanf("%1d",&emap[i][j]);
			if(emap[i][j]==fmap[i][j])
				emap[i][j]=fmap[i][j]=0;
		}
	for(R int i=1;i<=4;++i)
		for(R int j=1;j<=4;++j)
			if(fmap[i][j])
				q1[++len1].x=i,q1[len1].y=j;
	for(R int i=1;i<=4;++i)
		for(R int j=1;j<=4;++j)
			if(emap[i][j])
				q2[++len2].x=i,q2[len2].y=j;
	for(R int i=1;i<=4;++i)
		for(R int j=1;j<=4;++j)	
		{
			int x=i,y=j;
			for(R int k=1;k<=4;++k)
			{
				int nowx=x+dx[k],nowy=y+dy[k];
				if(nowx>=1&&nowx<=4&&nowy>=1&&nowy<=4)
				{
					int id1=id[x][y],id2=id[nowx][nowy];
					add(id1,id2,1);
				}	
			}
		}
	for(R int i=1;i<=len1;++i)
	{
		int id1=id[q1[i].x][q1[i].y];
		dj(id1);
		for(R int j=1;j<=len2;++j)
		{
			int id2=id[q2[j].x][q2[j].y];
			val[i][j]=dis[id2];
		}
	}
	dfs(1,0);
	printf("%lld",ans);
	return 0;
}
```



    



---

## 作者：南欺姬 (赞：5)

一道比较简单的bfs题，翻题解发现各位大佬好像都是用数组来记录状态~~？？？~~其实感觉用字符串来记录会比较简单些。

------------
16个格子分别记为

| 0 |  1| 2 |  3|
| :----------: | :----------: | :----------: | :----------: |
| 4 | 5 | 6|  7|
| 8| 9 | 10 | 11 |
| 12 | 13 | 14 | 15 |

有玩具为状态为1，无玩具状态为0，玩具的移动实质是状态的交换
### 字符串记录状态
输入时从0开始将状态加入到字符串中：
```cpp
for(int i=0;i<=3;i++){
          string s;       
          cin>>s;         
          a+=s;           
      }    
```
样例用字符串记录为：
1111000011100010 

### 开数组记录位移
事先开两个数组来记录位置的移动：
```cpp
  int x[24]={0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,0,1,2,4,5,6,8,9,10};
  int y[24]={1,2,3,7,5,6,7,11,9,10,11,15,13,14,15,4,5,6,8,9,10,12,13,14};//用x,y数组来记录可以发生的移动，如从0号格子可以跳到一号和4号
```
### 广搜代码
```cpp
while(!q.empty()){  
      string c=q.front();
      q.pop();        
      if(c==b){       
         cout<<m[c]; 
         return 0;   
      }//如果字符串与目标状态字符串相等，则输出答案               
      for(int i=0;i<24;i++){
          string d=c; 
          if(d[x[i]]==d[y[i]])continue;//如果两个位置的状态相同则无须交换
          swap(d[x[i]],d[y[i]]);
          if(m[d])continue;//如果交换后该状态的字符串已存在则不必再次搜索
          q.push(d);  
          m[d]=m[c]+1;//所用步数加一                                                  
     }               
 }             
```
## 完整代码
```cpp
#include<bits/stdc++.h> 
  using namespace std;    
  int x[24]={0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,0,1,2,4,5,6,8,9,10};
  int y[24]={1,2,3,7,5,6,7,11,9,10,11,15,13,14,15,4,5,6,8,9,10,12,13,14};//记录可交换位置
  map<string,int>m;//开map记录所用步数       
 queue<string>q;         
  string a,b;             
 int main(){             
      for(int i=0;i<=3;i++){
          string s;       
          cin>>s;         
          a+=s;           
      }//记录初始状态                   
      for(int i=0;i<=3;i++){
          string s;       
         cin>>s;         
          b+=s;           
      }//记录目标状态                   
      m[a]=0;             
      q.push(a);          
      while(!q.empty()){  
          string c=q.front();
          q.pop();        
          if(c==b){       
              cout<<m[c]; 
             return 0;   
         }//判断是否已到目标状态               
          for(int i=0;i<24;i++){
              string d=c; 
              if(d[x[i]]==d[y[i]])continue;
              swap(d[x[i]],d[y[i]]);
              if(m[d])continue;
              q.push(d);  
              m[d]=m[c]+1;                                                  
         }//判断是否交换位置               
      }                   
      return 0;           
  }                       

```
------------
萌新第一次写题解，如有讲述不周到处还望提出QwQ

---

## 作者：寻旧 (赞：3)

### BFS

貌似还用到了状态压缩

观察到矩阵的每个状态都是01串

将它转化为10进制存储下来

暴力每走一步判断当前矩阵是否与最终状态相同

相同比较更新答案

用结构体存储状态

贴代码~



```cpp
#include<cstdio>
#include<cstring>
#include<cmath> 
#include<iostream>
#define re register
using namespace std;
inline int read()
{
    int w=0,f=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){w=(w<<1)+(w<<3)+(c^48);c=getchar();}
    return f?w:~w+1;
}
inline void put(int x)
{
    if(x<0) putchar('-'),x=~x+1;
    if(x>9) put(x/10);
    putchar(x%10+'0');
}
const int N=4e5+5;
const int dx[5]={0,-1,1,0,0},
          dy[5]={0,0,0,-1,1};
struct node
{
    int a[5][5],dep;//a表示矩阵元素，dep表示走到这个矩阵时所花的步数 
}list[N],h;
bool v[N];
int head=1,tail=2;
int ed,ans=999999999;
char ch[5][5];
inline int zh(node h)//二进制转十进制 
{
    int a[20],len=16,num=0;
    for(re int i=1;i<=4;++i)
      for(re int j=1;j<=4;++j)
        a[len--]=h.a[i][j];
    for(re int i=1;i<=16;++i)
      num+=a[i]*pow(2,i-1);
    return num;
}
inline void bfs()
{
    while(head<tail)
    {
        node h;int k;
        for(re int x=1;x<=4;++x)
          for(re int y=1;y<=4;++y) //暴力，让每个点去与它相邻的点交换 
			for(re int i=1;i<=4;++i) //4个方向 
        	{
            	h=list[head];
            	int xx=x+dx[i],yy=y+dy[i];//保存新的矩阵 
            	if(h.a[xx][yy]==list[head].a[x][y]) continue; //如果相同（无玩具或者两个都是玩具）不交换 
            	if(xx>=1&&xx<=4&&yy>=1&&yy<=4)//是否越界 
            	{
            	    int tt=h.a[xx][yy];
            	    h.a[xx][yy]=list[head].a[x][y];
            	    h.a[x][y]=tt; //交换元素 
            	    h.dep=list[head].dep+1; //更新步数 
            	    
             	    k=zh(h);
             	    if(!v[k]) //判断当前状态是否存在过 
            	    {
            	        v[k]=true; //没存在过，加入队列 
            	        list[tail]=h;
            	        tail++;
            	        if(k==ed) ans=min(ans,h.dep);//如果达到末尾状态，更新答案 
            	    }
            }
        }
        head++;//队头出队 
    }
}
int main()
{
    for(re int i=1;i<=4;++i) scanf("%s",ch[i]+1);
	for(re int i=1;i<=4;++i)
      for(re int j=1;j<=4;++j)
        list[1].a[i][j]=ch[i][j]^48;//存储初始状态，并加入队列 
	list[1].dep=0;
    for(re int i=1;i<=4;++i) scanf("%s",ch[i]+1);
    for(re int i=1;i<=4;++i)
      for(re int j=1;j<=4;++j)
        list[0].a[i][j]=ch[i][j]^48;//存储结束状态，放在list[0]
    
    ed=zh(list[0]);//将结束状态转化为一个数 
    int st=zh(list[1]);
    if(st==ed)  //判断步数为0的情况 
    {
    	puts("0");
    	return 0;
	}
    bfs();
    put(ans);putchar('\n');
    return 0;
}
```


蒟蒻第一次写题解

写得不好请见谅

如有bug欢迎批评指出~


---

## 作者：Space_Gold_Trash (赞：3)

### 玄学算法：深搜

抱着深搜广搜优先深搜的精神，我才不会用广搜这么~~玄学~~麻烦的东西

### 正解！！！！深搜

### now,Let's finish it by dfs.

# way

思路很简单：

已经配好了的自然不用配了

核心枚举哪两个没配好的交换

很显然，设这两点为a(x1,y1),b(x2,y2)

交换的消耗是|x1-x2|+|y1-y2|

# Parts of the code:

### swap function：

```c
inline int abs(int a){
	if(a>0)return a;
	return -a;
}
```

~~拒绝TLE，从我做起~~

```c



```
### search function：

```c
inline void search(int p,int k){
	if(p>ans)return;         //超出ans自然退出
	if(k>n1){ans=p;return;}  
	//k是用来枚举比原来的小的（也就是待枚举的0）
	int i;
	for(i=1;i<=n2;i++)   //枚举待匹配的1
	if(!vis[i]){
		vis[i]=1;
		search(p+abs(x1[k]-x2[i])+abs(y1[k]-y2[i]),k+1);
		vis[i]=0;        //回溯
	}
}
```
```



```
### main function:
```c
int main( ){
	std::ios::sync_with_stdio(false);
	int i,j;
	char s[10],a[10][10];
	for(i=1;i<=4;i++)scanf("%s",a[i]+1);  
	for(i=1;i<=4;i++) {
		scanf("%s",s+1);
		for(j=1;j<=4;j++){
			if(s[j]<a[i][j])          //如果是0且不匹配
			x1[++n1]=i,y1[n1]=j;      //储存
			else if(s[j]>a[i][j])     //如果是1且不匹配
			x2[++n2]=i,y2[n2]=j;      //储存
		}
	}
	search(0,1);                 //从1开始枚举，开始值为0
	cout<<ans;
}
```

# The whole code:
```c
#include<iostream>
#include<cstdio>
using namespace std;
inline int abs(int a){
	if(a>0)return a;
	return -a;
}
bool vis[100];
int ans=1314520,n1=0,n2=0,x1[100],x2[100],y1[100],y2[100];
inline void search(int p,int k){
	if(p>ans)return;
	if(k>n1){ans=p;return;}
	int i;
	for(i=1;i<=n2;i++)
	if(!vis[i]){
		vis[i]=1;
		search(p+abs(x1[k]-x2[i])+abs(y1[k]-y2[i]),k+1);
		vis[i]=0;
	}
}
int main( ){
	std::ios::sync_with_stdio(false);
	int i,j;
	char s[10],a[10][10];
	for(i=1;i<=4;i++)scanf("%s",a[i]+1);
	for(i=1;i<=4;i++) {
		scanf("%s",s+1);
		for(j=1;j<=4;j++){
			if(s[j]<a[i][j])
			x1[++n1]=i,y1[n1]=j;
			else if(s[j]>a[i][j])
			x2[++n2]=i,y2[n2]=j;
		}
	}
	search(0,1);
	cout<<ans;
}
```


O（懒得算，过了就是了）

~~求过求点赞~~

---

## 作者：Celebrate (赞：3)

宣传一下[MyBlog](https://blog.csdn.net/zsyzClb/article/details/86552216)

这一道题看完后思考了一会儿，感觉是蒙的，后来实在忍不住看了一下题解

其实在这一道题中每一个玩具都是一样的，所以移动时就不用判断前方是否有别的玩具了

举个例子

我们开始是 :

0 1 1 1 1 1 

然后要变成

1 1 1 1 1 0

因为玩具都是一样的，所以把玩具一个个的往左边移动和把没有与结果匹配的那个玩具直接一步步跳到为匹配的点的步数是一样的

现在这道题就变成了看哪个位置的玩具没有匹配，就把那个玩具跳到另一个没有匹配的空格子

因为数据很小，所以我们只需要用深搜来求解就行了

参考代码

```cpp
#include <iostream>
#include <cmath>
 
using namespace std ;
 
struct zb {
	int x , y ; 
}c[26] ;
int a[5][5] , b[5][5] , w[5][5][5][5] ;
bool used[5][5] ;
int sum = 0 ;
int minn = 999999999 ;
 
void search ( int pos , int v ) {
	if ( pos > sum ) {
		minn = min ( minn , v ) ;
		return ; 
	}
	for ( int i = 1 ; i <= 4 ; i ++ ) 
		for ( int j = 1 ; j <= 4 ; j ++ ) 
			if ( w[c[pos].x][c[pos].y][i][j] != 0 && !used[i][j] ) {
				used[i][j] = true ;
				search ( pos + 1 , v + w[c[pos].x][c[pos].y][i][j] ) ;
				used[i][j] = false ;
			}
}
 
int main() {
	char ee ;
	for ( int i = 1 ; i <= 4 ; i ++ ) 
		for ( int j = 1 ; j <= 4 ; j ++ ) 
			cin >> ee , a[i][j] = ee - '0' ;
	for ( int i = 1 ; i <= 4 ; i ++ ) 
		for ( int j = 1 ; j <= 4 ; j ++ ) {
			cin >> ee ; b[i][j] = ee - '0' ;
			if ( a[i][j] == b[i][j] ) 
				a[i][j] = b[i][j] = 0 ;
		}
	for ( int i = 1 ; i <= 4 ; i ++ ) 
		for ( int j = 1 ; j <= 4 ; j ++ ) 
			if ( a[i][j] == 1 ) {
				c[++sum].x = i ; c[sum].y = j ;
				for ( int k = 1 ; k <= 4 ; k ++ )
					for ( int kk = 1 ; kk <= 4 ; kk ++ )
						if ( b[k][kk] == 1 ) 
							w[i][j][k][kk] = abs(i-k) + abs(j-kk) ;
			}
	search ( 1 , 0 ) ; cout << minn << endl ;
	return 0 ;
}

```

---

## 作者：ELLIAS (赞：3)

## 这或许会是这些题解中最裸的BFS

### NULL
先看一下题面
> 在一个4*4的方框内摆放了若干个相同的玩具，某人想将这些玩具重新摆放成为他心中理想的状态，规定移动时只能将玩具向上下左右四个方向移动，并且移动的位置不能有玩具，请你用最少的移动次数将初始的玩具状态移动到某人心中的目标状态。


### EINS

很显然地发现,这道题搜索树的深度几乎是无穷的,易于想到用BFS求解. ${4 * 4}$的方阵,总共状态的个数不过 ${65535}$ 种,这告诉我们很普通的BFS就能AC本题.看到题目中每个节点的状态只有 ${0, 1}$ 两种,不难想到使用二位(二进制)哈希判重.队列手写,减小一些常数.

### ZWEI

每个状态的容器
```
struct StandNode
{
	bool a[16];

	inline int get_hash ()
	{
		register int ret = a[0];
		for (rint i = 1; i <= 15; i ++) ret = (ret<<1) + a[i];
		return ret;
	}
} nico_STA, nico_FIN;
```
`get_hash()` 用来求解每个状态的哈希值, `nico_STA` 和 `nico_nico_FIN` 存储初始状态和结束状态.

队列元素
```cpp
struct QueueNode
{
	StandNode a;
	int ste;
} que[65537];
```
存储当前状态和步数

主程序
```cpp
int main ()
{
	input ();
	int FIN = nico_FIN.get_hash();

	register int head = 0, tail = 1, diff, xpos, kiana;
	que[tail].a = nico_STA;
	sjb[nico_STA.get_hash()] = true;
	while (head < tail)
	{
		head ++;
		if (que[head].a.get_hash() == FIN)
		{
			printf ("%d", que[head].ste);
			return 0;
		}
		for (rint i = 0; i <= 15; i ++) nico_bfswork (i, i % 4, head, tail);
	}
	puts ("No Solution");
	return 0;
}
```

BFS操作函数
```
inline void nico_bfswork (register int diff, register int xpos, register int head, register int &tail)
{
	register StandNode ellias; register int kiana;
	if (xpos && !que[head].a.a[diff - 1])
	{
		ellias = que[head].a, swap (ellias.a[diff], ellias.a[diff - 1]);
		kiana = ellias.get_hash ();
		if (!sjb[kiana]) que[++ tail].a = ellias, que[tail].ste = que[head].ste + 1, sjb[kiana] = true;
	}
	if (xpos <= 2 && !que[head].a.a[diff + 1])
	{
		ellias = que[head].a, swap (ellias.a[diff], ellias.a[diff + 1]);
		kiana = ellias.get_hash ();
		if (!sjb[kiana]) que[++ tail].a = ellias, que[tail].ste = que[head].ste + 1, sjb[kiana] = true;
	}
	if (diff >= 4 && !que[head].a.a[diff - 4])
	{
		ellias = que[head].a, swap (ellias.a[diff], ellias.a[diff - 4]);
		kiana = ellias.get_hash ();
		if (!sjb[kiana]) que[++ tail].a = ellias, que[tail].ste = que[head].ste + 1, sjb[kiana] = true;
	}
	if (diff <= 11 && !que[head].a.a[diff + 4])
	{
		ellias = que[head].a, swap (ellias.a[diff], ellias.a[diff + 4]);
		kiana = ellias.get_hash ();
		if (!sjb[kiana]) que[++ tail].a = ellias, que[tail].ste = que[head].ste + 1, sjb[kiana] = true;
	}
}
```
枚举四种方向,判断是否可行,加入队列.特别提醒:`tail`一定要取地址

### DREI
代码
```
#pragma GCC optimize ("Ofast", 3)
#pragma G++ optimize ("Ofast", 3)

#include <cstdio>
#include <map>

using namespace std;

#define rint register int
#define swap(x,y) ((y)^=(x)^=(y)^=(x))
#define gc() getchar()

struct StandNode
{
	bool a[16];

	inline int get_hash ()
	{
		register int ret = a[0];
		for (rint i = 1; i <= 15; i ++) ret = (ret<<1) + a[i];
		return ret;
	}
} nico_STA, nico_FIN;

struct QueueNode
{
	StandNode a;
	int ste;
} que[65537];

inline void input ()
{
	register char c[5];
	register int pos = 0;
	for (rint t = 1; t <= 4; t ++)
	{
		scanf ("%s", c);
		for (rint i = 0; i <= 3; i ++) nico_STA.a[pos ++] = c[i] - '0';
	}
	pos = 0;
	for (rint t = 1; t <= 4; t ++)
	{
		scanf ("%s", c);
		for (rint i = 0; i <= 3; i ++) nico_FIN.a[pos ++] = c[i] - '0';
	}
}

map <int, bool> sjb;

inline void nico_bfswork (register int diff, register int xpos, register int head, register int &tail)
{
	register StandNode ellias; register int kiana;
	if (xpos && !que[head].a.a[diff - 1])
	{
		ellias = que[head].a, swap (ellias.a[diff], ellias.a[diff - 1]);
		kiana = ellias.get_hash ();
		if (!sjb[kiana]) que[++ tail].a = ellias, que[tail].ste = que[head].ste + 1, sjb[kiana] = true;
	}
	if (xpos <= 2 && !que[head].a.a[diff + 1])
	{
		ellias = que[head].a, swap (ellias.a[diff], ellias.a[diff + 1]);
		kiana = ellias.get_hash ();
		if (!sjb[kiana]) que[++ tail].a = ellias, que[tail].ste = que[head].ste + 1, sjb[kiana] = true;
	}
	if (diff >= 4 && !que[head].a.a[diff - 4])
	{
		ellias = que[head].a, swap (ellias.a[diff], ellias.a[diff - 4]);
		kiana = ellias.get_hash ();
		if (!sjb[kiana]) que[++ tail].a = ellias, que[tail].ste = que[head].ste + 1, sjb[kiana] = true;
	}
	if (diff <= 11 && !que[head].a.a[diff + 4])
	{
		ellias = que[head].a, swap (ellias.a[diff], ellias.a[diff + 4]);
		kiana = ellias.get_hash ();
		if (!sjb[kiana]) que[++ tail].a = ellias, que[tail].ste = que[head].ste + 1, sjb[kiana] = true;
	}
}

int main ()
{
	input ();
	int FIN = nico_FIN.get_hash();

	register int head = 0, tail = 1, diff, xpos, kiana;
	que[tail].a = nico_STA;
	sjb[nico_STA.get_hash()] = true;
	while (head < tail)
	{
		head ++;
		if (que[head].a.get_hash() == FIN)
		{
			printf ("%d", que[head].ste);
			return 0;
		}
		for (rint i = 0; i <= 15; i ++) nico_bfswork (i, i % 4, head, tail);
	}
	puts ("No Solution");
	return 0;
}
```

---

## 作者：Sym_Je (赞：3)

调了一个多小时，静态查错就写了快70行，从dfs调到了bfs（呜呜呜~~~

    ok这道题就是一个典型的状压题+爆搜+可行性剪枝（2的16次方==65536，所以最大就是65535）
    我们在看看爆搜，我们可以发现每一个都是由另一个状态转移过来的，但这个状态不是一个连续的状态，而是一个随机的状态，所以我们用bfs来存每一个状态，然后看他能转移到那些状态，在扔到站，知道找到与目标状态一样的状态，来更新ans
    设该为二进制后某个位置为x（从左向右）
    文中说可以上下左右走，呢么改完二进制后就看上（x+4）,下（x-4),左（x+1),右(x-1)，是否有数，并且判一下边界情况，如（
    0000
    0000
    0000
    0001
    中1就不能向下或向右）把一周特判一下就好咯
    
    
    然后就是剪枝
    我们直接标记一下这个状态走没走过就ok了

   ```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cstdio>
#include<queue>
using namespace std;

char aa[5][5];
char bb[5][5];

int a[5][5];
int b[5][5];

int ks;
int js;

int ans=21111111;

int dp[2000032];
int vis[2000032];

queue<int>q;

void bfs(int zt)
{
	q.push(zt);
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		if(dp[u]>ans)
		return ;
		if(u==js)
		{ 
			ans=min(dp[u],ans);
			return ;
		}
		for(int i=0;i<=15;i++)
		{
			if((1<<i)&u)
			{
				if(((1<<(i+1))&u)==0&&i!=15&&i!=3&&i!=7&&i!=11)
				{
					int v=u-(1<<i)+(1<<(i+1));
					dp[v]=min(dp[v],dp[u]+1);
					if(!vis[v])
					q.push(v);
					if(v==js)
					{
						ans=min(dp[v],ans);
					}
					
				}
				if(((1<<(i-1)&u))==0&&i!=0&&i!=4&&i!=8&&i!=12)
				{
					int v=u-(1<<i)+(1<<(i-1));
					dp[v]=min(dp[v],dp[u]+1);
					if(!vis[v])
					q.push(v); 
					vis[v]=1;
					if(v==js)
					{
						ans=min(dp[v],ans);
					}
				
				}	
				if(i!=0&&i!=1&&i!=2&&i!=3&&((1<<(i-4))&u)==0)
				{
					int v=u-(1<<i)+(1<<(i-4));
					dp[v]=min(dp[v],dp[u]+1); 
					if(!vis[v])
					q.push(v);
					vis[v]=1;
					if(v==js)
					{
						ans=min(dp[v],ans);
					}
				}
				if(i!=15&&i!=14&&i!=13&&i!=12&&((1<<(i+4))&u)==0)
				{
					int v=u-(1<<i)+(1<<(i+4));
					dp[v]=min(dp[v],dp[u]+1); 
					if(!vis[v])
					q.push(v);
					vis[v]=1;
					if(v==js)
					{
						ans=min(dp[v],ans);
					}
				}	
			}
		}
	}
	

}

int main()
{
	memset(dp,0x3f,sizeof(dp));
	for(int i=1;i<=4;i++)
	{
		for(int j=1;j<=4;j++)
		{
			cin>>aa[i][j];
			a[i][j]=aa[i][j]-'0';
		}
	}
	for(int i=1;i<=4;i++)
	{
		for(int j=1;j<=4;j++)
		{
			cin>>bb[i][j];
			b[i][j]=bb[i][j]-'0';
		}
	}
	for(int i=1;i<=4;i++) 
	{
		for(int j=1;j<=4;j++)
		{
			ks=ks*2+a[i][j];
		}
	}
	for(int i=1;i<=4;i++)
	{
		for(int j=1;j<=4;j++)
		{
			js=js*2+b[i][j];
		}
	}
	dp[ks]=0;
	bfs(ks);
	printf("%d",ans);
	return 0;
}



```

---

## 作者：_qingshu_ (赞：2)

这是本题一篇费用流做法的题解，如果不是以练习费用流为目的的建议跳过。

# 题意;

给定两个 $4\times 4$ 的矩阵，若 $mp_{i,j}=1$ 则表示该点有玩具，每一步可以移动任意一个玩具到其上下左右的其中一格，允许两个玩具在同一个点，询问从第一个图移动到第二个图的最小步数。

# 建模：

默认您已经学会了费用流的原理与板子，下面将讲解建模思路。

首先建立一个超级源与超级汇，超级源可以向第一个图中的每一个 $\texttt{1}$ 连接一条流量为 $1$，费用为 $0$ 的边，表示考虑移动当前这个玩具。超级汇同理，第二个图中的每一个 $\texttt{1}$ 向超级汇连接一条流量为 $1$ 费用为 $0$ 的边，表示满足了有玩具在这个点的要求。

考虑移动，每一次移动等同于流向了上下左右其中一个点，产生费用 $1$，又因为同一条路线允许经过多次，所以每一个点向它上下左右四个点连一条流量为 $inf$，费用为 $1$ 的边。

这样我们跑出来的最小费用就是最小步数了。

# Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
char mp[520][520];
struct edge{
	int to,nxt;
	int val,spendf;
}e[5200010];
int tot=1,head[5200010],s,t;
inline void add(int nxt,int to,int val,int spendf){
	e[++tot].to=to;
	e[tot].nxt=head[nxt];
	e[tot].val=val;
	e[tot].spendf=spendf;
	head[nxt]=tot;
	
	e[++tot].to=nxt;
	e[tot].nxt=head[to];
	e[tot].val=0;
	e[tot].spendf=-spendf;
	head[to]=tot;
}
int ans=0,dis[5200010],vis[5200010];
inline bool spfa(){
	for(int i=1;i<=1002;i++){
		dis[i]=INT_MAX;
	}
	queue<int>q;
	q.push(s);
	dis[s]=0;
	vis[s]=1;
	while(!q.empty()){
		int x=q.front();
		q.pop();
		vis[x]=0;
		for(int i=head[x];i;i=e[i].nxt){
			int v=e[i].to;
			if(e[i].val&&dis[v]>dis[x]+e[i].spendf){
				dis[v]=dis[x]+e[i].spendf;
				if(!vis[v]){
					vis[v]=1;
					q.push(v);
				} 
			} 
		}
	}
	return dis[t]!=INT_MAX;
}
inline int dfs(int x,int sum){
	if(x==t)return sum;
	int res=0;
	vis[x]=1;
	for(int i=head[x];i&&sum;i=e[i].nxt){
		int v=e[i].to;
		if(e[i].val&&!vis[v]&&dis[v]==dis[x]+e[i].spendf){
			int k=dfs(v,min(sum,e[i].val));
			e[i].val-=k;
			e[i^1].val+=k;
			sum-=k;
			res+=k; 
			ans+=k*e[i].spendf;
		} 
	}
	vis[x]=0;
	return res;
}
inline void dinic(){
	while(spfa()){
		dfs(s,INT_MAX);
	}
}
int cx[]={1,0,0,-1};
int cy[]={0,1,-1,0};
int main(){
	s=1001;t=s+1;
	for(int i=1;i<=4;i++){
		for(int j=1;j<=4;j++){
			cin>>mp[i][j];
			if(mp[i][j]=='1'){
				add(s,(i-1)*4+j,1,0);
			}
			for(int k=0;k<4;k++){
				int x=i+cx[k],y=j+cy[k];
				if(x>=1&&x<=4&&y>=1&&y<=4){
					add((i-1)*4+j,(x-1)*4+y,INT_MAX,1);
				}
			}
		} 
	}
	for(int i=1;i<=4;i++){
		for(int j=1;j<=4;j++){
			cin>>mp[i][j];
			if(mp[i][j]=='1'){
				add((i-1)*4+j,t,1,0);
			}
		} 
	}
	dinic();
	cout<<ans;
}
```

---

## 作者：怺忆 (赞：2)

这其实是一道大水题

为什么这么说呢？

因为 DFS可以解决！

首先是读取数据，和预处理

另外，我们还要知道一个事实，就是一个玩具移到一个有
玩具的位置，就可以直接穿过去

因为 i 号想移动到 j 号，途中遇到 k 号，i 号就可以留在 k 号位置，然后 k 号帮 i 号接着走，等同于 i 号穿过 k 号，所以，变化前与变化后都有玩具的地方可以忽略，不会阻碍到其他玩具
```cpp
int read(){
	char ch=getchar();
	for(int i=0;i<=1;i++)
	for(int j=1;j<=4;j++){
    	while(ch!='0'&&ch!='1') ch=getchar();
    	for(int k=1;k<=4;k++) a[i][j][k]=ch-'0',ch=getchar();
	}
	for(int i=1;i<=4;i++)
	for(int j=1;j<=4;j++){
    	if(a[0][i][j]-a[1][i][j]<0) s[0][++m_1][0]=i,s[0][m_1][1]=j;
    	if(a[0][i][j]-a[1][i][j]>0) s[1][++m_2][0]=i,s[1][m_2][1]=j;
	}
	for(int i=1;i<=m_1;i++)
	for(int j=1;j<=m_2;j++)
	f[i][j]=abs(s[0][i][0]-s[1][j][0])+abs(s[0][i][1]-s[1][j][1]);
}
```
f 数组记录 i，j 两个玩具之间距离
```cpp
int dfs(int i){
	if(i>m_1){ans=min(ans,an);return 0;}
	for(int j=1;j<=m_2;j++){
		if(v[j]) continue;
		an+=f[i][j];v[j]=1;
		dfs(i+1);
		an-=f[i][j];v[j]=0;
	}
}
```
i枚举移动前的玩具，j枚举移动后的玩具

v 数组记录使用过的玩具，dfs（）结束后记得v[j]=0;

an记录现在的答案，ans记录所以最小值

AC代码如下
```cpp
#include<bits/stdc++.h>
using namespace std;
int ans=1<<30,s[2][17][2],f[17][17],a[2][5][5],m_1,m_2,an;
bool v[17];
int read(){
	char ch=getchar();
	for(int i=0;i<=1;i++)
	for(int j=1;j<=4;j++){
    	while(ch!='0'&&ch!='1') ch=getchar();
    	for(int k=1;k<=4;k++) a[i][j][k]=ch-'0',ch=getchar();
	}
	for(int i=1;i<=4;i++)
	for(int j=1;j<=4;j++){
    	if(a[0][i][j]-a[1][i][j]<0) s[0][++m_1][0]=i,s[0][m_1][1]=j;
    	if(a[0][i][j]-a[1][i][j]>0) s[1][++m_2][0]=i,s[1][m_2][1]=j;
	}
	for(int i=1;i<=m_1;i++)
	for(int j=1;j<=m_2;j++)
	f[i][j]=abs(s[0][i][0]-s[1][j][0])+abs(s[0][i][1]-s[1][j][1]);
}
int dfs(int i){
	if(i>m_1){ans=min(ans,an);return 0;}
	for(int j=1;j<=m_2;j++){
		if(v[j]) continue;
		an+=f[i][j];v[j]=1;
		dfs(i+1);
		an-=f[i][j];v[j]=0;
	}
}
int main(){
	freopen("1.in","r",stdin);
	freopen("1.out","w",stdout);
	read();dfs(1);
	printf("%d",ans);
	return 0;
}
```



---

## 作者：剑阁泪 (赞：2)

- 状压题解
- 先将目标和初始的状态压缩
- 然后从初始状态开始搜索，每次变了一个状态就更新这个状态需要的步数，直到搜到目标状态
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
using namespace std;
queue<int>q;
int goal,start,dis[1000001];
char s[10];
int main()
{
	memset(dis,0x3f3f3f3f,sizeof(dis));//初始化 
	for(int i=1;i<=4;i++)
	{
        scanf("%s",s+1);
        for(int j=1;j<=4;j++)
		{
            start|=(s[j]-'0')*(1<<((i-1)*4+j));//状态压缩，将原来的状态压缩 
        }
    }
    for(int i=1;i<=4;i++)
	{
        scanf("%s",s+1);
        for(int j=1;j<=4;j++)
		{
            goal|=(s[j]-'0')*(1<<((i-1)*4+j));//状态压缩，将目标的状态压缩 
        }
    }
    dis[start]=0;
	q.push(start);
	while(!q.empty())
	{
		int x=q.front();
		q.pop();
		if(x==goal)//找到目标 
		{
			break;
		}
		for(int i=1;i<=16;++i)
		{
			if(x&(1<<i))
			{
			    if(i+4<=16&&!(x&(1<<(i+4)))&&dis[(x^(1<<i))|1<<(i+4)]>dis[x]+1)//向下搜 
				{
                    dis[(x^(1<<i))|1<<(i+4)]=dis[x]+1;
                    q.push((x^(1<<i))|1<<(i+4));
                }
                if(i-4>=1&&!(x&(1<<(i-4)))&&dis[(x^(1<<i))|1<<(i-4)]>dis[x]+1)//向上搜 
				{
                    dis[(x^(1<<i))|1<<(i-4)]=dis[x] + 1;
                    q.push((x^(1<<i))|1<<(i - 4));
                }
                if(i%4!=0&&!(x&(1<<(i + 1)))&&dis[(x^(1 << i))|1<<(i+1)]>dis[x]+1)//向右搜 
				{
                    dis[(x^(1<<i))|1<<(i+1)]=dis[x]+1;
                    q.push((x^(1<<i))|1<<(i+1));
                }
                if(i%4!=1&&!(x&(1<<(i-1)))&&dis[(x^(1<<i))|1<<(i-1)]>dis[x]+1)//向左搜 
				{
                    dis[(x^(1<<i))|1<<(i-1)]=dis[x]+1;
                    q.push((x^(1<<i))|1<<(i-1));
                }
			}
		}
	}
	printf("%d",dis[goal]);
	return 0;
}
```


---

## 作者：KevinSo (赞：2)

  这是本蒟蒻的第一篇题解，如有不足，请见谅
  
   这一题是一道省选题，与黑白棋很相像，考的是hash，但这题毕竟**输入只有 _4*4_ **，所需移动的玩具很少，所以这题 **_暴搜_** 就可以过！！！！
      
   而hash的做法其他dalao已经给出了题解了，我就只写本蒟蒻的暴搜做法。。
   
   好了，上代码...
      
```cpp
#include<cstdio>
#include<iostream>
#include<string>
#include<algorithm>
using namespace std;
int tot1,tot2,minn=0x7fffff,pd=1;
bool b[16]={0};
int s[5][5]/*起始图*/,e[5][5]/*结束图*/,z[16][3]/*需转移的玩具（1、2分别记录x坐标与y坐标）*/,dz[16][3],/*玩具应转移到的点*/cs[16][16];/*转移所需次数*/
void bs(int x,int zs,int sum)//暴搜（x为需转移的玩具的序号、zs为转移了zs个玩具）
{
    for(int i=1;i<=tot1;i++)
    {
        if(!b[i])//判断改点是否已有玩具 
        {
            b[i]=1; 
            if(zs+1==tot1) minn=min(minn,sum+cs[x][i]);
            else bs(x+1,zs+1,sum+cs[x][i]);
            b[i]=0;
        }
    }
} 
int main()
{
    for(int i=1;i<=4;i++)
    for(int j=1;j<=4;j++)
    {
        char a;
        a=getchar();
        while(a!='0'&&a!='1') a=getchar();
        s[i][j]=a-'0';
    }
    for(int i=1;i<=4;i++)
    for(int j=1;j<=4;j++)
    {
        char a;
        a=getchar();
        while(a!='0'&&a!='1') a=getchar();
        e[i][j]=a-'0';
    }
    for(int i=1;i<=4;i++)
    for(int j=1;j<=4;j++)
    {
        if(s[i][j]!=e[i][j]&&s[i][j])
        {
			pd=0;
            z[++tot1][1]=i;
            z[tot1][2]=j;
        }
        else if(s[i][j]!=e[i][j]&&!s[i][j])
        {
			pd=0;
            dz[++tot2][1]=i;
            dz[tot2][2]=j;
        }
    }
    if(pd==1)
    {
		cout<<"0";
		return 0;
	}
    for(int i=1;i<=tot1;i++)//记录转移次数（距离） 
    for(int j=1;j<=tot1;j++)
    {
        if(z[i][1]!=dz[j][1]) cs[i][j]+=abs(z[i][1]-dz[j][1]);
        if(z[i][2]!=dz[j][2]) cs[i][j]+=abs(z[i][2]-dz[j][2]);
    }
    bs(1,0,0);
    printf("%d",minn);
    return 0;
}
```

---

## 作者：Eason_AC2 (赞：2)

主要参照[这篇题解（第一页第一篇）](https://www.luogu.org/problemnew/solution/P1225)，作者为本人教练。

讲解在注释里都有，自己看看吧。
```cpp
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <queue>
using namespace std;

int pre[6][6], tar[6][6], vis[65539], f[65539], dec1, dec2;
queue<int> q;
const int dx[4] = {-1, 1, 0, 0}, dy[4] = {0, 0, -1, 1};
	/*
		变量：
		pre数组表示初始状态，dec1表示初始状态转化的十进制数。
		tar数组表示目标状态，dec2表示目标状态转换的十进制数。
		vis数组表示是否被访问过。 
		q队列用来存储玩具摆放的状态。 
		dx和dy数组是为了方便表示扩展而使用的。 
		有关玩具放置的状态的转化请移步至函数1。 
	*/
int BintoDec(int a[6][6]) { 
	/*	
		函数1：int BintoDec(int a[6][6])
		此函数的目的：
			根据a数组，将玩具摆放的状态转化为十进制数。 
		变量解释： 
			a数组表示要转换的玩具摆放的状态。 
		具体思想： 
			由于每种玩具摆放的状态都是唯一的， 
			所以我们尝试着将其转化为一个数字。
			大家可以发现，每种玩具摆放的状态其实是二进制的表示。
			所以我们可以将其转化为十进制的数。
			例如：样例中，初始状态可以转化为：1111000011100010。 
			所以可以将其转化为十进制的数。 
			可能你会考虑爆long long或爆空间的问题。
			放心，玩具摆放的状态用十进制表示必不会超过2^16-1。
			所以，我们可以将样例中的起始状态和目标状态
			分别表示为61666和42405。
			具体怎么转化呢？
			我们先画一个玩具摆放的状态图：	 
			  1     2     3     4
			1 15	14    13    12
			2 11    10    9     8
			3 7     6     5     4
			4 3     2     1     0
			可以发现，每个格子对应的乘方有如下的规律：
			设格子(i,j)对应的乘方为G(i,j)，
			则有：G(i,j) = 16 - (i - 1) * 4 - j。
			这个稍微想一下就可以证明出来，这里不再赘述。 
	*/
	int res = 0;
	for(int i = 4; i >= 1; --i)
		for(int j = 4; j >= 1; --j)
			res += a[i][j] * pow(2, 16 - (i - 1) * 4 - j);
	return res;
}
	
void DectoBin(int x, int a[6][6]) {
	/*
		函数2：void DectoBin(int x, int a[6][6])
		此函数的目的：
			根据x，将十进制状态转换回一开始二进制的状态。
		变量解释： 
			x表示要转换回的十进制数，
			a数组表示转换后的二进制状态。 
		具体思想：
			呃。。。这就不用解释了吧。
			这个大家应该很明白吧。
			不明白就去看有关二进制的内容吧。 
	*/
	while(x) {
		for(int i = 4; i >= 1; --i)
			for(int j = 4; j >= 1; --j) {
				a[i][j] = x % 2;
				x /= 2;
			}
	} 
	//转换完毕 
}
int judge(int x0, int y0, int xx, int yy) {
	/*
		函数3：int judge(int x0, int y0, int xx, int yy)
		此函数的目的：
			判断是否越过边界且点所表示的数是否相同，是返回1，否表示0
		变量解释：
			xx,yy分别是点(x0,y0)经过扩展后得到的点的横坐标和纵坐标。
		具体思想：\ 
	*/
	return (xx >= 1) && (xx <= 4) && (yy >= 1) && (yy <= 4) && (pre[x0][y0] != pre[xx][yy]);
}
void bfs() {
	/*
		函数4：void bfs()
		此函数的目的：
			通过bfs求得最少步数。 
		变量解释：\
		具体思想：
			基本的bfs（STL<queue>）操作：
			1. 将初始状态入队，并标记在队列中（vis[x]=1）
			2. 在队列不为空时循环执行以下操作：
				(1)取出队首，将其转化为原来的二进制状态，然后出队。
				(2)向上下左右扩展。 
				(3)判断是否越过边界且两数相等。 
				if No then执行以下操作（最后需要还原a数组状态！）:
					1_ 提取扩展节点的状态，并将其转化为十进制数。 
					2_ 将扩展节点与原数交换
					3_ 记录交换后的数组对应的十进制数
					4_ 判断是否访问过
					5_ 若没访问过，则标记已访问过，并记录交换后的数组对应的十进制数的父节点，即交换前的数组对应的十进制数。 
					6_ 否则直接跳过。 
					7_ 如果已经达到了目标状态，直接返回。
				else then直接跳过 
	*/
	q.push(dec1);
	vis[dec1] = 1;/*注意！一定要加！！！*/ 
	while(q.size()/*或者可以写!q.empty()*/) {
		int now = q.front();
		DectoBin(now, pre);
		q.pop();
		for(int i = 1; i <= 4; ++i)
			for(int j = 1; j <= 4; ++j) {
				int x0 = i, y0 = j;
				for(int k = 0; k < 4; ++k) {
					int xx = x0 + dx[k], yy = y0 + dy[k], flag = 0;
					if(judge(x0, y0, xx, yy)) {
						flag = 1;
						int tmpdec1 = BintoDec(pre);
						swap(pre[x0][y0], pre[xx][yy]);
						int tmpdec2 = BintoDec(pre);
						if(!vis[tmpdec2]) {
							vis[tmpdec2] = 1;
							f[tmpdec2] = tmpdec1;
							q.push(tmpdec2); 
						}
						if(tmpdec2 == dec2)	return;
					}
					if(flag)
						swap(pre[x0][y0], pre[xx][yy]);
				}
			} 
	}
}
int main() {
	/*
		Step 1:输入&转化为二进制 
		由于输入形式中，数字都是连在一起的。 
		所以，大多数人都会想到用字符串或字符数组输入每一行， 
		然后将其转化为数字。但其实可以不用这么麻烦。
		大家都知道，占x位输入是这么写的：
		scanf("%xd", &a);（假定x是具体数字）
		所以，对于一行连在一起的数字，我们可以占一位输入。
		就是上面所写的那样。这样就可以使代码简洁明了。
		然后再调用上面的BintoDec函数得到初始和目标状态的十进制数。 
	*/ 
	for(int i = 1; i <= 4; ++i)
		for(int j = 1; j <= 4; ++j)
			scanf("%1d", &pre[i][j]);
	for(int i = 1; i <= 4; ++i)
		for(int j = 1; j <= 4; ++j)
			scanf("%1d", &tar[i][j]);
	dec1 = BintoDec(pre), dec2 = BintoDec(tar);
	/*
		Step 2:bfs一波走着！
		根据上面的函数，保证会有解。 
	*/ 
	bfs();
	f[dec1] = 0;
	int ans = 0;
	/*
		Step 3:递进求答案、输出&程序结束 
	*/
	while(f[dec2])	ans++, dec2 = f[dec2];
	printf("%d", ans);
	return 0; 
} 
```

---

## 作者：Celtic (赞：1)

BFS经典题。

将棋盘状态压缩成一个$16$位$2$进制数，然后暴力枚举每个位置，移动棋子。

移动时用位运算移动，哈希表判重。

然后我们记录步骤时只需要判断一下从哪个状态转移过来的。

代码中使用了$map$代替哈希表，简化代码。

具体代码如下
```cpp
#pragma GCC optimize(2)
#include<bits/stdc++.h>
#define eps 1e-20
#define re register
#define N 2001001
#define MAX 2001
using namespace std;
typedef long long ll;
typedef double db;
inline void read(re ll &ret)
{
    ret=0;re ll pd=0;re char c=getchar();
    while(!isdigit(c)){pd|=c=='-';c=getchar();}
    while(isdigit(c)){ret=(ret<<1)+(ret<<3)+(c^48);c=getchar();}
	ret=pd?-ret:ret;
}
ll a,b,tot;
char s[MAX][MAX];
ll d[5]={0,-4,4,1,-1};
ll dx[5]={0,-1,0,1,0};
ll dy[5]={0,0,1,0,-1};
struct node
{
	ll a,deep,t,data;
	ll fa;
/*	node(re ll x,re ll y,re ll z,re ll w)
	{
		a=x;
		deep=y;
		t=w;
		fa=z;
	}*/
};
node ans[N];
queue<node>q;
map<ll,bool>vis;
int main()
{
	for(re int i=1;i<=4;i++)
		for(re int j=1;j<=4;j++)
		{
			s[i][j]=getchar();
			while(s[i][j]!='0'&&s[i][j]!='1')
				s[i][j]=getchar();
			a=(a<<1)+(s[i][j]&15);
		}
	for(re int i=1;i<=4;i++)
		for(re int j=1;j<=4;j++)
		{
			s[i][j]=getchar();
			while(s[i][j]!='0'&&s[i][j]!='1')
				s[i][j]=getchar();
			b=(b<<1)+(s[i][j]&15);
		}
	re node tmp;
	tmp.a=a;
	tmp.deep=0;
	tmp.fa=0;
	tmp.t=0;
	tmp.data=++tot;
	ans[tot]=tmp;
	q.push(tmp);
	while(!q.empty())
	{
		re node tmp=q.front();
		q.pop();
		if(vis[tmp.a])continue;
		vis[tmp.a]=true;
	/*	printf("%lld\n",tmp.deep);
		re node tt=tmp;
		while(tmp.fa)
		{
			printf("%lld\n",tmp.t);
			tmp=ans[tmp.fa];
		}	
		tmp=tt;
		putchar('\n');
		cout<<tmp.a<<endl;
		for(re int i=15;i!=-1;i--)
		{
			printf("%lld",bool((1ll<<i)&tmp.a));
			if(i==12||i==8||i==4||i==0)
				putchar('\n');
		}
			
		putchar('\n');
		system("pause");
	*/
		if(tmp.a==b)
		{
			printf("%lld\n",tmp.deep);
		/*	while(tmp.fa)
			{
				printf("%lld%lld%lld%lld\n",tmp.t/10%10,tmp.t%10,tmp.t/1000%10,tmp.t/100%10);
				tmp=ans[tmp.fa];
			}*/
			exit(0);
		}
	 	node nn=tmp;
		for(re int i=0;i<16;i++)
		{
			if((1<<i)&tmp.a)
			for(re int j=1;j<=4;j++)
			{
				if(16-i+d[j]<=0||16-i+d[j]>16)continue;
				re ll w=ll(ceil(((16-i)/4.0))),x=((16-i)%4==0?4:(16-i)%4),y=ll(ceil(((16-i)+d[j])/4.0)),z=(((16-i)+d[j])%4==0?4:((16-i)+d[j])%4);
				re bool flag=false;
				for(re int k=1;k<=4;k++)
					if(w+dx[k]==y&&x+dy[k]==z)
					{
						flag=true;
						break;
					}
				if(!flag)continue;
				re bool t1=((1<<i)&tmp.a),t2=((1<<(i-d[j]))&tmp.a);
				if(t2)continue;
				nn=tmp;
				if(t1)
					nn.a|=(1<<(i-d[j]));
				else 
					nn.a&=(~(1<<(i-d[j])));
				if(t2)
					nn.a|=(1<<(i));
				else 
					nn.a&=(~(1<<(i)));
				nn.deep++;
				nn.t=ll(ceil(((16-i)/4.0)))*1000+((16-i)%4==0?4:(16-i)%4)*100+ll(ceil(((16-i)+d[j])/4.0))*10+(((16-i)+d[j])%4==0?4:((16-i)+d[j])%4);
				nn.fa=tmp.data;
				nn.data=++tot;
				ans[tot]=nn;
				q.push(nn);
			}
		}
	}
    exit(0);
}
```


---

## 作者：博丽灵梦、 (赞：1)

## 代码极丑警告

map与string配合bfs，简单粗暴（~~我对我的乡土码风还是很有自信的~~）

上下左右的移动可以浓缩一下，不过毕竟这样的工程量也不大

不过这么大量使用switch case结构其实挺蠢的，这是可以优化的地方

代码里已经讲明白了，也不需要再注意什么

```cpp
/*
0  1  2  3
4  5  6  7
8  9  10 11
12 13 14 15
*/


#include <iostream>
#include <map>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <queue>
#include <algorithm>
using namespace std;
map<string,string> mp;
queue<string> sp;
string st;
string op;
void bfs()
{
	while(!sp.empty())
	{
		string tmp=sp.front();
		sp.pop();
		for(int i=0;i<16;i++)
		{
			if(tmp[i]=='1')
			{
				/*左移*/
				switch(i)
				{
					case 0:
					case 4:
					case 8:
					case 12:
						break;
					default:
						string x=tmp;
						if(tmp[i-1]=='0')
						{
							x[i-1]=tmp[i],x[i]=tmp[i-1];
							if(mp.count(x)==0)
							{
								sp.push(x);
								mp[x]=mp[tmp]+'X';
							}
						}
						break;
				}
				/*右移*/
				switch(i)
				{
					case 3:
					case 7:
					case 11:
					case 15:
						break;
					default:
						string x=tmp;
						if(tmp[i+1]=='0')
						{
							x[i+1]=tmp[i],x[i]=tmp[i+1];
							if(mp.count(x)==0)
							{
								sp.push(x);
								mp[x]=mp[tmp]+'X';
							}
						}
						break;
				}
				/*上移*/
				switch(i)
				{
					case 0:
					case 1:
					case 2:
					case 3:
						break;
					default:
						string x=tmp;
						if(tmp[i-4]=='0')
						{
							x[i-4]=tmp[i],x[i]=tmp[i-4];
							if(mp.count(x)==0)
							{
								sp.push(x);
								mp[x]=mp[tmp]+'X';
							}
						}
						break;
				}
				/*下移*/
				switch(i)
				{
					case 12:
					case 13:
					case 14:
					case 15:
						break;
					default:
						string x=tmp;
						if(tmp[i+4]=='0')
						{
							x[i+4]=tmp[i],x[i]=tmp[i+4];
							if(mp.count(x)==0)
							{
								sp.push(x);
								mp[x]=mp[tmp]+'X';
							}
						}
						break;
				}
				/*over*/
				if(mp.count(op))
				{
					cout<<mp[op].size()<<endl;
					return;
				} 
				
			}
		}
	}
}
int main()
{
	for(int i=0;i<4;i++)
	for(int j=0;j<4;j++)
	{
		char ch;
		cin>>ch;
		st+=ch;
	}cin.get();
	sp.push(st);
	mp[st]="";
	for(int i=0;i<4;i++)
	for(int j=0;j<4;j++)
	{
		char ch;
		cin>>ch;
		op+=ch;
	}
	bfs();
}
```


---

## 作者：Leianha (赞：1)

## 状压bfs
一共有16个位置，最多会有$2^{16}=65536$种情况，用数组完全开的下。

用二进制中的1表示该位置有玩具，0表示该位置没有玩具。

由于广搜最先搜到的是最优解，直接用数组记录是否到达过该状态，顺便记录ans.

移动前的状态ans为0.

~~然后大力讨论12种情况即可~~

时间复杂度O($2^{16}$) ~~O(能过)~~

献上我~~又臭又长~~的代码


```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;
int z[524289],pan[524289];
int a,b,d;
char c;
queue<int>q;
int ex(int s,int li,int ri)
{
	return (s^(1<<li))^(1<<ri);
}
void fang(int xx,int fa)
{
	if(pan[xx]==0)
	{
		pan[xx]=1;
		z[xx]=z[fa]+1;
		q.push(xx);
	}
}
int main()
{
	//freopen("toy.in","r",stdin);
	//freopen("toy.out","w",stdout);
	for(int i=1;i<=16;++i)
	{
		cin>>c;
		a=(a<<1)|(c-'0');
	}
	for(int i=1;i<=16;++i)
	{
		cin>>c;
		b=(b<<1)|(c-'0');
	}
	if(a==b)
	{
		cout<<"0";
		return 0;
	}
	pan[a]=1;
	q.push(a);
	while(!q.empty())
	{
		int x=0;
		d=q.front();
		q.pop();
		if(d&(1<<15))//1号位 
		{
			if((d&(1<<14))==0)
			{
				x=ex(d,15,14);
				fang(x,d);
			}
			if((d&(1<<11))==0)
			{
				x=ex(d,15,11);
				fang(x,d);
			}
		}
		for(int i=2;i<=3;++i)//2~3号位 
		{
			if(d&(1<<(16-i)))
			{
				if((d&(1<<(16-i+1)))==0)
				{
					x=ex(d,16-i,16-i+1);
					fang(x,d);
				}
				if((d&(1<<(16-i-1)))==0)
				{
					x=ex(d,16-i,16-i-1);
					fang(x,d);
				}
				if((d&(1<<(16-i-4)))==0)
				{
					x=ex(d,16-i,16-i-4);
					fang(x,d);
				}
			}
		}
		if(d&(1<<12))//4号位 
		{
			if((d&(1<<13))==0)
			{
				x=ex(d,13,12);
				fang(x,d);
			}
			if((d&(1<<8))==0)
			{
				x=ex(d,12,8);
				fang(x,d);
			}
		}
		if(d&(1<<11))//5号位 
		{
			if((d&(1<<15))==0)
			{
				x=ex(d,15,11);
				fang(x,d);
			}
			if((d&(1<<10))==0)
			{
				x=ex(d,10,11);
				fang(x,d);
			}
			if((d&(1<<7))==0)
			{
				x=ex(d,7,11);
				fang(x,d);
			}
		}
		for(int i=6;i<=7;++i)//6~7号位 
		{
			if(d&(1<<(16-i)))
			{
				if((d&(1<<(16-i+4)))==0)
				{
					x=ex(d,16-i,16-i+4);
					fang(x,d);
				}
				if((d&(1<<(16-i+1)))==0)
				{
					x=ex(d,16-i,16-i+1);
					fang(x,d);
				}
				if((d&(1<<(16-i-1)))==0)
				{
					x=ex(d,16-i,16-i-1);
					fang(x,d);
				}
				if((d&(1<<(16-i-4)))==0)
				{
					x=ex(d,16-i,16-i-4);
					fang(x,d);
				}
			}
		}
		if(d&(1<<8))//8号位 
		{
			if((d&(1<<12))==0)
			{
				x=ex(d,8,12);
				fang(x,d);
			}
			if((d&(1<<9))==0)
			{
				x=ex(d,8,9);
				fang(x,d);
			}
			if((d&(1<<4))==0)
			{
				x=ex(d,8,4);
				fang(x,d);
			}
		}
		if(d&(1<<7))//9号位 
		{
			if((d&(1<<11))==0)
			{
				x=ex(d,7,11);
				fang(x,d);
			}
			if((d&(1<<6))==0)
			{
				x=ex(d,7,6);
				fang(x,d);
			}
			if((d&(1<<3))==0)
			{
				x=ex(d,7,3);
				fang(x,d);
			}
		}
		for(int i=10;i<=11;++i)//10~11号位 
		{
			if(d&(1<<(16-i)))
			{
				if((d&(1<<(16-i+4)))==0)
				{
					x=ex(d,16-i,16-i+4);
					fang(x,d);
				}
				if((d&(1<<(16-i+1)))==0)
				{
					x=ex(d,16-i,16-i+1);
					fang(x,d);
				}
				if((d&(1<<(16-i-1)))==0)
				{
					x=ex(d,16-i,16-i-1);
					fang(x,d);
				}
				if((d&(1<<(16-i-4)))==0)
				{
					x=ex(d,16-i,16-i-4);
					fang(x,d);
				}
			}
		}
		if(d&(1<<4))//12号位 
		{
			if((d&(1<<8))==0)
			{
				x=ex(d,8,4);
				fang(x,d);
			}
			if((d&(1<<5))==0)
			{
				x=ex(d,4,5);
				fang(x,d);
			}
			if((d&(1<<0))==0)
			{
				x=ex(d,4,0);
				fang(x,d);
			}
		}
		if(d&(1<<3))//13号位 
		{
			if((d&(1<<7))==0)
			{
				x=ex(d,3,7);
				fang(x,d);
			}
			if((d&(1<<2))==0)
			{
				x=ex(d,3,2);
				fang(x,d);
			}
		}
		for(int i=14;i<=15;++i)//14~15号位 
		{
			if(d&(1<<(16-i)))
			{
				if((d&(1<<(16-i+4)))==0)
				{
					x=ex(d,16-i,16-i+4);
					fang(x,d);
				}
				if((d&(1<<(16-i+1)))==0)
				{
					x=ex(d,16-i,16-i+1);
					fang(x,d);
				}
				if((d&(1<<(16-i-1)))==0)
				{
					x=ex(d,16-i,16-i-1);
					fang(x,d);
				}
			}
		}
		if(d&(1<<0))//16号位 
		{
			if((d&(1<<1))==0)
			{
				x=ex(d,0,1);
				fang(x,d);
			}
			if((d&(1<<4))==0)
			{
				x=ex(d,4,0);
				fang(x,d);
			}
		}
	}
	cout<<z[b];
	fclose(stdin);fclose(stdout);
	return 0;
}
```


---

## 作者：foreverlasting (赞：1)

为什么要bfs啊？不是dfs就可以了吗？

记录一下$1$的位置，做个差不就好了吗？为什么要哈希啊？一脸懵逼。

code:
```
//2018.9.5 by ljz
#include<bits/stdc++.h>
using namespace std;
#define res register int
#define LL long long
#define inf 0x3f3f3f3f
#define eps 1e-15
inline int read(){
    res s=0;
    bool w=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=1;ch=getchar();}
    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();
    return w?-s:s;
}
inline void _swap(res &x,res &y){
    x^=y^=x^=y;
}
inline int _abs(const res &x){
    return x>0?x:-x;
}
inline int _max(const res &x,const res &y){
    return x>y?x:y;
}
inline int _min(const res &x,const res &y){
    return x<y?x:y;
}
const int N=20;
namespace MAIN{
    struct P{
        int x,y;
        P() {}
        P(res x,res y):x(x),y(y) {}
    }c[N],d[N];
    int num;
    char a[N][N],b[N][N];
    int e[N][N];
    inline int get(const P &a,const P &b){
        return _abs(a.x-b.x)+_abs(a.y-b.y);
    }
    int ans;
    bool vis[N];
    void dfs(res x,res w){
        if(w>=ans)return;
        if(x==num+1){ans=_min(w,ans);return;}
        for(res i=1;i<=num;i++)
            if(!vis[i])
                vis[i]=1,dfs(x+1,w+e[x][i]),vis[i]=0;
    }
    inline void MAIN(){
        ans=inf;
        for(res i=1;i<=4;i++){
            scanf("%s",a[i]+1);
            for(res j=1;j<=4;j++)
                if(a[i][j]=='1')d[++num]=P(i,j);
        }
        num=0;
        for(res i=1;i<=4;i++){
            scanf("%s",b[i]+1);
            for(res j=1;j<=4;j++)
                if(b[i][j]=='1')c[++num]=P(i,j);
        }
        for(res i=1;i<=num;i++)
            for(res j=1;j<=num;j++)
                e[i][j]=get(c[i],d[j]);
        dfs(1,0);
        printf("%d\n",ans);
    }
}
int main(){
    MAIN::MAIN();
    return 0;
}
```

---

## 作者：lx_zjk (赞：0)

这道题本来是想用迭代加深搜索做的，可是不知道是代码写错了还是算法本身错误，所以一直不输出答案;

转变思路,给定的矩阵大小是固定的，且每个矩阵数位只能为0 or 1

所以考虑状态压缩

重点的东西写在代码注释里，望审核通过
```cpp
#include<bits/stdc++.h>

using namespace std;

typedef long long ll;

inline ll read() {
	ll f=1,x=0;
	char ch;
	do {
		ch=getchar();
		if(ch=='-')f=-1;
	} while(ch>'9'||ch<'0');
	do {
		x=x*10+ch-'0';
		ch=getchar();
	} while(ch>='0'&&ch<='9');
	return f*x;
}

int start,goal;

int dis[1000001];

queue<int>q;

inline void BFS()
{
	memset(dis,127,sizeof(dis));
	dis[start]=0;
	queue<int>q;
	q.push(start);
	while(!q.empty())
	{
		int x=q.front();q.pop();
		if(x==goal){
			cout<<dis[x]<<endl;
			return ;
		}
		for(int i=1;i<=16;i++)
		{
        	//判断第i位的数是否为1
			if(x&(1<<i))
			{
            	//判断不出界
                //判断要交换的位置的数是否为0
                //若交换后的数未被记录过，则更新他
				if(i+4<=16&&!(x&(1<<(i+4)))&&dis[(x^(1<<i))|1<<(i+4)]>dis[x]+1)
				{
					dis[(x^(1<<i))|1<<(i+4)]=dis[x]+1;
					q.push((x^(1<<i))|1<<(i+4));
				}
				if(i-4>=1&&!(x&(1<<(i-4)))&&dis[(x^(1<<i))|1<<(i-4)]>dis[x]+1)	
				{
					dis[(x^(1<<i))|1<<(i-4)]=dis[x]+1;
					q.push((x^(1<<i))|1<<(i - 4));
				}
				if(i%4!=0&&!(x&(1<<(i+1)))&&dis[(x^(1<<i))|1<<(i+1)]>dis[x]+1)
				{
					dis[(x^(1<<i))|1<<(i+1)]=dis[x]+1;
					 q.push((x^(1<<i))|1<<(i+1));
				}
				if(i%4!=1&&!(x&(1<<(i-1)))&&dis[(x^(1<<i))|1<<(i-1)]>dis[x]+1)
				{
					dis[(x^(1<<i))|1<<(i-1)]=dis[x]+1;
					 q.push((x^(1<<i))|1<<(i-1));
				}
			}
		
		}
	}
}

int main(){
	for(int i=1;i<=4;i++)
	{
		string s;
		cin>>s;
		for(int j=1;j<=4;j++)
		{
			start|=(s[j-1]-'0')*(1<<((i-1)*4+j));//将start状态存下来；
		}
	}
	for(int i=1;i<=4;i++)
	{
		string s;
		cin>>s;
		for(int j=1;j<=4;j++)
		{
			goal|=(s[j-1]-'0')*(1<<((i-1)*4+j));//将goal状态存下来
		}
	}
//	cout<<start<<" "<<goal<<endl;
	BFS();//广搜
	return 0;
}

```

---

## 作者：Para (赞：0)


对于已经匹配好的点，我们直接把他赋值为0；

# 对于用这个点去匹配其他点，肯定不如直接有这个点已匹配的点更优。
如果另一个点的某条转移路径需要路过这个点，我们可以转换为：把这个点先转移到目标点，然后再把另一个点转移过来。
得到这个结论就简单多了。我们只需要求得未匹配点到未匹配目标点的最短距离即可。 这个用数学方式：两点x坐标差的绝对值+两点y坐标的绝对值。
##### 即 abs（x1 - x2）+ abs(y1 - y2)
最后用深搜暴力求解即可
###### 管理员求通过
### 上代码
#
```

#include <cstdio>
#include <iostream>
#include <algorithm>
using namespace std;
struct kk {
	int x,y;
} c[26] ;//记录每一个a[][]有玩具的地方 
int a[5][5],b[5][5],w[5][5][5][5] ;
bool d[5][5];
int _sum = 0,_min = 999999999 ;//_sum记录 a[][] == 1 的个数, _min 是最小值 （及答案） 
void BFS ( int tot , int ans ) {//tot 是寻找到的个数 , ans 是需要步数 
	if ( tot > _sum ) {  //当搜索个数 > 原本个数时，跳出 
		_min = min ( _min , ans ) ; // 统计答案 
		return ;
	}
	for ( int i = 1 ; i <= 4 ; i ++ ) {
		for ( int j = 1 ; j <= 4 ; j ++ ) {
			if ( w[c[tot].x][c[tot].y][i][j] != 0 && d[i][j] == 0) {
				d[i][j] = 1 ;
				BFS ( tot + 1 , ans + w[c[tot].x][c[tot].y][i][j] ) ; //进入更深一层的递归  
				d[i][j] = 0 ; //回溯 
			}
		}
	}//查找 
}

int main() {
	char ch ;//用字符更好输入 
	for ( int i = 1 ; i <= 4 ; i ++ ) {
		for ( int j = 1 ; j <= 4 ; j ++ ) {
			cin >> ch;
			a[i][j] = ch - '0' ;
		}
	}//输入 
	for ( int i = 1 ; i <= 4 ; i ++ ) {
		for ( int j = 1 ; j <= 4 ; j ++ ) {
			cin >> ch ;
			b[i][j] = ch - '0' ;
			if ( a[i][j] == b[i][j] ) a[i][j] = b[i][j] = 0 ;
		}
	}//输入
	for (int i = 1 ; i <= 4 ; i ++ ) {
		for (int j = 1 ; j <= 4 ; j ++ ) {
			if (a[i][j] == 1) {
				c[++ _sum].x = i;
				c[_sum].y = j ;
				for (int k = 1; k <= 4; k ++) {
					for (int x = 1 ; x <= 4; x ++) {
						if (b[k][x] == 1) w[i][j][k][x] = abs(i - k) + abs(j - x) ;
					}
				}
			}
		}
	}//w[][][][]储存（i,j） -->  (k,x) 的距离 
	BFS(1,0);//BFS搜索 
	printf("%d",_min);//输出 
	return 0 ;
}

---

## 作者：Whyher (赞：0)

蒟蒻逛了一下题解区，发现大佬们都用二进制判重（可是我不会），就发一篇map判重。




```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<map>
using namespace std;
map<long long int,bool> mp;
struct node
{
	int a[7][7];
};
node q[1000000];//stl会更快；
int step[1000000];
int h=0,t=1;
long long int p;
long long int turn(node a)//转化成16位数字，方便用map；
{
	long long int s=0;
	for(int i=1;i<=4;i++)
		for(int j=1;j<=4;j++)
			s=s*10+a.a[i][j];
	return s;
}
int ans;
bool change(int h)
{
	node a=q[h];
	for(int j=1;j<=4;j++)
	{
		for(int i=1;i<=3;i++)
		{
			node tmp=a;
			swap(tmp.a[i][j],tmp.a[i+1][j]);
			long long int y=turn(tmp);
			if(mp[y]==0)
			{
				mp[y]=1;
				t++;
				q[t]=tmp;
				step[t]=step[h]+1;
			}
			if(y==p)
			{
				ans=step[t];
				return 1;
			}
		}
	}
	for(int i=1;i<=4;i++)
	{
		for(int j=1;j<=3;j++)
		{
			node tmp=a;
			swap(tmp.a[i][j],tmp.a[i][j+1]);
			long long int y=turn(tmp);
			if(mp[y]==0)//如果1,1或者0,0交换16位数并没有改变，判重可以去掉。
			{
				mp[y]=1;
				t++;
				q[t]=tmp;
				step[t]=step[h]+1;
			}
			if(y==p)//找到返回1；
			{
				ans=step[t];
				return 1;
				
			}
		}
	}
	return 0;//未找到返回0；
}
int main()
{
	node s,g;
	string c;
	for(int i=1;i<=4;i++)
	{
		cin>>c;
		for(int j=0;j<=3;j++)
		{
			s.a[i][j+1]=c[j]-'0';
		}
	}	
	long long int tt=turn(s);
	mp[tt]=1;
	for(int i=1;i<=4;i++)
	{
		cin>>c;
		for(int j=0;j<=3;j++)
		{
			g.a[i][j+1]=c[j]-'0';
		}
	}	
	p=turn(g);
	if(p==tt)
	{
		cout<<0<<endl;
		return 0;
	}
	q[t]=s;
	while(h<=t)
	{
		h++;
		if(change(h)==1)
		{
			cout<<ans<<endl;
			return 0;//输出...;
		}
	}
	return 0;
}
```
蒟蒻第一篇题解，望通过谢谢！


---


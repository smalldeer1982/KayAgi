# [SCOI2003] 字符串折叠

## 题目描述

折叠的定义如下：

1. 一个字符串可以看成它自身的折叠。记作 ```S = S```

2. ```X(S)``` 是 $X$ 个 ```S``` 连接在一起的串的折叠。记作 ```X(S) = SSSS…S```。

3. 如果 ```A = A’```, ```B = B’```，则 ```AB = A’B’ ```。例如：因为 ```3(A) = AAA```, ```2(B) = BB```，所以 ```3(A)C2(B) = AAACBB```，而 ```2(3(A)C)2(B) = AAACAAACBB```

给一个字符串，求它的最短折叠。

例如 ```AAAAAAAAAABABABCCD``` 的最短折叠为：```9(A)3(AB)CCD```。

## 说明/提示

一个最短的折叠为：`2(NEERC3(YES))`

## 样例 #1

### 输入

```
NEERCYESYESYESNEERCYESYESYES```

### 输出

```
14```

# 题解

## 作者：kradcigam (赞：247)

- Update 2020-6-5：感谢 @[blanc_x](https://www.luogu.com.cn/user/101620) 帮忙检查出了一处笔误。

- Update 2020-8-7：感谢 @[Garrison](https://www.luogu.com.cn/user/154334) 指出错误。

- Update 2021-8-12：修改优化了排版&解答评论问题：

	- 关于 4 重循环：包含函数里的一重，请不要再问这样的问题了。

- Update 2021-10-16：感谢 @[0Arctic0](https://www.luogu.com.cn/user/367991) 帮助修改了时间复杂度部分，增强语言的严谨性。

---

## 讲讲我的做法

题目大意：对一个字符串进行折叠是它长度最小。

看一眼数据范围：哇！字符串长度不超过 **100**！这是一道省选题，不可能给你太宽裕的时限，所以，题目基本暗示你要用 $n^{3}$ 多一些的算法复杂度。

这是一道最优化的题目，常见求最优化问题的算法比如贪心，模拟，枚举我都想不出什么好办法，唯独觉得像一道区间 dp。
### 区间 dp 的分析

#### 解释状态
我们用 $f_{i,j}$ 表示 $i\sim j$ 这个区间内最小的长度。

首先，我们可以把 $i\sim j$ 这个区间的字符串拆成 2 部分处理。

就有了这段代码：
```cpp
for(int l=2;l<=n;l++)
	for(int i=1,j=i+l-1;j<=n;i++,j++)
		for(int k=i;k<j;k++)
			f[i][j]=min(f[i][j],f[i][k]+f[k+1][j]);
```
当然我用了字符串，然后加空格，这样更加符合人脑思维。

也有同学喜欢用字符数组，我也写了这样的一段代码：
```cpp
for(int l=2;l<=n;l++){
    for(int i=0,j=i+l-1;j<n;i++,j++){
        for(int k=i;k<j;k++)
			f[i][j]=min(f[i][j],f[i][k]+f[k+1][j]);
    }
}
```
#### 折叠
至于如何判断能否折叠，我呢用了一个函数——`check`，来检查一下是否可以折叠。

字符串代码：
```cpp
bool check(int l,int r,int len){
    for(int i=l;i<=r;i++)
        if(st[i]!=st[(i-l)%len+l])return false;
    return true;
}
```
字符数组代码：
```cpp
bool check(char s[],int n,int len){
    for(int i=len;i<n;i++)
        if(s[i]!=s[i%len])return false;
    return true;
}
```
判断好了是否可以折叠，我们就可以去写状态了，从 $i\sim j$，判断区间折叠的循环节。

字符串代码：
```cpp
for(int l=2;l<=n;l++){
    for(int i=1,j=i+l-1;j<=n;i++,j++){
        for(int k=i;k<j;k++)
			f[i][j]=min(f[i][j],f[i][k]+f[k+1][j]);
        for(int k=i;k<j;k++){
            int len=k-i+1;
            if(l%len!=0)continue;
            if(check(i,j,len))f[i][j]=min(f[i][j],f[i][k]+2+m[l/len]);
        }
    }
}
```
字符数组代码：
```cpp
for(int l=2;l<=n;l++){
    for(int i=0,j=i+l-1;j<n;i++,j++){
        for(int k=i;k<j;k++)
			f[i][j]=min(f[i][j],f[i][k]+f[k+1][j]);
        for(int k=i;k<j;k++){
            int len=k-i+1;
            if(l%len!=0)continue;
            if(check(s+i,l,len))f[i][j]=min(f[i][j],f[i][k]+2+m[l/len]);
        }
    }
}
```
#### 边界条件以及初始化

刚刚的代码里出现里 $m$，现在我就来解释一下 $m$ 数组是干什么的。

**$m_i$ 的值表示的是数字 $i$ 的位数**，因为字符串的长度跟数字的位数有关。

我用的是最简单的方法，`for` 循环扫，**注意**：**100 也要赋值，万一数据给你 100 个同样的字符**。

```cpp
for(int i=1;i<=9;i++)m[i]=1;
for(int i=10;i<=99;i++)m[i]=2;
m[100]=3;
```

现在我们想一想初始化怎么做？

显然，$f_{i,i}=1$，其他初值设为 $∞$。
```cpp
memset(f,0x3f,sizeof(f));
for(int i=1;i<=n;i++)f[i][i]=1;
```

现在我们已经做完了所有的步骤，让我们看一看完整代码吧。

字符串代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
string st;
int n,m[110],f[110][110];
bool check(int l,int r,int len){
    for(int i=l;i<=r;i++)
        if(st[i]!=st[(i-l)%len+l])return false;
    return true;
}
int main(){
	cin>>st;
    n=st.size();
    st=' '+st;
    for(int i=1;i<=9;i++)m[i]=1;
    for(int i=10;i<=99;i++)m[i]=2;
    m[100]=3;
    memset(f,0x3f,sizeof(f));
    for(int i=1;i<=n;i++)f[i][i]=1;
    for(int l=2;l<=n;l++){
        for(int i=1,j=i+l-1;j<=n;i++,j++){
            for(int k=i;k<j;k++)
				f[i][j]=min(f[i][j],f[i][k]+f[k+1][j]);
            for(int k=i;k<j;k++){
                int len=k-i+1;
                if(l%len!=0)continue;
                if(check(i,j,len))f[i][j]=min(f[i][j],f[i][k]+2+m[l/len]);
            }
        }
    }
    printf("%d",f[1][n]);
    return 0;
}
```
字符数组代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
char s[110];
int n,m[110],f[110][110];
bool check(char s[],int n,int len){
    for(int i=len;i<n;i++)
        if(s[i]!=s[i%len])return false;
    return true;
}
int main(){
    scanf("%s",s);
    n=strlen(s);
    for(int i=1;i<=9;i++)m[i]=1;
    for(int i=10;i<=99;i++)m[i]=2;
    m[100]=3;
    memset(f,0x3f,sizeof(f));
    for(int i=0;i<n;i++)f[i][i]=1;
    for(int l=2;l<=n;l++){
        for(int i=0,j=i+l-1;j<n;i++,j++){
            for(int k=i;k<j;k++)
				f[i][j]=min(f[i][j],f[i][k]+f[k+1][j]);
            for(int k=i;k<j;k++){
                int len=k-i+1;
                if(l%len!=0)continue;
                if(check(s+i,l,len))f[i][j]=min(f[i][j],f[i][k]+2+m[l/len]);
            }
        }
    }
    printf("%d",f[0][n-1]);
    return 0;
}
```
### 时间复杂度

看上去我们套了 $4$ 个循环，然而真的时间复杂度就达到了 $n^{4}$ 吗？其实不是的。

首先 $n^{3}$ 肯定是存在的，那么为什么时间复杂度没有达到 $n^{4}$ 呢！

原因在于我们的 `continue`，它的复杂度是 $\log n$。

为什么？

我们进行 `check` 操作的显然是 $l$ 的因数，而 $l$ 的因数个数$<\log{l}$。

现实当中的常数还会更小，因为 `check` 的常数很小，它不是从 $1$ 开始，也没有到 $n$ 结束，并且一旦发现错误后会直接 `return`。

其实可以把里面的 2 个循环并成一个循环，但为了让大家看的更清楚，就不演示了。

---

## 作者：hfee (赞：24)

# 前置知识：区间DP

如果你不知道区间DP是个啥，可以去我的[这篇](https://www.luogu.org/blog/123936/solution-p1880)题解康康

大概讲了区间DP的原理（dalao请跳过）

——————可爱(*≧▽≦*)的分割线qwq——————

这篇题解有部分思路借鉴[skiy_gyx](https://www.luogu.org/blog/gyx8177919/solution-p4302)，感谢dalao的题解（就是他讲的有点少所以才发的这篇）

这题难度严重虚高，跟石子合并也差不了多少

### ~~chen_zhe:这是个p的省选题，顶多普及-~~

好了，看看题目，枚举贪心搜索好像都不大可行

于是我们就用区间DP

那么，怎么表示状态呢？

我们用$f[i][j]$表示字符串里i到j的折叠长度的最小值

直接套模板就可以得到

```
for(int l=1;l<=n;l++){
    for(int i=1,j=i+l-1;j<=n;i++,j++){
        for(int k=i;k<j;k++){
            f[i][j]=min(f[i][j],f[i][k]+f[k+1][j]);
        }
    }
}
```
记得初始化时把所有的$f[i][i]$都初始化成1

这里就不解释了


当然不会这么简单

对于每一个$i$到$j$的串，除了

- 分成两段的和，即上面的代码
- 还有自己单独构成一个循环的串

那么重点就在于判断这个串是否循环了

让我们来考虑一下怎么做

这个串如果循环，那么一定有一个循环节

比如abcabcabcabc中的abc

正好，我们上面的程序里面枚举了一遍断点

那么正好接着判断i到k的这一串可不可以作为循环节

首先，如果当前串的长度不是循环节的整数倍，那就直接排除

其次，我们只要写一个check函数

遍历一遍这个串，看看是不是每个都符合

```
bool check(int l,int r,int len){
    for(int i=l;i<=l+len-1;i++){ //遍历循环节的每一位
        for(int j=i;j<=r;j+=len){ //和之后串里的每一个循环节的相应位进行比较
            if(s[j]!=s[i]) return false;
        }
    }
    return true;
}
```
最后一点，这时折叠后的长度就是：

循环节的长度+2（括号）+循环节的长度的位数（即括号开头的数字）

另外两个都很好搞，这个循环节的长度的位数还要另作处理

不妨定义一个数组sz，存下每个数字的长度，即：

```
for(int i=1;i<=100;i++){
    if(i<=9) sz[i]=1;
    else if(i>=10&&i<=99) sz[i]=2;
    else sz[i]=3;
}

至此，我们就可以直接上代码了
```
# CODE:

```
#include<bits/stdc++.h>
using namespace std;
string s;
int sz[105],f[105][105];
bool check(int l,int r,int len){
    for(int i=l;i<=l+len-1;i++){
        for(int j=i;j<=r;j+=len){ 
            if(s[j]!=s[i]) return false;        
		}
    }
    return true;
}
int main(){
	cin>>s;
	int n=s.length();
	memset(f,0x3f,sizeof(f));
	for(int i=0;i<n;i++) f[i][i]=1;
	for(int i=1;i<=100;i++){
	    if(i<=9) sz[i]=1;
	    else if(i>=10&&i<=99) sz[i]=2;
	    else sz[i]=3;
	}
	for(int l=1;l<=n;l++){
	    for(int i=0,j=i+l-1;j<n;i++,j++){
	        for(int k=i;k<j;k++){
	            f[i][j]=min(f[i][j],f[i][k]+f[k+1][j]);
	            int len=k-i+1;
	            if(l%len) continue;
	            if(check(i,j,len)) f[i][j]=min(f[i][j],sz[l/len]+f[i][k]+2);
	        }
	    }
	}
	cout<<f[0][n-1];
	return 0;
}
```


小蒟蒻第一次写紫题（虽然难度没那么高）题解，求过QWQ


---

## 作者：Plus_Ultra (赞：12)

一. 具体解法：

设 dp[ l ][ r ] 表示，把 l ~ r 这个区间折叠的最短长度，然后我们想，对于一个区间来说，我们有两种选择：

- 一种是把这个区间它自己来折叠，

- 另一种是两块已经折叠的区间接起来.

- 对于第二种情况，直接枚举断点（区间dp中很常见），找最小的一种方
案,

- 对于第一种情况，找出它所有的折叠方案，在折叠方案中取一个最优的.

二. 思路分析：

整体的思路都是对于一段区间，两类决策

-  1：枚举端点，由子问题更新的最优决策.

-  2：该区间本身进行压缩（进行处理）的最优决策.

三. 转移套路

- 一般 n = 1000 的区间 dp 问题，状态就是二维的了，转移一般都是 O( 1 ) 的，dp 转移过程中主要考虑就是 L 和 R 两个边界的情况.


- 而 n = 100 的区间 dp ，除了边界往往还要枚举这个区间从哪个位置划分.

四. 细节问题.

- 我们预处理一个 leng[ i ] 表示数字 i 的长度（折叠后要加上）.

- dp[ i ][ i ] = 1，即自己到自己长度为1.

- 用循环节更新前，首先枚举由两个子串拼接起来的情况.

- 枚举循环节长度，检查更新

- 记住，更新时要加上2（括号）和 leng[ (r - l + 1) / len ] 数字长度.

五. 代码

下面上代码（我知道各位大佬也不需要代码）：

```
#include<iostream>
#include<cstring>

#define N 110

using namespace std;

char c[N];
int dp[N][N],leng[N];

void check(int l,int r,int len)
{
	if((r-l+1)%len)  return;
	for(int i=l;i<=r;i++)
		if(c[i]!=c[(i-l)%len+l])  return;
	dp[l][r]=min(dp[l][r],dp[l][l+len-1]+2+leng[(r-l+1)/len]); 
}

int main()
{
	cin>>c+1;
	int n=strlen(c+1);
	
	for(int i=1;i<=9;i++)  leng[i]=1;
	for(int i=10;i<=99;i++)  leng[i]=2;
	leng[100]=3;
	
	memset(dp,0x3f,sizeof(dp));
	for(int i=1;i<=n;i++)  dp[i][i]=1;
	
	for(int l=1;l<=n;l++)
		for(int i=1,j=i+l;j<=n;i++,j++)
		{
			for(int k=i;k<j;k++)  
				dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]);
			for(int k=1;k<=j-i;k++)  check(i,j,k);
		}
		
	cout<<dp[1][n]<<endl;
		
	return 0;
}
```

去掉空行后30来行，也是比较短了.

###  _[Plus Ultra!](https://www.luogu.org/blog/OnePunchManGO/)_ 


---

## 作者：浅色调 (赞：9)

### Solution：

　　本题考试时没搞出来。（话说老余$AK$了！，自己还是个蒟蒻！）

　　就是一个区间$DP$，我这里用记忆化搜索来实现。

　　巧妙运用一下字符串$string$流。定义状态$f[i][j]$表示区间$[i,j]$折叠后的最短字符串，那么当$l==r$时，显然$f[l][r]==s[l]$，搜索时枚举断点递归，找到使原串折叠后的长度最短的断点，然后枚举折叠的长度，这里用到了$stringstream$（字符串输入输出流）定义中间变量$op$，这样就可以简单的进行字符串的赋值，每一次$f[l][r]$赋为$f[l][r],op$中长度最短的一个（代码中的$op.tellp()$返回的是当前$put$流指针的位置（类似的还有$tellg$，返回$get$流指针的位置），可以理解为$op$的尾指针位置，即它的长度）。

　　这样写的好处是简洁而且能简单输出折叠后的字符串（一模一样的题，只是输出的是字符串，洛谷搜：$UVA1630\;Folding$，$STL$大法好！）。

$\quad\;\;$此时先为不会$stringstream$的小伙伴们，安利一波（我测试的代码）：
```cpp
#include<iostream>
#include<sstream>  //stringstream所需的头文件
using namespace std;
int main(){
    ios::sync_with_stdio(0);  //取消流同步是可以用的，完全和string输入输出流无关
    
    stringstream op;  //定义string输入输出流，任意变量和string互转
    string p;
    char s[12]={"lalalavan"}; 
    op<<s;  //将char类型的字符串赋值给op
    op>>p;  //将op输出到p中
    cout<<op.str()<<endl<<p<<endl;  //两种输出方式
    
    op.str("");
    op.clear();  //对op清空必须两个都要用，可以自行尝试去掉一个，会出兮兮`～`
    
    string num="23333";
    int n;
    op<<num;op>>n; //将string类型转为int类型
    cout<<n<<endl; //输出转换后的int类型
    return 0;
}
```
  
  $\quad\;\;$欢迎来踩博客:[five20](https://www.cnblogs.com/five20/p/9095505.html)
(蒟蒻写题解不易，转载请注明出处，万分感谢！)
### 本题代码：
```cpp
#include<bits/stdc++.h>
#define il inline
#define For(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)
#define Min(a,b) ((a)>(b)?(b):(a))
#define INF 23333
using namespace std;
int n;
string s,f[105][105];
il int check(int l,int r){
    int sl=r-l+1;
    For(k,1,sl>>1){
        if(sl%k)continue;
        bool f=1;
        For(i,l,r-k){
            if(s[i]==s[i+k])continue;
            f=0;
            break;
        }
        if(f)return k;
    }
    return 0;
}
il string dfs(int l,int r){
    if(!f[l][r].empty())return f[l][r];
    if(l==r)return f[l][r]=s[l];
    int mink,ansl=INF;
    For(i,l,r-1){
        int len=dfs(l,i).size()+dfs(i+1,r).size();
        if(len<ansl)mink=i,ansl=len;
    }
    f[l][r]+=dfs(l,mink),f[l][r]+=dfs(mink+1,r);
    int k=check(l,r);
    if(k){
        stringstream op;   //定义输入输出流
        op<<(r-l+1)/k<<"("<<dfs(l,l+k-1)<<")";    //将后面一大串依次赋给op
        if(op.tellp()<f[l][r].size()) op>>f[l][r];  //比较f[l][r]和op取长度最小的
    }
    return f[l][r];
}
int main(){
    cin>>s;
    n=s.size();
    For(i,0,n-1) For(j,0,n-1)f[i][j].clear();
    cout<<dfs(0,n-1).size();
    return 0;
}
```

---

## 作者：Frozen_Heart (赞：9)

# P4302 [SCOI2003]字符串折叠

### 题目描述

折叠的定义如下：

1.  一个字符串可以看成它自身的折叠。记作S = S
2.  X(S)是X(X>1)个S连接在一起的串的折叠。记作X(S) = SSSS…S(X个S)。
3.  如果A = A’, B = B’，则AB = A’B’ 例如，因为3(A) = AAA, 2(B) = BB，所以3(A)C2(B) = AAACBB，而2(3(A)C)2(B) = AAACAAACBB
    
    给一个字符串，求它的最短折叠。例如AAAAAAAAAABABABCCD的最短折叠为：9(A)3(AB)CCD。
    

### 输入输出格式

**输入格式：**  

仅一行，即字符串S，长度保证不超过100。

**输出格式：**  

仅一行，即最短的折叠长度。

### 输入输出样例

**输入样例#1：** 

NEERCYESYESYESNEERCYESYESYES

**输出样例#1：** 

14

### 说明

一个最短的折叠为：2(NEERC3(YES))

考试的题目，~~还不会区间dp~~，什么都不知道，考试的时候思路大概想到了，但是没有想到怎么实现。
用$F[i][j]$表示从第$i$个字符到第$j$个字符的最小长度。枚举**中间**断点，**一定要先处理完中间才能处理两边**，~~考试的时候就是不晓得怎么枚举~~(我还是太菜了)。
还有一点很容易错的，字符折叠起来**前面的数字可能为不止占一位**(如AAAAAAAAAA  --->  10(A))。
难点在于怎样判断折叠，看到网上很多大佬用%什么的很麻烦，其实我们只要算出折叠完后字母部分有多长，然后用当前位置减去长度就可以了。因为既然可以枚举到这里，那么前面一定保证了相同，这是我们没必要一定搞到第一个的位置去判断。具体看代码吧
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<algorithm>
using namespace std;
int len;
int f[110][110];
int dp[110];
char ch[110];
bool get(int x1,int y1,int x2,int y2)
{
    if((y2-x1+1)%(y1-x1+1)!=0) return false;
    int len=y1-x1+1;
    for(int i=x2;i<=y2;i++)
    {
        if(ch[i]!=ch[i-len]) 
        return false;
    }
    return true;
}
int cal(int k)
{
    int qwe=0;
    while(k)
    {
        qwe++;
        k/=10;
    }
    return qwe;
}
int main()
{
    memset(f,0x3f,sizeof(f));
    cin>>ch;
    len=strlen(ch);
    for(int i=0;i<len;i++)f[i][i]=1;
    for(int l=1;l<len;l++)
    {
        for(int i=0;i<len-l;i++)
        {
            int j=i+l;
            f[i][j]=(j-i+1);
            for(int k=i;k<j;k++)
            {
                if(!get(i,k,k+1,j))
                f[i][j]=min(f[i][j],f[i][k]+f[k+1][j]);
                else f[i][j]=min(f[i][j],f[i][k]+2+cal((l+1)/(k-i+1)));
                //printf("f[%d][%d]=%d\n",i,j,f[i][j]);
            }
        }
    }
    cout<<f[0][len-1];
    return 0;
}
```

---

## 作者：Seauy (赞：4)

# 1. 思路

当你拿到了一个字符串后，其实你并不知道它该怎么折叠。

因为折叠的情况实在是太多了，有可能整段全都折叠了，也有可能从中截出来一段然后折叠，更有可能选好几段折叠……最后还要从这么多情况中挑出最好的一种作为答案。

所以干脆想得简单粗暴一点，分两种情况：

1. 这整个字符串都给我折叠了（当然要枚举折叠的长度）。

2. 随便选一个地方切断，分成两段然后折叠（当然要枚举切断的点）。

同学们也应该看出来了，上面两部要重复操作，也就变成了递归的结构。等到不能再切了，也就是字符串长度只剩 1 了，就 return，当然也不要再折叠了，因为此时折叠肯定是不优的。

思路了解了，只要实现代码就行了。

# 2. 写代码

~~[ 然而就是实现很糟心 ]~~

由于字符串折叠后的最短情况长度只有一个，也就是一个字符串对应一个最优解，本人就没采用 区间DP，因为区间不一样时对应的字符串还可能是一样的，以 区间 为角标做 DP 会重复算同一个字符串很多次。

### 所以可能我自己发明了一种~~新 DP~~

为什么呢？因为我的 DP 角标里存的不是区间，也不是数字，也不是二进制状态……

### 而是字符串

~~[ 就让我命名一下，叫做 字符串DP 吧 ]~~

其实跟大家写得差不多，用递归实现的，只是传入函数的值为 string。

做 DP 当然要有 DP 数组，由于说了角标是字符串，就只能用 map<string,int> 喽。


------------


给出递推式：

(其中 x 为字符串，sub 为可以重复拼接成 x 的子串集合，intlen(a) 为整数 a 的位数)

![](https://cdn.luogu.com.cn/upload/pic/72399.png)

~~LaTeX 真好看~~

太复杂？

看不懂，看不清！？

还有你谷水印！？

没关系，上代码：
```cpp
// luogu-judger-enable-o2 诶呀这是什么，无关紧要的东东
#include<bits/stdc++.h>
using namespace std;

string s;
map<string,int> dp;

string CutOut(string ob,int L,int R)//裁剪 L~R 的字符串
{
	string cnt="";
	for(int i=L;i<=R;i++) cnt=cnt+ob[i];
	return cnt;
}

int INTlen(int ob)//整数数位个数
{
	if(!ob) return 1;
	int cnt=0;
	while(ob) cnt++,ob/=10;
	return cnt;
}

int DFS(string ob)//众所周知DP的实质是记忆化搜索（口胡）
{
	if(dp[ob]) return dp[ob];
	int len=ob.length();
	if(len<2) return len;
	int cnt=len;
	for(int i=1;i*i<=len;i++)//枚举重复区间的长度
		if(len%i==0)
		{
        	//长度为 i
			string temp=CutOut(ob,0,i-1);
			for(int j=i;j+i-1<len;j+=i)
				if(temp==CutOut(ob,j,j+i-1)) continue;
				else goto S1;
			//可以被折叠 
			cnt=min(cnt,INTlen(len/i)+DFS(temp)+2);
			S1: if(i!=len/i && i!=1)//长度为 len/i
			{
				temp=CutOut(ob,0,len/i-1);
				for(int j=len/i;j+len/i-1<len;j+=len/i)
					if(temp==CutOut(ob,j,j+len/i-1)) continue;
					else goto S2;
				//可以被折叠 
				cnt=min(cnt,INTlen(i)+DFS(temp)+2);
			}
			S2: ;
		}
	string temp="";
	for(int i=0;i<len-1;i++)
	{
		temp=temp+ob[i];
		cnt=min(cnt,DFS(temp)+DFS(CutOut(ob,i+1,len-1)));//一刀两断
	}
	return dp[ob]=cnt;//储存
}

int main()
{
	cin>>s;
	printf("%d\n",DFS(s));
	return 0;
}
```

感觉好像比区间DP快许多?!

然鹅

![](https://cdn.luogu.com.cn/upload/pic/72400.png)

比正解慢多啦 QAQ

为什么？因为 map 的查找效率并不是 O(1) 的，而是接近于 O(1) 的多项式，数据量大了还是会挂了的啦 QAQ

---

## 作者：HenryHuang (赞：4)

~~又来填一个以前很久很久以前挖的坑~~

--------------

首先如果先抛开折叠的内部情况不谈，我们可以得到这样的一个经典的区间DP的式子
$$
f[l][r]=min(f[l][r],f[l][k]+f[k+1][r])(l<=k<=r)
$$

这个式子应该很显然吧

然后我们可以继续来思考，折叠时候的情况，比如$ABCABCABC$，它能折叠成的最短长度就是$3(ABC)$

令$len$为区间$[l,r]$中的循环节，$cal(i)$表示数字i是几位数，然后我们就可以得到
$$
f[l][r]=min(f[l][r],f[l][l+len-1]+2+cal((r-l+1)/len)(l<=k<=r)
$$

2是括号位数

这里要注意，由于循环节内部仍然可能被折叠，所以应该是$f[l][l+len-1]$

~~其实还挺简单对吧~~

然后，本题最重要的一点，就是你判断循环节的时候不要判断错了，这样会死的很惨，因为一般都不会怀疑你是那个地方出了问题，然后，我这里用的是异或来处理

由于本人太蒟蒻，所以用的是记忆化搜索

详见代码
```
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
char a[200];
int f[200][200];
int cal(int x)
{
	int ans=0;
	while(x)
	{
		++ans;
		x/=10;
	}
	return ans;
}
inline bool check(int s, int l, int c)
{  
    if(l%c) return 0;
	for(int i=s+c;i<s+l;++i)
	if(a[i]^a[(i-s)%c+s]) return 0;  
    return 1;  
}  
int dfs(int l,int r)
{
	if(f[l][r]<1e7)
		return f[l][r];//记忆化
	if(r<=l) return 1;
	f[l][r]=r-l+1;
	for(int k=l;k<=r;++k)
		f[l][r]=min(f[l][r],dfs(l,k)+dfs(k+1,r));
	int tmp=(r-l+1)/2;
	for(int len=tmp;len>=1;--len)//只有小于等于区间长度才有可能形成循环节 
			if(check(l,r-l+1,len))
				f[l][r]=min(f[l][r],f[l][l+len-1]+2+cal((r-l+1)/len));

	return f[l][r];
}
int main()
{
	scanf("%s",a+1);
	int lena=strlen(a+1);
	memset(f,0x3f,sizeof f);
	for(int i=1;i<=lena;++i)
		f[i][i]=1;
	printf("%d",dfs(1,lena));
	return 0;
}
```




---

## 作者：Mathison (赞：4)

### 【题意描述】

一个字符串具有循环节的部分可以折叠，问折叠之后的最短的长度是多少？

### 【易错提示】

1. 不一定能折叠就折叠：比如 $\text{AA}$（长度为2）折叠后变成了$\text{2(A)}$（长度为4）;
2. 折叠后的$()$也算字符串长度
3. 折叠的数字前缀要计算位数：比如 $9$ 是一位，而 $10$ 是两位

### 【题意分析】

这个折叠的操作有没有很像合并？？想到[石子合并](https://www.luogu.org/problemnew/show/P1880)了没？？

只不过这个合并的操作需要**判断**能否合并

看来一定是区间dp了

### 【声明变量】

$a[i]$存字符串

$f[i][j]$表示区间$[i,j]$的最小长度

### 【解题思路】

- 区间dp:
  - 枚举左端点（从大到小）
    - 枚举右端点（从小到大）
      - 枚举循环节长度
        - 判断能否构成循环（判断过程见代码注释）
          - 转移
          
### 【区间dp一点小理解】

包括我最开始学习区间dp有一个疑问：为什么要从大到小枚举左端点？

现在给出最通俗易懂的解释：

我们的最终状态是$f[1][n]$（显然额）

如果从左枚举会导致 $f[1][i]$ **提前被更新**使得**后面更新的值**没有被转移到 $f[1][n]$ 而是转移到了 $f[n][n]$。
    
### 【代码实现】

```
#include<bits/stdc++.h>
using namespace std;
char a[110];
int f[110][110];
int cal(int x)//计算折叠前缀占的位数 
{
	int cnt=0;
	while(x) cnt++,x/=10;//计算折叠字符个数的位数 
	return cnt;
}
bool judge(int l,int r,int len)//判断l到r是否具有长度为len的循环节 
{
	if((r-l+1)%len) return 0;//区间长度不是len的整倍数，显然不是循环节
	for(int i=l;i<=l+len-1;i++)//枚举第一个循环节内每个字符 
	    for(int j=i+len;j<=r;j+=len)//枚举所有循环节当前位置的字符 
		    if(a[i]!=a[j]) return 0;//如果不同则说明没有构成循环 
	return 1; 
}
int main()
{
    scanf("%s",a+1);
    int n=strlen(a+1);
	for(int i=1;i<=n;i++)
	    for(int j=i;j<=n;j++)
		    f[i][j]=j-i+1;//赋初值
	for(int i=n-1;i>=1;i--)//枚举区间左端点 
	    for(int j=i+1;j<=n;j++)//枚举区间右端点 
			for(int len=1;len<=j-i+1;len++)//枚举i~j的循环节长度 
			    if(judge(i,j,len))//如果能构成循环节 
				    //区间内长度变为：循环节长度+前缀数字位数+2（括号所占的位数） 
					f[i][j]=min(f[i][j],f[i][i+len-1]+cal((j-i+1)/len)+2);
                     //否则不修改直接转移
			    else f[i][j]=min(f[i][j],f[i][i+len-1]+f[i+len][j]); 
	printf("%d",f[1][n]);
	return 0;
}
```





---

## 作者：wtxy2006 (赞：2)

#### 题目大意：
若干个重复的字符串可以被折叠，如'$\texttt{ABABAB}$' 可以折叠为'$\texttt{3(AB)}$'，允许嵌套。给出⻓为 $n$ 的字符串，求折叠后的最短⻓度。
#### 题目分析：
这道题是一道区间dp题，考虑状态：
设 $f[i][j]$ 表示区间 $[i,j]$ 的最短⻓度。
那怎么转移呢？
- 如果不进行折叠，可以直接由两个子区间加起来即为当前区间的值。
- 如果折叠，则枚举折叠的⻓度，判断是否符合条件。

综上所述,状态转移方程如下($a[k]$ 表示 $k$ 有几位)：
$$\begin{cases}f[i][j] = \min(f[i][j], f[i][k] + f[k + 1][j])(i\le k\le j);\cr
f[i][j] = \min(f[i][j], f[i][i + \frac{l}{k} - 1] + 2 + a[k])(k \in (x|l \bmod x == 0));\end{cases}$$
这里使用了一个 check()函数来判断是否重复。
``` cpp
// i:左边界;j:右边界;k:此区间内重复了几次
inline bool check(int i, int j, int k) {
  int len = j - i + 1, c = len / k;
  for (int l = i; l <= i + c - 1; l++) {
    char now = s[l];
    for (int o = 1; o < k; o++)
      if (now != s[l + o * c]) return false;
  }
  return true;
}
```
#### 完整代码：
```cpp
// P4302 [SCOI2003]字符串折叠
#include <cstdio>
#include <cstring>
#include <iostream>
#define MN 105
using namespace std;
int f[MN][MN], a[MN], n;
char s[MN];
// i:左边界;j:右边界;k:此区间内重复了几次
inline bool check(int i, int j, int k) {
  int len = j - i + 1, c = len / k;
  for (int l = i; l <= i + c - 1; l++) {
    char now = s[l];
    for (int o = 1; o < k; o++)
      if (now != s[l + o * c]) return false;
  }
  return true;
}
int main() {
  // 输入,s为字符串,n为字符串长度
  scanf("%s", s), n = strlen(s);
  // 预处理1~100的每个数的长度
  for (int i = 1; i <= 9; i++) a[i] = 1;
  for (int i = 10; i <= 99; i++) a[i] = 2;
  a[100] = 3;
  // 初始化,f[i][i]最小长度为1,其他的为极大值
  memset(f, 0x3f, sizeof(f));
  for (int i = 0; i < n; i++) f[i][i] = 1;
  // 区间dp模板
  for (int l = 2; l <= n; l++)
    for (int i = 0, j = i + l - 1; j < n; i++, j++) {
      // 1:不折叠,那么此区间的最小值是左右区间之和的最小值
      for (int k = i; k <= j; k++)
        f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j]);
      // 2:折叠,枚举此区间内重复了几次k
      for (int k = 2; k <= l; k++)
        if (!(l % k) && check(i, j, k))
          f[i][j] = min(f[i][j], f[i][i + l / k - 1] + 2 + a[k]);
    }
  printf("%d", f[0][n - 1]);
  return 0;
}
```
#### 复杂度计算：
首先外面2层循环复杂度为 $O(n^2)$，
$check()$ 函数总复杂度为 $O(n)$，
整数 $n$ 的因数个数近似 $\log n$，
所以总复杂度 $O(n^3\log n)$。
#### 后记：
这是萌新第二次写题解，如果有些不好的地方请多多指教。

---

## 作者：Dawn_Chase (赞：2)

# 没有题解?
### P党来一发
- 一看没有思路？
- 暴力出奇迹[滑稽]

## 好吧我们来进入正题
- 那么让我们来写写方程
- **f[i,j]表示最短的折叠长度**。
- 显然，f[i,j]=f[i,k]+f[k+1,j];(i<=k<=j)。
- **别忘了折叠**。
- 那么我们需要判断i~j是否能折叠。
- 怎么判断呢，取模大法好。
- 然后计算这个子串折叠后的长度，**别忘记那个数字长度，以及加上+2（括号）**。
- 像我这种蒟蒻一看题都能看出区间DP了。
- 然而，蒟蒻表示区间DP一脸懵逼，打了半天老是过不了。
- 所以呢，只好写记忆化了。

~~丢代码~~
```pascal
var st:ansistring;
    f:array[0..101,0..101] of longint;
    v:array[0..101,0..101] of boolean;
function min(x,y:longint):longint;
begin
  if x<y then
   exit(x);
  exit(y);
end;
function check(l,r,ll,rr:longint):boolean;  //判断是否能折叠
var i:longint;
begin
  if (r-l+1) mod (rr-ll+1)<>0 then
   exit(false);
  for i:=l to r do
   if st[i]<>st[(i-l) mod (rr-ll+1)+ll] then
    exit(false);
  exit(true);
end;
function leng(x:longint):longint; //统计数字长度
var ans:longint;
begin
  ans:=0;
  while x>0 do
   begin
    x:=x div 10;
    inc(ans);
   end;
  exit(ans);
end;
function ss(l,r:longint):longint;  //记忆化搜索
var i:longint;
begin
  if l=r then
   exit(1);
  if v[l,r] then
   exit(f[l,r]);
  v[l,r]:=true;
  f[l,r]:=r-l+1;
  for i:=l to r-1 do
   begin
    f[l,r]:=min(f[l,r],ss(l,i)+ss(i+1,r));
    if check(i+1,r,l,i) then
     f[l,r]:=min(f[l,r],ss(l,i)+leng((r-i) div (i-l+1)+1)+2);
   end;
  exit(f[l,r]);
end;
begin
  readln(st);
  writeln(ss(1,length(st)));
end.
```
代码太丑，大佬勿喷。

---

## 作者：_sry (赞：2)


其实一眼看到就能想到区间$dp$吧

设$dp(i,j)$表示从$i$到$j$的折叠次数最小，我们每次确定一个数$k$,若$i$~$k$能匹配$k+1$~$j$那么$dp(i,j)=dp(i,k)+2+s$,$s$为括号左面的数字的位数,$+2$是因为要算上括号，若不能则$dp(i,j)=dp(i,k)+dp(k+1,j)$

---

## 作者：红色OI再临 (赞：1)

will爷tql！！

像平常的区间dp一样，我们第一维枚举len，也就是区间长度，第二维枚举区间左端点，第三维枚举中间点，先不考虑压缩，那么状态转移方程为

$f[i][j]=min(f[i][k],f[k+1][j])$

现在考虑压缩，我们首先先暴力处理1~100的数字位数（反正也不多QAQ）

我们枚举循环节长度再判断是不是循环节，状态转移方程为

$f[i][j]=min(f[i][j],f[i][k]+2+nl[len/l])$

`nl[len/l]`为压缩后数字位数

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#define re register int
#define ll long long
#define maxn 200
using namespace std;
int f[maxn][maxn];
int n,m,nl[maxn];
char s[maxn];
bool pd(char as[],int n,int len){
	for(re i=len;i<n;i++)
	if(as[i]!=as[i%len])return 0;
	return 1;
}

int main(){
	scanf("%s",s+1);
	n=strlen(s+1);
	for(re i=1;i<=9;i++)
		nl[i]=1;
	for(re i=10;i<=99;i++)
		nl[i]=2;
	nl[100]=3;
	memset(f,0x3f,sizeof(f));
	for(re i=1;i<=n;i++)
		f[i][i]=1;
		int j;
		for(re len=2;len<=n;len++){
			for(re i=1;(j=i+len-1)<=n;i++){
				for(re k=i;k<j;k++)
					f[i][j]=min(f[i][j],f[i][k]+f[k+1][j]);		
		for(re k=i;k<j;k++){
			int l=k-i+1;
			if(len%l!=0)continue;
			if(pd(s+i,len,l)){
				f[i][j]=min(f[i][j],f[i][k]+2+nl[len/l]);
				//f[i][k]+2(括号）加数字长度 
			}
		}	
}
}
	printf("%d\n",f[1][n]);
	return 0;
	
}
```


---

## 作者：长江豚 (赞：0)

**题解**
1.算法思路
（1）dp核心：
看到区间求解会顺理成章的想到区间dp，将问题转换成多个子问题求解
根据区间dp通过子问题求解的特性
我们可以写出换与不换两种dp方程，如下

```c
//k是区间i到j中间枚举出的一个点
dp[i][j]=min(dp[i][j],dp[i][k]+2+solve(l/(k-i+1)));
//2是括号的长度，solve是用来求系数的长度，比如系数为39，solve就会返回2
dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]);//直接通过子问题转移求解
```
这里我们需要注意的是不一定折叠了就会更优，如 aaa折叠为3（a）就会更长
（2）check：
我们的第一个dp的使用是有条件的---------能够折叠
所以在dp过程中我们需要先check一下能否折叠

```c
int check(int x1,int y1,int x2,int y2)
{
	if((y2-x1+1)%(y1-x1+1)!=0) return 0;//判断能否被折叠成这个长度为y1-x1+1的片段
	int h=y1-x1+1;//将要折叠成为的长度
	for(int i=x2;i<=y2;i++)
	{
		if(v[i]!=v[i-h]) return 0;
		//这里其实还是有一些投机的，不需要改变数组初始位置以及取模来与第一个模板比较，而是可以层层check
	}
	return 1;//如果可以就return true
}
```
（3）dp初始化：这是一个很重要的细节点，单列一波。
因为求小，先直接memset为较大数。
然后因为每个区间长度唯一的dp数组都在开始一定为1（因为只一个字符嘛）
然后dp[i][j]因为表示的是从i到j的区间内的字符串最短长度，所以应该初始化为初始的字符串长度，即j-i+1

2.附上AC代码+注释

```c
#include<cstdio>
#include<iostream>
#include<stack>
#include<algorithm>
#include<cmath>
#include<cstring>
#define maxn 105
#define ll long long int 
using namespace std;
char v[maxn];
int dp[maxn][maxn];
int check(int x1,int y1,int x2,int y2)
{
	if((y2-x1+1)%(y1-x1+1)!=0) return 0;
	int h=y1-x1+1;
	for(int i=x2;i<=y2;i++)
	{
		if(v[i]!=v[i-h]) return 0;
	}
	return 1;
}
int solve(int k)
{
	int su=0;
    while(k)
    {
        su++;
        k/=10;
    }
    return su;
}
int get[105];
int len;
int main()
{	
	memset(dp,0x3f,sizeof(dp));
	cin>>v;
	len	=strlen(v);
	for(int i=0;i<len;i++)
		dp[i][i]=1;
	
	for(int l=2;l<=len;l++)
	{
		for(int i=0,j;(	j=l+i-1)<len;i++)
		{
			dp[i][j]=j-i+1;
			for(int k=i;k<j;k++)
			{
				k-i+1;
				if(check(i,k,k+1,j))
				{
					dp[i][j]=min(dp[i][j],dp[i][k]+2+solve(l/(k-i+1)));
				}
				else
				{
					dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]);//这里也可以拿出去，不过更加麻烦
				}
			}
		}
	}
	cout<<dp[0][len-1];
	return 0;
}
```


---

## 作者：Accoty_AM (赞：0)

~~可能我太弱，一眼看去好水~~

#  考虑从前向后转移

### 由  dp[l][r]=min(dp[l][k]+dp[k+1][r]) 处理出当前区间最优值


## 设当前区间长度为‘len’从前往后找和当前区间匹配紧挨着的区间，找到区间后用（整个处理到的区间/当前区间）所表示数字长度+2来更新后面的区间。


### 每次向后跳len长度，一旦不匹配就结束，因为这次匹配到的区间不能更新，后面的区间肯定也不行。


看代码注释


代码

```cpp
#include<bits/stdc++.h>
namespace Z_i_X{
	#define pr pair<int,int> 
	#define mme(x,val) memset(x,val,sizeof x)
	#define foe(i,n,val) for(int i=val;i<=n;++i)
	#define max(a,b) a>b?a:b;
	#define min(a,b) a<b?a:b;
	#define rg register
	inline int read(){
		rg char ch=getchar();
		rg int x=0,f=0;
		while(!isdigit(ch)) f|=(ch=='-'),ch=getchar();
		while(isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
		return f?-x:x;
	}
};
using namespace Z_i_X;
using namespace std;
char s[110];
int n;
int f[110][110];
inline int work(int l,int r,int ll,int rr){
	for(int i=0;i<=r-l;++i) if(s[l+i]!=s[ll+i]) return false;
	return true;
}
inline int ws(int x){//处理区间长度
	int sum=0;
	while(x){
		++sum;
		x/=10;
	}
	return sum;
}
inline int get(int l,int r,int ll,int rr){//处理区间倍数关系
	int len=r-l+1;
	int lenl=rr-ll+1;
	return ws(lenl/len);
}
	
int main(){
	scanf("%s",s+1);
	n=strlen(s+1);
	mme(f,0x3f);
	for(int i=1;i<=n;++i) f[i][i]=1;
	for(int len=1;len<=n;++len){
		for(int l=1;l+len-1<=n;++l){
			int r=l+len-1;
			for(int k=l;k<r;++k)//dp[l][r]=max(dp[l][k]+dp[k+1][r])
				f[l][r]=min(f[l][r],f[l][k]+f[k+1][r]);
			for(int k=r+1;k+len-1<=n;k+=len){//用当前区间更新后面的区间
				if(work(l,r,k,k+len-1)){
					f[l][k+len-1]=min(f[l][k+len-1],f[l][r]+2+get(l,r,l,k+len-1));
				}else break;//一但当前不匹配直接跳出
			}
		}
	}
	cout<<f[1][n]<<endl;
				
	return 0;
}

```


---

## 作者：_vandarkholme (赞：0)

dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])
然后去判断当前子串能不能压缩，即是否由重复字符串组成，
判断时只需暴力枚举重复长度，去判断即可。

如果当前子串可以压缩,则
   dp[i][j] = min(dp[i][j], dp[i][i + len - 1] + 2 + cnt((j - i + 1) / len));，
注意如果是数字，要用数字的位数表示增加的个数，而不是单纯的增加1.
其中 cnt(x)函数，就是计整数x的位数 

```
#include <cstdio>
#include <cstring>

using namespace std;
const int N=210;
char str[N];
int n, dp[N][N];
inline int mn(int a, int b){
    return a>b ? b : a;
}
int cnt(int x){//统计x的数字个数 
    int a=0;
    while (x){
        a++;  x/=10;
    }
    return a;
}

bool check(int l, int r, int len){//检查从l到r是否为相同字符串重叠而成 
    if ((r-l+1)%len) return false;
    for (int i=l; i<l+len; i++) {
        for (int j=i+len; j<=r; j+=len)
            if (str[i]!=str[j]) return false;
    }
    return true;
}

int cal(){//区间DP ，dp[i][j]表示从i到j的字符串压缩后的最短长度。 
    n=strlen(str+1);
    for (int i=1; i<=n; i++) dp[i][i]=1;
    for (int i=n-1; i>=1; i--) {
        for (int j=i+1; j<=n; j++) {
            dp[i][j]=1<<30;
            for (int k=i; k<j; k++)
                dp[i][j]=mn(dp[i][j], dp[i][k]+dp[k+1][j]);
            for (int len=1; len<=j-i+1; len++) {
                if (check(i, j, len)) {
                    dp[i][j]=mn(dp[i][j], dp[i][i+len-1]+2+cnt((j-i+1)/len));
                }
            }
        }
    }
    return dp[1][n];
}

int main(){
    scanf("%s", str+1); 
    printf("%d\n", cal());
    return 0;
}
```



---

## 作者：长江豚 (赞：0)

区间dp--P4302 [SCOI2003]字符串折叠
--
[传送门](https://www.luogu.org/problem/P4302)
sorry上一篇提交错了
**题解**
1.算法思路
（1）dp核心：
看到区间求解会顺理成章的想到区间dp，将问题转换成多个子问题求解
根据区间dp通过子问题求解的特性
我们可以写出换与不换两种dp方程，如下

```c
//k是区间i到j中间枚举出的一个点
dp[i][j]=min(dp[i][j],dp[i][k]+2+solve(l/(k-i+1)));
//2是括号的长度，solve是用来求系数的长度，比如系数为39，solve就会返回2
dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]);//直接通过子问题转移求解
```
这里我们需要注意的是不一定折叠了就会更优，如 aaa折叠为3（a）就会更长
（2）check：
我们的第一个dp的使用是有条件的---------能够折叠
所以在dp过程中我们需要先check一下能否折叠

```c
int check(int x1,int y1,int x2,int y2)
{
	if((y2-x1+1)%(y1-x1+1)!=0) return 0;//判断能否被折叠成这个长度为y1-x1+1的片段
	int h=y1-x1+1;//将要折叠成为的长度
	for(int i=x2;i<=y2;i++)
	{
		if(v[i]!=v[i-h]) return 0;
		//这里其实还是有一些投机的，不需要改变数组初始位置以及取模来与第一个模板比较，而是可以层层check
	}
	return 1;//如果可以就return true
}
```
（3）dp初始化：这是一个很重要的细节点，单列一波。
因为求小，先直接memset为较大数。
然后因为每个区间长度唯一的dp数组都在开始一定为1（因为只一个字符嘛）
然后dp[i][j]因为表示的是从i到j的区间内的字符串最短长度，所以应该初始化为初始的字符串长度，即j-i+1

2.附上AC代码+注释

```c
#include<cstdio>
#include<iostream>
#include<stack>
#include<algorithm>
#include<cmath>
#include<cstring>
#define maxn 105
#define ll long long int 
using namespace std;
char v[maxn];
int dp[maxn][maxn];
int check(int x1,int y1,int x2,int y2)
{
	if((y2-x1+1)%(y1-x1+1)!=0) return 0;
	int h=y1-x1+1;
	for(int i=x2;i<=y2;i++)
	{
		if(v[i]!=v[i-h]) return 0;
	}
	return 1;
}
int solve(int k)
{
	int su=0;
    while(k)
    {
        su++;
        k/=10;
    }
    return su;
}
int get[105];
int len;
int main()
{	
	memset(dp,0x3f,sizeof(dp));
	cin>>v;
	len	=strlen(v);
	for(int i=0;i<len;i++)
		dp[i][i]=1;
	
	for(int l=2;l<=len;l++)
	{
		for(int i=0,j;(	j=l+i-1)<len;i++)
		{
			dp[i][j]=j-i+1;
			for(int k=i;k<j;k++)
			{
				k-i+1;
				if(check(i,k,k+1,j))
				{
					dp[i][j]=min(dp[i][j],dp[i][k]+2+solve(l/(k-i+1)));
				}
				else
				{
					dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]);//这里也可以拿出去，不过更加麻烦
				}
			}
		}
	}
	cout<<dp[0][len-1];
	return 0;
}
```


---


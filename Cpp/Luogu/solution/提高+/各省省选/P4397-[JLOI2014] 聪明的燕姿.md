# [JLOI2014] 聪明的燕姿

## 题目背景

> 阴天傍晚车窗外
>
> 未来有一个人在等待
>
> 向左向右向前看
>
> 爱要拐几个弯才来
>
> 我遇见谁会有怎样的对白
>
> 我等的人他在多远的未来
>
> 我听见风来自地铁和人海
>
> 我排着队拿着爱的号码牌

## 题目描述

城市中人们总是拿着号码牌，不停寻找，不断匹配，可是谁也不知道自己等的那个人是谁。

可是燕姿不一样，燕姿知道自己等的人是谁，因为燕姿数学学得好！燕姿发现了一个神奇的算法：假设自己的号码牌上写着数字 $S$，那么自己等的人手上的号码牌数字的所有正约数之和必定等于 $S$。

所以燕姿总是拿着号码牌在地铁和人海找数字（喂！这样真的靠谱吗）可是她忙着唱《绿光》，想拜托你写一个程序能够快速地找到所有自己等的人。

## 说明/提示

对于 $100\%$ 的数据，$k\leqslant100$，$S\leqslant2\times10^9$。

## 样例 #1

### 输入

```
42```

### 输出

```
3
20 26 41```

# 题解

## 作者：ycyaw (赞：42)

给你一个数$S$，求约数和等于$S$的数。

好像也没什么好说的，主要就两个式子：

1、整数的唯一分解定理

![](https://i.loli.net/2019/03/29/5c9daab21c74d.png)

2、一个数的所有约数和

![](https://i.loli.net/2019/03/29/5c9daedb4a11e.png)

然后发现枚举选了哪些质数，以及这些质数的指数，等于得到了$x$，判断$S$是否符合条件即可。暴力枚举肯定会$T$，那就搜索，因为搜索可以在条件满足时再进入下一层，效率肯定大于枚举。

搜索需要三个参数，$now$，$x$，$s$，分别表示：还剩多少能够分解，当前枚举第$x$个质数，当前是哪个数。

我们知道，搜索满足条件时，就可以得到答案。那么，什么叫满足条件？有两种：

1、若当前数$now$可表示成一个并未搜索过的质数与$1$的和$($设这个质数为$p$，其实就是$p^{0}+p^{1}$ $)$，则$s$与$p$的乘积可以成为答案。

2、$now=1$，即当前的数不能再分解。则当前的数$s$可以成为答案。

主要的核心还是搜索，写了注释便于理解：
```cpp
#include<bits/stdc++.h>
#define ts cout<<"ok"<<endl
#define oo (1e18)
#define int long long
#define LL unsigned long long
#define hh puts("")
using namespace std;
int pr[100005],top=0,ans[100005],cnt;
bool v[100005];
inline int read(){
    int ret=0,ff=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-') ff=-ff;ch=getchar();}
    while(isdigit(ch)){ret=(ret<<3)+(ret<<1)+(ch^48);ch=getchar();}
    return ret*ff;
}
inline bool pd(int x){
    if(x==1) return 0;
    for(int i=2;i*i<=x;i++) if(x%i==0) return 0;
    return 1;
}
void dfs(int now,     int x,      int s){
// 还剩多少能够分解  第x个质数  当前是哪个数
    if(now==1){
        ans[++cnt]=s;
        return;
    }
    if(pd(now-1)&&now>pr[x]) ans[++cnt]=s*(now-1);
    for(int i=x;pr[i]*pr[i]<=now;i++){//枚举下一个选哪个质数 
        int t=pr[i];//t为次方和的最后一个数
        int sum=pr[i]+1;//sum为总次方和 
        for(;sum<=now;t*=pr[i],sum+=t) 
            if(now%sum==0) 
                dfs(now/sum,i+1,s*t);
    }
}
signed main(){
    memset(v,1,sizeof(v));
    v[1]=0;
    for(int i=2;i<=100000;i++){
        if(v[i]) pr[++top]=i;
        for(int j=1;j<=top&&pr[j]*i<=100000;j++){
            v[i*pr[j]]=0;
            if(i%pr[j]==0) break;
        }
    }
    int x;
    while(scanf("%lld",&x)!=EOF){
        cnt=0;
        dfs(x,1,1);
        sort(ans+1,ans+cnt+1);
        printf("%lld\n",cnt);
        for(int i=1;i<=cnt;i++) printf("%lld ",ans[i]);
        if(cnt) hh;
    }
    return 0;
}
```


---

## 作者：LaoPi (赞：26)

### 一、题目


#### 题目背景

阴天傍晚车窗外

未来有一个人在等待

向左向右向前看

爱要拐几个弯才来

我遇见谁会有怎样的对白

我等的人他在多远的未来

我听见风来自地铁和人海

我排着队拿着爱的号码牌

#### 题目描述
城市中人们总是拿着号码牌，不停寻找，不断匹配，可是谁也不知道自己等的那个人是谁。

可是燕姿不一样，燕姿知道自己等的人是谁，因为燕姿数学学得好！燕姿发现了一个神奇的算法：假设自己的号码牌上写着数字 $S$，那么自己等的人手上的号码牌数字的所有正约数之和必定等于 $S$。

所以燕姿总是拿着号码牌在地铁和人海找数字（喂！这样真的靠谱吗）可是她忙着唱《绿光》，想拜托你写一个程序能够快速地找到所有自己等的人。

#### 输入格式

输入包含 $k$ 组数据。 对于每组数据，输入包含一个号码牌$S$。

#### 输出格式

对于每组数据，输出有两行，第一行包含一个整数 $m$，表示有 $m$ 个等的人。

第二行包含相应的 $m$ 个数，表示所有等的人的号码牌。

注意：你输出的号码牌必须按照升序排列。

#### 输入输出样例

输入
```
42
```

输出 
```
3

20 26 41
```
#### 说明/提示

对于$100%$的数据，$k≤100, S≤2×10^9 $。



### 二、问题抽象化：

求约数和等于$S$的数。

### 三、需知定理&推导过程：

#### 1.唯一分解定理：

任何一个大于1的自然数N，都可以唯一分解成有限个质数的乘积

$N=P_1^{a_1}*P_1^{a_1}*P_2^{a_2}*…*P_n^{a_n}$，

$PS$：这里$P_1<P_2<…<P_n$均为质数，其诸指数$a_i$是正整数。
这样的分解称为N的标准分解式。

#### 2.约数和定理：

对于任意一个大于1的正整数N可以分解正整数：$N=P_1^{a_1}*P_2^{a_2}…P_n^{a_n}$，

则由约数个数定理可知N的正约数有$(a_1+1)(a_2+1)(a_3+1)…(a_n+1)$个，

那么$N$的$(a_1+1)(a_2+1)(a_3+1)…(a_n+1)$个正约数的和为

$(P_1^0+P_1^1+P_1^2+…+P_1^{a_1})(P_2^0+P_2^1+P_2^2+…P_2^{a_2})…(P_n^0+P_n^1+P_n^2+…P_n^{a_n})$


用搜索将$N$分解为$(P_1^0+P_1^1+…+P_1^{k_1})(P_2^0+P_2^1+…+P_2^{k_2})…(P_n^0+P_n^1+…+P_n^{k_n})$

每一次成功的分解都会产生一个答案

$P_1^{k_1}*P_2^{k_2}*……*P_n^{k_n}$

### 四、代码:
```cpp
#include<stdio.h>
#include<algorithm>//简约头文件 
int p[500050]/*线筛中记录质数*/,len/*线筛中质数个数*/,m/*题目中m个等的人*/,a[500050]/*记录m个人的号码牌*/,s/*自己的号码牌上写着的数字*/;
bool v[500050];//线筛中记录是否为质数 
inline void prime(){
	v[1]=1;
    for(int i=2;i<=100000;i++) {
        if(!v[i])
            p[++len]=i;
        for(int j=1;j<=len;++j) {
        	if(p[j]*i>100000){
        		break;
			}
            v[i*p[j]]=1;
            if(!(i%p[j])){//i%p[j]==0
                break;
            } 
        }
    }
}//线筛模板，求100000以内质数
inline bool is_prime(int n){//由于v数组的范围有限，不能判断大于100000的数，所以得再写一个判质数的程序 
	if(n<100000){
		return!v[n];
	}//在这里做了一个小小的优化，巧妙利用v数组 
    for(int i=1;p[i]*p[i]<=n;i++){//这里又做了一个优化，只枚举质数 
        if(!(n%p[i])){//n%p[i]==0
			return 0;
        }
    }
    return 1;
}//判质数 
inline void dfs(int x/*第x个质数*/,int k/*还剩k能够分解*/,int num/*当前数为num*/){//功能详见前文 
    if(k==1){
        a[++m]=num;
        return;
    }
    if(k>p[x]&&is_prime(k-1)){
    	a[++m]=(k-1)*num;
	}//特判
    for(int j=x;p[j]*p[j]<=k;j++){//枚举下一次选的质数因子 
        int cnt=p[j]+1,tmp=p[j];//cnt为总次方和，tmp为次方和的最后一个数
        for(;cnt<=k;tmp*=p[j],cnt+=tmp){//枚举有多少个因子
        	if(k%cnt==0){
        		dfs(j+1,k/cnt,num*tmp);
			}
		}
    }//实现分解 
}
signed main(){//因为“#define int long long” 
	prime();//筛质数 
    while(~scanf("%lld",&s)){//用于读入本题数据 
        m=0;//每次赋初值 
        dfs(1,s,1);//实现分解n（详见上文分析） 
        printf("%lld\n",m);
        std::sort(a+1,a+m+1);//为符合题目要求，将a数组排序 
        for(int i=1;i<=m;i++){
        	printf("%lld ",a[i]);
		}//输出a数组
        if(m){
        	printf("\n");
		}//本题逐行评测，没有这一句会全部WA掉 
    }
    return 0; 
}
```


### 五、结果：

分数 100

代码长度 1.63KB

用时 114ms

内存 888.00KB

---

## 作者：timmark (赞：16)

# P4397 题解
一道有一定代码难度的数学题。

本题的关键在于求一个数的因子和。

我们先来看一个公式：

如果一个数 $n$ 可以唯一分解为

$$
n=p_1^{a_1}\times p_2^{a_2}\times\cdots\times p_k^{a_k}
$$

则 $n$ 的正因子个数等于

$$
(a_1+1)(a_2+1)\cdots(a_k+1)
$$

也可以写作

$$
\prod \limits^{k}_{i=1} (a_i+1)
$$

很好理解，乘法原理，每一个因子 $p_i$ 都可以选择 $0\sim a_i$ 中的任意次方。

接下来，是这道题的重点：

如果 $n$ 可以唯一分解为上面的形式，则 $n$ 所有的正因子的和等于

$$
(1+p_1+{p_1}^2+\cdots+{p_1}^{a_1})(1+p_2+{p_2}^2+\cdots+{p_2}^{a_2})\cdots(1+p_k+{p_k}^2+\cdots+{p_k}^{a_k})
$$

也可以写作

$$
\prod \limits^{k}_{i=1} \sum \limits^{a_i}_{j=0} {p_i}^j
$$

理解方法类似，~~读者自证不难~~。

那么，接下来，我们考虑这个问题怎么实现。

后文中为了简便，用 $f(n,m)$ 表示 $1+n+n^2+\cdots+n^m$。

首先，处理出 $\sqrt{N}$ 范围内的质数（其中 $N$ 为 $S$ 的最大值，本题中为 $2\times 10^9$）。

接下来，使用 dfs，记录 $3$ 个参数，分别为：当前搜索到的质数编号 $step$、$S$ 到目前剩余的部分 $num$、当前选择的每一个质数 $p_i$ 的 $f(p_i,j)$ 的乘积 $now$。初始时，$step=1$，$num=S$，$now=1$。

设当前质数为 $p_{step}$，枚举 $j$，如果 $f(p_{step},j)$ 整除 $num$，则继续搜索，用 $p_{step}$ 后面的质数 $p_l$，用 $f(p_l,x)$ 来“拼出”$\dfrac{num}{f(p_{step},j)}$。

接下来考虑什么时候搜索停止，或者说记录答案。

显然，对于当 $num=1$ 时，答案为 $now$，然后退出搜索。

还有其他情况吗？

如果只有上面这种情况，显然这个程序的复杂度是 $\text O(S)$ 的，对于 $S=2\times10^9$ 的情况显然会爆炸。

我们发现，$f(n,m)$ 的增长速度极快，在 $j=2$ 时就会达到 $\text O(n^2)$ 级别。

$\text O(n^2)\le 2\times10^9$，估计一下，$n$ 大概最多也就 $5\times10^4$ 左右。

所以，我们只需要考虑哪些满足 $p_i\le \sqrt{num}$ 的质数 $p_i$，然后对于 $num-1$ 是质数的情况记录答案 $now\times(num,-1)$ 即可（因为质数的因子只有 $1$ 和自身，所以因子和为自身 $+1$）。

本题还有一个坑，题目里没说清楚，那就是如果符合条件的答案不存在，只输出一行 $0$，不输出换行。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll maxm=1e6;
ll n,p[maxm],cp,cnt,ans[maxm];
bool np[maxm+5];
void gp(){//线性筛
	for(int i=2;i<=maxm;i++){
		if(!np[i]) p[++cp]=i;
		for(int j=1;j<=cp;j++){
			if(p[j]*i>maxm) break;
			np[p[j]*i]=1;
			if(i%p[j]==0) break;
		}
	}
}bool ip(ll num){//判断质数
	if(num<=maxm) return np[num];//在线性筛范围内的直接返回
	for(int i=2;i*1ll*i<=num;i++) if(num%i==0) return 1;//在线性筛范围外的根号复杂度判断
	return 0;
}void dfs(ll num,ll step,ll now){
	if(num==1){
		ans[++cnt]=now;
		return ;
	}if(num>p[step] && !ip(num-1)) ans[++cnt]=now*(num-1);//非常重要，重点优化
	for(int i=step;p[i]*p[i]<=num/*只到 num 的平方根*/;i++){
		ll sum=p[i]+1,power=p[i];
		for(int j=1;sum<=num;j++){
			if(num%sum==0) dfs(num/sum,i+1,now*power);//整除的话继续搜
			power*=p[i],sum+=power;
		}
	}
}signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	gp();
	while(cin >> n ){
		cnt=0;
		dfs(n,1,1);
		sort(ans+1,ans+cnt+1);//排序，答案可能无序
		cout << cnt << "\n" ;
		for(int i=1;i<=cnt;i++) cout << ans[i] << " " ;
		if(cnt) cout << "\n" ;//坑
	}return 0;
}
```
看到这里，点个赞吧。

---

## 作者：mohei0 (赞：11)

# 题意

给出一个数 $S$ ,求约数和等于 $S$ 的数。

# 分析

## 约数和定理

我们知道，求一个数 $x$ 的约数和，可以先将它分解质因数，得到

$$\large x=\prod_{i=1}^kp_i^{a_i} $$

$x$ 的约数和就等于

$$\prod_{i=1}^k(\sum_{j=0}^{a_i}p_i^j) $$

那么这题就是将此反推会去求 $x$ 。

定义一个数 $a$ 满足 $a=\sum_{i=0}^b p^i=(1+p+p^2+\dots+p^b)$ ，这里 $b$ 没有限定， $p$ 为任意质数，我们把 $a$ 叫做“质数和”， $p^b$ 叫做 $a$ 的最大加数（自己瞎定义的，方便下面说明）。

**那么 $S$ 就是几个质数和的乘积，我们就要把 $S$ 分解开来， $x$ 就等于这些质数和的最大加数的乘积，注意这样分解可能不止一种分解方法，不是唯一分解的。**

## 预处理

**我们可以先处理出 $1$ 到 $\sqrt S$ 的质数，用于预处理出 $1$ 到 $S$ 的质数和。**

这里处理出来的质数和不是所有的质数和，而是 $p\leq\sqrt S$ 且质数和小于等于 $S$ 的质数和。

那 $\sqrt S<p\leq S$ 的质数和呢？

我们发现满足此条件的 $p^2>S$ 所以只会出现形同 $1+p$ 这样质数和小于等于 $S$ ，而 $1+p$ 又大于 $\sqrt S$ ，在分解中只会出现一次，所以分解到最后可以直接 $O(\sqrt S)$ 判断是否为这种质数和就好了，无需预处理。

**为了最后得出 $x$ ，我们用 $map$ 存这些质数和，关键字是质数和，关键字的值是这个质数和的最大加数。**

因为一个数可能是 $p$ 不同的质数和，如 $31=1+2+4+8+16=1+5+25$ 所以**关键字的值要用 $vector$ 存。**

## 分解 $S$

预处理出质数和，我们再枚举 $S$ 的约数，把同为 $S$ 约数和质数和的数拎出来，就可以递归分解 $S$ 了。

把 $S$ 分解成质数和的乘积，最后统计答案就好了。

这里有一个小细节，统计答案时不是要把最大加数都乘起来吗，这里所以的最大加数都要相互互质，不然就会出现 $(1+p+p^2)\cdot(1+p+p^2+p^3)=S$ 且 $p$ 相同情况，这根本不符合约数和定理。

# 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

long long gcd(long long x,long long y){return y?gcd(y,x%y):x;}

//prime 筛质数 
int prime[10000]={0},pn=0;
void getprime()
{
    bool is_prime[50000]={0};
    for(int i=2;i<=50000;i++)
    {
        if(!is_prime[i]) prime[++pn]=i;
        for(int j=1;j<=pn&&prime[j]*i<=50000;j++)
        {
            is_prime[prime[j]*i]=1;
            if(!(i%prime[j])) break;
        }
    }
}
//isprime 判断质数 
bool isprime(long long x)
{
    for(int i=2;i<=sqrt(x);i++)
        if(!(x%i)) return 0;
    return 1;
}

//Map 用Map记录下可以分成 1+p+p^2... 的数 
map<long long,vector<long long> > Map;
void getMap()
{
    for(long long i=1,sum,power;i<=pn;i++)
    {
        power=prime[i];
        sum=1+power;
        while(sum<=2e9)
        {
            Map[sum].push_back(power);
            power*=prime[i];
            sum+=power;
        }
    }
}

//ans
long long ans[100000]={0},ansn=0,final_ans[100000]={0};

//div div是S的约数，同时这个约数要满足可以分成 1+p+p^2... 
long long S,sqrt_S;
int S_div[50000]={0},dn=0;
void getdiv()
{
    for(long long i=1;i<=sqrt_S;i++)
    {
        if(!(S%i))
        {
            if(Map.find(i)!=Map.end()) S_div[++dn]=i;
            if(i!=S/i&&Map.find(S/i)!=Map.end()) S_div[++dn]=S/i;
        }
    }
    sort(S_div+1,S_div+1+dn);
}

//put q into ans
vector<int> q;
void putout(long long prod,int p)
{
    if(p>=q.size())
    {
        return (void)(ans[++ansn]=prod);
    }
    for(int i=0;i<Map[q[p]].size();i++)
        if(gcd(prod,Map[q[p]][i])==1)
        	putout(prod*Map[q[p]][i],p+1);
}

//q （ q 为队列，因为有些数会被分成不同的 1+p+p^2... 所以要加入队列中用 putout 遍历一遍）
void getq(int now_S,int now_div)
{
    if(now_S==1) return putout(1,0);
    for(int i=now_div;i<=dn;i++)
    {
        if(now_S<S_div[i]) break;
        if(now_S%S_div[i]==0)
        {
            q.push_back(S_div[i]);
            getq(now_S/S_div[i],i+1);
            q.pop_back();
        }
    }
    if(now_S>sqrt_S&&isprime(now_S-1)) putout(now_S-1,0);
}

int main()
{
    getprime();
    getMap();

    while(cin>>S)
    {
        memset(ans,0,sizeof(ans));
        memset(S_div,0,sizeof(S_div));
        dn=0;
        ansn=0;
        sqrt_S=sqrt(S);
        getdiv();

        getq(S,1);

        sort(ans+1,ans+1+ansn); //将答案排序 
        long long *p=unique(ans+1,ans+1+ansn); //去重 
        ansn=0;
        for(long long *i=&ans[1];i!=p;i++,ansn++); //统计个数 
        cout<<ansn<<endl;
        for(long long *i=&ans[1];i!=p;i++) //输出 
        {
        	cout<<*i;
        	if(i+1!=p) cout<<" ";
        	else cout<<endl;
        }
    }
}
```

---

## 作者：andychen_2012 (赞：5)

## 解题思路

我们可以先把 $\sqrt{n}$ 以内的质数求出来先。

然后一个个枚举 $1$ ~ $n$ 的数，将约数求出来后进行判断，看是否与n相同，相同的话答案加 $1$，将这个数加入答案数组。

那么如何求一个数的约数和呢？

这里介绍一个求约数和的公式。

我们假设一个数有一个数 $x$，然后这个数可以被拆成 $m$ 个质数 $a_k$ 的相乘。

$$x=\prod \limits_{k=1}^{m} p_{k}^{a_k}$$

那么这个数的约数和为：

$$f(x)=\prod \limits_ {k=1}^{m}\sum \limits_ {i=0}^{a_i} p_{k}^{i}$$

这样的话时间复杂度为 $O(n\sqrt{n})$ 是绝对过不了的。

我们接下来想着简化。

我们可以发现：

$$n=f(x)=\prod \limits_ {k=1}^{m}\sum \limits_ {i=0}^{a_i} p_{k}^{i}$$

也就是说 $n$ 为一些数的乘积。

那么我们可以将 $n$ 进行质因数分解。

然后我们就可以得到每一个 $\sum \limits_ {i=0}^{a_i} p_{k}^{i}$ 

最后根据这些就可以用dfs得到每一个 $ans$，又因为质数乘积得到唯一的数，所以 $ans$ 数量就是 $n$ 能够拆分的数量。

这里简单讲一下线性筛。

```cpp
v[1]=1;		//1不是质数 
for(int i=2;i<=50000;++i){		//枚举到最大的数 
	if(!v[i]) pr[++k]=i;		//如果现在这个点还没有被访问过，那么这个数就是质数 
	for(int j=1;j<=k&&pr[j]*i<=50000;++j){		//从i*2枚举到最大值 
		v[i*pr[j]]=1;
		if(i%pr[j]==0) break;
	}
}
```

以上是线性筛的代码。

具体细节看代码。

## 解题代码

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
typedef long long ll;
int s,k;
bool v[50005];
int pr[50005];
ll ans[50005],cnt=0;
inline bool jud(int x){
	if(x==1) return 0;
	for(int i=2;i*i<=x;++i) if(x%i==0) return 0;
	return 1;
}
inline void dfs(int now,int x,int s){
	if(now==1){		//加入现在所剩的数为1，那么就不能够再进行分解了，存入ans后直接返回 
		ans[++cnt]=s;
		return;
	}
	//如果now-1是质数的话，那么now-1的因数只有now-1和1，加起来正好为now
	//所以现在可以将进行到的数乘上now-1存入ans 
	if(jud(now-1)&&now>pr[x]) ans[++cnt]=s*(now-1);
	for(int i=x;pr[i]*pr[i]<=now;++i){		//这里是将now进行拆分，枚举下一个选的质数 
		int t=pr[i];		//t是平方不超过now的质数 
		int sum=t+1;		//sum则是次方的和，后面会多次累计 
		while(sum<=now){		//只要次方和比now小，就一直进行 
			if(now%sum==0) dfs(now/sum,i+1,s*t);	//如果sum能够整除now，也就是说sum是now的因数，就继续dfs 
			t*=pr[i]; 
			sum+=t;
		}
	}
}
int main(){
	v[1]=1;
	for(int i=2;i<=50000;++i){		//线性筛 
		if(!v[i]) pr[++k]=i;
		for(int j=1;j<=k&&pr[j]*i<=50000;++j){
			v[i*pr[j]]=1;
			if(i%pr[j]==0) break;
		}
	}
	while(~scanf("%d",&s)){
		cnt=0;
		dfs(s,1,1);		//当前分解的数，第x个质数，当前进行到第几个数 
		sort(ans+1,ans+cnt+1);		//要注意，因为dfs的时候，顺序是不定的，所以这里要排序 
		printf("%lld\n",cnt);
		for(int i=1;i<=cnt;++i) printf("%lld ",ans[i]);
		if(cnt) puts("");
	}
	return 0;
}
```


---

## 作者：RainFestival (赞：5)

我们知道，一个数的约数和是

它的每个质因子的各个次方之和再连乘

举个例子

360=2^3×3^2×5

约数和=(1+2^1+2^2+2^3)×(1+3^1+3^2)×(1+5^1)

所以我们枚举质数

先找出1-100000的质数

然后搜索质数前k次方和（质数不能重复）

就可以了

注意如果n-1也质数也要搜

我们可以确定，搜出的数不会重复，不会多，不会少

附上代码:

```
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int a[100005],b[1000005],ans,sum,n,pri[100005],del,bo;
long long adddsum=0;
int is_prime(int ch)
{
    if (ch<2) return 0;
    for (int i=2;i*i<=ch;++i)
        if (ch%i==0) return 0;
    return 1;
}
void dfs(int k,int mmin,int sum)
{
    if (k==1)
    {
        ans++;
        b[ans]=sum;
        return;
    }
    else
    {
        if (k-1>=pri[mmin]&&is_prime(k-1)) dfs(1,-1,sum*(k-1));
        for (int i=mmin;pri[i]*pri[i]<=k;++i)
        {
            int p=1,add=1,now=pri[i];
            for (int j=1;p<=k;++j)
            {
                add=add*now;
                p=p+add;
                if (k%p==0) dfs(k/p,i+1,sum*add);
            }
        }
    }
}
int main()
{
    for (int i=2;i<=100000;++i) a[i]=1;
    for (int i=2;i<=100000;++i)
        if (a[i])
        {
        	sum++;
        	pri[sum]=i;
        	for (int j=i;j<=100000/i;++j)
        	    a[i*j]=0;
        }
    while (scanf("%d",&n)!=EOF)
    {
        for (int i=1;i<=ans;++i)
            b[i]=0;
        ans=0;
        dfs(n,1,1);
        sort(b+1,b+ans+1);
        bo=0;    
        printf("%d\n",ans);
        if (ans==0) continue;
        for (int i=1;i<ans;++i)
            if ((i==1||b[i]!=b[i-1])&&b[i]!=0) bo=1,printf("%d ",b[i]);
        if ((ans==1||b[ans]!=b[ans-1])&&b[ans]!=0) bo=1,printf("%d",b[ans]);
        if (bo) putchar('\n');
    }
    return 0;
}
```
代码长度3.03k,时间76ms,内存3096KB

谢谢观赏


---

## 作者：Aliemo (赞：4)

# 先讲一些东西
#### 1.算数基本定理：任何一个大于1的自然数N，都可以唯一分解成有限个质数的乘积N=P₁^a₁ P₂^a₂…Pn^an，这里P₁<P₂<…<Pn均为质数，其诸指数ai是正整数。
#### 2.约数和定理：对于任意一个大于1的正整数N可以分解正整数：N=P₁^a₁ P₂^a₂…Pn^an，则由约数个数定理可知N的正约数有(a₁+1)(a₂+1)(a₃+1)…(an+1)个，那么N的(a₁+1)(a₂+1)(a₃+1)…(an+1)个正约数的和为f(N)=(P₁^0+P₁^1+P₁^2+…P₁^a₁)(P₂^0+P₂^1+P₂^2+…P₂^a₂)…
    
## 就是数轮题  
  
## 代码↓
```cpp
#include <cstdio>           //头文件不解释
#include <iostream>
#include <string>
#include <cstring>
#include <cmath>
#include <algorithm>
#ifndef rr
#define rr register
#endif
#define ll long long
using namespace std;
const ll N=1e10;                //找s以内的素数
ll b[500005],top,ans,a[500005];
bool f[500005];
ll x;
inline int xxs(){                     //找s以内的素数
	f[1]=1;
    for(rr ll i=2; i<=sqrt(N);++i) {
        if(!f[i])
            b[++top]=i;
        for(rr ll j=1;j<=top;++j) {
        	if(b[j]*i>sqrt(N))
        		break;
            f[i*b[j]]=1;
            if(i%b[j]==0)
                break;
        }
    }
}
inline bool ss(ll x) {              //判断素数
    for(rr ll i=2;i<=sqrt(x);++i)
        if(x%i==0)
            return 0;
    return 1;
}
inline void dfs(ll i,ll n,ll shu) {       //搜索约数和
    if(n==1) {
        a[++ans]=shu;
        return;
    }
    if(i>top||b[i]>=x-1)
        return;
    if(n-1>=b[i]&&ss(n - 1))
        a[++ans]=(n-1)*shu;
    for(rr int j=i;b[j]*b[j]<=n;++j) {
        ll tot=b[j]+1,tmp=b[j];
        for(;tot<=n;tmp*=b[j],tot+=tmp)
            if(n%tot==0)
                dfs(j+1,n/tot,shu*tmp);
    }
}
signed main() {
	xxs();                    //找素数
    while(scanf("%lld",&x)==1) {   //输入
        if(x==1) {
            printf("1\n1\n");    //1的情况单独判断
            continue;
        }
        ans=0;
        dfs(1,x,1);           //深搜解
        printf("%lld\n",ans);
        sort(1+a,a+ans+1);
        for(rr ll i=1;i<=ans;++i) 
        	printf("%lld ",a[i]);
        if(ans!=0)              //注意格式
            putchar('\n');
    }
}
```

---

## 作者：JackcreaM (赞：4)

 # 题解好少啊QAQ
 
 ## 安利一下
 ~~别人的~~题解
 
 
 ### [moyiii大佬的题解 https://www.cnblogs.com/moyiii-/p/7182894.html](https://www.cnblogs.com/moyiii-/p/7182894.html)
 
 
 
 
 
 一道显而易见的数学题，显而易见地我不会做。因为根本这个正解要用到的约数定理、约数和定理。唯一分解定理我都没学过，如果知道这些结论的话有没有推出答案的数学能力也未必。
 
   唯一分解定理：
   任何一个大于1的自然数N，都可以唯一分解成有限个质数的乘积N=P1^a1*P2^a2*…*Pn^an，这里P1<P2<…<Pn均为质数，其诸指数ai是正整数。这样的分解称为N的标准分解式。
    
   约数和定理：
   对于任意一个大于1的正整数N可以分解正整数：N=P1^a1*P2^a2…Pn^an，则由约数个数定理可知N的正约数有(a1+1)(a2+1)(a3+1)…(an+1)个，那么N的(a1+1)(a2+1)(a3+1)…(an+1)个正约数的和为f(N)=(P1^0+P1^1+P1^2+…P1^a1)(P2^0+P2^1+P2^2+…P2^a2)…(Pn^0+Pn^1+Pn^2+…Pn^an)。
    
   用搜索将n分解为(p1^0+p1^1+…+p1^k1)(p2^0+p2^1+…+p2^k2)……(pn^0+pn^1+…+pn^kn),每一次成功的分解都会产生一个答案p1^k1*p2^k2*……*pn^kn。
    
   搜索是很可行的。ad爷讲到对本题搜索的时间复杂度分析，当搜索的复杂度到了根号下根号n级别后就已经可以忽略了(高阶小量)，所以对这种搜索的时间复杂度只用考虑前几层。考试时常打搜索，有时接近正解，有时T得厉害，如果能学会这些分析应该会对搜索有更准确的估计吧。搜索之前要先处理出需要范围内的素数，还要有一个判断是否素数的函数。在搜索中要传递的是枚举到哪个素数(要求素数递增)、已有的乘积和、余下的需要分解的数。在搜索函数内先枚举素数，再枚举乘方，枚举到可以整除的就向下搜索。搜索停止的条件一是分解到只剩1，二是分解到一个大素数+1(直接在此处停止可以省去许多本来没有必要的枚举)。
    
   数学问题确实千古难题，不管是奥赛还是文化课。到底是哪里难，也说不出个一二三。破釜沉舟，誓死不向数学低头。
   
   
   #### 有没有看晕捏？上代码
   
   ```
   #include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ll long long
using namespace std;
const int sj=100100;
ll s,m,ps,p[10000],res[sj],ge;
bool fp[sj]={1,1};
void xxs()
{
     for(int i=2;i<100000;i++)
     {
       if(!fp[i])
       {
          ps++;
          p[ps]=i;
       }
       for(int j=1;j<=ps&&i*p[j]<sj-5;j++)
       {
          fp[i*p[j]]=1;
          if(!(i%p[j]))
             break;
       }
     }
}
int pss(ll x)
{
    if(x==1) return 0;
    for(int i=1;p[i]*p[i]<=x;i++)
      if(!(x%p[i]))
        return 0;
    return 1;
}
void dfs(int l,ll ji,ll yu)
{
     if(yu==1)
     {
        ge++;
        res[ge]=ji;
        return;
     }
     long long temp,f;
     if((yu-1)>p[l]&&pss(yu-1))
     {
         ge++;
         res[ge]=(yu-1)*ji;
     }
     for(int i=l+1;p[i]*p[i]<=yu;i++)
     {
        temp=1;
        f=1;
        for(int j=1;temp<=yu;j++)
        {
           f*=p[i];
           temp+=f;
           if((yu%temp)==0)
             dfs(i,ji*f,yu/temp);
        }
     }
}
void cz()
{
    while(scanf("%lld",&s)==1)
    {
       memset(res,0,sizeof(res));
       ge=0;
       dfs(0,1,s);
       if(ge!=0)
       {
         sort(res+1,res+ge+1,less<int>());
         printf("%lld\n",ge);
         for(int i=1;i<ge;i++)
           printf("%lld ",res[i]);
         printf("%lld\n",res[ge]);
       }
       else
         printf("0\n");
    }
}
int main()
{
    xxs();
    cz();
    return 0;
}
```


南风知我意，吹梦到西洲。

---

## 作者：Rainsleep (赞：3)

## 简要题意

不妨设一个数 $x$ 的约数之和为 $sum(x)$，求所有满足 $sum(x)=S$ 的数字。

## $\text{Solution}$

**前置芝士：线性筛，搜索**

先介绍两条引理，分析时会用到。

由唯一分解定理可得，对于任意正整数 $x$，其可以被表示为

$$x=\prod_{i=1}^k(p_i^{a_i})$$

**引理 $1$：**

对于任意正整数 $x$，其约数个数为
$$\prod_{i=1}^k (a_i + 1)$$

**引理 $2$：**

对于任意正整数 $x$，其约数之和为
$$sum(x)=\prod_{i=1}^k\sum_{j=0}^{a_i} a_i^j$$

考虑暴力做法，枚举 $[1,s]$ 内的数，枚举它们的约数，总时间 $O(n\sqrt{n})$，寄中寄。

考虑搜索解决，由于唯一分解定理，我们不妨通过决定每个质数的次数来获得每个数字以及其约数和。

对于边界条件，显然当约数之和剩余 $1$ 时，当前的数字就是答案之一。

当当前剩余的约数之和是某个形如 $(p_i^0 + p_i^1)$ 的形式时，我们只需要判断约数之和 $-1$（即 $-p_i^0$）是否为质数即可。


代码：
```cpp
#include<bits/stdc++.h>

using namespace std;

#define int long long
const int N = 100010;
int s, cnt = 0, primes[N];
bool state[N];
vector<int>res;

inline void Euler(int n)
{
	memset(state, true, sizeof state);
	state[1] = false;
	for(int i(2);i <= n; ++ i)
	{
		if(state[i])
			primes[++ cnt] = i;
		for(int j(1);j <= cnt and 1ll * primes[j] * i <= n; ++ j)
		{
			state[i * primes[j]] = false;
			if(i % primes[j] == 0)
				break;
		}
	}
	return ;
}

inline bool is_prime(int x)
{
	if(x <= 100009)
		return state[x];
	for(int i(1);primes[i] <= x / primes[i]; ++ i)
		if(x % primes[i] == 0)
			return false;
	return true;
}
	
inline void dfs(int cur, int remain, int ret)
{
	if(remain == 1)
	{
		res.push_back(ret);
		return ;
	}
	if(remain > primes[cur] and is_prime(remain - 1))
		res.push_back(ret * (remain - 1));
	for(int i(cur);primes[i] <= remain / primes[i]; ++ i)
	{
		int sum = primes[i] + 1; // 当前选定质数的要乘上的约数和
		int t = primes[i]; // 当前数字乘上的质数是多少
		for(;sum <= remain;t *= primes[i], sum += t)
			if(remain % sum == 0)
				dfs(i + 1, remain / sum, ret * t);
	}
	return ;
}

signed main()
{
	Euler(N - 1);
	while(~scanf("%lld", &s))
	{
		dfs(1, s, 1);
		sort(res.begin(), res.end());
		if(!res.size())
			puts("0");
		else
		{
			printf("%lld\n", res.size());
			for(int i(0);i < res.size(); ++ i)
				printf("%lld ", res[i]);
			putchar('\n');
			res.clear();
		}
	}
	return 0;
}
```



---

## 作者：徐致远 (赞：2)

[本蒟蒻的Blog](https://www.chnxuzhiyuan.cn/2019/05/19/%E3%80%8CJLOI2014%E3%80%8D%E8%81%AA%E6%98%8E%E7%9A%84%E7%87%95%E5%A7%BF-Solution/)

### 题解

对于一个数$X$对它分解质因数：

$X=p_1^{c_1}p_2^{c_2}\cdots p_k^{c_k}$

则有：

$\sum_{d|X}d=\prod_{i=1}^{k}{\sum_{j=0}^{c_k}{p_i^j}}$

所以可先把所有小于$\sqrt{S}$质数筛出来。

然后暴力搜索每个因子的个数。

最后那个大于$\sqrt{S}$的质因子，暴力判一下即可。

### 代码

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
typedef long long LL;
int S,p[4700],tot,ans[10000000];bool vis[45000];
inline void make_p()
{
	vis[0]=vis[1]=true;
	for(int i=2;i<=45000;i++)
	{
		if(!vis[i]) p[++p[0]]=i;
		for(int j=1;j<=p[0]&&p[j]*i<=45000;j++)
		{
			vis[i*p[j]]=true;
			if(i%p[j]==0) break;
		}
	}
}
inline bool IsPrime(int x)
{
	for(int i=2;i*i<=x;i+=(i&1)+1)
		if(x%i==0)
			return false;
	return true;
}
void DFS(int pn,int SN,int Num)
{
	if(SN==1)
	{
		ans[++tot]=Num;
		return;
	}
	if(SN>p[pn]&&IsPrime(SN-1)) ans[++tot]=Num*(SN-1);   //特判
	for(int i=pn;p[i]*p[i]<=SN;i++)        //枚举因子
	{
		LL t=p[i],sum=p[i]+1;
		for(;sum<=SN;t*=p[i],sum+=t)       //枚举因子个数
			if(SN%sum==0) 
				DFS(i+1,SN/sum,Num*t);
	}
}
int main()
{
	make_p();
	while(scanf("%d",&S)==1)
	{
		tot=0;DFS(1,S,1);
		printf("%d\n",tot);
		sort(ans+1,ans+1+tot);
		for(int i=1;i<=tot;i++)
			printf("%d%c",ans[i],i==tot?'\n':' ');
	}
	return 0;
}
```



---

## 作者：dutianchen1 (赞：1)

# 聪明的燕姿

### 思路简析

#### 一个比较重要的结论或者前置知识：

- $\forall X$，根据**唯一分解定理**，我们可以得到：$X=p_{1}^{a_{1}}p_{2}^{a_{2}}p_{3}^{a_{3}} \dots p_{n}^{a_{n}}$。那么我们就可以得到 $X$ 的**因数和**等于：$ \prod_{i=1}^{n} \sum_{j=0}^{a_{i}} p_{i}^{j} $。

简要证明一下：

我们可以把 $X$ 分解为两个因数相乘，于是考虑枚举第一个因数。

显然，这第一个因数可以分别从 $n$ 个 $p_{i}$ 中取出 $a_{j}$ 个质因子作为这个因数的质因数。也就是说第一个因数可以表示为 $p_{1}^{a_{i}}p_{2}^{a_{j}}p_{3}^{a_{k}} \dots p_{n}^{a_{l}}$，剩下的质因子就组成了第二个因数。

我们要求所有因数的和，又因为因数是对称的，我们只需将所有可能的第一个因数求和即可。

#### 接下来讲如何解决本题。

由于我们想要知道有哪些数的因数之和等于给定的 $s$。我们反向思考，考虑 $s$ 可以表示为多少数的因数之和。

于是我们枚举每一个质数的不同次幂，用搜索来考虑所有 $s$ 分解的方案。还有两个显然的搜索递归边界：（设 $x$ 为当前枚举到的因数和）

1. 当 $x-1$ 为质数时，由于因数和会加上 $1+(x-1)$，那么从此之前枚举的因数自然就成立了。
2. 当 $x=1$ 时，直接把枚举的因数加入即可。

 再优化一下过程，我们可以把循环求 $\sum_{i=0}^{k} p_{k}^{a_{i}}$ 化简为 $\frac{p_{k}^{a_{k}+1}-1}{p_{k}-1}$，套用快速幂即可。

在判断素数时，虽然我们一开始可以用线性筛记录 $\le 10^7$ 左右的素数，但是 $s\le2\times10^9$，我们仍然需要判定这个数是否为素数。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e6 + 5;
const ll inf = 1e18+7;
inline ll read(){
	ll x=0,f=1;
	char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch)){x=(x<<3)+(x<<1)+ch-48;ch=getchar();}
	return x*f;
}
ll prime[N],cnt;
bool vis[N];
ll s;
ll ans[N],tot;
void init(){
	vis[1]=true;
	for(int i=2;i<N;i++){
		if(!vis[i]){prime[++cnt]=i;}
		for(int j=1;prime[j]*i<N&&j<=cnt;j++){
			vis[prime[j]*i]=true;
			if(i%prime[j]==0)break;
		} 
	}
}
inline ll qpow(ll x,ll b){
	ll res=1;
	while(b){
		if(b&1) res=res*x;
		x=x*x;
		b>>=1;
	}
	return res;
}
bool check(ll x){
	if(x<N){
		return (!vis[x]);
	}
	else{
		for(int i=1;i<=cnt&&prime[i]<=x;i++){
			if(x%prime[i]==0){
				return false;
			}
		}
	}
	return true;
}
void dfs(ll s,ll pos,ll now){//现在状态下我们要求的因数和  取第几个质数 当前枚举的第一个因数 
	
    if(s==1){
        ans[++tot]=now;
        return;
    }
	if(check(s-1)&&s>prime[pos]){
		ans[++tot]=now*(s-1);
	}
    for(int i=pos;prime[i]*prime[i]<=s;i++){//枚举下一个搜索的质数 
        ll x=1,sum=0;
        while(sum<=s){
        	sum=(qpow(prime[i],x+1)-1)/(prime[i]-1);
        	x++;
        	if(s%sum==0){
        		dfs(s/sum,i+1,now*qpow(prime[i],x-1));
			}
		}
    }
}
int main(){
	init();
	while(~scanf("%lld",&s)){
		tot=0;
		dfs(s,1,1);
		sort(ans+1,ans+1+tot);
		cout<<tot<<'\n';
		for(int i=1;i<=tot;i++)cout<<ans[i]<<' ';
		if(tot)cout<<'\n'; 
	}
	return 0;
}
```

---

## 作者：wsm52 (赞：1)

# 前言
搜索题。
### 【1】暴力（应该没人不会吧）$30$ 分

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e7+10;
int s,a[N];
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	while(~scanf("%d",&s)){
		int m=0;
		for(int i=1;i<=s;i++){
			int sum=0;
			for(int j=1;j<=sqrt(i);j++){
				if(i%j==0) sum+=j;
				if(i/j==j) continue;
				if(i%(i/j)==0) sum+=i/j;
			}
			if(sum==s) a[++m]=i;
		}
		printf("%d\n",m);
		if(!m) continue;
		for(int i=1;i<=m;i++) printf("%d ",a[i]);
		printf("\n");
	}
	return 0;
}
```
暴力的时间复杂度为 $O(kS\sqrt{S})$，这不得爆炸！
### 【2】唯一分解定理、约数和定理和欧拉筛优化，$30$ 分
唯一分解定理：$\prod_{i=1}^{k} {p_i}^{a_i}$。

约数和定理：$\prod_{i=1}^{k} \sum_{j=0}^{a_i}{p_i}^j$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+10;
int s,a[N];
int primes[N],idx;
bool vis[N];
void init(){ //欧拉筛
	for(int i=2;i<N;i++){
		if(!vis[i]) primes[++idx]=i;
		for(int j=1;primes[j]*i<N;j++){
			vis[i*primes[j]]=true;
			if(i%primes[j]==0) break;
		}
	}
}
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	init();
	while(~scanf("%d",&s)){
		int m=0;
		for(int i=1;i<=s;i++){
			int sum=1,k=i;
			for(int j=1;primes[j]<=k&&j<=idx;j++){//唯一分解定理
				int x=1,num=0;
				if(k%primes[j]==0) num=1;
				while(k%primes[j]==0){
					x*=primes[j];
					num+=x;
					k/=primes[j];
				}
				if(num) sum*=num;//约数和定理
			}
			if(sum==s) a[++m]=i;
		}
		printf("%d\n",m);
		if(!m) continue;
		for(int i=1;i<=m;i++) printf("%d ",a[i]);
		printf("\n");
	}
	return 0;
}
```
做到这里我打开了标签，看到里面有**深度优先搜索（DFS）**，我人已经懵了，我还以为这道题是数学题（确实有数学的成分）。
### 【3】深度优先搜索（DFS）
这道题我们可以用质因子组装一个数出来。我们知道 $S$ 的因数和为 $\prod_{i=1}^{k} \sum_{j=0}^{a_j}{p_i}^j$，我们其实可以枚举质数以及它的个数使其的约数和等于 $S$  从而组成一个新的数。

【剪枝1】：如果 $num > primes_x$ 且$num-1$ 为质数（因为 $(num-1)^0+(num-1)^1=num$，$num-1$为最后一个质数），直接记录 $(num-1) \times sum$ 就行了。

【剪枝2】：没必要从第 $x$ 个质数一直枚举到第 $idx$ 个质数（这样会算得很大且没意义），满足 ${primes_i}^2 \le num$ 就行了。
# AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+10;
int s,a[N],pos;
int primes[N],idx;
bool vis[N];
void init(){//欧拉筛 
	for(int i=2;i<N;i++){
		if(!vis[i]) primes[++idx]=i;
		for(int j=1;primes[j]*i<N;j++){
			vis[i*primes[j]]=true;
			if(i%primes[j]==0) break;
		}
	}
}
bool check(int x){//判断是否为质数 
	if(x<N) return vis[x];
	int k=sqrt(x);
	for(int i=2;i<=k;i++) if(x%i==0) return true;
	return false;
}
void dfs(int x,int num,int sum){//从第x个质数开始，剩余约数和，已经组成的数 
	if(num==1){
		a[++pos]=sum;
		return;
	}
	if(num>primes[x]&&!check(num-1)) a[++pos]=sum*(num-1);//剪枝 
	for(int i=x;primes[i]*primes[i]<=num;i++){//枚举质数，剪枝 
		int tmp=primes[i];
		for(int j=primes[i]+1;j<=num;j+=tmp){//枚举质数的次数 
			if(num%j==0) dfs(i+1,num/j,sum*tmp);
			tmp*=primes[i];
		}
	}
}
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	init();
	while(~scanf("%d",&s)){
		pos=0;
		dfs(1,s,1);
		sort(a+1,a+pos+1);//从大到小输出，排序 
		printf("%d\n",pos);
		if(!pos) continue;
		for(int i=1;i<=pos;i++) printf("%d ",a[i]);
		printf("\n");
	}
	return 0;
}
```
# 结尾
推荐一道搜索题[年会小游戏](https://www.luogu.com.cn/problem/T494538)。

---

## 作者：Ryan_ (赞：1)

约数和定理：

若n的标准分解式为 p1^k1 * p2^k2 ……

那么n的约数和= π （Σ pi^xi ） xi∈[0,ki]

原本枚举小于S的质数，通过先判断S-1是不是质数 就可以 枚举根号S内的质数


```
#include<cstdio>
#include<algorithm>

using namespace std;

#define N 1000000

int prime[N+1],cnt;
bool vis[N+1];

int ans[N],tot;

void pre()
{
    vis[1]=true;
    for(int i=2;i<=N;++i)
    {
        if(!vis[i]) prime[++cnt]=i;
        for(int j=1;j<=cnt;++j)
        {
            if(i*prime[j]>N) break;
            vis[i*prime[j]]=true;
            if(!(i%prime[j])) break;
        }
    }
}

bool isprime(int x)
{
    if(x<=N) return !vis[x];
    for(int i=1;prime[i]*prime[i]<=x;++i)
        if(!(x%prime[i])) return false;
    return true;
}

void dfs(int last,int num,int rest)
{
    if(rest==1) { ans[++tot]=num; return; }
    if(rest-1>prime[last] && isprime(rest-1)) ans[++tot]=num*(rest-1);
    for(int i=last+1;prime[i]*prime[i]<=rest;++i)
        for(int sum=prime[i]+1,nnum=prime[i];sum<=rest;nnum*=prime[i],sum+=nnum)
            if(!(rest%sum)) dfs(i,num*nnum,rest/sum);
}

int main()
{
    pre();
    int n;
    while(scanf("%d",&n)!=EOF)
    {
        tot=0;
        dfs(0,1,n);
        sort(ans+1,ans+tot+1);
        printf("%d\n",tot);
        for(int i=1;i<=tot;++i) printf("%d ",ans[i]);
        if(tot) printf("\n");
    }
}
```


---

## 作者：ELECTRODE_kaf (赞：0)

### 题意

给定 $S$，求所有正约数之和等于 $S$ 的正整数

### 前置知识

唯一分解：$n=p_1^{q_1}\times p_2^{q_2}\times\cdots\times p_k^{q_k}$

因数和公式：记 $f(n)$ 为 $n$ 所有正因子的和，则有：

$f(n)=(1+p_1+{p_1}^2+\cdots+{p_1}^{q_1})(1+p_2+{p_2}^2+\cdots+{p_2}^{q_2})\cdots(1+p_k+{p_k}^2+\cdots+{p_k}^{q_k})$

可以通过乘法原理证明。

### 算法

核心为 dfs。

枚举 ${p_k}$ 和 ${q_k}$，若满足

$S=(1+p_1+{p_1}^2+\cdots+{p_1}^{q_1})(1+p_2+{p_2}^2+\cdots+{p_2}^{q_2})\cdots(1+p_k+{p_k}^2+\cdots+{p_k}^{q_k})$

那么将 $p_1^{q_1}\times p_2^{q_2}\times\cdots\times p_k^{q_k}$ 作为答案存储。

接下来考虑剪枝。

对 ${q_k}$ 的大小进行分类讨论：

1\. 当 ${q_k}=1$：

用 $x$ 表示当前正在拆分的数，如果 $(x-1)$ 为质数，因为质数无法再分为质数的乘积，所以当且仅当新的 ${p_k}=x-1,{q_k}=1$ 时可以得到一组新的解。

2\. 当 ${q_k}>1$：

只需要枚举不大于 $\sqrt x$ 的质数即可，这些质数可以预处理。

### AC code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define rep(i,x,y) for(int i=x;i<=y;i++)
#define fir first
#define sec second
#define ctn continue
#define pb push_back
#define ll long long
#define recal(x) x.resize(x.size()-1)//用来回溯 
int n;
vector<int>ans,prinum;//prinum存储sqrt(s)范围内的质数 
vector<pair<int,int> >ch;//记录已拆分的部分，first为底数p，second为指数q 
bool pri(int x) {
	rep(i,2,sqrt(x)) {
		if(x%i==0)return 0;
	}
	return x>1;//1不是质数 
}
void ini() {
	ans.clear();
}
void dfs(int x,int lst,ll pd) {//x表示当前正在拆分的数，lst表示上一次使用的数在prinum[]数组中的下标，pd表示已确定部分的乘积 
	if(x==1||pri(x-1)&&(lst<0||x-1>prinum[lst])) {
		//x==1表示拆分完毕，特判x-1为质数的情况，但要保证x-1大于上一次选取的数，以免产生重复解 
		if(x>1)ans.pb(pd*(x-1));//注意这只是一种方案，不能返回 
		else {
			ans.pb(pd);
			return;
		}
	}
	for(int i=lst+1; prinum[i]<=sqrt(x); i++) {//i枚举用来拆分的质数，从prinum中选取 
		ll sum=1,pow1=prinum[i];//sum记录(p^0+p^1+...+p^j)的值 
		for(int j=1;; j++) {//枚举次数 
			sum+=pow1;
			pow1*=prinum[i];
			if(sum>x)break;//超出退出 
			if(x%sum)ctn;//保证整除 
			ch.pb({prinum[i],j});//记录答案 
			dfs(x/sum,i,pd*pow1/prinum[i]);//pow1多乘了一次，退回去 
			recal(ch);
		}
	}
}
const int MAX=45000;//sqrt(2e9)<45000 
bool ispri[MAX+1];
void getpri() {//筛法求质数 
	rep(i,2,MAX) {
		if(ispri[i]==0) {
			for(int j=2; i*j<=MAX; j++)ispri[i*j]=1;
			prinum.pb(i);//顺便记录 
		}
	}
}
int main() {
	getpri();
	while(cin>>n) {
		ini();
		dfs(n,-1,1);//注意lst初值为-1 
		cout<<ans.size()<<'\n';
		if(ans.size()==0)ctn;//避免无解时输出多余换行 
		sort(ans.begin(),ans.end());//题目要求升序输出 
		for(int i:ans)cout<<i<<' ';
		cout<<'\n';
	}
}
```

---


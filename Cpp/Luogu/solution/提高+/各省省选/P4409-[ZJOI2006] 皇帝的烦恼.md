# [ZJOI2006] 皇帝的烦恼

## 题目描述

经过多年的杀戮，秦皇终于统一了中国。为了抵御外来的侵略，他准备在国土边境安置 $n$ 名将军。不幸的是这 $n$ 名将军羽翼渐丰，开始展露他们的狼子野心了。他们拒绝述职、拒绝接受皇帝的圣旨。

秦皇已经准备好了秘密处决这些无礼的边防大将。

不过为防兵变，他决定先授予这些将军一些勋章，为自己赢得战略时间。将军们听说他们即将被授予勋章都很开心，他们纷纷上书表示感谢。第 $i$ 个将军要求得到 $a_i$ 枚不同颜色的勋章。但是这些将军都很傲气，如果两个相邻的将军拥有颜色相同的勋章他们就会认为皇帝不尊重他们，会立即造反（编号为 $i$ 的将军和编号为 $i+1$ 的将军相邻；因为他们驻扎的边境可以类似看成一个圆形，所以编号 $1$ 和编号 $n$ 的将军也相邻）。

皇帝不得不满足每个将军的要求，但对他们的飞扬跋扈感到很气愤。于是皇帝决定铸造尽量少种类的勋章来满足这些狂妄者的要求。请问他至少要铸造多少种颜色的勋章？

## 说明/提示

$1 \leq n \leq 2 \times 10^4$，$1 \leq a_i  \leq 10^5$。

## 样例 #1

### 输入

```
4
2
2
1
1```

### 输出

```
4```

# 题解

## 作者：蒟蒻初音ミク (赞：49)

# 广告

[蒟蒻的blog](http://www.luogu.com.cn/blog/111990/#)

# 正文

题意：给定$n$个集合的大小，问在相邻集合没有交集的情况下，并集的最小大小

题解：**集合思想**（外带图形解释，~~生动而形象~~）

如果是一条链，那么直接贪心，找出最大的相邻数的和就是答案。但是这个是一个环，即**要避免与1集合的冲突**。那么考虑二分+$dp$

设二分出来的并集大小为$x$。

## 维护一个$minn[i]$：表示在不与集合i-1冲突的情况下，集合i与集合1的最小冲突数量。

![](https://cdn.luogu.com.cn/upload/pic/74568.png)

~~大概就是这个样子。。。~~

首先可以发现，不属于$i-1$集合也不属于$1$集合的元素是**能选多少选多少的**。由于求的是$minn[i]$，所以我们要使得$\{ i-1 \}∪ \{ 1 \}$的元素个数最小（因为这样的话能够不冲突的元素最多）而根据容斥原理（？？？），$\{ i-1 \}∪ \{ 1 \} = \{i-1 \}+ \{ 1 \}- \{ i-1 \}∩ \{1 \}$，即**需要$ \{ i-1 \}$与$\{ 1 \}$冲突数量最大**

## 所以还需要一个$maxx[i]$：表示在不与集合$i-1$冲突的情况下，集合$i$与集合$1$的最大冲突数量

然后状态转移方程就特别好写了：

```cpp
        maxx[i]=min(a[i],a[1]-minn[i-1]);
        minn[i]=max(0,a[i]-(x-(a[i-1]+a[1]-maxx[i-1])));
```

这里解释一下：

对于$minn[i]$，我们已经解释过了，但是对于$maxx[i]$，我们来看一下图：

![](https://cdn.luogu.com.cn/upload/pic/74572.png)

那么可以发现，$maxx[i]$其实就是把集合1剩下的部分全部占完（当然，可能占不完，因为最多占$a[i]$个），所以状态转移方程就是上面那个了。

最后贴一下代码，如果还有不懂的地方可以私信我哦~~~：

# code:

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int n,a[100005],l,r,maxx[100005],minn[100005];
bool check(int x)
{
    for(int i=2;i<=n;i++)
    {
        maxx[i]=min(a[i],a[1]-minn[i-1]);
        minn[i]=max(0,a[1]+a[i-1]-maxx[i-1]+a[i]-x);
    }
    if(!minn[n]) return true;
    else return false;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
        l=max(l,a[i]+a[i-1]);
    }
    maxx[1]=minn[1]=a[1];
    r=300000;
    while(l<=r)
    {
        int mid=(l+r)>>1;
        if(check(mid)) r=mid-1;
        else l=mid+1;
    }
    printf("%d",l);
    return 0;
}
```

---

## 作者：d3NtMDAw (赞：34)

更新说明：根据评论区提醒，修改了代码，并增添了针对评论的一些说明。


------------

看到这题，就容易想到一种瞎搞的办法，那就是把相邻两个数起来，求个$max$.时间复杂度$o(n)$.   
很容易找到反例$n=3$时，$a[i]$分别为$5,5,5$；按瞎搞做法是10，实际上应该是$15$.   
下面是~~严格的~~求证过程：   
先延续我们一开始的想法，可以随机取$x,y$为相邻两个数(设为$a[i],a[i+1],i+1≤n$)，然后若$a[i]<a[(i+2)%n]$,则将$x$调整为$a[(i+2)%n]$，依次调整后，总可以取到$x,y$使得$x+y$是相邻两个数中和最大的。看起来而任意的另外的将军则只需要与模二同余的$x$或$y$中取$a[i]$个勋章，即可保证题设条件。    
但是问题在于如反例中3号将军理论上应该从1号将军的$a[1]$个勋章中选，但是3号将军和1号将军相邻，于是出了锅。   
换个角度，每个勋章最多给$n/2$个将军，所以实际还需要确保勋章数大于上$=\sum_{i=1}^n(a[i])/(n/2)$的勋章，才足以满足题设条件，当然不可能有1.5个勋章，所以需要向上取整。   
另外,切记n=1，是要直接输出的。    
最后我们需要将两种情况的答案进行比较取最大值。取最大值的原因是因为这里并非是严格意义上的两种情况，而是一种类似于算两遍取最值的方法
时间复杂度还是o(n)。   
code如下：
```cpp
#include<stdio.h>
#include<math.h>
int ans;
int a[20001],m,n,i,j;
int main()
{
    scanf("%d",&n);
    for(i=1;i<=n;++i)
     scanf("%d",&a[i]);
    if(n==1) return printf("%d\n",n)&0;
    ans=a[1]+a[n]; 
    for(i=1;i<n;++i)
     if(a[i]+a[i+1]>ans)
       ans=a[i]+a[i+1];
    for(i=1;i<=n;++i) 
     m+=a[i];

    double mm=m,nn=n,tem;
    tem=ceil(mm/((int)(nn/2)));
    if ((int)tem>ans) ans=(int)tem;
    printf("%d",ans);
    return 0;
}

```

---

## 作者：木木！ (赞：26)

upd: 重写了，将代码换成正确的版本（之前手抽复制错了），并且让证明更加清晰（清晰了十七八倍）

我是来给那位 $\Theta(n)$ 的大佬补个证明的。

另设答案为 $A$，以下将证明答案为：

$$A=\max(a_i+a_{i-1},\lceil\frac{\sum a_i}{\lfloor\frac{n}{2}\rfloor}\rceil)$$

这里认为 $a_0=a_n$。

充分性很好证明，$A\geq \max(a_i+a_{i-1})$ 显然，由于一个勋章最多分给 $\lfloor\frac{n}{2}\rfloor$ 位将领，于是 $A\geq\lceil\frac{\sum a_i}{\lfloor\frac{n}{2}\rfloor}\rceil$。

接下来证明必要性。

首先，对于 $2|n$（$n$ 为偶数）的情况 $A=\max(a_i+a_{i-1})$。利用归纳法可以简单证得。或者使用直觉式的证明方法，如果将可用的勋章想象成一个 $[1,A]$ 的连续段，每个可用勋章用一个整数代表，那么偶数项从 $A$ 开始往下取，而奇数项从 $1$ 开始往上取，那么答案必定是最能顶的一对。

对于其他情况，假设 $A>\max(a_i+a_{i+1})$。由于 $n$ 是奇数，如果 $a_1$ 从 $1$ 开始往上取得，方针则是偶数尽量往下取，奇数尽量往上取。

令奇数位的“余量”为它的最低一项距离 $1$ 的距离（即如果用一个整数代表一个勋章，那么就是最小的整数减一），第 $i$ 位的余量为 $r_i$。那么，可以轻易证得答案合法的充要条件是 $r_n\geq a_1$。自然 $n=1$ 要特判。

为论述方便，令 $2k-1$ 位的余量是 $r$，$2k+1$ 位的余量是 $r'$，思路就是推出 $r'$ 和 $r$ 的关系。

如果 $r\geq a_{2k}$，则将所有 $a_{2k}$ 安排到余量中，$a_{2k+1}$ 则可以全部安排到上面，$r'=A-a_{2k+1}$。注意到 $A>a_{2k}+a_{2k+1}$，因此这么做不会导致重叠。

否则，将 $r$ 个勋章安排到下面，$a_{2k}-r$ 个勋章安排在最上方。$a_{2k+1}$ 就在 $a_{2k}-r$ 个勋章之下再继续取，最终 $r'=r+A-a_{2k}-a_{2k+1}$。同样注意到 $A>a_{2k}+a_{2k+1}$，因此这么做是合法的。

两种情况可以综合成一个统一的式子。我们可以注意到 $r'\leq r+A-a_{2k}-a_{2k+1}$。

柿子在第 $n$ 位的时候也适用，并且根据定义，有 $r_1=0$。因此可以得到这么一个式子：

$$r_n\leq\sum_{k=1}^{\lfloor\frac{n}{2}\rfloor} A-a_{2k}-a_{2k_1}$$

答案成立的条件即为：

$$\sum_{k=1}^{\lfloor\frac{n}{2}\rfloor} A-a_{2k}-a_{2k_1}\geq r_n\geq a_1$$

即：

$$\sum_{k=1}^{\lfloor\frac{n}{2}\rfloor} A-a_{2k}-a_{2k_1}\geq a_1$$

将 $A$ 提出来，并且简化剩下项的下标，可以得到：

$$\lfloor\frac{n}{2}\rfloor A-\sum_{k=2}^{n} a_k\geq a_1$$

再移项，将 $\lfloor\frac{n}{2}\rfloor$ 移过去，就可以得到激动人心的式子：

$$A\geq \frac{\sum a_i}{\lfloor\frac{n}{2}\rfloor}$$

满足这个条件并同时 $\geq\max(a_i+a_{i+1})$ 的 $A$ 就可以作为答案。

因此 $A=\max(a_i+a_{i-1},\lceil\frac{\sum a_i}{\lfloor\frac{n}{2}\rfloor}\rceil)$

附 AC 代码：

```cpp
#include <cstdio>
using namespace std;

void chkmax(int& a,int b)
{
	if(a<b)
	{
		a = b;
	}
}

int ai[20005];

int main()
{
	int n,sum=0;
	scanf("%d",&n);
	for(int i=1; i<=n; ++i)
	{
		scanf("%d",ai+i);
		sum += ai[i];
	}
	
	int ans = 0;
	for(int i=1; i<n; ++i)
	{
		chkmax(ans,ai[i]+ai[i+1]);
	}
	chkmax(ans, ai[1]+ai[n]);
	chkmax(ans, (sum+(n>>1)-1)/(n>>1));
	
	printf("%d",ans);
}
```

---

## 作者：C3H5ClO (赞：16)

# 答案公式的严谨证明

>本文并非原创,是总结了@木木! 和@Little_Ming 的想法而得出的.

**设答案为A,则柿子是$A=max\{a_1+a_2,a_2+a_3,...,a_n+a_1,\lceil\frac{\sum a_i}{\lfloor\frac n2\rfloor}\rceil\}$**

为什么呢?先证明必要性.

由于相邻两个将军勋章不能相同,因此A不小于任意两个将军勋章之和.由于每种勋章最多被分给$\lfloor \frac n2\rfloor$个将军,因此A不小于总勋章数除以$\lfloor \frac n2\rfloor$.

再证充分性.分奇偶两类讨论.

n为偶数时,显然有A不小于任意两个将军勋章之和是有合法方案的充分条件.不妨设$a_i+a_{i+1}$($a_n+a_1$同理)是最大的相邻将军之和,则有
$\frac n2(a_i+a_{i+1})\ge\sum a_i$,那么$A\ge a_i+a_{i+1}\ge\lceil\frac{\sum a_i}{\lfloor\frac n2\rfloor}\rceil$

n为奇数时,设奇数位的余量$r_{2k-1}$为第2k-1的将军所选勋章集合的补集与第1个将军所选勋章集合的交集大小.(这也是@木木 的题解出问题的地方,由于定义出错,他的证明看起来十分不严谨并且可能是伪证)

显然有结果满足条件等价于$r_n=a_1$

 _**情况一**_ ,当$a_{2k}\le r_{2k-1}$时,第2k的将军所选勋章集合为第一个将军所选集合的子集,由$A\ge a_{2k}+a_{2k+1}$可知$r_{2k+1}=min(A-a_{2k+1},a_1)$,此后$a_{2k+1}+a_{2k+2}\le A,a_{2k+2}\le A-a_{2k+1}\le r_{2k+1}$继续满足条件,归纳可知$r_n=min(A-a_n,a_1)=a_1$

 _**情况二**_ ,当$a_{2k}>r_{2k-1}$时,第2k的将军所选集合有$a_{2k}-r_{2k-1}$个不属于第一个将军所选集合,那么$r_{2k+1}=min(r_{2k-1}+A-a_{2k}-a_{2k+1},a_1)$,由情况一后面的归纳可知,$r_{2k+1}$属于情况二,则$r_{2k-1}$不可能属于情况一,那么
$$r_{2k+1}=min(min(r_{2k-3}+A-a_{2k-2}-a_{2k-1},a_1)+A-a_{2k}-a_{2k+1},a_1)$$
$$=min(r_{2k-3}+2A-a_{2k-2}-a_{2k-1}-a_{2k}-a_{2k+1},a_1+A-a_{2k}-a_{2k+1},a_1)$$
由于$A-a_{2k}-a_{2k+1}\ge 0$,
$$r_{2k+1}=min(r_{2k-3}+2A-a_{2k-2}-a_{2k-1}-a_{2k}-a_{2k+1},a_1)$$
归纳可知,当$r_n$由情况二产生时
$$r_n=min(r_1+\sum_{k=1}^{\lfloor \frac n2\rfloor}A-a_{2k}-a_{2k+1},a_1)$$
此时要使方案合法,则$r_n=a_1$
$$r_n=a_1\Leftrightarrow a_1=min(\sum_{k=1}^{\lfloor \frac n2\rfloor}A-a_{2k}-a_{2k+1},a_1)$$
$$r_n=a_1\Leftrightarrow a_1\le\sum_{k=1}^{\lfloor \frac n2\rfloor}A-a_{2k}-a_{2k+1}$$
$$r_n=a_1\Leftrightarrow \sum a_i\le\sum_{k=1}^{\lfloor \frac n2\rfloor}A$$
由于A是整数,
$$r_n=a_1\Leftrightarrow A\ge\lceil\frac{\sum a_i}{\lfloor\frac n2\rfloor}\rceil$$
(在@木木! 的题解中用的是不等式相加,并不能取等价于,因此他证明的"充分性"实际上也是必要性,是个伪证.)

至此,证明了$A\ge max\{a_1+a_2,a_2+a_3,...,a_n+a_1,\lceil\frac{\sum a_i}{\lfloor\frac n2\rfloor}\rceil\}$是方案合法的充要条件.由于答案最小,那么直接取到最小值即可.

---

## 作者：b2019dy (赞：12)

直接贪心我们很容易找到反例，考虑递推。  
我们设$ma_i$表示第i个数与第一个数最多可以相同多少个，$mi_i$表示第i个数与第一个数至少相同多少个  
我们可以很简单的看出$ma[i]=min(a[i],a[1]-mi[i-1])$，因为显然这一位将军与第一位将军最多同时拥有$a_i$枚勋章，而也不会超过第一位将军获得勋章数减去第i-1位将军最少与第一位将军相同的数额。  
接下来我们考虑$mi_i$的递推公式，显然，它不会小于0，然后我们考虑第i-1位将军所获勋章与第一位将军的不重合部分，很显然，这个值等于$a[i-1]-ma[i-1]$，因为第i位将军也不能与其重合，且要尽量与第1位将军不重合，则可得公式$a[1]+a[i-1]-ma[i-1]+a[i]-x$ ，而x是最大的奖章数，显然，其存在单调性，则我们二分x求解即可。  
注意：二分的下界不为0
```cpp
#include<iostream>
#include<iomanip>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;
int n,a[100005],l,r,ma[100005],mi[100005];
bool check(int x)
{
    for(int i=2;i<=n;i++)
    {
        ma[i]=min(a[i],a[1]-mi[i-1]);
        mi[i]=max(0,a[1]+a[i-1]-ma[i-1]+a[i]-x);
    }
    if(!mi[n]) return true;
    else return false;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
        l=max(l,a[i]+a[i-1]);
    }
    ma[1]=mi[1]=a[1];
    r=300000;
    while(l<=r)
    {
        int mid=(l+r)>>1;
        if(check(mid)) r=mid-1;
        else l=mid+1;
    }
    printf("%d",l);
}
```
 

---

## 作者：艾恩葛朗特 (赞：6)

## 有点恶意评分
~~不过不看题解能一遍过的真的很少

看到这题第一个想法——
### 暴力
打完暴力之后——
##### 52分
网上正解是dp+二分，有兴趣可以了解一下，蒟蒻在这里讲一下在暴力基础上~~奇特的解法~~

第一步：基础暴力

寻找两两之间的最大值，即目前“最少”需要的勋章个数
```cpp
	scanf("%d",&n);
	if (n==1){
		scanf("%d",&x);
		printf("%d",x);
		return 0;
	}
	scanf("%d%d",&a1,&y);
	ans=a1+y;
	s+=ans;
	for (int i=3;i<=n;i++){
		scanf("%d",&x);
		if (x+y>ans) ans=x+y;
		y=x;
		s+=x;
	}
    if (a1+y>ans) ans=a1+y;
```
第二步：特殊情况判断

如果数据为几个一模一样的数字，那么单单上面代码就会被hack，
要判断当前“最小”需要的勋章个数是否小于总勋章个数/人数的一半，即两个将军需要的最大勋章个数*组数是否小于总勋章个数
。如果小于，ans更新为总勋章个数/人数的一半
```
	if ((s+n/2-1)/(n/2)>ans) ans=(s+n/2-1)/(n/2);
```
完整代码
```cpp
#include<cstdio>
int n,x,y,ans,s,a1;
int main()
{
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	scanf("%d",&n);
	if (n==1){
		scanf("%d",&x);
		printf("%d",x);
		return 0;
	}
	scanf("%d%d",&a1,&y);
	ans=a1+y;
	s+=ans;
	for (int i=3;i<=n;i++){
		scanf("%d",&x);
		if (x+y>ans) ans=x+y;
		y=x;
		s+=x;
	}
	if (a1+y>ans) ans=a1+y;
	if ((s+n/2-1)/(n/2)>ans) ans=(s+n/2-1)/(n/2);
	printf("%d",ans);
	return 0;
}
```


---

## 作者：niolle (赞：5)

二分答案，
设x为mid-p[1]，可设DP[i][j]表示第i个守卫有j个奖牌与第1个相同，列出DP方程：

$dp[i][j]=\sum\limits_{k=0}^j dp[i][j]|dp[i][k]$
    
我们发现，如果第i个守卫最少可以有x个、
最多可以有y个奖牌与1号相同，

那么在[x,y]区间内一定都可以满足此时的要求(用k的范围可知)，

所以只需记录该区间的左右端点即可

注意二分答案的左端点应为相邻两个守卫需求的和的最大值

CODE:
```
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#define rep(i,a,b) for(int i=a;i<=b;i++)
using namespace std;
int n,a[100005],x[100005],y[100005],l,r;
bool check(int t){
    x[1]=y[1]=a[1];
    rep(i,2,n){
        x[i]=max(0,a[1]+a[i-1]+a[i]-y[i-1]-t);
        y[i]=min(a[i],a[1]-x[i-1]);
        if(x[i]>y[i]) return 0;
    }
    if(!x[n]) return 1;
    else return 0;
}
int main(){
    scanf("%d",&n);
    rep(i,1,n){
        scanf("%d",&a[i]);
        l=max(a[i]+a[i-1],l);
    }
    l=max(l,a[1]+a[n]);
    r=300001;
    while(l<r){
        int mid=(l+r)>>1;;
        if(check(mid)) r=mid;
        else l=mid+1;
    }
    cout<<l;
}
```


---

## 作者：XL4453 (赞：4)

------------
解题思路：

首先想到的是（错误的）贪心。

对于任意两个相邻的将军（包括第一个和最后一个），至少需要两人勋章之和的勋章，于是直接取所有的最大值。

错误的原因也很简单——没有考虑第一个和最后一个是相邻的。

例如有三个人，需求都是1，这个贪心的结果是2，实际显然为3。



------------


感觉贪心没什么大问题，能不能抢救一下呢？

顺着刚才的思路往下想，其实发现只有最后一个和第一个有冲突，为什么不能抢救一下呢？

可以发现，每一个勋章其实只能让 $\dfrac{n}{2}$ 个将军获得，否则就会冲突。

还是看一开始的反例，发现问题其实是出在每一个勋章都给了2个人，其实不可能，在那种情况下每个勋章最多只能给1个人。

那么就可以总结出另一个式子，也就是$\dfrac{\sum^{n}_{i=1}a_i}{\left\lfloor\dfrac{n}{2}\right\rfloor}$，
分母意思是每个徽章最多能给予的将军数，分子表示将军所需的勋章总数，整个式子意思就是把每个勋章作用发挥到最大至少需要的勋章数



------------
代码：

```cpp
#include<cstdio>
using namespace std;
int max(int a,int b){if(a>b)return a;return b;}
int n,a[20005],ans,tot;
int main(){
	scanf("%d",&n);
	if(n==1)return 0&scanf("%d",&a[1])&printf("%d",a[1]);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		ans=max(ans,a[i]+a[i-1]);
		tot+=a[i];
	}
	ans=max(ans,a[1]+a[n]);
	ans=max(ans,(tot+(n/2)-1)/(n/2));
	printf("%d",ans);
	return 0;
}
```


---

## 作者：lemir3 (赞：4)

[*在我的博客阅读*](https://www.lemir3.red/2020/05/09/ZJOI2006-%E7%9A%87%E5%B8%9D%E7%9A%84%E7%83%A6%E6%81%BC%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/)

## 题目分析

如果是一条链的话,直接贪心求出最大的相邻和即为答案.

然而题目是一个环,所以考虑最后一个集与第一个集的包含关系.

考虑二分出一个答案作为全集的大小,递推求解,设$min_i$为$\{i\} ~\cap~ \{i-1\} =0$的情况下,$\{i\} ~\cap~ \{1\}$的最小值.

因为要让$\{i\} ~\cap~ \{1\}$最小,所以要使i能够取的范围最大,我们需要使在{i-1}和{1}之外的元素最多,也就是最小化$\{i-1\} ~\cup~ \{1\}$.

根据容斥原理,我们知道:

>   $\{i-1\} ~\cup~ \{1\} = \{i-1\} + \{1\} - \{i-1\} ~\cap~ \{1\}$

{i-1}和{1}的大小是固定的,所以最大化$\{i-1\} ~\cap~ \{1\}$即可,我们设$max_i$为$\{i-1\} ~\cap~ \{1\}$的最大值.

现在考虑如何进行转移,对于$min_i$,我们用全集减去容斥原理求出的$\{i-1\} ~\cup~ \{1\}$,得到{i-1}和{1}之外的元素数量,用{i}减去这个数量就是必须与{1}相交的数量了,当然不能小于0.

对于$max_i$,很好发现用{1}减去$min_{i-1}$就是了,因为一个是交的最小值,一个是交的最大值.

## 代码

```cpp
#include "iostream"
#include "cstdio"
#include "cstring"
#include "cstdlib"
#include "cmath"
#include "cctype"
#include "iomanip"
#include "time.h"
#include "set"
#include "queue"
#include "map"
#include "stack"
#include "deque"
#include "vector"
#include "algorithm"
#define lxl long long
#define R register
#define INF 0x3f3f3f3f
#define debug(x) printf("debug:%lld\n",x)
const lxl maxn=20010;
lxl n,l,r=INF,mid,ans;
lxl max_[maxn],min_[maxn],a[maxn];
inline lxl read()
{
	char c=getchar();
	lxl f=1,x=0;
	for(;!isdigit(c);c=getchar())(c=='-')&&(f=-1);
	for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+(c^48);
	return f*x;
}
inline bool check(lxl limit)
{
	for(R int i=2;i<=n;++i)
	{
		max_[i]=std::min(a[i],a[1]-min_[i-1]);
		min_[i]=std::max((lxl)0,a[i]-(limit-(a[i-1]+a[1]-max_[i-1])));
	}
	return !min_[n];
}
int main(void)
{
	n=read();
	for(R int i(1);i<=n;++i)a[i]=read(),l=std::max(l,a[i]+a[i-1]);
	min_[1]=max_[1]=a[1];
	while(l<=r)
	{
		mid=(l+r)>>1;
		if(check(mid))r=mid-1,ans=mid;
		else l=mid+1;
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：小元勋 (赞：3)

- 可以发现，如果$n$为偶数，那么答案为相邻两个人$a_{i}$之和的最大值，即：

$$ans=\max(a_{i}+a_{i+1})$$

- 如果$n$为奇数，就不适用上诉方法了。我们二分答案$ans$。
假设已经有了$ans$枚勋章，该如何分配：


假设第一个人的勋章为$1\sim{a_{1}}$，那么最优策略是这样的：

编号为偶数的人尽量往前取，编号为奇数的人尽量往后取。

代码实现上，记录每个人在$[1,a_{1}]$中选了几个数,在$[a_{1}+1,ans]$中选了几个数。

最后如果第$n$个人在$[1,a_{1}]$取的数为$0$，则是可行的。


```cpp
#include <bits/stdc++.h>
using namespace std;
#define maxn 100050

int n,a[maxn],ans,l,r,mid;
struct node {
	int L,R;
}e[maxn];

inline int read_() {
	int x_=0,f_=1;char c_=getchar();
	while(c_<'0'||c_>'9') {if(c_=='-') f_=-1;c_=getchar();}
	while(c_>='0'&&c_<='9') {x_=(x_<<1)+(x_<<3)+c_-'0';c_=getchar();}
	return x_*f_;
}

inline bool work_(int x) {
	e[1].L = a[1];e[1].R = 0;
	int LL = a[1],RR = x - a[1];
	for(int i = 2;i <= n;++i) {
		if( ! ( i % 2 ) ) {
			e[i].L = min( LL - e[i-1].L,a[i] );
			e[i].R = a[i] - e[i].L;
			if( e[i].R + e[i-1].R > RR ) return false;  
			if( e[i].L < 0 || e[i].R > RR ) return false;
		}
		else {
			e[i].R = min( RR - e[i-1].R,a[i] );
			e[i].L = a[i] - e[i].R;
			if( e[i].L + e[i-1].L > LL ) return false;
			if( e[i].R < 0 || e[i].L > LL ) return false;
		}
	}
	if( ! e[n].L ) return true;
	return false;
}

void readda_() {
	n = read_();
	r = 0;
	for(int i = 1;i <= n;++i) {
		a[i] = read_();
		r = max( r,a[i] * 3 );
	}
	if( n == 1 ) {
		printf("%d\n",a[1]);
		return;
	} 
	ans = 0;
	if( ! ( n % 2 ) ) {
		for(int i = 1;i < n;++i) {
			ans = max( ans,a[i] + a[i+1] );
		}
		ans = max( ans,a[1] + a[n] );
		printf("%d\n",ans);
	}
	else {
		l = 0;
		while( l <= r ) {
			mid = ( l + r ) >> 1;
			if(work_(mid)) {
				ans = mid;
				r = mid - 1;
			}
			else l = mid + 1;
		} 
		printf("%d\n",ans);
	}
} 

int main() {
	readda_();
	return 0;
}
```

---

## 作者：shuiyuhan (赞：2)

这题怎么没有pascal题解啊qaq

那蒟蒻就发一篇吧

感觉这是道恶评题(应该只有黄吧)

如dalao所说，这题就是一个二分，因为有单调性，所以可以直接二分答案，然后再判断答案是否可行即可。

用b[i]表示第i个数与第一个数最多可以相同多少个，c[i]表示第i个数与第一个数至少相同多少个,所以只要判断c[n]是否为0即可

代码：
```pascal
uses math;
var
  a,b,c:array[0..100005] of int64;//小心longint不够存哦(虽然这题似乎不会)
  i,j,n,ll,rr,mid:longint;
function check(mid:longint):boolean;
var
  i:longint;
begin
  for i:=2 to n do
  begin
    b[i]:=min(a[i],a[1]-c[i-1]);
    c[i]:=max(0,a[1]+a[i-1]-b[i-1]+a[i]-mid);
  end;
  if c[n]=0 then exit(true) else exit(false);
end;//验证答案是否可行
begin
  readln(n);
  for i:=1 to n do
  begin
    read(a[i]);
    ll:=max(ll,a[i]+a[i-1]);
  end;
  b[1]:=a[1];
  c[1]:=b[1];
  rr:=300000;//rr代表查找上界,ll代表查找下界
  while ll<=rr do
  begin
    mid:=(ll+rr)>>1;//>>1相当于/2，但>>1更快
    if check(mid) then rr:=mid-1 else ll:=mid+1;//更新上下界
  end;//二分答案
  writeln(ll);
end.
```


---

## 作者：ncwzdlsd (赞：2)

先特判 $n=1$ 的情况，此时直接输出 $a_1$ 即可。

先考虑对于任意两个相邻的将军，至少需要他们需要的勋章数量和的花费，先在这些值里取 $\max$。

再考虑到每种勋章最多被分配给 $\lfloor \dfrac{n}{2}\rfloor$ 个将军，所以至少需要的勋章数不小于 $\lceil\dfrac{\sum\limits_{i=1}^n a_i}{\lfloor\dfrac{n}{2}\rfloor}\rceil$。

两者取较大值即是满足条件的最少勋章数。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

const int maxn=2e4+5;
int a[maxn];

signed main()
{
    int n;cin>>n;
    int sum=0;
    for(int i=1;i<=n;i++) cin>>a[i],sum+=a[i];
    if(n==1) cout<<a[1],exit(0);
    int ans=-INT_MAX;
    for(int i=1;i<n;i++) ans=max(ans,a[i]+a[i+1]);
    ans=max(ans,a[1]+a[n]);
    ans=max(ans,(int)ceil((double)sum/(n/2)));
    cout<<ans;
    return 0;
}
```

---

## 作者：caohan (赞：1)

# 思路

很容易手搓出一种在 $n$ 为偶数时的方法：取相邻两个数的最大值。

可是在奇数时随便一想，就有 $n=3,a={5,5,5}$ 的反例，其中正解为 $15$ 而上述方法为 $10$。

那在奇数时，就只能依靠二分来枚举答案了，假设当前正好枚举了 $x$ 这个数量。

我们便先让第 $1$ 个将军先领，命其领 $1$ 至 $a_i$ 这几种的奖牌。

则原区间便可分为 $\left [ 1,a_1 \right ] $ 和剩下的一部分。

可是因为可恶的环状排列，我们必须让第 $n$（奇数）位不拿偏小的区间，那第 $n-1$（偶数）位就必须尽量在偏小的区间中去拿，反复推下去，就知道，偶数拿小奇数拿大是一个正确的方案。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int a[20005],fl[20005],fr[20005];
int chk(int x)
{
	memset(fl,0,sizeof(fl));
	memset(fr,0,sizeof(fr));
	int l=a[1],r=x-a[1];
	fl[1]=a[1];//先让第一个将军拿完 
	for(int i=2;i<=n;i++)
	{
		if(a[i]+a[i-1]>x)
		{
			return 0;//相邻的都不够，肯定不可能 
		}
		if(i%2)
		{
			fr[i]=min(r-fr[i-1],a[i]);//能在右边拿，就别去左边 
			fl[i]=a[i]-fr[i];//实在拿不了，再往左边拿 
		}
		else
		{
			fl[i]=min(l-fl[i-1],a[i]);
			fr[i]=a[i]-fl[i];//同理 
		}
	}
	return !fl[n];//最后一个左边拿不拿 
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	int ans=-2100000000;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		ans=max(ans,a[i]+a[i-1]);
	}//输入，顺便处理偶数情况 
	if(n%2)
	{
		int l=1,r=2000000000;
		while(l<r)
		{
			int mid=(l+r)/2;
			if(chk(mid))
			{
				r=mid;
			}
			else
			{
				l=mid+1;
			}
		}//谨慎向小的二分 
		ans=l;//刷新答案 
	}
	cout<<ans;//输出 
	return 0;
}
```


---

## 作者：Durancer (赞：1)


#### P4409 [ZJOI2006]皇帝的烦恼

##### 思路

- 本题目的意思为给定 $n$ 个集合，按照一个圆形排列，保证集合 $i$ 与相邻的两个集合没有任何交集

- ~~如何求解是唯一的问题~~

- 首先可以可以将 $1$ 看做一个基准点，通过对  $2\to n$的集合求解来二分判断即可

- 设定两个变量
  
  $sml$ 表示 $1$ 与 $i$ 的最小交集个数
  
  $big$ 表示 $1$ 与 $i$ 的最大交集个数
  
  实际上就是根据容斥原理
  
  $$x_1\cup x_i=x_1+x_i -x_1\cap x_i$$
  
  得到即可
- 可以得到状态转移方程为

$$big_i=min(x_i,x_1-sml_{i-1})$$

$$sml_i=max(0,x_i-(pd-(x_{i-1}+x_1-big_{i-1})))$$

其中的$pd$为每一次二分出来的总勋章数，最后处理完的时候判断一下 $sml_n$ 是否为 $0$ 即可，因为只有保证最后一个与第一个的交集最小值为 $0$ 这个条件成立，才能保证所有的相邻的都没有交集（其他的再循环的时候已经处理好了，所以无需再检查，通过最后一个判断即可，其余的都是已经满足条件的了）

##### 代码

```
/*
	题意为：给定n个集合，按照一个圆形排列，保证集合i与相邻的两个集合没有任何交集
	思路：可以把集合1作为起点来找
	分别搜索2~n的集合的可行值 
*/
#include<algorithm>
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<queue>
#include<stack>
#include<map>
#include<set>
#define int long long 
using namespace std;
const int N=2e4+9;
int ans;
int xun[N];
int n,tol;
int big[N];//i与1的最大交集数量 
int sml[N];//表示i与1的最小交集数 
bool check(int x)
{
	for(int i=2;i<=n;i++)
	{
		big[i]=min(xun[i],xun[1]-sml[i-1]);
		sml[i]=max(0ll,xun[i]-(x-(xun[i-1]+xun[1]-big[i-1])));
	}
	if(!sml[n]) return true;//有交集说明一定不对 
	else return false;
} 
signed main()
{
	scanf("%lld",&n);
	int l=0;
	int r=300000;
	for(int i=1;i<=n;i++)
	{
		scanf("%lld",&xun[i]);
		l=max(l,xun[i]+xun[i-1]);//求出最小的情况 
		tol+=xun[i];
	}
	big[1]=sml[1]=xun[1];
	if(n==1) cout<<tol<<endl;
	while(l<=r)
	{
		int mid=(l+r)/2;
		if(check(mid))
		{
			r=mid-1;
			ans=mid;
		}
		else l=mid+1;
	}
	printf("%lld",ans);
	return 0;
}
```


---


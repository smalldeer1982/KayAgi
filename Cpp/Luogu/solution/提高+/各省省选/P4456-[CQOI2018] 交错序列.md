# [CQOI2018] 交错序列

## 题目描述

我们称一个仅由 $0$、$1$ 构成的序列为”交错序列“，当且仅当序列中没有相邻的 $1$（可以有相邻的 $0$）。例如，`000`,`001`,`101`,都是交错序列，而 `110` 则不是。

对于一个长度为 $n$ 的交错序列，统计其中 $0$ 和 $1$ 出现的次数，分别记为 $x$ 和 $y$。给定参数 $a$、$b$,定义一个交错序列的特征值为 $x^ay^b$。注意这里规定任何整数的 $0$ 次幂都等于 $1$（包括 $0^0=1$）。

显然长度为 $n$ 的交错序列可能有多个。我们想要知道，所有长度为 $n$ 的交错序列的特征值的和，除以 $m$ 的余数。（$m$ 是一个给定的质数）

例如，全部长度为 $3$ 的交错串为: `000`、`001`、`010`、`100`、`101`。当 $a=1,b=2$ 时，可计算：$3^1\times0^2+2^1\times1^2+2^1\times1^2+2^1\times1^2+1^1\times2^2=10$。


## 说明/提示

对于 30% 的数据，1≤n≤15

对于 100% 的数据，1≤n≤10000000 0≤a,b≤45 m<100000000

## 样例 #1

### 输入

```
3 1 2 1009```

### 输出

```
10```

## 样例 #2

### 输入

```
4 3 2 1009```

### 输出

```
204```

# 题解

## 作者：dtcxzyw (赞：15)

考虑贡献$x^ay^b=(n-y)^ay^b=\sum_{i=0}^{a}C(a,i)n^i(-y)^{a-i}y^b$

所以我们可以计算所有序列中1的个数的$a+b-i$次方和，然后枚举上式的$i$计算对应权值统计入答案即可。

设$F[i][j][0/1]$为前$i$位，最后一位为$0/1$，满足条件的序列的1的个数的j次方和，有转移方程:

0/1->0:贡献保持不变，$F[i][j][0]+=F[i-1][j][0/1]$

(在此感谢 @Joky_02 同学指出错误)

0->1:将$(y+1)^j$展开，有

$F[i][j][1]+=\sum_{k=0}^{j}C(j,k)F[i-1][k][0]$

填上转移矩阵后快速幂即可。

时间复杂度O($lgn(a+b)^3$)

最后附上代码：

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
const int size=185;
typedef long long Int64;
const Int64 maxv=1LL<<62;
#define asInt64(x) static_cast<long long>(x)
int mod;
struct Mat{
	int n,m,v[size][size];
	Mat(int n,int m):n(n),m(m){
		memset(v,0,sizeof(v));
	}
	int* operator[](int i){
		return v[i];
	}
	const int* operator[](int i) const{
		return v[i];
	}
	Mat operator*(const Mat& rhs) const{
		Mat res(n,rhs.m);
		for(int i=0;i<n;++i)
			for(int j=0;j<rhs.m;++j){
				Int64 sum=0;
				for(int k=0;k<m;++k){
					sum+=asInt64(v[i][k])*rhs[k][j];
					if(sum>=maxv)sum%=mod;
				}
				res[i][j]=sum%mod;
			}
		return res;
	}
};
int C[size][size]={};
Int64 powv[size];
int main(){
	int n,a,b;
	scanf("%d%d%d%d",&n,&a,&b,&mod);
	int c=a+b+1,d=2*c;
	
	C[0][0]=1;
	for(int i=1;i<c;++i){
		C[i][0]=1;
		for(int j=1;j<=i;++j)
			C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;
	}
	powv[0]=1;
	for(int i=1;i<=a;++i)
		powv[i]=powv[i-1]*n%mod;
		
	Mat mul(d,d);
	for(int i=0;i<c;++i){
		//0->0
		mul[i][i]=1;
		//1->0
		mul[i+c][i]=1;
		//0->1
		for(int j=i;j<c;++j)
			mul[i][j+c]=C[j][i];
	}
	
	Mat ans(1,d);
	ans[0][0]=1;
	while(n){
		if(n&1)ans=ans*mul;
		n>>=1,mul=mul*mul;
	}
	
	int res=0;
	for(int i=0;i<=a;++i){
		int p=a+b-i;
		Int64 fac=C[a][i]*((a-i)&1?-1:1)*powv[i]%mod;
		Int64 cnt=(ans[0][p]+ans[0][p+c])%mod;
		res=(res+cnt*fac)%mod;
	}
	printf("%d\n",(res+mod)%mod);
	return 0;
}

```


---

## 作者：RabbitHu (赞：13)

本题解同步发布于[胡小兔的博客](http://www.cnblogs.com/RabbitHu/p/BZOJ5298.html)，欢迎留言交流 >v<

## 题面

> 求所有长度为$n$的、没有相邻的1的01序列中，若0有$x$个、1有$y$个，$x^ay^b$之和（对$m$取模）。
> $n \le 10^7, m \le 10^8, 0 \le a, b \le 45$

## 题解

本题麻烦的地方在于这个$x^ay^b$怎么处理。

$$x^ay^b = (n - y)^ay^b = \sum_{i = 0}^{a}C_a^in^i(-y)^{a - i}y^b = \sum_{i = 0}^{a}(-1)^{a - i}C_a^in^iy^{a+b-i}$$ 

所以可以求出对于所有$i \in [0, a]$的$y^i$之和，然后枚举$i$乘上对应的系数，加起来即可。

那么如何求出$y^i$之和呢？

设$f[k][i][0/1]$表示长度为$k$、结尾是0/1的序列中“1的个数”（即$y$）的$i$次方之和。

0结尾的序列可以从0/1序列转移过来，而1的出现次数不会变。
$$f[k][i][0] = f[k - 1][i][0] + f[k - 1][i][1]$$

1结尾的序列只能从0结尾的转移过来，1的出现次数会+1，也就是新的$y' = (y + 1)^i = \sum_{j = 0}^{i}C_i^j y$。
$$f[k][i][1] = \sum_{j = 0}^{i}C_i^jf[k - 1][j][0]$$

然后构建矩阵就可以做了！

```cpp
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <iostream>
#include <set>
#define enter putchar('\n')
#define space putchar(' ')
using namespace std;
typedef long long ll;
template <class T>
void read(T &x){
    char c;
    bool op = 0;
    while(c = getchar(), c < '0' || c > '9')
    if(c == '-') op = 1;
    x = c - '0';
    while(c = getchar(), c >= '0' && c <= '9')
    x = x * 10 + c - '0';
    if(op == 1) x = -x;
}
template <class T>
void write(T x){
    if(x < 0) putchar('-'), x = -x;
    if(x >= 10) write(x / 10);
    putchar('0' + x % 10);
}

const int N = 185;
int n, a, b, P, sze1, sze2;
ll c[N][N], ans;
struct matrix {
    ll g[N][N];
    matrix(){
	memset(g, 0, sizeof(g));
    }
    matrix operator * (const matrix &b) const {
	matrix c;
	for(int i = 0; i < sze2; i++)
	    for(int j = 0; j < sze2; j++){
		for(int k = 0; k < sze2; k++)
		    c.g[i][j] += g[i][k] * b.g[k][j];
		c.g[i][j] %= P;
	    }
	return c;
    }
    friend matrix qpow(matrix a, int x){
	matrix ret;
	for(int i = 0; i < sze2; i++)
	    ret.g[i][i] = 1;
	while(x){
	    if(x & 1) ret = ret * a;
	    a = a * a;
	    x >>= 1;
	}
	return ret;
    }
} op;

int main(){
    read(n), read(a), read(b), read(P);
    sze1 = a + b + 1, sze2 = 2 * sze1;
    c[0][0] = 1;
    for(int i = 1; i <= a + b; i++){
	c[i][0] = 1;
	for(int j = 1; j <= i; j++)
	    c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % P;
    }
    for(int i = 0; i < sze1; i++){
	op.g[i][i] = op.g[i][sze1 + i] = 1;
	for(int j = 0; j <= i; j++)
	    op.g[sze1 + i][j] = c[i][j];
    }
    op = qpow(op, n);
    ll pw = 1;
    for(int i = 0; i <= a; i++){
	ans += (((a - i) & 1) ? -1 : 1) * c[a][i] * pw % P * (op.g[a + b - i][0] + op.g[sze1 + a + b - i][0]) % P;
	pw = pw * n % P;
    }
    write((ans % P + P) % P), enter;
    return 0;
}
```


---

## 作者：shadowice1984 (赞：12)

非常传统的双矩阵快速幂题目，但是这道题的亮点是卡常数吧……

在我AC这道题的时候，可能会出现读作TLE写做RE的情况发生，如果发生了这种情况(通常是40pts)，请开始卡常吧……

# 双矩阵快速幂

如果对矩阵快速幂一点都不了解的话，请自行百度自学吧……，这里默认你至少会一般的矩阵快速幂。

所谓双矩阵快速幂呢，就是在同一张矩阵中放置两个(甚至更多的)dp数组，这样可以实现处理两个不同dp数组的相互转移行为，或者出现了$dp_{i,j}$需要由$dp_{i-1,k},dp_{i-2,k'}$转移过来的尴尬情况，此时我们就可以通过一张矩阵上放置两个dp数组的方式来转移(代价是8倍的常数)，最简单的双矩阵快速幂就是求fibonacci数列第n项了，因为你的矩阵里同时保存了$f_{i},f_{i-1}$两个项

那么直接以这道题来讲解一下如何使用双矩阵快速幂以及如何卡常数好了


答案让我们求,有两个元不是十分美观，所以我们呢削去一个元

## $x^{a}y^{b}$

## $=(n-y)^ay^b$

使用二项式定理暴力展开

## $=\sum_{i=0}^{a}C_{a}^{i}(-1)^{a-i}n^{i}y^{a-i}y^b$

## $=\sum_{i=0}^{a}C_{a}^{i}(-1)^{a-i}n^{i}y^{a+b-i}$

然后我们现在要求的是

所有交错序列的上边式子的值，我们发现可以对于每一个交错序列来讲

## $C_{a}^{i}(-1)^{a-i}n^{i}$

都是常量，所以可以提出来，最后对所有式子的特征值统一用二项式定理

现在问题变成了，求所有交错序列的$y^{a+b-i}$的和，然后这样我们才可以仅在最后使用一次二项式定理

对于这个问题可以使用dp解决它，令$Dp_{i,j,k}(k∈(0,1))$表示决策到了第i位结尾为0/1，所有方案1的个数的j次方之和

那么转移方程有2个，分别是(0->0)或者(0->1)或者(1->0)

然后转移方程分别是这2个

转移到0的时候因为没有增加1的个数可以直接相加

## $Dp_{i,j,0}=Dp_{i-1,j,0}+Dp_{i-1,j,1}$

转移到1的时候增加了1的个数所以可以暴力二项式定理展开，由于不能放两个连续的1，所以只可以由0转移过来

## $Dp_{i,j,1}=\sum_{k=0}^{j}C_{j}^{k}Dp_{i-1,k,0}$

因此我们在构造转移矩阵的时候可以一张矩阵上放两个dp数组，前半部分放$Dp_{0}$，后半部分放$Dp_{1}$然后就可以转移啦~

当然构造转移矩阵时务必注意两点，转移的方向一定是从行到列的，转移从来都是单向转移。

转移矩阵的话，长相大概是左上角是单位矩阵(0->0)，左下角也是单位矩阵(1->0)，右上角是一个旋转90度的杨辉三角(0->1)，右下角全部是0(1->1)

然后矩阵快速幂就好了~

做完了？

你兴奋的写完了代码，加上去一看，40pts，只比$2^n$暴力高10分，手测一组数据，2.0s超了时限一倍……，我不服啊……

## 我要卡常数！

你仔细一看数据范围，发现m<=1e8而不是1e9

这意味着你可以在矩阵快速幂的时候在c\[i]\[j]通过$O(a+b)$次加法求出值之后再去膜，一次矩阵快速幂仅做了$O((a+b)^2)$次的取膜运算，卡常完毕……

你说，我不服啊……我要m开到1e9！

于是你尝试把long long换成了unsigned long long很好，你的程序变成了1.8s

然后你把循环的顺序由i,j,k换成了i,k,j，这会使你连续访问一段内存，大幅度减少cache miss，很好，现在你的程序可以在1.2s完成任务了……

然后你坐在电脑前卡了半年常数……却发现怎么也卡不进1s……正当你将要弃疗的时候，你把转移矩阵的n次幂打了出来！

你惊奇的发现，这个转移矩阵的n次幂是由4个上三角矩阵构成的！

这意味这整个矩阵有1/2的元素是0！，既然是0我们为什么要算它呢？

所以我们每次矩阵快速幂的时候只计算四个上三角矩阵的乘法，因为那些一定是0的部分我们没必要算……于是我们直接把常数除了一个2，然后现在我们可以在0.6s内通过这道题了……

上代码~

```C
#include<cstdio>
#include<algorithm>
#include<ctime>
using namespace std;const int M=190;typedef long long ll;int stat;int end;
int n;int m;ll mod;ll c[M][M];ll res;ll ans[M];ll siz;ll hsz;int a;int b;ll mi[M];
struct mar
{
 	ll mp[M][M];
 	mar(){for(int i=0;i<siz;i++)for(int j=0;j<siz;j++)mp[i][j]=0;}
 	friend mar operator *(const mar& a,const mar& b)//这里只做了4个上三角矩阵乘法，常数/2 
 	{
 		mar c;
 		for(int i=0;i<hsz;i++)//左上角 
         	for(int k=0;k<siz;k++)
 				for(int j=i;j<hsz;j++) 
 					(c.mp[i][j]+=a.mp[i][k]*b.mp[k][j])%=mod;
 		for(int i=0;i<hsz;i++)//右上角 
         	for(int k=0;k<siz;k++)
 				for(int j=hsz+i;j<siz;j++) 
 					(c.mp[i][j]+=a.mp[i][k]*b.mp[k][j])%=mod;
 		for(int i=hsz;i<siz;i++)//左下角 
         	for(int k=0;k<siz;k++)
 				for(int j=i-hsz;j<hsz;j++) 
 					(c.mp[i][j]+=a.mp[i][k]*b.mp[k][j])%=mod;
 		for(int i=hsz;i<siz;i++)//左下角 
         	for(int k=0;k<siz;k++)
 				for(int j=i;j<siz;j++) 
 					(c.mp[i][j]+=a.mp[i][k]*b.mp[k][j])%=mod;
 		return c;
 	}
}tr,ret,st;
int main()
{
    scanf("%d%d%d%lld",&n,&a,&b,&mod);hsz=a+b+1;siz=2*hsz;mi[0]=1;//因为放了两个dp数组 
    for(int i=0;i<hsz;i++)c[0][i]=c[i][i]=1;//先打表组合数 
    for(int i=0;i<hsz;i++)
        for(int j=1;j<i;j++)
            c[j][i]=(c[j-1][i-1]+c[j][i-1])%mod;
    for(int i=0;i<hsz;i++)tr.mp[i][i]=1;for(int i=0;i<hsz;i++)tr.mp[hsz+i][i]=1;//单位矩阵部分 
    for(int i=0;i<hsz;i++)for(int j=i;j<hsz;j++)tr.mp[i][hsz+j]=c[i][j];//杨辉三角部分 
    for(int i=0;i<siz;i++)ret.mp[i][i]=1;
    for(int p=n;p;p>>=1,tr=tr*tr)if(p&1)ret=ret*tr;//矩阵快速幂 
    for(int i=0;i<hsz;i++)ans[i]=(ret.mp[0][i]+ret.mp[0][hsz+i])%mod;//计算y^(a+b-i)和 
    for(int i=1;i<hsz;i++){mi[i]=mi[i-1]*n%mod;}//计算幂次 
    for(int i=0;i<=a;i++)//统一使用二项式定理 
    {
        ll del=c[i][a]*mi[i]%mod*ans[a+b-i]%mod;
        if((a-i)%2){res=(res+mod-del)%mod;}else {res=(res+del)%mod;}
    }printf("%lld",res);return 0;//拜拜程序~ 
}

```



---

## 作者：NaCly_Fish (赞：6)

一个很自然的想法是枚举序列中 $1$ 的个数 $i$，插板法即得答案为
$$\sum_{i=0}^n\binom{n-i+1}{i}  i ^b(n-i)^a$$
这个看起来就很像 EI 提出的那一套通法（赞美 EI！）能解决的。大部分题都是提取 $F(G(x))$ 的一项系数，但不要忘了其标准形式，即在对 $i\in[0,m]$ 已知
$$\sum_{j=0}^mA_j[x^j]G(x)^i$$
的时候可以 $\Theta(m)$ 求出
$$\sum_{j=0}^m A_j[x^j]F(G(x))=\sum_{i=0}^n f_i \sum_{j=0}^mA_j[x^j]G(x)^i$$
这里把求和上界暂记为 $m$，这个式子对应到我们这题上有
$$f_i = \binom{n-i+1}{i} \ , \ i^b(n-i)^a=\sum_{j=0}^mA_j[x^j]G(x)^i $$
用二项式展开可以发现，右式中对应 $i$ 的幂次最高到 $a+b$，所以应取 $m=a+b$。

现在就能直接套板子了，$F(x)$ 显然是微分有限的，求出 $\mathcal F(x)=F(x+1) \bmod x^{m+1}$ 对应的 ODE 后，递推求出 $\mathcal H(x) = \mathcal F(x-1)$ 的系数，最后所求即
$$\sum_{j=0}^m A_j[x^j] \mathcal H(G(x))=\sum_{i=0}^m h_i i^b(n-i)^a$$
但是要对 $i\in [0,m]$ 求出 $i^b(n-i)^a$ 似乎并不容易处理，如果哪位老哥会 $\Theta(m)$ 求的话还请来教育一下（

感觉还需要补充一下（才不是因为疏忽忘了说），在求 $\mathcal F(x)$ 的系数时需要先算出前两项。乍一看需要整式递推，不过将 $f_i$ 中的组合数拆开，可以得到：

$$F(x)=[z^n] \frac{1+xz}{1-z-xz^2}$$
于是有
$$\mathcal F(0)=[z^n] \frac{1+z}{1-z-z^2}$$
$$[x^1]\mathcal F(x) = \mathcal F'(0)=[z^n]\frac{z}{(1-z-z^2)^2}$$
问题从整式递推转化为了线性常系数递推，直接 $\Theta(\log n)$ 求出即可。


假设 $a,b$ 同阶，则总时间复杂度为 $\Theta(\log n +m \log m)$。

---

## 作者：PosVII (赞：6)

**前言**

------------

非常友好的省选题，用到的知识不是很难。喜提较劣 $O(n)$ 解。

**思路**

------------

单独列几项，发现答案长这样：

$\Sigma^{(n+1)/2}_{i=0} C^{i}_{n-i+1} \times (n-i)^{a} \times i^{b}$

难点在如何求 $(n-i)^{a} \times i^{b}$。

设函数 $f(x)=x^a$，其中 $a$ 为常数，且 $x=bc$，则 $f(x)=f(b)f(c)$。

因此只需要算质数的函数值即可用欧拉筛做了。可以证明时间复杂度为 $O(n)$。

**代码**

------------

```
#include<bits/stdc++.h>
using namespace std;
#define int long long
template<typename G> inline void read(G &x) {x=0;G f=1;char ch=getchar();while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();if(ch=='-') f=-1,ch=getchar();while(ch>='0'&&ch<='9') {x=x*10+(ch^48);ch=getchar();}x*=f;}
const int MAXN=1e7+5,MAXM=1e6+5;
int n,inv[MAXN],fac[MAXN],ans;
int f1[MAXN],f2[MAXN],pri[MAXM],cnt;
bool f[MAXN];
int qpow(int a,int b,const int p) {
    int res=1;
    while(b) {
        if(b&1) res=(res*a)%p;
        b>>=1;
        a=(a*a)%p;
    }
    return res;
}
int a,b;
void euler(const int p) {
	if(a==0) f1[0]=1;
	if(b==0) f2[0]=1;
	f1[1]=f2[1]=1;
	for(int i=2;i<=n;++i) {
		if(!f[i]) {
			f1[i]=qpow(i,a,p),f2[i]=qpow(i,b,p);
			pri[++cnt]=i;
		}
		for(int j=1;j<=cnt;++j) {
			if(i*pri[j]>n) break;
			f[i*pri[j]]=1;
			f1[i*pri[j]]=(f1[i]*f1[pri[j]])%p;
			f2[i*pri[j]]=(f2[i]*f2[pri[j]])%p;
			if(i%pri[j]==0) break; 
		}
	}
}
int m,lim;
int C(int x,int y,const int p) {
    return ((fac[x]*inv[y])%p*inv[x-y])%p;
}
signed main() {
	read(n),read(a),read(b),read(m),fac[0]=1;const int p=m;
	euler(p);
    for(int i=1;i<=n+1;++i) fac[i]=(fac[i-1]*i)%p;
	inv[n+1]=qpow(fac[n+1],p-2,p);
    for(int i=n;i>=0;--i) inv[i]=(inv[i+1]*(i+1))%p;
    for(int i=0;i<=(n+1)/2;++i) {
    	ans=(ans+((C(n-i+1,i,p)*f1[n-i])%p*f2[i]))%p;
	}
	printf("%lld",ans);
	return 0;
}
/*
(n-x)^a*(x)^b
=x^b(n-x)(n-x)
*/  
```

---

## 作者：Rorschachindark (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P4456)
# 思路
看到自己的做法似乎跟其他做法都不是很一样，所以还是来一发吧。（虽然自己好像跑得很慢。。。）

不难看出如果有 $x$ 个 $1$ 的时候一个数的贡献就是 $x^b(n-x)^a$，其它题解到这一步的时候都开始用二项式定理，但是其实我们完全可以不拆。

我们考虑有 $x$ 个 $1$ 的且满足条件的数有多少个，不难看出答案就是:

$$\sum_{i=0}^{n-x}\binom{n-x-i-1}{x-1}$$

其意义就是说我们枚举有 $i$ 个 $0$ 在第一个 $1$ 前面，然后把剩下 $n-x-i$ 个分成 $x$ 份分在每一个 $1$ 后面。

然后我们发现这个式子可以化成 $\binom{n-x+1}{x}$。

于是答案就是：

$$\sum_{x=0}^{\lfloor\frac{n+1}{2}\rfloor} \binom{n-x+1}{x}x^b(n-x)^a$$

我们如果要做到 $\Theta(n)$ 的话 $x^b$ 和 $(n-x)^a$ 直接线性筛就好了。

时空复杂度 $\Theta(n)$。
# $\texttt{Code}$
```cpp
#include <bits/stdc++.h>
using namespace std;

#define Int register int
#define MAXN 10000005

template <typename T> inline void read (T &t){t = 0;char c = getchar();int f = 1;while (c < '0' || c > '9'){if (c == '-') f = -f;c = getchar();}while (c >= '0' && c <= '9'){t = (t << 3) + (t << 1) + c - '0';c = getchar();} t *= f;}
template <typename T,typename ... Args> inline void read (T &t,Args&... args){read (t);read (args...);}
template <typename T> inline void write (T x){if (x < 0){x = -x;putchar ('-');}if (x > 9) write (x / 10);putchar (x % 10 + '0');}

int n,a,b,mod,tot,pw1[MAXN],pw2[MAXN],fac[MAXN],ifac[MAXN];
int mul (int a,int b){return 1ll * a * b % mod;}
int dec (int a,int b){return a >= b ? a - b : a + mod - b;}
int add (int a,int b){return a + b >= mod ? a + b - mod : a + b;}
int qkpow (int a,int b){int res = 1;for (;b;b >>= 1,a = mul (a,a)) if (b & 1) res = mul (res,a);return res;}
int binom (int a,int b){return a >= b ? mul (fac[a],mul (ifac[a - b],ifac[b])) : 0;}
int inv (int x){return qkpow (x,mod - 2);}

bool vis[MAXN];
void Euler (int up){
	pw1[0] = a == 0,pw2[0] = b == 0,pw1[1] = pw2[1] = 1;
	for (Int i = 2;i <= up;++ i){
		if (!vis[i]) fac[++ tot] = i,pw1[i] = qkpow (i,a),pw2[i] = qkpow (i,b);
		for (Int j = 1;j <= tot && i * fac[j] <= up;++ j){
			vis[i * fac[j]] = 1,pw1[i * fac[j]] = mul (pw1[i],pw1[fac[j]]),pw2[i * fac[j]] = mul (pw2[i],pw2[fac[j]]);
			if (i % fac[j] == 0) break;
		}
	}
}

signed main(){
	read (n,a,b,mod);Euler (n);
	fac[0] = 1;for (Int i = 1;i <= n + 1;++ i) fac[i] = mul (fac[i - 1],i);
	ifac[n + 1] = inv (fac[n + 1]);for (Int i = n + 1;i;-- i) ifac[i - 1] = mul (ifac[i],i);
	int ans = 0;for (Int x = 0;x <= (n + 1) / 2;++ x) ans = add (ans,mul (binom (n - x + 1,x),mul (pw1[n - x],pw2[x])));
	write (ans),putchar ('\n');
	return 0;
}
```

---

## 作者：a_sad_soul (赞：3)

## 暴力出奇迹!

首先我们用板插法可以得到公式是

$$\large\sum\limits_{k=0}^{n}{C_{k}^{n-k+1}(n-k)^ak^b}$$


注意到 $n$ 的大小只有 $10^7$，$a$ 和 $b$ 只有 $45$ 于是算 $C$ 和次幂部分可以大概看成一个常数。首先 $O(n+\log n)$ 预处理出 $0\sim n$ 的阶乘和逆元。暴力计算输出答案，恭喜你拿到了 55pts 的高分。

观察下后面几个点，其实都是多了 100ms+ 的。所以我们考虑把这部分常数优化掉。 

- 由于 C++ 的无符号整型比有符号的要快，所以我们可以将 `long long` 改为 `unsigned long long`。
- 带有 `const` 修饰的整型取模要比不带的要快，所以我们输入 $m$ 后将其置为`const`。

经过这些操作，你的代码就能愉快地卡过去了~

下面是我的代码（[最慢一个点 968ms](https://www.luogu.com.cn/record/154043966)）：


```cpp
#include<bits/stdc++.h>
#define MAXN 10000005
using namespace std;
unsigned long long mult[MAXN];
unsigned long long rev[MAXN];
long long n,m,a,b;
unsigned long long ksm(unsigned long long base,unsigned long long pow,const unsigned long long m)
{
    unsigned long long re=1;
    while(pow){
        if(pow&1)re=(base*re)%m;
        base=(base*base)%m;
        pow>>=1;
    }
    return re;
}
unsigned long long C(unsigned long long a,unsigned long long b,const unsigned long long m)
{
    return (mult[a]*rev[b]%m)*rev[a-b]%m;
}
int main()
{
    mult[0]=1;
    scanf("%lld%lld%lld%lld",&n,&a,&b,&m);
    const unsigned long long M=m;
    unsigned long long mid2=n;++mid2;
    for(int i=1;i<=mid2;++i)
        mult[i]=(mult[i-1]*i)%M;
    rev[mid2]=ksm(mult[mid2],m-2,M);
    rev[0]=1;
    unsigned long long ans=0;
    for(int i=mid2-1;i>=1;--i)
        rev[i]=(rev[i+1]*(i+1))%M;
    for(int i=0;i<=n-i+1;++i)
    {
        ans=(ans+(C(n-i+1,i,M)*ksm(n-i,a,M)%M)*ksm(i,b,M))%M;
    }
    printf("%lld\n",ans);
    return 0;
}

```

---

## 作者：Lijunzhuo (赞：2)

前提紧要：此题解时间复杂度高达 $O(n)$，虽然能过，但是想学矩阵优化的人建议看其他题解。  
由于不能存在相邻两个 $1$，由插板法可得答案为：
$$\sum\limits_{i=0}^{\left\lfloor\frac{n+1}{2}\right\rfloor}\dbinom{n-i+1}{i}\times(n-i)^a\times i^b$$
所以暴力即可：
```cpp
#include<bits/stdc++.h>
using namespace std;
unsigned long long inv[10000005],fac[10000005];
unsigned long long n,a,b,m;
inline unsigned long long KSM(unsigned long long x,unsigned long long y)
{
	int ans=1;
	while(y)
	{
		if(y&1)
			ans=ans*x%m;
		x=x*x%m;
		y>>=1;
	}
	return ans;
}
int main()
{
	cin>>n>>a>>b>>m,
	fac[0]=fac[1]=1;
	for(int i=2;i<=n+4;i++)
		fac[i]=fac[i-1]*i%m;
	inv[n+4]=KSM(fac[n+4],m-2);
	for(int i=n+3;i>=0;i--)
		inv[i]=inv[i+1]*(i+1)%m;
	unsigned long long ans=0,l=(n>>1)+(n&1);
	for(int i=0;i<=l;i++)
		ans=(ans+fac[n-i+1]*inv[i]%m*inv[n-i-i+1]%m*KSM(n-i,a)%m*KSM(i,b)%m)%m;
	cout<<ans<<"\n";
	return 0;
}
```
自信提交后发现 $\texttt{TLE}$ 了两个点，考虑卡卡常：
1. 能不要的空间不要（似乎没什么用）。
2. 用 $\texttt{unsigned long long}$，据说能够快一点点。
3. 也是最重要的一点——去掉多余取模，具体可看 $\texttt{AC}$ 代码。

综上，我们可以打出以下代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
unsigned long long inv[10000002],fac[10000002];
long long n,a,b,m;
inline unsigned long long KSM(unsigned long long x,unsigned long long y)
{
	unsigned long long ans=1;
	while(y)
	{
		if(y&1)
			ans=ans*x%m;
		x=x*x%m,
		y>>=1;
	}
	return ans;
}
int main()
{
	scanf("%lld%lld%lld%lld",&n,&a,&b,&m),
	fac[0]=fac[1]=1;
	const unsigned long long MOD=m;
	for(int i=2;i<=n+1;i++)
		fac[i]=fac[i-1]*i%MOD;
	inv[n+1]=KSM(fac[n+1],m-2);
	for(int i=n;i>=0;i--)
		inv[i]=inv[i+1]*(i+1)%MOD;
	unsigned long long ans=0;
	for(int i=0;i<=n-i+1;i++)
		ans=(ans+fac[n-i+1]*inv[i]%MOD*inv[n-i-i+1]%MOD*KSM(n-i,a)%MOD*KSM(i,b))%MOD;//就是这里少了个取模，想一想为什么？
	printf("%lld\n",ans);
	return 0;
}
```
交了上去，过了，[评测记录](https://www.luogu.com.cn/record/225706440)。

---

## 作者：yinbe (赞：2)

## 题目

“交错数列” 为一个相邻位不为 $1$ 的 $01$ 串，每一个“交错数列” 的贡献为 $x^ay^b$，其中 $x$ 为 $0$ 的个数，$y$ 为 $1$ 的个数，求所有长度为 $n$ 的“交错数列” 的贡献之和。

## 思路

考虑枚举 $1$ 的个数，设种类数为 $cnt_{i}$ 那么每种的贡献为 $cnt_{i}\times x^a y^b=cnt_{i}\times (n-y)^a y^b=cnt_{i}\times \sum\limits_{i=0}^{a} C_{a}^i\times n^i\times (-y)^{a-i}\times y^b$，所以我们可以预处理所有符合要求的序列的 $1$ 的个数的 $a-i+b$ 次方的和。

$dp_{i,j,1/0}$ 表示所有序列末尾为 $1/0$ 的序列前 $i$ 位的 $1$ 的数量的 $j$ 次方的和。

显然，$dp_{i,j,0}=dp_{i-1,j,0}+dp_{i-1,j,1}$。

而当结尾为 $1$ 时，设 $1$ 的数量为 $y$，将 $(y+1)^n$ 展开得 $\sum\limits_{i=0}^{n}C_{n}^i\times y^n=\sum\limits_{i=0}^{n}C_{n}^i\times dp_{i-1,j,0}$，即 $dp_{i,j,1}=\sum\limits_{i=0}^{n}C_{n}^i\times dp_{i-1,j,0}$。

---

综上：

$dp_{i,j,0}=dp_{i-1,j,0}+dp_{i-1,j,1}$

$dp_{i,j,1}=\sum\limits_{i=0}^{n}C_{n}^i\times dp_{i-1,j,0}$

---

这样直接转移是 $O(n(a+b))$ 的，无法通过，需要优化。

## 优化

> 一般来说，如果一类问题具有以下特点：
>
> 1. 可以抽象成一个长度为 $n$ 的一维向量（可以理解成一维数组），向量在每个单位时间发生**一次**变化；
>
> 2. 变化的形式是一个**线性递推**（只有若干“加法” 或“乘一个系数” 的运算）；
>
> 3. 该递推式在每个单位时间可能作用于不同的数字上，但自身**保持不变**；
>
> 4. 向量**变化时间（即递推的轮数）很长**，但**向量长度 $n$ 不大**。
>
> 那么就可以考虑采用矩阵乘法进行优化。
>
> ——《算法竞赛进阶指南》

此处我们的状态转移方程中，$i$ 为递推阶段，可以省略，我们可以把 $dp_{j,1}$ 放到 $dp_{j,0}$ 后面，变成 $dp_{j}$，在 $0\le j \le a+b$ 时表示 $dp_{j,0}$，而当 $a+b<j< 2\times(a+b+1)$ 时表示 $dp_{j,1}$，就变成了一个一维向量，就可以使用矩阵快速幂优化了。

容易推得，转移矩阵的一个左上角和左下角为单位矩阵（对角线为 $1$，其他地方为 $0$ 的矩阵），右上角为一个向右翻转 $90^{\circ }$ 的杨辉三角，右下角全为 $0$，~~具体证明请读者自证~~。

### 关于卡常

写完矩阵快速幂后，你惊奇地发现，你获得了 [$40 $ pts 的好成绩](https://www.luogu.com.cn/record/223653288)，~~比直接 DP 高了整整 $10 $ pts ！真的太棒了~~

因为 $m \le 10 ^8$，所以 $m \times 2(a+b) \le MAX＿LONGLONG$，所以在进行矩阵乘法时，我们可以先全部加完然后再取模。

## 代码

```cpp
#include<iostream>
#include<cstring>
using namespace std;
int n,a,b;
long long mod,f[105],inv[105],dp[205],base[205][205],tot[100],ans,mi[50];
long long quick_pow(long long a,long long b)
{
	long long ans=1;
	for(;b;b>>=1)
	{
		if(b&1)
			ans=ans*a%mod;
		a=a*a%mod;
	}
	return ans;
}
long long C(int a,int b)
{
	if(a<b||b<0||a<0)
		return 0;	
	if(a==0||b==0||a==b)
		return 1;
	return f[a]*inv[b]%mod*inv[a-b]%mod;
}
void mul()
{
	long long c[205];
	memset(c,0,sizeof(c));
	for(int j=0;j<2*(a+b+1);j++)
	{
		for(int k=0;k<2*(a+b+1);k++)
			c[j]+=dp[k]*base[k][j]%mod;
		c[j]%=mod;
	}
	memcpy(dp,c,sizeof(c));
}
void mulself()
{
	long long c[205][205];
	memset(c,0,sizeof(c));
	for(int i=0;i<2*(a+b+1);i++)
	{
		for(int j=0;j<2*(a+b+1);j++)
		{
			for(int k=0;k<2*(a+b+1);k++)
				c[i][j]+=base[i][k]*base[k][j]%mod;
			c[i][j]%=mod;
		}
	}
	memcpy(base,c,sizeof(c));
}
int main()
{
	scanf("%d%d%d%lld",&n,&a,&b,&mod);
	mi[0]=1;
	for(int i=1;i<=a;i++)
		mi[i]=mi[i-1]*n%mod;
	f[0]=1;
	for(int i=1;i<a+b+1;i++)
	{
		f[i]=f[i-1]*i%mod;
		inv[i]=quick_pow(f[i],mod-2);
	}
	for(int i=0;i<a+b+1;i++)
		base[i][i]=base[i+a+b+1][i]=1;
	for(int i=0;i<a+b+1;i++)
	{
		for(int j=0;j<a+b+1;j++)
			base[i][j+a+b+1]=C(j,i);
	}
	dp[0]=1;
	int m=n;
	for(;m;m>>=1)
	{
		if(m&1)
			mul();
		mulself();
	}
	for(int i=0;i<a+b+1;i++)
		tot[i]=dp[i]+dp[i+a+b+1];
	for(int i=0;i<=a;i++)
	{
		if((a-i)&1)
			ans=(ans+mod-C(a,i)*mi[i]%mod*tot[a-i+b]%mod)%mod;
		else
			ans=(ans+C(a,i)*mi[i]%mod*tot[a-i+b]%mod)%mod;
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：KokiNiwa (赞：1)

# [CQOI2018]交错序列

## 草稿

设有$a$个$0$，$b$个$1$的交错数列有$f(a,b)$个。着就相当于有$b$个板子，现在要在这$b$个板子中插入$a$个球，而且每两个板子间空内至少有$1$个球，两端不做要求。那么$f(a,b)=C_{a+1}^{b}$种插入方法。

于是答案可以表示为：

$$
\sum_{i=0}^{\lfloor \frac{n+1}{2}\rfloor}f(n-i,i)\cdot (n-i)^a\cdot i^b=\sum_{i=0}^{\lfloor \frac{n+1}{2}\rfloor}C_{n-i+1}^{i}\cdot(n-i)^a\cdot i^b
$$
尝试展开$(n-i)^ai^b$？

$$
\begin{aligned}
(n-i)^ai^b
&= \sum_{j=0}^{a} C_{a}^{j}\cdot i^{j+b}\cdot n^{a-j}\cdot (-1)^j
\end{aligned}
$$

没什么用处。

## 大概做法

首先展开$(n-i)^ai^b$。发现有一些是常数，最终要求的（对于每个序列不一样的），其实就是所有序列的1的个数的$a+b-i$次方。其中$i\in [1,a]$。然后可以递推。递推设$f_{i,j,k}$表示前$i$位，所有序列满足最后一位为$k$的$1$的个数的$j$次方和。然后用矩阵优化，矩阵中搞一个杨辉三角即可。
具体转移方程：
$$
f_{i,j,0}=f_{i,j,0}+f_{i,j,1}
$$
$$
f_{i,j,1}=\sum_{k=0}^{j}C_{j}^{k}f_{i-1,k,0}
$$

## 知识点

+ 并不是所有东西都化成数学形式就好的（化为数学式子就有可能发现不了某些优化方案）
+ 求一个与次方相关的式子的值的时候，可以考虑动态规划与杨辉三角结合。

+ 注意在系数为负数的数运算时先把这个数加$mod$在模$mod$在进行运算。否则会出事，有可能减成负数（这样答案就成了负数，虽然在模$mod$的意义下与答案等价）。

## 代码
```cpp
#include <cstdio>
#include <cstring>

typedef long long ll;
const int SIZE = 45 * 4 + 5;
int seqLen = 0, aExp = 0, bExp = 0, mod = 0;
int matSiz = 0;
ll C[95][95] = {};
struct MATRIX
{
	int row, col;
	ll num[SIZE][SIZE];
	MATRIX(int needRow, int needCol)
	{
		row = needRow;
		col = needCol;
		memset(num, 0, sizeof(num));
		return ;
	}
	
	MATRIX operator * (const MATRIX &d) const
	{
		MATRIX ret(row, d.col);
		for (int mid = 1; mid <= col; ++mid)
			for (int rI = 1; rI <= row; ++rI)
				for (int cJ = 1; cJ <= d.col; ++cJ)
				{
					ret.num[rI][cJ] += num[rI][mid] * d.num[mid][cJ] % mod;
					ret.num[rI][cJ] %= mod;
				}
		//访问一段连续空间
		return ret;
	}
} yuan(0, 0), zhuan(0, 0), res(0, 0);
void matPow(int ci)
{
	res = yuan;
	for (; ci; ci >>= 1, zhuan = zhuan * zhuan)
		if (ci & 1)
			res = res * zhuan;
	return ;
}
void initC()
{
	C[0][0] = 1;
	for (int down = 1; down <= 90; ++down)
	{
		C[down][0] = 1;
		for (int up = 1; up <= down; ++up)
		{
			C[down][up] = C[down - 1][up] + C[down - 1][up - 1];
			C[down][up] %= mod;
		}
	}
	return ;
}

int main()
{
	freopen("sequence.in", "r", stdin);
	freopen("sequence.out", "w", stdout);
	scanf("%d%d%d%d", &seqLen, &aExp, &bExp, &mod);
	matSiz = 2 * (aExp + bExp + 1);
	yuan.row = 1;
	yuan.col = matSiz;
	yuan.num[1][1] = 1;
	zhuan.row = matSiz;
	zhuan.col = matSiz;
	for (int rI = 1; rI <= matSiz / 2; ++rI)
	{
		zhuan.num[rI][rI] = 1;
	}
	for (int rI = 1; rI <= matSiz / 2; ++rI)
	{
		zhuan.num[rI + matSiz / 2][rI] = 1;
	}
	initC();
	for (int rI = 1; rI <= matSiz / 2; ++rI)
	{
		for (int cJ = matSiz / 2 + 1; cJ <= matSiz; ++cJ)
		{
			zhuan.num[rI][cJ] = C[cJ - matSiz / 2 - 1][rI - 1];
		}
	}
	matPow(seqLen);
//	res = res * yuan;这句话已经在 matPow 里面加过了
	ll nPow = 1, ans = 0;
	for (int ci = 0; ci <= aExp; ++ci)
	{
		ll pro = nPow * C[aExp][ci] % mod * ((aExp - ci) & 1 ? -1 : 1);
		pro = (pro + mod) % mod;
		//这里应该模一下
		ans += (res.num[1][matSiz / 2 - ci] % mod + res.num[1][matSiz - ci]) * pro % mod;
		ans %= mod;
		nPow = nPow * seqLen % mod;
	}
	printf("%lld\n", ans);
	fclose(stdin);
	fclose(stdout);
	return 0;
}
```

---

## 作者：toolazy (赞：0)

感觉自己想了一个很诡异的做法然后居然发现和题解区重了，难评（

---

感觉状态好复杂，所以不用矩阵快速幂了（哈？

看到 $n\le10^7$ 看着就像是 $O(n)$ 很能跑的样子，数学题出到这个数据范围不是很正常的吗（

所以决定直接枚举一点低端的东西看看能不能拆：

$$
\text{final ans}=\sum_{x=0}^{\lceil\frac n2\rceil}f(x)g(x)
$$

其中 $x$ 是我们枚举的『序列中 $1$ 的出现次数』，$f(x)$ 为序列数量，而 $g(x)$ 则为其贡献。

我们考虑一个一个攻破：

- 对于 $f$，其实这应该就是小学奥数了（

	所谓『隔板法』，$f(x)$ 意味着这 $x$ 个 $1$ 中间势必要存在 $x-1$ 个 $0$ 来隔断他们之间的~~羁绊~~联系。
    
    所以我们直接把 $0$（也就是隔板）拿掉，这样就直接从 $n-(x-1)=n+1-x$ 个数里面选 $x$ 个 $1$，然后再视情况把板子插回去。
    
    所以 $f(x)=\displaystyle\binom{n+1-x}{x}$。
    
    这玩意儿预处理一下阶乘和逆元就能 $O(n)\sim O(1)$ 的捏。
    
- 对于 $g$，答案其实更简单，就是 $g(x)=x^a\cdot (n-x)^b$。

	然后按照其他题解的说法，这时候就要开始大力拆解，开始 DP 递推了...
    
    no！
    
    其实已经结束了。
    
    遇到固定幂次的幂函数，使用欧拉筛实际上是一个非常套路的做法。
    
    所以其实这个 $a,b$ 是可以开到和 $n$ 同量级的，此时一次快速幂是 $O(\lg n)$ 但素数估量只有 $O(\frac n{\lg n})$，正好 $O(n)$。
    
    反观矩阵快速幂，现在已经错乱了（什
    
但是毕竟 $10^7$ 有点吃紧，卡卡常嘛正常的（矩阵快速幂不也要卡常的嘛 hhh

---

## 作者：Prean (赞：0)

我就是不用矩阵快速幂！

题意：一个 $ \rm 01 $ 序列为合法的当且仅当没有两个相邻的 $ 1 $，若 $ 1 $ 的个数为 $ x $，$ 0 $ 的个数为 $ y $，这个 $ \rm 01 $ 的价值为 $ x^a \times y^b $。

请求出所有长度为 $ n $ 的 $ \rm 01 $ 序列的价值之和，对 $ m $ 取模。

这道题的阴间之处就在于 $ m $ 不一定是质数。。。

首先我们枚举 $ 1 $ 的个数，可以得到答案为：
$$ \sum_{i=0}^n\binom {n-i+1} ii^b(n-i)^a $$
如果 $ m $ 是质数的话，这里就可以直接 $ O(n) $ 计算了，可惜并不是。

考虑使用二项式定理展开后者：
$$ \sum_{i=0}^{\infty}\binom {n-i+1}ii^b\sum_{j=0 }^a\binom a jn^{a-j}(-i)^j $$
$$ \sum_{j=0}^a\binom a jn^{a-j}(-1)^j\sum_{i=0}^{\infty}\binom {n-i+1} ii^{b+j} $$
现在的问题就是如何处理 $ \sum_{i=0}^{\infty}\binom {n-i+1}ii^k $。

使用 $ \binom n m=\binom {n-1} m+\binom {n-1}{m-1} $ 展开组合数：
$$ f_{n,k}=\sum_{i=0}^{\infty}\binom {n-i} i i^k $$
$$ f_{n,k}=\sum_{i=0}^{\infty}(\binom {n-i-1} i+\binom {n-i-1}{i-1})i^k $$
$$ f_{n,k}=\sum_{i=0}^{\infty}\binom {n-i-1}i i^k+\sum_{i=1}^{\infty}\binom {n-i-1}{i-1} i^k $$
$$ f_{n,k}=f_{n-1,k}+\sum_{i=0}^{\infty}\binom {n-i-2} i(i+1)^k $$
把后面用二项式定理展开：
$$ \sum_{i=0}^{\infty}\binom {n-i-2} i\sum_{j=0}^k \binom k ji^j $$
$$ \sum_{j=0}^k\binom k j\sum_{i=0}^{\infty}\binom {n-i-2} ii^j $$
所以：
$$ f_{n,k}=f_{n-1,k}+\sum_{j=0}^k\binom k jf_{n-2,j} $$
如果仔细点儿可以发现这里实际上是在说：
$$ f_{n,k}=f_{n-1,k}+f_{n-2,k}+\sum_{j=0}^{k-1}\binom k jf_{n-2,j} $$
也就是说 $ f_{i,j} $ 对 $ f_{n,k} $ 的贡献与斐波那契数列有关，为 $ \binom k jfib_{n-i-2} $。

接下来就很好办了。

设 $ F_k(x)=\sum_{i=0}^{\infty}f_{i,k}x^i $

首先很明显，根据定义有 $ F_0(x)=\frac 1 {1-x-x^2} $。（也就是斐波那契数列）

于是有：
$$ F_k(x)=\frac {x^2} {1-x-x^2}\sum_{i=0}^{k-1}\binom k iF_i(x) $$

我们可以根据这个直接知道 $ F_1(x)=\frac 1 {(1-x-x^2)^2} $。

那么 $ F_2(x) $ 呢？
$$ \frac {\binom 2 1}{(1-x-x^2)^3}+\frac {\binom 2 0}{(1-x-x^2)^2}=\frac {\binom 2 1+\binom 2 0(1-x-x^2)^1}{(1-x-x^2)^3} $$
合理猜测 $ F_k(x) $ 的分母为 $ (1-x-x^2)^{k+1} $。

于是我们只维护分子，不维护分母。

那么分子所对应的递推式就应该是 $ H_k(x)=\frac {x^2}{1-x-x^2}\sum_{i=0}^{k-1}\binom k iH_i(x)(1-x-x^2)^{k-i} $。

于是我们使用类似秦九韶求多项式的值的方法可以做到 $ O(k^3) $ 处理出 $ H_0(x) \sim H_k(x) $，然后再使用常系数齐次线性递推算一下就是~~和比暴力矩快还慢的~~$ O((a+b)^3+a(a+b)^2\log n) $ 了。

~~第二种做法：我们可以列一个 DP 方程，然后用 BM 大力猜出递推式，就可以做到 $ O((a+b)^2\log n) $ 了，好耶！（这里根据直觉猜测递推式的长度就是 a+b）~~

---


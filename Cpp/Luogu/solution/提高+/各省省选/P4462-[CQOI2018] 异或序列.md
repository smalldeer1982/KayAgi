# [CQOI2018] 异或序列

## 题目描述

已知一个长度为 $n$ 的整数数列 $a_1,a_2,\dots,a_n$，给定查询参数 $l,r$，问在 $a_l,a_{l+1},\dots,a_r$ 区间内，有多少子区间满足异或和等于 $k$。也就是说，对于所有的 $x,y (l \leq x \leq y \leq r)$，能够满足 $a_x \oplus a_{x+1} \oplus \dots \oplus a_y = k$ 的 $x,y$ 有多少组。


## 说明/提示

对于 $30\%$ 的数据，$1 \leq n, m \leq 1000$。

对于 $100\%$ 的数据，$1 \leq n, m \leq 10^5$，$0 \leq k, a_i \leq 10^5$，$1 \leq l_j \leq r_j \leq n$。

## 样例 #1

### 输入

```
4 5 1
1 2 3 1
1 4
1 3
2 3
2 4
4 4```

### 输出

```
4
2
1
2
1```

# 题解

## 作者：Lice (赞：54)

### 闲话

- 博主更新给管理员带来的不便请谅解

- UPD 20200207 - 添加了一些归纳过的计算公式

- UPD 20200210 - 更正了将块取小的原因。

这是一篇 ***在线算法*** 的题解！！！

用了分块，虽然比莫队差一点点点点，但怎么说也是一种优美的解法。

只是比较考验细节，调了好几个小时啊啊啊啊啊。。。

![1sovFJ.png](https://s2.ax1x.com/2020/02/05/1sovFJ.png)

wtcl...

## 正片

### 数列分块的思想（熟悉的可以略过）

数列分块又被称作数列的平方分割。

数列分块是将整段数列分为均匀的几块，使得每块长度为$b$（末块的最后一个是第$n$个，并不是直接向后$+b$个，注意特判）。这里，$b$常取$\sqrt{n}$。

然后对每个块都维护一些必要的信息。

比如：[P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)这一题就可以用分块做。

我们维护一下每个块的原数字之和，加法标记即可。

查询或修改时，并不一定目标区间一定包含整块。对于边角块，暴力。对于整块，取其现成维护的信息即可。

由于散块中的元素不超过$2\sqrt{n}$个，整块一个不超过$\sqrt{n}$块，所以这样的分块算法复杂度为$O(m\sqrt{n})$。

如果仅仅对分块了解至此，对于本题而言还是远远不够的。详细的教程请自行到网上学习。这里不再赘述。

本题中，这里认为$n,m,k$同阶。

### 下面算法基于的技巧

在下面的算法中，我们要做到快速求得某一段的异或和。

我们知道，异或的逆运算即为异或。

所以我们定义$s_i=a_1\oplus a_2\oplus ... \oplus a_i$，其中$\oplus$代表异或，$a$为原数组。

那么$a_l\oplus a_{l+1}\oplus ... \oplus a_{r}$就等于$s_{r}\oplus s_{l-1}$。

现在问题成了：给定$l,r$，求区间$[l-1,r]$中有多少对二元组$(i,j)$满足$l-1\le i\le j\le r$且$s_i\oplus s_j=k$。

注意，由于实际使用时，$l$是要减一的，因此不能从一开始，而是0。

### 对于此题需要维护的信息

我们现在使用$s$取代一无是处的$a$。

- $pre[i][j]$表示前$i$个块之内，数字$j$出现的次数。

- $ans[i][j]$表示第$i$个到第$j$块（包括$i,j$）的 ***答案***。

至于为什么做这些，请继续阅读。

这里我们暂时仍用$\sqrt{n}$作块的大小。

### 预处理——$pre,ans$的求法。

先是$pre$，这个简单。我们在$s$上一路扫去直到$B|i$时，即应该是下一个块的开始时，我们将这个块的$pre$的信息copy到下一个块中。扫的时候顺便处理一下第$i$个位置的所属块的编号。

下面的代码优化了一下，就是先求出最大的$s$的元素，以其为边界进行copy。注意不要漏掉0。

```cpp
memset(pre[0],0,sizeof(pre[0]));
limits=*max_element(s,s+1+n);
for(register int i=0,j=0;i<=n;i++)
{
	if(i%B==0)
	{
		block=++j;
		for(register int val=0;val<=limits;val++)
			pre[j][val]=pre[j-1][val];
	}
	belong[i]=j,pre[j][s[i]]++;
}
```

这部分的复杂度为$O(\max\limits_{i\in [0,n]}{s_i}\times \sqrt{n})$。

然后是$ans$，这个是第一个难点。为了求出所有的$ans$，我们分两步做。

1. 计算$ans[i][i]$：

这个不难，只要暴力计算就行了。复杂度$O((\sqrt{n})^3)=O(n\sqrt{n})$。

2. 计算$ans[i][j](j>i)$

上面我们计算的$ans[i][i]$即将会用到！

我们假设我们已经求得了$ans[i][j-1]$的值，那么$ans[i][j]$的值就是$ans[i][j-1]+ans[j][j]$······

Wrong!

上面，我们相当于只计算了区间的左右端点（这里左右端点指“下面算法基于的技巧”中的$(i,j)$的二元组）都在$[\text{第i块，第j-1块}]$和都在$\text{第j块}$的情况，而很有可能左右端点并不在上述两个区间之中的同一个，可能左端点在$[\text{第i块，第j-1块}]$，而右端点在$\text{第j块}$。这种情况我们漏掉了。

那怎么计算呢？我们可以枚举上述2部分的其中一部分的所有元素，另一部分可以利用已经求得的$pre$来计算与之对应的元素的个数。

那么枚举那一部分呢？显然是第二部分。因为第二部分是一个块，最多$\sqrt{n}$个元素，而第一部分指不定有多少块呢。。复杂度$O(2(\sqrt{n})^3)=O(n\sqrt{n})$

$$ans[i][j]=ans[i][j-1]+ans[j][j]+\sum\limits_{p\in\text{第
j块}}(pre[j-1][s_p\oplus k]-pre[i-1][s_p\oplus k])$$

处理$ans$的算法大致明朗了，代码：

```cpp
for(register int i=1;i<=block;i++)
	for(register int j=(i-1)*B;j<=min(n,i*B-1);j++)
		for(register int p=j+1;p<=min(n,i*B-1);p++)
			if((s[j]^s[p])==k) ans[i][i]++;
for(register int i=1;i<=block;i++)
	for(register int j=i+1;j<=block;j++)
	{
		ans[i][j]=ans[i][j-1]+ans[j][j];
		for(register int p=(j-1)*B;p<=min(n,j*B-1);p++)
			ans[i][j]+=pre[j-1][s[p]^k]-pre[i-1][s[p]^k];
	}
```

预处理工作就这么愉快的结束啦！预处理总复杂度为$O(n\sqrt{n})$。

### 在查询时利用好预处理的信息

查询时，输入是$l,r$，但查询时我们要将$l$减一，方便处理。

那么查询怎么做呢？别急，我们暂且讨论一下如何在$O(\text{区间长度})$的时间内求得一个询问的答案。

定义$rec[i]$为数字$i$出现的次数。

#### 快速计算散块

我们先扫一边区间，并处理好$rec$。然后再扫一遍，扫到第$i$位的时候，先将$rec[s_i]$减一，再将$s_i\oplus k$的数的个数，即$rec[s_i\oplus k]$的值加到答案上即可。

代码：

```cpp
LL ret=0ll;
for(register int i=l;i<=r;i++)
	__rec[s[i]]++;
for(register int i=l;i<=r;i++)
	__rec[s[i]]--,ret+=__rec[s[i]^k];
return ret;
```

对于散块，或者$(l,r)$之间（ ***不包括两个端点，便于判断*** ）并没有整块的情况，我们直接这样暴力即可。

由于这两种情况扫描的长度不超过$2\sqrt{n}$，所以单次操作的复杂度为$O(\sqrt{n})$。

#### 包含整块的情况

这是本题的第二个难点。

当时智障的我：这不就散块暴力，中间直接取$ans$就行了嘛......

Wrong！

还是那个问题：我们不能保证左右端点都在（这里左右端点指“下面算法基于的技巧”中的$(i,j)$二元组）左散块或都在右散块或都在整块。

所以麻烦的来了：我们不仅要计算三个独立的块，还有以下三种情况：

- 左端点在左散块，右端点在整块

- 左端点在左散块，右端点在右散块

- 左端点在整块，右端点在右散块

不急，慢慢来。

> 以下使用$X$表示整块的第一块，用$Y$表示整块的最后一块。

1. 三个独立的部分：

左右散块像上面一样暴力，整块部分直接取$ans$。

2. 左端点在左散块，右端点在整块

我们枚举左散块的所有元素，枚举至$s_i$时，在整块中查找$s_i\oplus k$的个数加入答案，这可以利用$pre$数组轻松做到。

$\text{答案}+=\sum\limits_{p\in \text{左散块}}(pre[Y][s_p\oplus k]-pre[X-1][s_p\oplus k])$

3. 左端点在左散块，右端点在右散块

先扫一遍左散块的所有元素，记录好左散块中每个元素出现的次数，即$rec$数组。

然后枚举右散块的所有元素，枚举至$s_i$时，在左散块中查找$s_i\oplus k$的个数，即$rec[s_i\oplus k]$的值加入答案。

4. 左端点在整块，右端点在右散块

整块不好枚举，所以我们枚举右端点。其他的操作与情况2的处理方式基本相同。

$\text{答案}+=\sum\limits_{p\in \text{右散块}}(pre[Y][s_p\oplus k]-pre[X-1][s_p\oplus k])$

以上就是处理包含整块情况的查询的全部内容啦！

代码：

```cpp
int X=belong[l]+1,Y=belong[r]-1;
LL ret=0ll;
/*整块*/
ret+=ans[X][Y];
/*左散块*/
for(register int i=l;belong[l]==belong[i];i++)
	__rec[s[i]]++;
for(register int i=l;belong[l]==belong[i];i++)
	__rec[s[i]]--,ret+=__rec[s[i]^k];
/*右散块*/
for(register int i=r;belong[r]==belong[i];i--)
	__rec[s[i]]++;
for(register int i=r;belong[r]==belong[i];i--)
	__rec[s[i]]--,ret+=__rec[s[i]^k];
	
/*左散块 -> 右散块*/
for(register int i=l;belong[l]==belong[i];i++)
	__rec[s[i]]++;
for(register int i=r;belong[r]==belong[i];i--)
	ret+=__rec[s[i]^k];
for(register int i=l;belong[l]==belong[i];i++)
	__rec[s[i]]--;
	
/*左散块 -> 整块*/
for(register int i=l;belong[l]==belong[i];i++)
	ret+=pre[Y][s[i]^k]-pre[X-1][s[i]^k];
	
/*整块 -> 右散块*/
for(register int i=r;belong[r]==belong[i];i--)
	ret+=pre[Y][s[i]^k]-pre[X-1][s[i]^k];
return ret;
```

复杂度：还是取决于散块的最大长度，为$O(\sqrt{n})$

## 时空复杂度

再次注明：此处认为$n,m,k$同阶。

时间：$O(n\sqrt{n})$

空间：$O(n\sqrt{n})$（$pre$数组）

## 完整代码

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

inline int read(){int x=0,f=1;char c=getchar();while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}return f*x;}

const int N=1e5+5;
const int K=1e5+5;
const int B=150;
const int T=N/B+5;

int s[N];
int n,m;
int k;

namespace SqrtDiv
{
	typedef long long LL;
	int belong[N];
	int pre[T][K<<1];
	LL ans[T][T];
	int limits;
	int block; 
	
	inline void init()
	{
		memset(ans,0,sizeof(ans));
		memset(pre[0],0,sizeof(pre[0]));
		limits=*max_element(s,s+1+n);
		for(register int i=0,j=0;i<=n;i++)
		{
			if(i%B==0)
			{
				block=++j;
				for(register int val=0;val<=limits;val++)
					pre[j][val]=pre[j-1][val];
			}
			belong[i]=j,pre[j][s[i]]++;
		}
		for(register int i=1;i<=block;i++)
			for(register int j=(i-1)*B;j<=min(n,i*B-1);j++)
				for(register int p=j+1;p<=min(n,i*B-1);p++)
					if((s[j]^s[p])==k) ans[i][i]++;
		for(register int i=1;i<=block;i++)
			for(register int j=i+1;j<=block;j++)
			{
				ans[i][j]=ans[i][j-1]+ans[j][j];
				for(register int p=(j-1)*B;p<=min(n,j*B-1);p++)
					ans[i][j]+=pre[j-1][s[p]^k]-pre[i-1][s[p]^k];
			}
	}
	
	int __rec[K<<1];
	inline LL query(int l,int r)
	{
		LL ret=0ll;
		if(belong[r]-belong[l]<=1)
		{
			for(register int i=l;i<=r;i++)
				__rec[s[i]]++;
			for(register int i=l;i<=r;i++)
				__rec[s[i]]--,ret+=__rec[s[i]^k];
			return ret;
		}
		int X=belong[l]+1,Y=belong[r]-1;
		
		/*整块*/
		ret+=ans[X][Y];
		/*左散块*/
		for(register int i=l;belong[l]==belong[i];i++)
			__rec[s[i]]++;
		for(register int i=l;belong[l]==belong[i];i++)
			__rec[s[i]]--,ret+=__rec[s[i]^k];
		/*右散块*/
		for(register int i=r;belong[r]==belong[i];i--)
			__rec[s[i]]++;
		for(register int i=r;belong[r]==belong[i];i--)
			__rec[s[i]]--,ret+=__rec[s[i]^k];
			
		/*左散块 -> 右散块*/
		for(register int i=l;belong[l]==belong[i];i++)
			__rec[s[i]]++;
		for(register int i=r;belong[r]==belong[i];i--)
			ret+=__rec[s[i]^k];
		for(register int i=l;belong[l]==belong[i];i++)
			__rec[s[i]]--;
			
		/*左散块 -> 整块*/
		for(register int i=l;belong[l]==belong[i];i++)
			ret+=pre[Y][s[i]^k]-pre[X-1][s[i]^k];
			
		/*整块 -> 右散块*/
		for(register int i=r;belong[r]==belong[i];i--)
			ret+=pre[Y][s[i]^k]-pre[X-1][s[i]^k];
		return ret;
	}
}

signed main()
{
	n=read(),m=read(),k=read();
	for(register int a,i=1;i<=n;i++)
		a=read(),s[i]=s[i-1]^a;
	SqrtDiv::init();
	while(m--)
	{
		int l=read()-1,r=read();
		printf("%lld\n",SqrtDiv::query(l,r));
	}
	return 0;
}
```

## 注意事项

- $ans$数组记得开```long long```。

- 注意询问时要将$l$减一，预处理时从0开始。

- 虽然原数字中的元素不超过$10^5$，但是$\oplus$之后可能会超过这个值。$10^5$的二进制是```1 1000 0110 1010 0000‬```，共17位，值域应该开到$2^{18}$，也就是```1<<18```。这里直接开到了$2\times 10^5$。

- 注意暴力计算散块时，$rec[s_i]$要先减去一再加入答案。最后清空$rec$时不能草率地```memset```，因为这样时$O(n)$的复杂度会原地爆炸。应当怎么加过来，怎么减回去，具体操作上面的代码有所体现。

## 未考虑到的问题

### 块的大小，真的最好是$\sqrt{n}$吗？

有人已经发现了：上面代码中块的大小我调小了。

如果把块的大小设成$\sqrt{n}$，即$\sqrt{10^5}\approx 316$，那么只能拿到70pts：https://www.luogu.com.cn/record/30177145

这是咋回事呀？？

观察以下我们的算法，会发现预处理做的干净利落，但询问有一坨循环，虽说复杂度正确，但常数还是有点大。减少询问时间的方式就是减小块长。（效率只与块长有关的说法并不正确，因为预处理的第一步就是$\text{块的数量}\times k$，更正一下。）

因此我调小了块的大小（150），虽然空间需求大了，但是果然快了不少：https://www.luogu.com.cn/record/30185458

注：块的大小为200时开O2才可以过。

### 是否存在更高效的算法

双倍经验：[CF617E XOR and Favorite Number](https://www.luogu.com.cn/problem/CF617E)

然而这份代码过不了。。。

上面，我们假设$n,m,k$同阶，但这里不行，因为值域$k\le 10^6$。这样复杂度就是$O((m+k)\sqrt{n})$，非常的菜。而且$pre$数组也是关于值域$k$的，直接$MLE$了。

难道就只有莫队可解了吗？对此本人持怀疑的态度。如果强大的你找到了更好的分块（可以是线段树）方法，欢迎私信（或评论）。

-----------------------

### 后记

wtcl这一题调了半天。。。

码字不易，留个赞叭QwQ。

[$\colorbox{yellow}{\texttt{cnblogs:https://www.cnblogs.com/-Wallace-/}}$](https://www.cnblogs.com/-Wallace-/)

[$\colorbox{greenyellow}{\texttt{luogu blog:https://strncmp.blog.luogu.org/}}$](https://strncmp.blog.luogu.org/)

---

## 作者：Deamer (赞：50)

## 闲话：

- 在这篇题解中你会看到一些题解被 hack。

- 在这篇题解中你会知道 Del 和 Add 函数正确顺序和一些难理解东西的原理。

- 在这片题解中你会看见很多作者自己踩过的坑。

## 正文：

我们可以维护异或前缀和，那么 $l$ 到 $r$ 的异或和就为 $a_l-1 \bigoplus  a_r$，问题就变成了询问区间 $[l-1 , r]$ 中，有多少对 $l$ 和 $r$ 满足 $a_{l-1} \bigoplus  a_r = k$。

我们对于每个值，用莫队维护它出现的次数和在它**之前**满足与这个值异或起来为 $k$ 的数的个数，添加或删除点时答案对应加上或减去维护的个数即可。

## Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long 
const int N=1e5+10,M=2e5+10;
int n,m,c;
int a[N];
struct Query { int l,r,id; } q[N];
int block;
int bel[N];
ll sum;
int tot[M];
ll ans[N];

bool cmp(Query a,Query b){
	return (bel[a.l]^bel[b.l]) ? bel[a.l]<bel[b.l] : ( (bel[a.l]&1) ? a.r<b.r : a.r>b.r ) ;
}

void Build(){
	block=pow(n,2.0/3.0);
	for(int i=1;i<=n;i++) bel[i]=(i-1)/block+1;
}

void Add(int x) { sum+=tot[a[x]^c]; tot[a[x]]++; }

void Del(int x) { tot[a[x]]--; sum-=tot[a[x]^c]; }

int main(){
	scanf("%d%d%d",&n,&m,&c);
	Build();
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1;i<=n;i++) a[i]^=a[i-1];
	for(int i=1;i<=m;i++){
		scanf("%d%d",&q[i].l,&q[i].r);
		q[i].id=i;
	}
	sort(q+1,q+1+m,cmp);
	tot[0]=1;
	int l=0,r=0;
	for(int i=1;i<=m;i++){
		int ql=q[i].l-1,qr=q[i].r,id=q[i].id;
		while(l<ql) Del(l++);
		while(l>ql) Add(--l);
		while(r<qr) Add(++r);
		while(r>qr) Del(r--);
		ans[id]=sum;
	}
	for(int i=1;i<=m;i++) printf("%lld\n",ans[i]);
	return 0;
}
```

说几个坑点和不好理解的点吧 : 

1. ```tot[0]=1``` : 由于询问是对于区间 $[l-1,r]$ 的，所以询问范围为 $[0,n]$，又因为 $a_0=0$，所以要写上这句话，不然对于异或前缀和为 $k$ 的位置，显然有一个合法区间 $[1,x]$，其所对应的 $l$ 为 $0$，但由于 $tot_0=0$，没有统计答案。

2. ```l=0``` : 由于询问范围为 $[0,n]$，自然 $l$ 初始值为 $0$ （这个 shaber 因为这个调了半天）。

3. ```ql=q[i].l-1``` : 由于询问是对于区间 $[l-1,r]$。

4. ```void Add(int x) { sum+=tot[a[x]^c]; tot[a[x]]++; }``` : 由于询问是对于区间 $[l-1,r]$ 的，且 $l≤r$，所以在异或前缀和数组中这一定是两个位置，如果先写第二句话的话，当 $k=0$ 时，$sum$ 在统计答案时会会把当前位置算进当前位置的答案中加上，显然不合法，于是多算答案。

5. ```void Del(int x) { tot[a[x]]--; sum-=tot[a[x]^c]; }``` : 其实大致思路同上一条，由于询问是对于区间 $[l-1,r]$ 的，且 $l≤r$，所以在异或前缀和数组中这一定是两个位置，如果先写第二句话的话，当 $k=0$ 时，$sum$ 在统计答案时会把当前位置算进当前位置的答案中减去，显然不合法，于是少算答案。

6. ```tot[200010]``` 由于异或前缀和可能大于 $n$，最大值为 $2^{17}-1=131071$，故开这么大。

7. $l$ 和 $r$ 的加减与 Add 和 Del 的先后循序 : 删除是删除当前位置，故先 Del 再加减，添加是添加下一个位置，故先加减再 Add （这应该没人错吧 qwq )。

8. 由于是区间数量，记得开 ```long long```。

**对于上文第五条错误 $hack$ :**
```
2
```

```
4 1 0
0 1 0 1
2 4
```

正确输出 : 

```
2
```

错误输出 : 

```
1
```
**对于上文第八条错误 hack : (叉了6篇)**
```
2
```

```
100000 1 0
(100000个0)
1 100000
```

正确输出 : 

```
5000050000

```

错误输出 : 

```
705082704

```
数组越界应该不用我说怎么卡了吧 qwq （其实我也不会

**有错误请及时回复或私信我，谢谢啦！**

**写在最后：希望被 hack 的题解不要只改了代码，不写明原理，只是说 “脑抽了” 之类的话。**

Upd : 11.22 改了评论区指出的错误

---

## 作者：shadowice1984 (赞：11)

数据结构学傻了导致看到这道题只想着线段树……

其实是莫队的，$O(N\sqrt{N})$的复杂度可以毫不费力的通过$O(10^5)$的数据范围

不会莫队的话请出门左转小Z的袜子……包教包会

然后这里介绍一个比较好写的莫队写法，我们单独考虑挪动左端点和右端点的情况
，这样的话就不需要讨论两个区间的重叠情况了，然后插入的时候是前++，--，删除的时候是后++，--，因为我们必须保证当前的左端点，右端点是已经存在的点而不是别的东西……

但是我们会发现这样的话会在两个区间完全没有交点的时候多删除一些点或者多插入一些点，而这在某些题里面是不允许的(尽管这道题里面正的点和负的点会消掉但是有些题不允许)所以我们直接特判下两个区间不重叠的情况然后重构整个区间就可以了

对于莫队的具体做法就是先预处理出来异或前缀和，方便求区间异或值

然后我们维护一个当前区间里每个值有多少个数，然后插入的时候求一下这个区间里有多少个值为k^a\[r]的数就可以了，注意插入的时候先处理答案后插入点，删除的时候先删除点后处理答案即可。

然后代码会非常的好写~

```C
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;const int N=1e5+10;typedef long long ll;
int bs;int n;int m;int k;int val[N];ll nowans;int nl;int nr=-1;
struct query{int p;int l;int r;ll ans;}q[N];int a[N];
inline bool cmp1(const query& a,const query& b){return a.l>b.l;}
inline bool cmp2(const query& a,const query& b){return a.r<b.r;}
inline bool cmp3(const query& a,const query& b){return a.p<b.p;}
int main()
{
    scanf("%d%d%d",&n,&m,&k);bs=sqrt(m);
    for(int i=1;i<=n;i++){scanf("%d",&a[i]);a[i]^=a[i-1];}//离线 
    for(int i=1,l,r;i<=m;i++){scanf("%d%d",&l,&r);q[i]=(query){i,l-1,r,0};}//对询问分块 
    sort(q+1,q+m+1,cmp1);for(int i=1;i<=m;i+=bs){sort(q+i,q+min(i+bs,m+1),cmp2);}
    for(int i=1;i<=m;i++)
    {
        if(nr<q[i].l)//判一下区间重叠 
        {
            for(int p=nl;p<=nr;p++){val[a[p]]--;}nowans=0;nl=q[i].l;nr=q[i].r;
            for(int p=nl;p<=nr;p++){nowans+=val[k^a[p]];val[a[p]]++;}
        }
        else //单独考虑左端点和右端点就好了~ 
        {
            for(;nl<q[i].l;){val[a[nl]]--;nowans-=val[k^a[nl++]];}
            for(;nl>q[i].l;){nowans+=val[k^a[--nl]];val[a[nl]]++;}
            for(;nr>q[i].r;){val[a[nr]]--;nowans-=val[k^a[nr--]];}
            for(;nr<q[i].r;){nowans+=val[k^a[++nr]];val[a[nr]]++;}
        }q[i].ans=nowans;
    }sort(q+1,q+m+1,cmp3);
    for(int i=1;i<=m;i++){printf("%lld\n",q[i].ans);}return 0;//拜拜程序~ 
}
```


---

## 作者：Watanabe (赞：2)

好不容易有道一发过的莫队，发个题解纪念一下，~~虽然是简单题~~

我们首先注意到 $k$ 是定值，而本题又没有修改，所以直接考虑莫队，~~毕竟莫队比分块好写点~~

考虑加入一个数会造成什么样的贡献：

从左边加入的话相当于就是这个数作为左端点，而右端点在当前维护区间里的一个子区间的异或和为 $k$，那么我们就直接维护当前区间的后缀异或数组，加入的话利用 $x \oplus y=k$ 等价于 $x \oplus k=y$，直接开个桶记录后缀值就好。

从右边加入同理，只不过相当于查询前缀。

删除一个数同理，不过需要注意的是我们在加入时需要考虑当前数自己的贡献，删除的时候不用，可以自己想想为什么。

注意：我们维护的前缀要维护当前插入位置的前一个，这是因为 $l$ 到 $r$ 的区间异或和其实等价于 $s_r \oplus s_{l-1}$ ，维护后缀则维护当前位置的后一个，方便查询。

code:

```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define re register
#define int long long

using namespace std;
const int N=1e5+100,M=1ll<<21;
int n,a[N],sr[N],sl[N],k,Q;
struct Node{
	int l,r,id;
}q[N];

//
int m,belong[N];
inline void init()
{
	m=sqrt(n);
	for(re int i=1;i<=n;++i) belong[i]=(i-1)/m+1;
	for(re int i=1;i<=n;++i) sl[i]=sl[i-1]^a[i];//前缀
	for(re int i=n;i;--i) sr[i]=sr[i+1]^a[i];//后缀 
}
inline bool cmp(Node A,Node B)
{
	if(belong[A.l]==belong[B.l]) return A.r<B.r;
	return A.l<B.l;
}
int l=1,r,nw,ans[N];
int tl[M],tr[M];//前缀，后缀 
inline void addl(int x)
{
	nw+=tr[k^sr[x]];
	tl[sl[x-1]]++,tr[sr[x+1]]++;
	if((k^sr[x])==sr[x+1]) ++nw;
}
inline void addr(int x)
{
	nw+=tl[k^sl[x]];
	tl[sl[x-1]]++,tr[sr[x+1]]++;
	if((k^sl[x])==sl[x-1]) ++nw;
}
inline void dell(int x)
{
	nw-=tr[k^sr[x]];
	//cout<<x<<" "<<r<<" "<<tr[k^sr[x]]<<" "<<sr[x]<<"\n";
	tl[sl[x-1]]--,tr[sr[x+1]]--;
}
inline void delr(int x)
{
	nw-=tl[k^sl[x]];
	tl[sl[x-1]]--,tr[sr[x+1]]--;
}
signed main()
{
	cin>>n>>Q>>k;
	for(re int i=1;i<=n;++i) cin>>a[i];
	for(re int i=1;i<=Q;++i)
	{
		cin>>q[i].l>>q[i].r;
		q[i].id=i;
	}
	init();
	sort(q+1,q+Q+1,cmp);
	for(re int i=1;i<=Q;++i)
	{
		int ql=q[i].l,qr=q[i].r;
		while(l>ql) addl(--l);
		while(r<qr) addr(++r);
		while(l<ql) dell(l++);
		while(r>qr) delr(r--);
		ans[q[i].id]=nw;
	}
	for(re int i=1;i<=Q;++i) cout<<ans[i]<<"\n";
	return 0;
}
```


---

## 作者：Moon_Wind (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P4462)



------------

**题意简述**：

给定一个长度为 $n$ 的序列和一个数 $k$，给出 $m$ 次询问，每次询问某个区间中有多少个子区间的异或和为 $k$。

**算法分析**：

看见区间询问，就可以想到处理前缀。对于一个没有修改的区间询问问题，我们可以使用莫队，如果不知道莫队的，请移步[P2706](https://www.luogu.com.cn/problem/P2709)。

先预处理一下前缀异或和，因为异或本身就是异或的逆运算，所以当 $sum_x\bigoplus sum_{op}=k$ 时 $sum_x=k\bigoplus sum_{op}$，那么我们在处理每一次查询时计算出当前区间满足 $sum_x=sum_{op}\bigoplus k$ 的 $x$ 的个数，然后根据这个数来更新 $op$ 即可。

**注意事项**：

左端点要减去 $1$，要开 `long long`。

**代码部分**：



------------
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,m,k,len,t[500001],q[50001];
ll ans[500001],opp[100001],sum=0;
struct node{
	int l,r,id;
}a[500001];
bool cmp(node a,node b){
	if(a.l/len==b.l/len) return a.r<b.r;
	return a.l<b.l;
}
void add(int op){
	sum+=t[opp[op]^k];
	t[opp[op]]++;
	return;
}//把板子拿过来改改就行。
void sub(int op){	
	t[opp[op]]--;
	sum-=t[opp[op]^k];
	return;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n>>m>>k;
	len=n/int(sqrt(n));
	for(int i=1;i<=n;i++) cin>>q[i],opp[i]=opp[i-1]^q[i];
        //异或前缀和。
	for(int i=1;i<=m;i++){
		cin>>a[i].l>>a[i].r;
		a[i].l--;
		a[i].id=i; 
	}
	sort(a+1,a+m+1,cmp);
	int l=1,r=0;
	for(int i=1;i<=m;i++){
		while(l<a[i].l){
			sub(l);
			l++;
		}
		while(l>a[i].l){
			l--;
			add(l);
		}
		while(r>a[i].r){
			sub(r);
			r--;
		}
		while(r<a[i].r){
			r++;
			add(r);
		}
		ans[a[i].id]=sum;
	}//莫队基础操作。
	for(int i=1;i<=m;i++) cout<<ans[i]<<endl;
	return 0;
} 
```


------------


---

## 作者：CNS_5t0_0r2 (赞：1)

本文同步发表于 [cnblogs](https://www.cnblogs.com/5002-qwq/p/18120911)。

注：下文中的所有 $\oplus$ 均表示两数按位异或。

对于所有询问，和普通莫队一样的分块然后排序。在这里只讨论 ``add`` 和 ``del`` 操作的具体实现。

题目中需要求一段区间的异或值，所以我们可以预处理序列 $a$ 的“前缀异或值”``pre_xor``，题目中的 $a_x \oplus a_{x+1} \oplus \dots \oplus a_y$ 可利用异或的性质转化为 ``pre_xor[y] ^ pre_xor[x - 1]``。

这样，求区间 $[l,r]$ 中能够满足 $a_x \oplus a_{x+1} \oplus \dots \oplus a_y = k$ 的 $x,y$ 有多少组，就相当于求区间 $[l - 1,r]$ 中有多少组 ``pre_xor[y] ^ pre_xor[x - 1] == k``。这就可以用莫队了。

显然，设 ``cnt[x]`` 代表数 $x$ 的出现次数，则其可以与所有的 $x \oplus k$ 配对即可。显然，在这里的 $x$ 和 $x \oplus k$ 一般是不用担心顺序的，总贡献为 ``cnt[x] * cnt[x ^ k]``。

不过有一个特殊情况：当 $k = 0$ 时，$x = x \oplus k$，这个时候就得特判贡献为 ``(cnt[x] * (cnt[x] - 1)) >> 1`` 了。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e5 + 9,M = 1e5 + 9,SqrtN = 339,K = 1 << 20;
int n,m,k;
struct block{
	int l,r;
} b[SqrtN];
int belong[N];
int block_len,block_cnt;
void build_block(){
	block_len = block_cnt = (int)sqrt(n);
	for(int i = 1;i <= block_cnt;i++){
		b[i].l = b[i - 1].r + 1;
		b[i].r = i * block_len;
	}
	b[block_cnt].r = n;
	for(int i = 1;i <= block_cnt;i++)
		for(int j = b[i].l;j <= b[i].r;j++)
			belong[j] = i;
}
struct queries{
	int l,r,id;
} q[M];
int a[N],pre_xor[N];
int cnt[K];
int ans[M],tmp;
int lres = 1,rres;
bool cmp(queries q1,queries q2){
    return belong[q1.l] == belong[q2.l] ? belong[q1.r] < belong[q2.r] : belong[q1.l] < belong[q2.l];
}
void add(int x){
	tmp -= k ? (cnt[x] * cnt[x ^ k]) : ((cnt[x] * (cnt[x] - 1)) >> 1);
	cnt[x]++;
	tmp += k ? (cnt[x] * cnt[x ^ k]) : ((cnt[x] * (cnt[x] - 1)) >> 1);
}
void del(int x){
	tmp -= k ? (cnt[x] * cnt[x ^ k]) : ((cnt[x] * (cnt[x] - 1)) >> 1);
	cnt[x]--;
	tmp += k ? (cnt[x] * cnt[x ^ k]) : ((cnt[x] * (cnt[x] - 1)) >> 1);
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin >> n >> m >> k;
	build_block();
	for(int i = 1;i <= n;i++){
		cin >> a[i];
		pre_xor[i] = pre_xor[i - 1] ^ a[i];
	}
	for(int i = 1;i <= m;i++){
		cin >> q[i].l >> q[i].r;
		q[i].id = i;
	}
	sort(q + 1,q + m + 1,cmp);
    for(int i = 1;i <= m;i++){
        int L = q[i].l - 1,R = q[i].r;
        while(lres > L)
            add(pre_xor[--lres]);
        while(rres < R)
            add(pre_xor[++rres]);
        while(lres < L)
            del(pre_xor[lres++]);
        while(rres > R)
            del(pre_xor[rres--]);
        ans[q[i].id] = tmp;
    }
	for(int i = 1;i <= m;i++)
		cout << ans[i] << '\n';
	return 0;
}
```

---

## 作者：JuRuoOIer (赞：1)

# 题解 P4462 [CQOI2018] 异或序列

### 前排提示

本题解为**莫队**做法，且认为读者已经学过了莫队算法。

传送门：[本题](https://www.luogu.com.cn/problem/P4462) [双倍经验（注意值域不同）](https://www.luogu.com.cn/problem/CF617E)

双倍经验中的中文题意很清楚，故此处不再赘述。

### 做法

区间查询，而且**只有查询**，直接想到莫队。

但莫队希望 $O(1)$ 地移动当前区间的左端点或右端点，而暴力地移动却是 $O(n^2)$ 的（枚举另一个端点并求出异或和），因此目标就是优化这个过程。

如果原题目要求的是求和而不是求异或和，那显然可以前缀和优化掉一个 $n$。找找规律，发现异或具有结合律（$a\oplus b\oplus c=a\oplus(b\oplus c)$），而且异或的逆运算也是异或（$a\oplus b=c\Leftrightarrow c\oplus a=b$），那就意味着也能像求前缀和一样求前缀异或和了。

现在考虑优化掉枚举端点的那个 $n$。我们暴力枚举（假设是左）端点时，如果当前位于 $r$，前缀异或和为 $s$，则判断一个左端点 $l$ 是否合法，显然需要判断 $s_r\oplus s_{l-1}$ 是否等于 $k$。而刚才说了，异或的逆运算就是异或，所以变成了判断 $s_r\oplus k$ 是否等于 $s_{l-1}$。此时注意到值域不大，所以开个桶 $t$ 存当前区间每一个位置的前缀异或和，每次找 $t_{s_r\oplus k}$ 的值就行了。

这样左端点或右端点移动一格就可以用 $O(1)$ 的时间完成，总复杂度 $O(n\sqrt{n})$。

最后，两处易错的细节：
- 加入一个数时先更新答案再更新桶，删除时先更新桶再更新答案。原因：
  - 当 $k=0$ 时，如果先插入再更新答案，那么贡献将会把插入的这个位置也算上去；
  - 同理，删除时如果先更新答案再删除，也会把删除的这个位置也算上去。
  - 而 $[l,r]$ 的异或和为 $s_{l-1}\oplus s_r$，因此 $l-1$ 不能等于 $r$，即一个位置不能给它自己提供贡献。
- 由于用前缀异或和求区间异或和是 $s_{l-1}\oplus s_r$，所以每次查询区间的 $l$ 要减 $1$。

### 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define lf double
#define ld long double
using namespace std;
struct node{
	ll l,r,ans,rk;
};
ll n,m,k,l,r,ans,a[100010],qzh[100010],bel[100010],t[2000010];
node q[100010];
bool cmp(node x,node y){
	return bel[x.l]==bel[y.l]?x.r<y.r:x.l<y.l;
}
bool cmprk(node x,node y){
	return x.rk<y.rk;
}
int main(){
	cin>>n>>m>>k;
	ll len=sqrt(n);
	for(int i=1;i<=n;i++){
		cin>>a[i];
		qzh[i]=qzh[i-1]^a[i];
		bel[i]=(i-1)/len;
	}
	for(int i=0;i<m;i++){
		cin>>q[i].l>>q[i].r;
		q[i].l--;
		q[i].rk=i;
	}
	sort(q,q+m,cmp);
	l=2;r=1;
	for(int i=0;i<m;i++){
		while(l<q[i].l){
			t[qzh[l]]--;
			ans-=t[qzh[l]^k];
			l++;
		}
		while(l>q[i].l){
			l--;
			ans+=t[qzh[l]^k];
			t[qzh[l]]++;
		}
		while(r<q[i].r){
			r++;
			ans+=t[qzh[r]^k];
			t[qzh[r]]++;
		}
		while(r>q[i].r){
			t[qzh[r]]--;
			ans-=t[qzh[r]^k];
			r--;
		}
		q[i].ans=ans;
	}
	sort(q,q+m,cmprk);
	for(int i=0;i<m;i++){
		cout<<q[i].ans<<endl;
	}
	return 0;
}
···

---

## 作者：Siegerkranz_2735 (赞：1)

### 简化题意

给定一个大小为 $n$ 的序列和一个数字 $k$，再给出 $m$ 组询问，询问给出一个区间，这个区间里面有多少个区间的异或结果为 $k$。

### 分析

首先，既然有区间就会想到处理前缀。对于一个不强制在线的多个区间询问的问题，我们可以考虑莫队。（或者我们可以直接看标签）

在处理每个查询时计算出当前区间内满足 $sum_x = sum_{new} \oplus k$ 的 $x$ 的个数，然后根据这个数来更新 $now$，从而达到优化计算的目的。

### 注意：

左端点一定要 $-1$，同时数组要开够，蒟蒻在这里被坑了。

最后不难得到如下代码：

```cpp
#include<bits/stdc++.h>
#define N 100010
using namespace std;
long long n,m,a[N],cnt[10000010],belong[N],k;
struct Cmd{int l,r,id;}cmd[N];
long long L=1,R=0,now=0,ans[N];
bool cmp(Cmd x,Cmd y){
    if(belong[x.l]!=belong[y.l]) return belong[x.l]<belong[y.l];
    return x.r<y.r;
}
void add(int p){now+=cnt[a[p]^k],cnt[a[p]]++;}
void remove(int p){cnt[a[p]]--,now-=cnt[k^a[p]];}
int main(){
    scanf("%lld%lld%lld",&n,&m,&k);
    for(int i=1;i<=n;i++)scanf("%lld",&a[i]),a[i]=a[i-1]^a[i];
    int s=sqrt(n);
    for(int i=1;i<=n;i++)belong[i]=(i-1)/s+1;
    for(int i=1;i<=m;i++){
        scanf("%d%d",&cmd[i].l,&cmd[i].r);
        cmd[i].id=i,cmd[i].l--;
    }
    sort(cmd+1,cmd+m+1,cmp);
    for(int i=1;i<=m;i++){
        for(;L<cmd[i].l;remove(L++));
        for(;R>cmd[i].r;remove(R--));
        for(;L>cmd[i].l;add(--L));
        for(;R<cmd[i].r;add(++R));
        ans[cmd[i].id]=now;
    }
    for(int i=1;i<=m;i++) printf("%lld\n",ans[i]);
    return 0;
}
```


代码中的 $add$ 函数和 $remove$ 函数用于维护异或和的计算。$cnt$ 数组用于记录每个异或值出现的次数，$belong$ 数组用于标记元素属于哪个块。通过逐个移动左右指针，更新 $now$ 变量，可以高效地计算每个查询的结果。

---

## 作者：zhangbo1000 (赞：0)

update 2024.3.21 重新提交以去除旧博客分类。

~~蒟蒻也想写有意思的开头，可惜十天过去了，它依旧没有这种能耐。~~

### 1. 算法

很容易发现，$l\sim r$ 区间的异或和可以用前缀和优化，具体地，令 $s_i=a_1\oplus a_2 \oplus a_3\oplus\cdots\oplus a_{i-1}\oplus a_i$，则有 $a_l\oplus a_{l+1}\oplus \cdots \oplus a_{r}=s_{l-1}\oplus s_r$，于是问题就转化为了：

* **在给定的区间 $[l,r]$ 中，求有多少对 $x,y\in[l,r]$，使 $s_{x-1}\oplus s_{y}=k$。**

~~闲话：做过的可能已经发现这题跟 [P1494 小 Z 的袜子](https://www.luogu.com.cn/problem/P1494)很像了。~~

接下来，我们为了方便讨论和写，不妨将所有 $l\gets l-1$，这样统计 $s_{x}\oplus s_{y}=k$，就~~好看~~方便多了。

仔细看题，$n\le 10^5$，那么 $\Theta(n\sqrt{n})$ 的算法可过，而且是很单纯的区间统计，那么我们就可以用莫队解决。

怎么莫队关键在于加入一个以及删除一个数对答案的贡献（虽然实际上可用**回滚莫队**解决只加不删和只删不加，但很多题用不到。）。

这道题中，由 $s_x\oplus s_y=k$ 可知 $s_x\oplus k=s_y$，故我们可用一个专门的数组 $q$ 来记录之前出现的数，具体地 $q_i $ 表示 $i$ 出现的次数，那么由于加入一个数 $x$ 时，它与之前统计的区间中每个 $k\oplus x$，都能成对，故对答案的贡献为 $q_{x\oplus k}$ ，之后再使 $q_x\gets q_{x}+1$，注意两者更新顺序，即使 $x\oplus k =x$，也不能计算 $x$ 对自身的贡献，因为按照我们的定义，$s_l\oplus s_r$ 表示的是区间 $[l+1,r]$ 的异或和，所以这里的 $l\le r-1$，自然不能统计 $l=r$ 的答案。

删除就是把添加反过来，先 $q_x\gets q_x-1$，再减去对答案的贡献。

(其实这里在数学上是说的通的，毕竟 $x\oplus k=x$ 说明 $k=0$，统计 $[r+1,r]$ 就是把空集算进去了，但题目肯定不能这么做。)

显然，这样弄移动左右端点的复杂度是 $\Theta(1)$，因此总复杂度为 $\Theta(n\sqrt{n})$，可通过此题。

### 2. 优化

快速读入不必多说，部分题常数优化蛮大的。

```cpp
inline void read(int& x){
	x=0;
	char c;
	while((c=getchar())<'0');
	while(c>='0')x=(x<<3)+(x<<1)+(c^'0'),c=getchar();
}
```

奇偶化排序是莫队的特有形式和独特优势。~~写的时候差点以为 zzmg，仔仔细细读了半天才发现和政治课本上的话没有直接联系。~~具体的，如果我们对相邻的两个块（编号必然一奇一偶，即所谓的“奇偶化”。）一个右端点从小到大，另一个从大到小，那么右端点在到达一个块的最大值后，立刻要变到的是另一个块的最大值，最坏常数比直接从小到大排小大约 $\frac{1}{3}$，还是很明显的，[部分题](https://www.luogu.com.cn/problem/CF1000F)甚至必须加才能用莫队过。

### 3. 代码

注释没加，当然除非你是直接下拉到这的应该都能看懂。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<bitset>
#include<vector>
using namespace std;
#define N 100010
#define B 500
inline void read(int& x){
	x=0;
	register char c;
	while((c=getchar())<'0');
	while(c>='0')x=(x<<3)+(x<<1)+(c^'0'),c=getchar();
}
struct uke{
	int l,r,ind,kuai;
}ask[N];
bool operator<(const uke& x,const uke& y){
	return x.kuai==y.kuai?x.r<y.r:x.kuai<y.kuai;
}
int a[N],q[N*2];
long long ans[N];
int main(){
	q[0]=1;
	int n,m,k;
	read(n);
	read(m);
	read(k);
	for(int i=1;i<=n;i++){
		read(a[i]);
		a[i]^=a[i-1];
	}
	for(int i=1;i<=m;i++){
		read(ask[i].l);read(ask[i].r);
		ask[i].kuai=ask[i].l/B;
		ask[i].ind=i;
	}
	sort(ask+1,ask+1+m);
	register int i=0,j=0;
	register long long now=0;
	for(int x=1;x<=m;x++){
		const int &l=ask[x].l-1,&r=ask[x].r;
		while(i>l){
			now+=(q[a[--i]^k]);
			q[a[i]]++;
		}
		while(j<r){
			now+=(q[a[++j]^k]);
			q[a[j]]++;
		}
		while(i<l){
			q[a[i]]--;
			now-=(q[a[i++]^k]);
		}
		while(j>r){
			q[a[j]]--;
			now-=(q[a[j--]^k]);
		}
		ans[ask[x].ind]=now;
	}
	for(i=1;i<=m;i++)printf("%lld\n",ans[i]);
	return 0;
}
```

注意，$(10^5)^2>2^{32}$，记得开 ```long long```。

---

## 作者：_zuoqingyuan (赞：0)

# 题意简述

[传送门。](https://www.luogu.com.cn/problem/P4462)

给定一个长度为 $n$ 的序列 $a$，有 $m$ 个询问，每次给出一个区间 $[L,R]$，求出区间内有多少个子区间异或和为指定的 $k$。

数据范围：$1\le n,m,a_i,k\le 10^5$。

# 思路分析

前置知识：[莫队。](https://oi-wiki.org/misc/mo-algo/)

在此之前，我们要先知道异或运算是个什么东西：就是将两个二进制数的最低位对其，依次比较两个二进制数的每一位，如果相同，则得到的结果为 $0$，不同则为 $1$。

从定义可以推导出来的结论：对于任意 $x$，都有 $x\oplus x=0$，应为两个相同的数二进制上每一位都相同，所以结果一定为 $0$，同理可以推出 $x\oplus 0=x$。这里不多做叙述。（$\oplus$ 为异或的运算符号）

我们定义 $s_i=a_1\oplus a_2\oplus\dots\oplus a_i $。显然 $a_l\oplus a_{l+1}\oplus\dots\oplus a_r=s_r\oplus s_{l-1}$。基于的原理便是 $x\oplus x=0$。应为 $s_r,s_{l-1}$ 都包含 $s_{l-1}$ 这个部分，所以相抵消，只剩下 $[l,r]$ 这部分的异或和。

根据异或的定义，我们可以很方便的推出：如果 $a\oplus b=k$，那么 $a\oplus k=b,b\oplus k=a$。

结论部分讲解完毕，让我们回到题面，注意到是区间静态问题，不要求强制在线，显然可以用莫队乱搞。

我们在上文提到 $s_r\oplus s_{l-1}$ 即为 $[l,r]$ 区间的异或和。可以将问题转化为：每次给出区间 $[L,R]$，求出 $\sum\limits_{L-1\le i,j\le R}[s_i\oplus s_j=k]$。我们可以开一个桶 $cnt$，$cnt_{s_i}$ 为当前区间中，$s_i$ 的个数。当前区间异或和为 $k$ 的子区间数量为 $ans$。

如果有 $s_i\oplus s_j=k$，那么必然 $s_i\oplus k=s_j$。如果当前区间左右边界移动时，区间内多了一个 $s_i$，那么该区间内所有的 $s_j$ 与其的异或和是 $k$，区间内 $s_j$ 的数量为 $cnt_{s_j}$，所以对当前区间答案的贡献为 $cnt_{s_j}$。在将 $cnt_{s_i}+1$。我们就完成了区间的扩张。

已知 $s_i,k$，如何快速找到 $s_j$ 使得 $s_i\oplus s_j=k$。根据异或运算的性质 $s_j=s_i\oplus k$。

# 坑点大全：
1. 因为询问是区间 $[L,R]$，而处理时会将 $L-1$。所以会出现左边界为 $0$ 的情况。因此莫队中两个指针的初始位置都是 $0$.

2. 初始情况下，区间包含 $s_0=0$，所以 $cnt_0$ 初值为 $1$。

3. 当 $k=0$ 时，对于任何 $a$ 都有 $a\oplus 0=a$。因此在删除时，应当先对 $cnt$ 操作，再对答案 $ans$ 操作（我 WA 了好几次）。

4. 虽然 $a_i$ 小于 $10^5$，但如果 $a_1=100000,a_2=31071$，$s_2$ 有最大值为 $377777$。所以 $cnt$ 的大小一定要把控好（好像数据不卡这个）。

莫队是什么大家应该也知道吧，~~毕竟我都讲完了。~~

# Code
码风不好，勿抄。
```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>
using namespace std;
const int N=4e5+10;
typedef long long ll;
ll n,m,k,a[N],t,cnt[N],ans,ql,qr,l,r,res[N];
struct node{
    ll l,r,idx;
}b[N];
inline void read(ll &x){
    char ch=getchar();
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    return;
}
inline void write(ll x){
    if(x>9)write(x/10);
    putchar(x%10+'0');
}
bool cmp(node a,node b){
    return (a.l/t)^(b.l/t)?a.l<b.l:((a.l/t)&1?a.r<b.r:a.r>b.r);//常数优化
}
inline void add(int x){
    ans+=cnt[a[x]^k];
    cnt[a[x]]++;
    
}
inline void del(int x){
    cnt[a[x]]--;//如果你100pts，但 Unaccepted，你很可能错这里了。一定要先修改cnt再修改ans.具体可以看我上面说的坑点（第3条）。
    ans-=cnt[a[x]^k];
}
int main(){
    read(n),read(m),read(k);t=sqrt(n);
    for(int i=1;i<=n;i++)read(a[i]),a[i]^=a[i-1];
    for(int i=1;i<=m;i++)read(b[i].l),read(b[i].r),b[i].l--,b[i].idx=i;
    sort(b+1,b+1+m,cmp);
    cnt[0]=1;
    for(int i=1;i<=m;i++){
        ql=b[i].l,qr=b[i].r;
        while(l<ql)del(l++);
        while(l>ql)add(--l);
        while(r<qr)add(++r);
        while(r>qr)del(r--);
        res[b[i].idx]=ans;
    }
    for(int i=l;i<=m;i++){
        write(res[i]);putchar('\n');
    }
    return 0;
}
```
[AC 记录。](https://www.luogu.com.cn/record/146437774)

如有错误，请指出。

---

## 作者：_qhbd_ (赞：0)

# 题意
给定一个长 $n$ 数列 $a$，共 $m$ 组询问，每组询问给定 $l,r$ 求在区间 $l$ 到 $r$ 中有多少区间满足所有的数的异或和等于 $k$。
# 思路
首先看到这道题的数据量是 $n,m,a_i(1\le i\le n)\le10^5$，可以知道要用莫队，同时根据题意可以知道要用到异或相关知识。

如果你不会莫队的话，可以先去以下两道题学习学习练练手。
- [P1494 [国家集训队] 小 Z 的袜子](https://www.luogu.com.cn/problem/P1494)
- [P2709 小B的询问](https://www.luogu.com.cn/problem/P2709)


但是作为以一个学 OI 的，异或就跟加减乘除一样，不该不会。

## 进入正题。

这道题，相对于上面两道题，因为异或和知识的进入，有一些需要变的点。如果变通好了充其量算是个重点，否则，就是骨折点。

首先，这里莫队维护的值是前缀异或和。关于为什么，很容易知道，如果在移动左右指针的过程中有一个前缀异或和是 $a$，若此时有 $x$ 个前缀异或和为 $a\oplus k$ 就意味着在有 $x$ 个区间的异或和为 $k$。

其次，因为要维护的值是区间的异或和，所以我们这里肯定是要用到前缀异或和的。

很容易知道，如果你维护了一个异或数组 $Pre$，那么求 $[l,r]$ 区间的异或和就是 $Pre_r\oplus Pre_{l-1}$。所以坑点来了，因为维护的值是前缀异或和，所以维护 $[l,r]$ 区间时实际上需要维护的是 $[l-1,r]$。

最后是 AC 代码。
# 实现
```cpp
#include<iostream>
#include<algorithm>
#include<math.h>
#define int long long
#define N 100005
#define G 321
using namespace std;
int n,m,k,siz,res,a[N],rev[N],num[N],ans[N],pre[N];
struct que{
	int l,r,id;
}q[N];
bool cmp(que a,que b){
	if(rev[a.l]!=rev[b.l])
		return a.l<b.l;
	return a.r<b.r;
}
void del(int x){
	--num[pre[x]];//如果k=0,后自减的操作会漏计答案
	res-=num[pre[x]^k];
}
void add(int x){
	res+=num[pre[x]^k];
	++num[pre[x]];//如果k=0,先自加的操作会多计答案
}
signed main(){
	scanf("%lld%lld%lld",&n,&m,&k);
	siz=sqrt(n);
	for(int i=1;i<=n;i++){
		rev[i]=(i-1)/siz+1;
		scanf("%lld",&a[i]);
		pre[i]=pre[i-1]^a[i];
	}
	for(int i=1,l,r;i<=m;i++){
		scanf("%d%d",&q[i].l,&q[i].r);
		q[i].id=i;
	}
	sort(q+1,q+m+1,cmp);
	num[0]=1;
	for(int i=1,l=0,r=0;i<=m;i++){
		while(r<q[i].r)add(++r);
		while(r>q[i].r)del(r--);
		while(l<q[i].l-1)del(l++);
		while(l>q[i].l-1)add(--l);//l要减一
		ans[q[i].id]=res;
	}
	for(int i=1;i<=m;i++)
		printf("%lld\n",ans[i]);
	return 0;	
} 
```

---

## 作者：_anll_ (赞：0)

从线段树摸鱼，一路摸到莫队，都到这了那不妨再摸篇题解。

[顺道放个双倍经验。](https://www.luogu.com.cn/problem/CF617E)
## 题目大意
给你一个长度为 $n$ 的数组，$m$ 组询问，问你某个区间中有多少个子区间的异或和等于 $k$。

## 大体思路
对于数组 $a$，求 $a_x \oplus a_{x+1} \oplus \dots \oplus a_y $ 的值，等价于求它的前缀异或数组 $pre$ 中 $pre_{x-1} \oplus pre_y $ 的值。于是我们就把这个题转换成在某个区间中有多少对 $l$ 和 $r$ 满足 $pre_{l-1} \oplus pre_r = k$。

于是问题就变得简单起来。不妨拿数组 $cnt$ 维护有效的区间异或和出现过的次数。我们知道，对于三个数 $a$、$b$、$c$，如果存在 $a \oplus b = c$，那必将存在 $a \oplus c =b$。因此对于每个坐标 $x$，它对答案的贡献显然是 $cnt_{pre_x \oplus k}$。然后我们就可以愉快地用莫队进行维护了。

每次枚举左右节点时别忘了**把左端点减一**。

## 代码展示
```cpp
#include<iostream>
#include<map>
#include<cmath>
#include<algorithm>
#define int long long
using namespace std;
struct Que{
	int l,r,id;
}que[100005];
int n,q,k,bl,num[100005],pre[100005];
int cnt[140005],ans,anu[100005];
bool cmp(Que a,Que b){
	if(a.l/bl!=b.l/bl) return a.l<b.l;
	if(a.l/bl&1) return a.r<b.r;
	return a.r>b.r;
}
void add(int x){
	ans+=cnt[pre[x]^k];//先更新答案，否则在k=0的情况中会多算
	cnt[pre[x]]+=1;
}
void del(int x){
	cnt[pre[x]]-=1;
	ans-=cnt[pre[x]^k];//同上，后更新答案，否则在k=0的情况中会多算 
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n>>q>>k;
	bl=sqrt(n);
	for(int i=1;i<=n;i++){
		cin>>num[i];
		pre[i]=pre[i-1]^num[i];
	}
	for(int i=1;i<=q;i++){
		cin>>que[i].l>>que[i].r;
		que[i].id=i;
	}
	sort(que+1,que+1+q,cmp);
	int l=1,r=0;
	for(int i=1;i<=q;i++){
		while(l<que[i].l-1) del(l++);
		while(l>que[i].l-1) add(--l);
		while(r<que[i].r) add(++r);
		while(r>que[i].r) del(r--);
		anu[que[i].id]=ans;
	}
	for(int i=1;i<=q;i++) cout<<anu[i]<<endl;
	return 0;
}
```


---

## 作者：lovely_hyzhuo (赞：0)

一道比较板的莫队。

预处理前缀异或，然后线段树或者莫队什么的都可以。

我的写法是莫队（最近在水板子）。

在处理每个查询时计算出当前区间内满足 $sum_x=sum_{new}\oplus k $ 的个数，然后更新 $now$。

甚至个人认为最难的 $del$ 和 $add$ 在这题都只是把板拉过来加个异或。

具体的话就是先预处理出来异或前缀和，方便求区间异或值，然后我们维护一个当前区间里每个值有多少个数，然后插入的时候求一下这个区间里有多少个值为 $k$ 异或 $a_r$ 的数就可以了，注意插入的时候先处理答案后插入点，删除的时候先删除点后处理答案即可（这应该是众所周知的吧）。

代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct node
{
	int l,r;
	int id;
}a[900010];
int n,m,k;
int cnt[900010];
int pos[900010];
int sum;
int t;
int c[1900010];
void add(int col)
{
	sum+=cnt[col^k];
	cnt[col]++;
}
void cel(int col)
{
	
	cnt[col]--;
	sum-=cnt[col^k];
}
bool cmp(node a,node b)
{
	return ((a.l-1)/t)==((b.l-1)/t)?a.r>b.r:((a.l-1)/t+1)<((b.l-1)/t+1);
}
int ans[1000010];
signed main()
{
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++)
		cin>>c[i],c[i]^=c[i-1];
	t=sqrt(n);
	for(int i=1;i<=m;i++)
	{
		cin>>a[i].l>>a[i].r;
		a[i].l--;
		a[i].id=i;
	}
	sort(a+1,a+m+1,cmp);
	int l=1,r=0;
	for(int i=1;i<=m;i++)
	{
		while(l<a[i].l)cel(c[l++]);
		while(r>a[i].r)cel(c[r--]);
		while(l>a[i].l)add(c[--l]);
		while(r<a[i].r)add(c[++r]);
		ans[a[i].id]=sum;
	}
	for(int i=1;i<=m;i++)
		cout<<ans[i]<<endl;
	return 0;
}
```


---

## 作者：ywy_c_asm (赞：0)

来一篇分块的题解。

这题其实跟不带修改的区间逆序对几乎一样，并且这题只需要桶的查询还不用带log。就是有多少二元组$(l,r)$使得前缀和异或是k，我们令$f[i][j]$为块i的左端点到j这段区间内的答案，再令$g[i][j]$为块0~块i有多少个前缀和为j，查询的时候先让左块到右端点的f数组统计进去，在考虑左端点到左块这一小段，他会和他自身、中间大块、右边一小段产生贡献，前者后者开桶暴力记录，中间的用g数组的前缀和相减统计一下，也是$O(N\sqrt N)$的。

上代码~

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define blo 316
#define ll long long
using namespace std;
namespace ywy{
	inline int get(){
		int n=0;char c;while((c=getchar())||23333){
			if(c>='0'&&c<='9')break;if(c=='-')goto s;
		}n=c-'0';while((c=getchar())||23333){
			if(c>='0'&&c<='9')n=n*10+c-'0';else return(n);
		}s:while((c=getchar())||23333){
			if(c>='0'&&c<='9')n=n*10-c+'0';else return(n);
		}
	}
	void print(ll num){
		if(num>=10)print(num/10);
		putchar(num%10+'0');
	}
	ll f[320][100001];
	int sums[100001];
	int g[320][200001],cnt[200001];
	void ywymain(){
		int n=get(),m=get(),k=get();
		int b=1,mx=k;
		for(register int i=1;i<=n;i++)mx=max(mx,sums[i]=sums[i-1]^get());
		while(b<=mx)b<<=1;
		for(register int i=0;i<=n/blo;i++){
			for(register int j=0;j<=b;j++)cnt[j]=0;
			for(register int j=i*blo;j<=n;j++)f[i][j]=((j==i*blo)?0:f[i][j-1])+cnt[sums[j]^k],cnt[sums[j]]++;
			if(i!=0)for(register int j=0;j<=b;j++)g[i][j]=g[i-1][j];
			for(register int j=i*blo;j<=n&&j<(i+1)*blo;j++)g[i][sums[j]]++;
		}
		memset(cnt,0,sizeof(cnt));
		while(m){
			m--;
			int l=get()-1,r=get();
			int lsb=l/blo+1,rsb=r/blo-1;
			if(l%blo==0)lsb--;
			if((r+1)%blo==0)rsb++;
			if(lsb>rsb){
				ll ans=0;
				for(register int i=l;i<=r；i++){
					ans+=cnt[k^sums[i]];cnt[sums[i]]++;
				}
				print(ans);putchar('\n');
				for(register int i=l;i<=r;i++)cnt[sums[i]]=0;continue;
			}
			ll ans=f[lsb][r];
			for(register int i=(rsb+1)*blo;i<=r;i++)cnt[sums[i]]++;
			for(register int i=l;i<lsb*blo;i++){
				ans+=cnt[sums[i]^k],ans+=(g[rsb][sums[i]^k]-g[lsb-1][sums[i]^k]),cnt[sums[i]]++;
			}
			print(ans);putchar('\n‘);
			for(register int i=(rsb+1)*blo;i<=r;i++)cnt[sums[i]]=0;
			for(register int i=l;i<lsb*blo;i++)cnt[sums[i]]=0;
		}
	}
}
int main(){
	ywy::ywymain();return(0);\\再见程序
}
```

---


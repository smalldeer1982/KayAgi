# [JXOI2018] 游戏

## 题目背景

九条可怜是一个富有的女孩子。

## 题目描述

她长大以后创业了，开了一个公司。 但是管理公司是一个很累人的活，员工们经常背着可怜偷懒，可怜需要时不时对办公室进行检查。

可怜公司有 $n$ 个办公室，办公室编号是 $l$ 到 $l+n-1$ ，可怜会事先制定一个顺序，按照这个顺序依次检查办公室。一开始的时候，所有办公室的员工都在偷懒，当她检查完编号是 $i$ 的办公室时候，这个办公室的员工会认真工作，并且这个办公室的员工通知所有办公室编号是 $i$ 的倍数的办公室，通知他们老板来了，让他们认真工作。因此，可怜检查完第 $i$ 个办公室的时候，所有编号是 $i$ 的倍数(包括 $i$ )的办公室的员工会认真工作。

可怜发现了员工们通风报信的行为，她发现，对于每种不同的顺序 $p$ ，都存在一个最小的 $t(p)$ ，使得可怜按照这个顺序检查完前 $t(p)$ 个办公室之后，所有的办公室都会开始认真工作。她把这个 $t(p)$ 定义为 $p$ 的检查时间。

可怜想知道所有 $t(p)$ 的和。

但是这个结果可能很大，她想知道和对 $10^9+7$ 取模后的结果。

## 说明/提示

### 样例解释

考虑所有办公室被检查的相对顺序:

{2 3 4} ,时间是 2 。
{3 2 4} ,时间是 2 。
{4 2 3} ,时间是 3 。
{4 3 2} ,时间是 3 。
{2 4 3} ,时间是 3 。
{3 4 2} ,时间是 3 。

和是 $16$ 。

### 数据范围

对于 20% 的数据，$r-l+1\leq 8$。  
对于另 10% 的数据，$l=1$。  
对于另 10% 的数据，$l=2$。  
对于另 30% 的数据，$l\leq 200$。  
对于 100% 的数据，$1\leq l\leq r\leq 10^7$。

## 样例 #1

### 输入

```
2 4```

### 输出

```
16
```

# 题解

## 作者：Dr_Gilbert (赞：60)

发现题解第一篇的结论比较缺乏证明，看题解的时候一直没看懂，后来自己想了想才理解结论的正确性，在此对结论补充一下证明。  

要求最后一个关键点的期望位置，不妨求排在所有关键点后的非关键点的期望个数。任意钦定一个非关键点，去掉序列中所有其它非关键点。$k$ 个关键点将原序列分为了 $k+1$ 段，这个非关键点和关键点的位置关系与非关键点个数无关。故对于任意一个非关键点，它排在所有关键点后面的概率为
$$
P=\frac{1}{k+1}
$$
由于有 $n-k$ 个非关键点，则排在所有关键点后的非关键点的个数期望
$$
E=(n-k)P=\frac{n-k}{k+1}
$$
故最后一个关键点的位置期望
$$
E=n-\frac{n-k}{k+1}=\frac{kn+n-n+k}{k+1}=\frac{k(n+1)}{k+1}
$$
则答案为
$$
\frac{k}{k+1}(n+1)!
$$

---

## 作者：ningyuheng (赞：43)

我们经过观察发现，对于每个数字，我们可以分成关键数字和非关键数字，关键数字为在这l~r里面没有数字（除他本身）的倍数是它。显而易见的是对于一个排列最末尾的关键数字所在的位置即是它的检查时间。问题转换为在n个数中随机取k个数，最末尾的数字的位置的期望乘以n的阶乘（即所有排列总数）。显然如果是期望，那么肯定是平均分布,可以得出位置的期望为k/(k+1)×(n+1)(因为位置从1开始数起)，则总答案即为k/(k+1)×((n+1)!).附上目前最短代码：
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
long long l,r,book[10000005],k,ans,mo=1e9+7,i,j;
int main(){
	scanf("%lld%lld",&l,&r);
	for(i=l;i<=r;i++)
		if(book[i]==0)
			for(k++,j=i*2;j<=r;j+=i)
				book[j]=1;
	ans=k;
	for(i=1;i<=r-l+2;i++)
		if(i!=k+1)
			ans=ans*i%mo;
	printf("%lld\n",ans);
	return 0;
}

```

---

## 作者：wxgwxg (赞：23)

题意，给一个区间$[l,r]$,每次选一个数，把它和它的倍数去掉，耗时为$[l,r]$的所有数都被消掉的次数，问所以不同选则方式的总耗时；

$l=1$,答案就是1的位置，答案是$r! \times (n+1)/2$,

$l!=1$ ,可以用类似筛法的算法，找到最小的未标记的数，把它和它的倍数标记，
代码大概长这个样子
```cpp
	for(int i=l;i<=r;i++)
	{
		if(!vis[i])
		{
			sum++;
			for(int j=i<<1;j<=r;j+=i)
				vis[j]=1;
		}
	}
```
复杂度是 $O(nloglogn)$的

我们发现，只要找到选了这些没被标记的数，就可以把所有数消掉了，就是有多少数是必选的，也就是代码中的sum。

有了sum，就可以计算答案了，设$f[i]$为第$i$次消掉所有数的次数，
则 $f[i]= sum*C(n-sum,n-i)\times(i-1)!\times(n-i)!$

就是后$n-i$个数都不是要选的，就是$C(n-sum,n-i)\times(n-i)!$,第$i$个数是要选的,有$sum$个，前$i-1$个数排列有 $(i-1)!$个；

答案为 $\sum_{i=sum}^{n} i\times f[i]$

找到未标记的数也可以用线性筛筛出每个数的最小因数，若该数除最小因数小于$l$,就是必选数，虽然复杂度是 $O(n)$，其实还没有上面那个快，又没有上面的好写，~~选哪个就不用说了吧~~。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
inline int read()
{
	int k=0,f=1;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) k=k*10+c-'0';return f*k;
}
const int N=10000055,mod=1e9+7;
int fac[N],inv[N],l,r,n,tot,pri[N];
bool vis[N];
int ksm(int x,int k) {int as=1;for(;k;k>>=1,x=1ll*x*x%mod) if(k&1) as=1ll*as*x%mod;return as;}
int main()
{
	l=read();r=read();
	fac[0]=1;
	for(int i=1;i<=r;i++) fac[i]=1ll*i*fac[i-1]%mod;
	inv[r]=ksm(fac[r],mod-2);
	for(int i=r;i;i--) inv[i-1]=1ll*i*inv[i]%mod;
	if(l==1)
	{
		printf("%lld\n",1ll*fac[r]*(r+1)%mod*ksm(2,mod-2)%mod);
		return 0;
	}
	int sum=0,ss=0;
	for(int i=l;i<=r;i++)
	{
		if(!vis[i])
		{
			sum++;
			for(int j=i<<1;j<=r;j+=i)
				vis[j]=1;
		}
	}
	n=r-l+1;int as=0;
	for(int i=sum;i<=n;i++)
	{	
		as=(as+1ll*sum*fac[n-sum]%mod*inv[i-sum]%mod*fac[i]%mod)%mod;	
	}
	printf("%d\n",as);
}
```

---

## 作者：4526_ (赞：15)

#### update:2019.10.07

之前组合数求和部分运算符号忘打了，第11条中等号左边为加号，不是相乘，已补上



------------


[题目链接](https://www.luogu.org/problem/P4562)

由于我太蒻了不会 O(n) 求组合数，看不懂dalao们的题解，这里提供一种结论与组合数无关的 O(n) 做法（当然推导过程要用到组合数），思维难度省选，~~代码难度入门~~

**前置知识：概率与期望的定义、组合数的性质（必修2-3应该都会讲）**

**主要思想：期望、组合数学**

大致思路：

1、分析可知某些办公室不能被其他办公室通知到，即编号不是其他编号的整数倍（以下简称伪素数），那么t(p)即为最后一个伪素数的出现位置

2、用埃氏筛搞出 l~r 中伪素数的个数，记为m，复杂度 O(n)

3、一句话题意：n个数中选m个数，求**最后一个被选数位置的期望**

4、由期望的定义得 **ans= $ \sum_{i=m}^{n} $ i \* 最后一个数位置为i的概率**

5、把一项的表达式拿出来得到 $ \frac{C_{i-1}^{m-1}}{C_{n}^{m}} $ * i * n!，即**位置为 i 的概率 [ 前 i-1 个数中选 m-1 个（i号位必定被选）除以n个数中选m个 ] 乘上位置为 i 对答案的贡献再乘上总情况数（n个数的全排列）**

6、拆开得 $ \frac{(i-1)!}{(m-1)!(i-m)!} $ \* $ \frac{m!(n-m)!}{n!} $ \* i \* n!

7、约分得 $ \frac{i!}{(m-1)!(i-m)!} $ \* (n-m)! \* m!

8、把分数化为 $ \frac{i! * m}{m!(i-m)!} $ 

9、分母的 m 拎出来得 $ C_{i}^{m} $ \* (n-m)! \* m! \* m

10、对 $ C_{i}^{m} $ 求和，其中 m ≤ i ≤ n ; 当 i = m 时， $ C_{i}^{m+1} $ = 0 （ m 个数中选不出 m+1 个）,令原式加上 $ C_{m}^{m+1} $ 答案不变

11、由组合数的性质得 $ C_{m}^{m} $ + $ C_{m}^{m+1} $ = $ C_{m+1}^{m+1} $ ， $ C_{m+1}^{m} $ + $ C_{m+1}^{m+1} $ = $ C_{m+2}^{m+1} $ ， $ C_{m+2}^{m} $ + $ C_{m+2}^{m+1} $ = $ C_{m+3}^{m+1} $ ······

12、（类似于数学归纳法）得到求和结果为 $ C_{n+1}^{m+1} $ 

13、合并整个式子得 $ \frac{(n+1)!}{(m+1)!(n-m)!} $ \* (n-m)! \* m! \* m ,约分得最终结果 (n+1)! \* $ \frac{m}{m+1} $ 

AC代码：

```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define ha 1000000007
using namespace std;

int l,r,num;
long long ans;
bool pd[10000010];

int main(){
	scanf("%d %d",&l,&r);
	for(register int i=l;i<=r;++i){
		if(pd[i]) continue;
		num++;
		for(register int k=i+i;k<=r;k+=i) pd[k]=true;
	}
	ans=num;
	for(register int i=r-l+2;i;--i){
		if(i!=num+1) ans=(ans*i)%ha;
	}
	printf("%d",ans);
	return 0;
}

```

欢迎来[我的blog](https://www.luogu.org/blog/138812/#)看看

---

## 作者：Ebola (赞：13)


首先计算出$l$到$r$中，不是任何数的倍数的有多少个，记这个值为$sum$。比如说$l=4, r=8$时，$4,5,6$都不是任何数的倍数，此时$sum=3$。我们称这样的数为“关键数”

不难发现，$t(p)$的定义，其实就是排列$p$中，最后一个关键数的位置

于是我们可以枚举最后一个关键数的位置i，在它后面不能存在关键数，所以它后面的元素有$C(n-sum, n-i)$种选取方法，对于每种选取方案，$i$后面的元素有$(n-i)!$种排列方式，$i$前面的元素有$(i-1)!$种排列方式，然后$i$这个位置可以是$sum$个关键数中的任意一个，并且这个位置对答案的贡献为$i$

于是答案可以表达成下式：

$$\sum\limits_{i=1}^ni\times sum\times \binom{n-sum}{n-i}\times(n-i)!\times(i-1)!$$

直接预处理阶乘及其逆元即可，$sum$直接埃氏筛暴算即可

```cpp
#include<bits/stdc++.h>
using namespace std;

const int ha=1000000007;
const int N=10000010;
bool vis[N];
int l,r,sum=0;
int fac[N],ifac[N];

int Pow(int a,int b)
{
    int ans=1;
    for(;b;b>>=1,a=1ll*a*a%ha)
        if(b&1) ans=1ll*ans*a%ha;
    return ans;
}

void Init(int n)
{
    fac[0]=1;
    for(int i=1;i<=n;i++)
        fac[i]=1ll*fac[i-1]*i%ha;
    ifac[n]=Pow(fac[n],ha-2);
    for(int i=n-1;i>=0;i--)
        ifac[i]=1ll*ifac[i+1]*(i+1)%ha;
}

inline int C(int n,int m){return n<m?0:1ll*fac[n]*ifac[m]%ha*ifac[n-m]%ha;}

int main()
{
    cin>>l>>r;Init(r);
    for(int i=l;i<=r;i++)
    {
        if(vis[i]) continue;
        sum++;
        for(int j=i;j<=r;j+=i)
            vis[j]=1;
    }
    int ans=0,n=r-l+1;
    for(int i=1;i<=n;i++)
    {
        int res=1ll*i*sum%ha;
        res=1ll*res*C(n-sum,n-i)%ha;
        res=1ll*res*fac[n-i]%ha;
        res=1ll*res*fac[i-1]%ha;
        ans=(ans+res)%ha;
    }
    cout<<ans<<endl;
    return 0;
}
```



---

## 作者：HigHwind (赞：10)

看样子并没有人在求到可以$O(n)$计算的和式后再往下算了，我这里提供继续化简（hua she tian zu）的办法，可以将关于$l=1$分类讨论直接避免掉，而且答案异常简洁。

不过我们还是先看一下$l=1$的情况吧，虽然和待会的讨论无关。

显然每个排列的答案就是$1$的位置，因为选了$1$就可以把所有的数都选上……而还没有选到$1$的时候，$1$肯定没被选，这个很显然。所以有

$$\mathrm{ans}=\sum_{i=1}^{r-l+1}i\cdot(r-l)!=\dfrac{(r-l+2)!}{2}=\dfrac{(r+1)!}{2}$$

**定义**  对于一个$x\in[l,r]:$不是$[l,r]\backslash\{x\}$中任何一个数的倍数，那么我们就称它为**独立**的。

我们可以$\mathcal O(r-l)$预处理出哪些数是**独立**的。不难发现，找到所有这样的数后，只要我们选完了这些数就完成了任务。

设*独立的数的总数*有$n$个，那么最后一个独立的数可以出现在$[n,r-l+1]$的任何一个位置$u$上，对答案的贡献就是$u$，方案数的话，首先得保证剩下的$n-1$独立的数要在前$u-1$个位置中，那么就有$n!(r-l-n+1)!\binom{u-1}{n-1}$种，这样一来

$$\begin{aligned}\mathrm{ans}/[n!(r-l-n+1)!]&=\sum_{u=n}^{r-l+1}u\binom{u-1}{n-1}\\&=n\sum_{u=n}^{r-l+1}\binom un\\&=n\left(\sum_{u=0}^{r-l+1}\binom un-\sum_{u=0}^{n-1}\binom un\right)\\&=n\binom{r-l+2}{n+1}-n\binom{n}{n+1}\\&=n\binom{r-l+2}{n+1}-0\\&=\dfrac{n\cdot(r-l+2)!}{(n+1)!(r-l-n+1)!}\end{aligned}$$

$$\therefore \mathrm{ans}=\dfrac{n(r-l+2)!}{n+1}$$

上面的推导过程中，只使用了两个公式，我在下面列出

$$\sum_{r=0}^n\binom{r}{k}=\binom{n+1}{k+1}\qquad\qquad(\text{上指标求和})$$

$$r\binom{r-1}{k-1}=k\binom{r}{k}\qquad\qquad(\text{吸收公式})$$

知道了这两个公式、上面的过程就很显然了，这两个公式都可以用加法公式和组合数的对称公式证明，有兴趣的读者可以试着证明一下。

怎么验证这个答案呢？我们首先发现它过了样例，然后可以发现当$l=1$时，此时显然有$n=1$（独立的数只有$1$这一个），那么代入$l,n$，发现同$l=1$的讨论统一起来了。

rank1代码奉上qwq（非常好写，用了`bitset`的话内存也极其优越）

```cpp
#include <iostream>
#include <algorithm>
#include <bitset>
#define gor(A,B,E) for(int A=B;A<=E;++A)
using namespace std; typedef long long ll;
const int N = 1e7 + 30, MOD = 1e9 + 7;
ll l, r, n, q = 1;
bitset<N> v;
inline ll qpow(ll x,ll k) {ll as=1;for(;k;k>>=1,x=1ll*x*x%MOD) if(k&1) as=1ll*as*x%MOD;return as;}
int main() {
    cin >> l >> r;
    gor(i, 2, r - l + 2) q = (q * i) % MOD;
    gor(i, l, r) {
        if (v[i]) continue;
        for (int j = i << 1; j <= r; j += i)
            if (!v[j]) v[j] = 1, ++n;
    } n = r - l + 1 - n;
    return printf("%lld", ((qpow(n + 1, MOD - 2) * n)%MOD * q)%MOD), 0;
}
```

---

## 作者：foreverlasting (赞：3)

[题面](https://www.luogu.org/problemnew/show/P4562)

组合数学+九条可怜。

报警了啊，题解的复杂度不是错的吗？那个类似埃氏筛的东西的复杂度应该是$O(nlogn)$的啊，怎么跑过去的......

正确复杂度应该是$O(n)$。我们知道，若一个数的最大因数（不等于它本身）在$[l,r]$区间内，则无论如何都需要将它的最大因数先找到，所以我们可以利用欧拉筛处理每个数的最小质因数，这样就可以找到最大因数了。

考虑如何做组合数学。假设必须要找到的数有$tot$个，那么我们的$t(p)$是大于等于$tot$，小于$r-l+1$的。考虑每种$t(p)$的方案数，这也很算，是$C(i-1,tot-1)*tot!*(n-tot)!$，$i$表示当前$t(p)$。然后就好了。

code:
```
#define MIAOKEHAO                                                                    \
    　　　　　　　　┏┓　　┏┓                                                       \
    　　　　　　　┏┛┗━━┛┗━┓                                                   \
    　　　　　　　┃　　　　　　　┃                                                   \
    　　　　　　　┃　　　━　　  ┃                                                   \
    　　　　　　　┃　＞　　　＜　┃                                                   \
    　　　　　　　┃　　　　　　　┃                                                   \
    　　　　　　　┃...　 ⌒ ...  ┃                                                   \
    　　　　　　　┃　　　　　　　┃                                                   \
    　　　　　　　┗━┓　　　┏━┛                                                   \
    　　　　　　　　　┃　　　┃　Code is far away from bug with the animal protecting \
    　　　　　　　　　┃　　　┃  神兽保佑 , 代码无bug                                 \
    　　　　　　　　　┃　　　┃　　　　　　　　　　　                                 \
    　　　　　　　　　┃　　　┃　　　　　　　　　　　                                 \
    　　　　　　　　　┃　　　┃　　　　　　　　　　　                                 \
    　　　　　　　　　┃　　　┃　　　　　　　　　　　                                 \
    　　　　　　　　　┃　　　┗━━━┓ 　　　　　　　　　　　                        \
    　　　　　　　　　┃　　　　　　　┣┓ 　　　　　　　　　　　                      \
    　　　　　　　　　┃　　　　　　　┏┛ 　　　　　　　　　　　                      \
    　　　　　　　　　┗┓┓┏━┳┓┏┛ 　　　　　　　　　　　                        \
    　　　　　　　　　　┃┫┫　┃┫┫  　　　　　　　　　　　                         \
    　　　　　　　　　　┗┻┛　┗┻┛
#undef MIAOKEHAO
#pragma GCC optimize(2)
//2018.10.31 by ljz
#include<bits/stdc++.h>
using namespace std;
#define res register int
#define LL long long
#define inf 0x3f3f3f3f
#define eps 1e-15
inline int read(){
    res s=0;
    bool w=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=1;ch=getchar();}
    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();
    return w?-s:s;
}
inline void _swap(res &x,res &y){
    x^=y^=x^=y;
}
inline int _abs(const res &x){
    return x>0?x:-x;
}
inline int _max(const res &x,const res &y){
    return x>y?x:y;
}
inline int _min(const res &x,const res &y){
    return x<y?x:y;
}
const int N=1e7+10;
const int kcz=1e9+7;
namespace MAIN{
	int l,r;
	int fac[N],inv[N],prim[N],mn[N];
	int cnt;
	inline void pre(){
		mn[1]=1;
		for(res i=2;i<=r;i++){
			if(!mn[i])mn[i]=i,prim[++cnt]=i;
			for(res j=1;j<=cnt&&prim[j]*i<=r;j++){
				mn[prim[j]*i]=prim[j];
				if(i%prim[j]==0)break;
			}
		}
		inv[0]=inv[1]=fac[0]=fac[1]=1;
		for(res i=2;i<=r;i++)fac[i]=1LL*fac[i-1]*i%kcz,inv[i]=1LL*inv[kcz%i]*(kcz-kcz/i)%kcz;
		for(res i=2;i<=r;i++)inv[i]=1LL*inv[i-1]*inv[i]%kcz;
	}
	inline int C(const res &x,const res &y){
		return 1LL*fac[x]*inv[y]%kcz*inv[x-y]%kcz;
	}
	int tot,ans;
	inline void add(res &x,const res &y){
		x+=y;
		x>=kcz?x-=kcz:1;
	}
    inline void MAIN(){
    	l=read(),r=read();
    	pre();
    	for(res i=l;i<=r;i++)if(i/mn[i]<l)tot++;
    	if(l==1)tot++;
    	for(res i=tot;i<=r-l+1;i++)add(ans,1LL*C(i-1,tot-1)*fac[tot]%kcz*fac[r-l+1-tot]%kcz*i%kcz);
    	printf("%d\n",ans);
    }
}
int main(){
    MAIN::MAIN();
    return 0;
}
```

---

## 作者：HC20050615 (赞：2)

## 前言
因为本蒟蒻太菜了，看了题解才做出来这道题，感觉这道题难度适中，很适合练习推式子的能力，所以想到写一篇题解。同时感谢[4526_](https://www.luogu.com.cn/user/138812)这位大佬的题解，给了我很大的启发。
## 题意分析
编号为 $x$ 的房间在被检查过之后，编号为 $x$ 的倍数的房间就没有检查的必要了。因此，只要所有编号不是任何其他房间编号的倍数的房间被检查完，所有的房间一定都开始认真工作了。

题目可简化为：对于区间 $l \sim n$ ，定义关键数为不被任何此区间其它数整除的数。求其所有排列最后一个关键数所在位置的总和。
## 做题思路
可以通过 $O(n)$ 的时间复杂度（其实埃筛也可以过，但时间复杂度不对，~~我就用的埃筛~~）来搜索所有关键数，记其个数为 $m$ 。

首先，根据期望的性质可知，期望 $\times$ 总方案数 $=$ 总和，所以我们可以先找出期望，在再其对应的方案数来求得总和。又因为期望等于概率 $\times$ 贡献

所以答案可表示为 $\sum_{i=m}^{n}($最后一个关键数在 $i$ 位置的概率 $\times i)\times$ 所有排列数

最后一个关键数在 $i$ 的概率 $=$ 最后一个关键数在 $i$ 的方案数 $/$ 总方案数 $=\frac{\tbinom{m-1}{i-1}(n-m)!m!}{\tbinom{m}{n}(n-m)!m!}=\frac{\tbinom{m-1}{i-1}}{\tbinom{m}{n}}$

$$
ans=\sum_{i=m}^{n}(\frac{\tbinom{m-1}{i-1}}{\tbinom{m}{n}}\times i)\times n!
$$
$$
=\sum_{i=m}^{n}(\frac{\frac{(i-1)!}{(m-1)!(i-m)!}}{\frac{n!}{m!(n-m)!}}\times i)\times n!
$$
$$
=\sum_{i=m}^{n}(\frac{i!}{m!(i-m)!})\times m!\times m \times(n-m)!
$$
$$
=\sum_{i=m}^{n}\tbinom{m}{i}\times m\times m!\times(n-m)!
$$
易证：
$$
\tbinom{m}{m}+\tbinom{m+1}{m}
=\tbinom{m+1}{m+1}
$$
$$
\tbinom{m}{m+1}+\tbinom{m+1}{m+1}=\tbinom{m+1}{m+2}
$$
$$
\tbinom{m}{m+2}+\tbinom{m+1}{m+2}=\tbinom{m+1}{m+3}
$$
$$
...
$$
故有：
$$
\sum_{i=m}^{n}\tbinom{m}{i}
$$
$$
=\tbinom{m}{m}+\tbinom{m}{m+1}+\tbinom{m}{m+2}+\tbinom{m}{m+3}+...+\tbinom{m}{n}
$$
$$
=\tbinom{m}{m}+0+\tbinom{m}{m+1}+\tbinom{m}{m+2}+\tbinom{m}{m+3}+...+\tbinom{m}{n}
$$
$$
\tbinom{m}{m}+\tbinom{m+1}{m}+\tbinom{m}{m+1}+\tbinom{m}{m+2}+\tbinom{m}{m+3}+...+\tbinom{m}{n}
$$
$$
=\tbinom{m+1}{n+1}
$$
带回原式，有：
$$
ans=\tbinom{m+1}{n+1}\times m\times m!\times(n-m)!
$$
$$
=\frac{(n+1)!}{(m+1)!(n-m)!}\times m\times m!\times(n-m)
$$
$$
=\frac{m(n+1)!}{m+1}
$$
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int l,r;
bool b[10000001];
int n,m;
long long mod=1e9+7;
inline void find_key()
{
	for(register int i=l;i<=r;i++)
	{
		if(!b[i])
		{
			m++;
			for(register int j=2*i;j<=r;j+=i)
			{
				b[j]=1;
			}
		}
	}
	return ;
}
int main()
{
	cin>>l>>r;
	n=r-l+1;
	find_key();
	long long ans=m;
	for(register int i=2;i<=m;i++)
	{
		ans*=i;
		ans%=mod;
	}
	for(register int i=m+2;i<=n+1;i++)
	{
		ans*=i;
		ans%=mod;
	}
	cout<<ans<<endl;
	return 0;
}
```


---

## 作者：Fairicle (赞：2)

我们定义，一个在 $[l,r]$ 内的数如果在 $[l,r]$ 中没有其倍数，那么我们称这种数为 “重要的数”。

显然，只有所有“重要的数”被选了，游戏就结束，反过来也是一样的（因此是充要条件）。

所以只需要枚举选到第 $x$ 个数选择了最后一个“重要的数”即可，用式子表达就是 

$\sum\limits_{x=num}^{r-l+1}x\times C_{x-1}^{num-1}\times (r-l+1-num)!\times (num!)$（用 $num$ 代表“重要的数”的个数）

考虑如何计算“重要的数”。我们发现对于一个 $x$，记它的最小素因子为 $p$，若 $\frac{x}{p}$ 已经在 $[l,r]$ 中出现了，那么它是不重要的，反之它是重要的。于是只需要线性筛一遍求出最小素因子。

code：

```cpp
#include"bits/stdc++.h"
using namespace std;
#define ri register int
#define ll long long
#define N 10000010
#define mod 1000000007
int wl,p[N>>3],np[N],l,r,mn[N],in,vis[N],mx=10000000;
ll inv[N],fac[N];
inline void sieve(){
    np[1]=1;
    for(ri i=1;i<=mx;++i){
        if(!np[i]) {p[++wl]=i;mn[i]=i;}
        for(ri j=1;j<=wl&&i*p[j]<=mx;++j){
            np[i*p[j]]=1;mn[i*p[j]]=p[j];
            if(i%p[j]==0) break;
        }
    }
}
inline ll ksm(ll x,ll y){
    ll res=1;
    while(y){
        if(y&1) res=res*x%mod;
        x=x*x%mod;
        y>>=1;
    }
    return res;
}
inline ll C(int x,int y){
    if(x<0||y<0||x>y) return 0;
    return fac[y]*inv[x]%mod*inv[y-x]%mod;
}
int main(){
    sieve();
    cin>>l>>r;
    fac[0]=inv[0]=1;
    for(ri i=1;i<=mx;++i) fac[i]=1ll*i*fac[i-1]%mod;
    inv[mx]=ksm(fac[mx],mod-2);
    for(ri i=mx-1;i>=1;--i) inv[i]=1ll*(i+1)*inv[i+1]%mod;
    if(l==1){
        ll ans=0,bas=fac[r-l];
        for(ri x=1;x<=r;++x) (ans+=(1ll*x*bas%mod))%=mod;
        cout<<ans;
        return 0;
    }
    else{
        for(ri i=l;i<=r;++i){
            if(!vis[i/mn[i]]) in++;
            vis[i]=1;
        }
        ll mul=fac[in]*fac[r-l+1-in]%mod;
        ll ans=0;
        for(ri x=in;x<=r-l+1;++x){
            (ans+=(1ll*x*C(in-1,x-1)%mod))%=mod;
        }
        ans=ans*mul%mod;
        cout<<ans;
    }
    return 0;
}
```


---

## 作者：nekko (赞：2)

对于一段区间，可以将每个数字连向它所有的倍数

这样惠有一些凛度点

如果要把所有数字全部消掉，那么一定需要把所有的凛度点都消掉

发现区间长度才 $10^7$，于是可以暴力枚举一下 $t(p)$ 的值，然后统计有多少种排列可以达到 $t(p)$

设凛度点的个数为 $tot$，$n=r-l+1$

假设当前枚举 $t(p)=i$，也就是说在第 $i$ 个位置上，是最后一个凛度点

于是显然达到 $t(p)=i$ 的方案数为：

$$f_i={tot \choose 1}{i - 1 \choose tot - 1}(tot-1)!(n-tot)!$$

那么答案就是：

$$\sum_{i=tot}^{n}i \times f(i)$$

然而如果这么写的话在 $bzoj$ 上是惠 $TLE$ 的，不妨接着大力化简一下（~~并不惠 $O(\log n)$ 的做法~~）：

$$ \begin{aligned} &\sum_{i=T}^{n}i {T \choose 1} {i - 1 \choose T - 1}(T-1)!(n-T)! \\ =&\sum_{i=T}^{n}i T \frac{(i-1)!}{(T-1)!(i-T)!}(T-1)!(n-T)! \\ =&T(n-T)!\sum_{i=T}^{n}\frac{i!}{(i-T)!} \\ \end{aligned} $$

``` cpp
#include <bits/stdc++.h>
using namespace std; typedef long long ll;
const int N = 1e7 + 10, mod = 1e9 + 7, T = 1e7;
int fac[N], invfac[N];

ll pw(ll a, ll b) {
	ll r = 1;
	for( ; b ; b >>= 1, a = a * a % mod)
		if(b & 1)
			r = r * a % mod;
	return r;
}

bool vis[N]; int tot, f[N];

int C(int n, int m) {
	return n >= m ? (ll) fac[n] * invfac[m] % mod * invfac[n - m] % mod : 0;
}

int main() {
	int l, r; scanf("%d%d", &l, &r);
	fac[0] = invfac[0] = 1;
	for(int i = 1 ; i <= T ; ++ i) fac[i] = (ll) fac[i - 1] * i % mod;
	invfac[T] = pw(fac[T], mod - 2);
	for(int i = T - 1 ; i ; -- i) invfac[i] = (ll) invfac[i + 1] * (i + 1) % mod;
	
	for(int i = l ; i <= r ; ++ i) {
		if(!vis[i]) {
			++ tot;
			for(int j = i ; j <= r ; j += i) {
				vis[j] = 1;
			}
		}
	}
	
	int n = r - l + 1, ans = 0;
	for(int i = tot ; i <= n ; ++ i) ans = (ans + (ll) fac[i] % mod * invfac[i - tot] % mod) % mod;
	ans = (ll) ans * tot % mod * fac[n - tot] % mod;
	if(ans < 0) ans += mod;
	printf("%d\n", ans);
}
```

---

## 作者：huangzirui (赞：1)

题意：

在 $\text{[l,r]}$ 的数字中，选出多少个数满足它们的倍数覆盖整个区间。求对于所有的情况选出数的和。

$l,r \leq 10^7$

---

考虑一个数向它的倍数连边，那么就形成了一张有向无环图。

原题等于求选出多少个点令这些点可以到达整个图。

显然只要关注那些没有入度的点，也就是集合中没有它的约数的数。

设 $n$ 个数中 $s$ 个数没有约数，考虑枚举选出数的个数，那么答案就是：

$$\sum_{i=s}^n i\times \dbinom{n-s}{i-s} \times i! \times \dfrac{s}{i}$$

式子的意义是：考虑一定选 $s$ 个没有约数的数，于是在剩下的数中选择 $i-s$ 个，乘以排列数 $i!$ ，因为最后选择的一定是没有约数的所以要乘以 $\dfrac{s}{i}$ 。

（筛出无入度的数的复杂度是 $n\log n$ 级别的。）

---

## 作者：Chivas_Regal (赞：0)

# 思路

分析一波题意，**$t(p)$ 就是对于排列 $p$ ，没有因子的数出现的最后位置**   
  
那么我们将所有数分为  
$div_1$：无因子的数的数量  
$div_2$：有因子的数的数量  
这个可以通过埃氏筛求得   
  
对于答案，考虑贡献，即为对于每一个位置 $i$，求它能作为 $t(p)$ 的排列数量 $num$   
那么答案便是 $\sum\limits_i(i\times num)$   
  
对于 $num$ 的求法:  
- 我们让 $div_1$ 其中一个卡在第 $i$ 个位置  
- 其余的 $div_1-1$ 个数在 $[1,i)$ 里面任意分布  
- 这里我们只是考虑了位置。还要考虑方案数 所以 $div_1,div_2$ 也都要全排列一下 

那么 $num=1\times \binom{i-1}{div_1-1}\times (div_1!)\times (div_2!)$  

由于前 $i$ 个位置要存放完 $div_1$ 个数，所以 $i\in[div_1,n]$  
所以答案为  
$$\sum\limits_{i=div_1}^n(1\times\binom{i-1}{div_1-1}\times (div_1!)\times (div_2!)\times i)$$

# 代码

```cpp
const int N = 1e7 + 10;
const int mod = 1e9 + 7;

inline ll ksm (ll a, ll b) { ll res = 1; while (b) { if (b & 1) res = res * a % mod; a = a * a % mod; b >>= 1; } return res; }
inline ll inv (ll x) { return ksm(x, mod - 2); }

ll f[N], ivf[N];
inline void Pre () {
        f[0] = 1;
        for (int i = 1; i < N; i ++) f[i] = f[i - 1] * i % mod;
        ivf[N - 1] = inv(f[N - 1]);
        for (int i = N - 2; i >= 0; i --) ivf[i] = ivf[i + 1] * (i + 1) % mod;
}
inline ll C (int n, int m) {
        return f[n] * ivf[m] % mod * ivf[n - m] % mod;
}

bool vis[N];

int main () {
        ios::sync_with_stdio(false);
        cin.tie(nullptr);

        Pre();

        int l, r; cin >> l >> r;
        int n = r - l + 1;

        int div1 = 0, div2 = n;
        for (int i = l; i <= r; i ++) {
                if (!vis[i]) {
                        div1 ++;
                        div2 --;
                        for (int j = i + i; j <= r; j += i) vis[j] = true;
                }
        }

        ll res = 0;
        for (int i = div1; i <= n; i ++) {
                res += C(i - 1, div1 - 1) * f[div1] % mod * f[div2] % mod * i % mod;
                res %= mod;
        }
        cout << res << endl;
}
```

---

## 作者：Froranzen (赞：0)

首先，容易发现，在所有的顺序中，存在一部分数一定会被选中，我们不妨称这些数为特殊数。易知特殊数满足在 $l \thicksim (i-1)$ 中不存在它的因数。这些数我们可以用类似埃氏筛的做法来求，代码如下：


```cpp
    for(int i = l; i <= r; ++i) {
        if(!vis[i]) {
            ++num;
            for(int j = i; j <= r; j += i)
            	vis[j] = 1;
        }
    }

```

$num$ 即为特殊数个数。

特殊数在任何一种顺序中都会有 $1$ 的贡献。我们考虑非特殊数在什么时候会有贡献。

显然，当一个非特殊数的位置在一个特殊数位置的前面，那么这个非特殊数在当前顺序中就会有 $1$ 的贡献。

这样，我们想到通过枚举位置来计算非特殊数的贡献。

直接计算贡献很麻烦，考虑求出非特殊数在位置 $i$ 不会造成贡献的顺序数 $f_i$ 来用容斥做。

设当前位置为 $i$，那么首先要满足所有特殊数在位置 $i$ 前，共有 $\frac{(i-l)!}{(i-l-num)!}$ 种组合，位置 $i$ 的非特殊数有 $n-num$ 种选择，剩下的非特殊数的组合共有 $(n-num-1)!$ 种，所以 
$$f_i = \frac{(i-l)!}{(i-l-num)!} \times (n-num) \times (n-num-1)! $$

所以 $ans = n! \times n - \sum_{i=l}^r f_i $

部分代码：

```cpp
int l, r, n, num;
const int N = 1e7+3;
const int mod = 1e9+7;
bool vis[N];
int mul[N], inv[N];

inline int ksm (int a, int b) {
    ll ans = 1, base = a;
    while(b) {
        if(b & 1) ans = ans * base % mod;
        base = base * base % mod;
        b >>= 1;
    }
    return ans;
}

inline int calc (int n, int m) {
    if(n < m) return 0;
    if(n < 0 || m < 0) return 0;
    return 1ll * mul[n] * inv[n-m] % mod % mod;
}

ll ans;

int main () {
    io >> l >> r;
    n = r - l + 1;
    mul[0] = inv[0] = 1;
    re(i, r) mul[i] = 1ll * mul[i-1] * i % mod;
    inv[r] = ksm(mul[r], mod-2);
    pe(i, r-1) inv[i] = 1ll * inv[i+1] * (i+1) % mod;
    rep(i, l, r) {
        if(!vis[i]) {
            ++num;
            ste(j, i, r, i) vis[j] = 1;
        }
    }
    ans = 1ll * mul[n] * n % mod;
    rep(i, l, r) {
        ll tmp = 1ll * (n-num) * calc(i-l, num) % mod * mul[n-1-num] % mod;
        ans = (ans - tmp + mod) % mod;
    }
    io << ans;
}
```


---

## 作者：TonyYin (赞：0)

## 题意

给定 $[l, r]$ 区间，对于区间内所有数的一个顺序，每次取出最前面的数并将其倍数划去，当所有区间的数都被划去时停止。求所有排列中，取出的数的个数之和。

$1\leq l\leq r\leq 10^7$，答案对 $10^9+7$ 取模。

## 分析

对于每个顺序，有一些特殊的数必须被取，并且全部取完这些之后就不用再取了。

可以发现这些数的特征是：**除了自己外，没有因子在 $[l, r]$ 内**。由于没有因子在 $[l, r]$ 内，这些数不可能被提前划去。

回到题目对 $t(p)$ 的定义，可以知道对于任意排列 $p$，$t(p)$ 的数值，就是顺序中**最后**一个这样特殊的数**的位置**。

比如：在对于 $[3, 8]$ 的顺序 $5, 3, 8, 6, 7, 4$ 当中，$4$ 就是其中的一个关键数。$4$ 不能被区间内的其他数提前划掉，这个顺序的 $t(p)=6$.

先考虑如何快速找出这些数。

我们可以用线性筛法，预处理出每个数的最小值因子 $\min_x$，这样用 $\dfrac{x}{\min_x}$ 就可以求出 $x$ 的最大因子 $\max_x$. 如果 $\max_x < l$，那么 $x$ 就是特殊的数。

此时我们已经知道了特殊的数有哪些，考虑如何直接算出答案。

设一共有 $s$ 个特殊的数，则答案为：
$$
\sum_{i=s}^{n}{i\times \dbinom{i-1}{s - 1}\times (s-1)!\times s\times (n-s)!}
$$
可以理解为，枚举最后一个关键数的位置，统计其贡献：若有 $x$ 个排列使得最后一个关键数的位置为 $i$，那么其对答案的贡献为 $i\times x$.

现在要求的就是这个 $x$. 

首先，我们要在 $i$ 这个位置放一个关键数，这个数可以在关键数中随便取，方案数为 $s$.

$\tbinom{i-1}{s-1}$ 是说，在前 $i-1$ 个位置放进去 $s-1$ 个关键数，这 $s-1$ 个数的顺序随意，所以还要乘上一个 $(s-1)!$.

对剩下没放的 $n-s$ 个数，可以在所有空余的地方随便放，方案数为 $(n-s)!$.

于是我们得到上面的答案，预处理组合数后，循环一次求解即可。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int MAXN = 1e7 + 10, mod = 1e9 + 7;
int l, r;
bool is_prime[MAXN];
int min_div[MAXN], prime[MAXN], cnt = 0;//min_div[x] 为x的最小非1因子
int fac[MAXN], inv_fac[MAXN];
inline int power(int x, int k, int mod) { //快速幂
	int res = 1;
	while(k) {
		if(k & 1) {
			res = res * x % mod;
		}
		x = x * x % mod;
		k >>= 1;
	}
	return res;
}
inline void init() { //预处理组合数（阶乘 & 阶乘的逆元）
	fac[0] = 1;
	for(int i = 1; i <= r; i++) {
		fac[i] = fac[i - 1] * i % mod;
	}
	inv_fac[r] = power(fac[r], mod - 2, mod);
	for(int i = r - 1; i >= 0; i--) {
		inv_fac[i] = inv_fac[i + 1] * (i + 1) % mod;
	}
}
inline int C(int n, int m) { //求组合数，C(n, m) = C_n^m
	return fac[n] * inv_fac[m] % mod * inv_fac[n - m] % mod;
}
signed main() {
	scanf("%lld%lld", &l, &r);
	int n = r - l + 1;
	init();
	if(l == 1) { //这里需要特判，因为下面的因子并不包括1，对于l=1的情况容易直接得出答案
		cout << fac[n] * (n + 1) % mod * 500000004 % mod;
		return 0;
	}
	for(int i = 2; i <= r; i++) is_prime[i] = 1;
	for(int i = 2; i <= r; i++) { //线性筛，求每个数的最小因子
		if(is_prime[i]) {
			prime[++cnt] = i; min_div[i] = i;
		}
		for(int j = 1; j <= cnt && i * prime[j] <= r; j++) {
			is_prime[i * prime[j]] = false;
			min_div[i * prime[j]] = prime[j];
			if(i % prime[j] == 0) break;
		}
	}
	int sum = 0, ans = 0;
	for(int i = l; i <= r; i++) sum += (i / min_div[i] < l); //求特殊数的个数
	for(int i = sum; i <= n; i++) { //求解答案
		ans += i * C(i - 1, sum - 1) % mod * fac[sum] % mod * fac[n - sum] % mod;
		ans %= mod;
	}
	cout << ans % mod << endl;
	return 0;
}
```





---

## 作者：yzhang (赞：0)

[原题传送门](https://www.luogu.org/problem/P4562)

根据倍数关系珂以建出图，举个栗子：1,2,3要向6连边，1,2,4要向8连边……，这个珂以线性筛解决

这样我们珂以得出结论，要把所有度数为0的点选上，设这个数为$k$，则

$$Ans=\sum_{i=k}^n i \tbinom{i-1}{k-1} k! (n-k)!$$

$\tbinom{i-1}{k-1}$表示第$i$个取的点是度数为0的点，前面$i-1$个取的点要有$k-1$个度数为0的点的方案数，$k!$和$(n-k)!$表示度数是否为0的之内的排序方案数

暴力计算一下即可，复杂度为$O(n)$（实际后面那个组合数是珂以O(1)求的，但是瓶颈在于线筛）

```cpp
#include <bits/stdc++.h>
#define N 10000005
#define mod 1000000007
#define getchar nc
using namespace std;
inline char nc(){
    static char buf[100000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
inline int read()
{
    register int x=0,f=1;register char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    return x*f;
}
inline void write(register int x)
{
    if(!x)putchar('0');if(x<0)x=-x,putchar('-');
    static int sta[20];register int tot=0;
    while(x)sta[tot++]=x%10,x/=10;
    while(tot)putchar(sta[--tot]+48);
}
inline int power(register int a,register int b)
{
    int res=1;
    while(b)
    {
        if(b&1)
            res=1ll*res*a%mod;
        a=1ll*a*a%mod;
        b>>=1;
    }
    return res;
}
int l,r,n,ans,cnt;
int ispr[N],pr[N],tot,fac[N],invf[N];
inline void init()
{
    ispr[1]=pr[1]=1;
    if(l==1)
    {
        cnt=1;
        return;
    }
    for(register int i=2;i<=r;++i)
    {
        if(!ispr[i])
            pr[++tot]=i,cnt+=(i>=l);
        for(register int j=1;j<=tot&&pr[j]*i<=r;++j)
        {
            ispr[pr[j]*i]=1;
            if(i<l&&i*pr[j]>=l)
                ++cnt;
            if(i%pr[j]==0)
                break;
        }
    }
}
int main()
{
    l=read(),r=read(),n=r-l+1;
    init();
    fac[0]=1;
    for(register int i=1;i<=n;++i)
        fac[i]=1ll*fac[i-1]*i%mod;
    invf[n]=power(fac[n],mod-2);
    for(register int i=n-1;i>=0;--i)
        invf[i]=1ll*invf[i+1]*(i+1)%mod;
    for(register int i=cnt;i<=n;++i)
        ans=(0ll+ans+1ll*i*fac[i-1]%mod*invf[i-cnt]%mod)%mod;
    write(1ll*ans*invf[cnt-1]%mod*fac[cnt]%mod*fac[n-cnt]%mod);
	return 0;
}
```

---


# [JSOI2009] 瓶子和燃料

## 题目描述

jyy 一直想着尽快回地球，可惜他飞船的燃料不够了。有一天他又去向火星人要燃料，这次火星人答应了，要 jyy 用飞船上的瓶子来换。jyy 的飞船上共有 $N$ 个瓶子（$1 \leq N \leq 1000$），经过协商，火星人只要其中的 $K$ 个。 

jyy 将 $K$ 个瓶子交给火星人之后，火星人用它们装一些燃料给 jyy。所有的瓶子都没有刻度，只在瓶口标注了容量，第 $i$ 个瓶子的容量为 $V _ i$（$V _ i$ 为整数，并且满足 $1 \leq V _ i \leq 10 ^ 9$） 。火星人比较吝啬，他们并不会把所有的瓶子都装满燃料。他们拿到瓶子后，会跑到燃料库里鼓捣一通，弄出一小点燃料来交差。jyy 当然知道他们会来这一手，于是事先了解了火星人鼓捣的具体内容。

火星人在燃料库里只会做如下的 $3$ 种操作：

1. 将某个瓶子装满燃料；
2. 将某个瓶子中的燃料全部倒回燃料库；
3. 将燃料从瓶子 $a$ 倒向瓶子 $b$，直到瓶子 $b$ 满或者瓶子 $a$ 空。燃料倾倒过程中的损耗可以忽略。

火星人拿出的燃料，当然是这些操作能得到的最小正体积。jyy 知道，对于不同的瓶子组合，火星人可能会被迫给出不同体积的燃料。jyy 希望找到最优的瓶子组合，使得火星人给出尽量多的燃料。

## 说明/提示

选择第 $2$ 个瓶子和第 $3$ 个瓶子，火星人被迫会给出 $4$ 体积的容量。

## 样例 #1

### 输入

```
3 2
3
4
4```

### 输出

```
4```

# 题解

## 作者：logfk (赞：22)

裴蜀定理 对任何整数a、b和它们的最大公约 数d，关于未知数x和y的线性不定方程（称为裴蜀等式）：若a,b是整数,且gcd(a,b)=d，那么对于任意的整数x,y,ax+by都一定是d的倍数，特别地，一定存在整数x,y，使ax+by=d成立。

它的一个重要推论是：a,b互质的充要条件是存在整数x,y使ax+by=1.


------------
感谢度娘

这是一道运用裴蜀定理的数论题，通过题意也可得知，火星人只会给你最少而又不为零的燃料。（火星人真的很强）


------------

我们来模拟一下火星人倒燃料的过程：

样例：3 4 4

显然只有两种方案：3 4和4 4

3（①） 4（②）：把②倒入燃料，然后倒给①，把①倒掉，于是乎，只剩下②的1单位燃料。

4 4：由于火星人会给你燃料，所以无论怎么倒都会有一个瓶子有4单位燃料。

结论就显而易见了，其实就是要从n个数找出k个数，使最大公约数最大。

首先分解因数：
```cpp

    for(i=1;i<=n;i++)
    {
        cin>>a[i];
        for(j=1;j*j<=a[i];j++)
        {
            if(a[i]%j!=0) continue;
            if(!f[j]) p[++t]=j;//第一次进入，证明有此因数
            f[j]++;//能装的个数++ 
            if(!f[a[i]/j]) p[++t]=a[i]/j;//同上
            if(j*j!=a[i]) f[a[i]/j]++;
            //判相等，就是不重复加一个因数，因为只有一个瓶子
        }
    }
```

然后就把所有的因数枚举：
```cpp
    for(i=1;i<=t;i++)
    {
        if(f[p[i]]>=k) ans=max(ans,p[i]);//不断地查找，找到最大的且因子数量大于要选择瓶子数的就更换最大值。
    }
```

最后进行输出，于是一行新鲜的代码出炉了：
```cpp
#include<iostream>
using namespace std;
long long a[1010],f[10000010],p[10000010],t,ans;//a体积,f能装x体积的个数，p燃料 
int main()
{
    int n,k;
    cin>>n>>k;
    for(int i=1;i<=n;i++) cin>>a[i];
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j*j<=a[i];j++)
        {
            if(!a[i]%j) continue;
            if(!f[j]) p[++t]=j;//第一次进入 
            f[j]++;//能装的个数++ 
            if(!f[a[i]/j]) p[++t]=a[i]/j;//同 
            f[a[i]/j]++;//同 
            if(j*j==a[i]) f[j]--;//判相等 
        }
    }
    for(int i=1;i<=t;i++)
    {
        if(f[p[i]]>ans) ans=max(ans,p[i]);//略 
    }
    cout<<ans<<endl;
}
```

**于是就RE了**

原因是因为开了了大量无用的空间，f、p数组中的一些空间不一定应用，造成了很大的空间浪费，而在空间限制的面前，数组已经不能满足我们的需要，我们需要用到映射器，也就是MAP，STL容器能够节省大量的空间，它在存入数据时会随数量的增加而增加，貌似是呈2^n递增的，所以它正是适合这道题的存储器（~~为什么要用这个名字啊~~）
```cpp
#include<map>
#include<cstdio>
using namespace std;
int a[1010],p[5000010],t,ans;//a体积,f能装x体积的个数，p燃料
map<int,int>f; 
int max(int x,int y){
    return x>y?x:y;
}
int read()//快读根据自己需要酌情添加
{
    int x=0,y=1;char c=getchar();while(c<'0'||c>'9'){y=-y;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+(c-'0');c=getchar();}
    return x*y;
}
int main()
{
    int n=read(),k=read(),i,j;
    for(i=1;i<=n;i++)
    {
        a[i]=read();
        for(j=1;j*j<=a[i];j++)
        {
            if(a[i]%j!=0) continue;
            if(!f[j]) p[++t]=j;//第一次进入 
            f[j]++;//能装的个数++ 
            if(!f[a[i]/j]) p[++t]=a[i]/j;//同 
            if(j*j!=a[i]) f[a[i]/j]++;//判相等 
        }
    }
    for(i=1;i<=t;i++)
    {
        if(f[p[i]]>=k) ans=max(ans,p[i]);//略 
    }
    printf("%d",ans);
    return 0;
;}
```

PS:map前一个定义是驱动，后一个是存储内容，比如说可以把f["apple"]=666,这种操作在正确定义的情况下是允许的。

---

## 作者：gyyyyx (赞：10)

首先，我们来模拟一下火星人倒油过程。

假设给火星人两个瓶子，容量分别为 $a$，$b$。

不妨设 $a>b$。

那火星人第一次会选多少燃料呢？

火星人一定会先将 $a$ 倒满，将 $a$ 的燃料倒满 $b$，再将 $b$ 的燃料倒回到燃料库。重复几次，燃料就只剩下 $a\ mod\ b$。

然后再重复一下，又因为火星人一定会给你燃料，最后就会得到一个结果：$\gcd(a,b)$。

那如果要三个，四个，甚至更多个瓶子呢？其实简单推理一下结论也是一样的，等于所有选择的瓶子的容量的最大公约数。

也就是说我们要找到 $k$ 个瓶子，使得最大公约数最大。

很多人就卡在了这一步不知道怎么办。

其实我们都十分思维定式。

最大公约数就是从所有公约数中选出最大的。

那我们为什么不可以先找到公约数呢？

而公约数又是从所有约数集合中找出公共的部分。

我们可以将所有数的约数都分解出来，然后找出是否有某个约数出现的次数大于等于 $k$，然后在这些约数中找到最大的就是答案。

应该解释的挺清楚了 ~~(bushi~~ 直接看代码：

```cpp
#include<bits/stdc++.h>
#define N 10000005
using namespace std;
map <int,int> f;
vector <int> p;
int n,k,a,ans;
int main(){
    scanf("%d%d",&n,&k);
    for(int i(1);i<=n;++i){
        scanf("%lld",&a);
        for(int j(1);j*j<=a;++j){
            if(a%j) continue;
            if(!f[j]) p.push_back(j);
            ++f[j];
            if(!f[a/j]) p.push_back(a/j);
            ++f[a/j];
            if(j*j==a) --f[j];
        }
    }
    for(int i(0);i<p.size();++i)
        if(f[p[i]]>=k) ans=max(ans,p[i]);
    printf("%d\n",ans);
    return 0;
}
```

✿✿ヽ(°▽°)ノ✿

---

## 作者：XUCHENGHUI (赞：7)

[更好的阅读体验点这里](https://blog.csdn.net/stevensonson/article/details/80657753)

这题是一道运用裴蜀定理的题目。
裴蜀定理的具体内容如下：

若a,b是整数,且gcd（a,b)=d，那么对于任意的整数x,y,ax+by都一定是d的倍数，特别地，一定存在整数x,y，使ax+by=d成立。

它的一个重要推论是：a,b互质的充要条件是存在整数x,y使ax+by=1.

裴蜀定理可以用欧几里德算法来证明（也就是辗转相除法）

现在我们回到题目。由于裴蜀定理，我们可以发现：用容量为x和y瓶子互相倒，那么最终能倒出的最小值就为gcd(x,y)
很显然，这个可以由ax+by一定为d的倍数，而最小正倍数就是d。并且必定存在整数x,y，使ax+by=d成立这两个定理来证明。所以题目就变成了：n个数里面选择k个数，使他们的gcd最大。由于题目的数据范围，这道题就变得十分简单，我们只要用sqrt(n)来分解所有的因数，然后用map记录即可。

```cpp
#include<bits/stdc++.h>
#define MAXN 1005
#include<map>
using namespace std;
int read(){
    char c;int x=0,y=1;while(c=getchar(),(c<'0'||c>'9')&&c!='-');
    if(c=='-') y=-1;else x=c-'0';while(c=getchar(),c>='0'&&c<='9')
    x=x*10+c-'0';return x*y;
}
int n,k,f[MAXN],re[5000005],top,ans;
map<int,int> a;
int main()
{
    n=read();k=read();
    for(int i=1;i<=n;i++) f[i]=read();
    for(int i=1;i<=n;i++)
     for(int j=1;j*j<=f[i];j++){
        if(f[i]%j!=0) continue;
        if(!a[j]) re[++top]=j;a[j]++;
        if(!a[f[i]/j]) re[++top]=f[i]/j;a[f[i]/j]++;
        if(j*j==f[i]) a[j]--;
     }
    for(int i=1;i<=top;i++)
       if(a[re[i]]>=k) ans=max(ans,re[i]);
    printf("%d",ans);
    return 0;
}
```

---

## 作者：AcerMo (赞：7)

暴力求解，预处理每个数的因子，排个序，然后在出现次数大于等于k次的因子中找到最大的数

---

## 作者：_JF_ (赞：5)

## [JSOI2009] 瓶子和燃料

根据裴蜀定理可以知道，$ax+by$ 能凑出最小的正整数为  $gcd(a,b)$。

所以选择几个瓶子，答案就是几个瓶子的 $gcd$。故将每个数分解因数,找最大且出现至少 $k$ 次的因数即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N =1e6+10;
map<int,int> a;
inline long long read()
{
    register long long x=0,f=0;
    register char t=getchar();
    while(t<'0'||t>'9')f^=(t=='-'),t=getchar();
    while(t>='0'&&t<='9')x=(x<<3)+(x<<1)+(t^48),t=getchar();
    return f?-x:x;
}
int main()
{
	int n,k;
	n=read(),k=read();
	int maxx=-1e6-10;
	for(int i=1;i<=n;i++)
	{
		int v;
		v=read();
		for(int j=1;j*j<=v;j++)
		{
			if(v%j==0)
			{
				a[j]++;
				a[v/j]++;
			}
		}
		if(sqrt(v)*sqrt(v)==v)
			a[sqrt(v)]--;
	}
	for(map<int,int>::iterator it=a.end();it!=a.begin();it--)
	{
		if((*it).second>=k)
		{
			cout<<(*it).first<<endl;
			return 0;
		}
	}
}
```


---

## 作者：zhuxiangrui_2010 (赞：3)

## 题意
从 $n$ 个瓶子里选 $k$ 个，使得火星人操作之后燃料最多。
## 思路
前置知识：[裴蜀定理](https://answer.baidu.com/answer/land?params=DQ9OEfOZXWvOgdb74%2FwI9IOXU1dBcOhTNUZMNU%2Fj%2FuSmR8WE9HQaJzZYRqOPSEUGyUgwbjtHXWeUyGXJ9MPMT%2F3ynRaEFD5OrL1GgGdMgMbxTFdV0ydS7B0RScsKkASKDQOptXQ08VBl%2FJUIW2XmIZ61NfyowCQ4GSg1ZWv%2BVMgmKbPHuishQ3POF%2B3isEvh9XiZV2G%2F0JdTqWmEToyTzQ%3D%3D&from=dqa&lid=f61104fe0031d05d&word=%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86)。

~~由题意得~~，火星人给你的燃料最少但**大于零**，而且必由 $k$ 个瓶子相加减组成。

而通过裴蜀定理我们知道，$ax+by$ 一定是 $\gcd\left(a,b\right)$ 的倍数。即在正整数范围内，$\min\left\{ax+by\right\}=\gcd\left(a,b\right)$。

所以，火星人给你的燃料一定是这 $k$ 个瓶子的最大公约数。

由于 $n$ 较小而 $V_i$ 较大，所以考虑存所有 $V_i$ 的因数，输出存入次数大于等于 $k$ 的数之中的最大值。
## 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e7+5;
map<int,int> f;
int n,k,t=0,p=-1,a[N];
signed main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		int x;
		cin>>x;
		for(int j=1;j<=sqrt(x);j++){
			if(x%j==0){
				if(f[j]==0){
					a[++t]=j;
				}
				f[j]++;
				if(x/j!=j){
					if(f[x/j]==0){
						a[++t]=x/j;
					}
					f[x/j]++;
				}
			}
		}
	}
	for(int i=1;i<=t;i++){
		if(f[a[i]]>=k){
			p=max(p,a[i]);
		}
	}
	cout<<p;
    return 0;
}
```

---

## 作者：WaterSun (赞：3)

[更好的阅读体验](https://watersun.top/%5B%E9%A2%98%E8%A7%A3%5DP4571%20[JSOI2009]%20%E7%93%B6%E5%AD%90%E5%92%8C%E7%87%83%E6%96%99/)

# 思路

首先考虑两个瓶子容量分别为 $x,y$ 互相倒的情况。发现每一次都是将剩余的液体减少 $x$ 或者 $y$，因此这两个瓶子的贡献就是 $ax + by$，其中 $a,b$ 是常数。

根据裴蜀定理，$\min\{ax + by\} = \gcd(x,y)$。拓展到多个数，就是使得选取的 $k$ 个数的 $\gcd$ 最大。

# Code

```cpp
#include <bits/stdc++.h>
#define re register
#define int long long

using namespace std;

const int N = 1010;
int n,k,ans;
unordered_map<int,int> vis;
vector<int> p;

inline int read(){
	int r = 0,w = 1;
	char c = getchar();
	while (c < '0' || c > '9'){
		if (c == '-') w = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9'){
		r = (r << 3) + (r << 1) + (c ^ 48);
		c = getchar();
	}
	return r * w;
}

signed main(){
	n = read(),k = read();
	for (re int i = 1;i <= n;i++){
		int x;
		x = read();
		for (re int j = 1;j * j <= x;j++){
			if (x % j == 0){
				p.push_back(j),vis[j]++;
				if (j != x / j) p.push_back(x / j),vis[x / j]++;
			}
		}
	}
	for (auto x:p){
		if (vis[x] >= k) ans = max(ans,x);
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：the_Death (赞：3)

这是~~我第一个自己没看题解写出来的~~一道数学题。

众位大神，这个菜鸡写的比较啰嗦，不喜请划过

------------
如果只看两个瓶子相互倒的话，就是一道小学数奥题——结论就是两者的GCD,那么我们就可以猜测这个结论在拓展到n个数的时候也成立。关于这个成立的原因，第一份题解写的很好，我就当一个补充，写一写几个式子来再证一下两个瓶子互相倒吧。


------------
首先，我们不妨假设有两个瓶子a,b,且Va<Vb,且Va=x,Vb=y。每一次倒的定义就是：油池->b,b->a,a->油池,b->a。
 
|  |第一次  |第二次  |第三次  |第四次  |  第N次   |
| :----------- | :----------- | :----------- | :----------- | :----------- | :----------- |:-----------|
|a剩余 |y-x  |2y-2x  |3y-3x  |4y-4x  |ny-nx  |
|a差多少满  |2x-y  |3x-2y  |4x-3y  |5x-4y  |(n+1)y-nx  |

我们可以~~清晰的~~看到，每次a的剩余都符合模式a*x-b*y，所以我们可以知道，当两个瓶子相互倒的话，就是符合裴蜀定理的a*x+b*y=d，所以，就可以解决了。而当拓展到多个时，就可以想，先找两，把两个这么相互倒可以找到的最大值再当成一个瓶子，放入，以此类推。所以题目就成了，给你N个数，任选k个数，求这k个数的GCD最大可以是多少


------------
由于题目的范围，我们可以用试除法求出这n个数的因子,然后用一种玄学的统计众数方法找到K个数的GCD/这个找众数的方法叫什么名字我忘了，但大致思路就是——把每个因数组成的数组先排序，然后从后向前扫，用一个变量cnt记录某个数出现的次数。如果这个数所在的位置的上一个位置的数和它一样，cnt++,否则就变为1.如果这个数出现过K次以上，那么在它清零前，cnt就会大于k。


------------
下面就是代码了
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
int n,k,a[1000005],top,cnt=1,x;
int main() {
	scanf("%d%d",&n,&k);
	for(register int i=1;i<=n;i++){
		scanf("%d",&x);
		for(register int i=1;i<=sqrt(x);i++){//试除法处理
            if(x%i==0){
                a[++top]=i;
                if(i*i!=x) a[++top]=x/i;
            }
        }
	}sort(a+1,a+top+1);
	for(register int i=top-1;i>0;i--) {
		//众数的统计
		if(a[i]==a[i+1]) cnt++; else cnt=1;
		if(cnt>=k){
			printf("%d",a[i]);
            system("pause");
			return 0;
		}
	}
	system("pause");
	return 0;
}   
```


------------
国际惯例，谢谢观赏


---

## 作者：StayAlone (赞：2)

看了一下远古题解，表示格式和内容非常谔谔。

题意很是不清楚。

### 题意

有 $n$ 个瓶子，每个瓶子有一个容量。从中选 $k$ 个交给火星人，火星人会在一些操作后将装了燃料的瓶子给你。火星人很不善良，想要尽量少的给你，但是为了不显得吝啬，不能不给你。火星人只能执行以下操作：

1. 装满一个瓶子；
2. 倒空一个瓶子；
3. 将一个瓶子中的燃料倒入另一个瓶子，直到那个瓶子满了或者这个瓶子空了。

问你最多能获得多少燃料。

### 思路

经典问题。

先考虑两个瓶子的情况。设容量分别为 $x,y$，且 $x<y$。

当 $x$ 是满的，$y$ 是空的时：

1. 倒空：相当于减去 $x$。
2. 倒满：相当于加上 $y$。
3. $x\to y$：要么不变，要么同倒空。


当 $y$ 是满的，$x$ 是空的时：

1. 倒空：相当于减去 $y$。
2. 倒满：相当于加上 $x$。
3. $y\to x$：若再倒掉 $x$，相当于减去 $x$；若再倒掉 $y$，相当于减去 $y-x$。

当 $x,y$ 内都有燃料的情况也可以类似分析。发现无论怎样，总燃料都可以表示为 $ax + by$。根据裴蜀定理，$ax+by=k$ 的所有解都满足 $\gcd(x,y)\mid k$，所以 $ax+by$ 的最小正整数解为 $\gcd(x,y)$。换句话说，当给外星人容量为 $x,y$ 的两个瓶子时，他会给你 $\gcd(x,y)$ 的燃料。

推广到 $k$ 个瓶子，外星人将会给你 $\gcd(a_1,a_2,a_3,\cdots,a_k)$ 的燃料。所以现在要在 $n$ 个数中选取 $k$ 个，使得这个值最大。

只需要分解出每个数的所有因数，记录 $cnt_x$ 表示有多少个数含有因数 $x$。选取最大的 $x$ 满足 $cnt_x\geq k$ 即可。时间复杂度 $\mathcal O(n\sqrt a)$。

好吧我为了图方便写了 map 居然也能过，但这已经不是本题解的重点了。用桶实现就行。

分解因数时应当注意完全平方数的情况，不过这个题好像没卡。

[AC code 记录](https://www.luogu.com.cn/record/100806041)
```cpp
int n, k, a[1010];
map <int, int> cnt;

int main() {
	read(n, k); rer(i, 1, n, a);
	rep1(i, 1, n) {
		rep1(j, 1, sqrt(a[i])) if (a[i] % j == 0) {
			++cnt[j];
			if (j * j != a[i]) ++cnt[a[i] / j];
		}
	}
	int ans = 1;
	for (auto v : cnt) if (v.snd >= k && v.fst > ans) ans = v.fst;
	printf("%d", ans);
	rout;
}
```

---

## 作者：When (赞：2)

#### 前置芝士

>  **裴蜀定理**
>
> 若$a$，$b$是整数，且$gcd(a,b)=d$，那么对于任意的整数$x$，$y$，$ax+by$都一定是$d$的倍数，特别地，一定存在整数$x$，$y$，使$ax+by=d$成立。
>
> 推广: $a_1,a_2,a_3...a_n$为$n$个整数，$d$是它们的最大公约数，那么存在整数$x_1...x_n$使得$x_1\times a_1+x_2\times a_2+...x_n\times a_n=d$。

#### 思路

根据裴蜀定理，外星人所给出的燃料数量为$k$个瓶子容积的$gcd$。因此问题就转化为：从$n$个数中选出$k$个数，使得它们的$gcd$最大。

我们可以将每个数的因数分解出来（**并不只是质因数**），记录每一个因子的出现次数，排序以后选出最大的出现次数$\geq k$的就可以了。

另外，本题数值较大，需要开$map$。

#### 参考代码

```cpp
#include <cstdio>
#include <algorithm>
#include <map>

using namespace std;

const int maxn = 1e6 + 10;
int n,cnt,k;
struct Num{
    int val,num;
}p[maxn];
map<int,int> T;

bool cmp(Num x, Num y){return x.val > y.val;}

int main(){
    scanf("%d%d", &n, &k);
    for(int i = 1; i <= n; ++ i){
        int v; scanf("%d", &v);
        for(int j = 1; j * j <= v; ++ j){
            if(v % j == 0){
                if(!T[j]) T[j] = ++ cnt, p[cnt].val = j, p[cnt].num ++;
                else p[T[j]].num ++;
                int fff = v / j;
                if(fff == j) continue;
                if(!T[fff]) T[fff] = ++ cnt, p[cnt].val = fff, p[cnt].num ++;
                else p[T[fff]].num ++;
            }
        }
    }
    sort(p + 1, p + 1 + cnt, cmp);
    for(int i = 1; i <= cnt; ++ i)
        if(p[i].num >= k) return printf("%d\n", p[i].val), 0;
    return 0;
}
```



---

## 作者：kiwabo (赞：1)

AcerMo：暴力求解，预处理每个数的因子，排个序，然后在出现次数大于等于$k$次的因子中找到最大的数。

完事

------------
是不可能的。

根据[裴蜀定理](https://baike.baidu.com/item/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/0)
若 $a$，$b$ 是整数，且 $\gcd(a,b)=d$，那么对于任意的整数 $x$，$y$，$ax+by$ 都一定是 $d$ 的倍数，特别地，一定存在整数 $x$,$y$ 使 $ax+by=d$ 成立。

可以得知其实题目就是在给出的 $n$ 个数里找 $k$ 个数使得他们的最大公约数最大。

言后就可以~~乱搞~~暴力解题了。

`AC CODE`(无（you）反作弊）：
```cpp
#include<iostream>
using namespace std;
int a[1005],p[5000005],t,ans;
map<int,int>f; 
int max(int x,int y)
{
    return x>y?x:y;
}
int main()
{
    int n,k,i,j;
    cin>>n>>k;
    for(i=1;i<=n;i++)
    {
        cin>>a[i];
        for(j=1;j*j<=a[i];j++)
        {
            if(a[i]%j!=0)
                continue;
            if(!f[j])
                p[++t]=j;
            f[j]++;
            if(!f[a[i]/j])
                p[++t]=a[i]/j; 
            if(j*j!=a[i])
                f[a[i]/j]++;
        }
    }
    for(i=1;i<=t;i++)
    {
        if(f[p[i]]>=k)
            ans=max(ans,p[i]);
    }
    cout<<ans;
}
```
完事（真的）！！！
------------

---

## 作者：icefake (赞：1)

# P4571 [JSOI2009]瓶子和燃料


### **题意**
题目虽然长，但题意应该很好理解，就是**在给出的 $n$ 个数中找出 $k$ 个数使得他们的最大公约数最大**。

---

### **分析**
知道了题意，应该就能~~一眼~~看出这是一道要用裴蜀定理的题目了——而且还比较板（谔谔

如果不知道裴蜀定理的可以看一下下面的资料，知道的就可以跳过了

> ### 贝祖定理（裴蜀定理）
若 $a, b$ 是整数，且 $gcd(a, b) = d$;
那么对于任意的正整数 $x, y，ax + by = m$ 中的 $m$ 一定是 $d$ 的倍数;
并且一定存在整数 $x, y$ 使得 $ax + by = d$ 成立，且不止一组;

**火星人倒出来的燃料量一定是所选出来的 $k$ 最大公约数的整数倍**

所以我们就可以将题目化简为以上题意中的粗体字

---

### **至于具体实现**
大致算法都很前面几位dalao差不多

但是——

在寻找最大的那个 $gcd$ 的时候我觉得可以加一个 $check$ 函数，然后在计数的时候，如果这个计数比 $k$ 大了，那么就将这个数和 $Max$（初始为 $0$ ）进行比较，然后让 $Max$ 取 $max$，这样最后就可以直接输出了，也不用再用一次循环来寻找 $Max$。

（具体实现见本蒟蒻的代码中的注释

---

### **$AC$ 代码**
终于可以放上代码了！！！ $QAQ$ 
```cpp
#include<bits/stdc++.h>

using namespace std;

int n, k, tem, v, Max = 0;
map <int, int> wrt;

inline int read(){//快读
  	int x=0,w=1;char ch=0;
  	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
  	while(ch>='0'&&ch<='9'){x=x*10+(ch-'0');ch=getchar();}
  	return x*w;
}

inline void write(int x){//快写
  	static int sta[35];int top=0;
  	do{sta[top++]=x%10,x/=10;}while (x);
  	while(top)putchar(sta[--top]+48);
}

void check(int x)//check
{
	if(wrt[x] >= k) {//条件是必须比 k 大
		Max = max(Max, x);//取大的那一个
	}
	return ;
}

signed main()
{
	n = read(); k = read();
	for(int i = 1; i <= n; i ++) {
		v = read();
		for(int l = 1; l <= sqrt(v); l ++) {
			if(v % l == 0) {
				wrt[l] ++; check(l);//check wrt[l]
				if(l * l != v) wrt[v / l] ++, check(v / l);//check wrt[v/l]
			}
		}
	}
	write(Max);//直接输出
	return 0;//完结，只有2个for
}
```





---

## 作者：ComeTheWay (赞：0)

update 20240731 19：52 修了一下细节。

update 20240801 20：03 修了上一个 update 的拼写问题，修了一些细节。

update 20240804 20：01 修了上一个 update 的没加空格的问题，修了一些细节。

update 20240921 21：50 （作者改这么晚一看就是被文化课迫害了）修了一些细节。

dalao 们已经把这题说的很清楚了，但蒟蒻还是来发一篇与众不同的题解。

[请各位先了解一下更相减损术。](https://baike.baidu.com/item/%E6%9B%B4%E7%9B%B8%E5%87%8F%E6%8D%9F%E6%9C%AF/449183?fr=ge_ala)


>第一步：任意给定两个正整数；判断它们是否都是偶数。若是，则用 $2$ 约简；若不是则执行第二步。
第二步：以较大的数减较小的数，接着把所得的差与较小的数比较，并以大数减小数。继续这个操作，直到所得的减数和差相等为止。
则第一步中约掉的若干个 $2$ 的积与第二步中等数的乘积就是所求的最大公约数。
其中所说的“等数”，就是公约数。求“等数”的办法是“更相减损”法。
>
>来自百度百科。

我们注意到，如果两个数不停减来减去，得到的最小的数字只有可能是两数之间的**最大公约数**。

我们进一步推论，如果有多个数，互相减来减去，得到的最小数只能是他们的**最大公约数**。

那么我们明确了思路：从 $n$ 数里选 $k$ 个，使这 $k$ 个数的最大公约数最大。这就涉及到各位的 dfs 功夫了，这里就不贴代码了。

**但是**！这一定会超时的。怎么办呢？

其实我们大可不必直接求出来，我们可以直接分解因数（不是质因数），然后用数组记录每个因数出现的次数，在出现次数超过 $k$ 的因数中寻找最大值，这里还是不贴代码。

**但是**！你自己试试，RE $9$ 个点，为什么呢？

原因就是因数太大了，数组存不下，所以我们又用上了 STL 库：[map](https://zh.cppreference.com/w/cpp/container/map)。

我们可以建立 map 来映射因数与出现次数，这样就可以 AC 了！

完整代码如下：


```cpp
#include <bits/stdc++.h>
using namespace std;
int a, n, k;
vector<int> p;
map<int, int> d;
int ans = 1;

signed main() {
    cin >> n >> k;
    for (int i = 1; i <= n; i++) {
        cin >> a; // 其实这边不用开数组的。
        for (int j = 1; j <= sqrt(a); j++) { // 枚举因子，为了省时只需枚举到 sqrt(a)。
            if (a % j == 0) {
        		if (d[j] == 0) p.push_back(j);
	            if (d[a / j] == 0) p.push_back(a / j); // 储存因子。
	            d[j]++, d[a / j]++; // 记录出现次数。
	            if (j * j == a) d[a / j] --; // 注意一下特判 。
			}
        }
    }
    for(auto i : p) if (d[i] >= k /*这是进行取最大值的先决条件。*/) ans = max(ans, i);
    cout << ans;
    return 0;
}
// 不知可否说一句，这是我的第一份题解？
```

再见啦，请支持一下！

---

## 作者：jiayixuan1205 (赞：0)

## 题解：P4571 [JSOI2009] 瓶子和燃料
### 题意分析
由题可知，火星人一定会尽可能让你可以获得的燃料少。

那么，我们先来分析他们的三种操作，前两种操作显然可以忽略，真正对最终结果产生影响的只有第三种操作。因此，他们就会不断进行第三种操作，在不同瓶子中颠倒来获得最小值。我们令两个瓶子的容量 $a$ 大于 $b$，那么容易得到，每次获得的最小燃料值就是 $a \bmod b$，易得，最后得到的值就是这几个数的最大公因数。因此，我们就把问题转化成了选取 $k$ 个数，使他们的最大公因数最大，所求得的最大值就是我们可获得的最大值。
### 做法分析
我们可以将每个输入的数分解因数，将求出的因数个数进行记录，最后在所有因数中寻找出现次数大于 $k$ 次的因数，取最大值即可。
### 代码展示
```cpp
#include<bits/stdc++.h>

using namespace std;

const int N = 1e7+10;
map<int,int> mp;//记录因数及其出现次数 
vector<int> v;//记录出现过的因数 
int n,k,a,ans;

int main()
{
	std::ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>k;
	for(int i=1;i<=n;i++)
	{
		cin>>a;
		for(int j=1;j*j<=a;j++)
		{
			if(a%j) continue;
			if(!mp[j]) v.push_back(j);
			mp[j]++;
			if(!mp[a/j]) v.push_back(a/j);
			mp[a/j]++;
			if(j*j==a) mp[j]--; 
		}
	}
	for(int i=0;i<v.size();i++)
	{
		if(mp[v[i]]>=k) ans=max(ans,v[i]);
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：CQ_JiJi (赞：0)

# $\tt{Solution}$
这个题的难度在于分析题目的本质，如果我告诉你这题就是叫你在给定的 $n$ 个数中选 $k$ 个使得这 $k$ 个数的最大公因数最大，我相信大家应该都会做。

你会发现，使用容量为 $a,b$ 的两个瓶子最终能得到的最小燃料是 $\gcd(a,b)$，由裴蜀定理可得 $ax+by$ 为 $\gcd(a,b)$ 的倍数，而且将容量为 $a,b$ 的瓶子分别倒空的次数又正好对应这里的 $x,y$，而此时的最小正整数便是 $\gcd(a,b)$ 了。由此可以推展得到 使用容量为 $a_1,a_2,\dots,a_k$ 的瓶子可以得到 $\gcd(a_1,a_2,\dots,a_k)$ 的燃料。

具体的处理方法就是存下来 $n$ 个数中，含有 $x$ 因子的数量 $cnt_x$，最后的答案就是最大的满足 $cnt_x \geq k$ 的 $x$ 了。

```cpp
/*
	Luogu name: Symbolize
	Luogu uid: 672793
*/
#include<bits/stdc++.h>
#define int long long
#define pii pair<int,int>
#define x first
#define y second
#define rep1(i,l,r) for(register int i=l;i<=r;++i)
#define rep2(i,l,r) for(register int i=l;i>=r;--i)
#define rep3(i,x,y,z) for(register int i=x[y];~i;i=z[i])
#define rep4(i,x) for(auto i:x)
#define debug() puts("----------")
const int N=1e5+10;
const int inf=0x3f3f3f3f3f3f3f3f;
using namespace std;
int n,k,ans;
map<int,int> cnt;
int read()
{
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return f*x;
}
signed main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	n=read();
	k=read();
	rep1(i,1,n)
	{
		int x=read();
		rep1(j,1,sqrt(x))
		{
			if(x%j==0)
			{
				if(j*j==x) ++cnt[j];
				else ++cnt[j],++cnt[x/j];
			}
		}
	}
	rep4(x,cnt) if(x.x>ans&&x.y>=k) ans=x.x;
	cout<<ans<<endl;
	return 0;
}

```

---

## 作者：糖hhhh？ (赞：0)

莫名想到这题[P1414](https://www.luogu.org/problem/P1414)

其实两题的思路差不多，这题数据大一些

思路和证明大佬们讲得很清楚了qwq

这里提供一种hash乱搞算法qwq


```
#include <bits/stdc++.h>
#define re register
#define mod 9909983
using namespace std;
inline int read(){}
inline void write(int x){}
int n,maxx,p;
int num[mod+10],number[mod+10];
inline void jkl(int x){
	for(re int i=1;i<=sqrt(x);i++)
	if(x%i==0)
	{
		int t=i;
		if(number[t%mod]==0){
			number[t%mod]=i;
			num[t%mod]=1;
		}
		else{
			while(number[t%mod]!=i)t++;
			num[t%mod]++;
		}
		
		t=x/i;
		if(number[t%mod]==0){
			number[t%mod]=x/i;
			num[t%mod]=1;
		}
		else{
			while(number[t%mod]!=x/i)t++;
			num[t%mod]++;
		}
	}
}
int main()
{
	n=read();p=read();
	for(re int i=1;i<=n;i++)jkl(read());
	for(re int i=1;i<mod;i++)
	if(num[i]>=p)maxx=max(maxx,number[i]);
	write(maxx);
	return 0;
}
```


---

## 作者：大菜鸡fks (赞：0)

这题我是先猜了一个结论：最小值是最大公约数。

后来感性的想了一下：每个瓶子里的燃料量是自己瓶子的容量-（0/1）*每个瓶子的容量

里面的0和1可以任意取，然后这个形式就是裴蜀定理的扩展了。

```cpp
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
const int N=1005;
int n,k,a[N*N],cnt;
inline void init(){
	scanf("%d%d",&n,&k);
	for (int i=1;i<=n;i++){
		int x;
		scanf("%d",&x);
		for (int j=1;j<=(int)sqrt(x);j++){
			if (x%j==0){
				a[++cnt]=j;
				if (j*j!=x){
					a[++cnt]=x/j;
				}
			}
		}
	}
}
int temp;
inline void solve(){
	sort(a+1,a+1+cnt); temp=1;
	for (int i=cnt-1;i;i--){
		if (a[i]==a[i+1]){
			temp++;
		}else{
			temp=1;
		}
		if (temp>=k) {
			printf("%d\n",a[i]);
			return;
		}
	}
}
int main(){
	init();
	solve();
	return 0;
}
```

---


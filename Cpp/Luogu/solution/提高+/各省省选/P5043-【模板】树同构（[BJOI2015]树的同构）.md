# 【模板】树同构（[BJOI2015]树的同构）

## 题目描述

树是一种很常见的数据结构。

我们把 $N$ 个点，$N-1$ 条边的连通无向图称为树。

若将某个点作为根，从根开始遍历，则其它的点都有一个前驱，这个树就成为有根树。

对于两个树 $T_1$ 和 $T_2$，如果能够把树 $T_1$ 的所有点重新标号，使得树 $T_1$ 和树 $T_2$ 完全相同，那么这两个树是同构的。也就是说，它们具有相同的形态。

现在，给你 $M$ 个无根树，请你把它们按同构关系分成若干个等价类。

## 说明/提示

编号为 $1, 2, 4$ 的树是同构的。编号为 $3$ 的树只与它自身同构。

对于 $100\%$ 的数据，$1\leq N,M\leq 50$。

## 样例 #1

### 输入

```
4 
4 0 1 1 2 
4 2 0 2 3 
4 0 1 1 1 
4 0 1 2 3 ```

### 输出

```
1 
1 
3 
1 ```

# 题解

## 作者：zhoukangyang (赞：152)

[更蒟蒻的体验](https://www.cnblogs.com/zkyJuruo/p/14175062.html)

听说题解里全是 $O(n^2m)$ 的，今天神 [@](https://codeforces.com/profile/tourist)[hehezhou](https://www.luogu.com.cn/user/67371
) 介绍了一种优秀的方法。

用多项式哈希，记录走过的结点的顺序。

首先如果是有根树，而且儿子结点有先后遍历顺序这样子就是对的。

然后如果儿子结点没有顺序就按照儿子的哈希值排序，然后再哈希。

有根树拓展到无根树只要找到重心然后再做即可。（两个重心也是可以的，比较的时候看看两个哈希值能否对应上即可）

于是得出了哈希值，最后暴力比较即可。

时间复杂度 $\Theta(mn \log n)$, 时间复杂度瓶颈再于对哈希值排序。

神仙 `Forever_Pursuit`说他用基数排序，因此是 $\Theta(mn)$。

# 代码：

```cpp
#include<bits/stdc++.h>
#define L(i, j, k) for(int i = j, i##E = k; i <= i##E; i++) 
#define R(i, j, k) for(int i = j, i##E = k; i >= i##E; i--)
#define ll long long
#define ull unsigned long long 
#define db double
#define pii pair<int, int>
#define pil pair<int, lonf long>
#define mkp make_pair
using namespace std;
const int N = 55;
const int mod = 1019260817;
const int G = 19491001;
int Pow[N];
int n, m;
struct Tree {
	int A, B;
} f[N];
bool operator == (Tree aa, Tree bb) {
	return aa.A == bb.A && aa.B == bb.B;
}
int head[N], edge_id;
struct edge {
	int to, next;
} e[N << 1];
void add_edge(int u, int v) {
	++edge_id, e[edge_id].to = v, e[edge_id].next = head[u], head[u] = edge_id;
}
int has[N], siz[N], dep[N], rt, rrt, rtm;
void findrt(int x, int fa) {
	siz[x] = 1;
	int maxn = 0;
	for(int i = head[x]; i; i = e[i].next) {
		int v = e[i].to;
		if(v == fa) continue;
		findrt(v, x), siz[x] += siz[v], maxn = max(maxn, siz[v]);
	}
	maxn = max(maxn, n - siz[x]);
	if(maxn < rtm) rtm = maxn, rt = x, rrt = 0;
	else if(maxn == rtm) rrt = x;
}
int tot;
pii sav[N];
void dfs(int x, int fa) {
	has[x] = 1ll * dep[x] * Pow[1] % mod, siz[x] = 1;
	for(int i = head[x]; i; i = e[i].next) {
		int v = e[i].to;
		if(v == fa) continue;
		dep[v] = dep[x] + 1, dfs(v, x);
	}
	tot = 0;
	for(int i = head[x]; i; i = e[i].next) {
		int v = e[i].to;
		if(v == fa) continue;
		sav[++tot] = mkp(has[v], siz[v]);
	}
	sort(sav + 1, sav + tot + 1);
	L(i, 1, tot) (has[x] += 1ll * sav[i].first * Pow[siz[x]] % mod) %= mod, siz[x] += sav[i].second;
}
void In(int x) {
	rtm = mod, rrt = 0;
	scanf("%d", &n);
	L(i, 1, n) {
		int v; scanf("%d", &v);
		if(v) add_edge(i, v), add_edge(v, i);
	}
	findrt(1, -1);
	dep[rt] = 1, dfs(rt, -1), f[x].A = has[rt];
	if(rrt) dep[rrt] = 1, dfs(rrt, -1), f[x].B = has[rrt];
	if(f[x].A < f[x].B) swap(f[x].A, f[x].B);
	L(i, 1, n) head[i] = 0;
	edge_id = 0;
}
int mian() {
	Pow[0] = 1;
	L(i, 1, 50) Pow[i] = 1ll * Pow[i - 1] * G % mod;
	scanf("%d", &m);
	L(i, 1, m) In(i);
	L(i, 1, m) L(j, 1, i) if(f[i] == f[j]) {
		printf("%d\n", j);
		break;
	}
	return 0;
}
```

**祝大家学习愉快！**

---

## 作者：ix35 (赞：42)

## P5043 树同构

这题我用了相对准确的最小表示法来完成（与某个取模 Hash 对拍时，那个 Hash 炸得很惨，不知道是否是写法原因）。

另一篇题解也是最小表示，但是我的实现方式不同。

---

### 一、有根树的最小表示

树的括号序列转化：从树根开始执行一次 DFS，每一个结点的子树都有进入和回溯两个过程。DFS 过程中维护一个序列，进入一个子树时向序列中加入一个左括号，回溯时向序列中加入一个右括号，如此可以构成长度为 $2\times n$ 的括号序列。

然而 DFS 过程中，一个点 $u$ 有多个子结点 $v_1,v_2,\cdots,v_k$，因此在不规定访问顺序的情况下，同一棵树有多种不同的括号序列，其中字典序最小的一个称为这颗**有根树的最小表示**。

最小表示法的性质：

**两颗有根树树同构的充要条件是其最小表示相同。**

证明：

充分性：通过最小表示可以唯一确定一棵树的结构：从根节点出发，遇到左括号就向下走一步，遇到右括号就向上走一步，这样的走法在结点无标号时是确定的。树的结构显然唯一确定，因此最小表示相同，树的结构就相同。

必要性：结构相同，DFS 过程完全相同，最小表示显然相同。

**最小表示的求法**：

DFS 一次即可，设 $f_i$ 表示以 $i$ 为根的子树的最小表示。设一个点 $u$ 的子结点分别为 $v_1,\cdots,v_k$，则将 $f_{v_1},\cdots,f_{v_k}$ 按字典序从小到大排序，有：

$$f_u=(f_{v_1}\cdots f_{v_n})$$

字符之间直接连接。

最坏时间复杂度为 $O(n^2)$，此为链的情况。

---

### 二、无根树的同构

一种简单粗暴的方法：对于树 $T$，枚举每个点 $i$ 为根求出最小表示 $ans_i$，令 $ans(T)=\min(ans_i)$，得到所有最小表示中的字典树最小值。这样，两棵树 $T1,T2$ 同构的充要条件就是 $ans(T_1)=ans(T_2)$。

这个方法的原理其实是无根树转成有根树，令 $ans_i$ 取到最小值的 $i$ 设为 $minroot(T)$，则 $ans(T_1)=ans(T_2)$ 即 $ans_{minroot(T_1)}=ans_{minroot(T_2)}$，而无根树要同构，只需要以某个点为根转化为有根树后同构即可。

该算法完成 [这题](https://www.luogu.com.cn/problem/P5043) 的时间复杂度是 $O(n^3m)$，还有进一步优化的空间。

对于两棵同构树 $T$，我们只需要快速找到其中两个“同位点”（即在同构树中结构位置相同的点），以这两个同位点为根检验最小表示即可，事实上，任意两个同位点得出的最小表示都应该是相同的。

通常我们选择的同位点是重心。

对于树 $T$，设其重心为 $G_1,G_2$（也可能只有 $1$ 个），设 $ans(T)=\min(ans_{G_1},ans_{G_2})$，则两棵无根树同构当且仅当 $ans$ 值相同。

因此对于每棵树，我们只需要最多检验两个点的最小表示，时间复杂度变成 $O(n^2m)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN=60;
int t,n,x,eg,mnp,flg,hd[MAXN],ver[2*MAXN],nx[2*MAXN],sz[MAXN],mx[MAXN];
string mn[MAXN],f[MAXN],g[MAXN],tmp;
void add_edge (int x,int y) {
	ver[++eg]=y;
	nx[eg]=hd[x];
	hd[x]=eg;
	return;
}
void dfs1 (int x,int fa) {
	sz[x]=1;
	for (int i=hd[x];i;i=nx[i]) {
		if (ver[i]==fa) {continue;}
		dfs1(ver[i],x);
		sz[x]+=sz[ver[i]];
		mx[x]=max(mx[x],sz[ver[i]]);
	}
	mx[x]=max(mx[x],n-sz[x]);
	mnp=min(mnp,mx[x]);
	return;
}
void dfs2 (int x,int fa) {
	f[x]="0";
	for (int i=hd[x];i;i=nx[i]) {
		if (ver[i]==fa) {continue;}
		dfs2(ver[i],x);
	}
	int tot=0;
	for (int i=hd[x];i;i=nx[i]) {
		if (ver[i]==fa) {continue;}
		g[++tot]=f[ver[i]];
	}
	sort(g+1,g+tot+1);
	for (int i=1;i<=tot;i++) {f[x]+=g[i];}
	f[x]+="1";
	return;
}
int main () {
	scanf("%d",&t);
	for (int ii=1;ii<=t;ii++) {
		scanf("%d",&n);
		memset(hd,0,sizeof(hd));
		memset(mx,0,sizeof(mx));
		eg=flg=0,mnp=n+1;
		tmp="1";
		for (int i=1;i<=n;i++) {
			scanf("%d",&x);
			if (x) {add_edge(x,i),add_edge(i,x);}
		}
		dfs1(1,0);
		for (int i=1;i<=n;i++) {
			if (mx[i]==mnp) {
				dfs2(i,0);
				tmp=min(tmp,f[i]);
			}
		}
		mn[ii]=tmp;
		for (int i=1;i<=ii-1;i++) {
			if (mn[i]==mn[ii]) {
				printf("%d\n",i),flg=1;
				break;
			}
		}
		if (!flg) {printf("%d\n",ii);}
	}
	return 0;
}
```







---

## 作者：EnofTaiPeople (赞：10)

### Part1 前言

我在一年前写过树同构，但那种方法是复杂度极高且容易产生冲突的，一年之后，我想要介绍三种方法，其中一种较慢但是确定性算法，另外两种保证线性但是基于数值哈希的方式，但并没有通用 Hack，即 Hack 方式仅限于对着代码卡。

### Part2 确定性算法

考虑对一棵有根树进行哈希，定义一棵有根树的哈希值为其所有子树哈希值组成的数组排序后的结果，这是一个 `vector`，我们每加入一个 `vector` 就用 `map` 给它标号。

这样可以做到绝对正确，但我们只做到了有根树，时间复杂度为 $O(n^2\log n)$。

考虑一棵无根树最多有两个重心，我们可以对每一个重心分别哈希，然后取最值。

于是得到了本题的做法，时间 $O(NS\log S)$，空间 $O(\sum n^2)$，其中 $N=\max n,S=\sum n$。

代码片段：
```cpp
int calc(int x,int pr){
    vector<int>a={-1};
    for(int y:lk[x])
        if(y!=pr)a.push_back(calc(y,x));
    sort(a.begin(),a.end());
    if(!mp[a])mp[a]=++mt;
    return mp[a];
}
```

### Part3 较劣的非确定性算法

上面发现，我们每获得一个 `vector` 就将其插入了 `map` 内，而 `vector` 的比较是 $O(n)$ 的，所以我们可以对于每一个 `vector` 进行字符串哈希后再插入 `map`，这样就变成了时间 $O(S\log S)$，空间 $O(S)$。

代码片段：
```cpp
int calc(int x,int pr){
    vector<int>a={0};
    for(int y:lk[x])
        if(y!=pr)a.push_back(calc(y,x));
    sort(a.begin(),a.end());
    ul res=0;
    for(int p:a)res=res*C+rp[p];
    if(!mp[res])mp[res]=++mt;
    return mp[res];
}
```

### Part4 较优的非确定性算法

其实我认为这个算法比上面更优是因为其更简便且更好用。

它是基于和哈希的，但我们不能单纯地将儿子的哈希值加起来，这样会有通用卡法，甚至你随便拍几组就挂了。

所以需要对儿子节点的哈希值做多项式变换，即让一个函数作用于它。

然后你会发现可以用换根 dp 在 $O(n)$ 的时间内求出以所有节点为根的哈希值，然后就可以暴力取最值了。

于是本题优化到了时空 $O(S)$ 十分优秀。

代码片段：
```cpp
void dfs(int x,int pr){
    h1[x]=13;if(pr){
        auto it=lk[x].begin();
        while(*it!=pr)++it;lk[x].erase(it);
    }
    for(int y:lk[x])
        dfs(y,x),h1[x]+=F(h1[y]);
}
void dp(int x,int pr){
    if(pr)h2[x]=h1[x]+F(h2[pr]-F(h1[x]));
    else h2[x]=h1[x];
    for(int y:lk[x])dp(y,x);
    lk[x].clear();
}
```

以上三种算法均可以通过本题和 [SPOJ 加强版](https://www.luogu.com.cn/problem/SP7826)。

### Part5 后记

马上就要省选了，HNOI2023rp++！

过了样例 $\Leftrightarrow$ 得分在 $[0,100]$ 之间。

---

## 作者：山田リョウ (赞：6)

首先先把题目弱化一下，假如是有根树该怎么做。

很容易想到判断几棵树是否相同可以去看括号序是否一样，只要求出括号序再丢尽 `std::map` 里解决就行了。

对应同一个节点的儿子该按什么顺序连在一起呢？可以考虑把它们的括号序按字典序排个序，按这个顺序连在一起。

但是字符串比较有点慢，是 $\mathcal{O}\left(n\right)$ 的，可以考虑把字符串换成字符串的哈希值，但是我们注意到此题数据范围极小，$n$ 最大也就 $50$，所以可以考虑把括号序压成二进制数（左括号是 $0$，右括号是 $1$）,最大不会超过 $2^{2\times50=100}-1$（其实最大是 $2^{99}$，因为括号序首位一定是左括号。。。），用 `int128` 存就行了。

求这个值的参考代码如下：
```cpp
struct int128{
	unsigned long long a,b;
	int128 operator <<(const size_t&o)const{
		return (o<64)?(int128){a<<o|b>>64-o,b<<o}:(int128){b<<o-64,0};
	}
	int128 operator |(const int128&o)const{
		return (int128){a|o.a,b|o.b};
	}
	bool operator <(const int128&o)const{
		return a==o.a?b<o.b:a<o.a;
	}
}name[51];int size[51],head[51],m,n,A[51];
struct{int v,nxt;}e[51];
inline bool cmp(int a,int b){return name[a]<name[b];}
void dfs(int x,int f){
	int tot=0;size[x]=1;name[x]={0,0};
	for(int i=head[x];~i;i=e[i].nxt)
		if(e[i].v!=f){
			dfs(e[i].v,x);
			size[x]+=size[e[i].v];
		}
	for(int i=head[x];~i;i=e[i].nxt)if(e[i].v!=f)A[tot++]=e[i].v;
	std::sort(A,A+tot,cmp);
	for(int i=0;i<tot;++i)name[x]=name[x]<<(size[A[i]]<<1)|name[A[i]];
	name[x]=name[x]<<1|(int128){0,1};
}
```
但是本题里的树是无根树，我们要把它变成有根树，可以考虑用树的重心（最多也只有 $2$ 个）作为根求出括号序压成整数的值，如果有两个重心就把这两个重心作为根求出的值取个最小值就好了。

时间复杂度是 $\mathcal{O}\left(mn\log n\right)$，其中的 $\log n$ 是来自排序，所以如果我们用字符串哈希，把模数取小点（就比如取 `101`），再用基数排序的话，是可以做到 $\mathcal{O}\left(mn\right)$ 的，但是由于要取模，而且此题中的 $\log n$ 很小，我就没写哈希的做法，毕竟哈希或许可以卡掉。

代码（目前最优解 rank$1$）
```cpp
#include<stdio.h>
#include<algorithm>
#include<map>
struct int128{
	unsigned long long a,b;
	int128 operator <<(const size_t&o)const{
		return (o<64)?(int128){a<<o|b>>64-o,b<<o}:(int128){b<<o-64,0};
	}
	int128 operator |(const int128&o)const{
		return (int128){a|o.a,b|o.b};
	}
	bool operator <(const int128&o)const{
		return a==o.a?b<o.b:a<o.a;
	}
}name[51];int size[51],head[51],m,n,A[51];
struct{int v,nxt;}e[51];
inline bool cmp(int a,int b){return name[a]<name[b];}
void dfs(int x,int f){
	int tot=0;size[x]=1;name[x]={0,0};
	for(int i=head[x];~i;i=e[i].nxt)
		if(e[i].v!=f){
			dfs(e[i].v,x);
			size[x]+=size[e[i].v];
		}
	for(int i=head[x];~i;i=e[i].nxt)if(e[i].v!=f)A[tot++]=e[i].v;
	std::sort(A,A+tot,cmp);
	for(int i=0;i<tot;++i)name[x]=name[x]<<(size[A[i]]<<1)|name[A[i]];
	name[x]=name[x]<<1|(int128){0,1};
}
int cent[2],tot;
void query(int x,int f){
	size[x]=1;int weight=0;
	for(int i=head[x];~i;i=e[i].nxt)
		if(e[i].v!=f){
			query(e[i].v,x);
			size[x]+=size[e[i].v];
			weight=size[e[i].v]>weight?size[e[i].v]:weight;
		}
	if((weight<<1)<=n&&n<=(size[x]<<1))cent[tot++]=x;
}
int main(){
	std::map<int128,int> MAP;
	scanf("%d",&m);
	for(int k=1;k<=m;++k){
		scanf("%d",&n);
		for(int i=1;i<=n;++i)head[i]=-1;tot=0;
		int cnt=0;
		for(int i=1;i<=n;++i){
			int x;scanf("%d",&x);
			if(x){
				e[cnt]={x,head[i]},head[i]=cnt++;
				e[cnt]={i,head[x]},head[x]=cnt++;
			}
		}
		query(1,0);
		dfs(cent[0],0);
		int128 NAME=name[cent[0]];
		if(tot>1)dfs(cent[1],0),NAME=name[cent[1]]<NAME?name[cent[1]]:NAME;
		if(MAP.find(NAME)!=MAP.end())printf("%d\n",MAP[NAME]);
		else printf("%d\n",MAP[NAME]=k);

	}
	return 0;
}
```

---

## 作者：Aw顿顿 (赞：6)

> **[P5043 【模板】树同构](https://www.luogu.com.cn/problem/P5043)**
>
> 给定两棵树 $T_1,T_2$，若能够将他们的节点重新标号使得他们的结构相同，则称他们为同构树。
>
> 现给定 $m$ 棵树，对于每棵树求与其同构的树的最小编号。

对于同构更严谨的定义参见 Wiki，核心思想是在点集之间建立双射。

不妨考虑忽略题目中的 $0$ 节点。

## 最小表示 / AHU 算法

假定现在有一颗有根树，以树根为起点，我们需要进行一次 DFS，现在我们要通过深搜产生一个括号序列。我们规定在进入一个子树时向序列中加入一个左括号，回溯时向序列中加入一个右括号，通过不断地操作维护序列，最终会产生一个长度为结点数两倍（对于本题，是 $2\times n$）的括号序列。

由于遍历的顺序不同，产生的括号序列也有所不同。我们规定在所有合法的括号序列之中，字典序最小的序列被命名为**有根树最小表示**。求取最小表示的意义在于，两棵树的最小表示相同等价于两棵树同构。因为同构的两棵树最小表示显然相同，而最小表示对于无标号树确定了唯一的访问顺序，通过**唯一的访问顺序**可以确定**唯一的树形结构**。

记 $f_i$ 为一棵树以 $i$ 节点为根的最小表示，那么这其实是一个字符串序列，对于 $u$ 的所有节点 $v$，最小表示可以被记作：

$$f_u=\sum f_{v_i}$$

## 同构无根树

而对于一颗无根树，我们考虑他们的同构和有根树同构之间的关系。最简单的方案是，求出一颗无根树的最小表示中的**字典序最小值**，具体而言是这样的：

$$T(f)=\min\{f_1,f_2,\cdots,f_n\}$$

由于对于指定根求最小表示在树退化成一条链的情况下复杂度是 $O(n^2)$ 的，因此对于无根树按上述方法求取实际上复杂度是 $O(n^3)$。对于模板题来说，比对 $m$ 棵树的最小表示总复杂度为 $O(n^3m)$ 是不够优秀的，考虑在无根树这一块优化复杂度。由于如果我们能够在两棵树之间找到**同位点**，即在两颗同构树中处于同一位置的点并对其求最小表示即可。

这样的点在哪里呢？考虑**树的重心**。一棵树至多有两个重心，此处给出判定方法：

- 重心数量不同的两棵树不同构。
- 均有一颗重心 $u$ 的两棵树是同构的当且仅当 $f_{u_1}=f_{u_2}$。
- 均有两颗重心 $u,v$ 的两棵树是同构的当且仅当 $\min\{f_{u_1},f){v_1}\}=\min\{f_{u_2},f){v_2}\}$。

现在，问题非常明了，对于每一棵树我们检验的点数是极少的，因此整体复杂度被优化到 $O(n^2m)$，已经足够通过模板题，普通的树哈希复杂度也是一样的。**朴素的 AHU 算法还有优化的空间**，此处暂时不提及。

## 算法实现

我们需要两次 DFS 来实现这样的算法，第一次 DFS 要求出每一个节点的 $size$ 和 $mx$ 值：

```cpp
void dfs1(int x,int fa){
	sz[x]=1;
	for(int i=h[x];i;i=e[i].nxt){
		int v=e[i].v;
		if(v==fa)continue;
		dfs1(v,x);
		sz[x]+=sz[v];
		mx[x]=max(mx[x],sz[v]);
	}mx[x]=max(mx[x],n-sz[x]);
	mp=min(mp,mx[x]);return;
}
```

第二次的 DFS 就可以确定以指定节点为根的最小表示。若将括号序列用 $\texttt{01}$ 序列表示，则一个节点的最小表示是一个 $\texttt{0}$ 之后按字典序加上所有子树的最小表示。因此在此过程中需要排序，其余只需要在递归过程中进行构造即可：

```cpp
void dfs2(int x,int fa){
	f[x]="0";
	for(int i=h[x];i;i=e[i].nxt){
		int v=e[i].v;
		if(v!=fa)dfs2(v,x);
	}int tot=0;
	for(int i=h[x];i;i=e[i].nxt){
		int v=e[i].v;
		if(v!=fa)son[++tot]=f[v];
	}sort(son+1,son+tot+1);
	for(int i=1;i<=tot;i++)f[x]+=son[i];
	f[x]+="1";return;
}
```

## 全文代码

全文代码实现如下：

```cpp
#include<bits/stdc++.h>
#define N 99
using namespace std;
struct Edge{
    int v,nxt;
}e[N<<1];
int h[N],cnt;
int T,n,x,mp,flag,sz[N],mx[N];
string mn[N],f[N],g[N],tmp;
void add(int u,int v){e[++cnt].v=v;e[cnt].nxt=h[u];h[u]=cnt;}
void dfs1(int x,int fa){
	sz[x]=1;
	for(int i=h[x];i;i=e[i].nxt){
		int v=e[i].v;
		if(v==fa)continue;
		dfs1(v,x);
		sz[x]+=sz[v];
		mx[x]=max(mx[x],sz[v]);
	}mx[x]=max(mx[x],n-sz[x]);
	mp=min(mp,mx[x]);return;
}void dfs2(int x,int fa){
	f[x]="0";
	for(int i=h[x];i;i=e[i].nxt){
		int v=e[i].v;
		if(v!=fa)dfs2(v,x);
	}int tot=0;
	for(int i=h[x];i;i=e[i].nxt){
		int v=e[i].v;
		if(v!=fa)g[++tot]=f[v];
	}sort(g+1,g+tot+1);
	for(int i=1;i<=tot;i++)f[x]+=g[i];
	f[x]+="1";return;
}void init(){
	memset(h,0,sizeof h);
	memset(mx,0,sizeof mx);
	cnt=flag=0,mp=n+1;tmp="1";
}signed main(){
	scanf("%d",&T);
	for(int k=1;k<=T;k++){
		scanf("%d",&n);init();
		for(int i=1;i<=n;i++){
			scanf("%d",&x);
			if(x)add(x,i),add(i,x);
		}dfs1(1,0);
		for(int i=1;i<=n;i++){
			if(mx[i]==mp){
				dfs2(i,0);
				tmp=min(tmp,f[i]);
			}
		}mn[k]=tmp;
		for(int i=1;i<k;i++){
			if(mn[i]==mn[k]){
				printf("%d\n",i);
				flag=1;
				break;
			}
		}if(!flag)printf("%d\n",k);
	}return 0;
}
```






---

## 作者：XL4453 (赞：1)

### 解题思路：

这里采用速度较快且准确性较高的重心双哈希。

---

对于只需要求出无根树值的情况，直接进行哈希并不优秀，直接暴力做复杂度相对较高，而换根又会导致代码变得更为复杂。这时候就希望在树中找一个较为确定的点作为树的根，转化为更为简单的有根树哈希，此处可以采用树的重心。

树的重心是将这个点删除之后剩下森林中最大联通块最小的一个位置。树的重心有一个或者两个，且对于任意两颗同构无根树，其重心的位置相同却确定。

---
在确定了根节点之后就可以进行哈希了。

笔者采用了双哈希，两个哈希式子分别是 $f_i=size_i\sum f_{son_i}+size_i^2$ 以及 $g_i=size_i\sum f_{son_i}^2+1$。

对于两个重心的情况，可以让两个都作为根节点跑一次取 $f$ 较小的一个作为最终使用的哈希值。

最后使用 $\text{map}$ 判断就行了。

---
注意数组要清空。

---
### 代码：

```cpp
#include<algorithm>
#include<cstdio>
#include<map>
using namespace std;
#define int long long
const int MAXN=100005,MOD=1000000007;
int m,n,x,head[MAXN],num[MAXN],nxt[MAXN],tot,size_[MAXN],f1[MAXN],f2[MAXN],h[MAXN],ans_cnt,ans_pos1,ans_pos2;
map <pair<int,int> ,int> mp;
void init(){
	for(int i=1;i<=2*n;i++)
	head[i]=nxt[i]=num[i]=size_[i]=f1[i]=f2[i]=h[i]=0;
	tot=0;
}
void add(int x,int y){
	nxt[++tot]=head[x];
	head[x]=tot;
	num[tot]=y;
}
void dfs1(int now,int fa){
	size_[now]=1;
	for(int i=head[now];i;i=nxt[i]){
		if(num[i]==fa)continue;
		dfs1(num[i],now);
		size_[now]+=size_[num[i]];
		h[now]=max(h[now],size_[num[i]]);
	}
	h[now]=max(h[now],n-size_[now]);
}
void dfs2(int now,int fa){
	size_[now]=1;
	f1[now]=f2[now]=0;
	for(int i=head[now];i;i=nxt[i]){
		if(num[i]==fa)continue;
		dfs2(num[i],now);
		size_[now]+=size_[num[i]];
		f1[now]=(f1[now]+f1[num[i]])%MOD;
		f2[now]=(f2[now]+f2[num[i]]*f2[num[i]]%MOD)%MOD;
	}
	f1[now]=(f1[now]*size_[now]%MOD+size_[now]*size_[now]%MOD)%MOD;
	f2[now]=(size_[now]*f2[now]+1)%MOD;
}
signed main(){
	scanf("%lld",&m);
	for(int loop=1;loop<=m;loop++){
		init();
		scanf("%lld",&n);
		for(int i=1;i<=n;i++){
			scanf("%lld",&x);
			if(x!=0)add(x,i),add(i,x);
		}
		dfs1(1,0);
		ans_cnt=1000000000;
		ans_pos1=ans_pos2=-1;
		for(int i=1;i<=n;i++){
			if(h[i]==ans_cnt){
				ans_pos2=i;
			}
			if(h[i]<ans_cnt){
				ans_cnt=h[i];
				ans_pos1=i;
				ans_pos2=-1;
			}
		}
		if(ans_pos2==-1){
			dfs2(ans_pos1,0);
			if(mp[make_pair(f1[ans_pos1],f2[ans_pos1])]==0)
			mp[make_pair(f1[ans_pos1],f2[ans_pos1])]=loop;
			printf("%lld\n",mp[make_pair(f1[ans_pos1],f2[ans_pos1])]);
		}
		else{
			dfs2(ans_pos2,0);
			int p1=f1[ans_pos2],p2=f2[ans_pos2];
			dfs2(ans_pos1,0);
			if(p1>f1[ans_pos1]){
				if(mp[make_pair(p1,p2)]==0)
				mp[make_pair(p1,p2)]=loop;
				printf("%lld\n",mp[make_pair(p1,p2)]);
			}
			else{
				if(mp[make_pair(f1[ans_pos1],f2[ans_pos1])]==0)
				mp[make_pair(f1[ans_pos1],f2[ans_pos1])]=loop;
				printf("%lld\n",mp[make_pair(f1[ans_pos1],f2[ans_pos1])]);
			}
		}
	}
	return 0;
}
```


---

## 作者：clo201111 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P5043)

看到树的同构，很容易想到 Hash。本题是无根树，我们先考虑有根树怎么做。

### 1. 有根树的同构
判断有根树是否同构时，可以把这些树 Hash 一下。两棵有根树同构，仅当它们的 Hash 值相同，在 Hash 值相同的情况下，也可能有极小的概率两棵树不同构。但如果 Hash 值不同，那么它们不可能同构。

可以写多值 Hash 来降低冲突的概率，但是本题不卡。

对于树的 Hash 值的设计比较随意，可以设以结点 $x$ 为根的子树的 Hash 值为以 $x$ 的子结点为子树 Hash 值的异或和与质数 $P$ 的乘积，同时也可以在转移 Hash 值时加一些位运算等来降低冲突概率。

### 2. 无根树的同构
现在再回到题目考虑无根树。注意到一棵无根树最多有两个重心，只需把以重心为根时的 Hash 值求出来即可。我们可以用 `map` 维护同构树的最小编号，对于第 $i$ 棵树，先用 DFS 求出它的重心，对它的每个重心进行 Hash，如果 Hash 值在 `map` 中存在，那么答案就是 `map` 中的对应值；否则若不存在就加入 `map`，答案就是 $i$。

除去 `STL` 的查询，时间复杂度为 $O(mn)$，轻松过本题。

### 代码实现
**Code：** （C++11）
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ULL;
const int MAXN=2E02,P=139;
int m,n,fa,ans;
map<pair<ULL,ULL>,int> id;
set<int> tree[MAXN+5];
unsigned long size[MAXN+5],w[MAXN+5];
set<int> centre;
void getCentre(int x,int fa) {
  size[x]=1;
  for(auto it=tree[x].begin();it!=tree[x].end();it=next(it)) {
    int y=* it;
    if(y==fa)  continue;
    getCentre(y,x);
    size[x]+=size[y];
    if(size[y]>w[x])  w[x]=size[y];
  }
  if(w[x]<=n/2 && n-size[x]<=n/2)
    centre.insert(x);
}
ULL Hash(int x,int fa) {
  ULL res=0;
  size[x]=1;
  for(auto it=tree[x].begin();it!=tree[x].end();it=next(it))
    if(* it!=fa) {
      ULL h=Hash(* it,x);
      res=res^h^(h<<17);
      size[x]+=size[* it];
	}
  (res*=P)+=size[x];
  return res;
}
int main() {
  scanf("%d",&m);
  for(int i=1;i<=m;i++) {
    memset(size,0,sizeof size);
    memset(w,0,sizeof w);
    centre.clear();
    scanf("%d",&n);
    for(int j=1;j<=n;j++)
      tree[j].clear();
    for(int j=1;j<=n;j++) {
      scanf("%d",&fa);
      if(fa) {
        tree[fa].insert(j);
        tree[j].insert(fa);
	  }
	}
	getCentre(1,0);
	ans=i;
	pair<ULL,ULL> h;
	for(auto it=centre.begin();it!=centre.end();it=next(it))
	  if(it==centre.begin())
	    h.first=Hash(* it,0);
	  else
	    h.second=Hash(* it,0);
	if(centre.size()>1) {
	  if(h.first>h.second)
	    swap(h.first,h.second);
	}
	else
	  h.second=h.first;
	if(id.count(h)==0)
	  id[h]=i;
	printf("%d\n",id[h]);
  }
}

```

---


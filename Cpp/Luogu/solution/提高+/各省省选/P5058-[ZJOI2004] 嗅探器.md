# [ZJOI2004] 嗅探器

## 题目描述

某军搞信息对抗实战演习，红军成功地侵入了蓝军的内部网络。

蓝军共有两个信息中心，红军计划在某台中间服务器上安装一个嗅探器，从而能够侦听到两个信息中心互相交换的所有信息。

但是蓝军的网络相当的庞大，数据包从一个信息中心传到另一个信息中心可以不止有一条通路。

现在需要你尽快地解决这个问题，应该把嗅探器安装在哪个中间服务器上才能保证所有的数据包都能被捕获？

## 说明/提示

对于 $100\%$ 的数据，$1\le n\le 2 \times 10^5$，边数不超过 $5 \times 10^5$。

## 样例 #1

### 输入

```
5
2 1
2 5
1 4
5 3
2 3
5 1
0 0
4 2```

### 输出

```
1```

# 题解

## 作者：泥土笨笨 (赞：89)

还没有圆方树的题解，我来写一个。

前置知识0，点双连通分量，这个相信来做这道题的同学应该都会了。
前置知识1，圆方树，可以参考小粉兔的博客文章https://www.cnblogs.com/PinkRabbit/p/10446473.html

用圆方树解决点双连通分量相关的问题，比较舒服。把原图中每个点当成一个圆点，给每个强连通分量创建一个方点，把属于这个强连通分量中的圆点向对应的方点连边，这样得到一个新的树。这个新的树上面，度大于1的圆点，就是割点。而题目中问两个服务器之间的必经点，就是割点。那么只需要建好圆方树以后，在树上两点间路径上找编号最小的圆点就行了。

首先题目中的两个服务器，分别设为start和target，这时候题目中并没有保证start和target是连通的，所以只需从start开始tarjan跑一遍，看看跑完以后target点的dfs时间戳是否变过，如果没有，说明不连通，一定无解。如果连通，其他没经过的点也不用管了，只需要处理这一个连通分量里面的点就行了。

跑tarjan的时候，顺便把圆方树建起来，这个建树的过程可以参考代码中的注释。建好树以后，怎么找两点间路径呢？可以以start为根，向下dfs找target点，因为圆方树是一个无根树，以谁为根都可以，不妨以start为根，很方便。

然后往下dfs的过程中记录路径上的答案，找到target输出答案即可，总复杂度$O(N)$

代码：
```cpp
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <cstdlib>

using namespace std;
const int MAXN = 400005;//这里注意要开双倍空间，因为圆方树上点的个数可能到2n的数量
//n是原图中点的数量，start和target是两个服务器，nn是圆方树上点的数量
int n, start, target, nn, pre[MAXN], low[MAXN], dt;
//分别是原图，和圆方树的邻接表
vector<int> adj[MAXN], adjT[MAXN];
stack<int> s;

void tarjan(int u, int father) {
    pre[u] = low[u] = ++dt;
    s.push(u);
    for (int i = 0; i < adj[u].size(); ++i) {
        int v = adj[u][i];
        if (pre[v] == 0) {
            tarjan(v, u);
            low[u] = min(low[u], low[v]);
            if (low[v] >= pre[u]) {
                nn++;//找到一个新的点双连通分量，新增一个方点
                while (true) {
                    int t = s.top();
                    s.pop();
                    adjT[nn].push_back(t);//原图中的点到方点连边
                    adjT[t].push_back(nn);
                    if (t == v) break;//这里pop到v为止，u点保留在栈里面，因为割点可能被很多点双公用
                }
                adjT[u].push_back(nn);//u点也在这个点双里面，也像方点连边。
                adjT[nn].push_back(u);
            }
        } else if (v != father) {
            low[u] = min(low[u], pre[v]);
        }
    }
}

//u是当前访问到的点，ans是目前从根走下来的路径上的答案，father是u的父亲
void dfs(int u, int ans, int father) {
    if (u == target) {
        //如果走到target了
        if (ans == 0) {
            //ans还是0，说明路上没经过割点
            printf("No solution\n");
        } else {
            printf("%d\n", ans);
        }
        exit(0);
    }
    if (u != start && adjT[u].size() > 1 && u <= n) {
        //遇到非叶子的圆点，说明是割点
        if (ans == 0) {
            ans = u;
        } else {
            ans = min(ans, u);
        }
    }
    for (int i = 0; i < adjT[u].size(); ++i) {
        int v = adjT[u][i];
        if (v == father) continue;
        dfs(v, ans, u);
    }
}

int main() {
    scanf("%d", &n);
    int u, v;
    while (scanf("%d%d", &u, &v)) {
        if (u == 0 && v == 0) break;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    scanf("%d%d", &start, &target);
    nn = n;//最开始的时候，圆方树里面点的个数等于圆点个数
    tarjan(start, 0);//从其中一个服务器开始跑一遍tarjan
    if (pre[target] == 0) {
        //从起点到终点不连通
        printf("No solution\n");
        return 0;
    }
    //这时候以start为根，在圆方树上dfs找target，沿途记录经过的最小的割点编号
    dfs(start, 0, 0);
    return 0;
}
```


---

## 作者：TonyYuan (赞：87)

（$2020.3.25$更新排版及原题解数据范围，感谢@♗Wendigo♝）

&emsp;&emsp;考虑缩点时的过程，设$u$是$v$的祖先，我们通过找$v$为根的搜索子树是否能延伸到时间戳小于$u$的节点来判断u是否为割点。如果该子树不能延伸至$u$以上，则去掉$u$后该子树会与其余部分“失去联系”。  

&emsp;&emsp;由此我们这样想：如果我们以一个信息中心$a$为根开始搜索，找到一个非根的割点$u$；此时若对应的子树根$v$的时间戳小于等于$b$的时间戳，则说明$b$存在于$v$的子树内。  

&emsp;&emsp;这很显然，由于$dfn$随$dfs$序更新，若还没搜到$b$，则其$dfn$为$0$；或者$dfn$不为$0$而小于$v$，则说明$b$在进入$v$以前已经被搜到了。

&emsp;&emsp;那么如果把$u$断掉，$v$的整棵子树都会与根$a$失去联系，$u$就是所求的点之一。

&emsp;&emsp;算法只对原$Tarjan$函数的判断条件略做了修改，因此效率得到了极大保留，时间复杂度$O(n+m)$。
```
#include <iostream>
#include <algorithm>
#include <vector>
#include <cstdio>
#include <queue>
const int maxn(200010);
const int maxm = 500010;
using namespace std;
int top = 1, head[maxn], n, a, b;
struct node {
    int to, nxt;
} edge[maxm<<1];
void tarjan(int);
bool cut[maxn];
inline void insert(int u, int v) {
    edge[++top] = (node) {v, head[u]};
    head[u] = top;
}
int main() {
    scanf("%d", &n);
    int u, v; 
    scanf("%d %d", &u, &v);
    while (!(u==0 && v==0)) {
        insert(u, v), insert(v, u);
        scanf("%d %d", &u, &v);
    }
    scanf("%d %d", &a, &b);
    tarjan(a);
    for(int i = 1; i <= n; i++)
        if(cut[i]) {
            printf("%d", i);
            return 0;
        }
    puts("No solution");
    return 0;
}
int dfn[maxn], low[maxn], timer;
void tarjan(int u) {
    dfn[u] = low[u] = ++timer;
    for(int i = head[u]; i; i = edge[i].nxt) {
        int v = edge[i].to;
        if(!dfn[v]) {
            tarjan(v);
            low[u] = min(low[u], low[v]);
            if(low[v]>=dfn[u] && u!=a && dfn[b]>=dfn[v]) 
                cut[u] = 1;
        } else
            low[u] = min(low[u], dfn[v]);
    }
    return;
}
    


    
```

---

## 作者：fdszlzl (赞：40)

[P5058 [ZJOI2004]嗅探器](https://www.luogu.com.cn/problem/P5058)

**题意：**无向连通图中有A、B两点，问是否存在一个点能切断A、B之间的联系。

**割点。**

易想，如果$u$是割点，且将A、B两点割在两边，则此点可行。

![](https://cdn.luogu.com.cn/upload/image_hosting/c7imdl6u.png)


如何判断A或B是否在$u$的搜索子树或不在搜索子树中？

$dfn[i]$是点$i$的dfs序，如果 $dfn[v]>dfn[u]$ 则$v$在$u$的搜索子树中，如果 $dfn[v]<dfn[u]$ 则$v$不在$u$的搜索子树中。于是如果点$u$满足以下条件且是割点：
$$ dfn[u]>dfn[A] \&\& dfn[u]<dfn[B] $$
$$ dfn[u]>dfn[B] \&\& dfn[u]<dfn[A] $$
则$u$必为答案之一。

如果A、B都在$u$的搜索子树内，是不是就不是答案呢？如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/ny4x4qjm.png)


$u$也是答案之一。此时，没有办法用$u$来界定，$u$割掉v、B这一支，显然有： $dfn[v]<=dfn[B] \&\& dfn[v]>dfn[A]$，我们发现这个判定包含之前的判定。

最终答案需满足下列条件：

- $u$是割点
- $v$是$u$割掉的这一支的首节点
- A或B在$v$子树内（包括$v$)且B或A不在$v$子树内。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N=2e5+10,M=5e5+10;
int vex[N],k,n,m,A,B,ans=1e9;
struct edge {
	int u,v,next;
}e[M*2];

void add(int u,int v){
	k++;
	e[k].u=u;
	e[k].v=v;
	e[k].next=vex[u];
	vex[u]=k;
	return;
}

int dfn[N],low[N],idx;

int check(int u,int v){
	if(dfn[v]<=dfn[A]&&dfn[v]>dfn[B]) return 1;
	if(dfn[v]<=dfn[B]&&dfn[v]>dfn[A]) return 1;
	return 0;
}

void tarjan(int u,int fa){
	dfn[u]=low[u]=++idx;
	for(int i=vex[u];i;i=e[i].next){
		int v=e[i].v;
		if(!dfn[v]) {
			tarjan(v,u);
			low[u]=min(low[u],low[v]);
			if(low[v]>=dfn[u]&&u!=A&&u!=B&&check(u,v)) {
				ans=min(ans,u);
			}		
		}
		else if(v!=fa) low[u]=min(low[u],dfn[v]);
	}
	return;
}

int main(){
	cin>>n;
	while(1){
		int u,v;
		cin>>u>>v;
		if(u==0&&v==0) break;
		add(u,v);
		add(v,u);	
	}
	cin>>A>>B;
	tarjan(1,0);
	if(ans==1e9) cout<<"No solution";
	else cout<<ans;
	return 0;
} 
```









---

## 作者：船医 (赞：21)

**因为a,b间所有的信息都要经过中间服务器，说明中间服务器删掉后，ab不连通，这个中间服务器一定是一个割点。**

**我们在用Tarjan求割点时，要判断割点是否把 a 和 b 必须分割到两个不连通的部分中。**

为了简化问题，我们直接把a点作为根，从a点开始做DFS。

最容易想到的就是判断b的时间戳（dfn）是否不小于我们找到的割点，如下图

![](https://cdn.luogu.com.cn/upload/image_hosting/p0e1c4cf.png)

但是这种想法是有缺陷的。

假如a有一条连向b的边，但b却是由u遍历到的，那么这时u就不能分开a与b。

![](https://cdn.luogu.com.cn/upload/image_hosting/gaz2nzvk.png)

_**所以我们想到利用判断 u是割点的 v点**_ 

 对于一个割点u，若判定u为割点的边是(u,v)：

1.dfn[b]<dfn[u]，此时b是u的祖先或者b和u不在同一个子树内。由于a是根，那么a和b一定在一个连通块内。

2.dfn[b]>dfn[u]&&dfn[b]<dfn[v]，此时b是v的兄弟子树中的节点，无法确定 a,b是否在一个连通块。

3.dfn[b]>=dfn[v]，此时b是v的子树中的节点，a,b一定不在一个连通块。

**想清楚这些，AC就向你挥手了。**

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1000005;//看起来舒服
int n,m,root,low[N],dfn[N],x,y,ans[N],tot,point[N],aa,bb,ff;
vector<int> g[N];//邻接表
//不需要栈了，因为不是缩点，不需要给所属强连通分量编号
void tanjan(int u){
	low[u]=dfn[u]=++tot;
	for(int i=0;i<g[u].size();i++)
	{
		if(!dfn[g[u][i]])//没到过
		{
			tanjan(g[u][i]);
			if(low[g[u][i]]>=dfn[u])
			{
				if(root!=u)//非根节点
				{
					if(dfn[bb]>=dfn[g[u][i]])
					{
						point[u]=1;//是所求的点。注意这个点是割点，但不是所有割点。
						ff=1;//用于输出判断
					}
				}
			}
			else
			{
				low[u]=min(low[u],low[g[u][i]]);
			}
		}
		else
		{
			low[u]=min(low[u],dfn[g[u][i]]);
		}
	}
}
int main(){
	cin>>n;
	x=1;
	y=1;
	while(x&&y)
	{
		cin>>x>>y;
		g[x].push_back(y);
		g[y].push_back(x);
	}
	cin>>aa>>bb;
	root=aa;
	tanjan(aa);//tanjan  a就行，简化问题
	int j=0;
	for(int i=1;i<=n;i++)
	{
		if(point[i]!=0)
		{
			ans[j]=i;
			j++;
		}
	}
	if(ff==0)
	cout<<"No solution";
	else
	{
		cout<<ans[0];
	}//输出判断。
	return 0;
}
```
祝大家儿童节快乐！

---

## 作者：gcwixsxr (赞：16)

 这是一道割点的板子题

~~其实这道题挺水的~~

在板子上加一道特判就可以了..

为了简化问题，我们直接从 a 点开始做DFS。

对于一个割点 u ，若判定 u 为割点的边是 (u,v),那么有以下讨论,

 - 如果 $dfn[b] < dfn[u]$，则 $b$ 是 $u$ 的祖先或者 $b$ 和 $u$ 不在同一个子树内，由于 $a$ 是根，那么 $a$和 $b$ 一定在一个连通块内。

 - 如果 $dfn[b] > dfn[u] \,\  and \,\ dfn[b] <dfn[v]$，则 $b$ 是 $v$ 的兄弟子树中的节点，无法确定 $a,b$ 是否在一个连通块。


 - 如果 $dfn[b] >= dfn[v]$，则 $b$ 是 $v$ 的子树中的节点，$a,b$ 一定不在一个连通块。
 
![](https://cdn.luogu.com.cn/upload/image_hosting/vu4h63n3.png)

大概这三种情况就对应上述三种图

综上满足$dfn[b] >= dfn[v]$就行

```cpp
#include<bits/stdc++.h>
using namespace std;
struct edge{
    int to,next;
}e[1000010];
int n,m,stindex,ei,ans;
int a,b;
int h[200010],dfn[200010],low[200010];
bool u[200010];
void add (int x,int y)
{	
	ei++;
    e[ei].to=y;
    e[ei].next=h[x];
    h[x]=ei;
}
void tarjan(int f, int fa)
{
	int cnt = 0;
	stindex++;
	low[f]=dfn[f]=stindex;
	for(int i=h[f];i;i=e[i].next)
	{
		if(e[i].to==fa)continue;
		cnt++;
		int to = e[i].to;
		if(dfn[to]==0)
		{
			tarjan(to,f);
			if((fa==0&&cnt>1||fa!=0&&low[to]>=dfn[f])&&dfn[b]>=dfn[to])//相对板子tarjan部分就只改了这一句
			{
				u[f]=1;
			}
			low[f] = min(low[f],low[to]);
		}else
		{
			low[f] = min(low[f],dfn[to]);
		}
	}
}
int main(){
    scanf ("%d",&n);
    int xx,yy;
    while(scanf("%d%d",&xx,&yy)&&xx&&yy){
        add (xx,yy);
        add (yy,xx);
    }
    scanf("%d%d",&a,&b);
    tarjan (a,0);
    for (int i=1;i<=n;i++)
        if (u[i])return printf ("%d\n",i),0;
	printf("No solution\n");
    return 0;
}
```


---

## 作者：我去 (赞：10)

# 这个思路码量有些大，不过跑的挺快的。。
24ms  800kb

看了半天题解发现没有哪位julao用**Tarjan求完割点**，再将**原图缩成一棵树**，最后从**其中一个信息中心Dfs到另一个信息中心**。

在Dfs中，传三个值

- id:当前的到了哪个点（**缩点后的新编号**）
- fa:这个点的父亲（**防止Dfs死循环**）
- minn:从选定的信息中心到目前为止经过的割点中最小的编号（如果没有经过任何割点就为INF）

### 具体细节代码有注释

```cpp
#include<cstdio>
#include<string>
#include<cstring>
#include<algorithm>
#include<cctype>
#include<vector>
#include<stack>
using namespace std;
const int MAXN = 110;
const int MAXM = 10010;
const int INF = 0x3f3f3f3f;

template <typename T>
inline void read(T&x){
    x=0; char temp=getchar(); bool f=false;
    while(!isdigit(temp)){if(temp=='-') f=true; temp=getchar();}
    while(isdigit(temp)){x=(x<<1)+(x<<3)+temp-'0'; temp=getchar();}
    if(f) x=-x;
}
template <typename T>
void print(T x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) print(x/10);
    putchar(x%10+'0');
}

//basic
int n;
int x,y;
//save edge1
struct node1{
    int to,next;
}edge1[MAXM];
int head1[MAXN],cnt1;
//Tarjan
int dfn[MAXN],low[MAXN],sign;
int root;
bool cut[MAXN]={false};
int vdcc,belong[MAXN];
stack<int> sta;
vector<int> block[MAXN];
//Build
int newid[MAXN];//割点在缩完点图中的新编号
struct node{
    int to,next;
}edge[MAXM];
int head[MAXN],cnt;
int size;
//Dfs
int ans=INF,ori[MAXN<<1];//ori与newid是互逆的，ori用来记录在新图中的编号为i的点原来的编号是多少（只记录割点）

inline void AddEdge1(int u,int v){//加原图的边
    edge1[++cnt1]=(node1){v,head1[u]};
    head1[u]=cnt1;
}

inline void AddEdge(int u,int v){//加新图的边
    edge[++cnt]=(node){v,head[u]};
    head[u]=cnt;
}

void Tarjan(int id,int pre){//割点Tarjan正常操作
    dfn[id]=low[id]=++sign;
    sta.push(id);
    if(id==root&&head1[id]==0){
        block[++vdcc].push_back(id); sta.pop();
        return;
    }
    int sub=0;
    for(register int i=head1[id];i;i=edge1[i].next){
        int aim=edge1[i].to;
        if(dfn[aim]==0){
            sub++;
            Tarjan(aim,i);
            low[id]=min(low[id],low[aim]);
            if((id==root&&sub>1)||(id!=root&&low[aim]>=dfn[id])) cut[id]=true;//判断是否为割点
            if(low[aim]>=dfn[id]){//保存联通块
                vdcc++;
                int temp;
                do{
                    temp=sta.top(); sta.pop();
                    block[vdcc].push_back(temp);
                }while(temp!=aim);
                block[vdcc].push_back(id);
            }
        }
        else if(i!=(pre^1))//可以不用判断
                 low[id]=min(low[id],dfn[aim]);
    }
}

inline void Build(){
    size=vdcc;
    for(register int i=1;i<=n;i++)//给割点单独赋在新图中的编号
        if(cut[i])//判断割点
            newid[i]=++size,ori[newid[i]]=i;
    for(register int i=1;i<=vdcc;i++){
        int temp=block[i].size();
        for(register int j=0;j<temp;j++){
            belong[block[i][j]]=i;//记录原图编号为i的点属于编号为几的联通块
            if(cut[block[i][j]])
                AddEdge(i,newid[block[i][j]]),AddEdge(newid[block[i][j]],i);
        }
    }
}

void Dfs(int id,int fa,int minn){
    if(id==belong[y]){ans=min(ans,minn); return;}
    for(register int i=head[id];i;i=edge[i].next){
        int son=edge[i].to;
        if(son!=fa){
            int temp;
            if(son!=belong[x]&&son!=belong[y]&&son>vdcc) temp=min(minn,ori[son]);//新图中割点的编号是存在newid里的，而newid是由vdcc累加得出的，所以新图编号大于原有的点双联通块的个数的点就是割点，所以minn取这个割点在原图中的编号（记在ori里的）
            else temp=minn;
            Dfs(son,id,temp);
        }
    }
}

int main(){
    read(n);
    while(true){
        int u,v; read(u),read(v); if(u==0&&v==0) break;
        AddEdge1(u,v); AddEdge1(v,u);
    }
    read(x),read(y);

    for(register int i=1;i<=n;i++)
        if(dfn[i]==0)
            root=i,Tarjan(i,0);
    Build();
    Dfs(belong[x],0,INF);
    if(ans==INF) puts("No solution");
    else print(ans);
    return 0;
}

```


---

## 作者：WaltVBAlston (赞：10)

大家好，我是Andy_2006，今天给大家讲一下这道题。

在对题目进行了2ms的分析之后，我判定这是一道利用Tarjan求割点的题目，总体难度不是很高，只要想到了方法，实现是很容易的。

主题思想：

我们把a节点当做是root（根节点），然后进行tarjan，进行玩一波正常操作之后枚举节点，输出最小的。

tarjan求割点：

假如一个点是割点（我们设为x），那么他一定满足以下性质：

1.拥有儿子（搜索树中）

2.儿子能回溯到的最早时间戳不小于x在搜索树中被遍历的时间点。

当然了，如果这个点是root并且拥有两个以上的儿子节点（搜索树中），那么这也是一个割点，可是这道题不允许我们在root放嗅探器，所以这个判定方法用不上。

如果一个点是割点，那么就是说，所有的信息都要从这里经过，我们就标记一下，方便后面枚举。

这里我们要注意的是：b节点被访问的时间戳必须不小于这个节点被访问的时间，不然的话，就算断了这里，也不能保证a和b不能传输消息。

在了解这些之后，代码就很容易写出来了：

（为了保证大家的阅读体验，我换了个码风，之前的总有人说太毒瘤了）

```
#include <cstdio>
#define ll long long
#define maxn1 2000005
#define maxn2 10000005
using namespace std; 
ll u[maxn2],v[maxn2],now[maxn1],before[maxn2],dfn[maxn1],low[maxn1],n,m,deep=0,a,b;
bool is[maxn1];
inline ll min(ll x, ll y)
{
	return x < y ? x : y;
}
void tarjan(ll x)
{
	dfn[x] = low[x] = ++deep;
	for(ll i = now[x]; i != -1; i = before[i]){
		if(!dfn[v[i]]){
			tarjan(v[i]);
			low[x] = min(low[x], low[v[i]]);
			if(low[v[i]] >= dfn[x] && x!=a && dfn[b] >= dfn[v[i]])
				is[x] = true;
		} 
		else
			low[x] = min(low[x], dfn[v[i]]);
	}
	return;
}
int main(){
	scanf("%lld", &n);
	m = 0;
	for(ll i = 1; i <= n; i++){
		now[i] = -1;
		dfn[i] = low[i] = 0;
	}
	while(1){
		m++;
		scanf("%lld%lld", &u[m], &v[m]);
		if(u[m] == 0 || v[m] == 0)
		{
			break;
		}
		before[m] = now[u[m]];
		now[u[m]] = m;
	}
	for(ll i = m + 1; i <= 2*m; i++){
		u[i] = v[i - m];
		v[i] = u[i - m];
		before[i] = now[u[i]];
		now[u[i]] = i;
	}
	scanf("%lld%lld", &a, &b);
	tarjan(a);
	for(ll i = 1; i <= n; i++){
		if(is[i]){
			printf("%lld", i);
			return 0;
		}
	}
	puts("No solution");
	return 0;
}
```

喜欢的话点个赞吧！

番外：

（哈哈，浙江省选不过如此嘛。等等，2004年？？？。。。。）

（Andy，你要点脸，你不就是通过搜索“割点”这个知识点弄到的这道题吗？）

（小声BB！）

---

## 作者：issue_is_fw (赞：7)

如果这个点是割点且删去后,$a$和$b$在不同的连通块就可行

现在问题关键就是如何判断这个割点是否把$a$,$b$隔开来了

那么现在我们从$a$点开始$tarjan$

想象一下$v$是$u$的儿子,如果$dfn[u]<=low[v]$说明$u$是割点

删掉$u$后,$a$和$v$必定隔开来

那如果$b$在$v$的一侧,不就说明$a$和$v$隔开了吗?

那$b$在$v$的一侧不就说明$dfn[b]>=dfn[v]$吗?

因为$v$是继$u$第一个被访问的,所以如果$dfn[b]<dfn[v]$

说明b在u的那一侧,删掉这个点不一定可行

```
#include <bits/stdc++.h>
using namespace std;
const int maxn=1e6+10;
int n,l,r;
struct edge{ int to,nxt; } d[maxn];
int head[maxn],cnt=1;
void add(int u,int v){ d[++cnt]=(edge){v,head[u]},head[u]=cnt; }
int dfn[maxn],low[maxn],stac[maxn],id,top,cut[maxn];
void tarjan(int u,int root)
{
	low[u]=dfn[u]=++id,stac[++top]=u;
	int flag=0;
	for(int i=head[u];i;i=d[i].nxt )
	{
		int v=d[i].to;
		if( !dfn[v] )
		{
			tarjan(v,root);
			low[u]=min( low[u],low[v] );
			if( dfn[u]<=low[v] )
			{
				flag++;
				if( u!=root||flag>=2 )
				{
					if( dfn[v]<=dfn[r] )	cut[u]=1;
				}
			}
		}
		else	low[u]=min( low[u],dfn[v] );
	}
}
int ans[maxn];
int main()
{
	cin >> n;
	while( cin >> l >> r && (l+r)!=0 )	add(l,r),add(r,l);
	cin >> l >> r;
	tarjan(l,l);
	for(int i=1;i<=n;i++)
	if( cut[i]&&i!=l&&i!=r )
	{
		cout << i;
		return 0;
	}
	cout << "No solution";
} 
```

---

## 作者：AKakA (赞：7)

~~这道是割点的模板题~~

**割点： 一个无向连通图中，删除一个点以及与它相连的所有边后，图不再连通，则称这个点是原图的割点。**

tarjan求割点：
1. 如果图中还存在未被访问过的节点 u，从任意未被访问过的节点 u 出发做DFS，并用全局变量记录 当前DFS的根为 u。
2. 当前节点 u 被访问时，记录dfn[u]，并初始化low[u] = dfn[u]，初始化 flag = 0。
3. 如果当前节点 u 有一条连向一个未访问节点 v 的边，且low[v]<low[u]，则更新 low(u) = min(low(u),low(v))。
4. 如果当前节点 u 有一条连向一个未访问节点 v 的边，且low[v]>=dfn[u]，则令 flag 加 1。如果 u 是根 且 flag >=2 ，标记 u 为割点；如果 u 不是根，标记 u 为割点。
5. 如果当前节点 u 有一条连向一个已经访问过的节点 v 的边，则 low(u) = min(low(u), dfn(v));

思路：从一个中心服务器开始求割点，再判断割点点是否把 a 和 b 必须分割到两个不连通的部分中（这样才能拦截之间的所有信息）

Code

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=400100;
int n,a,b;
int dfn[N],low[N],head[N],cut[N];  //cut记录割点
int root,tot;    //root记录根节点，tot记录搜索的编号
int ne;

struct Edge
{
	int next;
	int to;
};
Edge edge[N];  

void add(int from,int to)
{
	ne++;
	edge[ne].next=head[from];
	edge[ne].to=to;
	head[from]=ne;
}

//前向星建图

void tarjan(int u)
{
	int flag=0;                //记录根节点的子树个数（如果节点 u 
                                 是根，且拥有两颗或以上的子树，则节点 u 是一个割点。
）
	low[u]=dfn[u]=++tot;    
	for (int i=head[u];i;i=edge[i].next)
	{
		int to=edge[i].to;
		if(!dfn[to]) 
		{               
			tarjan(to);            
			if(low[to]>=dfn[u])    //点to能到达的最高的点都没有比点u高，那么点to是一个割点（前提点u不是根节点，不然可以到达另一个子树）
			{                
				flag++;
				if(flag>1||root!=u)    //上一个注释
				{
					if(dfn[to]<=dfn[b]) cut[u]=true;   // a 和 b 必须分割到两个不连通的部分中，意思就是割点必须在a，b中间
				}
			}
			else
			{
				low[u]=min(low[u],low[to]);
			}      
		}
		else
		{
			low[u]=min(low[u],dfn[to]);
		}    
	} 
}

int main()
{
	cin>>n;
	while(1)
	{
		int x,y;
		cin>>x>>y;
		if(x==0&&y==0) break;
		add(x,y);
		add(y,x);               //建双向边
	}
	cin>>a>>b;
	root=a;              //从a开始搜索
	tarjan(root);
	for(int i=1;i<=n;i++)
	{
		if(cut[i])
		{
			cout<<i<<endl;     //只用输出编号最小的
			return 0;
		}
	}
	cout<<"No solution"<<endl;
	return 0;
}
```

写题解不易，望采纳


---

## 作者：GBLoi (赞：1)

一道 $tarjan$ 题

> 蓝军共有两个信息中心，红军计划在某台中间服务器上安装一个嗅探器，从而能够侦听到两个信息中心互相交换的所有信息。

也就是说，$a$ 到 $b$ 的所有路径必须经过 那个中间服务器。

-----> 如果删去那个中间服务器，$a$ 与 $b$ 不联通。

-----> 那个中间服务器是一个割点。（一个特殊的割点）

假设用 $now$ 表示当前结点， $v$ 表示儿子。

$exa[now]$ 表示当前结点所在子树中有无 $a$

$exb[now]$ 同理

那么当且仅当以下条件全部发生时，$now$ 可以更新 $ans$

- now为割点（这是显然的，上面已分析）
- 在以上条件成立时，$a$ 与 $b$ 只能有一个在 $v$ 的子树内（因为删去 $now$ 后 $v$ 的子树的点与其他点不联通）（如果a，b都不在v内，now也可能是答案，但这是通过其他子树来实现的）。
- ```now!=a&&now!=b```(一定不要忘记)（看清题目）

## Code

```cpp
#include<cstdio>
#include<iostream>
#define LL long long
#define rint register int
using namespace std;
namespace FastIO
{
char c;
bool sign;
template<class T>
inline void read(T &x)
{
	x=0;
	sign=false;
	for(c=getchar();c<'0'||c>'9';c=getchar()) 
		if(c=='-') 
			sign=true;
	for(;c>='0'&&c<='9';c=getchar()) 
		x=(x<<1)+(x<<3)+(c&15);
	if(sign) x=~x+1;
	return;
}
}
using FastIO::read;
//======================================
const int N=2e5+5;
const int M=1e6+5;
int one[N];
int ver[M],Next[M];
int tot=0;
inline void AddEdge(const int &a,const int &b)
{
	tot++;
	Next[tot]=one[a];
	one[a]=tot;
	ver[tot]=b;
	return;
}
//======================================
int n;
int a,b;
int dfn[N],low[N],times=0;
bool exa[N],exb[N]; // 在搜索树的子树中有没有 a，b
int ans=N+3;
void tarjan(int now,const int &fa)
{
	dfn[now]=low[now]=++times;
	rint i,v,child=0;
	for(i=one[now];i>0;i=Next[i]) {
		v=ver[i];
		if(!dfn[v]) {
			child++;
			tarjan(v,now);
			low[now]=min(low[now],low[v]);
			if(exa[v]) exa[now]=true;
			if(exb[v]) exb[now]=true; 
			if((fa==-1&&child>1)||(fa!=-1&&low[v]>=dfn[now]))
				if(exa[v]^exb[v]&&now!=a&&now!=b) // !!!
					ans=min(ans,now);
		}
		else if(v!=fa) 
			low[now]=min(low[now],dfn[v]);
	}
	return;
} 
int main()
{
//	freopen("1.in","r",stdin);
	rint i;
	int x,y;
	read(n);
	while(true) {
		read(x); read(y);
		if(x==0&&y==0) 
			break;
		AddEdge(x,y);
		AddEdge(y,x);
	}
	read(a); read(b);
	exa[a]=true;
	exb[b]=true;
//	tarjan(a,-1);
	for(i=1;i<=n;i++) 
		if(dfn[i]==0) 
			tarjan(i,-1);
	if(ans==N+3) 
		puts("No solution");
	else printf("%d\n",ans);
	return 0;
}
```



---


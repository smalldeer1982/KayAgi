# [SHOI2014] 神奇化合物

## 题目背景

SHOI2014 day2t1

## 题目描述

科学家最近发现了一种高分子有机化合物 SHTSC。这种物质的分子由单个或多个原子组成，原子之间通过化学键相互连接。SHTSC 十分不稳定，其原子之间的化学键经常会伴随着炫酷的声音特效和光影效果发生断裂或者重新连接。

然而，令科学家们大为惊异的是，SHTSC 在变化过程中始终保持着一种特殊的性质：即不存在这样的原子序列 $a_1,a_2,\ldots,a_n \ (n>3)$ 满足 $a_1$ 与 $a_2$、$a_2$ 与 $a_3$、......、$a_{n-1}$ 与 $a_n$ 以及 $a_n$ 与 $a_1$ 都通过化学键相连,但它们之间却没有其他化学键相连的情况。

现在科学家将 SHTSC 的原子由 $1$ 到 $n$ 标号，并告诉你 SHTSC 的初始形态以及原子之间的化学键变化情况，他们想知道在实验过程中的某些时刻 SHTSC 分裂成了多少个分子？

## 说明/提示

对于 30%的数据，$n, q\leq 1000$。

对于 100%的数据，$n\leq 5000,m\leq 200000,q\leq 10000$。

## 样例 #1

### 输入

```
7 10
1 2
2 3
3 4
4 1
1 3
2 4
5 6
6 7
7 5
2 5
10
Q
D 2 5
Q
D 5 6
D 5 7
Q
A 2 5
Q
A 5 6
Q```

### 输出

```
1
2
3
2
1```

# 题解

## 作者：pigstd (赞：9)

我们先考虑暴力

很容易想到一个$O((m+n) \times q)$的算法：用链表存图，用二维数组记录删去的边，然后每次查询就暴力dfs

然后我们可以发现，虽然$m$很大，但是$q$很小，这意味着大多数边是永远不会被删除的，所以我们可以离线，先用并查集把所有永远不会被删掉的边缩成一个点，然后暴力就好了

设查询的次数为$k$，时间复杂度大概是$O(((q-k)+n) \times k)$，能跑过去

code：[正解](https://www.luogu.com.cn/paste/wvjq153u)

总结：在遇到不会做的题目时候，可以观察数据范围的特殊性，然后~~暴力~~对症下药

---

## 作者：foreverlasting (赞：8)

随便点开一道，发现居然能秒。然后口胡一下题解。

看到操作，明显反应是线段树分治吧，然后就做完了。当然这好像不是正解吧。

看到数据范围，就会发现这是一道傻子题。边有2e5，修改操作只有1e4，那不是随便做吗。暴力把某些一直存在的连通块记一下，这样点数迅速下降，直接暴力做就没了。

还是线段树分治好，懒得写代码了。

---

## 作者：Rorschachindark (赞：6)

# 神奇化合物
## 思路
其实这道题拿线段树分治很简单。。。

我们直接用线段树分治，然后里面用按秩合并并查集维护联通数就好了。具体操作就是每合并一次就意味着连通数减一，撤销操作就是加1。

然后也没有什么难点，数据随随便便就能跑过。

但其实这道题评为蓝牌还是有点过了，线段树分治的题再怎么也应该是紫的吧。。。可能是因为暴力能水过去。
## $\text {Code}$
```cpp
int n,m,Ans;
int fa[MAXN],size[MAXN];

stack <int> S; 

int findSet (int x)
{
	while (x ^ fa[x]) x = fa[x];
	return x;
}

void Merge (int x,int y)
{
	if (x == y) return ;
	if (size[x] > size[y]) swap (x,y);
	Ans --,S.push (x),size[y] += size[x],fa[x] = y;
}

struct Edge
{
	int u,v,l,r;//相连的两个点，持续时间 
}e[MAXX + MAXK]; 

vector <int> tree[MAXK << 2];

void update (int k,int l,int r,int tl,int tr,int res)
{
	if (l > tr || tl > r) return ;
	if (l >= tl && r <= tr) return tree[k].push_back (res);
	int mid = (l + r) >> 1;
	update (k << 1,l,mid,tl,tr,res);
	update (k << 1 | 1,mid + 1,r,tl,tr,res);
}

void Delete (int tag)
{
	while (S.size() > tag)
	{
		int x = S.top();S.pop ();
		Ans ++,size[fa[x]] -= size[x],fa[x] = x;
	}	
}

void Divide (int k,int l,int r)
{
	int tag = S.size();
	for (Int i = 0;i < tree[k].size();++ i)
	{
		int x = tree[k][i],u = e[x].u,v = e[x].v;
		u = findSet (u),v = findSet (v);
		Merge (u,v);
	}
	if (l == r)
	{
		write (Ans),putchar ('\n');
		return Delete (tag);
	}
	int mid = (l + r) >> 1;
	Divide (k << 1,l,mid),Divide (k << 1 | 1,mid + 1,r);
	return Delete (tag);
}

map <int,int> mp[MAXN];

signed main()
{
	n = Ans = read (),m = read ();
	for (Int i = 1;i <= n;++ i) fa[i] = i,size[i] = 1;
	for (Int i = 1;i <= m;++ i) e[i].u = read (),e[i].v = read (),e[i].l = 1,mp[e[i].u][e[i].v] = mp[e[i].v][e[i].u] = i;
	int q = read (),cnt = 0,ecnt = m;
	for (Int i = 1;i <= q;++ i)
	{
		char s[10] = {};
		scanf ("%s",s);
		if (s[0] == 'A')
		{
			int x = read (),y = read ();
			mp[x][y] = mp[y][x] = ++ ecnt;
			e[ecnt] = Edge {x,y,cnt + 1,0};
		}
		else if (s[0] == 'D')
		{
			int x = read (),y = read ();
			e[mp[x][y]].r = cnt + 1;
		}
		else ++ cnt;
	}
	for (Int i = 1;i <= ecnt;++ i) 
	{
		if (e[i].r == 0) e[i].r = cnt + 1;
		if (e[i].l < e[i].r) update (1,1,cnt,e[i].l,e[i].r - 1,i);
	}
	Divide (1,1,cnt);
    return 0;
}
```

---

## 作者：huayucaiji (赞：2)

**2021/3/15 修复了代码中的一个小bug。**~~再次吐槽数据是真的水~~

------

我做完这个题才发现可以用缩点+暴力水过去。。。。建议加强数据吧。

我的第一思路是线段树分治。看到这种动态图，第一反应是线段树分治没什么问题吧。。。。

具体来说，我们把每条边出现的时间统计出来，挂到线段树上，然后遍历一遍即可。要标记一下每次询问的时间点。判断图的块数的话，可以用**可撤销并查集**，用栈记录一下每次的操作，最后回退回去就好了。

问题是如何记录每条边出现的时间呢？我们可以开一个数组 $a_{i,j}$ 记录 $(i,j)$ 这条边目前最早一次出现的时间点。

- 如果遇到 `A i j`，就把 $a_{i,j}$ 更改成当前时间点。
- 如果是 `D i j`，就把 $a_{i,j}$ 记为 $0$，把这一段时间挂到线段树上即可。

最后遍历线段树，每个时间点的答案就算出来了，只需要对号入座即可。

```cpp
//Don't act like a loser.
//This code is written by huayucaiji
//You can only use the code for studying or finding mistakes
//Or,you'll be punished by Sakyamuni!!!
#include<bits/stdc++.h>
#define int long long
#define pr pair<int,int>
using namespace std;

int read() {
	char ch=getchar();
	int f=1,x=0;
	while(ch<'0'||ch>'9') {
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') {
		x=x*10+ch-'0';
		ch=getchar();
	}
	return f*x;
}

const int MAXN=5000+10,MAXM=4e5+10;

int n,m,q,cnt,num;
stack<pr > stk;
int size[MAXN],father[MAXN],a[MAXN][MAXN],qu[MAXM],ans[MAXM];
vector<pr > edge[MAXM<<2];

int find(int x) {
	if(x!=father[x]) {
		return find(father[x]);
	}
	return x;
}
void merge(pr s) {
	int x=find(s.first);
	int y=find(s.second);
	if(x==y) {
		stk.push(make_pair(-1,-1));
		return ;
	}
	num--;
	if(size[x]>size[y]) {
		swap(x,y);
	}
	father[x]=y;
	size[y]+=size[x];
	stk.push(make_pair(x,y));
}
void del() {
	int x=stk.top().first;
	int y=stk.top().second;
	stk.pop();
	if(x==-1) {
		return ;
	}
	num++;
	father[x]=x;
	size[y]-=size[x];
}

void modify(int l,int r,int p,int x,int y,pr s) {
	if(r<x||y<l) {
		return ;
	}
	if(x<=l&&r<=y) {
		edge[p].push_back(s);
		return ;
	}
	
	int mid=(l+r)>>1;
	modify(l,mid,p<<1,x,y,s);
	modify(mid+1,r,p<<1|1,x,y,s);
}

void query(int l,int r,int p) {
	int sz=edge[p].size();
	for(int i=0;i<sz;i++) {
		merge(edge[p][i]);
        //加边
	}
	if(l==r) {
		ans[l]=num;
	}
	else {
		int mid=(l+r)>>1;
		query(l,mid,p<<1);
        //遍历线段树
		query(mid+1,r,p<<1|1);
	} 
	while(sz--) {
		del();
        //回退操作
	}
}

signed main() {
	cin>>n>>m;
	num=n;
	for(int i=1;i<=n;i++) {
		father[i]=i;
		size[i]=i;
	} 
	for(int i=1;i<=m;i++)  {
		int u,v;
		u=read();
		v=read();
		a[u][v]=a[v][u]=1;
	}
	cin>>q;
	
	for(int i=1;i<=q;i++) {
		char c;
		cin>>c;
		if(c=='Q') {
			qu[++cnt]=i;
		}
		if(c=='A') {
			int u,v;
			u=read();
			v=read();
			a[u][v]=a[v][u]=i;
		}
		if(c=='D') {
			int u,v;
			u=read();
			v=read();
			modify(1,q,1,a[u][v],i-1,make_pair(u,v));
			a[u][v]=a[v][u]=0;
		}
	}
	for(int i=1;i<=n;i++) {
		for(int j=1;j<i;j++) {
			if(a[i][j]) {
				modify(1,q,1,a[i][j],q,make_pair(i,j));
			}
		}
	}
	
	query(1,q,1);
	for(int i=1;i<=cnt;i++) {
		cout<<ans[qu[i]]<<endl; 
	}
	return 0;
}
/*
7 10
1 2
2 3
3 4
4 1
1 3
2 4
5 6
6 7
7 5
2 5
3
Q
D 2 5
Q
*/
```

---

## 作者：tjtdrxxz (赞：1)

我们发现这题并没有强制在线，所以考虑线段树分治。

线段树分治很好理解，就是以时间为单位构造一棵线段树，对于有基于时间或者撤销操作的题能够以 $ O (n \log {n} \times x) $ 的时间复杂度~~创~~过去，其中 $ x $ 是线段树上维护的数据结构的时间复杂度。

回到这道题，因为是动态图连通性，所以可以用并查集去维护，对于一条边，我们记录他的出现时间和消失时间，在线段树上的这段区间中对维护的并查集进行加边操作。因为加入的边会在一定时间后消失，所以并查集应该是可撤销的。

可撤销并查集很好写，就是在原按秩合并的并查集的基础上加一个栈记录每次修改的节点，撤销的时候从栈顶一次修改就好了。至于为什么可删，因为是按秩合并的并查集，所以每次两点关系不会被修改（类比路径压缩）。这样就能实现可撤销功能。

具体实现参考代码：

code：
```cpp
# include <bits/stdc++.h>
using namespace std;
using size_s = unsigned int;
int fa[1000012], siz[1000012];
int qx[1000012], qy[1000011];
int l[1000011], r[1000011];
vector <int> q;
int ans;
int find (int x)
{
	return fa[x] == x ? x : find (fa[x]);
}
int merge (int x, int y)
{
	x = find (x), y = find (y);
	if (x == y) return false;
	if (siz[x] < siz[y])
	{
		swap (x, y);
	}
	q.push_back (y);
	siz[x] += siz[y];
	fa[y] = x, ans --;
	return true;
}
void cut ()
{
	int x = q.back ();
	q.pop_back (), ans ++;
	siz[fa[x]] -= siz[x];
	fa[x] = x;
}
char op[1000011];
int n, m, k;
struct SegTree
{
	size_s l, r, mid;
	SegTree *ls, *rs;
	vector <int> stk;
	SegTree (size_s s, size_s t) :
		l {s}, r {t}, mid { (l + r) >> 1 },
		ls {nullptr}, rs {nullptr}
		{
			if (l == r)
			{
				return;
			}
			ls = new SegTree (l, mid + 0);
			rs = new SegTree (mid + 1, r);
		}
	void modify (size_s s, size_s t, int x)
	{
//		cout << s << ' ' << t << endl;
		if (s > t) return;
		if (l >= s and r <= t)
		{
			stk.push_back (x);
			return;
		}
		if (s <= mid) ls -> modify (s, t, x);
		if (t >  mid) rs -> modify (s, t, x);
	}
	void solve ()
	{
		int cnt = 0;
		for (auto x : stk)
		{
			int u = qx[x], v = qy[x];
//			cout << "num : " << u << ' ' << v << endl;
			cnt += merge (u, v);
		}
		if (l == r)
		{
			if (op[l] == 'Q')
			{
				cout << ans << endl;
			}
		}
		else
		{
			ls -> solve ();
			rs -> solve ();
		}
		while (cnt --)
		{
			cut ();
		}
	}
};
int mp[5011][5011], tot;
int lt[5011][5011];
int main ()
{
	cin >> n >> m;
	for (int i = 1; i <= n; i ++) fa[i] = i, siz[i] = 1;
	for (int i = 1; i <= m; i ++)
	{
		int u,v;
		cin >> u >> v;
		if (u > v) swap (u, v);
		mp[u][v] = ++ tot;
		qx[tot] = u, qy[tot] = v;
		l[tot] = 1;
	}
	cin >> k;
	ans = n;
	SegTree tr (1, k);
	for (int i = 1; i <= k; i ++)
	{
		cin >> op[i];
		if (op[i] == 'A')
		{
			int u, v;
			cin >> u >> v;
			if (u > v) swap (u, v);
			mp[u][v] = ++ tot;
			qx[tot] = u;
			qy[tot] = v;
			l[tot] = i;
		}
		else if (op[i] == 'D')
		{
			int u, v;
			cin >> u >> v;
			if (u > v) swap (u, v);
			r[mp[u][v]] = i;
		}
	}
	for (int i = 1; i <= tot; i ++)
	{
		if (r[i] == 0) r[i] = k;
		if (l[i] < r[i])
		{
			tr.modify (l[i], r[i], i);
		}
	}
	tr.solve ();
	return 0;
}
```

---

## 作者：Yajnun (赞：1)

### 根据题意，一条边被删去会使联通块个数$+1$当且仅当该边不处于一个三元环内。同理，加边时，若两点属于同一联通块，则两点均与同一点直接相连

### 先用并查集算出初始联通块数，在用bitset维护连边情况即可
```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cmath>
#include<stack>
#include<cstring>
#include<bitset>
#include<string>
#define ll long long
#define maxn 5005
#define re(i,a,b) for(int i=a;i<=b;i++)
using namespace std;
inline int read(){char c=getchar();int f=1;int ans = 0;while(c>'9'||c<'0'){if(c=='-')f=-f;c=getchar();}while(c<='9'&&c>='0'){ans =ans*10+c-'0';c=getchar();}return ans*f;}
//_____________________________________________________________________________________________________
int n,m,fa[maxn];
bitset<maxn>bit[maxn];
int find(int x)
{return fa[x]==x?x:fa[x]=find(fa[x]);}
int main()
{
	n=read(),m=read();
	re(i,1,n) fa[i] = i;
	int ans = n;
	while(m--)
	{
		int x=read(),y=read();
		bit[x].set(y,1); bit[y].set(x,1);
		int xx = find(x),  yy=find(y);
		if(xx!=yy)
			--ans, fa[xx] = yy;
	}
	int q = read();
	char c[10] ;
	while(q--)
	{
		scanf("%s",c);
		if(c[0]=='Q') printf("%d\n",ans);
		else 
		{
			int x = read(),y=read();
			if(c[0]=='A')
			{
				if((bit[x]&bit[y]).none()) --ans;
				bit[x].set(y,1);bit[y].set(x,1);
			}
			else
			{
				bit[x].set(y,0);bit[y].set(x,0);
				if((bit[x]&bit[y]).none()) ++ans;
			}
		}
	}
	return 0;
}
```


---

## 作者：LastKismet (赞：0)

# Sol
很水的题吧……显然直接套线段树分治就没了。

翻译一下题意，就是对一个图动态删边连边，求不同时刻的连通块数。

线段树分治时间轴，把边挂在相应的作用范围上，可撤销并查集维护连通性，没了。
# Code
```cpp
const int N=5005,M=2e5+5,Q=1e4+5;

int n,m,q;

stack<pii> stk;
struct DSU{
	int sz;
	int fa[N],rk[N];
	void init(){rep(i,1,n)fa[i]=i,rk[i]=1;sz=n;}
	int find(int x){while(fa[x]!=x)x=fa[x];return x;}
	void merge(int a,int b){
		a=find(a),b=find(b);
		--sz;
		if(rk[a]>rk[b])swap(a,b);
		fa[a]=b;stk.push({a,rk[b]});
		if(rk[a]==rk[b])++rk[b];
	}
	bool same(int a,int b){return find(a)==find(b);}
}dsu;

int ans[Q];

struct segment{
	vec<pii> dat[Q<<2];
	void modify(int lq,int rq,pii v,int x=1,int l=0,int r=q){
		if(lq<=l&&r<=rq)return dat[x].pub(v);
		int m=l+r>>1;
		if(lq<=m)modify(lq,rq,v,x<<1,l,m);
		if(m<rq)modify(lq,rq,v,x<<1|1,m+1,r);
	}
	void query(int x=1,int l=0,int r=q){
		int cnt=0;
		for(auto i:dat[x])if(!dsu.same(i.fir,i.sec))dsu.merge(i.fir,i.sec),++cnt;
		if(l!=r){
			int m=l+r>>1;
			query(x<<1,l,m);
			query(x<<1|1,m+1,r);
		}else ans[l]=dsu.sz;
		while(cnt--){
			auto tp=stk.top();stk.pop();
			int f=dsu.fa[tp.fir];
			++dsu.sz;
			dsu.rk[f]=tp.sec;
			dsu.fa[tp.fir]=tp.fir;
		}
	}
}seg;

int lst[M+Q];
map<pii,int> mp;
pii edg[M+Q];
vec<int> qs;

inline void Main(){
    read(n,m);
	dsu.init();
	rep(i,1,m){
		int a,b;read(a,b);
		mp[minmax(a,b)]=i;
		edg[i]={a,b};
	}
	read(q);
	rep(i,1,q){
		char op;read(op);
		if(op=='A'){
			int a,b;read(a,b);
			mp[minmax(a,b)]=++m;
			edg[m]={a,b};
			lst[m]=i;
		}else if(op=='D'){
			int a,b;read(a,b);
			int e=mp[minmax(a,b)];
			seg.modify(lst[e],i-1,{a,b});
			lst[e]=q+1;
		}else qs.pub(i);
	}
	rep(i,1,m)if(lst[i]<=q)seg.modify(lst[i],q,edg[i]);
	seg.query();
	for(auto i:qs)put(ans[i]);
}
```

---

## 作者：D0000 (赞：0)

为啥没有 $nq$ 做法？

题目描述第二段的意思就是本题中所有简单环的长度为 $3$。也就是说若两点在环上当且仅当它们在一个长度为三的环上。然后加边（删边）主要是需要判断两点加边前（删边后）在不在环（也就是长度为 $3$ 的环）上。使用邻接矩阵记录某两个点是否存在边。挨个判断环上的第三个点即可。

代码：

```cpp

#include<cstdio>
int n,m,a,b;
bool fl[5005][5005],vis[5005];
int ans;
void dfs(int now){
	vis[now]=1;
	for(int i=1;i<=n;i++)if(fl[now][i]&&!vis[i])dfs(i);
}
int main(){
	scanf("%d%d",&n,&m);
	while(m--)scanf("%d%d",&a,&b),fl[a][b]=fl[b][a]=1;
	for(int i=1;i<=n;i++)if(!vis[i])dfs(i),ans++;
	scanf("%d",&m);
	while(m--){
		char c[2];
		scanf("%s",c+1);
		if(c[1]=='Q')printf("%d\n",ans);
		else{
			scanf("%d%d",&a,&b);
			if(c[1]=='A'){
				if(fl[a][b])continue;
				ans--;fl[a][b]=fl[b][a]=1;
				for(int z=1;z<=n;z++){
					if(fl[a][z]&&fl[b][z]){
						ans++;
						break;
					}
				}
			}
			else{
				if(!fl[a][b])continue;
				ans++;fl[a][b]=fl[b][a]=0;
				for(int z=1;z<=n;z++){
					if(fl[a][z]&&fl[b][z]){
						ans--;
						break;
					}
				}
			}
		}
	}
}
```

---

## 作者：sunset_breeze (赞：0)

# 题意
给你一个 $n$ 个节点的图，要求支持动态删边，加边，求图的连通块数量。

# 思路
发现这是一道动态树板题，~~直接在线 `LCT`~~，但注意到 $n \le 5000$ 的特殊数据范围，且没有强制在线，所以我们换种思路，分析性质，令时间轴为 $Q$ 操作的询问时间，容易得到一条边只会有 $[st,ed)$ 的生效区间。这时，直接操作序列分治树也就是线段树分治解决。

## 具体实现
用一颗线段树维护时间轴，树上每个节点代表 $[l,r]$ 的时间，将离线下来后边的生效区间扔到线段树里，因为这些信息不可合并，所以每个节点再各开一个 `vector` 记录。

最后遍历分治树（线段树），由于是按照时间顺序建树，所以前序 `dfs` 即可还原询问结果。但 `dfs` 时需要维护**无向图**联通块数，且需要回滚，用**回滚并查集**即可。

## $Code$
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e3+50,M=2e5+50,Q=1e4+50;
int n,m,q;
int f[N],mp[N][N],tot,top,h[N],cnt,Ans;
struct node{
	int x,y,flag;
}s[N];
struct edge{
	int u,v,l,r;
}e[M+Q];
int Find(int x)
{
	if(x==f[x])return x;
	return Find(f[x]);
}
void merge(int x,int y)
{
	int xx=Find(x),yy=Find(y);
	if(xx==yy)return;
	if(h[xx]>h[yy])swap(xx,yy);
	f[xx]=yy;Ans--;
	s[++top]=(node){xx,yy,h[xx]=h[yy]};
	if(h[xx]=h[yy])h[yy]++;
}
vector<int> g[N*18];
void update(int p,int l,int r,int x,int y,int k)
{
	if(x<=l&&r<=y)
	{
		g[p].push_back(k);
		return;
	}
	int mid=(l+r)>>1;
	if(x<=mid)update(p*2,l,mid,x,y,k);
	if(y>mid)update(p*2+1,mid+1,r,x,y,k);
}
void solve(int p,int l,int r)
{
	int lasttop=top;
	for(int i=0;i<(int)g[p].size();i++)merge(e[g[p][i]].u,e[g[p][i]].v);
	if(l==r)printf("%d\n",Ans);
	else
	{
		int mid=(l+r)>>1;
		solve(p*2,l,mid);solve(p*2+1,mid+1,r);
	}
	while(top>lasttop)
	{
		h[f[s[top].x]]-=s[top].flag;
		f[s[top].x]=s[top].x;
		top--;Ans++;
	}
}
int main()
{
	scanf("%d %d",&n,&m);Ans=n;
	for(int i=1;i<=n;i++)f[i]=i,h[i]=1;
	for(int i=1;i<=m;i++)
	{
		int u,v;
		scanf("%d %d",&u,&v);
		mp[u][v]=mp[v][u]=++tot;
		e[i].u=u;e[i].v=v;e[i].l=1;
	}
	scanf("%d",&q);
	for(int i=1;i<=q;i++)
	{
		char op[10];
		scanf("%s",op);
		if(op[0]=='A')
		{
			int x,y;
			scanf("%d %d",&x,&y);
			mp[x][y]=mp[y][x]=++tot;
			e[tot].u=x;e[tot].v=y;e[tot].l=cnt+1;
		}
		else if(op[0]=='D')
		{
			int x,y;
			scanf("%d %d",&x,&y);
			e[mp[x][y]].r=cnt+1;
		}
		else cnt++;
	}
	for(int i=1;i<=tot;i++)
	{
		if(e[i].r==0)e[i].r=cnt+1;
		if(e[i].l<e[i].r)update(1,1,cnt,e[i].l,e[i].r-1,i);
	}
	solve(1,1,cnt);
	return 0;
}
```

---

## 作者：CaoXian (赞：0)

线段树分治，感觉跟模板题很像啊。

如何统计一张无向图的极大联通子图个数？可以直接用并查集维护结点之间的联通关系，统计有多少个集合即可。

但是这道题有删除操作，并查集不能简单地执行这种操作，所以得改变我们的维护方式，尝试把修改和询问离线下来。

一个插入和删除操作正好是配对的，在一条边被插入后直到这条边被删除前，这条边都有可能对答案做出贡献，这启发我们对时间轴做一些操作。

具体地，可以对 $[0, q]$ 这一段时间建一棵线段树，把一条边的加入和删除看作在这棵线段树上区间“加边”，如果某一个区间被覆盖到了就表示在这一段时间里这条边是存在的。

线段树分治就很套路了，进入一个区间的时候把这个区间上存储的边全部加进并查集里面，退出区间的时候撤销掉这些连边操作。因为涉及到撤销，所以并查集不能用路径压缩而是得用按秩合并优化。

统计答案的话就是：连边时如果两个结点不在同一个集合里就将当前极大联通子图个数减 $1$，撤销连边时将当前极大联通子图个数加 $1$。

连边操作用一个栈记录下来即可，撤销时弹栈弹到旧栈顶即可。

附一份代码，有点丑，代码里是把一个连边操作压到了一个 `long long` 变量里：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n, m, q, u, v, rel;
unordered_map<ll, int> mp;
char op;
struct Segment_Tree {
	int pos, L, R, top, ans, l[40005], r[40005], father[5005], height[5005];
	bool flag[40005];
	ll v;
	pair<int, int> st[40005];
	vector<ll> g[40005];
	#define lc (k << 1)
	#define rc (lc | 1)
	#define mid ((l[k] + r[k]) >> 1)
	Segment_Tree() {
		for(int i = 1; i <= 5000; ++i) father[i] = i, height[i] = 1;
	}
	int findset(int x) {return father[x] == x ? x : findset(father[x]);}
	void merge(int x, int y) {
		if(x == y) return;
		--ans;
		if(height[x] > height[y]) swap(x, y);
		st[++top] = make_pair(x, height[x] == height[y]);
		father[x] = y, height[y] -= (height[x] == height[y]);
	}
	void demerge() {
		++ans;
		height[father[st[top].first]] -= st[top].second;
		father[st[top].first] = st[top].first;
		--top;
	}
	void build(int k) {
		if(l[k] == r[k]) return;
		l[lc] = l[k], r[lc] = mid, l[rc] = mid + 1, r[rc] = r[k];
		build(lc), build(rc);
	}
	void change(int k) {
		if(L <= l[k] && r[k] <= R) {
			g[k].push_back(v);
			return;
		}
		if(L <= mid) change(lc);
		if(R > mid) change(rc);
	}
	void add(int k) {
		if(l[k] == r[k]) {
			flag[k] = true;
			return;
		}
		if(pos <= mid) add(lc);
		else add(rc);
	}
	void solve(int k) {
		int last = top;
		for(const auto& i : g[k]) {
			merge(findset(i >> 31), findset(i & 2147483647));
		}
		if(l[k] == r[k]) {
			if(flag[k]) cout << ans << '\n';
		}
		else {
			solve(lc), solve(rc);
		}
		while(top > last) demerge();
	}
	void change(int lt, int rt, ll val) {
		L = lt, R = rt, v = val;
		return change(1);
	}
	void Add(int Pos) {
		pos = Pos;
		return add(1);
	}
} tree;
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin >> n >> m;
	while(m--) {
		cin >> u >> v;
		if(u > v) swap(u, v);
		rel = (u << 31) | v;
		mp[rel] = 0;
	}
	cin >> q;
	tree.l[1] = 0, tree.r[1] = q;
	tree.build(1);
	for(int i = 1; i <= q; ++i) {
		cin >> op;
		if(op == 'A') {
			cin >> u >> v;
			if(u > v) swap(u, v);
			rel = (u << 31) | v;
			mp[rel] = i;
		}
		else if(op == 'D') {
			cin >> u >> v;
			if(u > v) swap(u, v);
			rel = (u << 31) | v;
			tree.change(mp[rel], i - 1, rel);
			mp.erase(rel);
		}
		else if(op == 'Q') {
			tree.Add(i);
		}
	}
	for(const auto& i : mp) {
		tree.change(i.second, q, i.first);
	}
	tree.ans = n;
	tree.solve(1);
	return 0;
}
```

---

## 作者：Natori (赞：0)

>[P5214 [SHOI2014] 神奇化合物](https://www.luogu.com.cn/problem/P5214)

这篇题解补一下对题目中特殊性质的分析，虽然线段树分治做法好像并没有用到它。

考虑下面这个环：

![](https://cdn.luogu.com.cn/upload/image_hosting/08svjg3q.png)

显然这个环不合法。

那么加一条边能使它变得合法吗？答案是也不能。

![](https://cdn.luogu.com.cn/upload/image_hosting/38yqchim.png)

考虑上面的连通块，虽然比之前的环多了一条边，但它仍然是不合法的。因为此时出现了两个大小为 $4$ 的环，仍然不符合要求。

这是否就意味着所有环都不符合要求？也不是。题目中的特殊性质只针对 $n \ge 4$ 的情况，因此如果一个环只有三个点，那么它就是符合要求的。

于是，所有连通块仅有如下几种形态：

![](https://cdn.luogu.com.cn/upload/image_hosting/morl2b0g.png)

从左到右分别为环、树和基环树，环和基环树应满足环的点数为 $3$。单点和两点之间连有一条边的情况算在了树里面。

**综上讨论，一条边被删去会使联通块个数增加 $1$，当且仅当该边不处于一个点数为 $3$ 的环内。**

到这里就有很多种做法，包括各种暴力以及 ```std::bitset```，其他题解都有，这里不再赘述。

------------

提一下线段树分治做法，需要先将所有操作离线下来，并记录每条边存在的时间段，以及每次询问的时刻。时间区间是 $[1,q]$。

维护一个可撤销并查集，并用一个栈存储连通块大小较小的点。开一个全局变量 $ans$ 维护当前的答案。

当递归到分治树的一个节点 $u$ 时，将之前插入到 $u$ 的边的两端点所在并查集合并。然后判断当前节点是否为叶节点：若是则输出答案并撤销至当前节点合并之前的情形，随后回溯；否则递归下去。

并查集合并时 $ans$ 减去 $1$，撤销时 $ans$ 加上 $1$。

理解其正确性：如果并查集合并成功，说明两端点不在同一连通块内，此时加边会使答案自增。而撤销是合并的“逆运算”，所以答案要自减。

至于为什么不用管删边，这就是线段树分治将删除转化为撤销的巧妙之处。由于之前已经将每条边的存在时段记录下来，所以线段树分治的撤销就相当于在加入这条边后删除它！

该算法的时间复杂度为 $\mathcal{O}(q \log q \log n)$，可以轻松通过。~~然而似乎并没有 bitset 跑得快~~

具体细节可以看代码，如果有问题恳请指出！

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e3+7,M=2e5+7,Q=1e4+7;
int n,m,q,edge_tot,qcnt;
char opt[7];
struct Edge{
	int from,to,timl,timr;
}edge[M+Q];
unordered_map<int,int> uom[N];
int stc[Q],top,ans;
struct Disjoint_Set_Union{
	int fa[N],siz[N];
	void init(){
		for(int i=1;i<=n;i++){
			fa[i]=i;
			siz[i]=1;
		}
	}
	int find(int x){
		return fa[x]==x?x:find(fa[x]);
	}
	void unite(int x,int y){
		if(x==y)
			return;
		if(siz[x]>siz[y])
			swap(x,y);
		ans--;
		stc[++top]=x;
		siz[y]+=siz[x];
		fa[x]=y;
	}
	void undo(int sz){/*撤销至栈中有sz个元素的情形*/
		while(top>sz){
			int x=stc[top];
			top--;
			ans++;
			siz[fa[x]]-=siz[x];
			fa[x]=x;
		}
	}
}dsu;
vector<int> smtdv[Q<<2];
#define ls(o) (o)<<1
#define rs(o) (o)<<1|1
void insert(int o,int l,int r,int ql,int qr,int eg){
	if(ql<=l&&r<=qr){
		smtdv[o].push_back(eg);
		return;
	}
	int mid=(l+r)/2;
	if(ql<=mid)
		insert(ls(o),l,mid,ql,qr,eg);
	if(mid+1<=qr)
		insert(rs(o),mid+1,r,ql,qr,eg);
}
void divide(int o,int l,int r){
	int sz=top;
	for(auto cur:smtdv[o]){
		int u=edge[cur].from,v=edge[cur].to;
		u=dsu.find(u);
		v=dsu.find(v);
		dsu.unite(u,v);
	}
	if(l==r){
		cout<<ans<<'\n';
		dsu.undo(sz);
		return;
	}
	int mid=(l+r)/2;
	divide(ls(o),l,mid);
	divide(rs(o),mid+1,r);
	dsu.undo(sz);
}
#undef ls
#undef rs
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	ans=n;
	dsu.init();
	for(int i=1,u,v;i<=m;i++){
		cin>>u>>v;
		edge[i].from=u;
		edge[i].to=v;
		edge[i].timl=1;
		uom[u][v]=uom[v][u]=i;
	}
	cin>>q;
	edge_tot=m;
	for(int i=1,u,v;i<=q;i++){
		cin>>opt;
		if(opt[0]=='A'){
			cin>>u>>v;
			uom[u][v]=uom[v][u]=++edge_tot;
			edge[edge_tot]={u,v,qcnt+1,0};
		}
		else if(opt[0]=='D'){
			cin>>u>>v;
			edge[uom[u][v]].timr=qcnt+1;
		}
		else if(opt[0]=='Q')
			qcnt++;
	}
	for(int i=1;i<=edge_tot;i++){
		if(edge[i].timr==0)
			edge[i].timr=qcnt+1;
		if(edge[i].timl<edge[i].timr)
			insert(1,1,qcnt,edge[i].timl,edge[i].timr-1,i);
	}
	divide(1,1,qcnt);
	return 0;
}
```

推荐一篇关于线段树分治的[博客](https://foreverlasting1202.github.io/2019/07/19/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E6%B2%BB%E6%80%BB%E7%BB%93/)~~，比我这个蒟蒻讲得好多了~~。

---

## 作者：hexz01 (赞：0)

唠几句：   
一开始让我写这道题，其实我是，是拒绝的。    
我跟大爷讲，我拒绝，因为，其实我，根本搞不懂这个时间复杂度。    
大爷跟我讲，敲时加特技，代码很短很快很好。    
加了30行特技之后呢，代码    
后来我其实知道这个是真的，是有时间复杂度保证的。我的代码呢，就这么加特技，加了很多特技，代码，    
我敲完的代码就是这个样子的，你敲完也会是这个样子，因为...   

加！特！技！
---
离线后有些边一定不会被删，然后用这些边来并查集缩点。
然后数据规模就很小的，这样我们就可以暴力搞了。    

---
AC代码：
```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define N 5050
#define M 501000
using namespace std;
int ru[M],rv[M];
struct KSD
{
    int v,len,next;
}e[M];
int head[N],cnt;
int f[N],map[N][N];
int find(int x){return (x==f[x])?x:f[x]=find(f[x]);}
inline void add(int u,int v,int len=1)
{
    map[u][v]=++cnt;
    e[cnt].v=v;
    e[cnt].len=len;
    e[cnt].next=head[u];
    head[u]=cnt;
}
int n,m,q;
struct QUERY
{
    int f,a,b;
    QUERY(int _f=0,int _a=0,int _b=0):f(_f),a(_a),b(_b){}
    void read(int _f)
    {
        f=_f;
        scanf("%d%d",&a,&b);
        if(f==2)map[a][b]=map[b][a]=0;
    }
}query[10100];
bool vis[N];
void dfs(int x)
{
    int i,v;
    vis[x]=true;
    for(i=head[x];i;i=e[i].next)
    {
        if(e[i].len)
        {
            v=e[i].v;
            if(!vis[v])dfs(v);
        }
    }
}
char tt[5];
int main()
{
    freopen("test.in","r",stdin); 
    int i,j,k;
    int a,b,c;
    int fa,fb;

    scanf("%d%d",&n,&m);
    for(i=1;i<=n;i++)f[i]=i;
    for(i=1;i<=m;i++)
    {
        scanf("%d%d",&a,&b);
        ru[i]=a,rv[i]=b;
        map[a][b]=map[b][a]=true;
    }
    scanf("%d",&q);
    for(i=1;i<=q;i++)
    {
        scanf("%s",tt);
        if(tt[0]=='Q')continue;
        else if(tt[0]=='A')query[i].read(1);
        else query[i].read(2);
    }
    for(i=1;i<n;i++)for(j=i+1;j<=n;j++)
        if(map[i][j])f[find(j)]=find(i);
    memset(map,0,sizeof map),cnt=1;
    for(i=1;i<=m;i++)
    {
        a=find(ru[i]),b=find(rv[i]);
        if(a==b)continue;
        if(map[a][b])e[map[a][b]].len++,e[map[b][a]].len++;
        else add(a,b),add(b,a);
    }
    for(i=1;i<=n;i++)find(i);
    for(i=1;i<=q;i++)
    {
        if(!query[i].f)
        {
            int ret=0;
            memset(vis,0,sizeof vis);
            for(j=1;j<=n;j++)if(f[j]==j&&!vis[j])
            {
                ret++;
                dfs(j);
            }
            printf("%d\n",ret);
        }
        else if(query[i].f==1)
        {
            a=f[query[i].a],b=f[query[i].b];
            if(map[a][b])e[map[a][b]].len++,e[map[b][a]].len++;
            else add(a,b),add(b,a);
        }
        else 
        {
            a=f[query[i].a],b=f[query[i].b];
            e[map[a][b]].len--,e[map[b][a]].len--;
        }
    }
    return 0;
}

```
点个赞在走呗！（*＾3＾）

---

## 作者：louhao088 (赞：0)

# 神奇化合物

## 题意
给一个图，对其进行删边和加边，求联通块。


------------

## 思路


### $30pt$
我们看到数据，立刻想到了一个$m*q$的暴力解法，把删边用二维数组标记，对每次询问用$m$的时间复杂度求

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
	char ch=getchar();int x=0;bool f=0;
	for(;!isdigit(ch);ch=getchar())if(ch=='-')f=1;
	for(;isdigit(ch);ch=getchar())x=(x<<1)+(x<<3)+(ch^48);
	if(f==1)x=-x;return x;
}
struct node
{
	int v,nex;
}e[500005];
int n,m,q,x,y,cnt=0,ans=0,head[5005];
bool flag[5005][5005],vis[5005];
char ch=0;
void add(int u,int v)
{
	e[++cnt].v=v,e[cnt].nex=head[u],head[u]=cnt;
}
void dfs(int x)
{
	for(int i=head[x];i;i=e[i].nex)
	{
		if(!vis[e[i].v]&&!flag[x][e[i].v])vis[e[i].v]=1,dfs(e[i].v);
	}
}
int main()
{
	freopen("edge.in","r",stdin);
	freopen("edge.out","w",stdout);
	n=read();m=read();
	for(int i=1;i<=m;i++)
	{
		x=read(),y=read();add(x,y),add(y,x);
	}
	q=read();
	while(q--)
	{
		while(ch!='Q'&&ch!='D'&&ch!='A')ch=getchar();
		if(ch=='Q')
		{
			memset(vis,0,sizeof vis);ans=0;
			for(int i=1;i<=n;i++)
			{
				if(!vis[i])ans++,dfs(i);
			}
			cout<<ans<<endl;
		}
		else if(ch=='D')
		{
			x=read(),y=read();
			flag[x][y]=1;
			flag[y][x]=1;
		}
		else if(ch=='A')
		{
			x=read(),y=read();
			add(x,y),add(y,x);
			flag[x][y]=0,flag[y][x]=0;
		}
		ch=0;
	}
	return 0;
}
```


------------

### $100pt$

我们发现m远大于q,所以考虑缩点，把永不删除的边标记，进行一遍求联通块，把值$Hash$了发现只剩下很少的点，之后直接暴力即可。

注：同一联通块之间不能连边，两个联通块之间会有多个边要记录

```cpp
#include<bits/stdc++.h>
using namespace std;

inline int read()
{
	char ch=getchar();bool f=0;int x=0;
	for(;!isdigit(ch);ch=getchar())if(ch=='-')f=1;
	for(;isdigit(ch);ch=getchar())x=(x<<1)+(x<<3)+(ch^48);
	if(f==1)x=-x;return x;
}
struct node
{
	int v,nex;
}e[400005],e1[400005];
int n,m,head[5005],cnt=0,x[200005],y[200005],q,qes[20005][3],num=0,id[5005],tot=0,f[1005][1005],head1[1005],ans;
bool flag[5005][5005],vis[5005];
char ch[20005];
void add(int u,int v)
{
	e[++cnt].v=v,e[cnt].nex=head[u],head[u]=cnt;
}
void add1(int u,int v)
{
	e1[++tot].v=v,e1[tot].nex=head1[u],head1[u]=tot;
}
void dfs(int x,int y)
{
	id[x]=y;
	for(int i=head[x];i;i=e[i].nex)
	{
		if(!vis[e[i].v])vis[e[i].v]=1,dfs(e[i].v,y);
	}
}
void dfs1(int x)
{
	for(int i=head1[x];i;i=e1[i].nex)
	{
		if(!vis[e1[i].v]&&f[x][e1[i].v]>0)vis[e1[i].v]=1,dfs1(e1[i].v);
	}
}
int main()
{
	n=read(),m=read();
	for(int i=1;i<=m;i++)	
		x[i]=read(),y[i]=read(),flag[x[i]][y[i]]=1;
	q=read();
	for(int i=1;i<=q;i++)
	{
		while(ch[i]!='Q'&&ch[i]!='D'&&ch[i]!='A')ch[i]=getchar();
		if(ch[i]=='Q');
		else if(ch[i]=='D')
		{
			qes[i][1]=read(),qes[i][2]=read();
			flag[qes[i][1]][qes[i][2]]=0;
			flag[qes[i][2]][qes[i][1]]=0;
		}
		else if(ch[i]=='A')qes[i][1]=read(),qes[i][2]=read();
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			if(flag[i][j]&&i!=j)add(i,j),add(j,i);
	memset(vis,0,sizeof vis);
	for(int i=1;i<=n;i++)
	{
		if(!vis[i])vis[i]=1,dfs(i,++num);
	}
	for(int i=1;i<=m;i++)
	{
		if(id[x[i]]!=id[y[i]])add1(id[x[i]],id[y[i]]),add1(id[y[i]],id[x[i]]),
		f[id[x[i]]][id[y[i]]]++,f[id[y[i]]][id[x[i]]]++;
	}
	for(int i=1;i<=q;i++)
	{
		if(ch[i]=='Q')
		{
			ans=0;
			memset(vis,0,sizeof vis);
			for(int i=1;i<=num;i++)
				if(!vis[i])vis[i]=1,dfs1(i),ans++;
			cout<<ans<<endl;
		}
		else if(ch[i]=='D')
		{
			if(id[qes[i][1]]!=id[qes[i][2]])f[id[qes[i][1]]][id[qes[i][2]]]--,f[id[qes[i][2]]][id[qes[i][1]]]--;
		}		
		else if(ch[i]=='A')
		{
			if(id[qes[i][1]]!=id[qes[i][2]])add1(id[qes[i][1]],id[qes[i][2]]),add1(id[qes[i][2]],id[qes[i][1]]),
			f[id[qes[i][1]]][id[qes[i][2]]]++,f[id[qes[i][2]]][id[qes[i][1]]]++;
		}
			
	}
	return clock();
}
```















---

## 作者：rEdWhitE_uMbrElla (赞：0)

~~看一眼就知道是动态图吖（口胡.jpg~~

以上纯属假消息。。。

其实这题是一道明显的技(xia)巧(gao)题，我们发现询问数远小于边数，这表明有一些边是一直存在的。。于是我们可以离线做，，对一直存在的边组成的图进行缩点，然后就开始暴力维护添边和删边即可。。注意用计数器纪录一下重边，而不是不停的加边即可。。

最好再判一下自环，，有人已经造出有自环的hack数据惹。。似乎还卡掉了不少人。。

```cpp
#include <bits/stdc++.h>
#define mp make_pair
using namespace std;

int lst[5005], to[100005], pre[100005], tot,in[5005][5005], iu[200005], iv[200005], qu[10005], qv[10005], idx[5005], fa[5005], cnt;
char tp[10005];
bool vis[5005], del[100005];

map<int, pair<int, int> > edge[5005];

inline void add_edge(int u, int v) {
    if (edge[u].count(v) && edge[u][v].first) {
        edge[u][v].first++;
        return;
    }
    edge[u][v] = mp(1, tot);
    to[tot] = v;
    pre[tot] = lst[u];
    lst[u] = tot++;
}

int findf(int u) {
    if (u == fa[u]) return u;
    return fa[u] = findf(fa[u]);
}

void dfs(int u) {
    vis[u] = true;
    for (int i = lst[u]; ~i; i = pre[i]) {
        if (!del[i] && !vis[to[i]])
            dfs(to[i]);
    }
}

int main() {
    memset(lst, -1, sizeof lst);
    int n, m;
    scanf("%d%d", &n, &m);
    for (int i = 0; i < m; i++) {
        scanf("%d%d", iu + i, iv + i);
        in[--iu[i]][--iv[i]] = 1;
        in[iv[i]][iu[i]] = 1;
    }
    int q;
    scanf("%d", &q);
    for (int i = 0; i < q; i++) {
        scanf(" %c", tp + i);
        if (tp[i] != 'Q') {
            scanf("%d%d", qu + i, qv + i);
            qu[i]--;
            qv[i]--;
            if (tp[i] == 'D') in[qu[i]][qv[i]] = in[qv[i]][qu[i]] = 0;
        }
    }
    for (int i = 0; i < n; i++) fa[i] = i;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            if (in[i][j]) fa[findf(i)] = findf(j);
    for (int i = 0; i < n; i++)
        if (findf(i) == i) idx[i] = cnt++;
    for (int i = 0; i < n; i++) idx[i] = idx[fa[i]];
    memset(in, false, sizeof in);
    for (int i = 0; i < m; i++) {
        int u = idx[iu[i]], v = idx[iv[i]];
        if (u != v) {
            add_edge(u, v);
            add_edge(v, u);
		}
    }
    for (int i = 0; i < q; i++)
        if (tp[i] == 'Q') {
            memset(vis, false, cnt);
            int ans = 0;
            for (int j = 0; j < cnt; j++) {
                if (!vis[j]) {
                    ans++;
                    dfs(j);
                }
            }
            printf("%d\n", ans);
        } else if (tp[i] == 'A') {
            int u = idx[qu[i]], v = idx[qv[i]];
            if (u != v) {
                add_edge(u, v);
                add_edge(v, u);
			}
        } else {
            int u = idx[qu[i]], v = idx[qv[i]];
            if (u == v) continue;
            edge[u][v].first--;
            edge[v][u].first--;
            if (!edge[u][v].first) del[edge[u][v].second] = del[edge[v][u].second] = true;
        }
}
```

~~个人感觉shoi并不算特别的毒瘤？~~

---


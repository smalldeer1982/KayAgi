# [AHOI2013] 找硬币

## 题目描述

小蛇是金融部部长。最近她决定制造一系列新的货币。假设她要制造的货币的面值为 $x_1~,~x_2~,~x_3...$ 那么 $x_1$ 必须为 $1$，$x_b$ 必须为 $x_a$ 的正整数倍（$b~>~a$）。例如 $1~,~5~,~125~,~250$ 就是一组合法的硬币序列，而 $1~,~5~,~100~,~125$ 就不是。不知从哪一天开始，可爱的蛇爱上了一种萌物——兔纸！从此，小蛇便走上了遇上兔纸娃娃就买的不归路。某天，小蛇看到了 $N$ 只可爱的兔纸，假设这 $N$ 只兔纸的价钱分别是 $a_1~,~a_2~...~a_N$。现在小蛇想知道，在哪一组合法的硬币序列下，买这N只兔纸所需要的硬币数最少。买兔纸时不能找零。

## 说明/提示

$1~\leq~N~\leq~50$

$1~\leq~a_i~\leq~10^5$

## 样例 #1

### 输入

```
2
25 102```

### 输出

```
4```

# 题解

## 作者：谋事在人 (赞：9)

## 1. 题目解释
定义任意多种货币满足任意两种货币之间都有倍数关系，用这些货币去购买n种物品，要求购买时使用的货币总数（注意是数量）最少。（必须正好凑齐）


------------

## 2.题目分析
考虑到每个货币都是比它小的货币面值的倍数，所以每几个小面值的货币都可以被一个大面值（已定义的）的货币代替，而且不会有损失，可以采用贪心的思想。

题目中有多种可能的定义货币方式，例如若20元为最大面值可以定义为{1,4,20}或{1,5,20}，20元为最大面值时的解答依赖于4元或5元的情况，且可以取min，看数据范围，n=50,v=100000，O(nv$&radic;v$)的暴力dp(常数小）可以过。


------------

## 3.dp思路
可以定义dp[i]为以i为最大面值时的最少使用货币个数。

枚举ij<=maxn的j，dp[ij]=min(dp[ij],dp[i]-minus）;（ij代表i*j）

此处的minus为所有兔子中可以把j个面值为i的货币换成面值为i*j的货币时可以减少的货币数量。


------------

## 4.贴代码
```
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

int n,maxn,ans = 1e9+7,a[100],dp[100010];

int main(){
	memset(dp,0x3f,sizeof(dp));
	dp[1]=0;
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		maxn=max(maxn,a[i]);
		dp[1]+=a[i];
	}
	ans=dp[1];//最少的货币数量
	for(int i=1;i<=maxn/2;i++){
		for(int j=2;j*i<=maxn;j++){//枚举i与j
			int minus=0;
			for(int r=1;r<=n;r++)//暴力求替换后的收益
				minus+=a[r]/(i*j);
			dp[i*j]=min(dp[i*j],dp[i]-(j-1)*minus);//dp
			ans=max(ans,dp[i*j]);//防作弊
		}
	}
	printf("%d\n",ans);
	return 0;
}
```
~~最后吐槽一句，这个题真的是黑题难度吗...~~

---

## 作者：Karl_Aurora (赞：5)

更新于 2021.8.11

P5228 [AHOI2013]找硬币  [题目传送门](https://www.luogu.com.cn/problem/P5228)

~~个人感觉这题似乎并没有达到黑题应有难度，只是单纯的暴力dp而已qwq~~

woc，蓝了，我还说好不容易水了一篇假的黑题题解了，结果……

~~（我tmd没事反馈这道题干啥……~~

------------
#### 以下为题目解析

题目中规定任意两种货币之间都有倍数关系，要求用这些货币去买珂爱的兔纸，使用的货币数量最少，且没有找零

因为货币之间都有倍数关系，所以可以得出当存在几个小面额货币可以被一个大面额货币替代时，替代肯定是最优的

因此，可以得出状态转移方程 $ dp_{i \times j} = \min(dp_{i \times j},dp_i - chge) $，即买价格为 $ i \times j $ 的物品所需的货币数量等于原先的较优解与替换后的结果的较小值，其中 $ chge $ 表示将面值为 $ i $ 的货币替换成面值为 $ i \times j $ 的货币所节省下的货币数量

因为这题的数据范围为 $ n \leq 50 ,v \leq 100000 $，所以暴力dp是可以过的

------------

下面是代码qwq

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
    int X=0,w=0;
	char ch=0;
    while(!isdigit(ch)){w|=ch=='-';ch=getchar();}
    while(isdigit(ch))X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
    return w?-X:X;
}
inline void write(int x) {
	static int stk[100], top = 0;
	if(x==0){putchar('0');return;}
	if(x<0){x=-x;putchar('-');}
 	while(x){stk[++top]=x%10;x/=10;}
	while(top)putchar(stk[top--] ^ '0');
	return;
}
//祖传快读快输qwq
int n,maxn,ans=INT_MAX,a[55],dp[100010];
int main(){
    memset(dp,0x3f,sizeof(dp));
    dp[1]=0;
    n=read();
    for(int i=1;i<=n;i++){
        a[i]=read();
        maxn=max(maxn,a[i]);
        dp[1]+=a[i];
    }
    ans=dp[1];
    for(int i=1;i<=maxn/2;i++){
        for(int j=2;j*i<=maxn;j++){
            int chge=0;
            for(int r=1;r<=n;r++)
                chge+=a[r]/(i*j);
            dp[i*j]=min(dp[i*j],dp[i]-(j-1)*chge);
            ans=min(ans,dp[i*j]);
        }
    }
    printf("%d\n",ans);
    return 0;
}
```

经实测，2.19s，1.15MB通过，求资瓷！

---

## 作者：静かな海 (赞：5)

没想到这题还挺冷门……

介绍一种 $\mathcal O(n+v\lg v)$ 的做法吧，是 @q234rty 教我的（唔姆

dp 的主过程和原 $\mathcal O(nv\lg v)$ 做法一样，设 $f(i)$ 为最大值为 $i$ 的答案，但是这个做法太愚蠢了（q酱原话），我们考虑优化一下

注意到复杂度瓶颈在求这两个式子

$$
g(i)=\sum_{1\le k\le n}\left\lfloor\frac{a_k}{i}\right\rfloor
$$

$$
\begin{aligned}
\sum_{1\le k\le n}\left[\left\lfloor\frac{a_k}{i}\right\rfloor\bmod p_j\right]&=\sum_{1\le k\le n}\left[\left\lfloor\frac{a_k}{i}\right\rfloor-p_j\cdot\left\lfloor\frac{a_k}{i\cdot p_j}\right\rfloor\right]\\&=g(i)-p_j\cdot g(i\cdot p_j)
\end{aligned}
$$

$g(i)$ 开个桶枚举倍数求一下就好了

这样 $n$ 就可以出到 $10^6$ 啦

```cpp
//　静かな海
#include <bits/stdc++.h>
using namespace std;

inline int rd() {
  int x=0,c,f=1;while(!isdigit(c=getchar()))if(c=='-')f=-1;
  for(;isdigit(c);c=getchar())x=x*10+c-'0';return x*f;
}
const int N = 1e5+3;

int n, m, a[N], v[N], p[N]; bool pv[N];
int f[N], g[N];

signed main() {
  n = rd();
  for (int i=1; i<=n; i++) v[a[i] = rd()]++, m = max(m, a[i]);
  for (int i=2; i<=m; i++) {
    if (!pv[i]) p[++p[0]] = i;
    for (int x=i<<1; x<=m; x+=i)
      pv[x] = 1;
  }
  for (int i=1; i<=m; i++) v[i] += v[i-1];

  for (int i=1; i<=m; i++)
    for (int x=i-1,e=1; x<=m; e++,x+=i)
      g[i] += e*(v[min(x+i,m)]-v[x]);
  
  for (int i=m; i; i--) {
    f[i] += g[i];
    for (int j=1; j<=p[0]&&i*p[j]<=m; j++)
      f[i] = min(f[i], f[i*p[j]]+g[i]-p[j]*g[i*p[j]]);
  }

  printf("%d\n", f[1]);
}
```


---

## 作者：RP_INT_MAX (赞：3)

## $\tt Solution$

以下令第 $i$ 只兔子的价钱为 $\text{Price}_i$。

由于每种货币都是前方货币的整数倍，很显然，如果后方的货币可以用，一定比使用前方的货币更优。考虑 dp。

设 $f(i)$ 表示最大货币面值为 $i$ 时，需要的最少硬币数。

下面思考如何转移。

根据“每种货币都是前方货币的整数倍”这一性质，不难得出 $f(i)$ 可以由 $i$ 的约数转移过来。

枚举 $i$ 及其倍数 $j$，令 $c$ 表示把 $j$ 个面值为 $i$ 的货币替换为面值 $i \times j$ 时可以减少的货币数量。可以得出转移方程：

$$
f(i \times j) = \min \{ f(i)-c \}
$$

其中，$c = (j-1) \displaystyle \sum_{k=1}^{n} \lfloor \frac{\text{Price}_k}{i \times j} \rfloor$。

如果 $i \times j > \max \{ \text{Price}_i \}$，那么 $i \times j$ 面值的货币就没有任何意义，因此注意 $i \times j \le \max \{ \text{Price}_i \}$。

初始化：$\forall 2 \le i \le \max \{ \text{Price}_i \},f(i)=+\infty$，而 $f(1)= \sum \text{Price}_i$。答案即为 $\min \{ f(i) \}$。

## $\tt Code$

```cpp
#include <bits/stdc++.h>
using namespace std;
const int oo=0x3f3f3f3f;
int n,a[60],f[100010];
int main () {
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n;
	int mx=-oo;
	memset(f,oo,sizeof f);
	f[1]=0;
	for(int i=1;i<=n;++i) {
		cin>>a[i];
		f[1]+=a[i];
		mx=max(mx,a[i]);
	}
	for(int i=1;i<=mx;++i)
		for(int j=2;i*j<=mx;++j) {
			int cnt=0;
			for(int k=1;k<=n;++k)
				cnt+=a[k]/(i*j);
			cnt*=(j-1);
			f[i*j]=min(f[i*j],f[i]-cnt);
		}
	int ans=oo;
	for(int i=1;i<=mx;++i)
		ans=min(ans,f[i]);
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：OoXiao_QioO (赞：2)

这篇题解主要介绍优化做法，对于朴素做法可以移步到别的题解。

* 做法一

不妨设 $f_m$ 表示当前最大的硬币面值为 $m$ 的最小代价，然后只需要枚举 $k$，然后从 $f_m$ 贡献到 $f_{mk}$ 即可。

由调和级数结论，复杂度为 $O(na\times \log a)$。

* 做法二

继承做法一，发现硬币每次增大的倍数是质数的时候显然更加优秀，因此枚举可以只枚举质数，复杂度 $O(na \log \log a)$。

* 做法三

考虑 dp 具体的转移过程，形如 $f_{mk}=\min \left\{ f_m + \sum_{i=1}^n (\left \lfloor \frac{a_i}{m} \right \rfloor \mod k)\right\}$。

我们知道 $a\mod b = a-b\times \left \lfloor \frac{a}{b} \right \rfloor$，所以式子可以写为 $f_{mk}=\min \left\{f_m+\sum_{i=1}^n (\left \lfloor \frac{a_i}{m} \right \rfloor-k\times \left \lfloor \frac{a_i}{mk} \right \rfloor)\right\}$。

不妨设 $s_m=\sum_{i=1}^n \left \lfloor \frac{a_i}{m} \right \rfloor$，那么 $f_{mk}=\min\left\{f_m+s_m-s_{mk}\times k\right\}$。

考虑如何预处理出 $s_m$。枚举 $m$，看看有多少个 $i$ 满足 $\left \lfloor \frac{a_i}{m} \right \rfloor = w$，显然是所有满足 $mw\le a_i < m(w+1)$ 的 $a$，这些 $a$ 的数量可以直接预处理。

这样复杂度就成为了 $O(a \log a)$，$n$ 完全可以开到 $10^6$ 甚至更大。

---

## 作者：wasa855 (赞：2)

### DP   
考虑 $f[i]$ 等于货币值是 $i$ 的情况下最少要用多少钱  
  
由于每一种货币都是前面的倍数，那么可以贪心地说：如果较大面值的货币可以用就用，这比用小面值的货币更优。
   
转移：考虑把兔子的价格中可以用大面值货币支付的那部分记录下来，然后减去，剩下的就是答案。   
然后每个 $i$ 必由较小的 $j$ 且 $j$ 是 $i$ 的倍数转移而来，那么从小到大dp即可。   

代码：   
``` cpp
#include<bits/stdc++.h>
using namespace std;
int a[55];
int f[100005];
signed main()
{
	memset(f,0x7f,sizeof(f));
	int n;
	cin>>n;
	int maxn=0;
	f[1]=0;
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		f[1]+=a[i];
		maxn=max(a[i],maxn);
	}
	int ans=f[1];
	for(int i=1;i<=maxn;i++)
	{
		for(int j=2;j*i<=maxn;j++)
		{
			int tmp=0;
			for(int k=1;k<=n;k++)
			{
				tmp+=a[k]/(i*j);
			}
			f[i*j]=min(f[i*j],f[i]-(j-1)*tmp);
		}
	}
	for(int i=1;i<=maxn;i++)
	{
		if(ans>f[i])
		{
			ans=f[i];
		}
	}
	cout<<ans<<endl;
	return 0;
}

```

---


# [SNOI2017] 一个简单的询问

## 题目描述

给你一个长度为 $N$ 的序列 $a_i$，$1\leq i\leq N$，和 $q$ 组询问，每组询问读入 $l_1,r_1,l_2,r_2$，需输出

$$
\sum\limits_{x=0}^\infty \text{get}(l_1,r_1,x)\times \text{get}(l_2,r_2,x)
$$

$ \text{get}(l,r,x)$ 表示计算区间 $[l,r]$ 中，数字 $x$ 出现了多少次。

## 说明/提示

对于 $20\%$ 的数据，$1\leq N,Q\leq 1000$；  
对于另外 $30\%$ 的数据，$1\leq a_i\leq 50$；  
对于 $100\%$ 的数据，$N,Q\leq 50000$，$1\leq a_i\leq N$，$1\leq l_1\leq r_1\leq N$，$1\leq l_2\leq r_2\leq N$。

数据范围与原题相同，但测试数据由 LibreOJ 自制，并非原数据。  

**注意：** 答案有可能超过 `int` 的最大值。

## 样例 #1

### 输入

```
5
1 1 1 1 1
2
1 2 3 4
1 1 4 4```

### 输出

```
4
1```

# 题解

## 作者：NaCly_Fish (赞：57)

题目丢给了我们一个很复杂的询问，肯定不能直接做。  
所以我们可以考虑差分一下，问题就会变得很简单了。 


题目中原式是这样的  
$$\sum\limits_{x=1}^\infty \text{get}(l_1,r_1,x)*\text{get}(l_2,r_2,x)$$  
根据差分，容易发现   
$$\text{get}(l,r,x)=\text{get}(1,r,x)-\text{get}(1,l-1,x)$$  
为了方便下面表述，我们设  
$$g(i,x)=\text{get}(1,i,x)$$
于是原式化为
$$\sum\limits_{x=1}^\infty g(r_1,x)g(r_2,x)-g(r_1,x)g(l_2-1,x)-g(l_1-1,x)g(r_2,x)+g(l_1-1,x)g(l_2-1,x)$$  
然后就将其强拆成 $4$ 个询问  
$$q_1=\sum\limits_{x=1}^\infty g(r_1,x)g(r_2,x)$$  
$$q_2=\sum\limits_{x=1}^\infty g(r_1,x)g(l_2-1,x)$$
$$ q_3=\sum\limits_{x=1}^\infty g(l_1-1,x)g(r_2,x)$$
$$q_4=\sum\limits_{x=1}^\infty g(l_1-1,x)g(l_2-1,x)$$  
然后询问的实际答案就是$ q_1-q_2-q_3+q_4$  

然后就能直接用莫队搞了，具体实现见代码。  
时间复杂度 $\text{O}(n^\frac32)$，可以无压力通过。  
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<vector>
#include<queue>
#include<cstdlib>
#include<ctime>
#define int long long
#define reg register
#define N 50003
using namespace std;

struct query{
	int l,r,id,type;
	query(int l=0,int r=0,int id=0,int type=0):l(l),r(r),id(id),type(type){}
	//这里的l,r表示的并不是区间,只是为了方便才这么写的 
	//id表示属于哪个询问,type表示其正负 
};

int a[N],be[N],ans[N];
int cntl[N],cntr[N];
query q[N<<2];
int n,m,unit,res,qc,l,r;

inline void read(int &x);
void print(int x);
inline bool cmp(query x,query y);
inline void movel(int t);
inline void mover(int t);

signed main(){
	int l1,r1,l2,r2,t = 0;
	read(n);
	unit = sqrt(n);
	for(reg int i=1;i<=n;++i){
		read(a[i]);
		be[i] = i/unit+1;
	}
	read(m);
	for(reg int i=1;i<=m;++i){
		read(l1),read(r1),read(l2),read(r2);
		q[++qc] = query(r1,r2,i,1); //强拆成4个询问 
		q[++qc] = query(r1,l2-1,i,-1);
		q[++qc] = query(l1-1,r2,i,-1);
		q[++qc] = query(l1-1,l2-1,i,1);
	}
	for(reg int i=1;i<=qc;++i){
		if(q[i].l<=q[i].r) continue;
		swap(q[i].l,q[i].r);
	}
	sort(q+1,q+1+qc,cmp);
	l = 0,r = 0;
	for(reg int i=1;i<=qc;++i){
		while(l<q[i].l) movel(1);
		while(l>q[i].l) movel(-1);
		while(r<q[i].r) mover(1);
		while(r>q[i].r) mover(-1);
		if(q[i].type==1) ans[q[i].id] += res;
		else ans[q[i].id] -= res;
	}
	for(reg int i=1;i<=m;++i){
		print(ans[i]);
		putchar('\n');
	}
	return 0;
}

inline void movel(int t){
	if(t==1){
		++cntl[a[l+1]];
		res += cntr[a[l+1]];  //计算移动端点对答案的贡献。这里可以自己思考一下 
		++l;
	}else{
		--cntl[a[l]];
		res -= cntr[a[l]];
		--l;	
	}
}

inline void mover(int t){
	if(t==1){
		++cntr[a[r+1]];
		res += cntl[a[r+1]];
		++r;
	}else{
		--cntr[a[r]];
		res -= cntl[a[r]];
		--r;
	}
}

inline bool cmp(query x,query y){
	if(be[x.l]==be[y.l]) return x.r < y.r;
	return x.l < y.l;
}

inline void read(int &x){
	x = 0;
	char c = getchar();
	while(c<'0'||c>'9') c = getchar();
	while(c>='0'&&c<='9'){
		x = (x<<3)+(x<<1)+(c^48);
		c = getchar();
	}
}

void print(int x){
	if(x>9) print(x/10);
	putchar(x%10+'0');
}
```

---

## 作者：juju527 (赞：13)

加强版：[[Ynoi2016]这是我自己的发明](https://www.luogu.com.cn/problem/P4689)

### [[Snoi2017]一个简单的询问](http://www.lydsy.com/JudgeOnline/problem.php?id=5016)

我们设$f(l_1,r_1,l_2,r_2)$为区间$[l_1,r_1]$和$[l_2,r_2]$中各取一个的权值相同情况总数

但4元我们不好处理

容斥

$f(l_1,r_1,l_2,r_2)=f(1,r_1,1,r_2)-f(1,l_2-1,1,r_1)-f(1,l_1-1,1,r_2)+f(1,l_1-1,1,l_2-1)$

这样的话每一个f就只有两元了

我们用图来形象的看一看这个容斥

![](https://s1.ax1x.com/2020/04/02/GtVQRH.png)

我们首先计算了两个紫色区间的f

那么，棕色区间([1,l2-1])和绿色区间([1,r1])的f是我们不应该计算的

同理[1,l1-1]和[1,r2]是我们不该计算的

两个均减去的话，把[1,l1-1]和[1,l2-1]的f减了两遍，加回来即可

然后对于区间1统计某数字个数的问题我们用普通莫队解决

我们发现我们需要计算的都是f(1,x,1,y)这个形式

不妨设x小于y

对于一个数字k，它对答案的贡献即[1,x]内k数量乘以[1,y]内k数量

设s1=[1,x]内k数量,s2=[1,y]内k数量

在莫队l指针向左时，某个k的s1应该减少1，所有s2不变，对答案贡献-s2

l指针向右，某个k的s1应该增加1，所有s2不变，对答案贡献s2

在莫队r指针向左时，某个k的s2应该减少1，所有s1不变，对答案贡献-s1

r指针向右，某个k的s2应该增加1，所有s1不变，对答案贡献s1

我们拿两个数组记录数量就好了

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=50005,maxm=50005;
int block;
struct Query{
	int id,x,y;
	bool operator <(Query i)const{
		return ((x-1)/block==(i.x-1)/block)?y<i.y:x<i.x;
	}
}q[4*maxm];
int a[maxn];
long long ans=0;
int cnt1[maxn],cnt2[maxn];
long long ANS[maxm];
int read(){
	int x=0,y=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return x*y;
}
void ins1(int x){
	ans+=cnt2[a[x]];
	cnt1[a[x]]++;
	return ;
}
void ins2(int x){
	ans+=cnt1[a[x]];
	cnt2[a[x]]++;
	return ;
}
void del1(int x){
	ans-=cnt2[a[x]];
	cnt1[a[x]]--;
	return ;
}
void del2(int x){
	ans-=cnt1[a[x]];
	cnt2[a[x]]--;
	return ;
}
int main(){
	int n,m,Q=0;
	n=read();
	block=sqrt(n);
	for(int i=1;i<=n;i++)a[i]=read();
	m=read();
	for(int i=1;i<=m;i++){
		int l1,r1,l2,r2;
		l1=read();r1=read();l2=read();r2=read();
		Q++;q[Q].id=i;q[Q].x=r1;q[Q].y=r2;
		if(q[Q].x>q[Q].y)swap(q[Q].x,q[Q].y);
		Q++;q[Q].id=-i;q[Q].x=l2-1;q[Q].y=r1;
		if(q[Q].x>q[Q].y)swap(q[Q].x,q[Q].y);
		Q++;q[Q].id=-i;q[Q].x=l1-1;q[Q].y=r2;
		if(q[Q].x>q[Q].y)swap(q[Q].x,q[Q].y);
		Q++;q[Q].id=i;q[Q].x=l1-1;q[Q].y=l2-1;
		if(q[Q].x>q[Q].y)swap(q[Q].x,q[Q].y);
	}
	sort(q+1,q+Q+1);
	int l=0,r=0;
	for(int i=1;i<=Q;i++){
		int id=q[i].id,x=q[i].x,y=q[i].y;
		while(l<x)ins2(++l);
		while(l>x)del2(l--);
		while(r<y)ins1(++r);
		while(r>y)del1(r--);
		ANS[abs(id)]+=(id<0?-ans:ans);
	}
	for(int i=1;i<=m;i++)printf("%lld\n",ANS[i]);
	return 0;
}

```

---

## 作者：Egg_eating_master (赞：11)

这里提供一个无脑分块做法。

看到数据范围 $5\times 10^4$，考虑分块，设块长为 $\sqrt n$。令 $sum_{i,j}$ 表示前 $j$ 个数对第 $i$ 个块产生的贡献。这个东西可以 $O(n\sqrt n)$ 预处理出来。

对于每个询问，把它拆成三个部分：

- 区间二的所有整块 对 整个区间一 产生的贡献
- 区间一的所有整块 对 区间二的散块 产生的贡献
- 区间一的散块 对 区间二的散块 产生的贡献

建议自己画个图理解一下。

前两个部分显然可以直接利用 $sum$ 来搞，对于第三个部分，暴力开桶，扫一遍就没了。

时空复杂度均为 $O(n\sqrt n)$。常数较莫队略大，但不卡常也能做到稳定跑过。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 50005, maxb = 255;
int n, m, block, t;
int a[maxn], ind[maxn];
int sum[maxb][maxn];
int st[maxb], ed[maxb], pos[maxn];
int cnt[maxn];
void discrete() {
    memcpy(ind, a, sizeof(a)); sort(ind + 1, ind + 1 + n);
    int len = unique(ind + 1, ind + 1 + n) - ind - 1;
    for (int i = 1; i <= n; i++)
        a[i] = lower_bound(ind + 1, ind + 1 + n, a[i]) - ind;
}
void getsum(int k) {
    for (int i = st[k]; i <= ed[k]; i++) cnt[a[i]]++;
    for (int i = 1; i <= n; i++) sum[k][i] = sum[k][i - 1] + cnt[a[i]];
    for (int i = st[k]; i <= ed[k]; i++) cnt[a[i]]--;
}
void init() {
    block = sqrt(n); t = ceil(n * 1. / block);
    for (int i = 1; i <= t; i++) {
        st[i] = (i - 1) * block + 1; ed[i] = min(i * block, n);
        for (int j = st[i]; j <= ed[i]; j++) pos[j] = i;
    }
    for (int i = 1; i <= t; i++) getsum(i);
}
int query(int l1, int r1, int l2, int r2) {
    int p1 = pos[l1], q1 = pos[r1], p2 = pos[l2], q2 = pos[r2], ans = 0;
    for (int i = p2 + 1; i <= q2 - 1; i++) ans += sum[i][r1] - sum[i][l1 - 1];
    for (int i = p1 + 1; i <= q1 - 1; i++)
        if (p2 != q2) ans += sum[i][ed[p2]] - sum[i][l2 - 1] + sum[i][r2] - sum[i][st[q2] - 1];
        else ans += sum[i][r2] - sum[i][l2 - 1];
    if (p2 == q2)
        for (int i = l2; i <= r2; i++) cnt[a[i]]++;
    else {
        for (int i = l2; i <= ed[p2]; i++) cnt[a[i]]++;
        for (int i = st[q2]; i <= r2; i++) cnt[a[i]]++;
    }
    if (p1 == q1)
        for (int i = l1; i <= r1; i++) ans += cnt[a[i]];
    else {
        for (int i = l1; i <= ed[p1]; i++) ans += cnt[a[i]];
        for (int i = st[q1]; i <= r1; i++) ans += cnt[a[i]];
    }
    if (p2 == q2)
        for (int i = l2; i <= r2; i++) cnt[a[i]]--;
    else {
        for (int i = l2; i <= ed[p2]; i++) cnt[a[i]]--;
        for (int i = st[q2]; i <= r2; i++) cnt[a[i]]--;
    }
    return ans;
}
int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i];
    discrete();
    init();
    cin >> m;
    for (int i = 1; i <= m; i++) {
        int l1, r1, l2, r2; cin >> l1 >> r1 >> l2 >> r2;
        cout << query(l1, r1, l2, r2) << endl;
    }
    return 0;
}
```

---

## 作者：Mihari (赞：8)

# T 「SNOI2017」一个简单的询问
## 题目
[点这里](https://loj.ac/problem/2254)
## 考场思考
$50pts$：暴搜前 $2$ 组，再拿 $3$ 组特殊数据分。

$80pts$：纯莫队，无优化。

$code-80pts$

```cpp
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
#define LL long long
template<class T>inline void qread(T& x){
    char c;bool f=false;x=0;
    while((c=getchar())<'0'||'9'<c)if(c=='-')f=true;
    for(x=(c^48);'0'<=(c=getchar())&&c<='9';x=(x<<1)+(x<<3)+(c^48));
    if(f)x=-x;
}
template<class T,class... Args>inline void qread(T& x,Args&... args){qread(x),qread(args...);}
inline int rqread(){
    char c;bool f=false;int x=0;
    while((c=getchar())<'0'||'9'<c)if(c=='-')f=true;
    for(x=(c^48);'0'<=(c=getchar())&&c<='9';x=(x<<1)+(x<<3)+(c^48));
    return f?-x:x;
}
template<class T>inline T Max(const T x,const T y){return x>y?x:y;}
template<class T>inline T Min(const T x,const T y){return x<y?x:y;}
template<class T>inline T fab(const T x){return x>0?x:-x;}

const int MAXN=5e4;

int N,M,Q,a[MAXN+5];
struct query{
    int l,r,l2,r2,id;
    query(){}
    query(const int L,const int R,const int L2,const int R2,const int I):l(L),r(R),l2(L2),r2(R2),id(I){}
    bool operator<(const query a){return l/M==a.l/M?r/M<a.r/M:l/M<a.l/M;}
}q[MAXN+5];

int l1,r1,l2,r2;
int t1[MAXN+5],t2[MAXN+5],maxx;
LL res[MAXN+5];

signed main(){
	qread(N);
    M=sqrt(N);
    for(int i=1;i<=N;++i)qread(a[i]),maxx=Max(maxx,a[i]);
    qread(Q);
    for(int i=1,l,r,l2,r2;i<=Q;++i){
        qread(l,r,l2,r2);
        q[i]=query(l,r,l2,r2,i);
    }
    sort(q+1,q+Q+1);
    for(int i=1;i<=Q;++i){
        while(r1<q[i].r)++r1,++t1[a[r1]];
        while(r1>q[i].r)--t1[a[r1]],--r1;
        while(l1<q[i].l)--t1[a[l1]],++l1;
        while(l1>q[i].l)--l1,++t1[a[l1]];

        while(r2<q[i].r2)++r2,++t2[a[r2]];
        while(r2>q[i].r2)--t2[a[r2]],--r2;
        while(l2<q[i].l2)--t2[a[l2]],++l2;
        while(l2>q[i].l2)--l2,++t2[a[l2]];

        LL ans=0;
        for(int j=1;j<=maxx;++j)ans+=1ll*t1[j]*t2[j];
        res[q[i].id]=ans;
    }
    for(int i=1;i<=Q;++i)printf("%lld\n",res[i]);
}
```


## 题解
首先，我们二次差分化简这个公式（我把 $x$ 省略了）
$$\begin{aligned}
\sum _{x=0}^{\infty}get(l_1,r_1)\times get(l_2,r_2)
=&\sum _{x=0}^{\infty}(get(1,r_1)-get(1,l_1-1))\times (get(1,r_2)-get(1,l_2-1)) \\
=&\sum _{x=0}^{\infty}get(1,r_1)\times get(1,r_2)-get(1,r_1)\times get(1,l_2-1)-get(1,l_1-1)\times get(1,r_2)+get(1,l_1-1)\times get(1,l_2-1)
\end{aligned}
$$
然后，我们发现，一个询问由本来的两个函数变成四个了。

但是这样有个好处，所有的函数都成为 $get(1,t)$ 的形式，而且，一个子问题被我们转化成了四个部分，分别是：
$$\begin{aligned}
&Q_1=\sum _{x=0}^{\infty}get(1,r_1)\times get(1,r_2) \\
&Q_2=\sum _{x=0}^{\infty}get(1,r_1)\times get(1,l_2-1) \\
&Q_3=\sum _{x=0}^{\infty}get(1,l_1-1)\times get(1,r_2) \\
&Q_4=\sum _{x=0}^{\infty}get(1,l_1-1)\times get(1,l_2-1)
\end{aligned}
$$
最终，这个子问题的答案就是 $$ans=Q_1-Q_2-Q_3+Q_4$$

那么又有一个问题，我们怎么求 $Q_i$ ？

知道的都会说：[莫队算法](https://www.cnblogs.com/MisakaAzusa/p/8684319.html)

只不过这个莫队算法仅仅是一个思路，或者说借鉴了莫队的思想。

考虑对一个区间 $[l,r]$ 进行维护，搞清楚维护对象：$Q_i$ 的值。

那这个 $Q_i$ 的值怎么维护呢？这好像和莫队没啥关系吧？

是的，这是变形的地方。

我们先看，假如这是一道莫队的题，那么我们加减点就是 `++(--)cnt[point]` 即可。

但是这道题我们如果想要 `++(--)cnt[point]` 的话，有什么影响呢？

假如说我们维护 $r$ ，那么当 `++(--)tr[point]` 的时候，我们维护的 $ret=Q_i$ 的值的变化，就是**另一个括号一整个的值**了。

所以我们的 $ret$ 应该对应的 `+(-)tl[point]`。

如果还不知道怎么办，看看代码总有好处...

```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
#define rep(q,a,b) for(int q=a,q##_end_=b;q<=q##_end_;++q)
#define dep(q,a,b) for(int q=a,q##_end_=b;q>=q##_end_;--q)
template<class T>inline void qread(T& x){
    char c;bool f=false;x=0;
    while((c=getchar())<'0'||'9'<c)if(c=='-')f=true;
    for(x=(c^48);'0'<=(c=getchar())&&c<='9';x=(x<<1)+(x<<3)+(c^48));
    if(f)x=-x;
}
template<class T,class... Args>inline void qread(T& x,Args&... args){qread(x),qread(args...);}
inline int rqread(){
    char c;bool f=false;int x=0;
    while((c=getchar())<'0'||'9'<c)if(c=='-')f=true;
    for(x=(c^48);'0'<=(c=getchar())&&c<='9';x=(x<<1)+(x<<3)+(c^48));
    return f?-x:x;
}
template<class T>inline T Max(const T x,const T y){return x>y?x:y;}
template<class T>inline T Min(const T x,const T y){return x<y?x:y;}
template<class T>inline T fab(const T x){return x>0?x:-x;}

const int MAXN=5e4;

int N,a[MAXN+5],M,Q,tl[MAXN+5],tr[MAXN+5],ans[MAXN+5],l,r,ret;

struct query{
	int l,r,type,id;
	query(){}
	query(const int L,const int R,const int T,const int I):l(L),r(R),type(T),id(I){}
	bool operator<(const query a){return l/M==a.l/M?r/M<a.r/M:l/M<a.l/M;}
}q[(MAXN<<2)+5];

signed main(){
	M=sqrt(N=rqread());
	rep(i,1,N)qread(a[i]);
	qread(Q);
	for(int i=1,l1,r1,l2,r2;i<=Q;++i){
		qread(l1,r1,l2,r2);//拆询问
		q[i-1<<2]=query(r1,r2,1,i);
		q[i-1<<2|1]=query(l2-1,r1,-1,i);
		q[i-1<<2|2]=query(l1-1,r2,-1,i);
		q[i-1<<2|3]=query(l1-1,l2-1,1,i);
	}
	sort(q,q+(Q<<2));
	for(int i=0;i<(Q<<2);++i){
		if(q[i].l<1||q[i].r<1)continue;
	/*
		我们把一个问题拆成了四个子问题
		考虑其中一个子问题 get(1,l)*get(1,r)
		设 tl 为 l 维护的桶，tr 同理
		当右边的 get 减去 1 后，
		原式=get(1,l)*(get(1,r)-1)=get(1,l)*get(1,r)-get(1,l)
		可以看出，当 tr 减去一个一之后，另一个括号被整体减去一次
		所以我们在维护当前桶 tr 和 ret 时，桶 tr - 1 ，但是 ret 要减去一个 tl 整体
	*/
		while(l<q[i].l)ret+=tr[a[++l]],++tl[a[l]];
		while(l>q[i].l)ret-=tr[a[l]],--tl[a[l--]];
		while(r<q[i].r)ret+=tl[a[++r]],++tr[a[r]];
		while(r>q[i].r)ret-=tl[a[r]],--tr[a[r--]];
		ans[q[i].id]+=ret*q[i].type;
	}
	for(int i=1;i<=Q;++i)printf("%d\n",ans[i]);
    return 0;
}
```

---

## 作者：SSerxhs (赞：6)

几乎和thuwc2019的d1t1一样，~~然而并没有做出来~~

传统莫队是处理多组区间询问的利器，然而莫队的核心是对于平面二维数点哈密顿路（距离按曼哈顿距离）长度的一种较优解（$O(n\sqrt n)$），并不要求所有点都满足$x\leq y$。也就是说，莫队是用来处理一类双端点询问，而不仅仅是区间。

借助这个思想，我们可以考虑差分，把一个询问$(l_1,r_1,l_2,r_2)$拆成四个双端点询问($(r_1,r_2)+(l_1-1,l_2-1)-(l_1-1,r_2)-(r_1,l_2-1)$)，其中每个询问是对其前缀和的（相当于所有新询问的l都为1），这样就可以把一个四端点询问拆成四个双端点询问，也就可以使用莫队来解决了。

```cpp
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N=5e4+2,M=2e5+2;
ll ans[N],cur;
int bel[N],z[M],y[M],wz[M],a[N],ap1[N],ap2[N];
int n,m,q,i,j,l,r,c,x,ksiz;
inline void read(int &x)
{
	c=getchar();
	while ((c<48)||(c>57)) c=getchar();
	x=c^48;c=getchar();
	while ((c>=48)&&(c<=57))
	{
		x=x*10+(c^48);
		c=getchar();
	}
}
void qs(int l,int r)
{
	int i=l,j=r,m=bel[z[l+r>>1]],mm=y[l+r>>1];
	while (i<=j)
	{
		while ((bel[z[i]]<m)||(bel[z[i]]==m)&&((m&1)&&(y[i]<mm)||(1^m&1)&&(y[i]>mm))) ++i;
		while ((bel[z[j]]>m)||(bel[z[j]]==m)&&((m&1)&&(y[j]>mm)||(1^m&1)&&(y[j]<mm))) --j;
		if (i<=j)
		{
			swap(z[i],z[j]);
			swap(y[i],y[j]);
			swap(wz[i++],wz[j--]);
		}
	}
	if (i<r) qs(i,r);
	if (l<j) qs(l,j);
}
int main()
{
	read(n);ksiz=sqrt(n<<2);
	if (ksiz>n) ksiz=n;
	for (i=1;i<=n;i++)
	{
		read(a[i]);bel[i]=(i-1)/ksiz+1;
	}
	read(q);
	for (i=1;i<=q;i++)
	{
		read(j);read(l);read(r);read(x);
		z[++m]=l;y[m]=x;wz[m]=i;
		z[++m]=j-1;y[m]=r-1;wz[m]=i;
		z[++m]=l;y[m]=r-1;wz[m]=-i;
		z[++m]=j-1;y[m]=x;wz[m]=-i;
	}
	qs(1,m);l=0;r=0;
	for (i=1;i<=m;i++)
	{
		while (l<z[i])
		{
			++ap1[a[++l]];
			cur+=ap2[a[l]];
		}
		while (r<y[i])
		{
			++ap2[a[++r]];
			cur+=ap1[a[r]];
		}
		while (l>z[i])
		{
			--ap1[a[l]];
			cur-=ap2[a[l--]];
		}
		while (r>y[i])
		{
			--ap2[a[r]];
			cur-=ap1[a[r--]];
		}
		if (wz[i]>0) ans[wz[i]]+=cur; else ans[-wz[i]]-=cur;
	}
	for (i=1;i<=q;i++) printf("%d\n",ans[i]);
}
```


---

## 作者：cirnovsky (赞：4)

## 题意简述

求式子

## 题解

纯算式子nt行为，由于是出现次数，满足区间加减性，所以我们可以这样表达 $\mathrm{get}(l,r,x)$（省略 $x$）:

$$
\mathrm{get}(l,r)=\mathrm{get}(1,r)-\mathrm{get}(1,l-1)
$$

那么我们代进原式，化一波式子：

$$
\sum_{i=1}^{\infty}\mathrm{get}(l_{1},r_{1},x)\times\mathrm{get}(l_{2},r_{2},x)
$$
$$
\sum_{i=1}^{\infty}(\mathrm{get}(1,r_{1})-\mathrm{get}(1,l_{1}-1))\times(\mathrm{get}(1,r_{2})-\mathrm{get}(1,l_{2}-1))
$$

$$
\sum_{i=1}^{\infty}\mathrm{get}(r_{1})\times\mathrm{get}(r_{2})-\mathrm{get}(r_{1})\times\mathrm{get}(l_{2}-1)-\mathrm{get}(l_{1}-1)\times\mathrm{get}(r_{2})+\mathrm{get}(l_{1}-1))\times\mathrm{get}(l_{2}-1)
$$

$$
\mathrm{let}\ F(x,y)=\sum_{d}\mathrm{get}(1,l,d)\times\mathrm{get}(1,r,d)
$$

则答案为:

$$
F(r_{1},r_{2})-F(r_{1},l_{2}-1)-F(l_{1}-1,r_{2})+F(l_{1}-1,l_{2}-1)
$$

考虑怎么更新，比如从 $l$ 更新到 $l+1$，则：

$$
\mathrm{get(1,l)}\times\mathrm{get}(1,r)
$$

$$
\mathrm{get(1,l+1)}\times\mathrm{get}(1,r)
$$

$$
\mathrm{get(1,l)}\times\mathrm{get}(1,r)+\mathrm{cont}(a_{l})
$$

其中 $\mathrm{cont}(a_{l})$ 表示 $a_{l}$ 的出现次数。

则我们就知道怎么更新了，由于我们维护和的是前缀信息，所以姿势和普通莫队有点不一样。

维护两个数组 `cntl[x]` 和 `cntr[y]` 表示答案式子

$$
F(r_{1},r_{2})-F(r_{1},l_{2}-1)-F(l_{1}-1,r_{2})+F(l_{1}-1,l_{2}-1)
$$

中 $F(x,y)$ 的值。

式子和表达可能有些玄学，自己意会一下吧。

```cpp
#include <cstdio>
#include <algorithm>

using namespace std;

const int Maxn = 50000 + 5;
int n, m, q, each, cube, isa[Maxn], bel[Maxn], cntl[Maxn], cntr[Maxn];
long long now, ans[Maxn];
struct Query_Node
{
	int l, r, id, typ;
	Query_Node(int tl = 0, int tr = 0, int tid = 0, int tpyt = 0)
	{
		l = tl;
		r = tr;
		id = tid;
		typ = tpyt;
	}
} Q[Maxn << 2];

bool cmp(Query_Node rhs, Query_Node shr)
{
	if (bel[rhs.l] == bel[shr.l])	return rhs.r < shr.r;
	else 	return rhs.l < shr.l;
}

void Contribute()
{
	int l = 0, r = 0;
	for (int i = 1; i <= m; ++i)
	{
		while (l < Q[i].l)
		{
			++cntl[isa[++l]];
			now += cntr[isa[l]];
		}
		while (l > Q[i].l)
		{
			--cntl[isa[l]];
			now -= cntr[isa[l--]];
		}
		while (r < Q[i].r)
		{
			++cntr[isa[++r]];
			now += cntl[isa[r]];
		}
		while (r > Q[i].r)
		{
			--cntr[isa[r]];
			now -= cntl[isa[r--]];
		}
		ans[Q[i].id] += Q[i].typ * now;
	}
}

signed main()
{
	scanf("%d", &n);
	each = 230;
	for (int i = 1; i <= n; ++i)
	{
		scanf("%d", &isa[i]);
		bel[i] = (i - 1) / each + 1;
	}
	scanf("%d", &q);
	for (int i = 1; i <= q; ++i)
	{
		int l1, r1, l2, r2;
		scanf("%d %d %d %d", &l1, &r1, &l2, &r2);
		Q[++m] = Query_Node(r1, r2, i, 1);
		Q[++m] = Query_Node(r1, l2 - 1, i, -1);
		Q[++m] = Query_Node(l1 - 1, r2, i, -1);
		Q[++m] = Query_Node(l1 - 1, l2 - 1, i, 1);
	}
	for (int i = 1; i <= m; ++i)
	{
		if (Q[i].l < Q[i].r)	swap(Q[i].l, Q[i].r);
	}
	sort(Q + 1, Q + 1 + m, cmp);
	Contribute();
	for (int i = 1; i <= q; ++i)	printf("%lld\n", ans[i]);
	return 0;
}
```

---

## 作者：FjswYuzu (赞：2)

基础莫队。

题意：多组询问，给定不变的序列 $a$，每次给出 $l_1,r_1,l_2,r_2$，定义 $\operatorname{get}(l,r,p)$ 为区间 $[l,r]$ 中，有多少个 $a_i=p$。求：

$$\sum_{x=0}^∞ \operatorname{get}(l_1,r_1,x)\times \operatorname{get}(l_2,r_2,x)$$

显然这个询问是十分复杂的。考虑容斥，将 $l_1,r_1,l_2,r_2$ 抽象为一个点对 $((l_1,r_1),(l_2,r_2))$。设 $\operatorname{g}(u，x)=\operatorname{get}(1,u,x)$，答案即为：

$$
\sum_{x=0}^∞ \operatorname{g}(r_1,x)\times \operatorname{g}(r_2,x)-\operatorname{g}(r_1,x)\times \operatorname{g}(l_2-1,x)-\operatorname{g}(r_2,x)\times\operatorname{g}(l_1-1,x)+\operatorname{g}(l_1-1,x)\times  \operatorname{g}(l_2-1,x)
$$

使用莫队，将每组询问拆成四组计算即可。

另外，因为 $a$ 中的元素最大为 $5\times 10^4$，原式的 $∞$ 即为 $5 \times 10^4$。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
LL cntl[50005],p,pos[50005],a[50005],n,m,gr,ans[50005],cntr[50005];
struct queries{
	LL l,r,id,gx;
	queries(){l=r=id=gx=0;}
	queries(LL L,LL R,LL ID,LL GX){l=L,r=R,id=ID,gx=GX;if(l>r)	l^=r^=l^=r;}
	bool operator < (queries x) {
		if(pos[l]==pos[x.l])	return r<x.r;
		return l<x.l;
	}
}que[400005];
void add1(LL s)
{
	gr+=cntr[a[s]];
	++cntl[a[s]];
}
void add2(LL s)
{
	gr+=cntl[a[s]];
	++cntr[a[s]];
}
void sub1(LL s)
{
	gr-=cntr[a[s]];
	--cntl[a[s]];
}
void sub2(LL s)
{
	gr-=cntl[a[s]];
	--cntr[a[s]];
}
int main(){
	scanf("%lld",&n);
	p=sqrt(n);
	for(LL i=1;i<=n;++i)	scanf("%lld",&a[i]),pos[i]=(i-1)/p+1;
	scanf("%lld",&m);
	for(LL i=1;i<=m;++i)
	{
		LL l1,l2,r1,r2;
		scanf("%lld %lld %lld %lld",&l1,&r1,&l2,&r2);
		que[i*4-3]=queries(r1,r2,i,1);
		que[i*4-2]=queries(r1,l2-1,i,-1);
		que[i*4-1]=queries(l1-1,r2,i,-1);
		que[i*4]=queries(l1-1,l2-1,i,1);
	}
	m*=4;
	sort(que+1,que+1+m);
	for(LL i=1,l=1,r=1;i<=m;++i)
	{
		while(l>que[i].l)	sub2(l--);
		while(r<que[i].r)	add1(++r);
		while(l<que[i].l)	add2(++l);
		while(r>que[i].r)	sub1(r--);
		ans[que[i].id]+=que[i].gx*gr;
	}
	for(LL i=1;i<=m/4;++i)	printf("%lld\n",ans[i]);
	return 0;
}
```

---

## 作者：Thaumaturge (赞：2)

蒟蒻也可以做的吧？

看到不带修改的5e4就容易想到根号算法。莫队？不会搞。那可不可以用分块实现呢？

首先观察题面，要求的是这个东西：

$\sum\limits_{i=0}^{∞}sum(l_1,r_1,i) * sum(l_2,r_2,i)$

即如果$[l_1,r_1]$中有$x_1$个$i$,$[l_2,r_2]$中有$x_2$个$i$，就会对答案产生$x_1 * x_2$的贡献

那么把这个式子拆一下就能变成：（~~今天模拟赛出原题诶~~）$\sum\limits_{i=l_1}^{r_1}\sum\limits_{j=l_2}^{r_2}[a[i]=a[j]]$

转化后怎么分块呢？

首先要离散化一下。。。

我们设$Q[i][j]$表示第$i$个数中与前$j$个块中的数相等的组数。$K[i][j]$表示第$i$个块中与前$j$个块中相等的数的组数

怎么求这两个数组呢？

我们先把$a$数组离散化一下

设$pre[i][j]$表示前i个块中含有的$j$的个数

那么就可以通过递推pre数组直接求了。

对于一个询问$:l_1$,$r_1$,$l_2$,$r_2$，那么先把第一个的块分出来，再分第二个的块。设分出来的块集合分别为$U_1$（左右端点为$L_1$与$R_1$），$U_2$（左右端点为$L_2$与$R_2$），剩下的零散点的集合为$A_1$,$A_2$

答案就为$Q[x][R_1]_ {x\in U_2}-Q[x][L_1-1]_ {x\in U_2}+Q[x][R_2]_ {x\in U_1}-Q[x][L_2-1]_ {x\in U_1}+{\sum\limits_{i=L_1}^{R_1}}K[i][R_2]-K[i][L_2-1]+[x=y] _ {x\in A_1,y\in A_2}$

前面的都已经预处理好了，而且都控制在$O(sqrt(n))$，最后的$[x=y]$项呢？

容易发现$|A_1|,|A_2|<=sqrt(n)$。那么可以对于其中一个，把元素都放入桶中，另一个依次来统计，插入$O(sqrt(n))$，查询$O(sqrt(n))$，删除可以打标记，$O(sqrt(n))$

然后就做完啦！

细节挺多的，详见代码吧～

```cpp
#include <bits/stdc++.h>

#define N 50100

#define Nk 210

#define ll long long

#pragma GCC optimize(2)

using namespace std;

int l[N],r[N];

//零散的数就直接搜，这样满足一定是O(sqrt(n))的

int Q[N][Nk];//每个数的对应

int K[Nk][Nk];//每个块的对应

int pre[Nk][N];//pre数组，每个块前缀和的所含数

int cnt;

int dy[N],tot;

int x1,x2,x3,x4;

int n,m;

int v[N];

int val[N];


struct data{
	int x,y,z;
}a[N];

inline int read(){
	int x=0;char c=getchar();bool y=1;
	for(;c<'0' || c>'9';c=getchar()) if(c=='-') y=0;
	for(;c>='0' && c<='9';c=getchar()) x=(x<<1)+(x<<3)+c-48;
	if(y) return x;
	return -x;
}

bool cmp(data x,data y){
	return x.x<y.x;
}

bool dmp(data x,data y){
	return x.y<y.y;
}

int main(){
	n=read();
	for(int i=1;i<=n;i++)
	a[i].x=read(),a[i].y=i;
	sort(a+1,a+n+1,cmp);

	m=read();

	for(int i=1;i<=n;i++)
	{
		if(a[i].x!=a[i-1].x)
		tot++;
		a[i].z=tot;
	}

	sort(a+1,a+n+1,dmp);//离散化
	
	for(int i=1;i<=n;i+=300)//分出块
	{
		cnt++;
		l[cnt]=r[cnt-1]+1,r[cnt]=min(n,l[cnt]+299);
	}

	for(int i=1;i<=cnt;i++)//求出pre数组
	{
		for(int j=1;j<=tot;j++)
		{
			pre[i][j]=pre[i-1][j];
		}
		for(int j=l[i];j<=r[i];j++)
		pre[i][a[j].z]++;
	}

	for(int i=1;i<=cnt;i++)
	{
		for(int j=1;j<=cnt;j++)
		{
			for(int k=l[i];k<=r[i];k++)//依次递推Q，K数组
			{
				Q[k][j]=pre[j][a[k].z];
				K[i][j]+=Q[k][j];
			}
		}
	}
	
	while(m--){//开始询问了
		x1=read(),x2=read(),x3=read(),x4=read();
		int L1=1,R1=cnt,L2=1,R2=cnt;
		while(x1>l[L1]) L1++;
		while(x3>l[L2]) L2++;
		while(x2<r[R1]) R1--;
		while(x4<r[R2]) R2--;
		
		ll ans=0;

		if(L2<=R2)
		{

			if(L1<=R1)
			{
				for(int i=x1;i<l[L1];i++)
				ans+=Q[i][R2]-Q[i][L2-1];
				
				for(int i=r[R1]+1;i<=x2;i++)
				ans+=Q[i][R2]-Q[i][L2-1];
			}//统计Q的贡献，注意分情况讨论
			else
			for(int i=x1;i<=x2;i++)
			ans+=Q[i][R2]-Q[i][L2-1];
			
			for(int i=L1;i<=R1;i++)//统计K的贡献
			ans+=K[i][R2]-K[i][L2-1];

			for(int i=x3;i<l[L2];i++)
			{
				if(!val[a[i].z]) v[++v[0]]=a[i].z;
				val[a[i].z]++;
			}
			for(int i=r[R2]+1;i<=x4;i++)
			{
				if(!val[a[i].z]) v[++v[0]]=a[i].z;
				val[a[i].z]++;
			}
		}
		else
		for(int i=x3;i<=x4;i++)
		{
			if(!val[a[i].z]) v[++v[0]]=a[i].z;
			val[a[i].z]++;
		}

		if(L1<=R1)
		{
			for(int i=x1;i<l[L1];i++)//统计散块贡献
			ans+=val[a[i].z];
			
			for(int i=r[R1]+1;i<=x2;i++)
			ans+=val[a[i].z];
			
			if(L2<=R2){//Q的是分开的，每个要再统计一次
				for(int i=x3;i<l[L2];i++)
				ans+=Q[i][R1]-Q[i][L1-1];
				for(int i=r[R2]+1;i<=x4;i++)
				ans+=Q[i][R1]-Q[i][L1-1];
			}
			else
			for(int i=x3;i<=x4;i++)
			ans+=Q[i][R1]-Q[i][L1-1];
		}
		else
		for(int i=x1;i<=x2;i++)
		ans+=val[a[i].z];
		
		for(int i=1;i<=v[0];i++)
		{
			val[v[i]]=0;
			v[i]=0;
		}
		v[0]=0;

		printf("%lld\n",ans);
	}

	return 0;
}
```
哦，忘记说了，要开$O2$才跑得过去。。。（可能是常数巨大吧）

---

## 作者：mol_low (赞：2)

[题目传送门](https://www.luogu.org/problemnew/show/P5268)
# 分析
对于只查询不修改，而且查询有关元素出现次数的要求，我们显然要用莫队做。但是我们没法一次处理四个端点，也没法将乘法分开(改成纯加减运算很麻烦且时间很高)。我们考虑将题目丢给我们的式子改写一下：

$$\sum^{\infty}_{x=0}get(l_1,r_1,x)*get(l_2,r_2,x)$$
$=$
$$\sum^{\infty}_{x=1}\{[get(1,r_1,x)-get(1,l_1-1,x)]*[get(1,r_2,x)-get(1,l_2-1,x)]\}$$
但是这个式子太长了，我们设
$$f(a,x)=get(1,a,x)$$
那么原式转化为：
$$\sum^{\infty}_{x=1}f(r_1,x)f(r_2,x)-f(r1,x)f(l_2-1,x)-f(l_1-1,x)f(r_2,x)+f(l_1-1,x)f(l_2-1,x)$$
看到这里我们还是得到一些本质上是乘法的式子(~~难道蒟蒻真的做不出来了吗？~~)，但是细看我们会发现，上面的所有乘法式都有一个共同点：乘号两边的式子有重叠部分!我们假设现在左指针向左移了一位(从$l$到$l-1$)，则新答案为$ans'=f(l-1,a_l)f(r,a_l)$ ，对答案的影响为:
$$ans-ans'=f(l,a_l)f(r,a_l)-f(l-1,a_l)f(r,a_l)=f(r,a_l)$$
对于左指针右移以及右指针可用同样方法得出答案的转移，所以我们成功将上面的式子转换成了加法式。我们只需将$cnt$数组开成两维，分别储存$f(l,x)$与$f(r,x)$即可(这也是本蒟蒻无法理解鱼大佬~~玄学更新答案~~之处，望各位大佬指教，谢谢)。

$Code:$
```cpp
#include <cstdio>
#include <algorithm>
#include <cmath>
using namespace std;
#define N 50000
#define LL long long

int n , m , M , num;
int a[N + 2];
int cnt[2][N + 2];
LL ans , Ans[N + 2];
struct Node{
	int left , right , id;
	bool type;
	Node(){}
	Node(int A , int B , int C , bool D) {
		left = A;
		right = B;
		id = C;
		type = D;
	}
	bool operator < (const Node &x) const {
		return (left / num) == (x.left / num) ? right < x.right : left < x.left;
	}
}ask[4 * N + 2];

void in(int &x) {
	x = 0;
	char c = getchar();
	bool f = 1;
	while(c < '0' or c > '9') {
		if(c == '-') f = 0;
		c = getchar();
	}
	while(c >= '0' and c <= '9') {
		x = (x << 1) + (x << 3) + c - '0';
		c = getchar();
	}
	if(!f) x = (~x) + 1;
} 

void out(int x) {
	if(x < 0) {
		x = (~x) + 1;
		putchar('-');
	}
	if(x >= 10) out(x / 10);
	putchar(x % 10 + '0');
}

void add(int direction , int x) {
	ans += cnt[direction][a[x]];
	++ cnt[!direction][a[x]];
}

void del(int direction , int x) {
	ans -= cnt[direction][a[x]];
	-- cnt[!direction][a[x]];
}

int main() {
	in(n);
	for(int i = 1; i <= n; i ++) in(a[i]);
	in(m);
	num = n / sqrt(m); 
	int l1 , r1 , l2 , r2;
	for(int i = 1; i <= m; i ++) {
		in(l1) , in(r1) , in(l2) , in(r2);
		ask[++ M] = Node(r1 , r2 , i , 1);
		ask[++ M] = Node(r1 , l2 - 1 , i , 0);
		ask[++ M] = Node(l1 - 1 , r2  , i , 0);
		ask[++ M] = Node(l1 - 1 , l2 - 1 , i , 1);
	}
	for(int i = 1; i <= M; i ++) if(ask[i].left > ask[i].right) swap(ask[i].left , ask[i].right);
	sort(ask + 1 , ask + M + 1);
	int l = 0 , r = 0;
	for(int i = 1; i <= M; i ++) {
		while(l < ask[i].left) add(1 , ++ l);
		while(l > ask[i].left) del(1 , l --);
		while(r < ask[i].right) add(0 , ++ r);
		while(r > ask[i].right) del(0 , r --);
		if(ask[i].type) Ans[ask[i].id] += ans;
		else Ans[ask[i].id] -= ans;
	}
	for(int i = 1; i <= m; i ++) out(Ans[i]) , putchar('\n');
	return 0;
}
```

---

## 作者：GoPoux4 (赞：0)

打完加强版 [P4689 [Ynoi2016]这是我自己的发明](https://www.luogu.com.cn/problem/P4689) 来把这道题切了（

----

### 题解

令

$$
{\rm{F}}(l_1,r_1,l_2,r_2)=\sum_{x=1}^{\infty} {\rm{get}}(l_1,r_1,x) \times {\rm{get}}(l_2,r_2,x)
$$

对于原式可以做一个差分：

$$
{\rm{get}}(l_1,r_1,x)={\rm{get}}(1,r_1,x)-{\rm{get}}(1,l_1-1,x)
$$

代入原式中并化简得到：

$$
{\rm{F}}(l_1,r_1,l_2,r_2)={\rm{F}}(1,r_1,1,r_2)-{\rm{F}}(1,r_1,1,l_2-1)-{\rm{F}}(1,l_1-1,1,r_2)+{\rm{F}}(1,l_1-1,1,l_2-1)
$$

令 ${\rm{f}}(l,r)={\rm{F}}(1,l,1,r)$，则将给出的每个询问拆成四个形如 ${\rm{f}}(l,r)$ 的询问即可。

注意：由于 ${\rm{f}}(l,r)$ 的两个下标并不代表区间，所以莫队中 $\text{add,del}$ 操作与区间查询略有不同。

---

Code：

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#define maxn 50005
#define R register
#define INF 0x3f3f3f3f
#define lxl long long
#define BN 400
using namespace std;

inline lxl read()
{
	lxl x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') {x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
	return x*f;
}

struct ques
{
	int l,r,id;
	bool operator < (const ques &x) const
	{
		if(l/BN!=x.l/BN) return l<x.l;
		if((l/BN)&1) return r<x.r;
		return r>x.r;
	}
}query[maxn<<2];

int qcnt;
int N,Q,a[maxn];

inline void Get_Query(int l1,int r1,int l2,int r2,int id)
{
	query[++qcnt]=(ques){r1,r2,id};
	query[++qcnt]=(ques){r1,l2-1,-id};
	query[++qcnt]=(ques){l1-1,r2,-id};
	query[++qcnt]=(ques){l1-1,l2-1,id};
}

lxl cnt1[maxn],cnt2[maxn],ans[maxn],sum;

inline void add1(int i)
{
	++cnt1[i];
	sum+=cnt2[i];
}

inline void del1(int i)
{
	--cnt1[i];
	sum-=cnt2[i];
}

inline void add2(int i)
{
	++cnt2[i];
	sum+=cnt1[i];
}

inline void del2(int i)
{
	--cnt2[i];
	sum-=cnt1[i];
}

int main()
{
	//freopen("P5268.in","r",stdin);
	N=read();
	for(R int i=1;i<=N;++i)
		a[i]=read();
	Q=read();
	for(R int i=1;i<=Q;++i)
	{
		int l1=read(),r1=read(),l2=read(),r2=read();
		Get_Query(l1,r1,l2,r2,i);
	}
	for(R int i=1;i<=qcnt;++i)
		if(query[i].l>query[i].r)
			swap(query[i].l,query[i].r);
	sort(query+1,query+qcnt+1);
	for(R int i=1,l=1,r=1;i<=qcnt;++i)
	{
		ques &q=query[i];
		while(l<q.l) add1(a[++l]);
		while(l>q.l) del1(a[l--]);
		while(r>q.r) del2(a[r--]);
		while(r<q.r) add2(a[++r]);
		ans[abs(q.id)]+=sum*1ll*(q.id/abs(q.id));
	}
	for(R int i=1;i<=Q;++i)
		printf("%lld\n",ans[i]);
	return 0;
}
```


---

## 作者：Jμdge (赞：0)

氧气优化快排 Orz 


# noteskey

总之这题目光看式子非常不可做，但是看起来就很套路（所以怎么黑的）


我们一眼看去这个区间信息就是满足可加可减性的，所以差分一下，询问分成 4 份，然后莫队处理就好了

也就是说，原本是 $(r1-l1) * (r2-l2)$

现在变成了 $(r1-0) * (r2-0)-(r1-0)* (l2-1 -0)-(r2-0)* (l1-1 -0) + (l1-1-0)* (l2-1-0)$


但这个莫队有点清奇就对了，因为答案统计的是 1~l 和 1~r 两个区间的信息乘积...



# code



```cpp
//by Judge
#include<bits/stdc++.h>
#define Rg register
#define fp(i,a,b) for(Rg int i=(a),I=(b)+1;i<I;++i)
#define ll long long
using namespace std;
const int M=5e4+3;
typedef ll arr[M];
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline int read(){ ll x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} char sr[1<<21],z[20];int CCF=-1,Z;
inline void Ot(){fwrite(sr,1,CCF+1,stdout),CCF=-1;}
inline void print(ll x,char chr='\n'){
    if(CCF>1<<20)Ot();if(x<0)sr[++CCF]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++CCF]=z[Z],--Z);sr[++CCF]=chr;
} ll n,m,bl,cnt,L,R,res; arr a,pos,ans,cntl,cntr;
struct que{ int l,r,id,tp; }q[M<<2];
inline bool cmp(que a,que b){return pos[a.l]^pos[b.l]?a.l<b.l:pos[a.l]&1?a.r<b.r:a.r>b.r;}
int main(){ int l1,r1,l2,r2; n=read(),bl=sqrt(n);
	fp(i,1,n) a[i]=read(),pos[i]=(i-1)/bl+1; m=read();
	fp(i,1,m){ l1=read(),r1=read(),l2=read(),r2=read();
		q[++cnt]={r1,r2,i,1},q[++cnt]={l1-1,l2-1,i,1};
		q[++cnt]={l1-1,r2,i,-1},q[++cnt]={r1,l2-1,i,-1};
	}
	fp(i,1,cnt) if(q[i].l>q[i].r) swap(q[i].l,q[i].r);
	sort(q+1,q+1+cnt,cmp); fp(i,1,cnt){
		while(L<q[i].l) ++L,++cntl[a[L]],res+=cntr[a[L]];
		while(R<q[i].r) ++R,++cntr[a[R]],res+=cntl[a[R]];
		while(L>q[i].l) res-=cntr[a[L]],--cntl[a[L]],--L;
		while(R>q[i].r) res-=cntl[a[R]],--cntr[a[R]],--R;
		if(q[i].tp>0) ans[q[i].id]+=res; else ans[q[i].id]-=res;
	} fp(i,1,m) print(ans[i]); return Ot(),0;
}
```


---

## 作者：徐致远 (赞：0)


[本蒟蒻的Blog](https://www.chnxuzhiyuan.cn/2019/03/04/%E3%80%8CSNOI2017%E3%80%8D%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%AF%A2%E9%97%AE-Solution/)

### 题解

首先拐一道弯，令$F(L1,R1,L2,R2)=\sum_{x=0}^{\infty}{get(L1,R1,x)\cdot get(L2,R2,x)}$。

那么根据容斥的原理，可以得到$F(L1,R1,L2,R2)=F(1,R1,1,R2)-F(1,L1,1,R2)-F(1,R1,1,L2)+F(1,L1,1,L2)$。

那么就把一个询问先拆成四个询问。

然后只要想办法求出$F(1,x,1,y)$。

直接套上莫队算法即可。

### 代码

```cpp
#include<cmath>
#include<cstdio>
#include<algorithm>
using namespace std;
typedef long long LL;
const int maxn=50005;
int n,q,A[maxn],S,Area[maxn],tot,cnt1[maxn],cnt2[maxn],p1,p2;LL ans[maxn],now;
inline int read()
{
	int ret=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9'){ret=ret*10+ch-'0';ch=getchar();}
	return ret*f;
}
struct Interval
{
	int R1,R2,f,id;
	void Init(){if(R1>R2)swap(R1,R2);}
	bool operator < (const Interval& b)const{return Area[R1]<Area[b.R1]||(Area[R1]==Area[b.R1]&&((Area[R1]&1)?R2<b.R2:R2>b.R2));}
}Q[maxn*4];
int main()
{
	n=read();S=sqrt(n)+1e-10;
	for(int i=1;i<=n;i++) A[i]=read();
	for(int i=1;i<=n;i++) Area[i]=(i-1)/S+1;
	q=read();
	for(int i=1;i<=q;i++)
	{
		int L1=read(),R1=read(),L2=read(),R2=read();
		tot++;Q[tot].R1=R1;Q[tot].R2=R2;Q[tot].f=1;Q[tot].Init();Q[tot].id=i;
		tot++;Q[tot].R1=L1-1;Q[tot].R2=R2;Q[tot].f=-1;Q[tot].Init();Q[tot].id=i;
		tot++;Q[tot].R1=R1;Q[tot].R2=L2-1;Q[tot].f=-1;Q[tot].Init();Q[tot].id=i;
		tot++;Q[tot].R1=L1-1;Q[tot].R2=L2-1;Q[tot].f=1;Q[tot].Init();Q[tot].id=i;
	}
	sort(Q+1,Q+1+tot);
	for(int i=1;i<=tot;i++)
	{
		while(p2<Q[i].R2){p2++;cnt2[A[p2]]++;now+=cnt1[A[p2]];}
		while(p1>Q[i].R1){cnt1[A[p1]]--;now-=cnt2[A[p1]];p1--;}
		while(p2>Q[i].R2){cnt2[A[p2]]--;now-=cnt1[A[p2]];p2--;}
		while(p1<Q[i].R1){p1++;cnt1[A[p1]]++;now+=cnt2[A[p1]];}
		ans[Q[i].id]+=now*Q[i].f;
	}
	for(int i=1;i<=q;i++)
		printf("%lld\n",ans[i]);
	return 0;
}
```



---

## 作者：zzhhtt (赞：0)

题解：因为题意很容易懂，所以直接说题；

我们可以将关系式变换一下get(l1,r1,x)*get(l2,r2,x)=get(0,r1,x)*get(0,r2,x)+get(0,l1-1,x)*get(0,l2-1,x)+get(l2-1,r2,x)*get(0,l1-1,x)-get(l1-1,r1,x)*get(0,l1-1,x);然后利用莫队算法即可。

AC代码为：



```
// luogu-judger-enable-o2
#include<bits/stdc++.h>
using namespace std;
const int maxn=5e4+10;
const int INF=0x3f3f3f3f;


struct node{
int L;
int R;
int Id;
int sign;
} p[4*maxn];


int a[maxn],block,pos[maxn];
long long cnt[maxn],cntc[maxn],num[maxn];


bool cmp(const node &a,const node &b)
{
return pos[a.L]==pos[b.L]? a.R<b.R : pos[a.L]<pos[b.L];
}


int main()
{
int N,M,l1,l2,r1,r2;

while(scanf("%d",&N)!=EOF)
{
long long flag=0;

memset(cnt,0,sizeof(cnt));
memset(cntc,0,sizeof(cntc));

block=sqrt(N);

for(int i=1;i<=N;i++)
{
cin>>a[i];
pos[i]=(i-1)/block+1;
}	

cin>>M;
for(int i=1;i<=M;i++)
{
cin>>l1>>r1>>l2>>r2;

p[++flag]=node{r1,r2,i,1};
p[++flag]=node{r2,l1-1,i,-1};
p[++flag]=node{l2-1,r1,i,-1};
p[++flag]=node{l1-1,l2-1,i,1};
}

sort(p+1,p+flag+1,cmp);

int l=0,r=0,ans=0;

for(int i=1;i<=flag;i++)
{
while(l<p[i].L)
{
l++;
ans+=cntc[a[l]];
cnt[a[l]]++;
}
while(l>p[i].L)
{
ans-=cntc[a[l]];
cnt[a[l]]--;
l--;
}
while(r<p[i].R)
{
r++;
ans+=cnt[a[r]];
cntc[a[r]]++;	
} 
while(r>p[i].R)
{
ans-=cnt[a[r]];
cntc[a[r]]--;
r--;
}

num[p[i].Id]+=ans*p[i].sign;
}
for(int i=1;i<=M;i++)
cout<<num[i]<<endl;
}

return 0;
}
```


---


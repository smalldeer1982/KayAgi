# [TJOI2019] 甲苯先生的字符串

## 题目背景

TJOI2019 D1T1

源文件名：str.*

时间限制: 1s 内存限制: 128M

## 题目描述

一天小甲苯得到了一条神的指示，他要把神的指示写下来，但是又不能泄露天机，所以他要用一种方法把神的指示记下来。神的指示是一个字符串，记为字符串 $s_1$，$s_1$ 仅包含 $26$ 个小写字母。现在小甲苯想要写下神的指示，记为字符串 $s_2$，$s_2$ 仅包含 $26$ 个小写字母，要求 $s_1$ 中的相邻的两个字母不能在 $s_2$ 中相邻地出现。现在给定 $s_2$ 的长度，小甲苯想知道他有多少种方法可以将神的指示写下来。输出种类数结果对 $10^9+7$ 取模。

## 说明/提示

对于 $30\%$ 的数据 $n\le100000$。

对于 $100\%$ 的数据 $1 \le n\le10^{15}$，$|s_1| \le 10^5$。

说明：相邻要求顺序相同，如样例中的 $s_2$ 里不能出现 $\text{ab}$，且仅不能出现 $\text{ab}$，但可以出现 $\text{ba}$。

## 样例 #1

### 输入

```
2
ab
```

### 输出

```
675
```

# 题解

## 作者：Fading (赞：10)

有**点**思维含量的题啊。

虽然作为省选题太套路了。

很显然是$dp$

设$f[i][j]$表示长度为$i$,末位为字符$j$的方案数

很显然的转移式

$$f[i][j]+=f[i-1][k]\ (kj\ \text{不为s1的子串})$$

但是$n$很大，怎么办呢？

发现是否可以转移的情况是固定的

可以考虑使用**矩阵**来判断是否可以转移。

如果字符串$ij$不为$s1$的子串，那么矩阵$X$中$X[i][j]=1$，否则$X[i][j]=0$。

$X$大小为$26$。

一次转移就是做一次矩阵乘法

$\begin{bmatrix}f[1] & f[2] & ... &f[26]\end{bmatrix}\times X$

为什么呢？

因为$f[i][j]+=f[i-1][k]\ (kj\ \text{不为s1的子串})$

也就是$f[i][j]+=f[i-1][k]\times X[k][j]$

就是
$$f[j]=\sum_{k=1}^{26}f[k]\times X[k][j]$$

正好是矩阵的形式。

由于初始条件下$f[1]=f[2]=...=1$，所以我们只要求出$X^{n-1}$矩阵中所有数的和就好了。矩阵快速幂做到时间复杂度$O(26^3log_2n)$

```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
#define ljc 1000000007
using namespace std;
long long n,m,pr,nf,x;
char s[1000001];
struct matrix{
    long long x[27][27];long long sz;	
    inline void clear(){
        for (int i=1;i<=26;i++){
            for (int j=1;j<=26;j++){
                x[i][j]=0;
            }
        }
    }
}a,one;
inline matrix mul(matrix a,matrix b){
    matrix c;
    c.clear();c.sz=a.sz;
    for (int i=1;i<=26;i++){
        for (int j=1;j<=26;j++){
            for (int k=1;k<=26;k++){
                c.x[i][j]=(c.x[i][j]%ljc+a.x[i][k]%ljc*b.x[k][j]%ljc)%ljc;
            }
        }
    }
    return c;
}
inline matrix fast_pow(matrix a,long long b){
    matrix t=one;
    while (b){
        if (b&1LL) t=mul(t,a);
        a=mul(a,a);b/=2LL;
    }
    return t;
}
inline void init_one(){
    one.sz=a.sz;
    for (int i=1;i<=26;i++){
        one.x[i][i]=1;
    }
}
int main(){
    scanf("%lld",&n);
    init_one();
    for (int i=1;i<=26;i++){
    	for (int j=1;j<=26;j++){
    		a.x[i][j]=1;
		}
	}
	scanf("%s",s+1);
	int len=strlen(s+1);
	for (int i=2;i<=len;i++){
		a.x[s[i-1]-'a'+1][s[i]-'a'+1]=0;
	}
    a=fast_pow(a,n-1);
    long long ans=0;
	for (int i=1;i<=26;i++){
    	for (int j=1;j<=26;j++){
    		ans=(ans+a.x[i][j])%ljc;
		}
	}
	cout<<ans;
}

```


---

## 作者：Ccreeper (赞：9)

这道题自己做的时候真没想出来正解。后来发现其实并不难，只能说自己学的不扎实，不会应用学过的知识。

# [更好的阅读体验](https://ccreeper33.github.io/2019/05/12/P5337%E7%94%B2%E8%8B%AF%E5%85%88%E7%94%9F%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/)


## 构造

不难发现状态只有26种，并且后一位字母由是前一位决定的，所以我们可以得到递推式

$$f[i] [j]= \sum_{k = 0}^{25} f[i - 1] [k] * d[k][j] $$

其中$d[i] [j]$表示上一位为第$i$个字母时，当前位是否可以为第$j$个字母。

既然有了递推式，又发现数据范围是$10^{15}$，不难想到用矩阵快速幂来加速，所以构造以下矩阵

$$
 \begin{bmatrix}
   1 & 1 & 1 & 1 & 1 & ... &1 \\
 \end{bmatrix}
$$
$$ans$$

表示当$n = 1$时，分别可能以26个字母结尾。

$$
 \begin{bmatrix}
  1 & 1 & 1& ... &1\\\\
  1 & 1 & 1& ... &1\\\\
  1 & 1 & 1& ... &1\\\\
  \vdots & \vdots & \vdots & & \vdots \\\\
  1 & 1 & 1& ... &1\\\\
 \end{bmatrix}
$$

$$base$$

转移矩阵，意义如上文中的$d[i][j]$。

$$
\left[
 \begin{matrix}
  1\\\\
  1\\\\
  1\\\\
  \vdots \\\\
  1\\\\
 \end{matrix}
\right]
$$

$$get\_ans$$

对$ans$矩阵元素求和。

### 构造完成！

此时可得$ans * base^{n - 1} * get\_ans$即为所求答案。

## 附代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod = 1e9 + 7;
typedef long long LL;

struct matrix { //矩阵相关
	LL a[26][26];
	matrix() {  
		memset(a, 0, sizeof(a));
	}
	matrix operator *(const matrix &o) { //重载运算符
		matrix res;
		for(int i = 0; i < 26; ++i) {
			for(int k = 0; k < 26; ++k) {
				int temp = a[i][k];
				for(int j = 0; j < 26; ++j) {
					res.a[i][j] += (temp * o.a[k][j]) % mod;
					res.a[i][j] %= mod;
				}
			}
		}
		return res;
	}
}ans, base, get_ans;

/*
istream& operator >> (istream &is, matrix &o) { 
    for(int i = 0; i < 26; ++i) {
        for(int j = 0; j < 26; ++j) {
            is >> o.a[i][j];
        }
    }
    return is;
}
ostream& operator << (ostream &os, const matrix &o) {
    for(int i = 0; i < 26; ++i) {
        for(int j = 0; j < 26; ++j) {
            os << o.a[i][j] << " ";
        }
        os << endl;
    }
    return os;
}
*/

matrix q_pow(matrix a, LL b) { //矩阵快速幂
	matrix res;
	for(int i = 0; i < 26; ++i) { 
		res.a[i][i] = 1;
	}
	while(b) {
		if(b & 1) res = res * a;
		a = a * a;
		b >>= 1; 
	}
	return res;
}

LL n, len;
char s[100005]; 

int main() {
	for(int i = 0; i < 26; ++i) {
		ans.a[0][i] = get_ans.a[i][0] = 1;
		for(int j = 0; j < 26; ++j) {
			base.a[i][j] = 1;
		}
	}
	cin >> n >> s;
	len = strlen(s); 
	for(int i = 1; i < len; ++i) {
		base.a[s[i - 1] - 'a'][s[i] - 'a'] = 0;
	}
	cout << (ans * q_pow(base, n - 1) * get_ans).a[0][0] << endl;
	return 0;
}
```


---

## 作者：fish_love_cat (赞：4)

TJOI 怎么天天出矩阵快速幂啊。

---

容易发现每个字符后面接的东西是一定的，可以考虑建图。

然后就变成和 [P5789](https://www.luogu.com.cn/problem/P5789) 差不多的东西了，dp 做法是一致的。

但直接做过不了，于是大力矩阵快速幂优化 dp 即可。

注意到本题 $n=1$ 时是只有源点的初始状态，所以快速幂时要令 $n$ 减一。

然后就是本题源点任意，统计答案方式略有差异。

其他没了。代码很丑没必要放了。

---

## 作者：crashed (赞：1)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.com.cn/problem/P5337)看题目。  
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然是一道$DP$题。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$f(i,j)$：长度为$i$，最后一个字符$j$，且满足题目要求的字符串的数量。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设$g(x,y)$表示$x$和$y$两个字符可以在最终的字符串中相邻出现，也就是满足$x$和$y$不在$s_1$中相邻。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;转移：  
$$f(i,j)=\sum_{k='a'}^{'z'}f(i-1,k)[g(k,j)]$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;暴力做是$O(26^2n)$的，$T$飞了。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑优化。发现第二位状态只有$26$，并且$n$无比巨大，所以考虑矩阵加速。设计初始矩阵为： 
$$\begin{bmatrix}1&1&1&\dots&1\end{bmatrix}$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;转移矩阵：  
$$\begin{bmatrix}g('a','a')&g('a','b')&g('a','c')&\dots&g('a','z')\\g('b','a')&g('b','b')&g('b','c')&\dots&g('b','z')\\g('c','a')&g('c','b')&g('c','c')&\dots&g('c','z')\\\vdots&\vdots&\vdots&\ddots&\vdots\\g('z','a')&g('z','b')&g('z','c')&\dots&g('z','z')\end{bmatrix}$$    
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时间是$O(26^3\log_2n)$   
# 代码
```cpp
#include <cstdio>
#include <cstring>

typedef long long LL;

const int mod = 1e9 + 7;
const int MAXSIZ = 30, MAXLEN = 1e5 + 5;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

struct matrix
{
	int mat[MAXSIZ][MAXSIZ], n, m;
	matrix( const int N = 0, const int M = 0 ) { n = N, m = M, memset( mat, 0, sizeof mat ); }
	int * operator [] ( const int & indx ) { return mat[indx]; }
	matrix operator * ( matrix other ) const 
	{
		matrix ret = matrix( n, other.m );
		for( int i = 1 ; i <= ret.n ; i ++ )
			for( int j = 1 ; j <= ret.m ; j ++ )
				for( int k = 1 ; k <= m ; k ++ )
					ret[i][k] = ( ret[i][k] + 1ll * mat[i][j] * other[j][k] % mod ) % mod;
		return ret;
	}
	void operator *= ( matrix other ) { *this = *this * other; }
}A, B;

LL N;
int M;
char S[MAXLEN];

int getIndx( char c ) { return c - 'a' + 1; }
matrix I( const int n ) 
{ matrix ret = matrix( n, n ); for( int i = 1 ; i <= n ; i ++ ) ret[i][i] = 1; return ret; }

matrix qkpow( matrix base, LL indx )
{
	matrix ret = I( base.n );
	while( indx )
	{
		if( indx & 1 ) ret *= base;
		base *= base; indx >>= 1;
	}
	return ret;
}

void init()
{
	A = matrix( 1, 26 );
	for( int i = 1 ; i <= 26 ; i ++ ) A[1][i] = 1;
	B = matrix( 26, 26 );
	for( int i = 1 ; i <= 26 ; i ++ )
		for( int j = 1 ; j <= 26 ; j ++ )
			B[i][j] = 1;
}

int main()
{
	init();
	read( N );
	scanf( "%s", S + 1 ), M = strlen( S + 1 );
	for( int i = 1 ; i < M ; i ++ ) B[getIndx( S[i] )][getIndx( S[i + 1] )] = 0;
	matrix part = qkpow( B, N - 1 );
	matrix fine = A * part;
	int res = 0;
	for( int i = 1 ; i <= 26 ; i ++ ) res = ( res + fine[1][i] ) % mod;
	write( res ), putchar( '\n' );
	return 0;
}
```

---

## 作者：Hope2075 (赞：1)

这题应该是送分题（然而我并没有考这道题）

首先，发现字符串的唯一用处是确定限制

所以，扫一遍，记录哪些有序字母对不能出现，记$p[i][j]=1$表示$i,j$可以连续出现，$p[i][j]=0$表示$i,j$不能连续出现

对于$n\leq 100000$的数据：

考虑DP

可以发现，只需记录已选部分长度和最后一位的字母即可

设$dp[i][c]$表示已经确定前$i$位，且最后一位是字母$c$的情况数

则$dp[1][c]=1$

$dp[i][c]=\sum _{c'=1}^{26} (dp[i-1][c']*p[c'][c])$

30分到手

继续优化

观察后面的式子，很像矩阵乘法

如果把$dp[i]$和$p$分别作为一个矩阵，就会发现，转移：

$dp[i]=dp[i-1]*p$

这样就可以得到：

$dp[n]=dp[1]*p^{n-1}$

把$n=0$和$n=1$特判掉，剩下的部分矩阵快速幂即可

最后计算答案时，直接把矩阵里的所有数相加即可

这样就能A了

代码：

```cpp
#include<iostream>
using namespace std;
const int C=26;
const long long M=1000000007;
struct matrix{
	long long num[C][C];
};
matrix operator*(matrix a,matrix b){
	matrix c;
	for(int i=0;i<C;i++){
		for(int j=0;j<C;j++){
			c.num[i][j]=0;
		}
	}
	for(int i=0;i<C;i++){
		for(int j=0;j<C;j++){
			for(int k=0;k<C;k++){
				c.num[i][j]+=a.num[i][k]*b.num[k][j];
				c.num[i][j]%=M;
			}
		}
	}
	return c;
}
matrix fpow(matrix a,long long b){
	matrix ans;
	for(int i=0;i<C;i++){
		for(int j=0;j<C;j++){
			ans.num[i][j]=(i==j);
		}
	}
	while(b){
		if(b&1)ans=ans*a;
		b>>=1;
		a=a*a;
	}
	return ans;
}
matrix p;
long long n;
char str[100007];
int main(){
	ios::sync_with_stdio(false);
	cin>>n>>str;
	if(n==0){
		cout<<"1"<<endl;
	}else if(n==1){
		cout<<"26"<<endl;
	}else{
		for(int i=0;i<C;i++){
			for(int j=0;j<C;j++){
				p.num[i][j]=1;
			}
		}
		for(int i=1;str[i];i++){
			p.num[str[i]-'a'][str[i-1]-'a']=0;
		}
		p=fpow(p,n-1);
		long long ans=0;
		for(int i=0;i<C;i++){
			for(int j=0;j<C;j++){
				ans+=p.num[i][j];
				if(ans>=M)ans-=M;
			}
		}
		cout<<ans;
	}
}
```

---

## 作者：Great_Influence (赞：1)

矩阵快速幂裸题。

代码:
```cpp
#include<cstdio>
#include<cstdlib>
#include<cctype>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<cassert>
#include<iostream>
#include<climits>
#include<vector>
#include<bitset>
#include<queue>
#define Rep(i,a,b) for(register int i=(a);i<=(b);++i)
#define Repe(i,a,b) for(register int i=(a);i>=(b);--i)
#define rep(i,a,b) for(register int i=(a);i<(b);++i)
#define pb push_back
#define mp make_pair
#define mx(a,b) (a>b?a:b)
#define mn(a,b) (a<b?a:b)
typedef unsigned long long uint64;
typedef unsigned int uint32;
typedef long long ll;
using namespace std;

namespace IO
{
	const uint32 Buffsize=1<<15,Output=1<<24;
	static char Ch[Buffsize],*S=Ch,*T=Ch;
	inline char getc()
	{
		return((S==T)&&(T=(S=Ch)+fread(Ch,1,Buffsize,stdin),S==T)?0:*S++);
	}
	static char Out[Output],*nowps=Out;
	
	inline void flush(){fwrite(Out,1,nowps-Out,stdout);nowps=Out;}

	template<typename T>inline void read(T&x)
	{
		x=0;static char ch;T f=1;
		for(ch=getc();!isdigit(ch);ch=getc())if(ch=='-')f=-1;
		for(;isdigit(ch);ch=getc())x=x*10+(ch^48);
		x*=f;
	}

	template<typename T>inline void write(T x,char ch='\n')
	{
		if(!x)*nowps++='0';
		if(x<0)*nowps++='-',x=-x;
		static uint32 sta[111],tp;
		for(tp=0;x;x/=10)sta[++tp]=x%10;
		for(;tp;*nowps++=sta[tp--]^48);
		*nowps++=ch;
		if(nowps-Out>=1<<23)flush();
	}

	inline void getstr(char*q)
	{
		register char ch;
		for(ch=getc();!isgraph(ch);ch=getc());
		for(;isgraph(ch);ch=getc())*q++=ch;
		*q='\0';
	}

	inline void getwd(char&x){for(x=getc();!isupper(x);x=getc());}
}
using namespace IO;

void file()
{
#ifndef ONLINE_JUDGE
	FILE*DSD=freopen("water.in","r",stdin);
	FILE*CSC=freopen("water.out","w",stdout);
#endif
}

inline void Chkmin(int&u,int v){u>v?u=v:0;}

inline void Chkmax(int&u,int v){u<v?u=v:0;}

inline void Chkmax(double&u,double v){u<v?u=v:0;}

inline void Chkmax(ll&u,ll v){u<v?u=v:0;}

inline void Chkmin(ll&u,ll v){u>v?u=v:0;}

const int MAXN=1e5+7;

static ll n;

static char s[MAXN];

inline void init()
{
	read(n);
	getstr(s);
}

const int mod=1e9+7;

static ll A[26][26];

static struct mat
{
	int c[26][26];

	mat operator*(const mat&a)const
	{
		static mat X;
		rep(i,0,26)rep(j,0,26)
		{
			A[i][j]=0ll;
			rep(k,0,8)A[i][j]+=(ll)c[i][k]*a.c[k][j];
			A[i][j]%=mod;
			rep(k,8,17)A[i][j]+=(ll)c[i][k]*a.c[k][j];
			A[i][j]%=mod;
			rep(k,17,26)A[i][j]+=(ll)c[i][k]*a.c[k][j];
			X.c[i][j]=A[i][j]%mod;
		}
		return X;
	}
}bs,as;

inline void solve()
{
	int x=strlen(s)-1;
	rep(i,0,26)rep(j,0,26)bs.c[i][j]=1;
	rep(i,0,x)bs.c[s[i]-'a'][s[i+1]-'a']=0;
	rep(i,0,26)as.c[i][i]=1;
	for(--n;n;n>>=1,bs=bs*bs)if(n&1)
		as=as*bs;
	static ll aaa=0ll;
	rep(i,0,26)rep(j,0,26)aaa+=as.c[i][j];
	cout<<aaa%mod<<endl;
}

int main()
{
	file();
	init();
	solve();
	return 0;
}
```

---

## 作者：ThomasX (赞：0)

**搬运官方题解。**

------------

$dp[i][j]$表示长度为$i$的字符串以$j$结尾时的合法方案数，$w[i][j]$表示字符串$ij$能否出现。

dp状态转移方程表示: $dp[i][j] = \sum w[k][j] \times dp[i-1][k]$

对于100%的数据，考虑到转移方程是个矩阵，可以使用矩阵快速幂加速运算。

------------

std
```cpp
#include <bits/stdc++.h>
using namespace std;
char s[100100];
struct Mat{
	long long m[26][26];
};
long long mod=1e9+7;

Mat mul(Mat a,Mat b){
	Mat ret;
	memset(ret.m,0,sizeof(ret.m));
	for(int i=0;i<26;i++)
		for(int j=0;j<26;j++)
			for(int k=0;k<26;k++)
				ret.m[i][j]+=a.m[i][k]*b.m[k][j]%mod;
	for(int i=0;i<26;i++)
		for(int j=0;j<26;j++)
			ret.m[i][j]%=mod;
	return ret;
}

Mat mypow(Mat a,long long int k){
	Mat ret;
	for(int i=0;i<26;i++)
		for(int j=0;j<26;j++)
			ret.m[i][j]=(i==j);
	while(k){
		if(k&1) ret=mul(ret,a);
		a=mul(a,a);
		k>>=1;
	}
	return ret;
}

int main(){
	freopen("str.in", "r", stdin);
	freopen("str.out", "w", stdout);
	long long int n;
	scanf("%lld%s",&n,s);
	int l=strlen(s);
	Mat a;
	for(int i=0;i<26;i++)
		for(int j=0;j<26;j++)
			a.m[i][j]=1;
	for(int i=1;i<l;i++){
		a.m[s[i-1]-'a'][s[i]-'a']=0;
	}
	a = mypow(a,n-1);
	long long ans=0;
	for(int i=0;i<26;i++)
		for(int j=0;j<26;j++)
			ans+=a.m[i][j];
	ans%=mod;
	printf("%lld\n",ans);
}

```


---

## 作者：liuqy (赞：0)

先吐槽一下出题人的语文水平~~真的是有所欠缺~~，首先字符是有顺序的，题目中ab无法出现，但ba可以。

------------

首先看到这道题的第一眼就可以看出是道dp题,定义dp[i][j]表示长度为i结尾是j的方案数。另外开一个数组表示f,表示前后两个字符能否在一起,然后按照转移方程


### dp[i][j]=dp[i-1][k]（f[j][k]为真时）然后递推算出即可。

------------

当然你只能过30%的点，再看看范围n=$10^{15}$，发现其实可以直接把两串合成一串，依此递推，复杂度直接就下来了，所以用矩阵快速幂~~瞎搞~~即可。
### dp[i][j]=a[i][k]*b[k][j]

------------

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
const int MAXN=1e9+7;
struct node{
	long long m[30][30];
};
char s[11000];
long long n;
node mul(node a,node b){
	node pre;
	memset(pre.m,0,sizeof (pre.m));
	for(int i=0;i<26;i++)for(int j=0;j<26;j++)for(int k=0;k<26;k++)pre.m[i][j]+=a.m[i][k]*b.m[k][j]%MAXN;
	for(int i=0;i<26;i++)for(int j=0;j<26;j++)pre.m[i][j]%=MAXN;
	return pre;
}
node mypow(node a,long long k){
	node pre;
	for(int i=0;i<26;i++)for(int j=0;j<26;j++)pre.m[i][j]=(i==j);
	while(k){
		if(k&1)pre=mul(pre,a);
		a=mul(a,a);
		k>>=1;
	}
	return pre;
}
int main(){
	scanf("%lld%s",&n,s);
	node a;
	for(int i=0;i<26;i++)for(int j=0;j<26;j++)a.m[i][j]=1;
	for(int i=1;i<strlen(s);i++)a.m[s[i-1]-'a'][s[i]-'a']=0;
	a=mypow(a,n-1);
	long long ans=0;
	for(int i=0;i<26;i++)for(int j=0;j<26;j++)ans+=a.m[i][j]%MAXN;
	printf("%lld",ans%MAXN);
	return 0;
}
```


---

## 作者：zhenglier (赞：0)

~~小蒟蒻终于会了一点矩阵快速幂了。~~

## 前置知识：理解矩阵乘法以及矩阵快速幂

对于长度为1的串，末尾为a~z的字符串个数全部为1，我们考虑增加一个长度后的答案。如果没有限制条件，每一个串都能转化为长度加一的末尾为a~z的串，所以矩阵为长为26，宽为26，所有数都是1的矩阵。

但因为在给定串中相邻的字符不能在此串中相邻，相当于在字符串$s$中，对于任意$1<i<=len_s$，以$s_{i-1}$的字符串无法转移给以$s_i$为结尾的串。这等价于在矩阵中将$(s_{i-1},s_i)$赋值为0，所以我们把这些点赋值为0，然后再跑矩阵快速幂就可以了。

记住最后的答案要将以a~z结尾的所有串的个数加起来。


```cpp
#include<bits/stdc++.h>
#define res register int
using namespace std;
const int p=1e9+7,N=26;
struct matrix{
   int a[N+1][N+1];
   matrix(){
       memset(a,0,sizeof a);
   }
}ma;
matrix operator*(const matrix&x,const matrix&y){
    matrix c;
    for(res i=1;i<=N;++i){
        for(res j=1;j<=N;++j){
            for(res k=1;k<=N;++k){
                c.a[i][j]=(c.a[i][j]+1ll*x.a[i][k]*y.a[k][j]%p)%p;
            }
        }
    }
    return c;
}
matrix mpow(matrix a,long long n){
    matrix ret;
    for(int i=1;i<=N;++i){
        ret.a[i][i]=1;
    }
    while(n){
        if(n&1)ret=ret*a;
        a=a*a;
        n/=2;
    }
    return ret;
}
long long n;
int a,b;
char s[1000010];
int main(){
    cin>>n;
    cin>>s;
    int len=strlen(s);
    for(int i=1;i<=N;++i){
        for(int j=1;j<=N;++j){
            ma.a[i][j]=1;
		}
	}
    for(int i=1;i<len;++i){
        ma.a[s[i-1]-'a'+1][s[i]-'a'+1]=0;
	}
    matrix ret,ot;
    for(int i=1;i<=N;++i)ret.a[i][N]=1;
    ot=mpow(ma,n-1)*ret;
    int ans=0;
    for(int i=1;i<=N;++i)ans=(ans+ot.a[i][N])%p;
    cout<<ans<<endl;
}
```


---


# [JSOI2015] 最大公约数

## 题目描述

给定一个长度为 $N$ 的正整数序列 $A_i$ 。

对于其任意一个连续的子序列 $A_l,A_{l+1},...,A_r$ ，我们定义其权值 $W(L,R)$ 为其长度与序列中所有元素的最大公约数的乘积，即 $W(L,R) = (R-L+1) × \gcd (A_l,...,A_r)$。

`JYY` 希望找出权值最大的子序列。

## 说明/提示

$1 \le  A_i \le  10^{12}, 1 \le  N \le  100000$

## 样例 #1

### 输入

```
5
30 60 20 20 20```

### 输出

```
80```

# 题解

## 作者：redegg (赞：36)

简单证明一下，集合$\{gcd(a[l],a[l+1]...a[r])\ | l\le r\}$元素个数不超过$logn$个：

小于$n$且能被$n$整除的最大的数字一定小于等于$n/2$，也就说小于$n$的最大的$gcd$不超过$n/2$。

那么固定$r$后，每次往左边扩大一格，扩大区间范围后的$gcd$要么等于原来的$gcd$，要么就是小于等于原来的$gcd/2$。也就说产生的新的$gcd$数值一定都小于等于原来都一半，那么也就最多产生$log$级别个新的$gcd$数值。

并且我们发现，左边的$gcd(a[l]...a[r])$一定小于等于$gcd(a[l+1]...a[r])$。

所以我们枚举r，用一个队列存储这log个不同的gcd的左端点，每次直接枚举这些gcd更新，更新的时候加一些判断处理重复就好了，写起来很容易。

复杂度：$(nlog^2n)$

```
#include <bits/stdc++.h>
using namespace std;

int n;
queue<int> que;
queue<int> lins;
long long g[100005];
long long ans;

long long gcd(long long a,long long b){
    if(a==0)return b;
    return gcd(b%a,a);
}

int main()
{
    scanf("%d",&n);
    g[0]=-1;
    for(int i=1;i<=n;i++)
    {
        scanf("%lld",&g[i]);
        int last=0;
        while(!que.empty())
        {
            int x=que.front();
            que.pop();
            g[x]=gcd(g[x],g[i]);
            ans=max(ans,g[x]*(i-x+1));
            if(g[x]==g[last])continue;
            lins.push(x);
            last=x;
        }
        ans=max(ans,g[i]);
        while(!lins.empty())
        {
            que.push(lins.front());
            lins.pop();
        }
        if(g[last]!=g[i])que.push(i);
    }
    printf("%lld\n",ans);
    return 0;
}

```


---

## 作者：saxiy (赞：17)

#### UPD: 19/10/05 补充了部分说明，感谢 @LRL52 提出的错误并修正了代码。
#### UPD：21/06/10 修改了表述并补充了正确性证明

------------

这题可以用区间分治的思想。在两年后的今天我才惊讶地发现《算法导论》分治章节的第一页就是这个算法。

#### 题目分析:

在我们现在考虑的区间 $[L,R]$ 中，设最大价值区间为 $[l,r]$，设 $mid=\left\lfloor\frac{L+R}{2}\right\rfloor$，那么它只有三种可能：

1. $[l,r]$ 在区间 $[L,mid)$ 中。
2. $[l,r]$ 在区间 $(mid,R]$ 中。
3. $l$ 在 $[L,mid]$ 中，$r$ 在 $[mid,R]$ 中。

前两种情况递归就行了，边界为 $L=R$，以权值 $a_i$（即自己乘以长度 $1$）尝试更新答案。

然后是第三种情况，既然 $l$ 在 $[L,mid]$ 中，$r$ 在 $[mid,R]$ 中，那么必然包含了 $a_{mid}$ 这个数，从 $a_{mid}$ 开始向左右扩展，如果一个与当前选取的区间左右相邻的数加进来能保持当前 $\gcd$ 不变，那么就贪心地加进来，在无法拓展时就可以尝试更新答案了，然后加进会改变 $\gcd$ 的一个新数，又开始拓展 $\dots$ 直到拓展到边界 $L$ 或者 $R$ 为止。

在加进新数改变 $\gcd$ 时我们有两种选择，一种是加左边的，一种是加右边的，我们只需要一次以左边为准拓展完一次，再一次以右边为准即可。这样能保证考虑到这个区间所有的 $\gcd$ 了，正确性在代码后证明。

不算 $\gcd$ 的复杂度为 $O(n\log{n})$。 ~~大家就把gcd当常数好了~~

#### 代码实现(2019年，216ms in total):

```cpp
//2019 last edition by saxiy，2019的古董仅作参考
#pragma GCC optimize("fast-math,unroll-loops")
#include <bits/stdc++.h>
#define RS register
#define N 100005
using namespace std;
typedef long long ll;

template <typename T> void read(T &x) {
	x = 0; RS char c(getchar());
	while(!isdigit(c)) c = getchar();
	for(;isdigit(c);c = getchar())
		x = (x << 3) + (x << 1) + (c ^ 48); 
}

int n; ll a[N];

inline ll max(ll a, ll b) { return a > b ? a : b; }

ll gcd(ll a, ll b) {//不用管这gcd
	if(!a) return b; if(!b) return a;
	if(!(a & 1 || b & 1))
		return gcd(a >> 1, b >> 1) << 1;
	if(!(a & 1)) return gcd(a >> 1, b);
	if(!(b & 1)) return gcd(a, b >> 1);
	return gcd(abs(a - b), min(a, b));
}

ll dfs(int L, int R) {
	if(L == R) return a[L];
	RS int l, r, mid = L + R >> 1;
	l = r = mid;
	RS ll g = a[mid], maxx = a[mid];
	while(L <= l && r < R) {
		g = gcd(a[++r], g);
		while(r <= R) if(a[++r] % g) break; r--;
		while(l >= L) if(a[--l] % g) break; l++;
		maxx = max(maxx, (r - l + 1) * g);
	}
	l = r = mid; g = a[mid];
	while(L < l && r <= R) {
		g = gcd(a[--l], g);
		while(l >= L) if(a[--l] % g) break; l++;
		while(r <= R) if(a[++r] % g) break; r--;
		maxx = max(maxx, (r - l + 1) * g);
	}
	return max(maxx, max(dfs(L, mid), dfs(mid + 1, R)));
}

int main() {
	read(n);
	for(RS int i = 1;i <= n;i++) read(a[i]);
	printf("%lld", dfs(1, n));
	return 0;
}
```

#### 正确性证明

会用到几个易证的引理，留给读者思考就略过证明了。

1. 对于所有 $a_i(i \in [L,R])$，区间 $[a_i,a_{mid}]$ 一定被拓展过。 
2. 对于一个序列任意的子序列（可以不连续），子序列的 $\gcd$ 一定 $\ge$ 原序列的 $\gcd$。
3. 如果公共 $\gcd$ 减小，至少除以 $2$。

定义某区间的 **父区间** 为此区间经两侧完全贪心拓展后的区间。

定义 **最大价值区间** 为其相同公共 $\gcd$ 的子区间的 **父区间**，即保证目前 $\gcd$ 不变的情况下，区间长度最大。

现在我们算法最大的问题就是只能保证每个 $a_i(i \in [L,R])$，区间 $[a_i,a_{mid}]$ 被拓展过，会不会存在一个区间 $[l,r]$ 满足 $l\in [L,mid] \And r\in [mid,r]$ 并且我们没考虑过，事实上这样的区间是存在的，下面证明这样的区间不可能更新答案。

假设存在 **最大价值区间** $[l,r]$（显然我们只用考虑**最大价值区间**）是区间 $[L,R]$ 内的最优解，那么根据 **引理1**，$[l,mid]$ 和 $[mid,r]$ 一定被拓展过，那么存在 $a_n\in[l,mid)$ 恰好位于 $[mid,r]$的 **父区间** 左侧相邻位置且使得 $a_n$ 加入 $[mid,r]$ 的 **父区间** 后会改变其 $\gcd$。同理定义 $a_m\in (mid,r]$。根据 **引理2、3**，可以得到如下不等式关系。

定义区间 $[l,r]$ 长度为 $S$、$\gcd$ 为 $E$，区间 $[l,mid]$ **父区间** 长度为 $S_l$、$\gcd$ 为 $E_l$，同理定义 $S_r$、$E_r$。

$$\begin{cases}SE>S_lE_l\\SE>S_rE_r\\S_l+S_r>S\\E\le \frac{E_l}{2}\\E\le \frac{E_r}{2}\end{cases}$$

不等式 $1$、$2$ 描述了最优权值关系，限定了 $[l,r]$ 能尝试更新答案。不等式 $3$ 描述的长度关系来自于 $[l,mid]$ 和 $[mid,r]$ 的 **父区间** 至少共同包含了 $a_{mid}$ 这个数。不等式 $3$、$4$ 说明了 $[l,r]$ 不可被拓展到的性质和 **引理3**。

将不等式 $4$ 带入 $1$，$5$ 带入 $2$ 可得：

$$\begin{cases}S_l<\frac{S}{2}\\S_l<\frac{S}{2}\end{cases}$$

相加便和不等式 $3$ 推出了矛盾。

**所以，不存在这样的区间有机会更新答案**

证毕，这就是正确性。

---

## 作者：stansxt (赞：10)

# 前言

- 这篇题解思路可能比较诡异，且代码冗长，只是在这里记录一下自己的思路供大家参考，请急于了解常规思路的大佬移步QwQ

---

# 思路

- 首先，我们固定右端点，然后我们就只需要快速找到 ***能更新答案的左端点***，并更新答案
- 第一步非常简单，我们要找出第一个能更新答案的左端点。由于每次左移左端点，$gcd$ 只可能变小或不变，不可能变大，所以我们只需要找到当前 ***可能的最大 $gcd$ ，然后判断左端点至少在哪里，之后判断该左端点到当前右端点的区间 $gcd$ 是否仍是当前需要的 $gcd$*** ，如果是就停下，否则更新当前最大可能的 $gcd$ 并重复这一步。注意如果左端点已经小于等于0，就表明当前右端点不可能更新答案，所以 $continue$
- 注意停下之后，$while$ 循环找到满足当前 $gcd$ 的最左端点，然后再更新答案
- 第二步，我们需要再向左找到下一个、下下个……所有能更新答案的左端点
- 在仔细思考~~看了题解~~之后，我们发现现在我们已经有了一个左端点，并且答案就是由该端点产生的，并且左移左端点后 $gcd$ 必然变小（不会不变）。 ***注意到 $gcd$ 变小后，新的 $gcd$ 一定被原来的 $gcd$ 整除，所以新的 $gcd$ 一定小于等于原 $gcd$ 的一半。*** 为了能够更新答案， ***不难发现区间长度至少需要 * 2*** 。因此，我们每次更新左端点使得区间长度翻倍即可

- 代码中有些释，不理解的话可以参考代码哦~


---

# 代码

```

//P5502 [JSOI2015]最大公约数  
//submit 1             
//By sxt on 2020.3.14    
#include<iostream>   
#include<cstdio>   
#include<cstdlib>   
#include<cstring>   
#include<algorithm>    

#define rg register int   
#define il inline    
#define int long long    
#define in read()                   
#define pint(x) printf("%lld\n", x)    
#define _num(x) (x >= '0' && x <= '9')  
#define mid ((l+r)>>1)   
#define el else if  

using namespace std;  

const int N = 1e5 + 7;

inline int read(){  
	int x=0,f=1;      
	char ch=getchar();   
	while(!_num(ch)){   
		if(ch=='-')    
			f=-1;  
		ch=getchar();   
	}  
	while(_num(ch)){   
		x=x*10+ch-'0';   
		ch=getchar();   
	}           
	return x*f;    
}    

struct Tree{    
	int g;    
}tr[N<<2];    
    
int a[N], m, n, now, kk;

//线段树，O(logn)查询区间gcd

il void upd(int rt){    
	tr[rt].g = __gcd(tr[rt<<1].g, tr[rt<<1|1].g);    
}   
 
void build(int l, int r, int rt){   
	if(l == r){   
		tr[rt].g = a[l];   
		return;   
	}    
	build(l, mid, rt<<1), build(mid+1, r, rt<<1|1);    
	upd(rt);    
	return;     
}      

int query(int l, int r, int lx, int rx, int rt){   
	if(l == lx && r == rx){   
		return tr[rt].g;   
	}    
	if(rx <= mid) return query(l, mid, lx, rx, rt<<1);    
	el(lx > mid) return query(mid+1, r, lx, rx, rt<<1|1);                                 
	else return __gcd(query(l, mid, lx, mid, rt<<1), query(mid+1, r, mid+1, rx, rt<<1|1));   
}

int gcd(int u, int v){    
	if(u < v) swap(u, v);    
	return v == 0 ? u : gcd(v, u % v);    
}    

int x, y, ans, ls;   

signed main()   
{   
	n = in;   
	for(rg i = 1; i <= n; ++ i){   
		a[i] = in;            
		ans = max(ans, a[i]);   
	}   
	build(1, n, 1);    
	for(rg i = 2; i <= n; ++i){   
		now = i-1;    
		x = gcd(a[now], a[i-1]);//初始最大gcd     
		y = ans / x;//区间长度至少是y才能更新答案    
		ls = i - y;//左端点    
		if(ls <= 0) continue;//该右端点已经不可能更新答案，就continue   
		y = query(1, n, ls, i, 1);//区间实际gcd    
		while(y != x){//实际gcd不等于需要的gcd，我们需要继续第一步    
			x = y;//当前最大可能gcd     
			y = ans / x;//区间长度至少是y才能更新答案  
			ls = i - y;   
			if(ls <= 0) break;    
			y = query(1, n, ls, i, 1);    
		}    
		if(ls <= 0) continue;    
		while(a[ls-1] % y == 0 && ls > 1) --ls;//找到当前gcd的最左端点   
		ans = y * (i - ls + 1);//更新答案   
		while(ls > i/2){//第二步    
			ls = ls * 2 - i;//ls依然是左端点          
			y = query(1, n, ls, i, 1);
            		if(ans > (i - ls + 1) * y){//无法更新答案，就稍微处理一下，其实没啥大用QwQ
                    		ls = i - ans / y;
                            	continue;
                        }
			ans = max(ans, (i - ls + 1) * y);    
		}  
	}  
	pint(ans);   
	return 0;   
}  

```

___

_$PS：这题纯粹是因为我一不小心把一篇题解从头到尾仔细看了一遍，然后就只好强迫自己想个新思路出来了QwQ$_

_$从13号早上一直想直到14号才想明白啊QwQ$_

---

___THE · END .___



---

## 作者：tth37 (赞：7)

对于求解区间权值 $=value *length$ 的最值问题时，我们通常可以枚举区间左端点，然后高效地找出右端点更新答案。

朴素的想法是枚举右端点 $r\in [l,n]$ 。根据显然的贪心策略，如果右端点在某一区间移动时，$\gcd(a_l,a_{l+1},...,a_r)$ 保持不变，则右端点越大越好。

因此可以用倍增优化右端点的确定。但是在倍增的过程中，需要多次查询区间最大公约数；我们可以用ST表的思路对序列预处理，做到 $O(1)$ 复杂度查询。

但是，如果已经确定左端点 $l$ ，不同的右端点选取会对应许多不同的最大公约数值，那么该算法的复杂度将无法承受。

稍加观察，可以发现当左端点确定时，右端点右移一个单位，原子段的最大公约数要么维持不变；要么变为原最大公约数的一个约数。换言之，当左端点确定时，不同的右端点最多对应 $\log_2n$ 个不同的最大公约数值。算法复杂度得以控制在 $O(n(\log n)^2)$ 。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

inline ll gcd(ll a, ll b) {
    return b == 0 ? a : gcd(b, a % b);
}

int T, N;
ll ans;
ll a[100005];
ll st[100005][18];
int lg[100005];

inline ll query(int l, int r) {
    int k = lg[r - l + 1];
    return gcd(st[l][k], st[r - (1 << k) + 1][k]);
}

int main() {
    lg[1] = 0;
    for (register int i = 2; i <= 100000; ++i)
        lg[i] = lg[i >> 1] + 1;
    scanf("%d", &N);
    for (register int i = 1; i <= N; ++i)
        scanf("%lld", &st[i][0]);
    for (register int j = 1; j <= lg[N]; ++j)
        for (register int i = 1; i + (1 << j) - 1 <= N; ++i)
            st[i][j] = gcd(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);
    for (register int l = 1; l <= N; ++l) {
        int r = l;
        while (r <= N) {
            ll cur = query(l, r);
            for (register int i = lg[N]; i >= 0; --i) {
                if (r + (1 << i) <= N && query(l, r + (1 << i)) == cur)
                    r += (1 << i);
            }
            ans = max(ans, cur * (r - l + 1));
            r += 1;
        }
    }
    printf("%lld", ans);
    return 0;
}
```

---

## 作者：crashed (赞：7)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.com.cn/problem/P5502)看题目。  
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~~感觉有点无脑的~~ 分治题。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于左右端点都在$[L,R]$的区间来说，它们无外乎出现三种情况——  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$1.$在区间$[L,(L+R)/2]$里。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$2.$在区间$[(L+R)/2+1,R]$里。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$3.$跨过了中点$(L+R)/2$。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一第二种情况显然可以继续划分下去解决。考虑第三种情况，此时这个区间一定跨过了$(L+R)/2$。不难想到再维护两个指针$lp$和$rp$。初始将它们指向$(L+R)/2$，然后移动它们。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设我们现在已经移动了几步了，此时序列的$\gcd$为$g$。我们移动$lp$和$rp$，直到再移动它们就会使$g$变化，也就是找到了该情况下最长的那个区间（贪心的思想）。计算答案，并且选择左边或右边向外走一步，改变当前的$g$，继续重复上面的步骤。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;至于每次选择哪一边的问题，我们其实可以选择走两遍，一遍每次都选择左边推进，另一遍每次都选择右边推进。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时间为$O(n\log_2n)$。  
# 代码
```cpp
#include <cstdio>

typedef long long LL;

const int MAXN = 1e5 + 5;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

template<typename _T>
_T MAX( const _T a, const _T b )
{
	return a > b ? a : b;
}

LL A[MAXN];
int N;

LL gcd( const LL a, const LL b ) { return b ? gcd( b, a % b ) : a; }

LL divide( const int L, const int R )
{
	if( L == R ) return A[L];
	LL ret = 0, g;
	int mid = L + R >> 1, l, r;
	l = r = mid, g = A[mid];
	while( L < l && r <= R )
	{
		g = gcd( g, A[-- l] );
		while( r < R && ! ( A[r + 1] % g ) ) r ++;
		while( L < l && ! ( A[l - 1] % g ) ) l --;
		ret = MAX( ret, ( r - l + 1 ) * g );
	}
	l = r = mid, g = A[mid];
	while( L <= l && r < R )
	{
		g = gcd( g, A[++ r] );
		while( L < l && ! ( A[l - 1] % g ) ) l --;
		while( r < R && ! ( A[r + 1] % g ) ) r ++;
		ret = MAX( ret, ( r - l + 1 ) * g );
	}
	return MAX( ret, MAX( divide( L, mid ), divide( mid + 1, R ) ) );
}

int main()
{
	read( N );
	for( int i = 1 ; i <= N ; i ++ ) read( A[i] );
	write( divide( 1, N ) ), putchar( '\n' ); 
	return 0;
}
```

---

## 作者：HeartBlock_Love (赞：5)

有一个知识点：长度n的序列的所有子序列的公约数，最多有logn个。

枚举右端点，那么右端点之前的公约数个数最多logn个。维护这些公约数，每个出现的最左坐标（L）。

扫描所有公约数，取最优解

```
#include <cstdio>
#include <cctype>
#pragma G++ optimize(2)
template<class code>inline code read(const code &a){
    code x=0;short w=0;char ch=0;
    while(!isdigit(ch)) {w|=ch=='-';ch=getchar();}
    while(isdigit(ch)) {x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return w?-x:x;
}
inline long long gcd(long long n1,long long m1) {
	if(m1==0) return n1;
	gcd(m1,n1%m1);
}
inline long long max(long long x1,long long y1) {
	if(x1>y1) return x1;
	return y1;
}
long long n,now,k,wei_zhi[100005],yue_shu[100005];
long long a[100005],ans;
int main(){
	n=read(n);
	for(int i=1;i<=n;++i) a[i]=read(a[i]);
	now=0; ans=0;
	for(int i=1;i<=n;++i) {
		++now;
		wei_zhi[now]=i;
		yue_shu[now]=a[i];
		for(int j=now-1;j>=1;--j) yue_shu[j]=gcd(yue_shu[j],yue_shu[j+1]);
		k=0;
		for(int j=1;j<=now;) {
			++k;
			wei_zhi[k]=wei_zhi[j];
			yue_shu[k]=yue_shu[j];
			while(yue_shu[k]==yue_shu[j]) ++j;
		}
		now=k;
		for(int j=1;j<=now;++j) ans=max(ans,(i-wei_zhi[j]+1)*yue_shu[j]);
	}
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：yizhishenjing (赞：2)

# 前言
本蒟蒻的第二篇题解（~~事实上第一篇题解没过~~）， _求过~_ 。

今天刚好学了**数论**，所以说写篇题解纪念一下。

# 正文

题目很简洁，求 $ W(L,R)=(R-L+1)\times \gcd(A_l,\dots ,A_r) $。

首先考虑暴力做法，每次枚举左端点 $ L $ 和右端点 $ R $ 但是显然在 $ N=10^5$的情况下显然会超时 。  所以说，我们考虑优化一下 。

令 $g(l,r)=\gcd(a_l,a_{l+1},\dots,a_r)$， 注意到当固定右端点 $R$，则对于左端点 $L$ 和 $L+1$，要么有 $g(l,r)=g(l+1,r)$，要么有 $g(l,r)\le \dfrac {g(l+1,r)}{2}$。

所以固定 $R$，不同的 $g(l,r)$ 个数是 $O(\log a_i)$ 的，且 $g(l,r)$ 相同的 $l$ 是一段连续区间。

同时在 $g(l,r)$ 相同时，显然有一贪心思想是 $l$ 越小越好，这样就可以保证 $(R-L+1)$ 更大。

所以用 vector 维护 $g(l,r)$ 相同的 $l$ 的区间左端点，这样这道题就做完了。时间复杂度是 $O(n\log_2a_i)$的。

# AC Code

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

ll n,A[100100],ans;

vector< pair<ll,ll> >last;//last存储以当前右端点结尾的所有gcd段信息

ll getgcd(ll x,ll y){
	if( y==0 )return x;
	return getgcd(y,x%y);
}//辗转相除法求gcd 

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	
	cin >> n;
	
	for(int i = 1; i <= n; i++) {
		cin >> A[i];
	}
	//枚举右端点r从1到n
	for(int r = 1;r <= n; r++) {
		
		vector< pair<ll,ll> >now;//now存储以r结尾的所有gcd段信息 
		
		now.push_back( { A[r], r } );//添加当前单个元素作为一个段 
		
		for(auto i : last){//处理上一个右端点(r-1)的gcd段，将当前元素A[r]与每个gcd段合并 
			
			ll lgcd = i.first ;
			
			ll gcd = getgcd( lgcd, A[r] );//计算新的gcd值 
			
			if(gcd == now.back().first) {//如果当前的gcd和当前now中的最后一个gcd段的值相同，说明可以合并一下 
				
				now.back().second = min( now.back().second, i.second );
				
			} else {//如果不行单独组成一个gcd段 
				
				now.push_back({ gcd, i.second });
				
			}
			
		}
		for(auto i : now){//更新一下答案 
			
			ll len = r - i.second + 1;
			
			ans = max( ans, len*i.first );
			
		}
		
		last = now;//将now作为下一轮的last 
		
	}
	
	cout << ans;
	
	return 0;
} 
```

---

## 作者：Leaper_lyc (赞：1)

发一种题解区没有的做法。

真是序列分治好题。

假如现在递归到了区间 $[L,R]$，最大的子序列无非是在左半边/右半边/横跨 $mid$。

主要是横跨 $mid$ 的情况，通常将区间分成两半分别考虑，再合并。以区间 $[L,mid]$ 为例：考虑它的后缀 $[L',mid]$，设后缀 $\gcd$ 数组 $p_i=\gcd(A_i,...,A_{mid})$。

第一种情况：如果 $[L',R]$ 和 $[L'-1,R]$ 的 $\gcd$ 相同，那自然的会选择 $[L'-1,R]$，因为更长。

第二种情况：但如果 $[L',R]$ 比 $[L'-1,R]$ 的 $\gcd$ 更大，这时候可以把这个 $L'$ 的位置放到一个 `vector` 里，代表这个 $\gcd$ 所能取到的最长长度的位置（称做最优位置）。

抓住 $\gcd$ 的性质，我们注意到： $p_i$ 中的不同元素至多有 $\log V$ 个（$V$ 是值域），也就是能让后缀 $\gcd$ 变化的位置至多有 $\log V$ 个，也就是说需要扔进 `vector` 里的东西实际上并不多。

右半边 $[mid+1,R]$ 同理，也可以处理出一个最优位置的集合。

然后 $O(\log^2 V)$ 枚举端点即可。

总复杂度也就 $O(n\log n\log V)$ 这样。

```cpp
#include <iostream>
#include <cstdio>
#include <vector>
using namespace std;
#define int long long
const int N = 1e5 + 10;
int n, a[N], ans;
vector < pair <int, int> > ls, rs;
inline int gcd(int x, int y) {
    return y == 0 ? x : gcd(y, x % y);
}
int solve(int l, int r) {
    if (l == r) return a[l];
    int mid = (l + r) >> 1;
    int res = max(solve(l, mid), solve(mid + 1, r));
    ls.clear(), rs.clear();
    for (int i = mid, g = a[mid]; i >= l; i--) {
        int gg = gcd(g, a[i]);
        if (gg < g) ls.push_back({i + 1, g});
        else if (i == l) ls.push_back({l, gg});
        g = gg;
    }
    for (int i = mid + 1, g = a[mid + 1]; i <= r; i++) {
        int gg = gcd(g, a[i]);
        if (gg < g) rs.push_back({i - 1, g});
        else if (i == r) rs.push_back({r, gg});
        g = gg;
    }
    // cout << "[" << l << ", " << r << "]\n";
    // for (auto i : ls) cout << "ls " << i.first << ' ' << i.second << '\n';
    // for (auto i : rs) cout << "rs " << i.first << ' ' << i.second << '\n';
    for (auto i : ls)
        for (auto j : rs)
            res = max(res, gcd(i.second, j.second) * (j.first - i.first + 1));
    return res;
}
signed main() {
    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i];
    cout << solve(1, n);
}
```

---

## 作者：zhoumurui (赞：1)

### 题面展示

令 $\operatorname{GCD}(i,j) = \gcd(a_i,\dots,a_j)$。

求 $\displaystyle \max_{i=1}^{n} \max_{j=i}^{n}(j-i+1)\operatorname{GCD}(i,j)$。

### 解题思路

前置知识：CDQ 分治、数论基础。

考虑 CDQ 分治。问题在于考虑下面这个式子：

$$\max_{i=l}^{mid} \max_{j=mid+1}^{r}(j-i+1)\operatorname{GCD}(i,j)$$

这个式子等于 $\displaystyle \max_{i=l}^{mid} \max_{j=mid+1}^{r}(j-i+1)\gcd(\operatorname{GCD}(i,mid),\operatorname{GCD}(mid,j))$ 是容易想到的。然而看上去不好优化。

考虑在 $mid$ 固定时，$\operatorname{GCD}(i,mid)$ 的取值只有 $\log n$ 种。考虑 $\operatorname{GCD}(i+1,mid)\mid \operatorname{GCD}(i,mid)$ 易证。

那么枚举两边各 $\log n$ 种取值，复杂度可以接受。

### 代码展示

```cpp
#include<bits/stdc++.h>
#define int long long
#define x first
#define y second
using namespace std;
int n,a[1000005],st[1000005][21];
int gcd(int x,int y){
    if (y==0)return x;
    return gcd(y,x%y);
}
int cal(int l,int r){
    int k=log2(r-l+1);
    return gcd(st[l][k],st[r-(1<<k)+1][k]);
}
int ans=0;
void cdq(int l,int r){
    if (l==r){
        ans=max(ans,a[l]);return;
    }
    int mid=(l+r)/2;
    cdq(l,mid);
    cdq(mid+1,r);
    
    vector<pair<int,int> > x,y;
    for (int i=l;i<=mid;i++){
        int temp=cal(i,mid);
        if (!x.size()||temp!=x.back().x)x.push_back({temp,i});
    }
    for (int i=r;i>mid;i--){
        int temp=cal(mid+1,i);
        //cout<<temp<<" "<<i<<"\n";
        if (!y.size()||temp!=y.back().x)y.push_back({temp,i});
    }
    for (pair<int,int> i:x){
        for (pair<int,int> j:y){
            //cout<<i.x<<" "<<j.x<<" "<<i.y<<" "<<j.y<<"\n";
            ans=max(ans,(j.y-i.y+1)*gcd(i.x,j.x));
        }
    }
}
signed main(){
    cin>>n;
    for (int i=1;i<=n;i++){
        cin>>a[i];
        st[i][0]=a[i];
    }
    for (int i=1;i<=20;i++){
        for (int j=1;j+(1<<i)-1<=n;j++){
            st[j][i]=gcd(st[j][i-1],st[j+(1<<i-1)][i-1]);
        }
    }
    cdq(1,n);
    cout<<ans<<"\n";
    return 0;
}
```

---

## 作者：nbhs23a28 (赞：1)

一道绝妙的思维题，要求灵活运用 $\gcd$ 的性质。（以下均不计辗转相除法时间复杂度，不妨将之看作近似常数的玩意儿）

本题要求数组中任意区间 $\gcd$ 与长度的最大乘积。根据题意，我们很容易可以想到枚举区间的暴力模拟算法。为了增强它的可优化性，我们不妨在此直接考虑如何在 $O(1)$ 或 $O(\log n)$ 内求出区间 $\gcd$。注意到 $\gcd$ 的性质与 $\max$ 类似，可由区间合并产生，且这些区间可重合。于是我们很容易想到可以用处理 RMQ 问题手段线段树与 ST 表。这样，我们暂且得到了 $O(n^2)$（ST 表）或 $O(n^2\log n)$（线段树）的暴力算法了。

接下来考虑优化，由于本题 $n\le 10^5$，我们想到考虑带一堆 $\log$ 的算法。注意 $\gcd$ 的数学性质，当在数列中添加一个数时，整个数列的 $\gcd$ 单调不增，要么较原先不变，要么至少除以 $2$，进一步，当 $\gcd$ 减小，我们为找到更优解至少要使长度乘 $2$。那么，我们是否可以考虑枚举一层左端点，再进行整体类倍增+局部二分呢？！具体化地说，就是采用线段树二分或二分联系 ST 表，每次找到使一定 $\gcd$ 不变的最大下标，将答案更新后将长度跳至原来两倍（或更多）即可。

时间复杂度 $O(n\log^3 n)$（线段树，由于复杂度及常数较劣洛谷卡常可过）或 $O(n\log^2 n)$（ST 表）。

Code：（以下采用线段树实现）
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
long long n,a[100010],gcd[400010],_gcd,ans;
void build(int l,int r,int id)
{if(l==r) 
 {gcd[id]=a[l];
  return;
 }
 int mid=(l+r)>>1;
 build(l,mid,id*2);
 build(mid+1,r,id*2+1);
 gcd[id]=__gcd(gcd[id*2],gcd[id*2+1]);
}
void query(int l,int r,int id,int ll,int rr)
{if(l>=ll&&r<=rr)
 {if(_gcd==0) _gcd=gcd[id];
  else _gcd=__gcd(_gcd,gcd[id]);
  return;
 }
 if(l==r) return;
 int mid=(l+r)>>1;
 if(ll<=mid)
 query(l,mid,id*2,ll,rr);
 if(rr>mid)
 query(mid+1,r,id*2+1,ll,rr);
}
signed main()
{//freopen("gcd.in","r",stdin);
 //freopen("gcd.out","w",stdout);
 ios::sync_with_stdio(0);cin.tie(0);
 cin>>n;
 for(int i=1;i<=n;i++)	
 cin>>a[i];
 build(1,n,1);
 for(int i=1;i<=n;i++)
 {long long id=i,g;
  while(id<=n)
  {_gcd=0;
   query(1,n,1,i,id);
   g=_gcd;
   int l=id,r=n;
   while(l<r)
   {int mid=(l+r+1)>>1;
    _gcd=0;
    query(1,n,1,i,mid);
    if(_gcd==g) l=mid;
    else r=mid-1;
   }
   ans=max(ans,g*(l-i+1));
   _gcd=0;query(1,n,1,i,l+1);
   id=i+(l-i+1)*(g/_gcd); //这行卡常使原先超时的测试点->600+ms
  }
 }
 cout<<ans;
}

---


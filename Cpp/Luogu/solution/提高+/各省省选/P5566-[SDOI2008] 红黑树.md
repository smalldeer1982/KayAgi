# [SDOI2008] 红黑树

## 题目描述

红黑树是一类特殊的二叉搜索树，其中每个结点被染成红色或黑色。若将二叉搜索树结点中的空指针看作是指向一个空结点，则称这类空结点为二叉搜索树的前端结点。并规定所有前端结点的高度为 $-1$。

一棵红黑树是满足下面“红黑性质”的染色二叉搜索树：

1. 每个结点被染成红色或黑色；
2. 每个前端结点为黑色结点；
3. 任一红结点的子结点均为黑结点；
4. 在从任一结点到其子孙前端结点的所有路径上具有相同的黑结点数。

从红黑树中任一结点 $x$ 出发（不包括结点 $x$），到达一个前端结点的任意一条路径上的黑结点个数称为结点 $x$ 的黑高度，记作 $bh(x)$ 。红黑树的黑高度定义为其根结点的黑高度。

给定正整数 $N$，试设计一个算法，计算出在所有含有 $N$ 个结点的红黑树中，红色内结点个数的最小值和最大值。

## 说明/提示

$N \leq 5000$

## 样例 #1

### 输入

```
8```

### 输出

```
1
4```

# 题解

## 作者：WarningQAQ (赞：11)

##### 最近在刷平衡树，看到标题就进来了，没想到是个dp？？？看了看，发现可以贪心，于是就有了这篇题解。
## 分析：
因为红黑树本身的性质，所以我们可以通过画图来枚举所有情况：


------------
先把每一个节点看成黑色的，通过红黑树性质来把一些结点变成红色的。

+ $case1:$

如图：![](https://i.loli.net/2020/11/25/e5kCrigwFBtu4al.png)

最亏的一种情况，两个黑色节点没变出来一个红色节点。

+ $case2:$

如图：![](https://i.loli.net/2020/11/25/pKYH8oQVW4Fi2be.png)

三个黑色节点变成一个红色节点，有点浪费。

+ $case3:$

如图：![](https://i.loli.net/2020/11/25/sU29YWJrkIVzSLh.png)

此时四个黑色节点变成两个红色节点，黑色节点的利用率最大。


------------
所以，贪心就很明确了。

$\text{\large{code:}}$
```cpp
#include "cstdio"
int n, ans, k;
int main()
{
	scanf("%d", &n);
	k = n + 1;
	while (k > 1)
	{
		ans += k & 1;
		k >>= 1;
	}
	printf("%d\n", ans);
	k = n + 1;
	ans = 0;
	while (k > 1)
	{
		if (k == 2)
			ans++, k--;
		else if ((k & 3) == 1)
			ans += ((k >> 2) << 1) - 1, k >>= 2, k++;
		else if ((k & 3) == 2)
			ans += ((k >> 2) << 1), k >>= 2, k++;
		else if ((k & 3) == 3)
			ans += ((k >> 2) << 1) + 1, k >>= 2, k++;
		else
			ans += (k >> 1), k >>= 2;
	}
	printf("%d", ans);
	return 0;
}
```


------------
### 关于DP
自己想了一种方法，不过好像有亿点点慢。

以最小值为例：

用 $R_{(i,j)}$ 表示 $i$ 个结点，黑高度为 $j$ 的红根树中红色结点最小值；

$B_{(i,j)}$ 表示 $i$ 个结点，黑高度为 $j$ 的黑根树中红色结点最小值。

$\therefore R_{(i,j)}=\min\left({R_{(i,j)},B_{(k,j-1)}+B_{(i-k-1,j-1)}+1}\right)\quad(i\leq k\leq i-2)$；

$\therefore B_{(i,j)}=\min\left({B_{(k,j-1)},B_{(i-k-1,j-1)},R_{(k,j)}+R_{(i-k-1,j)},R_{(k,j)}+B_{(i-k-1,j-1)}}\right)\quad(i\leq k\leq i-2)$；


------------
##### 代码就不放了，贪心它不香吗？

[$blog$](https://www.cnblogs.com/nakiri-ayame-suki/)

---

## 作者：liuyi0905 (赞：7)

当初看到这道题，差点手打红黑树了。看了眼算法标签，原来是道 $\operatorname{dp}$，~~算法标签告诉我们一切~~。

#### 接下来进入正题：

先来考虑红色内结点的个数最小值。

记 $k=n+1$，只需计算将 $k$ 分解成二进制后 $1$ 的个数，就是在每个奇数层只多出一个红结点，这是红结点的最小值。

$\operatorname{code}$
```cpp
k=n+1;
while(k>1)ans+=k&1,k>>=1;
```
再来考虑红色内结点的个数最大值。

既然是 $\operatorname{dp}$，那得先找到最优策略。显然，用完美二叉树来实现是最优方案，每 $k$ 个子节点都能合出 $\frac{k}{2}$ 个红色节点。

但这时分了几种情况：
+ $k=2$，答案只能是 $1$，直接跳出循环。
+ $k\bmod4=0$，答案为 $\frac{k}{2}$，$k$ 再除以 $4$。
+ $k\bmod4=1$，答案为 $\lfloor\frac{k}{4}\rfloor\times2-1$，$k=\lfloor\frac{k}{4}\rfloor+1$。
+ $k\bmod4=2$，答案为 $\lfloor\frac{k}{4}\rfloor\times2$，$k=\lfloor\frac{k}{4}\rfloor+1$。
+ $k\bmod4=3$，答案为 $\lfloor\frac{k}{4}\rfloor\times2+1$，$k=\lfloor\frac{k}{4}\rfloor+1$。

$\operatorname{code}$
```cpp
k=n+1;
while(k-1)
	if(k==2)ans++,k--;
	else if(k%4){
		ans+=k/4*2;
		if(k%4==1)ans-=1;
		else if(k%4==3)ans+=1;
		k=k/4+1;
	}
	else ans+=k/2,k/=4;
```

---

## 作者：spdarkle (赞：3)

# [SDOI2008] 红黑树

## DP解法

设 $f[i,j,0/1]$ 表示在有 $i$ 个节点，黑高度为 $j$ ，当前树是红/黑根树的最小值(最大值同理)

则有：

$$f[i,j,0]=\min_{1\le k<i-1}\min_{1\le j \le 2\log_2 n}(f[i-k-1,j,1]+f[k,j,1])+1$$

$$f[i,j,1]=\min_{1\le k<i-1}\min_{1\le j \le 2\log_2 n}(f[i-k-1,j-1,0/1]+f[k,j-1,0/1])$$

最大值同理，只是将 $\min$ 换为 $\max$
说明：对于黑高度的限制可以自行百度红黑树的性质，这个复杂度是$O(n^2\log_2n)$,可以过
## 贪心解法

**引理1**：任意含有 $n$ 个节点的树必定含有 $n+1$ 个前端节点

*证明*  首先若树是一条链显然成立。我们考虑将这个树在某个节点处旋转过来，也即将链中某个节点作为新的节点，两边的链作为儿子节点，此时这个节点原来有的一个前端节点没了，但是旋转前链顶在旋转后便拥有了2个前端节点，以此类推归纳可证
![](https://cdn.luogu.com.cn/upload/image_hosting/q7ssdep4.png)


我们可以看作用 $n+1$ 个节点，两两合并成新的节点并拼在一起，最终合并出根节点，此时就启发我们探索合并过程中所产生的红节点的最少与最多的策略了

因为节点两两合并，我们考虑将黑点的合并抽象出来，考虑黑点合并的基本模型

1. 两两合并成一黑
2. 三个合并成一红两黑
3. 四个合并成两红一黑
![](https://cdn.luogu.com.cn/upload/image_hosting/xir45snb.png)

因为这三种情况包括了黑点产生和红点产生的所有情况(黑高相同且扩展1)，所以说我们只需要这三种情况就可以拼出其他情况（因为红黑树的性质4，会导致最底层一定是这三种之一，层层上推即可得证）

那么分析一下，很明显情况3用来求最大值，情况1用来求最小值
### 最小值
需要注意的是，为了黑高度的合法，我们必须一层一层的往上构造
那么先说求最小值，我们可以先用黑点数量除以二就等同于整体向上用情况1构造一层，前提条件是黑点数量是偶数，当黑点数量是奇数的时候，先拿出两个合并成一个红点，因为这样不会影响黑高，并且会使得点的数量重新变为偶数，再除以2，直到黑点数量为1

通过这个想法，我们可以进行优化，会发现，我们实际上的红点个数就是在不断除以二的过程中除到奇数的情况(1除外)，所以一个节点数量为$n$的红黑树，它的最小红节点数量就是$n+1$在2进制状态下1的个数减1
### 最大值
然后再来看最大值，想想，最优策略应该是什么，应该是一层层的用4个节点往上构造2层，不够4个节点的，如果只有1个，需要拿出1个4，构成"2+3"。否则就是"3"/"2"

那么此时我们应该对黑节点数量的情况分类讨论，假设现在有$k$个黑节点数量

1. $k\bmod 4 \equiv 0$ ，此时我们选择整体向上构造两层，那么答案累加上 $\frac{k}{2}$，黑点数量变为 $\frac{k}{4}$
2. $k\bmod 4 \equiv 1$ ，此时我们选择构成“2+3”此时答案应该是累加上： $\frac{k-3}{2}$,此时 $k$ 变成 $\frac{k-5}{4}+2=\frac{k+3}{4}$
3. $k\bmod 4 \equiv 2$ ，此时我们选择构造"2"，答案应该是累加上 $\frac{k-2}{2}$，然后 $k$ 变为 $\frac{k-2}{4}+1=\frac{k+2}{4}$
4. $k\bmod 4 \equiv 3$ ，此时我们选择构造"3"，答案应该是累加上 $\frac{k-3}{2}+1=\frac{k-1}{2}$ ，然后 $k$ 变成 $\frac{k-3}{4}+1=\frac{k+1}{4}$


特别的，当 $k=2$ 时，直接令 $k=1$ ,答案加上1，因为两黑自动合成红

一些在操作过程中可能比较迷惑的地方
1. 随时，我们留下的 $k$ 个点都是黑点，红点是我们选择以上三种基本构造模型的时候搞出来的

2. 我们合并过程中并不是强制要求剩下的 $k$ 个点一定在同一深度

3. 可能有人会说，如果我们把 $k\bmod 4 \equiv 1$ 的情况那个1直接不动会更好，因为它在同样贡献的情况下还多出来了黑色节点，这个错误的原因是我们必须使用上面三个模型进行合并，否则黑高有问题，导致这棵树建立出来有问题

注意：**代码中/2,/4必须使用">>"不能用除号**，原因是二者运算机制的区别，用/的只有60分
下面贴上代码

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int k,n,mn,mx;
int main(){
	scanf("%d",&n);
	k=n+1;
	while(k>1){
		if(k&1)mn++;
		k>>=1;
	}
	k=n+1;
	while(k>1){
		if(k==2)mx++,k--;
		else if(k%4==0){
			mx+=k>>1;
			k>>=2;
		}
		else if(k%4==1){
			mx+=(k-3)>>1;
			k=(k+3)>>2;
		}
		else if(k%4==2){
			mx+=(k-2)>>1;
			k=(k+2)>>2;
		}
		else {
			mx+=(k-1)>>1;
			k=(k+1)>>2;
		}
	}
	printf("%d\n%d",mn,mx);
}
```

---

## 作者：MaLX (赞：2)

过几天就要考 SDOI 了，于是来切 SDOI 少有的几道蓝题。

### 题目大意
> 给你一棵根节点任意颜色的红黑树（区别于正常的红黑树，根节点只能是黑色的），求最多或最少有几个红色节点。

### 题目分析

我们分两步考虑：

#### 求最少的红色节点

我们先去考虑一种特殊情况：如图，当 $n+1$ 为 $2$ 的正整数次幂是我们可以把树全部设为黑色的，不难证明这样是最优的。

![](https://cdn.luogu.com.cn/upload/image_hosting/96657fw0.png)

那如果不是上述情况呢？
我们会发现每加入一个红节点能且只能复制出一份一模一样的子树来（如图）：

![](https://cdn.luogu.com.cn/upload/image_hosting/9idkru0m.png)

这样一来我们会发现节点数正好增加了 $2$ 的正整数次幂，所以计算出要加入节点的数量，每次取二进制最高位的 $1$ ，便是最优解。

而且我们可以证明这样做的可行性和最优性：

因为红色节点的儿子节点不能成为红色节点，但是红色节点一定有黑色兄弟节点或前端兄弟节点，所以一定不会对红节点的下一次插入造成影响。而代替取最高位的方法的无疑是用更多的红节点去凑成想要达到的数目，肯定不是最优的，证毕；

``` c++
	dep=log2(n+1);m=n+1-(1<<dep);
	for(int i=0;i<dep;i++)
	minn+=(m>>i)&1;
```

#### 求最多的红色节点

我们先手动模拟一下深度为 $3$ 以内完全二叉树的最优解，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/wyvwar7c.png)

于是我们可以轻松得到对应节点数的解：

``` c++
	for(int i=0;i<dep;i++)
	siz[i+1]=(1<<i+1)-1-siz[i],
```

那么如果不是这样呢？

我们可以在最后一层新加红节点，如果父节点是红色的话，反转它祖宗节点的颜色，和原本黑色祖宗节点的红儿子的颜色，以保证最小限度的减小红色节点的损失，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/gqe74jaw.png)

最优性证明就很简单了，你从上一个完全二叉树更新到下一个完全二叉树，每个节点的颜色都会发生改变，只是迟早的问题。

考虑一种情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/buzvu79p.png)

我们发现左子树是一棵符合上文要求的完全二叉树，我们考虑优化，直接拿它更新答案，递归另一子树即可。

### 完整代码

细节比较多，调起来有亿点麻烦。

时空复杂度： $O(\log n)$

``` c++
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
void solve();
int n,m,minn,maxn,dep;
int siz[100];
int main(){solve();return 0;}
void solve(){
	scanf("%d",&n);
	dep=log2(n+1);m=n+1-(1<<dep);
	for(int i=0;i<dep;i++)
	siz[i+1]=(1<<i+1)-1-siz[i],//求完全二叉树的最多红节点
	minn+=(m>>i)&1;//求最少的红色节点
	maxn=siz[dep];
	for(int d=dep;m;d--){
		d&1?maxn-=1:maxn-=1;//换颜色
		if(m>=1<<d-1){//左子树是一棵符合上文要求的完全二叉树
			maxn+=siz[d]-siz[d-1];//换子树
			m-=1<<d-1;
			if(m)maxn+=(d^1)&1;//去除重复记录的黑节点
		}
		maxn+=(d^1)&1;//将下一层要遍历的节点的颜色还原
      	//去除相邻两项遍历的影响
	}
	printf("%d\n%d",minn,maxn);
}
```

省选 RP++ 。

---


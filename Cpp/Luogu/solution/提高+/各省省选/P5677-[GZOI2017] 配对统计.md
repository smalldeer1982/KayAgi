# [GZOI2017] 配对统计

## 题目背景

GZOI2017 D1T3

## 题目描述

给定 $n$ 个数 $a_1,\cdots,a_n$。

对于一组配对 $(x,y)$，若对于所有的 $i=1,2,\cdots,n$，满足 $|a_x-a_y|\le|a_x-a_i|(i\not=x)$，则称 $(x,y)$ 为一组好的配对（$|x|$ 表示 $x$ 的绝对值）。

给出若干询问，每次询问区间 $[l,r]$ 中含有多少组好的配对。

即，取 $x,y$（$l\le x,y\le r$ 且 $x\not=y$），问有多少组 $(x,y)$ 是好的配对。

## 说明/提示

**【样例解释】**

第一次询问好的配对有：$(1,2)(2,1)$；

第二次询问好的配对有：$(1,2)(2,1),(1,3)(3,1)$；

答案 $=2\times 1+4\times 2=10$。

**【数据约束】**

![](https://cdn.luogu.com.cn/upload/image_hosting/32ms79n8.png)

## 样例 #1

### 输入

```
3 2
2 1 3
1 2
1 3```

### 输出

```
10```

# 题解

## 作者：harryzhr (赞：102)

蒟蒻的第一篇题解

[题目传送门 洛谷P5677 [GZOI2017]配对统计](https://www.luogu.com.cn/problem/P5677)

#### 前情提要
此题要用到树状数组，没有学过的朋友可以先去做做[洛谷P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)

## 简要题意
一组数 $a_1,a_2,\cdots,a_n$

一组配对 $(x,y)$ 是好的配对（以后简称好对）当且仅当 $(x,y)$ 使得 $\left\vert a_x-a_y\right\vert$ 最小。

多组询问 $[l,r]$ 中好对的个数。

## 思路

### 寻找所有好对
首先我们来理解题意：

 $\left\vert a_x-a_y\right\vert \le \left\vert a_x-a_i\right\vert(i\ne x)$ ，就是说 $a_x$ 和 $a_y$ 对于 $a_x$ 是相差最小两个数，放到数轴上就是挨得最近的两个数。

所以就想到了排序，这样每个数可能的好对就是它和它两边的两个数。

举个栗子：
$$3,9,11,4,8,6$$
编号
$$1,2,3,4,5,6$$
排序过后就变成
$$3,4,6,8,9,11$$
对应的编号是
$$1,4,6,5,2,3$$
对于每一个数，判断一下它与它左右两边的数的差的绝对值：
- 如果相等，那么就是两个好的配对（左右两边都是好对），以6为例：

$\left\vert 6-4\right\vert = \left\vert 6-8\right\vert$ 6和4对应的好对为 $(6,4)$ ，6和8对应的好对为 $(6,5)$。

- 如果不相等，那么只有绝对值之差更小的一对，以4为例：

$\left\vert 4-3\right\vert < \left\vert 4-6\right\vert$ 只有4和3的好对 $(4,1)$ 。

- 当然两边的数只有唯一的一对

3和4对应 $(1,4)$ ，11和9对应 $(3,2)$。

注：为方便以后查询，统一把好对中出现位置较小的那个放在前面（就是说6和8对应的好对 $(6,5)$ 记为 $(5,6)$ ）。

要注意的是，如果一个配对 $(x,y)$ 是好对， $(y,x)$ 不一定是好对，如9和11： $(3,2)$ 是好对，而 $(2,3)$ 就不是。

数据约束中说到当$i \ne j,a_i \ne a_j$，即$a$中没有相同的元素，这样就保证了这个配对判断的正确性。

至此我们已经找到了所有的配对，时间复杂度 $O(n \log n)$ （瓶颈在排序）。

### 查询所有询问
每次询问都是区间查询，很容易想到树状数组（当然还有线段树），也就是查询所有左右端点都在$[l,r]$内的好对。

但是怎么查呢？

请仔细思考后再继续阅读。

------------


你会发现，如果把所有的好对都放进树状数组里不太好查。

那我们就不要一次性把所有的好对都放进去呗。

也就是说，对于每次查询，我们只把右端点在 $(0,r]$ 内的好对放进树状数组。

树状数组 $tree[i]$ 表示左端点在 $[i-\operatorname{lowbit}(i)+1 , i]$ 内的所有好对的的个数。

已经放入的好对个数，减去左端点在 $(0,l-1]$ 内的好对（也就是减去 $\operatorname{query}(l-1)$ ），就可以得到答案了。

再举栗子：

![](https://cdn.luogu.com.cn/upload/image_hosting/lrn8goud.png)

实线表示该好对在树状数组中，虚线表示该好对还未放入树状数组。

待查询的区间 $[L,R]$ 如图所示，此时只有 $q_1,q_2$ 两个好对在R左侧，再减去左端点在L左侧的 $q_1$ ，就得到 $[L,R]$ 内的好对数目：1个（ $q_2$ ）。

我们再将所有的好对和所有的询问，都按右端点从小到大排个序。

每次R右移，就将右端点小于等于R的所有好对，都加入到树状数组里，再减去左端点在 $(0,l-1]$ 内的好对个数就是答案。

![](https://cdn.luogu.com.cn/upload/image_hosting/13o0nhf9.png)

此时R右移， $q_3,q_4$ 被放入树状数组，再减去左端点在L左侧的 $q_1,q_3$ ，就得到 $[L,R]$ 内的好对数目：2个（$q_2,q_4$）。

遍历每个询问$O(n)$，每次查询$O(\log n)$,总时间复杂度$O(n \log n)$。

### 统计答案
因为答案的计算方法很~~奇葩~~特殊， $\sum\limits_{i=1}^mAns_i \times i$ 。

所以我们在给询问排序的时候也要记录下它原先的 $i$ （代码中为 $pos$ ）。

$Ans_i$ 的计算方法上文已经讲得很清楚了，这里不再多说。

整体时间复杂度 $O(n \log n)$ 。

#### 亲身经历告诉你们一定要开long long!!!

## 关于hack

新增的hack中 $n=1$，如果不特判的话会出现 $i+=lowbit(i)$ 而 $i=0$，从而死循环，下面的代码已经可以通过 hack


## 上代码：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#define ll long long
using namespace std;
int lowbit(int x){	return x & (-x);}
int n,m;
ll tree[300001];
void add(int pos){	//单点修改（每次只用加1） 
	while(pos<=n)	
		tree[pos]++,pos+=lowbit(pos);
}
int Query(int num){
	ll sum=0;
	while(num>0)
		sum+=tree[num],num-=lowbit(num);
	return sum;
}
//以上为树状数组的单点修改区间查询 
struct Num{	
	ll num;	int pos;	//原数组 
}a[300001];
bool cmp(Num a1,Num a2){return a1.num<a2.num;}	//结构体排序 
struct Pair{
	int l,r;			//好对 
}pairr[600002];
int paircnt=0;		//记录好对个数 
void add_pair(Num a1,Num a2){
	int l=min(a1.pos,a2.pos) , r=max(a1.pos,a2.pos);
		//为了方便查询，统一把好对中出现位置较小的那个放在前面 
	pairr[++paircnt].l=l;
	pairr[paircnt].r=r;
	return ;
}
bool cmpPair(Pair a1,Pair a2){		//对所有的好对按右端点从小到大排序 
	if(a1.r!=a2.r)	return a1.r<a2.r;
	else return a1.l<a2.l;
}
struct Questions{
	int l,r,pos;		//询问 
}question[300001];
bool cmpQestions(Questions a1,Questions a2){	//对所有的询问按右端点从小到大排序 
	if(a1.r!=a2.r)	return a1.r<a2.r;
	else return a1.l<a2.l;
}
int main(){
	scanf("%d %d",&n,&m);
    	if(n==1){puts("0");return 0;}//新增的hack
	for(int i=1 ; i<=n ; i++){
		scanf("%lld",&a[i].num);
		a[i].pos=i;			//记录下该数在原先序列里的位置，排完序后方便添加配对 
	}
	sort(a+1,a+1+n,cmp);	//排序 
	add_pair(a[1],a[2]);	//首位特殊处理
	add_pair(a[n],a[n-1]);	//末尾特殊处理
	for(int i=2 ; i<n ; i++){
		int ldif = a[i].num-a[i-1].num , rdif = a[i+1].num-a[i].num;	//左边的差 和 右边的差 
		if(ldif<rdif)		add_pair(a[i],a[i-1]);		//左边差更小，只有左边的一对 
		else if(ldif==rdif)	add_pair(a[i],a[i-1]),add_pair(a[i],a[i+1]);
														//两边差更小，有两对 
		else				add_pair(a[i],a[i+1]);		//右边差更小，只有右边的一对 
	}
	sort(pairr+1 , pairr+1+paircnt , cmpPair);	//对所有的好对按右端点从小到大排序
	for(int i=1;i<=m;i++){
		scanf("%d %d", &question[i].l ,&question[i].r);
		question[i].pos=i;
	}
	sort(question+1 , question+1+m , cmpQestions);//对所有的询问按右端点从小到大排序
	ll ans=0;		//ans为最终答案
	for(int i=1,j=1 ; i<=m ; i++){	//i为当前询问，j为当前待入树状数组的好对 
		while(pairr[j].r<=question[i].r && j<=paircnt){
			add(pairr[j].l);		//如果当前好对的右端点在当前询问的右端点内，就加入树状数组 
			j++;
		}
		ans+=1ll * question[i].pos * (j-1- Query(question[i].l-1) );	//计算答案 
	}
	printf("%lld",ans);	//输出 
	return 0;
}
```

---

## 作者：Konnyaku_LXZ (赞：21)

看完题目，我的第一反应就是去看数据范围。然后我发现了一个很重要的信息：对于任意的 $i \ne j$ ， $a_i \ne a_j$。换句话说，就是**保证所有的 $a_i$ 都不相同**。

这个信息能告诉我们什么呢？一个好的配对 $(x,y)$ 的定义，是 $|a_x-a_y|$ 要小于等于其他所有 $|a_x-a_i|(i \ne x)$ ，我们很自然地联想到将数组**排序**。排完序之后我们分类讨论。当 $a_x>a_y$ 时，$|a_x-a_y|=a_x-a_y$，只有让 $a_x-a_y$ 最小，$(x,y)$ 才有可能是一组好的配对，所以 $y$ 的取值只有可能是 $x-1$ ；若 $a_x<a_y$ ，同上可证， $y$ 的取值只有可能是 $x+1$ 。那么这两个取值是不是都行呢？我们还得比较 $a_x-a_{x-1}$ 和 $a_{x+1}-a_x$ 的值，若相等，则两个取值都行；若 $a_x-a_{x-1}>a_{x+1}-a_x$ ，则 $y=x+1$ ；若 $a_x-a_{x-1}<a_{x+1}-a_x$ ，则 $y=x-1$。

所以当  $x==1 || x==N$ 时， $y$ 的取值有且仅有一个；否则 $y$ **的取值最多有两个，最少有一个**。假设对于每一个  $x(x \ne 1$ && $ x \ne N)$， $y$ 的取值都有两个，那么最多有 $N * 2 -1$ 个好的配对，因为 $N \le 300000$ ，所以我们可以将所有的配对都预处理好，然后用一个数组存起来。

那么现在问题就是如何统计一个区间 $l,r$ 内好的配对的数量。如果每次都 $O(N)$ 统计的话，肯定会超时，所以我们考虑优化。我们希望如果区间之间有重合的话，重合的部分的好的配对的数量我们只算一次，因为这样可以节约很多时间。如何做到只算一次呢？我们想**维护一个有序的统计顺序**，即**将所有好的配对按较小的那个值从小到大排序，并且将给出的区间按左端点从小到大排序**。设排序后的区间的左端点分别为 $l_1,l_2,\cdots,l_M$，右端点分别为 $r_1,r_2,\cdots,r_M$ ，则对于任意的 $i<j$ ，有 $l_i<=l_j$ ，所以**如果一个好的配对 $(x,y)$ ，满足$l_j \le x$ ，则该好的配对对区间 $l_j,N$ 有贡献，也一定对区间 $l_i,N(i<j)$ 有贡献**。所以我们**从后往前**遍历每一个区间，每次都**从后往前**将所有对当前的 $l_i$ 到 $N$ 这个区间有贡献的好的配对加入，然后统计区间 $l_i,r_i$ 内的好的配对的数量并保存在 $ans$ 数组里，最后依题意数据结果即可。统计区间 $l_i,r_i$ 内的好的配对的数量可以用**树状数组**在 $logN$ 的复杂度内实现。

总的时间复杂度：$(N+M)logN$。

于是我们就可以愉快地通过这题了。

$Code:$
	
	#include<iostream>
	#include<cstdio>
	#include<cmath>
	#include<algorithm>
	#include<cstring>
	using namespace std;
	const int MAXN=3e5+50;
	typedef long long LL;
	typedef pair<LL,LL> P;//用于存储好的配对的结构体
	struct node1{//用于将输入数组排序的结构体 
		LL x;//值 
		LL id;//存对应的原数组的编号，为了统计好的配对 
	};
	struct node2{//用于将区间排序的结构体 
		LL l;//左端点 
		LL r;//右端点 
		LL id;//存对应的原区间的编号，为了计算答案 
	};
	node1 a[MAXN<<1];//存储输入数组 
	node2 b[MAXN<<1];//存储输入区间 
	P mix[MAXN<<1];//存储好的配对 
	LL N,M,l,r,sub[MAXN<<1],c[MAXN<<1],ans[MAXN<<1],h=0,Ans=0;//c为树状数组，ans为答案数组 
	bool cmp1(node1 a,node1 b){return a.x<b.x;}//用于给输入数组排序 
	bool cmp2(P a,P b){return a.first<b.first;}//用于给好的配对排序 
	bool cmp3(node2 a,node2 b){return a.l!=b.l?a.l<b.l:a.r<b.r;}//用于给区间排序 
	inline void add(node1 a,node1 b){//统计好的配对的函数 
		mix[++h].first=min(a.id,b.id);
		mix[h].second=max(a.id,b.id);
	}
	inline LL lowbit(LL x){return x&-x;}
	inline void change(LL c[],LL len,LL now,LL k){//单点修改 
		while(now<=len){
			c[now]+=k;
			now+=lowbit(now);
		}
	}
	inline LL query(LL c[],LL len,LL now){//区间查询 
		LL res=0;
		while(now){
			res+=c[now];
			now-=lowbit(now);
		}
		return res;
	}
	int main()
	{
		memset(c,0,sizeof(c));
		scanf("%lld%lld",&N,&M);
		for(int i=1;i<=N;i++) scanf("%lld",&a[i].x),a[i].id=i;
		sort(a+1,a+1+N,cmp1);//先将输入数组排序 
		add(a[2],a[1]);add(a[N],a[N-1]);//对于第一个和最后一个数据特殊处理 
		for(int i=2;i<N;i++){//对于其他数据，统计好的配对的数量并且保存对应的x,y
			if(abs(a[i].x-a[i-1].x)==abs(a[i+1].x-a[i].x)){//以下是好的配对的三种情况 
				add(a[i],a[i-1]);
				add(a[i+1],a[i]);
			}
			if(abs(a[i].x-a[i-1].x)<abs(a[i+1].x-a[i].x)) add(a[i],a[i-1]);
			if(abs(a[i].x-a[i-1].x)>abs(a[i+1].x-a[i].x)) add(a[i+1],a[i]);
	}
		sort(mix+1,mix+1+h,cmp2);//将好的配对排序
		for(int i=1;i<=M;i++) scanf("%lld%lld",&b[i].l,&b[i].r),b[i].id=i;
		sort(b+1,b+1+M,cmp3);//将区间排序 
		int now=h;//指针 
		for(int i=M;i>=1;i--){
			while(mix[now].first>=b[i].l){//将所有有贡献的好的配对加入 
				change(c,N,mix[now].second,1);
				now--;//指针左移 
			}
			ans[b[i].id]=query(c,N,b[i].r);//统计区间(l[i],r[i])内的好的配对的数量并保存进ans数组 
		}
		for(int i=1;i<=M;i++) Ans+=ans[i]*i;//计算答案 
		printf("%lld\n",Ans);
		return 0;
	}

---

## 作者：MeowScore (赞：19)

upd on 2022-2-15 发现一个细节笔误

跟同学一起做线段树的题，同学拿线段树秒切，我不会，所以写的主席树，调了半天才过，孩子快死了，趁还活着发篇题解纪念。

[传送门 qwq](https://www.luogu.com.cn/problem/P5677)

题解好像没有主席树诶。

题面说 $(x,y)$ 这个有序数对是好的匹配，需要满足所有的 $i=1,2…n$，$|a_x-a_y|\leq|a_x-a_i|$。其实就是要求 $|a_x-a_y|=min{|a_x-a_i|}$。（当然 $i≠x$)。对于每个 $x$，$min{|a_x-a_i|}$ 排个序就能处理出来了。我们定义数组 $c$，$c_i$ 表示 $min{|a_x-a_i|}$。排完序顺便离散，我用的 map，~~所以跑的奇慢~~。


当 $i≠j$ 时 $a_i≠a_j$ 是个很好的性质。所以对于每个位置 $x$，最多有两个数字能与之匹配成 $(x,y)$，那两个数字也就是 $a_x+c_x$ 和 $a_x-c_x$，对应的位置（也就是 $y$）也能算出来，注意 $a_x+c_x$ 和 $a_x-c_x$ 不一定都存在，需要用 map 判一下。对于每对好的匹配 $(x,y)$，我们将来在主席树上计算贡献的时候都贡献在 $max(x,y)$ 处。

接下来 vector 大法好！枚举所有的好的匹配（其实是枚举 $x$ 位置，$y$ 也容易得到），对于 $(x,y)$，我们在 $min(x,y)$ 这一维 push_back 一个 $max(x,y)$。

离线询问，按右端点升序排序。在处理询问的时候，当扫描到一个 $x$ 位置，我们把 vector 在 $x$ 这一维的数都取出来。当取出一个 $y$，我们基于上一个版本新建一个版本的主席树，并在 $y$ 位置加 $1$。对于一次询问 $l,r$，我们如果直接查询处理完 $r$ 位置后的主席树的 $[l,r]$ 区间和显然不行，如果直接算，我们得到了目前为止所有 $(x,y)$ 对数，其中 $max(x,y)\in[l,r]$，但不保证 $min(x,y)\in[l,r]$。我们要减掉的是 $min(x,y)<l$ 且 $max(x,y)\in[l,r]$ 的数对个数，即处理完第 $l-1$ 个位置后的主席树的 $[l,r]$ 区间和。注意每个位置可能放多个数，即产生多个主席树版本，要注意区分版本编号和“处理完一个位置后的版本号”。



细节非常的多。经过数小时的奋斗，@Liu_Kevin 几乎喜提最劣解……

看到讨论区说有个 $n=1$ 的 hack，我就特判了一下，之后发现好像我的代码不用判也可以过，就删掉了那一段。如果你的第二个子任务炸了，建议考虑这一情况。

代码，希望对你有帮助：

```
#include<bits/stdc++.h>
using namespace std;
int read(){
	int ss=0,ww=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')
			ww=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		ss=ss*10+ch-'0';
		ch=getchar();
	}
	return ss*ww;
}
int n,m;
const int N=300010;
int a[N],c[N];
map<int,int> P;
struct DAT{
	int num;
	int id;
}b[N];
struct qu{
	int x;
	int y;
	int id;
}g[N];
int cmp(DAT x,DAT y){
	return x.num<y.num;
}
int cmp2(qu x,qu y){
	return x.y<y.y;
}
struct ST{
	int ls;
	int rs;
	int dat;
}st[N*40];
int root[N*2],tot;
int v[N];
int edition;
int build(int l,int r){
	tot++;
	int p=tot;
	if(l==r)
		return p;
	int mid=(l+r)/2;
	st[p].ls=build(l,mid);
	st[p].rs=build(mid+1,r);
	return p;
}
int add(int p,int l,int r,int x){
	tot++;
	int q=tot;
	st[q]=st[p];
	if(l==r){
		st[q].dat++;
		return q;
	}
	int mid=(l+r)/2;
	if(mid>=x)
		st[q].ls=add(st[p].ls,l,mid,x);
	else
		st[q].rs=add(st[p].rs,mid+1,r,x);
	st[q].dat=st[st[q].ls].dat+st[st[q].rs].dat;
	return q;
}
int res;
void ask(int p,int l,int r,int x,int y){
	if(l>=x&&r<=y){
		res+=st[p].dat;
		return;
	}
	int mid=(l+r)/2;
	if(mid>=x)
		ask(st[p].ls,l,mid,x,y);
	if(mid+1<=y)
		ask(st[p].rs,mid+1,r,x,y);
}
long long Ans;
vector<int> vec[N];
signed main(){
	n=read();
	m=read();
	for(int i=1;i<=n;i++){
		a[i]=read();
		b[i].num=a[i];
		b[i].id=i;
	}
	sort(b+1,b+n+1,cmp);
	c[b[1].id]=b[2].num-b[1].num;
	c[b[n].id]=b[n].num-b[n-1].num;
	for(int i=2;i<n;i++)
		c[b[i].id]=min(b[i].num-b[i-1].num,b[i+1].num-b[i].num);
	for(int i=1;i<=n;i++)
		P[b[i].num]=i;
	for(int i=1;i<=n;i++){
		int x=b[i].num;
		int y=b[i].num+c[b[i].id];
		if(P.find(y)!=P.end())
			vec[min(b[P[y]].id,b[P[x]].id)].push_back(max(b[P[y]].id,b[P[x]].id));
		y=b[i].num-c[b[i].id];
		if(P.find(y)!=P.end())
			vec[min(b[P[y]].id,b[P[x]].id)].push_back(max(b[P[y]].id,b[P[x]].id));
	}
	for(int i=1;i<=m;i++){
		int x,y;
		x=read();
		y=read();
		g[i].x=x;
		g[i].y=y;
		g[i].id=i;
	}
	sort(g+1,g+m+1,cmp2);
	int la=1;
	root[0]=build(1,n);
	for(int i=1;i<=m;i++){
		for(int j=la;j<=g[i].y;j++){
			for(int k=0;k<vec[j].size();k++){
				edition++;
				root[edition]=add(root[edition-1],1,n,vec[j][k]);
			}
	 		v[j]=edition;
		}
		la=g[i].y+1;
		if(g[i].x==g[i].y)
			continue;
		int ans=0;
		res=0;
		ask(root[v[g[i].y]],1,n,g[i].x,g[i].y);
		ans+=res;
		res=0;
		ask(root[v[g[i].x-1]],1,n,g[i].x,g[i].y);
		ans-=res;
		Ans+=((long long)(ans)*(long long)(g[i].id));
	}
	cout<<Ans;
	return 0;
}
```

---

## 作者：TonyYin (赞：17)

## 题意

给定一个数列 $a_1, a_2, \cdots, a_n$.

定义在**有序**数对 $(x, y)$ 上的“**好对**”：对于 $a_x$，$y\in[1, x)\cup(x, n]$ 能使 $|a_x-a_y|$ 取最小值。

给定 $q\leq 3\times 10^5$ 组询问，每次询问一个区间 $[l, r]$ 中，有多少个好对。

题目求：每次询问的答案 $Ans_i$ 与询问编号 $i$ 的乘积的和，即：
$$
\sum_{i=1}^{m}Ans_i\times i
$$

##  分析

#### 关于匹配

任何一个好对 $(x, y)$，都满足 $|a_x-a_y|\leq |a_x-a_i|(i\neq x)$.

并且通过数据范围可以发现：$\forall i\neq j$ 都有 $a_i\neq a_j$，所以当 $x$ 固定时，确定 $y$ 的方法是非常自然的。

**将 $a$ 数组排序**，排序后的数组为 $b$，不妨设 $a_x$ 在 $b$ 中的下标为 $t$，那么 **$a_y$ 在 $b$ 中的下标只可能为 $t-1$ 和 $t+1$.**

具体地：

- 如果 $|b_t-b_{t-1}|<|b_{t+1}-b_{t}|$，也就是 $b_{t-1}$ 距离 $b_t$ 更近，那么 $a_y$ 在 $b$ 中的下标为 $t-1$；
- 如果 $|b_t-b_{t-1}|>|b_{t+1}-b_{t}|$，此时 $b_{t+1}$ 距离 $b_t$ 最近，$a_y$ 在 $b$ 中的下标为 $t+1$；
- 如果 $|b_t-b_{t-1}|=|b_{t+1}-b_{t}|$，$a_y$ 在 $b$ 中的下标为 $t-1$ 或 $t+1$.

总之，我们可以非常容易地在 $O(n\log n)$ 复杂度内，**对于每个 $x$，找到能与其构成好的配对的 $y$.**

#### 关于询问

##### 思路

现在的问题是如何统计答案。

因为题目只要求输出所有询问的和，于是想到将询问**离线**下来。对于每个好对，统计有多少个询问完全覆盖了它。这个好对**对于最终答案的贡献**就是：**所有覆盖它的询问的编号之和**。

对于这个问题，容易想到将所有询问排序，之后用树状数组维护，具体方法：

##### 方法

从左到右枚举 $[1, n]$，假设枚举到了 $i$. 

对于 $i$，我们已经计算过与其匹配的数，在 $a$ 中的下标 $y$，如果 $y>i$，那么**所有左端点 $l\leq i$ 且右端点 $r\geq y$ 的询问都能包含这个好对。**

再考虑答案的形式 $\sum_{i=1}^{m}Ans_i\times i$，我们现在要求：左端点 $l\leq i$ 且右端点 $r\geq y$ 的询问的编号和，使用树状数组维护。

于是考虑将询问按照左端点排序，在枚举到 $i$ 的时候，把所有左端点 $l\leq i$ 的询问加入到树状数组中，**把树状数组的位置 $r$ 的权值加上这个询问的编号 $num$.**

这样，$(i, y)$ 的贡献就等价于：树状数组中 $[y, n]$ 的区间和。



如果与 $i$ 匹配的 $y<i$，在上面的方法中并没有包含到。所以我们再反向枚举一遍 $i$，方法相同。将右端点 $r\geq i$ 的询问加入树状数组，每次的贡献为树状数组中 $[1, y]$ 的区间和。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int MAXN = 3e5 + 10;
const int inf = 0x3f3f3f3f3f3f3f3f;
int c[MAXN];
int n, m;
int lowbit(int x) {
	return x & (-x);
}
void update(int x, int k) {
	for(int i = x; i <= n; i += lowbit(i)) {
		c[i] += k;
	}
}
int query(int x) {
	int ret = 0;
	for(int i = x; i > 0; i -= lowbit(i)) {
		ret += c[i];
	}
	return ret;
}
int query2(int x) {
	return query(n) - query(x - 1);
}
int a[MAXN];
struct Node{int num, val;} b[MAXN];
bool cmp(Node A, Node B) {
	return A.val <= B.val;
}
struct Query{int val, l, r;} q[MAXN];
bool cmp2(Query A, Query B) {
	return A.r >= B.r;
}
bool cmp3(Query A, Query B) {
	return A.l <= B.l;
}
int rk[MAXN];
signed main() {
	scanf("%lld%lld", &n, &m);
	for(int i = 1; i <= n; i++) {
		scanf("%lld", &a[i]);
		b[i].val = a[i]; b[i].num = i;
	}
	sort(b + 1, b + n + 1, cmp);
	for(int i = 1; i <= n; i++) {
		rk[b[i].num] = i;
	}
	for(int i = 1; i <= m; i++)  {
		q[i].val = i;
		scanf("%lld%lld", &q[i].l, &q[i].r);
	}
	sort(q + 1, q + m + 1, cmp2);
	int ans = 0;
	b[0].val = -inf; b[n + 1].val = inf;
	for(int i = n, j = 1; i >= 1; i--) {
		while(q[j].r >= i && j <= m) {
			update(q[j].l, q[j].val);
			j++;
		}
        //下面六行：判断 t-1 和 t+1，哪个距离 t 更近，能与 t 构成好的匹配。
		if(b[rk[i]].val - b[rk[i] - 1].val <= b[rk[i] + 1].val - b[rk[i]].val) {
			if(b[rk[i] - 1].num < i) ans += query(b[rk[i] - 1].num);
		}
		if(b[rk[i]].val - b[rk[i] - 1].val >= b[rk[i] + 1].val - b[rk[i]].val) {
			if(b[rk[i] + 1].num < i) ans += query(b[rk[i] + 1].num);
		}
	}
	sort(q + 1, q + m + 1, cmp3);
	memset(c, 0, sizeof(c));
	for(int i = 1, j = 1; i <= n; i++) {
		while(q[j].l <= i && j <= m) {
			update(q[j].r, q[j].val);
			j++;
		}
		if(b[rk[i]].val - b[rk[i] - 1].val <= b[rk[i] + 1].val - b[rk[i]].val) {
			if(b[rk[i] - 1].num > i) ans += query2(b[rk[i] - 1].num);
		}
		if(b[rk[i]].val - b[rk[i] - 1].val >= b[rk[i] + 1].val - b[rk[i]].val) {
			if(b[rk[i] + 1].num > i) ans += query2(b[rk[i] + 1].num);
		}
	}
	cout << ans << endl;
	return 0;
}
```



---

## 作者：ListenSnow (赞：10)

## 题意

给定 $n$ 个正整数，对于一组匹配 $(x,y)$，如果对于任意的 $i=1,2,⋯,n$，满足 $|a_x-a_y| \leq |a_x-a_i|(i \ne x)$。那么就称 $(x,y)$ 为一组好的匹配。

给出 $m$ 询问，每次询问区间 $[l,r]$ 中好的匹配的数量。

记第 $i$ 次询问的答案为 $ans_i$，那么最终只需输出 $\sum_{i=1}^{m} ans_i*i$。

## 思路

首先观察题目中对于“好的匹配”的定义，可以发现。对于一个数 $a_x$ ，能和它组成好的匹配的数 $a_y$ 一定满足 $|a_x-a_y|$ 的值最小，也就是 $a_y$ 是与 $a_x$ **相差最小的数**。于是就可以想到**排序**，将原数组排序后，对于任意的 $i=2,3,⋯,i-2,i-1$。能和 $a_i$ 组成好的匹配的数一定在 $a_{i-1}$ 和 $a_{i+1}$ 中（$a[1]$ 和 $a[n]$ 需要特判） 。于是就可以在 $O(n \log n)$ 的时间内求出所有的好的匹配。

然而对于题目中的查询操作。有一个很 navie 的想法：用树状数组 $c[x]$ 维护区间 $[1,x]$ 内的配对数量，对于每一个 $(x,y)$（设 $x<y$ 的），直接 $ add(y,1) $。在查询的时候输出 $query(r)-query(l-1)$ 。

可惜这样的想法是错误的，因为在相减的时候只减去了 $x<l,y<l$ 时的不合法配对，并没有减去 $x<l,y>l$ 时的不合法配对。

注意到本题中**并未要求支持**修改操作，于是可以考虑**离线做法**。

上述错误做法出现的问题是并未减去 $x<l,y>l$ 时的不合法配对。如果将 $add(y,1)$ 改成 $add(x,1)$，可以发现当 $r=n$ 时，$query(r)-query(l-1)$ 得到的答案就是正确的了，因为此时的 $query(l-1)$ 中只限制了 $x<l$，所以 $x<l,y \geq l$ 的不合法配对也被计算在其中。也就可以在被减去了。

但是一旦当 $r < n$ 时，这样的做法又是错误的，因为此时 $query(r)$ 中的配对的 $y$ 可以比 $r$ 还大。相减时就无法减去这些不合法匹配。

那如果在树状数组中**不记录**这些不合法匹配呢？

于是可以想到先将配对按照 $y$ 的大小进行排序。再将所有的询问**离线**，先记录下来，再按照右端点 $r$ 的大小进行排序。在求解每一次询问时，都只把 $y \leq r$ 的配对记录到树状数组中。这样就避免了 $r >y$ 的不合法匹配。

关于记录到树状数组中的信息，因为我们想要的是所有满足 $x \geq l$ 的匹配数量，所以可以直接在树状数组中记录 $n-x$，这样就可以 $query(n-l)$ 得到所有匹配的数量。

最后，别忘了开 **long long**。

## code：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
#define LL long long
const int N=3e5+10;
const int M=3e5+10;
int n,m,c[N];
LL ans;
struct node{
	int val,id;
	bool operator <(const node &t)const{
		return val<t.val;
	}
}a[N];
struct match{
	int l,r;
	bool operator <(const match &t)const{
	    if(r!=t.r)return r<t.r;
	    return l<t.l;
	}
}p[N<<1];//除了最大和最小的数，极端情况下每个数都能有两个好的匹配，所以数组大小要*2 
int tot=0;
struct quest{
	int l,r,id;
	bool operator <(const quest &t)const{
	    if(r!=t.r)return r<t.r;
	    return l<t.l;
	}
}q[M];
int max(int a,int b){return a>b?a:b;}
int min(int a,int b){return a<b?a:b;}
int lowbit(int x){return x&(-x);}
void updata(int x,int k)
{
	for(int i=x;i<=n;i+=lowbit(i)) c[i]+=k;
}
int query(int x)
{
	int res=0;
	for(int i=x;i;i-=lowbit(i)) res+=c[i];
	return res;
}
void add(int a,int b)
{
	p[++tot].l=min(a,b);
	p[tot].r=max(a,b);
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%d",&a[i].val),a[i].id=i;
    sort(a+1,a+n+1);
    for(int i=2;i<n;i++)
    {
    	int res1=a[i].val-a[i-1].val,res2=a[i+1].val-a[i].val;
    	if(res1<res2) add(a[i].id,a[i-1].id);
    	else if(res1>res2) add(a[i].id,a[i+1].id);
    	else add(a[i].id,a[i-1].id),add(a[i].id,a[i+1].id);//当两边都相等时当然就都是好的匹配 
	}
	add(a[1].id,a[2].id);
	add(a[n-1].id,a[n].id);//特判 
	sort(p+1,p+tot+1);
	for(int i=1;i<=m;i++) scanf("%d%d",&q[i].l,&q[i].r),q[i].id=i;//别忘了记录是第i个询问的答案还要*i 
	sort(q+1,q+m+1);
	int now=1;
	for(int i=1;i<=m;i++)
	{
		while(now<=tot&&p[now].r<=q[i].r) updata(n-p[now++].l,1);
		ans+=(LL)q[i].id*query(n-q[i].l);
	}
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：DPair (赞：9)

大家好，我非常不想写树状数组，所以我用莫队过了这道题。

## 【思路】
首先我们意识到一个数只可能与其前驱或后继形成“好的配对”。并且，若前驱或者后继中有一个与原数的 **差的绝对值** 比另一个更大的话，那么这个数也不能与原数形成“好的配对”。

考虑排序 + 预处理搞出能与一个数形成“好的配对”的位置。

那么显然，若一个在询问区间内的数，能与其形成 “好的配对” 的数也在这个区间里，那么就可以产生贡献。

然后我们就可以考虑莫队了。

对于每一个在区间内的数，记录与其能 **形成** “好的配对”的 **位置** 的贡献，然后把在位置当前区间内的贡献加到答案里面即可。

即对于每一个 $l\le x\le r$ ，设能与其产生 “好的配对” 的位置为 $y$ ，那么 $cnt[y] ++$ 。

最后查询 $\sum_{i=l}^r cnt[i]$ 即可。

这个东西显然可以用莫队处理。

移动指针的时候一方面修改 “区间端点” 对 $cnt$ 数组产生的贡献，另一方面修改 “区间改变” 对答案产生的影响。

然后就做完了。

## 【代码】
```cpp
#include <bits/stdc++.h>
using namespace std;
#define getchar() printf("I am a cheater!I AK IOI!%c", 10)
typedef pair <int, int> pi;
typedef long long LL;
template <typename T>
inline void read(T &x){
    x = 0;int fu = 1;
    char c = getchar();
    while(c > 57 || c < 48){
        if(c == 45) fu = -1;
        c = getchar();
    }
    while(c <= 57 && c >= 48){
        x = (x << 3) + (x << 1) + c - 48;
        c = getchar();
    }
    x *= fu;
}
template <typename T>
inline void fprint(T x){
    if(x < 0) putchar(45), x = -x;
    if(x > 9) fprint(x / 10);
    putchar(x % 10 + 48);
}
template <typename T>
inline void fprint(T x, char ch){
    fprint(x);putchar(ch);
}
inline char next_char(){
    char ch = getchar();
    while(ch == 9 || ch == 10 || ch == 32) ch = getchar();
    return ch;
}
int n, m;
#define MAXN 300005
#define block 547
pi s[MAXN];
int a[MAXN], bel[MAXN];
int L[MAXN], R[MAXN];
int cnt[MAXN];
LL ans, res;
struct Quest{
    int l, r, id;
    inline bool operator < (const Quest &tmp) const{
        return (bel[l] ^ bel[tmp.l]) ?(l < tmp.l) : ((bel[l] & 1)? r < tmp.r : r > tmp.r);
    }
}q[MAXN];

int main(){
    read(n);read(m);
    for (register int i = 1;i <= n;i ++){
        read(a[i]);
        s[i] = make_pair(a[i], i);
        bel[i] = (i - 1) / block + 1;
    }
    sort(s + 1, s + n + 1);
    s[0].second = 0;s[n + 1].second = n + 1;
    for (register int i = 1;i <= n;i ++){
        L[s[i].second] = s[i - 1].second;
        R[s[i].second] = s[i + 1].second;
        if(s[i].first - s[i - 1].first > s[i + 1].first - s[i].first && s[i + 1].second <= n) L[s[i].second] = 0;
        if(s[i].first - s[i - 1].first < s[i + 1].first - s[i].first && s[i - 1].second) R[s[i].second] = n + 1;
    }
    //以上是预处理，以下是莫队
    for (register int i = 1;i <= m;i ++){
        read(q[i].l);read(q[i].r);
        q[i].id = i;
    }
    sort(q + 1, q + m + 1);
    int l = q[1].l, r = l - 1;
    for (register int i = 1;i <= m;i ++){
        while(l > q[i].l){
            l --;
            ans += cnt[l];
            cnt[L[l]] ++;
            cnt[R[l]] ++;
            if(L[l] >= l && L[l] <= r) ans ++;
            if(R[l] >= l && R[l] <= r) ans ++;
        }
        while(r < q[i].r){
            r ++;
            ans += cnt[r];
            cnt[L[r]] ++;
            cnt[R[r]] ++;
            if(L[r] >= l && L[r] <= r) ans ++;
            if(R[r] >= l && R[r] <= r) ans ++;
        }
        while(r > q[i].r){
            cnt[L[r]] --;
            cnt[R[r]] --;
            if(L[r] >= l && L[r] <= r) ans --;
            if(R[r] >= l && R[r] <= r) ans --;
            ans -= cnt[r];
            r --;
        }
        while(l < q[i].l){
            cnt[L[l]] --;
            cnt[R[l]] --;
            if(L[l] >= l && L[l] <= r) ans --;
            if(R[l] >= l && R[l] <= r) ans --;
            ans -= cnt[l];
            l ++;
        }
        res = res + ans * q[i].id;
    }
    fprint(res, 10);
}
```

---

## 作者：Para (赞：5)

### [[GZOI2017]配对统计](https://www.luogu.com.cn/problem/P5677)

### 思路
因为对于任意不相同的 $i$ 和 $j$，$a_i$ 不等于 $a_j$，所以对于任意一个 $a_x$，与其配对的数至多有两个。

我们可以处理出每一组配对 $(x,y)$，将其按照 $x$ 按升序排列。因为题目中只有询问，将询问离线按 $l$ 升序排列。

可以发现，在处理每一对询问 $[l, r]$ 时，只有 $x >= l$ 的配对对答案有影响。建一棵 $BIT$，对询问从大到小扫描一遍，当存在一个未统计的 $x$ 大于等于当前的 $l$ 时，将 $y$ 加入 $BIT$。最后每次询问的答案就是 $sum (r)$。

### code

```cpp
#include <queue>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
struct st1 {
	long long x, id;
}a[500005];

long long tot = 0;
struct st2 {
	long long l, r;
}b[500005];

struct st3 {
	long long l, r, id;
}c[500005];
bool cmp1 (st1 x, st1 y) {
	return x.x < y.x;
}
bool cmp2 (st2 x, st2 y) {
	return x.l < y.l;
}
bool cmp3 (st3 x, st3 y) {
	return x.l < y.l;
}
void get_in (long long x, long long y) {
	b[++tot].l = min (x, y), b[tot].r = max (x, y);
}
long long n, m;
long long bit[500005];
long long lowbit (long long x) {
	return x & (-x);
}
long long sum (long long x) {
	long long ans = 0;
	for (; x; x -= lowbit (x)) ans += bit[x];
	return ans;
}
void add (long long x, long long y) {
	for (; x <= n; x += lowbit (x)) bit[x] += y;
}
long long ans[500005];
int main () {
	scanf ("%lld %lld", &n, &m);
	for (long long i = 1; i <= n; i++) {
		scanf ("%lld", &a[i].x);
		a[i].id = i;
	}
	sort (a + 1, a + 1 + n, cmp1);
	get_in (a[1].id, a[2].id);
	get_in (a[n-1].id, a[n].id);
	for (long long i = 2; i < n; i++) {
		if (a[i].x - a[i-1].x <= a[i+1].x - a[i].x) get_in (a[i].id, a[i-1].id);
		if (a[i].x - a[i-1].x >= a[i+1].x - a[i].x) get_in (a[i].id, a[i+1].id);
	}//统计配对
	for (long long i = 1; i <= m; i++) {
		scanf ("%lld %lld", &c[i].l, &c[i].r);
		c[i].id = i;
	}
	sort (b + 1, b + 1 + tot, cmp2);
	sort (c + 1, c + 1 + m, cmp3);//排序
	for (long long i = m; i >= 1; i--) {
		while (b[tot].l >= c[i].l) {
			add (b[tot].r, 1);
			tot--;
		}
		ans[c[i].id] = sum (c[i].r);
	}
	long long cnt = 0;
	for (long long i = 1; i <= m; i++) cnt += (ans[i] * i);
	printf ("%lld", cnt);
	return 0;
}
```

---

## 作者：Flanksy (赞：4)

### 树状数组

------------

题意：给出一个序列 $a$，多组询问求区间 $[l,r]$ 内的好的配对数，$(x,y)$ 是好的配对等价于在将序列所有元素在数轴上标记后，$a_y$ 是数轴上与 $a_x$ 最接近的元素之一，且 $(x,y)$ 配对有序。

观察数据范围发现需要离散序列 $a$，序列中不存在相同元素为解题提供了一些便利：不需去重，可以使用 ```unordered_map<int,int>``` 标记元素的位置。

另一方面可以发现 **$(x,y)$ 是好的配对不代表 $(y,x)$ 也是好的配对，如对于序列 ```1 3 4```，$(1,2)$ 为好的配对，但 $(2,1)$ 不是**。

将好的配对 $(x,y)$ 的贡献统计在树状数组中位置 $\min(x,y)$ 处，对询问按照右端点排序，对于询问 $[l,r]$，答案为已经统计的好的配对数量减去位置 $l$ 以前的好的配对数量。

每个数至多被加入一次，加入操作和统计操作的时间复杂度同为单次 $O(\log n)$，总体时间复杂度 $O(n\log n)$。

实现略有难度，此为笔者第一次写出的[代码](https://www.luogu.com.cn/paste/tu5rcg3f)，可简化的部分极多。remake 后打算发一篇题解，通过设置极值可以省略对 $n=1$ 等情况的特判。

```cpp
#include<bits/stdc++.h>
using namespace std;
constexpr int inf=1050000000;
struct Question{int l,r,i;}u[300005];
int n,m,pos,a[300005],c[300005],p[300005];
unordered_map<int,int> s;//s[x]:数x在序列a中的下标
long long ans,all;
bool on[300005];//on[i]:p[i]是否加入序列
bool cmp(const Question &x,const Question &y){return x.r<y.r;}
inline bool check(int x,bool y){return y ? p[x]-p[x-1]<=p[x+1]-p[x]:p[x]-p[x-1]>=p[x+1]-p[x];}
void add(int x){while(x<=n) c[x]++,x+=x&-x;}
int sum(int x){int ret=0;while(x) ret+=c[x],x-=x&-x;return ret;}
inline void update(int x,int y){all++,add(min(s[p[x]],s[p[y]]));}
void deal(int x){
	int it=lower_bound(p+1,p+n+1,x)-p;
	on[it]=1;//使用check判定好对是否成立,使用update更新数据
	if(on[it-1]&&check(it-1,0)) update(it,it-1);
	if(on[it+1]&&check(it+1,1)) update(it,it+1);
	if(on[it-1]&&check(it,1)) update(it,it-1);
	if(on[it+1]&&check(it,0)) update(it,it+1);
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]),p[i]=a[i],s[a[i]]=i;
	for(int i=1;i<=m;i++) scanf("%d%d",&u[i].l,&u[i].r),u[i].i=i;
	sort(p+1,p+n+1),sort(u+1,u+m+1,cmp);
	p[0]=-inf,p[n+1]=inf<<1;//左右赋极值
	for(int i=1;i<=m;i++){
		while(pos<u[i].r) deal(a[++pos]);
		ans+=(all-sum(u[i].l-1))*u[i].i;
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：vectorwyx (赞：4)

$(x,y)$ 是一组配对的前提是 $(a_x,a_y)$ 在值域上是相邻的。于是我们可以先把 $a$ 数组排序，找出所有可能的配对 $(x,y)$。如果把每个配对看做二维平面上的点，那么查询 $[l,r]$ 就等价于查询横坐标和纵坐标均介于 $[l,r]$ 的点的数量，这是经典的二维数点问题。使用扫描线即可轻松解决。注意特判 $n=1$ 的情况。

（附赠另一道经典例题：[HH 的项链](https://www.luogu.com.cn/problem/P1972)）

代码如下：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<vector>
#include<queue>
#include<map>
#define pii pair<int,int> 
#define mk make_pair
#define pb push_back
#define sml(x,y) (x=min(x,y))
#define big(x,y) (x=max(x,y))
#define lbit(x) (x&(-x))
#define ll long long
#define db double
#define fo(i,x,y) for(register int i=x;i<=y;++i)
#define go(i,x,y) for(register int i=x;i>=y;--i)
using namespace std;
inline int read(){int x=0,fh=1; char ch=getchar(); while(!isdigit(ch)){if(ch=='-') fh=-1; ch=getchar();} while(isdigit(ch)){x=(x<<1)+(x<<3)+ch-'0'; ch=getchar();} return x*fh;}
inline void out(int *a,int l,int r){fo(i,l,r) printf("%d ",*(a+i));puts("");}

//扫描线水题 
const int N=3e5+5;
int a[N],od[N],n,m,ans[N],tr[N],cnt;
bool cmp(int x,int y){return a[x]<a[y];} 
/*struct Point{
	int x,y;
	Point(){}
	Point(int l,int r){x=l,y=r;} 
};*/
pii point[N<<1];
struct Line{
	int x,u,d,op,num;
	Line(){}
	Line(int a1,int a2,int a3,int a4,int a5){x=a1,u=a2,d=a3,op=a4,num=a5;} 
	bool operator<(const Line&X)const{return x<X.x;} 
}A[N<<1];

inline void update(int x){
	while(x<=n){
		tr[x]++;
		x+=lbit(x);
	}
}
inline int ask(int x){
	int ret=0;
	while(x){
		ret+=tr[x];
		x-=lbit(x);
	}
	return ret;
}

int main(){
	cin>>n>>m;
	if(n==1) return puts("0"),0;
	fo(i,1,n) a[i]=read(),od[i]=i;
	sort(od+1,od+1+n,cmp);
	point[++cnt]=mk(od[1],od[2]);
	point[++cnt]=mk(od[n],od[n-1]);
	fo(i,2,n-1){
		int x=a[od[i]]-a[od[i-1]],y=a[od[i+1]]-a[od[i]];
		if(x<=y) point[++cnt]=mk(od[i],od[i-1]);
		if(y<=x) point[++cnt]=mk(od[i],od[i+1]);
	}
	fo(i,1,m){
		int l=read(),r=read();
		A[i]=Line(l-1,r,l,-1,i);
		A[i+m]=Line(r,r,l,1,i);
	}
	sort(point+1,point+1+cnt);
	sort(A+1,A+1+2*m);
	int id=1;
	fo(i,1,2*m){
		while(id<=cnt&&point[id].first<=A[i].x) update(point[id++].second);
		ans[A[i].num]+=A[i].op*(ask(A[i].u)-ask(A[i].d-1));
	}
	ll Ans=0;
	fo(i,1,m) Ans+=ans[i]*(ll)i;
	cout<<Ans;
	return 0;
}
/*
-------------------------------------------------
*/
```


---

## 作者：苏联小渣 (赞：3)

**本题可以做到强制在线**，但好像还没有在线询问的题解。

首先我们来分析一下问题，题目的式子的意思就是坐标轴上有 $n$ 个点，要找到两个 $x,y$ 满足 $y$ 是所有点里面离 $x$ 最近的。

这个 $y$ 显然只有 $1$ 或 $2$ 个（如果 $n=1$ 就没有），所以考虑预处理出来，可以用二分实现。对于每一个 $i$，记这两个点分别是 $a_i$ 和 $b_i$。

现在思考我们要求什么，$i \in [l,r]$，找到 $a_i \in [l,r]$ 的 $(i,a_i)$ 的数量以及 $b_i \in [l,r]$ 的 $(i,b_i)$ 数量。

这个东西可以用莫队转移，~~不过我没调出来~~。

思考复杂度更优的线段树。这个线段树要和下标、权值有关，普通的肯定不行，如果是树套树的话复杂度不能接受。由于没有修改，发现主席树可以解决这个问题。

思考主席树的本质，维护 $n$ 棵权值线段树，到了每一个点先继承上一个点，再修改一条链的权值信息，因此时空复杂度都是 $O(n \log n)$。而对于这题，到了每一个点，就在权值树上修改包含了 $a_i$ 和 $b_i$ 的那条链，让每个结点的 tag 加一。对于询问：

- $i \in [l,r]$，就是对第 $r$ 棵线段树和第 $l-1$ 棵线段树作差。

- $a_i,b_i\in [l,r]$，就是在主席树上查询一个区间和。

所以这题就解决了，复杂度 $O(n \log n)$。不过实现上有一些细节，否则会被卡常。比如说把 $a_i$ 和 $b_i$ 放到一颗线段树上解决，不要开两颗，否则查询的时候常数会很大。

### Code：

```c++
#include <bits/stdc++.h>
using namespace std;
int n, m, cnt, l, r, p[300010], a[300010], f[300010][2];
long long ans, now;
map <int, int> mp;
map <int, int> :: iterator it;
inline int read(){
	int s=0, w=1; char ch=getchar();
	while (ch < '0' || ch > '9'){if (ch == '-') w = -1; ch = getchar();}
	while (ch >= '0' && ch <= '9'){s = (s<<3) + (s<<1) + (ch^48); ch = getchar();}
	return s * w;
}
struct segment{
	int num=0, t[600010], L[15000010], R[15000010], d[15000010];
	inline void modify(int &p, int lst, int l, int r, int x){
		p = ++num, L[p] = L[lst], R[p] = R[lst], d[p] = d[lst];
		d[p] ++;
		if (l == r) return ;
		int mid = l + r >> 1;
		if (x <= mid) modify(L[p], L[lst], l, mid, x);
		else modify(R[p], R[lst], mid+1, r, x);
	}
	inline int query(int p, int lst, int l, int r, int x, int y){
		if (x <= l && r <= y) return d[p] - d[lst];
		int mid = l + r >> 1, ret = 0;
		if (x <= mid) ret += query(L[p], L[lst], l, mid, x, y);
		if (y > mid) ret += query(R[p], R[lst], mid+1, r, x, y);
		return ret;
	}
}S, T;
int main(){
	n = read(), m = read();
	for (int i=1; i<=n; i++){
		a[i] = read();
		mp[a[i]] = i;
	}
	for (int i=1; i<=n; i++){
		it = mp.upper_bound(a[i]);
		if (it != mp.end()) f[i][0] = it->second;
		it = mp.lower_bound(a[i]);
		if (it != mp.begin()){
			it --;
			f[i][1] = it->second;
			if (f[i][0] == 0) continue;
			int fx = a[f[i][0]] - a[i], fy = a[i] - a[f[i][1]];
			if (fx > fy) f[i][0] = 0;
			if (fx < fy) f[i][1] = 0;
		}
	}
	for (it=mp.begin(); it!=mp.end(); it++){
		it->second = ++cnt;
	}
	for (int i=1; i<=n; i++){
		a[i] = mp[a[i]];
	}
	for (int i=1; i<=n; i++){
		if (f[i][0]) S.modify(S.t[i*2-1], S.t[i*2-2], 1, n, f[i][0]);
		else S.t[i*2-1] = S.t[i*2-2];
		if (f[i][1]) S.modify(S.t[i*2], S.t[i*2-1], 1, n, f[i][1]);
		else S.t[i*2] = S.t[i*2-1];
	}
	for (int i=1; i<=m; i++){
		l = read(), r = read();
		now = S.query(S.t[r*2], S.t[(l-1)*2], 1, n, l, r);
		ans += 1LL * i * now;
	}
	printf ("%lld\n", ans);
	return 0;
}
```

---

## 作者：Harry27182 (赞：3)

### 简要题意

给定一组数 $a_1,a_2...a_n$ ，多次询问区间 $[l,r]$ 中满足 $|a_x-a_y|$ 最小的 $x,y$ 地个数。

### 解题思路

显然，对于每一个数 $a_x$ ，可能与 $a_x$ 组成好对的数只有排序后在 $a_x$ 左右两边的数。所以我们先排序（之后提到的序列为排序后的序列）。但是，我们发现，这两个数不一定都能和 $a_x$ 组成好对。$a_x$只能与最近的那一个组成好对（如果一样近都可以组成好对）。然后我们可以预处理出来所有的好对，下面考虑如何解决询问。

对于区间 $[l,r]$ 中的好对，可以用右端点在 $[1,r]$ 的好对与左端点在 $[1,l-1]$ 中的好对相减得到。所以我们可以用树状数组处理出好对个数。（不会树状数组的点[这里](https://www.luogu.com.cn/problem/P3374)）我们发现一次全部插入所有的好对实现有些麻烦，所以我们可以先对询问进行排序，然后动态插入好对。

具体实现细节见代码。

### AC 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,ans,cnt,tree[6000005];
struct num
{
	int val,pla;
}a[300005];//数据
struct node
{
	int l,r;
}c[600005];//好对
struct que
{
	int l,r,pla;
}q[300005];//询问
bool cmp(num a,num b)
{
	if(a.val==b.val)return a.pla<b.pla;
	return a.val<b.val;
}//对数据进行排序
bool cmp1(node a,node b)
{
	if(a.r==b.r)return a.l<b.l;
	return a.r<b.r;
}//对好对进行排序
bool cmp2(que a,que b)
{
	if(a.r==b.r)return a.l<b.l;
	return a.r<b.r;
}//对询问进行排序
void addpair(num a,num b)
{
	int l=min(a.pla,b.pla),r=max(a.pla,b.pla);
	cnt++;
	c[cnt].l=l;
	c[cnt].r=r;
}//添加好对
int lowbit(int x)
{
	return x&-x;
}
void add(int x)
{
	while(x<=n)
	{
		tree[x]++;
		x+=lowbit(x);
	}
}
int sum(int x)
{
	int ans=0;
	while(x!=0)
	{
		ans+=tree[x];
		x-=lowbit(x);
	}
	return ans;
}//树状数组标准三件套
signed main()
{
	scanf("%lld%lld",&n,&m);
	if(n==1){printf("0");return 0;}//特判n==1
	for(int i=1;i<=n;i++)
	{
		scanf("%lld",&a[i].val);
		a[i].pla=i;
	}
	sort(a+1,a+n+1,cmp);
	addpair(a[1],a[2]);
	addpair(a[n],a[n-1]);//第一组和最后一组需要特判
	for(int i=2;i<n;i++)
    {
    	int l=a[i].val-a[i-1].val,r=a[i+1].val-a[i].val;
    	if(l<=r)addpair(a[i],a[i-1]);
    	if(l>=r)addpair(a[i],a[i+1]);
    } 
    sort(c+1,c+cnt+1,cmp1);
    for(int i=1;i<=m;i++)
    {
    	scanf("%lld%lld",&q[i].l,&q[i].r);
    	q[i].pla=i;
    }
    sort(q+1,q+m+1,cmp2);
    int now=1;
    for(int i=1;i<=m;i++)
    {
    	while(c[now].r<=q[i].r&&now<=cnt)
    	{
    		add(c[now].l);
    		now++;
    	}//由于好对和询问是排好序的，所以可以通过now指针来维护到了哪个好对
    	ans+=q[i].pla*(now-1-sum(q[i].l-1));//now因为在前面多加了1，所以要减去1
    }
    printf("%lld",ans);
	return 0;
}
```


---

## 作者：养熊人 (赞：2)

### 题意简述


------------

给定一个数列，求一段区间内好配对的个数。好配对定义为若对于所有的 $i=1,2,\cdots,n$，满足 $|a_x-a_y|\le|a_x-a_i|(i\not=x)$，则称 $(x,y)$ 为一组好的配对（$|x|$ 表示 $x$ 的绝对值）。

### 做法


------------

- 对于一个数能与它形成好配对的一定是和它差值最小的数。顺着这个思路我们可以考虑将数列排序，排序后对于一个数字能与其匹配的只有它左边或右边的数，对于 $1$ 和 $n$ 的情况进行特判，如果两边差值相等就都是好配对。

- 现在问题就转化为给定一些配对找在 $l$ ，$r$ 这段区间中有几个好配对，对于这个问题，由于题目并未强制在线，我们可以考虑将询问离线下来。此时我们可以考虑把它转化为二维数点问题，对于每个配对用对应下标的最小值和最大值作为一个点，将每个询问拆成四个询问，$cdq$ 分治解决即可。

### 代码


------------

```cpp
#include<bits/stdc++.h>
#define F(i,x,n) for(int i=x;i<=n;++i)
#define _F(i,x,n) for(int i=x;i>=n;--i)
#define int long long
using namespace std;

inline int read(){
	int s=0;char c=getchar();bool flag=0;
	while(!isdigit(c))flag|=(c=='-'),c=getchar();
	while(isdigit(c))s=(s<<3)+(s<<1)+(c^48),c=getchar();
	return flag?-s:s; 
}

const int N=4e5+5;

struct node{
	int op,l,r,w,id;
	bool operator < (const node&p)const{
		return l==p.l?op<p.op:l<p.l;
	}
}q[N<<2],tem[N<<2];

struct node2{
	int v,id;
	bool operator < (const node2&p)const{
		return v<p.v;
	}
}a[N];

int c[N],res[N];
int n,m,tot;

void cdq(int l,int r){
	if(l==r)return;
	int mid=l+r>>1;
	cdq(l,mid),cdq(mid+1,r);
	int i=l,j=mid+1,o=l,cnt=0;
	while(i<=mid&&j<=r){
		if(q[i].r<=q[j].r){//先修改后询问
			if(!q[i].op)cnt++;
			tem[o++]=q[i++];
		}
		else{
			if(q[j].op)res[q[j].id]+=q[j].w*cnt;
			tem[o++]=q[j++];
		}
	}
	while(i<=mid)tem[o++]=q[i++];
	while(j<=r){
		if(q[j].op)res[q[j].id]+=q[j].w*cnt;
		tem[o++]=q[j++];
	}
	F(k,l,r)q[k]=tem[k];
}

signed main(){
	n=read(),m=read();
	F(i,1,n)a[i].v=read(),a[i].id=i;
	sort(a+1,a+1+n);
	F(i,1,n){//寻找好配对，注意对于每个点x要小于y插入。 
		if(i==1)q[++tot]=node{0,min(a[i].id,a[i+1].id),max(a[i].id,a[i+1].id),0,0};//特判i==1的情况
		else if(i==n)q[++tot]=node{0,min(a[i].id,a[i-1].id),max(a[i].id,a[i-1].id),0,0};//特判i==2的情况
		else{
			if(a[i].v-a[i-1].v>a[i+1].v-a[i].v)q[++tot]=node{0,min(a[i].id,a[i+1].id),max(a[i].id,a[i+1].id),0,0};
			else if(a[i].v-a[i-1].v<a[i+1].v-a[i].v)q[++tot]=node{0,min(a[i].id,a[i-1].id),max(a[i].id,a[i-1].id),0,0};
			else q[++tot]=node{0,min(a[i].id,a[i-1].id),max(a[i].id,a[i-1].id),0,0},q[++tot]=node{0,min(a[i].id,a[i+1].id),max(a[i].id,a[i+1].id),0,0};
		}
	}
	F(i,1,m){//将询问拆成4个询问计算
		int l=read(),r=read();
		q[++tot]=node{1,r,r,1,i};
		q[++tot]=node{1,l-1,l-1,1,i};
		q[++tot]=node{1,l-1,r,-1,i};
		q[++tot]=node{1,r,l-1,-1,i};
	}
	sort(q+1,q+1+tot);
	cdq(1,tot);
	int ans=0;
	F(i,1,m)ans+=res[i]*i;//统计答案
	cout<<ans<<'\n';
	return 0;
}
```

---

## 作者：彭天宇 (赞：2)

# 审题
[题面](https://www.luogu.com.cn/problem/P5677)

给定了一个序列a，要求求出序列中的数对(x,y)，使所有i(1<=i<=n&&i!=x)都满足abs(a[x]-a[y])<=abs(a[x]-a[i])。

其实就是使abs(a[x]-a[y])最小，那么显然排序并比较与x相邻的两个数就可以找出所有配对了。

# 思考

怎么求呢？

这一道题很好地运用了树状数组的一个功能：经过排序后，用插入顺序限制第一关键字（l），用下标限制第二关键字（r）。

我们求出所有配对以后，按照l升序排序，同时将询问按照l升序排序，发现：当询问的l从右向左推进时，l左边的数从对答案没有影响到有影响，并且一旦产生影响，以后都会有影响（此后x一直大于等于询问的l），所以将配对的右端点y加入树状数组，以后每一次询问，只要直接查询树状数组中<=r位置的配对数即为所求。（此时插入顺序使得满足l<=x，树状数组使满足r>=y）。

# 代码

```cpp
#include<bits/stdc++.h>
#define int long long
//这里图个省事，不然转化较烦
using namespace std;
const int N=1000010;
int n,m,tot;
int tree[N],ans[N];
//tree：树状数组，ans：如题意所示
struct shuzu{int num,place;}sz[N];
//给定的数，place是排序前的位置，插入配对用的
struct ask{int l,r,place;}a[N];
//询问，place用于ans统计
struct peidui{int l,r;}pd[N];
//固定配对
bool cmp1(shuzu x,shuzu y){return x.num<y.num;}
bool cmp2(ask x,ask y){return x.l<y.l;}
bool cmp3(peidui x,peidui y){return x.l<y.l;}
int lowbit(int x){return x&-x;}
void add(int x,int y){
	while(x<=tot){
		tree[x]+=y;
		x+=lowbit(x);
	}
}
int get(int x){
	int tmp=0;
	while(x){
		tmp+=tree[x];
		x-=lowbit(x);
	}
	return tmp;
}
//基本操作略
signed main(){
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%lld",&sz[i].num);
		sz[i].place=i;
	}
	sort(sz+1,sz+n+1,cmp1);
	sz[0].num=sz[n+1].num=1<<30;
	//不能和0号以及n+1号配对
	for(int i=1;i<=n;i++){
		if(abs(sz[i].num-sz[i-1].num)==abs(sz[i].num-sz[i+1].num)){
			pd[++tot].l=min(sz[i].place,sz[i-1].place);
			pd[tot].r=max(sz[i].place,sz[i-1].place);
			pd[++tot].l=min(sz[i].place,sz[i+1].place);
			pd[tot].r=max(sz[i].place,sz[i+1].place);
		}
		if(abs(sz[i].num-sz[i-1].num)<abs(sz[i].num-sz[i+1].num)){
			pd[++tot].l=min(sz[i].place,sz[i-1].place);
			pd[tot].r=max(sz[i].place,sz[i-1].place);
		}
		if(abs(sz[i].num-sz[i-1].num)>abs(sz[i].num-sz[i+1].num)){
			pd[++tot].l=min(sz[i].place,sz[i+1].place);
			pd[tot].r=max(sz[i].place,sz[i+1].place);
		}
		//分类讨论找出配对
	}
//	for(int i=1;i<=tot;i++)cout<<pd[i].l<<" "<<pd[i].r<<endl;
	sort(pd+1,pd+tot+1,cmp3);
	//这里排序之后使l升序，从后向前插入时就限制了l的范围
	for(int i=1;i<=m;i++){
		scanf("%lld%lld",&a[i].l,&a[i].r);
		a[i].place=i;
	}
	sort(a+1,a+m+1,cmp2);
	int tmp=tot;
	for(int i=m;i>=1;i--){
		while(pd[tmp].l>=a[i].l){
			add(pd[tmp].r,1);
			tmp--;
		}
		//从大到小（从右向左）插入，保持l单调
		ans[a[i].place]=get(a[i].r);
	}
	int last=0;
	for(int i=1;i<=m;i++)last+=ans[i]*i;
//	for(int i=1;i<=m;i++)cout<<ans[i]<<endl;
	printf("%lld\n",last);
	return 0;
}

```

### 注意细节哦！
比如数据大小和配对的边界（0和n+1）
# 关联
类似题目也有不少，比如
[P1972HH的项链](https://www.luogu.com.cn/problem/P1972)
[P1908逆序对](https://www.luogu.com.cn/problem/P1908)

---

## 作者：Arghariza (赞：1)

换了 $3$ 种做法……

考虑到对于一个 $x\in[1,n]$，使得 $|a_x-a_y|\le |a_x-a_i|$ 的 $y$ 不超过 $2$ 个，因为把 $a_i$ 看成在数轴上重新排布的点列，$x$ 固定，$y$ 不是取左边就是取右边，如果左右距离相同就两个都有。

所以合法的 $(x,y)$ 对数不超过 $2n$，题目即给出最多 $2n$ 个 $(x_i,y_i)$，求 $x,y$ 均在 $l,r$ 内的数对的个数。

然后这东西显然可以用树套树在线维护。把 $(x,y)$ 当成平面点对，每次查询 $x,y\in[l,r]$ 的矩形区域内点对个数。

我写了一个树状数组套线段树，然后 MLE on #9 #10。

竟然卡空间，太离谱了/ll

既然题目不要求在线，我们使用离线做法。

考虑到这玩意就是个二维数点，那我们对行做一个前缀和，把每个询问拆成 $(r,l,r)-(l-1,l,r)$ 的形式。形如 $(a,l,r)$ 表示求第 $1$ 到第 $a$ 行 $l$ 到 $r$ 的和。这东西用树状数组扫描线维护是容易的，按行扫描然后树状数组维护列的信息即可。

时间复杂度 $O(n\log n)$，空间 $O(n)$。最大的点比树套树快 $10$ 倍左右，这是好的。

代码，简单的。

```cpp
#include <bits/stdc++.h>
#define int long long
namespace mystd {
	inline int read() {
	    char c = getchar();
	    int x = 0, f = 1;
	    while (c < '0' || c > '9') f = (c == '-') ? -1 : f, c = getchar();
	    while (c >= '0' && c <= '9') x = (x << 1) + (x << 3) + c - '0', c = getchar();
	    return x * f;
	}
	inline void write(int x) {
	    if (x < 0) x = ~(x - 1), putchar('-');
	    if (x > 9) write(x / 10);
	    putchar(x % 10 + '0');
	}
}
using namespace std;
using namespace mystd;

const int maxn = 3e5 + 300;
struct node { int vl, id, ps[2]; } a[maxn];
struct qry { int op, x, l, r, id; } q[maxn << 1];
int n, m, cnt, tr[maxn], ans[maxn];
vector<int> g[maxn];

int lowbit(int x) { return x & (-x); }
void modify(int x) { for (int i = x; i <= n; i += lowbit(i)) tr[i]++; }
int query(int x) { int res = 0; for (int i = x; i; i -= lowbit(i)) res += tr[i]; return res; }

signed main() {
	n = read(), m = read();
	for (int i = 1; i <= n; i++) a[i].vl = read(), a[i].id = i;
	sort(a + 1, a + n + 1, [](node x, node y) { return x.vl < y.vl; });
	a[1].ps[0] = a[2].id, a[n].ps[0] = a[n - 1].id;
	for (int i = 2; i <= n - 1; i++) {
		if (a[i].vl - a[i - 1].vl == a[i + 1].vl - a[i].vl) a[i].ps[0] = a[i - 1].id, a[i].ps[1] = a[i + 1].id;
		else if (a[i].vl - a[i - 1].vl < a[i + 1].vl - a[i].vl) a[i].ps[0] = a[i - 1].id;
		else a[i].ps[0] = a[i + 1].id;
	} 
	sort(a + 1, a + n + 1, [](node x, node y) { return x.id < y.id; });
	for (int i = 1; i <= n; i++) for (int k = 0; k <= 1 && a[i].ps[k]; k++) g[i].push_back(a[i].ps[k]);
	for (int i = 1; i <= m; i++) {
		int l = read(), r = read();
		q[++cnt] = (qry) { -1, l - 1, l, r, i };
		q[++cnt] = (qry) { 1, r, l, r, i };
	}
	sort(q + 1, q + cnt + 1, [](qry x, qry y) { return x.x < y.x; });
	for (int i = 1, c = 1; i <= cnt; i++) {
		while (c <= q[i].x) {
			for (int k : g[c]) modify(k);
			c++;
		}
		ans[q[i].id] += q[i].op * (query(q[i].r) - query(q[i].l - 1));
	}
	int res = 0;
	for (int i = 1; i <= m; i++) res += i * ans[i];
	write(res);
	return 0;
}

```

---

## 作者：luckydrawbox (赞：1)

提供两种与众不同的做法。

[$\text{Link}$](https://www.luogu.com.cn/problem/P5677)

## 题意

若在整个数列中距离 $a_x$ 最近的数**包含** $a_y$，则称 $(x,y)$ 是好的配对（为了方便叙述，本文中认为 $a_x$ 配对了 $a_y$，$a_y$ 被 $a_x$ 配对了）。多组询问，每次询问区间 $[l,r]$ 中有多少组好的配对。

## 分析

首先可以注意到，若 $(x,y)$ 是好的配对，则 $(y,x)$ 不一定是，手动模拟即可明白。

其次题目中保证 $i\neq j$ 时，$a_i\neq a_j$，所以猜测正解与值域有关，但是 $1\le a_i\le 10^9$ 这个范围令人十分不爽，于是我们考虑把它离散化掉：$1\le a_i\le n$ 且当 $i\neq j$ 时，$a_i\neq a_j$。

这个时候可以发现一个有意思的性质：对于 $a_x$，能被他配对的 $a_y$ **只能**为 $a_x-1$ 或 $a_x+1$ 或二者均可。

又因为没有修改操作，于是我们可以预处理：

- $e$ 数组，$e_{a_i}=i$。
- $fl$ 数组，$fl_{a_x}$ 表示小于 $a_x$ 且**能被** $a_x$ 配对的数 $a_y$，没有则为 $0$。
- $ffl$ 数组，$ffl_{a_x}$ 表示小于 $a_x$ 且**能配对** $a_x$ 的数 $a_y$，没有则为 $0$。
- $fr$ 数组，$fr_{a_x}$ 表示大于 $a_x$ 且**能被** $a_x$ 配对的数 $a_y$，没有则为 $0$。
- $ffr$ 数组，$ffr_{a_x}$ 表示大于 $a_x$ 且**能配对** $a_x$ 的数 $a_y$，没有则为 $0$。

```cpp
for(int i=1;i<=n;i++){//b数组是离散化前的a数组
	if(a[i]==n||(a[i]>1&&b[a[i]]-b[a[i]-1]<=b[a[i]+1]-b[a[i]])){
		fl[a[i]]=a[i]-1;
		ffr[a[i]-1]=a[i];
	}
	if(a[i]==1||(a[i]<n&&b[a[i]]-b[a[i]-1]>=b[a[i]+1]-b[a[i]])){
		fr[a[i]]=a[i]+1;
		ffl[a[i]+1]=a[i];
	}
}
```

然后开一个数组 $f_x$ 表示 $x$ 是否在当前状态下存在，接下来就可以很快地进行**插入和删除**一个数了。

- 若要插入一个数 $a_x$，只需要判断可能与其配对的数 $fl_{a_x},ffl_{a_x},fr_{a_x},ffr_{a_x}$ 是否存在即可，把存在的数量加入到答案里。
- 若要删除一个数 $a_x$，只需要判断可能与其配对的数 $fl_{a_x},ffl_{a_x},fr_{a_x},ffr_{a_x}$ 是否存在即可，把存在的数量从答案里减去。

这为接下来两种做法的实现奠定了基础。

### 莫队

既然我们掌握了快速插入和删除一个数的方法，那么只需要把询问离线，再套莫队板子即可。

然而最后一个点 TLE 了，要加上玄学的奇偶性排序优化才可以过。

### 树状数组

莫队这么压线的做法肯定不是正解。

于是考虑从题目本身出发。

首先，看到求区间某种东西的个数时，我总是立刻有一个平凡而大胆的想法：

“既然要求 $[l,r]$，那么先求出前缀和 $[1,r]$ 和 $[1,l-1]$ 再相减不就行了么！”

想法很美好，然而现实很残酷。

因为这样做漏减了左右值分别在 $[1,l-1]$ 和 $[l,r]$ 的好的配对，于是开始思考：怎样求出它呢？

其实，我们可以把一个好的配对 $(x,y)$ 认为是一个区间 $[x,y]$（假设是 $x<y$ 的情况），那么上面要求的那个值就相当于求所有包含 $l-1$ 的区间 $[x,y-1]$ 的个数（假定当前只加入了 $a_1\sim a_r$），也就是使 $l-1$ 不是区间右端点的包含 $l-1$ 的区间的个数，这样保证了这些区间都横跨 $[1,l-1]$ 和 $[l,r]$。

这样我们只要写某种数据结构存下当前状态左右值分别在 $[1,l-1]$ 和 $[l,r]$ 的好的配对，每次我们加入一个配对 $(x,y)$ 时，只要把 $[x,y-1]$ 的每个数增加 $1$ 即可，不难想到运用包含**差分**思想的树状数组来解决这个问题。

## 代码

### 莫队

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
long long read(){
	long long x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
const int N=4e5+10;
int n,m,len;
ll a[N],b[N],cnt,ans;
int fl[N],fr[N],f[N],ffl[N],ffr[N];
struct asdf{
	int l,r,id;
}d[N];
bool cmp(asdf x,asdf y){
	return (x.l/len<y.l/len||(x.l/len==y.l/len&&((x.l/len)&1?x.r<y.r:x.r>y.r)));
}
void add(int x){
	f[x]=1;
	cnt+=f[fl[x]]+f[fr[x]]+f[ffl[x]]+f[ffr[x]];
}
void del(int x){
	f[x]=0;
	cnt-=f[fl[x]]+f[fr[x]]+f[ffl[x]]+f[ffr[x]];
}
int main(){
	n=read();m=read();
	len=sqrt(m);
	for(int i=1;i<=n;i++)
		b[i]=a[i]=read();
	sort(b+1,b+n+1);
	for(int i=1;i<=n;i++)
		a[i]=lower_bound(b+1,b+n+1,a[i])-b;
	for(int i=1;i<=n;i++){
		if(a[i]==n||(a[i]>1&&b[a[i]]-b[a[i]-1]<=b[a[i]+1]-b[a[i]])){
			fl[a[i]]=a[i]-1;
			ffr[a[i]-1]=a[i];
		}
		if(a[i]==1||(a[i]<n&&b[a[i]]-b[a[i]-1]>=b[a[i]+1]-b[a[i]])){
			fr[a[i]]=a[i]+1;
			ffl[a[i]+1]=a[i];
		}
	}
	for(int i=1;i<=m;i++){
		d[i].l=read();
		d[i].r=read();
		d[i].id=i;
	}
	sort(d+1,d+m+1,cmp);
	int ql=1,qr=0;
	for(int i=1;i<=m;i++){
		while(ql>d[i].l) add(a[--ql]);
		while(qr<d[i].r) add(a[++qr]);
		while(ql<d[i].l) del(a[ql++]);
		while(qr>d[i].r) del(a[qr--]);
		ans+=cnt*d[i].id;
	}
	cout<<ans<<endl;
	return 0;
}
```

### 树状数组

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
long long read(){
	long long x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
const int N=4e5+10;
int n,m;
ll a[N],b[N],cnt,ans,sum[N],c[N],e[N];
int fl[N],fr[N],f[N],ffl[N],ffr[N];
struct asdf{
	int l,r,id;
}d[N];
bool cmp(asdf x,asdf y){
	return x.r<y.r;
}
void Add(int x,int v){
	for(;x<=n;x+=x&-x)
		c[x]+=v;
}
ll ask(int x){
	ll ans=0;
	for(;x;x-=x&-x)
		ans+=c[x];
	return ans;
}
void add(int x){
	f[a[x]]=1;
	if(f[fl[a[x]]]){
		sum[x]++;
		Add(e[fl[a[x]]],1);
		Add(x,-1);
	}
	if(f[fr[a[x]]]){
		sum[x]++;
		Add(e[fr[a[x]]],1);
		Add(x,-1);
	}
	if(f[ffl[a[x]]]){
		sum[x]++;
		Add(e[ffl[a[x]]],1);
		Add(x,-1);
	}
	if(f[ffr[a[x]]]){
		sum[x]++;
		Add(e[ffr[a[x]]],1);
		Add(x,-1);
	}
}
int main(){
	n=read();m=read();
	for(int i=1;i<=n;i++)
		b[i]=a[i]=read();
	sort(b+1,b+n+1);
	for(int i=1;i<=n;i++){
		a[i]=lower_bound(b+1,b+n+1,a[i])-b;
		e[a[i]]=i;
	}
	for(int i=1;i<=n;i++){
		if(a[i]==n||(a[i]>1&&b[a[i]]-b[a[i]-1]<=b[a[i]+1]-b[a[i]])){
			fl[a[i]]=a[i]-1;
			ffr[a[i]-1]=a[i];
		}
		if(a[i]==1||(a[i]<n&&b[a[i]]-b[a[i]-1]>=b[a[i]+1]-b[a[i]])){
			fr[a[i]]=a[i]+1;
			ffl[a[i]+1]=a[i];
		}
	}
	for(int i=1;i<=m;i++){
		d[i].l=read();
		d[i].r=read();
		d[i].id=i;
	}
	sort(d+1,d+m+1,cmp);
	int q=0;
	for(int i=1;i<=m;i++){
		while(q<d[i].r){
			sum[q+1]=sum[q];
			q++;
			add(q);
		}
		ans+=(sum[d[i].r]-sum[d[i].l-1]-ask(d[i].l-1))*d[i].id;
	}
	cout<<ans<<endl;
	return 0;
}
```


---

## 作者：CPPfive (赞：1)

## 题目分析

我们发现：一个好的配对相当于一个区间（你可能会发现一个配对是有序的，但是这不影响我们将它转化成区间），一次查询就相当于查询有多少个区间被包含在查询的区间内。每个数作为一个好的配对中的 $x$ 最多有 $2$ 个配对，即两个区间，因此区间个数是 $N$ 这个数量级的。

预处理配对的时候只需要将数组排一次序，然后与一个数配对的数一定与它相邻，所以可以 $\mathcal{O}(N\log{N})$ 预处理出来。然后之后的查询可以将预处理好的配对对应的区间和查询的区间分别按照右端点排序。

之后查询的过程可以使用线段树（或者树状数组）维护，这里就不多介绍了。

最后是几点注意事项：
- 答案需要开 **long long**！

- 一定要注意边界条件！不然会顺利地被 **hack** 掉！

## 代码
```cpp
//洛谷P5677 

#include <bits/stdc++.h>
using namespace std;
#define lson (rt<<1)
#define rson (rt<<1|1)
typedef long long LL;
const int MAXN=300050;
int val[MAXN<<2];
int N,M,cnt,now=1;
LL ans;
struct query{
	int l,r,id;
	bool operator < (const query& o) const{
		return r<o.r;
	}
}Q[MAXN];
struct sect{
	int l,r;
	bool operator<(const sect& o) const{
		return r<o.r;
	}
}S[MAXN<<1];
struct num{
	int a,id;
	bool operator <(const num& o)const{
		return a<o.a;
	} 
}_a[MAXN];

//线段树部分，实际上树状数组更方便 
void pushup(int rt){val[rt]=val[lson]+val[rson];}
void update(int rt,int l,int r,int idx){
	if(l==r){
		++val[rt];return;
	}
	int mid=(l+r)>>1;
	if(idx>mid) update(rson,mid+1,r,idx);
	else update(lson,l,mid,idx);
	pushup(rt);
}
int query(int rt,int l,int r,int idx){
	if(l==r) return val[rt];
	int mid=(l+r)>>1;
	if(idx<=mid) return val[rson]+query(lson,l,mid,idx);
	else return query(rson,mid+1,r,idx);
}

int main()
{
	scanf("%d%d",&N,&M);
	for(int i=1;i<=N;++i) scanf("%d",&_a[i].a),_a[i].id=i;
	sort(_a+1,_a+N+1);
	
	//加上这一行后这个程序就不会被 n=1 的情况hack！ 
	if(N!=1){
		S[++cnt].l=min(_a[1].id,_a[2].id),S[cnt].r=max(_a[1].id,_a[2].id);
		S[++cnt].l=min(_a[N-1].id,_a[N].id),S[cnt].r=max(_a[N-1].id,_a[N].id);
	}
	for(int i=2;i<N;++i){
		int delta1=_a[i].a-_a[i-1].a,delta2=_a[i+1].a-_a[i].a;
		if(delta1==delta2){
			S[++cnt].l=min(_a[i].id,_a[i-1].id),S[cnt].r=max(_a[i].id,_a[i-1].id);
			S[++cnt].l=min(_a[i].id,_a[i+1].id),S[cnt].r=max(_a[i].id,_a[i+1].id);
		}
		else if(delta1<delta2) S[++cnt].l=min(_a[i].id,_a[i-1].id),S[cnt].r=max(_a[i].id,_a[i-1].id);
		else S[++cnt].l=min(_a[i].id,_a[i+1].id),S[cnt].r=max(_a[i].id,_a[i+1].id);
	}
	sort(S+1,S+cnt+1);
	for(int i=1;i<=M;++i) scanf("%d%d",&Q[i].l,&Q[i].r),Q[i].id=i;
	sort(Q+1,Q+M+1);
	for(int i=1;i<=M;++i){
		int r=Q[i].r;
		//将右端点小于等于查询的右端点的区间加到线段树中 
		while(S[now].r<=r&&now<=cnt) update(1,1,N,S[now++].l);
		ans+=(LL)Q[i].id*query(1,1,N,Q[i].l);
	}
	printf("%lld\n",ans);
	
	return 0;
}
```


---

## 作者：BDFCL (赞：1)

**Solution**

观察题目要求，如果用人话来说，每次给定一个区间$[l, r]$，询问数对$(x, y) \quad (x, y \in [l, r])$的个数，使得当$x$为定值时，$a_y$为与$a_x$的差的绝对值最小的那个

如果解释的更为人话一点就是求$x, y \in [l, r]$且$a_y$是在整个数组中最接近$a_x$的那个数

显然，由于$a_i$互不相同，这样的$y$只能是排序之后的第$x'+1$个或（和）第$x'-1$个（$x'$表示排序之后$x$所在位置），且对于每个$x$来说最多只有两个（当两者的差不相同时为较小的那个，否则两个都行），因此我们不妨将这些数对处理出来，然后问题就转变为求区间内点对个数的问题了

我们记处理出来的点对为$(p_i, q_i)$，由于点对中$p_i$与$q_i$的大小不影响结果，所以我们不妨将$p_i$定为较小的那个$q_i$定为较大的那个

考虑将询问离线，由于我们要求的是$l_j \leq q_i(1)$且$q_i \leq r_j(2)$的个数，按左端点从大到小排序，每次将所有满足条件$(1)$的点对插入，然后查询满足条件$(2)$的点对个数就行了，（由于将询问按左端点从大到小排序了，所以之前满足条件$(1)$的现在也一定满足）。这个过程可以用树状数组每次在对应的$q_i$的位置$+1$然后查询前缀和完成

时间复杂度大概是$O(n\log n)$ 

**Code**

```c++
#include <bits/stdc++.h>

#define N (int) (3e5+10)
#define ll long long

using namespace std;

int input () {
    int x = 0, f = 0;
    char c = getchar ();
    while (c < '0' || c > '9') f = c == '-', c = getchar ();
    while (c >= '0' && c <= '9') x = (x << 1) + (x << 3) + (c ^ 48), c = getchar ();
    return f ? - x : x;
}

int n, m;
pair <int, int> a[N];

vector <pair <int, int> > v;

struct Query {
    int l, r, id;
} q[N];

struct Bit {
    int val[N];
    int lowbit (int x) {
        return x & (- x);
    }
    void update (int pos, int delta) {
        while (pos <= n) val[pos] += delta, pos += lowbit (pos);
    }
    inline int query (int pos) {
        int ret = 0;
        while (pos) ret += val[pos], pos -= lowbit (pos);
        return ret;
    }
    Bit () {
        memset (val, 0, sizeof (val));
    }
} bit;

bool cmp1 (const pair <int, int> & x, const pair <int, int> & y) {
    return x.first < y.first;
}

bool cmp2 (const Query & x, const Query & y) {
    return x.l >= y.l;
}

bool cmp3 (const pair <int, int> & x, const pair <int, int> & y) {
    return x.first > y.first;
}

int main () {
    n = input (), m = input ();
    for (int i = 1; i <= n; i ++) a[i].first = input (), a[i].second = i;
    for (int i = 1; i <= m; i ++) q[i].l = input (), q[i].r = input (), q[i].id = i;

    sort (a+1, a+n+1, cmp1);
    sort (q+1, q+m+1, cmp2);

    v.push_back (make_pair (min (a[1].second, a[2].second), max (a[1].second, a[2].second)));
    v.push_back (make_pair (min (a[n-1].second, a[n].second), max (a[n-1].second, a[n].second)));
    for (int i = 2; i < n; i ++) {
        int d1 = a[i].first - a[i-1].first, d2 = a[i+1].first - a[i].first;
        if (d1 < d2) 
            v.push_back (make_pair (min(a[i].second, a[i-1].second), max (a[i].second, a[i-1].second)));
        else if (d1 > d2)
            v.push_back (make_pair (min(a[i].second, a[i+1].second), max (a[i].second, a[i+1].second)));
        else
            v.push_back (make_pair (min(a[i].second, a[i-1].second), max (a[i].second, a[i-1].second))),
            v.push_back (make_pair (min(a[i].second, a[i+1].second), max (a[i].second, a[i+1].second)));
    }

    sort (v.begin (), v.end (), cmp3);

    ll ans = 0;
    for (int i = 1, j = 0; i <= m;) {
        while (j < v.size () && v[j].first >= q[i].l) bit.update (v[j].second, 1), j ++;
        int tmp = q[i].l;
        while (i <= m && q[i].l == tmp) ans += 1ll * bit.query (q[i].r) * q[i].id, i ++;
    }

    printf ("%lld\n", ans);

    return 0;
}
```

**Conclusion**

1 试着将题目转成人话，方便理解

2 多组询问看看有没有离线做法，可以考虑将询问按某种性质排序等方式

---

## 作者：rainygame (赞：0)

这里给一个既不用主席树也不用离线的简单做法。~~但是最大点 982ms。~~

首先发现题目保证了 $a_i$ 两两不同，所以**和某个数 $x$ 可以配对的数 $y$ 最多只有 $2$ 个**。

考虑对每个数分别计算它**被**配对的贡献。（为什么是被呢？因为如果不是就会超时一点）这是容易处理的。然后把这些东西都搬到线段树上，在到线段树结点 $[l,r]$ 时，如何快速查询这个结点里面的**被**配对的数的配对数在 $[L,R]$ 中的数量呢？

不难想到二分。只需要先在建线段树的时候顺便双指针排序即可。

时间复杂度 $O(n \log n+q \log^2 n)$，空间复杂度 $O(n \log n)$。

代码：


```cpp
#include <bits/stdc++.h>
using namespace std;
#define MAXN 300001
typedef long long ll;

int n, m;
int a[MAXN]; struct Node{int v, id;}lsh[MAXN];
vector<int> y[MAXN];

namespace Seg{
	vector<int> tr[MAXN<<2];
	void build(int p, int l, int r){
		if (l == r){tr[p] = y[l]; return;} int mid((l+r)>>1); build(p<<1, l, mid); build(p<<1|1, mid+1, r);
		int L(0);
		for (int i(0); i<tr[p<<1].size(); ++i){
			while (L < tr[p<<1|1].size() && tr[p<<1|1][L] < tr[p<<1][i]) tr[p].push_back(tr[p<<1|1][L++]);
			tr[p].push_back(tr[p<<1][i]);
		}
		while (L < tr[p<<1|1].size()) tr[p].push_back(tr[p<<1|1][L++]);
	}
	ll qry(int p, int l, int r, int L, int R){
		if (L <= l && r <= R){
			return upper_bound(tr[p].begin(), tr[p].end(), R)-lower_bound(tr[p].begin(), tr[p].end(), L);
		}
		int mid((l+r)>>1); ll res(0);
		if (L <= mid) res += qry(p<<1, l, mid, L, R); if (R > mid) res += qry(p<<1|1, mid+1, r, L, R);
		return res;
	}
}

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    
    cin >> n >> m; for (int i(1); i<=n; ++i) cin >> a[i], lsh[i] = {a[i], i};
	sort(lsh+1, lsh+n+1, [](Node a, Node b){return a.v < b.v;});
    for (int i(1); i<=n; ++i){
    	if (i != n && (i == 1 || lsh[i+1].v-lsh[i].v <= lsh[i].v-lsh[i-1].v)) y[lsh[i].id].push_back(lsh[i+1].id);
    	if (i != 1 && (i == n || lsh[i+1].v-lsh[i].v >= lsh[i].v-lsh[i-1].v)) y[lsh[i].id].push_back(lsh[i-1].id);
	}
	for (int i(1); i<=n; ++i) if (y[i].size() == 2 && y[i][0] > y[i][1]) swap(y[i][0], y[i][1]); Seg::build(1, 1, n);
	ll ans(0); for (int i(1), l, r; i<=m; ++i) cin >> l >> r, (ans += Seg::qry(1, 1, n, l, r)*i); cout << ans;

    return 0;
}

```

---

## 作者：yizhiming (赞：0)

这篇题解是作者发癫了，学主席树学傻了属于是，不会主席树的建议去看别人的题解。

## 题目大意

我要养成不写题目大意，而让读者自己去看题面的习惯（

[$Link$](https://www.luogu.com.cn/problem/P5677)

## 题目分析

注意到这个序列没有重复的数，所以对于任意一个 $x$，最多只有两个 $y$ 能够与其匹配，设一个数的匹配值为 $res1,res2$，所以我们可以将问题转换成查询一个 $[l,r]$ 的区间内，权值即 $res1,res2$ 在 $[l,r]$ 区间的数有多少个。

这东西是主席树的基本操作，直接以原数组下标建立版本，将对应的匹配下标插入到权值线段树上直接维护即可。

## Code

注意最后那个阴间的数据，当 $n=1$ 的时候不会有任何一个数有匹配值，不特判掉会错。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <queue>
#define int long long
using namespace std;
int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
const int N = 3e5+5;
struct aa{
	int val,id;
	bool operator<(const aa&x)const{
		return val<x.val;
	}
}in[N];
int res[N][2];
struct bb{
	int lc,rc,siz;
}node[N*40];
int rt[N],tot;
void ins(int &u,int v,int l,int r,int pla){
	u = ++tot;
	node[u] = node[v];
	node[u].siz++;
	if(l==r){
		return;
	}
	int mid = (l+r)/2;
	if(pla<=mid){
		ins(node[u].lc,node[v].lc,l,mid,pla);
	}else{
		ins(node[u].rc,node[v].rc,mid+1,r,pla);
	}
}
int query(int u,int v,int l,int r,int ll,int rr){
	if(node[v].siz-node[u].siz==0){
		return 0;
	}
	if(l==ll&&r==rr){
		return node[v].siz-node[u].siz;
	}
	int mid = (l+r)/2;
	if(rr<=mid){
		return query(node[u].lc,node[v].lc,l,mid,ll,rr);
	}else if(ll>mid){
		return query(node[u].rc,node[v].rc,mid+1,r,ll,rr);
	}else{
		return query(node[u].lc,node[v].lc,l,mid,ll,mid)+query(node[u].rc,node[v].rc,mid+1,r,mid+1,rr);
	}
}
int ans;
signed main(){
	int n,m;
	n = read();m = read();
	for(int i=1;i<=n;i++){
		in[i].id = i;
		in[i].val = read();
	}
	sort(in+1,in+1+n);
	for(int i=1;i<=n;i++){
		if(i==1){
			res[in[i].id][0] = in[i+1].id;
		}else if(i==n){
			res[in[i].id][0] = in[i-1].id;
		}else{
			int res1 = abs(in[i].val-in[i-1].val),res2 = abs(in[i].val-in[i+1].val);
			if(res1<res2){
				res[in[i].id][0] = in[i-1].id;
			}else if(res1>res2){
				res[in[i].id][0] = in[i+1].id;
			}else{
				res[in[i].id][0] = in[i-1].id;
				res[in[i].id][1] = in[i+1].id;
			}
		}
	}
	for(int i=1;i<=n;i++){
		if(!res[i][0]){
			continue;
		}
		ins(rt[i],rt[i-1],1,n,res[i][0]);
		if(res[i][1]){
			ins(rt[i],rt[i],1,n,res[i][1]);
		}
	}
	int l,r;
	for(int i=1;i<=m;i++){
		l = read();r = read();
		ans+=i*query(rt[l-1],rt[r],1,n,l,r);
	}
	cout<<ans<<"\n";
	return 0;
}


```

没仔细看题解区，不过应该不会有魔怔人跟我一样写主席树吧（

---


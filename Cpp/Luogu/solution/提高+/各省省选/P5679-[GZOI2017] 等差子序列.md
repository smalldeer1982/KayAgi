# [GZOI2017] 等差子序列

## 题目背景

GZOI2017 D2T2

## 题目描述

给出一个长度为 $N$ 的正整数序列，问是否存在一个长度不小于三的等差子序列。

## 说明/提示

【数据约束】

对于 $20\%$的数据：$N\le 100$。

对于 $40\%$的数据：$N\le 10^3$。

对于 $100\%$的数据：$1\le T \le 10$，$1\le N\le 2\times 10^4$，序列中的数 $\le 2\times 10^4$。

## 样例 #1

### 输入

```
3
4
4 3 2 1
2
1 100
5
1 17 9 18 17```

### 输出

```
YES
NO
YES```

# 题解

## 作者：EnofTaiPeople (赞：14)

怎么好多人都要卡空间，还有的 $\text{NTT}$ 都用上了，这里大力推荐空间低于线性的做法。

如何让空间复杂度低于线性？我甚至不需要开数组，两个 `bitset` 就够了，于是空间复杂度为 $O(\dfrac{C}{w})$。

具体的，如果 $(i,j,k),i<j<k$ 构成等差数列，则有 $a_j-a_i=a_k-a_j$，将 $a_k$ 提出来，$a_k=2a_j-a_i$，设 $C$ 为值域，有 $a_k+C=2a_j+C-a_i$。

此处开一个 `bitset` 记录 $C-a_i$，另一个记录 $2a_j-a_i$，因为满足需求的 $2a_j-a_i\ge0$，求 $2a_j-a_i$ 的 `bitset` 只需要将前一个 `bitset` 左移 $2a_j$ 位即可，如果能在第二个 `bitset` 内找到 $a_k$，答案为 `YES`，否则为 `NO`。

代码不到 $400B$：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=60005,C=20001;
bitset<N>f,g;
int T,n,ans;
int main(){
	ios::sync_with_stdio(false);
	cin>>T;int i,x,y;
	while(T--){
		cin>>n,f.reset(),g.reset();
		for(i=1,ans=0;i<=n;++i){
			cin>>x;
			if(f[x])ans=1;
			f|=(g<<(x+x))>>C;
			g[C-x]=1;
		}puts(ans?"YES":"NO");
	}return 0;
}
```

---

## 作者：FjswYuzu (赞：6)

转化问题为问$a_i+a_k=2\times a_j(1 \leq i < j < k \leq n )$是否存在

我们枚举每一个数作为中间数，然后枚举差值进行判断，但这是会超时的，所以我们能够想到用bitset去优化它，把时间复杂度降到$\Theta(T \times \frac {n^2}{32})$，就可以AC了

但是网上的正解是枚举$a_j$，然后把两边当做生成函数卷积起来，直接是$\Theta(n \log n)$的，不如暴力。所以分块优化，分类讨论。一块分为1024是最快的，所以时间复杂度$\Theta(1024Tn)$，尽管不如bitset

主要是水在$a_i$太小被bitset水过了，不然挺难的。

```cpp
#include<cstdio>
#include<algorithm>
#include<bitset>
#include<iostream>
#include<queue>
#include<cstring>
using namespace std;
bitset<20005> fro,beh,cons[20005];
int n,a[20005],radix[20005];
int main(){
	cons[0][0]=1;
	for(int i=1;i<=20002;++i)	cons[i]=cons[i-1]<<1,cons[i][0]=1;
	int T;
	scanf("%d",&T);
	Goto:;
	while(T-->0)
	{
		scanf("%d",&n);
		fro.reset();
		beh.reset();
		memset(radix,0,sizeof radix);
		for(int i=1;i<=n;++i)	scanf("%d",&a[i]),++radix[a[i]],beh.set(a[i]);
		for(int i=1;i<=n;++i)//枚举每一个中间数，里面枚举差值
		{
			if(!--radix[a[i]])	beh.reset(a[i]);
			int dis=min(a[i]-1,20000-a[i]);
			if((((fro>>(20001-a[i]-dis))&cons[2*dis])&((beh>>(a[i]-dis))&cons[2*dis])).count())
			{
				puts("YES");
				goto Goto;
			}
			fro.set(20001-a[i]);
		}
		puts("NO");
	}
	return 0;
}
```

加强版见bzoj3509，是求数量而不是求存在

---

## 作者：lg_zhou (赞：5)

本篇是随机化题解，轻松可过。

要判断 $yes$ 还是 $no$，范围只有 $1000$。还只用管三个数之间的关系。一眼就像随机化。于是直接随机三个数的位置，将每组数据分配 $0.09$ 秒的时间即可。

这样 WA 的概率极大，期望得分 $45$。我们相当于随机了一个 $n^3$ 的做法。那我们先考虑做出来 $n^2$ 的做法。

这很好想：因为数的范围很小，考虑开桶维护每个数第一次出现的位置，然后枚举第二个第三个数，倒推算出第一个数，并查看第一次是否出现在第二个数前面即可。这样做可以获得 $80$ 分的好成绩（数据水了）。

那我们直接随机后两个数出现的位置即可通过本题。

放代码：

```cpp
#include<iostream>
#include<ctime>
#include<algorithm>
#include<cstring> 
using namespace std;
const int maxn = 2e4+5;
int s[maxn],fir[maxn] ;
int main(){
	//freopen("a.in","r",stdin);
	srand(time(0));
	int T;
	cin >> T;
	for (int t = 1; t <= T; t++){
		int n,a=0,b=0,c=0;
		memset(fir,0,sizeof fir);
		cin >> n;
		for (int i = 1; i <= n; i++){
			cin >> s[i];
			if (!fir[s[i]])fir[s[i]] = i;//第一次出现的位置
		}
		if (n <= 2){
			cout << "NO" << endl;
			continue;
		}
		int pan = 0;
		
		clock_t tt = clock();
		while( tt < CLOCKS_PER_SEC*(double(t)*0.097) ){ //每个点 0.097 秒
			int a = rand()%n+1;
			b = rand()%n+1;
			while(b == a) b = rand()%n+1;
			if (a < b) swap(a,b);
			
			if (s[b]-(s[a]-s[b]) <= 0 || s[b]-(s[a]-s[b]) > 2e4) continue;
			if ( fir[s[b]-(s[a]-s[b])] && fir[s[b]-(s[a]-s[b])] < b){
				pan = 1;
				cout << "YES" << endl;
				break;
			}
			tt = clock();
		}
		if (!pan) cout << "NO" << endl;
	}
	return 0;
}
```




---

## 作者：LanrTabe (赞：4)

[My Blog](https://www.cnblogs.com/LanrTabe/p/11901066.html) [题面](http://noi.gznc.edu.cn/UserFiles/file/20170428/20170428175455_662.pdf)

首先，题目可以转化为是否存在长度为$3$的等差子序列。

枚举中间的那个数$a_i$，判断两边是否存在两个数和中间这个数组成等差数列。

枚举差值$d$，判断是否存在$a_i-d,a_i+d$，这一步可以bitset加速。

但是还是比较慢，数据挺水，不知道能不能卡TLE。。

时间复杂度 $O(T\frac{n^2}{32})$

### 代码：

```cpp
#include <cstdio>
#include <bitset>
#include <cstring>
#include <algorithm>
#define Sub(B,l,r) (B>>(l)&One[(r)-(l)])

const int N=20005;
int T,n,a[N],c[N];
std::bitset<N> Pre,Suf,One[N];

int main()
{
    One[0].set(0);
    for(int i=1;i<=20000;++i)(One[i]=One[i-1]).set(i);
    for(scanf("%d",&T);T--;)
    {
        scanf("%d",&n),Pre.reset(),Suf.reset(),memset(c,0,sizeof c);
        for(int i=1;i<=n;++i)scanf("%d",&a[i]);
        for(int i=1;i<=n;++i)++c[a[i]],Suf.set(a[i]);
        bool Flag=false;
        for(int i=1;i<=n;++i)
        {
            if(!--c[a[i]])Suf.reset(a[i]);
            int l=std::min(a[i]-1,20000-a[i]);
            if((Sub(Pre,20001-a[i]-l,20001-a[i]+l)&Sub(Suf,a[i]-l,a[i]+l)).count())Flag=true,i=n;
            Pre.set(20001-a[i]);
        }
        puts(Flag?"YES":"NO");
    }
    return 0;
}
```

### Update in 2019/11/21

感谢UOJ群的聚聚们orz，这怎么出原题啊。。

[bzoj3509][CodeChef]COUNTARI

~~是不是都喜欢用权限题啊~~

首先题目就相当于求是否存在$(1\le i<j<k\le n,2a_j=a_i+a_k)$（这题还削弱了，原题求数量）

枚举$a_j$，则将两边看成一个生成函数卷积起来，最后看$2a_j$这个位置是不是$0$，不是则存在答案。

直接做就是$O(n*n\log n)$的，还不如暴力，那么就要优化一下：

对数列进行分块，设块大小为$B$，那么分两种情况：

- $3$个数在不同块中：

枚举$a_j$所在块，对两边进行卷积，用这个块中所有数都当成$a_j$判断一遍。

复杂度 $O(\frac nB *2^{16}*16)$（值域为$2^{16}$）

- 至少两个数在一个块中

枚举这个块，在块中枚举两个数，同时维护一下左右的数字个数，查询一下就好。

时间复杂度 $O(\frac nB*B^2)=O(nB)$

若$\frac nB *2^{16}*16=nB$，解得$B=1024$。

但因为$FFT$常数较大，将块大小开大一点可能更快。

时间复杂度 $O(TnB)$（还不如bitset

~~代码网上随便找一份就好了~~

---

## 作者：Little09 (赞：2)

容易发现依次枚举中间数，维护桶，然后枚举差值判断。这样就是 $O(Tn^2)$ 的。

```cpp
string ask()
{
	memset(c,0,sizeof(c));
	for (int i=1;i<=n;i++) a[i]=read(),c[a[i]]++;
	memset(b,0,sizeof(b));
	c[a[1]]--;
	for (int i=1;i<=n;i++)
	{
		for (int j=-MAXN;j<=MAXN;j++)
		{
			int x=a[i]-j,y=a[i]+j;
			if (x<1||y<1||x>MAXN||y>MAXN) continue;
			if (b[x]==0||c[y]==0) continue;
			return "YES";
		}
		if (i!=n) b[a[i]]++,c[a[i+1]]--;
	}
	return "NO";
}
```

怎么优化？在枚举差值那一步，可以考虑 bitset。

由于要找到 $a_x+a_y=2\times a_i(x<i<y)$，所以我们用两个 bitset 维护前面的桶和后面的桶。可以把和转化成差，用 bitset 的 & 判断。

于是时间复杂度是 $O(\frac{TN^2}{w})$。注意一些细节。

```cpp
// By: Little09
// Problem: P5679 [GZOI2017]等差子序列
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P5679
// Memory Limit: 128 MB
// Time Limit: 1000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

// By: Little09
// Problem: P5679 [GZOI2017]等差子序列
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P5679
// Memory Limit: 128 MB
// Time Limit: 1000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include<bits/stdc++.h>
using namespace std;
int T,n;
const int N=40005,MAXN=40000;
int a[N],b[N],c[N];
bitset<N>x,y,z;
inline int read()
{
	char C=getchar();
	int F=1,ANS=0;
	while (C<'0'||C>'9')
	{
		C=getchar();
	}
	while (C>='0'&&C<='9')
	{
		ANS=ANS*10+C-'0';
		C=getchar();
	}
	return F*ANS;
} 
string ask()
{
	x.reset(),y.reset();
	memset(c,0,sizeof(c));
	for (int i=1;i<=n;i++) a[i]=read(),c[a[i]]++;
	memset(b,0,sizeof(b));
	c[a[1]]--;
	for (int i=1;i<=MAXN;i++) if (c[i]>0) y[i]=1;
	for (int i=1;i<=n;i++)
	{
		z=((x>>(MAXN-2*a[i]))&y);
		if (z.count()) return "YES";
		if (i!=n) 
		{
			if (b[a[i]]==0) x[MAXN-a[i]]=1;
			b[a[i]]++,c[a[i+1]]--;
			if (c[a[i+1]]==0) y[a[i+1]]=0;
		}
	}
	return "NO";
}
int main() 
{
	cin >> T;
	while (T--)
	{
		n=read();
		cout << ask() << endl;
	}
    return 0;
}

```


---

## 作者：BFSDFS123 (赞：1)

题目大意：寻找一个位置 $x$，满足存在两个位置 $i,j(1\le i < x < j\le n)$，使 $a_x-a_i=a_j-a_x$。

这道题是道好题，可惜暴力能过。

 bitset 优化。

$a_x-a_i=a_j-a_x$ 可以化为 $2a_x=a_i+a_j$。求是否有两个数的和为 $x$ 已经是一个出烂的 bitset 题了。

注意到位置不能重复，则考虑前缀 bitset 和后缀 bitset 中有无和为目标答案的。

bitset 优化可以去做 [P5355 [Ynoi2017] 由乃的玉米田](https://www.luogu.com.cn/problem/P5355)。

注意这道题的 $a_x$ 要乘 2，故 bitset 大小要开 $4\times 10^4$。

时间复杂度 $O(T\times \dfrac{n^2}{\omega})$，$\omega$ 因机子而异。

实现：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define eps 1e-8
const int inf=0x3f3f3f3f;
const int Maxn=2e4+10;
const int Max=2e4;
bitset<Max> s1,s2;
int Ar[Maxn];
int tong[Maxn];
void work()
{
	memset(tong,0,sizeof(tong));
	s1.reset();
	s2.reset();
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&Ar[i]);
		s2[Max-Ar[i]]=1;
		tong[Ar[i]]++;
	}
	for(int i=1;i<=n;i++)
	{
		tong[Ar[i]]--;
		if(!tong[Ar[i]])
		{
			s2[Max-Ar[i]]=0;
//			cout<<"--"<<endl;
		}
		int x=2*Ar[i];
//		cout<<"x:"<<x<<endl;
		if(((s1&(s2>>(Max-x))).any())==true)
		{
			puts("YES");
			return ;
		}
		s1[Ar[i]]=1;
	}
	puts("NO");
	return ;
}
int main()
{
	int T;
	scanf("%d",&T);
	while(T--)
	{
		work();
	}
	
	return 0;
}

```

---

## 作者：FutaRimeWoawaSete (赞：1)

考虑枚举中间的数，那么问题转化成了求前缀后缀是否有两个数相加为中间数的值的两倍。                

经典 bitset 问题，可以考虑直接维护前缀的正向值域 bitset 和倒着的值域 bitset 就可以知道一个点是否能作为中转点了。                  

可以只预处理其中一种 bitset 来卡空间。

时间复杂度 $O(T\times \frac{n ^ 2}{w})$

```cpp
/*
考虑维护一个后缀 bitset 和前缀 bitset
枚举每个数作为中转点，即询问是否有两个数相加等于 2x 
*/
#include "bits/stdc++.h"
using namespace std;
const int Len = 2e4 + 5 , Lim = 4e4;
int T,n,a[Len];
bitset<40001> suf[Len],pre;
int main()
{
	scanf("%d",&T);
	while(T --)
	{
		scanf("%d",&n);
		for(int i = 1 ; i <= n ; i ++) scanf("%d",&a[i]);
		suf[n + 1].reset();
		pre.reset();
		for(int i = n ; i >= 1 ; i --)
		{
			suf[i] = suf[i + 1];
			suf[i].set(Lim - a[i] , 1);
		}
		bool flaw = 0;
		for(int i = 1 ; i <= n ; i ++) 
		{
			int now = a[i] * 2;
			if(((pre << (Lim - now)) & suf[i + 1]).any()) 
			{
				puts("Y");
				flaw = 1;
				break;
			}
			pre.set(a[i] , 1);
		}
		if(!flaw) puts("N");
	}
	return 0;
}
```

---

## 作者：MuYC (赞：0)

updata.修复了代码问题，烦请管理员重新审核一下。

$NTT$ + 分块的题解（在这一题复杂度很差，但是比 $n^2$ 要优秀，但是会被$biset$ 吊踩）

#### 题解正文

总之，本题要求判断是否存在等差子序列。

但是，我们只要找一个 **三元组**  $(i, j, k)i < j < k$ 满足 $a[j] - a[i] = a[k] - a[j]$ 即可。这个应该是蛮显然的。

上面的 **三元组** 可以转化一波 ： $a[i] + a[k] = 2*a[j]$ ，然后考虑到 $a[]$ 的值域很小，考虑使用 $NTT$ 优化判断存在多少个满足条件的三元组。（本题中如果大于等于1个就输出 $Y$ 就行了）

$NTT$ 优化这个判断过程的话，学过 $NTT$ 的就应该知道。

我们考虑枚举 $a[j]$ ，然后把 $j$ 左边的以及 $j$ 右边的看成一个 $n - 1$ 次多项式，不妨令左边的为多项式 $A(x)$ ， 右边的为多项式 $B(x)$ , $[i]A(x)$ (这个表示$A$ 的第 $i$ 项，下同)的系数就分别为 $j$ 左边的数 $i$ 出现的次数 $cnt1_i$ 以及$[i]B(x)$的系数即为右边的 $i$ 出现的次数 $cnt2_i$。这样子的话对于每一个 $a[j]$ 都要做一次 $NTT$ 进行卷积得到每个左边的数和右边每个的数和的出现次数，复杂度就成功的变成了 $n^2logn$ 。 好耶，我们可以愉快的 $TLE$ 了(bushi！

(为什么用卷积来优化可以自行去学习一下，这是一种很经典的应用)

这就很生草了。考虑如何优化。不然还不如暴力呢！

这就得引入 **优雅的暴力** ---- **分块**。

不得不说，分块的确很喵。

首先我们分块后得到的三元组就会分为三种类型：

+ $Case1$.$i,j,k$ 都属于同一块内
+ $Case2$.$i,j,k$ 其中两个属于同一块内，但是剩余的一个处于另外的块内
+ $Case3$.$i,j,k$ 三个所处的块都不同。

考虑如何处理这三个类型的三元组:

+ $Case1:$

这个直接在块内直接枚举 $j,k$ ，然后用桶判断一下 $a[k] - a[j]$ 在 $j$ 前面出现了几次。

+ $Case2:$

这个的话，考虑分别枚举 $j$ 和 $i$ 以及 $j$ 和 $k$，然后开两个全局数组当作桶，分别记录在这个块 $L[x]$($L[x]$ 表示当前块左端点，下面同理) 前面每个数的出现过多少次，以及在每个数在当前块 $R[x]$ 的后面出现了多少次
。然后其实跟 $Case1$ 是一样的判断就行了。

+ $Case3:$

这里就要搬上 $NTT$ 了。上面已经提到了具体的卷积方法。仍然采用枚举 $j$(默认 $j$ 是当前块内的点，但是其他两个不是) 的方法然后利用 $Case2$ 提到的两个统计出来的数组作为多项式系数，进行卷积。然后就可以统计答案了。也就是统计卷出来的多项式的第 $a[j] * 2$ 项之和 。

于是复杂度被我们优化到了 O$(T * (m * n + 2 * n*log(2*n) * n /m))$

($m$ 表示块的大小)

好耶！然后只要答案已经不为零了就 $break$。这样就能 ~~卡~~ 过这道题了呢。

用基本不等式算出当 $m = \sqrt{2nlogn}$ 的时候复杂度最优秀。但是你会发现这种块的大小是过不了这一题的(而且挂的很惨)，因为实际上 $NTT$ 要取模的话，得考虑常数。实在不行 $m = 1000$ 也能过，甚至 $m = 2000$ 也能过(貌似都跑得比理论最优快......)。这道题就是这样哩。

#### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1e5 + 50;
#define int long long
const int Mod = 998244353;
int A[MAXN];
int Lef[MAXN],Rig[MAXN];
int JL[MAXN],JR[MAXN];
int n;
int L[1005],R[1050],num = 0,rev[MAXN];
int pre[MAXN],nxt[MAXN];
int lim = 1, l = 0,m;
long long Ans = 0;

inline int read() {
	int x = 0 , flag = 1;
	char ch = getchar();
	for( ; ch > '9' || ch < '0' ; ch = getchar()) if(ch == '-') flag = -1;
	for( ; ch >= '0' && ch <= '9' ; ch = getchar()) x = (x << 3) + (x << 1) + ch - '0';
	return x * flag;
}

int quickpower(int x,int y) {
	int ans = 1 , op = x;
	while(y) {
		if(y & 1) ans *= op , ans %= Mod;
		op *= op , op %= Mod;
		y >>= 1;
	}
	return ans;
}

void NTT(int * a , int type) {
	for(int i = 0 ; i < lim ; i ++)
		if(i < rev[i]) swap(a[i],a[rev[i]]);
	for(int mid = 1 ; mid < lim ; mid <<= 1) {
		int gn = quickpower(3 , (Mod - 1) / (mid << 1));
		for(int i = 0 ; i < lim ; i += (mid << 1)) {
			int g = 1;
			for(int j = 0 ; j < mid ; j ++ , g = (g * gn) % Mod) {
				int x = a[i + j] , y = a[i + j + mid] * g % Mod;
				a[i + j] = (x + y) % Mod;
				a[i + j + mid] = (x - y + Mod) % Mod;
			}
		}
	}
	if(type == 1) return ;
	reverse(a + 1, a + lim);
	int inv = quickpower(lim , Mod - 2);
	for(int i = 0 ; i < lim ; i ++) a[i] *= inv , a[i] %= Mod;
	return ;
}

void deal(int x) {
	for(int i = L[x] ; i <= R[x] ; i ++) Rig[A[i]] --;
	for(int i = L[x] ; i <= R[x] ; i ++) {
		for(int j = i + 1 ; j <= R[x] ; j ++) {
			if(A[j] < A[i] * 2) {
				Ans += pre[A[i] - (A[j] - A[i])];
				Ans += Lef[A[i] - (A[j] - A[i])];
			}
			if(A[j] * 2 > A[i])
			Ans += Rig[A[j] + (A[j] - A[i])];
		}
		pre[A[i]] ++;
	}
	for(int i = 0 ; i <= m ; i ++) JL[i] = Lef[i];
	for(int i = 0 ; i <= m ; i ++) JR[i] = Rig[i];
	for(int i = m + 1; i < lim ; i ++) JL[i] = JR[i] = 0;
	NTT(JL , 1 ) ; NTT( JR , 1 );
	for(int i = 0 ; i < lim; i ++) JL[i] *= JR[i] , JL[i] %= Mod;
	NTT( JL , - 1);
	for(int i = L[x] ; i <= R[x]; i ++) 
	Ans += JL[2 * A[i]], pre[A[i]] = 0,Lef[A[i]] ++;
	return ;
}

signed main() {
	
	int Q = read();
	while(Q --) {
		n = read();
		memset(JL,0,sizeof(JL)); memset(Rig,0,sizeof(Rig));
		memset(JR,0,sizeof(JR)); memset(Lef,0,sizeof(Lef)); 
		lim = 1 , l = 0;
		m = n; num = 0; Ans = 0;
		for(int i = 1 ; i <= n ; i ++) A[i] = read() , Rig[A[i]] ++;
		int block = 2000;
		while(R[num] != n) {
			num ++;
			L[num] = R[num - 1] + 1;
			R[num] = min(num * block , n);
		}
		for( ; lim <= m * 2 ; lim <<= 1) l ++;
		for(int i = 0 ; i <= lim ; i ++) 
		rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (l - 1));
		for(int i = 1 ; i <= num && Ans == 0; i ++) deal(i);
		if(Ans != 0)cout << "YES" << endl;
		else cout << "NO" << endl;
	}
	return 0;
}
```

这道题的加强版大概是 $bzoj 3509$ COUNTING ， 需要统计三元组数量并且数据规模更大。

---


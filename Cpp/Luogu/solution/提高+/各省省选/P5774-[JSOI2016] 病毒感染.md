# [JSOI2016] 病毒感染

## 题目描述

JOSI 的边陲小镇爆发了严重的 Jebola 病毒疫情，大批群众感染生命垂危。计算机科学家 JYY 采用最新的算法紧急研制出了 Jebola 疫苗，并火速前往灾区救治患者。

一共有 $N$ 个小镇爆发了 Jebola 疫情。这些小镇由于地处边陲，仅仅通过一条长直公路连接。方便起见我们将这些小镇按照公路连接顺序由 $1$ 编号到 $N$。JYY 会在第一天一早抵达 $1$ 号小镇。

一开始在 $i$ 号小镇，有 $a_i$ 名患者感染了 Jebola 病毒。

每一天 JYY 可以选择：

1. 花费一天时间彻底治愈 JYY 目前所在的村庄的所有 Jebola 患者。这一天不会有任何患者死去；
2. 花费一天的时间前往一个相邻的村庄。

当一天开始时，如果一个村庄里有 $k$ 个 Jebola 患者，那么这一天结束时，这 $k$ 个患者会感染另外 $k$ 个这个村子里的健康村民并死去。所以对于 $i$ 号村庄，只要这个村庄没有被 JYY 彻底消灭疫情，那么每一天都会有 $a_i$ 个村民死去。

JYY 希望采用措施使得疫情被整体消灭时，总共死去的村民数量尽量少。

为了达成这一目标，JYY 有时会选择抵达一个村庄但是并不对村民进行施救。这样的行为如果不加限制，往往会造成更加严重的后果。

试想这样的情形：假设当 JYY 第一次抵达村庄 $i$，未作救治并直接前往了另一个村庄。那么由于 $i$ 村庄的人们求生心切，一旦当 JYY 朝向靠近 $i$ 村庄的方向前行时，$i$ 村庄的村民就会以为 JYY 是来救他们了，而产生巨大的期望。之后倘若 JYY 再次掉头朝着远离 $i$ 村庄的方向行进，那么 $i$ 村庄的村民就会因为巨大的失落而产生绝望的情绪。

为了避免这种情况，JYY 对他的行程做了如下规定：

假设 JYY 进入 $i$ 村庄并在第二天立即离开（村庄 $i$ 的疫情并未治愈）。如果在之后的某一天，JYY 从村庄 $j$ 前往村庄 $k$，并满足 $|k-i| \lt |i-j|$。那么在之后的日子里 JYY 只能朝着 $i$ 村庄前进直到抵达 $i$ 村庄并立即治愈该村的患者。在前往 $i$ 村庄的过程中，JYY 可以选择将途经村庄的疫情治愈。

比如，如果 JYY 有如下行程：

第一天：从村庄 $1$ 前往村庄 $2$；

第二天：从村庄 $2$ 前往村庄 $3$；

第三天：治愈村庄 $3$；

第四天：前往村庄 $2$。

此时 JYY 对于之后三天的行程只有唯一一种选择：

第五天：治愈村庄 $2$；

第六天：前往村庄 $1$；

第七天：治愈村庄 $1$。

JYY 想知道在治愈所有村庄之前，至少会有多少村民因 Jebola 死去。

## 说明/提示

**样例说明**

我们用 $C(k)$ 表示治愈 $k$ 号村庄，$i \rightarrow j$ 表示从村庄 $i$ 前进到村庄 $j$，用逗号分隔每一天的行程安排，那么样例中的最优策略为：

$1 \rightarrow 2 , C(2),2 \rightarrow 3 , 3 \rightarrow 4 , C(4) , 4 \rightarrow 3 , C(3) , 3 \rightarrow 2 , 2 \rightarrow 1 , C(1) , 1 \rightarrow 2 , 2 \rightarrow 3 , 3 \rightarrow 4 , 4 \rightarrow 5 , 5 \rightarrow 6 , C(6) , 6 \rightarrow 5 , C(5)$;

整个过程耗时 $18$ 天。

------

**数据范围**

对于 $10\%$ 的数据，满足 $N \le 10$；

对于 $30\%$ 的数据，满足 $N \le 20$；

对于 $50\%$ 的数据，满足 $N \le 60$；

对于 $100\%$ 的数据，满足 $1 \le N \le 3000$，$1 \le a_i \le 10^9$。

## 样例 #1

### 输入

```
6
40 200 1 300 2 10```

### 输出

```
1950```

# 题解

## 作者：Su_Zipei (赞：24)

 _ _ _ _# 原题链接：https://www.luogu.com.cn/problem/P5774
## 分析
直接看这道题，第一个困惑点，那个绝对值的比较是什么东西，根据数学知识，我们可以知道这个意思是$k$到$i$的距离小于$k$到$j$的距离，而路线是线性的，这就意味着当且仅当$k$在$j$的左边时才成立，不然总会有$k-i>k-j$，还不理解？看下图
![](https://cdn.luogu.com.cn/upload/image_hosting/g5tnufz7.png)
如果$K$在$K'$的位置，那么$K-i$一定大于$K-j$吧，所以这个题的题意是只要从$j$往回走去治愈$K$，就必须把之前没治愈过的村庄也治愈了。

想到这里，状态就差不多出来了，定义$DP_i$表示治愈前i个村庄的最小死亡数，下面考虑状态转移，对于$JYY$来说，每个村庄它都有两个选择，治愈$or$先去别的再走回来治愈，治愈的话很好弄，主要考虑的就是略过它的情况，这时候如果依次枚举$K$，效率应该是$N^3$，程序吃不消，$3000$的极限数据我们最少也要压到$N^2$左右，所以接下来考虑优化。

优化其实也挺简单的，主要有一点很恶心，下边再说。（从这里开始默认$j$在$i$的前边，请勿被上图迷惑）我们发现多出来的时间主要是用在了计算略过村庄再回来的死亡人数的计算，所以我们可以先考虑预处理出从$j$到$i$再从$i$到$j$然后又回到i这一过程中最少的死亡数，于是定义$g_{i,j}$含义为上述的来辅助我们的$DP$。我还是补一张图吧……把我自己绕懵了
![](https://cdn.luogu.com.cn/upload/image_hosting/l75a3obo.png)
 看了这张图我相信你就明白了$g$数组的含义，接下来考虑如何求解$g$数组，初始的话$g[i][i]$肯定是为0的，所以转移都应该从这个位置开始，即倒序，那么怎么转移呢，接下来就是很恶心的一个地方，计算经过的天数！很多题解里都没写到这个，这里详细计算一下。

对于$g_{i,j}$，同样分两种情况讨论，救助或是略过，不管是救助还是略过，都避免不了经过一个区间，就是$j+1$到$i$，所以这里可以分而治之，把$j$和$j+1$到$i$这两个分开，$g_{i,j}$的转移中应该需要有$g_{i,j+1}$，这里又启示我们进行倒序循环，同样，不管救助$j$还是略过，从$j$走到$j+1$的这一天里，区间$j+1$到$i$这一段的村庄都会死亡（为村民默哀？）所以答案累加$Sum_{j+1,i}$这个可以由前缀和$O(1)$求出，到了点$j+1$后，$j+1$到$i$的死亡人数就已经被记在了$g_{i,j+1}$里，所以可以不用考虑，这是两种情况所共同具有的死亡人数，下面对两种情况分开讨论，如果救治$j$的人，那么区间$j+1$，$i$的村民就要多死一天，即$Sum_{j+1,i}$，不救治呢？因为同样的我们跑路的代价都记录在了$g_{i,j+1}$里边，所以不救治的代价就是在这段时间里$j$村死亡的人数，你可能问，别的村难道没有死亡的吗？当然可能会有，但我们已经记录了，所以这里不需要再次加入，首先算一下从$j$跑到$i$再跑回来所需要的时间，这里举个例子，从4到5要1天，4到6要2天，4到7要3天，所以显然跑路时$j$村死亡的人是$2*(i-j)*a_j$，2是跑了两遍，$i-j$是刚刚推出来的，$a_j$是$j$村日死亡人数，那只有这些吗？当然不是，这只是跑路的代价，根据定义和题意，$j+1$到$i$这些村庄均被治愈且均在略过$j$后被治愈，所以一个村庄一天，一共就是$(i-(j+1)+1)*a_j$天，于是我们的$g_{i,j}$就有了转移方程
$g_{i,j}$=$g_{i,j+1}$+$Sum_{j+1,i}$+$min$($3*(i-j)*a_j$，$Sum_{j+1,i}$)

辅助进行转移的方程有了之后我们就可以进行$dp$的转移了，没错，下边还有很恶心的算时间。

对于每前$i$个村庄，都不可能直接求出他的最小值，所以要枚举中间点$j$，即我治愈了前$j$个村庄，但是$j+1$被略过了，所以$j+1$的治愈是从$j+1$走到$i$再走回来时才被治愈，这一段的代价就是$g_{i,j+1}$，治愈前j个的代价为$dp_j$，直接累加答案即可，那么最硬核的东西就是$i+1$到$n$的这段区间，因为在当前阶段，这段区间内的人是不可能被治愈的，所以一天内的死亡人数是$Sum_{i+1,n}$，天数呢？根据我之前所推导的，从$j+1$到$i$之间反复横跳一来一回一来需要天数$3*(i-(j+1))$，治愈区间$j+1$到$i$需要时间$(i-(j+1)+1)$。

这里不要忽略了一个地方，就是从$j$跑路跑到$j+1$时还有一天，所以总天数就是$3*(i-(j+1))+i-(j+1)+1+1$，乘上每天死亡的人数就是最后的代价，累加答案。

至此，这道省选题就落下了帷幕……什么？你问我最后转移的时候没考虑略过$i$就是一路向右的情况？怎么可能，当我枚举到$j=i-1$的时候，就相当于转移了这种情况，是吧，所以这个算法是没有问题的，时间复杂度大致为$O(n^2)$可以A掉

$Tips$：：如果你实在看不懂时间怎么算的请拿起笔自己模拟一下吧，很快就能懂，我也尽力了。
```
#include<iostream>
#include<cstring>
#define ll long long 
using namespace std;
const int N=3e3+10;
ll s[N],g[N][N],dp[N],a[N];
ll Sum(int l,int r){
    return s[r]-s[l-1];
}
int main(){
    int n;
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>s[i];a[i]=s[i];s[i]+=s[i-1];
    }
    for(int i=1;i<=n;i++)
    for(int j=i-1;j;j--)
        g[i][j]=g[i][j+1]+Sum(j+1,i)+min(3LL*(i-j)*a[j],Sum(j+1,i));
    memset(dp,0x3f,sizeof dp);
    dp[0]=0;
    for(int i=1;i<=n;i++)
    for(int j=0;j<i;j++)
        dp[i]=min(dp[i],dp[j]+g[i][j+1]+Sum(i+1,n)*((i-(j+1))*3+i-(j+1)+2));
    cout<<dp[n];
}
```
 

 _ _ _ _ 

---

## 作者：FjswYuzu (赞：14)

算是一道简单的 dp 题了。

我们直接暴力 dp 会发现 $O(n^3)$ 的时间复杂度只能得 $50\%$ 的分，于是我们考虑优化。

瓶颈在于我们无法快速计算 $i → j → i$ 途中的最少死亡的人数。于是我们把两样东西拆开来进行计算。

因为村庄排成一条链，我们定义 $sum_i=\sum_{j=1}^i a_j$。

我们定义 $dp_{i,j}$ 为 $i → j → i$ 途中的最少死亡的人数，枚举 $i$ 为起点， $j$ 为长度，可以得到这个 dp 方程：

$$dp_{j,i+j}=dp_{j+1,i+j} + \min ((sum_{i+j}-sum_{j})\times 2 , a_j \times i \times 3 + sum_{i+j}-sum_{j})$$

至此，我们用 $O(n^2)$ 的时间复杂度完成了预处理，接下来就是计算答案。

我们定义 $dp2_i$ 为当前在村庄 $i$ 并且 $i$ 到 $i$ 以前的村庄疫情消灭的总消失最小人数，我们可以快速得到：

$$dp2_i=\min \{dp2_j+dp_{j+1,i}+(4 \times i - 4 \times j - 2)\times (sum_n-sum_i)\}$$

至此，时间复杂度 $O(n^2)$，可以解决问题。

```cpp
#include<cstdio>
#include<cstring>
long long min(long long x,long long y){return x<y?x:y;}
long long n,dp[3005][3005],dp2[3005],sum[3005],a[3005];
int main(){
	scanf("%lld",&n);
	for(long long i=1;i<=n;++i)	scanf("%lld",&a[i]),sum[i]=sum[i-1]+a[i];
	for(long long i=1;i<=n-1;++i)	for(long long j=1;j<=n-i;++j)	dp[j][i+j]=dp[j+1][i+j]+min((sum[i+j]-sum[j])*2,a[j]*i*3+sum[i+j]-sum[j]);
	memset(dp2,0x3f,sizeof dp2);//设置极大值
	dp2[0]=0;
	for(long long i=1;i<=n;++i)	for(long long j=0;j<i;++j)	dp2[i]=min(dp2[i],dp2[j]+dp[j+1][i]+(4*i-4*j-2)*(sum[n]-sum[i]));
	printf("%lld",dp2[n]);
	return 0;
}
```

---

## 作者：Alex_Wei (赞：8)

> XXXIII. [P5774 [JSOI2016]病毒感染](https://www.luogu.com.cn/problem/P5774)
>
> 选自 [DP 做题记录](https://www.cnblogs.com/alex-wei/p/simple_DP.html) 例题 XXXIII.

细节巨大多。

一个显然的想法是设 $f_i$ 表示前 $i$ 个村庄的最少代价，但是这样不行，因为前 $i$ 个村庄的最优解不一定是全局最优解：我们可能会花更多的天数达到前 $i$ 个村庄的最优解，但是这会让后面村庄的代价增大。同时，数据范围不允许我们将天数设计到 DP 里面。

因此我们使用**代价提前计算**的 trick 即设 $f_i$ 表示治疗完前 $i$ 个村庄且现在在位置 $i$ 处时，所有村庄代价之和的最小值。转移直接枚举我们忽略的最左端的村庄 $j$，那么代价就是：

- 首先我们从 $j-1$ 处要经过 $4(i-j)+2$ 天才能走完 $j-1\to i\to j\to i$ 的总路程并治疗完所有村庄，因此代价加上 $(4(i-j)+2)(s_n-s_i)$，其中 $s$ 是 $a$ 的前缀和。
- 然后对于 $j+1\sim i$ 的每个位置 $k$，如果我们马不停蹄直接往右赶，则第一次到达该村庄的时间为 $k-j+1$。因此代价加上 $\sum_{k=j+1}^i a_k(k-j+1)$。
- 接下来对于村庄 $k$，若我们选择在 $j\to i$ 的时候治疗，则会花费一天时间，导致 $k+1\sim i$ 的救治时间变晚一天，代价为 $s_i-s_k$。否则必须在 $i\to j$ 的时候治疗，此时村庄 $k$ 会晚被治疗 $3(i-k)$ 天（可以手动模拟一下）。因此代价加上 $\sum_{k=j+1}^i \min(s_i-s_k,3(i-k)a_k)$。
- 最后考虑村庄 $j$ 会在第 $3(i-j)+1$ 天时被治疗，因此代价加上 $(3(i-j)+1)a_j$。
- 别忘了加 $f_{j-1}$。

枚举 $j$ 后对每个结果取个 $\min$ 即可。

这么搞时间复杂度是 $\mathcal{O}(n^3)$ 的，无法接受。但是注意到主要时间浪费在枚举 $k$，考虑怎么优化：首先倒序枚举 $k$，当 $j\to j-1$ 时，case 2 的总代价会加上 $a_j+(s_i-s_{j-1})$，case 3 的总代价会加上 $\min(s_i-s_j,3(i-j)a_j)$。

因此总复杂度为 $\mathcal{O}(n^2)$。**需要特判 $j=1$ 的情况，因为 JYY 第一天早上已经到了村庄 $1$ 而不是 $f_0$ 所表示的在不存在的村庄 $0$ 处。**

```cpp
const int N = 3e3 + 5;

ll n, a[N], s[N], f[N];
int main() {
	cin >> n, mem(f, 63, N), f[0] = 0;
	for(int i = 1; i <= n; i++) cin >> a[i], s[i] = s[i - 1] + a[i];
	f[1] = s[n] - a[1];
	for(int i = 2; i <= n; i++) {
		ll cur = 0;
		for(int j = i; j; j--) {
			ll coef = (4 * (i - j) + (j == 1 ? 1 : 2)) * (s[n] - s[i]);
			coef += (3 * (i - j) + (j == 1 ? 0 : 1)) * a[j];
			f[i] = min(f[i], f[j - 1] + cur + coef);
			cur += (j == 2 ? 0 : s[i] - s[j - 1]) + a[j];
			cur += min(s[i] - s[j], a[j] * 3 * (i - j));
		}
	} cout << f[n] << endl;
	return 0;
}
```



---

## 作者：是个妹子啦 (赞：4)

这是绿题吗？？？，可以评个~~蓝紫~~题 另外$Orz$ $SyadouHayami$神仙

可以发现往左走就要把左边所有没治愈的村庄治愈

过程可以分为几段，每段以任意顺序治愈后回到该段起点，再治愈其它段

设$f_i$表示治愈前$i$个村庄最小死亡人数，$s_i=\sum\limits_{j=1}^i a_i$，$w_{i,j}$为从$i$出发治愈$[i,j]$所有村庄再返回$i$的最小死亡人数，转移方程为
$$
f_i=\min\limits_{j<i}\{f_j+[j\not=0](s_n-s_j)+w_{j+1,i}+[i\not=n](i-j-1)(s_n-s_i)\}
$$
 $f_0=0$

$w_{i,j}$从$w_{i+1,j}$转移，枚举$i$开始治不治
$$
w_{i,j}=w_{i+1,j}+\min
\begin{cases}
2(s_n-s_i)+(s_n-s_j)\\
3(j-i)a_i+(s_n-s_i)+2(s_n-s_j)\\
\end{cases}
$$
$w_{i,i}=s_n-s_i$

```cpp
int main(){
	scanf("%d",&n);
	for (int i=1;i<=n;++i) scanf("%d",&a[i]),s[i] = s[i-1] + a[i];
	for (int j = 1;j <= n;++j) {
        w[j][j] = s[n]-s[j];
        for (int i = j-1;i;--i)
            w[i][j] = w[i+1][j] + min(2*(s[n]-s[i]) + s[n]-s[j],3*a[i]*(j-i) + 2*(s[n]-s[j]) + s[n]-s[i]);
    }
    memset(f,0x3f,sizeof(f)),f[0]=0;
    for(int i = 1;i <= n;++i)
        for(int j = 0;j < i;++j)
            f[i] = min(f[i],f[j] + (j != 0)*(s[n]-s[j]) + w[j+1][i] + (i-j-1)*(s[n]-s[i]));
    printf("%lld\n",f[n]);
}
```



---

## 作者：山田リョウ (赞：2)

[题目链接](https://www.luogu.com.cn/problem/P5774)

u1s1 我认为这题怎么说也得蓝吧，不可能才绿。

这道题我们需要两次 $dp$。

第一次的 $dp$ 数组我们叫做 $g$ 数组吧，$g_{i,j}$ 表示从第 $i$ 号村庄出发，到第 $j$ 号村庄，再回到第 i 号村庄治愈完 $[i,j]$ 区间内所有的村庄时这 $j-i+1$ 个村庄死的人数。

可以写出状态转移方程：
$$ g_{i,j}=g_{i+1,j}+\min(\sum\limits_{k=i+1}^{j}a[k],3\times(j-i)\times a_i)$$

其中 $3\times(j-i)$，因为从 $i+1$ 走到 $j$ 再回到 $i+1$ 需要 $2\times(j-i)$ 的时间，但是治愈 $i+1$ 到 $j$ 这 $j-i$ 个村庄还需要 $j-i$ 的时间，所以总共需要 $3\times(j-i)$ 的时间。

而 $\sum\limits_{k=i+1}^{j}a[k]$ 这部分可以用前缀和优化一下。

这部分代码：

```cpp
for(int i=n;i;--i)
	for(int j=i+1;j<=n;++j)
		g[i][j]=g[i+1][j]+sum[j]-sum[i]+min(3*(j-i)*(sum[i]-sum[i-1]),sum[j]-sum[i]);
```

第二次的 $dp$ 数组我们就叫做 $dp$ 吧，$dp_i$ 指治愈 $1$ 到 $i$ 这 $i$ 个村庄，而且最终回到 $i$ 的最小死亡人数（这里要算上所有村庄）。

容易写出状态转移方程：

$$ dp_i=\min\limits_{1\leq j<i}\{dp_j+g_{j+1,i}+(4\times i-4\times j-2)\times\sum\limits_{k=i+1}^n\} $$

$4\times i-4\times j-2$ 仍然是时间，因为要从 $j$ 走到 $i$ 再回到 $j+1$ 而且把 $j+1$ 到 $i$ 这一路上的所有村庄都治愈，然后在从 $j+1$ 回到 $i$：

$$(i-j)+[i-(j+1)]\times 2+[i-(j+1)+1]=4\times i-4\times j-2$$

而 $\sum\limits_{k=i+1}^n$ 同样可以用前缀和优化。

这一部分的代码：

```cpp
for(int i=1;i<=n;++i){
    dp[i]=0x7fffffffffffffffll;
    for(int j=0;j<i;++j)
        dp[i]=min(dp[i],dp[j]+g[j+1][i]+(4*i-4*j-2)*(sum[n]-sum[i]));
}
```

这么做的复杂度是 $O(n^2)$ ，足以通过此题，全部代码如下：

```cpp
#include<stdio.h>
typedef long long ll;
inline ll min(ll a,ll b){return a<b?a:b;}
ll g[3001][3001],dp[3001],sum[3001];
int n;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i){int x;scanf("%d",&x);sum[i]=sum[i-1]+x;}
	for(int i=n;i;--i)for(int j=i+1;j<=n;++j)g[i][j]=g[i+1][j]+sum[j]-sum[i]+min(3*(j-i)*(sum[i]-sum[i-1]),sum[j]-sum[i]);
	for(int i=1;i<=n;++i){dp[i]=0x7fffffffffffffffll;for(int j=0;j<i;++j)dp[i]=min(dp[i],dp[j]+g[j+1][i]+(4*i-4*j-2)*(sum[n]-sum[i]));}
	printf("%lld",dp[n]);
	return 0;
}
```



---

## 作者：Sol1 (赞：2)

这题评绿有点过分了吧，评蓝还差不多。

首先我们发现对于每一个点只有两种选择：

1. 掉头回去把所有前面的村庄都治愈了再回来
2. 继续往前走

但是如果直接做的话复杂度是会炸飞的，考虑如何优化。

首先，我们发现这个路径可以视作若干段 $l\rightarrow r\rightarrow l\rightarrow r$，其中 $l$ 可以等于 $r$。

而且肯定最后一个 $l\rightarrow r$ 是直接走过去而不治愈任何村庄的，所以我们可以先预处理从 $l$ 走到 $r$ 再回到 $l$，并把这一段区间中所有村庄都治愈，死亡的最少人数，设其为 $f_{l,r}$。

然后考虑从哪个区间转移，发现 $f_{l,r-1}\rightarrow f_{l,r}$ 不好弄，所以用 $f_{l+1,r}\rightarrow f_{l,r}$。

分情况讨论：

1. 救 $l$，后面的会死两天。
2. 不救 $l$，后面的会死一天，$l$ 会死 $3\times (r-l)$ 天。

于是就得到转移方程：

$$f_{i,j}=f_{i+1,j}+\min\{2\sum^{j}_{k=i+1}a_k,3a_i(j-i)+\sum^{j}_{k=i+1}a_k\}$$

预处理前缀和可以 $O(n^2)$ 转移。

剩下的就很简单了，设 $g_{i}$ 为救活前 $i$ 个村庄的最少死亡人数，每次枚举 $j$ 使得 $[j+1,i]$ 掉了一次头，然后考虑 $[i+1,n]$ 的贡献。

有转移方程：

$$g_i=\min_{j<i}g_j+f_{j+1,i}+(4i-4j-2)\sum_{k=i+1}^{n}a_k$$

同样可以 $O(n^2)$ 转移，那么就做完了。

代码很短。

```cpp
#include <iostream>
#include <cmath>
#include <cstring>
#include <cstdio>
using namespace std;

#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1 << 21], *p1 = buf, *p2 = buf;

inline int qread() {
	register char c = getchar();
	register int x = 0, f = 1;
	while (c < '0' || c > '9') {
		if (c == '-') f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = (x << 3) + (x << 1) + c - 48;
		c = getchar();
	}
	return x * f;
}

inline long long Abs(const long long& x) {return (x > 0 ? x : -x);}
inline long long Max(const long long& x, const long long& y) {return (x > y ? x : y);}
inline long long Min(const long long& x, const long long& y) {return (x < y ? x : y);}

int n;
long long a[3005], presum[3005], dp[3005][3005], ans[3005];

inline void Read() {
	n = qread();
	for (register int i = 1;i <= n;i++) presum[i] = presum[i - 1] + (a[i] = qread());
}

inline void Prefix() {
	memset(dp, 0x3f, sizeof(dp));
	for (register int i = 1;i <= n;i++) dp[i][i] = 0;
	for (register int l = 2;l <= n;l++) {
		for (register int i = 1;i <= n - l + 1;i++) {
			register int j = i + l - 1;
			dp[i][j] = dp[i + 1][j] + Min(2ll * (presum[j] - presum[i]), 3ll * (j - i) * a[i] + presum[j] - presum[i]);
		}
	}
}

inline void Solve() {
	memset(ans, 0x3f, sizeof(ans));
	ans[0] = 0;
	for (register int i = 1;i <= n;i++) {
		for (register int j = 0;j < i;j++) {
			ans[i] = Min(ans[i], ans[j] + dp[j + 1][i] + (presum[n] - presum[i]) * (4ll * (1ll * i - j) - 2));
		}
	}
	printf("%lld", ans[n]);
}

int main() {
	Read();
	Prefix();
	Solve();
	#ifndef ONLINE_JUDGE
	while (1);
	#endif
	return 0;
}
```

---

## 作者：哈撒各一 (赞：1)

这种绿色的~~紫题~~省选题对我这种蒟蒻太不友好了。

首先我们观察题目，可以发现以下几点已知：

* $n<=3000$ 我们可以考虑 $O(n^2)$的做法

* 每一个村庄都可能有两种情况：1.顺着走过去时就治疗。2.倒回来的时候再治疗。

* 前面的村庄是否治疗对后面的死亡数有影响。

我们根据上几点，可以很容易的想到用区间DP来解决。

我们发现要解决一个区间(i,j)的治疗问题可以转化为村庄i的治疗处理方式+区间(i+1,j)的解决方法。

那么我们就可以很~~显然~~艰难的写出状态转移方程：

$f_{i,j}=f_{i+1,j}+sum_{i+1,j}+min(3 * (i-j) * a_j,sum_{i+1,j})$

接下来我从左到右分析每一项：

$f_{i,j}:$ 我们要求得的目标。

$f_{i+1,j}:$ 我们将目标分解成$i+(i+1,j)$来分析。

$sum_{i+1,j}:$我们不管对i村庄选择哪种处理方法，都要消耗1的时间来移动到i+1。

$3 * (i-j) * a_j:$i村庄的处理情况1.倒回来处理i村庄：我们从$i+1$移动到$j$再从$j$移动到$i+1$一共消耗$2 * (i-j)$的时间，我们在i+1与j之间来回移动时一定已经把这(i-j)个村庄治疗了，消耗$(i-j)$的时间，所以一共消耗$3 * (i-j) $的时间，而在这一段时间里i村庄是一直在死亡的，所以这一段时间的死亡数就是$3 * (i-j) * a_j$。

$sum_{i+1,j}$i村庄处理情况2.直接处理i村庄：因为处理i村庄需要一点时间，所以这一点时间里(i+1,j)的村庄都要死亡，所以这一段时间的死亡数就是$sum_{i+1,j}$。

然而我们上面处理的都是治疗一段区间的情况，并没有确定最终结束点在哪里，而且每一段都是相互独立的。但是经过这一预处理，我们在计算答案的时候就只需要枚举i村庄掉不掉头就可以了。

所以这里我们也可以经过一段~~很长~~时间的思考写出最终答案的转移方程：

$f_i=min(f_i,f_j+g_{j+1,i}+sum_{i+1,n} * (i* 4-j* 4 -2))$

我仍然分析每一项：

$f_i:$ 解决i左边的村庄的治疗问题的代价。

$f_j:$ 将大的问题拆分为小的子问题$f_j+(j+1,i)$来解决。

$g_{j+1,i}:$ 先单独处理区间(j+1,i)。

$sum_{i+1,n} * (i* 4-j* 4 -2):$因为区间(j+1,i)是独立处理的，所以我们要取消他的独立性：我们在处理(j+1,i)时(i+1,n)是一直存在疾病的，所以我们在这段时间内要一直付出代价。而我们消耗的时间可以分为两个部分1.治疗疾病，一共(i-j)个村庄，每一个消耗1单位时间。2.移动，我们要从$j$移动到$i$，再从$i$移动到$j+1$,再从$j+1$移动到$i$。所以我们处理$(j+1,i)$消耗的时间就是$(2 * (i-j-1)+(i-j)+(i-j)=(4 * i - 4 * j - 2)$。

所以这道绿色省选题解~~完美~~艰难的解决了。

**CODE**

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 3010
#define int long long
int n,a[N],s[N];
int f[N],g[N][N];
int ans=LLONG_MAX;
signed main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	cin>>n;
	for(int i=1;i<=n;++i){
		scanf("%lld",a+i);
		s[i]=s[i-1]+a[i];
	}
	for(int i=1;i<=n;++i){
		for(int j=i-1;j;--j){
			g[j][i]=g[j+1][i]+(s[i]-s[j])+min(s[i]-s[j],3*(i-j)*a[j]);
		}
	}
	memset(f,0x3f,sizeof(f));
	f[0]=0;
	for(int i=1;i<=n;++i){
		for(int j=0;j<i;++j){
			f[i]=min(f[i],f[j]+g[j+1][i]+(s[n]-s[i])*(4*i-4*j-2));
		}
	}
	cout<<f[n]<<endl;
	return 0;
}
```


---

## 作者：Denny_Deng (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P5774)

进入[博客](https://www.luogu.com.cn/blog/denny-deng/ans-p5774)食用更佳

---------

首先我们观察题目，可以发现以下几点已知：

- $\because n\leq 3000$，$\therefore$ 我们可以使用 $O(n^2)$ 的算法

- 每一个村庄都可能有两种情况：
  1. 顺着走过去时就治疗；
  2. 倒回来的时候再治疗。

- 前面的村庄是否治疗对后面的死亡数有影响。

**思路一：暴力动态规划**

$\because$ 这种思路的时间复杂度是 $O(n^3)$，而这样的时间复杂度只能拿 $50\%$ 的分。

$\therefore$ 我们需要考虑优化。

**思路二：预处理+动态规划**

$\because$ 动态规划的瓶颈是我们无法快速计算 $i\rightarrow j \rightarrow i$ 途中的最少死亡的人数，

$\therefore$ 我们把两样东西拆开来进行计算。

$\because$ 村庄排成一条链，

$\therefore$ 我们定义 $sumv_i=\sum_{j=1}^ia_j$。

我们定义 $f2_{i,j}$ 为 $i\rightarrow j\rightarrow i$ 途中的最少死亡的人数，枚举 $i$ 为起点，$j$ 为长度，可以得到这个**状态转移**方程：
$$f2_{j,i+j}=f2_{j+1,i+j}+\min \{(sumv_{i+j}-sumv_{j})\times2,a_j\times i \times 3 + sumv_{i+j}-sumv_{j}\}$$
至此，我们用 $O(n^2)$ 的时间复杂度完成了预处理，接下来就是计算答案。

我们定义 $f_i$为当前在村庄 $i$ 并且 $i$ 到 $i$ 以前的村庄疫情消灭的总消失最小人数，我们可以快速得到：
$$f_i=\min\{f_i, f_j+f_{j+1,i}+(4 \times i - 4 \times j - 2)\times (sumv_n-sumv_i)\}$$
至此，时间复杂度是 $O(n^2)$，可以解决问题。

代码如下：
```cpp
// 头文件
#include <set>
#include <map>
#include <list>
#include <queue>
#include <stack>
#include <string>
#include <math.h>
#include <time.h>
#include <vector>
#include <bitset>
#include <memory>
#include <utility>
#include <stdio.h>
#include <sstream>
#include <iostream>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
#define int long long
using namespace std;

const signed N = 3e3 + 10;
const int INF = 0x7fffffffffffffff;

int n/*有n个小镇*/;
int f2[N][N]/*预处理数组*/;
int f[N]/*动态规划数组*/, sumv[N], a[N]/*对于i号村庄每天会有a[i]个村民死去*/;

void init();

int dp();

signed main()
{
    cin.tie(0);
    cout.tie(0);
	cin >> n;
	for (int i = 1; i <= n; ++i)
	{
	    cin >> a[i];
		sumv[i] = sumv[i - 1] + a[i];
	}
	init();
    // 设置最大值
	for (int i = 1; i < N; ++i)
	{
		f[i] = INF;
	}
	f[0] = 0;
	cout << dp() << endl;
	return 0;
}

// 预处理
void init()
{
	for (int i = 1; i <= n - 1; ++i)
	{
	    for (int j = 1; j <= n - i; ++j)
		{
		    f2[j][i + j] = f2[j + 1][i + j] + min((sumv[i + j] - sumv[j]) * 2, a[j] * i * 3 + sumv[i + j] - sumv[j]);
		}
	}
	return ;
}

// 动态规划
int dp()
{
	for (int i = 1; i <= n; ++i)
	{
	    for (int j = 0; j < i; ++j)
		{
		    f[i] = min(f[i], f[j] + f2[j + 1][i] + (4 * i - 4 * j - 2) * (sumv[n] - sumv[i]));
		}
	}
	return f[n];
}

```


---


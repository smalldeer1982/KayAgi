# [CQOI2008] 位统计

## 题目描述

给出 $N$ 个 $[0, 65535]$ 的整数，编程支持以下操作：


修改操作：```C d```，所有数增加 $d$。如果超过 $65535$，把结果模 $65536$。（$0\le d\le 65535$）

查询操作：```Q i```，统计有多少整数的第 $i$ 位非 $0$，换句话说，有多少个整数与 $2^i$ 的“按位与”操作值为正。（$0\le i\le 15$）

输出所有查询操作的统计值。

## 说明/提示

| 测试点编号 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $N$ | $3$ | $10$ | $100$ | $1000$ | $10000$ | $20000$ | $50000$ | $100000$ | $100000$ | $100000$ |
| $M$ | $3$ | $10$ | $100$ | $1000$ | $10000$ | $20000$ | $50000$ | $50000$ | $100000$ | $200000$ |


## 样例 #1

### 输入

```
3 5
1 2 4
Q 1
Q 2
C 1
Q 1
Q 2```

### 输出

```
1
1
2
1```

# 题解

## 作者：一念之间、、 (赞：9)

题意十分明了，

发现修改和询问是对于整个序列进行的处理，且询问只有 $16$ 种，发现在询问 $i$ 的时候比 $i$ 高的位都没有用，

所以考虑对每个 $i$ 开一个桶，记录小于等于 $2^i$ 的所有数是多少，对于 $i$ 询问会发现 $i$ 位为 $1$ 的一定是一段连续的区间，所以同时记录 $dlt$ ，加入一个偏移量，前缀和询问即可，

时间复杂度 $O(16\times2^{16}+n+m)$ 空间复杂度 $O(16\times2^{16})$ 

其实还有另外一个更好想到，更暴力的思路，将前 $8$ 位与后 $8$ 位分别进行处理，后 $8$ 位可以进行枚举，前 $8$ 位按照区间连续段前缀和询问即可

时间复杂度 $O(2^{8}\times m)$ 空间复杂度 $O(2^{16})$ 

这里给出第二种代码实现

```cpp


#include<bits/stdc++.h>
#define ll long long
using namespace std;
int read()
{
	char c;
	int w=1;
	while((c=getchar())>'9'||c<'0')if(c=='-')w=-1;
	int ans=c-'0';
	while((c=getchar())>='0'&&c<='9')ans=(ans<<1)+(ans<<3)+c-'0';
	return ans*w;
}
int n,m,t[65537],s[257],dlt=0;
int get(int l,int r)
{
	if(l<0)l+=65536*20;
	if(r<0)r+=65536*20;
	l%=65536,r%=65536;
	if(l<=r)return t[r]-((l!=0)?t[l-1]:0);
	return get(0,r)+get(l,65535);
}
signed main(){
	n=read(),m=read();
	for(int i=1;i<=n;i++)
	{
		int o=read();
		t[o]++;s[o%256]++;
	}
	for(int i=1;i<65536;i++)t[i]+=t[i-1];
	while(m--)
	{
		char c;
		while((c=getchar())!='C'&&c!='Q');
		if(c=='C')dlt+=read(),dlt%=65536;
		else 
		{
			int a=read(),ans=0;
			if(a<=7)
			{
				for(int i=0;i<256;i++)
					if(i>>a&1)ans+=s[(i-dlt+256*1000)%256];
			}
			else 
			{
				for(int i=0;i<256;i++)
					if(i>>(a-8)&1)ans+=get(i*256-dlt,(i+1)*256-1-dlt);
			}
			cout<<ans<<'\n';
		}
	}
	return 0;
}
```


---

## 作者：JK_LOVER (赞：6)

## 题意
给你 $n$ 个数有如下操作。
- 修改操作：所有数增加 $d$ 。
- 查询操作：统计有多少整数的第 $i$ 位非 $0$ 。
## 分析
- $i$ 并不大，可以考虑单独处理每一位 。
- 考虑修改造成的影响 。瓶颈在于快速遍历数组，考虑如下性质。
$$
2^i \le val\mod 2^{i+1} <2^{i+1}
$$
那么 $val$ 的第 $i$ 位就为 $1$ 。如果有修改的话。
$$
2^i \le val+d\mod 2^{i+1} <2^{i+1}
$$
$$
\Rightarrow 2^i-d \le val\mod 2^{i+1} <2^{i+1}-d
$$
就开 $16$ 颗权值线段树维护。这道题对于细节的处理非常多，结合代码理解更好。而且有可能变成负数记得取模。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){
    int sum=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){sum=sum*10+ch-'0';ch=getchar();}
    return sum*f;
}
const int mod = 65536;
const int N = 410000;
int t[20][N],L[20][N],R[20][N],a[N],n,m,d;
void build(int i,int x,int l,int r)
{
	int mid = l+r>>1;
	L[i][x] = l;R[i][x] = r;
	if(l==r) return;
	build(i,x<<1,l,mid);
	build(i,x<<1|1,mid+1,r);
}
void update(int i,int x,int key)
{
	t[i][x]++;
	if(R[i][x] == L[i][x]) return;	
	int mid = R[i][x] + L[i][x] >> 1;
	if(key <= mid) update(i,x<<1,key);
	else update(i,x<<1|1,key);  	
}
void Insert(int v,int x,int vll){
    if(vll<L[v][x]||R[v][x]<vll)return;
    t[v][x]++;
    if(L[v][x]==R[v][x])return;
    Insert(v,x<<1,vll);
    Insert(v,x<<1|1,vll);
}
int query(int i,int x,int l,int r)
{
	if(r < L[i][x] || l > R[i][x]) return 0;
	if(l <= L[i][x] && R[i][x] <= r) return t[i][x];
	return query(i,x<<1|1,l,r)+query(i,x<<1,l,r);
}
int main()
{
	n = read();m = read();
	for(int i = 1;i <= n;i++) a[i] = read();
	for(int i=0;i<=16;i++) build(i,1,0,((1<<i+1)-1));
	for(int i = 1;i <= 16;i++)
	for(int j = 1;j <= n;j++)
	update(i,1,a[j]%(1<<i));
	for(int i = 1;i <= m;i++)
	{
		char ch[10];
		scanf("%s",ch+1);
		if(ch[1] == 'C')
		{
			d = (1LL*d+mod+read())%mod;
		}
		else 
		{
			int x = read();
			int block = 1<<x+1;
			int l = (((1<<x)-d)%block+block)%block;
			int r = ((block-1-d)%block+block)%block;
			if(l <= r) printf("%d\n",query(x+1,1,l,r));
			else printf("%d\n",query(x+1,1,0,r)+query(x+1,1,l,block-1));
		}
	}
}
```

[地址](https://www.luogu.com.cn/blog/xzc/solution-p5783)

---

## 作者：Str_ywr (赞：2)

# 题意：
题意就是有两个操作 :

一个是把每个数 $+ d \pmod {65536}$。

一个是查询有多少个整数的第 $i$ 位不是 $0$。

# 解决

注意到数据范围是 $2\times10^5$ 并且还是动态更新，容易想到线段树。

那么这道题主要解决的就是：

## 1：怎么查询一个区间内有多少个数满足条件？
如果想要判断一个数的第 $i$ 位是不是 $1$ 这里先丢出来一个结论：

当 $2^i \le$ $val \bmod  2^{i+1} < 2^{i+1}$ 的时候，第 $i$ 位就是 $1$。


我们把这个数 $\bmod 2^{i+1}$ ，就获取了这个数的后 $i$ 位上的结果，如果第 $i$ 位上是 $1$，才可能是 [ $2^i$ , $2^{i+1}$ )。

所以，我们就可以用一个权值线段树来维护有多少个数在这个范围内。


## 2：如何维护$+$ $d$  ?

首先由于取模的性质。

如果 $2^i \le$ $val+d \bmod 2^{i+1} < 2^{i+1}$

那么 $2^i - d \le$ $val \bmod 2^{i+1} < 2^{i+1} - d$

由于是对于全体操作，所以通过记录当前已经累加的 $d$，就可以在查询的时候通过把范围 $- d$ 来得到查询区间。

# 代码
```cpp
#include<bits/stdc++.h>
#define maxn 100005
#define lson i<<1
#define rson i<<1|1
using namespace std;
typedef long long ll;
const int mod=65536;
inline int read() {
    int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9') {
        if (ch == '-')
            f = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = (x<<1)+(x<<3)+(ch^48);
        ch = getchar();
    }
    return x * f;
}
int n,m;
int a[maxn];
struct tr{
	int l,r;
	int sum;
}tree[20][mod<<2];
//线段树开四倍空间，mod是权值大小
//20指的是分别对于每一位上是1，开一颗线段树
void build(int now,int i,int l,int r){
	tree[now][i].l=l;
	tree[now][i].r=r;
	if(l==r) return;
	int mid=(l+r)>>1;
	build(now,lson,l,mid);
	build(now,rson,mid+1,r);
}
void update(int now,int i,int num){
	if(tree[now][i].l<=num&&tree[now][i].r>=num){
		tree[now][i].sum++;
	}else{
		return;
	}
	if(tree[now][i].l==tree[now][i].r) return;
	update(now,lson,num);
	update(now,rson,num);
}
int ask(int now,int i,int l,int r){
	if(r<tree[now][i].l||tree[now][i].r<l) return 0;
	if(l<=tree[now][i].l&&tree[now][i].r<=r) return tree[now][i].sum;
	return ask(now,lson,l,r)+ask(now,rson,l,r);
}
int main(){
	n=read(),m=read();
	for(int i=1;i<=n;i++){
		a[i]=read();
	}
	for(int i=1;i<=16;i++) build(i,1,0,(1<<(i+1))-1);
        //对于第i颗线段树，只用存储0~2^(i+1)-1
	for(int i=1;i<=16;i++){
		for(int j=1;j<=n;j++){
			update(i,1,a[j]%(1<<i));//初始的插入
		}
	}
	ll d=0;
	while(m--){
		char c;
		scanf(" %c",&c);
        	//" %c" 可以吞掉不可见字符
		if(c=='C'){
			d=(d+read())%mod;
            		//统计一下d,最后在询问的时候统一处理	
		}
		else{
			int i=read();
			long long M=1<<(i+1),l=(1<<i)-d,r=(1<<(i+1))-d-1;
            			//这里面l,r就对应的是上文讲到的左右边界，如果在这个范围内，就合法
			l=(l%M+M)%M;//!!! 这个d有可能会减出来负数，这样可以把负数转成正数
			r=(r%M+M)%M;//注意，这里的M不是上文的65536
			if(l>r){
            			//如果l>r。那么对应的区间就应该是l~M-1  和0~r，这两段合法
				cout<<ask(i+1,1,l,M-1)+ask(i+1,1,0,r)<<endl;
			}else{
				cout<<ask(i+1,1,l,r)<<endl;
			}
		}
	}
	return 0;
}


```


---

## 作者：THUD (赞：1)

## 题意
给出 $N$ 个整数，要求实现所有数加 $d$ 与查询多少整数的二进制位的第 $i$ 位为 $1$ 。
## 思路
~~先打开算法标签一看发现啥都没有~~\
有修改与查询操作，自然想到数据结构，由于每个数二进制位最多也就 $16$ 位，可以考虑**分别对于每位用数据结构维护**。
## 如何查询？
我们发现，一个数的**第 $i$ 位为 $1$ 等价于对 $2^i$ 取模后 $\ge 2^{i-1}$**,由于每次都是对全局查询，所以这 $N$ 个数可看作一个无序可重集，直接用数据结构分别维护对 $2^i$ 取模后的权值，查询即对值域区间 $[2^{i-1},2^i)$ 求和。
## 如何修改？
修改也是对全局操作，可考虑**使用一个全局标记记录修改的值**，每次查询时偏移即可。\
无法理解？看这个例子：\
假设开始时对 $2^3$ 取模后得到 $6$ 个数：\
$1$ $2$ $4$ $4$ $5$ $7$\
其中查询值域区间 $[4,7]$ 因此 $4$ $4$ $5$ $7$ 就是二进制第 $3$ 位为 $1$ 的数（这里所说的第 $3$ 位与题中描述不一样，题中位数是从 $0$ 开始的）。若此时对这些数区间加上 $2$ ，原来的数变成了：\
$3$ $4$ $6$ $6$ $7$ $2$\
现在的查询值域区间 $[4,7]$ 原来（即修改操作之前）为 $[2,5]$。\
所以只需查询原来 $[2,5]$ 区间的值即可，这个偏移量正好与序列整体增加的值（即全局标记中所记录的值）相反（注意如果偏移后区间的左端点为负需特殊处理，具体见代码）。
## 如何实现？
可以发现，**全过程都没有对初始序列进行实质性的修改，所以前缀和就能维护**，甚至能做到 $O(1)$ 查询与修改，不用什么线段树。\
具体实现时可以用 `&` 运算符代替取模运算，既跑起来快也不用对负数特判。
## AC代码
``` C++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int N=200005;
const int MOD=65536;
int n,m,tag,a[17][MOD],s[17][MOD];//这里的tag记录的是偏移量，与上文中略有不符
signed main(){
	scanf("%d%d",&n,&m);
	for(int i=1,t;i<=n;i++){
		scanf("%d",&t);
		for(int j=1;j<=16;j++) ++a[j][t&(1<<j)-1];
	}
	for(int j=1;j<=16;j++) partial_sum(a[j],a[j]+(1<<j)+1,s[j]);
	//使用STL求前缀和
	for(int t;m--;){
		char op;
		scanf("\n%c%d",&op,&t);
		if(op=='Q'){
			int l=(1<<t++)+tag,r=tag-1;
			l&=(1<<t)-1;
			r&=(1<<t)-1;
			printf("%d\n",s[t][r]-(l?s[t][l-1]:0)+(l<=r?0:s[t][1<<t]));
			//l=0与r>l时需特判 输出勿忘换行
		}
		if(op=='C') tag=tag-t&MOD-1;//注意这里由于记录的是偏移量所以使用减号
		//使用&运算符能保证tag为正 -的优先级高于&
	}
	return 0;
}
/*
4 3
7 0 1 3
C 3
Q 0
Q 2
*/
```
## 后记
这题也可以每个二进制位中，对于每个偏移量都预处理出当前第 $i$ 位为 $1$ 的数的数量，由于偏移量只有 $65536$ 种所以时空复杂度上与前缀和做法一致，各位若感兴趣也可以尝试实现，这里不再累述。\
第一篇题解，望各位提些建议，多多支持。

---

## 作者：A_Pikachu (赞：0)

### [题目传送门](https://www.luogu.com.cn/problem/P5783)
（如果 $\LaTeX$ 炸了，请到博客[观看](https://www.luogu.com.cn/article/5k1h0js5)）

$\Large\mathscr{P}\mathit{art}\,\,1\;\;\text{基本思路}$

首先注意到如果没有修改操作，那么单纯的查询只需要一次预处理即可高效完成。

然后将修改考虑进来，又注意到对于第 $i$ 位而言，增加的数的大小超过 $2^i$ 的部分并不会对其统计结果有影响，所以自然想到对于每一位各分一组，对于第 $i$ 组只需考虑模 $2^i$ 意义下的原数组。

那么我们只需要它能在记录的同时统计最高位的答案即可。先考虑仅修改一次的情况，对于第 $i$ 组，自然感觉会出现以下几种情况：

1. 最高位为 $0$ 的数在增加后最高位不变。
2. 最高位为 $0$ 的数在增加后第 $i$ 位变为 $1$。
3. 最高位为 $0$ 的数在增加后最高位变为第 $i+1$ 位，不过在模意义下最高位（第 $i$ 位）依然是 $0$，且显然此时不可能是 $1$。
4. 最高位为 $1$ 的数在增加后最高位不变。
5. 最高位为 $1$ 的数在增加后最高位变为第 $i+1$ 位，不过此时在模意义下最高位既可以是 $0$ 也可以是 $1$。

思考后发现，上述情况成立的条件范围均是值域的一段区间，故不难想到排序。对于排序后第 $p$ 个数 $a_p$ 和第一次的修改值 $d$，我们需考虑以下情况：

1. 若 $a_p$ 第 $i$ 位为 $0$，且 $a_p+d<2^i$，则操作对其最高位无影响。
2. 若 $a_p$ 第 $i$ 位为 $0$，且 $2^{i+1}>a_p+d\geq 2^i$，则操作将其最高位变为 $1$。
3. 若 $a_p$ 第 $i$ 位为 $0$，且 $a_p+d\geq 2^{i+1}$，则操作在模意义下对其最高位无影响。
4. 若 $a_p$ 第 $i$ 位为 $1$，且 $a_p+d<2^{i+1}$，则操作对其最高位无影响。
5. 若 $a_p$ 第 $i$ 位为 $1$，且 $2^{i+1}+2^i> a_p+d\geq 2^{i+1}$，则操作在模意义下将其最高位变为 $0$。
6. 若 $a_p$ 第 $i$ 位为 $1$，且 $a_p+d\geq 2^{i+1}+2^i$，则操作对其最高位无影响。

又同时注意到对于全局的增加操作并不会改变排序后数组的顺序，而对于排序后的数组，取所有数的最高位，必然是先有一段为 $0$，再有一段为 $1$。如果将这个性质应用到模意义下的排序数组，那么不同的只是数组最后面的一段数可能会在一次操作后移动（排序）到最前面，即如果将数组视为一个环，每个数的相对顺序在操作后也不会改变。

所以可以将历史操作的和累积下来，每次查询时只需考虑总影响即可。同时，笔者在此为了~~偷懒~~精简代码而记录了累计总和大于等于 $2^i$ 的情况以直接将第 $i$ 位为 $0$ 的数与为 $1$ 的数调换顺序，减少特判。

$\Large\mathscr{P}\mathit{art}\,\,2\;\;\text{Code}$

笔者此处选择了时间复杂度 $\Theta(n\log n\log V+m(\log V+\log n))$ 的~~偷懒~~写法，空间复杂度为 $\Theta(n\log V)$，其中 $V$ 为值域。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+5,Log=17,MOD=65536;
int n,m,u,pm[Log],dm[Log];
char tp;
struct arr{
	int px,cnt[2],tag,nw,a[2][N];
	int qry(){
		int pos1=lower_bound(a[nw]+1,a[nw]+n+1,pm[px]+1-tag)-a[nw]-1;
		int pos2=lower_bound(a[nw]+1,a[nw]+n+1,dm[px]-tag)-a[nw]-1;
		if(pos1>=cnt[nw]) return pos1-pos2;
		return cnt[nw]-pos2;
	}
	void upd(int c){
		tag=(tag+c)&pm[px];
		if(tag>=dm[px]) tag^=dm[px],nw^=1;
	}
}b[Log];
int main(){
	pm[0]=dm[0]=1;
	for(int i=1; i<Log; i++) pm[i]=pm[i-1]<<1|1,dm[i]=dm[i-1]<<1,b[i].px=i;
	scanf("%d%d",&n,&m);
	for(int i=1; i<=n; i++){
		scanf("%d",&u);
		for(int j=0; j<Log; j++){
			b[j].a[0][i]=u&pm[j];
			b[j].a[1][i]=(u&pm[j])^dm[j];
			b[j].cnt[0]+=!(bool)(u&dm[j]);
			b[j].cnt[1]+=(bool)(u&dm[j]);
		}
	}
	for(int j=0; j<Log; j++) for(int k=0; k<=1; k++) sort(b[j].a[k]+1,b[j].a[k]+n+1);
	while(m--){
		scanf(" %c%d",&tp,&u);
		if(tp=='Q'){
			printf("%d\n",b[u].qry());
		}else{
			for(int i=0; i<Log; i++) b[i].upd(u&pm[i]);
		}
	}
	return 0;
}
```

---


# [CQOI2008] 矩阵的个数

## 题目描述

给出一个 $n\times 3$ 的非负整数矩阵的各行各列之和，统计有多少个矩阵满足此条件。输出答案模 $10^{17}$ 的值。

## 说明/提示

| 测试点编号 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $N$ | $1$ | $2$ | $3$ | $10$ | $30$ | $50$ | $80$ | $120$ | $150$ | $200$ |


## 样例 #1

### 输入

```
3 2 3 4
1 2 6
```

### 输出

```
17```

# 题解

## 作者：UnyieldingTrilobite (赞：6)

Update:2020.2.28,修复错别字，麻烦管理员重新过下！

好像只有一篇~~过不了样例~~的题解。

~~据说是为了防抄袭稍改了一下。~~

那就让本juruo来一篇~~高清无注释能AC方便直接复制粘贴的~~题解吧！

大概说说思路，具体的珂以根据代码看/自己思考（如果一步步跟着想的话并不难）。

首先，看起来是不是总觉得和排列组合有千丝万缕的联系？

一般排列组合常用什么方法？

两种：数学/DP。

数学方面这题输入实在太太太太多了，不考虑。

于是乎就只剩下了DP。

状态很好想，自然定义。

$dp_{i,a,b,c}$表示目前填第$i$行，第一列所有数目前和为$a$，二，三列依次为$b,c$的总方案数。

转移方程也很好想，无非就是枚举这一行三列依次放什么数。

**接着开始优化，已经瞬间想出三个优化点的dalao可以跳过。**

首先，状态定义。

我们已经知道了每一行三个数的和，因此前多少行总和我们不都是已知了？

所以如果已知$a,b$那$c$不就被唯一确定了？

然后状态珂以压到二维。

类似转移也珂以。

进一步优化：

你会发现每一个转移只与前一行有关。

所以还可以滚动数组~

完整代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=1e17;
int n,c[109],r[309];
int f[2][129][129];
signed main(){
	scanf("%lld%lld%lld%lld",&n,c+1,c+2,c+3);
	for(int i=1;i<=n;++i)scanf("%lld",r+i);
	//读入
	if(accumulate(r+1,r+n+1,-c[1]-c[2]-c[3]))return puts("0"),0;
	//特判给定条件矛盾
	f[0][0][0]=1;//前0行两列填0（那么第三列也是0）有一种
	for(int i=1;i<=n;++i)
	for(int j=0;j<=c[1];++j)
	for(int k=0;k<=c[2];++k){
		f[i&1][j][k]=0;//注意清零！！！
		for(int l=0;l<=j&&l<=r[i];++l)
		for(int m=0;m<=k&&l+m<=r[i];++m)
		f[i&1][j][k]=(f[i&1][j][k]+f[i&1^1][j-l][k-m])%mod;//枚举这一行放了什么
	}
	printf("%lld\n",f[n&1][c[1]][c[2]]);//输出
	return 0;
}
```

---

## 作者：Saliеri (赞：3)

一种新方法。

___

心路历程：

好，砍掉一维，好像还可以滚，再加上奇怪的优化……**但是复杂度好像是$O(n*125^3)$ 的**，怎么办啊……

打开题解，**，$O(n*125^4)$ 过掉了？！

注：（如果有会分析原题解时间复杂度的，若能私信解惑，本人不胜感激）。

___

分析:

阅读题面，发现是**计数题**。

两种方式：

- 数学排列组合

- DP

此题显然DP。

开始设计状态。发现这是一个 $n*3$ 的矩阵，**3**。

从那三个数入手，以行为阶段。

设 $f\left[i\right]\left[x\right]\left[y\right]\left[z\right]$ 为到了第i行，三列上的数的和分别为x,y,z的矩阵总数。

直接暴力DP为$O(n*125^6)$ 的，转移显然。

第二步，考虑去除冗余维度。

发现前i行所有数的和是确定的，而知道两列的和即可知道第三列。

于是z这个维度可以去掉。

随后发现每一个阶段的转移只与上一个阶段的DP值有关，于是可以滚动数组优化，将空间复杂度降低一个层次。

到现在即得到$O(n*125^4$)的做法。

___

奇怪的优化：

我们考虑每个状态可能转移到的状态。

假设现在考虑的是$f\left[i\right]\left[x\right]\left[y\right]$ 的转移，$sum_i$ 表示这一行的和，而这个状态转移到的位置即为下图阴影部分内的点:

![](https://cdn.luogu.com.cn/upload/image_hosting/z2j8d8wf.png)

外层边缘可以转移显然，内部的点可以通过分配值给z转移到。

对这个三角形逐层进行更新，为了实现$O(1)$的每层更新，维护f的同时维护一个每层的差分数组。

时间复杂度为$O(n*125^3)$，实际上远远达不到。

有细节见代码。

### Code:

```cpp
#include <cstdio>
typedef long long ll;
const int maxn = 205;
const ll mod = 1e17;
int n,val[4],sum[maxn],summ[maxn];
ll dp[130][130],cf[130][130];
inline int min(int a,int b) {return a<b?a:b;}
int main() {
	scanf("%d %d %d %d",&n,&val[1],&val[2],&val[3]);
	for(int i=1; i<=n; ++i)scanf("%d",&sum[i]);
	for(int i=1; i<=n; ++i)summ[i] = summ[i-1] + sum[i];
	cf[0][0] = 1,cf[0][1] = -1;//赋初值f[0][0] = 1
	for(int i=0; i<n; ++i) {
		for(int j=0; j<=min(val[1],summ[i]); ++j)
			for(int k=0; k<=min(val[2],summ[i]); ++k)
				dp[j][k] = cf[j][k];
		for(int j=0; j<=min(val[1],summ[i]); ++j)
			for(int k=0; k<=min(val[2],summ[i]); ++k)
				dp[j][k] = (dp[j][k]+dp[j][k-1])%mod;//每次将最新的DP数组处理出来
		for(int j=0; j<=min(val[1],summ[i]); ++j)
			for(int k=0; k<=min(val[2],summ[i]); ++k)
				if(dp[j][k])//枚举有值的位置进行更新
					for(int row=j; row<=min(j+sum[i+1],125)//若三角形超出边界，不处理即可; ++row){
						cf[row][k+(row==j)] += dp[j][k];//+(row==j)表示不能转移到本身，否则会出现重复更新，导致答案错误
						cf[row][min(125,k+sum[i+1]-(row-j))+1] -= dp[j][k];
						cf[row][k+(row==j)] %= mod;
						cf[row][min(125,k+sum[i+1]-(row-j))+1] %= mod;
					}
	}
	for(int j=0; j<=val[1]; ++j)
		for(int k=0; k<=val[2]; ++k)
			dp[j][k] = cf[j][k];
	for(int j=0; j<=val[1]; ++j)
		for(int k=0; k<=val[2]; ++k) 
			dp[j][k] = (dp[j][k]+dp[j][k-1])%mod;
	printf("%lld\n",(dp[val[1]][val[2]]+mod)%mod);
	return 0;
}
```

---

## 作者：LJ07 (赞：2)

## 题目描述
[题目传送门](https://www.luogu.com.cn/problem/P5784)

## 思路简述
计数容易想是 dp。

不妨定义 $dp[i][s1][s2][s3]$ 表示到了第 $i$ 行，第一列的和是 $s_1$，第二列的和是 $s_2$，第三列的和是 $s_3$ ，$sum_i$ 表示第 $i$ 行数的和。

然而发现 $s_3$ 这一状态事实上是冗余的，可以省去。

此时状态转移方程为 $dp[i][s_1][s_2]=\sum\sum dp[i][s_1-j][s_2-z]$。

且上式中 $j$，$z$，$s_1$，$s_2$ 满足：
- $j+z\le sum_i$ 
- $\sum_{z=1}^i sum_z-s_1+s_2\le c_3$

套路地，我们可以通过枚举 $j$ 这一维，使用前缀和优化第二维 $z$ 的枚举。

更优地，我们还可以滚掉枚举当前是第几行这一维，空间复杂度 $O(125^2)$，时间复杂度 $O(N\times c_1\times c_2)$。

### 丑陋の代码
[click here](https://www.luogu.com.cn/paste/i9q4fl38)

---

## 作者：LimpidSlirm (赞：0)

## 题意

给定一个 $n\times3$ 的矩阵的各行各列之和，求满足条件的矩阵的个数。

## Solution

计数题，考虑朴素 dp，定义 $f_{i,a,b,c}$ 为当前枚举到第 $i$ 行，每列之和分别为 $a$，$b$，$c$ 时的方案数。枚举当前列所填数，令其分别为 $now_1$，$now_2$，$now_3$ 则有转移方程：
$$
\large{f_{i,a,b,c}\gets f_{i-1,a-now_1,b-now_2,c-now_3}}
$$
由于各行，列之和均小于等于 $125$，故每行之和 $val_i$ 大约在 $\frac{125\times 3}{n}$ 左右，每列之和 $sum_i$ 不超过 $125$，故朴素 dp 复杂度约为 $\mathcal{O}(n\times val^3\times sum^3)$，无法在时限内通过本题。故考虑优化。

发现当 $a$，$b$ 确定时，$c$ 也确定，故由此可通过前缀和将第四位优化掉，$now_1$，$now_2$，$now_3$ 同理。故当满足 $\sum^{i}_{k=1}sum_k-a-b \ge 0$ 且 $sum_i-now_1-now_2 \geq 0$ 时有转移方程：
$$
\large{f_{i,a,b}\gets f_{i-1,a-now_1,b-now_2}}
$$
最坏时间复杂度约为 $\mathcal{O}(n\times val^2\times sum^2)$ ，可以通过本题。 

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
	int res=0,flag=1;
	char ch=getchar();
	while(!isalnum(ch)) (ch=='-')?flag=-1:1,ch=getchar();
	while(isalnum(ch)) res=res*10+ch-'0',ch=getchar();
	return res*flag;
}
int val[210];
long long dp[210][210][210];
int main(int argc,const char *argv[])
{
	int n=read();
	int s1=read(),s2=read(),s3=read();
	for(int i=1;i<=n;i++)
		 val[i]=read();
	dp[0][0][0]=1;
	for(int i=1;i<=n;i++)
		for(int n1=0;n1<=s1;n1++)
			for(int n2=0;n2<=s2;n2++)
				for(int d1=0;d1<=n1&&d1<=val[i];d1++)
					for(int d2=0;d2<=n2&&d1+d2<=val[i];d2++)
						dp[i][n1][n2]=(dp[i][n1][n2]+dp[i-1][n1-d1][n2-d2])%(long long)1e17;
	printf("%lld",dp[n][s1][s2]);
	return 0;
}
```

### 写在最后

**三年 OI 一场空，不开 long long 见祖宗**

---

## 作者：cqbz_C202202_xsh (赞：0)

首先考虑 $DP$ ,定义状态 $dp_{i,j,k}$ 表示转移到第 $i$ 行时,所有第 $1$ 列的还未转移的数的和为 $j$ ,所有第 $2$ 列的还未转移的数的和为 $k$ 的总方案数。那么可以写出以下转移方程式：
$$dp_{i,j,k}=\sum_{x=0}^{a_i}\sum_{y=0}^{a_i-x}dp_{i-1,j+x,k+y}$$
若我们将 $i-1$ 的所有 $dp$ 值用一张表表示出来，假设 $a=2$，那么 $dp_{i,j,k}$ 的值即为图中三角形部分。
![](https://cdn.luogu.com.cn/upload/image_hosting/wos2vyk6.png)
考虑如何优化，我们首先发现 $dp_{i,j,k}$ 与 $dp_{i,j-1,k}$ 有一定的重叠部分，从这个地方我们来考虑转移。
再看两者之间所相差的即为
$$\sum _{x=0}^{a_i+1}dp_{i-1,j,k+x}-\sum _{x=0}^{a_i+1}dp_{i-1,j+a_i+1-x,k+x}$$
这两个式子用前缀和求解即可。
时间复杂度 $O(nc^2)$。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,s1,s2,s3,a[100005],sum,dp[130][130],sum1[130][130],sum2[130][130],mod=1e17;
long long Sum1(int x,int l,int r){
	if(r>s2)r=s2;
	return sum1[x][r]-(l?sum1[x][l-1]:0);
}
long long Sum2(int a,int b,int c,int d){
	if(b>=s2)a+=(b-s2),b=s2;
	if(d>=s2)c+=(d-s2),d=s2;
	return ((a>s1||a<0||b>s2||b<0||a+b>s1+s2||a+b<0)?0:sum2[a][b])-((c>s1||c<0||d>s2||d<0||c+d>s1+s2||a+b<0)?0:sum2[c][d]);
}
int main(){
	scanf("%lld%lld%lld%lld",&n,&s1,&s2,&s3);
	for(long long i=1;i<=n;i++){
		scanf("%lld",&a[i]);
		sum+=a[i];
	}
	dp[s1][s2]=1;
	for(long long j=s1;j>=0;j--){
		for(long long l=0;l<=s2;l++){
			sum1[j][l]=((l-1)<0?0:sum1[j][l-1])+dp[j][l];
			sum2[j][l]=((l-1<0||j+1>s1)?0:sum2[j+1][l-1])+dp[j][l]; 
			sum1[j][l]%=mod;
			sum2[j][l]%=mod;
		}
	}
	for(long long i=1;i<=n;i++){
		for(long long j=s1;j>=0;j--){
			for(long long l=s2;l>=0;l--){
				dp[j][l]=dp[j+1][l]+Sum1(j,l,l+a[i]+1)-Sum2(j,l+a[i]+1,j+a[i]+2,l-1);
				dp[j][l]%=mod;
			}
		}
		for(long long j=s1;j>=0;j--){
			for(long long l=0;l<=s2;l++){
				sum1[j][l]=((l-1)<0?0:sum1[j][l-1])+dp[j][l];
				sum2[j][l]=((l-1<0||j+1>s1)?0:sum2[j+1][l-1])+dp[j][l]; 
				sum1[j][l]%=mod;
				sum2[j][l]%=mod;
			}
		}
	}
	if(sum!=s1+s2+s3){
		printf("0");
	}else{
		dp[0][0]+=mod;
		dp[0][0]%=mod;
		printf("%lld\n",dp[0][0]);
	}
	return 0;
}
```


---


# [TJOI2017] 可乐（数据加强版）

## 题目背景

[原题](https://www.luogu.org/problem/P3758) 数据很弱，这个加强版卡掉了暴力的 DP 做法，并且补充了原题题面中缺少的 $\LaTeX$ 。

## 题目描述

加里敦星球的人们特别喜欢喝可乐。因而，他们的敌对星球研发出了一个可乐机器人，并且放在了加里敦星球的 $1$ 号城市上。这个可乐机器人有三种行为： 停在原地，去下一个相邻的城市，自爆。它每一秒都会随机触发一种行为。现在给加里敦星球城市图，在第 $0$ 秒时可乐机器人在 $1$ 号城市，问经过了 $t$ 秒，可乐机器人的行为方案数是多少？

## 说明/提示

【数据规模与约定】  

对于 $20\%$ 的数据， $n,m\leq 30$ ， $t\leq 1000$ ；  

对于 $50\%$ 的数据， $t\leq 10^6$；  

对于 $100\%$ 的数据， $n,m\leq 100$ ， $ t\leq 10^9$ .

【样例解释】

$1$ -> 爆炸

$1$ -> $1$ -> 爆炸

$1$ -> $2$ -> 爆炸

$1$ -> $1$ -> $1$

$1$ -> $1$ -> $2$

$1$ -> $2$ -> $1$

$1$ -> $2$ -> $2$

$1$ -> $2$ -> $3$

## 样例 #1

### 输入

```
3 2
1 2
2 3
2```

### 输出

```
8```

# 题解

## 作者：Kevin_Zhen (赞：19)

题目链接 [$\mathfrak{P5789}$](https://www.luogu.com.cn/problem/P5789)。  
[可能更好的阅读体验](https://www.luogu.com.cn/blog/150cm/solution-p5789)。

### 前置知识
**邻接矩阵 $A$ 的幂**的意义：  
$A^k$ 记录图上任意两点 $u$ 到 $v$ 恰好经过 $k$ 条边的路径数。

对于最初的邻接矩阵 $A$，$A_{i,j}=1$ **当且仅当**存在一条边 $i\Rightarrow j$。注意这里“当且仅当”的含义，如果 $A_{i,j}=1$ 且 $A_{j,k}=1$，但 $i$ 和 $k$ 两点之间没有一条边直接相连，此时的 $A_{i,k}=0$。那么换一个角度理解，$A$ 记录着图上任意两点 $u$ 到 $v$ 恰好经过 $1$ 条边的路径数。  
此时我们令矩阵 $C=A\times A$，由矩阵乘法可知 $C_{i,j}=\sum\limits_{k=1}^n A_{i,k}\times A_{k,j}$，实际上就等于枚举以 $k$ 为中转点，从点 $i$ 到点 $j$ 恰好经过 $2$ 条边的路径数。同理，如果要求经过 $3$ 条边，计算 $C\times A$，即 $A^3$ 即可。那么普适地，$A^k$ 记录图上任意两点 $u$ 到 $v$ 恰好经过 $k$ 条边的路径数。

[参考博客](http://www.matrix67.com/blog/archives/276)。

### 解题思路
对于停在原地的操作，不妨令每座城市连一条自环，理解为走过这条边后回到自己。  
对于爆炸操作，不妨令每座城市连一条**单向边**指向 $0$ 号结点，并使 $0$ 号结点**有且仅有**一条出边指向自己，理解为机器人走到 $0$ 号城市，然后在那不停兜圈。  
问题转变为机器人每一秒**必须**走过一条边，求 $t$ 秒后的行为方案数。  
求出 $A^t$，然后记录 $ans=\sum\limits_{i=0}^n{A^t}_{1,i}$ 即可。

**注意**：$0$ 号城市的自环是必需的。因为 $A^k$ 记录的是**恰好**经过 $k$ 条边。

### AC CODE
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;

const int maxn = 110;
const int Mod = 2017;

struct Matrix {
	int a[maxn][maxn], n, m;
	int* operator [](int x) { return a[x]; }
	void clear() { n = 0, m = 0, memset(a, 0, sizeof(a)); }
} a;

Matrix operator *(Matrix &x, Matrix &y) {
	Matrix z; z.clear(); z.n = x.n, z.m = y.m;
	for (int i = 0; i <= x.n; ++i) {
		for (int j = 0; j <= x.m; ++j) {
			for (int k = 0; k <= y.m; ++k) z[i][k] = (z[i][k] + x[i][j] * y[j][k]) % Mod;
		}
	}
	return z;
}

Matrix qpow(Matrix &base, int p) {
	Matrix res = base; --p;
	while (p) {
		if (p & 1) res = res * base;
		base = base * base;
		p >>= 1;
	}
	return res;
}

int n, m, t, ans;

int main() {
	scanf("%d%d", &n, &m); a.n = n, a.m = n;
	for (int i = 0; i <= n; ++i) a[i][i] = 1, a[i][0] = 1;
	for (int i = 1; i <= m; ++i) {
		int u, v; scanf("%d%d", &u, &v);
		a[u][v] = 1; a[v][u] = 1;
	}
	scanf("%d", &t);
	a = qpow(a, t); for (int i = 0; i <= n; ++i) ans = (ans + a[1][i]) % Mod;
	printf("%d", ans);
	return 0;
}
```


---

## 作者：_Diu_ (赞：13)

双倍经验：[P3758 可乐](https://www.luogu.com.cn/problem/P3758)

~~A 了这题就可乐，没 A 就是可悲勒~~

## DP

如果这一题的 $t$ 范围比较小的话，那么这一题就是一道动规大水题了。

设 $f_{i,u}$ 表示在第 $i$ 秒到达节点 $u$ 的方案数。

那么对于节点 $u$，$f_{i,u}=\sum_{(v,u)\in Edge}f_{i-1,v}$

因为还可以在某一秒站着不动，所以每一个点连一条边通向自己就可以了。

## 处理自爆

### 李姐 1

易得答案为 $\sum_{i=0}^{t}\sum_{j=1}^{n}f_{i,j}$。

只需要在每一次转移时维护一个和 $sum_i=sum_{i-1}+\sum_{j=1}^{i}f_{i,j}$。

最后的答案就是 $sum_t$。

### 李姐 2

就和众多题解一样，我们可以设置一个虚拟点 $n+1$ 表示天堂，

在机器人自爆时升入天堂，

然后强制第 $t$ 秒还没自爆的在第 $t+1$ 秒自爆，

那么答案就是 $f_{t+1,n+1}$。

实现起来和前面的差不多。

那么这一题就可以 $O((n+m)t)$，T 飞了。

## 矩阵快速幂优化 DP

注意到 $f_i$ 的状态只需要从 $f_{i-1}$ 的状态转移过来，

![](https://cdn.luogu.com.cn/upload/image_hosting/7fzxd7xs.png?x-oss-process=image/resize,m_lfit,h_1700,w_2250)

那么我们把转移方程放进去就好了。

## code

```cpp
#include<bits/stdc++.h>
//#define int long long
using namespace std;
const int N=110,p=2017;
int n,m,t;
struct Mat{
	int r,c;
	int mat[N][N];
	Mat(int x,int y){
		memset(mat,0,sizeof(mat));
		r=x,c=y;
	}
	void init(int n){
		memset(mat,0,sizeof(mat));
		for(int i=1;i<=n;i++)mat[i][i]=1;
		r=c=n;
	}
};
Mat operator*(Mat a,Mat b){
	Mat c(a.r,b.c);
	for(int l=1;l<=a.c;l++)
		for(int i=1;i<=a.r;i++)
			for(int j=1;j<=b.c;j++)
				c.mat[i][j]=(c.mat[i][j]+a.mat[i][l]*b.mat[l][j]%p)%p;
	return c;
}
Mat operator^(Mat a,int k){
    Mat c(a.r,a.r);
    c.init(a.r);
    for(;k;k>>=1,a=a*a)if(k&1)c=c*a;
    return c;
}
//矩阵快速幂模板
signed main(){
	scanf("%d%d",&n,&m);
	Mat a(n+1,n+1),ans(1,n+1); 
	ans.mat[1][1]=1;
	for(int i=1,u,v;i<=m;i++){
		scanf("%d%d",&u,&v);
		a.mat[u][v]=1;
		a.mat[v][u]=1;//双向边
	}
	for(int i=1;i<=n;i++)a.mat[i][i]=1;//自己可以原地不动
	for(int i=1;i<=n+1;i++)a.mat[i][n+1]=1;//向虚拟边连边
	scanf("%d",&t),++t;//答案是 ft+1,n+1
	a=a^t;
	ans=ans*a;
	printf("%d\n",ans.mat[1][n+1]);
}
```

---

## 作者：one_cell (赞：6)

##  矩阵快速幂
### 原创思路还是要感谢Zhang_RQ神仙
#### 这道题是让我们求在一个n个点，m条边的无向图中从1号点出发，走T步，每一步可以选一种操作，求方案个数。
#### 假设目前在u点，操作有以下3种：
#### ①若存在一条u-v的边，可以从u走到v
#### ②原地不动
#### ③原地自爆
#### //具体题意可以看https://www.luogu.com.cn/problem/P3758


------------
### 首先思考如何建图：由于n很小，可以直接邻接矩阵。但原地不动和自爆的情况如何考虑?
#### ①原地不动：等价于往自己连了一个自环，令f[i][i]=1
#### ②原地自爆：我们可以建一个表示自爆的0号城市。则不难发现，只要从1~n这些点都向0号点连一条单向边即可，令f[i][0]=1


------------


### 暴力搜索一定没有前途，T<=1e9
### 一. 我们思考如何在图中进行DP：
### 设f[i][j]表示从i走到j的方案个数,不难发现：f[i][j]=∑f[i][k]*f[k][j]（乘法原理）
### 则Answer=∑ f[1][i]


------------

### 那我们跑一遍DP，即可求出答案（有点像Floyd）
### 注意：这里的DP****并不是O（n^3)****，我们实际的状态是f[t][i][j]，有一个走了t步的限制
### 则时间复杂度为O(T*n^2)
### T<=1e9，还是不行


------------
### 思考如何优化
### 二. 考虑矩阵乘法
### 我们发现：这里的n，m<=100，但T<=1e9。两个数大小相差甚远
### 一般这种情况可以考虑如何用矩乘优化


------------
### 我们观察矩阵乘法的基本形式
    matrix operator * (const matrix &A,const matrix &B)
    {
        matrix C;
        C.n=A.n;C.m=B.m;
        for(int i=0;i<=C.n;i++)
            for(int j=0;j<=C.m;j++)
                for(int k=0;k<=A.m;k++)
                {
                    C.c[i][j]=(C.c[i][j]+A.c[i][k]*B.c[k][j])%mod;
                }
        return C;
    }
### 定理：设现在有一个矩阵A，则A^k含义即是，对于一个A[i][j]，表示从i到j走k步的方案总数  
------------
## 证明：
### 先抛开矩阵乘法，单纯地思考用DP如何做这道题。
#### 设f[i][j][k]表示从i到j，走了k步的方案个数。
#### 初始化：f[i][j][0]没有意义。我们直接看k=1时的初始化
#### 当k=1时其实就是这张图的邻接矩阵。对于一条边u-v，我们令f[u][v][1]=f[v][u][1]=1
#### 然后考虑状态转移：
#### f[i][j][k]=∑ f[i][p][k-1]*f[p][j][1]
#### 然后我们发现：k这一维只与k-1维有关系。所以我们可以省略这一维。就变成了f[i][j]=∑ f[i][p]*f[p][j]
#### 然后与朴素的快速幂一比较，发现大同小异，这样问题其实就转化了求A矩阵的T次方
#### 则以上问题就得到了证明


------------

### 一遍矩阵快速幂，轻松跑过~

## 详见代码：



    #include<iostream>
    #include<cstdio>
    #include<algorithm>
    #include<cstring>
    using namespace std;
    const int N=110,mod=2017;
    int n,m,T;
    struct matrix
    {
        int n,m,c[N][N];
        matrix()
        {
            n=m=0;
            memset(c,0,sizeof(c));
        }//初始化
    };
    matrix operator * (const matrix &A,const matrix &B)
    {//自定义函数（乘法）
        matrix C;
        C.n=A.n;C.m=B.m;
        for(int i=0;i<=C.n;i++)
            for(int j=0;j<=C.m;j++)
                for(int k=0;k<=A.m;k++)
                {
                    C.c[i][j]=(C.c[i][j]+A.c[i][k]*B.c[k][j])%mod;
                }
        return C;
    }//普通的矩阵乘法
    matrix ksm(matrix a,int b)
    {
        matrix ans;
        ans.n=ans.m=n;
        for(int i=0;i<=n;i++)ans.c[i][i]=1;
        //对角矩阵，累计答案
        while(b)//与正常的快速幂同理
        {
            if(b&1)ans=ans*a;
            a=a*a;
            b>>=1;
        }
        return ans;
    }//矩阵快速幂
    int main()
    {
        scanf("%d%d",&n,&m);
        matrix t;
        t.n=n;t.m=n;
        for(int i=1;i<=m;i++)
        {
            int u,v;
            scanf("%d%d",&u,&v);
            t.c[u][v]=t.c[v][u]=1;
            //原图中的邻接矩阵
        }
        for(int i=0;i<=n;i++)t.c[i][i]=1;
        for(int i=1;i<=n;i++)t.c[i][0]=1;
        //连自环和0号城市
        scanf("%d",&T);
        matrix res=ksm(t,T);//T次方即是答案
        int ans=0;
        for(int i=0;i<=n;i++)ans=(ans+res.c[1][i])%mod;
        //统计答案
        printf("%d",ans);
        return 0;
    }

---

## 作者：黑影洞人 (赞：4)

这道题看第一眼没有头绪。

再看一下数据范围，$t \leq 10^9$，说明这题的时间复杂度不可能有含 $t$ 的一次项。

看一下样例，用邻接矩阵表示出来：

$\begin{bmatrix} 
	1 & 1 & 0
 \\ 1 & 1 & 1
 \\	0 & 1 & 1 
\end{bmatrix}\quad$

停留在原地就是自环，对角线为 $1$ 即可。

还有一个条件我们没有考虑到，那就是自爆。于是我们把自爆定义为 $ 0 $ 节点。

$\begin{bmatrix} 
	1 & 0 & 0 & 0
\\	1 & 1 & 1 & 0
 \\ 1 & 1 & 1 & 1
 \\	1 & 0 & 1 & 1 
\end{bmatrix}\quad$

自爆有这个性质，爆炸了就不能走了，所以要建有向边。

于是我们想到了矩阵加速（矩阵乘法）来做这道题

每过一秒，矩阵就会变化，每个点会从和他连了边的节点转移过来。

根据乘法原理，节点 $ x $ 经过变化后得 $ X = \sum_{i=1}^N\sum_{j=1}^Na_{i,j}* M_{i,j}$

其中 $x$ 所在的行即为 $X$

最后发现这是一个矩阵乘法。

$ t $ 次操作可以用矩阵快速幂实现。

时间复杂度 $O(nm\log_2t)$

统计答案如何处理？

就记录过了 $t$ 秒后从 $1$ 走到了哪里。

于是 $ ans=\sum_{i=1}^N a_{1,i} $

上代码：

```
#include<cstdio>
#include<algorithm>
#include<cstring>
#define N 100
#define p 2017
using namespace std;
int n,m,t;
struct M{
	int m[105][105];
	M operator *(const M &s)const{
		M a;
		memset(&a,0,sizeof(a));
		for(int i=0;i<=N;i++)
			for(int j=0;j<=N;j++)
				for(int k=0;k<=N;k++)
					a.m[i][j]=(a.m[i][j]+m[i][k]*s.m[k][j]%p)%p;
		return a;		
	}
	M operator ^(const int &s)const{
		M res,a;
		memset(&res,0,sizeof(res));
		memset(&a,0,sizeof(a));
		for(int i=0;i<=N;i++){
			res.m[i][i]=1;
			for(int j=0;j<=N;j++)a.m[i][j]=m[i][j];
		}
		int b=s;
		while(b){
			if(b&1)res=res*a;
			a=a*a;
			b>>=1;
		}
		return res;
	}
	int ans(int n){
		int res=0;
		for(int i=0;i<=n;i++)res=(res+m[1][i])%p;
		return res;
	}
}sy;
signed main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		int u,v;
		scanf("%d%d",&u,&v);
		sy.m[u][v]=sy.m[v][u]=1;
	}
	for(int i=0;i<=n;i++)sy.m[i][i]=1;
	for(int i=1;i<=n;i++)sy.m[i][0]=1;
	scanf("%d",&t);
	sy=sy^t;
	printf("%d",sy.ans(n));
	return 0;
}


```

---

## 作者：vectorwyx (赞：1)

朴素的dp很好推：令 $dp_{i,j}$ 表示于 $i$ 时刻走到了点 $j$ 的方案数。那么转移方程为 $dp_{i,j}=\sum_{k=1}^{n}dp_{i-1,k}\times Z_{k,j}$，其中 $Z$ 为邻接矩阵，$Z_{i,j}$ 表示 $i,j$ 之间有没有边相连。注意，由于机器人可以停在原地，因此我们需要对每一个点都连一条自环，也就是令 $Z_{i,i}=1$。

初始化：$dp_{0,1}=1$，其余均为0。最终答案为  $\sum_{i=0}^{t}\sum_{j=1}^{n}dp_{i,j}$（需要算上在 $i,j$ 自爆的方案数）。

这样的时间复杂度为 $O(tn^{2})$，无法通过此题。考虑矩乘优化，则有 $dp_{i}=dp_{i-1}\times Z$，所以$dp_{t}=dp_{0}\times Z^{t}$，利用矩阵快速幂我们可以用$O(n^{3}\log{t})$ 的复杂度递推出$dp_{t}$。

这里有一个问题，我们之前计算答案需要用到 $dp_{i}(i\le t)$，但现在我们只知道 $dp_{t}$，也就是说自爆的方案数我们无法统计。因此我们需要建一个虚点 $n+1$，满足从这个点无法到达其它点，而从其它点都可以到达这里，那么从其它点到达这里就等同于在其它点自爆。加入这个虚点递推出 $dp_{t}$ 后求和即可。

代码如下（吸氧后拿到了[最优解](https://www.luogu.com.cn/record/39663834)）：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring> 
#define ll long long
#define fo(i,x,y) for(register int i=x;i<=y;++i)
#define go(i,x,y) for(register int i=x;i>=y;--i)
using namespace std;
inline int read(){ int x=0,fh=1; char ch=getchar(); while(!isdigit(ch)){ if(ch=='-') fh=-1; ch=getchar(); } while(isdigit(ch)){ x=(x<<1)+(x<<3)+ch-'0'; ch=getchar(); } return x*fh; }

const int maxn=105,yrz=2017;

struct Mat{
	int n,m;
	int a[maxn][maxn];
	void zero(){
		n=0,m=0;
		memset(a,0,sizeof a);
	}
}A,dp,Z,B,I,C;
int n,m,t;

Mat operator*(const Mat &x,const Mat &y){
	A.zero();
	A.n=x.n;
	A.m=y.m;
	fo(i,1,A.n)
		fo(j,1,A.m){
			fo(k,1,x.m) A.a[i][j]+=x.a[i][k]*y.a[k][j];
			A.a[i][j]%=yrz;
		}
	return A;
}

Mat ksm(const Mat &x,int y){
	if(y==0) return I;
	C=ksm(x,y/2);
	C=C*C;
	return y&1?C*x:C;
}

int main(){
	Z.n=Z.m=I.n=I.m=n=read()+1,m=read();
	fo(i,1,n) I.a[i][i]=Z.a[i][i]=1;
	fo(i,1,n-1) Z.a[i][n]=1;
	fo(i,1,m){
		int x=read(),y=read();
		Z.a[x][y]=Z.a[y][x]=1;
	}
	int t=read();
	dp.n=1,dp.m=n;
	dp.a[1][1]=1;
	B=ksm(Z,t);
	dp=dp*B;
	int ans=0;
	fo(i,1,n) ans+=dp.a[1][i];
	cout<<ans%yrz;
	return 0;
}
```


---

## 作者：pyyyyyy (赞：1)

**定义**

阶为$n$的图$G$的邻接矩阵$A$是$n \times n$的。将$G$的顶点标签为$v_1,v_2,...,v_n$。若$(v_i,v_j) \in E(G)$，$A_{ij}=1$，否则$A_{ij}=0$。也可以用大于0的值表示边的权值，例如可以用边权值表示一个点到另一个点的距离。

**特性**
设图$G$的邻接矩阵为$A$，边的取值为1。

* 如果顶点有自我连接产生的自环，则在矩阵的主对角线上会有非零的值；如果没有自环，则主对角线上全部是0。
* $A^n$的元素$A^n_{ij}$可以表示由顶点$i$到顶点$j$长度为$n$的径的数目。 
* $G$没有有向圈若且唯若 $ I-A$可逆。 $(IA)^{-1}$的元素$ij$表示由顶点$i$到顶点$j$的所有径的数目。因为：$ (I-A)^{-1} = I A A^2 A^3 ... $

以上内容来自[维基百科](https://zh.wikipedia.org/w/index.php?title=%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5&action=edit&section=3)

这道题就是利用了第二个特性

如果单纯考虑走的话，大那就是$\sum\limits_{i=1}^{n}A[1][i]$

那么如何考虑不动和爆炸的情况呢？

不动简单，我要给每个节点连上自环，这样就相当于不动了

那么爆炸呢？

爆炸需要满足两个条件

- 爆炸不能够还原
- 所有点都随时能够选择爆炸

这样我们就可以把所有点连接到一个点（虚拟的）上去，这个点除了自己连边外不连其他边

这样就满足了上面的两个条件

```cpp
/*
@ author:pyyyyyy
-----思路------
-----debug-------

*/
#include<bits/stdc++.h>
using namespace std;
const int N=150;
const int mod=2017;
struct Matrix
{
	int m[N][N];
}a,ans;
Matrix mul(Matrix x,Matrix y)
{
	Matrix c;
	memset(c.m,0,sizeof(c.m));
	for(int i=0;i<=100;++i)
		for(int j=0;j<=100;++j)
			for(int k=0;k<=100;++k)
				c.m[i][j]=(c.m[i][j]+x.m[i][k]*y.m[k][j])%mod;
	return c;		
}
Matrix ksm(Matrix &a,int b)
{
	Matrix ret;
	memset(ret.m,0,sizeof(ret.m));
	for(int i=1;i<=100;++i) ret.m[i][i]=1;
	while(b)
	{
		if(b&1) ret=mul(ret,a);
		a=mul(a,a);
		b>>=1;
	}
	return ret;
}
int n,m,t;
void add(int u,int v)
{
	a.m[u][v]=1;
}
int main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	cin>>n>>m;
	for(int i=1;i<=m;++i)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		add(u,v);add(v,u);
	}
	for(int i=0;i<=n;++i) add(i,i);
	for(int i=1;i<=n;++i) add(i,0);
	cin>>t;
	Matrix cnt=ksm(a,t);
	int ans=0;
	for(int i=0;i<=n;++i) ans=(ans+cnt.m[1][i])%mod;
	cout<<ans;
	return 0;
}
```

---

## 作者：Fairicle (赞：1)

第一思路：dp。

设 $f_{i,j,0}$ 为还未爆炸过的方案数。$f_{i,j,1}$为爆炸过的方案数。

则有 $f_{i,j,0}$ $=$ $\sum\limits_{a_{j,k}=1}$ $f_{i-1,k,0}$ $+$ $f_{i-1,j,0}$

$f_{i,j,1}$ $=$ $f_{i-1,j,0}$ $+$ $f_{i-1,j,1}$

第一维可以滚动一下，省空间。

时间复杂度~~大概是~~ $O(tm)$

正解：矩阵快速幂加速

邻接矩阵建图，设为 $A$

$A^k[i][j]$ 代表的是从 $i$ 到 $j$ 经过 $k$ 秒之后的方案数。

考虑一层递推，必有类似于Floyd的 

$A^k[i][j]$ $=$ $\sum\limits$ $A^{k-1}[i][k]\ *A^1[k][j]$

上面这个式子显然是可以矩阵加速的。

然而这道题还有停留在原地和自爆两种~~奇怪的~~设定。其实也很容易解决，对于停留，每个点都连一个自环即可，自爆就可以建一个爆炸点 $0$，所有点都向其连边，且这个点无出边，就做到了只进不出。

时间复杂度是 $O(n^3logt)$

接下来就是~~喜闻乐见的~~上代码时间
```cpp
#include"bits/stdc++.h"
using namespace std;
#define ll long long
#define ul unsigned long long
#define ui unsigned int
#define ri register int
#define pb push_back
#define mod 2017
inline int read(){
	int x=0,flag=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-') flag=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+(ch^48);ch=getchar();}
	return x*flag;
}
struct node{
	int a[110][110];
}p;
int n,m,t;
inline int lowbit(int x){return x & ( - x ) ;}
inline node mul(node x,node y){
	node ans;
	for(ri i=0;i<=100;++i)
	for(ri j=0;j<=100;++j)
	ans.a[i][j]=0;
	for(ri i=0;i<=100;++i)
	for(ri j=0;j<=100;++j)
	for(ri k=0;k<=100;++k)
	ans.a[i][j]+=x.a[i][k]*y.a[k][j],ans.a[i][j]%=mod;
	return ans;
}
inline node qpow(node x,int y){
	node res;
	for(ri i=0;i<=100;++i)
	for(ri j=0;j<=100;++j)
	res.a[i][j]=(i==j)?1:0;
	while(y)
	{
		if(y&1) res=mul(res,x);
		x=mul(x,x);
		y>>=1;
	}
	return res;
}
int main()
{
	n=read(),m=read();
	int x,y;
	for(ri i=1;i<=m;++i)
	{
		x=read(),y=read();
		p.a[x][y]=p.a[y][x]=1;
	}
	for(ri i=1;i<=n;++i)
	p.a[i][0]=1;
	for(ri i=0;i<=n;++i) p.a[i][i]=1;
	t=read();
	node ans=qpow(p,t);
	ll pp=0;
	for(ri i=0;i<=n;++i)
	pp+=ans.a[1][i],pp%=mod;
	cout<<pp;
    return 0;
}
```


---

## 作者：YuanZihan1225 (赞：0)

传送门：[P5789](https://www.luogu.com.cn/problem/P5789)

## 前置知识：

**邻接矩阵**中 $A^k$ 的意义：

$A ^ k$　记录了图上任意两点 u 到 v 恰好经过了 k 条边的路径数。

### 证明：

考虑矩阵乘法的定义：

$$
C = A \times B
$$

$$
C _ {i, j} = \sum _ {k = 1} ^ n A _ {i, k} \times B _ {k, j}
$$

那么：

$$
A ^ 2 _ {i, j} = \sum _ {k = 1} ^ n A _ {i, k} \times A _ {k, j}
$$

邻接矩阵 $A$ 中的元素都是用 $0$ , $1$ 来表示是否联通的，或者说，代表有没有方法从 $i$ 走到 $j$ 。那么， $A _ {i, k} \times A _ {k, j}$ 就是表示从 $i$ 走到 $k$ 再走到 $j$ 是否可行。可以发现， $A ^2$ 就是取了一个 $\sum$ ，其实就是统计用 $2$ 步从 $i$ 走到 $j$ 的方法总数。

## 进入正题：

- 题目大意：给出一个无向图，有一个机器人，初始在 $1$ 号城市，每秒有三种操作：停在原地、去下一个城市、自爆，求经过 $t$ 秒后机器人行为的方案数。

- 题意分析：所以我们要想办法对停在原点和自爆建边。

	1. 停在原点：就是每个点都有一条自环，这样机器人从自己走到自己相当于停在原地。
	2. 自爆：就是以后再也不走了，那么我们让它走到一个原图以外的点，不再出来，继续再里面绕圈，呆够 $t$ 秒，可以添加一个 $0$ 号点，每个点都向 $0$ 号点建一条**单向边**，注意 $0$ 号点也要建自环边。

- 现在问题就变成了机器人每一秒**必须**走过一条边，求 $t$ 秒后的行为方案数，于是我们只需要求：

$$
\sum _ {i = 0} ^ n A ^ t _ {1, i}
$$

**注意： 0 号城市的自环是必须的**，因为 $A ^ k$ 记录的是**恰好**经过 $k$ 条边，如果不加自环就不会计算机器人自爆后的路程。

代码我就不给了，希望大家自己写。（~~如果实在写不出可以参考其他神犇的题解~~）。

---

## 作者：ricky0916 (赞：0)

(双倍经验：[数据弱化版](https://www.luogu.com.cn/problem/P3758))

题目简述：一个机器人每一秒有三次操作：原地不动，去下一个相邻的城市，爆炸，问$ k $秒后有多少种不同的走法。

# Solution:

前置知识1：[矩阵快速幂](https://www.luogu.com.cn/problem/P3390)

前置知识2：若矩阵A表示一张图的邻接矩阵（仅包含0,1），那么$ A^k $的i行j列表示从i节点到j节点走k步的结果

好我们看看如何将这题转换成一张图 ~~（如何转换成前置知识2）~~

$1.$ 停在原地。这种操作就相当于自环，$a[i][i]=1$

$2.$ 去下一个相邻的城市。这种操作即为基础的邻接矩阵,$a[i][j]=a[j][i]=1$

$3.$ 自爆。开一个虚拟节点$0,a[i][0]=1,a[0][i]=0$

注意：有可能自爆后不到$t$步，所以为了设自爆后最后还有$t$步，$ a[0][0]=1$

最后，答案即为（令$ A $为邻接矩阵,$A[i][j]$表示矩阵$ A $的第$ i $行第$ j $列）$ \sum_{i=0}^n(A^t)[1][i] $

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=2017;
int n,m,s,t;
struct jz{
	int a[110][110];
	jz operator *(jz b){
		jz tmp;
		for(int i=0;i<=n;i++){
			for(int j=0;j<=n;j++){
				tmp.a[i][j]=a[i][0]*b.a[0][j]%mod;
				for(int k=1;k<=n;k++){
					tmp.a[i][j]=(tmp.a[i][j]+a[i][k]*b.a[k][j])%mod;
				}
			}
		}
		return tmp;
	}
	void print(){
		for(int i=0;i<=n;i++){
			for(int j=0;j<=n;j++){
				printf("%d ",a[i][j]);
			}putchar('\n');
		}
		
	}
}danwei,juzhen;
void init(){
	for(int i=0;i<=n;i++){
	    danwei.a[i][i]=1;
	    juzhen.a[i][0]=1;
	    juzhen.a[i][i]=1;
	}
}
jz ksm(jz n,int m){
	if(m==0) return danwei;
	if(m&1) return ksm(n*n,m/2)*n;
	return ksm(n*n,m/2);
}
int main(){
	scanf("%d%d",&n,&m);
	init();
	for(int i=0;i<m;i++){
		scanf("%d%d",&s,&t);
		juzhen.a[s][t]=juzhen.a[t][s]=1;
	}
	scanf("%d",&t);
	jz ans=ksm(juzhen,t);
	int an=0;
	for(int i=0;i<=n;i++){
		an=(an+ans.a[1][i])%mod;
	}
	printf("%d",an);
	return 0;
}
```


---

## 作者：Link_Space (赞：0)

首先读题，应该第一个想到的做法是DP，但是看到t的范围之后可以发现普通DP不可做，就开始想怎么去优化这个DP，最容易想到的就是用矩阵快速幂来快速求解DP，只要想到了矩阵快速幂来优化，转移矩阵也很快就可以构造出来，所以这道题并不算难，只需要思路顺流下来就可以想出做法了，以下是代码，思路在代码中详细讲解。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<vector>
using namespace std;
typedef long long ll;
int sq[105][105];
int n, m;
int t;
void mul(int c[][105],int a[][105],int b[][105])
{
	int temp[105][105];
	memset(temp, 0, sizeof temp);
	for (int k = 0; k <= n;k++)
	{
		for (int i = 0; i <= n;i++)
		{
			for (int j = 0; j <=n;j++)
			{
				temp[i][j] = (temp[i][j] + (ll)a[i][k] * b[k][j]) % 2017;
			}
		}
	}
	memcpy(c, temp, sizeof temp);
}//矩阵乘法板子
int main()
{
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m;i++)
	{
		int a, b;
		scanf("%d%d", &a, &b);
		sq[a][b] = sq[b][a] = 1;//给a,b之间建一条双向边
        
        //由于这个图的范围并不大，所以只需要用一个邻接矩阵就可以了，也方便了我们直接使用矩阵快速幂
	}
	for (int i = 0;i<=n;i++)
		sq[i][i] = 1;//此处是处理在原地不动的情况
	for (int i = 1;i<=n;i++)
		sq[i][0] = 1;//此处时原地自爆的情况
	scanf("%d", &t);
	int res[105][105];
	for (int i = 0; i <= n;i++)
	{
		res[i][i] = 1;//单位矩阵
	}
	while (t)
	{
		if (t & 1)
			mul(res, res, sq);
		mul(sq, sq, sq);
		t >>= 1;
	}//矩阵快速幂来快速求解
	int ans = 0;
	for (int i = 0; i <= n;i++)
	{
		ans = (ans + res[1][i]) % 2017;//答案为res[1][i]之和，res[i][j]表示从i到j的方案数，故只需要将1到每个点的方案数全部加上来就是所有的方案数
	}
	printf("%d", ans);
}
```


---

## 作者：JWRuixi (赞：0)

~~个人认为这道题很难理解~~


------------


### 题意
~~差不多就是说在一张无向图上，三种不同的选择：跑路、龟缩（不动）或升天，最后问你有怎样的结局~~

正经点就是：一张无向图，你可以选择走一条边或是原地不动或是直接结束，问在 $t$ 时间内有多少中走法。

### 思路
我觉得比较难想，把自己在家里闷了一晚上后得出结论：如果我们预处理一个矩阵 $g$ 使得 $g_{u,v}$ 表示从 $u$ 节点到 $v$ 节点有一条路；这时候我们在回忆一下矩阵乘法的定义： 

$g_{i,j}=\sum\limits_{k=1}^na_{i,k}b_{k,j}$ 

仔细琢磨一下 $a_{i,k}$ 表示从节点 $i$ 走到节点 $k$ 的种数，而 $b_{k,j}$ 表示从节点 $k$ 走到 节点 $j$ 的情况数，这一累积不就是从兜个圈从 $i$ 走到 $j$ 的情况数吗！

所以 $t$ 时间走过的情况其实就是矩阵的时间次幂

补一嘴，对于原地不动可以视为自环，对于自爆可以视为去了一个超级汇点

于是，直接上

### code：
```cpp
#include <bits/stdc++.h>
#define mod 2017
using namespace std;
//模数 
namespace q_wr {
	inline int read() {
		char c = getchar();
		int x = 0, f = 1;
		for (; !isdigit(c); c = getchar()) {
			if (c == '-') f = -1;
		}
		for (; isdigit(c); c = getchar()) {
			x = (x << 1) + (x << 3) + c - '0';
		}
		return x * f;
	}
	inline void write(int x) {
		if (x < 0) {
			x = ~(x - 1);
			putchar('-');
		}
		if (x > 9)
			write(x / 10);
		putchar(x % 10 + '0');
	}
}
  
using namespace q_wr;
  
int n, m, t;
  
struct matrix {
	int g[200][200];
	matrix () { memset(g, 0, sizeof g); }
	inline matrix operator * (const matrix b) const {
		matrix res;
		for (int i = 0; i <= n; i++) 
			for (int j = 0; j <= n; j++)
				for (int k = 0; k <= n; k++)
					res.g[i][j] = (res.g[i][j] + g[i][k] * b.g[k][j]) % mod;
		return res;
	}//由定义得 
};
//这里定义一下矩阵，用结构体 
matrix ans;
   
inline matrix mypow (int k, matrix base) {
	matrix res;
	for (int i = 0; i <= n; i++) {
		for (int j = 0; j <= n; j++) {
			res.g[i][j] = base.g[i][j];
		}
	}
	k--;
	while (k) {
		if (k & 1) 
			res = res * base;
		k >>= 1;
		base = base * base;
	}
	return res;
}
//快速幂 
int main () {
	n = read(), m = read();
	while (m--) {
		int u = read(), v = read();
		ans.g[u][v] = ans.g[v][u] = 1;
	}
	for (int i = 0; i <= n; i++) {
		ans.g[i][0] = 1;
		ans.g[i][i] = 1;
	}//处理自爆和不动 
	t = read();
	ans = mypow(t, ans);
	int res = 0;
	for (int i = 0; i <= n; i++)
		res = (res + ans.g[1][i]) % mod;//答案为从起点出发的所有情况 
	write(res);
}
```

---

## 作者：Plozia (赞：0)

宣传博客 $\to$ [link](https://blog.csdn.net/BWzhuzehao/article/details/117827004)

---------

这道题有一道数据弱化版，切了这道题的各位可以顺便把弱化版给切了。

做这道题首先需要知道一个结论：

设一张无向图 $G=<V,E>$，$A$ 是其邻接矩阵表示是否连通，设 $k \in N_+$，那么做矩阵快速幂 $A^k$ 之后 $A_{i,j}$ 表示 $k$ 步后 $i \to j$ 有多少种方案。

证明可以考虑设 $f_{i,j,k}$ 为 $k$ 步后 $i \to j$ 的方案数，那么有转移方程：

$$f_{i,j,k}=\sum f_{i,v,k-1} \times f_{v,j,k-1}$$

我们发现这就是矩阵乘法的定义式，而 $f_{i,j,1}$ 就是邻接矩阵。

于是这就等价于 $A^k$。

---------

考虑题目中的三种走法：

- 移动到相邻的城市。

这个直接在邻接矩阵里面存好了。

- 停在原地。

每个点向自己连边。

- 自爆。

建立一个自爆节点 $n+1$，$[1,n]$ 内的所有点往 $n+1$ 连边，相当于走到这个点就不能走了，也就是自爆。

注意：$n+1$ 不能向自己连边。

连边之后求出 $A^t$，答案就是 $\sum_{j \in[1,n+1]} A^t_{1,j}$。

---------

Code：

```cpp
/*
========= Plozia =========
    Author:Plozia
    Problem:P5789 [TJOI2017]可乐（数据加强版）
    Date:2021/6/11
========= Plozia =========
*/

#include <bits/stdc++.h>

typedef long long LL;
const int MAXN = 100 + 5, P = 2017;
int n, m, t;

struct Matrix
{
    LL a[MAXN][MAXN];
    int r, c;
    void init()
    {
        memset(a, 0, sizeof(a));
        for (int i = 1; i <= r; ++i) a[i][i] = 1;
    }
    Matrix operator *(const Matrix &fir)
    {
        Matrix tmp; memset(tmp.a, 0, sizeof(tmp.a));
        tmp.r = r; tmp.c = fir.c;
        for (int i = 1; i <= r; ++i)
            for (int k = 1; k <= c; ++k)
            {
                LL t = a[i][k];
                for (int j = 1; j <= fir.c; ++j)
                    { ((tmp.a[i][j] += t * fir.a[k][j]) >= P) ? (tmp.a[i][j] %= P) : 0; }
            }
        return tmp;
    }
}Base;

int Read()
{
    int sum = 0, fh = 1; char ch = getchar();
    for (; ch < '0' || ch > '9'; ch = getchar()) fh -= (ch == '-') << 1;
    for (; ch >= '0' && ch <= '9'; ch = getchar()) sum = (sum << 3) + (sum << 1) + (ch ^ 48);
    return sum * fh;
}
int Max(int fir, int sec) { return (fir > sec) ? fir : sec; }
int Min(int fir, int sec) { return (fir < sec) ? fir : sec; }

Matrix ksm(Matrix fir, LL sec)
{
    Matrix ans; ans.r = ans.c = fir.r; ans.init();
    for (; sec; sec >>= 1, fir = fir * fir)
        if (sec & 1) ans = ans * fir;
    return ans;
}

int main()
{
    n = Read(), m = Read();
    Base.r = Base.c = n + 1; Base.init();
    for (int i = 1; i <= m; ++i)
    {
        int x = Read(), y = Read();
        Base.a[x][y] = Base.a[y][x] = 1;
    }
    for (int i = 1; i <= n; ++i) Base.a[i][n + 1] = 1;
    t = Read(); Base = ksm(Base, t);
    LL ans = 0;
    for (int i = 1; i <= n + 1; ++i) ans += Base.a[1][i];
    ans %= P; printf("%lld\n", ans); return 0;
}
```

---


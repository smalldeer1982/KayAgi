# [CQOI2011] 分金币

## 题目描述

圆桌上坐着 $n$ 个人，每人有一定数量的金币，金币总数能被 $n$ 整除。每个人可以给他左右相邻的人一些金币，最终使
得每个人的金币数目相等。

你的任务是求出被转手的金币数量的最小值。

## 说明/提示

**样例说明**

设四个人编号为 $1,2,3,4$。第 $3$ 个人给第 $2$ 个人 $2$ 个金币（变成 $1,4,3,4$），第 $2$ 个人和第 $4$ 个人分别给第 $1$ 个人 $1$ 个金币。

**数据范围**

对于 $100\%$ 的数据，$3 \le n \le 10^5$，$总金币数 \le 10^9$。

## 样例 #1

### 输入

```
4
1
2
5
4
```

### 输出

```
4
```

# 题解

## 作者：翟翟 (赞：17)

目标是让每个人的金币数变为 $\large\overline{a}=\frac{\sum\limits_{i=1}^n a_i}{n}$。

记 $X_i$ 为编号为 $i$ 的人向其左边的人给的金币数量，负数反之。则 $ans=\large\sum\limits_{i=1}^n |X_i|$。

我们发现传递后第 $i$ 个人金币数为 $a_i+X_{i+1}-X_i=\overline{a}$。

所以 $X_i=X_{i-1}+\overline{a}-a_{i-1}$。

则 $X_2=X_1+\overline{a}-a_1$；

$X_3=X_2+\overline{a}-a_2=X_1+\overline{a}-a_1+\overline{a}-a_2$；

易得 $X_i=X_1+(i-1)\times\overline{a}-\large\sum\limits_{j=1}^{i-1}a_j$。

记 $C_i=\large\sum\limits_{j=1}^i a_j-i\times\overline{a}=\large\sum\limits_{j=1}^i(a_j-\overline{a})$，

则 $X_i=X_1-C_{i-1}$，$C$ 数组可求前缀和得出。

则 $ans=\large\sum\limits_{i=1}^n|X_1-C_{i-1}|$，类似在数轴上有 $n$ 个点，找到一个与所有点距离和最小的点。对 $C$ 数组排序，若 $n$ 为奇数，$X_i$ 取 $\large C_{\frac{n+1}{2}}$；若 $n$ 为偶数，$X_1$ 取 $\large C_{\frac{n}{2}-1}$ 到 $\large C_{\frac{n}{2}}$ 的数都可以，所以我们取 $\large X_1=C_{\lfloor{\frac{n+1}{2}}\rfloor}$ 便可以求出 $ans$ 的最小值。

时间复杂度 $\large\mathcal{O}(n \log n)$，瓶颈在于排序。

## Code
```
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+1;
int n,a[N],sum,mid,s[N];
long long ans;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		scanf("%d",a+i);
		sum+=a[i];
	}
	sum/=n;
	for(int i=1;i<n;++i)
		s[i]=s[i-1]+a[i]-sum;
	sort(s,s+n);
	mid=s[n>>1];
	for(int i=0;i<n;++i)
		ans+=abs(s[i]-mid);
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：mayike (赞：6)

### [题目传送门](https://www.luogu.com.cn/problem/P5817)

~~没做[**此题**](https://www.luogu.com.cn/problem/P1031)的不要看~~

## 题意
有 $n$ 个干草堆组成一个环，在第 $i$ 个位置有 $a[i]$ 个干草堆，可以将任意位置的干草堆向前或向后移动若干个，使第 $i$ 个位置有 $ans$ 个干草堆，询问最少需要移动多少个干草堆。 

## 思路

实则就是[**均分纸牌**](https://www.luogu.com.cn/problem/P1031)的升级版，其贪心思想也是本题要用到的。

即可规定一个方向，这里我规定向左，每堆牌都向左传，变成 $ans$ 个，若本不足 $b[i]$ 个咋办呢，那就向左索要，其实等价于传负数个，详细看这位大佬的 [**blog**](https://blog.csdn.net/qq_46105170/article/details/103790633)。

---

##### 注：以上链接博客均非本人所有

---

那么我们可设每个位置原有 $a[i]$ 个，要变成 $ans$ 个，向左传递（左右都可以，单一方向即可，这里规定向左）$x[i]$ 个。

则所求值为 $\sum _ {i = 1}^n\min(| x[i] |)$。

由题意我们可知：

$$ans=a[1]+x[2]-x[1]$$

$$ans=a[2]+x[3]-x[2]$$

依次推得当 $1 \le i < n$ 时：

$$ans=a[i]+x[i+1]-x[i]$$

$$ans=a[n]+x[1]-x[n]$$

可得：

$$x[2]=ans+x[1]-a[1]$$

$$x[3]=ans+x[2]-a[2]=ans+(ans+x[1]-a[1])-a[2]$$

$$ans+(ans+x[1]-a[1])-a[2]=2 \times ans-a[1]-a[2]+x[1]$$

即：

$$x[3]=2 \times ans-a[1]-a[2]+x[1]$$

对于 $2 \le i \le n$ 有：

$$x[i]=\sum_{j=1}^{i-1}(ans-a[j]) + x[1]$$

$$x[1]=\sum_{j=1}^{n}(ans-a[j]) + x[1]$$

不妨设：

$$c[1]=a[1]-ans$$

$$c[2]=a[1]+a[2]-2 \times ans$$

对于 $1 \le i \le n$ 则有：

$$c[i]=\sum_{j=1}^{i}(a[j]-ans)$$

即可知道：

$$x[2]=x[1]-c[1]$$

$$x[3]=x[1]-c[2]$$

当 $2 \le i \le n$ 时：

$$x[i]=x[1]-c[i-1]$$

$$x[1]=x[1]-c[n]$$

所以：

$$\sum _ {i = 1}^n\min(| x[i] |)$$

等价于：

$$\sum _ {i = 1}^n\min(| x[1]-c[i] |)$$

放在数轴上来讲就是点 $x[1]$ 到 $c[i]$ 的距离和的最小值，此处 $1 \le i \le n$。

那么 $x[1]=c[\frac{n+1}{2}]$ 时就一定可取最小值，这个就不说明了，自己思考一下为什么。

对于 $1 \le i \le n$，$c[i]$ 我们是已知的。那么，本题~~完~~。

等等，还有代码！

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[1000001],c[1000001],sum,mid,ans;
int main(){
	//经验: p2512 UVA11300 p3051 p4016 p2125 p5817 SP11117
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i],sum+=a[i];
	sum/=n;
	for(int i=1;i<=n;i++)c[i]=c[i-1]+a[i]-sum;
	sort(c+1,c+1+n);mid=c[(n+1)/2];
	for(int i=1;i<=n;i++)ans+=abs(mid-c[i]);
	cout<<ans;
}
```

---

## 作者：Kreado (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P5817)。

## 思路

我们最终结果是要使所有人的金币个数 $a_i$ 相等，也就是每个人的金币个数是所有人金币个数总和的平均数 $ave$，我们不妨设 $x_i$ 表示第 $i$ 个人向左传递的金币个数，可以列出方程组：

$$\begin{cases}a_1+x_2-x_1=ave&(1)\\a_2+x_3-x_2=ave&(2)\\a_3+x_4-x_3=ave
&(3)\\\cdots\\a_n+x_1-x_n=ave&(n)\end{cases}$$

最终我们要求的就是 $\max\{\sum_{i=1}^n |x_i|\}$。

为了消掉多余的 $x_i$，不妨让第二个方程组加上第一个方程组，在让第三个方程组加上第一个方程组和第二个方程组，也就是做一个前缀和，可以得到新方程组：

$$\begin{cases}a_1+x_2-x_1=ave\\a_1+a_2+x_3-x_1=2\times ave\\a_1+a_2+a_3+x_4-x_1=3\times ave\\\cdots\\a_1+a_2+\cdots+a_n+x_1-x_1=n\times ave\end{cases}$$

令 $c_i$ 表示 $\displaystyle\sum_{j=1}^i a_j-i\times ave$，那么对于每个 $i$ 有方程 $x_{(i \bmod n)+1}=x_1-c_i$。

现在我们只需最小化 $\displaystyle\sum_{i=1}^n |x_1-c_i|$，而 $c_i$ 是我们已知的，我们现在需要求出一个 $x_1$。

根据**中位数定理**，当 $x_1$ 取 $c$ 序列的中位数时该式子有最小值。

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const ll Maxn=1e6+7;
ll n,w[Maxn],ave,c[Maxn],ans;
int main(){
	scanf("%lld",&n);
	for(ll i=1;i<=n;i++) scanf("%lld",&w[i]),ave+=w[i];
	ave/=n;
	for(ll i=1;i<=n;i++) c[i]=c[i-1]+w[i]-ave; 
	sort(c+1,c+n+1);
	ll mid=c[(n+1)/2];
	for(ll i=1;i<=n;i++) ans+=abs(mid-c[i]);
	printf("%lld",ans);
	return 0;
}

```


---

## 作者：life_is_movie (赞：3)

设第 $i$ 个人需要给第 $i-1$ 个人 $x_i$ 个金币，特别的第 $1$ 个人给第 $n$ 个人 $x_1$ 个金币。

若 $x_i>0$ 意为给出，若 $x_i<0$ 意为收到。



由于最后所有的人手里的金币数量均相等，那么最后所有的人金币数都是平均数设为 $\bar a$。

我们可以根据传递关系列出如下等式

$$\begin{cases}
a_1-x_1+x_2&=\bar a \\
a_2-x_2+x_3&=\bar a \\
\cdots\\
a_{n-1}-x_{n-1}+x_n&=\bar a \\
a_{n}-x_n+x_1&=\bar a \\
\end{cases}$$

将上述式子移项可得

$$\begin{cases}
x_1-x_2&=a_1-\bar a\\
x_2-x_3&=a_2-\bar a \\
\cdots\\
x_{n-1}-x_n&=a_{n-1}-\bar a \\
x_n-x_1&=a_{n}-\bar a \\
\end{cases}$$

此时将最后两个式子相加可得 $x_{n-1}-x_n+x_n-x_1=a_{n-1}-\bar a+a_n-\bar a$

化简后为 $x_{n-1}-x_1=(a_{n-1}+a_n)-2\bar a$

同理可以列出后三个，后四个相加等其余的关系

$$\begin{cases}
x_n-x_1&=a_n-\bar a\\
x_{n-1}-x_1&=(a_{n-1}+a_n)-2\bar a\\
x_{n-2}-x_1&=(a_{n-2}+a_{n-1}+a_n)-3\bar a\\
x_{n-3}-x_1&=(a_{n-3}+a_{n-2}+a_{n-1}+a_n)-4\bar a\\
\cdots \\
x_2-x_1&=(a_2+a_3+\cdots+a_n)-(n-1)\bar a\\
x_1-x_1&=(a_1+a_2\cdots+a_n)-n\bar a
\end{cases}$$

我们将等式右边的 $-x_1$ 全部移到右边可得

$$\begin{cases}
x_n&=x_1+a_n-\bar a\\
x_{n-1}&=x_1+(a_{n-1}+a_n)-2\bar a\\
x_{n-2}&=x_1+(a_{n-2}+a_{n-1}+a_n)-3\bar a\\
x_{n-3}&=x_1+(a_{n-3}+a_{n-2}+a_{n-1}+a_n)-4\bar a\\
\cdots \\
x_2&=x_1+(a_2+a_3+\cdots+a_n)-(n-1)\bar a\\
x_1&=x_1+(a_1+a_2\cdots+a_n)-n\bar a
\end{cases}$$

将右边变一下符号。
$$\begin{cases}
x_n&=x_1-(\bar a-a_n)\\
x_{n-1}&=x_1-(2\bar a-(a_{n-1}+a_n))\\
x_{n-2}&=x_1-(3\bar a-(a_{n-2}+a_{n-1}+a_n))\\
x_{n-3}&=x_1-(4\bar a-(a_{n-3}+a_{n-2}+a_{n-1}+a_n))\\
\cdots \\
x_2&=x_1-((n-1)\bar a-(a_2+a_3+\cdots+a_n))\\
x_1&=x_1-(n\bar a-(a_1+a_2\cdots+a_n))
\end{cases}$$

回顾我们题目的所求，求解的是总传递金币数量的最小值，其实就是求解 $|x_1|+|x_2|+\cdots+|x_n|$ 的最小值。

即等同于求我们等号等号右边所有式子绝对值的和。

根据我们绝对值得几何意义，$|x_1-(\bar a-a_n)|$ 的含义就是点 $x_1$ 到点 $\bar a-a_n$ 的距离。那么题目就转变成了在数轴上有若干个点它们的坐标分别是 $\bar a-a_n,2\bar a-(a_{n-1}+a_n),\cdots$ 需要你找到一个点，使得到这些点的距离之和最小。

答案就是中位数。

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 1e6 + 5;
ll n, a[N], c[N];
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin >> n;
    ll avg = 0, sum = 0;
    for (int i = 1; i <= n; i++) 
    {
        cin >> a[i];
        sum += a[i];
    }
    avg = sum / n;
    for (int i = 1; i <= n; i++)
    {
        c[i] = (n - i + 1) * avg - sum;
        sum -= a[i];
    }
    sort(c + 1, c + n + 1);
    ll res = 0;
    for (int i = 1; i <= n; i++) res += abs(c[i] - c[(n + 1) / 2]);
    cout << res;
    return 0;
}
```

---

## 作者：luxiaomao (赞：3)

## 前言（~~废话~~）

听说写题解能加 rp？

那就~~水一篇题解~~然后把好运分给大家吧 QAQ。

CSP 2023 RP++ ！！！

## 分析

### 题意

题意似乎不难理解。

给出一个长度为 $n$ 的环，每个节点 $i\ (0 \le i < n)$ 上都有一个权值 $a_i$，保证 $\dfrac{\sum\limits_{i = 0}^{n-1}a_i}{n}$（即所有点权的平均值）为整数。每个点都可以将自己的点权分任意多给两侧的点，求最少需要几次操作才能均摊点权。

### 算法 $\to$ 实现

主要的思想是线性的填表。（但本蒟蒻的复杂度无法达到 $O(n)$ 而是 $O(n \log n)$，具体原因请看下文）

首先计算出权值的平均值 $sum$（~~谁教你这么起名的~~），然后用 $dp_i$ 表示第 $i$ 个人要传给下一个人多少金币。（显然地，如果 $dp_i < 0$， 说明第 $i+1$ 个人要向第 $i$ 个人“倒贴”）

那么：

$$ dp_i = (a_i\ +\ dp_{i-1}) - sum $$

显然，这样算出来后，不一定保证 $ans = \sum\limits_{i = 0}^{n-1}dp_i$，因为线性地递推其实上是一种断环成链的解决方式（在上文中，我们讲的是将边 $0-n$ 断掉的方式）。

但如果我们枚举断开的边，复杂度又会退化到 $O(n^2)$，该咋办？

我们将 $dp$ 数据进行排序，取出中位值 $dp_{\lfloor \frac{n}{2} \rfloor}$。

则有：（pia 黑板！！）

$$ans = \sum\limits_{i = 0}^{n-1}|dp_i-dp_{\lfloor \frac{n}{2} \rfloor}|$$

这个公式的本质是抵消掉无用的传递，取中位值最大限度地最小化了答案。

## Code Time

请看具体代码和注释。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long//十年OI一场空。。。

int n,a[100005],sum = 0,dp[100005];
int ans;

signed main(){
	scanf("%lld",&n);
	for(int i = 1;i <= n;i++){
		scanf("%lld",&a[i]);     
		sum += a[i];
	}
	sum /= n;//计算平均值      
	for(int i = 1;i <= n-1;i++)              
		dp[i] = dp[i-1] + a[i] - sum;//进行递推填表   
	sort(dp,dp+n);//进行排序，方便取出中位数
	for(int i = 0;i < n;i++)
		ans += abs(dp[i]-dp[n/2]);//每次统计当前数据与中位数的差值并加入最终答案
	printf("%lld",ans);
	return 0;//完结撒花~
}
```

虽然全程都是 $O(n)$ 的递推，但是为了取中位值而进行排序，最终的复杂度为 $O(n \log n)$，莫得关系，对于此题的数据范围可以轻松通过。

如有问题欢迎私信，谢谢大家的支持~

---

## 作者：ydkxj (赞：2)


## 题意说明：
这一道题其实就是每个人可以给他左右相邻的人一些金币，最终使得每个人的金币数目相等。



------------
1.  输入 $a _ {0} ^ {n}$。

1.  算平均数。

1.  将每个人金币大于平均值的或小于平均值的部分的转移到下一个人手中；令一个数 $ans = a _ {i} - a_{i-1}$ 统计一共要转移多少枚金币。

1.  输出 $ans$，完结撒花。

### CODE

```cpp
#include<iostream>
#include<algorithm>
#include<cmath>
using namespace std;
long long n,a[100005],sum,mid,dp[100005];
long long ans;
int main(){
	ios::sync_with_stdio(0);   
	cin.tie(0);                 //快读，优化cin/cout。 
	cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;++i){
		cin>>a[i];           //输入a[i]。 
		sum+=a[i];           //sum累加值。
	}
	sum=sum/n;               //取平均。 
	for(int i=1;i<n;++i)              
		dp[i]=dp[i-1]+a[i]-sum;    //累计。 
	sort(dp,dp+n);                 //sort大法YYDS记得打#include<algorithm>。
	mid=dp[n/2];
	for(int i=0;i<n;++i)
		ans+=abs(dp[i]-mid);       //取要移动的金币数。 
	cout<<ans;                     //完结撒花。 
                                  
}
```
PS:**记得开long long**。

求过。

---

## 作者：_zuoqingyuan (赞：1)

# 题意简述

环形均分纸牌。

# 思路分析

## 朴素均分纸牌

每个位置初始有纸牌 $a_i$，记 $s=\sum a_i$，则分完之后每个位置有 $\dfrac{s}{n}$，每个位置需要分出的纸牌数量记为 $A_i=a_i-\dfrac{s}{n}$。

注意 $A_i$ 可能为负数，有两种含义

- $A_i\ge 0$：表示需要将 $A_i$ 张牌从 $i$ 传到 $i+1$。

- $A_i<0$：表示需要将 $|A_i|$ 张牌从 $i+1$ 传到 $i$。

思考分纸牌的过程：

----

先将 $A_1$ 张牌传给 $2$ 这个位置，此时 $A_2'\to A_2+A_{i}$。

后将 $A_2'$ 张牌传给 $3$ 这个位置，此时 $A_3'\to A_3+A_2'$。

$$\dots$$

然后将 $A_k'$ 张牌传给 $k+1$ 这个位置，此时 $A_{k+1}'\to A_{k+1}+A_k'$

$$\dots$$

当前 $n-1$ 个位置的纸牌数均为 $\dfrac{s}{n}$，则第 $n$ 个位置无需再将纸牌“传给”其他位置，也可以说，$A_n'=0$。

----

整个过程中，传递所产生的总代价即为 $|A_1|+\sum\limits_{i=2}^n|A_i'|$。

我们发现，$A_k'$ 总会叠加在 $A_{k+1}'$ 中，不妨记 $S_i=\sum\limits_{j=1}^iA_j$。则总代价即可记为 $\sum\limits_{i=1}^n |S_i|$。

## 环形的均分纸牌

在这种情况下，最优方案一定也是“传递” $n-1$ 次。

我们枚举从位置 $k$ 开始不断向后“传导”的最优方案。

----

将 $A_k$ 张牌传给 $k+1$ 这个位置，此时 $A_{k+1}'\to A_{k+1}+A_k$

$$\dots$$

将第 $A_n'$ 张牌传给 $1$ 这个位置，此时 $A_1'=A_1+A_n'$

$$\dots$$

当前 $k\sim n,n\sim k-2$ 个位置的纸牌数均为 $\dfrac{s}{n}$，则第 $k-1$ 个位置无需再将纸牌传给其他位置，也可以说，$A_{k-1}'=0$。

----

我们仍然记 $S_i=\sum\limits_{j=1}^iA_j$，则从 $p$ 传导给 $p+1(k\le p<n)$ 的代价是 $S_p-S_{k-1}$。

当 $t=n$ 时，代价是 $S_n-S_{k-1}$。

当 $1\le t <k$ 时，代价是 $S_n-S_{k-1}+S_t$。

我们上文提到过 $S_n=0$，所以化简后，传递的总代价为 $\sum\limits_{i=1}^n|S_{k-1}-S_t|$。

问题在于如何找到一个 $k-1$，使得代价和最小。我们把所有 $S_i$ 画在数轴上，发现这个点取得越靠中间，它到其他点的总距离越小，代价和也就越小。所以我们取中位数就可以。

# Code

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
const int N=1e5+10;
int a[N],s[N],sum,n;
long long ans;
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)scanf("%d",a+i),sum+=a[i];
    for(int i=1;i<=n;i++)s[i]=s[i-1]+a[i]-sum/n;
    sort(s+1,s+1+n);
    for(int i=1;i<=n;i++)ans=(long long)ans+abs(s[i]-s[n/2+1]);
    printf("%lld\n",ans);
    return 0;
}
```

如有错误，请指出。

---

## 作者：Li_Yichen (赞：0)

环形均分纸牌。假设我们把数字存放在数组 $a$ 里，用 $avr$ 来表示数组的平均数，那么我们最终需要把每一个元素 $a_{i}$ 都变成 $avr$ 才能满足题意。和序列均分纸牌的唯一不同，就是第一个和最后一个是相连的。观察可得，一定有两个连续的元素之间包含 $avr$ 这个数。即如果第一个数设为 $a_{i}$ 的话，那么我们得到的结论可以表示为 $a_{i} \le avr \le a_{i+1}$ 的符号语言。简单表示为 $a_{i}$ 和 $a_{i+1}$ 不存在交换，也就是 $a_{i}$ 只会从 $a_{i-1}$ 获得，同理 $a_{i+1}$ 只会给 $a_{i+2}$ 多出来的数字。

这是解决这道题最重要的性质。如果我们想要让第 $i$ 个位置满足均分，那么我们需要从第一个到第 $i-1$ 个都均分，那么我们用 $need_{i}$ 来表示 $a_{i}-avr$ 的绝对值，也就是需要变化的数字量，即为 $\mid a_{i}-avr\mid$ 的值，发现我们需要计算前 $i$ 个需要的量之和，想到用前缀和来优化，用 $cnt_{i}$ 来表示前 $i$ 个需要变化数字的总和。

假设不需要交换的是 $p$ 位置，那么 $\sum_{\mid cnt_{i}-cnt_{p}\mid}^{i \le n}$ 为最后的答案。发现形式为绝对值不等式，最后要让答案最小，只要让 $cnt_{p}$ 为中位数即可，代码实现起来不难。

```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
int n;
int a[100005],cnt[100005],need[100005];
int avr;
int middle;
int ans;
signed main(){
    cin >> n;
    for(int i=1;i<=n;i++){
    	cin >> a[i];
    	avr += a[i];
	} 
	avr /= n;
    for(int i=1;i<=n;i++){
    	need[i] = a[i] - avr;//根据均分纸牌的思想算出来要转移的牌数 
	}
	for(int i=1;i<=n;i++){
		cnt[i] = cnt[i-1] + need[i];//对需要数前缀和 
	}
	//取中位数 
    sort(cnt+1,cnt+n+1); 
    middle = cnt[n/2+1];
    for(int i=1;i<=n;i++){
    	ans += abs(middle - cnt[i]);
	}
    cout << ans;
    return 0;
}

```

---

## 作者：wei2013 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P5817)

这就是均分纸牌的升级版，~~有点水~~。
## 思路：
首先，我们知道**中位数定理**，取中位数是最优解法，然后将超出平均值的向右给下一个人，小于平均值的拿过来，累加即可。

## code：
```
#include<bits/stdc++.h>
using namespace std;
long long a[1000005],p[1000005];
int main(){
	// 记得开longlong。
	long long sum=0,n,mid,ans=0;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		sum+=a[i];
	}
	sum/=n;
	for(int i=1;i<=n;i++){
		p[i]=p[i-1]+a[i]-sum;
	}
	sort(p+1,p+n+1);
	mid=p[(n+1)/2];
	for(int i=1;i<=n;i++){
		ans+=abs(mid-p[i]);
	}
	cout<<ans;
}
```


---

## 作者：2021zjhs005 (赞：0)

一道数学题，听说有[七倍经验](https://www.luogu.com.cn/discuss/639580)。

既然要使得每个人的金币数量相等，那么分到最后，每个人的金币数量为 $\frac{\sum_{i=1}^{n} a_i}{n}$。

但只是这样并不能求出最小转手金币数量。

我们不妨设 $x_i$ 表示第 $i$ 个人转手给左边的人的金币数。特别的，第 $1$ 个人要给第 $n$ 个人金币。

也就是说，答案为 $\sum_{i=1}^{n} \lvert a_i\rvert$。负数就是给第 $(i+1)\bmod n$ 个人的金币数。

设平均数为 $\bar{a}$，则：

$$\begin{cases}\bar{a} = x_{2} - x_{1} + a_1\\\bar{a}=x_3-x_2+a_2\\\ldots\\\bar{a} = x_1-x_n+a_n\end{cases}$$

也就是说，$\bar{a} = x_{(i+1)\bmod n} - x_i+a_i$。

移项后，可得：

$$\begin{cases}x_2 = \bar{a} - a_1+x_1\\x_3=\bar{a}-a_2+x_2\\\ldots\\x_n=\bar{a}-a_{n-1}+x_{n-1}\end{cases}$$


将 $x_i$ 带入方程组，可得：

$$\begin{cases}x_2=\bar{a}-a_1+x_1\\x_3=\bar{a}-a_2+(\bar{a}-a_1+x_1)= x_1+2\times \bar{a}-a_1-a_2\\x_4=\bar{a}-a_3+(x_1+2\times \bar{a}-a_1-a_2) = x_1+3\times \bar{a}-a_1-a_2-a_3\\\ldots\\x_n=\bar{a}-a_{n-1}+x_{n-1}=x_1+(n-1)\times \bar{a}-a_1-a_2-\ldots - a_{n-1} \end{cases}$$

为了使 $\sum_{i=1}^{n} \lvert x_i\rvert$ 最小，我们设 $q_i = -i\times \bar{a}+a_1+a_2+a_3+\ldots +a_i$，则有：

$$\begin{cases}x_1=x_1-q_0\\x_2=x_1-q_1\\x_3=x_1-q_2\\\ldots\\x_n=x_{1}-q_{n-1}\end{cases}$$

可以用前缀和求出每个 $q_i$（$1\le i\le n$）。


最后求得的结果就是 $\min{\sum_{i=1}^{n}\lvert x_1-q_{i-1}\rvert}$。

这里求最小值可以找到中间值，也就是 $q_{(n+1)\div 2}$，然后求出 $\sum_{i=1}^n \lvert q_i-q_{(n+1)\div 2}\rvert$ 即可。注意 $q$ 数组要**排序**！

为什么选取中间值？这个问题我想很容易思考，自己画个图就行了。

至于为什么这么求，真的很简单，自己思考吧。


注：本文最后一些的证明参考于 [这篇博客](https://www.luogu.com.cn/blog/swyn/solution-p5817)。

$\boxed{code}$
------------

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll N=1e5+10;
ll n,i,sum,ans,a[N],q[N];
int main(){
    cin>>n;
    for(i=1;i<=n;i++){
        cin>>a[i];
        sum+=a[i];
    }
    sum/=n;//求平均值。
    for(i=1;i<=n;i++)
        q[i]=q[i-1]+a[i]-sum;//前缀和。
    nth_element(q+1,q+((n+1)/2),q+1+n);
//用 nth_element 来简易排序，因为这里只需要 q 数组第 (n+1)/2 个，所以不一定要按照升序排序，找到这个数即可。不理解 nth 的可以上网搜。
    for(i=1;i<=n;i++)
        ans+=abs(q[i]-q[(n+1)/2]);//累加。
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：_radio_ (赞：0)

# P5817 分金币题解
~~作为一个蒟蒻，偶尔刷到几道[双倍经验](https://www.luogu.com.cn/problem/P2512)的题还挺不错的。~~
## 题意
圆桌上有 $n$ 个人，他们每人有 $a_i$ 个金币，每人都可以向左右的人分别分若干个金币，问最少流动多少金币能让所有人的金币数相等。[原题传送门](https://www.luogu.com.cn/problem/P5817)
## 思路
**我们设 $X_i$ 为第 $i$ 个人向左传的金币数**。这里可能就有同学要问了：那如果是向右传该怎么办呢？很简单：我们只用把 $X_{i+1}$ 减去第 $i$ 个人向右传的金币就行了。所以，$X_i$ 既可能是正数，也可能是负数。

那接下来该怎么办呢？略一思考，我们就能得出一个结论——所有人最终的金币数都是他们金币的平均值。那接下来就好办了：**我们设这个平均值为 $cnt$**，根据题意推导可得
$$X_2=cnt-(a_1-X_1)$$
变换得
$$X_2=cnt+X_1-a_1$$
以此类推
$$X_3=cnt+X_2-a_2$$
将 $X_2=cnt+X_1-a_1$ 代入得
$$X_3=cnt+(cnt+X_1-a_1)-a_2$$
化简得
$$X_3=2\times cnt+X_1-a_1-a_2 $$
由此可得
$$X_i=(i-1)\times cnt+X_1-a_1-a_2-\ldots-a_{i-1}$$
我们的目的是让所有 $\lvert X_i\lvert$ 的总和最小。因此，我们设
$$F_i=-i\times cnt+a_1+a_2+\ldots+a_i$$
则
$$X_1=X_1-F_0$$
ps:**这里需将 $F_0$ 初始化为 $0$**。
$$X_2=X_1-F_1$$
$$X_3=X_1-F_2$$
推导得
$$X_i=X_1-F_{i-1}$$
**因此，求 $\lvert X_1\lvert+\lvert X_2\lvert+\ldots+\lvert X_n\lvert$ 的最小值就等同于 $\lvert X_1-F_0\lvert+\lvert X_1-F_1\lvert+\lvert X_1-F_{n-1}\lvert$ 的最小值。**

这里插入一张图片
![](https://cdn.luogu.com.cn/upload/image_hosting/3jhprt1o.png)
可以发现，最优解必定是在最外围的 $A$、$G$ 两点之间，又必定在中层的 $B$、$F$ 两点之间，再进一步，必定在 $C$、$E$ 之间，最后发现，最优解就位于最中心的点 $D$ 处。

总结发现，如果有 $n$ 个点，那么 $\lceil n\div2\rceil$ 一定是最优解之一。

所以我们取排序后的 $F_{(i-1+1)\div2}\to F_{i\div2}$ 为中值，记所有 $F_i$ 与中值的差的绝对值的和，输出即可。（具体实现见代码）
## code
```cpp
#include<bits/stdc++.h>
#define int long long//十年OI一场空……
using namespace std;
int n,a[100010],F[100010]/*存储内容与上文相同*/,cnt;
//快读快写，卡常必备
inline int read(){
    register int x=0;
    register char ch=getchar();
    while(ch<'0'||ch>'9') ch=getchar();
    while(ch>='0'&&ch<='9'){
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x;
}
inline void write(int x){
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
int qsort(int l,int r,int k){//从第k小数抄来的题解……
	int i=l,j=r,mid=F[(l+r)>>1];
	while(i<=j){
		while(F[i]<mid) i++;
		while(F[j]>mid) j--;
		if(i<=j){
			swap(F[i],F[j]);
			i++;
			j--;
		}
	}
	if(k<=j) qsort(l,j,k);
	else if(i<=k) qsort(i,r,k);
	else return F[j+1];
}
signed main(){
    n=read();
    for(int i=1;i<=n;i++){
        a[i]=read();
        cnt+=a[i];//累加前缀和
    }
    cnt/=n;//除以项数
    for(int i=1;i<n;i++) F[i]=F[i-1]-cnt+a[i];//计算F数组
    int jz=qsort(0,n-1,n/2)/*找到第n/2小的数*/,ans=0;
    for(int i=0;i<n;i++) ans+=abs(F[i]-jz);//累加答案
    write(ans);
    return 0;
}
```
《琐记》：求求了，别抄，我不想别人因为我的题解变棕。代码是 AC 的，请放心食用。如有错误私信[我](https://www.luogu.com.cn/user/996338)指出，感激不尽。

---

## 作者：zwye (赞：0)

### 分析
设 $x_i$ 表示第 $i$ 个人要给他前面的人的金币数目，如 $x_2$ 表示第二个人要给第一个人的金币数。


对于第 $1$ 个人，$A_1-x_1+x_2=M \to x_2=M-A_1+x_1=x_1-(A_1-M)$。


对于第 $2$ 个人，$A_2-x_2+x_3=M \to x_3=M -A_2+x_2=2M-A_1-A_2+x_1=x_1-(A_2-M)-(A_1-M)$。


对于第 $3$ 个人，$A_3-x_3+x_-M \to x_4=M-A_3+x_3=3M-A_1-A_2-A_3+x_1=x_1-(A_3-M)-(A_2-M)-(A_1-M)$。


$\cdots$


规定 $C_1=A_1-M$,则


$x_1=x_1-C_1$


$x_2=x_1-(A_2-M)-C_1=x_1-C_2$


$\cdots$


我们可以得出：$C_i=C_i-1+A_i-M$。我们希望所有 $x_i$ 的绝对值之和尽量小。注意到 $x_1-C_l$ 的几何意义是数轴上点 $x$ 到 $C$ 的距离，所以问题变成了:给定数轴上的 $n$ 个点，找出一个到它们的距离之和尽量小的点。这个最优的 $x_1$ 就是这些数的“中位数”。中位数代入即可求值。


### 代码
```c
#include<bits/stdc++.h>
using namespace std;
long long A[100010],C[100010],tot,M;
int main()
{
	int n;
	while(scanf("%d",&n)==1)
	{
		tot=0;
		for(int i=1;i<=n;i++)
		{
			scanf("%lld",&A[i]);
			tot+=A[i];
		}
		M=tot/n;
		C[0]=0; 
		for (int i=1;i<=n;i++)C[i]=C[i-1]+A[i]-M;
		sort(C,C+n);
		long long x1=C[n/2]; 
		int ans=0;
		for(int i=0;i<n;i++)ans+=abs(x1-C[i]);
		printf("%lld",ans);
	}
	return 0;	
}
//提醒：记得开long long
```


---

## 作者：zhang_Jimmy (赞：0)

题意：  
圆桌上坐着 $n$ 个人，每人有一定数量的金币，金币总数能被 $n$ 整除。每个人可以给他左右相邻的人一些金币，最终使得每个人的金币数目相等。

你的任务是求出被转手的金币数量的最小值。

思路：

我们对第一个样例进行分析（$n = 4$）。

记 $x_i$ 为第 $i$ 个小朋友给出或索要下一个人的金币数量，可正可负。  
当 $x_i$ 为负数时，说明是给了下一个人 $\left\vert x_i \right\vert$ 个金币。 
当 $x_i$ 为正数时，说明是索要了下一个人 $x_i$ 个金币。

本题要求的其实是 $\sum _ {i = 1} ^ n \left\vert x_i \right\vert$。

接下来我们进行分析：  
我们设最终平均值为 $avg$，则可以得出关系式：  
$$a_1 - x_1 + x_4 = avg$$  
$$a_2 - x_2 + x_1 = avg$$  
$$a_3 - x_3 + x_2 = avg$$  
$$a_4 - x_4 + x_3 = avg$$  

再定义 $c_i = avg - a_i$，又能得到如下关系式：  
$$x_4 - x_1 = avg - a_1 = c_1$$  
$$x_1 - x_2 = avg - a_2 = c_2$$  
$$x_2 - x_3 = avg - a_3 = c_3$$  
$$x_3 - x_4 = avg - a_4 = c_4$$  

将这两个式子合并，得到：  
$$x_1 = x_4 - c_1$$  
$$x_2 = x_1 - c_2 = x_4 - \sum _ {i = 1} ^ {n - 2} c_i$$  
$$x_3 = x_2 - c_3 = x_4 - \sum _ {i = 1} ^ {n - 1} c_i$$ 
$$x_4 = x_3 - c_4 = x_4 - \sum _ {i = 1} ^ n c_i$$

将 $c$ 数组进行前缀和处理，得到 $s$ 数组，即 $s_i = \sum _ {j = 1} ^ i c_i$。则有：  
$$x_i = x_n - s_i$$  
$$\sum _ {i = 1} ^ n \left\vert x_i \right\vert = \left\vert x_n - s_1 \right\vert + \left\vert x_n - s_2 \right\vert  \dots \left\vert x_n - s_n\right\vert$$

由于 $s_i$ 是可以通过给定数据求出的，所以，此题可以转换为：  
在数轴上选一个点，使其到 $s_1$ 到 $s_n$ 的距离和最小。  
选的那个点为 $s_1$ 到 $s_n$ 的中位数，为 $m = s_{\lfloor\frac{n + 1}{2}\rfloor}$。

那么答案就为:  
$$\sum _ {i = 1} ^ n  \left\vert  m - s_i\right\vert$$

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N = 1e6 + 10;
int n;
LL a[N], c[N], s[N];
int main(){
// 	freopen("candy.in", "r", stdin);
//	freopen("candy.out", "w", stdout);
	cin >> n;
	LL sum = 0;
	for(int i = 1; i <= n; i ++){
		cin >> a[i];
		sum += a[i];
	}
	LL avg = sum /= n;
	for(int i = 1; i <= n; i ++)
		c[i] = avg - a[i];
	for(int i = 1; i <= n; i ++)
		s[i] = s[i - 1] + c[i];
	sort(s + 1, s + n + 1);
	LL m = s[(n + 1) / 2];
	LL ans = 0;
	for(int i = 1; i <= n; i ++)
		ans += abs(m - s[i]);
	cout << ans;
	return 0;
}

```


---


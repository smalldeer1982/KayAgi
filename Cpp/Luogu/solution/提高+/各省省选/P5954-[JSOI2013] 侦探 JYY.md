# [JSOI2013] 侦探 JYY

## 题目描述

JSOI 的世界里一共有 $N$ 个不同的事件（依次由 $1$ 到 $N$ 编号），以及 $M$ 条线索。每一条线索对应一个二元组 $(x,y)$，表示事件 $x$ 发生会导致事件 $y$ 发生。

**注意： 线索是单向的，也就是如果 $y$ 发生了，并不代表 $x$ 一定会发生。**

线索是有传递性的， 即如果存在线索 $(x,y)$ 以及 $(y,z)$， 那么 $x$ 发生则会导致 $z$ 发生。

同时由于世界是合理的，任意一个事件 $x$ 一定不会通过某些线索导致事件 $x$ 本身发生。

另外，整个世界仅包含这 $M$ 条线索， 我们不认为一些事件会凭空发生（就像福尔摩斯永远不会认为诡异的凶杀案是源于神的谴责）。具体而言，对于某个事件 $x$， 如果 $x$ 发生了，并且存在某个事件可能导致 $x$ 发生，那么一定至少有一个可能导致 $x$ 发生的事件发生了。

现在已知世界上的 $M$ 条线索，以及 $D$ 个已经发生的事件，那么由此推断，
哪些事件一定已经发生了呢？

## 说明/提示

### 样例解释

在第一个样例中，由于事件 $1$ 和事件 $2$ 这两个事件中的任何一个发生都会导致事件 $3$ 发生，所以我们并不能确定到底哪个事件发生了。

在第二个样例中，由于事件 $4$ 发生了，所以事件 $2$ 和事件 $3$ 中至少有一个发生了。而不论哪一个发生了，都可以推出事件 $1$ 发生了。

最终由于事件 $1$ 发生了，使得我们可以推断出，所有 $4$ 个事件都必然发生了。

### 数据范围

对于 $100\%$ 的数据，$1\leq D\leq N\leq 10^3,1\leq M\leq 10^5$。

## 样例 #1

### 输入

```
3 2 1
1 3
2 3
3```

### 输出

```
3```

## 样例 #2

### 输入

```
4 4 1
1 2
1 3
2 4
3 4
4```

### 输出

```
1 2 3 4```

# 题解

## 作者：bellmanford (赞：8)

$stO\quad JYY\quad Orz$

------------

首先，根据线索，将每个边反向再建一个图，用于逆推 

对于每个点，必然发生的情况只有三种：

- 1、题目给出此事件已发生

- 2、可以通过已知必然发生的事件直观的推出（也就是根据“线索是有传递性的”这一性质推出） 

- 3、对于每一个必然发生事件，如果关于这个点的每一条路径都必须经过目前节点，那该事件必然发生

第一种情况，直接记录下题目给出的条件，直接判断即可 

第二种情况，找出所有可以推出该事件的点，看是否存在必然事件 

只需在逆推图上bfs一遍，如果遍历到的事件是必然发生的，那JYY就可以通过那个事件推出这个事件的必然发生

第三种情况，将除了能推出自己的出度为0的点所能推出的所有节点打上标记，假如存在必然事件未被打上标记，则该事件所有路径必然经过目前节点 

```cpp
#include<iostream>
#include<cstdio>
#include<queue>
using namespace std;

#define JYY return
#define AK 0
#define IOI ;
const int M=1e5+5,N=1e3+5;

int n,m,D,tot=0,a[M],in[M],first[M];
bool vis[M],truth[M];
struct Edge{
	int to,nxt,pd;
}e[M<<1];
queue<int> Q;

int read(){
	int x=0,y=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-') y=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=x*10+ch-'0';
		ch=getchar();
	}
	return x*y;
}

void add(int x,int y,int fx){
	e[++tot].nxt=first[x];
	first[x]=tot;
	e[tot].to=y;
	e[tot].pd=fx;
}

bool check(int x){
	for(int i=1;i<=n;i++) vis[i]=0;vis[x]=1;
	while(!Q.empty()) Q.pop();Q.push(x);
	while(!Q.empty()){
		int u=Q.front();Q.pop();
		for(int i=first[u];i;i=e[i].nxt){
			int v=e[i].to;
			if(!e[i].pd) continue;
			if(truth[v]) return 1;
			if(!vis[v]) Q.push(v),vis[v]=1;
		}
	}
	for(int i=1;i<=n;i++) if(!in[i]&&!vis[i]) Q.push(i),vis[i]=1;
	while(!Q.empty()){
		int u=Q.front();Q.pop();
		for(int i=first[u];i;i=e[i].nxt){
			int v=e[i].to;
			if(e[i].pd) continue;
			if(!vis[v]) Q.push(v),vis[v]=1;
		}
	}
	for(int i=1;i<=D;i++) if(!vis[a[i]]) return 1;
	return 0;
}

int main(){
	n=read(),m=read(),D=read();
	for(int i=1;i<=m;i++){
		int x=read(),y=read();
		add(x,y,0),add(y,x,1);in[y]++;
	}
	for(int i=1;i<=D;i++) a[i]=read(),truth[a[i]]=1;
	for(int i=1;i<=n;i++) if(truth[i]||check(i)) printf("%d ",i),truth[a[++D]=i]=1;
	printf("\n");
	JYY AK IOI
}
```


---

## 作者：卷王 (赞：2)

突然翻到了这道题，感觉挺不错，就写一篇题解总结一下。

## 题目大意

共有 $n$ 个事件，已知 $D$ 个事件成立，请你通过给出的 $m$ 条 **事件 $x$ 成立，则另一个事件 $y$ 也成立** 的这类关系尽可能的推断出成立的事件并输出。

## 大体思路

$n$ 个事件可以看作 $n$ 个点，而 **事件 $x$ 成立，则另一个事件 $y$ 也成立** 这种关系其实就是一条 $x\rightarrow y$ 的有向边。然后我们可以 bfs。

但是正推似乎很难实现，那么正难则反，考虑建反向边，然后在这个图上 bfs。这就是 **逆向思维**。

所以大体只有三步：

* 读入，建图，标记已知的必然事件

* 直接运用明显关系（即形如 **一个必然事件指向一个未知事件** 的关系）推出一些必然事件。

* 在图上 bfs，推出那些并不明显的必然事件。具体可以参照其他人的代码和分析。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
//#define int long long
typedef long long ll;
typedef pair<int, int> pr;
#define up(i, l, r) for(int i = (l); i <= (r); i++)
#define down(i, r, l) for(int i = (r); i >= (l); i--)
const int mod = 1000000007;
const int base = 2333;
const double eps = 1e-6;

inline int read() {
	int x = 0, f = 1;
	char ch = getchar();
	while (ch < '0' || ch > '9') {
		if (ch == '-') f = -1;
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9') {
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
	return x * f;
}

int d, n, m, k, Q, T, _, ans = 0;
int a[1007], in[1007];
bool flag = 0;
vector<int> G[1007];
vector<int> E[1007];
bool vis[1007], tmp[1007];

inline bool check(int x) {
	memset(tmp, 0, sizeof(tmp));
	queue<int> q;
	q.push(x);
	tmp[x] = 1;
	while (!q.empty()) {
		int u = q.front();
		q.pop();
		for (auto v : E[u]) {
			if (vis[v]) return 1; //注意这里
			if (!tmp[v]) q.push(v), tmp[v] = 1;
		}
	}
	//队列现在是空的
	for (int i = 1; i <= d; i++)
		if (!in[i] && !tmp[i])
			tmp[i] = 1, q.push(i);
	while (!q.empty()) {
		int u = q.front();
		q.pop();
		for (auto v : G[u]) if (!tmp[v]) q.push(v), tmp[v] = 1;
	}
	for (int i = 1; i <= n; i++)
		if (!tmp[a[i]]) return 1;
	return 0;
}

signed main() {
	d = read(), m = read(), n = read();
	for (int i = 1; i <= m; i++) {
		int u = read(), v = read();
		G[u].push_back(v);
		E[v].push_back(u);
		in[v]++; //入度即反向图的出度
	}
	for (int i = 1; i <= n; i++) {
		a[i] = read();
		vis[a[i]] = 1;
	}
	for (int i = 1; i <= d; i++) {
		if (vis[i] || check(i)) {
			cout << i << " ";
			a[++n] = i;
			vis[i] = 1;
		}
	}
}
```

---

## 作者：inc1ude_c (赞：2)

本篇题解将会对 [bellmanford](https://www.luogu.com.cn/user/116015) 的题解进行更通俗的讲解。

先建图，$x$ 能推出 $y$，就代表一条 $x$ 到 $y$ 的有向边。任意一个事件 $x$ 一定不会通过某些线索导致事件 $x$ 本身发生，表示图中不存在环。

事件 $u$ 发生，可以是以下三种原因之一：

1. 输入直接告诉我们 $u$ 是必然事件

2. 因为其他必然事件，我们可以推出事件 $u$ 是必然的

3. 可以肯定 $u$ 让某些必然事件被推出。换句话说，如果删去事件 $u$，那么有些必然事件就无必然性

第二种情况，就是问有没有必然事件可以走到事件 $u$。直接反向建图，看看事件 $u$ 能不能走到任何一个必然事件即可。

第三种情况较为复杂。

先看用户 bellmanford 的代码中，第一次广搜后的 $vis$ 数组是什么，可以发现，$vis_i$ 表示事件 $i$ 能不能推出事件 $u$。

然后看一下**入度为 $0$** 的事件（也就是反向建图后出度为 $0$ 的事件），假设 $v$ 入度为 $0$，如果 $vis_v=0$（也就是 $v$ 推不出 $u$），并且事件 $v$ 可以推出必然事件 $w$，那么就说明 $w$ 的必然性不需要 $u$ 来做支撑。

所以，如果 $u$ 对于所有必然事件都不需要，那么就不满足条件三，反之则说明 $u$ 是必然发生的。

---

## 作者：Poetic_Rain (赞：1)

来自一位神仙学长的思路，题意就不说了

首先当前点被确定，那么他的所有儿子节点可以被确定

考虑父亲节点。当存在两个以及两个以上的入度为$0$的点可以到达当前节点时，该点的父亲节点是不可以确定的，但是也许会推出其他有用的信息

![](https://cdn.luogu.com.cn/upload/image_hosting/te2ivfcl.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

当数据是上面这样的时候，$3$是被确定的，$1$和$2$可能被确定，但是$4$却能被确定，答案为$3$，$4$。这应该是一组有用的数据，可以帮助更深的理解

那么我们如何除了这些情况呢？

我们可以预处理出所有节点的父亲节点（包括自己和祖先），并计算出最初的可以被确定的点的数量$sum$（即题目中的$b$)

假设当前处理的点为$x$（$x$没被确定），我们把所有的点分为两类

1. $x$的父亲节点和部分子节点

2. 除$x$的父亲节点外中入读为$0$的点以及这些点的子节点

可能说得不太清楚，画图来理解

![](https://cdn.luogu.com.cn/upload/image_hosting/5jt2r73z.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

红色的即为第二类点，蓝色为第一类点，方框内的表示与$x$完全没有关系的点

那么我们可以求出红色类点中，已经被确定的点的个数$tot$:

1. 当$tot=sum$，说明蓝色类点中，没有可以被确定的点

2. 当$tot<sum$，说明蓝色类点中有其它已经被确定的点

**因为$x$是没有被确定的点（见上），那么与蓝色类点中其他被确定的点一定能推出来$x$**，这个结论也不是特别显然，建议自己手模一下

由以上结论，我们可以知道$x$已经可以被确定了，此时$sum++$

对于每个点进行上述处理之后，我们再对每一个被确定的点进行一次搜索，他的子节点一定是可以被确定的

最后输出，结束

可能不太清楚的可以看代码注释，结合上面分析

```
#include<bits/stdc++.h>
using namespace std;
int head[200010],tot;
struct node{
	int net,to;
}e[200010];
int in[20010];
void add(int x,int y){
	e[++tot].net=head[x];
	e[tot].to=y;
	head[x]=tot;
}
int n,m,d;
bool v[20010],vis[20010];
set<int>fa[20010];
void bfs(int x){
	memset(vis,false,sizeof vis);
	queue<int>q;
	q.push(x);
	vis[x]=true;
	while(!q.empty()){
		int u=q.front();
		q.pop();
		fa[u].insert(x);
		for(int i=head[u];i;i=e[i].net){
			int y=e[i].to;
			if(vis[y]) continue;
			q.push(y);
			vis[y]=true; 
		}
	}
}
int sum;
int fin(int x){
	memset(vis,false,sizeof vis);
	queue<int>q;
	for(int i=1;i<=n;i++){
		if(fa[x].find(i)==fa[x].end()&&!in[i]) q.push(i),vis[i]=true;
		//表示红色类的点 
	}
	int tal=0;
	while(!q.empty()){
		int u=q.front();
		q.pop();
		tal+=v[u]; //统计个数 
		for(int i=head[u];i;i=e[i].net){
			int y=e[i].to;
			if(vis[y]) continue;
			q.push(y);
			vis[y]=true;
		}
	}
	return tal;
}
void bfs2(){
	queue<int>q;
	for(int i=1;i<=n;i++){
		if(v[i]){
			q.push(i);
		}
	}
	while(!q.empty()){
		int x=q.front();
		q.pop();
		for(int i=head[x];i;i=e[i].net){
			int y=e[i].to;
			if(v[y]) continue;
			v[y]=true;
			q.push(y);
		}
	} 
}
int main(){
	scanf("%d%d%d",&n,&m,&d);
	for(int i=1;i<=m;i++){
		int x,y;
		scanf("%d%d",&x,&y);
		add(x,y);
		in[y]++; //入度 
	}
	for(int i=1;i<=d;i++){
		int x;
		scanf("%d",&x);
		v[x]=true; //可以被确定 
		sum++; //已经确定的个数 
	}
	for(int i=1;i<=n;i++) bfs(i); //处理出每个点的父节点 
	for(int i=1;i<=n;i++){
		if(v[i]) continue;
		if(fin(i)<sum){ //蓝色类点中有被确定的点 
			v[i]=true;
			sum++; //当前点可以被确定 
		}
	}
	bfs2(); //把子节点标记一下 
	for(int i=1;i<=n;i++){
		if(v[i]) cout<<i<<" ";
	}
	return 0;
}
```


---


# [SCOI2006] 动态最值

## 题目描述

有一个包含 $n$ 个元素的数组，要求实现以下操作：

- `DELETE k`：删除位置 $k$ 上的数。右边的数往左移一个位置。
- `QUERY i j`：查询位置 $i\sim j$ 上所有数的最小值和最大值。

例如有 $10$ 个元素：

| 位置 | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ | $7$ | $8$ | $9$ | $	10$ |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | 
| 元素 | $1$ | $5$ | $2$ | $6$ | $7$ | $4$ | $9$ | $3$ | $1$ | $5$ |

`QUERY 2 8` 的结果为 `2 9`。依次执行 `DELETE 3` 和 `DELETE 6`（注意这时删除的是原始数组的元素 $7$）后数组变为：

| 位置 | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ | $7$ | $8$ |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | 
| 元素 | $1$ | $5$ | $6$ | $7$ | $4$ | $3$ | $1$ | $5$ |

`QUERY 2 8` 的结果为 `1 7`。


## 说明/提示

对于 $50\%$ 的数据，$1 \le n, m \le {10}^4$，删除操作不超过 $100$ 个。  
对于 $100\%$ 的数据，$1 \le n, m \le {10}^6$，数组中的元素绝对值均不超过 ${10}^9$。

## 样例 #1

### 输入

```
10 4
1 5 2 6 7 4 9 3 1 5
2 2 8
1 3
1 6
2 2 8```

### 输出

```
2 9
1 7```

# 题解

## 作者：EternalEpic (赞：5)

这道题，有删除操作，于是我想到了两种做法。

法1：序列平衡树，对于做过文艺平衡树的人很简单，只要维护一个类似线段树标记，就可以了。这里不着重描述。

法2：有一个很简单暴力的方法——用线段树。一个棘手的问题就是线段树是静态的，怎么支持删除？我们根本不要在结构中删去节点，我们只要将该节点的min设置成INT_MAX，max设置成INT_MIN，就可以消除掉该节点的贡献，从而在形式上“删去”了次节点。

那么，有一个深邃的问题，删的过程中数组下标在变化，所以要用树状数组维护pos之前删去了几个数，从而得到真正的idx。

但是，题目是给你真正的下标idx，你要倒着求pos，这就需要二分了，注意，二分时可能有多个满足值，要取最大的那一个，因为前面的都是已删去的数。

Last but not the least，code is here:

```cpp
const int Maxn = 1e6 + 5; int n, m, a[Maxn];
struct SegmentTree {
	int tmin[Maxn << 2 | 1], tmax[Maxn << 2 | 1];
	SegmentTree(void) {}
	inline void pushup(int pos) {
		tmin[pos] = min(tmin[pos << 1], tmin[pos << 1 | 1]);
		tmax[pos] = max(tmax[pos << 1], tmax[pos << 1 | 1]);
	}

	inline void build(int pos, int l, int r) {
		if (l == r) { tmin[pos] = tmax[pos] = a[l]; return; }
		int mid = l + r >> 1;
		build(pos << 1, l, mid),
		build(pos << 1 | 1, mid + 1, r);
		pushup(pos);
	}

	inline void remove(int pos, int l, int r, int idx) {
		if (l == r) { tmin[pos] = INT_MAX, tmax[pos] = INT_MIN; return; }
		int mid = l + r >> 1;
		if (idx <= mid) remove(pos << 1, l, mid, idx);
		else remove(pos << 1 | 1, mid + 1, r, idx);
		pushup(pos);
	}
	
	inline int querymin(int pos, int l, int r, int L, int R) {
		if (L <= l && R >= r) return tmin[pos];
		int mid = l + r >> 1, ret = INT_MAX;
		if (L <= mid) ret = querymin(pos << 1, l, mid, L, R);
		if (R > mid) chkmin(ret, querymin(pos << 1 | 1, mid + 1, r, L, R));
		return ret;
	}

	inline int querymax(int pos, int l, int r, int L, int R) {
		if (L <= l && R >= r) return tmax[pos];
		int mid = l + r >> 1, ret = INT_MIN;
		if (L <= mid) ret = querymax(pos << 1, l, mid, L, R);
		if (R > mid) chkmax(ret, querymax(pos << 1 | 1, mid + 1, r, L, R));
		return ret;
	}
} sgt;

struct BinaryIndexTree {
	int c[Maxn];
	BinaryIndexTree(void) { Ms(c, 0); return; }
	inline void update(int pos) { for (; pos <= n; pos += lowbit(pos)) ++c[pos]; }
	inline int query(int pos) { int ret = 0; for (; pos; pos -= lowbit(pos)) ret += c[pos]; return ret; }
} bit;

inline int Index(int pos) {
	int l = 1, r = n, ans;
	while (l <= r) {
		int mid = l + r >> 1;
		if (mid - bit.query(mid) == pos) ans = mid;
		if (mid - bit.query(mid) > pos) r = mid - 1;
		else l = mid + 1;
	} return ans;
}

signed main(void) {
//	file("");
	read(n), read(m);
	for (int i = 1; i <= n; i++) read(a[i]);
	sgt.build(1, 1, n);
	for (int opt, l, r; m; m--) {
		read(opt), read(l);
		if (opt == 1) { l = Index(l);
			sgt.remove(1, 1, n, l);
			bit.update(l + 1);
		} else {
			read(r); l = Index(l), r = Index(r);
			writeln(sgt.querymin(1, 1, n, l, r), ' ');
			writeln(sgt.querymax(1, 1, n, l, r));
		}
	}
//	fwrite(pf, 1, o1 - pf, stdout);
	return 0;
}
```


---

## 作者：Wall_breaker (赞：3)

既然楼下大佬写了一篇线段树加树状数组的题解，那不会树状数组的蒟蒻我就来写一篇两颗线段树的解法（真·最慢）
 
首先，我们发现，区间内查询最大最小值，这一眼就看出来线段树可以解。事实上，线段树可以解决区间中的大部分问题。缺点也很明确，就是速度慢。对于萌新来说，线段树远比树状数组好上手。

那么，接下来怎么处理移动的问题呢？
### 原：1 2 3 4 5 6 7 8
### 删：1 2 4 5 6 8
### 现：1 2 3 4 5 6
对于原来的4号位， 前面有一个3号位被删了，所以向前1个

对于原来的8号位，前面有两个位置被删了，所以向前2个

所以，我们发现，原来的位置前删除了x个数，则向前移动x位。

那么，我们现在知道了现在的位置，怎么推出原来的位置呢？

考虑再开一颗线段树，记录位置x前一共删了几个数。然后用二分去模拟原来的位置，不断靠近x，就能找到原来的位置了。

下面是代码

```cpp
#include<bits/stdc++.h>
using namespace std;
template <typename T>
inline void read(T &x) {
	x = 0;
	T f = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') f = -1;
	for (; isdigit(c); c = getchar()) x = (x << 1) + (x << 3) + (c ^ 48);
	x *= f;
}
inline void d_read(double &x) {
	x = 0.0;
	int f = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') f = -1;
	for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);
	if (c == '.'){
		double num = 1.0;
		c = getchar();
		for (; isdigit(c); c = getchar()) x = x + (num /= 10) * (c ^ 48);
	}
	x *= f;
}

template <typename T>
inline void w(T x) {
	if (x > 9) w(x / 10);
	putchar(x % 10 + 48);
}
template <typename T>
inline void write(T x, char c) {
	if (x < 0){
		putchar('-');
		x = -x;
	}
	w(x);
	putchar(c);
}
const int M = 1e6 + 5;
int n, m, a[M], s[M * 4], sum, t[M * 4], q[M * 4], mini, maxi;
inline void update(int p, int l, int r, int k) {
	if (l == r && l == k) {
		s[p] ++;
	}
	else {
		int mid = l + r >> 1;
		if (mid >= k) update(p << 1, l, mid, k);
		else update(p << 1 | 1, mid + 1, r, k);
		s[p] = s[p << 1] + s[p << 1 | 1];
	}
} 
inline void ask(int p, int l, int r, int ql, int qr) {
	if (l >= ql && r <= qr) {
		sum += s[p];
	}
	else {
		int mid = l + r >> 1;
		if (mid >= ql) ask(p << 1, l, mid, ql, qr);
		if (mid < qr) ask(p << 1 | 1, mid + 1, r, ql, qr);
	}
	return;
}
inline void modify(int p, int l, int r, int k) {
	if (l == r && l == k) {
		t[p] = INT_MIN;
		q[p] = INT_MAX;
	}
	else {
		int mid = l + r >> 1;
		if (mid >= k) modify(p << 1, l, mid, k);
		else modify (p << 1 | 1, mid + 1, r, k);
		t[p] = max(t[p << 1], t[p << 1 | 1]);
		q[p] = min(q[p << 1], q[p << 1 | 1]);
	}
}
inline void query(int p, int l, int r, int ql, int qr) {
	if (l >= ql && r <= qr) {
		mini = min(mini, q[p]);
		maxi = max(maxi, t[p]);
	}
	else {
		int mid = l + r >> 1;
		if (mid >= ql) query(p << 1, l, mid, ql, qr);
		if (mid < qr) query(p << 1 | 1, mid + 1, r, ql, qr);
	}
}
inline int binary(int x) {
	int l = 1, r = n, res = 0;
	while (l <= r) {
		int mid = l + r >> 1;
		sum = 0;
		ask(1, 1, n, 1, mid);
		if (mid - sum == x) {
			res = mid;
		}
		if (mid - sum > x) r = mid - 1;
		else l = mid + 1;
	}
	return res;
}
inline void build(int p, int l, int r) {
	if (l == r) {
		t[p] = q[p] = a[l];
	}
	else {
		int mid = l + r >> 1;
		build(p << 1, l, mid);
		build(p << 1 | 1, mid + 1, r);
		t[p] = max(t[p << 1], t[p << 1 | 1]);
		q[p] = min(q[p << 1], q[p << 1 | 1]);
	}
}
int main() {
	read(n); read(m);
	for (int i = 1; i <= n; i ++) {
		read(a[i]);
	}
	build(1, 1, n);
	int opt, x, y, del;
	for (int i = 1; i <= m; i ++) {
		read(opt);
		if (opt == 1) {
			read(del);
			x = binary(del);
			modify(1, 1, n, x);
			update(1, 1, n, x + 1);
		}
		else {
			read(x); read(y);
			mini = INT_MAX;
			maxi = INT_MIN;
			query(1, 1, n, binary(x), binary(y));
			write(mini, ' ');
			write(maxi, '\n');
		}
	}
	return 0;
}
```

---

## 作者：FjswYuzu (赞：2)

$\ \ \ \ \ \ \ $线段树的变种好题。

$\ \ \ \ \ \ \ $考虑到查询动态的最值问题，所以排除 ST 表和单调队列。所以很容易地想到用线段树。

$\ \ \ \ \ \ \ $`query` 操作倒是很好写，由于 `delete` 操作导致的下标变动，考虑维护子树大小进行操作。

$\ \ \ \ \ \ \ $维护子树的最大值 `maxn`，最小值 `minn`，子树大小 `sizen`，其余和普通线段树相同。

$\ \ \ \ \ \ \ $删除节点时，修改 `minn` 为极大值，`maxn` 为极小值，`sizen` 清零。然后往上 `push_up`，`sizen` 减一。

$\ \ \ \ \ \ \ $然后修改 `query`。当我们在查询区间 $[l,r]$ 的时候：

- 如果 $r < st_{lc(now)}.sizen$，递归查询左儿子。

- 如果 $l > st_{lc(now)}.sizen$，递归查询右儿子的区间 $[l-st_{lc(now)}.sizen,r-st_{lc(now)},sizen]$。

- 特殊的，如果区间横跨两个节点的时候，两边 `query` 区间 $[l,st_{lc(now)}.sizen]$ 和 $[1,r-st_{lc(now)}.sizen]$。

$\ \ \ \ \ \ \ $其中 $lc(now)$ 代表 $now$ 的左子树。

```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cstring>
#include<iostream>
#define MM int mid=(l+r)>>1
#define lc(x) (x<<1)
#define rc(x) ((x<<1)|1)
using namespace std;
struct node{
	int sizen,l,r,maxn,minn;
	node(){minn=2147483647,maxn=-2147483647,sizen=l=r=0;}
}st[4000005];
int n,T,a[1000005];
void push_up(int now)
{
	st[now].sizen=st[lc(now)].sizen+st[rc(now)].sizen;
	st[now].minn=min(st[lc(now)].minn,st[rc(now)].minn);
	st[now].maxn=max(st[lc(now)].maxn,st[rc(now)].maxn);
}
void build(int l,int r,int now)
{
	st[now].l=l,st[now].r=r;
	if(l==r)
	{
		st[now].maxn=st[now].minn=a[l];
		st[now].sizen=1;
		return ;
	}
	MM;
	build(l,mid,lc(now));
	build(mid+1,r,rc(now));
	push_up(now);
}
void query(int l,int r,int now,int &minn,int &maxn)
{
	if(l==1 && r==st[now].sizen)
	{
		minn=min(minn,st[now].minn);
		maxn=max(maxn,st[now].maxn);
		return ;
	}
	int lchild=st[lc(now)].sizen,rchild=st[rc(now)].sizen;
	if(l<=lchild && r>lchild)	query(l,lchild,lc(now),minn,maxn),query(1,r-lchild,rc(now),minn,maxn);
	else if(l<=lchild && r<=lchild)	query(l,r,lc(now),minn,maxn);
	else if(l>lchild && r<=lchild+rchild)	query(l-lchild,r-lchild,rc(now),minn,maxn);
}
void revoke(int where,int now)
{
	if(st[now].l==st[now].r)
	{
		--st[now].sizen;
		st[now].minn=2147483647,st[now].maxn=-2147483647;
		return ;
	}
	int lchild=st[lc(now)].sizen;	
	if(where<=lchild)	revoke(where,lc(now));
	else	revoke(where-lchild,rc(now));
	push_up(now);
}
int main(){
	scanf("%d %d",&n,&T);
	for(int i=1;i<=n;++i)	scanf("%d",&a[i]);
	build(1,n,1);
	while(T-->0)
	{
		int op;
		scanf("%d",&op);
		if(op==1)
		{
			int x;
			scanf("%d",&x);
			revoke(x,1);
		}
		else
		{
			int minn=2147483647,maxn=-2147483647,c,d;
			scanf("%d %d",&c,&d);
			query(c,d,1,minn,maxn);
			printf("%d %d\n",minn,maxn);
		}
	}
//	for(int i=1;i<=4*n;++i)	printf("%d %d %d %d %d\n",st[i].sizen,st[i].l,st[i].r,st[i].maxn,st[i].minn);//debug
	return 0;
}
```

---

## 作者：Prean (赞：2)

昨天考试考到了这道题，那就来补一下题解吧。

题意简单不再阐述。

首先删除之后还要向左移动，很容易想到 ~~ODT~~ 平衡树，这个过于一眼，不再阐述。

重点说第二种方法。

向左平移的这个操作，我们是否可以用别的方法代替呢？

比如不向左平移，后面的操作时“修正”下标。

对于“修正”操作，可以二分。直接在线段树上二分/在树状数组上倍增（也就是在树状数组上二分）。

二分有一个要注意的细节是：如果二分的是最右边的满足条件的端点，记得不要 Find(x) 而是 Find(x-1)+1。

查询和修改操作就是线段树板子。

代码：
```cpp
#include<cstdlib>
#include<cstdio>
#include<cctype>
const int M=1e6+5,INF=0x7fffffff;
int n,m,G,tmp,t[M],a[M];
struct Node{
	int mx,mi;
	Node(const int&mx=-INF,const int&mi=INF):mx(mx),mi(mi){}
}zkw[M<<2],it;
inline int min(const int&a,const int&b){
	return a>b?b:a;
}
inline int max(const int&a,const int&b){
	return a>b?a:b;
}
inline void Add(register int id){
	for(;id<=n;id+=id&-id)++t[id];
}
inline int Find(const int&id){
	int len,ans=0,num=0;
	for(len=tmp;len;len>>=1){
		if(ans+len<=id+num+t[ans+len])num+=t[ans+=len];
	}
	return ans;
}
inline Node merge(const Node&a,const Node&b){
	return Node(max(a.mx,b.mx),min(a.mi,b.mi));
}
inline void update(const int&u){
	zkw[u]=merge(zkw[u<<1],zkw[u<<1|1]);
}
inline void Build(){
	register int i;
	for(G=1;G<=n+1;G<<=1);
	for(i=1;i<=n;++i)zkw[G+i]=Node(a[i],a[i]);
	for(i=G-1;i;--i)update(i);
}
inline void Modify(int id){
	Add(id);
	for(zkw[id+=G]=Node(),id>>=1;id;id>>=1)update(id);
}
inline Node Query(int L,int R){
	Node ans=Node();
	for(L+=G-1,R+=G+1;L^R^1;L>>=1,R>>=1){
		if(~L&1)ans=merge(ans,zkw[L^1]);
		if(R&1)ans=merge(ans,zkw[R^1]);
	}
	return ans;
}
signed main(){
	register int i,x,L,R,opt;
	scanf("%d%d",&n,&m);tmp=n;
	for(i=1;i<=n;++i)scanf("%d",a+i);
	while(tmp^(tmp&-tmp))tmp^=tmp&-tmp;Build();
	for(i=1;i<=m;++i){
		scanf("%d",&opt);
		if(opt==1){
			scanf("%d",&x);
			Modify(Find(x-1)+1);
		}
		else{
			scanf("%d%d",&L,&R);
			it=Query(Find(L-1)+1,Find(R-1)+1);
			printf("%d %d\n",it.mi,it.mx);
		}
	}
}
```

---

## 作者：小菜鸟 (赞：2)

裸的平衡树（我并不知道不用线段树咋做

只要用到区间删除和区间查找。。。

---

有人写过splay了，这里给个fhq-treap供参考。（我终于渐渐有了平衡树不调试一遍过的能力，开心w

速度极慢，不开O2需15s过所有点，开了大幅下降至5s。

---

```cpp
#include<cstdio>
#include<ctime>
#include<cstdlib>
#include<algorithm>

struct Node
{
    int val,min_s,max_s,size,pri;
    Node *lc,*rc;

    Node(int _Value):
        val(_Value),
        min_s(val),
        max_s(val),
        size(1),
        pri(rand()),
        lc(NULL),
        rc(NULL)
        {}

    void maintain()
    {
        size=1;
        min_s=val;
        max_s=val;
        if(lc!=NULL)
        {
            size+=lc->size;
            min_s=std::min(min_s,lc->min_s);
            max_s=std::max(max_s,lc->max_s);
        }
        if(rc!=NULL)
        {
            size+=rc->size;
            min_s=std::min(min_s,rc->min_s);
            max_s=std::max(max_s,rc->max_s);
        }
    }
};
Node *root;

auto merge(Node *l,Node *r)
{
    if(l==NULL)return r;
    if(r==NULL)return l;
    if(l->pri>r->pri)
    {
        l->rc=merge(l->rc,r);
        l->maintain();
        return l;
    }
    else
    {
        r->lc=merge(l,r->lc);
        r->maintain();
        return r;
    }
}

void split(Node *rt,int k,Node *&l,Node *&r)
{
    if(rt==NULL)
    {
        l=NULL;
        r=NULL;
        return;
    }
    int s=1;
    if(rt->lc!=NULL)s+=rt->lc->size;
    if(s<k)
    {
        l=rt;
        split(l->rc,k-s,l->rc,r);
        l->maintain();
    }
    else
    {
        r=rt;
        split(r->lc,k,l,r->lc);
        r->maintain();
    }
}

void erase(int pos)
{
    Node *p1,*p2,*p3;
    split(root,pos+1,p2,p3);
    split(p2,pos,p1,p2);
    root=merge(p1,p3);
    delete p2;
}

auto query(int l,int r)
{
    Node *p1,*p2,*p3;
    split(root,r+1,p2,p3);
    split(p2,l,p1,p2);
    auto res=std::make_pair(p2->min_s,p2->max_s);
    root=merge(merge(p1,p2),p3);
    return res;
}

int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    for(int i=0;i<n;++i)
    {
        int x;
        scanf("%d",&x);
        root=merge(root,new Node(x));
    }
    while(m--)
    {
        int op;
        scanf("%d",&op);
        if(op==1)
        {
            int pos;
            scanf("%d",&pos);
            erase(pos);
        }
        if(op==2)
        {
            int l,r;
            scanf("%d%d",&l,&r);
            auto res=query(l,r);
            printf("%d %d\n",res.first,res.second);
        }
    }
}
```



---

## 作者：_Vix_ (赞：0)

[原题链接](https://www.luogu.com.cn/problem/P6011)

---

## 分析

第一眼：平衡树？第二眼：平衡树！

像维护线段树那样，在平衡树中多维护最大值和最小值即可。分裂时按照树的大小分，其他的和板子一样。

采用好写的 fhq，时间复杂度 $O((n+m)\log n)$。

## Code
```cpp
#include <bits/stdc++.h>
#define gc getchar
using namespace std;

inline int read() {
	int x = 0; bool flag = 0; char ch = gc();
	for (;!isdigit(ch); ch = gc()) flag |= ch == '-';
	for (; isdigit(ch); ch = gc()) x = (x << 1) + (x << 3) + (ch ^ 48);
	return flag ? ~(x - 1) : x;
}

const int N = 1e6 + 10;
int n, m, op, x, y;

struct Fhq {
	int val[N], rnd[N], siz[N], mxv[N], mnv[N], son[N][2];
	int rt, x, y, z, tid;
	Fhq() {
		memset(mxv, 0xc0, sizeof mxv);
		memset(mnv, 0x3f, sizeof mnv);
	}
	int New(int v) {
		int u = ++tid;
		val[u] = v, rnd[u] = rand(), siz[u] = 1;
		mxv[u] = max(mxv[u], v);
		mnv[u] = min(mnv[u], v);
		return u;
	}
	void update(int u) {
		siz[u] = siz[son[u][0]] + siz[son[u][1]] + 1;
		mxv[u] = max(val[u], max(mxv[son[u][0]], mxv[son[u][1]]));
		mnv[u] = min(val[u], min(mnv[son[u][0]], mnv[son[u][1]]));
	}
	void split(int u, int k, int &x, int &y) {
		if (!u) x = y = 0;
		else {
			if (k > siz[son[u][0]]) x = u, split(son[u][1], k - siz[son[u][0]] - 1, son[u][1], y);
			else y = u, split(son[u][0], k, x, son[u][0]);
			update(u);
		}
	}
	int merge(int x, int y) {
		if (!x || !y) return x + y;
		if (rnd[x] < rnd[y]) {
			son[x][1] = merge(son[x][1], y);
			update(x);
			return x;
		} else {
			son[y][0] = merge(x, son[y][0]);
			update(y);
			return y;
		}
	}
	void del(int pos) {
		split(rt, pos - 1, x, y);
		split(y, 1, y, z);
		rt = merge(x, z);
	}
	int query_max(int l, int r) {
		split(rt, r, x, z);
		split(x, l - 1, x, y);
		int res = mxv[y];
		rt = merge(x, merge(y, z));
		return res;
	}
	int query_min(int l, int r) {
		split(rt, r, x, z);
		split(x, l - 1, x, y);
		int res = mnv[y];
		rt = merge(x, merge(y, z));
		return res;
	}
} T;

int main() {
	n = read(), m = read();
	for (int i = 1; i <= n; i++) x = read(), T.rt = T.merge(T.rt, T.New(x));
	while (m--) {
		op = read();
		if (op == 1) x = read(), T.del(x);
		else x = read(), y = read(), printf("%d %d\n", T.query_min(x, y), T.query_max(x, y));
	}
	return 0;
}
```


---

## 作者：World_Creater (赞：0)

序列平衡树模板题。  

看到这题中的删除移位操作，容易想到使用 $\verb!FHQ-Treap!$ 将区间分裂成三段：在被删除的点之前的一段，要被删除的那一个点，以及删除的点之后的一段。并最后扔掉被删除的那一个点合并剩下的两段。

维护区间最大最小值时，只需要额外开两个变量，并在 $\verb!pushup!$ 的时候更新即可。

写过文艺平衡树的话应该很轻松。

说句闲话：这个做法的复杂度是 $O((n+m)\log n)$ 的，但是由于我的实现原因常数巨大，被一些神犇的 $O(m\log^2 n)$ [做法](https://www.luogu.com.cn/record/88865414)爆杀力。~~的确平衡树可以被各种乱搞代替~~。如果这题是区间删除的话应该平衡树更胜一筹。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
mt19937 rnd(time(0));
int n,m,a[1000005];
struct node{
	int lc,rc,val,size,seed,maxn,minn;
};
struct treap{
	node tree[4000005];
	int root;
	void pushup(int p)
	{
		if(!p) return ;
		tree[p].size=tree[tree[p].lc].size+tree[tree[p].rc].size+1;
		tree[p].maxn=max({tree[p].val,tree[tree[p].lc].maxn,tree[tree[p].rc].maxn});
		tree[p].minn=min({tree[p].val,tree[tree[p].lc].minn,tree[tree[p].rc].minn});
	}
	int merge(int x,int y)
	{
		if(!x||!y) return x+y;
		if(tree[x].seed<tree[y].seed)
		{
			tree[x].rc=merge(tree[x].rc,y);
			pushup(x);
			return x;
		}
		else
		{
			tree[y].lc=merge(x,tree[y].lc);
			pushup(y);
			return y;
		}
	}
	pair<int,int> split(int p,int k)
	{
		if(!p)
		{
			return {0,0};
		}
		if(tree[tree[p].lc].size>=k)
		{
			pair<int,int> t=split(tree[p].lc,k);
			tree[p].lc=t.second;
			pushup(p);
			return {t.first,p};
		}
		else
		{
			pair<int,int> t=split(tree[p].rc,k-tree[tree[p].lc].size-1);
			tree[p].rc=t.first;
			pushup(p);
			return {p,t.second};
		}
	}
	void build(int l,int r)
	{
		for(int i=l;i<=r;i++)
		{
			tree[i].lc=0;
			tree[i].rc=0;
			tree[i].size=1;
			tree[i].val=a[i];
			tree[i].seed=rnd();
			tree[i].minn=a[i];
			tree[i].maxn=a[i];
			root=merge(root,i);
		}
	}
	void del(int x)
	{
		pair<int,int> a=split(root,x-1),b=split(a.second,1);
		root=merge(a.first,b.second); 
	}
	pair<int,int> query(int l,int r)
	{
		pair<int,int> a=split(root,l-1),b=split(a.second,r-l+1);
		pushup(b.first);
		pair<int,int> res={tree[b.first].minn,tree[b.first].maxn};
		root=merge(a.first,merge(b.first,b.second));
		return res;
	}
	void sort(int p)
	{
		if(!p) return ;
		pushup(p);
		sort(tree[p].lc);
		cout<<tree[p].val<<" ";
		sort(tree[p].rc);
	}
}T;
int main()
{
	T.tree[0]={0,0,0,0,0,-1000000000,1000000000};
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	T.build(1,n);
	while(m--)
	{
		int opt;
		cin>>opt;
		if(opt==1)
		{
			int x;
			cin>>x;
			T.del(x);
		}
		else
		{
			int l,r;
			cin>>l>>r;
			pair<int,int> res=T.query(l,r);
			cout<<res.first<<" "<<res.second<<"\n";
		}
	}
}
```

---

## 作者：Tx_Lcy (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P6011)
## 思路
大家好，我非常喜欢线段树，于是我用线段树+二分+树状数组过了这道题。

我们首先看到了区间最大值，众所周知，区间最大值最简单的做法就是倍增/线段树了，但是这题需要资瓷修改，所以只能使用线段树。

接下来，我们发现这个动态的过程非常难受，设 $f_i$ 表示 $1$ 至 $i$ 可用的位置个数，显然，$f_i$ 是单调不下降的，所以我们可以利用这个性质来树状数组+二分。

我们可以二分位置，然后使用前缀和树状数组在 $\log$ 的时间复杂度下求出当前可用的位置个数。

时间复杂度 $O(m \log^2 n)$。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int const N=1e6+10;
int a[N],n;
struct node{int minx,maxx;};
struct Segment_Tree{
    #define ls (x<<1)
    #define rs (x<<1|1)
    #define mid ((l+r)>>1)
    int minx[N<<2],maxx[N<<2];
    inline void build(int x,int l,int r){
        if (l==r){minx[x]=maxx[x]=a[l];return;}
        build(ls,l,mid);build(rs,mid+1,r);
        minx[x]=min(minx[ls],minx[rs]);
        maxx[x]=max(maxx[ls],maxx[rs]);
    }
    inline node query(int x,int l,int r,int ll,int rr){
        if (ll<=l && r<=rr) return {minx[x],maxx[x]};
        node xx;xx.minx=1e9;xx.maxx=-1e9;
        if (ll<=mid){
            node le=query(ls,l,mid,ll,rr);
            xx.minx=min(xx.minx,le.minx);
            xx.maxx=max(xx.maxx,le.maxx);
        }
        if (mid<rr){
            node ri=query(rs,mid+1,r,ll,rr);
            xx.minx=min(xx.minx,ri.minx);
            xx.maxx=max(xx.maxx,ri.maxx);
        }
        return xx;
    }
    inline void update(int x,int l,int r,int p){
        if (l==r){minx[x]=1e9,maxx[x]=-1e9;return;}
        if (p<=mid) update(ls,l,mid,p);else update(rs,mid+1,r,p);
        maxx[x]=max(maxx[ls],maxx[rs]);minx[x]=min(minx[ls],minx[rs]);
    }
}T;
struct Tree_Array{
    int c[N];
    inline int lowbit(int x){return x&-x;}
    inline void update(int x,int v){while (x<=n) c[x]+=v,x+=lowbit(x);}
    inline int query(int x){int res=0;while (x) res+=c[x],x-=lowbit(x);return res;}
}t;
inline int lower(int x){
    int l=1,r=n,res=0;
    while (l<=r){
        int now=t.query(mid);
        if (mid-now==x) res=mid;
        if (mid-now>x) r=mid-1;
        else l=mid+1;
    }
    return res;
}
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    int m;cin>>n>>m;
    for (int i=1;i<=n;++i) cin>>a[i];
    T.build(1,1,n);
    while (m--){
        int opt;cin>>opt;
        if (opt==1){
            int k;cin>>k;k=lower(k);
            t.update(k+1,1);T.update(1,1,n,k);
        }
        else{
            int x,y;cin>>x>>y;
            x=lower(x);y=lower(y);
            node p=T.query(1,1,n,x,y);
            cout<<p.minx<<' '<<p.maxx<<'\n';
        }
    }
    return 0;
}
```


---

## 作者：年华天地 (赞：0)

线段树的练手好题。

### 题意
你需要写一个数据结构维护插入操作和寻找区间最大值的操作

### 方法
其实一般来说线段树是无法进行插入与删除操作的，因为线段树的性质依赖于它的结构，你一旦插入或者删除它的结构就会改变，那么它的性质也会改变。但也有特殊情况，比如说这道题。

我们可以对原序列维护一个线段树，只维护最大值就是一个裸题，但要支持删除操作的话该怎么办？暴力删绝对不行，不仅时间复杂度太大了，线段树的形态也改变了？那我们怎么办呢？我们可以在普通线段树的基础上多维护一个值——这段区间真实值的数量，那么我们查询与修改的时候就不是与mid比较了，而是与左儿子的真实值的个数作比较。

### 实现
首先，建树的时候要多出一个真实值的信息。（我用tr记录真实值）
```
void build(int id,int l,int r)
{
    t[id].l=l,t[id].r=r;
    t[id].len=t[id].tr=r-l+1;
    if (l==r)
    {
        t[id].maxx=t[id].minn=a[l];
        return ;
    }
    int mid=(l+r)/2;
    build(id*2,l,mid);
    build(id*2+1,mid+1,r);
    renew(id);
}
```

然后删除操作的时候我们找到一个点，把它的tr--，值赋为-inf，主要注意要与左儿子的真实值比较。
```
void delet(int id,int s)
{
    if (t[id].l==t[id].r)
    {
        t[id].maxx=-inf,t[id].minn=inf;
        t[id].tr--;
        return ;
    }
    if (s<=t[id*2].tr)delet(id*2,s);
    else delet(id*2+1,s-t[id*2].tr);
    renew(id);
}
```

### 完整代码
```
#include<cstdio>
#include <algorithm>
#define inf 0x3f3f3f3f
using namespace std;
const int N=3e6;
int n,m,a[N];
struct node{
    int l,r,len,tr,maxx,minn;
}t[N*3];
void renew(int id)
{
    t[id].maxx=max(t[id*2].maxx,t[id*2+1].maxx);
    t[id].minn=min(t[id*2].minn,t[id*2+1].minn);
    t[id].tr=t[id*2].tr+t[id*2+1].tr;
}
void build(int id,int l,int r)
{
    t[id].l=l,t[id].r=r;
    t[id].len=t[id].tr=r-l+1;
    if (l==r)
    {
        t[id].maxx=t[id].minn=a[l];
        return ;
    }
    int mid=(l+r)/2;
    build(id*2,l,mid);
    build(id*2+1,mid+1,r);
    renew(id);
}
void delet(int id,int s)
{
    if (t[id].l==t[id].r)
    {
        t[id].maxx=-inf,t[id].minn=inf;
        t[id].tr--;
        return ;
    }
    if (s<=t[id*2].tr)delet(id*2,s);
    else delet(id*2+1,s-t[id*2].tr);
    renew(id);
}
int ask1(int id,int l,int r)
{
    l=l<1?1:l;
    r=r<t[id].tr?r:t[id].tr;
    if (r-l+1==t[id].tr)return t[id].maxx;
    int t1=-inf,t2=-inf;
    if(r>t[id*2].tr)t1=ask1(id*2+1,l-t[id*2].tr,r-t[id*2].tr);
    if (l<=t[id*2].tr)t2=ask1(id*2,l,r);
    return max(t1,t2);
}
int ask2(int id,int l,int r)
{
    l=l<1?1:l;
    r=r<t[id].tr?r:t[id].tr;
    if (r-l+1==t[id].tr)return t[id].minn;
    int t1=inf,t2=inf;
    if(r>t[id*2].tr)t1=ask2(id*2+1,l-t[id*2].tr,r-t[id*2].tr);
    if (l<=t[id*2].tr)t2=ask2(id*2,l,r);
    return min(t1,t2);
}
int main()
{
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;i++)scanf("%d",&a[i]);
    build(1,1,n);
    int opt,l,r;
    for (int i=1;i<=m;i++)
    {
        scanf("%d",&opt);
        if (opt==1)
        {
            scanf("%d",&l);
            delet(1,l);
        }
        else
        {
            scanf("%d%d",&l,&r);
            printf("%d %d\n",ask2(1,l,r),ask1(1,l,r));
        }
    }
    return 0;
}

```

---

## 作者：YinyuDream (赞：0)

# 题解：
这道题是要求以下两个操作：删除序列上的一个数或查询一段区间的最值。对于这道题，我们可以用线段树求解。对于每一个节点，我们只需要记录当前节点的真实节点数量以及最值。当删除节点时，如果待删除的节点小于该节点左儿子的大小，在左子树递归求解，反之在右子树求解。当遍历到叶子节点时，将当前节点的大小修改为0，分别把极大值和极小值赋为-inf和inf，这样就可以避免答案错误。查询操作也是同理，根据子树的大小判断应该往那颗子树遍历。
# 代码：
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=1e6+10,inf=0x7f7f7f7f;
int n,m;
int a[maxn];
struct node{
    int _max,_min,size,l,r;
}tree[maxn*4];
void build(int id,int l,int r)
{
    tree[id].l=l,tree[id].r=r;
    if(l==r){
        tree[id]._min=tree[id]._max=a[l];
        tree[id].size=1;
        return ;
    }
    int mid=(l+r)/2;
    build(id*2,l,mid),build(id*2+1,mid+1,r);
    tree[id]._max=max(tree[id*2]._max,tree[id*2+1]._max);
    tree[id]._min=min(tree[id*2]._min,tree[id*2+1]._min);
    tree[id].size=tree[id*2].size+tree[id*2+1].size;
}
void update(int id,int x)
{
    if(tree[id].size==1){
        tree[id].size=0;
        tree[id]._min=inf;
        tree[id]._max=-inf;
        return ;
    }
    if(x<=tree[id*2].size)update(id*2,x);
    else update(id*2+1,x-tree[id*2].size);
    tree[id].size=tree[id*2].size+tree[id*2+1].size;
    tree[id]._max=max(tree[id*2]._max,tree[id*2+1]._max);
    tree[id]._min=min(tree[id*2]._min,tree[id*2+1]._min);
}
node query(int id,int l,int r)
{
    if(tree[id].size==r-l+1)return tree[id];
    if(r<=tree[id*2].size)return query(id*2,l,r);
    else if(l>tree[id*2].size)return query(id*2+1,l-tree[id*2].size,r-tree[id*2].size);
    else {
        node t1=query(id*2,l,tree[id*2].size),t2=query(id*2+1,1,r-tree[id*2].size),t3;
        t3._max=max(t1._max,t2._max),t3._min=min(t1._min,t2._min);
        return t3;
    }
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    build(1,1,n);
    for(int i=1,opt,x,y;i<=m;i++)
    {
        scanf("%d",&opt);
        if(opt==1){
            scanf("%d",&x);
            update(1,x);
        }else{
            scanf("%d%d",&x,&y);
            node t=query(1,x,y);
            printf("%d %d\n",t._min,t._max);
        }
    }
    return 0;
}

```


---

## 作者：critnos (赞：0)

这道题恶心的是删除后的移位操作。

不过可以把求区间最值的 $l,r$ 转移为线段树上的虚拟节点。就是说，先弄一个线段树维护区间最值，然后删除的时候只是用一个数据结构维护，在查询的时候利用数据结构把 $[l,r]$ 映射到线段树的 $[l',r']$ 上。

转移也很简单。

写一个平衡树维护数组下标。在删除的时候删除 $rank(k)$（平衡树中排名第 $k$ 的下标）。注意删除的时候要在线段树中剔除 $a_{rank(k)}$ 的影响。然后区间 $[l,r]$ 就是线段树中的 $[rank(l),rank(r)]$。

~~这还不如写一个文艺平衡树呢~~

这个平衡树比较特殊，你把它建出来后就会发现，如果用权值线段树实现这棵平衡树，和维护区间最值的线段树的样子完全一样。

然后就可以顺便用维护区间最值的线段树来维护一下权值线段树。

不过用权值树状数组可能会常数小一些。

下面是部分代码：

```cpp
	if(opt==1) 
		{
			madd(*f.find_by_order(l-1));//更新线段树
			f.erase(f.find_by_order(l-1));//删除下标
		}
		else
		{
			scanf("%d",&r);
			l=*f.find_by_order(l-1),r=*f.find_by_order(r-1);//映射
			printf("%d %d\n",min(1,l,r),max(1,l,r));//线段树求最值
		}
```

我没有用权值线段树写，而是用了 pb_ds。因为既然用另外的平衡树可以维护，权值线段树应该也可以。

---

## 作者：zhengrunzhe (赞：0)

这题不是裸平衡树吗 一个log啊

Splay维护最小最大值 删除都是基本操作了 找前驱后继splay一下就完了

记得添加两个哨兵 

$O(m \log n)$
```cpp
#include<cstdio>
template<class type>inline const void read(type &in)
{
	in=0;char ch(getchar());bool f(0);
	while (ch<48||ch>57){if (ch=='-')f=1;ch=getchar();}
	while (ch>47&&ch<58)in=(in<<3)+(in<<1)+(ch&15),ch=getchar();
	if (f)in=-in;
}
template<class type>inline const type min(const type &a,const type &b)
{
	return a<b?a:b;
}
template<class type>inline const type max(const type &a,const type &b)
{
	return a>b?a:b;
}
const int N(1e6+10),inf(1e9+10);
int n,m,a[N];
namespace Splay
{
	struct tree
	{
		tree *fa,*son[2];
		static tree *null;
		int val,mn,mx,size;
		void *operator new(size_t size);
		void operator delete(void *ptr);
		inline tree():val(0),mn(inf),mx(-inf),size(0)
		{
			static bool init(0);
			if (!init)
				init=1,
				null=new tree,
				null->son[0]=null->son[1]=null->fa=null;
			son[0]=son[1]=fa=null;
		}
		inline const void pushup()
		{
			size=son[0]->size+1+son[1]->size;
			mn=min(val,min(son[0]->mn,son[1]->mn));
			mx=max(val,max(son[0]->mx,son[1]->mx));
		}
		inline const bool id()
		{
			return fa->son[1]==this;
		}
		inline const void set(tree *p,const bool &d)
		{
			if (p!=null)p->fa=this;
			if (this!=null)son[d]=p;
		}
		inline const void rotate()
		{
			const bool f(id());
			tree *fa(this->fa);
			fa->fa->set(this,fa->id());
			fa->set(son[f^1],f);
			set(fa,f^1);
			fa->pushup();pushup();
		}
		inline const void splay(tree *goal);
	}*tree::null,*root;
	#define null tree::null
	char memory_pool[N*sizeof(tree)],*tail(memory_pool+sizeof memory_pool);
	void *recycle[N],**top(recycle);
	inline void *tree::operator new(size_t size){return top!=recycle?*--top:tail-=size;}
	inline void tree::operator delete(void *ptr){*top++=ptr;}
	inline const void tree::splay(tree *goal=null)
	{
		for (;fa!=goal;rotate())
			if (fa->fa!=goal)
				(fa->id()^id()?this:fa)->rotate();
		if (goal==null)root=this;
	}
	inline tree *findrank(int k)
	{
		tree *p(root);k++;
		while (1)
			if (k<=p->son[0]->size)p=p->son[0];
			else if (!(k-=p->son[0]->size+1))return p;
				else p=p->son[1];
	}
	inline const void remove(const int &pos)
	{
		tree *pre(findrank(pos-1)),*nxt(findrank(pos+1));
		pre->splay();nxt->splay(pre);
		delete nxt->son[0];
		nxt->son[0]=null;
		nxt->pushup();pre->pushup();
	}
	inline const void query(const int &l,const int &r)
	{
		tree *pre(findrank(l-1)),*nxt(findrank(r+1));
		pre->splay();nxt->splay(pre);
		printf("%d %d\n",nxt->son[0]->mn,nxt->son[0]->mx);
	}
	inline tree *build(const int &l,const int &r,tree *fa)
	{
		if (l>r)return null;
		const int mid(l+r>>1);
		tree *p(new tree);
		p->val=a[mid];if (fa)p->fa=fa;
		if (l==r)return p->pushup(),p;
		p->son[0]=build(l,mid-1,p);
		p->son[1]=build(mid+1,r,p);
		p->pushup();
		return p;
	}
}using namespace Splay;
int main()
{
	read(n);read(m);
	for (int i(1);i<=n;i++)read(a[i]);
	root=build(0,n+1,null);
	for (int opt,l,r;m--;)
		if (read(opt),read(l),opt&1)remove(l);
		else read(r),query(l,r);
	return 0;
}
```

---

## 作者：Alarm5854 (赞：0)

这道题目的时间限制有5秒，$O(m\log^2n)$ 的线段树+树状数组+二分是可以AC本题的，不过我貌似是AC的人中跑的最慢的。
### 做法：
用一个线段树维护区间的最值，每删除一个节点，就将这个节点的最大值变成-INF，最小值变成INF，再更新节点。用一个树状数组维护下标的转移量，每删除一个节点，就在原下标减去前缀和与这个下标相等的最后一个下标的后一个下标加一。用二分查找原下标减去前缀和与这个下标相等的最后一个下标，接着再以这个下标删除节点和修改值。
### 完整代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1000000 + 10;
const int INF = 1 << 30;
FILE *fin, *fout;//后面要用到的，暂时不用管
inline int read(int &x) {//快读和快写部分，不用管
	char c = 0;
	int f = x = 0;
	while (c < 48 || c > 57) {
		if (c == -1) return 0;
		if (c == '-')
			f = 1;
		c = fgetc(fin);
	}
	while (c > 47 && c < 58) x = (x << 3) + (x << 1) + (c & 15), c = fgetc(fin);
	if (f) x = -x;
	return 1;
}
template<class T, class... Args> inline int read(T &x, Args&... args) {
	return read(x) + read(args...);
}
inline void write(int x) {
	if (x < 0) {
		fputc(45, fout);
		write(-x);
		return;
	}
	if (x > 9) write(x / 10);
	fputc((x % 10) | 48, fout);
}
inline void write(char c) {
	fputc(c, fout);
}
inline void write(string s) {
	int len = s.length();
	for (int i = 0; i < len; ++i)
		fputc(s[i], fout);
}
#define l(p) t[p].l//宏定义，写起来方便
#define r(p) t[p].r
#define ma(p) t[p].maxn
#define mi(p) t[p].minn
struct SegmentTree {
	int l, r, maxn, minn;
} t[N << 2];//数组别忘记开四倍
int n, m, x, y, opt, a[N], c[N];
inline void build(int p, int l, int r) {
	l(p) = l, r(p) = r;
	if (l == r) {//只有一个数值，直接赋值
		ma(p) = mi(p) = a[l];
		return;
	}
	int m = (l + r) >> 1;
	build(p << 1, l, m);//递归子树
	build(p << 1 | 1, m + 1, r);
	ma(p) = max(ma(p << 1), ma(p << 1 | 1));
	mi(p) = min(mi(p << 1), mi(p << 1 | 1));
}
inline void erase(int p, int x) {//删除x节点
	if (l(p) == r(p)) {//修改最值，相当于删除
		ma(p) = -INF;
		mi(p) = INF;
		return;
	}
	int m = (l(p) + r(p)) >> 1;
	if (x <= m) erase(p << 1, x);
	else erase(p << 1 | 1, x);
	ma(p) = max(ma(p << 1), ma(p << 1 | 1));//别忘记更新最值
	mi(p) = min(mi(p << 1), mi(p << 1 | 1));
}
inline int QueryMax(int p, int l, int r) {//查询最大值，查询最小值如法炮制
	if (l <= l(p) && r >= r(p)) return ma(p);//只有一个数据，直接返回
	int m = (l(p) + r(p)) >> 1, res = -INF;//这里要先赋为-INF，查询最小值时要赋为INF
	if (l <= m) res = max(res, QueryMax(p << 1, l, r));//不用担心时间复杂度退化为O(n)，即使两个都递归了，下一次也只会递归一个
	if (r > m) res = max(res, QueryMax(p << 1 | 1, l, r));//等号不能有，否则TLE
	return res;
}
inline int QueryMin(int p, int l, int r) {//同上
	if (l <= l(p) && r >= r(p)) return mi(p);
	int m = (l(p) + r(p)) >> 1, res = INF;
	if (l <= m) res = min(res, QueryMin(p << 1, l, r));
	if (r > m) res = min(res, QueryMin(p << 1 | 1, l, r));
	return res;
}
inline void add(int p, int x) {//树状数组的修改操作
	for (; p <= n; p += p & -p) c[p] += x;
}
inline int ask(int p) {//树状数组的查询前缀和操作
	int res = 0;
	for (; p; p -= p & -p) res += c[p];
	return res;
}
inline int find(int x) {//二分查找原下标
	int l = 1, r = n, m, res;
	while (l <= r) {
		m = (l + r) >> 1;
		if (m - ask(m) == x) res = m;//不能直接返回
		if (m - ask(m) > x) r = m - 1;
		else l = m + 1;
	}
	return res;//返回值必定正确
}
signed main() {
	#ifdef ONLINE_JUDGE
	fin = stdin;//评测机上使用标准输入输出，本机上使用文件输入输出，可删去
	fout = stdout;
	#else
	fin = fopen("P6011.in", "rb");
	fout = fopen("P6011.out", "wb");
	#endif
	read(n, m);
	for (int i = 1; i <= n; ++i)
		read(a[i]);
	build(1, 1, n);//先进行预处理
	for (int i = 1; i <= m; ++i) {
		read(opt);
		if (opt == 1) {
			read(x), x = find(x);//卡常，否则可能TLE，下同
			erase(1, x);
			add(x + 1, 1);
		}
		else {
			read(x, y), x = find(x), y = find(y);
			write(QueryMin(1, x, y)), write(' ');
			write(QueryMax(1, x, y)), write('\n');
		}
	}
	return 0;
}
```

---


# [JSOI2015] 字符串树

## 题目背景

萌萌买了一颗字符串树的种子，春天种下去以后夏天就能长出一棵很大的字符串树。字符串树很奇特，树枝上都密密麻麻写满了字符串，看上去很复杂的样
子。

## 题目描述

字符串树本质上还是一棵树，即 $N$ 个节点 $N-1$ 条边的连通无向无环图，节点从 $1$ 到 $N$ 编号。与普通的树不同的是，树上的每条边都对应了一个字符串。萌萌和 JYY 在树下玩的时候，萌萌决定考一考 JYY。每次萌萌都写出一个字符串 $S$ 和两个节点 $U,V$，JYY 需要立即回答 $U$ 和 $V$ 之间的最短路径（即 $U,V$ 之间边数最少的路径，由于给定的是一棵树，这样的路径是唯一的）上有多少个字符串以 $S$ 为前缀。

JYY 虽然精通编程，但对字符串处理却不在行。所以他请你帮他解决萌萌的难题。

## 说明/提示

对于 $100\%$ 的数据，$1\leq N,Q\leq 10^5$，输入所有字符串长度不超过 $10$ 且只包含 `a~z` 的小写字母。

## 样例 #1

### 输入

```
4
1 2 ab
2 4 ac
1 3 bc
3
1 4 a
3 4 b
3 2 ab```

### 输出

```
2
1
1```

# 题解

## 作者：serene_analysis (赞：12)

提供第二种解法：简单 $\text{stl}$，$\text{hash}$，树剖。

#### 前言

- 和我上一篇题解不太一样，这篇题解更偏向于讲做法，会顺带提及想到这种做法的心路历程。原因最后说。

---

#### 题目大意

给一棵无根树，边有字符串权值，多次询问，每次询问给出字符串 $s$，求树上两点间路径中以 $s$ 为前缀的边数。

$n,q \le 10^5$， **所有字符串长度不超过 $10$，只含小写字母。**

---

#### 做题思考

看题，题面看完没什么想法，第一眼只想到了 $O(n \times len)$ 预处理 $\text{hash}$ 值，$O(nq)$ 暴力查询。

前缀匹配问题，看看能不能上 $\text{AC}$ 自动机之类的东西？好像不太行。

第一时间没有想到 $\text{trie}$ ，思路断掉。

看眼数据范围有没有特殊之处。“输入所有字符串长度不超过 $10$ 且只包含 `a~z` 的小写字母。”

长度不超过 $10$ ？那我的预处理就能接受了啊！能不能优化一下查询？

树上两点，询问是求数量，有可加性，那可以上树剖啊！

但是线段树怎么写？把所有字符串都记一遍？不现实。

那就换个数据结构！但是用什么呢？

这时候是拼底蕴的时候了。如果你做过[这道题](https://www.luogu.com.cn/problem/P5838)并仔细看了题解，你应该发现在第一页最下面有[Fzzzz](https://www.luogu.com.cn/user/174045)的另类做法。 $\text{vector}$ 存每个品种在树剖序（就是 $\text{dfs}$ 序） 中出现的位置，查询就在跳 $\text{top}$ 时二分查找 顶部和底部的 $\text{dfs}$ 序在询问品种的 $\text{vector}$ 中的位置差。他的做法在那道题中表现优秀，非常便于编写和调试。

回到这题，我们也可以借用这种方法。先把边权转为点权，然后将树剖的线段树换成 $\text{vector}$，把询问字符串的 $\text{hash}$ 值离散化后作为 $\text{vector}$ 的下标，每次查询在 $\text{vector}$ 上二分。

时间复杂度 $O(n \log n \times len\ +\ q \log n)$。

不要忘了把每个点的 $\text{dfs}$ 序加入 $\text{vector}$ 后要排序。

注意 $\text{vector}$ 的大小。

注意二分的写法。

记得最后把 $\text{lca}$ 的贡献减掉。

---

#### 代码

代码里使用了 $\text{map}$ 离散化，常数略大，不开 $\text{O2}$ 最大点需要 $1.9s$，开了需要 $650ms$。~~但是时限 $2s$，没想到吧~~

代码较长，原因是树剖和 $\text{hash}$ 预处理长度较大。

相信听懂了就不需要注释。

不加反作弊~~谁抄这个诡异的做法啊~~。

```
#include<algorithm>
#include<cstring>
#include<cstdio>
#include<vector>
#include<map>
typedef unsigned long long ull;
const int maxn=1e5+5;
const int maxm=maxn*2+5;
const int maxl=1e1+5;
const int jz=131;
struct edge{
	int to;
	int next;
	char str[maxl];
	void out(){
		for(int i=1;i<=(int)strlen(str+1);i++)printf("%c",str[i]);
		puts("");
		return;
	}
}qxx[maxm];
int qxx_cnt,h[maxn];
void add(int x,int y,char *s){
	int len=strlen(s+1);
	qxx_cnt++;
	for(int i=1;i<=len;i++)qxx[qxx_cnt].str[i]=s[i];
	qxx[qxx_cnt].to=y;
	qxx[qxx_cnt].next=h[x];
	h[x]=qxx_cnt;
	return;
}
void ad(int x,int y,char *s){
	add(x,y,s);
	add(y,x,s);
	return;
}
ull hash[maxn][maxl];
char up[maxn][maxl];
int d[maxn],size[maxn],fa[maxn],son[maxn];
void init(int x,int f){
	d[x]=d[f]+1;
	size[x]=1;
	fa[x]=f;
	for(int i=h[x];i;i=qxx[i].next){
		int v=qxx[i].to;
		if(v==f)continue;
		int len=strlen(qxx[i].str+1);
		hash[v][0]=1;
		for(int j=1;j<=len;j++)up[v][j]=qxx[i].str[j];
		for(int j=1;j<=len;j++)hash[v][j]=hash[v][j-1]*jz+(int)qxx[i].str[j];
		init(v,x);
		size[x]+=size[v];
		if(size[v]>size[son[x]])son[x]=v;
	}
	return;
}
int dfn[maxn],top[maxn];
int alt;
void topen(int x,int tp){
	top[x]=tp;
	dfn[x]=++alt;
	if(son[x])topen(son[x],tp);
	for(int i=h[x];i;i=qxx[i].next){
		int v=qxx[i].to;
		if(v==fa[x]||v==son[x])continue;
		topen(v,v);
	}
	return;
}
std::vector<int>apr[maxn*maxl];
std::map<ull,int>mp;
int mcnt;
int n,q;
int get(int l,int r,ull nhash){
	int id=mp[nhash];
	int rig=std::upper_bound(apr[id].begin(),apr[id].end(),r)-apr[id].begin(),
		lef=std::lower_bound(apr[id].begin(),apr[id].end(),l)-apr[id].begin();
	return rig-lef;
}
int tian(int x,int y,char *str){
	ull nhash=1;
	int len=strlen(str+1);
	for(int i=1;i<=len;i++)nhash=nhash*jz+(int)str[i];
	if(!mp[nhash])return 0;
	int ans=0;
	while(top[x]!=top[y]){
		if(d[top[x]]<d[top[y]])std::swap(x,y);
		ans+=get(dfn[top[x]],dfn[x],nhash);
		x=fa[top[x]];
	}
	if(d[x]<d[y])std::swap(x,y);
	ans+=get(dfn[y],dfn[x],nhash);
	ans-=(hash[y][len]==nhash);
	return ans;
}
signed main(){
	scanf("%d",&n);
	for(int i=1;i<=n-1;i++){
		int x,y;
		char str[maxl];
		scanf("%d%d %s",&x,&y,str+1);
		ad(x,y,str);
	}
	init(1,1);
	topen(1,1);
	for(int i=2;i<=n;i++){
		int len=(int)strlen(up[i]+1);
		for(int j=1;j<=len;j++){
			if(!mp[hash[i][j]])mp[hash[i][j]]=++mcnt;
			apr[mp[hash[i][j]]].push_back(dfn[i]);
		}
	}
	for(int i=1;i<=mcnt;i++)std::sort(apr[i].begin(),apr[i].end());
	scanf("%d",&q);
	for(int i=1;i<=q;i++){
		int x,y;
		char str[maxl];
		scanf("%d%d %s",&x,&y,str+1);
		printf("%d\n",tian(x,y,str));
	}
	return 0;
}
```

---

#### 为什么会想到这个做法

因为上来想到了 $\text{hash}$ ，一看长度很小发现可行，问题直接转化为询问一个数在树上两点间路径中的出现次数，这就是上面那题。

推荐把上题也做了。

感谢你的阅读，再见！

---

## 作者：云浅知处 (赞：6)

貌似题解区还没人写我这个做法？

题意大概是给定一棵树，每条边上有一个字符串，每次给两个点和一个新字符串，问两点路径上有多少字符串以这个字符串为前缀。

我们发现询问是一条链很难受，因此考虑先树剖，把 $u\to v$ 的路径剖成 $O(\log n)$ 段 $\text{DFS}$ 序连续的段，然后相当于在 $\text{DFS}$ 序上做 $O(q\log n)$ 次区间查询。

现在的问题就是查询区间 $[l,r]$ 中以 $S$ 为前缀的字符串个数。

考虑差分一波，变成 $[1,r]$ 的答案减去 $[1,l-1]$ 的答案，然后从 $1$ 开始做扫描线，同时维护一个 $\text{Trie}$，每次插入一个字符串，那么一个询问就相当于问此时 $\text{Trie}$ 里面有多少个字符串以它为前缀。这个属于 $\text{Trie}$ 的基操，直接写就行了。

时间复杂度为 $O(L\times (n+q)\log n)$，其中 $L=10$ 为字符串的最大长度，也就是 $\text{Trie}$ 树的高度。

代码并不是很难写，虽然我写了 $125$ 行，但是大部分其实都是板子=\_=

```cpp
#include<bits/stdc++.h>

#define int long long

using namespace std;

inline int read(){
	int x=0,f=1;char c=getchar();
	for(;(c<'0'||c>'9');c=getchar()){if(c=='-')f=-1;}
	for(;(c>='0'&&c<='9');c=getchar())x=x*10+(c&15);
	return x*f;
}

const int MN=1e5+5;

struct Trie{
	int d[MN*10][26],tot,siz[MN*10];

	void clear(){memset(d,0,sizeof(d)),tot=1,memset(siz,0,sizeof(siz));}

	void ins(string str){
		int len=str.size(),p=1;
		for(int i=0;i<len;i++){
			int c=str[i]-'a';siz[p]++;
			if(!d[p][c])d[p][c]=++tot;
			p=d[p][c];
		}
		siz[p]++;
	}

	int find(string str){
		int len=str.size(),y=1,p=1;
		for(int i=0;i<len;i++){
			int c=str[i]-'a';
			if(!d[p][c]){y=0;break;}
			p=d[p][c];
		}
		if(y==0)return 0;
		else return siz[p];
	}
}tree;

struct Edge{
	int to;string str;
	Edge(int T,string S):to(T),str(S){}
	Edge(){}
};

vector<Edge>G[MN];
int dep[MN],fa[MN],dfn[MN],siz[MN],top[MN],hson[MN];
string wei[MN],val[MN];

int dfs1(int u,int de){
	dep[u]=de,siz[u]=1;
	for(auto e:G[u]){
		int v=e.to;string w=e.str;
		if(v==fa[u])continue;
		fa[v]=u,wei[v]=w,siz[u]+=dfs1(v,de+1);
		if(siz[v]>siz[hson[u]])hson[u]=v;
	}
	return siz[u];
}

int tot=0;
void dfs2(int u,int tp){
	dfn[u]=++tot,top[u]=tp,val[tot]=wei[u];
	if(hson[u])dfs2(hson[u],tp);
	for(auto e:G[u]){
		int v=e.to;
		if(v!=fa[u]&&v!=hson[u])dfs2(v,v);
	}
}

struct Node{
	int f,id;string str;
	Node(int F,int I,string S):f(F),id(I),str(S){}
	Node(){}
};
vector<Node>q[MN];

int n,Q,ans[MN];

void add(int u,int v,int id,string str){
	while(top[u]!=top[v]){
		if(dep[top[u]]<dep[top[v]])swap(u,v);
		int l=dfn[top[u]],r=dfn[u];
		q[l-1].push_back(Node(-1,id,str));
		q[r].push_back(Node(1,id,str));
		u=fa[top[u]];
	}
	if(dep[u]>dep[v])swap(u,v);
	int l=dfn[u]+1,r=dfn[v];
	q[l-1].push_back(Node(-1,id,str));
	q[r].push_back(Node(1,id,str));
}

signed main(void){

#ifndef ONLINE_JUDGE
	freopen("in.in","r",stdin);
#endif

	cin>>n;
	for(int i=1;i<=n-1;i++){
		int u,v;string s;cin>>u>>v>>s;
		G[u].push_back(Edge(v,s)),G[v].push_back(Edge(u,s));
	}
	dfs1(1,1),dfs2(1,1);

	cin>>Q;
	for(int i=1;i<=Q;i++){
		int u,v;string s;cin>>u>>v>>s;
		add(u,v,i,s);
	}

	tree.clear();
	for(int i=2;i<=n;i++){
		tree.ins(val[i]);
		for(auto x:q[i])ans[x.id]+=x.f*tree.find(x.str);
	}

	for(int i=1;i<=Q;i++)cout<<ans[i]<<endl;

	return 0;
}
```

---

## 作者：SunsetLake (赞：5)

## 思路

每次询问 $u,v$ 的简单路径上有多少个字符串以 $s$ 为前缀，不难想到用 trie 树去维护。而普通的 trie 只能查询所有字符串中产生的答案，对于这类区间询问，就要用到可持久化 trie 树了。不会右转可持久化 trie 树[模板题](https://www.luogu.com.cn/problem/P4735)。

$u,v$ 的简单路径上编号不连续，非要把它拉到序列上可以树剖，麻烦了。树上两点间的查询还有一个简单思路：求出他们的 lca 为 $p$，那么答案就是 $ans_u+ans_v-2\times ans_p$。其中 $ans_i$ 表示 $i$ 到根节点的路径上，有多少个字符串以 $s$ 为前缀。这样，我们就只需要解决 $i$ 到根节点的问题了。

首先把边上的字符串转化到点上，因为每个点只有一个父亲，因此 $fa \to u$ 这条路径上的字符串就可以记为 $s_u$ 。然后按照 dfs 序建立每个点 trie 树的 $root$ （可持久化），每次从这个点的父亲的 $root$ 继承过来，那么下次访问这个点时就只会统计他到根节点上的答案了。算答案可以记一个 $sum_p$ 表示 trie 树上经过了 $p$ 这个点的字符串有多少个。与普通 trie 不同的是，他要记录当前点到根节点的所有答案，因此在插入时 $sum_p$ 不能单纯地 $+1$，而是用前缀和的形式要继承它父亲的答案，即 $sum_p=sum_{pre}+1$。查询如果发现一个点 $p$ 值为 $0$，那就说明没有 $s$ 这个字符串，`return 0` 就行。否则一直走完 $s$，最后 `return sum[p]`。

## code

```cpp
#include<bits/stdc++.h>
#define pb push_back
#define ll long long
#define mkp make_pair
using namespace std;
typedef pair<int,string>pii;
const int N=1e5+5;
int n,m,k,cnt,tot,dep[N];
int f[25][N],root[N];
vector<pii>e[N];
int tr[N*10][28],sum[N*10];
int work(char c){
	return c-'a'+1;
}
void insert(int pre,int p,string s){
	for(int i=0;i<s.size();++i){
		int u=work(s[i]);
		if(pre)for(int j=1;j<=26;++j)if(j!=u)tr[p][j]=tr[pre][j];//继承
		tr[p][u]=++cnt;
		p=tr[p][u];
		pre=tr[pre][u];
		sum[p]=sum[pre]+1;//更新前缀和
	}
}
int query(int p,string s){
	for(int i=0;i<s.size();++i){
		int u=work(s[i]);
		if(!tr[p][u])return 0;//没找到返回0
		p=tr[p][u];
	}
	return sum[p];
}
void dfs(int u,int fa){
	f[0][u]=fa;
	dep[u]=dep[fa]+1;
	for(int i=1;i<=20;++i)f[i][u]=f[i-1][f[i-1][u]];
	for(auto tmp:e[u]){
		int v=tmp.first;
		string s=tmp.second;
		if(v==fa)continue;
		root[v]=++cnt;
		insert(root[u],root[v],s);//每次继承它父亲的trie
		dfs(v,u);
	}
}
int lca(int x,int y){
	if(dep[x]<dep[y])swap(x,y);
	for(int i=20;i>=0;--i)if(dep[f[i][x]]>=dep[y])x=f[i][x];
	if(x==y)return x;
	for(int i=20;i>=0;--i)
		if(f[i][x]!=f[i][y]){
			x=f[i][x];
			y=f[i][y];
		}
	return f[0][x];
}
int main(){
	cin>>n;
	for(int i=1;i<n;++i){
		int a,b;
		string s;
		cin>>a>>b>>s;
		e[a].pb(mkp(b,s));e[b].pb(mkp(a,s));
	}
	dfs(1,0);
	int q;
	cin>>q;
	while(q--){
		int u,v;string s;
		cin>>u>>v>>s;
		cout<<query(root[u],s)+query(root[v],s)-2*query(root[lca(u,v)],s)<<endl;
	}
	return 0;
}
```


---

## 作者：AnneKH (赞：4)

### [原题链接](https://www.luogu.com.cn/problem/P6088)

### 前置技能：LCA, 可持久化 Trie

### 简要题意

- 给定一棵 $n$ 个点的树，树上每条边为一个字符串，你需要求出任意两个节点路径上有多少边代表的字符串以给定字符串为前缀。

- 树上路径查询问题一个很经典的思路：求出两个给定节点到根节点的答案，再减去重复的答案（LCA 到根节点的那一段，根据每道题可能稍有不同）。

- 于是问题就变成了：求出给定点到根节点路径上有多少条边代表的字符串以给定字符串为前缀。

- 很容易想到 Trie。而树上一共有 $(n - 1)$ 条以根节点为端点的链，而且有极大部分重复。考虑可持久化 Trie。

### 代码

```cpp
enum Max { N = 100000, LogN = 17, Len = 10 }; enum Inf { Inf = N + 1 };
unsigned int n, q;
using namespace std;
# include <cmath>
# include <iostream>
# include <string>
# define log log_by_9u46_MX
unsigned char log;

class Trie_Tree {
private:
    enum Char_Type_N { Char_Type_N = 26 };
    typedef unsigned int ID_Type;
    typedef unsigned int Size_Type;
    struct Point {
        ID_Type daughter[Char_Type_N];
        Size_Type size;
        Point() {
            for (unsigned char register i(0); i < Char_Type_N; ++i) daughter[i] = 0;
            size = 0;
        }
    } p[N * Len + 1];
    ID_Type root[N + 1];
    ID_Type length;
public:
    Trie_Tree() { p[root[1] = ++(length = 0)].size = 0; }
    void const inline Insert(string const s, ID_Type const mother, ID_Type const x) {
        ID_Type from(root[mother]), to(root[x] = ++length);
        for (unsigned char register i(0); i < s.length(); ++i) {
            for (unsigned char register j(0); j < Char_Type_N; ++j) p[to].size += p[p[to].daughter[j] = p[from].daughter[j]].size;
            ++p[to].size, from = p[from].daughter[s[i] - 'a'], to = p[to].daughter[s[i] - 'a'] = ++length;
        }
        ++p[to].size;
    }
    unsigned int const inline Query(string const s, ID_Type const x) {
        ID_Type t(root[x]);
        for (unsigned char register i(0); i < s.length(); ++i) t = p[t].daughter[s[i] - 'a'];
        return p[t].size;
    }
} trie;
# include <vector>
struct Point {
    struct Edge {
        unsigned int to;
        string str;
        Edge() { str.clear(); }
        Edge(unsigned int const to, string const str) { this->to = to, this->str = str; }
    };
    unsigned int mother[LogN];
    unsigned int depth;
    vector<Edge> out;
    Point() {
        for (unsigned char register i(0); i < LogN; ++i) mother[i] = 0;
        depth = 0, out.clear();
    }
} p[N + 1];

void const inline add(unsigned int const, unsigned int const, string const);
void const inline in() {
    cin >> n, log = log2(n);
    for (unsigned int register i(1); i < n; ++i) {
        unsigned int u, v; string s;
        cin >> u >> v >> s;
        add(u, v, s);
    }
}

void const search(unsigned int const x = 1, unsigned int const from = 0) {
    p[x].depth = p[from].depth + 1, p[x].mother[0] = from;
    for (unsigned char register i(1); i <= log; ++i) p[x].mother[i] = p[p[x].mother[i - 1]].mother[i - 1];
    for (unsigned int register i(0); i < p[x].out.size(); ++i) {
        if (p[x].out[i].to == from) continue;
        trie.Insert(p[x].out[i].str, x, p[x].out[i].to);
        search(p[x].out[i].to, x);
    }
}

unsigned int const inline LCA(unsigned int, unsigned int);
void const inline solve() {
    unsigned int u, v; string s;
    cin >> u >> v >> s;
    cout << trie.Query(s, u) + trie.Query(s, v) - trie.Query(s, LCA(u, v)) * 2 << endl;
}

signed int main() {
    in(), search();
    cin >> q;
    for (unsigned int register i(0); i < q; ++i) solve();
    return 0;
}

void const inline add(unsigned int const a, unsigned int const b, string const s) {
    p[a].out.push_back(Point::Edge(b, s)), p[b].out.push_back(Point::Edge(a, s));
}
# include <algorithm>
unsigned int const inline LCA(unsigned int x, unsigned int y) {
    if (p[x].depth < p[y].depth) swap(x, y);
    for (signed char register i(log); p[x].depth > p[y].depth; --i)
        if (p[p[x].mother[i]].depth >= p[y].depth) x = p[x].mother[i];
    if (x == y) return x;
    for (signed char register i(log); i >= 0; --i)
        if (p[x].mother[i] not_eq p[y].mother[i]) x = p[x].mother[i], y = p[y].mother[i];
    return p[x].mother[0];
}
```

---

## 作者：_Ch1F4N_ (赞：3)

来一发不需要任何高级数据结构的题解。

我们查询的是一个路径问题，考虑树上差分，把问题变成有一个节点到根节点的路径查询，离线询问把询问挂在点上，遍历一遍树做把从根节点到当前节点所经过的字符串用一个哈希存起来即可。

时间复杂度 $O(n \log n + n \times len)$ 瓶颈是求 LCA 假若换成线性 LCA 可以做到完全线性，空间复杂度 $O(n + \sum len)$。

```cpp
#include<bits/stdc++.h>
#include<bits/extc++.h>
using namespace std;
const int maxn = 1e5+114;
int fa[maxn][19],lg[maxn];
int answer[maxn],dep[maxn];
vector<int> edge[maxn];
__gnu_pbds::gp_hash_table<int,string> str[maxn];
int n,q;
struct Node{
	int id;
	int op;
	string s;
};
vector<Node> query[maxn];
__gnu_pbds::gp_hash_table<string,int> cnt;
string a[maxn];
void dfs1(int u,int father){
	a[u]=str[u][father];
	fa[u][0]=father;
	dep[u]=dep[father]+1;
	for(int i=1;i<=17;i++) fa[u][i]=fa[fa[u][i-1]][i-1];
	for(int v:edge[u]){
		if(v==father) continue;
		dfs1(v,u); 
	}
}
int LCA(int u, int v){
    if(dep[u]<dep[v])
        swap(u,v);
    while(dep[u]>dep[v]) {
        u=fa[u][lg[dep[u]-dep[v]]];
    }
    if(u==v)
    	return u;
    for(int i=17;i>=0;i--){
        if(fa[u][i]!=fa[v][i]){
            u=fa[u][i],v=fa[v][i];
        }
    }
    return fa[u][0];
}
void dfs2(int u){
	string s;
	for(int i=0;i<a[u].size();i++){
		s+=a[u][i],cnt[s]++;
	}
	for(Node now:query[u]){
		answer[now.id]+=now.op*cnt[now.s];
	}
	for(int v:edge[u]){
		if(v==fa[u][0]) continue;
		dfs2(v);
	}
	s.clear();
	for(int i=0;i<a[u].size();i++) s+=a[u][i],cnt[s]--;
}
int main(){
	cin>>n;
	lg[1]=0;
	for(int i=2;i<=n;i++) lg[i]=lg[i/2]+1;
	for(int i=1;i<n;i++){
		int u,v;
		string s;
		cin>>u>>v>>s;
		str[u][v]=str[v][u]=s;
		edge[u].push_back(v);
		edge[v].push_back(u);
	}
	dfs1(1,0);
	cin>>q;
	for(int i=1;i<=q;i++){
		int u,v;
		string s;
		cin>>u>>v>>s;
		query[u].push_back(Node{i,1,s});
		query[v].push_back(Node{i,1,s});
		query[LCA(u,v)].push_back(Node{i,-2,s});
	}
	dfs2(1);
	for(int i=1;i<=q;i++) cout<<answer[i]<<'\n';
}
```


---

## 作者：ImmortalWatcher (赞：3)

题目要我们求的是 $x$ 到 $y$ 的最短路径上的字符串的前缀与给定字符串相同的数量。

观察发现，答案要满足两个要求：

1、字符串要在 $x$ 到 $y$ 的最短路径上。

最短路径？？你想到了什么？

对，我们平时求树上两点最短路径长度时就是求 $x$ 、$y$ 和他们的 $LCA$ 到根节点的距离，然后加加减减即可。那么如果我们知道一个节点到根节点的路径上的合法字符串的数量，那么答案也就出来了。

2、给定字符串是该字符串的前缀。

前缀？？有什么东西可以快速判断一个字符串是多个字符串的前缀呢？

可以想到用数据结构维护。

那么维护字符串的数据结构就容易想到字典树了。

那么判断合法字符串的方法也就解决了。

但是如果对于每个节点到根节点的路径都开一个字典树的话，很明显空间会炸。

我们可以发现，一个节点的字典树状态与它的父节点的字典树状态是有联系的，就是多了它到它父亲的路径上的字符串嘛。

所以我们可以把每个字典树看做是一个历史版本，那么建课可持久化字典树就可以了。

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
struct node{int last,en,next;char s[11];} e[200001];
struct trie{int last,en,next;} tr[20000001];
int n,x,y,q,f[100001][18],tot,dep[100001],root[100001],t[20000001][2],tot1,tot2,len;
char s[11];
void add(int x,int y,char *s)
{
	e[++tot].en=y;
	for (int i=1;i<=len;i++)
		e[tot].s[i]=s[i];
	e[tot].next=e[x].last;
	e[x].last=tot;
}
void add1(int x,int y)
{
	tr[++tot1].en=y;
	tr[tot1].next=tr[x].last;
	tr[x].last=tot1;
}
void change(int k1,int k,int x,int z)
{
	t[k][0]=t[k1][0]+1;
	if (x>len) return;
	int kk=0;
	for (int i=tr[k1].last;i;i=tr[i].next)
		if (t[tr[i].en][1]!=e[z].s[x]-96) add1(k,tr[i].en);
		else kk=tr[i].en;
	t[++tot2][1]=e[z].s[x]-96;
	add1(k,tot2);
	change(kk,tot2,x+1,z);
}
void dfs(int x,int fa)
{
	dep[x]=dep[fa]+1;
	for (int i=e[x].last;i;i=e[i].next)
		if (e[i].en!=fa)
		{
			f[e[i].en][0]=x;
			len=strlen(e[i].s+1);
			root[e[i].en]=++tot2;
			change(root[x],root[e[i].en],1,i);
       			dfs(e[i].en,x);
		}
}
int lca(int x,int y)
{
	if (dep[x]<dep[y]) swap(x,y);
	for (int i=17;i>=0;i--)
		if (dep[f[x][i]]>=dep[y]) x=f[x][i];
	if (x==y) return x;
	for (int i=17;i>=0;i--)
		if (f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];
	return f[x][0];
}
int query(int k,int x)
{
	int kk=0;
	for (int i=tr[k].last;i;i=tr[i].next)
		if (t[tr[i].en][1]==s[x]-96)
		{
			kk=tr[i].en;
			break;
		}
	if (kk)
	{
		if (x==len) return t[kk][0];
		else return query(kk,x+1);
	}
	return 0;
}
int main()
{
	scanf("%d",&n);
	for (int i=1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		scanf("%s",s+1);
		len=strlen(s+1);
		add(x,y,s);add(y,x,s);
	}
	dfs(1,0);
	for (int j=1;j<=17;j++)
		for (int i=1;i<=n;i++)
			f[i][j]=f[f[i][j-1]][j-1];
	scanf("%d",&q);
	for (int i=1;i<=q;i++)
	{
		scanf("%d%d",&x,&y);
		scanf("%s",s+1);
		len=strlen(s+1);
		int z=lca(x,y);
		printf("%d\n",query(root[x],1)+query(root[y],1)-query(root[z],1)*2);
	}
	return 0;
}
```


---

## 作者：Endt (赞：3)

# 字符串树-题解

### 题面

一棵树，$n$ 个点，$n-1$ 条边，每条边对应一个字符串。$m$ 次询问，每次询问给出两个点 $x,y$ 和一个字符串 $s$，回答 $x$ 到 $y$ 路径上的所有字符串中以s为前缀的有多少个。

### 分析

前缀 $\to$ Trie Hash

树上最短路径 $\to$ LCA

LCA 很好求，可以用倍增、树剖、Tarjan 离线这些算法。接下来分析如何统计路径上的信息。

需要求的满足区间加减性，定义 $Ans(x\to y)$ 表示这条链上的答案，那么通过简单的容斥可得 :

$$
Ans(x\to LCA(x,y)\to y)=Ans(root\to x)+Ans(root\to y)-2Ans(root\to LCA(x,y))
$$

现在只需要解决从根节点到子节点之间的求解了。

给每一个节点建一棵 Trie，储存从根节点到此节点经过的字符串。这中间有极多的重复部分，可以改成可持久化 Trie，每一个节点以它的父亲节点为基础，加上它父亲与它连边上的字符串。

就好了！复杂度为 $O(Q\log N)$

#### 代码及注释

```cpp
#include<bits/stdc++.h>

using std::string;
using std::vector;
using std::pair;

int n,q;
class Trie{
public:
    int c[30];
    int num;
}t[3000000];//可持久化Trie
int Tcnt;
int rt[100005];
int Rcnt;
void ins(int p,string s){//插入
    q=++Tcnt;rt[++Rcnt]=q;
    for(char c:s){
        t[q]=t[p];
        ++t[q].num;
        t[q].c[c-'a']=++Tcnt;
        p=t[p].c[c-'a'],q=t[q].c[c-'a'];
    }
    t[q]=t[p];
    ++t[q].num;
}
int pre(int p,string s){//前驱个数（就存在num里面）
    for(char c:s){
        p=t[p].c[c-'a'];
    }
    return t[p].num;
}

class Node{
public:
    vector<pair<int,string>> c;
    int fa[20];
    int dp;
    int rt;
}a[100005];
void dfs(int x){//LCA初始化
    for(int i=1;i<20;++i){
        a[x].fa[i]=a[a[x].fa[i-1]].fa[i-1];
    }
    a[x].dp=a[a[x].fa[0]].dp+1;
    
    a[x].rt=rt[Rcnt];
    for(pair<int,string> i:a[x].c){
        int v=i.first;
        if(v!=a[x].fa[0]){
            a[v].fa[0]=x;
            ins(a[x].rt,i.second);
            dfs(v);
        }
    }
}
int lca(int x,int y){//LCA
    if(a[x].dp<a[y].dp)return lca(y,x);
    for(int i=19;i>=0;--i){
        if(a[a[x].fa[i]].dp>=a[y].dp)
            x=a[x].fa[i];
    }
    if(x==y)return y;
    for(int i=19;i>=0;--i){
        if(a[x].fa[i]!=a[y].fa[i])
            x=a[x].fa[i],y=a[y].fa[i];
    }
    return a[x].fa[0];
}

int main(){
    scanf("%d",&n);
    for(int i=1;i<n;++i){
        int u,v;string s;
        scanf("%d%d",&u,&v);std::cin>>s;
        a[u].c.push_back({v,s}),a[v].c.push_back({u,s});
    }
    dfs(1);
    scanf("%d",&q);
    while(~--q){
        int u,v;string s;
        scanf("%d%d",&u,&v);std::cin>>s;
        int w=lca(u,v);
        printf("%d\n",pre(a[u].rt,s)+pre(a[v].rt,s)-2*pre(a[w].rt,s));//上文推的容斥
    }
    return 0;
}
```
 


---

## 作者：唐一文 (赞：3)

发现字符串长度很小，考虑哈希。

每次询问相当于求出 $x$ 到 $y$ 路径上的字符串前缀长度为 $\left|S\right|$ 且哈希值与 $S$ 相等的个数。

一个很显然的做法是把哈希值离散化，开 $10$ 个主席树，第 $i$ 个记录每个长度为 $i$ 的哈希值的出现次数，和 [Count on a tree](https://www.luogu.com.cn/problem/P2633) 类似，不过注意这里边权转点权之后查询时是减去两倍的 LCA 而不是 LCA 和它的父亲。

记 $m=\sum\left|S\right|$，时间 $O\left(m\log m+q\log m\right)$，空间 $O(m\log m)$。

虽然这样已经过了，但是这样空间开销很大。

可以把询问拆成求从根到 $x$，根到 $y$ 和 根到 LCA 三条路径上的出现次数，然后离线下来就变成了单点修改单点查询，开个桶记录一下即可。

时间 $O(m\log m+q)$，空间 $O(m)$。

[主席树](https://www.luogu.com.cn/paste/29xetp34)

[离线做法](https://www.luogu.com.cn/paste/sv74udlc)

闲话：

一开始我写了个主席树 RE 了 4 个点，我以为是主席树空间太大了，又写了个离线做法，结果还是 RE。最后调了半天才发现是离散化数组开小了（

---

## 作者：hzjnsy (赞：2)

**[cnblogs](https://www.cnblogs.com/MnZnOIerLzy/articles/17704089.html)**

![](https://cdn.luogu.com.cn/upload/image_hosting/bkuv8zm8.png?x-oss-process=image/resize,m_lfit,h_1700,w_2205)

**[题目传送门](https://www.luogu.com.cn/problem/P6088 "题目传送门")**

> - 给出 $n$ 个点的树，边上有字符串 $s$，$q$ 次询问 $u,v$ 两点路径上有多少边的字符串以字符串 $t$ 为前缀。
>
> - $n,q\le 10^5$，$|s_i|\le 10$。

注意到 $|s_i|\le 10$，即本质不同的前缀不会超过 $10^6$ 种。于是先边转点，然后运用 [P5838](https://www.luogu.com.cn/problem/P5838 "P5838") 的套路，有两种方法：

- **【方法一】**

  对每种字符串建立动态开点线段树，线段树上的区间维护对应的 $dfn$ 序区间内该前缀的出现次数。跳链时在对应前缀的线段树上查询。
  
  时间复杂度为 $\mathcal{O}(q\log ^2 n)$，空间复杂度为 $\mathcal{O}\left(\left(\sum\limits_{i=1}^ns_i\right)\times 
  \log n\right)$。
  
  可以参考我 [P5838](https://www.cnblogs.com/MnZnOIerLzy/articles/17114627.html "P5838") 的题解。
  
- **【方法二】**

  对每种前缀开一个 `vector`，按从小到大的顺序存放具有该前缀节点的 $dfn$ 序。跳链时，设当前跳到点 $u$，二分出 $l$ 表示第一个大于等于 $dfn_{top_u}$ 的值的位置，$r$ 表示最后一个不超过 $dfn_u$ 的位置，则该重链的贡献为 $r-l+1$。
  
  时间复杂度为 $\mathcal{O}(q\log^2 n)$，空间复杂度为 $\mathcal{O}\left(\sum\limits_{i=1}^ns_i\right)$。
  
  可以参考我 [CF463E](https://www.cnblogs.com/MnZnOIerLzy/articles/17681318.html "CF463E") 的题解。
  
相比之下，【方法一】空间更劣，常数更大，但是可以支持更多的修改操作。【方法二】空间较优，常数较小，但是在修改方面有一定的局限性。

给的是【方法二】的代码。

**[评测记录](https://www.luogu.com.cn/record/124272144 "评测记录")**

```cpp
#include <bits/stdc++.h>
#define str string 
#define vec vector
#define P pair
#define eb emplace_back
#define fi first 
#define se second
#define bg begin 
#define ed end
using namespace std; const int N = 1e5 + 5;
int n, q, dep[N], top[N], siz[N], fa[N], dfn[N], id, hson[N]; 
map<str, vec<int>> mp; str s, t; vec<P<int, str>> g[N]; str col[N];
void dfs1(int u) {
    siz[u] = 1;
    for (auto i : g[u]) {
        if (i.fi == fa[u]) continue;
        col[i.fi] = i.se, dep[i.fi] = dep[fa[i.fi] = u] + 1;
        dfs1(i.fi), siz[u] += siz[i.fi];
    }
}
void dfs2(int u) {
    for (auto i : g[u])
        if (i.fi != fa[u]) {
            if ((siz[i.fi] << 1) > siz[u]) top[hson[u] = i.fi] = top[u];
            else top[i.fi] = i.fi; 
            dfs2(i.fi);
        }
}
void dfs3(int u) {
    dfn[u] = ++id, t = ""; int l = col[u].size();
    for (int i = 0; i < l; ++i) t += col[u][i], mp[t].eb(id);
    if (hson[u]) dfs3(hson[u]);
    for (auto i : g[u]) {
        if (i.fi == fa[u] || i.fi == hson[u]) continue; dfs3(i.fi);
    }
}
int query(int x, int y, str k) {
    if (mp.find(k) == mp.end()) return 0; int ret = 0;
    while (top[x] != top[y]) {
        if (dep[top[x]] < dep[top[y]]) swap(x, y);
        int u = lower_bound(mp[k].bg(), mp[k].ed(), dfn[top[x]]) - mp[k].bg();
        int v = upper_bound(mp[k].bg(), mp[k].ed(), dfn[x]) - mp[k].bg() - 1;
        ret += v - u + 1; x = fa[top[x]];
    }
    if (x == y) return ret;//有个 shaber 忘记处理同一重链的情况了，我不说是谁。
    if (dep[x] > dep[y]) swap(x, y);
    int u = lower_bound(mp[k].bg(), mp[k].ed(), dfn[x] + 1) - mp[k].bg();
    int v = upper_bound(mp[k].bg(), mp[k].ed(), dfn[y]) - mp[k].bg() - 1;
    return ret + v - u + 1;
}
signed main() {
    cin.tie(0), cout.tie(0), ios::sync_with_stdio(0); cin >> n;
    for (int i = 1, u, v; i < n; ++i)
        cin >> u >> v >> s, g[u].eb(v, s), g[v].eb(u, s);
    dfs1(1), dfs2(top[1] = 1), dfs3(1); cin >> q;
    for (int u, v; q--;) cin >> u >> v >> s, cout << query(u, v, s) << '\n';
    return 0;
}
```

---

## 作者：creation_hy (赞：1)

来个最无脑的做法（

把每条边的字符串弄到子节点上去，然后给每个点的字符串建 Trie，转化为求路径上有多少点在 Trie 上在给定字符串子树内。

计算 Trie 上每个点的 dfs 序区间 $[in_x,out_x]$，设给定字符串在 Trie 上是 $p$，转化为求路径上有多少点的 $in_x$ 在 $[in_p,out_p]$，树剖套主席树即可。

然后注意最后要把 LCA 在答案里面去掉，因为 LCA 的字符串对应边是它父亲到它。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 2e5 + 5;
const int M = 3e6 + 5;
int n, q, head[N], to[N], nxt[N], etot;
string val[N], s[N];
int rt[N], pos[N], num[N];
ll sum[N];
inline void link(int u, int v, string w)
{
    to[etot] = v;
    val[etot] = w;
    nxt[etot] = head[u];
    head[u] = etot++;
}
struct SegTree
{
    int L[M], R[M], sz[M], tot;
    inline int insert(int pre, int l, int r, int x)
    {
        int p = ++tot;
        sz[p] = sz[pre] + 1;
        if (l == r)
            return p;
        int mid = l + r >> 1;
        if (x <= mid)
            L[p] = insert(L[pre], l, mid, x), R[p] = R[pre];
        else
            L[p] = L[pre], R[p] = insert(R[pre], mid + 1, r, x);
        return p;
    }
    inline int query(int p1, int p2, int l, int r, int qx, int qy)
    {
        if (qx <= l && r <= qy)
            return sz[p2] - sz[p1];
        int mid = l + r >> 1, res = 0;
        if (qx <= mid)
            res += query(L[p1], L[p2], l, mid, qx, qy);
        if (mid < qy)
            res += query(R[p1], R[p2], mid + 1, r, qx, qy);
        return res;
    }
} seg;
struct Trie
{
    int t[M][26], in[M], out[M], tot, cnt;
    inline void insert(string s, int id)
    {
        int p = 0;
        for (char c : s)
        {
            c -= 'a';
            if (!t[p][c])
                t[p][c] = ++tot;
            p = t[p][c];
        }
        pos[id] = p;
    }
    inline int find(string s)
    {
        int p = 0;
        for (char c : s)
        {
            c -= 'a';
            if (!t[p][c])
                return -1;
            p = t[p][c];
        }
        return p;
    }
    inline void dfs(int x)
    {
        in[x] = ++cnt;
        for (int i = 0; i < 26; i++)
            if (t[x][i])
                dfs(t[x][i]);
        out[x] = cnt;
    }
} tr;
struct HLD
{
    int sz[N], son[N], id[N], cnt, up[N], dep[N], top[N];
    inline void dfs1(int x, int fa)
    {
        sz[x] = 1, dep[x] = dep[up[x] = fa] + 1;
        for (int i = head[x]; ~i; i = nxt[i])
            if (to[i] != fa)
            {
                s[to[i]] = val[i], dfs1(to[i], x), sz[x] += sz[to[i]];
                if (sz[to[i]] > sz[son[x]])
                    son[x] = to[i];
            }
    }
    inline void dfs2(int x, int fa, int tp)
    {
        num[id[x] = ++cnt] = x, top[x] = tp;
        if (son[x])
            dfs2(son[x], x, tp);
        for (int i = head[x]; ~i; i = nxt[i])
            if (to[i] != fa && to[i] != son[x])
                dfs2(to[i], x, to[i]);
    }
    inline int query(int x, int y, int pos)
    {
        int res = 0;
        while (top[x] != top[y])
        {
            if (dep[top[x]] < dep[top[y]])
                swap(x, y);
            res += seg.query(rt[id[top[x]] - 1], rt[id[x]], 1, tr.cnt, tr.in[pos], tr.out[pos]);
            x = up[top[x]];
        }
        if (dep[x] > dep[y])
            swap(x, y);
        return res + seg.query(rt[id[x]], rt[id[y]], 1, tr.cnt, tr.in[pos], tr.out[pos]);
    }
} hld;
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    memset(head, -1, sizeof(head));
    cin >> n;
    string str;
    for (int i = 1, u, v; i < n; i++)
        cin >> u >> v >> str, link(u, v, str), link(v, u, str);
    hld.dfs1(1, 0), hld.dfs2(1, 0, 1);
    for (int i = 2; i <= n; i++)
        tr.insert(s[i], i);
    tr.dfs(0);
    for (int i = 2; i <= n; i++)
        rt[i] = seg.insert(rt[i - 1], 1, tr.cnt, tr.in[pos[num[i]]]);
    cin >> q;
    while (q--)
    {
        int x, y;
        cin >> x >> y >> str;
        int p = tr.find(str);
        cout << (~p ? hld.query(x, y, p) : 0) << '\n';
    }
    return 0;
}
```

---

## 作者：huangrenheluogu (赞：1)

考虑树上差分。

维护一个字符串到根节点路径上所有点的 Trie，记 $sum_{i,s}$ 表示第 $i$ 个点查询 $s$ 是几个字符串的前缀的答案。

对于 $u,v,s$，答案显然就是 $sum_{v,s}+sum_{u,s}-2sum_{lca,s}$，树上差分的思想应该比较好理解。

下面就是可持久化 Trie 的过程。

可以类比主席树，我的做法是维护一个节点，如果不用延伸就和 $pre$ 指向同一个节点，否则就新建节点。

感觉结合主席树的思想会比较好推。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5, M = 15, C = 27;
int n, q, u, v, fir[N], nxt[N << 1], son[N << 1], tot = 1, fa[N][18], rt[N], dep[N], len, trie[N * M][C], ed[N * M], idx, res, LCA, sum1, sum2, sum3, p;
string w[N << 1], s;
inline void add(int x, int y){
	nxt[++tot] = fir[x];
	fir[x] = tot;
	son[tot] = y; 
}
inline int upd(int pre){
	res = ++idx;
	p = idx;
	len = s.size();
	for(int i = 0; i < len; i++){
		trie[p][s[i] - 'a'] = ++idx;
		ed[idx] = ed[trie[pre][s[i] - 'a']];
		ed[idx]++;
		for(int j = 0; j < 26; j++){
			if(j == s[i] - 'a') continue ;
			trie[p][j] = trie[pre][j];
		}
		p = trie[p][s[i] - 'a'];
		pre = trie[pre][s[i] - 'a'];
	}
	return res;
}
inline void dfs(int x, int ff){
	dep[x] = dep[ff] + 1;
	fa[x][0] = ff;
	for(int i = 1; i <= 17; i++) fa[x][i] = fa[fa[x][i - 1]][i - 1];
	for(int i = fir[x]; i ; i = nxt[i]){
		if(son[i] == ff) continue ;
		s = w[i];
		rt[son[i]] = upd(rt[x]);
		dfs(son[i], x);
	}
}
inline int lca(int x, int y){
	if(dep[x] < dep[y]) swap(x, y);
	for(int i = 17; ~i; i--){
		if(dep[fa[x][i]] < dep[y]) continue ;
		x = fa[x][i];
	}
	if(x == y) return x;
	for(int i = 17; ~i; i--){
		if(fa[x][i] != fa[y][i]){
			x = fa[x][i];
			y = fa[y][i];
		}
	}
	return fa[x][0];
}
inline int query(int p){
	len = s.size();
	for(int i = 0; i < len; i++){
		if(trie[p][s[i] - 'a'] == 0) return 0;
		p = trie[p][s[i] - 'a'];
	}
	return ed[p];
}
int main(){
	scanf("%d", &n);
	for(int i = 1; i < n; i++){
		scanf("%d%d", &u, &v);
		add(u, v), add(v, u);
		cin >> w[tot];
		w[tot ^ 1] = w[tot];
	}
	dfs(1, 0);
	scanf("%d", &q);
	for(int i = 1; i <= q; i++){
		scanf("%d%d", &u, &v);
		cin >> s;
		LCA = lca(u, v);
		sum1 = query(rt[u]);
		sum2 = query(rt[v]);
		sum3 = query(rt[LCA]);
		printf("%d\n", sum1 + sum2 - 2 * sum3);
	}
	return 0;
}
/*
4
1 2 ab
2 4 ac
1 3 bc
1
3 4 ab
*/
```

---

## 作者：未来姚班zyl (赞：1)

## 题目大意
一棵边权为字符串的树，多次询问两点路径上的边权有多少字符串以给定字符串为前缀。
## 题目分析
可持久化 trie 板子题。
- 路径——LCA。
- 前缀与计数——trie。
- 多次询问——可持久化。

求 LCA 可以倍增/树剖/RMQ，前两者时间复杂度分别 $O(n\log n+q\log n)$，$O(n+q\log n)$ 对于这种多次询问的题目，我们通常使用 RMQ 的 $O(n\log n+q)$。因为~~树剖代码稍长~~有的题目的查询次数可能会很大。

类比[这一道题（树上可持久化线段树）](https://www.luogu.com.cn/problem/P2633)的思路，本题中，我们随便选一个根节点，对树 dfs。trie 中记录儿子节点和 siz（用于记录前缀） 。每次在父亲节点（原树上的）的 trie 中加入边权（这是个字符串），这个字符串的每一个字符都要新建节点，最后复制到儿子节点的 trie 上。

要得到以 $s$ 为前缀的字符串数量，就要在对应的 trie 上找到 $s$ 结束的位置，加上这个节点对应的 siz 就是答案。而这个对应的 trie 在此题中就是两点间的路径。将其分为两段，$x$ 到 $lca(x,y)$ 和 $y$ 到 $lca(x,y)$。这样只需要先求出 $s$ 在 $x$ 的 trie 中结束的位置的 siz 减去 $s$ 在 $lca(x,y)$ 的 trie 中结束的位置，另一段同理，然后累加即可。

思路到这，空间复杂度显然，每次加入一个字符串都会占用其长度的节点，每个节点要记录每个字符对应的子节点编号，空间复杂度 $O(\sum \times\sum len)$，前面的 $\sum$ 指字符集的大小，这里是 $26$，后面的 $\sum len$ 指边上字符串的长度总和。对于时间复杂度，预处理 $O(n\log n)$，查询 $O(q+\sum len)$，前者是 RMQ 求 LCA 的复杂度，后者是查询的字符串的总长度，可以通过此题。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define L x<<1
#define R x<<1|1
#define mid (l+r>>1)
#define rep(x,y,z) for(int x=(y);x<=(z);x++)
#define per(x,y,z) for(int x=(y);x>=(z);x--)
#define ull unsigned long long
#define ui unsigned int
inline int read(){int s=0,w=1;char c=getchar();while(c<48||c>57) {if(c=='-') w=-1;c=getchar();}while(c>=48&&c<=57) s=(s<<1)+(s<<3)+c-48,c=getchar();return s*w;}
inline void pf(ll x){if(x<0) putchar('-'),x=-x;if(x>9)pf(x/10);putchar(x%10+48);}
const int N =1e5+5,M=1e5+5,inf=2147000000,base=19491001;
using namespace std;
struct node{
	int son[27],siz;
}trie[N*10];
int n=read(),h[N],to[N*2],nxt[N*2],cnt,root[N],f[N],o[N*2],st[N*2][22],Time,dep[N],lg[N*2],tot;
string w[N*2];
inline void add(int a,int b,string c){
	to[++cnt]=b,nxt[cnt]=h[a],h[a]=cnt,w[cnt]=c;
}
inline int insert(int &x,int X,string s){
	x++;
	int ans=x;
	trie[x]=trie[X];
	int len=s.length();
	int now=x;
	rep(i,0,len-1){
		int k=s[i]-'a'+1;
		trie[now].son[k]=++x;
		now=trie[now].son[k],X=trie[X].son[k];
		trie[now]=trie[X];
		trie[now].siz++;
	}
	return ans;
}
inline int query(int X,int x,string s){
	int len=s.length();
	rep(i,0,len-1){
		int k=s[i]-'a'+1;
		if(!trie[X].son[k])return 0;
		if(x!=-1){
			if(!trie[x].son[k])x=-1;
		}
		X=trie[X].son[k];
		if(x!=-1)x=trie[x].son[k];
	}
	if(x==-1)return trie[X].siz;
	return trie[X].siz-trie[x].siz;
}
inline void dfs(int x,int fa){
	f[x]=++Time,o[Time]=x,dep[x]=dep[fa]+1;
	for(int i=h[x];i;i=nxt[i]){
		int y=to[i];
		if(y^fa)root[y]=insert(tot,root[x],w[i]),dfs(y,x),o[++Time]=x;
	}
}
inline void prep(){
	st[1][0]=o[1];
	rep(i,2,Time)st[i][0]=o[i],lg[i]=lg[i>>1]+1;
	rep(p,1,19)rep(i,1,Time-(1<<p-1)+1)st[i][p]=dep[st[i][p-1]]<dep[st[i+(1<<p-1)][p-1]]?st[i][p-1]:st[i+(1<<p-1)][p-1];
}
inline int Get(int l,int r){
	int len=r-l+1;
	int p=lg[len];
	return dep[st[l][p]]<dep[st[r-(1<<p)+1][p]]?st[l][p]:st[r-(1<<p)+1][p];
}
inline int lca(int x,int y){
	int l=f[x],r=f[y];
	if(l>r)swap(l,r);
	return Get(l,r);
}
int main(){
	string s;
	for(int i=1,x,y;i^n;i++)x=read(),y=read(),cin >>s,add(x,y,s),add(y,x,s);
	int q=read();
	root[1]=0,dfs(1,0),prep();
	for(int i=1,x,y;i<=q;i++){
		x=read(),y=read(),cin >>s;
		int Lca=lca(x,y),ans=query(root[x],root[Lca],s)+query(root[y],root[Lca],s);
		pf(ans),putchar('\n');
	}
	return 0;
}
```


---

## 作者：YCSluogu (赞：1)

## P6088 题解

~~虽然树剖 + 可持久化 trie 的写法题解有，但貌似实现细节和我的并不一样，这里也讲一下吧~~
~~这篇题解主要引导一下不会可持久化 trie 的朋友~~

主要思路是可持久化 trie 和树剖。至于为什么不只用 LCA？其实树剖要快一点点（好吧其实是我当时没有想到怎么只用 LCA）。如果您还不会 trie 或者不会树剖……我觉得可以去看看别的题解或者补充相关知识再来写这道题。

#### 题意

给你一棵树，树上每一条边对应一个字符串。每次询问给定 $x, y$ 和字符串 $s$，询问 $x, y$ 之间有多少字符串以 $s$ 为前缀。

#### 亿点点解析

如果你到现在还没有显著思路，或者是不会可持久化 trie，我们可以先考虑一下这个问题的简单版：  
给定一个字符串数组 $str$，给定区间 $l, r$ 与前缀 $s$，求 $s_l$ 到 $s_r$ 之间有多少字符串的前缀为 $s$。

最暴力的思路就是从 $l$ 遍历到 $r$ 查看有多少字符串符合条件，但是其时间复杂度是 $O(qn^2)$ 显然会T。

或者可以建立 n 棵字典树，第 $i$ 棵字典树内包含着前面所有字符串的信息。这样我们在查询的时候就只需要获取第 $r$ 棵字典树内匹配数量与 第 $l - 1$ 棵字典树内匹配数量的差。

如例子 $\{aba, abb, acb\}$，我们可以得到这样几棵字典树：

![](https://cdn.luogu.com.cn/upload/image_hosting/k0i3cbgw.png)

当我们查询 $1, 3$ 中以 $ab$ 为前缀的字符串数量时，就可以获得第 3 棵字典树中的匹配数 2，第 0 棵字典树中的匹配数 0，相减得到答案。

不过这样子写不仅在内存上不优秀，在每次拷贝字典树时也会浪费过多时间。我们可以用一个比较讨巧的手段：每次只将自己修改了的节点的信息包括其连出的边重新拷贝一遍。如在插入第二个字符串 $abb$ 时，可以从第一棵（第一个版本）字典树中拷贝节点 $a$ 和 $ab$ 后进行修改。最后结果就像下面这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/r7b7eilp.png)

当插入第三个字符串时，很简单的就可以得到这张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/5cro2hct.png)

建议自己手推一遍后自己实现代码。但是这里给出我的建树方式：

``` cpp
const int kMaxN = 1e6;

// root[i] 表示第 i 个版本的字典树的根节点
int root[kMaxN];
int cnt[kMaxN];
int next[kMaxN][26];
int tot = 0;

void insert(const std::string& str, int pre, int now, int i = 0) {
  cnt[now] = cnt[pre]; // 从上一个版本那里拷贝一份
  memcpy(next[now], next[pre], sizeof(next[now])); // 从上一个版本那里拷贝一份
  cnt[now]++; // 对当前节点修改
  if (i >= str.size()) return;
  char v = str[i] - 'a';
  // 由于 next[now][v] 是会被修改的，为了不影响上一个版本，会新建一个节点，
  next[now][v] = ++tot;
  insert(str, next[pre][v], next[now][v], i + 1);
}
```
查询：
``` cpp
int query(const std::string& str, int now, int i = 0) {
  if (i >= str.size() || now == 0) return cnt[now];
  return query(str, next[now][str[i] - 'a'], i + 1);
}
```

现在我们回到弱化版的题目上来。既然我们已经可以实现可持久化 trie，这样我们在询问 $l, r, s$ 时就可以从 $r$ 版本 $l - 1$ 版本获取对应的匹配数量。

``` cpp
int query(int l, int r, const std::string& str) {
  return query(str, root[r]) - query(str, root[l - 1]);
}
```

原题目的一部分已经被解决。接下来只需要用树剖将整棵树抽成一个序列，然后每次查询 $x, y$ 时相当于转化为在一个序列上做若干次区间询问。  
不过由于题目是查询匹配的边，但是树剖更适合处理点上信息。所以可以定义一个点的字符串是它与它父亲相连的那条边的字符串（根结点的字符串为空），给出样例的图帮助理解：

![](https://cdn.luogu.com.cn/upload/image_hosting/lveday35.png)

当我们查询结点 $x, y$ 之间有多少路径以 $s$ 为前缀，就可以利用树剖来进行区间查询：

``` cpp
int ask(int x, int y, const std::string& str) {
  int ans = 0;
  while (top[x] != top[y]) {
    if (depth[top[x]] < depth[top[y]]) std::swap(x, y);
    ans += query(dfn[top[x]], dfn[x], str);
    x = fa[top[x]];
  }
  if (depth[x] > depth[y]) std::swap(x, y);
  ans += query(dfn[x], dfn[y], str);
  ans -= query(dfn[x], dfn[x], str);
  return ans;
}
```

由于我们将每个点的字符串设定为它与它父亲的连边，所以 $x$ 与 $y$ 的 LCA 是不能计入答案的，最后要减掉 LCA 的值。

全部代码就不放了（最主要的一些代码都已经给完了qwq）[AC记录](https://www.luogu.com.cn/record/90752132)，交的时候是最优解，~~可能是卡常卡出来的~~

~~第一次写紫题题解，好紧张~~



---

## 作者：Iota2029 (赞：1)

~~这道题好水~~
对于每个节点建一颗可持久化Trie，前一个版本是它的父亲，对于自己这个版本加入与它父亲连的边的字符串。然后这题没了。

对于答案，就是$Sum_u+Sum_v-2*Sum_{lca_{u,v}}$。

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

const int N = 100010;

template < class T >
inline void read(T &x)
{
	char ch = getchar(); x = 0; int fg = 1;
	for(;ch < '0' || ch > '9';) fg = ch == '-' ? -1 : 1, ch = getchar();
	for(;ch >= '0' && ch <= '9';) x = x * 10 + (ch ^ '0'), ch = getchar(); x *= fg;
}

struct Edge{ int to,nxt,id; } g[N << 1];
struct Trie{ int son[27],sum; } t[N * 10];
int last[N],cnt = 0,tot = 0,dep[N];
int n,st[N][20],m,rt[N];
char s[N][15];

void add(int u,int v,int id) { g[++cnt] = (Edge){ v,last[u],id }, last[u] = cnt; }
void Add_Edge(int u,int v,int id) { add(u,v,id), add(v,u,id); }

void build(int &root,int cur,int p,char *s,int len)
{
	root = ++tot; t[root] = t[cur], t[root].sum++;
	if(p > len) return;
	build(t[root].son[s[p] - 'a'],t[cur].son[s[p] - 'a'],p + 1,s,len);
}
void dfs(int x)
{
	for(int i = last[x];i;i = g[i].nxt)
		if(g[i].to != st[x][0]) st[g[i].to][0] = x, dep[g[i].to] = dep[x] + 1,
			build(rt[g[i].to],rt[x],1,s[g[i].id],strlen(s[g[i].id] + 1)), dfs(g[i].to);
}
int get_lca(int u,int v)
{
	if(dep[u] < dep[v]) swap(u,v);
	for(int i = 17;i >= 0; -- i)
		if(dep[st[u][i]] >= dep[v]) u = st[u][i];
	if(u == v) return u;
	for(int i = 17;i >= 0; -- i)
		if(st[u][i] != st[v][i]) u = st[u][i], v = st[v][i];
	return st[u][0];
}
int calc(int root,int len)
{
	for(int i = 1;i <= len; ++ i)
		root = t[root].son[s[0][i] - 'a'];
	return t[root].sum;
}
int main()
{
	read(n);
	for(int i = 1,u,v;i < n; ++ i)
		read(u), read(v), scanf(" %s",s[i] + 1), Add_Edge(u,v,i);
	dep[1] = 1, dfs(1), read(m), ++m;
	for(int j = 1;j <= 17; ++ j)
		for(int i = 1;i <= n; ++ i) st[i][j] = st[st[i][j - 1]][j - 1];
	for(int u,v;--m;)
	{
		read(u), read(v), scanf(" %s",s[0] + 1);
		int lca = get_lca(u,v),len = strlen(s[0] + 1);
		printf("%d\n",calc(rt[u],len) + calc(rt[v],len) - 2 * calc(rt[lca],len));
	}
	return 0;
}
```

---

## 作者：yizhiming (赞：0)

偶然发现很久之前写过极少见的可持久化 trie，平时见到的都是可持久化 01tire 记录一下。

[Link](https://www.luogu.com.cn/problem/P6088)

顺带~~推销~~推荐一下我的可持久化大杂烩[题单](https://www.luogu.com.cn/training/235446#information)。

## 题目大意

给定一个节点个数为 $n$ 的字符串树，每条边对应一个长度不超过 $10$ 的小写字母串，$Q$ 次询问 $u$ 到 $v$ 的简单路径上有几个边满足这个边的字符串以 $S$ 为前缀， $u,v,S$ 每次给出。

$1\leq n.Q \leq 10^5$。

## 题目分析

树上路径计数型问题，考虑差分，将问题转换 $u,v$ 到根的路径上满足条件的点的个数，再减去最近公共祖先的贡献即可。

所以问题转换成了如何求根到 $u$ 的路径上有多少个字符串满足条件，考虑每个节点是在他的树上父节点基础上，增加连接的这条边的字符串形成的，所以我们想到可持久化 trie，对于每个节点维护一个可持久化 trie，用来存储当前节点到根上的所有字符串，那么查询只需要找到 $S$ 这个点对应得 trie 节点，查询其内部的点数即可。

## Code

个人觉得可持久化 trie 递归式写法更好写一点。

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <queue>
using namespace std;
int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
const int N = 1e5+5;
char s[N][12],ask[N];
struct trie{
	struct aa{
		int ch[27],sum;
	}node[N*20];
	int tot;
	void upd(int &u,int v,int id,int cs){
		u = ++tot;
		node[u] = node[v];
		node[u].sum++;
		int sz = strlen(s[id]);
		if(sz==cs){
			return;
		}
		int x = s[id][cs]-'a';
		upd(node[u].ch[x],node[v].ch[x],id,cs+1);
	}
	int query(int u,int v,int L,int cs){
		int sz = strlen(ask);
		if(sz==cs){
			return node[u].sum+node[v].sum-2*node[L].sum;
		} 
		int x = ask[cs]-'a';
		return query(node[u].ch[x],node[v].ch[x],node[L].ch[x],cs+1);
	}
}T;
int n,q,rt[N];
struct ed{
	int nxt,to,id;
}edge[N*2];
int head[N],tote;
void link(int u,int v,int w){
	edge[++tote].nxt = head[u];edge[tote].to = v;head[u] = tote;edge[tote].id = w;
} 
int fa[N],siz[N],son[N],top[N],dep[N];
void dfs1(int u,int f){
	siz[u] = 1;
	for(int i=head[u];i;i=edge[i].nxt){
		int now = edge[i].to;
		if(now==f){
			continue;
		}
		fa[now] = u;
		dep[now] = dep[u]+1;
		T.upd(rt[now],rt[u],edge[i].id,0);
		dfs1(now,u);
		siz[u]+=siz[now];
		if(siz[now]>siz[son[u]]){
			son[u] = now;
		}
	}
}
void dfs2(int u,int t){
	top[u] = t;
	if(!son[u]){
		return;
	}
	dfs2(son[u],t);
	for(int i=head[u];i;i=edge[i].nxt){
		int now = edge[i].to;
		if(now==son[u]||now==fa[u]){
			continue;
		}
		dfs2(now,now);
	}
}
int Lca(int u,int v){
	while(top[u]!=top[v]){
		if(dep[top[u]]<dep[top[v]]){
			swap(u,v);
		}
		u = fa[top[u]];
	}
	if(dep[u]<dep[v]){
		swap(u,v);
	}
	return v;
}
int main(){
	n = read();
	for(int i=1;i<n;i++){
		int u,v;
		u = read();v = read();
		link(u,v,i);link(v,u,i);
		scanf("%s",s[i]);
	}
	dfs1(1,1);
	dfs2(1,1);
	q = read();
	while(q--){
		int u,v;
		u = read();v = read();
		scanf("%s",ask);
		int L = Lca(u,v);
		cout<<T.query(rt[u],rt[v],rt[L],0)<<'\n'; 
	}
	return 0;
}

```


---

## 作者：Fzrcy (赞：0)

设在 $x$ 到 $y$ 之间的最短路径中以 $S$ 为前缀的边数为 $F(x,y,S)$，树的根为 $1$。

明显的：$F(x,y,S)=F(x,Lca,S)+F(y,Lca,S)$（$Lca$ 为 $x$，$y$ 的最近公共祖先）。

记 $G(x,S)=F(1,x,S)$，有 $F(x,fa_x,S)=G(x,S)-G(fa_x,S)$（其中 $fa_x$ 为 $x$ 的祖先）。

即：$F(x,y,S)=G(x,S)+G(y,S)-2\times G(Lca,S)$。

考虑维护 $G(x,S)$：$G(x,S)$ 等于 $G(fa,S)$ 加上 $S$ 是否是 $w$ 的前缀（$w$ 为 $x$ 到 $fa$ 的边代表的字符串）。

用可持久化字典树维护 $G(x,S)$ 即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=3e5+11;
struct kchjh01trie{
    int ch[N*20][26], sz[N*20], node;
    int clone(int x){
        sz[++node]=sz[x];memcpy(ch[node],ch[x],sizeof(ch[node]));return node;
    }
    void ins(char *s, int Len, int &rt, int pre){
        int x=rt=clone(pre),y=pre; sz[x]++;
        for(int i=1; i<=Len; i++){
            int c=s[i]-'a';ch[x][c]=clone(ch[y][c]), sz[x=ch[x][c]]++,y=ch[y][c];
        }
    }
    int ask(char *s, int Len, int u){
        for(int i=1; i<=Len; i++)u=ch[u][s[i]-'a']; return sz[u];
    }
}t;
int st[N][21],dep[N],n,m,h[N],nt[N<<1],to[N<<1],cnt,rt[N],idx[N];  char s[N+5][12];
void link(int x,int y,int z){nt[++cnt]=h[x],h[x]=cnt,to[cnt]=y,idx[cnt]=z;}
void dfs(int x,int fa){
    dep[x]=dep[fa]+1,st[x][0]=fa;
    for(int i=1; i<21; i++)st[x][i]=st[st[x][i-1]][i-1];
    for(int i=h[x],v; i; i=nt[i])if(to[i]!=fa)
        t.ins(s[idx[i]],strlen(s[idx[i]]+1),rt[to[i]],rt[x]), dfs(to[i],x);
}
int Lca(int x, int y){
    if(dep[x]<dep[y])swap(x,y);
    for(int i=20; i>=0; i--)if(dep[st[x][i]]>=dep[y])x=st[x][i];
    if(x==y)return x;
    for(int i=20; i>=0; i--)if(st[x][i]!=st[y][i])x=st[x][i],y=st[y][i];
    return st[x][0];
}
char q[N]; int Len;
int get(int x){return t.ask(q,Len,rt[x]);}
int ask(int x,int y){int z=Lca(x,y);return get(x)+get(y)-2*get(z);}
int main(){
    scanf("%d",&n);
    for(int i=1,x,y; i<n; i++){
        scanf("%d %d %s",&x,&y,s[i]+1);
        link(x,y,i),link(y,x,i);
    }
    dfs(1,0); scanf("%d",&m); int x,y;
    while(m--) scanf("%d%d %s",&x,&y,q+1),Len=strlen(q+1),printf("%d\n",ask(x,y));
    return 0;
}
```



---

## 作者：fanypcd (赞：0)

可持久化 trie 树。

容易发现答案是有可减性的，如果 $a,b,c$ 三点是原树一条链深度递增的三个点，那么 $Ans_{b,c}=Ans_{a,c} - Ans_{a,b}$。

于是想到用 [可持久化 trie 树](https://oi-wiki.org//ds/persistent-trie/) 维护每个点到根的路径上的所有字符串。trie 树上每个节点维护经过当前节点的字符串有多少个。查询的返回时候前缀字符串的终点节点的维护值即可。

查询 $Ans_{u,v}$ 的时候，设 $u,v$ 的最近公共祖先为 $lc$，则 $Ans_{u,v} = Ans_{root,u} + Ans_{root,v} - 2 * Ans_{root,lc}$。

然后写个 [倍增或者树剖](https://oi-wiki.org//graph/lca/) 求 lca 就完了。

Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
template <class T> inline void read(T &x)
{
	x = 0;
	int f = 0;
	char ch = getchar();
	while(ch < '0' || ch > '9')
	{
		f |= ch == '-';
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9')
	{
		x = x * 10 + (ch - 48);
		ch = getchar();
	}
	x = f ? -x : x;
	return;
}
#define N 100005
int ch[N << 4][26], val[N << 4], cnt;
void clone(int &x)
{
	cnt++;
	memcpy(ch[cnt], ch[x], sizeof(ch[x]));
	val[cnt] = val[x];
	x = cnt;
	return;
}
inline void insert(int *x, char *s)
{
	for(int i = 1; i <= (int)strlen(s + 1); i++)
	{
		clone(*x);
		val[*x]++;
		x = &ch[*x][s[i] - 'a'];
	}
	clone(*x);
	val[*x]++;
	return;
}
inline int query(int x, char *s)
{
	for(int i = 1; i <= (int)strlen(s + 1); i++)
	{
		x = ch[x][s[i] - 'a'];
	}
	return val[x];
}
int first[N], Next[N << 1], to[N << 1], tot;
char w[N << 1][15];
inline void add(int x, int y, char z[15])
{
	Next[++tot] = first[x];
	first[x] = tot;
	to[tot] = y;
	memcpy(w[tot], z, 15);
	return;
}
int dep[N], fa[N][18], RT[N];
void dfs(int u)
{
	for(int i = 1; (1 << i) <= dep[u]; i++)
	{
		fa[u][i] = fa[fa[u][i - 1]][i - 1];
	}
	for(int i = first[u]; i; i = Next[i])
	{
		int v = to[i];
		if(dep[v])
		{
			continue;
		}
		RT[v] = RT[u];
		insert(&RT[v], w[i]);
		dep[v] = dep[u] + 1;
		fa[v][0]= u;
		dfs(v);
	}
	return;
}
int lca(int x, int y)
{
	if(dep[x] > dep[y])
	{
		swap(x, y);
	}
	for(int i = 17; i >= 0; i--)
	{
		if(dep[fa[y][i]] >= dep[x])
		{
			y = fa[y][i];
		}
	}
	if(x == y)
	{
		return x;
	}
	for(int i = 17; i >= 0; i--)
	{
		if(fa[x][i] != fa[y][i])
		{
			x = fa[x][i], y = fa[y][i];
		}
	}
	return fa[x][0];
}
int n, q;
signed main()
{
//	freopen("strings.in", "r", stdin);
//	freopen("strings.out", "w", stdout);
	read(n);
	int u, v;
	char w[15];
	for(int i = 1; i < n; i++)
	{
		read(u), read(v), scanf("%s", w + 1);
		add(u, v, w), add(v, u, w);
	}
	dep[1] = 1;
	dfs(1);
	read(q);
	while(q--)
	{
		read(u), read(v), scanf("%s", w + 1);
		int lc = lca(u, v);
		printf("%d\n", query(RT[u], w) + query(RT[v], w) - 2 * query(RT[lc], w));
	}
	return 0;
}
```

---

## 作者：MuYC (赞：0)

水水水水水题解。

#### 非完美做法！

这里带来一个并非正确复杂度，但是能够通过的做法（但是不开 O2 也能过）

（如果什么时候有人把我 Hack 了就踹我一脚我马上删题解）

#### 题解正文

做法：树上莫队

让我们把每一条边上面的字符串分解为其若干个后缀。因为字符串长度不超过 $10$ ，所以最多会有 $10$ 个后缀。

然后我们给这些后缀编号，也就是会有 $10^6$ 个字符后缀串。

做树上莫队的话还是就老样子做，加入一条边的贡献的时候就把它那些后缀的贡献全都加上，然后删除一条边的贡献的时候就把它的后缀的贡献全都减去，用一个桶维护，得到查询的答案就是查这个询问的字符串在编号后对应的桶。

这样你就获得了 $40pts$ 的好成绩！（

但是实际上有贡献的后缀只有询问查询到的那一些，于是我们至少可以删掉 $9 \times 10^5$ 个无用编号，比如 `aababaaba`，查询只有 `baaba` 和 `ba` 的话，我们就只需要留下 `ba` 和 `baaba`，其它的都是没有意义的。（好像剪枝不少，让 $40pts$ 直接到 $100pts$ 的秘技）。

把经过删除的剩余字符串重新编号，于是我们就可以得到每一个询问对应的字符串编号，还是按照一开头提到的方法做，于是我们就获得了 $100pts$ 的好成绩！

时间复杂度： 

$O(20 \times n \times \sqrt{Q} )$ (树上莫队自带 $\times  2$ ，然后因为字符串长度是 $O(10)$ 的，所以复杂度是这样的)

因为剪枝的原因所以跑过去了也不知道为什么，就发一篇题解来凑热闹吧。

#### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
char buf[1 << 21], *p1 = buf, *p2 = buf;
#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1 ++)
inline int read() {
    int x = 0, flag = 1;
    char ch = getchar();
    for( ; ch > '9' || ch < '0' ; ch = getchar()) if(ch == '-') flag = -1;
    for( ; ch >= '0' && ch <= '9' ; ch = getchar()) x = (x << 3) + (x << 1) + ch - '0';
    return x * flag;
}
inline void write(int x) {
    if(x == 0) { putchar('0'); return ; }
    int O[20], t = 0;
    while(x) {
        O[++ t] = x % 10;
        x /= 10;
    }
    for(register int i = t ; i >= 1 ; i --) putchar(O[i] + '0');
    return ;
}
unordered_map <string, int> mp, asked;
const int MAXN = 1e5 + 50;
int n, tot = 1, start[MAXN], now = 0;
int t[MAXN][20], nm[MAXN];
char s[30], f[20];
int q;
char sh[MAXN][20];
int fa[MAXN][22], dep[MAXN << 1], tail = 0, Dfs[MAXN << 1];
int fia[MAXN], ed[MAXN], block, used[MAXN << 1];
int Ans[MAXN], Cnt[MAXN * 20];
struct Edge{
	int next, to;
} edge[MAXN << 1];

struct Ques {
    int l, r, lca, id, op;
	char s[11];
} Q[MAXN << 1];

void add(int from, int to) {
	edge[++ tot] = (Edge){start[from], to};
	start[from] = tot;
	return ;
}

void DFS(int x, int from) {
    Dfs[++ tail] = x, fia[x] = tail;
    dep[x] = dep[from] + 1; fa[x][0] = from;
    for(register int i = 1 ; i <= log2(dep[x]) ; i ++) 
        fa[x][i] = fa[fa[x][i - 1]][i - 1];
    for(register int i = start[x] ; i ; i = edge[i].next) {
        int to = edge[i].to;
        if(to == from) continue;
        DFS(to, x);
    }
    Dfs[++ tail] = x, ed[x] = tail;
    return ;
}

int LCA(int x, int y) {
    if(dep[x] > dep[y]) swap(x, y);
    for(register int i = log2(dep[y]) ; i >= 0 ; i --)
        if(dep[fa[y][i]] >= dep[x]) y = fa[y][i];
    if(x == y) return x;
    for(register int i = log2(dep[x]) ; i >= 0 ; i --) {
        if(fa[x][i] != fa[y][i]) 
        x = fa[x][i], y = fa[y][i];
    }
    return fa[x][0];
}

bool cmp(Ques a, Ques b) {
    if(a.l / block != b.l / block) return a.l / block < b.l  / block;
    if(a.l / block % 2 == 1) return a.r / block < b.r / block;
	else return a.r / block > b.r / block;
}

void init() {
    n = read();
	for(register int i = 1 ; i <= n - 1 ; i ++) {
		int u = read(), v = read(), now = 0;
		char c;
		while((c = getchar()) != '\n') sh[i][now] = c, now ++;
		add(u, v), add(v, u);
	}

    DFS(1, 0), q = read();

    for(register int i = 1 ; i <= q ; i ++) {
        int u = read(), v = read(), lca = LCA(u, v), now = 0;
		char c;
		while((c = getchar()) != '\n') Q[i].s[now] = c, now ++;
		Q[i].lca = lca;
		if(!asked.count(Q[i].s)) asked[Q[i].s] = 1;
        if(dep[u] > dep[v]) swap(u, v);
        if(lca == u) {
            Q[i].id = i; Q[i].op = 2;
            Q[i].l = fia[u], Q[i].r = fia[v];
            if(Q[i].l > Q[i].r) swap(Q[i].l, Q[i].r);
        }
        else {
            Q[i].op = 1; Q[i].id = i; 
            Q[i].l = ed[u], Q[i].r = fia[v];
           if(Q[i].l > Q[i].r) Q[i].l = ed[v], Q[i].r = fia[u];
        }
    } block = pow(tail, 0.50);

	for(register int i = 1 ; i <= n - 1 ; i ++) {
		int u = edge[i * 2].to, v = edge[(i * 2) ^ 1].to, len = strlen(sh[i]);
		if(dep[v] < dep[u]) swap(u, v);
		for(register int j = 0 ; j < len ; j ++) {
			char c = sh[i][j];
			f[j] = c;
			if(!asked.count(f)) continue;
			if(!mp.count(f)) mp[f] = ++ now;
			t[v][++ nm[v]] = mp[f];
		}
		for(register int j = 0 ; j < len ;  j ++) f[j] = '\0';
	}
    return ;
}

void add(int x) {
    for(register int j = 1 ; j <= nm[x] ; j ++) Cnt[t[x][j]] ++;
    return ;
}

void del(int x) {
    for(register int j = 1 ; j <= nm[x] ; j ++) Cnt[t[x][j]] --;
    return ;
}

void ask(int x) {
    used[Dfs[x]] ? del(Dfs[x]) : add(Dfs[x]); used[Dfs[x]] ^= 1;
    return ;
}

void work() {
    sort(Q + 1, Q + 1 + q, cmp);
    int nowl = 1, nowr = 0;
    for(register int v = 1 ; v <= q ; v ++) {
        int ql = Q[v].l, qr = Q[v].r, id = Q[v].id, lca = Q[v].lca;
		if(!mp.count(Q[v].s)) { Ans[id] = 0; continue; }
        while(nowl > ql) ask(-- nowl);
        while(nowr < qr) ask(++ nowr);
        while(nowl < ql) ask(nowl ++);
        while(nowr > qr) ask(nowr --);
    	if(Q[v].op == 2) del(lca);
        Ans[id] = Cnt[mp[Q[v].s]];
        if(Q[v].op == 2) add(lca);
    }
    for(register int i = 1 ; i <= q ; i ++) write(Ans[i]), putchar('\n');
    return ;
}

int main() {
	//freopen("in", "r" ,stdin);
	//freopen("out", "w", stdout);
	init(), work();
	//cout << n << " "  << tail;
	return 0;
}
```

---


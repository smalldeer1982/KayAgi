# [JSOI2015] 非诚勿扰

## 题目背景

JYY 赶上了互联网创业的大潮，为非诚勿扰开发了最新的手机 App 实现单身大龄青年之间的“速配”。然而随着用户数量的增长，JYY 发现现有速配的算法似乎很难满足大家的要求，因此 JYY 决定请你来调查一下其中的原因。

## 题目描述

应用的后台一共有 $N$ 个女性和 $N$ 个男性，他们每个人都希望能够找到自己的合适伴侣。为了方便，每个男性都被编上了 $1$ 到 $N$ 之间的一个号码，并且任意两个人的号码不一样。每个女性也被如此编号。

JYY 应用的最大特点是赋予女性较高的选择权，让每个女性指定自己的“如意郎君列表”。每个女性的如意郎君列表都是所有男性的一个子集，并且可能为空。如果列表非空，她们会在其中选择一个男性作为自己最终接受的对象。

JYY 用如下算法来为每个女性速配最终接受的男性：将“如意郎君列表”中的男性按照编号从小到大的顺序呈现给她。对于每次呈现，她将独立地以 $P$ 的概率接受这个男性（换言之，会以 $1-P$ 的概率拒绝这个男性）。如果她选择了拒绝，App 就会呈现列表中下一个男性，以此类推。如果列表中所有的男性都已经呈现，那么中介所会重新按照列表的顺序来呈现这些男性，直到她接受了某个男性为止。显然，在这种规则下，每个女性只能选择接受一个男性，而一个男性可能被多个女性所接受。当然，也可能有部分男性不被任何一个女性接受。

这样，每个女性就有了自己接受的男性（“如意郎君列表”为空的除外）。现在考虑任意两个不同的、如意郎君列表非空的女性 $a$ 和 $b$，如果 $a$ 的编号比 $b$ 的编号小，而 $a$ 选择的男性的编号比 $b$ 选择的编号大，那么女性 $a$ 和女性 $b$ 就叫做一对不稳定因素。

由于每个女性选择的男性是有一定的随机性的，所以不稳定因素的数目也是有一定随机性的。JYY 希望你能够求得不稳定因素的期望个数（即平均数目），从而进一步研究为什么速配算法不能满足大家的需求。

## 说明/提示

对于 $100\%$ 的数据，$1\leq N,M\leq 5\times 10^5$，$0.4\leq P<0.6$。

输入保证每个女性的“如意郎君列表”中的男性出现且仅出现一次。


## 样例 #1

### 输入

```
5 5
0.5
5 1
3 2
2 2
2 1
3 1```

### 输出

```
0.89```

# 题解

## 作者：万弘 (赞：17)

不至于没有题解吧。。。

首先假设一个女性中意 $k$ 个男性，总得先把概率算出来吧。

对于第一个男性，选中的概率 $g(1)=P+(1-P)^kP+(1-P)^{2k}P+...$  
等比数列求和得 $g(1)=P\frac{1-(1-P)^\infty}{1-(1-P)^k}=\frac{P}{1-(1-P)^k}$

且  $\forall i>1,g(i)=g(i-1)\times (1-P)$，故可以求出所有 $g(i)$.   
从小到大考虑每个女性 $i$，若选择第 $j$ 个中意的男性(记为 $a_{i,j}$ ),则贡献为 
$$
\sum_{a<i}\sum_{b>a_{i,j}}P(a\text{ 选 }b)\times g(j)
$$
这就是个单点加，询问后缀和。树状数组维护即可。

复杂度 $\mathcal O(m\log n)$

PS:有点卡精度，我用 `double` 90pts，`long double` 就过了
```cpp
#define MAXN 500011
int n;
struct BIT
{
    long double t[MAXN];
    #define lowb (i&-i)
    void modify(int i,long double k)
    {
        while(i<=n)t[i]+=k,i+=lowb;
    }
    long double Qsum(int i)
    {
        long double res=0;
        while(i)res+=t[i],i-=lowb;
        return res;
    }
}t;
std::vector<int>a[MAXN];
long double Qpow(long double x,int p)
{
    long double res=1;
    while(p)
    {
        if(p&1)res*=x;
        x*=x,p>>=1;
    }
    return res;
}
int main()
{
    n=read();
    int m=read();
    double tmp;
    scanf("%lf",&tmp);
    long double p=tmp,ans=0;
    for(int i=1;i<=m;++i)
    {
        int u=read(),v=read();
        a[u].push_back(v);
    }
    for(int u=1;u<=n;++u)
    {
        if(a[u].empty())continue;
        std::sort(a[u].begin(),a[u].end());
        long double now=p/(1-Qpow(1-p,a[u].size()));
        for(int v:a[u])
        {
            ans+=t.Qsum(n-v)*now;
            now*=(1-p);
        }
        now=p/(1-Qpow(1-p,a[u].size()));
        for(int v:a[u])
        {
            t.modify(n-v+1,now);
            now*=(1-p);
        }
    }
    printf("%.2lf",tmp=ans);
    return 0;
}
```

---

## 作者：Jayun (赞：8)

# 链接：

[题目](https://www.luogu.com.cn/problem/P6089)

[博客园](https://www.cnblogs.com/GJY-JURUO/p/14264117.html)

# 题目大意：

有 $n$ 个甲类点和 $n$ 个乙类点。每个甲点可以和若干个乙点连接，对于每一个乙点，它会以 $p$ 的概率选择此点，不选择就跳到下一个点，若最后一点不选择，则跳到第一点。求出期望逆序对个数。

# 正文：

假设一个甲点可以和 $k$ 个乙点连接。

因为像一个环一样，可以转几圈。第一个乙点在第一圈被选中的概率是 $p$，第二圈被选中的概率就是 $(1-p)^kp$（即不选它 $k$ 次也就转了一圈，转完后再选），第三圈被选中的概率是 $(1-p)^{2k}p$，以此类推第一个乙点被选中的概率是：

$$E_1=\sum_{i=0}^{\infty}(1-p)^{ik}p$$

通过等比数列求和公式得到：

$$E_1=\frac{1-(1-p)^{\infty}}{1-(1-p)^{k}p}p=\frac{p}{1-(1-p)^{k}p}$$

式子中 $(1-p)^{\infty}$ 无限大所以 $1-(1-p)^{\infty}$ 无限小，所以可以把它化掉。

---

那么 $E_1$ 求好了，剩下的呢？很容易得到 $E_i=E_{i-1}\cdot(1-p)$，因为 $i$ 相当于是先拒绝了 $i-1$ 后得来的。

剩下的就和题目大意的一样，求一个逆序对就搞定了。

# 代码：

```cpp
int n, m;
long double p, t[N], ans;

vector <int> v[N];

void add (int x, long double k) {for (; x < n; x += x & -x) t[x] += k; }
long double query (int x) {long double ans = 0;for (; x; x -= x & -x) ans += t[x]; return ans;}

long double qpow(long double a, int b)
{
	long double ans = 1;
	for (; b; b >>= 1) {if(b & 1)ans *= a; a *= a;} 
	return ans;
}

int main()
{
	scanf ("%d%d", &n, &m);
	scanf ("%Lf", &p);
	for (int i = 1; i <= m; i++)
	{
		int x, y;
		scanf ("%d%d", &x, &y);
		v[x].push_back(y);
	}
	for (int i = 1; i <= n; i++) sort (v[i].begin(), v[i].end());
	for (int i = 1; i <= n; i++)
	{
		if (v[i].empty()) continue;
		int k = v[i].size();
		long double P = p / (1 - qpow(1 - p, k));
		for (int j = 0; j < k; j++)
			ans += P * query(n - v[i][j]),
			P *= 1 - p;
		P = p / (1 - qpow(1 - p, k));
		for (int j = 0; j < k; j++)
			add(n + 1 - v[i][j], P),
			P *= 1 - p;
	}
	printf ("%.2Lf", ans);
	return 0;
}
```

---

## 作者：kuuuun (赞：4)

# [传送门](https://www.luogu.com.cn/problem/P6089)

## *P6809非诚勿扰* ##

## 题目大意 ##

*这题题目有点长，以下是题目大意，不想看的可以跳过*

> 现在有 $n$ 个男生，$n$ 个女生。
>
> 这 $n$ 个男生女生都被分别编上了 ${1,2,3\cdots n}$ 的编号。
>
> 每个女生有一个列表，表示自己对哪几个男生有好感。
>
> 在这个列表中，男生们被以编号排名依次被呈现给这个女生
>
> 这个列表会一直滚动循环,直到这个女生选中其中一个男生这个列表才会停止。
>
> 每个女生每次选中目前看到的男生的概率都是 $P$。
>
> 设女生 $a$ 选中了男生 $x$，女生 $b$ 选中了男生 $y$ 。
>
> 如果 $a<b$ 并且 $x>y$，那么我们称这对女生是一对不稳定因素
>
> 现在给出 $n$ 和 $m$。
>
> $n$ 表示有 $n$ 个男生 $n$ 个女生；
>
> $m$ 表示所有女生好感列表长度总和为 $m$。
>
> 接下来给出 $a,b$ ，表示男生 $b$ 在女生 $a$ 的好感列表里。
> 输出期望不稳定因素。

## 解题 ##

很显然，这一题是一道期望题。

我们需要先把某个男生被某个女生选中的概率算出来，这样才能让我们计算期望。

设

> 在一个女生好感列表中,我们设列表中的男生为集合 $x$，则其中第 $i$ 个男生可表示为 $x_i$。  
$x_i$ 被某个女生选中的概率为 $g_i$。  
再设该列表中有 $k$ 个男生。  
这个女生看了 $n$ 轮。

好了 所有必备条件都设完了，开始推论！

~~现在的我强的可怕~~

---

> 对于第 $1$ 轮 ，$x_1$ 被选中的概率为 $P$，  
> 而 $x_2$ 被选中的必要条件是 $x_1$ 没被选中,
> 所以 $x_2$ 被选中的概率为 $(1-p)p$。  
> 对于任意的 $x_i$ 被选中的必要条件显然是前面的 $i-1$ 个男生都没被选中。  
> 得出 $x_i$ 被选中的概率为 $(1-p)^{i-1}p$。  
> 对于第 $2$ 轮，在 $x_1$ 之前的就有 $k$ 个男生，分别是 $x_1,x_2,\cdots x_k$。
> 
> 所以在这一轮中 $x_1$ 被选中的概率为 $(1-p)^{k}p$。  
以此类推，对于第 $i$ 轮的 $x_1$ 被选中的概率为 $(1-p)^ip$
>  
> 至于第 $i$ 轮的 $x_j$ 就由这一轮的 $x_1$ 依次乘 $(1-p)$ 即可推出，可得出为 $(1-p)^{(i-1)k+j-1}p$。  
> 每一轮的 $x_i$ 被选中的概率都推出来了，那么 $x_i$ 被选中的概率即为每轮概率的总和。
>
> 故选中 $x_j$ 的概率为 **$\sum_{i=1}^{\infty}{(1-p)^{(i-1)k+j-1}p}$。**

由于 $x_j$ 都能由 $x_1$ 推出，所以我们单看 $x_1$ 的公式即可。  
选中 $x_1$ 的概率为 $g_1=\sum_{i=1}^{\infty}(1-p)^{(i-1)k}p$。  

**很显然，这是一个等比数列求和**  
>代入公式得 $g_1=\frac{(1-p)^{\infty}-1}{(1-p)^k-1}p$。  
显然 $(1-p)^{\infty}$ 是收敛于 $0$ 的。  
故可得出 $g_1=\frac{-1}{(1-p)^k-1}p$，  
化简得出 $g_1=\frac{p}{1-(1-p)^k}$，  
由此可得 $g_j=\frac{(1-p)^{j-1}p}{1-(1-p)^k}$。  

使用快速幂可以快速求出。

---

概率求完了，我们需要求不稳定因素了。  
通过描述，很明显可以知道这是逆序对。

那么期望逆序对个数就很简单了。

普通的逆序对每点对计算贡献是 1，  
但在这题中，每点的贡献是则是自己的期望选中女生们选中的逆序对，

我们可以转换为男生按编号以自己被选中的概率为贡献做逆序对。  
由于一个男生可被选中多次，所以做完一个列表不能清空。

逆序对用树状数组计算即可  
(不会树状数组求逆序对的看下文)。

**自此 这题思路就打开了**

贴上代码（有点丑，看看就行）  
注意 `double` 有精度问题 要开 `long double`。

~~~c++
#include<bits/stdc++.h>
#define double long double
#define lowbit(x) (x&(-x))
using namespace std;
double p,tr[500001],s;
vector<int>g[500001];//概率数组，最好用vector存，不然有可能会爆空间(vector也有可能，但动态存储会好一点)
int n,m,x,y;
double qpow(double a,int b)//快速幂
{
	double s=1;
	while(b)
	{
		if(b&1)s*=a;
		a*=a;
		b>>=1;
	}
	return s;
}
void add(int x,double y)//单点修改
{
	for(int i=x;i<=n;i+=lowbit(i))tr[i]+=y;
}
double sum(int x)//单点前缀和
{
	double s=0;
	for(int i=x;i;i-=lowbit(i))s+=tr[i];
	return s;
}
double ask(int l,int r)//区间查询
{
	return sum(r)-sum(l-1);
}
int main()
{
	scanf("%d%d%llf",&n,&m,&p);//注意long double 是llf
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d",&x,&y);
		g[x].push_back(y);
	}
	for(int i=1;i<=n;i++)
	{
		if(g[i].empty())continue;//列表没有人，跳过
		sort(g[i].begin(),g[i].end());//按编号排序
		double e=p/(1.0-qpow(1.0-p,g[i].size()));//计算 x[1] 概率
		for(int j=0;j<g[i].size();j++)
		{
			s+=ask(g[i][j]+1,n)*e;//计算逆序对期望
			add(g[i][j],e);//更新
			e*=1.0-p;//更新概率
		}
	}
	printf("%.2llf\n",s);//注意保留两位小数
	return 0;
}
~~~

## PS:

[P1908模板](https://www.luogu.com.cn/problem/P1908)

树状数组求逆序对：

逆序对可转化为 $\sum_{i=2}^n\sum_{j=1}^i(a_i>a_j)$。

所以，我们可以遍历 $1$ 到 $n$。

以 $a$ 的值为下标建立树状数组(常搭配离散化)，

每个 $a_i$ 的贡献都是前面比它大的数的个数，

所以每个 $a_i$ 的贡献可以用 $a_i+1$ 到 $\max(a)$ 中之前出现过的数的个数之和。

既然是区间和，那么可以利用树状数组维护。

每到一个数 $a_i$ 就让 $s$ 加上 $\sum_{j=a_i+1}^{\max(a)}$。

再让 $a_i$ 节点加上权值 $1$。

贴上个模板代码

~~~c++
#include<bits/stdc++.h>
#define ll long long
#define lowbit(x) (x&(-x))
using namespace std;
ll a[1000001],b[1000001],tr[1000001],s,maxl,t;
int n;
map<ll,ll>mp;//离散化映射数组
void add(ll x,ll k)
{
	for(int i=x;i<=n;i+=lowbit(i))tr[i]+=k;
	return;
}
ll sum(ll x)
{
	ll s=0;
	for(int i=x;i;i-=lowbit(i))s+=tr[i];
	return s;
}
ll ask(ll l,ll r)
{
	return sum(r)-sum(l-1);
}
int main()
{
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%lld",&a[i]);
		b[i]=a[i];
	}
	sort(b+1,b+n+1);//确保大小关系不变
	for(int i=1;i<=n;i++)//映射
	{
		if(!mp[b[i]])mp[b[i]]=++t;
		maxl=max(maxl,mp[b[i]]);	
	}
	for(int i=1;i<=n;i++)//离散化
	{
		s+=ask(mp[a[i]]+1,maxl);
		add(mp[a[i]],1);
	}
	printf("%lld",s);
	return 0;
}
~~~

完结撒花！！！

---

## 作者：_anll_ (赞：3)

## 思路
我们定义多元组 $(x,y,a,b)$ 为 $x$ 女选了 $a$ 男且 $y$ 女选了 $b$ 男。当 $x<y$ 且 $a>b$ 时，该多元组存在贡献，为 $x$ 女选 $a$ 男的概率与 $y$ 女选 $b$ 男的概率相乘结果。

我们先假定已经处理完了概率那一步，只考虑最后如何处理结果。显然该多元组有贡献的条件为逆序对，所以直接用树状数组维护即可。

再来考虑如何处理概率。对于女选男的概率，应该是 $\displaystyle\sum^{siz}_{j=1}\sum^\infty_{i=0}(1-p)^{siz\times i}\times(1-p)^{j-1}\times p$，其中 $i$ 表示前面已经选了 $i$ 轮，$siz$ 表示当前女生选择列表的大小，$j$ 则表示当前选到选择列表内的第 $j$ 个男生。因为 $i$ 是无限大的，我们考虑怎么将其消掉。令 $X=(1-p)^{siz}$，$\displaystyle S=\sum^\infty_{i=0}(1-p)^{siz\times i}=X^0+X^1+X^2+\dots +X^\infty$。将 $S$ 扩大 $X$ 倍，即 $X\times S=X^1+X^2+\dots X^\infty$。两式相减，得到 $(1-X)\times S=X^0=1$。因此 $\displaystyle S=\dfrac{1}{1-(1-p)^{siz}}$，代回原式，最终变为 $\displaystyle \sum^{siz}_{j=1}\dfrac{(1-p)^{j-1}\times p}{1-(1-p)^{siz}}$。直接使用这个式子就好。

完结撒花。

## 代码
```cpp
#include<set>
#include<iomanip>
#include<iostream>
#define int long long
#define double long double
#define lowbit(x) (x&-x)
using namespace std;
const int N=5e5+5;
int n,m;
double p,ans,tr[N],pow[N];
set<int> num[N];
void add(int x,double k){
	for(int i=x;i<=n;i+=lowbit(i)) tr[i]+=k;
}
double Find(int x,double k=0){
	for(int i=x;i;i-=lowbit(i)) k+=tr[i];
	return k;
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n>>m>>p;int a,b;pow[0]=1;
	for(int i=1;i<=n;i++) pow[i]=pow[i-1]*(1-p);
	for(int i=1;i<=m;i++){
		cin>>a>>b;
		num[a].insert(-b);
	}
	for(int i=n;i;i--){
		int tot,siz=num[i].size();tot=siz;
		for(auto a:num[i]){
			int x=-a;tot--;
			double an=pow[tot]*p/(1-pow[siz]);
			add(x,an);
			ans+=an*Find(x-1);
		}
	}
	cout<<fixed<<setprecision(2)<<ans;
	return 0;
}
```

---

## 作者：AC_love (赞：3)

假如对于某个人，有 $k$ 个人可供她选择，我们可以来求一下每个人被选择的概率。

首先考虑第一个人，他在第一轮被选择的概率是 $p$。

第二轮时，由于前面 $k$ 个人都没有被选择，因此他在第二轮被选择的概率是 $(1 - p)^kp$。

同理，第三轮时，他被选择的概率是 $(1 - p)^{2k}p$。

以此类推，我们把这些都加起来，就是第一个人被选中的概率：$p + (1 - p)^kp + (1 - p)^{2k}p + (1 - p)^{3k}p + \cdots$。

不难发现这玩意是个等比数列，公比为 $(1 - p)^{k}$，不难发现这个公比小于 $1$，因此根据公式有 $S_1 = \dfrac{p}{1 - (1 - p)^k}$

注：等比数列求和公式：$S_{\infty} = \dfrac{a_1}{1 - q}$，其中 $q$ 是公比，且 $|q| < 1$。

那么第一个人的概率求出来了，不难发现第二个人被选择的概率就是在第一个人的基础上乘上 $(1 - p)$，第三个人就是在第二个人的基础上乘上 $(1 - p)$……以此类推。

我们用树状数组来维护逆序对数即可。

---

## 作者：LSG_waterlyf (赞：3)

设女生集合为$A$。首先先对$A$集合中的每个$Ai$的男生集合按编号排序，设$A$集合中的$Ai$有$m$位男生，对于第$i$位男生：

 - 第一轮即被选中：$P1=(1-p)^{(i-1)} *p$.

 - 第二轮：$P2:(1-p)^{(i-1+m)}*p$, 

 - 第$n$轮：$Pn=(1-p)^{(i-1+m*(n-1) )}*p$.

观察发现是等比数列，套公式得

$P=(1-p)^{(i-1)}*(1-(1-p)^{(m*n)})/(1-(1-p)^m)$ 

因为$n$无限大，所以$(1-p)^{(m*n)}$无限小。

所以选中$i$的概率为$P=(1-p)^{(i-1)}/(1-(1-p)^m)$. 

接下来只要用权值树状数组维护逆序対即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 500100
#define ll long double
int n,m;
ll p,c[N],ans;
int lowbit(int x) {return x&-x;}
void change(int x,ll w)
{
	while(x<N) c[x]+=w,x+=lowbit(x);
}
ll ask(int x)
{
	ll val=0;
	while(x) val+=c[x],x-=lowbit(x);
	return val;
}
vector<int>g[N];
int main()
{
	cin>>n>>m>>p;
	for(int i=1,a,b;i<=m;i++)
	  scanf("%d%d",&a,&b),g[a].push_back(b);
	for(int i=1;i<=n;++i) sort(g[i].begin(),g[i].end());
	for(int i=1;i<=n;i++)
	{
		if(!g[i].size()) continue;
		int k=g[i].size(),x;
		for(int j=0;j<k;j++)
		{
			x=g[i][j];
			ll pos=pow(1-p,j)*p/(1-pow(1-p,k));
		//	printf("girl==%d boy==%d p==%Lf\n",i,x,pos);
			ans+=pos*(ask(n)-ask(x));
		}
		for(int j=0;j<k;j++)
		{
			x=g[i][j];
			ll pos=pow(1-p,j)*p/(1-pow(1-p,k));
			change(x,pos);
		}
	}
	printf("%.2Lf",ans);
	return 0;
}
```


---

## 作者：raozf (赞：3)

### 概率：

设女生的列表里有 $k$ 人。

第一轮被选中: 概率为 $
p$。

第二轮被选中，也就是第一轮中 $k$ 个人都没被选中:  
概率为 $$ p  \cdot (1 - p) ^ k $$。

第三轮被选中，也就是第一、二轮中的 $2k$ 个人都没被选中:  
概率为 $$ \begin{aligned}  p  \cdot (1 - p) ^ {2k} \end{aligned} $$。

$\dots$


所以，男生最终被选中的概率为前面的概率累加，提出 $p$，得 $$ \begin{aligned} p \cdot \sum_{i=0}^{\infty} (1 - p) ^ {ik} \end{aligned}$$。

可以发现，这个数列是等比数列。

根据等比数列求和公式，$$ \begin{aligned} S = \frac{a(1 - r^n)}{(1 - r)} \end{aligned} $$，其中 $a$ 为首项，$r$ 为公比，$n$ 为项数。

代入得: $$ \begin{aligned} p \cdot \frac{1 \cdot[1 - (1 - p) ^ { k  \cdot \infty}]}{1 - (1 - p) ^ k}  &= p \cdot \frac{1 - (1 - p) ^ { \infty}}{1 - (1 - p) ^ k} \end{aligned}$$。

看数据范围，$$ \begin{aligned} 0.4 \leq p \lt  0.6，0.4 \lt (1 - p) \leq 0.6 \end{aligned} $$。

由于$(1 - p)$ 是小于 $1$ 的正数，所以它的无穷次方趋近于 $0$，可以当成 $0$ 来看，即 $$ \begin{aligned} p \cdot \frac{1 - (1 - p) ^ { \infty}}{1 - (1 - p) ^ k} &= p \cdot \frac{1}{1 - (1 - p) ^ k} \end{aligned} $$。

将 $p$ 乘上去，得$$ \begin{aligned} \frac{p}{1 - (1 - p) ^ k} \end{aligned} $$。

对于每一个男生,他都是上一个人被选后，即他落选后选到的，要乘上 $(1 - p)$。

对与男生 $i$，他落选了 $i - 1$ 次后被选上了，要乘上 $$ \begin{aligned} (1 - p) ^ {i -  1} \end{aligned} $$。

即女生 $k$ 选男生 $i$ 概率为：$$ \begin{aligned}  \frac{(1 - p) ^ {i - 1} \cdot p}{1 - (1 - p) ^ k} \end{aligned} $$。

最终先枚举女生，再在女生的列表里枚举男生，最后枚举符合条件的另一组男女，计算贡献。

###  优化:
单点加减，使用树状数组优化。

复杂度：$O(m \log n)$。

---

## 作者：xiezheyuan (赞：1)

## 简要题意

有 $n$ 个红色点，$n$ 个蓝色点，有 $m$ 条关系，每条关系 $(x,y)$ 形如第 $x$ 个红色点可以和第 $y$ 个蓝色点连一条边。初始时红色点和蓝色点各自按照编号排序并形成两排，红色点和蓝色点之间没有连边。

然后对于每一个红色点，我们将可以与之连边的蓝色点按照编号排序并将首尾相接（不是连边）形成一个环，红色点从编号最小的蓝色点开始判断，有 $P$ 的概率接受这个点，与这个蓝色点连一条边并结束本轮判断，有 $1-P$ 的概率移动到下一个点。

你需要求出最后连出的边中，期望有多少对边是交叉的（不包括在顶点处重合）。

$1\leq n,m\leq 5\times 10^5,0.4\leq P\lt 0.6$

## 思路

首先，不妨考虑枚举编号较大的红点 $p$，记 $A_i$ 表示点 $i$ 可以选择的蓝点集合，$P(i,j)$ 表示点 $i$ 选择 $j$ 的概率，则有红点构成的边对期望为：

$$
\sum_{k\in A_p}\sum_{i=1}^{p-1}\sum_{j\in A_i} [k<j]P(p,k)P(i,j)
$$

注意到后面的形式就是二维偏序，可以考虑用树状数组维护。所以现在的问题是如何求 $P$。

考虑 $A_i$ 中从小到大第 $k$ 个点的概率是多少，不难发现是这玩意：

$$
\sum_{t=0}^{+\infty} P(1-P)^{k-1+t|A_i|}
$$

等比数列求和：

$$
\frac{P(1-P)^{k-1}}{(1-P)^{|A_i|}}
$$

直接计算即可。时间复杂度 $O(m\log n)$。

## 代码

```cpp
#include <bits/stdc++.h>
//#define int long long
#define lowbit(x) ((x) & (-(x)))
using namespace std;

using real_f = long double;
const int N = 5e5 + 5;

int n, m;
vector<int> g[N];
real_f P, t[N];

void update(int p, real_f v){
    while(p <= n){ t[p] += v; p += lowbit(p); }
}

real_f query(int p){
    real_f res = 0;
    while(p){ res += t[p]; p -= lowbit(p); }
    return res;
}

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    cin >> n >> m >> P;
    for(int i=1;i<=m;i++){
        int u, v; cin >> u >> v;
        g[u].push_back(v);
    }
    real_f ans = 0;
    for(int i=1;i<=n;i++){
        if(g[i].empty()) continue;
        sort(g[i].begin(), g[i].end());
        real_f e = P / (1 - pow(1 - P, (real_f)g[i].size()));
        for(int j : g[i]) ans += (query(n) - query(j)) * e, e *= (1 - P);
        e = P / (1 - pow(1 - P, g[i].size()));
        for(int j : g[i]) update(j, e), e *= (1 - P);
    }
    cout << fixed << setprecision(2) << ans << '\n';
    return 0;
}

// Written by xiezheyuan
```

---

## 作者：OldDriverTree (赞：1)

水题，不到十分钟就切出来了。

# Solution

不难发现，题目就是让你求这个随机序列的逆序对期望个数。

令随机变量 $A_i$ 为序列第 $i$ 个位置的数，$S_i$ 为女性 $i$ 的如意郎君列表。

根据期望线性性，答案就为 $\sum_{i<j}(A_i>A_j\text{ 的概率 })$。

$A_i>A_j$ 的概率就等于 $\sum_{x\in S_i}\sum_{y\in S_i}[x>y]\times(i\text{ 选择 }x\text{ 的概率 })\times(j\text{ 选择 }y\text{ 的概率 })$。

考虑如何计算 $i$ 选 **$S_i$ 中第 $j$ 个** 的概率，枚举在第几轮选，概率就为 $\sum\limits_{k=0}^{+\infty}(1-p)^{\vert S_i\vert k+j-1}\times p$，等比数列求和搞一下就行了。

剩下的就是个二维偏序，树状数组维护一下概率之和就行了。

时间复杂度就为 $O(m\log n+\sum\vert S_i\vert\log \vert S_i\vert)$。
# Code
```c++
//when you use vector or deque,pay attention to the size of it.
//by OldDirverTree
#include<bits/stdc++.h>
#define P pair<int,int>
#define int long long
#define mid (l+r>>1)
using namespace std;
const int N=5e5+1;
long double p,ans,T[N];
vector<int> pos[N];
int n,m;

int read() {
	int x=0; bool f=true; char c=0;
	while (!isdigit(c) ) f&=(c!='-'),c=getchar();
	while (isdigit(c) ) x=(x<<3)+(x<<1)+(c&15),c=getchar();
	return f?x:-x;
}
long double query(int x,long double res=0) {
	while (x) res+=T[x],x&=x-1; return res;
}
void add(int x,long double y) {
	while (x<=n) T[x]+=y,x+=x&-x;
}
main()
{
	n=read(),m=read(),scanf("%Lf",&p);
	while (m--) { int x=read(); pos[x].push_back(read() ); }
	for (int i=1;i<=n;i++) {
		if (pos[i].empty() ) continue;
		sort(pos[i].begin(),pos[i].end() );
		double mul=1/(1-pow(1-p,pos[i].size() ) );
		for (int x:pos[i]) {
			ans+=(query(n)-query(x) )*mul*p;
			add(x,mul*p),mul*=1-p;
		}
	}
	printf("%.2Lf",ans);
	return 0;
}
```

---

## 作者：JimmyLee (赞：0)

# 分析

首先我们要求出对于第 $i$ 位女性，她选择每个列表中的男性的概率是多少。

第一轮选择第一位的概率为 $p$，选择第二位的概率为 $p(1-p)$，以此类推。

显然第一轮选择第 $k$ 位的概率为 $p(1-p)^{k-1}$。

假设列表中有 $n$ 名男性，那么第二轮选择第一位的概率为 $p(1-p)^n$。

所以选择第一位的概率 $P_1$ 为：

$$
\begin{aligned}
P_1&=\sum^{\infty}_{i=0}p(1-p)^{n\cdot i}\\
(1-p)P_1&=\sum^{\infty}_{i=1}p(1-p)^{n\cdot i}\\
\end{aligned}
$$

上下两式相减，得到：

$$
\begin{aligned}
(1-(1-p)^n)P_1&=\sum^{\infty}_{i=0}p(1-p)^{n\cdot i}-\sum^{\infty}_{i=1}p(1-p)^{n\cdot i}\\
(1-(1-p)^n)P_1&=p\\
P_1&=\frac{p}{1-(1-p)^n}\\
\end{aligned}
$$

这样我们就搞定了 $P_1$。

显然有：$P_i=(1-p)P_{i-1}$。

我们已经对于每个女性求出选择每个男性的概率，现在要考虑如何求得答案。

令 $S_i$ 为第 $i$ 个女性可选择的男性的集合。

答案就是下式：

$$
\sum_{i=1}^n\sum_{b\in S_i}\sum_{j=1}^{i-1}\sum_{k=b+1}^n P(j\ 选\ k)\cdot P(i\ 选\ b)
$$

考虑从小到大枚举女性，这样就保证了后枚举的女性编号一定大于枚举过的。

我们可以维护一个序列，存储选择第 $b$ 个男性的期望人数。

每次枚举 $i$ 和 $b$，对答案的贡献就是 $[b+1, n]$ 这个区间内的期望人数。

在枚举完一个 $i$ 后，将自己选择每个男性的概率累加到序列上。

单点修改，区间查询，用树状数组维护。

时间复杂度 $O(m\log m)$。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxn 500005
typedef long double f64_t;

struct BIT:vector<f64_t>
{
    using vector::vector;
    void modify(int p, f64_t x)    {for(;p<size();p+=p&-p) at(p)+=x;}
    f64_t query(int p) {f64_t r=0;for(;p;p-=p&-p) r+=at(p);return r;}
};

BIT ta(maxn);
vector<int> al[maxn];

int main()
{
    int n, m;
    f64_t p, ans=0;
    cin>>n>>m>>p;
    for(int a, b;m--;)
        cin>>a>>b, al[a].emplace_back(b);
    for(int i=1;i<=n;i++)
    {
        if(al[i].empty()) continue;
        sort(al[i].begin(), al[i].end());
        for(f64_t px=p/(1-pow(1-p, al[i].size()));auto b:al[i])
            ans+=(ta.query(n)-ta.query(b))*px, 
            ta.modify(b, px), px*=1-p;
    }
    cout<<format("{:.2f}", ans);
}
```

---

## 作者：Laoshan_PLUS (赞：0)

题意：**求一个随机序列的逆序对期望个数**。

前置知识：[树状数组求逆序对](https://oi-wiki.org/ds/fenwick/#%E5%85%A8%E5%B1%80%E9%80%86%E5%BA%8F%E5%AF%B9%E5%85%A8%E5%B1%80%E4%BA%8C%E7%BB%B4%E5%81%8F%E5%BA%8F)，等比数列求和公式。

设一个人的 “如意郎君列表” 大小为 $k$，则选中第 $i$ 个人的概率为：
$$
(1-p)^{i-1}p+(1-p)^{i-1+k}p+(1-p)^{i-1+2k}p+\cdots
$$

简写为：
$$
\sum_{j=0}^\infty(1-p)^{i-1+jk}p
$$

这是一个等比数列求和，公比为 $(1-p)^k$。由等比数列求和公式得，原式记为 $f(k,i)$ 等于：
$$
f(k,i)=\frac{(1-p)^{i-1}p}{1-(1-p)^k}
$$

若女性 $a$ 选择了男性 $x~(x\in L_a)$，女性 $b$ 选择了男性 $y~(y\in L_b)$，且满足 $a<b\land x>y$，那么对答案的贡献为 $f(k_a,x)\times f(k_b,y)$，其余情况贡献为 $0$。这就是一个逆序对，树状数组求解即可。

*另：此题需要开 `long double`。*

```cpp
#include <bits/stdc++.h>
#define lowbit(x) (x & -x)
using namespace std;

constexpr int MAXN = 5e5 + 5;
int n, m;
long double p, ans, c[MAXN];
vector<int> lj[MAXN];

void add(int x, long double k) {
	while (x <= n) {
		c[x] += k;
		x += lowbit(x);
	}
}

long double sum(int x) {
	long double res = 0;
	while (x) {
		res += c[x];
		x -= lowbit(x);
	}
	return res;
}

long double power(long double a, int b) {
	long double res = 1;
	while (b) {
		if (b & 1) res *= a;
		a *= a;
		b >>= 1;
	}
	return res;
}

int main() {
	scanf("%d%d%Lf", &n, &m, &p);
	for (int i = 1, x, y; i <= m; i++) {
		scanf("%d%d", &x, &y);
		lj[x].push_back(y);
	}
	for (int i = 1; i <= n; i++) sort(lj[i].begin(), lj[i].end());
	for (int i = 1; i <= n; i++) {
		if (lj[i].empty()) continue;
		long double P = p / (1 - power(1 - p, lj[i].size()));
		for (auto x : lj[i]) {
			ans += P * sum(n - x);
			P *= 1 - p;
		}
		P = p / (1 - power(1 - p, lj[i].size()));
		for (auto x : lj[i]) {
			add(n + 1 - x, P);
			P *= 1 - p;
		}
	}
	cout << fixed << setprecision(2) << ans << '\n';
	
	return 0;
}
```

---

## 作者：liugh_ (赞：0)

[P6089 [JSOI2015] 非诚勿扰](https://www.luogu.com.cn/problem/P6089)

每个女性有一个匹配列表，其中的男性按编号从小到大的顺序呈现给她。对于每次呈现，她将独立地以 $p$ 的概率接受这个男性；若她拒绝，就会呈现列表中下一个男性（**若列表中所有的男性均已呈现，则呈现列表中第一个男性**），以此类推，直到她接受了某个男性为止。求 $\sum_{1\le a<b\le n}\sum_{x\in l_a,y\in l_b, x>y} f(a,x)\cdot f(b,y)$，其中 $a,b$ 为任意女性，其匹配列表分别为 $l_a,l_b$，$f(u,v)$ 为女性 $u$ 和男性 $v$ 匹配的概率。

---

首先，对于每个女性，注意到实际的匹配列表是**无限长**的（即无限个原列表拼接在一起），如何求原列表中每个男性与她匹配的概率？记原列表长度为 $k$，以第一个男性为例：

$$
\begin{aligned}
&\underbrace{\red{0}0\cdots 0}_{k个}\underbrace{00\cdots 0}_{k个}\underbrace{00\cdots 0}_{k个}\cdots \qquad p\\
&\underbrace{00\cdots 0}_{k个}\underbrace{\red{0}0\cdots 0}_{k个}\underbrace{00\cdots 0}_{k个}\cdots \qquad p\cdot(1-p)^k \\
&\underbrace{00\cdots 0}_{k个}\underbrace{00\cdots 0}_{k个}\underbrace{\red{0}0\cdots 0}_{k个}\cdots \qquad p\cdot(1-p)^{2k} \\
&\cdots \\
\end{aligned}
$$

易得 

$$
f=p\cdot\sum_{i=0}^{\infty} (1-p)^{ik} \tag{1}
$$

观察发现 $(1)$ 式是一个等比数列求和的形式，其中首项为 $(1-p)^0=1$，公比为 $(1-p)^k$。

记 $S_n$ 为等比数列前 $n$ 项之和，$a$ 为首项，$r$ 为公比，我们有

$$
S_n=a+ar+ar^2+\cdots+ar^{n-1} \tag{2}
$$

又

$$
rS_n=ar+ar^2+ar^3+\cdots+ar^n \tag{3}
$$

式 $(2)$ 减式 $(3)$ 得

$$
(1-r)S_n=a-ar^n
$$
$$
S_n=a\cdot \frac{1-r^n}{1-r} \tag{4}
$$

注意到对于 $0\le|r|<1$，有

$$
\lim_{n\rightarrow \infty} r^n=0 \quad\Rightarrow \quad \lim_{n\rightarrow \infty} (1-r^n)=1 \tag{5}
$$

将式 $(5)$ 代入式 $(4)$ 中，得

$$
S_{\infty}=\frac{a}{1-r} \tag{6}
$$

将式 $(6)$ 代入式 $(1)$ 中，得

$$
f=\frac{p}{1-(1-p)^k}
$$

推广到第 $i$ 个男性，其被匹配当且仅当第 $i-1$ 个男性未被匹配，故有

$$
f(i)=f(i-1)\cdot (1-p)
$$

---

题目要求的是一个逆序对的形式，故对于每个女性，我们将所有 $f(i)$ 作为权值，用 BIT 维护即可。

```cpp
void main() {
	scanf(" %d %d %Lf", &N, &M, &P);
	for (int i = 1; i <= M; ++i) {
		int u, v; scanf(" %d %d", &u, &v);
		list[u].push_back(v);
	}
	for (int i = 1; i <= N; ++i) { // 枚举每个女性
		int k = list[i].size();
		if (k == 0) continue;
		sort(begin(list[i]), end(list[i]));
		// 为方便，此处采用0-index
		f[0] = P / (1 - fpow(1 - P, k));
		for (int j = 1; j < k; ++j) 
			f[j] = f[j - 1] * (1 - P);
		for (int j = 0; j < k; ++j) 
			ans += bit.query(list[i][j] + 1) * f[j]; // 题目要求严格大于，故取list[i][j]+1
		for (int j = 0; j < k; ++j)
			bit.modify(list[i][j], f[j]);
	}
	printf("%.02Lf", ans);
}
```

---

## 作者：Fzrcy (赞：0)

若一女性的如意郎君列表的大小为 $k$，则选择第 $i$ 个如意郎君（排序后）的概率 $P(k,i)$ 为：

$$P(k,i)=(1-P)^{i-1}P+(1-P)^{k+i-1}P+\dots$$

有：

$$P(k,i)=(1-P)^{i-1}P+(1-P)^{k}P(k,i)$$

即：

$$P(k,i)=\frac{(1-P)^{i-1}P}{1-(1-P)^k}$$

设第 $i$ 个女性的如意郎君列表的大小为 $k_i$。则第 $i$ 个女性选择她的如意郎君列表中的第 $a$ 个如意郎君 $x$，第 $j$（$j>i$）个女性选择她的如意郎君列表中的第 $b$（$a>b$）个如意郎君 $y$ 对答案的贡献为 $P(k_i,a)P(k_j,b)$，其他情况的贡献为 $0$。

这是个点带权的二维偏序问题，树状数组即可解决。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e6+1;
using db=long double;
db c[N],P;
int n,m;
vector<int>e[N];
void add(int x,db v){
    assert(x);
    for(;x<=n;x+=(x&-x))
        c[x]+=v;
}
db ask(int x){
    db r=0.;
    for(;x;x-=(x&-x))
        r+=c[x];
    return r;
}
db ksm(db x,int y){
    db r=1.;
    for(;y;y>>=1,x=x*x)
        if(y&1)r=r*x;
    return r;
}
int main(){
    cin>>n>>m>>P;
    for(int i=1,a,b;i<=m;i++)
        cin>>a>>b,e[a].push_back(b);
    db ans=0.;
    for(int i=1;i<=n;i++){
        sort(e[i].begin(),e[i].end());
        int tot=e[i].size();
        db p=P/(1.-ksm(1.-P,tot)),tmp=p;
        for(int j=0;j<tot;j++)
            ans+=ask(n-e[i][j])*p,p*=(1-P);
        p=tmp;
        for(int j=0;j<tot;j++)
            add(n-e[i][j]+1,p),p*=(1-P);
    }
    double res=ans;
    printf("%.2lf\n",res);
    return 0;
}
```

---

## 作者：封禁用户 (赞：0)

首先，我们可以利用等比数列求和公式，因为 $0.4 \le p < 0.6$，删去分子上的 $A(q+1)$ 算出每对男女 $(i,j)$ 在一起的概率。询问时倒序插入并用树状数组维护。

比如对一个女生 $a$，有 $k$ 个候选男生编号为 $1$ 至 $k$。那么对于第 $m$ 个男生， $(a,m)$ 在一起的概率就是 $(1-p) ^ {m-1} \times p + (1-p)^k \times (1-p) ^ {m-1} \times p + (1-p)^{2k} \times (1-p) ^ {m-1} \times p + ...+(1-p)^{x-1}\times (1-p) ^ {m-1} \times p$

我们不妨先利用等比数列求和公式：

$$S_n=a1\times \dfrac{1-q^n}{1-q}$$

其中， $a_1 = (1-p)^{m-1} \times p,q = (1 - p)^k$。那么在 $n$ 很大时， $q^n$ 就非常接近 $0$。所以我们不妨将 $q^n$ 当作 $0$，呢么答案就是 $a_1 \div (1-q)$。

我们发现，这个思路只能拿到 60 分。我们可以倒叙枚举女生，使用树状数组维护后 $i$ 个女生和前 $j$ 个男生配对的概率和，这一题就做完了。

## AC 代码
```cpp
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstring> 
#include<cstdio>
using namespace std;
typedef long long LL;
const int MAXN = 1e6 + 10;
const int INF = 0x3f;
int n, m;
struct TA{
	double a[MAXN];
	double sum(int p){
		double res = 0;
		for(;p;p-=(p&-p)){
			res += a[p];
		}
		return res;
	}
	void modify(int p,double val){
		p++;
		for(;p<=n;p+=(p&-p)){
			a[p] += val;
		}
	}
}ta;
struct Edge{
	int u, v;
	double p;
	Edge(){}
	Edge(int u,int v,double p):u(u),v(v),p(p){}
}e[MAXN];
bool cmp(Edge a,Edge b){
	if(a.u != b.u)return a.u < b.u;
	return a.v < b.v;
} 
double p;
double powp[MAXN];
int deg[MAXN], cnt[MAXN];
int main()
{
	cin >> n >> m >> p;
	for(int i = 0;i < m; i++){
		int u, v;
		cin >> u >> v;
		u--;
		v--;
		deg[u]+=1;
		e[i] = Edge(u, v, 0);
	}
	sort(e,e + m, cmp);
	powp[0] = 1.0;
	for(int i = 0;i < n; i++){
		powp[i + 1] = powp[i] * (1 - p);
	}
	memset(cnt, 0, sizeof(cnt));
	for(int i = 0;i < m; i++){
		int u = e[i].u;
		e[i].p = p * (powp[cnt[u]]) / (1 - powp[deg[u]]);
		cnt[u] += 1;
	}
	reverse(e, e + m);
	int pointer = 0;
	double res = 0.0;
	for(int i = n-1;i >= 0; i--){
		for(int j = pointer;j < m && e[j].u == i; j++){
			res += ta.sum(e[j].v) * e[j].p;
		}
		for(int j = pointer;j < m && e[j].u == i; j++){
			ta.modify(e[j].v, e[j].p);
			pointer = j + 1;
		}
	}
	printf("%.2lf", res);
    return 0;
}
```

---


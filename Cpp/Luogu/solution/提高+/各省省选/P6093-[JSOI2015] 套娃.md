# [JSOI2015] 套娃

## 题目背景

刚从俄罗斯旅游回来的 JYY 买了很多很多好看的套娃作为纪念品！JYY 由于太过激动，把所有的套娃全部都打开了。而由于很多套娃长得过于相像，JYY 现在不知道该如何把它们装回去了（他实在搞不清，应该把哪个套娃装到哪个里面去了）。

## 题目描述

JYY 一共有 $N$ 个拆开的套娃，每个套娃从 $1$ 到 $N$ 编号。编号为 $i$ 的套娃有一个外径 $Out_i$ 和一个内径 $In_i$（$In_i<Out_i$）。

对于套娃 $i$ 和套娃 $j$，如果满足 $Out_i<In_j$，那么套娃 $i$ 就可以装到套娃 $j$ 里面去。

注意，一个套娃内部，不允许并排的放入多个套娃。

也就是说，如果我们将 $i$ 装到 $j$ 的内部之后，还存在另一个套娃 $k$，也满足 $Out_k<In_j$，我们此时是不允许再将 $k$ 放到 $j$ 内部的（因为 $j$ 的内部已经放入了 $i$）。但是，如果 $k$ 还满足 $Out_k<In_i$，那么我们允许先将 $k$ 放到 $i$ 的内部，然后再把 $k$ 和 $i$ 作为一个整体放入 $j$ 的内部。

JYY 认为一套好的套娃，内部的空隙一定是尽量少的。如果套娃 $j$ 内部装入了套娃 $i$，那么我们认为，套娃 $j$ 内部产生的空隙为 $In_j-Out_i$；如果套娃 $j$ 的内部什么也没有装，那么套娃 $j$ 的空隙则就是 $In_j$。

JYY 也希望，那些长得更加好看的套娃，里面可以填的尽量满一些；而相对
那些不那么好看的套娃，JYY 也就相对不那么介意一些。为此 JYY 对于编号为 $i$ 的套娃设置了一个好看度 $B_i$，如果这个套娃内部还存在 $K$ 的空隙，那么 JYY 对于这个套娃就会产生 $K\times Bi$ 的不满意度。

JYY 对于一个套娃安装方案的不满意度，就是每个套娃产生的不满意度的总
和。JYY 希望找出一个，不满意度最小的套娃安装方案。

## 说明/提示

对于 $100\%$ 的数据，$N\leq 2\times 10^5$，$1\leq In_i<Out_i\leq 10^4$，$1\leq B_i\leq 10^9$。

## 样例 #1

### 输入

```
3
5 4 1
4 2 2
3 2 1```

### 输出

```
7```

# 题解

## 作者：FjswYuzu (赞：7)

$\ \ \ \ \ \ \ $算是贪心基础吗？

---

$\ \ \ \ \ \ \ $我们假设这 $n$ 个套娃全部空置，我们的答案为 $\sum_{i=1}^n in_i \times b_i$。在当前情况下，如果我们再将一个套娃放进另外一个套娃（不妨设为 $i$ 和 $j$），不满度就减少了 $out_i \times b_j$。想到了这里，考虑到 $in,out,b$ 是不会改变的，同时外径大的套娃显然不会影响其他的套娃，可以考虑贪心。

---

$\ \ \ \ \ \ \ $贪心策略：先以 $b_i$ 为关键字对 $n$ 个套娃从大到小排序，按着顺序将 $out$ 最大的套娃套进去。

$\ \ \ \ \ \ \ $对于这个直觉得来的贪心策略，我们如何证明？

$\ \ \ \ \ \ \ $仍然设两个套娃是 $i$ 和 $j$。如果 $b_i>b_j,out_p>out_q$，很显然，$b_i \times out_q+b_j \times out_p<b_i \times out_p+b_j \times out_q$，因此贪心策略得到证明。

---

$\ \ \ \ \ \ \ $回到问题。我们现在要做的是匹配两个套娃，首先将所有的套娃扔进可重集（`multiset`）当中，计算初始答案（也就是全部都是空套娃的情况）。

$\ \ \ \ \ \ \ $然后用二分查找（`lower_bound`）找到第一个大于等于当前考虑套在一起的套娃内径的外径。因为还是装不下，所以迭代器减一，然后将这两个娃套在一起，将这个套娃从可重集中去掉（可重集内部元素递增），并减去相应的贡献。

$\ \ \ \ \ \ \ $特殊的，如果迭代器没有查找到，也就是返回了 `Set.begin()`，此时当前的套娃没有一个满足要求。

---

$\ \ \ \ \ \ \ $有了这些，思路就很清晰了。注意套娃可能一样，所以要用可重集。

```cpp
#include<cstdio>
#include<algorithm>
#include<set>
#include<map>
using namespace std;
typedef long long LL;
#define int LL
typedef multiset<int>::iterator Site;
struct tw{
	int out,in,b;
	bool operator < (tw q) const {return b>q.b;}
}wa[200005];
multiset<int> Set;
signed main(){
	int n,ans=0;
	scanf("%lld",&n);
	for(int i=1;i<=n;++i)
	{
		scanf("%lld %lld %lld",&wa[i].out,&wa[i].in,&wa[i].b);
		ans+=wa[i].in*wa[i].b;
		Set.insert(wa[i].out);
	}
	sort(wa+1,wa+1+n);
	for(int i=1;i<=n;++i)
	{
		Site it=Set.lower_bound(wa[i].in);
		if(it!=Set.begin())	ans-=(*--it)*wa[i].b,Set.erase(it);
	}
	printf("%lld",ans);
	return 0;
}
```

---

$\ \ \ \ \ \ \ $~~劝诫：禁止套娃。~~

---

## 作者：jiayixuan1205 (赞：4)

## 题解：P6093 [JSOI2015] 套娃
### 题目大意
给出多个套娃的内径 `in`，外径 `out` 以及好看度 `b`，定义不满意度为两套娃间的空隙与外层不好看度乘积之和，求不满意度的最小值。
### 算法
考虑贪心。
### 分析
先考虑所有套娃不套在一起的情况，那么此时的不完美度就是所有的 `in` 和 `b` 的乘积之和。我们此时需要计算的值就转变为了每次套娃我们可以减少的不完美度的最大值。容易想到，我们先将所有套娃按照好看度由大到小排序，优先使好看度最高的套娃获得最小的内径差值。可以用 `multiset` 来记录未被套起来的套娃。
### 证明
如果先选择好看度没那么高的套娃相套，可以发现产生的贡献一定不高于如上方法，因此这个贪心是正确的。还看到了一种比较内径值与好看度成绩的积的方法，这里不加赘述。
### 注意
记得开 `long long`。
### 代码展示
```cpp
#include<bits/stdc++.h>
#define int long long

using namespace std;

const int N = 2e5+10;
int n,ans;

multiset<int>s;
multiset<int>::iterator it;//迭代器 

struct node{
    int in,out,b;
}a[N];

inline bool cmp(node a,node b)
{
    return a.b>b.b;
}

signed main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i].out>>a[i].in>>a[i].b;
        ans+=a[i].in*a[i].b;//初始未相套的不完美度 
        s.insert(a[i].out);//记录外径 
    }
    sort(a+1,a+1+n,cmp);
    for(int i=1;i<=n;i++)
    {
        it=s.lower_bound(a[i].in);//找到了间隙最接近的 
        if(it!=s.begin()) 
        {
            it--;//向前一位 
            ans-=a[i].b*(*it);//减去新产生的贡献 
            s.erase(it);
        }
    }
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：小杨小小杨 (赞：2)

## 题目意思：

很明白哈。

## 思路：

写代码前：为啥两篇题解这么像不会是抄的吧。

写代码后：这是蓝？？？？？

因为考虑到每一个套娃有美丽度和内径还有里面套娃的外径三个参数，我们发现这玩意似乎很难算——很难考虑里面的小内径的套娃怎么放置。

但是细细思考：美丽度是确定的，内径也是确定的，不确定的只有外径诶。

然后我们看到题目里的一句话：

**把 $k$ 和 $i$ 作为一个整体放入 $j$ 的内部**

也就是说，你可以认为这个套娃虽然放在了别的套娃里面，但是它相对于里面依旧是独立的个体，把它当独立个体算就好了。然后根据贪心，肯定让美丽值更高的个体先进行选择——因为它就一个变量。

那么就能得出结论了：

对于每一个套娃，按照美丽值从大到小排序后，每次放还没放在别的套娃里面的、和它差距最小的、能放在它里面的套娃，如果没有套娃可以放了那就只能空置了咯。

这里使用 multiset 实现。~~这玩意真好用就是有点慢~~。

## Code：


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e5+10;
int n,i,ans;
struct Node{int out,in,b;}doll[N];
multiset<int> p;
multiset<int>::iterator id;
bool cmp(Node x,Node y){return x.b>y.b;}//按照美丽值排序
signed main(){
	scanf("%lld",&n);
	for (i=1;i<=n;i++) scanf("%lld%lld%lld",&doll[i].out,&doll[i].in,&doll[i].b),p.insert(doll[i].out);//压入multiset（自动排序+可重复，老爽了）
	sort(doll+1,doll+n+1,cmp);//排序
	for (i=1;i<=n;i++){
		id=p.lower_bound(doll[i].in);//二分查找外径第一个大于等于内径的套娃
		if (id!=p.begin()) id--,ans+=(doll[i].in-(*id))*doll[i].b,p.erase(id);//如果能找到，那么就放进去
		else ans+=doll[i].in*doll[i].b;//不然就空置
	}
	printf("%lld\n",ans);
	return 0;
}
```

---


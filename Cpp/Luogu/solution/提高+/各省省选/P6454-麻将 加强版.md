# 麻将 加强版

## 题目背景

此题我本来是想出公开赛的，没想到撞题了。

题面是我自己撰写的，与原题不同。

此题题意与 [P4050](https://www.luogu.com.cn/problem/P4050) 大致相同，**有少许不同**，**且数据范围有所更改**。

------------

小 A 喜欢打麻将。

## 题目描述

小 A 找到了一副奇怪的麻将牌：只有一种 $1,2,\cdots,n$ 的数牌，且每种牌都有**无穷多张**。

定义「雀头」为两张一样的牌（如 $2,2$，$7,7$），「刻子」为三张一样的牌（如 $1,1,1$，$4,4,4$），「顺子」为三张序数相邻的牌（如 $1,2,3$，$9,10,11$，注意 $1$ 与 $n$ 不相邻）。「顺子」与「刻子」统称「面子」。

假如你能把你的手牌分为若干组「雀头」（**可以相同**），或者分为若干组「面子」（**可以相同**）以及一组「雀头」，那么你就可以「和牌」。

假如某副手牌加上某张牌后可以「和牌」，则称这副手牌「听」这张牌。

现在小 A 随意摸了 $k$ 张牌，他想知道他「听」哪些牌。

## 说明/提示

#### 样例解释

样例一解释：这种牌型叫做[纯正九莲宝灯](https://zh.moegirl.org/%E6%97%A5%E6%9C%AC%E9%BA%BB%E5%B0%86:%E4%B9%9D%E8%8E%B2%E5%AE%9D%E7%81%AF)。~~折寿警告~~  
具体划分方式：
```plain
1 111|123|456|789|99
2 111|345|678|999|22
3 123|345|678|999|11
4 111|234|456|789|99
5 111|234|678|999|55
6 123|456|678|999|11
7 111|234|567|789|99
8 111|234|567|999|88
9 123|456|789|999|11
```

[](https://i.loli.net/2020/04/18/TPvukw8pbHNnFC4.png)

样例二解释：很显然这套牌差一张 $7$ 即可分为 $1,1;1,1;3,3;3,3;5,5;5,5;7,7$ 共计 $7$ 组「雀头」和牌。

#### 数据范围

**本题采用捆绑测试。**

- $\text{Subtask\;1(5\;pts)}$：$k=1$。  
- $\text{Subtask\;2(5\;pts)}$：$n=1$。  
- $\text{Subtask\;3(10\;pts)}$：$n=9$。  
- $\text{Subtask\;4(15\;pts)}$：$k\le 100$。  
- $\text{Subtask\;5(15\;pts)}$：$n\le 100$。    
- $\text{Subtask\;6(50\;pts)}$：无特殊限制。  

对于所有数据，$1\le n\le 5\times10^3$，$1\le k\le 10^5$，$1\le a_i\le n$，$k\equiv 1\pmod 6$。

## 样例 #1

### 输入

```
9 13
1 1 1 2 3 4 5 6 7 8 9 9 9
```

### 输出

```
9
1 2 3 4 5 6 7 8 9```

## 样例 #2

### 输入

```
9 13
1 1 1 1 3 3 3 3 5 5 5 5 7
```

### 输出

```
1
7```

# 题解

## 作者：WYXkk (赞：30)

先说点无关的……

------

我出了这题，一开始就想到了原题题解中已有的 $O(n^3)$ 解法。

之后我思考了一下，想到了原题题解中没有的一种 $O(n^2)$ 解法。

某天我兴高采烈地想着“是不是所有麻将题都会拿纯九做样例”于是就搜到了这题。

于是我 test 了半天发现他们都过不了（因为我的 **解法（不是写法）** 常数小）。

同时我发现 baidu 到的前几十篇题解都是 $O(n^3)$ 的。

我私信咨询了 chen_zhe，他表示不适合放公开赛，于是我就扔这儿当加强了。

------

接下来说解法。

首先，我们可以轻易发现下面这个 $O(n^3)$ 的解法：

> 枚举听的牌，加一张进去。
>
> 枚举雀头，减掉两张。
>
> 贪心判断剩下的能不能划分为若干面子：由于三组同样的顺子可以被重新划分为三组刻子，因此尽量多划分为刻子更优。从 $1$ 开始贪心即可，从 $n$ 开始也可以。

代码实现可以参考原题的第一篇题解。此处略去。

此时我们发现，雀头为 $a$ 和 $a+1$ 的时候，我们几乎是把同样的过程做了两遍——从 $1$ 到 $a-1$ 的贪心过程**毫无变化**，如果反着贪的话那就是 $n$ 到 $a+2$。

于是我们可以考虑 **（不去掉雀头）** 正着贪一遍，反着贪一遍，记录一些信息，然后再通过记录的这些信息来确定和哪些牌。当然我们必须特判贪到一半贪不动的情况。

我们可以设 $f_{i,0}$ 和 $f_{i,1}$ 分别表示贪完 $1$ 到 $i$ 后需要多少张 $i+1$ 和 $i+2$ 来补全为若干组面子， $g_{i,0}$ 和 $g_{i,1}$ 则分别表示贪完 $n$ 到 $i$ 后需要多少张 $i-1$ 和 $i-2$ 来补全为若干组面子。

这两个贪心时都非常好维护，具体细节见代码。

假如我们根据 $f_{a-1}$ 和 $g_{a+1}$ 来确定雀头为 $i$ 时的答案，那么 $\{a-1,a,a+1\}$ 这组顺子会被试图计算两次，因此不行。

于是我们应该根据 $f_{a-1}$ 和 $g_{a+2}$ 来计算雀头为 $a$ 或 $a+1$ 是否可行。

减去补全需要的个数后，判断一下两个是否都大于零，然后判断是不是一个 $\equiv0\pmod 3$ 一个 $\equiv2\pmod 3$ 即可。

这样判断和牌是 $O(n)$ 的，可以通过本题。

（虽然原题题解的后几篇中也有 $O(n)$ 的 dp 判和，但是常数过大通过不了此加强版，开了 O2 也救不了）

$\texttt{code:}$

```cpp
#include<cstdio>
#include<iostream>
#include<fstream>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
#define Set(a) memset(a,0,sizeof(a))
#define F(i,a,b) for(register int i=a,i##end=b;i<=i##end;++i)
#define UF(i,a,b) for(register int i=a,i##end=b;i>=i##end;--i)
#define openf(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
#define re register
#define ri re int
#define il inline
typedef long long ll;
typedef unsigned long long ull;
template<typename T> inline T rd(T& x)
{
	T f=1;x=0;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(; isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(T)(c-'0');
	x*=f;
	return x;
}
ll rd(){ll x;rd(x);return x;}
inline int max(int a,int b){return a>b?a:b;}
inline int min(int a,int b){return a<b?a:b;}
const int inf=1<<30;

const int N=5005;
int a[N],b[N],n;
int l[N][2],r[N][2];
bool check()
{
	F(i,1,n) b[i]=a[i];
	int posl=n-1;
	F(i,1,n-2)
	{
		b[i]-=l[i-1][0];
		if(b[i]<0) {posl=i;break;}
		b[i]%=3;
		l[i][0]=l[i-1][1]+b[i];l[i][1]=b[i];
	}
	F(i,1,n) b[i]=a[i];
	int posr=2;
	UF(i,n,3)
	{
		b[i]-=r[i+1][0];
		if(b[i]<0) {posr=i;break;}
		b[i]%=3;
		r[i][0]=r[i+1][1]+b[i];r[i][1]=b[i];
	}
	bool flg=false;//i-1<posl i+2>posr
	F(i,posr-1,posl)
	{
		int x=a[i]-l[i-1][0]-r[i+2][1],y=a[i+1]-l[i-1][1]-r[i+2][0];
		if(x>=0&&y>=0) if((x%3==2&&y%3==0)||(x%3==0&&y%3==2)) {flg=true;break;}
	}
	bool x=1;F(i,1,n) if(a[i]%2!=0) x=0;
	if(x) flg=1;
	return flg;
}
int ls[N],tot=0;
int main()
{
	rd(n);int k=rd();
	while(k--) ++a[rd()];
	F(i,1,n)
	{
		++a[i];
		if(check()) ls[++tot]=i;
		--a[i];
	}
	printf("%d\n",tot);
	F(i,1,tot) printf("%d ",ls[i]);
	return 0;
}
```

最后再吐槽几句：

这题强一点的数据比较难造，我一开始完全随机 $k$ 张，结果造出来的不是不听牌就是听所有牌。

于是我就改成先随机一个和牌的然后再去掉一张，如果听 $1$ 或者 $n$ 张就重来（除了 sub12 必听一张，sub4 几乎永远听一张），才正常一点。当然就花了更长的时间写 gen。

（因此输出 `0` 没分，`n[newline]1 2 ... n` 只有 sub 2 过 233）

---

## 作者：喵仔牛奶 (赞：7)

# Preface

这是一篇时空复杂度 $\mathcal{O}(n)$ 的题解。


可以测评我的 [U321190 麻将 加强加强版 ](/problem/U321190)，也可以到[我的博客](https://www.cnblogs.com/Milkcatqwq/p/17594488.html)查看加强加强版更加详细的题解。

# Solution

由于三组同样的「顺子」可以被重新划分为三组「刻子」，所以相同的「顺子」不会超过三组。

设 $f_{i,j,k,0/1}$ 为用完 $1\sim i$ 的牌，加入了一张牌后，有 $j$ 组以 $i-2$ 开头的「顺子」，$k$ 组 $i-1$ 开头的「顺子」，有或无「雀头」（$1$ 为有，$0$ 为无）的情况是否可能。

设 $g_{i,j,k,0/1}$ 为用完 $1\sim i$ 的牌，未加入牌，有 $j$ 组以 $i-2$ 开头的「顺子」，$k$ 组 $i-1$ 开头的「顺子」，有或无「雀头」（$1$ 为有，$0$ 为无）的情况是否可能。

枚举 $i$ 进行每轮转移，转移如下。

先转移 $g$：
- 不分出「雀头」，则 $g_{i+1,k,(a_{i+1}-j-k)\bmod3,0/1}\gets g_{i,j,k,0/1}$。
- 分出「雀头」，则 $g_{i+1,k,(a_{i+1}-j-k-2)\bmod3,1}\gets g_{i,j,k,0}$。

接着转移 $f$：
- $f$ 间转移，不分出「雀头」，则 $f_{i+1,k,(a_{i+1}-j-k)\bmod3,0/1}\gets f_{i,j,k,0/1}$。
- $f$ 间转移，分出「雀头」，则 $f_{i+1,k,(a_{i+1}-j-k-2)\bmod3,1}\gets f_{i,j,k,0}$。
- 插入一张点数为 $i+1$ 的牌, 即 $a_{i+1}\gets a_{i+1}+1$。
- $g$ 向 $f$ 转移，不分出「雀头」，则 $f_{i+1,k,(a_{i+1}-j-k)\bmod3,0/1}\gets g_{i,j,k,0/1}$。
- $g$ 向 $f$ 转移，分出「雀头」，则 $f_{i+1,k,(a_{i+1}-j-k-2)\bmod3,1}\gets g_{i,j,k,0}$。

由于要输出方案，所以将 $f$ 的转移变为连边。DP 有无后效性，建出的图为 DAG。从最终状态出发，遍历能够到达的所有状态。当一个状态由 $g$ 转移来时，说明「听」这张牌。

需要特判全「雀头」的情况。

时间复杂度 $\mathcal{O}(n)$。

代码实现：
```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
using namespace std;
namespace Milkcat {
    typedef long long LL;
    typedef pair<LL, LL> pii;
    const int N = 1e6 + 5;
    int n, k, x, a[N], cnt[N], last[N], used[N], vis[N], g[N][3][3][2];
	vector<int> res, G[N], C[N];
	inline int id(int i, int j, int k, int p) { return i * 18 + j * 6 + k * 2 + p; }
	void dfs(int u) {
	    vis[u] = 1;
		for (int v : C[u]) used[v] = 1;
		for (int v : G[u])
		    if (!vis[v]) dfs(v);
	}
	int main() {
		cin >> n >> k;
		for (int i = 1; i <= k; i ++) cin >> x, a[x] ++;
		for (int i = 1; i <= n; i ++) cnt[a[i] % 2] ++, last[a[i] % 2] = i;
		g[0][0][0][0] = 1;
		for (int i = 0; i < n; i ++) {
			for (int j = 0; j < 3; j ++)
				for (int k = 0; k < 3; k ++)
					for (int p = 0; p < 2; p ++) {
						if (!g[i][j][k][p]) continue;
						if (a[i + 1] >= j + k) g[i + 1][k][(a[i + 1] - j - k) % 3][p] = 1;
						if (!p && a[i + 1] >= j + k + 2) g[i + 1][k][(a[i + 1] - j - k - 2) % 3][1] = 1;
					}
			for (int j = 0; j < 3; j ++)
				for (int k = 0; k < 3; k ++)
					for (int p = 0; p < 2; p ++) {
						int t = id(i, j, k, p);
						if (a[i + 1] >= j + k) G[id(i + 1, k, (a[i + 1] - j - k) % 3, p)].push_back(t);
						if (!p && a[i + 1] >= j + k + 2) G[id(i + 1, k, (a[i + 1] - j - k - 2) % 3, 1)].push_back(t);
					}
			a[i + 1] ++;
			for (int j = 0; j < 3; j ++)
				for (int k = 0; k < 3; k ++)
					for (int p = 0; p < 2; p ++) {
						if (!g[i][j][k][p]) continue;
						if (a[i + 1] >= j + k) C[id(i + 1, k, (a[i + 1] - j - k) % 3, p)].push_back(i + 1);
						if (!p && a[i + 1] >= j + k + 2) C[id(i + 1, k, (a[i + 1] - j - k - 2) % 3, 1)].push_back(i + 1);
					}
		}
		dfs(id(n, 0, 0, 1));
		if (cnt[1] == 1) used[last[1]] = 1;
		for (int i = 1; i <= n; i ++)
			if (used[i]) res.push_back(i);
		cout << res.size() << '\n';
		for (int v : res) cout << v << ' ';
        return 0;
    }
}
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0); 
    int T = 1;
    while (T --) Milkcat::main();
    return 0;
}


```

---


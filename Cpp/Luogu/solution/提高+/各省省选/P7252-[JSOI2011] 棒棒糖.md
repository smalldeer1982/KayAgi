# [JSOI2011] 棒棒糖

## 题目描述

Coffee 的世界里也是有棒棒糖卖的，Coffee 买了 $n$ 只连着的棒棒糖。这 $n$ 只棒棒糖包裹在小塑料袋中，排成
一列，相邻的两只棒棒糖的塑料袋是接起来的。为了方便，我们把棒棒糖从左到右编号为$1\cdots n$。

每只棒棒糖有一种口味。第 $i$ 只的口味是 $c_i$。两只棒棒糖 $i,j$ 的口味相同，当且仅当 $c_i=c_j$。Coffee 对 $m$ 只棒棒糖总体口味的评价比较奇怪。如果这 $m$ 只棒棒糖中，有一种口味 $c_0$ 的数量严格大于总数的一半，那么 Coffee 认为这 $m$ 只棒棒糖主要是 $c_0$ 口味的。Coffee 知道，这里的 $c_0$ 如果存在就一定是唯一的。而当 $c_0$ 不存在时，Coffee 认为这 $m$ 只棒棒糖是混合口味的。

Coffee 暂时舍不得吃棒棒糖，它在想一些好玩的问题。如果考虑棒棒糖序列的一个连续子序列 $s\cdots t(1\leq s\leq t\leq n)$，包括棒棒糖 $s$ 和 $t$。那么这 $t-s+1$ 只棒棒糖的总体口味是什么呢？

Coffee有一堆这样的问题，一共 $m$ 个。第 $i$ 个问题是棒棒糖子序列 $s_i\cdots t_i$ 的总体口味，请你帮忙解决。

## 说明/提示

### 样例解释 1

在第一个询问中，口味 $1$ 出现 $3$ 次，大于总数的一半，所以总体口味为 $1$。

在第二个询问中，没有一种口味出现次数大于总数的一半，所以为混合口味。

在第三个询问中，口味 $2$ 出现 $2$ 次，大于总数的一半，所以总体口味为 $2$。

### 数据范围

对于 $100\%$ 的数据，$1\leq n,m,c_i\leq 5\times 10^4$。

## 样例 #1

### 输入

```
5 3 
1 
2 
2
1
1
1 5
2 5
2 4```

### 输出

```
1
0
2```

# 题解

## 作者：namelessgugugu (赞：22)

首先这题显然可以有一万种做法做到 $O(n\log n)$ 的时间复杂度，但数据范围才 $50000$，为什么不用一点更劣但是更好写的做法呢？

考虑到如果区间有绝对众数，那么如果你随机挑选一个区间中的数，取到答案的概率超过 $\frac{1}{2}$。如果有答案，那么期望随机 $O(1)$ 次就能找到，并且随机 $k$ 次后还未找到答案的概率是不超过 $(\frac{1}{2})^k$ 的，因此如果多随几次后还未找到答案，我们就可以认定该区间没有绝对众数。我在代码中把这个阈值定为了 $40$ 次。

最后一个问题就是怎么算一个值在区间中的出现次数，这里直接选择用 `vector` 存下每一个颜色的序列，然后在对应颜色的 `vector` 中二分左右端点，下标之差即为出现次数。

```cpp
#include <cstdio>
#include <algorithm>
#include <vector>
#include <random>
const int N = 50005;
int n, m;
int c[N];
std::vector<int> vec[N];
inline int calc(int l, int r, int c)
{
    return std::upper_bound(vec[c].begin(), vec[c].end(), r) - std::lower_bound(vec[c].begin(), vec[c].end(), l);
}
std::mt19937 rng(114514);
int main(void)
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n;++i)
        scanf("%d", c + i), vec[c[i]].push_back(i);
    for (int i = 1, l, r; i <= m;++i)
    {
        scanf("%d%d", &l, &r);
        int ans = 0;
        for (int j = 1; j <= 40; ++j)
        {
            int t = rng() % (r - l + 1) + l;
            int cnt = calc(l, r, c[t]);
            if(cnt * 2 > r - l + 1)
            {
                ans = c[t];
                break;
            }
        }
        printf("%d\n", ans);
    }
    return 0;
}
```

---

## 作者：UnyieldingTrilobite (赞：15)

这里介绍一种理论最优复杂度的算法。

在阅读本文之前，您至少需要掌握：

+ 摩尔投票。

+ 猫树，或者其他写法的二区间合并。

我们将把算法分为求值和检验两部分依次阐述。

1. 求值

等于是要求个区间摩投出来。

序列按 $\log n$ 分块，块间猫，如此再在块内递归一层，我们接下来只需要 $O(n)-O(1)$ 地解决规模为 $O(\log\log n)$ 的问题。

我们考虑对每一个这样的块中块进行离散化（使用哈希表而不是排序来获得线性的复杂度），这样本质不同的块至多只有 $O((\log\log n)^{\log\log n})=O(2^{\log\log n\times\log\log\log n})$ 种，再考虑所有本质不同的询问，一共所有不同的状态数实际上只有 $O(2^{\log\log n\times\log\log\log n}(\log\log n)^2)$ 种，这个东西总之是亚线性的，我们全都嗯预处理出来就可以了。预处理使用摩投递推的话单次转移是常数时间，换而言之预处理的复杂度也就是这个鬼东西。至于状态的对应，我们二进制压缩一下就可以快速检索了。

总复杂度 $O(n)$。

2. 检验

实际上这部分比求值难……

首先有一个简单的结论是对于固定的 $x$ 绝对众数为 $x$ 的所有区间并集的长度是 $O(c_x)$ 的，其中 $c_x$ 表示 $x$ 的出现次数。证明就考虑一个加一减一的折线图然后顺次考虑每个峰然后分别砍掉就可以开归了。

我们考虑对于每一个并集中的区间 $[l,r]$，我们求出 $x$ 出现与否的状态在 $[l-1,r]$ 上的全局前缀和，这样所有被计算的前缀和数量也是 $O(c_x)$ 的，用哈希表存储。如此一来，对于检验 $x$ 为 $[l,r]$ 的绝对众数，我们只需要计算 $l-1$ 和 $r$ 位置上的前缀和即可。如果不存在，说明本身 $[l,r]$ 一定不是绝对众数为 $x$ 所有区间并集的子集，那么直接返回否即可。

至于这个找区间的实现……大概是我比较菜所以感觉非常阴间，我们考虑 $x$ 出现的第 $i$ 个位置为 $p_i$，那么我们维护 $2i-p_i$ 的前缀最小值和后缀最大值然后双指针对于每个位置求出“绝对众数为 $x$ 的区间最左边的 $x$ 在这个位置”的所有合法区间的并集形式，然后就可以了。这部分感觉非常抽象，建议直接看代码。

总复杂度 $O(n)$。

综上所述我们就在 $O(n)-O(1)$ 的复杂度内解决了这个问题。

```cpp
#include <bits/stdc++.h>
using namespace std;
struct custom_hash {
  static uint64_t splitmix64(uint64_t x) {
    x += 0x9e3779b97f4a7c15;
    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
    return x ^ (x >> 31);
  }
  size_t operator()(uint64_t x) const {
    static const uint64_t FIXED_RANDOM =
        chrono::steady_clock::now().time_since_epoch().count();
    return splitmix64(x + FIXED_RANDOM);
  }
};
typedef unordered_map<int, int, custom_hash> hmap;
constexpr int N = 5e4 + 9, B = 16, H = 4, W = 2;
constexpr int S = (N >> H) + 1, Z = 1 << (H * W);
int n, m, c[N];
struct mvt {
  int x, c;
  mvt() : x(0), c(0) {}
  mvt(int x, int c) : x(x), c(c) {}
  mvt(int x) : x(x), c(1) {}
  friend mvt operator+(const mvt& a, const mvt& b) {
    if (a.x == b.x) return {a.x, a.c + b.c};
    if (a.c > b.c) return {a.x, a.c - b.c};
    return {b.x, b.c - a.c};
  }
};
template <int L, int N>
struct ct_tree {
  mvt val[N], ct[L][N];
  void build(mvt* a, int n) {
    copy_n(a, n, val);
    for (int h = 0, s = 1; s < n; ++h, s <<= 1)
      for (int i = s; i <= n; i += s << 1) {
        ct[h][i - 1] = val[i - 1];
        for (int j = i - 1; j > i - s; --j)
          ct[h][j - 1] = val[j - 1] + ct[h][j];
        if (i == n) break;
        ct[h][i] = val[i];
        for (int j = i + 1; j < i + s && j < n; ++j)
          ct[h][j] = ct[h][j - 1] + val[j];
      }
  }
  mvt query(int l, int r) const {
    if (l == r) return val[l];
    int h = __lg(l ^ r);
    return ct[h][l] + ct[h][r];
  }
};
vector<int> dsct(int* a, int n) {
  hmap tmp;
  vector<int> ret;
  for (int i = 0, t = 0; i < n; ++i) {
    int& x = tmp[a[i]];
    if (!x) ret.push_back(a[i]), x = ++t;
    a[i] = x - 1;
  }
  return ret;
}
hmap s[N];
vector<int> idv;
mvt qans[Z][H][H];
struct iiblk {
  vector<int> idv;
  int st;
  void build(int* c, int n) {
    idv = dsct(c, n), st = 0;
    for (int i = 0; i < n; ++i) st |= c[i] << (i * W);
  }
  mvt query(int l, int r) const {
    mvt ans = qans[st][l][r];
    ans.x = idv[ans.x];
    return ans;
  }
};
struct iblk {
  ct_tree<W, B> bs;
  iiblk ib[B];
  void build(int* c, int n) {
    int z = ((n - 1) >> W) + 1;
    vector<mvt> val(z);
    for (int i = 0; i < n; ++i) val[i >> W] = val[i >> W] + c[i];
    bs.build(val.data(), z);
    for (int i = 0; i < z; ++i) ib[i].build(c + (i << W), min(n - (i << W), H));
  }
  mvt query(int l, int r) const {
    int lb = l >> W, rb = r >> W;
    if (lb == rb) return ib[lb].query(l & (H - 1), r & (H - 1));
    mvt ret = ib[lb].query(l & (H - 1), H - 1) + ib[rb].query(0, r & (H - 1));
    if (lb + 1 < rb) ret = ret + bs.query(lb + 1, rb - 1);
    return ret;
  }
} ib[S];
ct_tree<B, S> ct;
void init() {
  for (int s = 0; s < Z; ++s)
    for (int l = 0; l < H; ++l) {
      mvt tmp;
      for (int r = l; r < H; ++r)
        qans[s][l][r] = tmp = tmp + ((s >> (r * W)) & (H - 1));
    }
  idv = dsct(c, n);
  vector<vector<int>> pos(n);
  for (int i = 0; i < n; ++i) pos[c[i]].push_back(i);
  for (int t = 0; t < n; ++t) {
    vector<int>& occ = pos[t];
    int k = occ.size();
    if (!k) continue;
    vector<int> val(k);
    for (int i = 0; i < k; ++i) val[i] = 2 * i - occ[i];
    basic_string<bool> pmn(k, false), smx(k, false);
    vector<int> sufmx(k);
    vector<pair<int, int>> itv, tmp;
    for (int i = 0, p = INT_MAX; i < k; ++i)
      if ((pmn[i] = val[i] < p)) p = val[i];
    for (int i = k - 1, p = INT_MIN; ~i; --i)
      if ((smx[i] = val[i] > (sufmx[i] = p))) p = val[i];
    for (int i = 0, j = 0, w = 0; i < k; ++i) {
      if (!pmn[i]) continue;
      while (j < k && (sufmx[j] >= val[i])) ++j;
      while (w < k && (w < i || !smx[w])) ++w;
      if (j < i) break;
      int l = max(i ? occ[i - 1] + 1 : 0, occ[i] - (val[w] - val[i]));
      int r =
          min(j < k - 1 ? occ[j + 1] - 1 : n - 1, occ[j] + (val[j] - val[i]));
      itv.emplace_back(l, r);
    }
    int l = -1e9, r = l - 1;
    for (auto [pl, pr] : itv)
      if (pl > r + 1) {
        if (l <= r) tmp.emplace_back(l - 1, r);
        l = pl, r = pr;
      } else
        r = max(r, pr);
    if (l <= r) tmp.emplace_back(l - 1, r);
    for (int i = 0; auto [l, r] : tmp)
      for (int j = l; j <= r; ++j) {
        while (i < k && occ[i] <= j) ++i;
        s[t].emplace(j, i);
      }
  }
  int z = ((n - 1) >> H) + 1;
  vector<mvt> val(z);
  for (int i = 0; i < n; ++i) val[i >> H] = val[i >> H] + c[i];
  ct.build(val.data(), z);
  for (int i = 0; i < z; ++i) ib[i].build(c + (i << H), min(n - (i << H), B));
}
int gsum(int p, int x) {
  auto it = s[x].find(p);
  if (it == s[x].end()) return -1;
  return it->second;
}
bool chk(int l, int r, int x) {
  int sl = gsum(l - 1, x), sr = gsum(r, x);
  if (!~sl || !~sr) return false;
  return ((sr - sl) << 1) > r - l + 1;
}
int qbase(int l, int r) {
  int lb = l >> H, rb = r >> H;
  if (lb == rb) return ib[lb].query(l & (B - 1), r & (B - 1)).x;
  mvt ret = ib[lb].query(l & (B - 1), B - 1) + ib[rb].query(0, r & (B - 1));
  if (lb + 1 < rb) ret = ret + ct.query(lb + 1, rb - 1);
  return ret.x;
}
int query(int l, int r) {
  int x = qbase(l, r);
  return chk(l, r, x) ? idv[x] : 0;
}
signed main() {
  cin.tie(nullptr)->sync_with_stdio(false);
  cin >> n >> m;
  for (int i = 0; i < n; ++i) cin >> c[i];
  init();
  for (int l, r; m; --m) {
    cin >> l >> r;
    cout << query(--l, --r) << '\n';
  }
  return cout << flush, 0;
}
```

---

## 作者：山田リョウ (赞：13)

这是蒟蒻的第三篇题解，文笔可能不太好，希望各位神仙能理解。

这是一道题可以用主席树来做，我们先从这道题的祖宗说起。

---

> 维护一个序列，支持插入一个值，查询出现次数严格大于序列中元素个数的一半的数，若不存在则返回$0$。

开一棵值域线段树，由于一个正整数 $x$ 如果大于另一个数 $k$，则 $x$ 加上其他正整数，依然大于 $k$ 。~~废话！~~

所以我们这么写就好了：
```cpp
//没有编译过，不保证正确。
int query(int rt,int k,int l,int r) {
    if(l==r)
        return l;
    int mid=l+r>>1;
    if(node[node[rt].lc].sum>k)//如果左边的和大于k，左边就有可能有大于k的
        return query(node[rt].lc,k,l,mid);
    if(node[node[rt].rc].sum>k)//如果右边的和大于k，右边就有可能有大于k的
        return query(node[rt].rc,k,mid+1,r);
    return 0;//如果没有一边大于k，就返回0
}rn 0;
}
```
---

那我们这道题就开 $n+1$ 棵值域线段树，然后查询的时候就把第 $r$ 棵线段树减掉第 $l-1$ 棵线段树就好了！

查询部分代码如下：
```cpp
int query(int rtl,int rtr,int k,int l,int r) {
    if(l==r)
        return l;
    int lcsum=node[node[rtr].lc].sum-node[node[rtl].lc].sum,rcsum=node[node[rtr].rc].sum-node[node[rtl].rc].sum; //注意用右边的线段树减掉左边的
    int mid=l+r>>1;
    if(lcsum>k)
        return query(node[rtl].lc,node[rtr].lc,k,l,mid);
    if(rcsum>k)
        return query(node[rtl].rc,node[rtr].rc,k,mid+1,r);
    return 0;
}
```
但如果真的开 $n+1$ 棵线段树空间复杂度会爆炸，所以我们考虑优化：

1. 动态开点
1. 可持久化

单纯动态开点可能能过，只有可持久化应该能过，但我两个都用了，代码如下：
```cpp
#include<cstdio>
struct tree{
    int sum;
    int lc, rc;
    tree(int a=0,int b=0,int c=0) {
        sum=a;
        lc=b;
        rc=c;
    }
}node[850001];
int cnt;
int newnode(int a,int b,int c) {//新建一个线段树节点，负责的区间的和为a，左右儿子分别为b、c，并返回这个节点
    node[++cnt]=tree(a,b,c);
    return cnt;
}
int add(int rt,int x,int l,int r) {//复制rt这棵线段树，并在x位置上加一，并返回新线段树，其中l和r表示这棵线段树负责的范围
    if(l==r)
        return newnode(node[rt].sum+1,0,0);
    int mid=l+r>>1;
    if(x<=mid) 
        return newnode(node[rt].sum+1,add(node[rt].lc,x,l,mid),node[rt].rc);
    return newnode(node[rt].sum+1,node[rt].lc,add(node[rt].rc,x,mid+1,r));
}
const int qwq=0;
int query(int rtl,int rtr,int k,int l,int r) {
    if(l==r)
        return l;
    int lcsum=node[node[rtr].lc].sum-node[node[rtl].lc].sum,rcsum=node[node[rtr].rc].sum-node[node[rtl].rc].sum;
    int mid=l+r>>1;
    if(lcsum>k)
        return query(node[rtl].lc,node[rtr].lc,k,l,mid);
    if(rcsum>k)
        return query(node[rtl].rc,node[rtr].rc,k,mid+1,r);
    return 0;
}
int root[50001];
int main() {
    int n,m;
    std::scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) {
        int x;
        std::scanf("%d",&x);
        root[i]=add(root[i-1],x,1,50000);
    }
    while(m--) {
        int s,t;
        std::scanf("%d%d",&s,&t);
        std::printf("%d\n",query(root[s-1],root[t],t-s+1>>1,1,50000));
    }
    return qwq;
}
```

码字不易，求点个赞qwq。

---

## 作者：critnos (赞：8)

## 题意

经典题，区间严格过半众数。若不存在则输出 $0$。

## sol

俺来介绍一些~~早已普及的~~高科技。

~~随机化一边去啦~~

#### 一个非常规的巧妙做法

拆位，对于每一位组成的 $01$ 序列，建前缀和以维护区间中 $1$（$0$ 也可）的个数。

#### 对于答案的每一位的状态，就是这一位对应的 $01$ 序列的 $[l,r]$ 区间中状态数较多的那个。

实现细节：拆位的时候，逐位分开处理，可以做到 $O(n)$ 的空间复杂度。

做完了。。吗？

并没有！当区间中不存在严格众数时会出错。

所以我们需要一个 check 来验证求出来的答案是否正确。。换句话说就是求区间中某数出现次数。

~~莫队二次离线大家都学过吧？那你应该会那个离线扫描线~~

没学过也没有关系。我们将求 $[l,r]$ 中 $x$ 出现次数差分为 $[1,r]-[1,l-1]$。现在所有的询问都变成了 $[1,k]$ 的形式。把所有询问按 $k$ 归类（可以理解为排序，当然这一步是 $O(n)$ 的）。

从小到大扫描。另外维护一个数组 $t$。设我们扫到了 $p$ 这个位置则 $t_i$ 所表示的就是 $[1,p]$ 中 $i$ 的出现次数。即每扫到一个位置 $p$，$t_{a_p}\leftarrow t_{a_p}+1$。

这样扫到 $k$ 的时候，我们就可以 $O(1)$ 回答所有“$[1,k]$ 中 $x$ 的出现次数”的询问！答案就是 $t_x$！~~太神奇了！~~

这个算法就完整了。可惜是离线的。下文会介绍另外一种 check 方法。

https://www.luogu.com.cn/paste/2jpfpq4j

$O(n\log n)-(\log n)$


#### 正道

前置知识：摩尔投票法。

简介一下，考虑增量求出一个数组中的严格众数。维护当前严格众数 $p$ 和一个 $cnt$。加入一个数 $x$ 时，如果 $cnt=0$ 就把 $p$ 用 $x$ 替换掉。再如果（注意“再”，是执行了上一步替换后再执行，保证了加入新的数后 $cnt=1$） $x=p$ 就把 $cnt$ 加 $1$，否则就减 $1$。

他是正确的因为即使严格众数和其他数都抵消了也不会影响。

应该可以看出他是一个半群信息。。通俗来讲就是一般线段树可以维护的东西。

所以你把他丢到线段树上就好了。（我用的 zkw）

同样要 check。

$O(n)-(\log n)$

https://www.luogu.com.cn/paste/9hoisbd3


#### 真·高科技

嗯既然是半群信息，学术界有 $O(n\alpha(n))$ 的一般维护方式。$\alpha$ 为反阿克曼函数。

但这个特殊问题有严格 $O(n)-O(1)$ 的做法。

看这里 https://zhuanlan.zhihu.com/p/79423299 这里面有另外一种高论 check

sto hqztrue orz

---

## 作者：eexyz (赞：4)

这道题很水，写这篇题解只是因为其他 AC 代码都有点长。

如果 $r-l < 2T$ 暴力处理

否则答案出现次数必然大于 $T$ , 那么我们记录每个出现次数大于 $T$ 的数出现次数前缀和，挨个判断。

复杂度 $O(2qT+\frac{n+q}{T})$ ，取$T=\sqrt n$ 即可 AC

```c++
#include<bits/stdc++.h>
using namespace std;
#define N 50005
int S[N][251],i,c[N],g[251],a[N],j,l,r,cnt,n,m,mn,rv[N],fl;
main(){
	cin>>n>>m;
	for(i=1;i<=n;++i)cin>>a[i],++c[a[i]];
	for(i=1;i<N;++i)if(c[i]>200)g[++cnt]=i,rv[i]=cnt;
	memset(c,0,sizeof(c));
	for(i=1;i<=n;++S[i][rv[i]],++i)
		for(j=1;j<=cnt;++j)S[i][j]=S[i-1][j];
	while(m--){
		cin>>l>>r;mn=(r-l+1>>1);fl=0;
		if(r-l<400){
			for(i=l;i<=r;++i)if((++c[a[i]])>mn){cout<<a[i]<<"\n",fl=1;break;}
			for(;i>=l;--i)c[a[i]]=0;
		}
		else for(--l,i=1;i<=cnt;++i)
			if(S[r][i]-S[l][i]>mn){cout<<g[i]<<"\n",fl=1;break;}
		if(!fl)cout<<"0\n";
	}
}
```

---

## 作者：Andrewzdm (赞：3)

区间过半众数。

看到题目自然想到回滚莫队。

我们发现题目有如下特征：
+ 静态（不带修改，多次查询）
+ 每次查询是区间 $[l,r]$
+ 统计数的出现次数，而这个是经典的可以用莫队做的问题

判断是否存在数的出现次数严格大于区间长度的一半，就等价于判断区间里所有数的出现次数最大值是否严格大于区间长度的一半。

出现次数的最大值，是一个在添加过程中易维护，而在删除过程中不易维护的信息。因此我们考虑使用回滚莫队，也就是不删除莫队。

回滚莫队的实现方式及细节不了解的请自行移步模板题，这里不再赘述。

于是这题变成了一道板子题。时间复杂度 $O(n\sqrt n)$，由于 $n,m$ 同阶统一使用 $n$。

代码：
```cpp
#include <cstdio>
#include <algorithm>
#include <cmath>
using namespace std;
const int maxn = 5e4 + 10 , maxm = 5e4 + 10, maxb = 230;
int n, m;
int a[maxn];
struct query {
    int l, r, id;
} q[maxm];
int ans[maxm];
int blen, bnum, bel[maxn];
int cnt[maxn];
int L[maxb], R[maxb];

bool cmp(const query &x, const query &y) { return bel[x.l] != bel[y.l] ? bel[x.l] < bel[y.l] : x.r < y.r; }

int main() {
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; ++i) scanf("%d", a + i);
    for(int i = 1; i <= m; ++i) {
        scanf("%d%d", &q[i].l, &q[i].r);
        q[i].id = i;
    }
    blen = sqrt(n);
    bnum = n / blen;
    for(int i = 1; i <= bnum; ++i) {
        L[i] = (i - 1) * blen + 1;
        R[i] = i * blen;
    }
    if(R[bnum] != n) {
        L[bnum + 1] = R[bnum] + 1;
        R[++bnum] = n;
    }
    for(int i = 1; i <= bnum; ++i) fill(bel + L[i], bel + R[i] + 1, i);
    sort(q + 1, q + m + 1, cmp);
    int l = 1, r = 0, lst = 0, mx, fr;
    for(int i = 1; i <= m; ++i) {
        if(bel[q[i].l] != lst) {
            while(r >= l) --cnt[a[r--]];
            mx = 0; fr = 0;
            lst = bel[q[i].l];
            r = R[lst];
            l = r + 1;
        }
        if(bel[q[i].l] == bel[q[i].r]) {
            for(int j = q[i].l; j <= q[i].r; ++j)
                if(++cnt[a[j]] > mx)
                    mx = cnt[fr = a[j]];
            ans[q[i].id] = mx > (q[i].r - q[i].l + 1) / 2 ? fr : 0;
            for(int j = q[i].l; j <= q[i].r; ++j) --cnt[a[j]];
            mx = 0; fr = 0;
            continue;
        }
        while(r < q[i].r) {
            if(++cnt[a[++r]] > mx)
                mx = cnt[fr = a[r]];
        }
        int lol = l, tmp = mx, ffr = fr;
        while(lol > q[i].l) {
            if(++cnt[a[--lol]] > tmp)
                tmp = cnt[ffr = a[lol]];
        }
        ans[q[i].id] = tmp > (q[i].r - q[i].l + 1) / 2 ? ffr : 0;
        while(lol < l) --cnt[a[lol++]];
    }
    for(int i = 1; i <= m; ++i) printf("%d\n", ans[i]);
    return 0;
}
```

---

## 作者：惟有泪千行 (赞：3)

大家好，我非常喜欢暴力数据结构，于是就用莫队过了这道题。

我们考虑对询问进行离线，然后跑莫队，同时记录出现次数最多为多少，再用$multiset$维护每一个次数对应哪一些种类，对于每一个询问，如果$maxn>((que[i].r-que[i].l+1)/2)$就返回$muliset$里面的值，否则就返回0

具体实现可以看代码（含部分注释）

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 50005
int n,m,a[N],b[N],c[N],len,an[N],ans,ll=1,rr,maxn;
struct question{
	int l,r,id;
}que[N];
inline int read(){
	int x=0;char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return x;
}//快读 
inline bool cmp(question x,question y){
	if(x.l/len==y.l/len)return ((x.l/len)&1)?x.r<y.r:x.r>y.r;
	return x.l<y.l;
}//比较函数 
multiset<int>s[N];
inline void add(int x){
	s[b[a[x]]].erase(a[x]);
	--c[b[a[x]]],++b[a[x]];
	s[b[a[x]]].insert(a[x]);
	++c[b[a[x]]];
	if(b[a[x]]>maxn)++maxn;//如果超过了最大值就更新最大值 
}
inline void del(int x){
	s[b[a[x]]].erase(a[x]);
	--c[b[a[x]]],--b[a[x]];
	s[b[a[x]]].insert(a[x]);
	++c[b[a[x]]];
	if(b[a[x]]+1==maxn)maxn-=(c[b[a[x]]+1]==0);//如果最大值消失,就--（因为此时b[a[x]]为最大值）
}
int main(){
	n=read(),m=read(),len=sqrt(n);
	for(int i=1;i<=n;++i)a[i]=read();
	for(int i=1;i<=m;++i)que[i].l=read(),que[i].r=read(),que[i].id=i;
	sort(que+1,que+m+1,cmp);
	for(int i=1;i<=n;++i)s[0].insert(a[i]),++c[0];//注意一定在开始时要加入，否则会RE 
	for(int i=1;i<=m;++i){
		while(ll>que[i].l)add(--ll);
		while(rr<que[i].r)add(++rr);
		while(ll<que[i].l)del(ll++);
		while(rr>que[i].r)del(rr--);//莫队正常操作 
		an[que[i].id]=(maxn>((que[i].r-que[i].l+1)/2))?(s[maxn].empty()?0:*s[maxn].begin()):0;//判断是否有解 
	}
	for(int i=1;i<=m;++i)printf("%d\n",an[i]);
	return 0;
}
```

复杂度$\mathcal{O}(n\sqrt n\log n)$能过

据说正解是主席树，大家可以自行思考（好像更好写？

---

## 作者：ncwzdlsd (赞：2)

简化一下题意，其实就是要求区间众数，且区间众数数量必须过半。显然对于这样的区间询问，我们可以使用权值线段树来处理。看到题解区里的大佬还有用前缀和或莫队或随机化处理的，但是因为蒟蒻不会所以这里用简单好懂的可持久化线段树来处理 qwq。

我们先熟练地打出一套可持久化权值线段树的板子，在输入过程中不断插入，然后在查询区间众数的时候利用分治的思想，如果左右两边的某一边出现次数大于总次数的一半，那么就在该区间上继续查找，否则就去另一区间查找。

需要用到离散化处理每个点的权值，代码实现也比较简单，基本上就是板子，如果对可持久化线段树掌握得不太熟练的可以去看看可持久化线段树的两个模板题。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn=1e6+5;
int rr[maxn],c[maxn],b[maxn],cnt;

struct node
{
	int ls,rs,v;
}t[maxn];

int build(int l,int r)
{
	int id=++cnt;
	t[id].v=0;
	if(l==r) return id;
	int mid=(l+r)/2;
	t[id].ls=build(l,mid);
	t[id].rs=build(mid+1,r);
	return id;
} 

void update(int now,int pre,int l,int r,int k)
{
	t[now].ls=t[pre].ls,t[now].rs=t[pre].rs,t[now].v=t[pre].v+1;
	if(l==r) return;
	int mid=(l+r)/2;
	if(k<=mid) t[now].ls=++cnt,update(t[now].ls,t[pre].ls,l,mid,k);
	else t[now].rs=++cnt,update(t[now].rs,t[pre].rs,mid+1,r,k);
	t[now].v=t[t[now].ls].v+t[t[now].rs].v;
}

int query(int u,int v,int k,int l,int r)
{
	if(l>=r) return b[l];
	int ll=abs(t[t[v].ls].v-t[t[u].ls].v),rr=abs(t[t[v].rs].v-t[t[u].rs].v);
	int mid=(l+r)/2;
	if(ll>k) return query(t[u].ls,t[v].ls,k,l,mid);
	if(rr>k) return query(t[u].rs,t[v].rs,k,mid+1,r);
	return 0;
}

int main()
{
	int n,m;cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>c[i],b[i]=c[i];
	sort(b+1,b+n+1);
	int mm=unique(b+1,b+n+1)-b-1;rr[0]=build(1,mm);
	for(int i=1;i<=n;i++) 
		c[i]=lower_bound(b+1,b+mm+1,c[i])-b,rr[i]=++cnt,update(rr[i],rr[i-1],1,mm,c[i]);
	while(m--)
	{
		int s,t;cin>>s>>t;
		cout<<query(rr[s-1],rr[t],(t-s+1)/2,1,mm)<<endl;
	}
	return 0;
}

```

---

## 作者：Elma_ (赞：2)

主席树模板题打卡

先把每个数插进主席树，查询的时候判断众数在左边还是在右边。显然如果左边出现次数大于一半就在左边，否则就在右边。

需要离散化，代码和静态区间第 k 小没什么区别。

```cpp
#include <map>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define ll long long
using namespace std;

inline int read() {
	int x = 0, w = 1;char ch = getchar();
	while (ch > '9' || ch < '0') { if (ch == '-')w = -1;ch = getchar(); }
	while (ch >= '0' && ch <= '9')x = x * 10 + ch - '0', ch = getchar();
	return x * w;
}
inline void write(int x) {
    if (x < 0) putchar('-'), x = -x;
    if (x > 9) write(x / 10);
    putchar(x % 10 + '0');
}

const int maxn = 1e6 + 5;
const int mod = 1e9 + 7;
const int inf = 1e9;

inline int min(int x, int y) { return x < y ? x : y; }
inline int max(int x, int y) { return x > y ? x : y; }

struct node {
    int val, lson, rson;
} tree[maxn << 6];
int a[maxn], root[maxn], pos[maxn], tmp[maxn], b[maxn];
int n, m, cnt = 1, tot;

#define ls(x) tree[x].lson
#define rs(x) tree[x].rson
#define val(x) tree[x].val
inline void pushup(int x) {
    val(x) = val(ls(x)) + val(rs(x));
}
inline void build(int x, int l, int r) {
    val(x) = 0;
    if (l != r) {
    	ls(x) = ++cnt, rs(x) = ++cnt;
    	int mid = (l + r) >> 1;
    	build(ls(x), l, mid);
    	build(rs(x), mid + 1, r);
	}
}
inline void modify(int x, int pre, int to, int l, int r) {
    ls(x) = ls(pre), rs(x) = rs(pre), val(x) = val(pre) + 1;
    if (l == r) return;
    int mid = (l + r) >> 1;
    if (to <= mid) ls(x) = ++cnt, modify(ls(x), ls(pre), to, l, mid);
    else rs(x) = ++cnt, modify(rs(x), rs(pre), to, mid + 1, r);
    pushup(x);
}
inline int query(int ql, int qr, int l, int r, int k) {
    if (l >= r) return b[l];
    int L = val(ls(qr)) - val(ls(ql)), R = val(rs(qr)) - val(rs(ql));
    int mid = (l + r) >> 1;
    if (L > k) return query(ls(ql), ls(qr), l, mid, k);
    if (R > k) return query(rs(ql), rs(qr), mid + 1, r, k);
    return 0;
}
#undef ls(x)
#undef rs(x)
#undef val(x)
 
inline void init() {
	for (int i = 1;i <= n;i++) b[i] = a[i];
    sort(b + 1, b + n + 1); tot = unique(b + 1, b + n + 1) - b - 1;
    for (int i = 1;i <= n;i++) tmp[i] = lower_bound(b + 1, b + tot + 1, a[i]) - b;
}

int main(void) {
    n = read(), m = read();
    for (int i = 1;i <= n;i++) a[i] = read();
    init(), root[0] = 1, build(1, 1, tot);
    for (int i = 1;i <= n;i++) {
    	root[i] = ++cnt;
    	modify(root[i], root[i - 1], tmp[i], 1, tot);
	}
	while (m--) {
		int l = read(), r = read();
		printf("%d\n", query(root[l - 1], root[r], 1, tot, (r - l + 1) >> 1));
	}
	return 0;
}
```


---

## 作者：西瓜nd (赞：0)

## 题意简述

求区间严格大于区间长度一半的众数，若不存在则输出0。

~~这不就主席树模板题嘛~~


## 题目分析

求区间众数，其实可以很容易想到主席树（即可持久化权值线段树，不会的可以先去看看模板题[P3834](https://www.luogu.com.cn/problem/P3834)）。这里稍微讲一下主席树的基本思想，从左到右每插入一个数 $a_i$ 就产生一个版本的权值线段树 $T_i$ ，权值线段树每个节点上记录一个值 $sum$ ，表示该节点对应值域 $[L,R]$ 一共插入过多少数，即在此版本的权值线段树 $T_i$ 中值域区间 $[L,R]$ 里有多少个数。处理完所有数后，用类似前缀和的操作将 $T_R$ 的 $sum$ 减去 $T_{L-1}$ 的 $sum$ ，即可求出值域区间 $[L,R]$ 的数的个数。

基于以上主席树处理区间第 k 小问题的基本思想，我们已经能求出任意区间的数的个数，但题目要求的是区间严格大于区间长度一半的众数，这要怎么做呢？

其实很简单，对于一个权值线段树的节点，如果左儿子的数的个数比总数一半大，那么满足条件的众数就可能在左儿子里（也可能没有），此时再递归找左儿子，右儿子也同理。如果左右儿子的数的个数都比总数一半小，那显然左右儿子都不存在满足条件的众数。

要注意一点，当一个节点的左儿子满足条件时，众数不一定在左儿子里，右儿子也可能满足条件，所以两边都要判断和递归查找。

主席树更新和查找的时间复杂度都为 $O(n\log n)$ ，总时间复杂度为 $O((n+m)\log n)$ 。


## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=50005;
int n,m,cnt,len,ans;

struct node{
    int ls,rs,sum,zl;
}tree[maxn<<5];
int c[maxn],root[maxn];

//建树
int build(int l,int r){
    int p=++cnt;
    if(l==r){
        tree[p].zl=1;
        return p;
    }
    int mid=(l+r)>>1;
    build(l,mid);
    build(mid+1,r);

    return p;
}

//插入操作
int update(int l,int r,int now,int val){
    int p=++cnt;
    tree[p]=tree[now];
    tree[p].sum++;

    if(l==r)return p;

    int mid=(l+r)>>1;

    if(val<=mid)tree[p].ls=update(l,mid,tree[p].ls,val);
    else tree[p].rs=update(mid+1,r,tree[p].rs,val);

    return p;
}

//询问
void query(int l,int r,int p,int q,int k){
    if(l==r){
        ans=l;
        return;
    }

    int m=(l+r)>>1;

    int lx=tree[tree[p].ls].sum-tree[tree[q].ls].sum;   //值域[l,m]上数的个数
    int rx=tree[tree[p].rs].sum-tree[tree[q].rs].sum;   //值域[m+1,r]上数的个数

    if(lx<=k and rx<=k){    //如果左右儿子的数的个数都比总数一半小，说明该区间上不存在
        ans=0;
        return;
    }

    if(lx>k)query(l,m,tree[p].ls,tree[q].ls,k);     //值域[l,m]上数的个数大于总数一半，就尝试在左边找

    if(rx>k)query(m+1,r,tree[p].rs,tree[q].rs,k);   //值域[m+1,r]上数的个数大于总数一半，就尝试在右边找
}


int main(){
    ios::sync_with_stdio(0);
    cin>>n>>m;
    for(int i=1;i<=n;i++)cin>>c[i],len=max(len,c[i]);

    root[0]=build(1,len);

    for(int i=1;i<=n;i++)root[i]=update(1,len,root[i-1],c[i]);

    while(m--){
        int l,r,k;
        cin>>l>>r;
        k=(r-l+1)>>1;
        query(1,len,root[r],root[l-1],k);
        cout<<ans<<endl;
    }

    return 0;
}

```


---

## 作者：yizhiming (赞：0)

~~我是毒瘤大码量选手。~~

这道题的加强版 [$P3765$](https://www.luogu.com.cn/problem/P3765)，本文主要讲解能过加强版的做法（显然加强版能过，这道题也自然能过）。

## 题面描述

给定长度为 $n$ 的序列 $c$，$m$ 次查询区间严格众数（出现次数严格大于区间长度的一半）。

$1\leq n,m,c_i \leq5\times10^4$

## 题目分析

首先我们需要知道一个求严格区间众数的好东西，叫做摩尔投票法（不会这个的转去 [$P2397$](https://www.luogu.com.cn/problem/P2397)），这个东西支持查询严格区间众数，如果当前区间存在严格众数，那么其一定正确，否则可能会是任意数。

但是现在要查询的是区间怎么办呢？我们用线段树维护摩尔投票的合并过程即可，具体做法就是对于每个线段树节点维护区间众数是什么和摩尔投票的值，如果左右儿子众数相同，则合并，值相加，否则取值较大的，值取差。

但是之前说过了，只有存在严格众数时，摩尔投票法才保证正确，所以我们要知道线段树找到的区间众数，其出现次数是否严格大于区间长度的一半，怎么维护呢？我会主席树！然而加强版带修。

我们用一个更为巧妙的数据结构——平衡树，我们对于每种颜色维护一棵平衡树，将 $c_i=x$ 的下标 $i$ 插到 $x$ 这棵平衡树上。

假设当前找到的答案为 $col$，那么就在 $col$ 这棵平衡树上将区间 $[l,r]$ 分裂出来，因为平衡树上的值是下标，所以直接按值分裂出来即可。此时分裂出来的这棵平衡树的大小即为区间内 $col$ 的出现次数。

而且这个显然支持修改，我们直接维护每个值属于哪棵平衡树，修改时在原树上删掉它，然后再把它加入到新树上即可。

## Code

这部分代码删去了加强版的修改，能够通过此题，修改按照加强版说的直接维护即可。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <queue>
#include <cmath>
using namespace std;
int read(){
	int x=0,f=1;char ch = getchar();
	while(ch<'0'||ch>'9'){if(ch=='-'){f=-1;}ch = getchar();}
	while(ch>='0'&&ch<='9'){x = x*10+ch-'0';ch = getchar();}
	return x*f;
}
const int N = 5e5+5;
struct aa{
	int lc,rc,cnt,val;
}tree[N*2];
aa pushup(aa ls,aa rs){
	aa res;
	if(ls.val==rs.val){
		res.val = ls.val;
		res.cnt = ls.cnt+rs.cnt;
	}else if(ls.cnt>=rs.cnt){
		res.val = ls.val;
		res.cnt = ls.cnt-rs.cnt;
	}else{
		res.val = rs.val;
		res.cnt = rs.cnt-ls.cnt;
	}
	return res;
}
void up(int u){
	int ls = tree[u].lc,rs = tree[u].rc;
	tree[u] = pushup(tree[ls],tree[rs]);
	tree[u].lc = ls;tree[u].rc = rs;
}
int tote = 1;
int a[N];
void build(int u,int l,int r){
	if(l==r){
		tree[u].val = a[l];
		tree[u].cnt = 1;
		return;
	}
	int mid = (l+r)/2;
	tree[u].lc = ++tote;
	build(tote,l,mid);
	tree[u].rc = ++tote;
	build(tote,mid+1,r);
	up(u); 
}
void upd(int u,int l,int r,int p,int x){
	if(l==r){
		tree[u].val = x;
		tree[u].cnt = 1;
		return;
	}
	int mid = (l+r)/2;
	if(p<=mid){
		upd(tree[u].lc,l,mid,p,x);
	}else{
		upd(tree[u].rc,mid+1,r,p,x);
	}
	up(u);
}
aa query(int u,int l,int r,int ll,int rr){
	if(l==ll&&r==rr){
		return tree[u];
	}
	int mid = (l+r)/2;
	if(rr<=mid){
		return query(tree[u].lc,l,mid,ll,rr);
	}else if(ll>mid){
		return query(tree[u].rc,mid+1,r,ll,rr);
	}else{
		return pushup(query(tree[u].lc,l,mid,ll,mid),query(tree[u].rc,mid+1,r,mid+1,rr));
	}
}
int rt[N];
struct bb{
	int lc,rc,val,siz,rnd;
	void clear(){
		lc = rc = val = rnd = siz = 0;
	}
}node[N*2];
void pus(int u){
	node[u].siz = node[node[u].lc].siz+node[node[u].rc].siz+1;
} 
int tot;
int sta[N*2],top;
int newnode(int val){
	int u;
	if(top){
		u = sta[top--];
		node[u].clear();
	}else{
		u = ++tot;
	}
	node[u].val = val;
	node[u].rnd = rand();
	node[u].siz = 1;
	return u;
}
void split(int u,int val,int &x,int &y){
	if(!u){
		x = 0;y = 0;
		return;
	}
	if(node[u].val<=val){
		x = u;
		split(node[u].rc,val,node[u].rc,y);
	}else{
		y = u;
		split(node[u].lc,val,x,node[u].lc);
	}
	pus(u);
}
int merge(int u,int v){
	if(!u||!v){
		return u+v;
	}
	if(node[u].rnd>node[v].rnd){
		node[u].rc = merge(node[u].rc,v);
		pus(u);
		return u;
	}else{
		node[v].lc = merge(u,node[v].lc);
		pus(v);
		return v;
	}
}
int x,y,z;
void ins(int ver,int val){
	split(rt[ver],val,x,y);
	rt[ver] = merge(merge(x,newnode(val)),y);
}
void del(int ver,int val){
	split(rt[ver],val,x,z);
	split(x,val-1,x,y);
	sta[++top] = y;
	y = merge(node[y].lc,node[y].rc);
	rt[ver] = merge(merge(x,y),z);
}
int n,m;
int ask(int l,int r){
	int id = query(1,1,n,l,r).val;
	split(rt[id],l-1,x,y);
	split(y,r,y,z);
	int len = node[y].siz;
	rt[id] = merge(merge(x,y),z);
	if(len>(r-l+1)/2){
		return id;
	}else{
		return -1;
	}
}
void add(int u,int v){
	del(a[u],u);
	a[u] = v;
	ins(v,u);
	upd(1,1,n,u,v);
}
int main(){
	n = read();m = read();
	for(int i=1;i<=n;i++){
		a[i] = read();
		ins(a[i],i);
	} 
	build(1,1,n);
	int l,r;
	while(m--){
		l = read();r = read();
		int u = ask(l,r);
		if(u==-1){
			cout<<0<<"\n";
		}else{
			cout<<u<<"\n";
		}
	}
	return 0;
}

```

貌似还可以拿分块/莫队玩这个题。

---


# [省选联考 2021 A/B 卷] 卡牌游戏

## 题目描述

Alice 有 $n$ 张卡牌，第 $i$（$1 \le i \le n$）张卡牌的正面有数字 $a_i$，背面有数字 $b_i$，初始时所有卡牌正面朝上。

现在 Alice 可以将不超过 $m$ 张卡牌翻面，即由正面朝上改为背面朝上。Alice 的目标是让最终朝上的 $n$ 个数字的极差（最大值与最小值的差）尽量小。请你帮 Alice 算一算极差的最小值是多少。

## 说明/提示

**【样例 #1 解释】**

最优方案之一：将第 $1, 5, 6$ 张卡牌翻面，最终朝上的数字依次为 $10, 11, 13, 14, 6, 7$，极差为 $14 - 6 = 8$。

---

**【数据范围】**

对于所有测试数据：$3 \le n \le {10}^6$，$1 \le m < n$，$1 \le a_i, b_i \le {10}^9$。

每个测试点的具体限制见下表：

| 测试点编号 | $n \le$ | 特殊限制 |
|:-:|:-:|:-:|
| $1 \sim 2$ | $10$ | 无 |
| $3 \sim 4$ | $500$ | 无 |
| $5 \sim 6$ | $5 \times {10}^5$ | $m \le 1000$ |
| $7$ | ${10}^5$ | 无 |
| $8$ | $4 \times {10}^5$ | 无 |
| $9$ | $7 \times {10}^5$ | 无 |
| $10$ | ${10}^6$ | 无 |

## 样例 #1

### 输入

```
6 3
8 11 13 14 16 19
10 18 2 3 6 7
```

### 输出

```
8
```

## 样例 #2

### 输入

```
见附件中的 card/card2.in。```

### 输出

```
见附件中的 card/card2.ans。```

## 样例 #3

### 输入

```
见附件中的 card/card3.in。```

### 输出

```
见附件中的 card/card3.ans。```

# 题解

## 作者：AuCloud (赞：64)

~~来自一个考场上被自己一顿阴间操作把D1T1正解文件搞没了的sb~~

提供思路，不一定正确，欢迎各大佬hack（~~但是过了民间数据~~

对所有的值按大小排序，不论 $a$ 面 $b$ 面

记录每个值对应是 $a$ 面或者 $b$ 面

于是现在我们得到了一个长度为 $2N$ 的序列。

显然我们的答案就是这个序列的某个子序列两端的差值

具体求可以用双指针——我们可以删除前面一段和后面一段，要求是

- 删除的 $a$ 面总数不能超过要求

- 不能同时删除同一张卡的两面

对于第一条就拿个变量动态记录一下删了多少个就好

第二条开个桶维护就好

总时间复杂度$O(N\log N)$，瓶颈在排序

代码如下

```cpp
#include <bits/stdc++.h>
using namespace std;
struct hehe{
	long long a, num;
	int op;
	bool operator < (hehe b) const
	{
		return a < b.a;
	}
}a[2000001];
bool used[2000001];
int main()
{
	// freopen("card3.in", "r", stdin);
	int n, k;
	cin >> n >> k;
	for(int i = 1; i <= n; i++)
	{
		scanf("%d", &a[i].a);
		a[i].num = i;
		a[i].op = 1;
	}
	for(int i = 1; i <= n; i++)
	{
		scanf("%d", &a[n + i].a);
		a[i + n].num = i;
		a[i].op = 1;
	}
	sort(a + 1, a + n * 2 + 1);
	int l = 0, r = n * 2 + 1, now = 0;
	while(!used[a[l + 1].num] && now + a[l + 1].op <= k) now += a[l + 1].op, used[a[l + 1].num] = 1, l++;
	while(!used[a[r - 1].num] && now + a[r - 1].op <= k) now += a[r - 1].op, used[a[r - 1].num] = 1, r--;
	long long ans = 1000000000000;
	while(l >= 0)
	{
		ans = min(a[r - 1].a - a[l + 1].a, ans);
		used[a[l].num] = 0;
		now -= a[l].op;
		l--;
		while(!used[a[r - 1].num] && now + a[r - 1].op <= k) now += a[r - 1].op, used[a[r - 1].num] = 1, r--;

	}
	cout << ans << endl;
}

```

~~碎碎念：亲手把自己送出省队，我现在心态良好~~

---

## 作者：intel_core (赞：63)

首先不难发现这个题满足答案单调性   
现在考虑 $\text{check}$ 一个答案 $x$    
如果我们选定了值域区间的左端点，那么右端点就可以很简单的确定    
在这个基础上， $a_i$ 在选定范围内的卡牌就不用翻了   
所以其他的卡牌就需要进行翻面，并且对应的 $b$ 值必须在选定的范围内，否则跳过       
所以现在变成了查询 $b_i$ 的前后缀 $\text{RMQ}$    
总复杂度是 $O(nlogn)$ 的， $\text{i5-4590@3.3GHz}$ 可以做到 $\text{1s}$ 

---

## 作者：yzc2005 (赞：23)

提供一个线性做法（p.s. 不保证不 fst，即不保证正确性（

容易发现翻转的一定是一个前缀加一个后缀，而且在前缀中如果存在 $a_i>b_i$ 或在后缀中存在 $a_i<b_i$ 则一定不优。

于是假设前缀翻转到了 $i$，后缀翻转到了 $j$。特判 $m=n$ 的情况，则答案就是
$$
\max\{a_{j-1},\max(b_1,b_2,\cdots,b_i),\max(b_j,b_{j+1},\cdots,b_n)\}-\min\{a_{i+1},\min(b_1,b_2,\cdots,b_i),\min(b_{j},b_{j+1},\cdots,b_n)\}
$$
不妨令 
$$
l_i=\min\{a_{i+1},\min(b_1,b_2,\cdots,b_i)\}
$$
$$
r_i=\max(b_1,b_2,\cdots,b_i)
$$
$$
l'_i=\min(b_j,b_{j+1},\cdots,b_n)\ (j=n-i+1)
$$
$$
r'_i=\max\{a_{j-1},,\max(b_j,b_{j+1},\cdots,b_n)\}\ (j=n-i+1)
$$
则问题可以转化成求出
$$
\min\{\max(r_i,r'_j)-\min(l_i,l_j')\ |\ i+j\le m\}
$$
注意到 $r$ 单调不减，因此对于某个 $i$，如果存在 $j<i$ 使得 $l_j>l_i$，则选 $j$ 一定比选 $i$ 优。因此我们可以只取 $l$ 的前缀最大值，使得 $l$ 也单调不减。

同理可以得到 $l',r'$ 单调不增。

不妨从小到大枚举 $[l_i,r_i]$。注意到很强的单调性，除去两区间形成包含关系的情况，一定是取最大的 $r'_j\le r_i$ 或者最小的 $l'_j\ge l_i$，注意到这些端点也都是单调的，因此可以用指针扫。区间包含的情况可以再处理一遍 $l',r'$ 解决。  



---

## 作者：KaisuoShutong (赞：19)

**UPD：感谢 @[A_OI](https://www.luogu.com.cn/user/157781) 提供的两组 hack，已修复程序中的细节问题。**

来发一个非常好想但是有一点细节的题解。

首先我们会发现，如果序列按 $a$ 升序排列，那么翻转的数组一定只会是最前边的一段和最后面的一段。  
设 $1-i,j-n$ 被翻转（$i<j$），那么答案即为：
$$max(a_{j-1},max_b)-min(a_{i+1},min_b)$$

因为这是两个限制，不是很好做，所以我们考虑枚举前面的一段翻转了多长。  
不妨枚举 $i$，我们设：
$$mn(i)=min(b_{i-n}),mx(i)=max(b_{i-n})$$
$$MAXB=max_{b_{1-i}},MINB=min(a_{i+1},min_{b_{1-i}})$$

考虑对于所有的合法 $j$，维护答案最大值。  
答案的构成是一个最大值减一个最小值的形式，我们不妨先不管最小值，考虑最大值的极值。  
简化答案表达式，我们有：
$$max(a_{j-1},MAXB,mx(j))-min(MINB,mn(j))$$

显然可以观察到，对于 $mx$ 来说，其为递减函数，对于 $a$，其为递增函数。

那么它们一定构成如下情况：
![](https://cdn.luogu.com.cn/upload/image_hosting/ues6i6lo.png)
其中红色为凸壳部分（也就是最优解）。

考虑用 $MAXB$ 的线去截这个图形，有两种可能。

第一种，在交点下面。
![](https://cdn.luogu.com.cn/upload/image_hosting/uol7b21q.png)
那么凸壳没有变化。

第二种，在交点上面。
![](https://cdn.luogu.com.cn/upload/image_hosting/z6vemc48.png)
此时多出了一段。

总结一下，有两种情况：
1. 最大值与 $j$ 的取值无关，为 $MAXB$ 。体现在图中就是第二种情况的横线部分。
2. 最大值与 $j$ 的取值有关，为 $max(a_{j-1},mx(j))$。体现在图中就是两种斜线条。

同理最小值也有两种情况。
1. 无关，为 $MINB$。
2. 有关，为 $mn(j)$。

那么对这四种情况分类讨论即可。

因为有区间 $max/min$，所以还得用一个 $ST$ 表。  
具体地，我们维护：
1. $max(a_{j-1},mx(j))$ 的最小值。
2. $max(a_{j-1},mx(j))-mn(j)$ 的最小值。

再用 $lower\_bound$ 函数求出几个转折点的位置，即可通过此题。
因为使用的数据结构和算法比较简单，所以是小常数 $O(n\cdot logn)$。

细节有一点多，~~省选的时候多亏 CQ 地区停电 20 分钟让我在草稿纸上理清了思路~~。

附上有点丑的考场代码（好像我还是手写的二分）。

总体就这么多，点个赞再走吧。

另：附上 hack 数据查出的细节错误。  
代码中 `int px=erf(a,i+2,n,bmx);`，因为对于 $i$ 来说，我们取的是 $a_{i-1}$，所以应该改为 `int px=erf(a,i+1,n,bmx);`。



```cpp
#include<bits/stdc++.h>
using namespace std;
int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
	return s*w;
}
const int maxn = 1000010;
int erf(int*a,int l,int r,int vl)
{
	int mid,ans=r+1;
	while(l<=r)
	{
		if(a[mid=l+r>>1]>vl) r=(ans=mid)-1;
		else l=mid+1;
	}
	return ans;
}
int erfs(int*a,int l,int r,int vl)
{
	int mid,ans=l-1;
	while(l<=r)
	{
		if(a[mid=l+r>>1]>vl) l=(ans=mid)+1;
		else r=mid-1;
	}
	return ans;
}
int n,m,a[maxn],b[maxn],mx[maxn],mn[maxn],ans;
int fa[21][maxn],fa2[21][maxn];
int tt,Lg[maxn],pw[maxn];
int askmax(int x,int y)
{
	tt=Lg[y-x+1];
	return min(fa[tt][x],fa[tt][y-pw[tt]+1]);
}
int askdel(int x,int y)
{
	tt=Lg[y-x+1];
	return min(fa2[tt][x],fa2[tt][y-pw[tt]+1]);
}
void ST()
{
	for(int i=1;i<=n;i++) fa[0][i]=max(a[i-1],mx[i]);
	for(int i=1;pw[i]<=n;i++)
		for(int j=1;j+pw[i]<=n+1;j++) fa[i][j]=min(fa[i-1][j],fa[i-1][j+pw[i-1]]);

	for(int i=1;i<=n;i++) fa2[0][i]=max(a[i-1],mx[i])-mn[i];
	for(int i=1;pw[i]<=n;i++)
		for(int j=1;j+pw[i]<=n+1;j++) fa2[i][j]=min(fa2[i-1][j],fa2[i-1][j+pw[i-1]]);
}
signed main()
{
	n=read(),m=read();
	pw[0]=1;for(int i=1;(pw[i]=pw[i-1]*2)<=n;i++);
	Lg[0]=-1;for(int i=1;i<=n;i++) Lg[i]=Lg[i>>1]+1;
	for(int i=1;i<=n;i++) a[i]=read();
	for(int i=1;i<=n;i++) b[i]=read();
	mx[n+1]=0,mn[n+1]=0x3f3f3f3f;
	for(int i=n;i;i--) mx[i]=max(b[i],mx[i+1]),
					   mn[i]=min(b[i],mn[i+1]);
	a[0]=0x3f3f3f3f;
	ST();
	ans=a[n]-a[1];
	if(n==m) ans=min(ans,mx[1]-mn[1]);
	for(int i=0,bmx=0,bmnn=0x3f3f3f3f,lft;i<=m;i++)
	{
		lft=n-(m-i)+1;
		if(i) bmx=max(bmx,b[i]);
		if(i) bmnn=min(bmnn,b[i]);
		int bmn=min(bmnn,a[i+1]);
		ans=min(ans,max(bmx,a[n])-bmn);
		int px=erf(a,i+1,n,bmx);//px+1以及后面的都是ai更大 
		int vx=erfs(mx,i+2,n,bmx);//vx以及以前的都是mxi更大 
		int pn=erf(mn,i+2,n,bmn);//pn以及之后都是bmn更大 
		int L,R;
		if(vx+1<=px)
		{
			L=vx+1,R=px;
			L=max(L,lft);
			if(L<=R)
			{
				if(pn<=R) ans=min(ans,bmx-bmn);
				if(L<pn) ans=min(ans,bmx-mn[min(pn-1,R)]);
			}
			L=i+2,R=vx;
			L=max(L,lft);
			if(L<=R)
			{
				if(pn<=R) ans=min(ans,askmax(max(pn,L),R)-bmn);
				if(L<pn) ans=min(ans,askdel(L,min(pn-1,R)));
			}
			L=px+1,R=n;
			L=max(L,lft);
			if(L<=R)
			{
				if(pn<=R) ans=min(ans,askmax(max(pn,L),R)-bmn);
				if(L<pn) ans=min(ans,askdel(L,min(pn-1,R)));
			}
		}
		else
		{
			L=i+2,R=n;
			L=max(L,lft);
			if(L<=R)
			{
				if(pn<=R) ans=min(ans,askmax(max(pn,L),R)-bmn);
				if(L<pn) ans=min(ans,askdel(L,min(pn-1,R)));
			}
		}
	}
	cout<<ans<<'\n';
	return 0;
}

```

---

## 作者：VinstaG173 (赞：16)

没去省选。

首先我个人感觉翻面对极差的影响其实不好处理（可能是我比较菜），想到极差是最大值减最小值，于是想到把所有 $a,b$ 放一起排序然后把一种合法的翻面方案转化成排序后的一段连续区间。

连续区间就很好处理了，必定是前面去掉一段后面去掉一段，并且去掉的数不能有超过 $m$ 个属于 A，也不能有两个属于同一张牌。

容易发现当合法区间的左端点右移时，右端点不可能左移。所以可以使用双指针维护左右端点，时间复杂度 $O(n)$。但是由于有排序的存在，所以总的时间复杂度是 $O(n\log{n})$ 的。

非常好写，跑得也不慢。

Code:
```cpp
#include<cstdio>
#include<algorithm>
#define rg register
using std::sort;
struct emt
{
	int val,typ,num;
}x[2000003];
inline bool cmp(emt a,emt b)
{
	return a.val<b.val;
}
int n,m;
int l,r;
int ans=1e9,tms;
int cnt[1000003];
int main()
{
	scanf(" %d %d",&n,&m);
	for(rg int i=0;i<n;++i)scanf(" %d",&(x[i].val)),x[i].typ=1,x[i].num=i;
	for(rg int i=0;i<n;++i)scanf(" %d",&(x[i+n].val)),x[i+n].typ=0,x[i+n].num=i;
	n<<=1,l=0,sort(x,x+n,cmp);
	for(r=n-1;r>-1;--r)
	{
		if(cnt[x[r].num]||(tms==m&&x[r].typ))break;
		++cnt[x[r].num],tms+=x[r].typ;
	}
	for(;l<n;++l)
	{
		if(x[r].val-x[l].val<ans)ans=x[r].val-x[l].val;
		++cnt[x[l].num],tms+=x[l].typ;
		while(r<n&&(cnt[x[l].num]>1||tms>m))++r,--cnt[x[r].num],tms-=x[r].typ;
		if(r==n)break;
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Dyd本人 (赞：12)

# 一个 $O(n)$ 的做法 
我们可以发现因为 $a$ 是单调递增的，所以对于第 $i$ 张牌，如果它前面有没翻的牌，辣么我们即使翻了它，它对于最小值是没有贡献的，具体如下：  

1. 如果 $b_i>a_i$ ，因为一定存在 $j<i$ 使 $a_j<a_i$ ，故最小值不变。
1. 如果 $b_i<a_i$ ，最小值不增反减，这对答案无贡献。

综上，若翻 $a_i$ 对最小值有贡献，当且仅当第 $i$ 张牌之前的所有牌都翻过。  
这启发了我们，我们发现可以扫一遍所有卡，当我们决定翻牌 $i$ 来更新**最小值**时（此时一定是 $i$ 之前的牌都翻了，且 $b_i>a_i$ ），有以下情况（不妨把最小值记为 $l$ ，最大值记为 $r$ ）：

1. 若 $b_i<r$ 说明翻后只需更新 $l$ ， $l$ 更新为 $b_i$ 、 $a_{i+1}$ 、以及 $i$ 之前的所有牌（注意它们已翻过了）中的最小值。
1. 若 $b_i>r$ 此时**可能**需要同时更新 $r$ 和 $l$ ，我们先判断更新后答案是否更优，若是，则更新 $r$ 为 $b_i$ ， $l$ 为 $a_{i+1}$ 、以及 $i$ 之前的所有牌（注意它们已翻过了）中的最小值。

同理，我们可以用同样的方法更新**最大值**。但需要注意，翻牌次数是有限的，所以我们应**同时**计算最大和最小，每次选取其更优的更新（本人是用头尾指针完成的），当头尾指针非法（头大于尾）或翻牌次数用尽时停止。  
而还有一个优化是，用一个 $minn$ 来储存**当前节点（头指针）之前的所有牌的背面的最小值**（因为 $minn$ 是用来更新当前节点，而当前节点会更新，即翻面，的前提是之前的所有牌都翻面），同理用 $maxn$ 来储存**当前节点（尾指针）之后的所有牌的背面的最大值**，这样计算时就不必再扫描，只需在最后做出决策（更新最大还是更新最小）时同时更新对应的 $maxn$ 或 $minn$ 就好了。  
最终时间复杂度为 $O(n)$ 。  
贴代码：
```cpp
#include<iostream>
#include<cmath>
#include<cstring>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
using namespace std;
const int N=1e6+5;
int n,m;
int a[N],b[N];
int minn,maxn;
int l,r,l2,r2,l3,r3,h,t;		//l：最小值， r：最大值
								//l2、r2：更新最小值的情况下l和r的值
								//l3、r3：更新最大值的情况下l和r的值
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i) scanf("%d",&a[i]);
	for(int i=1;i<=n;++i) scanf("%d",&b[i]);
	l=a[1],r=a[n];
	minn=1e9,maxn=-1e9;		//初始时第1张牌前没牌，minn=INF
							//第n张牌后没牌，maxn=-INF 
	h=1,t=n;
	while(h<t&&m>0){
		l2=l,r2=r;
		l3=l,r3=r;
		m--;
		if(a[h]==l&&b[h]>a[h]){
			if(b[h]<r)
				l2=min(min(b[h],minn),a[h+1]);
			else if(b[h]-min(minn,a[h+1])<r-l) l2=min(minn,a[h+1]),r2=b[h];
		}
		if(a[t]==r&&b[t]<a[t]){
			if(b[t]>l) 
				r3=max(max(b[t],maxn),a[t-1]);
			else if(max(maxn,a[t-1])-b[t]<r-l) r3=max(maxn,a[t-1]),l3=b[t];
		}
		if(r2-l2<r3-l3){
			minn=min(minn,b[h]);
			h++;
			r=r2,l=l2;
		}
		else{
			maxn=max(maxn,b[t]);
			t--;
			r=r3,l=l3;
		}
	}
	printf("%d",r-l);
    return 0;
}
```


------------
写在最后：本人灰常弱鸡，如果有说的不对的地方还请指出，不胜感激！

---

## 作者：phigy (赞：11)

最大值和最小值自然就想到双指针 。

那么就将 $a$ 和 $b$ 数组合并为 $c$ 后排一个序 。

再在 $c$ 上双指针 。

如何判断是否可以在翻不超过 $m$ 次下是所有的牌不超过 $r$ 不小于 $l$ 。

可以枚举一遍如果正面不在范围内就翻，如果翻了还不在就不可能，记录翻的次数 。

这种方法是 $O(n^2)$ 的 。

然后因为 $a$ 是不下降数列 。

所以翻的一定是左边一段和右边一段 。

二分找到段长 。

再看两段长是否超过 $m$ 。

并且两端中 $b$ 的最大最小值是否超过了范围 。

所以预处理前缀后缀的最大最小 。

复杂度 $O(n\log n)$ 。

复杂度在于二分 。

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cctype>

#define int long long

using namespace std;

int n,m;
int a[1000005];
int b[1000005];
int c[2000020];

int big1[1000005],big2[1000005];
int sml1[1000005],sml2[1000005];

int read()
{
	char c=getchar();
	int x=0;
	while(!isdigit(c))c=getchar();
	while(isdigit(c))
	{
		x=x*10+c-'0';
		c=getchar();
	}
	return x;
}

int check(int x,int y)
{
	int minn,maxx;
	int l=0,r=n+1;
	while(l+1<r)
	{
		int mid=(l+r)/2;
		if(a[mid]<x)l=mid;
		else r=mid;
	}
	minn=l;
	l=0,r=n+1;
	while(l+1<r)
	{
		int mid=(l+r)/2;
		if(a[mid]<=y)l=mid;
		else r=mid;
	}
	maxx=l;
	if(n-maxx+minn>m)return 0;
	if((big1[minn]>y||sml1[minn]<x)&&minn!=0)return 0;
	if((big2[maxx+1]>y||sml2[maxx+1]<x)&&maxx!=n)return 0;
	return 1;
}

signed main()
{
	int i,j,k;
	cin>>n>>m;
	a[n+1]=99999999999;
	for(i=1;i<=n;i++)cin>>a[i],c[i]=a[i];
	for(i=1;i<=n;i++)cin>>b[i],c[i+n]=b[i];
	sml1[0]=9999999999;
	sml2[n+1]=9999999999;
	for(i=1;i<=n;i++)sml1[i]=min(sml1[i-1],b[i]);
	for(i=1;i<=n;i++)big1[i]=max(big1[i-1],b[i]);
	for(i=n;i>0;i--)sml2[i]=min(sml2[i+1],b[i]);
	for(i=n;i>0;i--)big2[i]=max(big2[i+1],b[i]);
	sort(c+1,c+2*n+1);
	int ans=9999999999;
	for(i=1,j=1;i<=2*n,j<=2*n;)
	{
		if(check(c[i],c[j]))
		{
			ans=min(c[j]-c[i],ans);
			i++;
		}
		else
		{
			j++;
		}
	}
	cout<<ans;
	return 0;
}


```



---

## 作者：_bestow (赞：7)

提供一个与大家都不同的方法。如果假了请提出qwq。

2021联合省选D1T1

先枚举一下最小值在哪个位置，有没有翻。

先考虑没有翻，然后必然在它前面的都需要翻，为了保证它是最小值再维护一个前缀 $\min$。然后后面肯定尽量让大的翻。如果后面一段连续的区间翻了后都大于当前值，并且最大值不会变大（即 $a_i>b_i$），就可以翻（还有一个前提是可以翻那么多次）。容易发现这有单调性，于是可以二分。

然后考虑翻了。就先二分找到哪个前缀需要翻。

如果这个前缀已经越过当前位置，在后面再按同样的方法二分一段后缀即可。如果没有越过，把后面分成两段，分别二分。然后发现直接用同样的方法二分也不会错。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1000005;
const int inf = 1e9;
template <typename T>
void read(T &x) {
    T flag = 1;
    char ch = getchar();
    for (; '0' > ch || ch > '9'; ch = getchar()) if (ch == '-') flag = -1;
    for (x = 0; '0' <= ch && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';
    x *= flag;
}
int n, m, a[MAXN], b[MAXN], ans = 1e9 + 1, pmnb[MAXN], pmxb[MAXN], smnb[MAXN], smxb[MAXN], check[MAXN];
int Find(int l, int r, int x) {
    int ret = 0;
    while (l <= r) {
        int mid = (l + r) >> 1;
        if (a[mid] <= x) ret = mid, l = mid + 1;
        else r = mid - 1;
    }
    return ret;
}
int main() {
    read(n); read(m);
    for (int i = 1; i <= n; i++) read(a[i]);
    for (int i = 1; i <= n; i++) read(b[i]);
	pmnb[0] = smnb[n + 1] = inf + 1;
    pmxb[0] = smxb[n + 1] = 0;
    for (int i = 1; i <= n; i++) pmnb[i] = min(b[i], pmnb[i - 1]), pmxb[i] = max(b[i], pmxb[i - 1]);
    for (int i = n; i >= 1; i--) smnb[i] = min(b[i], smnb[i + 1]), smxb[i] = max(b[i], smxb[i + 1]);
    check[n + 1] = 1;
    for (int i = n; i >= 1; i--) {
    	check[i] = check[i + 1];
    	if (a[i] < b[i]) check[i] = 0;
	}
	for (int i = 1; i <= n; i++) {
        if (a[i] < pmnb[i - 1] && i - 1 <= m) {
            int now = m - (i - 1);
            int l = max(n - now + 1, i + 1), r = n, res = n + 1;
            while (l <= r) {
                int mid = (l + r) >> 1;
                if (smnb[mid] > a[i] && check[mid]) res = mid, r = mid - 1;
                else l = mid + 1;
            }
            int mx = max(pmxb[i - 1], smxb[res]);
            if (res > i + 1) mx = max(mx, a[res - 1]);
            ans = min(ans, mx - a[i]);
        }
    }
    for (int i = n; i >= 1; i--) {
        int pos = Find(1, n, b[i]);
        int now = m;
        if (pos < i) now--;
        if (b[i] <= pmnb[pos] && pos <= now) {
            now -= pos;
            int l = max(max(n - now + 1, pos + 1), i + 1), r = n, res = n + 1;
            while (l <= r) {
                int mid = (l + r) >> 1;
                if (smnb[mid] > b[i] && check[mid]) res = mid, r = mid - 1;
                else l = mid + 1;
            }
            int mx = max(pmxb[pos], smxb[res]);
            if (res == i + 1 && pos < i && now >= n - i) {
                now -= n - i;
                l = max(pos + 1, i - now), r = i - 1, res = i;
                while (l <= r) {
                    int mid = (l + r) >> 1;
                    if (smnb[mid] >= b[i] && check[mid]) res = mid, r = mid - 1;
                    else l = mid + 1;
                }
                mx = max(mx, smxb[res]);
                if (res > pos + 1) mx = max(mx, a[res - 1]);
            } else {
                if (res > pos + 1) {
                	if (res > i + 1) mx = max(mx, a[res - 1]);
                	else if (res - 1 == i * res - 2 > pos) mx = max(mx, a[res - 2]);
                }
            }
            ans = min(ans, mx - b[i]);
        }
    }
    printf("%d\n", ans);
    return 0;
}
}

---

## 作者：MyukiyoMekya (赞：6)

枚举翻完卡牌后的最小值 $min$ ，如果存在一个 $a_i,b_i<min$ ，那么直接 break，否则分 $a_i<b_i$ 和 $a_i>b_i$ 讨论

$a_i<b_i$ 当然是能不翻就不翻，那么搞个能删除的堆 $pq$ 来维护这些的 $\max a_i$ ，当 $a_i<min$ 的时候说明这个卡牌必须翻了，

那么就把他从堆中删了，然后 $L=\max\{L,b_i\}$ ， $m\leftarrow m-1$ ，这部分在 $min$ 为最小值的时候最大值为 $A=\max \{L,pq.top()\}$。

$a_i>b_i$ 那当然是尽量让 $a_i$ 大的翻，那么就以 $a_i$ 为下标建立权值线段树，维护区间 $\max b_i$ 和数的个数，那么就是从 $10^9$ 开始往前 $m$ 个取 $\max b_i$ ，剩下的都是 $a_i$  ，这两个的最大值记为 $trmax$ ，如果出现 $b_i<min$ 那么说明这个卡牌不能翻转，

那就从线段树中删了这个然后 $R=\max \{R,a_i\}$，这部分在 $min$ 为最小值的时候最大值为 $B=\max \{R,trmax\}$。

如果 $m<0$ 那么就 break，否则就 $ans\leftarrow \min\{ans,\max\{A,B\}-min\}$

线段树那个部分下标可以直接用 $i$ ，因为互不相同然后默认排好序了

时间复杂度 $\mathcal O(n\log n)$，开 O2 洛谷极限数据不到 400ms 常数超级小

超级丑的考场代码：

```cpp
#include <bits/stdc++.h>
#define reg register
#define MP std::make_pair
#define ln std::putchar('\n')
#define lsp std::putchar(' ')
#define pb push_back
#define ALL(x) (x).begin(),(x).end()
#define mem(x,y) memset(x,y,sizeof(x))
#define dprintf(x...) fprintf(stderr,x)
template <class t> inline void read(t &s)
{
	s=0;
	reg char c=getchar();
	while(c<'0'||c>'9')c=getchar();
	while(c>='0'&&c<='9')s=(s<<3)+(s<<1)+(c^48),c=getchar();
}
template <class t> inline void write(t x)
{
	if(x<0)std::putchar('-'),x=-x;
	if(!x)return std::putchar('0'),void();
	static signed sta[50],top=0;
	while(x)sta[++top]=(x%10),x/=10;
	while(top)std::putchar(sta[top--]^48);
}
template <class t> inline bool checkmin(t &x,t y){if(x>y)return x=y,1;return 0;}
template <class t> inline bool checkmax(t &x,t y){if(x<y)return x=y,1;return 0;}
inline void setIn(std::string s){freopen(s.c_str(),"r",stdin);}
inline void setOut(std::string s){freopen(s.c_str(),"w",stdout);}
inline void setIO(std::string s){setIn(s+".in"),setOut(s+".out");}
inline int lowbit(int x){return x&(-x);}
const int MaxN=1e6+50;
struct Node
{
	int x,y,idx,nx;
}a[MaxN],b[MaxN],d[MaxN];
struct MINVAL
{
	int val;
	inline bool operator < (const MINVAL &nt) const
	{
		return val<nt.val;
	}
}valu[MaxN<<1];
int n,m,top=0;
inline bool cmp(const Node &a,const Node &b)
{
	return a.y<b.y;
}
int L,R;
namespace PQ
{
	struct PQN
	{
		int val,idx;
		inline bool operator < (const PQN &nt) const
		{
			return nt.val>val;
		}
	};
	std::priority_queue<PQN> Q,D;
	inline void insert(int idx)
	{
		Q.push((PQN){a[idx].x,idx});
	}
	inline void del(int idx)
	{
		D.push((PQN){a[idx].x,idx});
		checkmax(R,a[idx].y),--m;
		while(!Q.empty()&&!D.empty()&&Q.top().val==D.top().val)
			Q.pop(),D.pop();
	}
	inline int top()
	{
		if(!Q.empty())
			return Q.top().val;
		return 0;
	}
}
namespace TR
{
	int a[MaxN<<2],mxb[MaxN<<2],ndn,siz;
	#define lson (u<<1)
	#define rson (u<<1|1)
	inline void modify(int u,int l,int r,int p,int k,int b)
	{
		a[u]+=k;
		if(l==r)
			return mxb[u]=b,void();
		reg int mid=(l+r)>>1;
		p<=mid?modify(lson,l,mid,p,k,b):modify(rson,mid+1,r,p,k,b);
		mxb[u]=std::max(mxb[lson],mxb[rson]);
	}
	inline int kth(int u,int l,int r,int k)
	{
		if(l==r)
			return l;
		reg int mid=(l+r)>>1;
		return k<=a[lson]?kth(lson,l,mid,k):kth(rson,mid+1,r,k-a[lson]);
	}
	inline int query(int u,int l,int r,int ql,int qr)
	{
		if(!u)return 0;
		if(ql<=l&&r<=qr)return mxb[u];
		reg int mid=(l+r)>>1,res=0;
		if(ql<=mid)
			checkmax(res,query(lson,l,mid,ql,qr));
		if(mid<qr)
			checkmax(res,query(rson,mid+1,r,ql,qr));
		return res;
	}
	inline void insert(int idx)
	{
		++siz;
		modify(1,1,n,idx,+1,::a[idx].y);
	}
	inline void del(int idx)
	{
		--siz;
		modify(1,1,n,idx,-1,0);
		checkmax(L,::a[idx].x);
	}
	inline int query()
	{
		if(!siz)return 0;
		reg int mx=0,p=siz-m+1;
		if(p<=1)
			return mxb[1];
		reg int now=kth(1,1,n,p-1);
		checkmax(mx,::a[now].x);
		if(now<n)
			checkmax(mx,query(1,1,n,now+1,n));
		return mx;
	}
}
signed main(void)
{
	setIO("card");
	
	read(n),read(m);
	for(int i=1;i<=n;++i)
		read(a[i].x),a[i].idx=i;
	for(int i=1;i<=n;++i)
		read(a[i].y);
	for(int i=1;i<=n;++i)
		d[i]=b[i]=a[i];
	std::sort(d+1,d+n+1,cmp);
	reg int c=0;
	for(int i=1;i<=n;++i)
		valu[++c]=(MINVAL){a[i].x},valu[++c]=(MINVAL){a[i].y};
	std::sort(valu+1,valu+c+1);
	reg int minlim=1e9+1,ans=1e9+1;
	for(int i=1;i<=n;++i)
		checkmin(minlim,std::max(a[i].x,a[i].y));
	for(int i=1;i<=n;++i)
		if(a[i].x>a[i].y)
			TR::insert(i);
		else
			PQ::insert(i);
	reg int posa=0,posb=0;
	for(int i=1;i<=c&&valu[i].val<=minlim;++i)
	{
		reg int mn=valu[i].val;
		while(posa<n&&d[posa+1].x<d[posa+1].y)++posa;
		while(posb<n&&b[posb+1].x>b[posb+1].y)++posb;
		while(posa<n&&d[posa+1].y<mn)++posa,TR::del(d[posa].idx);
		while(posb<n&&b[posb+1].x<mn)++posb,PQ::del(b[posb].idx);
		if(m<0)
			break;
		reg int res=std::max(L,R);
		checkmax(res,PQ::top());
		checkmax(res,TR::query());
		checkmin(ans,res-mn);
	}
//	dprintf("answer %d\n",ans);
	write(ans),ln;
	return 0;
}


```


---

## 作者：w23c3c3 (赞：5)

感觉这题做法都挺玄学的。/fad

提供一个我自己的思路。

每次从小到大枚举最小值 $l$ ，显然 $l$ 应该在 $a_i,b_i$ 之间选一个。

这时候我们希望正面朝上的数字都比 $l$ 大。（这不一定满足 $l$ 是最小值，但这并不影响）

那么我们确定 $l$ 之后，那么一些牌的形态已经固定了，也就是说某些牌一定被翻（假如有 $k_{swaped}$ 张），某些牌一定不能被翻，某些牌随意。

那么按照贪心策略，我们只需要管不确定的那些牌，按 $a_i$ 从大到小决定要不要翻即可。

朴素实现是 $O(n^2)$ 的。

但是我们只需要求最大值最小，我们来看一下这个有哪些可能。

1. 已经确定翻/不翻中正面朝上的最大值

2. 还未确定的 $k-k_{swaped}$ 大中决定翻/不翻的最小可能的最大值

我们肯定希望这 $k-k_{swaped}$ 个是 $1-n$ 的一个后继，但是可能中间出现过确定被翻的。

为避免出现这种情况，注意到中间出现确定被翻的牌，肯定会使得 $a_i$ 这张牌小的牌不会出现贡献（可以理解为已经有确定的比 $a_i$ 大了，那 $a_i$ 就没必要再翻了）。

所以直接记录确定牌中 $a_i$ 最大的那张牌就可以了，要翻的区间就变成了 $1-n$ 的一个后缀，这是可以直接预处理的。

然后每次枚举到下一个 $l$ 时，都只会有一张牌，也就是你枚举到的一张牌的确定性发生了变化，这也很好维护。

当然在某些牌既得翻又不能翻的时候，直接退出即可。

这个可以 $O(n)$ 解决，至此我们就做完了。

复杂度 $O(n\log n)$，瓶颈在排序。

代码：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
struct node{
	int x,y,z;
	node(int x0=0,int y0=0,int z0=0){x=x0;y=y0;z=z0;}
	int operator<(node u)const{return x<u.x;}
}o,pq[2000001];
int n,k,i,l,r,ans,m,a[1000001],b[1000001],f[1000001],vis[1000001],pos,realpos,che;
int main(){
	scanf("%d%d",&n,&k);
	for(i=1;i<=n;i++)scanf("%d",&a[i]),pq[i]=node(a[i],i,1);
	for(i=1;i<=n;i++)scanf("%d",&b[i]),pq[n+i]=node(b[i],i,0);
	sort(pq+1,pq+2*n+1);
	for(i=n;i>=1;i--)f[i]=max(f[i+1],min(a[i],b[i]));f[n+1]=a[n];   //预处理后缀翻/不翻的最小可能最大值
	ans=a[n]-a[1];
	for(i=1;i<=2*n;i++){
		o=pq[i];
		if(n-k+1<=pos)realpos=pos+1;else realpos=n-k+1;
		ans=min(ans,max(max(m,a[realpos-1]),f[realpos])-o.x);
		pos=max(pos,o.y);
		k-=o.z;
		if(o.z)m=max(m,b[o.y]);else m=max(m,a[o.y]);
		if(k<0)break;
		if(vis[o.y])break;
		vis[o.y]=1;
	}
	printf("%d\n",ans);
}
```

---

## 作者：yzy1 (赞：4)

说一下我在考场上写的思路，不一定正确。

首先，最优策略一定是翻按照正面数字正序排序后的前后缀。

所以，我们可以预处理出只翻第 $1,1 \sim 2,1\sim3,\cdots,1\sim m$ 张牌（即前 $m$ 张）的最大最小值 $LMax(i),LMin(i)$，以及只翻第 $n,n-1\sim n,n -2\sim n,\cdots,n-m+1 \sim n$ 张牌（即后 $m$ 张牌）的最大最小值 $RMax(i), RMin(i)$。特别的，$LMin(0)=RMin(n+1)=a_{1\text{正面}}, LMax(0)=RMax(n+1)=a_{n\text{正面}}$。这部分可以用一个 set 维护，复杂度 $O(m\log m)$。

然后枚举 $i,j$ 表示翻前 $i$ 张和后 $j$ 张。此时的极差

$$F(i,j)=\begin{cases}RMax(j)-LMin(i)&LMax(i)=a_n \wedge RMin(j)=a_1\\\max\{LMax(i),RMax(j)\}-LMin(i)&LMax(i)\ne a_n \wedge RMin(j)=a_1\\RMax(j)-\min\{LMin(i),RMin(j)\}&LMax(i)=a_n \wedge RMin(j)\ne a_1\\\max\{LMax(i),RMax(j)\}-\min\{LMin(i),RMin(j)\}&\text{otherwise}\end{cases}$$

但是这样做的复杂度为 $O(n^2 \log n)$ 太高了过不去，必须优化一下。我们可以用一种类似前缀和的方法维护 $RMax_i-RMin_i$ 的后缀最小值的下标 $P_i$。这样就可以避免枚举 $j$。

上面可能没说清 $P_i$ 的意思。$P_i$ 为满足 $\min_{j=i}^n\{RMax(j)-RMin(j)\}=RMax(P_i)-RMin(P_i)$ 条件的最大值。

此时的答案为：

$$\begin{aligned}\min\limits_{i=0}^m&\{F(i,P_{i+1+n-m})\}\end{aligned}$$

总复杂度 $O((m+n) \log m)$，常数有点大，不过开了 O2 应该能过。

**Upd. 4-11:** 规范化 Latex。

---

## 作者：Light_snow (赞：3)

垃圾福建垫底选手来看看这题。

大家怎么都写带 $log$ 的。

我来说一个线性做法好了。

那么我们考虑枚举 $k$ 作为翻转完的最小值。

那么构造出一个满足条件的操作，我们在 $a_i$ 中查询一个最大的位置使 $a_i < k$ ，那么 $a_1$ 到 $a_i$ 都要进行翻转，且 $b_1$ 到 $b_i > k$，那么这样做的次数是 $i$ 或者 $i - 1$（考虑 $k$ 是 $b$ 且对应的 $a$ 在需要翻转的区间里）的。

那么考虑对这个 $k$ 求出一个最小的最大值$z$，同样的我们在$a_i$中查询一个最小的位置使$a_i > z$，那么$a_i$ 到 $a_n$都要进行翻转，且 $b_i$ 到 $b_n > k$，且 $b_i$ 到 $b_n < z$ ，那么这样做的次数是 $n - i + 1$ 或者 $n - i$ （考虑 $z$ 是 $b$ 且对应的 $a$ 在需要翻转的区间里）的，两边次数加起来不超过 $m$ 。

我们考虑对这几个条件进行分析一下，首先 $i$ 对于 $z$ 减小是单调的，由于 $min$ 只能下降不能上升， $max$ 只能上升不能下降，那么对于$z$下降来说，他的条件会越来越苛刻。

又因为我们从小到大枚举 $k$ ,用来满足
$k$ 的次数会单调不降，那么我们发现，对于一个 $z$ ，他的所有条件即 $b_i$ 到 $b_n > k$，且 $b_i$ 到 $b_n < z$ ,次数和小于 $m$ ，在 $k$ 上升都具有单调性，感性分析一下，在 $k$ 上升时， $z$ 具有单调不降的性质。

那么我们只要对 $k = 1$ 一个 $log$ 求出对应的 $z$ ,再进行双指针，就可以做到 $O(n)$ 了。

---

## 作者：Presentation_Emitter (赞：2)

提供思路，不一定正确，欢迎各大佬hack

该思路时间复杂度为 $\Theta(n \log n)$（$n,m$ 同阶）。

首先有以下结论：

- 一张卡不能翻 $2$ 次或更多次
  - 显然
- 翻的卡必定是最左侧或最右侧连续的一段
  - 如果没有翻两端的卡而直接翻中间的卡，则显然不会使答案更优

那么有一个显然的 $\Theta(m^2)$ 做法，枚举其中一段翻的卡，然后暴力更新答案。首先要处理`b`数组的前后缀 $\max / \min$（前缀 $\max$ 记为 $L_1$，$\min$ 记为 $L_2$，后缀记为 $R_1$ 和 $R_2$，同理），之后单独处理只有一端翻了卡的情况，然后对于其它情况暴力。

处理其它情况的伪代码如下：

$$\begin{aligned}
&for(i:1 \to m-1)\\
&\quad for(j:n-m+i+1 \to n)\\
&\quad\quad ans\leftarrow\min(ans,\max(a_{j-1},L_{1,i},R_{1,j})-\min(a_{i+1},L_{2,i},R_{2,j}))
\end{aligned}$$

应该不难理解，以下默认已经理解了这种方法。

那么首先把 $\max$ 和 $\min$ 中的 $i$ 和 $j$ 分离出来，就像这样：

$$\max(L_{1,i},\max(a_{j-1},R_{1,j}))-\min(\min(a_{i+1},L_{2,i}),R_{2,j})$$

我们可以设 $l_1=\max(a_{i+1},L_{1,i})$ 和 $l_2=\min(a_{i+1},L_{2,i})$，以及关于 $j$ 的函数 $f_1(j)=\max(a_{j-1},R_{1,j})$ 和 $f_2(j)=\min(a_{j-1},R_{2,j})$。

之后我们把整个过程分成两部分，一个部分处理 $l_1$ 与 $f_1$ 不相交的情况，另一部分处理相交的情况。

对于不相交的情况，对于所有 $l_2$ 按其值**从大到小**排序，然后用一个指针 $p$，初始 $p=n$，然后枚举 $i$ 的同时 $p$ 左移至**第一个**满足 $l_2 \le f_2(p)$ 的位置并更新答案。答案更新方式同暴力。

对于相交的情况，观察到 $l_1$ 与 $f_1(j)$ 的图像大致满足：  
![](https://cdn.luogu.com.cn/upload/image_hosting/svi9rl3g.png)  
那么对于所有 $l_1$ **从小到大**排序（因为€€£的数据水所以也许可以不用排），然后每一次 $l_1$ 上移的时候统计紫色部分（如图）对于的 $j$ 即可。  
![](https://cdn.luogu.com.cn/upload/image_hosting/1jpqo39o.png)  
同样按照暴力的方案更新答案即可。

~~代码太丑就不贴了~~

---

## 作者：Acetyl (赞：2)

首先，将所有的卡分成两类，一类是 $a_i\le b_i$，称之为“小翻大”，一类是 $b_i<a_i$，称之为“大翻小”。考虑枚举所有正面朝上的最小值，计算该最小值下正面朝上的最大值最小是多少。显然，最大值不会低于 $\min_{i=1}^n\max(a_i,b_i)$ ，同理，最小值也不会高于 $\max_{i=1}^n\min(a_i,b_i)$。

在钦定了最小值之后，在小翻大的卡中就出现了一些必须翻的卡（即 $a_i$ 小于当前最小值的卡，设这样的卡有 $s$ 张），这些卡的 $b$ 值会直接贡献进答案；还剩下了一些可翻可不翻的卡，而由于我们要求最大值最小，所以最优的方案就是少管闲事，不去翻那些可翻可不翻的卡。

下面考虑大翻小的卡，与之前相对，大翻小的卡当中就出现了一些必须不翻的卡（即 $b_i$ 小于当前最小值的卡），这些卡的 $a$ 值也会直接贡献进答案。对于剩下的卡，只需要按照从大到小的顺序依次翻开即可，直到把机会用完为止，即翻 $m-s$ 张。将这些卡按照 $a$ 值从大到小排序，如果前 $m-s$ 张卡中已经有必须不翻的卡了，那么答案一定从前面这些必须不翻的卡贡献而来，而如果前 $m-s$ 张卡中没有必须不翻的卡，则翻完 $m-s$ 张之后下一张刚好是第 $m-s+1$ 张，于是将这张卡的 $a$ 值也贡献进答案即可。最终的答案即为所有贡献进答案的值取 max。

由于最小值增大的过程中最大值不会减小，所以在从小到大枚举最小值的过程中，用同一个变量维护所有的最大值即可。时间复杂度 $\mathcal O(n\log n)$，其中复杂度瓶颈是排序。

放一个考场上写的程序：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define all(x) (x).begin(), (x).end()
#define SZ(x) ((int)(x).size())
#define loop(i, a) for (int i = 0; i < (a); ++i)
#define cont(i, a) for (int i = 1; i <= (a); ++i)
#define circ(i, a, b) for (int i = (a); i <= (b); ++i)
#define range(i, a, b, c) for (int i = (a); (c) > 0 ? (i <= (b)) : (i >= (b)); i += (c))
#define pub push_back
#define pob pop_back
#define mak make_pair
#define mkt make_tuple
typedef long long ll;
typedef long double lf;
const int Inf = 0x3f3f3f3f;
const ll INF = 0x3f3f3f3f3f3f3f3fll;

const int maxn = 1000005;

int a[maxn], b[maxn];
int n, m;
int mx, mn;
vector<pair<int, int> > dx, ds, xd;
vector<int> vs;

int main() {
	freopen("card.in", "r", stdin);
	freopen("card.out", "w", stdout);
	scanf("%d%d", &n, &m);
	cont(i, n) scanf("%d", a + i);
	cont(i, n) scanf("%d", b + i);
	mn = Inf;
	cont(i, n) {
		if (a[i] > b[i]) dx.pub(mak(b[i], a[i])), ds.pub(mak(a[i], b[i]));
		else xd.pub(mak(a[i], b[i]));
		vs.pub(a[i]); vs.pub(b[i]);
		mn = min(mn, max(a[i], b[i]));
		mx = max(mx, min(a[i], b[i]));
	}
	sort(all(ds)); reverse(all(ds));
	int mmx = mx;
	if (SZ(ds) > m) mmx = max(mmx, ds[m].first);
	sort(all(vs));
	sort(all(xd));
	sort(all(dx));
	int ptr = 0, pts = 0;
	int ans = Inf;
	loop(i, n << 1) {
		if (vs[i] > mn) break;
		while (ptr < SZ(xd) && xd[ptr].first < vs[i]) mmx = max(mmx, xd[ptr++].second);
		if (ptr > m) break;
		while (pts < SZ(dx) && dx[pts].first < vs[i]) mmx = max(mmx, dx[pts++].second);
		if (SZ(ds) > m - ptr) mmx = max(mmx, ds[m - ptr].first);
		ans = min(ans, mmx - vs[i]);
	}
	printf("%d\n", ans);
	return 0;
}
```

---


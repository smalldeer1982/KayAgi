# [省选联考 2021 B 卷] 取模

## 题目描述

给定 $n$ 个正整数 $a_i$，请你在其中选出三个数 $i, j, k$（$i \ne j$，$i \ne k$，$j \ne k$），使得 $(a_i + a_j) \bmod a_k$ 的值最大。

## 说明/提示

对于 $30 \%$ 的数据，$n \le 100$。  
对于 $60 \%$ 的数据，$n \le 3000$。  
对于 $100 \%$ 的数据，$3 \le n \le 2 \times {10}^5$，$1 \le a_i \le {10}^8$。

## 样例 #1

### 输入

```
6
4 7 7 5 2 2
```

### 输出

```
6
```

## 样例 #2

### 输入

```
见附件中的 mod/mod2.in。```

### 输出

```
见附件中的 mod/mod2.ans。```

# 题解

## 作者：bzy (赞：42)

Tips : 本解法不一定是正解。

考虑暴力，枚举 $a_k$, 将 $\{a_n\}$ 中除了 $a_k$ 的数字对 $a_k$ 取模，生成新序列 $\{b_n\}$。将 $\{b_n\}$ 中的数字分成两部分 $A, B$。$A$ 中元素小于 $\lceil\frac{n}{2}\rceil$, $B$ 中元素大于等于 $\lceil\frac{n}{2}\rceil$。然后考虑模 $a_k$ 意义下，最大值三种可能的情况:
1. $A$ 中最大值与次大值的和。
2. $B$ 中最大值与次大值的和减去 $a_k$。
3. 枚举 $b_i$ 找到 $\{b_n\}$ 小于 $a_k-b_i$ 的最大值 $b_x$，$b_i+b_x$ 可能为最大值。 

视实现情况，复杂度为 $\Theta(n^2\log n)$ ~ $\Theta(n^3)$。

考虑对上述暴力进行优化。

**优化一**

相同出现过的数字只枚举一次。

看起来用处不大，复杂度依然不变。

**优化二**

从大到小枚举 $a_k$, 然后记录一个答案 $p$。一旦 $a_k \le p$ 则不再枚举。

看起来用处不大，但结合优化一以后，复杂度下降到 $\mathcal{O}(n\log n\log V)$。其中 $V$ 是 $\{a_n\}$ 的值域大小。

这里的复杂度是一个比较松的上界，应该能找到更紧的界。

以下是这个上界的证明。

**证明**

考虑弱化上述的优化，即把记录的答案 $p$ 改成暴力中情况 1、2 的最大值，记作 $p=\max\{p_1,p_2\}$。

首先枚举 $\{a_n\}$ 中最大值为 $a_k$，记作 $a_x$。

延续暴力算法中的定义，有 $A$ 中所有元素均小于等于 $p_1$, 所以小于等于 $p$。即 $A$ 中元素无需枚举。所以只考虑 $B$ 中元素。

设 $\lceil\frac{a_x}{2}\rceil\le B_1\le B_2\le \cdots\le B_t\le a_x$。

假设枚举若干轮后 $p$ 变为 $p'$。则我们需要枚举的元素为

$p'\le B_s\le B_{s+1}\le \cdots\le B_t\le a_x$。

将上述不等式逐项相减得到 $\{u_1,u_2,\cdots,u_{t-s+1}\}$。

因为第二类最大值为 $B_i+B_{i+1}-B_{i+2}\le p'$。

所以 $u_i+2u_{i+1}\ge\sum\limits_{j=1}^{i+1}u_j$

要让 $u$ 尽可能小，上述不等式得取等号。

即 $u_{i+1}=\sum\limits_{j=1}^{i-1}u_j$。

此时可知 $u_{i+1}=u_i+u_{i-1}$ 形似斐波那契数列，所以 $u_n=\mathcal{O}((\frac{\sqrt{5}+1}{2})^n)$。

又因为 $B_t-p'=\sum\limits_{i=1}^{t-s+1} u = u_{t-s+2}\le\frac{V}{2}$。

所以需要枚举的数是 $\mathcal{O}(\log V)$ 级的。

总时间复杂度为 $\mathcal{O}(n\log n \log V)$。

---

## 作者：Mobius127 (赞：32)

$Update \ in\ 2021.6.24:$ 代码在 UOJ 被卡掉了，修了一下。

---

[题目传送门](https://www.luogu.com.cn/problem/P7521)

$a$ 的位置对我们没有影响，先排序。

考虑直接上暴力，枚举模数项 $a_{mid}$，直接对其它数进行 $\text {mod}$ 得到新数组 $b$。

那么对于 $a_{mid}$ 的贡献分成两类：

1. $b_i+b_j < a_{mid}$

1. $b_i+b_j > a_{mid}$

发现我们省了个等于的情况，因为这种根本没用。

第二种显然是 $b_{up}+b_{up-1}$，原因？

对于 $b$ 数组的每两个数相加都不会超过 $2 \times a_{mid}$，既然已经保证 $b_i+b_j > a_{mid}$，也就是说相当于一堆 $a_{mid} \le x \le 2 \times a_{mid}$，只要选和最大的两个即可，显然就是最大的两个数。

再回头过来看第一种。

这个显然可以搞双指针。

于是复杂度就是 $O(n^2 \log n)$（因为还有个排序）。

再想如何优化，倒序枚举 $mid$，如果当前最大值 $ans \ge a_{mid}-1$，即大于贡献的上届，就珂以直接 $\text{break}$ 掉了。

这个优化效果十分明显，直接过了。

然后你交到 [UOJ](https://uoj.ac/problem/627) 上，发现只有 [$95\ tps$](https://uoj.ac/submission/480746)，为什么？

显然还有个明显的 hack ：你在很多次的重判同一个模数。

加上一个 map 即可。

[$AC\ Code$](https://uoj.ac/submission/480747)



最后再来一波证明：

考虑到 $a_1...\le a_{mid-1}\le ans \le a_{mid} \le a_{mid+1}...\le a_n$ 。

根据刚刚的结论，显然有：

$$\text{对于} \forall i\ \in \ [mid, n-1),\ ans \ge (a_i+a_{i+1}) \mod a_{i+2}$$

考虑到 $a_i \le a_{i+1} \le a_{i+2}$，珂以把取模省掉。

$$ans \ge a_i+a_{i+1}-a_{i+2}$$

$$ans+a_{i+2} \ge a_i+a_{i+1}$$

$$ans+a_{i+2}-2 \times ans \ge (a_i -ans)+(a_{i+1}-ans)$$

令 $f_i=a_i-ans$ 。

$$f_{i+2} \ge f_i + f_{i+1}$$

这长得很像 Fibonacci 数列，而我们知道，Fibonacci 数列是以指数级增长的。

又 $f_{n}=a_n-ans \le 10^8$ 。

所以 $f_{mid} \approx  \log{10^8}$ ，也就是说，我们大概会扫  $\log$ 次，而单次的复杂度为 $O(n \log n)$ ， 所以总复杂度 $O(n \log n \log{10^8})$ 。


---

## 作者：I_am_Accepted (赞：30)

这题评绿显然是恶评啊，都是被数据水而骗分过的人害的。

这有复杂度和正确性证明。

我们将 $a$ 升序排序，即 $a_1\le a_2\le\dots\le a_n$。

如果我们已知了最终答案所取的模数是 $a_x$，则我们可以轻松地 $O(n\log n)$ 计算答案。

* * *

如何轻松？

我们将除了 $a_x$ 的数都 $\bmod\ a_x$ 后存入 $b_1,\dots,b_{n-1}$。

设答案取 $(b_y+b_z)\bmod a_x$，分成两类：

若 $b_y+b_z\ge a_x$，由于 $b_y+b_z\le 2a_x-2$，所以我们选择最大的两个 $b_y,b_z$。

若 $b_y+b_z<a_x$，我们排序后用双指针维护最大值。

* * *

我们**降序**枚举 $a_x$ 为模数，当**当前答案** $ans\ge a_x-1$，则我们输出 $ans$ 直接终止程序，因为接下来答案不可能更优。

当然，如果 $a_x=a_y(x<y)$，则 $a_x$ **没有必要当模数再算一次了**。

**看起来很暴力对吧？但是复杂度是对的。**

* * *

时间复杂度：

我们设可能能成为模数（即这个数在 $\{a\}$ 中之后的数都严格比她大）进行计算的数有：
$$
p_1<p_2<\dots <p_k
$$
$$
a_{p_1}< \dots < a_{p_{c-1}}\le (ans+1)< a_{p_c} \ < \dots <a_{p_k}\quad(*)
$$
其中 $ans$ 为最终答案。

发现 $a_{p_1}\sim a_{p_{c-1}}$ 都不会被算，因为都不大于 $ans+1$。

由于 $ans$ 是最优答案，得到
$$\forall i\in [c,k-2]\cap\mathbb{Z}
,\, (a_{p_i}+a_{p_{i+1}})\bmod a_{p_{i+2}}\le ans
$$
由 $(*)$ 的推论 
$$
a_{p_i}+a_{p_{i+1}}-2a_{p_{i+2}}<0$$
得到
$$
a_{p_i}+a_{p_{i+1}}-a_{p_{i+2}}\le ans
$$
进一步式子变形
$$
(a_{p_{i+2}}-ans)\ge (a_{p_{i+1}}-ans)+(a_{p_i}-ans)\quad(\Delta)
$$
代换 $h_i=a_{p_i}-ans$，由 $(*)$ 有
$$
\forall i\in [c,k]\cap\mathbb{Z},\, h_{i}\ge 2\quad(\text A)
$$
$(\Delta)$ 式子就变成了
$$
h_{i+2}\ge h_{i+1}+h_i\quad(\text B)
$$
结合 $(\text A)(\text B)$ 得到 $\{h\}$ 的**增长速度不小于斐波那契数列的增长速度，即不小于指数级别**。

由于 $a_n\le 10^8$，得到我们真正有计算的模数个数是 $\log 10^8$ 级别的，而一次计算模数的复杂度为 $O(n\log n)$（瓶颈在排序），所以最终复杂度为
$$
O(n\log n\log 10^8)
$$
可以通过 luogu 和 uoj 的测试点，完结撒花。

* * *

[luogu 提交](https://www.luogu.com.cn/record/88016992)

[uoj 提交](https://uoj.ac/submission/585641)

---

## 作者：lndjy (赞：26)

这篇题解是以这道题举例来说考场乱搞骗分的方法。因为 CCF 已经连续两年脚造省选 A 卷 D1T1 数据了。亲测有效。

### 适用条件

当你是和我一样水平较弱的选手，完全不会这题的正解，同时考场上其他题该暴力的暴力，该正解的正解都写完了，还有一段时间，准备颓扫雷或者纸牌啥的的时候，就可以尝试乱搞骗分。说不定能利用这点时间多骗一些分，~~甚至进队~~。

### 1.保证复杂度，骗正确性

说白了，就是在不超时的情况下尽可能让答案正确的可能性更大。

最常见的例子就是模拟退火，在达到一个时间之前一直跑。

分两步：

1.想一个正确性不对或者大概是对的但是不会证明的做法。

2.在时限的范围内，尽可能增加其正确性。

例：
- [P7521 [省选联考 2021 B 卷] 取模](https://www.luogu.com.cn/problem/P7521)

首先，想一个正确性不对的做法：

首先，模数差不多不会选一个小的数。

看到这道题，自然想到[这个题](https://www.luogu.com.cn/problem/P5682)。这个题有两种可能，一个是用第三大数模大数，一个是用最大数模次大数。

自然想到这题差不多是两个数加起来接近模数或者一个略小于模数一个略大于模数。因为模数不会小，所以这两个数差不多也不会小。

那么选较大的几个数暴力枚举就可以骗分了。

那么选几个数呢，这时候就是第二条了。

这样做的复杂度是 $x^3$，$x$ 为你选数的个数。显然，$x$ 越大，正确率越高，但是为了保证不超时，$x$ 可以选择 $300-500$ 左右。

虽然根据[这个题解](https://www.luogu.com.cn/blog/heshandeshenshi/solution-p7521)，$x=6$ 即可通过，但是考场不知道的情况还是我这样比较稳妥，更可能骗到更多分。

- [P7514 [省选联考 2021 A/B 卷] 卡牌游戏](https://www.luogu.com.cn/problem/P7514)

首先，想一个正确性不对的做法，根据思维能力有各种正确率不同的方法。不管你只想到[这个](https://www.luogu.com.cn/discuss/show/311215)还是直接双指针。

然后第二步，尽可能增加其正确性。首先，你可以在数据较小的时候直接跑之前写好的 40 分暴力。其次，你如果想到多种乱搞，可以取最小值。

### 2.保证正确性，骗复杂度

这个，也就是俗称 $n^2$ 过百万的一种可能方法。

分两步：

1.想一个复杂度不对或者大概是对的但是不会证明的做法。

2.在答案正确的范围内，尽可能优化其效率。

例：

- [P6619 [省选联考 2020 A/B 卷] 冰火战士](https://www.luogu.com.cn/problem/P6619)

首先 $q^2$ 暴力模拟很显然，每次增加或者减少一个战士。

然后剪枝优化。

在数据水的情况下，加入一个新的或者减少一个对最终的温度差不多只是微调。变化不会太大。

从上次的答案开始，暴力移动温度找最大值，就可以通过了。



------------

当你写完暴力和骗分的时候，考完心态会很好。因为你写的暴力，所以几乎不会挂，你写的骗分，得分还有可能比期望高，静静地看着大家挂分，自己却得分比期望高，岂不美哉？

---

## 作者：cmk666 (赞：13)

[题目传送门](/problem/P7521)

题目大意：给定序列 $a$，求 $\displaystyle\max_{i\ne j,i\ne k,j\ne k}(a_i+a_j)\bmod a_k$。

考虑固定模数 $a_k$。

令所有 $i\ne k$ 的 $a_i\bmod a_k$ 构成序列 $b$，那么答案最大只有两种情况：

1. $b_i+b_j\ge a_k$，那么因为 $b_i+b_j<2a_k$，因此 $ans=b_i+b_j-a_k$。要使 $ans$ 最大化，只需取最大的 $b_i,b_j$ 即可；

2. $b_i+b_j<a_k$，直接对 $b$ 排序跑一遍双指针即可得出最大的 $ans$。

这样做一遍时间复杂度是 $O(n\log n)$，但要做 $n$ 遍，难以承受。

于是考虑减少做的次数。

首先对于相同的 $a_k$，答案肯定是一样的，只需做一遍。

其次，我们对于 $a$ 按从大到小的顺序来做，如果当做到 $a_i$ 时 $ans\ge a_i$，那就没必要做了。正确性显然。

分析一下优化后的时间复杂度。

令 $a$ 已经从大到小排好序并去重。设 $a_1>\cdots>a_x>ans\ge a_{x+1}>\cdots>a_n$。

因为 $ans$ 是最大的答案，那么 $\forall1\le i\le x-2$，有 

$$(a_{i+1}+a_{i+2})\bmod a_i\le ans$$

显然

$$a_i>a_{i+1}>a_{i+2}>ans$$

那么

$$(a_{i+1}+a_{i+2})\bmod a_i\le ans<a_{i+1}+a_{i+2}<2a_i$$

所以

$$a_i\le a_{i+1}+a_{i+2}<2a_i$$

于是把取模干掉，得到

$$a_{i+1}+a_{i+2}-a_i\le ans$$

变形得到

$$(a_{i+1}-ans)+(a_{i+2}-ans)\le(a_i-ans)$$

令 $f_i=a_i-ans$，那么

$$f_i\ge f_{i+1}+f_{i+2}$$

发现这东西长的很像倒着的 [斐波那契数列](//oeis.org/A000045)。这玩意儿是呈指数级增长的。

又有 $f_1=a_1-ans\le a_1\le V$，其中 $V$ 代表值域，因此 $f_i$ 的数量至多只有 $\log V$ 级别。

换句话说，我们只会扫至多 $O(\log V)$ 次就能找到最终答案。

因此总的时间复杂度为 $O(n\log n\log V)$。核心代码如下：
```cpp
int n, a[200009], b[200009], cnt, ret, ans; map < int, int > mem;
inline int calc(int id)
{
	if ( mem.count(a[id]) ) return mem[a[id]];
	cnt = 0;
	For(i, 1, n) if ( i != id ) b[++cnt] = a[i] % a[id];
	sort(b + 1, b + cnt + 1), ret = ( b[cnt - 1] + b[cnt] ) % a[id];
	for ( int l = 1, r = cnt ; l < r ; l++ )
	{
		while ( l < r && b[l] + b[r] >= a[id] ) r--;
		if ( l < r ) ret = max(ret, b[l] + b[r]);
	}
	return mem[a[id]] = ret;
}
int main()
{
	read(n); For(i, 1, n) read(a[i]);
	sort(a + 1, a + n + 1, greater < int > ());
	For(i, 1, n)
	{
		if ( ans >= a[i] ) break;
		ans = max(ans, calc(i));
	}
	return printf("%d\n", ans), 0;
}
```

---

## 作者：xkcdjerry (赞：8)

本菜鸡看了聚佬的正解之后一头雾水，然后就自己写了一个很感性的玄学算法：

如果两个数和模 $a[k]$ 接近 $a[k]$ ，大概率是一个比 $a[k]$ 小一点的加上一个比 $a[k]$ 大一点的凑在一起。组成一个比 $2 \times a[k]$ 小一点的数，然后模 $a[k]$ 接近 $a[k]$ 。   
所以可以排序之后直接枚举 $k$ 然后在周围几个数字（即稍微大一点和小一点的数）中寻找解。  

代码：  
```cpp
#include <cstdio>
#include <algorithm>
#define N 200010
int n;
int a[N];
inline int min(int a,int b)
{
    return a<b?a:b;
}
inline int max(int a,int b)
{
    return a>b?a:b;
}
int main()
{
    int mx=-1;
    scanf("%d",&n);
    for(int i=0;i<n;i++) scanf("%d",a+i);
    std::sort(a,a+n);
    for(int i=0;i<n;i++)
        for(int j=max(i-10,0);j<min(i+10,n);j++)
            for(int k=max(j-10,0);k<min(i+10,n);k++)
            {
                if(i==j||k==i||k==j) continue;
                mx=max(mx,(a[i]+a[j])%a[k]);
                mx=max(mx,(a[i]+a[k])%a[j]);
                mx=max(mx,(a[j]+a[k])%a[i]);
            }
    printf("%d",mx);
    return 0;
}

```
[AC记录](https://www.luogu.com.cn/record/49654710)  
~~但是由于CCF脚造数据[不排序](https://www.luogu.com.cn/record/49654727)都能过去~~

---

## 作者：y0y68 (赞：7)

update 2021.4.16：锅已修复，感谢 @cnyz 的提醒

首先考虑 $n^2 \log n$ 的暴力，我的做法是 $set$ 里二分。

枚举模数，设为 $a_i$，然后枚举加数，设为 $a_j$，设另一个加数为 $a_k$。由于 $a_j \mod a_i$ 固定，所以要找到最优的 $a_k$ 即可。我们设 $a_j \mod a_i = m$，问题转为使 $(m+a_k) \mod a_i$ 最大。

发现当 $num ≠ a_i-m$ 时（$ 0 \le num \le a_i-1$），$num$ 优于 $num-1$（方便起见，称 $x$ 优于 $y$ 为 $(m+x) \mod a_i$ 大于 $(m+y) \mod a_i$）。又因为 $0$ 优于 $a_i-1$。所以优先级从大到小为：

$$a_i-m-1,a_i-m-2,\cdots,1,0,a_i-1,a_i-2,\cdots,a_i-m+1,a_i-m$$

即：

$(m+(a_i-m-1)) \mod a_i = a_i-1$

$(m+(a_i-m-2)) \mod a_i = a_i-2$

$\cdots \cdots$

$(m+0) \mod a_i = m$

$(m+(a_i-1)) \mod a_i = m-1$

$(m+(a_i-2)) \mod a_i = m-2$

$\cdots \cdots$

$(m+(a_i-m+1)) \mod a_i = 1$

$(m+(a_i-m)) \mod a_i = 0$

然后用 $set$ 将可取的 $a_k \mod a_i$ 存下来，就可以二分了（可能二分两次，第一次在 $0,\cdots,a_i-m-1$ 二分，无果的话就在 $a_i-m,\cdots,a_i-1$ 里再二分一次）。

关于优化：将 $a_i$ 从大到小排序，然后去重依次枚举，遇到 $a_i \le ans+1$ 就跳过（ $ans$ 为目前答案），即可通过此题。

附：此优化的时间复杂度因笔者太菜不会证明，如有会证的大佬请私信我。

AC code：

```
#include<iostream>
#include<cstdio>
#include<set>
#include<cstring>
#include<algorithm>
#define INF 0x3f3f3f3f
using namespace std;
const int N=2e5+5;
int n,tot,ans,a[N],b[N];
set<int>st;//这里的st为了我存了可取的a[k]%a[i]的相反数，方便二分
int bs(int x){//找目前不大于x的第一个位置，找不到返回INF
	set<int>::iterator it=st.lower_bound(x);
	if(it==st.end())return INF;
	return (*it);
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)
		scanf("%d",&b[i]);
	sort(b+1,b+n+1,greater<int>());
	int tot=0;a[++tot]=b[1];//去重时注意相同的数字最多可保留两个，保留一个会出错
	for(int i=2,l=1;i<=n;i++){
		if(b[i]==b[l]&&i-l<=1)a[++tot]=b[i];
		else if(b[i]!=b[l])a[++tot]=b[i],l=i;
	}
	for(register int i=1;i<=tot;i++)if(ans<=a[i]+1){
		st.clear();//注意清空
		for(register int j=1;j<=tot;j++){
			if(i==j)continue;//由题意知相等就跳过
			int t1=bs(a[j]%a[i]+1-a[i]);//第一次二分
			if(t1==INF){//第一次二分无果
				int t2=bs(1-a[i]);//第二次二分
				if(t2!=INF)ans=max(ans,(a[j]%a[i]-t2)%a[i]);//更新答案的时候注意正负性，即t2要取相反数
			}
			else ans=max(ans,(a[j]%a[i]-t1)%a[i]);//与上同理
			st.insert(-a[j]%a[i]);//插入相反数
		}
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：glorious_dream (赞：1)

### 题目描述：

给定一个序列，从中选出三个数 $i$，$j$，$k$，求 $(a[i]+a[j])$ $mod$ $a[k]$ 的值最大

### 算法描述：

首先来看暴力，$30%$ 的数据和 $60%$ 的数据直接暴力两层循环枚举就行。

$100%$ 的数据呢？首先，如果除数越大，那么得到的余数大的概率越大。在考场上没有思路的时候，不妨想一下数据。

给的数值很大的话，那么是不是除数越大，对应的答案就会越大呢？

这时有人会问，~~这不是骗分吗~~。但其实不完全是，如果考虑每次循环找 $10$ 个数，那么最终的答案准确率会更高的。当然，如果复杂度能算好，多取数，正确的可能性就越大。

### 代码如下：

```cpp
#include<bits/stdc++.h>
#define re register
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch == '-') f=-1 ; ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48) ; ch=getchar();}
	return x*f;
}
inline void print(int x){
	if(x/10) print(x/10);
	putchar(x%10+'0');
}
const int M = 2e5+10;
int a[M];
int n,maxn=-1e9;
signed main(){
	n=read();
	for(re int i(1) ; i<=n ; ++i) a[i] = read();
	stable_sort(a+1,a+n+1);
	for(re int i(1) ; i<=n ; ++i){
		for(re int j=max(i-10,1) ; j<=min(i+10,n) ; ++j){
			for(re int k(max(j-10,1)) ; k<=min(j+10,n) ; ++k){
				if(i==j||i==k||j==k) continue;
				maxn = max(maxn,(a[i]+a[j])%a[k]);
				maxn = max(maxn,(a[i]+a[k])%a[j]);
				maxn = max(maxn,(a[j]+a[k])%a[i]);
			}
		}
	}
	printf("%d",maxn);
	return 0;
}

```


---

## 作者：Southern_Dynasty (赞：1)

**注：本题解为乱搞做法。**

## $30 pts$

考虑暴力。

直接三重循环完事。

代码：

```cpp
#include<bits/stdc++.h>
//#include<bits/extc++.h>
#define gt getchar
#define pt putchar
#define y1 y233
typedef long long ll;
//typedef __int128 lll;
typedef unsigned long long ull;
const int N=2e5+5;
using namespace std;
//using namespace __gnu_pbds;
inline bool D(char ch){return ch>='0'&&ch<='9';}
inline int read(){
   	int x=0,f=1;char ch=gt();
   	while(!D(ch)){if(ch=='-')f=-1;ch=gt();}
   	while(D(ch)){x=(x<<1)+(x<<3)+(ch^48);ch=gt();}
	return x*f;
}
inline void print(int x){
	static int st[70];int top=0;
	if(x<0)pt('-'),x=-x;
    do{st[++top]=x%10,x/=10;}while(x);
    while(top)pt(st[top--]^48);
}
inline void printsp(int x){
	static int st[70];int top=0;
	if(x<0)pt('-'),x=-x;
    do{st[++top]=x%10,x/=10;}while(x);
    while(top)pt(st[top--]^48);pt(32);
}
inline void println(int x){
	static int st[70];int top=0;
	if(x<0)pt('-'),x=-x;
    do{st[++top]=x%10,x/=10;}while(x);
    while(top)pt(st[top--]^48);pt(10);
}
int n,a[N],ans;
signed main(){
	n=read();
	for(int i=1;i<=n;++i)
		a[i]=read();
	for(int i=1;i<=n;++i)
		for(int j=1;j<=n;++j)
			for(int k=1;k<=n;++k)
				if(i!=j&&j!=k&&i!=k)ans=max(ans,(a[i]+a[j])%a[k]);
	println(ans);
	return 0;
}
```

## $100 pts$

我们考虑对暴力进行乱搞优化。

因为我们要求最后取模后的答案最大，那么模数显然是要大一点更好（正确性不保证）。

那么我们对 $a$ 排序，然后选取其中较大的某些数暴力即可。因为是三次方的复杂度，所以选取前 $500$ 大的数跑 $O(n^3)$ 的暴力即可（数据过于水了）。

注意判断 $n<500$ 的情况。

代码：

```cpp
#include<bits/stdc++.h>
//#include<bits/extc++.h>
#define gt getchar
#define pt putchar
#define y1 y233
typedef long long ll;
//typedef __int128 lll;
typedef unsigned long long ull;
const int N=2e5+5;
using namespace std;
//using namespace __gnu_pbds;
inline bool D(char ch){return ch>='0'&&ch<='9';}
inline int read(){
   	int x=0,f=1;char ch=gt();
   	while(!D(ch)){if(ch=='-')f=-1;ch=gt();}
   	while(D(ch)){x=(x<<1)+(x<<3)+(ch^48);ch=gt();}
	return x*f;
}
inline void print(int x){
	static int st[70];int top=0;
	if(x<0)pt('-'),x=-x;
    do{st[++top]=x%10,x/=10;}while(x);
    while(top)pt(st[top--]^48);
}
inline void printsp(int x){
	static int st[70];int top=0;
	if(x<0)pt('-'),x=-x;
    do{st[++top]=x%10,x/=10;}while(x);
    while(top)pt(st[top--]^48);pt(32);
}
inline void println(int x){
	static int st[70];int top=0;
	if(x<0)pt('-'),x=-x;
    do{st[++top]=x%10,x/=10;}while(x);
    while(top)pt(st[top--]^48);pt(10);
}
int n,a[N],ans;
signed main(){
	n=read();
	for(int i=1;i<=n;++i)
		a[i]=read();
	sort(a+1,a+n+1);
	for(int i=max(n-499,1);i<=n;++i)
		for(int j=max(n-499,1);j<=n;++j)
			for(int k=max(n-499,1);k<=n;++k)
				if(i!=j&&j!=k&&i!=k)ans=max(ans,(a[i]+a[j])%a[k]);
	println(ans);
	return 0;
}
```

---


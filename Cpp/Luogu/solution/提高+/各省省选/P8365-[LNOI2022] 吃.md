# [LNOI2022] 吃

## 题目描述

小 A 很喜欢吃东西。

小 A 面前有 $n$ 份食物，第 $i$ 份有参数 $a_i$ 和 $b_i$。小 A 可以按照**任意顺序**吃掉这 $n$ 份食物。当她吃掉编号为 $i$ 的食物时，她可以选择将自己的体重乘以 $a_i$ 或者将自己的体重加上 $b_i$。每份食物只能吃恰好一次。

小 A 的初始体重为 $1$，请求出她吃完 $n$ 份食物后能达到的**最大**体重。答案可能很大，你只需要输出其对 $({10}^9 + 7)$ 取模后的结果。

**注意：你需要最大化体重并将该最大值对 $\bm{({10}^9 + 7)}$ 取模，而非最大化体重对 $\bm{({10}^9 + 7)}$ 取模的结果。**

## 说明/提示

**【样例解释 #1】**

以下方案可以达到最大体重：

- 吃掉第一份食物并选择将体重增加 $100$，体重变为 $101$；
- 吃掉第二份食物并选择将体重增加 $200$，体重变为 $301$；
- 吃掉第三份食物并选择将体重乘 $3$，体重变为 $903$；
- 吃掉第四份食物并选择将体重乘 $4$，体重变为 $3612$；
- 吃掉第五份食物并选择将体重乘 $5$，体重变为 $18060$。

**【样例 #2】**

见附件中的 `food/food2.in` 与 `food/food2.ans`。

该组样例满足 $n \le 10$ 和特殊性质 E。

**【样例 #3】**

见附件中的 `food/food3.in` 与 `food/food3.ans`。

该组样例满足 $n \le 20$ 和特殊性质 E。

**【样例 #4】**

见附件中的 `food/food4.in` 与 `food/food4.ans`。

该组样例满足 $n \le 2000$。

**【样例 #5】**

见附件中的 `food/food5.in` 与 `food/food5.ans`。

该组样例满足特殊性质 A。

**【样例 #6】**

见附件中的 `food/food6.in` 与 `food/food6.ans`。

该组样例满足特殊性质 C。

**【样例 #7】**

见附件中的 `food/food7.in` 与 `food/food7.ans`。

该组样例满足特殊性质 D。

**【样例 #8】**

见附件中的 `food/food8.in` 与 `food/food8.ans`。

该组样例满足特殊性质 B。

**【样例 #9】**

见附件中的 `food/food9.in` 与 `food/food9.ans`。

**【数据范围】**

对于 $100 \%$ 的测试数据，$1 \le n \le 5 \times {10}^5$，$1 \le a_i, b_i \le {10}^6$。

| 测试点编号 | $n \le $ | 特殊性质 |
|:-:|:-:|:-:|
| $1$ | $10$ | DE |
| $2$ | $10$ | E |
| $3$ | $10$ | AE |
| $4$ | $10$ | E |
| $5$ | $20$ | DE |
| $6$ | $20$ | E |
| $7$ | $20$ | E |
| $8$ | $20$ | E |
| $9$ | $2000$ | D |
| $10$ | $2000$ | 无 |
| $11$ | $2000$ | 无 |
| $12$ | $2000$ | 无 |
| $13$ | $5 \times {10}^5$ | BD |
| $14$ | $5 \times {10}^5$ | B |
| $15$ | $5 \times {10}^5$ | C |
| $16$ | $5 \times {10}^5$ | C |
| $17$ | ${10}^5$ | 无 |
| $18$ | ${10}^5$ | 无 |
| $19$ | $5 \times {10}^5$ | 无 |
| $20$ | $5 \times {10}^5$ | 无 |

特殊性质 A：$a_i = 1$。  
特殊性质 B：$a_i \ge b_i$。  
特殊性质 C：$a_i, b_i$ 在 $[1, {10}^6]$ 内独立均匀随机生成。  
特殊性质 D：$a_i \ge 2$。  
特殊性质 E：$a_i \le 4$。

## 样例 #1

### 输入

```
5
1 2 3 4 5
100 200 300 400 500
```

### 输出

```
18060
```

# 题解

## 作者：KaguyaH (赞：23)

#### Solution A

这是考场思路。

显然应先加后乘。显然若 $a_i = 1$ 则必然选择加，首先将这些 $b_i$ 累加到 $x$ 上。如果我们钦定在后面选择加的数对的 $a_i$ 的积为 $A$，则我们应该选择 $b_i$ 和最大的方案。

设 $f_i$ 表示 $\max \sum_{x \in S} b_x \pod{\min_{x \in S} a_x \ge 2 \land \prod_{x \in S} a_x = i}$。每种相同的 $a_x = y$ 只取最大的 $\lfloor \log_y 10^6 \rfloor$ 个，转移类似背包即可。

时间复杂度 $O(n \log n + v \log v \log \log v)$，其中 $v = \max b_i$。

#### Solution B

显然若 $a_i = 1$ 则必然选择加，首先将这些 $b_i$ 累加到 $x$ 上。

假设我们钦定了选择顺序。对于其余的数对 $(a, b)$，若选择加，则必然有 $x < \frac b {a - 1} \le b$。如果我们在后面选择了多于两个做加法，那么如果我们优先选择 $b$ 最大的那个做加法，其余的选择乘法更优。于是得到结论，$a > 1$ 的数对，至多选择一个做加法。接下来就非常容易做了。

时间复杂度 $O(n)$。

---

## 作者：7KByte (赞：15)

> 给定 $n$ 个二元组 $(a_i,b_i)$，任意排列，初始化 $S = 1$，每次可以选择让 $S \leftarrow S + b_i$ 或者 $S \leftarrow S \times a_i$。求最大值。

首先加法一定在乘法前面，因为所有数都是正数，把加法前移只会更优。

显然对于 $a_i = 1$ 的二元组我们一定选择加 $b_i$，因为使用 $a_i$ 等于没有变化。所以我们可以预处理并删去所有 $a_i = 1$ 的二元组。

并且对于 $a_i \neq 1$ 的二元组，我们最多只会选择一个数进行加法。反证，假设进行两次加法 $b_i, b_j$，不失一般性另 $b_i \ge b_j$，由于 $a_j \ge 2$，所以 $2b_i \ge b_i + b_j$，第二次选择乘法会更优。

这样我们只用枚举哪个数加即可，另 $K = \prod a_i$，如果不加答案为 $KS$，如果加 $b_i$ 那么答案为 $\dfrac{K(S+b_i)}{a_i}$，所以我们只用选出 $\dfrac{S+ b_i}{a_i}$ 最大的二元组即可。

时间复杂度 $\mathcal{O}(N)$，交了六发，要是考场上就可以原地退役了。出题人也算是“精心”构造大样例，给了 $9$ 个样例都不能说明问题。

```cpp
#define N 500005
int n, m, u[N]; LL S = 1;
struct node{int a, b; }a[N];
int main() {
	read(n);
	rp(i, n)read(u[i]);
	rp(i, n){
		int x = u[i], y; read(y);
		if(x == 1)S += y;
		else a[++m] = {x, y};
	}
	int pv = 0; long double w = S;
	rp(i, m){
		long double cur = (S + a[i].b) * 1. / a[i].a;
		if(cur > w)w = cur, pv = i;
	}
	S %= P;
	if(pv)S = (S + a[pv].b) % P;
	rp(i, m)if(i != pv)S = S * a[i].a % P;
	cout << S << endl;
	return 0;
}
```



---

## 作者：Cocoly1990 (赞：5)

考虑到每个操作的选择其实是相对独立的，也就是说只要确定了当前已经选择的食物集合 $S$ 和当前的体重 $w$，未来的决策和 $S$ 中每个食物具体如何选择没有关系。 

因此我们每个食物单独考虑，如果 $a_i=1$ 那么必然是选择加法。

排除掉所有 $a_i=1$ 的情况，我们考虑剩下的怎么选。

一个重要的性质是如果有加法的话，必然是先加后乘，证明：

废话，每次乘法对一个数的贡献至少为 2.

另一个重要的性质是剩下的加法数量至多为 1，考虑证明：

假设选择了两次加法，他们的增量分别是 $b_i,b_j,b_i\leq b_j$，那么他对答案的贡献是 $\left(b_i+b_j\right)\times s$，其中 $s$ 表示选择乘法的数的乘积。我们考虑把不选 $b_i$，他的贡献就是 $b_j\times s\times a_i$，显然 $b_i+b_j\leq b_j \times a_i$.

暴力枚举就好了，比较的时候注意一点细节就可以避免高精度。

---

## 作者：lnwhl (赞：3)

## Solution
一个比较有趣的贪心题。

首先，我们不难发现加法都是在前面，乘法都是在后面的。

之后，我们可以发现如果 $a_i=1$，我们一定选择加法。

对于 $a_i\ne1$ 的情况，可以证明最多只选一个加。

>证明： 如果两个二元组 $(a_i,b_i)$ 和 $(a_j,b_j)$ 都选择了加法，不妨设 $b_i\ge b_j$，因为 $a_i\ge2$，所以 $2\times b_i\ge b_i+b_j$，显然不如第二次选乘更优，因此得证。

这样，我们只需要找出选哪个加最优就可以了，也就是找出 $\frac{S+b_i}{a_i}$ 最大的二元组。注意这里的 $S$ 是加完所有 $a_i=1$ 的 $b_i$ 后的 $S$。

复杂度 $O(n)$。
## Code

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn=5e5+5;
const int p=1e9+7;
int n,a[maxn],b,cnt;ll S=1;
struct node{int x,y;}food[maxn];
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&b);
		if(a[i]==1)S+=b;
		else food[++cnt]=(node){a[i],b};
	}
	int cur;long double Max=S;
	for(int i=1;i<=cnt;i++)
	{
		long double now=1.0*(S+food[i].y)/food[i].x;
		if(now>Max)Max=now,cur=i;
	}
	if(cur)S=(S+food[cur].y)%p;
	for(int i=1;i<=cnt;i++)
		if(i!=cur)S=S*food[i].x%p;
	cout<<S;
	return 0;
}
```




---

## 作者：_slb (赞：2)

# T1 food

## Description

有 $n$ 个食物，每个食物有 $a_i,b_i$ 两个参数。你的初始质量为 $1$，可以以任意顺序吃这些食物，吃掉一个食物之后，你的质量可以加 $b_i$，或者乘上 $a_i$，最大化质量。

## Solution

首先肯定是先加后乘；

然后 $a=1$ 肯定加。

然后剩下的食物里，加只会进行一次，因为如果加多次，调整为只加最大的，剩下的乘是不劣的。

假设加上 $a=1$ 的质量为 $now$，那么把一个数从乘变成加会让全都乘的答案 $ans$ 变为 $ans\times\dfrac{b+now}{a\times now}$，扫一遍找到右边比例的最大值就好了。

## Code

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;

namespace solve
{
    const int maxn = 1e6 + 10;
    const int mod = 1e9 + 7;
    typedef long long ll;

    ll now = 1;

    struct node
    {
        int a, b;

        inline double f() { return (b + now) / (long double)1. / ((long double)a * now); }
    } a[maxn];

    int vis[maxn];

    int n;

    void main()
    {
        cin >> n;
        for (int i = 1; i <= n; i++)
            cin >> a[i].a;
        for (int i = 1; i <= n; i++)
            cin >> a[i].b;
        for (int i = 1; i <= n; i++)
            if (a[i].a == 1)
                now += a[i].b, vis[i] = 1;
        double d = 1;
        int pos = -1;
        for (int i = 1; i <= n; i++)
        {
            if (vis[i])
                continue;
            if (a[i].f() >= d)
                pos = i, d = a[i].f();
        }
        if (pos == -1)
        {
            now %= mod;
            for (int i = 1; i <= n; i++)
                if (!vis[i])
                    now *= a[i].a, now %= mod;
            cout << now << endl;
        }
        else
        {
            now += a[pos].b, now %= mod;
            for (int i = 1; i <= n; i++)
                if (!vis[i] && i != pos)
                    now *= a[i].a, now %= mod;
            cout << now << endl;
        }
    }
}

int main()
{
    ios::sync_with_stdio(false);
    solve::main();
}
```

---

## 作者：Coros_Trusds (赞：1)

贪心很显然是错的，但是可以拿到 $75$ 真的离谱。。。

# 题目大意

有 $n$ 个食物，每个食物有 $a_i,b_i$ 两个参数。你的初始质量为 $1$，可以以 **任意顺序** 吃这些食物，吃掉食物 $i$ 之后，你的质量可以乘上 $a_i$，或者加上 $b_i$，最大化质量。

$1\le a_i,b_i\le 10^6$。

# 题目分析

当 $a_i=1$ 时，$ans\times 1$ 必定小于 $ans$ 加一个大于等于 $1$ 的数，所以此时必选加。

当 $a_i\neq 1$ 时，此时即 $a_i\ge 2$，可以证明最多不会做超过 $1$ 次加法操作。

--------------
证明：

假设加了两次，贡献为 $b_i+b_j$。而乘的贡献为 $a_i\times a_j$，所以 $b_i+b_j\le a_i\times a_j$。加大于两次的情况是类似的。

--------------

所以就只有两种情况：加一次或零次即不加。

所以枚举在哪里加就好了。

注意过程中不要取模，最大是 $10^{17}$ 级别的，`long long` 是够的。

# 代码

```cpp
#include <iostream>
#include <cstdio>
#include <climits>//need "INT_MAX","INT_MIN"
#include <cstring>//need "memset"
#include <numeric>
#include <algorithm>
#include <cmath>
#define int long long
#define enter putchar(10)
#define debug(c,que) std::cerr << #c << " = " << c << que
#define cek(c) puts(c)
#define blow(arr,st,ed,w) for(register int i = (st);i <= (ed); ++ i) std::cout << arr[i] << w;
#define speed_up() std::ios::sync_with_stdio(false),std::cin.tie(0),std::cout.tie(0)
#define mst(a,k) memset(a,k,sizeof(a))
#define stop return(0)
const int mod = 1e9 + 7;
inline int MOD(int x) {
	if(x < 0) x += mod;
	return x % mod;
}
namespace Newstd {
	inline int read() {
		int ret = 0,f = 0;char ch = getchar();
		while (!isdigit(ch)) {
			if(ch == '-') f = 1;
			ch = getchar();
		}
		while (isdigit(ch)) {
			ret = (ret << 3) + (ret << 1) + ch - 48;
			ch = getchar();
		}
		return f ? -ret : ret;
	}
	inline double double_read() {
		long long ret = 0,w = 1,aft = 0,dot = 0,num = 0;
		char ch = getchar();
		while (!isdigit(ch)) {
			if (ch == '-') w = -1;
			ch = getchar();
		}
		while (isdigit(ch) || ch == '.') {
			if (ch == '.') {
				dot = 1;
			} else if (dot == 0) {
				ret = (ret << 3) + (ret << 1) + ch - 48;
			} else {
				aft = (aft << 3) + (aft << 1) + ch - '0';
				num ++;
			}
			ch = getchar();
		}
		return (pow(0.1,num) * aft + ret) * w;
	}
	inline void write(int x) {
		if(x < 0) {
			putchar('-');
			x = -x;
		}
		if(x > 9) write(x / 10);
		putchar(x % 10 + '0');
	}
}
using namespace Newstd;

const int N = 5e5 + 5;
struct Node {
	int mul,add;
	bool used;
} node[N];
int n;
#undef int
int main(void) {
	#define int long long
	n = read();
	for (register int i = 1;i <= n; ++ i) node[i].mul = read();
	for (register int i = 1;i <= n; ++ i) node[i].add = read();
	int ans = 1;
	for (register int i = 1;i <= n; ++ i) {
		if (node[i].mul == 1) {
			ans = ans + node[i].add;
			node[i].used = true;
		}
	}
	long double Max = ans;
	int pos = -1;
	for (register int i = 1;i <= n; ++ i) {
		if (!node[i].used) {
			long double p = (long double)(ans + node[i].add) / (long double)node[i].mul;
			if (p > Max) {
				Max = p;
				pos = i;
			}
		}
	}
	int res = ans;
	if (pos == -1) {
		for (register int i = 1;i <= n; ++ i) {
			if (!node[i].used) {
				res = res * node[i].mul % mod;
			}
		}
	} else {
		res = res + node[pos].add;
		for (register int i = 1;i <= n; ++ i) {
			if (!node[i].used && i != pos) {
				res = res * node[i].mul % mod;
			}
		}
	}
	printf("%lld\n",res);
	
	return 0;
}
```

---

## 作者：Polaris_Australis_ (赞：1)

[题面](https://www.luogu.com.cn/problem/P8365)

结论：$a_i=1$ 的全部选择加，其余点中最多选择加操作一次。

证明：假设加了多次，则从所加的这些数中选取 $b_i$ 最大的，先加，之后发现，其余所有的数 $+b_i$ 都不足原来的二倍，而选择 $\times a_i$ 则最少为原来二倍，$\times a_i$ 更优，所以之多加一次。

代码：

```cpp
// Problem: P8365 [LNOI2022] 吃
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P8365
// Memory Limit: 256 MB
// Time Limit: 1000 ms
//
// Powered by CP Editor (https://cpeditor.org)

#include <bits/stdc++.h>
#define int __int128_t
#define mod 1000000007
using namespace std;
int n, a[500010], b[500010];
int read() {
  char ch = getchar();
  while (!isdigit(ch)) ch = getchar();
  int ans = 0;
  while (isdigit(ch)) {
    ans = ans * 10 + ch - '0';
    ch = getchar();
  }
  return ans;
}
void write(int x) {
  if (x / 10) write(x / 10);
  putchar((x % 10) | 48);
}
int qp(int x, int y) {
  int cmp = 1;
  while (y) {
    if (y & 1) {
      cmp *= x;
      cmp %= mod;
    }
    x *= x;
    x %= mod;
    y >>= 1;
  }
  return cmp;
}
signed main() {
  n = read();
  for (int i = 1; i <= n; ++i) a[i] = read();
  for (int i = 1; i <= n; ++i) b[i] = read();
  int cnt1 = 1, cnt2 = 1;
  for (int i = 1; i <= n; ++i) {
    if (a[i] == 1)
      cnt1 += b[i];
    else {
      cnt2 *= a[i];
      cnt2 %= mod;
    }
  }
  int cmp1 = 0;
  for (int i = 1; i <= n; ++i) {
    if (a[i] != 1) {
      if (!cmp1) {
        cmp1 = i;
        continue;
      }
      double maxn1 =
          max(((double)1.0 * cnt1 + b[i]) / a[i], (double)1.0 * cnt1);
      double maxn2 =
          max(((double)1.0 * cnt1 + b[cmp1]) / a[cmp1], (double)1.0 * cnt1);
      if (maxn1 > maxn2) {
        cmp1 = i;
      }
    }
  }
  if (!cmp1) {
    write(cnt1 % mod * cnt2 % mod);
    return 0;
  }
  if (((double)1.0 * cnt1 + b[cmp1]) > (double)1.0 * cnt1 * a[cmp1]) {
    cnt1 += b[cmp1];
    cnt2 *= qp(a[cmp1], mod - 2);
    cnt2 %= mod;
  }
  cnt1 %= mod;
  write(cnt1 % mod * cnt2 % mod);
  return 0;
}
```


---

## 作者：happybob (赞：1)

有一种暴力，枚举全排列，然后暴力 dfs，复杂度是 $O(n! \cdot 2^n)$。撇开 `long long` 能不能存得下，这种做法显然超时。

显然，对于任意一种顺序而言，显然应该先做加法再做乘法。所以可以优化，枚举全排列后每次枚举一个位置作为加法和乘法的中断点，复杂度 $O(n! \cdot n)$。

对于每个 $a_i = 1$，显然这个时候一定会选择加上 $b_i$，因为乘以 $1$ 没有贡献，而加上 $b_i$ 却有贡献。

对于 $a_i \neq 1$，可以发现选择加上 $b_i$ 的次数不超过 $1$ 次。假设加了两次 $b_i, b_j$。那么得到的贡献是 $b_i + b_j$，而相乘得到的是 $b_i \cdot a_j$。显然 $a_j \geq 2$，所以 $b_i \cdot a_j \geq b_i + b_j$。

暴力枚举在哪个位置加上 $b_i$，取最大值即可，复杂度 $O(n)$。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
using namespace std;

const int N = 5e5 + 5;
const long long MOD = 1e9 + 7;

long long a[N], b[N], sum = 1;
double maxn = -1e12;

long long mul(long long a, long long b) / 龟速乘，其实不需要
{
	long long res = 0;
	while (b)
	{
		if (b & 1) res = (res + a) % MOD;
		a = (a + a) % MOD;
		b >>= 1;
	}
	return res;
}

int place;
int n;

int main()
{
	ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
	cin >> n;
	for (int i = 1; i <= n; i++)
	{
		cin >> a[i];
	}
	for (int i = 1; i <= n; i++)
	{
		cin >> b[i];
		if (a[i] == 1) sum += b[i];
	}
	maxn = sum;
	for (int i = 1; i <= n; i++) // 枚举哪一个数做加法
	{
		if (a[i] == 1) continue;
		double p = (sum + b[i]) * 1.0 / a[i];
		if (p > maxn)
		{
			maxn = p;
			place = i;
		}
	}
	long long ans = sum % MOD;
	if (!place)
	{
		for (int i = 1; i <= n; i++)
		{
			if (a[i] != 1) ans = mul(ans, a[i]);
		}
	}
	else
	{
		ans += b[place];
		ans %= MOD;
		for (int i = 1; i <= n; i++)
		{
			if (place != i && a[i] != 1) ans = mul(ans, a[i]);
		}
	}
	cout << ans << "\n";
	return 0;
}
```


---

## 作者：cfkk (赞：1)

感谢 [_slb](https://www.luogu.com.cn/user/373429) dalao的思路。

我是一个没有参加省选的菜 OIer 。

思路：

要想体重多，要按照以下方法来做：

- 当 $a_i=1$ 时，一定加 $b_i$ 。

- 一定要先加后乘才能保证答案最大

我们要知道，在 $a_i=1$ 除外，尽量不再使用加法，下面是证明：

假设选择了两次加法，增加的体量是 $b_i+b_j$，那么他对答案的贡献是 $b_i\times s+b_j\times s$，其中 $s$ 表示最终的答案选择乘法的所有乘积。如果选择一次加法一次乘法，他的贡献就是 $b_j\times s\times a_i$ ，显然$b_i\times s+b_j\times s < b_j\times s\times a_i$ 。

假设 $a=1$ 时，的重量为 $cnt$ ，那么把一个数从乘变成加会让全都乘的答案 $ans$ 变成 $ans\times\dfrac{b+cnt}{a\times cnt}$ ，扫一遍找到 $\dfrac{b+cnt}{a\times cnt}$ 的最大值就可以解决这道题了。

代码来喽：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define min(a,b)(a<b?a:b)
#define max(a,b)(a>b?a:b)
#define mod 1000000007
#define int long long
const int maxn=1e6+10;
inline int read()
{
    char ch=getchar();
    int s=0,w=1;
    while(ch<'0'||ch>'9')
    {
        if(ch=='-'){w=-1;}
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        s=(s<<1)+(s<<3)+ch-48;
        ch=getchar();
    }
    return w*s;
}
inline void out(int x)
{
    if(x<0){putchar('-'),x=-x;}
    if(x>9){out(x/10);}
    putchar(x%10+'0');
}
inline void print(int x)
{
    out(x);
    putchar('\n');
}
inline string read_char()
{
    string str="";
    while(1)
    {
        char ch=getchar();
        if(ch=='\n'){break;}
        str+=ch;
    }
    return str;
}
int ans=1;
struct node{int a,b;}a[maxn];
inline double f(int a,int b){return (b+ans)/(long double)1/((long double)a*ans);}//求上面的分数式
int vis[maxn];
signed main()
{
    int n=read();
    for(int i=1;i<=n;i++){a[i].a=read();}
    for(int i=1;i<=n;i++)
    {
        a[i].b=read();
        if(a[i].a==1){ans+=a[i].b,vis[i]=1;}//a[i]=1时必须加
    }
    double d=1;
    int pos=-1;
    for(int i=1;i<=n;i++)
    {
        if(vis[i]){continue;}
        if(f(a[i].a,a[i].b)>=d){pos=i,d=f(a[i].a,a[i].b);}//扫描找到最大的
    }
    if(pos==-1)
    {
        ans%=mod;
        for(int i=1;i<=n;i++)
        {
            if(!vis[i]){ans*=a[i].a,ans%=mod;}//没做标记就乘
        }
        print(ans);
    }
    else
    {
        ans+=a[pos].b,ans%=mod;
        for(int i=1;i<=n;i++)
        {
            if(!vis[i]&&i!=pos){ans*=a[i].a,ans%=mod;}//没做标记就乘
        }
        print(ans);
    }
	return 0;
}

```


---

## 作者：glorious_dream (赞：0)

### 题目分析：

给定两组数据，每一次可以乘一个数或者加一个数，初始值为 $1$，求最终可以获得的最大值。

### 算法分析：

首先有一个很显然的错误做法：以 $a_i$ 升序排序，然后求最大值。

为什么呢？可以发现，不一定 $a_i$ 小的要先加，这样会使答案不是最大值。

来看正确做法：首先，每一个 $a_i=1$ 的情况，我们都要把答案加上 $b_i$，然后会发现，先加后乘一定比先乘后加的答案大，因为因数变大，最后的乘积一定会变大。

接下来看需要加几个数。会发现，要不是就不加，要不是就加一个数。

为什么？因为要不就是直接把每一个 $a_i=1$ 所得的和乘上每一个 $a_i$，要不是一定可以找到一个数，使每一个 $a_i=1$ 所得的和加上这个数，再乘上其余的 $a_i$ 最大。

可以感性理解一下，如果加两次，第二次加和一定会比找到的数乘上第二个 $a_i$ 小，如果不是，一定可以找到另一个满足条件的。

所以这道题目就变成，找出1个或0个数，使其加上所有的 $a_i=1$ 的和除以 $b_i$ 最大。

还要注意一下坑点：要先找出来最大值，然后再进行取模运算。

### 代码：

```cpp
#include<bits/stdc++.h>
#define re register 
#define int long long
#define rep(a,b,c) for(re int a(b) ; a<=c ; ++a)
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch == '-') f=-1 ; ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48) ; ch=getchar();}
	return x*f;
}
const int M = 5e5+10;
const int mod = 1e9+7;
struct dat{
	int mul,add;
}a[M],work[M];
int n;
int sum=1,cheng=1,cnt,pos;
double ans;
signed main(){
	n=read();
	rep(i,1,n) a[i].mul = read();
	rep(i,1,n){
		a[i].add = read();
		if(a[i].mul == 1) sum += a[i].add;
		else work[++cnt].mul=a[i].mul,work[cnt].add=a[i].add;
	}
	ans = sum;
	rep(i,1,cnt){
		double xx = 1.0*(sum+work[i].add)/work[i].mul;
		if(xx > ans) ans = xx,pos = i;
	}
	sum %= mod;
	if(pos != 0) sum = (sum+work[pos].add)%mod;
	rep(i,1,cnt) if(i!=pos) sum = sum*work[i].mul%mod;
	printf("%lld\n",sum);
	return 0;
}
```


---


# [LNOI2022] 题

## 题目描述

给定长度为 $3 n$、值域为 $[0, 3]$ 的整数序列 $S = s_1 s_2 \cdots s_{3 n}$。你需要首先将 $S$ 中的每个 $0$ 替换为 $[1, 3]$ 中的任意一个整数，得到序列 $T = t_1 t_2 \cdots t_{3 n}$，然后给出 $n$ 个长度为 $3$ 的整数序列 ${\{ a_{i, 1}, a_{i, 2}, a_{i, 3} \}}_{1 \le i \le n}$，使得

- $\forall 1 \le i \le n$，$1 \le a_{i, 1} < a_{i, 2} < a_{i, 3} \le 3 n$；
- $\forall (i_1, j_1) \ne (i_2, j_2)$，$a_{i_1, j_1} \ne a_{i_2, j_2}$；
- $\forall 1 \le i \le n$，$\{ t_{a_{i, 1}}, t_{a_{i, 2}}, t_{a_{i, 3}} \}$ 是 $\{ 1, 2, 3 \}$ 的一个排列且逆序对数为奇数。

认为两个方案本质不同当且仅当序列 $T$ 不同或存在 $a_{i, j}$（$1 \le i \le n$，$1 \le j \le 3$）不同，求以上操作的本质不同的方案数，对 $({10}^9 + 7)$ 取模。

## 说明/提示

**【样例解释 \#1】**

前三组测试数据中 $n = 1$，故 $\{ a_{1, 1}, a_{1, 2}, a_{1, 3} \} = \{ 1, 2, 3 \}$。

对于第一组测试数据，只能有 $T = 123$，而 $\{ 1, 2, 3 \}$ 的逆序对数为 $0$ 不合法，故不存在方案。

对于第二组测试数据，$T = 123$ 不合法，而 $T = 132$ 时 $\{ 1, 3, 2 \}$ 的逆序对数为 $1$ 合法，故存在一个方案。

对于第三组测试数据，取 $T = 132$，$T = 213$，$T = 321$ 可以得到三个合法方案。

对于第四组测试数据，$T = 321321$，有如下六种方案：

- $\{ a_{1, 1}, a_{1, 2}, a_{1, 3} \} = \{ 1, 2, 3 \}$，$\{ a_{2, 1}, a_{2, 2}, a_{2, 3} \} = \{ 4, 5, 6 \}$
- $\{ a_{1, 1}, a_{1, 2}, a_{1, 3} \} = \{ 4, 5, 6 \}$，$\{ a_{2, 1}, a_{2, 2}, a_{2, 3} \} = \{ 1, 2, 3 \}$
- $\{ a_{1, 1}, a_{1, 2}, a_{1, 3} \} = \{ 1, 2, 6 \}$，$\{ a_{2, 1}, a_{2, 2}, a_{2, 3} \} = \{ 3, 4, 5 \}$
- $\{ a_{1, 1}, a_{1, 2}, a_{1, 3} \} = \{ 3, 4, 5 \}$，$\{ a_{2, 1}, a_{2, 2}, a_{2, 3} \} = \{ 1, 2, 6 \}$
- $\{ a_{1, 1}, a_{1, 2}, a_{1, 3} \} = \{ 1, 5, 6 \}$，$\{ a_{2, 1}, a_{2, 2}, a_{2, 3} \} = \{ 2, 3, 4 \}$
- $\{ a_{1, 1}, a_{1, 2}, a_{1, 3} \} = \{ 2, 3, 4 \}$，$\{ a_{2, 1}, a_{2, 2}, a_{2, 3} \} = \{ 1, 5, 6 \}$

**【样例 \#2】**

见附件中的 ` problem/problem2.in` 与 `problem/problem2.ans`。

该组样例中五组数据的 $n$ 分别为 $3, 5, 8, 12, 17$。

**【样例 \#3】**

见选手目录下的 `problem/problem3.in` 与 `problem/problem3.ans`。

该组样例满足特殊性质 A，五组数据的 $n$ 分别为 $2, 4, 7, 15, 19$。

**【数据范围】**

对于所有测试数据，$1 \le C \le 5$，$1 \le n \le 19$，字符串 $S$ 的长度为 $3 n$ 且仅由 $0, 1, 2, 3$ 构成。

| 测试点编号 | $n \le$ | 特殊性质 |
|:-:|:-:|:-:|
| $1$ | $1$ | 无 |
| $2$ | $2$ | 无 |
| $3$ | $3$ | 无 |
| $4$ | $5$ | A |
| $5$ | $7$ | 无 |
| $6$ | $10$ | 无 |
| $7$ | $13$ | A |
| $8$ | $16$ | 无 |
| $9$ | $18$ | 无 |
| $10$ | $19$ | 无 |

特殊性质 A：字符串 $S$ 由全 $0$ 的字符串构成。

**【提示】**

请注意程序的空间消耗。

## 样例 #1

### 输入

```
5
1
123
1
100
1
000
2
321321
2
000001
```

### 输出

```
0
1
3
6
60
```

# 题解

## 作者：KaguyaH (赞：16)

逆序对数为奇数的方案只有 $\lbrace 1, 3, 2 \rbrace, \lbrace 2, 1, 3 \rbrace, \lbrace 3, 2, 1 \rbrace$ 三种。

设 $f_{i, j, k, l, o, p, q}$ 表示前 $i$ 个位置，目前凑出的 $\lbrace 1 \rbrace, \lbrace 2 \rbrace, \lbrace 3 \rbrace, \lbrace 1, 3 \rbrace, \lbrace 2, 1 \rbrace, \lbrace 3, 2 \rbrace$ 的数目分别为 $j, k, l, o, p, q$ 的方案数即可。第一维可以滚动数组。

时间复杂度 $O(n^7)$，常数极小，可过。由于 $j + k + l + o + p + q \le n$，所以事实上 $(j, k, l, o, p, q)$ 的取值只有 $\binom {25}{6} \approx 1.77 \times 10^5$ 种。

---

## 作者：ainivolAGEM (赞：8)

**前情提要：**[更好的阅读体验。](https://www.luogu.com.cn/article/eojdyei9)

## 题目大意

[题目](https://www.luogu.com.cn/problem/P8366)给定长度 $3n$、值域为 $[ 0 , 3 ]$ 的序列 $S$，其中 $0$ 可以替换成 $[ 1 , 3 ]$ 中的任何数，替换后的 $S$ 称为 $T$，要求 $n$ 个形如 $\{ a _ { i , 1 } , a _ { i , 2 } , a _ { i , 3 } \} _ { 1 \leq i \leq n }$ 的互不相同三元组，使得：

- $1 \leq a _ { i , 1 } < a _ { i , 2 } < a _ { i , 3 } \leq 3n$

- $\{ t _ { a _ { i , 1 } } , t _ { a _ { i , 2 } } , t _ { a _ { i , 3 } } \}$ 是 $\{ 1 , 2 , 3 \}$ 的一个排列且逆序对数为奇数。

求满足以上条件的方案数，答案对 $( 10 ^ 9 + 7 )$ 取模。

$1 \leq n \leq 19$

## 题目分析

从条件入手，很显然满足条件的三元组只有 $ \{ 1 , 3 , 2 \} , \{ 2 , 1 , 3 \} , \{ 3 , 2 , 1 \}$，考虑其匹配过程，由于 $n$ 不大，考虑 dp。

我们设 $dp _ { i , a , b , c , d , e , f }$ 表示到第 $i$ 位的时候，**前面已经有了** $a$ 个 $\{ 1 \}$、$b$ 个 $\{ 2 \}$、$c$ 个 $\{ 3 \}$、$d$ 个 $ \{ 1 , 2 \}$、$e$ 个 $\{ 1 , 3 \}$、$f$ 个 $\{ 2 , 3 \}$ 的方案数。

转移显然分成三部分即 $t _ i$ 的每位数的三种情况（$0$ 则都可以），但是如果我们**转移到** $dp _ { i , a , b , c , d , e , f }$ 的话很麻烦，要判断很多无解情况，不如**从** $dp _ { i , a , b , c , d , e , f }$ **转移**，这样只需要判断一种情况即可。那么可得转移过程如下：

当 $s _ i = 1$ 或 $s _ i = 0$ 时：

$dp _ { i , a + 1 , b , c , d , e , f } = dp _ { i - 1 , a , b , c , d , e , f }$ （下一个为一个 $1$）

$dp _ { i , a , b - 1 , c , d + 1 , e , f } = dp _ { i - 1 , a , b , c , d , e , f } \times b $ （少 $2$ 多 $ 1 , 2$，由于少的**有多种情况**所以乘上 $b$）

$dp _ { i , a , b , c , d , e , f - 1 } = dp _ { i - 1 , a , b , c , d , e , f } \times f$ （有 $2 , 3$ 可以**匹配**，**匹配的**依然**有多种情况**所以乘上 $f$）

当 $s _ i = 2$ 或 $s _ i = 0$ 时：（后面 dp 原因与前面一致）

$$dp _ { i , a , b + 1 , c , d , e , f } = dp _ { i - 1 , a , b , c , d , e , f }$$

$$dp _ { i , a , b , c - 1 , d , e , f + 1 } = dp _ { i - 1 , a , b , c , d , e , f } \times c $$

$$dp _ { i , a , b , c , d , e - 1 , f } = dp _ { i - 1 , a , b , c , d , e , f } \times e$$

当 $s _ i = 3$ 或 $s _ i = 0$ 时：

$$dp _ { i , a , b , c + 1 , d , e , f } = dp _ { i - 1 , a , b , c , d , e , f }$$

$$dp _ { i , a - 1 , b , c , d , e + 1 , f } = dp _ { i - 1 , a , b , c , d , e , f } \times a $$

$$dp _ { i , a , b , c , d - 1 , e , f } = dp _ { i - 1 , a , b , c , d , e , f } \times d$$

其中，由于我们一开始可以在把**转移项**的不合法情况判掉，然后每次循环都排除掉很明显（比如 $a , b , c ,d ,e , f$ 所占空间不合法）的不合法情况，所以时间复杂度大概在 $10 ^ 5 $ 的量级，可以极限过去。空间的话第一维使用滚动数组优化就过了。由于匹配时**没有标号**，所以最后还需要乘上一个 $n !$。

答案显然为 $dp _ { 3n , 0 , 0 , 0 , 0 , 0 , 0 } \times n !$，记得随时取模。

### code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=20;
const int T=2;
const int MOD=1e9+7;
ll c,n,dp[T][N][N][N][N][N][N];
string s;
ll frac(ll x){
	ll ans=1;
	for(int i=1;i<=x;i++){
		ans*=i;
		ans%=MOD;
	}
	return ans;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>c;
	while(c--){
		cin>>n>>s;
		s='!'+s;
		dp[0][0][0][0][0][0][0]=1;
		for(int i=1;i<=3*n;i++){
			for(int a=0;a<=i&&2*a<=3*n-i+1&&a<=n;a++){
				for(int b=0;a+b<=i&&2*(a+b)<=3*n-i+1&&a+b<=n;b++){
					for(int c=0;a+b+c<=i&&2*(a+b+c)<=3*n-i+1&&a+b+c<=n;c++){
						for(int d=0;a+b+c+2*d<=i&&2*(a+b+c)+d<=3*n-i+1&&a+b+c+d<=n;d++){
							for(int e=0;a+b+c+2*(d+e)<=i&&2*(a+b+c)+d+e<=3*n-i+1&&a+b+c+d+e<=n;e++){
								for(int f=0;a+b+c+2*(d+e+f)<=i&&2*(a+b+c)+d+e+f<=3*n-i+1&&a+b+c+d+e+f<=n;f++){
									dp[i&1][a][b][c][d][e][f]=0;
								}
							}
						}
					}
				}
			}
			for(int a=0;a<=i&&2*a<=3*n-i+1&&a<=n;a++){
				for(int b=0;a+b<=i&&2*(a+b)<=3*n-i+1&&a+b<=n;b++){
					for(int c=0;a+b+c<=i&&2*(a+b+c)<=3*n-i+1&&a+b+c<=n;c++){
						for(int d=0;a+b+c+2*d<=i&&2*(a+b+c)+d<=3*n-i+1&&a+b+c+d<=n;d++){
							for(int e=0;a+b+c+2*(d+e)<=i&&2*(a+b+c)+d+e<=3*n-i+1&&a+b+c+d+e<=n;e++){
								for(int f=0;a+b+c+2*(d+e+f)<=i&&2*(a+b+c)+d+e+f<=3*n-i+1&&a+b+c+d+e+f<=n;f++){
									if(!dp[(i-1)&1][a][b][c][d][e][f]){
										continue;
									}
									if(s[i]-'0'==0||s[i]-'0'==1){
										if(a<n){
											dp[i&1][a+1][b][c][d][e][f]+=dp[(i-1)&1][a][b][c][d][e][f];
											dp[i&1][a+1][b][c][d][e][f]%=MOD;
										}
										if(b&&d<n){
											dp[i&1][a][b-1][c][d+1][e][f]+=dp[(i-1)&1][a][b][c][d][e][f]*b;
											dp[i&1][a][b-1][c][d+1][e][f]%=MOD;
										}
										if(f){
											dp[i&1][a][b][c][d][e][f-1]+=dp[(i-1)&1][a][b][c][d][e][f]*f;
											dp[i&1][a][b][c][d][e][f-1]%=MOD;
										}
									}
									if(s[i]-'0'==0||s[i]-'0'==2){
										if(b<n){
											dp[i&1][a][b+1][c][d][e][f]+=dp[(i-1)&1][a][b][c][d][e][f];
											dp[i&1][a][b+1][c][d][e][f]%=MOD;
										}
										if(c&&f<n){
											dp[i&1][a][b][c-1][d][e][f+1]+=dp[(i-1)&1][a][b][c][d][e][f]*c;
											dp[i&1][a][b][c-1][d][e][f+1]%=MOD;
										}
										if(e){
											dp[i&1][a][b][c][d][e-1][f]+=dp[(i-1)&1][a][b][c][d][e][f]*e;
											dp[i&1][a][b][c][d][e-1][f]%=MOD;
										}
									}
									if(s[i]-'0'==0||s[i]-'0'==3){
										if(c<n){
											dp[i&1][a][b][c+1][d][e][f]+=dp[(i-1)&1][a][b][c][d][e][f];
											dp[i&1][a][b][c+1][d][e][f]%=MOD;
										}
										if(a&&e<n){
											dp[i&1][a-1][b][c][d][e+1][f]+=dp[(i-1)&1][a][b][c][d][e][f]*a;
											dp[i&1][a-1][b][c][d][e+1][f]%=MOD;
										}
										if(d){
											dp[i&1][a][b][c][d-1][e][f]+=dp[(i-1)&1][a][b][c][d][e][f]*d;
											dp[i&1][a][b][c][d-1][e][f]%=MOD;
										}
									}
								}
							}
						}
					}
				}
			}
		}
		cout<<dp[3*n&1][0][0][0][0][0][0]*frac(n)%MOD<<'\n';
		memset(dp,0,sizeof(dp));
	}
}
```

看起来不错，我们交一发。

~~[看什么看，你被卡常了。](https://www.luogu.com.cn/record/166754364)~~

这里有一些卡常小寄巧：

- 别加万能头，一个个加头文件。

- 快读快写优化不能少。

- 能不开就不开 `long long`。

- 把用得多的内容用变量定义下来用。

- 尽量用位运算。

- `fac` 可以提前预处理。

- 最后一次 `memset` 可以特判不写。

修改完差不多就可以[过](https://www.luogu.com.cn/record/166759732)了。

## AC code

```cpp
#include<iostream>
#include<cstring>
using namespace std;
typedef long long ll;
const int MOD=1e9+7;
ll c,n,fac[20];
ll dp[2][20][20][20][20][20][20];
string s;
void print(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9){
		print(x/10);
	}
	putchar(x%10^48);
}
void init(){
	fac[0]=1;
	for(int i=1;i<=19;i++){
		fac[i]=fac[i-1]*i%MOD;
	}
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>c;
	init();
	while(c--){
		cin>>n>>s;
		dp[0][0][0][0][0][0][0]=1;
		for(int i=1;i<=3*n;i++){
			int last=3*n-i+1;
			char now=s[i-1]-'0';
			for(int a=0;a<=i&&2*a<=last&&a<=n;a++){
				for(int b=0;a+b<=i&&2*(a+b)<=last&&a+b<=n;b++){
					for(int c=0;a+b+c<=i&&2*(a+b+c)<=last&&a+b+c<=n;c++){
						for(int d=0;a+b+c+2*d<=i&&2*(a+b+c)+d<=last&&a+b+c+d<=n;d++){
							for(int e=0;a+b+c+2*(d+e)<=i&&2*(a+b+c)+d+e<=last&&a+b+c+d+e<=n;e++){
								for(int f=0;a+b+c+2*(d+e+f)<=i&&2*(a+b+c)+d+e+f<=last&&a+b+c+d+e+f<=n;f++){
									dp[i&1][a][b][c][d][e][f]=0;
								}
							}
						}
					}
				}
			}
			for(int a=0;a<=i&&2*a<=3*n-i+1&&a<=n;a++){
				for(int b=0;a+b<=i&&2*(a+b)<=last&&a+b<=n;b++){
					for(int c=0;a+b+c<=i&&2*(a+b+c)<=last&&a+b+c<=n;c++){
						for(int d=0;a+b+c+2*d<=i&&2*(a+b+c)+d<=last&&a+b+c+d<=n;d++){
							for(int e=0;a+b+c+2*(d+e)<=i&&2*(a+b+c)+d+e<=last&&a+b+c+d+e<=n;e++){
								for(int f=0;a+b+c+2*(d+e+f)<=i&&2*(a+b+c)+d+e+f<=last&&a+b+c+d+e+f<=n;f++){
									ll t=dp[(i-1)&1][a][b][c][d][e][f];
									if(!t){
										continue;
									}
									if(now==0||now==1){
										if(a<n){
											dp[i&1][a+1][b][c][d][e][f]=(dp[i&1][a+1][b][c][d][e][f]+t)%MOD;
										}
										if(b&&d<n){
											dp[i&1][a][b-1][c][d+1][e][f]=(dp[i&1][a][b-1][c][d+1][e][f]+t*b)%MOD;
										}
										if(f){
											dp[i&1][a][b][c][d][e][f-1]=(dp[i&1][a][b][c][d][e][f-1]+t*f)%MOD;
										}
									}
									if(now==0||now==2){
										if(b<n){
											dp[i&1][a][b+1][c][d][e][f]=(dp[i&1][a][b+1][c][d][e][f]+t)%MOD;
										}
										if(c&&f<n){
											dp[i&1][a][b][c-1][d][e][f+1]=(dp[i&1][a][b][c-1][d][e][f+1]+t*c)%MOD;
										}
										if(e){
											dp[i&1][a][b][c][d][e-1][f]=(dp[i&1][a][b][c][d][e-1][f]+t*e)%MOD;
										}
									}
									if(now==0||now==3){
										if(c<n){
											dp[i&1][a][b][c+1][d][e][f]=(dp[i&1][a][b][c+1][d][e][f]+t)%MOD;
										}
										if(a&&e<n){
											dp[i&1][a-1][b][c][d][e+1][f]=(dp[i&1][a-1][b][c][d][e+1][f]+t*a)%MOD;
										}
										if(d){
											dp[i&1][a][b][c][d-1][e][f]=(dp[i&1][a][b][c][d-1][e][f]+t*d)%MOD;
										}
									}
								}
							}
						}
					}
				}
			}
		}
		print(dp[3*n&1][0][0][0][0][0][0]*fac[n]%MOD);
		puts("");
		if(!c){
			break;
		}
		memset(dp,0,sizeof(dp));
	}
}
```

---

## 作者：MatrixCascade (赞：5)

lnoi t2 这么简单的么。。

手玩一下发现满足条件的排列就 $<3,2,1>,<2,1,3>,<1,3,2>$。你考虑在整个序列上数很麻烦，于是去想一边递推一边匹配。

定义 $dp_{cur,i,j,t,a,b,c}$，cur 是当前位置，可以滚动掉，剩下的表示匹配了 $i$ 个 $<1>$，$j$ 个 $<2>$，$t$ 个 $<3>$，$a$ 个 $<3,2>$，$b$ 个 $<2,1>$，$c$ 个 $<1,3>$，转移的时候把和每一种匹配的情况都去转移一遍，匹配完的东西不需要记录。

匹配过程中是没有标号的，所以我们要在结束后给答案乘以一个 $n!$。

状态 $O(n^7)$，转移 $O(1)$，总复杂度 $O(n^7)$，但是 $i+j+t+a+b+c\le n$，所以可以跑过去（次数可以用插板法算一下）。。

[代码](https://www.luogu.com.cn/paste/v43mwkof)、

---

## 作者：_slb (赞：5)

# T2 problem

## Description

给定长度为 $3 n$、值域为 $[0, 3]$ 的整数序列 $S = s_1 s_2 \cdots s_{3 n}$。你需要首先将 $S$ 中的每个 $0$ 替换为 $[1, 3]$ 中的任意一个整数，得到序列 $T = t_1 t_2 \cdots t_{3 n}$，然后给出 $n$ 个长度为 $3$ 的整数序列 ${\{ a_{i, 1}, a_{i, 2}, a_{i, 3} \}}_{1 \le i \le n}$，使得

- $\forall 1 \le i \le n$，$1 \le a_{i, 1} < a_{i, 2} < a_{i, 3} \le 3 n$；
- $\forall (i_1, j_1) \ne (i_2, j_2)$，$a_{i_1, j_1} \ne a_{i_2, j_2}$；
- $\forall 1 \le i \le n$，$\{ t_{a_{i, 1}}, t_{a_{i, 2}}, t_{a_{i, 3}} \}$ 是 $\{ 1, 2, 3 \}$ 的一个排列且逆序对数为奇数。

认为两个方案本质不同当且仅当序列 $T$ 不同或存在 $a_{i, j}$（$1 \le i \le n$，$1 \le j \le 3$）不同，求以上操作的本质不同的方案数，对 $({10}^9 + 7)$ 取模。

$n\leq19$。

## Solution

逆序对数是奇数，也就是说只有 $(1,3,2),(2,1,3),(3,2,1)$ 三种情况。

题目的要求相当于我们把 $3n$ 个数分到 $n$ 个三元组里，不难想到一个 dp：

$g(i,a,b,c,d,e,f)$ 表示当前 $T$ 填了前 $i$ 位，当前为 $(1),(2),(3)$ 的三元组分别有 $a,b,c$ 个；当前为 $(1,3),(2,1),(3,2)$ 的三元组分别有 $d,e,f$ 个的方案数。

这里我们不考虑 $n$ 个三元组的顺序，方案数为 $g(3n,0,0,0,0,0,0)$，再乘上 $n!$ 即可。

转移的时候就枚举这这一位填什么，分到哪个三元组里，乘一个系数转移就好了。

复杂度看似是 $O(n^7)$，但是我们只考虑能转移到最终状态的状态进行转移，比如说 $g(i,n,2,0,0,0,0)$ 这种状态显然就没有意义。多考虑一些类似的状态，状态数会减少很多，可以很快地通过本题。

如果你采用只存合法状态进行转移的方式，我估计会非常快（

## Code

注意空间需要滚动数组。

>这里放一份当前最优解的代码，是一位拒绝透露姓名的神仙在我代码的基础上进行了一波常数优化得到的（

因为有人抄题解，就不放最优解代码了，放一个自己的代码。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cctype>
#include <vector>
#include <array>
using namespace std;

const int mod = 1e9 + 7;
typedef long long ll;

int read()
{
    int x = 0;
    int f = 1;
    char ch = getchar();
    for (; !isdigit(ch); ch = getchar())
        if (ch == '-')
            f = -1;
    for (; isdigit(ch); ch = getchar())
        x = x * 10 + ch - '0';
    return x * f;
}

bool MEM1;

int T;

namespace solve
{
    const int maxn = 100;
    const int maxm = 20;

    int g[2][maxm][maxm][maxm][maxm][maxm][maxm];

    char str[maxn];
    int n;

#define upd(x, y)                \
    {                            \
        x = (x + y) % mod; \
    }
    inline int fac(int n)
    {
        int res = 1;
        for (int i = 1; i <= n; i++)
            res = 1ll * res * i % mod;
        return res;
    }
    void main()
    {
        scanf("%d%s", &n, str + 1);
        g[0][0][0][0][0][0][0] = 1;
        int cur = 1;
        for (int i = 1; i <= n * 3; i++)
        {
            int res = n * 3 - i + 1;
            for (int a = 0; a <= min(i - 1, n) && 2 * a <= res && a <= i; a++)
                for (int b = 0; b <= min(i - 1, n) && 2 * a + 2 * b <= res && a + b <= i && a + b <= n; b++)
                    for (int c = 0; c <= min(i - 1, n) && 2 * a + 2 * b + 2 * c <= res && a + b + c <= i && a + b + c <= n; c++)
                        for (int d = 0; d <= min(i - 1, n) && 2 * a + 2 * b + 2 * c + d <= res && a + b + c + 2 * d <= i && a + b + c + d <= n; d++)
                            for (int e = 0; e <= min(i - 1, n) && 2 * a + 2 * b + 2 * c + d + e <= res && a + b + c + 2 * d + 2 * e <= i && a + b + c + d + e <= n; e++)
                                for (int f = 0; f <= min(i - 1, n) && 2 * a + 2 * b + 2 * c + d + e + f <= res && a + b + c + 2 * d + 2 * e + 2 * f <= i && a + b + c + d + e + f <= n; f++)
                                    g[cur][a][b][c][d][e][f] = 0;
            for (int a = 0; a <= min(i - 1, n) && 2 * a <= res && a <= i; a++)
                for (int b = 0; b <= min(i - 1, n) && 2 * a + 2 * b <= res && a + b <= i && a + b <= n; b++)
                    for (int c = 0; c <= min(i - 1, n) && 2 * a + 2 * b + 2 * c <= res && a + b + c <= i && a + b + c <= n; c++)
                        for (int d = 0; d <= min(i - 1, n) && 2 * a + 2 * b + 2 * c + d <= res && a + b + c + 2 * d <= i && a + b + c + d <= n; d++)
                            for (int e = 0; e <= min(i - 1, n) && 2 * a + 2 * b + 2 * c + d + e <= res && a + b + c + 2 * d + 2 * e <= i && a + b + c + d + e <= n; e++)
                                for (int f = 0; f <= min(i - 1, n) && 2 * a + 2 * b + 2 * c + d + e + f <= res && a + b + c + 2 * d + 2 * e + 2 * f <= i && a + b + c + d + e + f <= n; f++)
                                    if (g[cur ^ 1][a][b][c][d][e][f])
                                    {
                                        int now = str[i] - '0';
                                        ll lst = g[cur ^ 1][a][b][c][d][e][f] % mod;
                                        if (now == 1 || now == 0)
                                        {
                                            if (a < n)
                                                upd(g[cur][a + 1][b][c][d][e][f], lst);
                                            if (c > 0 && f < n)
                                                upd(g[cur][a][b][c - 1][d][e][f + 1], lst * c);
                                            if (e > 0)
                                                upd(g[cur][a][b][c][d][e - 1][f], lst * e);
                                        }
                                        if (now == 2 || now == 0)
                                        {
                                            if (c < n)
                                                upd(g[cur][a][b][c + 1][d][e][f], lst);
                                            if (b > 0 && e < n)
                                                upd(g[cur][a][b - 1][c][d][e + 1][f], lst * b);
                                            if (d > 0)
                                                upd(g[cur][a][b][c][d - 1][e][f], lst * d);
                                        }
                                        if (now == 3 || now == 0)
                                        {
                                            if (b < n)
                                                upd(g[cur][a][b + 1][c][d][e][f], lst);
                                            if (a > 0 && d < n)
                                                upd(g[cur][a - 1][b][c][d + 1][e][f], lst * a);
                                            if (f > 0)
                                                upd(g[cur][a][b][c][d][e][f - 1], lst * f);
                                        }
                                    }
            cur ^= 1;
        }
        cout << g[cur ^ 1][0][0][0][0][0][0] * 1ll * fac(n) % mod << endl;
        if (T == 0)
            return;
        int res = n * 3;
        for (int a = 0; 2 * a <= res && a <= n; a++)
            for (int b = 0; 2 * a + 2 * b <= res && a + b <= n; b++)
                for (int c = 0; 2 * a + 2 * b + 2 * c <= res && a + b + c <= n; c++)
                    for (int d = 0; 2 * a + 2 * b + 2 * c + d <= res && a + b + c + d <= n; d++)
                        for (int e = 0; 2 * a + 2 * b + 2 * c + d + e <= res && a + b + c + d + e <= n; e++)
                            for (int f = 0; 2 * a + 2 * b + 2 * c + d + e + f <= res && a + b + c + d + e + f <= n; f++)
                                g[0][a][b][c][d][e][f] = g[1][a][b][c][d][e][f] = 0;
    }
}

bool MEM2;

int main()
{
    T = read();
    cerr << 1.0 * abs(&MEM1 - &MEM2) / 1024 / 1024 << endl;
    while (T--)
        solve::main();
}
```

---

## 作者：lupengheyyds (赞：2)

## 题面

给定长度为 $3 n$、值域为 $[0, 3]$ 的整数序列 $S = s_1 s_2 \cdots s_{3 n}$。你需要首先将 $S$ 中的每个 $0$ 替换为 $[1, 3]$ 中的任意一个整数，得到序列 $T = t_1 t_2 \cdots t_{3 n}$，然后给出 $n$ 个长度为 $3$ 的整数序列 ${\{ a_{i, 1}, a_{i, 2}, a_{i, 3} \}}_{1 \le i \le n}$，使得：

- $\forall 1 \le i \le n$，$1 \le a_{i, 1} < a_{i, 2} < a_{i, 3} \le 3 n$；
- $\forall (i_1, j_1) \ne (i_2, j_2)$，$a_{i_1, j_1} \ne a_{i_2, j_2}$；
- $\forall 1 \le i \le n$，$\{ t_{a_{i, 1}}, t_{a_{i, 2}}, t_{a_{i, 3}} \}$ 是 $\{ 1, 2, 3 \}$ 的一个排列且逆序对数为奇数。

认为两个方案本质不同当且仅当序列 $T$ 不同或存在 $a_{i, j}$ 不同，求以上操作的本质不同的方案数，对 $({10}^9 + 7)$ 取模。

$1\le n\le 19$

## 题解

先得到序列 $T$，再使得 $a_{i,j}$ 不同，可以看作在处理 $a$ 的过程中，$S$ 中的 $0$ 可以当作 $1，2，3$ 中的任意一个，于是从处理 $a$ 入手。

易得每个长度为 $3$ 的整数序列一定是 $\{1,3,2\},\{2,1,3\},\{3,2,1\}$ 中的一个，考虑成型过程，建立DP。

令 $dp_{i,a,b,c,d,e,f}$ 表示考虑前 $i$ 个数时，其中序列为 $\{1\}$ 的有 $a$ 个，序列为 $\{2\}$ 的有 $b$ 个，序列为 $\{3\}$ 有 $c$ 个，序列为 $\{2,1\}$ 的有 $d$ 个，序列为 $\{1,3\}$ 的有 $e$ 个，序列为 $\{3,2\}$ 的有 $f$ 个，的方案数，有：

$$
dp_{i,a,b,c,d,e,f}=\left\{\begin{aligned}
&dp_{i-1,a-1,b,c,d,e,f}+(b+1)dp_{i-1,a,b+1,c,d-1,e,f}+(f+1)dp_{i-1,a,b,c,d,e,f+1}&&s[i]=1\lor s[i]=0\\
&dp_{i-1,a,b-1,c,d,e,f}+(c+1)dp_{i-1,a,b,c+1,d,e,f-1}+(e+1)dp_{i-1,a,b,c,d,e+1,f} &&s[i]=2\lor s[i]=0\\
&dp_{i-1,a,b,c-1,d,e,f}+(a+1)dp_{i-1,a+1,b,c,d,e-1,f}+(d+1)dp_{i-1,a,b,c,d+1,e,f}&&s[i]=3\lor s[i]=0
\end{aligned}\right.
$$

答案即为 $dp_{3n,0,0,0,0,0,0}$。

由于 $a+b+c+d+e+f\le n$ 合法的状态并不多，只有 $10^5$ 级别，可以通过。

## 方法

- 考虑答案成型过程，在本题中，就是考虑 $\{1,3,2\},\{2,1,3\},\{3,2,1\} $ 的形成过程，建立 DP。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int NN=20,MOD=1e9+7;
int dp[2][NN][NN][NN][NN][NN][NN],n;
string s;
#define loop for(int a=0;2*a<=rest&&a<=n&&a<=i;a++)\
				for(int b=0;2*(a+b)<=rest&&a+b<=n&&a+b<=i;b++)\
					for(int c=0;2*(a+b+c)<=rest&&a+b+c<=n&&a+b+c<=i;c++)\
						for(int o=0;2*(a+b+c)+o<=rest&&a+b+c+o<=n&&a+b+c+2*o<=i;o++)\
							for(int p=0;2*(a+b+c)+o+p<=rest&&a+b+c+o+p<=n&&a+b+c+2*o+2*p<=i;p++)\
								for(int q=0;2*(a+b+c)+o+p+q<=rest&&a+b+c+o+p+q<=n&&a+b+c+2*o+2*p+2*q<=i;q++)
void Upd(int&x,long long y){
	x=(x+y)%MOD;
	return;
}
int Fac(int x){
	int res=1;
	for(int i=1;i<=x;i++){
		res=1ll*res*i%MOD;
	}
	return res;
}
int main(){
	int T;cin>>T;
	while(T--){
		cin>>n>>s;s='\0'+s;
		dp[0][0][0][0][0][0][0]=1;
		for(int i=1;i<=3*n;i++){
			int dgt=s[i]-'0',rest=3*n-i+1;
			loop dp[i&1][a][b][c][o][p][q]=0;
			loop{
				long long lst=dp[(i-1)&1][a][b][c][o][p][q];
				if(!lst)continue;
				if(dgt==1||dgt==0){
					if(a<n)Upd(dp[i&1][a+1][b][c][o][p][q],lst);
					if(b&&o<n)Upd(dp[i&1][a][b-1][c][o+1][p][q],lst*b);
					if(q)Upd(dp[i&1][a][b][c][o][p][q-1],lst*q);
				}if(dgt==2||dgt==0){
					if(b<n)Upd(dp[i&1][a][b+1][c][o][p][q],lst);
					if(c&&q<n)Upd(dp[i&1][a][b][c-1][o][p][q+1],lst*c);
					if(p)Upd(dp[i&1][a][b][c][o][p-1][q],lst*p);
				}if(dgt==3||dgt==0){
					if(c<n)Upd(dp[i&1][a][b][c+1][o][p][q],lst);
					if(a&&p<n)Upd(dp[i&1][a-1][b][c][o][p+1][q],lst*a);
					if(o)Upd(dp[i&1][a][b][c][o-1][p][q],lst*o);
				}
			}
		}
		cout<<1ll*dp[3*n&1][0][0][0][0][0][0]*Fac(n)%MOD<<"\n";
		memset(dp,0,sizeof dp);
	}
	return 0;
} 
```

---

## 作者：xiahaob (赞：1)

这个题目的意思就是说在原序列中选一些子序列。使得每个子序列都为 $132$，$213$ 或 $321$ 的方案数。

那么这个首先可以先去掉顺序。后面成一个 $n!$ 就行了。

那么会有一个直接 dp 的思路。从前往后考虑，就是说考虑现在这个数，要不要单独成为一个子序列。或者连在前面配对的子序列中。

$dp(i,a,b,c,d,e,f)$ 表示考虑前 $i$ 个数，那么配对了 $a$ 个 $1$，$b$ 个 $2$，$c$ 个 $3$。$d$ 个 $13$，$e$ 个 $21$，$f$ 个$32$。

$$
\begin{equation*}
     dp(i,a,b,c,d,e,f)=
     \begin{cases}
     dp(i-1,a-1,b,c,d,e,f)+dp(i-1,a,b+1,c,d,e-1,f)\times (b+1)+dp(i-1,a,b,c,d,e,f+1)\times (f+1) &\ s_i=0 \lor s_i=1\\
     dp(i-1,a,b-1,c,d,e,f)+dp(i-1,a,b,c+1,d,e,f-1)\times (c+1)+dp(i-1,a,b,c,d+1,e,f)\times (d+1) &\ s_i=0 \lor s_i=2\\
     dp(i-1,a,b,c-1,d,e,f)+dp(i-1,a+1,b,c,d-1,e,f)\times (a+1)+dp(i-1,a,b,c,d,e+1,f)\times (e+1) &\ s_i=0 \lor s_i=3\\

     \end{cases}
 \end{equation*}
$$

可以滚掉第一维，时间复杂度看起来是 $O(n^7)$。但是$a+b+c+d+e+f\le n$。所以常数非常小。可以通过。

```cpp
#include<bits/stdc++.h>
#define Rep(i) for(int a=0;a<=min(i,n);++a)for(int b=0;b<=min(i,n)&&a+b<=n;++b)for(int c=0;c<=min(i,n)&&a+b+c<=n;++c)for(int d=0;d<=min(i,n)&&a+b+c+d<=n;++d)for(int e=0;e<=min(i,n)&&a+b+c+d+e<=n;++e)for(int f=0;f<=min(i,n)&&a+b+c+d+e+f<=n;++f)
#define DP dp[a][b][c][d][e][f]
#define G g[a][b][c][d][e][f]
using namespace std;
const int N=21,p=1e9+7;
char s[N*3];
int T,n;
int dp[N][N][N][N][N][N],g[N][N][N][N][N][N];
inline void add(int &x,int y){x+=y;if(x>=p)x-=p;}
inline void solve(){
	scanf("%d",&n);scanf("%s",s+1);
	g[0][0][0][0][0][0]=1;
	for(int i=1;i<=3*n;++i){
		int v=s[i]-'0';
		Rep(i){
			DP=0;
			if(!v||v==1){
				if(a)add(DP,g[a-1][b][c][d][e][f]);
				if(e)add(DP,1ll*g[a][b+1][c][d][e-1][f]*(b+1)%p);
				add(DP,1ll*g[a][b][c][d][e][f+1]*(f+1)%p);
			}
			if(!v||v==2){
				if(b)add(DP,g[a][b-1][c][d][e][f]);
				if(f)add(DP,1ll*g[a][b][c+1][d][e][f-1]*(c+1)%p);
				add(DP,1ll*g[a][b][c][d+1][e][f]*(d+1)%p);
			}
			if(!v||v==3){
				if(c)add(DP,g[a][b][c-1][d][e][f]);
				if(d)add(DP,1ll*g[a+1][b][c][d-1][e][f]*(a+1)%p);
				add(DP,1ll*g[a][b][c][d][e+1][f]*(e+1)%p);
			}
		}
		Rep(i)G=DP;
	}
	int ans=dp[0][0][0][0][0][0];
	for(int i=2;i<=n;++i)ans=1ll*ans*i%p;
	printf("%d\n",ans);
	Rep(n)DP=G=0;//不要放在前面，如果不现在清空，后面 n 小一点可能会遍历到之前的状态。 
}
int main(){
	scanf("%d",&T);
	while(T--)solve();
	return 0;
}
```

---

## 作者：Z3k7223 (赞：1)

## Solution

注意到逆序对为奇数只有 $\set{1,3,2},\set{2,1,3},\set{3,2,1}$ 这三种，除开已经匹配完的三元组，此时匹配到一半的情况有 $\set{1},\set{2},\set{3},\set{1,3},\set{2,1},\set{3,2}$ 六种，设 $dp_{i,a,b,c,d,e,f}$ 表示匹配到第 $i$ 个位置，目前匹配到的 $\set{1},\set{2},\set{3},\set{1,3},\set{2,1},\set{3,2}$ 分别有 $a,b,c,d,e,f$ 个的方案数（若某个三元组匹配完成直接消除，不计入状态中），其中 $i$ 这维可以滚动掉。

接下来分类讨论转移。

若 $s_i=1$ 或 $s_i=0$：

$f_{i,a,b,c,d,e,f}=f_{i-1,a-1,b,c,d,e,f}(a>0)$，直接从头开始匹配一个三元组，初始只匹配了 $\set{1}$。

$f_{i,a,b,c,d,e,f}=(b+1) \times f_{i-1,a,b+1,c,d,e-1,f}(e>0)$，将 $1$ 与前面一个 $\set{2}$ 组合成 $\set{2,1}$，由于前面有 $(b+1)$ 个 $\set{2}$ 可供转移，所以要 $\times (b+1)$。

$f_{i,a,b,c,d,e,f}=(f+1) \times f_{i-1,a,b,c,d,e,f+1}$，将 $1$ 与前面一个 $\set{3,2}$ 组成一个三元组并消除，同理方案数也要 $\times (f+1)$。

后面 $s_i=2$ 和 $s_i=3$ 的情况都差不多：

若 $s_i=2$ 或 $s_i=0$：

$$f_{i,a,b,c,d,e,f}=f_{i-1,a,b-1,c,d,e,f}(b>0)$$

$$f_{i,a,b,c,d,e,f}=(c+1) \times f_{i-1,a,b,c+1,d,e,f-1}(f>0)$$

$$f_{i,a,b,c,d,e,f}=(d+1) \times f_{i-1,a,b,c,d,e,d+1}$$

若 $s_i=3$ 或 $s_i=0$：

$$f_{i,a,b,c,d,e,f}=f_{i-1,a,b,c-1,d,e,f}(c>0)$$

$$f_{i,a,b,c,d,e,f}=(a+1) \times f_{i-1,a+1,b,c,d-1,e,f}(d>0)$$

$$f_{i,a,b,c,d,e,f}=(e+1) \times f_{i-1,a,b,c,d,e+1,f}$$

答案就是全部匹配完后的 $f_{3n,0,0,0,0,0,0}$，但因为没有标号，所以实际答案还要再 $\times n!$。

还有一点要注意的是，由于每个三元组最多只能有一个正在匹配的子串，所以我们可以通过规定 $a+b+c+d+e+f \le n$ 来优化循环次数。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int mod=1e9+7;
int n,dp[2][21][21][21][21][21][21];
//      pos  1   2   3  13  21  32
int s[65];
int jc[20];
void clear(int i){
	for(int a=0;a<=i&&a<=n;a++){
		for(int b=0;a+b<=i&&a+b<=n;b++){
			for(int c=0;a+b+c<=i&&a+b+c<=n;c++){
				for(int d=0;a+b+c+d*2<=i&&a+b+c+d<=n;d++){
					for(int e=0;a+b+c+d*2+e*2<=i&&a+b+c+d+e<=n;e++){
						for(int f=0;a+b+c+d*2+e*2+f*2<=i&&a+b+c+d+e+f<=n;f++){
							dp[i&1][a][b][c][d][e][f]=0;
						}
					}
				}
			}
		}
	}
}
void solve(){
	cin>>n;
	for(int i=1;i<=3*n;i++){
		char ch;
		cin>>ch;
		s[i]=ch-'0';
	}
	dp[0][0][0][0][0][0][0]=1;
	for(int i=1;i<=3*n;i++){
		clear(i);
		for(int a=0;a<=i&&a<=n;a++){
			for(int b=0;a+b<=i&&a+b<=n;b++){
				for(int c=0;a+b+c<=i&&a+b+c<=n;c++){
					for(int d=0;a+b+c+d*2<=i&&a+b+c+d<=n;d++){
						for(int e=0;a+b+c+d*2+e*2<=i&&a+b+c+d+e<=n;e++){
							for(int f=0;a+b+c+d*2+e*2+f*2<=i&&a+b+c+d+e+f<=n;f++){
								if(s[i]==1||s[i]==0){
									if(a){
										dp[i&1][a][b][c][d][e][f]=(dp[i&1][a][b][c][d][e][f]+dp[!(i&1)][a-1][b][c][d][e][f])%mod;
									}
									if(e){//remove 2 to 21
										dp[i&1][a][b][c][d][e][f]=(dp[i&1][a][b][c][d][e][f]+dp[!(i&1)][a][b+1][c][d][e-1][f]*(b+1)%mod)%mod;
									}
									//remove 1 to 321
									dp[i&1][a][b][c][d][e][f]=(dp[i&1][a][b][c][d][e][f]+dp[!(i&1)][a][b][c][d][e][f+1]*(f+1)%mod)%mod;
								}
								if(s[i]==2||s[i]==0){
									if(b){
										dp[i&1][a][b][c][d][e][f]=(dp[i&1][a][b][c][d][e][f]+dp[!(i&1)][a][b-1][c][d][e][f])%mod;
									}
									if(f){//remove 3 to 13
										dp[i&1][a][b][c][d][e][f]=(dp[i&1][a][b][c][d][e][f]+dp[!(i&1)][a][b][c+1][d][e][f-1]*(c+1)%mod)%mod;
									}
									//remove 2 to 132
									dp[i&1][a][b][c][d][e][f]=(dp[i&1][a][b][c][d][e][f]+dp[!(i&1)][a][b][c][d+1][e][f]*(d+1)%mod)%mod;
								}
								if(s[i]==3||s[i]==0){
									if(c){
										dp[i&1][a][b][c][d][e][f]=(dp[i&1][a][b][c][d][e][f]+dp[!(i&1)][a][b][c-1][d][e][f])%mod;
									}
									if(d){//remove 1 to 13
										dp[i&1][a][b][c][d][e][f]=(dp[i&1][a][b][c][d][e][f]+dp[!(i&1)][a+1][b][c][d-1][e][f]*(a+1)%mod)%mod;
									}
									//remove 3 to 213
									dp[i&1][a][b][c][d][e][f]=(dp[i&1][a][b][c][d][e][f]+dp[!(i&1)][a][b][c][d][e+1][f]*(e+1)%mod)%mod;
								}
							}
						}
					}
				}
			}
		}
	}
	cout<<dp[(3*n)&1][0][0][0][0][0][0]*jc[n]%mod<<endl;
	clear(n*3),clear(n*3-1);
}
signed main(){
	jc[0]=1;
	for(int i=1;i<=19;i++){
		jc[i]=jc[i-1]*i%mod;
	}
	int t;
	cin>>t;
	while(t--){
		solve();
	}
	return 0;
}
```

---

## 作者：Locix_Elaina_Celome (赞：0)

# [LNOI2022] 题
> 给一个长 $3n$，值域 $[0,3]$ 的序列，其中 $0$ 要替换为 $[1,3]$ 中别的数。
> 
> 要求将其分成 $n$ 个长 $3$ 的子序列，要求每个子序列的逆序对数量为奇数。子序列间互相区分顺序。
>

首先找出哪些长度为 $3$ 的子序列是合法的，发现是 $\{1,3,2\},\{2,1,3\},\{3,2,1\}$ 三种。

然后就可以考虑 dp 了。

设 $dp_{i,a,b,c,d,e,f}$ 表示考虑前 $i$ 位，有了 $a$ 个 $\{1\}$，$b$ 个 $\{2\}$，$c$ 个 $\{3\}$，$d$ 个 $\{1,2\}$，$e$ 个 $\{1,3\}$，$f$ 个 $\{2,3\}$，

显然在 $a=b=c=d=e=f=0$ 时所有元素就全部匹配成了合法的子序列。

所以直接 dp 转移就好了。

答案即为 $dp_{3n,0,0,0,0,0,0}\times n!$，因为子序列间区分顺序，而我们只算了划分的方案，所以再乘上一个排列。

时间复杂度有点高，但是循环的时候判一下范围剪枝就好了。

```cpp

int dp[2][N][N][N][N][N][N];
int n;
int s[N*3];
int main(){
	int T;
	read(T);
	while(T--){
		read(n);
		char c=getchar();
		while(c<'0'||'3'<c)c=getchar();
		s[0]=c-'0';
		for(int i=1;i<n*3;i++)s[i]=getchar()-'0';
		dp[0][0][0][0][0][0][0]=1;
		for(int i=1;i<=n*3;i++){
			int X=(n*3-i+1);
			for(int a=0;a<=i&&(a<<1)<=X&&a<=n;a++)
				for(int b=0;a+b<=i&&((a+b)<<1)<=X&&a+b<=n;b++)
					for(int c=0;a+b+c<=i&&((a+b+c)<<1)<=X&&a+b+c<=n;c++)
						for(int d=0;a+b+c+(d<<1)<=i&&((a+b+c)<<1)+d<=X&&a+b+c+d<=n;d++)
							for(int e=0;a+b+c+((d+e)<<1)<=i&&((a+b+c)<<1)+d+e<=X&&a+b+c+d+e<=n;e++)
								for(int f=0;a+b+c+((d+e+f)<<1)<=i&&2*(a+b+c)+d+e+f<=X&&a+b+c+d+e+f<=n;f++)
									dp[i&1][a][b][c][d][e][f]=0;
			for(int a=0;a<=i&&(a<<1)<=X&&a<=n;a++){
				for(int b=0;a+b<=i&&((a+b)<<1)<=X&&a+b<=n;b++){
					for(int c=0;a+b+c<=i&&((a+b+c)<<1)<=X&&a+b+c<=n;c++){
						for(int d=0;a+b+c+(d<<1)<=i&&((a+b+c)<<1)+d<=X&&a+b+c+d<=n;d++){
							for(int e=0;a+b+c+((d+e)<<1)<=i&&((a+b+c)<<1)+d+e<=X&&a+b+c+d+e<=n;e++){
								for(int f=0;a+b+c+((d+e+f)<<1)<=i&&2*(a+b+c)+d+e+f<=X&&a+b+c+d+e+f<=n;f++){
									int u=dp[(i&1)^1][a][b][c][d][e][f];
									if(!u)continue;
									if(s[i-1]==1||!s[i-1]){
										if(a<n)dp[i&1][a+1][b][c][d][e][f]=(dp[i&1][a+1][b][c][d][e][f]+u)%P;
										if(b&&d<n)dp[i&1][a][b-1][c][d+1][e][f]=(dp[i&1][a][b-1][c][d+1][e][f]+u*b)%P;
										if(f)dp[i&1][a][b][c][d][e][f-1]=(dp[i&1][a][b][c][d][e][f-1]+u*f)%P;
									}
									if(s[i-1]==2||!s[i-1]){
										if(b<n)dp[i&1][a][b+1][c][d][e][f]=(dp[i&1][a][b+1][c][d][e][f]+u)%P;
										if(c&&f<n)dp[i&1][a][b][c-1][d][e][f+1]=(dp[i&1][a][b][c-1][d][e][f+1]+u*c)%P;
										if(e)dp[i&1][a][b][c][d][e-1][f]=(dp[i&1][a][b][c][d][e-1][f]+u*e)%P;
									}
									if(s[i-1]==3||!s[i-1]){
										if(c<n)dp[i&1][a][b][c+1][d][e][f]=(dp[i&1][a][b][c+1][d][e][f]+u)%P;
										if(a&&e<n)dp[i&1][a-1][b][c][d][e+1][f]=(dp[i&1][a-1][b][c][d][e+1][f]+u*a)%P;
										if(d)dp[i&1][a][b][c][d-1][e][f]=(dp[i&1][a][b][c][d-1][e][f]+u*d)%P;
									}
								}
							}
						}
					}
				}
			}
		}
		int jc=1;
		for(int i=2;i<=n;i++)jc=jc*i%P;
		write(dp[(n*3)&1][0][0][0][0][0][0]*jc%P);
		puts("");
		for(int a=0;a<=n&&(a<<1)<=3*n&&a<=n;a++)
			for(int b=0;a+b<=n&&((a+b)<<1)<=3*n&&a+b<=n;b++)
				for(int c=0;a+b+c<=n&&((a+b+c)<<1)<=3*n&&a+b+c<=n;c++)
					for(int d=0;a+b+c+(d<<1)<=n&&((a+b+c)<<1)+d<=3*n&&a+b+c+d<=n;d++)
						for(int e=0;a+b+c+((d+e)<<1)<=n&&((a+b+c)<<1)+d+e<=3*n&&a+b+c+d+e<=n;e++)
							for(int f=0;a+b+c+((d+e+f)<<1)<=n&&2*(a+b+c)+d+e+f<=3*n&&a+b+c+d+e+f<=n;f++)
								dp[0][a][b][c][d][e][f]=dp[1][a][b][c][d][e][f]=0;
	}
	return 0;
}
```

---

## 作者：_Flame_ (赞：0)

### $\text{solution}$

玩一玩发现性质，只有 $\lbrace1,3,2\rbrace$，$\lbrace2,1,3\rbrace$，$\lbrace3,2,1\rbrace$ 三种三元组逆序对为奇数。

数据范围小，设一个 $dp_{i,j,k,l,m,n,o}$ 表示前 $i$ 个位置凑出 $\lbrace1\rbrace $，$\lbrace2\rbrace $，$\lbrace3\rbrace $，$\lbrace1,3\rbrace $，$\lbrace2,1\rbrace $，$\lbrace3,2\rbrace $ 的数目为 $j,k,l,m,n,o$ 的方案数，简单转移即可。

第一位可以滚动，无用状态要剪枝掉，要不跑不过。

由于不会在匹配三元组时考虑顺序，最后输出答案 $dp_{3\times n,0,0,0,0,0,0}$ 时要乘上 $n$ 的阶乘。

---


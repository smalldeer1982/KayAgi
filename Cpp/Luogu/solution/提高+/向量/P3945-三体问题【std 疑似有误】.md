# 三体问题【std 疑似有误】

## 题目背景

@FirstLight0521 出题人在这里哦~

三体人所居住的星系由于三体运动的不确定性而导致三体星人生活动荡不安，善良的人类程序员（也就是你了！伟大的英雄！）决定帮助愚蠢得连程序都不会写的三体星人模拟天体的运动轨迹。这时，无聊的“歌者”文明决定戏弄一下你，于是给三体星系添加了一些新的星体。


## 题目描述

输入 $N$ 个天体与他们在空间中的坐标 $(x_i,y_i,z_i)$、初速度 $(v_x,v_y,v_z)$ 与质量 $M_i$，已知三体世界受到“歌者”影响时间的流动不是连续的（每 $0.01$ 秒钟刷新一次），天体均视为质点，求 $t$ 时刻所有天体的坐标。

本题万有引力常数 $G$ 取 $6.67408 \times 10^{-11}$，在代码中可以写成：

```cpp
#define G 6.67408e-11
```

当你的答案与标准答案的相对误差不超过 $0.5 \%$ 的时候，你在本测试点得到 AC。也就是说，保留多少位小数你可以自行确定。标准答案将会保留 $12$ 位小数。本题开启 SPJ 判断你的答案是否正确。


## 说明/提示

$3 \le N \le 30,0 \le t \le 100,-100 \le x_i,y_i,z_i \le 100$。$M_i$ 在 `long long` 范围内。

## 样例 #1

### 输入

```
3 100
0 10 0 10000000 0.006207480877613 0 0
8.660254037844 -5 0 10000000 -0.003103740438807 -0.00537583613352 0
-8.660254037844 -5 0 10000000 -0.003103740438807 0.00537583613352 0```

### 输出

```
0.620349511786 9.980741705470 0.000000000000
8.333401109655 -5.527609289167 0.000000000000
-8.953750621441 -4.453132416303 0.000000000000```

## 样例 #2

### 输入

```
3 100
0 10 0 10000000 0.06207480877613 0 0
8.760254037844 -5 0 10000000 -0.03103740438807 -0.0537583613352 0
-8.660254037844 -5 0 10000000 -0.03103740438807 0.0537583613352 0```

### 输出

```
6.204092324054 9.982347016794 0.000000000000
5.642963405596 -10.364100727695 0.000000000000
-11.747055729651 0.381753710901 0.000000000000```

# 题解

## 作者：walk_alone (赞：30)

这个题其实就是一个物理题啊！对高中物理要求的还有点高。  
~~（我这篇题解只讲物理的部分，代码不负责，逃）~~  
题目说三体世界受到“歌者”影响时间的流动不是连续的（每0.01秒钟刷新一次），其实间接的告诉你这题用**微元法：**   
**在极小的时间内，位移还来不及变化，所以受力可以看作是恒力，在这段时间内按匀变速直线运动去处理。**  
不过题目说按0.01s去做其实是降低了难度的。就算是不告诉你变化不连续，也要用微元法这种思想。  
这个题其实就是动力学很基础的一类题，主要的步骤就是**受力分析**然后**运动学**。  
**受力分析**就是将每个星体受到其他星体的万有引力进行合成。直接合成当然是不现实的，所以我们需要**正交分解**。  
首先祭出万有引力公式：  
$F=\frac {GMm} {R^2}$  
坐标系都建好了，正交分解相当于就是把这个力（因为是矢量所以可以分解）分解到$x$方向$y$方向$z$方向上。举个例子：  
有两个星体，坐标为($x_1$,$y_1$,$z_1$),($x_2$,$y_2$,$z_2$)  
令它们的距离为$d$，设万有引力的大小为$F$，对应的矢量设为$\vec{F}=(x,y,z)$，令$\vec{d}$为二者的方向向量，则有$\vec{F}=\lambda\vec{d}$（两个向量共线）   
~~（向量就是矢量）~~  
由向量的基本运算，则有  
$x=\frac{F(x_2-x_1)}{d}$,$y=\frac{F(y_2-y_1)}{d}$,$z=\frac{F(z_2-z_1)}{d}$  
然后将力进行矢量相加（就是把x，y，z方向上的数值相加），得到合力的矢量，然后再用$F=ma$得到每个方向上的加速度（加速度也是矢量，也可以分解）。  
接下来就是**运动学**了
又运动具有独立性，即每个方向上的运动互不干扰，所以可以将位移和速度分成三个方向上进行运算（位移和速度也是矢量，也可以分解）  
（补几个运动学公式）  
速度：$v_t=v_0+at$  
位移：$x=v_0t+\frac{1}{2}at^2$  
如果这些都知道了，那就是个模拟题了。

---

## 作者：机智的岂凡 (赞：16)

占坑发一篇题解

先看二维的

算一下总引力在分到x，y

Fx：Fy：F总=Dx：Dy：D总

再用它算一下就行

记得两个循环都是1~N

判断不等

```cpp
#include <bits/stdc++.h>
using namespace std;
double t0=0.01;
int N;
const int MAXN=39;
int xx,yy;
struct point
{
    double x,y,z;
    double xv,yv,zv,xa,ya,za;
    double a,b,c,d;
    double mass;
};
point pt,m[MAXN],pos[MAXN];
double tt;
int main()
{
    double f0=6.67408e-11;
    cin>>N;
    cin>>tt;
    for(int i=1;i<=N;i++) 
    {
        cin>>m[i].x>>m[i].y>>m[i].z;
        cin>>m[i].mass;
        cin>>m[i].xv>>m[i].yv>>m[i].zv;
    }
    while(tt>0)
    {   
        for(int i=1;i<=N;i++)
        {
            m[i].xa=m[i].ya=m[i].za=0;
            for(int j=1;j<=N;j++)
            {
                if(i!=j){
                double x1=m[i].a=m[j].x-m[i].x;
                double y1=m[i].b=m[j].y-m[i].y;
                double z1=m[i].c=m[j].z-m[i].z;
                m[i].d=sqrt(x1*x1+y1*y1+z1*z1);
                m[i].xa+=m[j].mass*f0*m[i].a/(m[i].d*m[i].d*m[i].d);//引力和距离平方成反比 在乘一个a/d 就是这样
                m[i].ya+=m[j].mass*f0*m[i].b/(m[i].d*m[i].d*m[i].d);//同上
                m[i].za+=m[j].mass*f0*m[i].c/(m[i].d*m[i].d*m[i].d);}
            }
        }
        for(int i=1;i<=N;i++){
        m[i].x+=t0*(m[i].xv+=t0*m[i].xa);
        m[i].y+=t0*(m[i].yv+=t0*m[i].ya);
        m[i].z+=t0*(m[i].zv+=t0*m[i].za);
    }
    //for(int i=1;i<=N;i++) printf("%lf %lf %lf\n",m[i].x,m[i].y,m[i].z);
    //cout<<endl;
    //for(int i=1;i<=50000000;i++);
    //system("cls");
    tt=tt-t0;
    }
    for(int i=1;i<=N;i++) printf("%lf %lf %lf\n",m[i].x,m[i].y,m[i].z);
//system("pause");
return 0;
}
最后问我为什么这么熟练，因为我为了研究天体物理早就自己做了一个……【滑稽】【逃】
```

---

## 作者：Vanilla_chan (赞：13)

# 洛谷 P3945 三体问题

## upd

修改了错别字

## background

在物竞dalao的帮助下（简化下？）终于A了此题，于是在他的提议下来喷出题人。

接下来看题。

## 题意分析

模拟三维空间中$n$个星体的运动，求$Ts$后$n$个星体的坐标。使用微元法，$dt=0.01s$。

$n\le 30,0\le T\le 100$。

精度要求：$0.5\%$。

## Solution

*以下变量大多都是矢量，就不打箭头了*

首先列出~~我们在小学一年级就学过的~~**万有引力公式**
$$
F=\frac{GMm}{r^2}
$$
其中$M,m$分别是两颗星球的质量，$r$是距离。

那么在每时每刻，用$n$个星体的质量和位置就可以算出每对星球之间的相互作用力。

设$F_i$表示第$i$颗星球的受力，则
$$
F_i=\sum_{j=1,j\not =i}^n \frac{Gm_im_j}{r^2}=Gm_i\cdot\sum_{j=1,j\not =i}^n \frac{m_j}{r^2}
$$
那么，根据**牛顿第二定律**$F=am$，这一刻的加速度为
$$
a_i=\frac{F_i}{m_i}=G\sum_{j=1;j\not =i}^n \frac{m_j}{r^2}
$$
*注意这里前面有个$\times m_i$，这里有个$\div m_i$，在程序中可以不用计算了，以保证精度。*

然后再用~~我们在幼儿园就学过的~~基本运动学公式
$$
x=v_0t+\frac12at^2
\\
v=at
$$
当您高高兴兴的算到了这里，觉得这道题配不起它是道蓝题的时候——

欸！我怎么才$38pts$？

难道是要先更新$v$再更新$x$？（即，用$t+dt$时刻的速度$v+a\cdot dt$当作$t$时刻的初速度去计算位移$x$）

欸！用错误的做法反而分更高了？！（$40pts$）

再开个$\texttt{long double}$试试——

欸！才$50pts$？难道要手写实数高精？

看看样例，居然样例跑的都这么吃劲（差距肉眼可见！）

当然也不是控制输出多少位小数的问题，因为错误只会出在$0.005$中。

于是我请$LHQing$来帮我调这一道题（他以前写过一个物理模拟器），在10min后他过了。

原因是，此题$std$认为在$dt$中星球做匀速直线运动，速度只会在每个$dt$之后改变,即
$$
v=at
\\
x=vt
$$
只需要这两个公式，不需要考虑星球在这段$dt$中的加速度！

那么，从某种意义上，$std$的精度岂不是比我的要劣……

## Code

三维矢量

```cpp
struct vector
{
	long double x,y,z;
	vector(long double xx=0,long double yy=0,long double zz=0)
	{
		x=xx,y=yy,z=zz;
	}
	void clear()
	{
		x=y=z=0;
	}
	void in()
	{
		cin>>x>>y>>z;
	}
	void out()
	{
		printf("%Lf %Lf %Lf",x,y,z);
	}
	vector operator+(const vector& b)const
	{
		return vector(x+b.x,y+b.y,z+b.z);
	}
	vector operator+=(const vector& b)
	{
		x+=b.x;
		y+=b.y;
		z+=b.z;
		return *this;
	}
	vector operator*(const long double& b)
	{
		return vector(x*b,y*b,z*b);
	}
	vector operator*=(const long double& b)
	{
		x*=b;
		y*=b;
		z*=b;
		return *this;
	}
	vector operator/(const long double& b)const
	{
		return vector(x/b,y/b,z/b);
	}
}F[100];
```

星球

```cpp
struct Star
{
	vector pos,v;
	long double m;
	IL void in()
	{
		pos.in();
		cin>>m;
		v.in();
	}
	IL void out()
	{
		pos.out();
	}
	
}star[100];
```

计算

```cpp
for(;T>0;T-=dt)
{
	for(int i=1;i<=n;i++) F[i].clear();
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			if(i==j) continue;
			r=(star[i].pos.x-star[j].pos.x)*(star[i].pos.x-star[j].pos.x)+(star[i].pos.y-star[j].pos.y)*(star[i].pos.y-star[j].pos.y)+(star[i].pos.z-star[j].pos.z)*(star[i].pos.z-star[j].pos.z);
			f=G*star[j].m/r;
			F[i]+=vector(f*(star[j].pos.x-star[i].pos.x)/sqrt(r),f*(star[j].pos.y-star[i].pos.y)/sqrt(r),f*(star[j].pos.z-star[i].pos.z)/sqrt(r));
		}
	}
	for(int i=1;i<=n;i++)
	{
		star[i].v+=F[i]*dt;
		star[i].pos+=(star[i].v)*dt;
	}
}
```

**完整代码**

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<limits.h>
#define IL inline
#define re register
#define LL long long
#define ULL unsigned long long
#ifdef TH
#define debug printf("Now is %d\n",__LINE__);
#else
#define debug
#endif
using namespace std;
const long double G = 6.67408e-11;
const long double dt = 1e-2;
int n;
long double T;
struct vector
{
	long double x,y,z;
	vector(long double xx=0,long double yy=0,long double zz=0)
	{
		x=xx,y=yy,z=zz;
	}
	void clear()
	{
		x=y=z=0;
	}
	void in()
	{
		cin>>x>>y>>z;
	}
	void out()
	{
		printf("%Lf %Lf %Lf",x,y,z);
	}
	vector operator+(const vector& b)const
	{
		return vector(x+b.x,y+b.y,z+b.z);
	}
	vector operator+=(const vector& b)
	{
		x+=b.x;
		y+=b.y;
		z+=b.z;
		return *this;
	}
	vector operator*(const long double& b)
	{
		return vector(x*b,y*b,z*b);
	}
	vector operator*=(const long double& b)
	{
		x*=b;
		y*=b;
		z*=b;
		return *this;
	}
	vector operator/(const long double& b)const
	{
		return vector(x/b,y/b,z/b);
	}
}F[100];
struct Star
{
	vector pos,v;
	long double m;
	IL void in()
	{
		pos.in();
		cin>>m;
		v.in();
	}
	IL void out()
	{
		pos.out();
	}
	
}star[100];
int main()
{
	cin>>n>>T;
	for(int i=1;i<=n;i++) star[i].in();
	long double f,r;
	for(;T>0;T-=dt)
	{
		for(int i=1;i<=n;i++) F[i].clear();
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=n;j++)
			{
				if(i==j) continue;
				r=(star[i].pos.x-star[j].pos.x)*(star[i].pos.x-star[j].pos.x)+(star[i].pos.y-star[j].pos.y)*(star[i].pos.y-star[j].pos.y)+(star[i].pos.z-star[j].pos.z)*(star[i].pos.z-star[j].pos.z);
				f=G*star[j].m/r;
				F[i]+=vector(f*(star[j].pos.x-star[i].pos.x)/sqrt(r),f*(star[j].pos.y-star[i].pos.y)/sqrt(r),f*(star[j].pos.z-star[i].pos.z)/sqrt(r));
			}
		}
		for(int i=1;i<=n;i++)
		{
			star[i].v+=F[i]*dt;
			star[i].pos+=(star[i].v)*dt;
		}
	}
	for(int i=1;i<=n;i++)
	{
		star[i].out();
		cout<<endl;
	}
	return 0;
}
```

注意第$95$行，$r$的定义是$r^2$，不先开方是为了精度。

以及玄学的物理计算在第$102,103$行

## 喷喷喷

![](https://cdn.luogu.com.cn/upload/image_hosting/bjwezmgk.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/dw1693bs.png)

---

## 作者：cancan123456 (赞：5)

## 数学基础：

三维空间中 $(x_0,y_0,z_0),(x_1,y_1,z_1)$ 的距离：

$$distance=\sqrt{(x_0-x_1)^2+(y_0-y_1)^2+(z_0-z_1)^2}$$

这个……反正我们学校是在初二的时候讲过。

## 物理基础：

万有引力公式：$F=G\cdot\dfrac{M_1M_2}{r^2}$

$F$ 表示力的大小，$M_1,M_2$ 表示两个物体的质量，$r$ 表示两个物体之间的距离，$G$ 是万有引力常数，即题目中给的 $6.67408\cdot10^{-11}$。

牛顿第二定律：$F=ma$。

$F$ 表示力的大小，$m$ 表示物体的质量，$a$ 表示加速度。

几个运动学公式：

$v=v_0+at$，其中 $v_0$ 表示初速度，$v$ 表示终速度，$a$ 表示加速度，$t$ 表示时间。

$x=v_0t+\dfrac12at^2$，其中 $x$ 表示位移（移动了多长距离），$v_0$ 表示**初速度**，$a$ 表示加速度，$t$ 表示时间。

上面都是高中物理。

假如说有两个物体 $A$ 和 $B$，分别位于 $(x_0,y_0,z_0)$ 和 $(x_1,y_1,z_1)$，设距离为 $r$。

通过上面的物理计算，我们可以得到物体 $A$ 吸引物体 $B$ 的力 $F$。

但是有个小问题：我们需要把这个力 $F$ 分解为在三个方向上（三个坐标轴）的力 $F_x,F_y,F_z$。

通过力的正交分解（高中物理），我们很容易地得出：

$$F_x=\dfrac{F(x_0-x_1)}{r}$$

$$F_y=\dfrac{F(y_0-y_1)}{r}$$

$$F_z=\dfrac{F(z_0-z_1)}{r}$$

然后对于每两个物体，计算它们互相的引力，累加到加速度里面，然后根据速度和位移公式计算就行了。

然后这道题就做完了！

几个小细节：

1. 在此题中，我们不能用上面给出的位移公式计算，要这样：

$$x=v_t0t$$

但是请注意，我们上面给出的公式在现实中是对的！我们上面给出的公式在现实中是对的！我们上面给出的公式在现实中是对的！

2. 不要用 `double`，用 `long double`。

3. 可以通过适当的约分简化计算：

根据 $\begin{cases}F=G\cdot\dfrac{m_1m_2}{r^2}\\F=ma\end{cases}$，我们可以得到：$a=G\cdot\dfrac{m_2}{r^2}$。

4. 先把所有的加速度计算完再计算速度和位移。

给出代码：

```cpp
#include <cstdio>
#include <cmath>
using namespace std;
const long double G = 6.67408e-11;
const long double t = 0.01;
struct Star { // 物体的结构体 
	long double m; // 质量 
	long double x, y, z; // 坐标 
	long double vx, vy, vz; // 速度矢量 
	long double ax = 0.0, ay = 0.0, az = 0.0; // 加速度矢量 
	// 输入 
	void get() {
		scanf("%Lf %Lf %Lf", &x, &y, &z);
		scanf("%Lf", &m);
		scanf("%Lf %Lf %Lf", &vx, &vy, &vz); 
	}
	// 输出 
	void put() {
		printf("%.12Lf %.12Lf %.12Lf\n", x, y, z);
	}
};
struct Galaxy { // 星系 
	Star star[30]; // 星系中的所有星星 
	int n, T; // 题目中给出的 n 和 T 
	void cal() { // 计算 0.01s 内星体的运动 
		for (int i = 0; i < n; i++) {
			star[i].ax = star[i].ay = star[i].az = 0.0;
			for (int j = 0; j < n; j++) {
				if (i != j) {
					// 距离的平方 
					long double dis2 = \
					(star[i].x - star[j].x) * (star[i].x - star[j].x) + \
					(star[i].y - star[j].y) * (star[i].y - star[j].y) + \
					(star[i].z - star[j].z) * (star[i].z - star[j].z);
					// 加速度 
					long double a = G * star[j].m / dis2;
					// 距离 
					long double dis = sqrt(dis2);
					// 正交分解 
					star[i].ax += a * (star[j].x - star[i].x) / dis;
					star[i].ay += a * (star[j].y - star[i].y) / dis;
					star[i].az += a * (star[j].z - star[i].z) / dis;
				}
			}
		}
		for (int i = 0; i < n; i++) {
			// 更新位置 
			star[i].vx += star[i].ax * t;
			star[i].vy += star[i].ax * t;
			star[i].vz += star[i].az * t;
			star[i].x += star[i].vx * t;
			star[i].y += star[i].vy * t;
			star[i].z += star[i].vz * t;
		}
	}
	// 输入 
	void get() {
		scanf("%d %d", &n, &T);
		for (int i = 0; i < n; i++) {
			star[i].get();
		}
	}
	// 输出 
	void put() {
	    for(int i = 0; i < n; i++) {
	    	star[i].put();
		}
	}
	// 求解 T s 内的运动 
	void solve() {
		// 一共有 T / 0.01 = T * 100 个时间单位 
		for (int _ = 0; _ < T * 100; _++) {
			cal();
		}
	}
} galaxy;
int main() {
	galaxy::get();
	galaxy::solve();
	galaxy::put();
	return 0;
}
```

---

## 作者：lzj666_luogu (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P3945)

### 题目注意事项：

本题万有引力常数 $G$ 取 $6.67408 \times 10^{-11}$。

### 做这道题所需的知识：

#### 1：距离公式

在三维空间内有两个点，设第一个点的坐标为 $(x_1,y_1,z_1)$，第二个点的坐标为 $(x_2,y_2,z_2)$，那两点之间的距离 distance 为：

$\operatorname{distance}=\sqrt{(x_2-x_1)^2+(y_2-y_1)^2+(z_2-z_1)^2}$。

#### 2：算加速度的

设 $F$ 表示力的大小，$M_1,M_2$ 表示两个物体的质量，$r$ 表示两个物体之间的距离，$G$ 是万有引力常数，有 $F=G \times \dfrac{M_1 \times M_2}{r^2}$。

而且还有设 $F$ 表示力的大小，$M$ 表示物体的质量，$a$ 表示加速度 $F=M \times a$。

联立可得 $M·a=G \times \dfrac{M_1 \times M_2}{r^2}$。

化简可得 $a=G \times \dfrac{M}{r^2}$。

#### 3：匀变速直线运动的公式

位移公式 $x=v_0t+\frac{1}{2}at^2$。

速度公式 $v=at$。

### 然后就可以开始构思代码了

先定义一个结构体来存天体。

```cpp
struct stars{
	long double x,y,z;//位置 
	long double xv,yv,zv;//三个方向上的速度
	long double nowx,nowy,nowz;//现在的速度改变量 
	long double changex,changey,changez;//计算时的改变量
	long double tmp;
	long double mass;//质量 
}m[MAXN];
```

再解决一下改变量的计算。

```cpp
m[i].changex=m[j].x-m[i].x; m[i].changey=m[j].y-m[i].y; m[i].changez=m[j].z-m[i].z;
//三个方向上的改变量 

m[i].tmp=sqrt(m[i].changex*m[i].changex + m[i].changey*m[i].changey + m[i].changez*m[i].changez);

m[i].nowx += m[j].mass*G/(m[i].tmp*m[i].tmp)/*距离*/ * m[i].changex/(m[i].tmp);
m[i].nowy += m[j].mass*G/(m[i].tmp*m[i].tmp)/*距离*/ * m[i].changey/(m[i].tmp);
m[i].nowz += m[j].mass*G/(m[i].tmp*m[i].tmp)/*距离*/ * m[i].changez/(m[i].tmp);
//引力和距离平方成反比,再乘一个change/tmp
```

最后再解决单位时间内改变的问题。

```cpp
m[i].x+=t0*(m[i].xv+=t0*m[i].nowx);
m[i].y+=t0*(m[i].yv+=t0*m[i].nowy);
m[i].z+=t0*(m[i].zv+=t0*m[i].nowz);
//单位时间内的改变量 
```

再保留一个小数位数。

```cpp
cout<<fixed<<setprecision(12);
```

最后就是完整代码。

```cpp
#include <bits/stdc++.h>
#define G 6.67408e-11
//重力加速度 
using namespace std;

const long double t0=0.01;//单位时间 
const int MAXN=30+10;//最大值 

int n;//天体个数 
long double tt;//时间 

struct stars{
	long double x,y,z;//位置 
	long double xv,yv,zv;//三个方向上的速度
	long double nowx,nowy,nowz;//现在的速度改变量 
	long double changex,changey,changez;//计算时的改变量
	long double tmp;
	long double mass;//质量 
}m[MAXN];

int main(){
	cin>>n>>tt;
	for(int i=1;i<=n;i++){
		cin>>m[i].x>>m[i].y>>m[i].z;//现在的位置 
		cin>>m[i].mass;//质量 
		cin>>m[i].xv>>m[i].yv>>m[i].zv;
	}
	while(tt>0){
		tt-=t0;
		for(int i=1;i<=n;i++){
			m[i].nowx=m[i].nowy=m[i].nowz=0;
			for(int j=1;j<=n;j++){
				if(i!=j){
					m[i].changex=m[j].x-m[i].x; m[i].changey=m[j].y-m[i].y; m[i].changez=m[j].z-m[i].z;
					//三个方向上的改变量 
					m[i].tmp=sqrt(m[i].changex*m[i].changex + m[i].changey*m[i].changey + m[i].changez*m[i].changez);
					
					m[i].nowx += m[j].mass*G/(m[i].tmp*m[i].tmp)/*距离*/ * m[i].changex/(m[i].tmp);
					m[i].nowy += m[j].mass*G/(m[i].tmp*m[i].tmp)/*距离*/ * m[i].changey/(m[i].tmp);
					m[i].nowz += m[j].mass*G/(m[i].tmp*m[i].tmp)/*距离*/ * m[i].changez/(m[i].tmp);
					//引力和距离平方成反比,再乘一个change/tmp
				}
			}
		}
		for(int i=1;i<=n;i++){
			m[i].x+=t0*(m[i].xv+=t0*m[i].nowx);
			m[i].y+=t0*(m[i].yv+=t0*m[i].nowy);
			m[i].z+=t0*(m[i].zv+=t0*m[i].nowz);
			//单位时间内的改变量 
		}
	}
	cout<<fixed<<setprecision(12);
	for(int i=1;i<=n;i++) cout<<m[i].x<<' '<<m[i].y<<' '<<m[i].z<<endl;
	return 0;
}
```

---

## 作者：Astar_renzhiyuan (赞：3)

# 洛谷 P3945 三体问题【std 疑似有误】题解

**这是一道模拟题**

先把常量宏定义一下。

```cpp
#define G 6.67408e-11
#define dt 0.01
```

解决这个问题，首先要知道万有引力公式，和一些必修一的基本公式。
$$
F=\frac{Gm_1m_2}{r^2}
$$

$$
x = 0.5at^2
$$
$$
v = at
$$
其次分析程序执行的步骤。

## 1. 其一，建立结构体并输入。
```cpp
struct node
{
  long double x;
  long double y;
  long double z;
  long double m;
  long double vx;
  long double vy;
  long double vz;
}star[32];
``````
```cpp
for(int i=0;i<n;i++){
   cin>>star[i].x>>star[i].y>>star[i].z>>star[i].m>>star[i].vx>>star[i].vy>>star[i].vz;
}
``````
## 2. 其二，计算加速度。

这里用一个 $mem$ 三维数组，来存放加速度，$aall$ 数组用来存放总加速度。
```cpp
long double aall[N][3];
long double mem[N][N][3];//1星受2星在x方向的加速度记为——mem[1][2][0]
``````


将星星从 $0$ 到 $n-1$ 编号，比如 $mem[1][2][0]$ 的值的含义就是 $1$ 号星球受到 $2$ 号星球在 x 轴方向上的加速度（0 代表 x 轴，1 代表 y 轴，2 代表 z 轴）。
因为：
$$
F = ma
$$
所以：
$$
a = \frac{Gm}{r^2}
$$
**注意这个 $m$ 是施力星球的质量。**

欲求加速度，先算距离，用空间之中的两点距离公式。
```cpp
long double cal_r(long double dx,long double dy,long double dz)
{
    return (sqrt(dx*dx+dy*dy+dz*dz));
}
```
因为一个星球可能受到多个星球的牵引，可能会受到多个加速度，对于多矢量的合成应该用正交分解。

比如在横轴上的矢量：
$$
a_x = \frac{aΔx}{r}
$$
$$
a_x = \frac{GmΔx}{r^3}
$$
由此，给出计算加速度的函数。

```cpp
void cal_a(int opt1,int opt2,long double m2,long double dx,long double dy,long double dz,long double r)
{
    if(r==0)
    {
        mem[opt1][opt2][0]=0;
        mem[opt1][opt2][1]=0;
        mem[opt1][opt2][2]=0;
    }
    mem[opt1][opt2][0]=G*m2*dx/r/r/r;
    mem[opt1][opt2][1]=G*m2*dy/r/r/r;
    mem[opt1][opt2][2]=G*m2*dz/r/r/r;
}
```
$opt1$ 与 $opt2$ 代表的是：编号为 $opt1$ 的星球受到编号为 $opt2$ 的星球给他的加速度。

## 3. 其三，计算速度以及位移。

**一定要注意的一点是，先计算加速后的速度,再算位移。**
因为 $dt$ 极短，这里的速度的变化可以看为：
 $$
v = v_0 + a \times dt
 $$
位移的变化量，可以直接用匀速直线运动的公式计算。
 $$
x = v \times dt
 $$
当然，如果用加速度的位移公式来算的话，不算错，可是原题里面需要的精度很高，如果用速度的位移公式来算的话，很可能会得到一半的分

给出总的操作函数:

```cpp
void optall()
{
    memset(aall,0,sizeof(aall));
    for(int i=0; i<n; i++) //i星受j星的加速度
    {
        for(int j=0; j<n; j++)
        {
            if(i!=j)
            {
                cal_a(i,j,star[j].m,star[j].x-star[i].x,star[j].y-star[i].y,star[j].z-star[i].z,cal_r(star[i].x-star[j].x,star[i].y-star[j].y,star[i].z-star[j].z));
                aall[i][0]+=mem[i][j][0];
                aall[i][1]+=mem[i][j][1];
                aall[i][2]+=mem[i][j][2];
            }
        }
    }
    for(int i=0; i<n; i++)
    {
        star[i].vx+=aall[i][0]*dt;
        star[i].vy+=aall[i][1]*dt;
        star[i].vz+=aall[i][2]*dt;
        star[i].x+=star[i].vx*dt;
        star[i].y+=star[i].vy*dt;
        star[i].z+=star[i].vz*dt;
    }
}
```
然后每 $dt$ 秒就执行一遍这个操作函数。

```cpp
for(long double i=0; i<=t; i+=0.01)
{
    optall();
}
```
记得控制输出的小数位数！

```cpp
for(int i=0; i<n; i++)
{
   cout.precision(12);
   cout<<star[i].x<<" "<<star[i].y<<" "<<star[i].z<<endl;
}
``````
AC code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define G 6.67408e-11
#define dt 0.01
const int N=32;
int n;
long double t;
long double aall[N][3];
long double mem[N][N][3];//1星受2星在x方向的加速度记为——mem[1][2][0]
struct node
{
    long double x=0;
    long double y=0;
    long double z=0;
    long double vx=0;
    long double vy=0;
    long double vz=0;
    long double m=0;
} star[31];
long double cal_r(long double dx,long double dy,long double dz)
{
    return (sqrt(dx*dx+dy*dy+dz*dz));
}
void cal_a(int opt1,int opt2,long double m2,long double dx,long double dy,long double dz,long double r)
{
    if(r==0)
    {
        mem[opt1][opt2][0]=0;
        mem[opt1][opt2][1]=0;
        mem[opt1][opt2][2]=0;
    }
    mem[opt1][opt2][0]=G*m2*dx/r/r/r;
    mem[opt1][opt2][1]=G*m2*dy/r/r/r;
    mem[opt1][opt2][2]=G*m2*dz/r/r/r;
}
void optall()
{
    memset(aall,0,sizeof(aall));
    for(int i=0; i<n; i++) //i星受j星的加速度
    {
        for(int j=0; j<n; j++)
        {
            if(i!=j)
            {
                cal_a(i,j,star[j].m,star[j].x-star[i].x,star[j].y-star[i].y,star[j].z-star[i].z,cal_r(star[i].x-star[j].x,star[i].y-star[j].y,star[i].z-star[j].z));
                aall[i][0]+=mem[i][j][0];
                aall[i][1]+=mem[i][j][1];
                aall[i][2]+=mem[i][j][2];
            }
        }
    }
    for(int i=0; i<n; i++)
    {
        star[i].vx+=aall[i][0]*dt;
        star[i].vy+=aall[i][1]*dt;
        star[i].vz+=aall[i][2]*dt;
        star[i].x+=star[i].vx*dt;
        star[i].y+=star[i].vy*dt;
        star[i].z+=star[i].vz*dt;
    }
}
int main()
{
    cin>>n;
    cin>>t;
    for(int i=0; i<n; i++)
    {
        cin>>star[i].x>>star[i].y>>star[i].z>>star[i].m>>star[i].vx>>star[i].vy>>star[i].vz;
    }
    for(long double i=0; i<=t; i+=0.01)
    {
        optall();
    }
    for(int i=0; i<n; i++)
    {
        cout.precision(12);
        cout<<star[i].x<<" "<<star[i].y<<" "<<star[i].z<<endl;
    }
    return 0;
}
```

---

## 作者：LXcjh4998 (赞：1)

[题目链接](https://www.luogu.com.cn/problem/P3945)
# 题意
给定 $n$ 个天体的位矢 $(r_{ix},r_{iy},r_{iz})$、初速度 $(v_{ix},v_{iy},v_{iz})$ 与 质量 $m_i$，万有引力常数 $G$ 取 $6.67408\times 10^{-11}$，求 $t$ 时刻所有天体的位矢（天体视为质点，单位都为 SI 单位）。

为了简化计算，假设时间的流逝是不连续的，每 $0.01$ 秒刷新一次（下文中，也称 $0.01$ 秒称为**一单位时间**）；并且在一单位时间内，视天体的运动为匀速直线运动。
# 思路
首先列出**本题目背景下**需要用到的物理公式：

- $F=\frac{Gm_1m_2}{r^2}$，$G$ 为万有引力常数，$m_1$、$m_2$ 为两天体的质量，$r$ 为两天体之间的距离。
- $a=\frac{F}{m}$，$F$ 为天体受到的力，$m$ 为 天体的质量。
- $v=v_0+at$，$v$ 为末速度，$v_0$ 为初速度，$a$ 为加速度，$t$ 为经过的时间。
- $r=r_0+vt$，$r$ 为末位矢，$r_0$ 为初位矢，$v$ 为末速度，$t$ 为经过的时间（现实世界中应当是 $r=r_0+\frac{1}{2}at^2$，但由于本题中时间流逝不连续，且在一单位时间内天体的运动视为匀速直线运动，因此修改为上式）。

然后就可以开始模拟了：

- 在一单位时间内，对于每一天体 $i$，计算其他每一天体对其的万有引力所产生的加速度的矢量和；
- 依照上述公式更新每一天体的位矢以及速度。
- 重复上述步骤，直至到达时刻 $t$。

实现时需要注意的几个细节：

- 由于相对误差不得超过 $0.5\%$，因此浮点数类型采用 `long double`；
- 计算天体 $i$ 对天体 $j$ 的万有引力所产生的加速度时，可以先计算加速度 $a$ 的大小，在计算其在 $x$ 轴、$y$ 轴、$z$ 轴 上的分量。具体内容详见代码实现。
- 将每一天体天体的加速度都计算好后，再更新每一天体的位矢和速度。
# 代码
[AC 记录](https://www.luogu.com.cn/record/203767406)

```cpp
#include<cstdlib>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<queue>
#include<cstdio>
#include<iostream>
#include<vector>
#include<map>
#include<cmath>
#include<iomanip>
#include<string>
#include<stack>
#define re register
#define ll long long
#define ull unsigned long long
#define vl __int128
#define ld long double
#define LL 2e18
#define INT 1e9
#define INF 0x3f3f3f3f
#define lb(x) (x&(-x))
#ifdef __linux__
#define gc getchar_unlocked
#define pc putchar_unlocked
#else
#define gc _getchar_nolock
#define pc _putchar_nolock
#endif
int T=1;
using namespace std;
inline bool blank(const char x){return !(x^32)||!(x^10)||!(x^13)||!(x^9);}
template<typename Tp>inline void read(Tp &x){x=0;re bool z=true;re char a=gc();for(;!isdigit(a);a=gc())if(a=='-')z=false;for(;isdigit(a);a=gc())x=(x<<1)+(x<<3)+(a^48);x=(z?x:~x+1);}
inline void read(double &x){x=0.0;re bool z=true;re double y=0.1;re char a=gc();for(;!isdigit(a);a=gc())if(a=='-')z=false;for(;isdigit(a);a=gc())x=x*10+(a^48);if(a!='.')return x=z?x:-x,void();for(a=gc();isdigit(a);a=gc(),y/=10)x+=y*(a^48);x=(z?x:-x);}
inline void read(ld &x){x=0.0;re bool z=true;re ld y=0.1;re char a=gc();for(;!isdigit(a);a=gc())if(a=='-')z=false;for(;isdigit(a);a=gc())x=x*10+(a^48);if(a!='.')return x=z?x:-x,void();for(a=gc();isdigit(a);a=gc(),y/=10)x+=y*(a^48);x=(z?x:-x);}
inline void read(char &x){for(x=gc();blank(x)&&(x^-1);x=gc());}
inline void read(char *x){re char a=gc();for(;blank(a)&&(a^-1);a=gc());for(;!blank(a)&&(a^-1);a=gc())*x++=a;*x=0;}
inline void read(string &x){x="";re char a=gc();for(;blank(a)&&(a^-1);a=gc());for(;!blank(a)&&(a^-1);a=gc())x+=a;}
template<typename T,typename ...Tp>inline void read(T &x,Tp &...y){read(x),read(y...);}
template<typename T>inline void read(T *begin,T *end){re T *i;if(begin<end)for(i=begin;i<end;++i)read(*i);else for(i=begin-1;i>=end;--i)read(*i);}
template<typename Tp>inline void write(Tp x){if(!x)return pc(48),void();if(x<0)pc('-'),x=~x+1;re int len=0;re char tmp[64];for(;x;x/=10)tmp[++len]=x%10+48;while(len)pc(tmp[len--]);}
inline void write(const double x){re int a=6;re double b=x,c=b;if(b<0)pc('-'),b=-b,c=-c;re double y=5*powl(10,-a-1);b+=y,c+=y;re int len=0;re char tmp[64];if(b<1)pc(48);else for(;b>=1;b/=10)tmp[++len]=floor(b)-floor(b/10)*10+48;while(len)pc(tmp[len--]);pc('.');for(c*=10;a;a--,c*=10)pc(floor(c)-floor(c/10)*10+48);}
inline void write(const ld x){re int a=6;re ld b=x,c=b;if(b<0)pc('-'),b=-b,c=-c;re ld y=5*powl(10,-a-1);b+=y,c+=y;re int len=0;re char tmp[64];if(b<1)pc(48);else for(;b>=1;b/=10)tmp[++len]=floor(b)-floor(b/10)*10+48;while(len)pc(tmp[len--]);pc('.');for(c*=10;a;a--,c*=10)pc(floor(c)-floor(c/10)*10+48);}
inline void write(const pair<int,double>x){re int a=x.first;if(a<7){re double b=x.second,c=b;if(b<0)pc('-'),b=-b,c=-c;re double y=5*powl(10,-a-1);b+=y,c+=y;re int len=0;re char tmp[64];if(b<1)pc(48);else for(;b>=1;b/=10)tmp[++len]=floor(b)-floor(b/10)*10+48;while(len)pc(tmp[len--]);a&&(pc('.'));for(c*=10;a;a--,c*=10)pc(floor(c)-floor(c/10)*10+48);}else printf("%.*lf",a,x.second);}
inline void write(const pair<int,ld>x){re int a=x.first;if(a<7){re ld b=x.second,c=b;if(b<0)pc('-'),b=-b,c=-c;re ld y=5*powl(10,-a-1);b+=y,c+=y;re int len=0;re char tmp[64];if(b<1)pc(48);else for(;b>=1;b/=10)tmp[++len]=floor(b)-floor(b/10)*10+48;while(len)pc(tmp[len--]);a&&(pc('.'));for(c*=10;a;a--,c*=10)pc(floor(c)-floor(c/10)*10+48);}else printf("%.*Lf",a,x.second);}
inline void write(const char x){pc(x);}
inline void write(const bool x){pc(x?49:48);}
inline void write(char *x){fputs(x,stdout);}
inline void write(const char *x){fputs(x,stdout);}
inline void write(const string &x){fputs(x.c_str(),stdout);}
template<typename T,typename ...Tp> inline void write(T x,Tp ...y){write(x),write(y...);}
template<typename T>inline void write(T *begin,T *end,const char c=' '){re T *i;for(i=begin;i<end;++i)write(*i,c);}
template<typename T>inline void init(T *begin,T *end,const T& val=T()){re T* i;for(i=begin;i<end;++i)*i=val;}
template<typename T>inline T max(T *begin,T *end){re T *ans,*i;for(i=begin;i<end;++i)if(i==begin||*ans<*i)ans=i;return *ans;}
template<typename T>inline T min(T *begin,T *end){re T *ans,*i;for(i=begin;i<end;++i)if(i==begin||*i<*ans)ans=i;return *ans;}
template<typename T>inline T calc_sum(T *begin,T *end,const T& val=T()){re T ans=val,*i;for(i=begin;i<end;++i)ans+=*i;return ans;}
template<typename T>inline bool is_equal(T *begin,T *end,const T& val=T()){re T *i;for(i=begin;i<end;++i)if(*i!=val)return false;return true;} //模板，无需在意。 

ll mod=0;
const int MAX=30;
const int N=MAX+10;
const ld G=6.67408e-11;
const ld dt=0.01;
//#define DEBUG
//#define more_text
struct planet{
	ld rx,ry,rz; //位矢 
	ld vx,vy,vz; //速度 
	ld ax,ay,az; //加速度 
	ld m;        //质量 
};
inline void read(planet &p){read(p.rx,p.ry,p.rz,p.m,p.vx,p.vy,p.vz);}
inline void write(planet p){write(make_pair(12,p.rx),' ',make_pair(12,p.ry),' ',make_pair(12,p.rz));}

int n;ld t;planet p[N];

void solve(int step){
	read(n,t);
	read(p+1,p+n+1);
	
	while(t>0){
		for(int i=1;i<=n;++i){
			p[i].ax=p[i].ay=p[i].az=0;
			
			for(int j=1;j<=n;++j){
				if(i==j)continue;
				
				ld dx=p[j].rx-p[i].rx,
				   dy=p[j].ry-p[i].ry,
				   dz=p[j].rz-p[i].rz; //计算由 p[i] 的位置引向 p[j] 的位置的矢量在 x 轴、y 轴、z 轴上的分量。 
				
				ld d=sqrt(dx*dx+dy*dy+dz*dz); //计算 p[i] 与 p[j] 之间的距离 。 
				
				ld a=G*p[j].m/(d*d); //a=F/p[i].m
				                     // =(G*p[i].m*p[j].m*p[j].m/(d*d))/p[i].m
				                     // =G*p[j].m/(d*d)
				p[i].ax+=a*dx/d;
				p[i].ay+=a*dy/d;
				p[i].az+=a*dz/d; //计算加速度在  x 轴、y 轴、z 轴上的分量。
			}
		}
		
		for(int i=1;i<=n;++i){
			p[i].vx+=p[i].ax*dt;
			p[i].vy+=p[i].ay*dt;
			p[i].vz+=p[i].az*dt; //计算速度在  x 轴、y 轴、z 轴上的分量。
			
			p[i].rx+=p[i].vx*dt;
			p[i].ry+=p[i].vy*dt;
			p[i].rz+=p[i].vz*dt; //计算位矢在  x 轴、y 轴、z 轴上的分量。
		}
		
		t-=dt;
	}
	
	write(p+1,p+n+1,'\n');
}
int main(){ //模板，无需在意。 
	#ifdef DEBUG
	freopen("test.in","r",stdin);freopen("test.out","w",stdout);
	#endif
	#ifdef more_text
	read(T);
	#endif 
	for(int i=0;i<T;++i)solve(i);
	#ifdef DEBUG
	fclose(stdin);fclose(stdout);
	#endif
	return 0;
}
/*
Input:
3 100
0 10 0 10000000 0.006207480877613 0 0
8.660254037844 -5 0 10000000 -0.003103740438807 -0.00537583613352 0
-8.660254037844 -5 0 10000000 -0.003103740438807 0.00537583613352 0
Output:
0.620349511786 9.980741705470 0.000000000000
8.333401109655 -5.527609289167 0.000000000000
-8.953750621441 -4.453132416303 0.000000000000
Outline:

*/
```

---

## 作者：AlexandreLea (赞：1)

## 题目大意

给定 $n$ 个质点及其在三维上的初速度分量，求在 $t$ 个时间刻后这些质点的位置。

## 题目思路

由于

$$\mathbf F=m\mathbf a=\frac{Gmm'}{|\mathbf d|^2}$$

由于我们可以在左右两边抵掉一项，即

$$|\mathbf a|=\frac{Gm'}{|\mathbf d|^2}$$

接下来，我们可以对加速度进行分解（即将它拆成三个维度上各个的加速度分量），这里 $x,y,z$ 指坐标之差

$$a_x=\frac{|\mathbf a|x}{|\mathbf d|}$$
$$a_y=\frac{|\mathbf a|y}{|\mathbf d|}$$
$$a_z=\frac{|\mathbf a|z}{|\mathbf d|}$$

而后就完了。这里需要先给速度加上加速度，然后再重新对位置进行修改。

代码如下。

```cpp
#include <iostream>
#include <cmath>
#include <iomanip>
#define double long double
#define G 6.67408e-11
using namespace std;
struct mp{
    double x,y,z,vx,vy,vz,m,ax,ay,az;
}suns[31]={};
double sqrdist(mp a,mp b){
    return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)+(a.z-b.z)*(a.z-b.z);
}
int main(){
    int n,t;
    cin>>n>>t;
    for(int i=1;i<=n;i++) cin>>suns[i].x>>suns[i].y>>suns[i].z>>suns[i].m>>suns[i].vx>>suns[i].vy>>suns[i].vz;
    for(int r=1;r<=t*100;r++){
        for(int i=1;i<=n;i++){
            suns[i].ax=suns[i].ay=suns[i].az=0.0;
            for(int j=1;j<=n;j++){
                if(i!=j){
                    double dis2=sqrdist(suns[i],suns[j]),a=G*suns[j].m/dis2,dis=sqrt(dis2);
                    suns[i].ax+=a*(suns[j].x-suns[i].x)/dis;
                    suns[i].ay+=a*(suns[j].y-suns[i].y)/dis;
                    suns[i].az+=a*(suns[j].z-suns[i].z)/dis;
                }
            }
        }
        for(int i=1;i<=n;i++) suns[i].vx+=suns[i].ax*0.01,suns[i].vy+=suns[i].ay*0.01,suns[i].vz+=suns[i].az*0.01,suns[i].x+=suns[i].vx*0.01,suns[i].y+=suns[i].vy*0.01,suns[i].z+=suns[i].vz*0.01;
    }
    cout.precision(12);
    for(int i=1;i<=n;i++) cout<<fixed<<suns[i].x<<" "<<fixed<<suns[i].y<<" "<<fixed<<suns[i].z<<endl;
    return 0;
}
```

**EOF**

---


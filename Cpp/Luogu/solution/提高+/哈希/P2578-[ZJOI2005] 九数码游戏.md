# [ZJOI2005] 九数码游戏

## 题目描述

![](https://cdn.luogu.com.cn/upload/pic/1701.png)


## 说明/提示

由@FlierKing提供SPJ


## 样例 #1

### 输入

```
2 3 0
1 8 7
5 4 6
```

### 输出

```
4
2 3 0
1 8 7
5 4 6

1 2 3
5 8 0
4 6 7

1 2 3
0 5 8
4 6 7

0 1 2
4 5 3
6 7 8

0 1 2
3 4 5
6 7 8
```

# 题解

## 作者：Andorxor (赞：44)

进一步强化广搜，增强代码能力的较好练习题。

思路上和八数码/魔板等题类似，每次一个状态按照两种方式进行扩展，使用队列存储每一种状态，直到弹出的状态是目标状态则结束。几个关键点：

1.输入的是3*3的矩阵，按照数组存储后，可以转换成9位数来表示状态。


2.两种操作，自行模拟下处理过程即可。

```cpp
void move1(int a[4][4]){    //操作一
    int tmp=a[1][1];
    a[1][1]=a[2][1],a[2][1]=a[3][1],a[3][1]=a[3][2];
    a[3][2]=a[3][3],a[3][3]=a[2][3],a[2][3]=a[1][3],a[1][3]=a[1][2],a[1][2]=tmp;
}
void move2(int a[4][4]){    //操作二
    int tmp=a[2][3];
    a[2][3]=a[2][2],a[2][2]=a[2][1],a[2][1]=tmp;
}
```
3.判重：此处如果用普通的数组来存储九位数作为下标判重当然是会超出空间，使用map的方法来进行判重会TLE五个点，因此这里使用的康托展开的方式获取每一种状态（每一个九位数）唯一映射的数字作为数组下标，这样是不会超空间的，因为九位数的全排列的可能性也就是9的阶乘。（不了解康托展开的同学可百度详细了解）


4.输出路径，可以使用数组来保存每一种状态的前驱是谁。（从后往前，想想为什么）

**具体过程看代码，注释写的很详细，代码比较长，细细看清楚每个函数的功能应该是可以很容易看懂代码，之后再自行实现即可。**
```cpp
#include<bits/stdc++.h>
using namespace std;
int cs[4][4],a[4][4],b[4][4],vis[1000000],mb=12345678,cnt,csz;
long long ans[100000];
map<long long,long long>father; //用于存路径
void init();
void bfs();
long long getDec(int a[4][4]);
void updateArr(long long s,int a[4][4]);
int getCantor(long long tmp);
void move1(int a[4][4]);
void move2(int a[4][4]);
void print(long long x);
int getCantor(long long tmp)    //根据九位数字获取对应的康托展开值
{
	int a[9]={0},i=8,ans=0;
	while(tmp!=0){
		a[i]=tmp%10;
		tmp/=10;
		i--;
	}
	for(i=0;i<9;i++)
	{
		int x=0;int c=1,m=1;
		for(int j=i+1;j<9;j++)
		{
			if(a[j]<a[i])x++;
			m*=c;c++;
		}
		ans+=x*m;
	}
	return ans;
}
void print(long long x){    //将数字按照3*3的数组的形式输出
    updateArr(x,a);
    for(int i=1;i<=3;i++){
        for(int j=1;j<=3;j++)
            cout<<a[i][j]<<" ";
        cout<<endl;
    }
    cout<<endl;
}
long long getDec(int a[4][4]){  //3*3数组转化成对应的数字
    long long s=0;
    for(int i=1;i<=3;i++)
        for(int j=1;j<=3;j++)
            s=s*10+a[i][j];
    return s;
}
void updateArr(long long s,int a[4][4]){    //使用数字来更新修改a数组的值
    for(int i=3;i>=1;i--){
        for(int j=3;j>=1;j--){
            a[i][j]=s%10;
            s/=10;
        }
    }
}
void move1(int a[4][4]){    //操作一
    int tmp=a[1][1];
    a[1][1]=a[2][1],a[2][1]=a[3][1],a[3][1]=a[3][2];
    a[3][2]=a[3][3],a[3][3]=a[2][3],a[2][3]=a[1][3],a[1][3]=a[1][2],a[1][2]=tmp;
}
void move2(int a[4][4]){    //操作二
    int tmp=a[2][3];
    a[2][3]=a[2][2],a[2][2]=a[2][1],a[2][1]=tmp;
}
void init(){            //处理输入
    for(int i=1;i<=3;i++)
        for(int j=1;j<=3;j++)
            cin>>cs[i][j];
    csz=getDec(cs);
}
void bfs(){
    queue<long long>q;
    q.push(csz);
    while(!q.empty()){
        long long exted=q.front();
        q.pop();
        if(exted==mb)   //找到了目标
            return;
        updateArr(exted,a); //根据此次拓展的结点更新a数组的值
        memcpy(b,a,sizeof(a));//复制一个a数组：b数组，方便做两种操作（就不需要做完一种操作后恢复）
        long long fa_a=getDec(a),fa_b=getDec(b);//得到a、b数组没操作前对应的数值
        move1(a),move2(b);                      //分别用a、b数组做两种操作
        long long son_a=getDec(a),son_b=getDec(b);//得到a、b数组操作后对应的数值
        int cantor_a=getCantor(son_a),cantor_b=getCantor(son_b);//得到操作后的数值的康托展开式
        if(!vis[cantor_a])                                      //判重：是否出现过
            q.push(son_a),vis[cantor_a]=1,father[son_a]=fa_a;   //使用father数组来记录路径
        if(!vis[cantor_b])
            q.push(son_b),vis[cantor_b]=1,father[son_b]=fa_b;
    }
}
int main(){
    init();
    csz=getDec(cs); //csz：初始值
    bfs();
    father[csz]=0;
    long long tmp=mb;   //mb：目标
    while(father[tmp]){	//如此找到的是倒过来的顺序，所以使用ans数组将结果存一遍
        cnt++;
        tmp=father[tmp];
        ans[cnt]=tmp;   
    }
    if(!cnt){
        cout<<"UNSOLVABLE"<<endl;
        return 0;
    }
    cout<<cnt<<endl;
    for(int i=cnt;i>=1;i--){  //将ans数组倒着输出一遍，即得到从起点到终点的次序
        print(ans[i]);
    }
    print(mb);
    return 0;
}
```


---

## 作者：EXODUS (赞：18)

[题目传送门](https://www.luogu.com.cn/problem/P2578)

[博客食用应该不会更佳](https://www.luogu.com.cn/blog/EXODUS/p2578-ti-xie)

首先，可以看到这个题目里有两种操作，要么旋转，要么移动。希望还原成目标状态，不由得让人想起来好像似乎大概应该差不多有一道叫八数码难题的题，故考虑搜索。

首先排除dfs，因为dfs算法不搜到头不返回，最坏情况下会把所有方案搜一遍，即使搜到了还有可能不是正解，即使高效剪枝也很有可能会TLE，所以考虑bfs。

首先，请自学bfs。
可以看看这三个dalao的

[1](https://www.cnblogs.com/1starfish/p/9403991.html) [2](https://www.imooc.com/article/285772) [3](https://blog.csdn.net/qq_41759198/article/details/81510147)

### 欢迎回来


------------
首先，根据题意，我们可以写出两个移动函数
```cpp
void move1(node &x){
	long long tmp=x.num[1];
    x.num[1]=x.num[4];
    x.num[4]=x.num[7];
    x.num[7]=x.num[8];
    x.num[8]=x.num[9];
    x.num[9]=x.num[6];
    x.num[6]=x.num[3];
    x.num[3]=x.num[2];
    x.num[2]=tmp;
}
void move2(node &x){
	swap(x.num[4],x.num[6]);
	swap(x.num[6],x.num[5]);
}
```

分别对应第一、二种移动方式。

在这里我用一维代替二维，$num_{i}$表示第$(i-1)\%3+1$层的第$i\%3$个数，$node$是一个结构体，表示某个时态下的棋盘状况。

## 接下来是bfs

```cpp
void bfs(){
	node tmp0;
	for(int i=1;i<=9;i++){
		tmp0.num[i]=first_num[i];
	}
	tmp0.now=0;
	tmp0.id=1;
	q.push(tmp0);
	while(!q.empty()){
		tot++;
		node tmp=q.front();
		q.pop();
		if(vis[int(tmp.num[1]*1e7+tmp.num[2]*1e6+tmp.num[3]*1e5+tmp.num[4]*1e4+tmp.num[5]*1e3+tmp.num[6]*1e2+tmp.num[7]*1e1+tmp.num[8])]){
			continue;
		}
		vis[int(tmp.num[1]*1e7+tmp.num[2]*1e6+tmp.num[3]*1e5+tmp.num[4]*1e4+tmp.num[5]*1e3+tmp.num[6]*1e2+tmp.num[7]*1e1+tmp.num[8])]=1;
		bool flag=1;
		for(int i=1;i<=9;i++){
			if(tmp.num[i]!=i-1){
				flag=0;
				break;
			}
		}
		if(flag){
			print(tmp.id);
			exit(0);
		}
		node m1=tmp;
		move1(m1);
		m1.id=(tmp.id*2ll);
		q.push(m1);
		node m2=tmp;
		move2(m2);
		m2.id=(tmp.id*2ll+1ll);
		q.push(m2);
	}
	cout<<"UNSOLVABLE";
	exit(0);
}
```
$tmp0$表示一开始的状态，将其加入队列，每次取出队首元素并进行判重。$flag$用来判断现在是不是目标状态。$m1$表示当前状态进行$move1$后的结果，$m2$表示当前状态进行$move1$后的结果。下面说一下判重。

## 判重
dalao：康拓展开。

#### ~~这对萌新极不友好！！！~~
考虑八数码难题的判重技巧。把原来的数看成一个大数，用vis数组记下。

### 问题是：他开不上去啊！！！
### （你说map？抱歉TLE；你说unordered_map?CCF不承认）
再次考虑进行状态压缩。因为有九个不变的数，所以最后一个数可以考虑不表示，这样数组大小只要开到$10^7$左右的$bool$类型就可以了，不会MLE。

## 下面是最后一个问题：输出。

看到有的dalao用$map$存前驱，没必要。

观察这幅图：

![](https://cdn.luogu.com.cn/upload/image_hosting/nedwspej.png)

这不就是颗二叉树吗？！

等等，二叉树？！

如果我把左子节点抽象成进行$move1$操作的父节点，右子节点抽象成进行$move2$操作的父节点，那么从根节点到达目标节点的路径可以看做从初始状态到目标状态的方式，而路径上经过的所有节点就是要输出的方式，而上文node中的$id$，就是起到了判别儿子的作用。

上图中的$5$号节点应为$7$号，因为$2$号节点的子节点不在了。

至此，我们可以写出$move$函数的逆函数：$return$函数
```cpp
void return1(node &x){
	long long tmp=x.num[1];
    x.num[1]=x.num[2];
    x.num[2]=x.num[3];
    x.num[3]=x.num[6];
    x.num[6]=x.num[9];
    x.num[9]=x.num[8];
    x.num[8]=x.num[7];
    x.num[7]=x.num[4];
    x.num[4]=tmp;
}
void return2(node &x){
	swap(x.num[4],x.num[5]);
	swap(x.num[5],x.num[6]);
}
```
## 接下来是输出
```cpp
void print(long long id){
	long long cnt=0;
	node ansf;
	long long x=log2(id);
	//if(x<0){
		//cout<<"UNSOLVABLE";
		//exit(0);
	//}
	for(int i=1;i<=9;i++){
		ansf.num[i]=i-1;
		ans[i][cnt]=ansf.num[i];
	}
	while(id>1){
		long long x=id%2;
		id/=2;
		if(x==1){
			return2(ansf);
			cnt++;
			for(int i=1;i<=9;i++){
				ans[i][cnt]=ansf.num[i];
			}
		}else{
			return1(ansf);
			cnt++;
			for(int i=1;i<=9;i++){
				ans[i][cnt]=ansf.num[i];
			}
		}
	}
	printf("%lld\n",x);
	for(int i=1;i<=9;i++){
		printf("%lld ",first_num[i]);
		if(!(i%3)){
			printf("\n");
		}
	}
	printf("\n");
	for(int i=cnt-1;i>=0;i--){
		for(long long j=1;j<=9;j++){
			printf("%lld ",ans[j][i]);
			if(!(j%3)){
				printf("\n");
			}
		}
		printf("\n");
	}
	
}
```
解释一下：当我们发现目标节点的编号为$id$时，进行分解二进制。若为$0$进行$return1$函数并保存答案，若为$1$进行$return2$函数并保存答案（应该能想出来，不多说了）
最后放上标程
```cpp
#include <bits/stdc++.h>
using namespace std;
bool vis[987654321];
struct node{
	long long num[14];
	long long now;
	long long id;
};
queue<node>q;
long long first_num[14];
long long ans[9][142857];
long long tot;
void move1(node &x){
	long long tmp=x.num[1];
    x.num[1]=x.num[4];
    x.num[4]=x.num[7];
    x.num[7]=x.num[8];
    x.num[8]=x.num[9];
    x.num[9]=x.num[6];
    x.num[6]=x.num[3];
    x.num[3]=x.num[2];
    x.num[2]=tmp;
}
void move2(node &x){
	swap(x.num[4],x.num[6]);
	swap(x.num[6],x.num[5]);
}
void return1(node &x){
	long long tmp=x.num[1];
    x.num[1]=x.num[2];
    x.num[2]=x.num[3];
    x.num[3]=x.num[6];
    x.num[6]=x.num[9];
    x.num[9]=x.num[8];
    x.num[8]=x.num[7];
    x.num[7]=x.num[4];
    x.num[4]=tmp;
}
void return2(node &x){
	swap(x.num[4],x.num[5]);
	swap(x.num[5],x.num[6]);
}
void print(long long id){
	long long cnt=0;
	node ansf;
	long long x=log2(id);
	for(int i=1;i<=9;i++){
		ansf.num[i]=i-1;
		ans[i][cnt]=ansf.num[i];
	}
	while(id>1){
		long long x=id%2;
		id/=2;
		if(x==1){
			return2(ansf);
			cnt++;
			for(int i=1;i<=9;i++){
				ans[i][cnt]=ansf.num[i];
			}
		}else{
			return1(ansf);
			cnt++;
			for(int i=1;i<=9;i++){
				ans[i][cnt]=ansf.num[i];
			}
		}
	}
	printf("%lld\n",x);
	for(int i=1;i<=9;i++){
		printf("%lld ",first_num[i]);
		if(!(i%3)){
			printf("\n");
		}
	}
	printf("\n");
	for(int i=cnt-1;i>=0;i--){
		for(long long j=1;j<=9;j++){
			printf("%lld ",ans[j][i]);
			if(!(j%3)){
				printf("\n");
			}
		}
		printf("\n");
	}
	
}
void bfs(){
	node tmp0;
	for(int i=1;i<=9;i++){
		tmp0.num[i]=first_num[i];
	}
	tmp0.now=0;
	tmp0.id=1;
	q.push(tmp0);
	while(!q.empty()){
		tot++;
		node tmp=q.front();
		q.pop();
		if(vis[int(tmp.num[1]*1e7+tmp.num[2]*1e6+tmp.num[3]*1e5+tmp.num[4]*1e4+tmp.num[5]*1e3+tmp.num[6]*1e2+tmp.num[7]*1e1+tmp.num[8])]){
			continue;
		}
		vis[int(tmp.num[1]*1e7+tmp.num[2]*1e6+tmp.num[3]*1e5+tmp.num[4]*1e4+tmp.num[5]*1e3+tmp.num[6]*1e2+tmp.num[7]*1e1+tmp.num[8])]=1;
		bool flag=1;
		for(int i=1;i<=9;i++){
			if(tmp.num[i]!=i-1){
				flag=0;
				break;
			}
		}
		if(flag){
			print(tmp.id);
			exit(0);
		}
		node m1=tmp;
		move1(m1);
		m1.id=(tmp.id*2ll);
		q.push(m1);
		node m2=tmp;
		move2(m2);
		m2.id=(tmp.id*2ll+1ll);
		q.push(m2);
	}
	cout<<"UNSOLVABLE";
	exit(0);
}
signed main()
{
	for(int i=1;i<=9;i++){
		cin>>first_num[i];
	}
	bfs();
	return 0;
}
```
# 最后：一定开$long\ long$

有问题请私聊，欢迎各位大佬暴踩。

看到这了，不点个赞行吗？？
## $The\ end$

---

## 作者：2018边境 (赞：13)

### 广搜好题一道，~~深搜几乎驾驭不了~~

关于表示状态的方法，大概有以下几种

#### 方法1:  **9位10进制表示**

优点：容易将矩阵映射成数字

缺点：难以表示转移，无法记录vis数组


~~空间炸死你，不信你试试下面代码交上去~~

```cpp
#include<cstring>
bool vis[876543211];
int main()
{
    memset(vis,0,sizeof(vis));
    /*
	注意：洛谷评测机制是访问多少空间算多少空间，
		  而一般比赛中评测机制是开多大数组算多大
		  memset一下 可确保遍历内部全部空间 
    */ 
	return 0;
}
```

#### 方法2: * *9维数组表示

优点：容易将矩阵映射成数组的一个对应空间、极易表示转移

缺点：~~还是炸空间~~
```cpp
#include<cstring>
bool vis[9][9][9][9][9][9][9][9][9];
int main()
{
    memset(vis,0,sizeof(vis));
	return 0;
}
```

#### 方法3： 康托尔展开
看看**百度定义**


------------


康托展开是一个全排列到一个自然数的双射，常用于构建哈希表时的空间压缩。 康托展开的实质是计算当前排列在所有由小到大全排列中的顺序，因此是可逆的。

----------

通俗地说，就是将一个数列根据字典序映射成一个较小的数，然后优化空间。

###### （代价是略增大时间常数）

这样配合10进制表达状态，简单做一个记忆化优化（由于广搜是 步数少->步数多 搜索，如果两次搜索到同一状态，第二次一定 **不优于** 第一次）

这样写以后，你就会发现

#### _ Submit++，Passed++；_ 

由于很多Dalao已经发过这样的代码了，我就不粘这一方法的代码了。

~~然而，最后几个测试点都要跑大约**900ms**，很不爽，有木有？~~

~~于是乎，天地玄黄，宇宙洪荒……~~
### 方法3+： 16进制优化+康托尔展开
#### 不久，方法3+横空出世
##  前方高能 
##  前方高能 
##  前方高能 

这里选用16进制的原因是：

1.与10进制相同的是，可以直接用一位表达矩阵的1个位置，而且都是一个long long int表达一个状态，空间没有任何劣势

2.可以通过省时间，功能强大的二进制位运算，快速高效地实现状态转移

#### 举个栗子：

#### a b c
#### d e f
#### g h i

用16进制表达就是
#### abcdefghi
执行操作2以后变为
#### a b c
#### f d e
#### g h i
用16进制表达就是
#### abcfdeghi
我们比较两个状态发现
#### 前三位abc和最后三位ghi不变

#### 所以可以直接利用 and 运算一次性提取这6位

#### t&（fff000fff），f表示16进制中的15
then？

#### d和e可以看做一个整体，即可以同理

#### t&（000ff0000）提取然后右移1个16进制位（>>4）转移

#### 同理可以（t&00000f000）<<8转移f

### 最后的最后，三部分或以下就是转移以后结果。

### 很愉（du）快（liu），有木有

由于操作1构成复杂，不详细讲解，但是无论多复杂，也一定比10进制时间常数小很多

上代码
```cpp
#include<cstdio>
bool vis[362883];//每一种状态是否以访问过 
long long sta[362883];//每一种状态的16进制下的数值 
long long Q[362883];//队列，记录状态编码  
int pre[362883];//前驱 
int steps[362883];//步数 
inline int Binary_Find(long long num) 
{
    register int l=1,r=362880/*9的阶乘*/,mid;
    while(l<=r)
    {
        mid=(l+r)>>1;
        if(sta[mid]==num)
        {
            return mid;
        }
        if(sta[mid]<num)
        {
            l=mid+1;
        }
        else r=mid-1;
    }
}
int num;
inline long long Spin(long long t)//操作1·谜之16进制状态转移 
{
	//我也不想换行o(╥﹏╥)o 
    return 
	((t&15732480)<<12)|((t&68451041280)>>4)|((t&255)<<4)|
	((t&61440)>>12)|(t&983040)|((t&251658240)>>12);
}
inline long long Push(long long t)//操作2·谜之16进制状态转移 
{
    return (t&68702703615)|(t&4294967296)|((t&61440)<<8)|((t&16711680)>>4);
}
void dfs(int cnt,long long alr)
{//深搜提前获取出所有状态的16进制表示 
    if(cnt==9)
    {
        sta[++num]=alr;
    }//康托展开，即序列映射成字典序排序 
    for(register int i=0;i<=8;++i)
    {
        if(!vis[i])
        {
            vis[i]=1;
            dfs(cnt+1,(alr<<4)|i);
            vis[i]=0;
        }
    }
}
void print(int pos)//递归输出路径 
{
    if(pos==0)
    {
        return;
        //一定要加在递归语句前面，不然死循环 
    }
    print(pre[pos]);
    long long t=Q[pos];
    long long base=64424509440;
    printf("%d ",(t&base)>>32);
    base>>=4;
    printf("%d ",(t&base)>>28);
    base>>=4;
    printf("%d\n",(t&base)>>24);
    base>>=4;
    printf("%d ",(t&base)>>20);
    base>>=4;
    printf("%d ",(t&base)>>16);
    base>>=4;
    printf("%d\n",(t&base)>>12);
    base>>=4;
    printf("%d ",(t&base)>>8);
    base>>=4;
    printf("%d ",(t&base)>>4);
    base>>=4;
    printf("%d\n\n",t&base);
    return;
}
int main()
{
    dfs(0,0);
    /*
	为啥不
	sort(sta+1,sta+362881)？
	答：根据dfs的特性，搜索记录出的状态顺序一定单调，可以手动模拟一下。 
	*/
    int x;
    for(int i=1;i<=9;++i)
    {
    	scanf("%d",&x);
    	Q[1]=(Q[1]<<4)|x;
		//将初始状态转化为16进制 
    }
    int head=1;
    int tail=1;
    int pos;
    while(head<=tail)
    {//广搜 
        long long cur=Q[head];
        if(cur==305419896/*搜索目标状态，即16进制下的012345678*/) 
        {
            break;
        }
        long long Next=Push(cur);
        pos=Binary_Find(Next);
        if(!vis[pos])
        {
            vis[pos]=1;
            /*
			由于广搜是 步数少->步数多 搜索，
			如果两次搜索到同一状态，
			第二次一定 *不优于* 第一次 ，直接剪枝减掉 
			*/
            Q[++tail]=Next;
            steps[tail]=steps[head]+1;
            pre[tail]=head;
        }
        Next=Spin(cur);
        pos=Binary_Find(Next);
        if(!vis[pos])
        {
            vis[pos]=1;
            Q[++tail]=Next;
            steps[tail]=steps[head]+1;
            pre[tail]=head;
        }
        ++head;
    }
    printf("%d\n",steps[head]);
    print(head);
    return 0;
}
```

---

## 作者：Dilute (赞：11)

其实根本不用什么九维数组之类的那么麻烦啦

（那样写起来多麻烦啊）

也不用康拓展开啊

（那样写起来容易出锅还难调啊）

其实直接状压就行了（具体看代码QwQ）

而且还有件事

就是状压根本不用把每一位都给压进去，只需要把前8位记录就行了

为什么呢？

因为显而易见，我们只要知道前8位，那么最后一位肯定就是已知的

所以记录最后一位显然是多余的

那么我们把

```cpp
1 2 3
4 5 6
7 8 0
```
这个矩阵，我们可以状压成

```cpp
123456789
```

显然，这个数肯定在$10 ^ 8$以内

那么，我们开一个$10 ^ 8$规模的$bool$数组的内存消耗是完全可以接受的

那么就可以愉快的$BFS$啦～～

上代码！

```cpp
#include<bits/stdc++.h>

bool hsh[100000000];

int Zip(int xx[]){ // 将一个表示矩阵的数组转化为一个表示状态的数组
	int Ans = 0;
	for(int i = 1; i <= 8; i++){
		Ans *= 10;
		Ans += xx[i];
	}
	return Ans;
}

struct Point{
	int Step;
	int Sit[10];
    int Last;
}q[1000010];
int qf = 1, qe = 1;

void Dfs(int Cur){
    if(Cur != 1)
        Dfs(q[Cur].Last);
    printf("%d %d %d\n%d %d %d\n%d %d %d\n\n", q[Cur].Sit[1], q[Cur].Sit[2], q[Cur].Sit[3], q[Cur].Sit[4], q[Cur].Sit[5], q[Cur].Sit[6], q[Cur].Sit[7], q[Cur].Sit[8], q[Cur].Sit[9]);
}
int main(){
	char s;
	q[1].Step = 0;
	for(int i = 1; i <= 9; i++){
        scanf("%d", &q[1].Sit[i]);
	}
	while(qf <= qe){
    	if(Zip(q[qf].Sit) == 1234567){
			printf("%d\n", q[qf].Step);
            Dfs(qf);
			return 0;
		}
		Point Prev = q[qf];
        q[++qe] = Prev;
        q[qe].Last = qf;
        q[qe].Step++;
        std::swap(q[qe].Sit[7], q[qe].Sit[4]);
        std::swap(q[qe].Sit[8], q[qe].Sit[7]);
        std::swap(q[qe].Sit[9], q[qe].Sit[8]);
        std::swap(q[qe].Sit[6], q[qe].Sit[9]);
        std::swap(q[qe].Sit[3], q[qe].Sit[6]);
        std::swap(q[qe].Sit[2], q[qe].Sit[3]);
        std::swap(q[qe].Sit[1], q[qe].Sit[2]);
        int kkk = Zip(q[qe].Sit);
        if(hsh[kkk])
            qe--;
        hsh[kkk] = true;

        q[++qe] = Prev;
        q[qe].Last = qf;
        q[qe].Step++;
        std::swap(q[qe].Sit[6], q[qe].Sit[5]);
        std::swap(q[qe].Sit[5], q[qe].Sit[4]);
        kkk = Zip(q[qe].Sit);
        if(hsh[kkk])
            qe--;
        hsh[kkk] = true;
        
        qf++;
	}
    printf("-1");
}
```

---

## 作者：Mr_think (赞：6)

## [P2578 [ZJOI2005]九数码游戏](https://www.luogu.com.cn/problem/P2578)
## 题目大意
给定一个九宫格，通过两种操作变成目标状态，输出最少步数与变化过程。若无法变成目标状态，输出 "UNSOLVABLE" 。
## solution:
考虑使用广搜优化( $\text{BFS}+\text{Hash}$ )。
下面开始广搜。队列中我存了结构体类型，包括两个成员：
```cpp
struct SI{
	string str; //当前状态
	int fl;//当前步数
}q[mo];//mo为哈希模数
```
我们用一个 $\text{string}$ 类型来表示当前的状态，这样方便通过下标实现两种操作。
下面我们构建出广搜框架：
```cpp
int h=1,t=0;
将初始状态入队;
while(h<=t){
	取出队头；
	如果当前状态与目标状态相同，返回当前步数；
	通过两种操作生成两个新状态；
  	判断新状态是否出现过，若没有{
		将该状态的字符串与当前步数+1做成结构题加入队尾；
		将该状态填入哈希表；
		记录路径；
   }
}
```
变换函数如下，直接模拟就好。

路径这里我们可以用一个 $\text{map<long long,long long> lujing}$ 来记录。 $\text{lujing[str]}$ 为此状态的前一步，通过 $\text{while}$ 循环记录答案，最后倒序输出后再输出目标状态即可。省选题，开个 $O2$ 也罢
## 接下来是细节的处理：
记录路径时需要将 $\text{string}$ 类型转换成一个九位数:
```cpp
long long zhuan(string str){
	long long s0,s1,s2,s3,s4,s5,s6,s7,s8;
	s0=(str[0]-'0')*100000000,s1=(str[1]-'0')*10000000,s2=(str[2]-'0')*1000000,
	s3=(str[3]-'0')*100000,   s4=(str[4]-'0')*10000,   s5=(str[5]-'0')*1000,
	s6=(str[6]-'0')*100,      s7=(str[7]-'0')*10,      s8=(str[8]-'0')*1;
	return s0+s1+s2+s3+s4+s5+s6+s7+s8;
}
```
输出这里需要将这个九位数拆开，一位一位输出：
```cpp
//为了避免写崩，我一位一位拆开的[捂脸]
inline void print(long long lu){
	long long s0,s1,s2,s3,s4,s5,s6,s7,s8;
	s8=lu%10,lu/=10,s7=lu%10,lu/=10,s6=lu%10,lu/=10,
	s5=lu%10,lu/=10,s4=lu%10,lu/=10,s3=lu%10,lu/=10,
	s2=lu%10,lu/=10,s1=lu%10,lu/=10,s0=lu%10,lu/=10,
	printf("%lld %lld %lld\n",s0,s1,s2);
	printf("%lld %lld %lld\n",s3,s4,s5);
	printf("%lld %lld %lld\n\n",s6,s7,s8);//此处两个换行！
}
```
看到这的同学，可以自己去写代码了(~~tf口吻~~)

[code](https://www.luogu.com.cn/paste/b5d0uuae)
### End
## 作者的碎碎念：

有用留赞(~~言简意赅~~)

---

## 作者：空の軌跡 (赞：4)

  关于这道题，发现别的dalao们代码很长，其实用不了那么多，60行内就可以解决的

  ~~码风不好，不喜勿喷~~
  
(这些话好像之前说过)

好，我们继续
# 思路

显而易见，又是BFS，我们只需开个结构体，用queue进行宽搜就可以了

至于输出顺序，我们在结构体里建个字符串保存路径，只需把操作记录下来，

最后结束时重新执行操作就可以了



~~所以这道题依然很水~~

访问标记就开个九维数组存就行了，不会爆掉的

# 代码

```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;
struct aq
{
	int t,y,u,g,h,j,b,n,m,time;   //time表示第几次操作，其余对照键盘
	string c;					 //存路径
}m,z;
bool ok[9][9][9][9][9][9][9][9][9];//访问用数组
int main()
{
	//读取很多很多的东西，然后处理并压入队列
	cin>>m.t>>m.y>>m.u>>m.g>>m.h>>m.j>>m.b>>m.n>>m.m;
    queue<aq>qa;
    qa.push(m);
	ok[m.t][m.y][m.u][m.g][m.h][m.j][m.b][m.n][m.m]=1;
    //队列开启BFS搜索
	while(!qa.empty())
	{
		z=qa.front();qa.pop();
        //如果满足条件则进行操作
		if(z.t==0&&z.y==1&&z.u==2&&z.g==3&&z.h==4&&z.j==5&&z.b==6&&z.n==7&&z.m==8)
		{
        	//先输出次数然后输出起始状态
			cout<<z.time<<"\n"<<m.t<<" "<<m.y<<" "<<m.u<<"\n"<<m.g<<" "<<m.h<<" "<<m.j<<"\n"<<m.b<<" "<<m.n<<" "<<m.m<<"\n\n";
			int k=z.c.length();
			for(int i=0;i<k;i++)//遍历字符串进行操作
			{
				if(z.c[i]=='1')//代表  1  操作
				{
					swap(m.t,m.g);swap(m.g,m.b);swap(m.b,m.n);swap(m.n,m.m);
					swap(m.m,m.j);swap(m.j,m.u);swap(m.u,m.y);
				}
				if(z.c[i]=='2')//代表  2  操作
				{
					swap(m.g,m.j);swap(m.j,m.h);
				}
                //输出操作后状态
				cout<<m.t<<" "<<m.y<<" "<<m.u<<"\n"<<m.g<<" "<<m.h<<" "<<m.j<<"\n"<<m.b<<" "<<m.n<<" "<<m.m<<"\n\n";
			}
			return 0;
		}
		z.time++;
        //操作 1
		if(!ok[z.g][z.t][z.y][z.b][z.h][z.u][z.n][z.m][z.j])
		{
			qa.push((aq){z.g,z.t,z.y,z.b,z.h,z.u,z.n,z.m,z.j,z.time,z.c+"1"});
			ok[z.g][z.t][z.y][z.b][z.h][z.u][z.n][z.m][z.j]=1;
		}
        //操作 2
		if(!ok[z.t][z.y][z.u][z.j][z.g][z.h][z.b][z.n][z.m])
		{
			qa.push((aq){z.t,z.y,z.u,z.j,z.g,z.h,z.b,z.n,z.m,z.time,z.c+"2"});
			ok[z.t][z.y][z.u][z.j][z.g][z.h][z.b][z.n][z.m]=1;
		}
	}
    //无解情况
	cout<<"UNSOLVABLE";
}
//很短的几十行代码
```

---

## 作者：mutable (赞：2)

## 思路

显而易见，这是一道BFS的题，但开九维bool数组判重会MLE。于是考虑将每个状态转成一个九位数，用unordered_map判重。然后记录前驱，最后递归输出即可。

## 代码
```cpp
#include<stdio.h>
#include<map>
#include<queue>
#define int long long
using namespace std;
char s[10];
struct node
{
	int a[3][3];//棋盘状态
	int x,y,num,pre;//位置，步数，前驱
} huaji;
map<int,bool> m;//判重
int pos[4][2]= {0,1,1,0,-1,0,0,-1},minn=1427750;//位置数组
int ans[3][3]= {0,1,2,3,4,5,6,7,8};//目标状态
int check(node huajii)//判断是否为目标状态
{
	for(int i=0; i<3; i++)
	{
		for(int j=0; j<3; j++)
		{
			if(ans[i][j]!=huajii.a[i][j])
			{
				return 0;
			}
		}
	}
	return 1;
}
int mytoint(node huajii)//转为9位数
{
	int anss=0;
	for(int i=0; i<3; i++)
	{
		for(int j=0; j<3; j++)
		{
			anss=anss*10+huajii.a[i][j];
		}
	}
	return anss;
}
node q[1000000];//队列
void print(node tt)//输出
{
	if(tt.pre==-1)
	{
		for(int i=0; i<3; i++)
		{
			for(int j=0; j<3; j++)
			{
				printf("%d ",tt.a[i][j]);
			}
			printf("\n");
		}
		printf("\n");
		return;
	}
	print(q[tt.pre]);
	for(int i=0; i<3; i++)
	{
		for(int j=0; j<3; j++)
		{
			printf("%d ",tt.a[i][j]);
		}
		printf("\n");
	}
	printf("\n");
}
signed main()
{
//	scanf("%s",&s);
//	for(int i=0; i<9; i++)
//	{
//		if(s[i]=='0')
//		{
//			huaji.x=i/3;
//			huaji.y=i%3;
//		}
//		huaji.a[i/3][i%3]=s[i]-'0';
//	}
	for(int i=0; i<3; i++)
	{
		for(int j=0; j<3; j++)
		{
			scanf("%d",&huaji.a[i][j]);
			if(huaji.a[i][j]==0)
			{
				huaji.x=i,huaji.y=j;
			}
		}
	}
	huaji.num=0;
	huaji.pre=-1;
	int tail=0,head=1;
	q[tail]=huaji;
	while(tail!=head)
	{
		node ls=q[tail];
		tail++;
		if(check(ls))
		{
			printf("%lld\n",ls.num);
			print(ls);
			return 0;
		}
		node nodenew;
		nodenew.pre=tail-1;
		nodenew.a[0][0]=ls.a[1][0];
		nodenew.a[0][1]=ls.a[0][0];
		nodenew.a[0][2]=ls.a[0][1];
		nodenew.a[1][0]=ls.a[2][0];
		nodenew.a[1][1]=ls.a[1][1];
		nodenew.a[1][2]=ls.a[0][2];
		nodenew.a[2][0]=ls.a[2][1];
		nodenew.a[2][1]=ls.a[2][2];
		nodenew.a[2][2]=ls.a[1][2];
		nodenew.num=ls.num+1;
		if(!m[mytoint(nodenew)])
		{
			m[mytoint(nodenew)]=1;
			q[head++]=nodenew;
		}//操作1
		node nodeneww;
		nodeneww.pre=tail-1;
		nodeneww.a[0][0]=ls.a[0][0];
		nodeneww.a[0][1]=ls.a[0][1];
		nodeneww.a[0][2]=ls.a[0][2];
		nodeneww.a[1][0]=ls.a[1][2];
		nodeneww.a[1][1]=ls.a[1][0];
		nodeneww.a[1][2]=ls.a[1][1];
		nodeneww.a[2][0]=ls.a[2][0];
		nodeneww.a[2][1]=ls.a[2][1];
		nodeneww.a[2][2]=ls.a[2][2];
		nodeneww.num=ls.num+1;
		if(!m[mytoint(nodeneww)])
		{
			m[mytoint(nodeneww)]=1;
			q[head++]=nodeneww;
		}//操作2
	}
	printf("UNSOLVABLE");//无法到达
	return 0;
}
```


---

## 作者：ZigZagKmp (赞：2)

>~~这道题目是我误打误撞找到的~~
>>[R7787384记录(我的)](https://www.luogu.org/record/show?rid=7787384)

>>等待评测有些不耐烦了，就翻到了下面一个评测

>>[R7787385记录](https://www.luogu.org/record/show?rid=7787385)

>于是~~蒟蒻的我用$map$开$O_2$瑟瑟发抖地卡着时限过了~~

### 这不是太难，感觉和[$\color{blue}Magic Squares$](https://www.luogu.org/problemnew/show/P2730)有点像

看到题目中要求最短变换次数，自然想到了广度优先搜索。题目中有说明要打印每一步的变换，那么我们用结构体存储一个人工队列，并且记录下每一个状态的前驱节点下标。

对于状态的保存，我莫名的想到了用$\color{red} string$+$map$。

用$\color{red} string$有几大好处：
- 调试时方便查看
- 编程实现简单
- 写状态改变函数方便快捷
- 可以直接作为STL相关容器类型
- **最重要的一点，不用记康托展开！**
>仅把它当做一个“跳板”——先写一个STL版的程序，确保主算法正确，然后把STL替换成合适的hash。
>--by lrj

[$\color{orange}\text{代码实现}$](http://cc.amazingcounters.com/counter.php?i=3223571&c=9671026)相对简单，在此不多加赘述。

---

## 作者：Beginner_df016 (赞：2)

填一下楼上取名最烦同学（那个我就不说真名了...）埋下的坑...

康托展开...第一遍看到这个名称的时候我是一脸懵逼的...（康托？康熙几世孙？)

其实它的主要作用就是压缩判重量...

举个简单的栗子...我们要判断的内容实质是9的全排列...

如果直接开数组就是[123456789..987654321]（当然如果你倔强地要从0开始我也不拦着...）

一算8亿多，炸内存...预计威力达到学校机房烂掉...

我知道热爱世界和平并且希望有个好成绩的你不会愿意这样子的...

仔细想想其中有很多是浪费掉的，比如198307177这种有重复数字的，不可能出现...

所以康托展开就横空出世了...

公式是这个样子...

X=a[n]\*(n-1)!+a[n-1]\*(n-2)!+...+a[i]\*(i-1)!+...+a[2]\*1!+a[1]\*0!

它求得的实际上是某个排列数的编号...

比如123456789对应的是0，123456798对应的是1，987654321对应的是362879...

这样的话就剩下9!=362880种，存储空间还可以留一部分给你住...（开玩笑...）

具体原理跟那个NOIP2014普及第四题的火星人中“求下一个排列数”类似...

康托展开就是把那一题倒了一下，从求第n个排列数变成了求某个排列数是第几个...

程序这个样子的...那个我P党...



```cpp
function Joker(s:array[1..9]of longint):longint;
var i,j,t:longint;
begin
 Joker:=0;
 for i:=2 to 9 do
  begin
　　t:=0;
　　for j:=1 to i-1 do
　　 if s[i]>s[j] then inc(t);
　　for j:=2 to i-1 do t:=t*j;
　　inc(Joker,t);
  end;
end;
```
初学者建议手算几个排列数试试看...有助于理解...
我废话可能有点多...谢谢你们忍着看到这里...


---

## 作者：Argon_Cube (赞：1)

* **【题目链接】**

[Link:P2578](https://www.luogu.com.cn/problem/P2578)

* **【解题思路】**

这是一篇适合初学者的题解，没有康托展开，没有九维数组，没有十六进制常数优化，吸完氧却比所有题解跑的都快，甚至第一次提交就比之前题解中最快的 $\color{orange}\small\mathsf{EXODUS}$ 还快了 $100ms$ 左右。

正如 $\color{red}\small\mathsf{zltzlt}\color{blue}(\mathsf{qwqaa})$ 所说，这是一道水到不能再水的紫题。

思路肯定是广搜，其它题解已经说过了。此处做大致总结：

1. 用一个数组存储状态去重。
2. 再开一个数组，表示这个状态从哪个状态转移而来。
3. 规划好如何压缩状态，一般用康托展开。
4. 搜索一遍，通过。

我说一说我对这个思路的具体化。

数组去重，本来想用```vector```，但是后来发现查找太耗时间，便没有采纳。

正好要存前驱，所以决定用```unordered_map```，哈希的复杂度非常优秀。

压缩状态中康托展开较复杂，所以可以转换为 $9$ 位数存储，空间完全不占劣势。

由于十进制数字不便操作，可以再转为字符数组。

以上两个功能可以集成在一个函数里。

* **【实现细节】**

在搜索中如果先搜操作 $1$，恢复原状态成本较大，所以本代码选择先搜操作 $2$，还原后再搜操作 $1$，最后下一次循环直接覆盖原字符数组。

* **【代码实现】**

```cpp
#include <unordered_map>
#include <iostream>
#include <queue>
#include <stack>

using namespace std;

enum convert_state{int_mtx=false,mtx_int=true};//指示convert函数转换方式，int_mtx为数值转矩阵，mtx_int为矩阵转数值

inline void convert(convert_state cvtstate,int& inttarg,char(* mtxtarg)[3]/*必须写成这样不然编译不给过*/)
{
	if(!cvtstate)//数值转矩阵
	{
		int intarg=inttarg;
		for(int i=2;i>=0;i--)
			for(int j=2;j>=0;j--)
				mtxtarg[i][j]=intarg%10+'0',intarg/=10;
	}
	else//矩阵转数值
	{
		inttarg=0;
		for(int i=0;i<3;i++)
			for(int j=0;j<3;j++)
				inttarg=inttarg*10+mtxtarg[i][j]-'0';
	}
}

int main(int argc,char *argv[],char *envp[])
{
	unordered_map<int,int> states;//去重用unordered_map
	char matrix[3][3];
	for(int i=0;i<3;i++)
		for(int j=0;j<3;j++)
			cin>>matrix[i][j];
	queue<int> BFS_que;
	int tmp,temp;
	convert(mtx_int,tmp,matrix);
	BFS_que.push(tmp);
	states[tmp]=-1;
	while(!BFS_que.empty())
	{
		convert(int_mtx,BFS_que.front(),matrix);
		temp=BFS_que.front();
		swap(matrix[1][2],matrix[1][1]);//操作2
		swap(matrix[1][0],matrix[1][1]);
		convert(mtx_int,tmp,matrix);
		swap(matrix[1][0],matrix[1][1]);
		swap(matrix[1][2],matrix[1][1]);
		if(states.find(tmp)==states.end())
		{
			BFS_que.push(tmp);
			states[tmp]=temp;
		}
		if(tmp==12345678)//如果符合条件，退出
			break;
		tmp=matrix[0][0];//操作1
		matrix[0][0]=matrix[1][0];
		matrix[1][0]=matrix[2][0];
		matrix[2][0]=matrix[2][1];
		matrix[2][1]=matrix[2][2];
		matrix[2][2]=matrix[1][2];
		matrix[1][2]=matrix[0][2];
		matrix[0][2]=matrix[0][1];
		matrix[0][1]=tmp;
		convert(mtx_int,tmp,matrix);
		if(states.find(tmp)==states.end())
		{
			BFS_que.push(tmp);
			states[tmp]=temp;
		}
		if(tmp==12345678)
			break;
		BFS_que.pop();
	}
	if(BFS_que.empty())//如果是因为搜完了都没出结果而退出，输出无解
		return cout<<"UNSOLVABLE"&&0;
	tmp=12345678;
	stack<int> answer;//看到了zltzlt的题解，决定采用他的方法
	while(tmp!=-1)
	{
		answer.push(tmp);
		tmp=states[tmp];
	}
	cout<<answer.size()-1<<endl;//别忘了输出操作次数
	while(!answer.empty())
	{
		convert(int_mtx,answer.top(),matrix);
		for(int i=0;i<3;i++)
		{
			for(int j=0;j<3;j++)
				cout<<matrix[i][j]<<' ';
			endl(cout);
		}
		endl(cout);
		answer.pop();
	}
 	return 0;
}

```

* **【彩蛋】**

$\color{red}\small\mathsf{zltzlt}$ 用手写队列的真正原因：他用```queue```就不行，换手写队列就过了（

---

## 作者：Jsxts_ (赞：1)

# 题解 P2578 【九数码游戏】
[传送门](https://www.luogu.com.cn/problem/P2578)

这题是一道好的广搜题，可以巩固广搜。

我们用结构体数组存储每个状态的值，为什么不用队列呢？等一下就会知道了。

对于操作 1 与操作 2，我们直接按题意模拟，循环都不用（反正大小只有3*3），具体代码如下：
```cpp

_state Do(_state a,int f) {
	if (f == 1) {//操作1
		int t = a.w[1][1];
		a.w[1][1] = a.w[2][1];
		a.w[2][1] = a.w[3][1];
		a.w[3][1] = a.w[3][2];
		a.w[3][2] = a.w[3][3];
		a.w[3][3] = a.w[2][3];
		a.w[2][3] = a.w[1][3];
		a.w[1][3] = a.w[1][2];
		a.w[1][2] = t;
	}
	else {//操作2
		int t = a.w[2][3];
		a.w[2][3] = a.w[2][2];
		a.w[2][2] = a.w[2][1];
		a.w[2][1] = t;
	}
	return a;
}
```
（相信看到代码都知道它在干什么）

然后是如何判重。把九宫格按顺序拼成一个九位数，再用 $\texttt{map}$ 判重即可。

最后是输出路径。我们可以在每个状态中记录一个数代表它的父亲，也就是它是从哪一个状态转移过来的。最后只要一直沿着父亲递归直到到达初始状态，在过程中输出九宫格即可，非常方便。

剩下的细节在代码里展示。

**Code:**
```cpp
#include <bits/stdc++.h>
using namespace std;
struct _state {
	int w[4][4];
	int step,pre;
}q[1000010];
map<int,int> m;
int cal(_state t) {//把九宫格变成一个数 
	int nm = 0;
	for (int i = 1;i <= 3;i ++ ) {
		for (int j = 1;j <= 3;j ++ ) {
			nm = nm * 10 + t.w[i][j];
		}
	}
	return nm;
}
_state Do(_state a,int f) {
	if (f == 1) {//操作1 
		int t = a.w[1][1];
		a.w[1][1] = a.w[2][1];
		a.w[2][1] = a.w[3][1];
		a.w[3][1] = a.w[3][2];
		a.w[3][2] = a.w[3][3];
		a.w[3][3] = a.w[2][3];
		a.w[2][3] = a.w[1][3];
		a.w[1][3] = a.w[1][2];
		a.w[1][2] = t;
	}
	else {//操作2 
		int t = a.w[2][3];
		a.w[2][3] = a.w[2][2];
		a.w[2][2] = a.w[2][1];
		a.w[2][1] = t;
	}
	return a;
}
void print(int x) {//输出 
	if (q[x].pre) print(q[x].pre);//一直递归它的父亲 
	for (int i = 1;i <= 3;i ++ ) {//输出九宫格 
		for (int j = 1;j <= 3;j ++ ) printf("%d ",q[x].w[i][j]);
		puts("");
	}
	puts("");//要多一个换行 
}
void bfs() {
	int head = 1,tail = 1;//手写队列 
	for (int i = 1;i <= 3;i ++ ) {
		for (int j = 1;j <= 3;j ++ ) {
			scanf("%d",&q[head].w[i][j]);
		}
	}
	q[head].step = 0;//步数 
	q[head].pre = 0;//父亲 
	for (;head <= tail;head ++ ) {
		_state cur = q[head];
		if (cal(cur) == 12345678) {//成为目标状态 
			printf("%d\n",cur.step);
			print(head);//输出路径 
			return;
		}
		for (int i = 1;i <= 2;i ++ ) {//两种操作 
			_state nw;
			if (i == 1) nw = Do(cur,1);
			else nw = Do(cur,2);
			if (m[cal(nw)]) continue;//判重 
			m[cal(nw)] = 1;
			q[++tail] = nw;
			q[tail].step ++;
			q[tail].pre = head;//记录父亲 
		}
	}
	printf("UNSOLVABLE");
}
int main() {
	bfs();
	return 0;
}
```

**Time：2.04s**

（如果把 $\texttt{map}$ 改成 $\texttt{unordered\_map}$ ，就1.11s）

---

## 作者：404_notfound (赞：1)

楼下巨佬们为何要用康拓展开？

~~您们让我这个蒟蒻怎么办~~

于是，我们把每个状态的九个数连在一起看成一个字符串

用hash来判重

bfs水过

至于记录路径，由于string有+操作，我们把每一步的状态都加在一起，形成一个长度为（9*步数）的字符串

处理处理输出就行



```cpp
#include<bits/stdc++.h>
#define inf 0x7fffffff
#define ll long long
using namespace std;
string goal="012345678";
#define mod 671088
vector<int> H[mod];
unsigned p=1e9+7;
void Add(unsigned x)
{
	unsigned i=x%mod;
	H[i].push_back(x);
}
bool Get(unsigned x)
{
	int q=x%mod;
	for(int i=0;i<H[q].size();i++)
	{
		if(H[q][i]==x)return 1;
	}
	return 0;
}
//hash判重↑
struct node{
	string now;//当前状态
	string road;//路径
	int step;//步数
};
signed main()
{
	string a;
	for(int i=1;i<=9;i++)//读入不好搞？用int读入！
	{
		int x;
		scanf("%d",&x);
		a+=x+'0';
	}
	queue<node> q;
	q.push((node){a,a,0});
	while(!q.empty())
	{
		node now=q.front();
		q.pop();
		if(now.now==goal)
		{
			printf("%d\n",now.step);
			int i=0,lap=0;
			while(lap!=now.step)
			{
				cout<<now.road[i]<<" ";
				i++;
				if(i%3==0)cout<<"\n";
				if(i%9==0)
				{
					lap++;
					cout<<"\n";
				}
			}
            //输出一遍最终状态
			cout<<"0 1 2\n3 4 5\n6 7 8\n";
			return 0;
		}
		string s;//强行旋转
		s=now.now.substr(3,1)+now.now.substr(0,1)+now.now.substr(1,1)+now.now.substr(6,1)+now.now.substr(4,1)+now.now.substr(2,1)+now.now.substr(7,1)+now.now.substr(8,1)+now.now.substr(5,1);
		//为何不能写now[3]+now[0]+..... ?
        	//string中取出一个元素的类型为char，char不支持操作，会出现蜜汁错误
       	 	unsigned hash=0;
		for(int i=0;i<s.size();i++)
		{
			hash=hash*p+s[i];
		}
		if(!Get(hash))
		{
			q.push((node){s,now.road+s,now.step+1});
			Add(hash);
		}
		
		s=now.now;
		char a1=s[3],a2=s[4],a3=s[5];
		s[3]=a3,s[4]=a1,s[5]=a2;
		hash=0;
		for(int i=0;i<s.size();i++)
		{
			hash=hash*p+s[i];
		}
		if(!Get(hash))
		{
			q.push((node){s,now.road+s,now.step+1});
			Add(hash);
		}//复制上面的代码
	}
	printf("UNSOLVABLE");//搜完了就无解
	return 0;
}
```


---

## 作者：糖hhhh？ (赞：1)

## 感觉其实并没有紫题难度。。

### 用数字记录状态，需要时逐位分割

### 上！

```
int a[10],ten[10];
int s,t;
int zq[3][10000001];
int l,r;
bool vis[87654322]={0};
```
#### zq[0][i]表示状态；zq[1][i]表示步数；zq[2][i]表示其father
#### vis用hash省内存，因为只需前8位数确定，整个状态就确定了

```
inline void read(){
    for(int i=9;i>=1;i--){
        scanf("%d",&a[i]);
        s+=(a[i]*ten[i]);
    }
}
inline void print(int x){
    if(zq[2][x])print(zq[2][x]);
    printf("%d %d %d\n",zq[0][x]/ten[9]%10,zq[0][x]/ten[8]%10,zq[0][x]/ten[7]%10);
    printf("%d %d %d\n",zq[0][x]/ten[6]%10,zq[0][x]/ten[5]%10,zq[0][x]/ten[4]%10);
    printf("%d %d %d\n",zq[0][x]/ten[3]%10,zq[0][x]/ten[2]%10,zq[0][x]/ten[1]%10);
    //逐位分割。。。
    printf("\n");
}
```
输入
输出：回溯以打印路径

```
inline void make1(){
    int nnew=0,pre=zq[0][l];
    nnew+=(pre/ten[4]%10*ten[1]);
    nnew+=(pre/ten[1]%10*ten[2]);
    nnew+=(pre/ten[2]%10*ten[3]);
    nnew+=(pre/ten[3]%10*ten[6]);
    nnew+=(pre/ten[6]%10*ten[9]);
    nnew+=(pre/ten[9]%10*ten[8]);
    nnew+=(pre/ten[8]%10*ten[7]);
    nnew+=(pre/ten[7]%10*ten[4]);
    nnew+=(pre/ten[5]%10*ten[5]);
    if(vis[nnew/10])return ;
    vis[nnew/10]=1;
    zq[0][r]=nnew;
    zq[1][r]=zq[1][l]+1;
    zq[2][r]=l;
    if(zq[0][r]==t){
        printf("%d\n",zq[1][r]);
        print(r);
        exit(0);
    }
    r++;
}
inline void make2(){
    int nnew=0,pre=zq[0][l];
    nnew+=(pre/ten[4]%10*ten[6]);
    nnew+=(pre/ten[1]%10*ten[1]);
    nnew+=(pre/ten[2]%10*ten[2]);
    nnew+=(pre/ten[3]%10*ten[3]);
    nnew+=(pre/ten[6]%10*ten[5]);
    nnew+=(pre/ten[9]%10*ten[9]);
    nnew+=(pre/ten[8]%10*ten[8]);
    nnew+=(pre/ten[7]%10*ten[7]);
    nnew+=(pre/ten[5]%10*ten[4]);
    if(vis[nnew/10])return ;
    vis[nnew/10]=1;
    zq[0][r]=nnew;
    zq[1][r]=zq[1][l]+1;
    zq[2][r]=l;
    if(zq[0][r]==t){
        printf("%d\n",zq[1][r]);
        print(r);
        exit(0);
    }
    r++;
}
```
木有什么技巧（逐位分割+宽搜模板+题意）

#### ten数组下方解释

```
int main()
{
    t=12345678;
    ten[1]=1;
    for(int i=2;i<=9;i++)
        ten[i]=10*ten[i-1];
    read();
    if(s==t){
        printf("0\n0 1 2\n3 4 5\n6 7 8\n");
        return 0;
    }
    l=1,r=2;
    zq[0][l]=s;zq[1][l]=0;zq[2][l]=0;
    vis[s/10]=1;
    while(l<r){
        make1();
        make2();
        l++;
    }
    printf("UNSOLVABLE\n");
    return 0;
}
```
应该很好理解吧。

### ten数组表示九宫格用数字表示后在哪一位，比如

### 012345678中5所对应的ten[3]为1000，

### 要取出5只需

### 012345678/ten[3]%10就可以了

# 仍然不觉得有难度。。

---

## 作者：Limit (赞：1)

这题....BFS，不是很明显吗？只是去重的表...9^9=387420489。要炸...
但因为最后一个数必然是与前面的数不同。所以可以删掉一个9,9^8=...~~懒到不想算反正可以过~~既然用来去重的表打好了，那就简单了
```cpp
#include<bits/stdc++.h>//标准的万能头
using namespace std;
const int Max=9*9*9*9*9*9*9;//古怪的卡过去了
int now[Max][9],come[Max],r[9],u[Max];
bool boo[9][9][9][9][9][9][9][9];//所谓的快要炸的去重用的表
int i,j,k,m,n,h=1,t=1,x;
int write(int x)//倒着输出，递归最方便了
{
  if(come[x]!=-1)write(come[x]);//进入下一层
  cout<<now[x][0]<<" "<<now[x][1]<<" "<<now[x][2]<<endl;
  cout<<now[x][3]<<" "<<now[x][4]<<" "<<now[x][5]<<endl;
  cout<<now[x][6]<<" "<<now[x][7]<<" "<<now[x][8]<<endl;
  cout<<endl;
  return 0;
}
int main()//呀
{
  for(i=0;i<9;i++)cin>>r[i];
  h=1;t=1;u[1]=0;
  for(k=0;k<9;k++)now[h][k]=r[k];
  boo[now[t][0]][now[t][1]][now[t][2]][now[t][3]][now[t][4]][now[t][5]][now[t][6]][now[t][7]]=true;
  come[1]=-1;
  while(t<=h)
  {
    if(now[t][0]==0&&now[t][1]==1&&now[t][2]==2&&now[t][3]==3&&now[t][4]==4&&now[t][5]==5&&now[t][6]==6&&now[t][7]==7)//恶心的代码*1
    {cout<<u[t]<<endl;write(t);/*输出*/return 0;}//终于找到解了！！！
    for(k=0;k<9;k++)r[k]=now[t][k];
    x=r[5];r[5]=r[4];r[4]=r[3];r[3]=x;
    if(!boo[r[1]][r[2]][r[3]][r[4]][r[5]][r[6]][r[7]][r[8]])//恶心的代码*2
    {h++;
      u[h]=u[t]+1;
      for(k=0;k<9;k++)now[h][k]=r[k];
      boo[r[1]][r[2]][r[3]][r[4]][r[5]][r[6]][r[7]][r[8]]=true;
      come[h]=t;}
    for(k=0;k<=9;k++)r[k]=now[t][k];
    x=r[0];r[0]=r[3];r[3]=r[6];r[6]=r[7];r[7]=r[8];r[8]=r[5];r[5]=r[2];r[2]=r[1];r[1]=x;//恶心的代码*3
    if(!boo[r[1]][r[2]][r[3]][r[4]][r[5]][r[6]][r[7]][r[8]])
    {h++;
      u[h]=u[t]+1;
      for(k=0;k<=9;k++)now[h][k]=r[k];
      boo[r[1]][r[2]][r[3]][r[4]][r[5]][r[6]][r[7]][r[8]]=true;
      come[h]=t;}
    t++;
  }
  return 0;
}
//恶心的代码终于完了
```
这是一到让代码更恶心的~~水题~~


---

## 作者：loaky (赞：1)

这个题和魔板的题比较像，最开始写的时候想的是把9个数看做一个字符串，用map来判重，后面写完了之后发现string出了问题，调试了30分钟没调出来，就放弃了，下午来写，其实不想麻烦的话，还是存数字，只是我们用康拓展开来判重，康拓展开对序列全排列有效的编码方法，但是这道题中我们有一个0，所以我们把所有的数都加上1，就变成了1-9，整个9个数只有两种变化，我们将这两种变化分别设为两个函数，用一个结构体来储存信息进行广搜，将每种状态储存起来，但是注意题中的输出，如果正向进行光搜的，不能记录变化的过程，因此我们倒着来，两种操作也就都要反着来，广搜就不用多数了吧，代码中注明。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cstdlib>
#include<queue>
using namespace std;
const long long maxn=5*1e6+5;
long long a[15],b[15],last,tp[15],nn=1,vis[maxn];
long long contor(){
    int nm=0,fj=1;
    int k=0;
    for(int i=1;i<=9;i++){
        for(int j=i+1;j<=9;j++){
            fj*=(9-j+1);
            if(a[i]>a[j]) k++;
        }
        nm+=(k*fj);
        k=0;
        fj=1;
    }
    return nm;
}
struct node{//prev代表这一个是由哪一个变化而来的，stp表示步数，id表示自己是序号，ct表示这个结构储存的序列进过康拓展开之后的编码，ai数组存的是这9个数的顺序。
    long long prev,stp,id,ct;
    long long ai[15];
}e[maxn];
queue<node>q;//开一个结构体队列
void c1(){//第一个变化操作，（要反着来）
    memcpy(tp,a,sizeof(tp));
    tp[1]=a[2];
    tp[2]=a[3];
    tp[3]=a[6];
    tp[4]=a[1];
    tp[6]=a[9];
    tp[7]=a[4];
    tp[8]=a[7];
    tp[9]=a[8];
    memcpy(a,tp,sizeof(a));
}
void c2(){//第二个变化
    memcpy(tp,a,sizeof(tp));
    tp[4]=a[5];
    tp[5]=a[6];
    tp[6]=a[4];
    memcpy(a,tp,sizeof(a));
}
void bfs(){//bfs过程
    q.push(e[1]);
    while(!q.empty()){
        node f=q.front();
        q.pop();
        if(f.ct==last){//如果到达目标状态就输出
            printf("%lld\n",f.stp);
            for(long long i=1;i<=9;i++){
                printf("%lld ",f.ai[i]-1);
                if(i%3==0) cout<<endl;
            }
            cout<<endl;
            for(long long i=f.prev;i;i=e[i].prev){
                for(long long j=1;j<=9;j++){
                    printf("%lld ",e[i].ai[j]-1);
                    if(j%3==0) cout<<endl;
                }
                cout<<endl;
            }
            exit(0);
        }
        else{//否则，我们继续将序列进行变化
            for(long long i=1;i<=9;i++) a[i]=f.ai[i];
            c1();
            long long fl=contor();
            if(!vis[fl]){
                e[++nn].prev=f.id;
                e[nn].id=nn;
                e[nn].stp=f.stp+1;
                e[nn].ct=fl;
                vis[fl]++;
                for(long long i=1;i<=9;i++){
                    e[nn].ai[i]=a[i];
                }
                q.push(e[nn]);
            }
            for(long long i=1;i<=9;i++) a[i]=f.ai[i];
            c2();
            fl=contor();
            if(!vis[fl]){
                e[++nn].prev=f.id;
                e[nn].id=nn;
                e[nn].stp=f.stp+1;
                e[nn].ct=fl;
                vis[fl]++;
                for(long long i=1;i<=9;i++){
                    e[nn].ai[i]=a[i];
                }
                q.push(e[nn]);
            }
        }
    }
}
int main(){	
    for(long long i=1;i<=9;i++){//目标状态
        scanf("%lld",&a[i]);
        a[i]+=1;
    }	
    last=contor();
    for(long long i=1;i<=9;i++) a[i]=i;//起始状态
    vis[contor()]++;
    e[1].prev=0;
    e[1].stp=0;
    e[1].id=1;
    e[1].ct=contor();
    for(long long i=1;i<=9;i++) e[1].ai[i]=a[i];
    bfs();//广搜
    printf("UNSOLVABLE");
    return 0;
}
```

---

## 作者：AcerMo (赞：1)

### 搜索好题 ！
#### 我用的BFS
##### 思路
直接枚举每种操作，然后用一个8维数组判断当前局面有没有出现过，为什么用八维呢？因为九个格子八个格子是确定的，那么剩下的一个也是确定的，所以我们不管他。
楼下的讲的都太复杂，这就是一道裸的BFS，一开始我想用IDFS，结果TLE了，分析了一下，发现只有9!种状态，所以我换了BFS，我们从结果状态向起始状态搜索，然后对于每种情况，记一个id，一个last，然后压入一个结构体里，然后输出的时候只需要倒序输出就好，因为倒着搜的 ，所以倒序输出就是正的
##### 注意点
操作2是只能移动中间的那行，我因为三行都动了，WA了半天QAQ
#### 代码
```cpp
//By AcerMo
#include<queue>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
struct emm
{
	int b[3][3],co,la,id;
	bool friend operator < (emm x,emm y)
	{return x.co>y.co;}
}ad,no,t[1000500];
priority_queue<emm>q;
int a[4][4],cnt;
bool f[9][9][9][9][9][9][9][9];
inline void cha1()
{
	ad=no;
	ad.b[1][0]=no.b[0][0];ad.b[2][0]=no.b[1][0];

	ad.b[2][1]=no.b[2][0];ad.b[2][2]=no.b[2][1];
	
	ad.b[1][2]=no.b[2][2];ad.b[0][2]=no.b[1][2];

	ad.b[0][1]=no.b[0][2];ad.b[0][0]=no.b[0][1];

	if (f[ad.b[0][0]][ad.b[0][1]][ad.b[0][2]][ad.b[1][0]][ad.b[1][1]][ad.b[1][2]][ad.b[2][0]][ad.b[2][1]]) return ;

	f[ad.b[0][0]][ad.b[0][1]][ad.b[0][2]][ad.b[1][0]][ad.b[1][1]][ad.b[1][2]][ad.b[2][0]][ad.b[2][1]]=1;

	ad.co=no.co+1;ad.la=no.id;ad.id=++cnt;t[cnt]=ad;

	return (void)(q.push(ad));
}
inline void cha2()
{
	ad=no;
	ad.b[1][2]=no.b[1][0];ad.b[1][0]=no.b[1][1];ad.b[1][1]=no.b[1][2];
	
	if (f[ad.b[0][0]][ad.b[0][1]][ad.b[0][2]][ad.b[1][0]][ad.b[1][1]][ad.b[1][2]][ad.b[2][0]][ad.b[2][1]]) return ;
	
	f[ad.b[0][0]][ad.b[0][1]][ad.b[0][2]][ad.b[1][0]][ad.b[1][1]][ad.b[1][2]][ad.b[2][0]][ad.b[2][1]]=1;
	
	ad.co=no.co+1;ad.la=no.id;ad.id=++cnt;t[cnt]=ad;

	return (void)(q.push(ad));
}
inline bool che()
{
	for (int i=0;i<3;i++)
	for (int k=0;k<3;k++)
	if (a[i][k]!=no.b[i][k]) 
	return 0;return 1; 
}
inline void BFS()
{
	for (int i=0;i<3;i++)
	for (int k=0;k<3;k++)
	no.b[i][k]=i*3+k;
	no.co=0;no.id=0;t[0]=no;q.push(no);
	while (q.size())
	{
		no=q.top();q.pop();
		if (che()) return (void)(cout<<no.co);
		cha2();cha1();
	}
	return ;
}
signed main()
{
	for (int i=0;i<3;i++)
	for (int k=0;k<3;k++)
	scanf("%d",&a[i][k]);
	BFS();int e=no.id;puts("");
	while (1)
	{
		for (int i=0;i<3;i++)
		{
			for (int k=0;k<3;k++)
			cout<<t[e].b[i][k]<<" ";
			puts("");
		}
		if (!e) break;
		puts("");e=t[e].la;
	}
	return 0;
}
```

---

## 作者：encore (赞：1)

思路和之前的大佬们差不多，主要在以下几个方面作了优化：

* 状态的表示

~~我也不知道有没有效果~~。观察两个操作，发现第二个操作只会移动3个元素，二第一个操作要移动8个。于是我按照以下方式定义我的状态：用一个9位十进制数表示，第一位（最高位）放九宫格中间的数，后面的8位异常为从九宫格左上角开始顺时针排列的数。

如以下棋盘：

|  0|  1|  2|
| -----------: | -----------: | -----------: |
|  **3**| **4** | **5** |
| **6** | **7** | **8** |

对应状态数：

**401258763**
。

这样操作一就变得十分简单。残念的是，操作二变麻烦了。不过我~~盲目~~分析了一下，觉得总体上还是有优化的。

当然如果用16进制的话或许能减小常数，~~懒得弄了~~

* 状态的存储

在上文的基础上我使用了hashmap。主要是简单，相对康托展开应该要快一点。

~~由于比较简单就不提了~~

* 搜索的方式

这应该是我最有效的优化。在这里我使用了双端队列BFS。双端队列BFS就是从起点和终点分别扩展，使用两个队列，每次扩展节点数较少的那个。比较简单，具体不讲了，可以看后文的代码实现。这里只提一个需要注意的地方。就是从终点扩展的时候要用逆操作。具体来说，对于以下状态为**目标状态**

|  0|  1|  2|
| -----------: | -----------: | -----------: |
|  **3**| **4** | **5** |
| **6** | **7** | **8** |

，
以下状态为**起始状态**

|  0|  1|  2|
| -----------: | -----------: | -----------: |
|  **4**| **5** | **3** |
| **6** | **7** | **8** |

的情况。很明显，只要一步操作二即可完成。但是反向从终点开始扩展的话，就不能直接用原来的操作二。

~~语文不好真麻烦，还是看例子吧~~

就是说，操作二是把中间一行向右移，但如果反向扩展的话，往右移就会变成这样

|  0|  1|  2|
| -----------: | -----------: | -----------: |
|  **5**| **3** | **4** |
| **6** | **7** | **8** |

这就不是起始状态了。

所以我们在从终点反向扩展的时候，要用一个操作的逆操作。比如操作二的逆操作就是把中间一行向左移。

还有就是路径输出的时候有一些区别。

好了，具体细节见代码：

```cpp
#include <cstdio>
#include <queue>

int ans;

inline void reada(int &x) {
  while (x = getchar(), x > '9' || x < '0'); x -= 48;
}

class Hash{
  public:
    inline void assign(int Key, int val) {
      int p = Key % _kMOD;
      for (int e = first_[p]; e; e = next_[e]) {
        if (val1_[e] == Key) { val2_[e] = val; return;}
      }
      next_[++edge_num_] = first_[p], first_[p] = edge_num_, 
      val1_[edge_num_] = Key, val2_[edge_num_] = val;
    }

    inline void modify(int Key, int val) {
      int p = Key % _kMOD;
      for (int e = first_[p]; e; e = next_[e]) {
        if (val1_[e] == Key) { val2_[e] += val; return;}
      }
      next_[++edge_num_] = first_[p], first_[p] = edge_num_, 
      val1_[edge_num_] = Key, val2_[edge_num_] = val;
    }

    int query(int Key) const{
      int p = Key % _kMOD;
      for (int e = first_[p]; e; e = next_[e]) {
        if (val1_[e] == Key) return val2_[e];
      }
      return 0;
    }
  protected:
    static const int _kMOD     = 999983;
    static const int _kMaxSize = 363000;
  private:
    int edge_num_;
    int first_[_kMOD], next_[_kMaxSize] , val1_[_kMaxSize], val2_[_kMaxSize];
};

int start_con;
int end_con = 401258763;

constexpr int pow10[10] = {1, 10, 100, 1000, 10000, 100000, 1000000, 
                           10000000, 100000000, 1000000000};

inline void conv(int &con, const int arr[]) {
  con = arr[4] * pow10[8] + arr[0] * pow10[7] + arr[1] * pow10[6] + 
        arr[2] * pow10[5] + arr[5] * pow10[4] + arr[8] * pow10[3] + 
        arr[7] * pow10[2] + arr[6] * pow10[1] + arr[3] * pow10[0];
}

inline void iconv(int con, int arr[]) {
  arr[3] = con % 10, con /= 10,
  arr[6] = con % 10, con /= 10,
  arr[7] = con % 10, con /= 10,
  arr[8] = con % 10, con /= 10,
  arr[5] = con % 10, con /= 10,
  arr[2] = con % 10, con /= 10,
  arr[1] = con % 10, con /= 10,
  arr[0] = con % 10, con /= 10,
  arr[4] = con % 10;
}

void out_put_con(int con) {
  int x[9];
  iconv(con, x);
  putchar(x[0] + '0'), 
  putchar(' '), 
  putchar(x[1] + '0'), 
  putchar(' '), 
  putchar(x[2] + '0'), 
  putchar('\n'), 
  putchar(x[3] + '0'), 
  putchar(' '), 
  putchar(x[4] + '0'), 
  putchar(' '), 
  putchar(x[5] + '0'), 
  putchar('\n'), 
  putchar(x[6] + '0'), 
  putchar(' '), 
  putchar(x[7] + '0'), 
  putchar(' '), 
  putchar(x[8] + '0'), 
  putchar('\n');
}


Hash dis1, dis2, pre1, pre2, vis;
int mid;

void operator_A(int &con) {
  int h = con / pow10[8], t = con % pow10[8];
  con = h * pow10[8] + (t % 10) * pow10[7] + t / 10;
}
void operator_B(int &con) {
  int s1, s2, s3, s4, s5;
  s5 = con % 10,
  con /= 10,
  s4 = con % pow10[3],
  con /= pow10[3],
  s3 = con % 10,
  con /= 10,
  s2 = con % pow10[3],
  con /= pow10[3],
  s1 = con;
  con = s3 + s4 * 10 + s1 * pow10[4] + 
        s2 * pow10[5] + s5 * pow10[8];
}

void inv_operator_A(int &con) {
  int h = con / pow10[8], t = con % pow10[8];
  con = h * pow10[8] + (t / pow10[7]) + (t % pow10[7]) * 10;
}

void inv_operator_B(int &con) {
  int s1, s2, s3, s4, s5;
  s5 = con % 10,
  con /= 10,
  s4 = con % pow10[3],
  con /= pow10[3],
  s3 = con % 10,
  con /= 10,
  s2 = con % pow10[3],
  con /= pow10[3],
  s1 = con;
  con = s1 + s4 * 10 + s5 * pow10[4] + 
        s2 * pow10[5] + s3 * pow10[8];
}

void (*FPArray[])(int&) = {operator_A, operator_B, inv_operator_A, inv_operator_B};

int BFS(int start_con, int end_con) {
  std::queue<int> q1, q2, *q;
  Hash *dis, *pre;
  int qv, fpa;
  bool flag = false;
  q1.emplace(start_con), q2.emplace(end_con);
  vis.assign(start_con, 1), vis.assign(end_con, 2);
  dis1.assign(start_con, 0), dis2.assign(end_con, 0);
  while ((!q1.empty()) && (!q2.empty())) {
    if (q1.size() <= q2.size()) {
      q = &q1, dis = &dis1, pre = &pre1, qv = 1, fpa = 0;
    } else {
      q = &q2, dis = &dis2, pre = &pre2, qv = 2, fpa = 2;
    }
    int qf = q->front(), dist = dis->query(qf);
    q->pop();
    for (int i = 0, qtf; i != 2; ++i) {
      qtf = qf;
      (i + fpa)[FPArray](qtf);
      int v = vis.query(qtf);
      if (v == qv) continue;
      vis.modify(qtf, qv);
      dis->assign(qtf, dist + 1);
      pre->assign(qtf, qf);
      if (v + qv == 3) {
        mid = qtf;
        flag = true;
        break;
      }
      q->emplace(qtf);
    }
    if (flag) break;
  }
  if (flag) {
    return dis1.query(mid) + dis2.query(mid);
  }
  return -1;
}

void print_path_A(int x) {
  if (!x) return;
  print_path_A(pre1.query(x));
  out_put_con(x), putchar('\n');
}

void print_path_B(int x) {
  while (x) {
  	out_put_con(x), putchar('\n');
  	x = pre2.query(x);
  }
}

void print_path(int mid) {
  print_path_A(pre1.query(mid)), print_path_B(mid);
}

int main() {
  int x[9];
  reada(x[0]),
  reada(x[1]),
  reada(x[2]),
  reada(x[3]),
  reada(x[4]),
  reada(x[5]),
  reada(x[6]),
  reada(x[7]),
  reada(x[8]);
  conv(start_con, x);
  ans = BFS(start_con, end_con);
  if (ans == -1) {  puts("UNSOLVABLE");}
  else {
    printf("%d\n", ans);
    print_path(mid);
  }
  return 0;
}
```
注释：

为了$\overset{\text{毒瘤}}{\text{方便}}$，我使用了指针。~~而且是函数指针~~。在```void (*FPArray[])(int&)``` 那里定义了一个名为FPArray的函数指针数组。```i[FParray](con)```表示调用FPArray中第i个函数，参数为con。

conv函数用于将状态数值转换成状态数组，iconv则相反。

hashmap vis里1为正面扩展过，2为反向扩展过，3为相遇。

出锅了或者有问题评论或者@我吧。

交了一下，173ms，没吸氧~~吸了也没用~~，目前排第五。不会卡常。$\overset{\text{不会}}{\text{不想}}$优化了。如果要冲榜我建议手写队列、循环展开、改哈希模数、输出优化之类。

顺便%%12ms的大佬，不知道用的什么神仙算法Orz

祝你们成功（滑稽

---

## 作者：shijunfeng00 (赞：1)

竟然没有C++的题解么

来一个C++的题解...

这道题……感觉&细节各种错

首先这个输出状态很麻烦...

从初始状态到末状态是一棵树

从根节点搜子叶要递归很麻烦

所以解决方案有两种

将输入状态定位末状态,初状态为

0 1 2
3 4 5
6 7 8
倒着搜

然后类似

```cpp
while(!c)
{
    cout<<list[c]; 
    c=list[c];
}
```
当然我们定义为 node list[1000000];输出数组,
好像是个链表吧...（还是一棵树,,还是啥链表树,,傻傻分不清啊）

定义个print函数.

然后,,当然,,q.tail的父节点当然是q.head啦

但是STL的queue好像不支持酱紫呀

于是干脆手写队列

和STL用法完全一样

特别注意的就是数组一定要开得贼大

不然无输出,,鬼知道特么要1000000呀

我开的1000，只有40分呢，郁闷了半天

输出当然我是用链表了呀

如果会用指针写链表最好,,节约空间和时间

大概是这么写吧..忘了,一年没用过了

```cpp
Type*list=new list; 
//动态链表建立
Type temp=list;
list=new Type;
list->father=temp;
scanf(list.data)
//遍历
while(list!=NULL)
{
    print(list->data);
    list=list->father;
}
```
哎呀……废话半天了,,其实我也不会
下面才是重点

```cpp
#include<iostream>
#include<cstring>
template<typename T_queue>                                           //模板类, 
class queue                                                           //可以访问下标的队列 
{
```
public:
```cpp
    queue(){head=1;tail=0;std::memset(data,0,sizeof(data));}
    void push(T_queue a){data[++tail]=a;}
    void pop(){if(head<=tail)head++;}
    T_queue front(){return data[head];}
    T_queue back(){return data[tail];}
    bool empty(){return head>tail;}
    T_queue data[2000000];
    int tail,head;
    int father;
};
template<typename T_stack>
class stack                                                     //栈 
{
```
public:
```cpp
    stack(){std::memset(data,0,sizeof(data));tail=0;}
    void push(T_stack a){data[++tail]=a;}
    void pop(){if(tail>0)tail--;}
    bool empty(){return tail==0;};
    T_stack top(){return data[tail];}
```
private:
```cpp
    T_stack data[2000000];
    int tail;
};
class node                //当前状态最小步数,当前状态. 
{
```
public:
```cpp
    int a[10],step;
}s;
///////////////////////// 
int temp_stack_list[2000000];                                           //temp_Type前缀代表Type变量预处理用的临时变量 
int f[]={1,1,2,6,24,120,720,5040,40320,326880},book[1000000];  //阶乘打表 
queue<node>q;
stack<int*>list;  //用法和STL完全一样,,除了下标访问 
//////////////////////////以上定义全局变量 
using namespace std;
void next(int*a,int i)                         //两种状态变化方式 
{                                             
    if(i==1)
    {
        int temp_a0=a[0];
        a[0]=a[3];a[3]=a[6];a[6]=a[7];a[7]=a[8];a[8]=a[5];a[5]=a[2];a[2]=a[1];
        a[1]=temp_a0;
        return;
    }
    if(i==2)
    {
        int temp_a5=a[5];
        a[5]=a[4];a[4]=a[3];
        a[3]=temp_a5;
        return;
    }
}
int inline cantor_expansion(int*a)             //康拓展开 ,,特殊的hash函数 
{
    int ans=0;
    for(int i=0;i<9;i++)
    {
        int tmp=0;                   
        for(int j=i+1;j<9;j++)
            if(a[i]>a[j])tmp++;
        ans+=tmp*f[8-i];
    }
    return ans;
}
void print(int*a)                              //打印数组 
{
    for(int i=0;i<9;i++)
    {
        cout<<a[i]<<" ";
        if((i+1)%3==0)
            cout<<endl;    
    }
}
int main()
{
    int end=0;
    for(int i=0;i<9;i++)cin>>s.a[i];
    if(cantor_expansion(s.a)==0)
    {
        cout<<0;
        return 0;
    }
    q.push(s);
    book[cantor_expansion(s.a)]=1;
    while(!q.empty())                       //裸的广度优先搜索也能过,,其他的懒得写,,嫌代码不够长么 
    {
        for(int i=2;i>0;--i)
        {
            node now_status=q.front();
            next(now_status.a,i);
            now_status.step=q.front().step+1;
            if(cantor_expansion(now_status.a)==end)
            {
                cout<<now_status.step<<endl;
                q.push(now_status);
                temp_stack_list[q.tail]=q.head;
                int p=q.tail;
                do
                {
                    list.push(q.data[p].a);             //入栈,,把输出顺序颠倒下 
                    p=temp_stack_list[p];
                }
                while(p);
                cout<<endl;
                print(list.top());
                list.pop();
                while(!list.empty())
                {
                    cout<<endl<<endl;
                    print(list.top());                 //输出 
                    list.pop();
                }                
                return 0;
            }
            if(book[cantor_expansion(now_status.a)]==0)
            {
                book[cantor_expansion(now_status.a)]=1;
                q.push(now_status);
                temp_stack_list[q.tail]=q.head;                     //伪链表 
            }        
        }
        q.pop();
    }
    cout<<"UNSOLVABLE"; 
} 

```

---

## 作者：封禁用户 (赞：0)

折磨了我一下午，我还是太蒻了

其实这题不用记录前驱，用二叉树等等，直接暴力就可以，我们可以在每个状态里保存一个字符串变量，用来记录走到这一步所有的路程，
最后输出最终状态里的字符串变量就OK了。

总体思路各位dalao们都讲过了，就是剪枝BFS+哈希，我就不再过多去说了。


~~一定一定要吸氧才能过，我就是因为一开始没吸氧，最后4个点tle~~

```cpp
#include <cstdio>
#include <set>
#include <queue>
#include <string>
using namespace std;

string new_path(int matrix[4][4]) {
	string path;
	for (int i = 1; i <= 3; i++) {
		for (int j = 1; j <= 3; j++) {
			path += (char)(matrix[i][j] + '0');
			path += ' ';
		}
		path += '\n';
	}
	return path + '\n';
}

struct Status {
	int matrix[4][4], step;
	string path;
	
	int get_hash() {
		int hash = 0;
		for (int i = 1; i <= 3; i++)
			for (int j = 1; j <= 3; j++)
				hash = hash * 10 + matrix[i][j];
		return hash;
	}
	
	Status change1() {
		Status changed;
		changed.step = step + 1;
		changed.matrix[1][1] = matrix[2][1];
    	changed.matrix[1][2] = matrix[1][1];
    	changed.matrix[1][3] = matrix[1][2];
    	changed.matrix[2][1] = matrix[3][1];
    	changed.matrix[2][2] = matrix[2][2];
    	changed.matrix[2][3] = matrix[1][3];
    	changed.matrix[3][1] = matrix[3][2];
    	changed.matrix[3][2] = matrix[3][3];
    	changed.matrix[3][3] = matrix[2][3];
    	changed.path = path + new_path(changed.matrix);
		return changed;
	}
	
	Status change2() {
		Status changed;
		changed.step = step + 1;
		for (int i = 1; i <= 3; i++) {
			changed.matrix[1][i] = matrix[1][i];
			changed.matrix[3][i] = matrix[3][i];
		}
		changed.matrix[2][1] = matrix[2][3];
		changed.matrix[2][2] = matrix[2][1];
		changed.matrix[2][3] = matrix[2][2];
		changed.path = path + new_path(changed.matrix);
		return changed;
	}
};

int main() {
	// read
	Status init;
	init.step = 0;
	for (int i = 1; i <= 3; i++)
		for (int j = 1; j <= 3; j++)
			scanf("%d", &init.matrix[i][j]);
	init.path = new_path(init.matrix);

	// BFS
	set<int> visit;
	queue<Status> que;
	que.push(init);
	while (!que.empty()) {
		Status &status = que.front(), changed1, changed2;
		int hash1, hash2;
		if (status.get_hash() == 12345678) {
			printf("%d\n", status.step);
			puts(status.path.c_str());
			return 0;
		}
		changed1 = status.change1();
		changed2 = status.change2();
		hash1 = changed1.get_hash();
		hash2 = changed2.get_hash();
		if (!visit.count(hash1)) {
			visit.insert(hash1);
			que.push(changed1);
		}
		if (!visit.count(hash2)) {
			visit.insert(hash2);
			que.push(changed2);
		}
		que.pop();
	}
	
	// no answer
	puts("UNSOLVABLE");
	return 0;
}
```


---

## 作者：Iron_Heart (赞：0)

## 思路

很明显需要使用广搜。

使用一个结构体来表示一个状态（`a` 是当前的九宫格；`last` 是当前状态是从哪个状态操作得来的，即该状态的父状态；`step` 是当前执行了几次操作）：

```cpp
struct state {
    int a[9], last, step;
};
```

之后是广搜的框架（为了方便，我使用手写队列）：

```cpp
    while (head <= tail) {
        state u = stas[head];
        ...
        ++head;
    }
```


接下来是模拟操作 $1$ 和操作 $2$：

```cpp
state move_1(state s) {
    state res = s;
    res.a[0] = s.a[3];
    res.a[1] = s.a[0];
    res.a[2] = s.a[1];
    res.a[5] = s.a[2];
    res.a[8] = s.a[5];
    res.a[7] = s.a[8];
    res.a[6] = s.a[7];
    res.a[3] = s.a[6];
    return res;
}

state move_2(state s) {
    state res = s;
    res.a[3] = s.a[5];
    res.a[4] = s.a[3];
    res.a[5] = s.a[4];
    return res;
}
```

两次操作后都需要将操作后的状态添加进队列。

**记得判重，不然会 MLE。**

为了方便判重，我们可以使用一个函数，将一个状态转化为一个整数，这样就只需判断该整数是否出现过即可：

```cpp
int state2int(state s) {
    int res = 0;
    for (int i = 0; i < 9; ++i) {
        res = 10 * res + s.a[i];
    }
    return res;
}
```


最后是判断到达目标状态时，打印路径。

一直沿着父状态找到初始状态，寻找的同时使用一个栈存放遍历到的所有状态，方便后面逆序输出。

其他细节见完整代码。

## 完整代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int head = 1, tail;
struct state {
    int a[9], last, step;
} beg, stas[2000000];
set<int> vis;
bool flag;

int state2int(state s) {
    int res = 0;
    for (int i = 0; i < 9; ++i) {
        res = 10 * res + s.a[i];
    }
    return res;
}

state move_1(state s) {
    state res = s;
    res.a[0] = s.a[3];
    res.a[1] = s.a[0];
    res.a[2] = s.a[1];
    res.a[5] = s.a[2];
    res.a[8] = s.a[5];
    res.a[7] = s.a[8];
    res.a[6] = s.a[7];
    res.a[3] = s.a[6];
    return res;
}

state move_2(state s) {
    state res = s;
    res.a[3] = s.a[5];
    res.a[4] = s.a[3];
    res.a[5] = s.a[4];
    return res;
}

void push(state s) {
    stas[++tail] = s;
    vis.insert(state2int(s));
}

int main() {
    for (int i = 0; i < 9; ++i) {
        scanf("%d", &beg.a[i]);
    }
    beg.last = -1;
    beg.step = 0;
    push(beg);
    while (head <= tail) {
        state u = stas[head];
        if (state2int(u) == 12345678) {
            stack<state> st;
            printf("%d\n", u.step);
            flag = 1;
            int idx = head;
            while (idx != -1) {
                st.push(stas[idx]);
                idx = stas[idx].last;
            }
            while (st.size()) {
                state u = st.top();
                st.pop();
                for (int i = 0; i < 3; ++i) {
                    for (int j = 0; j < 3; ++j) {
                        printf("%d ", u.a[i * 3 + j]);
                    }
                    putchar('\n');
                }
                putchar('\n');
            }
            break;
        }
        ++u.step;
        u.last = head;
        state v = move_1(u);
        if (!vis.count(state2int(v))) {
            push(v);
        }
        v = move_2(u);
        if (!vis.count(state2int(v))) {
            push(v);
        }
        ++head;
    }
    if (!flag) {
        puts("UNSOLVABLE");
    }
    return 0;
}
```


---

## 作者：qiianr (赞：0)

~~既然辣么多的题解都是p，那么我就来水一波c++的题解吧~~
# 敲板子 划重点
- 康托判重，楼上好多大佬都非常认真的讲了，这里不再赘述
- 逆向搜索，既然末状态都是相同的，那就从末状态开始搜索，把能够到达的点用~~小本本记录下答案来~~book,ans数组（其实好像开一个也行）记录下来，对于不能到达的数据判断就很快了（当然对于一组数据没有那么多的优势，但如果是输入多组数据，那它预处理扩展出了所有状态的优势就能够完全体现出来了）；搜索的时候我还用了一个结构体记录当前状态以及当前状态是由哪一个状态扩展而来的，然后输出方案的时候就敲极方便了

代码细节没有很多，这道题差不多可以说是广搜模板，跟八数码差不多

恩，基础非常重要，基础题也要超级认真去做去理解！

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <queue>
using namespace std;
const int maxn=500005;
const int sum[10]={1,1,2,6,24,120,720,5040,40320,362880};
int book[maxn],ans[maxn],cnt;
struct node{
	int a[4][4],step;
};
struct littlecase{
	node g;
	int last;
}f[maxn];

inline int check(node x){//康托计算
	int cc[10],c=0,ans=0;
	for(int i=1;i<=3;++i)for(int j=1;j<=3;++j) cc[++c]=x.a[i][j];
	for(int i=1;i<9;++i){
		c=0;
		for(int j=i+1;j<=9;++j){
			if(cc[j]<cc[i]) c++;
		}
		ans+=c*sum[9-i];
	}
	return ans;
}

inline void pre(){//逆向搜索预处理出能够到达的所有状态
	queue<node>q;
    book[0]=true;//记得true一下，以免数据为末状态时输出为不能到达
	node start;
    int cnt=-1;//注意为-1
	for(int i=1;i<=3;++i)for(int j=1;j<=3;++j)start.a[i][j]=++cnt;
	start.step=0;
	f[0].g=start;
	f[0].last=0;
	q.push(start);
	int a1,a2,a3,num;
	while(q.size()){
		node tem=q.front();q.pop();
		node now;
		cnt++;
		int hh=check(tem);
		//tem记录为上一个状态，now为扩展的状态，每次now=tem就可以避免再回去一遍的操作 = =
        //以下两种扩展方式
		now=tem;
		a1=now.a[2][1];
		a2=now.a[2][2];
		a3=now.a[2][3];
		now.a[2][1]=a2;
		now.a[2][2]=a3;
		now.a[2][3]=a1;
		now.step++;
		int z=check(now);
		if(!book[z]){
			f[z].g=now;
			f[z].last=hh;
			book[z]=1;
			ans[z]=now.step;
			q.push(now);
		}
		
		now=tem;
		num=now.a[1][1];
		now.a[1][1]=now.a[1][2];
		now.a[1][2]=now.a[1][3];
		now.a[1][3]=now.a[2][3];
		now.a[2][3]=now.a[3][3];
		now.a[3][3]=now.a[3][2];
		now.a[3][2]=now.a[3][1];
		now.a[3][1]=now.a[2][1];
		now.a[2][1]=num;
		now.step++;
		z=check(now);
		if(!book[z]){
			f[z].g=now;
			f[z].last=hh;
			book[z]=1;
			ans[z]=now.step;
			q.push(now);
		}
	}
}

int main(){
	pre();
	node getin;
	for(int i=1;i<=3;++i)for(int j=1;j<=3;++j)scanf("%d",&getin.a[i][j]);
	int ss=check(getin),k;
	if(book[ss]){
		printf("%d\n",ans[ss]);
		k=ss;
		for(int i=0;i<=ans[ss];++i){
			for(int i=1;i<=3;++i){
				for(int j=1;j<=3;++j){
					printf("%d ",f[k].g.a[i][j]);
				}
				printf("\n");
			}
			printf("\n");
			k=f[k].last;
		}
	} 
	else printf("UNSOLVABLE\n");
	return 0;
}
```

---

## 作者：取名最烦 (赞：0)

# BFS经典老题。相信主要架构许多同学~~应该~~没有问题~

但是这里有一个问题：判重。

如果用一般的标记数组，显然MLE啦O(9^9)自己算一下~

这里有一个算法可以快速把排列转化成数字，叫**康托展开**。

方法：设一个数列（数列中的数不重复）中第i个数前面有Ti个数比他小，然后把Ti代入公式Ti\*(i-1)!,把每个Ti加起来就行了。具体的大家可以**去百度**~

## 附上我的奇怪的没有几个人可以看懂的代码~

'''
```cpp
uses math;
var i,j,k,l,m,n,t,x,y,z,Head,Tail:longint;
Ampere,Volta,Joule,Watt:array[0..400000]of longint;
Ohm:array[0..8]of longint;
Newton:array[0..400000,0..8]of longint;//Newton（牛顿）是队列数组
function Cantor(x:longint):longint;//康托展开
var i,j,t:longint;
begin
 Cantor:=0;
 for i:=0 to 8 do
 begin
  t:=0;
  for j:=0 to i-1 do
   if Newton[x,i]<Newton[x,j] then inc(t);
  inc(Cantor,Joule[i]*t);
 end;
end;
Procedure Kill(x:longint);
var i,j,k:longint;
begin
 if Watt[x]<>0 then Kill(Watt[x]);
 for i:=0 to 8 do
 begin
  write(Newton[x,i]);
  if (i=2)or(i=5)or(i=8) 
   then writeln
   else write(' ');
 end;
 if x<>Head then writeln;
end;
Function Ok:boolean;
var i:longint;
begin
 for i:=0 to 8 do
  if i<>Newton[Head,i] then exit(false);
 exit(true);
end;
procedure Round;
var t,i:longint;
begin
 inc(Tail);
 Ampere[Tail]:=Ampere[Head]+1;
 for i:=0 to 8 do Newton[Tail,i]:=Newton[Head,i];
 t:=Newton[Tail,0];
 Newton[Tail,0]:=Newton[Tail,3];
 Newton[Tail,3]:=Newton[Tail,6];
 Newton[Tail,6]:=Newton[Tail,7];
 Newton[Tail,7]:=Newton[Tail,8];
 Newton[Tail,8]:=Newton[Tail,5];
 Newton[Tail,5]:=Newton[Tail,2];
 Newton[Tail,2]:=Newton[Tail,1];
 Newton[Tail,1]:=t;
 t:=Cantor(Tail);
 if Volta[t]=1 then
 begin
  dec(Tail);
  exit;
 end;
 Volta[t]:=1;
 Watt[Tail]:=Head;
end;
procedure Change;
var t:longint;
begin
 inc(Tail);
 Ampere[Tail]:=Ampere[Head]+1;
 for i:=0 to 8 do Newton[Tail,i]:=Newton[Head,i];
 t:=Newton[Tail,3];
 Newton[Tail,3]:=Newton[Tail,5];
 Newton[Tail,5]:=Newton[Tail,4];
 Newton[Tail,4]:=t;
 t:=Cantor(Tail);
 if Volta[t]=1 then
 begin
  dec(Tail);
  exit;
 end;
 Volta[t]:=1;
 Watt[Tail]:=Head;
end;
begin
 for i:=0 to 8 do read(Ohm[i]);
 Head:=0;
 Tail:=1;
 Joule[1]:=1;
 Watt[1]:=0;
 for i:=2 to 9 do Joule[i]:=i*Joule[i-1];
 for i:=0 to 8 do Newton[1,i]:=Ohm[i];
 while Head<Tail do
 begin
  inc(Head);
  if OK then
  begin
   writeln(Ampere[Head]);
   Kill(Head);
   halt;
  end;
  Round;
  Change;
 end;
 writeln('UNSOLVABLE');
end.
'''
```

---

## 作者：AutumnKite (赞：0)

#下面Pascal的注释比较少，有点麻烦，我也来凑个热闹#

##ZJOI的题会是水题？好吧，确实有点难（shui）##

当然最小次数肯定用BFS。9个数最多也只会出现9!种方法，400000的队列足够了。但是判重怎么办呢？数组元素必须连续啊，肯定不能开9^9的数组去判重吧。这里介绍一种特殊的哈希：

康托展开。用康托展开的公式能求出一个排列是所有排列中的第几个（从0开始）。那么012345678就对应0，876543210就对应362879，一共362880个，也就是9!。那么存储空间就大大减少了。其他就是裸的BFS了。

```cpp
type
  arr=array[0..8]of longint;
var
  q:array[0..400000]of arr;
  b:array[0..400000]of boolean;
  pre,s:array[0..400000]of longint;
  h,t:longint;
function cantor(x:longint):longint; //康托展开，对q[x]进行哈希
var
  i,j,k,tmp,ans:longint;
begin
  tmp:=1; ans:=0;
  for i:=0 to 8 do 
    begin
      k:=0;
      for j:=0 to i-1 do 
        if q[x,j]>q[x,i] then inc(k);
      ans:=ans+k*tmp;
      tmp:=tmp*(i+1);
    end;
  exit(ans);
end;
function move1():longint; //操作1，顺便返回新的排列的康托展开
var
  tmp:longint;
begin
  inc(t);
  q[t,0]:=q[h,3];
  q[t,1]:=q[h,0];
  q[t,2]:=q[h,1];
  q[t,3]:=q[h,6];
  q[t,4]:=q[h,4];
  q[t,5]:=q[h,2];
  q[t,6]:=q[h,7];
  q[t,7]:=q[h,8];
  q[t,8]:=q[h,5];
  tmp:=cantor(t);
  if b[tmp] then begin dec(t); exit; end; //已经出现过了，就删去
  b[tmp]:=true; pre[t]:=h; s[t]:=s[h]+1; //入队，pre表示前一个状态，s表示转换了几次
  exit(tmp);
end;
function move2():longint; //与操作1同理
var
  tmp:longint;
begin
  inc(t); q[t]:=q[h];
  q[t,3]:=q[h,5];
  q[t,4]:=q[h,3];
  q[t,5]:=q[h,4];
  tmp:=cantor(t);
  if b[tmp] then begin dec(t); exit; end;
  b[tmp]:=true; pre[t]:=h; s[t]:=s[h]+1;
  exit(tmp);
end;
procedure print(x:longint); //递归输出，利用pre数组
begin
  if pre[x]>0 then print(pre[x]);
  writeln(q[x,0],' ',q[x,1],' ',q[x,2]);
  writeln(q[x,3],' ',q[x,4],' ',q[x,5]);
  writeln(q[x,6],' ',q[x,7],' ',q[x,8]);
  writeln;
end;
procedure bfs();
var
  i:longint;
begin
  fillchar(b,sizeof(b),0);
  h:=0; t:=1; pre[1]:=0; s[1]:=0;
  for i:=0 to 8 do read(q[1,i]); //初始状态进队列
  b[cantor(1)]:=true; //初始状态置true
  while h<t do 
    begin
      inc(h);
      if move1()=0 then begin writeln(s[t]); print(t); exit; end;
      if move2()=0 then begin writeln(s[t]); print(t); exit; end;
    end; //返回值也就是哈希值等于0，说明是0123456789（目标状态），就输出
  writeln('UNSOLVABLE'); //队列空了说明不行
end;
begin
  bfs();
end.
```

---


# [HNOI2013] 比赛

## 题目描述

沫沫非常喜欢看足球赛，但因为沉迷于射箭游戏，错过了最近的一次足球联赛。此次联赛共 $N$ 支球队参加，比赛规则如下：

1. 每两支球队之间踢一场比赛；

2. 若平局，两支球队各得 $1$ 分；

3. 否则胜利的球队得 $3$ 分，败者不得分。 尽管非常遗憾没有观赏到精彩的比赛，但沫沫通过新闻知道了每只球队的最后总得分， 然后聪明的她想计算出有多少种可能的比赛过程。

譬如有 $3$ 支球队，每支球队最后均积 $3$ 分，那么有两种可能的情况：

可能性 $1$ and 可能性 $2$

| 球队 | $A$ | $B$ | $C$ | 得分 | 球队 | $A$ | $B$ | $C$ | 得分 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $A$ | - | $3$ | $0$ | $3$ | $A$ | - | $0$ | $3$ | $3$ |
| $B$ | $0$ | - | $3$ | $3$ | $B$ | $3$ | - | $0$ | $3$ |
| $C$ | $3$ | $0$ | - | $3$ | $C$ | $0$ | $3$ | - | $3$ |

但沫沫发现当球队较多时，计算工作量将非常大，所以这个任务就交给你了。请你计算出可能的比赛过程的数目，由于答案可能很大，你只需要输出答案对 $10^9+7$ 取模的结果。

## 说明/提示

$20\%$ 的数据满足 $N≤4$;

$40\%$ 的数据满足 $N≤6$;

$60\%$ 的数据满足 $N≤8$;

$100\%$ 的数据满足 $3≤N≤10$ 且至少存在一组解。

## 样例 #1

### 输入

```
4
4 3 6 4```

### 输出

```
3```

# 题解

## 作者：BJpers2 (赞：56)

首先考虑最暴力的方法，我们依次枚举$n(n-1)/2$场比赛的结果，按照$1V2,1V3...1Vn,2V3...2Vn...n-1Vn$d的顺序枚举。最后判断解是否可行

接下来上剪枝

### 剪枝们：

1. 考虑到最后再来判太浪费，索性在搜索时就限制每人的得分不超过总分。

2. 如果对于一个人u来说，他赢下所有以后的比赛也打不出自己的总分，剪枝。（最后分数也需等于总分）

3. 以上两条剪枝都是很弱智的。考虑$Sx$表示分出胜负的总场数，$Sy$表示平局的总场数,$Su$表示所有队总得分。那么显然有：$$Sx+Sy=n(n-1)/2$$且$$3Sx+2Sy=Su$$
由此可以解出$Sx$,$Sy$。在搜索时，在可利用其限制胜利场次。

4. 此题中心方法楼上已经说的很清楚了，大致利用的是人数为$X$,分数集合为$A[]$的比赛方案数一定，它与某人具体的得分是无关的。因此可以利用记忆化搜索（这好像不能叫剪枝）。把最后几个人剩余的分数哈希起来存就好了。

```
#include<iostream>
#include<cstdio>
#include<map>
#include<algorithm>
#define FOR(i,a,b) for(int i=a;i<=b;i++)
using namespace std;
typedef unsigned long long ll;
const ll B=28,P=1e9+7;
const int N=1000;
int n,a[N],b[N],s[N],su,sx,sy; 
map<ll,ll>h;
bool cmp(int x,int y){return x>y;}
ll dfs(int u,int v){
	ll ret=0;
	if(u==n) return 1;
	if(a[u]+3*(n-v+1)<s[u]) return 0;//保证u打满了总分
	if(v>n){
		FOR(i,u+1,n) b[i]=s[i]-a[i];
		sort(b+u+1,b+n+1);
		ll sta=0;
		FOR(i,u+1,n) sta=sta*B+b[i];//hash
		if(h.find(sta)!=h.end()) return h[sta];
		else return h[sta]=dfs(u+1,u+2);
	}
	if(a[u]+3<=s[u] && sx) 
		a[u]+=3,sx--,ret+=dfs(u,v+1),a[u]-=3,sx++; //u win
	if(a[u]+1<=s[u] && a[v]+1<=s[v] && sy) 
		a[u]++,a[v]++,sy--,ret+=dfs(u,v+1),a[u]--,a[v]--,sy++;//draw
	if(a[v]+3<=s[v] && sx) 
		a[v]+=3,sx--,ret+=dfs(u,v+1),a[v]-=3,sx++;//v win
	return ret%P;
}//一场u-v的比赛 
int main(){
	scanf("%d",&n);
	FOR(i,1,n) scanf("%d",&s[i]),su+=s[i];
	sx=su-n*n+n;sy=(su-3*sx)>>1;//算出sx,sy
	sort(s+1,s+n+1,cmp);
	printf("%lld",dfs(1,2)%P);
}

```

---

## 作者：caidd (赞：26)

其实是一道不错的搜索题啊，为什么没人发题解呢？

这题我一开始想到的是可不可以用数学方法做,可是当出现平局

时，便无法计算了。

接着立马就想到了搜索，可是到后面情况可能会特别多，搜索便

无法处理。加上了数学的优化后也只有60。

点开标签，发现了哈希的标签。我就想，最多十个队，每个队伍

最多是赢九把，27分，而十个队伍比赛的情况放入哈希函数中

最大为7.77*10^12，故开long long即可存入。

使用了该种记搜后，就会快很多。下面上代码（有细节解

释）。

```cpp
#include<cstdio>
#include<map>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<iostream>
#define MAXN 15
#define MOD 1000000007
#define ll long long
using namespace std;
ll a[MAXN];
map<ll,ll>mp;
bool cmp(int a,int b)
{
    return a>b;\\因为换位置结果不会变，故这样排序
    \\使大的与小的先配，这样就会快很多。
}
ll hash(int o)
{
    ll res=o,tmp[MAXN];
    for(int i=1;i<=o;i++) tmp[i]=a[i];
    sort(tmp+1,tmp+o+1,cmp);
    for(int i=1;i<=o;i++) res+=res*28+tmp[i];
    \\采用二十八进制记录情况
    return res;
}
ll dfs(int o,int n)
{
    if(a[n]>3*(n-o)) return -1;
    \\当前分数超过理论最大分即返回。
    ll res=0;
    if(o==n)
    {
        if(n==1) return 1;
        else
        {
            ll h=hash(n-1);
            if(mp[h]) return mp[h];
            return mp[h]=dfs(1,n-1);
        }
    }
    if(a[n]>=3)
    {
        ll tmp=0;
        a[n]-=3,tmp=dfs(o+1,n);
        if(tmp!=-1) res=(res+tmp)%MOD;
        a[n]+=3;
    }
    if(a[n]&&a[o])
    {
        ll tmp=0;
        a[n]--,a[o]--,tmp=dfs(o+1,n);
        if(tmp!=-1) res=(res+tmp)%MOD;
        a[n]++,a[o]++;
    }
    if(a[o]>=3)
    {
        ll tmp=0;
        a[o]-=3,tmp=dfs(o+1,n);
        if(tmp!=-1) res=(res+tmp)%MOD;
        a[o]+=3;
    }
    return res?res:-1;
}
int n;
int main()
{
    scanf("%d", &n);
    for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
    sort(a+1,a+n+1,cmp);
    printf("%lld\n",dfs(1,n));
    return 0;
}

```

---

## 作者：zrz_orz (赞：12)


> 这是一道搜索题

# 不要尝试复制代码，我说过了。。

看到数据范围为  N <= 10  就自然而然想到搜索，或者，~~状压DP~~

不过作为菜鸡，只会DFS

首先想到的是枚举 1 vs 2 ,1 vs 3 , 1 vs 4 ...
```cpp
void dfs(int u, int v) {
    if (u > n) {
        for (int i = 1; i <= n; i++) if (a[i] == s[i]) return;
        ans++;
        return;
    }
    a[u] += 3;
    dfs(u, v + 1);
    a[u] -= 3;
    a[v] += 3;
    dfs(u, v + 1);
    a[v] -= 3;
    a[v]++, a[u]++;
    dfs(u, v + 1);
    a[v]--, a[u]--;
}
```



但这样毫无疑问会超时，考虑如何剪枝

### 剪枝1：

显然当一支球队当前得分已经超过他本来分数时，由于没有减分的选择，所以这显然不合法。

```cpp
if (a[i] > s[i]) return;
```



### 剪枝2：

如果发现当前枚举的这支队伍后面的比赛无论怎么赢都凉了，显然这也不合法

```cpp
if (a[i] + 3 * (n - v + 1) < s[i]) return;
```



### 剪枝3：

设分出胜负的比赛场次的次数为 cnt\_win，平局的场次 cnt\_draw 

那么必然有   

$$

cnt_win  +  cnt_draw = n \* (n - 1) / 2 

3 \* cnt_win + 2 \* cnt_draw = sum_score

$$


这两个线性方程组显然有通解

```cpp
  for (int i = 1; i <= n; i++) {
      scanf ("%d", &s[i]);
      sum += s[i];
  }
  cnt_win = sum - n * (n - 1);
  cnt_draw = (sum - 3 * cnt_win) >> 1;
```



### 剪枝4 ：

因为比赛的分数与顺序无关，所以我只需要掌握某一种分数集合的方案数，在以后的过程中就可以直接用，避免重复预算。考虑如何储存，暴力hash就可以了，自然溢出一般是不会爆炸的。

```cpp
if (y > n) {
    for (int i = x + 1; i <= n; i++) b[i] = s[i] - a[i];
    sort(b + 1 + x, b + n + 1, cmp);
    ll hash_now = 0;
    for (int i = x + 1; i <= n; i++) hash_now = hash_now * 27 + b[i];
    if (hash.find(hash_now) != hash.end()) return hash[hash_now];
    else return hash[hash_now] = dfs(x + 1, x + 2);
}
```



### 总代码

```cpp
#include <bits/stdc++.h>
#define ll long long
#define N 101
#define MOD 1000000007
using namespace std;
int n, cnt_win, cnt_draw;
int s[N], a[N], b[N], sum;
map<ll, ll>hash;
bool cmp(int x, int y) {
  return x > y;
}
ll dfs(int x, int y) {
	ll res = 0;
	if (x == n) return 1;
	if (a[x] + (n - y + 1) * 3 < s[x]) return 0;
  if (y > n) {
  	for (int i = x + 1; i <= n; i++) b[i] = s[i] - a[i];
	  sort(b + 1 + x, b + n + 1, cmp);
	  ll hash_now = 0;
	  for (int i = x + 1; i <= n; i++) hash_now = hash_now * 27 + b[i];
	  if (hash.find(hash_now) != hash.end()) return hash[hash_now];
	  else return hash[hash_now] = dfs(x + 1, x + 2);
	}
	if (3 + a[x] <= s[x] && cnt_win) {
	  cnt_win--;
	  a[x] += 3;
	  (res += dfs(x, y + 1)) %= MOD;
	  cnt_win++;
	  a[x] -= 3;
	}
	if (1 + a[x] <= s[x] && 1 + a[y] <= s[y] && cnt_draw) {
	  cnt_draw--;
	  a[x]++, a[y]++;
	  (res += dfs(x, y + 1)) %= MOD;
	  cnt_draw++;
	  a[x]--, a[y]--;
	}
	if (3 + a[y] <= s[y] && cnt_win) {
	  cnt_win--;
	  a[y] += 3;
	  (res += dfs(x, y + 1)) %= MOD;
	  cnt_win++;
	  a[y] -= 3;
	}
	return res % MOD;
}
int main() {
  scanf ("%d", &n);
  for (int i = 1; i <= n; i++) {
	  scanf ("%d", &s[i]);
	  sum += s[i];
	}
	cnt_win = sum - n * (n - 1);
	cnt_draw = (sum - 3 * cnt_win) >> 1;
	sort(s + 1, s + n + 1, cmp);
	printf("%lld\n", dfs(1, 2));
	return 0;
}
```



---

## 作者：木xx木大 (赞：7)

[P3230 [HNOI2013]比赛](https://www.luogu.com.cn/problem/P3230) 

[双倍经验](https://www.luogu.com.cn/problem/P3154)

看到题，不会？那就搜！暴搜当然是要剪枝的。

* 剪枝1：当一只球队当前的分数已经超过题目给定的分数时，不合法

* 剪枝2：如果当前枚举的这只球队，后面就算全赢也无法达到题目给定分数，不合法

* **剪枝3**：可以手动算出能分出胜负的比赛局数 $sx$ 和平局数 $sy$ 。设所有队伍最终获得的总分为 $sum$ ，那么
  $$
  sx+sy=\frac {n\times (n-1)}{2} 
  $$ 
  $$
  3\times sx+2\times sy=sum
  $$

* **剪枝4** ：本题核心——**记忆化**！发现人数和分数集合一定时，方案数也是一定的，与每个人具体得了多少分无关。那么对于一种分数集合，我们可以把它对应的方案数存下来，之后再遇到时直接调用即可。具体实现可以用哈希。

  一个哈希时的细节：如果使用进制哈希，为了处理前导零的影响，每一位要+1。否则会被讨论区的hack数据hack掉。（感觉其他几篇题解好像没提到这一点）

一个疑惑：为什么暴搜前排个序会快很多？个人感性理解是因为能剪掉更多的枝。如果有巨佬帮忙解惑的话，我将非常感激！

感觉这题能紫完全是给剪枝4的啊！

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
namespace FGF
{
	int n,m;
	const int N=15;
	int a[N],c[N],b[N],sx,sy,sum;
	ll ans; 
	const int mo=1e9+7,se=101;
	map<ll,ll> mp;
	ll dfs(int x,int y)
	{
		if(x==n)return 1;
		if(a[x]+3*(n-y+1)<c[x])return 0;//剪枝2
		ll res=0;
		if(y>n)//剪枝4
		{
			for(int i=x+1;i<=n;i++)
				b[i]=c[i]-a[i];
			sort(b+x+1,b+n+1);
			ll h=0;
			for(int i=x+1;i<=n;i++)
				h=h*se+b[i]+1;//注意这个细节！不加1的话好像降序排序也可以
			if(mp.find(h)!=mp.end())return mp[h];
			else return mp[h]=dfs(x+1,x+2);
		}
		if(a[x]+3<=c[x]&&sx)//剪枝1
		{
			a[x]+=3;
			sx--;
			res+=dfs(x,y+1);
			a[x]-=3;
			sx++;
		}
		if(a[y]+3<=c[y]&&sx)//剪枝1
		{
			a[y]+=3;
			sx--;
			res+=dfs(x,y+1);
			a[y]-=3;
			sx++;
		}
		if(a[x]+1<=c[x]&&a[y]+1<=c[y]&&sy)//剪枝1
		{
			a[x]++,a[y]++;
			sy--;
			res+=dfs(x,y+1);
			a[x]--,a[y]--;
			sy++;
		}
		return res%mo;	
	}
	void work()
	{
		scanf("%d",&n);
		for(int i=1;i<=n;i++)
			scanf("%d",&c[i]),sum+=c[i];
		sort(c+1,c+n+1);//疑惑：不知道为什么排序后更快，可能是因为能剪掉更多的枝？
		sx=sum-n*(n-1),sy=n*(n-1)/2-sx;//剪枝3
		printf("%lld",dfs(1,2)%mo);
	}
}
int main()
{
	FGF::work();
	return 0;
}
```

---

## 作者：Gmt丶FFF (赞：1)

哈希+记忆化搜索。

正常搜索就对于每一次比赛有三种情况，第一组赢，平，第二组赢，然后判断最后分数是否符合题意即可。

剪枝1：无效性剪枝，若一个组枚举完后没有分数符合条件，返回 $0$。

剪枝2：无效性剪枝，若一个组还剩的比赛全胜也无法符合分数条件，返回 $0$。

剪枝3：优化搜索顺序，从分数大的来搜，得到赢局更多，情况会少。

剪枝4：设胜利数为 $x$，平局数为 $y$，分数总合为 $sum$，队数为 $n$。

那么：

$$\begin{aligned}

&x+y=\frac{n\times(n-1)}{2}\\
&3x+2y=num
\end{aligned}$$

解方程得到比赛数量。

优化：记忆化搜索。

记录当一个组所有比赛完后，其他组的还需要得到的分数值，分数值可利用 $30$（当然 $28$ 也行）进制存储，由于数组过大，利用 map 进行记忆化。

注意：用 map 时不能因为值不为 $0$ 而返回，而是搜索这个下表是否为 map 的末端，具体看代码。
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<map>
#define int long long
using namespace std;
const int N=15;
const int M=35;
const int mod=1e9+7;
int n,a[N],b[N],s[N],xt,yt;
map<int,int>m;
int cmp(int fi,int se)
{
	return fi>se;
}
int dfs(int x,int y)
{
	if(x==n)return 1;
	if(y>n)
	{
		if(a[x]>0)return 0;
		int num=0;
		for(int i=x+1;i<=n;i++)b[i]=a[i];
		sort(b+x+1,b+n+1);
		for(int i=x+1;i<=n;i++)num=num*27+b[i];
		if(m.find(num)!=m.end())return m[num];
		else return m[num]=dfs(x+1,x+2);
	}
	if((n-y+1)*3<a[x])return 0;
	int sum=0;
	if(a[x]>=3&&xt)
	{
		a[x]-=3;
		xt--;
		sum+=dfs(x,y+1);
		a[x]+=3;
		xt++;
	}
	if(a[x]>=1&&a[y]>=1&&yt)
	{
		a[x]--;
		a[y]--;
		yt--;
		sum+=dfs(x,y+1);
		a[x]++;
		a[y]++;
		yt++;
	}
	if(a[y]>=3&&xt)
	{
		a[y]-=3;
		xt--;
		sum+=dfs(x,y+1);
		a[y]+=3;
		xt++;
	}
	return sum;
}
signed main()
{
	scanf("%lld",&n);
	int sum=0;
	for(int i=1;i<=n;i++)scanf("%lld",&a[i]),sum+=a[i];
	sort(a+1,a+1+n,cmp);
	xt=sum-n*(n-1),yt=n*(n-1)/2-xt;
	int ans=dfs(1,2);
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：Rednoon (赞：0)

# 思路

这道题要用记忆化搜索来做这题。

如果直接暴力搜索，会出现一些重复的情况，那么这个时候我们需要进行判重性剪枝，最直接的方法就是直接记录已经走过的状态，即每个队伍的得分，     因为                                                         $n\le10$，但是也不可以直接储存，这里我们先加一个  long long   的哈希来存储，使用 map  进行判重操作。

这种方法是暴力的，但可行，只需要分析一下状态数量就可知。

 $10$ 个队伍，对于每个队伍来看，最多可以比赛  $9$ 场，得 $27$ 分，放入     hash  函数中，最大为   $7.77\times10^{12}$，在  long long 的范围之内，用  map  存储即可。

### 注意代码中搜索的小细节

-   将队伍得分从大到小排序，优先搜索分多的队伍。

-   每次与当前得分最多的队伍进行匹配。

# 附上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long a[11],b[11],n,x,y,z;
map<long,long> h;
long long dfs(long i,long j)//第i队与第j队比赛，返回总方案数。
{
    long long s=0;
    if(a[i]-3*(n-j+1)>0) return 0;
    if(j>n)//目标处理，比过所有队 
	{
        if(i==n-1) return 1;
        for(int k=i+1;k<=n;k++)
            b[k]=a[k];
        sort(b+i+1,b+n+1);//排序后用状态压缩
        for(int k=i+1;k<=n;k++)//类hash
            s=s*27+b[k]+1;
        if(h.find(s)!=h.end())//状态存在
		{
            return h[s]; //返回该状态前已经算出的方案数。 
        } 
        return h[s]=dfs(i+1,i+2); //下一个i队与其他队比赛 
    } 
    if(a[i]>2&&x)//i队还有3分可扣，并且输赢局还有剩余
	{
        a[i]-=3;--x;//设置决算胜局
        s+=dfs(i,j+1);//递归下一队
        a[i]+=3;x++;//恢复 
    }
    if(a[j]>2&&x)//j队还有3分可扣，并且输赢局有剩余 
	{
        a[j]-=3;
        x--;
        s+=dfs(i,j+1);
        a[j]+=3;x++;
    }
    if(a[i]&&a[j]&&y)//i队和j队都至少有1分，并且平局有剩余 
	{
        a[i]--;
        a[j]--;
        y--;
        s+=dfs(i,j+1);
        a[i]++;
        a[j]++;
        y++;
    }
	return s;
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++)
	{
        cin>>a[i];
        z+=a[i];//总分数 
    }
    sort(a+1,a+n+1);
    x=z-n*n+n;//输赢的局数
    y=(z-3*x)>>1;//平的局数
    cout<<dfs(1,2)%1000000007;//取模后输出 
    return 0;
}
```

---

## 作者：Others (赞：0)

很久以前的~~搜索剪枝里的一道题~~。

这题乍一看和组合数学挺像的，排排序，算算有多少个胜利，多少个平局，最后乱搞一下，但是瞎搞了一会儿，似乎不行。

这题普通的搜索显然只能挨个枚举：`dfs(i,j)` 第 $i$ 个人和第 $j$ 个人比赛，且第 $i$ 个人与 $[1,j)$ 里的人比完了，搞就行了。

这样应该没有多少分，想想怎么剪枝：

- 可行性剪枝，有两个，如果当前搜索到的分数已经超过了题目给的分数，那肯定无解；如果他与剩下的人比都赢了还不够的话，也是无解，这样好像可以多水 $10pts$。
- 记忆化搜索，记忆化搜索没有他做不到，只有你想不到（~~除非本身就无解~~）。这题的记忆化很正常，我们先来回忆一下如果可以记忆化的条件：当前的状态可以记录，这题的状态显然是每个队得到的分数（剩下的也可以），因为记忆化的精髓在于它不用管前面的，他只记后面的，于是我们将状态定义为每个队剩下的分数，如果这东西定了，那这个状态肯定也定了，就可以记忆化了。这里我们可以打 hash（~~其实打个键值丰富一点的平衡树也不是不可以~~。）
- 乱搞剪枝，记得开头说的数学吗？在最开始用数学搞的时候，我们能很轻易的算出有一方赢了的局数（$x$）和平局的局数（$y$）：$3x+2y=sum$ 和 $x+y=n$，$sum$ 和 $n$ 都是已知的，这样就可以算了（推荐手算一下，~~如果无聊可以跑高斯消元~~）。
- 这是我同学在某个地方提到的乱搞剪枝：从大到小排序，优化搜索顺序（不无道理）。

最后贴上我这丑陋的代码。

```cpp
#include <bits/stdc++.h>
#define ull unsigned long long
#define ll int
#define mod 1000000007
using namespace std;
ll sc[15],a[15];
ll n,scc[15]={ };
ll cnt1,cnt2;
map<ull,ll> Map;
ull Hash(int x){
	for(int i=x+1;i<=n;i++) a[i]=sc[i]-scc[i];
	stable_sort(a+x+1,a+n+1);
    ull tot=0;
    for(int i=x+1;i<=n;i++) tot=tot*131+a[i];
    return tot;
}
ll dfs(int i,int j){
	if(i==n+1) return 1;
	if(scc[i]>sc[i]) return 0;
	if(sc[i]-scc[i]>(n-j+1)*3) return 0; 
	if(j==n+1&&scc[i]<sc[i]) return 0;
	if(j==n+1&&scc[i]==sc[i]) {
		ull pos=Hash(i);
		if(Map.count(pos)) return Map[pos];
		else{
			ll sop=dfs(i+1,i+2);
			return Map[pos]=sop;
		}
	}
	ll pos=0;
	if(cnt1){
	    cnt1--;
    	scc[i]+=3;
    	pos+=dfs(i,j+1);
    	scc[i]-=3,scc[j]+=3;
    	pos+=dfs(i,j+1);
		scc[j]-=3,cnt1++;
	}
	if(cnt2){
	    cnt2--;
    	scc[i]+=1,scc[j]+=1;
    	pos+=dfs(i,j+1);
    	scc[i]-=1,scc[j]-=1;
    	cnt2++;
	}
	return pos%mod;
}
bool cmp(int x,int y){
	return x>y;
}
int main() {
	cin >> n;
	ll pp=0;
	for(int i=1;i<=n;++i){
		cin >> sc[i];
		pp+=sc[i];
	}
	sort(sc+1,sc+n+1,cmp);
	cnt1=pp-n*n+n;
	cnt2=(pp-3*cnt1)/2;
	cout << dfs(1,2)%mod;
	return 0;
}
```

---

## 作者：Cocoly1990 (赞：0)

首先显然想到的是暴力搜索，爆搜的方式就是 1v2->1v3...->1vN，然后 2V3...直至结尾。

然后很明显要剪枝，我们用 `dfs(nowt,nowm)` 表示现在是编号为 `nowt` 的战队打编号为 `nowm` ， `now[x]` 表示编号为 `x` 的战队的当前得分， `a[x]` 表示编号为 `x` 的战队的最终得分。给出下面几个剪枝方案：
1. 如果这个现在的得分超过了这个队的最终得分，因为即使输了也不会扣分，所以无论如何都无法满足最终的得分，那么此时应该退出。

	```cpp
 	  if (now[nowt] > a[nowt]) return;
	```
2. 如果此时的得分少的可怜，即使后面全赢这个队伍也得不到预期得分，那么此时应该退出。

	```cpp
    if(now[nowt] + (n - nowm + 1) * 3 < a[nowt]) return 0 ;
   ```
下面的剪枝就比较难想了。

3. 记忆化，这题很重要的性质就是如果人数和分数一定，那么方案数也一定，和每个人的具体得分无关，用哈希存储之后记忆化。
	
	``` cpp
	if(nowm > n)  
		{
			for(int i = nowt + 1 ; i <= n ; i ++) hashh[i] = a[i] - now[i] ;
			sort(hashh + nowt + 1 , hashh + n + 1 , cmp) ;
			ll ha = 0 ;
			for(int i = nowt + 1 ; i <= n ; i ++)	ha = ha * 97 + hashh[i] ; 
			if(hash.find(ha) != hash.end()) return hash[ha] ;
			else return hash[ha] = dfs(nowt + 1 , nowt + 2) ;  
		}
	```
4. 如果总得分是 `sum`，胜利场数是 `win`，平局场数是 `draw`，那么有

	$$\begin{cases}win + draw = \dfrac{n \times (n+1)}{2}\\ 3 \times win+2\times draw=sum\end{cases}$$
    解得
    
	$$\begin{cases}win = sum-n \times (n+1)\\ draw=\dfrac {n \times(n-1)}{2}-win\end{cases}$$
	手动解得答案即可。

	```cpp
    win = sum - n * (n - 1) , draw = n * (n - 1) / 2 - win ;
   ```
   解出答案后我们就可以以此来控制这个队胜利和平局的场数，也就是说如果现在的胜利或者平局场数超过了最后的胜利或平局场数，应该退出。
   就像这样：
   ```cpp
   if(now[nowt] + 3 <= a[nowt] && win)
   ```
5. 先搜得分大的一定状态少，为什么呢，因为得分小的比较容易被得分大的影响，也就是先搜得分大的那么得分小的的状态一定比较少。

	也就是我们更愿意第一图的样子而不是第二图。
    
	![](https://cdn.luogu.com.cn/upload/image_hosting/51ro7iv9.png)    
	![](https://cdn.luogu.com.cn/upload/image_hosting/dkr5i9ps.png)
    
   所以先搜最终得分大的。

	```cpp
    sort(a + 1 , a + n + 1 , cmp) ;
   ```
至此，剪枝完毕，核心代码已经给出，剩下的实现难度不高。

~~其实可以利用ssh直接在赛场上过的~~

---

## 作者：Celtic (赞：0)

- 算法： 深度优先搜索（~~暴力~~（逃
- 观察到 $n\leq 10$，所以我们可以用搜索来解决这道题。
- 很明显，对于每场结束的比赛，双方的得分都是不减的，所以当前搜到的这个人如果得分要比他的最终得分大的话就可以剪枝。
- 从 IDA* 方面考虑，设当前搜到 $(x,y)$的比赛，假如 $x$ 和 $y~n$比赛全都胜利，得到的分将是 $now_x+3(n-y+1)$（ $now_i$ 表示 $i$ 搜索到现在得分是多少）。
- 接下来考虑优化搜索顺序，显然先搜最终得分大的一定状态少，因为得分少的会被得分大的影响，从大的开始搜后面的无用状态会尽可能的少，所以我们按从大到小的顺序将得分排序进行搜索。
- 然后，我们可以发现胜场和负场对总分来说是等价的，贡献都是 $3$ ，平场贡献是 $2$。我们还知道总得分（$\sum_{i=1}^{n}a_i$）和总场数（ $\frac{n\times(n+1)}{2}$）。于是我们可以设胜场（负场）一共有 $x$ 场，平场一共有 $y$ 场，可以列出方程组
$$
\begin{cases} 
3x+2y=\sum_{i=1}^n a_i\\ 
x+y=\frac{n\times(n-1)}{2}\\  
\end{cases} 
$$

- 解之可得
$$
\begin{cases} 
x=-n\times(n-1)+\sum_{i=1}^n a_i\\ 
y=\frac{3n\times(n-1)}{2}-\sum_{i=1}^na_i\\  
\end{cases} 
$$

- 现在我们还能优化吗？
- 答案是：能。
- 有个东西叫做记忆化搜索，就是把搜到的结果记录下来，下次如果再要搜同样的状态时直接用就可以了。
- 那对于这道题，剩余需要得的分数数组相同时，搜索的结果是一定的，所以用哈希记录一下就可以了。
- 至此，所有剪枝完毕。
  
$\sf{Code}$
```cpp
#include<bits/stdc++.h>
#include<tr1/unordered_map>
#define re register
#define N 101001
#define MAX 2001
#define inf 1e18
using namespace std; 
typedef int ll;
typedef double db;
const ll mod=1000000007;
inline void read(re ll &ret)
{
	ret=0;re char c=getchar();re bool pd=false;
	while(!isdigit(c)){pd|=c=='-';c=getchar();}
	while(isdigit(c)){ret=(ret<<1)+(ret<<3)+(c&15);c=getchar();};
	ret=pd?-ret:ret;
	return;
}
ll n,a[N],ans,allx,ally,val[N],st[N];
ll b[MAX][MAX];
map<ll,ll>mp;
inline bool cmp(re ll x,re ll y)
{
	return x>y;
}
inline ll dfs(re ll x,re ll y,re ll nowx,re ll nowy)
{
	if(x==n)
		return 1;
	if(val[x]+(n-y+1)*3<a[x])
		return 0;
	if(y>n)
	{
		for(re int i=x+1;i<=n;i++)
			st[i]=a[i]-val[i];
		sort(st+x+1,st+n+1);
		re ll now=0;
		for(re int i=x+1;i<=n;i++)
			now=now*28+st[i];
		if(mp.find(now)!=mp.end())
			return mp[now];
		return mp[now]=dfs(x+1,x+2,nowx,nowy);
	}
	re ll ret=0;
	if(val[y]+3<=a[y]&&nowx)
		val[y]+=3,ret+=dfs(x,y+1,nowx-1,nowy),ret%=mod,val[y]-=3;
	if(val[x]+1<=a[x]&&val[y]+1<=a[y]&&nowy)
		val[x]++,val[y]++,ret+=dfs(x,y+1,nowx,nowy-1),ret%=mod,val[x]--,val[y]--;
	if(val[x]+3<=a[x]&&nowx)
	val[x]+=3,ret+=dfs(x,y+1,nowx-1,nowy),ret%=mod,val[x]-=3;
	return ret;
}
ll sum;
signed main()
{
	read(n);
	for(re int i=1;i<=n;i++)
		read(a[i]),sum+=a[i];
	allx=sum-n*n+n;
	ally=((sum-3*allx)>>1);
	sort(a+1,a+n+1,cmp);
	printf("%d\n",dfs(1,2,allx,ally));
	exit(0);
}
```

---


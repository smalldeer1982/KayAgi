# [CTSC2014] 企鹅 QQ

## 题目背景

PenguinQQ 是中国最大、最具影响力的 SNS（Social Networking Services）网站，以实名制为基础，为用户提供日志、群、即时通讯、相册、集市等丰富强大的互联网功能体验，满足用户对社交、资讯、娱乐、交易等多方面的需求。

## 题目描述

小 Q 是 PenguinQQ 网站的管理员，他最近在进行一项有趣的研究——哪些账户是同一个人注册的。经过长时间的分析，小Q发现同一个人注册的账户名称总是很相似的，例如 Penguin1，Penguin2，Penguin3……于是小 Q 决定先对这种相似的情形进行统计。

小 Q 定义，若两个账户名称是相似的，当且仅当这两个字符串等长且恰好只有一位不同。例如“Penguin1”和“Penguin2”是相似的，但“Penguin1”和“2Penguin”不是相似的。而小 Q 想知道，在给定的 $n$ 个账户名称中，有多少对是相似的。

为了简化你的工作，小Q给你的N 个字符串长度均等于L ，且只包含大小写字母、数字、下划线以及‘@’共64种字符，而且不存在两个相同的账户名称。

## 说明/提示

$4$ 对相似的字符串分别为：Fax 与 fax，Fax 与 max，fax 与 max，max 与 mac。

测试点编号|$N$|$L$|$S$
:-:|:-:|:-:|:-:
$1$|$50$|$10$|$64$
$2$|$500$|$100$|$64$
$3$|$3000$|$100$|$2$
$4$|$3000$|$100$|$64$
$5$|$30000$|$50$|$2$
$6$|$30000$|$50$|$64$
$7$|$30000$|$200$|$2$
$8$|$30000$|$200$|$64$
$9$|$30000$|$200$|$2$
$10$|$30000$|$200$|$64$

## 样例 #1

### 输入

```
4 3 64
Fax
fax
max
mac```

### 输出

```
4```

# 题解

## 作者：serverkiller (赞：41)

# 题意

给定$n$个字符串 问两个字符串只差一个字符的字符串对的数量

# solution

没错 我又来卡空间了.在Mr_zherui的题解中 使用了两个数组来储存前后的hash值之和 但是我们其实可以利用前缀和来优化成一个数组qwq

基于上述的 我写了下面这份代码 利用的是进制hash 具体的看注释吧 最主要是在求相等的时候排序可以将复杂度从$O(n^2)$降为$O(nlog_2n+n)$就比较满意了

```
#include <bits/stdc++.h>
#define ll long long
using namespace std;

int n,l,s;
ll ha[30005][205],t[30005],Hina[205];//记得开longlong蛤
const int p = 2333;

int main()
{
	scanf("%d%d%d",&n,&l,&s);
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= l; j++)
		{
			char c;
			cin >> c;//注意cin输入的时候是过滤换行符的 而scanf是读入换行符的 被这里卡着了
			ha[i][j] = ha[i][j - 1] * p + c;
		}
	}
	Hina[0] = 1;
	for (int i = 1; i <= l; i++)
	{
		Hina[i] = Hina[i - 1] * p;
	}//这里预处理出每一位的数量
	int ans = 0;
	for (int i = 1; i <= l; i++)
	{
		for (int j = 1; j <= n; j++)
		{
			t[j] = ha[j][l] - (ha[j][i] - ha[j][i - 1] * p) * Hina[l - i] - ha[j][i - 1] * (Hina[l - i + 1] - Hina[l - i]);
                        //去掉给第j个字符串第i位后的hash值 是整个的hash值 减掉这个位置的hash*Hina[l - i] 再减掉前面的数的hash*(Hina[l - i + 1]-Hina[l - i]) 
         		//其实可以去个括号就比较简洁了 但是我懒（
		}
		sort(t + 1,t + n + 1);//这里就是那个排序的地方啦
		int tmp = 1;
		for (int j = 1; j < n; j++)
		{
			if (t[j] != t[j + 1]) tmp = 1;
			else 
			{
				ans += tmp;
				tmp++;
			}
		}
	}
	printf("%d\n",ans);//输出答案qwq
	//system("pause");
	return 0;
}
```
写完这个代码没完 我们注意到$char$占$1$个字节 而$longlong$占了$8$个字节 所以我们可以保存$char$而不去保存每个位置的前缀和 

因为这里进制hash去掉某一位的时候可以单单将那一位变成0而不需要将前面的数位后移 因此有了这个代码:
```
#include <bits/stdc++.h>
#define ll long long
using namespace std;

int n,l,s;
ll ha[30005],t[30005],Hina[205];
char c[300005][205];
const int p = 2333;

int main()
{
	scanf("%d%d%d",&n,&l,&s);
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= l; j++)
		{
			cin >> c[i][j];
			ha[i] = ha[i] * p + c[i][j];
		}
	}
	Hina[0] = 1;
	for (int i = 1; i <= l; i++)
	{
		Hina[i] = Hina[i - 1] * p;
	}
	int ans = 0;
	for (int i = 1; i <= l; i++)
	{
		for (int j = 1; j <= n; j++)
		{
			t[j] = ha[j] - c[j][i] * Hina[l - i];
		}
		sort(t + 1,t + n + 1);
		int tmp = 1;
		for (int j = 1; j < n; j++)
		{
			if (t[j] != t[j + 1]) tmp = 1;
			else 
			{
				ans += tmp;
				tmp++;
			}
		}
	}
	printf("%d\n",ans);
	//system("pause");
	return 0;
}
```

这份代码的评测记录如下:
![](https://cdn.luogu.com.cn/upload/image_hosting/w0y4u9hc.png)

卡内存完毕x

---

## 作者：奔波儿霸 (赞：21)

### 思路
首先想到肯定是暴力的进行比较，两两判断看是否相似，这样的话时间复杂度少说也上了${O(n^2)}$，$TLE$在所难免。

那么久考虑一种更优的算法，将前缀和的思想加入到$hash$中，分别按照从前往后的顺序和从后往前的顺序生成两个$hash$数组。用$O(n)$的时间就可以完成预处理。

然后我们考虑枚举哪一位是不相同的，比较将这一位删去后的串的$hash$值是否相等，那么这个$hash$值我们可以借助两个$hash$数组在$O(1)$的时间内算出来，设这一位是$j$，那么我们只需要将$hash1[j-1]$和$hash[j+1]$的值加起来就可以的到删除掉以为之后的$hash$值。当然这两个$hash$数组都是二维的，上面的表示中省去的是第一维，第一维的意义是字符串的编号。

值得一提的是在比较的时候如果你写的很暴力的话，还是会$TLE$，所以我们使用$sort$将其排序，比较相邻的$hash$值，这样可以节省时间。算法的总时间复杂度就是$O(nl\log n)$，显然能过。

~~吐槽一下评测姬，是不是该换了。。。。。。~~

### 代码
```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>

const int maxn = 30003;
typedef unsigned long long ULL;
const ULL base = 131;
const int Mod = 1e9+7;

using namespace std;

int n, l, s, Ans;
ULL hs1[maxn][233], hs2[maxn][233], hs[maxn];
char ch[maxn][233];

inline void init(int x) {
	for(register int i=1; i<=l; i++) {
		hs1[x][i] = hs1[x][i-1] * 131 + ch[x][i];
	}
	for(register int i=l; i>=1; i--) {
		hs2[x][i] = hs2[x][i+1] * 137 + ch[x][i];
	}
}

int main() {
	scanf("%d%d%d", &n, &l, &s);
	for(register int i=1; i<=n; i++) {
		scanf("%s", ch[i]+1);
		init(i);
	}
	for(register int i=1; i<=l; i++) {
		for(register int j=1; j<=n; j++) {
			hs[j] = hs1[j][i-1]*233 + hs2[j][i+1]*211;
		}
		sort(hs+1, hs+1+n);
		int ans = 1;
		for(register int j=1; j<n; j++) {
			if(hs[j] == hs[j+1]) Ans += ans, ans ++;
			else ans = 1;
		}
	}
	printf("%d", Ans);
}
```

---

## 作者：lyyi2003 (赞：12)

好多人写单哈希被卡了？

这里有一种**不会被卡哈希**的办法．

设$pw_i=base^i$，则传统哈希的哈希值$hash=\sum pw_i*s[i]$，但我这里的哈希是将$pw_i$换成一个$long \ long$范围内的随机数，这样就可以防卡哈希了．

具体可以看代码里函数$Init()$那部分．

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 30007
#define M 207
#define ll long long
const int lim=200;
const ll Max=1e15;
const ll base=131;
char s[N][M];
ll pw[M],hs[N];
ll a[N];
ll rn(ll x,ll y)
{
	return ((ll)rand()<<31|rand())%(y-x+1)+x;
}
void Init()
{
	pw[0]=1;
	for(int i=0;i<=lim;i++)
		pw[i]=rn(1,Max);
	//这里本来应该是 pw[i]=pw[i-1]*base;
}
int main()
{
	int n,m,x;
	srand((unsigned)time(NULL));
	Init();
	scanf("%d%d%d",&n,&m,&x);
	for(int i=1;i<=n;i++)
		scanf("%s",s[i]);
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<m;j++)
			hs[i]=hs[i]+pw[j]*s[i][j];
	}
	ll ans=0;
	for(int i=0;i<m;i++)
	{
		for(int j=1;j<=n;j++)
		{
			ll x=hs[j]-pw[i]*s[j][i];
			a[j]=x;
		}
		sort(a+1,a+n+1);
		ll cnt=0;
		for(int j=1;j<=n;j++)
		{
			if(j==1||a[j]!=a[j-1])
				ans+=cnt*(cnt-1)/2,cnt=1;
			else cnt++;
		}
		ans+=cnt*(cnt-1)/2;
	}
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：清风我已逝 (赞：10)

夏令营讲了，回来巩固一下
```
1.预处理，算出前i段的哈希值（这里使用的为进制哈希）
2.根据题意，枚举不同位是哪一位，
  求所有字符串在去掉这一位后的哈希值，
  用排序等方法统计相同的对数。
3.O(lnlog2n)
```
```
那么如何求去掉一位的哈希值呢？

设去掉第k位,长度为l

HS=hs[i-1]*base^(l-i)+hs[l]-hs[i]*base^(l-i);
```

```cpp
#include<bits/stdc++.h>

#define N 30105
#define ull unsigned long long

using namespace std;

ull hsi[N][250],base=233,mod=2123,hs[N];
ull pw[N];
int n,l,s,ans;
char ss[N][250];

void init(){
	pw[0]=1; 
	for(int i=1;i<=l;i++) pw[i]=pw[i-1]*base;
}//预处理进制

int main()
{
	scanf("%d%d%d",&n,&l,&s);
	for(int i=1;i<=n;i++) cin>>ss[i];
	init();
	for(int i=1;i<=n;i++){
		for(int j=1;j<=l;j++){
			hsi[i][j]=hsi[i][j-1]*base+ss[i][j-1];
		}
	}//求解哈希值
	for(int i=1;i<=l;i++){
		for(int j=1;j<=n;j++){
			hs[j]=hsi[j][i-1]*pw[l-i]+hsi[j][l]-hsi[j][i]*pw[l-i];
		}
		sort(hs+1,hs+1+n);
		int t=1;
		for(int j=1;j<=n;j++){
			if(hs[j]!=hs[j-1]) t=1;
			else ans+=t,++t;
		}//sort+模拟
	}cout<<ans;
	return 0;
}
```

---

## 作者：Caicz (赞：8)

懒惰引发的惨案

关于hash，首先我们可以知道
有**一维hash 和二维hash**，

二维hash是永久化储存，方便接下来操作，但缺点是耗空间比较大

一维hash就像个工具人，用完就扔

注：本人直接用的unsigned long long 自然取模

**p值取 23 会被hack 4个点（别问我怎么知道）**

闲话分界线
------------

头一眼看到本题，乍一看没有什么思路
，仔细想了一小会儿，想出个O( n^2 )的算法
> **对每一个字符串进行hash处理**
>
> **暴力对每一对（i,j）进行相减**
>
> **如相减后的数能被 p（basic）整除，则成立**

心里美滋滋的想着可以ac时，一看数据范围，傻眼了
于是开始想优化（后来一想，好像此思路也有些问题）

+ 首先，我们是对每一对数相减后进行整除，我们可以在求出所有字符串的hash值后，再枚举该去掉哪一位
+ 其次，用**cnt[i]表示第i条子串去掉当前枚举的数位后的hash值**但是，怎么计算呢？

> **cnt[i]=h[len]\-(h[k] &times; p^(len-k))\+(h[k-1] &times; p^(len-k))**

+ 之后，我们对cnt数组进行排序，然后模拟找存在多少对

复杂度O(nl)

代码：
```cpp
#include<stdio.h>
#include<iostream>
#include<cstring>
#include<algorithm>
#define ull unsigned long long
#define p 233
using namespace std;
ull cnt[30000*201],sq[205];
ull h[30005][205];
int n,l,S,ct;
int ans,sum[30005];
char s[205];

int main()
{
	scanf("%d%d%d",&n,&l,&S);
	sq[0]=1;
	for(int i=1;i<=l;i++)
		sq[i]=sq[i-1]*p;
	for(int i=1;i<=n;i++)
	{
		scanf("%s",s+1);
		for(int j=1;j<=l;j++)
			h[i][j]=h[i][j-1]*p+s[j];
	}
	for(int k=1;k<=l;k++)
	{
		for(int i=1;i<=n;i++)
			cnt[i]=h[i][l]-h[i][k]*sq[l-k]+h[i][k-1]*sq[l-k];
		sort(cnt+1,cnt+1+n);
		int t=1;
		for(register int i=1;i<=n;i++)
			if(cnt[i]==cnt[i-1])
			{
				ans+=t;
				++t;
			}
			else
				t=1;
	}
	printf("%d",ans);
	return 0;
}
```


---

## 作者：Manjusaka丶梦寒 (赞：7)

枚举每一位字符，计算字符两侧的哈希值，然后进行比较，用map或排序记录出与其相同的字符串数量。

时间复杂度O(nlogn)

听起来虽然比较好实现，细节都在代码里。
```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cstdio>
using namespace std;
#define LL long long
#define N int(3e4+2)
#define M int(2e2+2)
#define base1 233 
#define base2 211
int n,m,l,ans;
char s[M];
unsigned long long temp[N],before[N][M],behind[N][M];
void work(int x)
{
    for(int i=1;i<=l;i++)before[x][i]=before[x][i-1]*149+s[i];
    for(int i=l;i>=1;i--)behind[x][i]=behind[x][i+1]*137+s[i];
}
int main()
{
    scanf("%d%d%d",&n,&l,&m);
    for(int i=1;i<=n;i++)
    {
        scanf("%s",s+1);
        work(i);
    }
    for(int j=1;j<=l;j++)
    {
        for(int i=1;i<=n;i++)temp[i]=before[i][j-1]*233+behind[i][j+1]*213;
        sort(temp+1,temp+1+n);
        int now=1;
        for(int i=2;i<=n;i++)
        {
            if(temp[i]==temp[i-1])ans+=now,now++;
            else now=1;
        }
    }
    printf("%d",ans);
}
```

---

## 作者：单曦增 (赞：6)

似乎大家全部都用的是hash？那我讲一个不用hash的做法吧。

首先考虑只有一位不同的是哪一位，那么这一位前面的位上的字符一定是全部相同，后面的字符也是全部相同。首先考虑后面的字符。

我们对n个串的反串建trie树，这样，每一个后缀就对应一个trie树上的唯一一个节点，不同的后缀对应的就是不同的节点，这样就不用hash表了。

但是字符集很大，用trie空间太大，那么就用邻接表或map存边就好了。

然后就是令前缀全部相同。那么我们从左到右枚举每一位，按照当前位的字符进行分治，当前位不同的就通过后缀计算贡献，相同的就放在一起，继续分治即可。

然后就跑的飞快，目前是BZOJ rk2,Luogu rk1。

实现的时候有很多细节，具体请参考代码。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
#include<cctype>
#define qmin(x,y) (x=min(x,y))
#define qmax(x,y) (x=max(x,y))
#define vi vector<int>
#define vit vector<int>::iterator
#define pir pair<int,int>
#define fr first
#define sc second
#define mp(x,y) make_pair(x,y)
#define rsort(x,y) sort(x,y),reverse(x,y)
using namespace std;

inline char gc() {
//	static char buf[100000],*p1,*p2;
//	return (p1==p2)&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
	return getchar();
}

template<class T>
int read(T &ans) {
	ans=0;char ch=gc();T f=1;
	while(!isdigit(ch)) {
		if(ch==EOF) return -1;
		if(ch=='-') f=-1;
		ch=gc();
	}
	while(isdigit(ch))
		ans=ans*10+ch-'0',ch=gc();
	ans*=f;return 1;
}

template<class T1,class T2>
int read(T1 &a,T2 &b) {
	return read(a)!=EOF&&read(b)!=EOF?2:EOF;
}

template<class T1,class T2,class T3>
int read(T1 &a,T2 &b,T3 &c) {
	return read(a,b)!=EOF&&read(c)!=EOF?3:EOF;
}

typedef long long ll;
const int Maxn=6100000;
const int Maxm=31000;
const int Maxl=210;
const int inf=0x3f3f3f3f;

int to[Maxn],nxt[Maxn],first[Maxn],tot=1;
char w[Maxn],s[Maxm][Maxl];
int p[Maxm][Maxl],n,len,x,po[Maxl][Maxl],qq[Maxl],bj[Maxl],ans;
int a[Maxm],siz[Maxl],b[Maxm],tn[Maxn],cnt=1;
queue<int> q[Maxl];

inline void add(int u,int v,char wi) {
	to[tot]=v;
	nxt[tot]=first[u];
	w[tot]=wi;
	first[u]=tot++;
}

void solve(int l,int r,int cur) {
	if(l>r) return ;
	if(cur==len) return ;
	int cnt=0;
	for(int i=l;i<=r;i++) {
		int x=s[a[i]][cur];
		q[x].push(a[i]);
		siz[x]++;
		if(!bj[x]) qq[++cnt]=x,bj[x]=1;
	}
	if(cnt==1) {
		for(int i=1;i<=cnt;i++) bj[qq[i]]=siz[qq[i]]=0;
		while(!q[qq[1]].empty()) q[qq[1]].pop();
		solve(l,r,cur+1);
	}
	else {
		int sxz,zhy=0;
		for(int i=1;i<=cnt;i++) {
			if(siz[qq[i]]>zhy) {
				sxz=i;
				zhy=siz[qq[i]];
			}
		}
		swap(qq[cnt],qq[sxz]);
		int las=l;po[cur][0]=las;
		for(int i=1;i<cnt;i++) {
			int x=qq[i],num=0;
			while(!q[x].empty()) {
				int now=q[x].front();
				q[x].pop();
				b[++num]=p[now][cur+1];
				ans+=tn[b[num]];
				a[las++]=now;
			}
			while(num) tn[b[num--]]++;
			po[cur][i]=las;
		}
		while(!q[qq[cnt]].empty()) {
			int now=q[qq[cnt]].front();
			q[qq[cnt]].pop();
			ans+=tn[p[now][cur+1]];
			a[las++]=now;
		} po[cur][cnt]=las;
		for(int i=l;i<po[cur][cnt-1];i++) tn[p[a[i]][cur+1]]--;
		for(int i=1;i<=cnt;i++) bj[qq[i]]=siz[qq[i]]=0;
		for(int i=1;i<=cnt;i++)
			solve(po[cur][i-1],po[cur][i]-1,cur+1);
	}
}

signed main() {
//	freopen("test.in","r",stdin);
	read(n,len,x);
	for(int i=1;i<=n;i++) {
		scanf("%s",s[i]);
		int now=1;
		for(int j=len-1;j>=0;j--) {
			int temp=0;
			for(int k=first[now];k;k=nxt[k])
				if(w[k]==s[i][j]) {
					temp=to[k];
					break;
				}
			if(!temp) add(now,++cnt,s[i][j]),temp=cnt;
			now=temp;
			p[i][j]=now;
		}
	}
	for(int i=1;i<=n;i++) a[i]=i;
	solve(1,n,0);
	printf("%d\n",ans);
	return 0;
}



```

---

## 作者：_Camille_ (赞：5)

### 前言
sk 邀请做一下这道题目，于是我就来了

### 思路
 
一开始之间想到的是暴力枚举，但很明显时间复杂度 O(n^2) 必然TLE，然后与 sk 稍微交流了一下，发现一种 O(nl log n) 的解法。具体就是先求出字符两侧的 Hash 值，然后用 sort 排序记录一下相同的字符串数量。细节不多，但实现还是有难度的。注释在代码里。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ull unsigned long long 
int n,l,m;
int ans;
char s[201];
ull q[30001][201],h[30001][201];
ull tmp[30001];//我开了ull，但是long long就可以了。
int main(){
    cin>>n>>l>>m;
    for(int i=1;i<=n;i++){
        scanf("%s",s+1);//注意一下过滤第一次输出，这样处理应该比较简单。
        for(int j=1;j<=l;j++){
            q[i][j]=q[i][j-1]*149+s[j];
        }
        for(int j=l;j>=1;j--){
            h[i][j]=h[i][j+1]*137+s[j];
        }//计算两侧hash。
    }
    for(int i=1;i<=l;i++){
        for(int j=1;j<=n;j++){
            tmp[j]=q[j][i-1]*233+h[j][i+1]*213;//两边hash汇总给tmp数组
        }
        sort(tmp,tmp+n+1);排序
        int f=1;
        for(int j=2;j<=n;j++){
            if(tmp[j]==tmp[j-1]){
                ans+=f;
                f++;
            }
            else{
                f=1;
            }
        }//模拟求出答案
    }
    cout<<ans;
    return 0;
}
```
具体实现就是这样，有什么不懂还可以私信我。

管理员审核辛苦了

P.S刚才算法复杂度写错了管理员再审核一遍谢谢了qwq

---

## 作者：Drinkkk (赞：4)

【参考资料】

hzwer的博客 - 「BZOJ3555」[Ctsc2014] 企鹅QQ：http://hzwer.com/5121.html 。

【题目背景】

PenguinQQ是中国最大、最具影响力的SNS（Social Networking Services）网站，以实名制为基础，为用户提供日志、群、即时通讯、相册、集市等丰富强大的互联网功能体验，满足用户对社交、资讯、娱乐、交易等多方面的需求。

【题目描述】

小Q是PenguinQQ网站的管理员，他最近在进行一项有趣的研究——哪些账户是同一个人注册的。经过长时间的分析，小Q发现同一个人注册的账户名称总是很相似的，例如Penguin1，Penguin2，Penguin3……于是小Q决定先对这种相似的情形进行统计。

小Q定义，若两个账户名称是相似的，当且仅当这两个字符串等长且恰好只有一位不同。例如“Penguin1”和“Penguin2”是相似的，但“Penguin1”和“2Penguin”不是相似的。而小Q想知道，在给定的n 个账户名称中，有多少对是相似的。

为了简化你的工作，小Q给你的$n$ 个字符串长度均等于$l$ ，且只包含大小写字母、数字、下划线以及‘@’共$64$种字符，而且不存在两个相同的账户名称。

【输入输出格式】

- 输入格式
第一行包含三个正整数$n$ ，$l$ ，$s$ 。其中$n$表示账户名称数量，$l$ 表示账户名称长度，$s$ 用来表示字符集规模大小，它的值只可能为$2$或$64$。

若$s$ 等于$2$，账户名称中只包含字符``‘0’``和``‘1’``共$2$种字符；

若$s$ 等于$64$，账户名称中可能包含大小写字母、数字、下划线以及``‘@’``共$64$种字符。

随后$n$ 行，每行一个长度为$l$ 的字符串，用来描述一个账户名称。数据保证$n$ 个字符串是两两不同的。

- 输出格式
仅一行一个正整数，表示共有多少对相似的账户名称。

【输入输出样例】

- 输入样例
```
4 3 64
Fax
fax
max
mac
```
- 输出样例
```
4
```
【说明】

$4$对相似的字符串分别为：``Fax``与``fax``，``Fax``与``max``，``fax``与``max``，``max``与``mac``。

【数据范围】


| 测试点编号 | $n$ | $l$ | $s$ |
| :-----------: | :-----------: | :-----------: | :-----------: |
| 1 | 50 | 10 | 64 |
| 2 | 500 | 100 | 64 |
| 3 | 3000 | 100 | 2 |
| 4 | 3000 | 100 | 64 |
| 5 | 30000 | 50 | 2 |
| 6 | 30000 | 50 | 64 |
| 7 | 30000 | 200 | 2 |
| 8 | 30000 | 200 | 64 |
| 9 | 30000 | 200 |  2|
| 10 | 30000  | 200 | 64 |

【题解】

hzwer太强啦~

我们在这里考虑用$h[x][i]$表示输入的$x$个字符串中的第$1$~$i$个字符的哈希值，并用$t[x][i]$来表示输入的$x$个字符串中的第$m$~$i$个字符的哈希值。如果你想要了解什么事哈希或者想要了解更多的生成哈希值的方式还请看[这里](https://www.luogu.org/blog/zzj/ti-xie-p4289-haoi2008-yi-dong-wan-ju-post)~

然后就可以放心的做啦~接着枚举删除某一位然后再暴力统计即可。时间复杂度大约为$\Theta(m \times n\;log_2\;n)$。

下面上AC代码~
```
#include <cstdio>
unsigned long long tmp[30001],h[30001][205],t[30001][205];
unsigned long long n=0,m=0,k=0;
char st[30001];
void px(unsigned long long l,unsigned long long r)
{
    unsigned long long x=l,y=r,mid=tmp[(l+r)/2];
    while(x<=y)
    {
        while(tmp[x]<mid)
        {
            x++;
        }
        while(tmp[y]>mid)
        {
            y--;
        }
        if(x<=y)
        {
            unsigned long long pt=tmp[x];
            tmp[x]=tmp[y];
            tmp[y]=pt;
            x++;
            y--;
        }
    }
    if(l<y)
    {
        px(l,y);
    }
    if(x<r)
    {
        px(x,r);
    }
}
void hash(unsigned long long x)
{
    for(unsigned long long i=1;i<=m;i++)
    {
        h[x][i]=h[x][i-1]*149+st[i];
    }
    for(unsigned long long i=m;i>=1;i--)
    {
        t[x][i]=t[x][i+1]*137+st[i];
    }
}
int main()
{
    unsigned long long ans=0;
    scanf("%llu %llu %llu",&n,&m,&k);
    for(unsigned long long i=1;i<=n;i++)
    {
        scanf("%s",st+1);
        hash(i);
    }
    for(unsigned long long j=1;j<=m;j++)
    {
        for(unsigned long long i=1;i<=n;i++)
        {
            tmp[i]=h[i][j-1]*233+t[i][j+1]*213;
        }
        px(1,n);
        unsigned long long now=1;
        for(unsigned long long i=2;i<=n;i++)
        {
            if(tmp[i]==tmp[i-1])
            {
                ans+=now++;
            }
            else
            {
                now=1;
            }
        }
    }
    printf("%llu",ans);
    return 0;
}
```

---

## 作者：yi_heng (赞：2)

        要用一下O2优化哦！！!
说明： 果然我还是太naive

思路：枚举哪一位不同，取左边和右边的hash值进行比较统计

hash值先预处理

复杂度:[Math Processing Error]

然而这个题大家都用的是自动溢出取模，我并不知道说明时候该用这个。之前等价表达式用被卡出shi来.

code：

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#define ll long long
using namespace std;
const int N=30010;
const ll mod=1e9+7;
const ll base=233;
pair <ll,ll> dx[N];
char c[N][203];
int n,l,s,ans;
ll f1[N][203],f2[N][203];
int main()
{
    scanf("%d%d%d",&n,&l,&s);
    for(int i=1;i<=n;i++)
        scanf("%s",c[i]+1);
    ll t=1;
    for(int j=1;j<=l;j++)
    {
        for(int i=1;i<=n;i++)
            f1[i][j]=(f1[i][j-1]+t*c[i][j])%mod;
        t=(t*base)%mod;
    }
    t=1;
    for(int j=l;j>=1;j--)
    {
        for(int i=1;i<=n;i++)
            f2[i][j]=(f2[i][j+1]+t*c[i][j])%mod;
        t=(t*base)%mod;
    }
    for(int i=1;i<=l;i++)
    {
        for(int j=1;j<=n;j++)
        {
            dx[j].first=f1[j][i-1];
            dx[j].second=f2[j][i+1];
        }
        sort(dx+1,dx+1+n);
        int cnt=0;
        for(int j=1;j<=n;j++)
        {
            if(dx[j]==dx[j-1]) cnt++;
            if(dx[j]!=dx[j-1])
            {
                ans+=(cnt-1)*cnt/2;
                cnt=1;
            }
        }
        ans+=(cnt-1)*cnt/2;
    }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：Memory_of_winter (赞：1)

[我的博客](https://www.cnblogs.com/Memory-of-winter/p/10349887.html)

**题目大意：**给你$n(n\leqslant3\times10^4)$个长度为$l(l\leqslant200)$的字符串，要你求出有多少对字符串是相似的，相似的定义是两个字符串只在一位上不同。

**题解：**可以对每一位求出去掉这一位后的字符串$hash$值，发现直接算可能有点烦，考虑异或的自反性（$a\oplus b\oplus a=b$），可以在$hash$时把每一位的结果异或起来，求扣除一位的$hash$值时只需要再异或上这一位即可。

用异或的话，需要给每一位一个权值，可以直接$rand$求出。

最后给存扣除每一位的数组排一个序，找其中相同的元素个数即可。



**C++ Code：**

```cpp
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <vector>
#define maxn 30010
#define maxl 210

inline unsigned long long randllu() { return static_cast<unsigned long long> (rand()); }
inline unsigned long long RAND() {
	return randllu() << 48 ^ randllu() << 32 ^ randllu() << 16 ^ randllu();
}

int n, l, ans;
unsigned long long len[256], str[256];
std::vector<unsigned long long> v[maxl];
int main() {
	srand(20040826);
	scanf("%d%d%*d", &n, &l);
	for (int i = 0; i < 256; ++i) {
		len[i] = RAND();
		str[i] = RAND();
	}
	for (int i = 1; i <= n; ++i) {
		static char s[maxl];
		scanf("%s", s);
		unsigned long long hsh = 0;
		for (int i = 0; i < l; ++i) hsh ^= len[i] * str[s[i]];
		for (int i = 0; i < l; ++i) v[i].push_back(hsh ^ len[i] * str[s[i]]);
	}
	for (int len = 0; len < l; ++len) {
		std::vector<unsigned long long> &V = v[len];
		std::sort(V.begin(), V.end());
		for (std::vector<unsigned long long>::iterator l = V.begin(); l != V.end(); ) {
			unsigned long long ch = *l;
			int now = 0;
			while (l != V.end() && *l == ch) ++l, ans += now++;
		}
	}
	printf("%d\n", ans);
	return 0;
}

```



---

## 作者：Panthera_AFO (赞：0)

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cctype>
#include<algorithm>
using namespace std;
typedef unsigned long long ll;

ll const maxn=30111,radix=26363,radix2=204917;
char a[210];
ll hash[maxn][210],hash2[maxn][210];
int n,l,s,cnt;
ll ans[maxn];

inline void hs(int x){
    for(int i=1;i<=l;i++)
        hash[x][i]=(hash[x][i-1]*radix+a[i]);
    for(int i=l;i>=1;i--)
        hash2[x][i]=(hash2[x][i+1]*radix2+a[i]);
}
        
int main(){
    cin>>n>>l>>s;
    for(int i=1;i<=n;i++){
        scanf("%s",a+1);
        hs(i);
    }
    for(int i=1;i<=l;i++){
        for(int j=1;j<=n;j++)
            ans[j]=hash[j][i-1]*(radix+666)+hash2[j][i+1]*(radix2+666);
        sort(ans+1,ans+1+n);
        int num=1;
        /*for(int j=2; j<=n; j++){
            if(ans[j]==ans[j-1])
            	num++;
            else if(num>1)
            	cnt+=((num+1)*num)/2;
        }*/
        for(int j=2; j<=n; j++) {
            if(ans[j]==ans[j-1])cnt+=num++;
            else num=1;
        }
    }
    cout<<cnt;
    return 0;
}
```

---


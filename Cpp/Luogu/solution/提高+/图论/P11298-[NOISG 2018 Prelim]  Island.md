# [NOISG 2018 Prelim]  Island

## 题目背景

翻译自 [NOISG 2018 Prelim C. Island](https://github.com/noisg/sg_noi_archive/tree/master/2018_prelim)。

**本题已启用 Special Judge，满足题目条件的任何答案都将视为正确。保证 SPJ 用时不超过 $1$ 秒**。

## 题目描述

老鼠吱吱发现了一座小岛，这座小岛上的人以捕鱼为生，所以他们的 $n$ 所房子（标号为 $1$ 到 $n$）都在小岛的**边缘**，大家还需要交换各自的鱼，所以有些路在小岛的中间。

为了连接城镇，在岛的内部创建了 $m$ 个路口（标号为 $n+1$ 到 $n+m$）。为了最大限度地降低建设成本，这个岛上**只有 $n+m−1$ 条路**，这样任何两个城镇之间就有且仅有一条路。

换言之，道路网络可以**表示为一棵树**，有 $n$ 个叶子（代表 $n$  所房子）和 $m$ 个非叶子节点（代表 $m$ 个路口）。根据树的性质，这棵树有 $n+m−1$条边（代表 $n+m-1$ 条路）。

此外，**每个路口至少有三条路与之相连**，除了路口外，路不会与其他路相交，也没有桥梁或隧道（它们很贵）。以下是一个有 $37$ 所房子、$20$ 个路口和 $56$ 条道路的岛的参考图：

![](https://cdn.luogu.com.cn/upload/image_hosting/h32hwja1.png)

老鼠吱吱很喜欢这座小岛，但是因为某种原因，它的地图被吹走了。但是吱吱想规划它的行程，所以他想知道小岛房子的位置。

幸运的是，它记录了**每一条道路的起点和终点**的观察记录本还在，现在请你推出，共有几种不同的情况使得小岛房子的位置不同。

**注意小岛是环形的，经过旋转完全一样的顺序视为同一种顺序**。

## 说明/提示

### 【样例 #1 解释】
有 $12$ 种合法的排列，如下图。

使用其他的方式（如 $4^1\times3^1$）也是可以的。

所有排列如下：
![](https://cdn.luogu.com.cn/upload/image_hosting/847a8hm5.png)
### 【样例 #2 解释】
有 $24$ 种合法的排列，其中一种如下：
![](https://cdn.luogu.com.cn/upload/image_hosting/xrc1rdel.png)

算出答案是 $5!=120$ 的很有可能是因为没有考虑旋转后一样的视为同一种方案的问题。
### 【样例 #3 解释】
有 $24$ 种合法的排列，其中一种如下：
![](https://cdn.luogu.com.cn/upload/image_hosting/d7xgyycj.png)
### 【数据范围】
| $\text{Subtask}$ | 分值 | 特殊性质 |
| :----------: | :----------: | :----------: |
| $0$ | $0$ | 样例 |
| $1$ | $7$ | $n+m\leq 2\times 10^5,m\leq1$ |
| $2$ | $20$ | $n+m\leq 2\times 10^5,m\leq10$ |
| $3$ | $31$ | $n+m\leq 10^3$ |
| $4$ | $42$ | $n+m\leq 2\times 10^5$ |

对于 $100\%$ 的数据：
- $2 \leq n,0\leq m$
- $n+m \leq 2\times10^5$

## 样例 #1

### 输入

```
5 2
1 7
3 7
6 2
7 4
6 7
5 6```

### 输出

```
3 1
4 1```

## 样例 #2

### 输入

```
5 1
6 1
6 2
6 3
6 4
6 5```

### 输出

```
3 1
2 3```

## 样例 #3

### 输入

```
6 3
7 1
7 2
8 3
8 4
9 5
9 6
7 8
9 8```

### 输出

```
24 1```

# 题解

## 作者：xiaoliebao1115 (赞：2)

水题。

假设固定节点 $1$ 的位置，这样答案最后就不用除以 $n$ 了。

那么我们从 $1$ 开始 dfs，令 $f_u$ 为以 $u$ 为根的子树的排列方案数，$s$ 为 $u$ 儿子个数，那么有 $f_u=\prod f_v\times s!$，因为儿子的排列可以随便换，每种换出来的都不一样。

那么答案就被转化为所有 $2$ 到 $n+m$ 的点的 $e_u-1$ 乘积再乘上 $e_1$，因为除了 $1$ 之外其他点的儿子数量就等于边数减一，其中 $e_x$ 表示 $x$ 的度数。

对于每一个点的贡献在数组上面记录，然后做一个后缀就可以求出对于每一个数在答案中有几个。

```cpp
for(int i=1;i<n+m;i++){
	int u,v;
	cin>>u>>v;
	ecnt[u]++,ecnt[v]++;
}
p[ecnt[1]]++;
for(int i=2;i<=n+m;i++) p[ecnt[i]-1]++;
int s=0;
for(int i=n+m;i>=2;i--){
	s+=p[i];
	p[i]=s;
	if(p[i]) cout<<i<<" "<<p[i]<<endl;
}
```

---

## 作者：AmaoFox (赞：0)

我们可以令任意一个路口 $r$ 作为根。

令 $G_i$ 表示点 $i$ 相邻的点一共有多少个，那么 $r$ 一共有 $G_r$ 个儿子。除此之外的每一个路口 $u$ 各有 $G_{u} - 1$ 个儿子，因为另一个是它的父亲。

每一个节点都可以进行排列，每一种排列都会成为一种新的树，因为左边儿子对应的房子不能放到右边儿子对应的房子的右边。因此，对于每个非根路口，都会对答案进行乘法原理贡献 $(G_{u} - 1)!$ 的因子。

对于根来说，它的 $G_{r}$ 个儿子虽然有 $(G_r)!$ 种排列方式，但是因为旋转以后相同算同一种，所以还需要除以 $G_r$，实际上也是 $(G_r - 1)!$ 种排列方式。

所以我们写出类似如下代码：

``` cpp
void dfs(int u, int fa) {
  ans *= frac[g[u].size() - 1];
  for(auto v : g[u]) {
    if(v != fa) {
      dfs(v, u);
    }
  }
}
```

发现这个题并不是要取模而是要分解因数。根据阶乘的定义很容易能想到一种简单且正确的实现方式。

``` cpp
#include <bits/stdc++.h>
#define int long long

using namespace std;

const int N = 100005;

vector<int> g[N];
int ans[N]; // ans[i] 表示 frac(i) 被乘入多少次

void dfs(int u, int fa) {
  ans[g[u].size() - 1]++;
  for(auto v : g[u]) {
    if(v != fa) {
      dfs(v, u);
    }
  }
}

signed main() {
  int n, m;
  cin >> n >> m;
  for(int i = 1; i < n + m; i++) {
    int u, v;
    cin >> u >> v;
    g[u].push_back(v);
    g[v].push_back(u);
  }
  dfs(n + m, n + m);
  for(int i = N; i; i--) {
    ans[i] += ans[i + 1];
  }
  for(int i = 2; i <= n + m; i++) {
    if(ans[i]) {
      cout << i << ' ' << ans[i] << '\n';
    }
  }
}
```

---

## 作者：aike_6yoshi9 (赞：0)

由于旋转后相等的算一种方案，所以我们可以把一个叶子节点固定住，比如说 $1$，这样的话就不需要考虑旋转了。  
然后考虑统计答案，我们假设一个节点 $u$ 有 $x$ 个儿子节点同时又是叶子节点的点，那么答案就为 $x$ 的阶乘，从假定的根节点开始算，直接统计就好了。  
代码就不放了，还不到 500B，自己写吧。

---

## 作者：ben090302 (赞：0)

考虑钦定某个所谓的叶子为根，反正就是边缘上的点为根，中间的点是晃荡的是不好计数的我们选择边缘作为开始。这样还可以避免旋转后相同的情况。

考虑 `dp`。

我们设 $u$ 子树内部的排列方式是 $f_u$，那么有 $f_u=cnt!\prod_{v\in son_u} f_v$。

其中 $cnt$ 代指儿子的数量，也就是各个儿子自己爱咋滴咋滴互不侵犯的计数，然后再考虑儿子之间交换顺序。稍微比划一下会发现这样没啥问题。

边界条件是叶子的答案是 $1$。

于是计数的问题解决了，接下来的问题是关于这个逆天答案输出方式。

我们观察一下这个答案，发现这个答案的 `dp` 完全是不必要的，把这个式子化简一下就是所有点的度数减一的阶乘的乘积。

然后这个输出就不那么困难的，原答案已经是一个阶乘之积的形式了，我们只需要统计每个数在阶乘里的出现次数就可以了。可以开一个桶加上差分统计桶上区间修改做到线性复杂度。

最后的最后还需要注意，题目虽然没写但是貌似认为方案数为 $1$ 的时候不需要输出，所以不要考虑阶乘里的 $1$。

```
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=2e5+5;
int n,m;
int d[N];
int ton[N];
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n+m;i++) d[i]=-1;
	for(int i=1;i<=n+m-1;i++){
		int u,v;
		cin>>u>>v;
		d[u]++,d[v]++;
	}
	for(int i=1;i<=n+m;i++){
		if(d[i]==1 or d[i]==0) continue;
		ton[2]++,ton[d[i]+1]--;
	}
	for(int i=2;i<=n+m;i++) ton[i]+=ton[i-1];
	for(int i=1;i<=n+m;i++){
		if(ton[i]>0) cout<<i<<" "<<ton[i]<<"\n";
	}
}
```

---


# 玛丽卡

## 题目描述

麦克找了个新女朋友，玛丽卡对他非常恼火并伺机报复。

因为她和他们不住在同一个城市，因此她开始准备她的长途旅行。

在这个国家中每两个城市之间最多只有一条路相通，并且我们知道从一个城市到另一个城市路上所需花费的时间。

麦克在车中无意中听到有一条路正在维修，并且那儿正堵车，但没听清楚到底是哪一条路。无论哪一条路正在维修，从玛丽卡所在的城市都能到达麦克所在的城市。

玛丽卡将只从不堵车的路上通过，并且她将按最短路线行车。麦克希望知道在最糟糕的情况下玛丽卡到达他所在的城市需要多长时间，这样他就能保证他的女朋友离开该城市足够远。

编写程序，帮助麦克找出玛丽卡按最短路线通过不堵车道路到达他所在城市所需的最长时间（用分钟表示）。


## 说明/提示

感谢 Imakf 提供的三组 hack 数据。

## 样例 #1

### 输入

```
5 7
1 2 8
1 4 10
2 3 9
2 4 10
2 5 1
3 4 7
3 5 10
```

### 输出

```
27```

# 题解

## 作者：wzporz (赞：56)

暂时运行效率rank1，大概是因为没有信仰，以为$O(n^3)$过不了1000，所以写了个$O(n^2 log_2n)$。



容易发现这题是一张稠密图，所以用$O(n^2)$的$dijkstra$即可，所谓的堆优化其实是劣化。关于SPFA，虽然这里没有死，但是已经死了。

是某道[题目](https://www.luogu.org/problemnew/show/P2685)的简化版：做法一样。

首先我们进行一次dijkstra，得到点1到点n的最短路径（如果有多条，随便找一条）。

显然，如果移除的不是这条路径上的边，贡献是不变的，现在考虑如果移除这条路径上的边。

那么对于另外的某一条路径，可以去update这条路径上的一些边

如果最短路径是A->B->...->C->D，存在一条路径A->B->E->C->D，那么在B->...->C这一段路径上的所有边如果去掉，还有那条路经，所以可以更新。

那么转化成一个简单的问题：区间取min，最后求所有值。

这个直接线段树区间取min（标记永久化），最后dfs一遍得到所有路径上删掉之后的max（还可以排序之后并查集维护）

注意这里的我们维护的对于1~n最短路径上的每条边，删掉它之后的1到n的最短距离。

来口胡一下证明，显然如果一条边跨越显然是对的，因为这条边一定可以正确地更新答案。

如果有超过一条边跨越，这条链与1到n最短路径的相连的点一定是直接走最短路径最优（不会劣），那么中间一定有一条边一定有路径1->这条路径->n，显然不重复。

```C++
#include<bits/stdc++.h>
using namespace std;
const int inf = 0x3f3f3f3f;
typedef long long ll;
#define gc getchar
#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)
#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)
#define rep(i,a,b) for(register int i=(a);i<int(b);++i)
inline ll read(){
    register ll x=0,f=1;register char c=gc();
    for(;!isdigit(c);c=gc())if(c=='-')f=-1;
    for(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);
    return x*f;
}
#define pc putchar
void write(ll x){if(x<0)x=-x,pc('-');if(x>=10)write(x/10);putchar(x%10+'0');}
void writeln(ll x){write(x);puts("");}
const int maxn = 1005;
bool vis[maxn];
int d1[maxn],dn[maxn],pre[maxn];
int n,m;
int a[maxn][maxn];
void dijkstra(int S,int dist[]){
    Rep(i,1,n) vis[i] = false;
    Rep(i,1,n) dist[i] = inf; 
    dist[S] = 0;pre[S]=0;
    Rep(i,1,n){
        int k = -1;
        Rep(j,1,n){
            if(vis[j]) continue;
            if(k == -1 || dist[k] > dist[j]) k = j;
        }
        vis[k] = true;
        Rep(j,1,n){
            if(vis[j]) continue;
            if(dist[j] > dist[k] + a[k][j]){
                dist[j] = dist[k] + a[k][j];
                pre[j] = k;
            }
        }
    }
}
vector<int> edge[maxn];
int fa[maxn];
int mx,pos[maxn];
inline int find(int x){return fa[x] == x ? x : fa[x] = find(fa[x]);}
#define lson (o<<1)
#define rson ((o<<1|1))
int tag[maxn<<2];
void modify(int o,int l,int r,int x,int y,int v){
    if(l==x&&r==y){tag[o] = min(tag[o],v);return ;}
    int mid = (l + r) >> 1;
    if(y<=mid) modify(lson,l,mid,x,y,v); else
    if(mid+1<=x)modify(rson,mid+1,r,x,y,v); else{
        modify(lson,l,mid,x,mid,v);
        modify(rson,mid+1,r,mid+1,y,v);
    }
}
void build(int o,int l,int r){
    tag[o]=inf;
    if(l==r)return;
    int mid = (l+r)>>1;
    build(lson,l,mid);build(rson,mid+1,r);
}
int query(int o,int l,int r,int x){
    if(l==r) return tag[o];
    int mid = (l+r)>>1;
    if(x<=mid) return min(query(lson,l,mid,x),tag[o]); else
               return min(query(rson,mid+1,r,x),tag[o]);
}
int main(){
    n = read(),m = read();
    Rep(i,1,n)Rep(j,1,n) a[i][j] = inf;
    Rep(i,1,m){
        int x = read(),y = read(),v = read();
        a[x][y] = a[y][x] = v;
    }
    dijkstra(n,dn);
    dijkstra(1,d1);
    Rep(i,1,n) fa[i] = pre[i];
    mx = 0;
    for(int i=n;i;i=pre[i]){
        pos[i] = ++mx;
        fa[i] = i;
        if(pre[i])
            a[i][pre[i]] = a[pre[i]][i] = inf;
    }
    build(1,1,n);
    Rep(i,1,n){
        Rep(j,1,n){
            if(i==j) continue;
            if(a[i][j] != inf){
                int w = min(dn[i] + d1[j] + a[i][j],dn[j]+d1[i]+a[i][j]);
                int x = pos[find(i)],y = pos[find(j)];
                if(x>y)swap(x,y);
                if(x==y) continue;
                modify(1,1,mx,x+1,y,w);
            }
        }
    }
    int ans = d1[n];
    Rep(i,2,n) ans = max(ans,query(1,1,mx,i));
    writeln(ans);
}

```

---

## 作者：huangzixi071018 (赞：25)

问题： 给出一张 $n$ 个点 $m$ 条边的带权的无向图。删除一条边，使得   $n$ 到 $1$ 的最短路的长度最大，输出这个最大长度。

很容易想到最短路，再把每条边删除一遍，找出最大长度，代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
    int u,w,id; 
};
vector<node>e[1005];
int n,m,d[1005],s=0;
void dijkstra(int x){
    priority_queue<pair<int,int>>q;
    d[n]=0;
    q.push(make_pair(0,n));
    while(!q.empty()){
        int k=q.top().second;
        q.pop();
        for (int i=0;i<e[k].size();i++){
            int v=e[k][i].u;
            if(e[k][i].id==x)continue;
            if(d[k]+e[k][i].w<d[v]){
                d[v]=d[k]+e[k][i].w;
                q.push(make_pair(-d[v],v));
            }
        }
    }
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=m;i++){
        int u,v,w;
        cin>>u>>v>>w;
        e[u].push_back({v,w,i});
        e[v].push_back({u,w,i});
    }
    for(int i=1;i<=m;i++){
        memset(d,0x3f,sizeof(d));
        dijkstra(i);
        s=max(s,d[1]);
    }
    cout<<s<<"\n";
    return 0;
}
```
这种写法只能拿 $80$ 分。

思路： 不算进最短路的边删掉也没有影响，于是我们可以只枚举算进最短路的边在算最短路时把转过来的边记录下来，再通过边推出另一个点和边，对边进行枚举即可。

代码:
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
    int u,w,id; 
}o[1000005];
vector<node>e[1005];
int n,m,d[1005],s=0,l[1005];
bool vis[1005],flag=1;
void dijkstra(int x){
    priority_queue<pair<int,int>>q;
    d[n]=0;
    q.push(make_pair(0,n));
    while(!q.empty()){
        int k=q.top().second;
        q.pop();
        if(vis[k])continue;
        vis[k]=1;
        for(int i=0;i<e[k].size();i++){
            int v=e[k][i].u;
            if(e[k][i].id==x)continue;
            if(d[k]+e[k][i].w<d[v]){
                d[v]=d[k]+e[k][i].w;
                if(flag){
                    l[v]=e[k][i].id;
                }
                q.push(make_pair(-d[v],v));
            }
        }
    }
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=m;i++){
        int u,v,w;
        cin>>u>>v>>w;
        e[u].push_back({v,w,i});
        e[v].push_back({u,w,i});
        o[i].u=u;
        o[i].w=v;
    }
    memset(d,0x3f,sizeof(d));
    memset(vis,0,sizeof(vis));
    dijkstra(0);
    flag=0;
    int b=1;
    while(l[b]!=0){
        memset(d,0x3f,sizeof(d));
        memset(vis,0,sizeof(vis));
        dijkstra(l[b]);
        s=max(s,d[1]);
        if(o[l[b]].u==b){
            b=o[l[b]].w;
        }else{
            b=o[l[b]].u;
        }
    }
    cout<<s<<"\n";
    return 0;
}
```



---

## 作者：囧仙 (赞：21)

## 题目大意

> 给定一张 $n$ 个点 $m$ 条边的带权无向图。现在需要删除一条边，使得 $1$ 到 $n$ 的最短路的长度最大，输出这个最大长度。  
> $1\le n\le 10^3;1\le m\le \frac{n(n-1)}{2}$。保证没有自环、重边。

## 题解

大多数错误的做法是枚举最短路上的边并删除，然后重新跑一遍最短路。如果用优先队列优化（劣化）的 $\text{Dijkstra}$，这么做的复杂度是 $\mathcal O(nm\log m)$；哪怕使用了朴素的 $\text{Dijkstra}$，复杂度也是 $\mathcal O(mn^2)$，无法通过在神 $\text{\color{red}\textcolor{black}Imakf}$ 添加的三个 $\text{Hack}$ 数据。

但可以发现，虽然我们不大能快速求出删除了一条边后的 $1$ 到 $n$ 的最短路，但是我们可以考虑，在强行让一条边被走，可以让哪些原先最短路上的边**不需要**被走。当我们删除了原先最短路上的某条边 $e$ 后，会产生一些替代路径，这么做本质上就是枚举了替代路径上面的边，求出删掉 $e$ 后会产生的最短路。替代路径的长度的最小值，就是删除 $e$ 对答案的贡献。

下文中，设 $\mathcal{E}$ 为原先的最短路。

可以证明，$\mathcal{E}$ 上原来必须要走，后来不需要被走的边必然是连续的一条路径。使用反证法。我们硬点了一条路径 $s\to t$。考虑 $\mathcal{E}$ 上路径 $a\to b\to c\to d$，其中 $a\to b,c\to d$ 这两段都是硬点前必须要走，硬点后不需要被走的路径（但是 $a,d$ 这两个点是一直要被经过的），而 $b\to c$ 则是一直要走的路径。如果 $a\to b$ 后来不需要走，那么必然存在一个走法绕过了 $a\to b$：从 $1$ 走到了 $s\to t$，再经过了一些边到了 $b$（必须会到达 $b$，不然无法保证 $b\to c$ 是必须走的边；同时在 $b$ 之前必然会经过 $s\to t$，否则就与 $a\to b$ 原来必须要走的假设矛盾了）；同理，存在走法从 $c$ 走到 $s\to t$ 再到终点 $n$。那么可以发现，存在一种更短的方案不经过 $b\to c$，与假设矛盾。因此这些被搁置的最短路上的边必然是连续的路径。

下面考虑怎么求出这个连续段的开头和结尾。一种可行的方法是，分别以 $1$ 和 $n$ 作为起点跑单源最短路。对于每个点，分别求出在这两次单源最短路过程中，到达它所经过的最后一个原先在 $\mathcal{E}$ 上的点（不妨分别记为 $A_i,B_i$）。当我们枚举替代路径上的边 $u\to v$ 时，我们断言 $\mathcal{E}$ 上的 $A_u,B_v$ 中间的边是会被搁置的。为什么这样是正确的呢？首先，硬点后 $1\to A_u\to u\to v\to B_v\to n$ 肯定是现在的最短路。如果我们选择了一部分 $\mathcal{E}$ 上 $A_u,B_v$ 的路径，肯定是不优的。但可能有些不必要被走的边不在 $\mathcal{E}$ 上 $A_u,B_v$ 之间的边里。这样是不会影响到答案的正确性的：假设有一条不在其中的边 $e$ 成了漏网之鱼，那么肯定会有一条路径横跨 $e$ 的两侧；后来我们肯定会枚举到这条路径上的边，然后重新把 $e$ 给标记了。

整理一下我们要做的事情：

- 求出从 $1$ 到 $n$ 的最短路 $\mathcal{E}$。  
- 分别求出 $1$ 和 $n$ 到达每个点的最短路上最后的 $\mathcal{E}$ 上的点的标号。  
- 枚举每条边并硬点它必然被选。求出新的最短路的长度，更新在最短路路径上 $A_u,B_v$ 两点间所有的边的权值。  
- 枚举最短路上的所有边，取所有权值的最大值。

关于第二步，考虑使用并查集。因为跑完单源最短路后本质上形成了一棵类似于树一样的东西，每个节点都有一个前驱节点。我们把 $\mathcal{E}$ 上的节点的前驱赋值为它本身，相当于把这个树形结构拆成了一堆树，每棵树的根节点都是 $\mathcal{E}$ 上的节点。使用路径压缩，可以快速求出一个节点所处子树的根节点是什么（也就是到达它的最短路上最后的 $\mathcal{E}$ 上的点的标号）。

关于第 $3,4$ 步，我们可以使用线段树维护。首先把整个最短路按照顺序映射成 $1,2,\cdots$ 那么最短路上的一条路径就转换为了一串连续的数字。我们要做的是区间赋值、单点查询历史最小值。考虑使用类似于标记永久化的方法：每个线段对应的节点存储一个 $\text{tag}$，当进行区间赋值时，若该线段被完全覆盖，则将 $\text{tag}$ 更新为权值和 $\text{tag}$ 值的最小值；若没完全覆盖，则递归操作。当我们查询时，统计查询的路径上所有节点的 $\text{tag}$ 的**最小值**。容易证明这种做法的正确性。

虽然证明内容写起来蛮多的，也不大容易理解，但是代码还算好写……总复杂度 $\mathcal O(n^2\log n)$，可以通过 $\text{\color{red}\textcolor{black}Imakf}$ 的三个 $\text{Hack}$ 数据和原来的数据。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int INF =1e9;
const int MAXN=1e3+3;
namespace Seg{
    const int SIZ=MAXN*4; int T[SIZ];
    #define lc(t) (t<<1)
    #define rc(t) (t<<1|1)
    void bld(int t,int a,int b){
        T[t]=INF; if(a==b) return; int c=a+b>>1;
        bld(lc(t),a,c),bld(rc(t),c+1,b);
    }
    void sst(int t,int a,int b,int l,int r,int w){
        if(l<=a&&b<=r) T[t]=min(T[t],w); else {
            int c=a+b>>1;
            if(l<=c) sst(lc(t),a,c  ,l,r,w);
            if(r> c) sst(rc(t),c+1,b,l,r,w);
        }
    }
    int  qry(int t,int a,int b,int p){
        if(a==b) return T[t]; int c=a+b>>1;
        if(p<=c) return min(T[t],qry(lc(t),a,c  ,p));
        else     return min(T[t],qry(rc(t),c+1,b,p));
    }
}
namespace Slv{
    int n,m,o,ans; bool U[MAXN][MAXN];
    int A[MAXN],B[MAXN],W[MAXN][MAXN]; bool V[MAXN];
    int P[MAXN],Q[MAXN],I[MAXN];
    int qread(){
        int w=1,c,ret;
        while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
        while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
        return ret*w;
    }
    void dij(int s,int t,int *D,int *E){
        up(1,n,i) D[i]=INF,V[i]=false; D[s]=0; up(1,n,i){
            int f=0;
            up(1,n,j) if((!f||D[j]<D[f])&&!V[j]) f=j; V[f]=true;
            up(1,n,j) if(!V[j]&&D[f]+W[f][j]<D[j]) D[j]=D[f]+W[f][j],E[j]=f;
        }
        if(!o){
            for(int p=t;p;p=E[p]) I[p] =--o; o=-o;
            for(int p=t,q=t;p;q=p,p=E[p]) I[p]+=o+1,U[p][q]=true;
        }
        up(1,n,i) if(I[i]) E[i]=i;
    }
    int gtf(int x,int *F){return x==F[x]?x:F[x]=gtf(F[x],F);}
    void slv(){
        n=qread(),m=qread();
        up(1,n,i) up(1,n,j) W[i][j]=INF;
        up(1,m,i){
            int u=qread(),v=qread(),w=qread();
            if(w<W[u][v])   W[u][v]=W[v][u]=w;
        }
        dij(1,n,A,P),dij(n,1,B,Q),Seg::bld(1,1,o);
        up(1,n,i) up(1,n,j) if(!U[i][j]&&!U[j][i]){
            int w=A[i]+W[i][j]+B[j],s=I[gtf(i,P)],t=I[gtf(j,Q)];
            if(s<t) Seg::sst(1,1,o,s,t-1,w);
        }
        up(1,o-1,i) ans=max(ans,Seg::qry(1,1,o,i));
        printf("%d\n",ans);
    }
}
int main(){
    Slv::slv(); return 0;
}
```

---

## 作者：I_am_Accepted (赞：9)

抢到了最优解。

前面的做法同 [@囧仙](https://www.luogu.com.cn/blog/over-knee-socks/solution-p1186)。

维护最短路上区间 check min 时采用 ST 表。最终查最大值前统一下放标记，这样做到了 $O(1)$ 打标记，空间 $O(n\log n)$（但是边数都 $O(n^2)$ 了所以这个不用管）。

复杂度降为 $O(n^2)$。

---

## 作者：锦依卫小生 (赞：8)

# 洛谷 P1186
## 题意分析
求出在删除任意一条边后从 $1$ 号结点到 $n$ 号结点的最短距离的最大值。
## 基本思想
不难分析出，要删除的边一定在在从 $1$ 号结点到 $n$ 号结点的最短路径上（否则最终结果仍然是删边前的最小值）。一种暴力的方法是先求出最短路，然后遍历一遍算出删除每一条边后的最短路径，取最大值——无法通过新增的 hack 数据。  
不妨转换思路，最终删边后的路径一定经过至少一条删边前最短路径之外的边，那么可以考虑经过一条确定边的最短路径。推理论证后得出，假设该边两边结点编号位 $u$、$v$,$d1$、$d2$ 数组分别表示到结点 $1$、$n$ 的最短路径长度，那么经过边 $u$、$v$ 的最短路 $d1(u)+d2(v)+l_{uv}$（$l$ 表示边长），那么删除被这条路径“架空”的原最短路上的边的新最短路就可能是该值。  
不难得出结论，从 $u$ 出发回到 $1$ 号结点的最短路径上最先到达的从 $1$ 到 $n$ 的最短路径上的结点（方便起见，我们称为父亲结点），与从 $v$ 出发回到 $n$ 号结点的最短路径上最先到达的从 $n$ 到 $1$ 的最短路径上的结点间的路径全部被架空。  
  
![](https://cdn.luogu.com.cn/upload/image_hosting/ngz83edb.png)  

本人采取边求最短路边求最先回到最短路径上的结点编号的方法（详见代码）。如此一来，题目就转化成了不断更新某一区间的路径被架空后的最小距离，最后查询每一条路径被架空后的最大值。很明显，可以使用线段树来实现。本篇题解采用标记下传。
## 具体做法与注意点
因为无法保证两边做 Dijkstra 求得的路径是一样的，本题解求最短路径只做一遍最短路，根据该条路径来确定关于 $1$ 和 $n$ 的父亲结点。
同时，也无法保证确定的父亲结点唯一，我们给最短路上的结点按照从 $1$ 走到  $n$ 标号，记为 $rk$。显然，为了结果最优，我们希望被架空的路径越多越好，那么求相对于 $1$ 号结点的父亲结点时我们要做到等距离下 $rk$ 越小越好，先对于 $n$ 则反之。  

![](https://cdn.luogu.com.cn/upload/image_hosting/3b0e6rvo.png)

如图，红色方案要优于蓝色方案  
最后，关于线段树，要注意我们始终要维护 **最小值**，最后在枚举所有非最短路上的边后再遍历每一个元素求最大值。  
总结起来，步骤如下：  
- 求最短路大小与各个结点前驱。
- 根据前驱求出最短路径，并求出 rk。
- 再分别对 $ 1 $ 、$ n $ 号结点求最短路，求出父亲结点。
- 枚举每一条非最短路径上的边，用线段树更新被其架空的路径段的最小值。
- 枚举每一条最短路径上的边，求出架空它们中的一个的最大值。  

一些注意点和解释在注释中标明。时间复杂度 $O(n^{2}\log{n})$。  
## 代码

```c
#include<bits/stdc++.h>
using namespace std;
const int MAX=1e3+5;
struct edge{
	int to,nxt,l;
};
edge e[MAX*MAX*2];
set<int> s;
int n,m,cnt=-1,head[MAX],d1[MAX],ans=0,d2[MAX],pre2[MAX][2],num;
int fa1[MAX],fa2[MAX],rk[MAX];
bool vis1[MAX],vis2[MAX],key[MAX];
int mins[MAX*4],swh[MAX*4];//swh 为 tag。
int read(){
	int x = 0, f = 1;
	char c = getchar();
	while(c < '0' || c > '9'){
		if(c == '-'){
			f = -1;
		}
		c = getchar();
	}
	while(c >= '0' && c <= '9'){
		x = x*10+c-'0';
		c = getchar();
	}
	return x*f;
}
void addedge(int u,int v,int x){
	cnt++;
	e[cnt].to=v;
	e[cnt].nxt=head[u];
	e[cnt].l=x;
	head[u]=cnt;	
}
void change(int k,int l,int r,int v){
	swh[k]=min(swh[k],v);
	mins[k]=min(mins[k],v);
}
void pushdown(int k,int l,int r){
	if(swh[k]>=1e9)
		return;
	int mid=l+r>>1;
	change(k<<1,l,mid,swh[k]);
	change(k<<1|1,mid+1,r,swh[k]);
	swh[k]=1e9;
}
int querry(int k,int l,int r,int x,int y){
	if(l>=x&&r<=y)
		return mins[k];
	int mid=l+r>>1;
	pushdown(k,l,r);
	int res=2e9;
	if(x<=mid)
		res=min(res,querry(k<<1,l,mid,x,y));
	if(mid<y)
		res=min(res,querry(k<<1|1,mid+1,r,x,y));
	return res; 
}
void modify(int k,int l,int r,int x,int y,int v){
	if(l>=x&&r<=y)
		return change(k,l,r,v); 
	int mid=l+r>>1;
	pushdown(k,l,r);
	if(x<=mid)
		modify(k<<1,l,mid,x,y,v);
	if(mid<y)
		modify(k<<1|1,mid+1,r,x,y,v);
	mins[k]=min(mins[k<<1],mins[k<<1|1]);
}
int main(){
    cin>>n>>m;
	for(int i=1;i<=n;++i)
		head[i]=-1;
	for(int i=1;i<=m;++i){
		int u,v,x;
		u=read();
		v=read();
		x=read();
		addedge(u,v,x);
		addedge(v,u,x);
	}
	 
	memset(d1,0x3f,sizeof(d1));
	memset(d2,0x3f,sizeof(d2));
	
	d2[n]=0;
	for(int i=1;i<=n;++i){
		int t1=2e9,t2=0;
		for(int j=1;j<=n;++j){
			if(!vis2[j]&&d2[j]<t1){
				t1=d2[j];
				t2=j;
			}
		}
		vis2[t2]=1;
		if(t2==0)
			continue; 
		for(int j=head[t2];j!=-1;j=e[j].nxt){
			int v=e[j].to;
			if(!vis2[v]&&d2[v]>d2[t2]+e[j].l){
				d2[v]=d2[t2]+e[j].l;
				pre2[v][0]=t2;
				pre2[v][1]=j; 
			}
		}
	} //求出各个点到 n 的最短路径与它们的前驱。 
	
	int now=1;
	fa1[1]=1;
	fa2[1]=1;
	rk[1]=1;
	key[1]=1;
	while(now!=n){
		s.insert(pre2[now][1]);
		s.insert(pre2[now][1]^1);
		num++;
		now=pre2[now][0];
		rk[now]=num+1;
		key[now]=1;
		fa1[now]=now;
		fa2[now]=now;
	}//从 1 开始倒退求出最短路径，路径上结点的父亲等于他们自身。
	 //同时求出 rk 即结点在路径中的顺序，同时把该边放入最短路集合，结点 key 赋值为 1。 
	
	d1[1]=0;//利用求最短路的过程求出父亲结点。
	for(int i=1;i<=n;++i){
		int t1=2e9,t2=0;
		for(int j=1;j<=n;++j){
			if(!vis1[j]&&d1[j]<t1){
				t1=d1[j];
				t2=j;
			}
		}
		if(t2==0)
			continue;
		vis1[t2]=1;
		for(int j=head[t2];j!=-1;j=e[j].nxt){
			int v=e[j].to;
			if(!vis1[v]&&d1[v]>d1[t2]+e[j].l){//如果 v 是通过 t2 更新的，那么 t2 是 v 的前驱，t2 的 v 的父亲。 
				d1[v]=d1[t2]+e[j].l;
				if(!key[v]){//最短路上的父亲不用更新。 
					fa1[v]=fa1[t2];//类似并查集的操作，始终保证指向的是根结点，即最短路上的结点。 
				}
			}
			else
				if(d1[v]==d1[t2]+e[j].l&&!key[v]&&rk[fa1[t2]]<rk[fa1[v]]){//如果等距，则比较它们父亲的 rk。
					fa1[v]=fa1[t2]; 
				} 
		}
	} 
	
	memset(d2,0x3f,sizeof(d2));//同样操作对 n 做一遍。
	memset(vis2,0,sizeof(vis2));
	d2[n]=0;
	for(int i=1;i<=n;++i){
		int t1=2e9,t2=0;
		for(int j=1;j<=n;++j){
			if(!vis2[j]&&d2[j]<t1){
				t1=d2[j];
				t2=j;
			}
		}
		vis2[t2]=1;
		if(t2==0)
			continue;
		for(int j=head[t2];j!=-1;j=e[j].nxt){
			int v=e[j].to;
			if(!vis2[v]&&d2[v]>d2[t2]+e[j].l){
				d2[v]=d2[t2]+e[j].l;
				if(!key[v]){
					fa2[v]=fa2[t2];
				}
			}
			else
				if(d2[v]==d2[t2]+e[j].l&&!key[v]&&rk[fa2[t2]]>rk[fa2[v]]){
					fa2[v]=fa2[t2];
				} 
		}
	} 

	memset(mins,0x3f,sizeof(mins));
	memset(swh,0x3f,sizeof(swh));
	for(int i=0;i<=cnt;++i){
		int u=e[i].to;
		int v=e[i^1].to;
		if(s.find(i)!=s.end())
			continue;//不能是最短路上的边。 
		int a=fa1[u];
		int b=fa2[v];
		if(rk[a]>=rk[b])
			continue; 
		int t=d1[u]+d2[v]+e[i].l;
		int l=rk[a];
		int r=rk[b]-1;
		if(l==0||r==0||l>r)
			continue;
		
		modify(1,1,num,l,r,t);
	}

	for(int i=1;i<=num;++i){
		int t=querry(1,1,num,i,i);
		ans=max(ans,t);	//架空每一条路中的最大值。
	}
		
	cout<<ans;
} 
```


---

## 作者：OldDriverTree (赞：7)

# Solution

这里讲一个乱搞的做法。

首先可以发现割掉的一定是最短路上的一条边，否则答案一定不会变。

考虑 dijkstra 找出最短路后，枚举最短路上的边，割掉后暴力跑 $O(n^2)$ 的 dijkstra，输出最短路最长的那一个，时间复杂度为 $O(n^3)$。

但是这样写会 TLE $97\texttt{pts}$，考虑随机化 + 卡时乱搞。

dijkstra 找出最短路后，把最短路上的边打乱，再枚举割的边，如果当前跑完 dijkstra 后时间大于 $0.97s$，就直接 break 输出答案，就 AC 了。

这就是随机化算法带给我的自信！

# Code
```c++
#include<bits/stdc++.h>
#define v to[e]
#define w val[e]
using namespace std;
const int N=1001,M=1e6;
int n,m,tot,ans,dis[N];
int head[N],nxt[M],to[M],val[M];
int pre[N]; bool st[N];
vector<int> path;

int read() {
	int x=0; char ch=0; while (!isdigit(ch) ) ch=getchar();
	while (isdigit(ch) ) x=(x<<3)+(x<<1)+(ch&15),ch=getchar();
	return x;
}
void add(int x,int y,int z) {
	to[tot]=y,val[tot]=z,nxt[tot]=head[x],head[x]=tot++;
}
int dijkstra()
{
	memset(dis,0x3f,sizeof dis);
	memset(st,0,sizeof st),dis[1]=0;
	for (int i=1;i<=n;i++) {
		int u=0; for (int j=1;j<=n;j++)
		if (!st[j]&&dis[j]<dis[u]) u=j;
		st[u]=true; for (int e=head[u];~e;e=nxt[e])
		if (dis[u]+w<dis[v]) dis[v]=dis[u]+w,pre[v]=e;
	}
	return dis[n];
}
int main()
{
	memset(head,-1,sizeof head);
	scanf("%d%d",&n,&m);
	while (m--) {
		int x=read(),y=read(),z=read();
		add(x,y,z),add(y,x,z);
	}
	dijkstra();
	for (int o=n;o^1;o=to[pre[o]^1]) path.push_back(pre[o]);
	random_shuffle(path.begin(),path.end() );
	for (int e:path) {
		int t=val[e]; val[e]=val[e^1]=1e9;
		ans=max(ans,dijkstra() ),val[e]=val[e^1]=t;
		if (1.0*clock()/CLOCKS_PER_SEC>0.97) break;
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：rq_kyz (赞：5)

# 【题解】 P1186 玛丽卡

### 传送门

[P1186 玛丽卡](https://www.luogu.com.cn/problem/P1186)

---

### 题意

给定一张 $n$ 个点、$m$ 条边的无向图，问哪一条边不能走，才会使 $1$ 到 $n$ 的最短路径最长。输出这个最大值。

---

### 分析

如果不可通行的边不在原本 $1$ 到 $n$ 的最短路径上，则对答案没有影响，所以我们只需要考虑 $1$ 到 $n$ 的最短路径上的边不可通行时的情况。

为了方便，我们把不经过一条边的 $1-n$ 的最短路长度叫做它的不经过长度。直接循环最短路上的边不方便维护，所以我们可以反其道而行，枚举每条边，然后更新最短路上的边的不经过长度。

如下图所示：

![](https://s11.ax1x.com/2024/01/13/pFPkv0P.png)

我们需要一个引理：如图所示，$1-n$ 的最短路与 $1-u$ 的最短路的前缀会重合一部分，可以没有，但一定不会重合与不重合两种状态来回跳。$n-v$ 的最短路同理。

设 $1-n$ 的原最短路为图中加粗点连成的路径，当前枚举到边 $u-v$。假设我们已经知道 $L$ 和 $R$ 的位置，那么这条从 $1$ 开始、经过 $u-v$、最后到达 $n$ 的路径长度就可以更新 $L$ 到 $R$ 之间所有边的不经过长度。

但还有两个问题：一是如何找到 $L$ 和 $R$，二是如何更新才不会 TLE。因为我们记录哪些边在 $1-n$ 的最短路上时已经跑过一遍 Dijkstra，所以找 $L$ 和 $R$ 的过程可以从 $1$ 和 $n$ 开始再跑两遍 Dijkstra，跑的过程中通过第一遍记录的可以一次性将 $1$ 和 $n$ 到所有点的 $L$ 和 $R$ 全部计算出来。

强行更新会 TLE，因为最坏情况时间复杂度为 $O(nm)$。这里注意到 $1-n$ 的最短路可以看为一条链或一个数组，所以我们可以使用线段树进行优化，线段树记录的数组的每个节点为 $1-n$ 的最短路上的边的不经过长度。

---

### 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll t[500001];
ll LR[2][1001];
struct s1{
	ll x,y,l;
}a[500001];
ll last[1001];
struct s2{
	ll t,to,l,i;
}nxet[1000001];
ll cd=0;
void lj(ll x,ll y,ll l,ll i){
	nxet[++cd].t=last[x];
	nxet[cd].to=y;
	nxet[cd].l=l;
	nxet[cd].i=i;
	last[x]=cd;
}
ll dis[2][1001];
bool vis[2][1001];
ll fa[1001];
struct s3{
	ll x,l;
}h[1000001];
ll len;
bool f(s3 num1,s3 num2){
	return num1.l>num2.l;
}
void dijkstra1(ll s){
	memset(dis[1],0x3f,sizeof(dis[1]));
	dis[1][s]=0;
	h[0]={s,0};
	len=1;
	while(len){
		ll x=h[0].x;
		pop_heap(h,h+len,f);
		len--;
		if(vis[1][x])
			continue;
		vis[1][x]=1;
		for(ll j=last[x];j;j=nxet[j].t){
			ll y=nxet[j].to;
			if(dis[1][y]>dis[1][x]+nxet[j].l){
				dis[1][y]=dis[1][x]+nxet[j].l;
				fa[y]=nxet[j].i;
				if(a[nxet[j].i].y==y)
					a[nxet[j].i].x^=a[nxet[j].i].y^=a[nxet[j].i].x^=a[nxet[j].i].y;
				h[len].x=y;
				h[len++].l=dis[1][y];
				push_heap(h,h+len,f);
			}
		}
	}
}
void dijkstra2(ll s,ll lr){
	memset(dis[lr],0x3f,sizeof(dis[lr]));
	memset(vis[lr],0,sizeof(vis[lr]));
	dis[lr][s]=0;
	LR[lr][s]=s;
	h[0]={s,0};
	len=1;
	while(len){
		ll x=h[0].x;
		pop_heap(h,h+len,f);
		len--;
		if(vis[lr][x])
			continue;
		vis[lr][x]=1;
		for(ll j=last[x];j;j=nxet[j].t){
			ll y=nxet[j].to;
			if(dis[lr][y]>dis[lr][x]+nxet[j].l){
				dis[lr][y]=dis[lr][x]+nxet[j].l;
				LR[lr][y]=(t[nxet[j].i]?y:LR[lr][x]);
				h[len].x=y;
				h[len++].l=dis[lr][y];
				push_heap(h,h+len,f);
			}
		}
	}
}
struct s4{
	ll l,r,pre,add;
}tree[4001];
void make_tree(ll p,ll l,ll r){
	tree[p].l=l;
	tree[p].r=r;
	tree[p].pre=tree[p].add=1e18;
	if(l<r){
		ll mid=(l+r)>>1;
		make_tree(2*p,l,mid);
		make_tree(2*p+1,mid+1,r);
	}
}
void push_down(ll p){
	if(tree[p].l<tree[p].r && tree[p].add){
		ll mid=(tree[p].l+tree[p].r)>>1;
		tree[2*p].pre=min(tree[2*p].pre,tree[p].add);
		tree[2*p].add=min(tree[2*p].add,tree[p].add);
		tree[2*p+1].pre=min(tree[2*p+1].pre,tree[p].add);
		tree[2*p+1].add=min(tree[2*p+1].add,tree[p].add);
		tree[p].add=1e18;
	}
}
void add(ll p,ll l,ll r,ll k){
	if(l<=tree[p].l && tree[p].r<=r){
		tree[p].pre=min(tree[p].pre,k);
		tree[p].add=min(tree[p].add,k);
		return;
	}
	push_down(p);
	ll mid=(tree[p].l+tree[p].r)>>1;
	if(l<=mid)
		add(2*p,l,r,k);
	if(r>mid)
		add(2*p+1,l,r,k);
}
ll ask(ll p,ll x){
	if(tree[p].l==tree[p].r)
		return tree[p].pre;
	push_down(p);
	ll mid=(tree[p].l+tree[p].r)>>1;
	return x<=mid?ask(2*p,x):ask(2*p+1,x);
}
int main(){
	ll n,m;
	scanf("%lld%lld",&n,&m);
	for(ll i=1;i<=m;i++){
		scanf("%lld%lld%lld",&a[i].x,&a[i].y,&a[i].l);
		lj(a[i].x,a[i].y,a[i].l,i);
		lj(a[i].y,a[i].x,a[i].l,i);
	}
	dijkstra1(n);
	ll cnt=1;
	for(ll x=fa[1];x;cnt++,x=fa[a[x].y])
		t[x]=cnt;
	t[0]=cnt--;
	dijkstra2(1,0);
	dijkstra2(n,1);
	make_tree(1,1,cnt);
	for(ll i=1;i<=m;i++){
		if(t[i])
			continue;
		else{
			if(t[fa[LR[0][a[i].x]]]<t[fa[LR[1][a[i].y]]])
				add(1,t[fa[LR[0][a[i].x]]],t[fa[LR[1][a[i].y]]]-1,dis[0][a[i].x]+a[i].l+dis[1][a[i].y]);
			if(t[fa[LR[0][a[i].y]]]<t[fa[LR[1][a[i].x]]])
				add(1,t[fa[LR[0][a[i].y]]],t[fa[LR[1][a[i].x]]]-1,dis[0][a[i].y]+a[i].l+dis[1][a[i].x]);
		}
	}
	ll max_=dis[0][n];
	for(ll i=1;i<=m;i++)
		if(t[i])
			max_=max(max_,ask(1,t[i]));
	printf("%lld",max_);
	return 0;
}
```

---

### 其他

[双倍经验](https://www.luogu.com.cn/problem/CF1163F)

---

## 作者：_VirtualPoint_ (赞：4)

# 题目大意

给出一个无向有权双连通图，求去除图中其中一条边之后从节点 $1$ 到节点 $n$ 的最大可能权值总和。

# 题目分析

我们很容易想到此题可以暴力的枚举每一条边，每次枚举一条边之后我们去除这条边，随后从节点 $1$ 跑一遍单源最短路（这里我用了 `dijkstra`），最后取到节点 $n$ 最短路的最大值即可。

当然，如果逐条边枚举还是太慢了，所以我们可以先跑一遍单源最短路，并且记录下最短路，随后我们逐条枚举最短路上的边，这样便可略过很多拆了也没有影响的无用边。

# 着手实现
声明：如下出现的所有代码请有需要的同学谨慎使用，切勿抄题解。这是非常不道德的行为。

- 如何去除边？

考虑卡最短路的“Bug”。我们可以把边权临时设置为一个极大值，之后我们跑最短路的时候自然就不会走这一条路。当然我们需要确保极大值要大于所有可能的边权。

可能产生不理解的地方都做了简单的注释，下面是根据如上基本思路写出的代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

long long n, m;
long long u, v, w;

bool flag;

long long vis[1005];
long long pth[1005];
long long pre[1005];

long long g[1005][1005];

inline void dijkstra() {
	memset(pth, 0x3f, sizeof(pth));
	memset(vis, 0, sizeof(vis));
	
	pth[1] = 0;
	
	for (long long i = 1; i <= n; ++i) {
		long long t = -1;
		
		for (long long j = 1; j <= n; ++j) {
			if (!vis[j] && (t == -1 || pth[t] > pth[j])) {
				t = j;
			}
		}
		
		vis[t] = 1;
		
		for (long long j = 1; j <= n; ++j) {
			if (pth[t] + g[t][j] < pth[j]) {
				pth[j] = pth[t] + g[t][j];
				
				if (flag) {//如果 flag 是 true 则记录最短路径
					pre[j] = t;
				}
			}
		}
	}
}

int main() {
    
	cin >> n >> m;
	
	memset(g, 0x3f, sizeof(g));//求最短路，设为极大值
	
	for (long long i = 1; i <= m; ++i) {
		cin >> u >> v >> w;
		
		g[u][v] = min(g[u][v], w);//防止重边
		g[v][u] = min(g[v][u], w);//防止重边
	}
	
	flag = true;//需要记录路径，因此设为 true
	
	dijkstra();
	
	flag = false;//剩下都不需要记录了
	
	long long u=n;
	long long ans=0;

  //此处u和v分别代表最短路上某条边的两个端点。
	
	while (pre[u]) {//枚举路径上的每一条边
		long long v = pre[u];
		long long tmp = g[u][v];//事先存好值
		
		g[u][v] = g[v][u] = pth[1004];//pth[1004] 是极大值，可以满足删边的需求
		
		dijkstra();
		
		ans = max(ans, pth[n]);//更新最大值
		
		g[u][v] = g[v][u] = tmp;//还原
		
		u = pre[u];
	}
	
	cout << ans << endl;
	return 0;
}
```

可是我们交上代码发现只有 99pts，时间不够优，考虑优化。

因为之前的题解已经将各种优秀的优化方式写的足够好了，这里提供一种投机取巧的卡常方式。

- 优化输入，在 `main` 函数开头加上如下代码禁用缓冲区：
```cpp
ios::sync_with_stdio(0);
cin.tie(0);
cout.tie(0);
```

- `for` 循环中所有的变量 `i` 加上前缀 `register`。

- 开启 `O2` 优化。

- 最后，为了防止超时，提供极限卡常方式。如下的代码检测到程序运行 `990ms` 后强制退出循环。
```cpp
if (1.*clock()/CLOCKS_PER_SEC>=0.99)
		  break;
```

因为在前 `990ms` 取到正解的可能性已经很大，所以加上这行代码防止超时，也可以有比较大的可能拿到正确答案。

经过以上卡常操作的代码可以成功通过评测。


```cpp
#include <bits/stdc++.h>
using namespace std;

long long n, m;
long long u, v, w;

bool flag;

long long vis[1005];
long long pth[1005];
long long pre[1005];

long long g[1005][1005];

inline void dijkstra() {
	memset(pth, 0x3f, sizeof(pth));
	memset(vis, 0, sizeof(vis));
	
	pth[1] = 0;
	
	for (register long long i = 1; i <= n; ++i) {
		long long t = -1;
		
		for (register long long j = 1; j <= n; ++j) {
			if (!vis[j] && (t == -1 || pth[t] > pth[j])) {
				t = j;
			}
		}
		
		vis[t] = 1;
		
		for (register long long j = 1; j <= n; ++j) {
			if (pth[t] + g[t][j] < pth[j]) {
				pth[j] = pth[t] + g[t][j];
				
				if (flag) {
					pre[j] = t;
				}
			}
		}
	}
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    
	cin >> n >> m;
	
	memset(g, 0x3f, sizeof(g));
	
	for (register long long i = 1; i <= m; ++i) {
		cin >> u >> v >> w;
		
		g[u][v] = min(g[u][v], w);
		g[v][u] = min(g[v][u], w);
	}
	
	flag = true;
	
	dijkstra();
	
	flag = false;
	
	long long u=n;
	long long ans=0;
	
	while (pre[u]) {
		long long v = pre[u];
		long long tmp = g[u][v];
		
		g[u][v] = g[v][u] = pth[1004];
		
		dijkstra();
		
		ans = max(ans, pth[n]);
		
		g[u][v] = g[v][u] = tmp;
		
		u = pre[u];
		
		if(1.*clock()/CLOCKS_PER_SEC>=0.99)
		  break;
	}
	
	cout << ans << endl;
	return 0;
}
```

---

## 作者：Nazq (赞：4)

## 前言

在加 hack 数据之前，AC 只需要模拟删边，暴力跑最短路即可。
现在，难度加大，综合性变强。
参考：[文章1](https://www.luogu.com/article/1y8x6vt4)，[文章2](https://www.luogu.com.cn/article/00vdrtpk)。

## 分析

题目意思明确，就是枚举删边，维护删边后最短路的最大值。

### 最短路

题目保证了只有正权边，所以无疑用 Dijkstra。但先别用堆优化~~虽然很好写~~。
由于 $1 \le M \le N \times (N-1) \div 2$，明显，测试点中会有稠密图的情况来卡你。堆优化 $\mathcal{O}(m\log{m})$，朴素 $\mathcal{O}(n^2)$。
此时，朴素 Dijkstra 时间复杂度更优。

### 找路径

这里有个小优化：当删的边不在原最短路径上，那么最短路不变，浪费时间。只需枚举删原最短路径上的边，其贡献才会改变。所以我们要找最短路径。
我们令 $now$ 的子节点为 $v$，边权为 $w$；令 $dis(i)$ 为起点到 $i$ 的最短路径。
如果 $dis(v) \gt dis(now) + w$ 成立，那么 $v$ 的最短路要通过 $now$。
我们记录前驱 $pre(v)$，即 $v$ 的最短路的上一个点。
由此，可以一步步找到起点，路径也就找到了。
记录前驱：
```cpp
pre[v] = now;
```
寻找路径：
```cpp
for (int i = n; i; i = pre[i])
```

### 找替代路径

即使减少的枚举的边数，但仍然会 TLE。
我第一次想的是：删掉最短路径上的任意一条边，那么肯定有另外一条路径连接这条边的两个端点，算出这条替代路径的权值，加上两端点分别到起点和终点的距离，维护最大值即可。结果就是被 hack 了。如下图。![img](https://cdn.luogu.com.cn/upload/image_hosting/bav7w8nc.png)

从 $1$ 到 $6$ 的最短路是：$1\to 2\to 4\to 6$。所以如果单纯枚举 $(1,2)$，$(2,4)$，$(4,6)$，并找其替代路径的话，结果显然错了。
我们换个思路，枚举不在最短路径上的边，钦定其是删掉最短路径的某一段后必定会被走的。如何找到该边替换的是原最短路径上的哪一段呢？
我们利用上面找到每个点的前驱，建立一个并查集，把每个点的父亲定为其前驱。那么通过找祖先一定可以找到起点。我们想让其在最短路径上就停止溯源，就把最短路径上的点的父亲定为自己即可。

#### 疑点

在做并查集时，为什么只用做到起点的并查集，而不做到终点的。这样不会使边的两个端点都找到原最短路径上同一个点吗？
当然，做两个分别到起点和终点的并查集是最好理解的，但是只做一个也不错。如下图。![img](https://cdn.luogu.com.cn/upload/image_hosting/uxal9q95.png)

当枚举 $(3,4)$ 时，这两个点确实都会找 $2$，但是枚举 $(4,5)$ 会找到 $2$，$5$ 两个点。
所以如果通过某一条两个端点都不在原最短路径上的边，那么通过其新最短路径与原最短路径一定有“分支边”。像这种路径只需枚举“分支边”即可找到。

### 维护区间最大值

我们找到了每条边删掉后的替代路径，那么维护最大值就是答案。
我们把原最短路径抽象成一个区间，区间上的点对应原最短路径上的一条边。但是边不好确定，我们就用边的左端点或右端点来代替，所以用到的只有最短路径上的点数减 $1$。枚举后，把删掉该边后的最短路径记录在该边上，用线段树维护区间最大值即可。

### Code

```cpp
#include <cstdio>
#include <algorithm>
using std::fill;
using std::swap;
using std::min;
using std::max;
inline void read(int& x){
    bool f = 1;x = 0;char ch = getchar();
    while(ch < '0' || ch > '9'){if(ch == '-') f = !f;ch = getchar();}
    while(ch >= '0' && ch <= '9'){x=(x << 1)+(x << 3)+(ch ^ 48);ch = getchar();}
    x=(f ? x : -x);
}
inline void write(int x) {
	if (x < 0)putchar('-'), x = -x;
	if (x > 9)write(x / 10);
	putchar(x % 10 | 48);
}
const int N = 1005, Inf = 0x3f3f3f3f;
int n, m, e[N][N], dis_s[N], dis_t[N], f[N], pre[N], pos[N], cnt, tag[N << 2], ans;
bool vis[N];
inline int lson(const int& p) {
	return p << 1;
}
inline int rson(const int& p) {
	return p << 1 | 1;
}
int find_set(int v) {
	if (v != f[v])
		f[v] = find_set(f[v]);
	return f[v];
}
void Read() {
	read(n);read(m);
	for (int i = 1; i <= n; ++i)
		fill(e[i] + 1, e[i] + n + 1, Inf);
	for (int i = 1, u, v, w; i <= m; ++i) {
		read(u);read(v);read(w);
		e[u][v] = w;e[v][u] = w;
	}
}
void Dijsktra(const int& s, int dis[]) {
	fill(dis + 1, dis + n + 1, Inf);
	fill(vis + 1, vis + n + 1, false);
	dis[s] = 0;
	for (int k = 1; k <= n; ++k) {
		int Min = Inf, now;
		for (int i = 1; i <= n; ++i)
			if (!vis[i] && dis[i] < Min)
				Min = dis[i], now = i;
		vis[now] = true;
		for (int v = 1, w; v <= n; ++v) {
			if (v == now)continue;
			w = e[now][v];
			if (dis[v] > dis[now] + w) {
				dis[v] = dis[now] + w;
				if (s == 1)pre[v] = now;
			}
		}
	}
}
void add_tag(int p, int val) {
	tag[p] = min(tag[p], val);//最短路保留权值小的路径 
}
void push_up(int p) {
	tag[p] = max(tag[lson(p)], tag[rson(p)]);//合并记录区间最大值 
}
void push_down(int p) {
	if (tag[p] != Inf) {
		add_tag(lson(p), tag[p]);
		add_tag(rson(p), tag[p]);
		tag[p] = Inf;
	}
}
void Build(int p, int pl, int pr) {
	if (pl == pr) {
		tag[p] = Inf;//初始化为正无穷 
		return;
	}
	int mid = (pl + pr) >> 1;
	Build(lson(p), pl, mid);
	Build(rson(p), mid + 1, pr);
	push_up(p);
}
void update(int p, int pl, int pr, int L, int R, int val) {
	if (L <= pl && pr <= R) {
		add_tag(p, val);
		return;
	}
	push_down(p);
	int mid = (pl + pr) >> 1;
	if (L <= mid)update(lson(p), pl, mid, L, R, val);
	if (R > mid)update(rson(p), mid + 1, pr, L, R, val);
	push_up(p);
}
int query(int p, int pl, int pr, int L, int R) {
	if (L <= pl && pr <= R)return tag[p];
	push_down(p);
	int res = 0, mid = (pl + pr) >> 1;
	if (L <= mid)res = query(lson(p), pl, mid, L, R);
	if (R > mid)res = max(res, query(rson(p), mid + 1, pr, L, R));
	return res;
}
int main() {
	Read();
	Dijsktra(1, dis_s);
	Dijsktra(n, dis_t);
	for (int i = 1; i <= n; ++i)
		f[i] = pre[i];//记录前驱 
	for (int i = n; i; i = pre[i]) {
		pos[i] = ++cnt;//抽象路径为区间 
		f[i] = i;//使其知道在最短路径上对应的一段 
		if (pre[i])e[i][pre[i]] = e[pre[i]][i] = Inf;//相当于标记, 后面就不会枚举到最短路径上的边 
	}
	Build(1, 2, cnt);//这里以及后面的 2~cnt 是因为用点代表边 
	for (int i = 1, u, v, w; i <= n; ++i) {
		for (int j = i + 1; j <= n; ++j) {
			if (e[i][j] == Inf)continue;
			u = pos[find_set(i)];//找到在最短路径上的替代部分 
			v = pos[find_set(j)];
			if (u == v)continue;
			if (v < u)swap(u, v);//保证L<=R 
			w = min(dis_s[i] + e[i][j] + dis_t[j], dis_s[j] + e[i][j] + dis_t[i]);//算出经过该边的最短路 
			update(1, 2, cnt, u + 1, v, w);
		}
	}
	ans = query(1, 2, cnt, 2, cnt);//找出区间最大值
	write(ans);
	return 0;
}
```

---


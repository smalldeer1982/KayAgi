# [蓝桥杯 2024 国研究生组] 最短路

## 题目描述

给定一个包含 $n$ 个点的图 $G$，用邻接矩阵 $A_{i,j}$ 表示，其中 $A_{i,j} = 0$ 表示无边，$A_{i,j} > 0$ 表示有边，$A_{i,j}$ 的值为边权。

给定 $m$ 次询问，每次询问你需要找出从 $a_i$ 到 $b_i$ 恰好经过 $c_i$ 条边的边权和最小的路径。对于每次询问，你可以选择某一条边，将其中的一次经过的边权整除 $2$（如果多次经过一条边，只有一次整除 $2$，其它次按原边权计算）。

## 说明/提示

### 评测用例规模与约定

- 对于 $40\%$ 的评测用例，$m = 1$，$c_i \leq 50$；
- 另有 $10\%$ 的评测用例，$m \leq 100$，$c_i \leq 50$；
- 另有 $20\%$ 的评测用例，$m = 1$，$c_i < 2^{24}$；
- 对于所有评测用例，$1 \leq n \leq 50$，$1 \leq m \leq 1000$，$1 \leq a_i, b_i \leq n$，$1 \leq c_i \leq 10^9$，$0 \leq A_{i,j} \leq 10^9$。

## 样例 #1

### 输入

```
3
0 1 1
0 1 0
1 0 0
4
2 1 1
1 2 2
1 3 3
3 1 4```

### 输出

```
-1
1
2
-1```

# 题解

## 作者：R_8x (赞：4)

# P12319 [蓝桥杯 2024 国研究生组] 最短路 - 题解

前置知识：分层图最短路，矩阵加速。

在尝试此题前建议先完成 [P2886 [USACO07NOV] Cow Relays G](https://www.luogu.com.cn/problem/P2886)。

## 正文

首先，题中提到了一项机制：对于每次询问，可以把一条边的边权整除 $2$，但每次询问只有可以进行一次此操作（即使多次经过一条边也只生效一次），所以考虑**拆点**：每个点有两种状态：进行过整除操作和没进行过，对拆开的两个点分别连边。

假设题中从 $u$ 向 $v$ 连了一条有向边，边权为 $w$，则对于拆出的点 $u'$ 和点 $v'$，我们需要额外从 $u$ 向 $v'$ 连一条边权为 $\frac{w}{2}$ 的边，代表在此处进行整除操作，当然，也要从 $u'$ 向 $v'$ 连一条边权为 $w$ 的边，代表进行过整除操作操作的情况。

由于题中的 $c_i \le 10^9$，所以使用矩阵乘法进行加速，其余部分就和 [P2886](https://www.luogu.com.cn/problem/P2886) 一样了……吗？

由于这道题需要进行 $m$ 次操作，而 $m \le 1000, n \le 50$，同时我们还进行了拆点，所以矩阵大小为 $100 \times 100$，则总的时间复杂度为 $O((2 \times n)^3 \times m\log{c_i})$，不能通过此题。

注意到，我们可以使用**倍增**进行预处理，处理出经过 $2^0$ 条边到 $2^{30}$ 条边的矩阵，然后对每次询问的 $c_i$ 进行拆位计算，减少矩阵乘法的次数。但这种优化实际上只减少了常数时间复杂度，并没有改变根本。然而，由于每次询问都给出了起点 $s$，我们可以把初始矩阵中的第 $s$ 行单独提取出来，然后再与倍增预处理出的矩阵进行矩阵乘法，这样单次计算的时间复杂度由 $O((2 \times n)^3)$ 变成了 $O((2 \times n)^2)$，同时保证了以 $s$ 为起点的值正确，此题解决。

时间复杂度：预处理部分为 $O(30 \times (2\times n)^3)$，查询部分为 $O(m \times (2 \times n)^2 \times \log{c_i})$。

以下为代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;//记得开 long long 
const ll inf=0x3f3f3f3f3f3f3f3f;
struct node
{
	int n,m;
	ll mp[105][105];
	node(){memset(mp,0x3f,sizeof(mp));}//在使用了 node(int x,int y) 这一构造函数后，直接开node数组无法通过编译，所以要加这一行 
	node(int x,int y){n=x,m=y,memset(mp,0x3f,sizeof(mp));}
	node operator * (node x)
	{
		int z=x.m;
		node res(n,z);
		for(int i=1;i<=n;i++)
			for(int j=1;j<=z;j++)
				for(int k=1;k<=m;k++)
					res.mp[i][j]=min(res.mp[i][j],mp[i][k]+x.mp[k][j]);//广义矩阵乘法 
		return res;
	}
};
node to[35];
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	int n,q;
	cin>>n;
	node a(n*2,n*2);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			int x;
			cin>>x;
			if(x!=0)
			{
				a.mp[i][j]=x;
				a.mp[i][j+n]=x/2;
				a.mp[i+n][j+n]=x;//拆点 
			}
		}
	}
	to[0]=a;
	for(int i=1;i<=30;i++)
		to[i]=to[i-1]*to[i-1];//倍增 
	cin>>q;
	while(q--)
	{
		int s,t,k;
		cin>>s>>t>>k;
		node st(1,n*2);
		for(int i=1;i<=n*2;i++)
			st.mp[1][i]=a.mp[s][i];
		k--;//k要减一，因为 k==1 为初始矩阵的情况，而进行一次乘法后为经过 2 条边的情况 
		for(int i=0;i<=30;i++)
			if(k&(1<<i))
				st=st*to[i];
		ll ans=min(st.mp[1][t],st.mp[1][t+n]);
		cout<<(ans==inf?-1:ans)<<"\n";
	}
	return 0;
}

```

---

## 作者：KobeBeanBryantCox (赞：1)

# P12319 [蓝桥杯 2024 国研究生组] 最短路 题解

[题目传送门](https://www.luogu.com.cn/problem/P12319)。

前置知识：分层图，[矩阵乘法求最短路](https://www.luogu.com.cn/problem/P2886)。

## 题意

给定有向图，给定很多询问，求 $a_i$ 到 $b_i$ 恰好经过 $c_i$ 条边的最短路。期间可以选择一条边将边权整除 $2$，多次经过这条边只算一次整除 $2$。

## 思路

如果没有整除 $2$ 操作，直接 $(\min,+)$ 矩阵快速幂就做完了。

现在加上整除 $2$ 操作，直接建分层图，从第一层转到第二层代表这一次要整除 $2$，然后在分层图上跑矩阵快速幂就做完了。

直接做时间复杂度过不去，考虑到给定了起点，我们只关心起点开始的路径，于是把矩阵中起点那一行取出来，变成向量乘矩阵。

然后还是过不去，为了规避掉矩阵快速幂中的矩阵乘矩阵，我们提前预处理经过 $2^i$ 条边时邻接矩阵，乘的时候类似倍增地乘即可，这样是向量乘矩阵的。

总时间复杂度 $O(n^3\log V+mn^2\log V)$，其中 $V$ 是 $c$ 的值域。

## AC 代码

几乎没有细节，只需要记得 $c$ 要先减 $1$ 就好了。

```cpp
#include<bits/stdc++.h>
#define Code using
#define by namespace
#define wjb std
Code by wjb;
#define int long long // 要开 long long！
int in()
{
	int k=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9')k=k*10+c-'0',c=getchar();
	return k*f;
}
void out(int x)
{
	if(x<0)putchar('-'),x=-x;
	if(x<10)putchar(x+'0');
	else out(x/10),putchar(x%10+'0');
}
const int N=110,inf=1e18;
struct Matrix
{
	int n,m,a[N][N];
	Matrix(int n_=0,int m_=0):n(n_),m(m_){for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)a[i][j]=inf;}
	int* operator[](int i){return a[i];}
	friend Matrix operator*(Matrix &a,Matrix &b)
	{
		int n=a.n,z=a.m,m=b.m;Matrix c(n,m);
		for(int k=1;k<=z;k++)for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)c[i][j]=min(c[i][j],a[i][k]+b[k][j]);
		return c;
	}
}e[31];
signed main()
{
	int n=in();
	for(int i=0;i<=30;i++)e[i]=Matrix(n<<1,n<<1);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
		{
			int v=in();
			if(v!=0)e[0][i][j]=e[0][i+n][j+n]=v,e[0][i][j+n]=v>>1;
		}
	for(int i=1;i<=30;i++)e[i]=e[i-1]*e[i-1];
	int m=in();
	while(m--)
	{
		int a=in(),b=in(),c=in()-1;
		Matrix res(1,n<<1);
		for(int i=1;i<=(n<<1);i++)res[1][i]=e[0][a][i];
		for(int i=0;i<=30;i++)if((c>>i)&1)res=res*e[i];
		out(res[1][b+n]==inf?-1:res[1][b+n]),putchar('\n');
	}
	return 0;
}
```

---

## 作者：A7F3jK9pR0xf_ (赞：0)

### [题目传送门](https://www.luogu.com.cn/problem/P12319)

~~两个矩阵甜菜 —— shx12 和 wxx 结合研究并通过。~~

### 算法 1

我们先考虑整除 $2$，可以建分层图，第 $1$ 张图由 $1\sim n$ 中的点构成，第 $2$ 张图由 $n+1\sim 2n$ 中的点构成，对于原图中的每条边 $(u,v,w)$，在分层图对应着 $(u,v,w)$、$(u+n,v+n,w)$ 和 $(u,v+n,\lfloor\frac{w}{2}\rfloor)$ 三条边。这样对于每次询问，我们跑 $c$ 次类似于 Floyd 的 DP 就可以了，时间复杂度是 $O(n^2mc)$，期望得分 50pts。

### 算法 2

如果我们把分层图的邻接矩阵列出的话，可以发现在以 $(\min,+)$ 半环的广义矩阵乘意义下邻接矩阵的 $c$ 次方就是对原图跑 $c$ 次 DP 的结果。由于 $(\min,+)$ 半环的矩阵乘具有结合律，我们可以用快速幂加速计算，这样时间复杂度降为 $O(8n^3m\log c)$，依然无法完全通过。

### 算法 3

我们想要尽可能的降低常数，可以用倍增预处理，令 $f_i$ 表示邻接矩阵 $A$ 的 $2^i$ 次方，这样有转移式 $f_i=f_{i-1}^2$，这一步复杂度为 $O(8n^3\log V)$，其中 $V$ 是 $c$ 的值域。幸运的话兴许能过掉一些点。

### 算法 4

由于我们计算的是 $a\to b$ 的最短路，实际上我们只需要得知邻接矩阵中有关 $x$ 的那一行就行。那我们就可以把它提取出来组成一个列向量，再让它乘以 $A^{c-1}$ 即可。向量乘矩阵显然比矩阵乘矩阵快很多（只取 $i=1$），直接把矩阵乘部分优化到了 $O(4n^2)$，总复杂度降为 $O(4n^2m\log c+8n^3\log V)$，可以通过。

代码很好写。

---

## 作者：gcx12012 (赞：0)

### 前言
做这题的时候差点没有想到拆点，唐完了。
### Solution
显然是一个矩阵加速题，如果没有整除 $2$ 的限制的话是好做的。我们设有关边权的矩阵为 $A$，一开始时先预处理 $A^{2^k}$，查询时设当前到第 $i$ 个点的最小距离为 $f_i$，我们把 $f$ 看作一个 $n$ 维向量，按照二进制拆位乘上满足条件的 $A^{2^k}$ 即可。

时间复杂度是 $O((n+m)n^2\log V)$ 的。

然后再考虑这个整除 $2$ 的限制，因为最多只能使用一次，于是我们多开一维 $0/1$ 表示有无使用整除 $2$，然后依旧做 $(\min,+)$ 的矩阵加速即可。

加了限制后的时间复杂度是 $O((2n+m)(2n)^2\log V)$ 的，可以通过。

---


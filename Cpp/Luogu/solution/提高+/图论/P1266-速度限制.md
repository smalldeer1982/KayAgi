# 速度限制

## 题目描述

在这个繁忙的社会中，我们往往不再去选择最短的道路，而是选择最快的路线。开车时每条道路的限速成为最关键的问题。不幸的是，有一些限速的标志丢失了，因此你无法得知应该开多快。一种可以辩解的解决方案是，按照原来的速度行驶。你的任务是计算两地间的最快路线。

你将获得一份现代化城市的道路交通信息。为了使问题简化，地图只包括路口和道路。每条道路是有向的，只连接了两条道路，并且最多只有一块限速标志，位于路的起点。两地 $A$ 和 $B$，最多只有一条道路从 $A$ 连接到 $B$。你可以假设加速能够在瞬间完成并且不会有交通堵塞等情况影响你。当然，你的车速不能超过当前的速度限制。


## 样例 #1

### 输入

```
6 15 1
0 1 25 68
0 2 30 50
0 5 0 101
1 2 70 77
1 3 35 42
2 0 0 22
2 1 40 86
2 3 0 23
2 4 45 40
3 1 64 14
3 5 0 23
4 1 95 8
5 1 0 84
5 2 90 64
5 3 36 40```

### 输出

```
0 5 2 3 1```

# 题解

## 作者：啧啧啧 (赞：167)

[P1266 速度限制](https://www.luogu.org/problem/P1266)题解


昨天考图论专题时考了这题(T4),当时一脸懵,暴力dijkstra还是boom 0.后来这位[大佬](https://www.luogu.org/space/show?uid=102754)教了我分层图.
于是我便~~穷困潦倒、千辛万苦、艰苦卓绝、含辛茹苦~~(轻松)地A了它

题解里只有一篇dijkstra的题解,所以我也来水一篇.



------------

**~~废话终结 进入正题~~**

## 思路:


本题有**限速**与**路程**两个条件.而为了时间最短(速度最快),所以限**速便是速度**(~~读者自证不难~~),而为了时间最短,所以我们以t(=s/v)为权值来跑**dijkstra**.

但是仔细读题,会发现每一条边的长度固定,但是速度不一定只有一种.设一条边没有限速时,它的速度是可能不唯一的.而如果单纯把它的速度设为它的前一条:
```cpp
void dj(){
	while(!p.empty()) p.pop();
	for(int i=1;i<=n;i++) dis[i]=1e9;
	p.push(make_pair(0,make_pair(1,70)));
	vis[1]=1;
	dis[1]=0;
	while(!p.empty()){
		int x=p.top().second.first;
		int batt=p.top().second.second;
		vis[x]=0;
		p.pop();
		for(int i=head[x];i;i=t[i].next){
			int y=t[i].to;
			if(t[i].bat){
				if((double)dis[y]>(double)dis[x]+(double)t[i].longg/(double)t[i].bat){
//					printf("from %d   to %d\	n",x,y);
					from[y]=x;
					dis[y]=(double)dis[x]+(double)t[i].longg/(double)t[i].bat;
					if(vis[y]) continue;
					vis[y]=1;
					p.push(make_pair(-dis[y],make_pair(y,t[i].bat)));
				}
				continue;
			}
			else{
				if((double)dis[y]>(double)dis[x]+(double)t[i].longg/(double)batt){
//					printf("from %d   to %d\n",x,y);
					from[y]=x;
					dis[y]=(double)dis[x]+(double)t[i].longg/(double)batt;
					if(vis[y]) continue;
					vis[y]=1;
					p.push(make_pair(-dis[y],make_pair(y,batt)));
				}
				continue;
			}
		}
	}
//	for(int i=1;i<=n;i++) printf("from[%d]=%d\n",i,from[i]);
//	for(int i=1;i<=n;i++) printf("dis[%d]=%lf\n",i,dis[i]);
	cout<<"0"<<" ";
	for(int i=d;i!=1;i=from[i]) printf("%d ",i);
	cout<<d-1<<endl;
}
```
# **那就是错的**
(别急着抄)

所以我们引入正题:[分层图(这个链接是假的)](https://baike.baidu.com/item/%E5%88%86%E5%B1%82%E5%9B%BE)

大家应该都知道dijkstra的常规操作以及数组:

1 dis[i]:出发点到点i的距离 (本题中为时间)

2 vis[i]:第i个点是否在队列(我的解释可能不普及)

那么在**分层图**中,我们给它们~~做个升级~~:

dis[i][j]:出发点到点i,速度为j时(可以理解成j的前一个点到j的速度为j)的距离(时间)

vis[i][j]:同上

那么对于每一个点x扩展到点y时:

#### - 如果边(x,y)的速度为0,那么便有:
```
if(...)
	dis[y][old_v]=dis[x][old_v]+(x,y).s/old_v;
```
//old_v为上一条的限速(代码中为vs)

//(x,y)为连接x与y的边

#### - 如果边(x,y)有速度,那么便有:
```
if(...)
	dis[y][now_v]=dis[x][old_v]+(x,y).s/now_v;
```
//old_v为上一条的限速

//now_v为现在的限速

//(x,y)为连接x与y的边

~~**(清晰易懂)**~~

好的呢,那就这样了吧.

输出存路径需要一个:

from[i][j]:点i(速度为j)的前一个点为from[i][j];

最后再一个递归就ok辽呢.

#### 上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,d;//点 边 终点
int tot,head[10001];
int vis[1001][1001];//如题解 
double dis[1001][1001];//如题解 
struct Node{
	int to,v,s;//点 限速 路程
	int next; 
}t[100001]; 
struct Nodee{
	int x,v;
}from[1001][1001];
void add(int from,int to,int v,int s){
	tot++;
	t[tot].to=to;
	t[tot].v=v;
	t[tot].s=s;
	t[tot].next=head[from];
	head[from]=tot;
}
void out(int x,int v){//输出递归 x为点 v为速度(别把v当做点) 
	if(x==1) return;
	out(from[x][v].x,from[x][v].v);
	printf("%d ",x-1);//在输入时+1了 
}
void dj(){
	priority_queue<pair<double,pair<int,int> > >p;//时间,点,速度 
	p.push(make_pair(0,make_pair(1,70)));
	for(int i=1;i<=n+1;i++){
		for(int j=1;j<=1000;j++){
			dis[i][j]=1e9+1;
		}
	} 
	dis[1][70]=0;
	vis[1][70]=1;
	while(!p.empty()){
		int x=p.top().second.first;
		int vs=p.top().second.second;
		vis[x][vs]=0;
		p.pop();
		for(int i=head[x];i;i=t[i].next){//如题解 
			int y=t[i].to;
			int n_v=t[i].v;
			if(t[i].v){//有速度 
				if(dis[y][n_v]>dis[x][vs]+(double)t[i].s/(double)n_v){
					dis[y][n_v]=dis[x][vs]+(double)t[i].s/(double)n_v;
//					printf("from %d  to %d\n",x-1,y-1);
					from[y][n_v]={x,vs};
					if(vis[y][n_v]) continue;
					vis[y][n_v]=1;
					p.push(make_pair(-dis[y][n_v],make_pair(y,n_v)));
				
				}
				continue;
			}
			if(!t[i].v){//无速度 
				n_v=vs;//照原来速度跑
				if(dis[y][n_v]>dis[x][vs]+(double)t[i].s/(double)n_v){
					dis[y][n_v]=dis[x][vs]+(double)t[i].s/(double)n_v;
//					printf("from %d  to %d\n",x-1,y-1);	
					from[y][n_v]={x,vs};
					if(vis[y][n_v]) continue;
					vis[y][n_v]=1;
					p.push(make_pair(-dis[y][n_v],make_pair(y,n_v)));
				} 
				continue;
			}
		}
	}
	int min_=0;
	dis[d][min_]=1e9+100;
	for(int i=1;i<=1000;i++){
		if(dis[d][min_]>=dis[d][i]&&dis[d][i]!=1e9+1) min_=i;
	}
//	printf("%lf\n",dis[d][min_]);
	printf("0 ");
	out(d,min_);
	printf("\n");
}

int read(){
	int f1=0,f2=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-') f2=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		f1=(f1<<1)+(f1<<3)+(ch^48);
		ch=getchar();
	}
	return f1*f2;
}
int main(){
	n=read(),m=read(),d=read();
	d++;
	for(int i=1;i<=m;i++){
		int A=read(),S=read(),D=read(),F=read();
		A++,S++;
		add(A,S,D,F);
//		add(S,A,D,F);	
	}
	dj();
	return 0;
}
```
最后温馨提示:

- m至少为 100001

- 点建议在输入时+1(最后输出记得-1)

-完结撒花

- **代码都抄了,赞是不是也要点?**

- 可以加我滴QQ(3147280295)不懂问我丫(抄代码也要理解哦)


---

## 作者：fanypcd (赞：15)

[P1266 速度限制 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1266)

亿眼分层图。

分层图除此之外还有很多应用（[如给你一个图，求使任意（不多于） k 条边权值变为 0 后的 S 到 T 的最短路（ k 不大）](https://oi-wiki.org/graph/node/)）。

最开始一直脑抽，认为如果当前速度小于到达的路的限速的话，仍然按照当前速度前进，就死活过不了样例。

我佛了。。

------

这里的分层图只是借用了一种表示不同状态的思想，而不是真的将图分层并在层之间建边跑最短路。

你大也可以将这试为动态规划的一种转移方式。

对于图 $G=(V(G),E(G))$​​，设 $dis[i][j]$​​​ 表示源点 S 到当前点 i，且到达速度为 j 时所花费的最短时间。

显然有 $dis[i][j] = \min_{l=0}^{maxspeed_k}dis[k][l] + len(k,i) / speed(k \in E)$​​​。

所以 dijkstrar 内的松弛操作应写为：

- 这里用邻接表存图
- sp[i] 表示第 i 条边的速度限制（无限制为 0 ）
- len[i] 表示第 i 条边的长度
- u 是一个 ```pair<int, int>``` 的二元组，first 里存储点标号，second 里存储当前速度。
- $from[i][j]$​ 二元组则表示从 S 到第 i 号点，到达速度为 j 时的最短路径上前一个点的标号及前一个点的到达速度。

```cpp
for(int i = first[u.first]; i; i = Next[i])
{
    int v = to[i], sped = (sp[i] ? sp[i] : u.second);
    double time = (double)len[i] / (double)sped;
    if(dis[u.first][u.second] + time < dis[v][sped])
    {
        dis[v][sped] = dis[u.first][u.second] + time;
        from[v][sped] = u;
        q.push(make_pair(-dis[v][sped], make_pair(v, sped)));
    }
}
```

最后我们只需要枚举终点的到达速度，取最大值，再依序输出路径即可。

Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define N 200005
int n, m, d;
int first[N], Next[N], to[N], sp[N], len[N], tot;
double dis[205][1005];
int vis[205][1005];
pair<int, int> from[205][1005];
void add(int x, int y, int z, int zz)
{
	Next[++tot] = first[x];
	first[x] = tot;
	to[tot] = y;
	sp[tot] = z;
	len[tot] = zz;
	return;
}
void dijkstrar(int x)
{
	priority_queue<pair<double, pair<int, int> > > q;
	for(int i = 1; i <= n; i++)
	{
		for(int j = 1; j <= 505; j++)
		{
			dis[i][j] = 1e9;
			vis[i][j] = 0;
		}
	}
	dis[x][70] = 0;
	q.push(make_pair(0, make_pair(x, 70)));
	while(!q.empty())
	{
		pair<int, int> u = q.top().second;
		q.pop();
		if(vis[u.first][u.second])
		{
			continue;
		}
		vis[u.first][u.second] = 1;
		for(int i = first[u.first]; i; i = Next[i])
		{
			int v = to[i], sped = (sp[i] ? sp[i] : u.second);
			double time = (double)len[i] / (double)sped;
			if(dis[u.first][u.second] + time < dis[v][sped])
			{
				dis[v][sped] = dis[u.first][u.second] + time;
				from[v][sped] = u;
				q.push(make_pair(-dis[v][sped], make_pair(v, sped)));
			}
		}
	}
	return;
}
void write(int x, int v)
{
	if(x == 1)
	{
		printf("0 ");
		return;
	}
	write(from[x][v].first, from[x][v].second);
	printf("%d ", x - 1);
	return;
}
signed main()
{
	scanf("%d%d%d", &n, &m, &d);
	int x, y, z, zz;
	for(int i = 1; i <= m; i++)
	{
		scanf("%d%d%d%d", &x, &y, &z, &zz);
		x++;
		y++;
		add(x, y, z, zz);
	}
	dijkstrar(1);
	d++;
	int maxx = 0;
	dis[d][maxx] = 1e9;
	for(int i = 1; i <= 500; i++)
	{
		if(dis[d][i] < dis[d][maxx])
		{
			maxx = i;
		}
	}
	write(d, maxx);
	return 0;
}
```



---

## 作者：Flanksy (赞：7)

### 启发式搜索

------------

动态规划的解法有些复杂，所以用 A* 通过了。

最短路类型问题，距离函数一般设为每个点到目标点的最短距离，这道题中由于存在速度，通过一些路径花费的时间可能受之前到达的路径影响。在反图上跑单源最短路，所有路径都无视限制开到最高速即可，这个距离函数是乐观的，可以保证答案的正确性。

A* 的部分需要记录当前速度，这个很容易做到。向相邻节点转移时特判一下路径有无限速，如果没有限速就用当前速度通过。

接下来是这道题的难点：记录路径。记录节点从哪个节点转移，由于抵达时的速度不同需要分开记录，笔者使用了一个 `vector` 完成。

[评测记录（40 points）](https://www.luogu.com.cn/record/109869258)

同时存在 TLE 和 MLE，考虑剪枝。优先考虑对距离函数加权，太大会导致 WA，太小则效率过低。手动二分，发现将距离函数放大到原先的 1.25 倍时结果仍然正确，再大则会出现 WA 的测试点。

[评测记录（80 points）](https://www.luogu.com.cn/record/109869450)

试图开 O2 通过，结果只是从 TLE 变成 MLE，继续剪枝。

想了一阵，决定控制节点访问次数，不清楚这是否会影响答案正确性，但其可以大大提升程序效率，是有必要应用的。

控制至多访问同一节点 100 次后可以获得 90 分，一个测试点 WA。再次手动二分，访问次数控制在 300 已经可以 AC。同时即使设定为 500 或者更大一些的数也不会超时。

[评测记录（AC）](https://www.luogu.com.cn/record/109870859)

```cpp
#include<bits/stdc++.h>
using namespace std;
constexpr double inf=1e12;
struct Edge{int v,to,las;double h,dis;};//当前速度 当前节点 转移来源 估值函数 实际距离 
bool cmp(const Edge &x,const Edge &y){return x.h>y.h;}
priority_queue<Edge,vector<Edge>,decltype(*cmp)> q(cmp);
struct Star{int v,w,to;};
struct Ztar{int w,to;};
int n,m,T,top,las[151],ans[151];
vector<pair<int,int> > mem;
vector<Star> e[151];
vector<Ztar> v[151];
double dis[151];
bool on[151];
int main(){
	ios::sync_with_stdio(0);
	cin>>n>>m>>T,++T;
	for(int i=1;i<=m;i++){
		static int x,y,w,_v;
		cin>>x>>y>>_v>>w;
		++x,++y,v[y].push_back(Ztar{w,x});
		e[x].push_back(Star{_v,w,y});
	}
	fill(dis+1,dis+n+1,inf);
	dis[T]=0.0,q.push(Edge{0,T,0,0.0,0.0});
	while(!q.empty()){
		int now=q.top().to;q.pop();
		if(on[now]) continue;
		on[now]=1;
		for(auto i:v[now]) if(dis[i.to]>dis[now]+1.0*i.w/500){
			dis[i.to]=dis[now]+1.0*i.w/500;
			q.push(Edge{0,i.to,0,dis[i.to],0.0});
		}
	}
	q.push(Edge{70,1,0,dis[1],0.0});
	mem.resize(1);
	while(!q.empty()){
		static constexpr int lim=300;
		static int tim[151];
		int v=q.top().v,now=q.top().to,ind=mem.size();
		double ran=q.top().dis;
		mem.push_back({now,q.top().las}),q.pop();
		if(now==T) break;
		if(++tim[now]>lim) continue;
		for(auto i:e[now]) if(tim[i.to]<=lim)
			if(!i.v) q.push(Edge{v,i.to,ind,ran+1.0*i.w/v+1.25*dis[i.to],ran+1.0*i.w/v});
			else q.push(Edge{i.v,i.to,ind,ran+1.0*i.w/i.v+1.25*dis[i.to],ran+1.0*i.w/i.v});
	}
	for(int i=mem.size()-1;mem[i].first;i=mem[i].second) ans[++top]=mem[i].first;
	for(int i=top;i;i--) cout<<ans[i]-1<<' ';
	return 0;
}
```


---

## 作者：木木！ (赞：7)

来一发不需要分层图的题解。（目前最优解第二，第一是 18 年评测姬快的那会提交的。）

定义无速度路为 $v=0$ 的边，有速度路为 $v\neq 0$ 的边。

如果想要直接 Dijkstra 暴碾的话，只需要对于每一个有速度路再枚举另一条紧接着它的无速度路更新就好了。但是会遇到一个问题：可能一条有速度路会紧接着许多条无速度路，无法直接枚举。

然后可以发现 **无速度的路可以合并**，即先走无速度路 $(a,b,0,l_1)$ 再走 $(b,c,0,l_2)$ 等价于直接走 $(a,c,0,l_1+l_2)$，因此可以先对每个点只对无速度路做一遍 Dijkstra，将所有超过两条的无速度路转化为一条无速度路。（类似于传递闭包。）

这样的话每个有速度路就只需要枚举 $\Theta(n)$ 条紧接着的无速度路就好了。

在输出路径的时候有点麻烦，需要对有速度路和无速度路分类讨论，还需要对 1 特判，不过都可以用样例调出来，最终 1A。

时间复杂度，令 $m_1$ 为无速度路的个数，$m_2$ 为有速度路的个数，$n$ 次 Dijkstra $\Theta(n(n+m_1)\log m_1)$，最后一次 Dijkstra $\Theta((n+m_2)\log m_2)$，枚举无速度路的时间复杂度可以合在一起计算，为 $\Theta(nm_2)$，最终时间复杂度 $\Theta(n^2\log n+nm_1\log n+nm_2)$。

附 AC 代码：

```cpp
#include <queue>
#include <stack>
#include <cstdio>
using namespace std;

int beg[155];
int ed[22505];
int nxt[22505];
int li[22505];
int vi[22505];
int top;

void addedge(int a,int b,int l,int v)
{
	++top;
	ed[top] = b;
	li[top] = l;
	vi[top] = v;
	nxt[top] = beg[a];
	beg[a] = top;
}

int dn;
int undist[155][155];
int unpre[155][155];
int vis[155];

void undisdij(int x)
{
	for(int i=1; i<=dn; ++i)
	{
		undist[x][i] = 0x7f7f7f7f;
		vis[i] = 0;
	}
	
	undist[x][x] = 0;
	priority_queue<pair<int,int> > pq;
	pq.push(make_pair(0,x));
	
	while(!pq.empty())
	{
		int th = pq.top().second;
		pq.pop();
		if(vis[th]) continue;
		
		vis[th] = 1;
		
		for(int p=beg[th]; p; p=nxt[p])
		{
			if(!vi[p] && undist[x][ed[p]]>undist[x][th]+li[p])
			{
				unpre[x][ed[p]] = th;
				undist[x][ed[p]] = undist[x][th]+li[p];
				pq.push(make_pair(-undist[x][ed[p]],ed[p]));
			}
		}
	}
}

double dist[155];
int type[155];
int pre[155];
int ppre[155];

void dijkstra(int s)
{
	priority_queue<pair<double,int> > pq;	
	for(int i=1; i<=dn; ++i)
	{
		pre[i] = s;
		ppre[i] = s;
		type[i] = 0;
		dist[i] = 1.*undist[s][i]/70;
		pq.push(make_pair(-dist[i],i));
		vis[i] = 0;
	}
	
	while(!pq.empty())
	{
		int th = pq.top().second;
		pq.pop();
		if(vis[th]) continue;
		
		vis[th] = 1;
		
		for(int p=beg[th]; p; p=nxt[p])
		{
			if(vi[p])
			{
				if(dist[ed[p]] > dist[th]+(1.*li[p]/vi[p]))
				{
					dist[ed[p]] = dist[th] + (1.*li[p]/vi[p]);
					type[ed[p]] = 1;
					pre[ed[p]] = th;
					pq.push(make_pair(-dist[ed[p]],ed[p]));
				}
				for(int i=1; i<=dn; ++i)
				{
					if(dist[i] > dist[th]+(1.*li[p]/vi[p])+(1.*undist[ed[p]][i]/vi[p]))
					{
						dist[i] = dist[th] + (1.*li[p]/vi[p]) + (1.*undist[ed[p]][i]/vi[p]);
						type[i] = 0;
						pre[i] = th;
						ppre[i] = ed[p];
						pq.push(make_pair(-dist[i],i));
					}
				}
			}
		}
	}
}

int main()
{
	int n,m,d;
	scanf("%d%d%d",&n,&m,&d);
	for(int i=1; i<=m; ++i)
	{
		int a,b,v,l;
		scanf("%d%d%d%d",&a,&b,&v,&l);
		addedge(a+1,b+1,l,v);
	}
	++d;
	
	dn = n;
	for(int i=1; i<=n; ++i)
	{
		undisdij(i);
	}
	
	dijkstra(1);
	
	stack<int> stk;
	while(d!=1)
	{
		stk.push(d);
		if(type[d])
		{
			d = pre[d];
		}
		else if(ppre[d] != pre[d])
		{
			int pxt = ppre[d];
			int xpt = pre[d];
			while(d!=pxt)
			{
				d = unpre[pxt][d];
				stk.push(d);
			}
			d = xpt;
		}
		else
		{
			while(unpre[1][d]!=1)
			{
				d = unpre[1][d];
				stk.push(d);
			}
			break;
		}
	}
	
	printf("0");
	while(!stk.empty())
	{
		printf(" %d",stk.top()-1);
		stk.pop();
	}
}
```

---

## 作者：Mine_King (赞：7)

首先我们要知道，dijkstra 其实是在图上的 DP（松弛可以看做状态转移），那么这题我们如果直接和普通 dijkstra 一样做是不行的，因为当两条速度为 $0$ 的边在一起时，前一条边的速度会影响后一条边的速度，也就是有后效性。

我们回头看一下数据范围，可以发现这两句话：

> $0 \le V \le 500$  
> $2 \le N \le 150$

于是我们就可以考虑把速度算作一维放在 DP 数组中，而 $N$ 和 $V$ 的取值范围又都很小，放一个数组里不会出现 MLE 的问题。  
所以这样做是可行滴~  

那么我们就可以得到状态转移方程：

- $V_2=0$：$v_{v,V_1}=min(v_{u,V_1}+V_1/L)$
- $V_2 \not= 0$：$v_{v,V_2}=min(v_{u,V_{1}}+V_2/L)$

其中，$V_1$ 表示到 $u$ 时的速度，$V_2$ 表示到 $v$ 时的速度，$u,v$ 分别表示起点和终点。

在松弛时特判一下 $V_2$ 的情况即可。  

最后的问题就是输出路径，我们可以用一个数组记录转移过来的那个点，最后递归输出即可。

还有个小细节就是在处理的时候把点的编号 $+1$ 会方便点，最后输出的时候再 $-1$ 就行了。

**Code**
```cpp
#include<queue>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int n,m,d;
int pre[155][505][2];//记录前驱
double v[155][505];
bool f[155][505];
struct node
{
	double first;
	int second,third;
	friend bool operator<(node x,node y){return x.first>y.first;}
};
priority_queue<node>q;//小根堆
struct graph
{
	int tot;
	int hd[155];
	int nxt[22505],to[22505],dt[22505],V[22505];
	void add(int u,int v,int w,int vv)
	{
		nxt[++tot]=hd[u];
		hd[u]=tot;
		to[tot]=v;
		dt[tot]=w;
		V[tot]=vv;
		return ;
	}
}g;
void print(int now,int vv)//递归输出
{
	if(now-1!=0) print(pre[now][vv][0],pre[now][vv][1]);
	printf("%d ",now-1);
	return ;
}
int main()
{
	scanf("%d%d%d",&n,&m,&d);
	for(int i=1;i<=m;i++)
	{
		int u,v,w,vv;
		scanf("%d%d%d%d",&u,&v,&vv,&w);
		g.add(u+1,v+1,w,vv);
	}
	for(int i=1;i<=n;i++)
		for(int j=0;j<=500;j++) v[i][j]=1e9;//初始化，不能用memset！（memset好像对double没效果）
	v[1][70]=0;
	q.push((node){0,1,70});
	while(!q.empty())
	{
		int xx=q.top().second,vv=q.top().third;
		q.pop();
		if(f[xx][vv]) continue;
		f[xx][vv]=true;
		for(int i=g.hd[xx];i;i=g.nxt[i])
			if(g.V[i]==0)
			{
				if(v[g.to[i]][vv]>v[xx][vv]+1.00*g.dt[i]/vv)
				{
					v[g.to[i]][vv]=v[xx][vv]+1.00*g.dt[i]/vv;
					pre[g.to[i]][vv][0]=xx;//记录前驱是哪个点
					pre[g.to[i]][vv][1]=vv;//记录前驱的速度
					q.push((node){v[g.to[i]][vv],g.to[i],vv});
				}
			}
			else
			{
				if(v[g.to[i]][g.V[i]]>v[xx][vv]+1.00*g.dt[i]/g.V[i])
				{
					v[g.to[i]][g.V[i]]=v[xx][vv]+1.00*g.dt[i]/g.V[i];
					pre[g.to[i]][g.V[i]][0]=xx;
					pre[g.to[i]][g.V[i]][1]=vv;
                    //也是记录前驱
					q.push((node){v[g.to[i]][g.V[i]],g.to[i],g.V[i]});
				}
			}
	}
	int av=0;
	for(int i=1;i<=500;i++)
		if(v[d+1][i]<v[d+1][av]) av=i;//最后一定要扫一遍，因为你不能确定最后是哪个速度总时间最短
	print(d+1,av);//输出
    //d记得要+1！！！
	return 0;
}
```

---

## 作者：postcards (赞：6)

此题可以称作分层图最短路？

用dist[i][j]表示到i点速度为j的最快时间

然后分两种情况来转移，一种是没限速的，一种是有限速的。

看着做就行了。。

```cpp

#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<queue>
#include<algorithm>
#include<ctime>
using namespace std;
const int N=255,M=N*N*2;
int list[M],head[N],next[M],w[M],len[M],tot;
void add(int a,int b,int c,int d)
{
    tot++;
//  cout<<"add "<<a<<" "<<b<<" "<<c<<" "<<d<<endl;
    list[tot]=b,len[tot]=c,w[tot]=d;
    next[tot]=head[a];
    head[a]=tot;
}
double dist[N][505];
bool vis[N][505];
struct pos
{
    int x,s;
    pos(){};
    pos(int nn,int ss){x=nn,s=ss;};
};
int pr[N][505],ps[N][505];
int n,m;
void spfa()
{
    memset(dist,66,sizeof dist);
    queue<pos>q;
    q.push(pos(1,70));dist[1][70]=0;
    vis[1][70]=1;
    while(!q.empty())
    {
         pos v=q.front();q.pop();
         vis[v.x][v.s]=0;
    //   cout<<v.x<<" "<<v.s<<endl;
         for(int i=head[v.x];i;i=next[i])
         {
                //cout<<i<<endl;
                int u=list[i];
                //cout<<u<<endl;
                if(w[i]==0)//没限速 
                {
                    if(1.0*len[i]/v.s+dist[v.x][v.s]<dist[u][v.s])
                    {
                        dist[u][v.s]=1.0*len[i]/v.s+dist[v.x][v.s];
                        pr[u][v.s]=v.x;
                        ps[u][v.s]=v.s;
                        if(!vis[u][v.s])
                        {
                            q.push(pos(u,v.s));
                            vis[u][v.s]=1;
                        }
                    }
                }
                else
                {
                    int mv=w[i];
                    if(1.0*len[i]/mv+dist[v.x][v.s]<dist[u][mv])
                    {
                        dist[u][mv]=1.0*len[i]/mv+dist[v.x][v.s];
                        pr[u][mv]=v.x;
                        ps[u][mv]=v.s;
                        if(!vis[u][mv])
                        {
                            q.push(pos(u,mv));
                            vis[u][mv]=1;
                        }
                    }
                }
        }
    }
}
void print(int a,int b)
{
    if(a!=1)print(pr[a][b],ps[a][b]);
    printf("%d ",a-1);
}
int e=0;
int main()
{
    scanf("%d%d%d",&n,&m,&e);e++;
    for(int i=1;i<=m;i++)
    {
        int a,b,c,d;scanf("%d%d%d%d",&a,&b,&c,&d);
        a++,b++;
        add(a,b,d,c);
    }
    spfa();
    double mn=1e30;int ans=0;
    for(int i=1;i<=500;i++)
    {
        if(mn>dist[e][i])
        mn=dist[e][i],ans=i;
    }
    print(pr[e][ans],ps[e][ans]);
    printf("%d\n",e-1);
}

```

---

## 作者：issue_is_fw (赞：4)

有点类似分层图的转移....

不会分层图也没关系,因为这个只是在最短路上稍加修改

令$dis[u][v]$是从点0出发到达点$u$速度为$v$的最快时间

普通的最短路$spfa$是每次把一个点入队

**这里有两种极其相似的写法(当然是方法二更优)**

$Ⅰ.和最短路一样每次把被更新的点入队$

由于每次没有保存在这个点速度的信息,所以可以暴力枚举所有$[0,500]$的速度,然后暴力转移

```
#include <bits/stdc++.h>
using namespace std;
#define f first
#define s second
const int maxn=300009;
int n,m,D,vis[maxn];
struct P{
	int to,nxt,v; double l;
}d[maxn]; int head[maxn],cnt=1;
void add(int u,int to,int v,double len){
	d[cnt]=(P){to,head[u],v,len}; head[u]=cnt++;
}
double dis[159][509];
typedef pair<int,int>p;
p pre[159][509];
void spfa(int s)
{
	for(int i=0;i<=150;i++)
	for(int j=0;j<=500;j++)
		dis[i][j]=1e9;
	queue<int>q;
	dis[s][70]=0,q.push(s);
	while( !q.empty() )
	{
		int u=q.front(); q.pop();
		vis[u]=0;
		for(int i=head[u];i;i=d[i].nxt)
		{
			int to=d[i].to,v=d[i].v;
			if( v )//限速 
			{
				int flag=0;
				for(int j=0;j<=500;j++)
				{
					if( dis[u][j]+d[i].l/(v*1.0)<dis[to][v] )
					{
						flag=1;
						dis[to][v]=dis[u][j]+d[i].l/(v*1.0);
						pre[to][v]=p(u,j);
					}
				}
				if( flag&&!vis[to] )	vis[to]=1,q.push(to);
			}	
			else//to从u的速度转移而来 
			{
				int flag=0;
				for(int j=0;j<=500;j++)
				{
					if( dis[u][j]+d[i].l/(j*1.0)<dis[to][j] )
					{
						flag=1;
						dis[to][j]=dis[u][j]+d[i].l/(j*1.0);
						pre[to][j]=p(u,j);
					}
				}
				if( flag&&!vis[to] )	vis[to]=1,q.push(to);				
			}
		} 
	}
}
void dfs(int u,int v){
	if( u==0 )
	{
		cout<<u<<" ";
		return;
	}
	dfs(pre[u][v].first,pre[u][v].second);
	cout<<u<<" ";
}
int main()
{
	cin >> n >> m >> D;
	for(int i=1;i<=m;i++)
	{
		int l,r,v; double len;
		cin >> l >> r >> v >> len;
		add(l,r,v,len);
	}
	spfa(0);
	int num=-1;
	double minn=1e9;
	for(int i=0;i<=500;i++)
		if( dis[D][i]<minn )
		{
			minn=dis[D][i];
			num=i;
		}
	dfs(D,num);
}
```

$Ⅱ.像分层图一样,每次把被更新的点和时间入队$

这样保存了速度的信息,直接对着速度转移就行,省掉了一个循环的复杂度

```
#include <bits/stdc++.h>
using namespace std;
#define f first
#define s second
const int maxn=300009;
int n,m,D,vis[159][509];
struct P{
	int to,nxt,v; double l;
}d[maxn]; int head[maxn],cnt=1;
void add(int u,int to,int v,double len){
	d[cnt]=(P){to,head[u],v,len}; head[u]=cnt++;
}
double dis[159][509];
typedef pair<int,int>p;
p pre[159][509];
void spfa(int s)
{
	for(int i=0;i<=150;i++)
	for(int j=0;j<=500;j++)
		dis[i][j]=1e9;
	queue<p>q;
	dis[s][70]=0,q.push(p(s,70));
	vis[s][70]=1;
	while( !q.empty() )
	{
		p u=q.front(); q.pop();
		vis[u.f][u.s]=0;
		for(int i=head[u.f];i;i=d[i].nxt)
		{
			int to=d[i].to,v=d[i].v;
			if( v )//限速 
			{
				if( d[i].l/(v*1.0)+dis[u.f][u.s]<dis[to][v] )
				{
					dis[to][v]=d[i].l/(v*1.0)+dis[u.f][u.s];
					pre[to][v]=u;
					if( !vis[to][v] )
					{
						q.push(p(to,v));
						vis[to][v]=1;
					}
				}
			}	
			else//to从u的速度转移而来 
			{
				if( d[i].l/(u.s*1.0)+dis[u.f][u.s]<dis[to][u.s] )
				{
					dis[to][u.s]=d[i].l/(u.s*1.0)+dis[u.f][u.s];
					pre[to][u.s]=p(u.f,u.s);
					if( !vis[to][u.s] )
					{
						vis[to][u.s]=1;
						q.push( p(to,u.s) );	
					}	
				}			
			}
		} 
	}
}
void dfs(int u,int v){
	if( u==0 )
	{
		cout<<u<<" ";
		return;
	}
	dfs(pre[u][v].first,pre[u][v].second);
	cout<<u<<" ";
}
int main()
{
	cin >> n >> m >> D;
	for(int i=1;i<=m;i++)
	{
		int l,r,v; double len;
		cin >> l >> r >> v >> len;
		add(l,r,v,len); 
	}
	spfa(0);
	int num=-1;
	double minn=1e9;
	for(int i=0;i<=500;i++)
		if( dis[D][i]<minn )
		{
			minn=dis[D][i];
			num=i;
		}
	dfs(D,num);
}
```



---

## 作者：KEBrantily (赞：2)

## Description

给定一张有向图，对于图中的每条边，给出它的长度以及经过它时的速度，当某条边给定的速度为 $0$ 时，它的速度可以是任意一条**连向这条边的起点的边**的速度。

求从 $0$ 号点出发，到达 $D$ 号所用时间最少的一条路径。

## Solution

根据题目信息，大概可以猜想到这是求一个最短路（或者在这个题目中叫做最快路）。

但是题目中只给出了路程与速度，并未给出时间，就要考虑该怎么转化。

显然，根据公式 $\large{t=\frac{s}{v}}$，我们便可以将路程与速度转化成时间，然后将它作为边权跑一个最短路。

但是这里还有第二个问题，那就是某些边的速度不确定，也就是它的时间（边权）不确定，所以我们要通过某些方法确定它的速度。

如果直接贪心地钦定某条无速度的边是当前能连到它的最快速度，可能会出现这条路并不是最短路的情况。

所以这个速度并不能提前确定，而是在我们遍历的时候择优确定。

我们知道，在最短路中，$dis[i]$ 一般表示从起点到 $i$ 号点的最短距离。

为了比较各个速度下的最短距离，我们可以在原基础上增加一维，也就是设 $dis[i][j]$ 表示从起点到第 $i$ 号点，且在第 $i$ 号点时速度为 $j$ 的最短距离。

这样进行最短路更新时可以更新各个速度下的最短路，也就可以找出最快的路径了。

### 关于代码的实现

- 我们可以开一个结构体，存储每个点以及这个点开始的速度是多少，用于求最短路时的更新。

- 输出方案时，可以按最短路统计路径的方法，记录路径上每个点的前驱节点，然后递归输出即可。

- 注意点是从 $0$ 到 $n-1$ 编号的。

## Code
```cpp
#include<queue>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<algorithm>
#define maxn 2100
#define maxm 100100
#define INF 0x3f3f3f3f
//#define int long long

using namespace std;

int n,m,end,tot;
double Dis[maxn][maxn];
int vis[maxn][maxn],head[maxn];
struct node{int pos,vold;}pre[maxn][maxn];
struct edge{int to,v,len,nxt;}e[maxm];

int read(){
	int s=0,w=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')s=(s<<1)+(s<<3)+ch-'0',ch=getchar();
	return s*w;
}

void add(int fr,int to,int v,int len){
    e[++tot].to=to;e[tot].len=len;
    e[tot].v=v;e[tot].nxt=head[fr];
    head[fr]=tot;
}

void spfa(){
    memset(pre,-1,sizeof pre);
    memset(Dis,127,sizeof Dis);
    Dis[1][70]=0;vis[1][70]=1;
    queue<node> d;d.push((node){1,70});
    while(!d.empty()){
        int u=d.front().pos;
        int v=d.front().vold;
        d.pop();vis[u][v]=0;
        for(int i=head[u];i;i=e[i].nxt){
            int to=e[i].to,vold=e[i].v;
            if(vold==0) vold=v;
            if(Dis[to][vold]>Dis[u][v]+(double)(e[i].len/(vold/1.0))){
                Dis[to][vold]=Dis[u][v]+(double)(e[i].len/(vold/1.0));
                pre[to][vold].pos=u;pre[to][vold].vold=v;
                if(!vis[to][vold]){
                    vis[to][vold]=1;
                    d.push((node){to,vold});
                }
            }
        }
    }
}

void print(int pos,int vold){
    if(pre[pos][vold].pos!=-1) 
        print(pre[pos][vold].pos,pre[pos][vold].vold);
    printf("%d ",pos-1);
}

int main(){
    n=read();m=read();end=read()+1;
    for(int i=1,fr,to,vold,len;i<=m;i++){
        fr=read()+1;to=read()+1;
        vold=read();len=read();
        add(fr,to,vold,len);
    }
    spfa();double minx=INF*1.0,id;
    for(int i=1;i<=500;i++)
        if(minx>Dis[end][i])
            minx=Dis[end][i],id=i;
    print(end,id);
    return 0;
}
```


---

## 作者：Acestar (赞：1)

题意很好理解，就是给你一个图，$n$ 个点，$m$ 条边，每条边包含长度 $l$，和 速度 $v$，求从 $0$ 到 $d$ 最短花多少时间，如果 $v=0$ 那么速度为到这条边的起点时的速度，也就是保持原速不变。

我用的邻接矩阵，用结构体 $G_{i,j}$ 存 $i$ 到 $j$ 是否有边 $(flag)$、距离 $(l)$、速度 $(v)$。

因为不同的速度会导致不同的结果，所以我们要把速度也标记下来。

用 $dis_{i,j}$ 表示从 $0$ 到 $i$ 并且到 $i$ 时速度为 $j$ 的最短时间，我们用 $dijkstra+$堆优化 求出 $dis$，然后在 $dis_{d,i}(0≤i≤500)$ 中找到最小的 $dis$，把速度存下来。

最后递归输出。用结构体数组 $pre_{i,j}$ 存 $dis_{i,j}$ 是由什么转移过来的。

输出的时候，就一直向前查找，直到前一个点为 $-1$ 再输出并回溯。

```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<queue>
#include<cstring>
#define N 200
#define V 510
#define INF 0x3f3f3f3f

using namespace std;

int n,m,d;
struct point
{
	int flag,v,l;	//flag:是否有边,v:速度,l:长度 
}G[N][N];
struct node	//优先队列的类型 
{
	int u,v;	//u:节点编号,v:到u时的速度 
	double t;	//已经用了多长时间 
	node(int _u=0,int _v=0,double _t=0)
	{
		u=_u;
		v=_v;
		t=_t;
	}
	const bool operator < (const node b) const	//因为我写的大根堆，所以要反过来 
	{
		return t==b.t?v<b.v:t>b.t;	//时间越小越好，如果相等，速度越大越好 
	}
}; 
struct PRE
{
	int u,v;	//前一个点的编号和速度 
}pre[N][V];
double dis[N][V];
int vis[N][V];
priority_queue <node> que;

void dijkstra()
{
	memset(dis,0x7f,sizeof(dis));
	memset(pre,-1,sizeof(pre));
	dis[0][70]=0;
	que.push(node(0,70,dis[0][70]));
	while(!que.empty())
	{
		node p=que.top();
		que.pop();
		int i=p.u,j=p.v;
		if(vis[i][j]) continue;
		vis[i][j]=1;
		for(int k=0; k<n; k++)
		{
			if(G[i][k].flag)
			{
				if(!G[i][k].v)
				{
					if(dis[i][j]+(double)(1.0*G[i][k].l/j)<dis[k][j])
					{
						dis[k][j]=dis[i][j]+(double)(1.0*G[i][k].l/j);
						que.push(node(k,j,dis[k][j]));
						pre[k][j].u=i;
						pre[k][j].v=j;
					}
				}
				else
				{
					int v=G[i][k].v;
					if(dis[i][j]+(double)(1.0*G[i][k].l/v)<dis[k][v])
					{
						dis[k][v]=dis[i][j]+(double)(1.0*G[i][k].l/v);
						que.push(node(k,v,dis[k][v]));
						pre[k][v].u=i;
						pre[k][v].v=j;
					}
				}
			}
		}
	}
	return;
}

void print(int u,int v)
{
	if(pre[u][v].u!=-1) print(pre[u][v].u,pre[u][v].v);
	printf("%d ",u);
}

int main()
{
	scanf("%d%d%d",&n,&m,&d);
	for(int i=1; i<=m; i++)
	{
		int a,b,v,l,t=0;
		scanf("%d%d%d%d",&a,&b,&v,&l);
		G[a][b]=(point){1,v,l};
	}
	dijkstra();
	double mint=INF;
	int speed;
	for(int i=0; i<=500; i++)
	{
		if(dis[d][i]<mint)
		{
			mint=dis[d][i];
			speed=i;
		}
	}
	print(d,speed);
	return 0;
}
```


---


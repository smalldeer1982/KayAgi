# [GCJ 2012 Finals] Zombie Smash

## 题目描述

你正在玩丧尸粉碎（Zombie Smash）这款游戏：你的目标是在墓地中用你可靠的丧尸粉碎器击碎不断从坟墓中冒出的丧尸。墓地被表示为一个平坦的二维网格。每只丧尸会在网格的某个 $(X, Y)$ 单元格中冒出，停留 1000 毫秒（ms），然后又消失回坟墓。任意时刻每个坟墓旁最多只会有一只丧尸。

你可以在 100ms 内移动到当前位置周围 8 个相邻格中的任意一个：也就是说，你可以向正北、正东、正南、正西、东北、东南、西北、西南移动。即使某个格子当前有丧尸占据，你依然可以经过或停在该格子。只要你到达丧尸所在的格子，就可以立即击碎该丧尸，但每次击碎后，你的丧尸粉碎器需要 750ms 冷却，冷却期间你不能再次击碎丧尸，但你可以自由移动。例如，刚刚在 $(0, 0)$ 击碎一只丧尸后：

* 你需要 750ms 才能到达并击碎 $(1, 1)$ 处的丧尸；
* 你需要 2000ms 才能到达并击碎 $(20, 20)$ 处的丧尸。

你在游戏开始时（时间 $=0$）站在 $(0, 0)$。每一关结束后，你想知道如果你玩得最优，这一关你最多能击碎多少只丧尸。

## 说明/提示

**限制条件**

- $1 \leq T \leq 100$
- $-1000 \leq X_i, Y_i \leq 1000$
- $0 \leq M_i \leq 100000000 = 10^8$
- 任意时刻同一格子不会有两只丧尸。换言之，如果某只丧尸在 $(x, y)$ 的 $t$ 时刻出现，则其他在 $(x, y)$ 出现的丧尸要么出现在 $t-1001$ 及更早，要么出现在 $t+1001$ 及更晚。

**测试集 1（7 分，结果可见）**

- $1 \leq Z \leq 8$

**测试集 2（18 分，结果隐藏）**

- $1 \leq Z \leq 100$

翻译由 ChatGPT-4.1 完成。

## 样例 #1

### 输入

```
3
4
1 0 0
-1 0 0
10 10 1000
10 -10 1000
3
1 1 0
2 2 0
3 3 0
5
10 10 1000
-10 10 1000
10 -10 1000
-10 -10 1000
20 20 2000```

### 输出

```
Case #1: 3
Case #2: 2
Case #3: 2```

# 题解

## 作者：tuxiaolai (赞：1)

# 1 说明
由于这题刚加进来没多久，我是第一个 AC 此题的，所以我不能保证题解的正确性。
# 2 审题
**[传送门](https://www.luogu.com.cn/problem/P13332)**

简要概括题目就是：从起点出发~~乱走~~，如果到达一个坐标后这个点刚好有僵尸，就可以击杀它，但下次击杀需要等 $750\text ms$ 后。从一个点走到另一个点的时间是 $\max(|x_1-x_2|,|y_1-y_2|)\times 100 \text ms$，即它们的切比雪夫距离，后文用 $dis_{i,j}$ 表示。
# 3 思路
首先我们要明确，我们走到一个点一定是有目的的，也就是说：只有我们确保能够击碎僵尸，才会走过去，且一定会击碎它。因此，我们可以从起点出发，遍历每个点，并计算距离。为避免过多地判断冷却时间，我们将状态定义为击杀僵尸时的坐标、击杀数及时间。每次将状态放入队列，并等待下一次扩展状态。对于冷却时间，共有两种情况：

- 在到达点之前冷却结束，可以直接继续击碎。
- 在到达点之前冷却未结束，需等至 $750\text ms$ 后才能继续击碎。

不难发现，从 $u$ 点出发（表示刚刚击碎完，进入冷却时间，起点除外），到达 $v$ 点并击碎所需的时间是 $\max(dis_{u,v},750\text ms)$。

其次，从 $u$ 点出发，到达 $v$ 点的时间（含冷却时间）是 $u_t+\max(dis_{u,v},750\text ms)$，$u_t$ 表示 $u$ 点的时间，对于 $v_t$ 共有三种情况：

- $v_m+1000\text ms<v_t$，（$v_m$ 表示僵尸出现的时间）即到达时僵尸以消失，那么不能击碎，也就不用扩展状态。
- $v_m \le v_t \le v_m+1000\text ms$，即在时间范围内，立即击碎并扩展状态。
- $v_t < v_m$，即僵尸还未出现，等到僵尸出现是立即击碎并扩展状态。

这样，我们就可以完整遍历所有情况啦！

注：上文中的“点”表示的是一种状态，包含了坐标、击杀数和时间。
# 4 AC CODE
思路已经十分详细了，这里不再拆开讲代码了：
```cpp
#include<bits/stdc++.h>
using namespace std;
int T;
int z;
struct Zb {//僵尸
    int x=0,y=0,m=0;//表示坐标和出现时间
} zb[110];
struct status {//状态
    int i,t,z;//表示僵尸编号、时间、击杀数
    bool operator<(const status &other)const {//按击杀数和时间比较
        return z==other.z ? t>other.t : z<other.z;
    }
} st[110];
bool vis[110];
int dis(Zb a,Zb b) {//切比雪夫距离
    return max(abs(a.x-b.x),abs(a.y-b.y));
}
int ans;
void solve() {
    for(int i=0; i<=z; i++) {//初始化
        st[i]= {i,0,0};
    }
    queue<status> q;//队列
    q.push({0,0,0});
    while(q.size()) {
        auto u=q.front();
        q.pop();
        ans=max(ans,u.z);
        for(int i=1; i<=z; i++) {
            if(i==u.i) {
                continue;
            }
            int nowdis=u.i==0 ? dis(zb[u.i],zb[i])*100 : max(dis(zb[u.i],zb[i])*100,750);//计算所用时间
            status nowst;//新状态
            if(u.t+nowdis>zb[i].m+1000) {//时间判断
                continue;
            } else {
                nowst.t=max(zb[i].m,u.t+nowdis);
            }
            nowst.i=i;
            nowst.z=u.z+1;
            if(st[i]<nowst) {//更优即放入
                st[i]=nowst;
                q.push(nowst);
            }
        }
    }
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin>>T;
    for(int j=1; j<=T; j++) {
        ans=0;
        cin>>z;
        for(int i=1; i<=z; i++) {//输入
            cin>>zb[i].x>>zb[i].y>>zb[i].m;
        }
        solve();
        cout<<"Case #"<<j<<": "<<ans<<'\n';
    }
    return 0;
}
//完结撒花！！！
```

---


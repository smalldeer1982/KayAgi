# 十字绣

## 题目背景

考古学家发现了一块布，布上做有针线活，叫做“十字绣”，即交替地在布的两面穿线。


## 题目描述

布是一个 $n\times m$ 的网格，线只能在网格的顶点处才能从布的一面穿到另一面。每一段线都覆盖一个单位网格的两条对角线之一，而在绣的过程中，一针中连续的两段线必须分处布的两面。给出布两面的图案（实线代表该处有线，虚线代表背面有线），问最少需要几针才能绣出来？一针是指针不离开布的一次绣花过程。

![](https://cdn.luogu.com.cn/upload/image_hosting/vftfilbf.png)


## 样例 #1

### 输入

```
4 5
.....
.\...
..\..
.....
.....
....\ 
.\X..
.....
```

### 输出

```
4
```

# 题解

## 作者：hzoi_liuchang (赞：10)

### 分析
一开始以为是一道DP题，后来发现状态不太好转移

后来看了题解才发现竟然是一道图论+$dfs$，确实不太好想

我们把格子上的点抽象成图中的节点，同时开一个数组记录它的入度

如果该点与正面的某一条线相连，我们就把它的入度加$1$

如果该点与反面的某一条线相连，我们就把它的入度减$1$

那么这一个点所需要的线的数量就是它的入度的绝对值

我们来举一个例子，如果一个点连着$3$个正面的线，又连着$2$个反面的线

那么$2$个正面的线就会和$2$个反面的线抵消，也就是转了一圈

而剩下的那一个正面的线必须另用一针

这样，对于每一个联通块，我们统计该联通块内所有节点的入度之和，最后把它除以二

因为一条线的起点和终点我们分别算了一遍

有一种特殊情况就是该联通块所有节点的入度之和为$0$
这说明一条线就可以解决，要特判一下

最后要注意字符\在判断的时候要写成\\\，或者用它的$ASCII$值$92$，否则会报错

### 代码
``` cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e6+5,maxk=205;
int head[maxn],tot=1,du[maxn],cnt,a[maxk][maxk],bb[maxn],ans,vis[maxn];
struct asd{
    int from,to,next;
}b[maxn];
void ad(int aa,int bb,int cc){
    b[tot].from=aa;
    b[tot].to=bb;
    b[tot].next=head[aa];
    head[aa]=tot++;
    if(cc==0) du[aa]++;
    else du[aa]--;
}
char s[maxk][maxk];
void dfs(int now){
    ans+=abs(du[now]);
    vis[now]=1;
    for(int i=head[now];i!=-1;i=b[i].next){
        int u=b[i].to;
        if(vis[u]==0){
            dfs(u);
        }
    }
}
int main(){
    memset(head,-1,sizeof(head));
    int n,m;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n+2;i++){
        for(int j=1;j<=m+2;j++){
            a[i][j]=++cnt;
        }
    }
    for(int i=1;i<=n;i++){
        scanf("%s",s[i]+1);
        for(int j=1;j<=m;j++){
		    if(s[i][j]=='\\'){
		        ad(a[i][j],a[i+1][j+1],0);
		        ad(a[i+1][j+1],a[i][j],0);
                bb[a[i][j]]=bb[a[i+1][j+1]]=1;
		    }
		    if(s[i][j]=='/'){
		        ad(a[i][j+1],a[i+1][j],0);
		        ad(a[i+1][j],a[i][j+1],0);
		        bb[a[i][j+1]]=bb[a[i+1][j]]=1;
		    }
		    if(s[i][j]=='X'){
			    ad(a[i][j+1],a[i+1][j],0);
			    ad(a[i][j],a[i+1][j+1],0);
			    ad(a[i+1][j],a[i][j+1],0);
			    ad(a[i+1][j+1],a[i][j],0);
			    bb[a[i][j]]=bb[a[i+1][j]]=bb[a[i+1][j+1]]=bb[a[i][j+1]]=1;
		    }
		}
    }
    for(int i=1;i<=n;i++){
        scanf("%s",s[i]+1);
        for(int j=1;j<=m;j++){
		    if(s[i][j]=='\\'){
		        ad(a[i][j],a[i+1][j+1],1);
		        ad(a[i+1][j+1],a[i][j],1);
                bb[a[i][j]]=bb[a[i+1][j+1]]=1;
		    }
		    if(s[i][j]=='/'){
		        ad(a[i][j+1],a[i+1][j],1);
		        ad(a[i+1][j],a[i][j+1],1);
		        bb[a[i][j+1]]=bb[a[i+1][j]]=1;
		    }
		    if(s[i][j]=='X'){
			    ad(a[i][j+1],a[i+1][j],1);
			    ad(a[i][j],a[i+1][j+1],1);
			    ad(a[i+1][j],a[i][j+1],1);
			    ad(a[i+1][j+1],a[i][j],1);
			    bb[a[i][j]]=bb[a[i+1][j]]=bb[a[i+1][j+1]]=bb[a[i][j+1]]=1;
		    }
		}
    }
    int mans=0;
    for(int i=1;i<=cnt;i++){
        if(bb[i] && !vis[i]){
            ans=0;
            dfs(i);
            if(ans==0) mans+=2;
            else mans+=ans;
        }
    }
    printf("%d\n",mans/2);
    return 0;
}
```

---

## 作者：Shawk (赞：6)

[可以在我的博客里看](https://www.cnblogs.com/Z8875/p/13261816.html)
- 题意

&emsp;&emsp;给出一个十字绣正反两面，一针中连续的俩段必须处于不同的面，求最少需要多少针可以缝出给出的十字绣。（多少针可以理解为多少根线）
-  解释一下样例：
1. 背面最右面的是一针
1. 背面左下的是一针
1. 和第二针挨着的是一针
1. 剩下三段线的可以一针穿过

- 分析

这道题给出很多段线，问最少的针数，容易想到要求联通块

要想一针穿成，肯定是在一个联通块中，但在一个联通块中却不一定是一针穿成。这怎么理解呢？

就是说一个点已经有了一条正面的线和一条反面的线，在来一条线的话就不能接这根线上了，需要另外一条新的线。那怎么求一个联通块最少用几条线呢？

我们这样想，一条线有两个端点（常识），如果一个点正面的线的段数等于反面的，那这里就没有端点。

这样，一个点的端点数就是在正面的线的段数与反面的差的绝对值，把一个联通块的所有点的这个绝对值加起来除以2就是这个联通块的结果了，要除以二就是因为前面提到了，一根线有两个端点，会算重。

还有一种情况，就是说整个联通块构成一个环，最后计算出来的s是0,但还是需要一根线，所以特判一下就好了。


求联通块的一般方法是并查集，但已经有大佬写了，我这里就分享一下DFS的写法。

- 需要注意以下几点 
1. 题目给出的$n\times m$是格子数，处理的时候是处理格点，格点总数为$\left ( n+1 \right ) \times \left ( m+1 \right )$.
1. 题目中表示左上到右下的'\'在C++语言中是转义字符，判断的时候写为'\\'才能表示'\'，不然会一直编译错误。

- 具体看代码注释（如果看不懂三目运算符可以看后面的注释，是等价的）
```cpp
#include <cmath>
#include <cstdio>
using namespace std;
const int N = 205;
struct side {
    int t, next;
}e[N*N<<3];
//存边数组要开8倍，考虑全是X的情况
int head[N*N], tot, f[N*N], face[N*N], rear[N*N];
void add(int x, int y, int z) {
    f[x] = 1;//标记是否有线
    e[++tot].next = head[x];
    head[x] = tot;
    e[tot].t = y;
    z == 1 ? face[x]++ : rear[x]++;
    /*f (z == 1) face[x]++;
    else rear[x]++;*/
    //记录正反面边的个数
    //1表示正面，-1表示反面
}
int n, m, h[N][N], v[N*N], s, ans;
char c[N];
void add1(int x, int y, int k) {//从右上到左下建边
    add(h[x][y+1], h[x+1][y], k);
    add(h[x+1][y], h[x][y+1], k);
}
void add2(int x, int y, int k) {//从左上到右下建边
    add(h[x][y], h[x+1][y+1], k);
    add(h[x+1][y+1], h[x][y], k);
}
void dfs(int x) {
    v[x] = 1;//标记已访问
    s += abs(face[x] - rear[x]);//计算端点数
    for (int i = head[x]; i; i = e[i].next) 
        if (!v[e[i].t]) dfs(e[i].t);
}
void init() {//初始化编号
    for (int i = 1; i <= n+1; i++)
        for (int j = 1; j <= m+1; j++)
            h[i][j] = (i-1) * (m+1) + j;
}
void read(int k) {
    for (int i = 1; i <= n; i++) {
        scanf("%s", c+1);
        for (int j = 1; j <= m; j++)
            if (c[j] == 'X') add1(i, j, k), add2(i, j, k);
            else if (c[j] == '/') add1(i, j, k);
            else if (c[j] == '\\') add2(i, j, k);
    }
}
int main() {
    scanf("%d%d", &n, &m);
    init();
    read(1);//读入正面
    read(-1);//读入背面
    for (int i = 1; i <= n+1; i++)
        for (int j = 1; j <= m+1; j++) {
            int x = h[i][j];
            if (!f[x] || v[x]) continue;
            s = 0;
            dfs(x);
            ans += s ? s >> 1 : 1;
            /*if (s != 0) ans += s >> 1;
            else ans++;*/
        }
    printf("%d\n", ans);
    return 0;
}
```


---

## 作者：幻星叶 (赞：4)

本题先用并查集来将所有针标记，然后在每个连通块中用每个点正针数与负针数差的绝对值的和算出每个连通块需要的针数。

    

    
```cpp
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
char s[3][201][201];
int father[50000],val[50000],b[50000],c[50000],vist[50000];
int a[300][300];
int num,sum,ans;
int n,m;
int find(int u)
{
    int f;
    if(father[u]==u)  return u;
    f=find(father[u]);
    father[u]=f;
    return father[u];
}
int main()
{
    int i,j,k,fi,fj;
    scanf("%d%d",&n,&m);
    for(i=1;i<=n;i++)
      scanf("%s",s[1][i]);
    for(i=1;i<=n;i++)
      scanf("%s",s[2][i]);
    for(k=1;k<=2;k++)
    for(i=1;i<=n;i++)
    for(j=0;j<m;j++)
    {
        if(s[k][i][j]=='/'||s[k][i][j]=='X') 
        {
           if(a[j+2][i]==0)
           {num++;father[num]=num;a[j+2][i]=num;}
           if(a[j+1][i+1]==0)
           {num++;father[num]=num;a[j+1][i+1]=num;}
           val[a[j+2][i]]+=2*k-3;
           val[a[j+1][i+1]]+=2*k-3;
           fi=find(a[j+2][i]);
           fj=find(a[j+1][i+1]);
           if(fi!=fj)  {father[fj]=fi;sum++;}
        }
        if(s[k][i][j]==92||s[k][i][j]=='X')
        {
            if(a[j+1][i]==0)
            {num++;father[num]=num;a[j+1][i]=num;}
            if(a[j+2][i+1]==0)
            {num++;father[num]=num;a[j+2][i+1]=num;}
            val[a[j+1][i]]+=2*k-3;
            val[a[j+2][i+1]]+=2*k-3;
            fi=find(a[j+1][i]);
            fj=find(a[j+2][i+1]);
            if(fi!=fj) {father[fj]=fi;sum++;}
        }
    }
    sum=0;
    for(i=1;i<=num;i++)
    {
        fi=find(i);
        if(vist[fi]==0)
        {sum++;c[sum]=fi;vist[fi]=1;}
        b[fi]=b[fi]+abs(val[i]);
    }
    ans=0;
    for(i=1;i<=sum;i++)
    {
        if(b[c[i]]==0)  b[c[i]]=1;
       ans=ans+(b[c[i]]+1)/2;
   }
    printf("%d",ans);
    return 0;
}

```

---

## 作者：Vocanda (赞：3)

## 分析
刚一看到这个题，第一个想法就是建好图，然后$Tarjan$求联通分量，但是这么做肯定是不对的。

我们分析一下，如果一个联通块里有两个正面的线，一个反面的线，那么我们能够推出来这个联通块需要两针才行。在建图的时候，我们把这个字符组成的一个个格子都变成一个点，每个点的标号不同，然后建边

从这个结论可以判断，每一个联通块里的点都有其相对应的最小针数，而这个最小针数就是正面的线和反面的线数量差的绝对值，因为每个边的两个点都会计算，所以最后统计出来的答案应该除以$2$。

应该注意的一点就是最后如果统计出来的答案是$0$，我们可以认为是环状，那么应该是有一针的，这里不用除以$2$，所以直接让$ans$加$2$即可

最后需要注意的就是'\\'这个符号，直接打出来肯定是不行的，我们可以把它直接放到最后直接$else$,也可以'\ \\'，还有用$ASCII$码，值为$92$来判断。
## 代码
```cpp


#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e5+10;
struct Node{
	int v,next;
}e[maxn<<4];
bool vis[maxn],b[maxn];
char s[205][205];
int n,m,a[550][550],z[maxn<<1],num;
int ans1,ans2,tot,head[maxn<<1];
void Add(int x,int y,int data){//建边，如果正面就让data为0，这个点的度++，反之则--，我们就在这里求出了答案所需要的绝对值
	if(data == 0)z[x]++;
	else z[x]--;
	e[++tot].v = y;
	e[tot].next = head[x];
	head[x] = tot;
}
void Dfs(int x){//深搜找每个联通块的针数
	vis[x] = 1;
	ans2+= abs(z[x]);
	for(int i=head[x];i;i=e[i].next){
		if(!vis[e[i].v])Dfs(e[i].v);
	}
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n+2;++i){
		for(int j=1;j<=m+2;++j){
			a[i][j] = ++num;
		}
	}
	for(int i=1;i<=n;++i){//正面的所有边
		cin>>s[i]+1;
		for(int j=1;j<=m;++j){//建边的时候正面的data也就是边权为0，便于判断
			if(s[i][j] == '\\'){//建边
				Add(a[i][j],a[i+1][j+1],0);
				Add(a[i+1][j+1],a[i][j],0);
				b[a[i][j]] = b[a[i+1][j+1]] = 1;//标记这里有线
			}
			if(s[i][j] == '/'){
				Add(a[i][j+1],a[i+1][j],0);
		    	        Add(a[i+1][j],a[i][j+1],0);
		   		b[a[i][j+1]]=b[a[i+1][j]]=1;//同上
			}
			if(s[i][j]=='X'){//X则对角建边
				Add(a[i][j+1],a[i+1][j],0);
				Add(a[i][j],a[i+1][j+1],0);
				Add(a[i+1][j],a[i][j+1],0);
				Add(a[i+1][j+1],a[i][j],0);
				b[a[i][j]]=b[a[i+1][j]]=b[a[i+1][j+1]]=b[a[i][j+1]]=1;
			}
		}
	}
	for(int i=1;i<=n;++i){//反面的建边，以下的细节同上
		cin>>s[i]+1;
		for(int j=1;j<=m;++j){
			if(s[i][j] == '\\'){
				Add(a[i][j],a[i+1][j+1],1);
				Add(a[i+1][j+1],a[i][j],1);
				b[a[i][j]] = b[a[i+1][j+1]] = 1;
			}
			if(s[i][j] == '/'){
				Add(a[i][j+1],a[i+1][j],1);
		    	Add(a[i+1][j],a[i][j+1],1);
		   		b[a[i][j+1]]=b[a[i+1][j]]=1;
			}
			if(s[i][j]=='X'){
				Add(a[i][j+1],a[i+1][j],1);
				Add(a[i][j],a[i+1][j+1],1);
				Add(a[i+1][j],a[i][j+1],1);
				Add(a[i+1][j+1],a[i][j],1);
				b[a[i][j]]=b[a[i+1][j]]=b[a[i+1][j+1]]=b[a[i][j+1]]=1;
			}
		}
	}
	
	for(int i=1;i<=num;++i){
		if(b[i] && !vis[i]){//当前点没有访问过且有线
			ans2=0;
			Dfs(i);//深搜求联通块的答案
			if(!ans2)ans1+=2;//联通块答案为0，也就是环，因为一会要除以2，所以直接加上2
			else ans1 += ans2;
		}
	}
	cout<<ans1/2<<"\n";
	
}

```

---

## 作者：jun头吉吉 (赞：2)

# P1524 【十字绣】

## 题意
布是一个$n\times m$的网格，线只能在网格的顶点处才能从一面穿到另一面。每一段线都覆盖一个单位网格的两条对角线之一，并且一针中连续的两段线必须分处布的两面。给出布两面的图案，问最少需要几针才能绣出来？
## 题解
~~比赛的时候T1是这题当场懵逼~~

其实本题并不难，只要认真思考还是很简单的~~这不妨碍我抱灵~~

首先考虑如何才能少线。考虑下面的图：

|一针|一针|一针|
|--|--|--|
|![](https://cdn.luogu.com.cn/upload/image_hosting/ywyxw4qj.png)|![](https://cdn.luogu.com.cn/upload/image_hosting/k8cakfwp.png)|![](https://cdn.luogu.com.cn/upload/image_hosting/si8z3ek5.png)|
第三个一针事实上可以看做是第一个、第二个一针的和减去在$\color{green}\text{绿点}$上的贡献得到的。于是我们似乎有了一点想法：

用$val_{i,j}$表示个点$(i,j)$被覆盖了几次，如果是正面的线就在两个端点个加$1$，否则就在两个端点个减$1$。

似乎想出了正解，~~但被无情的大样例hack了过去~~。问题出在哪里？

先把所有的线跑一遍并查集。一下在同一个集合里面讨论：

- 若$\sum |val|>0$则必定可以找到$\frac{\sum |val|}{2}$个端点开始，$\frac{\sum |val|}2$个端点结束，有$\frac{\sum |val|}{2}$条线。

- 若$\sum |val|=0$则所有的线构成了一个环，那么只需要一次

累计答案即可

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
template<const int maxn>
struct DSU{
    int fa[maxn];
    DSU(){for(int i=1;i<maxn;i++)fa[i]=i;}
    int getfa(int x){return fa[x]==x?x:fa[x]=getfa(fa[x]);}
    void merge(int x,int y){fa[getfa(x)]=getfa(y);}
};
#define sjy 200000
DSU<sjy>dsu;
int n,m;
char c[300][300][2];
#define P(x,y) ((x)-1)*(m+1)+(y)
int vis[sjy],val[sjy],val2[sjy];
bool is1(char c){return c=='\\'||c=='X';}
bool is2(char c){return c=='/'||c=='X';}
signed main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)cin>>c[i][j][0];
    for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)cin>>c[i][j][1];
    for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)for(int k=0;k<=1;k++){
        if(is1(c[i][j][k])){
            int x=P(i,j),y=P(i+1,j+1);
            dsu.merge(x,y);
            vis[x]=vis[y]=1;
            if(k)val[x]++,val[y]++;
            else val[x]--,val[y]--;
        }
        if(is2(c[i][j][k])){
            int x=P(i,j+1),y=P(i+1,j);
            dsu.merge(x,y);
            vis[x]=vis[y]=1;
            if(k)val[x]++,val[y]++;
            else val[x]--,val[y]--;
        }
    }
    for(int i=1;i<sjy;i++)
        if(vis[i])
            val2[dsu.getfa(i)]+=abs(val[i]);
    int res=0;
    for(int i=1;i<sjy;i++)
        if(vis[i]&&i==dsu.getfa(i))
            res+=val2[i]==0?1:val2[i]/2;
    cout<<res;
}
```

---

## 作者：OIer_ACMer (赞：1)

~~我觉得十字绣有必要要用代码实现吗？~~

------------
注：本题思路较为简单，所以笔者不会过多赘述原理以及证明，望周知！

------------
## 大致思路：
本题一看就不是个好做的题，由于问题是最少需要多少部才能够绣出图二中的图案。一开始想着是个 DP，但标签提示我这道题没那么好做，于是，我开始在图论上猛打草稿。

我们**把格子上的点抽象成图中的节点**，同时开一个数组记录它的度（无向图）。我们再把点的贡献定义为：**图中一个点通过相连的边得到的度数，也就相当于它贡献出的针数**。这时，就会有两种情况：

1. 如果**该点与正面的某一条线相连**，我们就把它的度加 $1$。

2. 如果**该点与反面的某一条线相连**，我们就把它的度减 $1$。

因为与该点相连的只有一条正面边和一条反面边，可以抵消掉一次针数，抵消一次贡献（相当于只是经过该点）。

最后统计一个连通块内所有点的 度数的绝对值（贡献），除以二就是这个连通块贡献的针数。同时，各位可能注意到了我的代码里将最后的 $ans$ 值除以了二。为什么要除以二？因为每一个点都记录的话**就会重复计数两次**（起点终点）。特别注意的是，如果计数完后连通块的贡献为 $0$，我们算它贡献的针数为 $1$，这样相当于这个连通块成环，也是需要一针（我就是卡在这个点上动弹不得）。

------------
## 代码如下：

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long
inline int read()
{
    register int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9')
    {
        if (ch == '-')
        {
            f = -1;
        }
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
    {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}
const int N = 210, M = 1000010, MM = N * N;
int INF = 0x3f3f3f3f, mod = 100003;
int LNF = 0x3f3f3f3f3f3f3f3f;
int n, m, k, T, S, D;
string s[N];
int a[N][N];
int head[MM], cnt;
int d[MM];
bool st[MM], bb[MM];
struct node
{
    int to, next;
    /* data */
} edge[M];
void add(int a, int b, int t)
{
    edge[cnt].to = b;
    edge[cnt].next = head[a];
    head[a] = cnt++;
    bb[a] = true;
    if (t == 1)
    {
        d[a]++;
    }
    else
    {
        d[a]--;
    }
}
void build(int t)
{
    for (int i = 0; i < n; i++)
    {
        cin >> s[i];
        for (int j = 0; j < m; j++)
        {
            int ru = a[i][j + 1], ld = a[i + 1][j], lu = a[i][j], rd = a[i + 1][j + 1];
            if (s[i][j] == '/')
            {
                add(ru, ld, t);
                add(ld, ru, t);
            }
            else if (s[i][j] == '\\')
            {
                add(lu, rd, t);
                add(rd, lu, t);
            }
            else if (s[i][j] == 'X')
            {
                add(ru, ld, t);
                add(ld, ru, t);
                add(lu, rd, t);
                add(rd, lu, t);
            }
        }
    }
}

int dfs(int x)
{
    st[x] = true;
    int cnt = abs(d[x]);
    for (int i = head[x]; ~i; i = edge[i].next)
    {
        int j = edge[i].to;
        if (st[j])
        {
            continue;
        }
        cnt += dfs(j);
    }
    return cnt;
}
signed main()
{
    n = read();
    m = read();
    for (int i = 0, k = 0; i <= n; i++)
    {
        for (int j = 0; j <= m; j++, k++)
        {
            a[i][j] = k;
        }
    }

    memset(head, -1, sizeof(head));
    build(1);
    build(-1);
    int ans = 0;
    for (int i = 0; i < (n + 1) * (m + 1); i++)
    {
        if (bb[i] && !st[i])
        {
            int t = dfs(i);
            if (!t)
            {
                ans += 2;
            }
            else
            {
                ans += t;
            }
        }
    }

    cout << ans / 2;

    return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/122857825)

---

## 作者：louhao088 (赞：1)

模拟赛上没打出来，看了大佬的代码受益匪浅，来发一篇题解


------------


## 思路

首先我们要把每个符号转化成两个点相连，建正边反边，用并查集连起来

```cpp
void gett(int i,int i1,int j,int j1,int k)//连起来
{
	int x=id(i,i1),y=id(j,j1);
	f[getf(x)]=getf(y);
	if(k==2)s[x]--,s[y]--;
	else s[x]++,s[y]++;
	vis[x]=vis[y]=1;
}
void add(int i,int j)//每个点与那个点连
{
	if(i<=n)
	{
		if(a[i][j]=='\\'||a[i][j]=='X')gett(i,j,i+1,j+1,1);
		if(a[i][j]=='/'||a[i][j]=='X')gett(i,j+1,i+1,j,1);
	}
	else if(i>n)
	{
		if(a[i][j]=='\\'||a[i][j]=='X')gett(i-n,j,i-n+1,j+1,2);
		if(a[i][j]=='/'||a[i][j]=='X')gett(i-n,j+1,i+1-n,j,2);
	}
}
```

------------

在每个连通块中，把每个点的路度差的绝对值加起来，在除以2。

注意 当路度和为0时，要用一针

```cpp
  for(int i=1;i<=nn*mm*2;i++)//算每个和
      if(vis[i])x=getf(i),flag[x]=1,sum[x]+=abs(s[i]);
  for(int i=1;i<=nn*mm*2;i++)//总和
      if(flag[i]==1)ans+=max(1,abs(sum[i])/2);
```



------------
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,nn,mm,s[1000005],cnt=0,f[1000005],tot=0,d[1000005],sum[1000005],ans=0,x;
bool vis[1000005],flag[1000005];
char a[1005][1005],ch;
int id(int x,int y)
{
	return (x-1)*mm+y;
}
int getf(int x)
{
	if(f[x]==x)return x;
	else return f[x]=getf(f[x]);
}
void gett(int i,int i1,int j,int j1,int k)
{
	int x=id(i,i1),y=id(j,j1);
	f[getf(x)]=getf(y);
	if(k==2)s[x]--,s[y]--;
	else s[x]++,s[y]++;
	vis[x]=vis[y]=1;
}
void add(int i,int j)
{
	if(i<=n)
	{
		if(a[i][j]=='\\'||a[i][j]=='X')gett(i,j,i+1,j+1,1);
		if(a[i][j]=='/'||a[i][j]=='X')gett(i,j+1,i+1,j,1);
	}
	else if(i>n)
	{
		if(a[i][j]=='\\'||a[i][j]=='X')gett(i-n,j,i-n+1,j+1,2);
		if(a[i][j]=='/'||a[i][j]=='X')gett(i-n,j+1,i+1-n,j,2);
	}
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n*2;i++)
		scanf("%s",a[i]+1);nn=n+1,mm=m+1;
	for(int i=1;i<=nn*mm*2;i++)f[i]=i;
	for(int i=1;i<=2*n;i++)
		for(int j=1;j<=m;j++)add(i,j); 
	for(int i=1;i<=nn*mm*2;i++)
		if(vis[i])x=getf(i),flag[x]=1,sum[x]+=abs(s[i]);
	for(int i=1;i<=nn*mm*2;i++)
		if(flag[i]==1)ans+=max(1,abs(sum[i])/2);
	cout<<ans;
	return 0;
}
```
















---

## 作者：ROY1994 (赞：1)

我们可以知道每个联通块是互不影响的，可以用并查集维护每个联通块

设每个联通块需要的针数为 $k$，

当 $k=0$ 时，实际针数为 $1$ （显然）

当 $k\neq 0$ 时，针数为 以每个点为起点的|正面针数-背面针数|，
由于每个点被访问两次，这种情况 $k$ 要除2

然后我们累加每个联通块的k，输出答案就好了

还要注意把边图转化成点图
```cpp
#include <bits/stdc++.h>
using namespace std;
int fa[900005];
inline int find(int x)
{
    while(x!=fa[x]) x=fa[x]=fa[fa[x]];
    return x;
}
inline int Abs(int x)
{
    return x<0?-x:x;
}
int n,m,tot;
int vis[800005],visblo[800005],ned[800005],sum[800005],blo[800005];
char mp[2][205][205];
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=0;i<n;i++)
        scanf("%s",mp[0][i]);
    for(int i=0;i<n;i++)
        scanf("%s",mp[1][i]);
    for(int i=0;i<(n+1)*(m+1);i++) fa[i]=i;
    for(int t=0;t<=1;t++)
    {
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<m;j++)
            {
                if(mp[t][i][j]=='\\'||mp[t][i][j]=='X')
                {
                    int x=i*(m+1)+j,y=(i+1)*(m+1)+j+1;
                    int fx=find(x),fy=find(y);
                    if(fx!=fy) fa[fx]=fy;
                    if(fx!=fy) fa[fx]=fy;
                    ned[x]+=-t*2+1; 
                    ned[y]+=-t*2+1;
                    vis[x]=vis[y]=1;
                }
                if(mp[t][i][j]=='/'||mp[t][i][j]=='X')
                {
                    int x=(i+1)*(m+1)+j,y=i*(m+1)+j+1;
                    int fx=find(x),fy=find(y);
                    if(fx!=fy) fa[fx]=fy;
                    ned[x]+=-t*2+1;
                    ned[y]+=-t*2+1;
                    vis[x]=vis[y]=1;
                }
            }
        }
    }
    int fi;
    for(int i=0;i<(n+1)*(m+1);i++)
    {
        if(!vis[i]) continue;
        fi=find(i);
        if(!visblo[fi]) visblo[fi]=1,blo[++tot]=fi;
        sum[fi]+=Abs(ned[i]);
    }
    int ans=0;
    for(int i=1;i<=tot;i++)
    {
        if(!sum[blo[i]]) ans++;
        else ans+=sum[blo[i]]/2;
    }
    printf("%d",ans);
}
```
~~话说我把fa初始成1卡了好久~~

---


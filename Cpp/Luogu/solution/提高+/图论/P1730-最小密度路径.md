# 最小密度路径

## 题目描述

给出一张有 $N$ 个点 $M$ 条边的加权有向无环图，接下来有 $Q$ 个询问，每个询问包括 $2$ 个节点 $X$ 和 $Y$，要求算出从 $X$ 到 $Y$ 的一条路径，使得密度最小（密度的定义为，路径上边的权值和除以边的数量）。


## 说明/提示

$1 \le N \le 50$，$1 \le M \le 1000$，$1\le W \le 10^5$，$1 \le Q \le 10^5$


## 样例 #1

### 输入

```
3 3
1 3 5
2 1 6
2 3 6
2
1 3
2 3
```

### 输出

```
5.000
5.500
```

# 题解

## 作者：似水年华 (赞：21)

#问题简述

给一个有向无环图，求任两点间距离除以边数的最小值。

#算法分析

考虑转化成我们熟悉的问题解决。

由于都是求最小，很容易想到和此题类似的一个问题，求任两点间的最短路，能否借鉴Floyd算法来解决呢？

本题不同点在于，还要除以一个边数。因为这个除法的缘故，使得Floyd算法的最优子结构性质被破坏，假设存在路径i -> k -> j，它的最小密度路径并不一定是i -> k的最小密度路径加上k -> j的最小密度路径。

例：设[A, B]表示路径的权值和为A，通过了B条边。假设从i -> k存在着两条路径L1[2, 3]以及L2[8, 10]，从k -> j存在着两条路径L3[1, 2]以及L4[51, 100]，很明显i -> k的最小密度路径是L1，k -> j的最小密度路径是L3，但是i -> k -> j的最小密度路径却是L1 + L4。

有否办法去掉这个除法的影响？

回到问题特性，是有向无环图，一条路径最多只能经过N-1条边，于是我们可以对边数进行枚举，即把答案的分母枚举了，剩下的就是让答案的分子最小化（答案是 权值和/边数），这就回到我们熟悉的问题：求最短。

在Floyd的基础上重新划分阶段定义状态：

第k个阶段表示恰好通过k条边两点间的最短路，这样的话最优子结构以及无后效性都满足（k的阶段的最优取值一定需要靠之前阶段的最优值，当然也不可能影响到之前阶段的取值了。）

定义状态f(i,j,k)表示从i到j恰好经过k条边的最短路，类似Floyd的算法得出DP方程：

 f(i,j,k)=Min{f(i,h,g)+f(h,j,k-g)}。 

这个方程是5维的，会超时，如何减小维数呢？

考虑在何处重复决策。注意到f（i,j,k）的选择路径V1－V2－...－Vk，实际上我们只要找到这里的一个点决策即可，而不需每个点都判断过去。这样就很容易想到在最后一个点进行决策。

f(i,j,k)=Min{f(i,h,k-1)+f(h,j,1)}。 

#参考程序

```cpp
#include<stdio.h>
using namespace std;
#define INF 1000000000
int n,m,q;
int dis[60][60][1010];
int main()
{
    int i,j,k,l;
    scanf("%d %d",&n,&m);//读入 
    for(l=1;l<=m;l++)
        for(i=1;i<=n;i++)
            for(j=1;j<=n;j++)
                dis[i][j][l]=INF;//初始化 
    for(i=1;i<=m;i++)
    {
        long long a,b,w;
        scanf("%lld %lld %lld",&a,&b,&w);
        if(dis[a][b][1]>w)
            dis[a][b][1]=w;//注意有重边的情况 
    }
    for(l=2;l<=m;l++)
        for(k=1;k<=n;k++)
            for(i=1;i<=n;i++)
                for(j=1;j<=n;j++)
                    if(dis[i][j][l]>dis[i][k][l-1]+dis[k][j][1])
                        dis[i][j][l]=dis[i][k][l-1]+dis[k][j][1];//类似Floyd算法的DP 
    scanf("%d",&q);
    while(q--)
    {
        int x,y;
        double ans=INF,min=INF;
        scanf("%d %d",&x,&y);//读入询问 
        for(l=1;l<=n;l++)
        {
            if(dis[x][y][l]<INF)
                ans=double(dis[x][y][l])/double(l);
            if(ans<min)
                min=ans;
        }//对边数进行枚举,算权值和/边数 
        if(min==INF)
            printf("OMG!\n");
        else
            printf("%.3lf\n",min);//输出 
    }
}
```

---

## 作者：creed_ (赞：12)

提供一种n^2*m*logn的做法

首先，很显然，答案是可以预处理的，开个二维数组ans，查询时直接输出就可以。

我们要求的是个分式对吧，即 Σwi/k （1<=i<=k), i是这条路径上的边，k是边数，可以
设答案为x

**接下来是重点**

对等式进行变形

                    x=Σwi/k
 
                    x*k=Σwi
                    
                    Σwi-x*k=0
                    
对于每一个确定的x，选择一条边的代价为wi-x。

如果可以找到一条路径使Σwi-x*k<0，则说明

                    Σwi<x*k
                    
                    Σwi/k<x
说明存在一种方案得到一条密度比x更小的路径，x还可以更小。

否则则说明无法得到密度为x的路径，x需要大一些。

很显然这个x是具有单调性的，可以二分答案求解。

贴上代码

```cpp

#include<iostream>
#include<cctype>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<queue>
#define N 1100
#define M 110000
#define inf 1e9+7
#define eps 0.000001
#define ll long long
using namespace std;
inline ll read()
{
    ll x=0,flag=1;
    char ch=0;
    while(!isdigit(ch)){ch=getchar();if(ch=='-')flag=-1;}
    while(isdigit(ch)) {x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
    return x*flag;
}
struct edge
{
    ll to;
    ll next;
    long double w;
}e[M*2];
ll num,head[N];
inline void add(ll x,ll y,long double z)
{
    num++;
    e[num].to=y;
    e[num].next=head[x];
    e[num].w=z;
    head[x]=num;
}
queue<ll>q;
long double dis[N],ans[N][N];
bool in_queue[N];
ll n,m;
void spfa(ll s,long double mid)
{
    for(ll i=1;i<=n;i++)
    dis[i]=inf;
    dis[s]=0;
    q.push(s);
    in_queue[s]=true;
    while(!q.empty())
    {
        ll x=q.front();
        //cout<<x<<" "<<dis[x]<<endl;
        q.pop();
        in_queue[x]=false;
        for(ll i=head[x];i;i=e[i].next)
        {
            ll to=e[i].to;
            if(dis[to]>dis[x]+e[i].w-mid)
            {
                dis[to]=dis[x]+e[i].w-mid;
                if(!in_queue[to])
                {
                    in_queue[to]=true;
                    q.push(to);
                }
            }
        }
    }
    return;
}
int main()
{
    ll i,j,x,y,z;
    n=read();
    m=read();
    for(i=1;i<=m;i++)
    {
        x=read();
        y=read();
        z=read();
        add(x,y,(long double)z);
    }
    for(i=1;i<=n;i++)
    {
        for(j=1;j<=n;j++)
        if(i!=j)
        {
        	spfa(i,0);//判断一下是否能到达
        	if(dis[j]==inf)
        	{
        		ans[i][j]=-1;
        		continue;
        	}
        	long double l=eps,r=inf;
            while(true)
            {
            	long double mid=(l+r)/(2.0);
                spfa(i,mid);
                if(dis[j]<0)
                {
                	r=mid+eps;
                }
                else
                {
                	l=mid-eps;
                }
                if(abs(r-l)<=eps*10)
                {
                	ans[i][j]=l;
                	break;
                }
            }
        }
    }
    ll qnum=read();
    for(i=1;i<=qnum;i++)
    {
        x=read();
        y=read();
        if(ans[x][y]>=0)
        printf("%.3Lf\n",ans[x][y]);
        else
        printf("OMG!\n");
    }
    return 0;
}
```

---

## 作者：fmx0219 (赞：12)

# 题目描述

给出一张有N个点M条边的加权有向无环图，接下来有Q个询问，每个询问包括2个节点X和Y，要求算出从X到Y的一条路径，使得密度最小（密度的定义为，路径上边的权值和除以边的数量）。
1 ≤ N ≤ 50，1 ≤ M ≤ 1000，1 ≤ W ≤ 100000，1 ≤ Q ≤ 100000
# 题目分析

首先看数据范围，我们发现n的值很小，那我们就可以直接dfs爆搜，时间复杂度为O（n^2）;
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int q;
struct node
{
	int ver;
	int next;
	int val;
}e[100004];
int h[10005],cnt=0;
double dis[55][55];//dis[x][y]表示从x到y的最小密度; 
void add(int u,int v,int w)
{
	e[++cnt].ver=v;
	e[cnt].val=w;
	e[cnt].next=h[u]; 
	h[u]=cnt;
}
void dfs(int x,double c,double t,int k)//c为权值，t为走过的边数; 
{
	dis[k][x]=min(dis[k][x],c/t);
	for(int i=h[x];i;i=e[i].next)
	{
		int y=e[i].ver;
		dfs(y,c+e[i].val,t+1,k);
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){int x,y,z;scanf("%d%d%d",&x,&y,&z);add(x,y,z);}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			dis[i][j]=5000000.000;//赋初值; 
		}
		dis[i][i]=0;//自己到自己的距离为0; 
	}
	for(int i=1;i<=n;i++)
	{
		dfs(i,0,0,i);
	}
	scanf("%d",&q);
	while(q--)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		if(dis[x][y]==5000000.000) printf("OMG!\n");//如果dis[x][y]仍等于初值，则表示x与y不连通; 
		else printf("%.3lf\n",dis[x][y]);
	}
}
```


---

## 作者：MuYC (赞：4)

#### 前言

看数据范围猜算法：$Floyd$

#### 思路

首先，看到点数只有50，果断邻接表啊。

然后我们明确一点：$Floyd$算法的本质其实就是$dp$

今天早上看到的一个帖子：[$Floyd$算法是经滚蛋数组优化的$dp$](https://www.luogu.com.cn/discuss/show/279108)

(因为楼主打错字笑了我好久)

给的点数比较少，但是询问特别多。看样子就可以预处理一下。

看题目的定义：“最小密度路径”是指　路径上边的权值和除以边的数量

不妨定义$DP$状态：$DP[i][j][cnt]$表示点$i$到点$j$经过$cnt$ 条边的最短路径。

怎么转移？这时候就可以上$Floyd$了。

$Floyd$ 有三重循环，第一二重是枚举两个要计算最短路径的点，第三重是枚举中转点。那么我们在这个题目的转移中就可以用到这个中转点来转移状态。

$DP[i][j][cnt_1] = DP[i][k][cnt_2] + DP[k][j][cnt_1-cnt_2]$

为什么这么转移呢？

根据$DP$中状态的设立感性理解一下:

$DP[i][j][cnt_1]$是指$i$到$j$要经过$cnt_1$条边。

$DP[i][k][cnt_2]$就是$i$到$k$经过$cnt_2$条边。

因为$i$到$j$规定了要走$cnt_1$条边，那么剩下的$k$到$j$就只能走$cnt_1 - cnt_2$条边了。

于是这样转移是可行的。

但是时间上貌似炸了。

仔细算一算你会发现时间复杂度是:O($n^3$ * $m^2$)

显然过不了$n <= 50$,$m<= 1000$的数据范围。

抱着好奇的心理我交了一发暴力：

$80pts$。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int MAXN = 52,MAXM = 1005,INF = 1000000000000000;

int dis[MAXN][MAXN][MAXM];
double Min[MAXN][MAXN];
int n , m;

signed main()
{
	cin >> n >> m;
	for(int i = 1 ; i <= m ; i ++)
	{
		int u,v,t;
		cin >> u >> v >> t;
		if(dis[u][v][1] != 0)
			dis[u][v][1] = min(t,dis[u][v][1]);
		else dis[u][v][1] = t;
	}
	for(int i = 1 ; i <= n ; i ++)
	{
		for(int j = 1 ; j <= n ; j ++)
			for(int k = 1 ; k <= m ; k ++)
		if(dis[i][j][k] == 0)
		dis[i][j][k] = INF;
	}
	for(int w = 2 ; w <= m ; w ++)
		for(int i = 1 ; i <= n ; i ++)
		{
			for(int j = 1 ; j <= n ; j ++)
				for(int k = 1 ; k <= n ; k ++)
					for(int z = 1 ; z < w ; z ++)
			dis[i][j][w] = min(dis[i][j][w],dis[i][k][z]+dis[k][j][w - z]);
		}
	for(int i = 1 ; i <= n ; i ++)
	{
		for(int j = 1 ; j <= n ; j ++)
		{
			Min[i][j] = (double) INF;
			for(int w = 1 ; w <= m ; w ++)
			if(dis[i][j][w] != INF)
			Min[i][j] = min(Min[i][j],double(dis[i][j][w]) / double(w));
		}
	}
	int Q;
	cin >> Q;
	for(int i = 1 ; i <= Q ; i ++)
	{
		int u,v;
		cin >> u >> v;
		if(Min[u][v] <= 1e13 && u != v)
		printf("%.3lf\n",Min[u][v]);
		else cout <<"OMG!\n";
	}
	return 0;
}
```

考虑如何优化。

根据我们的算法，$i$到$j$经过$cnt_1$条边的路径上，会不止有一个点，那么我们想到，因为我们枚举了所有的$k$，我们总会枚举到一个点是直接与$j$相邻的。

打个比方（这是$i$到$j$的路径抽象版）:

$i$ -----> $a$ -----> $b$ -----> ... -----> $t$ ----- >$j$

我们在枚举所有中转点的时候肯定会枚举到$t$，那么因为这条路径一共经过的了$cnt_1$条边，那么$i$ 到 $t$就经过了 $cnt_1 - 1$　条边，$t$到$j$就是一条边。

那么我们想到，实际上更新状态的时候没必要枚举方程中的$cnt_2$，只需要将$cnt_2$设置为$1$(或者是小于$cnt_1$，大于0的任何数)

这样子我们就可以减少一层枚举$cnt_2$的复杂度了。时间复杂度降到了O$(n^3m)$。

计算完了$DP[i][j][k]$根据定义记得预处理算一算$i$ 到$j$的最小密度路径保存起来，那么就可以O$(1)$回答询问了。


就可以过掉这一题了:

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int MAXN = 52,MAXM = 1005,INF = 1000000000000000;

int dis[MAXN][MAXN][MAXM];
double Min[MAXN][MAXN];
int n , m;

signed main()
{
	cin >> n >> m;
	for(int i = 1 ; i <= m ; i ++)
	{
		int u,v,t;
		cin >> u >> v >> t;
		if(dis[u][v][1] != 0)
			dis[u][v][1] = min(t,dis[u][v][1]);
		else dis[u][v][1] = t;//一开始经过一条路径的最短路要计算，相当于dp边界
	}
	for(int i = 1 ; i <= n ; i ++)
	{
		for(int j = 1 ; j <= n ; j ++)
			for(int k = 1 ; k <= m ; k ++)
		if(dis[i][j][k] == 0)
		dis[i][j][k] = INF;
	}
	for(int w = 2 ; w <= m ; w ++)
		for(int i = 1 ; i <= n ; i ++)
		{
			for(int j = 1 ; j <= n ; j ++)
				for(int k = 1 ; k <= n ; k ++)
			dis[i][j][w] = min(dis[i][j][w],dis[i][k][w - 1]+dis[k][j][1]);
		}
	for(int i = 1 ; i <= n ; i ++)
	{
		for(int j = 1 ; j <= n ; j ++)
		{
			Min[i][j] = (double) INF;
			for(int w = 1 ; w <= m ; w ++)
			if(dis[i][j][w] != INF)
			Min[i][j] = min(Min[i][j],double(dis[i][j][w]) / double(w));
		}//计算"最小密度"路径
	}
	int Q;
	cin >> Q;
	for(int i = 1 ; i <= Q ; i ++)
	{
		int u,v;
		cin >> u >> v;
		if(Min[u][v] <= 1e13 && u != v)
		printf("%.3lf\n",Min[u][v]);
		else cout <<"OMG!\n";//如果最短路径无穷大就表示无解
	}
	return 0;
}
```

---

## 作者：_zy_ (赞：3)

## [题目传送门](https://www.luogu.com.cn/problem/P1730)

~~目前是最优解。~~

题目大意：

求 $DAG$ 任两点间距离除以边数的最小值。

~~奇怪的DP??~~

不难发现，只需要处理出所有 $i$ 到 $ j$ 的 $k$ 条路径的距离最小和，就可以很轻松的求出来最小密度。

考虑暴力：

定义 $Dp_{[i,j,k]}$ 为示点 $i$  到点 $j$ 经过 $ k$ 条边的最短路径。

状态转移->类似 Floyd. 

$Dp_{[i,j,k]}=Dp_{[i,tot,k_1]}+Dp_{[tot,j,k-k_1]}$

--------

既然在图上为什么不跑一个 Toposort 呢？

既然在拓扑序中为什么不跑一个 Dp 呢？

定义 $dis_{i,j}$ 为从 $u$ 节点到  $i$ 节点走 $j$ 条路径的最短距离。

对于每一个节点 $i$ ，都可以有:

$dis_{v,j}=min(dis_{v,j},dis_{u,j-1})$

-  **Initialization**

对于节点 $i$ 为起点，处理出能到达的点和入度。
```cpp
void Init(int x)
{
	for(int i=fir[x];i;i=nex[i]) {
		int p=poi[i];
		in[p]++;
		if(v[p])	continue;
		v[p]=1;
		Init(p);
	}
}
```

-  **Toposort**

枚举每个节点 $i$ 作为起点，拓扑处理，枚举 $j$ 条路径状态转移。

最后如果可以跑到的话，将最短路转化为最小密度。

```cpp
void Toposort(int x)
{
	Clear(); Init(x);
	queue<int > q;
	q.push(x); dis[x][0]=0;
	while(!q.empty())
	{
		int now=q.front();
		q.pop();
		for(int i=fir[now];i;i=nex[i])
		{
			int p=poi[i];
			for(int j=1;j<=n;j++)
				dis[p][j]=min(dis[p][j],dis[now][j-1]+val[i]);
			in[p]--;
			if(!in[p])	q.push(p);
		}
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			if(v[i])	f[x][i]=min(f[x][i],dis[i][j]/j);
}

//

for(int i=1;i<=n;i++)
		Toposort(i);
```
关于 $OMG$ ：

很显然，当最短密度没有更新时，两点就不连通。

时间复杂度：
不到 $\mathcal{O_{n^3}}$


**代码如下:**
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<queue>
#include<map>
#define N 1010 
#define INF 2147483647
using namespace std;
int re() {
	int p=0,f=1; char i=getchar();
	while(i<'0'||i>'9')	{if(i=='-')  f=-1;i=getchar();}
	while(i>='0'&&i<='9')	p=p*10+i-'0',i=getchar();
	return f*p;
}
int n,m,u,sum,cnt,T;
int fir[N],poi[N],nex[N],val[N],in[N];
double dis[60][60],f[60][60];
bool v[N];
void ins(int x,int y,int z) {
	nex[++sum]=fir[x];
	poi[sum]=y;
	val[sum]=z;
	fir[x]=sum;
}
void Clear() {
	memset(v,0,sizeof(v));
	memset(in,0,sizeof(in));
	memset(dis,0x7f,sizeof(dis));
}
void Init(int x)
{
	for(int i=fir[x];i;i=nex[i]) {
		int p=poi[i];
		in[p]++;
		if(v[p])	continue;
		v[p]=1;
		Init(p);
	}
}
void Toposort(int x)
{
	Clear(); Init(x);
	queue<int > q;
	q.push(x); dis[x][0]=0;
	while(!q.empty())
	{
		int now=q.front();
		q.pop();
		for(int i=fir[now];i;i=nex[i])
		{
			int p=poi[i];
			for(int j=1;j<=n;j++)
				dis[p][j]=min(dis[p][j],dis[now][j-1]+val[i]);
			in[p]--;
			if(!in[p])	q.push(p);
		}
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			if(v[i])	f[x][i]=min(f[x][i],dis[i][j]/j);
}
int main()
{
	n=re(); m=re(); 	
	memset(f,0x7f,sizeof(f));
	for(int i=1;i<=m;i++) {
		int a,b,c;
		a=re(); b=re(); c=re();
		ins(a,b,c);
	}
	for(int i=1;i<=n;i++)
		Toposort(i);
	T=re();
	while(T--)
	{
		int a,b;
		a=re(); b=re();
		if(f[a][b]==f[a][0]) printf("OMG!\n");
		else printf("%.3lf\n",f[a][b]);
	}
}
```
**如有不妥，请不要吝啬您的评论!**





---

## 作者：CodyTheWolf (赞：1)

提供一个$O(n^2m)$的做法

------------

首先是数据范围，这个$10^5$的询问可本质上只有$n^2$~~是什么迷惑操作~~，因此可以预处理出每个点对直接的答案就可以了。

和最短路径不同，最小密度路径需要考虑到路径的长度以及**边的数量**。因为数量的关系，导致我们没办法像最短路那样，用**三角不等式**优化当前点和下一点的距离。

（比如，本来两点间的距离从2变为3，但是边的数量从1变成了2，有可能对**最后的最小密度路径**有促进作用，也可能会没有，所以无法从现在断定）

不过因为本题的$n$太小，而且图是DAG（有向无环图），**一条路径最长只能为$n$** （因为没有环）。我们可以枚举路径的，这样只要保证**边数量相同**的情况下，**长度最小**就可以了。


------------

我们为了方便，枚举每个点为起点（设为$s$），然后求这个点对每个点的最小密度路径。

我们刚刚说了讨论边数量相同的情况，那我们就设一个状态$dp(i,j)$表示起点$s$到$i$点，经过$j$条边**长度最短**的路径。

满足转移方程（设某条边的另一点为$v$,长度为$w$）
$dp(v,j+1)=min(dp(v,j+1),dp(i,j)+w)$

这就变成了DAG上的DP，很显然我们需要用拓扑排序的顺序转移，才能满足无后效性。

这里有一个注意点：拓扑排序的入度并不是**原图的入度**，而是点$s$**能到达的点**的最大子图的入度。换句话说，只有$s$能到达的边，才能给下一个点的入度+1。

（因为不能到达的边和点在对$s$讨论时根本没用，如果算上这些边会导致拓扑排序不能进行彻底）

使用一个从$s$开始的DFS，不访问重复的点即可统计入度（详情见代码）

最后对于答案$ans(s,i)$表示$s$到$i$的最小密度路径，只需要枚举$min(dp(i,j)/j),j∈[1,n]$ 即可

以及注意两点不连通时~~让我失去1A的~~“OMG!"

------------

枚举每个点需要$n$次。

对于一个点：

- $n$次的DFS
- $m$次的入队出队（拓扑排序）
- - 每次DP的转移需要$n$次

复杂度是$n*(n+m * n)$的，也就是$O(n^2m)$


------------

```cpp
#include <iostream>
#include <cstring>
#include <queue>
#include <iomanip>
using namespace std;
constexpr size_t MAXN = 55, MAXM = 1e3 + 5;
int head[MAXM], nxt[MAXM], v[MAXM], w[MAXM], cnt;
double ans[MAXN][MAXN];
int n, m, q;

inline void Addline(int x, int y, int z) { v[cnt] = y, w[cnt] = z, nxt[cnt] = head[x], head[x] = cnt++; }

inline void DFS(int x, int* ind, int* vis)
{
	for (int i = head[x]; ~i; i = nxt[i])
	{
		ind[v[i]]++;
		if (!vis[v[i]]) vis[v[i]] = true, DFS(v[i], ind, vis);
	}
}

inline void TopSort(int s)
{
	int ind[MAXN], vis[MAXN], dp[MAXN][MAXN];
	memset(ind, 0, sizeof ind), memset(vis, 0, sizeof vis);
	DFS(s, ind, vis);
	queue<int> Q; Q.push(s);
	memset(dp, 0x7f, sizeof dp), dp[s][0] = 0;
	while (!Q.empty())
	{
		int x = Q.front(); Q.pop();
		for (int i = head[x]; ~i; i = nxt[i])
		{
			for (int j = 0; j < n; j++)
				dp[v[i]][j + 1] = min(dp[v[i]][j + 1], dp[x][j] + w[i]);
			if (!--ind[v[i]]) Q.push(v[i]);
		}
	}
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
			ans[s][i] = min(ans[s][i], vis[i] ? (double)dp[i][j] / j : ans[s][i]);
}

signed main(void)
{
	ios::sync_with_stdio(false), cin.tie(0);
	memset(head, -1, sizeof head), memset(ans, 0x7f, sizeof ans);
	cin >> n >> m;
	for (int i = 1, x, y, z; i <= m; i++)
	{
		cin >> x >> y >> z;
		Addline(x, y, z);
	}
	for (int i = 1; i <= n; i++) TopSort(i);
	cin >> q;
	for (int i = 1, x, y; i <= q; i++)
	{
		cin >> x >> y;
		if (ans[x][y] != ans[0][0])
			cout << setiosflags(ios::fixed) << setprecision(3) << ans[x][y] << '\n';
		else
			cout << "OMG!\n";
	}
	return 0;
}
```




---

## 作者：command_block (赞：1)

最近$01$分数规划的题目做多了，看到这题下意识码了$SPFA+$二分，才看到$DAG$。

$SPFA+$二分也可以做这道题嘛。

这道题询问$10^5$然而本质不同的只有$n^2$个。

所以把询问打个表，最后查表输出。

从大佬那里听来，$DAG$上$SPFA$好像只能卡到$max(N^2,kM)$(~~错了别喷~~),所以直接大力$SPFA+01$分数规划做$N^2$次,复杂度也就$O(n^4log(?))$,还是可以过的。

$01$分数规划什么的还是老套路。

考虑对于询问$(from,to)$,显然可以二分答案(具有单调性)。

猜测答案为$limit$,则$limit$小于等于任何的可行解。

$\sum{W[i]}/\text{边数}>=limit$

$\sum{W[i]}/(\text{边数}*limit)>=1$

$\sum{W[i]}>=(\text{边数}*limit)$

$\sum{W[i]}-(\text{边数}*limit)>=0$

$\sum{(W[i]-limit)}>=0$

也就是说$limit$为合发解可以通过在一个边权为$(W[i]-limit)$的新图上跑最短路，$(from,to)$的距离小于等于0来检验。

然后还有个小优化。

对于每次二分的$check$,我们都跑了一次单源最短路，但是只利用了其中的一个信息，未免浪费。

我们可以利用这些信息，在二分的边界上做手脚(不知道如何描述，还是看代码吧)。

不知道卡掉的是常数还是复杂度，反正跑的挺快。

~~另外，我判断无解的方式有点令人无语~~

**Code:**

```cpp
#include<algorithm>
#include<cstdio>
#include<vector>
#include<queue>
#define eps 1e-5
using namespace std;
vector<int> g[55],l[55];
int n,m,from,to,len,q;
double ans[55][55],ll[55][55],rr[55][55],s[55];
queue<int> t;
bool in[55];
/*
假设ans>=limit
则sum(len)/sum(cnt) >= limit
  sum(len)/(sum(cnt)*limit) >= 1
  sum(len) >= sum(cnt)*limit
  sum(len)-sum(cnt)*limit >= 0
  sum(len-limit) > 0
*/
bool check(int from,int to,double limit)
{
  for (int i=1;i<=n;i++)s[i]=1e15;
  s[from]=0;t.push(from);in[from]=1;
  while(!t.empty()){
  	int u=t.front();
  	in[u]=0;
  	t.pop();
  	for (int i=0,v;i<g[u].size();i++)
  	 if (s[v=g[u][i]]>s[u]+l[u][i]-limit+eps){
  	   s[v]=s[u]+l[u][i]-limit;
	   //注意这里边权 
  	   if (!in[v]){in[v]=1;t.push(v);}
  	 }
  }s[from]=1e15;
  //SPFA,没啥好看的 
  for (int i=1;i<=n;i++)
    if (s[i]<eps)rr[from][i]=min(rr[from][i],limit);
    else ll[from][i]=max(ll[from][i],limit);
  //在这里做了手脚 
  return s[to]<eps;
}
void getans(int from,int to)
{
  if (!check(from,to,1e6))return ;
  //判断无解 
  double l=ll[from][to],r=rr[from][to],mid;
  while(r-l>eps){
  	mid=(l+r)/2;
  	if (check(from,to,mid))r=mid;
  	else l=mid;
  }ans[from][to]=l;
  //01分数规划 
}
int main()
{
  scanf("%d%d",&n,&m);
  for (int i=1;i<=m;i++){
    scanf("%d%d%d",&from,&to,&len);
    g[from].push_back(to);
    l[from].push_back(len);
  }
  for (int i=1;i<=n;i++)
   for (int j=1;j<=n;j++){
     ll[i][j]=0;rr[i][j]=100500;
	 ans[i][j]=2.333333333;
   }
  for (int i=1;i<=n;i++)
   for (int j=1;j<=n;j++)
    if (i!=j)getans(i,j);
  scanf("%d",&q);
  for (int i=1;i<=q;i++){
  	scanf("%d%d",&from,&to);
  	if (2.33333333<ans[from][to]&&ans[from][to]<2.33333334)
  	 puts("OMG!");
	else printf("%.3lf\n",ans[from][to]);
  }
  return 0;
}
```

~~Orz比各位dp的巨佬慢多了~~

---

## 作者：Novice_TvT (赞：1)

 
 
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int ma=100000000;
int n,k,m,s,t,i,j,x,y,z,q;
int a[101],v[101][101],f[101][101][1009],qa,qb;//v记录两点距离，f[x][y][t]记录两点在第t步的两点距离
double ans,mi;
int main()
{  scanf("%d%d",&n,&m);
   for(i=1;i<=n;i++)
    for(j=1;j<=n;j++)v[i][j]=ma;
   for(i=1;i<=n;i++)
    for(j=1;j<=n;j++)
     for(t=1;t<=m;t++)f[i][j][t]=ma;
   for(i=1;i<=m;i++)
   {scanf("%d%d%d",&x,&y,&z);
   if(z<v[x][y])v[x][y]=z,f[x][y][1]=z;}
   scanf("%d",&q);//读入
  for(t=2;t<=n;t++)//记录步数
   for(k=1;k<=n;k++)
    for(i=1;i<=n;i++)
     for(j=1;j<=n;j++)
      if(f[i][k][t-1]+v[k][j]<f[i][j][t])f[i][j][t]=f[i][k][t-1]+v[k][j];//Floyed算法
  for(i=1;i<=q;i++)
   {
    mi=ma;
    scanf("%d%d",&qa,&qb);//读入问题
    for(t=1;t<=n;t++)
   if(f[qa][qb][t]<ma){ans=(double)f[qa][qb][t]/t;
   if(ans<mi)mi=ans;}
   if(mi<ma)printf("%.3lf\n",mi);
   else cout<<"OMG!"<<endl;
}
return 0;    
}

```

---

## 作者：zhaimingshuzms (赞：1)

#这题其实不难

这题要求路径密度最小，就萌生出了要求出任意有序点对（i，j)经过l（这是L的小写）条边最短路的想法；

因为是任意两点，所以当然是floyd大法好，就是有一个坑，有重边，我因为偷懒没有用map[i][j]，直接给f数组赋值，结果没有判重边被坑了好多次；

接下来处理最小密度就直接枚举l（这是L的小写）即可，但是要注意类型强制转化，不然出来的答案全是x.000；

废话不多说，贴代码

##############################################################################

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=110,M=1010;
int n,m,l,i,j,k,q,x,y,z,f[M+1][N+1][N+1];
int main()
{
    scanf("%d%d",&n,&m);
    for (l=1; l<=m; l++)
    for (i=1; i<=n; i++)
    for (j=1; j<=n; j++)
    f[l][i][j]=1e9;
    for (i=1; i<=m; i++) 
    {
        scanf("%d%d%d",&x,&y,&z);
        if (z<f[1][x][y]) f[1][x][y]=z;//重边处理 
    }
    for (l=2; l<=m; l++)
    for (k=1; k<=n; k++)
    for (i=1; i<=n; i++)
    for (j=1; j<=n; j++)
        f[l][i][j]=min(f[l-1][i][k]+f[1][k][j],f[l][i][j]);
    scanf("%d",&q);
    for (; q; q--)
    {
        scanf("%d%d",&x,&y);
        long double ans=1e9;
        for (l=1; l<=m; l++)
        if (f[l][x][y]<1e9&&f[l][x][y]<ans*l) ans=(long double)f[l][x][y]/(long double)l;
        if (ans==1e9) printf("OMG!\n"); else printf("%.3Lf\n",ans);
    }
    return 0;
}
```

---

## 作者：luyan (赞：0)


# 题目大意

[题目链接](https://www.luogu.com.cn/problem/P1730)

题目大意：一个有向无环图（DAG），边权均为正整数。

定义一条路径的密度为 路径上的边权和/边数。

先有q组询问，每次给出xy，求从x到y的若干条路径中的最小路径密度是多少。

# 题目分析

令c为边权，d为路径条数

那么所求即为：$\frac{\sum{c}}{d}$

这是一个和式分式，对于这种题目，我们通常用一种方法叫做 [01分数规划](https://blog.csdn.net/luyan0408/article/details/106750403)

我们二分答案，然后判断。

判断过程：把每条边边权-二分答案然后判断最短路的正负性。

如果最短路是负的那么答案不合法，修改r

否则修改l

# 代码

下附AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){
	char s;
	int x=0,f=1;
	s=getchar();
	while(s<'0'||s>'9'){
		if(s=='-')f=-1;
		s=getchar();
	}
	while(s>='0'&&s<='9'){
		x*=10;
		x+=s-'0';
		s=getchar();
	}
	return x*f;
}
const int N=55;
int n,m;
vector<int>v[N];
vector<double>v1[N];
double ans[N][N];
double dist[N];
bool in[N];
queue<int>q;
bool spfa(int s,int ask,double limit){
	for(int i=1;i<=n;i++){
		dist[i]=0x3f3f3f3f;
		in[i]=0;
	}
	dist[s]=0;
	q.push(s);
	in[s]=1;
	while(!q.empty()){
		int x=q.front();
		in[x]=0;
		q.pop();
		for(int i=0;i<v[x].size();i++){
			int k=v[x][i];
			if(dist[k]>dist[x]+v1[x][i]-limit){
				dist[k]=dist[x]+v1[x][i]-limit;
				if(!in[k]){
					in[k]=1;
					q.push(k);
				}
			}
		}
	}
	return dist[ask]>0;
}
double maxn;
void go(int x,int y){
	double l=0,r=maxn;
	spfa(x,y,0);
	if(dist[y]==0x3f3f3f3f){
		ans[x][y]=-1;
		return;
	}
	while(r-l>1e-6){
		double mid=(l+r)/2;
		if(spfa(x,y,mid))l=mid;
		else r=mid;
	}
	ans[x][y]=l;
	return;
}
int main(){
	n=read(),m=read();
	for(int i=1;i<=m;i++){
		int a,b,c;
		a=read(),b=read(),c=read();
		maxn+=c;
		v[a].push_back(b);
		v1[a].push_back(c);
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(i==j)continue;
			go(i,j);
		}
	}
	int Q=read();
	for(int i=1;i<=Q;i++){
		int x=read(),y=read();
		if(ans[x][y]<0)printf("OMG!\n");
		else printf("%.3lf\n",ans[x][y]);
	}
}
```



---

## 作者：_J_C_ (赞：0)

其实这题很简单的……应该没有提高+/省选-~~（这就是为什么我0分2次？）~~

比较显然的是，**询问次数非常非常多，而n只有50。**

总共的询问方案只有(50\*50)2500种，它却问你10000下……不了解是几个意思、

考虑一下普通最短路的时候，我们只要记录走到这里的长度就好了。但这个要求的是平均长度……那我们就在记录一下走到这里总共用了k步就好了。

所以"状态"是dp[now][k]，代表走到了这里时已经走过的距离（不作除法，故为整数）。

严格来说，状态里还应该有起始点和终点，这样子才能动态规划。但是在这题里面，这个dp数组就是一个辅助用的数组：**真正的答案只取决于从哪里来和到哪里去**，和这些乱七八糟的now啊k啊其实一点关系都没有的。只是你那样子定义状态的的话你的状态转移……

我们在做的其实只是**利用dp数组计算出mem[fr][to]**，它代表了从fr到to的答案，之后记录一下以备它再次查询。用完了，dp丢了就好（初始化），或者你开dp[fr][to][now][k]也行的，只是**fr，to不同的状态间不会产生转移**。

我们用bfs干这件事：每次可以从状态dp[now][k]转移到dp[next][k+1]，只要你能走过去而且比先前的状态优（又或者之前就没有推出过这个状态）

所以这大概算是一个分层dp了：每次你只能从k走到k+1。

考虑到这是一个无环图（据讨论里说是有环的，我不清楚……但我这样是AC了），所以我们的k只要开到和n一样就够了——**因为没有环每次都只能往某个方向，在某个意义上的前进而不可能返回。**这样子的话，遍历全图最多k也就到n-1。

还有一个坑点就是走不到。。只要通过记录一个bVal[fr][to]记录一下当前mem[fr][to]是否是有效的就好了，如果bVis[fr][to] == true（已经查询过这对fr和to了）而bVal[fr][to] == false，则说明上次查询没出结果，这次当然也不会出，就"OMG!"了（我因为这里一次逻辑写漏，一次逻辑写反，全部"On linex …… read OMG!,expect XXX"……“我想，这实在是无法可想的了。”

上代码：

```cpp
#include <cstdio>
#include <cstdlib>

#include <queue>

#define FOR_EDGE(i, pt) for (int i(iHead[pt]); i; i = all[i].next)

class edge
{
public:
    int to, val, len, next;
}all[1123];
int iEnd(2);
int iHead[51];

void add(int fr, int to, int len)
{
    all[iEnd].to = to;
    all[iEnd].len = len;
    all[iEnd].next = iHead[fr];
    iHead[fr] = iEnd++;
}

int NextVis;
int bInQue[51][51];//这个状态在队列里了（莫名SPFA的感觉，感觉也算半个SPFA吧，只是全部正权和无环更像广搜）
int bVis[51][51];//在广搜时是否访问过（访问标记，代表当前dp值是否有效）
int dp[51][51];//辅助数组dp，如上所述

bool bMem[51][51], bVal[51][51];//是否查询过这对(fr,to)，以及是否有解
double mem[51][51];//实质上是完全记录了状态的数组，但是对于转移并没有什么用……真不知道怎么称呼好

double bfs(int fr, int to, bool& fail)
{
    if (bMem[fr][to] && !bVal[fr][to])
    {
        fail = true;//无解
        return 0;
    }
    if (bMem[fr][to])
    {
        fail = false;//有解有解（这行我错误两次……大概AC心切）
        return mem[fr][to];
    }
    ++NextVis;
    bMem[fr][to] = true;
    std::queue<int> now, pass;
    now.push(fr);
    pass.push(0);
    dp[fr][0] = 0;
    while (!now.empty())
    {
        int n(now.front()), p(pass.front());
        now.pop(); pass.pop();
        bInQue[n][p] = 0;
        if (n == to)
        {
            if (double(dp[n][p]) / double(p) < mem[fr][to] || !bVal[fr][to])
            {
                bVal[fr][to] = true;//找到一个解了，先记录一下，广搜完试试还有没有更优的解（？所以你用dijkstra到了这里大概可以直接走人了？）
                mem[fr][to] = double(dp[n][p]) / double(p);
            }
        }
        FOR_EDGE(i, n)
        {

            if (bVis[all[i].to][p + 1] ^ NextVis || dp[all[i].to][p + 1] > all[i].len + dp[n][p])
            {
                bVis[all[i].to][p + 1] = NextVis;//更优的状态，或者之前就没有这个状态
                dp[all[i].to][p + 1] = all[i].len + dp[n][p];
                if (bInQue[all[i].to][p + 1] ^ NextVis)
                {
                    bInQue[all[i].to][p + 1] = NextVis;//在队列里就不必入队了，因为已经偷换了dp值了
                    now.push(all[i].to);
                    pass.push(p + 1);
                }
            }
        }
    }
    if (!bVal[fr][to])
    {
        fail = true;
        return -1;
    }
    fail = false;
    return mem[fr][to];
}

int n, m, q;

int main()
{
    scanf("%d%d", &n, &m);//输入，建图，查询，输出，平淡无奇
    for (int i(0); i != m; ++i)
    {
        int fr, to, len;
        scanf("%d%d%d", &fr, &to, &len);
        add(fr, to, len);
    }
    scanf("%d", &q);
    for (int i(0); i != q; ++i)
    {
        int fr, to;
        scanf("%d%d", &fr, &to);
        bool fail;
        double ans = bfs(fr, to, fail);
        if (fail)
        {
            printf("OMG!\n");
        }
        else
        {
            printf("%.3f\n", ans);
        }
    }
    //while (1);
    return 0;
}

```



---

## 作者：荣一鸣 (赞：0)

在一个有向无环图中找到一个最（）的路径，然后输出其最（）的路径值。一看就是最短路的模型。这种题面~~白痴~~直接的题碰上是最好的，但既然这样的题如此~~白痴~~直接的问出来一定是有它的难度的。

很明显，这道题由于数据不大，可以用floyd直接做，可见这题目还是很简单的，但也表现这题目考的不是最短路，而是与最短路结合的数学基础。

我们用floyd时，会有状态转移方程，而我一开始是这样想的

```cpp
double f[51][51]//从i到j的最小密度对应的长度
double l[51][51]//从i到j的最小密度对应的路的条数

for(int k=1;k<=50;k++){
	for(int i=1;i<=50;i++){
    	for(int j=1;j<=n;j++){
        	double nt=(d[i][k]+d[k][j])/(l[i][k]+l[k][j]);
            if(nt<d[i][j]/l[i][j]){
            	d[i][j]=d[i][k]+d[k][j];
                l[i][j]=l[i][k]+l[k][j];
            }
        }
    }
}
```

然而WA，所以只能再思考给出一个数据来示范一下点A,B,C
A到B的路有L1（1,2）和L2（51,100）B到C的路有L3（3,4）和L4（8,10）若按上述方法会选中L1和L3实际上L2和L3是最短的，一次要把每一个情况都算一遍，不能只用贪心

```
for(int l=2;l<=n;l++){
		for(int k=1;k<=n;k++){
			for(int i=1;i<=n;i++){
				for(int j=1;j<=n;j++){
					d[i][j][l]=min(d[i][k][l-1]+d[k][j][1],d[i][j][l]);
//					cout<<d[i][j][l]<<endl;
				}
			}
		}
	}
```

这是正确的floyd过程

下面是完整代码

```
#include<stdio.h>
#include<iostream>
#include<cstdio>
using namespace std;
int n,m,q;
int map[51][51];
double d[51][51][51];
double li[51][51];
const int INF=0x7fffffff;

void init(){
	for(int i=1;i<n;i++){
		for(int j=i+1;j<=n;j++){
			map[i][j]=map[j][i]=li[i][j]=li[j][i]=INF;
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			for(int k=0;k<=n;k++){
				d[i][j][k]=INF;
			}
		}
	}
	for(int i=1;i<=n;i++){
		d[i][i][0]=0;
	}
}

void floyd(){
	for(int l=2;l<=n;l++){
		for(int k=1;k<=n;k++){
			for(int i=1;i<=n;i++){
				for(int j=1;j<=n;j++){
					d[i][j][l]=min(d[i][k][l-1]+d[k][j][1],d[i][j][l]);
				}
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			for(int k=1;k<=n;k++){
				if(d[i][j][k]<INF){
					li[i][j]=min(li[i][j],d[i][j][k]/k);
				}
			}
		}
	}
}

void solve(int x,int y){
	if(x==y||li[x][y]==INF){
		printf("OMG!\n");
		return;
	}
	printf("%.3f\n",li[x][y]);
}

int main(){
	scanf("%d%d",&n,&m);
	init();
	for(int i=1;i<=m;i++){
		int x,y,c;
		scanf("%d%d%d",&x,&y,&c);
		if(c<map[x][y]) map[x][y]=d[x][y][1]=c;
	}
	floyd();
	scanf("%d",&q);
	for(int i=1;i<=q;i++){
		int x,y;
		scanf("%d%d",&x,&y);
		solve(x,y);
	}
	return 0;
}
```

---


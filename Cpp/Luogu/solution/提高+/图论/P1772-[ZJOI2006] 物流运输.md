# [ZJOI2006] 物流运输

## 题目描述

物流公司要把一批货物从码头 A 运到码头 B。由于货物量比较大，需要 $n$ 天才能运完。货物运输过程中一般要转停好几个码头。  

物流公司通常会设计一条固定的运输路线，以便对整个运输过程实施严格的管理和跟踪。由于各种因素的存在，有的时候某个码头会无法装卸货物。这时候就必须修改运输路线，让货物能够按时到达目的地。  

但是修改路线是—件十分麻烦的事情，会带来额外的成本。因此物流公司希望能够订一个 $n$ 天的运输计划，使得总成本尽可能地小。


## 说明/提示

【数据范围】
对于 $100\%$ 的数据，$1 \le n \le 100$，$1\le m \le 20$, $1 \le k \le 500$, $1 \le e \le 200$。

【样例输入说明】

![](https://cdn.luogu.com.cn/upload/image_hosting/4lcnync6.png)

上图依次表示第 $1$ 至第 $5$ 天的情况，阴影表示不可用的码头。

【样例输出说明】

前三天走 $1 \to 4 \to 5$，后两天走 $1 \to 3 \to 5$，这样总成本为 $(2+2)\times 3+(3+2)\times 2+10=32$。

\_NOI导刊2010提高（01）


## 样例 #1

### 输入

```
  5 5 10 8
  1 2 1
  1 3 3
  1 4 2
  2 3 2
  2 4 4
  3 4 1
  3 5 2
  4 5 2
  4
  2 2 3
  3 1 1
  3 3 3
  4 4 5
```

### 输出

```
32```

# 题解

## 作者：ycyaw (赞：131)

模拟赛居然考了这道题，前一天刚看过，结果看了舍不得(~~不会~~)做，结果只骗到30pt

讲课人：很容易想到最短路+$dp$(~~我靠一点都不容易~~)

模拟赛后分析，才知道是处理出第i天到第j天都走同一条最短路的花费为$co[i][j]$

然后进行$dp$，$dp[i]$表示前i天的最小花费

转移方程很好想:$dp[i]=min(dp[j]+co[j+1][i]*(i-j)+k)$，预处理要赋值为$co[1][i]*i$

$dp$方程的意思，即在第$j+1$天改变路线，第$j+1$天~第$i$天都走同一条路线

那么如何处理$co[i][j]$?

很简单，对于每一个$(i,j)$，先把$i$到$j$天之间封闭的码头全部设为不可走，跑一遍最短路即可，初值为无穷

数据辣么小，跑几遍以及跑什么都没关系~~嘤嘤嘤~~

那我们就十分愉♂快的解决了此题~~~

愉♂快的提交了然后居然只有90pt

~~原谅我无耻的打开题解~~

啊啊啊原来要开$long$ $long$(明明数据辣么小)

献上代码：
```cpp
#include<bits/stdc++.h>
#define soo (1e8)
#define ll long long
using namespace std;
int d,cnt,head[25],dis[25],vis[25],cant_vis[25];
ll co[105][105],dp[105];
int n,m,k,ee,cl[25][105];
struct Edge{
	int v,nx,s;
}e[10005];
inline int read(){
    int ret=0,ff=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-') ff=-ff;ch=getchar();}
    while(isdigit(ch)){ret=(ret<<3)+(ret<<1)+ch-'0';ch=getchar();}
    return ret*ff;
}
void add(int x,int y,int z){
	e[++cnt].v=y;
	e[cnt].s=z;
	e[cnt].nx=head[x];
	head[x]=cnt;
}
void spfa(){//爱跑什么跑什么
	for(int i=1;i<=m;i++) dis[i]=soo,vis[i]=0;
	queue<int> q;
	dis[1]=0;
	q.push(1);
	while(!q.empty()){
		int x=q.front();
		q.pop();
		vis[x]=0;
		for(int i=head[x];i;i=e[i].nx){
			int v=e[i].v;
			if(cant_vis[v]) continue;
			if(dis[v]>dis[x]+e[i].s){
				dis[v]=dis[x]+e[i].s;
				if(!vis[v]){
					vis[v]=1;
					q.push(v);
				}
			}
		}
	}
}
signed main(){
	n=read(),m=read(),k=read(),ee=read();
	for(int i=1;i<=ee;i++){
		int x=read(),y=read(),z=read();
		add(x,y,z);
		add(y,x,z);
	}
	d=read();
	for(int i=1;i<=d;i++){
		int t=read(),x=read(),y=read();
		for(int j=x;j<=y;j++) cl[t][j]=1;
	}
	//cl[i][j]表示第i个码头在第j天不能走
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++){
			memset(cant_vis,0,sizeof(cant_vis));
			for(int r=i;r<=j;r++)
				for(int l=1;l<=m;l++)
					if(cl[l][r]) cant_vis[l]=1;
			spfa();
			co[i][j]=dis[m];
		}
	memset(dp,0x7f,sizeof(dp));
	for(int i=1;i<=n;i++){
		dp[i]=(ll)co[1][i]*i;
		for(int j=i-1;j>=0;j--)
			dp[i]=min(dp[i],dp[j]+co[j+1][i]*(i-j)+k);
	}
	printf("%lld",dp[n]);
    return 0;
}
```


---

## 作者：DavidJing (赞：56)

# 题意

给你m个码头，n天，其中一些码头在某些天会损坏，这n天都要有一条路从1->m，每一次更换道路会需要K的价值，求这n天每天从1到m的距离和与更改道路的价值之和的最小值.

# 解析

最优解问题明显就是一个dp，而求两点之间的距离当然就是最短路了~

那么思考怎么构建dp方程

**首先我们可以设f[i]表示前i天所花费的最小值**

**f[i]=min(f[i],f[j-1]+(i-j+1)$ * $L+K) （1<=j<=i)**

什么意思呢 **就是第j天到第i天走同一条路，并且这条路和第j-1天是不同的**

那么第j天到第i天走的肯定是此时情况下的最短路了,所以L表示在当前情况下的1->m的最短路,可以用spfa（~~虽然他已经死了~~）或dijktra求解



那么现在就要考虑码头无法使用的情况了，

**因为我们要保证第j天到第i天走的最短路是不能包括在这些天内不能经过的点的(哪怕是1天或是间断的几天都不行)**

所以我们枚举j的时候可以从大到小枚举，**并且将第j天无法通过的点同j+1->i天无法通过的点塞入一个集合，并且在求最短路时判断不经过集合中的点，就可以求出从第j天到第i天经过未损坏的点从1到m的最短路了~**

L这样求解，题目也就容易做出了~

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1005;
const int maxm=2005;
int ans,tot,a,b,c,d,n,m,K,e;
int dp[maxn],now[maxm],ff[maxn][maxm],cost[2*maxm],f[maxm],q[5*maxm],dis[maxm],DIS[maxn],nex[2*maxm],lnk[maxm],las[2*maxm];
void add(int x,int y,int z)
{nex[++tot]=y;las[tot]=lnk[x];lnk[x]=tot;cost[tot]=z;}
int read()
{
    int ch=0,x=0;while(ch=getchar(),ch<'0'||ch>'9');
    while(x=x*10+ch-48,ch=getchar(),ch>='0'&&ch<='9');
    return x;
}
int spfa()
{
    memset(dis,127,sizeof(dis));
    int head=1,tail=1;q[1]=1;dis[1]=0;f[1]=1;
    while(head<=tail)
    {
        int u=q[head];
        for(int k=lnk[u];k;k=las[k])
        if(dis[nex[k]]>dis[u]+cost[k]&&(!now[nex[k]]))//不能经过无法通过点
        {
            dis[nex[k]]=dis[u]+cost[k];
            if(!f[nex[k]])
            {
                f[nex[k]]=1;
                q[++tail]=nex[k];
            }
        }
        f[u]=0;
        head++;
    }
    return dis[m];
}
int main()
{
    n=read();m=read();K=read();e=read();
    for(int i=1;i<=e;i++)
    {
        a=read();b=read();c=read();
        add(a,b,c);add(b,a,c);
    }
    d=read();
    for(int i=1;i<=d;i++)
    {
        a=read();b=read();c=read();
        for(int j=b;j<=c;j++)
        ff[j][a]=1;
    }
    memset(dp,63,sizeof(dp));
    dp[0]=-K;//第一次选择路径是不算做跟改路径的
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)now[j]=0;
        for(int j=i;j>=1;j--)
        {
            for(int k=1;k<=m;k++)
            if(ff[j][k])now[k]=1;//now[k]表示第j天到第i天k是无法使用的
            int get=spfa();
            if(get>=100000000)break;//j->i天无法通过一条固定路径到达就退出，后面也不可能到达
            dp[i]=min(dp[i],dp[j-1]+(i-j+1)*get+K);
        }
    }
    printf("%d",dp[n]);
    return 0;
}
```



---

## 作者：litble (赞：46)

[安利个人博客](http://blog.csdn.net/litble/article/details/78427014)

没有人发dfs+状压dp做法我就来一发咯,虽然这种做法很辣鸡......

# 题目分析

首先发现m的范围是很小的,这是一个状压的征兆.然后发现每一种航线都可以用这条航线上经过的点集表示,因为某一天该航线是否可以走也仅和这条航线上的点能否走有关.

所以可以用dfs处理航线经过某一点集的最短路.

然后开始dp,那么用f(i,zt)表示第i天使用zt航线的最优解……

等等,我掐指一算,$2^{20}=1048576$,这么设计状态是要责任的.

但是我转念一想,因为起点和终点是固定要走的,所以事实上航线只有$2^{18}=262144$条,离超时还远着呢.

然后状态转移很简单,f(i,zt)=min(f(i-1,X)+(X!=zt)\*k+cost(zt))

可是这样子也是会超时的.因为枚举昨天的航线情况复杂度高达$2^{18}*2^{18}$.不过对于改变了航线的情况,我们肯定是考虑了很多杂余的状态,因此我们只要记录一下昨天的最优解las,方程就可以改成:

f(i,zt)=min(las+k,f(i-1,zt))+cost(zt);

于是就暴力AC了,代码还很吼写……

# 代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
#define LL long long
const int MX=(1<<18);
int n,m,k,e,d;
int l[22][22],bin[22],cl[105],vis[22];
LL f[2][MX],cost[MX],inf,tmp[MX];
//cl:某一天关闭的港口集合,cost:经过某一点集的航线的最短路,tmp:用于dfs剪枝
void work() {//dp过程
    LL las=0,now;int t;
    for(int i=1;i<=n;++i){
        now=inf,t=(i&1);//开了滚动数组desi
        for(int zt=0;zt<=bin[m]-1;++zt) {
            if((zt&cl[i])) {f[t][zt]=inf;continue;}//当天选择的航线,所有港口没有被关闭
            f[t][zt]=min(f[t^1][zt],las+k)+cost[zt];
            now=min(now,f[t][zt]);
        }
        las=now;//las:记录昨天的最优解
    }
    printf("%lld",las);
}
void dfs(int x,int zt,LL num) {//dfs过程
    if(num>=tmp[zt]) return;tmp[zt]=num;
//以上是一个从30分变成100分的剪枝.由于此题点非常少,而边可能很多,所以可能造成的重复状态很多
    for(int i=2;i<m;++i)
        if(!vis[i]&&l[x][i]!=inf)
        vis[i]=1,dfs(i,zt|bin[i],num+l[x][i]),vis[i]=0;
    if(l[x][m]!=inf) cost[zt]=min(cost[zt],num+l[x][m]);
}
int main()
{
    int x,y,z;
    scanf("%d%d%d%d",&n,&m,&k,&e);
    bin[2]=1;for(int i=3;i<=m;++i) bin[i]=bin[i-1]<<1;
    memset(l,0x3f,sizeof(l));memset(cost,0x3f,sizeof(cost));
    memset(tmp,0x3f,sizeof(tmp));inf=l[0][0];
    for(int i=1;i<=e;++i)
        scanf("%d%d%d",&x,&y,&z),l[x][y]=l[y][x]=min(l[x][y],z);
    scanf("%d",&d);
    for(int i=1;i<=d;++i) {
        scanf("%d%d%d",&x,&y,&z);
        for(int j=y;j<=z;++j) cl[j]|=bin[x];//记录每天被关闭的港口
    }
    vis[1]=1;dfs(1,0,0);work();
    return 0;
}
```

---

## 作者：荣一鸣 (赞：34)

这道题是要求最小成本，而成本=路程，成本最小即路程最短，所以就是求最短路了。

## 知道是最短路也不会做！！

的确，这题很恶心，需要将最短路和动态规划结合。

数组dp[][]来表示

我们来构想一下，当我们到第n天的时候，有两种选择，一是继续原先的路，二是换一条新的路，当然，如果在这一天原先的路不能走了就必须要换一条路，然而换成什么路当然是用最短路求啦。

我们再考虑一下，如果第n-1天的路在第n天就不能走了，我们换了一条最短的路，然而第n+1天这条最短路就又不能走了，又要换一条新的。我们可以考虑这样做，求出从第i天到第j天都可以走的最短路成本乘上（j-i+1），加上第i-1天及以前的总成本，再加上换方案的费用k。

再i不变的情况下枚举j并求最短路就OK了，而且最多只有20个码头，用floyd也是可以的，但是推荐spfa

```
#include<iostream>
#include<cstdio>
#include<iostream>
#include<queue>
#include<cstring>
using namespace std;
int n,m,k,e;
int map[21][21];
int d;
int a[21][110];
int dp[110];
int now[21];

int spfa(){
	queue<int> q;
	int dis[21];
	int vis[21];
	for(int i=1;i<=m;i++) dis[i]=0x7ffffff,vis[i]=0;
	dis[1]=0;
	q.push(1);
	while(!q.empty()){
		int u=q.front();
		q.pop();
		vis[u]=0;
		for(int i=1;i<=m;i++){
			if(now[i]) continue;
			if(map[u][i]>0&&dis[i]>dis[u]+map[u][i]){
				dis[i]=dis[u]+map[u][i];
				if(vis[i]==0){
					q.push(i);
					vis[i]=1;
				}
			}
		}
	}
	return dis[m];
}

int main(){
	cin>>n>>m>>k>>e;
	for(int i=1;i<=m;i++){
		for(int j=1;j<=m;j++){
			map[i][j]=0x7ffffff;
		}
	}
	for(int i=1;i<=e;i++){
		int f,t,l;
		cin>>f>>t>>l;
		map[f][t]=l;
		map[t][f]=l;
	}
	cin>>d;
	for(int i=1;i<=d;i++){
		int aa,b,p;
		cin>>p>>aa>>b;
		for(int j=aa;j<=b;j++){
			a[p][j]=1;
		}
	}
	for(int i=1;i<=n;i++) dp[i]=0x7ffffff;
	dp[0]=-k;
	for(int i=1;i<=n;i++){
		memset(now,0,sizeof(0));
		for(int l=1;l<=m;l++) now[l]=0;
		for(int j=i;j>=1;j--){
			for(int l=1;l<=m;l++){
				now[l]|=a[l][j];
			}
			int ll=spfa();
			if(ll==0x7ffffff)continue;
			dp[i]=min(dp[i],dp[j-1]+ll*(i-j+1)+k);
		}
	}
	cout<<dp[n];
	return 0;
}
```

---

## 作者：lyhahwq123 (赞：16)


**最短路 + dp **

最短路 相信都看得出来

由于路径的不确定 和 最优方案 而想到dp

蒟蒻代码 有详细注释

```c
#include<cstdio>
#include<cstring>
#include<queue>
#include<algorithm>
using namespace std;
const int maxn=30;
const int maxm=maxn*maxn;
const int INF=0X3f3f3f3f;
int day,n,recost,m,d,t;
int head[maxn],dist[maxn];
bool close[maxn][110],book[maxn],vis[maxn];
long long cost[110][110],dp[110];
struct node{
	int to,w,next;
} edge[maxm];
void add(int u,int v,int w){
	edge[ ++ d].to = v; edge[d].w = w;
	edge[d].next = head[u]; head[u] = d; 
}
int spfa(int x,int y){
	memset(dist,INF,sizeof(dist));
	memset(vis,0,sizeof(vis));
	memset(book,0,sizeof(book));//book数组表示从第x到第y天 港口的关闭 
	for(int i = 1;i <= n;i ++){
	    for(int j = x;j <= y;j ++)
	    if(close[i][j]) book[i] = 1;//从x到y有一天关闭也算关闭 保证共同性 
	}
	//标准spfa 
	queue<int> q;
	q.push(1); dist[1] = 0; vis[1] = 1;
	while(!q.empty())
	{
		int u = q.front(); q.pop(); vis[u] = 0;
		for(int i = head[u];i;i = edge[i].next){
			int v = edge[i].to;
			if(book[v]) continue;
			if(dist[v] > dist[u] + edge[i].w){
				dist[v] = dist[u] + edge[i].w;
				if(!vis[v]){
					q.push(v); vis[v] = 1; 
				}
			}
		}
	}
	return dist[n];
}
int main()
{
	scanf("%d %d %d %d",&day,&n,&recost,&m);//所需天数 点数 更新边所需代价 边数 
	for(int i = 1;i <= m;i ++){
		int u,v,w;
		scanf("%d %d %d",&u,&v,&w);
		add(u,v,w); add(v,u,w);//每条边的信息 建双向边 
	} scanf("%d",&t);//输入会关闭的港口数 
	for(int i = 1;i <= t;i ++){
		int p,u,v;
		scanf("%d %d %d",&p,&u,&v);//输入港口关闭信息 
		for(int j = u;j <= v;j ++){
			close[p][j]=1;// 用close储存信息 close[p][i]表示p港口在第i天会关闭 
		}
	}
	for(int i = 1;i <= day;i ++){
		for(int j = 1;j <= day;j ++){
			cost[i][j]=spfa(i,j);//用cost[i][j] 处理出从第i天到第j天共同的最短路的长度 
		}
	}
	for(int i = 1;i <= day;i ++){ 
		dp[i] = (long long)cost[1][i] * i;
		for(int j = 1;j <= i;j ++){
			dp[i] = min( dp[i],dp[j] + recost + (long long)cost[j+1][i]*(i-j));//将int 转化为longlong 
			//dp表示从第一天到第i天的最佳花费
			//j表示断点  意为从第j天更换航路 分为1-j + j-i + 更换费用 
		}
	}
	printf("%lld\n",dp[day]);
	return 0;
}
```

---

## 作者：hovny (赞：15)

## 前言

震惊！这种非主流的方法居然$A$了

## 解题思路

介绍一种不一样的思路，也就是不是**DP**的写法，

_纯粹的最短路_

数据范围比较小，然后又不同的天数

于是就可以搞**分层图**

#### 改变路径的情况

只要在一层的$n$号点与下一层$1$号点之间连一条边权为$K$的边

#### 不改变路径的情况

这种情况比较复杂，但还是由于数据范围比较小，我们就可以愉快地暴力了

把每一种路径不改变的情况（称为阶段）求出来

先枚举$i$，表示这一阶段的开始时间（即分层图上的第$i$层），

再枚举$j$，表示这一阶段的结束时间（即分层图上的第$j$层），

期间，能用的点，应该在这阶段内的每一天都可以通过，

也就是只能走没标记过的点

对于每个阶段，也可以很愉快地跑最短路

跑完最短路的结果就是一次（跑一层）的费用，再乘上 层数，在第$i$层的$1$号点和第$j$层的$n$号点之间连边，也就是表示可以直接略过中间部分

最后再整体跑个图就好了

~~怎么可能没有坑~~

坑点就是，为了防止我们连在$1$号点和$n$号点的边更新$n$号点所在层的其他节点的答案（毕竟你略过了中间部分就不能往回走了），所以在建图的时候，与$n$号点相连的边由**双向边改为单向边**即可

## Code

```cpp
#include<bits/stdc++.h>
#define INF 0x7f7f7f7f
#define rgt register
#define M 10407
#define Mn 107
#define N 23
using namespace std;
struct Edge{
	int to,cost,nxt;
	Edge(int a,int b):to(a),cost(b) {}
	Edge(){	}
}b[M<<1];
struct node{
	int p,t,cost;
	node(int a,int b,int c):p(a),t(b),cost(c){}
	node(){}
	inline bool operator< (const node x) const{
		return cost>x.cost;
	}
};
int head[N],hed[Mn];//分别存点和时间
int n,m,t,T,K,D,d[N],s[N][Mn];//d数组是一层的最短路，s是分层图上最短路
bool vis[N],usd[N],gg[N][Mn];//usd记录一个阶段不能选的点有哪些
inline int read() {
	rgt int s=0;
	rgt char c=getchar();
	while(!isdigit(c)) c=getchar();
	while(isdigit(c)) s=(s<<1)+(s<<3)+c-'0',c=getchar();
	return s;
}
inline void Add(int x,int y,int cost) {
	b[++t]=Edge(y,cost),b[t].nxt=head[x],head[x]=t;
}
inline void add(int x,int y,int cost) {
	b[++t]=Edge(y,cost),b[t].nxt=hed[x],hed[x]=t;
}
inline void Spfa() {//求一层的最短路
	int i,to,cur,cost;
	queue<int>p;p.push(1);
	memset(d,INF,sizeof(d)),d[1]=0,vis[1]=1;
	while(!p.empty()) {
		cur=p.front(),p.pop(),vis[cur]=0;
		for(i=head[cur];i;i=b[i].nxt) {
			to=b[i].to;
			if(usd[to]) continue;
			cost=d[cur]+b[i].cost;
			if(d[to]>cost) {
				d[to]=cost;
				if(!vis[to])
					vis[to]=1,
					p.push(to);
			}
		}
	}
}
inline void Dijstra() {//求整体的最短路
	int i,to,p,t,cost;
	bool vis[N][Mn];
	priority_queue<node>Q;Q.push(node(1,1,0));
	memset(s,INF,sizeof(s));s[1][1]=0;
	memset(vis,0,sizeof(vis));
	while(!Q.empty()) {
		p=Q.top().p,t=Q.top().t,Q.pop();
		if(vis[p][t]||t>T) continue;vis[p][t]=1;
		for(i=head[p];i;i=b[i].nxt) {
			to=b[i].to;if(gg[to][t]) continue;
			cost=b[i].cost+s[p][t];
			if(s[to][t]>cost) {
				s[to][t]=cost;
				Q.push(node(to,t,cost));
			}
		}
		if(p==1) {//特别的操作，其实就是为了减少连边数（有俩个关键字太烦了
			for(i=hed[t];i;i=b[i].nxt) {
				to=b[i].to,cost=b[i].cost+s[p][t];
				if(s[n][to]>cost) {
					s[n][to]=cost;
					Q.push(node(n,to,cost));
				}
			}
		}
		else if(p==n) {//这种情况直接特判，不用连边（因为太烦了
			if(s[1][t+1]>s[n][t]+K) {
				s[1][t+1]=s[n][t]+K;
				Q.push(node(1,t+1,s[1][t+1]));
			}
		}
	}
}
int main()
{
	int i,j,k,l,r,x,y,cost;
	T=read(),n=read(),K=read(),m=read();
	for(i=1;i<=m;i++)
	{
		x=read(),y=read(),cost=read();
		if(x==n) swap(x,y);//建图的时候n点连的是单向边
		if(y!=n) Add(y,x,cost);
		Add(x,y,cost);
	}
	D=read();
	while(D--) {
		x=read(),l=read(),r=read();
		for(i=l;i<=r;i++) gg[x][i]=1;//gg就是不能用
	}
	for(i=1;i<T;i++) {//枚举i
		for(k=1;k<=n;k++) usd[k]=gg[k][i];//
		for(j=i+1;j<=T;j++) {
			for(k=1;k<=n;k++) usd[k]|=gg[k][j];
			Spfa();if(d[n]!=INF) add(i,j,d[n]*(j-i+1));//如果不连通，就不能连，否则就会嘿嘿嘿
		}
	}Dijstra();
	printf("%d",s[n][T]);
	return 0;
}
```



---

## 作者：lzqy_ (赞：13)

模拟赛考了这题，啥都不会的我用了模拟退火骗了60pt……

但实际上用模拟退火确实能做，算是提供一个新思路吧。

## 思路

我们先假设已经知道了什么时候要改变线路。那么久会有一个很显然的做法：对于每一个不改变线路的区间跑最短路，保证不经过任意不能经过的道路。

但现在的问题是无法确定改变线路的时间。所以考虑模拟退火。

设一个数组 $c$，第 $i$ 位表示第 $i$ 天的状态。$1$ 为当天改变线路，$2$ 为当天不改变线路。

对于 $c$ 数组跑模拟退火即可。

## 代码

代码中有注释。

```cpp
#include<bits/stdc++.h>
#define pb push_back
using namespace std;
const int maxn=110;
const int inf=1061109567;
const double T=100000;
const double d=0.998;
const double e=0.001; 
inline int read(){
	register int x=0;
	register char c=getchar();
	for(;!(c>='0'&&c<='9');c=getchar());
	for(;c>='0'&&c<='9';c=getchar())
		x=(x<<1)+(x<<3)+c-'0';
	return x;
}
vector<int>v[maxn],w[maxn];
int a[maxn][maxn],f[maxn];
int pre[maxn][maxn];
bool c[maxn],ok[maxn],vis[maxn];
int n,m,B,K,ans=inf;
queue<int>q;
double rand_(){
	return (rand()%10000)/10000.0;
}
int spfa(){
	memset(f,0x3f3f3f,sizeof(f));
	f[1]=0,vis[1]=1,q.push(1);	
	register int t;
	while(!q.empty()){
		t=q.front(),q.pop(),vis[t]=0;
		for(register int i=0;i<v[t].size();i++)
			if(ok[v[t][i]]&&f[v[t][i]]>f[t]+w[t][i]){
				f[v[t][i]]=f[t]+w[t][i];
				if(!vis[v[t][i]])
					vis[v[t][i]]=1,q.push(v[t][i]);
			}
	}
	return f[m];
}
int Solve(){
	register int l=1,r=1,x;
	register long long sum=0;
	while(r<=n){
		while(r+1<=n&&!c[r]) r++;
     //找到当前区间的l,r边界
		for(register int i=1;i<=m;i++)
			ok[i]=(pre[i][r]-pre[i][l-1]==0);
      //判断哪些点可以走
		x=spfa();//跑最短路
		if(x==inf) return inf;
		sum+=(r-l+1)*1ll*spfa();
		l=++r,sum+=K;
	}
	return sum-K;//改变线路数=区间数-1
}
void SA(){
	register int x,y,sum,nowans=Solve();
	for(register double t=T;t>=e;t*=d){
		x=rand()%n+1,y=rand()%n+1;
		c[x]^=1,c[y]^=1;//随机改变c数组
		sum=Solve();		
		if(sum<nowans||exp((nowans-sum)/t)>=rand_())
			ans=min(nowans,ans),nowans=sum;
		else c[x]^=1,c[y]^=1; 
	}
	ans=min(ans,nowans);
}
int main(){
	srand(1145810);
   //您需要一个非常臭的随机种子
	n=read(),m=read(),K=read(),B=read();
	register int x,y,z,Time=clock();
	while(B--){
		x=read(),y=read(),z=read();
		v[x].pb(y),v[y].pb(x);
		w[x].pb(z),w[y].pb(z);
	}
	B=read();
	while(B--){
		x=read(),y=read(),z=read();
		for(register int i=y;i<=z;i++) 
			pre[x][i]=1;
	}
	for(register int i=1;i<=m;i++)
		for(register int j=1;j<=n;j++)
			pre[i][j]+=pre[i][j-1];
	while((clock()-Time)*1.0/CLOCKS_PER_SEC<=0.75) SA();
   //不断跑模拟退火(实际上只够跑一遍,还要开O2才能跑过)
	printf("%d\n",ans);
	return 0;
}
```
祝AC。


---

## 作者：KingBenQi (赞：10)

Solution
---
这道题是一道非常好的spfa的题
题目中的变化点就是再给定的时间区间内会对有些码头进行封锁
这就需要对于特定的时间区域内进行枚举
所以我们ww[i][j]跑spfa就是再i到j天的时间内跑出的最短路
dp就很简单且容易思考了@Tyher
```
#include<bits/stdc++.h>
#define N 21
#define M 200
#define LL long long
using namespace std;
inline int gi(){
    char ch=getchar();int x=0,q=0;
    while(ch<'0' || ch>'9') ch=='-'?q=1:0,ch=getchar();
    while(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();
    return q?(-x):x;
}
int n,m,k,e,d;
struct Edge{
	int next,to,w;
}h[M<<1];
int block[N][105],ww[105][105];
LL dp[105];
int tot,head[N];
int dis[N],exist[N];
bool vis[N];
void Add(int u,int v,int w){
	h[++tot].next=head[u];
	h[tot].to=v;
	h[tot].w=w;
	head[u]=tot;
}
queue<int >q;
int spfa(int a,int b){
	memset(dis,63,sizeof(dis));
	memset(vis,0,sizeof(vis));
	for(int i=1;i<=m;i++) exist[i]=1;
	for(int i=1;i<=m;i++)
		for(int j=a;j<=b;j++)
			if(block[i][j])
				exist[i]=0;
    q.push(1);vis[1]=1;dis[1]=0;
    while(!q.empty()){
        int u=q.front();q.pop();vis[u]=0;
        for(int i=head[u];i;i=h[i].next){
            int v=h[i].to;
            if(!exist[v]) continue;
            if(dis[u]+h[i].w<dis[v]){
                dis[v]=dis[u]+h[i].w;
                if(!vis[v]) q.push(v),vis[v]=1;
            }
        }
    }
    return dis[m];
}
int main(){
	//freopen("trans.in","r",stdin);
	//freopen("trans.out","w",stdout);
    n=gi();m=gi();k=gi();e=gi();
	for(int i=1,u,v,w;i<=e;i++){
		u=gi();v=gi();w=gi();
		Add(u,v,w);Add(v,u,w);
	}
	d=gi();
	for(int i=1,p,a,b;i<=d;i++){
		p=gi();a=gi();b=gi();
		for(int i=a;i<=b;i++) block[p][i]=1;
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			ww[i][j]=spfa(i,j);
	for(int i=1;i<=n;i++){
		dp[i]=(LL)ww[1][i]*i;
		for(int j=1;j<i;j++)
			dp[i]=min(dp[i],dp[j]+k+(LL)ww[j+1][i]*(i-j));
	}
	cout<<dp[n]<<endl;
	return 0;
}

```

---

## 作者：xieyuhao2022 (赞：6)

## 题意简述

给定一张无向图，每天都要从点 $1$ 走到点 $m$，而每天分别有一些点不能经过，如果要改变上一次的路线走到终点，要花费 $k$ 的成本，如何使得总花费最小。

## 算法分析

很明显，我们每天都要跑一次最短路，将不能走的点在预处理中标记出来，方便在跑图时判断。

那么如何使得总花费最小呢？我们不难想到，可以用 $sum(i,j)$ 表示从第 $i$ 天到 $j$ 天，点 $1$ 到点 $m$ 的最短路距离，再用 $f(i)$ 表示前 $i$ 天所需的最小成本。

那么我们推出转移方程： 

$$f(i)=\operatorname{min} (f(j)+sum(j+1,i)\times (i-j)+k)$$

这个方程的意思是，第 $i$ 天的最小成本取决于第 $j$ 天开始到第 $i$ 天的最短路长度乘上天数再加上改变的花费，总的时间复杂度在 $O(n^3\log m)$。

这样这道题就做完了，是一道不错的动态规划和最短路的练手题。

## 代码实现

```cpp
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
int n,m,k,E,d,head[500],tot;
int len[105][105]; bool dy[25][105];
long long f[105];
struct E{
	int to,nxt,w;
}edge[1000];
inline void add(int u,int v,int w){
	edge[++tot].to=v;
	edge[tot].nxt=head[u];
	edge[tot].w=w;
	head[u]=tot;
}
inline int spfa(int x,int y){
	int dis[25]; bool vis[25],inq[25];//在原基础上增加一个标记点的数组
	memset(dis,0x3f,sizeof(dis));
	memset(vis,0,sizeof(vis));
	memset(inq,0,sizeof(inq));
	for(register int i=1;i<=m;i++)
	for(register int j=x;j<=y;j++)
		if(dy[i][j]) inq[i]=1;
	dis[1]=0,vis[1]=1;
	queue<int> q;
	q.push(1);
	while(!q.empty()){
		register int u=q.front();q.pop();
		vis[u]=0;
		for(register int i=head[u];i;i=edge[i].nxt){
			register int v=edge[i].to,w=edge[i].w;
			if(inq[v]) continue;
			if(dis[u]+w<dis[v]){
				dis[v]=dis[u]+w;
				if(!vis[v]){
					vis[v]=1;
					q.push(v);
				}
			}
		}
	}
	return dis[m];
}
int main()
{
	scanf("%d%d%d%d",&n,&m,&k,&E);
	for(register int i=1;i<=E;i++){
		register int x,y,h;
		scanf("%d%d%d",&x,&y,&h);
		add(x,y,h),add(y,x,h);//加边
	}
	scanf("%d",&d);
	for(register int i=1;i<=d;i++){
		register int p,a,b;
		scanf("%d%d%d",&p,&a,&b);
		for(register int j=a;j<=b;j++)
			dy[p][j]=1;//dy[p][j]表示第p个点在第j天能否通过
	}
	for(register int i=1;i<=n;i++){
		for(register int j=1;j<=n;j++)
			len[i][j]=spfa(i,j);
	}
	for(int i=1;i<=n;i++){ 
		f[i]=(long long)len[1][i]*i;
		for(int j=1;j<=i;j++)
			f[i]=min(f[i],f[j]+(long long)len[j+1][i]*(i-j)+k);
	}//dp，注意将变量转化为long long
	printf("%lld",f[n]);
	return 0;
}
```

---

## 作者：Goes (赞：6)

今天真开心。。。想发题解(⊙o⊙)…


```cpp
//[ZJOI2006]物流运输  luogu.P1772 
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
```
/\*题解：
动规g[i][j]表示i到j天一直用同一条最短路的最小费用

即i到j天不改路线的最短路   spfa(i,j)求g[i][j]就好了

至于某个点在这段时间内是不是被更改过的判断

看下面的sum数组，我们称之为奇妙判断法，啧。

动规f[i]表示从第1天到第i天的最小花费

        =min(f[i],f[j]+g[j+1][i]\*(i-j)+K)

\*/
```cpp
inline int read(){
    char ch=getchar();int num=0;
    while(ch<'0'||ch>'9') ch=getchar();
    while(ch>='0'&&ch<='9')
        num*=10,num+=ch-'0',ch=getchar();
    return num;
}
const int N=105,M=25;
const int E=10005;
```
/\*
The game played by G.S.M. && Goes

It has started

Come on , boy!

\*/
            

```cpp
struct ss{
    int to,nex,va;
}edge[E];
int head[M],ecnt,sum[M][N];
void add(int va,int x,int y){
    edge[++ecnt]=(ss){y,head[x],va};
    edge[++ecnt]=(ss){x,head[y],va};
    head[x]=ecnt-1;head[y]=ecnt;
}void mark(int e,int s,int pos){
    for(int i=s;i<=e;i++)
        sum[pos][i]=1;
}
int n,m,K,e,d;
int g[N][N],f[N];
inline void gsin(){
    n=read(),m=read(),K=read(),e=read();
    for(int i=1;i<=e;i++)
        add(read(),read(),read());
    for(int i=1;i<=n;i++) f[i]=9999999;
    //奇妙标记法 
    d=read();//sum[pos][r]-sum[pos][l]!=0说明不可以
    for(int i=1;i<=d;i++) 
        mark(read(),read(),read());
    for(int i=1;i<=m;i++)
        for(int j=1;j<=n;j++)
            sum[i][j]+=sum[i][j-1];
}
inline void gsout(){
    printf("%d",f[n]-K);
}
int dis[M],vis[M];
int spfa(int l,int r)
{
    for(int i=1;i<=m;i++) dis[i]=999999,vis[i]=0;
    queue<int> q;
    q.push(1);dis[1]=0;vis[1]=1;
    while(!q.empty()){
        int sn=q.front();q.pop();vis[sn]=0;
        for(int i=head[sn];i;i=edge[i].nex){
            int fn=edge[i].to,val=edge[i].va;
            if(sum[fn][r]-sum[fn][l-1]||
                dis[fn]<=dis[sn]+val) continue;
            dis[fn]=dis[sn]+val;
            if(!vis[fn]){
                vis[fn]=1;
                q.push(fn);    
            }
        }
    }
    return dis[m];
}
inline void gsdp(){
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            g[i][j]=spfa(i,j);
    f[0]=0;
    for(int i=1;i<=n;i++)
        for(int j=0;j<i;j++)
            f[i]=min(f[i],f[j]+g[j+1][i]*(i-j)+K);
}
int main()
{
    gsin();
    gsdp();
    gsout();
    return 0;
}
```

---

## 作者：WanderOvO (赞：4)

本文将先讲一种我独立想出来的思路（不敢保证其正确性），然后再对最高赞的那篇题解的一些细节进行补充说明。
## 我的思路

考虑到切换路径有额外花费，所以不一定每次选择最短路就能得到最优解，所以不一定每次都选择最短路走。看到数据范围说只进行了100次物流运输，并且图只有20个点，所以可能考虑用搜索的方式去求最优解：每次运输，把能从1走到m的都试一试，dfs下去，刷新最优解。不过想要找到某次运输时所有的能从1走到m的路，不出意外肯定会超时。

由于是求最值，并且涉及决策，所以可能用到dp，一步一步来。

我最初想法是设$f[i]$为前i次运输的最小的消耗，如果这样定义，那么转移时要根据第i次的码头的可用的情况和第i次和第i-1次选的路一不一样来推转移方程。但是仅靠一维的状态，我自己没有想出来在已知$f[i-1]$时，如何知道第$i-1$次选的哪条路（所以我感觉最高赞题解很厉害）。

于是我思考如何通过加一维状态来表示出上一次是选择的哪条路。如果能预处理所有的1到m的路径，状压表示每条路径走过的点，那就可以用唯一的id来表示每种航线了，那么我们可以定义$f[i][j]$表示前i次运输，并且第i次运输采取的是id为j的航线方案，所达到的最小消耗。这样的话，考虑$f[i+1][d]$，其中d表示第$i+1$次能走的那些航线中的某个的$id$，那么转移方程为：$f[i+1][d]=min\{f[i][d]+len[d],min_{j\ne d } \{f[i][j]+len[d]\}+k\}$  ,其中$min_{j\ne d } \{f[i][j]+len[d]\}$指的是前i次运输的最小值，并且第$i$次运输选择了路线$j$，这个$j$可以取所有的第$i$次可走且$j \ne d$ 的路。由于只有20个点，且对于一条路径来说，每个点只有选与不选两种情况，并且这个问题还给定了起点和终点，那么至多有$2^{18}$种路径。这个大概就是我的思路了，写代码的时候，发现难以把空间控制在125MB之内，且速度也不太行，前3个点MLE了，后7个点TLE。目前只知道过了样例和几组手造数据。由于我不太会自动生成这道题目的合法的数据，所以也没和std对拍，所以这个方法的正确性还有待商榷。这个的代码由于比较长且爆零所以就不放了。

## 对最高赞题解的一些细节的说明

题解中一种思路是这样的：设$f[i]$表示前i次运输消耗的最小值，然后用一种分段的思想：虽然切换路径有开销导致每一段不一定选择最短路最合适，但是，可以确定的是，最后一段肯定是要选择最短路的，因为它是最后一段，不需要再切换成别的路了。所以，考虑枚举一个j，转移方程是$f[i]=min\{f[i],f[j-1]+(i-j+1)*minlen+k\}$ ，这个转移方程中$min$的后一项的意思是：前$j-1$天的运输最小值$f[j-1]$加上第$j$到第$i$天全部选择长度为$minlen$的最短路（与第$j-1$天不同）再加上一次切换开销$k$ 。枚举所有的$j$，能算出来一系列的值，取其中的最小值，就是$f[i]$了。这样就巧妙地利用了最短路径。初始化的话，我最开始简单地认为，$f[1]$可算，后面的都初始化成无穷大就可以了；想转移的时候，突然发现了一些问题：如何保证第$j$次和第$j-1$次选的路径是不同的呢？似乎我们还是要存储一下之前选的是哪条路，那样岂不是又要状压了？空间不还是会爆吗？先考虑一下还有没有其他问题，假设我们保证了$j-1$次和$j$次选择不同的路，那么我们只需要在枚举$j$ 的时候求有限制点的最短路就好了，由于图很小，所以完全可以每次单独求，用裸的dijkstra就可以。

下面回到刚才的疑问：如何保证第$j-1$天和第$j$天选的路径是不一样的？在看题解作者的代码之前，我也是很懵逼的，在看了之后，豁然开朗了。作者在dp时初始化$f[0]=-k$，虽然$f[0]$看似是个根本没用的东西，但是作者还是用它来做一些了不起的事情。不妨假设为了保证$f[3]$最小，前3天选的路需要是一样的，我们把它叫做$path1$，那么算$f[2]$ 时，由于前两次的限制条件和前三次的不一定一样，所以或许$f[2]$ 时不会选$path1 $(当然也可能会选)，我们把$f[2]$ 时选的那条路叫$path2$。如果$path1\ne path2 $，那么不难看出来转移方程是没有问题的。那如果$path1=path2$呢？由于前3天都要选$path2$，所以转移时如果按照转移方程，最终就是$f[3]=min\{f[3],f[0]+3*minlen+k,f[1]+2*minlen'+k,f[2]+minlen''+k\}$，由于最优解是三天都是$path1$，没切换线路，所以只有当$f[0]=-k$ 的时候，我们才能保证转移方程的正确性。所以，不需要再记录上次选了哪条路。

这样分析下来，本题的代码就只剩下几行dp和一个带限制的最短路了，dp的初始化和转移方式经过补充也应该可以写出来了。

代码如下：

```cpp
#include <bits/stdc++.h>
#define ll long long
#define INF 99999999999
using namespace std;
const int N=1e2+9;
const int M=22; 
typedef struct{
	ll to,nxt,weight;
}Edge;
Edge edge[M*(M-1)];
ll dist[M],f[N],cnt,head[M],n,m,k,e,unable[N][M],sign[M],vis[M];
ll dijkstra();
void add(ll x,ll y,ll z);
int main(){
	ll x,y,z,d,p,a,b;
	scanf("%lld %lld %lld %lld",&n,&m,&k,&e);
	for(int i=0;i<=m;i++){
		head[i]=-1; 
	} 
	while(e--){
		scanf("%lld %lld %lld",&x,&y,&z);
		add(x,y,z);
		add(y,x,z);
	}
	scanf("%lld",&d);
	while(d--){
		scanf("%lld %lld %lld",&p,&a,&b);
		for(int i=a;i<=b;i++){
			unable[i][0]++; //第i天不能用的港口+1 
			unable[i][unable[i][0]]=p; //第p个港口在a-b天不能用 
		}
	}
	f[0]=-k; //保证j-1和j选的路不同，即使相同也不会出错 
	for(int i=1;i<=n;i++){
		f[i]=INF; 
	}
	for(int i=1;i<=n;i++){
		for(int j=0;j<=m;j++){ //把不能走的点先设为空 
			sign[j]=0;
		}
		for(int j=i;j>=1;j--){ //不断增加不能走的点，直到根本没法走 
			for(int l=1;l<=unable[j][0];l++){
				sign[unable[j][l]]=1; //标记为不可走 
			}
			ll len=dijkstra();
			if(len==INF) { //路不通就不能走了 
				break;
			}
			f[i]=min(f[i],f[j-1]+len*(i-j+1)+k);
		}
	}
	printf("%lld\n",f[n]);
	return 0;
}
ll dijkstra(){
	for(int i=0;i<M;i++){
		dist[i]=INF;
		vis[i]=0;
	}
	dist[1]=0;
	ll pos=0,minlen=INF;
	for(int i=0;i<m;i++){
		minlen=INF;
		pos=0;
		for(int j=1;j<=m;j++){
			if(!vis[j] && !sign[j] && dist[j]<minlen){ //没找到最短路且可以走 
				minlen=dist[j];
				pos=j;
			}
		}
		if(pos==0){ //因为不可走，所以没找到 
 			break;
		}
		vis[pos]=1;
		for(ll j=head[pos];j>=0;j=edge[j].nxt){
			if(!vis[edge[j].to] && !sign[edge[j].to]){
				dist[edge[j].to]=min(dist[edge[j].to],dist[pos]+edge[j].weight);
			}
		}
	}
	return dist[m];
}
inline void add(ll x,ll y,ll z){
	edge[cnt].to=y;
	edge[cnt].nxt=head[x];
	edge[cnt].weight=z;
	head[x]=cnt++;
}
```



---

## 作者：Ginger_he (赞：3)

# 题目描述
求 $\min\left\{\sum_{i=1}^ndis(1,m)\right\}$，其中 $dis(a,b)$ 表示 $a$ 到 $b$ 的最短路，$i$ 表示第 $i$ 天，且一些点在某些时间段无法到达。
# 题解
设 $dp_i$ 为前 $i$ 天费用的最小值，不难想到状态转移方程为：  
$dp_i=\max\left\{dp_i,dp_{j-1}+f_{j,i}\times(i-j+1)+k\right\}$  
即从第 $j$ 天到第 $i$ 天改变运输路线。注意到状态转移方程中出现了 $f_{j,i}$，表示第 $j$ 天到第 $i$ 天码头 $A$ 到码头 $B$ 的最短路，因此需要预处理最短路(SPFA 或 dijkstra)。
## 代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node
{
	int v;
	int w;
}; 
int n,m,k,e,d,u,v,w,dis[105];
long long f[105][105],dp[105];
vector<node> g[25];
queue<int> q;
bool p[25][105],c[25],vis[25];
int spfa()
{
	memset(dis,0x3f,sizeof(dis));
	memset(vis,false,sizeof(vis));
	q.push(1);
	dis[1]=0;
	while(!q.empty())
	{
		int tmp=q.front();
		q.pop();
		vis[tmp]=false; 
		for(int i=0;i<g[tmp].size();i++)
		{
			v=g[tmp][i].v,w=g[tmp][i].w;
			if(c[v])
				continue;
			if(dis[tmp]+w<dis[v])
			{
				dis[v]=dis[tmp]+w;
				if(!vis[v])
				{
					vis[v]=true;
					q.push(v);
				}
			}
		}
	}
	return dis[m];
}
int main()
{
	memset(dp,0x3f3f3f3f,sizeof(dp));
	scanf("%d%d%d%d",&n,&m,&k,&e);
	for(int i=1;i<=e;i++)
	{
		scanf("%d%d%d",&u,&v,&w);
		g[u].push_back(node{v,w});
		g[v].push_back(node{u,w});
	}
	scanf("%d",&d);
	for(int i=1;i<=d;i++)
	{
		scanf("%d%d%d",&u,&v,&w);
		for(int j=v;j<=w;j++)
			p[u][j]=true;//p[i][j]表示码头i在第j天是否可以到达 
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=i;j<=n;j++)
		{
			memset(c,false,sizeof(c));
			for(int k=1;k<=m;k++)
			{
				for(int l=i;l<=j;l++)
				{
					if(p[k][l])
					{
						c[k]=true;//存在一天无法到达则在这段时间中都无法到达 
						break;
					}
				}
			}
			f[i][j]=spfa();//求第i天到第j天码头A到码头B的最短路 
		}
	}
	for(int i=1;i<=n;i++)
	{
		dp[i]=f[1][i]*i;//前i天走同一条路
		for(int j=i;j>=1;j--)
			dp[i]=min(dp[i],dp[j-1]+f[j][i]*(i-j+1)+k);//第j到第i天改变运输路线
	}
	printf("%lld\n",dp[n]);
	return 0;
}
```

---

## 作者：_Amadeus_ (赞：3)

由于数据范围较小，我们可以随便暴力解决这个问题。

我们采取dijkstra算法找到最短路，如果我们设置点x不能通过，那么在算法开始之前，就让vis[x]是true，这样算出的dis[m]值就是不通过点x时，从1到m的最短路。

设dp[i]是第i天的最小代价，显然开始时dp[0] = 0。

开始时dp[i]等于在第1天到第i天的所有被封的点没法走的情况下，跑dijkstra之后的dis[m]的值乘以i。

我们考虑转移方程，我们可以枚举上一次改变路径是第j天(0 <= j < i),那么在封锁了第j+1天到第i天的所有不可达点后，跑dijkstra:

dp[i] = min(dp[i], dp[j] + (i - j) * dis[m] + k);

记得开long long,注意数组范围

贴上我的AC代码：
```cpp
#include<bits/stdc++.h>
#define LL long long
#define maxn 25
#define maxe 1000
#define inf 0x3f3f3f3f
using namespace std;

struct Node{
	int t, next;
	LL c;
	Node(int _t, LL _c, int _next){
		t = _t;
		c = _c;
		next = _next;
	}
	Node(){
		
	} 
	bool operator < (Node n) const{
		return c > n.c;
	}
};

vector<int> nt[maxn];

Node ed[maxe];

int head[maxn], tot;

LL dis[maxn], dp[110];

bool vis[maxn];

void addedge(int f, int t, LL c){
	ed[tot] = Node(t, c, head[f]);
	head[f] = tot++;
}

priority_queue<Node> p;

void dijkstra(int s, int t){
	p.push(Node(s, 0, 0));
	for(int i = 0; i < maxn; ++i){
		dis[i] = inf;
	}
	while(!p.empty()){
		Node now = p.top();
		p.pop();
		if(vis[now.t]){
			continue;
		}
		vis[now.t] = true;
		dis[now.t] = now.c;
		for(int i = head[now.t]; i != -1; i = ed[i].next){
			p.push(Node(ed[i].t, now.c + ed[i].c, 0));
		}
	}
}

int main(){
	int n, m, e;
	LL K;
	scanf("%d %d %lld %d", &n ,&m, &K, &e);
	int f, t;
	LL c;
	memset(head, -1, sizeof head);
	tot = 0;
	for(int i = 0; i < e; ++i){
		scanf("%d %d %lld", &f, &t, &c);
		addedge(f, t, c);
		addedge(t, f, c);
	}
	int ti, l, r, now;
	scanf("%d", &ti);
	for(int i = 0; i < ti; ++i){
		scanf("%d %d %d", &now, &l, &r);
		for(int j = l; j <= r; ++j){
			nt[j].push_back(now);
		}
	}
	dp[0] = 0;
	for(int i = 1; i <= n; ++i){
		memset(vis, 0, sizeof vis);
		for(int j = 1; j <= i; ++j){
			for(int k = 0; k < nt[j].size(); ++k){
				vis[nt[j][k]] = 1;
			}
		}
		dijkstra(1, m);
		dp[i] = dis[m] * i;
		for(int j = 0; j < i; ++j){
			memset(vis, 0, sizeof vis);
			for(int k = j + 1; k <= i; ++k){
				for(int x = 0; x < nt[k].size(); ++x){
					vis[nt[k][x]] = 1;
				}
			}
			dijkstra(1, m);
			dp[i] = min(dp[i], dp[j] + (i - j) * dis[m] + K);
		}
	}
	printf("%lld\n", dp[n]);
	return 0;
}
```
我觉得我的代码还是比较好理解的吧。。。

---

## 作者：yangyujia18 (赞：3)

首先，因为数据小，最短路怎么跑都不会超时~~只要你不作死用Floyd~~  
然后，用dp找最优解  
ans[i][j]表示第i日到第j日的码头都封上的最短路长度（有可能没有所以都初始化为INF）  
f[i]表示前i天的最小花费  
初始化：  
ans=INF，f[0]=0  
转移方程：
f[i]=min(f[i],f[j]+ans[i][j+1]*(i-j)+k)  
上代码！
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAX=25;
const long long INF=200005;
int n,m,k,e,d;
long long sea[MAX][MAX],st[105],ed[105],po[105],ans[105][105],f[105];
bool use[MAX];
long long dijkstra()//数据小，妈妈再也不会担心MLE啦
{
	int start,end;
	long long dist[MAX];
	bool went[MAX];
	for(int i=1;i<=m;i++)
	{
		dist[i]=sea[1][i];
		went[i]=false;
	}
	dist[1]=0;
	went[1]=true;
	for(int i=2;i<=m;i++)
	{
		int tmp=INF;
		for(int j=1;j<=m;j++)
		{
			if(sea[i][j]!=INF&&!went[j]&&tmp>dist[j]&&use[j])
			{
				tmp=dist[j];
				start=j;
			}
		}
		went[start]=true;
		for(end=1;end<=m;end++)
			if(sea[start][end]!=INF&&start!=end)
				dist[end]=min(dist[end],dist[start]+sea[start][end]);
	}
	return dist[m];
}
int main()
{
	cin>>n>>m>>k>>e;
	for(int i=0;i<MAX;i++)
		for(int j=0;j<=MAX;j++)
			sea[i][j]=INF;
	for(int i=0;i<e;i++)
	{
		int x,y,c;
		cin>>x>>y>>c;
		sea[x][y]=sea[y][x]=c;
	}
	cin>>d;
	for(int i=1;i<=d;i++)
	{
		int p,a,b;
		cin>>p>>a>>b;
		st[i]=a;
		ed[i]=b;
		po[i]=p;
	}
	memset(ans,0,sizeof(ans));
	for(int l=0;l<=n;l++)
		for(int i=1;i+l<=n;i++)
		{
			for(int j=0;j<=MAX;j++)
				use[j]=true;
			for(int j=1;j<=d;j++)
				for(int k=i;k<=i+l;k++)
					if(k>=st[j]&&k<=ed[j])
						use[po[j]]=false;
			ans[i][i+l]+=dijkstra();
		}
	f[0]=0;
	f[1]=ans[1][1];
	for(int i=2;i<=n;i++)
	{
		f[i]=ans[1][i]*i;
		for(int j=i-1;j>=0;j--)
			f[i]=min(f[i],f[j]+ans[j+1][i]*(i-j)+k);
	}
	cout<<f[n]<<endl;
	return 0;
}
```
强推我的博客  
[传送门](https://www.luogu.org/blog/cowcowcow/)  
第5次交题解~~前几次几乎都没过嘤嘤嘤~~

---

## 作者：s_a_b_e_r (赞：3)

##最短路+floyd

看到这么多的SPFA，最短路不好做QAQ

于是仔细看题之后决定点 数这么少，floyd怎么也是可以吧。

m=20是m^3=8000，加上之前的n^2=10000；按照noip的评测机的性能估计；不超时的说

于是简短的三重循环解决。

但如果中间不加某点，就不要枚举那个就好。（这不知道的话就去在学一遍这个算法）

k[i]表示在这个时间段里第i个点被挖掉了。

然后开始暴力枚举中间点。

dp维护在区间最小值。

成功A掉此题

pd[i][j]表示在第i个时间j点不能用

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#define ll long long 
using namespace std;
const int INT=100000007;
int n,m,K,e,d;
int from,to,wi;
bool pd[133][30];
ll fol[100+99][100+99];
ll dp[100+99];
ll P[30][30];
int map[30][30];
bool k[30];
void G(){
    for(int i=0;i<30;i++)
       for(int j=0;j<30;j++)map[i][j]=INT;
    for(int i=1;i<=n;i++)dp[i]=INT;
}
ll PL(int k1,int k2){
    for(int i=1;i<=m;i++)
       for(int j=1;j<=m;j++)P[i][j]=map[i][j];
    for(int i=2;i<m;i++)
        for(int j=k1;j<=k2;j++)if(pd[j][i]){k[i]=1;break;}
    for(int i=1;i<=m;i++)
    if(!k[i])//没有这行会超时+wa
        for(int j=1;j<=m;j++)
            for(int k=1;k<=m;k++)
                P[j][k]=min(P[j][k],P[j][i]+P[i][k]);
    for(int i=1;i<m;i++)k[i]=0;
    return P[1][m];
}
int main(){
    G();
    cin>>n>>m>>K>>e;
    for(int i=1;i<=e;i++){
    cin>>from>>to>>wi;
    map[from][to]=min(map[from][to],wi);
    map[to][from]=min(map[to][from],wi);
    }
    cin>>d;
    for(int i=1;i<=d;i++){
        cin>>from>>to>>wi;
        for(int j=to;j<=wi;j++)pd[j][from]=1;}
    for(int i=1;i<=n;i++)
       for(int j=1;j<=n;j++)
          fol[i][j]=PL(i,j);
    for(int i=1;i<=n;i++){
    dp[i]=fol[1][i]*i;
      for(int j=0;j<i;j++)dp[i]=min(dp[i],dp[j]+K+fol[j+1][i]*(i-j));
}    cout<<dp[n];
    return 0;
}
```

---

## 作者：Daidly (赞：2)

本质上是最短路+DP。

DP 可以写状压 DP，也可以写线性 DP，这里展示线性 DP。

发现有连续天数最短路线一致，考虑设 $dis(i,j)$ 为第 $i$ 天到第 $j$ 天的最短路

设 $f_i$ 表示前 $i$ 天最少花费，转移方程为 $f_i=\min(f_j+dis(j+1,i)\times(i-j)+k),j\in [0,i)$.

理解为：第 $j+1$ 天到第 $i$ 天走同一条路，并且这条路和第 $j$ 天的路径不同。

更新答案即可，注意细节问题，开 `long long`：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,e,d,a,b,c;
long long dis[101][101],tmp[21],f[101];
bool vis[21],is[21][101];
vector<pair<int,int> >v[200005];
priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > >q;
void add(int uu,int vv,int ww){
	v[uu].push_back({vv,ww});
	v[vv].push_back({uu,ww});
}
int dij(int x,int y){
	memset(tmp,0x3f,sizeof(tmp));tmp[1]=0;
	memset(vis,0,sizeof(vis));
	for(int i=1;i<=m;++i){
		for(int j=x;j<=y;++j){
			if(is[i][j])vis[i]=1;
		}
	}
	q.push(make_pair(0,1));
	while(!q.empty()){
		int u=q.top().second;
		q.pop();
		if(vis[u])continue;
		vis[u]=1;
		for(int i=0;i<v[u].size();++i){
			if(tmp[v[u][i].first]>tmp[u]+v[u][i].second){
				tmp[v[u][i].first]=tmp[u]+v[u][i].second;
				q.push({tmp[v[u][i].first],v[u][i].first});
			}
		}
	}return tmp[m];
}
int main(){
	memset(f,0x3f,sizeof(f));
	cin>>n>>m>>k>>e;
	for(int i=1;i<=e;++i){
		cin>>a>>b>>c;
		add(a,b,c);
	}
	cin>>d;
	for(int i=1;i<=d;++i){
		cin>>c>>a>>b;
		for(int j=a;j<=b;++j){
			is[c][j]=1;
		}
	}
	for(int i=1;i<=n;++i){
		for(int j=i;j<=n;++j){
			dis[i][j]=dij(i,j);
		}
	}
	f[0]=-k;
	for(int i=1;i<=n;++i){
		for(int j=0;j<i;++j){
			f[i]=min(f[i],f[j]+dis[j+1][i]*(i-j)+k);
		}
	}
	cout<<f[n];
	return 0;
}
```

---

## 作者：BzhH (赞：2)

看完这道题，很容易想到需要用最短路，但是只用最短路显然是不行的，因为运输路线不止一条.

所以如果每一天都选择最短的路线答案可能并不是最优，所以这时候就需要考虑DP.

刚开始我想的是用状态压缩把所有可能的路线算出来，但很快就被我否决了，因为时间复杂度显然超了，所以考虑其他方法.

观察样例得出，有可能一段时间内的最短路是一样的，所以考虑定义一个数组$dis_{i,j}$表示第$i$天到第$j$天都可以走的最短的路线.

然后就可以定义状态$f_i$表示前$i$天的最短花费,考虑将n天划分成若干段进行转移即可.

得出状态转移方程
$f_i=\min\limits_{0\le j <i}f_j+(i-j) * (dis_{j+1,i})+k$.

代码
```
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
using namespace std;
const int N = 2e5 + 5;
typedef pair<int, int> PII;
typedef long long ll;

ll dis[105][105], f[105];
int n, m, k, e, dist[25];
int head[N], ver[N], net[N], edge[N], idx;
priority_queue<PII, vector<PII>, greater<PII> > q;
bool is[25][105], vis[25];

void add(int a, int b, int c)
{
    net[idx] = head[a];
    ver[idx] = b;
    edge[idx] = c;
    head[a] = idx++;
}

int Dij(int x, int y)//最短路
{
    memset(dist, 0x3f, sizeof(dist));
    memset(vis, 0, sizeof(vis));
    for (int i = 1; i <= m; i++)
        for (int j = x; j <= y; j++)
            if (is[i][j])
                vis[i] = true;
    q.push(make_pair(0, 1)), dist[1] = 0;
    while (!q.empty())
    {
        int u = q.top().second;
        q.pop();
        if (vis[u])
            continue;
        vis[u] = true;
        for (int i = head[u]; ~i; i = net[i])
        {
            int v = ver[i];
            if (dist[v] > dist[u] + edge[i])
            {
                dist[v] = dist[u] + edge[i];
                q.push({dist[v], v});
            }
        }
    }
    return dist[m];
}

int main()
{
    memset(f, 0x3f, sizeof(f));
    memset(head, -1, sizeof(head));
    scanf("%d%d%d%d", &n, &m, &k, &e);
    for (int i = 1; i <= e; i++)
    {
        int u, v, w;
        scanf("%d%d%d", &u, &v, &w);
        add(u, v, w), add(v, u, w);
    }
    int d;
    scanf("%d", &d);
    for (int i = 1; i <= d; i++)
    {
        int p, a, b;
        scanf("%d%d%d", &p, &a, &b);
        for (int i = a; i <= b; i++)
            is[p][i] = true;
    }
    for (int i = 1; i <= n; i++)
        for (int j = i; j <= n; j++)
            dis[i][j] = Dij(i, j);
    f[0] = -k;
    for (int i = 1; i <= n; i++)
        for (int j = 0; j < i; j++)
            f[i] = min(f[i], f[j] + (i - j) * dis[j + 1][i] + k);  
    printf("%d", f[n]);
}
```


---

## 作者：zzzty___ (赞：2)

# [P1772 [ZJOI2006]物流运输](https://www.luogu.com.cn/problem/P1772)

分析题目，可以想到**最短路**+**动态规划**

### 1.最短路

用dijkstra求最短路.

### 2.预处理

设$sig[i][j]$表示第$i$个港口在第$j$天能否被取，$0$表示可选，$1$表示不可选，在输入中即可预处理掉

设$dis[i][j](i\le j)$表示第$i$天到第$j$天中的最短路.

首先枚举起始天数$i$和终止天数$j$，随后枚举$i$到$j$中的每一天和每一个港口.

设$sel[k](1\le k\le m)$表示第$k$个港口在第$i$天到第$j$天内能否被选取.为了方便计算，设$0$表示可选，$1$表示不可选.

那么可以得出$sel[k]|=sig[k][day](i\le day \le j)$

最后处理出用最短路计算出$dis[i][j]$.

$sel$数组用于最短路计算中.

### 3.动态规划

设$f[i]$表示到第$i$天为止运输的最小成本.

$dis[i][j](i\le j)$表示第$i$到第$j$天中的最短路.

不难写出状态转移方程$f[i]=\min_{0 \le j<i}\{f[j]+(i-j)\times dis[j+1][i]+k\}$

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=100+5,maxm=20+5,maxe=20*19/2+5,inf=0x3f3f3f3f;
int n,m,k,e,D,cnt=0,head[maxm];
int f[maxn],d[maxn],dis[maxn][maxn];
bool sig[maxm][maxn],vis[maxm],sel[maxm];//0->can select 1->can't select
struct Edge
{
	int v,w,nxt;
}edge[maxe<<1];//undirected graph
struct Heap
{
	int id,dis;
	bool operator<(const Heap &t) const
	{return dis>t.dis;}
};
void add(int u,int v,int w)
{
	edge[++cnt].v=v;
	edge[cnt].w=w;
	edge[cnt].nxt=head[u];
	head[u]=cnt;
}
int dij()//dijkstra
{
	memset(d,inf,sizeof(d));
	memset(vis,0,sizeof(vis));
	priority_queue<Heap> q;
	q.push((Heap){1,0});
	d[1]=0;
	while(!q.empty())
	{
		int u=q.top().id;q.pop();
		if(vis[u]) continue;
		vis[u]=1;
		for(int i=head[u];i;i=edge[i].nxt)
		{
			int v=edge[i].v;
			if(sel[v]) continue;//不可选
			if(d[v]>d[u]+edge[i].w)
			{
				d[v]=d[u]+edge[i].w;
				q.push((Heap){v,d[v]});
			}
		}
	}
	return d[m];
}
int main()
{
	memset(sig,0,sizeof(sig));
	memset(dis,inf,sizeof(dis));
	cin>>n>>m>>k>>e;
	for(int i=1;i<=e;i++)
	{
		int u,v,w;
		cin>>u>>v>>w;
		add(u,v,w);
		add(v,u,w);
	}
	cin>>D;
	for(int i=1;i<=D;i++)
	{
		int p,a,b;
		cin>>p>>a>>b;
		for(int j=a;j<=b;j++)
			sig[p][j]=1;
	}
    //处理出dis
	for(int i=1;i<=n;i++)
		for(int j=i;j<=n;j++)
		{
			memset(sel,0,sizeof(sel));
			for(int k=i;k<=j;k++)
				for(int it=1;it<=m;it++)
					sel[it]|=sig[it][k];
			dis[i][j]=dij();
		}
    //dp
	f[0]=0;
	for(int i=1;i<=n;i++)
	{
		f[i]=(dis[1][i]==inf)?inf:dis[1][i]*i;
		for(int j=0;j<i;j++)
		{
			if(dis[j+1][i]==inf) continue;
			f[i]=min(f[i],f[j]+dis[j+1][i]*(i-j)+k);
		}
	}
	cout<<f[n]<<endl;
	return 0;
}
```


---

## 作者：Doubeecat (赞：2)

> [P1772 [ZJOI2006]物流运输](https://www.luogu.com.cn/problem/P1772)
> 
> 物流公司要把一批货物从码头 1 运到码头 $m$。由于货物量比较大，需要 $n$ 天才能运完，共有 $m$ 个码头。
> 
> 物流公司会设计一条固定的运输路线，有的时候某个码头会无法装卸货物。这时候就必须修改运输路线，让货物能够按时到达目的地。
> 
> 一次修改路线会带来 $k$ 的成本。因此物流公司希望能够订一个 $n$ 天的运输计划，使得总成本尽可能地小。
> 
> $n \leq 100,m \leq 20$

## 解题思路：

首先观察下这个题的样例解释，可以发现一个非常重要的思路：

每一个时间段中，**不调整路线**的最短路显然是固定的。

所以我们可以先考虑处理每个时间区间的**不调整路线**的最短路总长度 $f_{l,r}$。

发现全部都是正权边，我们可以使用 Dijkstra 来进行这一过程，只需要在每次松弛时将该区间里被封锁的点去掉即可。

注意，因为我们是对整个时间区间进行最短路处理，所以最后的长度要乘上 $r - l + 1$。

代码实现：
```cpp

read(z);
for (int i = 1;i <= z;++i) {
    int p,a,b;read(p,a,b);
    for (int j = a;j <= b;++j) {
        rea[j][p] = 1;
    }//rea[i][j]表示第i天点j是否被封锁
}

void dijkstra(int l,int r) {
    memset(dis,0x3f,sizeof dis);
    memset(vis,0,sizeof vis);
    memset(now,0,sizeof now);
    priority_queue <node> q;
    for (int i = l;i <= r;++i) {
        for (int j = 1;j <= m;++j) {
            if (rea[i][j]) now[j] = 1;
        }//如果在l - r 里这个点被封锁过，那么我们就不考虑这个点
    }
    dis[1] = 0;
    q.push((node){0,1});
    while (!q.empty()) {
        node p = q.top();q.pop();
        int x = p.num;
        vis[x] = 1;
        for (int i = hd[x];i;i = nxt[i]) {
            int y = to[i];
            if (!vis[y] && !now[y]) {//松弛的时候多加一步判断即可
                if (dis[y] > dis[x] + edg[i]) {
                    dis[y] = dis[x] + edg[i];
                    q.push((node){dis[y],y});
                }
            }
        }
    }
    if (dis[m] != INF) f[l][r] = dis[m] * (r - l + 1);
    //第 l - r 天的 最短路总长度
    else f[l][r] = INF;
}
```

接下来处理一个问题，我们要求的显然是 $f_{1,n}$，但是就如样例那样不连通怎么办？那就需要更改路径了。

注意到，第 $l\dots r$ 天的路径实际上可以先走 $l\dots p$ 的路径，再花费 $k$ 的代价更换到 $p+1 \dots r$ 的路径得到。

换句话说，这个代价事实上满足大段最优解是小段最优解合并来的性质，而这正是 **区间 DP** 所要求的。

并且这里 $k$ 不变，所以直接利用区间 DP 计算即可。

总时间复杂度 $O(n^2 m \log m + n ^ 3)$

## 代码：

```cpp
const int INF = 0x3f3f3f3f;
const int N = 200;
const int M = 400;
int dis[N],f[N][N],d[N][N],n,m,rr,e,z;

int hd[N],nxt[M],edg[M],to[M],tot;
bool vis[N],rea[N][N],now[N];

void add(int u,int v,int w) {to[++tot] = v,edg[tot] = w,nxt[tot] = hd[u],hd[u] = tot;}
void addedge(int u,int v,int w) {add(u,v,w),add(v,u,w);}

struct node {
    int dis,num;
    friend inline bool operator < (const node & a,const node &b) {
        return b.dis < a.dis;
    }
};

void dijkstra(int l,int r) {
    memset(dis,0x3f,sizeof dis);
    memset(vis,0,sizeof vis);
    memset(now,0,sizeof now);
    priority_queue <node> q;
    for (int i = l;i <= r;++i) {
        for (int j = 1;j <= m;++j) {
            if (rea[i][j]) now[j] = 1;
        }
    }
    dis[1] = 0;
    q.push((node){0,1});
    while (!q.empty()) {
        node p = q.top();q.pop();
        int x = p.num;
        vis[x] = 1;
        for (int i = hd[x];i;i = nxt[i]) {
            int y = to[i];
            if (!vis[y] && !now[y]) {
                if (dis[y] > dis[x] + edg[i]) {
                    dis[y] = dis[x] + edg[i];
                    q.push((node){dis[y],y});
                }
            }
        }
    }
    if (dis[m] != INF) f[l][r] = dis[m] * (r - l + 1);
    else f[l][r] = INF;
}

void input() {
    read(n,m,rr,e);
    for (int i = 1;i <= e;++i) {
        int u,v,w;read(u,v,w);
        addedge(u,v,w);
    }
    read(z);
    for (int i = 1;i <= z;++i) {
        int p,a,b;read(p,a,b);
        for (int j = a;j <= b;++j) {
            rea[j][p] = 1;
        }
    }
}

void DP() {
    for (int len = 2;len <= n;++len) {
        for (int i = 1;i + len - 1 <= n;++i) {
            int j = i + len - 1;
            for (int k = i;k <= j;++k) {
                f[i][j] = min(f[i][j],f[i][k] + f[k+1][j] + rr);
            }
        }
    }
}

signed main() {
    input();
    for (int i = 1;i <= n;++i) {
        for (int j = i;j <= n;++j) {
            dijkstra(i,j);
        }
    }
    DP();
    printf("%d",f[1][n]);
    return 0;
}
```

---

## 作者：破忆 (赞：2)

### 题意

有一些港口，每天都需要从1号港口运送货物到n号港口，每条航线都有代价，每天都有一些航线无法使用，修改路线需要一定代价，求一个d天的方案，使得这n天花费最小。


------------


### 分析

先记录每一时刻不能经过的航线
```cpp
	for(int i=1;i<=e;i++){
		int p=read(),x=read(),y=read();
		for(int j=x;j<=y;j++) lnk[j][++lnk[j][0]]=p;
	}
```


如果只有一天，大胆用SPFA刷最短路就行

既然有很多天，假设其中连续的几天不更改航线，对于这几天，有一些航线不能使用，就在刷最短路的时候放弃这些航线。

此处用usd数组记录第i天至第j天不能经过的航线，g[i][j]记录这些天不更改路线的最短路

枚举i和j暴力构造

```cpp
memset(g,63,sizeof g);
INF=g[0][0];
for(int i=1;i<=d;i++)
	for(int j=i;j<=d;j++){
		memset(usd,0,sizeof usd);
		for(int t=i;t<=j;t++)
		for(int tt=1;tt<=lnk[t][0];tt++) usd[lnk[t][tt]]=1;
		SPFA();
		g[i][j]=dis[n];
	}
```

至于SPFA，唯一与模板不同的地方在于标记过的航线不能走

至此，这道题已经解得差不多了

最后我们用f[i]表示前i天的最小代价

DP的转移方程也不难推

f[i]=min(f[j-1]+g[j][i]*(i-j+1)+k)

需要注意的是，如果一共使用了m种路线，额外的花费应该是（m-1）*k，这里多算了一次，初始时f[0]=-k;

```cpp
	memset(f,63,sizeof f);
	f[0]=-k;
	for(int i=1;i<=d;i++){
		int min_x=INF;
		for(int j=i;j;j--){
			if(g[j][i]==INF) continue;
			if(min_x>f[j-1]+g[j][i]*(i-j+1)+k) min_x=f[j-1]+g[j][i]*(i-j+1)+k;
		}
		f[i]=min_x;
	}
```
那么最后的答案就是f[d]


------------

### 解法

DP+SPFA

### 代码
```cpp
#include<bits/stdc++.h>
#define maxd 105
#define maxn 25
using namespace std;
int n,m,k,e,d,tot,mp[maxn][maxn],g[maxd][maxd],lnk[maxd][maxn],dis[maxn],que[maxn],f[maxd],INF;
bool vis[maxn],usd[maxn];
int read(){
	int ret=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}
void SPFA(){
	memset(dis,63,sizeof dis);
	memset(vis,0,sizeof vis);
	int hed=0,til=1;
	dis[1]=0;
	vis[1]=1;
	que[1]=1;
	while(hed!=til){
		hed=(hed+1)%maxn;
		vis[que[hed]]=0;
		for(int j=1;j<=n;j++)
		if(!usd[j]&&mp[que[hed]][j]&&dis[j]>dis[que[hed]]+mp[que[hed]][j]){
			dis[j]=dis[que[hed]]+mp[que[hed]][j];
			if(!vis[j]){
				vis[j]=1;
				til=(til+1)%maxn;
				que[til]=j;
				int nxt=(hed+1)%maxn;
				if(dis[que[nxt]]>dis[que[til]]) swap(que[nxt],que[til]);
			}
		}
	}
}
int main(){
	//freopen("P1772.in","r",stdin);
	//freopen("P1772.out","w",stdout);
	d=read(),n=read(),k=read(),e=read();
	for(int i=1;i<=e;i++){
		int x=read(),y=read(),z=read();
		if(!mp[x][y]||mp[x][y]>z) mp[x][y]=mp[y][x]=z;
	}
	e=read();
	for(int i=1;i<=e;i++){
		int p=read(),x=read(),y=read();
		for(int j=x;j<=y;j++) lnk[j][++lnk[j][0]]=p;
	}
	memset(g,63,sizeof g);
	INF=g[0][0];
	for(int i=1;i<=d;i++)
	for(int j=i;j<=d;j++){
		memset(usd,0,sizeof usd);
		for(int t=i;t<=j;t++)
		for(int tt=1;tt<=lnk[t][0];tt++) usd[lnk[t][tt]]=1;
		SPFA();
		g[i][j]=dis[n];
	}
	memset(f,63,sizeof f);
	f[0]=-k;
	for(int i=1;i<=d;i++){
		int min_x=INF;
		for(int j=i;j;j--){
			if(g[j][i]==INF) continue;
			if(min_x>f[j-1]+g[j][i]*(i-j+1)+k) min_x=f[j-1]+g[j][i]*(i-j+1)+k;
		}
		f[i]=min_x;
	}
	printf("%d\n",f[d]);
	return 0;
}
```


---

## 作者：约修亚_RK (赞：2)

写完输入隔了几天才写这题结果搞混变量名搞错维度白挂了好几次（趴）

前面各位都是用的SPFA，我用的是Dijkstra（从结果上看好像是比较慢（不过大概是STL常数问题））。

这题的本体就是一个DP，最短路函数设为cost(left, right)表示[left, right]这段时间内都可以走的道路所需要的代价（最短路长度乘以总天数）。

一维空间的DP，设一个k从第一天遍历到最后一天。再设一个i，从第二天遍历到第k天，决策是是否在第i天断开（也就是更换最短路）。

写出转移方程的话，就是这样：

```cpp
f[k] = min(cost(1, k), min(for i = 2, k: f[i-1] + cost(i, k) + changeCost))
```
代码就这几块：最短路，输入，动态规划，输出。

```cpp
/* P1772
 * Au: SJoshua
 */
#include <cstdio>
#include <cstring>
#include <vector>
#include <algorithm>
#include <queue>

using namespace std;

struct edge {
    int u, v, w;
} edges[1000]; 

vector <int> sea[21];

int dp[101], n, lines, days, db;
bool disable[21][101];

struct node {
    int u, d;
    bool operator < (const node &n) const {
        return d > n.d;
    }
};

int cost(int left, int right) {
    priority_queue <node> dij;
    bool visited[21], able[21];
    int dis[21];
    memset(visited, false, sizeof(visited));
    memset(able, true, sizeof(able));
    memset(dis, 0x3f, sizeof(dis));
    for (int k = 1; k <= n; k++) {
        for (int i = left; i <= right; i++) {
            if (disable[k][i]) {
                able[k] = false;
                break;
            }
        }
    }
    dij.push((node){1, 0});
    while (!dij.empty()) {
        node p = dij.top();
        dij.pop();
        if (visited[p.u] || !able[p.u]) {
            continue;
        }
        visited[p.u] = true;
        for (unsigned int k = 0; k < sea[p.u].size(); k++) {
            edge &e = edges[sea[p.u][k]];
            if (able[e.v] && p.d + e.w < dis[e.v]) {
                dij.push((node){e.v, dis[e.v] = p.d + e.w});
            }
        }
    }
    return dis[n] != 0x3f3f3f3f ? dis[n] * (right-left+1) : dis[n];
}

int main(void) {
    int p, a, b, cc;
    scanf("%d %d %d %d", &days, &n, &cc, &lines);
    for (int k = 0; k < lines; k++) {
        scanf("%d %d %d", &edges[k].u, &edges[k].v, &edges[k].w);
        edges[k+lines] = (edge){edges[k].v, edges[k].u, edges[k].w};
        sea[edges[k].u].push_back(k);
        sea[edges[k].v].push_back(k+lines);
    }
    for (scanf("%d", &db); db > 0; db--) {
        scanf("%d %d %d", &p, &a, &b);
        for (int k = a; k <= b; k++) {
            disable[p][k] = true;
        }
    }
    for (int k = 1; k <= days; k++) {
        dp[k] = cost(1, k);
        for (int i = 2; i <= k; i++) {
            dp[k] = min(dp[k], dp[i-1] + cost(i, k) + cc);
        }
    } 
    printf("%d", dp[days]);
    return 0;
}
```

---

## 作者：conprour (赞：1)

# 前言
[【题目传送门】](https://www.luogu.com.cn/problem/P1772)

考前发题解，RP++！！！

管理大大求过 QAQ。
# 题解
看到数据范围这么小，第一反应是可以每一天都跑一次最短路这样类似的预处理。然而单纯对于每一天跑最短路并没有什么意义。

考虑能否设计 DP。首先第一维一定是表示前 $i$ 天。常规的话可能会想到设计第二维表示到达某一个节点之类，但是仔细想想发现没法转移（很难判断两条路线是否相同）。

那么换个思路，由于分段会额外产生贡献，可以发现最优状态下走的最短路是分段的（也就是某一段时间内只走相同的最短路）。那么预处理出每一个时间段内的最短路，暴力枚举时间端点即可，把这段时间内不能走的点都标记上，然后跑 $d^2$ 次最短路。

这样 DP 只需一维：$dp_i$ 表示前 $i$ 天的最小代价，$val(i,j)$ 表示 $[i,j]$ 天里的最短路长度，那么有转移式：
$$dp_i=\max{dp_j+val(j+1,i)\times (i-j)}+k$$

因为第一次不算改变路线，所以要单独初始化，$dp_i=val(1,i)\times i$。

# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define FCC fclose(stdin),fclose(stdout)
#define pr pair<int,ll> 
#define MP make_pair
const int INF = 0x3f3f3f3f,N = 22,M = N*N,D = 105;
inline ll read()
{
	ll ret=0;char ch=' ',c=getchar();
	while(!(c>='0'&&c<='9')) ch=c,c=getchar();
	while(c>='0'&&c<='9') ret=(ret<<1)+(ret<<3)+c-'0',c=getchar();
	return ch=='-'?-ret:ret;
}
int head[N],ecnt=-1;
int d,n,m,k,pass[N][D];
void init_edge(){memset(head,-1,sizeof(head)),ecnt=-1;}
struct edge
{
	int nxt,to,w;
}a[M<<1];
inline void add_edge(int x,int y,int w)
{
	a[++ecnt]=(edge){head[x],y,w};
	head[x]=ecnt;
}
int dis[N];
ll dp[D],val[D][D];
bool vis[N],mp[N];
void dijk()
{
	priority_queue<pr,vector<pr>,greater<pr> >q;
	memset(dis,0x3f,sizeof(dis));
	memset(vis,0,sizeof(vis));
	dis[1]=0ll,q.push(MP(0,1));
	while(!q.empty())
	{
		int u=q.top().second;
		q.pop();
		if(vis[u]) continue;
		vis[u]=1; 
		for(int i=head[u];~i;i=a[i].nxt)
		{
			int v=a[i].to;
		//	printf("%d->%d\n",u,v);
			if(vis[v]||mp[v]) continue;
			if(dis[v]>dis[u]+a[i].w)
			{
				dis[v]=dis[u]+a[i].w;
				q.push(MP(dis[v],v));
			}
		}
	}
}
int main()
{
	init_edge();
	d=read(),n=read(),k=read(),m=read();
	for(int i=1;i<=m;i++)
	{
		int u=read(),v=read(),w=read();
		add_edge(u,v,w),add_edge(v,u,w); 
	}
	int q=read();
	for(int i=1;i<=q;i++)	
	{
		int x=read(),l=read(),r=read();
		for(int j=l;j<=r;j++) pass[x][j]=1;	
	}
	for(int i=1;i<=d;i++)	
		for(int j=i;j<=d;j++)
		{
			memset(mp,0,sizeof(mp));
			for(int u=1;u<=n;u++)
				for(int r=i;r<=j;r++)	
					mp[u]|=pass[u][r];
			dijk();
			val[i][j]=dis[n];
	//		printf("val[%d][%d]=%lld\n",i,j,val[i][j]);
		}
	//memset(dp,0x3f,sizeof(dp)),dp[0]=0ll;
	for(int i=1;i<=d;i++) dp[i]=val[1][i]*i;
	
	for(int i=2;i<=d;i++)	
		for(int j=1;j<i;j++)
			dp[i]=min(dp[i],dp[j]+val[j+1][i]*(i-j)+k);
	printf("%lld\n",dp[d]);
	return 0;
}
```

---

## 作者：神眷之樱花 (赞：1)

### 题外话
此题大家的的方法都大同小异，最短路加动态规划。

以下为详细的解析。
### 题意
把在某天某港口会无法使用的限制去除，其实就是一道经典的最短路模板题，此题的难点就是解决这个限制。
## 解析
此题的数据范围为 $n \leq 100$，$m \leq 20$。

注意题中的一句话：**任何时间都存在至少一条从码头 A 到码头 B 的运输路线。** 所以我们可以枚举出从某天到某天的最短路是多少。

具体思路为：将那段时间内不能使用的港口打上标记，用求最短路算法求出从 $1$ 号港口通过能使用的港口走到 $m$ 号港口的最短路。最后用 $dp$ 求出从第 $1$ 天到第 $n$ 天的最小花费。
### 打标记

```cpp
	day=read();
	for(int i=1;i<=day;i++)
	{
		int nb=read(),l=read(),r=read();//读入港口号，左端点，右端点。
		for(int j=l;j<=r;j++) used[nb][j]=true;//从左端点到右端点的每一天里，港口nb号都是关闭的。
		//used[nb][j]表示nb号港口在第j天是关闭的
	}
	for(int i=1;i<=n;i++)//枚举每一种可能的天数
	for(int j=i;j<=n;j++)//从第i天到第j天，所以j应该从i开始枚举。
	{
		memset(days_off,0,sizeof(days_off));//因为days_off数组记录的是第i天到第j天哪些港口不能使用，所以每次枚举都应该清零。
		for(int d=i;d<=j;d++)//枚举天数，配合used数组的储存方式，我们要求的是某天哪些港口不能使用，所以应放在外循环
		for(int to=1;to<=m;to++)//枚举港口
		if(used[to][d]) days_off[to]=true;
		SPFA(1);
		cost[i][j]=dis[m];//cost数组记录的是第i天到第j天的最短路长度。
	}
```
### SPFA
对于没有经过特殊构造的数据，SPFA还是很好用的。

如果更喜欢 $dj$ 也可以打 $dj$，这道题能随便跑。
```cpp
void SPFA(int s)
{
	memset(dis,0x3f,sizeof(dis));
	memset(vis,false,sizeof(vis));
	dis[s]=0,q.push(s),vis[s]=true;
	while(!q.empty())
	{
		int x=q.front();q.pop();
		vis[x]=0;
		for(int i=head[x];i;i=a[i].next)
		{
			int v=a[i].to;
			if(days_off[v]) continue;//如果港口关闭那么就不进行下面的操作，继续循环。
			if(dis[v]>dis[x]+a[i].w)
			{
				dis[v]=dis[x]+a[i].w;
				if(vis[v]) continue;
				q.push(v),vis[v]=true;
			}
		}
	}
}
```
### DP
这道题好像要卡 $int$,保险起见 $cost$ 数组和 $dp$ 数组都开成 $longlong$。

思路见代码注释。
```cpp
for(int i=1;i<=n;i++)
	{
		dp[i]=(long long)cost[1][i]*i;
		for(int j=i-1;j>=0;j--)
		dp[i]=min(dp[i],dp[j]+cost[j+1][i]*(i-j)+k);
        
      //dp[i]储存的是从第一天到第n天的最少花费。
      //枚举j的意义是在第j天改变路线。
      //那么就应该用dp[j]+cost[j+1][i]*(i-j)+k去更新dp[i]。
      //意思为先从第一天到第j天，花费为dp[j].
      //再从第j+1天到第i天，花费为cost[j+1][i]*(i-j)+k
      //cost[j+1][i]中储存的是从第j+1天到第i天的最短路长度。
      //而*(i-j)是因为每天都会有货物被运输，所以总花费应乘上天数。
      
	}
```
### 尾声
答案输出：
```cpp
printf("%lld",dp[n]);
```


---

## 作者：彭天宇 (赞：1)

在听别人讲解一半之后，自己一知半解地做，结果搞了很久都60分，结果才发现自己算法是错的。

首先反驳一下假算法：

猜想某一天如果切换路线，一定是走当天的最短路，之后如果能延续最好延续这条路。那就用$D[i][j]$表示从第$i$天到第$j$天都走第$i$天的最短路的价值，这样只需要记录第$i$天的最短路，也就是$D[i][i]$，判断接下来几天能不能走，如果可以，那$D[i][j]=D[i][i]\times (j-i+1)$

其实我当时就觉得这有问题，不过被谁说服了（或者是我神志不清理解错了）

来看这张图（边框加粗表示能走）
![hack](https://cdn.luogu.com.cn/upload/image_hosting/xfp6pzx4.png)
如果第一天选择走最短路$1-2-5$第二天就会被迫改用$1'-3'-5'$。花费为$106$。

然而如果两天都走$1-3-5$则花费为$8$

那么发现应该把连续多天的放在一起考虑。$D[i][j]$不再完全服从第$i$天的最短路，而是将$i$到$j$天能走的边加到图上（当然不用像上图一样加），进行最短路。

![](https://cdn.luogu.com.cn/upload/image_hosting/fse6zuow.png)

上面的两天就化简成这样。

然后才是$dp$。

$f[i]$表示到第$i$天花费的最小代价。

怎样转移？从前面某一天$j$之后开始改变路线，走$D[j+1][i]$，选取最小值，$j$之前怎样走不管。

$f[i]=min(f[j]+D[j+1][i]+k)(0\le j<i)$
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=110;
int n,m,k,e,d,tot,head[N*100],ver[N*100],edge[N*100],nxt[N*100],D[N][N],dis[N],from[N],f[N];
bool ok[N][N],vis[N];
int read(){
	int x=0,f=1;
	char ch=getchar();
	while(!isdigit(ch)){
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=x*10+ch-'0';
		ch=getchar();
	}
	return x*f;
}
void add(int x,int y,int z){
	nxt[++tot]=head[x];
	head[x]=tot;
	ver[tot]=y;
	edge[tot]=z;
}
struct road{
	int from,to,cost;
}r[N*100];
priority_queue<pair<int,int> >q;
void dij(){
	memset(dis,0x3f,sizeof dis);
	dis[1]=0;
	memset(vis,0,sizeof vis);
	q.push(make_pair(0,1));
	while(q.size()){
		int x=q.top().second;
		q.pop();
		if(vis[x])continue;
		vis[x]=1;
		for(int i=head[x];i;i=nxt[i]){
			int y=ver[i];
			int z=edge[i];
			if(dis[y]>dis[x]+z){
				dis[y]=dis[x]+z;
				q.push(make_pair(-dis[y],y));
				from[y]=x;
			}
		}
	}
}
signed main(){
	freopen("rand.in","r",stdin);
	freopen("mine.out","w",stdout);
	n=read(),m=read(),k=read(),e=read();
	//n是天数，m是点数，
	for(int i=1;i<=e;i++){
		r[i].from=read();
		r[i].to=read();
		r[i].cost=read();
	}
	d=read();
	for(int i=1;i<=m;i++)
		for(int j=1;j<=n;j++)ok[i][j]=1;
	for(int i=1;i<=d;i++){
		int x=read(),l=read(),r=read();
		for(int j=l;j<=r;j++)ok[x][j]=0;
	}
	memset(D,0x3f,sizeof D);
	for(int i=1;i<=n;i++){
		for(int j=0;j<=n;j++){
			tot=0;
			memset(head,0,sizeof head);
			for(int k=1;k<=e;k++){
				bool flag=true;
				for(int l=i;l<=j;l++)if((!ok[r[k].from][l])||(!ok[r[k].to][l]))flag=false;
				if(flag){
					add(r[k].from,r[k].to,r[k].cost);
					add(r[k].to,r[k].from,r[k].cost);
				}
			}
			dij();
			if(dis[m]>1e15)D[i][j]=1e15;
			else D[i][j]=dis[m]*(j-i+1);
		}
	}
	memset(f,0x3f,sizeof f);
	f[0]=0;
	for(int i=1;i<=n;i++)for(int j=0;j<i;j++)f[i]=min(f[i],f[j]+D[j+1][i]+k);
	cout<<f[n]-k<<endl;
	return 0;
}
```

---

## 作者：C20203030 (赞：1)

## 一、题目

[点此看题](https://www.luogu.org/problem/P1772)

## 二、解法

这道题得难点在于如何在限制点的情况下最短路和最小$k$值的决策，考虑动态规划。

每一天的路径可以不改变路径形态，或者改变路径形态。发现在决策过程中，会出现相同且连续的路径形态，我们自然而然地想到了区间类型的$dp$，即对于本题，我们要对一个大区间分段，每断开一次都会导致为$k$的花费，而分段后区间带来的代价减少。

设$f[i]$为对于$[1,i]$执行上述操作的最小花费，则有：

$f[i]=\min\{f[j-1]+k+cost[j][i]\}$

现在的问题是，怎么算$cost$？发现$cost$即为这个天数区间不能走被限制点的最短路径，考虑到$n\leq 20$，我们可以对点状压，取这些天数被限制点集的并集，然后跑$dijkstra$即可。

时间复杂度$O(n^2m\log m)$ 其中  ($n$为点数，$m$为边数)。


```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <queue>
using namespace std;
const int inf = 0x3f3f3f3f;
int read()
{
    int x=0,flag=1;
    char c;
    while((c=getchar())<'0' || c>'9') if(c=='-') flag=-1;
    while(c>='0' && c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
    return x*flag;
}
int n,m,T,k,d,tot,f[25],dis[25],dp[105],sit[105];
struct edge
{
    int v,c,next;
} e[405];
struct node
{
    int u,c;
    bool operator < (node x) const
    {
        return c>x.c;
    }
};
int dijkstra(int a,int b)
{
    int S=0;
    for(int i=a; i<=b; i++)
        S|=sit[i];
    memset(dis,0x3f,sizeof dis);
    priority_queue<node> q;
    q.push(node{1,0});
    dis[1]=0;
    while(!q.empty())
    {
        node t=q.top();
        q.pop();
        for(int i=f[t.u]; i; i=e[i].next)
        {
            int v=e[i].v,c=e[i].c;
            if(dis[v]>dis[t.u]+c && !((1<<v-1)&S))
            {
                dis[v]=dis[t.u]+c;
                q.push(node{v,dis[v]});
            }
        }
    }
    return dis[n];
}
signed main()
{
    T=read();
    n=read();
    k=read();
    m=read();
    for(int i=1; i<=m; i++)
    {
        int u=read(),v=read(),c=read();
        e[++tot]=edge{v,c,f[u]},f[u]=tot;
        e[++tot]=edge{u,c,f[v]},f[v]=tot;
    }
    d=read();
    for(int i=1; i<=d; i++)
    {
        int u=read(),a=read(),b=read();
        for(int j=a; j<=b; j++)
            sit[j]|=(1<<u-1);
    }
    for(int i=1; i<=T; i++)
    {
        dp[i]=inf;
        for(int j=1; j<=i; j++)
        {
            int t;
            if((t=dijkstra(j,i))^inf)
                dp[i]=min(dp[i],dp[j-1]+k+(i-j+1)*t);
        }
    }
    printf("%d\n",dp[T]-k);
}
```



---

## 作者：Gliese (赞：1)

## 题目背景
~~以下纯属虚构，请勿当真~~

在一个晚上，一位出题人闲得慌，于是，他打算出一道dp题，正苦苦思考如何出一道难题，他忽然想到了图论，于是，他将最短路与动规结合，就成了本题


------------
# 思路
tip：难题=简单模型+简单模型+简单模型+...+简单模型；

本题就由最短路+dp组成

最短路这里就不说了，推荐使用spfa，时间复杂度为O(KE)，十分高效，重点谈一下dp怎么写
#### 法一：~~理想很丰满，现实却骨感（鸡肋产品）~~
dp[i]表示第i天最小花费，将第i天最短路与第i-1天比较，相等加上路程花费，否则加上新最短路+改动花费的值，打个擂台就可以了

听上去有些道理，但实现不了~~（代码我没写）~~

如果要求最短路怎样走，spfa完全不行，只能dfs穷举路径，这样100%会TLE~~，如果没爆，祝贺你，你将成为NOI冉冉升起的一颗红巨星~~

#### 法二
设想一下，如果第j天至第i天路径相同，那么第j天至第i天港湾的关闭对这条路毫无影响，我们可以设置now数组记录第j至第i天关闭的全部港口。如果走得通，那么这些天最短路径不变，否则路径不同，递推式：dp[i]=min(dp[i],dp[j-1]+最短路花费*(i-j+1)+改路径花的费用)


------------
#### AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int dp[110],dis[110],vis[110],x[110][110],nw[110],cls[110][110];
queue<int> q;
int n,m,k,e,d;
int spfa()
{
	memset(dis,0x7f,sizeof(dis));
	memset(vis,0,sizeof(vis));
	dis[1]=0;
	q.push(1);
	vis[1]=1;
	while(!q.empty())
	{
		int top=q.front(),j;
		q.pop();
		vis[top]=0;
		for(int i=1; i<=m; ++i)
			if(x[top][i]>=0&&!nw[i]&&dis[i]>dis[top]+x[top][i])
			{
				dis[i]=dis[top]+x[top][i];
				if(!vis[i])
				{
					q.push(i);
					vis[i]=1;
				}
			}
	}
	return dis[m];
}
int main()
{
	memset(x,-1,sizeof(x));
	cin>>n>>m>>k>>e;
	for(int i=1; i<=e; ++i)
	{
		int r1,r2,r3;
		cin>>r1>>r2>>r3;
		x[r1][r2]=x[r2][r1]=r3;
	}
	cin>>d;
	for(int i=1; i<=d; ++i)
	{
		int p,r1,r2;
		cin>>p>>r1>>r2;
		for(int j=r1; j<=r2; ++j)
			cls[p][j]=1;
	}
	memset(dp,0x7f,sizeof(dp));
	dp[0]=-k;
	for(int i=1; i<=n; ++i)
	{
		memset(nw,0,sizeof(nw));
		for(int j=i; j>0; --j)
		{
			for(int bs=1; bs<=m; ++bs)
				nw[bs]=nw[bs]|cls[bs][j];//敲黑板！
			int total=spfa();
			if(total==0x7f7f7f7f)
				continue;
			dp[i]=min(dp[i],dp[j-1]+total*(i-j+1)+k)//敲黑板！
		}
	}
	cout<<dp[n];
	return 0;
}
```

---

## 作者：Wen_kr (赞：1)

思路跟前面的差不多。

只不过预处理方式不大一样，用了状态压缩思想

实际总时间24ms

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>
#include <ext/pb_ds/priority_queue.hpp>
#error Please DO NOT copy from others.
 //这里使用pb_ds库的priority_queue，noip能用，而且跑得更快 
using namespace std;
 
int n,m,k,bian,dp[105],ab[25][105],vis[25],shortest[105][105],dis[105],nab[25];
 //用到dp思想，具体dp方程下面解释，ab[i][j]表示第i个点第j天能否使用，shortest用来存储预处理出来的最短路，nab数组表示当前处理过程中哪些点能用，哪些点不可用 
struct edge
{
    int v,w,nxt;
}e[100005];
 //用邻接链表存边 
int ecnt,head[50];
 
void adde(int u,int v,int w)
{
    e[++ecnt].v = v;
    e[ecnt].w = w;
    e[ecnt].nxt = head[u];
    head[u] = ecnt;
    e[++ecnt].v = u;
    e[ecnt].w = w;
    e[ecnt].nxt = head[v];
    head[v] = ecnt;
}
 //加边，注意是双向边。 
void dijkstra()
{
    typedef pair<int,int> pii;
    __gnu_pbds::priority_queue<pii,greater <pii> > que;  //用pbds库的优先队列不用加vector<pii> 
    que.push(make_pair(0,1));
    dis[1] = 0;
    while(!que.empty())
    {
        int u = que.top().second;
        que.pop();
        if(vis[u]) continue;
        vis[u] = 1;
        for(register int i = head[u];i != -1;i = e[i].nxt)
        {
            int v = e[i].v;
            if(!nab[v])
            if(dis[u] + e[i].w < dis[v])
            {
                dis[v] = dis[u] + e[i].w;
                que.push(make_pair(dis[v],v));
            }
        }
    }  //dijkstra过程大致不需要变，除了要考虑这个点能不能用。 
}
 
int days[105],bin[25]={0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,524288,1048576};
 //这里用一个状压思想，避免每一次都重新计算数组导致信息浪费，days[i]表示第i天点的状态。 
int main()
{
    memset(head,-1,sizeof(head));
    scanf("%d%d%d%d",&n,&m,&k,&bian);
    int from,to,val,d;
    for(register int i = 1;i <= bian;i ++)
    {
        scanf("%d%d%d",&from,&to,&val);
        adde(from,to,val);
    }
    scanf("%d",&d);
    for(register int i = 1;i <= d;i ++)
    {
        scanf("%d%d%d",&val,&from,&to);
        for(register int j = from;j <= to;++j)
            ab[val][j] = 1;
    }
    //输入部分，不多做解释 
    for(register int i = 1;i <= n;i ++)
        for(register int j = 1;j <= m; ++ j)
            if(ab[j][i]) days[i] |= bin[j];
    //使用状压思想，一次性求出每一天的状态。（其实可以在输入中求，代码如下）
    for(register int i = 1;i <= d;i ++)
    {
        scanf("%d%d%d",&val,&from,&to);
        for(register int j = from;j <= to;j ++)
            days[j] |= bin[val];
    } 
    //防止复制粘贴用，不注释。 
    memset(dp,0x3f3f3f3f,sizeof(dp));//初始化dp数组 
    for(register int i = 0;i <= n;++ i)
        for(register int j = i;j <= n; ++ j)  //这里直接预处理所有的最短路而不是一边dp一边求最短路。 
        {
            memset(nab,0,sizeof(nab));
            int st = 0;
            for(register int l = i + 1;l <= j;l ++)
                st |= days[l];     //求每个时间段的最短路只需要或上即可。 
            for(register int l = 1;l <= m; ++l)
                nab[l] = ((st & bin[l]) > 0);
            memset(vis,0,sizeof(vis));
            memset(dis,0x3f3f3f3f,sizeof(dis));
            dijkstra();
            if(dis[m] != 1061109567)
            shortest[i][j] = dis[m];
            else
            {
                shortest[i][j] = -1;
                for(register int l = j + 1;l <= n;l ++) shortest[i][l] = -1;
                break;//剪枝，可以证明只要一天不行，接下来的都不行。 
            }
        }
        //这里可以简化，代码也如下：
     for(register int i = 0;i <= n; ++ i)
     {
         int st = 0;
         for(register int j = i;j <= n; ++ j)
         {
             if(j >= i + 1)
                 st |= days[j];
             memset(nab,0,sizeof(nab));
             for(register int l = 1;l <= m;++l)
                 nab[l] = ((st & bin[l]) > 0);
             memset(vis,0,sizeof(vis));
             memset(dis,0x3f3f3f3f,sizeof(dis));
             dijkstra();
             if(dis[m] != 1061109567)
                 shortest[i][j] = dis[m];
             else
             {
                 shortest[i][j] = -1;
                 for(register int l = j + 1;l <= n;++l)shortest[i][l] = -1;
                 break;
             }
         }
     }
     //防止copy不注释 
    dp[0] = 0;//初始化dp数组 
    for(register int i = 1;i <= n;i ++)
        for(register int j = 0;j <= i;j++)
            if(shortest[j][i] != -1)
            dp[i] = min(dp[i],dp[j] + shortest[j][i] * (i - j) + k);
        //dp[i]表示在第i天花费的最小值，则可以推出dp方程dp[i] = min{dp[j] + shortest[j][i] * (i-j) + k}，即在第j+1天更换方案，一直使用到第i天加上更换方案的消费。 
    printf("%d\n",dp[n] - k);//第一个方案不计算入更换方案，所以要减去一个k 
}
```

---

## 作者：TsReaper (赞：1)

设g(i,j)表示从第i天到第j天，不经过其间不能通过的点的最短路（也就是说，如果点x从第i天到第j天中，只要有一天不能经过，最短路就不考虑它），设f(i)表示从第1天运输到第i天的最小成本。显然f(i) = min(f(j)+g(i,j+1))+c（枚举哪一天之后改变线路），这样答案就是f(n)-c（因为第一次制定线路不需要c的代价）。

这样，主要问题就集中在了如何求g(i,j)。如果大家复杂度估计得比较好的话，通过这一题是非常容易的。我们只要暴力地求g(i,j)就好。因为每用最短路算法求一次g(i,j)的复杂度为O(m^2)，而g(i,j)一共有n^2个，这样复杂度就是O((nm)^2)，对于题目中的数据范围是完全可以通过的。

```cpp

#include <stdio.h>
#define QLEN 23
int n,m,d,v,sum[25][110];
int e[810][3],p[25];
int q[25],dis[25],head,tail;
int f[110],g[110][110];
short vis[25];
int min(int a,int b)
{
    return a<b?a:b;
}
void adde(int sn,int fn,int val,int id)
{
    e[id][0] = fn; e[id][1] = val; e[id][2] = p[sn]; p[sn] = id;
    e[id+1][0] = sn; e[id+1][1] = val; e[id+1][2] = p[fn]; p[fn] = id+1;
}
int spfa(int l,int r)
{
    int i,sn,fn,val;
    for(i=1;i<=n;i++) dis[i] = 9999999;
    head = 1; tail = 2;
    q[1] = 1; dis[1] = 0; vis[1] = 1;
    while(head != tail)
    {
        sn = q[head++];
        for(i=p[sn];i;i=e[i][2])
        {
            fn = e[i][0]; val = e[i][1];
            if(sum[fn][r]-sum[fn][l-1] || dis[fn]<=dis[sn]+val) continue;
            dis[fn] = dis[sn]+val;
            if(vis[fn]) continue;
            vis[fn] = 1; q[tail++] = fn;
            if(tail>QLEN) tail = 1;
        }
        vis[sn] = 0;
        if(head>QLEN) head = 1;
    }
    return dis[n];
}
int main()
{
    int i,j,sn,fn,val;
    scanf("%d%d%d%d",&d,&n,&v,&m);
    for(i=1;i<=d;i++) f[i] = 9999999;
    for(i=1;i<=m;i++)
    {
        scanf("%d%d%d",&sn,&fn,&val);
        adde(sn,fn,val,i<<1);
    }
    scanf("%d",&j);
    while(j--)
    {
        scanf("%d%d%d",&val,&sn,&fn);
        for(i=sn;i<=fn;i++) sum[val][i] = 1;
    }
    for(i=1;i<=n;i++) for(j=1;j<=d;j++) sum[i][j] += sum[i][j-1];
    for(i=1;i<=d;i++) for(j=i;j<=d;j++) g[i][j] = spfa(i,j);
    f[0] = 0;
    for(i=1;i<=d;i++) for(j=0;j<i;j++) f[i] = min(f[i],f[j]+g[j+1][i]*(i-j)+v);
    printf("%d",f[d]-v);
    return 0;
}

```

---

## 作者：Vector_Mingfan (赞：0)

[题目由此去 P1772 [ZJOI2006]物流运输](https://www.luogu.com.cn/problem/P1772)

[博客园食用更佳](https://www.cnblogs.com/VenomCorrect/p/15002721.html)

------------
**【题目算法】** 动态规划 $ + $ 最短路

**【题目分析】**

1 设 $ f_i $ 表示到第 $ i $ 天时所需的最小费用， $ a_{i, j}$ 表示从第 $ i $ 天到第 $ j $ 天使用同一条可行的从 $ 1 $ 到 $ n $ 的最短路。则：

$ F_i = \min (f_j + a_{j+1,i} * (i - j) + k;) $

$ Ans = f_m - k; $ （因为第一次加了一个 $ k $ ）

2.计算 $ a_{i,j} $ 的值。枚举 $ i $ 和 $ j $ ，标记不能用的码头，然后用 dij 求从 $ 1 $ 到 $ n $ 的最短路。

**【算法步骤】**

1.读入数据，用 $ w_{i,j} $ 记录第 $ i $ 天第 $ j $ 个不能用的码头；

2.求 $ a_{i,j} = $ dijkstra $ (); $

3.最后用 $ dp $ 求解

------------
- $ AC $ 代码

```
#include <cstdio>
#include <cstring>
#include <iostream>
#define INF 0x7fffffff/2
#define MAXN 105
#define ll long long
ll N,M,K,E,D,a[MAXN][MAXN],g[MAXN][MAXN],w[MAXN][MAXN],dis[MAXN],f[MAXN];
bool bj[MAXN],vst[MAXN];
int dij() {
	ll k,minn;
	for (ll i=1;i<=M;i++) {dis[i]=INF; vst[i]=0;}
	dis[1]=0;
	for (ll i=1;i<=M;i++) {
		k=0; minn=INF;
		for (ll j=1;j<=M;j++) {
			if (!vst[j]&&!bj[j]&&dis[j]<minn) {minn=dis[j]; k=j;}
		}
		if (!k) break;
		vst[k]=1;
		for (ll j=1;j<=M;j++) {
			if (g[k][j]>0&&dis[k]+g[k][j]<dis[j]) dis[j]=g[k][j]+dis[k];
		}
	}
	return dis[M];
}
void init() {
	for (ll i=1;i<=N;i++) {
		for (ll j=i;j<=N;j++) {
			memset(bj,0,sizeof(bj));
			for (ll k=i;k<=j;k++) for (ll l=1;l<=w[k][0];l++) bj[w[k][l]]=1;
			a[i][j]=dij();
		}
	}
}
void dp() {
	for (ll i=1;i<=N;i++) {
		f[i]=INF;
		for (ll j=0;j<i;j++) f[i]=min(f[j]+a[j+1][i]*(i-j)+K,f[i]);
	}
	printf("%lld",f[N]-K);
}
void read() {
	ll x,y,z,p,daya,dayb;
	scanf("%lld %lld %lld %lld",&N,&M,&K,&E);
	for (ll i=1;i<=E;i++) {scanf("%lld %lld %lld",&x,&y,&z); g[x][y]=g[y][x]=z;}
	scanf("%lld",&D);
	for (ll i=1;i<=D;i++) {
		scanf("%lld %lld %lld",&p,&daya,&dayb);
		for (ll j=daya;j<=dayb;j++) w[j][++w[j][0]]=p;
	}
}
int main() {
	read();
	init();
	dp();
	return 0;
}
```

---

## 作者：くろねこ (赞：0)

看我代码qwq

------------

```cpp
/*
-------------------------------------------------------------------------------------
※关于SPFA 它AK了 
-------------------------------------------------------------------------------------
推荐相似题目:CodeVS-1403[新三国争霸]
------------------------------------------------------------------------------------- 
本题大意是每段时间有一个点不能用,每修改一次路径花费一定价格,求最小花费
既然是点可能不能用,我们考虑采用 SPFA 算法来进行判断(SPFA 是基于点入队的最短路算法)
由于是最优解问题,显然会用到 DP
考虑到最后所求是 n 天时的最小花费,则DP[i] 表示第 i 天的最小花费
考虑到预处理问题,我们大概需要求 T^2 次最短路
时间复杂度约为O(T^2 * Kn)
可以很快的解决本题 
*/
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <queue>
using namespace std;
#define rg register
template <typename qwq> inline void read(qwq & x) 
{
	x = 0;
	rg int f = 1;
	rg char c = getchar();
	while (c < '0' || c > '9')
	{
		if (c == '-') f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9')
	{
		x = (x << 1) + (x << 3) + (c ^ 48);
		c = getchar();
	}
	x *= f;
}
template <typename qaq> inline void print(qaq x) 
{
	if (x < 0)
	{
		putchar('-');
		x = -x;
	}
	if (x > 9) print(x / 10);
	putchar(x % 10 + '0');
}
struct edge
{
	int u,v,w,next;
}e[23333];
int head[23333],tot;
bool ban[233][233];//ban[i][j]: i 点在第 j 天能否装卸货物 
inline void add(int x,int y,int z)
{
	++tot;
	e[tot].u = x;
	e[tot].v = y;
	e[tot].w = z;
	e[tot].next = head[x];
	head[x] = tot;
}
int dis[233],cost[233][233];
bool vis[233];
inline bool check(int t1,int t2,int x)//检查该时间段 x 点是否无法卸载货物 
{
	for (rg int i = t1;i <= t2;++i)
	{
		if (ban[x][i]) return false;
	}
	return true;
}
inline int spfa(int t1,int t2)//SPFA模板,传的参数为当前的天数(t1 天 ~ t2 天) 
{
	queue<int> q;
	memset(dis,0x3f,sizeof dis);
	memset(vis,0,sizeof vis);
	dis[1] = 0;
	q.push(1);
	vis[1] = true;
	while(!q.empty())
	{
		rg int x = q.front();
		q.pop(); 
		vis[x] = false;
		if (!check(t1,t2,x)) continue;//如果 x 点在t1~t2天无法装卸货物,则跳过该点判断 
		for (rg int i = head[x];i;i = e[i].next)
		{
			rg int v = e[i].v,w = e[i].w;
			if (dis[v] > dis[x] + w && check(t1,t2,v))//如果 v 点在t1~t2天无法装卸货物,则当前不进行松弛操作 
			{
				dis[v] = dis[x] + w;
				if (!vis[v])
				{
					q.push(v);
					vis[v] = true;
				}
			}
		}
	}
}
int n,m,k,t,p;
int x,y,z;
int dp[2333];
int main()
{
	read(t),read(n),read(k),read(m);
	for (rg int i = 1;i <= m;++i)
	{
		read(x),read(y),read(z);
		add(x,y,z),add(y,x,z);
	}
	read(p);
	for (rg int i = 1;i <= p;++i)
	{
		read(z),read(x),read(y);// z 点在 x ~ y 天内均无法装卸货物,预处理该状态 
		for (rg int j = x;j <= y;++j)
		{
			ban[z][j] = true;
		}
	}
	for (rg int i = 1;i <= t;++i)//枚举天数,预处理每个时间段可能的路程 
	{
		for (rg int j = i;j <= t;++j)
		{
			spfa(i,j);
			cost[i][j] = dis[n];
		}
	}
	for (rg int i = 1;i <= t;++i)
	{
		if (cost[1][i] == 0x3f3f3f3f) dp[i] = cost[1][i];//当前时间不能用一种方案直接到达 n 点,不能用来更新 
		else dp[i] = cost[1][i] * i;//否则将其正常赋值 
		for (rg int j = 1;j < i;++j)
		{
			if (cost[j + 1][i] == 0x3f3f3f3f) continue;
			dp[i] = min(dp[i],dp[j] + cost[j + 1][i] * (i - j));
		}
		dp[i] += k;//每次改变航线需要 k 的价格 
	}
	print(dp[t] - k);//由于第一个航线方案不需要 k 的价格,将其减去 
}
```


---

## 作者：Deny_小田 (赞：0)

最短路+dp


最短路使用spfa

dp方程：

···cpp

if(f[j+1][i] != inf) dp[i] = min(dp[i], dp[j]+f[j+1][i]\*(i-j)+k);

···

尼玛在bzoj上做的时候把数组开小了。。结果当然是tle。。。


代码（赠送注释）：


```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;

const int size = 25,_len = 105,_size = 1005,inf = 1000000000;            //inf = 2147483647
bool tag[size],a[size][_len],visited[size];
    //这里head、to、next等数组也可以用struct实现
int head[size],to[_size],next[_size],len[_size],dis[size],q[size],f[_len][_len],dp[_len];
int n,m,num,k,day,cnt;

void addEdge(int x, int y, int z){                //前向星..... 我们学长称之为 "向前星"..
    num++;
    to[num] = y; len[num] = z; next[num] = head[x]; head[x] = num;
}

void spfa(){                        //spfa模板不解释
    for(int i = 2; i <= n; i++) dis[i] = inf;
    dis[1] = 0;
    int l = 0,r = 1;
    q[1] = 1; visited[1] = true;

    while(l != r){                                //人工构造循环 vector
        l++;
        if(l == 21) l = 0;                        //1
        int x = q[l];
        for(int p = head[x]; p; p = next[p]){
            if(dis[x]+len[p] < dis[to[p]]){
                dis[to[p]] = dis[x]+len[p];
                if(!visited[to[p]] && ! tag[to[p]]){
                    r++; if(r == 21) r = 0;        //2
                    q[r] = to[p];
                    visited[to[p]] = true;
                }
            }
            visited[x] = false;
        }
    }
}

int main(int argc, char const *argv[]){
    /*************************初始化不解释********************************/
    scanf("%d %d %d %d",&day,&n,&k,&m);
    for(int i = 1; i <= m; i++){
        int x,y,z;
        scanf("%d %d %d",&x,&y,&z);
        addEdge(x, y, z); addEdge(y, x, z);                    //加边不解释
    }

    scanf("%d",&cnt);
    for(int i = 1; i <= cnt; i++){
        int x,l,r;
        scanf("%d %d %d",&x,&l,&r);
        for(int j = l; j <= r; j++) a[x][j] = 1;
    }
    
    /***************************开始求最短路***************************************/
    
    for(int i = 1; i <= day; i++){
        memset(tag, 0, sizeof(tag));
        for(int j = i; j <= day; j++){
            for(int k = 1; k <= n; k++) tag[k] |= a[k][j];
            spfa();
            f[i][j] = dis[n];
        }
    }

    /***********************下面开始dp******************************/
    dp[0] = -k;
    for(int i = 1; i <= day; i++){
        dp[i] = inf;
        for(int j = 0; j < i; j++){
            if(f[j+1][i] != inf) dp[i] = min(dp[i], dp[j]+f[j+1][i]*(i-j)+k);
        }
    }
    printf("%d\n",dp[day]);

    return 0;
}

```

参考资料：http://blog.csdn.net/u012288458/article/details/50659151


---

## 作者：Skywalker_David (赞：0)

单源最短路+DP

cop[i]=true 为第i天可连续使用 

dist[i,j]为从第i天到第j天的可持续的最短路

```delphi

program p1772
var a:array[1..20,1..20]of int64;  
    b,c,d,n,m,e,s:int64;  
    i,j,k,u,t:longint;  
    can:array[1..20,1..100]of boolean;  
    dis:array[1..100,1..100]of int64;  
    cop:array[1..20]of boolean;  
    f:array[1..100]of int64;  
  
function min(a,b:longint):longint;begin if a<b then exit(a)else exit(b)end;  
  
function getmin(s1,s2:longint):longint;  
var i,j,k,num,s:longint;  
    f:array[1..20]of longint;  
    bo:array[1..20]of boolean;  
begin  
  for i:=1 to m do f[i]:=7000000;  
  fillchar(bo,sizeof(bo),false);  
  bo[s1]:=false;f[s1]:=0;  
  while bo[s2]=false do  
  begin  
    num:=maxlongint;  
    for i:=1 to m do  
      if (bo[i]=false)and(cop[i]=true)and(f[i]<num) then  
      begin num:=f[i];s:=i;end;  
    bo[s]:=true;  
    for i:=1 to m do if (f[s]+a[s,i]<f[i])and(cop[i]) then f[i]:=f[s]+a[s,i];  
  end;  
  exit(f[s2]);  
end;  
  
begin  
  read(n,m,k,e);  
  for i:=1 to 20 do for j:=1 to 20 do a[i,j]:=7000000;  
  for i:=1 to 20 do a[i,i]:=0;  
  for i:=1 to e do  
  begin  
    read(c,d,s);  
    a[c,d]:=s;  
    a[d,c]:=s;  
  end;  
  read(s);  
  fillchar(can,sizeof(can),true);  
  for i:=1 to s do  
  begin  
    read(t,c,d);  
    for j:=c to d do can[t,j]:=false;  
  end;  
  
  for i:=1 to n do  
     for j:=i to n do  
        begin  
          fillchar(cop,sizeof(cop),true);  
          for u:=1 to m do for t:=i to j do cop[u]:=cop[u] and can[u,t];  
          dis[i,j]:=getmin(1,m);  
        end;  
  
  for i:=1 to n do  
  begin  
    f[i]:=dis[1,i]*i;  
    for j:=1 to i-1 do f[i]:=min(f[i],f[j]+dis[j+1,i]*(i-j)+k);  
  end;  
  
  writeln(f[n]);  
end. 

```
f[i,j]:=min{dist[1,i]\*i,f[j]+dist[j+1,i]\*(i-j)+k}

P党福音在上


---


# [NOIP 2013 提高组] 货车运输

## 题目背景

NOIP2013 提高组 D1T3

## 题目描述

A 国有 $n$ 座城市，编号从 $1$ 到 $n$，城市之间有 $m$ 条双向道路。每一条道路对车辆都有重量限制，简称限重。  

现在有 $q$ 辆货车在运输货物， 司机们想知道每辆车在不超过车辆限重的情况下，最多能运多重的货物。


## 说明/提示

对于 $30\%$ 的数据，$1 \le n < 1000$，$1 \le m < 10,000$，$1\le q< 1000$；

对于 $60\%$ 的数据，$1 \le n < 1000$，$1 \le m < 5\times 10^4$，$1 \le q< 1000$；

对于 $100\%$ 的数据，$1 \le n < 10^4$，$1 \le m < 5\times 10^4$，$1 \le q< 3\times 10^4 $，$0 \le z \le 10^5$。


## 样例 #1

### 输入

```
4 3
1 2 4
2 3 3
3 1 1
3
1 3
1 4
1 3```

### 输出

```
3
-1
3```

# 题解

## 作者：crazydave (赞：1039)

#思路#

首先便是想到了Floyd的暴力方法，状态转移方程也不难推出：w[i][j]=max(w[i][j], min(w[i][k],w[k][j]));但是$n^3$次方时间复杂度和$n^2$的空间复杂度是显然不可取的。


于是我们思考，可以发现有一些权值较小的边是不会被走过的。正如样例中的第三条边，就算有其他的很多条边，这条边无论如何也是不会被走过的。于是我们想到了可以将图中这样的边去掉，按照这个思路我们便想到了构造最大生成树，将其余的边去除。


得到了这样一个树之后，我们便考虑如何求出两个节点之间最小边权的最大值（即为题中的最大载重），因为这两点之间的路径是唯一的，我们只需要找出这条路径便可以得到答案。我们可以通过LCA来做到这一点，我求LCA的方法是先从每一个根节点进行搜索，求出节点深度等信息，然后利用这些信息进行树上倍增。


于是我们可以得出大体思路：首先重新建图，构造出最大生成树，然后在最大生成树上求LCA来回答询问。

#代码#


```cpp
#include<cstdio>  
#include<algorithm>  
#include<cstring>  
#include<iostream>  
#define MAXN 10005 
#define INF 999999999
using namespace std; 
struct Edge1{  
    int x,y,dis;
}edge1[50005]; //题目所给的图 
struct Edge2{
    int to,next,w;
}edge2[100005]; //最大生成树的图 
int cnt,n,m,head[MAXN],deep[MAXN],f[MAXN],fa[MAXN][21],w[MAXN][21];
//f数组表示并查集中的父节点，fa数组表示树上的父节点，w数组表示最大载重 
bool vis[MAXN]; 

void addedge(int from, int to, int w)
{ //前向星存图 
    edge2[++cnt].next=head[from];
    edge2[cnt].to=to;
    edge2[cnt].w=w;
    head[from]=cnt;
    return ;
}

bool CMP(Edge1 x, Edge1 y)
{
    return x.dis>y.dis; //将边权从大到小排序 
}

int find(int x){  //并查集寻找父节点 
    if(f[x]!=x) f[x]=find(f[x]);
    return f[x];
}

void kruskal()
{
    sort(edge1+1, edge1+m+1, CMP); 
    for(int i=1; i<=n; i++)
        f[i]=i;  //并查集初始化 
    for(int i=1; i<=m; i++)
        if(find(edge1[i].x)!=find(edge1[i].y)){
            f[find(edge1[i].x)]=find(edge1[i].y);
            addedge(edge1[i].x, edge1[i].y, edge1[i].dis);
            addedge(edge1[i].y, edge1[i].x, edge1[i].dis);  //无向图，双向加边 
        }
    return ;
}

void dfs(int node)
{
    vis[node]=true;
    for(int i=head[node]; i; i=edge2[i].next){ //前向星遍历 
        int to=edge2[i].to;
        if(vis[to]) continue;
        deep[to]=deep[node]+1; //计算深度 
        fa[to][0]=node; //储存父节点 
        w[to][0]=edge2[i].w; //储存到父节点的权值 
        dfs(to);
    }
    return ;
}

int lca(int x, int y)
{
    if(find(x)!=find(y)) return -1; //不连通，输出-1 
    int ans=INF;
    if(deep[x]>deep[y]) swap(x,y); //保证y节点更深 
    //将y节点上提到于x节点相同深度 
    for(int i=20; i>=0; i--)
        if(deep[fa[y][i]]>=deep[x]){
            ans=min(ans, w[y][i]);  //更新最大载重（最小边权） 
            y=fa[y][i]; //修改y位置 
        }
    if(x==y) return ans; //如果位置已经相等，直接返回答案 
    //寻找公共祖先 
    for(int i=20; i>=0; i--)
        if(fa[x][i]!=fa[y][i]){
            ans=min(ans, min(w[x][i], w[y][i])); //更新最大载重（最小边权）
            x=fa[x][i]; 
            y=fa[y][i]; //修改x,y位置 
        }
    ans=min(ans, min(w[x][0], w[y][0]));
    //更新此时x,y到公共祖先最大载重，fa[x][0], fa[y][0]即为公共祖先 
    return ans;
}

int main()
{
    int x,y,z,q;
    scanf("%d%d",&n,&m);
    for(int i=1; i<=m; i++){
        scanf("%d%d%d",&x,&y,&z);
        edge1[i].x=x;
        edge1[i].y=y;
        edge1[i].dis=z;
    } //储存题目所给图 
    kruskal();
    for(int i=1; i<=n; i++)
        if(!vis[i]){ //dfs收集信息 
            deep[i]=1; 
            dfs(i);
            fa[i][0]=i;
            w[i][0]=INF;
        }
    //LCA初始化 
    for(int i=1; i<=20; i++)
        for(int j=1; j<=n; j++){
            fa[j][i]=fa[fa[j][i-1]][i-1]; 
            w[j][i]=min(w[j][i-1], w[fa[j][i-1]][i-1]);
        }
    scanf("%d",&q);
    for(int i=1; i<=q; i++){
        scanf("%d%d",&x,&y);
        printf("%d\n",lca(x,y)); //回答询问 
    }
    return 0;
} 
```

---

## 作者：phython (赞：259)

## 不用lca
## 不用lca
## 不用lca
## 记
做完以后看了看题解（没有全部看完），发现大家都是最大生成树+lca做的。
简单贡献一下我的方法，**实现起来超简单**，我做的时候只用了最大生成树和set，边建树边回答询问。

## 题解
要求x到y所有的路径中最小边长的最大值！

我们贪心的加边，依照边从大往小的方式往里添加，然后合并并查集。
每次当查询分布在两个待合并的并查集的时候，当前的边长就是这次查询的答案。

我们对每个并查集维护一个集合，集合中保存的内容就是一个点在这个并查集中，而另一个点不在这个并查集中的询问编号。

当待合并的两个并查集所具有的集合里面拥有相同的询问编号时候，回答这个询问编号，然后把小的集合向大的集合合并，并将回答完的询问编号从集合中移除。

实现起来比较简单。

## 代码
```cpp
#include <bits/stdc++>
using namespace std;
int n,m,q;
set<int>::iterator it;
const int maxm = 50005;
const int maxn = 11111;
set<int> Q[11111];
struct edge{
    int u,v,cost;
    friend bool operator <(edge e1,edge e2){
        return e1.cost > e2.cost;
    }
}es[maxm];
int ans[maxm];
int parent[maxn];
int find(int x){
    return x == parent[x]?x:parent[x] = find(parent[x]);
}
int main(){
    memset(ans,-1,sizeof(ans));
    for(int i = 1;i < maxn;++i)
        parent[i] = i;
    scanf("%d%d",&n,&m);
    for(int i = 0;i < m;++i)
        scanf("%d%d%d",&es[i].u,&es[i].v,&es[i].cost);
    sort(es,es+m);
    scanf("%d",&q);
    for(int i = 0;i < q;++i){
        int x,y;
        scanf("%d%d",&x,&y);
        Q[x].insert(i);
        Q[y].insert(i);
    }
    for(int i = 0;i < m;++i){
        int x = es[i].u,y = es[i].v,c = es[i].cost;
        int px = find(x),py = find(y);
        if(px == py) continue;
        else{
            if(Q[px].size() > Q[py].size())
                swap(px,py);
            vector<int> tmp;
            for(it = Q[px].begin();it != Q[px].end();++it){
                int id = *it;
                if(Q[py].count(id)){
                    ans[id] = c;
                    tmp.push_back(id);
                }
                Q[py].insert(id);
            }
            for(int i = 0;i < tmp.size();++i)
                Q[py].erase(tmp[i]);
            parent[px] = py;
        }
    }
    for(int i = 0;i < q;++i)
        printf("%d\n",ans[i]);
}
```

---

## 作者：糪眾脦颰罷 (赞：153)

此题写法蛮多的，倍增和启发式合并的写法想必大家已经了解了，本人稍微提一下好了。

而至于按秩合并和整体二分的写法，本人就稍微详细地讲解一下。
## 解法一：生成树+倍增
用克鲁斯卡尔算法构建出若干棵最大生成树，那么每个询问就转化成了求x到y路径上的最小边权，用倍增维护即可。

代码:
```c++
#include<bits/stdc++.h>
#define MAXN 100010
using namespace std;
bool f;
int n,m,q;
struct node {
        int st,ed,v;
} Edge[MAXN];
int pre[MAXN];
bool cmp(node A,node B) {
        return A.v>B.v;
}
int Find(int x){
        if(pre[x]==x)return x;
        return pre[x]=Find(pre[x]);
}
struct ______________{
        vector<node>G[MAXN];
        int F[MAXN][20],num[MAXN][20],lg[MAXN],deep[MAXN],root[MAXN];
        bool mark[MAXN],vis[MAXN];
        void DFS(int x,int fa,int val,int rt){
                root[x]=rt;
                F[x][0]=fa;
                num[x][0]=val;
                deep[x]=deep[fa]+1;
                for(int i=1;(1<<i)<=deep[x];i++)F[x][i]=F[F[x][i-1]][i-1],num[x][i]=min(num[x][i-1],num[F[x][i-1]][i-1]);
                for(int i=0;i<G[x].size();i++){
                        int t=G[x][i].ed,val=G[x][i].v;
                        if(t==fa)continue;
                        DFS(t,x,val,rt);
                }
        }
        int LCA(int x,int y){
                if(deep[x]<deep[y])swap(x,y);
                int res=2e9+7;
                while(deep[x]>deep[y]){
                        res=min(res,num[x][lg[deep[x]-deep[y]]-1]);
                        x=F[x][lg[deep[x]-deep[y]]-1];
                }
                if(x==y)return res;
                for(int i=lg[deep[x]]-1;i>=0;i--){
                        if(F[x][i]==F[y][i])continue;
                        res=min(res,num[x][i]);
                        res=min(res,num[y][i]);
                        x=F[x][i],y=F[y][i];
                }
                res=min(res,num[x][0]);
                res=min(res,num[y][0]);
                return res;
        }
        void work(){
                for(int i=1;i<=MAXN-10;i++)lg[i]=lg[i-1]+((1<<lg[i-1])==i);
                for(int i=1;i<=n;i++)pre[i]=i;
                for(int i=1; i<=m; i++) {
                        int x,y,z;
                        scanf("%d %d %d",&x,&y,&z);
                        Edge[i]=node {x,y,z};
                }
                sort(Edge+1,Edge+1+m,cmp);
                for(int i=1;i<=m;i++){
                        int fx=Find(Edge[i].st),fy=Find(Edge[i].ed);
                        if(fx==fy)continue;
                        mark[Edge[i].st]=mark[Edge[i].ed]=true;
                        pre[fx]=fy;
                        G[Edge[i].st].push_back(node{0,Edge[i].ed,Edge[i].v});
                        G[Edge[i].ed].push_back(node{0,Edge[i].st,Edge[i].v});
                }
                for(int i=1;i<=n;i++){
                        if(!root[i]){
                                DFS(i,0,0,i);
                        }
                }
                scanf("%d",&q);
                for(int i=1;i<=q;i++){
                        int x,y;
                        scanf("%d %d",&x,&y);
                        if(root[x]!=root[y]){
                                puts("-1");
                                continue;
                        }
                        printf("%d\n",LCA(x,y));
                }
        }
}p100;
bool ff;
int main() {
        scanf("%d %d",&n,&m);
        p100.work();
        return 0;
}
```
## 解法二：并查集+启发式合并
先把询问挂在点上，并查集合并时不路径压缩，把询问数量小的点向大的点合并，同时更新询问答案。

代码:
```c++
#include<bits/stdc++.h>#define MAXN 100010using namespace std;
int pre[MAXN],q,n,m,ans[MAXN];
struct node{
        int st,ed,v;
}Edge[MAXN];
struct Query{
        int ed,id;
};
vector<Query> Q[MAXN];
bool cmpEdge(node A,node B){
        return A.v>B.v;
}
int Find(int x){
        while(1){
                if(pre[x]==x)return x;
                x=pre[x];
        }
}
void merge(int x,int y,int val){
        int fx=Find(x),fy=Find(y);
        if(fx==fy)return;
        if(Q[fx].size()>Q[fy].size())swap(fx,fy);
        pre[fx]=fy;
        for(int i=0;i<Q[fx].size();i++){
                int t=Q[fx][i].ed,id=Q[fx][i].id;
                if(ans[id]!=-1)continue;
                int ft=Find(t);
                if(ft==fy)ans[id]=val;
        }
        for(int i=0;i<Q[fx].size();i++)Q[fy].push_back(Q[fx][i]);
}
int main() {
        memset(ans,-1,sizeof(ans));
        scanf("%d %d",&n,&m);
        for(int i=1;i<=m;i++){
                int st,ed,v;
                scanf("%d %d %d",&st,&ed,&v);
                Edge[i].st=st,Edge[i].ed=ed,Edge[i].v=v;
        }
        sort(Edge+1,Edge+1+m,cmpEdge);
        scanf("%d",&q);
        for(int i=1;i<=q;i++){
                int x,y;
                scanf("%d %d",&x,&y);
                Q[x].push_back((Query){y,i});
                Q[y].push_back((Query){x,i});
        }
        for(int i=1;i<=n;i++)pre[i]=i;
        for(int i=1;i<=m;i++)merge(Edge[i].st,Edge[i].ed,Edge[i].v);
        for(int i=1;i<=q;i++)printf("%d\n",ans[i]);
        return 0;
}
```
## 解法三：整体二分+并查集
假设只有一个询问，那么我们肯定是二分载重量，然后连接大于等于载重量的边，判断x,y是否连通。

那么对于很多询问呢？

考虑到如果这些询问的mid值是具有单调性的，那么当前连边情况就可以由上一个直接转移过来（不需要重新加边）。
因此，我们可以先将mid值从大到小排序，然后再查过来，同时不断加边。

代码:
```c++
#include<bits/stdc++.h>#define MAXN 100010using namespace std;
int pre[MAXN],q,n,m,Ans[MAXN];
struct node{
        int st,ed,v;
}Edge[MAXN];
bool cmpEdge(node A,node B){
        return A.v>B.v;
}
struct Query{
        int l,r,mid,ans,id,st,ed;
}Q[MAXN];
bool cmpQuery(Query A,Query B){
        return A.mid>B.mid;
}
int Find(int x){
        if(pre[x]==x)return x;
        return pre[x]=Find(pre[x]);
}
void merge(int x,int y){
        int fx=Find(x),fy=Find(y);
        if(fx==fy)return;
        pre[fx]=fy;
}
bool check(int x,int y){
        int fx=Find(x),fy=Find(y);
        return (fx==fy);
}
int main() {
        scanf("%d %d",&n,&m);
        for(int i=1;i<=m;i++){
                int st,ed,v;
                scanf("%d %d %d",&st,&ed,&v);
                Edge[i].st=st,Edge[i].ed=ed,Edge[i].v=v;
        }
        sort(Edge+1,Edge+1+m,cmpEdge);
        scanf("%d",&q);
        for(int i=1;i<=q;i++){
                int x,y;
                scanf("%d %d",&x,&y);
                Q[i]=(Query){1,100000,50000,-1,i,x,y};
        }
        int cnt=20;
        while(cnt--){
                for(int i=1;i<=n;i++)pre[i]=i;
                for(int i=1;i<=q;i++)Q[i].mid=(Q[i].l+Q[i].r)>>1;
                sort(Q+1,Q+1+q,cmpQuery);
                for(int i=1,j=1;i<=q;i++){
                        if(Q[i].l>Q[i].r)continue;
                        while(Edge[j].v>=Q[i].mid&&j<=m){
                                merge(Edge[j].st,Edge[j].ed);
                                j++;
                        }
                        if(check(Q[i].st,Q[i].ed)){
                                Q[i].ans=Q[i].mid;
                                Q[i].l=Q[i].mid+1;
                        }
                        else Q[i].r=Q[i].mid-1;
                }
        }
        for(int i=1;i<=q;i++)Ans[Q[i].id]=Q[i].ans;
        for(int i=1;i<=q;i++)printf("%d\n",Ans[i]);
        return 0;
}
```

## 解法四：并查集+按秩合并
跟第一种写法差不多，只不过构建最大生成树时我们不路径压缩，用按秩合并的方法，把深度小的点合并到大的点上面。

注意了，此时连边并不是把两个点直接连边，而是把它们的**祖先**连边（边权还是一样）。

可以证明：因为我们是按边从大到小加的，而要查询路径上的边权最小值。此时，这条边把两个集合合并在了一起，**那么一个集合到另一个集合必定要经过这条边**，而这条边又是目前最小的（其它边可以不管了），所以我们**只用确保路径经过了这条边**即可。

按照这样构成的生成树深度最多只有log(n)，因此找路径暴力遍历即可。

代码:
```c++

#include<bits/stdc++.h>
#define MAXN 100010
using namespace std;
int n,m,q;
struct node {
        int st,ed,v;
} Edge[MAXN];
int pre[MAXN],dis[MAXN],deep[MAXN],W[MAXN],root[MAXN];
vector<node> G[MAXN];
bool cmp(node A,node B) {
        return A.v>B.v;
}
int Find(int x) {
        while(1){
                if(pre[x]==x)return x;
                x=pre[x];
        }
}
void merge(int x,int y,int v){
        int fx=Find(x),fy=Find(y);
        if(fx==fy)return;
        if(dis[fx]>dis[fy])swap(fx,fy);
        pre[fx]=fy;
        if(dis[fx]==dis[fy])dis[fy]++;
        G[fx].push_back((node){0,fy,v});
        G[fy].push_back((node){0,fx,v});
}
void DFS(int x,int fa,int val,int k){
        root[x]=k;
        deep[x]=deep[fa]+1;
        pre[x]=fa;
        W[x]=val;
        for(int i=0;i<G[x].size();i++){
                int t=G[x][i].ed;
                if(t==fa)continue;
                DFS(t,x,G[x][i].v,k);
        }
}
int LCA(int x,int y){
        if(deep[x]<deep[y])swap(x,y);
        int res=2e9+7;
        while(deep[x]>deep[y])res=min(res,W[x]),x=pre[x];
        while(x!=y){
                res=min(res,W[x]),res=min(res,W[y]);
                x=pre[x],y=pre[y];
        }
        return res;
}
int main() {
        scanf("%d %d",&n,&m);
        for(int i=1; i<=n; i++)pre[i]=i;
        for(int i=1; i<=m; i++) {
                int x,y,z;
                scanf("%d %d %d",&x,&y,&z);
                Edge[i]=(node) {x,y,z};
        }
        sort(Edge+1,Edge+1+m,cmp);
        for(int i=1;i<=m;i++){
                merge(Edge[i].st,Edge[i].ed,Edge[i].v);
        }
        for(int i=1;i<=n;i++){
                if(!root[i])DFS(i,0,0,i);
        }
        scanf("%d",&q);
        for(int i=1; i<=q; i++) {
                int x,y;
                scanf("%d %d",&x,&y);
                if(root[x]!=root[y]) {
                        puts("-1");
                        continue;
                }
                printf("%d\n",LCA(x,y));
        }
        return 0;
}
```

---

## 作者：niiick (赞：134)

####update 8.31

网上讲解Kruskal重构树的比较少，
自己写了篇博客对Kruskal重构树小小的总结了一下，希望对大家有所帮助
####[Kruskal重构树—学习笔记](https://blog.csdn.net/niiick/article/details/81952126)

博客讲解细致一些，下面的有所简化
****************
翻了几页竟然都没看到kruskal重构树???

很经典的Kruskal重构树应用—求**图中任意两点间所有路径中最小边权的最大值**

在kruskal的过程中

若当前边所连两点u和v不在一个集合内

则**新建一个节点node，点权为该边边权**

然后连接**u所在集合的根与node**以及**v所在集合的根与node**

重构完成之后，指定**每个集合的根作为所在森林的根**

则u到v路径上最大边权的最小值
就是**LCA(u,v)的点权**

```cpp
#include<iostream>
#include<vector>
#include<algorithm>
#include<queue>
#include<cstring>
#include<cstdio>
using namespace std;

int read()
{
    int f=1,x=0;
    char ss=getchar();
    while(ss<'0'||ss>'9'){if(ss=='-')f=-1;ss=getchar();}
    while(ss>='0'&&ss<='9'){x=x*10+ss-'0';ss=getchar();}
    return f*x;
}

const int maxn=200010;
int n,m,cnt;
struct node{int u,v,dis;}edge[maxn];
bool cmp(node a,node b){return a.dis>b.dis;}
struct node2{int v,nxt;}E[maxn];
int head[maxn],tot;
int val[maxn],ff[maxn],vis[maxn];
int fa[maxn],top[maxn],son[maxn];
int size[maxn],dep[maxn];

void add(int u,int v)
{
    E[++tot].nxt=head[u];
    E[tot].v=v;
    head[u]=tot;
}

int find(int x)
{
    if(x==ff[x])return x;
    else return ff[x]=find(ff[x]);
}

void dfs1(int u,int pa)
{
    size[u]=1; vis[u]=1;
    for(int i=head[u];i;i=E[i].nxt)
    {
        int v=E[i].v;
        if(v==pa) continue;
        dep[v]=dep[u]+1; fa[v]=u;
        dfs1(v,u);
        size[u]+=size[v];
        if(size[v]>size[son[u]])son[u]=v;
    }
}

void dfs2(int u,int tp)
{
    top[u]=tp;
    if(son[u])dfs2(son[u],tp);
    for(int i=head[u];i;i=E[i].nxt)
    {
        int v=E[i].v;
        if(v==fa[u]||v==son[u])continue;
        dfs2(v,v);
    }
}

void kruskal()
{
    sort(edge+1,edge+1+m,cmp);
    for(int i=1;i<=n;++i)ff[i]=i;
    for(int i=1;i<=m;++i)
    {
        int fu=find(edge[i].u),fv=find(edge[i].v);
        if(fu!=fv)
        {
            val[++cnt]=edge[i].dis;
            ff[cnt]=ff[fu]=ff[fv]=cnt;
            add(fu,cnt); add(cnt,fu);
            add(fv,cnt); add(cnt,fv);
        }
    }
    for(int i=1;i<=cnt;++i)//注意图可能是个森林
    if(!vis[i])
    {
        int f=find(i);
        dfs1(f,0); dfs2(f,f);
    }
}

int LCA(int u,int v)
{
    while(top[u]!=top[v])
    {
        if(dep[top[u]]>dep[top[v]])u=fa[top[u]];
        else v=fa[top[v]];
    }
    return dep[u]<dep[v]?u:v;
}

int main()
{
    n=read();m=read();cnt=n;
    for(int i=1;i<=m;i++)
    edge[i].u=read(),edge[i].v=read(),edge[i].dis=read();
    
    kruskal();
    int q=read();
    while(q--)
    {
        int u=read(),v=read();
        if(find(u)!=find(v))printf("-1\n");
        else printf("%d\n",val[LCA(u,v)]);
    }
    return 0;
    //niiick
}
```

---

## 作者：NaCly_Fish (赞：67)

终于把这题切了。。百感交集啊  
听说 NOIp 前发题解可以 rp++，于是就有了这篇题解  
   
首先我们来分析：   
要使得货车装最重的货物，那么就必须货车走的路载重要尽可能大 —— 也就是说，载重较小的路是不会被走过的。


于是我们就可以想到构建一棵原图的最大生成树（参见模板 [P3366 最小生成树](https://www.luogu.org/problemnew/show/P3366)）。这样就可以在满足**各城市之间连通情况不变**的前提下，使得城市之间路载重最大。  
****
然后：求货车能装最大货物重量的问题，就转化成了求树上两点权值最小的边的问题了！   
   
如果用朴素算法求的话，显然是不行的，单次查询会被卡到 $\mathcal O(n)$ 的复杂度。  
那我们可以换一种思路：倍增求出 $u,v$ 两点的 LCA，设其为 $t$。  
那么 $u$ 到 $v$ 的最小边权就是：$u$ 到 $t$ 的最小边权 和 $v$ 到 $t$ 的最小边权取较小值。  
$u,v$ 到 $t$ 的最小边权又怎么求呢？   
     
我们可以建一个数组 `minw`（即 Minimum Weight），其中 `minw[i][j]` 表示 $i$ 节点到其 $2^j$ 级祖先之间的最小边权。是不是和倍增 LCA 的做法很像？   
这样就可以在求 LCA 的过程中得到答案了。  

我们也容易推出 `minw` 的递推公式：   
（为了方便，这里设 $i$ 的 $2^j$ 级祖先为 $g$）
```cpp
minw[i][j] = min(minw[i][j-1],minw[g][j-1]);
```
有了递推公式，`minw` 数组就可以在预处理节点祖先信息时搞定了。   
 ****
最后就是计算答案的部分：  

对于不连通的两个点很好判断，用并查集判一下，如果不连通直接输出 $-1$。  
如果两点连通：  
我们需要记录答案 `ans` ，并初始化为正无穷（取一个足够大的整数即可）。   
对于点 $u$，倍增过程中每次跳到其 $2^j$ 级节点时，进行操作：   
```cpp
ans = min(ans,minw[u][j]);
```
这样你就得到了答案！
    
注意坑点：  
给定的图可能有一些互不连通的城市群，在预处理的时候不要遗漏了。

参考代码：
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<vector>
#define N 10003
#define inf 0x3f3f3f3f
using namespace std;

struct edge{
    int u,v,w;
    edge(int u=0,int v=0,int w=0):u(u),v(v),w(w){}
    bool operator < (const edge& a) const{
        return w>a.w;
    }
};

int f[N][15],depth[N],lg2[N];
int ft[N],minw[N][15];
bool vis[N];
vector<edge> adj[N];
edge e[50003];
int n,m;

inline int min(int a,int b){
    if(a>b) return b;
    return a;
}

int find(int x){
    if(ft[x]==x) return x;
    ft[x] = find(ft[x]);
    return ft[x];
}

inline void read(int &x){
    x = 0;
    char c = getchar();
    while(!isdigit(c)) c = getchar();
    while(isdigit(c)){
        x = (x<<3)+(x<<1)+c-'0';
        c = getchar();
    }
}

inline int getw(int u,int v){
    int l = adj[u].size();
    for(int i=0;i<l;++i){
        if(v==adj[u][i].v) 
            return adj[u][i].w;
    }
}

void dfs(int u,int fa){
    vis[u] = true;
    depth[u] = depth[fa]+1;
    f[u][0] = fa;
    int w,g,v,l,t = lg2[depth[u]];
    w = getw(u,fa);
    minw[u][0] = w;
    if(fa==0) minw[u][0] = inf;
    for(int i=1;i<t;++i){
        g = f[u][i-1];
        minw[u][i] = min(minw[u][i-1],minw[g][i-1]);
        f[u][i] = f[g][i-1];
    }
    l = adj[u].size();
    for(int i=0;i<l;++i){
        v = adj[u][i].v;
        if(v==fa) continue;
        dfs(v,u);
    }
}

int lca(int a,int b){
    if(find(a)^find(b)) return -1;
    int t,res = inf;
    if(depth[a]<depth[b]){
        t = a;
        a = b;
        b = t;
    }
    while(depth[a]>depth[b]){
        t = lg2[depth[a]-depth[b]]-1;
        res = min(res,minw[a][t]);
        a = f[a][t];
    }
    if(a==b) return res;
    for(t=lg2[depth[a]]-1;t>=0;--t){
        if(f[a][t]==f[b][t]) continue;
        res = min(res,min(minw[a][t],minw[b][t]));
        a = f[a][t];
        b = f[b][t];
    }
    res = min(res,min(minw[a][0],minw[b][0]));
    return res;
}

void kruskal(){
    sort(e+1,e+1+m);
    int cnt = n-1;
    for(int i=1;i<=m;++i){
        if(cnt==0) break;
        int fu,fv,u,v,w;
        u = e[i].u;
        v = e[i].v;
        w = e[i].w;
        fu = find(u);
        fv = find(v);
        if(fu==fv) continue;
        ft[fu] = fv;
        --cnt;
        adj[u].push_back(edge(u,v,w));
        adj[v].push_back(edge(v,u,w));
    }
}

int main(){
    memset(minw,inf,sizeof(minw));
    int u,v,w,q;
    read(n),read(m);
    for(int i=1;i<=n;++i) ft[i] = i;
    for(int i=1;i<=m;++i){
        read(u),read(v),read(w);
        e[i] = edge(u,v,w);
    }
    kruskal();
    lg2[1] = 1;
    for(int i=2;i<=n;++i)
        lg2[i] = lg2[i-1]+(i>>lg2[i-1]==1);
    for(int i=1;i<=n;++i){
        if(vis[i]) continue;
        dfs(i,0);
    }
    read(q);
    ++q;
    while(--q){
        read(u),read(v);
        printf("%d\n",lca(u,v));
    }
    return 0;
}
```

---

## 作者：zhengrunzhe (赞：34)

貌似没有C++ Tarjan的题解(不加RMQ)

交了n遍终于变成最优解

主要用的的算法:kruskal(最大生成树)+Tarjan(最近公共祖先)

对于读入进来的每一条边，我们做一边最大生成树

就得到了n-1条最大生成树中的边

逐次访问这n-1条边，

需要建一个特殊的树，通过并查集来实现

该树特征：对于一个非叶节点，该节点的权值代表左子树的所有节点到右子树中的所有节点的答案(该树共有2n-1个节点)

对于每一条边，把该边的两个端点所在的集合的顶端间建一个节点，该节点的权值为该边的权值，之后把两个端点和该节点的集合合并起来

对于样例(有一个4号节点，但是没有连它的边，所以算了不画了):

 ![](https://cdn.luogu.com.cn/upload/pic/6451.png) 

建出的特定的树为(圈圈中的数字代表节点，旁边的数字代表权值):

 ![](https://cdn.luogu.com.cn/upload/pic/6452.png) 

如图，1号2号节点到3号节点的答案为它们的LCA的权值，那么

所以我们只要在这颗特定的树中，求两点的lca的权值，即答案

因为我用的是tarjan，是离线算法，一开始把ans数组全部设为-1，后来在求解，

求不出来的就是-1无解

(说出来可能有点混乱，看代码就懂了吧)

### 数据已加强 图可能并不连通

所以由于Tarjan求lca法只能处理一棵树 但求出来的kruskal重构树可能由于图并不连通而造成构成森林，一次tarjanDFS只能处理一棵树 ，所以我们需要多加一个循环进行多次dfs

森林中，每次只对一棵树的根开始dfs，如何判断是不是树根呢？我重构树的时候，采用了并查集，find(x)就能找到点x的根，如果find(x)==x的话就说明x是一个树根，因为当fa[x]==x时find(x)==x，所以可以简写成fa[x]==x

dfs处理询问时，原本条件是if(vis[v])就代表find(v)(此时是dfs时所用的并查集操作)是(u,v)的lca，但由于存在森林，所以需要加上一点特殊处理：
1.每次dfs前清零vis数组，前一棵树中的所有节点都标记为未访问过，这样if(vis[一个非同棵中的节点])必定不成立。但是清零也耗时啊，有可能就T了，所以不太好做

2.加一条判断Find(u)==Find(v)(此时的Find表示重构树中的并查集操作，该语句意思即在重构树中处于同一集合)，在同一棵树中才能处理，可行 不慢

~~3.写倍增/树剖~~
```cpp
#include<cstdio>
#include<algorithm>
#define reg register
using namespace std;
const int N=100000,M=500000,Q=300000;
bool vis[2*N];
int n,m,que,from[N],cnt,fa[2*N],f[2*N],ans[Q],k;
struct edge{int to,w,next;}e[M],q[Q*2],te[M];
struct tree{int l,r,d;}t[N*2];
//这里其实偷懒了，其实这个是邻接表的结构，而e和te数组并不是真的邻接表 
//e代表读入的每一条边，to代表该边的一个节点，next代表另一个节点，w代表边权 
//te与e的结构一样，代表最大生成树中的每一条边
inline void read(reg int &x)
{
    reg int out=0;reg char cc=getchar();
    while (cc>57||cc<48)cc=getchar();
    while (cc>=48&&cc<=57)
        out=out*10+cc-48,cc=getchar();
    x=out;
}
inline void add(reg int a,reg int b,reg int c)
{
    q[++cnt].next=from[a];
    q[cnt].to=b;
    q[cnt].w=c;
    from[a]=cnt;
}
inline bool cmp(const edge &e1,const edge &e2)
{
    return e1.w>e2.w;
}
inline void clear()
{
    for (int i=1;i<2*n;i++)fa[i]=i;
}
int Find(reg int o)
{
    if (fa[o]==o)return o;
    return fa[o]=Find(fa[o]);
}
inline void Union(reg int a,reg int b)
{
    reg int f1=Find(a),f2=Find(b);
    if (f1==f2)return;
    fa[f2]=f1;
}
int Findd(reg int x)
{
	return f[x]==x?x:f[x]=Findd(f[x]);
}
inline void Unionn(reg int a,reg int b)
{
	reg int f1=Findd(a),f2=Findd(b);
	if (f1==f2)return;
	f[f2]=f1;
}
inline void kruskal() //最大生成树 
{
    for (reg int i=1;i<=m;i++)
    {
        reg int u=e[i].to,v=e[i].next;
        if (Find(u)!=Find(v))
            Union(u,v),te[++k]=e[i];//将该条边加到最大生成树中 
    }
}
inline void build()
{
    for (reg int i=1;i<=k;i++)//在最大生成树的每一条边里找 
    {
        reg int u=Find(te[i].to),v=Find(te[i].next);
        t[n+i].l=u;t[n+i].r=v;
        t[n+i].d=te[i].w;
        //因为t[n+i]的节点肯定是闲置的，所以我们把它当作一个存权值的借点，代表从它的左子树中的每一个节点到右子树中的每一个节点的答案 
        Union(n+i,u);Union(n+i,v);
    }
}
void tarjan(reg int p) //一次tarjan处理一棵森林中的所有询问
{
    vis[p]=1;
	for (reg int i=from[p];i;i=q[i].next)
    {
       	reg int v=q[i].to;
       	if (vis[v]&&Find(v)==Find(p))ans[q[i].w]=t[Findd(v)].d;
        //不同棵树是不能处理的
    }
    reg int ls=t[p].l,rs=t[p].r;
    if (ls)tarjan(ls),Unionn(p,ls);
    if (rs)tarjan(rs),Unionn(p,rs);
}
int main()
{
    read(n);read(m);
    for (reg int i=1;i<=m;i++)
        read(e[i].to),read(e[i].next),read(e[i].w);
    read(que);
    for (reg int i=1;i<=que;i++)
    {
        reg int x,y;
        read(x);read(y);
        add(x,y,i),add(y,x,i);
    }
    sort(e+1,e+m+1,cmp);
    clear();kruskal();
    clear();build();
    fill(ans+1,ans+que+1,-1);
    for (reg int i=1;i<2*n;i++)f[i]=i; //f数组代表每次dfs时的并查集操作，fa现在用来处理重构树中的森林
    for (reg int i=n+1;i<=n+k;i++)if (fa[i]==i)tarjan(i); //如果i是树根就dfs
    for (reg int i=1;i<=que;i++)printf("%d\n",ans[i]);
    return 0;
}
```

---

## 作者：天上一颗蛋 (赞：27)

# 树链剖分+线段树

## 思路
貌似题解里没有树链剖分和线段树的，贡献一发。

首先明确题目要求：一辆车走某条路从x城到y城的边权最小值

我们把要求分开来看：

1. 从x城到y城：我们需要走的路径将两点联通

1. 边权最小值：我们要找这条路上的限重最小值

如果你是一个货车司机（而且题目还告诉你你的汽车走多远不要油），你肯定想多运一些货物，也就要求联通两点的权值尽可能大。

又要**保证联通**，又要**保证权值尽可能大**，没错，我们需要用到最小生成树。

（如果还不理解，你可以设想一下，有两条都可以从a到b，一条路限重10，一条路限重100，你一定会选择第二条路；我们再推广一下，如果两条路都能联通还未联通的a、b两个联通块（你可以认为a、b是两个岛，两条路是跨岛大桥），一条路限重10，一条路限重100，你还是一定会选择第二条路）

最小生成树的方法：先按边权大小排序，利用并查集判断两块是否联通，生成一个新的图

---
好，现在第一个问题解决了：你运货的最大路径方案一定在新的图（树）上了，怎么求两点之间权值最小的呢？

因为这是一棵树，所以两点之间路径唯一，可是直接搜索时间又肯定承受不住，我们这时就可以采用树链剖分了

[这是类似树剖板题的题，就有提到求某两点的最值问题](https://www.luogu.org/problemnew/show/P2590)

值得一提的是：树剖+线段树只是支持修改和查询**点权**的，这时我们就需要知道怎么将**边权转换为点权**

## 边权与点权之间的转换

![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1521015915358&di=c761d3150b4221a7eaa7dbe10521a558&imgtype=jpg&src=http%3A%2F%2Fimages0.cnblogs.com%2Fblog2015%2F790029%2F201507%2F281612511418262.png)

随便在网上找了个图：我们这样实现**边权与点权之间的转换**：将根节点的点权设为INF，**然后所有边权下放到连接的点**（所有边权往下挪到了点里，由于根节点值为INF不影响min的计算（同理，查询最大值就设为-INF））

~~然后直接查询就好啦！~~

**怎么可能？！**

刚开始的时候，我转换完后就直接像树剖板题那样求最值了，结果**只有10分**，那么问题出在哪呢？

我们看一下这个图（黑色是边权，黄色是转换后的点权）：

![](https://cdn.luogu.com.cn/upload/pic/15596.png)

若想查询A点到B点的最值，我们会发现，按普通树剖的查询方法，我们会访问20那个点（5-20-19-8），然而应该访问的路径是5-19-8，所以我们要对查询函数做一些修改，“绕开那些点”

```cpp
void getans(int x,int y){
    if(findfather(x) != findfather(y)){
        printf("-1\n");
        return ;
        }
    int ans = INF;
    while(top[x] != top[y]){
        if(dep[top[x]] < dep[top[y]])swap(x,y);
        ans = min(ans,query(1,pos[top[x]],pos[x]));
        x = fa[top[x]];
        }
    if(x == y){
        printf("%d\n",ans);//绕开
        return ;
        }
    if(dep[x] > dep[y])swap(x,y);
    ans = min(ans,query(1,pos[x] + 1,pos[y]));//+1绕开
    printf("%d\n",ans);
    }
```

# AC代码

```cpp
#include<iostream>
#include<vector>
#include<queue>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int RD(){
    int out = 0,flag = 1;char c = getchar();
    while(c < '0' || c >'9'){if(c == '-')flag = -1;c = getchar();}
    while(c >= '0' && c <= '9'){out = out * 10 + c - '0';c = getchar();}
    return flag * out;
    }
const int maxn = 500190,INF = 999999999;
int num,nr,nume,na,cnt,numt;
int head[maxn];
struct Node{
    int v,nxt,dis;
    }E[maxn * 2];
void add(int u,int v,int dis){
    E[++nume].nxt = head[u];
    E[nume].v = v;
    E[nume].dis = dis;
    head[u] = nume;
    }
struct R{
    int u,v,dis;
    }I[maxn];
bool cmp(R a,R b){
    return a.dis > b.dis;
    }
int father[maxn];
int findfather(int v){
    if(father[v] == v)return v;
    return father[v] = findfather(father[v]);
    }
void Union(int a,int b){
    int faA = findfather(a);
    int faB = findfather(b);
    if(faA != faB)father[faA] = faB;
    }
void buildG(){//建最小生成树
    for(int i = 1;i <= nr;i++){
        if(findfather(I[i].u) != findfather(I[i].v)){
            add(I[i].u,I[i].v,I[i].dis);
            add(I[i].v,I[i].u,I[i].dis);
            Union(I[i].u,I[i].v);
            }
        }
    }
int dep[maxn],fa[maxn],wson[maxn],top[maxn],size[maxn],pos[maxn],ori[maxn];
int val[maxn];
int vis[maxn];
void dfs1(int id,int F){
    vis[id] = true;
    numt++;
    size[id] = 1;
    for(int i = head[id];i;i = E[i].nxt){
        int v = E[i].v;
        if(v == F)continue;
        dep[v] = dep[id] + 1;
        fa[v] = id;
        val[v] = E[i].dis;
        dfs1(v,id);
        size[id] += size[v];
        if(size[v] > size[wson[id]]){
            wson[id] = v;
            }
        }
    }
void dfs2(int id,int TP){
    top[id] = TP;
    pos[id] = ++cnt;
    ori[cnt] = id;
    if(!wson[id])return ;
    dfs2(wson[id],TP);
    for(int i = head[id];i;i = E[i].nxt){
        int v = E[i].v;
        if(v == fa[id] || v == wson[id])continue;
        dfs2(v,v);
        }
    }
#define lid (id << 1)
#define rid (id << 1) | 1
struct sag_tree{
    int l,r;
    int min;
    int lazy;
    }tree[maxn << 2];
void build(int id,int l,int r){
    tree[id].l = l;
    tree[id].r = r;
    if(l == r){
        tree[id].min = val[ori[r]];
        return ;
        }
    int mid = l + r >> 1;
    build(lid,l,mid);
    build(rid,mid + 1,r);
    tree[id].min = min(tree[lid].min,tree[rid].min);
    }
int query(int id,int l,int r){
    if(tree[id].l == l && tree[id].r == r){
        return tree[id].min;
        }
    int mid = tree[id].l + tree[id].r >> 1;
    if(mid < l){
        return query(rid,l,r);
        }
    else if(mid >= r){
        return query(lid,l,r);
        }
    else{
        return min(query(lid,l,mid),query(rid,mid + 1,r));
        }
    }
void getans(int x,int y){
    if(findfather(x) != findfather(y)){
        printf("-1\n");
        return ;
        }
    int ans = INF;
    while(top[x] != top[y]){
        if(dep[top[x]] < dep[top[y]])swap(x,y);
        ans = min(ans,query(1,pos[top[x]],pos[x]));
        x = fa[top[x]];
        }
    if(x == y){
        printf("%d\n",ans);
        return ;
        }
    if(dep[x] > dep[y])swap(x,y);
    ans = min(ans,query(1,pos[x] + 1,pos[y]));
    printf("%d\n",ans);
    }
int main(){
    num = RD();nr = RD();
    for(int i = 1;i <= num;i++){
        father[i] = i;
        }
    for(int i = 1;i <= nr;i++){
        I[i].u = RD();
        I[i].v = RD();
        I[i].dis = RD();
        }
    sort(I + 1,I + 1 + nr,cmp);
    buildG();
    int s = 1;
    while(s <= num){
        if(vis[s] == false){
            dep[s] = 1;
            val[s] = INF;
            dfs1(s,-1);
            dfs2(s,s);
            }
        s++;
        }
    build(1,1,numt);
    na = RD();
    int u,v;
    for(int i = 1;i <= na;i++){
        u = RD();v = RD();
        getans(u,v);
        }
    return 0;
    }
```
最后，感谢大佬的帮助
[大佬](http://www.cnblogs.com/Mychael/)

[广告](https://www.luogu.org/blog/QVQ/)

---

## 作者：ikunTLE (赞：10)

[题目传送门](https://www.luogu.com.cn/problem/P1967)

### 思路

不难发现，当有两条路径同时满足从 $x$ 到 $y$，肯定会优先选择载重量较大的一条路径。然后想到可以把载重量小的边全部删掉，得到一棵**最大生成树**。

得到了一棵树，不难想到用 LCA 倍增求最终答案。

时间复杂度 $\mathcal{O}(n\log n)$，可以通过此题。

**注意事项**

- 本题不保证图连通，需要从多个起点出发。

**AC CODE**

```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){int x=0;char f=1,ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();return x*f;}
const int N=1e4+10,M=5e4+10;
int n,m,fa[N],depth[N],dp[40][N],w[40][N];
void _init(){
	for(int i=1;i<=n;++i)
		fa[i]=i;
	return;
}
int _find(int x){
	if(x==fa[x])
		return x;
	fa[x]=_find(fa[x]);
	return fa[x];
}
void _merge(int x,int y){
	int xx=_find(x),yy=_find(y);
	if(xx!=yy)
		fa[xx]=yy;
	return;
}
struct node{
	int u,v,w;
	friend bool operator<(const node cmp_x,const node cmp_y){
		return cmp_x.w>cmp_y.w;
	}
}a[M];
vector<node>vc[N];
void kruskal(){
	sort(a+1,a+m+1);
	_init();
	int cnt=0,sum=0;
	for(int i=1;i<=m;++i){
		if(cnt==n-1)
			break;
		if(_find(a[i].u)!=_find(a[i].v)){
			_merge(a[i].u,a[i].v),++cnt;
			vc[a[i].u].push_back({a[i].u,a[i].v,a[i].w});
			vc[a[i].v].push_back({a[i].v,a[i].u,a[i].w});
		}
	}
	return;
}
#define fa father
void dfs(int x,int fa){
	depth[x]=depth[fa]+1;
	dp[0][x]=fa;
	for(int i=1;i<=30;++i){
		dp[i][x]=dp[i-1][dp[i-1][x]];
		w[i][x]=min(w[i-1][x],w[i-1][dp[i-1][x]]);
	}
	for(auto i:vc[x])
		if(i.v!=fa){
			w[0][i.v]=i.w;
			dfs(i.v,x);
		}
	return;
}
#undef fa
int lca(int x,int y){
	if(_find(x)!=_find(y))
		return -1;
	if(depth[x]<depth[y])
		swap(x,y);
	int h=depth[x]-depth[y],ans=INT_MAX;
	for(int i=30;i>=0;--i)
		if(h>=(1<<i)){
			h-=(1<<i);
			ans=min(ans,w[i][x]);
			x=dp[i][x];
		}
	if(x==y)
		return ans;
	for(int i=30;i>=0;--i)
		if(dp[i][x]!=dp[i][y]&&(1<<i)<=depth[x]){
			ans=min(ans,w[i][x]);
			x=dp[i][x];
			ans=min(ans,w[i][y]);
			y=dp[i][y];
		}
	return min(ans,min(w[0][x],w[0][y]));
}
int main(){
	n=read(),m=read();
	memset(w,0x3f,sizeof(w));
	for(int i=1;i<=m;++i)
		a[i]={read(),read(),read()};
	kruskal();
	for(int i=1;i<=n;++i)
		if(!depth[i])
			dfs(i,0);
	int q=read();
	while(q--){
		int x=read(),y=read();
		printf("%d\n",lca(x,y));
	}
	return 0;
}
```

---

## 作者：SammyChu (赞：7)

本题最关键的一步就是想到利用**最大生成树**来简化图，使其变成一棵树，转化为树上的题目。

那么这里简单证明一下关于使用最大生成树来简化问题的正确性。（任意一辆货车只需要在这棵树上跑就好了）

反证法：

命题：假设存在一条从$u$到$v$的路径，设为$x$，使得这条路径上的最小边权大于最大生成树上$u$到$v$的路径(设为$y$)上的最小边权（有点绕，其实就是有一条**更优的路径**）

若该命题成立：

那么，假设这条路径上的最小边为$a$,树上的最小边为$b$。易得：
$$a < b$$
我们再来考虑一下最大生成树的求出过程（$kruskal$，$prim$同理，这里用$kruskal$）：
1. 对所有边从**大到小**排序

1. 依次选边，一条边被选入最大生成树的条件是它所连的两个结点不在同一个并查集，即**两点不连通**。

既然如此，那么也就是说$a$在$kruskal$过程中被考虑到时没有被选入最大生成树。由此可得$a$所连的两个结点能够通过一些 （**边权最小值更大的**） 路径互相到达，而其中的**最优的路径一定是在最大生成树上**的，设为$z$。~~（划分句子结构）~~

这个还要证吗？好吧，如果不在最大生成树上，**请从证明开始的地方重复以上过程**……~~（逃）~~

所以我们可以知道，$z$路径比$x$路径更优；而$z$路径是在最大生成树上的。

又因为**树上两点有且仅有一条简单路径**（不走回头路），所以
$$y=z$$
而这与之前假设的$x$比$y$更优**矛盾**。所以命题不成立，所以树上的路径是最优路径。

接下来考虑一个小细节：图有可能**不连通**。

这个就很烦，因为最大生成树在图不连通的情况下根本求不出来。有一个办法就是保证这个图是联通的，即**创造一个虚点**，让它和所有的点相连，这样把最大生成树的边数加1即可。

但是虚点连的边的**边权**？

考虑到这个边权不能影响连通的部分的最大生成树，也就是说必须保证不管有没有这个虚点，一个连通部分求出来的**最大生成树必须不变**；此外，对于不连通的部分，又必须**保证有这样的边把他们连起来**。考虑到在$kruskal$的时候会对便**从大到小排序**，以及题目中所说的不连通则输出-1，于是我 ~~（得到暗示）~~ 受到启发可以把虚边设为-1，这样只需直接求出路径上的最小值，如果有-1则说明不连通，就**无需特判**。

剩下的就是处理树上任意两点的简单路径的最小值。

## 暴力数据结构大法
# 好！

作为懒得思考的我，当然是使用树链剖分过掉啦。
（这就是一个树剖的板子）

关于树链剖分，需要的前置知识：线段树，DFS序

至于不会树链剖分，可以自行学习，也可以用别的方法去解决。

这里就不讲了，主要是想到最大生成树，其他就不难了，树剖只是一种办法而已。

贴代码：
```cpp
#include<bits/stdc++.h>//万能头文件 
#define INF 0x7fffffff //设置最大值，用于在线段树区间查询中求最小值 
using namespace std;
inline void read(int &x)//读入优化 
{
	int w=x=0;
	char ch=0;
	while(ch<'0'||'9'<ch)
		w|=(ch=='-'),ch=getchar();
	while('0'<=ch&&ch<='9')
		x=(x<<3)+(x<<1)+(ch^'0'),ch=getchar();
	x=w?-x:x;
}
const int N=2e4,M=1e5;
struct segtree//线段树 
{
	int l,r,wmin;
}tr[N<<2];
#define ls tr[id].l
#define rs tr[id].r
#define lid id<<1
#define rid id<<1|1
//一手宏定义 
int n,m,q,root,a,b,c;//root为虚点 
struct Edge
{
	int u,v,w;
}E[N<<1],e[M|1];//邻接表 
bool operator <(const Edge &x,const Edge &y)
{
	return x.w>y.w;
}//排序使用的重载运算符 
int last,fst[N],nxt[N<<1];
int tot,sum,rep[N];//并查集部分 
int fa[N],dep[N],size[N];
int son[N],top[N],val[N];
int cnt,name[N],node[N];//树链剖分所需的数组 
int find(int x)//并查集 
{
	while(x!=rep[x])
		x=rep[x]=rep[rep[x]];
	return x;
}
void add(int x,int y,int z)//加边 
{
	E[++last]=(Edge){x,y,z};
	nxt[last]=fst[x],fst[x]=last;
}
void pre(int x)//树链剖分第一次DFS 
{
	dep[x]=dep[fa[x]]+1,size[x]=1;
	for(int i=fst[x];i;i=nxt[i])
		if(E[i].v^fa[x])//相当于E[i].v!=fa[x] 
		{
			fa[E[i].v]=x,val[E[i].v]=E[i].w;
			pre(E[i].v),size[x]+=size[E[i].v];
			if(size[son[x]]<size[E[i].v])
				son[x]=E[i].v;
		}
}
void dfs(int x,int up)//树链剖分第二次DFS 
{
	top[x]=up,name[x]=++cnt,node[cnt]=x;
	if(son[x])
		dfs(son[x],up);
	for(int i=fst[x];i;i=nxt[i])
		if(E[i].v^fa[x]&&E[i].v^son[x])
			dfs(E[i].v,E[i].v);
}
void build(int x,int y,int id)//线段树建树 
{
	ls=x,rs=y;
	if(x==y)
	{
		tr[id].wmin=val[node[x]];
		return;
	}
	int mid=(ls+rs)>>1;
	build(x,mid,lid),build(mid+1,y,rid);
	tr[id].wmin=min(tr[lid].wmin,tr[rid].wmin);
}
int query(int x,int y,int id)//无需修改，所以modify都懒得写了 
{
	if(x<=ls&&rs<=y)
		return tr[id].wmin;
	int mid=(ls+rs)>>1,res=INF; 
	if(x<=mid)
		res=min(res,query(x,y,lid));
	if(y>mid)
		res=min(res,query(x,y,rid));
	return res;
}
int ask(int x,int y)//树链剖分查询路径上最小边权 
{
	int res=INF;
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]])
			swap(x,y);
		res=min(res,query(name[top[x]],name[x],1));
		x=fa[top[x]];
	}
	if(x==y)
		return res;
	if(name[x]>name[y])
		swap(x,y);
	return min(res,query(name[x]+1,name[y],1));
}
int main()
{
	read(n),read(m),root=n+1;
	for(int i=1;i<=n;++i)
		rep[i]=i,e[++sum]=(Edge){root,i,-1};//连虚边 
	for(int i=1;i<=m;++i)
	{
		read(a),read(b),read(c);
		e[++sum]=(Edge){a,b,c};
	}
	sort(e+1,e+sum+1);//排序 
	//由于kruskal的求解过程无需建图，所以我们只连最大生成树上的边就好 
	for(int i=1;i<=sum;++i)
	{
		a=e[i].u,b=e[i].v,c=e[i].w;
		if(find(a)!=find(b))//最大生成树的求解过程 
		{
			add(a,b,c),add(b,a,c);//现在再来连边 
			++tot,rep[find(b)]=find(a);
		}
		if(tot==n)
			break;
	}
	pre(root),dfs(root,root),build(1,root,1);
	read(q);
	for(int i=1;i<=q;++i)
		read(a),read(b),printf("%d\n",ask(a,b));
	return 0;
}
```
这不就AC了吗？不喜勿喷 ~~喜欢的记得点个赞哟！~~

---

## 作者：songge888 (赞：6)

### 题意

给你一片森林，求森林中两点的路径中，最小边权的最大值，若两点不连通，输出 $-1$。

### 思路

先假设点 $x$ 和 $y$ 连通（$x$ 和 $y$ 在一个子图上）。

为了让路径上的最小边权最大，则这个路径一定在两点所在树的最大生成树（MST）上，让我们来利用反证法简要证明一下。

假设有两个点 $s$ 和 $t$ 之间在最大生成树上的路径的最小边权为 $E$，如果存在另外一条路径使得路径上的最小路径 $E'>E$，那么在一开始用 Kruskal 求最大生成树的时候，$E'$ 就被选了，所以最优路径一定在最大生成树上。

~~证完了？~~

我们现在只保留最大生成树。

$x$ 到 $y$ 的路径为 $x \to \text{LCA}(x,y) \to y$。

LCA 可以用倍增求。

但是如果暴力求路径上的最小值，当树是一条链的时候会被卡到 $O(n)$，显然会寄。

考虑优化。

开一个数组 $dis$，$dis_{i,j}$ 表示 $i$ 的第 $2^j$ 个祖宗和 $i$ 之间的最小边权。

当枚举到 $i$ 的第 $2^j$ 个祖宗（下设为 $k$）时：

$$dis_{i,j}=\min(dis_{i,j-1},dis_{k,j-1})$$

跟 LCA 求 $fa$ 很像啊，那就一起维护吧。

但是还没完。

一开始我们假设：

> 先假设点 $x$ 和 $y$ 连通（$x$ 和 $y$ 在一个子图上）。

那么如果两个点不连通呢？

用一个并查集维护每个点所在的连通块就行了。

时间复杂度 $O(n \log n)$。

### Code

```c++
#include<bits/stdc++.h>
#define bug cout<<"songge888"<<'\n';
#define int long long
using namespace std;
const int INF=1e18;
int n,m,q;
int ans;
struct node{
	int v,w;
};
struct lyl{
	int u,v,w;
}a[50010];
bool operator <(lyl x,lyl y){
	return x.w>y.w;
}
vector<node> g[50010];
int faa[50010];//维护并查集的，不是维护LCA
int vis[50010];
int dis[50010][55];
int depth[50010],fa[50010][55],lg[50010];
void dfs(int now,int fath,int d){
	vis[now]=1;
	dis[now][0]=d;
	fa[now][0]=fath;
	depth[now]=depth[fath]+1;
	for(int i=1;i<=lg[depth[now]];i++){
		fa[now][i]=fa[fa[now][i-1]][i-1];
		dis[now][i]=min(dis[now][i-1],dis[fa[now][i-1]][i-1]);
	}
	for(auto [v,w]:g[now]){
		if(v!=fath){
			dfs(v,now,w);
		}
	}
	return ;
}
int LCA(int x,int y){
	ans=INF;
	if(depth[x]<depth[y]){
		swap(x,y);
	}
	while(depth[x]>depth[y]){
		ans=min(ans,dis[x][lg[depth[x]-depth[y]]-1]);
		x=fa[x][lg[depth[x]-depth[y]]-1];
	}	
	if(x==y){
		return ans;
	}
	for(int k=lg[depth[x]]-1;k>=0;k--){
		if(fa[x][k]!=fa[y][k]){
			ans=min(ans,min(dis[x][k],dis[y][k]));
			x=fa[x][k],y=fa[y][k];
		}
	}
	ans=min(ans,min(dis[x][0],dis[y][0]));
	return ans;
}
int Find(int x){
	if(faa[x]==x){
		return x;
	}
	else{
		return faa[x]=Find(faa[x]);
	}
}
void add(int u,int v){
	faa[u]=v;
}
int cnt;
void ku(){
	for(int i=1;i<=m;i++){
		if(Find(a[i].u)!=Find(a[i].v)){
			add(Find(a[i].u),Find(a[i].v));
			g[a[i].u].push_back({a[i].v,a[i].w});
			g[a[i].v].push_back({a[i].u,a[i].w});
			cnt++;
		}
		if(cnt==n-1){
			break;
		}
	}
	return ;
}
signed main(){
//	freopen("input.txt","r",stdin);
	
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=n;i++){
    	faa[i]=i;
	}
	for(int i=1;i<=n;i++){
		lg[i]=lg[i-1]+(1<<lg[i-1]==i);
	}
    for(int i=1;i<=m;i++){
    	cin>>a[i].u>>a[i].v>>a[i].w;
	}
	sort(a+1,a+1+m);
	ku();
//	bug
	for(int i=1;i<=n;i++){
		if(!vis[i]){
			dfs(i,0,0); 
		}
	}
	
	cin>>q;
	while(q--){
		int s,t;
		cin>>s>>t;
		if(Find(s)!=Find(t)){
			cout<<-1<<'\n';
		}
		else{
			cout<<LCA(s,t)<<'\n';
		}
	}
	return 0;
}
```

---

## 作者：WsW_ (赞：3)

### 思路
容易发现，如果某一条道路连接的两座城市，可以通过其他限重都不小于这条道路的若干条道路连通，那么这一条道路就是废物道路，可以把它删了。  
将道路看做边，城市看做点。  
根据贪心思想，显然我们应该按边权从小到大判断并删边。但是删边并判断连通性非常复杂，不过正难则反，既然删边很麻烦，我们就考虑从零开始加边。  
显然最大边肯定是要的；如果次大边和最大边不重，那最大边也是要的；我们发现，如果加了某条边会成环，那就说明这条边是废物边。  
判环可以用并查集。按照上面这个方法加边之后，我们发现原来的图就变成了一棵没有废物边的树。树上两点间只有唯一路径，题目就变成了查询树上两点间路径上边权的最小值。  
查询树上关于两点间路径的信息可以利用树上倍增。  

需要对边按边权排序，遍历边并用并查集判环，预处理树上倍增，查询的时候树上倍增。  
时间复杂度为 $O(m\log m+n\log n+q\log n)$。

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef tuple<int,int,int> tiii;
typedef pair<int,int> pii;
int n,m,q;
tiii edg[50005];
int fa[10003];
int Log[10003];
int dep[10003],f[10003][15],mn[10003][15];
vector<pii>e[10003];
bool vis[10003];

int findfa(int u){
	if(fa[u]!=u)fa[u]=findfa(fa[u]);
	return fa[u];
}
void kruskal(){
	for(int i=1;i<=n;i++)fa[i]=i;
	for(int i=1;i<=m;i++){
		int u=get<1>(edg[i]),v=get<2>(edg[i]);
		if(findfa(u)==findfa(v))continue;
		fa[fa[u]]=fa[v];
		e[u].push_back({v,get<0>(edg[i])});
		e[v].push_back({u,get<0>(edg[i])});
//		cout<<u<<' '<<v<<"  ="<<get<0>(edg[i])<<'\n';
	}
}

void dfs(int p,int fa){
	vis[p]=1;
	dep[p]=dep[fa]+1;
	f[p][0]=fa;
//	cout<<"\n"<<p<<" "<<dep[p]<<'\n';
	for(int i=1;i<=Log[dep[p]];i++){
		f[p][i]=f[f[p][i-1]][i-1];
		mn[p][i]=min(mn[f[p][i-1]][i-1],mn[p][i-1]);
//		cout<<mn[p][i]<<' ';
	}
	for(int i=0;i<e[p].size();i++){
		if(!vis[e[p][i].first]){
			mn[e[p][i].first][0]=e[p][i].second;
			dfs(e[p][i].first,p);
		}
	}
}

int lca(int x,int y){
	if(dep[x]<dep[y])swap(x,y);
	int ans=1e9;
	while(dep[x]>dep[y]){
		ans=min(ans,mn[x][Log[dep[x]-dep[y]]]);
//		cout<<ans<<'\n';
		x=f[x][Log[dep[x]-dep[y]]];
	}
	if(x==y)return ans;
	for(int i=Log[dep[x]];i>=0;i--){
		if(f[x][i]==f[y][i])continue;
		ans=min({ans,mn[x][i],mn[y][i]});
		x=f[x][i],y=f[y][i];
	}
	ans=min({ans,mn[x][0],mn[y][0]});
	return ans;
}

int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m;
	Log[0]=-1;dep[0]=-1;
	for(int i=1;i<=n;i++)Log[i]=Log[i>>1]+1;
	for(int i=1;i<=m;i++){
		int u,v,w; cin>>u>>v>>w;
		edg[i]=make_tuple(w,u,v);
	}
	sort(edg+1,edg+1+m,greater<tiii>());
	kruskal();
	for(int i=1;i<=n;i++){
		if(!vis[i]){
			dfs(i,0);
		}
	}
	cin>>q;
	while(q--){
		int x,y; cin>>x>>y;
		if(findfa(x)!=findfa(y)){
			cout<<"-1\n";
			continue;
		}
		cout<<lca(x,y)<<'\n';
	}
	return 0;
}
```

---

## 作者：HasNoName (赞：2)

### 思路
这是一道重构树的板子题。

重构树就是每次将一张无向图中两端点在不同连通块中的边中边权最大的边上造一个点，且这个点的左右孩子分别是左右两个连通块中在重构树树上深度最小的节点，点权为这条边的边权。

由于一张图中两个点之间的简单路径中边权最小的一条边等价于最小生成树上两个点之间路径上的最大边权，又等价于重构树上两个点最近共公祖先得权值。

所以建出重构树后写最近公共祖先即可。

[推荐一篇写的很好的文章](https://www.luogu.com.cn/article/jsyjaruc)。
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=20005,M=50005,L=19;//重构树有O(2N)个节点。
struct E
{
	int ne,to;
}e[2*M];
struct P
{
	int x,y,z;
}ee[M];
int he[N],idx,fath[N],idxp,a[N];
int fa[N][L+1],d[N];
void add(int x,int y)
{
	e[++idx].ne=he[x];
	e[idx].to=y;
	he[x]=idx;
}
bool cmp(P a,P b)
{
	return a.z>b.z;
}
int find(int x)//判断两点是否在同一个集合内。
{
	if(x==fath[x])return x;
	return fath[x]=find(fath[x]);
}
void dfs(int x,int fat)//的到重构树上每个节点的信息。
{
	fa[x][0]=fat;
	d[x]=d[fat]+1;
	for(int i=he[x];i;i=e[i].ne)
	{
		int y=e[i].to;
		dfs(y,x);
	}
}
int lca(int x,int y)//最近公共祖先。
{
	if(d[x]<d[y])swap(x,y);
	for(int i=L;i>=0;i--)
		if(d[fa[x][i]]>=d[y])
			x=fa[x][i];
	if(x==y)return x;
	for(int i=L;i>=0;i--)
		if(fa[x][i]!=fa[y][i])
		{
			x=fa[x][i];
			y=fa[y][i];
		}
	return fa[x][0];
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=m;i++)
		cin>>ee[i].x>>ee[i].y>>ee[i].z;
	sort(ee+1,ee+m+1,cmp);
	for(int i=1;i<=2*n;i++)fath[i]=i;
	idxp=n;
	for(int i=1;i<=m;i++)
	{
		int x=find(ee[i].x),y=find(ee[i].y);
		if(x==y)continue;
		fath[x]=++idxp;//重构树树上深度最小的节点
		fath[y]=idxp;
		add(idxp,x);//建树
		add(idxp,y);
		a[idxp]=ee[i].z;
	}
	for(int i=1;i<=2*n;i++)
		if(fath[i]==i)dfs(i,i);
	for(int j=1;j<=L;j++)
		for(int i=1;i<=idxp;i++)
			fa[i][j]=fa[fa[i][j-1]][j-1];
	int T;
	cin>>T;
	while(T--)
	{
		int x,y;
		cin>>x>>y;
		if(find(x)!=find(y))cout<<"-1\n";//不连通
		else cout<<a[lca(x,y)]<<'\n';
	}
	return 0;
}
```

---

## 作者：CaiZi (赞：1)

[瓶颈生成树](https://oi-wiki.org/graph/mst/#%E7%93%B6%E9%A2%88%E7%94%9F%E6%88%90%E6%A0%91)板子题。

首先给的是一张图不好做，考虑只保留两个点之间最小边权最大的路径，只需要求瓶颈生成树即可，求的方法与求最小生成树相同，使用 Kruskal 算法即可。注意这里求出来的不一定是一颗树，可能是一片森林，因为原图没有保证连通，如果两点不在一个连通块，直接输出 `-1`，可以使用并查集判断。

接下来问题转化成了，给定一颗树，每次询问求两点间路径的边权的最小值。考虑倍增，维护每个点的 $2^i$ 级祖先和到 $2^i$ 级祖先的路径上的边权的最小值。然后就可以直接查询了。

代码实现非常复杂。

时间复杂度 $O(m\log m+n\log n+q\log n)$。

代码展示：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct sb{
	int x,y,z;
	friend bool operator < (sb x1,sb x2){
		return x2.z<x1.z;
	}
}w[114514];
struct tree{
	int fa[25],d,u[25];
}r[114514];
int n,m,q,a,b,f[114514],fx,fy,ans,to;
vector<pair<int,int>>v[114514];
bool k[114514];
inline int find(int t){
	return f[t]==t?t:f[t]=find(f[t]);
}
inline void dfs(int t){
	k[t]=1;
	for(int i=1;i<=20;i++){
		r[t].fa[i]=r[r[t].fa[i-1]].fa[i-1];
		r[t].u[i]=min(r[t].u[i-1],r[r[t].fa[i-1]].u[i-1]);
	}
	for(auto i:v[t]){
		to=i.first;
		if(!k[to]){
			r[to].d=r[t].d+1;
			r[to].fa[0]=t;
			r[to].u[0]=i.second;
			dfs(to);
		}
	}
	return;
}
signed main(){
	cin.tie(nullptr)->sync_with_stdio(0);
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		f[i]=i;
		cin>>w[i].x>>w[i].y>>w[i].z;
	}
	sort(w+1,w+1+m);
	for(int i=1;i<=m;i++){
		if((fx=find(w[i].x))!=(fy=find(w[i].y))){
			f[fx]=fy;
			v[w[i].x].push_back(make_pair(w[i].y,w[i].z));
			v[w[i].y].push_back(make_pair(w[i].x,w[i].z));
		}
	}
	for(int i=1;i<=n;i++){
		if(!k[i]){
			r[i].d=1;
			dfs(i);
			r[i].fa[0]=i;
			r[i].u[0]=INT_MAX;
		}
	}
	cin>>q;
	for(int i=1;i<=q;i++){
		cin>>a>>b;
		if(find(a)!=find(b)){
			cout<<"-1\n";
		}
		else{
			if(r[a].d<r[b].d){
				swap(a,b);
			}
			ans=INT_MAX;
			for(int i=20;i>=0;i--){
				if(r[r[a].fa[i]].d>=r[b].d){
					ans=min(ans,r[a].u[i]);
					a=r[a].fa[i];
				}
			}
			if(a!=b){
				for(int i=20;i>=0;i--){
					if(r[a].fa[i]!=r[b].fa[i]){
						ans=min({ans,r[a].u[i],r[b].u[i]});
						a=r[a].fa[i];
						b=r[b].fa[i];
					}
				}
				ans=min({ans,r[a].u[0],r[b].u[0]});
			}
			cout<<ans<<'\n';
		}
	}
	return 0;
}
```

---

## 作者：XCDRF_ (赞：1)

# P1967 \[NOIP2013 提高组] 货车运输

[原题传送门](https://www.luogu.com.cn/problem/P1967)

[更好的阅读体验](https://www.luogu.com.cn/article/polpf97p)

## 题目大意

给出 $n$ 个点，$m$ 条边，$q$ 组询问。每组询问需求出给出两个点之间的所有路径中，最小边权最大的那一条，并输出（若不存在输出 $-1$）。

## 解题思路

首先我们假设这两个点连通，则要使两点之间路径最小边权最大，必须走两点所在子图的最大生成树上的路径。因为最大生成树可以在保持各城市之间连通情况不变的情况下，使各点之间路径边权最大。

然后问题就转化成了求树上两点路径中边权最小值。如果暴力判断，最坏可能会被卡成 $O(n)$ 的复杂度。

这时我们考虑用倍增的思想来做。设 $f_{i,j}$ 表示 $i$ 节点上方 $2^j$ 条边中边权的最小值，递推式为：

$$ \large f_{i,j}=f_{f_{i,j-1},j-1}$$

这样就可以在 $O(\log n)$ 的复杂度下求出两点之间路径边权最小值。

注意到我们还需要求 LCA，则可以在倍增求 LCA 的同时求出 $f$ 数组。

最后我们再看一下一开始假设有的条件——两点连通，可以用并查集维护。因为我们在构建最大生成树时已经做过了并查集操作，所以在求最小边权前直接判断即可。

## 参考代码

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
const int N=1e4+5,M=1e5+5,INF=0x3f3f3f3f;
int n,m,tot,q;
int head[N],f[N],fa[N][30],minn[N][30],dep[N];
bool vis[N];
struct Edge{
	int nxt,from,to,w;
}edge[M],e[M]; 
bool cmp(Edge x,Edge y){
	return x.w>y.w;
}
void add(int x,int y,int w){
	edge[++tot]={head[x],0,y,w};
	head[x]=tot;
}	
int find(int x){
	return f[x]==x?x:f[x]=find(f[x]);
}	
void kruskal(){
    int res=0,cnt=0;
    for(int i=1;i<=m;i++){
        int x=e[i].from,y=e[i].to,w=e[i].w;
        int fx=find(x),fy=find(y);
        if(fx!=fy){
            f[fx]=fy;
            add(x,y,w);
			add(y,x,w); 
    	}
    }
}	
void dfs(int x){
	vis[x]=1;
	dep[x]=dep[fa[x][0]]+1;
	for(int i=1;(1<<i)<=dep[x];i++) fa[x][i]=fa[fa[x][i-1]][i-1],minn[x][i]=min(minn[x][i-1],minn[fa[x][i-1]][i-1]);//LCA和边权最小值
	for(int i=head[x];i;i=edge[i].nxt){
		int xx=edge[i].to;
		if(vis[xx]) continue;
		fa[xx][0]=x;//初始化
		minn[xx][0]=edge[i].w;
		dfs(xx);
	}
}

int lca(int x,int y){
	if(find(x)!=find(y)) return -1;//判断不连通情况
	if(dep[x]<dep[y]) swap(x,y);
	int ans=INF;
	for(int i=25;i>=0;i--)
		if(dep[fa[x][i]]>=dep[y]) ans=min(ans,minn[x][i]),x=fa[x][i];//一定注意先赋完值再往上跳 
	if(x==y) return ans;
	for(int i=25;i>=0;i--)
		if(fa[x][i]!=fa[y][i]) ans=min(ans,min(minn[x][i],minn[y][i])),x=fa[x][i],y=fa[y][i];
	ans=min(ans,min(minn[x][0],minn[y][0]));
	return ans;
}	
int main(){
	ios::sync_with_stdio(0);
    cin.tie(0);
	cin>>n>>m;
	for(int i=1,x,y,z;i<=m;i++){
		cin>>x>>y>>z;
		e[i]={0,x,y,z};
	}
	sort(e+1,e+m+1,cmp);
	for(int i=1;i<N;i++) f[i]=i;
	kruskal();
	for(int i=1;i<=n;i++)
		if(!vis[i]){
			dep[i]=1;
			dfs(i);
		}
	cin>>q;
	for(int i=1,x,y;i<=q;i++){
		cin>>x>>y;
		cout<<lca(x,y)<<'\n';
	}
	return 0;
}	
```

[AC 记录](https://www.luogu.com.cn/record/194925586)

---

## 作者：collegiate (赞：0)

### 重构树

看见了求**最大载重**之后，就可以想到重构树了。

那么重构树是什么？现在来解释一下。

> 我们会模仿最小生成树的算法，先将边权排序，因为这里是求**最大边权的最小值**，所以这里我们使用**升序排序**。

> 然后我们依次遍历每一条边，我们定义 $find(x)$ 为节点 $x$ 所在并查集的根。
> 
> 那么对于该边连接的两个节点 $x$ 和 $y$ 来说，如果 $find(x) \ne find(y)$ 的话，那么就新建一个节点 $id$，将 $id$ 作为节点 $find(x)$ 和 $find(y)$ 的父亲节点。
> 
> 当然别忘了更新并查集 $fa_{find(x)} = id , fa_{find(y)} = id$。


我们遍历完所有的边之后，得到了一定是一颗树！也就是重构树了。而这棵树的根节点为**最后创建的新节点**。

而如果这个图并不连通，那么就遍历每一个节点，让**这个节点所在的并查集的根作为这棵树的根**。

### 解决问题

构建了重构树之后，我们定义 $lca(x,y)$ 为重构树上的两个节点的**最近公共祖先**。

那么从节点 $x$ 到节点 $y$ 的最大承重就是 $lca(x,y)$ 的权值！

我们这里用的是**倍增**求最近公共祖先。


```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=5e4+5;
struct node{
	ll x,y,val;
}edge[N<<1];
vector<ll> G[N];
ll val[N],fa[N];
ll depth[N];
ll fath[N][22];
bool vis[N];
ll n,m,q,id,x,y,w;
bool cmp(node a,node b){
	return a.val>b.val;
}
ll find(ll x){
	return fa[x]==x ? x:fa[x]=find(fa[x]);
}
void kruskal(){//kruskal重构树
	sort(edge+1,edge+m+1,cmp);//排序
	for(int i=1;i<=n+m;i++) fa[i]=i;
	id=n;
	for(int i=1;i<=m;i++){
		x=find(edge[i].x);
		y=find(edge[i].y);
		w=edge[i].val;
		if(x==y) continue;
		++id;
		fa[x]=fa[y]=id;//新建节点
		G[id].push_back(x);
		G[id].push_back(y);
		val[id]=w;
	}
} 
void dfs(ll now,ll father){//预处理
	vis[now]=1;
	depth[now]=depth[father]+1;
	fath[now][0]=father;
	for(auto y:G[now]){
		if(y!=father) dfs(y,now);
	}
	return ;
}
ll LCA(ll x,ll y){//倍增
	if(depth[x]<depth[y]) swap(x,y);
	ll dis=depth[x]-depth[y];
	for(int i=20;i>=0;i--) if(dis>>i&1) x=fath[x][i];
	if(x==y) return x;
	for(int i=20;i>=0;i--)
		if(fath[x][i]!=fath[y][i])
			x=fath[x][i],y=fath[y][i];
	return fath[x][0];
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++) cin>>edge[i].x>>edge[i].y>>edge[i].val;
	kruskal();
	for(int i=id;i>=1;i--) if(!vis[i]) dfs(i,0);
	for(int j=1;j<=20;j++)
		for(int i=1;i<=id;i++)
			fath[i][j]=fath[fath[i][j-1]][j-1];
	cin>>q;
	while(q--){
		cin>>x>>y;
		if(find(x)!=find(y)) cout<<-1<<endl;
		else cout<<val[LCA(x,y)]<<endl;
	}
	return 0;
}
```

---

## 作者：CuFeO4 (赞：0)

图上任意两点间路径最小值最大，考虑最大生成树。

两点之间答案为 $-1$ 时，当且仅当两点不连通，用求最大生成树时的并查集判一下就好了。

反之，答案就是 $s\rightarrow t$ 之间路径的最小边权，套路地，将边权转点权，假如有一条路径 $u\rightarrow v$ 的边权为 $w$，那么 $d_v = w$（其中 $d_x$ 表示 $x$ 的点权），那么答案就是求 $s\rightarrow \operatorname{LCA}(s,t)$ 和 $t\rightarrow \operatorname{LCA}(s,t)$ 之间的点权最小值，注意不包括 $\operatorname{LCA}(s,t)$ 的点权，这个直接树剖+ST表即可做到 $O(n\log n)$ 的优秀复杂度。

总的时间复杂度 $O(m\log m+n+q\log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define rep(i,s,t,p) for(int i = s;i <= t;i += p)
#define drep(i,s,t,p) for(int i = s;i >= t;i -= p)
#ifdef LOCAL
  auto I = freopen("in.in","r",stdin),O = freopen("out.out","w",stdout);
#else
  auto I = stdin,O = stdout;
#endif
using ll = long long;using ull = unsigned long long;
using db = double;using ldb = long double;
#define eb emplace_back
const int N = 1e4 + 10,M = 5e4 + 10;
int n,m,top[N],siz[N],son[N],fa[N],dep[N],d[N],dfn[N],rdfn[N],tim;
int st[15][N];
vector<pair<int,int> > e[N];
struct Edge{int u,v,w;}E[M];
struct DSU{
  vector<int> fa;
  void init(int n){fa.resize(n+1);rep(i,1,n,1) fa[i] = i;}
  int get_fa(int x){while(x ^ fa[x]) x = fa[x] = fa[fa[x]];return x;}
  bool Merge(int x,int y){
    x = get_fa(x),y = get_fa(y);
    if(x == y) return false;
    return fa[x] = y,true;
  }
}D;
void dfs1(int x){
  dep[x] = dep[fa[x]] + 1;
  siz[x] = 1;
  for(auto &[y,w]:e[x]){
    if(y == fa[x]) continue;
    d[y] = w;fa[y] = x;dfs1(y);
    siz[x] += siz[y];
    if(siz[son[x]] < siz[y]) son[x] = y;
  }
}
void dfs2(int x,int t){
  top[x] = t;rdfn[dfn[x] = ++tim] = x;
  st[0][tim] = d[x];
  if(son[x]) dfs2(son[x],t);else return;
  for(auto &[y,w]:e[x]){
    if(y == fa[x] || y == son[x]) continue;
    dfs2(y,y);
  }
}
int Sq(int l,int r){
  if(l > r)return 0x3f3f3f3f;
  int k = __lg(r-l+1);
  return min(st[k][l],st[k][r-(1<<k)+1]);
}
int qry(int x,int y){
  if(D.get_fa(x) != D.get_fa(y)) return -1;
  if(x == y) return 0;
  int fx = top[x],fy = top[y],res = 0x3f3f3f3f;
  while(fx ^ fy){
    if(dep[fx] < dep[fy]) swap(fx,fy),swap(x,y);
    res = min(res,Sq(dfn[fx],dfn[x]));
    x = fa[fx],fx = top[x];
  }
  if(dep[x] > dep[y]) swap(x,y);
  return min(res,Sq(dfn[x]+1,dfn[y]));
}
signed main(){
  cin.tie(nullptr)->sync_with_stdio(false);
  cin>>n>>m;D.init(n);
  rep(i,1,m,1) cin>>E[i].u>>E[i].v>>E[i].w;
  sort(E+1,E+1+m,[](const Edge &x,const Edge &y){return x.w > y.w;});
  rep(i,1,m,1){
    auto &[x,y,w] = E[i];
    if(!D.Merge(x,y)) continue;
    e[x].eb(y,w);e[y].eb(x,w);
  }
  rep(i,1,n,1) if(!siz[i]) dfs1(i),dfs2(i,i);
  rep(j,1,__lg(n),1) rep(i,1,n-(1<<j)+1,1)
    st[j][i] = min(st[j-1][i],st[j-1][i+(1<<(j-1))]);
  int q;cin>>q;
  rep(test,1,q,1){
    int x,y;cin>>x>>y;
    cout<<qry(x,y)<<'\n';
  }
}
```

---

## 作者：Ak_hjc_using (赞：0)

这道题其实是一个非常模板的 **LCA** 题。

## $\texttt{思路}$

**使用算法：最大生成树，倍增 LCA。**

由于数据范围非常的大，我们可以考虑使用**倍增算法：LCA** 来解决这个问题。

首先，其中有一个贪心的思路，那么就是我们既然要求是需要运最大的边权，那么我们必然不会去走那些边权较小的边，那样只会减小我们的答案，所以，我们就需要对这张图做最大生成树，直接抛弃那些边权较小的边。

然后，我们就要求答案了，要求我们求出从 $x$ 到 $y$ 的能够运输的最大价值，所以我们自然的就想到了使用 LCA 来解决这个问题，我们在除了 $fa$（表示其父亲的数组）之外，用一个 $Mi$ 数组来记录这条边上的答案，所以我们直接在 LCA 中求出答案就可以了。

## $\texttt{代码}$

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

#define int long long
const int N = 2e5 + 5;
int n, m, idx = 0, f[N], dep[N], dis[N], fa[N][30], Mi[N][30];
struct Edge {
  int u, v, w;
} a[N], b[N];
struct Node {
  int v, w;
};
vector<Node> G[N];
void add_Edge(int u, int v, int w) {
  G[u].push_back({v, w});
  G[v].push_back({u, w});
  return;
}
int find(int x) {
  if (f[x] != x) f[x] = find(f[x]);
  return f[x];
}
bool cmp(Edge a, Edge b) {
  return a.w > b.w;
}
void kruskal() {
  for (int i = 1; i <= m; ++i) {
    int u = find(a[i].u), v = find(a[i].v);
    if (u != v) {
      f[u] = v;
      add_Edge(a[i].u, a[i].v, a[i].w);
    }
  }
  return;
}
void bfs(int s) {
  queue<int> Q;
  dep[0] = 0;
  dep[s] = 1;
  Q.push(s);
  while (!Q.empty()) {
    int u = Q.front();
    Q.pop();
    for (int i = 0; i < G[u].size(); ++i) {
      int v = G[u][i].v, w = G[u][i].w;
      if (dep[v] > dep[u] + 1) {
        dep[v] = dep[u] + 1;
        fa[v][0] = u;
        Mi[v][0] = w;
        Q.push(v);
        for (int k = 1; k <= 20; ++k) fa[v][k] = fa[fa[v][k - 1]][k - 1], Mi[v][k] = min(Mi[v][k - 1], Mi[fa[v][k - 1]][k - 1]);
      }
    }
  }
  return;
}
int lca(int u, int v) {
  if (find(u) != find(v)) return -1;
  if (dep[u] < dep[v]) swap(u, v);
  int ans = 1e18;
  for (int k = 20; k >= 0; --k)
    if (dep[fa[u][k]] >= dep[v]) ans = min(ans, Mi[u][k]), u = fa[u][k];
  if (u == v) return ans;
  for (int k = 20; k >= 0; --k)
    if (fa[u][k] != fa[v][k]) ans = min(ans, min(Mi[u][k], Mi[v][k])), u = fa[u][k], v = fa[v][k];
  ans = min(ans, min(Mi[u][0], Mi[v][0]));
  return ans;
}
signed main() {
  cin >> n >> m;
  for (int i = 1; i <= n; ++i) f[i] = i;
  for (int i = 1; i <= m; ++i) cin >> a[i].u >> a[i].v >> a[i].w;
  sort(a + 1, a + m + 1, cmp);
  kruskal();
  memset(dep, 0x3f, sizeof(dep));
  memset(Mi, 0x3f, sizeof(Mi));
  for (int i = 1; i <= n; ++i) {
    if (dep[i] == 0x3f3f3f3f3f3f3f3f) {
      dep[i] = 1;
      bfs(i);
      fa[i][0] = i;
      Mi[i][0] = 0x3f3f3f3f3f3f3f3f;
    }
  }
  int Q;
  cin >> Q;
  while (Q--) {
    int u, v;
    cin >> u >> v;
    cout << lca(u, v) << '\n';
  }
  return 0;
}

```

---

## 作者：Ameiyo (赞：0)

# NOIP2013 货车运输

$ made \ by \ Ameiyo $ 

---

本来不准备打题解的，结果某机房巨佬说没有整体二分的做法，那就来水一发。

每条边有一个上限，载重量不能超过路径上所有的上限，所以最优的情况就是路径上最小的边权（上限，这样说着顺口）。

而题目要求两点间最大的载重量，即 路径上最小边权 的最大值。

给人一种二分的感觉。

那么对于 $ x $ 和 $ y $ 来说，我们二分路径上最小的边权 $ mid $ ，判断能不能从 $ x $ 只经过边权大于等于 $ mid $ 的边到达 $ y $ 。

这样的话，对于所有的询问，每次更新 $ mid $ 后要把所有满足条件的边都遍历一遍（判断是否联通最优的做法应该是并查集），在询问过多的情况下并吃不消。

但是对于所有的询问来说，很多边都是可以共用的，只要这些边的边权都大于等于他们的 $ mid $ 。所以可以考虑 __整体二分__ 。

整体二分是一种离线算法。他把共用的信息合并到一起而不用每个询问分开处理，因此可以节省巨大的复杂度。

首先把边按边权排序，每次处理时，我们把所有的询问按照各自当前的 $ mid $ 排序，然后按照从大到小的顺序遍历询问，每次遍历时保证当前并查集的信息对应着当前的询问，即所有加入的边的边权都大于等于 $ mid $ 。因为 $ mid $ 是有序的，所以已经加入的边是不用删掉的。这样对于 $ mid $ 就能判断 $ x $ 和 $ y $ 是否联通，继而改变 $ l , r $ 以及 $ mid $ ，为二分下一步进行做准备。

这里只是简略的讲一下，整体二分的练手题还有区间第 $ k $ 大。

代码要注意如果一个询问不能二分了就不能继续处理，要跳过他。

```cpp
#define reg register
#define ll long long
#define rep(i, a, b) for (reg int i = (a), i##end = (b); i <= i##end; ++i)
#define dep(i, a, b) for (reg int i = (a), i##end = (b); i >= i##end; --i)
using namespace std;

template <typename _typer> inline _typer read() {
    _typer init = 0; int ch = getchar(), k = 0;
    for ( ; !isdigit(ch); ch = getchar()) k = (ch == '-');
    for ( ; isdigit(ch); ch = getchar())
        init = (init << 3) + (init << 1) + (ch ^ 48);
    return k ? -init : init;
}
const ll N = 10005, INF = 100000;
const ll M = 50005, LogINF = 20;


char aaa;


int n, m, q, Ans[M];

struct EDGE { // 边
    int x, y, c;
    inline bool operator < (const EDGE &__) const {
        return c > __.c;
    }
} edge[M];
struct QUERY { // 询问
    int x, y, l, r, mid, res, id;
    inline bool operator < (const QUERY &__) const {
        return mid > __.mid;
    }
} Query[M];
struct UnionFindSet { // 并查集
    int fa[N];
    void Init(int n) { rep (i, 1, n) fa[i] = i; }
    int Find(int x) { return x == fa[x] ? x : fa[x] = Find(fa[x]); }
    void Uni(int x, int y) {
        x = Find(x), y = Find(y);
        if (x != y) fa[x] = y;
    }
    bool Check(int x, int y) { return Find(x) == Find(y); }
} UFS;


void Work() {
    sort(edge + 1, edge + m + 1);
    rep (ks, 1, LogINF) {
        UFS.Init(n);
        sort(Query + 1, Query + q + 1);
        int cur = 1;
        rep (i, 1, q) if (Query[i].l <= Query[i].r) {
            while (cur <= m && edge[cur].c >= Query[i].mid)
                UFS.Uni(edge[cur].x, edge[cur].y), ++cur;
            if (UFS.Check(Query[i].x, Query[i].y)) {
                Query[i].l = Query[i].mid + 1;
                Query[i].res = Query[i].mid;
            } else {
                Query[i].r = Query[i].mid - 1;
            }
            Query[i].mid = (Query[i].l + Query[i].r) >> 1;
        }
    }
}


char bbb;


int main() {
    n = read<int>(), m = read<int>();
    rep (i, 1, m) {
        edge[i].x = read<int>(), edge[i].y = read<int>();
        edge[i].c = read<int>();
    }
    rep (i, 1, q = read<int>()) {
        Query[i].x = read<int>();
        Query[i].y = read<int>();
        Query[i].l = 0, Query[i].r = INF;
        Query[i].mid = (Query[i].l + Query[i].r) >> 1;
        Query[i].res = -1, Query[i].id = i;
    }

    Work();

    rep (i, 1, q) Ans[Query[i].id] = Query[i].res;
    rep (i, 1, q) printf("%d\n", Ans[i]);
    return 0;
}
```

---

$ in \ 2019.8.10 $ 

---


# 道路值守

## 题目描述

Z-Kingdom 有着四通八达的现代化交通。时值独立庆典之际，随着来自周边国家旅客的日益增多，犯罪行为也悄无声息开始滋长起来。

特别任务支援科的警察们从总部收到了关于调查伪装在游客中的犯罪分子的请求。通过调查，他们得到了一张地图，记载了 Z-Kingdom 内每一条道路的长度。

显然，为了减少犯罪行为被发现的可能性，犯罪分子总是会选择最短的路径来行动。为了方便安排人手和推测犯罪分子采取的路线，他们希望得知任意两个地点之间，有多少条犯罪分子可能会选择的道路。


## 说明/提示

【数据规模】

- 对于 $30\%$ 的数据，保证 $N \le 50$；
- 对于 $60\%$ 的数据，保证 $N \le 100$；
- 对于 $100\%$ 的数据，保证 $N \le 500$。


## 样例 #1

### 输入

```
5 6
1 2 1
2 3 1
3 4 1
4 1 1
2 4 2
4 5 4```

### 输出

```
1 4 1 2 1 5 6 1 2 1```

# 题解

## 作者：GNAQ (赞：13)

先Floyd求出最短路


对于每一个点i：

{
枚举所有点j ，确保i,j联通，且i,j不是一点。

然后检查有多少点k与j有连边，且在i-j的最短路dis[i][j]上。（也就是检查从i到j有多少条边满足在dis[i][j]上且与j相连）


esum[j]=1\*k , k∈(g[k][j]!=0 && dis[i][k]+g[k][j]==dis[i][j])


最后考虑DP

枚举一个终点j，再枚举一个k，如果k在i-j的最短路上，那么esum[k]个方案计入C[i][j]。（有esum[k]条边可以到k点，在最短路上可以选k点，所以要计入方案数目）

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<string>
#include<cmath>
#include<algorithm>
#include<iterator>
#include<utility>
#include<queue>
using namespace std;

int nodenum,edgenum;
int g[510][510]={0},dis[510][510]={0},fx,wx,tx,C[510][510]={0};
int esum[510]={0};

inline void readx(int& x)
{
    x=0;
    register char ch=0; int k=1;
    while (ch<'0' || ch>'9') { ch=getchar(); if (ch=='-') k=-1; }
    while (ch>='0' && ch<='9') { x=x*10+ch-'0'; ch=getchar(); }
    x*=k;
}

void SPFA(int nodex)
{
    bool vis[510]={0};
    register int prex,u,v;
    queue<int> que;

    vis[nodex]=true; dis[nodex][nodex]=0; que.push(nodex);
    while (!que.empty())
    {
        u=que.front(); que.pop();
        vis[u]=false;
        for (register int i=1;i<=nodenum;i++) if (g[u][i])
        {
            if (dis[nodex][i]>dis[nodex][u]+g[u][i])
            {
                dis[nodex][i]=dis[nodex][u]+g[u][i];
                if (!vis[i])
                {
                    que.push(i);
                    vis[i]=true;
                }
            }
        }
    }
}

int main()
{
    memset(dis,0x3f,sizeof(dis));
    readx(nodenum); readx(edgenum);
    for (register int i=1;i<=edgenum;i++)
    {
        readx(fx); readx(tx); readx(wx);
        g[fx][tx]=g[tx][fx]=wx;
    }
    
    for (register int i=1;i<=nodenum;i++) SPFA(i);
    
    //init
    for (register int i=1;i<=nodenum;i++)
    {
        memset(esum,0,sizeof(esum));
        for (register int j=1;j<=nodenum;j++) if (i!=j && dis[i][j]!=dis[0][0])
        {
            for (register int k=1;k<=nodenum;k++) if (g[k][j])
            {
                if (dis[i][k]+g[k][j]==dis[i][j]) esum[j]++;
            }
        }
        for (register int j=1;j<=nodenum;j++) if (i!=j)
        {
            for (register int k=1;k<=nodenum;k++) if (i!=k)
            {
                if (dis[i][k]+dis[k][j]==dis[i][j]) C[i][j]+=esum[k];
            }
        }
    }
    
    for (register int i=1;i<=nodenum;i++)
        for (register int j=i+1;j<=nodenum;j++) printf("%d ",C[i][j]);
    
    return 0;
}
}
```

---

## 作者：__Watcher (赞：8)

上一篇题解是 2017 年的，2020 年人民前来报到 ~

---

看一个前传：他们希望得知任意两个地点之间，有多少 **地点** 犯罪分子可能会选择。

不错，枚举起点 $i$ 和终点 $j$，枚举给个节点 $k$，若 $f(i,k)+f(k,j)=f(i,j)$（$f$ 是啥自己清楚），那么 $k$ 可以出现在 $i$ 到 $j$ 的最短路上。易知，时间复杂度 $O(n^3)$。

---

考虑向该题转换。

这一次，枚举每一条 **有向边** $k$，设该边连接地点 $a$，$b$，长度为 $c$。那么，当 $f(i,a)+c+f(b,j)=f(i,j)$ 时，$k$ 这条边是可以选的（同理吗，很显然的）。经测试，该题边数非常稠密，达到 $n^2$ 级别，因此该算法复杂度 $O(n^4)$，只能拿到 $60\ pts$。

```cpp
int main() {
	cin>>n>>m;
	memset(f, 0x7f, sizeof(f));
	for(int i=1;i<=n;i++) f[i][i]=0;
	for(int i=1;i<=m;i++) {
		int a=read(), b=read(), c=read();
		charu(a, b, c);
		charu(b, a, c);
		f[a][b]=f[b][a]=min(c, f[a][b]);
	}
	for(int k=1;k<=n;k++) {
		for(int i=1;i<=n;i++) {
			for(int j=1;j<=n;j++) {
				f[i][j]=min((ll)f[i][j], (ll)f[i][k]+f[k][j]);
			}
		}
	}
	for(int i=1;i<=n;i++) {
		for(int j=i+1;j<=n;j++) {
			int ans=0;
			for(int k=1;k<=tot;k++) {
				int a=d[k].a, b=d[k].b, c=d[k].c;
				if(f[i][a]+c+f[b][j]==f[i][j]) {
					ans++;
				}
			}
			printf("%d ", ans);
		}
	}
}
```

---

于是，我们还是希望 $k$ 这一层循环枚举的是点，那么，**每一条边都接在它的到达节点上**。同上面一样，设一条边连接地点 $a$，$b$，长度为 $c$。首先满足 
$$f(i,a)+c=f(i,b)$$ 
我们枚举 $b$，看有多少条这样的边满足上式，数量加到 $b$ 头上。然后满足 
$$c+f(b,j)=f(a,j)$$
还是枚举 $b$，满足 
$$f(i,a)+c+f(b,j)=f(i,j)$$
首先 $b$ 要在 $i$ 到 $j$ 的最短路上，于是变形：
$$f(i,a)+c+f(b,j)=f(i,b)+f(b,j)$$
$$f(i,a)+c=f(i,b)$$
看，已经预处理过了。所以枚举 $b$，满足 
$$f(i,b)+f(b,j)=f(i,j)$$
然后对记在 $b$ 上的 $f(i,a)+c=f(i,b)$ 数量求和。

---

提供代码，仅供参考：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
int read() {
	int x=0, f=1; char ch=' ';
	while(!isdigit(ch)) {ch=getchar(); if(ch=='-') f=-1;}
	while(isdigit(ch)) x=(x<<3)+(x<<1)+(ch^48), ch=getchar();
	return x*f;
}
int f[505][505], n, m, tot, z[505], g[505][505];
int main() {
	cin>>n>>m;
	memset(f, 0x7f, sizeof(f));
	for(int i=1;i<=n;i++) f[i][i]=0;
	for(int i=1;i<=m;i++) {
		int a=read(), b=read(), c=read();
		f[a][b]=f[b][a]=min(c, f[a][b]);
		g[a][b]=g[b][a]=c;
	}
	for(int k=1;k<=n;k++) {
		for(int i=1;i<=n;i++) {
			for(int j=1;j<=n;j++) {
				f[i][j]=min((ll)f[i][j], (ll)f[i][k]+f[k][j]);//最短路
			}
		}
	}
	for(int i=1;i<=n;i++) {
		memset(z, 0, sizeof(z));
		for(int j=1;j<=n;j++) {
			if(i==j||f[i][j]==f[0][0]) continue;//小细节啦，注意一下
			for(int k=1;k<=n;k++) {
				if(!g[k][j]) continue;//必须直接连通
				if(f[i][k]+g[k][j]==f[i][j]) {
					z[j]++;//加在 j 头上的数量
				}
			} 
		}
		for(int j=i+1;j<=n;j++) {
			int ans=0;
			for(int k=1;k<=n;k++) {//枚举的就是 b
				if(k==i) continue;
				if(f[i][k]+f[k][j]==f[i][j]) {
					ans+=z[k];
				}
			}
			printf("%d ", ans);
		}
	}
}

```




---

## 作者：新手7889456 (赞：2)

~~其实这题挺水的，大家千万不要把它想难了~~


------------
## 正文

首先我们要一直跑最短路，对于每一次每一个点，都记录ta的爹（可能有多个爹）

最后统计答案的时候再去dfs找答案

就挺暴力的

代码：

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue> 
using namespace std;

const int N = 501,M = 250001;

int n,m,f[N],ans,tot;
int head[N],xia[M<<1],to[M<<1],dis[M<<1];
int fa[N][N],top[N];     top[i]表示 i 的爹一共有多少个，fa就是ta的爹爹们
bool ok[N];

struct edge{
	int x,dis;
	edge();
	edge(int xx,int dd){
		x = xx,dis = dd;
	}
	bool operator < (const edge & a) const {return dis>a.dis;}
	bool operator > (const edge & a) const {return dis<a.dis;}
};

priority_queue<edge> q;   啊这

void bfs(int st){
	q.push(edge(st,0));
	while(q.size()){
		int x = q.top().x;q.pop();
		ok[x] = 0;
		for(int i(head[x]);i;i=xia[i]) {
			int j(to[i]);
			if(f[j]>f[x]+dis[i]) {
				f[j] = f[x] + dis[i];
				top[j] = 1;   找到更短的，摒弃ta之前的爹
				fa[j][1] = x;  这是新爹
				if(ok[j]) continue;
				ok[j] = 1;
				q.push(edge(j,f[j]));
			}
			else if(f[j]==f[x]+dis[i]) fa[j][++top[j]] = x;  相等时的其他father
		}
	}
}

void dfs(int x) {
	ans++;
	if(ok[x]||x==0) return;   x==0 不加也行
	ok[x] = 1;
	for(int i(1);i<=top[x];++i)
	dfs(fa[x][i]);
}

int main(){
	scanf("%d%d",&n,&m);
	int x,y,z;
	for(int i(1);i<=m;++i){
		scanf("%d%d%d",&x,&y,&z);
		xia[++tot] = head[x];
		head[x] = tot,to[tot] = y,dis[tot] = z;
		xia[++tot] = head[y];
		head[y] = tot,to[tot] = x,dis[tot] = z;
	}
	for(int i(1);i<n;++i)
	{
		memset(f,0x3f,sizeof(f));
		memset(fa,0,sizeof(fa));
		memset(top,0,sizeof(top));
		memset(ok,0,sizeof(ok));
		f[i] = 0,ok[i] = 1;
		bfs(i);         阿巴阿巴，跑最短路
		for(int j(i+1);j<=n;++j) {
			memset(ok,0,sizeof(ok));
			ans = 0;
			for(int k(1);k<=top[j];++k)
			dfs(fa[j][k]);          dfs找ans
			printf("%d ",ans);
		}
	}
	return 0;
}
```


---

## 作者：_Maverick_ (赞：1)

## 思路
这道题很明显是要用 Floyd 的，所以肯定先用 Floyd 跑一遍，求出任意两点之间的最路径。这个数据范围摆明了让你 $O(n^3)$ 去过的，于是我们不难发现这道题可以 DP 来统计答案。

跑完 Floyd 后，我们去枚举所有于 $j$ 有连边且在 $i$ 到 $j$ 的最短路上的 $k$，每找到一个就将 $w_j$ 加 $1$。统计完后，我们再去找所有在 $i$ 到 $j $最短路上的点（不需要连边），每找到一个，就将 $i$ 和 $j$ 这两个点之间的答案加上 $w_k$。因为我们不难发现，如果 $k$ 在 $i$ 到 $j$ 的最短路上，那么在 $i$ 到 $k$ 最短路上的点，也在 $i$ 到 $j$ 的最短路上。这就完成了 DP。
## ACcode

```cpp
#include<bits/stdc++.h>
using namespace std;
const int inf = INT_MAX / 3;
long long a[510][510], n, m, f[510][510], wzy[510], t[510][510];
inline int read() {
	int s = 0, f = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar())if (c == '-')f = -1;
	for (; isdigit(c); c = getchar())s = (s << 3) + (s << 1) + (c ^ 48);
	return s * f;
}
inline void write(int x) {
	if (x < 0) {
		putchar('-');
		x = -x;
	}
	if (x > 9) write(x / 10);
	putchar(x % 10 + '0');
}
int main() {
	n = read();
	m = read();
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)a[i][j] = f[i][j] = inf;
	for (int i = 1; i <= m; i++) {
		int x = read(), y = read(), z = read();
		a[x][y] = f[x][y] = z;
		a[y][x] = f[y][x] = z;
	}
	for (int i = 1; i <= n; i++)a[i][i] = f[i][i] = 0;
	for (int k = 1; k <= n; k++)
		for (int i = 1; i <= n; i++)
			if (i != k)
				for (int j = 1; j <= n; j++) {
					if (i != j && j != k)
						f[i][j] = min(f[i][j], f[i][k] + f[k][j]);
				}
	for (int i = 1; i <= n; i++) {
		memset(wzy, 0, sizeof(wzy));
		for (int j = 1; j <= n; j++) {
			if (i != j && f[i][j] != inf)
				for (int k = 1; k <= n; k++) {
					if (a[k][j] != 0)
						if (f[i][k] + a[k][j] == f[i][j])wzy[j]++;
				}
		}
		for (int j = 1; j <= n; j++) {
			if (i != j)
				for (int k = 1; k <= n; k++)
					if (i != k)
						if (f[i][k] + f[k][j] == f[i][j])t[i][j] += wzy[k];
		}
	}
	for (int i = 1; i < n - 1; i++) {
		for (int j = i + 1; j <= n; j++) {
			write(t[i][j]);
			putchar(' ');
		}
	}
	write(t[n - 1][n]);
	putchar('\n');
	return 0;
}

```

---

## 作者：无名之雾 (赞：1)

~~校内模拟赛刷到的，调了我好久。~~

## 题意

求每两个点间最短路上边的数量。

## 思路

首先考虑最原始的算法。

不难想到 floyd 跑全源最短路求出两两点间最短路长度。时间复杂度 $O(n^3)$。

然后暴力统计位于最短路的边。

我们设两点间最短路为 $f_{i,j}$ 边长为 $g_{i,j}$ 那么位于最短路上的边应满足：

$$f_{i,a}+g_{a,b}+f_{b,j}=f_{i,j}$$

如果暴力枚举，时间复杂度 $O(n^2m)$ 对于稠密图，$m$ 是 $n^2$ 级的，显然无法通过测试。

仔细观察式子，不难发现式子可以拆分成两部分：

$$f_{i,a}+g_{a,b}=f_{i,b}$$
$$f_{i,b}+f_{b,j}=f_{i,j}$$

就可以发现，我们只需要 $O(n^3)$ 的预处理出第一个式子，在 $O(n^3)$ 求第二个式子即可。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long 
inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
inline void write(int x){
    if(x==0){putchar('0');return;}
	int len=0,k1=x,c[10005];
	if(k1<0)k1=-k1,putchar('-');
	while(k1)c[len++]=k1%10+'0',k1/=10;
	while(len--)putchar(c[len]);
}
const int N=5e3+5;
int f[N][N],z[N],g[N][N];
signed main(){
	int n=read(),m=read();
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			f[i][j]=INT_MAX;
		}
	} 
	for(int i=1;i<=n;i++)f[i][i]=0;
	for(int i=1;i<=m;i++){
		int a=read(),b=read(),c=read();
		f[a][b]=f[b][a]=min(c,f[a][b]);
		g[a][b]=g[b][a]=c;
	}
	for(int k=1;k<=n;k++){
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				f[i][j]=min(f[i][j],f[i][k]+f[k][j]);
			}
		}
	}
	/*for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++)cout<<f[i][j]<<" ";
		puts("");
	}*/
	for(int i=1;i<=n;i++){
		memset(z,0,sizeof z);
		for(int j=1;j<=n;j++){
			if(i==j||f[i][j]==f[0][0])continue;
			for(int k=1;k<=n;k++){
				if(!g[k][j])continue;
				if(f[i][k]+g[k][j]==f[i][j])z[j]++;
			} 
		}
		for(int j=i+1;j<=n;j++){
			int ans=0;
			for(int k=1;k<=n;k++){
				if(k==i)continue;
				if(f[i][k]+f[k][j]==f[i][j])ans+=z[k];
			}
			write(ans),putchar(' ');
		}
	}
	return 0;
}
```

---

## 作者：MarsCheng (赞：0)

# 题解：P2103 道路值守

给一个神奇的做法，复杂度不会证，但是是最优解。

显然要先 Floyd 求出最短路，记 $i$ 和 $j$ 之间的最短路为 $f_{i,j}$。

此时，一个朴素的想法是对于每一个点对 $(i,j)$，统计满足 $f_{i,x}+z+f_{y,j}=f_{i,j}$ 的边 $(x,y,z)$ 的个数。

但是显然因为题目并未对 $m$ 做限制，所以这是 $O(n^4)$ 的。

但是我们发现，找到在 $(i,j)$ 最短路上的点只需要统计满足 $f_{i,k}+f_{k,j}=f_{i,j}$ 的点 $k$ 即可。同时我们感性理解发现在最短路上面的点的平均个数应该比较少。然后我们直接枚举最短路上面的点之间的边即可。

有没有大佬给个复杂度证明啊。

## code

实现非常简单，思路也简单，直接一发跑到最优解（最优解代码加了快读）。

```cpp
#include <bits/stdc++.h>

const int N = 500 + 7, M = N * N, inf = 0x3f3f3f3f;

int n, m, dis[N][N], edge[N][N], st[N], tp, ans;

int main() {
    scanf("%d%d", &n, &m);
    memset(dis, 0x3f, sizeof(dis));
    for (int i = 1, x, y, z; i <= m; ++i) {
        scanf("%d%d%d", &x, &y, &z);
        dis[x][y] = dis[y][x] = z;
        edge[x][y] = edge[y][x] = z;
    }
    for (int i = 1; i <= n; ++i)
        dis[i][i] = 0;
    for (int k = 1; k <= n; ++k)
        for (int i = 1; i <= n; ++i)
            for (int j = 1; j <= n; ++j)
                if (dis[i][k] != inf && dis[k][j] != inf)
                    dis[i][j] = std::min(dis[i][j], dis[i][k] + dis[k][j]);
    for (int i = 1; i <= n; ++i) {
        for (int j = i + 1; j <= n; ++j) {
            tp = 0, ans = 0;
            for (int k = 1; k <= n; ++k)
                if (dis[i][k] + dis[k][j] == dis[i][j])
                    st[++tp] = k;
            for (int a = 1; a <= tp; ++a)
                for (int b = a + 1; b <= tp; ++b)
                    if (
                        edge[st[a]][st[b]] &&
                        (dis[i][st[a]] + dis[st[b]][j] + edge[st[a]][st[b]] == dis[i][j] ||
                         dis[i][st[b]] + dis[st[a]][j] + edge[st[a]][st[b]] == dis[i][j]))
                        ans++;
            printf("%d", ans);
        }
    }
    return 0;
}
```

---

## 作者：iranai (赞：0)

~~一开始以为是求有多少种最短路。~~
# 思路
题目要求的是 $x$ 节点到 $y$ 节点的最短路中有多少条路径，我们可以思考：

在 $x$ 节点到 $y$ 节点的最短路中会经过许多中间节点 $k$,假设从 $x$ 到 $y$ 的方向上，$k$ 所接收到的边有 $cnt_k$ 条在 $x$ 到 $y$ 的最短路中，那实际上$x$ 节点到 $y$ 节点的最短路中就有 $(\sum_{i = 1}^{n}cnt_i)+cnt_y$ 条边，其中 $i$ 为在 $x$ 节点到 $y$ 节点的最短路中的节点编号。

如何计算 $cnt_i$ 呢？我们假设 $d_{i,j}$ 为 $i$ 到 $j$ 的最短距离，$g_{i,j}$ 为 $i$ 到 $j$ 的边长，我们可以在每次遍历起点时预处理出所有的 $cnt_i$，即：遍历每一个目标节点 $j$，同时遍历中间节点 $k$，如果 $d_{i,k}$ 加上 $g_{k,j}$ 与 $d_{i,j}$ 相等，则证明k是在 $i$ 到 $j$ 的最短路上，且有一条边连向 $j$，那么此时我们就可以使 $cnt_j$ 加等于一。这样，对于这个起点 $i$，我们就处理出了所有的以它为起点的最短路的 $cnt_i$。

处理好了 $cnt_i$，就可以求答案了。直接遍历 $i$ 之后的目标节点 $j$，定义一个 $ans=cnt_j$ 再从 $1$ 到 $n$ 遍历中间节点 $k$，如果 $d_{i,k}+d_{k,j}=d_{i,j}$，则说明节点 $k$ 在 $i$ 节点到 $j$ 节点的最短路中，我们可以让 $ans$ 加上 $cnt_k$。遍历完后输出 $ans$ 即可。
# 代码

```
#include<bits/stdc++.h>
using namespace std;
int n,m;
int g[510][510];
int d[510][510];
void floyd(){
	for(int k=1;k<=n;k++){
		for(int i=1;i<=n;i++){
			if(i==k) continue;
			for(int j=1;j<=n;j++){
				if(j==k) continue;
				d[i][j]=min(d[i][j],d[i][k]+d[k][j]);
			}
		}
	}
}
int cnt[510];
int main(){
	memset(d,0x3f,sizeof(d));
	memset(g,0x3f,sizeof(g));
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) d[i][i]=0;
	for(int i=1;i<=m;i++){
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		d[x][y]=d[y][x]=g[x][y]=g[y][x]=z;
	}
	floyd();
	for(int i=1;i<=n;i++){
		memset(cnt,0,sizeof(cnt));
		for(int j=1;j<=n;j++){
			if(j==i) continue;
			if(d[i][j]==0x3f3f3f3f) {
				continue;
			}
			for(int k=1;k<=n;k++){
				if(g[k][j]==0x3f3f3f3f) continue;
				if(d[i][k]+g[k][j]==d[i][j]) cnt[j]++;
			}
		}
		for(int j=i+1;j<=n;j++){
			int ans=cnt[j];
			for(int k=1;k<=n;k++){
				if(k==i) continue;
				if(k==j) continue;
				if(d[i][k]+d[k][j]==d[i][j]) ans+=cnt[k];
			}
			printf("%d ",ans);
		}
	}
	return 0;
}
```

---

## 作者：lsz0205 (赞：0)

## 坑点
题目所要求的是两条路之间有多少条路（**直连的**）包含在这两个点间的最短路径中，而不是问这两个点间有多少种最短的走法。

如果有因为这样想错了的同学进来看题解，为了不让你白想，不妨做做这道题（但不能用本题的 Floyd 算法）

[题目传送门](https://www.luogu.com.cn/problem/P1144)

## 思路
注意到 $n \le 500$ 并且是求多源最短路，因此选用 Floyd 算法。

如何判断一条边是否位于最短路径中？不难想到，对于已经求出来的一条 $i$ 到 $j$ 最短路径，我们假设一个中转节点 $k$，如果由 $i$ 到 $k$ 的最短路（简记为 $d_{i,k}$)加上 $k$ 到 $j$ 之间的直连边的长度（简记为 $g_{k,j}$)
等于最短路径的长的话，那么说明 $g_{k,j}$ 位于最短路径中。

对于每一个起点，我们枚举每一个它可以到达的终点 $j$，以及中转节点 $k$，如果满足上述性质，那么我们认为由 $i$ 到 $j$ 的最短路径中，可选取的边数加一（简记为 $cnt_{j}$)。

由此可得对于所有能够用于更新的 $k$,$
C_{i,j} = \sum_{k = 1}^{n} cnt_k
$（$n$ 为满足的k的个数）

那么为什么呢？因为我们可以发现如果我们当前的 $k \ne j$，在 $d_{k,j}$ 中可以选取的边一定可以被后面的$k$ 遍历到。

## 优化
以下情况可以跳过：

1. 如果起点和重点相同

2. 如果起点和中转节点相同

3. 如果不存在最短路

4. 如果枚举某直连边时并不直连

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m;
int g[510][510];//存原图
int d[510][510];
int cnt[510];
void floyd() {
	for(int k=1; k<=n; k++) {
		for(int i=1; i<=n; i++) {
			for(int j=1; j<=n; j++)
				d[i][j]=min(d[i][j],d[i][k]+d[k][j]);
		}
	}
}
signed main() {
	memset(g,0x3f,sizeof(g));
	scanf("%lld%lld",&n,&m);
	for(int i=1; i<=n; i++) {
		g[i][i]=0;
	}
	while(m--) {
		int x,y,z;
		scanf("%lld%lld%lld",&x,&y,&z);
		g[x][y]=min(g[x][y],z);
		g[y][x]=g[x][y];
	}
	memcpy(d,g,sizeof(d));

	floyd();
	for(int i=1; i<=n; i++) {
		memset(cnt,0,sizeof(cnt));//不同起点要清空
		for(int j=1; j<=n; j++) { //枚举从i出发到j，k为中转节点，有多少条边被最短路径利用
			if(i==j) {
				continue;
			}
			if(d[i][j]==0x3f3f3f3f3f3f3f3f) {
				continue;
			}
			for(int k=1; k<=n; k++) {
				if(g[k][j]==0x3f3f3f3f3f3f3f3f||g[k][j]==0) {
					continue;
				}
				if(d[i][k]+g[k][j]==d[i][j]) { //说明最短路径中包含k->j这条边
					cnt[j]++;
				}
			}
		}
		for(int j=i+1; j<=n; j++) {
			int ans=0;
			for(int k=1; k<=n; k++) {
				if(k==i) continue;//以自己为中转节点
				if(d[i][k]+d[k][j]==d[i][j]) { //注意与44行不同
					ans+=cnt[k];
				}
			}
			printf("%lld ",ans);
		}
	}
	return 0;
}
```

---

## 作者：CultReborn (赞：0)

[原题链接](https://www.luogu.com.cn/problem/P2103)

模拟测试做到这道题，考的是 Floyd 算法的应用，蒟蒻调了一个半小时才熬出来。今天宜：写题解、一遍通过审核，所以攒攒人品顺便巩固一下这道好题。

求审核大大通过啦～～～

# 题意（简洁向）

求任意两点间所有可能的最短路的所经过的总边数。

# 思路（详细向）

无论是空间限制、时间限制还是题面都在提示着我们使用**多源**最短路算法：Floyd。于是我们先使用 Floyd 求出多源最短距离。

难点就在于如何求可能的总边数，如果做过最短路计数的大佬肯定有些想法。

在这里我们设 $u$ 和 $v$ 之间最短距离为 $dp(u,v)$，$u$ 和 $v$ 之间的边记为 $(u,v)$，边权为 $w(u,v)$，若存在一个点 $k$，使得 $dp(u,k)+w(k,v)=dp(u,v)$，则边 $(u,v)$ 一定是从 $u$ 到 $v$ 可选择的最短路，将其逐一累加在 $sum(v)$ 中，表示以 $u$ 为起点，$v$ 为终点，到达点 $v$ 的最后一条边有几种可能。

接下来处理最短路计数。假设存在点 $k$，使得 $dis(i,k)+dis(k,j)=dis(i,j)$，那么 $k$ 是从 $i$ 到 $j$ 的某条最短路径上经过的点。我们又通过前面的计算得道，从 $i$ 到 $k$ 的最短路上，到达 $k$ 的最后一条边有 $sum(k)$ 种可能，这 $sum(k)$ 条边也都是从 $i$ 到 $j$ 可以选择的道路。设 $cnt(i,j)$ 为 $i$ 至 $j$ 可能最短路的总边数，那么 $cnt(i,j)=\sum sum(k)$。

枚举所有的起点、终点、途径点，重复如上处理即可。数据范围 $n$ 在 500 以内，内存限制 125M（模拟赛开了 1G。。。），使用邻接矩阵存图完全没问题。算法复杂度瓶颈在 Floyd 和后面的遍历，为 $O(n^3)$，时限十分宽松，给到了 3 秒，稳稳过了。

另外还有几个需要注意的细节：

1. 注意是总边数而不是最短路数啊！！！！！蒟蒻一开始理解错了浪费整整半小时。
2. 注意存图数组以及最短路数组的初值，在横纵坐标相等时赋值为 $0$，其它情况赋值为无限大（边权大小没给实在让人纠结，希望修改一下题面增添一下）。
3. 注意三重循环区分清楚各个下标的含义。
4. 累加 $sum$ 数组时一定要注意特判 $j = k$ 的情况并跳出。
5. 点点之间不一定连通，最后输出答案需要特判，如果是无穷大则输出 $0$，因为这个没注意到丢了两个点。。。

# 代码（丑陋向）

```cpp
#include<bits/stdc++.h>
#define int long long //因为不知道权值数据范围所以只好这么整。。。
using namespace std;
const int maxn = 502;
inline int Read();
int n,m,cnt[maxn][maxn],G[maxn][maxn];
int dp[maxn][maxn],sum[maxn];
signed main(){
  n = Read(); m = Read();
  for(int i = 1;i <= n;++i){
  	for(int j = 1;j <= n;++j){
  	  if(i == j) G[i][j] = dp[i][j] = 0; //注意赋初值
  	  else G[i][j] = dp[i][j] = 1e10; 
      //1e10 有些保守了，虽然最终是对的
	}
  }
  for(int i = 1;i <= m;++i){
  	int u = Read(),v = Read(),w = Read();
	G[u][v] = w,G[v][u] = w; 
	dp[u][v] = w;dp[v][u] = w;
  }
  for(int k = 1;k <= n;++k) // Floyd 模板，注意 k、i、j 顺序
  	for(int i = 1;i <= n;++i)
	  for(int j = 1;j <= n;++j)
		  dp[i][j] = min(dp[i][k] + dp[k][j],dp[i][j]);
		  
  for(int i = 1;i <= n;++i){ //起 
  	memset(dep,0,sizeof(dep));
	for(int j = 1;j <= n;++j) //过 
	  for(int k = 1;k <= n;++k){ //终 
	    if(j == k) continue; //attention
	    if(dp[i][j] + G[j][k] == dp[i][k])
	      ++sum[k]; //累加可经边数
	  }
  	for(int j = 1;j <= n;++j){
	  for(int k = 1;k <= n;++k){
	  	if(dp[i][j] + dp[j][k] == dp[i][k]) //最短路计数
		  cnt[i][k] += sum[j];
	  }	
	}
  }
  for(int i = 1;i < n;++i)
    for(int j = i + 1;j <= n;++j)
      if(dp[i][j] == 1e10) printf("0 "); //特判！！！！
      else printf("%lld ",cnt[i][j]);
  return 0;
}
inline int Read(){
  char c = getchar();
  int x = 0,f = 1;
  while(c < '0' || c > '9'){
    if(c == '-') f = -1;
    c = getchar();
  }
  while(c >= '0' && c <= '9'){
    x = x * 10 + c - '0';
    c = getchar();
  }
  return x * f;
}
```

---

## 作者：ZnPdCo (赞：0)

题目大意：给定两个端点，求两个端点间的最短**道路**数量。

---

设 $f_{i,j}$ 表示从 $i$ 到 $j$ 的最短距离，$g_{i,j}$ 表示**直接连接** $i$ 到 $j$ 的道路长度。如果 $a\to b$ 是 $i\to j$ 最短路上的一条边，下列条件一定成立：

$$
f_{i,a}+g_{a,b}+f_{b,j}=f_{i,j}
$$

统计答案也非常简单：

$$
ans_{i,j} = \sum [f_{i,a}+g_{a,b}+f_{b,j}=f_{i,j}]
$$

但是我们发现，我们需要枚举 $i,j,a,b$ 四个东西，时间复杂度是 $O(n^4)$。

---

如果 $a\to b$ 是 $i\to j$ 最短路上的一条边，明显有：

$$
f_{i,a}+g_{a,b}=f_{i,b} \\
f_{i,b}+f_{b,j}=f_{i,j}
$$

我们想要统计：
$$
ans_{i,j} = \sum [f_{i,a}+g_{a,b}+f_{b,j}=f_{i,j}]
$$

其实只需要统计：

$$
ans_{i,j} = \sum [f_{i,a}+g_{a,b}=f_{i,b}][f_{i,b}+f_{b,j}=f_{i,j}]
$$

我们可以 $O(n^3)$ 预处理 $\sum [f_{i,a}+g_{a,b}=f_{i,b}]$ 的答案，再 $O(n^3)$ 统计答案即可。

复杂度 $O(n^3)$。

代码：

```c++
#include<cstdio>
#include<cstring>
#define ll long long
ll n, m;

ll f[510][510];
ll c[510][510];
ll g[510][510];
ll z[510];




ll ans[510];

int main() {
	scanf("%lld %lld", &n, &m); 
	
	
	for(ll i = 1; i <= n; i++) {
		for(ll j = 1; j <= n; j++) if(i != j) {
			f[i][j] = 1e9;
		}
	}
	
	for(ll i = 1; i <= m; i++) {
		ll u, v, l;
		scanf("%lld %lld %lld", &u, &v, &l);
		f[u][v] = l;
		f[v][u] = l;
		g[v][u] = l;
		g[u][v] = l;
	}
	
	for(ll k = 1; k <= n; k++) {
		for(ll i = 1; i <= n; i++) {
			for(ll j = 1; j <= n; j++) {
				if(i == j || j == k || i == k) continue;
				if(f[i][j] > f[i][k] + f[k][j]) {
					f[i][j] = f[i][k] + f[k][j];
				}
			}
		}
	}
	
	for(ll i = 1; i <= n; i++) {
		
		memset(z, 0, sizeof(z));
		
		
		for(ll j = 1; j <= n; j++) {
			if(i == j || f[i][j] >= 1e9) continue;
			
			
			for(ll k = 1; k <= n; k++) {
				if(!g[k][j]) continue;
				
				if(f[i][k] + g[k][j] == f[i][j]) {
					z[j]++;
				}
			}
		}
		
		for(ll j = i + 1; j <= n; j++) {
			ll ans = 0;
			for(ll k = 1; k <= n; k++) {
				if(f[i][k] + f[k][j] == f[i][j]) {
					ans += z[k];
				}
			}
			printf("%lld ", ans);
		}
	}
}
```

---


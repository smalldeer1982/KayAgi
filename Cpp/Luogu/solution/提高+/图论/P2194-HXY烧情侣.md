# HXY烧情侣

## 题目描述

众所周知，HXY 已经加入了 FFF 团。现在她要开始喜（sang）闻（xin）乐（bing）见（kuang）地烧情侣了。

这里有 $n$ 座电影院，$n$ 对情侣分别在每座电影院里，然后电影院里都有汽油，但是要使用它需要一定的费用。$m$ 条单向通道连接相邻的两对情侣所在电影院。

HXY 有个绝技，如果她能从一个点开始烧，最后回到这个点，那么烧这条回路上的情侣的费用只需要该点的汽油费即可。并且每对情侣只需烧一遍，电影院可以重复去。然后她想花尽可能少的费用烧掉所有的情侣。

问：最少需要多少费用，并且当费用最少时的方案数是多少？由于方案数可能过大，所以请输出方案数对 $10^9+7$ 取模的结果。

（注：这里 HXY 每次可以从任何一个点开始走回路。就是说一个回路走完了，下一个开始位置可以任选。所以说不存在烧不了所有情侣的情况，即使图不连通，HXY 自行选择顶点进行烧情侣行动。且走过的道路可以重复走。）

## 说明/提示

对于 $30\%$ 的数据，$1\le n,m \le 20$；  
对于另外 $10\%$ 的数据，保证不存在回路；  
对于 $100\%$ 的数据，$1\le n \le 10^5$，$1\le m \le 3\times 10^5$，$0\le w_i \le 10^9$。

## 样例 #1

### 输入

```
3
1 2 3
3
1 2
2 3
3 2```

### 输出

```
3 1
```

## 样例 #2

### 输入

```
3
10 20 10
4
1 2
1 3
3 1
2 1
```

### 输出

```
10 2
```

# 题解

## 作者：扬皓2006 (赞：48)

其实我本人是反对烧情侣的

因为我喜欢一个特勇的女孩纸,但是总是泡不到（OIer共性）

好了，进入正题

此题为Tarjan

我就说一下方案数怎么算

就是乘法原理：各个强连通分量中最小花费点的个数相乘

上代码:
```
#include<bits/stdc++.h>//万能头
#define maxn 100001
#define maxm 300005
using namespace std;
struct Edge{
	int nex,to;
}edge[maxm];
int low[maxn],dfn[maxn],k[maxm],c[maxm],du[maxm],hea[maxm],stac[maxn],ins[maxn],a[maxn];
int top,tot,n,m,num,cnt;
long long ans1,ans2=1,mo=1e9+7;//ans1,ans2一定要longlong不然可能会炸
vector<int>scc[maxm];
void add(int x,int y)
{
	edge[++tot].nex=hea[x];
	edge[tot].to=y;
	hea[x]=tot; 
}//存下一条<x.y>的弧
void tarjan(int x)//Tarjan1经典模板
{
	dfn[x]=low[x]=++num;
	stac[++top]=x;ins[x]=1;
	for(int i=hea[x];i;i=edge[i].nex)
	{
		int y=edge[i].to;
		if(!dfn[y])
		{
			tarjan(y);
			low[x]=min(low[x],low[y]);
		}
		else if(ins[y])
		{
			low[x]=min(low[x],dfn[y]);
		}
	}
	if(low[x]==dfn[x])
	{
		int z;cnt++;
		do{
			z=stac[top--];ins[z]=0;c[z]=cnt;k[cnt]++;scc[cnt].push_back(z);
		}while(x!=z);
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
	}
	scanf("%d",&m);
	for(int i=1;i<=m;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		add(x,y);//存边
	}
	for(int i=1;i<=n;i++)
	{
		if(!dfn[i])  tarjan(i);//如果未被搜索就Tarjan
	}
	for(int i=1;i<=cnt;i++)
	{
		int coun=1,x=0x3fffffff;
		int len=scc[i].size();
		for(int j=0;j<len;j++)
		{
			if(a[scc[i][j]]==x) coun++;//如果一样就++
		    if(a[scc[i][j]]<x)
		    {
			    x=a[scc[i][j]];
			    coun=1;
		    }//如果小于就重置
		}
		ans1+=x;
		ans2*=coun;
		ans2%=mo;
	}
	cout<<ans1<<" "<<ans2;
	return 0;
}
```
最后，祝各位OIer都能A过此题（不抄题解），也祝你们能够追到自己心仪的妹子！

管理大大给个通过呗

---

## 作者：三好代表 (赞：10)

### 残忍的题面

我们来看这一道题，其实冗长的题目告诉我们一个核心——**用tarjan**

**tarjan是用来干什么呢？**是用来求强连通分量（代码中指sc）

**求出来又有什么用呢？**每当我们求出一个强连通分量时，就去计算当前强连通分量中各点最小值是多少以及其个数，然后分别开两个计数器，假设ans1是用来存个数相乘，ans2是用来累加最小值的。

临门一脚，千万别忘了取%   另外注意如果小伙伴这样和我一样写tarjan的话

```cpp
for(int i=head[x];i!=-1;i=e[i].next)
```
一定记住，在main函数里要

```cpp
memset(head,-1,sizeof(head));
```

否则他会输不进去，也跑不出来！（血的教训）

~~（看本蒟蒻的代码，大神勿喷）~~

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod = 1e9+7;
#define ll long long
#define inf 1e9
const int N = 310000;
const int M = 210000;
int head[M],v[M],dfn[M],low[M],q[M];
int be[M],sum[M],hh[M],num[M];
int ss,n,m,now,cnt,tot,sc;
ll ans1=1,ans2;
bool f[N];
struct Edge{
	int to,next;
}e[N];
void add(int x,int y)
{
	e[++ss].to=y;
	e[ss].next=head[x];
	head[x]=ss;
}
void dfs(int x)//这里的dfs和下面tarjan分着写的，不管怎样都是tarjan模板
{
	low[x]=dfn[x]=++cnt;
	q[++tot]=x;
	f[x]=1;
	for(int i=head[x];i!=-1;i=e[i].next)
	{
		if(!dfn[e[i].to])
		{
			dfs(e[i].to);
			low[x]=min(low[x],low[e[i].to]);
		}
		else
		if(f[e[i].to])
		low[x]=min(low[x],dfn[e[i].to]);
	}
	if(low[x]==dfn[x])
	{
		sc++;
		be[x]=sc;
		hh[sc]=inf;
		do
		{
			now=q[tot--];
			f[now]=0;
			be[now]=sc;
			if(v[now]<hh[sc])
			{
				hh[sc]=v[now];
				num[sc]=0;
			}
			if(v[now]==hh[sc]) num[sc]++;
		}
		while(now!=x);
	}
}
void tarjan()
{
	for(int i=1;i<=n;i++)
		if(!dfn[i]) dfs(i);
}
int main()
{
	memset(head,-1,sizeof(head));
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>v[i];
	cin>>m;
	for(int i=1;i<=m;i++)
	{
		int x,y;
		cin>>x>>y;
		add(x,y);
	}
	tarjan();
	for(int i=1;i<=sc;i++)//最后的处理，ans1别忘初值为1
	{
		ans1*=num[i];
		ans2+=hh[i];
		ans1%=mod;
	}
	cout<<ans2<<" "<<ans1;
	return 0;
}
```

---

## 作者：清风我已逝 (赞：8)

tarjan水题


tarjan缩点，记录联通块情况，模拟一下即可

。。。

详细一点就是

vector数组记录每个联通块里的每一个点

最小汽油费即为每个联通块里最小点权

方案数即为每个联通块里最小点权的点数之积（乘法原理）%1e9+7

```cpp
#include<bits/stdc++.h>

#define N 501010
using namespace std;

int n,head[N],tot,w[N],m,ans1,ans2;
struct node {
    int to,next;
} e[N];
void add(int u,int v) {
    e[++tot].to=v,e[tot].next=head[u],head[u]=tot;
}

const int mod=1e9+7;

int dfn[N],low[N],item,belong[N],all[N],cnt;
bool vis[N];
stack<int>S;
vector<int>G[N];
void tarjan(int u){
	dfn[u]=low[u]=++item;
	S.push(u);vis[u]=1; 
	for(int i=head[u];i;i=e[i].next){
		int v=e[i].to;
		if(!dfn[v]){
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}else if(vis[v]) low[u]=min(low[u],dfn[v]); 
	}
	if(low[u]==dfn[u]){
		int v=u;++cnt;
		do{
			v=S.top();S.pop();
			vis[v]=0;belong[v]=cnt;all[cnt]++;
			G[cnt].push_back(v);
		}while(v!=u);
	}
}

int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&w[i]);
	scanf("%d",&m);
	for(int a,b,i=1;i<=m;i++) {
		scanf("%d%d",&a,&b);
		add(a,b);
	}
	for(int i=1;i<=n;i++)
		if(!dfn[i]) tarjan(i);
	ans2=1;
	for(int i=1;i<=cnt;i++){
		int tpt=G[i].size(),tkt=0,minn=mod;
		for(int j=0;j<tpt;j++){
			if(w[G[i][j]]<minn){
				minn=w[G[i][j]];
				tkt=1;
			}else if(minn==w[G[i][j]]) ++tkt;
		}
		ans1+=minn;
		ans2=(ans2%mod*tkt%mod)%mod;
	}
	printf("%d %d",ans1,ans2);
	return 0;
}
```

---

## 作者：liuyanxi2 (赞：4)

~~看到题面时我这个单身狗的第一反应竟然是好~~

这道题很明显，是道强连通（要烧到出发点）所以肯定用tarjan，所以第一小问就很简单了，就是一个模板强连通。

第二小问也很水，只需要统计每个强连通内最小花费的汽油桶有多少个，再将各个权值相乘即可（乘法原理）~~不要忘了取模哦（血的教训）~~

另外，题干虽然说没有0，但是好像有，所以不能这样打：

```
if(s1[ma[a]]==s[a])	  
s2[ma[a]]++,s2[ma[a]]=s2[ma[a]]%1000000007;
if(s1[ma[a]]>s[a])
s2[ma[a]]=1,s1[ma[a]]=s[a];
```

好了，下面是正确代码，码风有点奇特，大佬勿喷

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstring>
#include<cmath>
#include<stack>
using namespace std;
long long ans1,a,b,c,d,e,f,g,m,n,z,x,k1[500001],k2[500001],l,o,opt,head[500001],cnt,ans,ans2,dfn[500001],low[500001],mjc,vis[500001],ma[500001],in[500001],out[500001],s[100001],s1[100001],s2[100001];
stack <int >p;
void ab(int q,int w)
{
    cnt++;
    k1[cnt]=head[q];
    k2[cnt]=w;
    head[q]=cnt;
}

void tarjin(int q)
{
    int w;
    dfn[q]=low[q]=++mjc;
    p.push(q);
    vis[q]=1;
    for(int i=head[q];i!=0;i=k1[i])
    {
        w=k2[i];
        if(dfn[w]==0)
        {
            tarjin(w);
            low[q]=min(low[q],low[w]);
        }
        else
        if(vis[w])
        low[q]=min(low[q],dfn[w]);
    }
    if(low[q]==dfn[q])
    {
		ans++;
        while(q!=w)
        {
            w=p.top();
            p.pop();
            vis[w]=0;
            ma[w]=ans;
        }
    }
}
int main ( )
{
    cin>>n;
    for(int i=1;i<=n;i++)
    scanf("%d",&s[i]);
    cin>>m;
    for(int i=1;i<=m;i++)
	{
		scanf("%d%d",&b,&c);
		if(b!=c)
		ab(b,c);
	}
    for(int i=1;i<=n;i++)
    if(!dfn[i])
    tarjin(i);
    for(a=1;a<=ans;a++)
	s1[a]=999999999; 
  	for(a=1;a<=n;a++)
  	{
  		{
  			if(s1[ma[a]]==s[a])
  			s2[ma[a]]++,s2[ma[a]]=s2[ma[a]]%1000000007;
  			if(s1[ma[a]]>s[a])
  			s2[ma[a]]=1,s1[ma[a]]=s[a];
  		}
  	}
  	ans1=0;ans2=1;
  	for(a=1;a<=ans;a++)
  	{
  		ans1+=s1[a];
  		ans2*=s2[a]%1000000007;
  	}
  	if(ans1!=0)
	cout<<ans1<<' '<<ans2%1000000007;
    return 0 ;
}
```

~~点赞哦~~

---

## 作者：封禁用户 (赞：4)

这题是一道[强联通分量](https://baike.baidu.com/item/强连通分量/7448759?fr=aladdin)的~~水~~题,我用[$tarjan$](https://blog.csdn.net/weixin_43843835/article/details/88381828)做的。

第一问的最小花费其实就是求每个强连通分量里的最小点权值,然后再把它们相加。

具体实现:

```cpp
for(int i=1;i<=cnt;i++) ans1=ans1+minn[i];
```

$cnt$为有多少个强联通分量,$minn_i$是每个强连通分量里的最小点权值。

第二问其实也不难,可以用乘法原理做,在跑$tarjan$的时候加一个判断就行了:如果一个强连通分量中有两个最小点权值相等,那么$sum_i$(记录每个强连通分量里面有多少个最小点权值)就加$1$。这里有一点要注意:如果最小点权值更新了,那么$sum_i$也要随之更新。

具体实现:

```cpp
ans2=1;
for(int i=1;i<=cnt;i++) ans2=(ans2*sum[i])%1000000007;
```

完整代码:

```cpp
#include<bits/stdc++.h>
//#define chenkeqi return
//#define AK 0
//#define PJz ;
using namespace std;
struct edge
{
	long long v,next;
}
e[600005];
long long a[100005],head[600005];
long long low[300005],ins[300005];
long long belong[300005],dfn[300005];
long long cnt,k,tot,n,m,ans1,ans2;
long long minn[300005],sum[300005];
stack<int>s;
void adde(long long u,long long v)
{
	e[++k].v=v;
	e[k].next=head[u];
	head[u]=k;
}
//前向星存图
void tarjan(int u)
{
	dfn[u]=low[u]=++tot;
	s.push(u);
	ins[u]=1;
	for(int i=head[u];i!=-1;i=e[i].next)
	{
		int v=e[i].v;
		if(!dfn[v])
		{
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}
		else if(ins[v])
			low[u]=min(low[u],dfn[v]);
	}
	if(dfn[u]==low[u])
	{
		int kl;
		cnt++;
		do
		{
			kl=s.top();
			s.pop();
			belong[kl]=cnt;//belong好像没啥用
			ins[kl]=0;
			if(minn[cnt]==a[kl])//如果最小值有相同
				sum[cnt]++;//此强连通分量中多一种方案
			if(a[kl]<minn[cnt])//如果有更小值
			{
				minn[cnt]=a[kl];//更新最小值
				sum[cnt]=1;//此强连通分量中方案归1
			}
		}while(u!=kl);
	}
}
//tarjan模板代码
int main()
{
	memset(head,-1,sizeof(head));
	memset(minn,127,sizeof(minn));//注意minn和head的初始化
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	cin>>m;
	for(int i=1;i<=m;i++)
	{
		int a,b;
		cin>>a>>b;
		adde(a,b);//加边
	}
	for(int i=1;i<=n;i++)
	{
		if(!dfn[i])
			tarjan(i);
	}
	for(int i=1;i<=cnt;i++)
		ans1=ans1+minn[i];
	ans2=1;
	for(int i=1;i<=cnt;i++)
		ans2=(ans2*sum[i])%1000000007;
   	//对两个问的操作,前面已经讲过
	cout<<ans1<<" "<<ans2;
	//chenkeqi AK PJz
	return 0;
}
```

---

## 作者：lzpclxf (赞：3)

[题目](https://www.luogu.org/problem/P2194)

说实话，这题我第一遍没做出来，去看了题解，然而看了题解的我眼泪掉下来，怎么大家最后弹栈的过程全都是$do \ while$啊,~~废话，那个好写~~，但是本人比较喜欢$while$，所以就来写一写惹

##### 1.这题要建立的是单向边

大家仔细分析样例这是很容易就可以发现的

##### 2.多种方案情况
一开始，我以为多种方案就是多少种走法~~你到底看没看题目啊~~然后我们可完美的过掉2个样例并且拿到$0$分的好成绩，然后我们会发现，多种方案数其实就是在一个环内，有多个点的点权相等，此时不论从哪个点走他们的答案都是一样的。
##### 3.tarjan弹栈
虽然$do \ while$码量比较少，但是我就是喜欢$while$，所以我就写的$while$一开始我的代码不对，还以为是这里的问题，想找篇题解康康人家怎么写的，结果没找到$qwq$
##### 4.统计答案
据说这题不取模也能过。其实我们完全不必要又开数组最后又来循环统计答案之类的,直接开单个变量维护就好了。方案数统计是乘法原理。

这里再对上边提的$4$点再结合代码讲一下
```cpp

	if(dfn[u] == low[u]) {
		geshu = 0, 	minn = 0x3f3f3f3f;
		while(stac[top] != u) {
			vis[stac[top]] = 0;
			if(w[stac[top]] < minn) minn = w[stac[top]], geshu = 0;
			if(w[stac[top--]] == minn) geshu++;
		}
		top--, vis[u] = 0;
		if(w[u] < minn) minn = w[u], geshu = 1;
		else if(w[u] == minn) geshu++;
		ans += minn;
		sum = (sum * geshu) % md;
	}
```

我们$while$循环的条件是栈顶不等于当前的节点，所以到了当前的节点$u$的时候就会停下，而$u$又是这个环里的元素，所以我们最后再对$u$判断一下即可，$while$里的最后两行，是更新最小值并记录最小值的数量的，倒数第二行把他变成零，最后一个行又会把它变成$1$了，所以不用担心没有更新的情况，如果我们直接把他变成$1$那样最后一行按理说是应该写$else \ if$但是我们已经更新了，如果$geshu$加了，那只能说明这个点的点权和上一次更新之前的一样，这样写就会使我们的$sum$最后变大

The Last;
```cpp
#include <cstdio>
#include <iostream>
using namespace std;
const int N = 1e6+7;
const int md = 1e9+7;
int n, head[N << 1], cnt,  w[N], m, dfn[N], low[N], tot, top, stac[N], ans, minn, sum = 1, geshu;
bool vis[N];
struct node {
	int nxt, to;
}e[N << 1];
int read() {
	int s = 0, w = 1;
	char ch = getchar();
	while(!isdigit(ch)) {if(ch == '-') w = -1; ch = getchar();}
	while(isdigit(ch)) {s = s * 10 + ch - '0'; ch = getchar();}
	return s * w;
}
void add(int x, int y) {
	e[++cnt].nxt = head[x];
	e[cnt].to = y;
	head[x] = cnt;
}
void tarjan(int u) {
	dfn[u] = low[u] = ++tot, stac[++top] = u, vis[u] = 1;
	for(int i = head[u]; i; i = e[i].nxt) {
		int v = e[i].to;
		if(!dfn[v]) tarjan(v), low[u] = min(low[u], low[v]);
		else if(vis[v]) low[u] = min(low[u], dfn[v]); 
	}
	if(dfn[u] == low[u]) {
		geshu = 0, 	minn = 0x3f3f3f3f;
		while(stac[top] != u) {
			vis[stac[top]] = 0;
			if(w[stac[top]] < minn) minn = w[stac[top]], geshu = 0;
			if(w[stac[top--]] == minn) geshu++;
		}
		top--, vis[u] = 0;
		if(w[u] < minn) minn = w[u], geshu = 1;
		else if(w[u] == minn) geshu++;
		ans += minn;
		sum = (sum * geshu) % md;
	}
} 
int main() {
	n = read();
	for(int i = 1; i <= n; i++) w[i] = read();
	m = read();
	for(int i = 1, x, y; i <= m; i++) {
		x = read(), y = read();
		add(x, y);
	}
	for(int i = 1; i <= n; i++) 
		if(!dfn[i]) tarjan(i);
	printf("%d %d\n", ans, sum);
	return 0;
}
```
谢谢收看，祝身体健康！

---

## 作者：Social_Zhao (赞：3)

遇到这种~~鬼迷日眼~~的题目要学会翻译成现代汉语。

> 众所周知，HXY已经加入了FFF团。现在她要开始喜（sang）闻（xin）乐（bing）见（kuang）地烧情侣了。这里有n座电影院，n对情侣分别在每座电影院里，然后电影院里都有汽油，但是要使用它需要一定的费用。m条单向通道连接相邻的两对情侣所在电影院。然后HXY有个绝技，如果她能从一个点开始烧，最后回到这个点，那么**烧这条回路上的情侣的费用只需要该点的汽油费即可**。并且**每对情侣只需烧一遍，电影院可以重复去**。然后她想**花尽可能少的费用烧掉所有的情侣**。问最少需要多少费用，并且当**费用最少时的方案数**是多少？由于方案数可能过大，所以请输出方案数对1e9+7取模的结果。
>
> （注：这里HXY每次可以从任何一个点开始走回路。就是说一个回路走完了，下一个开始位置可以任选。所以说不存在烧不了所有情侣的情况，即使图不连通，HXY自行选择顶点进行烧情侣行动。且走过的道路可以重复走。）

扯了这么多，其实就是想表达一个意思：求所有$SCC$中的**最小点权和**以及**能达到这个最小点权和的方案数**。

$SCC$中的最小点权和求法这里就无需赘述了。比较难的是这个方案数。

我们不难从样例#2中发现，可能一个$SCC$中最小点权有多个。我们不妨大胆地做出猜想：根据乘法原理，如果我们把所有$SCC$中最小点权的数量乘起来，是不是就是方案数了呢？**这是没问题的**。

所以说本题的两个答案：

$minn[i]$表示第$i$个$SCC$的最小点权，$num[i]$表示第$i$个$SCC$中最小点权的数量，$cnt$表示$SCC$的数量则：

第一个答案$ans1 = \sum\limits_{i = 1}^{cnt}{minn[i]}$。

第二个答案$ans2 = \prod\limits_{i = 1}^{cnt}{num[i]}$

这就完了。

```cpp
#include<iostream>
#include<cstdio>
#include<stack>
#include<cstring>
using namespace std;

const int MaxN = 1e5 + 5;
const int MaxM = 3e5 + 5;
const int Mod = 1e9 + 7;
int n, m;
struct Edge 
{
	int v, nxt;
} edge[MaxM];
int head[MaxN], k = 1;
int ins[MaxN], low[MaxN], dfn[MaxN], col[MaxN], cnt = 0, minn[MaxN], num[MaxN], tim;
int val[MaxN];
stack<int> st;

int get() //读优不解释
{
	int x = 0, f = 1; char c = getchar();
	while(!isdigit(c)) { if(c == '-') f = -1; c = getchar(); }
	while(isdigit(c)) { x = x * 10 + c - '0'; c = getchar(); }
	return x * f;
}

void addedge(int u, int v) //建边不解释
{
	edge[k].v = v;
	edge[k].nxt = head[u];
	head[u] = k++;
}

void init() //读入数据
{
	memset(minn, 0x3f, sizeof(minn)); 
	n = get();
	for(int i = 1; i <= n; i++) val[i] = get();
	m = get();
	for(int i = 1; i <= m; i++) addedge(get(), get());
}

void Tarjan(int u) //Tarjan求SCC
{
	dfn[u] = low[u] = ++tim;
	ins[u] = 1;
	st.push(u);
	for(int i = head[u]; i; i = edge[i].nxt)
	{
		int v = edge[i].v;
		if(!dfn[v]) Tarjan(v), low[u] = min(low[u], low[v]);
		else if(ins[v]) low[u] = min(low[u], dfn[v]);
	}
	if(low[u] == dfn[u])
	{
		int l;
		cnt++;
		do
		{
			l = st.top(); st.pop();
			ins[l] = 0;
			col[l] = cnt;
			if(val[l] < minn[cnt]) //如果出现一个更便宜的，说明之前统计的都白统计了，要清零
			{
				minn[cnt] = val[l];
				num[cnt] = 1;
			}
			else if(val[l] == minn[cnt]) num[cnt]++; //如果相等，说明这个值也可能是最小点权。
		} while(l != u);
	}
}

void Calc_SCC()
{
	for(int i = 1; i <= n; i++) if(!dfn[i]) Tarjan(i); //图可能不连通，所以要枚举树根
}

void solve()
{
	Calc_SCC();
	int sum = 0, ans = 1; //和的初值为0，积的初值为1
	/*
	printf("cnt=%d\n", cnt);
	for(int i = 0; i <= n; i++)
	{
		printf("%d %d %d\n", col[i], num[col[i]], minn[col[i]]);
	}
	*/
	for(int i = 1; i <= cnt; i++)
	{
		sum += minn[i]; //累加和
		ans *= num[i]; //累乘积
		ans %= Mod; //不要忘了取模
	}
	printf("%d %d", sum, ans);
}

int main()
{
	init();
	solve();
}
```

另外，这题的数据貌似有点问题啊？

我一个过不了样例一的程序（时间戳``++tim``写成``tim++``）交上去有90pts？望加强。

---

## 作者：封禁用户 (赞：3)

## 题外话
看了看都是Tarjan的算法，这里来个Kosaraju的。
## Ad
个人博客高清重制版同步：http://www.cinema000.xyz/1544.ruby
## 分析

其实这里第一问就是求每个SCC的最小权值的和，和与这个最小权值相等的方案数。

然后我们就在求SCC的过程中维护最小值，而方案数可以用分步计数原理求解。

## 代码

Kosaraju：

```cpp
#include<cstdio>
#include<vector>
#include<algorithm>
const int MAXN = 100000 + 6;
const int INF = 0x7fffffff;
int A[MAXN],ans[MAXN],ans2[MAXN];
struct Edge{int v,d;Edge(int v,int d){this -> v = v;this -> d = d;}Edge(){}};
class SCC{
public:
	std::vector<Edge> G[MAXN],G2[MAXN];
	std::vector<int> S;
	int SCCNo[MAXN],SCCCnt;
	bool hash[MAXN];
	void addEdge(int u,int v,int d){
		G[u].push_back(Edge(v,d));
		G2[v].push_back(Edge(u,d));
	}
	void dfs1(int u){
		if(hash[u]) return;
		hash[u] = true;
		for(int i = 0;i < G[u].size();i++) dfs1(G[u][i].v);
		S.push_back(u);
	}
	void dfs2(int u){
		if(SCCNo[u]) return;
		SCCNo[u] = SCCCnt;
		ans[SCCNo[u]] = std::min(ans[SCCNo[u]],A[u]);
		for(int i = 0;i < G2[u].size();i++) dfs2(G2[u][i].v);
	}
	void findSCC(int n){
		SCCCnt = 0;
		for(int i = 1;i <= n;i++) dfs1(i);
		for(int i = n - 1;i >= 0;i--) if(!SCCNo[S[i]]){SCCCnt++;dfs2(S[i]);}
	}
};

int main(){
	SCC s;
	std::fill(ans,ans + MAXN,INF);
	int n;scanf("%d",&n);
	for(int i = 1;i <= n;i++) scanf("%d",&A[i]);
	int m,u,v;scanf("%d",&m);
	while(m--){
		scanf("%d %d",&u,&v);
		s.addEdge(u,v,666);
	}
	s.findSCC(n);
	long long cnt1 = 0,cnt2 = 1;
	for(int i = 1;i <= s.SCCCnt;i++) cnt1 += ans[i];
	for(int i = 1;i <= n;i++) if(A[i] == ans[s.SCCNo[i]]) ans2[s.SCCNo[i]]++;
	for(int i = 1;i <= s.SCCCnt;i++) cnt2 *= ans2[i] % (long long)(1e9 + 7);
	
	printf("%lld %lld",cnt1,cnt2);
	
	return 0;
}
```



---

## 作者：caozy623 (赞：2)

这题其实就是道求强连通分量的模板题……我是用tarjan写的。求强连通分量（SCC）的过程不再赘述，可自行寻找网上论文进行学习tarjan求强连通分量算法。然后就不难了，求SCC的时候每找到一个，就计算当前SCC中的各点的最小值及其个数，用乘法原理把个数相乘作为ans1，累加最小值作为ans2。

然后按要求输出即可……


  
```cpp
#include<iostream>  
#include<cstring>  
#include<cstdio>  
#include<algorithm>  
#include<vector>  
#include<string>  
#include<set>  
#include<queue>  
#include<stack>  
#include<map>  
#include<cmath>  
#include<cstdlib>  
#define ll long long  
#define maxn 100010  
#define maxm 300010  
#define hzy 1000000007  
#define inf 1000000000  
using namespace std;  
inline ll read()  
{  
    ll x=0,f=1;char ch=getchar();  
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}  
    while(ch>='0'&&ch<='9'){x*=10;x+=ch-'0';ch=getchar();}  
    return x*f;  
}  
inline void read(char *s,int &ts)  
{  
    char x=getchar();  
    while(!(x>='a'&&x<='z'))x=getchar();  
    while(x>='a'&&x<='z')s[++ts]=x,x=getchar();  
}  
using namespace std;  
struct data{int to,next;}e[maxm];  
int head[maxn];  
int n,m,now,cnt,top;  
int v[maxn],dfn[maxn],low[maxn],q[maxn];  
int scc,mn[maxn],belong[maxn],num[maxn];  
bool inq[maxn];  
ll ans1=1,ans2;  
void dfs(int a)  
{  
    inq[a]=1;  
    low[a]=dfn[a]=++cnt;  
    q[++top]=a;  
    int c=head[a];  
    while(c)  
    {  
        if(!dfn[e[c].to])  
        {  
            dfs(e[c].to);  
            low[a]=min(low[a],low[e[c].to]);  
        }  
        else if(inq[e[c].to])low[a]=min(low[a],dfn[e[c].to]);  
        c=e[c].next;  
    }  
    if(low[a]==dfn[a])  
    {  
        scc++;  
        belong[a]=scc;  
        mn[scc]=inf;  
        do  
        {  
            now=q[top--];  
            inq[now]=0;  
            belong[now]=scc;  
            if(v[now]<mn[scc]){mn[scc]=v[now];num[scc]=0;}  
            if(v[now]==mn[scc])num[scc]++;  
        }  
        while(now!=a);  
    }  
}  
void tarjan()  
{  
    for(int i=1;i<=n;i++)  
        if(!dfn[i])dfs(i);  
}  
int main()  
{  
    scanf("%d",&n);  
    for(int i=1;i<=n;i++)  
        scanf("%d",&v[i]);  
    scanf("%d",&m);  
    for(int i=1;i<=m;i++)  
    {  
        int x,y;  
        scanf("%d%d",&x,&y);  
        e[i].to=y;  
        e[i].next=head[x];  
        head[x]=i;  
    }  
    tarjan();  
    for(int i=1;i<=scc;i++)  
    {  
       ans1*=num[i];ans2+=mn[i];  
       ans1%=hzy;  
    }  
    printf("%I64d %I64d\n",ans2,ans1);  
    return 0;  
}
```

---

## 作者：陈新月 (赞：2)

思路：

这题，也算一个tarjan的裸题吧，题目的意思就是求在一个强连通分量里的点最小值与和这个最小值相等的点有几个，为什么呢？

第一问是求烧完全部情侣需要的最小汽油费用，其实就是求每一个强连通分量里的最小值，然后累加就可以了，第二问是求方案数，也比较显然地，我们只需要求每一个强连通分量里的和最小值相等的点有几个，然后累乘就行了。


代码如下，部分重要细节已注释











    




```cpp
#include<cstdio>
#include<stack>
#include<algorithm>
#define N 100009
#define M 300009
using namespace std;
#ifdef WIN32                    //条件编译，NOIP党黑科技，可以不用再担心long long的影响 
#define LL "%I64d %I64d\n"
#else
#define LL "%lld %lld\n"
#endif
const long long MOD = 1000000007;
int en,n,m;
int t,cnt,low[N],dfn[N];
bool instack[N];
stack<int> sta;
long long ans1,ans2 = 1;
int node[N];
struct edge{
    int e;
    edge *next;
}*v[N],ed[M];
void add_edge(int s,int e){                       //前向星存边 
    en++;
    ed[en].next = v[s],v[s] = ed+en,v[s]->e =e;
}
void dfs(int now){
    t++;
    low[now] = dfn[now] = t;
    instack[now] = true;
    sta.push(now);
    for(edge *e = v[now];e;e=e->next)
      if(!dfn[e->e]){
           dfs(e->e);
           low[now] = min(low[now],low[e->e]);
      }
      else if(instack[e->e])low[now] = min(low[now],dfn[e->e]);
    if(low[now] == dfn[now]){
        cnt++;
        int minz = 19999999,cc = 0;
        while(sta.top() != now){
            instack[sta.top()] = false;
            if(node[sta.top()] < minz){
                cc = 1;
                minz = node[sta.top()];
            }
            else if(minz == node[sta.top()])cc++;
            sta.pop();
        } 
        sta.pop();
        instack[now] = false;
        if(node[now] == minz)cc++;
        else if(node[now] < minz){
            cc = 1;
            minz = node[now];
        }
        ans1 += minz;                        //累加每个强连通分量的最小值 
        ans2 = (ans2*cc)%MOD;                //累乘每个强连通分量里和最小值相等的点的个数并取模 
    }
}
void tarjan(){                               //Tarjan 
    for(int a = 1; a<= n; a++)
      if(!dfn[a])dfs(a);
}
int main(){
    scanf("%d",&n);
    for(int i = 1; i <= n; i++)scanf("%d",&node[i]);
    scanf("%d",&m);
    for(int i = 1; i <= m; i++){
        int u,v;
        scanf("%d%d",&u,&v);
        add_edge(u,v);
    }
    tarjan();
    printf(LL,ans1,ans2);            //输出 
    return 0;
}

```

---

## 作者：Doubeecat (赞：1)

## 题目链接：

[P2194 HXY烧情侣](<https://www.luogu.org/problem/P2194>)

## 题目描述：

众所周知，HXY已经加入了FFF团。现在她要开始喜（sang）闻（xin）乐（bing）见（kuang）地烧情侣了。这里有n座电影院，n对情侣分别在每座电影院里，然后电影院里都有汽油，但是要使用它需要一定的费用。m条单向通道连接相邻的两对情侣所在电影院。然后HXY有个绝技，如果她能从一个点开始烧，最后回到这个点，那么烧这条回路上的情侣的费用只需要该点的汽油费即可。并且每对情侣只需烧一遍，电影院可以重复去。然后她想花尽可能少的费用烧掉所有的情侣。问最少需要多少费用，并且当费用最少时的方案数是多少？由于方案数可能过大，所以请输出方案数对1e9+7取模的结果。

（注：这里HXY每次可以从任何一个点开始走回路。就是说一个回路走完了，下一个开始位置可以任选。所以说不存在烧不了所有情侣的情况，即使图不连通，HXY自行选择顶点进行烧情侣行动。且走过的道路可以重复走。）

## 解题思路：

题目中写的很清楚，这题直接套一个 Tarjan 就完了

现在讨论一下两个问题：

1. 最少需要多少费用

   这个比较好想，只要将缩点后的每个 SCC 权值变成其中点权最小的即可

2. 总共有多少方案

   这个比较难想，但是我们可以结合一下乘法原理的思想，将每个 SCC 中的点权等于 SCC 的点权的个数相乘

可能有点绕口，我们用形式化的语言来描述一下

记 $siz_i$  为 $SCC_i$ 中点权最小的权值， $num_i$ 为 $SCC_i$ 中点权等于最小点权的权值的点，$cnt$ 为 SCC 数量

则有

$$ans_1 = \sum^{cnt}_{i=1}siz[i]$$

$$ans_2 = \prod^{cnt}_{i=1}num_i$$

便可写出代码

## 代码：

```cpp
#include <cstring>
#include <cstdio>
#include <cctype>
#include <cmath>
#include <stack>
using std::stack;
#define long long ll
#define register int ri

char buf[1<<21],*p1=buf,*p2=buf;
inline int gc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}
inline int read() {
	char v = gc();int x = 0,f = 1;
	while (!isdigit(v)) {if (v == '-')f = -1;v = gc();}
	while (isdigit(v)) {x = x * 10 + v - 48;v = gc();}
	return x * f;
}
const int N = 100001;
const int M = 500001;
const int INF = 0x3f3f3f3f;

int to[M],hd[N],nxt[M],tot;

inline void add(int u,int v) {to[++tot] = v;nxt[tot] = hd[u];hd[u] = tot;}
inline void addedge(int u,int v) {add(u,v),add(v,u);}

template <typename T> inline T min(T x,T y) {return x<y?x:y;}
template <typename T> inline T max(T x,T y) {return x>y?x:y;}

int dfn[N],low[N],c[N],cnt,num,siz[N],p[N],pre[N],ins[N],n,m,ans1,ans2 = 1;
stack <int> s;

void tarjan(int x) {
	dfn[x] = low[x] = ++cnt;
	s.push(x);ins[x] = 1;
	for (int i = hd[x];i;i = nxt[i]) {
		if (!dfn[to[i]]) {
			tarjan(to[i]);
			low[x] = min(low[x],low[to[i]]);
		}
		else if (ins[to[i]]) {
			low[x] = min(low[x],dfn[to[i]]);
		}
	}
	if (dfn[x] == low[x]) {
		int y;c[x] = ++num;
		do {
			y = s.top();c[y] = num;ins[y] = 0;s.pop();
			if (pre[y] < p[num]) {
				p[num] = pre[y];
				siz[num] = 1;
			}
			else if (pre[y] == p[num]) {
				++siz[num];
			}
		}while (x != y);
	}
}

signed main() {
	memset(p,INF,sizeof(p));
	n = read();
	for (int i = 1;i <= n;++i) pre[i] = read();
	m = read();
	for (int i = 1;i <= m;++i) {
		int x = read(),y = read();add(x,y);
	}
	for (int i = 1;i <= n;++i) {
		if (!dfn[i]) tarjan(i);
	}
	for (int i = 1;i <= num;++i) {
		ans1 += p[i];ans2 *= siz[i];
	}
	printf("%d %d",ans1,ans2);
	return 0;
}
```



---

## 作者：Kevin_F (赞：1)

这个题可以说是tarjan强连通分量的裸题，但需要维护每个强连通分量的最小值，所以做法就很明确了。

我们先明确几个数组的意思：

1.首先是tarjan缩点中的几个数组：
   
      dfn[i]:i点的时间戳
  
      low[i]，表示这个点以及其子孙节点连的所有点中dfn最小的值
  
      stack[]，表示当前所有可能能构成是强连通分量的点。
  
      ins[i]，表示 i 是否在stack[ ]数组中
      
      num[i],表示第 i 个强连通分量中有多少个点
      
      belong[i],表示第 i 点在哪一个强连通分量里
      
2.然后是我们用来维护最小值以及最小  值个数的数组

      minn[i]，表示第 i 个强连通分量中点权的最小值
      
      sum[]:表示最小值是 i 的有多少个
      
      
最最最需要注意的两初始化：

1.ans2 需要初始化为 1

2.minn[i]这个数组要初始为正无穷。


```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
using namespace std;
const long long mod = 1e9 + 7;
const int maxn = 1e5 + 5;
const int maxm = 3e5 + 4;

int n,m,a[maxn],x,y;
struct Edge{
	int to,next,val;
}edge[maxm << 1];
int head[maxn],tot;
int dfn[maxn],low[maxn],ind;
int stack[maxn],top,cnt,num[maxn],belong[maxn];
bool ins[maxn];
int ans1,ans2 = 1,minn[maxn],sum[maxn];

void add(int u,int v){
	edge[++tot].to = v;
	edge[tot].next = head[u];
	head[u] = tot;
}

inline int read(){
	char ch = getchar();
	int f = 1 , x = 0;
	while(ch > '9' || ch < '0'){
		if(ch == '-') f = -1;
		ch = getchar();
	}
	while(ch <= '9' && ch >= '0'){
		x = x * 10 + ch - '0';
		ch = getchar();
	}
	return x * f;
}

void print(int x){
	if(x < 0){
		putchar('-');
		x = -x;
	}
	if(x > 9)  print(x / 10);
	putchar(x % 10 + '0');
}

void tarjan(int x){
	dfn[x] = low[x] = ++ind;
	ins[x] = true;
	stack[++top] = x;
	for(int i=head[x];i;i=edge[i].next){
		int v = edge[i].to;
		if(ins[v])  low[x] = min(low[x] , dfn[v]);
		if(!dfn[v]){
			tarjan(v);
			low[x] = min(low[x] , low[v]);
		}
	}
	int k;
	if(dfn[x] == low[x]){
		++cnt;
		do{
			k = stack[top];
			num[cnt]++;
			ins[k] = false;
			minn[cnt] = min(minn[cnt] , a[k]);
			top--;
			belong[k] = cnt;
		}  while(k != x);
	}
}

int main(){
	n = read();
	for(int i=1;i<=n;i++){
		a[i] = read();
	}
	m = read();
	for(int i=1;i<=m;i++){
		x = read();  y = read();
		add(x,y);
	}
	for(int i=1;i<=n;i++)
	   minn[i] = 1e9;
	for(int i=1;i<=n;i++)
	  if(!dfn[i]) tarjan(i);
	for(int i=1;i<=cnt;i++){
		ans1 += minn[i];
	}
	print(ans1);
	cout<<" ";
	for(int i=1;i<=n;i++)
	  if(a[i] == minn[belong[i]])
	    sum[belong[i]]++;
	for(int i=1;i<=cnt;i++)
	  ans2 = ans2 * sum[i] % mod;
	print(ans2);
	return 0;
}
```

---

## 作者：睿屿青衫 (赞：1)

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define ll long long//long long用ll表示 
#define maxn 1000000
#define INF 1e9+7//大数用INF表示 
using namespace std;
ll qr,cnt,cnum,dfn[maxn],low[maxn],vis[maxn],stack[maxn];
ll top,n,m,qq,p[maxn],ans[maxn],ans1,ans2=1,head[maxn];
ll color[maxn],anss[maxn];
struct EDGE
{
    ll next;
    ll to;
}edge[maxn*3];
void add(ll from,ll to)
{
    edge[++qr].next=head[from];
    edge[qr].to=to;
    head[from]=qr;
}
void tarjan(ll x)
{
    dfn[x]=low[x]=++cnt;//更新时间戳，就这个写法 
    vis[x]=1;stack[++top]=x;//入栈操作 
    for(ll i=head[x];i;i=edge[i].next)
```
{//枚举从x开始的边，其实这个函数几乎就是模板
```cpp
         ll v=edge[i].to;
         if(!dfn[v])
          {
              tarjan(v);
              low[x]=min(low[x],low[v]);
          }
         else if(vis[v]) low[x]=min(low[x],dfn[v]);
     }
    if(dfn[x]==low[x])
     {
         cnum++;//对我来说很长时间才弄懂这个玩意：强连通分量数目 
         do
         {
             color[stack[top]]=cnum;//标记强连通分量号（有人称染色） 
             vis[stack[top]]=0;//出栈操作，模板背过 
             ans[cnum]=min(ans[cnum],p[stack[top]]);//更新这个强连通分量最小的费用 
             qq=stack[top--];//出栈 
         }while(qq!=x);
     }
}
int main()
{
    ios::sync_with_stdio(false);
    cin>>n;
    for(ll i=1;i<=n;++i)
     cin>>p[i];
    cin>>m;
    ll z=INF;//最后直接%INF的话编译错误，我也不知道为啥 
    for(int i=1;i<=n;++i)
     ans[i]=INF;//初始化，memset最好别用，有毒！总是会出现一些莫名其妙的数 
    for(ll i=1;i<=m;++i)
     {
         ll x,y;
         cin>>x>>y;
         add(x,y);
     }
    for(ll i=1;i<=n;++i)
     if(!dfn[i]) tarjan(i);//模板 
    for(ll i=1;i<=cnum;++i)
     ans1+=ans[i];//每个强连通分量加上最小值，最后就是第一问答案 
    printf("%lld ",ans1);//输出ll型，int不知道会不会炸 
    for(int i=1;i<=n;++i)
     {    
         if(p[i]==ans[color[i]])
              anss[color[i]]++;//枚举每一个点，如果这个点的费用和所属的强连通分量的最小费用一样，那么这个强连通分量的方案数加一 
     }
    for(int i=1;i<=cnum;++i) ans2*=anss[i];//我一开始错了：做的加法，后来想想每个点都有**种可能，n个点肯定乘法啊 
    printf("%lld",ans2%z);//模 
    return 0;
}
```

---

## 作者：Elma_ (赞：0)

## Description

[题目链接](https://www.luogu.com.cn/problem/P2194)

## Solution

蛮裸的一道$tarjan$题。

考虑每一个强连通分量，统计点权最小的点的权值和点权最小的点的个数。

那么最少的费用就是每个$SCC$里点权最小点的权值之和，根据乘法原理，方案数就是每个$SCC$里点权最小的点的个数之积。

做法不难想，套个$tarjan$这题就做完了。不过要注意两个$ans$要开$long$ $long$，$inf$也要开大，不然会爆炸。

~~别问我怎么知道的会炸就对了~~

## Code
```cpp
#include <cmath>
#include <stack>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define maxn 1000005
#define inf 1e9
#define mod 1000000007
using namespace std;

struct node
{
	int nxt, to;
}edge[maxn << 2];
long long n, m, dfs_block, scc_cnt, tot, ans1, ans2 = 1;
long long siz[maxn], head[maxn], sccno[maxn], low[maxn], dfn[maxn], minn[maxn], sum[maxn], v[maxn];
bool vis[maxn];
stack<int> s;

inline void addedge(int u, int v)
{
	edge[++tot].nxt = head[u];
	edge[tot].to = v;
	head[u] = tot;
}

inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9')f=ch=='-'?-1:f,ch=getchar();
    while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();
    return x*f;
}

void tarjan(int u)
{
	low[u] = dfn[u] = ++dfs_block;
	vis[u] = true;
	s.push(u);
	for (int i = head[u];i;i = edge[i].nxt)
	{
		int v = edge[i].to;
		if (!dfn[v])
		{
			tarjan(v);
			low[u] = min(low[u], low[v]);
		}
		else if (vis[v])
		{
			low[u] = min(low[u], dfn[v]);
		}
	}
	if (dfn[u] == low[u])
	{
		sccno[u] = ++scc_cnt;
		vis[u] = false;
		minn[scc_cnt] = inf;
		for (;;)
		{
			int x = s.top();s.pop();
			sccno[x] = scc_cnt;
			vis[x] = false;
			if (v[x] < minn[scc_cnt])
			{
				minn[scc_cnt] = v[x];
				sum[scc_cnt] = 0;
			}
			if (v[x] == minn[scc_cnt]) sum[scc_cnt]++;
			if (x == u) break;
		}
	}
}

int main(void)
{
	n = read();
	for (int i = 1;i <= n;i++)
		v[i] = read();
	m = read();
	for (int i = 1;i <= m;i++)
	{
		int u = read(), v = read();
		addedge(u, v);
	}
	for (int i = 1;i <= n;i++)
		if (!dfn[i]) tarjan(i);
	for (int i = 1;i <= scc_cnt;i++)
	{
		ans1 += minn[i];
		ans2 *= sum[i];
		ans2 %= mod;
	}
	cout << ans1 << " " << ans2 << endl;
	return 0;
}
```


---

## 作者：PrincessYR✨～ (赞：0)

[双倍经验](https://www.luogu.com.cn/problem/CF427C)

这道题与CF的CF427C Checkposts十分相似

这道题难度并不大，只要会强连通分量基本上都能AC。

强连通分量讲解[看这里](https://183473.blog.luogu.org/tarjan-qiang-lian-tong-fen-liang)

我们分步来看：

首先，他让我们找最小值，我们可以在求强连通分量是给每一个强连通分量先付一个最大值，然后在和属于这个强连通分量的点一一比较，取最小值即可。

```
cost_last[numb]=min(cost_last[numb],cost[q]);
```

cost_last[numb]为第numb个强连通分量的最小值，cost[q]为属于第numb个强连通分量的点q的花费。

其次题目让我们求有几种花费相同的情况，我们可以去找每个强连通分量是否有花费一样的点，如果有就累乘，一直乘道最后，别忘了mod1000000007。

温馨提示：

# long long

请记住不开long long见zz，多开long long见zz。

最后贴上代码：

```
#include<bits/stdc++.h>
#define MAX 0x3f3f3f3f
using namespace std;
const int M= 1e5 + 10;
const int mod=1000000007; 
inline int read()
{
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')
		f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return x*f;
}
vector<int> m[M];
vector<int> fe[M];
stack<int> st;
bool inst[M];
int n,q,low[M],dfn[M],num;
int a,b,numb;
long long cost_last[M],cost[M],last_sum,latlat;
int nums[M],tot;
void tarjan(int x)
{
	dfn[x]=low[x]=++num;
	inst[x]=true;
	st.push(x);
	for(int i=0;i<m[x].size();i++)
	{
		int next=m[x][i];
		if(dfn[next]==0)
		{
			tarjan(next);
			low[x]=min(low[x],low[next]);
		}
		else if(inst[next]==1)
		{
			low[x]=min(low[x],dfn[next]);
		}
	}
	if(dfn[x]==low[x])
	{
		numb++;
		int q;
		do
		{
			q=st.top();
			st.pop();
			inst[q]=false;
			//bl[q]=numb;
			cost_last[numb]=min(cost_last[numb],cost[q]);
			fe[numb].push_back(q);
		}while(q!=x);
	}
}
int main() 
{
	latlat=1;
	tot=0;
	memset(cost_last,21474836,sizeof(cost_last)) ;
	n=read();
	for(int i=1;i<=n;i++)
	cost[i]=read();
	q=read();
	for(int i=1;i<=q;i++)
	{
		a=read();b=read();
		m[a].push_back(b);
	}
	for(int i=1;i<=n;i++)
		if(dfn[i]==0)
		tarjan(i);
	for(int i=1;i<=numb;i++)
	{
		last_sum+=cost_last[i];
	}
	cout<<last_sum<<" ";
	for(int i=1;i<=numb;i++)
	{
		for(int j=0;j<fe[i].size();j++)
		{
			if(cost[fe[i][j]]==cost_last[i])
			tot++;
		}
		latlat=(latlat*tot)%mod;
		tot=0;
	}
	cout<<latlat;
	return 0;
}
```


---

## 作者：寒鸽儿 (赞：0)

题面中,  
回路等价于强连通分量  
方案之间的区别在于不同回路选择的起点  
因此最小代价等于每个强连通分量的最小代价点之和  
方案数等于每个强连通分量的最小点权点的个数之积  
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;

const int maxn = 123456, maxm = 345678, inf = 2147483647, p = 1000000007;
typedef long long ll;

int cost[maxn];
int head[maxn], ver[maxm], nex[maxm], tot;
inline void addedge(int u, int v) {
	ver[tot] = v; nex[tot] = head[u]; head[u] = tot++;	
}

int dfn[maxn], low[maxn], minCost[maxn], co[maxn], num[maxn], sta[maxn], col = 1, dfs_clock = 1, top;
void tarjan(int cur) {
	dfn[cur] = low[cur] = dfs_clock++;
	sta[top++] = cur;
	for(int i = head[cur]; ~i; i = nex[i]) {
		if(!dfn[ver[i]]) {
			tarjan(ver[i]);
			low[cur] = min(low[cur], low[ver[i]]);	
		} else if(!co[ver[i]]) {
			low[cur] = min(low[cur], dfn[ver[i]]);
		}
	}
	if(dfn[cur] == low[cur]) {
		minCost[col] = cost[cur]; num[col] = 1;
		while(sta[--top] != cur) {
			co[sta[top]] = col;
			if(cost[sta[top]] < minCost[col]) {
				minCost[col] = cost[sta[top]];
				num[col] = 1;
			} else if(cost[sta[top]] == minCost[col]) {
				++num[col];	
			}
		}
		co[cur] = col++;
	}
}

int main() {
	memset(head, -1, sizeof(head));
	int n, m, u, v;
	scanf("%d", &n);
	for(int i = 1; i <= n; ++i) scanf("%d", cost + i);
	scanf("%d", &m);
	while(m--) {
		scanf("%d %d", &u, &v);
		addedge(u, v);
	}
	for(int i = 1; i <= n; ++i)
		if(!co[i])
			tarjan(i);
	ll ansCost = 0, ansNum = 1;
	for(int i = 1; i < col; ++i) {
		ansCost += minCost[i];
		ansNum = ansNum * num[i] % p;
	}
	printf("%lld %lld\n", ansCost, ansNum);
	return 0;
}
```

---

## 作者：abandentsky (赞：0)

题意：看完这个题目觉得是强联通没问题，问题在于需不需要缩点重新建图，后来发现题目说（可以从任何一个点开始走回路），所以就没必要了。直接上手跑强联通分量，同时记录每个强连通分量里面最小值的大小和元素个数。最后个数相乘，元素相加。输出就好了，没必要开Long Long。。直接给出代码：（刘汝佳版tarjain）
```c
#include<bits/stdc++.h>
#pragma GCC optimize(2)
#define MAXN 100010
#define maxnode 50010
#define sigma_size 26
#define md 1000000007
#define INF 0x3f3f3f3f
using namespace std;
typedef long long LL;

int n,m,u,v;
int val[MAXN];
vector<int> G[MAXN];
int pre[MAXN],lowlink[MAXN],sccno[MAXN],dfs_clock,scc_cnt;
stack<int> S;

void dfs(int u)
{
    S.push(u);
    pre[u]=lowlink[u]=++dfs_clock;
    for(int i=0;i<G[u].size();i++)
    {
        int v=G[u][i];
        if(!pre[v])
        {
            dfs(v);
            lowlink[u]=min(lowlink[u],lowlink[v]);
        }
        else if(!sccno[v])
        {
            lowlink[u]=min(lowlink[u],pre[v]);
        }
    }
    if(pre[u]==lowlink[u])
    {
        ++scc_cnt;
        for(;;)
        {
            int x=S.top();
            S.pop();
            sccno[x]=scc_cnt;
            if(x==u)
                break;
        }
    }
}

void Find_scc(int n)
{
    memset(pre,0,sizeof(pre));
    memset(sccno,0,sizeof(sccno));
    dfs_clock=scc_cnt=0;
    for(int i=1;i<=n;i++)
    {
        if(!pre[i])
            dfs(i);
    }
    int maxn[MAXN],num[MAXN];
    memset(maxn,INF,sizeof(maxn));
    for(int i=1;i<=n;i++)
    {
        int tg=sccno[i];
        if(val[i]<maxn[tg])                                          //在每个强连通分量里面找到最小值
        {
            maxn[tg]=val[i];                                          //记录最小值
            num[tg]=1;                                                   //此时的数量置为1
        }
        else if(val[i]==maxn[tg])                             //如果这个点是所在强连通的最小值
        {
            num[tg]++;                                                   //计数值直接加一
        }
    }
    int sum=0,ans=1;
    for(int i=1;i<=scc_cnt;i++)
    {
        sum+=maxn[i];
        ans*=num[i];
        ans%=md;
    }
    printf("%d %d\n",sum,ans);
}

int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d",&val[i]);
    scanf("%d",&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%d %d",&u,&v);
        G[u].push_back(v);
    }
    Find_scc(n);
    return 0;
}

```


---

## 作者：Last_Reincarnation (赞：0)

~~这道题看到机房dalao做，4遍才A掉，然后我也做了一下，一A,数据也太水了。。。。~~

csp前颓废发题解

进入正题：

1.首先读完题可以的出这是一道缩点的模板。

2.然后可以打完Tarjan版子

3.显然，每个环的费用即为环中费用的最小值，如果没环则费用为自己的费用

4.然后最小费用即为所有强连通的最小费用和

5.如何处理方案个数呢？我比较懒，所以开了一个map，将一个环中每个点的费用的直离散到map中然后每个环中最小费用出现的个数相乘即为方案数

6.其实map比较慢，如果要追求更快O（1）存费用的可以先把费用离散化一下，然后即可，这里就不写离散化代码了（为什么？因为我懒。。）

其实这样的题适合颓废时刷，思维量小，代码好打也好调。。

详细注释在代码中

code
```cpp
#include <iostream>
#include <cstdio>
#include <map>
#define Re register
using namespace std;

const int mod = 1e9 + 7;
const int maxn = 3e5 + 10;

map<int, int>M; 

int n, m, u, v, w;
int cnt, tim, top, ans, sum;
int head[maxn], a[maxn];
int dfn[maxn], low[maxn], sd[maxn], stc[maxn], size[maxn], val[maxn], rht[maxn];
bool vis[maxn];

//dfn[], low[], sd[], stc[], vis[]为缩点专用数组；
//size[]这里其实没啥用，就是顺手打上的，可以记录每个强连通中的点的个数
//val[]记录每个强连通中的最小值
//rht[]记录每个强连通中与最小值相等的点的个数

struct Edge{
	int u, v, w, next;
	Edge(int _u, int _v, int _nxt){
		this -> u = _u;
		this -> v = _v;
		this -> next = _nxt;
	}Edge(){}
}e[maxn << 1];//据说指针比较快。


inline int Min (int x,int y){
	return (x < y) ? x : y;
}//比较喜欢手写Min

void add (int u, int v){
	e[++cnt] = Edge(u, v, head[u]);
	head[u] = cnt;
}

int f_;
char ch_;
template <class T>
	inline T read (T &x_){
		x_ = 0, f_ = 1, ch_ = getchar();
		while (ch_ > '9' || ch_ < '0'){if (ch_ == '-') f_ = -1; ch_ = getchar();}
		while (ch_ >= '0' && ch_ <= '9') x_ = (x_ << 3) + (x_ << 1) + ch_ - 48, ch_ = getchar();
		return x_ *= f_;
	}
	
void Tarjan(int x){
	dfn[x] = low[x] = ++tim;
	stc[++top] = x;
	vis[x] = 1;
	for (Re int i = head[x];i;i = e[i].next){
		int y = e[i].v;
		if (!dfn[y]){
			Tarjan(y);
			low[x] = Min (low[x], low[y]);
		}
		else if (vis[y])
				low[x] = Min (low[x], dfn[y]);
	}
	if (dfn[x] == low[x]){
		int y;
		val[x] = a[x];
		while (y = stc[top--]){
			sd[y] = x;
			vis[y] = 0;
			size[x]++;//记录强连通中点的个数
			val[x] = Min (val[x], a[y]);//就强连通的最小费用
            M[a[y]]++;//离散到map中
			if (x == y) break;
		}
		rht[x] = M[val[x]];//记录与最小值相等的点的个数
		M.clear();//清空map
	}
}

int main(){
	read(n);
	for (Re int i = 1;i <= n; ++i) read(a[i]);
	read(m);
	for (Re int i = 1;i <= m; ++i){
		read(u); read(v);
		add (u, v);
	}
	for (Re int i = 1;i <= n; ++i){
		if (!dfn[i]) Tarjan(i);
	}
	sum = 1;//sum记录方案数
	for (Re int i = 1;i <= n; ++i){
		if (sd[i] != i) continue;//若等于i，则说明它就是强连通的头
		ans += val[i];
		if (size[i] == 1) continue;
		sum *= rht[i]; //求方案数
		sum %= mod;
	}
	printf ("%d ", ans);
	printf ("%d\n", sum);
	return 0;
}
```

有问题可以私信我，看到定回复。

祝大家CSP RP++;

日拱一卒，功不唐捐！


---

## 作者：LGG_ (赞：0)

数组**Tarjan**![](https://cdn.luogu.com.cn/upload/pic/1436.png)

numm[]和hh[]分别存方案和费用


```c
#include"iostream"
#include"cstring"
using namespace std;
#define inf 1e9
const int mod=1e9+7;
const int N = 310000;
const int M = 210000+100000;
int dfn[M],low[M],vv[M];
int be[M],hh[M],st[M],numm[M];
int fir[M],next[M],to[M];
bool co[N];
long long ans1=1,ans2=0;
int ss,n,m,now,cnt,tot,sc;
void tarjan(int u)
{
	dfn[u]=low[u]=++cnt;
	st[++tot]=u;
	co[u]=1;
	for(int i=fir[u];i;i=next[i])
	{//**这里**
		int v=to[i];
		if(!dfn[v])
		{
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}
		else 
		if(co[v])
		low[u]=min(low[u],dfn[v]);
	}
	if(low[u]==dfn[u])
	{
		sc++;
		be[u]=sc;
		hh[sc]=inf;
		do
		{
			now=st[tot--];
			co[now]=0;
			be[now]=sc;
			if(vv[now]<hh[sc])
			{
				hh[sc]=vv[now];
				numm[sc]=0;
			}
			if(vv[now]==hh[sc])numm[sc]++;
		}
		while(now!=u);
	}
}
void uu(int x,int y)
{
	to[++ss]=y;
	next[ss]=fir[x];
	fir[x]=ss;
}
int main()
{
	//memset(fir,-1,sizeof(fir));//如果
                              //赋值则函数循环“i”改为“i！=-1”；
	cin>>n;
	for(int i=1;i<=n;i++)
	cin>>vv[i];
	cin>>m;
	for(int i=1;i<=m;i++)
	{
		int x,y;
		cin>>x>>y;
		uu(x,y);
	}
	 for(int i=1;i<=n;i++)
        if(!dfn[i]) tarjan(i);
	
	for(int i=1;i<=sc;i++)
	{
		ans1*=numm[i];//ans1初始1（乘法。）
		ans2+=hh[i];
		ans1%=mod;
	}
	cout<<ans2<<" "<<ans1;
	return 0;
}
```
看不懂结构体的可以来看看数组![](https://cdn.luogu.com.cn/upload/pic/1436.png)



---

## 作者：LevenKoko (赞：0)

## [------更好的观看效果------](https://www.cnblogs.com/zhenglw/p/10752577.html)

###                 ~~省选前颓几道水题？~~

言归正传：
	显然这是一道TARJAN，~~题面已经想方设法在提醒你了~~
    
    
   只要记录每个强联通分量中的最小元素值和最小元素值对应的数量即可
   
   看到很多题解都是全部处理完之后在最后统计最小元素值和最小元素对应数量并统计两个答案的，其实对于减小常数来说这样是没必要的,因为每个强连通分量只会在tarjan的途中被搜索到一次（可以叫做无后效性？）所以只要一边tarjan一边统计答案即可
   
   
```cpp
#include<cstdio>
#include<iostream>
#include<cstdlib>
#include<cstring>
#define writep(x) write(x),putchar(' ')
#define writeln(x) write(x),puts("") 
#define ha 1000000007//珍惜生命，暴力取膜不可取，所以，我们取ha
using namespace std;
inline int read(){
    int ans=0,f=1;char chr=getchar();
    while(!isdigit(chr)){if(chr=='-') f=-1;chr=getchar();}
    while(isdigit(chr)){ans=(ans<<3)+(ans<<1)+chr-48;chr=getchar();}
    return ans*f;
}void write(int x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}const int M=3e5+5;
int n,m,a[M],head[M],ver[M],nxt[M],tot,dfn[M],low[M],ins[M],sta[M],top,t,mn[M],col,color[M],cnt[M],mc[M],ans1,ans2=1;
/*
col 强连通分量数量
color[]强连通分量的编号
cnt[]强连通分量重元素个数（这里貌似没用）
mn[]强连通分量中值最小值
mc[]强连通分量中最小值个数
*/
inline void add(int x,int y){ver[++tot]=y;nxt[tot]=head[x];head[x]=tot;}
inline void cmin(int &a,int b){if(a>b) a=b;}
void Tarjan(int x){
    dfn[x]=low[x]=++t;ins[x]=1,sta[top++]=x;
    for(register int i=head[x];i;i=nxt[i])
        if(ins[ver[i]]==0) Tarjan(ver[i]),cmin(low[x],low[ver[i]]);
        else if(ins[ver[i]]==1) cmin(low[x],dfn[ver[i]]);
    if(dfn[x]==low[x]) ++col,mn[col]=0x7fffffff;
    if(dfn[x]==low[x]){
        do{
            --top,++cnt[col],color[sta[top]]=col;ins[sta[top]]=-1;
            if(mn[col]>a[sta[top]])	 mn[col]=a[sta[top]],mc[col]=0;
            if(mn[col]==a[sta[top]]) ++mc[col];//关键部分
        }while(sta[top]!=x);
        ans1+=mn[col];ans2=ans2*mc[col]%ha;//记录答案
	}
    
}
int main(){
    n=read();for(register int i=1;i<=n;++i) a[i]=read();
    m=read();for(register int i=1,x,y;i<=m;++i){x=read(),y=read(),add(x,y);}
    for(register int i=1;i<=n;++i) if(!dfn[i]) Tarjan(i);//基本操作
    writep(ans1),writeln(ans2);//输出
    return 0;
}

```

---

## 作者：Zekrom (赞：0)

分2步：  
1.tarjan缩点    缩点时记录强连通分量内最少的花费和最少花费的方法数  
2.对于每个强连通分量  ans1+=最小花费,ans2*=方法数  
理清后  上代码  
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define N 100010
#define M 300010
#define inf 0x3f3f3f3f
const int mod=1e9+7; 
using namespace std;
int n,m,cost[N],dfn[N],low[N],min_cost[N],way[N],stack[N],ru[N],c[N],all[N],ans1,ans2,tot,num,cnt,top,head[N];
bool ins[N];
struct Edge{
	int u,v,next;
}edge[M];
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();
	}while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();
	}return  x*f;
}
inline void add(int x,int y){edge[++tot].u=x;edge[tot].v=y;edge[tot].next=head[x];head[x]=tot;}
void tarjan(int x){
	dfn[x]=low[x]=++num;
	stack[++top]=x;ins[x]=1;
	for(int i=head[x];i;i=edge[i].next){
		int y=edge[i].v;
		if(!dfn[y]){
			tarjan(y);
			low[x]=min(low[x],low[y]);
		} 
		else if(ins[y])
			low[x]=min(low[x],dfn[y]);
	}
	if(dfn[x]==low[x]){
		int z;cnt++;
		do{
			z=stack[top--];
			if(cost[z]<min_cost[cnt]){
				min_cost[cnt]=cost[z];way[cnt]=1;
			}
			else if(cost[z]==min_cost[cnt])
				way[cnt]++;
			ins[z]=0;c[z]=cnt;all[cnt]++;
		}while(x!=z);
	}
}
int main()
{
	n=read();
	memset(min_cost,0x3f,sizeof(min_cost));
	ans2=1;
	for(int i=1;i<=n;i++){
		cost[i]=read();
	}
	m=read();
	for(int i=1;i<=m;i++){
		int x=read(),y=read();
		add(x,y);
	}
	for(int i=1;i<=n;i++)
		if(!dfn[i])tarjan(i);
	for(int i=1;i<=tot;i++)
	{
		int u=edge[i].u,v=edge[i].v;
		if(c[u]!=c[v])
			ru[c[v]]++;
	}
	for(int i=1;i<=cnt;i++){
		ans1+=min_cost[i];
		ans2=ans2*way[i]%mod;
	}
	printf("%d %d\n",ans1,ans2);
	return 0;
}

```


---


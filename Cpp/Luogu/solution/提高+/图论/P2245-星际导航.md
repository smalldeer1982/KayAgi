# 星际导航

## 题目描述

$\text{sideman}$ 做好了回到 $\text{Gliese}$ 星球的硬件准备，但是 $\text{sideman}$ 的导航系统还没有完全设计好。为了方便起见，我们可以认为宇宙是一张有 $N$ 个顶点和 $M$ 条边的带权无向图，顶点表示各个星系，两个星系之间有边就表示两个星系之间可以直航，而边权则是航行的危险程度。

$\text{sideman}$ 现在想把危险程度降到最小，具体地来说，就是对于若干个询问 $(A, B)$，$\text{sideman}$ 想知道从顶点 $A$ 航行到顶点 $B$ 所经过的最危险的边的危险程度值最小可能是多少。作为 $\text{sideman}$ 的同学，你们要帮助 $\text{sideman}$ 返回家园，兼享受安全美妙的宇宙航行。所以这个任务就交给你了。

## 说明/提示

对于 $40\%$ 的数据，满足 $N \leq 1000, M \leq 3000, Q \leq 1000$。

对于 $80\%$ 的数据，满足 $N \leq 10000, M \leq 10^5, Q \leq 1000$。

对于 $100\%$ 的数据，满足 $N \leq 10^5, M \leq 3 \times 10^5, Q \leq 10^5, L \leq 10^9$。数据不保证没有重边和自环。

## 样例 #1

### 输入

```
4 5
1 2 5
1 3 2
2 3 11
2 4 6
3 4 4
3
2 3
1 4
1 2
```

### 输出

```
5
4
5
```

# 题解

## 作者：asuldb (赞：25)

### $kruskal$重构树，轻松最优解第一

这个东西主要来处理最小生成树的最大边权问题

当然也可以处理最大生成树的最小边权问题

其实这个重构树的核心思想跟 $krsskal$差不多

这张图是样例的最小生成树

![图](https://cdn.luogu.com.cn/upload/pic/24706.png)

而这张是重构树

![图](https://cdn.luogu.com.cn/upload/pic/24707.png )

我们看到右图里的重构树中多了一些方点

这些方点是怎么产生的呢

其实这些方点是原来最小生成树里的边

我们重构树的过程是这样的

   1. 将所有边按边权从小到大排序

   1.  每次最小的一条边，如果条边相连的两个点在同一个集合中，那么就跳过，否则就将这两个点的祖先都连到一个虚点上去，让这个虚点的点权等于这条边的边权

这样的话这课被重构的树就有一些奇妙的性质

   1. 原本最小生成树上的点在重构树里都是叶节点
   
   1. 从任何一个点往根上引一条路径，这条路径经过的点的点权单调不降（最大生成树单调不升）

   1. 任意两点之间路径的最大边权就是他们的LCA的点权
   
于是我们重构树之后找一下LCA就行了

这里用的是树剖，还是挺快的

代码

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#define re register
#define maxn 200001
using namespace std;
struct node
{
	int v,nxt,w;
}e[maxn<<2],a[maxn<<2];
int n,m,k,num,Q;
int fa[maxn],top[maxn],f[maxn],deep[maxn],head[maxn];
int sum[maxn],son[maxn],key[maxn];
inline int read()
{
	char c=getchar();
	int x=0;
	while(c<'0'||c>'9') c=getchar();
	while(c>='0'&&c<='9') 
		x=(x<<3)+(x<<1)+c-48,c=getchar();
	return x;
}
inline int find(int x)
{
	if(fa[x]==x) return x;
	return fa[x]=find(fa[x]);
}
inline int add_edge(int x,int y)
{
	e[++num].v=y;
	e[num].nxt=head[x];
	head[x]=num;
}
void dfs1(int r)
{
	sum[r]=1;
	int maxx=-1;
	for(re int i=head[r];i;i=e[i].nxt)
	if(!deep[e[i].v])
	{
		deep[e[i].v]=deep[r]+1;
		f[e[i].v]=r;
		dfs1(e[i].v);
		sum[r]+=sum[e[i].v];
		if(sum[e[i].v]>maxx) maxx=sum[e[i].v],son[r]=e[i].v;
	}
}
void dfs2(int r,int topf)
{
	top[r]=topf;
	if(!son[r]) return;
	dfs2(son[r],topf);
	for(re int i=head[r];i;i=e[i].nxt)
	if(deep[e[i].v]>deep[r]&&son[r]!=e[i].v) dfs2(e[i].v,e[i].v); 
}
inline int LCA(int x,int y)
{
	while(top[x]!=top[y])
	{
		if(deep[top[x]]<deep[top[y]]) swap(x,y);
		x=f[top[x]];
	}
	if(deep[x]<deep[y]) return x;
	return y;
}
inline int cmp(node aa,node bb)
{
	return aa.w<bb.w;
}
int main()
{
	n=read();
	m=read();
	for(re int i=1;i<=m;i++)
	{
		a[i].v=read();
		a[i].nxt=read();
		a[i].w=read();
	}
	sort(a+1,a+m+1,cmp);
	for(re int i=1;i<=(n<<1);i++) fa[i]=i;
	k=n;
	for(re int i=1;i<=m;i++)
	{
		int xx=find(a[i].v);
		int yy=find(a[i].nxt);
		if(xx==yy) continue;
		fa[xx]=fa[yy]=++k;
		add_edge(k,xx);
		add_edge(xx,k);
		add_edge(k,yy);
		add_edge(yy,k);
		key[k]=a[i].w;
	}
	for(re int i=k;i;i--)
	if(!deep[i]) deep[i]=1,dfs1(i),dfs2(i,i);
	Q=read();
	int x,y;
	while(Q--)
	{
		x=read();
		y=read();
		if(find(x)!=find(y)) puts("impossible");
		else printf("%d",key[LCA(x,y)]),putchar(10);
	}
	return 0;
}
```


---

## 作者：beng (赞：7)

[食用链接味道更佳qwq](http://www.cnblogs.com/qbwhtc/p/7406607.html)

# 主要算法：Kruskal算法构造最小生成树+数组模拟邻接表存储+最近公共祖先（LCA）查询。

本题给我们的是一个图，我们首先想到的可能是求出各个点之间的最短路径，但这一想就不现实，因为多源最短路径都要O(N^3)的时间复杂度，而单源最短路径一遍也会TLE，所以我们应换一种思路思考这道题。

我们~~敏锐地~~发现，这题似乎与NOIP2013Day1T3十分相似（几乎就是一样的，这篇题解的意义何在qwq），类似的题目还有NOIP2012Day2T3与NOIP2015Day2T3，这些题目的共同点都是在树上倍增跑，并且与NOIP2015Day2T3一样都用到了LCA，所以我们可以把它变成一棵树，这样我们就用到了最小生成树。这样，把它变成一棵树后再按之前的套路倍增啊，LCA啊之类的，就可以~~很容易的~~把这题A了。

现在我们首先要解决的是最小生成树的问题，到底是用Prim算法还是用Kruskal算法呢？我们知道，Prim算法要每次循环一遍找最小边权，这样时间复杂度就是O(N^2)了（但用堆什么的就另当别论了qwq），而Kruskal算法若用快排可以把时间复杂度减到O(N\*logN)（应该是吧qwq），因此Prim算法会TLE，而Kruskal算法不会，故我们用Kruskal算法。

接下来Kruskal算法筛下来的边用数组模拟的邻接表存储下来，开始建树。（这里注意把每一棵树都建好，我试过只建含有编号1的树，竟也A了，但我们还是严谨一点，不要水数据吧qwq~~但没想到只建含有编号1的树NOIP2013Day1T3这样也A了，数据是有多水~~）

接下来就是查询操作了。这里我使用的是倍增算法，倍增时我们可以参考之前的题目的经验，用一个二维数组f存储，其中f[i,j]表示第i个节点往上（根节点方向）跑2^j个点到达的点，但这样我们还是无法知道两点之间的最大边（题目要求的答案），所以我们可以再用一个二维数组s存储，s[i,j]表示第i个节点往上（根节点方向）跑2^j个点中的最大边，这样我们预处理完，就可以用log级别的时间复杂度来完成查询了。倍增算法的LCA我这里就不再叙述了。关于其他方面，就只要当两点的代表不是同一个点时特判一下输出“impossible”就可以了。

——————分割不完全的分割线——————

pascal代码如下：

```cpp
uses math;
var n,m,i,j,k,l,r,ans:longint;
a,be,tar,next,x,y,len:array[1..300000]of longint;
f,s:array[0..100000,0..17]of longint;
b:array[1..100000]of boolean;
c,last,floor,find:array[0..100000]of longint;
function go(x:longint):longint;//并查集
begin
  if c[x]<>x then
  go:=go(c[x])
  else
  go:=x;
  c[x]:=go;
end;
procedure sort(l,r:longint);//Kruskal算法先按边权排序
var i,j,xx,yy:longint;
begin
  i:=l;
  j:=r;
  xx:=len[(l+r) div 2];
  repeat
  while len[i]<xx do
  inc(i);
  while xx<len[j] do
  dec(j);
  if i<=j then
  begin
    yy:=len[i];
    len[i]:=len[j];
    len[j]:=yy;
    yy:=x[i];
    x[i]:=x[j];
    x[j]:=yy;
    yy:=y[i];
    y[i]:=y[j];
    y[j]:=yy;
    inc(i);
    dec(j);
  end;
  until i>j;
  if l<j then
  sort(l,j);
  if i<r then
  sort(i,r);
end;
begin
  readln(n,m);
  for i:=1 to m do
  readln(x[i],y[i],len[i]);
  for i:=1 to n do
  c[i]:=i;
  sort(1,m);
  for i:=1 to m do//Kruskal算法求最小生成树，并用邻接表存储
  if c[go(x[i])]<>c[go(y[i])] then
  begin
    c[go(x[i])]:=c[go(y[i])];
    inc(k);
    //因是无向图，所以每条边两点做起点的情况都不能放过
    a[k]:=len[i];//a数组装该边长度
    a[k+n-1]:=len[i];
    be[k]:=x[i];//be数组装该边起点
    be[k+n-1]:=y[i];
    tar[k]:=y[i];//tar数组装该边终点
    tar[k+n-1]:=x[i];
    next[k]:=last[x[i]];//next数组装下一个该找哪条边
    next[k+n-1]:=last[y[i]];
    last[x[i]]:=k;//last数组装以该点为起点的最后一条边是哪个
    last[y[i]]:=k+n-1;
  end;
  for j:=1 to n do//各种建树，这里使用的是BFS
  if not b[j] then
  begin
    l:=1;
    r:=1;
    find[1]:=j;//find为BFS数组
    floor[j]:=1;//floor为该点深度（根节点深度为1）
    b[j]:=true;//b数组表示是否被访问过
    while l<=r do//开始广搜
    begin
      i:=last[find[l]];
      while i>0 do
      begin
        if not b[tar[i]] then
        begin
          floor[tar[i]]:=floor[be[i]]+1;
          f[tar[i],0]:=be[i];
          s[tar[i],0]:=a[i];
          inc(r);
          find[r]:=tar[i];
          b[tar[i]]:=true;
        end;
        i:=next[i];
      end;
      inc(l);
    end;
  end;
  for j:=1 to 17 do//倍增预处理
  for i:=1 to n do
  begin
    f[i,j]:=f[f[i,j-1],j-1];
    s[i,j]:=max(s[i,j-1],s[f[i,j-1],j-1]);
  end;
  readln(m);
  for i:=1 to m do//开始查询
  begin
    readln(l,r);
    ans:=0;
    if c[go(l)]<>c[go(r)] then//特判两点不在同一集合的情况
    begin
      writeln('impossible');
      continue;
    end;
    //下面开始LCA
    if floor[l]<floor[r] then
    begin
      j:=l;
      l:=r;
      r:=j;
    end;
    if floor[l]>floor[r] then
    for j:=17 downto 0 do
    if floor[f[l,j]]>=floor[r] then
    begin
      if ans<s[l,j] then
      ans:=s[l,j];
      l:=f[l,j];
    end;
    if l=r then
    begin
      writeln(ans);
      continue;
    end;
    for j:=17 downto 0 do
    if f[l,j]<>f[r,j] then
    begin
      if ans<s[l,j] then
      ans:=s[l,j];
      if ans<s[r,j] then
      ans:=s[r,j];
      l:=f[l,j];
      r:=f[r,j];
    end;
    if ans<s[l,0] then
    ans:=s[l,0];
    if ans<s[r,0] then
    ans:=s[r,0];
    writeln(ans);
  end;
end.
```

---

## 作者：songyuchen (赞：5)

##最小生成树+最近公共祖先LCA+并查集

**很综合的一道题目**

要解决这一题，首先要想明白的是为什么最后的解一定在该图的最小生成树上。（这个留给读者自己思考啦，虽然说确实看起来是的，但如何准确地证明呢？这是需要思考的）


然后我们就可以对要查询的两个点进行LCA啦。关于LCA的基本算法（倍增）请到我的[这篇文章][1]查看。


那么接下来的问题是，我们虽然求出了最近公共祖先，但我们并不知道这条路上的最大边权是多少啊？


这里我们引入一个新数组Path。Path[u][i]代表u到它的2^i祖先的路径上的最大边权。是不是觉得Path的定义与Parent有些相似呢？是的，这也是为了在倍增过程中方便地更新最后要求的值所定义的，并且它的求值与更新与Parent总是在一起的，过程也很类似，相信如果读者已经了解了LCA中Parent数组的求法，不难推导出Path的求法。


程序中要添加求Path数组的地方有两处

一是在dfs过程中，在得出Parent[v][0]的值得同时可以得出Path[v][0]=W[u][v]（W[u][v]代表u-v这条边上的权值）

二是在for循环求Parent[i][j]=Parent[Parent[i][j-1]][j-1]时，同样可以递推出Path[i][j]=max(Path[i][j-1],Path[Parent[i][j-1]][j-1])，即i到2^j祖先路径上的最大值等于i到2^(j-1)上的最大值和i的2^(j-1)祖先到i的2^(j-1)祖先的2^(j-1)祖先的最大值这两者中的最大值。（有点绕，多读几遍就好了）


最后，在进行倍增上翻的过程中，每次更新a与b的值的同时，记录下最大的路径就可以了。


如果还有不理解，请结合下面的代码努力理解。

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<vector>
using namespace std;

class Edge1
{
public:
    int v,w;
};

class Edge2
{
public:
    int u,v,w;
};

bool operator < (Edge2 a,Edge2 b)
{
    return a.w<b.w;
}

const int maxN=100010;
const int maxM=300010;
const int inf=2147483647;

int n,m;
Edge2 E[maxM];
vector<Edge1> T[maxN];
//Union_Find_Set
int Mayuri[maxN];
//LCA
int Parent[maxN][25];
int Path[maxN][25];
int Depth[maxN];
bool vis[maxN];

int read();
void MST();
int Find(int u);
bool Union(int u,int v);
void LCA_init();
void dfs(int u);
int LCA(int a,int b);

int main()
{
    n=read();m=read();
    for (int i=1;i<=m;i++)
    {
        E[i].u=read();
        E[i].v=read();
        E[i].w=read();
    }
    MST();//求最小生成树
    LCA_init();//LCA的各种信息初始化
    int Q=read();
    for (int i=1;i<=Q;i++)
    {
        int x=LCA(read(),read());
        if (x==-1)
            cout<<"impossible"<<endl;//注意无解的情况，即这两点不连通，可以用并查集判断
        else
            cout<<x<<endl;
    }
    return 0;
}

int read()//读入优化
{
    int x=0;
    int k=1;
    char ch=getchar();
    while (((ch<'0')||(ch>'9'))&&(ch!='-'))
        ch=getchar();
    if (ch=='-')
    {
        k=-1;
        ch=getchar();
    }
    while ((ch>='0')&&(ch<='9'))
    {
        x=x*10+ch-48;
        ch=getchar();
    }
    return x*k;
}

void MST()//求最小生成树，这里用克鲁斯卡尔算法
{
    sort(&E[1],&E[m+1]);
    for (int i=1;i<=n;i++)//并查集初始化
        Mayuri[i]=i;
    int cnt=0;
    for (int i=1;i<=m;i++)
    {
        int u=E[i].u;
        int v=E[i].v;
        int w=E[i].w;
        if (Union(u,v))
        {
            T[u].push_back((Edge1){v,w});
            T[v].push_back((Edge1){u,w});
            cnt++;
            if (cnt==n-1)
                break;
        }
    }
    return;
}

int Find(int u)
{
    if (Mayuri[u]!=u)
        Mayuri[u]=Find(Mayuri[u]);
    return Mayuri[u];
}

bool Union(int u,int v)
{
    int fu=Find(u);
    int fv=Find(v);
    if (fu!=fv)
    {
        Mayuri[fu]=fv;
        return 1;
    }
    return 0;
}

void LCA_init()
{
    memset(Parent,0,sizeof(Parent));
    memset(Path,0,sizeof(Path));
    memset(Depth,0,sizeof(Depth));
    memset(vis,0,sizeof(vis));
    dfs(1);
    for (int j=1;j<=20;j++)
        for (int i=1;i<=n;i++)
        {
            Parent[i][j]=Parent[Parent[i][j-1]][j-1];
            Path[i][j]=max(Path[i][j-1],Path[Parent[i][j-1]][j-1]);//同时求解Path
        }
    return;
}

void dfs(int u)
{
    vis[u]=1;
    for (int i=0;i<T[u].size();i++)
    {
        int v=T[u][i].v;
        if (vis[v]==0)
        {
            Depth[v]=Depth[u]+1;
            Parent[v][0]=u;
            Path[v][0]=T[u][i].w;//记录Path的初值
            dfs(v);
        }
    }
}

int LCA(int a,int b)
{
    if (Find(a)!=Find(b))
    {
        return -1;
    }
    int max_path=0;
    if (Depth[a]<Depth[b])
        swap(a,b);
    for (int i=20;i>=0;i--)
        if ((Parent[a][i]!=0)&&(Depth[Parent[a][i]]>=Depth[b]))
        {
            max_path=max(max_path,Path[a][i]);//同时更新当前的最大边权
            a=Parent[a][i];
        }
    if (a==b)
        return max_path;
    for (int i=20;i>=0;i--)
        if ((Parent[a][i]!=0)&&(Parent[b][i]!=0)&&(Parent[a][i]!=Parent[b][i]))
        {
            max_path=max(max_path,Path[a][i]);//这里也是更新当前的最大边权
            max_path=max(max_path,Path[b][i]);
            a=Parent[a][i];
            b=Parent[b][i];
        }
    max_path=max(max_path,Path[a][0]);//最后要注意再与Path[a][0]和Path[b][0]比较一下，因为在原来的LCA中，公共祖先是Parent[a][0]或Parent[b][0]
    max_path=max(max_path,Path[b][0]);
    return max_path;
}
```
 [1]: http://www.cnblogs.com/SYCstudio/p/7150010.html

另外Link一下我的博客：http://www.cnblogs.com/SYCstudio/

我的博客中关于本题的解法：http://www.cnblogs.com/SYCstudio/p/7151236.html

PS：管理员给个通过吧，这道题还没有题解呢


---

## 作者：doby (赞：4)

货车运输 数据加强版

所经过的最危险的边的危险程度值最小

又在一张图上，可以得出可以经过的边都在这张图的最小生成树上

把边权推给一条边上深度更大的点，用树剖/倍增快速求两点间最大点权

两点的LCA的点权所代表的边不在这两点间的路径上，要去掉

最后重构出来的可能是森林，要用并查集判断是否在同一棵树上

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n,m,q,x,y,bks,cnt,tot,out,u[100010],v[100010],w[100010],a[100010],at[100010],fa[100010],h[100010],dep[100010],size[100010],dad[100010],son[100010],id[100010],top[100010];
char c;
struct Edeg
{
	int u,v,w;
}d[300010];
struct Edge
{
	int to,next;
}e[200010];
struct SegT
{
	int s;
}t[400010];
int read()
{
	out=0,c=getchar();
	while(c<48||c>57){c=getchar();}
	while(c>=48&&c<=57){out=(out<<3)+(out<<1)+(c&15),c=getchar();}
	return out;
}
bool cmp(const Edeg &a, const Edeg &b)
{
	return a.w<b.w;
}
int max(int a,int b)
{
	return a>b?a:b;
} 
int Find(int x)
{
	return fa[x]==x?x:fa[x]=Find(fa[x]);
}
void Add(int x,int y)
{
	e[++cnt].next=h[x],
	e[cnt].to=y,
	h[x]=cnt;
}
void Kruskal()
{
	sort(d+1,d+m+1,cmp);
	for(int i=1;i<=n;i++){fa[i]=i;}
	bks=0;
	for(int i=1;i<=m;i++)
	{
		int fx=Find(d[i].u),fy=Find(d[i].v);
		if(fx^fy)
		{
			fa[fx]=fy,++bks,
			u[bks]=d[i].u,v[bks]=d[i].v,w[bks]=d[i].w;
			Add(d[i].u,d[i].v);
			Add(d[i].v,d[i].u);
		}
		if(bks==n-1){break;}
	}
}
void DFS1(int x)
{
	dep[x]=dep[dad[x]]+1,size[x]=1;
	for(int i=h[x];i;i=e[i].next)
	{
		int y=e[i].to;
		if(y^dad[x])
		{
			dad[y]=x;
			DFS1(y);
			size[x]+=size[y];
			if(size[son[x]]<size[y]){son[x]=y;}
		}
	}
}
void DFS2(int x)
{
	id[x]=++tot,at[tot]=a[x],
	top[x]=x==son[dad[x]]?top[dad[x]]:x;
	if(!son[x]){return;}
	DFS2(son[x]);
	for(int i=h[x];i;i=e[i].next)
	{
		int y=e[i].to;
		if(y^dad[x]&&y^son[x]){DFS2(y);}
	}
}
void Pushup(int k)
{
	t[k].s=max(t[k<<1].s,t[k<<1|1].s);
}
void Build(int k,int l,int r)
{
	if(l==r)
	{
		t[k].s=at[l];
		return;
	}
	int mid=l+r>>1;
	Build(k<<1,l,mid);
	Build(k<<1|1,mid+1,r);
	Pushup(k);
}
int Query(int k,int l,int r,int ll,int rr)
{
	if(r<ll||rr<l){return -19260817;}
	if(ll<=l&&r<=rr){return t[k].s;}
	int mid=l+r>>1;
	return max(Query(k<<1,l,mid,ll,rr),Query(k<<1|1,mid+1,r,ll,rr));
}
int LCA(int x,int y)
{
	int ans=-19260817;
	while(top[x]^top[y])
	{
		if(dep[top[x]]<dep[top[y]]){x^=y,y^=x,x^=y;}
		ans=max(ans,Query(1,1,n,id[top[x]],id[x])),
		x=dad[top[x]];
	}
	if(dep[x]>dep[y]){x^=y,y^=x,x^=y;}
	ans=max(ans,Query(1,1,n,id[x]+1,id[y]));
	return ans;
}
int main()
{
	n=read(),m=read();
	for(int i=1;i<=m;i++){d[i].u=read(),d[i].v=read(),d[i].w=read();}
	Kruskal();
	for(int i=1;i<=n;++i){if(!dep[i]){DFS1(i);}}
	for(int i=1;i<n;++i)
	{
		if(dep[u[i]]>dep[v[i]]){a[u[i]]=w[i];}
		else{a[v[i]]=w[i];}
	}
	for(int i=1;i<=n;++i){if(!id[i]){DFS2(i);}}
	Build(1,1,n);
	q=read();
	while(q--)
	{
		x=read(),y=read();
		if(Find(x)!=Find(y)){puts("impossible");}
		else{printf("%d\n",LCA(x,y));}
	}
	return 0;
}
```

---

## 作者：Erina (赞：3)

为什么这题一定要用kruskal重构树?

其实直接倍增就好了啊......

把最小生成树搞出来, 然后直接在树上倍增求最小边权就行了.

吸一口氧好像直接挤进了最优解第一面吧......

```cpp
#include<iostream>
#include<queue>
#include<algorithm>
#define max(x,y) (x>y?x:y)// 相传能变快, 但是其实变慢了
using namespace std;
namespace fio {
	streambuf* in = cin.rdbuf();
	char bb[1000000], * s = bb, * t = bb;
#define gc() (s==t&&(t=(s=bb)+in->sgetn(bb,1000000),s==t)?EOF:*s++)
	inline int read() {// 快读
		int x = 0;
		char ch = gc();
		while (ch < 48)ch = gc();
		while (ch >= 48)x = x * 10 + ch - 48, ch = gc();
		return x;
	}
}using fio::read;
typedef pair<int, int>mp;
typedef pair<mp, int>mmp;
int anc[100005][20], maxn[100005][20], dep[100005], fa[100005];
int n, m;
vector<mmp>rds;
vector<mp>road[100005];
int find(int x) { return x == fa[x] ? x : fa[x] = find(fa[x]); }
void dfs(int x, int p) {
	dep[x] = dep[p] + 1, anc[x][0] = p;
	for (int i = 1; i < 20; i++)anc[x][i] = anc[anc[x][i - 1]][i - 1], maxn[x][i] = max(maxn[x][i - 1], maxn[anc[x][i - 1]][i - 1]);
	for (mp it : road[x])if (it.first != p)maxn[it.first][0] = it.second, dfs(it.first, x);
}
int lca(int x, int y) {// 倍增部分核心代码
	int ans = 0;
	if (dep[x] < dep[y])swap(x, y);
	for (int i = 19; ~i; i--)if (dep[anc[x][i]] >= dep[y])ans = max(ans, maxn[x][i]), x = anc[x][i];
	if (x == y)return ans;
	for (int i = 19; ~i; i--)if (anc[x][i] != anc[y][i])ans = max(ans, max(maxn[x][i], maxn[y][i])), x = anc[x][i], y = anc[y][i];
	return max(ans, max(maxn[x][0], maxn[y][0]));
}
void w(int x) {// 快写, 其实还有更快的但是懒得写 :(
	if (x >= 10)w(x / 10);
	putchar(x % 10 + 48);
}
int main() {
	n = read(), m = read();
	for (int i = 1; i <= n; i++)fa[i] = i;
	for (int i = 1; i <= m; i++)rds.push_back({ {read(), read()}, read() });
	sort(rds.begin(), rds.end(), [](mmp a, mmp b) {return a.second < b.second; });// 构建最小生成树
	for (mmp it : rds)if (find(it.first.first) != find(it.first.second))
		fa[find(it.first.first)] = find(it.first.second),
		road[it.first.first].emplace_back(it.first.second, it.second), road[it.first.second].emplace_back(it.first.first, it.second);// 构建最小生成树
	for (int i = 1; i <= n; i++)if (!dep[i])dfs(i, 0);
	int q = read();
	while (q--) {
		int x = read(), y = read();
		if(find(x)!=find(y))puts("impossible");// you don't say!(其实是没有看见)
		else w(lca(x, y)), putchar('\n');
	}
}
```


---

## 作者：betterer (赞：3)

### Kruskal（并查集）算法求MST（最小生成树）+倍增求父
[最小生成树出门左拐](https://www.luogu.org/problemnew/show/P3366)
### 着重介绍倍增，也就是deep[N],up[N][18],da[N][18]和lca()
- deep[i] _dfs()
- up[j][i] **j的第2^i代father**
- da[j][i] **j的第2^i代father之间的最危险的边的危险程度值**

在_dfs()中算得j的father即2^0代father,和j的father即第2^0代father之间的最危险的边的危险程度值

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100005,M=300005;
int n,m,q,b[N],ai,fa[N],aj,deep[N],up[N][18],da[N][18],flag[N],ans;
struct node{
    int to,next/*from*/,danger;
    bool operator<(node &x){
    	return danger<x.danger;
    }
}aa[M]/*Graph*/,a[N<<1];//SMT
void in(){
    scanf("%d%d",&n,&m);
    for(int i=0,x,y,z;i<m;i++)
    {
        scanf("%d%d%d",&x,&y,&z);
        aa[++ai]=(node){x,y,z};
    }
}
int find(int i){
    if(fa[i]!=i)fa[i]=find(fa[i]);
    return fa[i];
}
void _dfs(int u){
    for(int i=b[u],v;i;i=a[i].next)
    if(!deep[v=a[i].to])
    {
        deep[v]=deep[u]+1;
        up[v][0]=u;
        da[v][0]=a[i].danger;
        _dfs(v);
    }
}
int lca(int x,int y){
    int i,ans=0;
    if(deep[y]>deep[x])swap(x,y);
    for(i=17;~i;--i)//走到同一个高度
    if(deep[up[x][i]]>=deep[y])
    ans=max(ans,da[x][i]),x=up[x][i];//倍增
    for(i=17;~i;--i)//找最早的共同父亲，同时求出最小值
    if(up[x][i]!=up[y][i])
    ans=max(ans,max(da[x][i],da[y][i])),x=up[x][i],y=up[y][i];//倍增
    return x==y?ans:max(ans,max(da[x][0],da[y][0]));//最后检验
}
void work(){
    for(int i=1;i<=n;i++)fa[i]=i;
    sort(aa+1,aa+ai+1);
    for(int i=1;i<=ai;i++)
    {
        int ii=aa[i].to,jj=aa[i].next,kk=aa[i].danger;
        if(find(ii)!=find(jj)){
            fa[find(ii)]=find(jj);
            a[++aj]=(node){ii,b[jj],kk};b[jj]=aj;
            a[++aj]=(node){jj,b[ii],kk};b[ii]=aj;
        }
    }
}
void pre(){
    for(int i=1;i<=n;++i)
    if(!deep[i])
    {
        deep[i]=1;
        _dfs(i);
        up[i][0]=i;//self-father防越位
        da[i][0]=0;
    }
    for(int i=1;i<18;++i)
    for(int j=1;j<=n;++j)
    {
        up[j][i]=up[up[j][i-1]][i-1];
        da[j][i]=max(da[j][i-1],da[up[j][i-1]][i-1]);
    }
}
void out(){
    pre();
    int ii,jj;
    for(scanf("%d",&q);q;q--)
    {
        scanf("%d%d",&ii,&jj);
        if(find(ii)!=find(jj))printf("impossible\n");
        else printf("%d\n",lca(ii,jj));
    }
}
int main(){
    in();
    work();
    out();
}
```

---

## 作者：yyb_test (赞：3)

既然只有一篇题解

那么，我来补充一篇

首先，在题解的最开始，一定要%%%楼上大佬songyuchen


---

接下来进入正题

这道题和NOIP2013货车运输的本质是一模一样的

显然可以用更好的方法来解决（网络流、树链剖分等）

但是我这个蒟蒻用最弱的方法：最小生成树+LCA


---
但是，一定有人会有疑问，为什么是最小生成树

我们可以简单的证明一下

假设当前的两个节点之间，最小生成树上的最大边权是x

但是存在另外一条路径的边权的最大值是x'，且x‘<x

这种情况会不会存在？

最小生成树是将边按照权值排序后再来链接

如果存在x'所在的这一条路径的话,必定会优先选择x'所在的路径

而不是x所在的路径

（为什么请自己考虑一下）

那么，知道结果必定在最小生成树上

问题迎刃而解

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
#define MAX 110000
#define MAXL 510000
#define INF 0

inline int read()
{
    register int x=0,t=1;
    register char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
    if(ch=='-'){t=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
    return x*t;
}

int f[MAX],dep[MAX];
int minl[MAX][21],p[MAX][51];
int n,m,Q,u,v,w;

struct Line
{
      int u,v,w;//从u到v，权值w 
}e[MAXL];

struct Edge
{
      int v,next,w;
}E[MAXL];
int h[MAX],cnt=1,tot=1;

inline void Add(int u,int v,int w)//建边
{
       E[tot]=(Edge){v,h[u],w};
       h[u]=tot++;
}

inline bool operator <(Line a,Line b)//需要求最小生成树 
{
      return a.w<b.w;
}

int getf(int u)//并查集 
{
      return f[u]==u?u:f[u]=getf(f[u]);
}

void Build(int u,int ff)//建树 
{
      for(int i=h[u];i;i=E[i].next)
      {
               int v=E[i].v;
               if(v!=ff)
               {
                        dep[v]=dep[u]+1;
                        p[v][0]=u;
                        minl[v][0]=E[i].w;
                        Build(v,u);
               }
      }
}

void Prepare()//LCA的预处理 
{
      for(int j=1;(1<<j)<=n;++j)
      {
              for(int i=1;i<=n;++i)
              {
                        p[i][j]=p[p[i][j-1]][j-1];
                        minl[i][j]=max(minl[i][j-1],minl[p[i][j-1]][j-1]);
              }
      }
}

int Query(int u,int v)//询问 
{
      int ans=INF;
      if(dep[u]<dep[v])swap(u,v);//u是深度大的结点
      for(int j=20;j>=0;--j)//使得u,v深度相同 
          if(p[u][j]&&dep[p[u][j]]>=dep[v])
          {
                    ans=max(ans,minl[u][j]);
                    u=p[u][j];
          }
      if(u==v)
          return ans;
      for(int j=20;j>=0;--j)//找到LCA并求解 
      {
            if(p[u][j]!=p[v][j])
            {
                      ans=max(ans,minl[u][j]);
                      ans=max(ans,minl[v][j]);
                      u=p[u][j];
                      v=p[v][j];
            }
      }
      ans=max(ans,minl[u][0]);
      ans=max(ans,minl[v][0]);
      return ans;
}

int main()
{
    n=read();m=read();
    for(int i=1;i<=m;++i)
       e[i]=(Line){read(),read(),read()};
    sort(&e[1],&e[m+1]);
    
    //克鲁斯卡尔求最小生成树
    for(int i=1;i<=n;++i)f[i]=i;//并查集初始化 
    for(int i=1;i<n;++i)//克鲁斯卡尔 
    {
            while(getf(e[cnt].u)==getf(e[cnt].v)&&cnt<=m)cnt++;//找到下一条可行的边
            if(cnt>m)break;//不用连了，没有边了 
            f[getf(e[cnt].v)]=getf(e[cnt].u);//选择边
            Add(e[cnt].u,e[cnt].v,e[cnt].w);
            Add(e[cnt].v,e[cnt].u,e[cnt].w);
    }
    

    for(int i=1;i<=n;++i)//建树 
      if(!dep[i])
      {
              dep[i]=1;
              Build(i,0);
      }
      
    Prepare();//LCA准备 
    
    Q=read();
    while(Q--)
    {
             u=read();v=read();
             if(getf(u)!=getf(v))//没有连在一起 
                printf("impossible\n");
             else
                 printf("%d\n",Query(u,v));
    }
}

```

---

## 作者：C1R1A1E1F1 (赞：2)

这题其实和[P1967货车运输](https://www.luogu.com.cn/problem/P1967)很像了~~

~~所以说别讲了~~

# PART 1：思路

首先分析题目，这道题让我们求两点之间路径上最大边权的最小值（接下来简称“距离”，包含“距离”的路径简称“距离”路径），看到这里猛然想起P1967有没有！ ~~（然而我不会做！）~~

那么我们就顺理成章的想到了求最小生成树，但是为什么最小生成树正确呢？

## 反证法！
### 证明：

**假设一：存在两点 $x,y$ 使得两点在树上的“距离”           $treedis(x,y)$ 大于两点之间的“距离” $dis(x,y)$ 。**

回顾最小生成树定义，易知图 $S$ 的最小生成树 $T$ 可以满足一个性质：

**性质一：若不包含边 $(x,y)$ ，则必存在一条从 $x$ 到 $y$ 的路径 $k$ 使得路径上的每一条边的边权都比边(x,y)的边权 $cost$ 小。**

同时我们还能易得一个“距离”路径的性质：

**性质二：若从点 $x$ 到点 $y$ 的“距离”路径 $k$ 不经过边 $(x,y)$ ，那么任何一条过边 $(x,y)$ 的路径 $k_x$ 都不是“距离”路径**

那么我们就可以瞬间证伪原假设：

首先设这条导致 $dis(x,y)\leqslant treedis(x,y)$ 的边为 $(t_1,t_2)$ ，并且边权为 $t_k$ ，那么因为最小生成树 $T$ 不包含边 $(t_1,t_2)$ ，所以根据性质一，在 $T$ 上必然存在从 $t_1$ 到   $t_2$ 的路径 $k$ 使得 $k$ 上的每一条边边权都小于等于 $t_k$ ，所以说 $t_1,t_2$ 之间的“距离”肯定不等于 $t_k$ ，又由性质二的每条经过 $(t_1,t_2)$ 的路径都不会是最优解，从而假设一不成立。

那么我们就有思路了：先遍历出来原图 $S$ 的最小生成树 $T$ ,再在树上求出 $A,B$ 两点之间的唯一一条“距离”。

# PART 2：优化+细节

树上求距离很明显是LCA，但是看见这 $N=10^5,Q=10^5$ 的数据范围心里还是发憷……

### 那就优化！

怎么优化呢？很简单，我们一点一点分析：

首先倍增求最近公共祖先和kruskal求最小生成树已经优化到头了，但是我们树上寻路还是没有优化！

但是如何优化树上寻路呢？

其实真·非常简单，我们只需要仿照倍增求$LCA$的方法做出倍增求“距离”就可以了，类似的状态转移方程如下：

$dis[i][j]=max(dis[i-1][j],dis[i-1][fa[i-1][j]])$

最后提醒一点：如果两个顶点之间不可达，输出 $impossible$ ,也就是说图有可能不连通！！！

# PART 3：code
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,q,fa[100005],f[18][100005],vit[100005],dep[100005],lo[18][100005];
struct i1
{
	int from,to,cost;//kruskal存边
}ed[300005];
struct it
{
	
	int t,cost;//存树图
};
vector<it>mp[100005];
bool cmp(i1 a,i1 b)
{
	return a.cost<b.cost;
}
int find(int x)//kruskal并查集
{
	if(fa[x]==x)
		return x;
	fa[x]=find(fa[x]);
	return fa[x];
}
void add(int ff,int t,int x)//往树图里加边
{
	it temp;
	temp.cost=x;
	temp.t=t;
	mp[ff].push_back(temp);
}
void kls()//kruskal=kls
{
	int num=0;//边的数量
	for(int i=1;i<=m;i++)
	{
		i1 temp=ed[i];
		int ff=find(temp.from),ft=find(temp.to);
		if(ff!=ft)//如果这条边连的是不同区块
		{
			num++;
			fa[ff]=ft;//并查集基本操作
			add(temp.from,temp.to,temp.cost);//往树图加边
			add(temp.to,temp.from,temp.cost);
		}
		if(num==n-1)
			return;
	}
}
void fs(int x,int fat,int loo)//深搜建树
{
	vit[x]=1;//万一不联通呢？
	f[0][x]=fat;//倍增求父
	dep[x]=dep[fat]+1;//我的深度
	lo[0][x]=loo;//倍增求距
	for(int i=0;i<mp[x].size();i++)
	{
		it temp=mp[x][i];
		if(temp.t!=fat)
			fs(temp.t,x,temp.cost);//递归搜索
	}
}
void ycl()//预处理=ycl
{
	for(int i=1;i<=17;i++)
		for(int j=1;j<=n;j++)
			f[i][j]=f[i-1][f[i-1][j]];//真·倍增求父
	for(int i=1;i<=17;i++)
		for(int j=1;j<=n;j++)
			lo[i][j]=max(lo[i-1][j],lo[i-1][f[i-1][j]]);//真·倍增求距
}
int lca(int x,int y)//lca
{
	if(x==y)
		return x;
	if(dep[x]<dep[y])
		swap(x,y);
	for(int i=17;i>=0;i--)
		if(dep[f[i][x]]>=dep[y])
			x=f[i][x];//倍增向上跳
	if(x==y)
		return x;//在P3379被卡了好几天才发现没加的特判
	for(int i=17;i>=0;i--)
		if(f[i][x]!=f[i][y])
			x=f[i][x],y=f[i][y];//一起往上跳
	return f[0][x];
}
int fl(int x,int y)//树上求距
{
	int sum=0;
	for(int i=17;i>=0;i--)
		if(dep[f[i][x]]>=dep[y])
			sum=max(sum,lo[i][x]),x=f[i][x];//倍增往上跳
	return sum;
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
		cin>>ed[i].from>>ed[i].to>>ed[i].cost;
	sort(ed+1,ed+1+m,cmp);//排序
	for(int i=1;i<=n;i++)
		fa[i]=i;//并查集一定要初始化！！！
	kls();/、kruskal
	for(int i=1;i<=n;i++)
		if(vit[i]==0)
			fs(i,i,0);//对森林进行搜索
	ycl();//预处理
	cin>>q;
	while(q--)
	{
		int x,y;
		cin>>x>>y;
		if(find(x)!=find(y))//如果不在一棵树上
			cout<<"impossible";
		else//否则
		{
			int Lca=lca(x,y);
			cout<<max(fl(x,Lca),fl(y,Lca));//要输出较大值
		}
		cout<<endl;
	}
}
```

//第一篇题解，求过~~


---

## 作者：Agakiss (赞：1)

### Description
[[LuoGu2245]星际导航](https://www.luogu.org/problem/P2245)
### Solution
好像叫作最小瓶颈路问题

就是把原图求最小生成树，然后在树上跑$\text{LCA}$的最大值

如果不在一个一颗树上，就输出$\text{impossible}$

玄学证明不会
### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 800010
struct rec {
	int nxt, ver, val;
} t[N];
struct Rec {
	int u, v, w;
} e[N];
int n, m, q, cnt, tot, u, v;
int fa[N], head[N], deep[N], f[N][21], h[N][21];
inline int read() {
	int s = 0, w = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') w = -1;
	for (; isdigit(c); c = getchar()) s = (s << 1) + (s << 3) + (c ^ 48);
	return s * w;
}
int find(int x) {
	if (fa[x] == x) return x;
	return fa[x] = find(fa[x]);
}
inline void Merge(int x, int y) {
	fa[find(x)] = find(y);
}
inline bool cmp(Rec x, Rec y) {
	return x.w < y.w;
}
inline void add(int u, int v, int w) {
	t[++cnt].nxt = head[u], t[cnt].ver = v, t[cnt].val = w, head[u] = cnt;
}
inline void Init() {
	for (register int i = 1; i <= n; i++)
		fa[i] = i;
}
inline void kruskal() {
	sort(e + 1, e + m + 1, cmp);
	for (register int i = 1; i <= m; i++) {
		int eu = find(e[i].u), ev = find(e[i].v);
		if (eu == ev) continue;
		add(e[i].u, e[i].v, e[i].w), add(e[i].v, e[i].u, e[i].w);
		fa[ev] = eu;
		++tot;
		if (tot == n - 1) break;
	}
}
void DFS(int u, int fa, int w) {
	deep[u] = deep[fa] + 1;
	f[u][0] = fa, h[u][0] = w;
	for (register int i = 1; i <= 20; i++)
		f[u][i] = f[f[u][i - 1]][i - 1],
		h[u][i] = max(h[u][i - 1], h[f[u][i - 1]][i - 1]);
	for (register int i = head[u]; i; i = t[i].nxt) {
		int v = t[i].ver;
		if (v != fa)
			DFS(v, u, t[i].val);
	}
}
inline int LCA(int u, int v) {
	int ans = 0;
	if (deep[u] < deep[v]) swap(u, v);
	for (register int i = 20; i >= 0; i--)
		if (deep[f[u][i]] >= deep[v]) {
			ans = max(ans, h[u][i]);
			u = f[u][i];
		}
	if (u == v) return ans;
	for (register int i = 20; i >= 0; i--)
		if (f[u][i] != f[v][i]) {
			ans = max(ans, h[u][i]), ans = max(ans, h[v][i]);
			u = f[u][i], v = f[v][i];
		}
	ans = max(ans, h[u][0]), ans = max(ans, h[v][0]);
	return ans;
}
int main() {
	//freopen("a.in", "r", stdin);
	//freopen("1.out", "w", stdout);
	n = read(), m = read();
	for (register int i = 1; i <= m; i++)
		e[i].u = read(), e[i].v = read(), e[i].w = read();
	Init();
	kruskal();
	for (register int i = 1; i <= n; i++)
		if (!deep[i])
			DFS(i, 0, 0);
	q = read();
	for (register int i = 1; i <= q; i++) {
		u = read(), v = read();
		if (find(u) != find(v))
			printf("impossible\n");
		else
			printf("%d\n", LCA(u, v));
	}
	return 0;
}
```

---

## 作者：Saber_Master (赞：0)

[P2245 星际导航](https://www.luogu.com.cn/problem/P2245)

#### 克鲁斯卡尔重构树

本题可以算是克鲁斯卡尔重构树的模板题，下面简称重构树.重构树是用来解决无向图中关于某段路径上最小边权最大或最大边权最小问题的利器.下面简要介绍一下构造过程：

同普通的库鲁斯卡尔一样，重构树也需要使用并查集维护连通性，最终得到图的是原图的一个极大生成森林.

1.  本题需要求最大边权最小，所以我们考虑先将边权从小到达排序.
2.  接下来依次扫描每一条边$(x, y, z)$，若$x$与$y$在同一个并查集内，则直接$continue$掉.否则，我们新建一个附加点$p$.假若$x$所在的并查集祖先为$f_x$，$y$所在的并查集祖先为$f_y$，那么，我们将$f_x$和$f_y$的父亲指向点$p$，顺便在邻接表连上无权有向边$(p, x)$和$(p, y)$.此时，$p$是带点权的，其值为此时的边权$z$.
 
容易发现，由于我们边权是从小到大排序的，并且每次连接的时候父节点的权值都不小于子节点权值，故构造出的重构树是一个类似于大根堆的结构,并且由根出发的路径上深度越大的节点权值越小.

对于每一个询问$(x, y)$, $lca(x, y)$的权值即为答案.

注意特判掉$x,y$不连通的情况.

排序复杂度$O(n \log n)$，倍增$lca$复杂度$O(n \log n)$，故总复杂度$O(n \log n)$

核心代码

```cpp
const ll N=2e5+5, M=3e5+5;

ll head[N], to[N<<1], next[N<<1], tot;
inline void add(ll x, ll y){
	to[++tot]=y; next[tot]=head[x]; head[x]=tot;
}

inline void Link(ll x, ll y){
	add(x, y); add(y, x);
}

ll n, m;

struct node{
	ll x, y, z;
	
	node(){}
	node(ll X, ll Y, ll Z):x(X), y(Y), z(Z){}
	
	inline bool operator <(const node &X)const{return this->z<X.z;}
}edge[M];

namespace dsu{
	ll f[N];
                                                                   
	//并查集初始化
	inline void init(ll lim){
		for (R ll i=1; i<=lim; i++) f[i]=i;
	}
	
	inline ll getf(ll x){
		return f[x]==x?x:f[x]=getf(f[x]);
	}
}

ll cnt;
ll v[N];
ll f[N][20], dep[N];

inline void dfs(ll x, ll fa){
	f[x][0]=fa;
	for (R ll i=1; i<20; i++) f[x][i]=f[f[x][i-1]][i-1];
	dep[x]=dep[fa]+1;
	for (R ll i=head[x], ver; i; i=next[i]){
		ver=to[i];
		dfs(ver, x);
	}
}

inline ll lca(ll x, ll y){
	if (dep[x]<dep[y]) swap(x, y);
	for (R ll i=19; ~i; i--)
		if (dep[f[x][i]]>=dep[y]) x=f[x][i];
	if (x==y) return x;
	for (R ll i=19; ~i; i--)
		if (f[x][i]!=f[y][i]) x=f[x][i], y=f[y][i];
	return f[x][0];
}

ll Q;
int main(){
	read(n); read(m); cnt=n;
	for (R ll i=1, x, y, z; i<=m; i++){
		read(x); read(y); read(z);
		edge[i]=node(x, y, z);
	}
	sort(edge+1, edge+m+1);
	dsu::init(n<<1);
	for (R ll i=1, x, y; i<=m; i++){
		x=edge[i].x, y=edge[i].y;
		x=dsu::getf(x); y=dsu::getf(y);
		if (x==y) continue;
		++cnt;
		v[cnt]=edge[i].z;
		dsu::f[x]=dsu::f[y]=cnt;
		add(cnt, x); add(cnt, y);
	}
	for (R ll i=1, x; i<=cnt; i++){
		x=dsu::getf(i);
		if (!dep[x]) dfs(x, 0);
	}
	read(Q);
	ll x, y, belx, bely;
	while(Q--){
		read(x); read(y);
		belx=dsu::getf(x), bely=dsu::getf(y);
		if (belx!=bely) puts("impossible");
		else writeln(v[lca(x, y)]);
	}
}
```


---

## 作者：ctq1999 (赞：0)

和[P1967 货车运输](https://www.luogu.com.cn/problem/P1967)类似。

## 题目简述

给定一个 $n$ 个点 $m$ 条边的无向边带权图，求两点的路径上的边权的最大值的最小值。

## 思路

注意图不保证联通。

因为是要求最大值的最小值，那么在保证多个联通分量内的点依然与其他点联通的情况下，去掉权值较大的边。这些边的权值对答案不会产生贡献。

那么去完边后，因为点与点必须还要联通，联通分量会变成多个树，点与点路径上边权的最大值，就是这个点对的答案。

时间复杂度 $O(m+n\log n)$。

## 实现

在一个联通分量中找到一个树的任意一个边权都尽可能小的，也就是树的边权之和要最小，那么最小生成树就可以解决。

最小生成树求解可以用 Kruskal，对于符合的边，直接在邻接表建边。

然后对于每个点对，用并查集判断一下是否在同一个联通分量中，不在的话就是直接 `impossible`，否则就用 LCA 就出路径上边权的最大值就可。

## 代码

```cpp
#include<bits/stdc++.h>

#define ll long long
#define y1 caibictq
#define P pair<int, int>
#define fi first
#define se second

using namespace std;

const int MAXN = 400010;
const int MAXM = 100010;
const int mod = 1e9 + 7;
const int INF = 0x3f3f3f3f;

int n, m, q, k;
int tot, tot1, cnt, ans;

int read() {
	int f = 1, s = 0;
	char ch = getchar();
	while ('0' > ch || ch > '9') {if (ch == '-') f = -1; ch = getchar();}
	while ('0' <= ch && ch <= '9') {s = (s << 1) + (s << 3) + ((int)ch ^ 48); ch = getchar();}
	return s * f;
}

int a[MAXN], head[MAXN];
int bel[MAXN], vis[MAXN];
int dep[MAXN], f[MAXN][50], mx[MAXN][50], lg[MAXN];

int find(int x) {
	while (x != bel[x]) x = bel[x] = bel[bel[x]];
	return x;
}

struct edge {
	int to, next, w;
}e[MAXN << 1];

struct edge1 {
	int u, v, w;
}e1[MAXN];

void add_edge(int x, int y, int w) {
	e[++tot].to = y;
	e[tot].w = w;
	e[tot].next = head[x];
	head[x] = tot;
	return;
}

bool cmp(edge1 x, edge1 y) {
	return x.w < y.w;
}

void Kruskal() {
	sort(e1 + 1, e1 + tot1 + 1, cmp);
	for (int i = 1; i <= tot1; i++) {
		int bel_u = find(e1[i].u);
		int bel_v = find(e1[i].v);
		if (bel_u == bel_v) continue;
		add_edge(e1[i].u, e1[i].v, e1[i].w);
		add_edge(e1[i].v, e1[i].u, e1[i].w);
		bel[bel_u] = bel_v;
		if (++cnt == n - 1) break;
	}
	return;
}

void dfs(int x, int fa) {
	vis[x] = 1;
	dep[x] = dep[fa] + 1; f[x][0] = fa;
	for (int i = 1; (1 << i) <= dep[x]; i++) {
		f[x][i] = f[f[x][i - 1]][i - 1];
		mx[x][i] = max(mx[x][i - 1], mx[f[x][i - 1]][i - 1]);
	}
	for (int i = head[x]; i; i = e[i].next) {
		int y = e[i].to;
		if (y == fa) continue;
		mx[y][0] = e[i].w;
		dfs(y, x);
	}
	return;
}

int LCA(int x, int y) {
	int res = -INF;
	if (dep[x] < dep[y]) swap(x, y);
	while (dep[x] > dep[y]) {
		res = max(res, mx[x][lg[dep[x] - dep[y]] - 1]);
		x = f[x][lg[dep[x] - dep[y]] - 1];
	}
	if (x == y) return res;
	for (int i = lg[dep[x]] - 1; i >= 0; i--) {
		if (f[x][i] == f[y][i]) continue;
		res = max(res, mx[x][i]);
		res = max(res, mx[y][i]);
		x = f[x][i];
		y = f[y][i];
	}
	return max(res, max(mx[x][0], mx[y][0]));
}

int main() {
	int T;
	scanf("%d%d", &n, &m);
	for (int i = 1, u, v, w; i <= m; i++) {
		scanf("%d%d%d", &u, &v, &w);
		if (u == v) continue;
		e1[++tot1].u = u; e1[tot1].v = v; e1[tot1].w = w;
	}
	for (int i = 1; i <= n; i++) {
		bel[i] = i;
		lg[i] = lg[i - 1] + ((1 << lg[i - 1]) == i);
	}
	Kruskal();
	memset(mx, -0x3f, sizeof(mx));
	for (int i = 1; i <= n; i++) {
		if (!vis[i]) dfs(i, 0);
	}
	scanf("%d", &q);
	for (int i = 1, x, y; i <= q; i++) {
		scanf("%d%d", &x, &y);
		if (find(bel[x]) != find(bel[y])) printf("impossible\n");
		else printf("%d\n", LCA(x, y));
	}
	return 0;
}
/*
6 6
1 2 5
1 3 2
2 3 11
2 4 6
3 4 4
5 6 3
5
2 3
1 4
1 2
5 1
5 6
*/

```

> 日拱一卒，功不唐捐。

---

## 作者：ueettttuj (赞：0)

[题目](https://www.luogu.org/problem/P2245)

**最小生成树+树链剖分**

这题可以先跑一个最小生成树，这样就能满足每条边的危险程度尽可能小。然后对于每一个询问，如果暴力枚举必然超时。所以可以把最小生成树树剖一遍，并用线段树维护最大值。然后对于每一个询问就可以更快的得出结果输出。注意图不一定联通，所以要建一个超级原点，并用并查集维护两点是否联通。

注意边权要转为点权

贴代码

```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,m,tot,cnt,num;
struct node{
	long long x,y,z;
};
node edge[500010],edge2[500010];
long long fa[100010],head[100010];
struct data{
	long long to,nex,val;
};
data EDGE[1000010];
struct dada{
	long long top,deep,id,fa,son,size,val;
};
dada treecut[1000100];
struct node2{
	long long mx;
};
node2 tree[4000100];
void add(long long x,long long y,long long z){
	EDGE[++tot].to=y;
	EDGE[tot].nex=head[x];
	EDGE[tot].val=z;
	head[x]=tot;
}
bool cmp(const node &q,const node &w){
	return q.z<w.z;
}
long long find(long long x){ //并查集 
	if(fa[x]!=x) fa[x]=find(fa[x]);
	return fa[x];
}
void krus(){   //求最小生成树 
	long long xx,yy;
	for(long long i=1;i<=m;i++){
		xx=find(edge[i].x);
		yy=find(edge[i].y);
		if(xx!=yy){
			fa[xx]=yy;
			add(edge[i].x,edge[i].y,edge[i].z);
			add(edge[i].y,edge[i].x,edge[i].z);
			edge2[++num].x=edge[i].x;
			edge2[num].y=edge[i].y;
			edge2[num].z=edge[i].z;
		}
	}
}
void pushup(long long rt,long long l,long long r){
	if(l!=r){
		tree[rt].mx=max(tree[rt*2].mx,tree[rt*2+1].mx);
	}
}
void build(long long rt,long long l,long long r){ //线段树建树 
	if(l==r){
		tree[rt].mx=treecut[l].val;
		return ;
	}
	long long mid=(l+r)/2;
	build(rt*2,l,mid);
	build(rt*2+1,mid+1,r);
	pushup(rt,l,r);
}
long long ask(long long rt,long long l,long long r,long long x,long long y){ //线段树查询 
	if(x<=l && y>=r){
		return tree[rt].mx;
	}
	long long mid=(l+r)/2;
	long long anss=-10000000000000;
	if(x<=mid) anss=max(anss,ask(rt*2,l,mid,x,y));
	if(y>mid) anss=max(anss,ask(rt*2+1,mid+1,r,x,y));
	return anss; 
}
void dfs1(long long rt,long long father,long long depp){ //树剖 
	treecut[rt].fa=father;
	treecut[rt].deep=depp;
	treecut[rt].size=1;
	long long maxson=-1;
	for(long long i=head[rt];i;i=EDGE[i].nex){
		long long y;
		y=EDGE[i].to;
		if(y==father) continue ;
		dfs1(y,rt,depp+1);
		treecut[rt].size+=treecut[y].size;
		if(treecut[y].size>maxson){
			maxson=treecut[y].size;
			treecut[rt].son=y;
		}
	}
}
void dfs2(long long rt,long long topp){
	treecut[rt].top=topp;
	treecut[rt].id=++cnt;
	if(treecut[rt].son==0) return ;
	dfs2(treecut[rt].son,topp);
	for(long long i=head[rt];i;i=EDGE[i].nex){
		long long y;
		y=EDGE[i].to;
		if(y==treecut[rt].fa || y==treecut[rt].son) continue ; 
		dfs2(y,y);
	}
}
long long update(long long x,long long y){
	long long anss=-1000000000000;
	while(treecut[x].top!=treecut[y].top){
		if(treecut[treecut[x].top].deep<treecut[treecut[y].top].deep) swap(x,y);
		anss=max(anss,ask(1,1,n+1,treecut[treecut[x].top].id,treecut[x].id));
		x=treecut[treecut[x].top].fa;
	}
	if(treecut[x].id>treecut[y].id) swap(x,y);
	anss=max(anss,ask(1,1,n+1,treecut[x].id+1,treecut[y].id));
	return anss;
}
int main(){
	scanf("%lld %lld",&n,&m);
	tot=1;
	for(long long i=1;i<=m;i++){
		scanf("%lld %lld %lld",&edge[i].x,&edge[i].y,&edge[i].z);
	}
	sort(edge+1,edge+m+1,cmp);
	for(long long i=1;i<=n;i++){
		fa[i]=i;
	}
	krus();  //求出最小生成树 
	for(long long i=1;i<=n;i++){
		if(fa[i]==i){
			add(0,i,0);
			add(i,0,0);
		}
	}
	dfs1(0,-1,1);
	dfs2(0,0);
	for(long long i=1;i<=num;i++){ //注意边权转点权 
		if(treecut[edge2[i].x].deep>treecut[edge2[i].y].deep){
			treecut[treecut[edge2[i].x].id].val=edge2[i].z;
		}
		else treecut[treecut[edge2[i].y].id].val=edge2[i].z;
	}
	build(1,1,n+1); //建树 
	long long q;
	scanf("%lld",&q);
	for(long long i=1;i<=q;i++){
		long long b,c;
		scanf("%lld %lld",&b,&c);
		if(find(b)!=find(c)) printf("impossible\n"); //判断是否联通 
		else{
			printf("%lld\n",update(b,c));
		}
	}
	return 0;
}
```
[双倍经验？？？！！！](https://www.luogu.org/problem/P1967)

---

## 作者：zhengrunzhe (赞：0)

提供用tarjan求lca法

思路可以参考我之前的题解

[P1967 货车运输](https://www.luogu.org/blog/van/solution-p1967)

P1967这道题查的是路径最小权值的最大值

那么这道题查的是路径最大权值的最小值

把快排cmp的大于改成小于就好了
```cpp
#include<cstdio>
#include<algorithm>
const int N=1000000,M=3000000;
bool f[2*N];
int n,m,que,from[N],cnt,i,fa[2*N],ans[N],k;
struct edge{int to,w,next;}e[M],q[N*2],te[M];
//这里其实偷懒了，其实这个是邻接表的结构，而e和te数组并不是真的邻接表 
//e代表读入的每一条边，to代表该边的一个节点，next代表另一个节点，w代表边权 
//te与e的结构一样，代表最大生成树中的每一条边
struct tree{int l,r,d;}t[N*2];
inline void read(int &x)
{
    short fh=1;x=0;char cc=getchar();
    while (cc>57||cc<48)fh=cc=='-'?-1:fh,cc=getchar();
    while (cc>=48&&cc<=57)x=x*10+cc-48,cc=getchar();
    x*=fh;
}
inline void add(int a,int b,int c)
{
    q[++cnt].next=from[a];
    q[cnt].to=b;
    q[cnt].w=c;
    from[a]=cnt;
}
inline bool cmp(const edge &e1,const edge &e2)
{
    return e1.w<e2.w;
}
int Find(int o)
{
    return fa[o]==o?o:fa[o]=Find(fa[o]);
}
inline void Union(int a,int b)
{
    int f1=Find(a),f2=Find(b);
    if (f1==f2)return;
    fa[f2]=f1;
}
inline void kruskal()  //最大生成树 
{
    for (int i=1;i<=m;i++)
    {
        int u=e[i].to,v=e[i].next;
        if (Find(u)!=Find(v))
            Union(u,v),te[++k]=e[i]; //将该条边加到最大生成树中 
    }
}
inline void build()
{
    for (int i=1;i<=k;i++) //在最大生成树的每一条边里找 
    {
        //通过并查集实现，并查集的顶端即子树的根 
        int u=Find(te[i].to),v=Find(te[i].next);
        t[n+i].l=u;t[n+i].r=v;
        //因为t[n+i]的节点肯定是闲置的，所以我们把它当作一个存权值的节点，代表从它的左子树中的每一个节点到右子树中的每一个节点的答案 
        t[n+i].d=te[i].w;
        Union(n+i,u);Union(n+i,v);
    }
}
void tarjan(int p) //求两点的LCA 
{
    f[p]=1;
    for (int i=from[p];i;i=q[i].next)
    {
        int v=q[i].to;
        if (f[v])ans[q[i].w]=t[Find(v)].d;
    }
    int ls=t[p].l,rs=t[p].r;
    if (ls)tarjan(ls),Union(p,ls);
    if (rs)tarjan(rs),Union(p,rs);
}
int main()
{
    read(n);read(m);
    for (int i=1;i<=m;i++)
        read(e[i].to),read(e[i].next),read(e[i].w);
    read(que);
    for (int i=1;i<=que;i++)
    {
        int x,y;
        read(x);read(y);
        add(x,y,i),add(y,x,i);
    }
    std::sort(e+1,e+m+1,cmp);
    for (int i=1;i<2*n;i++)fa[i]=i;kruskal();
    for (int i=1;i<2*n;i++)fa[i]=i;build();
    for (int i=1;i<2*n;i++)fa[i]=i;tarjan(n+k);
    for (int i=1;i<=que;i++)
    	if (ans[i])printf("%d\n",ans[i]);
        else puts("impossible");
    return 0;
}
```

---

## 作者：斯德哥尔摩 (赞：0)

楼下 倍增、树剖 什么的都有，这里给一种 LCT 的做法。

首先，你要知道LCT是什么——[P3690 【模板】Link Cut Tree （动态树）](https://www.luogu.org/problemnew/show/P3690)

然后，我会告诉你，凡是 树剖、LCA 能做的，LCT 都能做！

LCT是个好东西啊！不用考虑森林（不止一颗树）的情况！

首先一个最小生成树没得说。。。

但是，这题要求的不是点权，而是边权，怎么办呢？

我们可以想到，添加一条 u->v 的边，权值为w，那么就相当于：

```cpp
link(u,id);link(v,id);//id是边的序号
value[id]=w;
```

于是这个问题就被愉快地解决了。

注：LCT中可以保存边的序号，也可以直接保存边权（暂时还没试过），我是保存了边的序号。

附代码：
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#define MAXN 300010
using namespace std;
int n,m,q;
int w[MAXN<<1],fa[MAXN];//因为有边的序号，所以开两倍！
int top,stack[MAXN<<1];
struct node1{//Link-Cut-Tree，本蒟蒻习惯用结构体
	int f,flag,son[2];
	int v;
}a[MAXN<<1];
struct node2{
	int u,v,w;
}b[MAXN];
inline int read(){//读优
	int date=0,w=1;char c=0;
	while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
	while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}
	return date*w;
}
bool cmp(const node2 &x,const node2 &y){
	return x.w<y.w;
}
inline bool isroot(int rt){//判根
	return a[a[rt].f].son[0]!=rt&&a[a[rt].f].son[1]!=rt;
}
inline void pushup(int rt){//上传
	if(!rt)return;
	a[rt].v=rt;
	if(w[a[rt].v]<w[a[a[rt].son[0]].v])a[rt].v=a[a[rt].son[0]].v;
	if(w[a[rt].v]<w[a[a[rt].son[1]].v])a[rt].v=a[a[rt].son[1]].v;
}
inline void pushdown(int rt){//下传
	if(!rt||!a[rt].flag)return;
	a[a[rt].son[0]].flag^=1;a[a[rt].son[1]].flag^=1;a[rt].flag^=1;//当初这里把1敲成了0，然后调了一下午（吃枣药丸。。。）
	swap(a[rt].son[0],a[rt].son[1]);
}
inline void turn(int rt){//旋转
	int x=a[rt].f,y=a[x].f,k=a[x].son[0]==rt?1:0;
	if(!isroot(x)){
		if(a[y].son[0]==x)a[y].son[0]=rt;
		else a[y].son[1]=rt;
	}
	a[rt].f=y;a[x].f=rt;a[a[rt].son[k]].f=x;
	a[x].son[k^1]=a[rt].son[k];a[rt].son[k]=x;
	pushup(x);pushup(rt);
}
void splay(int rt){//伸展
	top=0;
	stack[++top]=rt;//最好不要在函数内定义，可能会RE。
	for(int i=rt;!isroot(i);i=a[i].f)stack[++top]=a[i].f;
	while(top)pushdown(stack[top--]);
	while(!isroot(rt)){
		int x=a[rt].f,y=a[x].f;
		if(!isroot(x)){
			if((a[y].son[0]==x)^(a[x].son[0]==rt))turn(rt);
			else turn(x);
		}
		turn(rt);
	}
}
void access(int rt){//打重链
	for(int i=0;rt;i=rt,rt=a[rt].f){
		splay(rt);
		a[rt].son[1]=i;
		pushup(rt);
	}
}
inline void makeroot(int rt){access(rt);splay(rt);a[rt].flag^=1;}//换根
inline void split(int x,int y){makeroot(x);access(y);splay(y);}//取出重链
inline void link(int x,int y){makeroot(x);a[x].f=y;}//连边
int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}
void uniun(int x,int y){x=find(x);y=find(y);if(x!=y)fa[y]=x;}//并查集
void kruskal(){//最小生成树
	int s=0;
	for(int i=1;i<=n;i++){//初始化
		fa[i]=i;
		a[i].v=i;
		w[i]=0;
	}
	sort(b+1,b+m+1,cmp);//排序
	for(int i=1;i<=m;i++){//将边权存入LCT
		w[i+n]=b[i].w;
		a[i+n].v=i+n;
	}
	for(int i=1;i<=m&&s<n-1;i++)
	if(find(b[i].u)!=find(b[i].v)){//生成树
		uniun(b[i].u,b[i].v);
		link(b[i].u,i+n);
		link(b[i].v,i+n);//连边
		s++;
	}
}
void work(){//工作
	int x,y;
	q=read();
	while(q--){
		x=read();y=read();
		if(find(x)!=find(y)){//记得这句
			printf("impossible\n");
			continue;
		}
		split(x,y);
		printf("%d\n",w[a[y].v]);//直接输出
	}
}
void init(){//读入+预处理
	n=read();m=read();
	for(int i=1;i<=m;i++){b[i].u=read();b[i].v=read();b[i].w=read();}
	kruskal();
}
int main(){//主函数So easy！
	init();
	work();
	return 0;
}

```

---

## 作者：何俞均 (赞：0)

看到没有树链剖分的题解，于是赶紧来一发。 如果还不会会树链剖分，可以在[这里](https://www.luogu.org/problemnew/show/3384)学一下，打打板子。

可能因为这题有多个联通块，用树剖做起来比较麻烦(建n颗线段树)所以用树剖的人很少，但是这个麻烦还是可以解决的：

只要建一个虚点(这里使用0号节点)，将所有联通块连起来即可，再从0号节点dfs就只用dfs一遍了，然后注意一些细节(在代码中指出)，这题就基本上没什么问题了！

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<string>
#include<map>
#include<set>
#include<vector>
#include<queue>
#include<stack>
#include<algorithm>
#define RG register
#define file(x) freopen(x".in","r",stdin);freopen(x".out","w",stdout);
using namespace std;

inline int gi(){
    int data=0,w=1;
    char ch=0;
    while(ch!='-'&&(ch>'9'||ch<'0')) ch=getchar();
    if(ch=='-') w=-1,ch=getchar();
    while(ch>='0'&&ch<='9') data=data*10+ch-'0',ch=getchar();
    return data*w;
}
#define N 100010
int n,m,fa[N],p[N],a[N];
struct Edge{int u,v,w;}e[N*3];//存最小生成树的边

struct Node{int to,cost;};
vector<Node> G[N];//本人习惯用vector存图
inline void Add_Edge(int u,int v,int w){
    G[u].push_back((Node){v,w});
    G[v].push_back((Node){u,w});
}

//并差集判是否在一个集合+最小生成树
int findSet(int x){return p[x]==x?x:p[x]=findSet(p[x]);}
inline void Unite(int u,int v){p[findSet(u)]=p[findSet(v)];}
inline bool same(int u,int v){return findSet(u)==findSet(v);}
inline bool cmp(const Edge &a,const Edge &b){return a.w<b.w;}
inline void kruskal(){
    sort(&e[1],&e[m+1],cmp);
    for(RG int i=1;i<=m;i++){
        if(same(e[i].v,e[i].u)) continue;
        Add_Edge(e[i].v,e[i].u,e[i].w);
        Unite(e[i].v,e[i].u);
    }
}
//以下是树链剖分
int top[N],dep[N],size[N],son[N],L[N],dfn[N],tim=-1;//细节1：tim赋为-1(因为从0开始dfs)
#define cur G[x][i]
void dfs(int x,int f){//把边权化为点权并求出fa[x]
    fa[x]=f;
    for(RG int i=0;i<G[x].size();i++){
        if(cur.to==fa[x]) continue;
        a[cur.to]=cur.cost;
        dfs(cur.to,x);
    }
}
void dfs1(int x){
    dep[x]=dep[fa[x]]+1;
    size[x]=1;
    son[x]=n+1;//细节2：重儿子是赋为n+1（0是根节点）
    for(RG int i=0;i<G[x].size();i++){
        if(cur.to==fa[x]) continue;
        dfs1(cur.to);
        size[x]+=size[cur.to];
        if(size[son[x]]<size[cur.to]) son[x]=cur.to;
    }
}
void dfs2(int x,int tp){
    top[x]=tp;
    tim++;
    dfn[tim]=x;L[x]=tim;
    if(son[x]!=n+1) dfs2(son[x],tp);
    for(RG int i=0;i<G[x].size();i++){
        if(cur.to==fa[x]||cur.to==son[x]) continue;
             dfs2(cur.to,cur.to);
    }
}
//线段树维护路径最小
class SegMent_Tree{
    #define lson ( o<<1)
    #define rson ((o<<1)|1)
    public:
    int val[N<<2];
    void build(int o,int l,int r){
        if(l==r){
            val[o]=a[dfn[l]];
            return ;
        }
        int mid=(l+r)>>1;
        build(lson,l,mid);
        build(rson,mid+1,r);
        pushup(o);
    }
    int query(int o,int ql,int qr,int l,int r){
        if(l>qr||r<ql) return -99999999;
        if(ql<=l&&r<=qr) return val[o];
        int mid=(l+r)>>1;
        return max(query(lson,ql,qr,l,mid),query(rson,ql,qr,mid+1,r));
    }
    inline int Ask(int u,int v){
        int ret=-99999999;
        while(top[u]!=top[v]){
            if(dep[top[u]]<dep[top[v]]) swap(u,v);
            ret=max(ret,query(1,L[top[u]],L[u],1,n));
            u=fa[top[u]];
        }
        if(dep[u]<dep[v]) swap(u,v);
        return max(ret,query(1,L[v]+1,L[u],1,n));//细节3：注意是L[v]+1,自己想一想是什么原因
    }
    private:
    inline void pushup(int o){val[o]=max(val[lson],val[rson]);}
}t;

int main(){
    n=gi();m=gi();
    for(RG int i=1;i<=m;i++) e[i].u=gi(),e[i].v=gi(),e[i].w=gi();
    for(RG int i=1;i<=n;i++) p[i]=i;//初始化并查集
    kruskal();//生成树
    memset(fa,-1,sizeof(fa));//把fa数组初始化成-1，因为建的虚点为0
    fa[0]=0;//细节4：fa[0]=0,要不然会RE
    for(RG int i=1;i<=n;i++) if(fa[i]==-1) dfs(i,0);
    for(RG int i=1;i<=n;i++) if(fa[i]==0) Add_Edge(i,0,0);
    dfs1(0);dfs2(0,0);
    RG int T=gi();
    t.build(1,1,n);
    while(T--){
        int u=gi(),v=gi();
        if(!same(u,v)) puts("impossible");
        else printf("%d\n",t.Ask(u,v));
    }
    return 0;
}
```

---


# 课程

## 题目描述

有 $n$ 个人与 $m$ 个教室。其中，可以在第 $i$ 个教室上课的学生有 $k_i$ 个，编号分别为 $p_{i,j}$。每个学生都有至少一个教室**可以**上课，并且每个学生**只能**在一个教室上课。

现在询问是否存在一种方案，使得每个教室里至少有一名学生。若可以满足要求，输出 `YES`，否则输出 `NO`。

## 说明/提示

$n\leq 2\times 10^4,m\leq 2\times 10^4,T\leq 10$。

## 样例 #1

### 输入

```
2
3 3
3 1 2 3
2 1 2
1 1
3 3
2 1 3
2 1 3
1 1```

### 输出

```
YES
NO```

# 题解

## 作者：欧鹰 (赞：12)

_第三篇题解 ，心态有点稳啦。正如就如上一篇题解所说，我欧鹰就是跳下去，也绝对不会给我博客打广告_
[真香](https://www.luogu.org/blog/174026/)

#### 下面进入这道题的题解

------------

说实话，第一次看到这题。啊！一道蓝题，吓得我加了收藏，就退了出来。~~做了道紫题~~，现在闲着无聊就又回来看这题，看了题，又看了数据，这道题真是符合他的标签，水一样颜色的题，简称为水题。

这个题其实就是，从最少人的课程开始遍历，依次递增，在再本课程的人里边选一个人，他可以选的课程最多，并他没有选其他科，就选这个人。

### 明明标签是图论，但我却写得像贪心，所以欢迎大家HACK！！！！！

# 下面是代码（代码就不解释啦，不懂得可以私聊，顺便点个赞，谢谢。）

```cpp
#include<bits/stdc++.h>

using namespace std;

int t,p,n,cnt,vis[100500],head[400500],out[100500],flag;

struct nod{
	int u,v;
}a[100500];

void add(int u,int v)
{
	a[++cnt].u=head[u];
	
	head[u]=cnt;
	
	a[cnt].v=v;
}

int read(){
    char ch=getchar(); int f=1,a=0;
    while(!isdigit(ch)){ if(ch=='-') f=-1; ch=getchar(); }
    while(isdigit(ch)){ a=a*10+ch-'0';     ch=getchar(); }
    return a*f;
}

struct node{
	int cla,num;
}in[100500];

bool cmp(node a,node b)
{
	return a.num<b.num;
}

int main()
{
	t=read();
	
	while(t--)
	{
		memset(in,0,sizeof(in));
		
		memset(out,0,sizeof(out));
		
		memset(head,0,sizeof(head));
		
		memset(vis,0,sizeof(vis));
		
		memset(a,0,sizeof(a));
		
		cnt=flag=0;
		
		p=read();
		
		n=read();
		
		for(int i=1;i<=p;i++)
		{
			//int num;
			
			in[i].num=read();
			
			int numm=in[i].num;
			
			in[i].cla=i;
			
			while(numm--)
			{
				int y;
				
				y=read();
				
				add(i,y+p);
				
				out[y+p]++;
			}
		}
		
		sort(in+1,in+1+p,cmp);
		
		for(int i=1;i<=p;i++)
		{
			int maxv=21475622,vv=-1;
			
			for(int j=head[in[i].cla];j;j=a[j].u)
			{
				int v=a[j].v;
				
				if(out[v]<maxv&&vis[v]!=1)
				{
					maxv=out[v];
					
					vv=v;
				}
			}
			
			if(vv==-1)
			{
				cout<<"NO"<<'\n';
				
				flag=1;
				
				break;
			}
			
			vis[vv]=1;
		}
		
		if(flag==0) cout<<"YES"<<'\n';
	}
	
	return 0;
	
}

```




---

## 作者：山雨木子 (赞：7)

# 爆搜

思路：
对于每个教室，选取她的学生中的一个去（这样就符合要求了）

然后考虑后来的教室，每个教室只考虑她的学生中没有被选过的，然后选择即可....

一个显而易见的优化：

将教室按照人数**从小到大排序**   这样会大大减少搜索树的规模

这样就能过了这道题~

时间还算比较优秀 （22ms）

上代码
```cpp
//优先满足人数少的
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn = 2e4+5;
struct room{int cnt,num[maxn]; };
room a[105];
int n,p,T,vis[maxn];
int read(){
	char ch=getchar(); int f=1,a=0;
	while(!isdigit(ch)){ if(ch=='-') f=-1; ch=getchar(); }
	while(isdigit(ch)){ a=a*10+ch-'0';     ch=getchar(); }
	return a*f;
}
int cmp(const room & a,const room & b){
	return a.cnt<b.cnt;
}
bool dfs(int now ){
	if(now==p+1) return true;
	bool flag=false; 
	for(int i=1;i<=a[now].cnt;i++){
		if(!vis[a[now].num[i]]){
			vis[a[now].num[i]]=1;
			if(dfs(now+1)) {
				flag=true;
				break;
			}
			vis[a[now].num[i]]=0;
		}
	}
	return flag;
}
int main(){
	T=read();
	while(T--){
	    p=read(); n=read();
		memset(vis,0,sizeof(vis));
		for(int i=1;i<=p;i++){
			a[i].cnt=read();
			for(int j=1;j<=a[i].cnt;j++)
				a[i].num[j]=read();
 		}
		sort(a+1,a+p+1,cmp);
		bool ok=false;
		for(int i=1;i<=a[1].cnt;i++){
			vis[a[1].num[i]]=1;
			if(dfs(2)){
				ok=true;
				break;
			}
			vis[a[1].num[i]]=0;
		}
		if(ok) cout<<"YES"<<endl;
		else cout<<"NO"<<endl;
	}
}
```

---

## 作者：xkcdjerry (赞：3)

看到题解区只有一篇暴力题解还是 2018 年的，蒟蒻决定写一下自己的做法：  

当时看到山雨木子的代码时最困惑的是为什么 `return true;` 之前不清空 `vis[a[now].num[i]]`，后面想了很久才知道 `return true;` 时已经处理完毕并找到答案了，所以 `vis` 长什么样子已经不用管了。  

但是就像可以用 `goto` 而不是每层特判一个 `flag` 以从多层嵌套循环中跳出一样；也可以用 `longjmp` 来从多层嵌套函数中快速跳出，此外两者都有着减少逻辑和加速代码的作用。  
本人实测不使用快读时与加快读的暴力题解速度差不多（快出 7ms）  

带注释代码如下：

```c++
#include <cstdio>
#include <algorithm>
#include <csetjmp> //包含 jmp_buf,longjmp,setjmp
#define N 20010

//类似goto中的标签，但是以必须手动初始化为代价换来可以在函数间跳转
jmp_buf buf;

using std::sort;

//vis[i]=学生i是否已被占用
bool vis[N];

//为了加速sort单独分离出位置，sort的时候只会交换两个整数
//而不是（在某些低效的实现上）整个数组
struct room
{
    int i,k;
    bool operator<(room b) const{return k<b.k;}
}a[N];

int p[N][N];
int m,n;

void dfs(int o)
{
    //如果成功了跳转回setbuf的位置并令其返回1
    if(o==m) longjmp(buf,1);
    //正常处理
    for(int i=0;i<a[o].k;i++)
    {
        int t=p[a[o].i][i];
        if(!vis[t])
        {
            vis[t]=true;
            dfs(o+1);
            vis[t]=false;
        }
    }
}
void once()
{
    scanf("%d%d",&m,&n);
    for(int i=0;i<m;i++)
    {
        int k;
        scanf("%d",&k);
        for(int j=0;j<k;j++) scanf("%d",p[i]+j);
        a[i].i=i,a[i].k=k;
    }
    
    //sort一下优先处理能去的学生少的课
    sort(a,a+m);
    
    //多组数据所以记得清空vis
    for(int i=1;i<=n;i++) vis[i]=0;
    
    //如果第一次执行（即设置buf）返回0，否则返回longjmp的第二个参数
    if(!setjmp(buf))
    {
        dfs(0);
        //如果执行了longjmp一定不会返回此处
        //（会跳到setjmp然后进入if分支）
        puts("NO");
    }
    else
        puts("YES");
}

//多组数据板子，不用解释
int main()
{
    int t;
    scanf("%d",&t);
    while(t--) once();
    return 0;
}
```



---

## 作者：Mr_think (赞：3)

## [P2417 课程](https://www.luogu.com.cn/problem/P2417)
## 题目大意：
有 $m$ 个教室，$n$ 个学生，存在一些关系，问是否所有学生都可以上课。
## solution:
看到这种两个集合中的点有关系的题果断想到二分图。
样例图：
![](https://cdn.luogu.com.cn/upload/image_hosting/jcae2xcy.png)

然后我们求出当前二分图的最大匹配，若最大匹配数等于教室数，就满足题意。

## 细节处理：
- 邻接表数组要开足够！
- 多组数据别忘了初始化。

看到这的同学可以自己去写代码了

[code](https://www.luogu.com.cn/paste/grnfsg86)

### End

---

## 作者：清远学会 (赞：3)

# 简单的二分图
### 但是我用的是网络流（EK算法）；
## 简单讲讲建图：
	1，设源点s和汇点t，为使编号不冲突，不妨设s = 0，t = p+n+1；
	2，s向学生连边，流量为1；因为每个学生只会走向一个教室（毕竟不会分身）；
    3，在学生与教室连边，流量不为0即可，表示这个学生可以去这个教室上课；备注下，编号不可冲突，所以在教室编号加上个n即可；
    4，将教室与t连边，流量为1；

### 在此基础上跑最大流，只要最大流为教室数，表明教室到t跑满，符合题意；
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<queue>
#include<cstring>
#define N 800500
using namespace std;

int T,n,m;
int head[N],cnt;
struct node {
	int from,nxt,to,dis;
}e[N];
int fa[N],low[N];
int s,t;

inline void cp(int u,int v,int w) {
	cnt ++;
	e[cnt].to = v;
	e[cnt].dis = w;
	e[cnt].from = u;
	e[cnt].nxt = head[u];
	head[u] = cnt;
}

queue<int> q;
inline bool BFS() {
	while(!q.empty()) q.pop();
	memset(fa,0,sizeof(fa));
	memset(low,0,sizeof(low));
	low[s] = 999999999,fa[s] = 1;
	q.push(s);
	while(!q.empty()) {
		int u = q.front(); q.pop();
		if(u == t) return true;
		for(int i = head[u];i;i = e[i].nxt) {
			int v = e[i].to;
			if(!fa[v] && e[i].dis) {
				fa[v] = i;
				low[v] = min(low[u],e[i].dis);
				q.push(v);
			}
		}
	}
	return false;
}

inline int EK() {
	int res = 0;
	while(BFS()) {
		for(int i = t;i != s;i = e[fa[i]].from) {
			int k = fa[i];
			e[k].dis -= low[t];
			e[k ^ 1].dis += low[t];
		}
		res += low[t];
	}
	return res == n;
}

inline void Work() {
	memset(head,0,sizeof(head)); cnt = 1;
	scanf("%d%d",&n,&m);  
	s = 0; t = n + m + 1;
	for(int i = 1;i <= m;i ++) 
		cp(s,i,1),cp(i,s,0);
	for(int i = 1;i <= n;i ++) {
		int opt; scanf("%d",&opt);
		for(int j = 1;j <= opt;j ++) {
			int u; scanf("%d",&u);
			cp(u,i + m,1); cp(i + m,u,0);
		}
	}
	for(int i = 1;i <= n;i ++) 
		cp(i + m,t,1),cp(t,i + m,0);
	if(EK()) printf("YES\n");
	else printf("NO\n");
}

int main() {
	scanf("%d",&T);
	while(T --) Work();
	return 0;
}
```
### 谢谢

---

## 作者：PiCaHor (赞：3)

这是一个坑爹的题，忘了要读完每一组，调了3天，stl的联系，空间非常小 QAQ

-----------------------------------------------------------分割线-------------------------------------------------------------------------------------

就是匈牙利算法的最大匹配

网络流也可以呀






```cpp
#include <bits/stdc++.h>
using namespace std;
int m,n,x,p,y,ans,T;
vector <int> v[300];
int _link[20100];
bool vis[20001];
bool find(int x)
{
  if(x==0) return true;
  for(int i=0; i<v[x].size(); i++)
  {
    if(!vis[v[x][i]])
    {
      vis[v[x][i]]=1;
      if(_link[v[x][i]]==0||find(_link[v[x][i]]))
      {
        _link[v[x][i]]=x;
        return true;
      }
    }
  }
  return false;
}
int main()
{
  scanf("%d",&T);
  while(T--)
  {
    memset(_link,0,sizeof(_link));
    memset(v,0,sizeof(v));
    scanf("%d%d",&p,&n);
    for(int i=1; i<=p; i++)
    {
      scanf("%d",&m);
      for(int j=1; j<=m; j++)
      {
        scanf("%d",&y);
        v[i].push_back(y);
      }
    } 
    if(p>n)
    {
      printf("NO\n");
      continue ;
    }
    ans=0;
    for(int i=1; i<=p; i++)
    {
      memset(vis,0,sizeof(vis));
      if(find(i)) ans++;
    }
    if(ans==p)
      printf("YES\n");
    else
      printf("NO\n");
  }
  return 0;
}
```

---

## 作者：Steinway (赞：1)

好像用邻接表存的且用数组的就只有第一位dalao了吧..  
  
不过好像反应是错误的代码..  
  
那我这里就重新发一遍A过了的吧
  
很裸的二分图最大图匹配 (dalao们都说这是很裸的网络流

（其实是下面dalao都写得很详细了 我只是补充一下）  

（因为我觉得memset比for更快点 所以就改成memset了..求dalao勿喷）  

（个人认为写的代码 可读性还是比较高的...）

```
//#define fre yes

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;

const int maxn = 20010 * 2;
int curch[maxn];
int head[maxn];
int ver[maxn];
int to[maxn];

bool Vis[maxn];

int n,m,k,tot,ans;

//毒瘤快读
template<typename T>inline void read(T&x)
{
    x = 0;char c;int lenp = 1;
    do { c = getchar();if(c == '-') lenp = -1; } while(!isdigit(c));
    do { x = x * 10 + c - '0';c = getchar(); } while(isdigit(c));
    x *= lenp;
}

//存图
void addedge(int x,int y)
{
    ver[tot] = y;
    to[tot] = head[x];
    head[x] = tot++;
}

//匈牙利算法
bool can(int x)
{
    for (int i=head[x];~i;i=to[i])
    {
        int y = ver[i];
        if(!Vis[y])
        {
            Vis[y] = 1;
            if(!curch[y]||can(curch[y]))
            {
                curch[y] = x;
                return 1;
            }
        } } return 0;
}

int main()
{
    read(k);
    while(k--)
    {
    	//感觉memset比for快 就全部换成memset了
        // for (int i=0;i<maxn;i++) { curch[i] = 0;head[i] = -1;ver[i] = 0;to[i] = 0; }
        memset(curch,0,sizeof(curch));
        memset(head,-1,sizeof(head));
        memset(ver,0,sizeof(ver));
        memset(to,0,sizeof(to));
        ans = 0;tot = 0;

        read(n);read(m);
        for (int i=1;i<=n;i++)
        {
            int x;
            read(x);
            for (int j=1;j<=x;j++)
            {
                int y;
                read(y);
                addedge(i,y);
            }
        } 
        
        //这个要放到后面..（因为这个我挂了一次）
        if(n > m)
        {
            puts("NO");
            continue;
        }
        
        for (int i=1;i<=n;i++)
        {
            memset(Vis,false,sizeof(Vis));
            if(can(i)) ans++;
        } if(ans == n) puts("YES");
        else puts("NO");
    } return 0;
} //Over
```

---

## 作者：斯德哥尔摩 (赞：1)

这是一道经典的二分图最大匹配的裸题。。。

匈牙利大法好。。。

然而一开始挂了不计 n (n>=10) 次，对拍了半小时，读入优化的锅。。。

有毒。。。

附代码：

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#define MAXN 110
#define MAXM 20010
using namespace std;
int t,n,p,ans;
int f[MAXM],a[MAXN][MAXM];//匹配数组 与 路径数组
bool vis[MAXM];//是否匹配标记
bool find(int x){//寻找
     for(int i=1;i<=n;i++){//枚举所有学生
             if(!vis[i]&&a[x][i]){//若有兴趣，且未匹配
                                  vis[i]=true;//标记
                                  if(f[i]==-1||find(f[i])){//若未匹配 或 能腾出一个空位
                                                           f[i]=x;//修改
                                                           return true;
                                                           }
                                  }
             }
     return false;
}
int main(){
    int x,y;
    scanf("%d",&t);
    while(t--){
               memset(a,0,sizeof(a));
               memset(f,-1,sizeof(f));
               memset(vis,false,sizeof(vis));
               scanf("%d%d",&p,&n);//记住，读入优化有毒。。。
               if(p>n){//若 课程数 多于 学生数 ，一定不能全匹配
                       printf("NO\n");
                       continue;
                       }
               for(int i=1;i<=p;i++){//对 每个课程 与 每个学生 建立关系
                       scanf("%d",&x);
                       for(int j=1;j<=x;j++){
                               scanf("%d",&y);
                               a[i][y]=1;
                               }
                       }
               ans=0;
               for(int i=1;i<=p;i++){
                       memset(vis,false,sizeof(vis));
                       if(find(i))
                       ans++;//匹配计数
                       }
               if(ans==p)printf("YES\n");
               else printf("NO\n");
               }
    return 0;
}

```

---

## 作者：happybob (赞：0)

考虑二分图匹配。

对每一个教室和这个教室可以上课的学生连边，显然这是一个二分图，左部是教室，右部是学生。求一下最大匹配 $x$，若 $x= m$，即 $m$ 个教室都可以有学生，那么答案为 `YES`，不然答案为 `NO`。

代码：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <vector>
using namespace std;

const int N = 5e4 + 5;

int match[N];
bool f[N];
vector<int> G[N];

int t, n, m;

int find(int u)
{
	for (int i = 0; i < G[u].size(); i++)
	{
		int j = G[u][i];
		if (!f[j])
		{
			f[j] = true;
			if (!match[j] || find(match[j]))
			{
				match[j] = u;
				return 1;
			}
		}
	}
	return 0;
}

int main()
{
	scanf("%d", &t);
	while (t--)
	{
		scanf("%d%d", &m, &n);
		for (int i = 1; i <= n; i++) G[i].clear();
		for (int i = 1; i <= n; i++) match[i] = f[i] = 0;
		for (int i = 1; i <= m; i++)
		{
			int k;
			scanf("%d", &k);
			for (int j = 1; j <= k; j++)
			{
				int x;
				scanf("%d", &x);
				G[i].push_back(x);
			}
		}
		if (m > n)
		{
			puts("NO");
			continue;
		}
		int res = 0;
		for (int i = 1; i <= m; i++)
		{
			memset(f, 0, sizeof f);
			res += find(i);
		}
		if (res == m) printf("YES\n");
		else printf("NO\n");
	}
	return 0;
}
```

---

## 作者：Link_Space (赞：0)

看到大佬们都打什么二分图，然而我这个菜鸡并没有学过，所以只能打一个爆搜，但是居然惊讶地发现能过，而且非常快，~~看来这五个点数据非常水~~；

爆搜的思路非常简单，就是挨个挨个地判断每个教室里面的每个学生是否已经被前面的教室选过，只要没被选过就选这个学生，然后搜索后面的教室，只要有一种方法可行即可，代码也和思路一样十分简单，以下是本蒟蒻的代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<vector>
using namespace std;
struct node{
    vector<int> peo;//此教室的学生编号集合
    int cnt;//这个教室能进去的人数
}room[200005];//用结构体存方便排序
bool vis[200005];
bool cmp(node a,node b)
{
    return a.cnt < b.cnt;
}
int m, n;
bool dfs(int now)
{
    if(now==m+1)
        return true;//搜索完了所有的教室即代表有一种方案可行
    bool flag = false;
    for (int i = 0; i < room[now].cnt;i++)
    {
        if(vis[room[now].peo[i]] == 0)
        {
            vis[room[now].peo[i]] = 1;//只要没被搜过就去搜
            if(dfs(now + 1))
            {
                flag = true;
                break;
            }//有一种方案可行即可
            vis[room[now].peo[i]] = 0;//回溯
        }
    }
    return flag;
}
int main()
{
    int t;
    scanf("%d", &t);
    while(t--)
    {
        memset(vis, 0, sizeof vis);
        scanf("%d%d", &m, &n);
        for (int i = 1; i <= m;i++)
        {
            room[i].peo.clear();
            room[i].cnt = 0;
        }
        for (int i = 1; i <= m; i++)
        {
            scanf("%d", &room[i].cnt);
            for (int j = 1; j <= room[i].cnt; j++)
            {
                int a;
                scanf("%d", &a);
                room[i].peo.push_back(a);
            }
        }
        sort(room + 1, room + m + 1, cmp);//将教室从人数从小到大排序，可以优化搜索效率
        if(dfs(1))
            printf("YES\n");
        else
            printf("NO\n");
    }
}
```


---

## 作者：abandentsky (赞：0)

题意：不说了，自己看；
思路：二分图最大匹配。
注意数组要开20w以上，不然必错两个点。，其他的没的说，套模板。
```c
#include<bits/stdc++.h>
#pragma GCC optimize(2)
#define MAXN 4105
#define maxnode 1000005
#define sigma_size 26
#define md 12345678
#define INF 0x3f3f3f3f
#define pii pair<int,int>
using namespace std;

int T,p,n;
vector<int>G[MAXN];
bool vis[MAXN*5];
int Left[MAXN*5];

bool match(int u)
{
    for(int i=0;i<G[u].size();i++)
    {
        int v=G[u][i];
        if(vis[v])
            continue;
        vis[v]=true;
        if(Left[v]==-1||match(Left[v]))
        {
            Left[v]=u;
            return true;
        }
    }
    return false;
}

bool solve()
{
    memset(Left,-1,sizeof(Left));
    for(int i=1;i<=p;i++)
    {
        memset(vis,0,sizeof(vis));
        if(!match(i))
           return false;
    }
    return true;
}

void init(int n)
{
    for(int i=0;i<=n;i++)
        G[i].clear();
}

int main()
{
    scanf("%d",&T);
    while(T--)
    {
        scanf("%d %d",&p,&n);
        init(n);
        int m;
        for(int i=1;i<=p;i++)
        {
            scanf("%d",&m);
            for(int j=1;j<=m;j++)
            {
                int tg;
                scanf("%d",&tg);
                G[i].push_back(tg+p+2);                    //将学生的编号映射到+p
            }
        }
        if(solve())
            printf("YES\n");
        else
            printf("NO\n");
    }
    return 0;
}

```


---

## 作者：归山_ (赞：0)

这道题我可能会是最暴力的题解了~

对了这个题解并不是正解哦~

------------
## 思路
	首先我们考虑每课程都要有人去并且输出很水

	那么我们为什么不直接从全局来看呢
    
    然后我就有了这样的想法

	因为每个人可以选择很多课程

	所以我们读入后把学生的编号用一个数组记下来

	最后直接判断是否满足每个课堂都能有学生去
    
	没错
    
###     这是个贪心
	
	可能我描述的比较难理解但是代码真的很简单
    
    最后要注意的是YES，NO不要打错了
    
    我就是因为这个每次都是20分，我还以为我打错了。。。
	
   ~~虽然真的错了~~


------------
## 代码
```
#include<iostream>
#include<cmath>
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;

const int maxn=100010;
int t;
int p,n; 
int sum;
int a[maxn];

int main(){
	cin>>t;
	while(t--){
		memset(a,0,sizeof(a));
		sum=0;
		cin>>p>>n;
		int x;
		int num;
		for(int i=1;i<=p;i++){
			cin>>x;
			for(int j=1;j<=x;j++){
				cin>>num;
				a[num]++;
			}
		}
		for(int i=1;i<=n;i++) if(a[i]!=0) sum++;
		if(sum<p) cout<<"NO"<<'\n';
		else cout<<"YES"<<'\n';
	}
}
```

完结撒花~~~

# 祝大家 csp-s/j   ~~noip~~   rp++；


---

## 作者：生而为人 (赞：0)

写在前面的话

最近复习图论，想算法想得头疼，题解又大都语焉不详，非但刷题带来的快感大不如前，而且十分费时，常常导致我熬夜，我自己都几乎要“哀民生之多艰”了。现在好不容易想明白一道题，我打算自己写写题解，看能否讲得更清楚一点，以方便后来者。当然，本人水平有限，还望多多包涵。
此题 是典型的 二分图 匹配，本人 用的 是匈牙利算法， 首先 把 每个课堂与人连边，最后 跑一边 匈牙利即可。
下面 附代码、
```c
#include<iostream>
#include<cstdio>
#include<vector>
#include<cstring>
using namespace std;
int t,p,n;
vector<int>va[20005];
bool done[105];
int in[105];
bool dfs(int now)
{
	for(int i=0;i<va[now].size();i++)
	{
		int to=va[now][i];
		if(done[to]) continue;
		done[to]=1;
		if(!in[to]||dfs(in[to]))
		{
			in[to]=now;
			return true;
		}
	}
	return false;
}
int main()
{
	cin>>t;
	while(t--)
	{
		memset(done,0,sizeof(done));
		memset(in,0,sizeof(in));
		for(int i=1;i<=p;i++)
		va[i].clear();
		bool flag=0;
		cin>>p>>n;
		for(int i=1,tot;i<=p;i++)
		{
			cin>>tot;
			for(int j=1,k;j<=tot;j++)
			{
				cin>>k;
				va[i].push_back(k+p);
			}
		}
		for(int i=1;i<=p;i++)
		{
			memset(done,0,sizeof(done));
			if(!dfs(i)) {flag=1;break;}
		}
		if(flag) cout<<"NO"<<endl;
		else cout<<"YES"<<endl;
	}
}
```


---

## 作者：MloVtry (赞：0)

标准的二分图最大匹配

建立超级源与超级汇

源于屋子相连

人与汇相连

屋子在和人相连

最大流，看流量是否等于p就行

这里给一下网络流的代码

（p的范围没给re了好多次一脸辛酸）


```cpp
#include<algorithm>
#include<iostream>
#define M 10000000
#define inf 1<<30
#include<cstring> 
#include<cstdio>
#include<queue>
#define N 101000
using namespace std;
int head[N],Next[M],to[M],cup[M],e;
int T,p,n,s,t;
void buid(int u,int v,int c)
{
    Next[++e]=head[u],head[u]=e;
    to[e]=v,cup[e]=c;
}
int mflow,use[N],itc[N];
queue<int> q; 
bool bfs()
{
    memset(itc,0,sizeof(itc));
    q.push(s);itc[s]=1;
    while(!q.empty())
    {
        int now=q.front();q.pop();
        for(int i=head[now];i;i=Next[i])
        {
            if(!cup[i]) continue;
            int j=to[i];
            if(!itc[j])
            {
                itc[j]=itc[now]+1;
                q.push(j);
            }
        }
    }
    return itc[t];
}
int doit(int now,int want)
{
    if(now==t||want==0) return want;
    int get=0;
    for(int i=use[now];i;i=Next[i])
    {
        int j=to[i];use[now]=i;
        if(itc[j]==itc[now]+1)
        {
            int f=doit(j,min(want,cup[i]));
            if(!f) continue;
            want-=f;get+=f;
            cup[i]-=f;cup[i^1]+=f;
            if(!want) break;
        }
    }
    return get;
}
void max_flow()
{
    mflow=0;
    while(bfs())
    {
        for(int i=s;i<=t;++i) use[i]=head[i];
        mflow+=doit(s,inf);
    }
}
int main()
{
    scanf("%d",&T);
    while(T--)
    {
        memset(head,0,sizeof(head));
        e=1;
        scanf("%d%d",&p,&n);
        s=0,t=p+n+1;
        for(int i=1;i<=p;++i)
        {
            int m;scanf("%d",&m);
            for(int j=1;j<=m;++j)
            {
                int v;scanf("%d",&v);
                buid(i,v+p,1);
                buid(v+p,i,0);
            }
            buid(s,i,1);buid(i,s,0);
        }
        for(int i=1;i<=n;++i) buid(i+p,t,1),buid(t,i+p,0);
        max_flow();
        if(mflow==p) printf("YES\n");
        else printf("NO\n");
    }
    return 0;
}
```

---

## 作者：Stump (赞：0)

```cpp
//二分图匹配裸题
//匈牙利算法和网络流dinic算法
#include<iostream>
#include<cstdio>
#define FOR(i,s,t) for(register int i=s;i<=t;++i)
#define BIG 233333
using namespace std;
int m,n,p,x,y,tot,T,ans;
int las[BIG],to[BIG],nxt[BIG],con[BIG],vis[BIG];
inline int match(int now){
    for(register int e=las[now];e;e=nxt[e]){
        if(!vis[to[e]]){
            vis[to[e]]=1;
            if(!con[to[e]]||match(con[to[e]])){
                con[to[e]]=now;
                return 1;
            }
        }
    }
    return 0;
}
inline void add(int x,int y){
    nxt[++tot]=las[x];
    las[x]=tot;
    to[tot]=y;
}
int main(){
    scanf("%d",&T);
    while(T--){
        ans=0;
        scanf("%d%d",&p,&n);
        FOR(i,1,p){
            scanf("%d",&m);
            FOR(j,1,m){
                scanf("%d",&x);
                add(i,p+x);
            }
        }
        FOR(i,1,p){
            FOR(j,1,p+n)
                vis[j]=0;
            ans+=match(i);
        }
        ans==p?puts("YES"):puts("NO");
        FOR(i,1,n+p)
            con[i]=las[i]=0;
        tot=0;
    }
    return 0;
}
```

---

## 作者：jamespaul (赞：0)

```cpp
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
const int maxn = 301*101;
int first[maxn],next[maxn],v[maxn];//头结点，下一点，和边的终点（即学生编号）
bool vis[maxn];    //记录是否访问过
int link [maxn];//记录与之匹配的点
int p , n ;
bool find ( int k )
{
    int i ;
    for ( i = first[k] ; i != -1 ;  i =next [i] ) 
```
{//寻找与k连接的点
        if ( !vis [v[i]] )

{//如果没访问过，则访问并标记

            vis [ v[i]] =true ;

            if ( link [v[i]] == 0 || find ( link [v[i]] ) )

{//如果该学生还未匹配课堂或存在增广路

            
```cpp
                link [v[i]] = k ;//与之匹配
                return true ;
            }
        }
    }
    return false;
}
int main()
{
    int t ; 
    scanf("%d",&t) ;
    while ( t -- )
    {
        scanf("%d%d",&p,&n) ;
        if ( p > n ) //如果学生人数都少于课堂数，明显不可能达到匹配
            cout <<"NO"<<endl;
        else
        {
            int i , j ; 
            memset ( first , -1 , sizeof ( first ) );    //初始化表头
            memset ( link , 0 , sizeof ( link ) ) ;        //初始化
            int e = 0 ;
            for ( i = 0 ; i < p ; i ++ )
            {
                int a ;
                scanf("%d",&a);
                for ( j = 0 ; j < a ; j ++ , e ++ )
                {
                    scanf("%d",&v[e]);
                    next [e] = first [i+1];    //插入链表，从头端插入
                    first [i+1] = e ;        //记录链表头结点
                }
            }
            bool ans = 0 ;
            for ( i = 0 ; i < p ; i ++ )
            {
                memset ( vis , 0 , sizeof ( vis ) ) ;
                if ( !find ( i + 1 ) )
```
{//如果找不到与改点匹配的点，则答案就为NO
```cpp
                    ans =true;
                    break;
                }
            }
            if ( ans )
                cout<<"NO"<<endl;
            else
                cout<<"YES"<<endl;
        }
    }
    return 0;
}
```

---


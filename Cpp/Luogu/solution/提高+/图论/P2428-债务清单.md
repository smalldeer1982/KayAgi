# 债务清单

## 题目描述

HZGD 刚刚带领着他的 $N$ 个学生参加完第 LXX 届 NOI。但他的学生发现他们本应该报销的费用还一直拖欠着，于是纷纷找 HZGD 要他给他们报销。不过麻烦的是，学生们总是成双成对的找他，并且只报告他们的债务总和，有的人可能来报告好几次。这让 HZGD 非常难办，他不知道是不是有些人会谎报债务，于是他希望能够列出一张债务清单。


## 说明/提示

对于 $30\%$ 的数据，有 $1 ≤ N ≤ 10,1 ≤ M ≤ 55$；

对于 $60\%$ 的数据，有 $1 ≤ N ≤ 100,1 ≤ M ≤ 1000$；

对于 $100\%$ 的数据，有 $1 ≤ N ≤ 1000,1 ≤ M ≤ 10^5$，所有输入数据不超过 $2\times 10^6$。


## 样例 #1

### 输入

```
3 3
1 2 2
2 3 4
1 3 6
```

### 输出

```
2.00
0.00
4.00
```

# 题解

## 作者：greenheadstrange (赞：10)

# 分析：
看到这道题我还以为是高斯消元，可惜**M≤100000**，~~**GG**~~

怎么办呢？

#### 先分析样例（如果我们用数学的方法来做的话，我们该怎么做呢？）

![](https://cdn.luogu.com.cn/upload/pic/60712.png)

1. 先设第一个数为x

2. 然后求出另外两个点的值

3. 再通过方程求得x的值，其它点的值迎刃而解

#### 在回到本题

先设出x，再依次写出其它点的值（kx+b）当有重新返回的时候就可以用方程来求出x的值

```cpp
for(int k=1;k<=n;k++){
	if(v[k])continue;
        while(!q.empty())q.pop();
        q.push(k);
        f[k]=1;
        v[k]=1;
        b[k]=0;
        while(!q.empty()){
            int x=q.front();
            q.pop();
            for(int i=head[x];i;i=c[i].next){
                int nf=-f[x],nb=c[i].l-b[x],y=c[i].to;
                if(f[y]){
                    if(nf==f[y]&&nb!=b[y]){cout<<"jinitaimei";return 0;}
                    if(nf!=f[y]){ans[k]=(b[y]-nb)/(nf-f[y]);break;}
                }
                else{
                    q.push(y);
                    f[y]=nf;
                    b[y]=nb;
                }
            }
        }
        q.push(k);
        while(!q.empty()){
            int x=q.front();
            q.pop();
            for(int i=head[x];i;i=c[i].next){
            	int y=c[i].to;
                if(!v[y]){
                    v[y]=1;
                    ans[y]=c[i].l-ans[x];
                    q.push(y);
                }
            }           	
        }
    }
```

再给个完整的

```
#include<bits/stdc++.h>
using namespace std;
bool v[1005];
struct note{
    int next,to;
	double l;
}c[200005];
int n,m,cnt,head[1005];
double ans[1005],f[1005],b[1005];
queue<int>q;
void add(int x,int y,int z){
    cnt++;
    c[cnt].l=z;
    c[cnt].to=y;
    c[cnt].next=head[x];
    head[x]=cnt;
}
int main(){
    int aa,bb;
	double cc;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)scanf("%d%d%lf",&aa,&bb,&cc),add(aa,bb,cc),add(bb,aa,cc);
    for(int k=1;k<=n;k++){
        if(v[k])continue;
        while(!q.empty())q.pop();
        q.push(k);
        f[k]=1;
        v[k]=1;
        b[k]=0;
        while(!q.empty()){
            int x=q.front();
            q.pop();
            for(int i=head[x];i;i=c[i].next){
                int nf=-f[x],nb=c[i].l-b[x],y=c[i].to;
                if(f[y]){
                    if(nf==f[y]&&nb!=b[y]){cout<<"jinitaimei";return 0;}
                    if(nf!=f[y]){ans[k]=(b[y]-nb)/(nf-f[y]);break;}
                }
                else{
                    q.push(y);
                    f[y]=nf;
                    b[y]=nb;
                }
            }
        }
        q.push(k);
        while(!q.empty()){
            int x=q.front();
            q.pop();
            for(int i=head[x];i;i=c[i].next){
            	int y=c[i].to;
                if(!v[y]){
                    v[y]=1;
                    ans[y]=c[i].l-ans[x];
                    q.push(y);
                }
            }           	
        }
    }
    for(int i=1;i<=n;i++)printf("%.2lf\n",ans[i]);
    return 0;
}
```




---

## 作者：JK_LOVER (赞：3)

## 题意
给你 $m$ 个条件 $val_a+val_b = W_i$ ，求满足该条件的解。
## 分析
- 如果有解：

如果直接令出每个 $val_a$ ，再通过高斯消元求解，其时间复杂度为 $O(n^3)$ 。发现每个限制条件都只与两个元素有关。可以采用主元法。
令一个 $val_i = x$ ，这里 $x=1$ 。则有：
$$
val_1+val_b = W_j \Rightarrow val_b=W_j-val_1
$$
$$
val_b=-x+W_j
$$
若有 $val_b+val_c = W_i$ ，则：
$$
val_b+val_c=W_j\Rightarrow val_c=W_i-val_b
$$
$$
val_c=x+(W_i-W_j)
$$
以此类比。每个 $val_i$ 可以写作这样的形式 $val_i=x+b $ 或者 $ val_i=-x+b$ 。那么如果出现 $val_1 = -x+b$ 则 $val_1=x=\frac{b}{2}$ 。那么通过 $dfs$ 搜索。只要出现环就可以计算出一组解。

- 如果无解：

一：没有找到环， $val_1$ 没有两种表达方式。

二：找到环了，但是 $val_1$ 表示成 $val_1=x+b(b\ne0)$ 。那么也是没有解的。

三：有多组解（这应该不叫无解），但是我判了一下就 $WA$ 了，求大佬们查错。
## 代码
```cpp

#include<bits/stdc++.h>
using namespace std;
const int N = 10000010;
#define int long long
const double eps = 1e-8;
int read()
{
	int x = 0,f = 0;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=1;ch=getchar();}
	while(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}
	return f?-x:x;
}
int n,m,cnt = 0,head[N];
bool flag = 0,vis[N];
int A[N],B[N];
double Ans;
struct E{int to,nxt,w;}e[N];
void add(int x,int y,int w)
{
	e[++cnt].to = y;e[cnt].w = w;e[cnt].nxt = head[x];head[x] = cnt;
}
void dfs(int x,int a,int b)
{
	if(flag) return;
	//cout<<x<<" ::x "<<a<<" ::a "<<b<<" ::b"<<endl;
	if(vis[x] && x == 1)
	{
		//ax-x = -b;
		//x = (-b)/(a-1);
		if((a==1) && b) 
		{
			flag = 1;
			return;
		}
		double ans = b/2.0;
		if(!Ans) Ans = ans;
//		if(fabs(Ans - ans) != 0.0)
//		{
//			flag = 1;
//			return ; 就是这里了不知道为啥WA了
//		}
		return;
	}
	vis[x] = 1;
	for(int i = head[x];i;i = e[i].nxt)
	{
		int w = e[i].w;
		int y = e[i].to;
		if(vis[y] && !(y==1)) continue;
		dfs(y,- a,w - b);
	//	cout<<y<<" ::y  "<<-a<<" "<<w-b<<endl;
		A[y] = - a;
		B[y] = w - b;
	}
}
signed main()
{
	n = read();m = read();

	for(int i = 1;i <= m;i++)
	{
		int a = read(),b = read(),c = read();
		add(a,b,c);
		add(b,a,c);
	}
	dfs(1,1,0);
	A[1] = 1;B[1] = 0;
	if(flag)
	{
		cout<<"IMPOSSIBLE"<<endl;
		return 0;
	}
	for(int i = 1;i <= n;i++)
	{
		printf("%.2lf\n",A[i]*Ans+B[i]);
	}
}
```


[欢迎来踩](https://www.luogu.com.cn/blog/xzc/solution-p2428)

---

## 作者：bamboo12345 (赞：2)

先给出几个hack：
```4 5
2 4 10
3 4 9
1 2 2
2 3 2
1 3 2
```
```
6 6
1 2 2
2 3 2
1 3 2
4 5 2
5 6 2
4 6 2
```
直接叉掉了所有其他题解的错误方式。

还有很多其他的提交记录也可以被叉掉，还有其他的坑点。

这题细节其实非常多，所以我很希望出题人能放个代码。
# 0.更新
暂无
# 1.正文
[题目传送门](https://www.luogu.com.cn/problem/P2428)

首先第一想法是高斯消元，但是时间复杂度要 $O(n^3)$ 不太好会爆炸。

但是我们不妨考虑一种人类的解方程方式。

我们可以设其中一个元 $x_i$ 为 $t$，然后去带着这个未知数去求解其他我们能求解的。

我们记 $k(i),b(i)$ 代表当前点 $i$ 的值为 $k(i)t+b(i)$。

比如样例，我们设 $t=x_1$，我们就可以标出这样的一些 $k,b$。

| 编号|$k$|$b$|表达式|
|:---:|:---:|:---:|:---:|
|$1$|$1$|$0$|$t$|
|$2$|$-1$|$2$|$-t+2$|
|$3$|$1$|$2$|$t+2$|

注意到我们这时候会重复把点 $1$ 标为 $4-t$，这时我们可以列出一个方程：

$$4-t=t$$

可以解得 $t=2$。

但有些时候是无解的，比如数据是这样的：
```
4 4
1 2 2
2 3 0
3 4 2
1 4 2
```

那么我们会标出这样：

| 编号|$k$|$b$|表达式|
|:---:|:---:|:---:|:---:|
|$1$|$1$|$0$|$t$|
|$2$|$-1$|$2$|$-t+2$|
|$3$|$1$|$-2$|$t-2$|
|$4$|$-1$|$4$|$-t+4$|

这时我们注意到方程是这样子的：

$$t-2=t$$

显然这个方程并没有解。

---

这些都是现象，那么我们考虑什么时候我们可以列出这样一个方程呢？

我们其实可以先进行深搜，一步步找出 $k,b$ 的值。

我们可以把深搜树给画出来进行一定的分析。

可以看到，其实可以列出方程的时候就是有返租边的时候，因为这时有了一个环。

那么我们现在就考虑深搜，每次遇到返租边就更新 $t$ 就可以了。

---

结束了吗？并没有。

注意到一件事情：我们可能不会有一个环。

这句话有两个面：

- 我们一个环都没有

- 我们有多于一个的环

先说第一种情况，注意到每个人的钱都要不小于 $0$，则对于一个人 $i$，有 $k(i)t+b(i)\ge 0$。

然后注意到 $k(i)$ 只会为 $-1$ 或 $1$，所以我们只用考虑 $k(i)=-1$ 的位置的限制。

那么如果 $-t+b(i)\ge 0$，则 $t\le b(i)$，我们找最小的 $b(i)$ 然后取 $t=b(i)$ 即可，但要注意如果 $b(i)<0$ 则没有解。

第二种情况，我们需要随时判断是否不同部分解出来的解是否正确，所以当我们找到一个环的时候，我们就要考虑是否有答案了，如果有，那么就要判断会不会和之前的不一样。

---

第二个坑点，图其实可能是不连通的，这个你需要对所有的连通块分别遍历。


---

第三个坑点，注意到其实我可以构造重边之类的东西，要注意判掉。

以下给出代码：

```
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int maxn=1005;
const double eps=1e-6;
int n,m,f[maxn][maxn];
struct Edge
{
	int to,val;
};
vector<Edge> e[maxn];
struct node
{
	int x=0,b=0;
} a[maxn];
double ans=0;
int vis[maxn],flag,use[maxn];
void dfs(int u,int fa)
{
	vis[u]=1;
	use[u]=1;
	//cout <<u<<" "<<a[u].x<<endl;
	for(int i=0;i<e[u].size();i++)
	{
		int v=e[u][i].to;
		node tmp;
		tmp.x=-a[u].x,tmp.b=e[u][i].val-a[u].b;
		if(v==fa)
			continue;
		if(!vis[v])
		{
			//f[u][v]=1;
			a[v]=tmp;
			dfs(v,u);
		}
		else
		{
		//	while(1);
			if(tmp.x==a[v].x&&tmp.b!=a[v].b)
			{
				cout <<"IMPOSSIBLE"<<endl;
				exit(0);
			}
			if(!flag&&a[v].x!=tmp.x)
			{
				flag=1;
				ans=(double)(a[v].b-tmp.b)/(double)(tmp.x-a[v].x);
				//cout <<a[v].b<<" "<<tmp.b<<" "<<tmp.x<<" "<<a[v].x<<endl;
			}
			else if(flag&&fabs((double)(a[v].b-tmp.b)/(double)(tmp.x-a[v].x)-ans)>eps)
			{
				cout <<"IMPOSSIBLE"<<endl;
				exit(0);
			}
		}
	}
} 
int mx=-2e9,mn=2e9;
double as[maxn];
signed main()
{
	memset(f,-1,sizeof(f));
	cin >>n>>m;
	for(int i=1;i<=m;i++)
	{
		int x,y,w;
		cin >>x>>y>>w;
		e[x].push_back(Edge{y,w});
		e[y].push_back(Edge{x,w});
		if(x>y)
			swap(x,y);
		if(f[x][y]==-1)
			f[x][y]=w;
		else if(f[x][y]!=w)
		{
			cout <<"IMPOSSIBLE"<<endl;
			return 0;
		}
	}
	for(int i=1;i<=n;i++)
	{
		if(!vis[i])
		{
			a[i].x=1;
			ans=0,flag=0;
			dfs(i,0);
			if(flag)
			{
				for(int j=1;j<=n;j++)
					if(use[j])
						as[j]=ans*a[j].x+a[j].b,use[j]=0;
			}
			else
			{
				mx=-2e9,mn=2e9;
				for(int j=1;j<=n;j++)
					if(use[j])
					{
						if(a[j].x<0)
							mn=min(mn,a[j].b);
						else
							mx=max(mx,a[j].b);
					}
				if(mn<0||mx>mn)
				{
					cout <<"IMPOSSIBLE"<<endl;
					return 0;
				}
				else
				{
					ans=mn;
					for(int j=1;j<=n;j++)
						if(use[j])
							as[j]=a[j].x*ans+a[j].b,use[j]=0;
				}
			}
		}
	}
	for(int i=1;i<=n;i++)
		if(as[i]<0)
		{
			cout <<"IMPOSSIBLE"<<endl;
			return 0;
		}
	for(int i=1;i<=n;i++)
		printf("%.2lf\n",as[i]);
	return 0;
}
```

---

## 作者：Tracy_Loght (赞：1)

## 题目描述：

有 $M$ 个式子，表示为 $a_{i}+a_{o}=m_{i}$ 的形式，求这一个多元多次方程组的解。

## 思考：

### 结论：


------------

这一个不就是简单的在 $M$ 个式子中找如 **$a_{i}+a_{o}=m_{1}, a_{i}+a_{z}=m_{2}, a_{o}+a_{z}=m_{3}$** 的式子吗！

### 为什么呢？


------------

因为可以求出答案啊！（不懂的看下面）

当我们找到如图这个式子：~~（用哈希来找到这三个式子）~~

$$ \begin{cases} \cdots\\ a_{i}+a_{o} = m_{1} \cdots\cdots\cdots1\\\cdots \\a_{i}+a_{z}=m_{2} \cdots\cdots\cdots2\\\cdots\\ a_{o}+a_{z}=m_{3}\cdots\cdots\cdots3 \\\cdots\end{cases}$$

解一个三元三次方程，会吧！

不会也没事，看**下面**，会的跳过就行。



------------


 1. $2(a_{i}+a_{o}+a_{z}) =m_{1}+m_{2}+m_{2}$ (将上面的式子相加一 $+$ 二 $+$ 三）
 
 2. $a_{i}+a_{o}+a_{z} =\frac{m_{1}+m_{2}+m_{2}}{2} $ (将上面的式子同时除以 $2$）
 
 3. 减去一，二，三式子中的任意一个，为了好表示，我减去了第一式）
 
 $a_{i} + a_{o} + a_{z} - ( a_{i}+a_{o} )=\frac{m_{1}+m_{2}+m_{2}}{2} -m_ {1}$
 
 4. 化简后：
 
 $a_{z} =\frac{m_{1}+m_{2}+m_{2}}{2} -m_ {1}$
 
 
------------


如果发现找不到，就 `cout<<"IMPOSSIBLE";`。

找得到就解方程，在套进去求剩余的解（知二求一），最后一定可以找到所有人的债务数额。

**完结！**

---

## 作者：AC_CSP (赞：1)

[$\text{题目传送门}$](https://www.luogu.com.cn/problem/P2428) 
$|$ 
[$\text{博客}$](https://www.luogu.com.cn/blog/481527/p2428-zhai-wu-qing-dan-ti-xie)

## $\text{题目大意}$

给你 $m$ 条对 $n$ 个变量的限制，形如 $x_a+x_b=c$。同时满足 $\forall i ,x_i \ge 0 $。求 $x_1\sim x_n$ 的值。保留两位小数。无解报告 ```IMPOSSIBLE```。否则保证有唯一解。

## $\text{Solution}$

不妨尝试用 $x_1$ 表示 $x_2\sim x_n$。

以样例为例子，我们有：

$\begin{cases}x_1+x_2=2\\x_2+x_3=4\\x_1+x_3=6\end{cases}$

变换一下得到：

$\begin{cases}x_1=x_1\\x_2=2-x_1=4-x_3=4-(6-x_1)=x_1-2\\x_3=6-x_1=4-x_2=4-(2-x_1)=x_1+2\end{cases}$

所以我们只要存下一个变量的某种表示方法的系数和常数，然后下一次搜到解方程即可。

这里要注意判断无解的情况：

+ 若一个未知数的某两种表示方式 $x$ 的系数相同而常数不同，直接输出无解。

+ 若一个未知数的某两种表示方式算出的答案与之前不同，直接输出无解。

+ 若一个未知数的某两种表示方式系数常数都相同，直接跳过，计算完毕后判断无解（无数解）。

注意可能有多于一个的连通块。

但是不要忘了还有一种特殊情况：若两个变量和为零，那么这两个变量都为零。对于每个连通块，如果有上述情况存在，即可直接更新答案，但要注意检查答案。

对于无解的判断样例参考[这篇帖子](https://www.luogu.com.cn/discuss/612064)，之前的题解全部无法通过。

这里我使用 bfs 实现，时间复杂度 $\mathcal{O}(n+m)$。

## $\text{Code}$

```cpp
# include <bits/stdc++.h>
using namespace std ; 
const int N = 1e3 + 7 ;
const int M = 1e5 + 7 ;
struct edge {
    int nxt , v , w ;
} e [ M << 1 ] ;  // 双倍内存 
int h [ N ] , cnt ;
inline void add_edge ( int u , int v , int w ) {
    e [ ++ cnt ] = ( edge ) { h[u] , v , w } ;
    h[u] = cnt ;
}
struct node {
    int pos , k , b ; // 系数，常数 
} tmp ;
int k[N] , b[N] ;
double x = -114514 ; // 开始一个不可能的值 
int n , m ; double ans[N] ;
bool vis[N] , vis2[N] , vis3[N] ;
int main () {
    ios :: sync_with_stdio ( false ) , cin . tie ( 0 ) , cout . tie ( 0 ) ;
    cin >> n >> m ;
    for ( int i = 1 ; i <= m ; i ++ ) {
        int u , v , w ; cin >> u >> v >> w ;
        add_edge ( u , v , w ) , add_edge ( v , u , w ) ;
    }
    queue < int > qq ;
    for ( int i = 1 ; i <= n ; i ++ ) {
        if ( vis[i] ) continue ; x = -114514 ;
        bool bo = 0 ; int y ;
		queue < int > c ; c . push ( i ) ;
		while ( ! c . empty () ) { // bfs 求 w = 0 
			int u = c . front () ; c . pop () ; vis2[u] = 1 ;
			for ( int j = h[u] ; j ; j = e[j] . nxt ) {
				int v = e[j] . v , w = e[j] . w ;
				if ( w == 0 ) bo = 1 , y = u ;
				if ( ! vis2[v] ) {
					vis2[v] = 1 ; 
					c . push ( v ) ;
				}
			}
		}
		if ( bo == 1 ) {
			queue < int > cc ; cc . push ( y ) ;
			while ( ! cc . empty () ) { // bfs 更新答案 
				int u = cc . front () ; cc . pop () ; vis3[u] = 1 ;
				for ( int j = h[u] ; j ; j = e[j] . nxt ) {
					int v = e[j] . v , w = e[j] . w ;
					if ( ans[v] == 0 ) ans[v] = w - ans[u] ; // 更新并 check 
					else {
						cout << "IMPOSSIBLE\n" ; // 矛盾 
						return 0 ;
					}
					if ( ! vis3[v] ) {
						vis3[v] = 1 ;
						cc . push ( v ) ;
					}
				}
			}
		} 
        queue < node > q ; tmp = ( node ) { i , 1 , 0 } ; q . push ( tmp ) ;
        while ( ! q . empty () ) {
            node u = q . front () ; q . pop () ; vis [ u . pos ] = 1 ; qq . push ( u . pos ) ;
            if ( k [ u . pos ] == 0 && b [ u . pos ] == 0 ) { // 更新一个新的点 
                k [ u . pos ] = u . k , b [ u . pos ] = u . b ;
                for ( int i = h [ u . pos ] ; i ; i = e[i] . nxt ) {
                    int v = e[i] . v , w = e[i] . w ;
                    node _ = ( node ) { v , - u . k , w - u . b } ; // w - ( kx + b ) = - kx + w - b 
                    q . push ( _ ) ;
                }
            }
            if ( k [ u . pos ] == u . k && b [ u . pos ] != u . b ) { // 无解 
                cout << "IMPOSSIBLE\n" ;
                return 0 ;
            }
            if ( k [ u . pos ] == u . k && b [ u . pos ] == u . b ) continue ; // 无数解 
            double nx = -1.0 * ( b [ u . pos ] - u . b ) / ( k [ u . pos ] - u . k ) ; // 新的答案 
            if ( x == -114514 ) x = nx ; 
            if ( fabs ( x - nx ) > 0.0000001 ) { // 矛盾 
                cout << "IMPOSSIBLE\n" ;
                return 0 ;
            }
        }
        if ( x == -114514 && ! bo ) { // 无数解 
            cout << "IMPOSSIBLE\n" ;
            return 0 ;
        }
        if ( bo ) continue ; // 之前 w = 0 更新过了 
		while ( ! qq . empty () ) { // 更新答案 
            int u = qq . front () ; qq . pop () ;
            ans[u] = k[u] * x + b[u] ;
        }
    } 
    for ( int i = 1 ; i <= n ; i ++ ) {
    	if ( ans[i] < 0 ) { // 不能为负 ！！！ 
    		cout << "IMPOSSIBLE\n" ;
    		return 0 ;
		}
	}
	for ( int i = 1 ; i <= n ; i ++ )
    	printf ( "%.2f\n" , ans[i] ) ;
    return 0 ; 
}
```


---

## 作者：zerc (赞：1)

**题意：**

求解方程组：

$$
\begin{cases}
 x_{u_1} + x_{v_1} = w_1 \\
 x_{u_2} + x_{v_2} = w_2 \\
 \dots \\
 x_{u_m} + x_{v_m} = w_m
\end{cases}
$$

$n \le 10^3, m \le 10^5$

**题解：**

直接消元时间复杂度无法接受。

考虑人类如何解方程：

+ 设 $x_1 = a$；

+ 对于 $x_1 + x_i = w_1$，可以得到 $x_i = w_1 - x_1 = w_1 - a$；

+ 对于 $x_i + x_j = w_2$，可以得到 $x_j = w_2 - x_i = w_2 - w_1 + a$；

+ 不断重复这个过程，发现对于每个 $x_i$ 都可以用 $k_i \times a + b_i$ 表示；

+ 对于 $x_r + x_1 = w_3$，可以得到 $x_1 = w_3 - x_r$，
  
  用 $x_1$ 的表达式求解：
  
  $$
  \begin{aligned}
   k_1' \times a + b_1' &= a \\
   a &= \frac{b_1'}{1 - k_1'}
  \end{aligned}
  $$
  
  无解的情况为 $k_1' = 0 \land b_1' \not= 0$，
  
  可以解得 $a$，回代得到 $x_1 \sim x_n$ 的值。
  
发现整个过程可以用 dfs（或 bfs）实现，时间复杂度 $O(m)$。

```cpp
struct edge {
    int to, nxt, val;
} e[M];

struct raip {
    int k, b;
} f[N];

int cnt, head[N];

double ans;

std::bitset<N> vis;

void add(int u, int v, int w) {
    e[++cnt] = {v, head[u], w}, head[u] = cnt;
}

void dfs(int u, raip g) {
    if (u == 1 and vis[1]) {
        if (g.k == 1 and g.b) {
            io << "IMPOSSIBLE", exit(0);
        } else {
            if (g.b) ans = g.b / 2.;
            // 防止无数解的情况覆盖掉 ans
        }
        return;
    }
    vis[u] = true;
    for (int i = head[u]; i; i = e[i].nxt) {
        int v = e[i].to;
        if (! vis[v] or v == 1) {
            dfs(v, f[v] = {-g.k, e[i].val - g.b});
        }
    }
}

int main() {
    int n, m; io >> n >> m;
    for (int i = 1; i <= m; i++) {
        int u, v, w; io >> u >> v >> w;
        add(u, v, w), add(v, u, w);
    }
    dfs(1, f[1] = {1, 0});
    for (int i = 1; i <= n; i++) {
        io << f[i].k * ans + f[i].b << '\n';
    }
}

```

注意一些[实现细节](https://www.luogu.com.cn/discuss/529090)就好了。

---


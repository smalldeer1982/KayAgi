# [SCOI2012] 滑雪

## 题目描述

a180285 非常喜欢滑雪。他来到一座雪山，这里分布着 $m$ 条供滑行的轨道和 $n$ 个轨道之间的交点（同时也是景点），而且每个景点都有一编号 $i\space (1 \le i \le n)$ 和一高度 $h_i$。  

a180285 能从景点 $i$ 滑到景点 $j$ 当且仅当存在一条 $i$ 和 $j$ 之间的边，且 $i$ 的高度**不小于** $j$。与其他滑雪爱好者不同，a180285 喜欢用最短的滑行路径去访问尽量多的景点。如果仅仅访问一条路径上的景点，他会觉得数量太少。

于是 a18028 5拿出了他随身携带的时间胶囊。这是一种很神奇的药物，吃下之后可以立即回到上个经过的景点（不用移动也不被认为是 a180285 滑行的距离）。  

请注意，这种神奇的药物是可以连续食用的，即能够回到较长时间之前到过的景点（比如上上个经过的景点和上上上个经过的景点）。 现在，a180285站在 $1$ 号景点望着山下的目标，心潮澎湃。他十分想知道在不考虑时间胶囊消耗的情况下，以最短滑行距离滑到尽量多的景点的方案（即满足经过景点数最大的前提下使得滑行总距离最小）。你能帮他求出最短距离和景点数吗？


## 说明/提示

【数据范围】   
对于 $ 30\% $ 的数据，$ 1 \le n \le 2000 $；   
对于 $ 100\% $ 的数据，$ 1 \le n \le 10^5 $。


对于所有的数据，保证 $ 1 \le m \le 10^6 $ , $ 1 \le h_i \le 10^9 $ ，$ 1 \le k_i \le 10^9 $。


## 样例 #1

### 输入

```
3 3 
3 2 1 
1 2 1 
2 3 1 
1 3 10 ```

### 输出

```
3 2```

# 题解

## 作者：Khassar (赞：35)

/\*
题目大意为：在只能从点权大的点到点权小的点（可以相等）的情况下，从1点出发建立一棵尽可能有更多点的最小生成树

显然我们不能直接求最小生成树，因为有些点应为高度原因无法到达。

为保证我们只会由高到低，我们就只建立由高向低的单向边即可。

对于建立出来的图A，由1点开始宽搜，将扩展到的点和边加入一个新图B，所有扩展到的点便是能到达的最多点。

我们再在这个新图上跑Kruskal求最小生成树，求得最短距离。

对于排序部分，为保证有尽可能多的点在最小生成树里，我们按终点的高度为第一关键字从大到小排序，边长为第二关键字从小到大排序；

这样就能保证拓展的点最多，进而再用最小生成树求最短距离。

\*/





```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<cstdlib>
#include<string>
#include<queue>
#include<map>
#include<vector>
#define ll long long
#define R register
#define Rf(a,b,c) for(R int (a)=(b);(a)<=(c);++(a))
#define Tf(a,b,c) for(R int (a)=(b);(a)>=(c);--(a))
using namespace std;
const int N=2000000+5,M=100000+5;
ll n,m,tot,ans,num,sum,cnt,ql,qr;
struct it{
    ll u,v,w;//新图 
};
struct node {
    ll to,nx,val;//初始图（链式前向星） 
};
it a[N];node b[N];
ll fa[M],h[M],head[M],q[M];
bool vis[M];
inline ll read()//读入优化 
{
    ll x=0,f=1;char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x*=10;x+=(ch-'0');ch=getchar();}
    return x*f;
}
bool cmp1(it x,it y) {
//比较函数，以终点的高度为第一关键字从大到小排序，边长为第二关键字从小到大排序 
    if(h[x.v]!=h[y.v]) return h[x.v]>h[y.v];
    return x.w<y.w;
}
inline ll find(ll x) {//并查集找父亲 
    if(fa[x]!=x) fa[x]=find(fa[x]);
    return fa[x];
}
inline void add(int u,int v,int c) {//链式前向星加边 
    b[++num].to=v;
    b[num].nx=head[u];
    head[u]=num;
    b[num].val=c;
}
void bfs(){//宽搜，拓展可到达的点，建新图 
    q[++qr]=1;vis[1]=1;
    while(ql<qr) {
        int now=q[++ql];
        for(int i=head[now];i;i=b[i].nx) {
            a[++cnt].u=now;a[cnt].v=b[i].to;a[cnt].w=b[i].val;//建立新图的边 
            if(!vis[b[i].to]) {
                vis[b[i].to]=1;sum++;//sum计数器计可到达的点 
                q[++qr]=(b[i].to);
            }
        }
    }
}
int main()
{
//    freopen("steep.in","r",stdin);
//    freopen("steep.out","w",stdout);
    n=read();m=read();//读入数据 
    Rf(i,1,n) h[i]=read(),fa[i]=i;
    Rf(i,1,m) {
        R int u=read(),v=read(),c=read();
        if(h[u]>=h[v]) add(u,v,c);//根据边两边的点的高度，建立一条由高到低的单向边 
        if(h[u]<=h[v]) add(v,u,c);//当高度相等时会建两条边 
    }
    bfs();//广搜拓展点 
    sort(a+1,a+1+cnt,cmp1);//对新图的点跑Kruskal求最小生成树 
    Rf(i,1,cnt) {
        R int rx=find(a[i].u),ry=find(a[i].v);
        if(rx!=ry) {
            fa[rx]=ry;ans+=a[i].w;//求最短距离 
        }
    }
    printf("%lld %lld",sum+1,ans);//sum+1，还有初始的1点可到 
    return 0;
}

```

---

## 作者：Ccliang (赞：28)

好像题解里只有一个人用了prim，~~而且我还看不懂~~，实际上这道题目用prim的话会快一些。

概括一下题意：

我们从编号为一的点向下滑行，中途可以回到已走路径上的任意一点，而且回到已走点的距离不计入总距离，需求出我们能经过的最多的点数以及在此前提下所走的最短距离。

因为往回走不计入总距离，即重复走过一条边边权只算一次，所以我们的总距离即整个过程中走过的路径的边权和，那么我们要求的就是以 1 为根节点的点数最多的最小生成树。

根据题目意思，我们只能从高的节点走到低的节点，所以如果我们直接按一般的最小生成树的算法按边权排序，就会出现错误，举个栗子就知道了：

```
3
3 2 1
1 2 5
1 3 2
2 3 1

```
如果按一般的最小生成树的算法，最小边权和为3，但是很明显我们的答案应该是6，因为我们并不能从 3 号节点到 2 号节点。

我们会发现不管我们往下怎么连边，都不会对高度比它高的产生影响，所以我们在给点排序应该以节点高度为第一关键字，距生成树的距离为第二关键字。

而最小生成树的算法都是将能接到树上的节点全都接上，所以我们只需要在建树树统计一下就可以算出最多能到景点的数量了。

接下来看代码：~~我知道你们只看这个~~

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
#define ll long long
using namespace std;

const int N = 1e5 + 10;
const int M = 1e6 + 10;

inline int read()
{
	int res=0;
	char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')res=(res<<3)+(res<<1)+(ch^48),ch=getchar();
	return res;
}

struct edge{
	int next,to,w;
}r[M<<1];

int head[N],tot;

void add(int u,int v,int w)
{
	r[++tot]=(edge){head[u],v,w};
	head[u]=tot;
}

struct node{
	int high,dis,id;
};

bool operator <(const node &a,const node &b)
{
	if(a.high!=b.high)return a.high<b.high;
	return a.dis>b.dis;
}

priority_queue<node> q;

int maxn;

ll cnt,ans;

int h[N],d[N];

bool intree[N];

void prim(int st)
{
	memset(d,0x7f,sizeof(d));
	d[st]=0;
	q.push((node){h[st],0,st});
	while(!q.empty())
	{
		int u=q.top().id;
		q.pop();
		if(intree[u])continue;
		intree[u]=true;
		cnt++,ans+=d[u];
		for(int e=head[u];e;e=r[e].next)
		{
			int v=r[e].to,w=r[e].w;
			if(intree[v])continue;
			if(d[v]>w)
				d[v]=w,q.push((node){h[v],d[v],v});
		}
	}
}

int main()
{
	int n=read(),m=read();
	for(int i=1;i<=n;i++)
		h[i]=read();
	for(int i=1,u,v,w;i<=m;i++)
	{
		u=read(),v=read(),w=read();
		if(h[u]>=h[v])add(u,v,w);
		if(h[v]>=h[u])add(v,u,w);
	}
	prim(1);
	printf("%lld %lld\n",cnt,ans);
	return 0;
}
```


---

## 作者：mrsrz (赞：13)

题目大意：给你一张带权有向图（由于存在高度限制，所以边是有向的），问你从1开始最多能深度优先遍历多少个点（使用时间胶囊即为回溯），在遍历最多点的情况下，使得所有经过的边的权值和最小（由于深度优先遍历，所以就是求“有向图的最小生成树”）。



第一问很容易，深搜遍历即可。


在遍历的时候把有用的边记录下来。


第二问其实就是求最小生成树，但边是有向的，怎么办?


这里仍然可以使用Kruskal解决。


我们可以在对边排序的时候，以终点的高度为第一关键字，从大到小排，以边权为第二关键字，从小到大排。


要保证有向图的“最小生成树”正确，我们必须从高到低按次序遍历下来。


而以终点的高度从大到小排，就能保证所遍历的点一定是从大到小的，也就保证了答案的正确性。


然后Kruskal跑即可。


时间复杂度O(mlogm)，时间限制5s，强的数据能在1s左右运行完。


注意答案会超出2^32，要用64位整数。

```cpp
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>
using namespace std;
int n,m,h[100002],cnt,head[100002],fa[100002],cnt2,mxJD,head2[100002];
long long mxDS;
bool vis[100002];
int dad(int x){return fa[x]==x?x:fa[x]=dad(fa[x]);}
struct edge{
    int from,to,dis,nxt;
    bool operator<(const edge& rhs)const{
        if(h[to]!=h[rhs.to])return h[to]>h[rhs.to];
        return dis<rhs.dis;
    }
}e[1000005<<1],e2[1000005<<1];
inline int readint(){
    char c=getchar();
    for(;!isdigit(c);c=getchar());
    int d=0;
    for(;isdigit(c);c=getchar())
    d=(d<<3)+(d<<1)+(c^'0');
    return d;
}
void dfs(int now){
    vis[now]=true;
    ++mxJD;
    for(int i=head[now];i;i=e[i].nxt){
        e2[++cnt2]=(edge){e[i].from,e[i].to,e[i].dis,head2[e[i].from]};
        head2[e[i].from]=cnt2;
        if(!vis[e[i].to])dfs(e[i].to);
    }
}
int main(){
    memset(head,0,sizeof head);
    cnt=cnt2=mxJD=mxDS=0;
    n=readint(),m=readint();
    for(int i=1;i<=n;++i)h[i]=readint(),fa[i]=i;
    while(m--){
        int u=readint(),v=readint(),t=readint();
        if(h[u]>=h[v]){
            e[++cnt]=(edge){u,v,t,head[u]};
            head[u]=cnt;
        }//NOT else
        if(h[u]<=h[v]){
            e[++cnt]=(edge){v,u,t,head[v]};
            head[v]=cnt;
        }
    }
    memset(head2,0,sizeof head2);
    memset(vis,0,sizeof vis);
    dfs(1);
    printf("%d ",mxJD);
    sort(e2+1,e2+cnt2+1);
    for(int i=1;i<=cnt2;++i){
        int a=dad(e2[i].from),b=dad(e2[i].to);
        if(a!=b){
            mxDS+=e2[i].dis;
            fa[b]=a;
            if(--mxJD<2)break;
        }
    }
    printf("%lld\n",mxDS);
    return 0;
}
```

---

## 作者：MSF_Akatsuki (赞：7)

题意：给一个有向图，求以1点为根的有向树形图，满足含点数最大的前提下，边权和最小（时间胶囊实际上就是在路径上回溯，其结果就是最后升成一棵树）。另外，第一问本质求从根开始可达的点的个数。

开始没看见它给定了根，想了很久，然而既然给了根就是很简单的一道题了。

考虑按点从根进行拓展，使用prim求最小生成树。

由于这个算法过程中不能到达的点可以直接在过程中通过高度判断，所以第一问的正确性不会有问题。

接下来第二问

从根到达的点的数量是确定的，所以只要能到达的点都可以拓展。

转移的过程中，只能从高度高的向高度低的转移。所以我们对于所有可以拓展的点，先拓展高度更高的，最终答案不会更劣。

然后按照一般的prim做法，优先拓展距离已经存在的生成树距离最小的点即可。

整个过程中拿个堆维护数据，按高度为第一关键字，上述距离为第二关键字建堆就可以。

事实上，这个做法写起来和板子唯一的区别就是重载运算符的时候。。


贴我跑得非常慢的程序（实际上就是stl大常数）

***cpp








```cpp
#include<cstdio>
#include<cstdlib>
#include<queue>
using namespace std;
bool vis[100005];
int ans,t,n,m,u,v,k,fr[100005];
long long asl;
struct SSSD
{
    int ed,nxt,v;
}sd[2000005];
struct PRR{int a,b,nd;}pr[100005];
bool operator <(const PRR &a,const PRR &b){return a.a<b.a?1:a.a==b.a?(a.b>b.b?1:a.b==b.b?a.nd<b.nd:0):0;}
bool operator ==(const PRR &a,const PRR &b){return a.nd==b.nd&&a.b==b.b;}
struct HEAP
{
    priority_queue<PRR> n,dl;
    void ck(){while(dl.size()>0&&dl.top()==n.top())dl.pop(),n.pop();}
    void insert(PRR a){ck();n.push(a);}
    void del(PRR a){ck();dl.push(a);}
    int size(){ck();return n.size()-dl.size();}
    PRR pop(){ck();PRR a=n.top();n.pop();return a;}
}hp;
void addedge(int s,int e,int k)
{
    ++t;
    sd[t].ed=e;
    sd[t].v=k;
    sd[t].nxt=fr[s];
    fr[s]=t;
}
void prim()
{
    pr[1]=(PRR){pr[1].a,0,1};
    hp.insert(pr[1]);
    while(hp.size()>0)
    {
        PRR a=hp.pop();
        vis[a.nd]=1;
        ans++;
        asl+=a.b;
        for(int i=fr[a.nd];i!=0;i=sd[i].nxt)
        {
            if(pr[sd[i].ed].a>pr[a.nd].a)continue;
            if(vis[sd[i].ed])continue;
            if(pr[sd[i].ed].b==0x7fffffff)
            {
                pr[sd[i].ed].b=sd[i].v;
                hp.insert(pr[sd[i].ed]);
            }
            else if(sd[i].v<pr[sd[i].ed].b)
            {
                hp.del(pr[sd[i].ed]);
                pr[sd[i].ed].b=sd[i].v;
                hp.insert(pr[sd[i].ed]);
            }
        }
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&pr[i].a);
        pr[i].nd=i;
        pr[i].b=0x7fffffff;
    }
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d%d",&u,&v,&k);
        if(pr[u].a>=pr[v].a)addedge(u,v,k);
        if(pr[u].a<=pr[v].a)addedge(v,u,k);
    }
    prim();
    printf("%d %lld",ans,asl);
}
```
***
注意洛谷数据非常弱，所以。。。可以适当在这里交完以后换个oj......

我也不知道为啥怎么搜都是kruscal的写法啊///


放了一样的一份在：<http://www.msfakatsuki.com/index/Pennant-number=190>


---

## 作者：Azuree (赞：6)

[查看原题请戳这里](https://www.luogu.org/problemnew/show/P2573)  
# 解题思路
首先，因为题目要求求`“即满足经过景点数最大的前提下使得滑行总距离最小”`，所以这道题目我们可以用最小生成树来解决。
# 具体做法
 ## 核心算法
 这里推荐用kruskal去求最小生成树(`prim`虽然加上堆优化也应该不会超时，但是ta真的是代码难敲效率还低qwq)。  
 因为这道题目对于每个点的高度都有一个限制，所以有些点即使是有边相连也是到不了的。此时我们可以先统计可以到达的边，然后只储存两个端点都可以到达的边。  
 ## 注意事项
 因为每个点具有高度，所以建边是应根据情况选择建单向边还是双向边。  
 由于每个点的高度都有限制，所以并不是某个点在一开始统计的时候统计为能到达就可以随意选边。所以我们在对边进行排序是，应把终点的高度设为第一关键字，把边权设为第二关键字

# 代码
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<algorithm>
#define ll long long
#define INF 0x7fffffff
#define re register

using namespace std;

int read()
{
    register int x = 0,f = 1;register char ch;
    ch = getchar();
    while(ch > '9' || ch < '0'){if(ch == '-') f = -f;ch = getchar();}
    while(ch <= '9' && ch >= '0'){x = x * 10 + ch - 48;ch = getchar();}
    return x * f;
}

struct edge1{
	int next,to,k,from;
}edge[2000005];

struct edge2{
	int x,y,k;
}e[2000005];

long long n,m,u,v,k,t,cnt,ans,tot,h[100005],d[100005],vis[100005],fa[100005];

void add(int x, int y, int k)
{
	edge[++cnt].to = y;
	edge[cnt].k = k;
	edge[cnt].next = d[x];
	edge[cnt].from = x;
	d[x] = cnt;
}

void dfs(int s)
{
	vis[s] = 1;
	for(re int i = d[s]; i; i = edge[i].next) if(!vis[edge[i].to]) dfs(edge[i].to);
}

int mysort(edge2 a, edge2 b)
{
	if(h[a.y] != h[b.y]) return h[a.y] > h[b.y];
	return a.k < b.k;
}

int find(int x) {if(fa[x] == x) return x; return fa[x] = find(fa[x]);}

void kruskal()
{
	for(re int i = 1; i <= n; i++) fa[i] = i;
	sort(e + 1, e + t + 1, mysort);
	for(re int i = 1; i <= t; i++)
	{
		if(find(e[i].x) != find(e[i].y))
		{
			ans = ans + e[i].k;
			fa[find(e[i].x)] = find(e[i].y);
		}
	}
}

int main()
{
	n = read(); m = read();
	for(re int i = 1; i <= n; i++) h[i] = read();
	for(re int i = 1; i <= m; i++)
	{
		u = read();  v = read(); k = read();
		if(h[u] >= h[v]) add(u,v,k);
		if(h[u] <= h[v]) add(v,u,k);
	}
	dfs(1);
	for(re int i = 1; i <= cnt; i ++)
	{
		if((edge[i].from != edge[i - 1].to || edge[i].to != edge[i - 1].from) && vis[edge[i].from] && vis[edge[i].to])
		{
			e[++t].k = edge[i].k;
			e[t].x = edge[i].from;
			e[t].y = edge[i].to;
		}
	}
	kruskal();
	for(re int i = 1; i <= n; i++) if(vis[i]) tot ++;
	printf("%lld %lld\n", tot, ans);
    return 0;
}
```

---

## 作者：1saunoya (赞：6)

>[$\mathcal{\large{\colorbox{#005}{My Blog }}}$](https://www.cnblogs.com/qf-breeze/p/10753653.html)

[$problem$](https://www.luogu.org/problemnew/show/P2573)

这题就是 搜索 + 最小生成树？

反正就是这样的

1. 求从1开始能最到几个地方。
2.最短长度 即最小生成树。
我的做法是 先前向星存图 存好之后遍历 弄好第一个问 顺便处理好第二个问。
可以搜索 遍历出来 能到几个点。 然后顺便重新存图 因为有些路径就在这时候显得一点没用了。

然后跑$kruskal$ 求最短距离？ 没了。

关于排序的话 有一点 要从高到低排 高度相同的 取最小（最小生成树）

所以的话呢 
我们需要一个cmp

```cpp
bool cmp(E x , E y) { return h[x.v] == h[y.v] ? x.w < y.w : h[x.v] > h[y.v] ; }

```
然而这样的话 就可以达到排序的目的 也就是保证拓展的点最多

关于前向星存图 注意的是 高度相等需要建双向边。

数组开两倍（大雾

```cpp
#include <bits/stdc++.h>
using namespace std ;
//#define int long long 

typedef long long LL ;
inline int rd() { int x = 0 ; int f = 1 ; register char c ;
#define gc c = getchar()
    while(isspace(gc)) ;
    if(c == '-') f = -1 , gc ;
    while(x = (x<<1) + (x<<3) + (c&15) , isdigit(gc)) ;
    return x * f ;
#undef gc
}

int n , m ;
const int inf = INT_MAX >> 1 ;
const int N = 100000 + 5 ;
int h[N] ;
const int M = 1000000 + 5 ;
struct node { int to ; int val ; int nxt ; } Edge[M << 1] ;
int cnt(0) ;
int head[N] ;
struct E { int u ; int v ; int w ; } edge[M << 1] ;
bool cmp(E x , E y) { return h[x.v] == h[y.v] ? x.w < y.w : h[x.v] > h[y.v] ; }
inline void Add(int u , int v , int w) {
	Edge[++ cnt].to = v , Edge[cnt].val = w , Edge[cnt].nxt = head[u] ;
	head[u] = cnt ; 
}
int fa[N] ;
inline int find (int x) { return x == fa[x] ? x : fa[x] = find (fa[x]) ; } 
inline void merge(int x , int y) { fa[x] = y ; }
bool vis[N] ;
int num(0) , sum(1) ;
LL ans(0) ;
inline void Dfs(int x) {
	for(register int i = head[x] ; i ; i = Edge[i].nxt) {
		edge[++ num].u = x ; edge[num].v = Edge[i].to ; edge[num].w = Edge[i].val ;
		if(!vis[Edge[i].to]) vis[Edge[i].to] = 1 , ++ sum , Dfs(Edge[i].to) ;
	}
} 
inline void kruskal() {
	sort(edge + 1 , edge + num + 1 , cmp) ;
	for(register int i=1;i<=num;i++) {
		int fx = find(edge[i].u) , fy = find(edge[i].v) ;
		if(fx == fy) continue ;
		merge(fx , fy) ; ans += edge[i].w ;
	}
	return ;
}
signed main() {
	n = rd() , m = rd() ;
	for(register int i=1;i<=n;i++) fa[i] = i ;
	for(register int i=1;i<=n;i++) h[i] = rd() ;
	for(register int i=1;i<=m;i++) {
		int u = rd() , v = rd() , w = rd() ;
		if(h[u] >= h[v]) Add(u , v , w) ;
		if(h[u] <= h[v]) Add(v , u , w) ;
	}
	vis[1] = 1 , Dfs(1) ;
	kruskal() ;
	cout << sum << ' ' << ans << endl ;
	return 0 ;
}
```

---

## 作者：chenzida (赞：3)

题意简述：在一个只能沿着边从点权大的点向点权小的点连边，在这个图在包含的点最多的前提下求边权和最小的生成树。

思路解析：如果将这道题抽象出了题意简述的内容的话，就可以考虑使用 $Kruskal$ 还是 $Prim$ 了。但是由于本蒟蒻不知道在有向边的情况下怎么用 $Kruskal$，所以我就用 $Prim$ 写的这道题。

但这一道题中，看数据范围能够发现显然要用堆优化版的 $Prim$，所以之后重要的就是确定 $Prim$ 的排序关键字了。

我们先假设已经在生成树中的集合叫 $S$,然后想一想，$S$ 中只经过一条边就能到达的结点中，高度最大的我们肯定要取。因为这个结点不可能绕路之后被取到，因为这是高度最大的结点，而我们经过的结点高度肯定是递减的，所以这个命题正确。

这样就满足了条件1，而条件2怎么满足呢？当然就是在满足条件1的情况下按离集合 $S$ 的距离越近越好。

总结一下，也就是说我们的排序有两个关键字，第一关键字是通向的结点的高度，第二关键字是离集合 $S$ 的距离。

代码如下：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int NR=1e5+10;
const int MR=2e6+10; 
const int INF=0x3f3f3f3f;
int n,m;
int a[NR];
int to[MR],nxt[MR],val[MR];
int head[NR];
int tot=1;
void add(int x,int y,int z)
{
	to[tot]=y;
	val[tot]=z;
	nxt[tot]=head[x];
	head[x]=tot++;
}
int ans1;
ll ans2;
bool vis[NR];
int dis[NR];
struct Nd
{
	int x,h,d;
	bool operator <(const Nd &A) const
	{
		if(A.h!=h) return h<A.h;
		return d>A.d;
	}
};
priority_queue<Nd> q;
Nd tmp;
void prim(int s)
{
	memset(dis,0x3f,sizeof(dis));
	memset(vis,0,sizeof(vis));
	tmp.x=s,tmp.h=a[1],tmp.d=0;dis[s]=0;
	q.push(tmp);
	while(!q.empty())
	{
		int x=q.top().x;
		q.pop();
		if(vis[x]) continue;
		if(dis[x]>=INF) return;
		ans1++,ans2+=1ll*dis[x];vis[x]=1;
		for(int i=head[x];i;i=nxt[i])
		{
			int y=to[i];
			if(dis[y]>val[i]&&!vis[y])
			{
				dis[y]=val[i];
				tmp.x=y,tmp.h=a[y],tmp.d=dis[y];
				q.push(tmp);
			}
		}
	}
}
int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch<='9'&&ch>='0'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return x*f;
}
int main()
{
//	freopen("1.in","r",stdin);
//	freopen("1.out","w",stdout);
	n=read(),m=read();
	for(int i=1;i<=n;i++) a[i]=read();
	for(int i=1;i<=m;i++)
	{
		int x=read(),y=read(),z=read();
		if(a[x]>a[y]) add(x,y,z);
		else if(a[y]>a[x]) add(y,x,z);
		else add(x,y,z),add(y,x,z);
	}
	prim(1);
	printf("%d %lld\n",ans1,ans2);
	return 0;
}

```


---

## 作者：喵の耳 (赞：3)

并查集写错少find了导致一直MLE。。。

## dfs+kruskal

因为时间胶囊无限，所以相当于回溯回祖先节点再向下dfs

先dfs一遍看最多能滑多少点，能滑到的点连边

用这些新的边跑最小生成树，排序的时候先按高度从大到小再按边权从小到大

因为显然当高度较高时能滑的点更多

code

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace gengyf{
const int maxn=1e5+5;
#define int long long
inline int read(){
	int x=0,f=1;char s=getchar();
	while(s<'0'||s>'9'){if(s=='-')f=-1;s=getchar();}
	while(s>='0'&&s<='9'){x=x*10+s-'0';s=getchar();}
	return f*x;
}
int n,m,h[maxn],sum=1,tot,ans;
struct Edge{
	int u,v,w;
}E[maxn*20];
struct edge{
	int nxt,to,w;
}e[maxn*20];
int head[maxn],cnt,fa[maxn];
bool vis[maxn];
inline void add(int from,int to,int w){
	e[++cnt].to=to;e[cnt].w=w;e[cnt].nxt=head[from];head[from]=cnt;
}
void dfs(int x){
	for(int i=head[x];i;i=e[i].nxt){
		int to=e[i].to;
		E[++tot].u=x;E[tot].v=to;E[tot].w=e[i].w;
		if(!vis[to]){
			vis[to]=1;sum++;dfs(to);
		}
	}
}
bool cmp(Edge a,Edge b){
	return h[a.v]==h[b.v]?a.w<b.w:h[a.v]>h[b.v];
}
int find(int x){
	return x==fa[x]?x:fa[x]=find(fa[x]);
}
int main(){
	n=read();m=read();
	for(int i=1;i<=n;i++){
		h[i]=read();fa[i]=i;
	}
	for(int i=1;i<=m;i++){
		int u,v,w;
		u=read();v=read();w=read();
		if(h[u]==h[v]){
			add(u,v,w);add(v,u,w);
		}
		else if(h[u]>h[v])add(u,v,w);
		else add(v,u,w);
	}
	vis[1]=1;dfs(1);
	sort(E+1,E+1+tot,cmp);
	int k=0;
	for(int i=1;i<=tot;i++){
		int u=find(E[i].u),v=find(E[i].v);
		if(u!=v){
			fa[u]=v;
			ans+=E[i].w;k++;
		}
		if(k==sum-1)break;
	}
	printf("%lld %lld",sum,ans);
	return 0;
}
}
signed main(){
	gengyf::main();
	return 0;
}
```


---

## 作者：AcerMo (赞：2)

楼下的STL看的我发慌233
我发一篇看起来不是那么乱的代码，~~毕竟强迫症~~
思路是一样的，先在原图上dfs找到能去的所有点，丢到新图里，我直接放到了priority_queue里，struct封装就好，然后记得开longlong，记得能去的点要算上1号点，记得dfs之前vis[1]附成1，我因为没有赋值，WA了1组，居然只有一组，神奇
代码
```cpp
#include<cmath>
#include<queue>
#include<cstdio>
#include<vector>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int M=1005000;
int n,m;
int high[M],vis[M];
int fa[M],siz[M];
long long int cnt,ans,tot;
struct edge
{
	int to,cost;
}add;
vector<edge>v[M];
struct edg
{
	int from,to,cost;
	bool friend operator < (edg a,edg b)
	{
		if (high[a.to]!=high[b.to]) return high[a.to]<high[b.to];
		return a.cost>b.cost; 
	}
}now;
priority_queue<edg>q;
void built(int x)
{
	for (int i=0;i<v[x].size();i++)
	{
		int go=v[x][i].to;
		int pay=v[x][i].cost;
		now.from=x,now.to=go,now.cost=pay,q.push(now);
		if (!vis[go]) vis[go]=1,built(go),cnt++;
	}
	return ;
}
int find(int x)
{
	if (x!=fa[x]) return fa[x]=find(fa[x]);
	return x;
}
void unionn(int a,int b)
{
	if (siz[a]<siz[b]) siz[b]+=siz[a],fa[a]=b;
	else siz[a]+=siz[b],fa[b]=a;
	return ;
}
void kru()
{
	while (q.size()&&tot!=cnt)
	{
		now=q.top();q.pop();
		int r1=find(now.from);
		int r2=find(now.to);
		if (r1!=r2)
		{
			ans+=now.cost;
			unionn(r1,r2);
			tot++;
		}
	}
}
void constt()
{
	for (int i=1;i<=n;i++)
	fa[i]=i,siz[i]=1;
	cnt=tot=ans=0;
	return ;
}
int main()
{
	scanf("%d%d",&n,&m);
	constt();int a,b,c;
	for (int i=1;i<=n;i++)
	scanf("%d",&high[i]);
	for (int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&a,&b,&c);
		if (high[a]<high[b]) swap(a,b);
			add.to=b;add.cost=c;v[a].push_back(add);
		if (high[a]==high[b]) 
			add.to=a,add.cost=c,v[b].push_back(add);
	}
	vis[1]=1;built(1);kru();
	cout<<cnt+1<<" "<<ans;
	return 0;
}
```

---

## 作者：Dedsec (赞：1)

## 最大景点数

由于时间胶囊是无限的，所以滑雪过程就可以类似搜索，从高节点到低节点。我们就进行一个搜索，能搜到的点即为能经过的点。

##最短距离

把边先按终点高度排序为第一关键字（从大到小），边长为第二关键字排序（从大到小）之后，就会保证优先到高点，同高点之间选最小边。


---


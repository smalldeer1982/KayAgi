# [NOIP 2015 提高组] 运输计划

## 题目背景

NOIP2015 Day2T3

## 题目描述

公元 $2044$ 年，人类进入了宇宙纪元。

L 国有 $n$ 个星球，还有 $n-1$ 条双向航道，每条航道建立在两个星球之间，这 $n-1$ 条航道连通了 L 国的所有星球。

小 P 掌管一家物流公司， 该公司有很多个运输计划，每个运输计划形如：有一艘物流飞船需要从 $u_i$ 号星球沿最快的宇航路径飞行到 $v_i$ 号星球去。显然，飞船驶过一条航道是需要时间的，对于航道 $j$，任意飞船驶过它所花费的时间为 $t_j$，并且任意两艘飞船之间不会产生任何干扰。

为了鼓励科技创新， L 国国王同意小 P 的物流公司参与 L 国的航道建设，即允许小 P 把某一条航道改造成虫洞，飞船驶过虫洞不消耗时间。

在虫洞的建设完成前小 P 的物流公司就预接了 $m$ 个运输计划。在虫洞建设完成后，这 $m$ 个运输计划会同时开始，所有飞船一起出发。当这 $m$ 个运输计划都完成时，小 P 的物流公司的阶段性工作就完成了。

如果小 P 可以自由选择将哪一条航道改造成虫洞， 试求出小 P 的物流公司完成阶段性工作所需要的最短时间是多少？

## 说明/提示

所有测试数据的范围和特点如下表所示

 ![](https://cdn.luogu.com.cn/upload/pic/1831.png) 

**请注意常数因子带来的程序效率上的影响。**

对于 $100\%$ 的数据，保证：$1 \leq a_i,b_i \leq n$，$0 \leq t_i \leq 1000$，$1 \leq u_i,v_i \leq n$。


## 样例 #1

### 输入

```
6 3 
1 2 3 
1 6 4 
3 1 7 
4 3 6 
3 5 5 
3 6 
2 5 
4 5```

### 输出

```
11```

# 题解

## 作者：CodyTheWolf (赞：953)

## 智商不够，数据结构来凑QwQ
## 这里提供一种比较暴力的做法
## ~~因为码量较大，适合对线段树，树状数组，树剖熟悉的同学做~~


------------


## 直观地理解题目：
-	在一颗**有边权的树**上有m条路径，**清零一条边**的边权使得**m条路径的最大值**最小。

## 对于最暴力的做法：
-	把n-1条边，每条都做：**清零当前边，重新统计路径最小值。**


------------

## 对于上面这种暴力做法，肯定会T，我们先解决几个问题并想想怎么优化：
**如何求树上路径的值？**

-	树剖后，对于一条边(x,y)，**我们选取最深的那个点作为边的代表**，易证**一个点只会对应一条边**，**且树根没有对应边**（画个图很好理解的）。这样就把边的问题转化成点的问题了，加棵线段树统计即可。~~这个已经是很日常的套路了。~~

**我们必须要试全部的n-1条边嘛？**

-	对于还没有清零过的**原图**，我们先算出**每条路径的值**。对于当前**最长的路径A**，**如果我们删除A以外的边，此时的最大值肯定还是A**。也就是说，**我们要删除的边肯定在A上**，这样就不一定要试全部的边了（特殊情况可能还是会）。所以说我们记录下最长路径的数据，在这里暂时**设为最长路径的数据为(a,b,c)**

**我们每次都要重新统计嘛？**

-	很容易能想到，如果清零一条边B，在m条路径中，如果**某条路径不包含B是不用更新的。**

-	因此我们换个思路，如果我们清零B，要更新答案，只需要知道**经过B的路径中最大的那一个**和**不经过B的路径中最大的那一个**，分别**设为路径C,D**。更新答案，只需（**取C减去边B的值**和**不经过B最大的路径值**）求最大值，再和**已统计答案取最小值**即可。

-	即：**ans=min(ans,max(C-B,不经过B))** （为了方便描述，用编号代替权值）

-	对于C，因为我们只在A上清零边，又因为A是最长路径，**C=A**。那么怎么求D就是关键了：

-	对于D，我们的定义是**不经过当前边的最大路径**，为了时间复杂度，我们可以**预处理**一下每条边对应的D：

-	设mx[k]为**不包含k这条边**的**最长路径权值**，对于一条路径，设它**包含的边**的集合为E，整张图边的集合为R，路径的权值为t。那么mx中的哪些位置需要拿E来更新？显然是mx[R-E]对**自己和t**求最大值(mx[R-E]=max(mx[R-E],t)),这里的R-E也就是E的补集，即**所有不在这条路径上的边**。

-	对于补集R-E我们肯定不能一个个更新。因为树剖后，**一条路径可以转化成几条链**，又因为**一条链（不管轻重）上对于的线段树编号肯定是连续**的，我们能先在这个路径上跳，记录下第i条链的数据[xi,yi]，**根据xi或者yi排序后**，我们得到几个**有序而且不相交**的区间[xi,yi]，那么就在[1,n]上**取这些区间的补集**在**mx上更新路径的值t**即可：

-	**即[1,x1-1],[y1+1,x2-1],[y2+1,x3-1]...[y(end)+1,n]**,注意最前和最后的两个区间，小心x1==1和yn==n，需要特判，不然线段树可能会出错。

-	求出了mx数组后，我们很容易能想到，如果清零一条边B，设其权值为k，**当前所有路径的最大值会变成max(c-k,mx[B])**,c为最大路径的权值，c-k就相当于清零B，mx[B]就是不经过B的最长路径。


------------


## 这样我们就把问题都解决了，所以解题步骤是：
-	1.读入数据这么多确定不写个**快读**？
-	2.把求**边**路径的问题**转化**到**点**上。
-	3.求出路径**最长的路径A**，**记录下它的信息**（a,b,c)
-	4.预处理mx数组**（mx要对应到线段树上，因为要多次区间修改）**
-	5.在(a,b)路径上的**每条边**都做：**清零**，更新一次**最小的最大路径值**，即答案。

=====

-	对于5，具体步骤是：枚举a,b上的每条边，设答案为ans，当前想清零的边为B，权值为k，那么:
-	ans = min(ans, max(c - k,mx[B]))。（mx[B]用线段树求出）


------------


## 最后再强调一下需要注意的问题：
-	1.快读！！！

-	2.在线段树上求值的时候不要把公共祖先算进去，因为LCA代表的边不在路径上，可以在最后（设两点为x,y且x深度小于y，对应的线段树编号为id[x],id[y])添加成update(id[x]+1,id[y])。

-	3.取区间补集时特判第一和最后的区间，详情见上面的内容。

-	4.第15号点，路径会有x==y的情况，用树剖可能需要特判为0.

-	5.本程序开O2交13号点RE，不开O2可以过？？（可能只有我有这个问题QwQ）


------------


# CODE：
（因为方法几乎都是数据结构，而且步骤已经讲的非常清楚了，所以注释只标个大方向，就不每行解释了，而且代码量也挺大）

```cpp
#pragma warning (disable:4996)
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#define RG register
#define mid ((x+y)>>1)
#define lson (pst<<1)
#define rson (pst<<1|1)
using namespace std;
const int maxn = 3e5 + 5, maxm = maxn << 1, inf = 0x7fffffff;
int x[maxn], y[maxn], z[maxn], p[maxn];//x,y,z为每条边的数据，p[x]为x代表边的权值
int head[maxm], nxt[maxm], v[maxm], cnt;//前向星
int son[maxn], dad[maxn], sz[maxn], depth[maxn], root;//树剖dfs1
int id[maxn], top[maxn], rak[maxn], num;//树剖dfs2
int c[maxn], d[maxn], srt[maxn];//记录区间并排序的数组
int ma, mb, mc;//最大路径的记录
int n, m;

struct Binary_Indexed_Tree//求和树状数组
{
	int a[maxn];

	inline int lowbit(int k) { return k & (-k); }
	inline void update(int x, int k) { for (int i = x; i <= n; i += lowbit(i))	a[i] += k; }
	inline int query(int x) { int i = x, ans = 0; for (i = x; i >= 1; i -= lowbit(i))	ans += a[i]; return ans; }
	inline void build(int x) { for (int i = 1; i <= n; i++)	update(i, p[rak[i]]); }
	inline int sum(int l, int r) { return query(r) - query(l - 1); }
}BIT;

inline int max(int x, int y) { return x > y ? x : y; }
inline int min(int x, int y) { return x < y ? x : y; }

struct Segment_Tree//最大值线段树
{
	int mx[maxn << 2], tag[maxn << 2];

	inline void pushdown(int pst)
	{
		if (!tag[pst])	return;
		int k = tag[pst];
		mx[lson] = max(mx[lson], k), mx[rson] = max(mx[rson], k);
		tag[lson] = max(tag[lson], k), tag[rson] = max(tag[rson], k);
		tag[pst] = 0; return;
	}

	inline void pushup(int pst) { mx[pst] = max(mx[lson], mx[rson]); }

	inline void update(int x, int y, int pst, int l, int r, int k)
	{
		if (x > y || y<l || x>r)	return;
		if (l <= x && y <= r) { mx[pst] = max(mx[pst], k), tag[pst] = max(tag[pst], k); return; }
		pushdown(pst);
		update(x, mid, lson, l, r, k), update(mid + 1, y, rson, l, r, k);
		pushup(pst); return;
	}

	inline int query(int x, int y, int pst, int p)
	{
		if (x == y)	return mx[pst];
		pushdown(pst);
		if (p <= mid)	return query(x, mid, lson, p);
		else return query(mid + 1, y, rson, p);
	}
}ST;

inline void addline(int x, int y) { v[cnt] = y, nxt[cnt] = head[x], head[x] = cnt++; }

inline int read()
{
	RG char c = getchar(); RG int x = 0;
	while (c<'0' || c>'9')	c = getchar();
	while (c >= '0'&&c <= '9')	x = (x << 3) + (x << 1) + c - '0', c = getchar();
	return x;
}

inline void dfs1(int x, int f, int d)//树剖
{
	dad[x] = f, depth[x] = d, sz[x] = 1;
	for (RG int i = head[x]; ~i; i = nxt[i])
	{
		if (v[i] == f)	continue;
		dfs1(v[i], x, d + 1);
		sz[x] += sz[v[i]];
		if (sz[v[i]] > sz[son[x]])	son[x] = v[i];
	}
	return;
}

inline void dfs2(int x, int t)//树剖
{
	top[x] = t, id[x] = ++num, rak[id[x]] = x;
	if (!son[x])	return;
	dfs2(son[x], t);
	for (RG int i = head[x]; ~i; i = nxt[i])
		if (v[i] != dad[x] && v[i] != son[x])	dfs2(v[i], v[i]);
	return;
}

inline int sum(int x, int y)//求某条路径的权值
{
	RG int tx = top[x], ty = top[y], ans = 0;
	while (tx != ty)
	{
		if (depth[tx] >= depth[ty])	ans += BIT.sum(id[tx], id[x]), x = dad[tx], tx = top[x];
		else ans += BIT.sum(id[ty], id[y]), y = dad[ty], ty = top[y];
	}
	if (id[x] <= id[y])	ans += BIT.sum(id[x] + 1, id[y]);
	else ans += BIT.sum(id[y] + 1, id[x]);
	return ans;
}

inline bool cmp(int x, int y) { return c[x] < c[y]; }

inline void update(int x, int y, int z)//更新mx数组（其实是更新最大值线段树）
{
	RG int tx = top[x], ty = top[y], t = 0;
	while (tx != ty)
	{
		if (depth[tx] >= depth[ty]) c[++t] = id[tx], d[t] = id[x], x = dad[tx], tx = top[x];
		else c[++t] = id[ty], d[t] = id[y], y = dad[ty], ty = top[y];
	}
	if (id[x] <= id[y])	c[++t] = id[x] + 1, d[t] = id[y];
	else c[++t] = id[y] + 1, d[t] = id[x];
	for (int i = 1; i <= t; i++)	srt[i] = i;
	sort(srt + 1, srt + t + 1, cmp);
	if (c[srt[1]] > 1)	ST.update(1, n, 1, 1, c[srt[1]] - 1, z);
	if (d[srt[t]] < n)	ST.update(1, n, 1, d[srt[t]] + 1, n, z);
	for (int i = 1; i < t; i++)	ST.update(1, n, 1, d[srt[i]] + 1, c[srt[i + 1]] - 1, z);
	return;
}

inline int find_ans(int x, int y)//在最大路径上遍历并清零边求答案
{
	RG int ans = inf;
	if (x == y)	return 0;
	if (depth[x] < depth[y])	swap(x, y);
	while (depth[x] != depth[y])	ans = min(ans, max(mc - p[x], ST.query(1, n, 1, id[x]))), x = dad[x];
	while (x != y)
	{
		if (depth[x] > depth[y])	ans = min(ans, max(mc - p[x], ST.query(1, n, 1, id[x]))), x = dad[x];
		else ans = min(ans, max(mc - p[y], ST.query(1, n, 1, id[y]))), y = dad[y];
	}
	return ans;
}

int main(void)
{
	memset(head, -1, sizeof(head));
	n = read(), m = read();
	for (int i = 1; i < n; i++)	x[i] = read(), y[i] = read(), z[i] = read();
	for (int i = 1; i < n; i++)	addline(x[i], y[i]), addline(y[i], x[i]);
	root = rand() % n + 1, dfs1(root, 0, 1), dfs2(root, root);//树剖
	for (int i = 1; i < n; i++)
	{
		if (depth[x[i]] > depth[y[i]])	p[x[i]] = z[i];//把深度大的点作为一条边的代表
		else p[y[i]] = z[i];
	}
	BIT.build(n);
	for (int i = 1; i <= m; i++)
	{
		RG int a = read(), b = read(), temp;
		temp = sum(a, b), update(a, b, temp);
		if (temp >= mc)	ma = a, mb = b, mc = temp;//求最大路径
	}
	printf("%d\n", find_ans(ma, mb));
	return 0;
}
```
## ~~真的很用心写的一篇题解，留个赞再走吧QwQ~~

---

## 作者：焰火俊俊 (赞：19)

**这是一篇思路清晰的题解，没有用到树链拋分等~~高深算法~~，也不会被第13个点卡常，有详细的复杂的分析，看不懂其他题解的可以试试这篇理清思路**

1.相关知识算法：**倍增求路径长度，二分，树上差分**；

2.思考思路：我们看到题目让你求的其实是减掉一条路的长度后，所有路径的最大值的最小值是多少，我们要想到这道题很可能是**二分答案**，再看数据范围nm都是十的五次方级别那这样二分的思路是有了。

那么现在我们想想，怎样进行二分？？每当我们二分了一个答案，是要保证所有的减去虫洞时间的路径都不要超过这个答案，那么真正决定这个方案可不可行的不就是**所有路径中最大的那一个减去所有可以删边权的边是否大于mid**，若小于等于，那么比他更小的那些路径自然也可以，若大于mid则不可以；

接下来我们解决怎样选上述的**可以删边权的边**，显然你可以删边权的这条边一定要是所有超过mid的所有路径的**公共边**，因为只要有一个超过mid的路径不包含，那么这个路径相当于边权没有减少，自然会超mid使答案不合法，而我们就要用**树上差分**来解决这个问题；

3.复杂度优化：对于求m个路径的长度，我们发现我们只在二分过程中用到了所有路径的最大值和路径长度，这个过程在二分过程中是不变的，**所以我们可以把求m个路径的过程放在二分之外**，以及二分的左起点即答案的最小值是**最长的路径减去减去最长的边权**；

同时求路径长度要用到**倍增知识**

4.复杂度分析：倍增求路径 o(mlogn);二分o（log300000000）；树上差分o（n）；倍增处理（n+nlogn）；

所以总复杂度为O（n+nlogn+mlogn+log(3*10^8)*n）;

同时注意**用scanf输入**，就不会被第十三个点卡啦。

我代码会尽量备注，不懂得可以私信问我；

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int n,m,x,y,cnt,fir[300010],dis[300010],w[300010][25],f[300010][25],d[300010],vis[300010],maxx,a[300010],b[300010],cha[300010],ans=1e9,edge[600010],maxbi;
struct ren{
	int e,nex,w;
}bian[600010];
void addedge(int ss,int ee,int ww){
	cnt++;
	bian[cnt].e=ee;
	bian[cnt].w=ww;
	bian[cnt].nex=fir[ss];
	fir[ss]=cnt;
}//建边
void dfs1(int u){
	for(int x=fir[u];x;x=bian[x].nex){
		int en=bian[x].e;
		if(vis[en]==0){
			vis[en]=1;
			d[en]=d[u]+1;		
			f[en][0]=u;
			w[en][0]=bian[x].w;
			dfs1(en);
		}
	}
}//处理倍增要用到的深度d，祖先f，路径和w；
int lujing(int a,int b){
	int ans=0;
	if(d[a]<d[b])swap(a,b);
	for(int i=20;i>=0;i--)
	if(d[f[a][i]]>=d[b]){
		ans+=w[a][i];
		a=f[a][i];
	}
	if(a==b)return ans;
	for(int i=20;i>=0;i--)
	if(f[a][i]!=f[b][i]){
		ans+=w[a][i]+w[b][i];
		a=f[a][i];
		b=f[b][i];
	}
	ans+=w[a][0]+w[b][0];
	return ans;
}//倍增求路径
int lca(int a,int b){
	if(d[a]<d[b])swap(a,b);
	for(int i=20;i>=0;i--)
	if(d[f[a][i]]>=d[b])a=f[a][i];
	if(a==b)return a;
	for(int i=20;i>=0;i--)
	if(f[a][i]!=f[b][i]){
		a=f[a][i];
		b=f[b][i];
	}
	return f[a][0];
}//倍增求lca，在树上差分时会用到；
void dfs2(int u){
	for(int x=fir[u];x;x=bian[x].nex){
		int en=bian[x].e;
		if(vis[en]==0){
		vis[en]=1;
		dfs2(en);
		cha[u]+=cha[en]; 
		edge[x]=cha[en];
	}
}
}//树上差分；
int main(){
	cin>>n>>m;
	for(int i=1;i<n;i++){
		int w;		
		scanf("%d%d%d",&x,&y,&w);
		addedge(x,y,w);
		addedge(y,x,w);
	}
	f[1][0]=1;d[1]=1;vis[1]=1;
	dfs1(1);//倍增处理；
	for(int i=1;i<=20;i++)
	    for(int u=1;u<=n;u++){
	    	f[u][i]=f[f[u][i-1]][i-1];
	    	w[u][i]=w[f[u][i-1]][i-1]+w[u][i-1];
		}//倍增处理
	for(int i=1;i<=m;i++){
		scanf("%d%d",&a[i],&b[i]);
		dis[i]=lujing(a[i],b[i]);
		maxx=max(maxx,dis[i]);
	}//求路径长度以及其最大值；
	for(int i=1;i<=2*(n-1);i++)
	maxbi=max(maxbi,bian[i].w);
	int l=maxx-maxbi,r=300000000,mid;//注意l取值
	while(l<=r){//二分
		mid=(l+r)/2;
		int t=0,maxbian=0;
		memset(edge,0,sizeof(edge));
		memset(cha,0,sizeof(cha));
		memset(vis,0,sizeof(vis));
		for(int i=1;i<=m;i++)
		if(dis[i]>mid){
			cha[a[i]]++;
			cha[b[i]]++;
			cha[lca(a[i],b[i])]-=2;
			t++;
		}
		if(t==0){
			ans=min(ans,mid);
			r=mid-1;
			continue;
		}//没有超过mid的肯定符合；

		vis[1]=1;
		dfs2(1);	
		for(int i=1;i<=2*(n-1);i++)
		if(edge[i]==t)maxbian=max(maxbian,bian[i].w);
		if(maxx-maxbian<=mid){
			ans=min(ans,mid);
			r=mid-1;
		}
		else l=mid+1;
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：糪眾脦颰罷 (赞：7)

## 一个O（n）的解法。
### 不难发现有如下性质：
- 被改造成虫洞的边一定在最长路径上

那么，我们用类似提直径的方法把**这条路径给拎出来**

![](https://cdn.luogu.com.cn/upload/pic/72262.png)

就会形成这样的一棵树。

那么，对于一条边，若其被改成虫洞，最长路径会有如下三种情况:

- 依然是当前的最长路径

- 被改造边左端点的最长路径

- 被改造边右端点的最长路径

难道我们不用考虑经过该边的路径吗？？

当然不用。

我们已经是在**最长路径**上改造边了，**而最长路径是长于任何一条路径的**（废话），那么经过该边的任何路径在此边被改造后**依然短于最长路径**，故不用考虑。

至于求两端的最长路径，我们可以前缀和后缀分别维护一下。



------------


### 那么怎么求前缀（后缀）呢？

我们可以在每个点开个vector,对于一条路径，我们把另一端点以及路径的编号加到vector中。

然后，再开个vis数组，表示这个点是否被访问过。

在遍历时，我们访问所有以这一点为一端点的路径标号$id$和另一端点$y$，若另$vis[y]=true$，就拿$id$的长度去更新即可。（口胡不清，这最好手动模拟一下）

### 至于求路径长和LCA呢？

额，树剖我是当常数看的。。。

~~实在不行你可以Tarjan离线预处理啊~~

代码（~~巨丑无比~~）:
```
#include<bits/stdc++.h>
#define reg register int
#define MAXN 300010
using namespace std;
int n,m,head[MAXN],dis[MAXN],tot,maxx,bh,pre[MAXN],sumfr[MAXN],sumla[MAXN],num[MAXN],lian[MAXN],ans=2e9+7;
bool mark[MAXN],vis[MAXN];
struct node {
	int st,ed,lca,d;
} P[MAXN];
struct Edge {//前向星
	int ed,v,last;
} G[MAXN*2];
struct que {
	int ed,id;
};
vector<que> Q[MAXN];
struct s__ {//树剖预处理
	int son[MAXN],size[MAXN],top[MAXN],deep[MAXN];
	void DFS1(int x,int fa,int v) {
		dis[x]=dis[fa]+v;
		pre[x]=fa;
		deep[x]=deep[fa]+1;
		size[x]=1;
		for(int i=head[x]; ~i; i=G[i].last) {
			int t=G[i].ed,v=G[i].v;
			if(t==fa)continue;
			DFS1(t,x,v);
			size[x]+=size[t];
			if(size[son[x]]<size[t])son[x]=t;
		}
	}
	void DFS2(int x,int fa,int zu) {
		top[x]=zu;
		if(son[x])DFS2(son[x],x,zu);
		for(int i=head[x]; ~i; i=G[i].last) {
			int t=G[i].ed;
			if(t==son[x]||t==fa)continue;
			DFS2(t,x,t);
		}
	}
	int LCA(int x,int y) {
		while(top[x]!=top[y]) {
			if(deep[top[x]]<deep[top[y]])swap(x,y);
			x=pre[top[x]];
		}
		if(deep[x]>deep[y])swap(x,y);
		return x;
	}
} shupou;
void Rd(int &res) {//读优
	res=0;
	char ch=getchar();
	while('0'>ch||ch>'9')ch=getchar();
	while('0'<=ch&&ch<='9')res=(res<<3)+(res<<1)+(ch-'0'),ch=getchar();
}
void Add(int st,int ed,int v) {
	tot++;
	G[tot]=Edge {ed,v,head[st]};
	head[st]=tot;
}
void DFS(int x,int fa,int &bb) {
	num[x]=bb;
	for(int i=head[x]; ~i; i=G[i].last) {
		int t=G[i].ed;
		if(t==fa)continue;
		if(!mark[t])continue;
		lian[bb]=G[i].v;
		bb++;
		DFS(t,x,bb);
	}
}
void DFSla(int x,int fa,int zu) {//后缀
	vis[x]=1;
	for(int i=0; i<Q[x].size(); i++) {//访问vector
		int t=Q[x][i].ed,id=Q[x][i].id;
		if(vis[t]==1)sumla[zu]=max(sumla[zu],P[id].d);//更新
	}
	int nex=0;
	for(int i=head[x]; ~i; i=G[i].last) {
		int t=G[i].ed,v=G[i].v;
		if(t==fa)continue;
		if(mark[t]) {//优先遍历两旁伸出的子树
			nex=t;
			continue;
		}
		DFSla(t,x,zu);
	}
	if(nex) {
		sumla[num[nex]]=sumla[num[x]];//更新下一个的后缀
		if(nex==P[bh].st)return;//下一个点如果是另一端点的话就直接退出
		DFSla(nex,x,num[nex]);
	}
}
void DFSfr(int x,int fa,int zu) {//前缀
	vis[x]=1;
	for(int i=0; i<Q[x].size(); i++) {//访问vector
		int t=Q[x][i].ed,id=Q[x][i].id;
		if(vis[t]==1)sumfr[zu]=max(sumfr[zu],P[id].d);//更新
	}
	int nex=0;
	for(int i=head[x]; ~i; i=G[i].last) {
		int t=G[i].ed,v=G[i].v;
		if(t==fa)continue;
		if(mark[t]) {//优先遍历两旁伸出的子树
			nex=t;
			continue;
		}
		DFSfr(t,x,zu);
	}
	if(nex) {
		sumfr[num[nex]]=sumfr[num[x]];//更新下一个的前缀
		if(nex==P[bh].ed)return;//下一个点如果是另一端点的话就直接退出
		DFSfr(nex,x,num[nex]);
	}
}
int main() {
	memset(head,-1,sizeof(head));
	Rd(n),Rd(m);
	for(int i=1; i<=n-1; i++) {
		int x,y,z;
		Rd(x),Rd(y),Rd(z);
		Add(x,y,z);
		Add(y,x,z);
	}
	shupou.DFS1(1,0,0);
	shupou.DFS2(1,0,1);
	for(int i=1; i<=m; i++) {
		Rd(P[i].st),Rd(P[i].ed);
		P[i].lca=shupou.LCA(P[i].st,P[i].ed);
		P[i].d=dis[P[i].st]+dis[P[i].ed]-2*dis[P[i].lca];
		if(P[i].d>maxx)maxx=P[i].d,bh=i;
		Q[P[i].st].push_back(que {P[i].ed,i});
		Q[P[i].ed].push_back(que {P[i].st,i});
	}
	int st=P[bh].st,ed=P[bh].ed,lca=P[bh].lca;
	while(st!=lca)mark[st]=true,st=pre[st];
	while(ed!=lca)mark[ed]=true,ed=pre[ed];
	mark[lca]=true;
	int bb=1;
	DFS(P[bh].st,0,bb);
	DFSfr(P[bh].st,0,num[P[bh].st]);
	memset(vis,false,sizeof(vis));
	DFSla(P[bh].ed,0,num[P[bh].ed]);
	for(int i=1;i<=bb;i++){//更新最终答案
		int res=0;
		res=max(res,P[bh].d-lian[i]);
		res=max(res,sumfr[i]);
		res=max(res,sumla[i+1]);
		ans=min(ans,res);
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Cesare (赞：7)

## $Solution$

想想还是来发个题解吧，毕竟写了两个小时。

一档分一档分讲，慢慢来。


### $Subtask1: n <= 3000\ (50pts)$ 

这档分就是考虑预处理倍增点和边权数组，做到 $O(log\ n)$ 求树上两点之间的路径，然后暴力枚举把哪一条边边权变为 $0$ ，每次更新边权数组然后 $m$ 个点对距离全部求一遍取 $Max$ 即可，复杂度 $O(nm\ log\ n)$ 。


### $Subtask2: m == 1\ (10 pts)$

$ps:$ 此处说的 $10pts$ 是指使你的得分在 $Subtask1$ 的基础上增加 $10pts$ 。

只有一条路径要跑，就考虑直接求这条路径，暴跳的同时求一下路径中权值最大的那条边，总价值减去权值最大的边的边权就是答案，复杂度 $O(n)$ 。


### $Subtask3: v = u + 1\ (20 pts)$ 

也就是一条链的情况。
考虑后面给你的 $u \to v$ 的路径是确定的，我们用线段树维护区间和，二分时间，如果当前这段区间和 > 上界时间，就记录下当前的区间和以及区间。再看区间 Max 去掉后是否可以，不可以直接返回 $0$ 。 

然后如果又有一段区间不行了，就跟前面的区间取交集，没有交集就返回 $0$ ，有交集就再询问区间 Max ，跟当前的最大区间和取差看还能不能满足答案。做到底即可。复杂度 $O(n\ log^2\ n)$ 。


### $Subtask4: n <= 3 \times 10^5\ (20pts)$ 

也就是正解了。

考虑刚刚的 $Subtask3$ 的做法如何转移到树上，直接用树剖复杂度显然不对，可以考虑用树上差分去记录每条边被包含的次数，然后枚举一个点是否被所有不满足的路径包含，如果是就判一下最大路径和减去这条边的边权后是否满足，满足直接返回 $1$ ，到底还没有就是 $0$ 。

如此，这道题就做完了。

## $Code:$ 

```cpp
#include <bits/stdc++.h>
//#include <tr1/unordered_map>
//#include"Bignum/bignum.h"
//#define big bignum
#define lowbit(x) (x & -x)
#define debug(x) (cout << "#x = " << (x) << endl)
#define Set(x, i) memset (x, i, sizeof(x))
#define R register
#define For(i, j, k) for(R int i = (j); i <= (int) (k); ++i)
#define Rep(i, j, k) for(R int i = (j); i >= (int) (k); --i)
#define Cross(i, j, k) for(R int i = (j); i; i = (k))
using namespace std;
typedef long long ll;
const ll N = 300011;
const ll INF = 5e16;

namespace IO {

	inline char gc() {
		static char buf[100000], *p1 = buf, *p2 = buf;
		return (p1 == p2) && (p2 = (p1 = buf) +
			fread(buf, 1, 100000, stdin), p1 == p2)? EOF: *p1++;
	}

	#define dd ch = getchar()
	inline int read() {
		R int x = 0, f = 0; R char dd;
		for (; !isdigit(ch); dd) f ^= (ch == '-');
		for (; isdigit(ch); dd)  x = x * 10 + (ch ^ 48);
		return f? -x: x;
	}
	#undef dd

	inline void write ( ll x ) {
		if (x < 0) x = -x, putchar('-');
		if (x > 9) write(x / 10); putchar(x % 10 | 48);
	}

	inline void wrn ( ll x ) { write(x), putchar(' '); }

	inline void wln ( ll x ) { write(x), putchar('\n'); }

	inline void wlnn ( ll x, ll y ) { wrn(x), wln(y); }

}

using IO::wln;
using IO::read;

namespace Cesare {
	
	ll Tag[N];
	int U[N], V[N];
	int n, m, uu[N], vv[N], ww[N];
	
	struct Edge {
		int To, Next, w;
	} e[N << 1];
	
	int cnt = 2, head[N];
	
	inline void add ( int u, int v, int w ) {
		e[++cnt] = (Edge) {v, head[u], w}, head[u] = cnt;
		e[++cnt] = (Edge) {u, head[v], w}, head[v] = cnt;
	}
	
	inline void Cmax ( ll &a, ll b ) { (a < b) && (a = b); }
	
	ll w[21][N];
	int dep[N], f[21][N]; 
	
	inline void dfs ( int u, int fa ) {
		dep[u] = dep[f[0][u] = fa] + 1;
		For ( i, 1, 20 ) 
			f[i][u] = f[i - 1][f[i - 1][u]], 
			w[i][u] = w[i - 1][u] + w[i - 1][f[i - 1][u]];
		Cross ( i, head[u], e[i].Next ) {
			ll v = e[i].To;
			if (v == fa) continue;
			w[0][v] = e[i].w, dfs(e[i].To, u);
		}
	}
	
	inline int LCA ( int x, int y ) {
		if (dep[x] < dep[y]) swap(x, y);
		for (int i = 20; ~i; --i) 
			if (dep[f[i][x]] >= dep[y]) x = f[i][x];
		if (x == y) return x;
		for (int i = 20; ~i; --i) 
			if (f[i][x] != f[i][y]) x = f[i][x], y = f[i][y];
		return f[0][x];
	}
	
	inline void Update ( int x, int y ) {
		ll lca = LCA(x, y);
		++Tag[x], ++Tag[y], Tag[lca] -= 2;
	}
	
	inline void Dfs ( int u, int fa ) {
		Cross ( i, head[u], e[i].Next ) {
			ll v = e[i].To;
			if (v == fa) continue;
			Dfs(v, u), Tag[u] += Tag[v];
		}
	}

	inline int IsCycle() {
		For ( i, 1, n - 1 ) 
			if (uu[i] != i || vv[i] != i + 1) return 1;
		return 0;
	}
	
	inline ll Dision ( int x, int y ) {
		ll res = 0;
		if (dep[x] < dep[y]) swap(x, y);
		for (int i = 20; ~i; --i) 
			if (dep[f[i][x]] >= dep[y]) 
				res += w[i][x], x = f[i][x];
		if (x == y) return res;
		Rep ( i, 20, 0 ) if (f[i][x] != f[i][y]) 
			res += w[i][x] + w[i][y], x = f[i][x], y = f[i][y];
		return res + w[0][x] + w[0][y];
	}
	
namespace Subtask1 {
	
	ll Ans = INF;
	
	inline void Dfs ( int u, int fa ) {
		For ( i, 1, 20 ) 
			w[i][u] = w[i - 1][u] + w[i - 1][f[i - 1][u]];
		Cross ( i, head[u], e[i].Next ) 
			if (e[i].To != f[0][u]) Dfs(e[i].To, u);
	}
	
	inline void Solve ( int pos ) {
		int W, u = uu[pos], v = vv[pos];
		int x = (dep[u] > dep[v])? u: v;
		
		W = w[0][x], w[0][x] = 0; Dfs(1, 0);
		
		ll Mx = 0;
		For ( i, 1, m ) 
			Mx = max(Mx, Dision(U[i], V[i]));
		Ans = min(Ans, Mx);
		
		w[0][x] = W; Dfs(x, 0);
	}
	
	void main() {
		For ( i, 1, n - 1 ) Solve(i);
		wln(Ans), exit(0);
	}
	
}
	
namespace Subtask2 {
	
	inline ll Solve ( int x, int y ) {
		ll Mx = 0, res = 0;
		for (; x != y; ) {
			if (dep[x] < dep[y]) swap(x, y);
			res += w[0][x], Mx = max(Mx, w[0][x]), x = f[0][x];
		} return res - Mx;
	}
	
	void main() {
		wln(Solve(U[1], V[1])), exit(0);
	}
	
}

namespace Subtask3 {
	
	/*
		一条链怎么做。 
		考虑后面给你的 u -> v 的路径是确定的。 
		线段树维护区间和，二分时间。 
		如果当前这段区间和 > 上界时间， 
		记录下当前的区间和以及区间 
		再看区间 Max 去掉后是否可以，不可以直接 -1 。 
		然后如果又有一段区间不行了。 
		跟前面的区间取交集，没有交集就是 -1 。 
		有交集就再询问区间 Max ，跟当前的最大区间和 
		取差看行不行。 
		做到底即可。 
	*/
	
	#define ls(x) (x << 1)
	#define rs(x) (x << 1 | 1)
	#define mid ((l + r) >> 1)
	
	ll T[N << 2], Mx[N << 2];
	
	inline void pushUp ( int p ) {
		T[p] = T[ls(p)] + T[rs(p)];
		Mx[p] = max(Mx[ls(p)], Mx[rs(p)]);
	}
	
	inline void build ( int p, int l, int r ) {
		if (l == r) return (void) (T[p] = Mx[p] = ww[l]);
		build(ls(p), l, mid); build(rs(p), mid + 1, r); pushUp(p);
	}
	
	inline ll QuerySum ( int p, int l, int r, int ul, int ur, ll res = 0 ) {
		if (l >= ul && r <= ur) return T[p];
		if (mid >= ul) res += QuerySum(ls(p), l, mid, ul, ur);
		if (mid < ur)  res += QuerySum(rs(p), mid + 1, r, ul, ur);
		return res;
	}
	
	inline ll QueryMax ( int p, int l, int r, int ul, int ur, ll res = 0 ) {
		if (l >= ul && r <= ur) return Mx[p];
		if (mid >= ul) Cmax(res, QueryMax(ls(p), l, mid, ul, ur));
		if (mid < ur)  Cmax(res, QueryMax(rs(p), mid + 1, r, ul, ur));
		return res;
	}
	
	inline int Check ( ll x ) {
		ll Ms = 0;
		int nowl = 1, nowr = n;
		For ( i, 1, m ) {
			int u = U[i], v = V[i];
			ll s = QuerySum(1, 1, n, u, v - 1);
			
			if (s <= x) continue;
			
			nowl = max(nowl, u), 
			nowr = min(nowr, v);
			if (nowl > nowr) return 0;
			
			Ms = max(Ms, s);
			if (Ms - QueryMax(1, 1, n, nowl, nowr) > x) return 0;
		} return 1;
	}
	
	void main() {
		build(1, 1, n);
		
		ll l = 1, r = 1e10;
		while (l <= r) {
			ll Mid = (l + r) >> 1;
			Check(Mid)? r = Mid - 1: l = Mid + 1;
		} wln(l), exit(0);
	}
	
}
	
	int cc, Need[N];
	
	inline int Check ( ll x ) {
		cc = 0;
		ll ma = 0;
		Set (Tag, 0);
		For ( i, 1, m ) {
			ll dis = Dision(U[i], V[i]);
			if (dis > x) Need[++cc] = i, ma = max(ma, dis);
		} 
		if (!cc) return 1;
		
		For ( i, 1, cc ) Update(U[Need[i]], V[Need[i]]);
		
		Dfs(1, 0);
		For ( i, 1, n ) if (Tag[i] == cc) 
			if (ma - w[0][i] <= x) return 1;
		return 0;
	}
	
	ll sum;
	int mxx;
	
	int main() {
		n = read(), m = read();
		for (int i = 1, w; i < n; ++i) 
			uu[i] = read(), vv[i] = read(), 
			ww[i] = read(), add(uu[i], vv[i], ww[i]), mxx = max(mxx, ww[i]); 
		dfs(1, 0);
		
		for (int i = 1; i <= m; ++i) 
			U[i] = read(), V[i] = read();
		For ( i, 1, m ) Cmax(sum, Dision(U[i], V[i]));
		
		if (n <= 2000) Subtask1 :: main();
		else if (m == 1) Subtask2 :: main();
		else if (!IsCycle()) Subtask3 :: main();
		
		ll l = sum - mxx, r = sum;
		while (l <= r) {
			ll Mid = (l + r) >> 1;
			Check(Mid)? r = Mid - 1: l = Mid + 1;
		} return wln(l), 0;
	}
	
}

int main()
{
//	freopen("transport17.in", "r", stdin);
//	freopen(".out", "w", stdout);

	return Cesare :: main();
}

/*

*/


```

---

## 作者：_Deer_Peach_ (赞：5)

背景：学习 LCA 时的练习题，~~被卡了整整两天~~，于是发篇题解巩固一下。

题意简述：

改其中一条边使其改为虫洞（即改权值为 $0$），使得所有运输计划的时间的最大值最小。

思路：

二分，倍增与树上差分。

考虑二分答案，设所有运输计划的时间的最大的最小值为 $k$，判断是否能够改一条边权值为 $0$ 使得所有运输路径的权值小于等于 $k$。

首先可以将运输计划分类：
1. 路径权值小于 $k$；
2. 路径权值大于 $k$。

改造的边一定是在第二类运输计划的路径的公共边上，否则不可能使所有运输路径的权值小于等于 $k$，因为这一条边不在其中一个第二类运输计划的路径上，那么这一个运输计划就不会改变路径权值之和。

接下来考虑如何选择边。用一个数组记录 $x$ 与它父节点组成的边被覆盖的次数，当然不能直接算，这里用差分优化。最终被覆盖的总次数为第二种运输计划的数量就是可以选择修改的边。

求出所有可以修改的边的最大权值，再判断最大的运输路径的权值和减去可以修改的边的最大权值是否小于等于 $k$。

最后，求路径权值和肯定不能暴力，可以用一个数组记录从根节点到当前节点的权值和，再预处理一个倍增表，就可以比较快速求出两点之间的路径权值和。

代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)
const int N=300005;
int n,m,maxpllen;
struct node{
	int x,w;
};
vector<node>a[N];//领接表存边
int fath[N][30];//倍增表
int lg[N],deep[N],dis[N];//lg[i]=log2(i),deep[i]为i在树中的深度，dis[i]表示根节点到节点i的权值和
int num[N],lca[N],pldis[N];//num为差分数组，lca[i]为第i个运输计划的两点的最近公共祖先,pldis[i]为第i个运输计划的路径权值之和
struct plan{
	int s,t;
}pl[N];//运输计划
void dfs(int x,int fa){//预处理
	deep[x]=deep[fa]+1;
	fath[x][0]=fa;
	int len=a[x].size();
	for(int i=0;i<len;i++){
		int y=a[x][i].x;
		if(y==fa)continue;
		dis[y]=dis[x]+a[x][i].w;
		dfs(y,x);
	}
}int LCA(int x,int y){//求最近公共祖先
	if(deep[x]<deep[y])swap(x,y);
	while(deep[x]>deep[y])x=fath[x][lg[deep[x]-deep[y]]];
	if(x==y)return x;
	for(int i=lg[deep[x]];i>=0;i--)
		if(fath[x][i]!=fath[y][i])x=fath[x][i],y=fath[y][i];
	return fath[x][0];
}void dfs2(int x,int fa){//树上差分
	int len=a[x].size();
	for(int i=0;i<len;i++){
		int y=a[x][i].x;
		if(y==fa)continue;
		dfs2(y,x);
		num[x]+=num[y];
	}
}bool check(int x){//二分判断
	//cout<<"\n------\n"<<x<<endl;
	memset(num,0,sizeof(num));
	int cnt=0,maxlen=0;
	for(int i=1;i<=m;i++){
		int pllen=pldis[i];
		if(pllen>x){//第二种运输计划
			num[pl[i].s]++;//差分处理
			num[pl[i].t]++;
			num[lca[i]]-=2;
			cnt++;
		}maxlen=max(maxlen,pllen);
	}if(cnt==0)return true;//没有第二种运输计划则满足
	dfs2(1,0);//用差分还原出原数组
	/*cout<<x<<endl;
	for(int i=1;i<=n;i++)cout<<num[i]<<" ";
	cout<<endl;*/
	for(int i=2;i<=n;i++){//是否有满足条件的
		if(num[i]!=cnt)continue;
		if(maxlen-(dis[i]-dis[fath[i][0]])<=x)return true;
	}return false;
}
signed main(){
	scanf("%lld%lld",&n,&m);int l=0,r=0,mid;
	for(int i=2;i<=n;i++)lg[i]=lg[i>>1]+1;
	for(int i=1,x,y,w;i<n;i++){
		scanf("%lld%lld%lld",&x,&y,&w);
		a[x].push_back(node{y,w});
		a[y].push_back(node{x,w});
		l=max(l,w);
	}dfs(1,0);
	for(int i=1;i<=lg[n];i++)//预处理倍增表
		for(int j=1;j<=n;j++)
			fath[j][i]=fath[fath[j][i-1]][i-1];
	for(int i=1;i<=m;i++){
		scanf("%lld%lld",&pl[i].s,&pl[i].t);
		lca[i]=LCA(pl[i].s,pl[i].t);
		pldis[i]=dis[pl[i].s]+dis[pl[i].t]-dis[lca[i]]*2;
		r=max(r,pldis[i]);
	}maxpllen=r;
		/*for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				cout<<LCA(i,j)<<" ";
			}cout<<endl;
		}*/
	l=r-l;while(l<r){//二分答案
		mid=l+r>>1;
		check(mid)?r=mid:l=mid+1;
	}cout<<r;
	return 0;
} 
```

---

## 作者：AC_love (赞：5)

[第一篇题解](https://www.luogu.com.cn/blog/CodyTheWolf/solution-p2680)提到了一种极其暴力码量极大极其考验码力的做法，我的方法与他的类似，然而摒弃了一点人类智慧，换上了一点更暴力的数据结构，相比他的方法也更容易理解，但是也更难调，如果诸位真心觉得我的代码长度很阴间，那看个乐子就行，了解一下此题的奇葩正解做法。

题意：一颗有边权的树上有 $m$ 条路径，选择其中任意一条边将其边权转为 $0$ 使最长路径最短。

首先我们可以想到：我们要改变的边一定在起初的最长路径上。否则不管你改哪条边，最长路径的长度都没有变，相当于改得毫无意义。

那么我们可以暴力枚举最长路径上的每一条边，看看修改这条边之后答案是多少，然后把所有答案取 $\min$，就是我们最终的答案。

这是一个非常直观的思路，也非常好想，然而很多人想到这里也就到此为止了，因为这个做法看起来就不是一个时间复杂度正确的可行做法，而且看起来也确实有点过于暴力了。

但是数据结构魔怔人说：我们可以用数据结构来优化暴力。

首先找最长路径，这个肯定是树链剖分，没什么好说的。

然后我们暴力枚举每一条可能修改的边的时候，需要知道修改这条边之后答案是多少，这一步该怎么办呢？

我们注意到，修改一条边的时候，假如这条边边权为 $l$，则所有包含这条边的路径的长度都会减少 $l$，而这些路径的相对大小不变，所以在所有包含这条边的路径里，最长的路径一定是**原本的最长路径**。而对于所有不包含这条边的路径里，它们内部的相对大小也是不变的，所以此时可能成为最长路径的两条路径其实就是：**原本的最长路径，不包含改变的边的所有路径里的最长路径**。

那么显然我们可以针对每一条边预处理出不经过这条边的最长路径。

这个怎么处理呢？

我们不妨先树剖再开一棵线段树，每次我们读入一条新路径就在这条路径的节点上打上标记，然后我们对整棵线段树做一个区间赋值，但是赋值的时候要略过打标记的节点。

听起来好像很对，但是有的同学反应比较迅速，想起来：因为赋值的时候必须和所有原有的值都比较一下看应该取哪个，那这样做的话就必须一直传到底，复杂度就是 $O(n)$ 的，完全去除了线段树复杂度低的优势，顺便保留了线段树常数巨大的劣势，这不就寄了吗？

说得好，如果我们一直传到底的话，确实如此，但是我们真的需要一直传到底吗？

我们可以画个图来理解一下。

![](https://cdn.luogu.com.cn/upload/image_hosting/qdpr7o2t.png)

假如我们当前某条路径树剖之后经过的节点是这些蓝色的子节点。

显然，因为我们打标记的时候是区间赋值的，所以显然这颗线段树会是这样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/m5b4y75u.png)

其中蓝色的节点是打过 tag 的节点。

此时我们可以给每个节点维护一个 havetag 标记，表示这个点的子节点里有没有打过 tag 的节点。

![](https://cdn.luogu.com.cn/upload/image_hosting/r41q0skr.png)

图中黑色节点是有 havetag 标记的，而白色节点没有。

显然，如果我们发现我们当前下传到了一个白色节点，那么这个节点的子节点里一定没有任何一个点是有 tag 的，我们不妨直接在这个节点打上一个 lazytag 表示待下传的值（这种暴力做法的 tag 有点多，注意不要混淆），如果我们发现这个点已经有过一个 lazytag 了，那么我们就把两个 lazytag 取最大值。

而如果下传到了一个黑色节点，我们不能直接打 lazytag，但是由于这个点本身没有 tag，所以我们可以修改一下当前这个点的最大值，然后继续下传。

如果传到了一个蓝色节点，说明这个节点的子节点都在这条路径上，此时不能再下传了，直接返回即可。

然后每次区间赋值之后，记得取消你所有的 tag 和 havetag 标记即可。

等所有路径都赋值完了之后，你再下传所有的 lazytag 就行。

思路非常好理解，接下来说这部分的代码。

首先是定义结构体，里面有六个值：当前节点维护的左右区间，当前节点的 maxn 的值，当前节点有没有 tag 和 havetag，还有待下传的 lazytag。

```cpp
struct tree2
{
	int l;
	int r;
	int maxn;
	// maxn 表示不经过这条边的所有路线中的最长的那条 
	bool tag;
	// tag 是我们之前打上的标记 
	bool havetag;
	// havetag 表示该节点的子节点中是否含有 tag 
	int lazy;
	// lazy 表示我们的待下传的最大值 
};
tree2 tt[N * 4];
```

然后我们考虑如何传 havetag 标记，其实如果一个点需要打 havetag 标记，无非就两种情况：

1. 该节点的子节点有 tag 标记
2. 该节点的子节点有 havetag 标记

具体代码实现如下：

```cpp
void pushup_tag(int p)
{
	tt[p].havetag = (tt[p * 2].havetag || tt[p * 2 + 1].havetag || tt[p * 2].tag || tt[p * 2 + 1].tag);
}
```

然后是打 tag，这一部分和普通的线段树的区间修改很像，不需过多赘述。

不过还有一点值得注意，因为每次区间赋值之后你还要清除 tag，所以 set_tag 可以直接传一个参数 tag 表示你是要打 tag 还是要清除 tag，这样就不用像我最开始一样傻了吧唧地写了一个 set_tag 再写了一个 clear_tag 折磨自己了。

```cpp
void set_tag(int p, int l, int r, bool tag)
{
	if(l <= tt[p].l && tt[p].r <= r)
	{
		tt[p].tag = tag;
		return;
	}
	int mid = (tt[p].l + tt[p].r) / 2;
	if(mid >= l)
		set_tag(p * 2, l, r, tag);
	if(mid < r)
		set_tag(p * 2 + 1, l, r, tag);
	pushup_tag(p);
}
```

然后路径修改，这一部分和树链剖分的模板也很像，不再过多赘述：

```cpp
void path_set_tag(int x, int y, bool tag)
{
	while(d[x].top != d[y].top)
	{
		if(d[d[x].top].dep < d[d[y].top].dep)
			swap(x, y);
		set_tag(1, d[d[x].top].id, d[x].id, tag);
		x = d[d[x].top].fa;
	}
	if(d[x].dep < d[y].dep)
		swap(x, y);
	set_tag(1, d[y].id + 1, d[x].id, tag);
}
```

然后是我们的重头戏，下传懒标记。

不过思路之前说过了，按照这个思路老老实实模拟即可：

```cpp
void set_lazy(int p, int lazy)
{
	if(tt[p].havetag == 0 && tt[p].tag == 0)
	{
		// 当前这个节点的子节点里没有带 tag 的，这时候我们可以直接打上标记 
		tt[p].lazy = max(tt[p].lazy, lazy);
		tt[p].maxn = max(tt[p].maxn, lazy);
		return;
	}
	if(tt[p].lazy >= lazy)
	{
		// 当前节点已经有了大于 lazy 的懒标记，那么我们就不用再传下去了，因为即使传下去也没什么用，照样以后会被覆盖
		return; 
	}
	if(!tt[p].tag)
		tt[p].maxn = max(tt[p].maxn, lazy);
		// 这个节点的子节点里有 tag 但是该节点没有 tag，那么我们可以直接修改它的 maxn 的值
	if(tt[p].l == tt[p].r || tt[p].tag)
	{
		// 已经传到底层或传到有 tag 的点了，传不下去了 
		return;
	}
	set_lazy(p * 2, lazy);
	set_lazy(p * 2 + 1, lazy);
}
```

下传 lazytag：

```cpp
int b[N];
// b 数组记录对于每条边不经过这条边的路线的最大值 
void spread(int p)
// 把所有 lazy 标记传到底让我们知道每条边的信息 
// p 是当前节点编号 
{
	if(tt[p].l == tt[p].r)
	{
		b[tt[p].l] = tt[p].maxn;
		return;
	}
	tt[p * 2].maxn = max(tt[p * 2].maxn, tt[p].lazy);
	tt[p * 2 + 1].maxn = max(tt[p * 2 + 1].maxn, tt[p].lazy);
	tt[p * 2].lazy = max(tt[p * 2].lazy, tt[p].lazy);
	tt[p * 2 + 1].lazy = max(tt[p * 2 + 1].lazy, tt[p].lazy);
	spread(p * 2);
	spread(p * 2 + 1);
}
```
利用树剖信息求 LCA，然后暴力枚举每一条边：

```cpp
void find_LCA(int x, int y)
{
	while(d[x].top != d[y].top)
	{
		if(d[d[x].top].dep < d[d[y].top].dep)
			swap(x, y);
		x = d[d[x].top].fa;
	}
	if(d[x].dep < d[y].dep)
		swap(x, y);
	Lca = d[y].id;
}

void dfs3(int x)
{
	if(d[x].id == Lca)
		return;
	while(d[x].id != Lca)
	{
		minn = min(minn, max(maxn - d[x].w, b[d[x].id]));
		x = d[x].fa;
	}
}
```

这就是这种做法的核心代码。

由于本人码风问题（不压行 + 喜欢写比火车头还长的宏定义）导致我的代码长度非常长，为了不影响题解区的观感，我把完整代码放到了云剪切板里：[点我查看](https://www.luogu.com.cn/paste/srqfxecw)

那么这道题的暴力做法大致就是这样的。

完美，撒花

✿✿ヽ(°▽°)ノ✿

---

## 作者：0Io_oI0 (赞：4)

~~感谢本题教会我无数卡常技巧 qwq~~

**题目大意：**

有一个 $n$ 个结点，$n-1$ 条边的树状图，有 $m$ 次运输，每次运输从 $u_i$ 运送到 $v_i$ 的最短路径。现在可以将某个路径变成虫洞，来节省时间，求将某个路径变成虫洞后，每个任务所需要的最短时间。

**思路**

看完这道题目以后，我们的大致思路为：采用二分查找来确定最短时间。对于 $mid$，检查是否存在一条航道，将其改造成虫洞后，所有运输的最长时间不超过 mid。而在求路径长的时候我们需要用到 LCA。

**大体的步骤如下：**

1. 使用 BFS 初始化节点的父节点、深度和距离。
2. 使用倍增预处理 $up$ 数组，用来计算 LCA。 
3. 计算计划的起点和终点的 LCA 和路径长。
4. 进行二分查找，对于每个 $mid$，查看是否存在一条边，将其变为虫洞后，所有运输的最大时间不超过 $mid$。
5. 使用差分标记长度超过 $mid$ 的运输路径，检查是否存在满足条件的边。

**如果还有疑问，可以看代码注释：**

```cpp
#include<bits/stdc++.h> 
#define I using 
#define AK namespace 
#define IOI std 
#define i_ak return 
#define ioi 0 
#define int long long // 使用long long类型 

I AK IOI; 

const int MAXN=3e5+5; // 最大节点数 
const int LOG=20;      // LCA倍增的层数 

int n,m; 
int parent[MAXN],depth[MAXN],w[MAXN]; // 父节点/深度/边权 
int up[LOG][MAXN];                    // LCA倍增数组 
int dist[MAXN];                       // 根节点到各点距离 
int nodes_order[MAXN];                // 按深度排序的节点序列 

// 邻接表结构体（模拟vector<pair>）
struct Edge{
    int to,t;         // 相邻节点和边权 
    int next;         // 下条边索引 
}edges[MAXN<<1];      // 双向边需要两倍空间 
int head[MAXN],edge_cnt; 

// 运输计划结构体 
struct Query{
    int u,v,lca; 
    int len;          // 原始路径长度 
}q[MAXN]; 

// 链式前向星加边 
void add_edge(int a,int b,int t){
    edges[++edge_cnt] = {b,t,head[a]};
    head[a] = edge_cnt;
}

// BFS预处理树结构 
void bfs(int root){
    queue<int> que; 
    que.push(root); 
    parent[root] = -1; 
    depth[root] = 0; 
    dist[root] = 0; 

    while(!que.empty()){
        int u=que.front(); que.pop(); 
        // 遍历邻接表 
        for(int i=head[u];i;i=edges[i].next){
            int v=edges[i].to, t=edges[i].t; 
            if(v == parent[u]) continue; 
            
            parent[v] = u; 
            depth[v] = depth[u]+1; 
            w[v] = t; 
            dist[v] = dist[u]+t; 
            que.push(v); 
        }
    }
}

// 预处理LCA的倍增数组 
void pre_lca(){
    for(int i=1;i<=n;++i) up[0][i] = (parent[i]==-1) ? i : parent[i]; 
    for(int k=1;k<LOG;++k)
        for(int i=1;i<=n;++i)
            up[k][i] = up[k-1][up[k-1][i]]; 
}

// 查询LCA 
int lca(int u,int v){
    // 先调整到同一深度 
    if(depth[u]<depth[v]) swap(u,v); 
    for(int k=LOG-1;k>=0;--k)
        if(depth[up[k][u]] >= depth[v]) 
            u = up[k][u]; 
    if(u == v) return u; 
    // 一起向上跳 
    for(int k=LOG-1;k>=0;--k)
        if(up[k][u] != up[k][v])
            u=up[k][u],v=up[k][v]; 
    return parent[u]; 
}

// 预处理所有查询的LCA和路径长度 
void pre_queries(){
    for(int i=0;i<m;++i){
        int u=q[i].u, v=q[i].v; 
        int l=lca(u,v); 
        q[i].lca = l; 
        q[i].len = dist[u] + dist[v] - 2*dist[l]; 
    }
}

// 检查mid是否可行 
bool check(int mid){
    int diff[MAXN]={0};       // 差分数组 
    int max_gap=0, cnt=0;     // 最大需要消减的差值/超限路径数 
    int S[MAXN],s_cnt=0;      // 存储超限的路径 

    // 筛选超限的运输计划 
    for(int i=0;i<m;++i){
        if(q[i].len > mid){
            S[s_cnt++] = i; 
            max_gap = max(max_gap, q[i].len - mid); 
        }
    }
    if(s_cnt == 0) return true; 
    
    // 树上差分操作 
    for(int i=0;i<s_cnt;++i){
        int u=q[S[i]].u, v=q[S[i]].v, l=q[S[i]].lca; 
        diff[u]++, diff[v]++, diff[l]-=2; 
    }
    // 自底向上传递差分值 
    for(int i=0;i<n;++i){
        int u=nodes_order[i]; 
        if(parent[u] == -1) continue; 
        diff[parent[u]] += diff[u]; 
    }
    // 检查是否存在公共边 
    for(int u=2;u<=n;++u) 
        if(diff[u]==s_cnt && w[u]>=max_gap) 
            return true; 
    return false; 
}

signed main(){
    ios::sync_with_stdio(0); cin.tie(0); 
    
    cin>>n>>m; 
    // 读取边并建图 
    for(int i=0;i<n-1;++i){
        int a,b,t; cin>>a>>b>>t; 
        add_edge(a,b,t); add_edge(b,a,t); 
    }
    bfs(1); // 预处理树结构 

    // 按深度降序排序节点 
    for(int i=0;i<n;++i) nodes_order[i] = i+1; 
    sort(nodes_order,nodes_order+n,[&](int a,int b){
        return depth[a] > depth[b]; 
    }); 

    pre_lca(); // 预处理LCA 

    // 读取所有查询 
    for(int i=0;i<m;++i) cin>>q[i].u>>q[i].v; 
    pre_queries(); // 预处理查询数据 

    // 二分答案 
    int max_len=0; 
    for(int i=0;i<m;++i) max_len=max(max_len, q[i].len); 
    int left=0, right=max_len, ans=max_len; 
    
    while(left <= right){
        int mid = (left+right)>>1; 
        if(check(mid)){
            ans = mid; 
            right = mid-1; 
        }else{
            left = mid+1; 
        }
    }
    cout<<ans; 
    i_ak ioi; 
}
```

复杂度分析：$O((n+m)\log n)$。

亲测可过，请勿抄袭！

---

## 作者：Liyanxi1028 (赞：3)

### 前言

运输计划这道题作为当年 NOIP 的 D2T3，是一道~~卡常~~ LCA 好题。没有用什么高级的算法，难点在于思路。

### 分析

题意不再赘述。我们要求：完成阶段性工作所需要的时间最短，换个说法，即**所有计划中所用时间最长的需要最短**。我们提取出关键词“最长的最短”，这提示我们可以**二分**！

接下来考虑二分如何验证。比如验证能否在 $k$ 时间内完成。若要在 $k$ 时间内完成，则原本完成时间大于 $k$ 的计划中必须有航道被改造。也就是说，我们必须将**一条被所有完成时间大于 $k$ 的计划覆盖的航道**改为虫洞，并且这条航道的长度必须**大于等于计划最大路径长度减 $k$**，阶段性工作才能在 $k$ 时间内完成。

求所有完成时间大于 $k$ 的计划，用 LCA 计算路径长度即可；
求满足被所有完成时间大于 $k$ 的计划覆盖的航道，可以使用树上差分。但我们要把路径转化到点上 —— 令 1 为根，将路径转到子节点上存储，以便差分。时间复杂度 $O(n\log n)$。

接下来就是本题卡常之处，你兴冲冲交上代码，却发现 [T 了一个点](https://www.luogu.com.cn/record/206579541)。原来是差分后做前缀和的 dfs 太慢。怎么办呢？我们在 LCA 预处理时同时搞一个前序遍历数组，就可以倒序使用这个数组做前缀和，不用 dfs 了。显然，这样做前缀和一定是正确的。

### 代码

有注释。

```cpp
#include<bits/stdc++.h>
#define int long long
#define db long double
#define Pii pair<int,int>
#define fi first
#define se second
#define mid ((l+r)>>1)
#define f(x,y) fixed<<setprecision(y)<<x
#define gc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,rp,stdin),p1==p2)?EOF:*p1++)

using namespace std;
const int N=3e5+10;
const int rp=1e6+10;

int n,m,cnt,ans,maxt,q[N],p[N],b[N],d[N],dp[N],fa[N][20];
vector<Pii> vt[N];
struct node{int u,v,w,t;}a[N];
//计划起点 计划终点 计划起点与计划终点的最近公共祖先 计划所需时间 
char buf[rp],*p1=buf,*p2=buf;

inline int read() 
{
	int x=0,f=1; char c=0;
    while(!isdigit(c)){if(c=='-') f=-1; c=gc();}
    while(isdigit(c)) x=(x<<3)+(x<<1)+(c^48),c=gc();
    return x*f;
}//快读
 
inline char read_ch()
{
	char c=0;
	while(!isalpha(c)) c=gc();
	return c;
}

inline void dfs(int x,int f)
{
	p[++cnt]=x; //前序遍历数组
	d[x]=d[f]+1; dp[x]=dp[f]+b[x]; fa[x][0]=f;
	for(int i=1;i<20;++i) fa[x][i]=fa[fa[x][i-1]][i-1];
	for(auto a:vt[x]) if(a.fi!=f) b[a.fi]=a.se,dfs(a.fi,x);
}//LCA 预处理 

inline int get(int u,int v)
{
	if(d[u]<d[v]) swap(u,v);
	int x=d[u]-d[v];
	for(int i=0;(1<<i)<=x;++i) if((1<<i)&x) u=fa[u][i];
	if(u==v) return u;
	for(int i=19;i>=0;--i)
		if(fa[u][i]!=fa[v][i]) u=fa[u][i],v=fa[v][i];
	return fa[u][0];
}//LCA 找最近公共祖先

inline int cr(int x)
{
	cnt=0; memset(q,0,sizeof q);
	for(int i=1;i<=m;++i) 
		if(a[i].t>x)
		{
			++cnt;//完成时间大于 k 的计划数量加一 
			++q[a[i].u]; ++q[a[i].v];
			q[a[i].w]-=2;//差分 
		}
	for(int i=n;i>=1;--i) q[fa[p[i]][0]]+=q[p[i]];
	for(int i=1;i<=n;++i) 
		if(q[i]==cnt&&maxt-b[i]<=x) //改造此航道即可符合要求 
			return 1;
	return 0;
}

signed main()
{
	cin.tie(0)->sync_with_stdio(0);
	n=read(); m=read(); int u,v,w;
	for(int i=1;i<n;++i)
	{
		u=read(); v=read(); w=read();
		vt[u].push_back({v,w});
		vt[v].push_back({u,w});
	}
	dfs(1,0);
	for(int i=1;i<=m;++i)
	{
		a[i].u=u=read(); a[i].v=v=read();
		a[i].w=w=get(u,v);
		a[i].t=dp[u]+dp[v]-2*dp[w];//LCA 计算路径 
		maxt=max(maxt,a[i].t);//计划最大路径长度
	}
	int L=0,R=maxt; ans=maxt;
	while(L<=R)
	{
		int mi=(L+R)>>1;
		if(cr(mi)) R=mi-1,ans=mi;
		else L=mi+1;
	}//二分 
	cout<<ans;
	return 0;
}
```

希望我的题解对大家有帮助！

---

## 作者：ymx2009 (赞：2)

# 题目大意
选择一条边，把它的边权改为 $0$ 使得走完所有给定路径的最大值最小。
# Solutoin
本题是最大值最小的问题，我们可以想到二分，二分完成所有工作的最短时间 $mid$。  
那么判断如果所有不合法的路径，即通过这条路径的时间大于 $mid$ 的路径，都通过一条边，且权值和最大的路径减这条边的边权小于 $mid$，那么 $mid$ 是合法的。  
实现的时候可以使用树上差分来统计是否所有非法路径都通过同一条边。
# 代码时间

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e5+10;
int n,m,fa[N],dep[N],son[N],top[N],sum[N],sz[N],st[N],en[N],temp[N],dfn[N];
vector<pair<int,int> > e[N];
void dfs(int x,int deep,int father,int val)
{
	sz[x]=1,dep[x]=deep,fa[x]=father,sum[x]=val;
	for(auto v:e[x])
	{
		int u=v.first,w=v.second;
		if(u==fa[x]) continue;
		dfs(u,deep+1,x,val+w);
		sz[x]+=sz[u];
		if(sz[u]>sz[son[x]]) son[x]=u;
	}
}
int tot;
void dfs1(int x,int k)
{
	dfn[++tot]=x;
	if(son[x]) dfs1(son[x],k);
	top[x]=k;
	for(auto v:e[x])
	{
		int u=v.first;
		if(u==son[x]||u==fa[x]) continue;
		dfs1(u,u);
	}
}
int lca(int x,int y)
{
	for(;top[x]!=top[y];)
	{
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		x=fa[top[x]];
	}
	return (dep[x]<dep[y])?x:y;
}
bool check(int x)
{
	int sm=0,maxx=0;
	memset(temp,0,sizeof temp);
	for(int i=1;i<=m;i++)
	{
		int LCA=lca(st[i],en[i]);
		if(sum[st[i]]+sum[en[i]]-2*sum[LCA]<=x) continue; 
		maxx=max(maxx,sum[st[i]]+sum[en[i]]-2*sum[LCA]-x);
		temp[st[i]]++,temp[en[i]]++;
		temp[LCA]-=2;
		sm++;
	}
	if(!sm) return true;
	for(int i=n;i>1;i--) temp[fa[dfn[i]]]+=temp[dfn[i]];
	for(int i=1;i<=n;i++)
	{
		if(temp[dfn[i]]>=sm&&sum[dfn[i]]-sum[fa[dfn[i]]]>=maxx) return true;
	}
	return false;
}
int f(int l,int r)
{
	if(l>=r) return l;
	int mid=l+r>>1;
	if(check(mid)) return f(l,mid);
	return f(mid+1,r);
}
int main()
{	
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	int sm=0;
	for(int i=1;i<n;i++) 
	{
		int x,y,z;
		cin>>x>>y>>z;
		e[x].push_back({y,z});
		e[y].push_back({x,z});
		sm+=z;
	}
	for(int i=1;i<=m;i++) cin>>st[i]>>en[i];
	dfs(1,1,0,0);
	dfs1(1,1);
	cout<<f(0,sm);
	return 0;
}
```

---

## 作者：Bobi2014 (赞：2)

这是一道~~可爱~~的树上差分、二分、树链剖分题目。

### 前置知识

-  [树上差分](https://www.cnblogs.com/TEoS/p/11376676.html)
-  [二分](https://blog.csdn.net/Mr_dimple/article/details/114656142/)
-  [树链剖分](https://oi-wiki.org/graph/hld/)

### 题面描述

有 $n-1$ 条边的树和 $m$ 条路径，你可以让一条边的边权为零，使操作后的路径长度最大值最小。

### 思路

看到这种最大值最小题目，第一时间想到的就是二分题目要求输出的答案，而答案的最大值是 $n \times t$，所以二分的时间复杂度为 $O(\log(3 \times 10^8))$，那么检查答案是否可行的函数的时间复杂度就要控制在 $O(n \log n)$ 左右，我们想到一棵树上简单路径是唯一的，我们可以用两点的最近公共祖先求出两点之间的距离，于是树链剖分熟练的打上（不带线段树），预处理好每条路径的长度与它们的最近公共祖先。我们想到在所有的路径中，我们需要让长度 $>mid$ 的路径长度降低，所以那条边一定是所有长度 $>mid$ 的路径的公共边，求公共边可以枚举所有路径，如果长度 $>mid$，那么使用树上差分让这条路径经过的边全部 $+1$。统计每条边被走了多少次，如果等于长度 $>mid$ 的路径的条数且最长的那条路径减去它的长度 $\le mid$，那么函数返回 $1$，如果没有满足条件的边则返回 $0$。最终时间复杂度 $O(\log(3 \times 10^8) \times n)$。

---

## 作者：20111019Yu (赞：2)

### 题意
有一颗 $n$ 个点的树，第 $i$ 条边连接 $a_{i},b_{i}$ 长度为 $t_{i}$。 你可以将一条路的长度变为 $0$，让 $m$ 对 $(x_{i},y_{i})$ 路径长度最大值最小。
### 思路
~~不会有人看到最大值最小不写二分答案吧。~~

我们将 $m$ 对节点按路径长度从大到小排序，令第 $i$ 长的路径长度为 $len_{i}$，路径为 $e_{i}$。

有一个很显然的事情，你选的边一定在 $e_{1}$ 上，并且选的边长度越大越好。

但是这样是错的，因为没有考虑到 $len_{2}$ 和 $len_{1}$ 差不多大且 $e_{1}$ 和 $e_{2}$ 相交于一条边上，这样选择这条边就比之前那种优秀。

推广一下，假设选择第 $r$ 条边，若它可能成为答案，当且仅当 $\exists k\in(1,n),\text{s.t. }r\in\displaystyle\cap_{i=1}^k e_{i}\land t_{r}=\max_{j\in\cap_{i=1}^k e_{i}} t_{j}$，可以自行理解。

$k$ 我们可以枚举，用树链剖分维护路径，线段树维护交集最大值，总时间复杂度 $\mathcal{O(n\log n+m\log^2n)}$。
### code

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n, m, x, y, z, dfn[300005], low[300005], indx, siz[300005], son[300005], tp[300005], dep[300005], fa[300005], rnk[300005], a[300005], ans = 1e9, cnt;
struct road{
	int x, y, z;
} rd[300005];
struct segtree{
	int sum, tag, len, maxn;
	segtree operator + (const segtree b) const{
		segtree a = b;
		a.tag = 0ll;
		a.len += len;
		if(a.sum < sum){
			a.sum = sum;
			a.maxn = maxn;
		}
		else if(a.sum == sum) a.maxn = max(a.maxn, maxn);
		return a;
	}
} s[1200005];
struct nude{
	int u, v;
};
vector<nude> vec[300005];
vector<road> lis;

bool cmp(road a, road b){
	return a.z > b.z;
}
void dfs1(int x, int o){
	dep[x] = dep[o] + 1;
	fa[x] = o, siz[x] = 1;
	for( auto i : vec[x] ){
		if(i.u == o) continue;
		dfs1(i.u, x);
		siz[x] += siz[i.u];
		if(siz[son[x]] < siz[i.u]) son[x] = i.u;
	}
	return;
}
void dfs2(int x, int o, int res){
	dfn[x] = low[x] = ++indx;
	tp[x] = res, rnk[indx] = x;
	if(!son[x]) return;
	dfs2(son[x], x, res);
	low[x] = max(low[x], low[son[x]]);
	for( auto i : vec[x] ){
		if(i.u == o || i.u == son[x]) continue;
		dfs2(i.u, x, i.u);
		low[x] = max(low[x], low[i.u]);
	}
	return;
}
void pushup(int rt){
	s[rt] = s[rt << 1] + s[rt << 1 | 1];
	return;
}
void pushdown(int rt){
	s[rt << 1].tag += s[rt].tag;
	s[rt << 1 | 1].tag += s[rt].tag;
	s[rt << 1].sum += s[rt].tag;
	s[rt << 1 | 1].sum += s[rt].tag;
	s[rt].tag = 0;
	return;
}
void update(int L, int R, int l, int r, int rt, int c){
	if(L <= l && r <= R){
		s[rt].sum += c;
		s[rt].tag += c;
		return;
	}
	pushdown(rt);
	int mid = (l + r) >> 1;
	if(mid >= L) update(L, R, l, mid, rt << 1, c);
	if(mid < R) update(L, R, mid + 1, r, rt << 1 | 1, c);
	pushup(rt);
	return;
}
void update_len(int L, int R, int l, int r, int rt, int c){
	if(L <= l && r <= R){
		s[rt].len += c;
		s[rt].maxn += c;
		return;
	}
	int mid = (l + r) >> 1;
	if(mid >= L) update_len(L, R, l, mid, rt << 1, c);
	if(mid < R) update_len(L, R, mid + 1, r, rt << 1 | 1, c);
	pushup(rt);
	return;
}
segtree query(int L, int R, int l, int r, int rt){
	if(L <= l && r <= R) return s[rt];
	pushdown(rt);
	int mid = (l + r) >> 1;
	segtree ans = {0, 0, 0, 0};
	if(mid >= L) ans = ans + query(L, R, l, mid, rt << 1);
	if(mid < R) ans = ans + query(L, R, mid + 1, r, rt << 1 | 1);
	return ans;
}
void lca(int x, int y){
	while(tp[x] != tp[y]){
		if(dep[tp[x]] < dep[tp[y]]){
			update(dfn[tp[y]], dfn[y], 1, n, 1, 1);
			y = fa[tp[y]];
		}
		else{
			update(dfn[tp[x]], dfn[x], 1, n, 1, 1);
			x = fa[tp[x]];
		}
	}
	if(dep[x] < dep[y]){
		update(dfn[x], dfn[y], 1, n, 1, 1);
		update(dfn[x], dfn[x], 1, n, 1, -1);
	}
	else{
		update(dfn[y], dfn[x], 1, n, 1, 1);
		update(dfn[y], dfn[y], 1, n, 1, -1);	
	}
	return;
}
int lca_len(int x, int y){
	int sum = 0;
	while(tp[x] != tp[y]){
		if(dep[tp[x]] < dep[tp[y]]){
			segtree lin = query(dfn[tp[y]], dfn[y], 1, n, 1);
			sum += lin.len;
			y = fa[tp[y]];
		}
		else{
			segtree lin = query(dfn[tp[x]], dfn[x], 1, n, 1);
			sum += lin.len;
			x = fa[tp[x]];
		}
	}
	if(dep[x] < dep[y]){
		segtree lin1 = query(dfn[x], dfn[y], 1, n, 1);
		segtree lin2 = query(dfn[x], dfn[x], 1, n, 1);
		sum += lin1.len - lin2.len;
	}
	else{
		segtree lin1 = query(dfn[y], dfn[x], 1, n, 1);
		segtree lin2 = query(dfn[y], dfn[y], 1, n, 1);	
		sum += lin1.len - lin2.len;
	}
	return sum;
}

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin >> n >> m;
	for( int i = 1; i < n; i++ ){
		cin >> x >> y >> z;
		vec[x].push_back({y, z});
		vec[y].push_back({x, z});
		rd[i] = {x, y, z};
 	}
 	dfs1(1, 0);
 	dfs2(1, 0, 1);
 	for( int i = 1; i < n; i++ ){
		 x = rd[i].x, y = rd[i].y, z = rd[i].z;
		 if(dep[x] < dep[y]) update_len(dfn[y], dfn[y], 1, n, 1, z);
		 else update_len(dfn[x], dfn[x], 1, n, 1, z);
 	}
 	for( int i = 1; i <= m; i++ ){
		cin >> x >> y;
		lis.push_back({x, y, lca_len(x, y)});
	}
	sort(lis.begin(), lis.end(), cmp);
	lis.push_back({0, 0, 0});
	for( int i = 0; i < m; i++ ){
		road t = lis[i];
		cnt++;
		if(t.x == t.y) cnt--;
		lca(t.x, t.y);
		if(s[1].sum < cnt) break;
		ans = min(ans, max(lis[0].z - s[1].maxn, lis[i + 1].z));
	} 
	cout << ans << '\n';
	return 0;
}
```

---

## 作者：Archy_ (赞：1)

## 题目思路

**前置知识：最近公共祖先，树上差分，二分。**

首先我们看到题目中的图保证联通且有 $n - 1$ 条边，那么这个图一定是树，对于有 $n - 1$ 条边但不是树可以有以下情况。所以这道题我们就可以考虑进行树上操作。
![](https://cdn.luogu.com.cn/upload/image_hosting/koljomav.png)

根据题意，找所有运输航道至少要多长时间，即要使花费时间最长的那个运输航线花费的时间最小，就是最大答案的最小值，我们就可以考虑对答案进行二分，然后进行贪心的 check。

我们怎么对当前的答案进行 check 呢？首先我们可以找出所有运输航线的花费时间，对于小于等于当前答案的运输航线，我们可以不进行考虑。因为此时就算开一条虫洞，这条运输航线也一定小于等于当前答案。

对于大于当前答案的运输航线，我们一定要在这些运输航线的公共边上开虫洞，如果我们在其他边上开虫洞，那么一定会存在运输航线花费时间还大于当前答案，不满足条件。现在问题转化为怎么快速找到公共边。这里注意，**公共边可能存在多条**。

大于当前答案的运输航线有 $tot$ 条，若 $tot = 0$，直接满足条件。否则找公共边。考虑树上差分数组 $run$，$run_i$ 记录第 $i$ 个点它上面那条边经过多少次。对于一条边 $(u,v)$，将 $run_u \gets run_u + 1$，$run_v \gets run_v + 1$，$run_{lca(u,v)} \gets run_{lca(u,v)} - 2$，然后将差分数组从树的叶子向上累加答案。我们发现，若 $run_i = tot$，那么这个点的上面的边一定是公共边。

我们在处理边权的时候也将边权下放到点上，同理从叶子向上累加，对于 $u$ 到 $v$ 这条路径长，就为 $dis_u + dis_v - 2 \times dis_{lca(u,v)}$。

判断当前公共边作为虫洞是否可行，就找这 $tot$ 条航道的路径最大值，然后减去这条公共边的长度判断是否小于等于当前二分的这个答案就行了，若是则满足条件。

但是这样的话我们在 check 中的循环还计算了 lca，时间复杂度为 $O(nlog^2n)$，有大量重复计算，还不是很优，我们预处理出路径的 lca 和长度就行了。

假设树为题目样例，当前二分答案为 $11$，用蓝色代表处理后的 $run_i$，红色代表处理后的 $dis_i$，黄色代表公共边，由于此时大于 $11$ 的运输路径只有一条，所以公共边为这条运输路径上的所有边，均如下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/kd3vz7ta.png)

## Code
```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;

const int N = 3e5 + 10;
int n, q, cnt, head[N];
int a[N], b[N], disab[N], lcaab[N];
int dis[N], dep[N], pre[N][21];
int run[N];

struct node {
	int to, next, w;
} e[N << 1];

void addi(int u, int v, int w) {
	e[++ cnt] = {v, head[u], w};
	head[u] = cnt;
}

void add(int u, int v, int w) {
	addi(u, v, w); addi(v, u, w); 
}

void dfs(int u, int fa) {
	dep[u] = dep[fa] + 1;
	pre[u][0] = fa;
	for(int i = 1; i <= 20; i ++) {
		pre[u][i] = pre[pre[u][i - 1]][i - 1];
	}
	for(int i = head[u]; i; i = e[i].next) {
		int v = e[i].to;
		if(v == fa) continue;
		dis[v] = e[i].w + dis[u];
		dfs(v, u);
	}
}

int lca(int u, int v) {
	if(u == v) return u;
	if(dep[u] < dep[v]) swap(u, v);
	for(int i = 20; i >= 0; i --) {
		if(dep[v] <= dep[u] - (1 << i)) u = pre[u][i];
	}
	if(u == v) return u;
	for(int i = 20; i >= 0; i --) {
		if(pre[u][i] == pre[v][i]) continue;
		u = pre[u][i], v = pre[v][i];
	}
	return pre[u][0];
}

void dfs2(int u, int fa) {
	for(int i = head[u]; i; i = e[i].next) {
		int v = e[i].to;
		if(v == fa) continue;
		dfs2(v, u);
		run[u] += run[v];
	}
}

bool check(int x) {
	for(int i = 1; i <= n; i ++) run[i] = 0;
	int tot = 0, maxdis = 0;
	for(int i = 1; i <= q; i ++) {
		maxdis = max(maxdis, disab[i]);
		if(disab[i] > x) {
			run[a[i]] ++, run[b[i]] ++;
			run[lcaab[i]] -= 2;
			tot ++;
		} 
	}
	if(tot == 0) return 1;
	dfs2(1, 0);
	for(int i = 1; i <= n; i ++) {
		int w = dis[i] - dis[pre[i][0]];
		if(run[i] == tot && maxdis - w <= x) {
			return 1;
		}
	}
	return 0;
}

inline int rd(){
	int w = 1, x = 0;
    char c = getchar();
	while(c < 48 || c > 57) {
		if(c == 45) w *= -1;
		c = getchar();
	}
	while(c >= 48 && c <= 57) {
		x = (x << 1) + (x << 3) + (c ^ 48);
		c = getchar();
	}
	return x * w;
}

int main() {
	n = rd(), q = rd(); 
	for(int i = 1; i < n; i ++) {
		int u = rd(), v = rd(), w = rd();
		add(u, v, w);
	}
	dfs(1, 0);
	for(int i = 1; i <= q; i ++) {
		a[i] = rd(), b[i] = rd();
		lcaab[i] = lca(a[i], b[i]);
		disab[i] = dis[a[i]] + dis[b[i]] - 2 * dis[lcaab[i]];
	}
	int l = 0, r = 1e9, mid, ans = 0;
	while(l <= r) {
		mid = (l + r) >> 1;
		if(check(mid)) r = mid - 1, ans = mid;
		else l = mid + 1; 
	}
	cout << ans << "\n";
	return 0;
}
```

---

## 作者：hongzy (赞：1)

这题就没往二分上想，直接使用线段树+树剖大暴力

做法就是枚举每一条边$(u, fa[u], w)$，求出删除这条边后的答案。

假设已经求出了两个数组$past[u], nopast[u]$分别表示经过u的路径长度最大值, 不过u的路径长度最大值

那么删除边$(u, fa[u], w)$后答案就是$max(past[u] - w, nopast[u])$

考虑怎么在树剖时候用两个线段树维护$past, nopast$

加入一条树上路径$(u, v, d)$的时候

$past$很方便更新，树剖的时候区间取$max$一下 

$nopast$很需要把past更新的区间记录下来然后排序，记为$[l_1, r_1],[l_2, r_2],...,[l_k, r_k]$

然后在$nopast$的线段树上更新$[1, l_1-1], [r_1+1, l_2-1], ..., [r_k + 1, n]$ 这些区间

时间复杂度是否过大？

加入路径操作每次更新$past$的$O(\log n)$个区间，$nopast$区间实际上也只有$O(\log n)$个，排序需要$O(\log n\log\log n)$的时间，一次加入路径操作的复杂度只有$O(\log n\log\log n+\log^2n)$，总复杂度只有$O(n+m(\log n\log\log n+\log^2n))$

（雾

最后有一个常数优化，即其实不需要枚举每一条边，直接枚举最长路径上的边即可（道理十分简单不再赘述）

下面的代码给出了详细注释.注意细节.

```cpp
#include <algorithm>
#include <cstdio>
#include <vector>
using namespace std;

typedef long long LL;

const int N = 3e5 + 10;

struct Edge { int v, w; };
vector<Edge> G[N];

int n, m, df[N];
int fa[N], dep[N], son[N], sz[N];
int top[N], idx[N], seg[N], dfn;
LL dep2[N], ans, past[N], nopast[N];
//fa, dep, son, sz, top, idx, seg为树剖内容 
//df[u]表示u到fa[u]的距离 ; dep2[u]表示根到u到距离 
//past[u]表示经过点u的路径最大值
//nopast[u]表示不过点u的路径最大值 
void dfs1(int u, int f) {
	sz[u] = 1; dep[u] = dep[fa[u] = f] + 1;
	for(int i = 0; i < G[u].size(); i ++) {
		int & v = G[u][i].v, & w = G[u][i].w;
		if(v ^ f) {
			dep2[v] = dep2[u] + (df[v] = w); dfs1(v, u); sz[u] += sz[v];
			if(sz[v] > sz[son[u]]) son[u] = v;
		}
	}
}
void dfs2(int u, int topf) {
	top[seg[idx[u] = ++ dfn] = u] = topf;
	if(!son[u]) return ;
	dfs2(son[u], topf);
	for(int i = 0, v; i < G[u].size(); i ++)
		if(!idx[v = G[u][i].v]) dfs2(v, v);
}
// 以上为树链剖分板子 
struct Seg {
	// 线段树维护最大值
	LL tag[N << 2] = {0};
	void pushd(int k) { //懒标记下传 
		if(!tag[k]) return ;
		tag[k << 1] = max(tag[k << 1], tag[k]);
		tag[k << 1 | 1] = max(tag[k << 1 | 1], tag[k]);
		tag[k] = 0;
	}
	void modify(int k, int l, int r, int L, int R, LL w) { //区间修改 
		if(l > R || r < L) return ;
		if(L <= l && r <= R) return void (tag[k] = max(tag[k], w));
		if(l == r) return ;
		int mid = l + r >> 1; pushd(k);
		if(L <= mid) modify(k << 1, l, mid, L, R, w);
		if(mid < R) modify(k << 1 | 1, mid + 1, r, L, R, w);
	}
	LL query(int k, int l, int r, int p) { //单点查询 
		if(l == r) return tag[k];
		int mid = l + r >> 1; pushd(k);
		if(p <= mid) return query(k << 1, l, mid, p);
		return query(k << 1 | 1, mid + 1, r, p);
	}
	void getmx(int k, int l, int r, LL * arr) { //获取叶子结点信息 
		if(l == r) return void (arr[seg[l]] = tag[k]);
		int mid = l + r >> 1; pushd(k);
		getmx(k << 1, l, mid, arr);
		getmx(k << 1 | 1, mid + 1, r, arr);
	}
} s1, s2;
// s1维护经过i的路径最大值
// s2维护不过i的路径最大值 

LL TreeDis(int u, int v) { //树剖求两点距离 
	const int uu = u, vv = v;
	for(; top[u] ^ top[v]; u = fa[top[u]])
		if(dep[top[u]] < dep[top[v]]) u ^= v ^= u ^= v;
	if(dep[u] > dep[v]) u ^= v ^= u ^= v;
	return dep2[uu] + dep2[vv] - 2ll * dep2[u];
}

void TreeAdd(int u, int v, const LL & d) { //加入一条路径 
	struct Node {
		int l, r;
		bool operator < (const Node & node) const { return l < node.l; }
	};
	static Node pos[N];
	int cnt = 0;
	for(; top[u] ^ top[v]; u = fa[top[u]]) {
		if(dep[top[u]] < dep[top[v]]) u ^= v ^= u ^= v;
		s1.modify(1, 1, n, idx[top[u]], idx[u], d);
		pos[cnt ++] = Node {idx[top[u]], idx[u]};
	}
	if(dep[u] > dep[v]) u ^= v ^= u ^= v;
	if(idx[u] ^ idx[v]) {
		//注意idx[u]要 + 1, lca到fa[lca]到边是不经过的 
		s1.modify(1, 1, n, idx[u] + 1, idx[v], d);
		pos[cnt ++] = Node {idx[u] + 1, idx[v]};
	}
	sort(pos, pos + cnt); //把覆盖区间排序
	//把没有覆盖的区间更新 s2, 注意最左和最右的区间也要更新 
	if(pos[0].l > 1) s2.modify(1, 1, n, 1, pos[0].l - 1, d);
	if(pos[cnt - 1].r < n) s2.modify(1, 1, n, pos[cnt - 1].r + 1, n, d);
	for(int i = 0; i < cnt - 1; i ++) {
		int ll = pos[i].r + 1, rr = pos[i + 1].l - 1;
		if(ll <= rr) s2.modify(1, 1, n, ll, rr, d);
	}
}

void TreeForce(int u, int v) { //在树上暴力跳枚举边 
	int uu = u, vv = v;
	for(; top[u] ^ top[v]; u = fa[top[u]])
		if(dep[top[u]] < dep[top[v]]) u ^= v ^= u ^= v;
	if(dep[u] > dep[v]) u ^= v ^= u ^= v;
	for(int i = uu; i ^ u; i = fa[i]) //u -> lca 
		ans = min(ans, max(past[i] - df[i], nopast[i]));
	for(int i = vv; i ^ u; i = fa[i]) //v -> lca
		ans = min(ans, max(past[i] - df[i], nopast[i]));
}

int main() {
	int u, v, w;
	scanf("%d%d", &n, &m);
	for(int i = 1; i < n; i ++) {
		scanf("%d%d%d", &u, &v, &w);
		G[u].push_back(Edge {v, w});
		G[v].push_back(Edge {u, w});
	}
	dfs1(1, 0); dfs2(1, 1);
	int su, sv; LL maxd = -1;   //记录最长路径 
	for(int i = 1; i <= m; i ++) {
		scanf("%d%d", &u, &v);
		LL d = TreeDis(u, v);
		TreeAdd(u, v, d);
		ans = max(ans, d);
		if(d > maxd) maxd = d, su = u, sv = v;
	}
	s1.getmx(1, 1, n, past);    //获取经过i的路径最大值 
	s2.getmx(1, 1, n, nopast);  //获取不过i的路径最大值 
	TreeForce(su, sv);          //在最长路径上枚举边 
	printf("%lld\n", ans);
	return 0;
} 

```

---

## 作者：qhr2023 (赞：1)

## solution

LCA 加二分加树上差分。

题意：给定一颗有边权的树，让 $m$ 条路径权值最大尽可能小，可以将一条边权改为 $0$。

首先让最大值最小，用二分来做。

若我们现在验证是否能在 $x$ 的时间内完成所有运输计划，即修改一个虫洞，判断所有路径和的最大值是否不大于 $x$。我们修改一条本就不大于 $x$ 的路径一定是不优的，所以修改的虫洞一定在路径和大于 $x$ 的路径上。

设有 $k$ 条路径和超过 $x$ 的路径，那我们一定在一条 $k$ 条路径重叠的路径上，即 $k$ 条路径的交上，建虫洞，如果不存在这样的路径，显然没法使 $k$ 条路径都不大于 $x$，即 $x$ 一定不合法。

假设我们找到了这样的一条路径，把路径上边权最大的边改成虫洞一定是最优的。若仍不能使所有路径和都不大于 $x$，那 $x$ 就不是个可行的答案。

现在问题成了如何求这 $k$ 条路径的交。我们可以预处理所有路径的边权和，找到这 $k$ 条路径。对于预处理路径权，令 $1$ 号结点为根，记 $dis_i$ 表示点 $i$ 到根的路径权，一条 $u$ 到 $v$ 的路径权就是 $dis_u+dis_v-dis_{lca(u, v)} \times 2$。如图，红色是 $u$，蓝色是 $v$，绿色是 $lca(u, v)$。

![](https://cdn.luogu.com.cn/upload/image_hosting/1m9ige0f.png)

对于求交，我们建一个和原树结构一样的树，但边权为 $0$，利用树上差分，将这 $k$ 条路径经过的边权都加一，这样所有边权为 $k$ 的边就是这 $k$ 条路径的交。

复杂度是 $O((n+m)\log n+(n\log n))$。

---

## 作者：Motonic_queues (赞：0)

# 题意描述
给定一棵树，以及若干条路径。将任意一条边边权变为 $0$，使得最长的路径长度最短。  
# 思路分析  
题意简化后可以看出很明显的二分模型（最大值最小），那么能够想到二分答案，将求解性问题转化为判定性问题。  

### 如何判定  
假设现在判定的答案是 $mid$。  
容易想到先得出所有路径的长度。  
其中长度大于 $mid$ 的就不用管了。  


对于剩下的，需要归零一条边使得长度都小于 $mid$。  
那么首先，归零的这条边必须被所有路径都覆盖，不然就一定会留下过长的路径。（条件 $1$）  
其次，这条边的权值要比最长的路径与 $mid$ 的差值还要大，不然就会使得最大的路径仍然过长。（条件 $2$）  

接下来的思路就很显而易见了。  
为了方便地表示一条边，我们可以用一条边所连接的深度大的那个点去代替表示。  

为了满足条件 $1$，可以用树上差分解决，如果你不知道“树上差分”，具体地说，令 $cov_i$ 是第 $i$ 条边被覆盖的次数，那么对于一条路径 $(u,v)$，让 $cov_u$ 和 $cov_v$ 加 $1$，$cov_{LCA_{u,v}}$ 减 $2$。  
完事后再在树上做一个前缀和，就能得到真正的 $cov$ 了。  

那么假设 $k$ 是需要考虑的路径数量，我们直接遍历所有被覆盖次数等于 $k$ 的路径，然后找出其中边权大于最长的路径与 $mid$ 的差值的边，就可以宣告 $mid$ 合法了。  
否则 $mid$ 不合法。  

# 时间复杂度  
二分上下界显然可以从 $\min{E}$ 到 $\sum E$，简便起见就表示为 $\log\sum E$。  
每次判定做差分 $O(N)$，遍历 $O(N)$，所以加起来还是 $O(N)$。  

共计复杂度 $O(N\log\sum E)$。

---

## 作者：linch (赞：0)

UPD on 2025/1/23 16:22 修改错别字。

前置知识：二分答案，$\operatorname{LCA}$ 和 [边差分](https://oi-wiki.org/basic/prefix-sum/#%E8%BE%B9%E5%B7%AE%E5%88%86)。

## Problem
省流题面：给定一棵 $n$ 个节点的树和树上的 $m$ 条路径，你可以将任意一条边的权值改为 $0$ 使得这 $m$ 条路径长度的最大值最小，求出这个最小值。

## Solution
### Analysis
看到“最大值最小”容易发现是二分答案。考虑二分最短时间。

**那么如何判定是否符合要求？**

设 $V'$ 为 $m$ 条路径中初始长度大于当前二分需要判定的长度值的路径集合。

注意到以下事实：
- 需要改为 $0$ 的边一定在 $V'$ 中所有路径的交上，否则一定会有一条路径的长度不变，无法满足要求。
- 在所有可能被改为 $0$ 的路径中，将权值最大的一条边改为 $0$ 一定不劣于其他改法。证明略。

我们可以使用边差分来求出这个交。将 $V'$ 中所有路径经过的边边权加 $1$。最终边权等于 $V'$ 大小的即为它们的交。同时，我们记录下交上的边权最大值即可。

最后，枚举 $V'$ 每条路径，由于它一定经过改为 $0$ 的这条边，那么这条路径长度一定可以减去改为 $0$ 的这条边的权值，判断是否符合要求即可。

### Summary
以上就是这道题的主要解题思路。我们还需要求出每条路径的 $\operatorname{LCA}$ 和初始长度。其求法较为模板、基础，就不再赘述。时间复杂度是 $n\log n$ 级别的，符合要求。但是有些卡常。需要注意二分时不要传参，没开 O2 的情况下还需要 [这个帖子](https://www.luogu.com.cn/discuss/997645) 中提到的小优化。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=6e5+10;
const int inf=1e9+10;
int x,pre[maxn],fw[maxn],len[maxn],l[maxn],r[maxn],cnt,n,m,c[maxn],lc[maxn],dep[maxn],f[maxn],sz[maxn],hson[maxn],tp[maxn],head[maxn];//fw:记录从父亲过来的那条边权值。
struct edge{
	int to,nxt,w;
}e[maxn];
void add_edge(int u,int v,int w){
	e[++cnt]={v,head[u],w};
	head[u]=cnt;
}
void init(){
	for(int i=1;i<=n;i++){
		sz[i]=1;
		tp[i]=i;
	}
}
void dfs1(int x){
	for(int i=head[x];i;i=e[i].nxt){
		int v=e[i].to;
		if(v==f[x]) continue;
		f[v]=x;
		dep[v]=dep[x]+1;
		fw[v]=e[i].w;
		pre[v]=pre[x]+e[i].w;
		dfs1(v);
		sz[x]+=sz[v];
		if(sz[v]>sz[hson[x]]) hson[x]=v;
	}
}
void dfs2(int x){
	if(hson[x]){
		tp[hson[x]]=tp[x];
		dfs2(hson[x]);
	}
	for(int i=head[x];i;i=e[i].nxt){
		int v=e[i].to;
		if(v==f[x] || v==hson[x]) continue;
		dfs2(v);
	}
}
void dfs3(int x){
	for(int i=head[x];i;i=e[i].nxt){
		int v=e[i].to;
		if(v==f[x]) continue;
		dfs3(v);
		c[x]+=c[v];
	}
}
int LCA(int x,int y){
	while(tp[x]!=tp[y]){
		if(dep[tp[x]]<dep[tp[y]]) swap(x,y);
		x=f[tp[x]];
	}
	return dep[x]<dep[y] ? x : y;
}
bool chk(){
	int tot=0;
	for(int i=1;i<=m;i++){
		if(len[i]>x){
			tot++;
			c[l[i]]++;c[r[i]]++;
			c[lc[i]]-=2;
		}
	}
	dfs3(1);
	int mx=0;
	bool flag=false;
	for(int i=1;i<=n;i++){
		if(c[i]==tot){
			mx=max(mx,fw[i]);
			flag=true;
		}
		c[i]=0;
	}
	if(!flag) return false;
	for(int i=1;i<=m;i++){
		if(len[i]-mx>x) return false;
	}
	return true;
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
	cin>>n>>m;
	init();
	for(int i=1;i<n;i++){
		int u,v,w;
		cin>>u>>v>>w;
		add_edge(u,v,w);
		add_edge(v,u,w);
	}
	dfs1(1);
	dfs2(1);
	for(int i=1;i<=m;i++){
		cin>>l[i]>>r[i];
		lc[i]=LCA(l[i],r[i]);
		len[i]=pre[l[i]]+pre[r[i]]-2*pre[lc[i]];
	}
	int ll=0,rr=inf,ans=inf;
	while(ll<=rr){
		x=ll+rr>>1;
		if(chk()){
			rr=x-1;
			ans=min(x,ans);
		}
		else ll=x+1;
	}
	cout<<ans<<"\n";
	return 0;
}
```

C++14（GCC 9）O2，最慢 776ms，可过。[AC record](https://www.luogu.com.cn/record/199803297)。

---

## 作者：AC_Evil (赞：0)

楼上下写的都是树上差分二分什么的，我提供个新方法。

预处理每对节点的距离（LCA），同时找出最长链，缩短的边一定在这条链上。此过程为O(nlogn)。

枚举链上每一条边，对于所有点对，可以分成两种了：1）经过这条边的点对；2）不经过的。

判断方法：割掉这条边，判断两点是否连通，仍连通，说明不经过，反之经过。于是一棵树就被拆成了两棵。对于经过的路径（包含最长的），距离都会被缩短，但因为最长的路径存在，所以无需考虑经过的其他路径；而不经过的路径之中取个最大值，将最长路径减去边的权和不经过该边的最大值中再取最大值，枚举所有边的时候再取个最小值就OK了。

在链上一条接着一条判断边时，其中的一棵子树会获得更多的节点，其中可能就包括端点，获得其中一个表示此点对经过该边，获得另一个表示不经过了，因为都在子树中连通。这个过程中判断完所有的边后，所有节点都转至子树中，复杂度为O(n)。

对于判断不经过该边的点对的最大值，维护个线段树，开始时维护第i个点对距离d[i]，在得到一个端点后修改成0，另一个也得到时修改回来。此过程为O(nlogn)。

分析结束。

本人代码比较粗劣，不放了，上面思路也很清晰了。

---


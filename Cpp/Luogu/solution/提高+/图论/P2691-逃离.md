# 逃离

## 题目描述

**译自 CLRS Problem 26-1 Escape problem**

在一个 $n\times n$ 的网格中有 $m$ 个起始点 $(x_1, y_1),$ $(x_2, y_2),$ $\dots,$ $(x_m, y_m)$，试问：能否为这些结点分别找一条到边界的路径，且这 $m$ 条路径互不相交（即任意两条路径上没有一个相同的结点）。

![https://i.loli.net/2018/10/14/5bc2ec2948f8b.png](https://i.loli.net/2018/10/14/5bc2ec2948f8b.png)

黑点表示起始点，其他点用白点表示。找出的路径用加粗的线表示。图 (a) 存在符合条件的 $m$ 条路径，图 (b) 则不存在。



## 样例 #1

### 输入

```
6
10
2 2
2 4
2 6
3 1
3 2
3 4
3 6
4 2
4 4
4 6
```

### 输出

```
YES```

# 题解

## 作者：易颖杰 (赞：6)

这道题，蒟蒻的思路其实并不是很完美，本来想看看能骗多少分，结果0ms跑完满分，这道题仔细分析后蒟蒻发现，可以把这歌矩阵分成许多嵌套的小矩阵每一个矩阵里的点能不能全出来就看它最外面的的一圈的出口数是否大于等于里面的点的个数，是就可以，不是就不可以，然后逻辑上把最外层的点消除，那么里面又是一个矩阵，这样的话就可以一层一层的消去所有的点，不过这思路有反例，想知道的私信我。好了，详情看代码：

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
const int N=40;
int n,map[N][N],m;
int work(int l)
{
    int found=0;//found是最外层点的个数
    for(int i=1+l;i<=n-l-1;i++)//找点
    {
        if(map[i][1+l]) found++;
        if(map[n-l][i]) found++;
        if(map[i][n-l]) found++;
        if(map[1+l][i]) found++;
    }
    if(map[1+l][1+l]) found--;//重复寻找的要减掉
    if(map[n-l][n-l]) found++;//上面的循环没循环到的位置
    m-=found;//删除外层点
    found=(n-l*2-2)*4-found;//算出出口个数
    return found;
}
bool solve()
{
    for(int i=0;i<=(n%2 ? n/2-1:n/2-2);i++)//枚举层数，但是要特判奇偶
        if(work(i)<m)//里面的点比出口多......
            return 0;//返回false
    return 1;//可以全部到达边缘
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        map[x][y]=1;//起始点标记
    }
    if(solve()) printf("YES\n");
    else printf("NO\n");
    return 0;
}
```

---

## 作者：aSunnyDay (赞：0)

LaTeX fixed.句号加了

这种有比较明显的**源汇关系**的可以看出来是网络流(每个起始节点是源点，边界是汇点)。

首先我们用超级源把起始节点连起来。

题目说路径不能有公共**点**，也就是说一个**点**只能用在**一条路径**上，如果把每个点当做一个点的时候就不能保证这条性质。

# 怎么办？

我们可以用**拆点**的方式把这些**点拆成两份**，两份点之间连一条权值为 $1$ 的边，这样我们就能保证，每个点只用一次。

### 那么如果有两个点是相邻的怎么连呢?

我们发现，权值为 $1$ 的边是必须得让两个点走过(如果这两个点最终被选入了一条路径)，所以说这样就很好解决了。

![](https://cdn.luogu.com.cn/upload/image_hosting/7rk0g2gv.png)

红色的边就代表是要连的边。

这样就解决了该题的算法部分。

放代码。
```cpp
#include<bits/stdc++.h>
#define idL(i,j) ((i-1)*n+j)
#define idR(i,j) ((i-1)*n+j+n*n)
using namespace std;
typedef long long ll;
const ll N=36;
const ll INF=1e15;
ll n,m,dx[4]={1,0,0,-1},dy[4]={0,1,-1,0},hd[2*N*N],lv[2*N*N],S,T,cur[2*N*N],cnt=1;
bool vis[N][N];
ll read(){
	ll x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9') f=((bool)(c^'-')<<1)-1,c=getchar();
	while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return x*f;
}
struct edge{ll to,w,nxt;}es[22*N*N];
void ad(ll x,ll y,ll w){es[++cnt]=(edge){y,w,hd[x]},hd[x]=cnt;}
void add(ll x,ll y,ll w,ll v=0){ad(x,y,w);ad(y,x,v);}
bool bfs(){
	queue<ll> q;
	q.push(S);
	memset(lv,0,sizeof(lv));
	lv[S]=1;
	while(!q.empty()){
		ll x=q.front();q.pop();
		for(ll i=hd[x],v;i;i=es[i].nxt)
			if(!lv[v=es[i].to]&&es[i].w)
				lv[v]=lv[x]+1,
				q.push(v);
	}
	return lv[T];
}
ll dfs(ll x,ll flow){
	if(x==T) return flow;
	ll res=0;
	for(ll i=cur[x],v,w;i&&flow;i=es[i].nxt){
		cur[x]=1;
		if((w=es[i].w)&&lv[v=es[i].to]==lv[x]+1){
			ll nxt=dfs(v,min(flow,es[i].w));
			es[i].w-=nxt,es[i^1].w+=nxt,
			res+=nxt,flow-=nxt;
		}
	}
	return res;
}
ll dinic(){
	ll sum=0;
	while(bfs()){
		for(ll i=S;i<=T;++i) cur[i]=hd[i];
		sum+=dfs(S,INF);
	}
	return sum;
}
int main(){
	n=read(),m=read(),T=2*n*n+1;
	for(ll i=1;i<=m;++i)
		vis[read()][read()]=1;
	for(ll i=1;i<=n;++i)
		for(ll j=1;j<=n;++j){
			add(idL(i,j),idR(i,j),1);
			for(ll k=0;k<4;++k){
				ll nx=i+dx[k],ny=j+dy[k];
				if(nx>=1&&nx<=n&&ny>=1&&ny<=n&&(!(vis[i][j]&vis[nx][ny])))
					add(idR(i,j),idL(nx,ny),1);
			}
			if(i==1||j==1||i==n||j==n) add(idR(i,j),T,1);
			if(vis[i][j]) add(S,idL(i,j),1);
		}
	if(dinic()==m) cout<<"YES";
	else cout<<"NO";
	return 0;
}
```


---

## 作者：rui_er (赞：0)

最大流。

题目中的起始点肯定是要被超级源连上的。考虑到要求这 $m$ 个点能通过 $m$ 条不在格点相交的路径连到边界上，流的方法大致就是沿着网格线，然后边界点连超级汇，权值都是 $1$。另外，每个点只能在不超过一条路径上，只是这样会被重复流过，需要搞一遍拆点的套路。

这题的网络流建模挺经典的。

```cpp
//By: Luogu@rui_er(122461)
#include <bits/stdc++.h>
#define rep(x,y,z) for(int x=y;x<=z;x++)
#define per(x,y,z) for(int x=y;x>=z;x--)
#define debug printf("Running %s on line %d...\n",__FUNCTION__,__LINE__)
#define fileIO(s) do{freopen(s".in","r",stdin);freopen(s".out","w",stdout);}while(false)
using namespace std;
typedef long long ll;
const int N = 1e4+5, M = 5e5+5, inf = 0x3f3f3f3f; 

int n_, m_, n, m, s, t, dis[N], now[N];
template<typename T> void chkmin(T& x, T y) {if(x > y) x = y;}
template<typename T> void chkmax(T& x, T y) {if(x < y) x = y;}
struct Edge {
	int v, w, nxt;
	Edge(int a=0, int b=0, int c=0) : v(a), w(b), nxt(c) {}
	~Edge() {} 
}e[M];
int h[N], ne = 1;
void add(int u, int v, int w) {
	e[++ne] = Edge(v, w, h[u]); h[u] = ne;
	e[++ne] = Edge(u, 0, h[v]); h[v] = ne;
}
queue<int> q;
int dfs(int u, int lim) {
	if(u == t || !lim) return lim;
	int res = 0;
	for(int i=now[u];i;now[u]=i=e[i].nxt) {
		int v = e[i].v, w = e[i].w;
		if(dis[v] == dis[u] + 1) {
			int qwq = dfs(v, min(w, lim));
			if(!qwq) continue;
			e[i].w -= qwq; e[i^1].w += qwq;
			lim -= qwq; res += qwq;
			if(!lim) break;
		}
	}
	return res;
}
bool bfs() {
	rep(i, 1, n) {
		dis[i] = inf;
		now[i] = h[i];
	}
	dis[s] = 0;
	q.push(s);
	while(!q.empty()) {
		int u = q.front(); q.pop();
		for(int i=h[u];i;i=e[i].nxt) {
			int v = e[i].v, w = e[i].w;
			if(!w || dis[v] < inf) continue;
			dis[v] = dis[u] + 1;
			q.push(v);
		}
	}
	return dis[t] < inf;
}
int dinic() {
	int flow = 0;
	while(bfs()) flow += dfs(s, inf);
	return flow;
}
int getId(int x, int y) {
	return (x - 1) * n_ + y;
}

int main() {
	scanf("%d%d", &n_, &m_);
	s = 2 * n_ * n_ + 1;
	n = t = s + 1;
	rep(i, 1, m_) {
		int x, y;
		scanf("%d%d", &x, &y);
		add(s, getId(x, y), 1);
	}
	rep(i, 1, n_) {
		rep(j, 1, n_) {
			add(getId(i, j), n_*n_+getId(i, j), 1);
			if(i > 1) add(n_*n_+getId(i, j), getId(i-1, j), 1);
			if(j > 1) add(n_*n_+getId(i, j), getId(i, j-1), 1);
			if(i < n_) add(n_*n_+getId(i, j), getId(i+1, j), 1);
			if(j < n_) add(n_*n_+getId(i, j), getId(i, j+1), 1);
			if(i == 1 || j == 1 || i == n_ || j == n_) add(n_*n_+getId(i, j), t, 1);
		}
	}
	puts(dinic()==m_?"YES":"NO");
    return 0;
}
```

---


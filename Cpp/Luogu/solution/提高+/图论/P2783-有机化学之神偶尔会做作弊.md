# 有机化学之神偶尔会做作弊

## 题目背景

XS 中学化学竞赛组教练是一个酷爱炉石的人。

有一天他一边搓炉石一边监考，而你作为一个信息竞赛的大神也来凑热闹。

然而你的化竞基友却向你求助了。

“第 1354 题怎么做？”<--手语  他问道。

## 题目描述

你翻到那一题：给定一个烃，只含有单键（给初中生的一个理解性解释：就是一堆碳用横线连起来，横线都是单条的）。

然后炎魔之王拉格纳罗斯用他的火焰净化了一切环（？？？）。所有的环状碳都变成了一个碳，如图所示。

![环状碳变为一个碳](https://cdn.luogu.com.cn/upload/pic/2758.png)

然后指定多组碳，求出它们之间总共有多少碳，如图所示（和上图没有关系）。

![求出有多少碳](https://cdn.luogu.com.cn/upload/pic/2759.png)

但是因为在考试，所以你只能把这个答案用手语告诉你的基友。你决定用二进制来表示最后的答案，如图所示（不要在意，和题目没有什么没关系）。

![二进制手语](https://cdn.luogu.com.cn/upload/pic/2760.png)

### 题意简述

给你一个 $n$ 个点，$m$ 条边的无向图。把图中所有的环变为一个点，求变化后某两个点之间有多少个点。

## 说明/提示

两个碳不成环。

## 数据范围及约定

对于 $100\%$ 的数据，$1<n\le10 ^ 4$，$1<m\le5\times 10 ^ 4$。

## 样例 #1

### 输入

```
3 2
1 2
2 3
2
1 2
2 3
```

### 输出

```
10
10```

# 题解

## 作者：SammyChu (赞：35)

### 前言
在$[WA]$了$10$次之后，我终于过了这道题……

------------

读完题后思路就已经很明朗了：
1. 找环，缩点
1. 利用$LCA$寻找两点之间碳的个数

------------

**但是**……找环的过程？由于这是个**无向图**，所以是不存在强连通分量的。强连通分量是**有向图**中的定义。对于无向图只有双连通分量。而双连通分量又分两种：
- 点-双连通分量
- 边-双连通分量

从题目描述来看，本题需要把所有的碳环全部缩成一个点。但是由于我对双连通分量的缩点不熟，于是我专门去查看了资料：点-双连通分量的缩点是基于**割点**的，而边-双连通分量是基于**桥**的。

问题来了：是写 点-双连通分量 还是 边-双连通分量 呢？仔细查看定义后，我发现：点-双连通分量 缩点后的结构是不符合本题的要求的。因为**它缩点后是会把割点看作单独的一个点**，而本题是要求把所有的简单环变成一个点，此时这显然是不对的。

------------

至于题解里的各位大佬写的“点-双连通分量”，要么是我学艺不精，没有正确$get$ 点-双连通分量 的缩点的真正定义，要么就是那个不能叫 点-双连通分量 的缩点。不管怎么说，我放弃了写 点-双连通分量 的想法。
***
$P.S.$
***
这里仅仅是发表了个人的观点，如有异议欢迎在讨论区指教。个人感觉应该是我理解错了，因为那个感觉是强行把无向图写成了有向图的强连通分量，这当然是正确的，而且十分巧妙，只是说法可能不一样。如有冒犯，请多多包涵。~~（瑟瑟发抖）~~

------------

经过一番深思熟虑，我决定写 边-双连通分量。边-双连通分量 的求解方法如下：
1. 找到该图中的所有的桥（删去后使得原图不连通的边）
1. 把桥删掉，此时图中的每一个连通的部分组成一个 边-双连通分量。

然而这种做法有一个巨大的$bug$摆在面前：两点间的重边只能算一条边。而在桥的定义中，一旦有重边的存在，这些重边就都不能叫做桥了。但是在本题中，这是不对的。

解决的办法：**去掉重边即可**。

重边怎么去掉呢？我想到了三种思路：（我因为太菜了不会写$vector$）
1. 若用邻接表存图，则可利用哈希表的方式，在添加边之前先看有没有这条边存在。但是时间复杂度为$O(n^{2})$，超时。
2. 若采用邻接矩阵存图，则可以$O(1)$去掉重边，但是空间无法承受。
3. 采用双链表存图，并且把所有的边复制一遍，按照按照起点优先，终点其次，**编号**最后的关键字排序，然后$O(m)$判重。总时间复杂度：$O(m\cdot log_{2}m)$，可行。

	注意，一定要按照起点，终点，**编号**的关键字，这样才能保证相同的边相邻。至于为什么要在最后加一个编号，是因为一条无向边是当作两条有向边存的，如果编号从$2$开始，则一条边 $e$ 的对应边为 $e$ $xor$ $1$ 。必须要在最后的关键字中加入编号，才能保证前后属于一条无向边的两条有向边是一一对应的。比如前面有两个 $3$ $->$ $10$ ，编号为  $6$ 、$9$ ；后面有两个 $10$ $->$ $3$ ，编号为 $8$ 、$7$ ，没有一 一对应，去重后就会出错。（这个错我查了一下午，心酸）

	至于去重，直接用双链表就可以了。
***
接下来是缩点。去掉桥后，每一个连通块里的所有点标记上同一个颜色，然后查看所有边，把两条边的两点的颜色连起来重新建图。缩完点后图就变成了一棵树，随便指定一个点为根，跑$LCA$就行了。我用的是倍增，复杂度为$O(n\cdot log_{2}n)$。

最后统计出答案后转为二进制即可，总时间复杂度$O(m\cdot log_{2}m+tot\cdot n\cdot log_{2}n)$。

$[AC]$代码如下，其中有注释。
```cpp
#include<bits/stdc++.h>
using namespace std;
inline void read(int &x)//读入优化 
{
	int w=x=0;
	char ch=0;
	while(ch<'0'||'9'<ch)
		w|=(ch=='-'),ch=getchar();
	while('0'<=ch&&ch<='9')
		x=(x<<3)+(x<<1)+(ch^'0'),ch=getchar();
	x=w?-x:x;
}
const int N=1e5,M=5e5;//怒开10倍
//<吐槽>： 
//感觉最后一个点超出了题目描述的数据范围 
struct Edge
{
	int u,v;
}E[M<<1|1],e[M<<1|1];
struct node
{
	int no,u,v;
}cop[M<<1|1];
queue<int> q; 
int last=1,fst[N+1],nxt[M<<1|1],bef[M<<1|1];//原图 
int num,head[N+1],to[M<<1|1];//缩点图 
int n,m,dep,dfn[N+1],low[N+1];//tarjan
int tot,cnt,typ[N+1]; //缩点 
bool flag[M<<1|1],bri[M<<1|1],vis[N+1],rvis[N+1];//重边 , 桥 , 缩点 
int lg2[N+1],as[25][N+1],depth[N+1];//lca
void add(int x,int y)
{
	E[++last]=(Edge){x,y};
	bef[fst[x]]=last,nxt[last]=fst[x],fst[x]=last;//使用双链表便于删边 
	cop[last]=(node){last,x,y};
}
bool operator<(const node &x,const node &y)//重载运算符以便于排序删边 
{
	if(x.u!=y.u)
		return x.u<y.u;
	if(x.v!=y.v)	
		return x.v<y.v;
	return x.no<y.no;
}
void del(int x)//利用双链表删边 
{
	flag[x]=1;
	if(bef[x])
		nxt[bef[x]]=nxt[x];
	else
	{
		int y=E[x].u;
		fst[y]=nxt[x];
	}
}
void tarjan(int x,int e)//找桥 
{
	dfn[x]=low[x]=++dep;
	for(int i=fst[x];i;i=nxt[i])
	{
		int y=E[i].v;
		if(i==(e^1))
			continue;
		if(!dfn[y])
		{
			tarjan(y,i);
			low[x]=min(low[x],low[y]);
			if(low[y]>dfn[x])
				bri[i]=bri[i^1]=1;//桥的判定法则 
		}
		else
			low[x]=min(low[x],dfn[y]);
	}
}
void run(int x)//遍历找连通块 
{
	vis[x]=1;
	q.push(x);
	for(int i=fst[x];i;i=nxt[i])
	{
		int y=E[i].v;
		if(!vis[y]&&!bri[i])
			run(y); 
	}
}
void radd(int x,int y)//重新建图 
{
	e[++num]=(Edge){x,y};
	to[num]=head[x],head[x]=num;
}
void dfs(int x,int fa)//lca预处理 
{
	rvis[x]=1,depth[x]=depth[fa]+1,as[0][x]=fa;
	for(int i=1;i<=lg2[depth[x]]+1;++i)
		as[i][x]=as[i-1][as[i-1][x]];
	for(int i=head[x];i;i=to[i])
	{
		int y=e[i].v;
		if(!rvis[y]&&y!=fa)
			dfs(y,x);
	}
}
int lca(int x,int y)//倍增求lca 
{
	if(depth[x]<depth[y])
		swap(x,y);
	for(int i=lg2[depth[x]]+1;i>=0;--i)
	{
		if(depth[as[i][x]]>=depth[y])
			x=as[i][x];
		if(x==y)
			return x;
	}
	for(int i=lg2[depth[x]]+1;i>=0;--i)
		if(as[i][x]!=as[i][y])
			x=as[i][x],y=as[i][y];
	return as[0][x]; 
}
void print(int x)
{
	if(x==0)
	{
		printf("0");
		return;
	}
	if(x==1)
	{
		printf("1");
		return;
	}
	print(x>>1);
	printf("%d",x%2);	
}
int main()
{
	read(n),read(m);
	for(int i=1;i<=m;++i)
	{
		int a,b;
		read(a),read(b);
		if(a!=b) 
			add(a,b),add(b,a);
	}
	sort(cop+2,cop+last+1);//排序去重边 
	for(int i=3;i<=last;++i)
		if(cop[i].u==cop[i-1].u&&cop[i].v==cop[i-1].v)
			del(cop[i].no);
	for(int i=1;i<=n;++i)
		if(!dfn[i])
			tarjan(i,1);
	for(int i=1;i<=n;++i)
		if(!vis[i])
		{
			run(i);
			++cnt;
			while(!q.empty())//利用队列存储连通块 
			{
				typ[q.front()]=cnt;
				q.pop();
			}
		}
	for(int i=2;i<=last;++i)
	{
		if(flag[i])
			continue;//不要忘了去掉重边 
		int a=E[i].u,b=E[i].v;
		a=typ[a],b=typ[b];
		if(a!=b)
			radd(a,b),radd(b,a);
	}
	for(int i=2;i<=cnt;++i)
		lg2[i]=lg2[i>>1]+1;
	dfs(1,0);
	read(tot);
	while(tot--)
	{
		int a,b;
		read(a),read(b);
		a=typ[a],b=typ[b];
		int c=lca(a,b);
		int ans=depth[a]+depth[b]-(depth[c]<<1)+1;//计算碳的个数，记得+1 
		print(ans);
		printf("\n");
	}
	return 0;
}
```
当然，我这种写法其实并不优，复杂度没有其他大佬们的方法优，请谅解！

---

## 作者：Kelin (赞：30)

题意:给你一个无向图,其中一个点双联通分量算作一个点,询问两个点之间有多少点

点双联通分量:所谓点-双连通分量是指在一个无向图中两点间至少有两条路径,且路径中(不算头尾)的点不同.

我们只要把所有的双联通分量缩成一个点,然后这个图又是一个连通图

即缩点之后就是一个联通无环图了——即树

询问两点之间有多点就是询问树上距离+1了

树上距离=dep[u]+dep[v]-2\*dep[lca(u,v)]

然后这道题,tarjan的时候最好用vector存边,不然第4个点死活过不去(不要问我为啥知道的)


---

## 作者：Hyscere (赞：20)


边双缩点然后$lca$跑$dis$就好了。

注意这里是边双，不知道为啥所有题解都说的是点双。

边双是定义在点上的，即每个点只属于一个边双；点双是定义在边上的，即每条边只属于一个点双。

```c++
#include<bits/stdc++.h>
using namespace std;
 
void read(int &x) {
    x=0;int f=1;char ch=getchar();
    for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-f;
    for(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';x*=f;
}
 
void print(int x) {
    if(x<0) putchar('-'),x=-x;
    if(!x) return ;print(x/2),putchar(x%2+48);
}
void write(int x) {if(!x) putchar('0');else print(x);putchar('\n');}

#define lf double
#define ll long long 

const int maxn = 2e4+10;
const int maxm = 1e5+10;
const int inf = 1e9;
const lf eps = 1e-8;

int n,m;

struct Tree {
	int head[maxn],tot,fa[maxn][15],dep[maxn],vis[maxn];
	struct edge{int to,nxt;}e[maxm<<1];

	void add(int u,int v) {e[++tot]=(edge){v,head[u]},head[u]=tot;}
	void ins(int u,int v) {add(u,v),add(v,u);}

	void dfs(int x,int Fa) {
		dep[x]=dep[Fa]+1,fa[x][0]=Fa;
		for(int i=1;i<=14;i++) fa[x][i]=fa[fa[x][i-1]][i-1];
		for(int i=head[x];i;i=e[i].nxt)
			if(e[i].to!=Fa) dfs(e[i].to,x);
	}

	int lca(int x,int y) {
		if(dep[x]<dep[y]) swap(x,y);
		for(int i=14;~i;i--) if(dep[fa[x][i]]>=dep[y]) x=fa[x][i];
		if(x==y) return x;
		for(int i=14;~i;i--) if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i];
		return fa[x][0];
	}

	int dis(int x,int y) {return dep[x]+dep[y]-2*dep[lca(x,y)]+1;}
}T;

struct Graph {
	int head[maxn],tot,dfn[maxn],low[maxn],dfn_cnt,bel[maxn],col,sta[maxn],top;
	struct edge{int to,nxt;}e[maxm<<1];

	void add(int u,int v) {e[++tot]=(edge){v,head[u]},head[u]=tot;}
	void ins(int u,int v) {add(u,v),add(v,u);}
	
	void tarjan(int x,int fa) {
		dfn[x]=low[x]=++dfn_cnt,sta[++top]=x;
		for(int v,i=head[x];i;i=e[i].nxt) {
			if((v=e[i].to)==fa) continue;
			if(!dfn[v]) tarjan(v,x),low[x]=min(low[x],low[v]);
			else low[x]=min(low[x],dfn[v]);
		}
		if(dfn[x]==low[x]) {
			++col;
			while(sta[top]!=x) bel[sta[top--]]=col;
			bel[sta[top--]]=col;
		}
	}

	void prepare() {
		for(int i=1;i<=n;i++) if(!dfn[i]) tarjan(i,0);
		for(int x=1;x<=n;x++)
			for(int i=head[x];i;i=e[i].nxt)
				if(bel[e[i].to]!=bel[x]) T.add(bel[e[i].to],bel[x]); //注意这里单向边
		T.dfs(1,0);
	}
}G;

int main() {
	read(n),read(m);for(int i=1,x,y;i<=m;i++) read(x),read(y),G.ins(x,y);
	G.prepare();int q;read(q);for(int i=1,x,y;i<=q;i++) read(x),read(y),write(T.dis(G.bel[x],G.bel[y]));
	return 0;
}
```

---

## 作者：zhengrunzhe (赞：12)

用邻接表过了啊？？？？

提供个tarjanLCA

tarjan算法求完双连通分量之后重构图，输出两点间距离

dep[x]+dep[y]-2dep[lca]+1


```cpp
#include<stack>
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=1e4+10,M=5e4+10;
stack<int>s;
bool vis[N];
int n,m,tot,dfn[N],low[N],dfn_cnt,edge_cnt,ciredge_cnt,ask_cnt,cir_cnt,head[N],from[N],start[N],cir[N],fa[N],lca[N],dep[N]={0,1};
struct edge{int to,next,num;}e[M*2],c[M*2],q[N];
inline void addedge(int a,int b) //加一条原图的边 
{
	e[++edge_cnt].next=head[a];
	head[a]=edge_cnt;
	e[edge_cnt].to=b;
}
inline void addcircle(int a,int b) //加一条双连通分量的边 
{
	c[++ciredge_cnt].next=from[a];
	from[a]=ciredge_cnt;
	c[ciredge_cnt].to=b;
}
inline void addquery(int a,int b,int c) //加一条lca查询的边 
{
	q[++ask_cnt].next=start[a];
	start[a]=ask_cnt;
	q[ask_cnt].to=b;
	q[ask_cnt].num=c;
}
void dfs(int p,int fa)
{
	low[p]=dfn[p]=++dfn_cnt;s.push(p);
	for (int to,i=head[p];i;i=e[i].next)
		if ((to=e[i].to)!=fa)
			if (!dfn[to])dfs(to,p),low[p]=min(low[p],low[to]);
			else if (!cir[to])low[p]=min(low[p],dfn[to]);
	if (low[p]!=dfn[p])return;
	cir_cnt++;
	while (1)
	{
		int x=s.top();s.pop();
		cir[x]=cir_cnt;
		if (x==p)break;
	}
}
inline void tarjan()
{
	for (int i=1;i<=n;i++)if (!dfn[i])dfs(i,0);
}
inline void rebuild() //重构图 
{
	for (int id1,i=1;i<=n;i++)
		for (int id2,j=head[i];j;j=e[j].next)
			if ((id1=cir[i])!=(id2=cir[e[j].to]))
				addcircle(id1,id2),addcircle(id2,id1);
}
inline void init() 
{
	fill(vis+1,vis+cir_cnt+1,0);
	for (int i=1;i<=cir_cnt;i++)fa[i]=i;
}
int find(int x)
{
	return fa[x]==x?x:fa[x]=find(fa[x]);
}
inline void Union(int x,int y)
{
	int f1=find(x),f2=find(y);
	if (f1==f2)return;
	fa[f1]=f2;
}
void getdep(int p) //dfs求深度 
{
	vis[p]=1;
	for (int to,i=from[p];i;i=c[i].next)
		if (!vis[to=c[i].to])
			dep[to]=dep[p]+1,getdep(to);
}
void tarjan_lca(int p) //tarjan求lca 
{
	vis[p]=1;
	for (int to,i=start[p];i;i=q[i].next)
		if (vis[to=q[i].to])lca[q[i].num]=find(to);
	for (int to,i=from[p];i;i=c[i].next)
		if (!vis[to=c[i].to])
			tarjan_lca(to),Union(to,p);
}
inline int distance(int x,int y,int lca)
{
	return dep[x]+dep[y]-2*dep[lca]+1;
}
inline void print(int x) //转成二进制输出 
{
	stack<bool>st;
	while (x)st.push(x%2),x/=2;
	while (st.size())printf("%d",st.top()),st.pop();
	puts("");
}
int main()
{
	scanf("%d%d",&n,&m);
	int a,b;
	while (m--)
		scanf("%d%d",&a,&b),
		addedge(a,b),addedge(b,a);
	tarjan();rebuild();
	scanf("%d",&tot);
	for (int i=1;i<=tot;i++)
		scanf("%d%d",&a,&b),
		addquery(cir[a],cir[b],i),addquery(cir[b],cir[a],i);
	getdep(1);init();tarjan_lca(1);
	for (int i=1;i<=tot;i++)
		print(distance(q[i*2].to,q[i*2-1].to,lca[i]));
	return 0;
}
```

---

## 作者：Juan_feng (赞：12)

### 终于有机会写一道黑题~~至少目前是这样~~的题解了！小蒟蒻好兴奋qwq

这道题可以说是非常水了，方法都差不多，基本上就是先用tarjan求双联通分量缩一下点，然后再重新建图进行处理，最后把答案转化为二进制。

看各位dalao都是缩点后求出lca再直接计算的（**depth[x]+depth[y]-depth[lca]*2+1**）

**小蒟蒻这里提供一种在树剖中直接求出答案的方法~~（似乎本质上并没有区别）~~权当是一种思路吧qwq**
```
int qrange(int x,int y){
    int ress=0;
    while(top[x]!=top[y]){  
        if(depth[top[x]]<depth[top[y]])
          swap(x,y);
        ress+=depth[x]-depth[top[x]]+1;
        x=fa[top[x]];
    }
    if(depth[x]>depth[y])
      swap(x,y);
    int ree=depth[y]-depth[x]+1;
    return ress+ree;
}

```
**在树剖每次跳链的时候顺便求出走过的碳的数量，这样就不用专门求lca了（雾**

有dalao说必须要用vector存边，小蒟蒻瑟瑟发抖，思量再三最后还是用的邻接表，然而就过了(雾

程序中还有简单的注解，小蒟蒻在这里就不多说了qwq

那么代码如下：

```
#include<iostream>
#include<cstring>
#include<cstdio>
#include<stack>
#define maxn 200010
#define re register
#define FOR(i,l,r) for(re int i=l;i<=r;i++)
using namespace std;

int n,m,k,c,t,cnt,num,num1,tot,co,x,y,z;
int ans[maxn],head1[maxn],depth[maxn],fa[maxn],son[maxn],head2[maxn];
int a[maxn],low[maxn],dfn[maxn],val[maxn],b[maxn],siz[maxn],top[maxn]; 
int shu[100010],id[maxn];

struct hz{
    int next;
    int to;
    int ff;
}h1[maxn],h2[maxn]; //邻接表存图

stack<int> st;

inline void in(int &x){ //无处不在的快读
    x=0;int f=1;char c=getchar();
    while(c<'0'||c>'9'){
        if(c==-1) return;
        if(c=='-')f=-1;
        c=getchar();
    }
    while(c<='9'&&c>='0'){
        x=(x<<1)+(x<<3)+(c^'0');
        c=getchar();
    }
    x=x*f;
}

inline void out(int a){
    if(a<0){
        a*=-1;
        putchar('-');
    } 
    if(a>=10)out(a/10);
    putchar(a%10+'0');
}

void add1(int from,int to){  //读入时的加边
    h1[++num].next=head1[from];
    h1[num].ff=from;
    h1[num].to=to;
    head1[from]=num;
}

void add2(int from,int to){ //缩点后的加边
    h2[++num1].next=head2[from];
    h2[num1].to=to;
    head2[from]=num1;
}

void tarjan(int x,int f){ //tarjan求双连通分量
    dfn[x]=low[x]=++tot;
    b[x]=1;
    st.push(x);
    for(re int i=head1[x];i!=0;i=h1[i].next){
        if(h1[i].to==f) //和tarjan求强联通分量略用差别，不能走回父节点
          continue;
        if(dfn[h1[i].to]==0){
            tarjan(h1[i].to,x);
            low[x]=min(low[x],low[h1[i].to]);
        }
        else
          if(b[h1[i].to]==1)
            low[x]=min(low[x],dfn[h1[i].to]);
    }
    if(dfn[x]==low[x]){
        ++co;
        while(x!=st.top()){
            b[st.top()]=0;
            a[st.top()]=co;
            st.pop();
        }
        b[x]=0;
        a[x]=co;
        st.pop();
    }
}

void dfs1(int f,int ff){ 
    depth[f]=depth[ff]+1;
    fa[f]=ff;
    siz[f]=1;
    for(re int i=head2[f];i!=0;i=h2[i].next){
        if(h2[i].to==ff)
          continue;
        dfs1(h2[i].to,f);
        siz[f]+=siz[h2[i].to];
        if(siz[h2[i].to]>siz[son[f]])
          son[f]=h2[i].to;
    }
}

void dfs2(int x,int topf){ 
    top[x]=topf;
    id[x]=++cnt;
    if(!son[x])
      return;
    dfs2(son[x],topf);
    for(re int i=head2[x];i!=0;i=h2[i].next){
        if(h2[i].to==fa[x]||h2[i].to==son[x])
          continue;
        dfs2(h2[i].to,h2[i].to);
    }
}

int qrange(int x,int y){ //树剖求答案
    int ress=0;
    while(top[x]!=top[y]){
        if(depth[top[x]]<depth[top[y]])
          swap(x,y);
        ress+=depth[x]-depth[top[x]]+1;
        x=fa[top[x]];
    }
    if(depth[x]>depth[y])
      swap(x,y);
    int ree=depth[y]-depth[x]+1;
    return ress+ree;
}

void zhuan(int x){ //转2进制
    int w=0;
    memset(shu,0,sizeof(shu));
    while(x!=0){
        shu[++w]=x%2;
        x/=2;
    }
    for(re int i=w;i>=1;i--)
      out(shu[i]);
    puts("");
}

int main(){
    in(n),in(m);
    FOR(i,1,m){
        in(x),in(y);
        add1(x,y);  //无向边
        add1(y,x); 
    }
    co=0;
    FOR(i,1,n)   //求环
      if(!dfn[i])
        tarjan(i,0);
    FOR(i,1,2*m){ //缩点重新建图
        if(i%2==0) continue;
        if(a[h1[i].ff]!=a[h1[i].to])
          add2(a[h1[i].ff],a[h1[i].to]),add2(a[h1[i].to],a[h1[i].ff]);
    }
    dfs1(1,0);
    dfs2(1,1);
    int kk,ansss;
    in(kk);
    FOR(i,1,kk){
        in(x),in(y);
        x=a[x],y=a[y];  //读入点所在的双连通分量的序号
        zhuan(qrange(x,y)); //转换2进制
    }
    return 0; //功德圆满
}
```

---

## 作者：genshy (赞：10)

# 前言

这道题以前还是道（~~水~~）黑题，现在怎么降紫了？？？？

## 前置芝士

1. tarjain 缩点

1. 倍增求LCA或树剖求LCA

1. 脑子。。。

## 题意

给你一个无向图，要求你把所有的环缩成一个点。在新得到的图上问你两个点之间有多少个点。

## 分析

首先我们会由 "所有的环状碳都变成了一个碳" 想到要缩点。

但是无向图怎么缩点呢？

我们可以按照原来无向图那样缩点，但要注意的一点是 $to != fa[x] $

因为这是无向图，可能有的边会直接连向他父亲，假如我们要走这条边的话，就会重

复搜，就这样一直无限循环下去。剩下的就和有向图的缩点没什么区别了。

接着我们就要考虑每个询问。

我们把所有的环去掉后，就会得到一个有向无环图（树）。不理解的童鞋请画图自证

那么问题就会转化为树上问题。

甩给你一张图

![](https://images.cnblogs.com/cnblogs_com/zjp-shadow/1056673/o_tree3.png)

假如我们要求 $4$ 和 $7$ 之间的有多少个点。我么可以用

$dep[4] + dep[7] - 2 * dep[3] + 1 $ 

即 $dep[x] + dep[y] - 2 * dep[lca(x,y)] + 1$

由于他的深度有类似于前缀和的性质，所以我们可以这么处理。

为什么要减一呢？ 因为你 $LCA $处 只能算一个点，但你却减了两次，所以要

重新加上

## 补充

关于一个数转二进制的方法。

我们可以联想到快速幂中要依次取出指数的二进制每一位，所以我们可以像快速幂

中的写法模拟出二进制每一位。

代码如下

```cpp
void shuchu(int x)
{
    int xx = 0;//记录有多少位
    for(; x; x>>=1)//依次取出每一位上的数字
    {
    	xx++;
    	if(x & 1) t[xx] = 1;
    	else t[xx] = 0;
    }
    for (int i = xx; i >= 1; i-- )  printf("%d",t[i]);//倒序输出
    printf("\n");
}
```

## 几个要注意的点

1. 求两个点的LCA 一定要在新建的图上求 （本蒟蒻就在这里卡了好几回）

1. 树剖求 LCA 时要注意是在缩完点之后的图上求

1. tarjain 缩点时要注意不能访问到他父亲的边

## 新发现

以前的代码，我求的是每一条链的轻儿子竟然意外的AC了。

但求重儿子要比求轻儿子要跑的快。雾


不懂得同鞋 , 请看下面代码 ，下面有注释。

## 代码
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int N = 1e5+10;
int n,m,u,v,x,y,tot,sum,cnt,num,topp,T;
int dep[N],fa[N],size[N],top[N],head[N],hed[N];
int shu[N],dfn[N],low[N],sta[N],son[N];
int t[N];
bool vis[N];
inline int read()//标准快读
{
	int s = 0,w = 1; char ch = getchar();
	while(ch < '0' || ch > '9'){if(ch == '-') w = -1; ch = getchar();}
	while(ch >= '0' && ch <= '9'){s = s * 10+ch -'0'; ch = getchar();}
	return s * w;
}
struct node{int to,net;}e[N<<1],edge[N<<1];//为了压行不择手段
void add(int x,int y)
{
	e[++tot].to = y;
	e[tot].net = head[x];
	head[x] = tot;
}
void add_(int x,int y)//建新图上的边
{
	edge[++sum].to = y;
	edge[sum].net = hed[x];
	hed[x] = sum;
}
void tarjain(int x,int fa)//缩点
{
	dfn[x] = low[x] = num++;
	sta[++topp] = x; vis[x] = 1;
	for(int i = head[x]; i; i = e[i].net)
	{
		int to = e[i].to;
		if(to == fa) continue;//特判是不是联向他父亲得边
		if(!dfn[to])
		{
			tarjain(to,x);
			low[x] = min(low[x],low[to]);
		}
		else if(vis[to])
		{
			low[x] = min(low[x],dfn[to]);
		}
	}
	if(dfn[x] == low[x])//求强联通分量
	{
		cnt++; int y;
		do
		{
			y = sta[topp--];
			//size[cnt]++;
			shu[y] = cnt;
			vis[y] = 0;
		}while(x != y);
	}
}
void get_tree(int x)//树剖第一遍DFS求重儿子
{
	dep[x] = dep[fa[x]] + 1; size[x] = 1;
	for(int i = hed[x]; i; i = edge[i].net)
	{
		int to = edge[i].to;
		if(to == fa[x]) continue;
		fa[to] = x;
		get_tree(to);
		size[x] += size[to];
		if(size[to] > size[son[x]]) son[x] = to;
	}
}
void dfs(int x,int topp)//树剖第二遍DFS求每条链的顶端
{
	top[x] = topp;
	if(son[x]) dfs(son[x],topp);
	for(int i = hed[x]; i; i = edge[i].net)
	{
		int to = edge[i].to;
		if(to == fa[x] || to == son[x]) continue;
		dfs(to,to);
	}
}
int lca(int x,int y)//树剖求LCA
{
	while(top[x] != top[y])
	{
		if(dep[top[x]] < dep[top[y]]) swap(x,y);
		x = fa[top[x]];
	}
	if(dep[x] < dep[y]) return x;
	else return y;
}
void shuchu(int x)//二进制转化
{
    int xx = 0;
    for(; x; x>>=1)
    {
    	xx++;
    	if(x & 1) t[xx] = 1;
    	else t[xx] = 0;
    }
    for (int i = xx; i >= 1; i--) printf("%d",t[i]);
    printf("\n");
}
int main()
{
	n = read(); m = read();
	for(int i = 1; i <= m; i++)
	{
		u = read(); v = read();
		add(u,v); add(v,u);
	}
	for(int i = 1; i <= n; i++)
	{
		if(!dfn[i]) tarjain(i,0);
	}
	for(int i = 1; i <= n; i++)//缩点
	{
		for(int j = head[i]; j; j = e[j].net)
		{
			int to = e[j].to; 
			if(shu[to] != shu[i])
			{
				add_(shu[i],shu[to]);
			}
		}
	}
	get_tree(1);
	dfs(1,1);
	T = read();
	while(T--)
	{
		x = read(); y = read();
		int Lca = lca(shu[x],shu[y]);
		int ans = dep[shu[x]] + dep[shu[y]] - 2 * dep[Lca] + 1;//计算每个询问的答案
		shuchu(ans);
	}
	return 0;
}
```




---

## 作者：米奇奇米 (赞：10)

## 题解-P2783 有机化学之神偶尔会做作弊
**[P2783 有机化学之神偶尔会做作弊]**(https://www.luogu.org/problemnew/show/P2783)
### $1.1$ 题目意思
按照人话讲就是给你一张图，让你缩点，然后求树上两点之间距离即可（答案以二进制形式输出）

### $2.1$算法思想
按照$1.1$马上就可以想到先用$tarjan$缩点一遍，然后再重构图，再呢就是$lca$求出树上两点距离，再用数组模拟二进制转换。于是你就水过啦一道黑题。但是值得注意的是在$tarjan$缩点的时候，如果这个环的大小$siz\leq 2$（题目中说两个碳不成环）就跳过即可。主要是细节问题，其余的都很简单的呀。

### $3.1$代码实现
**第一部分：tarjan缩点**
```cpp
inline void tarjan(int u,int fa) {
//略加变化的trajan模板
    stak[++top]=u;
    low[u]=dfn[u]=++now;
    for ( int i=head[u];i;i=e[i].nex ) {
        int v=e[i].to;
        if(v==fa) continue;//如果siz<=2不缩点
        if(!dfn[v]) {
            tarjan(v,u);
            low[u]=min(low[u],low[v]);
        }
        else 
            if(!col[v]) 
                low[u]=min(low[u],dfn[v]);
    }
    if(low[u]==dfn[u]) {
        col[u]=++sum;
        siz[sum]++;
        while(stak[top]!=u) {
            col[stak[top]]=sum;
            siz[sum]++;
            top--;
        }
        top--;
    }
}
```

**第二部分：重新构图**
```cpp
    cnt=0;
    memset(head,0,sizeof(head));
    memset(e,0,sizeof(e));
    //初始化
    for ( int i=1;i<=m;i++ ) 
        if(col[u[i]]!=col[v[i]]) {
        //如果两个点在不同的强连通分量里面，连两个强连通分量
            add_edge(col[u[i]],col[v[i]]);
            add_edge(col[v[i]],col[u[i]]);
        }
```

**第三部分：dfs预处理+lca倍增**
```cpp
inline void dfs(int u,int fa) {
    d[u]=d[fa]+1;//预处理深度
    pa[u][0]=fa;//求父亲是谁
    for ( int i=1;i<=20;i++ ) 
        pa[u][i]=pa[pa[u][i-1]][i-1];//倍增预处理pa数组
    for ( int i=head[u];i;i=e[i].nex ) {
        int v=e[i].to;
        if(v==fa) continue;
        dfs(v,u);//递归下去
    }
}

inline int lca(int a,int b) {
    if(d[a]>d[b]) swap(a,b);
    for ( int i=20;i>=0;i-- ) 
        if(d[b]-(1<<i)>=d[a]) b=pa[b][i];
    if(a==b) return a;//如果已经相同求直接返回
    for ( int i=20;i>=0;i-- ) 
        if(pa[a][i]!=pa[b][i]) {
            a=pa[a][i];
            b=pa[b][i];
        }
    return pa[a][0];
}
```
**第四部分：求树上两点之间的距离**
$d[a]+d[b]-2*d[lca(a,b)]$
```cpp
inline int find(int a,int b) {
    return d[a]+d[b]-2*d[lca(a,b)]+1;
}
```

**第五部分：二进制转换**
```cpp
inline void change(int s) {
    int len=0;
    memset(bit,0,sizeof(bit));
    while(s!=0) {
        bit[++len]=s%2;//数组模拟每一位情况
        s/=2;
    }
    for ( int i=len;i>=1;i-- ) 
        printf("%d",bit[i]);
    printf("\n");
}
```
**代码主要就这么多了，剩下的就是细节问题，代码也就不放了，祝大家A掉这道黑题，美滋滋。。。**





---

## 作者：BILL666 (赞：10)

[更舒适的体验](https://www.luogu.org/blog/doitsmart/solution-p2783)

### 这是一道非常好~~（shui)~~的题 
与各位大佬基本相同：

1.先用Tarjan找出图中所有的强连通分量

2.然后缩点并且重新构建图

3.很显然此时整个图已经是一个树了，跑LCA

4.二进制输出

**这里有一个小小的优化（所以可以不用vector存边）**

-读入每条边时用数组记下

-重新构建图时直接枚举每一个点

-检查他们是否在同一个强连通分量内

-如果否，连边即可

**重构图时间复杂度降了一维哦**

## code

```cpp
#include<bits/stdc++.h>
#define N 100001
using namespace std;
int n,m,tot,q,sign,top,cnt;
int first[N<<1][2],next[N<<1][2],to[N<<1][2],dfn[N],low[N],sta[N],id[N],dep[N];
int p[N][50],xx[N],yy[N];
bool insta[N];
void ADD(int x,int y,int w)
{
	next[++tot][w]=first[x][w];
    to[tot][w]=y;
    first[x][w]=tot;
}
void add(int x,int y,int w)
{
	ADD(x,y,w);
    ADD(y,x,w);
}
////强连通分量部分 
void DFS(int x,int fa)
{
    dfn[x]=low[x]=++sign;
    sta[++top]=x;
    insta[x]=1;
    int k=first[x][0],u;
    while(k)
    {
        u=to[k][0];
        if(u==fa) //两个碳不成环
        {
            k=next[k][0];
            continue;
        }
        if(!dfn[u])
        {
            DFS(u,x);
            low[x]=min(low[u],low[x]);
        }
        else if(insta[u])
            low[x]=min(low[x],dfn[u]);
        k=next[k][0];
    }
    if(low[x]==dfn[x])
    {
    	cnt++;
    	while (7) 
        {
        	int y=sta[top];
        	top--;
        	id[y]=cnt;
        	if(x==y)
            	break;
    	}
    }
    return;
}
//重构图
void rebuild()
{
    tot=0;
    for(int i=1;i<=m;i++)
        if(id[xx[i]]!=id[yy[i]])
            add(id[xx[i]],id[yy[i]],1);
}
//LCA预处理
void DFS2(int son,int fa)
{
    dep[son]=dep[fa]+1;
    p[son][0]=fa;
    for(int i=first[son][1];i;i=next[i][1]) 
        if(to[i][1]!=fa) 
            DFS2(to[i][1],son);
    return;
}
//LCA
int LCA(int a,int b)
{
    if(a==b) return a;
    if(dep[a]>dep[b]) swap(a,b);
    for(int i=20;i>=0;i--) 
        if(dep[p[b][i]]>=dep[a]) 
            b=p[b][i];
    if(a==b) return a;
    for(int i=20;i>=0;i--) 
        if(p[a][i]!=p[b][i])
            a=p[a][i],b=p[b][i];
    return p[a][0];
}
//输出
int tmp[64];
void print(int res) 
{
    if(res==0) {puts("0");return;}
    if(res<0) {putchar('-');res=0-res;}
    while(res) tmp[++tmp[0]]=res&1,res>>=1;
    while(*tmp) putchar(tmp[(*tmp)--]+'0');
    putchar('\n');
} 
int main()
{
    cin>>n>>m;
    for(int i=1;i<=m;i++) 
    {
        cin>>xx[i]>>yy[i];
        add(xx[i],yy[i],0);
    }
    for(int i=1;i<=n;i++)
        if(!dfn[i]) DFS(i,0);
    rebuild();
    DFS2(1,0);
    for(int i=1;i<=20;i++)
        for(int j=1;j<=cnt;j++)
            p[j][i]=p[p[j][i-1]][i-1];
    cin>>q;
    while(q--)
    {
        int a,b;
        cin>>a>>b;
        a=id[a];
        b=id[b];//记得一定是缩完点后的编号！！
//我被卡了n次
        int lca=LCA(a,b),ans;
        ans=dep[a]+dep[b]-(dep[lca]<<1)+1;
        print(ans);
    }
    return 0;
}
```

[广告](https://www.luogu.org/blog/doitsmart/#)

---

## 作者：Nepenthe (赞：9)

这真是一道水积分的好题(咦为什么我发的所有题解都是水积分的好题)

其实仔细想想,这道题并没有什么很难的地方

把环缩成点用双联通分量(只要改一下强连通分量就好了),然后建棵树跑LCA就好了

摆两个板子上去,你就可以获得92分(因为第四个点过不了)

用vector存边就可以过了(不知道为什么但是BeNoble大佬发现了这一点%%%%)

```cpp
#include<iostream>
#include<cstdio>
#include<string>
#include<cstring>
#include<algorithm>
#include<vector>
#include<cmath>
#define siz 10010
#define minn(a,b) (a<b?a:b)
using namespace std;
//强连通分量部分 
int n,m,s,t,pos,top,cnt,corcnt;
int first[siz],dfn[siz],low[siz],cor[siz],corsiz[siz],st[siz];
bool in[siz];
vector <int> node[siz*10];
void tajan(int p,int form) {
    dfn[p]=low[p]=++cnt;
    st[++top]=p,in[p]=1;
    for(int i=0;i<node[p].size();++i)
     if(node[p][i]!=form) {
         if(!dfn[node[p][i]]){
            tajan(node[p][i],p);
            low[p]=minn(low[node[p][i]],low[p]);
         } else if(in[node[p][i]]) low[p]=minn(low[p],dfn[node[p][i]]);
     }
    int j;
    if(low[p]==dfn[p]) {
        corcnt++;
        do {
            j=st[top--],in[j]=0; 
            cor[j]=corcnt,corsiz[corcnt]++;
        }while(j!=p);
    }
}

//重建图 
int rfirst[siz];
vector <int> rnode[siz*10];
void rebuild() {
    pos=0;
    for(int i=1;i<=n;++i)
     for(int j=0;j<node[i].size();++j)
       if(cor[i]!=cor[node[i][j]]) rnode[cor[i]].push_back(cor[node[i][j]]);
}

//LCA部分
int q;
int u,v,dep[siz],T[siz][21];
void dfs(int p,int fa,int depth){
    dep[p]=depth,T[p][0]=fa;
    for(int i=0;i<rnode[p].size();++i)
     if(rnode[p][i]!=fa) dfs(rnode[p][i],p,depth+1);
}
int LCA(int u,int v) {
    if(dep[u]<dep[v]) swap(u,v);
    int d=dep[u]-dep[v];
    for(int i=20;i>=0;--i)
      if(d&(1<<i)) u=T[u][i];
    if(u==v) return u;
    for(int i=20;i>=0;--i)
      if(T[u][i]!=T[v][i]) u=T[u][i],v=T[v][i];
    return T[u][0];
}

//输出部分
int tmp[64];
void print(int res) {
    if(res==0) { puts("0"); return ;}
    if(res<0) { putchar('-');res=0-res; }
    while(res) tmp[++tmp[0]]=res&1,res>>=1;
    while(*tmp) putchar(tmp[(*tmp)--]+'0');
    putchar('\n');
} 
int main(){

//    freopen(".in","r",stdin);
//    freopen(".out","w",stdout);
    scanf("%d%d",&n,&m);
    while(m--) {
        scanf("%d%d",&s,&t);
        node[s].push_back(t);
        node[t].push_back(s);
    }
    for(int i=1;i<=n;++i)
     if(!dfn[i]) tajan(i,0);
    rebuild();
    dfs(1,0,0);
    for(int j=1;j<=20;++j)
     for(int i=1;i<=corcnt;++i)
      T[i][j]=T[T[i][j-1]][j-1];
    scanf("%d",&q);
    for(int i=1;i<=q;++i) {
        scanf("%d%d",&u,&v);
        int lca=LCA(cor[u],cor[v]);
        print(dep[cor[u]]+dep[cor[v]]-(dep[lca]<<1)+1);
    }
    return 0;
}
```
代码风格比较诡异你们可以复制然后Astyle一下


---

## 作者：顾z (赞：8)


# [顾](https://www.luogu.org/blog/RPdreamer/#)[z](https://www.cnblogs.com/-guz/)

~~你没有发现两个字里的blog都不一样嘛~~ qwq

题目描述-->[p2783 有机化学之神偶尔会做作弊](https://www.luogu.org/problemnew/show/P2783)

挺恶心的一个题,涉及到了$tarjan+LCA$

首先$Tarjan$缩点,对强连通分量之间建边.跑$LCA$即可

需要注意的是,求出来$LCA$之后求距离的时候,要$+1$

$$ans=dis[x]+dis[y]-2\times dis[lca]+1$$

这里为为什么要加$1$?我们计算$dis[x]+dis[y]-2\times dis[lca]$的时候就减去了$LCA$这个点,需要再加上.

(建议手绘一下 qwq)

转化为二进制也很简单,不多$BB$ 　~~虽然刚开始我也写错了 qwq~~

**PS：当求$LCA$的时候要对$x,y$所在强连通分量求$LCA$**

``代码``

```c++
/*变量名起的很玄学 qwq,看清*/
#include<bits/stdc++.h>
#define N 100008
#define R register
using namespace std;
inline void in(int &x)
{
	int f=1;x=0;char s=getchar();
	while(!isdigit(s)){if(s=='-')f=-1;s=getchar();}
	while(isdigit(s)){x=x*10+s-'0';s=getchar();}
	x*=f;
}
int n,m,head[N],tot,dfn[N],low[N],stk[N],top,idx,h[N],ttt;
struct code{int u,v;}edge[N<<3],e[N<<3];
int belong[N],col,dis[N],depth[N],f[N][21];
int q;
bool inq[N];
inline void add(int x,int y)
{
	e[++tot].u=h[x];
	e[tot].v=y;
	h[x]=tot;
}
inline void ado(int x,int y)
{
	edge[++ttt].u=head[x];
	edge[ttt].v=y;
	head[x]=ttt;
}
void tarjan(int x,int fa)
{
	dfn[x]=low[x]=++idx;
	stk[++top]=x;inq[x]=true;
	for(R int i=h[x];i;i=e[i].u)
	{
		if(e[i].v==fa)continue;
		if(!dfn[e[i].v])
		{
			tarjan(e[i].v,x);
			low[x]=min(low[x],low[e[i].v]);
		}
		else if(inq[e[i].v])
			low[x]=min(low[x],dfn[e[i].v]);
	}
	if(dfn[x]==low[x])
	{
		col++;
		int now=-1;
		while(now!=x)
		{
			now=stk[top--];
			inq[now]=false;
			belong[now]=col;
		}
	}
}
void dfs(int u,int fa)
{
	f[u][0]=fa;
	dis[u]=dis[fa]+1;
	depth[u]=depth[fa]+1;
	for(R int i=1;(1<<i)<=depth[u];i++)
		f[u][i]=f[f[u][i-1]][i-1];
	for(R int i=head[u];i;i=edge[i].u)
	{
		if(edge[i].v==fa)continue;
		dfs(edge[i].v,u);	
	}
}
inline int lca(int x,int y)
{
	int res=0;
	if(depth[x]>depth[y])swap(x,y);
	for(R int i=17;i>=0;i--)
		if(depth[x]+(1<<i)<=depth[y])
			y=f[y][i];
	if(x==y)return y;
	for(R int i=17;i>=0;i--)
	{
		if(f[x][i]==f[y][i])continue;
		x=f[x][i],y=f[y][i];		
	}
	return f[x][0];
}
int main()
{
	in(n),in(m);
	for(R int i=1,x,y;i<=m;i++)
	{
		in(x),in(y);
		add(x,y),add(y,x);
	}
	for(R int i=1;i<=n;i++)
		if(!dfn[i])tarjan(i,0);
	for(R int i=1;i<=n;i++)
		for(R int j=h[i];j;j=e[j].u)
			if(belong[i]!=belong[e[j].v])
				ado(belong[i],belong[e[j].v]);

	dfs(belong[1],0);
	in(q);
	for(R int x,y,la;q;q--)
	{
		in(x),in(y);
		x = belong[x], y = belong[y];
		la=lca(x,y);
		int ans=dis[x]+dis[y]-2*dis[la]+1;
		int size[15]={0},cnt=0;
		while(ans)
		{
			size[++cnt]=ans%2;
			ans/=2;
		}
		for(R int i=cnt;i>=1;i--)
			printf("%d",size[i]);
		putchar('\n');
	}
}
```



---

## 作者：GKxx (赞：7)

## 谁说不用vector过不去？

我就用普通的前向星存图过了，没用vector

思路基本上跟大家都差不多。先用tarjan跑出强连通分量，然后缩点。缩点就是重新建一张图，新图的结点编号对应原来的图的强连通分量编号。再具体一点就是，对于原图中的每条边(u, v)，如果u和v分属不同的强连通分量（即sccno[u] != sccno[v]），那么向新图中加一条边(sccno[u], sccno[v])。

新图必然是一棵树，问题就变为求树上两点之间有多少个点。如果树根的dep设为0，那么ans=dep[sccno[x]] + dep[sccno[y]] - 2 * dep[lca] + 1.

```cpp
// C++11
#include <cctype>
#include <cstdio>
#include <climits>
#include <algorithm>
#include <stack>

#define il inline
#define gc getchar
#define rep(i, a, b) for (int i = a; i <= b; ++i)
#define rrep(i, a, b) for (int i = a; i >= b; --i)

template <class T> il void read(T& t) {
    int f = 0, c = gc(); t = 0;
    while (!isdigit(c)) f |= c == '-', c = gc();
    while (isdigit(c)) t = t * 10 + c - 48, c = gc();
    f ? t = -t : 0;
}
template <class T, class... Args> il void read(T& t, Args&... args) {
    read(t);
    read(args...);
}

const int maxn = 5e4 + 100;
typedef int arrT[maxn << 1];
arrT v, head, next, low, pre, sccno;
int dfs_clock, scccnt;
int n, m, tot = -1;
std::stack<int> s;

void dfs1(int x, int fa) {
    pre[x] = low[x] = ++dfs_clock;
    s.push(x);
    for (int i = head[x]; i != -1; i = next[i]) {
        int y = v[i];
        if (y != fa) {
            if (!pre[y]) {
                dfs1(y, x);
                low[x] = std::min(low[x], low[y]);
            } else if (!sccno[y]) {
                low[x] = std::min(low[x], pre[y]);
            }
        }
    }
    if (low[x] == pre[x]) {
        ++scccnt;
        while (0207) {
            int y = s.top();
            s.pop();
            sccno[y] = scccnt;
            if (x == y)
                break;
        }
    }
}
il void find_scc() { rep(i, 1, n) if (!pre[i]) dfs1(i, -1); }
il void ae(int x, int y) {
    v[++tot] = y;
    next[tot] = head[x];
    head[x] = tot;
}
il void init() { rep(i, 1, n) head[i] = -1; }

arrT v2, head2, next2, dep;
int anc[maxn][50];

il void ae2(int x, int y) {
    v2[++tot] = y;
    next2[tot] = head2[x];
    head2[x] = tot;
}
il void rebuild() {
    tot = -1;
    rep(i, 1, scccnt) head2[i] = -1;
    rep(i, 1, n) for (int j = head[i]; j != -1; j = next[j]) if (sccno[i] != sccno[v[j]])
        ae2(sccno[i], sccno[v[j]]);
}
void dfs2(int x) {
    dep[x] = dep[anc[x][0]] + 1;
    rep(i, 1, 20) anc[x][i] = anc[anc[x][i - 1]][i - 1];
    for (int i = head2[x]; i != -1; i = next2[i])
        if (v2[i] != anc[x][0]) {
            anc[v2[i]][0] = x;
            dfs2(v2[i]);
        }
}
il int getLCA(int x, int y) {
    if (x == y) return x;
    if (dep[x] < dep[y]) std::swap(x, y);
    rrep(i, 20, 0) if (dep[anc[x][i]] >= dep[y]) x = anc[x][i];
    if (x == y) return x;
    rrep(i, 20, 0) if (anc[x][i] != anc[y][i]) x = anc[x][i], y = anc[y][i];
    return anc[x][0];
}

void printInBinary(int ans) {
    if (!ans) return;
    printInBinary(ans >> 1);
    printf("%d", ans & 1);
}

int main() {
    read(n, m);
    init();
    rep(i, 1, m) {
        int x, y;
        read(x, y);
        ae(x, y);
        ae(y, x);
    }
    find_scc();
    rebuild();
    dfs2(1);
    int q;
    read(q);
    rep(i, 1, q) {
        int x, y;
        read(x, y);
        int lca = getLCA(sccno[x], sccno[y]);
        int ans = dep[sccno[x]] + dep[sccno[y]] - (dep[lca] << 1) + 1;
        printInBinary(ans);
        printf("\n");
    }
    return 0;
}
```

---

## 作者：我没有开挂 (赞：6)

身为一个蒟蒻，竟然第一次没看题解AC了一道~~(伪)~~黑题。

**分析题干：**（已经了解了题意&&明白什么叫双连通分量的dalao可以跳过此部分）

先看一看题目，恩，一下就看见了题目中的**“所有的环状碳都变成了一个碳”**（划重点），联想到了啥？没错，tarjan缩点！但是再稍微看看题目就会发现事情有一点不对劲：这是无向图呀，那么整个图难道不就是一个强连通分量吗？
然而，这世间还存在一种东西叫做**双连通分量**（也许是我太蒟了，今天才知道有这东西）

关于双连通分量：
双连通分量分点双连通分量和边双连通分量两种。若一个无向图中的去掉任意一个节点（一条边）都不会改变此图的连通性，即不存在割点（桥），则称作点（边）双连通图。一个无向图中的每一个极大点（边）双连通子图称作此无向图的点（边）双连通分量。求双连通分量可用Tarjan算法。

											    以上来自万能的百度百科。

那么显然（原谅我用这么恶劣的词），这里是点双联通分量。至于做法，等下再代码里会有详解的。

扯的有点远了，让我们再看下一个关键句：**指定多组碳，求出它们之间总共有多少碳**，那么这就很明显是求图中两个点之间的点个数了（再看一看样例，就可以判断这里两点之间的点个数是包括了那两个点本身的）。

OK，那么本题题意即为：求出一个将所有点双连通分量缩点之后的图中两个点之间的点个数（包括其本身）。

**算法解析：**

刚刚在分析题干的部分已经提到了点双连通分量，那我就直接从缩点之后开始讲起了。

经过了缩点之后的图必定是一棵树，那么我们现在怎么求树上的两点之间的点个数呢？emmmm，爆搜？TLE将会等着你的。那么这题就没办法了吗？

~~不存在的，不然我写这篇题解干嘛。~~突然想到了前几天刚刚复习过了的[P1967货车运输](https://www.luogu.org/problemnew/show/P1967)。这题是用LCA求两点之间的最大的 路径中权值的最小值，与这道题有一点点沾边。那么这道题可不可以用LCA搞事呢？确实是可以的。其实很简单，直接先求出两点直接的lca，然后点数就是deep[x]-deep[lca]+deep[y]-deep[lca]+1了，对吧。

好的，这样的话，这题的思路就出来了：首先将所有点双连通分量进行缩点，再用LCA求出两点之间的点个数就行了，~~好像真的很简单？~~

**代码展示：**

```cpp
#include <bits/stdc++.h>

#define MAXN 500500
#define re register

using namespace std;

struct edge
{
    int to,next;
}e[MAXN<<1];

int first[MAXN],x[MAXN],y[MAXN],book[MAXN];//x,y记录边（用于缩点重建边），book用于LCA初始化 
int f[MAXN][21],deep[MAXN];
int low[MAXN],dfn[MAXN],co[MAXN]; 
int conum,n,m,tot,cnt;

stack <int> p;

inline int read()//读优 
{
    int res=0;re bool f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-') f=0;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        res=(res<<3)+(res<<1)+(ch&15);
        ch=getchar();
    }
    return f?res:-res;
}

inline void addedge(int u,int v)
{
    e[++tot].to=v;
    e[tot].next=first[u];
    first[u]=tot;
}

inline void tarjan(int u,int fa)  //tarjan 
{
    low[u]=dfn[u]=++cnt;
    p.push(u);
    for(re int i=first[u];i;i=e[i].next)
    {
        int v=e[i].to;
        if(v==fa) continue; //与普通tarjan唯一的区别，如果能不经过父亲节点使得low[u]==dfn[u]，那么就是点双连通分量 
        //其他部分就不用解释了吧，毕竟敢做黑题的人一般都是dalao(我当然不是) 
        if(!dfn[v])
        {
            tarjan(v,u);
            low[u]=min(low[u],low[v]);
        }
        else if(!co[v]) low[u]=min(low[u],dfn[v]);
    }
    if(low[u]==dfn[u])
    {
        ++conum;
        while(p.top()^u)//p.top!=u 
        {
            co[p.top()]=conum;
            p.pop();
        }
        co[p.top()]=conum;
        p.pop();
    }
}

inline void rebuild()//缩点加重建边 
{
    tot=0;
    memset(first,0,sizeof first);
    for(int i=1;i^m;++i)//i!=m
        if(co[x[i]]^co[y[i]]) addedge(co[x[i]],co[y[i]]),addedge(co[y[i]],co[x[i]]);
    //应该很好理解吧 
}

inline void init(int u,int fa)//经典的LCA的初始化 
{
    if(book[u]) return;
    book[u]=1;
    deep[u]=deep[fa]+1;
    for(re int i=1;i^21;++i)//i<=20 
        f[u][i]=f[f[u][i-1]][i-1];
    for(re int i=first[u];i;i=e[i].next)
    {
        int v=e[i].to;
        if(v==fa) continue;
        f[v][0]=u;
        init(v,u);
    }
}

inline int LCA(int a,int b)//经典的LCA 
{
    if(deep[a]<deep[b]) swap(a,b);
    for(re int i=20;~i;--i)//i>=0
        if(deep[f[a][i]]>=deep[b])
            a=f[a][i];
    if(a==b) return a;
    for(re int i=20;~i;--i)//i>=0
        if(f[a][i]^f[b][i])
            a=f[a][i],b=f[b][i];
    return f[a][0];
}

inline void print(int x) //二进制输出 
{
    if(!x) return;
    print(x>>1);
    printf("%d",x&1);
}

int main()
{
    int t;
    n=read(),m=read();
    ++n;++m;//方便下面的i^m，i^n等操作 （tips：a^b <==> a!=b） 
    for(re int i=1;i^m;++i)
    {
        x[i]=read(),y[i]=read();
        addedge(x[i],y[i]);
        addedge(y[i],x[i]);//记得是无向图 
    }
    for(re int i=1;i^n;++i) if(!dfn[i]) tarjan(i,i); //tarjan找点双连通分量 
    rebuild();//缩点重新建边 
    ++conum;//同样是方便下面的i^conum操作 
    
    for(re int i=1;i^conum;++i) if(!book[i]) init(i,i);//实际上可以不用这样，因为确定了是连通图 
    //init(1,1); //直接这样就行了
	 
    t=read();
    for(re int i=0;i^t;++i)
    {
        int x=read(),y=read();
        int lca=LCA(co[x],co[y]);//记得是co[x]与co[y]，而不是x,y，不然会出事的 
        print(deep[co[x]]-deep[lca]+deep[co[y]]-deep[lca]+1);//二进制输出
        printf("\n");
    }
    return 0;
}
```

---

## 作者：Infiltrator (赞：3)

## 这题不难qwq  
~~但是卡了我好长时间~~  
# 题意  
给出一张无向图，每次删去一个e-DCC(边双连通分量），重新建图，然后求两点所在e-DCC之间距离。  
# 思路  
这道题的题意非常的显然，所以我们只要直接按照题意做一遍就好了。  

最后求两点之间距离的时候，求一个LCA即可，答案就是d[a]+d[b]-2* d[lca（a,b）]+1  
所以这道题就做完了(雾  
# 小bug  
我们交上了代码，心满意足的期待着又一道黑题的ac，但是突然结果出现，只有73pts。怎么回事啊？？？  

## 这就是本题解最重要的部分  

边双联通分量有有两种方法，其中一种是求出所有割边，然后依次删去。这样剩下的图就被分成了很多单独的部分，每一个部分就是一个e-DCC  

另一种方法则和有向图的缩点相似，我们用一个栈记录搜索树上的点，当low[x]=dfn[x]的时候将stack里的点依次退出，一直退到x，我们便求出了一个e-DCC  

注意：最下方题面里说两个点不删去所以当我们tarjan的时候遇到x的父亲就直接continue,按这个思路法二可以过。  

但是法一即使加上这个判断也过不了，所以还是不写法一比较好(雾
# 73ptsCODE
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>
#include <cmath>
using namespace std;
#define N 100500
#define M 500500
int n,m,head[N],num=1,dfn[N],low[N],cnt,bridge[M],he[N],sy[N],numm,t,f[N][50],d[N];
queue<int> q;
struct node
{
    int next,to;
}edge[M*2],tu[M*2];
void addedge(int u,int v)
{
    edge[++num]=(node){head[u],v};
    head[u]=num;
}
void newaddedge(int u,int v)
{
    tu[++numm]=(node){he[u],v};
    he[u]=numm;
}
void tarjan(int x,int in_edge)
{
    low[x]=dfn[x]=++cnt;
    for(int i=head[x];i;i=edge[i].next)
    {
        int v=edge[i].to;
        if(!dfn[v])
        {
            tarjan(v,i);
            low[x]=min(low[x],low[v]);
            if(dfn[x]<low[v])bridge[i]=bridge[i^1]=1;
        }
        else if(i!=(in_edge^1))low[x]=min(low[x],dfn[v]);
    }
}
void jb(int x,int syy)
{
    for(int i=head[x];i;i=edge[i].next)
    {
        int v=edge[i].to;
        if(bridge[i]||sy[v])continue;
        sy[v]=syy;
        jb(v,syy);
    }
}
void bfs()
{
    q.push(1);
    d[1]=1;
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        for(int i=he[u];i;i=tu[i].next)
        {
            int v=tu[i].to;
            if(d[v])continue;
            d[v]=d[u]+1;
            f[v][0]=u;
            for(int k=1;k<=t;k++)f[v][k]=f[f[v][k-1]][k-1];
            q.push(v);
        }
    }
}
int lca(int a,int b)
{
    if(d[a]<d[b])swap(a,b);
    for(int i=t;i>=0;i--)if(d[f[a][i]]>=d[b])a=f[a][i];
    if(a==b)return a;
    for(int i=t;i>=0;i--)if(f[a][i]!=f[b][i])a=f[a][i],b=f[b][i];
    return f[a][0];
}
void xs(int shu)
{
    int answer[500000],kkk=0;
    while(shu)
    {
        answer[++kkk]=shu%2;
        shu/=2;
    }
    for(int i=kkk;i>=1;i--)printf("%d",answer[i]);
    printf("\n");
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        int u,v;
        scanf("%d%d",&u,&v);
        addedge(u,v);addedge(v,u);
    }
    for(int i=1;i<=n;i++)if(!dfn[i])tarjan(i,0);
    cnt=0;
    for(int i=1;i<=n;i++)if(!sy[i])sy[i]=++cnt,jb(i,cnt);
    for(int i=2;i<=num;i++)if(sy[edge[i].to]!=sy[edge[i^1].to])newaddedge(sy[edge[i].to],sy[edge[i^1].to]);
    t=(int)(log(cnt)/log(2))+1;
    bfs();
    int tot;
    scanf("%d",&tot);
    for(int i=1;i<=tot;i++)
    {
        int a,b;
        scanf("%d%d",&a,&b);
        a=sy[a];b=sy[b];
        int lcab=lca(a,b);
        xs(d[a]+d[b]-2*d[lcab]+1);
    }
    return 0;
}
```     


------------


# 100ptsCODE
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>
#include <cmath>
using namespace std;
#define N 100500
#define M 500500
int stack[N],top,ttt,n,m,head[N],num=1,dfn[N],low[N],cnt,bridge[M],he[N],sy[N],numm,t,f[100050][50],d[N];
queue<int> q;
struct node
{
    int next,to;
}edge[M*2],tu[M*2];
void addedge(int u,int v)
{
    edge[++num]=(node){head[u],v};
    head[u]=num;
}
void newaddedge(int u,int v)
{
    tu[++numm]=(node){he[u],v};
    he[u]=numm;
}
void tarjan(int x,int fa)
{
    low[x]=dfn[x]=++cnt;
    stack[++top]=x;
    for(int i=head[x];i;i=edge[i].next)
    {
        int v=edge[i].to;
        if(v==fa)continue;
        if(!dfn[v])
        {
            tarjan(v,x);
            low[x]=min(low[x],low[v]);
        }
        else low[x]=min(low[x],dfn[v]);
    }
    if(low[x]==dfn[x])
    {
        sy[x]=++ttt;
        while(stack[top]!=x)sy[stack[top]]=ttt,top--;
        top--;
    }
}
void jb(int x)
{
    sy[x]=cnt;
    for(int i=head[x];i;i=edge[i].next)
    {
        int v=edge[i].to;
        if(bridge[i]||sy[v])continue;
        jb(v);
    }
}
void bfs()
{
    q.push(1);
    d[1]=1;
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        for(int i=he[u];i;i=tu[i].next)
        {
            int v=tu[i].to;
            if(d[v])continue;
            d[v]=d[u]+1;
            f[v][0]=u;
            for(int k=1;k<=t;k++)f[v][k]=f[f[v][k-1]][k-1];
            q.push(v);
        }
    }
}
int lca(int a,int b)
{
    if(d[a]<d[b])swap(a,b);
    for(int i=t;i>=0;i--)if(d[f[a][i]]>=d[b])a=f[a][i];
    if(a==b)return a;
    for(int i=t;i>=0;i--)if(f[a][i]!=f[b][i])a=f[a][i],b=f[b][i];
    return f[a][0];
}
void xs(int shu)
{
    int answer[500000],kkk=0;
    while(shu)
    {
        answer[++kkk]=shu%2;
        shu/=2;
    }
    for(int i=kkk;i>=1;i--)printf("%d",answer[i]);
    printf("\n");
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        int u,v;
        scanf("%d%d",&u,&v);
        addedge(u,v);addedge(v,u);
    }
    for(int i=1;i<=n;i++)if(!dfn[i])tarjan(i,0);
    cnt=0;
   // for(int i=1;i<=n;i++)if(!sy[i]){++cnt;jb(i);}
    for(int i=2;i<=num;i++)if(sy[edge[i].to]!=sy[edge[i^1].to])newaddedge(sy[edge[i].to],sy[edge[i^1].to]);
    t=32;
    bfs();
    int tot;
    scanf("%d",&tot);
    for(int i=1;i<=tot;i++)
    {
        int a,b;
        scanf("%d%d",&a,&b);
        a=sy[a];b=sy[b];
        int lcab=lca(a,b);
        xs(d[a]+d[b]-2*d[lcab]+1);
    }
    return 0;
}
```


---

## 作者：Froggy (赞：3)

## 没人离线用Tarjan求lca嘛??
#### 可以省很多时间
#### ----这样存边就可以用链式前向星喽~
###### ~~谁都知道缩点+LCA~~
---
##### 其实,我没用双强连通分量.过边时给另外一个边顺便打个标记就行了~,防止重复走
### 这样搞:
你过了edge[i],
那就打edge[(i-1)^1+1]的标记.
##### 神马意思呢?
说白了就是过单数边打双数边的标记,过双数边打单数边的标记;
(因为存边时是一对一对存的)

---
其他内容看看楼下大佬的吧,这里不再多说

---
```cpp
#include<iostream>
#include<map>
#include<cstdlib>
#include<cstring>
#include<vector>
#include<stack>
#include<cstdio>
using namespace std;
#define N 10010
inline int read(){//快读,因为数据太多啦~
	int x=0;
	char c=getchar();
	while(c<'0'||c>'9')c=getchar();
	while(c>='0'&&c<='9'){
	    x=(x<<3)+(x<<1)+c-'0';c=getchar();
	}
	return x;
}
int n,m,cnt=0,num=0,tot=0,q,ans[N<<8],f[N],dep[N];
int head[N],dfn[N],low[N],vis[N],color[N],x[N<<4],y[N<<4];
//STL大法真好用
stack<int> st;
vector<pair<int,int> > vec[N<<3];
map<pair<int,int>,int> mp;
struct Edge{
	int to,nxt,use;//use就是标记
}edge[N<<4];
void add(int a,int b){
	cnt++;
	edge[cnt].use=0;
	edge[cnt].to=b;
	edge[cnt].nxt=head[a];
	head[a]=cnt;
}
void Tarjan(int u){
	st.push(u);
	dfn[u]=low[u]=++num;
	vis[u]=1;
	for(int i=head[u];i;i=edge[i].nxt){
		if(edge[i].use)continue;
		int v=edge[i].to;
		edge[((i-1)^1)+1].use=1;
		if(!dfn[v]){
			Tarjan(v);
			low[u]=min(low[u],low[v]);
		}
		else if(vis[v]){
			low[u]=min(low[u],dfn[v]);
		}
	}
	if(dfn[u]==low[u]){
		int t=0;
		tot++;
		while(t!=u){
			vis[st.top()]=0;
			color[st.top()]=tot;
			t=st.top();
			st.pop();
		}
	}
}
//离线求Tarjan要用到并查集
int getf(int x){
	if(f[x]==x)return x;
	return f[x]=getf(f[x]);
}
void merge(int x,int y){
	int r1,r2;
	r1=getf(x),r2=getf(y);
	if(r1!=r2){
		f[r2]=r1;
	}
}
void Deal(int u,int fa){
	dep[u]=dep[fa]+1;
	for(int i=head[u];i;i=edge[i].nxt){
		if(edge[i].use)continue;
		int v=edge[i].to;
		edge[((i-1)^1)+1].use=1;
		if(v==fa)continue;
		Deal(v,u);
	}
}
void Tarjan2(int u,int fa){//HERE,重点,离线LCA
	for(int i=head[u];i;i=edge[i].nxt){
		if(edge[i].use)continue;
		int v=edge[i].to;
		edge[((i-1)^1)+1].use=1;
		if(v==fa)continue;
		Tarjan2(v,u);
		merge(u,v);
	}
	vis[u]=1;
	for(int i=0;i<vec[u].size();i++){
		int v=vec[u][i].first;
		if(vis[v]){
			ans[vec[u][i].second]=dep[u]+dep[v]-2*dep[getf(v)]+1;
		}
	}
}
void print(int x){
	if(x==0)return;
	print(x>>1);
	cout<<(x&1);
}
int main(){
	n=read();m=read();
	for(int i=1;i<=m;i++){
		int u,v;
		u=read(),v=read();
		if(mp[make_pair(u,v)])continue;//用map去重,否则会WA几个点
		mp[make_pair(u,v)]=mp[make_pair(v,u)]=1;
		x[i]=u,y[i]=v;
		add(u,v);add(v,u);
	}
	for(int i=1;i<=n;i++){
		if(!dfn[i])Tarjan(i);
	}
	cnt=0;
	memset(head,0,sizeof(head));
	memset(edge,0,sizeof(edge));
	memset(vis,0,sizeof(vis));//疯狂memset,省点空间
	for(int i=1;i<=m;i++){
		if(color[x[i]]!=color[y[i]]){
			add(color[x[i]],color[y[i]]);
			add(color[y[i]],color[x[i]]);
		}
	}
	memset(x,0,sizeof(x));
	memset(y,0,sizeof(y));
	for(int i=1;i<=n;i++)f[i]=i;
	q=read();
	for(int i=1;i<=q;i++){
		x[i]=read(),y[i]=read();
		vec[color[x[i]]].push_back(make_pair(color[y[i]],i));
		vec[color[y[i]]].push_back(make_pair(color[x[i]],i));
	}
	Deal(1,0);
	for(int i=1;i<=2*m;i++)edge[i].use=0;
	vis[1]=1;
	Tarjan2(1,0);
	for(int i=1;i<=q;i++){
		print(ans[i]);
		cout<<endl;
	}
	return 0;
}


```
转二进制时我试了一下itoa()函数~~不知道的话找度娘~~,加了<ctdlib>,可惜CE,只能手动转.
  
# ~~本青蛙第二次AC黑题,呱~~~~
#### 有问题的问我哦~私信也可以
~~本青蛙只是个渣渣,欢迎大佬菜我~~

---

## 作者：MisakaQAQ (赞：2)

####  **看大家都写的tarjan双连通+倍增LCA，我就发一篇双Tarjan（Tarjan双连通+Tarjan_LCA）的题解吧。**

首先我们看看题，题主要有3个问题有待我们去解决

1.将碳环缩成一个点

2.求两点之中点的个数

3.输出2进制表示

问题一我们可以通过Tarjan割边求出图中DCC然后缩点重建边来解决，

核心代码如下：
------------

```
#include<bits/stdc++.h>
using namespace std;
long long n,m,q;
bool bridge[1000010];
long long num,dfn[1000010],low[1000010];
long long c[1000010],dcc;
//ci表示点所在双连通分量的编号
struct node{
	long long to,next;
}edge[1000010],edge_c[1000010];
//edge为缩点前的图的储存，edge_c为缩点后的图。

long long first[1000010],first_c[1000010],cnt=1,cnt_c;
void add(long long u,long long v){
	edge[++cnt].to = v;
	edge[cnt].next = first[u];
	first[u] = cnt;
}
void add_c(long long u,long long v){
	edge_c[++cnt_c].to = v;
	edge_c[cnt_c].next = first_c[u];
	first_c[u] = cnt_c;
}

void TJ_C(long long x,long long in){
	dfn[x] = low[x] = ++num;
	for(long long i = first[x];i;i = edge[i].next){
		long long y = edge[i].to ;
		if(!dfn[y]){
			TJ_C(y,i);
			low[x] = min(low[x],low[y]);
			if(low[y]>dfn[x]){
				bridge[i] = bridge[i^1]=1;
			}
		}
		else if(i!=(in^1))low[x]=min(low[x],dfn[y]);
	}
}
//tarjan的割边判定法则

void dfs(long long x){
	c[x] = dcc;
	for(long long i =first[x];i;i=edge[i].next){
		long long y = edge[i].to;
		if(c[y]||bridge[i])continue;
		dfs(y);
	}
}
//缩点操作
int main(){
	scanf("%lld%lld",&n,&m);
	for(long long i = 1; i <= m; i++){
		long long x,y;
		scanf("%lld%lld",&x,&y);
		add(x,y);add(y,x);
	}//邻接表建边
    
	scanf("%lld",&q);
	for(long long i = 1; i <= n; i++)if(!dfn[i])TJ_C(i,0);
	for(long long i = 1; i <= n; i++)if(!c[i]){dcc++;dfs(i);}
    
	for(long long i = 2; i <=cnt;i++){
			long long y = edge[i].to,x = edge[i^1].to;
			if(c[x] == c[y])continue;
			add_c(c[x],c[y]);
		}
    //使用异或操作，一次性处理2个点
    
}
```
然后问题一就可以解决了，至于问题二，我们可以想，一个无向无环图不就是一颗树吗？至于2点中点的个数就是两点距离加一，也就是以下公式：

		ans = d[x] + d[y] - 2*d[LCA(x,y)] + 1
而这就要用到LCA了，因为是多组数据,所以我们就使用Tarjan_LCA离线算法，时间复杂度较低(O(n+m))

下面是核心代码部分：
------------
```
#include<bits/stdc++.h>
using namespace std;
long long n,m,q;
long long ans[1000010];
long long fa[1000010],d[1000010],v[1000010];
vector<long long>query[1000010],query_id[1000010];

struct node{
	long long to,next;
}edge[1000010];

long long first[1000010],cnt=1;
void add(long long u,long long v){
	edge[++cnt].to = v;
	edge[cnt].next = first[u];
	first[u] = cnt;
}


void add_query(long long x,long long y,long long id){
	query[x].push_back(y),query_id[x].push_back(id); 
	query[y].push_back(x),query_id[y].push_back(id);  
}

long long get(long long x){
	return fa[x]==x?x:fa[x]=get(fa[x]);
}

void TJ_LCA(long long x){
	v[x] = 1;
	for(long long i = first[x];i;i = edge[i].next){
		long long y = edge[i].to;
		if(v[y])continue;
		d[y] = d[x]+1;
		TJ_LCA(y);
		fa[y] = x;
	}
	for(long long i = 0;i < query[x].size(); i++){
		long long y = query[x][i],id = query_id[x][i];
		if(v[y] == 2){
			long long LCA = get(y);
			ans[id] = min(ans[id],d[x]+d[y]-2*d[LCA]+1);
            //求两点中点的个数
		}
	}
	v[x] = 2;
} 
//Tarjan_LCA
int main(){
	scanf("%lld%lld",&n,&m);
	for(long long i = 1; i <= m; i++){
		long long x,y;
		scanf("%lld%lld",&x,&y);
		add(x,y);add(y,x);
	}
    //建边
	memset(ans,0x3f,sizeof ans); 
	for(long long i = 1; i <= q; i++){
		long long x,y;
		scanf("%lld%lld",&x,&y);
		if(x == y)ans[i] = 1;
		else{
			add_query(x,y,i);
		}
	}
	// 将答案所对应编号和询问的2点联系起来
	for(long long i = 1; i <= n; i++)fa[i]=i;
    //并查集初始化
	TJ_LCA(1);

	for(long long i = 1; i <= q; i++){ 
		printf(“%d”,ans[i]);
		printf("\n");
	}
}
```
在解决完问题2后，大问题就已经差不多解决完了，问题3的话不多说，直接上代码

```
void output(long long x){
	if(x){
		output(x>>1);
		printf(x&1?"1":"0");
	}
}
```
然后如果你照着这个打完2个版子，你会发现只有73分（不要问我怎么知道的）
那是什么原因呢？

因为重边问题。

首先，题目里说了，2碳不成环，而数据里有重边，Tarjan割边会把有重边的2点缩掉，这就导致你的答案会出错，于是我又用了领接矩阵来删除重边。

下面是AC代码
------------
```
#include<bits/stdc++.h>
//万能头文件，不推荐与下面using namespace std一起使用，仅为减少码长
using namespace std;

long long n,m,q,ans[1000010];

bool bridge[1000010];
long long num,dfn[1000010],low[1000010];
//Tarjan割边所用数组

long long c[1000010],dcc;
//缩点所用数组

long long fa[1000010],d[1000010],v[1000010];
vector<long long>query[1000010],query_id[1000010];
//Tarjan_LCA所用数组

struct node{
	long long to,next;
}edge[1000010],edge_c[1000010];
map<int ,bool>mp[1000010];//用map写领接矩阵，防止爆空间
long long first[1000010],first_c[1000010],cnt=1,cnt_c;
//存图所用数组

void add(long long u,long long v){
	edge[++cnt].to = v;
	edge[cnt].next = first[u];
	first[u] = cnt;
}
//建初始图
void add_c(long long u,long long v){
	edge_c[++cnt_c].to = v;
	edge_c[cnt_c].next = first_c[u];
	first_c[u] = cnt_c;
}//建缩点后图

void add_query(long long x,long long y,long long id){
	query[x].push_back(y),query_id[x].push_back(id); 
	query[y].push_back(x),query_id[y].push_back(id);  
}
//存储答案与问题

void TJ_C(long long x,long long in){
	dfn[x] = low[x] = ++num;
	for(long long i = first[x];i;i = edge[i].next){
		long long y = edge[i].to ;
		if(!dfn[y]){
			TJ_C(y,i);
			low[x] = min(low[x],low[y]);
			if(low[y]>dfn[x]){
				bridge[i] = bridge[i^1]=1;
			}
		}
		else if(i!=(in^1))low[x]=min(low[x],dfn[y]);
	}
}
//Tarjan求割边
void dfs(long long x){
	c[x] = dcc;
	for(long long i =first[x];i;i=edge[i].next){
		long long y = edge[i].to;
		if(c[y]||bridge[i])continue;
		dfs(y);
	}
}
// 缩点
long long get(long long x){return fa[x]==x?x:fa[x]=get(fa[x]);}
//并查集
void TJ_LCA(long long x){
	v[x] = 1;
	for(long long i = first_c[x];i;i = edge_c[i].next){
		long long y = edge_c[i].to;
		if(v[y])continue;
		d[y] = d[x]+1;
		TJ_LCA(y);
		fa[y] = x;
	}
	for(long long i = 0;i < query[x].size(); i++){
		long long y = query[x][i],id = query_id[x][i];
		if(v[y] == 2){
			long long LCA = get(y);
			ans[id] = min(ans[id],d[x]+d[y]-2*d[LCA]+1);
		}
	}
	v[x] = 2;
} 
//LCA

void output(long long x){
	if(x){
		output(x>>1);
		printf(x&1?"1":"0");
	}
}
//输出
int main(){
	scanf("%lld%lld",&n,&m);
    
	for(long long i = 1; i <= m; i++){
		long long x,y;
		scanf("%lld%lld",&x,&y);
		if(mp[x][y])continue;
		mp[x][y] = 1;
		mp[y][x] = 1;
        // 统计边，防重边
		add(x,y);add(y,x);
	}
    
	
	for(long long i = 1; i <= n; i++)if(!dfn[i])TJ_C(i,0);
	for(long long i = 1; i <= n; i++)if(!c[i]){dcc++;dfs(i);}
	for(long long i = 2; i <=cnt;i++){
		long long y = edge[i].to,x = edge[i^1].to;
		if(c[x] == c[y])continue;
		add_c(c[x],c[y]);
	}
    //问题一
    
    scanf("%lld",&q);
	memset(ans,0x3f,sizeof ans); 
	for(long long i = 1; i <= q; i++){
		long long x,y;
		scanf("%lld%lld",&x,&y);
		if(c[x] == c[y])ans[i] = 1;
		else{
			add_query(c[x],c[y],i);
		}
	}
	for(long long i = 1; i <= n; i++)fa[i]=i;
	TJ_LCA(1);
	//问题二
    
	for(long long i = 1; i <= q; i++){ 
		output(ans[i]);
		printf("\n");
	}
    //问题三
}
```


		
        


---

## 作者：斯德哥尔摩 (赞：2)

额，大部分人都用的$vector$过了第4个点，但是我好像就是前向星过的。。。

那就给大家一个参考的范例吧，顺便加上一个黑科技——$namespace$

这是一个好东西，比如你在省选场上，想打暴力，但是能打不同的部分分的暴力，就可以用$namespace$把各个暴力括起来，防止变量名的重复再去调试而耽误了时间。

还有一个用处：当使用了不同的算法，但是又容易弄混淆时（比如$LCA$与$Tarjan$强连通都有$DFS$），就可以分别把这两个算法括起来，防止变量名的重复。

然后是算法。

我们看题，要求点双连通分量缩点后求两点间距离。

我们发现缩完点后的图是棵树，那么两点间距离就可以用$LCA$解决了：

$dis=deep[x]+deep[y]-deep[LCA(x,y)]* 2+1$

然后的问题就是点双连通分量怎么求。

跟强连通分量差不多，只要修改修改就好了。

剩下的，看代码吧。。。

附代码：
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#define MAXN 100010
using namespace std;
int n,m,q,c=1;
int head[MAXN],deep[MAXN],son[MAXN],size[MAXN],fa[MAXN],top[MAXN],colour[MAXN];
struct Tree{
	int next,to;
}a[MAXN<<1];
inline int read(){
	int date=0,w=1;char c=0;
	while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
	while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}
	return date*w;
}
inline void add_tree(int x,int y){
	a[c].to=y;a[c].next=head[x];head[x]=c++;
}
namespace Tarjan{//Tarjan点双连通分量
	int c=1,top=1,d=1,s=0;
	int head[MAXN],cstack[MAXN],deep[MAXN],low[MAXN];
	struct node{
	    int next,to;
	}a[MAXN];
	inline void add(int x,int y){
		a[c].to=y;a[c].next=head[x];head[x]=c++;
		a[c].to=x;a[c].next=head[y];head[y]=c++;
	}
	void work(int x,int f){
		deep[x]=low[x]=d++;
		cstack[top++]=x;
		for(int i=head[x];i;i=a[i].next){
			int v=a[i].to;
			if(v==f)continue;
			if(!deep[v]){
				work(v,x);
				low[x]=min(low[x],low[v]);
			}
			else if(!colour[v])
			low[x]=min(low[x],deep[v]);
		}
		if(low[x]==deep[x]){
			s++;
			do{
				colour[cstack[top-1]]=s;
			}while(cstack[--top]!=x);
		}
	}
	void init(){
		int x,y;
		n=read();m=read();
		for(int i=1;i<=m;i++){
			x=read();y=read();
			add(x,y);
		}
		for(int i=1;i<=n;i++)if(!deep[i])work(i,0);
	    for(int i=1;i<=n;i++)
	    for(int j=head[i];j;j=a[j].next){
		    int v=a[j].to;
		    if(colour[i]!=colour[v])add_tree(colour[i],colour[v]);
	    }
	}
}
void dfs1(int rt){//LCA我用的是树链剖分
	son[rt]=0;size[rt]=1;
	for(int i=head[rt];i;i=a[i].next){
		int will=a[i].to;
		if(!deep[will]){
			deep[will]=deep[rt]+1;
			fa[will]=rt;
			dfs1(will);
			size[rt]+=size[will];
			if(size[will]>size[son[rt]])son[rt]=will;
		}
	}
}
void dfs2(int rt,int f){
	top[rt]=f;
	if(son[rt])dfs2(son[rt],f);
	for(int i=head[rt];i;i=a[i].next){
		int will=a[i].to;
		if(will!=fa[rt]&&will!=son[rt])
		dfs2(will,will);
	}
}
int LCA(int x,int y){
	while(top[x]!=top[y]){
		if(deep[top[x]]<deep[top[y]])swap(x,y);
		x=fa[top[x]];
	}
	if(deep[x]>deep[y])swap(x,y);
	return x;
}
inline void write(int x){//输出二进制
    if(!x)return;
    write(x>>1);
    printf("%d",x&1);
}
void work(){
	int x,y;
	q=read();
	while(q--){
		x=colour[read()];y=colour[read()];//已经缩完了点，所以是缩完点后的编号
		int lca=LCA(x,y);
		write(deep[x]+deep[y]-deep[lca]*2+1);
		printf("\n");
	}
}
void init(){
	deep[1]=1;
	dfs1(1);
	dfs2(1,1);
}
int main(){//主函数So easy!
	Tarjan::init();
	init();
	work();
	return 0;
}

```

---

## 作者：Uniecho1 (赞：2)

# 咳咳，人生第一道的黑题

很显然是一个缩点+并查集+树上倍增LCA+十转二

所以......所以似乎真没啥好说的？

记得判个重边不然只有72分（tarjan会把有重边的两个点缩成一个），然后求两点距离之后再+1才是碳的数量

好了真的没了，就这样吧

```cpp
#include<bits/stdc++.h>
using namespace std;

int head[100005],size,N,M,dfn[10005],low[10005],indx;
int col[10005],cnt,u[50005],v[50005],f[10005],lg2[10005]={-1};
int fa[10005][20],dep[10005];
bool vis[100005];

struct node{
	int nxt,to;
}edge[100005];

void adde(int from,int to){
	edge[size].nxt=head[from];
	edge[size].to=to;
	head[from]=size++;
}

std::stack<int>s;

void tarjan(int cur,int pa){
	low[cur]=dfn[cur]=++indx;s.push(cur);
	for(int i=head[cur];i!=-1;i=edge[i].nxt){
		if(vis[i])continue;
		int v=edge[i].to;
		if(v==pa)continue;
		if(!dfn[v]){
			vis[i]=vis[i^1]=1;
			tarjan(v,cur);
			vis[i]=vis[i^1]=0;
			low[cur]=min(low[cur],low[v]);
		}
		else low[cur]=min(low[cur],dfn[v]);
	}
	if(low[cur]==dfn[cur]){
		int top;cnt++;
		do{
			top=s.top();s.pop();
			col[top]=cnt;
		}while(top!=cur);
	}
}

int find(int x){
	if(f[x]!=x)
	f[x]=find(f[x]);
	return f[x];
}

void prepare(int cur,int pa){
	dep[cur]=dep[pa]+1;fa[cur][0]=pa;
	for(int k=1;k<=lg2[dep[cur]];k++)fa[cur][k]=fa[fa[cur][k-1]][k-1];
	for(int i=head[cur];i!=-1;i=edge[i].nxt){
		int v=edge[i].to;if(v==pa)continue;
		prepare(v,cur);
	}
}

int LCA(int u,int v){
	if(dep[u]<dep[v])swap(u,v);
	while(dep[u]>dep[v])u=fa[u][lg2[dep[u]-dep[v]]];
	if(u==v)return u;
	for(int k=lg2[dep[u]];k>=0;k--){
		if(fa[u][k]==fa[v][k])continue;
		u=fa[u][k];v=fa[v][k];
	}
	return fa[u][0];
}

int print(int x){
	std::stack<int>s;
	while(x){
		s.push(x&1);
		x>>=1;
	}
	while(!s.empty()){
		printf("%d",s.top());
		s.pop();
	}
}

int main(){
	//freopen("in.txt","r",stdin);
	memset(head,-1,sizeof(head));
	scanf("%d%d",&N,&M);
	for(int i=1;i<=M;i++){
		scanf("%d%d",&u[i],&v[i]);
		adde(u[i],v[i]);adde(v[i],u[i]);
	}
	for(int i=1;i<=N;i++)if(!dfn[i])tarjan(i,0);
	memset(edge,0,sizeof(edge));
	memset(head,-1,sizeof(head));
	size=0;for(int i=1;i<=cnt;i++){
		lg2[i]=lg2[i/2]+1;f[i]=i;
	}
	for(int i=1;i<=M;i++)
	if(col[u[i]]!=col[v[i]]&&find(col[u[i]])!=find(col[v[i]]))
	adde(col[u[i]],col[v[i]]),adde(col[v[i]],col[u[i]]),f[find(col[u[i]])]=find(col[v[i]]);
	prepare(1,0);int tot;
	scanf("%d",&tot);
	while(tot--){
		int a,b;
		scanf("%d%d",&a,&b);
		a=col[a],b=col[b];
		print(dep[a]+dep[b]-2*dep[LCA(a,b)]+1);
		printf("\n");
	}
	return 0;
}
```


---

## 作者：钱逸凡 (赞：1)

又一道~~水~~黑题

# 思路：

## 显然的缩点+树剖/倍增求lca

由于是无向图，缩点时写法略有变化，即一个点和他的父亲不能构成强连通分量

缩点就这么写：~~（码风略丑）~~
```
void dfs(int u,int fa){
	vis[u]=1;
	dfn[u]=low[u]=++ti;
	st[++sttop]=u;
	inst[u]=1;
	for(int i=oldhead[u];i;i=nod[i].next){
		int d=nod[i].v;
		if(d==fa)continue;
		if(!vis[d]){
			dfs(d,u);
			low[u]=min(low[u],low[d]);
		}
		else if(inst[d])low[u]=min(low[d],low[u]);
	}
	if(dfn[u]==low[u]){
		int now;
		taj++;
		do{
			now=st[sttop--];
			inst[now]=0;
			Belong[now]=taj;
		}while(now!=u);
	}
}
```

还有这奇怪的输出格式：
```
inline int out(int n){//输出n的二进制表示
	int o=log2(n);
	for(;o>=0;o--){
		if((1<<o)<=n){
			n-=(1<<o);
			printf("1");
		}
		else printf("0");
	}
	printf("\n");
}
```


------------

完整代码：
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
inline int Read(){
	int x=0;
	char c=getchar();
	while(c>'9'||c<'0')c=getchar();
	while(c>='0'&&c<='9')x=x*10+c-'0',c=getchar();
	return x;
}
int toop,cnt;
int oldhead[11010];
int head[10101];
struct Node{
	int v;
	int next;
}nod[101010],node[101010];
inline void ad(int u,int v){
	nod[++toop].v=v;
	nod[toop].next=oldhead[u];
	oldhead[u]=toop;
}//旧图 
inline void addedge(int u,int v){
	node[++cnt].v=v;
	node[cnt].next=head[u];
	head[u]=cnt;
}//新图 
inline void add(int u,int v){
	ad(u,v);
	ad(v,u);
}//旧图
inline void newadd(int u,int v){
	addedge(u,v);
	addedge(v,u);
}//新图 
int n,m;
int Belong[11010];
int vis[11010];
bool inst[10505];
int st[10101];
int sttop;
int taj;
int dfn[10101],low[10101],ti;
void dfs(int u,int fa){
	vis[u]=1;
	dfn[u]=low[u]=++ti;
	st[++sttop]=u;
	inst[u]=1;
	for(int i=oldhead[u];i;i=nod[i].next){
		int d=nod[i].v;
		if(d==fa)continue;
		if(!vis[d]){
			dfs(d,u);
			low[u]=min(low[u],low[d]);
		}
		else if(inst[d])low[u]=min(low[d],low[u]);
	}
	if(dfn[u]==low[u]){
		int now;
		taj++;
		do{
			now=st[sttop--];
			inst[now]=0;
			Belong[now]=taj;
		}while(now!=u);
	}
}
void sd(){
	int i,j;
	for(i=1;i<=n;i++)if(!vis[i])dfs(i,i);
	for(i=1;i<=n;i++){
		for(j=oldhead[i];j;j=nod[j].next){
			int d=nod[j].v;
			if(Belong[i]!=Belong[d]) newadd(Belong[i],Belong[d]);
		}
	}
}
int dep[10101],siz[10101],fa[10101],son[10101],top[10101];
void dfs1(int u){
	siz[u]=1;
	for(int i=head[u];i;i=node[i].next){
		int d=node[i].v;
		if(fa[u]!=d){
			fa[d]=u;
			dep[d]=dep[u]+1;
			dfs1(d);
			siz[u]+=siz[d];
			if(siz[d]>siz[son[u]])son[u]=d;
		}
	}
}
void dfs2(int u,int tp){
	top[u]=tp;
	if(son[u])dfs2(son[u],tp);
	for(int i=head[u];i;i=node[i].next){
		int d=node[i].v;
		if(fa[u]!=d&&son[u]!=d)dfs2(d,d);
	}
}
inline int lca(int u,int v){
	while(top[u]!=top[v]){
		if(dep[top[u]]>dep[top[v]])u=fa[top[u]];
		else v=fa[top[v]];
	}
	return dep[u]>dep[v]?v:u;
}
inline int out(int n){
	int o=log2(n);
	for(;o>=0;o--){
		if((1<<o)<=n){
			n-=(1<<o);
			printf("1");
		}
		else printf("0");
	}
	printf("\n");
}
int main(){
	n=Read(),m=Read();
	register int i;
	int u,v;
	for(i=1;i<=m;i++)u=Read(),v=Read(),ad(u,v);
	sd();
	dep[1]=1;
	dfs1(1);
	dfs2(1,1);
	int q;
	q=Read();
	while(q--){
		u=Read(),v=Read();
		u=Belong[u];
		v=Belong[v];
		out(dep[u]+dep[v]-2*dep[lca(u,v)]+1);
	}
	return 0;
}
```
# ~~求赞~~

---

## 作者：TEoS (赞：0)

**题意分析**

给出一个无向图，要求将边双联通分量缩点，并给出多个询问求缩点后树上的链长。

看到题解区和讨论区很多人在讨论缩的是e-DCC还是v-DCC，可以看一下下面这张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/ogdrp5qh.png)

可以看出，加粗的这几个点(3,6,7,8,9)显然属于同一个e-DCC,但不属于同一个v-DCC。而根据题意，这几个点应该要缩成同一个点，因此缩的是e-DCC。

**思路分析**

显然地，先缩点，然后求链长。求链长的方法就很多了，不过基本上都要先求出LCA，然后通过深度数组$d$来求出链长。因此能求LCA的算法都可以用来求链长，本文代码使用tarjan求LCA（~~怎么又是tarjan~~）

**具体实现**

无耻地挂一波博客链接：[LCA详解](https://www.cnblogs.com/TEoS/p/11376616.html)

对于在同一个e-DCC里的节点，可以直接特判，显然，答案为1，可以不用再去求。

还有一个需要注意的点，输入数据中可能会有重边，这个重边会导致原本不在同一个e-DCC里的节点被误判为在同一个e-DCC里而导致WA。对于重边的处理，其它题解提供了一些不错的方法，大家可以参考。当然，对于对原程序~~懒得~~不想有太大改动的同学，我们注意到数据范围很小，因此可以直接开一个二维数组判断两个点之间是否已有边，若已有边就不再连，以达到去除重边的目的，空间复杂度$O(n^2)$，勉强卡过。

对于输出，可以用一个栈存储答案，每次取$x$二进制下的最后一位，即$x\%2$，然后除二，直到最高位，然后倒序输出。注意特判0的情况。

还有细节的处理可以看代码注释。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<stack>
#include<vector>
#define y(i) query[x][i].first
#define id(i) query[x][i].second
#define ano ((i-1)^1)+1
using namespace std;
const int N=1e4+100,M=5e4+100;
int n,m,k,tot,num,ctot,cnt;
int head[N],ver[M<<1],Next[M<<1];
int ch[N],cv[M<<1],cn[M<<1];
int low[N],dfn[N],v[N],d[N],fa[N],c[N],ans[M];
bool p[M<<1],pp[N][N];
vector<pair<int,int> > query[M];
stack<int> s;
void add(int x,int y)
{
	ver[++tot]=y,Next[tot]=head[x],head[x]=tot;
	ver[++tot]=x,Next[tot]=head[y],head[y]=tot;
}//原图加边
void addc(int x,int y)
{
	cv[++ctot]=y,cn[ctot]=ch[x],ch[x]=ctot;
}//新图加边
void Add(int x,int y,int id)
{
	query[x].push_back(make_pair(y,id));
	query[y].push_back(make_pair(x,id));
}//加入询问
int get(int a)
{
	return fa[a]==a?a:fa[a]=get(fa[a]);
}//路径压缩并查集
void tarjan(int x,int fa)
{
	dfn[x]=low[x]=++num;
	for(int i=head[x];i;i=Next[i])
	{
		int y=ver[i];
		if(!dfn[y])
		{
			tarjan(y,i);
			low[x]=min(low[x],low[y]);
			if(low[y]>dfn[x])
				p[i]=p[ano]=1;
		}
		else
			if(ano!=fa)
				low[x]=min(low[x],dfn[y]);
	}
}//tarjan求e-DCC
void dfs(int x)
{
	c[x]=cnt;
	for(int i=head[x],y;i;i=Next[i])
		if(!c[y=ver[i]] && !p[i])
			dfs(y);
}//e-DCC缩点
void lca(int x,int f)
{
	v[x]=1;d[x]=d[f]+1;
	for(int i=ch[x],y;i;i=cn[i])
		if(!v[y=cv[i]])
		{
			lca(y,x);
			fa[y]=x;
		}
	for(int i=0;i<query[x].size();i++)
		if(v[y(i)]==2)
			ans[id(i)]=d[x]+d[y(i)]-2*d[get(y(i))]+1;//计算答案，get(y(i))即为LCA(x,y(i))
	v[x]=2;
}//tarjan求LCA及链长
void print(int x)
{
	if(!x)
	{
		puts("0");
		return ;
	}//特判0
	while(s.size())
		s.pop();
	while(x)
		s.push(x%2),x>>=1;//每次取二进制下最后一位
	while(s.size())
		printf("%d",s.top()),s.pop();//倒序输出
	puts("");
}//输出答案
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1,x,y;i<=m;i++)
	{
		scanf("%d%d",&x,&y);
		if(!pp[x][y] && !pp[y][x])
		add(x,y),pp[x][y]=pp[y][x]=1;//判重边
	}//原图加边
	for(int i=1;i<=n;i++)	
		if(!dfn[i])
			tarjan(i,0);//tarjan求e-DCC
	for(int i=1;i<=n;i++)
		if(!c[i])
			cnt++,dfs(i);//e-DCC缩点
	for(int i=1,x,y;i<=tot;i++)
		if(c[x=ver[i]]!=c[y=ver[ano]])
			addc(c[x],c[y]);//新图加边
	scanf("%d",&k);
	for(int i=1,x,y;i<=k;i++)
	{
		scanf("%d%d",&x,&y);
		if(c[x]==c[y])
			ans[i]=1;//特判
		else
			Add(c[x],c[y],i);
	}//加入询问
	for(int i=1;i<=n;i++)
		fa[i]=i;//并查集初始化
	lca(c[1],0);//tarjan求LCA及链长
	for(int i=1;i<=k;i++)
		print(ans[i]);
	return 0;
}
```


---


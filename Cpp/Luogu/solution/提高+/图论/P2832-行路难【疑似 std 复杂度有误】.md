# 行路难【疑似 std 复杂度有误】

## 题目背景

小X来到了山区，领略山林之乐。在他乐以忘忧之时，他突然发现，开学迫在眉睫


## 题目描述

山区有 $n$ 座山。山之间有 $m$ 条羊肠小道，每条连接两座山，只能单向通过，并会耗费小 X 一定时间。

小 X 现在在 $1$ 号山，他的目的是 $n$ 号山，因为那里有火车站。

然而小 X 的体力是有限的。他每通过一条羊肠小道，就会变得更疲劳，导致他通过任意一条羊肠小道的时间都增加 $1$。

## 说明/提示

### 数据范围及约定

对于全部数据，$n \le 10^4$，$m \le 2\times 10^5$。

数据保证没有多条最短路径。

## 样例 #1

### 输入

```
5 8
2 4 2
5 2 1
1 2 1
4 3 2
1 3 3
4 5 2
1 5 8
3 5 3
```

### 输出

```
7
1 3 5 
```

# 题解

## 作者：y2823774827y (赞：21)

貌似下面的题解已全被hack

分析 ~~dalao就直接看程序吧~~

   1. 采用的是普通的bfs入队列，正确性？先是不太疲劳时会直接入队列；后面来的情况必须是当前路径小于之前确定的才有可能为解：因为已经更疲劳了，路径总得小点吧(对同一点入队列分析)
   1. 该题主要难点其实在于如何存入路径，每个点的前驱会随bfs更新而变化，所以本题这样似乎行不通~~留给dalao们尝试吧~~，一般spfa_bfs都习惯用标准queue存入点。这里自己定义队列，用结构体去维护值
   
ps：由于蒟蒻能力有限，如有hack数据希望私信


```cpp
//n<=10000, m<=200000
#include<cstdio>
#include<cstring>
using namespace std;
struct node{
    int to,next,d;
}dis[200010];
struct code{
    int u,d,dfn,pre;
}que[100000010];
int n,m,num,inf=0x3f3f3f3f,tail,hea; int last[10010],head[10010],lu[10010];
inline void add(int u,int v,int d){
    dis[++num].to=v; dis[num].d=d; dis[num].next=head[u]; head[u]=num;
}
void cout(int x){
    if(!x)
        return;
    cout(que[x].pre);
    printf("%d ",que[x].u);
}
void bfs(){
    memset(lu,inf,sizeof(lu));
    lu[1]=0;
    que[++tail].u=1;
    while(hea<=tail){
        hea++;
        int u=que[hea].u,dfn=que[hea].dfn,d=que[hea].d;
        for(int i=head[u];i;i=dis[i].next){
            int v=dis[i].to;
            if(lu[v]>d+dfn+dis[i].d){
                lu[v]=d+dfn+dis[i].d;
                tail++;
                que[tail]=(code){v,lu[v],dfn+1,hea};
                last[v]=tail;
            }
        }
    }
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;++i){
        int u,v,d;
        scanf("%d%d%d",&u,&v,&d);
        add(u,v,d);
    }
    bfs();
    printf("%d\n",lu[n]);
    cout(last[n]);
    return 0;
}
```

---

## 作者：xiejinhao (赞：13)

# $P2832$ 行路难 题解

珍爱生命，远离走路哇……~~没事跑到大山里干啥呢~~



反正这就是个毒瘤题目。因为题目有两个条件，即走的路程和走过的通道数量，而通道数量是会影响走过的路程的，所以一般的最短路算法都可以被卡掉。

比如我们来看下面这个栗子：

![](https://i.loli.net/2019/09/19/xHhSBpIDOqumwRY.png)

我们发现 $1->n$ 的路径有两条，分别是：

$\color{red}1->4->5->6->7$ 和 $\color{green}1->2->3->4->5->6->7$

如果你打正常的$dijkstra$，那么根据最短边原则，它会选择第二条。好了你被卡了。如果你打 $SPFA$，那么我们不仅可以在数据上卡你，也可以让你 $T$ 飞……

所以**很明显这是不可以**的。但是我发现第$11,12$两组数据构造的图都类似于上面这种……即从$1$开始（或者终点）只有 $2$ 种选择，所以我们可以针对数据**强制**选一条边和不选一条边。但对于非$Hack$数据你这么做就不对了，而那两组数据并没有什么特征，所以你可以跑两遍 $dijkstra$，一遍正常，一遍只有一个点没走过才更新，这样你就可以通过全部数据，但是这并不是我们要讲的重点。**因为这种写法可以被这样的图卡掉**：

![](https://i.loli.net/2019/09/19/TJb9y8m4vIipXZf.png)

你一定发现了，这张图 $1$ 不止一个出口，但是你安照上面的写法是对的，也只是偶然，我们稍微进行修改你就被卡了：

![](https://i.loli.net/2019/09/19/yeIGbBd54jxMJwu.png)

```cpp
INPUT:
9 10
1 2 1
2 3 1
3 4 0
4 5 0
1 5 97
1 6 3
6 5 5
5 7 1
7 8 1 
8 9 1

RIGHT OUTPUT
21
1 6 5 7 8 9

WRONG OUTPUT
26
1 2 3 4 5 7 8 9
```
很明显我们这样强制选边不正确了。虽然$1->6$权值为$3$是比$1->2$权值为$1$来的大的，但是其反而能够成为最优解。

为什么呢？其实就是因为题目不仅限制了路径最短，还限制了一个疲劳度。而疲劳度影响了途径，所以走下面那条路反而更疲劳，最后更慢，这也就是一句话：

$$\color{red}\text{欲速则不达}$$

那么我们就要在路径长度和原路长度当中进行一个折中，取一个最优决策。

**那么我们先考虑最暴力的算法，对于一个节点有多条出边，爆搜强制选择与不选。**

很明显这样是会$T$的，因为最坏的复杂度是$O(M^2+NM)$ 的。

（也许复杂度是会小于这个的，因为我听说也可以过……）

那么我们不用考虑优化了……因为已经没有可以优化的空间了。所以我们必须尝试一下别的思路。

其实你是可以用 $A*$搜索 的（如果你估价函数写的好的话）。但是我不会这种神奇的算法，然后我第二反应就是**按层次来找路径**。也就是$BFS$。为什么这么做是可行的？

下面来看看为什么吧，还是拿上面那幅图举栗子：

![](https://i.loli.net/2019/09/19/yeIGbBd54jxMJwu.png)

首先我们先手动划分一下$Bfs$的顺序，也就是节点层次：

首先从$1$访问，节点$1$的层次是$deep[1]=1$。

层次为$deep_i=2$的有：$2 ,6$，$deep_i=3$的有$3,5$。

到这里我不再继续，因为你会发现有一个小问题：节点$5$在拓展给$7$后还会被$3->4->5$在标记一个层次（即更新）。按照以往的$Bfs$这种情况是不会出现的，因为我们用了一个$vis_i=0/1$数组表示一个未访问过/访问过。那节点$4$就再也不会传递给$5$信息了。但是万一就要$4$走到$5$才是最优的呢？那么我们先考虑先更新$5->7$再更新$4->5->7$会不会造成影响（因为在$4$没访问到$5$之前$4$和$7$是同个层次，因此先拓展$5$，再拓展$4$）。

其实你会发现是**不会影响**的。因为我们更新有下面这一个条件限制：

$$\color{green}\text{三角不等式：}dis[y]≤dis[x]+edge_{x,y}$$

### $Done!$

其实你已经完成了。**所以我们可以扔掉$vis$数组了**。真正就是只需要一个$BFS$解决即可。因为如果一开始$1->2$比$1->6$更优，那么后者一定会覆盖到前者，因为$4$还会再更新到$5$。那么如果$1->2$比$1->6$更优但是却是$4$先更新$5$然后$6$再更新$5$呢?

**都说了要满足上面的条件再转移了嘛！**（当然你需要一个额外的$dfn$限制，而上面没打出来）

因此即使$4$先更新了$5$也不会对答案造成影响。上述结论可以推广到1节点更多连边的情况。

不会造成影响的情况，比如：

![](https://i.loli.net/2019/09/19/epCSuRr2i4q38tY.png)

~~很明显没有影响。~~

然后由于上面的这种情况也是个特例，上面的构造也可能出现在图的中部甚至出现多个，但我们按照上面的方式跑仍然不会出错，因为假设对于图中间某个部分第一次出现这种情况，那么之前的情况都很正常，那么是没有问题的；如果在这之后又出现了这样的构造，那么由于最优解重复更新的性质，自然也可以求出最优解。

然后这个应该没有负权吧？即使出现了负权+环也会正确，因为每多走一条边都会积累疲劳度，所以最终也会到达$n$点（因为你不可能真的输入一个负无穷吧），不会出现我们没有$vis$数组死循环的情况！

~~反正题目数据应该保证边权没有负的啦……难不成可以时光倒流？~~

然后我们来分析一下复杂度吧：

我们恰好会遍历每一条边……好多次，所以总的复杂度$O(\sum_{2≤i≤n-1}^{i}in[i]*out[i]+out[1]+in[n])$，反正比较玄学。

所以只分析最坏的时间复杂度就好了，因为$n_{max}=10000,m_{max}=200000$，每个节点大约都有$20$条连边，所以**最坏的复杂度就**是$O(\sum_{2≤i≤n-1}^{i}20*20+40)=O(400N)$，还是可以通过的。

至于为什么取平均是最大的，毕竟按照数学知识，两数之和确定，那么两个数越接近他们的乘积越大嘛……

综上所述，我们成功解决了这样一个~~神奇的~~$DL$的题目。

下面先给出可以通过本题的**最短路算法**。

由于线段树优化$dijkstra$明显快于堆优化，所以下面打的$dijkstra$是线段树优化的。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 10010, M = 200010;
int head[N], Next[M], edge[M], ver[M];
void add(int x , int y, int val) {
	static int cnt = 0;
	ver[++cnt] = y, edge[cnt] = val;
	Next[cnt] = head[x], head[x] = cnt;
}
namespace SEG {
#define Tree_SIZE 100010
#define inf (1 << 30)
	struct Edge {
		int l, r, val, id;
	}t[Tree_SIZE << 2];
#define ls(x) (x << 1)
#define rs(x) (x << 1 | 1)
	inline void update(int p) {
		if(t[ls(p)].val == inf && t[rs(p)].val == inf)
			t[p].val = inf, t[p].id = 0;
		else if(t[ls(p)].val < t[rs(p)].val)
			t[p].val = t[ls(p)].val, t[p].id = t[ls(p)].id;
		else 
			t[p].val = t[rs(p)].val, t[p].id = t[rs(p)].id;
	}
	
	inline void build(int p, int l, int r) {
		t[p].l = l, t[p].r = r, t[p].val = inf;
		if(l == r) {
			t[p].id = l;
			return;
		}
		int mid = (l + r) >> 1;
		build(ls(p), l, mid);
		build(rs(p), mid + 1, r);
	}
	
	inline void change(int p, int x, int val) {
		if(t[p].l == t[p].r) {
			t[p].val = val;
			return;
		}
		
		int mid = (t[p].l + t[p].r) >> 1;
		if(x <= mid) change(ls(p), x, val);
		else change(rs(p), x, val);
		update(p); 
	}
#undef Tree_SIZE
#undef inf
#undef ls
#undef rs
}

bool v[N]; int d[N], pre[N], dfn[N];
inline void dijkstra(int s, int n) {
#define inf (1 << 30)
    memset(d, 0x3f, sizeof(d));
    memset(v, 0, sizeof(v));
    SEG::build(1, 1, n);
    d[s] = 0, SEG::change(1, s, 0); 
    dfn[s] = 0;
    while(SEG::t[1].id) {
    	int x = SEG::t[1].id;
    	SEG::change(1, x, inf);
    	if(v[x]) continue;
    	v[x] = 1;
    	for(int i = head[x]; i; i = Next[i]) {
    		int y = ver[i];
    		if((d[y] > d[x] + edge[i] + dfn[x]) && !dfn[y]) {
    			d[y] = d[x] + edge[i] + dfn[x];
    			dfn[y] = dfn[x] + 1;
    			pre[y] = x;
    			SEG::change(1, y, d[y]);
			}
		}
	}
#undef inf
}

int pre1[N], d1[N];
inline void Dijkstra(int s, int n) {
#define inf (1 << 30)
	memset(d1, 0x3f, sizeof(d));
	memset(dfn, 0 ,sizeof(dfn));
	memset(v, 0, sizeof(v));
	SEG::build(1, 1, n);
	d1[s] = 0, SEG::change(1, s, 0); 
    dfn[s] = 0;
    while(SEG::t[1].id) {
    	int x = SEG::t[1].id;
    	SEG::change(1, x, inf);
    	if(v[x]) continue;
    	v[x] = 1;
    	for(int i = head[x]; i; i = Next[i]) {
    		int y = ver[i];
    		if((d1[y] > d1[x] + edge[i] + dfn[x])) {
    			d1[y] = d1[x] + edge[i] + dfn[x];
    			dfn[y] = dfn[x] + 1;
    			pre1[y] = x;
    			SEG::change(1, y, d1[y]);
			}
		}
	}
#undef inf
}

inline void output(int x, int *pre) {
	if(pre[x]) output(pre[x], pre);
	printf("%d ", x);
}

int main() {
	int n, m;
    scanf("%d %d", &n, &m);
    for(int i = 1, x, y, v; i <= m; i++) {
    	scanf("%d %d %d", &x, &y, &v);
    	add(x, y, v);
	}
	dijkstra(1, n);
	Dijkstra(1, n);
	printf("%d\n", min(d[n], d1[n]));
	if(d1[n] < d[n]) output(n, pre1);
	else output(n, pre);
    return 0;
}
```
然后你知道上面的算法**仅仅能够通过本题及一些特殊数据**就好，以后还会被卡的。

我们把注意力放在下面这一份$BFS$的代码当中。

然后有一个小细节就是，因为会重复覆盖，所以寻找前驱节点按照队列编号找就可以了，所以我们**手动模拟一个队列**，数组大小就开$400*N$就可以（因为最多访问$400*N$条边（其实比这个数还小点），点数多一点点）。然后仍然采用递归输出答案（你们应该都能想出来）。还有一种正序循环输出答案的方式，就是你跑反图，那样直接输出就是正的了$QAQ$。记得记录下最后更新$n$节点的队列中元素编号。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 10010, M = 200010;
int head[N], Next[M], edge[M], ver[M];
void add(int x , int y, int val) {
	static int cnt = 0;
	ver[++cnt] = y, edge[cnt] = val;
	Next[cnt] = head[x], head[x] = cnt;
}

int d[N], pre[N];
struct rec {
	int x, dfn, dis, pre;
	rec() { x = 0, dfn = 0, dis = 0, pre = 0;}
}q[400 * N];

inline void bfs() {
	memset(d, 0x3f, sizeof d);
	rec k;
	int l = 1, r = 0;
	q[++r].x = 1, q[r].dfn = 0, q[r].dis = 0, q[r].pre = 0;
	while(l <= r) { 
		int x = q[l].x, dis = q[l].dis, dfn = q[l++].dfn;
		for(int i = head[x]; i; i = Next[i]) { 
			int y = ver[i]; 
			if(d[y] > dis + dfn + edge[i]) { 
				d[y] = dis + dfn + edge[i];
				k.x = y, k.dfn = dfn + 1, k.dis = d[y], k.pre = l - 1;
				q[++r] = k;
                pre[y] = r;
			}
		}
	}
}

inline void output(int x) { 
	if(q[x].pre) output(q[x].pre);
	printf("%d ", q[x].x);
}

int main() {
	int n, m;
    scanf("%d %d", &n, &m);
    for(int i = 1, x, y, v; i <= m; i++) {
    	scanf("%d %d %d", &x, &y, &v);
    	add(x, y, v);
	}
	bfs();
	printf("%d\n", d[n]);
	output(pre[n]);
    return 0;
}
```

然后我想总结的就是：**看到路径最短不一定是最短路算法。**

这里有本题的一些不优秀的$Hack$数据：[点我$QAQ$](https://www.luogu.com.cn/discuss/show/68500)

这里是我的评测记录：

最短路算法：[点我$QAQ$](https://www.luogu.com.cn/record/24105986)

$BFS$：[点我$QAQ$](https://www.luogu.com.cn/record/24121414)

------------

$2019.9.20 \ Update:$修正了题解中一些细节错误，增加了一些提醒。



$End$
------------


### **都写了这么清楚了，不点个赞？**
$PS:$如果这样的$BFS$写法不正确被$hack$掉了请在评论区留言。

---

## 作者：地表最强男人 (赞：6)

## 首先，不能用dijkstra
因为当前的最短不一定是能够全局的最短路（类似dijkstra不能够跑负权边，如果当前有一条很长但是步数很少的边，还有一组很短，但是步数很多的边，当前的最短更新后面节点不一定是最优的，但是有些题解过了让我很不理解，请尝试这一些数据[hack数据](https://www.luogu.org/discuss/show/68500)）

所以只能跑快要去世的spfa，而且注意，当前的状态包括了步数，最短路和节点的编号，这些是要作为一个状态存入队列中的，而不能分开。举个例子，有一个节点x，步数为2，最短路为2，另一个节点x，步数为1，最短路为2，这两个节点并不能算同一个节点。而且这题还不好按照普通的spfa来记录当前节点有没有在队列中，因为会mle（想一下数组要开多大）。所以我打了一个没有记录是否在队列中的spfa，然后一直被最后两组数据卡了。所以这题还有一个关键点。

## 跑反图
这是我看[这个大佬的题解](https://jrzy.blog.luogu.org/solution-p2832)然后明白的。因为这题要输出路径，而且当前的最短不能作为全局的最短路，而且如果只是普通的记录的pre，后面的输出会变得很奇怪（自己看hack数据的第一组）。

## 但是跑反图也是错误的，因为会被覆盖
可以尝试一下这一组：
```cpp
6 6
1 2 2
2 3 2
3 4 5
4 5 3
5 6 2
3 5 11
```
## 所以这题只能用数组模拟队列，因为这样才能存储一个节点的前一个节点是什么(要不然会被覆盖)
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int N=10010,M=400010;
int n,m,head[M],ver[M],Next[M],tot,headd=1,end=0,key;
long long d[M],num[N],edge[M];
struct rec{
	int step,dis,num,tail;
}q[M];
void add(int x,int y,long long z)
{
	ver[++tot]=y,edge[tot]=z;
	Next[tot]=head[x],head[x]=tot;
}
void bfs()
{
	memset(d,0x3f,sizeof(d));
	d[1]=0;
	rec now;
	now.num=1,now.step=0,now.dis=0,now.tail=-1;
	q[++end]=now;
	while(headd<=end)
	{
		now=q[headd];
		int x=now.num,st=headd;
		headd++;		
		for(int i=head[x];i;i=Next[i])
		{
			int y=ver[i],z=edge[i];
			if(d[y]>now.dis+z+now.step)
			{
				d[y]=now.dis+z+now.step;
				rec Nex;
				Nex.num=y;
				Nex.dis=d[y];
				Nex.step=now.step+1;
				Nex.tail=st;
				q[++end]=Nex;
				if(y==n)
					key=end;
			}
		}
	}
}
void print(int x)
{
	if(q[x].tail!=-1)
		print(q[x].tail);
	cout<<q[x].num<<" ";
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int x,y;
		long long z;
		cin>>x>>y>>z;
		add(x,y,z);
	}
	bfs();
	cout<<d[n]<<endl;
	print(key);
	return 0;
}
```


蒟蒻疯狂借鉴总结，应该是正解（如果是的话希望能顶上去，因为题解很多都有些问题，谢谢支持）。


---

## 作者：老咸鱼了 (赞：4)

~~这题我看了下讨论版的hack数据，不然还真不知道怎么过。~~
我就重点讲下题解为什么会被hack掉，
例如这组数据
INPUT:
7 7
1 2 1
2 3 1
3 4 1
4 5 1
5 6 1
6 7 1
1 5 14
OUTPUT:
19
1 5 6 7
这是标准输入输出，而他们的输出是
19
1 2 3 4 5 6 7
出现这种情况的原因是因为共用一个疲劳和距离，因为疲劳度会随着你走的多而越来越多，就拿这个样例来说，你走1-2-3-4-5最后5的距离是
10比直接走1-5 14要少4，所以别的代码会记录的是这个点疲劳度是3，而不会记录疲劳度1距离为14的这种走法，两种走法虽然都是一样的总花费时间，但是1-2-3-4-5-6-7这种走法花费的要更加疲劳，所以我们选择第二种走法1-5-6-7。

~~吐槽下，明明第二种走的距离要远，应该第二种更加疲劳才对~~

这样的话你就需要从n跑到1而不是从1跑到n，这样原本疲劳多的点会变成疲劳少的点  ~~可能是数据太小，看不出什么东西来，数据大一点可能还是过不去~~

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,t,dis[500050];
int head[500050],cnt,from[500050],times[500050];
bool vis[500050];
struct f{
	int next,to,dis;
}a[500050];
inline void add(int u,int v,int d)
{
	cnt++;
	a[cnt].dis=d;
	a[cnt].next=head[u];
	a[cnt].to=v;
	head[u]=cnt;
}
void spfa()
{
	memset(times,0,sizeof(times));
	memset(from,0,sizeof(from));
	queue<int >q;
	q.push(n);
	dis[n]=0;
	vis[n]=true;
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		vis[u]=false;
		for(int i=head[u];i;i=a[i].next)
		{
			int t=a[i].to;
			if(a[i].dis+dis[u]+times[u]<dis[t])
			{
				dis[t]=dis[u]+a[i].dis+times[u];
				times[t]=times[u]+1;
				from[t]=u;
				if(!vis[t])
				{
					q.push(t);
					vis[t]=true;
				}
			}
		}
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	dis[i]=0x7fffffff;
	for(int i=1;i<=m;i++)
	{
		int u,v,d;
		scanf("%d%d%d",&u,&v,&d);
		add(v,u,d);
	}
	spfa();
	printf("%d\n",dis[1]);
	int t=1;
	while(t)
	{
		printf("%d ",t);
		t=from[t];
	}
	return 0;
}
```
如果哪里有问题希望ORZ能指正

---

## 作者：Yeji_ (赞：4)

## 难点
这道题其实并不难，在数据更新以后，就只有了2个难点：

1.路径的输出。
2.必须要存反向边，并且要从n向1跑。（这个bug我也真的不知道）

## 前置知识
想A这道题，就必须有一些前置知识：dijkstra或spfa，并且你要学会链式前向星。

## 存图方法

### 邻接矩阵：

其实就像他的字面义一样，就是一个二维数组的矩阵，用来存储两个点之间的所属关系，如果这两个点之间有联系，那么便在它们的二维矩阵的交点处附上1。所以说还是比较好理解了的

但是呢，假如有五个点，那么就开一个5*5的二维矩阵，浪费的空间很多，所以我们又有了一个数据结构：链式前向星存图。

### 链式前向星：

若有五个点，假设把他们想做是一个个的小房间，每个房间中藏有其他房间的钥匙，每个房间可以通往其他人的房间。现在我来讲一讲他的具体步骤吧：

有一个东西叫做st的里面存储的是第i条路的最后一条路的编号。

所以呢，我们可以定一个结构体，具体代码如下：

  ```cpp
  struct Edge
  {
          int nxt,to,val;
  }e[6001];//这一步是定义一个结构体。
  void add(int a,int b,int value)
  {
          e[++tot].to = b;//拓展一个新的边
          e[tot].val = value;//这是这条边的权值
          e[tot].last = st[a];
          st[a] = tot;
  }
  //这是每一步都要做的事哦！
  ```

  ```cpp

  顺便附上遍历的代码：
  for(int st[i];i != -1;i = e[i].last)
  {
  }//这样我们就可以遍历全部的点了！！！：）
  ```

接着，最短路的方法应该不用我介绍了吧（大家会看这题，应该就会最短路了）




### 输出
当时我是有点懵的，怎么输出路径???

想了很久，我想出来一个办法————递归输出

用一个$pre$数组来储存节点的上一个节点。有终点开始查找前驱就可以了，所以，这道题，我们应该就可以很简单的A掉了啊

### 代码


    #include<cstdio>
    #include<iostream>
    #include<queue>
    #include<cstring>
    using namespace std;
    const int inf=2147483647;
    int tot,st[200000],n,m,s,t,dis[290000],vis[299909],pre[200000],num[200000];
    struct Edge
    {
            int val,to,next;
    }edge[200000];
    void add(int a,int b,int c)
    {
        edge[++tot].to=b;
        edge[tot].next=st[a];
        edge[tot].val=c;
        st[a]=tot;
    }
    void dg(int x)
    {
        while (x!=n)
        {
            printf("%d ",x);
            x=pre[x];
        }
        printf("%d",n);
    }
    void spfa(int s)
    {
        queue<int> q;
        for (int i = 1; i <= n; ++i)
        {
            dis[i]=inf;
            num[i]=inf;
            vis[i]=0;
        }
        dis[s]=0;
        num[s]=0;
        vis[s]=1;
        q.push(s);
        while (!q.empty())
        {
            int u=q.front();
            q.pop();vis[u]=0;
            for (int i=st[u];i!=0;i=edge[i].next)
            {
                int v=edge[i].to;
                if (dis[v]>=dis[u]+edge[i].val+num[u])
                {
                    if (dis[v]>dis[u]+edge[i].val+num[u])
                    {
                        dis[v]=dis[u]+edge[i].val+num[u];
                        pre[v]=u;
                        num[v]=num[u]+1;
                        if (vis[v]==0)
                        {
                            vis[v]=1;
                            q.push(v);
                        }
                    } 
                    if (dis[v]==dis[u]+edge[i].val+num[u])
                    {
                        if (num[v]>num[u])
                        {
                            num[v]=num[u]+1;
                            pre[v]=u;
                            if (vis[v]==0)
                            {
                                 vis[v]=1;
                                q.push(v);
                            }
                        }  
                    }

                }
            }
        }
    }
    int main()
    {
        cin>>n>>m;
        for (int i=1;i<=m;i++)
        {
            int a,b,c;
            cin>>a>>b>>c;
            add(b,a,c);
        }
        spfa(n);
        cout<<dis[1]<<endl;
        dg(1);
        return 0;
    }


---

## 作者：Stella_Yan (赞：3)

---

题外话：
今天早上本蒟蒻刚写了一篇绿题题解，晚上的蓝题题解求过QWQ

---

正文：

这一题虽然有了好多题解，但是新的数据貌似把楼下好多题解都hack掉了。

这一题我的思路和楼下差不多，就是加一个$l$数组表示走到第$i$个点的疲劳值，然后算最短路的时候加上就可以了。

# 但是这里要存反向边！把正的边反过来存！

反过来存完原来的就~~扔掉~~不存了，跑spfa的时候从n跑到1。那么为什么要存反向边呢？因为这一题要输出路径，我们用$p$数组代表走到点$i$的时候的上一个点是哪个。但是这个$p$数组不能和求最短路同步更新。因为这一题加入了疲劳，可能走到$i$点时的路径是最短的，但是疲劳值不一定是最少的。接着走的时候疲劳值会变得更大，所以后面的点不一定是最短路。但是$p$数组已经更新过了，所以这里的$p$数组实际上是表示从1走到$i$点的最短路径的上一个点是从哪里走过来的，所以只有我们更新到终点时，才把$p$数组存储起来，用另外一个$px$ ~~劈叉~~数组表示。但是有时候同步的更新是对的，而又还没走到终点，所以这时候$p$数组才是正确的，而$px$数组又没有同步更新，那这时候要怎么办呢？

# 存反向边！

这时候的$p$表示的其实是从$n$号点走到$i$号点的最短路的上一个点的编号是多少，也就是从$i$号点走到$n$号点的最短路的下一个点是多少。那么这时候从$n$往回跑就不会出现“最短路是对的，但$p$数组不对”的情况了。

贴上代码：

---

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
const int MAXN=100010;
const int MAXM=200010;
const int inf=999999999;
int dis[MAXN],u[MAXM],v[MAXM],w[MAXM];
int fst[MAXM],nxt[MAXM];
int l[MAXN],p[MAXM];
int px[MAXM];
bool b[MAXN];
int f[MAXN];//跑spfa要用的一堆数组
int n,m;
void print(int x){//输出部分
	while(x!=-1){//因为这里的px[x]表示的是最短路里的x的下一个点，最后一个点的下一个点我们设为-1，
    			 //所以循环一遍就好了
		printf("%d ",x);
		x=px[x];
	}
}
void init(){//初始化
    for(int i=1;i<=n;i++){
    	dis[i]=inf;
	}
    dis[n]=0;//记住要从n开始跑
    for(int i=1;i<=m;i++){
        fst[i]=-1;
    }
}
void spfa(){
    queue<int> q;
    q.push(n);
    l[n]=0;
    for(int i=1;i<=n;i++)//所有都初始化为-1，表示还没有开始跑
    	p[i]=-1;
    while(!q.empty()){
        int x=q.front();
        q.pop();
        b[x]=0;
        for(int k=fst[x];k!=-1;k=nxt[k]){
			if(dis[v[k]]>dis[x]+l[x]+w[k]){
       	        dis[v[k]]=dis[x]+l[x]+w[k];
                l[v[k]]=l[x]+1;
                p[v[k]]=x;
                if(v[k]==1){//这里只有跑到头了才更新px数组
                	for(int i=1;i<=n;i++){
                		px[i]=p[i];
					}
				}
                if(b[v[k]]==0){
                    b[v[k]]=1;
                    q.push(v[k]);
                }
            }
            else if(dis[v[k]]==dis[x]+w[k]){//这里是一个优化，如果走到同一个点，路程相同并且疲劳度比之前小的话
            								//那之后走的路程肯定比之前少
                if(l[x]+1<l[v[k]]){//更新疲劳度
                	l[v[k]]=l[x]+1;
                	p[v[k]]=x;//p数组也要更新
				}
            }
		}
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    init();
    for(int i=1;i<=m;i++){
        scanf("%d%d%d",&v[i],&u[i],&w[i]);//注意这里是先读入v[i]，再读入u[i]，之前正好反过来
        nxt[i]=fst[u[i]];
        fst[u[i]]=i;
    }
    spfa();
    printf("%d\n",dis[1]);//dis[1]就是从第n个点走到第一个点的最短路径，反过来也是一样的
    print(1);//输出
    return 0; //结束
}
```

---

宣传一波[blog](https://jiying.blog.luogu.org/)

---

## 作者：北方有小仙儿 (赞：2)

~~看起来并不难~~

在求最短路的基础上加上当前时间，即下一条路要多的额外时间就可以了。
设d[x]为从起点到x的最短路，每次更新的时候若d[y]>d[x]+路程+额外加的时间，就更新d[y],将t[y]=t[x]+1;

唯一要想一下的就是要正反建图都跑一遍求最小值。

记录路径的时候就记录前缀就行，即从哪个点更新过来，每次更新d[y]的时候记录pre[y]=x;

如果是正图值比较小，记录路径从n一路找到1，再倒着输出。
如果是反图值比较小，记录路径从1到n，正着输出。

讨论中的hack数据没有hack到我哎【托腮】，如果有hack数据请私信联系我~~

有不明白的地方也欢迎私信~~~

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<string>
#include<algorithm>
#include<queue>
using namespace std;
int n,m,res;
int d[10005],t[10005],pre[10005],ans[10005]; 
int cnt,to[200005],val[200005],nxt[200005],head[10005]; 
struct edge{
	int u,v,w;
}a[200005];
void add(int u,int v,int w)
{
	cnt++;
	to[cnt]=v;
	val[cnt]=w;
	nxt[cnt]=head[u];
	head[u]=cnt;
} 
void dijkstra(int v0)
{
	priority_queue<pair<int,int> >q;
	memset(d,0x3f,sizeof(d));
	memset(t,0,sizeof(t));
	d[v0]=0,t[v0]=0;
	q.push(make_pair(0,v0));
	while(!q.empty())
	{
		int x=q.top().second;q.pop(); 
		for(int i=head[x];i;i=nxt[i])
		{
			int y=to[i],z=val[i],e=t[x];
			if(d[y]>d[x]+z+e)
			{
				pre[y]=x;
				d[y]=d[x]+z+e;
				t[y]=e+1;
				q.push(make_pair(-d[y],y));
			}
		}
	}
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int u,v,w;
		cin>>u>>v>>w;
		a[i].u=u,a[i].v=v,a[i].w=w;
		add(u,v,w);
	}
	dijkstra(1);
	res=d[n];
	int x=n,u=0;
	while(x!=1)
	{
		ans[++u]=x;
		x=pre[x];
	}
	ans[++u]=1; 
	cnt=0;
	memset(to,0,sizeof(to));
	memset(val,0,sizeof(val));
	memset(nxt,0,sizeof(nxt));
	memset(head,0,sizeof(head)); 
	for(int i=1;i<=m;i++)
	{
		add(a[i].v,a[i].u,a[i].w);
	}
	dijkstra(n);
	if(d[1]<res)
	{
		int x=1,u=0;
		while(x!=n)
		{
			ans[++u]=x;
			x=pre[x];
		}
		ans[++u]=n;
		cout<<d[1]<<endl;
		for(int i=1;i<=u;i++)cout<<ans[i]<<" ";
		return 0;
	}
	cout<<res<<endl;
	for(int i=u;i>=1;i--)cout<<ans[i]<<" ";
	return 0;
}
```

---

## 作者：xfydemx (赞：2)

这题真的不难啊...也就是看着吓人

然而我第一眼还是被吓住了（逃

~~我可能还是太菜了...~~

咳。
其实只要跑SPFA时记录到现在已经走了多少步，

在模板的基础上加一项num[y]即可

每次走一步维护一下num数组

还不是个模板题嘛。

于是很开心的拿来模板改一改就A啦

呈上自以为风格很棒的代码


```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<queue>
#include<stack>
using namespace std;
#define rg register
long long head[220000],n=1,m,k,inde,flag,Case,rs,root;
long long fl=0,fg,cnt,scnt,t,q,p,e,s,ans,f,r,cld;
long long dis[120000],num[120000],chu[120000],pre[120000];
bool vis[120000];
struct Edge{
    int next,to,w;
}a[220000];
void add(int x,int y,int w){
    inde++;
    a[inde].to=y;
    a[inde].next=head[x];
    a[inde].w=w;
    head[x]=inde;
}
queue<int> Q;
void Spfa(){
    Q.push(1);
    dis[1]=0;
    pre[1]=1;
    while(!Q.empty()){
        int x=Q.front();
        Q.pop();
        vis[x]=0;
        for(int i=head[x];i;i=a[i].next){
            int y=a[i].to;
            if(dis[y]>dis[x]+a[i].w+num[x]){
                dis[y]=dis[x]+a[i].w+num[x];
                num[y]=num[x]+1;
                pre[y]=x;
                if(!vis[y])    Q.push(y);
                vis[y]=1;
            }
        }
    }
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=m;i++){
        cin>>q>>e>>r;
        add(q,e,r);
    }
    memset(dis,0x3f,sizeof(dis));
    Spfa();
    cout<<dis[n];
    int v=n;
    do{
        chu[++fl]=v;
        v=pre[v];
    }while(pre[v]!=v);
    cout<<endl<<"1"<<" ";
    for(int i=fl;i>=1;i--){
        cout<<chu[i]<<" ";
    }
}

```

---

## 作者：w20230071_QwQ (赞：1)

这题的其他题解怎么一直提 HACK 啊，那我提供一种较保险的方法。


------------

由于除了已花费时间之外，还要记录另一个状态，就是已经过路的条数，

不妨在用最短路时将这两个都暴力枚举 点数为 $n^2$ ，

但肯定会超时，考虑优化。

$$$$

* 首先，当一个点之前经过时的 $time$ 和 $number$ 都比 现在的小，那么这次选取就不必了（被单调了pwp）。


* 其次，上面会导致许多状态都用不上，所以可以用 $map$ 优化内存避免 MLE。


对于单调优化开 $map$ 时要注意不能 $map$ 套 $map$ ，而是 $map$ 加数组。

比如原先这样写 `map<int,map<int,int>>mp` 会 T 一个点， ~~(想出来这样写的我好sb)~~

改成 `map<int,int>a[10010]` 就轻松过了，

对于打印路径，记录每个状态的上一个就行了（也就是开了两个 $map$ ）。

$code:$




```cpp
#include<bits/stdc++.h>
using namespace std;
map<int,int>bs[10010];
map<int,int>as[10010];
int pd[10010][2];
struct Node{
	int time,number,point;
}node[10000000];
int dtop=0;
int n,m,a,b,c;
int ans,now;
int fir[10010],nxt[200010],to[200010],qp[200010],top=0;
void ad(int x,int y,int z){//加边 
	top++;nxt[top]=fir[x];fir[x]=top;to[top]=y;qp[top]=z;
}
bool cmp(Node a,Node b){//堆排序 
	return (a.time^b.time)? a.time<b.time:a.number<b.number;
}
void add(int x,int y,int z,int fa){//手打堆加入 
	
	if(bs[x][y]<=z&&bs[x][y])return ;//剪枝 
	if(y>pd[x][0]&&z>pd[x][1]){return ;}  
	if(y<pd[x][0]){
		pd[x][0]=y,pd[x][1]=z;
	}
	bs[x][y]=z;
	dtop++;
	node[dtop].time=z;
	node[dtop].point=x;
	node[dtop].number=y;
	as[x][y]=fa;
	int zz=dtop;
	while(zz>1){
		if(cmp(node[zz],node[zz>>1])){
			swap(node[zz],node[zz>>1]);zz>>=1;
		}
		else return ;
	}
}
void push(int &x,int &y,int &z){//手打堆弹出 
	x=node[1].point;y=node[1].number;z=node[1].time;
	node[1]=node[dtop];dtop--;
	int zz=1;
	while((zz<<1)<=dtop){
		int zzz;
		if((zz<<1)<dtop&&cmp(node[zz<<1|1],node[zz<<1]))zzz=zz<<1|1;
		else zzz=zz<<1;
		if(cmp(node[zzz],node[zz]))swap(node[zz],node[zzz]),zz=zzz;
		else return ;
	}
}
void put(int &x,int &y,int &z){
	while(1){
		if(!dtop)return ;
		push(x,y,z);
		if((bs[x][y]>=z||!bs[x][y])&&(y<=pd[x][0]||z<=pd[x][1]))return ;
	}
}
void Dij(){//纯板子 
	memset(pd,0x7f,sizeof(pd));
	pd[1][0]=0;pd[1][1]=0;
	add(1,0,0,0);
	ans=0;
	int x,y,z;
	while(dtop){
		put(x,y,z);//弹出 
		if(x==n)ans=z,now=y;
		if(ans)return ;
		for(int i=fir[x];i;i=nxt[i]){
			add(to[i],y+1,z+y+qp[i],x);//加入 
		}
	}
}
void print(){
	int zan[10010],ttop=0;
	int zz=n;
	while(zz>=1){
		zan[++ttop]=zz;
		zz=as[zz][now];//每次找上一个 
		now--;
	}
	while(ttop){
		printf("%d ",zan[ttop--]);	
	}
}
int main(){
	cin>>n>>m;//点数，边数 
	for(int i=1;i<=m;i++){
		scanf("%d%d%d",&a,&b,&c);//加边 
		ad(a,b,c);
	}
	Dij();//裸板子 
	cout<<ans<<endl;//输出答案 
	print();//打印路径 
}
```








---

## 作者：pzc2004 (赞：1)

[题目传送门](https://www.luogu.org/problem/P2832)

给出一种保证正确但复杂度玄学的算法。

使用dijkstra，开一个$dis$数组，$dis_{i,j}$表示从1到$i$，共经过$j$条边的最小距离，但容易发现这样内存会炸，于是可以考虑用map，然后就可以愉快dijkstra了，跑的时候顺便记录一下前驱。

但是这样只有52分，还得加一个剪枝，记录一下从1到$i$的最短距离和这个最短距离共经过了几条边，如果当前的距离大于这个最短距离，当前经过的边数也大于这个边数，当前状态就一定不是最优的，~~再卡卡常，开开O2，就过了~~，最慢的点跑了981ms。

代码：
```
#include <bits/stdc++.h>
using namespace std;
namespace io
{
#define SIZ (1 << 21 | 1)
#define gc() (iS == iT ? (iT= (iS= ibuff) + fread(ibuff, 1, SIZ, stdin), (iS == iT ? EOF : *iS++)) : *iS++)
#define out()                             \
	fwrite(obuff, 1, oS - obuff, stdout); \
	oS= obuff;
	char *iS, *iT, ibuff[SIZ], obuff[SIZ], *oS= obuff, *oT= oS + SIZ - 1, fu[110], c;
	int fr;
	template <class Type>
	inline void read(Type &x)
	{
		x= 0;
		Type y= 1;
		for(c= gc(); (c > '9' || c < '0') && c != '-'; c= gc())
			;
		c == '-' ? y= -1 : x= (c & 15);
		for(c= gc(); c >= '0' && c <= '9'; c= gc()) x= x * 10 + (c & 15);
		x*= y;
	}
	template <class Type>
	inline void print(Type x, char text= '\n')
	{
		if(x < 0) *oS++= '-', x*= -1;
		if(x == 0) *oS++= '0';
		while(x) fu[++fr]= x % 10 + '0', x/= 10;
		while(fr) *oS++= fu[fr--];
		*oS++= text;
		out();
	}
}
using io::print;
using io::read;
#define N 10001
#define M 200001
int n, m, head[N], cnt, ans= 2147483647, mi, stac[N], top, a1[N], a2[N];
struct sb//链式前向星存边
{
	int a, b, c;
	inline sb(int x= 0, int y= 0, int z= 0) { a= x, b= y, c= z; }
} e[M];
inline void add(int a, int b, int c)//建边
{
	e[++cnt]= sb(head[a], b, c), head[a]= cnt;
}
struct sb2//放到优先队列里的东西
{
	int a, b, c;
	inline sb2(int x= 0, int y= 0, int z= 0) { a= x, b= y, c= z; }
	inline bool operator<(const sb2 &y) const { return b > y.b; }
};
priority_queue<sb2> q;
struct sb3//放到map里的东西
{
	int a, b;
	inline sb3(int x= 0, int y= 0) { a= x, b= y; }
	inline bool operator<(const sb3 &y) const { return a < y.a || (a == y.a && b < y.b); }
};
map<sb3, int> dis, pre;//距离，前驱
map<sb3, bool> vis;//dijkstra的vis数组
signed main()
{
#ifndef ONLINE_JUDGE
	freopen("testdata.in", "r", stdin);
	freopen("testdata.out", "w", stdout);
#endif
	read(n), read(m);
	for(int i= 1, a, b, c; i <= m; i++) read(a), read(b), read(c), add(a, b, c);//建边
	memset(a1, 0x7f, sizeof(a1));//初始化
	q.push(sb2(1, 0, 0));
	dis[sb3(1, 0)]= 0;
	while(!q.empty())//跑dijkstra
	{
		sb2 kkk= q.top();
		q.pop();
		if(vis[sb3(kkk.a, kkk.c)] || kkk.c == n) continue;//如果已经访问过就continue，同时如果已经经过了n个点接下来就会重复经过点，肯不是最优的，也continue
		if(kkk.b >= a1[kkk.a] && kkk.c > a2[kkk.a]) continue;//上面讲的剪枝
		vis[sb3(kkk.a, kkk.c)]= 1;
		if(kkk.a == n)//记录答案
		{
			if(ans > kkk.b)
			{
				ans= kkk.b, mi= kkk.c;
			}
		}
		for(int i= head[kkk.a]; i; i= e[i].a)
		{
			int xxx= kkk.b + e[i].c + kkk.c;
			sb3 xx(e[i].b, kkk.c + 1);
			map<sb3, int>::iterator it= dis.find(xx);
			if(it == dis.end() || (*it).second > xxx)//更新dis
			{
				dis[xx]= xxx;
				pre[xx]= kkk.a;
				if(xxx < a1[e[i].b])//更新从1到i的最短路径
				{
					a1[e[i].b]= xxx;
					a2[e[i].b]= kkk.c + 1;
				}
				else if(xxx == a1[e[i].b] && kkk.c + 1 < a2[e[i].b])
					a2[e[i].b]= kkk.c + 1;
				q.push(sb2(e[i].b, dis[xx], kkk.c + 1));
			}
		}
	}
	print(ans);
	for(sb3 i= sb3(n, mi); i.b >= 0; i= sb3(pre[i], i.b - 1)) stac[++top]= i.a;//记录路径
	for(int i= top; i; i--) print(stac[i], ' ');
}
```
![](https://www.luogu.org/images/congratulation.png)

---

## 作者：丿王者之路 (赞：1)

这是一道较水的spfa题；

虽然楼下有跟我差不多的，但其是用vector来存的图，那我还是厚着脸皮发一道自己的更弱的吧；

这道题的核心是求最短路，但引入了疲惫值这一东西,仔细想一下，其实也就只是在spfa上做了一个小小的改动；

在队列中我们压入的不仅仅只是点了，还应该压入到达当前节点所经过的路径条数（即还需花费的代价），到当前节点的距离；

然后在跑spfa就可以了；

如还是不懂，可以参见我代码，进行理解；

```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;
const int maxn=10000+10,maxm=200000+10;
int n,m,dist[maxn],pre[maxn],Ans[maxn];
//用pre[]来记录路径，Ans[]来记录所经过的点； 
struct node
{
    int next,to,w;
}edge[maxm];
int head[maxn],k;
void adde(int u,int v,int w)
{
    edge[++k].to=v;
    edge[k].w=w;
    edge[k].next=head[u];
    head[u]=k;
}
struct ans
{
    int dis,node,time;
};
void spfa(int st)
{
    queue<ans> q;
    memset(dist,0x7f,sizeof dist);
    dist[st]=0;q.push(ans{0,st,0});
    while(!q.empty())
    {
        ans tmp=q.front();q.pop();
        for(int i=head[tmp.node];i;i=edge[i].next)
        {
            int to=edge[i].to;
            if(dist[to]>tmp.dis+edge[i].w+tmp.time)//注意了，核心代码（与普通spfa不同的地方） 
            {
                dist[to]=tmp.dis+edge[i].w+tmp.time;
                pre[to]=tmp.node;
                q.push(ans{dist[to],to,tmp.time+1});
            }
        }
    }
}
int main()
{
    scanf("%d %d",&n,&m);
    for(int u,v,z,i=1;i<=m;i++) scanf("%d %d %d",&u,&v,&z),adde(u,v,z);
    spfa(1);
    //从起点开始； 
    printf("%d\n",dist[n]);
    int tmp=n,jilu=0;
    Ans[++jilu]=tmp;
    while(pre[tmp])
    {
        Ans[++jilu]=pre[tmp];
        tmp=pre[tmp];
```
}//将pre[]记录的路径转到Ans中；
    for(int i=jilu;i>=1;i--) printf("%d ",Ans[i]);

    //注意要倒着输出； 

}

---

## 作者：Kwork (赞：1)

这一题说是话我AC的时间跨度很大。一开始拿了50分然后放弃了，然后过了一段时间之后一次就AC了。

我的思路是spfa，但在普通的spfa上需要改进，因为这道题引入了疲劳。

那么我们在更新非终点的点的最短用时的时候要在原来的基础上加上疲劳度。

其他没和平常的最短路没什么两样。


```cpp
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <vector>
#include <queue>
#include <algorithm>
//luogu 貌似会把空行吞掉
using namespace std;
#define pb push_back
//
const int MAXN=10000+20,MAXM=200000+20,INF=1234567890;
//
struct edge{int to,w;};
//
vector<edge>G[MAXN];
int n,m,pre[MAXN],d[MAXN],power[MAXN],inq[MAXN];
queue<int>que;
vector<int>ans;
//
inline void read(int &n){
    n=0;
    char ch=getchar();
    while(ch<'0' || ch>'9') ch=getchar();
    do{
        n=n*10+ch-'0';
        ch=getchar();
    }while(ch>='0' && ch<='9');
    return;
}
inline void add_edge(int u,int v,int w){
    edge e;
    e.to=v,e.w=w;
    G[u].pb(e);
    return;
}
void init(){
    int u,v,w;
    read(n);read(m);
    for(int i=1;i<=m;i++){
        read(u);read(v);read(w);
        add_edge(u,v,w);
    }
    return;
}
void solve(){
    memset(inq,0,sizeof(que));
    memset(pre,-1,sizeof(pre));
    memset(power,0,sizeof(power));
    for(int i=1;i<=n;i++) d[i]=INF;
    d[1]=0;inq[1]=1;que.push(1);
    while(!que.empty()){
        int u=que.front();
        que.pop();inq[u]=0;
        for(int i=0;i<G[u].size();i++){
            int v=G[u][i].to;
            int w=G[u][i].w;
            if(v==n){
                if(d[v]>(d[u]+w)){
                    d[v]=d[u]+w;
                    pre[v]=u;
                    if(!inq[v]){
                        inq[v]=1;
                        que.push(v);
                    }
                }
            }
            else{
                if(d[v]>(d[u]+power[u]+w+1)){
                    d[v]=d[u]+power[u]+w+1;
                    power[v]=power[u]+1;
                    pre[v]=u;
                    if(!inq[v]){
                        inq[v]=1;
                        que.push(v);
                    }
                }
                else{
                    if(d[v]==(d[u]+power[u]+w+1)){
                        if(power[v]>(power[u]+1)){
                            power[v]=power[u]+1;
                            pre[v]=u;
                            if(!inq[v]){
                                inq[v]=1;
                                que.push(v);
                            }
                        }
                    }
                }
            }
        }
    }
    printf("%d\n",d[n]);
    int t=n;
    while(1){
        ans.pb(t);
        t=pre[t];
        if(t==-1) break;
    }
    for(int i=ans.size()-1;i>=0;i--){
        printf("%d ",ans[i]);
    }
    return;
}
int main(){
    init();
    solve();
    return 0;
}
```

---

## 作者：Link_Space (赞：0)

其实这道题就是求最短路，只不过路的权值会随时间的变化而变化，既然是最短路，那么当然可以用到Dijkstra来跑一遍，只不过需要在路上处理一下关于时间的改变而改变的边权，具体详情请看代码
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<queue>
using namespace std;
typedef long long ll;
typedef pair<ll, pair<int,int> > PII;
priority_queue<PII, vector<PII>, greater<PII>> q;
int head[1000000];
int ver[1000000];
int nxt[1000000];
int cnt;
int link[1000000];
int bef[1000000];
void add(int x,int y,int z)
{
    nxt[++cnt] = head[x];
    head[x] = cnt;
    ver[cnt] = y;
    link[cnt] = z;
}
int n, m;
ll dis[1000000];
bool aim[1000000];
void djslm(int sta)//标准的Dijkstra
{
    memset(dis, 0x7f, sizeof dis);
    q.push({0, {0, sta}});
    dis[sta] = 0;
    while(!q.empty())
    {
        PII temp = q.top();
        q.pop();
        ll lea = temp.first;
        int now = temp.second.first;//此处与常规不同，多了一个now记录当前的时间
        int point = temp.second.second;
        if(aim[point])
            continue;
        aim[point] = 1;
        for (int i = head[point]; i;i=nxt[i])
        {
            int v0 = ver[i];
            if(dis[v0]>lea+link[i]+now)//在比较的时候也要+上当前时间
            {
                dis[v0] = lea + link[i] + now;
                bef[v0] = point;//顺便记录路上经过的点
                q.push({dis[v0], {now + 1, v0}});
            }
        }
    }
}
void out(int now)
{
    printf("%d ", now);
    if(bef[now])
        out(bef[now]);
}
int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m;i++)
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(b, a, c);//注意这里要反向建边然后跑反向图，否则会错两个点
    }
    djslm(n);
    printf("%lld\n",dis[1]);
    out(1);//由于是倒着跑的，往前输出路径
    printf("\n");
}
```


---

## 作者：Victorique_De_Blois (赞：0)

### 最短路的路径输出：

- 我们要有一个数组$pre$来保存节点的前趋

- 判断$v$是否为$u$的前趋，则要看$u$的最短路是否能更新$v$的路径。

- 由终点开始查找前趋，递归调用就可以输出了：

---

$Code:$

    void print(int x) {
        if(pre[x] != -1)//当x的前趋不为空时
            print(pre[x]);//查找它的前趋
        printf("%d ", x);//最后输出x
    }
    
### 疲劳值的累加：

- 用当前一层的待扩散节点$u$去更新其连接点$v$时，$v$应该累加多少疲劳值。

- 我们需要查询从起点到$u$的路径数量，用数组$k$保存。

- $spfa$势在必行，我们可以得出：$k[v]=k[u]+1$

### 算法分析：

- 从起点到$u$的最短路已经求出，而$u$又是通过一条连边到达$v$，故：
$$dis[v]=\min(dis[v],dis[u]+edge[i].w+k[u])$$

- 若$u$能更新$v$到起点的最短距离，则我们称$u$为$v$的前趋。

- 当然，若$v$的未被标记，我们能将其作为下一待扩散节点入队。

- 就这样结束了吗？

- 我们也要想办法尽量减少小X的疲劳值，当$u$通过连边到达点$v$的距离与其本身到起点的距离相等时，我们要取最小的疲累值累加。

- 前趋设定两个，到了终点再赋值。

### 核心代码：

    void spfa(int start)
    {
        for(int i = 1; i <= n; i++)
            dis[i] = inf;//初始化到正无穷 
        queue<int> Q;//创建队列保存待扩散节点 
        Q.push(start);//将起点入队。 
        dis[start] = 0;
        vis[start] = 1;
        while(!Q.empty())
        {
            int u = Q.front();//取出队头元素 
            Q.pop();
            vis[u] = 0;
            for(int i = head[u]; i; i = edge[i].next)
            {
                int v = edge[i].to;
                if(dis[v] > dis[u] + k[u] + edge[i].w)
                {
                    p[v] = u;//保存前趋 
                    k[v] = k[u] + 1;//疲劳值累加 
                    dis[v] = dis[u] + k[u] + edge[i].w;//更新路径 
                    if(v == 1)
                        memcpy(pre, p, sizeof p);//到了终点确定前趋 
                    if(!vis[v])//没有被标记就入队 
                    {
                        vis[v] = 1;//标记 
                        Q.push(v);//入队 
                    }
                }
                else if(dis[v] == dis[u] + edge[i].w) {
                    if(k[u] + 1 < k[v]) {//更新更小的疲劳值 
                        k[v] = k[u] + 1;
                        p[v] = u;//前趋重置 
                    }
                }
            }
        }
    }

---

## 作者：YitsuHolo (赞：0)

其实这个题还是比较水

首先我们可以明确一点，当前的最优解不一定是全局最优解

这一点可以很容易证明，具体数据也可以参照出题人的hack数据

样例输入：

7 7

1 2 2

2 3 2

3 4 2

4 5 2

5 6 2

6 7 2

1 4 10

样例输出：

22

1 4 5 6 7

那么我们可以想到，既然到达当前点经过的不同的路径会对距离有或多或少的影响，那么我们就将这个经过的点的数量分离出来形成新的一维，原来的最短路就变成了两维，dist[ i ][ j ]表示到达i这个点，经过j条边的最短路径

```cpp
//知道你们喜欢这个 
#include<queue>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
struct node
{
	int to,next,dist;
};
struct point
{
	int to,step;//由于最短路是记录的两维，所以spfa也要记录两个量 
};
int head[10010];
node edge[200010];
int n,m,k;
//亲自测试，经过的边数不超过50 
int dist[10010][60];	//距离 
bool vis[10010][60];	//是否在队列中 
int pre[10010][60];		//当前点从哪个点转移过来 

//建边，不用说了 
inline void add(int come,int to,int dist)
{
	edge[++k]=(node){to,head[come],dist};
	head[come]=k;
}

//spfa上稍加改动 
void spfa()
{
	point x;
	memset(dist,0x7f,sizeof(dist));
	queue<point> q;
	
	//dist[哪个点][经过的边的数量] 
	q.push((point){1,0});
	vis[1][0]=true;
	dist[1][0]=0;
	
	while(!q.empty())
	{
		x=q.front();q.pop();
		if(x.step>=50) continue;	//防止指针越界 
		vis[x.to][x.step]=false;
		for(int i=head[x.to];i;i=edge[i].next)
		{
			int v=edge[i].to;
			if(dist[v][x.step+1]>dist[x.to][x.step]+edge[i].dist+x.step)
			{
				dist[v][x.step+1]=dist[x.to][x.step]+edge[i].dist+x.step;	//改变最短路径的值 
				pre[v][x.step+1]=x.to;	//改变前驱 
				if(!vis[v][x.step+1])	//队列中没有的话就丢进去 
				{
					vis[v][x.step+1]=true;
					q.push((point){v,x.step+1});
				}
			}
		}
	}
}

void print(int u,int step)	//输出答案 
{
	if(!u) return ;
	print(pre[u][step],step-1);
	printf("%d ",u);
}

int main()
{
	int u,v,w;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&u,&v,&w);
		add(u,v,w);
	}
	
	spfa();
	int step,minn=0x7fffffff;
	
	//最后一定要再扫一遍，因为不知道答案的位置 
	for(int i=1;i<=50;i++)
		if(dist[n][i]<minn)
			minn=dist[n][i],step=i;
	
	printf("%d\n",dist[n][step]);
	print(n,step);
	return 0;
}
```

---

## 作者：Memorize (赞：0)

这道题还是一道比较裸的最短路 这道题唯一的难点是权值会动态的变化 所以我们在松弛操作中添加一个sum数组

sum[i]表示到i时已经走了几条路 那么松弛操作稍稍做一点变动:

```cpp
if(dist[e[i].to]>dist[p]+e[i].w+du[p])
            {
               dist[e[i].to]=dist[p]+e[i].w+du[p];
               du[e[i].to]=du[p]+1;
               pre[e[i].to]=p;
               if(!vis[e[i].to])
               {
                  vis[e[i].to]=true;
                  que[++qtail]=e[i].to;
               }    
            }
            else if(dist[e[i].to]==dist[p]+e[i].w&&du[e[i].to]>du[p]+1)//这样会使得后面的更优
            du[e[i].to]=du[p]+1,pre[e[i].to]=p;
剩下的就是spfa框架啦!
```

---


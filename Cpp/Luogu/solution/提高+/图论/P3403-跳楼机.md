# 跳楼机

## 题目背景

DJL 为了避免成为一只咸鱼，来找 srwudi 学习压代码的技巧。


## 题目描述

Srwudi 的家是一幢 $h$ 层的摩天大楼。由于前来学习的蒟蒻越来越多，srwudi 改造了一个跳楼机，使得访客可以更方便的上楼。

经过改造，srwudi 的跳楼机可以采用以下四种方式移动：

1. 向上移动 $x$ 层；
2. 向上移动 $y$ 层；
3. 向上移动 $z$ 层；
4. 回到第一层。

一个月黑风高的大中午，DJL 来到了 srwudi 的家，现在他在 srwudi 家的第一层，碰巧跳楼机也在第一层。DJL 想知道，他可以乘坐跳楼机前往的楼层数。

## 说明/提示

可以到达的楼层有：$1,5,8,9,10,12,13,14,15$。

$1 \le h \le 2^{63}-1$，$1 \le x,y,z \le 10^5$。

## 样例 #1

### 输入

```
15
4 7 9
```

### 输出

```
9
```

## 样例 #2

### 输入

```
33333333333
99005 99002 100000
```

### 输出

```
33302114671
```

# 题解

## 作者：xht (赞：117)

## 基本思想

通过同余构造某些状态，状态之间的关系类似于两点之间的带权有向边。

那么可以以此建图，将某些问题转化为最短路问题，再使用具有优秀时间复杂度的算法求解。

#### 【例题】[P3403 跳楼机](https://www.luogu.com.cn/problem/P3403)

首先可以将 $h$ 减去 $1$，同时起始楼层设为 $0$。

设 $d_i$ 为能够到达的最低的 $\bmod x = i$ 的楼层。

则有 $i \stackrel{y}{\longrightarrow} (i+y)\bmod x$ 和 $i \stackrel{z}{\longrightarrow} (i+z)\bmod x$。

像这样建图后，$d_i$ 就相当于 $0 \to i$ 的最短路，Dijkstra 即可。

最后统计时，对于 $d_i \le h$，有贡献 $\lfloor\frac{h-d_i}x\rfloor + 1$。

总时间复杂度 $\mathcal O(n \log n)$。

```cpp
const int N = 1e5 + 7;
const ll inf = (1ull << 63) - 1;
ll h, d[N], ans;
int x, y, z, v[N];
vector< pi > e[N];
pq< pair< ll, int > > q; 

int main() {
	rd(h), --h, rd(x), rd(y), rd(z);
	for (int i = 0; i < x; i++) e[i].pb(mp((i + y) % x, y)), e[i].pb(mp((i + z) % x, z)), d[i] = inf;
	d[0] = 0, q.push(mp(0, 0));
	while (q.size()) {
		int x = q.top().se;
		q.pop();
		if (v[x]) continue;
		v[x] = 1;
		for (ui i = 0; i < e[x].size(); i++) {
			int y = e[x][i].fi, z = e[x][i].se;
			if (d[y] > d[x] + z) d[y] = d[x] + z, q.push(mp(-d[y], y));
		}
	}
	for (int i = 0; i < x; i++)
		if (h >= d[i]) ans += (h - d[i]) / x + 1;
	print(ans);
	return 0;
}
```

#### 【例题】[P2371 [国家集训队]墨墨的等式](https://www.luogu.com.cn/problem/P2371)

上一题的扩展。

```cpp
const int N = 5e5 + 7;
const ll inf = 1e18;
ll l, r, d[N], ans;
int n, x, v[N];
vector< pi > e[N];
pq< pair< ll, int > > q; 

int main() {
	rd(n), rd(l), --l, rd(r), rd(x);
	for (int i = 1; i < x; i++) d[i] = inf;
	for (int i = 1, y; i < n; i++) {
		rd(y);
		for (int i = 0; i < x; i++)
			e[i].pb(mp((i + y) % x, y));
	}
	q.push(mp(0, 0));
	while (q.size()) {
		int x = q.top().se;
		q.pop();
		if (v[x]) continue;
		v[x] = 1;
		for (ui i = 0; i < e[x].size(); i++) {
			int y = e[x][i].fi, z = e[x][i].se;
			if (d[y] > d[x] + z) d[y] = d[x] + z, q.push(mp(-d[y], y));
		}
	}
	for (int i = 0; i < x; i++) {
		if (r >= d[i]) ans += (r - d[i]) / x + 1;
		if (l >= d[i]) ans -= (l - d[i]) / x + 1;
	}
	print(ans);
	return 0;
}
```

---

## 作者：StarsIntoSea_SY (赞：39)

Upd 24.10.17：修改了部分笔误。

包括 [OI Wiki](https://oi-wiki.org/graph/mod-shortest-path/) 在内的同余最短路教程感觉都过于抽象，本蒟蒻学了很久才理解……于是写下了这篇算是比较详细的文章。

前置知识：单源最短路、同余。

在此之前可以去 [OI Wiki](https://oi-wiki.org/graph/mod-shortest-path/) 了解一下同余最短路的用途，这里不多赘述。

注意：本文章语言更偏向口语化，没有过多专业术语，如果您需要更加严谨的文章建议转向其他文章，感谢。

# 图论部分

（凡是提到类似“跑一遍最短路”的话可以认为是 Dijkstra 算法或 SPFA 算法，两者无异。）

（如果您曾经接触过[差分约束](https://www.luogu.com.cn/problem/P5960)并且已经理解掌握，那么您可以跳过该部分。）

先来看这么一张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/b17489y5.png)

这是以 $1$ 号节点出发，跑一遍最短路会得到 $dis$ 数组，$dis[x]$ 表示从 $1$ 号节点到 $x$ 节点的最短路径。

我会暂时把这类跑一遍最短路的图称为**最短路图**。

在跑最短路时，我们总是会不断更新 $dis$ 数组（即松弛操作），更新的条件是满足：$dis[x]+edge(x,y)<dis[y]$。

其中 $edge(x,y)$ 表示从 $x$ 向 $y$ 的一条有向边的边权，如上图的 $edge(5,3)=6$。

但是最短路图有一个显然的性质：对于任意两个点 $x,y$，若 $x$ 向 $y$ 有有向边，那么一定满足不等式：
$$
dis[x]+edge(x,y)\ge dis[y]
$$
证明比较容易：如果没有能够进行松弛操作的一对点，就会停止跑最短路，相当于没有任意两个点满足：$dis[x]+edge(x,y)<dis[y]$，那反过来就得到了 $dis[x]+edge(x,y)\ge dis[y]$。

这个性质非常重要，这将会是解决同余最短路和差分约束的关键。

# 算法部分

引入一个问题：

>  给定四个正整数 $x,y,z,H$，求有多少个整数 $d \in [0,H]$ 满足 $ax+by+cz=d$，其中 $a,b,c$ 且都是非负整数。

（接下来的 $a,b,c$ 均为非负整数，称一个数合法当且仅当其可以表示成 $ax+by+cz$ 的形式，但不一定小于等于 $H$。）

一个重要的性质，若一个整数 $k$ 能被若干个 $y,z$ 拼成（$k=by+cz$），那么 $k+x$、$k+2x$、$k+3x\cdots$ 都是合法的，当然 $k$ 本身也是合法的。

我们令函数 $f(i)$ 为 $by+cz \bmod x =i$ 时最小的 $ay+bz$。也可以理解为使用若干个 $x$ 和 $y$ 能够拼成与 $i$ 在模 $x$ 意义下最小的值。

该函数有一个显而易见的性质：
$$
f(i)+y \ge f((i+y)\bmod x)\\
f(i)+z \ge f((i+z)\bmod x)
$$
我们发现这个性质与我们上面提到的最短路图的性质（$dis[x]+edge(x,y)\ge dis[y]$）相似。

这样我们可以建边：
$$
edge(i,(i+y)\bmod x)=y\\
edge(i,(i+z)\bmod x)=z
$$
即：
- $i$ 向 $(i+y)\bmod x$ 建一条边权为 $y$ 的有向边。
- $i$ 向 $(i+z)\bmod x$ 建一条边权为 $z$ 的有向边。

$i$ 为大于等于 $0$ 小于 $x$ 的整数。

建完边之后，跑一遍最短路，得到的 $dis[i]$ 就相当于 $f(i)$。

那么有了 $f(i)$，如何计算答案。

根据我们刚开始得出的一个性质，若一个整数 $k=by+cz$，那么对于 $k+x$、$k+2x$、$k+3x\cdots$ 小于等于 $H$ 的数共有 $\lfloor\frac{H-k}{x}\rfloor$ 个。

这个公式其实很简单，大于 $k$ 小于等于 $H$ 的数有 $H-k$ 个，在这些数中每 $x$ 个数就有 $1$ 个，一共就是 $\lfloor\frac{H-k}{x}\rfloor$ 个。

那么本题的答案就是：
$$
\sum_{i=0}^{x-1}\lfloor\frac{H-f(i)}{x}\rfloor+1
$$
加一是因为 $f(i)$ 本身也是一个合法数。

让 $f(i)$ 尽可能小是为了防止漏解。

根据定义，$f(0)$ 一定等于 $0$，那么跑最短路时源点也就确定了是 $0$。

## 例题1 [P3403 跳楼机](https://www.luogu.com.cn/problem/P3403)

其实就是上面的那道题。

但是楼层是从 $1$ 开始的，我们可以假设从 $0$ 开始，统计到 $H-1$ 即可。


```cpp
#include <stdio.h>
#include <queue>
using namespace std;
#define int long long
const int N=1e5+5;
const int inf=9223372036854775807;
int H,x,y,z,idx=0;
int dis[N],vis[N],h[N];
struct node{int to,c,ne;}e[N<<1];
void add(int a,int b,int c){
	e[++idx]={b,c,h[a]};
	h[a]=idx;
}
void SPFA(){//最短路模板
	for(int i=0;i<x;++i) dis[i]=inf;
	queue<int> q;
	q.push(0),dis[0]=0;
	while(!q.empty()){
		int x=q.front();
		q.pop();
		vis[x]=0;
		for(int i=h[x],y,w;i;i=e[i].ne){
			y=e[i].to;
			w=e[i].c;
			if(dis[x]+w<dis[y]){
				dis[y]=dis[x]+w;
				if(!vis[y]){
					vis[y]=1;
					q.push(y);
				}
			}
		}
	}
}
int main(){
	scanf("%lld%lld%lld%lld",&H,&x,&y,&z);
	if(x==1||y==1||z==1){printf("%lld\n",H);return 0;}//特判
	--H;
	for(int i=0;i<x;++i){
		add(i,(i+y)%x,y);
		add(i,(i+z)%x,z);
	}
	SPFA();
	int res=0;
	for(int i=0;i<x;++i)
		if(H>=dis[i]) res+=(H-dis[i])/x+1;//这里特判一下是可能会有大于H的情况，导致出现负数
	printf("%lld\n",res);
}
```

## 例题2 [P2371 [国家集训队] 墨墨的等式](https://www.luogu.com.cn/problem/P2371)

只是从 3 个的情况变成了 $n$ 个的情况。

统计时只需要先统计小于等于 $r$ 的情况，把答案减去小于等于 $l-1$ 的情况即可。

注意要额外特判等于 $0$ 的情况。


```cpp
int main(){
	scanf("%lld%lld%lld",&n,&l,&r);qwq=-1;
	for(int i=1;i<=n;++i){
		scanf("%lld",&a[i]);
		if(a[i]==1){
			printf("%lld\n",r-l+1);
			return 0;
		}
		if(a[i]!=0&&qwq==-1) qwq=i;//记录第一个不为0的位置
	}
	if(qwq==-1){printf("0\n");return 0;}
	--l;
	for(int i=0;i<a[qwq];++i)
		for(int j=1;j<=n;++j)
			if(j!=qwq) add(i,(i+a[j])%a[1],a[j]);
	SPFA();
	int res=0;
	for(int i=0;i<a[qwq];++i){
		if(r>=dis[i]) res+=((r-dis[i])/a[qwq]+1);
		if(l>=dis[i]) res-=((l-dis[i])/a[qwq]+1);
	}
	printf("%lld\n",res);
}
```

## 例题3 [AT_arc084_b Small Multiple](https://www.luogu.com.cn/problem/AT_arc084_b)

令函数为 $f(i)$ 为一个数 $x \bmod n =i$ 时位数和的最小值。

那么有：

- $f(i) \ge f(10i\bmod n)$
- $f(i) +1 \ge f((i+1)\bmod n)$

即 $i$ 向 $10i \bmod n$ 建一条边权为 $0$ 的边、$i$ 向 $(i+1)\bmod n$ 建一条边权为 $1$ 的边。

注意这里应该让 $f(1)=1$ 且以 $1$ 为源点跑最短路，答案为 $f(0)$，因为我们是要求出 $n$ 的正整数倍的答案，其在模 $n$ 意义下为 $0$。而且 $f(1)$ 显然等于 $1$。 

# 其他注意事项

不难发现这个同余最短路是需要选出一个数作为模数，我们暂时令这个数为 $x$。

我看很多讲解是要求 $x$ 尽可能小，但没必要。跑这个最短路需要 $x$ 个点，边的个数与点数相关，因此，选出的 $x$ 实际上与整个程序效率有关，并不影响正确性。

感谢您能看到这里！如果有什么不懂的地方\有错误需要指正的地方就私信我，感谢！！qwq

---

## 作者：MrPython (赞：12)

从来没见过同余最短路，确实有点意思的。此类题关键在于，其中某个元素的范围很小，我们需要以此为切入点解决。方便起见，我们从 $0$ 开始出发，存在的最后一个楼层为 $h-1$。

对于任何一个能到达的数，可以继续乘坐跳楼机上升 $x$ 层若干次。因此可以发现，设有 $a\equiv b \pmod x$，其中 $a\le b$，若可以到达 $a$，则一定可以到达 $b$。

假设我们已经求出了仅使用 $y$ 和 $z$ 能到达的数集 $S$。从 $S$ 中任取一数 $v$，则任意 $v+kx(k\ge0,v+kx<h)$ 都可以达到，这样的 $k$ 有 $\left \lfloor \dfrac{h-1-v}{x} \right \rfloor +1$ 个。

但是，一个数可能会被重复统计。这是由于 $S$ 中可能有多个数关于 $x$ 同余。其中一个解决方案，即多个同余的数仅保留最小的，这是因为从最小的这个数 $v$ 开始一直加 $x$ 若干次后，一定可以到达其他与 $v$ 模 $x$ 同余的点。

现在，对于每个 $0\le i<n$，我们想要知道集合中满足 $v\bmod x=i$ 的最小的点 $v$（形式化地，我们要求 $\min_{v\in S,v\bmod x=i}v$）。这里的一个相当聪明的步骤是转化为图论问题。

我们建立一个 $x$ 个点的图，编号为 $0$ 到 $x-1$。对某一个点 $i$，我们建立边 $i\stackrel{y}{\longrightarrow}((i+y)\bmod x)$ 和 $i\stackrel{z}{\longrightarrow}((i+z)\bmod x)$。在这个图中，每条种移动方案都可以用一条路径描述：上升 $y$ 层相当于沿着边权为 $y$ 的移动一轮，上升 $z$ 层相当于沿着边权为 $z$ 的移动一轮，移动的距离即到达的高度。

从 $0$ 出发跑最短路，设从 $0$ 出发到点 $i$ 的最短路为 $dis_i$。而 $dis_i$ 同时还是我们上面要求的 $\min_{v\in S,v\bmod x=i}v$！

确实很聪明的转化。
~~~cpp
#include <bits/extc++.h>
using namespace std;
namespace pbds = __gnu_pbds;
istream& fin = cin;
ostream& fout = cout;
using ui = unsigned int;
using uli = unsigned long long int;
using li = long long int;
vector<uli> dijkstra(size_t s, vector<vector<pair<size_t, uli>>> const& mp) {
  vector<uli> dis(mp.size(), numeric_limits<uli>::max() / 2);
  vector<bool> vis(mp.size());
  priority_queue<pair<uli, size_t>, vector<pair<uli, size_t>>,
                 greater<pair<uli, size_t>>>
      q;
  dis[s] = 0;
  q.emplace(0, s);
  while (!q.empty()) {
    size_t p = q.top().second;
    q.pop();
    if (vis[p]) continue;
    vis[p] = true;
    for (auto i : mp[p])
      if (dis[p] + i.second < dis[i.first])
        q.emplace(dis[i.first] = dis[p] + i.second, i.first);
  }
  return dis;
}
int main(void) {
  ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
  uli h;
  ui x, y, z;
  fin >> h >> x >> y >> z;
  --h;
  vector<vector<pair<size_t, uli>>> mp(x);
  for (size_t i = 0; i < x; ++i)
    mp[i].emplace_back((i + y) % x, y), mp[i].emplace_back((i + z) % x, z);
  auto dis = dijkstra(0, mp);
  uli ans = 0;
  for (size_t i = 0; i < x; ++i)
    if (dis[i] <= h) ans += (h - dis[i]) / x + 1;
  fout << ans;
  return 0;
}
~~~

---

## 作者：eternal (赞：5)

对高度进行一下Hash，可以有一部分分，如果强悍一点的话，动态开，有可能能够过掉，我在本机上试了下，大概需要5.0s。。。


考虑这样一种情况，记di = c , 表示在满足 c mod x = i 的前提下，仅通过第二和第三个操作能够到达的最小楼层c ， 如果我们算出了di ， 那么这个问题就解决了， 答案就是 (h - di) / x + 1 ( i : 0 ... x - 1 )



       d(i + y) mod x = di + y

       d(i + z) mod x = di + z

用spfa搞一下就可以了


---

## 作者：ZRZ0818 (赞：4)

**tip:** 若无特殊声明，以下出现变量均为**非负整数**。

## 简要题意：

给定一个整数 $h$，再给出三个整数 $x,y,z$，求在区间 $[1,h]$ 中可以由形如 $ax+by+cz$ 的式子所得到的不同数字的个数。


## 思路分析：

**方法 1**：考虑分别枚举 $a,b,c$ 的值，时间复杂度 $\mathcal{O} (h ^{3})$，无法接受。

**方法 2**：尝试优化暴力，考虑只枚举 $b,c$ 的值，那么 $a$ 的可能性我们就可以通过计算得出。  
考虑到会有 $a_1x+b_1y+c_1z = a_2x+b_2y+c_2z$ 这种重复情况，我们试着把等式两边减去若干个 $a$，那么必然会出现 $a_3x+b_1y+c_1y = b_2y+c_2z$ 这种情况，也就是说，$b_1y+c_1z$ 可以通过增加 $a_3$ 倍 $x$ 使得它与 $b_2y+c_2z$ 相等。

现在需要用到一些同余的思想，~~不会同余的同学可以先去补一下课~~。  
设 $d_1 =b_1y+c_1z,d_2 =b_2y+c_2z$，$d_1 \equiv e \pmod x $。  
则有 $kx+e=d_1$，所以 $d_2 =d_1+a_3x =(k+a_3)x +e$，显然 $d_2 \equiv e \pmod x$。  
所以 $d_1 \equiv d_2 \pmod x$，那么我们就可以开一个数组 $f$，$f_i$ 为 $\mod x$ 为 $i$ 的最小 $b_1y+c_1z$ 的值，则答案即为 $\sum_{i=0}^{x-1} \lfloor \frac {(h-1-f_i)}{x} \rfloor +1 $（$h-1$ 是因为题目中 $h$ 从1开始）。


时间复杂度 $\mathcal O(h^2)$，亲测可得 40pts。

## 正解想法：

我们的思路已经很接近正解了，接下来考虑优化暴力枚举 $b,c$ 的过程。

假设我们已经得到了最小的 $by+cz \equiv i \pmod x$，将 $by+cz$ 分别加上一个 $y,z$，就会得到 $(b+1)y+cz \equiv i+y \pmod x$ 和 $by+(c+1)z \equiv i+z \pmod x$。于是我们便将 $by+cz \equiv i \pmod x$ 分别花费了权值 $y,z$ 拓展了两种情况（$(i+y) \bmod x$ 和 $(i+z) \bmod x$）。

仔细一想，这种办法是不是跟最短路的松弛操作很类似——通过一定的代价将一个点转移到别的点，如果转移到的点已经被访问过了，取最小权值。

于是，我们可以效仿最短路的建边操作，由点 $i$ 到点 $(i+y) \bmod x$ 和 $(i+z) \bmod x$ 可以表示为：

$$
i \stackrel{y}{ \to } (i+y) \bmod x 
$$

$$
i \stackrel{z}{ \to} (i+z) \bmod x
$$

因此，只需循环 $x$ 次，每次给余数 $i$ 建两条边，记 $dis_i$ 表示 $\bmod x$ 余 $i$ 所需的 $y,z$ 总和最小值，特别地，$dis_0 =0$，再跑 Dijkstra 模板即可。

这就是同余最短路，时间复杂度 $\mathcal O(h 
\log h)$。

最后答案即为：

$$
\sum^{x-1}_{i=0} \lfloor \frac{h-1-dis_i}{x} \rfloor+1
$$

 _完整 code:_

 
```cpp
#include<bits/stdc++.h>
#define PR pair<int,int>
#define MAXN 100005
#define int long long
const int INF =(1ull <<63) -1;

using namespace std;
struct Edge{
	int to,w;
};
vector<Edge> g[MAXN];
priority_queue<PR,vector<PR>,greater<PR> > q;
int dis[MAXN];
bool vis[MAXN];

void Dijkstra( const int s,const int x) {
	for ( int i=0; i<x; i++) dis[i] =INF;
	q.push({0,s}),dis[s] =0;
	while ( !q.empty()) {
		int pos =q.top().second; q.pop();
		if ( vis[pos]) continue;
		vis[pos] =1;
		for ( auto &nex:g[pos]) {
			if ( dis[nex.to] >dis[pos] +nex.w) {
				dis[nex.to] =dis[pos] +nex.w;
				q.push({dis[nex.to],nex.to});
			}
		}
 	}
}

signed main() {
	ios::sync_with_stdio(false);
	
	int h,x,y,z;  cin >>h >>x >>y >>z;
	
	--h;
	for ( int i=0; i<x; i++) {
		g[i].push_back((Edge){(i+y) %x,y});
		g[i].push_back((Edge){(i+z) %x,z});
	}
	
	Dijkstra(0,x);
	
	int ans =0;
	for ( int i=0; i<x; i++) {
		if ( dis[i] <=h) {
			ans +=(h -dis[i])/x +1;
		}
	}
	cout <<ans;
	
	return 0;
}
```

---

## 作者：abc1856896 (赞：1)

同余最短路板子题。

通过同余构造类似于两点之间的带权有向边。那么可以建图，将问题转化为求最短路。

# Solution

首先暴力枚举或动态规划显然会爆。

首先有一个显然的性质：如果 $m$ 是可以用 $y$ 和 $z$ 的构造出来的，那么对于所有小于 $h$ 的 $m+kx(k \ge 0)$ 显然是合法的。

定义 $f_i$ 为合法的的最低的对 $x$ 取模结果为 $i$ 的数。

则有 $f_i +y \ge f_{(i+y) \bmod x}$ 且 $f_i+z \ge f_{i+z \bmod x}$。而这两个不等式满足最短路松弛的不等式。

那么就有 $i \to {i+y} \bmod x$ 和 $i \to {i+y} \bmod x$。建图跑迪杰斯塔拉即可。

注意实现的时候要先将高度减一。

# Code

```cpp
#include<bits/stdc++.h>
#define int long long
int head[2000005],cnt;
struct data{
	int to;
	int next;
	int w;
};
data edge[2000005];
void add_edge(int from,int to,int w) {
	cnt++;
	edge[cnt].to=to;
	edge[cnt].w=w;
	edge[cnt].next=head[from];
	head[from]=cnt;
}
int dis[1000005];
bool vis[1000005];
struct node{
	int dis;
	int pos;
	bool operator < (const node &x) const {
		return x.dis<dis;
	}
};
std::priority_queue<node> q;
void dijkstra(int s) {
	memset(dis,0x3f,sizeof(dis));
	dis[s]=0;
	q.push((node){0,s});
	while(!q.empty()) {
		node t=q.top();
		q.pop();
		int u=t.pos;
		if(vis[u]) continue;
		vis[u]=1;
		for(int i=head[u];i;i=edge[i].next) {
			int v=edge[i].to;
			if(dis[v]>dis[u]+edge[i].w) {
				dis[v]=dis[u]+edge[i].w;
				q.push((node){dis[v],v});
			}
		}
	}
}
int h,x,y,z,ans=0;
signed main() {
	std::cin>>h>>x>>y>>z;

//特判
	if(x==1 || y==1 || z==1) {
	    std::cout<<h;
	    return 0;
	}
	h--;
  //建图
	for(int i=0;i<x;i++) {
		add_edge(i,(i+z)%x,z);
		add_edge(i,(i+y)%x,y);
	}
	dijkstra(1);
	for(int i=0;i<x;i++) {
		if(h>=dis[i]) ans+=(h-dis[i])/x+1;
    //注意这个地方要多加一条判断
	}
	std::cout<<ans;
	return 0;
}
```

---

## 作者：Helloworldwuyuze (赞：0)

## P3403 跳楼机

### Des

你刚开始处于 $1$，且你有四种操作，分别是 $l\leftarrow l+x$，$l\leftarrow l+y$，$l\leftarrow l+z$，$l\leftarrow 1$。问最后你能到达到小于等于 $h$ 的位置有多少个。

### Sol

~~没想到同余最短路这么典的 `trick` 的板子竟然还能写题解~~。

首先，这显然是一个完全背包问题。我们可以设 $f_i$ 表示 $i$ 可达或不可达。那么有转移：
$$
f_j = f_j\vee f_{j-a_i}
$$
对于 $y$ 与 $z$ 同理。

这样可以使用二进制分解 + `bitset` 优化到 $O(\frac{nV\log V}{w})$，总之过不了。

怎么办呢，我们考虑如果 $i$ 可达，那么对于所有的 $i + kx$ 都是可达的。因此我们只需要求出来最早什么时候可以到达模 $x$ 等于 $i$ 的点即可。

于是问题规模被我们缩到了 $O(x)$ 的范围，而这是可以接受的。考虑怎么继续处理。我们发现，在 $\bmod x$ 的意义下，原来的三条转移也是成立的，只不过这时候为了知道到达这一个 $i$ 的具体楼层，我们需要为每一条边加一个权值表示向上走 $w$ 才能到达下一个点。也就是说，有有向边：
$$
\begin{cases}
l\to l+y\pmod x\\
l\to l+z\pmod x
\end{cases}
$$
于是跑最短路即可。

对于一个 $i$，如果 $d_i\le h$ 即可贡献 $\left\lfloor\frac{h}{d_i}\right\rfloor+1$ 即可。

```cpp
#define int unsigned long long
const int INF = 0x3f3f3f3f;
typedef pair<int,int> PII;
typedef pair<int,PII> PIII;
const int N = 5e5 + 10;
const int H = 32;
inline int min(int x,int y){ return x < y ? x : y; }
inline int max(int x,int y){ return x < y ? y : x; }

int n, l, r, a[N], ans, m = INF;
vector<PII> g[N];

int dis[N], vis[N];
priority_queue<PII, vector<PII>, greater<PII> > q;
void dijkstra(){
	memset(dis, 0x3f, sizeof(dis));
	dis[0] = 0, q.push(mk(dis[0], 0));
	while(q.size()){
		int x = q.top().se; q.pop();
		if(vis[x])	continue;
		vis[x] = true;
		for(auto y : g[x])
			if(dis[y.fi] > dis[x] + y.se){
				dis[y.fi] = dis[x] + y.se;
				q.push(mk(dis[y.fi], y.fi));
			}
	}
}
int solve(int x){
	int ans = 0;
	for(int i=0;i<m;++i)
		if(dis[i] <= x)	ans += (x - dis[i])/m + 1;
	return ans;
}

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cin>>r>>a[1]>>a[2]>>a[3]; n = 3; m = a[1]; --r;
	for(int i=0;i<m;++i)
		for(int j=2;j<=n;++j)
			g[i].pb(mk((i + a[j]) % m, a[j]));
	dijkstra();
	cout<<solve(r)<<endl;
	return 0;
}
```

---

## 作者：sad_lin (赞：0)

### [【同余最短路模板】P3403 跳楼机](https://www.luogu.com.cn/problem/P3403)

本题可以抽象为如下问题：
> 给定四个正整数 $x,y,z,H$，求有多少个整数 $d \in [1,H]$ 满足 $ax+by+cz=d$，其中 $a,b,c$ 都是非负整数。

我们定义 $k=by+cz$，而这个 $k$ 有特殊的性质就是 $k\equiv{k+x}\equiv{k+2x}\equiv{\cdots }\equiv{k+ax} \pmod x$，而且一定有 $k \in [0,x-1]$，也就是说我们知道了一个 $k$ 且 $k$ 合法的话我们就可以一直加 $x$ 直到超过 $H$ 限制。

**当然如果 $k$ 互不相同那 $k+x$ 也互不相同。**

![image](https://cdn.luogu.com.cn/upload/image_hosting/9lz43xox.png)

所以我们有 $dis_i$ 为使得 $k\bmod x=i$ 的**最低层数**（层数越低可加的 $x$ 就越多），然后我们将 $[0,x-1]$ 每个点都视为一个**单独的节点**，我们进行以下建边方式：

- $i$ 向 $(i+y)\bmod x$ 建一条权值为 $y$ 的有向边。

- $i$ 向 $(i+z)\bmod x$ 建一条权值为 $z$ 的有向边。

明显的 $dis_0$ 一定为 $0$，所以我们以这个点为起点**跑最短路**得到每个点的 $dis_i$。

因为我们的点的范围为 $[0,x-1]$ 所以要将 $H-1$ 使得起始楼层为 $0$。

楼层的最大限制为 $h$，那你从 $k$ 通过加 $x$ 最多可以加 $\lfloor \frac{h-dis_i}{x} \rfloor+1$ 个 $x$（**加一是因为 $x$ 的系数可以为 $0$**）。

那么最后的答案就是：

$$\sum_{i=0}^{x-1} \lfloor \frac{h-dis_i}{x} \rfloor+1$$

代码部分：

```cpp
#include <bits/stdc++.h>
#define int long long
const int N=1e6;
const int inf=1e16;
using namespace std;

int head[N];
int cnt=1;
struct ss{
	int v,next,w;
}e[N<<1];
void add(int u,int v,int w){
	e[++cnt].v=v;
	e[cnt].w=w;
	e[cnt].next=head[u];
	head[u]=cnt;
}

int h,x,y,z;

int vis[N];
int dis[N];
queue<int> q;

void spfa(int s){
	dis[s]=0;
	vis[s]=1;
	q.push(s);
	while(!q.empty()){
		int x=q.front();
		q.pop();
		vis[x]=0;
		for(int i=head[x];i;i=e[i].next){
			int y=e[i].v;
			if(dis[y]>dis[x]+e[i].w){
				dis[y]=dis[x]+e[i].w;
				if(!vis[y]){
					q.push(y);
				}
			}
		}
	}
}

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr); 
	
	cin>>h>>x>>y>>z;
	h--;
	for(int i=0;i<x;i++){
		dis[i]=inf;
		add(i,(i+y)%x,y);
		add(i,(i+z)%x,z);
	}
	spfa(0);
	int ans=0;
	for(int i=0;i<x;i++){
		if(dis[i]<=h&&dis[i]!=inf){
			ans+=(h-dis[i])/x+1;
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：C_Pos_Princess (赞：0)

## 题目模型——同余最短路
- 给定 $n$ 个整数，求这 $n$ 个整数能拼凑出多少的其他整数（$n$ 个整数可以重复取）。
- 给定 $n$ 个整数，求这 $n$个整数不能拼凑出的最小（最大）的整数,或者至少要拼几次才能拼出模 $K$ 余 $p$ 的数。

## 核心 / 模型
其实就是找准一个标准数 $x$，以他的完全剩余系为最短路中的点，看能不能到达。

考虑 $dis$ 数组的意义来找答案。

$dis_i$ 表示模 $x$ 等于 $i$ 的最小的可以表示出来的数。


### 例题一 [P3403 跳楼机](https://www.luogu.com.cn/problem/P3403)

#### 题意
给定 $x,y,z,h$ ，对于 $k\in [1,h]$ ,有多少个 $k$ 满足 $ax + by + cz = k$。

我们选择 $a$ 作为基准数，也就是模数，$dis_i$ 表示模 $x$ 余 $i$ 的数中所能表示出来的数的最小的那个。

#### 代码
```
ll H;
ll x,y,z;
int e[N],ne[N],h[N],w[N],cnt;
void add(ll a,ll b,ll c){
	e[++cnt] = b;
	ne[cnt] = h[a];
	h[a] = cnt;
	w[cnt] = c;
}

ll dis[N];
queue<int> q;
bool vis[N];
void spfa(){
	dis[0] = 0;
	vis[0] = 1;
	q.push(0);
	while(!q.empty()){
		int u = q.front();
		q.pop();
		vis[u] = 0;
		for(int i = h[u];~i;i= ne[i]){
			int j = e[i];
			if(dis[j]>dis[u]+w[i]){
				dis[j] = dis[u]+w[i];
				if(!vis[j]){
					q.push(j);
					vis[j] = 1;
				}
			}
		}
	}
	
}
int main(){
	read(H);
	read(x,y,z);
	memset(h,-1,sizeof h); 
	if(x == 1 && y == 1 && z == 1){
		write(H);
		return 0; 
	}
	H--;
	
	for(int i = 0;i<x;i++){
		add(i,(i+z)%x,z);
		add(i,(i+y)%x,y);
		dis[i] =linf;
	}
	spfa();
	ll ans = 0;
	for(int i = 0;i<x;i++){
		if(H>=dis[i]) ans+=(H-dis[i])/x+1;
	}
	write(ans);
	
	return 0;
}
```

---

## 作者：Cells (赞：0)

### 写在前面

感谢 [MrPython](https://www.luogu.com.cn/user/679581) 大佬的思路。

### 题目大意

对于给定 $x, y, z, h$，对于 $k \in [1, h]$，有多少个不同的 $k$ 满足 $ax + by + cz = k$。（$0 \leq a, b, c$）

### 思路

将 $h$ 减一方便后续的处理。

首先，如果 $a \equiv b\pmod x$，并且 $a \leq b$，那么 $a$ 一定可以通过加若干个 $x$ 变成 $b$。

令使用若干 $y$ 和若干 $z$ 能够拼凑成的集合为 $S$，那么 $S$ 中任意元素 $val$，$val + kx$（$0 \leq k, val + kx \leq h$）都可以成为答案，那么 $k$ 有：

$$
\left \lfloor \frac{h - val}{x} \right \rfloor + 1
$$

个。

但我们仔细想想，在模 $x$ 意义下同余的两个数必定会被重复统计，怎么去重呢？

比较显然的是，我们对任意 $0 \le i < x$ 都用集合 $S$ 中最小的模 $x$ 为 $i$ 的数去统计答案，就可以做到不重不漏，因为其他同余的数都可以通过在最小值基础上加 $x$ 的方式被统计到。

怎么找最小值呢？

我们选择把他转化成[**同余最短路**](https://oi-wiki.org//graph/mod-shortest-path/)问题，从余数 $i$ 分别向 $(i + y) \% x$ 和 $(i + z) \% x$ 建一条边长为 $y$ 和 $z$ 的边，相当于从这里再上升 $y$ 层和 $z$ 层，那么从 $0$ 开始跑最短路（不选 $y$ 和 $z$ 模 $x$ 就是 0，所以余数 $0$ 的最小值就是 $0$），到点 $i$ 的最短路 $dis_i$ 不就是最小值吗？

统计答案即可。

### Code

```c++
# include <bits/stdc++.h>
# define int ULL
# define sec second
# define rep(i, a, b) for(int i = (a); i <= (b); ++ i)
using namespace std;

using ULL = unsigned long long;

using LL = long long;
using PII = pair<int, int>;

const LL INF = LLONG_MAX;

const int N = 1e5 + 10, M = N << 1;

int idx;
int h[N];

ULL high, x, y, z, ans;
ULL dis[N];
LL e[M], w[M], ne[M];

bitset<N> vis;

void add(int a, int b, int c){
	e[++ idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx;
}

void SPFA(int s){//我喜欢SPFA所以把dijkstra换成SPFA了 
	rep(i, 0, x - 1) dis[i] = INF;
	dis[0] = 0;
	
	vis.reset();
	
	priority_queue<PII, vector<PII>, greater<PII> > heap;
	heap.push({0, s});
	
	while(!heap.empty()){
		int u = heap.top().sec;
		heap.pop();
		
		if(vis[u]) continue;
		vis[u] = true;
		
		for(int i = h[u]; i; i = ne[i]){
			int v = e[i];
			
			if(vis[v] || dis[v] <= dis[u] + w[i]) continue;
			
			dis[v] = dis[u] + w[i];
			heap.push({dis[v], v});
		}
	}
}

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	cin >> high >> x >> y >> z;
	high --;
	
	rep(i, 0, x - 1){
		add(i, (i + y) % x, y);//建边 
		add(i, (i + z) % x, z);
	}
	
	SPFA(0);//从0开始 
	
	rep(i, 0, x - 1){
		if(dis[i] <= high) ans += (high - dis[i]) / x + 1;//必须要符合条件才能计算 
	}
	
	cout << ans;
	
	return 0;
}
```

当然你也可以不建边，直接现场处理出来。

```c++
# include <bits/stdc++.h>
# define int ULL
# define sec second
# define rep(i, a, b) for(int i = (a); i <= (b); ++ i)
using namespace std;

using ULL = unsigned long long;

using LL = long long;
using PII = pair<int, int>;

const LL INF = LLONG_MAX;

const int N = 1e5 + 10, M = N << 1;

int idx;
int h[N];

ULL high, x, y, z, ans;
ULL dis[N];

bitset<N> vis;

void SPFA(int s){//我喜欢SPFA所以把dijkstra换成SPFA了 
	rep(i, 0, x - 1) dis[i] = INF;
	dis[0] = 0;
	
	vis.reset();
	
	priority_queue<PII, vector<PII>, greater<PII> > heap;
	heap.push({0, s});
	
	while(!heap.empty()){
		int u = heap.top().sec;
		heap.pop();
		
		if(vis[u]) continue;
		vis[u] = true;
		
		int v, w;
		v = (u + y) % x, w = y;
		
		if(!vis[v] && dis[v] > dis[u] + w){
			dis[v] = dis[u] + w;
			heap.push({dis[v], v});
		}
		
		v = (u + z) % x, w = z;
		
		if(!vis[v] && dis[v] > dis[u] + w){
			dis[v] = dis[u] + w;
			heap.push({dis[v], v});
		}
	}
}

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	cin >> high >> x >> y >> z;
	high --;
	
	SPFA(0);//从0开始 
	
	rep(i, 0, x - 1){
		if(dis[i] <= high) ans += (high - dis[i]) / x + 1;//必须要符合条件才能计算 
	}
	
	cout << ans;
	
	return 0;
}
```

建议大家写不建边的版本，因为后面有些同余最短路的问题因为空间问题无法建边，例如 [P8060 \[POI2003\] Sums](https://www.luogu.com.cn/problem/P8060)。

今天的题解就到这里，谢谢大家！！！

---


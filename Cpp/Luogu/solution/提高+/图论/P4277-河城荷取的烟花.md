# 河城荷取的烟花

## 题目背景

#宴会已经接近尾声
![](https://cdn.luogu.com.cn/upload/pic/15119.png)

## 题目描述

快乐的时光总是这么短暂，这场宴会终究将要闭幕。

为了给大家留下一个深刻而美好的印象，萃香拜托掌握着顶尖科技的河城荷取用她刚刚研制出的装置来点燃烟花。

这个装置由3部分构成——一些长度为1的绳子，一些长度为$\sqrt{ 2 }$的绳子，还有一块不能燃烧的木板。河城荷取将木板划分成长度为 1 的单元格，并标上坐标，之后将这些绳子摆在木板上连接成一个连通图(即绳子上的任意两点均可互相到达)。注意，这些绳子的两端必须放在单元格的顶点上，即长度为 1 的绳子只能放在单元格的某一边上，长度为$\sqrt{ 2 }$的绳子只能放在单元格的某一对角线上。

现在，河城荷取会在木板上任意一根绳子的端点处点火(不能从绳子的中间处点火)，点火后，火会沿着绳子向前燃烧（每根绳子都有自己的燃烧速度），并能点燃与它相接的其它绳子。

比如说下面这张图，河城荷取不能在 A 点点火，但在 C 点或 B点点火都是充许的。

![](https://cdn.luogu.com.cn/upload/pic/15120.png)

为了演出效果，河城荷取必须保证所有绳子都燃烧完的总时间最短，可是由于绳子的条数过多，所以河城荷取找到了你来帮忙，让你帮她求出最短的总时间是多少。

如果你能完成这个任务，你就会获得两个奖励——100分和观赏一场盛大的烟花盛宴！


## 说明/提示

【样例一解释】:从任一端点火都行，燃烧时间都是 1

【样例二解释】:

在 (0,0)位置点火，绳子 1, 3 和 4 将被点燃，燃烧 0.5 分钟后，绳子 2 将被从中间点燃向两端燃烧，再过 0.5 分钟，绳子 1, 3, 4 将被完全燃烧，绳子5将被点燃并在 1分钟后燃烧完 (比绳子 2 早燃完)。

绳子 2 从中间向两端燃烧 0.5 分钟以后，变成两小段，每段的燃烧时间是 4.5
分钟。但因为此时两小段绳子的另一端也同时被点燃，燃烧速度变成原来的
两倍，还需 2.25 分钟的燃烧时间， 所以总时间： 1 + 2.25 = 3.25

【数据范围】:

![](https://cdn.luogu.com.cn/upload/pic/15213.png)

## 样例 #1

### 输入

```
1
0 0 1 1 1```

### 输出

```
1.0000```

## 样例 #2

### 输入

```
5
0 0 0 1 1
1 0 0 1 10
0 0 1 0 1
0 0 1 1 1
2 2 1 1 1```

### 输出

```
3.2500```

# 题解

## 作者：Ireliaღ (赞：26)

## 一些前言

这道题对于我们机房有着里程碑一样的意义，因为它让我们最能抄题解最菜的那只当场退役。

那次是高一NOIP之后不久的一次模拟赛，考了三道题，这个是T3，考完之后大部分人前两题拿了大部分分，T3爆零，那兄弟前两题爆零，T3切了，后来教练发现是copy的Solution，他就退役了。

（本来想放个我们学校OJ的截图，但是他被我们教练从OJ里踢了，表格里没有他了。

## 解题思路

考虑把大的问题逐步分解

首先我们整体解题框架就是枚举所有可以点燃的点作为方案，对于每一个方案，算出所有绳子被燃尽的时间的最大值，求出这些最大值的最小值就是答案。

那么当我们确定了点燃点时，如何确定每根绳子被燃尽的时间？

为了方便存储，我们把一根绳子从中间折半分成两根存储。我们以拆完后所有的绳子端点为节点，以每根绳子燃烧时间为边权建图。显然，从$s$点燃的话，每一个节点$i$被燃到的时间点就是$s$开始的单源最短路。这样，我们就求出了所有端点的被点燃的时间。

已知绳子两端点的点燃时间和燃烧速度，如何求出绳子燃尽时间？显然是小学相遇问题，大家都会推。

这样这个问题就被完美解决了。

## 程序实现

这道题的思路很巧，并且程序实现细节较多，大家可以看代码注释。

```cpp
#include <iostream>
#include <cstdio>
#include <iomanip>
#include <cstring>
//防CE+防抄袭 
#define x1 partychicken
#define x2 vcode
#define y1 ubospica
#define y2 greygoods

using namespace std;
const int MAXN = 2005;
const double EPS = 1e-6;
const double INF = 1e9;

int n, m;
int id[4005][4005];//如果坐标(i, j)是绳子端点，那么建的图中的节点为id[i][j] 
int cant[MAXN];//绳子折半后中间点不能作为开始点，在这标一下 
int to[MAXN], nxt[MAXN], head[MAXN], ecnt;
double val[MAXN], dis[MAXN];
int lid[MAXN], rid[MAXN], tot;//每根绳子两端点对应图中的节点编号 
double v[MAXN];//每根绳子燃烧速度 
double ans;

void Add(int u, int v, double w) {
	to[++ecnt] = v; val[ecnt] = w; nxt[ecnt] = head[u]; head[u] = ecnt;
	to[++ecnt] = u; val[ecnt] = w; nxt[ecnt] = head[v]; head[v] = ecnt;
//	cerr << u << ' ' << v << ' ' << w << '\n';
}

void SetStick(int x1, int y1, int x2, int y2, double len) {
	x1 <<= 1; x1 += 2001;//为了便于计算，把坐标调整调正 
	y1 <<= 1; y1 += 2001;
	x2 <<= 1; x2 += 2001;
	y2 <<= 1; y2 += 2001;
	int x3 = (x1 + x2 >> 1), y3 = (y1 + y2 >> 1);//中间点 
	if (!id[x1][y1]) id[x1][y1] = ++n;//在图中建出节点 
	if (!id[x2][y2]) id[x2][y2] = ++n;
	if (!id[x3][y3]) id[x3][y3] = ++n;
	cant[id[x3][y3]] = 1;//中间点不能点燃 
	Add(id[x1][y1], id[x3][y3], len / 2.0);
	Add(id[x3][y3], id[x2][y2], len / 2.0);
	lid[++tot] = id[x1][y1]; rid[tot] = id[x3][y3]; v[tot] = 1.0 / len;//记录每条边的信息 
	lid[++tot] = id[x3][y3]; rid[tot] = id[x2][y2]; v[tot] = 1.0 / len;
}

int q[MAXN], ql, qr;
int vis[MAXN];

void SPFA(int s) {//单源最短路 
	for (int i = 1; i <= n; i++) dis[i] = INF; dis[s] = 0;
	ql = qr = 1; q[1] = s;
	memset(vis, 0, sizeof(vis)); vis[s] = 1;
	while (ql <= qr) {
		int u = q[ql++ % n]; vis[u] = 0;
		for (int i = head[u]; i; i = nxt[i]) {
			int v = to[i];
			if (dis[v] - dis[u] > val[i] + EPS) {
				dis[v] = dis[u] + val[i];
				if (!vis[v]) {
					vis[v] = 1;
					q[++qr % n] = v;
				}
			}
		}
	}
//	cerr << '*';
//	for (int i = 1; i <= n; i++) cerr << dis[i] << ' ';
//	cerr << '\n';
}

double EndTime(int sid) {//相遇问题，计算绳子被燃尽的时间 
	double t1 = dis[lid[sid]], t2 = dis[rid[sid]], V = v[sid];
	if (t1 - t2 > EPS) swap(t1, t2);
	if (t2 - t1 > 0.5 / V) return t1 + 0.5 / V;
	double res1 = t2;
	double res2 = (0.5 - V * (t2 - t1)) / (V * 2.0);
	return res1 + res2;
}

void Cal(int s) {//计算从节点s点燃，所有绳子被燃尽的时间 
	SPFA(s);
	double res = 0;
	for (int i = 1; i <= tot; i++) res = max(res, EndTime(i));
	ans = min(ans, res);//更新总答案 
}

int main() {
	cin >> m;
	for (int i = 1; i <= m; i++) {
		int x1, y1, x2, y2; double t;
		cin >> x1 >> y1 >> x2 >> y2 >> t;
		SetStick(x1, y1, x2, y2, t);
	}
	ans = INF;
	for (int i = 1; i <= n; i++) {//枚举点燃点 
		if (cant[i]) continue;
		Cal(i);
	}
	cout << fixed << setprecision(4) << ans << '\n';
	return 0;
}
```

---

## 作者：Wy12121212 (赞：12)

# 萃香的新年宴会第三题题解#3河城荷取的烟花
## by Wy12121212

[题目链接](https://www.luogu.org/problemnew/show/P4279)

## 这题能被dfs卡过的说，但是这里只介绍std做法，如果想了解dfs做法可以@oscar 大爷

题意:坐标系上有很多绳子，长度不是1就是$\sqrt 2$,且这些绳子的端点都在格子上，保证绳子不重合且联通，现在让你从一点点燃绳子使燃烧尽的总时间最短。请你输出最短的燃烧时间。

**本题做题难度:** 提高

**本题思考难度:** 提高

**考查知识点:**图论，最短路

**首先我们要知道这些要点：**

1、绳子可能相交，因此绳子可以能从中间被点燃。

2、绳子可能从两边被点燃，直至燃尽。然而两侧的点燃时间可能不相同，也就是说，不一定会在绳子的中间燃尽。

然后，显然从(i,j)点燃后燃到(x,y)处的时间t即为node[i,j]->node[x,y]的最短距离，所以我们以绳子的端点为顶点建一个无向图(如果有两根绳子相交就把交点push进去)。之后跑一遍floyd求出任意两点间的最短路径即燃烧到这个点的时间。

那么我们可以枚举每个点作为起点st,稍作观察，我们可以得到一个公式，设绳子L两个端点分别为A、B，则L的燃尽时间为

**  (time[L]+|dis[st][B]-dis[st][A]|)/2+min(time[A],time[B])**
  
所以我们求出所有的起火点中max(time[1-n])最小的值就可以了，怎么样，是不是很水啊qwq

然后这里是std：

```cpp
#include<cstdio>
#include<map>
#include<cmath>
#include<queue>
#include<iostream>
#include<cstring>
#include<cstdlib>
#define x first
#define y second
using namespace std;
struct B
{
    int f,t;
    double d;
}b[20000];
pair<double,double> a[10000];
map <pair<double,double>,int>id;
int m,n,st[10500];
double dis[3000][3000],ans,sum,arr[10500];
int ee;
int main()
{
    //freopen("firework.in","r",stdin);
    //freopen("firework.out","w",stdout);
    scanf("%d",&m);
    for (int i=1;i<=m;i++)
    {
        pair<double,double> u,v;
        int f,t;
        double d;
        scanf("%lf%lf%lf%lf%lf",&u.x,&u.y,&v.x,&v.y,&d);
        sum+=d;
        if (!id.count(u)) id[u]=++n,a[n]=u,st[n]=1;
        if (!id.count(v)) id[v]=++n,a[n]=v,st[n]=1;
        f=id[u],t=id[v];
        if (u.x!=v.x&&u.y!=v.y)
        {
            double xx=(u.x+v.x)/2.0,yy=(u.y+v.y)/2.0;
            pair<double,double> mid=pair<double,double>(xx,yy);
            if (!id.count(mid)) id[mid]=++n,a[n]=mid;
            int md=id[mid];
            /*addedge(f,md,d/2.0);
            addedge(md,f,d/2.0);
            addedge(md,t,d/2.0);
            addedge(t,md,d/2.0);*/
            dis[f][md]=dis[md][f]=dis[md][t]=dis[t][md]=d/2.0;
            //fff[f][md]=fff[md][f]=fff[md][t]=fff[t][md]=1;
            b[++ee].f=f,b[ee].t=md,b[ee].d=d/2.0;
            b[++ee].f=md,b[ee].t=t,b[ee].d=d/2.0;
        }
        else b[++ee].f=f,b[ee].t=t,b[ee].d=d;
        //fff[f][t]=fff[t][f]=1;
        //addedge(f,t,d);
        //addedge(t,f,d);
        dis[f][t]=dis[t][f]=d;
    }
    ans=sum;
    //for(int i=1;i<=n;i++)spfa(i);
    for (int k=1;k<=n;k++)
        for (int i=1;i<=n;i++)
            for (int j=1;j<=n;j++)
                if (dis[i][k]&&dis[k][j]&&(dis[i][j]==0||dis[i][j]>dis[i][k]+dis[k][j]))
                    dis[i][j]=dis[i][k]+dis[k][j];
    for (int i=1;i<=n;i++)
        if (st[i])
        {
            double timm=0,tim;
            for (int j=1;j<=ee;j++)
            {
                if (dis[i][b[j].f]<dis[i][b[j].t])tim=dis[i][b[j].t]+(b[j].d-dis[i][b[j].t]+dis[i][b[j].f])/2;
                else tim=dis[i][b[j].f]+(b[j].d-dis[i][b[j].f]+dis[i][b[j].t])/2;
                timm=max(timm,tim);
            }
            if (ans==0||ans>timm) ans=timm;
        }
    printf("%.4lf\n",ans);
    return 0; 
}
```

如果你有任何问题，请加入**我的团队**发帖提问或者加我的qq，私信我可能看不见



---

## 作者：XSZCaesar (赞：5)

## 关于P4277 【河城荷取的烟花】的题解

学校的一场考试：

[点进去你也无法登陆的传送门](http://www.accoders.com/contest.php?cid=1771)

技能比拼，分组方案，勇士的篝火

1.国王要嫁女儿啦！OI村庄里的勇士们都想去试试，但是~~(不好的事都叫但是)~~......

2.经过OI村子里的内部选拔，很多勇士都获得了村长的青睐，村长为了......

3.OI村庄的勇士如愿娶了国王女儿，村长打算......

讲了~~由村长暗箱操作使一群OIER~~勇士娶~~一位~~公主的故事

~~由情节就能看出数据水的一批~~

【河城荷取的烟花】的情节就美了很多

T3中出现了一个美观~~扭曲~~的图片：

![](https://cdn.luogu.com.cn/upload/pic/15120.png)

题意：

现需燃尽一摊奇怪的绳子（学校里是木棍，差不多），要找一个整点点火，使得燃尽时间最短

### 要明白火的（此题中）特性：

- 点燃后，火会沿着木棍向前方燃烧，可以点燃与它相接的木棍
- 只能在木棍的两端点燃。

下面是一些~~没多大用处的~~话：



------------


知识点：构图+最短路应用

在此题中是一个连通图，如果我们直接构图处理比较复杂~~根本不会~~。

我们对原问题进行转换:

由于绳&棍与绳&棍之间只能在绳&棍的两端或中间相交。我们把每根绳&棍拆分成两根相等的小绳&棍，这样，绳&棍的数量增加了一倍。

原问题就转化为，绳&棍与绳&棍之间只能在绳&棍的两端相交，这样处理起来就比较方便。

我们以绳&棍为边，绳&棍与绳&棍之间的交点为顶点，构建一个连通图，问题变为寻找一个合适的顶点，使得点燃以后完全燃烧的时间最短。


------------

有用的：

- 一个绳&棍可拆成两截小的绳&棍

- 很显然~~（“显然”是没有原因的）~~，燃烧时间等于点燃的顶点到图中最远点的时间，如下图:

![](https://cdn.luogu.com.cn/upload/pic/46628.png)



------------


由上述，需求最短路：

于是我们~~怎么会有我~~可以利用Floyd's算法求出任意两点间的最短距离

余下还需检查每一条&根 绳&棍是否燃尽

当然，如果没有完全燃烧，应求出剩余边燃烧所需最长时间

一些有~~（有？）~~用的话：

------------

对于燃烧时间为L的木棍，它的两端被点燃的时刻为T1和T2

如果T1 = T2+L 或者是 T2 = T1+L,那么燃烧到T1 和 T2 的最大时刻，这根木棍己经完全燃烧 

如果T1与T2之间的时间差不等于L，那么就说明火是从不同的路径燃烧到这根木棍的两端。火将从两端向中间燃烧，并在木棍内的某个点燃完

在简单情况中，如果是从两端同时点燃，燃烧时间为L/2。

更一般地，如果T1与T2不等，我们设一端是从0时刻点燃，另一端是从T时刻点燃，那么这根木棍的燃烧时间为

#### T + (L-（T-0）)/2. 

即，一端先燃烧T时间后，另一端才开始燃烧，完全燃烧后的时间为

#### （L-(T-0)）/2.

------------

## Floyd's :

------------

```cpp
#include<bits/stdc++.h>

using namespace std;

double max(double a,double b)
{
	if(a>b)return a;
	else return b;
}
double min(double a,double b)
{
	if(a<b)return a;
	else return b;
}
int n;
int a1,a2,b1,b2,a1_5,b1_5,a[10001][10001];
double t;
double e[3001][3001],dis[3001][3001];
int tot=0;
bool mid[3001];
double minx=0x7fffffff,maxx=-0x7fffffff;
int main()
{
	memset(dis,0x7fffffff,sizeof(dis));
	memset(e,0x7fffffff,sizeof(e));
	memset(mid,false,sizeof(mid));
	scanf("%d",&n);
	for(register int i=1;i<=n;i++)
	{
		scanf("%d%d%d%d%lf",&a1,&b1,&a2,&b2,&t);
		a1=a1*2+400,b1=b1*2+400,a2=a2*2+400,b2=b2*2+400;
		a1_5=(a1+a2)/2;
		b1_5=(b1+b2)/2;
		if(!a[a1][b1])a[a1][b1]=++tot;
		if(!a[a2][b2])a[a2][b2]=++tot;
		if(!a[a1_5][b1_5])
		{
			a[a1_5][b1_5]=++tot;
			mid[tot]=true;
		}
		e[a[a1][b1]][a[a1_5][b1_5]]=t*1.00000/2;
		e[a[a1_5][b1_5]][a[a1][b1]]=t*1.00000/2;
		e[a[a2][b2]][a[a1_5][b1_5]]=t*1.00000/2;
		e[a[a1_5][b1_5]][a[a2][b2]]=t*1.00000/2;
		dis[a[a1][b1]][a[a1_5][b1_5]]=t*1.00000/2;
		dis[a[a1_5][b1_5]][a[a1][b1]]=t*1.00000/2;
		dis[a[a2][b2]][a[a1_5][b1_5]]=t*1.00000/2;
		dis[a[a1_5][b1_5]][a[a2][b2]]=t*1.00000/2;
	}
	for(register int k=1;k<=tot;k++)
	{
		for(register int i=1;i<=tot;i++)
		{
			for(register int j=1;j<=tot;j++)
			{
				if(dis[i][k]<0x7fffffff&&dis[k][j]<0x7fffffff)
				{
					dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
				}
			}
		}
	}
	for(register int k=1;k<=tot;k++)
	{
		if(mid[k])continue;
		maxx=-0x7ffffff;
		for(register int i=1;i<=tot;i++)maxx=max(maxx,dis[k][i]);
		for(register int i=1;i<=tot;i++)
		{
			for(register int j=1;j<=tot;j++)
			{
				if(dis[k][i]<e[i][j]+dis[k][j]&&dis[k][j]<dis[k][i]+dis[i][j])
				{
					maxx=max(maxx,max(dis[k][i],dis[k][j])+(e[i][j]-max(dis[k][i],dis[k][j])+min(dis[k][i],dis[k][j]))/2.0);
				}
				
			}
		}
		minx=min(minx,maxx);
	}
	printf("%.4lf",minx);
	return 0;
}
```

------------

其实，只要不直接抄题解，Ctrl+c & Ctrl+v 挺好的

但是~~（前面说过“但是”不是一个很好的词）~~上面这段代码交上洛谷不可能对

上代码是针对我校OJ的题，数据水的一批,截取:

------------

【数据范围】

100%的数据：

1<=n<=40;

|a|,|b|,|c|,|d|≤200, 0≤t≤1e7;

------------

运用邻接矩阵等知识点，10分不错了

![](https://cdn.luogu.com.cn/upload/pic/46636.png)

做最短路方法太多了，例如SPFA，中国算法当然要用~~（模板好套）~~

有了前面代码的基础当然好写

奉上：



------------

```cpp
#include<bits/stdc++.h>

using namespace std;

double max(double a,double b)
{
	if(a>b)return a;
	else return b;
}
double min(double a,double b)
{
	if(a<b)return a;
	else return b;
}
struct node
{
	int from,to;
	double val;
	int nxt;
	node(int from=0,int to=0,double val=0,int nxt=0):from(from),to(to),val(val),nxt(nxt){};
};
int n,tot=0,len=0;
double val;
int a1,a2,b1,b2,am,bm;
int f[10000];
node edge[20000];
int head[10000],a[4000][4000];
double dis[10000];
bool vis[10000];
double ans=0x7fffffff;
void add(int from,int to,double val)
{
    edge[++len]=node(from,to,val,head[from]);
	head[from]=len;
}
int Num(int x,int y)
{ 
    if(!a[x][y])a[x][y]=++tot; 
	return a[x][y]; 
}
void SPFA(int s)
{
    deque<int> q;
	memset(vis,0,sizeof(vis));
	memset(dis,127,sizeof(dis));
	dis[s]=0;
	q.push_front(s);
	vis[s]=1;
	while(!q.empty())
	{
	    int cur=q.front();
		q.pop_front();
		vis[cur]=0;
		for(register int i=head[cur];i;i=edge[i].nxt)
		{
		    int id=edge[i].to;
			if(dis[id]>dis[cur]+edge[i].val)
			{
			    dis[id]=dis[cur]+edge[i].val;
				if(!vis[id])
				{
				    vis[id]=true;
					if(q.empty())q.push_front(id);
					else
					{
					    if(dis[id]<dis[q.front()])q.push_front(id);
						else q.push_back(id);
					}
				}
			}
		}
	}
}
double calculate(int x)
{
    double s=max(dis[edge[x].from],dis[edge[x].to]);
	s+=(edge[x].val-abs(dis[edge[x].from]-dis[edge[x].to]))/2;
	return s;
}
double check(int x)
{
    SPFA(x);
    double ans=0;
    for(register int i=1;i<=len;i+=2)ans=max(ans,calculate(i));
    return ans;
}
int main()
{
	scanf("%d",&n);
	for(register int i=1;i<=n;i++)
	{
        scanf("%d%d%d%d",&a1,&b1,&a2,&b2);
        a1=a1*2+2000,a2=a2*2+2000,b1=b1*2+2000,b2=b2*2+2000;
        am=(a1+a2)/2,bm=(b1+b2)/2;
		scanf("%lf",&val);
		val/=2;
        add(Num(a1,b1),Num(am,bm),val);
		add(Num(am,bm),Num(a1,b1),val);
		add(Num(a2,b2),Num(am,bm),val);
		add(Num(am,bm),Num(a2,b2),val);
		f[Num(a1,b1)]=1;
		f[Num(a2,b2)]=1;
	}
	for(register int i=1;i<=tot;i++)if(f[i])ans=min(check(i),ans);
	printf("%.4lf",ans);
	return 0;
}
```

------------

这个SPFA自然是可过的

![](https://cdn.luogu.com.cn/upload/pic/46641.png)

Floyd's算法已经有大佬写的很好，就不需要我的了~~

好不容易写出来了，当然要发题解~~ ~~只有一篇，过的概率大一些~~

我要是过不去，岂不尴尬，求过o(╥﹏╥)o

谢谢Thanks♪(･ω･)ﾉ

再见ヾ(￣▽￣)Bye~Bye~

---

## 作者：grard4 (赞：3)

~~历经周折，终于能够投放本蒟蒻的第一篇题解。~~

## 纠正：

出题人的 std 存在一处明显错误，由于没有正确的使用 Floyd 而影响到后面答案的求解（std 的 Floyd 算法会使得 $dis_{i,i}\ne 0$）。

可以看如下输出输出（by [Cap1taL](https://www.luogu.com.cn/user/467107)）

input:

```
4
0 0 1 1`2
0 0 0 1 3
0 1 1 1 7
0 1 1 0 3
```
output:

```
4.7500
```
而 std 的输出是 $5.7500$。

## 步入正题：

前言：请注意区分**某个点被点着**和**某根绳子被燃烧完**。

首先认真读题，而不是被出题人画的图吓得不知所措~~本人第一次做这题时也被吓到了 qwq~~。

仔细看图容易发现，构成图的绳子无非就只有两种：水平（竖直）边和斜边。

同时可以发现，不需要在乎每根绳子原来的长度（$1$ 或 $\small\sqrt{2}$），而只需在乎每根绳子燃烧完的所需时间。

并且绳子是连通的，即不需要二次点火才能完成任务。

假设有点 $i$，$j$，$k$，存在边 $(i,j)$ 和边 $(j,k)$，若从点 $i$ 处点火，则绳子全部烧完的时间为 $T_{(i,j)}+T_{(j,k)}$（火焰要先烧到 $j$ 再烧到 $k$），若从点 $j$ 处点火，则绳子全部烧完的时间为 $\max(T_{(i,j)},T_{(j,k)})$（火焰可以从 $j$ 同时向 $i$ 和 $k$ 出发）。可以看出，点 $x$ 被点着的时间，正是来的最早的火焰到达点 $x$ 的所需时间~~废话~~。

因此由上面得到的结论，我们就很容易可以想到构造一个图，图中的每个点就是每条绳子的端点，边权就是每根绳子燃烧完的所需时间。枚举每一个端点，然后对着这个图求一遍最短路，则每个点的最短路的长度就是火焰到达那个点的所需时间。于是就可以求出此时每根绳子燃烧完的所需时间，此时的答案就是每根绳子燃烧完所需时间的最大值。

---

其次注意细节。再次观察又会发现，图中有两段绳子呈现‘$\times$’型相交，这也就意味着，火焰可能最先从绳子的中点被点燃，然后分别向绳子的两端延伸。改变一下思路，由于只有斜边的绳子才会相交，于是将斜边的绳子从中间切开分为两段再去存。（具体地说，将边 $(i,j)$ 拆分成边 $(i,k)$ 和边 $(k,j)$，其中 $k$ 是边 $(i,j)$ 的中点）。

---

最后数学推导。假如说我们已经求出了边 $(i,j)$ 中火焰到达点 $i$ 和点 $j$ 的时间（假定分别为 $t_i$ 和 $t_j$），那么如何求出这根绳子燃烧完的所需时间？这个问题就变成了我们小学经常做的相遇问题。

我们设每根绳子的总路程为 $1$，注意此时要如下分类讨论：

1. 如果是整根绳子，则燃烧的速度为 $v=\Large\frac{1}{T_{(i,j)}}$。

2. 如果是半根绳子，由于路程缩短一半，所以燃烧时间也会缩短一半，因此燃烧的速度变为 $v=\Large\frac{1}{\frac{T_{(i,j)}}{2}}\normalsize=\Large\frac{2}{T_{(i,j)}}$。

设这根绳子燃烧殆尽的时间为 $T$，那么就很很容易列出方程：
$$
v(T-t_i)+v(T-t_j)=1
$$
解得 $T=\large\frac{1}{2v}+\frac{t_i+t_j}{2}$。

---

大致的思路都已经讲的差不多了，代码实现的细节方面还是比较多的。

于是这道题就这么愉快地就做完了，~~可喜可贺可喜可贺~~。

上代码：（写的很丑，勿喷）

```cpp
#include<iostream>
#include<queue>
#define MAXN 2005
using namespace std;

int n,cnt,tot,num,h[MAXN],k1[MAXN],k2[MAXN];
int f[MAXN<<1][MAXN<<1];
bool vis[MAXN],no[MAXN];
double ans,dis[MAXN],sp[MAXN];
//k1[i],k2[i]表示第 i 个绳子端点的所在编号
//f[i][j]标记点(i,j)的编号,嫌麻烦的话也可以使用map<pair<double,double> >来存
//sp[i]表示编号为 i 的绳子燃烧速度
//no[i]表示编号为 i 的点是否不可点燃

const double eps=1e-6;
const double inf=1e9;
struct edge
{
    int nxt,to;
    double val;
}e[MAXN<<1];
void add(int u,int v,double w)     //链式向前星 
{
    e[++cnt]=(edge){h[u],v,w};
    h[u]=cnt;
}
int read()
{
    int ret=0,sgn=0,ch=getchar();
    while(!isdigit(ch)) sgn|=ch=='-',ch=getchar();
    while(isdigit(ch)) ret=(ret<<3)+(ret<<1)+(ch^48),ch=getchar();
    return sgn ? -ret:ret;
}
void init(int x1,int y1,int x2,int y2,double w)       //插入每一根绳子
{
    
    x1+=1000,y1+=1000,x2+=1000,y2+=1000;    //由于数组下标不能为负,因此对负数坐标进行偏移
    x1<<=1,y1<<=1,x2<<=1,y2<<=1;            //直接取中点会出现小数,因此对每个坐标乘2处理,这样就避免了出现小数的情况
    if (!f[x1][y1]) f[x1][y1]=++tot;
    if (!f[x2][y2]) f[x2][y2]=++tot;
    if (x1==x2||y1==y2)    //不是斜边就直接记录
    {
        add(f[x1][y1],f[x2][y2],w),add(f[x2][y2],f[x1][y1],w);
        k1[++num]=f[x1][y1],k2[num]=f[x2][y2],sp[num]=1.0/w;
    }
    else                   //是斜边就分成两段记录      
    {
        int x3=x1+x2>>1,y3=y1+y2>>1;
        if (!f[x3][y3]) f[x3][y3]=++tot,no[tot]=true;
        add(f[x1][y1],f[x3][y3],w/2),add(f[x3][y3],f[x1][y1],w/2);
        add(f[x3][y3],f[x2][y2],w/2),add(f[x2][y2],f[x3][y3],w/2);
        k1[++num]=f[x1][y1],k2[num]=f[x3][y3],sp[num]=2.0/w;
        k1[++num]=f[x3][y3],k2[num]=f[x2][y2],sp[num]=2.0/w;
    }
}
void spfa(int s)       //对点 s 跑一遍最短路
{
    for (int i=1;i<=tot;i++)
      dis[i]=inf,vis[i]=false;
    queue<int> q;
    q.push(s);dis[s]=0;
    while(!q.empty())
    {
        int u=q.front();q.pop();
        vis[u]=false;
        for (int i=h[u];i;i=e[i].nxt)
        {
            int v=e[i].to;
            if (dis[v]>dis[u]+e[i].val+eps)
            {
                dis[v]=dis[u]+e[i].val;
                if (!vis[v]) vis[v]=true,q.push(v);
            }
        }
    }
}
double check(int s)    //求每个绳子燃烧完所需时间(推导见前文)
{
    int x=k1[s],y=k2[s];
    double v=sp[s];
    return 1.0/(v*2)+(dis[x]+dis[y])/2;
}
double calc(int s)     //点燃每个点求总时间
{
    double res=0;
    spfa(s);
    for (int i=1;i<=num;i++) res=max(res,check(i));
    return res;
}
int main()
{
    n=read();ans=inf;
    while(n--)
    {
        int x1=read(),y1=read(),x2=read(),y2=read();
        double w;cin>>w;        //不会快读double的屑
        init(x1,y1,x2,y2,w);
    }
    for (int i=1;i<=tot;i++)    //枚举每个端点进行点燃
      if (!no[i]) ans=min(ans,calc(i));
    printf("%.4f\n",ans);
    return 0;                   //完美撒花*★,°*:.☆(￣▽￣)/$:*.°★* 。
}
```

---

## 作者：youlv (赞：3)

# P4277 河城荷取的烟花
[题目传送门](https://www.luogu.com.cn/problem/P4277)
## 思路分析

### 基本思路
一段绳子燃烧需要满足到达其中一个端点，如果燃烧过程中另一个端点没有点燃，燃烧用时即为 $t$。**而燃烧到一个点的时间就是起始点到它的最短路。**

因此可以用 floyd 算法跑出任意两点之间需要的燃烧时间。然后枚举起始点 $s$，计算每一条绳子燃烧完的时间为到达端点的时间+绳子燃烧用时，并取所有绳子用时的最大值，即为以 $s$ 为起始点的燃烧时间。


### 解决绳子交点问题
  
![](https://cdn.luogu.com.cn/upload/image_hosting/qzm2gu9i.png)

如图中红点 A 处，两条长度为 $\sqrt{2}$ 的边如果相交，当火从一个方向燃烧到 A 点处，会同时向其它三个方向燃烧。

因此，需要把这两条边折半存储。如果在存储斜边过程中，发现已经存在一条斜边能够与当前边相交，就把原来的边删掉，新建一个中间点，并连出 4 条新边，边权为原先的一半。

只有斜边会产生端点以外的交点，所以不必把所有点折半存储，这样可以节约时间复杂度而且简化思路。

### 解决绳子两头燃烧问题

首先，在最短路上，两头燃烧**不会发生**。

证明：给定起始点 $s$,设 $dis(i)$ 为 $s$ 到 $i$ 的最短路，假设存在一条边 ${u,v}$ 边权为 $t$，这条边从两头燃烧并且在 $s$ 到点 $x$ 最短路上。令 $dis(u)<dis(v)$，要满足该边两头燃烧，需满足 $dis(u)+t>dis(v)$，则路径 $s->v->x$ 显然优于 $s->u->v->x$，矛盾，可见最短路经过的边不会两头燃烧。

因此，只需考虑统计每条边燃烧完时间时，绳子是否两头燃烧。

对于一条边 ${u,v}$ 边权为 $t$，令 $dis(u)<dis(v)$,如果 $dis(u)+t=dis(v)$，说明这条边不两头燃烧，它烧尽的时间就是 $dis(v)$。

如果 $dis(u)+t>dis(v)$，说明这条边两头燃烧，根据~~简单的小学奥数~~相遇问题，可以得出它烧尽的时间是 $dis(v)+[ t-(dis(v)-dis(u))]/2$。

## 程序实现
### 细节
- 因为输入数据给的是坐标，定义坐标数组 $loc[i][j]$ 为坐标 $(i,j)$ 的点的序号。坐标范围是 $[-1000,+1000]$，**需要把坐标转为正值**。
- 图的存储分别使用邻接矩阵实现 floyd，邻接表实现边的遍历。
- 题干要求 "不能从绳子的中间处点火",所以处理相交边时，要记录新建的原点不能作为起始点。
- 邻接表删边可以用 $del[i][j]$ 记录是否删除从 $i$ 到 $j$ 的边，遍历时跳过删掉的边即可。

### $Code$
```cpp

#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int INF=0x7fffffff;

struct edge{
	int u,v;
	double time;
};

int n,loc[2005][2005],cnt,m;    //loc数组记录点与坐标的对应关系
double g[1000][1000];           //邻接矩阵，用于跑最短路
bool del[2005][2005],nots[2005];//del数组删边，nots数组排除不能作为起始点的点
vector<edge> e;                 //邻接表存边，用于判断每一条绳子燃尽的时间

double check(int s){
	double ans=0;
	for(auto i:e){
		if(del[i.u][i.v]) continue;//排除删掉的边
		if(i.time==abs(g[s][i.u]-g[s][i.v])){
			ans=max(ans,max(g[s][i.u],g[s][i.v]));//这条边从一端燃烧
		}
		else{
			double t1=min(g[s][i.u],g[s][i.v]),t2=max(g[s][i.u],g[s][i.v]);
			ans=max(ans,t2+(i.time-(t2-t1))/2);//这条边从两端燃烧
		}
	}
	return ans;
}


int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		int x01,y01,x02,y02;
		double tt;
		cin>>x01>>y01>>x02>>y02>>tt;
		if(x01>x02){  //方便找对应的斜边
			swap(x01,x02);swap(y01,y02);
		}
		if(!loc[x01+1000][y01+1000]) loc[x01+1000][y01+1000]=++cnt;
		if(!loc[x02+1000][y02+1000]) loc[x02+1000][y02+1000]=++cnt;//存储坐标对应的点
		
		
		if(y01>y02)
		if(loc[x01+1000][y01+1000-1]&&loc[x02+1000][y02+1000+1])
		if(g[loc[x01+1000][y01+1000-1]][loc[x02+1000][y02+1000+1]]){
			
			int loct=++cnt;double gt=g[loc[x01+1000][y01+1000-1]][loc[x02+1000][y02+1000+1]];
			//新建点
			del[loc[x01+1000][y01+1000-1]][loc[x02+1000][y02+1000+1]]=1;
			del[loc[x02+1000][y02+1000+1]][loc[x01+1000][y01+1000-1]]=1;
			nots[loct]=1;
			//删除原先的边，记录新点不作为起始点
			e.push_back({loc[x01+1000][y01+1000],loct,tt/2});
			e.push_back({loc[x02+1000][y02+1000],loct,tt/2});
			e.push_back({loc[x01+1000][y01+1000-1],loct,gt/2});
			e.push_back({loc[x02+1000][y02+1000+1],loct,gt/2});
			
			g[loc[x01+1000][y01+1000]][loct]=tt/2;
			g[loct][loc[x01+1000][y01+1000]]=tt/2;
			g[loc[x02+1000][y02+1000]][loct]=tt/2;
			g[loct][loc[x02+1000][y02+1000]]=tt/2;
			g[loc[x01+1000][y01+1000-1]][loct]=gt/2;
			g[loct][loc[x01+1000][y01+1000-1]]=gt/2;
			g[loc[x02+1000][y02+1000+1]][loct]=gt/2;
			g[loct][loc[x02+1000][y02+1000+1]]=gt/2;
			
			continue;
		}
			
		if(y01<y02)
		if(loc[x01+1000][y01+1000+1]&&loc[x02+1000][y02+1000-1])
		if(g[loc[x01+1000][y01+1000+1]][loc[x02+1000][y02+1000-1]]){
			
			
			int loct=++cnt;double gt=g[loc[x01+1000][y01+1000+1]][loc[x02+1000][y02+1000-1]];
			
			del[loc[x01+1000][y01+1000+1]][loc[x02+1000][y02+1000-1]]=1;
			del[loc[x02+1000][y02+1000-1]][loc[x01+1000][y01+1000+1]]=1;
			nots[loct]=1;
			
			e.push_back({loc[x01+1000][y01+1000],loct,tt/2});
			e.push_back({loc[x02+1000][y02+1000],loct,tt/2});
			e.push_back({loc[x01+1000][y01+1000+1],loct,gt/2});
			e.push_back({loc[x02+1000][y02+1000-1],loct,gt/2});
			
			g[loc[x01+1000][y01+1000]][loct]=tt/2;
			g[loct][loc[x01+1000][y01+1000]]=tt/2;
			g[loc[x02+1000][y02+1000]][loct]=tt/2;
			g[loct][loc[x02+1000][y02+1000]]=tt/2;
			g[loc[x01+1000][y01+1000+1]][loct]=gt/2;
			g[loct][loc[x01+1000][y01+1000+1]]=gt/2;
			g[loc[x02+1000][y02+1000-1]][loct]=gt/2;
			g[loct][loc[x02+1000][y02+1000-1]]=gt/2;
			
			continue;
		}
			
		e.push_back({loc[x01+1000][y01+1000],loc[x02+1000][y02+1000],tt});
		g[loc[x01+1000][y01+1000]][loc[x02+1000][y02+1000]]=tt;
		g[loc[x02+1000][y02+1000]][loc[x01+1000][y01+1000]]=tt;
	}
	n=cnt;
	m=e.size();
	for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++)
		if(i!=j&&!g[i][j]) g[i][j]=INF;
	for(int k=1;k<=n;k++)
	for(int i=1;i<=n;i++)
		if(i!=k)
		for(int j=1;j<=n;j++)
			if(i!=j&&j!=k&&g[i][j]>g[i][k]+g[k][j]) g[i][j]=g[i][k]+g[k][j];
	//floyd找出燃烧到每一个点所用时间
	
	double ans=INF;
	for(int i=1;i<=n;i++){
		if(nots[i]) continue;//边的中点不能作为起始点
		ans=min(ans,check(i));
	}
	printf("%0.4f",ans);
} 
```






---

## 作者：AbioAg (赞：2)

touhou 赛高~

观察发现对于火在绳子上燃烧的过程，可以抽象为在边上行走，而燃烧路径上经过若干绳子交点时，引燃其他绳子的过程可以看做是分散出若干分身去同时行走，于是我们有如下建模思路：

对于绳子的两个端点，以及若干绳子相交点，我们把它们抽象成节点，对于绳子，我们把它们抽象成边，我们要求的便是从某个绳子端点开始行走，按如上移动方式移动
经历所有绳子的最短时间。

但值得注意的是我们的绳子有可能从两头同时向内燃烧，而我们显然不存在对应的算法实现这一过程，但是我们对于一条边，却可以求出火到它的两个端点的最短时间，这样我们就把问题转化为了对于每条边，在边上做相遇问题，~~根据小学奥数~~，从开始点燃初始点到某条边燃尽所需时间的式子也是很好推出的：$T=0.5\times(e[i].val+dis[u]+dis[v])$。

于是我们便可以通过最短路来解决这个问题，我们采用 map 来将坐标映射为对应节点，同时对于斜向边，存在相交可能，我们将斜向边断成两截，同时行走时间都赋为原时间的一半，为了方便中点坐标在 map 中的映射，我们把输入点的坐标均翻倍，这样取中点一定为整点，便于在 map 上映射。

值得一提的是题目不允许在绳子交点处点燃，这个很好处理，建点时用 flg 数组标记一下中点即可。

代码很简洁，很优雅。

[code](https://www.luogu.com.cn/paste/9sb60no1)

---


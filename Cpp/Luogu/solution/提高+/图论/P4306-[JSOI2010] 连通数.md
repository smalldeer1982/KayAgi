# [JSOI2010] 连通数

## 题目背景

本题数据过水，可前往 https://www.luogu.com.cn/problem/U143178 提交

$\text{upd 2022.8.4}$：已作为 Hack 数据合并进来。

## 题目描述

度量一个有向图连通情况的一个指标是连通数，指图中可达顶点对个的个数。

如图

![](https://cdn.luogu.com.cn/upload/image_hosting/8jviim6w.png)

顶点 $1$ 可达 $1, 2, 3, 4, 5$

顶点 $2$ 可达 $2, 3, 4, 5$

顶点 $3$ 可达 $3, 4, 5$

顶点 $4, 5$ 都只能到达自身。

所以这张图的连通数为 $14$。

给定一张图，请你求出它的连通数

## 说明/提示

对于 $100 \%$ 的数据，$1 \le N \le 2000$。

## 样例 #1

### 输入

```
3
010
001
100```

### 输出

```
9```

# 题解

## 作者：bztMinamoto (赞：22)

感谢zjq大佬（最楼下那位）给蒟蒻耐心的讲解~~（因为数组开小，满屏的花花绿绿还有TLE）~~

两种方法。第一种，就像是楼下所说，先tarjan+缩点，然后在新的图上建一个反向图，同时用拓扑排序不断更新每一个强连通分量能够到达的其他强连通分量。最后枚举每一个强连通分量，若h[i][j]为1则ans加上两个强连通分量的点数之积


上代码,具体看注解
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<queue>
#include<bitset>
#include<string>
#define fu(a,b,c) for(int a=b;a<=c;a++)
#define fd(a,b,c) for(int a=b;a>=c;a--)
using namespace std;
const int N=2050,M=4000500;
int ver[M],Next[M],head[N];
int vc[M],nc[M],hc[N],low[N],dfn[N],stack[N],c[N],k[N],t[N];
bitset<N> h[N];
bool v[N];
int n,m,tot,num,cnt,tc,top,ans;
inline void add(int x,int y)
{
    ver[++tot]=y,Next[tot]=head[x],head[x]=tot;
}
inline void add_c(int x,int y)
{
    vc[++tc]=y,nc[tc]=hc[x],hc[x]=tc;
}
void tarjan(int x)//跑一边tarjan
{
    low[x]=dfn[x]=++num;
    stack[++top]=x,v[x]=1;
    for(int i=head[x];i;i=Next[i])
    {
        int y=ver[i];
        if(!dfn[y])
        {
            tarjan(y);
            low[x]=min(low[x],low[y]);
        }
        else if(v[y]) low[x]=min(low[x],dfn[y]);
    }
    if(low[x]==dfn[x])
    {
        int y;
        cnt++;
        do{
            y=stack[top--];v[y]=0;
            c[y]=cnt;
            k[cnt]++;
        }while(x!=y);
        h[cnt][cnt]=1;
        //每一个强连通分量一定能够到达自己
    }
}
void solve()
{
//跑一边拓扑排序
    queue<int> q;
    fu(i,1,cnt)
    if(!t[i]) q.push(i);
    while(!q.empty())
    {
        int x=q.front();
        q.pop();
        for(int i=hc[x];i;i=nc[i])
        {
            int y=vc[i];
            h[y]|=h[x];
            t[y]--;
            if(!t[y]) q.push(y);
        }
    }
}
int main()
{
    cin>>n;
    fu(i,1,n)
    {
        string s;
        cin>>s;
        fu(j,0,s.size()-1)
        if(s[j]=='1') add(i,j+1);
    }
    fu(i,1,n)
    if(!dfn[i]) tarjan(i);
    fu(x,1,n)
    for(int i=head[x];i;i=Next[i])
    {
        int y=ver[i];
        if(c[x]!=c[y]) add_c(c[y],c[x]),t[c[x]]++;
        //缩点，记得要建的是反向图，同时记录点的入度
    }
    solve();
    fu(i,1,cnt)
    fu(j,1,cnt)
    if(h[i][j]) ans+=k[i]*k[j];
    printf("%d",ans);
    return 0;
}
```

第二种方法。因为每一个整数有32位，我们设T=30，可以把n个点分为n/T组，每一组有至多30个点，每个点位于第i/30组的第i%30位

一个整数，可以表示为二进制，我们可以用此方法来表示一个点能否到达另一个点。比方说h[i]=100110（二进制），表示这一个点能够到达点1,2,4

我们用h[i][j/30]表示每一个强连通分量能否到达每一个点的情况。
```
if(h[i][j/30]&1<<(j%30)) ans+=k[i];
```
其中i代表强联通分量的编号，j代表点的编号，k[i]代表此强连通分量中共有多少个点。

如果一个强联通分量能够到达一个点，那么答案就累加上它的点数

剩下的，就是tarjan缩点再建反图拓扑，第一种方法中已说明，不再赘述


具体细节看注解
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<queue>
#define fu(a,b,c) for(int a=b;a<=c;a++)
#define fd(a,b,c) for(int a=b;a>=c;a--)
using namespace std;
const int N=2050,M=4000500,T=30;
int ver[M],Next[M],head[N];
int vc[M],nc[M],hc[N],low[N],dfn[N],stack[N],c[N],k[N],t[N];
int h[N][N/T];
bool v[N];
int n,m,tot,num,cnt,tc,top,ans;
inline void add(int x,int y)
{
    ver[++tot]=y,Next[tot]=head[x],head[x]=tot;
}
inline void add_c(int x,int y)
{
    vc[++tc]=y,nc[tc]=hc[x],hc[x]=tc;
}
void tarjan(int x)
{
    low[x]=dfn[x]=++num;
    stack[++top]=x,v[x]=1;
    for(int i=head[x];i;i=Next[i])
    {
        int y=ver[i];
        if(!dfn[y])
        {
            tarjan(y);
            low[x]=min(low[x],low[y]);
        }
        else if(v[y]) low[x]=min(low[x],dfn[y]);
    }
    if(low[x]==dfn[x])
    {
        int y;
        cnt++;
        do{
            y=stack[top--];v[y]=0;
            c[y]=cnt;
            k[cnt]++;
            h[cnt][y/T]|=1<<(y%T);
            //一个强连通分量能够到达哪些点，记录
        }while(x!=y);
    }
}
void solve()
{
    queue<int> q;
    fu(i,1,cnt)
    if(!t[i]) q.push(i);
    while(!q.empty())
    {
        int x=q.front();
        q.pop();
        for(int i=hc[x];i;i=nc[i])
        {
            int y=vc[i];
            fu(j,0,n/T)
            h[y][j]|=h[x][j];
            t[y]--;
            if(!t[y]) q.push(y);
        }
    }
}
int main()
{
    cin>>n;
    fu(i,1,n)
    {
    	string s;
    	cin>>s;
    	fu(j,0,n-1)
    	if(s[j]=='1') add(i,j+1);
    }
    fu(i,1,n)
    if(!dfn[i]) tarjan(i);
    fu(x,1,n)
    for(int i=head[x];i;i=Next[i])
    {
        int y=ver[i];
        if(c[x]!=c[y]) add_c(c[y],c[x]),t[c[x]]++;
    }
    solve();
    fu(i,1,n)
    {
        int l=i/T,r=1<<(i%T);
        fu(j,1,cnt)
        if(h[j][l]&r) ans+=k[j];
        //判断每一个强连通分量能否到达某个点
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：Unordered_OIer (赞：14)

# P4306 题解
## 题意
求任意一个节点通过有向边可以到达的节点数之和。
## 解答
### 解法$1$
求节点数，那么我们把所有节点能够到达的节点都记录下来，然后最后加一下。  
嗯？这不就是$Floyd$吗。用$bitset$优化一下，应该可以骗到不少分数吧。  

代码：
```cpp
#include <bits/stdc++.h>
#define N 2005
using namespace std;

typedef long long ll;
ll n,ans = 0;
bitset<N>can_reach[N]; // 可以开一个bool数组代替，但是空间上不优

void prepare_floyd()
{
	for (ll i = 1; i <= n; i ++)
		for (ll j = 1; j <= n; j ++)
			if (can_reach[j][i]) can_reach[j] |= can_reach[i]; // 能从j到i
}

void solve_floyd()
{
	for (ll i = 1; i <= n; i ++)
		for (ll j = 1; j <= n; j ++)
			if (can_reach[i][j]) ans ++; // 能到达
}

void init()
{
	cin >> n;
	for (ll i = 1; i <= n; i ++)
	{
		for (ll j = 1; j <= n; j ++)
		{
			char c; cin >> c;
			if (c == '1') can_reach[i][j] = 1; // i可以到达j
		}
		can_reach[i][i] = 1; // i可以到达i
	}
}

void putans() { cout << ans << endl; }

void _main(){
	init();
	prepare_floyd();
	solve_floyd();
	putans();
}

int main()
{
	_main();
	return 0;
}
```

然后我们交上去一发，我的天[AC](https://www.luogu.com.cn/record/36120987)了  
~~完结撒花~~  

既然有解法$1$，那也有解法$2$啊~

### 解法$2$
这个解法就是大多数题解里提到的$tarjan$**缩点**。

我们考虑一个**没有环**的原题，那么直接搜一遍完事，非常简单。  
但这题比较麻烦的地方是**有环**，有环会使搜索被卡，而我们除了搜索以外没有其他很好的想法。  

所以我们要**想方设法使搜索可行**。

并且，我们发现如果把环看成一个点，然后把这个点作为一个有权值的**胖点**（即把这个点算作多个点捏一起），答案**不会改变**。

这……$tarjan$缩点！把一个环缩成一个点！然后拓补排序一下即可。

拓补排序的代码：
```cpp
void topo_sort()
{
    for (ll i = 1; i <= block_counter; i ++)
        f[i][i] = 1; // i to i
    queue<ll> q;
    for (ll i = 1; i <= block_counter; i ++)
        if (!in[i]) q.push(i); // push
    while (!q.empty()){
        ll u = q.front(); q.pop(); // get front
        for (ll i = 0; i < G[u].size(); i++){
            ll v = G[u][i]; f[v] |= f[u];
            if (!(--in[v])) q.push(v);
        }
    }
}
```

[AC记录](https://www.luogu.com.cn/record/36122463)

完结撒花~顺便求赞

---

## 作者：YoungNeal (赞：7)


## Solution

题解在博客[食用](https://www.cnblogs.com/YoungNeal/p/9127102.html)效果更佳哦~

~~下面题解都不是正解诶。。交到BZOJ上会WA到死~~

 $Tarjan$ 缩点 $+$ 拓扑排序 $+$ $bitset$ 优化状压

显然对于每个强联通分量我们都要求出在新图上它能到达哪些点。

如何求呢？

法一： $dfs$，对于每个强联通分量找一下它连出去的边能到达哪些联通块，统计答案即可。~~(只是口胡一下没有写这种方法如果写不出来别找我)~~

法二：我们定义数组 $f[i][j]$ 表示能否从第 $i$ 个连通分量到达第 $j$ 个连通分量。因为值只能为 $0/1$，我们用 $bitset$ 来状压第二维。因为 $f[j]=or(f[i]),j\;can\;go\;to\;i$，所以我们在新图上建立一张反图，拓扑排序，按照拓扑序即可求出每个点能到达哪些点。复杂度 O(n^2/32)。

## Code

```cpp
#include<queue>
#include<bitset>
#include<cstdio>
#include<cctype>
#include<iostream>
#define N 2005
#define min(A,B) ((A)<(B)?(A):(B))

int ans;
char ch[N];
bool in[N];
int n,cnt,sum,tot;
int dfn[N],low[N];
std::bitset<N> f[N];
std::queue<int> topo;
int belong[N],deg[N];
int head[N],head2[N];
int stk[N],top,sze[N];

struct Edge{
    int to,nxt;
}edge[N*N],edge2[N*N];

void add(int x,int y){
    edge[++cnt].to=y;
    edge[cnt].nxt=head[x];
    head[x]=cnt;
}

void add2(int x,int y){
    edge2[++cnt].to=y;
    edge2[cnt].nxt=head2[x];
    head2[x]=cnt;
}

int getint(){
    int x=0;char ch=getchar();
    while(!isdigit(ch)) ch=getchar();
    while(isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return x;
}

void tarjan(int now){
    dfn[now]=low[now]=++sum;
    stk[++top]=now;in[now]=1;
    for(int i=head[now];i;i=edge[i].nxt){
        int to=edge[i].to;
        if(!dfn[to]){
            tarjan(to);
            low[now]=min(low[now],low[to]);
        }
        else if(in[to])
            low[now]=min(low[now],dfn[to]);
    }
    if(low[now]==dfn[now]){
        int y; tot++;
        do{
            y=stk[top--];
            belong[y]=tot;
            sze[tot]++;
            in[y]=0;
        }while(y!=now);
    }
}

signed main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%s",ch);
        for(int j=0;j<n;j++){
            if(ch[j]=='0') continue;
            add(i,j+1);
        }
    }
    cnt=0;
    for(int i=1;i<=n;i++){
        if(!dfn[i])
            tarjan(i);
    }
    for(int x=1;x<=n;x++){
        for(int i=head[x];i;i=edge[i].nxt){
            int to=edge[i].to;
            if(belong[x]==belong[to]) continue;
            deg[belong[x]]++;
            add2(belong[to],belong[x]);
        }
    }
    for(int i=1;i<=tot;i++)
        f[i][i]=1;
    for(int i=1;i<=tot;i++){
        if(!deg[i])
            topo.push(i);
    }
    while(topo.size()){
        int u=topo.front();topo.pop();
        for(int i=head2[u];i;i=edge2[i].nxt){
            int to=edge2[i].to;
            deg[to]--;
            f[to]|=f[u];
            if(!deg[to])
                topo.push(to);
        }
    }
    for(int i=1;i<=tot;i++){
        for(int j=1;j<=tot;j++){
            if(f[i][j])
                ans+=sze[i]*sze[j];
        }
    }
    printf("%d\n",ans);
    return 0;
}
```



---

## 作者：Jμdge (赞：2)

一个强爆了的类似分块的状压做法（好吧我承认思路没什么别致的，但是起码这份代码也是有优化的。）


```cpp
#include<iostream>  
#include<cstdio>  
#include<cstdlib>  
#include<cmath>  
#include<cstring>  
#include<algorithm>  
using namespace std;  
const int M=2100;  
int n,ans,block,num,pat;  
int top,tim,cnt,patt;
int head[M],h[M],r[M];
int dfn[M],low[M];
int stk[M],in[M];  
int blg[M],has[M];
int mark[M][M];  
char ch[M];
struct edge{
    int to,next;
}e[M*M],ed[M*M];  
inline void add(int u,int v){
	++pat; e[pat].to=v; e[pat].next=head[u]; head[u]=pat;
}

void tarjan(int u)  //缩点
{  
    dfn[u]=low[u]=++tim;  
    stk[++top]=u, in[u]=1;  
    for(int i=head[u];i;i=e[i].next){
        int v=e[i].to;
        if(!dfn[v])
            tarjan(v),
            low[u]=min(low[u],low[v]);
        else if(in[v])
            low[u]=min(low[u],dfn[v]);  
    }
    if(low[u]==dfn[u]){  
        int now; ++cnt;  
        do{  
            now=stk[top--];  
            blg[now]=cnt;  
            ++has[cnt];  
            in[now]=0;  
        }while(now!=u);  
    }  
}  
  
inline void addedge(int u,int v){  //新图建边
	++patt; ed[patt].to=v; ed[patt].next=h[u]; h[u]=patt;
}
inline void rebuild()  
{  
    for(int u=1;u<=n;++u)
    for(int i=head[u];i;i=e[i].next){
        int v=e[i].to;
        if(blg[u]!=blg[v])
        	addedge(blg[v] , blg[u]),
			++r[blg[u]];  //反向建图的操作
    }   
}  

int main()  
{  
    scanf("%d",&n);
	block=30; num=n/block+1;  //类似分块
    for(int i=1;i<=n;++i){  
        scanf("%s",ch+1);  
    	for(int j=1;j<=n;++j)
        if(ch[j]-'0') add(i , j);
	}   
    for(int i=1;i<=n;++i)  
        if(!dfn[i]) tarjan(i);  
    rebuild(); top=0;   
    for(int i=1;i<=n;++i)  //对于每一个连通块内的点进行记录
        mark[blg[i]][i/block+1]|=(1<<(i%block));  
    for(int i=1;i<=cnt;++i)  //从入度为零的联通块开始操作
        if(!r[i]) stk[++top]=i;  
    while(top){  
        int u=stk[top]; --top;  
        for(int i=h[u];i;i=ed[i].next){  
            int v=ed[i].to;  
            for(int j=1;j<=num;++j)  //给指向的联通块加上自己已有的信息（分块加）
                mark[v][j]|=mark[u][j];   
            if(--r[v]==0) stk[++top]=v;  
        }  
    }  
    for(int i=1;i<=cnt;++i)  //每个连通块所能通到的点*联通块内点数，计入答案
    for(int j=1;j<=n;++j)  
    if((mark[i][j/block+1])&(1<<(j%block)))
        ans+=has[i];  
    printf("%d\n",ans);  
    return 0;  
}
```

---


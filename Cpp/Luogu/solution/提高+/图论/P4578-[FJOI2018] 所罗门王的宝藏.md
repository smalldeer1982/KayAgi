# [FJOI2018] 所罗门王的宝藏

## 题目描述

据古代传说记载，所罗门王既是智慧的代表，又是财富的象征。他建立了强大而富有的国家，聚集了大批的黄金象牙和钻石，并把这些价值连城的珍宝藏在一个神秘的地方，这就是世人瞩目的“所罗门王的宝藏”。多少个世纪以来，人们一直在寻找这批早已失落的古代文明宝藏，寻找盛产黄金和钻石的宝地。曾经追寻所罗门王宝藏的冒险者们都一去不回，至今没人解开这个谜题。亨利男爵在一次幸运的旅途中意外地得到了三百年前一位葡萄牙贵族留下的写在羊皮卷上的所罗门王的藏宝图和一本寻宝秘籍。在这张藏宝图的诱惑下，亨利男爵邀请约翰上校和勇敢的猎象人夸特曼开始了寻找埋葬在黑暗地底的所罗门王宝藏的艰险历程。他们横穿渺无边际的沙漠和浓荫蔽日的原始森林，越过汹涌澎湃的激流险滩，翻越高耸入云的峻岭雪山，饱尝沙漠的酷热和冰雪严寒，在藏宝图的指引下来到非洲一个原始的神秘国度库库安纳。这里有残酷的人殉制度，有一个拥有一千个妻室的独眼暴君特瓦拉，有像兀鹫一般丑恶诡诈老而不死的女巫加古尔，还有美丽聪慧的绝代佳人弗拉塔。在这片陌生而又险象环生的土地上三位寻宝英雄历尽艰辛，终于在绝代佳人弗拉塔的帮助下在海底深处找到了珍藏这批价值连城宝藏的巨大的藏宝洞。然而在女巫加古尔的精心策划下，一场灭顶之灾正在悄悄逼近。

藏宝洞的洞门十分坚固且洞门紧闭，如果不知道开启洞门的秘密是无法打开藏宝洞的洞门。在藏宝洞的洞门一侧有一个奇怪的矩形密码阵列。根据寻宝秘籍的记载，在密码阵列每行的左侧和每列的顶端都有一颗红宝石按钮。每个按钮都可以向左或向右转动。每向左转动一次按钮，相应的行或列中数字都增 $1$。每向右转动一次按钮，相应的行或列中数字都减 $1$。在矩形密码阵列的若干特定位置镶嵌着绿宝石。只有当所有绿宝石位置的数字与藏宝图记载的密码完全相同，紧闭的洞门就会自动缓缓打开。女巫加古尔早已得知开门的秘密。为了阻止寻宝者打开洞门，女巫加古尔为开门的密码阵列设置了全 $0$ 的初始状态。试图打开洞门的寻宝者如果不能迅速转动按钮使所有绿宝石位置的数字与藏宝图记载的密码完全相同，就会自动启动藏宝洞玄妙的暗器机关，使寻宝者遭到灭顶攻击而死于非命。

您能帮助三位寻宝英雄顺利打开藏宝洞的洞门吗？

编程任务：对于给定的密码阵列，找到获得正确密码的红宝石按钮的转动序列。


## 说明/提示

对于 $100\%$ 的数据，$1 \le n, m, k \le 1000$，$k \le n \times m$，$|c| \le 1,000,000$。

## 样例 #1

### 输入

```
2
2 2 4
1 1 0
1 2 0
2 1 2
2 2 2
2 2 4
1 1 0
1 2 0
2 1 2
2 2 1```

### 输出

```
Yes
No```

# 题解

## 作者：未见堇开 (赞：21)

差分约束做法。

设第$r$行的操作使这一行的数增加了$x_{r}$，第$c$列的操作使这一列的数减少了$y_{c}$，

那么显然对于第$r$行第$c$列绿宝石的密码$p$，有$x_{r}-y_{c}=p$

即：$\left\{\begin{matrix}x_{r}-y_{c}\leq p\\x_{r}-y_{c}\geq p\end{matrix}\right.$

移项得$\left\{\begin{matrix}x_{r}-y_{c}\leq p\\y_{c}-x_{r}\leq -p\end{matrix}\right.$

对两个不等式分别连边$(r\overset {p}{\rightarrow}c+n)\; ,\; (c+n\overset {-p}{\rightarrow}r)$，即可构造差分约束系统。

因为题目只求解的存在性，判负环即可。

讲解到此为止。放代码。

```cpp
#include<cstdio>
#include<queue>
#define reg register
#define MAXN 2019
using namespace std;

struct edge
{int pre,dis,to;}e[5005];
int n,m,k,s,ptr_e;
bool have=false;
int last[MAXN],dis[MAXN],inq[MAXN],vis[MAXN];

inline void spfa()
{
	dis[s]=0;
	queue<int> q; 
	for(int i=1;i<=n+m;i++)
		dis[i]=0x23333333,inq[i]=vis[i]=0;
	q.push(s),vis[s]=1;
	while(!q.empty())
	{
		int tmp=q.front();
		q.pop(),inq[tmp]=0;
		for(reg int i=last[tmp];i;i=e[i].pre)
		{
			int v=e[i].to,w=e[i].dis;
			if(dis[v]>dis[tmp]+w)
			{
				if(vis[v]>=n+m)
				{
					have=true;
					return;
				}
				dis[v]=dis[tmp]+w;
				if(!inq[v])
				{
					++vis[v],inq[v]=1;
					q.push(v);
				}
			}
		}
	}
	have=false;
	return;
}

inline void addedge(int u,int v,int d)//连边
{
	e[++ptr_e].pre=last[u];
	e[ptr_e].dis=d,e[ptr_e].to=v,last[u]=ptr_e;
	return;
}

inline int qin()//快读
{
	reg int ans=0,m=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')
			m=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		ans=ans*10+(ch-'0');
		ch=getchar();
	}
	return(ans*m);
}

int main()
{
	int t=qin();
	while(t--)
	{
		n=qin(),m=qin(),k=qin();
		ptr_e=0,s=n+m+1;
		last[s]=0;
		for(reg int i=1;i<=n+m;i++)
			last[i]=0,addedge(s,i,0);
		while(k--)
		{
			int u=qin(),v=qin(),d=qin();
			addedge(u,v+n,d),addedge(n+v,u,-d);
		}
		spfa();
		if(have)
			puts("No");
		else
			puts("Yes");
	}
	return(0);
}
```
[97msAC](https://www.luogu.org/recordnew/show/17424151)

---

## 作者：lightup37 (赞：10)

## 本题解同步于[博客园](https://www.cnblogs.com/tyqtyq/p/10387591.html)

emmm切了近年省选题来写题解啦qwq

该题较其他省选题较水吧（否则我再怎么做的出来

思路是图论做法，做法上楼上大佬已经讲的很清楚了，我来谈谈代码实现上的一些细节

$$\text{设节点1...2n，i}\in\text{1-n表示i行，i}\in\text{(n+1)-2n时表示i-n列}$$

$$\text{当我们读到一颗绿宝石(x,y,k)时，就从x向y+n连一条权值为k的边}$$

$$\text{当我们连完边后会发现给一行/一列增加a就相当于把与这个点相连的所有边权值增加a}$$

$$\text{这个加边权可以转化为加点权}$$

$$\text{设}onk_i\text{表示在这个节点上的点击次数，}$$

$$\text{搜索起始节点的初值为与这个节点所连边中权值最小的}$$

$$\text{那么已知两点i,j以及}edge_{i,j}\text{和}onk_i\text{，那么由题目条件易得}onk_j=edge_{i,j}-onk_i$$

$$\text{那么直接dfs}$$

时间复杂度为$$O(T\times(KlogK+K)) = O(TNlogN)$$要改进也行，因为我们对于每个点所连边只要边权最小数所以没必要sort，但当我想到这一点时已经AC本题~

$$Talk\;is\;free\;,\;show\;me\;the\;code$$
```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<algorithm>
#include<cstring>
#define MAXN 1005
using namespace std ;
inline void read(int &x) {
	scanf("%d",&x) ;
}
class getsol {
	public:
		//========data========
		vector<pair<int,int> > edge[MAXN*2] ; //pair第一维是边权，第二维是到达边的编号
		int n , m , k , onk[MAXN*2] , inq[MAXN*2] , flag ;//inq表示是否被搜到
		//========func========
		void add(int x,int y,int v) {
			edge[x].push_back(make_pair(v,y)) ; //加边
		}
		bool check(int u,int v,int w) {
			//check , 判断v点是否可行
			if(onk[u]+onk[v]!=w) return 0 ;
			return 1 ;
		}
		void dfs(int D) {
			//cout<<"DFS : START SEARCH IN DOT "<<D<<endl ;
			if(flag==0) return ;
			inq[D] = 1 ;
			for(auto& i : edge[D]) { //对于每个edge[D]中的元素i
				///cout<<"DFS : SEARCH IN DOT "<<i.second<<endl ;
				if(flag==0) return ;
				//cout<<"In dot : "<<i.second<<endl ;
				int ver = i.second , edgeval = i.first ;
				if(inq[ver]) {
					if(flag==1) //如果答案还是"Yes"那么更新，这里是一个优化~
						flag = check(D,ver,edgeval) ;
					continue ;
				} else {
					onk[ver] = edgeval-onk[D] ;
					dfs(ver) ;
				}
			}
		}
		void PRINT(int* arr,int n) {
			for(int i=1; i<=n; ++i) {
				cout<<"arr["<<i<<"] = "<<arr[i]<<endl ;
			}
		}
		void sol() {
			flag = true ;
			read(n) , read(m) , read(k) ;
			//行的编号为1~n
			//列的编号为(n+1)~(2*n)
			//喵~
			for(int i=1; i<=k; ++i) {
				int x,y,v ;
				read(x) , read(y) , read(v) ;
				add(x,y+n,v) ;
				add(y+n,x,v) ;
			}
			//cerr<<"FINISH READ"<<endl ;
			for(int i=1; i<=2*n; ++i) sort(edge[i].begin(),edge[i].end()) ;
			//cerr<<"FINISH SORT"<<endl ;
			for(int i=1; i<=2*n; ++i) {
				if(!inq[i]&&flag&&!edge[i].empty()) { // 注意这里判一下vector是否为空。。因为这个RE了两三次
					onk[i] = (*edge[i].begin()).first ;
					//cerr<<"SEARCH IN DOT "<<i<<endl ;
					dfs(i) ;
				}
			}
			if(flag==1) {
				for(int i=1; i<=2*n; ++i)
					for(auto& j : edge[i])
						if(flag==1) //重新check一遍，以免遗漏
							flag = check(i,j.second,j.first) ;
			}
			if(flag) puts("Yes") ;
			else puts("No") ;
			//PRINT(onk,2*n) ;
		}
		void clear() {
			for(int i=1; i<=2*n; ++i) edge[i].clear() ;
			memset(inq,0,sizeof(onk)) ;
			memset(onk,0,sizeof(onk)) ;
			n = m = k = flag = 0 ;
		}
} ;
getsol M ;
int T ;
int main() {
	//freopen("solo3.in" , "rb" , stdin) ;
	//freopen("solo3.out", "wb" ,stdout) ;
	read(T) ;
	while(T--) M.sol() , M.clear() ;
}
```

注意本代码是使用C++11标准写成，代码中不同不同语法处已标注

---

## 作者：s_r_f (赞：7)

$update$ $on$ $2020.4.19$ $:$ 代码有锅$,$所以修一下$.$

每个绿宝石对应一个限制 $t[x][y] = row[x] + col[y]$

其中 $row[x]$ 为行，$col[y]$ 为列。

那么，我们对于两个同行的绿宝石 $(a,b,c)$ 和 $(a,d,e)$，

有 $t[a][b] - t[a][d] = col[b] - col[d]$;

对于$row[]$同理。

然后判断是否存在合法的 $row[]$ 和 $col[]$ 即可$.$

因为我们求出了 $row[]$ 和 $col[]$ 内部的差$,$那么我们就可以直接$dfs$来$check.$

因为 $n,m,k<=1000$ 所以我为了省事没写$O(n+m+k),$直接$O(n^2+m^2+k^2)$了.

代码$($ **$updated$** $)$：

```cpp

#include <bits/stdc++.h>
using namespace std;
template <typename T> void read(T &x){
	x = 0; int f = 1; char ch = getchar();
	while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();}
	while (isdigit(ch)) {x = x * 10 + ch - '0'; ch = getchar();}
	x *= f;
}
const int N = 1005,M = 1005,K = 1005;
int n,d1[N][N]; bool vis1[N][N];
int m,d2[M][M]; bool vis2[M][M];

bool flag1; bool vis[N]; int val[N];


inline void dfs1(int x){
	vis[x] = 1;
	for (int y = 1,v; y <= n; ++y) if (vis1[x][y]){
		v = val[x] + d1[x][y];
		if (!vis[y]) val[y] = v,dfs1(y);
		else if (val[y] != v) flag1 = 0;
	}
}
inline bool check1(){
	int i,j;
	for (i = 1; i <= n; ++i) vis[i] = 0;
	flag1 = 1;
	for (i = 1; i <= n; ++i) if (!vis[i]) vis[i] = 1,val[i] = 0,dfs1(i);
	return flag1;
}
bool flag2;
inline void dfs2(int x){
	vis[x] = 1;
	for (int y = 1,v; y <= m; ++y) if (vis2[x][y]){
		v = val[x] + d2[x][y];
		if (!vis[y]) val[y] = v,dfs2(y);
		else if (val[y] != v) flag2 = 0;
	}
}
inline bool check2(){
	int i,j;
	for (i = 1; i <= m; ++i) vis[i] = 0,val[i] = 0;
	flag2 = 1;
	for (i = 1; i <= m; ++i) if (!vis[i]) vis[i] = 1,val[i] = 0,dfs2(i);
	return flag2;
}

bool flag; int k,x[K],y[K],v[K];
inline void Ins1(int x,int y,int v){
	if (!vis1[x][y]) vis1[x][y] = 1,d1[x][y] = v;
	else if (d1[x][y] != v) flag = 0;
}
inline void Ins2(int x,int y,int v){
	if (!vis2[x][y]) vis2[x][y] = 1,d2[x][y] = v;
	else if (d2[x][y] != v) flag = 0;
}
inline bool solve(){
	int i,j;
	read(n),read(m),read(k),flag = 1;
	for (i = 1; i <= k; ++i) read(x[i]),read(y[i]),read(v[i]);
	for (i = 1; i <= n; ++i) for (j = 1; j <= n; ++j) vis1[i][j] = 0;
	for (i = 1; i <= m; ++i) for (j = 1; j <= m; ++j) vis2[i][j] = 0;
	for (i = 1; i <= n; ++i) Ins1(i,i,0);
	for (i = 1; i <= m; ++i) Ins2(i,i,0);
	for (i = 1; i <= k; ++i) for (j = i+1; j <= k; ++j){
		if (x[i] == x[j]){
			Ins2(y[i],y[j],v[j]-v[i]);
			Ins2(y[j],y[i],v[i]-v[j]);
		}
		if (y[i] == y[j]){
			Ins1(x[i],x[j],v[j]-v[i]);
			Ins1(x[j],x[i],v[i]-v[j]);
		}
	}
	if (!flag) return 0;
	return check1() && check2();
}

int main(){
	int T; read(T); while (T--) puts(solve() ? "Yes" : "No");
	return 0;
}

```

---

## 作者：w36557658 (赞：5)

欢迎访问我的博客～ https://www.cnblogs.com/luyouqi233/p/9145394.html

更新了一下证明与系统化题解与代码（不然看着不方便），如有错误还请指出。
_______________________

前置：

先转换成图论模型，即每个绿宝石，横坐标向纵坐标连边，权值为绿宝石要的数。

然后就变成了每个点，我按一下可以使得与它相连的边都$+1/-1$，问能否使图边权全部变成$0$。

那么我们顺其自然的开个$del[i]$表示$i$这个点需要删多少次才能符合答案，显然的对于每条边$(u,v,w)$都要有$del[u]+del[v]==w$。

更进一步：

我们思考若原图为一棵树会不会好做些。

求证：**对于连边情况为一棵树来说，当一个结点的$del$固定时，有且只有唯一解。**

证明：令该节点为根，根层为$0$层，往下为$1$层，$2$层……

由$del[u]+del[v]==w$可知三个值知道两个即可求第三个，所以$0$层的$del$定下来后$1$层的就定了，之后$2$层的就定了……以此类推。

也因此，我们如果对根的$del+k$的话，那么对于每一奇数层$del$就要$-k$，每一偶数层就要$+k$。我们用这一性质可以构造出所有的解。

之后对于非树边，**有且只有奇层与偶层的点连边**这一种情况。（因为永远都是横纵相连，所以奇奇边和偶偶边是不存在的）

而又因为**对于奇数层和偶数层非树边来说两点的$del$和永远不变**（一个$+k$一个$-k$抵消了），所以通过它们与边权的比较我们就可以判断答案合法性。

以及我们也因此论证了对于最开始的$del$定什么都无所谓，所以就定$0$呗，何乐而不为呢？

后记：

题解最开始比较意识流，没有详细的证明，所以修正一下。

本人写这个博客时已经是退役一年OIER，因此如果有疏漏请指出。

希望审核给过吧……我原本改了一遍题解结果一天没审核完所以干脆重写了一遍。

不过这题作为为数不多自己做出来的省选题果然不算太难，毕竟意识流想法是对的所以反着证明就没有什么难度了……大概？

```cpp
#include<cmath>
#include<stack>
#include<queue>
#include<cstdio>
#include<cctype>
#include<vector>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
typedef long long ll;
const int N=2005;
inline ll read(){
    ll X=0,w=0;char ch=0;
    while(!isdigit(ch)){w|=ch=='-';ch=getchar();}
    while(isdigit(ch))X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
    return w?-X:X;
}
struct node{
    int to,nxt,w;
}e[N];
int n,m,k,cnt,head[N],del[N];
bool vis[N];
queue<int>q;
inline void add(int u,int v,int w){
    e[++cnt].to=v;e[cnt].w=w;e[cnt].nxt=head[u];head[u]=cnt;
}
bool bfs(int s){
    while(!q.empty())q.pop();
    q.push(s);vis[s]=1;
    while(!q.empty()){
    int u=q.front();q.pop();
    for(int i=head[u];i;i=e[i].nxt){
        int v=e[i].to,w=e[i].w;
        if(vis[v]){
        if(del[u]+del[v]!=w)return 0;
        }else{
        del[v]=w-del[u];
        vis[v]=1;
        q.push(v);
        }
    }
    }
    return 1;
}
int main(){
    int T=read();
    while(T--){
    memset(vis,0,sizeof(vis));
    memset(head,0,sizeof(head));
    cnt=0;
    n=read(),m=read(),k=read();
    for(int i=1;i<=k;i++){
        int u=read(),v=read(),w=read();
        add(u,v+n,w);add(v+n,u,w);
    }
    bool ans=1;
    for(int i=1;i<=n+m;i++){
        if(!vis[i])ans&=bfs(i);
    }
    if(ans)puts("Yes");
    else puts("No");
    }
    return 0;
}
```


---

## 作者：cyffff (赞：3)

[$\text{Link}$](https://www.luogu.com.cn/problem/P4578)
## 题意
给出 $n\times m$ 的矩阵中 $k$ 个数，记为 $x_i,y_i,v_i$，问有没有序列 $p,q$ 满足 $v_i=p_{x_i}+q_{y_i}$。

$n,m,k\le1000$。
## 思路
学校模拟赛题，一眼差分约束，不过我忘了咋写。于是想出了一种不同的解法。

我们可以考虑行、列之间的差，如 $a_{i,j}=p_i+q_j,a_{i,j'}=p_i+q_{j'},a_{i,j}-a_{i,j'}=q_j-q_{j'}$。用这样的方法可以记录列与列之间的差，同理可以记录行与行之间的差，过程中，如果发现原先记录的与现在新发现的不一样，则为 `No`，否则为 `Yes`。

时间复杂度 $O(k^2)$。

上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N=1e3+10;
int T,n,m,k;
int cnt,mat[N][N],h[N][N],l[N][N];
inline void init(){
	memset(mat,-1,sizeof(mat));
	memset(h,-1,sizeof(h));
	memset(l,-1,sizeof(l));
}
struct point{
	int x,y,v;
}addi[N];
int main(){
	T=read();
	while(T--){
		n=read(),m=read(),k=read();
		init();
		bool fl=0;
		for(int i=1;i<=k;i++){
			int x=read(),y=read(),v=read();
			if((~mat[x][y])&&mat[x][y]!=v){
				puts("No");
				fl=1;
			}
			mat[x][y]=v;
			addi[i]=(point){x,y,v};
		}
		if(fl) goto nxt;
		for(int A=1;A<=k;A++){
			for(int B=1;B<=k;B++){
				if(A!=B){
					int i=addi[A].x,j=addi[A].y;
					int ii=addi[B].x,jj=addi[B].y;
					if(j==jj){
						if((~h[i][ii])&&h[i][ii]!=mat[ii][j]-mat[i][j]){
							puts("No");
							goto nxt;
						}else{
							h[i][ii]=mat[ii][j]-mat[i][j];
							h[ii][i]=mat[i][j]-mat[ii][j];
						}
						
					}
					if(i==ii){
						if((~l[j][jj])&&l[j][jj]!=mat[i][jj]-mat[i][j]){
							puts("No");
							goto nxt;
						}else{
							l[j][jj]=mat[i][jj]-mat[i][j];
							l[jj][j]=mat[i][j]-mat[i][jj];
						}
					}
				}
			}
		}
		puts("Yes");
		nxt:;
	}
	return 0;
}
```
再见 qwq~

---

## 作者：万万没想到 (赞：2)

原题传送门：[P4578 [FJOI2018]所罗门王的宝藏](https://www.luogu.com.cn/problem/P4578)

定义 $a[i][j]$ 为第 $i$ 行，第 $j$ 列的密码。

定义 $ val[i] ,(1 \leq i \leq n)$ 为第 $i$ 行的旋转次数，$ val[j] ,(n+1 \leq j \leq 2n)$ 为第 $j$ 列的旋转次数。左旋为正，右旋为负。

读题后，可以发现题目交代了我们的条件即为：对于给定的 $x,y,c$ ，设该组数据表示的即为 $a_{x,y}=c$ 并且 $val[x]+val[y+n]=c$ ，则我们发现这一个点将 $val[x]$ 与 $val[y+n]$ 联系起来。

考虑 $k$ 组数据就产生了 $k$ 组联系，每组只会将某一行与某一列联系起来，而行与行，列与列之间并无联系。用点描述行或列的 $val$ ，而用边描述这种联系，我们会发现，这构成了一个二分图。

采用无向边的连接方式，我们发现此图可分割成互不干涉的联通块。因此对每个联通块单独考虑，且只有当所有联通块有合法解是输出 $\text {Yes}$ ，否则为 $\text {No}$ 。

对联通块内的点，考虑从某一点 $u$ 开始，不妨设该点的 $val[u]$ 为 $m$ ，则该点所连另一点 $v$ 必须满足 $val[v]=c-m$ 其中 $c$ 为联系两个点的边的权值。

若 $v$ 之前未被访问过，我们将其记录下并继续进行深搜。若访问过，且与当前情况不冲突，即之前记录的 $val[u]$ 与目前本将赋值的相等，则不必遍历第二遍。否则产生冲突，无合法解。

我们考虑到每经过一条边， $m$ 的项只会乘上 $-1$ ，而剩下的只是常数项的加减，则可以想象到有合法解的结果就是对于每个点都能且仅能用 $m$ 写成以 $km+b$ 的形式，其中 $k \in \{ 1,-1 \}$ 。同时由于二分图的性质，我们知道了 $k$ 对于某一点也是确定的，则我们可以得知从任意一点出发都可以得到类似的结果。每个点都是平等的。

从而若一个联通块内有合法解，一定可以用以上的形式进行表达。同时该块内点的 $val$ 也一定含有 $m$ 。不妨取 $m=0$ ，这并不影响我们的操作，因为一条边连接的两个点是在二分图中，两点 $m$ 的 $k$ 恰好一正一负。

以上就是本题的解法，同时我们还可以发现，按照上文操作后，常数项的加减经历不超过 $2000$ 条边，这与数据范围中 $|c| \leq 1e6$ 恰好契合，即为我们只用开 $\text {int}$ 即可。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=2e3+5;
int T,n,m,k,cnt,val[MAXN],head[MAXN];
bool vis[MAXN],pas;
struct node{
	int to,nex,val;
}e[MAXN];
void add(int u,int v,int w){e[++cnt].to=v,e[cnt].val=w,e[cnt].nex=head[u],head[u]=cnt;}
void dfs(int u){
	vis[u]=1;
	for(int i=head[u];i;i=e[i].nex){
		int v=e[i].to;
		if(!vis[v])val[v]=e[i].val-val[u],dfs(v);
		else if(val[u]+val[v]!=e[i].val){pas=1;return;}
	}
}
int main(){
	int u,v,w;
	scanf("%d",&T);
	while(T--){
		memset(head,0,sizeof(head));
		memset(vis,0,sizeof(vis));
		cnt=0,pas=0;
		scanf("%d%d%d",&n,&m,&k);
		for(int i=1;i<=k;++i){
			scanf("%d%d%d",&u,&v,&w);
			add(u,v+n,w),add(v+n,u,w);
		}
		for(int i=1;i<=n;++i){
			if(!vis[i])val[i]=0,dfs(i);
		}
		if(pas)printf("No\n");
		else printf("Yes\n");
	}
	return 0;
}
```


---

## 作者：ccsc (赞：2)

本题不用多说，思路不是很好想，但是实现却是异常的简单；

思路：
	
   >针对于每一个数据：(x,y,c)把行列拆开，对于一个限制x,y,c，将x行到y列连边，定义边权为c。
   
   具体做法
   	
    >设节点1...2n，i∈1-n表示i行，i∈(n+1)-2n时表示i-n列


>当我们读到一颗绿宝石(x,y,k)时，就从x向y+n连一条权值为k的边

>当我们连完边后会发现给一行/一列增加a就相当于把与这个点相连的所有边权值增加a

>这个加边权可以转化为加点权
  
>然后dfs一遍，如果存在环的话显然必须要环上存在合法解，那么随便令一个东西为x，记录每个值为ax+b的形式，检查二分图是否合法。

那么按照这个思路进行求解，即可

code:
```cpp
/*
	Name: luogu P4578 [FJOI2018]所罗门王的宝藏
	Copyright: ccsc
	Author: ccsc
	Date: 15-10-19 11:42
	Description: 图论 
*/
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int x=0;
	bool f=0;
	char ch;
	ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')f=1;
		ch=getchar();
	}
	while(ch<='9'&&ch>='0'){
		x=(x<<3)+(x<<1)+(ch^48);
		ch=getchar();
	}
	return f?-x:x;
}
int n,m,k;
int a[2020],b[2020];
bool vis[2020];
struct pp{int v,nxt,w;}e[2020<<1];
int head[2020],cnt=1;
inline void add(int u,int v,int w){e[cnt]=(pp){v,head[u],w};head[u]=cnt++;}
bool f1=false;
void dfs(int u)
{
    vis[u]=true;if(!f1)return;
    for(int i=head[u];i;i=e[i].nxt)
    {
        int v=e[i].v,w=e[i].w;
        if(!vis[v])a[v]=-a[u],b[v]=w-b[u],dfs(v);
        else if(a[v]+a[u]!=0||b[u]+b[v]!=w){f1=false;return;}
    }
}
int main()
{
    int T=read();
    while(T--)
    {
        n=read();
		m=read();
		k=read();
		cnt=1;
        for(int i=1;i<=k;++i)
        {
            int x=read(),y=read(),d=read();
            add(x,y+n,d);add(y+n,x,d);
        }
        f1=true;
        for(int i=1;f1&&i<=n;++i)
            if(!vis[i])a[i]=1,b[i]=0,dfs(i);
        puts(f1?"Yes":"No");
        for(int i=1;i<=n+m;++i)vis[i]=false,head[i]=0;
    }
    return 0;
}
```


---

## 作者：破忆 (赞：1)

### 【题目大意】
有一个$n×m$的全$0$矩阵，可以给每行或每列增加或减少某个值，最后需要特定点满足特定值，问是否可行

------------

### 【分析】
令第i行增加的值为$f(i)$，第j列增加的值为$g(j)$

如果存在特定点$A_{i,j}$的值为$S$，需要$f(i)+g(j)=S$

把$f(i)$和$g(j)$都抽象成点$u,v$

就是在$u$和$v$之间连了一条边，使得$u$和$v$的点权和为$S$

那么建边之后遍历每条边判断是否可行即可

复杂度 $O(Tk)$

------------

### 【算法】
暴力

------------
### 【代码】
```
#include<bits/stdc++.h>
using namespace std;
const int maxn=1005,maxe=maxn<<1,maxt=maxe;
int t,n,m,k;
int tot,lnk[maxt];
struct edge{
	int to,nxt,s;
}e[maxe];
int read(){
	int ret=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}
bool vis[maxt];
int dis[maxt];
bool ans;
void clear(){
	ans=tot=0;
	memset(dis,0,sizeof dis);
	memset(vis,0,sizeof vis);
	memset(lnk,0,sizeof lnk);
}
void add_e(int x,int y,int z){
	e[++tot]=(edge){y,lnk[x],z};
	lnk[x]=tot;
}
bool DFS(int x,int s){//假设当前点x的点权为s
	vis[x]=1;
	dis[x]=s;
	for(int j=lnk[x];j;j=e[j].nxt){
		int y=e[j].to;
		if(vis[y]){
			if(e[j].s-dis[x]!=dis[y]) return 1;
		}//判断
		else{
			if(DFS(y,e[j].s-dis[x])) return 1; 
		}//继续搜索
        
	}
	return 0;
}
//其实就是spfa判环
int main(){
 	freopen("P4578.in","r",stdin);
 	freopen("P4578.out","w",stdout);
	t=read();
	while(t--){
		n=read(),m=read(),k=read();
		clear();
		for(int i=1;i<=k;i++){
			int x=read(),y=read()+n,z=read();
			add_e(x,y,z),add_e(y,x,z);//建边
		}
		m+=n;
		for(int i=1;i<=m;i++){
			if(vis[i]) continue;
			if(DFS(i,0)){
				ans=1;
				break;
			}
		}
		printf("%s\n",ans?"No":"Yes");
	}
	return 0;
}
```


---

## 作者：lytqwq (赞：1)

貌似和其他做法~~完全~~不一样

显然，如果可以把全零的阵列转化成要求的阵列，那么就可以把要求阵列转化成全零阵列，然后我们就要检查要求的阵列 怎么（能不能）转化成全零阵列。

首先想到，先确定纵的按钮，然后检查每行是不是一样，如果一样就可以通过转行的按钮使整行为零。

**如何确定纵的按钮？**

把a数组储存第x行y列的密码

对每行中有绿宝石的按钮的密码取最大值maxn，那么 _该行其他有绿宝石的按钮的所在列_ 都需要比最大值所在列少 $ maxn-a[x][y] $ ，同时最大值所在列比当前列多 $ maxn-a[x][y] $

其实就是差分约束然后SPFA判负环（应该是这个算法，我从书上接触过思想）

之后SPFA判负环就行了

如果你90分，可能是 [因为这个](https://www.luogu.com.cn/discuss/show/105388) ，可以if判断一下

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 1001
int n,m,T,k;
int a[N][N],b[N][N],c[N];
int cnt,Head[N],Next[N*N*2],V[N*N*2],W[N*N*2];
void add(int u,int v,int w)
{
	V[cnt]=v;
	W[cnt]=w;
	Next[cnt]=Head[u];
	Head[u]=cnt++;
}
int vis[N],dis[N];
int bo;
int SPFA(int u)
{
	if(bo)
	{
		return 0;
	}
	vis[u]=1;
	for(int i=Head[u];i!=-1;i=Next[i])
	{
		if(dis[V[i]]>dis[u]+W[i])
		{
			if(vis[V[i]]==1)
			{
				bo=1;
				return 0;
			}
			dis[V[i]]=dis[u]+W[i];
			SPFA(V[i]);
			if(bo==1)
			{
				return 0;
			}
		}
	}
	vis[u]=0;
	return 1;
}
int main()
{
	scanf("%d",&T);
	while(T--)
	{
		memset(Head,-1,sizeof(Head));
		memset(vis,0,sizeof(vis));
		memset(dis,0x7f,sizeof(dis));
		memset(a,0,sizeof(a));
		memset(b,0,sizeof(b));
		memset(c,0,sizeof(c));
		cnt=0;
		scanf("%d%d%d",&n,&m,&k);
		int no=0;
		for(int i=1;i<=k;i++)
		{
			int x,y,c;
			scanf("%d%d%d",&x,&y,&c);
			if(b[x][y]==1&&a[x][y]!=c)
			{
				no=1;
				printf("No\n");
				break;
			}
			b[x][y]=1;
			a[x][y]=c;
		}
		if(no)
		{
			continue;
		}
		memset(c,0,sizeof(c));
		for(int i=1;i<=n;i++)
		{
			int maxn=-99999999,name=-1;
			for(int o=1;o<=m;o++)
			{
				if(b[i][o]==1)
				{
					if(maxn<a[i][o])
					{
						maxn=a[i][o];
						name=o;
					}
				}
			}
			if(name==-1)
			{
				continue;
			}
			for(int o=1;o<=m;o++)
			{
				if(b[i][o]==1&&name!=o)
				{
					add(o,name,maxn-a[i][o]);
					add(name,o,a[i][o]-maxn);
				}
			}
		}
		int yes=0;
		for(int i=1;i<=m;i++)
		{
			if(dis[i]!=dis[0])
			{
				continue;
			}
			bo=0;
			dis[i]=0;
			int qwq=SPFA(i);
			if(qwq==0)
			{
				printf("No\n");
				yes=1;
				break;
			}
		}
		if(yes==1)
		{
			
		}
		else
		{
			printf("Yes\n");
		}
	}
}
```


AC情况： [https://www.luogu.com.cn/record/29051678](https://www.luogu.com.cn/record/29051678)


---

## 作者：OIerAlbedo (赞：1)

# 前言

看到题目之后,大惊,这不是差分约束系统吗,还很像模板题的样子,再一看题解,果然是差分约束系统,再想到今天做的题都是差分约束系统的,更加坚定了自己的想法，但是我不会差分约束系统呀，所以我只能用并查集了。
# 题意

每一行可以全部加一个数，每一列也可以全部加一个数，使其成为题目要求的矩阵。

# 初步思想

那么我们可以假设每一行加的数为$ -g[i] $,每一列的数为$ +g[j+n] $,那么题目的要求就是$ -g[i]+g[j+n]=a[i][j] $。也许有人要问为什么不用$ g[i]+f[j] $这样的形式，因为后面要用并查集维护要求。

# 正题

对于每一个 $ i,j,a[i][j] $ ，我们将$ i,j+n $进行连边，如果他们已经在一个连通块内，则判断先前已经求出的解与当前的答案是否相同。

而为什么他们在一个连通块内就可以得出答案呢?

我们对于$ G[i]-G[j]=x $与$ G[j]-G[k]=y $ 可得出$ G[i]-G[k]=x+y $

又对于$ G[i]-G[j]=x $与$ G[i]-G[k]=y $可得出$ G[k]-G[j]=x-y $

故对于一个联通块内的数都有这种关系，所以都可以得出。

也许有的人会认为，求出连通块有什么用？

现在就是答案，我们令$ dis[i]=g[i]-g[root(i)] $ $ dis[j]=g[j]-g[root(j)] $ 则 $ g[i]-g[j]=dis[i]-dis[j] $ 。

也许有的人说这是无用功，但是当有新边连进来时就有大用了。

这时对于$ dis[i]=g[i]-g[root(i)];dis[j]=g[j]-g[root(j)]; $

我们考虑将j所在的子树连到i所在的子树，那么这时候
$$

dis[root(j)]=g[root(j)]-g[root(i)]=g[j]-dis[j]+dis[i]-g[i]=v-dis[j]+dis[i]

$$

就可以改变了，这时候在用并查集改变下面的点就好了。

# 代码

```cpp
 #include<bits/stdc++.h>
 using namespace std;
 int r1,r2,e[20000],f[20000],n,m,q,T,x,y,z,i;
 bool flag;
 int find(int x)
 {
    if (f[x]==x) return x;
    int y=find(f[x]);e[x]+=e[f[x]];f[x]=y;return f[x];
 }
 int main()
 {
    cin>>T;
    for (;T;T--)
       {
       cin>>n>>m>>q;    
       for (i=1;i<=n+m;i++) 
            {
            f[i]=i;e[i]=0;
           }
        flag=true;
       for (;q;q--)
           {
            cin>>x>>y>>z;
            if (flag==true)
               {
            r1=find(x);r2=find(y+n);
            if (r1==r2)
                {
                    if (e[y+n]-e[x]!=z)
                        flag=false;   
                }
            else
                {
                    e[r2]=z-e[y+n]+e[x];f[r2]=r1;
                    find(x);find(y+n);
                }
            }
          }
        if (flag==false) cout<<"No"<<endl;
        else cout<<"Yes"<<endl;
       }
    return 0;
 }
```

---

## 作者：Y_B_Y (赞：0)

题意就是一个$n\times m$的矩阵,一开始全是零,你可以个每一行或每一列都加1或减1,要求特定区域的值与要求值相等

我们设$h_i$为第$i$行的数变化的多少,设$l_j$为第$j$列的数变化的多少,如果我们要求第$i$行,第$j$列的数为x,那么我们可以得到

$h_i+l_j=x~~$①

我们发现这个式子有两个未知数,我们可以尝试来划掉一个

假设我们还要求第$q$行,第$j$列的数为y,那么我们可以得到$h_q+l_j=y~~$②

①-② 得$l_i-l_j=x-y~~$

这种类型的式子如果你做过[P2294 [HNOI2005]狡猾的商人](https://www.luogu.com.cn/problem/P2294) ,你一定不陌生,所以做法就是**我们依这个式子建一条边,再反着加一条边,从超级源点出发,如果出现正环即无解,否则有解**,可以自己举几个例子理解(可以先做那道题,模型更简单,来学习)

那么如果没有"要求第$q$行,第$j$列的数为y",那么第$j$列只有第$i$行有要求,那么我们一定可以通过对第$j$列进行操作来满足它(因为第$j$列只有第$i$行有要求)

同理,我们还可以找行数不同,列数相等的来得到式子,这两种要各自建图和跑$\operatorname{SPFA}$/然后要都满足才是$\operatorname{Yes}$

注意事项:本题依这种方法图可能会比较大,数组开大一点

代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1100000;
int T,n,m,k,cnt[2],x[N],y[N],z[N],ft[2][N],nx[2][N],to[2][N],w[2][N],vis[2][N],dis[2][N],SUPER_POINT=1086;//x为行y为列z为所需值,visa用于判正环,SUPER_POINT为超级源点
bool inq[2][N];
queue<int> Q;
#define x xx//下面不小心用了x左类型,这里define掉
int spfa(int s,bool x) //x来区别这次跑那个
{
    for(int i=0;i<=max(n,m);i++) dis[x][i]=-0x3f3f3f3f,inq[x][i]=0;
    dis[x][s]=0;//起点可改
    inq[x][s]=1;//同上
    Q.push(s);//同上
    while(!Q.empty()) 
    {
       int now=Q.front();Q.pop();
       inq[x][now]=0;
       for(int i=ft[x][now];i;i=nx[x][i]) 
       {
           int toi=to[x][i],wi=w[x][i];
           if(dis[x][toi]<dis[x][now]+wi) 
           {
               dis[x][toi]=dis[x][now]+wi;
               if(!inq[x][toi]) 
               {
               	  vis[x][toi]++;
               	  if(vis[x][toi]>n) return 0;//出现正环
                  Q.push(toi);
                  inq[x][toi]=1;
               }
           } 
       }
    }
    return 1;
}
#undef x xx//取消define
inline long long read()
{
    char c=getchar();long long sum=0,f=1;
    while(!(c>='0'&&c<='9')) {if(c=='-') f=-1;c=getchar();}
    while(c>='0'&&c<='9') {sum=((sum<<1)+(sum<<3))+(c-'0');c=getchar();}
    return sum*f;
}
void add(bool a,int b,int c,int d)
{
	nx[a][++cnt[a]]=ft[a][b];
	ft[a][b]=cnt[a];
	to[a][cnt[a]]=c;
	w[a][cnt[a]]=d;
}
int main()
{
	T=read();
	while(T--)
	{
		cnt[0]=cnt[1]=0;
		memset(ft,0,sizeof(ft));memset(nx,0,sizeof(ft));memset(to,0,sizeof(ft));memset(w,0,sizeof(ft));memset(vis,0,sizeof(ft));//重置
		n=read();m=read();k=read();
		for(int i=1;i<=k;i++) x[i]=read(),y[i]=read(),z[i]=read();
		for(int i=1;i<=k;i++)
		  for(int j=1;j<=k;j++)
			{
				if(i==j) continue;
				if(x[i]==x[j]) add(0,y[i],y[j],z[i]-z[j]);
				if(y[i]==y[j]) add(1,x[i],x[j],z[i]-z[j]);//分别加边
			}
		for(int i=1;i<=m;i++) add(0,SUPER_POINT,i,0); 
		for(int i=1;i<=n;i++) add(1,SUPER_POINT,i,0); //连超级源点
		if((!spfa(SUPER_POINT,0))||(!spfa(SUPER_POINT,1))) printf("No\n");
		else printf("Yes\n");//要都满足才是yes
		TAIL:;
	}
}
```


---


# 【模板】2-SAT

## 题目描述

有 $n$ 个布尔变量 $x_1\sim x_n$，另有 $m$ 个需要满足的条件，每个条件的形式都是 「$x_i$ 为 `true` / `false` 或 $x_j$ 为 `true` / `false`」。比如 「$x_1$ 为真或 $x_3$ 为假」、「$x_7$ 为假或 $x_2$ 为假」。

2-SAT 问题的目标是给每个变量赋值使得所有条件得到满足。

## 说明/提示

$1\leq n, m\leq 10^6$ , 前 $3$ 个点卡小错误，后面 $5$ 个点卡效率。

由于数据随机生成，可能会含有（ 10 0 10 0）之类的坑，但按照最常规写法的写的标程没有出错，各个数据点卡什么的提示在标程里。

## 样例 #1

### 输入

```
3 1
1 1 3 0```

### 输出

```
POSSIBLE
0 0 0```

# 题解

## 作者：Anguei (赞：485)

## 什么是 2-SAT？
首先，把「2」和「SAT」拆开。SAT 是 Satisfiability 的缩写，意为可满足性。即一串布尔变量，每个变量只能为真或假。要求对这些变量进行赋值，满足布尔方程。

举个例子：教练正在讲授一个算法，代码要给教室中的多位同学阅读，代码的码风要满足所有学生。假设教室当中有三位学生：Anguei、Anfangen、Zachary_260325。现在他们每人有如下要求：

+ **Anguei**: 我要求代码当中满足下列条件之一：
  1. 不写 `using namespace std;` （ $\neg a$）
  2. 使用读入优化 （$b$）
  3. 大括号不换行 （$\neg c$）
+ **Anfangen**: 我要求代码当中满足下条件之一：
  1. 写 `using namespace std;` （$a$）
  2. 使用读入优化 （$b$）
  3. 大括号不换行 （$\neg c$）
+ **Zachary_260325**：我要求代码当中满足下条件之一：
  1. 不写 `using namespace std;` （$\neg a$）
  2. 使用 `scanf` （$\neg b$）
  3. 大括号换行 （$c$）
 
我们不妨把三种要求设为 $a,b,c$，变量前加 $\neg$ 表示「不」，即「假」。上述条件翻译成布尔方程即：$(\neg a\vee b\vee\neg c) \wedge (a\vee b\vee\neg c) \wedge (\neg a\vee\neg b\vee c)$。其中，$\vee$ 表示或，$\wedge$ 表示与。（就像集合中并集交集一样）

现在要做的是，为 ABC 三个变量赋值，满足三位学生的要求。

Q: 这可怎么赋值啊？暴力？

A: 对，这是 SAT 问题，已被证明为 **NP 完全** 的，只能暴力。

Q: 那么 2-SAT 是什么呢？

A: 2-SAT，即每位同学 **只有两个条件**（比如三位同学都对大括号是否换行不做要求，这就少了一个条件）不过，仍要使所有同学得到满足。于是，以上布尔方程当中的 $c,\neg c$ 没了，变成了这个样子：$(\neg a\vee b) \wedge (a\vee b) \wedge (\neg a\vee\neg b)$

## 怎么求解 2-SAT 问题？
**使用强连通分量。** 对于每个变量 $x$，我们建立两个点：$x, \neg x$ 分别表示变量 $x$ 取 `true` 和取 `false`。所以，**图的节点个数是两倍的变量个数**。**在存储方式上，可以给第 $i$ 个变量标号为 $i$，其对应的反值标号为 $i + n$**。对于每个同学的要求 $(a \vee b)$，转换为 $\neg a\rightarrow b\wedge\neg b\rightarrow a$。对于这个式子，可以理解为：「若 $a$ 假则 $b$ 必真，若 $b$ 假则 $a$ 必真」然后按照箭头的方向建有向边就好了。综上，我们这样对上面的方程建图：

| 原式 | 建图 |
| :----------- | :----------- |
| $\neg a\vee b$     | $a\rightarrow b\wedge\neg b\rightarrow\neg a$ |
| $a \vee b$         | $\neg a\rightarrow b\wedge\neg b\rightarrow a$ |
| $\neg a\vee\neg b\space \space $ | $a\rightarrow\neg b\wedge b\rightarrow\neg a$ |

于是我们得到了这么一张图：

![built](https://s1.ax1x.com/2018/08/22/PTAjy9.png)

可以看到，$\neg a$ 与 $b$ 在同一强连通分量内，$a$ 与 $\neg b$ 在同一强连通分量内。**同一强连通分量内的变量值一定是相等的**。也就是说，如果 $x$ 与 $\neg x$ 在同一强连通分量内部，一定无解。反之，就一定有解了。

但是，对于一组布尔方程，可能会有多组解同时成立。要怎样判断给每个布尔变量赋的值是否恰好构成一组解呢？

这个很简单，只需要 **当 $x$ 所在的强连通分量的拓扑序在 $\neg x$ 所在的强连通分量的拓扑序之后取 $x$ 为真** 就可以了。在使用 Tarjan 算法缩点找强连通分量的过程中，已经为每组强连通分量标记好顺序了——**不过是反着的拓扑序**。所以一定要写成 `color[x] < color[-x]` 。

时间复杂度：$O(N + M)$

## 说了这么多，咋不上代码啊？
核心代码在下面。
### 建图
```cpp
n = read(), m = read();
for (int i = 0; i < m; ++i) {
    // 笔者习惯对 x 点标号为 x，-x 标号为 x+n，当然也可以反过来。
    int a = read(), va = read(), b = read(), vb = read();
    if (va && vb) { // a, b 都真，-a -> b, -b -> a
        g[a + n].push_back(b);
        g[b + n].push_back(a);
    } else if (!va && vb) { // a 假 b 真，a -> b, -b -> -a
        g[a].push_back(b);
        g[b + n].push_back(a + n);
    } else if (va && !vb) { // a 真 b 假，-a -> -b, b -> a
        g[a + n].push_back(b + n);
        g[b].push_back(a);
    } else if (!va && !vb) { // a, b 都假，a -> -b, b -> -a
        g[a].push_back(b + n);
        g[b].push_back(a + n);
    }
}
```
当然，还有更精简的位运算建图方式，可以免去上面的四个 if：
```cpp
n = read(), m = read();
for (int i = 0; i < m; ++i) {
    int a = read(), va = read(), b = read(), vb = read();
    g[a + n * (va & 1)].push_back(b + n * (vb ^ 1));
    g[b + n * (vb & 1)].push_back(a + n * (va ^ 1));
}
```


### 找环
```cpp
// 注意所有东西都要开两倍空间，因为每个变量存了两次
void tarjan(int u) {
    low[u] = dfn[u] = ++dfsClock;
    stk.push(u); ins[u] = true;
    for (const auto &v : g[u]) {
        if (!dfn[v]) tarjan(v), low[u] = std::min(low[u], low[v]);
        else if (ins[v]) low[u] = std::min(low[u], dfn[v]);
    }
    if (low[u] == dfn[u]) {
        ++sccCnt;
        do {
            color[u] = sccCnt;
            u = stk.top(); stk.pop(); ins[u] = false;
        } while (low[u] != dfn[u]);
    }
}
// 笔者使用了 Tarjan 找环，得到的 color[x] 是 x 所在的 scc 的拓扑逆序。
for (int i = 1; i <= (n << 1); ++i) if (!dfn[i]) tarjan(i);
```
### 输出
```cpp
for (int i = 1; i <= n; ++i)
    if (color[i] == color[i + n]) { // x 与 -x 在同一强连通分量内，一定无解
        puts("IMPOSSIBLE");
        exit(0);
    }
puts("POSSIBLE");
for (int i = 1; i <= n; ++i)
    print((color[i] < color[i + n])), putchar(' '); // 如果不使用 Tarjan 找环，请改成大于号
puts("");
```

---

## 作者：暗ざ之殇 (赞：334)


## 关于 $2-SAT$ 的小总结，希望能帮助大家

### $Update$ $in$ $2020.9.11$ 改正了代码中的一些错误
也可以到我的 [$blog$](https://www.cnblogs.com/xcg123/p/11818059.html) 去看哦~
### $2-SAT$ 问题：

有 $n$ 个变量，每一个变量都是 $bool$ 类型的，除了这 $n$ 个变量以外，我们还有 $m$ 个关系表达式，关系表达式差不多是这样的：

$x_1$ & $x_2 = false$（注意每个表达式只会有两个变量）

问给出 $m$ 个关系表达式后，能否给这 $n$ 个变量找出一个赋值的方法，使得满足所有的表达式； 

### 建边方式：

核心问题只需要考虑有没有解；

对于每个变量都只有两种取值：$0 / 1$，那么对于每个点，我们把每个变量拆成 $true$ 点和 $false$ 点；

假如我们有一个关系：$x_1$ & $x_2 = false$；

**说明 $x_1$ 和 $x_2$ 中一定有一个为 $false$；**

那么我们可以从 $x_1$ 的 $true$ 连向 $x_2$ 的 $false$，从 $x_2$ 的 $true$ 连向 $x_1$ 的 $false$；
![](https://cdn.luogu.com.cn/upload/image_hosting/zxk71w4g.png)

**要注意只有关系明确的时候才能建边；**

解释一下为什么这么连边：

如果 $x_1$ 的值为 $true$ ，那么如果我们 $x_2$ 的值再为 $true$ 的话，就不满足 “ $x_1$ & $x_2 = false$ ” 这个式子了，所以如果 $x_1$ 为 $true$ 的话是能明确推出 $x_2$ 为 $false$ 的；

我们可以从 $x_2$ 的 $flase$ 向 $x_1$ 的 $true$ 连边吗？这样也能满足关系式；

显然不能，因为如果 $x_2$ 为 $false$ 的话，$x_1$ 为 $true$ 或 $ false$ 都是可以的，这不是明确的关系，我们不能建边；

所以一般的建边方式为：

若 “ $x_a = p$ 或 $x_b = q$ ” 中至少有一个满足，那么我们建两条有向边：

$x_a ($¬$p)  ->  x_b (q)$ 

$x_b ($¬$q)  ->  x_a (p)$ 

**可以简单总结为：其中一个不成立则另一个一定成立（这是明确的关系）；**

如果一个变量必须等于 $true$，那么我们从这个点的 $false$ 连向这个点的 $true$，表示我们从 $false$ 走也会走到 $true$，也就是说只能等于 $true$；

![](https://cdn.luogu.com.cn/upload/image_hosting/rrtjsq4h.png)


至于建边的时候怎么给点编号嘛，自定义喽，不过我建议大家这样编号（下面的代码都是这么编号的）：

![](https://cdn.luogu.com.cn/upload/image_hosting/zxksz5dh.png)

这样的话对于一个变量 $k$，编号为 $k$ 的点代表了这个变量的 $false$ 点，编号为 $k+n$ 的点代表了这个变量的 $true$ 点；

判解方式： 
这么判断是否有解？

**无解的情况：某一个变量的 $false$ 能走到 $true$，从 $true$ 也能走到 $false$，也就是说，某一个变量的两个取值在同一个强连通分量内的话，就说明无解。**

求强联通分量的话常用的方法是 $Tarjan$ 。

![](https://cdn.luogu.com.cn/upload/image_hosting/v7jlwp8x.png)

否则就是有解的情况，然后它一般让你输出一个给所有变量赋值的方法，使其满足所有的关系式；

那么怎么给变量赋值呢？我们来看一个图：

![](https://cdn.luogu.com.cn/upload/image_hosting/fu7ffw8d.png)


我们发现，从 $x_1$ 的 $false$ 出发会走到 $x_1$ 的 $true$ ，也就是说 $x_1$ 现在只能等于 $true$ 了；同理从 $x_2$ 的 $true$ 出发能走到 $x_2$ 的 $flase$，说明 $x_2$ 只能等于 $flase$；

解释一下吧：

如果我们不将 $x_1$ 赋值为 $true$，而是赋值为 $false$，那会发生什么呢？

由 $x_1$ 的 $false$ 是能明确推出 $x_2$ 是为 $true$ 的，但是又有 $x_2$ 的 $true$ 能明确推出 $x_1$ 为 $true$，这与刚刚我们将 $x_1$ 赋值为 $false$ 是相矛盾的；（你也可以这么理解：假如你在解方程，实在是解不出来了，你就来了个特殊值法，将 $x$ 代入 $1$ 试试看，结果解出来等式不成立，就说明 $x ≠ 1$）；

有了这个性质，就说明在有解的情况下，一个变量的两个取值是有前后推导关系的，也就是一个取值直接或间接的指向了另一个取值；

**我们所要选的就是被指向的这个取值，不然会产生像上例那样的矛盾；**

**在拓扑序上的表现为：我们要在两种取值中选择拓扑序较大的那个值；**

~~所以我们接下来要：缩点 + 拓扑 + 染色~~

**其实我们在 $Tarjan$ 的时候就已经求出了强联通分量的拓扑序了，只不过是反序；**

（以我的理解是拓扑序越大的点在一棵树上是越靠近叶节点的，然后越靠近叶节点的那些节点在 $Tarjan$ 的时候是越早被缩点的，所以拓扑序越大的点其所在强联通分量编号越小）

那么我们只要取两个取值中强联通分量编号较小的所对应的值就可以了；（这是保证不会错的，因为有时候两个值取哪个都行）

上代码喽：
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<vector>
using namespace std;
long long read()
{
    char ch=getchar();
    long long a=0,x=1;
    while(ch<'0'||ch>'9')
    {
        if(ch=='-') x=-x;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        a=(a<<1)+(a<<3)+(ch-'0');
        ch=getchar();
    }
    return a*x;
}
const int N=4e6+5;
int n,m,a,b,x,y,tim,top,edge_sum,scc_sum;
int dfn[N],low[N],st[N],vis[N],scc[N],head[N];
struct node
{
    int to,next;
}A[N];
void add(int from,int to)
{
    edge_sum++;
    A[edge_sum].next=head[from];
    A[edge_sum].to=to;
    head[from]=edge_sum;
}
void tarjan(int u)
{
    dfn[u]=low[u]=++tim;
    st[++top]=u;
    vis[u]=1;
    for(int i=head[u];i;i=A[i].next)
    {
        int v=A[i].to;
        if(!dfn[v])
        {
            tarjan(v);
            low[u]=min(low[u],low[v]);
        }
        else if(vis[v]) low[u]=min(low[u],dfn[v]);
    }
    if(dfn[u]==low[u])
    {
        scc_sum++;
        while(st[top]!=u)
        {
            scc[st[top]]=scc_sum;
            vis[st[top]]=0;
            top--;
        }
        scc[st[top]]=scc_sum;
        vis[st[top]]=0;
        top--;
    }
}
int main()
{
    n=read();m=read();
    for(int i=1;i<=m;i++)
    {
        a=read();x=read();  //第a个数为x或第b个数为y 
        b=read();y=read();
        if(x==0&&y==0)      //"如果第a个数为0或第b个数为0"至少满足其一 
        {
            add(a+n,b);     //a=1则b=0 
            add(b+n,a);     //b=1则a=0 
        }
        if(x==0&&y==1)      //"如果第a个数为0或第b个数为1"至少满足其一 
        {
            add(a+n,b+n);   //a=1则b=1 
            add(b,a);       //b=0则a=0 
        }
        if(x==1&&y==0)      //"如果第a个数为1或第b个数为0"至少满足其一
        {
            add(a,b);       //a=0则b=0 
            add(b+n,a+n);   //b=1则a=1 
        }
        if(x==1&&y==1)      //"如果第a个数为1或第b个数为1"至少满足其一
        {
            add(a,b+n);     //a=0则b=1 
            add(b,a+n);     //b=0则a=1 
        }
    }
    for(int i=1;i<=2*n;i++) //对每个变量的每种取值进行tarjan 
    {
        if(!dfn[i]) tarjan(i);
    }
    for(int i=1;i<=n;i++)   //判断无解的情况 
    { 
        if(scc[i]==scc[i+n]) //同一变量的两种取值在同一强联通分量里,说明无解 
        {
            printf("IMPOSSIBLE\n");
            return 0;
        }
    }
    printf("POSSIBLE\n");   //否则就是有解 
    for(int i=1;i<=n;i++)
    {
        if(scc[i]>scc[i+n]) printf("1 ");  //强联通分量编号越小 -> 拓扑序越大 -> 越优 
        else printf("0 ");
    }
    return 0;
}
```
还有一个几乎和模板题一样的~~水~~题，双倍经验，双倍欢乐$qwq$！

[$P4171 [JSOI2010]$满汉全席](https://www.luogu.org/problem/P4171)

谢谢大家的观看，觉得不错的点个赞呗$(((o(*ﾟ▽ﾟ*)o)))$

感谢 Chinese_zjc_ 提供的 $hack$ 数据，数据如下：

```
2 5
2 0 1 1
2 1 2 1
2 0 2 0
1 0 1 1
1 1 1 0
```
原先代码的问题是 $if(v==fa) continue;$ 这一语句导致了缩点过程中若两点间相互连了两条有向边，原先代码是无法将两点判断在同一个连通块内的，所以无法通过 $hack$ 数据。因此删掉之后就可以通过 $hack$ 数据了。

---

## 作者：TopCarry (赞：84)


果然没有Kosaraju的题解╮(╯_╰)╭。

&emsp;&emsp;事实上$tarjan$解$2-SAT$会很不自然，因为它的拓扑序其实是倒过来的，而$Kosaraju$就不会有这个烦恼，正好没人打，我来水一发。


&emsp;&emsp;考虑到这个优秀的冷门算法大多数人不用，所以简单介绍一下。

 关于Kosaraju

1. 代码不容易错
 
2. 思维上更好理解，更加自然。

3. 和$2-SAT$问题的原理上更加共通

 先上一波代码：
```cpp
void add(int x,int y){
	e[++tot].to=y;e[tot].next=head[x];head[x]=tot;
	e[++tot].to=x;e[tot].next=HEAD[y];HEAD[y]=tot;
}
```
```cpp
void dfs1(int u){
	int i;
	vis[u]=1;
	for(i=head[u];i;i=e[i].next)
		if(!vis[e[i].to])
			dfs1(e[i].to);
	turn[++cnt]=u;
}
void dfs2(int u){
	belong[u]=cnt;vis[u]=1;
	for(int i=HEAD[u];i;i=e[i].next)
		if(!vis[e[i].to])
			dfs2(e[i].to);
}
void kosaraju(){
	for(int i=1;i<=2*n;i++)
		if(!vis[i])dfs1(i);
	reset(vis);cnt=0;
	for(int i=2*n;i>=1;i--)
		if(!vis[turn[i]])
			cnt++,dfs2(turn[i]);
}
```
原理很简单：

1. 考虑无向图的缩点，对于每个强联通分量，只要从这个块任意一个点开始跑到没点可去就可以了。
2. 然而有向图不可以，设$A$，$B$为两个强联通分量，当$A->B$时，我们依然无脑跑，把跑到的缩一起，但是呢，如果我们从$A$中的点开始跑，就会把$A$和$B$缩一起，这是我们不希望的，所以我们考虑让他总会从$B$开始遍历。
3. 我们使用“逆后序”，即先遍历该点的出点，在把它丢进去，相当于是“每个点跑完的顺序”。

```cpp
void dfs1(int u){
	int i;
	vis[u]=1;
	for(i=head[u];i;i=e[i].next)
		if(!vis[e[i].to])
			dfs1(e[i].to);
	turn[++cnt]=u;
}
```
 这样做会有一个很棒的性质，模拟一波过程：
 
&emsp;&emsp;$(1).$从$A$开始跑，遍历顺序为:$A->B->$把$B$丢进栈$->$回溯到$A->$把$A$丢进栈。
 
&emsp;&emsp;$(2).$从$B$开始跑，遍历顺序为:跑完$B->$把$B$丢进栈$->$因为边的方向是$A$到$B$而到不了$A$，退出$->$发现$vis[A]=0->$跑$A->$把$A$丢进栈。

&emsp;&emsp;我们发现不管怎么样，栈顶都是A。
&emsp;&emsp;$4.$但是这个$A$很让人难受，相当于我们找到了一种方法，使栈顶永远都是那个不应该跑的点，这和第二条中的期望不符合诶。
 
&emsp;&emsp;5.于是我们建一个反图，对于$A$和$B$，他们依然都是强联通的(比如环反向了还是一个环)，但是$A->B$的边变成了$B->A$，而$A$在栈顶，这就很完美!现在我们像无向图一样无脑遍历一遍就$OK$了。

呼，总算是讲完了，那么开始正式讲一波2-SAT。

&emsp;&emsp;分析一波逻辑：

&emsp;&emsp;$1.<A=1$或者$B=1>$ $=$ $($当$A$不选,$B$一定得选;当$B$不选，$A$一定得选$)$
 
&emsp;&emsp;$2.<A=0$或者$B=0>$ $=($当$A$选，$B$一定不选;当$B$选,$A$一定不选$)$

&emsp;&emsp;$3.<A=0$或者$B=1>$ $=($当$A$选，$B$一定选;当$B$不选，$A$一定不选$)$

 $4.<A=1$或者$B=0>$ $=($当$A$不选，$B$一定不选；当$B$选,$A$一定选)


 &emsp;&emsp;这样一来，一个个令人不爽的“或者”就变成了可以确定的“一定”，我们就可以根据这个关系建图。

&emsp;&emsp;$tips$:当你把上面四句理解了，下面的代码应该也就可以看懂了，如果不理解把4种情况带进去看一看应该就清晰了。(在下方代码之中，$1-n$表示$1-n$决策选，$n+1-2n$表示$1-n$决策不选)
```cpp
for(i=1;i<=m;i++){
	x=read();f1=read();y=read();f2=read();
	add(x+n*(f1&1),y+n*(f2^1));
	add(y+n*(f2&1),x+n*(f1^1));
}
```
 &emsp;&emsp;为什么这个逻辑问题会和强联通分量沾上关系呢？

&emsp;&emsp;构建出了图之后，我们发现，若$A->B$代表选了决策$A$一定选决策$B$，那么我们如果这样指了一圈之后指到了相悖的决策，就像$A=1->B=1->A=0$，那么这个$2-SAT$肯定是无解的：
```cpp
for(i=1;i<=n;i++)
	if(belong[i]==belong[i+n]){
		cout<<"IMPOSSIBLE";return 0;
}
```

&emsp;&emsp;这个逻辑其实很好想，但是“如果没有这种情况即有解”这一结论又是怎么来的呢?
&emsp;&emsp;我们考虑这样一件事情：如果逻辑关系$A->B->C->D->A$存在，那么他们的“非”关系一定有$!D$$->$$!C$$->$$!B$$—>$$!A->!D$存在，如下图所示：
![](https://cdn.luogu.com.cn/upload/pic/50490.png)
 此时我们任取其中一组强联通分量就可以产生一组解了。
 &emsp;&emsp;但是事情往往不如人意，我们加一条$B->!C$，随之产生了$C->!B$:![](https://cdn.luogu.com.cn/upload/pic/50492.png )
&emsp;&emsp;那么 ($ABCD$全选) 和 ($ABCD$都不选) 两个“逻辑块”就不是任意取了，显然我们如果选 ($ABCD$全选) 这个块会出现问题。
 &emsp;&emsp;有没有觉得这一部分和之前的Kosaraju某一部分相似呢？
 &emsp;&emsp;怕你们懒得翻，帮你们回忆一下：
&emsp;&emsp;“$2.$然而有向图不可以，设$A$，$B$为两个强联通分量，当$A->B$时，我们依然无脑跑，把跑到的缩一起，但是呢，如果我们从$A$中的点开始跑，就会把$A$和$B$缩一起，这是我们不希望的，所以我们考虑让他总会从$B$开始遍历。”
 &emsp;&emsp;$2-SAT$原理是这样的：当出现强联通分量$A->B$的时候，我们要满足B的要求,也就是满足拓扑序更靠后的“联通块”的要求。(这和$Kosaraju$不是一样的:当遇到了$A->B$，先缩$B$)
 &emsp;&emsp;回忆一下$Kosaraju$干了什么事情：当$A->B$,$A$总是在栈顶，也就是说比$B$更早遍历，拓扑序更小，这真是太棒了!
&emsp;&emsp;在$Kosaraju$算法的实现当中，每个节点所属的强联通分量的编号其实就是他们的拓扑序，于是，当我们想知道$A$选不选，只需要比较$A$和$!A$所属联通块的编号就$OK$了，选择那个编号更大，即拓扑序更靠后的决策。
```cpp
cout<<"POSSIBLE\n";
	for(i=1;i<=n;i++){
		cout<<(belong[i]>belong[i+n])<<' ';
	}	
```
&emsp;&emsp;因为拓扑序较大的决策肯定不会和拓扑序较小的决策冲突，那么我们按照拓扑序，从后往前进行满足，在有解状态下一定可以找到一组可行解。
 &emsp;&emsp;至此 问题完美解决 当逻辑关系不止$4$个的时候只要修改建边方式就好。
&emsp;&emsp;完整代码如下：
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#define reset(a) memset((a),0,sizeof((a)))
using namespace std;
static char buf[100000],*pa,*pd;
#define gc pa==pd&&(pd=(pa=buf)+fread(buf,1,100000,stdin),pa==pd)?EOF:*pa++
inline int read(){
	register int x(0);register char c(gc);
	while(c>'9'||c<'0')c=gc;
	while(c>='0'&&c<='9')x=x*10+c-48,c=gc;
	return x;
}
const int N=4001000;
struct edge{
	int to,next;
}e[N];
int head[N],tot,HEAD[N];
int n,m,cnt,turn[N],belong[N],vis[N];
void add(int x,int y){
	e[++tot].to=y;e[tot].next=head[x];head[x]=tot;
	e[++tot].to=x;e[tot].next=HEAD[y];HEAD[y]=tot;
}
void dfs1(int u){
	int i;
	vis[u]=1;
	for(i=head[u];i;i=e[i].next)
		if(!vis[e[i].to])
			dfs1(e[i].to);
	turn[++cnt]=u;
}
void dfs2(int u){
	belong[u]=cnt;vis[u]=1;
	for(int i=HEAD[u];i;i=e[i].next)
		if(!vis[e[i].to])
			dfs2(e[i].to);
}
void kosaraju(){
	for(int i=1;i<=2*n;i++)
		if(!vis[i])dfs1(i);
	reset(vis);cnt=0;
	for(int i=2*n;i>=1;i--)
		if(!vis[turn[i]])
			cnt++,dfs2(turn[i]);
}
int main(){
	n=read();m=read();
	register int i,x,y,f1,f2;
	for(i=1;i<=m;i++){
		x=read();f1=read();y=read();f2=read();
		add(x+n*(f1&1),y+n*(f2^1));
		add(y+n*(f2&1),x+n*(f1^1));
	}
	kosaraju();
	for(i=1;i<=n;i++)
		if(belong[i]==belong[i+n]){
			cout<<"IMPOSSIBLE";return 0;
		}
	cout<<"POSSIBLE\n";
	for(i=1;i<=n;i++){
		cout<<(belong[i]>belong[i+n])<<' ';
	}	
	return 0;
}
```

---

## 作者：Great_Influence (赞：56)

# $2-sat$

$k-sat$问题大概就是多个$01$变量之间存在$k$元限制求合法解的问题。其中，$k$元限制指的是:

$$x_{p_1}\oplus x_{p_2}\oplus x_{p_3}\cdots\oplus x_{p_k}=a$$

其中，$a$是$0$或者$1$，而$\oplus$是某一种二元$bool$操作。

$k>2$的情况已被证明是$NP$问题，目前只能够暴力枚举来解决。

而当$k=2$时，存在$O(nm)$和$O(n+m)$两种常用做法。$O(nm)$的做法可以用来解决关于最小字典序解的问题。因为无法通过此题，所以在此只描述$O(n+m)$的算法。

因为条件是二元的，因此每个限制都只会涉及$2$个变量。这启发我们使用图论来解决这个问题。我们将每个变量都拆成$2$个，分别表示该变量$=0$和$=1$的情况。再定义边$(u,v)$表示选择$u$就必须选择$v$。那么，我们可以直接将问题转化成以下$3$种情况:

(以下为了方便，用$x_{i,a}$表示第$i$个变量选择$a$的点，$(u,v)$表示$u$到$v$的边，$\otimes$表示异或)

### 1. $x_i=a$ ,则 $x_j=b$

建边$(x_{i,a},x_{j,b})$,$(x_{j,b\otimes1},x_{i,a\otimes1})$

意义显然。如果$x_i=a$，那么$x_j=b$。如果$x_j!=b$，那么$x_i!=a$。

### 2. $x_i=a$ 与 $x_j=b$ 至少满足一个

建边
$(x_{i,a\oplus1},x_{j,b})$,$(x_{j,b\oplus1},x_{i,a})$

同样十分显然。如果$x_i!=a$,那么$x_j=b$。如果$x_j!=b$，那么$x_i=a$。

### 3. $x_i=a$ 一定满足

建边$(x_{i,a\oplus1},x_{i,a})$

考虑该操作的意义。首先可以知道，$x_{i,0}$和$x_{i,1}$必须选择且仅选择一个。那么，因为$x_i=a$一定满足，则$x_i!=a$的点不可以取。那么，直接建边$(x_{i,a\oplus1},x_{i,a})$可以控制$x_{i,a\oplus1}$这个点一定不可选择，否则无解。

可以证明，以上$3$种情况囊括了所有可能的多元限制。其余限制可以通过转化变成以上$3$种。

经过操作后，你就得到了一张有向图。开始考虑这张图的作用。

首先，对于这张图中的每个强连通分量中的点一定要么同时选，要么同时不选。

那么，我们将图缩强连通分量。

这时候就可以判断无解了。如果$x_{i,0}$和$x_{i,1}$在同一个强连通分量中，那么明显无解。

此时，你就得到了一张拓扑图。这张拓扑图中，如果$u$可以到达$v$，那么$u$选择则$v$也必须选择。

那么，你可以利用强连通分量的标号来得到**反向的拓扑序**。

再结合上面的性质，可以得到一个选择策略:

在$x_{i,0}$和$x_{i,1}$中选择拓扑序较大的点。

这样就可以避免产生冲突了。并且这种方法一定可以构造出解。

这样$2-sat$求解就完成了。其瓶颈在强连通分量的处理，利用$Tarjan$可以做到$O(n+m)$已抵达输入下界。因此，时间复杂度为$O(n+m)$。

## 核心代码:

```cpp
static int dfn[MAXN<<1],low[MAXN<<1],bel[MAXN<<1];
static int e,cnt,sta[MAXN<<1],tp;

void tarjan(int u)
{
	dfn[u]=low[u]=++e;sta[++tp]=u;
	for(register int v:ed[u])
	{
		if(!dfn[v])tarjan(v),Chkmin(low[u],low[v]);
		else if(!bel[v])Chkmin(low[u],dfn[v]);
	}
	if(low[u]==dfn[u])for(++cnt;sta[tp+1]^u;--tp)
		bel[sta[tp]]=cnt;
}

inline void solve()
{
	Rep(i,2,n<<1|1)if(!dfn[i])tarjan(i);
	Rep(i,1,n)if(bel[i<<1]==bel[i<<1|1])return (void)puts("IMPOSSIBLE");
	puts("POSSIBLE");
	Rep(i,1,n)write(bel[i<<1]>bel[i<<1|1],' ');
}
```

---

## 作者：Piwry (赞：33)

貌似少有题解解释 “取拓扑序较大者” 这步的正确性，于是这里就补充个简短的证明

另外在我查阅资料时，还发现有以 wiki 为代表的另一种 2-sat 做法，主要区别在最后一步；由于没什么实现价值，这里就不展开了。有兴趣可以参考 [“2-SAT 解法浅析”](https://www.oschina.net/uploads/doc/sat2_sjtu_zhaoshuang.pdf), [wiki(en)](https://en.wikipedia.org/wiki/2-satisfiability)

## 解析

### Part 0 - 导入

一般我们求解 2-sat 的过程为：

1. 建图（具体略）
2. 对图求出强联通分量，并求出缩点后的拓扑序
3. 若存在对应同一个变量的两个结点在同一个分量内，即无解
4. 否则一定有解；对每个变量取所在分量拓扑序较大的那个对应结点，一定能构造出一组合法解

其中不太显然的地方主要在 $\text{4.}$

### Part 1 - 引理

设变量 $x_i$ 对应的结点为 $u_{i, p}, p\in \{0, 1\}$

先考虑这样一个引理：

> 引理 $1.$ 若存在边 $(u_{i, p}, u_{j, q})$，那么一定对应地存在边 $(u_{j, q\text{ xor }1}, u_{i, p\text{ xor }1})$

考虑我们建图的连边规则，这是显然的（即若有要求 「$x_i=b_1$ 或 $x_j=b_2$」，那么 $x_i$ 对应的不满足要求的结点（$u_{i, b_1\text{ xor }1}$）就会向 $x_j$ 对应的满足要求的结点（$u_{j, b_2}$）连一条有向边；另一条边亦然）

更进一步地，有如下引理：

> 引理 $2.$ 若存在路径（单向）$p(u_{i, p}, u_{j, q})$，那么一定对应地存在路径 $p(u_{j, q\text{ xor }1}, u_{i, p\text{ xor }1})$

对路径上每一条边运用 $\text{引理 1.}$ 即可得到

### Part 2 - 证明

再考虑我们算法的 $\text{4.}$；不妨用反证法证明其正确性

记 $f(u_{i, p})$ 表示 $u_{i, p}$ 所在分量的（缩点后的）拓扑序

设有 $f(u_{i, p})<f(u_{i, p\text{ xor }1}) [1], f(u_{j, q})>f(u_{j, q\text{ xor }1}) [2]$，且存在路径（单向）$P_1=p(u_{j, q}, u_{i, p})$。显然这由我们的算法会得到一个非法的结果

考虑 $\text{引理 2.}$，得出也存在路径 $P_2=p(u_{i, p\text{ xor }1}, u_{j, q\text{ xor }1})$。由 $P_1$ 可推出 $f(u_{j, q})<f(u_{i, p}) [3]$，由 $P_2$ 可推出 $f(u_{i, p\text{ xor }1})<f(u_{j, q\text{ xor }1}) [4]$。联立 $[1], [3], [4]$ 可得 $f(u_{j, q})<f(u_{j, q\text{ xor }1})$，这和作为前提的 $[2]$ 是矛盾的；由此可推得算法的 $\text{4.}$ 是正确的

（这部分作图可能会更直观w）

## CODE

仅供参考

```cpp
#include <cstdio>
#include <algorithm>
using std::min;

/*------------------------------IO------------------------------*/

namespace IO_number{
	int read(){
		int x =0; char c =getchar(); bool f =0;
		while(c < '0' || c > '9') (c == '-') ? f =1, c =getchar() : c =getchar();
		while(c >= '0' && c <= '9') x =(x<<1)+(x<<3)+(48^c), c =getchar();
		return (f) ? -x : x;
	}
	
	void write(const int &x){
		if(x/10)
			write(x/10);
		putchar('0'+x%10);
	}
}
using namespace IO_number;

/*------------------------------Graph------------------------------*/

const int MAXN =1e6+20;

int first[MAXN<<1], tote;
struct edge{
	int to, nxt;
}e[MAXN<<1];

inline void addedge(const int &u, const int &v){
	++tote, e[tote].to =v, e[tote].nxt =first[u], first[u] =tote;
}

/*------------------------------Tarjan------------------------------*/

int scc_id[MAXN<<1], Scc_id;

int dfn[MAXN<<1], low[MAXN<<1], Dfn;
int stk[MAXN<<1], stk_top;
bool instk[MAXN<<1];

void tarjan(const int &u){
	low[u] =dfn[u] =++Dfn;
	stk[stk_top++] =u;
	instk[u] =1;
	for(int l =first[u]; l; l =e[l].nxt){
		if(!dfn[e[l].to]){
			tarjan(e[l].to);
			low[u] =min(low[u], low[e[l].to]);
		}
		else if(instk[e[l].to])
			low[u] =min(low[u], dfn[e[l].to]);
	}
	if(low[u] == dfn[u]){
		++Scc_id;
		while(stk[stk_top] != u){
			scc_id[stk[stk_top-1]] =Scc_id;
			instk[stk[stk_top-1]] =0;
			--stk_top;
		}
	}
}

/*------------------------------Main------------------------------*/

int main(){
	int n =read(), m =read();
	for(int t =0; t < m; ++t){
		int i =read(), a =read(), j =read(), b =read();
		/* [1, n] -> false, [n+1, 2n] -> true */
		// x_i, x_j 均不满足不能同时成立 //
		addedge(i+(a^1)*n, j+b*n);
		addedge(j+(b^1)*n, i+a*n);
	}
	
	for(int i =1; i <= 2*n; ++i){
		if(!dfn[i])
			tarjan(i);
		if(i <= n && scc_id[i] == scc_id[i+n])
			return puts("IMPOSSIBLE") && 0;
	}
	puts("POSSIBLE");
	for(int i =1; i <= n; ++i)
		write((scc_id[i+n] < scc_id[i])), putchar(' ');
}
```

---

## 作者：happyZYM (赞：18)

将每一个点$x_i$拆成$2i$和$2i+1$（$2i$表示$x_i$的假状态，$2i+1$表示$x_i$的真状态），问题就化为了从2n个状态中选出原来的每一个$x_i$的一个状态。

这有什么用呢？别急，先举个栗子，“1 1 3 0”就可以用有向边 2->6 7->3 来表示，什么意思呢？2表示1为false，根据规则可得3一定为false（也就是6），7表示3为true，根据规则可得1一定为true。那么就可以对这个有向图的每个连通分量（不一定是强连通的）进行dfs处理，并加上剪枝、回溯就行了，细节见代码。

```cpp
// luogu-judger-enable-o2
#include<cstdio>
#include<vector>
using namespace std;
template<typename T> inline void read(T& t)
{
    t=0; bool f=false; char ch;
    while(ch=getchar(),!((ch>='0'&&ch<='9')||ch=='-'));
    if(ch=='-') f=true,ch=getchar();
    t=ch-'0';
    while(ch=getchar(),ch>='0'&&ch<='9') t=t*10+ch-'0';
    if(f) t=-t;
}
template<typename T,typename... Args> inline void read(T& t,Args&... args) { read(t); read(args...); }
const int maxn=1e6+7;
struct TwoSAT
{
    int n;
    vector<int> G[maxn*2];
    bool mark[maxn*2];
    int S[maxn*2],c;
    bool dfs(int x)
    {
        if(mark[x^1]) return false;
        if(mark[x]) return true;
        mark[x]=true;
        S[c++]=x;
        for(int i=0;i<G[x].size();i++)
            if(!dfs(G[x][i])) return false;
        return true;
    }
    //x = xval or y = yval
    void add_clause(int x,int xval,int y,int yval)
    {
        x=x*2+xval;
        y=y*2+yval;
        G[x^1].push_back(y);
        G[y^1].push_back(x);
        //一个不满足一定能推出另一个满足
    }
    bool solve()
    {
        for(int i=0;i<n*2;i+=2)
            if(!mark[i]&&!mark[i+1])//没被访问过
            {
                c=0;
                if(!dfs(i))
                {
                    while(c>0) mark[S[--c]]=false;
                    //回溯
                    if(!dfs(i+1)) return false;
                    //true/false都不行那就无药可救了
                }
            }
        return true;
    }
}Ago;
int m,x,xval,y,yval;
int main()
{
#ifdef local
    freopen("pro.in","r",stdin);
#endif
    read(Ago.n,m);
    while(m-->0)
    {
        read(x,xval,y,yval);
        Ago.add_clause(x,xval,y,yval);
    }
    if(!Ago.solve()) printf("IMPOSSIBLE\n");
    else
    {
        printf("POSSIBLE\n");
        for(int i=1;i<=Ago.n;i++)
            if(Ago.mark[i<<1]) printf("0 ");
            else printf("1 ");
        printf("\n");
    }
    return 0;
}
```

---

## 作者：kuansoudafahao (赞：16)

## $2-SAT$问题

我们发现，题目的要求是在两个条件中任选一个满足。也就是说，如果我们不选A条件，就必须要选B条件；同理，我们不选B条件，就必须要选A条件。

现在，我们假设边(A,B)表示选了A条件，就必须要选B条件。那么根据上面的推论，我们发现现在我们应该连边(非A条件，B条件)，(非B条件，A条件)。

这个时候我们能发现，如果A条件和非A条件在同一个强连通分量里面，证明选了A条件之后我们就要选非A条件，这自相矛盾。这个时候无解。

顺便给大家推荐几道相关的题目：

[JSOI2010满汉全席](https://www.luogu.org/problemnew/show/P4171)

[POJ2723](http://poj.org/problem?id=2723)

```c++
#include <cstdio>
#define min(a,b) (a<b?a:b)

const int maxn=1e6+10;
struct EDGE
{
	int t,next;
}edge[maxn<<2];
int head[maxn<<1],low[maxn<<1],dfn[maxn<<1],stack[maxn<<1],scc[maxn<<1];
bool in[maxn<<1];
int cur,n,tim,top,cnt,m;

void add(int u,int v)
{
	edge[++cur].t=v;
	edge[cur].next=head[u];
	head[u]=cur;
}

void tarjan(int u)
{
	low[u]=dfn[u]=++tim;
	stack[top++]=u;in[u]=true;
	for(int i=head[u]; i; i=edge[i].next)
	{
		int v=edge[i].t;
		if(!dfn[v])
		{
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}else	if(in[v])
			low[u]=min(low[u],dfn[v]);
	}
	if(low[u]==dfn[u])
	{
		int v;
		cnt++;
		do
		{
			v=stack[--top];
			in[v]=false;
			scc[v]=cnt;
		}while(u!=v);
	}
}

bool two_SAT()
{
	for(int i=1; i<=2*n; i++)
		if(!dfn[i])
			tarjan(i);//tarjan找强连通分量 
	for(int i=1; i<=n; i++)
		if(scc[i]==scc[i+n])//a条件和非a条件在同一个强连通分量，原问题无解 
			return false;
	return true;
}

int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1; i<=m; i++)
	{
		int a,b,aval,bval;
		scanf("%d%d%d%d",&a,&aval,&b,&bval);
		int nota=aval^1,notb=bval^1;//这里我用a表示条件a选0的情况，a+n表示条件a选1的情况。 
		add(a+nota*n,b+bval*n);//连边(非a，b) 
		add(b+notb*n,a+aval*n);//连边(非b，a) 
	}
	if(two_SAT())
	{
		printf("POSSIBLE\n");
		for(int i=1; i<=n; i++)
			printf("%d ",scc[i]>scc[i+n]);
	}else
		printf("IMPOSSIBLE");
	return 0;
}
```

---

## 作者：Mobius127 (赞：13)

来一波非 $Tarjan$ 的题解。

基本建图可以去按照其他题解去做，这里不再阐述。

考虑使用~~冰茶几~~并查集去做缩点。

当搜到一个未搜到的点时继续往下搜，当重复走到到一点，时，我们就将我们所在的节点并入目标节点中，走完后将点深度标记为负。最后存在于同一并查集中的点形成一个环。

缩点程序如下：

```cpp
void dfs(int pos){
    for(int i=h[pos]; i; i=edge[i].nxt){
        int to=edge[i].to;
        if(!dep[to]){
            dep[to]=dep[pos]+1;
            dfs(to);
        }
        if(dep[find(to)]>0){
            if(dep[find(pos)]<dep[f[to]]) 
                f[f[to]]=f[pos];
            else f[f[pos]]=f[to];
        }
    }
    dep[pos]=-1, top_mark[pos]=++cnt;//记拓扑序
}
```

这时你就会有疑问：这样不会出错吗？

解答：因为我们每一次都是将深度大的点并入深度小的点中，这样就会使得即使在深度大的点退栈后，环上的节点仍能找到其的祖先节点（即环中最先被遍历的节点），巧妙的转化了缩点的技巧。

判断无解时，直接去找是否有同一点出于一个环上即可。

输出一组解时，优先选择拓扑序较大的即可。

### Code

```cpp
#include <stdio.h>
#include <algorithm>
#include <string.h>
#define N 2000005
using namespace std;
inline int read(){
	char ch;int x=0, f=1;ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return x*f;
}
int h[N], tot;
struct Edge{
	int to, nxt;
}edge[N*5];
void add(int x, int y){
//	printf("%d %d\n", x, y);
	edge[++tot].to=y, edge[tot].nxt=h[x];
	h[x]=tot;
}
int n, m;
int f[N], dep[N], top_mark[N], cnt;
int find(int x){return f[x]=x==f[x]?f[x]:find(f[x]);}
void dfs(int pos){
    for(int i=h[pos]; i; i=edge[i].nxt){
        int to=edge[i].to;
        if(!dep[to]){
            dep[to]=dep[pos]+1;
            dfs(to);
        }
        if(dep[find(to)]>0){
            if(dep[find(pos)]<dep[f[to]]) 
                f[f[to]]=f[pos];
            else f[f[pos]]=f[to];
        }
    }
    dep[pos]=-1, top_mark[pos]=++cnt;
}
int main(){
	n=read(), m=read();
	for(int i=1; i<=2*n; i++) f[i]=i;
	for(int k=1; k<=m; k++){
		int i=read(), a=read(), j=read(), b=read();
		add(i+n*(a&1), j+n*(b^1));add(j+n*(b&1), i+n*(a^1));
	}
	for(int i=1; i<=2*n; i++) if(!dep[i]) dfs(i);
    for(int i=1; i<=n; i++)
        if(find(i)==find(i+n)) return printf("IMPOSSIBLE")*0;
    printf("POSSIBLE\n");
    for(int i=1; i<=n; i++){
        int i_=i+n;
        if(top_mark[find(i)]<top_mark[find(i_)])
            printf("%d ", 1);
        else printf("%d ", 0);
    }
	return 0;
}
```


---

## 作者：caojia (赞：13)

### 前言（feihua）
SAT是适定性(Satisfiability)问题的简称 。一般形式为k-适定性问题，简称 k-SAT

可以证明，当k>2时，k-SAT是NP完全的。因此一般讨论的是k==2的情况，即2-SAT问题。


------------

2-SAT用处 ：有若干个包含2个元素的集合，只能选择每个集合中的一个元素，并给出一些条件（例：选a后不能选b），要求求出满足这些条件的选择，这个解也称为2-SAT的解

####  如何求解？

![](https://cdn.luogu.com.cn/upload/image_hosting/yvpf7xam.png?x-oss-process=image/resize,m_lfit,h_170,w_225)
如上图，为{A,A'},{B,B'},{C,C'}这几个集合

若给出条件，{A,B'},{B‘C’}不能同时选择

因为{A,A'},{B,B'},{C,C'}中，每个集合都要选出一个元素，即不能同时选择

又因为{A,B'}不能同时选择，则选择B‘时，一定选择A’，于是在B‘，A’之间连上一条有向边（因为选A‘不一定B’）；同理，在选B时也一定选A

其它也同上处理，于是：
![](https://cdn.luogu.com.cn/upload/image_hosting/or7mztck.png?x-oss-process=image/resize,m_lfit,h_170,w_225)
接着再进行缩点，然而这个栗子中没有可缩的点，判断对称的两点是否在同一个强连通分量中，若在，则无解

若不在，我们接着应该求出符合要求的解，如何求呢

1.进行拓扑排序（不用了）我们可以发现，缩点后强连通分量的编号就是反着的拓扑排序

为什么要拓扑排序呢？比如一个样例，它让A->B->A'，显然我们不能选A，只能选A’（拓扑排序大的），即选强连通分量编号小的

2.对于每一个集合，选出强连通分量小的

上AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int head[2000006],zhan[2000006],color[2000006],dfn[2000006],low[2000005];
int num,Color,dfx,top;
bool pd[2000005];
struct{
    int to,next;
}a[2000006];
void lian(int from,int to){
    num++;
    a[num].to=to;
    a[num].next=head[from];
    head[from]=num;
}
void tarjan(int x){
    int i;
    dfn[x]=low[x]=++dfx;zhan[++top]=x;
    pd[x]=1;
    for(i=head[x];i;i=a[i].next){
        if(pd[a[i].to]==0){
            tarjan(a[i].to);
            low[x]=min(low[x],low[a[i].to]);
        }
        if(color[a[i].to]==0)low[x]=min(low[x],dfn[a[i].to]);
    }
    if(low[x]==dfn[x]){
        Color++;
        do{
            i=zhan[top];top--;
            color[i]=Color;
        }while(low[i]!=dfn[i]);
    }
}
int main(){
    int n,m,i,j,a,_a,b,_b;
    scanf("%d%d",&n,&m);
    for(i=1;i<=m;i++){
        scanf("%d%d%d%d",&a,&_a,&b,&_b);
        if(_a==0&&_b==0)lian(a+n,b),lian(b+n,a);
        else if(_a==1&&_b==0)lian(a,b),lian(b+n,a+n);
        else if(_a==0&&_b==1)lian(a+n,b+n),lian(b,a);
        else lian(a,b+n),lian(b,a+n);
    }
    for(i=1;i<=2*n;i++){
        if(color[i]==0)tarjan(i);
    }
    for(i=1;i<=n;i++){
        if(color[i]==color[i+n]){
            printf("IMPOSSIBLE\n");
            return 0;
        }
    }
    printf("POSSIBLE\n");
    for(i=1;i<=n;i++){
        if(color[i]<color[i+n])printf("0 ");
        else printf("1 ");
    }
    return 0;
}
```


---

## 作者：Tenshi (赞：11)

# 目录
> 简介

> 做法

> 代码

## 简介
k-SAT（全称Satisfiability）问题，具体来说，给定 $n$ 个具有真假的**命题**，给一些**逻辑关系**（例如 $p_1 \vee p_2$），如果逻辑关系式子包含 $k$ 个元，要求出 $n$ 个命题的真假值满足所有逻辑关系。当 $k>3$ 时，已经被证明为 $NPC$ 问题，但是 $k=2$ 时可以使用线性复杂度的算法解决，所以我们在这重点讨论 2-SAT 问题。

## 做法
注意到这样一个事实：$a\vee b \Leftrightarrow \neg a \rightarrow b$ ，同理，$a\vee b \Leftrightarrow \neg b \rightarrow a$ 。（详细可以参考数理逻辑）

> $\rightarrow$ 被称为**蕴含**

如果将 $n$ 个命题看成 $2n$ 个点，然后利用上面的事实建边的话，就可以转化为图论问题求解了。

具体来说，例如，有命题 $p_1,p_2$ ，逻辑关系为 $p_1\vee p_2$ ，我们将 $p_1$ 拆成两个状态（图论中相应的两个点） $x_1, \neg x_1$ ，分别表示 $p_1$ 取**真**、取**假**，$p_2$ 用相同方式处理，那么逻辑关系可以转化为图论中的两条**有向**边：$(\neg x_1, x_2),~(\neg x_2, x_1)$ 。

用这样的方式，就可以将所给的**命题**以及**逻辑关系**转化为一个**有向图**了。

对这个有向图，我们采用 $SCC缩点$ ，如果一个命题的两个状态 $x_i,~\neg x_i$ 同时出现在同一个强连通分量中，问题无解（因为不可能有 $x_i$ 直接或间接地蕴含 $\neg x_i$）

否则，$x_i,~\neg x_i$ 所在的强连通分量编号一定存在严格的偏序关系（通俗地说就是一定是一大一小），我们取编号小的那个状态作为命题 $p_i$ 的取值即可。

下面简单说明这样取即可保证正确：

假如 $\neg a \rightarrow b$，由**逆否命题**性质，一定有 $\neg b \rightarrow a$ ，如果说 $\neg a$ 和 $b$ 在同一强连通分量中，那么 $\neg b$ 和 $a$ 一定在另一强连通分量中，不妨设 $a$ 所在的强连通分量编号较小，我们选取了 $a$ 。由强连通分量性质，$a$ 与 $\neg b$ 可以相互到达，所以 $\neg b$ 一定要被选取，而事实上由构造方式知 $\neg b$ 一定是被选取的，因此这样做能够保证正确性。

具体细节参见代码。

在实现中，我们采取 tarjan 算法求强连通分量。

[模板题](https://www.luogu.com.cn/problem/P4782)

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;

inline void read(int &x) {
    int s=0;x=1;
    char ch=getchar();
    while(ch<'0'||ch>'9') {if(ch=='-')x=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') s=(s<<3)+(s<<1)+ch-'0',ch=getchar();
    x*=s;
}

const int N=2e6+5, M=2e6+5;
int n, m;

struct node{
	int to, next;	
}e[M];

int h[N], tot;

void add(int u, int v){
	e[tot].to=v, e[tot].next=h[u], h[u]=tot++;
}

int ts, dfn[N], low[N];
int stk[N], top;
int id[N], cnt;
bool ins[N];

void tarjan(int u){
	dfn[u]=low[u]=++ts;
	stk[++top]=u, ins[u]=true;
	for(int i=h[u]; ~i; i=e[i].next){
		int go=e[i].to;
		if(!dfn[go]){
			tarjan(go);
			low[u]=min(low[u], low[go]);
		}else if(ins[go]) low[u]=min(low[u], dfn[go]);
	}
	
	if(dfn[u]==low[u]){
		int y;
		cnt++;
		do{
			y=stk[top--], ins[y]=false, id[y]=cnt; 
		}while(y!=u);
	}
}

int res[N];

int main(){
	memset(h, -1, sizeof h);
	read(n), read(m);
	
	while(m--){
		int i, a, j, b; read(i), read(a), read(j), read(b);
		i--, j--;
		add(2*i+!a, 2*j+b), add(2*j+!b, 2*i+a);
	}
	
	for(int i=0; i<2*n; i++) if(!dfn[i]) tarjan(i);
	
	for(int i=0; i<n; i++) if(id[2*i]==id[2*i+1]){
		puts("IMPOSSIBLE");
		return 0;
	}else res[i]= id[2*i]>id[2*i+1];
	
	puts("POSSIBLE");
	for(int i=0; i<n; i++) printf("%d ", res[i]);
	cout<<endl;
	
	return 0;
}
```


---

## 作者：小蒟蒻皮皮鱼 (赞：6)

## 引入：

相信大家都了解过差分约束系统。差分约束系统的大体意思就是给出一些有某种关系的变量，问你是否有某种赋值使得这些关系全部成立

其实$2-SAT$的题目描述和这个很像（~~虽然解法不一样~~）

那么$2-SAT$到底是什么呢？

通俗一点来说，就是有$n$个bool变量$x_1$~$x_n$有$m$个位运算的表达式（只有两个变量），求是否有一种方法使得$m$个表达式都成立
$$\ $$
## 例题

[洛谷P4782](https://www.luogu.org/problem/P4782)

### 题目背景

2-SAT 问题 模板

### 题目描述

有$n$个布尔变量$x_1$~$x_n$，另有$m$个需要满足的条件，每个条件的形式都是"$x_i$为true/false"或"$x_j$为true/false"。比如"$x_1$为真或$x_3$为假"、"$x_7$为假或$x_2$为假"。2-SAT 问题的目标是给每个变量赋值使得所有条件得到满足。

### 输入格式

第一行两个整数n和m，意义如体面所述。

接下来m行每行4个整数$ i ,a, j, b $，表示"$x_i$为a或$x_j$为b"($a,b\in \{0,1\}$​)

### 输出格式

如无解，输出"IMPOSSIBLE"（不带引号）; 否则输出"POSSIBLE"（不带引号),下一行$n$个整数（$x_1$~$x_n$$\in \{0,1\}$），表示构造出的解。
$$\ $$
## 如何解决这类问题？

首先，我们发现一个变量取值的真和假是相对独立的，也就是说和他自己没有关系，只和其他变量的真假有关系

那我们不妨为每一个变量建两个节点，一个表示真，一个表示假（我这里用1~n表示假，n+1~2n表示真）

有了点，考虑怎么连边。如果一个变量的真假能够推出另一个变量的真假，就对这两个变量对应的真假连边

比如：$x_1$为真或$x_2$为假，那么$x_1$的假就可以推出$x_2$的真，$x_2$的真就可以推出$x_1$的假

那么就把$x_1$对应的假节点连向$x_2$对应的真节点，把$x_2$对应的真节点连向$x_1$对应的假节点

如何判断有没有解？

考虑无解的情况，肯定是出现了矛盾，也就是一个点的真推出了它自己的假，或者是这个点的假推出了它自己的真。这种情况有什么特征？

发现如果是这样的话，这个点的真和假一定在相同的强连通分量里面

强联通分量？那不就是tarjan吗？

时间复杂度O(n+m)

那么怎么找出满足题意的解？

**当$x$所在的强连通分量的拓扑序在$\neg x$之后时，直接取$x$为真就行了**。tarjan算法在执行的过程中已经为每一个强连通分量标好了拓扑序（**不过是和正常的拓扑序相反**）

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2000050;

int head[N],ecnt;//1~n存0,n+1~2n存1 
struct edge
{
	int to,nxt;
}edg[N<<1];

inline void add(int u,int v)
{
	edg[++ecnt].to=v;
	edg[ecnt].nxt=head[u];
	head[u]=ecnt;
}

int n,m;

inline void read()
{
	for(int i=1;i<=m;i++)
	{
		int x,a,y,b;
		scanf("%d%d%d%d",&x,&a,&y,&b);//建边 
		if(a==1&&b==1) add(x,y+n),add(y,x+n);
		if(a==0&&b==1) add(x+n,y+n),add(y,x);
		if(a==1&&b==0) add(x,y),add(y+n,x+n);
		if(a==0&&b==0) add(x+n,y),add(y+n,x);
	}
}
//tarjan
int dfn[N],low[N],in[N],s[N],scc[N],top,ind,cnt;

void tarjan(int x)
{
	low[x]=dfn[x]=++ind;
	s[top++]=x;
	in[x]=1;
	for(int i=head[x];i;i=edg[i].nxt)
	{
		int v=edg[i].to;
		if(!dfn[v])
		{
			tarjan(v);
			low[x]=min(low[x],low[v]);
		}
		else if(in[v]) low[x]=min(low[x],dfn[v]);
	}
	if(dfn[x]==low[x])
	{
		cnt++;
		while(s[top]!=x)
		{
			top--;
			in[s[top]]=0;
			scc[s[top]]=cnt;
		}
	}
}

int main()
{
	scanf("%d%d",&n,&m);
	read();
	for(int i=1;i<=2*n;i++)
	{
		if(!dfn[i]) tarjan(i);
	}
	for(int i=1;i<=n;i++) if(scc[i]==scc[i+n]) return cout<<"IMPOSSIBLE",0;
	puts("POSSIBLE");
	for(int i=1;i<=n;i++) printf("%d ",scc[i]>scc[i+n]);
}
```

---

## 作者：yzc2005 (赞：4)

# 一、说明

## $1.$ 问题背景
有 $N$ 个布尔变量 $x_1,x_2...x_n$。

给出一些**一元或者二元**限制关系。

$2-SAT$ 问题是要确定 $N$ 个布尔变量的值，使得其满足所有限制关系。
## $2.$ 构建图论模型
建立 $2N$ 个点的有向图：

$i$ 表示 $x_i=false$

$i'=i+n$ 点表示 $x_i=true$

一条 $u->v$ 的有向边表示**如果选择了 $u$，那么一定要选择 $v$。**

$2-SAT$ 有解当且仅当 $\forall{i}$，**从 $i$ 点出发不能到达 $i'$ 点，或从$i'$ 点出发不能到达 $i$ 点。**

利用 $Kosaraju$ 算法求出强连通分量即可。如果 $\exists{i}$，使得 $i$ 和 $i'$ 在同一个强连通分量里则无解，否则有解。

输出方案：如果从 $i$ 点出发可以到达 $i'$ 点，则选了 $i$ 会导致选 $i'$，矛盾，因此只能选 $i'$。故取 $i$ 和 $i'$ 在逆后序中**靠后**的一个即可。
## $3.$ 限制的构图方法
### $(1)$ 一元限制：

以 $u=true$ 为例，

$u->u'$，使 $u_{false}$ 不可行，于是只能选择 $u_{true}$。
### $(2)$ 二元限制：

注意原命题**与其逆否命题**都要连！！

#### $(i)$ $u$ $or$ $v=true$
若 $u$ 为假，则 $v$ 为真：连边 $u->v'$。

若 $v$ 为假，则 $u$ 为真：连边 $v->u'$。

#### $(ii)$ $u$ $or$ $v=false$
$u$ 为假：连边 $u'->u$。

$v$ 为假：连边 $v'->v$。

#### $(iii)$ $u$ $and$ $v=false$
若 $u$ 为真，则 $v$ 为假：连边 $u'->v$。

若 $v$ 为真，则 $u$ 为假：连边 $v'->u$。
#### $(iiii)$ $u$ $and$ $v=true$
$u$ 为真：连边 $u->u'$。

$v$ 为真：连边 $v->v'$。

#### $(iiiii)$ $u!=v$
**若 $u$ 为真，则 $v$ 为假：连边 $u'->v$。**

**若 $u$ 为假，则 $v$ 为真：连边 $u->v'$。**

**若 $v$ 为真，则 $u$ 为假：连边 $v'->u$。**

**若 $v$ 为假，则 $u$ 为真：连边 $v->u'$。**


#### $(iiiiii)$ $u==v$
**若 $u$ 为真，则 $v$ 为真：连边 $u'->v'$。**

**若 $u$ 为假，则 $v$ 为假：连边 $u->v$。**

**若 $v$ 为真，则 $u$ 为真：连边 $v'->u'$。**

**若 $v$ 为假，则 $u$ 为假：连边 $v->u$。**


呼，总而言之，先把一切有可能的命题都列出来，再观察其逆否命题是否已经包含。

## $4.$ 模板
```

const int N = 2e6 + 5, M = 2e6 + 5;
struct Graph {
	int to[M], nxt[M], head[M], cnt;
	inline void add(int u, int v) {
		to[++cnt] = v;
		nxt[cnt] = head[u];
		head[u] = cnt;
	}
} G1, G2;
inline void add_edge(int u, int v) {
	G1.add(u, v);
	G2.add(v, u);
}

int n, m, h, b[N], q[N], cnt, tot, id[N][2], pos[N];

void dfs1(int u) {
	b[u] = 1;
	go(G2, u) if(!b[v]) dfs1(v);
	q[++tot] = u;
}

void dfs2(int u, int c) {
	b[u] = c;
	go(G1, u) if(!b[v]) dfs2(v, c);
}

int main() {
	read(n), read(m);
	fu(k, 0, 1) fu(i, 1, n) id[i][k] = ++cnt;  
	for(int i = 1, u, x, v, y; i <= m; ++i) {
		read(u), read(x), read(v), read(y);
		add_edge(id[u][!x], id[v][y]);
		add_edge(id[v][!y], id[u][x]);
	}
	fu(u, 1, cnt) if(!b[u]) dfs1(u); reset(b);
	fd(i, cnt, 1) if(!b[q[i]]) dfs2(q[i], q[i]);
	fu(i, 1, n) if(b[id[i][0]] == b[id[i][1]]) finish(puts("IMPOSSIBLE"));
	puts("POSSIBLE");
	fu(i, 1, cnt) pos[q[i]] = i; 
	fu(i, 1, n) printf("%d ", pos[id[i][0]] > pos[id[i][1]] ? 0 : 1);
	return 0;
}
```









---

## 作者：Xie_BR (赞：3)

### ~~我不会告诉你我在这道题上死了多少次。。。~~

废话不多说，这道题是一个2-SAT的模板题（不知道2-SAT是什么的小伙伴可以去网上找找，Xie_BR在此不做过多的解释）  

### 首先  
对于2-SAT来说，Xie_BR建议使用   
  # Tarjan + Topsort  
这是很好很好的方法，简单明了，~~只有200行~~  

先建边，通过逻辑推理，发现1或0的关系原来可以这么建边：  
```cpp
int x,a,y,b;
scanf("%d%d%d%d",&x,&a,&y,&b);
if(a)
{
	if(b)
	{
		add(x+n,y);
		add(y+n,x);
	}else
	{
		add(y,x);
		add(x+n,y+n);
	}
}else
{
	if(b)
	{
		add(x,y);
        add(y+n,x+n);
	}else
	{
		add(x,y+n);
		add(y,x+n);
	}
}
```

然后我们需要通过tarjan+缩点合并环，最后计数。

# 在此十分感谢spj！！！

最后，我们来看看  
# AC代码：  
```cpp
#include<bits/stdc++.h>
#define MK 5000010
using namespace std;
int n,m;

struct edge
{
	int to,next,f;
}e[MK*2];

int h[MK],ei = 0;

void add(int x,int y)
{
	ei++;
	e[ei].to = y;
	e[ei].f = x;
	e[ei].next = h[x];
	h[x] = ei;
}

stack<int>st;
int dfn[MK],cnt[MK],stindex = 0,tmindex = 0,indegree[MK];
int low[MK],team[MK],col[MK];

void tarjan(int f)
{
	stindex++;
	low[f] = dfn[f] = stindex;
	st.push(f);
	for(int i=h[f];i;i=e[i].next)
	{
		int to = e[i].to;
		if(dfn[to]==0)
		{
			tarjan(to);
			low[f] = min(low[f],low[to]);
		}else
		{
			if(team[to]==0)
			{
				low[f] = min(low[f],dfn[to]);
			}
		}
	}
	if(low[f] == dfn[f])
	{
		tmindex++;
		while(1)
		{
			int top = st.top();
			st.pop();
			team[top] = tmindex;
			cnt[tmindex]++;
			if(top==f)
			{
				break;
			}
		}
	}
	return; 
}

int opt[MK];

int check()
{
	for(int i=1;i<=n;i++)
	{
		if(team[i]==team[i+n])
		{
			return 0;
		}
		opt[team[i]] = team[i+n];
		opt[team[i+n]] = team[i];
	}
	return 1;
}

void suodian()
{
	memset(h,0,sizeof(h));
	int newei = ei;
	ei = 0;
	for(register int i=1;i<=newei;i++)
	{
		int f = e[i].f;
		int to = e[i].to;
		if(team[f]==team[to])
		{
			continue;
		}
		indegree[team[f]]++;
		add(team[to],team[f]);
	}
	return;
}

void topsort()
{
	queue<int>qu;
	for(int i=1;i<=tmindex;i++)
	{
		if(indegree[i]==0)
		{
			qu.push(i);
		}
	}
	while(!qu.empty())
	{
		int f1 = qu.front();
		qu.pop();
		if(col[f1]==0)
		{
			col[f1] = 1;
			col[opt[f1]] = 2;
		}
		for(int i=h[f1];i;i=e[i].next)
		{
			int to = e[i].to;
			indegree[to]--;
			if(indegree[to]==0)
			{
				qu.push(to);
			}
		}
	}
	return;
}

void out()
{
	printf("POSSIBLE\n");
	for(int i=1;i<=n;i++)
	{
		if(col[team[i]]==1)
		{
			printf("1 ");
		}else
		{
			printf("0 ");
		}
	}
	return;
}

void dotarjan()
{
	for(int i=1;i<=2*n;i++)
	{
		if(!dfn[i])
		{
			tarjan(i);
		}
	}
	return;
}

signed main()
{
	scanf("%d%d",&n,&m);
	while(m--)
	{
		int x,a,y,b;
		scanf("%d%d%d%d",&x,&a,&y,&b);
		if(a)
		{
			if(b)
			{
				add(x+n,y);
				add(y+n,x);
			}else
			{
				add(y,x);
				add(x+n,y+n);
			}
		}else
		{
			if(b)
			{
				add(x,y);
				add(y+n,x+n);
			}else
			{
				add(x,y+n);
				add(y,x+n);
			}
		}
	}
	dotarjan();
	if(!check())
	{
		printf("IMPOSSIBLE\n");
		return 0;
	}
	suodian();
	topsort();
	out();
	return 0;
} 
```

不多不多，也就200行。  
蒟蒻的想法可能和幼稚，大佬指教啊啊啊啊啊啊啊啊啊！！！

---

## 作者：Zxsoul (赞：2)

# 浅谈2-SAT

## 前言

> 最近也是刚刷到，学了两个小时，分享一下我对它的理解

## 概念

**2-SAT** 拆开可以从字面上大体了解，即：满足条件数量为2的情况下得到的可行性最优解。

它的对象一般都是我们高中学的逆否命题，例如：

- 若 $P$ 则 $Q$ , 和 若非 $P$ 则非 $Q$

  上述又称做**逆否命题**，待会讲解是会用到

- 真切的例子：有你没我，有我没你！

在 2-SAT 问题中，我们总能把 $M$ 统一转化为 “若变量 $A_i$ 赋值为 $A_i,p$ ，则变量 $A_j$ 就必须赋值为 $A_j,q$， 其中 $p,q$ 均为我们常用的$true,false$ ”

## 建边

回想一下高中概率统计那一部分，我们学过概率的计算，那么它表示什么
$$
\mathfrak{A}\ P(a+b)=a\lor b

$$
$$
 \mathfrak{B}\ b.\ P(ab)=a\land b
$$

- $\mathfrak{A}$ 表示 $a,b$ 两个事件中至少有一个发生
- $\mathfrak{B}$ 表示 $a,b$ 两个事件同时发生

有了数学的理解，我们的建边会有新的台阶

- 建立 $2N$ 个节点的有向图，每个变量 $A_i$ 对应着两个节点，分别为 $i$ 和 $i + N$
  - 都是两个点的原因是一个事件存在正反两面，即上述我们所说的**逆否命题**，他的正面成立，自然反面也必然成立，若不能理解，请自行百度了解**逆否命题**，（此处的正面与反面非广义）
- 当考虑条件时，让一对**有关联**的两个点建立有向边
  - 什么叫**有关联**呢，很简单，如果 $A$ 成立，那么对应 $B$ 的也一定成立，我们称此叫关联。最真切的例子就是，”今天你要登洛谷“，那么 “打卡” 这一事件 $B$ 是你接下来一定要做的，类似的，都可以这么理解，存在必然性

- 那么**有向边**的**指向**呢？ 存在关联的问题定有前后顺序，即只有先发生 $A$, 才回先发生 $B$,就如 先有您父亲，再有您一样，那么具体点就是由"父亲"向“儿子”建边，如果倒过来，却没有逻辑

- 说一下列出数学概念的意义，在题中，限制条件是一个广泛的层面，而满足这个条件的有多种情况，所以我们可以利用**概率思想**全面的建边。

## 实现

`Tarjan` 算法是个不错的选择，因为它可以寻找请连通分量，强连通分量里存在我们需要的可行解。

**无解:** 如果一个事件的正反面都在同一个强联通分量里的，即你吃了苹果，可你又没吃苹果，这很冤，所以这是矛盾的，自然不存在可行解.

## 时间复杂度

保证所有的 $2N$ 点都要被 `tarjan` 所以为：
$$
O(N+M)
$$

## 可行解选择策略

我比较喜欢用拓扑序，即我们在`tarjan`时用来标记强连通分量的数组

因为 `tarjan` 的本质就是深搜，所以拓扑序按点从小到大排的话，拓扑序是由大到小的，即搜索树越深的点，拓扑序越小

因此我们可以通过比较**拓扑序**得到可行解，不同的题对于大小的不一样，

我认为，注意是我认为，如果否命题可以连向真命题，那么拓扑序大的记录答案，反之记录小的。讲解完毕！

## Code

```c
#include <cmath>
#include <queue>
#include <cstdio>
#include <vector>
#include <cstring>
#include <iostream>
#include <algorithm>
#define ll long long
using namespace std;

const int A = 1e5 + 11;
const int B = 5 *1e6 + 11;
const int mod = 1e9 + 7;
const int inf = 0x3f3f3f3f;

inline int read() {
  char c = getchar();
  int x = 0, f = 1;
  for ( ; !isdigit(c); c = getchar()) if (c == '-') f = -1;
  for ( ; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);
  return x * f;
}
vector<int> e[B];
int vis[B];
int mon[B], cnt, n, m, low[B], dfn[B], lt[B], sum, ans, dis[B], st[B], top;
int x[B], y[B], vx[B], s, p;
void tarjan(int u){
  low[u] = dfn[u] = ++cnt, st[++top] = u;
  for (int i = 0; i < e[u].size(); i++){
    int v = e[u][i];
    if(!dfn[v]){ tarjan(v); low[u] = min(low[u], low[v]);}
    else if(!lt[v]) low[u] = min(low[u], dfn[v]);
  }
  if(dfn[u] == low[u]){
    sum++; 
    while(st[top] != u) {lt[st[top--]] = sum;}
    lt[st[top--]] = sum;
  }
}
int main() {
// freopen("a.in", "r", stdin);
//  freopen(".out", "w", stdout);
  n = read(), m = read();
  for(int i = 1; i <= m; i++){
     int x, a, y, b;
     cin >> x >> a >> y >>b;
     e[x + n * (a ^ 1)].push_back(y + n * (b & 1));
     e[y + n * (b ^ 1)].push_back(x + n * (a & 1));  
  }
  for(int i = 1; i <= (n << 1); i++) if(!dfn[i]) tarjan(i);
  for(int i = 1; i <= n; i++)
       if(lt[i] == lt[i + n]) 
        {
            cout << "IMPOSSIBLE" << "\n";
            return 0;
        }
  cout << "POSSIBLE" << endl;
  for(int i = 1; i <= n; i++) printf("%d ", lt[i] > lt[i + n]);
  return 0;
}


```

作者 $@Tzy$ 

转载请标明出处、	

---

## 作者：Push_Y (赞：2)

### 前言

今天上图论课，老师给我们做 **2-SAT** 、 二分图 、 网络流 的**复习**。然而我都没预习过！于是学习完 **2-SAT** 来一波题解啦。

### 2-SAT是什么

N个 **bool** 变量 $x[1...N]$，若干个约束，每个约束形如：$x[i]=0/1$ 和 $x[j]=0/1$ 不能同时成立。问是否存在一个赋值使约束成立。

其他博客里的讲解，都有很多初中生看着苦恼的符号，我就说的通俗一点吧。

>校长要给同学们排一节他们想上的课，并且满足每个人的至少一点需求。

>甲想要上王老师的数学课。
>
>乙想要上王老师的体育课。

这里面上王老师的课是一个约束，数学课、体育课是一个约束。

### 怎么解决 2-SAT

前置技能：$Tarjan$

把一个点分成两份。$u$ -> $u+ , u-$ 。对约束进行分类。这题里具体如下代码。由于分成两个点不大好表示，就表示成 $u , u+n$。
```cpp
        if(x==0&&y==0){
            add(a+n,b);
            add(b+n,a);
        }
        else if(x==0&&y==1){
            add(a+n,b+n);
            add(b,a);
        }
        else if(x==1&&y==0){
            add(a,b);
            add(b+n,a+n);
        }
        else if(x==1&&y==1){
            add(a,b+n);
            add(b,a+n);
        }
```

怎么判断是否有解呢？`Tarjan` 以后，如果一个点 $u$ 和 $u+n$ 属于一个连通块，那就不可能了。

```cpp
	for(int i=1;i<=n;i++){
		if(co[i]==co[i+n]){
			puts("IMPOSSIBLE");
			exit(0);
		}
	}
```

否则即有解。然后输出就很简单了。
```cpp
	puts("POSSIBLE");
	for(int i=1;i<=n;i++){
		if(co[i]>co[i+n])printf("1 ");
		else printf("0 ");
	}
```

### 结合代码


```cpp
#include <bits/stdc++.h>
using namespace std;

inline int gin(){//快读
	char c=getchar();
	int s=0,f=1;
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		s=(s<<3)+(s<<1)+(c^48);
		c=getchar();
	}
	return s*f;
}

const int N=4e6+5;
int n,m,top,num,col,dfn[N],low[N],st[N];
int head[N],ne[N],to[N],co[N],tot; 
//co[i]表示点i属于的连通块，其他数组名为常规

inline void add(int u,int v){//前向星连边，没有边权
	to[++tot]=v;
	ne[tot]=head[u];
	head[u]=tot;
}

void tarjan(int u){//做一遍Tarjan，求出每个点所在的连通块。
	dfn[u]=low[u]=++num;
	st[++top]=u;
	for(int i=head[u],v;i;i=ne[i]){
		v=to[i];
		if(!dfn[v]){
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}
		else if(!co[v])
			low[u]=min(low[u],dfn[v]);
	}
	if(dfn[u]==low[u]){
		co[u]=++col;
		while(st[top]!=u){
			co[st[top]]=col;
			top--;
		}
		top--;
	}
}

int main(){
	n=gin(),m=gin();
	for(int i=1;i<=m;i++){
        int a=gin(),x=gin();
        int b=gin(),y=gin();
        //分类。还有一种需要推很久的位运算压成两行代码，题解区里有，我是推不出来了。
        if(x==0&&y==0){
            add(a+n,b);
            add(b+n,a);
        }
        else if(x==0&&y==1){
            add(a+n,b+n);
            add(b,a);
        }
        else if(x==1&&y==0){
            add(a,b);
            add(b+n,a+n);
        }
        else if(x==1&&y==1){
            add(a,b+n);
            add(b,a+n);
        }
	}
	for(int i=1;i<=2*n;i++)
		if(!dfn[i])tarjan(i);
	for(int i=1;i<=n;i++){
		if(co[i]==co[i+n]){
			puts("IMPOSSIBLE");
			exit(0);
		}
	}
	puts("POSSIBLE");
	for(int i=1;i<=n;i++){
		if(co[i]>co[i+n])printf("1 ");
		else printf("0 ");
	}
	return 0;
}

```


---

## 作者：GoPoux4 (赞：2)

> SAT 是适定性（Satisfiability）问题的简称。一般形式为 k - 适定性问题，简称 k-SAT。而当 $k>2$ 时该问题为 NP 完全的。所以我们只研究 $k=2$ 的情况。
>
> ——摘自 _OI-Wiki_ 

2-SAT问题大多是固定的模型：

给定若干个均有两个元素的集合，为了方便，我们称集合 $i$ 中一个元素为 $A_i$ ，另一个元素为 $A_i'$ 。现在给出若干限制条件，如选择 $A_i$ 就不能选择 $A_j$ ，选择 $A_i$ 就必须选择 $A_j$ 等（其中 $i \not= j$ ）。询问是否存在一种方案，能够在满足限制条件的同时从每一个集合中都选出**一个**元素。

发现**一个限制条件只和两个集合**有关，于是我们可以考虑将这种关系抽象成图上的边，将集合中对立的两个元素抽象成点。

若现在有这样一个限制：选择 $A_i$ 就不能选择 $A_j$ 。那么如果选择 $A_i$ 就必须选择 $A_j'$ ，选择 $A_j$ 就必须选择 $A_i'$ 。对于这样的限制，连边 $A_i \to A_j'$ 和 $A_j \to A_i'$ 。于是图中的边有了具体意义：$u \to v$ 的边表示若选 $u$ 则必选 $v$ 。

不难发现，若一个点 $u$ 被选择，则 $u$ 所能到达的点均必须被选择。这个性质明显与**连通性**相关。

于是有了一个结论：**若一个点 $u$ 被选择，那么与 $u$ 在同一个强连通分量中的点均必须被选择。**

这句话说明**同一个强连通分量中的点取或不取的状态是一致的**。

这样就能判断是否有解了：若同一个集合中的两个元素在同一个强连通分量中，则问题无解。很显然，若 $A_i$ 和 $A_i'$ 要么同时选，要么都不选，则不满足题设。

求出强连通分量后判断无解：

```cpp
for(int i=1;i<=n;++i)
	if(scc[i]==scc[i+n])
	{
		puts("IMPOSSIBLE");
		return 0;
    }
```

---

但是有些题不止让你判断有无解，还让你输出可行解，这就需要用到**拓扑排序**。

设 $S_i$ 表示 $A_i$ 所在的强连通分量，$S_i'$ 表示 $A_i'$ 所在的强连通分量。

推广一下上面对于单点的结论：**若一个强连通分量 $S$ 被选择，则 $S$ 所能到达的强连通分量均必须被选择**。

先考虑这样一种情况： $S_i$ 与 $S_i'$ 联通，并且假设 $S_i$ 的拓扑序小于 $S_i'$ 的拓扑序。则必然有：若 $S_i$ 被选择，则 $S_i'$ 必须被选择。那肯定不能选 $S_i$ 了，因为 $S_i$ 和 $S_i'$ 必然不能同时选。这样我们就确定了选择方案。

而 $S_i$ 与 $S_i'$ 不连通的话，上面的方法就不行了，因为没法确定选择方案，而一个看起来满足要求的方案可能会对其他的强连通分量产生影响，而枚举方案肯定复杂度爆炸。

我们尝试将两种情况进行统一，即选择 $S_i$ 和 $S_i'$ 中拓扑序大的那个强连通分量。而这样选择其实是正确的，来简单证明一下：

由最初的连边方式可知，得出的图是对称的：

![aqViHP.png](https://s1.ax1x.com/2020/08/10/aqViHP.png)

所以缩点后的DAG也是对称的：

![aqVNv9.png](https://s1.ax1x.com/2020/08/10/aqVNv9.png)

考虑这么一个DAG：

![aqVWDI.png](https://s1.ax1x.com/2020/08/10/aqVWDI.png)

不难看出 $S_i'$ 的后继结点与 $S_i$ 的前驱结点是对称的。

于是选择 $S_i'$ 会导致 $S_i'$ 的后继结点全部被选择，而选择 $S_i'$ 就必须不选 $S_i$ ，选择 $S_i'$ 的后继结点会导致 $S_i$ 的前驱结点不被选择。也就是说，$S_i'$ 以下的结点全选， $S_i$ 以上的结点全不选。不难看出，这样选择对虚线框中的结点无影响。

于是可知，这样选择不会导致矛盾。

---

跑完tarjan后不需要再拓扑，因为tarjan求出的scc编号就是**逆拓扑序**。

注意一下：若将 $i$ 集合拆成 `i<<1` 和 `i<<1|1` 两个点，那么从`2`扫描到`n<<1|1` 求出的拓扑序对于第二种情况会出锅，大概是因为同一个连通块中结点的拓扑序不连续造成的。

---

$\text{Code}:$

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <stack>
#define maxn 2000005
#define R register
#define INF 0x3f3f3f3f
using namespace std;
typedef long long lxl;

inline int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') {x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
	return x*f;
}

struct edge
{
	int u,v,next;
}e[maxn];

int head[maxn],k;

inline void add(int u,int v)
{
	e[k]=(edge){u,v,head[u]};
	head[u]=k++;
}

int n,m,ans[maxn];
int dfn[maxn],low[maxn],dfs_cnt,scc[maxn],scc_cnt;
std::stack<int> S;
bool vis[maxn];

inline void tarjan(int u)
{
	S.push(u);
	dfn[u]=low[u]=++dfs_cnt;
	for(int i=head[u];~i;i=e[i].next)
	{
		int v=e[i].v;
		if(!dfn[v])
		{
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}
		else if(!scc[v]) low[u]=min(low[u],dfn[v]);
	}
	if(dfn[u]==low[u])
	{
		++scc_cnt;
		int x;
		do
		{
			x=S.top();S.pop();
			scc[x]=scc_cnt;
		} while (x!=u);
	}
}

int main()
{
	// freopen("P4782.in","r",stdin);
	n=read(),m=read();
	memset(head,-1,sizeof(head));
	for(int i=1;i<=m;++i)
	{
		int x=read(),a=read(),y=read(),b=read();
		add(x+n*(a&1),y+n*(b^1));
		add(y+n*(b&1),x+n*(a^1));
	}
	for(int i=1;i<=(n<<1);++i)
		if(!dfn[i]) tarjan(i);
	for(int i=1;i<=n;++i)
		if(scc[i]==scc[i+n])
		{
			puts("IMPOSSIBLE");
			return 0;
		}
	puts("POSSIBLE");
	for(int i=1;i<=n;++i)
		printf("%d ",scc[i]<scc[i+n]);
	return 0;
}
```

---

参考文献：_国家集训队2003年论文集：伍昱--由对称性解2-SAT问题_



---

## 作者：柳苏明 (赞：2)

upd 2020.9.1

更换用词精简了代码。但不知道为什么上次重新提交时把我的题解给撤了。

# 2-SAT问题

[~~获得更差的阅读体验~~](https://ignotusjee.github.io/2020/09/08/2-SAT/)

[洛谷4782](https://www.luogu.com.cn/problem/P4782)
题意：给定m个约束条件，形式为$x_i,x_j$，表示$x_i$为真/假或$x_j$为真/假，给每个变量赋值使得所有条件得到满足。

### 方法：

将问题转化为图论问题。设$x$表示变量$x$取`false`，¬$x$表示变量$x$取`true`。建立$2 \times n$个点，设$x_i$对应点$i$，¬$x_i$对应点$i+n$，则连有向边的意义为若前者成立则后者必成立。利用给出条件连边建图：

| 约束条件 | 连边 |
| ---- | ---- |
| $x_i$ or $x_j$ |   $i+n \rightarrow j , j+n \rightarrow i$ |
| ¬$x_i$ or $x_j$ |   $i \rightarrow j , j+n \rightarrow i+n$ |
| $x_i$ or ¬$x_j$ |   $i+n \rightarrow j+n , j \rightarrow i$ |
| ¬$x_i$ or ¬$x_j$ |   $i \rightarrow j+n , j \rightarrow i+n$ |

**以一言以蔽之：对于每个约束，若其中一个变量不满足条件，则另一个必须满足。**
连边代码如下~~位运算毒瘤~~：
```cpp
AddEdge(u+n*(a^1),v+n*(b&1));
AddEdge(v+n*(b^1),u+n*(a&1));
```
接下来需要找出是否有可行解。可以发现，$i$是$j$的前驱当且仅当$i$点的取值条件成立时$j$点的取值条件成立（此处取值条件指点所指的变量为`true`或`false`），并且有$i$点的取值条件不成立时$j$点的取值条件不一定成立。显然，当$x_i$和¬$x_i$属于同一个强连通分量时，不存在可行解（存在互相矛盾）。因此，只要使用$tarjan$缩点，在每个强连通分量中看有没有$i$和$i+n$的点对即可实现。

代码如下：
```cpp
int low[maxn<<1],dfn[maxn<<1],stamp,belong[maxn<<1],cnt;
int s[maxn<<1],top;
char ins[maxn<<1];
void tarjan(int u) {
	dfn[u]=low[u]=++stamp;
	s[++top]=u;ins[u]=0xff;
	for(R i(head[u]);i;i=e[i].next) {
		const int &v=e[i].v;
		if(!dfn[v]) {
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}
		else if(ins[v]) low[u]=min(low[u],dfn[v]);
	}
	if(dfn[u]==low[u]) {
		cnt++;
		while(s[top+1]!=u) {
			belong[s[top]]=cnt;
			ins[s[top--]]=0x0;
		}
	}
}

for(R i(1);i<=n;i++)
	if(belong[i]==belong[i+n])
		return write("IMPOSSIBLE\n"),0;
```
最后，要找出一组可行解。由上文可知，当$i$为$i+n$的前驱时，$x_i$取`true`；当$i+n$为$i$的前驱时，$x_i$取`false`（让前者不成立，后者成立）。在$tarjan$时，标号数组`belong`即为反向的拓扑序。因此，通过此数组即可得出前驱后继关系，即$i \text{为j的前驱} \Leftrightarrow belong[i]>belong[j]$。
代码如下：
```cpp
for(R i(1);i<=n;i++)
	write((int)(belong[i]>belong[i+n])," \n"[i==n]);
```

最后放出完整代码
```cpp
#include <cstdio>
#include <cctype>
#include <cstring>
#define R register int

namespace quick {
//毒瘤快读
}
using namespace quick;

const int maxn=1e6+20,inf=0x3f3f3f3f;
int n,m;

struct Edge {
	int v,next;
	Edge(int v=0,int next=0) :v(v),next(next) {}
}e[maxn<<2];
int head[maxn<<1],k;
inline void AddEdge(const int &u,const int &v) {
	e[++k]=Edge(v,head[u]);
	head[u]=k;
}

int low[maxn<<1],dfn[maxn<<1],stamp,belong[maxn<<1],cnt;
int s[maxn<<1],top;
char ins[maxn<<1];
void tarjan(int u) {
	dfn[u]=low[u]=++stamp;
	s[++top]=u;ins[u]=0xff;
	for(R i(head[u]);i;i=e[i].next) {
		const int &v=e[i].v;
		if(!dfn[v]) {
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}
		else if(ins[v]) low[u]=min(low[u],dfn[v]);
	}
	if(dfn[u]==low[u]) {
		cnt++;
		while(s[top+1]!=u) {
			belong[s[top]]=cnt;
			ins[s[top--]]=0x0;
		}
	}
}

int main(void) {
#ifndef ONLINE_JUDGE
	freopen("sat.in","r",stdin);
#endif
	read(n,m);
	for(R i(1);i<=m;i++) {
		R u,a,v,b;
		read(u,a,v,b);
		AddEdge(u+n*(a^1),v+n*(b&1));
		AddEdge(v+n*(b^1),u+n*(a&1));
	}
	for(R i(1);i<=(n<<1);i++) if(!dfn[i]) tarjan(i);
	for(R i(1);i<=n;i++)
		if(belong[i]==belong[i+n])
			return write("IMPOSSIBLE\n"),flush(),0;
	write("POSSIBLE\n");
	for(R i(1);i<=n;i++)
		write((int)(belong[i]>belong[i+n])," \n"[i==n]);
	flush();
	return 0;
}
```

---

## 作者：神眷之樱花 (赞：1)

# 博客阅读更佳
[My Blog](https://blog.csdn.net/init1064573673/article/details/116357182)

# 题解
### 连边
* 定义点 $x$ 表示$(x-(x>n)*n)=(x>n)$，也就是：
* 如果点 $x\leq n$，则代表第 $x$ 个数为 $0$。
* 如果点 $x\geq n+1$，则代表第 $x-n$ 个数为 $1$。
* 定义边 ($x,y$) 由 $(x-(x>n)*n)=(x>n)$ 可以推出 $(y-(y>n)*n)=(y>n)$。

对于条件 ($x=a||y=b$)，我们可以转化为：
$$x=a\ xor\ 1\rightarrow y=b$$
$$y=b\ xor\ 1\rightarrow x=a$$
由此我们就知道了该怎么连边。

```cpp
add(x + (a ^ 1) * n,y + b * n);
add(y + (b ^ 1) * n,x + a * n);
```
### 判无解
于是连完后，我们跑一遍tarjan，求出其中的强连通分量，如果 $x$ 和 $x+n$ 同处于一个强连通分量内，那么显然无解。原因很显然，这意味着我们从 $x=0$ 推出了 $x = 1$。
### 构造值
接下来是构造值的问题。
我用的是小蓝书的第二种方法，这里就不赘述原理了。
# 代码

```cpp
#include<cstdio>
#include<iostream>
using std::min;
const int N = 2e6 + 5;
struct edge {
	int next,to;
}a[N << 1];
int head[N],opp[N],n,m,a_size = 1;
inline void add(int u,int v) {
	a[++a_size] = (edge){head[u],v};
	head[u] = a_size;
}
int dfn[N],low[N],sta[N],c[N],top = 0,cnt = 0,num = 0;
bool ins[N];
void tarjan(int x) {
	dfn[x] = low[x] = ++num;
	sta[++top] = x; ins[x] = true;
	for(int i = head[x]; i; i = a[i].next) {
		int y = a[i].to;
		if(!dfn[y]) {
			tarjan(y);
			low[x] = min(low[x],low[y]);
		}
		else if(ins[y])
			low[x] = min(low[x],dfn[y]); 
	}
	if(dfn[x] == low[x]) {
		int y; cnt++;
		do {
			y = sta[top--]; ins[y] = false;
			c[y] = cnt;
		}while(x != y);
	}
}
inline int read() {
	int x = 0,flag = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9'){if(ch == '-')flag = -1;ch = getchar();}
	while(ch >='0' && ch <='9'){x = (x << 3) + (x << 1) + ch - 48;ch = getchar();}
	return x * flag;
}
int main() {
	n = read(),m = read();
	for(int i = 1; i <= m; i++) {
		int x = read(),a = read(),y = read(),b = read();
		add(x + (a ^ 1) * n,y + b * n);
		add(y + (b ^ 1) * n,x + a * n);
	} n <<= 1;
	for(int i = 1; i <= n; i++)
		if(!dfn[i]) tarjan(i);
	n >>= 1;
	for(int i = 1; i <= n; i++)
		if(c[i] == c[i + n]) {puts("IMPOSSIBLE"); return 0;}
	puts("POSSIBLE");
	for(int i = 1; i <= n; i++)
		printf("%d ",c[i] > c[n + i]);
	return 0;
} 
```


---

## 作者：zimindaada (赞：1)

### [博客阅读更佳](https://www.cnblogs.com/zimindaada/p/2_SAT.html)

---

### SAT问题的定义

SAT是Satisfiability（可满足性）的缩写，而k-SAT问题就是说你有$n$个未知的`bool`变量$a_i$，有$m$个对这些变量的限制，每个限制有$k$个元素，设每个元素为$x$，要求 $x$或$\neg x$ 的 $\lor$（或）或者$\land$（和）的值（如3-SAT中，形如`(a or b or !c)` 或 `a and !b and !c` 的条件）为`true`，或定义某一个未知数为`true`/`false`的一种解法。

很容易想到$O(2^nm)$暴力做法，即枚举每一个`bool`未知数的值，判断是否合法。而对于$k \geq 3$而言的k-SAT已经被证明是NP完全问题（即没有多项式复杂度的问题），而我们研究的2-SAT则有一个多项式解法。

### 2-SAT问题的解法

定义对于任何一个单字母`bool`变量$a$为`true`。

我们通过建一些特殊的图来实现：我们令编号从$1$到$n$的点为未知变量$a_i$取`true`的情况，$n+1$到$2 \times n$的点为$a_i$取`false`的情况。连边方面，我们令从$a$连向$b$表示由$a$能推到$b$，则$a\land b$可以变为$a \rightarrow b, b\rightarrow a$，即由$a$为真可以推出$b$为真，由$b$为真可以推出$a$为真；$a \lor b$可以变为$\neg a \rightarrow b, \neg b \rightarrow a$，即若$a$为假则$b$为真；$a = x (x\in \{ true, false\})$可以变为$\neg a \rightarrow a$，这个我们之后再说为什么，先当这种情况不存在。可以发现所有情况都可以化为刚才三种情况之一。

然后我们对于这样一个特殊的图跑一边强连通分量，如果存在$\neg a$和$a$只有同存在于同一个强连通分量中，则一定无解，因为这一意味着你可以从$\neg a$推到$a$，而很明显这是矛盾的。

于是我们得到了一张拓扑图。有一个性质，就是在有解的情况下，一个未知数的两个取值是有前后推导关系的，也就是一个取值直接或间接的指向了另一个取值时，我们取后者是一定有解的。实际实现上，输出的时候，输出对于每一个点拆除的`true`和`false`中，拓扑序较大的那一个，则一定有一个解。然而由于我们跑了`Tarjan`，那么我们可以附带着求一个反向的拓扑序，那么这就拓扑序也求得了。

从刚才这一角度来说，对于刚才建图中的第三种情况，我们连$\neg a \rightarrow a$可以让$a$的拓扑序必定大于$\neg a$，即最后输出的时候一定会输出开始时给它的定义。

很明显复杂度瓶颈在`Tarjan`跑强连通分量上，其复杂度为$O(n+m)$，所以总复杂度为$O(n+m)$

### 例题

#### 例题1 [P4782 【模板】2-SAT 问题](https://www.luogu.com.cn/problem/P4782)

一道模板题，甚至连赋值操作都没有。可以看到这里输入的时候用了一些小技巧来压了一下输入的行，其他就没什么难以理解的了。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
namespace ztd{
    using namespace std;
    typedef long long ll;
	const int mod = 998244353;
	const int inf = 2147483647;
    template<typename T> inline T read(T& t) {//fast read
        t=0;short f=1;char ch=getchar();double d = 0.1;
        while (ch<'0'||ch>'9') {if (ch=='-') f=-f;ch=getchar();}
        while (ch>='0'&&ch<='9') t=t*10+ch-'0',ch=getchar();
        if(ch=='.'){ch=getchar();while(ch<='9'&&ch>='0') t+=d*(ch^48),d*=0.1,ch=getchar();}
        t*=f;
        return t;
    }
}
using namespace ztd;
const int maxn = 2e6+7, maxm = 2e6+7;
int n, m;

int last[maxn], ecnt;
struct edge{int y, gg;}e[maxm];
inline void addedge(int x, int y){
	e[++ecnt] = {y, last[x]};
	last[x] = ecnt;
}

int dfn[maxn], low[maxn], pcnt, st[maxn], top, gang[maxn], gtot;
bool instack[maxn];
void Tarjan(int x){
	dfn[x] = low[x] = ++pcnt; 
	st[++top] = x; instack[x] = 1;
	for(int i = last[x], y = e[i].y; i; i = e[i].gg, y = e[i].y){
		if(!dfn[y]){
			Tarjan(y);
			low[x] = min(low[x], low[y]);
		}else if(instack[y]) low[x] = min(low[x], dfn[y]);
	}
	if(low[x] == dfn[x]){
		int now; ++gtot;
		do{
			now = st[top--]; instack[now] = 0;
			gang[now] = (gtot);
		}while(now ^ x);
	}
}

int main(){
	read(n); read(m);
	int xx, yy, hmx, hmy;
	for(int i = 1; i <= m; ++i){
		read(xx); read(hmx); read(yy); read(hmy); 
		addedge(xx+(1-hmx)*n, yy+hmy*n);
		addedge(yy+(1-hmy)*n, xx+hmx*n);
	}
	for(int i = 1; i <= n*2; ++i) if(!dfn[i]) Tarjan(i);
	for(int i = 1; i <= n; ++i){
		if(gang[i] == gang[i+n]){
			puts("IMPOSSIBLE");
			return 0;
		} 
	}
	puts("POSSIBLE");
	for(int i = 1; i <= n; ++i){
		cout << ((int)(gang[i] > gang[i+n])) << " ";
	} 
	cout << '\n';
	return 0;
}

```
还有几道比较好的练手题，如

[P4171 【JSOI2010】满汉全席](https://www.luogu.com.cn/problem/P4171)（跟模板区别不大）


[P3825 【NOI2017】游戏](https://www.luogu.com.cn/problem/P3825)（比较好的实际应用题）

关于这些题的题解，可以在[我的博客](https://www.cnblogs.com/zimindaada/p/2_SAT.html)里看。


---

## 作者：xfrvq (赞：0)

[原题链接](https://www.luogu.com.cn/problem/P4782)

[博客食用](https://www.luogu.com.cn/blog/368107/solution-p4782)

---

**前言**

阅读本文，你需要掌握的算法如下：

+ 图的存储&遍历

+ ***DFS***

~~对没错真就只有这两条~~

---

1. ***2-SAT*** 介绍

***2-SAT*** 问题指的是**给定一些布尔变量，以及它们的关系（比如 $a$ 为真或 $b$ 为假），要你求出解存不存在，存在就构造出一组解**。

那么我们怎么解决这个问题呢？

~~还真就是dfs~~

---

STEP 1：把问题转化到一个图上

我们先建立一个图包含 $2\times n$ 个点，用于存下第 $i$ 个点为 $true$ 或 $false$ 的情况

这里我用 $0 \dots n-1$ 代表 $n$ 个点，第 $i$ 个点的 $false$ 情况对应图里的第 $2 \times i$ 个点，$true$ 情况对应图里的第 $2 \times i + 1$ 个点

这样就可以用 $i$ `^` $1$取到编号一样但真假值与 $i$ 相反的点。

好的，开始建图

以条件 $a$ 为真或 $b$ 为假举例：

+ 如果 $a$ 为真，则 $b$ 必定也为真
+ 如果 $b$ 为假，则 $a$ 必定也为假
- 如果 $a$ 为假，推不出任何东西
- 如果 $b$ 为真，推不出任何东西

那么就应该是：
```cpp
if(!a && !b){
	G[i << 1].push_back(j << 1 | 1);
	G[j << 1].push_back(i << 1 | 1);
} else if(a && !b){
	G[i << 1 | 1].push_back(j << 1 | 1);
	G[j << 1].push_back(i << 1);
} else if(!a && b){
	G[j << 1 | 1].push_back(i << 1 | 1);
	G[i << 1].push_back(j << 1);
} else if(a && b){
	G[i << 1 | 1].push_back(j << 1);
	G[j << 1 | 1].push_back(i << 1);
}
```

---

STEP 2：DFS

DFS的时候，我们开一个 $vis$ 数组标记**图上**第 $i$ 个点是否被标记（标记表示我们暂时选这个点，如果后面发现行不通了就取消标记）

那如果点 $2 \times i$ 被标记了并且点 $2 \times i + 1$ 也被标记了，那么就直接一路取消标记

我们开一个数组装下所有被标记了的点的编号以方便我们后面取消标记

代码（注释在里面）：
```cpp
bool dfs(int u){
	if(vis[u ^ 1]) return false;  // 如果这个点真假值相反的情况被标记了，那么矛盾，不能再DFS下去
	if(vis[u]) return true; // 如果曾经DFS过这个点并且把它标记上了，就不用再DFS下去了，直接反回
	vis[u] = true; // 标记上
	a[len++] = u; // 存入数组
	for(int i = 0;i < G[u].size();++i)
		if(!dfs(G[u][i])) return false; // 任何一个v失败就不能再DFS下去了
	return true;
}
```

---

STEP 3：**2-SAT**函数

我们用一个`_2_SAT`函数来完成操作

代码（注释在里面）：
```cpp
bool _2_SAT(){
	for(int i = 0;i < 2 * n;i += 2){
		if(vis[i] == false && vis[i + 1] == false){ // 如果这个点没有访问过
			len = 0; // DFS前清零
			if(!dfs(i)){ // 如果DFS失败
				while(len > 0) vis[a[--len]] = false; // 沿路清空标记
				if(!dfs(i + 1)) return false; // 这个时候尝试另一种可能，如果还是失败，就彻底失败，不可能存在可行解
			}
		}
	}
	return true;
}
```

---

美好的AC代码时刻：

```cpp
#include<stdio.h>
#include<vеctor>
std::vector<int> G[2000001];
int n,m,a[2000001],len = 0;
bool vis[2000001];
bool dfs(int u){
	if(vis[u ^ 1]) return false;
	if(vis[u]) return true;
	vis[u] = true;
	a[len++] = u;
	for(int i = 0;i < G[u].size();++i)
		if(!dfs(G[u][i])) return false;
	return true;
}
bool _2_SAT(){
	for(int i = 0;i < 2 * n;i += 2){
		if(vis[i] == false && vis[i + 1] == false){
			len = 0;
			if(!dfs(i)){
				while(len > 0) vis[a[--len]] = false;
				if(!dfs(i + 1)) return false;
			}
		}
	}
	return true;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int _i = 1;_i <= m;++_i){
		int i,a,j,b;
		scanf("%d%d%d%d",&i,&a,&j,&b);
		--i,--j;
		if(!a && !b){
			G[i << 1].push_back(j << 1 | 1);
			G[j << 1].push_back(i << 1 | 1);
		} else if(a && !b){
			G[i << 1 | 1].push_back(j << 1 | 1);
			G[j << 1].push_back(i << 1);
		} else if(!a && b){
			G[j << 1 | 1].push_back(i << 1 | 1);
			G[i << 1].push_back(j << 1);
		} else if(a && b){
			G[i << 1 | 1].push_back(j << 1);
			G[j << 1 | 1].push_back(i << 1);
		}
	}
	if(_2_SAT()){
		puts("POSSIBLE");
		for(int i = 0;i < n;++i)
			printf("%d ",vis[i << 1] ? 1 : 0 );
	} else puts("IMPOSSIBLE");
	return 0;
}
```

---

## 作者：_121017_ (赞：0)

$2 - SAT$ 的板子题。
# 思路
说白了就是 $Tarjan$ 求强连通分量，只不过在建边上有许多技巧。我们把一个点拆成 $a_i$ 和 $a_{i+n}$ 两个点，分别表示 $a_i$ 取真和取假时的点。

下面是条件分别为 $4$ 种情况是我们的建边方案。

---
- $a_i=0||b_i=0$ 时，我们建 $a_i->b_{i+n}$ 的边和 $b_i->a_{i+n}$ 的边。

- $a_i=1||b_i=0$ 时，我们建 $a_{i+n}->b_{i+n}$ 的边和 $b_i->a_i$ 的边。

- $a_i=0||b_i=1$ 时，我们建 $a_i->b_i$ 的边和 $b_{i+n}->a_{i+n}$ 的边。

- $a_i=1||b_i=1$ 时，我们建 $a_{i+n}->b_i$ 的边和 $b_{i+n}->a_i$ 的边。

---
最后统计的时候如果 $a_i$ 与 $a_{i+n}$ 在同一强连通分量内，无解。反之，如果 $a_i$ 所属的强连通分量出现的时间小于 $a_{i+n}$ 所属的，$a_i$ 为 $1$，否则为 $0$。
# code
```cpp
#include<bits/stdc++.h>
#define ri register int
using namespace std;
const int MAX_N=15000005;
int n,m,ti,ans;
int head[MAX_N],to[MAX_N],next[MAX_N];
int dfn[MAX_N],low[MAX_N];
bool flag[MAX_N],vis[MAX_N];
int cnt;
int num[MAX_N];
int color[MAX_N];
stack <int> s;
void add(int u,int v){
	++cnt;
	to[cnt]=v;
	next[cnt]=head[u];
	head[u]=cnt;
}
void tarjan(int u){
	s.push(u);
	vis[u]=flag[u]=1;
	dfn[u]=low[u]=++ti;
	for(ri i=head[u];i;i=next[i]){
		int v=to[i];
		if(!dfn[v]){
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}else{
			if(vis[v]){
				low[u]=min(low[u],dfn[v]);
			}
		}
	}
	if(low[u]==dfn[u]){
		cnt++;
		while(s.top()!=u){
			int v=s.top();
			s.pop();
			color[v]=cnt;
			num[cnt]++;
			vis[v]=0;
		}
		s.pop();
		color[u]=cnt;
		num[cnt]++;
		vis[u]=0;
	}
}
int main(){
	cin>>n>>m;
	for(ri i=1;i<=m;i++){
		int a,b,c,d;
		cin>>a>>b>>c>>d;
		if(b==d){
			if(b){
				add(a+n,c);
				add(c+n,a);
			}else{
				add(a,c+n);
				add(c,a+n);
			}
		}else{
			if(b){
				add(a+n,c+n);
				add(c,a); 
			}else{
				add(a,c);
				add(c+n,a+n);
			}
		}
	}
	for(ri i=1;i<=2*n;i++){
		if(!flag[i]) tarjan(i);
	} 
	for(ri i=1;i<=n;i++){
		if(color[i]==color[i+n]){
			cout<<"IMPOSSIBLE";
			return 0;
		}
	}
	cout<<"POSSIBLE"<<endl;
	for(ri i=1;i<=n;i++){
		cout<<(color[i]<color[i+n])<<" ";
	}
	return 0;
}
```


---

## 作者：xukuan (赞：0)

不会2-SAT的右转[2-SAT算法初步](https://www.luogu.org/blog/xukuan/2-SAT)

这里重点讲**建模**

我们发现，“2-SAT问题中两个条件之间是异或关系”

这里的两个条件是或关系

那么我们该如何处理？

我们发现，选择了not A,就必须选择B；选择了not B，就必须选择A。

这就有一个异或关系了。

同时注意连边时是两条单向边

最后，这里的小于和大于不能乱用，因为原题是或关系

**代码（与i对应的状态是i+n）**

```cpp
#include<bits/stdc++.h>
#include<iostream>
#include<cstdio>
#define ll long long
using namespace std;

const ll N=1000010<<1,M=1000010<<1;//有n*2个点
ll n,m,deep,color,v[N],dfn[N],low[N],colour[N];
ll ver[M<<1],Next[M<<1],head[N],tot;
stack<ll> st;

inline ll read(){
	ll x=0,tmp=1;
	char ch=getchar();
	while(!isdigit(ch)){
		if(ch=='-') tmp=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<3)+(x<<1)+(ch^48);
		ch=getchar();
	}
	return tmp*x;
}

inline void addEdge(ll x,ll y){
	ver[++tot]=y;
	Next[tot]=head[x];
	head[x]=tot;
}

inline ll id(ll x,ll y){
	return x+n*(y&1);
}

//tarjan部分与缩点无异
void tarjan(ll x){
	dfn[x]=low[x]=++deep;
	v[x]=1; st.push(x);
	for(ll i=head[x]; i; i=Next[i]){
		ll y=ver[i];
		if(!dfn[y]){
			tarjan(y);
			low[x]=min(low[x],low[y]);
		}
		else{
			if(v[y]) low[x]=min(low[x],dfn[y]);
		}
	}
	if(dfn[x]==low[x]){
		colour[x]=++color;
		v[x]=0;
		while(st.top()!=x){
			colour[st.top()]=color;
			v[st.top()]=0;
			st.pop();
		}
		st.pop();
	}
}

int main(){
	n=read(); m=read();
	while(m--){
		ll x1=read(),x2=read(),Y1=read(),y2=read();
		addEdge(id(x1,x2),id(Y1,y2^1));
		addEdge(id(Y1,y2),id(x1,x2^1));
		//建模，注意是两条单向边
	}
	for(ll i=1; i<=n*2; i++){//有n*2个点
		if(!dfn[i]) tarjan(i);
	}
	for(ll i=1; i<=n; i++){
		if(colour[i]==colour[i+n]) return printf("IMPOSSIBLE")&0;
		//两个状态在同一个环里
	}
	printf("POSSIBLE\n");
	for(ll i=1; i<=n; i++){
		putchar((colour[i]<colour[i+n])+'0');
		putchar(' ');
	}
	return 0;
}
```

---


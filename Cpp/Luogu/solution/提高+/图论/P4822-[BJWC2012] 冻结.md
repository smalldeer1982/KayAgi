# [BJWC2012] 冻结

## 题目背景

“我要成为魔法少女！”

“那么，以灵魂为代价，你希望得到什么？”

“我要将有关魔法和奇迹的一切，封印于卡片之中„„”

在这个愿望被实现以后的世界里，人们享受着魔法卡片（SpellCard，又名符卡）带来的便捷。

现在，不需要立下契约也可以使用魔法了！你还不来试一试？

比如，我们在魔法百科全书（Encyclopedia of Spells）里用“freeze”作为关键字来查询，会有很多有趣的结果。

例如，我们熟知的 Cirno，她的冰冻魔法当然会有对应的 SpellCard 了。当然，更加令人惊讶的是，居然有冻结时间的魔法，Cirno 的冻青蛙比起这些来真是小巫见大巫了。

这说明之前的世界中有很多魔法少女曾许下控制时间的愿望，比如 Akemi Homura、Sakuya Izayoi、……

当然，在本题中我们并不是要来研究历史的，而是研究魔法的应用。

## 题目描述

我们考虑最简单的旅行问题吧： 现在这个大陆上有 $N$ 个城市，$M$ 条双向的道路。城市编号为 $1$ ~ $N$，我们在 $1$ 号城市，需要到 $N$ 号城市，怎样才能最快地到达呢？

这不就是最短路问题吗？我们都知道可以用 Dijkstra、Bellman-Ford、Floyd-Warshall等算法来解决。

现在，我们一共有 $K$ 张可以使时间变慢 50%的 SpellCard，也就是说，在通过某条路径时，我们可以选择使用一张卡片，这样，我们通过这一条道路的时间 就可以减少到原先的一半。需要注意的是：

1. 在一条道路上最多只能使用一张 SpellCard。
2. 使用一张SpellCard 只在一条道路上起作用。
3. 你不必使用完所有的 SpellCard。

给定以上的信息，你的任务是：求出在可以使用这不超过 $K$ 张时间减速的 SpellCard 之情形下，从城市 $1$ 到城市 $N$ 最少需要多长时间。

## 说明/提示

#### 样例 1 解释

在不使用 SpellCard 时，最短路为 $1 \to 2 \to 4$，总时间为 10。现在我们可以使用 1 次 SpellCard，那么我们将通过 $2 \to 4$ 这条道路的时间减半，此时总时间为7。

#### 数据规模与约定

对于 $100\%$ 的数据，保证：

- $1 \leq K \leq N \leq 50$，$M \leq 10^3$。
- $1 \leq A_i,B_i \leq N$，$2 \leq Time_i \leq 2 \times 10^3$。
- 为保证答案为整数，保证所有的 $Time_i$ 均为偶数。
- 所有数据中的无向图保证无自环、重边，且是连通的。

## 样例 #1

### 输入

```
4 4 1 
1 2 4 
4 2 6 
1 3 8 
3 4 8 
```

### 输出

```
7```

# 题解

## 作者：Isprime (赞：110)

## 题解P4822[BJWC2012]冻结

[配合Blog食用更佳](https://www.luogu.org/blog/149815/solution-p4822)

[原题传送门](https://www.luogu.org/problem/P4822)

**分层图模板题**

题意简化：有n个点，m条边，求s到t的最短路


现在让我们口胡一张图，是这样的（图很丑，请见谅）

![](https://cdn.luogu.com.cn/upload/pic/72236.png)

但题目中多了一个条件：我们至多可以让k条边的权值变为原来的50%（不一定要有k条边权值变成50%）

这不就是分层图裸题吗，建k层图（因为k≤50，所以并不会占用太大的空间），举个栗子：x和y之间有一条权值为z的边，则第0到k层的x,y之间都要连权值为z的边,第0到k-1层的x或y连到第i+1层的y或x的权值改为原来的50%

图就变成了下面这个样子↓

![](https://cdn.luogu.com.cn/upload/pic/72243.png)

~~乱七八糟，看都看不清~~

~~图里面有一些0，你就当成是原来的50%吧毕竟画图的那个软件不知道被我丢哪儿去了~~

p.s.图中8和9的编号画反了 ~~，凑合着看吧~~

好吧等有时间了我会改

所以最终答案只需要跑一边Dijkstra再找出dis[i*(n+1)+t]的最小值即为答案

Code
```cpp
#include<cstdio>
#include<queue>
#define ri register int
#define MAXN 51
#define MAXM 1001 
#define INF 2147483647
using namespace std;
int n,m,k,edge_sum;
int head[MAXM*201],dis[MAXN*201];
bool vis[MAXN*201];
struct Edge{
	int next,to,dis;
}edge[MAXM*201];
inline void addedge(int from,int to,int dis){
	edge[++edge_sum].next=head[from];
	edge[edge_sum].dis=dis;
	edge[edge_sum].to=to;
	head[from]=edge_sum;
}
struct Node{
	int u,dis;
	bool operator <(const Node& rhs) const {
        return dis>rhs.dis;
    }
};
inline void dijkstra(){
	priority_queue<Node> q;
	q.push((Node){1,0});
	while(!q.empty()) {
		int u=q.top().u;
		q.pop();
		vis[u]=1;
		for(ri i=head[u];i;i=edge[i].next)
			if(!vis[edge[i].to]&&dis[edge[i].to]>dis[u]+edge[i].dis){
				dis[edge[i].to]=dis[u]+edge[i].dis;		
				q.push((Node){edge[i].to,dis[edge[i].to]});
			}
	}
}
int main()
{
	scanf("%d %d %d",&n,&m,&k);
    for(ri i=1;i<=m;i++)
    {
    	int x,y,z;
        scanf("%d%d%d",&x,&y,&z);
        for(ri j=0;j<=k;j++) addedge(j*n+x,j*n+y,z),addedge(j*n+y,j*n+x,z);
        for(ri j=0;j<k;j++) addedge(j*n+x,(j+1)*n+y,z/2),addedge(j*n+y,(j+1)*n+x,z/2);
    }
    for(ri i=1;i<=n*k+n;i++) dis[i]=INF;
    dis[1]=0;
    dijkstra();
    int min=INF;
    for(ri i=0;i<=k;i++) if(min>dis[i*n+n]) min=dis[i*n+n];
    printf("%d\n",min);
    return 0;
}
}
```

~~码风真差~~

# 说句闲话：研究分层图的最好方法是
### A了4568,再A了2939，还要A了4822
**祝你们成功 (滑稽**

3倍经验

我都告诉你这么多了，不点个赞？

---

## 作者：D_14134 (赞：23)

这不就是一道分层图最短路的板子题吗？

既然刷了就复习~~（预习）~~一下分层图。

我们一般用分层图解决在最短路中有办法减少边权的题。那么

### **思路如下** 

把图分成k层，每层仍然是n个点，每层的连边方式仍然和原图相同。除此以外，层与层之间该如何连边呢？

我们假设现在在第i层，点u和点v之间有一条权值w的边，对于下一层，即i+1层，u'与v'之间仍是有一条权为w的边，且对于u与v'之间应该加上一条边权为0的边。所以如果每一层有m条边，第i层和第i+1层之间也一定是有m条边。

对于我们当前找到的终点，尝试起点的状态去更新，不选择此条边免费的状态和选择此条边免费的状态，再将这两个状态压入队列去更新可以到达的其他状态。 

以上就是这道题的思路。类似题有 Bzoj 2763 飞行路线 和 [USACO09FEB]改造路RevampingTrail

我们有时也用分层图解决一些其它问题，主要是最短路上的涂色问题

这种类型主要思路仍然是多开一维记录当前状态，然后根据当前状态更新其对应状态。我们每找到一个终点，首先尝试用起点状态去更新起点颜色不同的状态，再去更新终点在此时刻的状态，将终点状态压入队列更新其他状态。 

类似题有 Codevs 1391 伊吹萃香

以上就是对分层图的复习~~（预习）~~


------------

那么本题的
# code
```cpp
#include<queue>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define maxn 10000000
#define inf 0x7f7f7f
using namespace std;
struct node{
	int to,next,w;
}edge[maxn*2];
int n,m,k,x,y,z,tot,dis[maxn],vis[maxn],head[maxn];
inline int point(int x,int y){return y*n+x;}
inline int min(int a,int b){return a<b?a:b;}
inline void adde(int u,int v,int w){edge[++tot].next=head[u],edge[tot].to=v,edge[tot].w=w,head[u]=tot;}
int read(){
    int x=0,f=1;char ch=getchar();
    while (ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while (ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
queue<int> q;
inline void spfa(){
	for(int i=1;i<=point(n,k);i++) dis[i]=inf;
	dis[1]=0;vis[1]=1;
	q.push(1);
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=head[u];i>0;i=edge[i].next){
			int v=edge[i].to;
			if(dis[v]>dis[u]+edge[i].w){
				dis[v]=dis[u]+edge[i].w;
				if(!vis[v]){
					q.push(v);
					vis[v]=1;
				}
			}
		}
		vis[u]=0;
	}
}
int main(){
	n=read();m=read();k=read();
	for(int i=1;i<=m;i++){
		int x=read(),y=read(),z=read();
		for(int j=0;j<=k;j++) adde(point(x,j),point(y,j),z),adde(point(y,j),point(x,j),z);
		for(int j=0;j<k;j++) adde(point(x,j),point(y,j+1),z/2),adde(point(y,j),point(x,j+1),z/2);
	}
	spfa();
	int ans=inf;
	for(int i=0;i<=k;i++) ans=min(ans,dis[point(n,i)]);
	printf("%d",ans);
	return 0;
}
```


---

## 作者：communist (赞：13)

这个题没有什么可写的部分分吧

比较套路的一个题

两种其实差不多的解法

### 1，$DP$最短路

回顾最短路的实现中，我们用$len[i]$表示从起点到$i$这个点的最短距离

那么加入减小边权了呢，我们可以用$len[i][j]$表示到第$i$个点，用掉$k$次减少边权机会的最小距离

转移是显然的，在普通最短路转移的基础上，加入从用掉$j$个支援到用$j+1$个的转移，

$len[v][j+1]=min(len[v][j+1],len[u][j]+dis[u][v]/2)$

最后取$min(len[n][i])(i\in{[1,k]})$即可

```
#include<iostream>
#include<cstring>
#include<cstdio>
#include<queue>
using namespace std;
const int maxn=60;
int n,m,ki,len[maxn][maxn],e[maxn][maxn];
bool exist[maxn][maxn];
int spfa()
{
    queue<int>q,qs;
    memset(len,0x3f,sizeof(len));
    len[1][0]=0;
    exist[1][0]=1;
    q.push(1),qs.push(0);
    while(!q.empty())
    {
        int i=q.front(),k=qs.front();
        q.pop(),qs.pop();
        exist[i][k]=0;
        for(int j=1;j<=n;j++)
        {
            if(e[i][j]>1e6)
                continue;
            if(len[j][k]>len[i][k]+e[i][j])
            {
                len[j][k]=len[i][k]+e[i][j];
                if(!exist[j][k])
                    exist[j][k]=1,q.push(j),qs.push(k);
            }
            if(len[j][k+1]>len[i][k]+e[i][j]/2)
            {
                len[j][k+1]=len[i][k]+e[i][j]/2;
                if(!exist[j][k+1]&&k<ki)
                    exist[j][k+1]=1,q.push(j),qs.push(k+1);
            }
        }
    }
    int ret=1e9;
    for(int i=0;i<=ki;i++)
        ret=min(ret,len[n][i]);
    return ret;
}
int main()
{
    scanf("%d%d%d",&n,&m,&ki);
    memset(e,0x3f,sizeof(e));
    for(int x,y,d,i=1;i<=m;i++)
    {
        scanf("%d%d%d",&x,&y,&d);
        e[x][y]=e[y][x]=d;
    }
    printf("%d\n",spfa());
    return 0;
}
```

### 2，分层图最短路

本来是有$n$个点的，但是不好处理，我们不妨把每个点拆成$k+1$个，第$j$个表示到这个点要用$j$次支援

建图的时候同层正常连边，本层到上层连边时边权除2，直接跑最短路，统计答案时枚举第$n$个点各层最小代价即可

```
#include<iostream>
#include<cstring>
#include<cstdio>
#include<queue>
using namespace std;
const int maxn=2600;
struct edge{
    int next,to,dis;
}e[210010];
int cnt,head[maxn],n,m,ki,len[maxn];
bool exist[maxn];
inline void add(int x,int y,int d)
{
    e[++cnt].next=head[x];
    e[cnt].to=y;
    e[cnt].dis=d;
    head[x]=cnt;
}
int spfa()
{
    queue<int> q;
    memset(len,0x3f,sizeof(len));
    q.push(1);
    len[1]=0;
    exist[1]=1;
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        exist[u]=0;
        for(int v,i=head[u];i;i=e[i].next)
            if(len[v=e[i].to]>len[u]+e[i].dis)
            {
                len[v]=len[u]+e[i].dis;
                if(!exist[v])
                    exist[v]=1,q.push(v);
            }
    }
    int ret=1e9;
    for(int i=1;i<=ki+1;i++)
        ret=min(ret,len[n*i]);
    return ret;
}
int main()
{
    scanf("%d%d%d",&n,&m,&ki);
    memset(e,0x3f,sizeof(e));
    for(int x,y,d,i=1;i<=m;i++)
    {
        scanf("%d%d%d",&x,&y,&d);
        for(int j=0;j<=ki;j++)
        {
            add(x+j*n,y+j*n,d),add(y+j*n,x+j*n,d);
            if(j<ki)
                add(x+j*n,y+(j+1)*n,d/2),add(y+j*n,x+(j+1)*n,d/2);
        }
    }
    printf("%d\n",spfa());
    return 0;
}
```

---

## 作者：囧仙 (赞：9)

## 题目大意 

> $n$ 个点的稠密图。你可以进行 $k$ 次操作，令某条边权值变成一半，每条边只能变换最多一次。询问从 $1$ 到 $n$ 的最短路。  
> $n\le 50,k\le 50$ 。
  

## 题解

楼上给出了非常多的用 $\text{SPFA}$ 或者 $\text{Dijkstra}$ 的分层图做法。但是无论是 $\text{Dij}$ 还是 $\text{SPFA}$ 写起来都比传统的 $\text{Floyd}$ 麻烦。这里提供一个 $\mathcal O(k\times n^3)$ 的 $\text{Floyd}$ 做法。

- 由于 $n\le 50,m\le 10^3$ 达到了稠密图的程度，于是下文不再区分 $m$ ，而是直接当作 $n^2$ 处理了……

下文设 $W_{i,j}$ 表示连接 $(i,j)$ 的边权， $S_{i,j}$ 表示 $(i,j)$ **不进行变换**的情况下的最短路， $T_{i,j}$ 表示进行了若干次变换后的最小路。（特别地，若某条路径不存在，设为 $+\infty$ ） 。

显然，由于 $n\le 50$ ，我们可以预处理出 $S_{i,j}$ 和 $W_{i,j}$ 。下面考虑枚举进行了多少次变换。不妨设枚举到了第 $t$ 次。

事实上，我们需要用目前计算出的执行了最多 $t-1$ 次变换的 $T_{i,j}$ 计算出下一个 $T_{i,j}$ （不妨设为 $T_{i,j}'$ ）。显然有这样的递推式：

$$T_{i,j}'=\min_{k\in[1,n]} \left\{T_{i,j},T_{i,k}+\frac{1}{2}W_{k,j}\right\}$$

理解：枚举每一条路径 $(i,k)$ ，对边 $(k,j)$ 使用变换，更新答案至 $T_{i,j}'$ 。

注意：我们并不需要考虑对一条边重复变换的情况。因为 $(i,j)$ 最短路径上显然不可能对一条边进行两次以上的变换。

当然，在变换过一条边后可能还会走若干步才会进行下一次变换。也就是说，我们在 $T_{i,j}$ 的基础上可以再走若干步。事实上，这相当于第 $i$ 个点和第 $j$ 个点之间，有一条长度为 $S_{i,j}$ 的边。要注意的是，在进行下一次变换之前，我们都是走的普通路，于是应当用 $S_{k,j}$ 更新 $T_{i,j}'$ 。容易发现，这就是朴素的 $\text{Floyd}$ 。

这时，我们计算出了变换了最多 $t$ 次的 $T_{i,j}'$ 。将它复制到 $T_{i,j}$ 就可以进行下一轮循环了。

时间复杂度显然是 $\mathcal O(k\times n^3)$ 。

---

附记：让我们计算一下朴素的分层图做法的复杂度。

分层图将所有的 $n$ 个点和 $n^2$ 条边复制了 $k$ 次，也就是说，构造出的分层图应当有 $nk$ 个点和 $n^2k$ 条边。对于每个点，我们都要枚举一下与它相连的所有边（一共是 $2n$ 个），这部分复杂度达到了 $kn^2$ 。这些边还要全部丢到优先队列里，复杂度还要多个 $\log $……于是二叉堆优化的 $\text{Dijkstra}$ 的复杂度实际上是 $\mathcal O(kn^2\log kn^2)$ ……（这么看来，我的 $\text{Floyd}$ 做法还不错嘛）。当然，如果你非常能码，用了些特殊的堆，可以一定程度降低复杂度。

顺带一提，题解区里另外有个 $\mathcal O(n^3k^2)$ 的 $\text{Floyd}$ 。但是实现的不怎么好，差点就被卡到 $\text{TLE}$ ……

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int INF =1e9;
const int MAXN=50+3;
int n,m,p,S[MAXN][MAXN],T[MAXN][MAXN],R[MAXN][MAXN],W[MAXN][MAXN];
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
    return ret*w;
}
int main(){
    n=qread(),m=qread(),p=qread();
    up(1,n,i) up(1,n,j) S[i][j]=W[i][j]=INF; up(1,n,i) S[i][i]=W[i][i]=0;
    up(1,m,i){
        int a=qread(),b=qread(),w=qread();
        S[a][b]=S[b][a]=W[a][b]=W[b][a]=min(W[a][b],w);
    }
    up(1,n,i) up(1,n,j) up(1,n,k) S[j][k]=min(S[j][k],S[j][i]+S[i][k]);
    up(1,n,i) up(1,n,j) T[i][j]=S[i][j];
    up(1,p,o){
        up(1,n,i) up(1,n,j) R[i][j]=T[i][j];
        up(1,n,i) up(1,n,j) up(1,n,k) R[i][k]=min(R[i][k],T[i][j]+W[j][k]/2);
        up(1,n,i) up(1,n,j) T[i][j]=R[i][j];
        up(1,n,i) up(1,n,j) up(1,n,k) T[i][k]=min(T[i][k],T[i][j]+S[j][k]);
    }
    printf("%d\n",T[1][n]);
    return 0;
}
```

---

## 作者：Seauy (赞：8)

## 当无数大佬正在想 分层图 SPFA Dij DP 的时候……

BFS 突然冒了出来，蒟蒻们大呼：“得救了！”，于是其它带有难度的算法被他们给抛弃了……

见此状，我心中也愤愤不平：“难道一道紫题就是给你们用 BFS 水过的吗！”一旁的 FHY 点点头。“本来就是要你们练习分层图的，你们这样子，对得起出题人吗？”

FHY 打开测评记录，忽地发现我 AC 了，疑惑地转过头看我：“你怎么过了？”

我：“是啊，刚过的”

FHY：“你不是不会分层图最短路吗？”

我：“是啊”

FHY：“你……”

# 我用的可不是 BFS
而是她的近亲，DFS 辣 qwq

当然，古典的 DFS 肯定是炸得定定地，于是，记忆化搜索登场了……

用 mem 数组记录状态，参数分别有：

1. now，现在走到了哪里！

2. Left，还有多少 SpellCard！

3. visit，遍历了哪些点！（很显然遍历了已经遍历的点是不优的）

信心满满地认为找到了 DP 大佬们找出的递推式，写完了提交……

[ 大佬：你写的 DP 才用 map！ ]

```cpp
#include<bits/stdc++.h>
using namespace std;

const int MAXN=50;

struct DE{int nxt,val;};

int n,m,k;
map< int,map< int,map<long long,int > > > mem;
map< int,map< int,map<long long,bool> > > vis;
vector<DE> graph[MAXN+5];

int DFS(int now,int Left,long long visit)
{
	/*
		printf("%d %d\n",now,Left);
		system("pause");
	*/
	if(vis[now][Left][visit]) return mem[now][Left][visit];
	if(now==n) return mem[now][Left][visit]=0;
	int cnt=INT_MAX>>1;
	for(int i=0;i<graph[now].size();i++)
	{
		int rear=graph[now][i].nxt;
		int cost=graph[now][i].val;
		if(!(visit&(1<<(rear-1)))) cnt=min(cnt,cost+DFS(rear,Left,visit|(1<<(now-1))));
	}
	for(int i=0;i<graph[now].size() && Left>0;i++)
	{
		int rear=graph[now][i].nxt;
		int cost=graph[now][i].val>>1;
		if(!(visit&(1<<(rear-1)))) cnt=min(cnt,cost+DFS(rear,Left-1,visit|(1<<(now-1))));
	}
	vis[now][Left][visit]=1;
	return mem[now][Left][visit]=cnt;
}

int main()
{
	scanf("%d %d %d",&n,&m,&k);
	for(int i=1;i<=m;i++)
	{
		int a,b,t;
		scanf("%d %d %d",&a,&b,&t);
		graph[a].push_back(DE{b,t});
		graph[b].push_back(DE{a,t});
	}
	printf("%d\n",DFS(1,k,0));
	return 0;
}
```
蓝了一片，不过谢天谢地，还有 50 分……

既然最经典的记忆化会爆内存，那就用剪枝型记忆化吧

还是 mem ，不过参数没了超级大的 visit，功能也变了

$ mem[now][Left] $ 表示搜到目前为止这个状态的最优解

然后再加上个最优化剪枝，你居然用 DFS 过了紫题……

上代码

```cpp
#include<bits/stdc++.h>
using namespace std;

const int MAXN=300;//数组要开大一点，不知道为什么，会 RE

struct DE{int nxt,val;};

int n,m,k,ans=INT_MAX;
int mem[MAXN+5][MAXN+5];
vector<DE> graph[MAXN+5];

void DFS(int now,int Left,int step)
{
	if(step>=mem[now][Left] || step>=ans) return;
    //不加 step>=ans 第三个点会由 RE 变 TLE
	mem[now][Left]=step;
	if(now==n) {ans=min(ans,step);return;}
	for(int i=0;i<graph[now].size();i++)
	{
		int rear=graph[now][i].nxt;
		int cost=graph[now][i].val;
		DFS(rear,Left,step+cost);
	}
	for(int i=0;i<graph[now].size() && Left>0;i++)
	{
		int rear=graph[now][i].nxt;
		int cost=graph[now][i].val>>1;
		DFS(rear,Left-1,step+cost);
	}
}

int main()
{
	scanf("%d %d %d",&n,&m,&k);
	for(int i=1;i<=m;i++)
	{
		int a,b,t;
		scanf("%d %d %d",&a,&b,&t);
		graph[a].push_back(DE{b,t});
		graph[b].push_back(DE{a,t});
	}
	for(int i=1;i<=n;i++)
		for(int j=0;j<=m;j++)
			mem[i][j]=INT_MAX;
	DFS(1,k,0);
	printf("%d\n",ans);
	return 0;
}
```
FHY：“什么情况……”

我：“这可是常规操作。用 DFS 过分层图紫题，要不要再练练？”

[ 本人把那道题的编号给忘了，貌似是个蓝题，也是分层图但是可以用 DFS 水过的……如有同学找到了请私信谢谢 QAQ ]

---

## 作者：回青绝影 (赞：7)

#### QAQ，这道题题面太长了~~废话连篇~~

##### 但这不是重点，重点是这题太 _水_ 了

裸的分层图……

------------

[P4822](https://www.luogu.org/problem/P4822)

[P4568](https://www.luogu.org/problem/P4568)

[P1948](https://www.luogu.org/problem/P1948)

[P2939](https://www.luogu.org/problem/P2939) <--毒瘤，卡数组大小

### 4倍经验！


------------

将上下两层之间连上正常边的权值一半大小的边就可以了！

然后就是分层图常规操作了

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1500001;
struct st{
    int dis,x;
    st (const int a,const int b){
        dis=a;
        x=b;
    }
    bool operator < (const st a)const {
        return dis>a.dis;
    }
};
priority_queue <st> q;
int n,m,cnt,s,t,k;
int nxt[2*N],last[2*N],a[2*N],w[2*N];
int dis[N];
bool l[N];
void add(int x,int y,int z){
    nxt[++k]=last[x];
    last[x]=k;
    a[k]=y;
    w[k]=z;
}
void dijkstra(int s){
    memset(dis,0x3f,sizeof(dis));
    dis[s]=0;
    q.push(st(0,s));
    while (!q.empty()){
        while (!q.empty()&&l[q.top().x]) q.pop();
        if (q.empty()) break;
        int x=q.top().x;q.pop();
        l[x]=1;
        for (int i=last[x];i;i=nxt[i]){
            int y=a[i];
            if (dis[y]>dis[x]+w[i]){
                dis[y]=dis[x]+w[i];
                q.push(st(dis[y],y));
            }
        }
    }
}
signed main(){
    scanf("%lld%lld%lld",&n,&m,&cnt);s=1;t=n;
    // for (int i=0;i<n;i++) last[i]=-1;
    for (int x,y,z,i=1;i<=m;i++){
        scanf("%lld%lld%lld",&x,&y,&z);
        add(x,y,z);add(y,x,z);
        for (int j=1;j<=cnt;j++){
            add(x+(j-1)*n,y+j*n,z/2);
            add(y+(j-1)*n,x+j*n,z/2);
            add(x+j*n,y+j*n,z);
            add(y+j*n,x+j*n,z);
        }
    }
    for (int i=1;i<=cnt;i++) add(t+(i-1)*n,t+i*n,0);
    dijkstra(s);
    printf("%lld",dis[t+cnt*n]);
    return 0;
}
```


---

## 作者：Aicx_ (赞：5)

### 题目描述

“我要成为魔法少女！”
“那么，以灵魂为代价，你希望得到什么？”
“我要将有关魔法和奇迹的一切，封印于卡片之中„„”

在这个愿望被实现以后的世界里，人们享受着魔法卡片（$SpellCard$，又名符卡）带来的便捷。

现在，不需要立下契约也可以使用魔法了！你还不来试一试？
比如，我们在魔法百科全书$(Encyclopedia of Spells)$里用“$freeze$”作为关键字来查询，会有很多有趣的结果。
例如，我们熟知的Cirno，她的冰冻魔法当然会有对应的 $SpellCard$了。 当然，更加令人惊讶的是，居然有冻结时间的魔法$Cirno$的冻青蛙比起这些来真是小巫见大巫了。
这说明之前的世界中有很多魔法少女曾许下控制时间的愿望，比如 $Akemi Homura$ 、$Sakuya Izayoi$ 、„„
当然，在本题中我们并不是要来研究历史的，而是研究魔法的应用。

我们考虑最简单的旅行问题吧： 现在这个大陆上有$N$个城市$M$条双向的道路。城市编号为$1$ $\sim$ $N$ ，我们在$1$号城市，需要到$N$号城市，怎样才能最快地到达呢？
这不就是最短路问题吗？我们都知道可以用$Dijkstra$ 、$Bellman-Ford$ 、$Floyd-Warshall$等算法来解决。
现在，我们一共有$K$张可以使时间变慢$50$%的$SpellCard$ ，也就是说，在通过某条路径时，我们可以选择使用一张卡片，这样，我们通过这一条道路的时间 就可以减少到原先的一半。需要注意的是：

   1. 在一条道路上最多只能使用一张$SpellCard$。
   2. 使用一张$SpellCard$只在一条道路上起作用。
   3. 你不必使用完所有的$SpellCard$。

给定以上的信息，你的任务是：求出在可以使用这不超过$K$张时间减速的$SpellCard$之情形下，从城市$1$到城市$N$最少需要多长时间。
### 输入格式

第一行包含三个整数$N$ , $M$ , $K$。
接下来$M$行，每行包含三个整数$Ai$ , $Bi$ , $Timei$，表示存在一条$Ai$与$Bi$之间的双向道路，在不使用 $SpellCard$之前提下 ，通过它需要$Timei$的时间。
### 输出格式

输出一个整数，表示从$1$号城市到$N$号城市的最小用时。

## 题解 :
分层图板子题 .

最近学了下分层图最短路 , 写篇题解记录一下 . 

对于分层图最短路有个很明显的东西就是题目会强制给你一些条件让你在此基础上跑最短路 .

题目给我们$k$次边权减半的机会 , 直接跑最短路不太好搞 , 于是乎分层图最短路横空出世 .

首先我们对于题目给我们的连边还是正常连 , 但是我们要把连好边的图复制$k$份 , 上下平行放置, 对于原本有边的两个节点 , 我们在不同的图之间给他们连一条边权减半的边 . 通俗来讲的话 , 假如本来$1$号节点与$2$号节点之间有权值为$w$的连边 , 那么我们就在第一张图的$1$号节点与第二张图的二号节点之间连一条权值为$\frac{w}{2}$的边 , 如果在跑最短路的过程中走了这条边 , 那么实际上代表的意义就是我们从$1$号节点走向$2$号节点的过程中用了一次边权减半的机会 , 
挺显然的...吧?

那么我们走到第二张图之后因为第二张图和原图是一样的 , 所以并不影响我们跑最短路的正确性 . 只是它还有减半边权的机会去第三张图 , 一共$k$张图 , $k$次边权减半的机会 , 因为题目没有强行要求我们用完$k$次机会 , 所以答案在每张图的$n$号节点上取$dis[n]$最小值 , 正确性显然 . 

$code:$
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=10000+5;
const int M=50000+5;
#define Is(c) ('0'<=c && c<='9')
inline void read(int &x){
	x=0;char c=getchar();
	while(!Is(c)) c=getchar();
	while(Is(c)) x=(x<<3)+(x<<1)+c-48,c=getchar();
}
int n,m,k,tot;
int head[N*100],dis[N*100],vis[N*100];
struct Edge{
	int next,to,dis;
}e[M*100];
inline void add_edge(int from,int to,int dis){
	e[++tot].next=head[from];
	e[tot].to=to;
	e[tot].dis=dis;
	head[from]=tot;
}
struct cmp{
	int num,dis;
	bool operator < (const cmp&x)const{
		return x.dis<dis;
	}
};
priority_queue<cmp> q;
void dij(){
	memset(dis,0x3f,sizeof(dis));
	q.push((cmp){1,0});dis[1]=0;
	while(!q.empty()){
		int u=q.top().num;
		q.pop();
		if(vis[u]) continue;
		vis[u]=1;
		for(int i=head[u];i;i=e[i].next){
			int v=e[i].to;
			if(dis[v]>dis[u]+e[i].dis){
				dis[v]=dis[u]+e[i].dis;
				q.push((cmp){v,dis[v]});
			}
		}
	}
}
int main(){
	read(n),read(m),read(k);
	if(k>=m){puts("0");return 0;}
	int a,b,c;
	for(int i=1;i<=m;i++){
		read(a),read(b),read(c);
		add_edge(a,b,c);
		add_edge(b,a,c);
		for(int j=1;j<=k;j++){
			add_edge(a+(j-1)*n,b+j*n,c>>1);
			add_edge(b+(j-1)*n,a+j*n,c>>1);
			add_edge(a+j*n,b+j*n,c);
			add_edge(b+j*n,a+j*n,c);
		}
	}
	dij();
	int ans=2147483647;
	for(int i=0;i<=k;i++) ans=min(ans,dis[n+i*n]);
	printf("%d",ans);
	return 0;
}
```

---

## 作者：维迭生 (赞：4)

这道题题解里面竟然没有wqs二分？！  
简直不可饶恕。  
~~话说wqs二分里面的收税思想和这题的代价有点像呢~~  
### 简而言之，就是你每用一张卡， 都要付出一个额外代价
## 但是我们怎么知道这个代价是多少呢？
YY一下：
- 假如代价小了， 那么肯定用的卡片数就多
- 假如代价大了， 那么肯定用的卡片数就少  
### 所以...
## 我们的这个额外代价需要让我们用的卡片数刚好是$K$。		
那么很好, 我们只需要**二分查找这个代价就行了**.  
简单吧?至少我觉得比分层图好写. 

### 还有一些小问题...  
**比如我咋统计我一路上用了多少次卡片呢?**	    

[P1144最短路计数](https://www.luogu.org/problem/P1144)  
方法是一样的哈.

上代码, 具体的细节我加了注释.  
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>

using namespace std;

const int MAXN = 55;
const int MAXM = 2019;

int head[MAXN], to[MAXM << 1], nxt[MAXM << 1], en, c[MAXM << 1], mark[MAXM << 1];
int n, m, k, l, r, mid, ans;
int dis[MAXN], vis[MAXN], cnt[MAXN];

void addedge(int u, int v, int w, int cc){
	to[++en] = v;
	nxt[en] = head[u];
	head[u] = en;
	c[en] = w;
	mark[en] = cc;
	return;
}//mark数组用以标记这条路是否使用了卡片.
struct Node{
	int id, dis, cnt;
	bool operator < (const Node &node) const {
		if(dis == node.dis) return node.cnt < cnt;
		return node.dis < dis; 
	}
}t;


bool check(int cost){		//Dijkstra求最短路
	priority_queue <Node> q;
	memset(dis, 0x3f, sizeof dis);
	memset(cnt, 0x3f, sizeof cnt);
	memset(vis, false, sizeof vis);
	
	cnt[1] = dis[1] = 0;
	t.id = 1, t.cnt = t.dis = 0;
	q.push(t);
	Node fr;int u, v, w;
	while(!q.empty()){
		fr = q.top();
		q.pop();
		u = fr.id;
		if(vis[u]) continue;
		vis[u] = true;
		for(int i = head[u]; i; i = nxt[i]){
			v = to[i], w = c[i];
			if(mark[i]) w += cost;		//假如用了卡片,需要付出额外费用
			if(dis[v] > dis[u] + w){
				dis[v] = dis[u] + w;
				cnt[v] = cnt[u] + mark[i];	//统计cnt的方法神似P1144
				t.id = v, t.cnt = cnt[v], t.dis = dis[v];
				q.push(t);
			}else if(dis[v] == dis[u] + w && cnt[v] < cnt[u] + mark[i]){
				cnt[v] = cnt[u] + mark[i];
				t.id = v, t.dis = dis[v], t.cnt = cnt[v];
				q.push(t);
			}
		}
	}
	return (cnt[n] <= k);
}

int main(){
	scanf("%d%d%d", &n, &m, &k);
	int u, v, w;
	for(int i = 0; i < m; ++i){
		scanf("%d%d%d", &u, &v, &w);
		addedge(u, v, w, 0);
		addedge(v, u, w, 0);
		addedge(u, v, w>>1, 1);		//所有边都加上, 包括用了卡片的
		addedge(v, u, w>>1, 1);		//记得双向边, 数组开4倍.
	}
	
	l = 2, r = 2000;
	while(l <= r){				//二分查找额外花费
		mid = (l+r)>>1;
		if(check(mid)){
			ans = mid;
			r = mid-1;
		}else l = mid+1;
	}
	check(ans);
	return ((printf("%d\n", dis[n]-ans*cnt[n])) &0);	//输出的时候记得把额外花费去掉
}
```

### A完这题可以去A[改造路](https://www.luogu.org/problem/P2939)
可以用wqs二分的
题还有[CF739E Gosha is Hunting](https://www.luogu.org/problem/CF739E), [P4767 邮局](https://www.luogu.org/problem/P4767).

---

## 作者：ez_lcw (赞：4)

# bfs找最短路

其实可以用$dijkstra$或者$SPFA$(我队某巨佬还用了分层图），但我懒得做，~~我才不会告诉你我是不会做的呢~~

因为我们可以看到**数据范围**：$1≤K≤N≤50$，$M≤1000$$

所以能轻易想到思路最简单的算法其实是**$bfs$+$dis$优化硬找最短路**

建边就不说了~~但还是不要作死用邻接矩阵了~~，我用的是**前向星**。

------------

## 至于bfs中的精髓代码：

### 一、用一个二维数组$dis[i][j]$来记忆化

$i$表示节点编号

$j$表示剩余的能使用的$SpellCard$数量

### 二、queue里存的数据
1. u：当前节点

2. s：当前耗费的时间

3. k：当前剩下的能使用的$SpellCard$数量

### 三、分类讨论

我们就分两种情况讨论：
```cpp
//to[i]表示要去的点（v）
//w[i]表示这条边的权值

if(now.s+w[i]<dis[to[i]][now.k])//不使用SpellCard
{
	dis[to[i]][now.k]=now.s+w[i];
	q.push((data){to[i],now.s+w[i],now.k});
}
if(now.k>0&&now.s+w[i]/2<dis[to[i]][now.k-1])//使用SpellCard
{
	dis[to[i]][now.k-1]=now.s+w[i]/2;
	q.push((data){to[i],now.s+w[i]/2,now.k-1});
}
```

------------

最后的代码如下：
```cpp
#include<cstdio>
#include<queue>
#include<cstring>

#define N 51
#define M 2001

using namespace std;

struct data//queue里的东东
{
    int u,s,k;
}now;

int n,m,k,cnt,head[N],to[M],nxt[M],w[M],dis[N][N];

queue<data>q;

void adde(int u,int v,int wi)//链式前向星存边
{
    cnt++;
    to[cnt]=v;
    w[cnt]=wi;
    nxt[cnt]=head[u];
    head[u]=cnt;
}

int bfs()//bfs找最短路
{
    memset(dis,127,sizeof(dis));//初始化
    q.push((data){1,0,k});
    dis[1][k]=0;
    while(!q.empty())
    {
        now=q.front();
        q.pop();
        for(int i=head[now.u];i;i=nxt[i])//刚刚讲到的精髓
        {
            if(now.s+w[i]<dis[to[i]][now.k])
            {
                dis[to[i]][now.k]=now.s+w[i];
                q.push((data){to[i],now.s+w[i],now.k});
            }
            if(now.k>0&&now.s+w[i]/2<dis[to[i]][now.k-1])
            {
                dis[to[i]][now.k-1]=now.s+w[i]/2;
                q.push((data){to[i],now.s+w[i]/2,now.k-1});
            }
        }
    }
    int minn=0x7fffffff;
    for(int i=0;i<=k;i++)minn=min(minn,dis[n][i]);//找最大
    return minn;
}

int main()
{
    scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=m;i++)
    {
        int u,v,wi;
        scanf("%d%d%d",&u,&v,&wi);
        adde(u,v,wi);//双向建边
        adde(v,u,wi);
    }
    printf("%d\n",bfs());
    return 0;
}
```

---

## 作者：Honor誉 (赞：3)

这题其实用不着什么分层图最短路，直接一个二维数组跑SPFA就可以了。

说下思路：

（1）存图可以用vector，也可以用前向星。

（2）我们在进行SPFA的时候，VIS数组和DIS数组都要用二维进行储存。

（3）我们最后计算最短路的时候，要从零到K进行一次取最小值。

相信大家注意以上三点，就大多数人都不会错了。
```cpp
#include<bits/stdc++.h>
using namespace std;
struct data
{
    int x,y;
};
struct data1
{
    int x,y;
};
vector<data> a[51];
int n,m,k,x,y,z,vis[51][51];
double dis[51][51],minn;
queue<data1> q;
int main()
{
    memset(dis,0x7f7f7f7f,sizeof(dis));
    minn=99999999;
    scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d%d",&x,&y,&z);
        a[x].push_back((data)
        {
            y,z
        });
        a[y].push_back((data)
        {
            x,z
        });
    }
    q.push((data1)
    {
        1,k
    });
    vis[1][k]=1;
    dis[1][k]=0;
    while(!q.empty())
    {
        data1 u=q.front();
        q.pop();
        vis[u.x][u.y]=0;
        for(int i=0;i<a[u.x].size();i++)
        {
            int v=a[u.x][i].x;
            int d=a[u.x][i].y;
            if(u.y>0)
            {
                if(dis[v][u.y-1]>dis[u.x][u.y]+d*0.5)
                {
                    dis[v][u.y-1]=dis[u.x][u.y]+d*0.5;
                    if(!vis[v][u.y-1])
                    {
                        vis[v][u.y-1]=1;
                        q.push((data1)
                        {
                            v,u.y-1
                        });
                    }
                }
                if(dis[v][u.y]>dis[u.x][u.y]+d)
                {
                    dis[v][u.y]=dis[u.x][u.y]+d;
                    if(!vis[v][u.y])
                    {
                        vis[v][u.y]=1;
                        q.push((data1)
                        {
                            v,u.y
                        });
                    }
                }
            }else{
                if(dis[v][u.y]>dis[u.x][u.y]+d)
                {
                    dis[v][u.y]=dis[u.x][u.y]+d;
                    if(!vis[v][u.y])
                    {
                        vis[v][u.y]=1;
                        q.push((data1)
                        {
                            v,u.y
                        });
                    }
                }
            }
        }
    }
    for(int i=0;i<=k;i++)
    {
        minn=min(minn,dis[n][i]);
    }
    cout<<minn<<endl;
    return 0;
}
```

---

## 作者：寒鸽儿 (赞：2)

[博客食用效果更佳](https://www.luogu.org/blog/oldherd/solution-p4822)
### 应用分层图最短路解决
分层图最短路，顾名思义，就是将点分成许多层。用来表示不同状态。例如，在本题目中第x层代表目前用了x张卡的情况。在这点上有点类似于dp。  
在层中和层间分别定义好转移关系，例如本题中同一层中的转移路径长度等于原图，向上一层转移路径长度等于原长的二分之一。  
至于这个转移的实现有两种。一种是把距离开成d[maxn][num_card]的形式，像跑dp一样跑，将转移内置在dij中。另一种是把d建成一个数组，用循环存边（就是对于每个转换关系建边），然后跑普通的dij即可。
下面给出的代码是第一种形式
```cpp
#include <cstdio>
#include <cstring>
#include <queue>
#define pii pair<int, int>
#define pip pair<int, pii>

using namespace std;

int head[10010], ver[100010], wei[100010], nex[100010], d[10010][30], vis[10010][30], n, tot, k;

inline void add(int u, int v, int w) {
	ver[tot] = v; wei[tot] = w; nex[tot] = head[u]; head[u] = tot++;
}

priority_queue<pip> q;

void dijkstra() {
	memset(d, -1, sizeof(d)); memset(vis, 0, sizeof(vis));
	d[1][0] = 0; q.push(make_pair(0, make_pair(1, 0)));
	while(!q.empty()) {
		int cur = q.top().second.first, s = q.top().second.second; q.pop();
		if(vis[cur][s]) continue;
		vis[cur][s] = 1;
		for(int i = head[cur]; i != -1; i = nex[i]) {
			if(d[ver[i]][s] == -1 || d[ver[i]][s] > d[cur][s] + wei[i]) {
				d[ver[i]][s] = d[cur][s] + wei[i];
				q.push(make_pair(-d[ver[i]][s], make_pair(ver[i], s)));
			}
			if(s < k && (d[ver[i]][s+1] == -1 || d[ver[i]][s+1] > d[cur][s] + wei[i] / 2)) {
				d[ver[i]][s+1] = d[cur][s] + wei[i] / 2;
				q.push(make_pair(-d[ver[i]][s+1], make_pair(ver[i], s+1)));
			}
		}
	}
}

inline int mind(int i, int j) {
	if(i == -1) return j;
	if(j == -1) return i;
	return i < j ? i : j;
}

int main() {
	int m, u, v, w;
	memset(head, -1, sizeof(head));
	scanf("%d %d %d", &n, &m, &k);
	while(m--) {
		scanf("%d %d %d", &u, & v, &w);
		add(u, v, w); add(v, u, w);
	}
	dijkstra();
	int ans = -1;
	for(int i = 0; i <= k; i++) {
		ans = mind(ans, d[n][i]);
	}
	printf("%d\n", ans);
	return 0;
}
```

欢迎互相关注(然而在oi界蒟蒻的圈很小)。  
最后安利一下[蒟蒻的洛谷博客](https://www.luogu.org/blog/oldherd/)

---

## 作者：suyiheng (赞：2)

```
这道题其实不需要分层图，它其实就是一个典型的二维bfs。
```
```
#include<iostream>
#include<cstdio>
#include<queue>
using namespace std;
int n,m,k,x,y,z,f[51][51],ans=10000000;
vector<int> u[51],v[51];
bool r[51][51];
void bfs(){
	queue<int> p,q;
	p.push(1);
	q.push(0);
	while(!p.empty()){
		x=p.front();
		y=q.front();
		p.pop();
		q.pop();
		r[x][y]=0;
		for(int i=0;i<u[x].size();i++){
			if(f[u[x][i]][y]>f[x][y]+v[x][i]){//不使用【符卡】
				f[u[x][i]][y]=f[x][y]+v[x][i];
				if(r[u[x][i]][y]==0){//剪枝
					p.push(u[x][i]);
					q.push(y);
					r[u[x][i]][y]=1;
				}
			}
			if(y<k){//判断【符卡】是否用完
				if(f[u[x][i]][y+1]>f[x][y]+v[x][i]/2){//若没有用完，使用一张【符卡】
					f[u[x][i]][y+1]=f[x][y]+v[x][i]/2;
					if(r[u[x][i]][y+1]==0){//剪枝
						p.push(u[x][i]);
						q.push(y+1);
						r[u[x][i]][y+1]=1;
					}
				}
			}
		}
	}
}
int main(){
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=n;i++)for(int j=0;j<=k;j++)f[i][j]=10000000;//初始化bfs数组。
	f[1][0]=0;
	for(int i=1;i<=m;i++){
		scanf("%d%d%d",&x,&y,&z);
		u[x].push_back(y);
		v[x].push_back(z);
		u[y].push_back(x);
		v[y].push_back(z);
	}//vector建图（无向图）
	bfs();//爆搜
	for(int i=0;i<=k;i++)ans=min(ans,f[n][i]);//使用【符卡】的个数
	printf("%d",ans);//输出
}
```

---

## 作者：Accoty_AM (赞：1)

~~可能是我脑回路比较清奇~~，想到DP来解这道题。

### F[i][j]表示到第i个点用了j个魔法卡片时的最优解。

最短路考虑用三角形不等式来更新，直接用前面状态往后更新即可

不用卡片

if(f[i][k]+mp[i][j]<f[j][k]){

f[j][k]=f[i][k]+mp[i][j];

}
               
用卡片

if(k)

if(f[i][k-1]+mp[i][j]/2<f[j][k]&&f[i][k-1]!=0x3f3f3f3f){

f[j][k]=f[i][k-1]+mp[i][j]/2;

}

**外层循环N遍即可，因为直接从当前点更新可能不是最优的，由其他点跟新k次后再走这个点才是最优的。**

代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define rg register
inline int read(){
    rg char ch=getchar();
    rg int x=0,f=0;
    while(!isdigit(ch)) f|=(ch=='-'),ch=getchar();
    while(isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return f?-x:x;
}
int n,m,f[55][1010],mp[55][55],ans=0x3f3f3f3f;
int main(){
    n=read();int k=read();m=read();
    memset(mp,0x3f,sizeof mp);
    memset(f,0x3f,sizeof f);
    f[1][0]=0;
    int cnt=1;
	for(int x,y,z,i=1;i<=k;++i){
		x=read(),y=read(),z=read();
		mp[x][y]=mp[y][x]=z;
	}
    for(int l=1;l<=n;++l)
    for(int i=1;i<=n;++i){
        for(int j=1;j<=n;++j){
            if(j==i) continue;
            for(int k=0;k<=m;++k){
                if(f[i][k]+mp[i][j]<f[j][k]){
                    f[j][k]=f[i][k]+mp[i][j];
                }
                if(k)
                if(f[i][k-1]+mp[i][j]/2<f[j][k]&&f[i][k-1]!=0x3f3f3f3f){
                    f[j][k]=f[i][k-1]+mp[i][j]/2;
                }
            }
        }
    }
    for(int i=0;i<=m;++i) if(f[n][i]<=ans) ans=f[n][i],st=i;
    cout<<ans<<endl;
    return 0;
}
```


---

## 作者：ShuraEye (赞：1)

# 广搜不就好了吗，为什么要用spfa呢？？？

这道题其实没那么复杂，一个记忆化广搜直接搞定，其实非常简单。

用一个$struct$里面，存$u$：当前的点，$s$:当前剩下的$spellcard$，$ans$:当前的时间。

然后这里最好加一个记忆化$dis$两维数组，第一维存当前的$to[$i$]$，第二维存当前$spellcard$的个数，可以减少时间复杂度。

这里提醒一下大家，

千万不要用$priority$_$queue$！！！

千万不要用$priority$_$queue$！！！

千万不要用$priority$_$queue$！！！

就是因为用了这个坑人的$priority$_$queue$，我直接$T$90 。。。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1010;
int n,m,k,cnt=0;
int to[N<<1];
int nxt[N<<1];
int w[N<<1];
int head[N<<1];
int dis[N][51];
struct edge
{
    int u,s,ans;
};
void add(int u,int v,int c)
{
    to[++cnt]=v;
    nxt[cnt]=head[u];
    w[cnt]=c;
    head[u]=cnt;
}
void bfs()
{
    queue<edge>q;	
    q.push((edge){1,k,0});
    memset(dis,0x7f,sizeof(dis));
    dis[1][k]=0;
    while(!q.empty())
    {
        edge e=q.front();
        q.pop();
        for(register int i=head[e.u];i;i=nxt[i])
        {
            if(e.s>0&&e.ans+w[i]/2<dis[to[i]][e.s-1])
            {
                q.push((edge){to[i],e.s-1,e.ans+w[i]/2});
                dis[to[i]][e.s-1]=e.ans+w[i]/2;
            }
            if(e.ans+w[i]<dis[to[i]][e.s])
            {
                q.push((edge){to[i],e.s,e.ans+w[i]});
                dis[to[i]][e.s]=e.ans+w[i];
            }
        }
    }
    int minn=0x7fffffff;
    for(register int i=0;i<=k;i++)minn=min(minn,dis[n][i]);
    printf("%d",minn);
}
int read()
{
    char ch=getchar();
    int x=0,f=1;
    while(ch<'0'||ch>'9')
    {
        if(ch=='-')f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}
int main()
{
    n=read();m=read();k=read();
    int a,b,c;
    for(register int i=1;i<=m;i++)
    {
        a=read();b=read();c=read();
        add(a,b,c);add(b,a,c);
    }
    bfs();
    return 0; 
}
/*
4 4 1 
1 2 4 
4 2 6 
1 3 8 
3 4 8 
*/
```

---

## 作者：asd_a (赞：1)

看了数据范围以后，就秒了  
### 允许二维  
所以开一个 dis i,j和in i,j  
表示i至1用j次卡片的最短距离，和i至1用j次卡片的最短距离是否在spfa队列里.  
spfa每次跑两个情况（用或不用）并维护k即可  
coding:
```
#include<bits/stdc++.h>
using namespace std;
int dis[100][100],in[100][100];
int n,m,k;
struct edge{
	int w,to;
};
struct node{
	int x,y;
};
vector<edge>e[10005];
int spfa()
{
	queue<node>q;
	in[1][0]=1;
	q.push(node{1,0});
	dis[1][0]=0;
	while(!q.empty())
	{
		node u=q.front();q.pop();
		for(int i=0;i<e[u.x].size();i++)
		{
			int v=e[u.x][i].to;
			if(dis[v][u.y]>dis[u.x][u.y]+e[u.x][i].w)
			{
				dis[v][u.y]=dis[u.x][u.y]+e[u.x][i].w;
				if(!in[v][u.y])
				{
					in[v][u.y]=1;
					q.push(node{v,u.y});
				}
			}
		}
		if(u.y<k)
		{
			for(int i=0;i<e[u.x].size();i++)
			{
				int v=e[u.x][i].to;
				if(dis[v][u.y+1]>dis[u.x][u.y]+(e[u.x][i].w>>1))
				{
					dis[v][u.y+1]=dis[u.x][u.y]+(e[u.x][i].w>>1);
					if(!in[v][u.y+1])
					{
						in[v][u.y+1]=1;
						q.push(node{v,u.y+1});
					}
				}
			}
		}
	}
	int anss=INT_MAX;
	for(int i=0;i<=k;i++) anss=min(anss,dis[n][i]);
	return anss;
}
int main()
{
	cin>>n>>m>>k;
	int x,y,z;
	for(int i=1;i<=m;i++)
	{
		cin>>x>>y>>z;
		e[x].push_back(edge{z,y});
		e[y].push_back(edge{z,x});
	}
	for(int i=1;i<=n;i++)
		for(int j=0;j<=k;j++)
			dis[i][j]=INT_MAX>>2;
	cout<<spfa()<<endl;
	return 0;
}
```

---

## 作者：linch (赞：0)

前置知识：最短路，分层图。

## Problem
给出一个 $N$ 个节点，$M$ 条边的无向图，你可以任选不超过 $K$ 条边将其边权减小一半。求出最短路径长度。

## Solution
对于每个节点，将其拆分成 $K+1$ 个节点。第 $i$ 层的节点 $j$ 表示到这个节点 $j$ 已经使用了 $i$ 次技能，下面用 $P_{i,j}$ 表示。同时定义$d_{i,j}$ 表示从起点出发，使用了 $i$ 次技能后到达节点 $j$ 的最短路长度。 

采用 DP 思想，分不同决策进行讨论。考虑每一条从 $u$ 到 $v$ 的权值为 $w$ 的一条有向边，可以使用一次技能，将其权值减半，此时需要向下连一层，即对于每一层，从 $P_{i,u}$ 出发，向 $P_{i+1,v}$ 连一条权值为 $\frac{w}{2}$ 的边。转移公式为 $d_{i+1,v}=\min{(d_{i+1,v},d_{i,u}+\frac{w}{2})}$。

同理，也可以选择不使用技能。此时向同一层连边。即对于每一层，从 $P_{i,u}$ 出发，向 $P_{i,v}$ 连一条权值为 $w$ 的边。转移公式为 $d_{i,v}=\min{(d_{i,v},d_{i,u}+w)}$。

对于拆完的点和这张图，跑一次最短路算法即可。最终答案即为 $d_{i,n}(0\le i \le k)$ 中的最小值。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxk=55;
const int maxn=2e3+10;
const int inf=1e9+10;
int n,m,k,cnt,head[maxn],dis[maxk][maxn];
bool vis[maxk][maxn];
struct edge{
	int to,nxt,w;
}e[maxn];
void add_edge(int u,int v,int w){
	e[++cnt]={v,head[u],w};
	head[u]=cnt;
}
void init(){
	for(int i=0;i<=k;i++){
		for(int j=1;j<=n;j++){
			dis[i][j]=inf;
		}
	}
}
struct node{
	int x,p,dis;
};
priority_queue<node>q;
bool operator <(const node &xx,const node &yy){
	return xx.dis>yy.dis;
}
void dijkstra(){
	q.push({1,0,0});
	dis[0][1]=0;
	while(!q.empty()){
		node t=q.top();
		q.pop();
		int u=t.x,c=t.p,d=t.dis;
		if(vis[c][u]) continue;
		vis[c][u]=true;
		for(int i=head[u];i;i=e[i].nxt){
			int v=e[i].to;
			if(c<k && d+e[i].w/2<dis[c+1][v]){
				dis[c+1][v]=d+e[i].w/2;
				q.push({v,c+1,dis[c+1][v]});
			}
			if(d+e[i].w<dis[c][v]){
				dis[c][v]=d+e[i].w;
				q.push({v,c,dis[c][v]});
			}
		}
	}
}
int main(){
	cin>>n>>m>>k;
	init();
	for(int i=1;i<=m;i++){
		int u,v,w;
		cin>>u>>v>>w;
		add_edge(u,v,w);
		add_edge(v,u,w);
	}
	dijkstra();
	int ans=inf;
	for(int i=0;i<=k;i++){
		ans=min(ans,dis[i][n]);
	}
	cout<<ans<<"\n";
	return 0;
}
```
[AC record](https://www.luogu.com.cn/record/200806993)

---

## 作者：hwx12233 (赞：0)

p2939
p4568

这道题就是跑最短路时
$dp$一下

$dis[i][j]$表示到第i个点用了j次的最短路程

$dis[i][j]=min(dis[pre_i][j]+edge[i].dis,dis[pre_i][j-1]+edge[i].dis/2)$

标签没$dp$有失公正

代码如下
```cpp
#include<bits/stdc++.h>
#include<queue>
using namespace std;
const int inf=0x3f3f3f3f;
const int N=1000+10;
struct E{
	int to,dis,next;
}edge[N<<2];
struct node{
	int dis,pos,cnt;
	bool operator <(const node &x)const{return x.dis<dis;}
};
int n,m,k,cnt,head[N],dis[N][N];bool vis[N];
inline void add(int u,int v,int d){
	edge[++cnt].to=v;
	edge[cnt].dis=d;
	edge[cnt].next=head[u];
	head[u]=cnt;
}
priority_queue<node>q;
inline void dijkstra(){
	dis[1][0]=0;
	q.push((node){0,1,0});
	while(!q.empty()){
		node tmp=q.top();q.pop();
		int x=tmp.pos,l=tmp.cnt;
		for(int i=head[x];i;i=edge[i].next){
			int y=edge[i].to;
			if(l<k&&dis[x][l]+edge[i].dis/2<dis[y][l+1]){
				dis[y][l+1]=dis[x][l]+edge[i].dis/2;
				q.push((node){dis[y][l+1],y,l+1});
			}
			if(l<=k&&dis[x][l]+edge[i].dis<dis[y][l]){
				dis[y][l]=dis[x][l]+edge[i].dis;
				q.push((node){dis[y][l],y,l});
			}
		}
	}
}
int main(){
	cin>>n>>m>>k;int u,v,d;
	memset(dis,0x3f,sizeof(dis));
	for(int i=1;i<=m;i++){
		cin>>u>>v>>d;
		add(u,v,d);add(v,u,d);
	}
	dijkstra();
	int ans=100000;
	for(int i=0;i<=k;i++)ans=min(ans,dis[n][i]);
	cout<<ans;
	return 0;
}
```


---

## 作者：EarthGiao (赞：0)

## 【思路】
分层图 + dijkstra    
分层图板子题     
如果想了解分层图请看这里    
[了解分层图](https://www.cnblogs.com/acioi/p/11716483.html)     

### 【题目大意】
从1到n跑    
其中可以让k条路的耗时变为原来的一半    
求最小耗时    

### 【题目分析】
如果你不是第一次做最短路的话   
那看到这k条减半的路    
会情不自禁的联想到k条免费的路   
从而想到分层图这个简单的东西    
本质上K条免费的路和k调皮减半的路处理方式是一个样的   
所以可以用分层图做    

### 【核心思路】
将题目给出的图赋值k遍    
然后将两个图之间的路径都标为原来距离的一半    
因为那条路被使用了魔法    
然后就可以裸着跑dijkstra了    
比较用0次魔法到用k次魔法到达的终点里面   
哪一个消耗的时间最少就是答案了     

### 【注意】
做分层图题目的时候    
必须要对空间范围严格把关    
要不然很容易出问题     
温馨提示：如果不知道开多少，那就能开多大就开多大     

## 【完整代码】
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring> 
using namespace std;
struct point
{
	int w,x;
	bool operator < (const point & xx)const 
	{
		return xx.w < w;
	}
};
const int Max = 100005;
struct node
{
	int y,ne,z;
}a[20 * Max];
int sum = 0;int head[Max];

void add(int x,int y,int z)
{
	a[++ sum].y = y;
	a[sum].ne = head[x];
	a[sum].z = z;
	head[x] = sum;
}
int d[Max];
bool use[Max];
priority_queue<point>q;
void dj()
{
	memset(d,0x3f,sizeof(d));
	d[1] = 0;
	q.push((point){0,1});
	while(!q.empty())
	{
		point qwq = q.top();
		q.pop();
		int x = qwq.x,w = qwq.w;
		if(use[x] == true)
			continue;
		else
			use[x] = true;
		for(register int i = head[x];i != 0;i = a[i].ne)
		{
			int awa = a[i].y;
			if(d[awa] > d[x] + a[i].z)
			{
				d[awa] = d[x] + a[i].z;
				if(use[awa] == false)
					q.push((point){d[awa],awa});
			}
		}
	}
}

int main()
{
	int n,m,k;
	cin >> n >> m >> k;
	int x,y,z;
	for(register int i = 1;i <= m;++ i)
	{
		cin >> x >> y >> z;
		add(x,y,z);
		add(y,x,z);
		for(register int j = 1;j <= k;++ j)
		{
			add(j * n + x,j * n + y,z);
			add(j * n + y,j * n + x,z);
			add((j - 1) * n + x,j * n + y,z / 2);
			add((j - 1) * n + y,j * n + x,z / 2);
		}
	}
	dj();
	int M = 0x7fffffff;
	for(register int i = 0;i <= k;++ i)
		M = min(M,d[i * n + n]);
	cout << M << endl;
	return 0;
}
```

---

## 作者：crashed (赞：0)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.org/problem/P4822)看题目。  
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实这道题跟[[JLOI]飞行路线](https://www.luogu.org/problem/P4568)是基本相同的，建分层图之后跑$Dijkstra$。区别在于从每层图转移的时候边权不是$0$，而是原边权的一半。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;建完之后跑就可以了。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~~爽不爽，一次水两道，出题人真是良心~~  
# 代码
```cpp
#include <queue>
#include <cstdio>
#include <cstring>
using namespace std;

const int INF = 0x3f3f3f3f;
const int MAXN = 1e4 + 5, MAXM = 5e4 + 5, MAXK = 15;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

template<typename _T>
_T MIN( const _T a, const _T b )
{
	return a < b ? a : b;
}

struct node
{
	int u, dis;
	node(){}
	node( const int U, const int Dis ){ u = U, dis = Dis; }
	bool operator < ( const node & other ) const { return ! ( dis < other.dis ); }
};

struct edge
{
	int to, nxt, w;
}Graph[MAXK * MAXM * 4 + MAXK * 2];

priority_queue<node> q;

int dis[MAXN * MAXK];
int head[MAXN * MAXK];
int N, M, K, cnt;
bool visited[MAXN * MAXK];

void addEdge( const int from, const int to, const int W )
{
	cnt ++;
	Graph[cnt].w = W, Graph[cnt].nxt = head[from], Graph[cnt].to = to;
	head[from] = cnt;
}

void Dijkstra( const int sta )
{
	while( ! q.empty() ) q.pop();
	memset( dis, 0x3f, sizeof( dis ) ), memset( visited, false, sizeof( visited ) );
	dis[sta] = 0, q.push( node( sta, 0 ) );
	node h;
	int v, w;
	while( ! q.empty() )
	{
		h = q.top(), q.pop();
		if( visited[h.u] ) continue;
		visited[h.u] = true;
		for( int i = head[h.u] ; i ; i = Graph[i].nxt )
		{
			v = Graph[i].to, w = Graph[i].w;
			if( ! visited[v] && dis[v] > dis[h.u] + w )
				dis[v] = dis[h.u] + w, q.push( node( v, dis[v] ) );
		}
	}
}

int main()
{
	int fr, to, W;
	read( N ), read( M ), read( K );
	for( int i = 1 ; i <= M ; i ++ )
	{
		read( fr ), read( to ), read( W ), fr --, to --;
		for( int j = 0 ; j < K ; j ++ ) addEdge( fr + j * N, to + ( j + 1 ) * N, W >> 1 ), addEdge( to + j * N, fr + ( j + 1 ) * N, W >> 1 );
		for( int j = 0 ; j <= K ; j ++ ) addEdge( fr + j * N, to + j * N, W ), addEdge( to + j * N, fr + j * N, W );
	}
	Dijkstra( 0 );
	int res = INF;
	for( int i = 0 ; i <= K ; i ++ )
		res = MIN( res, dis[( i + 1 ) * N - 1] );
	write( res ), putchar( '\n' );
	return 0;
}
```

---

## 作者：hylong (赞：0)

### 部分一（非正解）
#### 思路：
先运行最短路，再路径还原，找到通过的前k大的边权，在除以2，所得的即为解 ~~（假的）~~。
#### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct prep{
	int x;
	int y;
}pre[51],qk[101];
int px[51];
int mapp[51][51],n,m,k,l;
int dis[100];
bool ok[51];
int read()
{
	int x=0;
	char b=getchar();
	while(b>'9' || b<'0')
	 b=getchar();
	while(b>='0' && b<='9')
	{
	 x=x*10+b-'0';
	 b=getchar();
	}
	return x;
}//快读
void Dijkstra(int s)
{
	int i,b;
	dis[s]=0;
	while(1)
	{
	 b=-1;
	 for(i=1;i<=n;i++)
	  if(!ok[i] && (b==-1 || dis[i]<dis[b]))
	   b=i;
	 if(b==-1)
	  break;
	 ok[b]=true;
	 for(i=1;i<=n;i++)
	 {
	  if(i==n)
	  {
	   if(dis[i]>dis[b]+mapp[b][i])
	   {
	    dis[i]=dis[b]+mapp[b][i];
	    l=0;
	   }
	   if(dis[i]>=dis[b]+mapp[b][i])
	    qk[++l].x=b;
	   break;
	  }
	  if(dis[i]>dis[b]+mapp[b][i])
	  {
	   dis[i]=dis[b]+mapp[b][i];
	   pre[i].x=b;
	   pre[i].y=max(pre[i].y,mapp[b][i]);
	  }
	  else
	   if(dis[i]==dis[b]+mapp[b][i])
	    if(pre[i].y<mapp[b][i])
	    {
	     pre[i].x=b;
	     pre[i].y=mapp[b][i];
		}
	 }
	}
}//Dijkstra找最短路
bool cmp(int x,int y)
{
	return x>y;
}
vector<prep> get(int j)
{
	vector<prep>lu;
	for(;pre[j].x!=-1;j=pre[j].x)
	 lu.push_back(pre[j]);
	reverse(lu.begin(),lu.end());
	return lu;
}//路径还原
int main()
{
	int i,j,o=0,x,y,z,ans=0,minn=0x7ffffff;
    n=read();
    m=read();
    k=read();
    fill(ok,ok+n+1,false);
    fill(dis,dis+n+1,0x7fffffff);
    for(i=1;i<=n;i++)
     for(j=1;j<=n;j++)
      mapp[i][j]=0x7ffffff;
    for(i=1;i<=m;i++)
    {
     x=read();
     y=read();
     z=read();
     mapp[y][x]=mapp[x][y]=min(mapp[x][y],z);
	}
	for(i=1;i<=n;i++)
	 pre[i]={-1,-1};
	Dijkstra(1);
	ans=dis[n];
	for(i=1;i<=l;i++)
	{
	 o=0;
	 ans=dis[n];
	 px[++o]=mapp[n][qk[i].x];
	 for(j=qk[i].x;pre[j].x!=-1;j=pre[j].x)
	  px[++o]=mapp[j][pre[j].x];
	 sort(px+1,px+o+1,cmp);
	 for(j=1;j<=k && j<=o;j++)
	  ans=ans-px[j]/2;
	 minn=min(minn,ans);
	}//找最小的结果
	cout<<minn<<endl;
	return 0;
}
```
这是我开始写的代码，只有70分，然而我不信这个邪，一直用这个思路去写，最高70分。
### 部分二（正解）
#### 个人经历：
在一页多提交后，我信了这个邪，但是又不想丢掉这道紫题，所以我干脆去学分层图最短路（常规解法），然而我连Dijkstra的堆优化都不会，我先是学了Dijkstra的堆优化，再是分层图最短路，最后，在O2优化的帮助下，我终于A了这题。
#### 思路：
多加一维表示用了SpellCard的张数，其它的类似于Dijkstra的堆优化代码（其实就是[P4779](https://www.luogu.org/problem/P4779)的代码改一些小东西）
#### 代码：
```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
using namespace std;
struct Edge{
	int to;
	int next;
	int w;
}edge[10000];
struct node{
	int now;
	int d;
	int zs;
	bool operator < (const node &a)const
	{
	 return d>a.d;
	}//重载运算符
};
int n,m,k,num_edge;
int dis[100][100],ok[100][100],head[100];//dis[i][j]代表点1到点i的情况下用了j张SpellCard的最短路长度
priority_queue<node>que;//别跟我说你连STL优先队列都不知道
int read()
{
	int x=0;
	char g=getchar();
	while(g>'9' || g<'0')
	 g=getchar();
	while(g<='9' && g>='0')
	{
	 x=x*10+g-'0';
	 g=getchar();
	}
	return x;
}//相当于scanf读入正数，因为没有负数，就犯懒删掉了一点点不太要紧的东西
void add(int u,int v,int wei)
{
	num_edge++;
	edge[num_edge].to=v;
	edge[num_edge].w=wei;
	edge[num_edge].next=head[u];
	head[u]=num_edge;
}//加边，如果不会请前往百度百科前向星或一本通邻接表
void Dijkstra()
{
	node a,b;
	int i,x,y,t,qz,e;
	dis[1][0]=0;
	que.push((node){1,0,0});
	while(!que.empty())
	{
	 a=que.top();
	 que.pop();
	 x=a.now;
	 y=a.d;
	 e=a.zs;
	 if(ok[x][e] || y>dis[x][e])
	  continue;
	 ok[x][e]=true;
	 for(i=head[x];i;i=edge[i].next)
	 {
	  t=edge[i].to;
	  qz=edge[i].w;
	  if(dis[t][e]>dis[x][e]+qz)
	  {
	   dis[t][e]=dis[x][e]+qz;
	   que.push((node){t,dis[t][e],e});
	  }//不用SpellCard的情况
	  if(dis[t][e+1]>dis[x][e]+qz/2 && e<k)
	  {
	   dis[t][e+1]=dis[x][e]+qz/2;
	   que.push((node){t,dis[t][e+1],e+1});
	  }//用SpellCard的情况
	 }
	}
}//分层图最短路（常规解法），写过SPFA的人应该都知道
int main()
{
	int i,j,x,y,z;
	int minn=1000006;
	n=read();m=read();k=read();
	for(i=0;i<=n;i++)
	 for(j=0;j<=n;j++)
	  dis[i][j]=1000005,ok[i][j]=false;
	for(i=1;i<=m;i++)
	{
	 x=read();y=read();z=read();
	 add(x,y,z);
	 add(y,x,z);//双向边，所以要加两次
	}
	Dijkstra();
	for(i=0;i<=k;i++)
	 minn=min(minn,dis[n][i]);//求用了0~k张SpellCard后的最短路长度的最小值
	cout<<minn<<endl;
	return 0;
}
```

---

## 作者：Sober_Clever (赞：0)

分层最短路的板子题

构思还是有点有趣

建k层图，第k层编号从1+(k-1)+n到n+(k-1)+n

对于边（u，v，w）

第k层上，（k-1）* n+u 和（k-1）* n+v建一条权值为w的双向边

（k-1）* n+u 到 k * n+v、（k-1）* n+v 到 k * n+u建一条权值为w/2的单向边
（表示用了一次SpellCard ）

最后在整个大图上跑一边最短路即可

~~难得A一道紫题，纪念一下~~

```cpp
#include<cstdio>
#include<cstring>
#include<queue>
const int MAXN=2600 + 3;
using namespace std;
int read()
{
	int x=0,w=1;
	char c=getchar();
	while(c<'0'||c>'9'){if(c=='-') w=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+c-48;c=getchar();}
	return x*w;	
}

struct Edge
{
	int to,next,w;
}e[MAXN*80];
int head[MAXN]={0},cnt=0;
inline void add(int u,int v,int w)
{
	e[++cnt].to=v;
	e[cnt].w=w;
	e[cnt].next=head[u];
	head[u]=cnt;	
}

int d[MAXN],vis[MAXN]={0};
priority_queue<pair<int,int> > Q;
void dij()
{
	memset(d,127,sizeof(d));
	memset(vis,0,sizeof(vis));
	d[1]=0,Q.push(make_pair(0,1));
	while(!Q.empty())
	{
		int u=Q.top().second;
		Q.pop();
		if(vis[u]) continue;
		vis[u]=1;
		for(int i=head[u];i;i=e[i].next)
		{
			int v=e[i].to;
			if(d[v]>d[u]+e[i].w)
			{
				d[v]=d[u]+e[i].w;
				Q.push(make_pair(-d[v],v));
			}
		}
	}
}
int main()
{
	int n=read(),m=read(),k=read();
	for(int i=1;i<=m;i++)
	{
		int u=read(),v=read(),w=read();
		for(int j=0;j<=k;j++)
		{
			add(u+(j-1)*n,v+j*n,w/2);
			add(v+(j-1)*n,u+j*n,w/2);
			add(j*n+u,j*n+v,w);
        add(j*n+v,j*n+u,w);
		}
	}
	dij();
	int ans=1<<30;
	for(int i=0;i<=k;i++)
		ans=min(ans,d[n+i*n]);
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：DukeLv (赞：0)

题目：
```

题目描述

“我要成为魔法少女！”
“那么，以灵魂为代价，你希望得到什么？”
“我要将有关魔法和奇迹的一切，封印于卡片之中„„”

在这个愿望被实现以后的世界里，人们享受着魔法卡片（SpellCard，又名符卡）带来的便捷。

现在，不需要立下契约也可以使用魔法了！你还不来试一试？
比如，我们在魔法百科全书（Encyclopedia of Spells）里用“freeze”作为关键字来查询，会有很多有趣的结果。
例如，我们熟知的Cirno，她的冰冻魔法当然会有对应的 SpellCard 了。 当然，更加令人惊讶的是，居然有冻结时间的魔法，Cirno 的冻青蛙比起这些来真是小巫见大巫了。
这说明之前的世界中有很多魔法少女曾许下控制时间的愿望，比如 Akemi Homura、Sakuya Izayoi、„„
当然，在本题中我们并不是要来研究历史的，而是研究魔法的应用。

我们考虑最简单的旅行问题吧： 现在这个大陆上有 N 个城市，M 条双向的道路。城市编号为 1~N，我们在 1 号城市，需要到 N 号城市，怎样才能最快地到达呢？
这不就是最短路问题吗？我们都知道可以用 Dijkstra、Bellman-Ford、Floyd-Warshall等算法来解决。
现在，我们一共有 K 张可以使时间变慢 50%的 SpellCard，也就是说，在通过某条路径时，我们可以选择使用一张卡片，这样，我们通过这一条道路的时间 就可以减少到原先的一半。需要注意的是：

    在一条道路上最多只能使用一张 SpellCard。
    使用一张SpellCard 只在一条道路上起作用。

    你不必使用完所有的 SpellCard。

    给定以上的信息，你的任务是：求出在可以使用这不超过 K 张时间减速的 SpellCard 之情形下，从城市1 到城市N最少需要多长时间。

输入输出格式
输入格式：

第一行包含三个整数：N、M、K。
接下来 M 行，每行包含三个整数：Ai、Bi、Timei，表示存在一条 Ai与 Bi之间的双向道路，在不使用 SpellCard 之前提下，通过它需要 Timei的时间。

输出格式：

输出一个整数，表示从1 号城市到 N号城市的最小用时。

输入输出样例
输入样例#1： 复制

4 4 1 
1 2 4 
4 2 6 
1 3 8 
3 4 8 

输出样例#1： 复制

7

说明

样例解释：
在不使用 SpellCard 时，最短路为 1à2à4，总时间为 10。现在我们可以使用 1 次 SpellCard，那么我们将通过 2à4 这条道路的时间减半，此时总时间为7。
对于100%的数据：1 ≤ K ≤ N ≤ 50，M ≤ 1000。
1≤ Ai，Bi ≤ N，2 ≤ Timei ≤ 2000。
为保证答案为整数，保证所有的 Timei均为偶数。
所有数据中的无向图保证无自环、重边，且是连通的。

```


这个题本来想先写个暴力，写完之后一算复杂度竟然完全ok？题解区竟然没人写这么简单的作法。。。

我用了我的本命算法：Floyd，然后用一点dp的思路，mp[i][j][k]表示i到j用k张卡片。正常Floyd作法，只有转移略有不同，前后暴力枚举使用卡牌个数，然后相加取最小就行了。

详情见代码

代码：

```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<ctime>
#include<queue>
#include<algorithm>
#include<cstring>
using namespace std;
#define duke(i,a,n) for(register int i = a;i <= n;++i)
#define lv(i,a,n) for(register int i = a;i >= n;--i)
#define clean(a) memset(a,0,sizeof(a))
const int INF = 1 << 30;
typedef long long ll;
typedef double db;
template <class T>
void read(T &x)
{
	char c;
	bool op = 0;
	while(c = getchar(), c < '0' || c > '9')
		if(c == '-') op = 1;
	x = c - '0';
	while(c = getchar(), c >= '0' && c <= '9')
		x = x * 10 + c - '0';
	if(op) x = -x;
}
template <class T>
void write(T x)
{
	if(x < 0) putchar('-'), x = -x;
	if(x >= 10) write(x / 10);
	putchar('0' + x % 10);
}
int n,m,k,mp[55][55][55];
int main()
{
	read(n);read(m);read(k);
	int x,y,t;
	memset(mp,0x3f,sizeof(mp));
	duke(i,1,m)
	{
		read(x);read(y);read(t);
		mp[x][y][0] = t;
		mp[y][x][0] = t;
		mp[x][y][1] = t / 2; //这两行必须有，因为只有这个可以体现出使用卡牌的价值
		mp[y][x][1] = t / 2;
	}
	duke(i,1,n)
	{
		mp[i][i][0] = 0;//初始化
	}
	duke(i,1,n)
	{
		duke(j,1,n)
		{
			if(i != j)
			{
				duke(l,1,n)
				{
					if(i != l && j != l)
					{
						duke(f,0,k)//枚举卡牌数
						duke(g,0,f)//第一段使用的数量
						mp[i][j][f] = min(mp[i][j][f],mp[i][l][g] + mp[l][j][f - g]);//转移
					}
				}
			}
		}
	}
	int maxn = INF;
	duke(i,0,k)
	{
		maxn = min(maxn,mp[1][n][i]);//统计答案
	}
	printf("%d\n",maxn);
	return 0;
}
```


---

## 作者：斯德哥尔摩 (赞：0)

[P4822 [BJWC2012]冻结](https://www.luogu.org/problemnew/show/P4822)

这种题没有分层图+最短路的题解，差评。。。

我来补一个吧。。。

每层正常建图，相邻两层间建长度为$\frac{w}{2}$的边。

然后一发$SPFA$就好了。

最后在$n\times i,i\in [1,k+1]$的最短路中取最小值即可。

这个题正解据说是$SPFA+DP$，但是我不会啊。。。

[本蒟蒻的博客](https://www.cnblogs.com/Yangrui-Blog/p/9498018.html)

附代码：
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<queue>
#define MAXN 3010
#define MAXM 1000010
#define MAX 999999999
using namespace std;
int n,m,k,s,t,c=1;
int head[MAXN],path[MAXN];
bool vis[MAXN];
struct Graph{
    int next,to,w;
}a[MAXM<<1];
inline int read(){
    int date=0,w=1;char c=0;
    while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
    while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}
    return date*w;
}
int relax(int u,int v,int w){
    if(path[v]>path[u]+w){
        path[v]=path[u]+w;
        return 1;
    }
    return 0;
}
inline void add(int u,int v,int w){
    a[c].to=v;a[c].w=w;a[c].next=head[u];head[u]=c++;
}
void spfa(){
    int u,v;
    queue<int> q;
    for(int i=1;i<=n*(k+2);i++){path[i]=MAX;vis[i]=false;}
    path[s]=0;
    vis[s]=true;
    q.push(s);
    while(!q.empty()){
        u=q.front();
        q.pop();
        vis[u]=false;
        for(int i=head[u];i;i=a[i].next){
            v=a[i].to;
            if(relax(u,v,a[i].w)&&!vis[v]){
                vis[v]=true;
                q.push(v);
            }
        }
    }
}
void work(){
    int ans=MAX+1;
    spfa();
    for(int i=1;i<=k+1;i++)ans=min(ans,path[i*n]);
    printf("%d\n",ans);
}
void init(){
    int u,v,w;
    n=read();m=read();k=read();
    s=1;t=n;
    for(int i=1;i<=m;i++){
        u=read();v=read();w=read();
        for(int j=0;j<=k;j++){
            add(u+j*n,v+j*n,w);
            add(v+j*n,u+j*n,w);
        }
        for(int j=0;j<k;j++){
            add(u+j*n,v+(j+1)*n,w>>1);
            add(v+j*n,u+(j+1)*n,w>>1);
        }
    }
}
int main(){
    init();
    work();
    return 0;
}

```

---

## 作者：Mr_Wu (赞：0)

**前置知识**

建图，求最短路

**题面**

[BJWC2012]冻结 [luogup4622](https://www.luogu.org/problemnew/show/P4822)

**题意**

一个连通无向图，无自环、重边，可令至多$k$条边的边权变为原来的一半，求$1$~$n$最短路。

**算法**

分层图 + 最短路。

你一开始有一个图。

把这个图复制成$K+1$个，对于一条边$(u,v,k)$，在第$i$个图的$u$和第$i+1$个图的$v$之间连一条权为$\frac{k}{2}$的边。

也保证了“每条边最多用一次SpellCard”。

建完图直接从点$1$跑最短路就行了。

最后把每个图的$dis[n]$都找出来取$min$就是答案。

边的数组要开大啊！~~我交了5次90把边大小开大五倍就过了~~

----

参考代码：

```cpp
#include <cstdio>
#include <queue>
using namespace std;

#define MAXN 500005
#define INF 2147483647
inline long long read() //没有任何亮点的读入优化
{
    char c = getchar();
    long long ret = 0, t = 1;
    while ((c < '0' || c > '9') && c != '-') c = getchar();
    if (c == '-') t = -1, c = getchar();
    while (c >= '0' && c <= '9') ret = (ret << 3) + (ret << 1) + c - '0', c = getchar();
    return ret * t;
}

int N, M, K;
struct node
{
    int v, next, cost;
}E[MAXN]; //链式前向星存图（好像不用？）
int Elen, head[MAXN], dis[MAXN], ans = INF;
bool vis[MAXN];
void add(int u, int v, int k)
{
    ++Elen, E[Elen].v = v, E[Elen].next = head[u], head[u] = Elen, E[Elen].cost = k;
}
struct state
{
    int v, dis;
};
struct cmp
{
    bool operator() (state a, state b)
    {
        return a.dis > b.dis;
    }
};
priority_queue<state, vector<state>, cmp> Q;
void dijkstra(int s)
{
    int i;
    state u, t;
    for (i = 1; i <= N * (K + 1); ++i) dis[i] = INF;
    dis[s] = 0;
    t.v = s, t.dis = 0;
    Q.push(t);
    while (!Q.empty())
    {
        u = Q.top();
        Q.pop();
        if (vis[u.v]) continue;
        vis[u.v] = true;
        for (i = head[u.v]; i; i = E[i].next)
        {
            if (dis[u.v] + E[i].cost < dis[E[i].v])
            {
                dis[E[i].v] = dis[u.v] + E[i].cost;
                t.v = E[i].v, t.dis = dis[E[i].v];
                Q.push(t);
            }
        }
    }
}
int main()
{
    N = read(), M = read(), K = read();
    register int i, j, u, v, k;
    for (i = 1; i <= M; ++i)
    {
        u = read(), v = read(), k = read();
        for (j = 0; j <= K; ++j)
        {
            add(u + j * N, v + j * N, k);
            add(v + j * N, u + j * N, k);
            //每个图上都要连边
        }
        for (j = 0; j < K; ++j)
        {
            add(u + j * N, v + (j + 1) * N, k >> 1);
            add(v + j * N, u + (j + 1) * N, k >> 1);
            //相邻编号的图的对应点连边权一半
        }
    }
    dijkstra(1);
    for (i = 1; i <= K + 1; ++i) ans = min(ans, dis[N * i]);
    //每个图的dis[N]取Min
    printf("%d", ans);
    return 0;
}
```

---

## 作者：zjc23 (赞：0)

我的解法是spfa+dp

f[i][j]表示走到i点用了j次卡牌消耗的时间

那么在spfa时，很容易就可以通过松弛操作来将f[u][j]转移到f[v][j]和f[v][j+1],注意j+1不能大于K。

代码
```cpp
#include <bits/stdc++.h>

using namespace std;

int f[51][51];
int to[1001],nex[1001],head[51],val[1001],ce;
int n,m,k;
bool vis[51][51];

void add(int u,int v,int w){
	to[++ce]=v;nex[ce]=head[u];head[u]=ce;val[ce]=w;
}

int read(){
	int x=0;char ch=getchar();
	while(!isdigit(ch))ch=getchar();
	while(isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();
	return x;
}

void spfa(){
	queue< pair<int,int> > q;//用pair来装i和j
	pair<int,int> u;
	f[1][0]=0;
	q.push(make_pair(1,0));
	vis[1][0]=1;
	while(!q.empty()){
		u=q.front();q.pop();
		vis[u.first][u.second]=0;
		for(int i=head[u.first];i;i=nex[i]){

		if(f[u.first][u.second]+val[i] < f[to[i]][u.second]){
				f[to[i]][u.second]=f[u.first][u.second]+val[i];
			if(!vis[to[i]][u.second]){
				vis[to[i]][u.second]=1;
				q.push(make_pair(to[i],u.second));
			}
		}

		if((u.second+1 <=k) && (f[u.first][u.second]+val[i]/2 < f[to[i]][u.second+1])){
				f[to[i]][u.second+1]=f[u.first][u.second]+val[i]/2;
				if(!vis[to[i]][u.second+1]){
					vis[to[i]][u.second+1]=1;
					q.push(make_pair(to[i],u.second+1));
				}
			}
		}
	}
}

void init(){
	for(int i=1;i<=n;i++)
	for(int j=0;j<=k;j++)//这里注意要从第零次开始赋值
		f[i][j]=1e9;
}

int main(){
	n=read(),m=read(),k=read();
	init();
	for(int i=1;i<=m;i++){
		int u=read(),v=read(),w=read();
		add(u,v,w);
		add(v,u,w);
	}
	spfa();
	int ans=1e9;
	for(int i=0;i<=k;i++)ans=min(ans,f[n][i]);
	printf("%d",ans);
	return 0;
}

```

---


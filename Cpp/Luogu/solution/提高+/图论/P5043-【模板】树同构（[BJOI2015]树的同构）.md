# 【模板】树同构（[BJOI2015]树的同构）

## 题目描述

树是一种很常见的数据结构。

我们把 $N$ 个点，$N-1$ 条边的连通无向图称为树。

若将某个点作为根，从根开始遍历，则其它的点都有一个前驱，这个树就成为有根树。

对于两个树 $T_1$ 和 $T_2$，如果能够把树 $T_1$ 的所有点重新标号，使得树 $T_1$ 和树 $T_2$ 完全相同，那么这两个树是同构的。也就是说，它们具有相同的形态。

现在，给你 $M$ 个无根树，请你把它们按同构关系分成若干个等价类。

## 说明/提示

编号为 $1, 2, 4$ 的树是同构的。编号为 $3$ 的树只与它自身同构。

对于 $100\%$ 的数据，$1\leq N,M\leq 50$。

## 样例 #1

### 输入

```
4 
4 0 1 1 2 
4 2 0 2 3 
4 0 1 1 1 
4 0 1 2 3 ```

### 输出

```
1 
1 
3 
1 ```

# 题解

## 作者：zhoukangyang (赞：135)

[更蒟蒻的体验](https://www.cnblogs.com/zkyJuruo/p/14175062.html)

听说题解里全是 $O(n^2m)$ 的，今天神 [@](https://codeforces.com/profile/tourist)[hehezhou](https://www.luogu.com.cn/user/67371
) 介绍了一种优秀的方法。

用多项式哈希，记录走过的结点的顺序。

首先如果是有根树，而且儿子结点有先后遍历顺序这样子就是对的。

然后如果儿子结点没有顺序就按照儿子的哈希值排序，然后再哈希。

有根树拓展到无根树只要找到重心然后再做即可。（两个重心也是可以的，比较的时候看看两个哈希值能否对应上即可）

于是得出了哈希值，最后暴力比较即可。

时间复杂度 $\Theta(mn \log n)$, 时间复杂度瓶颈再于对哈希值排序。

神仙 `Forever_Pursuit`说他用基数排序，因此是 $\Theta(mn)$。

# 代码：

```cpp
#include<bits/stdc++.h>
#define L(i, j, k) for(int i = j, i##E = k; i <= i##E; i++) 
#define R(i, j, k) for(int i = j, i##E = k; i >= i##E; i--)
#define ll long long
#define ull unsigned long long 
#define db double
#define pii pair<int, int>
#define pil pair<int, lonf long>
#define mkp make_pair
using namespace std;
const int N = 55;
const int mod = 1019260817;
const int G = 19491001;
int Pow[N];
int n, m;
struct Tree {
	int A, B;
} f[N];
bool operator == (Tree aa, Tree bb) {
	return aa.A == bb.A && aa.B == bb.B;
}
int head[N], edge_id;
struct edge {
	int to, next;
} e[N << 1];
void add_edge(int u, int v) {
	++edge_id, e[edge_id].to = v, e[edge_id].next = head[u], head[u] = edge_id;
}
int has[N], siz[N], dep[N], rt, rrt, rtm;
void findrt(int x, int fa) {
	siz[x] = 1;
	int maxn = 0;
	for(int i = head[x]; i; i = e[i].next) {
		int v = e[i].to;
		if(v == fa) continue;
		findrt(v, x), siz[x] += siz[v], maxn = max(maxn, siz[v]);
	}
	maxn = max(maxn, n - siz[x]);
	if(maxn < rtm) rtm = maxn, rt = x, rrt = 0;
	else if(maxn == rtm) rrt = x;
}
int tot;
pii sav[N];
void dfs(int x, int fa) {
	has[x] = 1ll * dep[x] * Pow[1] % mod, siz[x] = 1;
	for(int i = head[x]; i; i = e[i].next) {
		int v = e[i].to;
		if(v == fa) continue;
		dep[v] = dep[x] + 1, dfs(v, x);
	}
	tot = 0;
	for(int i = head[x]; i; i = e[i].next) {
		int v = e[i].to;
		if(v == fa) continue;
		sav[++tot] = mkp(has[v], siz[v]);
	}
	sort(sav + 1, sav + tot + 1);
	L(i, 1, tot) (has[x] += 1ll * sav[i].first * Pow[siz[x]] % mod) %= mod, siz[x] += sav[i].second;
}
void In(int x) {
	rtm = mod, rrt = 0;
	scanf("%d", &n);
	L(i, 1, n) {
		int v; scanf("%d", &v);
		if(v) add_edge(i, v), add_edge(v, i);
	}
	findrt(1, -1);
	dep[rt] = 1, dfs(rt, -1), f[x].A = has[rt];
	if(rrt) dep[rrt] = 1, dfs(rrt, -1), f[x].B = has[rrt];
	if(f[x].A < f[x].B) swap(f[x].A, f[x].B);
	L(i, 1, n) head[i] = 0;
	edge_id = 0;
}
int mian() {
	Pow[0] = 1;
	L(i, 1, 50) Pow[i] = 1ll * Pow[i - 1] * G % mod;
	scanf("%d", &m);
	L(i, 1, m) In(i);
	L(i, 1, m) L(j, 1, i) if(f[i] == f[j]) {
		printf("%d\n", j);
		break;
	}
	return 0;
}
```

**祝大家学习愉快！**

---

## 作者：hyfhaha (赞：58)

咦，见没人发题解，我来水一波。
# 进入正题
题意：将所有树结构相同的树归类。
## 思路
嗯，这道题让我们把树的结构归类，自然而然就想到了哈希，我们对这整颗树哈希一遍。然后判同构就十分之简单了。只需要找哈希值一样的树就可以了。

其实真得很简单，不知道为什么是紫的。如果思路还不懂的话，可以看代码注释。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const long long maxn=1001;
long long ans[maxn][maxn],n,m,head[maxn],last[maxn],Next[maxn],tot,x;
void add(int x,int y){				//建边 
    last[++tot]=y;Next[tot]=head[x];head[x]=tot;
}
long long Hash(int x,int f)			//树哈希 
{
    long long q[maxn],ans=maxn,top=0;
    for(int i=head[x];i;i=Next[i])	//遍历所以子节点 
    if(last[i]!=f)					//不能再次遍历以遍历的点，即x的父亲 
	q[++top]=Hash(last[i],x);
    sort(q+1,q+top+1);				//把哈希打得更乱 
    for(int i=1;i<=top;i++)			//对x点计算哈希值 
    ans=ans*2333+q[i];
    return ans*2333+maxn+1;
}
int main(){
    cin>>m;
    for(int i=1;i<=m;i++)
    {
        tot=0;memset(head,0,sizeof(head));		//建边清0 
        cin>>n;
        for(int j=1;j<=n;j++)
        {
            cin>>x;
            if(x!=0)add(x,j),add(j,x);
        }
        for(int j=1;j<=n;j++)
        ans[i][j]=Hash(j,0);			//树哈希 
        sort(ans[i]+1,ans[i]+n+1);
        for(int j=1,k=0;j<=i;j++)
        {
            while(k<=n) if(ans[i][++k]!=ans[j][k]) break;	//找同构 
            if(k>n){printf("%d\n",j);break;}	//找到同构就输出 
        }
    }
    return 0;
}
```

---

## 作者：ix35 (赞：39)

## P5043 树同构

这题我用了相对准确的最小表示法来完成（与某个取模 Hash 对拍时，那个 Hash 炸得很惨，不知道是否是写法原因）。

另一篇题解也是最小表示，但是我的实现方式不同。

---

### 一、有根树的最小表示

树的括号序列转化：从树根开始执行一次 DFS，每一个结点的子树都有进入和回溯两个过程。DFS 过程中维护一个序列，进入一个子树时向序列中加入一个左括号，回溯时向序列中加入一个右括号，如此可以构成长度为 $2\times n$ 的括号序列。

然而 DFS 过程中，一个点 $u$ 有多个子结点 $v_1,v_2,\cdots,v_k$，因此在不规定访问顺序的情况下，同一棵树有多种不同的括号序列，其中字典序最小的一个称为这颗**有根树的最小表示**。

最小表示法的性质：

**两颗有根树树同构的充要条件是其最小表示相同。**

证明：

充分性：通过最小表示可以唯一确定一棵树的结构：从根节点出发，遇到左括号就向下走一步，遇到右括号就向上走一步，这样的走法在结点无标号时是确定的。树的结构显然唯一确定，因此最小表示相同，树的结构就相同。

必要性：结构相同，DFS 过程完全相同，最小表示显然相同。

**最小表示的求法**：

DFS 一次即可，设 $f_i$ 表示以 $i$ 为根的子树的最小表示。设一个点 $u$ 的子结点分别为 $v_1,\cdots,v_k$，则将 $f_{v_1},\cdots,f_{v_k}$ 按字典序从小到大排序，有：

$$f_u=(f_{v_1}\cdots f_{v_n})$$

字符之间直接连接。

最坏时间复杂度为 $O(n^2)$，此为链的情况。

---

### 二、无根树的同构

一种简单粗暴的方法：对于树 $T$，枚举每个点 $i$ 为根求出最小表示 $ans_i$，令 $ans(T)=\min(ans_i)$，得到所有最小表示中的字典树最小值。这样，两棵树 $T1,T2$ 同构的充要条件就是 $ans(T_1)=ans(T_2)$。

这个方法的原理其实是无根树转成有根树，令 $ans_i$ 取到最小值的 $i$ 设为 $minroot(T)$，则 $ans(T_1)=ans(T_2)$ 即 $ans_{minroot(T_1)}=ans_{minroot(T_2)}$，而无根树要同构，只需要以某个点为根转化为有根树后同构即可。

该算法完成 [这题](https://www.luogu.com.cn/problem/P5043) 的时间复杂度是 $O(n^3m)$，还有进一步优化的空间。

对于两棵同构树 $T$，我们只需要快速找到其中两个“同位点”（即在同构树中结构位置相同的点），以这两个同位点为根检验最小表示即可，事实上，任意两个同位点得出的最小表示都应该是相同的。

通常我们选择的同位点是重心。

对于树 $T$，设其重心为 $G_1,G_2$（也可能只有 $1$ 个），设 $ans(T)=\min(ans_{G_1},ans_{G_2})$，则两棵无根树同构当且仅当 $ans$ 值相同。

因此对于每棵树，我们只需要最多检验两个点的最小表示，时间复杂度变成 $O(n^2m)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN=60;
int t,n,x,eg,mnp,flg,hd[MAXN],ver[2*MAXN],nx[2*MAXN],sz[MAXN],mx[MAXN];
string mn[MAXN],f[MAXN],g[MAXN],tmp;
void add_edge (int x,int y) {
	ver[++eg]=y;
	nx[eg]=hd[x];
	hd[x]=eg;
	return;
}
void dfs1 (int x,int fa) {
	sz[x]=1;
	for (int i=hd[x];i;i=nx[i]) {
		if (ver[i]==fa) {continue;}
		dfs1(ver[i],x);
		sz[x]+=sz[ver[i]];
		mx[x]=max(mx[x],sz[ver[i]]);
	}
	mx[x]=max(mx[x],n-sz[x]);
	mnp=min(mnp,mx[x]);
	return;
}
void dfs2 (int x,int fa) {
	f[x]="0";
	for (int i=hd[x];i;i=nx[i]) {
		if (ver[i]==fa) {continue;}
		dfs2(ver[i],x);
	}
	int tot=0;
	for (int i=hd[x];i;i=nx[i]) {
		if (ver[i]==fa) {continue;}
		g[++tot]=f[ver[i]];
	}
	sort(g+1,g+tot+1);
	for (int i=1;i<=tot;i++) {f[x]+=g[i];}
	f[x]+="1";
	return;
}
int main () {
	scanf("%d",&t);
	for (int ii=1;ii<=t;ii++) {
		scanf("%d",&n);
		memset(hd,0,sizeof(hd));
		memset(mx,0,sizeof(mx));
		eg=flg=0,mnp=n+1;
		tmp="1";
		for (int i=1;i<=n;i++) {
			scanf("%d",&x);
			if (x) {add_edge(x,i),add_edge(i,x);}
		}
		dfs1(1,0);
		for (int i=1;i<=n;i++) {
			if (mx[i]==mnp) {
				dfs2(i,0);
				tmp=min(tmp,f[i]);
			}
		}
		mn[ii]=tmp;
		for (int i=1;i<=ii-1;i++) {
			if (mn[i]==mn[ii]) {
				printf("%d\n",i),flg=1;
				break;
			}
		}
		if (!flg) {printf("%d\n",ii);}
	}
	return 0;
}
```







---

## 作者：Starlight237 (赞：38)

没有人发$ELFHash$的题解吗？

## $ELF\ Hash$
我们先看一个最简单的错位叠加的字符串哈希：
```cpp
inline uint hs(char *s){
	reg uint sm=0;
	reg char *p=s;
	while(*p)sm=(sm<<4)+*p++;
	return (sm&0x7fffffff);
}
```
但是这个哈希函数显然可能会溢出，从而增加冲突的可能性。

为了防止溢出，可以利用一个辅助变量x，每次更新哈希值的时候执行以下操作：
```cpp
(x=sm&0xf0000000)&&(sm^=(x>>24),sm&=~x);
//为了压行+卡常数进行了改写，实际上等同如下代码：
x=sm;
if(x&0xf0000000)sm^=(x>>24),sm&=~x;
```
它的意义是：取x的可能溢出的最高一位，若不为零则有溢出风险，这时最简单的方式就是直接暴力地把溢出的内容转移到低位，这样既可保证每一位都对hash值有影响。

可以证明，这样的哈希方式正确率是极高的。

那么如何应用到树上哈希？

首先经典的树哈希是这样的：
$$hash_i=val_i+\sum hash_{son_j}\times something$$
对比一下经典字符串哈希：
$$hash_i=val_i+hash_{i-1}\times something$$
故可以仿照字符串哈希，进行如下操作（这里我取的$val=1$）：
```cpp
unsigned int Has(int x,int fa){
	unsigned int siz=0,tmp,sm=1,s[51];
	for(reg int i=head[x];i;i=eg[i].nxt)
		if(eg[i].v!=fa)s[++siz]=Has(eg[i].v,x);
	sort(s+1,s+siz+1);
	for(reg int i=1;i<=siz;++i)
		sm=(sm<<4)+s[i],
		(tmp=sm&0xf0000000)&&(sm^=(tmp>>24),sm&=~tmp);
	return (sm&0x7fffffff);
}
```
其余操作可以参见其他题解。

顺便指出，hyfhaha大佬的题解中比较哈希值的时候出现了一个UB（未定义操作），本题能够AC，但是有一定风险。

### 本文完结
## 点赞是一种美德

---

## 作者：142857cs (赞：18)

看到这题只有一个不知道是什么的题解，所以来发一篇题解

先考虑根固定的情况

这时可以用树的最小表示法（也可以用树哈希，但不知道另外那篇题解写的哈希是什么）

对树进行dfs，得到括号序列，然后对树的所有子树求最小表示法，再用trie树对子树的最小表示法排序，就得到了树的最小表示法

根固定的树的最小表示法和树的形态是一一对应的，但是这题的根并不固定（题面有点不明确，但样例是这样），所以直接求是错的

考虑找树的重心，如果它是唯一的，可以以它为根求最小表示法

否则，一定是两棵大小为n/2的树中间连一条边

对两边的树分别求最小表示法（这时根是固定的了），再比较它们的字典序，把字典序小的放前面

这样得到的字符串一定和树的形态一一对应，用trie树存一下就行了

时间复杂度O(m*n^2)

```cpp
#include<stdio.h>
struct node{
	int ch[2];
	int size;
	int val;
};
node nn[4096];
int num;
void add(char* s,int n,int now)
{
	nn[now].size++;
	if(n==0)
	{
		nn[now].val++;
		return;
	}
	if(!nn[now].ch[s[0]-'0'])
	{
		num++;
		nn[num].ch[0]=0;
		nn[num].ch[1]=0;
		nn[num].size=0;
		nn[num].val=0;
		nn[now].ch[s[0]-'0']=num;
	}
	add(s+1,n-1,nn[now].ch[s[0]-'0']);
}
int query(char* s,int n,int now,int i)
{
	if(n==0)
	{
		if(nn[now].val==0)
		{
			nn[now].val=i;
		}
		return nn[now].val;
	}
	if(!nn[now].ch[s[0]-'0'])
	{
		num++;
		nn[num].ch[0]=0;
		nn[num].ch[1]=0;
		nn[num].size=0;
		nn[num].val=0;
		nn[now].ch[s[0]-'0']=num;
	}
	return query(s+1,n-1,nn[now].ch[s[0]-'0'],i);
}
void sol(char* s,int n)
{
	if(n==0)
	{
		return;
	}
	int lastwz=0;
	int cnt=0;
	for(int i=0;i<n;i++)
	{
		if(s[i]=='0')
		{
			cnt++;
		}
		else
		{
			cnt--;
		}
		if(cnt==0)
		{
			sol(s+lastwz+1,i-lastwz-1);
			lastwz=i+1;
		}
	}
	num=0;
	nn[num].ch[0]=0;
	nn[num].ch[1]=0;
	nn[num].size=0;
	nn[num].val=0;
	cnt=0;
	lastwz=0;
	for(int i=0;i<n;i++)
	{
		if(s[i]=='0')
		{
			cnt++;
		}
		else
		{
			cnt--;
		}
		if(cnt==0)
		{
			add(s+lastwz,i-lastwz+1,0);
			lastwz=i+1;
		}
	}
	int now=0;
	cnt=0;
	while(1)
	{
		if(nn[now].size==0)
		{
			break;
		}
		nn[now].size--;
		if(nn[now].val)
		{
			nn[now].val--;
			now=0;
			continue;
		}
		if(nn[now].ch[0]&&nn[nn[now].ch[0]].size)
		{
			s[cnt]='0';
			now=nn[now].ch[0];
		}
		else
		{
			s[cnt]='1';
			now=nn[now].ch[1];
		}
		cnt++;
	}
}
char s[64][128];
int len[64];
int head[64],last[128],to[128],cnt=0;
int size[64];
void add(int u,int v)
{
	cnt++;
	last[cnt]=head[u];
	head[u]=cnt;
	to[cnt]=v;
}
void dfs(int u,int f)
{
	size[u]=1;
	for(int i=head[u];i;i=last[i])
	{
		int v=to[i];
		if(v==f)
		{
			continue;
		}
		dfs(v,u);
		size[u]+=size[v];
	}
}
int findroot(int u,int f,int n)
{
	for(int i=head[u];i;i=last[i])
	{
		int v=to[i];
		if(v==f)
		{
			continue;
		}
		if(size[v]<=n)
		{
			continue;
		}
		return findroot(v,u,n);
	}
	return u;
}
int tim;
void dfs2(int u,int f,int id)
{
	s[id][tim]='0';
	tim++;
	for(int i=head[u];i;i=last[i])
	{
		int v=to[i];
		if(v==f)
		{
			continue;
		}
		dfs2(v,u,id);
	}
	s[id][tim]='1';
	tim++;
}
int main()
{
	int m;
	scanf("%d",&m);
	for(int i=1;i<=m;i++)
	{
		int n;
		scanf("%d",&n);
		for(int i=1;i<=n;i++)
		{
			head[i]=0;
		}
		cnt=0;
		for(int j=1;j<=n;j++)
		{
			int v;
			scanf("%d",&v);
			if(v)
			{
				add(j,v);
				add(v,j);
			}
		}
		dfs(1,0);
		int u=findroot(1,0,n>>1);
		int v=0;
		for(int i=head[u];i;i=last[i])
		{
			if((size[to[i]]<<1)==n)
			{
				v=to[i];
				break;
			}
		}
		tim=0;
		dfs2(u,v,i);
		if(v)
		{
			dfs2(v,u,i);
		}
		sol(s[i],tim);
		len[i]=tim;
	}
	num=0;
	nn[num].ch[0]=0;
	nn[num].ch[1]=0;
	nn[num].size=0;
	nn[num].val=0;
	for(int i=1;i<=m;i++)
	{
		printf("%d\n",query(s[i],len[i],0,i));
	}
	return 0;
}
```

---

## 作者：zzw4257 (赞：11)

~~介于这道题没大佬发重心的写法，我就来凑个热闹~~

- ## 前置知识

### 一.树的重心

定义如下：删掉某节点$i$后，若剩余$k$个连通分量，那么定义$d(i)$为这些连通分量中节点数的最大值。所谓重心，就是使得$d(i)$最小的节点$i$。

定理：__重心最多有两个__

证明：__比较感性的理解__:一个重心代表一种最优均分的方案，最坏的情况就是左右为难，两个划分同样优

求法:

```
//size[x]为x子树大小
//maxl为最后min{d(i)}
inline void DFS(re int x,re int fa){
	size[x]=1;
	re int i,y,res=0;
	for(i=h[x];i;i=e[i].next){
		y=e[i].to;if(y==fa)continue;
		DFS(y,x);
		size[x]+=size[y];
		res=max(res,size[y]);
	}
	res=max(res,n-size[x]);d[x]=res;
	maxl=min(maxl,res);
}
```

最后比较一下重心即可出来

```
//每次调用时
maxl=INF;DFS(1,0);
for(j=1;j<=n;++j){if(d[j]==maxl)rt[++tot]=j;}
```
### 二.树的同构

- 引入:$POJ1635$

- 概念：我们对一棵树的最小$01$欧拉序($0->$入 $1->$出)称为其最小表示，判断两树是否同构可比较它们的最小表示

- 实现：

	- 法一：根据定义直接递归解决
    
    - 法二：对于更大的数据我们采用树$Hash$
    
	核心：
	
	```
	inline int Solve(re int x,re int fa){
	re int i,y,res=2333;
	re vector<int > t;
	for(i=h[x];i;i=e[i].next){
		y=e[i].to;if(y==fa)continue;
		t.push_back(Solve(y,x));
	}
	sort(t.begin(),t.end());
	for(i=0;i<t.size();++i)res=((res*Mul)^t[i])%Mod;
	return res;
}
	```

对这道题：考虑对两棵同构的无根树，我们只需要比较其以树上固定点(即不会因为编号方式改变改变的点)为根的$Hash$值,重心则是一个很好的例子

步骤：先找每棵树重心（最多两个），以重心为根来比较

注意一些细节：

由于重心的编号顺序不一定因此我们每次都要存下所有重心为根$Hash$值

还是放一下代码：

```
inline void DFS(re int x,re int fa){
	size[x]=1;
	re int i,y,res=0;
	for(i=h[x];i;i=e[i].next){
		y=e[i].to;if(y==fa)continue;
		DFS(y,x);
		size[x]+=size[y];
		res=max(res,size[y]);
	}
	res=max(res,n-size[x]);d[x]=res;
	maxl=min(maxl,res);
}
inline int Solve(re int x,re int fa){
	re int i,y,res=2333;
	re vector<int > t;
	for(i=h[x];i;i=e[i].next){
		y=e[i].to;if(y==fa)continue;
		t.push_back(Solve(y,x));
	}
	sort(t.begin(),t.end());
	for(i=0;i<t.size();++i)res=((res*Mul)^t[i])%Mod;
	return res;
}
int main(void){
	re int i,j,x;
	scanf("%d",&m);
	memset(ans,INF,sizeof ans);
	for(i=1;i<=m;++i){
		scanf("%d",&n);
		cnt=0;memset(h,0,sizeof h);tot=0;
		for(j=1;j<=n;++j){scanf("%d",&x);if(x){AddEdge(j,x);AddEdge(x,j);}}
		maxl=INF;DFS(1,0);
		for(j=1;j<=n;++j){if(d[j]==maxl)rt[++tot]=j;}
		for(j=1;j<=tot;++j)ans[i]=min(ans[i],Solve(rt[j],0));
		for(j=1;j<=i;++j)if(ans[j]==ans[i]){printf("%d\n",j);break;}
	}
	return 0;
}
```


---

## 作者：EnofTaiPeople (赞：9)

### Part1 前言

我在一年前写过树同构，但那种方法是复杂度极高且容易产生冲突的，一年之后，我想要介绍三种方法，其中一种较慢但是确定性算法，另外两种保证线性但是基于数值哈希的方式，但并没有通用 Hack，即 Hack 方式仅限于对着代码卡。

### Part2 确定性算法

考虑对一棵有根树进行哈希，定义一棵有根树的哈希值为其所有子树哈希值组成的数组排序后的结果，这是一个 `vector`，我们每加入一个 `vector` 就用 `map` 给它标号。

这样可以做到绝对正确，但我们只做到了有根树，时间复杂度为 $O(n^2\log n)$。

考虑一棵无根树最多有两个重心，我们可以对每一个重心分别哈希，然后取最值。

于是得到了本题的做法，时间 $O(NS\log S)$，空间 $O(\sum n^2)$，其中 $N=\max n,S=\sum n$。

代码片段：
```cpp
int calc(int x,int pr){
    vector<int>a={-1};
    for(int y:lk[x])
        if(y!=pr)a.push_back(calc(y,x));
    sort(a.begin(),a.end());
    if(!mp[a])mp[a]=++mt;
    return mp[a];
}
```

### Part3 较劣的非确定性算法

上面发现，我们每获得一个 `vector` 就将其插入了 `map` 内，而 `vector` 的比较是 $O(n)$ 的，所以我们可以对于每一个 `vector` 进行字符串哈希后再插入 `map`，这样就变成了时间 $O(S\log S)$，空间 $O(S)$。

代码片段：
```cpp
int calc(int x,int pr){
    vector<int>a={0};
    for(int y:lk[x])
        if(y!=pr)a.push_back(calc(y,x));
    sort(a.begin(),a.end());
    ul res=0;
    for(int p:a)res=res*C+rp[p];
    if(!mp[res])mp[res]=++mt;
    return mp[res];
}
```

### Part4 较优的非确定性算法

其实我认为这个算法比上面更优是因为其更简便且更好用。

它是基于和哈希的，但我们不能单纯地将儿子的哈希值加起来，这样会有通用卡法，甚至你随便拍几组就挂了。

所以需要对儿子节点的哈希值做多项式变换，即让一个函数作用于它。

然后你会发现可以用换根 dp 在 $O(n)$ 的时间内求出以所有节点为根的哈希值，然后就可以暴力取最值了。

于是本题优化到了时空 $O(S)$ 十分优秀。

代码片段：
```cpp
void dfs(int x,int pr){
    h1[x]=13;if(pr){
        auto it=lk[x].begin();
        while(*it!=pr)++it;lk[x].erase(it);
    }
    for(int y:lk[x])
        dfs(y,x),h1[x]+=F(h1[y]);
}
void dp(int x,int pr){
    if(pr)h2[x]=h1[x]+F(h2[pr]-F(h1[x]));
    else h2[x]=h1[x];
    for(int y:lk[x])dp(y,x);
    lk[x].clear();
}
```

以上三种算法均可以通过本题和 [SPOJ 加强版](https://www.luogu.com.cn/problem/SP7826)。

### Part5 后记

马上就要省选了，HNOI2023rp++！

过了样例 $\Leftrightarrow$ 得分在 $[0,100]$ 之间。

---

## 作者：Cht_master (赞：7)

- 提供一种在 $n=10^5$ 的级别也很难出现错误的哈希计算公式：

>- 注意以 $u$ 为根的子树指以 1 为起点遍历时 $u$ 的子树；而以 $u$ 为根时的全树指以 $u$ 为起点遍历整棵树。

- 令 $f(u)$ 表示以结点 $u$ 为根的子树对应的哈希值，$g(u)$ 表示 $u$ 为根时全树的哈希值；$size(u)$ 为以 $u$ 为根的子树的大小，$fa(u)$ 为 $u$ 的父亲；$prime(i)$ 指第 $i$ 个质数。计算公式为：
$$
f(u)=\sum_{v\in son(u)}f(v)\cdot prime(size(v))\\
g(u)=prime(siz(1)-siz(u))\cdot(g(fa(u))-f(u)\cdot prime(size(u)))+f(u)
$$

- 其中 $f(u)$ 就能满足一般的树同构的判断了。$g(u)$ 的计算用换根 DP 实现。

- 最后需要尤其注意 $g(T1)=g(T2)$ 但 $size(T1)\not =size(T2)$ 的情况是存在的，所以需要在最后特判一下。

- 如果仍然觉得判断不准确，可以对树的两个重心（如果有两个重心）分别进行 DP 然后看哈希值一不一样；在此的基础上再用双哈希。

- 利用 `set` 实现 $\text{Two Point}$ 的复杂度为 $O(nm\log_2n)$；若再利用哈希判断优化可以做到 $O(nm)$。

```cpp
#include<bits/stdc++.h>
#define ull unsigned long long
using namespace std;
const int mxNM(5e1);
namespace Prm{//埃氏筛足矣.
	int cnt,Is[23005],prm[mxNM*mxNM+5];
	void Art_scan(int R){
		for(int i(0);i<=R;++i)Is[i]=-1;
		for(int i(2);i<=R;++i)if(Is[i]==-1){
			Is[i]=1,prm[++cnt]=i;
			for(int j(i<<1);j<=R;j+=i)Is[j]=0;
		}
	}
}
namespace Trees{
	int m;//m个树.
	struct Tree{
		int fa[mxNM+5],siz[mxNM+5];
		vector<int>nd[mxNM+5];
		ull f[mxNM+5],g[mxNM+5];//令f(u)表示以结点u为根的子树对应的哈希值,g(u)表示u为根时全树的哈希值.
		void add(int u,int v){if(u&&v)nd[u].push_back(v);}//不更新0结点.
		void dfs1(int u,int pre){//计算f(u).
			fa[u]=pre,siz[u]=f[u]=1;
			for(int i(0),v;i<nd[u].size();++i){
				v=nd[u][i];if(v==pre)continue;
				dfs1(v,u),siz[u]+=siz[v],f[u]=f[u]+(1ull)*f[v]*Prm::prm[siz[v]];
			}
		}
		void dfs2(int u){//计算g(u).
			g[u]=Prm::prm[siz[1]-siz[u]]*(g[fa[u]]-f[u]*Prm::prm[siz[u]])+f[u];
			for(int i(0),v;i<nd[u].size();++i)if(nd[u][i]!=fa[u])dfs2(nd[u][i]);
		}
	}tr[mxNM+5];
	void sol(){
		for(int i(1);i<=m;++i)tr[i].dfs1(1,0);
		for(int i(1);i<=m;++i)tr[i].dfs2(1);
		for(int T1(1);T1<=m;++T1){//Two Point.
			set<ull>s;s.clear();
			for(int u(1);u<=tr[T1].siz[1];++u)s.insert(tr[T1].g[u]);
			for(int T2(1),F(0);T2<=m;++T2){
				for(int u(1);u<=tr[T2].siz[1];++u)
					if(tr[T1].siz[1]==tr[T2].siz[1]&&s.find(tr[T2].g[u])!=s.end()){F=1,printf("%d\n",T2);break;}//记得特判树的大小.
				if(F)break;
			}
		}
	}
}
int main(){
	Prm::Art_scan(23000);//大约要算到23000.
	scanf("%d",&Trees::m);
	for(int i(1),n;i<=Trees::m;++i){
		scanf("%d",&n);
		for(int u,v(1);v<=n;++v)scanf("%d",&u),Trees::tr[i].add(u,v),Trees::tr[i].add(v,u);
	}
	Trees::sol();
	return 0;
}
```

---

## 作者：Aw顿顿 (赞：6)

> **[P5043 【模板】树同构](https://www.luogu.com.cn/problem/P5043)**
>
> 给定两棵树 $T_1,T_2$，若能够将他们的节点重新标号使得他们的结构相同，则称他们为同构树。
>
> 现给定 $m$ 棵树，对于每棵树求与其同构的树的最小编号。

对于同构更严谨的定义参见 Wiki，核心思想是在点集之间建立双射。

不妨考虑忽略题目中的 $0$ 节点。

## 最小表示 / AHU 算法

假定现在有一颗有根树，以树根为起点，我们需要进行一次 DFS，现在我们要通过深搜产生一个括号序列。我们规定在进入一个子树时向序列中加入一个左括号，回溯时向序列中加入一个右括号，通过不断地操作维护序列，最终会产生一个长度为结点数两倍（对于本题，是 $2\times n$）的括号序列。

由于遍历的顺序不同，产生的括号序列也有所不同。我们规定在所有合法的括号序列之中，字典序最小的序列被命名为**有根树最小表示**。求取最小表示的意义在于，两棵树的最小表示相同等价于两棵树同构。因为同构的两棵树最小表示显然相同，而最小表示对于无标号树确定了唯一的访问顺序，通过**唯一的访问顺序**可以确定**唯一的树形结构**。

记 $f_i$ 为一棵树以 $i$ 节点为根的最小表示，那么这其实是一个字符串序列，对于 $u$ 的所有节点 $v$，最小表示可以被记作：

$$f_u=\sum f_{v_i}$$

## 同构无根树

而对于一颗无根树，我们考虑他们的同构和有根树同构之间的关系。最简单的方案是，求出一颗无根树的最小表示中的**字典序最小值**，具体而言是这样的：

$$T(f)=\min\{f_1,f_2,\cdots,f_n\}$$

由于对于指定根求最小表示在树退化成一条链的情况下复杂度是 $O(n^2)$ 的，因此对于无根树按上述方法求取实际上复杂度是 $O(n^3)$。对于模板题来说，比对 $m$ 棵树的最小表示总复杂度为 $O(n^3m)$ 是不够优秀的，考虑在无根树这一块优化复杂度。由于如果我们能够在两棵树之间找到**同位点**，即在两颗同构树中处于同一位置的点并对其求最小表示即可。

这样的点在哪里呢？考虑**树的重心**。一棵树至多有两个重心，此处给出判定方法：

- 重心数量不同的两棵树不同构。
- 均有一颗重心 $u$ 的两棵树是同构的当且仅当 $f_{u_1}=f_{u_2}$。
- 均有两颗重心 $u,v$ 的两棵树是同构的当且仅当 $\min\{f_{u_1},f){v_1}\}=\min\{f_{u_2},f){v_2}\}$。

现在，问题非常明了，对于每一棵树我们检验的点数是极少的，因此整体复杂度被优化到 $O(n^2m)$，已经足够通过模板题，普通的树哈希复杂度也是一样的。**朴素的 AHU 算法还有优化的空间**，此处暂时不提及。

## 算法实现

我们需要两次 DFS 来实现这样的算法，第一次 DFS 要求出每一个节点的 $size$ 和 $mx$ 值：

```cpp
void dfs1(int x,int fa){
	sz[x]=1;
	for(int i=h[x];i;i=e[i].nxt){
		int v=e[i].v;
		if(v==fa)continue;
		dfs1(v,x);
		sz[x]+=sz[v];
		mx[x]=max(mx[x],sz[v]);
	}mx[x]=max(mx[x],n-sz[x]);
	mp=min(mp,mx[x]);return;
}
```

第二次的 DFS 就可以确定以指定节点为根的最小表示。若将括号序列用 $\texttt{01}$ 序列表示，则一个节点的最小表示是一个 $\texttt{0}$ 之后按字典序加上所有子树的最小表示。因此在此过程中需要排序，其余只需要在递归过程中进行构造即可：

```cpp
void dfs2(int x,int fa){
	f[x]="0";
	for(int i=h[x];i;i=e[i].nxt){
		int v=e[i].v;
		if(v!=fa)dfs2(v,x);
	}int tot=0;
	for(int i=h[x];i;i=e[i].nxt){
		int v=e[i].v;
		if(v!=fa)son[++tot]=f[v];
	}sort(son+1,son+tot+1);
	for(int i=1;i<=tot;i++)f[x]+=son[i];
	f[x]+="1";return;
}
```

## 全文代码

全文代码实现如下：

```cpp
#include<bits/stdc++.h>
#define N 99
using namespace std;
struct Edge{
    int v,nxt;
}e[N<<1];
int h[N],cnt;
int T,n,x,mp,flag,sz[N],mx[N];
string mn[N],f[N],g[N],tmp;
void add(int u,int v){e[++cnt].v=v;e[cnt].nxt=h[u];h[u]=cnt;}
void dfs1(int x,int fa){
	sz[x]=1;
	for(int i=h[x];i;i=e[i].nxt){
		int v=e[i].v;
		if(v==fa)continue;
		dfs1(v,x);
		sz[x]+=sz[v];
		mx[x]=max(mx[x],sz[v]);
	}mx[x]=max(mx[x],n-sz[x]);
	mp=min(mp,mx[x]);return;
}void dfs2(int x,int fa){
	f[x]="0";
	for(int i=h[x];i;i=e[i].nxt){
		int v=e[i].v;
		if(v!=fa)dfs2(v,x);
	}int tot=0;
	for(int i=h[x];i;i=e[i].nxt){
		int v=e[i].v;
		if(v!=fa)g[++tot]=f[v];
	}sort(g+1,g+tot+1);
	for(int i=1;i<=tot;i++)f[x]+=g[i];
	f[x]+="1";return;
}void init(){
	memset(h,0,sizeof h);
	memset(mx,0,sizeof mx);
	cnt=flag=0,mp=n+1;tmp="1";
}signed main(){
	scanf("%d",&T);
	for(int k=1;k<=T;k++){
		scanf("%d",&n);init();
		for(int i=1;i<=n;i++){
			scanf("%d",&x);
			if(x)add(x,i),add(i,x);
		}dfs1(1,0);
		for(int i=1;i<=n;i++){
			if(mx[i]==mp){
				dfs2(i,0);
				tmp=min(tmp,f[i]);
			}
		}mn[k]=tmp;
		for(int i=1;i<k;i++){
			if(mn[i]==mn[k]){
				printf("%d\n",i);
				flag=1;
				break;
			}
		}if(!flag)printf("%d\n",k);
	}return 0;
}
```






---

## 作者：Yosame (赞：6)

感觉本题根本评不上紫题的难度.jpg

# 什么是哈希？
[https://baike.baidu.com/item/Hash/390310?fr=aladdin](Hash)百度百科中的解释

简单来讲，把具有相同特征的东西，映射为相同的一个数，这样可以方便我们来判断两个东西是否相同。

具体到本题来说，对于相同结构的树，对应的哈希值就应该相同，我们可以以此来判断两棵树是否是~~同分异构体~~同构的树。

# 具体怎么做？

前面说了，把一棵树映射为一个数，那么按照什么法则来映射？这就需要你自己来定规则了。首先可以定一个点为根节点，然后我们可以把所有子树的大小的乘积作为**这棵树**以**该节点为根节点**时的哈希值大小。
### 但是！！！
我们很容易发现，按照此规则来哈希，很有可能两棵不同的树，哈希值是相等的。

因此，我们就需要将我们的哈希规则尽量设置得复杂一点，当然，并没有固定的哈希方式。举个例子，在本题中，我用dfs的哈希方式是：

1、先将本层的值设为1，每次深搜子树返回时，将该值左移一位，再加上子树的返回值。

2、预处理时用rand()随机出一个数组（设为a），假设本次dfs深度为d，那么本次dfs返回值再增加a[d]。

最后，只需要比较每棵树以每个点作为根节点得到的**所有哈希值是否相等**即可。

下面上代码：

```cpp
#include<cstdio>
#include<vector>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<ctime>
#define ci const int
#define ull unsigned long long
#define mp 2600
using namespace std;
int head[mp],ver[mp<<1],nxt[mp<<1],num[54],tot,m,pairx[54],hrd[54];//hash_random_seed 
bool v[mp];
ull hashr[54][54];
inline int rd(){
    int io=0;char in=getchar();
    while(in<'0'||in>'9')in=getchar();
    while(in>='0'&&in<='9')io=(io<<3)+(io<<1)+(in^'0'),in=getchar();
    return io;
}
inline void adds(ci x,ci y){
	ver[++tot]=y;
	nxt[tot]=head[x];
	head[x]=tot;
}
ull dfs(ci x,ci dep){
	v[x]=1;ull hash=1;
	for(int t=head[x];t;t=nxt[t]){
		int y=ver[t];
		if(v[y])continue;
		hash<<=1;
		hash*=dfs(y,dep+1);
	}
	return hash+hrd[dep];
}
int main(){
	m=rd();
	srand(unsigned(time(0)));
	for(int t=0;t<=50;++t)hrd[t]=rand();
	for(int t=0;t<m;++t){
		int n=rd(),id=t*50;
		num[t]=n;
		for(int z=1;z<=n;++z){
			int x=rd();
			if(x)adds(z+id,x+id),adds(x+id,z+id);
		}
	}
	for(int t=0;t<m;++t){
		for(int x=1;x<=num[t];++x){
			memset(v+1+t*50,0,50);
			hashr[t][x]=dfs(x+t*50,0);
		}
	}
	for(int t=0;t<m;++t){
		sort(hashr[t]+1,hashr[t]+num[t]+1);
		for(int x=0;x<t;++x){
			bool findx=1;
			if(num[t]!=num[x])continue;
			for(int c=1;c<=num[x];++c)if(hashr[t][c]!=hashr[x][c]){
				findx=0;
				break;
			}
			if(findx){
				pairx[t]=x+1;
				break;
			}
		}
		printf("%d\n",pairx[t]?pairx[t]:t+1);
	}
	return 0;
}
```


---

## 作者：阿萨德 (赞：6)

很容易想到用hash来解决本题

楼下的题解求了以每一个点为根的hash值，事实上，我们只需要以**树的重心**作为根即可（若重心在边上则跑两遍）

但是，本题如果采取传统的hash方法很容易撞，我们需要一个巧妙的hash方法

```cpp
//伪代码
hash[v] = 1;
for v in {son(u)}
	hash[u] = hash[u] + hash[v];
hash[u] = hash[u] * hash[u];
```

---

## 作者：山田リョウ (赞：5)

首先先把题目弱化一下，假如是有根树该怎么做。

很容易想到判断几棵树是否相同可以去看括号序是否一样，只要求出括号序再丢尽 `std::map` 里解决就行了。

对应同一个节点的儿子该按什么顺序连在一起呢？可以考虑把它们的括号序按字典序排个序，按这个顺序连在一起。

但是字符串比较有点慢，是 $\mathcal{O}\left(n\right)$ 的，可以考虑把字符串换成字符串的哈希值，但是我们注意到此题数据范围极小，$n$ 最大也就 $50$，所以可以考虑把括号序压成二进制数（左括号是 $0$，右括号是 $1$）,最大不会超过 $2^{2\times50=100}-1$（其实最大是 $2^{99}$，因为括号序首位一定是左括号。。。），用 `int128` 存就行了。

求这个值的参考代码如下：
```cpp
struct int128{
	unsigned long long a,b;
	int128 operator <<(const size_t&o)const{
		return (o<64)?(int128){a<<o|b>>64-o,b<<o}:(int128){b<<o-64,0};
	}
	int128 operator |(const int128&o)const{
		return (int128){a|o.a,b|o.b};
	}
	bool operator <(const int128&o)const{
		return a==o.a?b<o.b:a<o.a;
	}
}name[51];int size[51],head[51],m,n,A[51];
struct{int v,nxt;}e[51];
inline bool cmp(int a,int b){return name[a]<name[b];}
void dfs(int x,int f){
	int tot=0;size[x]=1;name[x]={0,0};
	for(int i=head[x];~i;i=e[i].nxt)
		if(e[i].v!=f){
			dfs(e[i].v,x);
			size[x]+=size[e[i].v];
		}
	for(int i=head[x];~i;i=e[i].nxt)if(e[i].v!=f)A[tot++]=e[i].v;
	std::sort(A,A+tot,cmp);
	for(int i=0;i<tot;++i)name[x]=name[x]<<(size[A[i]]<<1)|name[A[i]];
	name[x]=name[x]<<1|(int128){0,1};
}
```
但是本题里的树是无根树，我们要把它变成有根树，可以考虑用树的重心（最多也只有 $2$ 个）作为根求出括号序压成整数的值，如果有两个重心就把这两个重心作为根求出的值取个最小值就好了。

时间复杂度是 $\mathcal{O}\left(mn\log n\right)$，其中的 $\log n$ 是来自排序，所以如果我们用字符串哈希，把模数取小点（就比如取 `101`），再用基数排序的话，是可以做到 $\mathcal{O}\left(mn\right)$ 的，但是由于要取模，而且此题中的 $\log n$ 很小，我就没写哈希的做法，毕竟哈希或许可以卡掉。

代码（目前最优解 rank$1$）
```cpp
#include<stdio.h>
#include<algorithm>
#include<map>
struct int128{
	unsigned long long a,b;
	int128 operator <<(const size_t&o)const{
		return (o<64)?(int128){a<<o|b>>64-o,b<<o}:(int128){b<<o-64,0};
	}
	int128 operator |(const int128&o)const{
		return (int128){a|o.a,b|o.b};
	}
	bool operator <(const int128&o)const{
		return a==o.a?b<o.b:a<o.a;
	}
}name[51];int size[51],head[51],m,n,A[51];
struct{int v,nxt;}e[51];
inline bool cmp(int a,int b){return name[a]<name[b];}
void dfs(int x,int f){
	int tot=0;size[x]=1;name[x]={0,0};
	for(int i=head[x];~i;i=e[i].nxt)
		if(e[i].v!=f){
			dfs(e[i].v,x);
			size[x]+=size[e[i].v];
		}
	for(int i=head[x];~i;i=e[i].nxt)if(e[i].v!=f)A[tot++]=e[i].v;
	std::sort(A,A+tot,cmp);
	for(int i=0;i<tot;++i)name[x]=name[x]<<(size[A[i]]<<1)|name[A[i]];
	name[x]=name[x]<<1|(int128){0,1};
}
int cent[2],tot;
void query(int x,int f){
	size[x]=1;int weight=0;
	for(int i=head[x];~i;i=e[i].nxt)
		if(e[i].v!=f){
			query(e[i].v,x);
			size[x]+=size[e[i].v];
			weight=size[e[i].v]>weight?size[e[i].v]:weight;
		}
	if((weight<<1)<=n&&n<=(size[x]<<1))cent[tot++]=x;
}
int main(){
	std::map<int128,int> MAP;
	scanf("%d",&m);
	for(int k=1;k<=m;++k){
		scanf("%d",&n);
		for(int i=1;i<=n;++i)head[i]=-1;tot=0;
		int cnt=0;
		for(int i=1;i<=n;++i){
			int x;scanf("%d",&x);
			if(x){
				e[cnt]={x,head[i]},head[i]=cnt++;
				e[cnt]={i,head[x]},head[x]=cnt++;
			}
		}
		query(1,0);
		dfs(cent[0],0);
		int128 NAME=name[cent[0]];
		if(tot>1)dfs(cent[1],0),NAME=name[cent[1]]<NAME?name[cent[1]]:NAME;
		if(MAP.find(NAME)!=MAP.end())printf("%d\n",MAP[NAME]);
		else printf("%d\n",MAP[NAME]=k);

	}
	return 0;
}
```

---

## 作者：DengDuck (赞：4)

这道题判断树结构是否相等，尽可能简单地存储最多的信息的特征，可以考虑哈希。

考虑如何求出一个树的哈希值。

首先随机生成一个参数，利用其进行哈希，每个树的权值就是其子树的权值乘上随机参数再加一。

不过可能会溢出，所以加上一个模数，我用的是 $10^9+7$。

但是同构还需要考虑不同的点作为根的不同情况，所以我们对于每个节点作为根都要生成一个哈希值，然后和前面的树比较。

时间复杂度是 $O(n^2m)$ 的。
```cpp
#include<bits/stdc++.h> 
#define LL long long
using namespace std;
const LL mod=1e9+7;
LL T,n,m,x,len[55],ans[55][55]; 
vector<LL>v[55];
LL dfs(LL x,LL fa)
{
	LL cnt=1;
	for(LL i:v[x])
	{
		if(i==fa)continue; 
		cnt=(cnt+dfs(i,x)*T)%mod; 
	}
	return cnt;
}
int main()
{
	srand(time(0));
	T=rand();
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=50;j++)v[j].clear();
		cin>>m;
		len[i]=m;
		for(int j=1;j<=m;j++)
		{
			cin>>x;
			if(x==0)continue;
			v[x].push_back(j);
			v[j].push_back(x);
		}
		for(int j=1;j<=m;j++)
		{
			ans[i][j]=dfs(j,0);
		}
		sort(ans[i]+1,ans[i]+m+1);
		for(int j=1;j<=i;j++)
		{
			if(len[j]!=m)continue;
			bool f=0;
			for(int k=1;k<=m;k++)
			{
				if(ans[j][k]!=ans[i][k])
				{
					f=1;
					break;
				}
			}
			if(!f)
			{
				cout<<j<<endl;
				break; 
			}
		}
	}
}
```

---

## 作者：Infinite_Eternity (赞：4)

# Description

[P5043 【模板】树同构（[BJOI2015]树的同构）](http://www.luogu.com.cn/problem/P5043)

我们把 $N$ 个点，$N-1$ 条边的连通无向图称为树。

若将某个点作为根，从根开始遍历，则其它的点都有一个前驱，这个树就成为有根树。

对于两个树 $T_1$ 和 $T_2$，如果能够把树 $T_1$ 的所有点重新标号，使得树 $T_1$ 和树 $T_2$ 完全相同，那么这两个树是同构的。也就是说，它们具有相同的形态。

现在，给你 $M$ 个无根树，请你把它们按同构关系分成若干个等价类。

数据范围：$1\leq N,M\leq 50$。

# Analysis

树哈希模板题。

这里介绍一种不容易被卡的树哈希。

判断树同构有两种办法，一种是最小表示法，一种就是树哈希。

树哈希有很多办法，但是大多很容易被卡掉，这里介绍一种。

> $f_{x}$ 表示 $x$ 为根的子树的 Hash 值，$son_{x}$ 表示 $x$ 的子结点的集合，$size_{y}$ 表示 $y$ 为根的子树规模，$prime(i)$ 表示第 $i$ 个素数，则：
> $$f_{x}=1+\sum_{y \in son_{x}}f_{y}\times prime(size_{y})$$

同样地，树哈希是可以换根 dp 的，也就是说可以求出每一个点作为根的答案。

如果我们需要快速判断，那么我们可以考虑重心来判断，最多四个重心，一共也四种情况，只要一个满足则说明两个树同构。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
template <typename T>
inline void read(T &x)
{
	x=0;char ch=getchar();bool f=false;
	while(!isdigit(ch)){if(ch=='-'){f=true;}ch=getchar();}
	while(isdigit(ch)){x=x*10+(ch^48);ch=getchar();}
	x=f?-x:x;
	return ;
}
template <typename T>
inline void write(T x)
{
	if(x<0) putchar('-'),x=-x;
	if(x>9) write(x/10);
	putchar(x%10^48);
	return ;
}
#define ll long long
#define PII pair<int,int>
#define mp make_pair
#define fi first
#define se second
const int N=1e5+5,M=1e6+5;
int n,m,p,prime[N],cnt,siz[N],f[N],g[N],rt,Ans[N];
vector<int>vec[N];
bool vis[M];
void Primes(int n)
{
	for(register int i=2;i<=n;++i)
    {
		if(!vis[i]) prime[++cnt]=i;
		for(register int j=1;i*prime[j]<=n&&j<=cnt;++j)
        {
			vis[i*prime[j]]=true;
			if(i%prime[j]==0) break;
		}
	}
	return ;
}
void dfs1(int x)
{
	f[x]=1;siz[x]=1;
	for(auto y:vec[x]){dfs1(y);siz[x]+=siz[y];f[x]+=f[y]*prime[siz[y]];}
	return ;
}
void dfs2(int x,int val)
{
	val=val*prime[n-siz[x]];
	g[x]=f[x]+val;
	for(auto y:vec[x]) dfs2(y,val+f[x]-f[y]*prime[siz[y]]);
	return ;
}
int now=n,rt1=51,rt2=51;
void GetRoot(int x)
{
	int Maxn=0;
	for(auto y:vec[x])
    {
		GetRoot(y);
		Maxn=max(Maxn,siz[y]);
	}
	Maxn=max(Maxn,n-siz[x]);
	if(Maxn<now) now=Maxn,rt1=x,rt2=51;
	else if(Maxn==now) rt2=x;
	return ;
}
PII v[N];
int main()
{
	read(m);Primes(1000);
	for(register int i=1;i<=m;++i)
    {
		read(n);
		for(register int i=1;i<=n;i++) vec[i].clear();
		for(register int i=1,x;i<=n;i++){read(x),vec[x].push_back(i);if(x==0) rt=i;}
		dfs1(rt);dfs2(rt,0);
		rt1=rt2=51,now=n;
		GetRoot(rt);
		v[i]=mp(g[rt1],g[rt2]);
	}
	for(register int i=1;i<=m;++i)
    {
		for(register int j=1;j<=m;++j)
        {
			if(v[i].se&&v[j].se){if(v[i].fi==v[j].fi||v[i].fi==v[j].se||v[i].se==v[j].fi||v[i].se==v[j].se){Ans[i]=j;break;}}
			else if(v[i].se){if(v[i].fi==v[j].fi||v[i].se==v[j].fi){Ans[i]=j;break;}}
			else if(v[j].se){if(v[i].fi==v[j].fi||v[i].fi==v[j].se){Ans[i]=j;break;}}
			else{if(v[i].fi==v[j].fi){Ans[i]=j;break;}}
		}
		write(Ans[i]),putchar('\n');
	}
	
	return 0;
}
```

---

## 作者：longlongzhu123 (赞：3)

发一波题解~~~

楼上 @hyfhaha （%%%神仙）的代码已经写的很明白了，不过他好像没有讲清楚哈希中的具体做法和一些细节处理，我在这里补充一下OvO。

---------------

# 解法：树上哈希

这道题可以对于树上的每个点记录整棵子树的**哈希值**。

## 计算哈希值

首先，叶子节点的哈希值为1（不能为0，如果为0就与空结点无法区分了）。

如果该节点没有儿子，哈希值返回1。

```cpp
if(lis[u].size() == 1 && father != 0)  //  这是叶子的标志哦
    return 1;
```

对于非空结点，先求出其所有子树的哈希值，然后排序，把这些值当成字符串的字符处理就行啦！

具体就是：将子树的哈希值存入 `buffer` 中，并排序。

```cpp
sort(buffer.begin(), buffer.end());
for(int i = 0; i < buffer.size(); i ++) {
    res = (res * SEED + buffer[i]) % MOD;
}
```

可以看到，`for` 的部分基本和字符串哈希一样QwQ。

## 判断是否同构

如果两棵树同构，这两棵树中每一个结点的哈希值一定是相同的。

（不要直接判断根，因为碰撞概率较大）

```cpp
for(int j = 1; j <= i; j ++) {
    bool flag = true;
    for(int k = 1; k <= m; k ++) {
        if(tree_hash[j][k] != tree_hash[i][k]) {
            flag = false;
            break;
        }
    }
    if(flag){
        cout<<j<<endl;
        break;
    }
}
```

# 完整代码

```cpp#include<string>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<vector>
using namespace std;
typedef long long LL;
const LL MAXN  = 50 + 10;
const LL SEED  = 10007;
const LL MOD   = 19260817;  //  ...
struct Graph {
    vector<int> lis[MAXN];
    void add(int u, int v) {
        lis[u].push_back(v);
        lis[v].push_back(u);
    }
    LL hash(int u, int father) {
        if(lis[u].size() == 1 && father != 0)
            return 1;
        else {
            vector<LL> buffer;
            LL res = 1;
            for(int i = 0; i < lis[u].size(); i ++) {
                int v = lis[u][i];
                if(v == father)
                    continue;
                buffer.push_back(hash(v, u));
            }
            sort(buffer.begin(), buffer.end());
            for(int i = 0; i < buffer.size(); i ++) {
                res = (res * SEED + buffer[i]) % MOD;
            }
            return res;
        }
    }
}tree[MAXN];
LL tree_hash[MAXN][MAXN];
int n, m, father;
int main() {
    cin>>n;
    for(int i = 1; i <= n; i ++) {
        cin>>m;
        Graph& T = tree[i];
        for(int j = 1; j <= m; j ++) {
            cin>>father;
            if(father == 0)
                continue;
            T.add(father, j);
        }
        for(int j = 1; j <= m; j ++) {
            LL h = T.hash(j, 0);
            tree_hash[i][j] = h;
        }
        sort(tree_hash[i] + 1, tree_hash[i] + m + 1);
        for(int j = 1; j <= i; j ++) {
            bool flag = true;
            for(int k = 1; k <= m; k ++) {
                if(tree_hash[j][k] != tree_hash[i][k]) {
                    flag = false;
                    break;
                }
            }
            if(flag){
                cout<<j<<endl;
                break;
            }
        }
    }
    return 0;
}
```

---

## 作者：rEdWhitE_uMbrElla (赞：3)

说是树同构的模板，不如说是树上哈希的模板。。。

### 思路：

这题就是使用树上哈希来纪录结构，之后和其他树进行比对就行了。经过一段时间的考察，发现这题并不卡自然溢出，那就用自然溢出吧。。还比单模数或双模数要快且好写。。

### 具体步骤：

1. 建树
	
    链式前向星就不讲了。。见代码
    
  ```cpp
  void add_edge(int x,int y) {
      last[++tot]=y;
      nxt[tot]=head[x];
      head[x]=tot;
  }
  ```

2. 树上哈希
	
    强制让1号节点做根，dfs序存储结构，哈希便是正常的自然溢出哈希，这里甚至不需要用unsigned，因为只需要哈希值，不需要以哈希值为下标，见代码
    
  ```cpp
  long long tree_hash(int x,int f) {
      unsigned long long q[maxn],res=base,top=0;
      for(int i=head[x]; i; i=nxt[i])
          if(last[i]!=f)
              q[++top]=tree_hash(last[i],x);
      sort(q+1,q+top+1);
      for(int i=1; i<=top; i++) res=res*guguval+q[i];
      return res*guguval+maxn+1;
  }
  ```

3. 比对

	用一个数组存下每个树的子树（包括整个树）的哈希值，然后一一比对即可，见代码
    
  ```cpp
  int query(int treeindex,int treesize){
      for(int j=1; j<=treesize; j++) ans[treeindex][j]=tree_hash(j,0);
      sort(ans[treeindex]+1,ans[treeindex]+treesize+1);
      for(int j=1,k; j<=treeindex; j++) {
          for(k=0;k<=treesize;++k) if(ans[treeindex][++k]!=ans[j][k]) break;
          if(k>treesize) return j;
      }
  }
  ```
  
### std：

```cpp
#include<bits/stdc++.h>
using namespace std;

constexpr long long maxn=1001,guguval=99983;
long long base;

class hash_table{
private:
	long long ans[maxn][maxn],head[maxn],last[maxn],nxt[maxn],tot;
	long long tree_hash(int x,int f) {
		unsigned long long q[maxn],res=base,top=0;
		for(int i=head[x]; i; i=nxt[i])
			if(last[i]!=f)
				q[++top]=tree_hash(last[i],x);
		sort(q+1,q+top+1);
		for(int i=1; i<=top; i++) res=res*guguval+q[i];
		return res*guguval+maxn+1;
	}
public:
	void init(){
		tot=0;
		memset(head,0,sizeof(head));
	}
	void add_edge(int x,int y) {
		last[++tot]=y;
		nxt[tot]=head[x];
		head[x]=tot;
	}
	int query(int treeindex,int treesize){
		for(int j=1; j<=treesize; j++) ans[treeindex][j]=tree_hash(j,0);
		sort(ans[treeindex]+1,ans[treeindex]+treesize+1);
		for(int j=1,k; j<=treeindex; j++) {
			for(k=0;k<=treesize;++k) if(ans[treeindex][++k]!=ans[j][k]) break;
			if(k>treesize) return j;
		}
	}
}table;

long long n,m;

int main() {
	srand(20050829);
	base=(int)rand()+1000;
	scanf("%lld",&m);
	for(int i=1; i<=m; i++) {
		cin>>n,table.init();
		long long x;
		for(int j=1; j<=n; j++) {
			scanf("%lld",&x);
			if(x!=0) table.add_edge(x,j),table.add_edge(j,x);
		}
		printf("%d\n",table.query(i,n));
	}
	return 0;
}
```

---

## 作者：高天 (赞：2)

## 思路：

从树的重心开始hash因为重心最多两个。

然后找到树的最小表示就好了。

对于两颗待判定的树,将两颗树分别以树上每一个节点为根节点求hash值……

将根节点的hash值储存起来排序然后两颗树一一比对。

如果完全一样则两棵树就一样。


------------

## 代码：
```cpp
#include<bits/stdc++.h>//万能脑袋 
using namespace std;
const int maxn = 505;
int f[maxn],son[maxn],n,mx;
vector<int>E[maxn];
string h[maxn],h2[maxn],ha[maxn];
void root(int x,int fa) {//重心 
	son[x]=1,f[x]=0;
	for(int i=0; i<E[x].size(); i++) {
		int p=E[x][i];
		if(p==fa)continue;
		root(p,x);
		son[x]+=son[p];
		f[x]=max(f[x],son[p]);
	}
	f[x]=max(f[x],n-son[x]);
	mx=max(f[x],mx);
}
void insert() {
	for(int i=1; i<=n; i++)E[i].clear();
	mx=0;
	memset(f,0,sizeof(f));
	memset(son,0,sizeof(son));
}
void dfs(int x,int fa) {//括号序列的确定 
	h[x]="(";
	for(int i=0; i<E[x].size(); i++) {
		int v = E[x][i];
		if(v!=fa)dfs(v,x);
	}
	int now=0;
	for(int i=0; i<E[x].size(); i++) {
		int v = E[x][i];
		if(v!=fa)
			h2[now++]=h[v];
	}
	sort(h2,h2+now);
	for(int i=0; i<now; i++)
		h[x]+=h2[i];
	h[x]+=")";
}
string get() {
	scanf("%d",&n);
	insert();
	for(int i=1; i<=n; i++) {//读入并连边 
		int x;
		scanf("%d",&x);
		if(x) {
			E[x].push_back(i);
			E[i].push_back(x);
		}
	}
	root(1,0);
	string tmp = "";
	for(int i=1; i<=n; i++) {//确定重心 
		if(f[i]==mx) {
			dfs(i,0);
			if(h[i]>tmp)tmp=h[i];
		}
	}
	return tmp;
}
int main() {
	int chess;
	scanf("%d",&chess);
	for(int i=1; i<=chess; i++)
		ha[i]=get();
	for(int i=1; i<=chess; i++) {//确定标号 
		for(int j=1; j<=i; j++) {
			if(ha[i]==ha[j]) {
				cout<<j<<endl;
				break;
			}
		}
	}
}
```

再见！

---

## 作者：ottora (赞：2)

### 前言

这道题的很多题解（包括 [OI Wiki](https://oi-wiki.org/graph/tree-hash/)）都介绍了 $O\left(n^2m\right)$ 的方法，或是用更加复杂的方法实现 $O\left(nm\log n\right)$ 甚至 $O\left(nm\right)$，不过常数略大。这里我将介绍一种小常数 $O\left(nm\right)$ 的方法。

### 正文

对于一棵无根树，一般的暴力哈希是将无根树转化成有根树，再由叶节点到根结点进行哈希，哈希值只在相邻节点之间更新。这样的到的哈希值很明显受根结点影响，所以需要以每个节点为根各自哈希一次。

但是我们发现拓扑排序在树的形态不变的情况下，相邻两点的遍历顺序不变。所以我们可以在拓扑的同时更新下一节点的哈希值，这样同构的树得到的哈希值肯定是一样的。此时只需要一次哈希，总体的时间复杂度为 $O\left(nm\right)$。

注意最后拓扑的两个节点之间可能会互相影响时，不更新哈希值即可。

### 代码

```cpp
#include<bits/stdc++.h>
typedef unsigned int u32;
using namespace std;
const int maxe=105;
const int maxn= 55;
const u32 P[2]={1000000007u,1000000009u};
const u32 X[2]={1145141919u,2333233233u};
int N,M,K,tot,lnk[maxn],nxt[maxe],son[maxe];
int Siz[maxn],Du[maxn],Dis[maxn];
void add_e(int x,int y){
	Du[son[++tot]=y]++,nxt[tot]=lnk[x],lnk[x]=tot;
}
map<pair<pair<int,int>,int>,int>Map;
u32 Hsh[maxn][2];
auto Topo(){
	queue<int>Q;int cnt=N-1;
	auto res=make_pair(0u,0u);
	for(int i=1;i<=N;i++){
		if(!Du[i]) Q.push(i);
		Hsh[i][0]=X[0];
		Hsh[i][1]=X[1];
	}
	while(!Q.empty()){
		int id=Q.front();
		Du[id]=-1,Q.pop(),--cnt;
		res.first +=Hsh[id][0]+=++Siz[id];
		res.second+=Hsh[id][1]+=  Siz[id];
		for(int j=lnk[id];j;j=nxt[j]) if(Du[son[j]]>=0){
			if(!cnt&&Dis[id]==Dis[son[j]])continue;
			Dis[son[j]]=max(Dis[son[j]],Dis[id]+1);
			Hsh[son[j]][0]*=(Hsh[id][0]+X[0])%P[0];
			Hsh[son[j]][1]*=(Hsh[id][1]+X[1])%P[1];
			if(!--Du[son[j]]) Q.push(son[j]);
			Siz[son[j]]+=Siz[id];
		}
	}
	return make_pair(res,N);
}
int read(){
	int f=1,ret=0;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-f; ch=getchar();}
	while( isdigit(ch)) ret=(ret<<3)+(ret<<1)+(ch&15),ch=getchar();
	return f*ret;
}
int main(){
	M=read();
	for(int t=1;t<=M;t++){
		N=read(),tot=0;
		memset(lnk,0x00,sizeof lnk);
		memset(nxt,0x00,sizeof nxt);
		memset(Siz,0x00,sizeof Siz);
		memset(Hsh,0x00,sizeof Hsh);
		memset(Dis,0x00,sizeof Dis);
		memset(Du ,0xFF,sizeof Du );
		for(int i=1;i<=N;i++) if(int x=read()) add_e(i,x),add_e(x,i);
		auto hash=Topo();if(!Map[hash]) Map[hash]=t;
		printf("%d\n",Map[hash]);
	}
	return 0;
}
```

---

## 作者：zjc5 (赞：1)

[题目链接](https://www.luogu.com.cn/problem/P5043)

~~这题似乎没有紫题的难度。~~

**思路：**

样例中编号为 $1,2$ 的树同构。

可以对比一下。

对于样例中编号为 $1$ 的树：

以 $1$ 为根时到 $2,3,4$ 号节点的距离分别是 $1,1,2$；

以 $2$ 为根时到 $1,3,4$ 号节点的距离分别是 $1,2,1$；

以 $3$ 为根时到 $1,2,4$ 号节点的距离分别是 $1,2,3$；

以 $4$ 为根时到 $1,2,3$ 号节点的距离分别是 $2,1,3$。

对于样例中编号为 $2$ 的树：

以 $1$ 为根时到 $2,3,4$ 号节点的距离分别是 $1,2,3$，和编号为 $1$ 的树中的 $3$ 号节点一样；

以 $2$ 为根时到 $1,3,4$ 号节点的距离分别是 $1,1,2$，和编号为 $1$ 的树中的 $1$ 号节点一样；

以 $3$ 为根时到 $1,2,4$ 号节点的距离分别是 $2,1,1$，和编号为 $1$ 的树中的 $2$ 号节点一样；

以 $4$ 为根时到 $1,2,3$ 号节点的距离分别是 $3,2,1$，和编号为 $1$ 的树中的 $4$ 号节点一样。

可以发现编号为 $2$ 的树中，以任意一个编号的点为根，都可以在编号为 $1$ 的树中找到一个一样的节点。

那么就可以用哈希储存值，再开一个数组储存同构的树的最小编号。

代码时间复杂度 $O(n^2m)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int>v[60];
int m,n,x,a[60],num[60],ans,sum,bs=71,mod=1001;
int mp[1010];
void hh(int now,int fa,int step){
	sum=sum*step%mod;
	for(int i=0;i<v[now].size();i++){
		int t=v[now][i];
		if(t!=fa) hh(t,now,step+1);
	}
}
int main(){
	cin>>m;
	for(int i=1;i<=m;i++){
		cin>>n;
		for(int i=1;i<=n;i++)
			v[i].clear();
		for(int j=1;j<=n;j++){
			cin>>x;
			if(x>0){
				v[j].push_back(x);
				v[x].push_back(j);
			}
		}
		for(int j=1;j<=n;j++){
			sum=1;
			hh(j,0,1);
			num[j]=sum;
		}
		sort(num+1,num+n+1);
		ans=0;
		for(int j=1;j<=n;j++)
			ans=(ans*bs%mod+num[j])%mod;
		if(!mp[ans]) mp[ans]=i;
		cout<<mp[ans]<<"\n";
	}
	return 0;
}
```

代码只有 $39$ 行！！

---

## 作者：XL4453 (赞：1)

### 解题思路：

这里采用速度较快且准确性较高的重心双哈希。

---

对于只需要求出无根树值的情况，直接进行哈希并不优秀，直接暴力做复杂度相对较高，而换根又会导致代码变得更为复杂。这时候就希望在树中找一个较为确定的点作为树的根，转化为更为简单的有根树哈希，此处可以采用树的重心。

树的重心是将这个点删除之后剩下森林中最大联通块最小的一个位置。树的重心有一个或者两个，且对于任意两颗同构无根树，其重心的位置相同却确定。

---
在确定了根节点之后就可以进行哈希了。

笔者采用了双哈希，两个哈希式子分别是 $f_i=size_i\sum f_{son_i}+size_i^2$ 以及 $g_i=size_i\sum f_{son_i}^2+1$。

对于两个重心的情况，可以让两个都作为根节点跑一次取 $f$ 较小的一个作为最终使用的哈希值。

最后使用 $\text{map}$ 判断就行了。

---
注意数组要清空。

---
### 代码：

```cpp
#include<algorithm>
#include<cstdio>
#include<map>
using namespace std;
#define int long long
const int MAXN=100005,MOD=1000000007;
int m,n,x,head[MAXN],num[MAXN],nxt[MAXN],tot,size_[MAXN],f1[MAXN],f2[MAXN],h[MAXN],ans_cnt,ans_pos1,ans_pos2;
map <pair<int,int> ,int> mp;
void init(){
	for(int i=1;i<=2*n;i++)
	head[i]=nxt[i]=num[i]=size_[i]=f1[i]=f2[i]=h[i]=0;
	tot=0;
}
void add(int x,int y){
	nxt[++tot]=head[x];
	head[x]=tot;
	num[tot]=y;
}
void dfs1(int now,int fa){
	size_[now]=1;
	for(int i=head[now];i;i=nxt[i]){
		if(num[i]==fa)continue;
		dfs1(num[i],now);
		size_[now]+=size_[num[i]];
		h[now]=max(h[now],size_[num[i]]);
	}
	h[now]=max(h[now],n-size_[now]);
}
void dfs2(int now,int fa){
	size_[now]=1;
	f1[now]=f2[now]=0;
	for(int i=head[now];i;i=nxt[i]){
		if(num[i]==fa)continue;
		dfs2(num[i],now);
		size_[now]+=size_[num[i]];
		f1[now]=(f1[now]+f1[num[i]])%MOD;
		f2[now]=(f2[now]+f2[num[i]]*f2[num[i]]%MOD)%MOD;
	}
	f1[now]=(f1[now]*size_[now]%MOD+size_[now]*size_[now]%MOD)%MOD;
	f2[now]=(size_[now]*f2[now]+1)%MOD;
}
signed main(){
	scanf("%lld",&m);
	for(int loop=1;loop<=m;loop++){
		init();
		scanf("%lld",&n);
		for(int i=1;i<=n;i++){
			scanf("%lld",&x);
			if(x!=0)add(x,i),add(i,x);
		}
		dfs1(1,0);
		ans_cnt=1000000000;
		ans_pos1=ans_pos2=-1;
		for(int i=1;i<=n;i++){
			if(h[i]==ans_cnt){
				ans_pos2=i;
			}
			if(h[i]<ans_cnt){
				ans_cnt=h[i];
				ans_pos1=i;
				ans_pos2=-1;
			}
		}
		if(ans_pos2==-1){
			dfs2(ans_pos1,0);
			if(mp[make_pair(f1[ans_pos1],f2[ans_pos1])]==0)
			mp[make_pair(f1[ans_pos1],f2[ans_pos1])]=loop;
			printf("%lld\n",mp[make_pair(f1[ans_pos1],f2[ans_pos1])]);
		}
		else{
			dfs2(ans_pos2,0);
			int p1=f1[ans_pos2],p2=f2[ans_pos2];
			dfs2(ans_pos1,0);
			if(p1>f1[ans_pos1]){
				if(mp[make_pair(p1,p2)]==0)
				mp[make_pair(p1,p2)]=loop;
				printf("%lld\n",mp[make_pair(p1,p2)]);
			}
			else{
				if(mp[make_pair(f1[ans_pos1],f2[ans_pos1])]==0)
				mp[make_pair(f1[ans_pos1],f2[ans_pos1])]=loop;
				printf("%lld\n",mp[make_pair(f1[ans_pos1],f2[ans_pos1])]);
			}
		}
	}
	return 0;
}
```


---

## 作者：artofproblemsolving (赞：1)

直接进入正题：

当我们想判断某两张图是否同构时，或者某两棵有根树是否相同时，我们就需要一个可行的比较手段，这是我们就又想到了**哈希**！

而这道题不就正好完全符合吗！

题目分析：可以注意到，对于一棵无根树，它的重心个数不超过 2。

   枚举每个重心，以重心为根求出这棵有根树的最小表示，然后取字典序最大的即可。
   
   对于有根树的最小表示，可以看成括号序列，每次把子树的括号序列按字典序排序后依次串联起来即可。
   
代码如下：
```
#include <bits/stdc++.h>
using namespace std;
const int maxn=55;
int T,n,g[maxn],v[maxn<<1],nxt[maxn<<1],ed,f[maxn],son[maxn],mx;
string h[maxn],q[maxn],val[maxn];
inline void link(int x,int y){v[++ed]=y;nxt[ed]=g[x];g[x]=ed;}
void findroot(int x,int y){ //寻找重心
  son[x]=1;
  f[x]=0;
  for(int i=g[x];i;i=nxt[i])
    if(v[i]!=y){
      findroot(v[i],x);
      son[x]+=son[v[i]];
      if(son[v[i]]>f[x])
        f[x]=son[v[i]];
    }
  if(n-son[x]>f[x]) f[x]=n-son[x];
  if(f[x]<mx) mx=f[x];
}
void dfs(int x,int y){ //括号序列的确定
  h[x]='(';
  for(int i=g[x];i;i=nxt[i])
    if(v[i]!=y)
      dfs(v[i],x);
  int t=0;
  for(int i=g[x];i;i=nxt[i])
    if(v[i]!=y)
      q[t++]=h[v[i]];
  sort(q,q+t);
  for(int i=0;i<t;i++)
    h[x]+=q[i];
  h[x]+=")";
}
string solve(){
  string t="";
  cin>>n;
  ed=0;mx=n;
  fill(g+1,g+n+1,0);
  for(int i=1,x;i<=n;i++){ //读入并连边
    cin>>x;
    if(x) link(i,x),link(x,i);
  }
  findroot(1,0); //确定重心
  for(int i=1;i<=n;i++)
    if(f[i]==mx){
      dfs(i,0); //以i为根进行dfs
        t=h[i];
    }
  return t;
}
int main(){
  cin>>T;
  for(int i=1;i<=T;i++)
    val[i]=solve();
  for(int i=1,who;i<=T;i++){ //确定编号
    for(int j=i;j;j--)
      if(val[j]==val[i]) who=j;
    cout<<who<<endl;
  }
  return 0;
}
```

---

## 作者：ningago (赞：0)

### 爆搜

枚举两棵树，dfs 枚举全排列，重新标号，判断数列两个父亲序列是否全部相等即可。

复杂度 $O(n^3 \cdot n!)$，快得跟爬一样。

### 有根树

有根树的同构就是在这题的基础上，不将根重新标号的情况。

使用哈希表的思想，给每棵树用尽可能玄学的公式算出一个哈希值。枚举后比较两棵树哈希值是否相等即可。

复杂度 $O(m^2n)$。

（下文哈希值全部自然溢出）。

然而，公式是不能随便选的，比如你选：

$$f_k=((\bigoplus_{nx\in Son_k}f_{nx}) * 114514+1919)\oplus 1919810$$

提交这题就会获得 $50$ 分的好成绩。

```cpp
unsigned long long dfs(int k,int fa)
{
	f[k] = 0;
	for(int i = h[k];~i;i = ne[i])
	{
		int nx = e[i];
		if(nx == fa)
			continue;
		f[k] ^= dfs(nx,k);
	}
	f[k] = (f[k] * 114514 + 1919) ^ 1919810;
	return f[k];
}
```
（整棵树的哈希值就是 `f[root]`）。

原因很显然，不同的树结构获得了同样的哈希值。

有没有更加聪明的公式呢？聪明的前辈们发明了这个公式：

$$f_k=1+\sum_{nx\in Son_k}f_{nx}\times prime(sz_{nx})$$

（也就是`oi-wiki`的“方法三”。）

```cpp
unsigned long long prime[N] = {0,2  ,3  ,5  ,7  ,11 ,13 ,17 ,19 ,23 ,29 ,31 ,37 ,41 ,43 ,47 ,53 ,59 ,61 ,67 ,71 , 73 ,79 ,83 ,89 ,97 ,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229};

unsigned long long dfs(int k,int fa)
{
	f[k] = 1;
	sz[k] = 1;
	for(int i = h[k];~i;i = ne[i])
	{
		int nx = e[i];
		if(nx == fa)
			continue;
		f[k] += dfs(nx,k) * prime[sz[nx]];
		sz[k] += sz[nx];
	}
	return f[k];
}
```

### 无根树

暴力枚举根，求出并存下每个点作为根的哈希值。

如果两棵树上有某个哈希值相同，就认为两颗树就是同构的。

复杂度 $O(m^2n^2)$。

~~虽然复杂度高，但使用这个方法可以检测你的哈希方法的冲突率。~~

~~毕竟是面向数据范围程序设计竞赛。~~

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>

#define N 55

unsigned long long prime[N] = {0,2  ,3  ,5  ,7  ,11 ,13 ,17 ,19 ,23 ,29 , 31 ,37 ,41 ,43 ,47 ,53 ,59 ,61 ,67 ,71 ,73 ,79 ,83 ,89 ,97 ,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229};

int n,m;
int num[N];
unsigned long long res[N][N];

int h[N],e[N << 1],ne[N << 1],idx;
void add_edge(int x,int y)
{
	ne[++idx] = h[x];
	h[x] = idx;
	e[idx] = y;
}

void add(int x,int y)
{
	add_edge(x,y);
	add_edge(y,x);
}

unsigned long long f[N],sz[N];

unsigned long long dfs(int k,int fa)
{
	f[k] = 1;
	sz[k] = 1;
	for(int i = h[k];~i;i = ne[i])
	{
		int nx = e[i];
		if(nx == fa)
			continue;
		f[k] += dfs(nx,k) * prime[sz[nx]];
		sz[k] += sz[nx];
	}
	return f[k];
}

int ans[N];

int main()
{
	memset(h,-1,sizeof(h));
	scanf("%d",&m);
	for(int i = 1;i <= m;i++)
	{
		ans[i] = i;
		scanf("%d",&n);
		num[i] = n;
		for(int j = 1,f;j <= n;j++)
		{
			scanf("%d",&f);
			if(f)
				add(f,j);
		}
		for(int j = 1;j <= n;j++)
			res[i][j] = dfs(j,0);
		for(int j = 1;j <= n;j++)
			h[j] = -1;
		for(int j = 1;j <= idx;j++)
			e[j] = ne[j] = 0;
		idx = 0;
	}
	for(int i = 1;i <= m;i++)
	{
		for(int j = 1;j <= m;j++)
		{
			if(num[i] != num[j])
				continue;
			for(int p = 1;p <= num[i];p++)
			{
				for(int q = 1;q <= num[j];q++)
				{
					if(res[i][p] == res[j][q])
					{
						ans[j] = std::min(ans[j],i);
						ans[i] = std::min(ans[i],j);
					}
				}
			}
		}
	}
	for(int i = 1;i <= m;i++)
		printf("%d\n",ans[i]);
	return 0;
}
```

---


# [MtOI2018] 刷题？作业狂魔！

## 题目背景

在临听到暑假的尾声以后，神奇的 cz 终于发觉自己的作业不能完成了。

在他写完作业之前，你需要将他做作业的顺序告诉给他听，这样你们就可以一起玩了。  



## 题目描述

你拥有 $T$ 分钟的时间。

做作业的顺序可以根据重要度 $v_i$ 来排序，但可能这不是最佳方案。且每项作业可能不止有一项，所以每项作业还有一个数量 $c_i$，每项 $t_i$ 分钟可以完成。

而在做某作业之前可能要先写完某个作业，所以还给出 $M$ 个关系，每个关系包含两个数 $a$，$b$ ，代表 $a$ 是 $b$ 完成的前提，不存在 $a=b$ 的情况。

关系不排除环的情况，cz 不想重做一遍作业，只好不做在环上的作业。

当某作业做到一半但时间结束，则失去该作业重要度；当该作业只做了 $k$ 个，但 $k\leq c_i$ ,则得到 $k\times v_i$ 重要度 , 如果该作业没把 $c_i$ 个做完，则不得做其他作业。

可存在 $b$ 有多个 $a$，但请注意一个作业的 **一个** 前提被做了以后，该作业就可以被做了。但cz非常专注，他写完一个作业以后就必须写**以该作业为前提的**作业。

## 说明/提示

### 子任务

对于 $100\%$ 的数据，$1<=N<=10000,1<=M<=100000$

其他值均在$long long$范围内。


### 题目来源

[MtOI2018 迷途の家の水题大赛](https://www.luogu.org/contest/11260) T1

出题人：Doubleen

56432

## 样例 #1

### 输入

```
4 7
2 1 1
2 1 2
2 1 3
2 1 4
3
3 4
2 3
1 2```

### 输出

```
6```

# 题解

## 作者：Doubleen (赞：21)

首先，这是一道图论题，$n=10000$就是暴力dfs求解。但是有一个环的限制，因此先用tarjan把环的作业去除，再dfs就可以了

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
typedef long long ll;
const ll M=10005;
ll v[M],c[M],t[M];
struct node{
	ll to,next;
}edge[M*11];
ll head[M],cnt;
bool vis[M],can[M];
ll dfn[M],low[M],sta[M],in[M],color[M];
ll top,sum,tot,ans;
inline void add(ll x,ll y){edge[++cnt]=(node){y,head[x]},head[x]=cnt;}
inline ll read()
{
    ll x=0,f=1; char ch=0;
    while(!isdigit(ch)) f=(ch=='-'?-1:1),ch=getchar();
    while(isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return x*f;
}
void tarjan(ll x)
{
	dfn[x]=low[x]=++tot;
	sta[++top]=x; vis[x]=true;
	for(register ll i=head[x];i;i=edge[i].next)
	{
		ll u=edge[i].to;
		if(!dfn[u]){
			tarjan(u);
			low[x]=min(low[x],low[u]);
		}
		else if(vis[u]){
			low[x]=min(low[x],dfn[u]);
		}
	}
	if(dfn[x]==low[x]){
		ll jsq=1;
		color[x]=++sum; vis[x]=false;
		while(sta[top]!=x){
			jsq++;
			color[sta[top]]=sum;
			vis[sta[top--]]=false;
		}
		if(jsq>1) can[sum]=true;
		top--;
	}
}
void dfs(ll x,ll s,ll la)
{
	ans=max(ans,s);
	for(register ll i=head[x];i;i=edge[i].next)
	{
		ll u=edge[i].to;
		if(can[color[u]]) continue;
		if(la>=c[u]*t[u]) dfs(u,s+c[u]*v[u],la-c[u]*t[u]);
		else ans=max(ans,s+(la/t[u])*v[u]);
	}
}
int main()
{
	ll n=read(),T=read();
	for(register ll i=1;i<=n;i++){
		v[i]=read(); c[i]=read(); t[i]=read();
	}
	ll m=read();
	for(register ll i=1;i<=m;i++){
		ll x=read(),y=read();
		add(x,y); in[y]++;
	}
	for(register ll i=1;i<=n;i++){
		if(!dfn[i]) tarjan(i);
	}
	for(register ll i=1;i<=n;i++){
		if(in[i]||can[color[i]]) continue;
		if(T>=c[i]*t[i]) dfs(i,c[i]*v[i],T-c[i]*t[i]);
		else ans=max(ans,(T/t[i])*v[i]);
	}
	printf("%lld\n",ans);
	return 0;
}
```
**那个别忘了吸氧哦QAQ，讲的太差请见谅**

---

## 作者：DJN123 (赞：3)

~~就 AC 了？这么水吗？~~  
# dfs 纯度爆表的一题  
题意简述：有 $n$ 个点，通过第 $i$ 个点得到的价值（或是路费）为 $v_i \times c_i$ ，耗费 $t_i \times c_i$ 的时间，再给出 $m$ 条单向边，只能从入读为零的点开始。  
求：在 $T$ 时间内的最大价值。  
第一眼，最短路！但是，并不是最短路板子，因为我们发现他不能走环（不知道有没有人跟我一样看成没有环），于是，我们可以用 Tarjan 将环噶了，然后爆搜。  
# Code:  
注释就不写了，将就看吧。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int in(){
	int ans = 0, f = 1;
	char c = getchar();
	while(c < '0' || '9' < c){
		if(c == '-')f = -1;
		c = getchar();
	}
	do{
		ans = (ans << 1) + (ans << 3) + c - '0';
		c = getchar();
	}while('0' <= c && c <= '9');
	return ans * f;
}
void out(int x){
	if(x < 0){
		x = -x;
		putchar('-');
	}
	if(x >= 10)out(x / 10);
	putchar(x % 10 + '0');
}
struct node {
	int next, to;
}road[100005];
struct student{
	int t, w;
}f[100005];
int head[100005], cnt;
void add(int x, int y) {
	road[++cnt].next = head[x];
	road[cnt].to = y;
	head[x] = cnt;
}
bool yes[100005];
int maxx, n, T, v[100005], c[100005], t[100005], m, x, y, du[100005];
void dfs(int now, int time, int val) {
	if(time > T || yes[now])return;
	if(val == f[now].w && time > f[now].t)return;
	f[now].w = val;
	f[now].t = time;
	maxx = max(maxx, val + min(c[now], (T - time) / t[now]) * v[now]);
	for(int i = head[now];i;i = road[i].next){
		int r = road[i].to;
		dfs(r, time + c[now] * t[now], val + c[now] * v[now]);
	}
}
stack <int> q;
int df[100005], low[100005], sum;
bool vis[100005];
void tarjan(int now){
	df[now] = low[now] = ++sum;
	vis[now] = 1;
	q.push(now);
	for(int i = head[now];i;i = road[i].next){
		int r = road[i].to;
		if(!df[r])tarjan(r);
		if(vis[r]) low[now] = min(low[now], low[r]);
	}
	if(low[now] == df[now]){
		bool flag = 1;
		while(q.top() != now){
			flag = 0;
			yes[q.top()] = 1;
			vis[q.top()] = 0;
			q.pop();
		}
		if(!flag)yes[q.top()] = 1;
		vis[now] = 0;
		q.pop();
	}
}
signed main() {
	n = in(), T = in();
	for(int i = 1;i <= n;i++) {
		v[i] = in();
		c[i] = in();
		t[i] = in();
		f[i].t = 1e9;
	}
	m = in();
	for(int i = 1;i <= m;i++) {
		x = in(), y = in();
		add(x, y);
		du[y]++;
	}
	for(int i = 1;i <= n;i++)if(!df[i])tarjan(i);
	for(int i = 1;i <= n;i++)if(!du[i])dfs(i, 0, 0);
	out(maxx);
}
```

---

## 作者：Accepted3927 (赞：2)

## **题解：P5477 [MtOI2018] 刷题？作业狂魔！**
题目理解：不做环上作业，使价值最大。因此，首先我们就需要——**判环**！

 tarjan 判环已经有人讲过了，拓扑的那篇错了，那我就再来讲一下**拓扑**判环吧。（前置知识：**拓扑排序** ）

拓扑排序可以判断有向图中有无环，但**并不能直接把环“拎出来”**，某些点可能可以由环到达，但并不在环上。

那么该怎么办呢？不妨思考一个问题：**如果图是反的，会怎么样？**

 _**很显然，建反图跑两遍拓扑就可以成功判环！**_ 

接下来的 dfs 部分，很多人会直接暴力求解多条“作业链”，但这样时间会更**长**（~~虽然本题数据很水~~）。

于是我们可以把所有作业链的“**端点**”，也就是初始入度为0的点与0号点连一条有向边，并且使 $v_0=c_0=t_0=0$ ，然后从0号点开始遍历整个有向图。

最后的最后，提醒一句：

#### _**十年 OI 一场空，不开 long long 见祖宗！**_ 

## **AC Code：**

```cpp
#include<iostream>
#include<queue>
#include<vector>
using namespace std;
long long n,m,p;
long long v[10005],c[10005],t[10005];
long long rd[10005],cd[10005];
vector<int> e[10005];
vector<int> g[10005];//反图
bool f[10005]; 
long long ans=0;
inline void tpst(){
	queue<int> q;
	for(int i=1;i<=n;i++){
		if(rd[i]==0){
		q.push(i);e[0].push_back(i); 	
		}
		
	}
	while(!q.empty()){
		int tmp=q.front();
		q.pop();
		for(int i=0;i<e[tmp].size();i++){
			int vt=e[tmp][i];
			rd[vt]--;
			if(rd[vt]==0){
				q.push(vt);
			}
		}
	}
	bool k=0;
	for(int i=1;i<=n;i++){
		if(rd[i]>0) k=1;
		if(cd[i]==0) q.push(i);
	}
	if(k==0) return;
	while(!q.empty()){
		int tmp=q.front();
		q.pop();
		for(int i=0;i<g[tmp].size();i++){
			int vt=g[tmp][i];
			cd[vt]--;
			if(cd[vt]==0) q.push(vt);
		}
	}
	for(int i=1;i<=n;i++){
		if(cd[i]>0 && rd[i]>0){
			f[i]=1;
		}
	}
}
inline int read(){
	int x=0,f=0;
	char ch=0;
	while(!isdigit(ch)){
		f|=(ch=='-');
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x << 3)+(x << 1)+(ch ^ 48);
		ch=getchar();
	}
	return f?-x:x;
}
inline void dfs(int s,long long time,long long value){
	if(time+t[s]*c[s]>p){
		long long x=(p-time)/t[s];
		ans=max(ans,value+x*v[s]);
		return;
	}
	for(int i=0;i<e[s].size();i++){
		int vt=e[s][i];
		if(f[vt]==0) dfs(vt,time+t[s]*c[s],value+v[s]*c[s]);
	}
	ans=max(ans,value+c[s]*v[s]);
	return;
}
int main(){
    n=read();p=read();
    for(int i=1;i<=n;i++){
    	v[i]=read();
    	c[i]=read();
    	t[i]=read();
	}
	cin>>m;
	for(int i=1;i<=m;i++){
		int r,u;r=read();u=read();
		rd[u]++;
		e[r].push_back(u); 
		cd[r]++;
		g[u].push_back(r);
	}
	tpst();
	v[0]=t[0]=c[0]=0;
	dfs(0,0,0);
	printf("%d",ans);
    return 0;
}
```

---

## 作者：code_farmer2_2 (赞：1)

# 洛谷 P5477 刷题？作业狂魔！
## 前言
蒟蒻随机跳题跳过来的，写完后发现这题就一篇题解，于是向大家分享一下我的思路~

## 算法分析
### 深度优先搜索（dfs）
[前置知识：P2196](https://www.luogu.com.cn/problem/P2196) ~~（不会有人都做这题了还不会深搜吧）~~  
首先这个题给了我们一个有向带权图，但是带了**两个权**（价值和时间），因此记忆深搜不太好写。但是转眼一看数据范围，我们可以发现 $m$ 比较小，说明边少，图较为稀疏。对于稀疏图使用暴力深搜进行搜索，由于每个点产生的搜索分支较少，速度会远快于稠密图，因此这题我们可以先尝试暴力求解。

### 拓扑排序
[前置知识：P1347](https://www.luogu.com.cn/problem/P1347)  
然而，这个题还有一个条件，那便是带环的路不能走。可能是因为本蒟蒻知识量有限，第一时间想到的竟然是**拓扑排序**……但是发现居然意外地好用？众所周知，拓扑排序在遇到只剩环的情况时将因为无法找到入度为零的点而终止排序，而这时图中将只剩下环和必须通过环才能到达的点。我们只需要将这些点全部标记，在搜索到这个点时直接返回即可。这样只需要做一次拓扑排序就可以删除所有环，而且最坏情况下时间复杂度也仅有 $O(n+m)$，更不用说删除环之后搜索量极大幅度减少，非常的 nice~

## Code
**记得开 long long！**

```cpp
#include <iostream>
#include <queue>

using namespace std;

int m,n,head[10005],ru[10005],st[10005],stlen;
long long T,v[10005],c[10005],t[10005],rd[100005][2],ans,nv;
queue<int> q;

void dfs(int pos,long long nt)
{
	if(t[pos]==-1) return; //如果是被拓扑排序删除的环则返回
	if(nt<=c[pos]*t[pos])
	{
		ans = max(ans,nv+v[pos]*(nt/t[pos]));
		return;
	}
	nt -= t[pos]*c[pos];
	nv += c[pos]*v[pos];
	int t1 = head[pos];
	while(t1)
	{
		dfs(rd[t1][0],nt);
		t1 = rd[t1][1];
	}
	ans = max(ans,nv);
	nv -= c[pos]*v[pos]; //回溯
	return;
}

int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	
	cin >> n >> T;
	for(int i=1;i<=n;i++) cin >> v[i] >> c[i] >> t[i];
	cin >> m;
	int t1,t2;
	for(int i=1;i<=m;i++) //链式前向星存储路径并维护入度(当然也可以用邻接表)
	{
		cin >> t1 >> rd[i][0];
		rd[i][1] = head[t1];
		head[t1] = i;
		ru[rd[i][0]]++;
	}
	
	for(int i=1;i<=n;i++) //将初始入度为零的点标记为dfs和拓扑排序的起点
	{
		if(ru[i]==0)
		{
			q.push(i);
			st[++stlen] = i;
		}
	}
	while(!q.empty()) //进行拓扑排序
	{
		t1 = q.front();
		q.pop();
		t2 = head[t1];
		while(t2)
		{
			if(!(--ru[rd[t2][0]])) q.push(rd[t2][0]);
			t2 = rd[t2][1];
		}
	}
	for(int i=1;i<=n;i++) //删除所有环(当排序终止时入度大于零的点全部都是环或必须经过环才能到达的点)
	{
		if(ru[i]>0) t[i] = -1;
	}
	
	for(int i=1;i<=stlen;i++)
	{
		dfs(st[i],T);
	}
	cout << ans;
}
```

## 后记
以上代码在最大的 case 仅用时 5ms，快得都超出了我的预计……甚至还有优化空间（比如俩权的记忆化搜索啥的）……只能说拓扑排序是真的好用~

蒟蒻第一篇题解，有什么建议欢迎指出~

---


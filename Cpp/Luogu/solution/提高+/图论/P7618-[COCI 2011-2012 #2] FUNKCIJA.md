# [COCI 2011/2012 #2] FUNKCIJA

## 题目描述

Mirko 写了如下的函数：

（C++）

```cpp
int fun() {
    int ret = 0;
    for (int a = X1; a <= Y1; ++a)
         for (int b = X2; b <= Y2; ++b)
             ...
                 for (int <N-th> = XN; <N-th> <= YN; ++<N-th>)
                     ret = (ret + 1) % 1000000007;
    return ret;
}

```

（Pascal）

```pascal
function fun: longint;
var
  ret: longint;
  a, b, ... , y, z: longint;
begin
  ret := 0;
  for a := X1 to Y1 do
    for b := X2 to Y2 do
      ...
        for <N-th> := XN to YN do
          ret := (ret + 1) mod 1000000007;
  fun := ret;
end;
```

_<N-th>_ 表示第 $N$ 个小写字母。每个 $X_i$ 和 $Y_i$ 可能表示外层循环的变量名，也可能表示一个 $\le 10^5$ 的正整数。例如 $X_3$ 可以是 $a$，$b$，也可以是一个整数常量。$X_i$ 和 $Y_i$ 中至少有一个会是整数常量。

计算这个函数的返回值。

## 说明/提示

#### 【数据范围】

对于 $100\%$ 的数据，$1 \le N \le 26$。

#### 【说明】

本题分值按 COCI 原题设置，满分 $150$。

题目译自 **[COCI2011-2012](https://hsin.hr/coci/archive/2011_2012/) [CONTEST #2](https://hsin.hr/coci/archive/2011_2012/contest2_tasks.pdf)** ___T5 FUNKCIJA___。

## 样例 #1

### 输入

```
2
1 2
a 3```

### 输出

```
5```

## 样例 #2

### 输入

```
3
2 3
1 2
1 a```

### 输出

```
10```

## 样例 #3

### 输入

```
3
1 2
a 3
1 b```

### 输出

```
11```

# 题解

## 作者：by_chance (赞：6)

写在前面：这是今天的训练题，本蒟蒻发现这里居然没有题解，于是交一发~~水题解~~做点贡献。

------------

[Link](https://www.luogu.com.cn/problem/P7618)

题目描述：给定一个循环，求最内层执行次数。对 $1e9+7$ 取模。

看到这道题，第一反应肯定是懵逼的。不用慌，我们先来打一些暴力，也就是模拟循环：比如，用搜索的方式，枚举每个变量的每个取值，到达底层就更新答案。代码就不放了。

这个代码可以让我们想到一样东西：树。没错，这道题就是树形DP。~~（貌似有些牵强？不管了）~~

注意到题目里还有一个条件：$X_i$ 和 $Y_i$ 中至少有一个是数字。翻译一下，就是第 $i$ 个变量的取值范围只由**不超过一个**变量决定。这个变量就可以成为第 $i$ 个变量的父亲。

如果想到这里，恭喜你，已经解决了一半。接下来的问题就是如何统计答案。我们拿一个数据手玩一下：

```
5
2 4
1 a
a 5
2 b
b 4
```
建立其对应的树：

![](https://cdn.luogu.com.cn/upload/image_hosting/hd0ogglp.png)

注意到，当 $a$ 取某一值时，其所有子树的循环次数的乘积，就是 $a$ 取这个值时的循环次数。那么，只需要将 $a$ 取所有值时子树乘积求和。对于每一个节点，递归进行这个操作即可。

代码实现时，用 $sum[i][j]$ 表示第 $i$ 个变量取值为 $j$ 时的循环次数，就有 $sum[i][j]=\Sigma sum[p][q]$，$p$ 是 $i$ 的一个子节点，$q$ 取遍循环范围。这显然是一个区间和，可以用前缀和优化。

另外，需要注意的是要特判循环不进行的情况。在代码中标出了。

AC代码：（码风较丑，不喜轻喷）
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll mod=1000000007,M=100005;
ll n,ans,fa[30],a[30],b[30],s[30][M],sum[30][M];
string x,y;
vector<int> son[30];
int read(string s){
	int x=0;
	for(int i=0;i<s.size();i++)x=(x<<1)+(x<<3)+s[i]-'0';
	return x;
}
bool check(string s){return islower(s[0]);}
void dfs(int x){
	int tmpa=a[x],tmpb=b[x];
	if(a[x]==-1)a[x]=a[fa[x]];
	if(b[x]==-1)b[x]=b[fa[x]];
	for(int j=a[x];j<=b[x];j++)sum[x][j]=1;
	for(int i=0;i<son[x].size();i++){
		int y=son[x][i];dfs(y);
		for(int j=a[x];j<=b[x];j++){
			if(a[y]==-1){
				if(b[y]>=j)sum[x][j]=(s[y][b[y]]-s[y][j-1]+mod)%mod*sum[x][j]%mod;
				else sum[x][j]=0;//特判
			}
			else{
				if(a[y]<=j)sum[x][j]=(s[y][j]-s[y][a[y]-1]+mod)%mod*sum[x][j]%mod;
				else sum[x][j]=0;//特判
			}
		}
	}
	for(int j=a[x];j<=b[x];j++)s[x][j]=(s[x][j-1]+sum[x][j])%mod;
	a[x]=tmpa;b[x]=tmpb;
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>x>>y;
		if(check(x)){
			fa[i]=x[0]-'a'+1;
			a[i]=-1;b[i]=read(y);
		}
		else if(check(y)){
			fa[i]=y[0]-'a'+1;
			a[i]=read(x);b[i]=-1; 
		}
		else{
			a[i]=read(x);
			b[i]=read(y);
		}//a[i],b[i]可以理解为变量i的值域
		if(fa[i]!=0)son[fa[i]].push_back(i);
	}
	sum[0][0]=1;
	for(int i=1;i<=n;i++){
		if(!fa[i]){
			dfs(i);
			sum[0][0]=sum[0][0]*s[i][b[i]]%mod;
		}
	}//sum[0][0]是记答案用的
	printf("%lld\n",sum[0][0]);
	return 0;
}
```

---

## 作者：TemplateClass (赞：4)

$\gdef \dp{\mathrm{dp}}$
$\gdef \son{\operatorname{son}}$
$\gdef \ssum{\operatorname{sum}}$

建图，对于两个有关联的循环（假设是第 $i$ 个和第 $j$ 个），我们连一条边 $(i, j)$；如果这个循环的上下界都是常数而非变量，朝结点 $0$ 连边。由于上下界最多只有一个变量，所以容易证明这是一个树。

然后我们开始 dp。设 $\dp _ {u, i}$ 表示第 $u$ 个循环的循环变量的值为 $i$ 时子树循环的次数，容易得到转移：

$$\dp _ {u, i} = \prod _ {v \in \son(u)} \sum _ {j = X _ v} ^ {Y _ v} \dp _ {v, j}$$

记 $V = 10 ^ 5$，直接按照这个式子转移是 $O(nV ^ 2)$ 的，时间复杂度显然承受不了，我们考虑用前缀和预处理后面那一坨和式，每次 $O(V)$ 地去维护即可，时间复杂度 $O(nV)$，然后就做完了。

```cpp
#include<iostream>
#include<vector>
#include<utility>
#include<cctype>

#define x first
#define y second

constexpr int N = 26 + 5;
constexpr int V = 1e5 + 5;
constexpr int MOD = 1000000007;
typedef std::pair<int, int> Range;

int n; Range r[N]; std::vector<int> G[N];
int sum[N][V]; bool calc_ed[N];

inline int gsum(int u, int l, int r) {
	return l > r ? 0 : (sum[u][r] - sum[u][l - 1] + MOD) % MOD;
}

int solve_dp(int u, int i) {
	int ret = 1;
	for(const auto& v : G[u]) {
		if(!calc_ed[v] && (calc_ed[v] = true)) {
			int pL = r[v].x ? r[v].x : 1, pR = r[v].y ? r[v].y : V - 1;
			for(int j = pL; j <= pR; ++j) {
				sum[v][j] = (1ull * sum[v][j - 1] + solve_dp(v, j)) % MOD; 
			}
		}
		int L = (r[v].x ? r[v].x : i), R = (r[v].y ? r[v].y : i);
		ret = (1ull * ret * gsum(v, L, R)) % MOD;
	}
	return ret;
}

int main(){
	std::ios::sync_with_stdio(false);
	std::cin.tie(0), std::cout.tie(0);
	
	std::cin >> n;
	for(int i = 1; i <= n; ++i) {
		std::string a, b; std::cin >> a >> b;
		bool ia = std::isalpha(a[0]), ib = std::isalpha(b[0]);
		r[i].x = ia ? 0 : std::stoi(a), r[i].y = ib ? 0 : std::stoi(b);
		int ati = a[0] - 'a' + 1, bti = b[0] - 'a' + 1;
		G[ia ? ati : ib ? bti : 0].push_back(i);
	}
	std::cout << solve_dp(0, 0) << "\n";
	
	return 0;
}
```

---

## 作者：mRXxy0o0 (赞：4)

# Problem
$n$ 个嵌套 ```for``` 循环，对每个循环变量给出上下界（数或至多一个外层的变量），求最内层的循环次数。
___
# Solution
通过日常代码经验，**交换两个毫无关联（没有直接或间接关联）的循环对整体次数没有影响**，所以，我们考虑对每一坨关联起来的循环分开计算。

对于一坨循环，通过它们的关联关系，把它们画成一棵树，表示其依赖关系。

然后，掏出树形 DP，$f_{u,i}$ 表示循环 $u$ 的循环变量为 $i$ 时其子树的总循环次数，对于 $u$ 的每个儿子 $v_k$，**它们的先后是随意的**。所以，为了便于理解，假设先进行 $v_1$ 的所有循环，再进行 $v_2,v_3,\cdots,v_k$ 的循环。设当儿子的循环变量取 $l$ 时可以转移到当前节点，于是可以得到（分步乘起来）:

$$ f_{u,i}=\prod\limits_{j=1}^{k}\sum f_{v_j,l}$$


只剩最后一个问题，儿子中有哪些 $l$ 可以转移过来。这是比较容易的，对于一个已经确定的循环变量 $i$，可以根据上下界的定义，直接 ```for``` 模拟一遍。

简单计算一下时间复杂度为 $O(n\times10^{10})$（$n$ 个循环，一个循环值域为 $10^5$，再枚举一遍儿子节点的值域 $10^5$）。明显是不行的。

再研究一下，~~显而易见地~~发现，儿子中可转移的东西是**连续**的（毕竟是 ```++i```）,于是就拿出前缀和优化，砍掉一个 $10^5$。

最后，在算完每一坨之后，因为是嵌套的循环，就把每一坨的循环次数乘起来得出答案。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N(30),M(1e5+10),mod(1e9+7);
int n,a[N],b[N],d[N],h[N],ne[N],e[N],idx;
ll f[N][M],ans=1,sum[N][M];
bool fg[N];
inline ll mo(ll x){
	return x<mod?x:x-mod;
}
inline void add(int u,int v){
	ne[++idx]=h[u],h[u]=idx,e[idx]=v;
}
inline void dfs(int u){
	for(int i=a[u];i<=b[u];++i) f[u][i]=1;
	for(int i=h[u];i;i=ne[i]){
		int v=e[i];
		dfs(v);
		for(int j=a[u];j<=b[u];++j){
			if(d[v]) f[u][j]=f[u][j]*(a[v]<=j?sum[v][j]-sum[v][a[v]-1]+mod:0)%mod;
			else f[u][j]=f[u][j]*(j<=b[v]?sum[v][b[v]]-sum[v][j-1]+mod:0)%mod;
		}
	}
	for(int i=a[u];i<=b[u];++i) sum[u][i]=mo(sum[u][i-1]+f[u][i]);
}
int main(){
	string l,r;
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		a[i]=1,b[i]=M-1;
		cin>>l>>r;
		int ff=0;
		if(l[0]>='a'&&l[0]<='z') add(l[0]-'a'+1,i);
		else{
			a[i]=0;
			for(int j=0;j<l.size();++j) a[i]=(a[i]<<1)+(a[i]<<3)+(l[j]-'0');
			++ff;
		}
		if(r[0]>='a'&&r[0]<='z') add(r[0]-'a'+1,i),d[i]=1;
		else{
			b[i]=0;
			for(int j=0;j<r.size();++j) b[i]=(b[i]<<1)+(b[i]<<3)+(r[j]-'0');
			++ff;
		}
		if(ff==2) fg[i]=1;
	}
	for(int i=1;i<=n;++i)
		if(fg[i]) dfs(i),ans=ans*(sum[i][b[i]]-sum[i][a[i]-1]+mod)%mod;
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：hnczy (赞：0)

遇到不明二元关系建议建图。

巧了，这题直接就是建树即可。

因为每一个点只有一个入度。

当然为了方便计算，可以建一个虚原点，去连那些没有父亲的点。

这样我们就可以愉快的树形 dp 了。

$dp[i][j]$ 表示在 $i$ 这一个点等于 $j$ 时所获得的收益。

$dp[i][j] =\prod pre[v][r_{v,j}]-pre[v][l_{v,j}-1]$ 这里的 $r$ 指的是在这 $v$ 一个点的父亲选了 $j$ 时的上界，$l$ 同理。

```c++
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=1e9+7;
int n,fa[30],f[30][100005],a[3][30],flag[30];
string s[3][30];
vector<int>e[30];
void dfs(int x) {
	for(int i=a[1][x]; i<=a[2][x]; i++)f[x][i]=1;
	for(int p:e[x]) {
		dfs(p);
		for(int i=a[1][x]; i<=a[2][x]; i++) {
			int L=a[1][p],R=a[2][p];
			if(flag[p]==1)L=i;
			else if(flag[p]==2)R=i;
			if (L <= R)(f[x][i] *= ((f[p][R] - f[p][L - 1] ) % mod+ mod)%mod) %= mod;
            else f[x][i] = 0;
		}
	}
	for(int i=a[1][x]; i<=a[2][x]; i++)(f[x][i]+=f[x][i-1])%=mod;
}
int solve(string s) {
	int sum=0;
	for(int i=0; i<s.size(); i++)
		sum=sum*10+s[i]-'0';
	return sum;
}
signed main() {
	scanf("%lld",&n);
	for(int i=1; i<=n; i++) {
		cin>>s[1][i]>>s[2][i];
		if(!isdigit(s[1][i][0]))e[s[1][i][0]-'a'+1].push_back(i),fa[i]=1,flag[i]=1,a[1][i]=1;
		else a[1][i]=solve(s[1][i]);
		if(!isdigit(s[2][i][0]))
			e[s[2][i][0]-'a'+1].push_back(i),fa[i]=1,flag[i]=2,a[2][i]=100000;
		else a[2][i]=solve(s[2][i]);
		if(!fa[i])e[0].push_back(i);
	}
	a[1][0]=a[2][0]=1;
	dfs(0);
	printf("%lld",f[0][1]) ;
	return 0;
}

```

---

## 作者：teylnol_evteyl (赞：0)

看起来比较复杂，但实际上是一个树上 dp 的模型。

因为每一重循环都最多有一个依赖，可以转化为树上的父子关系，于是就形成了一个森林。

对于非叶子节点，设 $f_{u,i}$ 表示第 $u$ 循环变量的值是 $i$ 时所有直接或间接依赖于它的循环变量（即以它为根的子树除开它的部分）循环次数，对非根节点设 $g_{u,i}$ 表示当第 $u$ 个变量依赖的循环变量值为 $i$ 时它和所有直接或间接依赖于它的循环变量（即以它为根的子树）循环次数。

对于非叶子节点，可以发现一个节点的子节点的子树是不互相影响的，也就是说交换子树之间循环的内外位置是不会影响答案的，根据乘法原理，$f_{u,i}=\prod g_{v,i}$，其中 $v$ 是 $u$ 的子节点。

对于非根节点，父亲节点循环变量的取值会限制这个变量的取值范围，所以 $g$ 应该是 $f$ 的一个区间和。具体地，如果父亲节点限制了取值的上界，则当 $i<x_u$ 时，$g_{u,i}=0$，当 $i\ge x_u$ 时，$g_{u,i}=\sum_{j=x_u}^i f_{u,j}$；如果父亲节点限制了取值的下界，则当 $i>y_u$ 时，$g_{u,i}=0$，当 $i\le y_u$ 时，$g_{u,i}=\sum_{j=i}^{y_u}f_{u,i}$，可以用前缀和优化。

对每棵树处理完 dp 数组之后，考虑计算答案。可以发现对于所有子树之间的循环内外关系也是可以交换的，所以答案就是所有根节点对答案贡献的乘积，如果根节点 $u$ 有儿子节点，就让答案乘上 $\sum_{i=x_u}^{y_u}f_{u,i}$，如果没有儿子节点，那这就是一层没有限制也不限制其他变量取值的循环了，就让答案乘上 $y_u-x_u+1$。

```
#include <bits/stdc++.h>

using namespace std;

typedef long long LL;

const int N = 30, M = 1e5 + 5, P = 1e9 + 7;

int n, m = 1e5;
char str[N];
int x[N], y[N], fa[N], op[N];
int la[N], ne[N], en[N], idx;
bool st[N];
LL f[N][M], s[N][M];
LL res;

void add(int a, int b)
{
	ne[ ++ idx] = la[a];
	la[a] = idx;
	en[idx] = b;
}

void add(LL &x, LL y)
{
	x += y;
	if(x >= P) x -= P;
}

void dfs(int u)
{
	st[u] = true;
	if(!la[u])
	{
		if(op[u] == 1)
			for(int j = 1; j <= m; j ++ ) f[u][j] = max(y[u] - j + 1, 0);
		else
			for(int j = 1; j <= m; j ++ ) f[u][j] = max(j - x[u] + 1, 0);
		for(int j = 1; j <= m; j ++ ) s[u][j] = s[u][j - 1], add(s[u][j], f[u][j]);
	}
	else
	{
		for(int i = 1; i <= m; i ++ ) f[u][i] = 1;
		for(int i = la[u]; i; i = ne[i])
		{
			int v = en[i];
			dfs(v);
			for(int j = 1; j <= m; j ++ ) f[u][j] = f[u][j] * f[v][j] % P;
			for(int j = 1; j <= m; j ++ ) s[u][j] = s[u][j - 1], add(s[u][j], f[u][j]);
		}
		if(fa[u])
		{
			if(op[u] == 1)
				for(int j = 1; j <= m; j ++ )
				{
					if(j > y[u]) f[u][j] = 0;
					else f[u][j] = s[u][y[u]], add(f[u][j], P - s[u][j - 1]);
				}
			else
				for(int j = 1; j <= m; j ++ )
				{
					if(j < x[u]) f[u][j] = 0;
					else f[u][j] = s[u][j], add(f[u][j], P - s[u][x[u] - 1]);
				}
			for(int j = 1; j <= m; j ++ ) s[u][j] = s[u][j - 1], add(s[u][j], f[u][j]);
		}
	}
}

int main()
{
	scanf("%d", &n);
	for(int i = 1; i <= n; i ++ )
	{
		scanf("%s", str);
		if(str[0] > '9')
		{
			fa[i] = str[0] - 'a' + 1;
			op[i] = 1;
			add(fa[i], i);
		}
		else
			for(int j = 0; str[j]; j ++ ) x[i] = x[i] * 10 + str[j] - 48;
		scanf("%s", str);
		if(str[0] > '9')
		{
			fa[i] = str[0] - 'a' + 1;
			op[i] = 2;
			add(fa[i], i);
		}
		else
			for(int j = 0; str[j]; j ++ ) y[i] = y[i] * 10 + str[j] - 48;
	}
	
	res = 1;
	for(int i = 1; i <= n; i ++ )
		if(!st[i])
		{
			if(la[i])
			{
				dfs(i);
				res = res * (s[i][y[i]] - s[i][x[i] - 1] + P) % P;
			}
			else res = res * (y[i] - x[i] + 1) % P;
		}
	
	printf("%lld\n", res);
	return 0;
}
```

---


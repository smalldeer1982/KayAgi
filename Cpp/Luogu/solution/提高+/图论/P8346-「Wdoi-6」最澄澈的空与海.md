# 「Wdoi-6」最澄澈的空与海

## 题目背景

[![](https://cdn.luogu.com.cn/upload/image_hosting/hiekh6t5.png)](https://thwiki.cc/%E5%8D%AF%E9%85%89%E4%B8%9C%E6%B5%B7%E9%81%93_%EF%BD%9E_Retrospective_53_minutes.)

广重号载着二人向东飞驰。毫无噪音，毫无摇摆，只是一个劲向东飞驰。在“万景幕”装置之下，尽管是全地下的卯酉东海道，乘客们也能饱览美丽的富士山和太平洋的景色。

但是，从这列卯酉新干线『广重』上看到的极富日本风味的美丽情景，对于梅莉来说，只不过是无趣的视觉刺激罢了。高动态范围的影像也好，极富日本风味的情景也好，都敌不过真正的天空的颜色。

身与华落，心将香飞。即便肉体会像花朵一样终有一天凋落，但心却可以如花香一般飘往远方。

「梅莉，你看，天上的星星呦。」

## 题目描述

### 简要题意

给定 $2n$ 个点、$m$ 条边的[二分图](http://oi-wiki.com/graph/bi-graph/#_1)（可能有重边），左部点与右部点个数相同，判断其完美匹配数量是否**恰好**为 $1$。是则输出 `Renko`，否则输出 `Merry`。

> **注**：完美匹配是指，从边集中选出 $n$ 条边，这些边的顶点组成的点集恰好覆盖了所有的 $2n$ 个点。

---
### 原始题意

在夜里，莲子与梅莉来到了东京的海边，躺在沙滩上，欣赏着澄澈的天空与大海，数起了天上的星星。

在这些星星之中，有 $n$ 个星星 $\{a_i\}$，是莲子先发现的，被称为莲子星；而又有 $n$ 个星星 $\{b_i\}$，是梅莉先发现的，被称为梅莉星。由于她们心有灵犀，这两批星星之间**不存在交集**。  

她们发现，有一些莲子星，与一些梅莉星之间恰好存在运动关系。具体而言，这些关系一共有 $m$ 组，每一组关系形如 $(u_i,v_i)$，也就是说第 $u_i$ 颗莲子星与第 $v_i$ 颗梅莉星之间存在运动关系。这些运动关系有可能重复。

这让莲子和梅莉非常好奇。作为专攻超统一物理学的女大学生，莲子认为，如果认为这些星星的运动是**和谐**的，那么她应当能够从这 $m$ 个运动关系中，找出若干个运动关系，使得**每颗**星星**都被**这些运动关系**包含**的同时，不会有一颗星星**被包含在两个**运动关系之中。

然而，梅莉认为，**和谐**的运动可能是不存在的，更何况即使莲子找到了**和谐**的运动，莲子也无法确保这种和谐运动的**唯一性**。两种和谐运动不同，当且仅当选取出的两组运动关系中，存在至少一个运动关系，是不相同的。

因为意见不合，她们于是打情骂俏了一顿。莲子于是记下了她们所看到了星星和她们之间的运动关系，并且找到了已经证明了 P=NP 的你，希望你能告诉她们，最后是谁正确呢？

## 说明/提示

### 样例解释

#### 样例 \#1

![](https://cdn.luogu.com.cn/upload/image_hosting/6skoily9.png)

如图所示，存在唯一的方案：$\{1\to 1,2\to 5,3\to 2,4\to 3,5\to 4\}$。

### 数据范围

**本题采用捆绑测试。**

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|c|}\hline
\textbf{Subtask} & \textbf{\textsf{分值}} & \bm{n\le } & \bm{m\le} & \textbf{\textsf{特殊性质}} & \textbf{Subtask \textsf{依赖}}\cr\hline
1 & 10 & 10 & 10 & - & - \cr\hline
2 & 20 & 300 & 4\times 10^4 & - & 1\cr\hline
3 & 20 & 10^5 & 5 \times 10^5 & \mathbf{A} & - \cr\hline
4 & 20 & 10^5 & 2 \times 10^5 & \mathbf{B} & - \cr\hline
5 & 30& 10^6 & 2\times 10^6 & - & 2,3,4 \cr\hline
\end{array}
$$

- 特殊性质 $\mathbf{A}$：保证对于第 $i$ 颗莲子星，与第 $i$ 颗梅莉星之间存在运动关系。
- 特殊性质 $\mathbf{B}$：保证 $m=2n-1$。

对于 $100\%$ 的数据，保证 $1 \le u_i,v_i\le n \le 10^6$，$1 \le m \le 2 \times 10^6$，$1 \leq T \leq 5$ 且对于每个测试点，$\sum m \leq 4 \times 10^6$。

对于 $\rm Subtask\ 5$，时间限制为 $3$ 秒。其它测试点时间限制为 $1$ 秒。

## 样例 #1

### 输入

```
1
5
6
1 1
1 3
3 2
2 5
4 3
5 4```

### 输出

```
Renko```

# 题解

## 作者：retep (赞：23)

## 题目简述
已知一个左右都有 $n$ 个节点，一共有 $m$ 条边的二分图，求此图是否有且仅有一种完全匹配方案。是则输出 Renko，否则输出 Merry。

## 题目分析
这是一道结论题，先说结论，**当一个二分图有且仅有一种解时，必定有节点的入度为 $1$**。

如何证明？
因为只要入度为 $2$ 的情况被证明了，入度大于 $2$ 的情况就都可以通过删边转换过来，所以
考虑反证法，证明当所有节点的入度为 $2$ 时，只有以下两种情况：
1. 有解时，解的数量一定大于 $1$
2. 无解时...就是无解（~~废话~~）

无解的情况很好说明，只要找到一个例子就行了，剩下的就是有解的情况。

因为有解，所以我们可以先建一个节点一一对应的二分图，然后在这张图上加边，试图将其变成所有节点入度为 $2$ 的二分图，起始状态如下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/dhx4le1x.png)

我们只考虑一边的节点，因为两边是对称的。

左边的每个节点都已经有了一个右边的第一选择，也就是现在连着的节点，他们还需要一个右边的第二选择来让自己的度数变成 $2$。 

两个不同的节点可能选相同的节点作为第二选择，我们按第二选择的不同节点数量来分类讨论。

当作为第二选择的节点的数量为 $1$ 时，也就是所有节点的第二选择都是同一个点时...这种情况并不存在，因为如果是这样的话，**被选为第二选择的那一个节点对面的节点**就没有可选的第二选择了，因为那是它的第一选择，它不能再选一次同样的。

当作为第二选择的节点的数量为 $2$ 时，我们设被选为第二选择的节点为 $A$ 与 $B$。 $A$ 节点对面的节点一定会选 $B$ 作为第二选择。 $B$ 节点对面的节点也一定会选 $A$ 作为第二选择。这就形成了一个交叉，交叉一定会产生第二种匹配方法。

如下图所示，黄色的是新增的边，第二选择的 $A$ 与 $B$ 是节点 $2$ 与 $4$。$1$ 改选 $4$，$3$ 改选 $2$，就有了第二种匹配方法。

![](https://cdn.luogu.com.cn/upload/image_hosting/sru93gkb.png)

同样地，当作为第二选择的节点的数量为 $3$ 时，如下图所示，$2$、$4$、$6$ 是第二选择节点。$1$、$2$、$3$、$4$、$5$、$6$ 节点的新边产生了第二种解法。

![](https://cdn.luogu.com.cn/upload/image_hosting/jrhulow7.png)

但这只是**当第二选择节点对面的所有节点的第二选择都不重复时**的必然情况，如果重复了呢？

如下图所示，作为第二选择的 $6$ 与 $2$ 对面的节点都选了 $4$ 作为第二选择。

![](https://cdn.luogu.com.cn/upload/image_hosting/oqpmonyn.png)

熟悉的交叉又出现了，对，就是第二选择节点数为 $2$ 时的情况，所以一定也有第二种解法。

通过以上的观察（并没有严格证明，只是助于理解），我们可以得到一个重要结论：
1. 当第二选择节点对面的节点的第二选择不重复时，直接就能找到第二种匹配方法
2. 有重复时，会出现之前的某种情况，然后找到第二种匹配方法。

于是乎，不管怎样添边，都会出现第二种匹配方法，所以当二分图的所有节点度数为 $2$ 并且有解时，解的数量一定大于 $1$。

结论有了，该怎么用呢？需要注意的是这只是一个必要非充分条件，也就是说满足题意所说的**有且仅有一个解的情况一定会出现入度为 $1$ 的节点**，但并不代表有入度为 $1$ 的节点的二分图就一定满足题意。

幸运的是，咱们会写程序。我们可以每次找到入度为 $1$ 的节点，也就是只有一条边的节点。然后顺着那条唯一的边找到对面的一个节点。这两个节点一定是**锁死**的，因为如果它俩不在一起，入度为 $1$ 的点就没有别的选择了，二分图也就无解了。

既然它俩的关系已经确定了，那么它俩就对剩余节点的匹配就没有影响了，我们就可以将它俩连点带边全部删掉。注意，边也要删掉，以此减少某些节点的入度。

就这样一直迭代下去，如果可以全部删完，那么就是满足题意的，删不完就是说有入度都大于 $2$ 的子问题，只有无解或者解的数量大于 $1$ 的可能，不满足题意。

每次寻找入度为 $1$ 的节点太耗时间了，我们可以考虑类似拓扑排序的做法，但不是将入度变为 $0$ 的节点点入队，而是将入度变为 $1$ 的节点入队。

## code:
```cpp
#include<bits/stdc++.h>
#define N 2000005
#define ll long long
using namespace std;

int t,n,m,cnt;
vector<int> to[N];
int in[N];
bool del[N];

void solve(){
	cin>>n>>m;
	for(int i=1,u,v;i<=m;i++){
		cin>>u>>v; v+=n; //右边的点重新编号
		to[u].push_back(v); in[v]++;
		to[v].push_back(u); in[u]++;
	}
	queue<int> q; cnt=0;
	for(int i=1;i<=2*n;i++)
		if(in[i]==1)q.push(i); //将入度为1的点入队
	while(!q.empty()){
		int now=q.front(),buf=0; q.pop();
		if(del[now]||in[now]!=1)continue; //如果已经没删掉了，或者入度不为1了，那就跳过。已经入队的点的状态也可能被改变，因为这里是左右两边一起迭代的。
		del[now]=true; cnt++; //删掉这个点，删掉的数量加1
		while(del[to[now][buf]])buf++; //找到仅存的那一条边
		del[to[now][buf]]=true; cnt++; //顺着仅存的边找到另一个点，删掉
		for(int i=0;i<to[to[now][buf]].size();i++) //删边，没有真的删，只是减少目标节点的入度，这也是为什么要用while找仅存的边。
			if(!del[to[to[now][buf]][i]]&&(--in[to[to[now][buf]][i]])==1)
				q.push(to[to[now][buf]][i]); //如果还没被删，并且入度减少为1了就入队
	}
	if(cnt==n*2)cout<<"Renko"<<endl; //全删了
	else cout<<"Merry"<<endl;  //没全删
	for(int i=1;i<=n*2;i++)in[i]=del[i]=0,to[i].clear(); //多组数据，要初始化
}

int main(){
	cin>>t;
	while(t--)solve();
	return 0;
}
```



---

## 作者：Cocoly1990 (赞：9)

很有意思的题目。

我们考虑怎么思考这个问题，我们假设一个图有且仅有一个完美匹配，这时候插入一个点，什么情况下这个新图也有且仅有一个完美匹配呢？没错，仅当这个点度数为 $1$，否则这张新图的完美匹配个数应该是这个点的度数。显然，到这里我们可以猜结论，**当且仅当图中有度数为 $1$ 的点否则必然没有或有多于一种完美匹配。**

考虑如何证明，不妨反证法，假设一张 $2n$ 个点的二分图每个点的度数至少为 $2$，且假设该图存在有且仅有一个完美匹配 $a_i\rightarrow a_j,i\in\left[1,n\right]$，我们不妨找出这个完美匹配，并删去这些边，并建立一张 $n$ 个点的新图，对于剩下的边若存在 $a_i\rightarrow b_i$，则在新图上连有向边 $i\rightarrow j$.容易发现新图每个点的出度都至少为 $1$，则至少存在一个简单环（如果是不是简单环就把他扣成简单环看），不妨假设他是 $1\rightarrow 2\rightarrow \cdots \rightarrow k\rightarrow 1$.那么原图存在另一个完美匹配 $a_1\rightarrow b_2,a_2\rightarrow b_3,\cdots a_k\rightarrow b_1,a_i\rightarrow b_i,i\in\left[k+1,n\right]$.

至此结论成立，我们可以采用不断减小子问题的方法来解决这题，具体而言，利用队列不断删除度数为 $1$ 的点和他对面的点，并把删除后度数为 $1$ 的点再入队，如果图删空了，就 `Renko`，否则是 `Merry`。

多测要清空！！！！！！1

---

## 作者：minstdfx (赞：7)

我是废物。
### 题意简述

判断一个左右部点数均为 $n$ 的二分图是否**有且仅有**一个完全匹配方案。

### 一眼观察

我会二分图匹配！

先不说你怎么判断唯一性，光是找匹配方案你就 T 飞了（匈牙利复杂度 $\Theta(nm)$，dinic 复杂度 $\Theta(m\sqrt n)$）。

### 二眼观察

手玩 $1437$ 组之后可以发现每组可行解必有一度点。但也仅限于此了。

结论：对于一个左部右部均 $n$ 个点的二分图，如果它每个点的度数都大于等于 $2$，那么它完美匹配必然不可能存在且唯一。

假设该唯一完美匹配为 $u_i \rightarrow v_{s_i}$，去掉这些边的图上套路地将 $u_i \rightarrow v_j$ 的边变成 $n$ 点有向图中的边 $i \rightarrow j$，则有向图中每个点都有出边，必然存在简单环 $\{c_1,c_2,\cdots,c_k\}$

则在原二分图中 $\forall i$ 存在边 $u_{c_i} \rightarrow v_{c_{i\bmod k+1}}$。

我们把原匹配中的边 $\{(v_{c_i}\rightarrow v_{s_{c_i}}),\cdots\}$ 换成 $\{(v_{c_i}\rightarrow v_{s_{c_{i\bmod k+1}}}),\cdots\}$ 就可以得到另一个完美匹配。

对于一个断言存在完美匹配的二分图，每个一度点显然只能匹配它所连接的相邻点。

那么把这个点对 $(u_i,v_j)$ 从原本的二分图中删去，显然不影响完美匹配的存在性和唯一性。

存在性：因为如果有的话显然只能这两个匹配和其他点无关，如果没有的话去掉这一个点对的二分图还是没完美匹配的（否则，若去掉之后的二分图有完美匹配那把这一组加上去也有完美匹配了，矛盾）。

唯一性：因为如果有的话显然只能这两个匹配和其他点无关，所以其他点是否唯一不关这两个点的事。

那么不停的删掉一度点和它的相邻点就好了。
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=2000009;
int vis[maxn],n,m,N;
vector<int> e[maxn];
deque<int> q;
int read() {
	int a=0,b=1,c=getchar();
	while(isspace(c)) c=getchar();
	if(c=='-') b=-1,c=getchar();
	while(isdigit(c)) a=(a<<3)+(a<<1)+(c^48),c=getchar();
	return a*b;
}
int deg[maxn];
bool check()
{
	for(int i=1;i<=N;++i)
	{
		deg[i]=e[i].size();
		if(e[i].empty()) {
			// printf("%d is empty.\n",i);
			return false;
		}
		else if(e[i].size()==1) vis[i]=true,q.push_back(i);
	}
	int visited=0;
	while(!q.empty())
	{
		int cur=q.front(),nxt=-1;
		q.pop_front();++visited;
		for(auto i:e[cur])
			if(!vis[i])
			{
				nxt=i;
			}
		if(nxt==-1) continue;
		vis[nxt]=1;++visited;
		for(auto i:e[nxt])
		{
			if(!vis[i])
			{
				if((--deg[i])<2) {
					q.push_back(i);
					vis[i]=1;
				}
			}
		}
	}
	// printf("%d\n",visited);
	return visited>=N;
}
int main()
{
	int t=read(),u,v;
	while(t--)
	{
		n=read();m=read();N=n<<1;
		for(int i=1;i<=N;++i) e[i].clear();
		memset(vis,0,sizeof(int)*(N+1));
		q.clear();
		while(m--)
		{
			u=read();v=read();
			e[u].push_back(v+n);
			e[v+n].push_back(u);
		}
		puts(check()?"Renko":"Merry");
	}
}
```

---

## 作者：Kevin_Mamba (赞：6)

题中的简要题意已经很精简了，这里就不多复述了。

## $Solution$

原本想水水二分图的题，但做了半天，写的匈牙利算法挂了，又是答案错误又是超时的。所以我翻了翻题解，有一句话点醒了我。

这句话的大概意思就是**若一个二分图有且仅有一个完美匹配，这个图的左部点中必有度数为 $1$ 的点。**

其实这句话很有意思。我琢磨了一下，其实不难理解。

1. **若整个图中有点的度数有 $0$，那就肯定没有完美匹配。** 因为这个点无法匹配另一部的任意一个点，匹配数量就不可能达到 $n$。

2. **若左部点度数都大于 $1$，若有完美匹配，那就必有多个。** 每个点都会有至少一个可配对的替代品，至少会出现一个循环（你的配偶给我，我的配偶给他，他的配偶给你）。注意不一定 $n$ 个点都参与循环。

得到这个结论后，我又想到了，那**度数为 $1$ 的左部点在完美匹配中能配对的点就只有一个**，那不就能把这一对点和他们所有的连边删去，康康剩下的图的完美匹配情况？

所以我想到拓扑，虽然不能说完全是，只能说是相似。

具体步骤如下（可能不是最简单的，但是比较好理解）。

#### 第一步：存图（本人使用链式前向星）。

输入两个数：$u,v$。$u$ 为左部点，$v$ 为右部点。

存两条**有向边**。$u\rightarrow v$ 和 $v\rightarrow u$。为了避免左右部点编号重复，分开存。

然后将 $u$ 的出度加上 $1$。

#### 第二步：伪拓扑。

1. 判断是否有入度为 $0$ 点。若有，直接判断没有完美匹配。同时看有没有出度为 $1$ 的左部点。若有，加入栈。

2. 循环至栈内没有点。每次取出栈顶，用一个 $s$ 累计有多少个左部点入过栈。 

3. 枚举栈顶 $u$ 的所有连边，因为 $u$ 此时出度为 $1$，至多有一个连边的 $v$ 还存在。若不存在 $v$，说明 $v$ 已经被另一个左部点抢了，直接判断出无完美匹配；否则用一个 $vis$ 数组标记这个 $v$，相当于把它删了。然后用之前存的 $v\rightarrow u$ 枚举与 $v$ 相连的 $u$，将所有 $u$ 的出度减一。

4. 若出度被减的 $u$ 出度只剩下 $1$，加入栈。

#### 第三步：判断答案。

若 $s=n$，说明只有一个完美匹配。否则代表不止一个，或者没有。

## 代码实现

```cpp
#include<bits/stdc++.h>
#define il inline 
#define re register
using namespace std;

const int N=1e6+10,M=2e6+5;

int n,m;

int cnt,head[N],nxt[M],to[M],out[N];
// u->v
int cnt_2,head_2[N],nxt_2[M],to_2[M];
// v->u

bool vis[N];

int s,stac[N],top;
// 能删的左部点个数，存能删的左部点的栈 

il void qian(re int u,re int v)
{
	to[++cnt]=v;
	nxt[cnt]=head[u];
	head[u]=cnt;
}

il void qian_2(re int u,re int v)
{
	to_2[++cnt_2]=v;
	nxt_2[cnt_2]=head_2[u];
	head_2[u]=cnt_2;
}

// 前向星存图 

int main()
{
	int T;
	scanf("%d",&T);
	while(T--)
	{	
		// 记得初始化 
		memset(head,0,sizeof head);
		memset(head_2,0,sizeof head_2);
		memset(vis,false,sizeof vis);
		memset(out,0,sizeof out);
		s=cnt=cnt_2=top=0;
		scanf("%d%d",&n,&m);
		for(re int i=1;i<=m;i++)
		{
			re int u,v;
			scanf("%d%d",&u,&v);
			out[u]++;
			qian(u,v);
			qian_2(v,u);
		} 
		bool f=true;
		for(re int i=1;i<=n;i++)
		{
			if(out[i]==0||head_2[i]==0) 
			// 判断度数为 0 
			{
				f=false;
				break;
			}
			if(out[i]==1)
				stac[++top]=i;
			// 出度为 1，入栈 
		}
		if(!f)
		{
			puts("Merry");
			continue;
		}
		while(top)
		{
			re int U=stac[top],V=0; 
			top--,s++;
			for(re int i=head[U];i;i=nxt[i])
			{
				re int v=to[i];
				if(!vis[v]) 
				// 找到唯一出边连的点 
				{
					V=v;
					break;
				}
			}
			if(V==0) break; 
			vis[V]=true;
			// 删点（若存在） 
			for(re int i=head_2[V];i;i=nxt_2[i])
			{
				re int u=to_2[i];
				out[u]--;
				// 出度减一 
				if(out[u]==1)
					stac[++top]=u;
					// 新点入栈 
			}
		}
		puts(s==n?"Renko":"Merry");	
	}

	return 0;
}
```











---

## 作者：gyyyyx (赞：6)

还是很有难度的。

首先如果一个二分图最多**有且仅有**一个完美匹配，那**一定有点**的入度为 $1$。

那要如何证明呢？

假设有一个有 $2n$ 个点，$n$ 条边的二分图：

![](https://cdn.luogu.com.cn/upload/image_hosting/5ybqliua.png)

很明显每个点的入度都为 $1$，且只有一种完美匹配方案。

那如果我们要让每个点的入度都**至少**为 $2$ 呢？

很明显，**至少**要增加 $n$ 条边。

我们先加上 $n-1$ 条边：

![](https://cdn.luogu.com.cn/upload/image_hosting/piu10jlu.png)

我们会发现 $3$，$4$ 两个点入度仍然为 $1$。

如果把它们相连：

![](https://cdn.luogu.com.cn/upload/image_hosting/hvnckm9k.png)

那就会出现两种完美匹配方案。

但如果我们将 $3$，$4$ 与其他点相连，类似这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/9yalbkcx.png)

就会出现更多完美匹配方案。

所以说，如果某些节点和某些边所组成的新的二分图有多种完美匹配方案，那一定是所有点的入度都大于 $1$。

但你交了这样一个[代码](https://www.luogu.com.cn/paste/4gya2gq7)之后会发现。。。[TAT](https://www.luogu.com.cn/record/76293503)

因为满足题意所说的**有且仅有**一个解的情况一定会出现入度为 $1$ 的节点，但并**不代表**有入度为 $1$ 的节点的二分图就一定满足题意。

怎么办？

可以用拓扑排序。

我们可以每次找到入度为 $1$ 的节点。然后顺着那条唯一的边找到对面的一个节点。这两个节点一定是一起的，因为如果它俩不在一起，入度为 $1$ 的点就没有别的选择了，二分图也就无解了。

然后还有一个要注意的点，如果选择的节点的入度已经为零（可能是先入了队列，然后删掉了它仅剩的那个节点和对应的边，但是这个节点并没有出队），那要直接判断为 ```Merry``` ，无解。

代码：

```cpp
#include<bits/stdc++.h>
#define N 1000005
using namespace std;
int T,n,m,u,v,cnt;
int du[N<<1];
vector <int> G[N<<1];
queue <int> q;
bool del[N<<1];
inline bool TPSORT(){
    while(!q.empty()) q.pop();cnt=0;
    for(int i(1);i<=(n<<1);++i) del[i]=0;
    for(int i(1);i<=(n<<1);++i)
        if(du[i]==1) q.push(i);
    while(!q.empty()){
        int u(q.front()),v(0);q.pop();
        if(del[u]) continue;
        del[u]=1;++cnt;
        for(int i(0);i<G[u].size();++i)
            if(!del[G[u][i]]){
                v=G[u][i];
                break;
            }
        if(!v) return 0;
        del[v]=1;++cnt;
        for(int i(0);i<G[v].size();++i)
            if(!del[G[v][i]]&&(--du[G[v][i]])==1)
                q.push(G[v][i]);
    }
    return cnt==(n<<1);
}
int main(){
    scanf("%d",&T);
    while(T--){
        scanf("%d%d",&n,&m);
        for(int i(1);i<=(n<<1);++i) du[i]=0;
        for(int i(1);i<=(n<<1);++i) G[i].clear();
        for(int i(1);i<=m;++i){
            scanf("%d%d",&u,&v);
            ++du[u];++du[v+n];
            G[u].push_back(v+n);
            G[v+n].push_back(u);
        }
        puts(TPSORT()?"Renko":"Merry");
    }
    return 0;
}
```
完结撒✿

---

## 作者：_www_ (赞：3)

### 简化题意
给定一个左右侧均有 $n$ 个点，$m$ 条边的二分图，判断其是否有且仅有一个完美匹配方案。

$n\le 10^6$，$m\le 2\times10^6$。
### 题解
直接跑二分图匹配显然不行，我们发现题述合法二分图满足原图存在完美匹配且删去任意一条匹配边后不存在完美匹配，故可转化为完美匹配存在性判定问题。

**Hall 定理**：二分图 $G$ 存在一个匹配包含左侧所有点，当且仅当对任意左侧点集 $S$，其邻居点集 $N(S)$ 满足 $|N(S)|\ge|S|$。

若一个二分图 $G$ 合法，则其满足上述条件，且对其删去一条匹配边后的二分图 $G'$，存在左侧非空点集 $S$ 满足 $|N(S)|<|S|$。由于删去一条边至多使一个左侧点集 $S$ 的邻居点数减少 $1$，故原图一定存在一个左侧非空点集 $S$ 满足 $|N(S)|=|S|$，显然这个点集内的点度数均为 $1$。所以我们得到了一个二分图合法的必要条件，即其左侧存在度数为 $1$ 的点。

对于左侧一个度数为 $1$ 的点，存在唯一右侧点与其匹配，把这两个点和与它们相连的边删去后可转化为一个子问题，即只需判断子图是否合法。我们不断删去 $1$ 度点和与其匹配的点，若能将图删空显然合法，否则余下的子图不存在 $1$ 度点，故一定不合法。

时间复杂度 $\mathcal{O}(n+m)$。
```cpp
#include<bits/stdc++.h>
const int N=2e6+5;
int T,n,m,d[N],v[N];
std::vector<int> e[N];
std::queue<int> q;
int main(){
	for(scanf("%d",&T);T--;){
		scanf("%d%d",&n,&m);
		for(int i=1;i<=n+n;++i)d[i]=v[i]=0,e[i].clear();
		for(int x,y;m--;)scanf("%d%d",&x,&y),e[x].push_back(n+y),e[n+y].push_back(x),++d[x];
		for(int i=1;i<=n;++i)if(d[i]==1)q.push(i);
		for(int x;q.size()&&(x=q.front());q.pop())
			for(int y:e[x])if(!v[y]++)for(int z:e[y])if(--d[z]==1)q.push(z);
		puts(*std::min_element(v+n+1,v+n+n+1)?"Renko":"Merry");
	}
	return 0;
}
```

---

## 作者：XL4453 (赞：2)

感谢 [$\text{JohnVictor}$](https://www.luogu.com.cn/user/254752) 指出题解错误。

一个每一个点的度数都超过 $2$ 的二分图并不一定能够删成每一个点度数恰好为 $2$ 的二分图，不能直接转化到正则图上进行证明。

---
### 解题思路：

首先排除一些干扰。

将所有的只有一条边连接的点删去，当然同样需要删去经过一些次数的删去之后剩下的边数只有一的点。这一步的过程一定不干扰后面的所有操作。

在在此之后，如果图中还存在完全没有边与之连接的点，可以直接断言不存在完美匹配，这同样是显然的。

---

然后发现经过处理的二分图中所有的点的度数至少为 $2$，接下来就只需要考虑一个度数至少为 $2$ 的二分图的匹配情况就行了。

假设这个二分图没有完美匹配，那么直接不满足条件。重点讨论存在至少一组完美匹配的情况。在这种情况考虑一条交替回路，也就是从一个点出发，依次经过匹配边和非匹配边最后回到原来点的一条路径。如果存在这样的一条交替回路，那么将这一条路上的边全都取反，也就说明了存在不止一种完美匹配。

从任意一个点出发，每一次从当前点的若干条边中依次选出匹配边和非匹配边，由于每一个点的度数至少为 $2$，而且每一个点都在匹配中，容易知道每一个点的边中至少有一个匹配边和一个非匹配边，结合需要的匹配边和非匹配边交替出现，所以到达一个尚未被访问过的节点时一定存在向周围节点拓展的方案，换言之，不存在到达某一个未被拓展到的节点而不能继续拓展的情况。在经过这样的若干次拓展之后，由于节点时有限的，一定会到达某一个之前被拓展到的节点，那么，从这个在之前被拓展到的节点开始，向后依次走之前拓展出来的路径，也就找到了一条交替回路，从而说明了至少存在两种不完全相同的完美匹配。

---
### 代码：
```cpp
#include<cstdio>
#include<cstring>
using namespace std;
const int MAXN=8000006;
int n,m,head[MAXN],nxt[MAXN],num[MAXN],x,y,tot,d[MAXN];
int del[MAXN],q[MAXN],l,r,T;
void add(int x,int y){
	nxt[++tot]=head[x];
	head[x]=tot;
	num[tot]=y;
}
void init(){
	memset(head,0,sizeof(head));
	memset(nxt,0,sizeof(nxt));
	memset(num,0,sizeof(num));
	memset(d,0,sizeof(d));
	memset(del,0,sizeof(del));
	memset(q,0,sizeof(q));
	l=r=tot=0;
}
void work(){
	init();
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		scanf("%d%d",&x,&y);y+=n;
		add(x,y);add(y,x);
		d[x]++;d[y]++;
	}
	n*=2;l=1;r=0;
	for(int i=1;i<=n;i++)
	if(d[i]==1)q[++r]=i;
	while(l<=r){
		if(del[q[l]]||d[q[l]]!=1){
			l++;
			continue;
		}
		int nu=0;
		for(int i=head[q[l]];i;i=nxt[i]){
			if(del[num[i]]==0){
				del[num[i]]=1;
				del[q[l]]=1;
				nu=num[i];
			}
		}
		for(int i=head[nu];i;i=nxt[i])
		if(del[num[i]]==0&&(--d[num[i]])==1)q[++r]=num[i];
		l++;
	}
	for(int i=1;i<=n;i++){
		if(del[i]!=1){
			printf("Merry\n");
			return;
		}
	}
	printf("Renko\n");
}
int main(){
	scanf("%d",&T);
	while(T--)work();
	return 0;
}
```


---

## 作者：WhisperingWillow (赞：2)

### 题目描述
给定 $2n$ 个点、$m$ 条边的二分图（可能有重边），左部点与右部点个数相同，判断其完美匹配数量是否恰好为 $1$，是则输出 Renko，否则输出 Merry。

注：完美匹配是指，从边集中选出 $n$ 条边，这些边的顶点组成的点集恰好覆盖了所有的 $2n$ 个点。
### 题目分析

用匈牙利算法解决：$O(nm)$ 

用 dinic 算法解决：$O(m\sqrt{n})$ 
 
 $m\leq10^6\times2$ 

 $n\leq10^6$ 
 

### 完美匹配的条件
看到这里大概能猜出题目意思了。

完美匹配唯一的情况：至少一个节点入度是 $1$。

关于证明楼上写得很明白了，这里主要讲怎么实现。

立马提交 ~~WA~~。

需要注意的是这只是一个必要非充分条件，也就是说满足题意所说的有且仅有一个解的情况一定会出现入度为 $1$ 的节点，但并不代表有入度为 $1$ 的节点的二分图就一定满足题意。


解题思路
------------

所以我们可以从拓扑排序的角度来解决，因为不断找入度为一的节点太耗时间了。

~~什么？你不知道拓扑排序？请看这里。~~[link](https://baike.baidu.com/item/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/5223807?fr=aladdin)

用人话来说：就是每次找入度为零的节点，找与之相邻的节点，删掉这条边，重复，最后到没有入度为 $0$ 的为止。

不过要注意的是，这里我们把节点入度是 $1$ 的入队。

若把图删没了，说明只有 $1$ 个完美匹配。否则代表不止 $1$ 个，或者没有。

### 代码区

时间复杂度 $O(n+m)$。

本蒟蒻丑陋代码：

```cpp
#include<bits/stdc++.h>
#define int long long//不建议使用 int->long long 用signed main() 
typedef long long ll; //推荐使用，很稳定 
using namespace std;
const int N = 2 * 1e6 + 10;
int du[N];
vector<int> G[N];//vector存图
bool del[N];
inline int read(){
	int f=1,x=0;//x=0!!!!!!!!! 
	int ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') {
		x=x*10+ch-'0';
		ch=getchar();
	}
	return f*x;
}//快读模板，比scanf()快五倍 
signed main(){
    int t=read(), cnt;
    while(t -- ) {
        cnt = 0;
        int n=read(),m=read();
        for (int i = 0; i < m; i ++ ) {
            int x=read(), y=read();
            G[x].push_back(y + n);
            G[y + n].push_back(x);
            du[x]++, du[y + n]++;
            //建边
        }
        queue<int> q;
        for (int i = 1; i <= 2 * n; i ++ ) {
            if(du[i] == 1)q.push(i);//找入度为一
        }
        while(q.size()) {//伪拓扑排序
            int u = q.front();
            q.pop();
            if(del[u]) continue;//同一点不能访问两次
            del[u] = 1;
            cnt ++;
            int id;
            for (int i = 0; i < (int)G[u].size(); i ++ ) {//找节点U中一个可以访问且没有被访问过的点 
                if(!del[G[u][i]]) {
                	id = G[u][i];
                	break;
                }//找到就退出  
            }   
            cnt ++;//删点个数+1 
            del[id] = 1;
            for (int i = 0; i < (int)G[id].size(); i ++ ) {
                //if(del[G[id][i]]) continue;
                if((-- du[G[id][i]])== 1) {//如果删一个点正好为一，则入队
                    q.push(G[id][i]);//没有真正删边，只是存了入度 
                }
            }
        }
        puts(n*2 == cnt ? "Renko" : "Merry");
        //如果正好删了2*n个点，符合题意。否则与题意不符
        for (int i = 1; i <= 2 * n; i ++ )du[i] = del[i] = 0, G[i].clear();//多侧不清空，爆零两行泪 
 
    } 
    return 0;
}
```

---

## 作者：zyn_ (赞：0)

我们希望找到一个二分图的唯一完美匹配。

注意到图中有环是很危险的。有引理：如果存在环 $a_1,b_1,a_2,b_2,\dots,a_k,b_k$，满足**存在**一个匹配使所有 $(a_i,b_i)$ 均为这个匹配中的边，那么将这些边换成 $(b_i,a_{i+1})$ 就得到第二个匹配，于是唯一性不满足。

考虑先确定一些匹配中必须包含的边。如果某个左部点的度数为 $0$ 那么无完美匹配。如果某个左部点的度数为 $1$，那么这唯一的边被确定存在于匹配中，于是递归到 $n-1$ 大小的问题。

如果所有左部点的度数都 $\ge 2$ 呢？考虑任取一个左部点 $b_1$，假设最终的匹配中有边 $(b_1,a_1)$，那么存在一个右部点 $a_2$，满足二分图中有边 $(b_1,a_2)$，但这条边不在匹配中。

如果 $a_2$ 的度数为 $1$，那么不存在完美匹配。否则，设最终 $(a_2,b_2)$ 在完美匹配中。类似地有 $a_3,b_3,a_4,b_4,\dots$，可以**无限地**写下去。

所以存在 $x<y$ 使 $a_x=a_y$。注意到所有 $a_i,b_i$ 以及 $b_i,a_{i+1}$ 之间都有边。这意味着 $a_x,b_x,a_{x+1},b_{x+1},\dots,a_{y-1},b_{y-1}$ 是一个环，且 $\forall x\le k\lt y$，$(a_k,b_k)$ 在完美匹配中。于是由引理完美匹配不唯一。

于是有如下算法：

1. 检查是否有左部点度数为 $0$，若有，输出 `Merry`，结束。
2. 检查是否有左部点度数为 $1$，若无，输出 `Merry`，结束。
3. 于是确定了一条边 $e$ 在完美匹配中。从图中删去 $e$ 的两个端点以及这两个端点引出的所有边。

容易维护。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 1000009
#define M 2000009
#define ll long long
#define INF 0x3f3f3f3f
int T,n,m,a,b,deg[N];
vector<int> v[N];
int x[N<<2],id[N<<2];ll sum[N];
void bd(int pl,int pr,int p){
    if(pl==pr){x[p]=deg[pl];id[p]=pl;return;}
    int mid=(pl+pr)>>1;
    bd(pl,mid,p<<1);bd(mid+1,pr,p<<1|1);
    if(x[p<<1]<x[p<<1|1])x[p]=x[p<<1],id[p]=id[p<<1];
    else x[p]=x[p<<1|1],id[p]=id[p<<1|1];
}
void upd(int t,int pl,int pr,int p){
    if(pl==pr){--x[p];if(x[p]==0)x[p]=INF;return;}
    int mid=(pl+pr)>>1;
    if(t<=mid)upd(t,pl,mid,p<<1);
    else upd(t,mid+1,pr,p<<1|1);
    if(x[p<<1]<x[p<<1|1])x[p]=x[p<<1],id[p]=id[p<<1];
    else x[p]=x[p<<1|1],id[p]=id[p<<1|1];
}
bool chk(){
    bd(1,n,1);
    for(int i=1;i<=n;++i){
        if(x[1]>1)return 0;
        int s=id[1],t=sum[s];
        for(int i:v[t])upd(i,1,n,1),sum[i]-=t;
    }
    return 1;
}
int main(){
    scanf("%d",&T);
    while(T--){
        scanf("%d%d",&n,&m);
        for(int i=1;i<=n;++i)deg[i]=sum[i]=0,v[i].clear();
        for(int i=1;i<=m;++i){
            scanf("%d%d",&a,&b);
            ++deg[a];sum[a]+=b;
            v[b].push_back(a);
        }
        puts(chk()?"Renko":"Merry");
    }
    return 0;
}
```

---

## 作者：lfxxx (赞：0)

首先判断整张图是否只有一组完美匹配太困难，我们先来考虑个简单的问题：一个点是否只有另一个点唯一能与其匹配。

考虑找出所有度数为 $1$ 的点，显然唯一能确定与其匹配的点，把两个点一起删掉，再看有没有新产生的一度点，有的话就重复这个过程，不难发现这一步可以拓扑排序来做，做完之后要么存在一个点度数为 $0$，这说明不存在完美匹配，要么所有点度数均大于等于 $2$。

所有点度数大于等于 $2$ 时，假若存在一组完美匹配，则一定可以从一个点出发，不断交替走匹配边与非匹配边，由于每个点至少有两个出边，所以可以一直重复这个过程直到回到一个走过的点，这时候我们找到一个由匹配边与非匹配边交替构成的环，将这个环上所有边的状态（是否为匹配边）翻转即可得到一组新的完美匹配。

这说明当第一步拓扑排序没有删完所有点时，要么不存在完美匹配，要么完美匹配不唯一，均不合法。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e6+114;
vector<int> E[maxn][2];
int vis[maxn][2];
int d[maxn][2];
int del;
int n,m;
void work(){
    for(int i=0;i<maxn;i++) E[i][0].clear(),E[i][1].clear(),vis[i][0]=vis[i][1]=0,d[i][0]=d[i][1]=0,del=0;
    cin>>n>>m;
    for(int i=1;i<=m;i++){
        int u,v;
        cin>>u>>v;
        d[u][0]++;
        d[v][1]++;
        E[u][0].push_back(v);
        E[v][1].push_back(u);
    }
    queue< pair<int,int> > q;
    for(int i=1;i<=n;i++){
        if(d[i][0]==1) q.push(make_pair(i,0));
        else if(d[i][0]==0){
            cout<<"Merry\n";
            return ;
        }
        if(d[i][1]==1) q.push(make_pair(i,1));
        else if(d[i][1]==0){
            cout<<"Merry\n";
            return ;
        }   
    }
    while(q.size()>0){
        pair<int,int> u=q.front();
        q.pop();
        if(vis[u.first][u.second]==1) continue;
        vis[u.first][u.second]=1,del++;
        for(int v:E[u.first][u.second]){
            if(vis[v][u.second^1]==1) continue;
            vis[v][u.second^1]=1,del++;
            for(int w:E[v][u.second^1]){
                d[w][u.second]--;
                if(d[w][u.second]==1&&vis[w][u.second]==0) q.push(make_pair(w,u.second));
            } 
        }
    }
    cout<<(del==2*n?"Renko\n":"Merry\n");
    return ;
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    int T;
    cin>>T;
    while(T--) work();
    return 0;
}
```

---

## 作者：lyhqwq (赞：0)

# Solution
好题。

考虑用找增广路的方式去找另一种匹配，显然如果我们可以找到一种左部点开始，左部点和右部点交替的环，那么就有至少两种匹配方式。

那么如果所有点的度数至少为 $2$，那么一定可以找到这样的一个环，所以存在度数为 $1$ 的点是合法的必要条件。

接下来用类似拓扑排序的方式判合法即可。

# Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e6+5;
int _;
int n,m;
int deg[N],vis[N];
vector<int> vec[N];
queue<int> q;
void solve(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=2*n;i++) vec[i].clear(),vis[i]=deg[i]=0;
	for(int i=1,u,v;i<=m;i++){
		scanf("%d%d",&u,&v);
		vec[u].push_back(v+n);
		vec[v+n].push_back(u);
		deg[u]++,deg[v+n]++;
	}
	for(int i=1;i<=2*n;i++){
		if(deg[i]==1) q.push(i),vis[i]=1;
		if(!deg[i]) return puts("Merry"),void();
	}
	while(!q.empty()){
		int u=q.front();
		q.pop();
		int p=0;
		for(int i=0;i<vec[u].size();i++){
			int v=vec[u][i];
			if(vis[v]) continue;
			p=v;
		}
		if(!p) continue;
		vis[p]=1;
		for(int i=0;i<vec[p].size();i++){
			int v=vec[p][i];
			if(vis[v]) continue;
			deg[v]--;
			if(deg[v]<=1) q.push(v),vis[v]=1;
		}
	}
	int cnt=0;
	for(int i=1;i<=2*n;i++) cnt+=vis[i];
	if(cnt==2*n) puts("Renko");
	else puts("Merry");
}
int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	scanf("%d",&_);
	while(_--) solve();
	return 0;
}

```

---

## 作者：快斗游鹿 (赞：0)

有趣的题目。

数据范围 $n\le 10^6,m\le 2\times 10^6$，因此二分图匹配相关算法的时间复杂度都无法接受。

观察性质，首先，如果出现一个点度数为 $0$，显然无解。而如果图中出现了一个长为 $2n$ 的，不经过重复点的环，则一定可以构造出两组不同的完美匹配，而每个点度数都大于 $1$ 是出现这种情况的必要条件，因此猜想结论与度数有关。

继续考察当所有点度数大于 $1$ 时会有什么情况，如果图中本身存在完美匹配，则必然可以找出一个环，使得环上左部点到右部点的边是这组完美匹配的一部分，此时通过反转环上边状态，即可构造出另一组完美匹配。而如果图中本身就不存在完美匹配，当然无解。因此此时一定不会存在恰好 $1$ 组完美匹配。

否则，度为 $1$ 的点所匹配的点显然唯一确定，可以直接模拟这个匹配过程，每次把必然匹配的一组点从图中删去，如果最后点删完了，就只有这么一组完美匹配，否则剩下没删去的点肯定是一个点度数都大于 $1$ 的子图，回到了前面一种情况。

---

## 作者：_fairytale_ (赞：0)

好妙的题。记一下。

## 结论
如果一个二分图中所有点的度数都 $\ge 2$，那么这张图要么没有完美匹配，要么完美匹配不唯一。

## 证明

没有完美匹配的情况是显然的，我们只考虑证明完美匹配不唯一。

首先我们随便找出原图的一组完美匹配，钦定左部点 $L_i$ 匹配右部点 $R_i$。

![](https://cdn.luogu.com.cn/upload/image_hosting/cgg1irjb.png)

然后我们删掉原图上的所有匹配边，将剩下的边 $L_i\to R_j$ 转化成有向图中的边 $i\to j$，那么在新图中每个点至少有一条出边，因此这个新图中必然存在一个环 $(u_1,u_2,\dots,u_k)$，对应了原图的这样一种结构：

![](https://cdn.luogu.com.cn/upload/image_hosting/325idek9.png)

且这个结构可以替换掉原来 $(L_{u_1},L_{u_2},\dots,L_{u_k})$ 与 $(R_{u_1},R_{u_2},\dots,R_{u_k})$ 之间的匹配。

因此完美匹配不止一种。

但是如果原图存在一度点，就不能适用这个结论，于是我们可以不断删掉一度点和它的相邻点，直到图被删完（此时完美匹配唯一）或者适用这个结论为止。

```cpp
#include<bits/stdc++.h>
#define re register
#define yon(x) (x?cout<<"Renko\n":cout<<"Merry\n")
#define rep(x,qwq,qaq) for(re int (x)=(qwq);(x)<=(qaq);++(x))
using namespace std;
#define maxn 1000100
int T;
int n,m;
int deg[maxn<<1];
int mat[maxn<<1];
vector<int>g[maxn<<1];
void toposort() {
	queue<int>q;
	rep(i,1,n+n)if(deg[i]==1)q.push(i);
	while(!q.empty()) {
		int u=q.front();
		q.pop();
		for(int v:g[u]) {
			if(mat[u]) {
				--deg[v];
				if(deg[v]==1&&(!mat[v]))q.push(v);
			} else if(!mat[v]) {
				mat[v]=u;
				mat[u]=v;
				--deg[v];
				q.push(v);
			}
		}
		if(!mat[u]) {
			yon(0);
			return;
		}
	}
	rep(i,1,n+n)if(!mat[i]) {
		yon(0);
		return;
	}
	yon(1);
}
int u,v;
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>T;
	while(T--) {
		cin>>n>>m;
		rep(i,1,n+n)g[i].clear(),deg[i]=mat[i]=0;
		rep(i,1,m) {
			cin>>u>>v;
			g[u].emplace_back(v+n);
			g[v+n].emplace_back(u);
			++deg[u],++deg[v+n];
		}
		toposort();
	}
	return 0;
}
```

---

## 作者：Benzenesir (赞：0)

首先，我们看一下如果直接跑 Dinic 的话，可能是是卡不过去的，但是可以过不少点。

我们这里来证明一个很强的结论，就是如果一个二分图有且仅有一个完美匹配，则其一定有一个点的度数为 1。

如果有一个点的度数小于 1，则其不联通，自然没有完美匹配。

如果所有的点的度数都大于一，则我们将完美匹配删去，发现如果用右部点向左部点连边，每个点的出度入度都不为 1，则原图中一定有一个环。

但是这并不意味着有一个点的度数为 1 就一定有唯一的完美匹配，这里发现，与度数为 1 的点相连的点的匹配一定是对面的点，我们可以把这两个点给删了。

这里就变成了一个归纳的问题了，判断剩下的图是不是也有一个点的度数为 1，重复以下操作就可以了。

---


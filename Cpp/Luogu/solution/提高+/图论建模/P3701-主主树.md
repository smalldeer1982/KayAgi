# 主主树

## 题目背景

byx 和诗乃酱都非常都非常喜欢种树。有一天，他们得到了两颗奇怪的树种，于是各自取了一颗回家种树，并约定几年后比一比谁种出来的树更加牛 X。

## 题目描述

很快，这棵树就开花结果了。byx 和诗乃酱惊讶的发现，这是一棵主主树，树上长满了主主和主主的朋友们。这棵树上一共有五种人，主主（$\verb!J!$），记记（$\verb!HK!$），高高（$\verb!W!$），王王（$\verb!E!$）和歪歪（$\verb!YYY!$）。他们发现，他们的主主树上的人数相同，都为 $N$。

 ![](https://cdn.luogu.com.cn/upload/image_hosting/0vklm8ow.png) 

研究发现，这五种人的输赢如上图所示（一样的人不能 PK），箭头指向输的人。至于为什么，留给同学们自己思考。

比赛如期进行。

byx 和诗乃酱要进行 $M$ 场比赛，每一场比赛他们会选出树上的两个人来比较看谁更牛 X。

第 $i$ 个人寿命为 $\text{Life}_i$ 秒，每次比完赛他们就会 $-1$s。当他们生命为 $0$s 时他们就不能再比赛了。

同时，当 $\verb!J!$ 的寿命为 $0$ 时，同一棵树上的 $\verb!YYY!$ 可以为他 $+1$s。每个 $\verb!YYY!$ 只能给每个 $\verb!J!$ 续一次。

那么问题来了：

现在给定 $N,M(1\le N\le 100,1\le M\le 1000)$，诗乃酱和 byx 每一个人所属种类（$\verb!J!,\verb!HK!,\verb!W!,\verb!YYY!$ 或 $\verb!E!$）以及每一个人的生命，生命不超过 $50$。请你算算 byx 最多能够赢得多少场比赛呢。

数据保证每一场一定都有人用。两个人之间只能比一场。

## 说明/提示

第一场主主赢记记，第二场高高赢王王，第三场歪歪赢记记。


## 样例 #1

### 输入

```
3 3
J W YYY
J HK E
2 2 2
2 2 2
```

### 输出

```
3
```

# 题解

## 作者：Mr_QwQ (赞：53)

说这题NOI+，其实（应该）也没有这么难。

对于每个人建一个点。

对于每个byx的人，从源点向人连边，容量为此人的寿命。

对于每个手气君的人，从人向汇点连边，容量为此人的寿命。

对于每个byx的人与手气君的人，如果byx能够用此人赢手气君，从byx的这个人向手气君的这个人连一条边，容量为1。

另：对于长者，他的生命要加上p，p为本方膜法师的人数，代表续命。

（深受膜蛤文化影响的我开始以为续命时自己要-1s……傻乎乎地从膜法师向长者连了条容量为1的边QAQ……）

最后跑裸的最大流即可。

代码就不需要贴了，毕竟写个网络流板子套上去就没了。


---

## 作者：Victorique (赞：20)

源于某些目的，写了这篇题解。

好了先说些废话，刚学OI（半年前？？），看到这题觉得十分高大上，有一种高山仰止的感觉。。然而刚刚想做做数据结构，又翻到这道题，仔细揣摩了一下题意，擦嘞，就是一个二乎乎的最大流。。

好了，照例还是要说说建图的，方法不难看出，如果读入正常一点的话，应该很容易可以发现，建立超级源和超级汇之后，把byx的人向源点连边（很套路~楼下貌似也说了~<-雾
）然后，把对面的向汇点连边，容量均为寿命。然后照着题里那张图把byx能打赢对面的连一条容量为1的边，然后，没有然后了！。

有一些要注意的地方还是要提一下的：

①这个题读入真TNN恶心，怎么处理？通过观察法，我们看出，如果用字符串储存所有人的类型的话，，，非常可行，而且——所有类型的第一个字母均不相同，都不用什么高级的判定方法。。。而且数据范围也很小，直接N^2连边就可以了。

②续命是个什么机制？？？ 通过膜法。。。我们可以知道一些神奇的事情，这里的续1s并不用给自己-1s。

③我的样例输出了4，但是我自己手推模拟了也是4啊，但是为啥是3？？  好好读题，有一个一共比m场。。就比了3场你哪来的4？？<-雾

放上代码给大家参考一下，蒟蒻码风不良请谅解
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<queue>
#define re register
#define inf 500000000
#define s1 b1[i].id[0]
#define s2 b2[j].id[0] 
using namespace std;
struct pe
{
	int hp;
	string id;
};
pe b1[101],b2[101];
struct po
{
	int to,nxt,w;
}edge[300001];
int head[20001],cur[200001],num=-1,n,m,t,x,y,s,l,tot,sum,xu1,xu2,dep[20001];
inline int read()
{
	int x=0,c=1;
	char ch=' ';
	while((ch>'9'||ch<'0')&&ch!='-')ch=getchar();
	while(ch=='-')c*=-1,ch=getchar();
	while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();
	return x*c;
}
inline void add_edge(int from,int to,int w)
{
	edge[++num].nxt=head[from];
	edge[num].to=to;
	edge[num].w=w;
	head[from]=num;
}
inline void add(int from,int to ,int w)
{
	add_edge(from,to,w);
	add_edge(to,from,0);
}
inline bool bfs()
{
	memset(dep,0,sizeof(dep));
	queue<int> q;
	while(!q.empty())
	q.pop();
	dep[s]=1;
	q.push(s);
	while(!q.empty()){
		int u=q.front();
		q.pop();
		for(re int i=head[u];i!=-1;i=edge[i].nxt)
		{
			int v=edge[i].to;
			if(edge[i].w>0&&dep[v]==0)
			{
				dep[v]=dep[u]+1;
				if(v==t)
				return 1;
				q.push(v);
			}
		}
	}
	return 0;
}
inline int dfs(int u,int dis)
{
	if(u==t)
	return dis;
	int diss=0;
	for(re int& i=cur[u];i!=-1;i=edge[i].nxt)
	{
		int v=edge[i].to;
		if(edge[i].w!=0&&dep[v]==dep[u]+1)
		{
			int check=dfs(v,min(dis,edge[i].w));
			if(check)
			{
				diss+=check;
				dis-=check;
				edge[i].w-=check;
				edge[i^1].w+=check;
				if(dis==0) break;
			}
		}
	}
	return diss;
}
inline int dinic()
{
	int ans=0;
	while(bfs())
	{
		for(re int i=s;i<=t;i++)
		cur[i]=head[i];
		while(int d=dfs(s,inf))
		ans+=d;
	}
	return ans;
}
inline int pd1(int x)
{
	if(b1[x].id[0]=='J')
	return xu1; else
	return 0;
}
inline int pd2(int x)
{
	if(b2[x].id[0]=='J')
	return xu2; else
	return 0;
}
int main()
{
	memset(head,-1,sizeof(head));
	n=read();m=read();
	for(re int i=1;i<=n;i++)
		cin>>b1[i].id;
	for(re int i=1;i<=n;i++)
		cin>>b2[i].id;
	for(re int i=1;i<=n;i++)
		cin>>b1[i].hp;
	for(re int i=1;i<=n;i++)
		cin>>b2[i].hp;
	for(re int i=1;i<=n;i++){
		if(b1[i].id[0]=='Y')
			xu1++;
		if(b2[i].id[0]=='Y')
			xu2++;
	}
	s=0;t=2*n+1;
	for(re int i=1;i<=n;i++){
		for(re int j=1;j<=n;j++){
			if(s1=='J'&&(s2=='H'||s2=='W'))
			add(i,j+n,1);
			if(s1=='E'&&(s2=='J'||s2=='Y'))
			add(i,j+n,1);
			if(s1=='Y'&&(s2=='J'||s2=='H'))
			add(i,j+n,1);
			if(s1=='H'&&(s2=='E'||s2=='W'))
			add(i,j+n,1);
			if(s1=='W'&&(s2=='Y'||s2=='E'))
			add(i,j+n,1);
		}
	}
	for(re int i=1;i<=n;i++)
		add(s,i,b1[i].hp+pd1(i)),add(i+n,t,b2[i].hp+pd2(i));
	cout<<min(dinic(),m);
}
```

---

## 作者：钱逸凡 (赞：8)

~~这题感觉完全没有黑题的难度啊，毕竟连我都会做~~

# 思路：~~很明显的~~最大流

[如果不会最大流](https://www.luogu.org/blog/ONE-PIECE/wang-lao-liu-di-zong-jie)

为什么会想到最大流呢？

### 其实题目里到处都在暗示要用最大流

比如说：

两个人之间只能比一场。--->连一条容量为1的边

每次比完赛他们就会-1s。当他们生命为0s时他们就不能再比赛了。-->每条增广路流1，容量减1，边的容量满了就不能流了

最多能够赢得多少场比赛--->最大流是多少

## 看吧，到处都在暗示用最大流

# 接下来我们讲建图：

## 定义点：

byx和手气君每个人都对应一个点

还要一个s（源点），一个t（汇点），一个tt（假装是汇点，后面要加tt指向t的边来限制场数）

## 加边:

1.s流向byx每个人的边，容量为人的寿命（如果是J就加上YYY的数量）

2.手气君每个人流向tt的边，容量为人的寿命（J要加YYY的数量）

3.按克制关系加边，byx的人流向手气君的人（注意：每个被克的人都要加，例：byx的每个J要对应手气君每个HK和每个W），容量为1

4.tt流向t的边，容量为m（最多比m场）

## 更直观的理解：

样例建好图后是这样的：
![](https://cdn.luogu.com.cn/upload/pic/32097.png)

## 然后跑最大流就完了，由于图很稠密，推荐Dinic

[如果不会Dinci](https://www.luogu.org/blog/ONE-PIECE/wang-lao-liu-jiang-xie-zhi-dinic)

代码略丑:

```
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<queue>
#include<vector>
using namespace std;
const int inf=1<<30;
int a[101][2];//分别装byx和手气君的人，1表示J，2表示HK，3表示W，4表示YYY，5表示E
int b[101][2];//装寿命 
inline void REad(int i,int f){
    char c=getchar();
    string st="";
    while(c>'Z'||c<'A')c=getchar();
    while(c>='A'&&c<='Z')st=st+c,c=getchar();
    if(st=="J")a[i][f]=1;
    else if(st=="HK")a[i][f]=2;
    else if(st=="W")a[i][f]=3;
    else if(st=="YYY")a[i][f]=4;
    else if(st=="E")a[i][f]=5;
}//f==0表示byx，f==1表示手气君 
inline int Read(){
    int x=0;
    char c=getchar();
    while(c>'9'||c<'0')c=getchar();
    while(c>='0'&&c<='9')x=x*10+c-'0',c=getchar();
    return x;
}
int head[10101],cur[10101],top=1;
int n,m,s,t,tt;
struct Node{
    int v;
    int val;
    int next;
}node[101010];
inline void addedge(int u,int v,int val){
    node[++top].v=v;
    node[top].val=val;
    node[top].next=head[u];
    head[u]=top;
}
inline void add(int u,int v,int val){
    addedge(u,v,val);
    addedge(v,u,0);
}
int dep[10101],inque[10101];
bool spfa(){
    for(register int i=1;i<=t;i++){
        dep[i]=inf;
        inque[i]=0;
        cur[i]=head[i];
    }
    queue<int>q;
    q.push(s);
    dep[s]=0;
    while(!q.empty()){
        int u=q.front();
        q.pop();
        inque[u]=0;
        for(int i=head[u];i;i=node[i].next){
            int d=node[i].v;
            if(node[i].val&&dep[d]>dep[u]+1){
                dep[d]=dep[u]+1;
                if(inque[d]==0){
                    q.push(d);
                    inque[d]=1;
                }
            }
        }
    }
    return dep[t]!=inf;
}
int maxflow,vis;
int dfs(int u,int flow){
    if(u==t){
        vis=1;
        maxflow+=flow;
        return flow;
    }
    int used=0;
    for(int i=cur[u];i;i=node[i].next){
        cur[u]=i;
        int d=node[i].v;
        if(dep[d]==dep[u]+1&&node[i].val){
        int low=dfs(d,min(node[i].val,flow-used));
        if(low!=0)used+=low,node[i].val-=low,node[i^1].val+=low;
        }
        if(used==flow)break;
    }
    return used;
}
int Dinic(){
    maxflow=0;
    while(spfa()){
        vis=1;
        while(vis)vis=0,dfs(s,inf);
    }
    return maxflow;
}
vector<int>J,HK,W,YYY,E;
void k(int i,vector<int> a){
	int sz=a.size();
	for(int j=0;j<sz;j++)add(i,n+a[j],1);//两个人之间只能比一场 
}
void ad(int i){
	if(a[i][0]==4||a[i][0]==5)k(i,J);
	if(a[i][0]==1||a[i][0]==4)k(i,HK);
	if(a[i][0]==1||a[i][0]==2)k(i,W);
	if(a[i][0]==3||a[i][0]==5)k(i,YYY);
	if(a[i][0]==2||a[i][0]==3)k(i,E);
}//按照克制关系给i点加边 
int main(){
    n=Read(),m=Read();
    register int i;
    int cnt1,cnt2;//两人YYY的数量 
    cnt1=cnt2=0;
    s=2*n+1,tt=2*n+2,t=2*n+3;
    add(tt,t,m);//最多比m场 
    for(i=1;i<=n;i++){
    REad(i,0);
    if(a[i][0]==4)cnt1++;   
    }
    for(i=1;i<=n;i++){
    REad(i,1);
    if(a[i][1]==4)cnt2++;
    if(a[i][1]==1)J.push_back(i);
    else if(a[i][1]==2)HK.push_back(i);
    else if(a[i][1]==3)W.push_back(i);
    else if(a[i][1]==4)YYY.push_back(i);
    else if(a[i][1]==5)E.push_back(i);
    }
    for(i=1;i<=n;i++)b[i][0]=Read();
    for(i=1;i<=n;i++)b[i][1]=Read();
    int now;
    for(i=1;i<=n;i++){
    now=i;
    if(a[i][0]==1)add(s,now,b[i][0]+cnt1);//YYY只能给J加命 
    else add(s,now,b[i][0]);
    ad(i);
    }
    for(i=1;i<=n;i++){
    now=i+n;
    if(a[i][1]==1)add(now,tt,b[i][1]+cnt2);
    else add(now,tt,b[i][1]);
    }
    printf("%d",Dinic());
    return 0;
}
```

---

## 作者：gesong1234 (赞：7)

题目传送门：[P3701 主主树](https://www.luogu.com.cn/problem/P3701)。
# 思路
这道题一看就是用**网络最大流**来求解。

接下来我们考虑如何建图。

1. 建立一个超级源点 $S$，$S$ 向 byx 的每个人连接流量为人物寿命的边。
2. 建立一个超级汇点 $T$，诗乃酱的每个人向 $T$ 连接流量为人物寿命的边。
3. 根据题目中的关系，如果 byx 的第 $i$ 个人，可以打败诗乃酱的第 $j$ 个人，那么 $i$ 和 $j$ 连一条，流量为 $1$ 的边。

注意：由于题目中说，当 J 的寿命为 $0$ 时，同一棵树上的 YYY 可以为他增加 $1$ 秒的寿命，因此 J 的寿命是本身寿命加上 YYY 个数。

最后我们的答案就为 $\min(\text{最大流},m)$，因为最多比赛 $m$ 场。
# 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int h[1234567],e[1234567],f[1234567],nx[1234567],cur[1234567],d[1234567],cnt,s,t,n,m;
pair<string,int> bb[1234567],ss[1234567];
#define a first
#define b second
void add(int u,int v,int w){
	e[cnt]=v,f[cnt]=w,nx[cnt]=h[u],h[u]=cnt++;
	e[cnt]=u,f[cnt]=0,nx[cnt]=h[v],h[v]=cnt++;
}
bool bfs(){
	for (int i=0;i<=t;i++) d[i]=-1;
	d[s]=0;
	cur[s]=h[s];
	queue<int>q;
	q.push(s);
	while(!q.empty()){
		int u=q.front();
		q.pop();
		for (int i=h[u];~i;i=nx[i]){
			int v=e[i],w=f[i];
			if (d[v]==-1&&w){
				d[v]=d[u]+1;
				cur[v]=h[v];
				if (v==t) return 1;
				q.push(v);
			}
		}
	}
	return 0;
}
int find(int u,int limit){
	if (u==t) return limit;
	int flow=0;
	for (int i=cur[u];~i&&flow<limit;i=nx[i]){
		int v=e[i],w=f[i];
		cur[u]=i;
		if (d[v]==d[u]+1&&w){
			int x=find(v,min(w,limit-flow));
			if (!x) d[v]=-1;
			flow+=x;
			f[i]-=x;
			f[i^1]+=x;
		}
	}
	return flow;
}
int dinic(){
	int r=0,flow;
	while(bfs())
		while(flow=find(s,1e9)) r+=flow;
	return r;
}
int check(string x,string y,int i,int j){
	if (x=="YYY"&&y=="HK") add(i,j+n,1);
	if (x=="YYY"&&y=="J") add(i,j+n,1);
	if (x=="E"&&y=="YYY") add(i,j+n,1);
	if (x=="E"&&y=="J") add(i,j+n,1);
	if (x=="J"&&y=="HK") add(i,j+n,1);
	if (x=="J"&&y=="W") add(i,j+n,1);
	if (x=="W"&&y=="YYY") add(i,j+n,1);
	if (x=="W"&&y=="E") add(i,j+n,1);
	if (x=="HK"&&y=="W") add(i,j+n,1);
	if (x=="HK"&&y=="E") add(i,j+n,1);
}
main(){
	cin>>n>>m;
	int cntb=0,cnts=0;
	for (int i=1;i<=n;i++){
		cin>>bb[i].a;
		if (bb[i].a=="YYY") cntb++;
	} 
	for (int i=1;i<=n;i++){
		cin>>ss[i].a;
		if (ss[i].a=="YYY") cnts++;
	} 
	for (int i=1;i<=n;i++){
		cin>>bb[i].b;
		if (bb[i].a=="J") bb[i].b+=cntb;
	}
	for (int i=1;i<=n;i++){
		cin>>ss[i].b;
		if (ss[i].a=="J") ss[i].b+=cnts;
	}
	s=0,t=n+n+1;
	for (int i=0;i<=t;i++) h[i]=-1;
	for (int i=1;i<=n;i++) add(s,i,bb[i].b),add(i+n,t,ss[i].b);
	for (int i=1;i<=n;i++)
		for (int j=1;j<=n;j++)
			check(bb[i].a,ss[j].a,i,j);
	cout <<min(dinic(),m);
    return 0;
}
```

---

## 作者：VenusM1nT (赞：3)

可惜不是在0**7那一天做到这题

【毕竟那个时候还不会网络流5555】

本来看到题目没想到是网络流，但是楼上dalao的题解说“题目里到处都在暗示网络流”，于是翻回去一看……

`箭头指向输的人。至于为什么，留给同学们自己思考。`

好嘛，这已经是明示网络流了……

于是来建模吧~

设立超级源点$S$为0，代表$byx$，设立超级汇点$T$为$n*2+1$，代表手气君

首先分别计算两人手中膜法师的个数$sum$，并给两人的主席加上相应的生命

（但是我对膜蛤文化了解甚少啊，为什么各位dalao说要-1s啊233）

对于$byx$的每个人，从$byx$连向这个人，容量为该人的生命，代表这个人只能被$byx$使用**生命**次

对于**手气君**的每个人，从这个人连向**手气君**，容量也为该人的生命，代表这个人只能被**手气君**使用**生命**次

然后枚举$byx$和**手气君**的每个人，如果$byx$能赢**手气君**，那么就从$byx$的人连向**手气君**的人，边权为$1$，代表$byx$的这个人能够带来$1$的贡献（就是多流$1$的水，感性理解一下）

然后跑一遍$Dinic$即可

不过要注意的是，游戏最多进行$m$场，所以当答案大于$m$时，要输出$m$，而不是$ans$

见代码

```cpp
#include<bits/stdc++.h>
#define inf 1010580540
using namespace std;
queue <int> q;
int cnt=1,fst[305],nxt[200005],to[200005],w[200005],cur[305];
int n,m,S,T,dep[305],a[105],b[105],amo,bmo;
string as[105],bs[105];
void AddEdge(int u,int v,int c)
{
	to[++cnt]=v;
	nxt[cnt]=fst[u];
	fst[u]=cnt;
	w[cnt]=c;
}
bool Bfs()
{
	memset(dep,0,sizeof(dep));
	q.push(S);
	dep[S]=1;
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		for(int i=fst[u];i;i=nxt[i])
		{
			int v=to[i];
			if(!dep[v] && w[i])
			{
				dep[v]=dep[u]+1;
				q.push(v);
			}
		}
	}
	return dep[T];
}
int Dfs(int u,int flow)
{
	if(u==T || !flow) return flow;
	int used=0;
	for(int i=cur[u];i;i=nxt[i])
	{
		cur[u]=i;
		int v=to[i];
		if(dep[v]==dep[u]+1 && w[i])
		{
			int fl=Dfs(v,min(flow,w[i]));
			if(fl)
			{
				used+=fl;
				flow-=fl;
				w[i]-=fl;
				w[i^1]+=fl;
				if(!flow) break;
			}
		}
	}
	return used;
}
int Dinic()//弧优化Dinic，不谈
{
	int sum=0;
	while(Bfs())
	{
		memcpy(cur,fst,sizeof(fst));
		sum+=Dfs(S,inf);
	}
	return sum;
}
int main()
{
	scanf("%d %d",&n,&m);
	S=0;
	T=n*2+1;//建立超级源点和汇点
	for(int i=1;i<=n;i++)
	{
		cin >> as[i];
		if(as[i]=="YYY") amo++;//计算byx的膜法师个数
	}
	for(int i=1;i<=n;i++)
	{
		cin >> bs[i];
		if(bs[i]=="YYY") bmo++;//计算手气君的膜法师个数
	}
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		if(as[i]=="J") a[i]+=amo;//给byx的主席加上生命
	}
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&b[i]);
		if(bs[i]=="J") b[i]+=bmo;//给手气君的主席加上生命
	}
	for(int i=1;i<=n;i++)
	{
		AddEdge(S,i,a[i]);
		AddEdge(i,S,0);//从byx的人向byx连边，代表使用次数
	}
	for(int i=n+1;i<=n*2;i++)
	{
		AddEdge(i,T,b[i-n]);
		AddEdge(T,i,0);//从手气君的牌向手气君连边，代表使用次数
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			if(as[i]=="J" && (bs[j]=="W" || bs[j]=="HK"))
			{
				AddEdge(i,j+n,1);
				AddEdge(j+n,i,0);
			}
			else if(as[i]=="E" && (bs[j]=="J" || bs[j]=="YYY"))
			{
				AddEdge(i,j+n,1);
				AddEdge(j+n,i,0);
			}
			else if(as[i]=="YYY" && (bs[j]=="J" || bs[j]=="HK"))
			{
				AddEdge(i,j+n,1);
				AddEdge(j+n,i,0);
			}
			else if(as[i]=="HK" && (bs[j]=="W" || bs[j]=="E"))
			{
				AddEdge(i,j+n,1);
				AddEdge(j+n,i,0);
			}
			else if(as[i]=="W" && (bs[j]=="YYY" || bs[j]=="E"))
			{
				AddEdge(i,j+n,1);
				AddEdge(j+n,i,0);
			}//如果能赢就分别连边，代表对答案贡献为1
		}
	}
	int ans=Dinic();//跑Dinic求解
	printf("%d\n",ans>m?m:ans);//判断是否大于m
	return 0;
}
```

---

## 作者：splendore (赞：3)

## 思路

看题可得出这道题是最大流，于是开始思考如何构图 。

先建立源点 $S$ 和汇点 $T$。

将每个byx的人与源点连一条容量为寿命的边。

再将每个诗乃酱的人与汇点连一条边，容量也为寿命。

对于每个魔法师 $(?)$ 直接给其对应的主人增加 $1s$ 的寿命。

如果 $byx$ 的一个人可以赢诗乃酱的一个人，那么连上一条容量为 $1$ 的边。

最好提前把各个人的相互比赛的输赢情况~~打表~~预处理。

接着就可以愉快的套板子了。

## Code
```cpp
#include<stdio.h>
#include<string.h>
#include<queue>
const int inf=0x3f3f3f3f,N=1005,M=10005;
bool g[6][6]={
{0,0,0,0,0,0},
{0,0,1,1,0,0},
{0,0,0,0,1,1},
{0,0,1,0,0,1},
{0,1,0,1,0,0},
{0,1,0,0,1,0}};
struct edge{int x,y,c,pre,other;}a[M];int len,last[N],h[N],st,ed,A[N],B[N];
void ins(int x,int y,int c){
	a[++len]=edge{x,y,c,last[x],len+1};last[x]=len;
	a[++len]=edge{y,x,0,last[y],len-1};last[y]=len;
}
int read(){
	int x=0;char c=getchar();
	while(c<'0'||c>'9')c=getchar();
	while(c>='0'&&c<='9')x=(x<<1)+(x<<3)+(c^48),c=getchar();
	return x;
}
bool bh(){
	memset(h,0,sizeof(h));h[st]=1;
	std::queue<int>q;q.push(st);
	while(!q.empty()){
		int x=q.front();
		for(int k=last[x];k;k=a[k].pre){
			int y=a[k].y;
			if(h[y]==0&&a[k].c>0){
				h[y]=h[x]+1;
				q.push(y);
			}
		}
		q.pop();
	}
	return h[ed]>0;
}
inline int min(int x,int y){return x<y?x:y;}
int findflow(int x,int f){
	if(x==ed)return f;
	int sx=0;
	for(int k=last[x];k;k=a[k].pre){
		int y=a[k].y;
		if(a[k].c>0&&sx<f&&h[y]==h[x]+1){
			int sy=findflow(y,min(a[k].c,f-sx));
			a[k].c-=sy;a[a[k].other].c+=sy;
			sx+=sy;
		}
	}
	if(sx==0)h[x]=0;
	return sx;
}
int main(){
	int n=read(),m=read(),hpA=0,hpB=0;
	char str[5];st=n<<1|1;ed=st+1;
	for(int i=1;i<=n;++i){
		scanf("%s",str);
		if(str[0]=='J')A[i]=1;
		else if(str[0]=='W')A[i]=2;
		else if(str[0]=='H')A[i]=3;
		else if(str[0]=='Y')A[i]=4,++hpA;
		else A[i]=5;
	}
	for(int i=1;i<=n;++i){
		scanf("%s",str);
		if(str[0]=='J')B[i]=1;
		else if(str[0]=='W')B[i]=2;
		else if(str[0]=='H')B[i]=3;
		else if(str[0]=='Y')B[i]=4,++hpB;
		else B[i]=5;
	}
	for(int i=1;i<=n;++i)
		for(int j=1;j<=n;++j)
			if(g[A[i]][B[j]])
				ins(i,n+j,1);
	for(int i=1;i<=n;++i){
		int x=read();
		if(A[i]==1)x+=hpA;
		ins(st,i,x);
	}
	for(int i=1;i<=n;++i){
		int x=read();
		if(B[i]==1)x+=hpB;
		ins(n+i,ed,x);
	}
	int s=0;while(bh())s+=findflow(st,inf);
	printf("%d\n",min(m,s));
}
```

---

## 作者：望眼浮云 (赞：3)

### 不要受膜文化影响！！！

膜法师给主席续命不扣血！！！

我一个同学就在这上面卡了好久

~~其实这题没到黑题难度~~，因为主席和膜法所以刷上去的？

不扯了，开始解题，建图后跑网络流，建图如下：

1.超级源点byx的每个人连边，权值为生命

2.手气君的每个人向超级汇点连边，权值为生命

3.byx的每个人向能战胜的人连边，权值为1,因为每两个人之间只能战斗一次

另外，关于膜法师给主席加血，直接算出膜法师的数量p,给每个主席加上就好了，两边都要加。有些同学可能会以为膜法师死了就不能给主席加血了，这个不用管的，放心加。

还有ans和m要取min，因为只打m场，但是最大流可能大于m

```cpp
#include<bits/stdc++.h>
using namespace std;
const int inf=1e9;
int n,m,x,y,z,s,t,ans,d[10005];
struct node{
	int next,to,w;
}a[500000];
int cnt=1,head[10005],cur[10005];
int hp1[10000],hp2[10000];
char s1[10000],s2[10000],b1[10000],b2[10000]; 
queue <int> q;
void add(int x,int y,int dis)
{
	a[++cnt].next=head[x];
	a[cnt].to=y;
	a[cnt].w=dis;
	head[x]=cnt;
}
bool bfs(int s,int t)
{
	memset(d,0x7f,sizeof(d));
	while(!q.empty()) q.pop();
	for(int i=0;i<=t;i++) cur[i]=head[i];
	d[s]=0;
	q.push(s);
	while(!q.empty())
	{
		int u=q.front();q.pop();
		for(int i=head[u];i;i=a[i].next)
		{
			int v=a[i].to;
			if(d[v]>inf&&a[i].w)
			{
				d[v]=d[u]+1;
				q.push(v);
			}
		}
	}
	if(d[t]<inf) return true;
	else return false;
}
int dfs(int now,int t,int limit)
{
	if(!limit||now==t) return limit;
	int flow=0,f;
	for(int i=cur[now];i;i=a[i].next)
	{
		cur[now]=i;
		int v=a[i].to;
		if(d[v]==d[now]+1&&(f=dfs(v,t,min(limit,a[i].w))))
		{
			flow+=f;
			limit-=f;
			a[i].w-=f;
			a[i^1].w+=f;
			if(!limit) break;
		}
	}
	return flow;
}
void insert(int x,int y,int z)
{add(x,y,z);add(y,x,0);}
void build()  //建图
{
    int i,j;
    s=0;t=2*n+1;
    for(i=1;i<=n;i++) insert(0,i,hp1[i]); //超级源点byx的每个人连边，权值为生命
    for(i=1;i<=n;i++) insert(i+n,t,hp2[i]); //手气君的每个人向超级汇点连边，权值为生命
    for(i=1;i<=n;i++)
    {
        for(j=1;j<=n;j++)  //byx的每个人向能战胜的人连边，权值为1
        {
            if(b1[i]=='J'&&(b2[j]=='W'||b2[j]=='H')) insert(i,j+n,1);  
            if(b1[i]=='W'&&(b2[j]=='Y'||b2[j]=='E')) insert(i,j+n,1);
            if(b1[i]=='H'&&(b2[j]=='W'||b2[j]=='E')) insert(i,j+n,1);
            if(b1[i]=='E'&&(b2[j]=='Y'||b2[j]=='J')) insert(i,j+n,1);
            if(b1[i]=='Y'&&(b2[j]=='H'||b2[j]=='J')) insert(i,j+n,1);
        }
    }
}
void scan() //输入
{
     int i,p1=0,p2=0;
    for(i=1;i<=n;i++)
    {
        cin>>s1;        
        b1[i]=s1[0];    //用b1存首字母就好了，因为不同类的人首字母不同
        if(s1[0]=='Y') p1++;  //统计膜法师数量，下同
    }
    for(i=1;i<=n;i++)
    {
        cin>>s2;
        b2[i]=s2[0];
        if(s2[0]=='Y') p2++;
    }
    for(i=1;i<=n;i++)
    {
        cin>>hp1[i];   
        if(b1[i]=='J') hp1[i]+=p1; //给主席加血，下同
    }
    for(i=1;i<=n;i++)
    {
        cin>>hp2[i];
        if(b2[i]=='J') hp2[i]+=p2;
    }
}
int main()
{
	scanf("%d %d",&n,&m);
	scan();
	build();
	while(bfs(s,t)) ans+=dfs(s,t,inf); //模板网络流
	printf("%d\n",min(ans,m));         //ans和m取min，因为只打m场，但是最大流可能大于m
	return 0;
}
```

---

## 作者：liangbowen (赞：3)

## 前言

[题目传送门！](https://www.luogu.com.cn/problem/P3701)

[更好的阅读体验？](https://www.cnblogs.com/liangbowen/p/17022736.html)

比较简单的最大流基础建图题。

如果认为思路部分过于复杂，可以直接看图。![](//图.tk/3)

## 思路

以下为了方便，我们把 byx 称作 A，把诗乃酱称作 B。

首先发现，人物的唯一限制就是寿命。我们直接以此来建网络即可。

注意到有一个特殊的限制：

> 当 J 的寿命为 $0$ 时，同一棵树上的 YYY 可以为他延长一秒的寿命。

这说明，YYY 的寿命**可能不是他的初始寿命**。我们可以记录一下双方各有几个 J。

假设 A 有 $cnt$ 个 J，那么 YYY 的寿命就是 $w + cnt$。B 方同理。

那么我们现在得到了所有人真实的寿命，所以：

+ 从源点向每个 A 的人连边，流量是人物的寿命。
+ 从每个 B 的人向汇点连边，流量是人物的寿命。

---

人物与人物之间有克制关系，我们以此为依据建立 A 与 B 人物之间的网络。

这个就简单了：如果 $a_i$ 克制 $b_j$，建立 $i \to j$ 的流量为 $1$ 的边即可，此处的 $1$ 的意义是，获胜的比赛数量。

然后再上一个 Dinic 板子即可。

**注意，最后的答案要与 $m$ 取一个 $\min$！**

## 建图

有一说一，看一眼这个图就懂了啊。

![](https://cdn.luogu.com.cn/upload/image_hosting/08x5121z.png)

## 代码

```cpp
#include <iostream>
#include <cstdio>
#include <queue>
#include <cstring>
using namespace std;
const int N = 205;
struct Edge {int now, nxt, w;} e[N * 2 + N * N];
int head[N], _head[N], cur = 1;
void add(int u, int v, int w)
{
    e[++cur].now = v, e[cur].nxt = head[u], e[cur].w = w;
    head[u] = cur;
}
void ADD(int u, int v, int w) {add(u, v, w), add(v, u, 0);}
int s, t;
bool vis[N]; int dis[N];
bool bfs()
{
    queue <int> q;
    memset(vis, false, sizeof vis);
    q.push(s), vis[s] = true, dis[s] = 0, _head[s] = head[s];
    while (!q.empty())
    {
        int u = q.front(); q.pop();
        for (int i = head[u]; i; i = e[i].nxt)
        {
            int v = e[i].now;
            if (vis[v] || !e[i].w) continue;
            vis[v] = true, dis[v] = dis[u] + 1, _head[v] = head[v];
            if (v == t) return true;
            q.push(v);
        }
    }
    return false;
}
int dfs(int u, int maxflow)
{
    if (u == t) return maxflow;
    int flow = 0;
    for (int i = _head[u]; i && flow < maxflow; i = e[i].nxt)
    {
        _head[u] = i;
        int v = e[i].now;
        if (dis[v] != dis[u] + 1 || !e[i].w) continue;
        int ww = dfs(v, min(maxflow - flow, e[i].w));
        if (ww == 0) dis[v] = -114514;
        e[i].w -= ww, e[i ^ 1].w += ww, flow += ww;
    }
    return flow;
}
int dinic()
{
    int ans = 0, flow;
    while (bfs())
        while (flow = dfs(s, 2147483647))
            ans += flow;
    return ans;
}

const bool dict[5][5] = { //克制关系
    0, 1, 1, 0, 0,
    0, 0, 1, 1, 0, 
    0, 0, 0, 1, 1, 
    1, 0, 0, 0, 1, 
    1, 1, 0, 0, 0
};
int read() //为了方便把人物转化为数字
{
    string s;
    cin >> s;
    if (s == "J") return 0;
    if (s == "HK") return 1;
    if (s == "W") return 2;
    if (s == "E") return 3;
    if (s == "YYY") return 4;
}
int a[N], b[N];

int main()
{
    ios::sync_with_stdio(false);
    int n, m, cnta = 0, cntb = 0;
    cin >> n >> m;
    s = 0, t = 2 * n + 1;
    for (int i = 1; i <= n; i++)
    {
        a[i] = read();
        if (a[i] == 4) cnta++; //统计YYY的个数
    }
    for (int i = 1; i <= n; i++)
    {
        b[i] = read();
        if (b[i] == 4) cntb++; //统计YYY的个数
    }
    for (int i = 1; i <= n; i++)
    {
        int w;
        cin >> w;
        if (a[i] == 0) w += cnta; //每一个YYY都可以给J续命
        ADD(s, i, w);
    }
    for (int i = 1; i <= n; i++)
    {
        int w;
        cin >> w;
        if (b[i] == 0) w += cntb; //每一个YYY都可以给J续命
        ADD(i + n, t, w);
    }    
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            if (dict[a[i]][b[j]]) //根据克制关系建边
                ADD(i, j + n, 1);
    cout << min(dinic(), m);
    return 0;
}
```

希望能帮助到大家！

---

## 作者：Capella (赞：2)

建模的方法，楼上说得很清楚啦。

我就是来一波指针邻接表的写法。

要注意一点，指针邻接表存图，反向边不能通过数组下标来访问qwq。

要在边的结构体中手动记录反向边指针。

（个人认为，这样比什么 `i^1` 或者 `((i-1)^1)+1` 这种蛇皮操作方便多了qwq！）

目前见过的指针邻接表选手不是很多呀。

思路上没什么，希望能给指针邻接表选手提供借鉴吧qwq。

[那个…广告什么的…欢迎访问我的博客qwq。](https://www.cnblogs.com/Capella/p/9069178.html)
```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <queue>
using std::min;
using std::queue;
const int MAXN=210,INF=0x3f3f3f3f;
int n,m,S,T,win[5][5]={	{0	,1	,1	,-1	,-1	},
						{-1	,0	,1	,1	,-1	},
						{-1	,-1	,0	,1	,1	},
						{1	,-1	,-1	,0	,1	},
						{1	,1	,-1	,-1	,0	}};
struct Edge
{
	int to,w;
	Edge *nxt,*back;
	Edge(int to=0,int w=0,Edge* nxt=nullptr):to(to),w(w),nxt(nxt),back(nullptr){}
	~Edge(void)
	{
		if(nxt!=nullptr)
			delete nxt;
	}
}*head[MAXN];
void AddEdges(int u,int v,int w)
{
	head[u]=new Edge(v,w,head[u]);
	head[v]=new Edge(u,0,head[v]);
	head[u]->back=head[v];
	head[v]->back=head[u];
}
int Number(char *s)
{
	if(s[0]=='J')
		return 0;
	else if(s[0]=='H')
		return 1;
	else if(s[0]=='W')
		return 2;
	else if(s[0]=='E')
		return 3;
	else if(s[0]=='Y')
		return 4;
}
void InitTree(int *a)
{
	char s[5];
	for(int i=1;i<=n;++i)
	{
		scanf(" %s",s);
		a[i]=Number(s);
		if(a[i]==4)
			++a[0];
	}
}
void Init(void)
{
	static int a[MAXN],b[MAXN];
	T=(n<<1)+1;
	InitTree(a);
	InitTree(b);
	for(int i=1;i<=n;++i)
		head[i]=nullptr;
	for(int i=1,x;i<=n;++i)
	{
		scanf("%d",&x);
		AddEdges(S,i,!a[i] ? x+a[0] : x);
	}
	for(int i=1,x;i<=n;++i)
	{
		scanf("%d",&x);
		AddEdges(i+n,T,!b[i] ? x+b[0] : x);
	}
	for(int i=1;i<=n;++i)
		for(int j=1;j<=n;++j)
			if(win[a[i]][b[j]]==1)
				AddEdges(i,j+n,1);
}
void Destroy(void)
{
	for(int i=S;i^T;++i)
		delete head[i];
}
namespace Procyon
{
	int dis[MAXN];
	Edge *cur[MAXN];
	bool BFS(int S,int T)
	{
		queue<int> q;
		memset(dis,0,sizeof dis);
		q.push(S);
		dis[S]=1;
		while(!q.empty())
		{
			int u=q.front(),v;
			q.pop();
			for(Edge *i=head[u];i!=nullptr;i=i->nxt)
				if(i->w && !dis[v=i->to])
				{
					q.push(v);
					dis[v]=dis[u]+1;
				}
		}
		return dis[T];
	}
	int DFS(int u,int k)
	{
		if(u==T || !k)
			return k;
		int v,f,sum=0;
		for(Edge *&i=cur[u];i!=nullptr;i=i->nxt)
			if(i->w && dis[v=i->to]==dis[u]+1 && (f=DFS(v,min(k,i->w))))
			{
				k-=f;
				sum+=f;
				i->w-=f;
				i->back->w+=f;
			}
		if(!sum)
			dis[u]=1;
		return sum;
	}
	void Dinic(int S,int T)
	{
		int ans=0;
		while(BFS(S,T))
		{
			memcpy(cur,head,sizeof head);
			ans+=DFS(S,INF);
		}
		printf("%d\n",min(m,ans));
	}
}
int main(int argc,char** argv)
{
	scanf("%d %d",&n,&m);
	Init();
	Procyon::Dinic(S,T);
	Destroy();
	return 0;
}
```

---

## 作者：wangyibo201026 (赞：1)

## 题意

应该都看懂了吧！

## 思路

题目中在疯狂暗示本题需要用最大流：

- 第 $i$ 个人寿命为 $Life_i$ 秒，每次比完赛他们就会 $-1s$。当他们生命为 $0s$ 时他们就不能再比赛了。

显然可以看出，这就是最大流，但是是点权，我总结了最大流和最小割碰到点的解决方法：

- 最大流，建立超级源点和超级汇点，进行连边。

- 最小割，把一个点拆分为两个点，在中间连一条边权为该点点权的边。

显然我们可以采取如上方法，由于 YYY 可以给 J 续命，所以需要统计 YYY 个数，然后加到该 J 的生命值上去。然后就是打斗关系，将图中赢的人想输的人连一条边权为 $1$ 的边，这都是最大流的老套路了。

由于最多进行 $m$ 场比赛，所以最大流需要和 $m$ 取个 $\min$，~~我不会告诉你我因为这个调了好久，最后发现输入一个 $m$ 什么用都没有，悲剧了~~。

## 代码

代码：

```cpp
#include<bits/stdc++.h>
#define int long long

using namespace std;

const int N = 1e5 + 5;
const int inf = 1 << 30;

int n, m, s, t;
string a[N], b[N];

int cost[2][N];    //分别是两方的生命值

int dep[N], st[N];
bool vis[N];

int head[N], tot = 1;

struct Node{
	int to, w, next;
}edges[N * 2];

void add(int u, int v, int w){
	tot++;
	edges[tot].to = v;
	edges[tot].w = w;
	edges[tot].next = head[u];
	head[u] = tot;
}

//dinic 三个优化火力全开，我就不相信能 T

bool bfs(){
	memset(dep, -1, sizeof(dep));    //-1 有保障
	dep[s] = 1;
	queue<int> q;
	q.push(s);
	while(!q.empty()){
		int x = q.front();
		q.pop();
		for(int i = head[x]; i; i = edges[i].next){
			if(dep[edges[i].to] == -1 && edges[i].w){
				dep[edges[i].to] = dep[x] + 1;
				if(edges[i].to == t){
					return true;
				}
				q.push(edges[i].to);
			}
		}
	}
	return false;
}

int dfs(int x, int flow){
  if(x == t){
    vis[t] = true;
		return flow;
	}
	int tmp = 0, sum = 0;
  for(int i = st[x]; i; i = edges[i].next){
    st[x] = i;
    if(edges[i].w && dep[edges[i].to] == dep[x] + 1){
			if(tmp = dfs(edges[i].to, min(flow - sum, edges[i].w))){    //使用炸边优化
				edges[i].w -= tmp;
				edges[i ^ 1].w += tmp;
				sum += tmp;
			}
			if(flow == sum){
				break;
			}
    }
  }
  if(!sum){
  	dep[x] = 0;
	}
  return sum;
}

int dinic(){
	int ans = 0, sum;
	while(bfs()){
	  memcpy(st, head, sizeof(head));    //显然用了当前弧优化
	  vis[t] = true;    //这里可能是没见过的优化，如果不能到达 t 就直接退出，快了不少
	  while(vis[t]){
	    vis[t] = false;
		  while(sum = dfs(s, inf)){
			  ans += sum;
		  }
	  }
	}
	return ans;
}

bool Check(int x, int y){    //判断胜负关系
	if(a[x] == "J"){
		return (b[y] == "HK" || b[y] == "W");
	}
	else if(a[x] == "W"){
		return (b[y] == "YYY" || b[y] == "E");
	}
	else if(a[x] == "HK"){
		return (b[y] == "E" || b[y] == "W");
	}
	else if(a[x] == "YYY"){
		return (b[y] == "HK" || b[y] == "J");
	}
	else{
		return (b[y] == "J" || b[y] == "YYY");
	}
}

signed main(){
	cin >> n >> m;
	s = 0, t = 2 * n + 1;
	for(int i = 1; i <= n; i++){
		cin >> a[i];
		if(a[i] == "YYY"){
			cost[0][0]++;
		}
	}
	for(int i = 1; i <= n; i++){
		cin >> b[i];
		if(b[i] == "YYY"){
			cost[1][0]++;
		}
	}
	for(int i = 1; i <= n; i++){
		cin >> cost[0][i];
		if(a[i] == "J"){
			cost[0][i] += cost[0][0];
		}
	}
	for(int i = 1; i <= n; i++){
		cin >> cost[1][i];
		if(b[i] == "J"){
			cost[1][i] += cost[1][0];
		}
	}
	for(int i = 1; i <= n; i++){
		add(s, i, cost[0][i]);
		add(i, s, 0);
		add(n + i, t, cost[1][i]);
		add(t, n + i, 0);
	}
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= n; j++){
			if(Check(i, j)){
				add(i, j + n, 1);
				add(j + n, i, 0);   //老生常谈
			}
		}
	}
	cout << min(dinic(), m);   //一定要取 min
	return 0;
}
```

---

## 作者：Celtic (赞：1)

网络流经典题。

由于每个 YYY 能给 J 提供 $1$ 点生命，所以我们把 J 的生命增加对应的 YYY 的数量。

然后我们建立源点和汇点，源点向每个 byx 的人连边，容量为这个人的生命。每个诗乃酱的人向汇点连边，容量也为这个人的生命，表示这个人能够比赛这个人的生命次。

然后枚举每个 byx 的人和诗乃酱的人，如果 byx 能赢，我们就让 byx 的人到诗乃酱的人之间连一条边权为 $1$ 的边，表示对答案有 $1$ 的贡献。

然后跑一边 dinic ，然后再和 $m$ 取 $\min$ 即为答案。

代码
```cpp
#include<bits/stdc++.h>
#define N 201001
#define MAX 2001
#define re register
#define inf 1e18
using namespace std;
typedef long long ll;
typedef double db;
inline void read(re ll &ret)
{
	ret=0;re char c=getchar();re bool pd=false;
	while(!isdigit(c)){pd|=c=='-';c=getchar();}
	while(isdigit(c)){ret=(ret<<1)+(ret<<3)+(c&15);c=getchar();}
	ret=pd?-ret:ret;
	return;
}
ll n,m,sum1,sum2,s,t,a[N],b[N],lx[N];
char ss[2][N][10];
ll win[5][5]=
{
	0,1,1,-1,-1,
	-1,0,1,-1,1,
	-1,-1,0,1,1,
	1,1,-1,0,-1,
	1,-1,-1,1,0
};
struct node
{
	ll from,to,dis,nxt;
}e[N];
ll head[N],now[N],dep[N],cnt=-1;
inline void add(re ll u,re ll v,re ll d)
{
	e[++cnt].from=u;
	e[cnt].to=v;
	e[cnt].dis=d;
	e[cnt].nxt=head[u];
	head[u]=cnt;
	return;
}
queue<ll>q;
inline bool bfs()
{
	memset(dep,0,(t+1)*sizeof(ll));
	dep[s]=1;
	q.push(s);
	while(!q.empty())
	{
		re ll ver=q.front();
		q.pop();
		now[ver]=head[ver];
		for(re int i=head[ver];i!=-1;i=e[i].nxt)
		{
			if(!dep[e[i].to]&&e[i].dis)
			{
				dep[e[i].to]=dep[ver]+1;
				q.push(e[i].to);
			}
		}
	}
	return dep[t];
}
inline ll dfs(re ll ver,re ll lim)
{
	if(ver==t)
		return lim;
	re ll out=0;
	for(re ll i=now[ver];i!=-1;i=e[i].nxt)
	{
		now[ver]=i;
		if(e[i].dis&&dep[e[i].to]==dep[ver]+1&&lim)
		{
			re ll tmp=dfs(e[i].to,min(lim,e[i].dis));
			lim-=tmp;
			out+=tmp;
			e[i].dis-=tmp;
			e[i^1].dis+=tmp;
		}
	}
	if(!out)
		dep[ver]=0;
	return out;
}
inline ll dinic(re ll s,re ll t)
{
	re ll ret=0;
	while(bfs())
		ret+=dfs(s,inf);
	return ret; 
}
signed main()
{
	memset(head,-1,sizeof(head));
	read(n);
	read(m);
	t=(n<<1)+1;
	for(re int i=1;i<=n;i++)
	{
		scanf("%s",ss[0][i]+1);
		sum1+=(ss[0][i][1]=='Y');
		switch(ss[0][i][1])
		{
			case 'J':lx[i]=0;break;
			case 'H':lx[i]=1;break;
			case 'W':lx[i]=2;break;
			case 'Y':lx[i]=3;break;
			default :lx[i]=4;break;
		}
	}
	for(re int i=1;i<=n;i++)
	{
		scanf("%s",ss[1][i]+1);
		sum2+=(ss[1][i][1]=='Y');
		switch(ss[1][i][1])
		{
			case 'J':lx[i+n]=0;break;
			case 'H':lx[i+n]=1;break;
			case 'W':lx[i+n]=2;break;
			case 'Y':lx[i+n]=3;break;
			default :lx[i+n]=4;break;
		}
	}
	for(re int i=1;i<=n;i++)
	{
		read(a[i]);
		if(!lx[i])
			a[i]+=sum1;
	}
	for(re int i=1;i<=n;i++)
	{
		read(b[i]);
		if(!lx[i+n])
			b[i]+=sum2;
	}
	for(re int i=1;i<=n;i++)
	{
		add(s,i,a[i]);
		add(i,s,0);
		add(i+n,t,b[i]);
		add(t,i+n,0);
	}
	for(re int i=1;i<=n;i++)
	{
		for(re int j=n+1;j<=(n<<1);j++)
		{
			if(win[lx[i]][lx[j]]==1)
			{
				add(i,j,1);
				add(j,i,0);
			}
		}
	}
	n<<=1;
	printf("%lld\n",min(dinic(s,t),m));
	exit(0);
}
```


---

## 作者：wcyQwQ (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P3701)

[可能更好的阅读体验](https://chenyu-w.github.io/2022/07/29/P3701%E4%B8%BB%E4%B8%BB%E6%A0%91/)

## 前言

网络流建模入门经典题。

### 前置芝士

最大流


## 分析

看到人分为两个阵营，不难想到用最大流来做。

我们建立虚拟源汇 $s$ 和 $t$，将 $s$ 向 byx 的人连边，将诗乃的人向 $t$ 连边，边的容量为这个人物初始的生命值，注意如果这个人是 J 的话初始生命值要加上本队中 YYY 的人数，然后按题目给的胜负关系两两连容量为 $1$ 的边。然后跑 dinic 最大流即可。注意最终答案与 $m$ 取 $\min$。

## 代码

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 1e5 + 10, INF = 1 << 30;
int h[N], e[N], ne[N], f[N], idx;
int d[N], cur[N];
int s, t;
string a[N], b[N];
int l1[N], l2[N];

inline int read()
{
	int x = 0, y = 1; char c = getchar();
	while (c < '0' || c > '9') {
		if (c == '-') y = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
	return x * y;
}

inline void add(int a, int b, int c)
{
	e[idx] = b;
	f[idx] = c;
	ne[idx] = h[a];
	h[a] = idx++;
}

inline bool check(int i, int j)
{
	if (a[i] == "J")
		return b[j] == "HK" || b[j] == "W";
	if (a[i] == "W")
		return b[j] == "YYY" || b[j] == "E";
	if (a[i] == "HK")
		return b[j] == "W" || b[j] == "E";
	if (a[i] == "YYY")
		return b[j] == "J" || b[j] == "HK";
	if (a[i] == "E")	
		return b[j] == "YYY" || b[j] == "J";
}

inline bool bfs()
{
	memset(d, -1, sizeof d);
	queue<int> q;
	q.push(s);
	d[s] = 0;
	cur[s] = h[s];
	while (q.size())
	{
		int u = q.front();
		q.pop();
		for (int i = h[u]; ~i; i = ne[i])
		{
			int v = e[i];
			if (d[v] == -1 && f[i])
			{
				d[v] = d[u] + 1;
				cur[v] = h[v];
				if (v == t) return true;
				q.push(v);
			}
		}
	}
	return false;
}

inline int find(int u, int lim)
{
	if (u == t) return lim;
	int flow = 0;
	for (int i = cur[u]; ~i && flow < lim; i = ne[i])
	{
		cur[u] = i;
		int v = e[i];
		if (d[v] == d[u] + 1 && f[i])
		{
			int t = find(v, min(f[i], lim - flow));
			if (!t) d[v] = -1;
			f[i] -= t, f[i ^ 1] += t, flow += t;
		}
	}
	return flow;
}

inline int dinic()
{
	int res = 0, flow;
	while (bfs()) while (flow = find(s, INF)) res += flow;
	return res;
}

int main()
{
	memset(h, -1, sizeof h);
	int n = read(), m = read();
	s = 0, t = 2 * n + 1;
	for (int i = 1; i <= n; i++)
		cin >> a[i];
	for (int i = 1; i <= n; i++)
		cin >> b[i];
	for (int i = 1; i <= n; i++)
		l1[i] = read();
	for (int i = 1; i <= n; i++)
		l2[i] = read();
	int p = 0;
	for (int i = 1; i <= n; i++)
		if (a[i] == "YYY") p++;
	for (int i = 1; i <= n; i++)
		if (a[i] == "J") l1[i] += p;
	p = 0;
	for (int i = 1; i <= n; i++)
		if (b[i] == "YYY") p++;
	for (int i = 1; i <= n; i++)
		if (b[i] == "J") l2[i] += p;
	for (int i = 1; i <= n; i++)
		add(s, i, l1[i]), add(i, s, 0);
	for (int i = 1; i <= n; i++)
		add(n + i, t, l2[i]), add(t, n + i, 0);
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
		{
			if (check(i, j))
				add(i, n + j, 1), add(n + j, i, 0);
		}
	printf("%d\n", min(dinic(), m));
	return 0;
}
```



---

## 作者：Foreverxxx (赞：0)

网络流的题就是难建模……

### 思路

首先模拟样例（人物均用首字母替代）。

![](https://cdn.luogu.com.cn/upload/image_hosting/863rhtoc.png)

样例中，J 可以花费 $1$ 的生命值战胜 H，W 可以花费 $1$ 的生命值战胜 E，Y 可以用 $1$ 的生命值战胜 J，那么总共可以获胜 $3$ 场。

那么可以用二分图匹配？

题目中，Y 可以给 J 回血，有了这种~~奇怪的~~功能后，二分图就不能解决问题了。

那么，就用网络流！

对于连边的方式，我们枚举 byx 的所有点，当枚举到 $i
$ 时，我们考虑枚举诗乃酱的所有点，枚举到点 $i$ 可以获胜的点时，连一条容量为 $1$ 的边。

对于生命的限制，根据题意，显然应该让 Y 给 J 加上尽量多的血量，以便获得更多的胜利。

在建立超级源点时，从源点向所有 byx 的点连边，容量便是这个人最大可以达到的血量。建立超级汇点时，从所有诗乃酱的边向汇点连边，容量也为这个人的最大血量。

如果还是不理解，推荐画个图，毕竟网络流建模不是一眼就能看出来的。

Code

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int sss=0;
	char chh=getchar();
	while(chh<'0'||chh>'9') chh=getchar();
	while(chh>='0'&&chh<='9'){
		sss=sss*10+chh-'0';
		chh=getchar();
	}
	return sss;
}
int n,m,s,t;
int depth[1000005];
int head[1000005],to[1000005],nxt[1000005],val[1000005],tot=1;
void add(int u,int v,int w){
	to[++tot]=v;
	val[tot]=w;
	nxt[tot]=head[u];
	head[u]=tot;
}
int yyya=0,yyyb=0;
struct node{
	int HP;
	string name;
}a[105],b[105];
int check_a(int now){	
	if(a[now].name[0]=='J') return yyya;
	return 0;
}
int check_b(int now){
	if(b[now].name[0]=='J') return yyyb;
	return 0;
}
bool bfs(){
	memset(depth,0,sizeof depth);
	depth[s]=1;
	queue<int> q;
	q.push(s);
	while(!q.empty()){
		int x=q.front(); q.pop();
		for(register int i=head[x];i;i=nxt[i]){
			if(val[i]&&!depth[to[i]]){
				depth[to[i]]=depth[x]+1;
				q.push(to[i]);
			}
		}
	}
	return depth[t];
}
int dfs(int now,int flow){
	if(now==t) return flow;
	int now_flow=0;
	for(register int i=head[now];i&&flow;i=nxt[i]){
		int u=to[i];
		if(val[i]&&depth[u]==depth[now]+1){
			int tmp=dfs(u,min(flow,val[i]));
			val[i]-=tmp;
			val[i^1]+=tmp;
			now_flow+=tmp;
			flow-=tmp;
		}
	}
	if(now_flow==0) depth[now]=0;
	return now_flow;
}
int Dinic(){
	int ans=0;
	while(bfs()) ans+=dfs(s,1e9);
	return ans;
}
int main(){
	memset(head,-1,sizeof head);
	n=read(),m=read();
	s=0,t=2*n+1;
	for(register int i=1;i<=n;i++){
		cin>>a[i].name;
		if(a[i].name[0]=='Y') yyya++;
	}
	for(register int i=1;i<=n;i++){
		cin>>b[i].name;
		if(b[i].name[0]=='Y') yyyb++;
	}
	for(register int i=1;i<=n;i++) a[i].HP=read();
	for(register int i=1;i<=n;i++) b[i].HP=read();
	for(register int i=1;i<=n;i++){
		for(register int j=1;j<=n;j++){
			if(a[i].name[0]=='W'&&(b[j].name[0]=='Y'||b[j].name[0]=='E')){
				add(i,j+n,1); add(j+n,i,0);
			}
			else if(a[i].name[0]=='H'&&(b[j].name[0]=='W'||b[j].name[0]=='E')){
				add(i,j+n,1); add(j+n,i,0);
			}
			else if(a[i].name[0]=='J'&&(b[j].name[0]=='W'||b[j].name[0]=='H')){
				add(i,j+n,1); add(j+n,i,0);
			}
			else if(a[i].name[0]=='Y'&&(b[j].name[0]=='H'||b[j].name[0]=='J')){
				add(i,j+n,1); add(j+n,i,0);
			}
			else if(a[i].name[0]=='E'&&(b[j].name[0]=='Y'||b[j].name[0]=='J')){
				add(i,j+n,1); add(j+n,i,0);
			}
		}
	}
	for(register int i=1;i<=n;i++){
		add(s,i,a[i].HP+check_a(i)); add(i,s,0);
		add(i+n,t,b[i].HP+check_b(i)); add(t,i+n,0);
	}
	printf("%d",min(Dinic(),m));
	return 0;
}
```

---

## 作者：happy_dengziyue (赞：0)

### 1 思路

我们可以把 `byx` 的人和 `诗乃酱` 的人分成两个集合。

将源点向每个 `byx` 的人连边，容量为这个人的血量，代表这人能扛多少比赛。

将每个 `诗乃酱` 的人连边，容量为这个人的血量，~~代表这人能被 `byx` 打多少次。~~

注意加上续命带来的血量。

然后，如果一个 `byx` 的人能打 `诗乃酱` 的人，就连一条边，容量为 $1$。代表同样两人只能打一次。

跑一遍网络最大流即可。

注意，因为只有 $m$ 场比赛机会，所以，设最大流为 $ans$，则输出应为 $\operatorname{min}(ans,m)$。

### 2 代码与记录

```cpp
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
#define inf 0x3f3f3f3f
int n;//人数
int m;//比赛数
#define s 0//源点
#define t 201//汇点
struct P{
	int k,w;//种类，血量
};
P p1[102];//byx信息
P p2[102];//诗乃酱信息
int x1=0;//byx续命数
int x2=0;//诗乃酱续命数
bool to[7][7];//是否能对战
struct E{
	int u,v,w,a,nx;//起点、终点、流量、反边、下一条
}e[12000];//边
int ei=0;//下标
int fir[220];//开始路径
int de[220];//深度
int ans=0;//答案
inline int askk(char a){
	switch(a){
		case 'J':return 1;
		case 'H':return 2;
		case 'W':return 3;
		case 'E':return 4;
		case 'Y':return 5;
	}
	return 0;
}
inline void addedge(int u,int v,int w){
	++ei; e[ei].u=u; e[ei].v=v; e[ei].w=w; e[ei].a=ei+1; e[ei].nx=fir[u]; fir[u]=ei;
	++ei; e[ei].u=v; e[ei].v=u; e[ei].w=0; e[ei].a=ei-1; e[ei].nx=fir[v]; fir[v]=ei;
}
inline int mi(int a,int b){
	return a<b?a:b;
}
bool bfs(){
	memset(de,0,sizeof(de));
	queue<int>q;
	int u;
	de[s]=1;
	q.push(s);
	while(!q.empty()){
		u=q.front();
		q.pop();
		for(int i=fir[u],v;i;i=e[i].nx){
			v=e[i].v;
			if(e[i].w&&!de[v]){
				de[v]=de[u]+1;
				q.push(v);
			}
		}
	}
	return de[t];
}
int dfs(int u,int f){
	if(u==t||!f)return f;
	int res=0;
	for(int i=fir[u],v,w;i;i=e[i].nx){
		v=e[i].v;
		if(e[i].w&&de[u]+1==de[v]){
			w=dfs(v,mi(f,e[i].w));
			if(w){
				e[i].w-=w;
				e[e[i].a].w+=w;
				f-=w;
				res+=w;
				if(!f)break;
			}else de[v]=-1;
		}
	}
	return res;
}
int main(){
	#ifndef ONLINE_JUDGE
	freopen("P3701_1.in","r",stdin);
	freopen("P3701_1.out","w",stdout);
	#endif
	scanf("%d%d",&n,&m);
	memset(to,0,sizeof(to));
	to[1][2]=to[1][3]=true;
	to[2][3]=to[2][4]=true;
	to[3][4]=to[3][5]=true;
	to[4][1]=to[4][5]=true;
	to[5][1]=to[5][2]=true;
	for(int i=1;i<=n;++i){
		char a[5];
		scanf("%s",a);
		p1[i].k=askk(a[0]);
		if(p1[i].k==5)++x1;
	}
	for(int i=1;i<=n;++i){
		char a[5];
		scanf("%s",a);
		p2[i].k=askk(a[0]);
		if(p2[i].k==5)++x2;
	}
	for(int i=1;i<=n;++i){
		scanf("%d",&p1[i].w);
	}
	for(int i=1;i<=n;++i){
		scanf("%d",&p2[i].w);
	}
	memset(fir,0,sizeof(fir));
	for(int i=1;i<=n;++i){
		addedge(s,i,p1[i].w+x1*(p1[i].k==1));
		addedge(i+n,t,p2[i].w+x2*(p2[i].k==1));
	}
	for(int i=1;i<=n;++i){
		for(int j=1;j<=n;++j){
			if(to[p1[i].k][p2[j].k])addedge(i,j+n,1);
		}
	}
	while(bfs())ans+=dfs(s,inf);
	printf("%d\n",mi(ans,m));
	return 0;
}
```

[记录传送门](https://www.luogu.com.cn/record/58125395)

By **dengziyue**

---

## 作者：Hale (赞：0)

这道题，在学主席树的时候就看见了，就加入了收藏计划

最近省选前，填坑，就把这道题切了

主要还是网络流

首先对网络关系处理一下，我用了一下map使它更好处理一下

建图方式：

每个人为一个点

对byx和手气君有的得膜法师进行统计

向byx每个点连边，流量为生命，如果当前节点位主席，生命值加上膜法师数量

同时对手气君的每个点也这样处理

最后对有冲突关系的双方连线，流量为1

这样乖乖的跑一下最大流就好了鸭，嘤嘤嘤

上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+7;
const int INF=0x7f7f7f;
//1:j 主席  2:w高人  3:HK港记 4:YYY膜法师  5:E女王 
bool gx[6][6]={{0,0,0,0,0,0},
              {0,0,1,1,0,0},
              {0,0,0,0,1,1},
			  {0,0,1,0,0,1},
			  {0,1,0,1,0,0},
			  {0,1,0,0,1,0}};
int m,n,k,maxflow,cnt=1,tot,ss,t,ans,inc,mtot;
int head[N],dep[N];
map<string,int> mp;
string s[101][2];
bool vis[N];
struct edge
{
	int nx,to,flow;
} e[N];
void add_edge(int a,int b,int flow)
{
	cnt++;e[cnt].nx=head[a];e[cnt].to=b;e[cnt].flow=flow;head[a]=cnt;
	cnt++;e[cnt].nx=head[b];e[cnt].to=a;e[cnt].flow=0;head[b]=cnt;
}
bool bfs(int s,int t)
{
	queue<int> que;que.push(s);
	memset(dep,0,sizeof(dep));dep[s]=1;
	while (!que.empty())
	{
		int x=que.front();que.pop();
		for (int i=head[x];i;i=e[i].nx)
		{
			int y=e[i].to;
			if (dep[y]==0&&e[i].flow)
			{
				dep[y]=dep[x]+1;
				que.push(y);
			}
		}
	}
	if (dep[t]==0) return false;
	else return true;
}
int dfs(int x,int limit,int t)
{
	if (x==t) return limit;
	int used=0;
	for (int i=head[x];i;i=e[i].nx)
	{
		int y=e[i].to;
		if (dep[y]==dep[x]+1&&e[i].flow)
		{
			int di=dfs(y,min(limit-used,e[i].flow),t);
			if (di>0)
			{
				e[i].flow-=di;
				e[i^1].flow+=di;
				used+=di;
				if (used==limit) return limit;
			}
		}
	}
	if (!used) dep[x]=-2;
	return used;
}
void dinic(int s,int t)
{
	while (bfs(s,t)) ans+=dfs(s,INF,t);
}
int main()
{
	scanf("%d%d",&n,&m);ss=N-3;t=N-4;
	for (int i=1;i<=n;i++) cin>>s[i][0];
	for (int i=1;i<=n;i++) cin>>s[i][1];
	mp["J"]=1;mp["W"]=2;mp["HK"]=3;mp["YYY"]=4;mp["E"]=5;
	for (int i=1;i<=n;i++)
	 for (int j=1;j<=n;j++)
	{
		int x=mp[s[i][0]],y=mp[s[j][1]];
		if (gx[x][y])add_edge(i,j+n,1);
	}
	for (int i=1;i<=n;i++) if (mp[s[i][0]]==4) tot++;
	for (int j=1;j<=n;j++) if (mp[s[j][1]]==4) mtot++;
	for (int i=1;i<=n;i++)
	{
		int x;scanf("%d",&x);
		if (mp[s[i][0]]==1) add_edge(ss,i,x+tot);
		else add_edge(ss,i,x);
	}
	for (int i=1;i<=n;i++)
    {
    	int x;scanf("%d",&x);
    	if (mp[s[i][1]]==1) add_edge(i+n,t,x+mtot);
    	else add_edge(i+n,t,x);
	}
	dinic(ss,t);
	printf("%d\n",min(ans,m));
	return 0;
} 
```


---

## 作者：suyiheng (赞：0)

```
讲一下大体的思路吧：
其实就是建完图再跑一遍最大流。
建图：
1、建一个超级原点，一个超级汇点。
2、超级原点向每一个byx的人连一条容量为此人寿命的边（主席的寿命要加魔法师的数量点）。
3、每一个手气君的人向超级汇点一条容量为此人寿命的边（主席的寿命要加魔法师的数量点）。
4、从每一个byx的人向被他克制的手气君的人一条容量为无限的边。
最后从超级原点向一个超级汇点跑一遍最大流就好了！
```
------------

```c++
还是贴一下蒟蒻的代码吧：


#include<iostream>
#include<cstdio>
#include<vector>
#include<queue>
#include<string>
using namespace std;
struct data{
	int a,b,c;
	data(int a,int b,int c){
		this->a=a;
		this->b=b;
		this->c=c;
	}
};
vector<data> v;
vector<int> u[1001];
int n,m,k,x1[101],y1[101],s,t1,t2,f[1001],father[1001][2],CZ_AK_IOI,ans;
string str;
void data_ad(int x,int y,int z){
	v.push_back(data(x,y,z));
	u[x].push_back(s);
	s++;
	v.push_back(data(y,x,0));
	u[y].push_back(s);
	s++;
}
void bfs(){
	while(1){
		queue<int> q;
		for(int i=0;i<=k;i++){
			f[i]=0;
			father[i][0]=0;
			father[i][1]=0;
		}
		f[0]=10000000;
		q.push(0);
		while(!q.empty()){
			int c=q.front();
			q.pop();
			for(int i=0;i<u[c].size();i++){
				int d=u[c][i];
				data da=v[d];
				if(!f[da.b]&&da.c>0){
					f[da.b]=min(f[c],da.c);
					father[da.b][0]=c;
					father[da.b][1]=d;
					q.push(da.b);
				}
			}
		}
		if(f[k]==0)break;
		for(int i=k;i!=0;i=father[i][0]){
			v[father[i][1]].c-=f[k];
			v[father[i][1]^1].c+=f[k];
		}
		ans+=f[k];
	}
}
int main(){
	scanf("%d %d",&n,&m);
	k=2*n+1;
	for(int i=1;i<=n;i++){
		cin>>str;
		if(str=="W"){
			x1[i]=1;
		}else if(str=="HK"){
			x1[i]=2;
		}else if(str=="J"){
			x1[i]=3;
		}else if(str=="YYY"){
			x1[i]=4;
			t1++;
		}else if(str=="E"){
			x1[i]=5;
		}
	}
	for(int i=1;i<=n;i++){
		cin>>str;
		if(str=="W"){
			y1[i]=1;
		}else if(str=="HK"){
			y1[i]=2;
		}else if(str=="J"){
			y1[i]=3;
		}else if(str=="YYY"){
			y1[i]=4;
			t2++;
		}else if(str=="E"){
			y1[i]=5;
		}
	}
	for(int i=1;i<=n;i++){
		scanf("%d",&CZ_AK_IOI);
		if(x1[i]==3)CZ_AK_IOI+=t1;
		data_ad(0,i,CZ_AK_IOI);
	}
	for(int i=1;i<=n;i++){
		scanf("%d",&CZ_AK_IOI);
		if(y1[i]==3)CZ_AK_IOI+=t2;
		data_ad(i+n,k,CZ_AK_IOI);
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(x1[i]==1&&(y1[j]==4||y1[j]==5))data_ad(i,n+j,1);
			else if(x1[i]==2&&(y1[j]==1||y1[j]==5))data_ad(i,n+j,1);
			else if(x1[i]==3&&(y1[j]==1||y1[j]==2))data_ad(i,n+j,1);
			else if(x1[i]==4&&(y1[j]==2||y1[j]==3))data_ad(i,n+j,1);
			else if(x1[i]==5&&(y1[j]==3||y1[j]==4))data_ad(i,n+j,1);
		}
	}
	bfs();
	printf("%d",min(ans,m));
}
```

---


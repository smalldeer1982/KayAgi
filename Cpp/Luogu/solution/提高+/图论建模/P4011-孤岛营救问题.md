# 孤岛营救问题

## 题目描述

$1944$ 年，特种兵麦克接到国防部的命令，要求立即赶赴太平洋上的一个孤岛，营救被敌军俘虏的大兵瑞恩。瑞恩被关押在一个迷宫里，迷宫地形复杂，但幸好麦克得到了迷宫的地形图。迷宫的外形是一个长方形，其南北方向被划分为 $N$ 行，东西方向被划分为 $M$ 列，于是整个迷宫被划分为 $N\times M$ 个单元。每一个单元的位置可用一个有序数对(单元的行号，单元的列号)来表示。南北或东西方向相邻的 $2$ 个单元之间可能互通，也可能有一扇锁着的门，或者是一堵不可逾越的墙。迷宫中有一些单元存放着钥匙，并且所有的门被分成$P$ 类，打开同一类的门的钥匙相同，不同类门的钥匙不同。


大兵瑞恩被关押在迷宫的东南角，即 $(N,M)$ 单元里，并已经昏迷。迷宫只有一个入口，在西北角。也就是说，麦克可以直接进入 $(1,1)$ 单元。另外，麦克从一个单元移动到另一个相邻单元的时间为 $1$，拿取所在单元的钥匙的时间以及用钥匙开门的时间可忽略不计。


试设计一个算法，帮助麦克以最快的方式到达瑞恩所在单元，营救大兵瑞恩。


## 说明/提示

$|X_{i1}-X_{i2}|+|Y_{i1}-Y_{i2}|=1,0\leq G_i\leq P$

$1\leq Q_i\leq P$


$N,M,P\leq10, K<150,S\leq 14$


## 样例 #1

### 输入

```
4 4 9
9
1 2 1 3 2
1 2 2 2 0
2 1 2 2 0
2 1 3 1 0
2 3 3 3 0
2 4 3 4 1
3 2 3 3 0
3 3 4 3 0
4 3 4 4 0
2
2 1 2
4 2 1```

### 输出

```
14```

# 题解

## 作者：Siyuan (赞：62)

[$$\Large\texttt{My Blog}$$](https://hydingsy.github.io/)

---

> 题目链接：[Luogu 4011](https://www.luogu.org/problemnew/show/P4011)

1944 年，特种兵麦克接到国防部的命令，要求立即赶赴太平洋上的一个孤岛，营救被敌军俘虏的大兵瑞恩。瑞恩被关押在一个迷宫里，迷宫地形复杂，但幸好麦克得到了迷宫的地形图。迷宫的外形是一个长方形，其南北方向被划分为 $N$ 行，东西方向被划分为 $M$ 列，于是整个迷宫被划分为 $N\times M$ 个单元。每一个单元的位置可用一个有序数对（单元的行号，单元的列号）来表示。南北或东西方向相邻的 $2$ 个单元之间可能互通，也可能有一扇锁着的门，或者是一堵不可逾越的墙。迷宫中有一些单元存放着钥匙，并且所有的门被分成 $P$ 类，打开同一类的门的钥匙相同，不同类门的钥匙不同。

大兵瑞恩被关押在迷宫的东南角，即 $(N,M)$ 单元里，并已经昏迷。迷宫只有一个入口，在西北角。也就是说，麦克可以直接进入 $(1,1)$ 单元。另外，麦克从一个单元移动到另一个相邻单元的时间为 $1$，拿取所在单元的钥匙的时间以及用钥匙开门的时间可忽略不计。

试设计一个算法，帮助麦克以最快的方式到达瑞恩所在单元，营救大兵瑞恩。

数据范围：$1\le N,M,P\le 10$

------

## Solution

由于每次移动的代价都是 $1$，所以我们可以考虑 $\texttt{01BFS}$；又因为 $P$ 的范围很小，可以对 $P$ 进行状压，记 $cost(i,j,k)$ 表示到 $(i,j)$ 拥有的钥匙集合为 $k$ 的最小花费，维护 $i,j,k$ 进行 $\texttt{01BFS}$，一旦有解直接返回，需要判断无解情况。

注意每个点可以放置多个钥匙，钥匙使用后还是存在的。

**时间复杂度**：$O(NM\cdot 2^P)$

------

## Code

```cpp
#include <cstdio>
#include <algorithm>
#include <queue>

const int N=12;
const int dx[]={1,-1,0,0},dy[]={0,0,1,-1};
int n,m,e[N][N][N][N],cnt[N][N],key[N][N][N];
bool vis[N][N][1<<14];
struct node {
    int x,y,k,d;
    node() {x=y=k=d=0;}
    node(int _x,int _y,int _k,int _d) {
        x=_x,y=_y,k=_k,d=_d;
    }
};

int getkey(int x,int y) {
    int ans=0;
    for(int i=1;i<=cnt[x][y];++i) ans|=(1<<(key[x][y][i]-1));
    return ans;
}
int bfs(int sx,int sy) {
    std::queue<node> q;
    int sk=getkey(sx,sy);
    q.push(node(sx,sy,sk,0)),vis[sx][sy][sk]=1;
    while(!q.empty()) {
        node u=q.front(); q.pop();
        if(u.x==n&&u.y==m) return u.d;
        int ux=u.x,uy=u.y;
        for(int i=0;i<4;++i) {
            int vx=ux+dx[i],vy=uy+dy[i],opt=e[ux][uy][vx][vy];
            if(vx<1||vx>n||vy<1||vy>m||opt<0||(opt&&!(u.k&(1<<(opt-1))))) continue;
            int nxt=u.k|getkey(vx,vy);
            if(vis[vx][vy][nxt]) continue;
            q.push(node(vx,vy,nxt,u.d+1)),vis[vx][vy][nxt]=1;
        }
    }
    return -1;
}
int main() {
    int k,s;
    scanf("%d%d%*d",&n,&m);
    for(scanf("%d",&k);k--;) {
        int x1,y1,x2,y2,g;
        scanf("%d%d%d%d%d",&x1,&y1,&x2,&y2,&g);
        if(g) e[x1][y1][x2][y2]=e[x2][y2][x1][y1]=g;
        else e[x1][y1][x2][y2]=e[x2][y2][x1][y1]=-1;
    }
    for(scanf("%d",&s);s--;) {
        int x,y,q;
        scanf("%d%d%d",&x,&y,&q);
        key[x][y][++cnt[x][y]]=q;
    }
    printf("%d\n",bfs(1,1));
    return 0;
}
```



---

## 作者：半仙胡小桃 (赞：36)

类型：状压+BFS

不是网络流（滑稽

很明显是个状压嘛。

我们状态压缩钥匙。

$vis[x][y][S]$ 表示在x y这个位置持有钥匙状态为S是否来过

BFS队列里存4个变量

分别为当前横纵坐标，步数以及钥匙状态

map[x1][y1][x2][y2]表示两个点直接是否有墙或者是门。

pas[x][y][i]表示x y这个点放的钥匙的种类

num[x][y]表示当前点钥匙数目

坑点：

1.钥匙不是用了就没了（(#`O′)喂，没了才有问题吧

2.一个点可以放多个钥匙（人家又没说只放一个。

3.初始点可以放钥匙

4.别忘了输出-1....

~~虽然我只被2坑了~~

CODE
[题目传送门](https://www.luogu.org/problemnew/show/P4011)

```cpp
#include <cstdio>
#include <iostream>
#include <queue> 
#define il inline 
using namespace std;
bool vis[11][11][(1<<11)];
int map[11][11][11][11];
int pas[11][11][11],num[11][11];
struct node{
    int x,y,step,cos;
}; 
queue <node> dl;
int n,m,p,k;
int dx[]={0,1,-1,0,0},dy[]={0,0,0,1,-1};
il int BFS()
{
    int nows=0;
    for(int i=1;i<=num[1][1];i++)
     nows|=(1<<(pas[1][1][i]-1));
    vis[1][1][nows]=1;
    dl.push((node){1,1,0,nows});
    while(!dl.empty())
    {
        node now=dl.front();
        dl.pop();
        if(now.x==n&&now.y==m)
         return now.step; 
        for(int i=1;i<=4;i++) 
         {
           int xx=now.x+dx[i],yy=now.y+dy[i],t;
           if(xx<1||yy<1||xx>n||yy>m) continue;
           if(map[now.x][now.y][xx][yy]==-1) continue;
           if((t=map[now.x][now.y][xx][yy])!=0)
            if((now.cos&(1<<(t-1)))==0) continue;
           int cosx=now.cos;
           for(int j=1;j<=num[xx][yy];j++)
            cosx|=(1<<(pas[xx][yy][j]-1));
           if(vis[xx][yy][cosx]) continue;
           vis[xx][yy][cosx]=1;
           dl.push((node){xx,yy,now.step+1,cosx});
         }
    }
    return -1;
}
int main()
{
    //freopen("rescue.in","r",stdin);
    //freopen("rescue.out","w",stdout);
    scanf("%d%d%d%d",&n,&m,&p,&k);
    for(int i=1;i<=k;i++)
    {
        int x1,x2,y1,y2,g;
        scanf("%d%d%d%d%d",&x1,&y1,&x2,&y2,&g);
        if(g==0) map[x1][y1][x2][y2]=map[x2][y2][x1][y1]=-1;
        else map[x1][y1][x2][y2]=map[x2][y2][x1][y1]=g;
    }
    int s;
    scanf("%d",&s);
    for(int i=1;i<=s;i++)
    {
        int x,y,p;
        scanf("%d%d%d",&x,&y,&p);
        pas[x][y][++num[x][y]]=p;
    }
    printf("%d\n",BFS());
    return 0;
} 
```

---

## 作者：孤叶残影 (赞：24)

（DIJSKRAL应该也能做）
本题利用分层图建立模型，若没有钥匙和门，可直接用最短路算法求解

------------
但有了门的因素，可建立2的p次方层（共有p种钥匙，每种钥匙有有与没有两种状态，共计2的p次方）。

------------
# 对于分层图连边

------------
再同一层中，在相邻两点间连一条权值为1的边（双向），若该点有一把k种钥匙，则在该点与有第k种钥匙状态的那一层连一条权值为0的边，然后BFS
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int to,next,w;
}a[1000000];
struct typekey{
	int x,y;
}key[15][20];
int n,M,tot=0,row,line,keyn;
int layer,r,num[20][20];
int fg[200][200],kn[15],frist[102405],dis[102405];
int q[1000000],inf=1e9;
bool vst[102405];
inline void scan()
{
	int i,j,x,y,p,k=0;
	scanf("%d %d %d %d",&row,&line,&keyn,&r);
	for(i=1;i<=row;i++)
	{
		for(j=1;j<=line;j++)
		num[i][j]=++k;         //编号
	}
	for(i=1;i<=r;i++)
	{
		scanf("%d %d",&x,&y);
		j=num[x][y];
		scanf("%d %d",&x,&y);
		k=num[x][y];
		scanf("%d",&p);
		if(p==0) p=-1;            //表示围墙
		fg[j][k]=fg[k][j]=p;
	}
	scanf("%d",&r);
	for(i=1;i<=r;i++)
	{
		scanf("%d %d %d",&x,&y,&p);
		kn[p]++;
		key[p][kn[p]].x=x;      //key[p][kn[p]]为第p类钥匙的第kn[p]把所在的位置
		key[p][kn[p]].y=y;
	}
}
inline void add_edge( int x,int y,int w)
{
	tot++;
	a[tot].to=y;
	a[tot].w=w;
	a[tot].next=frist[x];
	frist[x]=tot;
	
}
inline void process()
{
	int i,j,k,x,y,t;
	bool havekey[15]={0};
	M=row*line;         //每层节点数
	layer=1<<keyn;     //共有layer层数 
	n=M*layer;           //总节点数
	for(k=0;k<layer;k++)         //对每层处理
	{
		for(i=1;i<=keyn;i++)
		if(k&(1<<(i-1))) havekey[i]=true;
		else havekey[i]=false;
		for(i=1;i<=row;i++)         //在本层连边
		{
			for(j=1;j<=line;j++)
			{
				x=num[i][j];
				y=num[i][j+1];       //向右连接
				if(y!=0&&fg[x][y]!=-1)   //有节点且两点间无墙
				{
					if(fg[x][y]==0||havekey[fg[x][y]])
					{
						add_edge(k*M+x,k*M+y,1);
						add_edge(k*M+y,k*M+x,1);
					}
				}
				y=num[i+1][j];            //向下连边
				if(y!=0&&fg[x][y]!=-1)
				{
					if(fg[x][y]==0||havekey[fg[x][y]])
					{
						add_edge(k*M+x,k*M+y,1);
						add_edge(k*M+y,k*M+x,1);
					}
				}			
			}
		}
		for(i=1;i<=keyn;i++)           //转移到其他状态
		{
			if(!havekey[i])            //未持有i类钥匙转移
			{
				t=k+(1<<(i-1));       //得到i类钥匙的层
				for(j=1;j<=kn[i];j++)     //循环i类钥匙位置
				{
					x=num[key[i][j].x][key[i][j].y];
					add_edge(k*M+x,t*M+x,0);
				}
			}
		}
	} 
}
inline void SPFA()
{
	int i,j,k,head,tail;
	for(i=1;i<=n;i++) dis[i]=inf;
	dis[1]=0;vst[1]=true;head=tail=1;q[1]=1;
	while(head<=tail)
	{
		i=q[head];
		for(k=frist[i];k;k=a[k].next)
		{
			j=a[k].to;
			if(dis[j]>dis[i]+a[k].w)
			{
				dis[j]=dis[i]+a[k].w;
				if(!vst[j])
				{
					q[++tail]=j;
					vst[j]=true;
				}
			}
		}
		vst[i]=false;
		head++;
	}
}
inline void end()
{
	int i,ans=inf,T;
	SPFA();
	T=num[row][line];
	for(i=0;i<layer;i++)
	ans=min(ans,dis[i*M+T]);
	if(ans<inf) printf("%d",ans);
	else printf("-1");
}
int main()
{
	scan();
	process();//建图
	end();
	return 0;
}
```


---

## 作者：TRZ_2007 (赞：10)

# Solution  
这道题目可以轻松地看出应该考虑宽搜算法来解决，其他题解中没有讲明白如何准确压位，所以本蒟蒻来讲一下。  
### 什么是压位？  
压位通俗的说就是把一个**不可**或**很难**直接标记的状态变得更好标记。  
### 如何压位？  
以本题为例，题目当中钥匙可能有10种，按照我们之前的方法，需要开一个10维的布尔数组来进行标记，但这无疑为判重带来了巨大的麻烦。于是我们观察每把钥匙的状态，发现钥匙只有两种状态：有还是没有。于是考虑二进制。用一个10位二进制数来表示每一把钥匙的状态，如``0000000000``就表示目前你一把钥匙都没有，而``0000001000``就表示你有第4把钥匙，那我们如何实现呢？  
首先你先确保你明白二进制的运算后再看下文。  
假如我们现在一把钥匙都没有，来到了一个有第4把钥匙的~~风水宝地~~，我们就需要拿起这一把钥匙，使得二进制数``0000000000``变成``0000001000``，我们就只需要把数字``1``向左移动``3``个单位，下面画个图进行理解：  

![](https://cdn.luogu.com.cn/upload/image_hosting/hhssv9gp.png)  

也就是说如果我们取了第 $q$ 把钥匙，我们需要把它压入状态只需要将它向左移动 $q-1$ 位，伪代码如下：  
```cpp
getk(q)
	x = 1 << (q-1)
```
那么如果说我们有多把钥匙呢？  
那我们就考虑**按位或**，举个例子，如果你现在有了第三把钥匙，你又拿到了第四把，那么我们只需要把这两个二进制数按位或一下即可。  
画个图：  

![](https://cdn.luogu.com.cn/upload/image_hosting/9d1p7bbo.png)  
哦对了，图上的那个**xor是按位或，不是按位异或**，打错了。

也就是说我们将两把钥匙合并只需要按位或一下即可，伪代码如下：  
```cpp
merge(q) 
	p |= q  //p是原来的钥匙状态，q是新来的。
```

那么我们现在解决了拿钥匙的问题，现在我们要解决判重的问题，怎么解决呢？  
这次我们用**按位与**，举个例子，如果你现在有了第2,3,4,7,9把钥匙，而这扇门需要第八把钥匙，我们只需要把你手中有的钥匙的状态和第八把钥匙的状态按位与，如果结果为0，则没有这一把钥匙，否则就有这把钥匙，画个图：  

![](https://cdn.luogu.com.cn/upload/image_hosting/0zt2idea.png)  
![](https://cdn.luogu.com.cn/upload/image_hosting/k14ts94z.png)  

但是你要注意，第 $p$ 把钥匙的状态时二进制数左移 $p-1$ 位的，不能搞错。  

这道题目好像难的就是状态的压缩吧，其他你应该可以自己做出来的，代码就不放了。

---

## 作者：LordLeft (赞：10)

显然，这是一道广度优先搜索的题目

在这个题目中，当前的状态是“走到哪”和“有哪些钥匙”，所以用结构体来模拟队列。考虑到情况比较多，可以开一个多维map来记录哪些状态已经有过了，防止bfs时重复入队

我们定义一个01字符串，每一位对应每一把钥匙的状态（开头加一个没有意义的‘0’）。比如，现在我的状态是“0011001000”，表示我们已经找到了第二、三、六把钥匙。当我走到一个格子，里面有四、七号钥匙，只要把s[4]，s[7]改为‘1’就行了，状态更新为“0011101100”。

个人认为这样比较直观，修改时也比较方便，(可能)便于理解 （主要是不会二进制状压lol）

code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,p,k,s;
int bar[12][12][12][12];//存墙和门，四个维度分别是x1,y1,x2,y2，存储的值是门的序号（或者墙）
string key[12][12];//存每一格有哪些钥匙
struct cell{
	int x,y,step;//分别是横坐标、纵坐标和步数
	string l;//当前有哪些钥匙
	}que[1000005];//模拟队列
map<pair<string,pair<int,int>  >,bool>jud;//用于去重，string是钥匙状态，里面的pair是坐标
int fx[4][2]={{1,0},{-1,0},{0,-1},{0,1}};//方向数组
int main(){
	std::ios::sync_with_stdio(false);//稍微加快一下cin、cout的速度，也可以写快读
	cin>>n>>m>>p>>k;
	for(int i=1;i<=k;i++){
		int x1,y1,x2,y2,z;
		cin>>x1>>y1>>x2>>y2>>z;
		if(z==0)z=-1;//这里转换一下，用-1表示墙，不然会出锅
		bar[x1][y1][x2][y2]=z;
		bar[x2][y2][x1][y1]=z;//门是双向的，所以要存两遍
		}
	cin>>s;	
	for(int i=1;i<=s;i++){
		int x,y;
		char z;
		cin>>x>>y>>z;
		key[x][y]+=z;//存放这个点有哪些钥匙（至于为什么是‘+z’，看后面）
		}
	string ll="";
	for(int i=0;i<=p;i++){
		ll+='0';
		}//初始化一下钥匙状态，把每个位都定为0
	int le=0,ri=0;	
	cell a;	
	a.x=1;a.y=1;a.l=ll;a.step=0;
	que[le]=a;//起点入队
	bool bj=0;//判断是否有解
	while(le<=ri){//bfs基本操作
		int xx=que[le].x,yy=que[le].y,how=que[le].step;
		string v=que[le].l;
		jud[make_pair(v,make_pair(xx,yy))]=1;//这个状态已经存在过了，标记一下
		if(xx==n&&yy==m){//到达终点说明有解，直接结束
			cout<<how;
			bj=1;
			break;
			}
		++le;
	for(int q=0;q<4;q++){
			string now=v;
			int i=xx+fx[q][0],j=yy+fx[q][1];
			if(i<1||i>n||j<1||j>m)continue;//判断越界
			if(bar[xx][yy][i][j]==-1)continue;//判断有无墙
			for(int u=0;u<key[i][j].length();u++){//看看这个点有哪些钥匙
				int h=key[i][j][u]-'0';
				now[h]='1';//修改钥匙状态
				}
			if(jud[make_pair(now,make_pair(i,j))]==1)continue;//判重	
 			if(bar[xx][yy][i][j]>0){//假如有门
				if(now[bar[xx][yy][i][j]]=='0')continue;//判断有没有开这个门的钥匙
				}
			cell b;
			b.x=i;b.y=j;b.step=how+1;b.l=now;
			++ri;
			que[ri]=b;//进队
			}										
		}								
	if(bj==0){
		cout<<-1;//无解输出-1
		}	
	return 0;
	}
```

巨坑：一个点可以放多把钥匙（所以在更新key数组是是加上一个字符，而不是直接修改）

程序跑的很慢，但是解决这道题绰绰有余

（表达能力较差，抱歉）

---

## 作者：s_a_b_e_r (赞：9)

###分层图+dp

这个是网络流?震惊！

从$(1,1)$到$(n,m)$中在某些限制下最少走多少步。

那么唯一的问题就是这些限制怎么判断。

由于钥匙的种数有限。且$\le 14$

那么我们可以用一个二进制数表示有没有在拿到当前钥匙。

于是,记录$dis[x][y][z]$为当前钥匙状态是z,走到了$(x,y)$这个点最少需要的步数。

当前能转移的条件是对于所有门的二进制的第$i$位为1的,都有$(1<<i)\&z\ne 0$

于是对于墙的状态,则可以用$2^k$这样表示,（因为没有这样的钥匙~~(笑~~

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<queue>
#include<cstring>
#define y1 bibalabalab__bibibili 
using namespace std;
const int maxn=12;
const int xx[5]={0,0,1,-1},yy[5]={1,-1,0,0};
inline int read(){
    int an=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){ch=getchar();}
    while('0'<=ch&&ch<='9'){an=an*10+(ch^48);ch=getchar();}
    return an;
}
int n,m,P,K,KEY;
struct saber{
int x,y,key;
};
typedef saber ssr;
int b[maxn][maxn][maxn][maxn];//P种钥匙0-(1<<p)-1 
int dis[maxn][maxn][1<<16];
int key[maxn][maxn];
inline bool get(int x,int y){
    for(;x;x-=x&-x){//提取最后一位为1的位置
        int now=x&-x;
        if(!(y&now))return 0;
    }
    return 1;
}
queue<saber>q;
int main(){
    n=read();m=read();P=read();
    K=read();
    for(int i=K;i;i--){
        int x0=read(),y0=read(),x1=read(),y1=read(),kind=read();
        if(kind){
        b[x0][y0][x1][y1]|=1<<kind-1;
        b[x1][y1][x0][y0]|=1<<kind-1;
        }
        else {
        b[x0][y0][x1][y1]|=1<<P;
        b[x1][y1][x0][y0]|=1<<P;
        }
    }
    KEY=read();
    for(int i=KEY;i;i--){
        int x=read(),y=read(),z=read();
        key[x][y]|=1<<z-1;
    }
    memset(dis,0x3f3f3f,sizeof dis);
    q.push((saber){1,1,0});
    dis[1][1][0]=0;
    while(!q.empty()){
        ssr p=q.front();q.pop();
        for(int i=0;i<5;i++){
            int x=p.x+xx[i];
            int y=p.y+yy[i];
            if(x<1||y<1||x>n||y>m)continue;
            bool ok=get(b[p.x][p.y][x][y],p.key);
            if(ok){
                if(dis[x][y][p.key|key[x][y]]>dis[p.x][p.y][p.key]+1){
                    dis[x][y][p.key|key[x][y]]=dis[p.x][p.y][p.key]+1;
                    q.push((saber){x,y,p.key|key[x][y]});
                }
            }
        }
    }
    int ans=0x3f3f3f;
    for(int i=0;i<(1<<P);i++)ans=min(ans,dis[n][m][i]);
    if(ans==0x3f3f3f)cout<<-1;
    else cout<<ans;
    return 0;
}
```
[最后推荐一道类似题,同样都是用了状压的bfs](https://www.luogu.org/problemnew/show/P3786)


---

## 作者：FXY是蒟蒻 (赞：7)

# SPFA大法好
第一道紫题……

一开始看到这个网络流题居然是紫吓了一跳，瞅了瞅觉得如果用bfs应该没有那么难，用SPFA练练手之后发现好像如果不用bfs真的值这么难，不过好像题解并没有SPFA的
### SPFA死了？
## 不可能！
### 两个坑点
第一个是一把钥匙可以多次使用。虽然是常识——但是不排除有人会落掉

第二个是一个房间可以有多把钥匙，但是两个房间之间只可能有一！扇！门！大部分WA都是这来的
#### 思路
1.一个map数组把地图信息存进去（建图）

2.判断：越界，有墙 ，没钥匙开门——都不行

3.跑SPFA按套路更新，输出

bingo！（这道题输入太……）
#### CODE
```c
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
int n,m,p,k,s,x1,y1,x2,y2,dis[18][18][1030],g,zz,ans=2e9;
int dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};//方向
bool flag[18][18][1030];
int c[18][18],map[18][18][4];
struct node
{
    int x,y,z; 
}u,f;
queue<node>q;
void add_map(int a,int b,int aaa,int bbb,int c)//建图
{
  //四个方向储存
    if(aaa==a-1&&bbb==b)
	{
		map[a][b][0]=c;
		map[aaa][bbb][2]=c;
		return;
	}
    if(aaa==a&&bbb==b+1)
	{
		map[a][b][1]=c;
		map[aaa][bbb][3]=c;
		return;
	}
    if(aaa==a+1&&bbb==b)
	{
		map[a][b][2]=c;
		map[aaa][bbb][0]=c;
		return;
	}
    if(aaa==a&&bbb==b-1)
	{
		map[a][b][3]=c;
		map[aaa][bbb][1]=c;
		return;
	}
}
int main()
{
    memset(map,-1,sizeof(map));//-1默认格子之间没有障碍
	scanf("%d%d%d%d",&n,&m,&p,&k);//输入不用说了
    for(int i=1;i<=k;i++)
    {
        scanf("%d%d%d%d%d",&x1,&y1,&x2,&y2,&g);
        add_map(x1,y1,x2,y2,g);
    }
    scanf("%d",&s);
    for(int i=1;i<=s;i++)
    {
    	int a,b,d;
        scanf("%d%d%d",&a,&b,&d);
        c[a][b]|=(1<<(d-1));//一个点可以存多个钥匙！
    }
    memset(dis,63,sizeof(dis));//清空dis数组
    f.x=1;
    f.y=1;
    f.z=c[1][1];
    q.push(f);
    flag[1][1][f.z]=1;
    dis[1][1][f.z]=0;
    while(!q.empty())
    {
        f=q.front();q.pop();
        flag[f.x][f.y][f.z]=0;
        for(int i=0;i<4;i++)
        {
            u.x=f.x+dx[i];
            u.y=f.y+dy[i];
            u.z=f.z|c[u.x][u.y]; 
            if(u.x<1||u.x>n||u.y<1||u.y>m||map[f.x][f.y][i]==0||map[f.x][f.y][i]>0&&!(f.z&(1<<(map[f.x][f.y][i]-1))))
            continue;  //挡着，没钥匙，越界，都pass掉  
            if(dis[u.x][u.y][u.z]>dis[f.x][f.y][f.z]+1)//按套路跑一跑
            {
        		dis[u.x][u.y][u.z]=dis[f.x][f.y][f.z]+1;
                if(!flag[u.x][u.y][u.z])
                {
                    flag[u.x][u.y][u.z]=1;
                    q.push(u);
                }
            }
        }
    }
    for(int i=0;i<(1<<p);i++)
    ans=min(ans,dis[n][m][i]);
    if(ans<1e8)
    printf("%d\n",ans);
    else
    printf("-1\n");
    return 0;
}
```
码风清奇……

我爱SPFA，SPFA使我快乐

审核真好看！给过吧QWQ

---

## 作者：Aryzec (赞：6)

#### [题面](https://www.luogu.org/problemnew/show/P4011)
---
## 大致题意
起点为 $(1,1),$  终点为$(n,m)$。有些格子上有若干个钥匙，两个格子之间可能有一堵墙或者一扇可以用对应钥匙打开的门。每次移动需要 $1$ 个单位时间，其他动作不需要时间，求最少需要多少时间能从起点到达终点。

---
## 思路
状压$+bfs$

这种题很容易想到用 $bfs,$ 但是问题在走的时候如果两个格子之间有门，我们不知道怎么去判断当前手上所有的钥匙里有没有能打开这扇门的钥匙。我们注意到钥匙的种类最多只有 $14$ 种，我们可以想到用状压来表示当前搜到的钥匙的状态。

一些数组的意思：

$pw_i=2^{i-1}$
    
$Key_{i,j}$ 表示在第 $i$ 行第 $j$ 列的格子能获得的钥匙（用二进制存储）

$vis_{i,j,s}$ 表示在第 $i$ 行第 $j$ 列的格子且持有钥匙的状态为 $s$ 的情况之前有没有搜到过

$mp_{x_1,y_1,x_2,y_2}$ 表示第 $x_1$ 行第 $y_1$ 列的格子与第 $x_2$ 行第 $y_2$ 列的格子之间有没有墙或门，如果都没有的话为0，如果有墙的话为-1，如果是门的话则为$pw_i$ ($i$为对应能打开该门的钥匙的编号)

具体的会在代码里讲的。

---
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int dx[]={1,-1,0,0};//增量数组
const int dy[]={0,0,1,-1};
int vis[25][25][40005],x,y,xx,yy,g,pw[105],mp[16][16][16][16],Key[20][20],n,m,tot;
struct tzg{int x,y,key,stp;}q[5000005];//q为广搜用的队列
int bfs(){
	int h=1,t=1;
	vis[1][1][Key[1][1]]=1;//一开始就有位于(1,1)的钥匙
	q[t]=(tzg){1,1,Key[1][1],0};
	for(;h<=t;++h){
		tzg u=q[h];//取队头
		for(int k=0;k<4;++k){
			int x=u.x+dx[k],y=u.y+dy[k],key=u.key,stp=u.stp;
			if(x<1||y<1||x>n||y>m)continue;//如果超出格子则跳过
			if(mp[x][y][u.x][u.y]==-1)continue;//如果两个格子之间有墙则跳过
			if((mp[x][y][u.x][u.y]&key)!=mp[x][y][u.x][u.y])continue;//如果两个格子之间有门而且手上所有的钥匙里没有能打开该门的钥匙则跳过
			key|=Key[x][y];
			if(vis[x][y][key])continue;//如果之前搜到过这个状态则跳过
			vis[x][y][key]=1;stp++;//可以则扩展
            q[++t]=(tzg){x,y,key,stp};
			if(x==n&&y==m)return stp;//如果已经走到(n,m)则返回答案
		}
	}
	return -1;//无法抵达
}
int main(){
	pw[1]=1;for(int i=2;i<=15;++i)pw[i]=pw[i-1]<<1;//预处理pw数组
	scanf("%d%d%d",&n,&m,&g);
	scanf("%d",&tot);
	while(tot--){
		scanf("%d%d%d%d%d",&x,&y,&xx,&yy,&g);
		mp[x][y][xx][yy]=mp[xx][yy][x][y]=(g==0?-1:pw[g]);//如果是墙则赋值为-1,否则为对应钥匙编号
	}
	scanf("%d",&tot);
	while(tot--){
		scanf("%d%d%d",&x,&y,&g);
		Key[x][y]|=pw[g];//表示在(x,y)点上有编号为g的钥匙
	}
	cout<<bfs();
	return 0;
}
```


---

## 作者：lizongru (赞：6)

这种状压加最短路的套路在我校今天的集训里面作为签到题出现了（甚至那道题更难），然后晚上就看到了这道题，顺手就把它切了。看到题解里面没有这种堆优化$dijkstra$的做法于是写一发题解。

这道题的题意就相当于一个无向连通图，通过某些边需要满足特定的条件，求起点到终点的最短路。由于这道题中钥匙种类很少，所以可以考虑状压。一个位置拥有某个钥匙$q$则将到达这个点可获得的状态或上一个$(1 << (q - 1))$，某位置$i$与$j$间有门$g$则等价于到达$i$时的状态要包含$(1 << ( g - 1))$才能通过这条路。然后建边时将限制加进去，跑最短路时更新当前状态即可(详见代码)。

所以这道题其实可以出得更难，即支持随意连边及两个位置之间有很多道门。

下面上代码:
```cpp
#include<bits/stdc++.h>
using namespace std;
inline void read(int &x){
    char c = getchar();
    int p = 1;
    x = 0;
    while(!isdigit(c)){
        if(c == '-')p = -1;
        c = getchar();
    }
    while(isdigit(c)){
        x = (x << 1) + (x << 3) + (c ^ '0');
        c = getchar();
    }
    x *= p;
}
const int mx = 405;
struct edge{
    int to, next, lim, w;
}e[mx << 1];
int head[mx], tot, dis[mx][(1 << 11)], n, m, p, k, s, to[mx];
int dir[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
map<pair<int, int>, int>ma1, ma2;
inline int get_pos(int xx, int yy){
    return (xx - 1) * m + yy;
}
#define x first
#define y second
#define mp make_pair
typedef pair<pair<int, int>, int> pii;
priority_queue<pii, vector<pii >, greater<pii > >qu;
inline void add(int u, int v, int w, int lim){
    e[++tot].to = v;
    e[tot].w = w;
    e[tot].lim = lim;
    e[tot].next = head[u];
    head[u] = tot;
}
inline int _min(int a, int b){
    return a < b ? a : b;
}
inline void dij(){
    qu.push(mp(mp(0, 1), 0));
    memset(dis, 0x3f, sizeof(dis));
    int ans = INT_MAX;
    dis[1][0] = 0;
    int N = get_pos(n, m);
    pii tmp;
    while(!qu.empty()){
        tmp = qu.top();
        qu.pop();
        int u = tmp.x.y, w = tmp.x.x, con = tmp.y;
        if(dis[u][con] < w)continue;
        if(u == N)ans = _min(ans, w);
        con |= to[u];
        for(register int i = head[u]; i; i = e[i].next){
            if((con | e[i].lim) != con)continue;
            int v = e[i].to;
            if(dis[v][con] > w + e[i].w){
                dis[v][con] = w + e[i].w;
                qu.push(mp(mp(dis[v][con], v), con));
            }
        }
    }
    if(ans == INT_MAX)puts("-1");
    else printf("%d\n", ans);
}
int main(){
    //freopen(".in", "r", stdin);
    //freopen(".out", "w", stdout);
    read(n), read(m), read(p);
    read(k);
    int xx1, yy1, xx2, yy2, g;
    for(register int i = 1; i <= k; ++i){
        read(xx1), read(yy1), read(xx2), read(yy2), read(g);
        int pos1 = get_pos(xx1, yy1), pos2 = get_pos(xx2, yy2);
        if(g == 0)ma2[mp(pos1, pos2)] = 1, ma2[mp(pos2, pos1)] = 1;
        else ma1[mp(pos1, pos2)] = (1 << (g - 1)), ma1[mp(pos2, pos1)] = (1 << (g - 1));
    }
    read(s);
    int xx, yy, q;
    for(register int i = 1; i <= s; ++i){
        read(xx), read(yy), read(q);
        to[get_pos(xx, yy)] |= (1 << (q - 1));
    }
    for(register int i = 1; i <= n; ++i){
        for(register int j = 1; j <= m; ++j){
            int pos1 = get_pos(i, j);
            for(register int d = 0; d < 4; ++d){
                int xx = i + dir[d][0], yy = j + dir[d][1];
                if(xx >= 1 && xx <= n && yy >= 1 && yy <= m){
                    int pos2 = get_pos(xx, yy);
                    if(ma2[mp(pos1, pos2)]){
                        continue;
                    }
                    add(pos1, pos2, 1, ma1[mp(pos1, pos2)]);
                    add(pos2, pos1, 1, ma1[mp(pos1, pos2)]);
                }
            }
        }
    }
    dij();
    return 0;
}
```

---

## 作者：Refined_heart (赞：5)

题目大意：给一个迷宫，有些地方可以走，有些地方有墙不能走，有些地方有门，有钥匙才能走。问从$(1,1)$走到$(n,m)$的最小步数。

找最小步数，应该可以想到$\text{bfs.}$

那我们想一下，走到一个点，我们要维护哪些信息。

有：当前点坐标$(i,j)$,当前步数$s$,当前拥有的钥匙$v$.

看到数据范围很小，我们可以用状压解决状态问题。也就是说，如果可以开启$Q$类门，那么这个$v$对应二进制第$Q$位就应该是$1$.

当我们遇到一扇门的时候，只需要判断:
```cpp 
v>>d[x][y][xx][yy]&1
```
即可。这段意思是，如果这扇门对应类型$(d[x][y][xx][yy])$对应位置为$1$,则可以到；如果不为$1$，则不能走。

因为那小的可怜的数据范围，所以这个四维数组显然开的下。

我们走到一个格子，要在拾取它的钥匙之前判断，而不是先拾取，后判断。

更新状态的时候不要不小心把基本状态给改了。

当你敲半天敲完代码，发现$52points$,两个$MLE$,一个$TLE$.

考虑剪枝一波。

对于一个点，我们走到这里，要更新的信息有哪些？

更改步数，钥匙信息。

那，如果我们走到这个点，并且钥匙信息相同的话，显然就不用再走了。

开一个数组维护信息剪枝即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,p,k,N,a[11][11];
int d[11][11][11][11];
const int dx[4]={1,0,-1,0};
const int dy[4]={0,1,0,-1};
struct node{int i,j,v,s;};
queue<node>q;
int v[11][11][1<<11];
void solve(){
	int f=0;
	q.push((node){1,1,a[1][1],0});
	while(!q.empty()){
		node tmp=q.front();
		q.pop();
		int x=tmp.i,y=tmp.j,sta=tmp.v;
		if(x==n&&y==m){
			printf("%d\n",tmp.s);
			f=1;break;
		}
		for(int i=0;i<4;++i){
			int xx=dx[i]+x,yy=dy[i]+y;
			if(xx<1||yy<1||xx>n||yy>m||d[x][y][xx][yy]==2147483647||(xx==x&&yy==y))continue;
			if(!d[x][y][xx][yy]){
				if(v[xx][yy][sta|a[xx][yy]])continue;
				q.push((node){xx,yy,sta|a[xx][yy],tmp.s+1});v[xx][yy][sta|a[xx][yy]]=tmp.s+1;
			}
			else{
				if(!(sta>>d[x][y][xx][yy]&1))continue;
				if(v[xx][yy][sta|a[xx][yy]])continue;
				q.push((node){xx,yy,sta|a[xx][yy],tmp.s+1});
				v[xx][yy][sta|a[xx][yy]]=tmp.s+1;
			}
		}
	}
	if(!f)printf("-1\n");
}
int main(){
	scanf("%d%d%d%d",&n,&m,&p,&k);
	for(int i=1;i<=k;++i){
		int x1,y1,x2,y2,g;
		scanf("%d%d%d%d%d",&x1,&y1,&x2,&y2,&g);
		if(g>=1){
			d[x1][y1][x2][y2]=d[x2][y2][x1][y1]=g;
			continue;
		}
		else d[x1][y1][x2][y2]=d[x2][y2][x1][y1]=2147483647;
	}
	scanf("%d",&N);
	for(int i=1;i<=N;++i){
		int x1,y1,Q;
		scanf("%d%d%d",&x1,&y1,&Q);
		a[x1][y1]|=(1<<Q);
	}
	solve();
	return 0;
}
```


---

## 作者：Celebrate (赞：5)

解题方法：状态压缩+BFS

我们把钥匙先状态压缩（感觉这题不是网路流）

定义个结构体

x，y表示坐标，k表示步数，key表示钥匙的情况

v[x][y][tt]表示点（x,y)带有这么多的钥匙是否来过

map[x1][y1][x2][y2]表示两个点直接是否有墙或者是门，0表示可以字节通过

num[x][y]表示点（x,y)有多少把钥匙

g[x][y][i]表示点（x,y）放的第i把钥匙

坑点：（和楼下大佬一样）

1.钥匙不是用了就没了

2.一个点可以放多个钥匙

3.初始点可以放钥匙

4.别忘了输出-1....

上代码：

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<queue>
using namespace std;
struct node
{
    int x,y,k,key;
};
queue<node> q;
bool v[11][11][1<<11];
int map[11][11][11][11];
int g[11][11][11];
int num[11][11];
int n,m,p,k;
int dx[4]={-1,1,0,0};
int dy[4]={0,0,-1,1};
inline int BFS()
{
    int tt=0;
    for(int i=1;i<=num[1][1];i++) tt=tt|(1<<(g[1][1][i]-1));//把点起点的钥匙状态压缩，然后存到栈里面 
    v[1][1][tt]=1;q.push((node){1,1,0,tt});
    while(!q.empty())
    {
        node x=q.front();q.pop();
        if(x.x==n && x.y==m) return x.k;//因为是BFS，找到就直接输出 
        for(int i=0;i<=3;i++)
        {
            int xx=x.x+dx[i];
            int yy=x.y+dy[i];
            if(1<=xx && xx<=n && 1<=yy && yy<=m)//判断边界 
            {
                if(map[x.x][x.y][xx][yy]==-1) continue;//如果不能走 
                int t;
                if((t=map[x.x][x.y][xx][yy])!=0)//如果没有门的钥匙 
                	if((x.key&(1<<(t-1)))==0) continue;
                int tt=x.key;//压缩一下捡到的钥匙 
                for(int j=1;j<=num[xx][yy];j++)
                	tt=tt|(1<<(g[xx][yy][j]-1));
                if(v[xx][yy][tt]) continue;//如果这种方案已经被找过了，就不用再找了 
                v[xx][yy][tt]=1;//记录为找过 
                q.push((node){xx,yy,x.k+1,tt});//入栈 
            }
        }
    }
    return -1;
}
int main()
{
    scanf("%d%d%d%d",&n,&m,&p,&k);//输入以及初始化 
    for(int i=1;i<=k;i++)
    {
        int x1,x2,y1,y2,g;
        scanf("%d%d%d%d%d",&x1,&y1,&x2,&y2,&g);
        if(g==0) map[x1][y1][x2][y2]=map[x2][y2][x1][y1]=-1;
        else     map[x1][y1][x2][y2]=map[x2][y2][x1][y1]=g;
    }
    int s;
    scanf("%d",&s);
    for(int i=1;i<=s;i++)
    {
        int x,y,p;
        scanf("%d%d%d",&x,&y,&p);
        g[x][y][++num[x][y]]=p;
    }
    printf("%d\n",BFS());//输出 
    return 0;
}
```

解答以下疑问：

问：此题为什么用BFS而不是最短路

答：此题为一个矩阵，不用多次更新一个点，先找到的肯定不会比后找到的步数要多

---

## 作者：listenteresaX (赞：4)

#### spfa大法好！释义见代码
代码：
```
#include<iostream>
#include<cstring>
#include<cstdio>
#include<queue>
using namespace std;
int n,m,p,k,s,x,y,xx,yy,dis[18][18][1030],z,zz,ans=2e9;
struct node
{
    int x,y,z;//x,y所在的点，y当前钥匙情况 
}u,f;
queue<node>q;
int dx[]={-1,0,1,0};
int dy[]={0,1,0,-1};
bool v[18][18][1030];
int c[18][18],g[18][18][4];
void add(int x,int y,int xx,int yy,int z)
{
    if(xx==x-1&&yy==y){g[x][y][0]=z;g[xx][yy][2]=z;return;}
    if(xx==x&&yy==y+1){g[x][y][1]=z;g[xx][yy][3]=z;return;}
    if(xx==x+1&&yy==y){g[x][y][2]=z;g[xx][yy][0]=z;return;}
    if(xx==x&&yy==y-1){g[x][y][3]=z;g[xx][yy][1]=z;return;}
    //0,1,2,3与dx[],dy[]方向一致 
}
int main()
{
    cin>>n>>m>>p>>k;
    memset(g,-1,sizeof(g));//g[所在的x][所在的y][要去的方向] 
                            //g=-1:没限制 ；g=0：墙，不能走 ；g>=1&&g<=p 有钥匙的才开门 
    for(int i=1;i<=k;i++)
    {
        scanf("%d%d%d%d%d",&x,&y,&xx,&yy,&z);
        add(x,y,xx,yy,z);//建立方向限制 
    }
    cin>>s;//输入钥匙 
    for(int i=1;i<=s;i++)
    {
        scanf("%d%d%d",&x,&y,&z);
        c[x][y]|=(1<<(z-1));//c[][]:该点所有的钥匙情况 
        // 一点可放多个钥匙， 
    }
    memset(dis,63,sizeof(dis));//spfa 
    f.x=1;
    f.y=1;
    f.z=c[1][1];//起点可以有钥匙 
    q.push(f);
    v[1][1][f.z]=1;
    dis[1][1][f.z]=0;
    while(!q.empty())
    {
        f=q.front();q.pop();
        v[f.x][f.y][f.z]=0;
        for(int i=0;i<4;i++)//向四周走 
        {
            u.x=f.x+dx[i];
            u.y=f.y+dy[i];
            u.z=f.z|c[u.x][u.y];//u：要去的点的情况 
            if(u.x<1||u.x>n||u.y<1||u.y>m||g[f.x][f.y][i]==0||g[f.x][f.y][i]>0&&!(f.z&(1<<(g[f.x][f.y][i]-1))))
            continue;//越界，有墙 ，没钥匙开门  都不行            
            if(dis[u.x][u.y][u.z]>dis[f.x][f.y][f.z]+1)//更新（套路） 
            {
                dis[u.x][u.y][u.z]=dis[f.x][f.y][f.z]+1;
                if(!v[u.x][u.y][u.z])
                {
                    v[u.x][u.y][u.z]=1;
                    q.push(u);
                }
            }
        }
    }
    for(int i=0;i<(1<<p);i++)
    ans=min(ans,dis[n][m][i]);//最短时间 
    if(ans<1e8)cout<<ans;
    else cout<<-1<<endl;//无解 
    return 0;
}
```

---

## 作者：源氏可以吃吗 (赞：3)

### 题目大意
一个迷宫，给定一个N*M的迷宫，给出门与墙的位置还有钥匙的位置
求出从(1,1)到（n,m）的最短路径。
### 解法
BFS无敌。
### 难点
会有多把钥匙几多个门，且门是双向的 。
### 一般人不会踩到的坑
一把钥匙可以重复使用，~~魔塔的锅~~。
### 解题思路
从（1,1）开始直接跑BFS，然后在BFS里判断钥匙和门。
### 下面直接贴代码
```cpp
#include<bits/stdc++.h>//美美的万能头 
using namespace std;
struct Point
{
	int x, y, step;
	bool b[11];//记录是否钥匙 
}s; 
bool used[11][11][2100];
int det[4][2] ={{1,0},{-1,0},{0,1},{0,-1}};
int n, m, p, k, hk;
int g[11][11][11][11];
bool h[11][11][11];
Point q[2001510];//队列开大些，不怕爆空间 
int f = 1, e = 0;
int gen(Point u)
{
	int res = 0, tmp = 1;
	for (int i = 1; i <= 10; i++)
	{
		if (u.b[i] == 1)
		{
			res = res + tmp;
		}
		tmp = tmp * 2;
	}
	return res;
}//二进制压位 
int main()
{
	memset(g, -1, sizeof(g));//memset是好习惯 
	cin >> n >> m >> p >> k;
	if (n == 1 && m == 1)
	{
		cout << 0 << endl;
		return 0;
	}//特判地图大小为1 
	for (int i = 1; i <= k; i++)
	{
		int x1, y1, x2, y2;
		cin >> x1 >> y1 >> x2 >> y2;
		cin >> g[x1][y1][x2][y2];
		g[x2][y2][x1][y1] = g[x1][y1][x2][y2];//门是双向的 
	}
	cin >> hk;
	for (int i = 1; i <= hk; i++)
	{
		int x1, y1, z1;
		cin >> x1 >> y1 >> z1;
		h[x1][y1][z1] = 1; 
	}
	s.x = 1, s.y = 1, s.step = 0;
	memset(s.b, 0, sizeof(s.b));//清空钥匙 
	e++;
	q[e] = s;
	used[1][1][0] = 1;
	while (f <= e)//判断队列是否为空 
	{
		Point u = q[f];
		f++;
		for (int i = 0; i < 4; i++)
		{
			Point v = u;
			v.x = u.x + det[i][0], v.y = u.y + det[i][1], v.step = u.step + 1;
			if (v.x < 1 || v.x > n || v.y < 1 || v.y > m) continue;//若果越界 
			if (g[u.x][u.y][v.x][v.y] == 0) continue;//如果是墙 
			if (g[u.x][u.y][v.x][v.y] > 0 && v.b[   g[u.x][u.y][v.x][v.y]   ] == 0) continue;//如果是门且没有钥匙 
			for (int i = 1; i <= 10; i++)
			{
				if (h[v.x][v.y][i]  == 1)
					v.b[i]  = 1;//捡钥匙 
			}
			if (used[v.x][v.y][gen(v)] == 1) continue; //哈希判重 
			if (v.x == n && v.y == m)
			{
				cout << v.step << endl;
				return 0;//找到终点 
			}
			e++;
			q[e] = v;
			used[v.x][v.y][gen(v)] = 1;//进队列 
		}
	}
	cout << -1 << endl;//如果无解 
	return 0;//华丽的结束 
}
```

---

## 作者：installb (赞：2)

虽然这题在网络流24题里，但是这题可以用**BFS**做   

基础BFS中 状态一般都是某个位置$(x,y)$和步数$step$  
这题还需要记录**目前拥有钥匙**的情况  
即使处在同一位置，拿过钥匙和没拿钥匙的状态是一定不一样的，最直观的理解方式就是边上有一扇门，开门了直接到终点，否则绕很远的路  

记录方式:**状压(状态压缩)**  
**二进制第i位代表是否拥有能开i类门钥匙**  
$p<=10$ 完全没问题  
由于同类钥匙作用相同 只用记录类别 即按门记录钥匙获取状况  

最后就是bfs模板了  

状压使用位运算操作 可以很方便还快地实现很多操作  

小技巧:0直接视为没有对应钥匙的门

## code:
```cpp
#include <map>
#include <list>
#include <queue>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define LL long long
using namespace std;

char vis[11][11][4000] = {0}; // vis[x][y][z]表示在x,y 拥有钥匙情况为z
int key[11][11] = {0}; // 记录一个点钥匙情况(还是状态压缩过的) 注意一个点可能有多把钥匙
int dor[11][11][11][11] = {0}; // 墙直接暴力四维存 方便实现

int n,m,p,k,a,b,c,d,e,tx,ty,i,cnt = 0;
int dx[4] = {-1, 0, 1, 0}; // 方位数组
int dy[4] = { 0,-1, 0, 1};

struct node{
	int x,y,step,key; // 坐标，步数，钥匙
}h,t;

queue <node> q;

void bfs(){
	h.x = 1; h.y = 1; h.step = 0; h.key = key[1][1]; vis[h.x][h.y][h.key] = 1; q.push(h);
	while(!q.empty()){
		h = q.front(); q.pop();
		cnt ++;
		if(h.x == n && h.y == m){
			printf("%lld\n",h.step); // 到终点
			return;
		}
		for(i = 0;i < 4;i ++){
			tx = h.x + dx[i],ty = h.y + dy[i];
			if(tx < 1 || ty < 1 || tx > n || ty > m) continue;
			if(dor[h.x][h.y][tx][ty] >= 0) if(!(h.key & (1 << dor[h.x][h.y][tx][ty]))) continue;
        // 是否有门/是否有开这门的钥匙
			t.x = tx; t.y = ty; t.step = h.step + 1;
			t.key = h.key | key[tx][ty]; // 直接按位或当前格的钥匙
			if(vis[tx][ty][t.key]) continue; // 目前状态已访问过
			vis[tx][ty][t.key] = 1;
			q.push(t);
		}
	}
	printf("-1\n"); // 无解
	return;
}

int main(){
	memset(dor,-1,sizeof(dor));
	scanf("%d %d %d",&n,&m,&p);
	scanf("%d",&k);
	while(k --){
		scanf("%d %d %d %d %d",&a,&b,&c,&d,&e);
		dor[a][b][c][d] = e;
		dor[c][d][a][b] = e; // 存墙
	}
	scanf("%d",&k);
	while(k --){
		scanf("%d %d %d",&a,&b,&c);
		key[a][b] |= (1 << c); // 按位或
	}
	bfs();
	return 0;
}
```

---

## 作者：ez_lcw (赞：2)

# bfs+二进制状压
这跟网络流有个屁关系（虽然不确定是不是可以网络流乱脑一波混过去）

首先看到这题，第一个想法就是bfs暴力。但是这样就考虑到一个问题：因为有可能为了取钥匙而多走很多路或折返，所以就不能设vis或dis数组，所以很有可能存不下~~明明是的确存不下~~

50分代码：

```cpp
#include<queue>
#include<cstring>
#include<cstdio>
 
#define N 15
 
using namespace std;
 
int n,m,p,k,s,door[N][N][N][N],fx[4]= {-1,0,1,0},fy[4]= {0,1,0,-1},key[N][N];
bool vis[N][N];
 
struct data {
    int x,y,s;
    bool key[N];
//  bool operator < (const data &c) const {
//      return s>c.s;
//  }
} now,a;
 
queue<data>q;
 
int read(){
    int x=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=10*x+ch-'0';
        ch=getchar();
    }
    return x;
}
 
bool right(int x,int y) {
    if(x>=1&&x<=n&&y>=1&&y<=m) {
        return true;
    } else {
        return false;
    }
}
 
int dijkstra() {
    a.x=1;
    a.y=1;
    a.key[key[1][1]]=true;
//  vis[1][1]=true;
    q.push(a);
    while(!q.empty()&&(q.front().x!=n||q.front().y!=m)) {
        now=q.front();
        q.pop();
//      printf("%d %d %d\n",now.x,now.y,now.s);
//      if(vis[now.x][now.y]){
//          continue;
//      }
//      vis[now.x][now.y]=true;
        for(int i=0; i<4; i++) {
            int xi=now.x+fx[i];
            int yi=now.y+fy[i];
            if(right(xi,yi)/*&&!vis[xi][yi]*/&&(door[now.x][now.y][xi][yi]&&(door[now.x][now.y][xi][yi]==-1||(now.key[door[now.x][now.y][xi][yi]])))) {
                a=now;
                a.x=xi;
                a.y=yi;
                a.s++;
                a.key[key[xi][yi]]=true;
                q.push(a);
            }
        }
    }
    if(q.empty()) {
        return -1;
    } else {
        return q.front().s;
    }
}
 
int main() {
    memset(door,-1,sizeof(door));
    n=read();m=read();p=read();k=read();
    for(int i=1; i<=k; i++) {
        int xi1,yi1,xi2,yi2,num;
        xi1=read();yi1=read();xi2=read();yi2=read();num=read();
        door[xi1][yi1][xi2][yi2]=num;
        door[xi2][yi2][xi1][yi1]=num;
    }
    s=read();
    for(int i=1; i<=s; i++) {
        int xi,yi,num;
        xi=read();yi=read();num=read();
        key[xi][yi]=num;
    }
    printf("%d\n",dijkstra());
    return 0;
}
```

然后就MLE了2个点，TLE了1个点。

所以这是我们要想，怎么去优化——**状压**。

**状压的主体思路是：用二进制来存是否有这个钥匙，如果有那一位就是1，否则为0，这么做因为2进制只有0或1。比如，有5种钥匙，但我只有1号、3号钥匙，就可以用二进制存为：00101。**

**至于具体的存法，就得涉及到位运算符“|”，它能将两个数转为二进制，然后依次比较每一位，只要这两个数的某一位上有一个为1，那么答案的这一位就为1，否则为0，这样就能更新已有的钥匙。至于看某一个钥匙他有没有，只用将已有的钥匙的二进制数右移（>>）需要的钥匙数位就行了再取末位就行了。**

具体代码如下：

```cpp
#include<queue>
#include<cstring>
#include<cstdio>
  
#define N 11

using namespace std;
  
int n,m,p,k,s,door[N][N][N][N],fx[4]= {-1,0,1,0},fy[4]= {0,1,0,-1},key[N][N];
bool vis[N][N][1000];//前两个框内是坐标，后面是存钥匙的cos

struct data {
    int x,y,s,cos;//前两个框内是坐标，后面是时间和存钥匙的cos
} now,a;
  
queue<data>q;
  
int read(){//快读
    int x=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=10*x+ch-'0';
        ch=getchar();
    }
    return x;
}
  
bool right(int x,int y) {//判断边界
    if(x>=1&&x<=n&&y>=1&&y<=m) {
        return true;
    } else {
        return false;
    }
}
  
bool check(int x,int y,int z,int h,int sum){//判断钥匙是否存在
    int ans=door[x][y][z][h];
    if(!door[x][y][z][h]){//如果是墙
        return 0;
    }
    if(door[x][y][z][h]==-1){//如果既没门也没墙
        return 1;
    }
    return (sum>>ans)&1;//判断有没有钥匙
} 
 
int bfs() {
    q.push((data){1,1,0,0});
    while(!q.empty()&&(q.front().x!=n||q.front().y!=m)) {
        now=q.front();
        q.pop();
        if(vis[now.x][now.y][now.cos]){//如果访问过
            continue;
        }
        vis[now.x][now.y][now.cos]=true;//标记
        for(int i=0; i<4; i++) {
            int xi=now.x+fx[i];
            int yi=now.y+fy[i];
            if(right(xi,yi)&&check(now.x,now.y,xi,yi,now.cos)&&!vis[xi][yi][now.cos]){//判断
                q.push((data){xi,yi,now.s+1,cos|key[xi][yi]});//更新已有钥匙
            }
        }
    }
    if(q.empty()) {//队列空了表示到不了
        return -1;
    } else {
        return q.front().s;//return 时间
    }
}
  
int main() {
    memset(door,-1,sizeof(door));//初始化
    n=read();m=read();p=read();k=read();
    for(int i=1; i<=k; i++) {
        int xi1,yi1,xi2,yi2,num;
        xi1=read();yi1=read();xi2=read();yi2=read();num=read();
        door[xi1][yi1][xi2][yi2]=num;//记住：双向都要建门
        door[xi2][yi2][xi1][yi1]=num;
    }
    s=read();
    for(int i=1; i<=s; i++) {
        int xi,yi,num;
        xi=read();yi=read();num=read();
        key[xi][yi]+=1<<num;//更新这个位置的钥匙数（1<<num是2^num次方的意思，也就是将第num位设为1）
    }
    printf("%d\n",bfs());
    return 0;
}
```
打波广告：[My blog](https://www.luogu.org/blog/lc-2018-Canton/)

---

## 作者：zubizakeli (赞：2)

~~为什么这道题是网络流啊qwq~~

前面两位大佬直接对状态bfs了，我再提供一份建图跑最短路的代码好了=-=

把有没有每种钥匙分成（1<<p）层，然后给每层的每个点编号。

在每层图中如果相邻点之间可达就连距离为1的边。

对于每个有钥匙k的房间，把每一个没有该钥匙k的层s中的该房间向s^(1<<(k-1)) [拿到该钥匙的层] 的该房间连一条距离为0的边。

起点是第0层（一个钥匙都没有）中的（1,1），每层图中的(n,m)向终点t连一条距离为0的边，最后跑spfa即可。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#include<bitset>
#define LL long long
#define RI register int
using namespace std;
const int INF = 0x7ffffff ;
const int N = 10 + 2 ;
const int CC = 100 + 10 ;
const int M = 1e6 + 10 ;
const int NN = 1e6 + 10 ;

const int cx[] = {-1,0,0,1} ;
const int cy[] = {0,1,-1,0} ;

inline int read() {
	int k = 0 , f = 1 ; char c = getchar() ;
	for( ; !isdigit(c) ; c = getchar())
	  if(c == '-') f = -1 ;
	for( ; isdigit(c) ; c = getchar())
	  k = k*10 + c-'0' ;
	return k*f ;
}
struct Edge {
	int to, next, val ;
}e[M] ;
int n, m, p, k, t ; int head[NN], dis[NN] ;
int noo[N][N][N][N] ; // 11表示墙，其他正整数表示哪个钥匙可以开这两个点之间的门，0表示畅通 
inline void add_edge(int x,int y,int vv) {
	static int cnt = 1 ;
	e[++cnt].to = y, e[cnt].next = head[x], head[x] = cnt, e[cnt].val = vv ;
}

inline void spfa() {
	for(int i=1;i<=NN;i++) dis[i] = INF ; int s = 1 ;
	deque<int>q ; q.push_back(s) ; dis[s] = 0 ; bitset<NN>inq ;  // 双向队列优化
	while(!q.empty()) {
		int x = q.front() ; q.pop_front() ;
		for(int i=head[x];i;i=e[i].next) {
			int y = e[i].to ;
			if(dis[y] > dis[x]+e[i].val) {
				dis[y] = dis[x]+e[i].val ;
				if(!inq[y]) {
					if(!q.empty() && dis[y] < dis[q.front()]) q.push_front(y) ;
					else q.push_back(y) ;
					inq[y] = 1 ;
				}
			}
		}
		inq[x] = 0 ;
	}
	if(dis[t] == INF) printf("-1") ;
	else printf("%d",dis[t]) ;
}

int main() {
	n = read(), m = read(), p = read(), k = read() ; t = NN-10 ;
	int x1, y1, x2, y2, ii ;
	for(int i=1;i<=k;i++) {
		x1 = read(), y1 = read(), x2 = read(), y2 = read(), ii = read() ;
		if(!ii) {
			noo[x1][y1][x2][y2] = noo[x2][y2][x1][y1] = 11 ;
		} else noo[x1][y1][x2][y2] = noo[x2][y2][x1][y1] = ii ;
	}
	for(int s=0;s<(1<<p);s++) {    // 对于每一层建图 
		for(int i=1;i<=n;i++) {
			for(int j=1;j<=m;j++) {
				int p = s*CC + (i-1)*m + j ;
				for(int k=0;k<4;k++) {
					int xx = i+cx[k], yy = j+cy[k] ;
					if(!xx || !yy || xx > n || yy > m) continue ;
					int pp = s*CC + (xx-1)*m + yy ;
					if( !noo[i][j][xx][yy] || (s&(1<<(noo[i][j][xx][yy]-1))) ) 
					  add_edge(p,pp,1), add_edge(pp,p,1) ;
				}
			}
		}
	}
	int nn = read() ;
	for(int i=1;i<=nn;i++) {   // 不同层之间的处理 
		int x = read(), y = read(), kk = read() ;
		for(int s=0;s<(1<<p);s++) {
			if(!(s&(1<<(kk-1)))) { // 没有该钥匙的状态可以转移到有该钥匙的状态 
				int p1 = s*CC + (x-1)*m + y, p2 = (s^(1<<(kk-1)))*CC + (x-1)*m + y ;
				add_edge(p1,p2,0) ;
			}
		}
	}
	for(int s=0;s<(1<<p);s++) add_edge(s*CC+n*m,t,0) ;
	spfa() ;
	return 0 ;
}
```

（在编号建图时编号的不重复很关键qwq）

---

## 作者：S_S_H (赞：1)

$Back$ $to$ $OI$ $!!!$

今天刷了一道状压，感觉是假紫题。（虽然不加剪枝卡到52分）

题目描述：给定$n\times m$的迷宫，有些格子间有墙和门，而有些格子里有对

应门的钥匙，求出$(1,1)$到$(n,m)$的最短路。

数据范围:$n,m<=10$，钥匙数$p<=14$

数据范围小于20，~~不是爆搜就是状压~~。

由于地图很小，我们可以用四维$check$数组存信息。

而本题求最短路，我们就可以用$BFS$来求。

这里就可以用状压来压缩钥匙的状态，并用位运算来判断能否通过门。

然而本题到这里就只有$52$分$......$因为没有剪枝！！！

棋盘很小，最大就是$10\times 10$，所以状态会很冗杂，我们就需要剪枝。

很基本的剪枝啦，记一下在某一个点上的钥匙状态有没有被经过就好。

剩下的就是一些细节啦：

1.起始点可以放钥匙。

2.一个格子可以有很多钥匙。

$Code$:

```cpp
#include<iostream>
#include<queue>
#include<cstdio>
using namespace std;
int n,m,p,k,s,map[12][12],check[12][12][12][12];
int tx[6]={1,-1,0,0};
int ty[6]={0,0,1,-1};
bool vis[12][12][32768];
struct node{
	int x,y,step,key;//坐标，步数，钥匙
};
int bfs(){
	if(n==1&&m==1) return 0;//特判，数据中并没有卡这个点
	queue<node>q;
	node now=(node){1,1,0,map[1][1]};//起始点可以有钥匙
	q.push(now);
	while(q.size()){
		node now=q.front();
		for(int i=0;i<=3;i++){
			int kx=now.x+tx[i];
			int ky=now.y+ty[i];
			if(kx>=1&&kx<=n&&ky>=1&&ky<=m){
				if((now.key&check[now.x][now.y][kx][ky])||(!check[now.x][now.y][kx][ky])){//这个是位运算，因为格子间的钥匙唯一，如果手中有的话进行一下与运算就可以判断
					node to=(node){kx,ky,now.step+1,now.key|map[kx][ky]};
					if(kx==n&&ky==m) return now.step+1;
					if(vis[kx][ky][to.key]) continue;//这里是剪枝
					vis[kx][ky][to.key]=true;
					q.push(to);
				}
			}
		}
		q.pop();
	}
	return -1;
}
int main(){
	scanf("%d%d%d%d",&n,&m,&p,&k);
	for(int i=1;i<=k;i++){
		int x1,y1,x2,y2,d;
		scanf("%d%d%d%d%d",&x1,&y1,&x2,&y2,&d);
		if(!d) check[x1][y1][x2][y2]=check[x2][y2][x1][y1]=1<<p;
		else check[x1][y1][x2][y2]=check[x2][y2][x1][y1]=1<<(d-1);//这里说一下，因为墙不能走（没有钥匙），我们就可以把它设为1<<p，这样就不会出现可以符合墙的钥匙
	}
	scanf("%d",&s);
	for(int i=1;i<=s;i++){
		int x,y,d;
		scanf("%d%d%d",&x,&y,&d);
		map[x][y]|=1<<(d-1);//注意这里，可能有多把钥匙
	}
	printf("%d\n",bfs());
	return 0;
}
```
祝大家$2020$ $CSP$ $NOI$ $XXXOI$ $RP++!!!$

---

## 作者：SKTelecomT1_Faker (赞：1)

```cpp
#include<bits/stdc++.h>
using namespace std;
struct Point
{
    int x,y,step;
    int key;
};
int det[4][2]={{1,0},{-1,0},{0,1},{0,-1}};
Point q[500000],s;
int f=1,e=1;
bool used[20][20][1024];
int g[20][20][20][20];
int n,m,p,k,ks;
int gk[20][20][10],len[20][20];
int main()
{
    cin>>n>>m>>p>>k;
    for (int i=1;i<=k;i++)
    {
        int xa,ya,xb,yb;
        cin>>xa>>ya>>xb>>yb;
        cin>>g[xa][ya][xb][yb];
        if (g[xa][ya][xb][yb] == 0) g[xa][ya][xb][yb] = -1;
        g[xb][yb][xa][ya] = g[xa][ya][xb][yb];
    }
    cin>>ks;
    for (int i=1;i<=ks;i++)
    {
        int x,y;
        cin>>x>>y;
        len[x][y]++;
        cin>>gk[x][y][len[x][y]]; 
    }
    s.x=1,s.y=1;
    s.step=0,s.key=0;
    used[1][1][0]=1;
    q[1]=s;
    while(f<=e)
    {
        Point u=q[f];
        f++;
        for (int i=0; i<4;i++)
        {
            Point v;
            v.x=u.x+det[i][0], v.y=u.y+det[i][1];
            v.step=u.step+1;
            v.key=u.key;
            if (v.x<1||v.x>n) continue;
            if (v.y<1||v.y>m) continue;
            if (g[u.x][u.y][v.x][v.y]==-1) continue;
            int tmp=g[u.x][u.y][v.x][v.y];
            if (tmp>0) 
            { 
                if ((u.key>>(tmp-1))%2== 0)
                    continue;
            }
            if (len[v.x][v.y]!=0)
            {
                for (int j=1;j<=len[v.x][v.y];j++)
                {
                    int tmp=gk[v.x][v.y][j];
                    if ((u.key>>(tmp-1))%2==0)
                        v.key+=(1<<(tmp-1)) ;
                }
            }
            if (used[v.x][v.y][v.key]==0)
            {
                e++;
                q[e]=v;
                used[v.x][v.y][v.key]=1;
                if (v.x==n&&v.y==m) 
                {
                    cout<<v.step<<endl;
                    return 0;
                }
            }
        }
    }
    cout<<-1;
    return 0;
}
```
这是一道很难很难的宽搜的题目（紫题！），但只要弄清思路难度不大（怎样表示当前状态）。

在这个题目中，**关键是怎么表示当前拿到钥匙的状态**，用结构体来模拟队列——最基本的思路。可以开一个多维数组来记录哪些状态已经有过了，防止重复入队导致答案出错。

定义一个字符串，每一位对应每一把钥匙的状态拿到钥匙是1，没有拿到是0，第一位是0.比如，现在我的状态是“000000000”，表示没有钥匙。当我走到一个格子，里面有四、七号钥匙，只要把s[4]，s[7]改为‘1’就行了，状态更新为“0000100100”。之后就是基本的宽搜套路，记得不行输出-1.

希望我的解说对大家有帮助。


---

## 作者：Conrad (赞：1)

### 思路：
**分层图**+（稀有的）**dijkstra**
### 解题步骤：
#### 0. 读入
1). 这一步……不讲了吧！
#### 1. 建图
1). 分层图是将图分成（**1<<钥匙种类**）层（注意：我发现其他dalao们都是以**p**为**钥匙种类**，我认为不妥。因为题目中**p**也**包含了墙**，因此**加大了计算量**！！！）；

2). 连接层内连边：从每个点**向下**和**向右**连边。如果有墙，就不连，否则连一条**权值为1**的边；

3). 各层间连边：用‘&’位运算来查找**哪一层有所需要的钥匙**，在两个位置间连一条权值为0的边。
#### 2. 最短路求答案
1). 最短路求出**dis**数组；

2). 枚举**每一层**的“入口”，求出答案。



------------
上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int read()
{
	int f=1,res=0;char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9') res=res*10+ch-'0',ch=getchar();
	return res*f;
}
#define inf 999999
struct node
{
    int k,dis;
    bool operator<(const node &a)const
    {
        return a.dis<dis;
    }
};
priority_queue<node> q;
struct edge{int x,y;}kypos[20][20];
int ans=inf,row,line,p,keyn,K,S,tot=0,sum=0,all=0,layer=0;
int dis[(1<<14)*100],v[(1<<14)*100],kycnt[15],cc[15],num[200][200],fg[200][200];
vector<int> nxt[(1<<14)*100],far[(1<<14)*100];
void init()
{
	row=read(),line=read(),p=read(),K=read();
	for(int i=1; i<=row; i++)
		for(int j=1; j<=line; j++) num[i][j]=++sum;
	for(int i=1; i<=K; i++)
	{
		int x1=read(),y1=read(),x2=read(),y2=read(),g=read();
		int j=num[x1][y1],k=num[x2][y2];
		if(g&&!cc[g]) cc[g]++,keyn++;
		if(!g) g=-1;
		fg[j][k]=g;
	}
	S=read();
	for(int i=1; i<=S; i++)
	{
		int x=read(),y=read(),q=read();
		if(!cc[q]) cc[q]++,keyn++;
		kycnt[q]++,kypos[q][kycnt[q]].x=x,kypos[q][kycnt[q]].y=y;
	}
	keyn++;
}
void add(int x,int y,int w)
{
	nxt[x].push_back(y),far[x].push_back(w);
}
void build()
{
	bool kyflag[20]={0};
	sum=row*line,layer=1<<keyn,all=layer*sum;
	for(int k=0; k<layer; k++)
	{
		for(int i=1; i<=keyn; i++)
			if(k&(1<<(i-1))) kyflag[i]=true;
			else kyflag[i]=false;
		for(int i=1; i<=row; i++)
			for(int j=1; j<=line; j++)
			{
				int x=num[i][j],y=num[i+1][j];
				if(y&&fg[x][y]!=-1)
					if(!fg[x][y]||kyflag[fg[x][y]]) add(k*sum+x,k*sum+y,1),add(k*sum+y,k*sum+x,1);
				y=num[i][j+1];
				if(y&&fg[x][y]!=-1)
					if(!fg[x][y]||kyflag[fg[x][y]]) add(k*sum+x,k*sum+y,1),add(k*sum+y,k*sum+x,1);
			}
		for(int i=1; i<=keyn; i++)
			if(!kyflag[i])
			{
				int x=k+(1<<(i-1));
				for(int j=1; j<=kycnt[i]; j++)
				{
					int p=num[kypos[i][j].x][kypos[i][j].y];
					add(k*sum+p,x*sum+p,0);
				}
			}
	}
}
void dijkstra()
{
    memset(v,0,sizeof(v));
    for(int i=1; i<=all; i++) dis[i]=inf;
    dis[1]=0,q.push((node){1,0});
    while(!q.empty())
    {
        int x=q.top().k;q.pop();
        if(v[x]) continue;v[x]=1;
        for(int i=0; i<nxt[x].size(); i++) 
        {
            int y=nxt[x][i],z=far[x][i];
            if(dis[y]>dis[x]+z)
            {
                dis[y]=dis[x]+z;
            	q.push((node){y,dis[y]});
    		}
		}
	}
}
void solve()
{
	int i,T;
	dijkstra();
	T=num[row][line];
	for(int i=0; i<layer; i++) ans=min(ans,dis[i*sum+T]);
	/*
	int x=0;
	for(int i=0; i<layer; i++)
	{
		for(int j=1; j<=row; j++)
		{
			for(int k=1; k<=line; k++) cout<<dis[++x]<<" ";
			cout<<endl;
		}
		cout<<endl;
	}
	*/
	if(ans<inf) printf("%d\n",ans);
	else puts("-1");
}
int main()
{
	init();
	build();
	solve();
	return 0;
}
```


---


# 「Wdsr-2.5」第二次月面战争

## 题目背景

若干年之前，八云紫策划了第二次月面战争。

作为神社的巫女，灵梦自然有保护人间之里人类的职责。为了能够使得人类免受月面战争可能造成的影响，灵梦决定在博丽神社设立一个结界。

由于结界的影响范围有限，只能覆盖到博丽神社，于是灵梦决定将人间之里的所有居民迁入到神社中去。然而由于居民数目较多，灵梦在组织上出现了一些困难。这时，她找到了外界的你，希望你帮助她解决这个问题。

## 题目描述

人间之里可以看做一张 $n$ 个点 $m$ 条边的有向图，而博丽神社在点 $t$ 。然而由于时间差的原因，灵梦不能一次性获取所有居民的位置，于是她会依次受到 $k$ 条消息，每条信息包含一个节点 $x$。

- 如果 $x$ 号节点本来没有居民，那么灵梦得知了有一个居民在 $x$ 号节点。
- 如果 $x$ 号节点本来有居民，那么由于某些原因， $x$ 号节点现在没有居民了。

由于某些原因，在 $t$ 号节点也有可能存在居民。

每当得知一条新的消息后，灵梦都需要快速计算出居民的最快疏散时间，以便于合理安排（此时，你可以认为其他节点上没有居民）。同时为了避免拥挤，以及其他难以预料的困难，灵梦做出了如下规则：

- 每一时刻，每个居民只能沿着一条有向边走一步，或者**停留在原地**。
- 每一时刻，每个节点上，**最多只能有一位居民**。
- 当居民到达了博丽神社，那么**下一时刻**他就可以进入结界以获得庇护。你可以认为，在居民进入结界后他的行程就结束了。

最快疏散时间，指的是**所有居民**全部进入结界的最短用时。

## 说明/提示

#### 样例 1 说明

![main1.png](https://i.loli.net/2021/03/26/bWyznVgRc1pqPaf.png)

这张图描述了**初始状态**、**第一次操作**、**第二次操作**的情况。可以发现；

- 第一次操作后， $7$ 号节点最快通过 $7\to 6\to 1$ 到达神社，再花费 $1$ 单位时间进入神社，总共用时 $3$ 单位时间。
- 第二次操作后， $1$ 号节点花费 $1$ 时刻进入神社， $7$ 号节点仍然按照 $7\to 6\to 1$ 到达神社，并花费 $1$ 单位时间进入神社即可。总共花费 $3$ 单位时间。

![main2.png](https://i.loli.net/2021/03/26/sr3kbOWh7PxBway.png)

这张图描述了第三次操作后的情况。

第一时刻， $1$ 进入神社， $2\to 1,7\to 6$ ；第二时刻， $1$ 进入神社， $6\to 1$ ；第三时刻所有人都进入了神社，于是总共花费 $3$ 单位时间。

![main3.png](https://i.loli.net/2021/03/26/IWt7zKPohpFBmfV.png)

这张图描述了第四次操作后的情况。

第一时刻， $1$ 进入神社， $3\to 1,7\to 6$ ， $2$ 不动；第二时刻， $1$ 进入神社， $2\to 1$ ， $6$ 不动。接下来花费 $2$ 时刻全部进入神社，于是总共花费 $4$ 单位时间。

#### 样例 2,3

见下发附件。

#### 数据范围及约定

$$
\def\bd{\boldsymbol}
\def\a{\texttt{A}}	% 链的性质
\def\b{\texttt{B}}	% 菊花图的性质
\def\p{\texttt{P}}	% k为正的性质
\def\n{\text{无特殊限制}}
\def\l{\hline}
\def\arraystretch{1.5}\begin{array}{|c|c|c|c|c|}\l
\textbf{数据点} & \bd{n} & \bd{m} & \bd{k} & \textbf{特殊性质} \cr\l
1\sim4 & n\le 8 & m\le 10 & k\le 10 & - \cr\l
5,6 & \n & m=n-1 & \n & \p,\a \cr\l
7,8 & \n & m=n-1 & \n & \p,\b \cr\l
9 & n\le 10^5 & m=n-1 & k\le 10^5 & \p \cr\l
10\sim 12 & n\le 10^3 & m\le 10^3 & k\le 10^3 & - \cr\l
13,14 & n\le 10^5 & m\le 10^5 & k\le 10^5 & \p \cr\l
15\sim 17 & n\le 10^5 & m\le 10^5 & k\le 10^5 & - \cr\l
18\sim 20 & \n & \n & \n & - \cr\l
\end{array}
$$

- 特殊性质 $\texttt{P}:$ 保证只存在出现居民的操作。
- 特殊性质 $\texttt{A}:$ 保证整张图是一条链，但不保证 $t$ 是链的一端。
- 特殊性质 $\texttt{B}:$ 保证除了 $t$ 以外的所有节点，都指向 $t$ 。


对于所有数据，满足 $1\le n\le 10^6; 1\le m\le 1.05\times 10^6;1\le k\le 10^6$ 。保证所有节点可以到达 $t$。

## 样例 #1

### 输入

```
7 7 4 1
2 1
3 1
4 2
5 2
6 1
7 6
3 2
7 1 2 3
```

### 输出

```
3
3
3
4
```

# 题解

## 作者：囧仙 (赞：6)

## 题解

先考虑一个简化的问题： 

> $k$ 个人，每个人距离 $t$ 的最近距离为 $dist_i$ 。然后我们要让他们到达神社。

其实这玩意有两种思路，貌似都是对的（

## 想法

### 思路一

考虑让所有人同时沿着最短路向神社走去。可能发生的最糟糕的情况是，两个人挤占了同一个点，但是我们不知道他们什么时候相撞。但是事实上我们根本不需要考虑相撞的地点。只要假想一个时间轴，我们现在将第 $i$ 个人插入到 $dist_i$ 位置。如果已经被占用了，那就向后插入到第一个没有被插入的位置。最后一个被占用的位置所在的点就是答案。

~~至于为什么正确，感性理解吧~~。一个人 $i$ 会停留在原地，当且仅当他要到达的下一个点被占用了。他后面可能有个人 $j$ 也要到达 $i$ 所在的位置，**这样的前提是他的最短路和 $\boldsymbol{i}$ 重叠**。 $j$ 可不可以绕路呢？事实上是不行的，因为 $i$ 排队的原因是 $i$ 要走的路被占掉了， $j$ 试图包抄也会被阻挡。如果 $j$ 能先于 $i$ 到达被占用的节点，那就与 $j$ 走的是最短路相不符，所以无论如何 $j$ 都会被阻塞。

### 思路二

刚刚那个思路是屑波（@离散小波变换° ）想出来的，可谓是非常难以理解（）下面的思路是 $\text{chenxinyang2006}$ 提供的。

考虑按照 $dist_i$ 的大小，从大到小决定每个人。我们将“每个人走到神社”转换为“神社里的人走到相应的位置”。 $dist$ 大的人显然不会阻拦 $dist$ 小的人，如果 $dist$ 相同，那就按照顺序出来。于是第 $i$ 个人花费的时间应该是 $dist_i+rank_i$ ，其中 $rank_i$ 表示 $dist_j$ **不小于** $i$ 的 $j$ 有多少个。显然这样是正确的（

事实上，出题人写了两个程序的暴力代码并且进行了一些对拍，并没有拍出不同的数据点。可以验证这两种思路都是对的。下面考虑如何实现。

## 求解

两种做法都可以用 $\mathcal O(n\log n)$ 的时间复杂度实现。我们关心的是如何动态维护两个东西。

### 思路一

我们需要动态插入/删除一个人，并且找到最靠后的那个人。一种可行的做法是，维护一个数列 $\{P_i\}$ ，其中 $P_i$ 表示，在时间轴上仅考虑前 $i$ 个点，从第 $i$ 个位置起，还需要排多少个人才可以将积攒的人全部排完；如果当前第 $i$ 个位置没有人，那就令 $P_i=-1$ （定义有点复杂……）考虑去维护。

插入一个人 $i$ ，他的位置为 $dist_i$ ，那么我们就要找到第一个空闲的位置（即，第一个满足 $P_{j}=-1,j\ge dist_i$ 的那个 $j$） $x$ ，然后让 $P_{j}\gets P_{j}+1 (j=dist_i,dist_i+1,\cdots x)$ 。删除一个人 $i$ ，我们就要找到他影响到的所有的 $P_j$ ，然后令 $P_{j}\gets P_j-1$ 。可以发现，这样的 $j$ 就是满足 $P_{j}=0,j\ge dist_i$ 的第一个 $j$ 。

考虑如何去快速查询、快速区间修改。我们用一棵线段树维护 $\{P_i\}$ ，每个节点存储该区间的最小值 ，以及用于区间加减的 $\text{tag}$ 。食用方法和普通线段树差不多，只要维护就完事了。关键是查询。我们要查询 $[dist_i,+\infty)$ 里第一个 $0$ 和 $-1$ ，考虑线段树上二分。假设我们要求 $[x,+\infty)$ 第一个 $k$ ，目前在线段树上节点 $p$ ，那就看它左侧的节点的最小值是否不超过 $k$ ；如果是，就查询左节点，否则查询右节点。（因为本题的特殊性质， $0$ 必定在 $-1$ 前面，所以维护最小值是正确的。）顺便完成区间修改就行了。

复杂度是 $\mathcal O(q\log n)$ 的。

### 思路二

为了方便操作，我们使用值域线段树，用来维护每个 $dist$ 的贡献 $Q_i$ 。（其实也可以维护每个人的贡献，而这是 $\rm cxy$ 代码的做法。这里仅讨论前者）初始时线段树上每个节点权值设为 $0$ ，当插入第 $i$ 个人时，设 $d=dist_i$ ，我们需要判断之前有没有点在 $d$ ，如果没有，那就要对应的点的权值加上 $d$ （根据贡献的计算式子），即 $Q_d\gets Q_d+d$ 。以及他前面所有 $dist$ 的贡献都要加上 $1$ ；删除第 $i$ 个人，那就要判断删除后是否还存在点在 $d$ ，如果是，那也要令 $Q_d\gets Q_d-d$ 。同时让它前面的 $dist$ 的贡献都减去 $1$ 。每次操作完，查询全局最大值作为答案就行了。

具体操作非常简单，就不细讲了（

---

顺带一提， $10^5$ 的测试点是留给奇妙的 $\mathcal O(q\log^2 n)$ 做法的。尽管我不大清楚是否真的有这样的算法（

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long LL;
const int INF =2147483647;
const int SIZ =1e6;
char buf[SIZ],*p1,*p2;
char readc(){
    if(p1==p2) p1=buf,p2=buf+fread(buf,1,SIZ,stdin);
    return *p1++;
}
int qread(){
	int w=1,c,r=0;
	while((c=readc())> '9'||c< '0') w=(c=='-'?-1:1); r=c-'0';
	while((c=readc())>='0'&&c<='9') r=r*10+c-'0';
	return r*w;
}
const int MAXN =1.05e6+3,MAXM=1.2e6+3;
namespace Gra{
	int H[MAXN],V[MAXM],N[MAXM],t,D[MAXN]; bool F[MAXN];
	void add(int u,int v){V[++t]=v,N[t]=H[u],H[u]=t;} 
    queue <int> Q;
    void bfs(int u){
        Q.push(u); while(!Q.empty()){
            int a=Q.front(); Q.pop(); for(int i=H[a],b;i;i=N[i]){
                if(!F[b=V[i]]) F[b]=true,Q.push(b),D[b]=D[a]+1;
            }
        }
    }
}
int n,l,m,q,t,C[MAXN];
namespace Seg{
	unsigned int W[MAXN*2],T[MAXN*2],M[MAXN*2],F[MAXN],w,t;
	inline void inc(unsigned int p){
        if(!F[p]) M[p|n]+=p; ++F[p],p|=n; ++M[p];
        up(1,l,i){
            if(p&1) ++T[p^1],++M[p^1]; M[p>>1]=max(M[p],M[p^1])+T[p>>1]; p>>=1;
        }
    }
    inline void dec(unsigned int p){
        --F[p];if(!F[p]) M[p|n]-=p; p|=n; --M[p];
        up(1,l,i){
            if(p&1) --T[p^1],--M[p^1]; M[p>>1]=max(M[p],M[p^1])+T[p>>1]; p>>=1;
        }
    }
}
bool O[MAXN];
int main(){
	n=qread(),m=qread(),q=qread(),t=qread();
	for(l=1;(1<<l)<=n;++l); n=1<<l;
	up(1,m,i){int u=qread(),v=qread();Gra::add(v,u);}
	Gra::D[t]=1,Gra::F[t]=true,Gra::bfs(t);
    up(1,q,i){
        int x=qread(); O[x]?Seg::dec(Gra::D[x]):Seg::inc(Gra::D[x]);
        O[x]^=1,printf("%d\n",Seg::M[1]-1);
    }
	return 0;
}

```

---

## 作者：Karl_Aurora (赞：3)

**[~~无耻地推销个人博客 qwq~~](https://www.luogu.com.cn/blog/ling-XAIqwq/solution-p7508)**

**[题目传送门](https://www.luogu.com.cn/problem/P7508)**

------------

## 题意

给定一个有向图，其中若干个点上有人，每个人每个单位时间可以沿着一条边移动，且每个点最多只能容纳一人，求所有人全部移动到节点 $t$ 的最短用时，带修。

## 解法

和 Golden_Cat 神仙在机房里讨论这道题，结果两个人分别口胡出了官方题解的两种做法，这边选我想出来的的比较简单的 ~~（也许吧）~~ 一种思路来讲。（stO Golden_Cat Orz）

我们发现这个多起点多出发时间往终点靠拢的过程正向可能比较难以处理，结合之前多校联合集训时的一些抽象题的经验 ~~（说的就是你，往NOIP模拟赛中赛P5163这种重工业题的华师一）~~，可以想到去尝试把整个过程逆向处理。

所以这个问题就变成了若干个人依次从起点出发走向各自的终点，由于所有人速度都是一样的，那么先出发的人一定在后出发的人之前，所以就有这样一个非常好的性质：

一个人停下来，当且仅当他要去的结点上有人也停了下来。

而这个堵车链条想要启动，只可能是有人已经停在了其对应的终点，所以我们只要把所有人按照路程长度排序，让要走的路程更远的人先走，就可以在整个过程中规避堵车。

所以令第 $i$ 个人要走的路程长度为 $dis_i$，他按路程从大到小排在第 $rnk_i$，那么他算上排队时间从起点走到终点所需的时间就为 $dis_i+rnk_i-1$，将所有的结果取最大值即可。

但是这道题带修，所以我们需要一个可以维护 $rnk$ 的数据结构，那么很显然，值域线段树，启动！

然后这道题就做完了。

最后代码如下：

```cpp
#include <bits/stdc++.h>
#define maxn 1000010
#define maxm 2000010
#define writeln(X) write(X), putchar('\n')
#define lson(X) (X << 1)
#define rson(X) ((X << 1) | 1)
#define mid ((l + r) >> 1)
#define segroot 1
using namespace std;
static char buf[1 << 23], *p1 = buf, *p2 = buf, obuf[1 << 23], *O = obuf;
#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 22, stdin), p1 == p2) ? EOF : *p1++)
#define putchar(X) *O++ = (X)
template < typename T > 
inline void read(T &X)
{
    X = 0; bool f = false; char ch = getchar();
    while (!isdigit(ch)) {f |= ch == '-'; ch = getchar();}
    while (isdigit(ch)) {X = (X * 10) + (ch ^ 48); ch = getchar();}
    X = f ? -X : X;
}
template < typename T >
inline void write(T X)
{
    if (X == 0) {putchar('0'); return;}
    if (X < 0) {putchar('-'); X = -X;}
    static char cnt = 0, num[20];
    while (X) {*(num + cnt++) = (X % 10) ^ 48; X /= 10;}
    while (cnt) putchar(*(num + --cnt));
}
struct side {int to, next;} sidelist[maxm];
int sidecnt, sidehead[maxn];
inline void buildside(const int &u, const int &v) {sidelist[++sidecnt] = {v, sidehead[u]}; sidehead[u] = sidecnt;}
int seg[maxm << 2], lazytag[maxn << 2];
inline void pushtag(const int &x) {lazytag[lson(x)] += lazytag[x]; lazytag[rson(x)] += lazytag[x]; seg[x] += lazytag[x]; lazytag[x] = 0;}
inline void update(const int &x) {seg[x] = max(seg[lson(x)] + lazytag[lson(x)], seg[rson(x)] + lazytag[rson(x)]);}
int inseg[maxm];
bool have_man[maxn];
void change(const int &x, const int &l, const int &r, const int &lx, const int &rx, const int &val)
{
    if (l > r || lx > rx) return;
    if (l >= lx && r <= rx) {lazytag[x] += val; return;}
    pushtag(x);
    if (mid >= lx) change(lson(x), l, mid, lx, rx, val);
    if (mid < rx) change(rson(x), mid + 1, r, lx, rx, val);
    update(x);
    return;
}
int n, m, k, t;
queue < int > q;
int dis[maxn];
int main()
{
#ifndef ONLINE_JUDGE
    freopen("P7508.in", "r", stdin);
    freopen("P7508.out", "w", stdout);
#endif
    read(n); read(m); read(k); read(t);
    for (int i = 1; i <= m; ++i)
    {
        int u, v;
        read(u); read(v);
        buildside(v, u);
    }
    memset(dis, 0x3f, sizeof(dis));
    dis[t] = 1; q.emplace(t);
    while (!q.empty())
    {
        int u = q.front(); q.pop();
        for (int i = sidehead[u]; i; i = sidelist[i].next)
        {
            int v = sidelist[i].to;
            if (dis[u] + 1 < dis[v]) {dis[v] = dis[u] + 1; q.emplace(v);}
        }
    }
    for (int i = 1; i <= k; ++i)
    {
        int x;
        read(x);
        if (!have_man[x])
        {
            have_man[x] = true;
            x = dis[x];
            if (!inseg[x]) change(segroot, 1, m, x, x, x);
            ++inseg[x];
            change(segroot, 1, m, 1, x, 1);
            writeln(seg[segroot] + lazytag[segroot] - 1);
        }
        else
        {
            have_man[x] = false;
            x = dis[x];
            --inseg[x];
            if (!inseg[x]) change(segroot, 1, m, x, x, -x);
            change(segroot, 1, m, 1, x, -1);
            writeln(seg[segroot] + lazytag[segroot] - 1);
        }
    }
    fwrite(obuf, O - obuf, 1, stdout);
    fclose(stdin); fclose(stdin);
    return 0;
}
```

至此，愉快 AC，完结撒花

---

## 作者：迟暮天复明 (赞：1)

通过了神奇的方法砍了过去。

首先不难证明每个居民只会从最短路走过去。

证明：如果某个居民有 $s$ 和 $s'$ 两条路可以走，且 $s'>s$，那么可能会发生以下两种情况：

+ 该居民从 $s$ 走过去不需要排队排到 $s'$ 的时刻，那么显然 $s$ 比 $s'$ 优。
+ 该居民从 $s$ 走过去要排队排到 $s'$ 以后，那么怎么走都一样。

所以他只可能选择从 $s$ 这条路走过去，于是原图就被缩成一个 DAG 了。

假设某一次询问的答案为 $T$，那么显然需要满足从每个起点到终点的最短路的最大值不能超过 $T$，以及对于每个小于 $T$ 的时刻 $x$，要求 $T-x$ 不小于最短路大于等于 $x$ 的点数 $k$。

设每个起点到终点的最短路的最大值为 $S$，后面一项用前缀和拆开就变成了 $T-x\ge sum_S-sum_x$，也就是 $T-sum_S\ge x-sum_x$，其中 $x\le S$。

然后 $S$ 和 $x-sum_x$ 都是可以大力线段树维护的，于是这个题就做完了。但是我这个做法卡常比较的严重（本来用 STL 的可重集维护 $S$ 然后时间烂了）。

贴个[代码](https://paste.ubuntu.com/p/drDC25rGSH/)

---

## 作者：_Cheems (赞：0)

贪心地想，肯定是让每个点走最短路，不妨记为 $dist_i$，但是会出现冲突。

结论：若 $dist_x\ne dist_y$，则一定不会冲突，反之一定冲突。

倒推可证。

那么考虑逐个插入 $dist_i$，若已有 $dist_j=dist_i$，那就让 $dist_i$ 增加直到没有相同的即可。

不过这个东西不太好维护的亚子，注意到：若将所有 $dist_i$ 从大到小给予排名 $rk_i$，那么要求的最大值就是 $\max dist_i+rk_i-1$。

其实等价于假设 $>dist_i$ 的元素构成一段连续区间，算出来让它排在这个区间右端点的右边。就算实际上并不构成一段连续的区间，也不会导致答案变大。所以是对的。

那么值域线段树维护即可。
#### 代码
写的比较史。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 1.05e6 + 5;
int n, m, k, _t, u, v, dis[N], x;
int flag[N], buc[N];
vector<int> to[N];
queue<int> q; 
set<int> s;

inline int read() { int x = 0, w = 0; char ch = 0; while (!isdigit(ch)) {w |= ch == '-'; ch = getchar();} while (isdigit(ch)) {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();} return w ? -x : x; }
inline void write(int x) { if (x < 0) putchar('-'), x = -x; if (x > 9) write(x / 10); putchar(x % 10 + '0'); }
namespace Sg_Tree{
	#define lt (u << 1)
	#define rt (u << 1 | 1)
	#define mid (l + r >> 1)
	int t[N << 2], tag[N << 2];
	inline void psup(int u) {t[u] = max(t[lt], t[rt]);}
	inline void psdw(int u) {t[lt] += tag[u], t[rt] += tag[u], tag[lt] += tag[u], tag[rt] += tag[u], tag[u] = 0;}
	inline void build(int u, int l, int r){
		if(l == r) {t[u] = l; return ;}
		build(lt, l, mid), build(rt, mid + 1, r);
		psup(u);
	}
	inline void upd(int u, int l, int r, int ll, int rr, int p){
		if(ll <= l && r <= rr) {t[u] += p, tag[u] += p; return ;}
		psdw(u);
		if(ll <= mid) upd(lt, l, mid, ll, rr, p);
		if(rr > mid) upd(rt, mid + 1, r, ll, rr, p);
		psup(u);
	}
	inline int fid(int u, int l, int r, int ll, int rr){
		if(ll > rr) return 0;
		if(ll <= l && r <= rr) return t[u];
		psdw(u); int res = 0;
		if(ll <= mid) res = max(res, fid(lt, l, mid, ll, rr));
		if(rr > mid) res = max(res, fid(rt, mid + 1, r, ll, rr));
		psup(u); return res;
	}
}using namespace Sg_Tree;
int main(){
	cin >> n >> m >> k >> _t;
	for(int i = 1; i <= m; ++i) u = read(), v = read(), to[v].push_back(u);
	dis[_t] = 1, q.push(_t);
	while(!q.empty()){
		int u = q.front(); q.pop();
		for(auto v : to[u])
			if(!dis[v]) dis[v] = dis[u] + 1, q.push(v);
	}
	++m;
	build(1, 1, m);
	while(k--){
		x = read();
		if(!flag[x]){
			flag[x] = 1, upd(1, 1, m, 1, dis[x], 1);
			if((++buc[dis[x]] == 1)) s.insert(dis[x]);
		}
		else{
			flag[x] = 0, upd(1, 1, m, 1, dis[x], -1);
			if((--buc[dis[x]]) == 0) s.erase(dis[x]);
		}
		write(max(fid(1, 1, m, 1, *s.rbegin()) - 1, 0));	
		putchar('\n');
	}
	return 0;
}
```

---


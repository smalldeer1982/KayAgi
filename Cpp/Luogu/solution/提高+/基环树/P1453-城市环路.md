# 城市环路

## 题目描述

一座城市，往往会被人们划分为几个区域，例如住宅区、商业区、工业区等等。

B 市就被分为了以下的两个区域——城市中心和城市郊区。在这两个区域的中间是一条围绕 B 市的环路，环路之内便是 B 市中心。


整个城市可以看做一个 $n$ 个点，$n$ 条边的单圈图（保证图连通），唯一的环便是绕城的环路。保证环上任意两点有且只有 $2$ 条简单路径互通。图中的其它部分皆隶属城市郊区。

现在，有一位名叫 Jim 的同学想在 B 市开店，但是任意一条边的 $2$ 个点不能同时开店，每个点都有一定的人流量，第 $i$ 个点的人流量是 $p_i$，在该点开店的利润就等于 $p_i×k$，其中 $k$ 是一个常数。

Jim 想尽量多的赚取利润，请问他应该在哪些地方开店？


## 说明/提示

#### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $n \leq 100$。
- 另有 $20\%$ 的数据，保证环上的点不超过 $2000$ 个。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 10^5$，$1 \leq p_i \leq 10^4$，$0 \leq u, v < n$，$0 \leq k \leq 10^4$，$k$ 的小数点后最多有 $6$ 位数字。

## 样例 #1

### 输入

```
4
1 2 1 5
0 1
0 2
1 2
1 3
2
```

### 输出

```
12.0```

# 题解

## 作者：龙神哈迪斯 (赞：131)

### 放在前面的话

那个，楼下的$dfs$找环的确有问题，就在讨论区的那组数据可以把它成功$Hack$掉

然后几篇题解似乎都是基环树？~~这么高级的东西我还不会啊~~

大多人没把$dp$定义式讲清楚，然我们这种$小蒟蒻$很尴尬啊，于是我决定献丑一发

然后这题其实是我在图论里找的，结果莫名跑出一道树形dp来，可能Luogu知道我的树形dp太菜了，然后推荐的???

欢迎大家来$Hack$

### 题目大意

给你一棵树，点有点权，强制要求一条边只能选一个点，并且还额外命令$(S,T)$也不能同时选，求满足条件下的最大贡献

### Sol

这不是摆明了那你用树形dp切掉的节奏吗？

设$f[u][0/1]$表示以$u$为根的字树，$u$点选或不选的最大贡献

然后转移比较显然，

1.如果$u$点要选，则它所有的儿子都不能选

2.如果$u$点不选，那么它的儿子可以选也可以不选

所以转移式就是

$$f[u][1]=\sum_{u->v}f[v][0]$$
$$f[u][0]=\sum_{u->v}max(f[v][0],f[v][1])$$

然后考虑最后的统计答案

以$S$，$T$两点分别做一次$dp$，然后在$f[S][0],f[T][0]$中取较大值，这样就能保证$S,T$不可能同时被选了

### code

然后就是愉快的上代码环节了


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int _=100005;
inline int read()
{
	char ch='!';int z=1,num=0;
	while(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();
	if(ch=='-')z=-1,ch=getchar();
	while(ch<='9'&&ch>='0')num=(num<<3)+(num<<1)+ch-'0',ch=getchar();
	return z*num;
}
int n,p[_],fa[_],S,T;
struct ed{int to,next;}e[_<<1];
int cnt,head[_];
double f[_][2];
void link(int u,int v){e[++cnt]=(ed){v,head[u]};head[u]=cnt;}
int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}
void dfs(int u,int fa)
{
	f[u][1]=p[u];f[u][0]=0;
	for(int i=head[u];i;i=e[i].next)
	{
		int v=e[i].to;
		if(v==fa)continue;
		dfs(v,u);
		f[u][0]+=max(f[v][0],f[v][1]);
		f[u][1]+=f[v][0];
	}
}
int main()
{
	n=read();
	for(int i=1;i<=n;++i)p[i]=read(),fa[i]=i;
	for(int i=1;i<=n;++i)
	{
		int u=read()+1,v=read()+1;
		if(find(u)==find(v)){S=u,T=v;continue;}
		link(u,v);link(v,u);fa[find(v)]=find(u);
	}
	double k,ans=0;
	scanf("%lf",&k);
	dfs(S,0);ans=f[S][0];
	dfs(T,0);ans=max(ans,f[T][0]);
	printf("%.1lf\n",ans*k);
	return 0;
}

```


---

## 作者：LHRG李 (赞：82)

题目链接：[城市环路](https://www.luogu.com.cn/problem/P1453)。

关于题目：一道比较显然的 **基环树** 上的 dp 题。

应用算法：树形 dp $+$ 环形 dp。

------------

#### 写在前面：

$\qquad\!\!$本来题解区有一篇和我的思路一样的题解，不过那篇题解写得并不对，并不能通过我为这道题添加的 hack 数据。由于我个人认为这个思路对于基环树的初学者思维难度较小，比较友好，所以就有了这篇题解。

$\qquad\!\!updata\ \ 2020.10.6$：修改了之前挂错的链接；增加时空复杂度分析。

$\qquad\!\!updata\ \ 2020.10.25$：修改了之前对于 环形 dp 的初始化的一个错误。感谢 @[pigstd](https://www.luogu.com.cn/user/141179) 指出。

#### 下面进入正文：

- 一、分析题意：

$\qquad\!\!n$ 个点 $n$ 条边、全部联通且只有一个环，满足这些条件的图很显然是一棵[基环树](https://www.luogu.com.cn/blog/user52918/qian-tan-ji-huan-shu)。

$\qquad\!\!$每个点有点权且任意相邻的两个点不能同时选取，很显然我们需要进行类似于[没有上司的舞会](https://www.luogu.com.cn/problem/P1352)的 dp。

- 二、dp 过程：

    $\qquad\!\!$和其它题解不一样的，我的 dp 过程主要是利用基环树的一个性质将该问题分解为两个子问题逐一解决。

    $\qquad\!\!$由于一棵基环树可以看作一棵树加了一条非重边在图上形成了唯一一个环，那么我们可以将该环上的每个点看作一个**根节点**，在不考虑环上的点与之联通的情况下，每个根节点都联通出**一棵树**。也就是说，一棵基环树等价于**很多棵树的根节点被连在了一个环上的一张图**。

    $\qquad\!\!$由此，我们便可以将这个问题分解为**以环上的点为根节点的很棵多树的 树形 dp $+$ 这些环上的点的 环形 dp**。

    $\qquad\!\!$具体过程如下：

    - 1、找环：

    $\qquad\!\!$我利用的是拓扑排序 $+$ dfs 的方式进行找环。

    $\qquad\!\!$首先，对于所有节点拓扑排序一遍，而后入度为 $2$ 的点就是环上的点。

    $\qquad\!\!$其次，任意选择一个环上的点（我选择的就是编号最小的节点）进行 dfs。

    $\qquad\!\!$最后，每次 dfs 到一个 **未被记录入环并且入度为 $2$ 的节点**，将其记录入环并进行递归。

    $\qquad\!\!$可能有同学要问：为什么不能直接拓扑排序后每个点一次循环一遍入度为 $2$ 就记录入环而要区 dfs 呢？

    $\qquad\!\!$那是因为我们之后需要进行 环形 dp，需要保证**环上依次连续的点在图上也是依次连续的**，所以不能只进行一个简简单单的循环而需要 dfs。

    - 2、树形 dp：

    $\qquad\!\!$即对于每棵树都进行一次[没有上司的舞会](https://www.luogu.com.cn/problem/P1352)的 dp 过程：

    $\qquad\!\!$设 $f_{i,0}$ 表示 $i$ 点不选择，$i$ 点子树的最大贡献；$f_{i,1}$ 表示 $i$ 点选择，$i$ 点子树的最大贡献。对于每个点 $i$，$f_{i,0}$ 的初始值为 $0$，$f_{i,1}$ 的初始值即为题目中的每个点的人流量 $p_i$。

    $\qquad\!\!$转移方程（$v$ 点为 $u$ 点的子节点）：

    $\qquad\!\!f_{u,0}\gets f_{u,0}+\max(f_{v,0},f_{v,1})$

    $\qquad\!\!f_{u,1}\gets f_{u,1}+f_{v,0}$

    - 3、环形 dp：

    $\qquad\!\!$_没有接触过 环形 dp 的同学可以左转先看一下这两道题：[P6064 [USACO05JAN]Naptime G](https://www.luogu.com.cn/problem/P6064) 和 [SP283 NAPTIME - Naptime](https://www.luogu.com.cn/problem/SP283)。_

    $\qquad\!\!$由于此时每棵树内部节点的关系均已满足题目的限定，剩下的就是环上的各个节点之间的关系，那么我们只需要对每棵树的根节点进行一次 环形 dp 即可得出答案。

    $\qquad\!\!$设 $c_i$ 为环上第 $i$ 个点的编号，$tot$ 为环上的节点总数。

    $\qquad\!\!$那么此时 $f_{c_i,0}$ 代表以 $c_i$ 为根的树不选 $c_i$ 最大贡献； $f_{c_i,1}$ 代表以 $c_i$ 为根的树选 $c_i$ 最大贡献。

    $\qquad\!\!$设 $g_{i,0}$ 表示点 $c_i$ 不选，前 $i$ 个节点的最大贡献，设 $g_{i,1}$ 表示点 $c_i$ 选，前 $i$ 个节点的最大贡献。

    $\qquad\!\!$转移方程：

    $\qquad\!\!g_{i,0}\gets \max(g_{i-1,0},g_{i-1,1})+f_{c_i,0}$

    $\qquad\!\!g_{i,1}\gets g_{i-1,0}+f_{c_i,1}$

    $\qquad\!\!$由于是进行 环形 dp，为了枚举全面所有的情况，我们需要进行两次 dp 过程：

    $\qquad\!\!$①、规定 $c_1$ 节点一定不选：

    $\qquad\!\!\qquad\!\!$初始化 $g$ 中的每一个元素为 $-inf$；$g_{1,0}=f_{c_1,0}$。

    $\qquad\!\!\qquad\!\!$进行 dp，统计答案 $ans=\max(g_{tot,0},g_{tot,1})$。

    $\qquad\!\!$②、规定 $c_1$ 节点一定选：

    $\qquad\!\!\qquad\!\!$初始化 $g$ 中的每一个元素为 $-inf$；$g_{1,1}=f_{c_1,1}$。

    $\qquad\!\!\qquad\!\!$进行 dp，统计答案 $ans=\max(ans,g_{tot,0})$。
    
- 三、复杂度分析：

	- 时间复杂度：无论是在找环还是在两次 dp 的过程中，每个点最多被经过一次，所以时间复杂度为 $O(n)$。
   
   - 空间复杂度：由几个数组的定义可知，每个数组所用的空间均为 $O(n)$ 的数量级，所以总空间复杂度为 $O(n)$。

- 四、最后，上代码（码风不喜勿喷）：

```cpp
//P1453 城市环路
#include<bits/stdc++.h>
#define in inline
#define re register
#define N 100010
using namespace std;
int n;
int cnt,head[N];
struct edge
{
	int to,nxt;
};
edge e[N<<1];
bool b[N];
int tot;
int rd[N],c[N];
int f[N][2],g[N][2];
int ans;
double k;
in int qread()
//快读
{
    int x=0,y=1;
    int ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-')
		{
			y=-1;
		}
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x*y;
}
in void mr(re int u,re int v)
//建边
{
	e[++cnt].to=v;
	e[cnt].nxt=head[u];
	head[u]=cnt;
	return ;
}
in void dfs0(re int u,re int fa)
//找环
{
	for(re int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].to;
        //父节点或已在环上就不算
		if(v==fa||b[v])
		{
			continue;
		}
        //找到一个点就加入环
		if(rd[v]==2)
		{
			b[v]=1;
			c[++tot]=v;
            //递归
            dfs0(v,u);
            //加入一个点后就跳出循环
			break;
		}
	}
    return ;
}
in void tppx()
//拓扑排序
{
	queue<int> q;
	for(re int i=1;i<=n;i++)
	{
		if(rd[i]==1)
		{
			q.push(i);
		}
	}
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		for(re int i=head[u];i;i=e[i].nxt)
		{
			int v=e[i].to;
			rd[v]--;
			if(rd[v]==1)
			{
				q.push(v);
			}
		}
	}
	for(re int i=1;i<=n;i++)
	{
        //找到第一个在环上的点加入环并进行 dfs
		if(rd[i]==2)
		{
			b[i]=1;
			c[++tot]=i;
			dfs0(i,0);
            //加入一个点后就跳出循环
			break;
		}
	}
	return ;
}
in void dfs(re int u,re int fa)
//树形 dp
{
	for(re int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].to;
		if(v==fa||b[v])
        //父节点或已在环上就不算
		{
			continue;
		}
		dfs(v,u);
        //转移
		f[u][0]+=max(f[v][1],f[v][0]);
		f[u][1]+=f[v][0];
	}
	return ;
}
int main()
{
    //读入
	n=qread();
	for(re int i=1;i<=n;i++)
	{
		f[i][1]=qread();
	}
	for(re int i=1;i<=n;i++)
	{
		int u=qread()+1;
		int v=qread()+1;
        //统计入度
		rd[u]++;
		rd[v]++;
        //建边
		mr(u,v);
		mr(v,u);
	}
    //拓扑排序
	tppx();
    //对于每棵树 树形 dp
	for(re int i=1;i<=tot;i++)
	{
		dfs(c[i],0);
	}
    //环形 dp
	memset(g,-0x3f,sizeof(g));
	g[1][0]=f[c[1]][0];
	for(re int i=2;i<=tot;i++)
	{
		g[i][1]=g[i-1][0]+f[c[i]][1];
		g[i][0]=max(g[i-1][0],g[i-1][1])+f[c[i]][0];
	}
	ans=max(g[tot][0],g[tot][1]);
	memset(g,-0x3f,sizeof(g));
	g[1][1]=f[c[1]][1];
	for(re int i=2;i<=tot;i++)
	{
		g[i][1]=g[i-1][0]+f[c[i]][1];
		g[i][0]=max(g[i-1][0],g[i-1][1])+f[c[i]][0];
	}
	ans=max(ans,g[tot][0]);
    //读入 k
	scanf("%lf",&k);
    //输出答案
	printf("%.1lf\n",ans*k);
	return 0;
}
```



---

## 作者：Dispwnl (赞：12)

这道题就是难一点的树形dp

只要想清楚如何处理环就很简单了（然而我还是一如既往的看了题解）

先dfs预处理

如果这个点的下一个点已经遍历过了

就表明它俩在环上

定为s1,s2

强拆s1,s2之间的边

以s1,s2为根树形dp

用二维数组表明第i个点选或不选的最大值

f[i][1]表示建

f[i][0]表示不建

所以


f[i][1]+=f[c[i].y][0];

f[i][0]+=max(f[c[i].y][1],f[c[i].y][0]);

输出f[s1][0],f[s2][0]最大值

（关于为什么是f[s1][0],f[s2][0]最大值：

如果是f[s1][1]时

无法判断选s2时是否是最大值

所以干脆不选s1

以求出不选s1时的最大值

而选s1时的最大值在s2中判断

所以最后要取最大值）

```cpp
# include<iostream>
# include<cstdio>
# include<cstring>
using namespace std;
struct p{
    int x,y;
}c[1000001];
int n,num,s1,s2;
int h[1000001];
double k,ans;
double p[1000001];
double f[1000001][2];
bool ff;
bool use[1000001];
void add(int x,int y)
{
    c[++num].x=h[x];
    c[num].y=y;
    h[x]=num;
}
void dfs(int x,int y)
{
    use[x]=1;
    for(int i=h[x];i;i=c[i].x)
      if(c[i].y!=y)
      {
          if(use[c[i].y])
          {
              ff=1;
              s1=x,s2=c[i].y;
              return;
        }
        dfs(c[i].y,x);
        if(ff) return;
      }
    use[x]=0;
}
void dfs1(int x,int y)
{
    f[x][1]=p[x];
    for(int i=h[x];i;i=c[i].x)
      {
          if((x==s1&&c[i].y==s2)||(x==s2&&c[i].y==s1)||c[i].y==y)
          continue;
          dfs1(c[i].y,x);
          f[x][1]+=f[c[i].y][0];
          f[x][0]+=max(f[c[i].y][1],f[c[i].y][0]);
      }
}
int main()
{
    scanf("%d",&n);
    for(int i=0;i<n;i++)
      scanf("%lf",&p[i]);
    for(int i=1;i<=n;i++)
      {
          int x,y;
          scanf("%d%d",&x,&y);
          add(x,y);
          add(y,x);
      }
    scanf("%lf",&k);
    dfs(0,0);
    dfs1(s1,s1);
    double ans1=f[s1][0];
    memset(f,0,sizeof(f));
    dfs1(s2,s2);
    double ans2=f[s2][0];
    printf("%.1lf",max(ans1,ans2)*k);
    return 0;
}

```

---

## 作者：拿省一就改名 (赞：7)

## 前来凑一篇题解，一道基环树树形dp(づ｡◕‿‿◕｡)づ
**从骑士那里转过来的，这两个题有很大的相似之处，树形dp好像都有一定的继承性。如果你是树形dp萌新的话，可以去看没有上司的晚会，如果你是大佬的话，A掉这个题后顺便可以去把骑士A掉。**


------------

**emmm，跑题了 。这种题的套路就是将环上的随意相邻两点钦定只选一点。然后跑两边树形dp就好了。找环这个操作是在dfs的时候维护一个vis数组（都不陌生吧），然后只要遇见一个被标记过得，就说明它在环上，同时它的前驱一定也在环上。就这样，我们就找到了两个点，然后分别以他们为根跑dp就行了，代码也没有难度。**

**不过这个题我并没有用楼上各位大佬的 ^ 操作~~（才不是不会用呐）~~，我在树形dp时多传了一个参数，
如下**
```cpp
void dfs(int u,int pre,int no)
```
**u表示当前节点，pre存前驱，no存钦定不选的点。
然后就可以开开心心的dp了**


------------

#### AC代码：
```cpp
#include<iostream>
#include<cstdio>
const int maxn = 100001;
const int inf=0x7ffff;
using namespace std;
int n,w[maxn],f[maxn][2],ans=0;
double k;
bool vis[maxn];
struct edge
{
    int y,next;
}e[maxn<<1];
int head[maxn<<1],cnt=0;
void add(int x,int y)
{
    e[++cnt].y=y;
    e[cnt].next=head[x];
    head[x]=cnt;
}
int flag=0;
void dfs(int u,int pre,int no)
{
    f[u][0]=0,f[u][1]=w[u];
    for(int i=head[u];i;i=e[i].next)
    {
        int v=e[i].y;
        if(v==pre)continue;
        if(v!=no)
        {
            dfs(v,u,no);
            f[u][1]+=f[v][0];
            f[u][0]+=max(f[v][0],f[v][1]);  
        }
        else f[u][1]=-inf;
    }
}
void find_circle(int x,int pre)
{
    if(flag) return;
    if(!vis[x]) vis[x]=1;
    for(int i=head[x];i;i=e[i].next)
    {
        int v=e[i].y;
        if(v==pre) continue;
        if(!vis[v]) find_circle(v,x);
        else
        {
            dfs(x,v,x);
            int temp=max(f[x][1],f[x][0]);
            dfs(v,x,v);
            ans=max(f[v][0],max(f[v][1],temp));
            flag=1;
            return ;   
        }
    }
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d",&w[i]);
    for(int i=1;i<=n;i++)
    {
        int a,b;
        scanf("%d%d",&a,&b);
        a++,b++;
        add(a,b);
        add(b,a);
    }
    scanf("%lf",&k);
    find_circle(1,1);
    double answer=(double)ans*k;
    printf("%.1lf",answer);
}
```
### PS：蒟蒻的一篇博文，谢谢支持(∩_∩)
2018-08-09 16:27

---

## 作者：dztlb (赞：6)

2020.6.10 更新：修改了用语，代码添加了注释

和没有上司的舞会差不多，唯一的不同是增加了一条边，成为了基环树。

考虑找到那个唯一的环，处理成树的情况。

同样的，首先dfs找到环，这里考虑假如一个点遍历它的儿子时，发现它的儿子已经vis了，那么这两个点就在环上。

把这两个点取出，断开连接，成为一颗树，分别用两个点作为根节点进行dfs(实际操作实现中则记录根节点为no，当支路儿子等于no时，不拓展这颗子树)

假如两点为u,v

dp[u][0]记录了不取u的最优情况,dp[v][0]记录了不取v的最优情况,因为u,v在原图中相邻，不能同时取，所以最后的答案就是dp[u][0],dp[v][0]最大值

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,u,v,ans=0;
double k;
int cnt=0;
int w[200005];
struct edge{
	int num;
	int next;
}p[200005];
int head[200005]={0};
void add(int a,int b){
	p[++cnt].num=b;
	p[cnt].next=head[a];
	head[a]=cnt;
}
bool flag=0;
bool vis[100005]={0};
int dp[100005][2]={0};
void dfs(int u,int pre,int no){
	dp[u][1]=w[u];
	dp[u][0]=0;
	for(int i=head[u];i;i=p[i].next){
		int v=p[i].num;
		if(v==pre){//跳过父节点
			continue;
		}
		if(v!=no){
			dfs(v,u,no);
			dp[u][1]+=dp[v][0];//转移状态，取 不取上个点的情况
			dp[u][0]+=max(dp[v][0],dp[v][1]);//取 上个点的两状态的最大值
		}
	}
}
void fc(int x,int pre){
	if(flag){//假如已经找到了环，继续就没有意义
		return ;
	}
	if(!vis[x]){//vis记录有没有走过
		vis[x]=1;
	}
	for(int i=head[x];i;i=p[i].next){
		int v=p[i].num;
		if(v==pre){
			continue;
		}
		if(!vis[v]){
			fc(v,x);
		}else{//x v在环上 
			flag=1;
            //相当于断开x v，分别以两点为根节点dp
			dfs(x,v,x);//以x为起点，记录x不会作为子节点
			ans=max(ans,dp[x][0]);
			dfs(v,x,v);//以v为起点，记录x不会作为子节点
			ans=max(ans,dp[v][0]);
            //最终答案相当于是不取u或者不取v的答案的最大值，因为显然两者不能同时取
			return;
		}
	}
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&w[i]);//每个点的价值
	} 
	for(int i=1;i<=n;i++){
		scanf("%d%d",&u,&v);
		u++;//处理为1-n
		v++;
		add(u,v);//连接u v，类似链式前向星
		add(v,u);
	}
	scanf("%lf",&k);
	fc(1,1);//从一号点开始找环，先默认它的祖先是自己
	double answer=(double)ans*k;//利润是k倍的人流量
	printf("%.1lf",answer);
	return 0;
}
```


---

## 作者：xcxc82 (赞：6)

# P1453 城市环路 题解


## [间隙](https://www.luogu.com.cn/problem/P1453)

## 前置知识

- ### 树形dp,基环树

## 大致题意

给一颗含有点权的基环外向树



假如两个点之间有一条边连接,如果选择了其中一端的节点,那另一段的节点则不可选择


求:最大贡献

## 分析

先讲一下什么是基环树。

基环树,简单来说就是多了一条边的树,产生了一个环形结构,环上的每个节点都是一颗树的根

![](https://cdn.luogu.com.cn/upload/image_hosting/g8bnch8r.png)

画成图的话大概是这个样子(基环外向树)

一般来说,这种题目的做法都是先找到环,断开环中的一条边,
把它当成一般的树形$DP$来做。

### 如何找环?

一般有$dfs$跟并查集两种方法 , 这里我采用的是并查集的做法

一开始每个节点都是一个独立的集合

每连接一条边,就把这两个点合并到一个集合中

如果在连接一条边之前,两个节点就已经在一个集合中了,说明这**两个节点已经联通了,再连接这条边必然会产生环的情况**

![](https://cdn.luogu.com.cn/upload/image_hosting/53vb8z0u.png)
### 如何转移?

找到了环之后,只需要将环上的这条边断开即可

这样的话就可以当作普通的树形$DP$来做了

设$f[i][0]$为选第$i$个节点产生的最大贡献

$f[i][1]$为不选第$i$个节点产生的最大贡献

如果选了第$i$个节点,那它的儿子肯定都不能选

反之,儿子可以选择选,也可以选择不选

得到转移方程:

$f[u][0] = \sum f[v][0]$

$f[u][1] = \sum max(f[v][1],f[v][0])$

## 代码实现

思路明白了代码实现应该就不难了

要注意的是环上的两个点都可以作为树的根节点,因此在$DP$的时候要把两个点都跑一遍

具体的细节注释有写

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 1e5+10;
struct edge{//存图 
	int v,next;
}e[MAXN<<1];
int f[MAXN][2],w[MAXN];//dp数组,点权 
double k; 
int fa[MAXN];
int head[MAXN<<1],cnt = 0;
int root1,root2;//环上的两个点 
int n;
void add(int u,int v){//前向星 
	e[++cnt].v = v;
	e[cnt].next = head[u];
	head[u] = cnt;
} 
int find(int x){//查找集合 
	if(fa[x]==x){
		return x;
	}
	else{
		return fa[x] = find(fa[x]);
	}
}

void circle(int u,int fa){//树形dp 
	f[u][1] = w[u],f[u][0] = 0;//初始化 
	for(int i=head[u];i;i=e[i].next){
		int v = e[i].v;
		if(v!=fa){ 
			circle(v,u);
			f[u][0]+=max(f[v][1],f[v][0]);//转移 
			f[u][1]+=f[v][0];
		}
	}
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&w[i]);
		fa[i] = i;//初始化集合 
	}
	for(int i=1;i<=n;i++){
		int u,v;
		scanf("%d%d",&u,&v);
		u++,v++;
		if(find(u)==find(v)){//如果在加边前就在一个集合中了,说明找到了环 
        	root1 = u,root2 = v;//记录环上的两个点 
        	continue;//直接跳过加边操作,相当于断开这条边 
		}
        add(u,v);
		add(v,u);
		fa[find(v)] = find(u);//合并集合 
	}
	scanf("%lf",&k);
	circle(root1,0);
	double r1 = f[root1][0];//选root1 
	
	circle(root2,0);
	double r2 = f[root2][0];//选root2 
	
	printf("%.1lf",max(r1,r2)*k);//取最大 
	return 0;
}
```



---

## 作者：Drifterming (赞：4)

```
//一道上午的时候不知道哪错了发了讨论然后放弃了的题。
//感谢@sqairy 大佬   一语道破我的错误所在
 
//楼下都用的dfs找环，当时没想出用dfs做来，所以在输入的时候处理的环 
//因为如果一条边的端点已经全部出现的话，我们把这条边加进去，就构成了一个环，
//所以开一个flag[]标记，标记这个点有没有输入过，
//如果 flag[u]&&flag[v]，那么这肯定是一个环上的一条边，然后让A=u,B=v,
//并且我们不把这条边加进图里，这样就构成了一棵树 
//从A,B做两次树形DP，找最大值。 和没有上司的舞会那道题一样 
//还有就是要取max(dp[A][0],dp[B][0])，
//为什么是不选A和B的情况的最大值：
//因为我们如果是在选A或B的情况中取最大值，我们不能保证A(B)选了，但是B(A)没选

#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;

const int N=1e6+5;

int n,A,B;
double K;
int p[N];
int head[N],num_edge;
bool flag[N];
double dp[N][2];
struct Edge
{
	int v,nxt;
}edge[N<<1];

int read()
{
	char c=getchar();int num=0;
	for(;!isdigit(c);c=getchar());
	for(;isdigit(c);c=getchar())
		num=num*10+c-'0';
	return num;
}

void add_edge(int u,int v)
{
	edge[++num_edge].v=v;
	edge[num_edge].nxt=head[u];
	head[u]=num_edge;
}

void dfs(int u,int fa)
{
	dp[u][1]=p[u],dp[u][0]=0;
	for(int i=head[u],v;i;i=edge[i].nxt)
	{
		v=edge[i].v;
		if(v==fa)
			continue;
		dfs(v,u);
		dp[u][0]+=max(dp[v][0],dp[v][1]);	//这个点不选，加上它的儿子选或不选的最大值 
		dp[u][1]+=dp[v][0];	//这个点选，它的儿子们不能选 
	}
}

int main()
{ 
	n=read();
	for(int i=0;i<n;++i)
		p[i]=read();
	bool ok=0;	//标记找没找到环 
	for(int i=1,u,v;i<=n;++i)
	{
		u=read(),v=read();
		if(!ok&&flag[u]&&flag[v])	//一条边的两个端点都出现过，那么着肯定是一个环上的边 
		{
			ok=1;	//找到环了 
			A=u,B=v;	//记录两个端点 
			continue;	//不加这条边 
		}
		flag[u]=flag[v]=1;		//标记两个端点已经出现过 
		add_edge(u,v);	//加边 
		add_edge(v,u);
	}
	scanf("%lf",&K);
	dfs(A,A);	//从A跑DFS 
	double ans=dp[A][0];
	dfs(B,B);	//从B跑DFS 
	ans=max(ans,dp[B][0]);
	printf("%.1lf",ans*K);
	return 0;
}
```

---

## 作者：年华天地 (赞：2)

# 题目大意
给你一颗基环树（比普通树多一条边形成一个环），每一个点有一个权值，要求相邻的两个点不能同时选，求所有方案中权值最大为多少，最后再乘一个实数。
# 方法
![](https://cdn.luogu.com.cn/upload/image_hosting/i9u4h6ow.png)

上面是一个基环树的图，圆表示一个点，三角形表示一颗树。

我们要在基环树上做$dp$，其实可以转化为对以在环上每一个点为根的树中做树形$dp$，最后在环上做环形$dp$。

## 步骤
1.找环，用$dfs$，用$book$标记已经走过的点，如果从一个点走到了一个被标记过的点并且这个点不是他的父亲，证明找到环了，然后从这个点一直往上跳到被标记的点，就找到了环，并用数组记录环上的点。
```
bool dfs(int u,int fa)
{
	f[u]=fa;
	book[u]=1;
	for(int i=head[u];i;i=e[i].next)
	{
		int y=e[i].to;
		if (y==fa)continue;
		if (book[y])
		{
			int x=u;
			while(x!=f[y])
			{
				cnt++;
				s[cnt]=x;
				v[x]=1;
				x=f[x];
			}
			return 1;
		}
		else
		{
			if (dfs(y,u))return 1;
		}
	}
	return 0;
}
```
2.在每一个树上做树形$dp$，不会的可以先去做没有上司的舞会。
```
for (int i=1;i<=cnt;i++)dfs_dp(s[i],0);
```

```
void dfs_dp(int x,int fa)
{
	for (int i=head[x];i;i=e[i].next)
	{
		int y=e[i].to;
		if (v[y]||y==fa)continue;
		dfs_dp(y,x);
		dp[x][0]+=max(dp[y][0],dp[y][1]);
		dp[x][1]+=dp[y][0];
	}
	dp[x][1]+=a[x];
}
```
3.在环上做$dp$，我们用$g[i][1/0][1/0]$表示当前点，当前点选不选，第一个点选不选（因为是环，最后一个点与第一个点相连）。

我用$s[i]$记录的环上的点。

```
g[s[i]][1][1]=g[s[i-1]][0][1]+dp[s[i]][1];//当前点选，上一个点就不选，第一个点选。
g[s[i]][0][1]=max(g[s[i-1]][0][1],g[s[i-1]][1][1])+dp[s[i]][0];//当前点不选，上一个点可以选也可以不选，第一个点选。
g[s[i]][1][0]=g[s[i-1]][0][0]+dp[s[i]][1];//当前点选，上一个点就不选，第一个点不选。
g[s[i]][0][0]=max(g[s[i-1]][1][0],g[s[i-1]][0][0])+dp[s[i]][0];//当前点不选，上一个点可以选也可以不选，第一个点不选。
```


4输出答案，我们输出最后一个点不选，第一个点不选，最后一个点选，第一个点不选，最后一个点不选，第一个点不选三个方案中权值最大的，再乘$k$（我用$m$表示，我用了滚动数组）。
```
printf("%.1lf",(double)max(max(g[cnt%2][0][1],g[cnt%2][1][0]),g[cnt%2][0][0])*m);
```

---

## 作者：Randolph、 (赞：2)

[P1453 城市环路 ](https://www.luogu.org/problem/P1453)

感觉基环树（or环套树）的题目一般都是找到树上的环，断掉一条边再进行树上的操作（如noip2018[P5022 旅行](https://www.luogu.org/problem/P5022)）

### 双倍经验：[P2607 [ZJOI2008]骑士](https://www.luogu.org/problem/P2607)

P1453和P2607这两题实际上就是基环树上的[P1352 没有上司的舞会](https://www.luogu.org/problem/P1352)，用树形DP即可，但是因为有环，所以要先找到环再删一条边才能DP

至于树形DP就不多说了，毕竟是基环树，最主要的就是找环操作了，翻了翻题解，大概有下面几种方法：

一. 读入时判断

1. 并查集 ，若两点在一个并查集中则记录下来，不连边不合并

2. （不建议使用）bool记录点是否出现过，若读入时两点在之前都已出现了，则为环，不连边（**BUG：本题数据较弱可过，但可能在一些数据中出错**，看评论中有一组hack数据：5 1 2 3 4 5 0 1 2 3 2 4 0 2 3 4 9.0，答案为63.0，但这种找环方法会超时）

二、读入后判断

1. 如本程序，dfs找环，找到时记录两点a,b或边编号e，dp时不仅要判断v!=fa，还应判断(u!=a || v!=b) && (u!=b || v!=a)或(e!=i && (e^1)!=i)(双向边)

2. （不建议使用）连单向边u->v（注意要保证有有向环），记录fa[v]=u，从一个已存在的点开始不断找fa直到遇到走过的则找到了环。这种写法可以用在P2607（见[**这个题解**](https://www.luogu.org/blog/HullEssien/solution-p2607)），此题未必可行

```cpp
while(!vis[fa[rt]]) rt=fa[rt],vis[rt]=1;//rt与fa[rt]连为了环
```

对于此题，找到环上两点a，b后，分别以a，b为根做两次树形DP，第一次取f[a][0]，第二次取f[b][0]（这样保证a与b虽相邻但不会同时被被取），取max(f[a][0],f[b][0])与K相乘即可

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
#define ll int //这个代码是在P2607的基础上修改的，所以直接把ll定义为int了
const int N=1e5+100;
int h[N],rt,rt2,n,cnt,val[N];
bool vis[N];
ll f[N][2],ans;
struct edge {
	int v,h;
} e[N<<1];
inline void add(int u,int v) {
	e[++cnt]=(edge) {
		v,h[u]
	},h[u]=cnt;
}

void dp(int x,int fa) {
	vis[x]=1,f[x][1]=val[x];
	for (int i=h[x],v; i; i=e[i].h) {
		v=e[i].v;
		if ((x!=rt || v!=rt2) && (x!=rt2 || v!=rt) && v!=fa)
			dp(v,x),
			f[x][0]+=max(f[v][0],f[v][1]),
			         f[x][1]+=f[v][0];
	}
}

bool find(int x,int fa) {  //dfs找环
	vis[x]=1;
	for(int i=h[x]; i; i=e[i].h)
		if (e[i].v^fa)
			if (vis[e[i].v]) {
				rt=e[i].v,rt2=x; //找到了环，记录起端点（相当于切断i这条边）
				return 1;
			} else if (find(e[i].v,x)) return 1;
}

void solve(int x) { //分别以两端点做树形DP
	find(x,-1);
	dp(rt,rt);
	ll tmp=f[rt][0];
    
	memset(f,0,sizeof f);
	dp(rt2,rt2);
    
	ans=max(tmp,f[rt2][0]);
}
int main() {
	scanf("%d",&n);
	for (int i=0; i<n; i++) scanf("%d",&val[i]);
	for (int i=1,x,y; i<=n; i++) scanf("%d%d",&x,&y),add(x,y),add(y,x);
	solve(0); //注意若是森林需枚举1~n的点
	double tmp;
	scanf("%lf",&tmp);
	printf("%.1lf",(double)ans*tmp);
}
```


---

## 作者：SimonSu (赞：2)

先说说基环树是什么吧！

基环树是一种图，它由一个环组成，环上每个点都是一棵树点树根，所以称为基环树。当然，一棵树上连一条边也会变成基环树。

题目中 *p 的条件通过乘法分配律显然可以提出来，当没有处理

如果本题取消条件是基环树而是一棵树，那么问题便简化为了
[没有上司的舞会](https://www.luogu.org/problemnew/show/P1352)，处理方法就是简单的树形DP。

而基环树问题重要的肯定就是断环，那么我们可以延伸思考一个问题，一个点在树上只有选和不选两种状态，所以可以出现一道处理方式相关的有向基环树题目 [创世纪](https://www.acwing.com/problem/content/361/) 这道题目是双向边

因为本题不需要枚举每个节点只需要环上每个节点所以可以使用并查集找环  ~~打了可持久化好写又快速~~  并查集可以说是非常重要的数据结构了 不会的快学！~~（都做城市环路了都应该会吧）~~

如果遇到题目需要强制要求路径只能够去DFS了

而本题因为是无向图，所以只需要对断边的两个节点进行，一次DP，并且记录不其节点的答案，max比较就可以了

现在贴上code【由于是双倍经验那边来的所以打的是森林的情况 当然森林是可以解决树的问题的】


```cpp
#include<iostream>
#include<stdio.h>
#include<algorithm>
#include<string.h>
#include<queue>
#include<stack>
#define LL long long
using namespace std;
const LL maxn=1000010;
inline void read(int &x){
    x=0;int f=1;char c=getchar();
    while(c>'9'||c<'0'){if(c=='-') f=-1;c=getchar();	}
    while(c>='0'&&c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar();
    x*=f;
}

struct node{
    int v,nxt;
}e[maxn<<1];
int head[maxn],tot;
inline void add(int x,int y)
{
    tot++;
    e[tot].v = y;
    e[tot].nxt = head[x];
    head[x] = tot;
}

int w[maxn],fa[maxn];
inline LL find(int x)
{
    if(x!=fa[x]) fa[x]=find(fa[x]);
    return fa[x];
}

int n,a[maxn],b[maxn],tmp,cnt,nowa,dd;
LL f[maxn],g[maxn],tmpp;//f选 g不选

inline void dfs(LL u,LL fa)
{
    f[u]=w[u];
    g[u]=0;
    for(int i=head[u];i;i=e[i].nxt)
    {
        LL v=e[i].v;
        if(v==fa||v==nowa) continue;
        dfs(v,u);
        
		if(g[v]>f[v]) g[u]+=g[v];
        else g[u]+=f[v];//就是max 
        
		f[u]+=g[v];
    }
}
LL ans;
double PP; 
int main()
{
    read(n);
    for(int i=1;i<=n;i++) fa[i]=i,read(w[i]);
    for(int i=1;i<=n;i++)
    {
        read(dd),read(tmp);
        dd++,tmp++;
        if(find(tmp)!=find(dd))
        {
            add(tmp,dd);
            add(dd,tmp);
            fa[fa[tmp]]=fa[dd];
        }
        else
        {
            cnt++;
            a[cnt]=tmp;
            b[cnt]=dd;
        }
    }
    scanf("%lf",&PP);
    for(int i=1;i<=cnt;i++)
    {
        nowa = a[i];
        dfs(a[i],0);
        tmpp = g[a[i]];
        
        nowa = b[i];
        dfs(b[i],0);
        if(tmpp>g[b[i]])
           ans+=tmpp;
        else ans+=g[b[i]];
    }
    
    printf("%.1lf",ans*1.0*PP);
    return 0;
}
```


---

## 作者：_J_C_ (赞：1)

emm，这道题找环好像比dp还难……

dfs找环的话，如果数据就是一个100000个点的大环，搞不好要栈崩（深度为100000）。

而广搜似乎又不太好表示路径。怎么办呢？

我用栈模拟深搜……orz

### **【强烈建议先看接下来的代码，因为下面的描述完全就是伪代码……看不懂代码再来读伪代码嘛】**

深搜需要两个参数：dep表示深度，now表示当前结点

深搜其实还需要额外一个参数，就是当前枚举到了这个节点的哪一条边（邻接表存图）

所以开三个栈（stack）

```cpp
std::stack<int> stk, edge_rank, dep;
```

然后枚举这个点相连的边NextEdge，如果这个边连到的点未访问过，那么就需要深搜了。

若这个边连到的点已经被访问过了，那么判断这个点的深度是否为当前点的深度-1，如果是，则说明这个边通向点是来到当前点的点，忽略；否则，这个就出现环了，标记CircleBegin并且break

需要深搜的时候，更新当前栈edge_rank的值，然后将深搜的三个参数压入栈，并且标记vis[nextpoint]为当前点的深度+1，break掉循环。

在循环外，如果NextEdge是无效值（枚举完了这个点的边），那么说明退出的原因是这个点的边枚举完了，而非需要深搜，所以pop掉三个栈栈顶的元素

在最外面，不停的退栈直到栈顶元素等于CircleBegin，那么退出来的元素及CircleBegin都是属于这个环的了，而且是非常好的相邻关系。（联想一下深搜）




```cpp

void dfs()
{
	stk.push(0);//从0号点开始搜索
	edge_rank.push(iHead[0]);
	dep.push(1);
	vis[0] = 1;
	int CircleBegin(-1);
	while (!stk.empty() && CircleBegin == -1)
	{
		int depth(dep.top());
		int NextEdge(edge_rank.top());
		while (NextEdge)
		{
			if (vis[all[NextEdge].to] == 0)//如果这个点未访问
			{
				vis[all[NextEdge].to] = depth + 1;//开始准备深搜
				edge_rank.pop();
				edge_rank.push(all[NextEdge].next);
				stk.push(all[NextEdge].to);
				edge_rank.push(iHead[all[NextEdge].to]);
				dep.push(depth + 1);
				break;
			}
			else if (vis[all[NextEdge].to] != depth - 1)//否则，如果这个点不是来到当前点时经过的点
			{
				CircleBegin = all[NextEdge].to;//找到环
				break;
			}
			NextEdge = all[NextEdge].next;
		}
		if (NextEdge == 0)//这个点的所有边都遍历了，却未找到环，退栈
		{
			stk.pop();
			edge_rank.pop();
			dep.pop();
		}
	}
	while (!stk.empty())
	{
		bInCircle[stk.top()] = true;//栈内直到CircleBegin都是环内元素
		circle[iEndCir++] = stk.top();
		if (stk.top() == CircleBegin) break;
		stk.pop();
	}
	CLEAR_STACK(stk);//清空栈
	CLEAR_STACK(edge_rank);
	CLEAR_STACK(dep);
}

```

显然，这么做如果存在二元环是要WA起飞的。【不过并没有】


然后到了精彩的dp环节。

【可是我已经不想说了orz写了好长的题解。】

有两个dp：树上的和环上的，显然这两个dp是独立的。

树上的简单：定义val[x][0]表示x及x的子树中，不选x的最大值（先不乘以k）
定义val[x][1]表示x及x的子树中，选择x的最大值。

然后dfs处理一下就好了（？？？为什么这里dfs我就不怕栈崩溃呢？？？）


然后是环上的。

定义状态为dp[x][y][z]，其中x为环上节点的独立编号（0-iEndCir-1），y为是否选择第一个点，z为是否选择当前点

对于x=0,1,iEndCir-1，都是需要特殊处理的……0大家都懂；1是因为他前面的就是0，而y就是关于0号点的状态；iEndCir-1则是因为它与0相邻

怎么dp嘛……留给读者思考~~【其实是我太懒不想写了，而且状态也挺清楚的...吧】~~

```cpp

#include <cstdio>
#include <cstdlib>

#include <stack>

#define CLEAR_STACK(x) {while (!x.empty()) x.pop();}

#define FOR_EDGE(i, pt) for (int i(iHead[pt]); i; i = all[i].next)


class edge
{
public:
	int to, next;
}all[212345];

int iHead[112345];

int iEnd(2);
void add(int fr, int to)
{
	all[iEnd].to = to;
	all[iEnd].next = iHead[fr];
	iHead[fr] = iEnd++;
}

int p[112345];

int circle[112345];
int iEndCir;

int from[112345];
int vis[112345];
bool bInCircle[112345];

std::stack<int> stk, edge_rank, dep;

void dfs()
{
	stk.push(0);
	edge_rank.push(iHead[0]);
	dep.push(1);
	vis[0] = 1;
	int CircleBegin(-1);
	while (!stk.empty() && CircleBegin == -1)
	{
		int depth(dep.top());
		int NextEdge(edge_rank.top());
		while (NextEdge)
		{
			if (vis[all[NextEdge].to] == 0)
			{
				vis[all[NextEdge].to] = depth + 1;
				edge_rank.pop();
				edge_rank.push(all[NextEdge].next);
				stk.push(all[NextEdge].to);
				edge_rank.push(iHead[all[NextEdge].to]);
				dep.push(depth + 1);
				break;
			}
			else if (vis[all[NextEdge].to] != depth - 1)
			{
				CircleBegin = all[NextEdge].to;
				break;
			}
			NextEdge = all[NextEdge].next;
		}
		if (NextEdge == 0)
		{
			stk.pop();
			edge_rank.pop();
			dep.pop();
		}
	}
	while (!stk.empty())
	{
		bInCircle[stk.top()] = true;
		circle[iEndCir++] = stk.top();
		if (stk.top() == CircleBegin) break;
		stk.pop();
	}
	CLEAR_STACK(stk);
	CLEAR_STACK(edge_rank);
	CLEAR_STACK(dep);
}

int val[112345][2];
bool bVis[112345];

inline int max(const int& a, const int& b) { return a > b ? a : b; }
inline void GetMax(int& a, int b) { if (b > a) a = b; }

void dfs(int now)
{
	bVis[now] = true;
	val[now][1] = p[now];
	FOR_EDGE (i, now)
	{
		if (bVis[all[i].to] || bInCircle[all[i].to]) continue;
		dfs(all[i].to);
		val[now][0] += max(val[all[i].to][0], val[all[i].to][1]);
		val[now][1] += val[all[i].to][0];
	}
}

int dp[112345][2][2];

int solve()
{
	for (int i(0); i != iEndCir; ++i) dfs(circle[i]);
	dp[0][0][0] = val[circle[0]][0];
	dp[0][1][1] = val[circle[0]][1];
	dp[1][0][0] = dp[0][0][0] + val[circle[1]][0];
	dp[1][1][0] = dp[0][1][1] + val[circle[1]][0];
	dp[1][0][1] = dp[0][0][0] + val[circle[1]][1];
	dp[1][1][1] = -21234567;
	int last(iEndCir - 1);
	for (int i(2); i != last; ++i)
	{
		dp[i][0][0] = val[circle[i]][0] + max(dp[i - 1][0][0], dp[i - 1][0][1]);
		dp[i][0][1] = val[circle[i]][1] + dp[i - 1][0][0];
		dp[i][1][0] = val[circle[i]][0] + max(dp[i - 1][1][0], dp[i - 1][1][1]);
		dp[i][1][1] = val[circle[i]][1] + dp[i - 1][1][0];
	}
	int ret(0);
	for (int i(0); i != (1 << 3); ++i)
	{
		int a(i & 1), b((i & 2) >> 1), c((i & 4) >> 2);
		if (!a || !b && !c)
		{
			GetMax(ret, dp[last - 1][b][c] + val[circle[last]][a]);
		}
	}
	return ret;
}

int n;

int main()
{
	scanf("%d", &n);
	for (int i(0); i != n; ++i) scanf("%d", &p[i]);
	double k;
	for (int i(0); i != n; ++i)
	{
		int fr, to;
		scanf("%d%d", &fr, &to);
		add(fr, to);
		add(to, fr);
	}
	scanf("%lf", &k);
	dfs();
	int x = solve();
	printf("%.1lf\n", double(x) * k);
	return 0;
}

```

---

## 作者：I_AM_HelloWord (赞：1)

楼下的代码其实是错的，而且他题解中的dp方程也是错的。他在使用反向弧判断时，显然1^1=0，而他的链式前向星是从标号1开始，由于他在建树的时候是从第二个点1开始的，而不是从第一个点0开始的，所以本题数据并没有检测出他的问题来。管理员觉得是否需要加强数据？

我来具体说一下怎么个搞法。

首先，对于n个点n条边的联通图，它一定是一个环加外向树，大概长这样：

 ![](https://cdn.luogu.com.cn/upload/pic/7860.png) 

就是环上的每个点都是一个树的根。这个图也有很多性质。常常的处理方式是缩环为点，或者就是破环为链。

由于这个图只有一个环，直接一个dfs标记点，如果一个点走到一个已经标记的点时，这个就是环中的一条边，直接把这条边人为删掉，然后分别以这两个点为根做树形dp。这时就是一个儿子父亲的关系了，几乎就是一个（没有上司的舞会，又称聚会的快乐，可见洛谷P1271）

设dp[u][0]表示以u为根的子树中，不选u时最大流量，dp[u][1]表示以u为根的子树中选u时的最大流量，

那么根据一条边两段不能都选可知：

dp[u][0]=sigma(max(dp[v][0],dp[v][1]))

dp[u][1]=sigma(dp[v][0])+val[u]

最终就是max(dp[st][0],dp[en][0])【为什么是不选st，en的状态呢？因为我们人为的删掉了(st,en)的边，所以如果我们选了st，我们无法判断是否选了en，所以我们改成不选st，那么就可能选en，也有可能不选，但最终肯定是最优的，毕竟这条边并不是要求必须选一个点的啊！】


参考代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int M=100010;
int EdgeCnt=0,n,a[M],val[M],st,en,idx;
bool flag=false,vis[M];
struct Edge{
    int to,next;
}e[M<<1];
int dp[M][2];
double p;
int read(){
    int x=0,f=1;char ch=getchar();
    while (ch<'0' || ch>'9'){if (ch=='-')f=-1;ch=getchar();}
    while ('0'<=ch && ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return x*f;
}
void adde(int u,int v){
    int p=EdgeCnt++;
    e[p].to=v;e[p].next=a[u];
    a[u]=p;
}
void dfs(int u,int fa){
    vis[u]=true;
    for (int p=a[u];p!=-1;p=e[p].next){
        int v=e[p].to;
        if (v!=fa){
            if (vis[v]){idx=p,st=u,en=v;flag=true;return;}
            dfs(v,u);
            if (flag)return;
        }
    }
}
void calc(int u,int fa){
    dp[u][1]=val[u];dp[u][0]=0;
    for (int p=a[u];p!=-1;p=e[p].next){
        int v=e[p].to;
        if (v!=fa && p!=idx && (p^1)!=idx){
            calc(v,u);
            dp[u][0]+=max(dp[v][0],dp[v][1]);
            dp[u][1]+=dp[v][0];
        }
    }
}
int main(){
    memset(a,0xff,sizeof(a));
    n=read();
    for (int i=1;i<=n;i++)val[i]=read();
    for (int i=1;i<=n;i++){
        int u=read()+1,v=read()+1;
        adde(u,v);adde(v,u);
    }
    scanf("%lf",&p);
    dfs(1,0);
    calc(st,0);double t1=dp[st][0];
    calc(en,0);double t2=dp[en][0];
    printf("%.1f",max(t1,t2)*p);
    return 0;
}

```

---

## 作者：zhouenji (赞：1)

由于题目上说的很清楚，只有一个环，其余的全是连在环上的链

于是我们可以找到那个环，然后拆环成树，并分别以拆掉的那条边的两端为根跑树形dp，

最后取max(dp[x1][0],dp[x2][0])就行了

dp转移方程为 dp[x][1]+=max(dp[e[i].to][0],dp[e[i].to][1]);dp[x][0]+=dp[e[i].to][0];

以下是代码：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
const int maxn=1000000+10;
struct nod
{
    int next,to,w;
}e[maxn];
int head[maxn],s[maxn];
int n,m,flag=0,E,x1,x2,k=1;
bool vis[maxn];
double dp[maxn][2];
double l;
void adde(int u,int v)
{
    e[++k].next=head[u];
    e[k].to=v;head[u]=k;
}
void find(int x,int f)
{
    vis[x]=true;
    for(int i=head[x];i;i=e[i].next)
    {//printf("%d ",i);
        if(e[i].to==f) continue;
        if(flag==1) return;
        if(vis[e[i].to])
        {
            flag=1;
            E=i;x1=x;x2=e[i].to;return;
        }
        find(e[i].to,x);
    }
}
void dfs(int x,int f)
{
    dp[x][1]=s[x]*1.0*l;dp[x][0]=0;//printf("%d ",x);
    for(int i=head[x];i;i=e[i].next)
    {
        if(e[i].to==f || i==E || (i^1)==E) continue;
        dfs(e[i].to,x);
        dp[x][0]+=max(dp[e[i].to][0],dp[e[i].to][1]);
        dp[x][1]+=dp[e[i].to][0];
    }
}
int main()
{
    scanf("%d",&n);
    for(int i=0;i<n;i++) scanf("%d",&s[i]);
    for(int i=1;i<=n;i++)
    {
        int u,v;
        scanf("%d%d",&u,&v);adde(u,v);adde(v,u);
    }scanf("%lf",&l);
    find(1,1);
    dfs(x1,x1);double ss=dp[x1][0];
    dfs(x2,x2);double tt=dp[x2][0];
    printf("%.1f\n",max(ss,tt));
}
```

---

## 作者：CreeperLordVader (赞：0)

做法很复杂,常数也奇大无比,但还是跟大家分享一下我的做法

这个题我感觉比骑士那个题还难一点..因为输入的时候是以无向图的形式,每个点没有父指针

我的套路一般是这样的

### 1.拓扑排序

有父指针就用,没有父指针就顺便构造父指针,由儿子向父亲跳,同时用儿子的状态更新父亲的状态

对于本题,由于是个基环树而且是个无向图,我们用$deg[x]$记录与$x$相邻的节点数,$x$能入队,当且仅当$x$的儿子全被访问,只剩下$x$的父亲与之相连,也就是$deg[x]=1$

反映到$deg$上,每算过一个点,就把它的父亲的$deg--$,如果父亲的$deg$为1,则把父亲入队

### 2.把状态集中到环上

在第一步拓扑排序之后,环上的点状态仍然处于原始状态,没有被更新

这时我们要找到一些点$x$,$x$的父指针在环上,用x的状态更新与之相连的环上的点的状态

### 3.保存环上的点的状态

在第5步,我们会修改环上的点的状态值,因此要开一个数组保存环上的点的状态,并作为环上的点的点权

### 4.按顺序把环上点存入一个列表(我用的是STL的vector)

对于骑士那个题,可以直接利用父指针按顺序找出所有环上点,对于本题,环上的点没有参与拓扑排序,没有父指针,我们只能用一个简单的dfs来找

### 5.在列表上DP

对于本题而言,DP两次,第一次强制选环上第一个点,初值为我们保存好的状态

怎么强制呢?DP时是要取max的,因此把不选该点的结果赋值成负无穷,在DP时肯定就不会取负无穷的情况

因为是个环,最后一个与第一个点实际上是相连的,选了第一个不能选最后一个,因此答案是不选最后一个点的结果

第二次强制不选环上第一个点,与第一次DP同理

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
double ans=0.0;
double k,d[100010][2];//d是状态
double g[100010][2];//用于保存状态
bool vis[100010];
int deg[100010],a[100010];
int f[100010];//父指针
queue<int>q;
vector<int>v[100010];
vector<int>cir;//保存环上点
void read(int& x)
{
	char c=getchar();
	x=0;
	while(c<'0'||c>'9')c=getchar();
	while(c>='0'&&c<='9')
	{
		x=x*10+c-'0';
		c=getchar();
	}
}
void dfs(int x)
{
	vis[x]=1;
	cir.push_back(x);
	for(int i=0;i<v[x].size();i++)
	{
		int y=v[x][i];
		if(!vis[y])dfs(y);
	}
}
double circle(int x)
{
	double ans1=0.0,ans2=0.0;
	dfs(x);
	d[cir[0]][0]=(double)-1e9;
	d[cir[0]][1]=g[cir[0]][1];//第一次DP,强制选择第一个点
	for(int i=1;i<cir.size();i++)
	{
		d[cir[i]][0]=g[cir[i]][0]+max(d[cir[i-1]][0],d[cir[i-1]][1]);
		d[cir[i]][1]=g[cir[i]][1]+d[cir[i-1]][0];
	}
	ans1=d[cir[cir.size()-1]][0];
	d[cir[0]][0]=g[cir[0]][0];//第二次DP,强制不选第一个点
	d[cir[0]][1]=(double)-1e9;
	for(int i=1;i<cir.size();i++)
	{
		d[cir[i]][0]=g[cir[i]][0]+max(d[cir[i-1]][0],d[cir[i-1]][1]);
		d[cir[i]][1]=g[cir[i]][1]+d[cir[i-1]][0];
	}
	ans2=max(d[cir[cir.size()-1]][0],d[cir[cir.size()-1]][1]);
	return max(ans1,ans2);
}
int main()
{
	read(n);
	for(int i=1;i<=n;i++)
	{
		read(a[i]);
	}
	for(int i=1;i<=n;i++)
	{
		int x,y;
		read(x);
		read(y);
		x++;
		y++;
		v[x].push_back(y);
		v[y].push_back(x);
		deg[x]++;
		deg[y]++;
	}
	scanf("%lf",&k);
	for(int i=1;i<=n;i++)
	{
		d[i][1]=a[i]*k;
		if(deg[i]==1)
		{
			q.push(i);
		}
	}
	while(!q.empty())//拓扑排序
	{
		int fa=q.front();
		q.pop();
		vis[fa]=1;
		for(int i=0;i<v[fa].size();i++)
		{
			int y=v[fa][i];
			if(vis[y])//访问过,肯定是儿子
			{
				d[fa][0]+=max(d[y][1],d[y][0]);
				d[fa][1]+=d[y][0];
			}
			else//这个y没有访问过,肯定是父亲
			{
				deg[y]--;
				f[fa]=y;
				if(deg[y]==1)q.push(y);
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		if(vis[i])
		{
			if(!vis[f[i]])
			{
				d[f[i]][0]+=max(d[i][1],d[i][0]);
				d[f[i]][1]+=d[i][0];//用不在环上的点的状态更新环上的点
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		if(!vis[i])//保存状态
		{
			g[i][0]=d[i][0];
			g[i][1]=d[i][1];
		}
	}
	for(int i=1;i<=n;i++)
	{
		if(!vis[i])ans+=circle(i);
	}
	printf("%.1lf",ans);
}
```


---

## 作者：Linne (赞：0)

比较简单的一道题，不过有点考验代码能力。

------------

显然，我们要找一个最大独立集，然而是在基环树上。那么我们第一步先找出环（关于怎么找，有很多方法，我习惯用并查集加一遍dfs)，标记出来。然后对于环上的每个节点分离出来作为根，做一遍树上的最大独立集。这样除了环之外的部分就没有用了。接着做两遍环形dp，每次强制不选头/尾，就好了。其实也比较模板。

------------

我码风不好，凑合看吧QAQ
```cpp

#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
#define RE register
#define clear(a) memset(a,0,sizeof a)

inline int read(){
    int date=0,w=1;char c=0;
    while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
    while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}
    return date*w;
}

void chkmin(int &x,int y){
	x=min(x,y);
}
void chkmax(int &x,int y){
	x=max(x,y);
}
const int N=2000005;
int  n,head[N],nxt[N],ver[N],tot,v[N],fa[N];
void add(int x,int y){
	ver[++tot]=y;nxt[tot]=head[x];head[x]=tot;
}
int find(int x){
	if(fa[x]==x)return x;
	return fa[x]=find(fa[x]);
}
void merge(int x,int y){
	int a=find(x),b=find(y);
	fa[a]=b;
}
bool in_one(int x,int y){
	return find(x)==find(y);
}
int loop[N];
stack<int>s;
int st,e,vis[N],lop[N],cnt;
bool flg=0;
void dfs(int x){
	s.push(x);
	
		if(x==e){
			while(s.size()){
				loop[s.top()] =1;
				lop[++cnt]=s.top();
				s.pop();
			}
			flg=1;
			return;
		}
	
	if(vis[x]){ s.pop();return;
	}
	vis[x]=1;
	for(int i=head[x];i;i=nxt[i]){
		int y=ver[i];
		dfs(y); 
		if(flg)return;
	}
	s.pop();
	vis[x]=0;
}
long double k;
int p[N],f[N][2];
void dfs2(int x){
	vis[x]=1;
	int sum1=0,sum2=0;
	for(int i=head[x];i;i=nxt[i]){
		int y=ver[i];
		if(!loop[y]){
			if(!vis[y]){
				dfs2(y);
				sum1+=f[y][0];
				sum2+=max(f[y][0],f[y][1]);
			}
			
		}
	}
	f[x][0]=sum2;
	f[x][1]=sum1+p[x];
}
int d[N][2],ans;
int main(){
	
    n=read();
    for(int i=1;i<=n;++i)p[i]=read();
    for(int i=1;i<=n;++i)fa[i]=i;
    for(int i=1;i<=n;++i){
    	int x,y;
    	x=read();y=read();
    	x++;y++;
    	
    	if(in_one(x,y)){
    		st=x;
    		e=y;
		}
    	else{
    		add(x,y);
    		add(y,x);
    		merge(x,y);
		} 
	}
	cin>>k;
	dfs(st);
//	for(int i=1;i<=n;++i){
//	 cout<<loop[i]<<endl;
//	}
	clear(vis);
	for(int i=1;i<=n;++i){
		if(!loop[i])continue;
		dfs2(i);
	}
	for(int i=1;i<=cnt;++i){
		int x=lop[i];
		d[i][0]=max(d[i-1][0],d[i-1][1])+f[x][0];
		d[i][1]=d[i-1][0]+f[x][1];
	}
	chkmax(ans,d[cnt][0]);
	clear(d);
	for(int i=cnt;i;--i){
		int x=lop[i];
		d[i][0]=max(d[i+1][0],d[i+1][1])+f[x][0];
		d[i][1]=d[i+1][0]+f[x][1];
	}
	chkmax(ans,d[1][0]);
	k*=ans;
//	for(int i=1;i<=n;++i){
//		if(loop[i])cout<<"qwq "<< i <<": "<< f[i][0] <<' '<< f[i][1] <<endl;
//	}
	cout<<fixed<<setprecision(1)<<k<<endl;
	return 0;
}

```


---


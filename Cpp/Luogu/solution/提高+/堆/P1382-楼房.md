# 楼房

## 题目描述

地平线（$x$ 轴）上有 $n$ 个楼房，每个楼房可以表示为一个矩形。

用三个整数 $h_i,l_i,r_i$ 来表示第 $i$ 个矩形：矩形左下角为 $(l_i,0)$，右上角为 $(r_i,h_i)$。

地平线高度为 $0$。在轮廓线长度最小的前提下，从左到右输出轮廓线。

## 说明/提示

样例二如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/pmf4pzif.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/5ec8sxwi.png)

数据范围:

对于 $30\%$ 的数据，$n\le100$。

对于另外 $30\%$ 的数据，$1\le h_i,l_i,r_i\le 1000$。

对于 $100\%$ 的数据，$1\le n\le10^5$，$1\le h_i\le 10^9$，$-10^9\le l_i<r_i\le10^9$。

## 样例 #1

### 输入

```
2
3 0 2
4 1 3
```

### 输出

```
6
0 0
0 3
1 3
1 4
3 4
3 0```

## 样例 #2

### 输入

```
5
3 -3 0
2 -1 1
4 2 4
2 3 7
3 6 8```

### 输出

```
14
-3 0
-3 3
0 3
0 2
1 2
1 0
2 0
2 4
4 4
4 2
6 2
6 3
8 3
8 0```

# 题解

## 作者：shuri001 (赞：26)

扫描线

注释非常详细 请看看ovo


```cpp
#include<cstdio>
#include<set>
#include<algorithm>
using namespace std;
int n,cnt,num;
struct build{
    int h,l,r;//高，左，右 
}a[100010];
struct line{
    int up,x,k;//高，x轴，出入属性 
}l[200020];//扫描线 
struct ANS{
    int ax,ay;//左边，右边 
}ans[400040];
int read(){
    char c=getchar();int num=0,flag=1;
    while(c<'0'||c>'9'){if(c=='-')flag=-1;c=getchar();}
    while(c>='0'&&c<='9'){num=num*10+c-'0';c=getchar();}
    return num*flag;
```
}//读入优化
```cpp
multiset<int>s;//存高度，默认递增，可以重复 
int cmp(line i,line j){
    if(i.x!=j.x)return i.x<j.x;//如果靠左的排到前面 
    if(i.k!=j.k)return i.k<j.k;//入边在前 
    if(i.k==1)return i.up>j.up;//入边越高越容易挡住 
    if(i.k==2)return i.up<j.up;//出边越矮越容易挡住 
}
int main(){
    n=read();//读边数 
    for(int i=1;i<=n;i++){
        a[i].h=read(),a[i].l=read(),a[i].r=read();//读入 
        l[++cnt].up=a[i].h,l[cnt].x=a[i].l,l[cnt].k=1;//加入边 
        l[++cnt].up=a[i].h,l[cnt].x=a[i].r,l[cnt].k=2;//加出边 
    }
    sort(l+1,l+cnt+1,cmp);//为扫描排序 
    s.insert(0);//初始最大高度为0 
    for(int i=1;i<=cnt;i++){
        int mx=*s.rbegin();//取最高的高度 
        if(l[i].k==1){//如果是入边 
            if(l[i].up<=mx) s.insert(l[i].up);//比最高矮，加入堆 
            else{
                ++num;ans[num].ax=l[i].x;ans[num].ay=mx;//记录交叉点 
                ++num;ans[num].ax=l[i].x;ans[num].ay=l[i].up;//记录交叉点上面的点 
                s.insert(l[i].up);//加高 
            }
        }
        if(l[i].k==2){//如果是出边 
            if(l[i].up==mx&&s.count(mx)==1){//如果当前的就是最高的线，而且，没有跟它一样高的 
                s.erase(mx);//取出这一条 
                ans[++num].ax=l[i].x; ans[num].ay=l[i].up;// 记录右上顶点 
                ans[++num].ax=l[i].x;ans[num].ay=*s.rbegin();//记录交叉点 
            }
            else s.erase(s.find(l[i].up));//删掉一样高的边 
        }
    }
    printf("%d\n",num);//输出节点个数 
    for(int i=1;i<=num;i++)   printf("%d %d\n",ans[i].ax,ans[i].ay); //输出结果 
    return 0;
}

```

---

## 作者：xiaolou (赞：25)

P1382 解题报告 By xiaolou

# 前置瞎BB

最近又切了几道线段树~~水题~~，于是再发一篇解题报告~~骗咕值~~，翻了一下第一页的题解，全都看不懂，咕计全tm是神仙

结果发现没几篇线段树的，就来BB一发

线段树太好使了~~虽然我好像在某篇分块题解里说过线段树垃圾~~

# 主要思想

应该都能看出来是线段树叭，线段树如果没学过，请先去学（大雾）

# 代码实现

因为出题人非常 disgusting，所以要加一个sb的离散化，然后我就威胁机房同学交了我一下离散化

其实就是线段树直接搞一搞，维护离散化后每个单位上的高度最大值就好了，最后用一个数组存答案，最后一起输出

贴一下常数大，又臭又长而且极其丑陋的代码

```cpp
#include <bits/stdc++.h>

using namespace std;
struct Node
{
	int le,ri;
	int mx;
}t[4000005];
int a[4000005],x[4000005],y[4000005],h[4000005];
void BuildT(int id,int l,int r)//建树，没什么可讲的，注意细节
{
	t[id].le=l;
	t[id].ri=r;
	t[id].mx=0;
	if(l==r)
	{
		return;
	}
	int mid=(l+r)/2;
	BuildT(id*2,l,mid);
	BuildT(id*2+1,mid+1,r);
}
void Push(int id)
{
	t[id*2].mx=max(t[id*2].mx,t[id].mx);
	t[id*2+1].mx=max(t[id*2+1].mx,t[id].mx);		
}
void Change(int id,int l,int r,int c)//修改，注意修改区间的
判定{
    if(t[id].le==l&&t[id].ri==r)
    {
        t[id].mx=max(t[id].mx,c);
        return;
    }
    Push(id);
    if(r<=t[id*2].ri)
    {
        Change(id*2,l,r,c);
    }
    else if(l>=t[id*2+1].le)
    {
        Change(id*2+1,l,r,c);
    }
    else//我在这里死过
    {
        Change(id*2,l,t[id*2].ri,c);
        Change(id*2+1,t[id*2+1].le,r,c);
    }
}
int Query(int id,int pos)//查询
{
	if(t[id].le==t[id].ri)
	{
		return t[id].mx;
	}
	Push(id);
	if(pos<=t[id*2].ri)
	{
		return Query(id*2,pos);
	}
	else
	{
		return Query(id*2+1,pos);
	}
}

int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
	{
		scanf("%d%d%d",&h[i],&x[i],&y[i]);
		a[i*2-1]=x[i];
		a[i*2]=y[i];
	}
	sort(a+1,a+2*n+1);
	int m=unique(a+1,a+2*n+1)-a-1;
	BuildT(1,1,m);
	for(int i=1;i<=n;++i)//离散化部分，就不解释了
	{
		x[i]=lower_bound(a+1,a+m+1,x[i])-a;
		y[i]=lower_bound(a+1,a+m+1,y[i])-a;
		Change(1,x[i],y[i]-1,h[i]);
	}
	int cnt=0;
	int last=0;
	x[++cnt]=a[1];
	y[cnt]=0;
	for(int i=1;i<m;++i)
	{
		int height=Query(1,i);
		if(height!=last)
		{
			x[++cnt]=a[i];
			y[cnt]=height;
			x[++cnt]=a[i+1];
			y[cnt]=height;
		}
		else
		{
			x[cnt]=a[i+1];
		}
		last=height;//对于每个单位，求出高度，把结果存进数组里
	}
	printf("%d\n",cnt+1);
	for(int i=1;i<=cnt;++i)
	{
		printf("%d %d\n",x[i],y[i]);
	}
	printf("%d 0",a[m]);
	return 0;
}
```
最后安利一下[我的博客](https://www.luogu.org/blog/xiaolou/)

点个赞吧

---

## 作者：wanghanjun (赞：15)

大致思路是离散化+线段树

### 离散化
这题有负数，数据范围还是1e9，不用离散化肯定会炸空间（除非你用其他做法）

先用sort排序，再用unique函数去重，查找所在位置时用lower_bound即可。

#### 代码：
```cpp
for(int i=1;i<=n;i++){
	scanf("%d%d%d",&h[i],&x[i],&y[i]);
	a[i*2-1]=x[i];
	a[i*2]=y[i];
}
sort(a+1,a+2*n+1);
m=unique(a+1,a+2*n+1)-a-1;
for(int i=1;i<=n;i++){
	x[i]=lower_bound(a+1,a+m+1,x[i])-a;
	y[i]=lower_bound(a+1,a+m+1,y[i])-a;
}
```
注意一下，lower_bound和unique返回的是指针，要-a。

### 线段树
离散化之后，就可以用线段树啦。

维护每一段（即相邻两点之间）的最大高度，比较简单，不需要用lazy，直接取最大值就可以了。

#### 代码：
```cpp
void buildtree(int id,int l,int r){
	t[id].l=l;t[id].r=r;t[id].h=0;
	if(l==r){
		return;
	}
	int mid=(l+r)/2;
	buildtree(id<<1,l,mid);
	buildtree(id<<1|1,mid+1,r);
}//建树

void pushdown(int id){
	t[id<<1].h=max(t[id<<1].h,t[id].h);
	t[id<<1|1].h=max(t[id<<1|1].h,t[id].h);
}//下移

void change(int id,int l,int r,int c){
	if(t[id].l==l&&t[id].r==r){
		t[id].h=max(t[id].h,c);
		return;
	}
	pushdown(id);
	if(t[id<<1].r>=r){
		change(id<<1,l,r,c);
	}
	else if(t[id<<1|1].l<=l){
		change(id<<1|1,l,r,c);
	}
	else{
		change(id<<1,l,t[id<<1].r,c);
		change(id<<1|1,t[id<<1|1].l,r,c);
	}
}//修改

int query(int id,int k){
	if(t[id].l==t[id].r){
		return t[id].h;
	}
	pushdown(id);
	if(k<=t[id<<1].r){
		return query(id<<1,k);
	}
	else{
		return query(id<<1|1,k);
	}
}//查询
```

### 输出（大雾）
我觉得这道题的输出也是这道题的一大难点，我开始维护的是每一点上的最大高度，结果发现不好输出，才改为维护每一段。

对于每一段，记录左侧编号和右侧编号及其高度，如果和上一段高度一样，就把那段右侧“拉长”，即改为当前一段的右侧编号。

#### 代码：
```cpp
last=0;
cnt++;
x[cnt]=a[1];y[cnt]=0;
for(int i=1;i<m;i++){
	int p=query(1,i);
	cout<<"height = "<<p<<endl;1021;
	if(p!=last){
		cnt++;
		x[cnt]=a[i];y[cnt]=p;
		cnt++;
		x[cnt]=a[i+1];y[cnt]=p;
	}
	else{
		x[cnt]=a[i+1];
	}
	last=p;
}
printf("%d\n",cnt+1);
for(int i=1;i<=cnt;i++){
	printf("%d %d\n",x[i],y[i]);
}
printf("%d 0\n",a[m]);
```
## 然后把以上所有部分拼在一起就可以了。

### 附代码：
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;

const int MAXN=100005;
struct tree{
	int l,r,h;
}t[MAXN<<2];
int a[MAXN<<1],x[MAXN],y[MAXN],h[MAXN],n,m,last,cnt=0;

void buildtree(int id,int l,int r){
	t[id].l=l;t[id].r=r;t[id].h=0;
	if(l==r){
		return;
	}
	int mid=(l+r)/2;
	buildtree(id<<1,l,mid);
	buildtree(id<<1|1,mid+1,r);
}//建树

void pushdown(int id){
	t[id<<1].h=max(t[id<<1].h,t[id].h);
	t[id<<1|1].h=max(t[id<<1|1].h,t[id].h);
}//下移

void change(int id,int l,int r,int c){
	if(t[id].l==l&&t[id].r==r){
		t[id].h=max(t[id].h,c);
		return;
	}
	pushdown(id);
	if(t[id<<1].r>=r){
		change(id<<1,l,r,c);
	}
	else if(t[id<<1|1].l<=l){
		change(id<<1|1,l,r,c);
	}
	else{
		change(id<<1,l,t[id<<1].r,c);
		change(id<<1|1,t[id<<1|1].l,r,c);
	}
}//修改

int query(int id,int k){
	if(t[id].l==t[id].r){
		return t[id].h;
	}
	pushdown(id);
	if(k<=t[id<<1].r){
		return query(id<<1,k);
	}
	else{
		return query(id<<1|1,k);
	}
}//查询

int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d%d%d",&h[i],&x[i],&y[i]);
		a[i*2-1]=x[i];
		a[i*2]=y[i];
	}
	sort(a+1,a+2*n+1);
	m=unique(a+1,a+2*n+1)-a-1;
	buildtree(1,1,m);
	for(int i=1;i<=n;i++){
		x[i]=lower_bound(a+1,a+m+1,x[i])-a;
		y[i]=lower_bound(a+1,a+m+1,y[i])-a;
		change(1,x[i],y[i]-1,h[i]);
	}//离散化
	last=0;
	cnt++;
	x[cnt]=a[1];y[cnt]=0;
	for(int i=1;i<m;i++){
		int p=query(1,i);
		cout<<"height = "<<p<<endl;1021;
		if(p!=last){
			cnt++;
			x[cnt]=a[i];y[cnt]=p;
			cnt++;
			x[cnt]=a[i+1];y[cnt]=p;
		}
		else{
			x[cnt]=a[i+1];
		}
		last=p;
	}
	printf("%d\n",cnt+1);
	for(int i=1;i<=cnt;i++){
		printf("%d %d\n",x[i],y[i]);
	}
	printf("%d 0\n",a[m]);//输出
	return 0;
}
```


---

## 作者：Rayment (赞：11)

补充一个zkw线段树的做法。

这个题为什么适合用zkw线段树做呢，原因是，虽然题目需要区间更新，但是却只要求最后一次询问输出答案。但是这个题目有很多细节要处理一下。

首先，一看数据范围，不用离散化想必是不行的。其次，这个线段树其实只需要维护高度最大值，根据zkw线段树的思想，lazy标记可以直接代替节点所维护出的值，于是这个线段树我们只需要lazy数组就好了。最后，因为题中所给的均为一个矩形，那么两个相邻的x坐标之间的轮廓线必定是水平的。因此，我们可以不妨保存一个上一个相邻x节点所维护出来的高度为pre，对于这个x坐标上的两个拐点，其中一个高度等于pre，另外一个就是这个线段树维护出来的高度，然后就可以愉快地输出了。

除此之外，还有保存节点数的数组应该要开到size的四倍，因为在没有任何两个矩形重合的情况下，拐点数量会达到size的四倍;还有lazy标记要开到size的八倍……问了一位神犇，神犇说因为如果对叶子节点下推标记，那么就会导致WA。突然发现自己以前打pushdown的时候，貌似从来没有注意过这个问题，于是就酿成了惨剧，交到我都开始怀疑自己是来卡评测的……


```cpp
#include <algorithm>
#include <iostream>
#include <cstdio>
using namespace std;
const int size=100010;
int n,N,r=0,p=0,pre=0,z[size],y[size],h[size],rank[size<<1],lazy[size<<3];
struct data{
    int x,y;
}point[size<<2];
template <typename Tp> inline void read(Tp &x)
{
    x=0;
    int f=1;
    char ch=getchar();
    while(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();
    if(ch=='-') f=-1,ch=getchar();
    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();
    x*=f;
}
void input()
{
    read(n);
    for(int i=1;i<=n;i++)
    {
        read(h[i]);
        read(z[i]);
        rank[++r]=z[i];
        read(y[i]);
        rank[++r]=y[i];
    }
}
int get(int x)
{
    int z=1,y=r,m;
    while(z^y)
    {
        m=(z+y)>>1;
        if(x==rank[m])
          return m;
        if(x>rank[m])
          z=m+1;
        else
          y=m;
    }
    return z;
}
void pushdown(int rt)
{
    if(lazy[rt<<1]<lazy[rt])
      lazy[rt<<1]=lazy[rt];
    if(lazy[rt<<1|1]<lazy[rt])
      lazy[rt<<1|1]=lazy[rt];
    lazy[rt]=0;
}
void update(int l,int r,int val)
{
    for(l+=N-1,r+=N+1;l^r^1;l>>=1,r>>=1)
    {
        if(~l&1 &&lazy[l^1]<val)
          lazy[l^1]=val;
        if(r&1  &&lazy[r^1]<val)
          lazy[r^1]=val;
    }
}
int main()
{
    input();
    sort(rank+1,rank+r+1);
    r=unique(rank+1,rank+2*n+1)-rank-1;
    for(N=1;N<r+2;N<<=1);
    for(int i=1;i<=n;i++)
      update(get(z[i]),get(y[i])-1,h[i]);
    for(int i=1;i<N;i++)
      if(lazy[i])
        pushdown(i);
    for(int i=1;i<=r;i++)
      if(lazy[i+N]!=pre)
      {
          point[++p].x=rank[i],point[p].y=pre;
          point[++p].x=rank[i],point[p].y=lazy[i+N];
          pre=lazy[i+N];
      }
    printf("%d\n",p);
    for(int i=1;i<=p;i++)
      printf("%d %d\n",point[i].x,point[i].y);
    return 0;
}
```

---

## 作者：George1123 (赞：8)

[${\color{orange}\text{欢迎拜访我这个蒟蒻的博客}}$](https://www.luogu.org/blog/wzc-wwwwd/)
#### 此题算法标签：线段树、二叉堆
### 我感觉用二叉堆要快得多
## 思路：
### 1.建一个堆H
###### ~~别手写了，用STL快得多~~
#### 代码如下
```cpp
struct Heap{
    priority_queue<int> Q,D;
    void push(int x){
        Q.push(x);
    } void del(int x){
        D.push(x);
    } int top(){
        while(!D.empty()&&
        Q.top()==D.top()){
            Q.pop();
            D.pop();
        } if(Q.empty()) return -1;
        return Q.top();
    } void clear(){
        while(!Q.empty()) Q.pop();
        while(!D.empty()) D.pop();
    } bool empty(){
    	return Q.empty();
	}
}H;
```
### 2.~~拆楼~~将一个楼房看成左竖线和右竖线
##### 好方法：包装成结构体数组T+按x轴排序
#### 此后即可用二叉堆处理竖(fei)线(xu)
#### 这是结构体代码：
```cpp
struct SKY{
	int x,h;
	bool f;
	void make(int xl,
	int hl,bool fl){
		x=xl;
		h=hl;
		f=fl;
	} bool operator ==(SKY rhs){
		return (x==rhs.x&&
		h==rhs.h&&f==rhs.f);
	}
}in;
```
#### f=1 左竖线
#### f=0 右竖线

#### 这是排序函数：
```cpp
bool cmp(SKY p,SKY q){
	if(p.x!=q.x)
		return p.x<q.x;
	if(p.f!=q.f)
		return p.f>q.f;
	if(p.f) return p.h>q.h;
	return p.h<q.h;
}
```
#### 最后两句是不是很奇怪？
#### 但是如果你不这么写，你就只能过这题：


[P1904 【天际线】](https://www.luogu.org/problem/P1904)
#### 因为房屋的起点、终点可以重合
#### 这么写恰好维护了二叉堆的处理顺序
#### ~~不这么写60分~~
### 3.走线
#### （1） 将竖线们排序
```cpp
sort(T.begin(),T.end(),cmp);
```
#### （2） 遍历竖线，将竖线的高度压进二叉堆
### 如果f=1，当前竖线是最高的，将相关两点放进数组ans
```cpp
if(T[i].f){
	if(T[i].h>H.top()){
		a.make(T[i].x,H.top());
		ans.push_back(a);
		a.make(T[i].x,T[i].h);
		ans.push_back(a);
	} H.push(T[i].h);
}
```
### 如果f=0，并且对应竖线是最高的，也将相关两点放进数组ans
```cpp
else {
			if(T[i].h==H.top()){
				H.del(H.top());
				if(T[i].h!=H.top()){
					a.make(T[i].x,T[i].h);
					ans.push_back(a);
					a.make(T[i].x,H.top());
					ans.push_back(a);
				}
			} else H.del(T[i].h);
		}
```
#### * _关键：可能有并列最高，如上特判_ 
### 最后输出数组ans就好了（ans是点数组）
## 全代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
struct SKY{
	int x,h;
	bool f;
	void make(int xl,
	int hl,bool fl){
		x=xl;
		h=hl;
		f=fl;
	} bool operator ==(SKY rhs){
		return (x==rhs.x&&
		h==rhs.h&&f==rhs.f);
	}
}in;
struct point{
	int x,y;
	void make(int xl,int yl){
		x=xl; y=yl;
	}
}a;
int n,left,m;
int L,Hi,R;
vector<SKY> T;
vector<point> ans;
struct Heap{
    priority_queue<int> Q,D;
    void push(int x){
        Q.push(x);
    } void del(int x){
        D.push(x);
    } int top(){
        while(!D.empty()&&
        Q.top()==D.top()){
            Q.pop();
            D.pop();
        } if(Q.empty()) return -1;
        return Q.top();
    } void clear(){
        while(!Q.empty()) Q.pop();
        while(!D.empty()) D.pop();
    } bool empty(){
    	return Q.empty();
	}
}H;
bool cmp(SKY p,SKY q){
	if(p.x!=q.x)
		return p.x<q.x;
	if(p.f!=q.f)
		return p.f>q.f;
	if(p.f) return p.h>q.h;
	return p.h<q.h;
} int main(){
	scanf("%d",&n);
	in.make(INT_MIN,0,1);
	T.push_back(in);
	H.push(0);
	for(int i=1;i<=n;i++){
		cin>>Hi>>L>>R;
		in.make(L,Hi,1);
		T.push_back(in);
		in.make(R,Hi,0);
		T.push_back(in);
	} sort(T.begin(),T.end(),cmp);
	for(int i=1;i<=2*n;i++){
		if(T[i].f){
			if(T[i].h>H.top()){
				a.make(T[i].x,H.top());
				ans.push_back(a);
				a.make(T[i].x,T[i].h);
				ans.push_back(a);
			} H.push(T[i].h);
		} else {
			if(T[i].h==H.top()){
				H.del(H.top());
				if(T[i].h!=H.top()){
					a.make(T[i].x,T[i].h);
					ans.push_back(a);
					a.make(T[i].x,H.top());
					ans.push_back(a);
				}
			} else H.del(T[i].h);
		}
	} m=ans.size();
	cout<<m<<endl;
	for(int i=1;i<=m;i++)
		cout<<ans[i-1].x<<" "
		<<ans[i-1].y<<endl;
	return 0;
}
```
## 谢谢大家！！
#### 你过了这题后，可以把上面1904过了




---

## 作者：Flanksy (赞：7)

### 并查集

------------

#### 前言

这个做法的优点：好想、好写且效率较高。

类似[白雪皑皑](https://www.luogu.com.cn/problem/P2391)中的区间染色，后被染色的区间颜色会覆盖任何先前被染色的区间颜色，区间的染色存在顺序，从后到前的染色顺序可以直接固定区间的颜色，不接受之后（实际操作序列中之前）的染色；在本题中更高的楼房会覆盖更低的楼房的天际线，和白雪皑皑类似。

笔者将这种题目的性质大致总结如下：**对于序列的操作存在优先级，优先级高的操作覆盖优先级低的操作**。所以，如果按照优先级进行操作，配合并查集就可以实现对于序列每个元素的 $O(1)$ 操作。

------------

#### 并查集优化暴力染色

暴力思路：使用数组 $c$ 记录区间 $[-10^9,+10^9]$ 上每个整数点的高度，对位置 $c_i$ 取原高度和当前楼房高度 $\max$，所有操作结束后遍历 $c$，统计拐点数并记录其位置输出。

无需分析，本题的时间和空间限制显然无法接受此等做法的花费。

一个显而易见的优化：由于答案只要求统计天际线拐点个数和坐标，只考虑可能存在拐点的位置，即每栋楼房的最左端和最右端。离散后对每个位置更新最大高度，最终扫描一遍离散序列，统计拐点数量并记录位置、输出。

由于每栋楼房离散后被序列中的两个点代替，时间复杂度瓶颈为染色操作的 $O(n^2)$。

现在使用并查集，楼房的高度已经提前得知，从高到低对楼房排序后，依次更新每个位置的高度，已经更新过的位置用并查集跳过。由于使用并查集，每个位置至多被染色 $1$ 次，染色操作的时间复杂度优化至均摊 $O(n\log n)$，总体时间复杂度 $O(n\log n)$。至此，可以通过此题。

拐点的出现是因为位置存在高度变化，其必定成对出现，所以可以依次比较每个位置的高度来记录答案。为了防止两栋楼房之间的缝隙被错误填充，将楼房离散后的右端点 $-1$，连带解决了最后一个天际线拐点 $y$ 坐标应为 $0$ 的处理，不需要额外操作。

```cpp
#include<algorithm>
#include<iostream>
#include<utility>
#include<vector>
using namespace std;
struct House{int h,l,r;}s[100001];
int n,cnt,c[200001],f[200001],p[200001];//数组c记录离散后每个点的高度
vector<pair<int,int> > v;//记录天际线拐点的坐标
bool cmp(const House &x,const House &y){
	return x.h>y.h;
}
int ask(const int &x){
	if(x==f[x]) return x;
	return f[x]=ask(f[x]);
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>s[i].h>>s[i].l>>s[i].r;
		p[i]=s[i].l,p[i+n]=s[i].r;
	}
	sort(s+1,s+n+1,cmp);//排序和离散化
	sort(p+1,p+n*2+1);
	cnt=unique(p+1,p+n*2+1)-p-1;
	for(int i=1;i<=cnt;i++) f[i]=i;//并查集初始化
	for(int i=1;i<=n;i++){
		s[i].l=lower_bound(p+1,p+cnt+1,s[i].l)-p;
		s[i].r=lower_bound(p+1,p+cnt+1,s[i].r)-p;
		for(int j=ask(s[i].r-1);j>=s[i].l;j=ask(j-1))
			c[j]=s[i].h,f[j]=f[j-1];//并查集更新
	}
	for(int i=1;i<=cnt;i++) if(c[i]!=c[i-1]){
		v.push_back({p[i],c[i-1]});
		v.push_back({p[i],c[i]});
	}
	cout<<v.size()<<'\n';
	for(auto &i:v) cout<<i.first<<' '<<i.second<<'\n';
	return 0;
}
```

------------

#### 闲话

笔者练习扫描线时看到了此题，联想到并查集，翻阅题解区却没找到一篇提及并查集的题解，最终抱着偷懒的心态实现并通过了，几个月后心血来潮想要写一篇题解。

---

## 作者：万枪先生 (赞：5)

神犇们都用高端的方法，看不懂555crying，


我只好用低端的扫描线和堆。。。


·第一步，离散化：


 
```cpp
struct Road {
   int x, y, num;
   bool kind;
} road[nn*2];    //楼房当然是盖在路上啦~
```
在输入时把一栋楼拆成两个点，kind=1说明它是楼的终点，num是编号：
 
 
```cpp
int s=0;
for (i=1;i<=n;i++){
  scanf("%d%d%d",&h,&l,&ri);
  road[s].num=i;
  road[s].y=h;
  road[s++].x=l;
  road[s].kind=1;
  road[s].num=i;
  road[s].y=h;
  road[s++].x=ri;
}
```
按 x 从小到大sort。
·第二步，用堆求解：

堆中存楼高和编号num(用num与bool数组来判断一栋楼是否已经过去了)。

堆维护扫过的、还没过去的楼中的最大高度，因为充当轮廓都是当前最大楼高。

for (i=0;i<s;i++) 一遍就好了。

细节有好多，讲了就没意思了。

·第三步 输答案。

复杂度： O（nlogn）



```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#define r register
#define nn 100005
using namespace std;
bool vis[nn];
int Ans[nn*4][2];
struct Dui{
    int y;
    int num;
}dui[nn*20];
struct Road{
    int x,y,num;
    bool kind;
}road[nn*2];
inline bool cmp(r Road a,r Road b){
    return a.x<b.x;
}
inline bool cmp2(r Dui a,r Dui b){
    return a.y<b.y;
}
int main(){
    r int n,i,s=0,l,ri,h;
    cin>>n;
    for (i=1;i<=n;i++){
        scanf("%d%d%d",&h,&l,&ri);
        road[s].num=i;
        road[s].y=h;
        road[s++].x=l;
        road[s].kind=1;
        road[s].num=i;
        road[s].y=h;
        road[s++].x=ri;
    }
    sort(road,road+s,cmp);
    r int pre=0,last=0,a=0,tail=0,now;
    for (i=0;i<s;i++){
        now=road[i].x;
        while (road[i].x==now){
            if (road[i].kind){
                vis[road[i].num]=1;
                while (vis[dui[0].num]){
                    pop_heap(dui,dui+tail+1,cmp2);
                    tail--;
                }
            }
            else {
                dui[++tail].y=road[i].y;
                dui[tail].num=road[i].num;
                push_heap(dui,dui+tail+1,cmp2);
            }
            i++;
        }
        i--;
        if (dui[0].y>pre||(vis[last]&&dui[0].y!=pre)){
            Ans[++a][0]=road[i].x;
            Ans[a][1]=pre;
            Ans[++a][0]=road[i].x;
            Ans[a][1]=dui[0].y;
            pre=dui[0].y;
            last=dui[0].num;
        }
    }
    cout<<a<<endl;
    for (i=1;i<=a;i++){
        printf("%d %d\n",Ans[i][0],Ans[i][1]);
    }
    return 0;
}
```

---

## 作者：doby (赞：4)

不难发现轮廓线上的点坐标都在轮廓高度发生变化的位置上

而轮廓的高度就是当前的最大高度

扫描线再维护当前的最大值

这里用Splay

需要对坐标离散化，只需要记录插入和弹出的时刻就可以了

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n=1,hst1=-1000000001,hst2,in,u=1,v=1,tt,cnt,root,tot,cot,tims[200010],ans[200010][2];
struct House
{
	int x,y,h;
}h[100010];
struct Popout
{
	int y,h;
}p[100010];
struct Splay
{
	int son[2],fa,val,size,cnt;
}t[100010];
bool cmp(House a,House b)
{
	if(a.x==b.x){return a.h>b.h;}
	return a.x<b.x;
}
bool comp(Popout a,Popout b)
{
	return a.y<b.y;
}
int New(int x)
{
	t[++tot].val=x,t[tot].cnt=1,t[tot].size=1;
	return tot;
}
void Update(int p)
{
	t[p].size=t[t[p].son[0]].size+t[t[p].son[1]].size+t[p].cnt;
}
int Relate(int p)
{
	return t[t[p].fa].son[1]==p; 
}
void Connect(int p,int fa,bool which)
{
	t[p].fa=fa;
	if(fa){t[fa].son[which]=p;}
}
void Rotate(int p)
{
	int fa=t[p].fa;
	bool lr=Relate(p);
	Connect(p,t[fa].fa,Relate(fa));
	Connect(t[p].son[lr^1],fa,lr);
	Connect(fa,p,lr^1);
	Update(fa);Update(p);
}
void Splay(int p,int goal)
{
	for(int fa;(fa=t[p].fa)!=goal;Rotate(p))
	{
		if(t[fa].fa!=goal){Rotate(Relate(p)==Relate(fa)?fa:p);}
	}
	if(!goal){root=p;}
}
void Insert(int x)
{
	if(!root){New(x);root=tot;return;}
	int now=root;
	while(1)
	{
		if(x==t[now].val)
		{
			++t[now].cnt;
			Update(now);Update(t[now].fa);
			Splay(now,0);
			return;
		}
		int fa=now;
		bool which=x>t[now].val;
		now=t[fa].son[which];
		if(!now)
		{
			New(x);
			Connect(tot,fa,which);
			Update(fa);
			Splay(tot,0);
			return;
		}
	}
}
void Find(int x)
{
	if(!root){return;}
	int now=root;
	while(t[now].son[x>t[now].val]&&t[now].val!=x){now=t[now].son[x>t[now].val];}
	Splay(now,0);
}
int GP(int x)
{
	Find(x);
	if(t[root].val<x){return root;}
	int now=t[root].son[0];
	while(t[now].son[1]){now=t[now].son[1];}
	return now;
}
int GN(int x)
{
	Find(x);
	if(t[root].val>x){return root;}
	int now=t[root].son[1];
	while(t[now].son[0]){now=t[now].son[0];}
	return now;
}
void Delete(int x)
{
	int pre=GP(x),nxt=GN(x);
	Splay(pre,0);
	Splay(nxt,pre);
	int del=t[nxt].son[0];
	if(t[del].cnt>1)
	{
		t[del].cnt--;
		Splay(del,0);
	}
	else{t[nxt].son[0]=0;}
}
int GVBR(int rank)
{
	int now=root;
	while(now)
	{
		if(t[now].son[0]&&rank<=t[t[now].son[0]].size)
		{
			now=t[now].son[0];
			continue;
		}
		rank-=t[t[now].son[0]].size+t[now].cnt;
		if(rank<=0){return t[now].val;}
		now=t[now].son[1];
	}
}
int main()
{
	Insert(-1000000001);Insert(1000000001);
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
	{
		scanf("%d%d%d",&h[i].h,&h[i].x,&h[i].y);
		p[i].y=h[i].y,p[i].h=h[i].h,
		tims[++cot]=h[i].x,tims[++cot]=h[i].y;//这就是离散化
	}
	sort(h+1,h+n+1,cmp);
	sort(p+1,p+n+1,comp);
	sort(tims+1,tims+cot+1);
	for(int i=1;i<=cot;++i)
	{
		tt=tims[i],hst2=0;
		while(h[u].x==tt)//插入
		{
			Insert(h[u].h);
			++u,++in;
		}
		while(p[v].y==tt)//弹出
		{
			Delete(p[v].h);
			++v,--in;
		}
		hst2=max(hst2,GVBR(in+1));//查询当前的高度
		if(hst1!=hst2){ans[++cnt][0]=tt,ans[cnt][1]=(hst1==-1000000001?0:hst1),ans[++cnt][0]=tt,ans[cnt][1]=(hst2==-1000000001?0:hst2);}//高度变化，记录
		hst1=hst2;
	}
	printf("%d\n",cnt);
	for(int i=1;i<=cnt;++i){printf("%d %d\n",ans[i][0],ans[i][1]);}
	return 0;
}
```

---

## 作者：plane (赞：4)

有两种方法。。但需要注意的细节挺多。例如两条等高线段重叠或恰好衔接的情况。


1、用堆维护当前最高高度进行计算。


2、用线段树直接计算。


---

## 作者：Fzun1ltgk8JtJT (赞：3)

### 首先，我们尝试使用线段树去解决，应该维护区间的最大值。但是这样维护感觉很不爽。于是我们将所有的矩形从矮到高排序，这样只用暴力修改每一段区间的数值即可
### 接着想去修改区间，尝试构建一棵线段树，然而左右端点范围达到了10^9，因而无法直接用矩形的边界作为线段树区间，需要进行离散化。
### 然而我懒得进行离散化，想一想这题是暴力修改一段区间为定值，自然地想到了珂朵莉树。
### 于是就用珂朵莉树A了这道题，注意所有修改完毕后，一段高度相同的区间在珂朵莉树中可能对应不只一个节点，因而尝试去合并。
### AC代码：
```cpp
#include <cstdio>
#include <algorithm>
#include <set>
#define IT set<node>::iterator
using std::set;
const int MAXN = int(1e5 + 5); 
struct node{
    mutable int l, r;
    mutable int v;
    node(int L, int R = -1, int V = 0) : l(L), r(R), v(V){}
    bool operator<(const node& o) const{
        return l < o.l;
    }
};
set<node> s;
IT split(int pos){
   IT it = s.lower_bound(pos);
   if(it != s.end() && it->l == pos)return it;
   --it;
   int L = it->l, R = it->r, V = it->v;
   s.erase(it);
   s.insert(node(L, pos - 1, V));
   return s.insert(node(pos, R, V)).first;
}
void assign(int L, int R, int V){
    IT itr = split(R + 1), itl = split(L);
    s.erase(itl, itr);
    s.insert(node(L, R, V));
}
struct rect{
    int l, r, h;
    bool used;
} a[MAXN];
bool cmp1(rect a, rect b){
	return a.l < b.l;
}
bool cmp(rect a, rect b){
    return a.h < b.h;
} 
struct ans_t{
	int x, y;
	ans_t(){}
	ans_t(int x, int y) : x(x), y(y){}
} ans[MAXN * 4];
int p;
int main(){
    int n;
    scanf("%d", &n);
    s.insert(node(int(-1e9-5), int(1e9+5), 0));
    for(int i = 1; i <= n; ++i)
        scanf("%d%d%d", &a[i].h, &a[i].l, &a[i].r); 
    std::sort(a + 1, a + 1 + n, cmp);
    for(int i = 1; i <= n; ++i)
        assign(a[i].l, a[i].r - 1, a[i].h);
    //珂朵莉树上维护的相同高度相邻的区间不一定连续，进行合并
    for(IT i = s.begin(); i != s.end();){
    	IT nex = i;
    	++nex;
    	if(nex != s.end() && nex->v == i->v && nex->l == i->r + 1){
    		i->r = nex->r;
    		s.erase(nex);
    	}else ++i;
    }
    for(IT i = s.begin(); i != s.end(); ++i){
        if(i->l == -1e9-5)ans[++p] = ans_t(i->r+1, 0);
        else if(i->r == 1e9+5)ans[++p] = ans_t(i->l, 0);
        else ans[++p] = ans_t(i->l, i->v), ans[++p] = ans_t(i->r+1,i->v);
    }
    printf("%d\n", p);
    for(int i = 1; i <= p; ++i)
    	printf("%d %d\n", ans[i].x, ans[i].y);
    return 0;
}

```

---

## 作者：CURRENT_F (赞：3)

我并不会大佬说的扫描线什么的骚操作。

我只是通过比较特殊的插入方式和线段树完成了此题。当然，看数据范围，很容易就可以想到使用离散化。在离散化时，一个矩形我插入了三个点，分别是，l,r-1,r,因为l代表在这个地方会有一个可能产生的高点，r-1是为了保证在[l,r-1]区间里，都有hi参与最大值运算。最后一个点是r，为了使其能够给其他矩形让出位置，这一点的处理比较特别。

首先，我们可以发现当h变化时，当h变大，肯定有一个更高的矩形与这一个相交或相邻，当h变小，肯定这个矩形到达了尽头，然后可能变为零或是接下来的矩形的最大h。所以在最后的r这个位置这里，我们不将这个点的高修改为h而是修改成0。而且，我们观察可以发现，当h变化时，变化的位置一定会出现两次，所以我们只存储后一次的值，用线段树计算后一次的值，然后可以直接推导出上一次的坐标值。这样，所有的出现在r位置的矩形可以正常计算。然后我们对于[l,r-1]区间就是正常的修改为h

注意几个小细节

一是开一个变量表示之前的h，以便观看h是否变化，若h没有变化则根本不需要输出这个点。
二是要根据具体情况开线段树数组的大小。

下面是代码  我的线段数常数大，跑的慢（我是菜鸡啊）

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 1e5 + 10;
int n, h[maxn], l[maxn], r[maxn], loc[8 * maxn];
priority_queue <int> A;
int read() {
    char x = getchar(); int t = 0, f = 1;
    while (x<'0' || x>'9') {
        if (x == '-') f = -1;
        x = getchar();
    }
    while (x >= '0'&&x <= '9') {
        t = t * 10 + x - '0';
        x = getchar();
    }
    return t * f;
}
struct line_tre {
    int max, lazytag;
}tre[12 * maxn];
int upout = 0,ans[8*maxn][2],cnt;
void query(int root, int tl, int tr) {
    tre[root].max = max(tre[root].max, tre[root].lazytag);
    if (tl == tr) {
        if (tre[root].max != upout) {
            ans[++cnt][0] = loc[tl];
            ans[cnt][1] = upout;
            ans[++cnt][0] = loc[tl];
            ans[cnt][1] = tre[root].max;
            upout = tre[root].max;
        }
        return;
    }
    tre[root * 2].lazytag = max(tre[root * 2].lazytag, tre[root].lazytag);
    tre[root * 2 + 1].lazytag = max(tre[root * 2 + 1].lazytag, tre[root].lazytag);
    tre[root].lazytag = 0;
    query(root * 2, tl, (tl + tr) >> 1);
    query(root * 2 + 1, ((tl + tr) >> 1) + 1, tr);
    return;
}
void update(int root, int tl, int tr, int ql, int qr, int val) {
    if (ql > tr || qr < tl) return;
    if (tl >= ql && tr <= qr) {
        tre[root].lazytag = max(tre[root].lazytag, val);
        tre[root].max = max(tre[root].max, tre[root].lazytag);
        return;
    }
    tre[root].max *= max(tre[root].max, tre[root].lazytag);
    tre[root * 2].lazytag = max(tre[root * 2].lazytag, tre[root].lazytag);
    tre[root * 2 + 1].lazytag = max(tre[root * 2 + 1].lazytag, tre[root].lazytag);
    tre[root].lazytag = 0;
    update(root * 2, tl, (tl + tr) >> 1, ql, qr, val);
    update(root * 2 + 1, ((tl + tr) >> 1) + 1, tr, ql, qr, val);
    return;
}
int erf(int x) {
    int l = 1, r = loc[0], mid;
    while (l < r) {
        mid = (l + r) >> 1;
        if (loc[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return l;
}
int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        h[i] = read(), l[i] = read(), r[i] = read();
        A.push(-l[i]); A.push(-r[i] + 1); A.push(-r[i]);
    }
    int up = -1e9-10;
    for (int i = 1; i <= 3 * n; i++) {
        if (A.top() != up) {
            up = A.top();
            loc[++loc[0]] = -A.top();
        }
        A.pop();
    }
    for (int i = 1; i <= n; i++) {
        update(1, 1, loc[0], erf(l[i]), erf(r[i] - 1), h[i]);
    }
    query(1, 1, loc[0]);
    cout << cnt << endl;
    for (int i = 1; i <= cnt; i++) {
        cout << ans[i][0] << ' ' << ans[i][1] << endl;
    }
    return 0;
}

```


---

## 作者：Melo_DDD (赞：2)

我发现一件可怕的事情，就是这道题并没有分块题解。

为啥跑了个次优解啊，但是卡不到最优解了。

思路：以矩形的横长为区间，宽度为值，维护出来之后就可以找到轮廓上的点了。

这种只用取最大值的应该优先考虑分块，好写而且（比线段树）常数小一点。

还是老套路，小块暴力取最大值，整块维护一个最大值的标记，最后查询的时候对当前点和所在块的标记取一个最大值即可得到当前位置的纵坐标。

注意值域很大但是 $n$ 很小，所以可以~~用 map~~ 离散化。

需要注意的是矩形覆盖的应该看作**单位长度而不是点**，所以假如一个矩形覆盖了轴上 $[x,y]$ 这些点应该看作是覆盖了 $[x,y-1]$ 这几条**线段**。

如何输出轮廓线上的点，可以考虑当前的的高度和上一个的高度的关系，如果不相等，把当前点的坐标放进去，如果相等，更新横坐标。

分析一下复杂度，不然太不靠谱了。

首先分块分两个部分：

1. 对小块的暴力操作。由于我们每次至多对两块进行这样的操作，每块的块长都是 $\Theta(\sqrt{n})$ 的，所以整体仍然是 $\Theta(\sqrt{n})$ 级别。
2. 对大块的区间操作，对一个大块操作的复杂度是常数级别的，由于一共只有 $\Theta(\sqrt{n})$ 块，所以这个也是 $\Theta(\sqrt{n})$ 的。

综上，分块单次操作复杂度是根号的，那么总的复杂度是 $\Theta(n\sqrt{n})$ 的。

预处理和统计答案是线性的。

离散化可以看作是循环套二分，是 $\Theta(n\log n)$ 的。

所以我们的总的复杂度还是 $\Theta(n\sqrt{n})$ 的，~~不够优秀~~可以通过本题。


代码：


```cpp
#include <bits/stdc++.h>
#define f(i ,m ,n ,x) for (int i = (m) ;i <= (n) ;i += (x))
using namespace std ;
template < typename T > inline void read ( T &x ) {
	x = 0 ;
	bool flag (0) ;
	register char ch = getchar_unlocked () ;
	while (! isdigit (ch)) {
		flag = ch == '-' ;
		ch = getchar_unlocked () ;
	}
	while (isdigit (ch)) {
		x = (x << 1) + (x << 3) + (ch ^ 48) ;
		ch = getchar_unlocked () ;
	}
	flag ? x = -x : 0 ;
} 
const int N = 2e5 + 7 ;
const int M = 630 ;
int belong[N] ,n ,h[N] ,l_[N] ,r_[N] ,b[N] ,a[N] ,tot ,t ,l[M] ,r[M] ,cov[M] ;
inline void modify (int nowl ,int nowr ,int k) {
	int p = belong[nowl] ,q = belong[nowr] ;
	if (p == q) {
		f (i ,nowl ,nowr ,1) 
			a[i] = max (a[i] ,k) ;
		return ;
	}
	f (i ,nowl ,r[p] ,1) 
		a[i] = max (a[i] ,k) ;
	f (i ,p + 1 ,q - 1 ,1) 
		cov[i] = max (cov[i] ,k) ;
	f (i ,l[q] ,nowr ,1) 
		a[i] = max (a[i] ,k) ;
	return ;
} 
inline int query (int cur) {
	return max (a[cur] ,cov[belong[cur]]) ;
}
vector < pair < int ,int > > ans ;
int main () {
	read (n) ;
	f (i ,1 ,n ,1) {
		read (h[i]) ,read (l_[i]) ,read (r_[i]) ;
		b[++ tot] = l_[i] ,b[++ tot] = r_[i] ;
	}
	sort (b + 1 ,b + tot + 1) ;
	tot = unique (b + 1 ,b + tot + 1) - b - 1 ; // 一定要去重，不然会导致断档
	f (i ,1 ,n ,1) {
		l_[i] = lower_bound (b + 1 ,b + tot + 1 ,l_[i]) - b ;
		r_[i] = lower_bound (b + 1 ,b + tot + 1 ,r_[i]) - b ;
	}
	t = sqrt (tot) ; // 注意是对 tot 分块
	f (i ,1 ,t ,1) 
		l[i] = (i - 1) * t + 1 ,r[i] = i * t ;
	if (r[t] < tot) {
		t ++ ;
		l[t] = r[t - 1] + 1 ;
		r[t] = tot ;
	}
	f (i ,1 ,t ,1) {
		f (j ,l[i] ,r[i] ,1)
			belong[j] = i ;
	}
	f (i ,1 ,n ,1) 
		modify (l_[i] ,r_[i] - 1 ,h[i]) ;           
	ans.emplace_back (b[1] ,0) ;
	int las = 0 ;
	f (i ,1 ,tot - 1 ,1) {
		int v = query (i) ;
		if (v != las) {
			ans.emplace_back (make_pair (b[i] ,v)) ;
			ans.emplace_back (make_pair (b[i + 1] ,v)) ;
		} else 
			(* -- ans.end ()).first = b[i + 1] ; // vector 的 end 返回的是空，要找前一个位置才是结尾
		las = v ;
	}
	ans.emplace_back (make_pair (b[tot] ,0)) ;
	cout << ans.size () << '\n' ;
	for (int i = 0 ;i < ans .size () ;i ++) 
		cout << ans[i].first << ' ' << ans[i].second << '\n' ;
	return 0 ;
}
```

---

## 作者：xh39 (赞：2)

前置算法:离散化**或**动态开点。 //建议先学习其中之一,但这只是代码实现问题,不会也不影响看懂题解的思路部分。

这题直接用类似于扫描线的方法就可以了。没学过扫描线的也可以看此篇题解。如果学了扫描线,基本上就是模板题了。

首先把所有平行于y轴放到一个数组里面**从小到大**排序(放平行于x轴的也可以),如果是矩形的左线段标记为1,右线段标记为-1。为什么这样标记后面再说。

现在想要维护一个矩形构成的轮廓线,那么根据之前排好序的线段逐一进行操作,如果**当前线段有顶点**,此点的x轴还是原来的x轴,y轴肯定是由当前的y值最大的线段的上端顶点的y值和其他的一个点。这个其他的点其实就是上一次的最大值。

如果没有顶点,那么就是该线段不是当前的最大值,或者不是唯一的最大值。比如对于以下2种情况。
```
(v表示枚举到了这条边)
________         __v_____
|   v___|__     |  |  |  |
|   |   |  |    |  |  |  | (图2矩形1是第1,3条边)
|___|___|__|    |__|__|__|
     图1            图2
```
所以在枚举时要特判,如果max值不更新,那么一定是以上2中情况之一。

还有一个问题:怎么求最大值?

这时候我们标记的1和-1就有用了,求最大值很容易想到线段树。然后对于标记为1的,就把线段的上下端点y值之间的值都+1,然后在修改的时候可以记录最大值,这就是结果,不用写查询函数。

细节部分: //讲一下部分我错过的地方。

考虑清楚加和查询的顺序,~~顺序不做提示,自己去调吧。~~

考虑线段重复问题,~~也不做提示~~。

代码: //注释比较少,将就着吧。
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
struct xyq{
	int x1,x2,y,sign;
}a[1000005];
struct rule{
	bool operator()(const xyq &s1,const xyq &s2){
		return s1.y<s2.y||s1.y==s2.y&&s1.x2<s2.x2;
	}
};
int x[1000005];
int addsum[1000005],size[1000005];
void change(long long id,long long nowl,long long nowr,long long ql,long long qr,long long add){
	if(nowr<ql||nowl>qr){
		return;
	}
	if(nowl>=ql&&nowr<=qr){
		addsum[id]+=add;
		if(addsum[id]>0){
			size[id]=x[nowr+1]-x[nowl]; //size可以表示最大值。
		}else{
			size[id]=0; //没有线段,即为0。
		}
		if(addsum[id]<=0){
			if(nowl==nowr){
				size[id]=0;
			}else{
				size[id]=size[id<<1]+size[(id<<1)|1];
			}
		}
		return;
	}
	long long mid=nowl+nowr>>1;
	change(id<<1,nowl,mid,ql,qr,add);
	change((id<<1)|1,mid+1,nowr,ql,qr,add);
	if(addsum[id]<=0){
		if(nowl==nowr){
			size[id]=0;
		}else{
			size[id]=size[id<<1]+size[(id<<1)|1];
		}
	}
}
int ansx[1000005],ansy[1000005],tot=0;
int main(){
	long long l,r,h,n,i,x1,y1,x2,y2,ykb,sum=0,t1,t2,last=0;
	cin>>n;
	for(i=0;i<n;++i){
		cin>>h>>l>>r;
		x1=0;
		x2=h;
		y1=l;
		y2=r;
		a[i<<1].x1=x1;
		a[(i<<1)|1].x1=x1;
		a[i<<1].x2=x2;
		a[(i<<1)|1].x2=x2;
		a[i<<1].y=y1;
		a[(i<<1)|1].y=y2;
		a[i<<1].sign=1;
		a[(i<<1)|1].sign=-1;
		x[i<<1]=x1;
		x[(i<<1)|1]=x2;
	}
	sort(a,a+(n<<1),rule()); //离散化。
	sort(x,x+(n<<1));
	ykb=(n<<1);
	for(i=0;i<ykb;++i){
		sum+=size[1]*(a[i].y-a[i-1].y);
		t1=lower_bound(x,x+ykb,a[i].x1)-x; //与下面一行都是离散化。
		t2=lower_bound(x,x+ykb,a[i].x2)-x;
		change(1,0,ykb,t1,t2-1,a[i].sign);
		if(size[1]!=last&&a[i].y!=a[i+1].y&&(a[i].y!=a[i-1].y||a[i].sign==a[i-1].sign||a[i].x2!=a[i-1].x2)){
			ansx[tot]=a[i].y;
			ansx[tot+1]=a[i].y;
			ansy[tot]=last;
			ansy[tot+1]=size[1];
			last=size[1];
			tot+=2;
		}
	}
	cout<<tot<<endl;
	for(i=0;i<tot;i++){
		cout<<ansx[i]<<" "<<ansy[i]<<endl;
	}
	return 0;
}
```

---

## 作者：Setsugesuka (赞：1)

这是一道矩形底相同的扫描线题目，对于这类题目，我们可以使用 $ODT$ 进行求解。

注意到大矩形覆盖小矩形的本质就是区间推平，不难想到把所有读入进来的矩形按高度从小到大排序，依次对每个区间进行推平，最后的结果就是答案。

遗憾的是，由于本人码风过丑，程序跑了 $640ms$ ，并不能踩爆标算。

```cpp
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#include <bits/stdc++.h>
using namespace std;

template <class T>
inline void write(T x)
{
    if(x>9)
    {
        write(x/10);
    }
    putchar(x%10+'0');
}

inline char nc()
{
    static char buf[1000000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++;
}

inline void read(int &sum)
{
    char ch=nc();
    int tf=0;
    sum=0;
    while((ch<'0'||ch>'9')&&(ch!='-')) ch=nc();
    tf=((ch=='-')&&(ch=nc()));
    while(ch>='0'&&ch<='9') sum=sum*10+(ch-48),ch=nc();
    (tf)&&(sum=-sum);
}

struct node
{
    int l,r,v;
    node(){}
    node(int L,int R=-1,int V=0):l(L),r(R),v(V){}
    inline bool operator <(const node &o) const
    {
        return l<o.l;
    }
};

struct house
{
    int l,r,h;
    inline bool operator <(const house &o) const
    {
        return h<o.h;
    }
};

set<node> s;

int n;
house a[100010];
vector<pair<int,int> >ans;

inline void merge(int l)
{
    set<node>::iterator it1,it2,it3;
    it2=s.lower_bound(l);
    if(it2==s.begin())
        return;
    it1=it2,it3=it2;
    --it1,++it3;
    bool pd3=(it3!=s.end());
    if(pd3&&it1->v==it2->v&&it2->v==it3->v&&it1->v==it3->v)
    {
        int l=it1->l,r=it3->r,v=it2->v;
        s.erase(it1,++it3);
        s.insert(node(l,r,v));
    }
    else if(it1->v==it2->v)
    {
        int l=it1->l,r=it2->r,v=it2->v;
        s.erase(it1,++it2);
        s.insert(node(l,r,v));
    }
    else if(pd3&&it2->v==it3->v)
    {
        int l=it2->l,r=it3->r,v=it2->v;
        s.erase(it2,++it3);
        s.insert(node(l,r,v));
    }
}

inline set<node>::iterator split(int pos)
{
    set<node>::iterator it=s.lower_bound(node(pos));
    if(it!=s.end()&&it->l==pos) return it;
    --it;
    int L=it->l,R=it->r,V=it->v;
    s.erase(it);
    s.insert(node(L,pos-1,V));
    return s.insert(node(pos,R,V)).first;
}

inline void assignval(int l,int r,int v)
{
    set<node>::iterator itr=split(r+1),itl=split(l);
    s.erase(itl,itr);
    s.insert(node(l,r,v));
}

inline void query()
{
    set<node>::iterator it=s.begin();
    while(it!=s.end())
    {
        for(;it!=s.end();++it)
        {
            if(it->v!=0)
                break;
        }
        if(it==s.end())
            break;
        ans.push_back(make_pair((it->l)/2,0));
        ans.push_back(make_pair((it->l)/2,it->v));
        for(;it!=s.end();++it)
        {
            if(it->v==0)
                break;
            int ccv1=it->v,ccpos1=it->r;
            ++it;
            int ccv2=it->v,ccpos2=it->l;
            --it;
            if(ccv2==ccv1)continue;
            else if(ccv2>ccv1)
            {
                ans.push_back(make_pair(ccpos2/2,ccv1));
                ans.push_back(make_pair(ccpos2/2,ccv2));
            }
            else
            {
                ans.push_back(make_pair(ccpos1/2,ccv1));
                ans.push_back(make_pair(ccpos1/2,ccv2));
            }
        }
    }
}

int main()
{
    read(n);
    s.insert(node(-2e9-10,2e9+10));
    for(register int i=1;i<=n;++i)
    {
        read(a[i].h),read(a[i].l),read(a[i].r);
        a[i].l*=2;
        a[i].r*=2;
    }
    sort(a+1,a+n+1);
    for(register int i=1;i<=n;++i)
    {
        assignval(a[i].l,a[i].r,a[i].h);
        merge(a[i].l);
        merge(a[i].r);
    }
    query();
    int sz=ans.size();
    printf("%d\n",sz);
    for(register int i=0;i<sz;++i)
    {
        printf("%d %d\n",ans[i].first,ans[i].second);
    }
    return 0;
}
```


---

## 作者：渺小的Mastar (赞：1)

感觉dalao们的扫描线的姿势不太正确
[P1904天际线](https://www.luogu.org/problem/P1904)
[UVA105 The Skyline Problem](https://www.luogu.org/problem/UVA105)[P5490 【模板】扫描线](https://www.luogu.org/problem/P5490)[P1856 [USACO5.5]矩形周长Picture](https://www.luogu.org/problem/P1856)
这题类似于扫描线的模板题，同样是维护当前线段的长度就行啦（五倍经验つ﹏⊂逃     (lll￢ω￢)
```
#include <bits/stdc++.h>
using namespace std;
#define LOVE *
#define ll int
#define super inline
#define _tp template
#define _tpn typename
#define pigs register ll
#define loop(a, b, m) for (register ll a = b; a <= m; ++a)
#define anti_loop(a, b, m) for (register ll a = b; a >= m; --a)
super char kanna()
{
    static char buf[1 << 22], *p1 = buf, *p2 = buf;
    return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << !2, stdin), p1 == p2) ? EOF : *p1++;
}
super ll read()
{
    pigs CLPig = 0, XZT = 1;
    char qwq = kanna();
    while (!isdigit(qwq))
        XZT = qwq ^ 45 ? 1 : -1, qwq = kanna();
    while (isdigit(qwq))
        CLPig = CLPig * 10 + (qwq ^ 48), qwq = kanna();
    return CLPig LOVE XZT;
}
#define MAXN 200005
struct Sugment
{
    int x, h, k;
    Sugment() {}
    Sugment(int a, int b, int c) : x(a), h(b), k(c) {}
    bool operator<(const Sugment &a) const
    {
        return x < a.x;
    }
} line[MAXN];
int Y[MAXN];
struct node
{
    int len, cnt;
} st[MAXN << 2];
void pushup(int o, int l, int r)
{
    if (st[o].cnt)
        st[o].len = Y[r + 1] - Y[l];
    else
        st[o].len = l == r ? 0 : st[o << 1].len + st[o << 1 | 1].len;
}
void update(int o, int l, int r, int x, int y, int k)
{
    if (x <= l && r <= y)
    {
        st[o].cnt += k;
        pushup(o, l, r);
        return;
    }
    int mid = l + r >> 1;
    if (x <= mid)
        update(o << 1, l, mid, x, y, k);
    if (mid < y)
        update(o << 1 | 1, mid + 1, r, x, y, k);
    pushup(o, l, r);
}
struct ANS
{
    int a, b;
    ANS() {}
    ANS(int _a, int _b) : a(_a), b(_b) {}
} ans[MAXN];
int main()
{
    int tot = 1, pre = -2147483647, n = 0, x, y, z, gg = read(), top = 0;
    loop(i, 1, gg)
    {
        scanf("%d%d%d", &y, &x, &z);
        line[++n] = Sugment(x, y, 1);
        line[++n] = Sugment(z, y, -1);
        Y[++tot] = y;
    }
    sort(Y + 1, Y + tot + 1);
    sort(line + 1, line + n + 1);
    tot = unique(Y + 1, Y + 1 + tot) - Y - 1;
    loop(i, 1, n)
        line[i].h = lower_bound(Y + 1, Y + tot + 1, line[i].h) - Y;
    int kkk = 0;
    for (int i = 1; i <= n; i++)
    {
        while (line[i].x == line[i + 1].x && i < n)
            update(1, 1, tot, 1, line[i].h - 1, line[i].k), i++;
        update(1, 1, tot, 1, line[i].h - 1, line[i].k);
        if (st[1].len != pre)
        {
            ans[++kkk] = ANS(line[i].x, pre == -2147483647 ? 0 : pre);
            ans[++kkk] = ANS(line[i].x, st[1].len);
            pre = st[1].len;
        }
    }
    printf("%d\n", kkk);
    loop(i, 1, kkk)
    {
        printf("%d %d\n", ans[i].a, ans[i].b);
    }
    return 0;
}
```

---

## 作者：fysbb (赞：1)

这一题还没有pascal的题解，所以补一篇pascal的堆+扫描线题解。~~（因为我不会线段树）~~

```pas
var
   p,lr,h,a,b:array[0..200005]of longint;
   heap,will:array[0..400005]of longint;
   n,x,y,z,i,t,tot,totwill,height,ans:longint;
```

两个大根堆，heap储存当前楼房的高度，will储存将要删除的楼房的高度。push(q)表示将q加入heap，del表示删除heap堆顶。pushwill(q)表示将q加入will，delwill表示删除will堆顶。

p[i]表示第i条边的x坐标

lr[i]表示第i条边是楼房的左侧边还是右侧边，lr[i]=1左侧边,lr[i]=2右侧边。

h[i]表示第i条边的高度。

a[i]表示第i个节点的x坐标,b[i]表示第i个节点的y坐标。

#### 读入
对于每个楼房，要读入左侧边和右侧边。
```pas
  for i:=1 to n do begin
    readln(z,x,y);
    t:=2*i;
    p[t-1]:=x;
    h[t-1]:=z;
    lr[t-1]:=1;
    p[t]:=y;
    h[t]:=z;
    lr[t]:=2;
  end;
```

#### 预处理
将边按x坐标从小到大（x坐标相同时，先右侧边后左侧边）进行排序。
```pas
  procedure qsort(l,r:longint);
  var i,j,mid,t,cen:longint;
  begin
    i:=l;j:=r;
    mid:=p[(i+j) div 2];
    cen:=lr[(i+j) div 2];
    repeat
      while (p[i]<mid) or ((p[i]=mid) and (lr[i]>cen)) do  inc(i);
      while (p[j]>mid) or ((p[j]=mid) and (lr[j]<cen)) do dec(j);
      if i<=j then begin
        t:=p[i];
        p[i]:=p[j];
        p[j]:=t;
        t:=lr[i];
        lr[i]:=lr[j];
        lr[j]:=t;
        t:=h[i];
        h[i]:=h[j];
        h[j]:=t;
        inc(i);
        dec(j);
      end;
    until i>j;
    if l<j then qsort(l,j);
    if i<r then qsort(i,r);
  end;
```

#### 扫描处理

height记录处理前楼房的最高高度。

如果这条边是左侧边，则将其加入heap，如果是右侧边则加入will。

x坐标相同的所有边加入完成后，比较heap[1]和will[1],如果相同，同时删去两个堆顶，并继续判断，直到它们不相同，得到新的heap。

记录答案。
```pas
  while i<=t do begin
    case lr[i] of
    1:begin                                //该x坐标上只有左侧边
        height:=heap[1];                   //height记录处理前的最大楼高
        repeat
          push(h[i]);
          inc(i);
        until (p[i]<>p[i-1]) or (i>t);
        dec(i);
        if heap[1]>height then begin       //新的最大楼高比之前高时，轮廓线才会变化 
          inc(ans);
          a[ans]:=p[i];b[ans]:=height;
          inc(ans);
          a[ans]:=p[i];b[ans]:=heap[1];
        end;
      end;
    2:begin                                //该x坐标上既有左侧边，又有右侧边。
        height:=heap[1];
        repeat                             //将该x坐标所有右侧边加入will
          pushwill(h[i]);
          inc(i);
        until (p[i]<>p[i-1]) or (lr[i]=1) or (i>t);
        if p[i]=p[i-1] then begin
          repeat                           //将该x坐标所有左侧边加入heap
            push(h[i]);
            inc(i);
          until (p[i]<>p[i-1]) or (i>t);
        end;
        dec(i);
        while totwill<>0 do                //将楼房删除，更新heap 
          if will[1]=heap[1] then begin delwill;del; end
            else break;
        if heap[1]<>height then begin      //新的最大楼高和之前不同时，轮廓线才会变化
          inc(ans);
          a[ans]:=p[i];b[ans]:=height;
          inc(ans);
          a[ans]:=p[i];b[ans]:=heap[1];
        end;
      end;
    end;
    inc(i);
  end;
```

#### 输出
先输出节点个数ans，再输出节点坐标。
```pas
  writeln(ans);
  for i:=1 to ans do writeln(a[i],' ',b[i]);
```

#### 完整代码
本人蒟蒻，若代码有错误，请大佬指出。
```pas
program project1;
var
   p,lr,h,heap,will,a,b:array[0..400005]of longint;
   n,x,y,z,i,t,tot,totwill,height,ans:longint;
procedure qsort(l,r:longint);
var i,j,mid,t,cen:longint;
begin
  i:=l;j:=r;
  mid:=p[(i+j) div 2];
  cen:=lr[(i+j) div 2];
  repeat
    while (p[i]<mid) or ((p[i]=mid) and (lr[i]>cen)) do inc(i);
    while (p[j]>mid) or ((p[j]=mid) and (lr[j]<cen)) do dec(j);
    if i<=j then begin
      t:=p[i];
      p[i]:=p[j];
      p[j]:=t;
      t:=lr[i];
      lr[i]:=lr[j];
      lr[j]:=t;
      t:=h[i];
      h[i]:=h[j];
      h[j]:=t;
      inc(i);
      dec(j);
    end;
  until i>j;
  if l<j then qsort(l,j);
  if i<r then qsort(i,r);
end;

procedure push(q:longint);
var i,j,t:longint;
begin
  inc(tot);
  heap[tot]:=q;
  i:=tot;
  while (i shr 1)<>0 do begin
    j:=i shr 1;
    if heap[j]<heap[i] then begin
      t:=heap[i];
      heap[i]:=heap[j];
      heap[j]:=t;
    end else break;
    i:=j;
  end;
end;

procedure del;
var i,j,t:longint;
begin
  heap[1]:=heap[tot];
  heap[tot]:=0;
  dec(tot);
  i:=1;
  while (i shl 1)<=tot do begin
    j:=i shl 1;
    if (j+1<=tot) and (heap[j]<heap[j+1]) then inc(j);
    if heap[i]<heap[j] then begin
      t:=heap[i];
      heap[i]:=heap[j];
      heap[j]:=t;
    end else break;
    i:=j;
  end;
end;

procedure pushwill(q:longint);
var i,j,t:longint;
begin
  inc(totwill);
  will[totwill]:=q;
  i:=totwill;
  while (i shr 1)<>0 do begin
    j:=i shr 1;
    if will[j]<will[i] then begin
      t:=will[i];
      will[i]:=will[j];
      will[j]:=t;
    end else break;
    i:=j;
  end;
end;

procedure delwill;
var i,j,t:longint;
begin
  will[1]:=will[totwill];
  will[totwill]:=0;
  dec(totwill);
  i:=1;
  while (i shl 1)<=totwill do begin
    j:=i shl 1;
    if (j+1<=totwill) and (will[j]<will[j+1]) then inc(j);
    if will[i]<will[j] then begin
      t:=will[i];
      will[i]:=will[j];
      will[j]:=t;
    end else break;
    i:=j;
  end;
end;

begin
  readln(n);
  tot:=0;
  totwill:=0;
  ans:=0;
  fillchar(p,sizeof(p),0);
  fillchar(lr,sizeof(lr),0);
  fillchar(h,sizeof(h),0);
  fillchar(heap,sizeof(heap),0);
  fillchar(will,sizeof(will),0);
  for i:=1 to n do begin
    readln(z,x,y);
    t:=2*i;
    p[t-1]:=x;
    h[t-1]:=z;
    lr[t-1]:=1;
    p[t]:=y;
    h[t]:=z;
    lr[t]:=2;
  end;
  qsort(1,t);
  i:=1;
  while i<=t do begin
    case lr[i] of
    1:begin
        height:=heap[1];
        repeat
          push(h[i]);
          inc(i);
        until (p[i]<>p[i-1]) or (i>t);
        dec(i);
        if heap[1]>height then begin
          inc(ans);
          a[ans]:=p[i];b[ans]:=height;
          inc(ans);
          a[ans]:=p[i];b[ans]:=heap[1];
        end;
      end;
    2:begin
        height:=heap[1];
        repeat
          pushwill(h[i]);
          inc(i);
        until (p[i]<>p[i-1]) or (lr[i]=1) or (i>t);
        if p[i]=p[i-1] then begin
          repeat
            push(h[i]);
            inc(i);
          until (p[i]<>p[i-1]) or (lr[i]=2) or (i>t);
        end;
        dec(i);
        while totwill<>0 do
          if will[1]=heap[1] then begin delwill;del; end
            else break;
        if heap[1]<>height then begin
          inc(ans);
          a[ans]:=p[i];b[ans]:=height;
          inc(ans);
          a[ans]:=p[i];b[ans]:=heap[1];
        end;
      end;
    end;
    inc(i);
  end;
  writeln(ans);
  for i:=1 to ans do writeln(a[i],' ',b[i]);
end.

```

---

## 作者：OnlySky (赞：1)

思路：

离散化+线段树

有的神犇说扫描线+堆更快，但是我不会。。

写了一个晚上

难在离散化和把线段放置

线段放置要考虑蛮多的情况

比如
恰好公用一个端点，可是不重叠

完全重叠

等等等等

离散化，用map记录下来，然后用迭代器全部存起来（stl大法好）

然后，用离散化好的点的两点之间的间隙建立线段树

然后把线段排序，从小到大

然后愉快的裸flag线段树

然后，像建树一样，一次优化<nlogn的check

如果前面的间隙的dis不等于现在的间隙的dis就输出

轻松ac（不知道wa了多少次re多少次）






```cpp
#include <map>
#include <cstdio>
#include <iostream>
#include <algorithm>
using namespace std;
struct node {
    long long int l,r,dis;
};
struct node edge[100001];
inline void read_int(long long int &now_);
class T_tree {
```
public:
        
        
        












```cpp
        int l,r,mid;
        long long int dis,flag;
        void mid_()
        {
            mid=(l+r)>>1;
        }
        void flag_()
        {
            flag=0;
        }
        void dis_()
        {
            dis=0;
        }
};
class T_tree tree[100001*4*2];
long long int n,if_Z,num=0,before=0,before_=0;
long long int point[100001*2],ans=0,ans_now[100001*4],ans_dis[100001*4];
char Cget;
bool if_fi=true;
map<long long int,long long int>if_;
inline void read_int(long long int &now_)
{
    now_=0,if_Z=1,Cget=getchar();
    while(Cget<'0'||Cget>'9')
    {
        if(Cget=='-') if_Z=-1;
        Cget=getchar();
    }
    while(Cget<='9'&&Cget>='0')
    {
        now_=now_*10+Cget-'0';
        Cget=getchar();
    }
    now_*=if_Z;
}
inline bool cmp(struct node some1,struct node some2)
{
    return some1.dis<some2.dis;
}
void tree_build(int now,int l,int r)
{
    tree[now].l=l,tree[now].r=r;
    if(l==r)
    {
        tree[now].dis_();
        return ;
    }
    tree[now].mid_();
    tree_build(now<<1,l,tree[now].mid);
    tree_build(now<<1|1,tree[now].mid+1,r);
}
inline void tree_down(int now)
{
    if(tree[now].l==tree[now].r) return ;
    tree[now<<1].dis=tree[now].flag;
    tree[now<<1].flag=tree[now].flag;
    tree[now<<1|1].dis=tree[now].flag;
    tree[now<<1|1].flag=tree[now].flag;
    tree[now].flag_();
}
void tree_change(int now,int l,int r,long long int dis)
{
    if(tree[now].l==l&&tree[now].r==r)
    {
        tree[now].dis=dis;
        tree[now].flag=dis;
        tree_down(now);
        return ;
    }
    if(tree[now].flag) tree_down(now);
    if(l>tree[now].mid) tree_change(now<<1|1,l,r,dis);
    else if(r<=tree[now].mid) tree_change(now<<1,l,r,dis);
    else
    {
        tree_change(now<<1,l,tree[now].mid,dis);
        tree_change(now<<1|1,tree[now].mid+1,r,dis);
    }
}
int times=0;
void tree_check(int now)
{
    if(tree[now].l==tree[now].r)
    {
        if(tree[now].dis!=before)
        {
            ans_now[++ans]=point[tree[now].l];
            ans_dis[ans]=before;
            ans_now[++ans]=point[tree[now].l];
            ans_dis[ans]=tree[now].dis;
            before=tree[now].dis;
        }
        return ;
    }
    if(tree[now].flag) tree_down(now);
    tree_check(now<<1),tree_check(now<<1|1);
}
int main()
{
    read_int(n);
    for(int i=1;i<=n;i++)
    {
        read_int(edge[i].dis),read_int(edge[i].l),read_int(edge[i].r);
        if_[edge[i].l]=edge[i].l,if_[edge[i].r]=edge[i].r;
    }
    for(map<long long int,long long int>::iterator it=if_.begin();it!=if_.end();it++)
    {
        point[++num]=it->first;
        it->second=num;
    }
    tree_build(1,1,num+1);
    sort(edge+1,edge+n+1,cmp);
    for(int i=1;i<=n;i++)
    {
        tree_change(1,if_[edge[i].l],if_[edge[i].r]-1,edge[i].dis);
    }
    tree_check(1);
    printf("%lld\n",ans);
    for(int i=1;i<=ans;i++) printf("%lld %lld\n",ans_now[i],ans_dis[i]);
    return 0;
}
```

---

## 作者：GoldenFlash (赞：0)

我们考虑每个横坐标x到x+1这一段区间，若此区间的最大高度不等于前一个区间的最大高度，则有轮廓线的两个顶点的横坐标为x，纵坐标分别为两个区间的高度。

用线段树维护最大值即可。注意需要离散化，而由于最后高度为0的地方在输入中没有体现，可以将每个矩形的最后一段区间的后面一段区间也一同维护。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 2e5 + 5;
struct Jv
{
    int h, l, r;
}jv[MAXN];
int a[MAXN<<2], b[MAXN<<2];
struct SegmentTree
{
    int l, r, maxx, lazy;
    #define l(x) tree[x].l
    #define r(x) tree[x].r
    #define maxx(x) tree[x].maxx
    #define lazy(x) tree[x].lazy
}tree[MAXN<<3];

void spread(int p)
{
    if(lazy(p))
    {
        maxx(p<<1) = max(maxx(p<<1), lazy(p));
        maxx(p<<1|1) = max(maxx(p<<1|1), lazy(p));
        lazy(p<<1) = max(lazy(p<<1), lazy(p));
        lazy(p<<1|1) = max(lazy(p<<1|1), lazy(p));
        lazy(p) = 0;
    }
}

void buildTree(int p, int l, int r)
{
    l(p) = l, r(p) = r, maxx(p) = 0, lazy(p) = 0;
    if(l == r)
        return;
    int mid = l(p) + r(p) >> 1;
    buildTree(p<<1, l, mid);
    buildTree(p<<1|1, mid+1, r);
}

void change(int p, int l, int r, int k)
{
    if(l <= l(p) && r(p) <= r)
    {
        maxx(p) = max(maxx(p), k);
        lazy(p) = max(lazy(p), k);
        return;
    }
    spread(p);
    int mid = l(p) + r(p) >> 1;
    if(l <= mid)
        change(p<<1, l, r, k);
    if(r > mid)
        change(p<<1|1, l, r, k);
    maxx(p) = max(maxx(p<<1), maxx(p<<1|1));
}

int ask(int p, int l, int r)
{
    if(l <= l(p) && r(p) <= r)
    {
        return maxx(p);
    }
    spread(p);
    int res = 0;
    int mid = l(p) + r(p) >> 1;
    if(l <= mid)
        res = ask(p<<1, l, r);
    if(r > mid)
        res = max(res, ask(p<<1|1, l, r));
    return res;
}

struct Out
{
    int x, y;
}out[MAXN<<1];
int main()
{
    int n;
    scanf("%d", &n);
    int u = 0, p = 0;
    for(int i = 1; i <= n; ++i)
    {
        scanf("%d%d%d", &jv[i].h, &jv[i].l, &jv[i].r);
        jv[i].r--;
        b[p++] = jv[i].l, b[p++] = jv[i].r, b[p++] = jv[i].r+1;
    }
    sort(b, b + p);
    a[u++] = b[0];
    for(int i = 1; i < p; ++i)
        if(b[i] != b[i-1])
            a[u++] = b[i];
    a[u] = a[u-1]+1;
    u++;
    buildTree(1, 0, u);
    for(int i = 1; i <= n; ++i)
    {
        int lx = lower_bound(a, a + u, jv[i].l)-a;
        int rx = lower_bound(a, a + u, jv[i].r)-a;
        change(1, lx, rx, jv[i].h);
    }
    int pre = 0, now, uu = 0;
    for(int i = 0; i <= u; ++i)
    {
        now = ask(1, i, i);
        if(now == pre)
            continue;
        out[uu].x = a[i], out[uu++].y = pre;
        out[uu].x = a[i], out[uu++].y = now;
        pre = now;
    }
    printf("%d\n", uu);
    for(int i = 0; i < uu; ++i)
        printf("%d %d\n", out[i].x, out[i].y);
    return 0;
}

```


---


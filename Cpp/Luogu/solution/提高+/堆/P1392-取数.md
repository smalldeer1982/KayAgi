# 取数

## 题目描述

在一个 $n$ 行 $m$ 列的数阵中，你须在每一行取一个数（共 $n$ 个数），并将它们相加得到一个和。对于给定的数阵，请你输出和前 $k$ 小的取数方法。


## 说明/提示

对于 $20\%$ 的数据，$1\le n\le 8$。

对于 $100\%$ 的数据，$1\le n\le 800$，$1\le k\le m\le 800$。


## 样例 #1

### 输入

```
3 3 2
1 2 3
6 3 5
4 1 2
```

### 输出

```
5 6```

# 题解

## 作者：wjy666 (赞：25)

我们考虑前面x-1行的前k小,升序放在b数组里

第x行共m个数,升序放在a数组里

然后只需要用大根堆维护,依次比较a[i]+b[j]的大小

在堆里已经有k个值的情况下,如果他比顶小就弹掉顶,把它丢进去

否则break掉,因为b数组单调不降,后面不可能有贡献

于是就做完了

但是真的做完了吗？这$^{tm}$不是3方1个log吗？？不会T的吗？？？

很多人想到这里就把这个做法ban了

然而再仔细想想:

考虑a[i]+b[j],由于a,b数组单调不降,必定有**至少**$ij-1$个元素小于等于他

所以当$ k<ij $ 时循环**一定**会break掉

所以做一遍的循环次数**不是**看起来的平方

**而是** $ \sum^{k}_{i=1} \frac{k}{i} $

由调和级数~~或者写个代码算一遍~~可知其大概是$k log_2 k$

所以真实复杂度上限是2方2个log,而且根本跑不满

辅以fread在luogu拿下了暂时的rk1

```cpp
#include<bits/stdc++.h>
#define For(i,j,k) for(int i=j;i<=k;++i)
using namespace std;
namespace IO{//这份代码拿来学fread也是很不错的
	const int Buffsize=1<<23;
	char c[Buffsize],*ch=c;
	void INIT(){fread(c,1,Buffsize,stdin);}
	int x,l;
	int read(){
		x=0,l=1;
		while(!isdigit(*ch)) {if ((*ch)=='-') l=-1; ch++;}
		while(isdigit(*ch)) x=x*10+(*ch^48),ch++;
		return x*l;
	}
}
using namespace IO;
priority_queue<int> q;
int a[805],b[805];
int main(){
	INIT(); int n=read(),m=read(),k=read(),o,oo;
	q.push(0); int op=800,ans=0;
	while(n--){
		For(j,1,m) a[j]=read(); sort(a+1,a+1+m);
		o=oo=0; while(!q.empty()) b[++o]=q.top(),q.pop();
		For(i,1,m)
			for(int j=o;j>=1;--j){//在这里b数组单调不升,所以倒着来
				if (oo<k) q.push(a[i]+b[j]),++oo;
				else if (q.top()<=a[i]+b[j]) break; //关键优化
				else q.pop(),q.push(a[i]+b[j]);
			}
	}
	o=0;
	while(!q.empty()) b[++o]=q.top(),q.pop();
	for(int i=o;i>=1;--i) printf("%d ",b[i]);
	return 0;
}
```

---

## 作者：ChenHacker (赞：9)

### 看着楼下的题解，竟然没有用STL的？（听说是数据太强卡STL的优先队列，~~可是本蒟蒻不会手写堆而且我可不这么认为~~）我来一个STL版本。
## sort+STL+DFS=Accpted
思路楼下的楼下讲得很好，如果还是有一点蒙请移步[P1631 序列合并](https://www.luogu.org/problemnew/show/P1631)
```cpp
#include<bits/stdc++.h>
using namespace std;
priority_queue<int>w;
int m,n,k,a[805][805],gt[805],c[805],top;//gt数组计录每一行最小值的前缀和;
int get(int i)//第i行以下最小值的和
{
	return gt[n]-gt[i];
}
void search(int t,int s)//DFS
{
	for(int i=1;i<=m;i++)
	{
		s+=a[t][i];
		if(s+get(t)>w.top()) return;//如果选择此数并且加上可能取得的最小值还是不够小，直接return;
		if(t==n) if(s<w.top()) w.pop(),w.push(s);else;
		else search(t+1,s);
		s-=a[t][i];//回溯;
	}
}
int main()
{
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
			cin>>a[i][j];
		sort(a[i]+1,a[i]+1+m);//排序
		gt[i]=gt[i-1]+a[i][1];//处理前缀和
	}
	for(int i=1;i<=k;i++)
		w.push(INT_MAX);//初始化
	search(1,0);//DFS
    /*因为是大根堆，所以反向输出*/
	while(w.size()) c[++top]=w.top(),w.pop();
	for(int i=k;i>=1;i--)
		cout<<c[i]<<' ';
	return true;
}

```
顺便附上一组很水的数据~~比样例好~~

	9 9 10
	1 2 3 4 5 6 7 8 9
	1 2 3 4 5 6 7 8 9
	1 2 3 4 5 6 7 8 9
	1 2 3 4 5 6 7 8 9
	1 2 3 4 5 6 7 8 9
	1 2 3 4 5 6 7 8 9
	1 2 3 4 5 6 7 8 9
	1 2 3 4 5 6 7 8 9
	1 2 3 4 5 6 7 8 9


---

## 作者：【天朝】MILK (赞：6)

**介绍**一道**基本版**题目[序列合并](https://www.luogu.org/problemnew/show/P1631)

仔细分析有何不同？

- 这里有**N个**数组，而上题只有**两个**

- 上题是求最小的**N个**，而这里是求其中的**K个**

#### 注意到K<=M

那么

我们可以用一个数组记录前i个数组的最优**K个值**

并不断地与**第i+1数组**进行比较从而**更新**这K个数

从而将问题转化为序列合并去完成

------------
那么 如何求取2个数组之间的**最优K项**呢？

- 对此两个数组**排序**

假设堆中元素不足K个，直接入**大根堆**。

假设堆中元素已有K个

- A[i]+B[j]<堆顶，堆顶出堆A[i]+B[j]入堆。

- A[i]+B[j]>=堆顶，我不仅不要此元素，由于B数组单调递增，我也不要B数组在A[i]情况下的任意解。（代码实现用**BREAK**）


------------
代码时间复杂度（最大**次数**）：**66334603**（这**不是**~~电话号码~~）

据说计算机一秒内最多可以计算**八千万**次。

------------
酱紫已有就可以以**较慢的速度AC**了（**4089ms**）

**安利**一下某**不知名**优化！

------------

```cpp
#pragma GCC optimize(5)
```
------------

结果：（**2546ms**）

------------
上代码
------------
**手写堆，勿嫌弃**

------------
```cpp
#pragma GCC optimize(5)
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const long long INF=1e17;
int Num2,m,n,k,Map[805][805],b[8000];
int Ans[805];
void AddHeap(int x)
{
    int Now=++Num2;b[Num2]=x;
    while(Now>1&&b[Now]>b[Now/2])
    {
        swap(b[Now],b[Now/2]);Now/=2;
    }
}
void Delete()
{
    int Now=1,k;b[1]=b[Num2];Num2--;
    while(Now*2<=Num2)
    {
        if(b[Now*2]>b[Now*2+1]||Num2==2*Now)k=Now*2;else k=Now*2+1;
        if(b[Now]<b[k]){swap(b[Now],b[k]);Now=k;}else break;
    }
}
void DFS(int D)
{
    if(D==n+1)return;
    for(int i=1;i<=k;i++)
     {
        for(int j=1;j<=k;j++)
        {
            int x=Map[1][i]+Map[D][j];
            if(Num2<k)AddHeap(x);
            else
            {
                if(b[1]>x){Delete();AddHeap(x);}
                else break;
            }
        }
    }
    for(int i=k;i>=1;i--)Map[1][i]=b[1],Delete();
    DFS(D+1);
}
int main()
{
    scanf("%d%d%d",&n,&m,&k);
    int A[805];
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)scanf("%d",&A[j]);sort(A+1,A+1+m);
        for(int j=1;j<=m;j++)Map[i][j]=A[j];
    }
    DFS(2);
    for(int i=1;i<=k;i++)printf("%d ",Map[1][i]);puts("");
    return 0;
}
```



---

## 作者：Starlight237 (赞：6)

思路依然是这样：如果$a[i]+a[j]$是第k小和，则$\min\{a[i+1]+b[j],a[i]+b[j+1]\}$是第k+1小和。用二叉堆维护即可。

然而，不会手写堆的同学们是否还在T飞的边缘徘徊呢？
## STL的希望来了！
普通STL如果不开O2，一定会TLE。

然而，除了STL以外，仍然有许多循环、排序等占用了大量时间。尤其是排序，达到$O(nm\log m)$的级别，忽略常数后甚至超过堆操作的$O(nk\log k)$。

那么我们首先优化排序。记得WC2017T2有个基数排序，优化后可以轻松踩爆sort。

于是我们的基数排序华丽登场：
```cpp
inline void basesort(int n,int *a,int *b){
    memset(b,0,sizeof(b));
    int r1[256],r2[256],r3[256],r4[256];
    #define Mem(K) memset(r##K,0,sizeof(r##K))
    Mem(1),Mem(2),Mem(3),Mem(4);
    ri *p,*E,tp=n>>3,tmp;
    for(p=a,E=a+n;p!=E;++p)
        ++r1[*p&255],++r2[*p>>8&255],++r3[*p>>16&255],++r4[*p>>24&255];
    for(ri i=1;i<256;++i)
        r1[i]+=r1[i-1],r2[i]+=r2[i-1],r3[i]+=r3[i-1],r4[i]+=r4[i-1];
    for(tmp=tp,p=a+n-1;tmp;--tmp)
        b[--r1[p[0]&255]]=p[0],b[--r1[p[-1]&255]]=p[-1],
        b[--r1[p[-2]&255]]=p[-2],b[--r1[p[-3]&255]]=p[-3],
        b[--r1[p[-4]&255]]=p[-4],b[--r1[p[-5]&255]]=p[-5],
        b[--r1[p[-6]&255]]=p[-6],b[--r1[p[-7]&255]]=p[-7],p-=8;
    switch(n&7){
        case 7:b[--r1[*p&255]]=*p,--p;case 6:b[--r1[*p&255]]=*p,--p;
        case 5:b[--r1[*p&255]]=*p,--p;case 4:b[--r1[*p&255]]=*p,--p;
        case 3:b[--r1[*p&255]]=*p,--p;case 2:b[--r1[*p&255]]=*p,--p;
        case 1:b[--r1[*p&255]]=*p,--p;
    }
    #define todo(A,B,k,P) for(tmp=tp,p=B+n-1;tmp;--tmp)\
        A[--r##k[p[0]>>P&255]]=p[0],A[--r##k[p[-1]>>P&255]]=p[-1],\
        A[--r##k[p[-2]>>P&255]]=p[-2],A[--r##k[p[-3]>>P&255]]=p[-3],\
        A[--r##k[p[-4]>>P&255]]=p[-4],A[--r##k[p[-5]>>P&255]]=p[-5],\
        A[--r##k[p[-6]>>P&255]]=p[-6],A[--r##k[p[-7]>>P&255]]=p[-7],\
        p-=8;\
    switch(n&7){\
        case 7:A[--r##k[*p>>P&255]]=*p,--p;case 6:A[--r##k[*p>>P&255]]=*p,--p;\
        case 5:A[--r##k[*p>>P&255]]=*p,--p;case 4:A[--r##k[*p>>P&255]]=*p,--p;\
        case 3:A[--r##k[*p>>P&255]]=*p,--p;case 2:A[--r##k[*p>>P&255]]=*p,--p;\
        case 1:A[--r##k[*p>>P&255]]=*p,--p;\
    }
    todo(a,b,2,8)
    todo(b,a,3,16)
    for(tmp=tp,p=b+n-1;tmp;--tmp)
        a[--r4[p[0]>>24]]=p[0],a[--r4[p[-1]>>24]]=p[-1],
        a[--r4[p[-2]>>24]]=p[-2],a[--r4[p[-3]>>24]]=p[-3],
        a[--r4[p[-4]>>24]]=p[-4],a[--r4[p[-5]>>24]]=p[-5],
        a[--r4[p[-6]>>24]]=p[-6],a[--r4[p[-7]>>24]]=p[-7],p-=8;
    switch(n&7){
        case 7:a[--r4[*p>>24]]=*p,--p;case 6:a[--r4[*p>>24]]=*p,--p;
        case 5:a[--r4[*p>>24]]=*p,--p;case 4:a[--r4[*p>>24]]=*p,--p;
        case 3:a[--r4[*p>>24]]=*p,--p;case 2:a[--r4[*p>>24]]=*p,--p;
        case 1:a[--r4[*p>>24]]=*p,--p;
    }
}
```
然后呢，发现许多顺序访问数组的循环，我们可以直接拿指针优化。

非常耗时的条件判断，我们可以用短路特性来完成：
```cpp
if(a)b换成a&&(b,0)
if(!a)b换成a||(b,0)
```

最后当然少不了freadfwrite啦！

最终我们得到下面的代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define reg register
#define ri register int
#define IOSIZE 10000000
static char in[IOSIZE],*p=in,out[IOSIZE],*q=out,ch[20],*t=ch;
inline int read(){
    reg int x=0;
    while(*p<48)++p;
    while(*p>47)x=(x<<1)+(x<<3)+(*p++^48);
    return x;
}
inline void write(int x){
    !x&&(*q++=48);
    while(x)*t++=x%10+48,x/=10;
    while(t!=ch)*q++=*--t;
}
static int n,m,K,a[1001],b[1001],c[1001],d[1001];
inline void basesort(int n,int *a,int *b){
    memset(b,0,sizeof(b));
    int r1[256],r2[256],r3[256],r4[256];
    #define Mem(K) memset(r##K,0,sizeof(r##K))
    Mem(1),Mem(2),Mem(3),Mem(4);
    ri *p,*E,tp=n>>3,tmp;
    for(p=a,E=a+n;p!=E;++p)
        ++r1[*p&255],++r2[*p>>8&255],++r3[*p>>16&255],++r4[*p>>24&255];
    for(ri i=1;i<256;++i)
        r1[i]+=r1[i-1],r2[i]+=r2[i-1],r3[i]+=r3[i-1],r4[i]+=r4[i-1];
    for(tmp=tp,p=a+n-1;tmp;--tmp)
        b[--r1[p[0]&255]]=p[0],b[--r1[p[-1]&255]]=p[-1],
        b[--r1[p[-2]&255]]=p[-2],b[--r1[p[-3]&255]]=p[-3],
        b[--r1[p[-4]&255]]=p[-4],b[--r1[p[-5]&255]]=p[-5],
        b[--r1[p[-6]&255]]=p[-6],b[--r1[p[-7]&255]]=p[-7],p-=8;
    switch(n&7){
        case 7:b[--r1[*p&255]]=*p,--p;case 6:b[--r1[*p&255]]=*p,--p;
        case 5:b[--r1[*p&255]]=*p,--p;case 4:b[--r1[*p&255]]=*p,--p;
        case 3:b[--r1[*p&255]]=*p,--p;case 2:b[--r1[*p&255]]=*p,--p;
        case 1:b[--r1[*p&255]]=*p,--p;
    }
    #define todo(A,B,k,P) for(tmp=tp,p=B+n-1;tmp;--tmp)\
        A[--r##k[p[0]>>P&255]]=p[0],A[--r##k[p[-1]>>P&255]]=p[-1],\
        A[--r##k[p[-2]>>P&255]]=p[-2],A[--r##k[p[-3]>>P&255]]=p[-3],\
        A[--r##k[p[-4]>>P&255]]=p[-4],A[--r##k[p[-5]>>P&255]]=p[-5],\
        A[--r##k[p[-6]>>P&255]]=p[-6],A[--r##k[p[-7]>>P&255]]=p[-7],\
        p-=8;\
    switch(n&7){\
        case 7:A[--r##k[*p>>P&255]]=*p,--p;case 6:A[--r##k[*p>>P&255]]=*p,--p;\
        case 5:A[--r##k[*p>>P&255]]=*p,--p;case 4:A[--r##k[*p>>P&255]]=*p,--p;\
        case 3:A[--r##k[*p>>P&255]]=*p,--p;case 2:A[--r##k[*p>>P&255]]=*p,--p;\
        case 1:A[--r##k[*p>>P&255]]=*p,--p;\
    }
    todo(a,b,2,8)
    todo(b,a,3,16)
    for(tmp=tp,p=b+n-1;tmp;--tmp)
        a[--r4[p[0]>>24]]=p[0],a[--r4[p[-1]>>24]]=p[-1],
        a[--r4[p[-2]>>24]]=p[-2],a[--r4[p[-3]>>24]]=p[-3],
        a[--r4[p[-4]>>24]]=p[-4],a[--r4[p[-5]>>24]]=p[-5],
        a[--r4[p[-6]>>24]]=p[-6],a[--r4[p[-7]>>24]]=p[-7],p-=8;
    switch(n&7){
        case 7:a[--r4[*p>>24]]=*p,--p;case 6:a[--r4[*p>>24]]=*p,--p;
        case 5:a[--r4[*p>>24]]=*p,--p;case 4:a[--r4[*p>>24]]=*p,--p;
        case 3:a[--r4[*p>>24]]=*p,--p;case 2:a[--r4[*p>>24]]=*p,--p;
        case 1:a[--r4[*p>>24]]=*p,--p;
    }
}
struct Node{
    int x,y,sum,pre;
};
struct cmp{
    inline bool operator()(Node a,Node b){return a.sum>b.sum;}
};
int main(){
    fread(in,1,IOSIZE,stdin);
    priority_queue<Node,vector<Node>,cmp>Q;
    n=read(),m=read(),K=read();
    for(reg int *i=c+1,*j=c+m+1;i!=j;++i)*i=read();
    basesort(m,c+1,d+1);
    for(reg int i=1;i<n;++i){
        for(reg int *j=a+1,*e=a+m+1,*k=b+1,*l=c+1;j!=e;++j,++k,++l)
            *j=*l,*k=read();
        basesort(m,b+1,d+1);
        while(!Q.empty())Q.pop();
        Q.push(Node{1,1,a[1]+b[1],0});
        for(reg int j=1;j<=K;++j){
            Node now=Q.top();Q.pop();
            int x=now.x,y=now.y,sum=now.sum,pre=now.pre;
            Q.push(Node{x,y+1,a[x]+b[y+1],1});
            pre||(Q.push(Node{x+1,y,a[x+1]+b[y],0}),0);
            c[j]=sum;
        }
    }
    for(reg int *i=c+1,*j=c+K+1;i!=j;++i)write(*i),*q++=' ';
    fwrite(out,1,q-out,stdout);
    return 0;
}
```
不开O2轻松卡过，最慢的一个点仅800ms。

开了O2后，是2019年的最优解rk1（吐槽：Luogu3的评测机怎么那么快，2018年rk1基本上是没有超越的可能了）。

还是嫌慢？

内存池优化STL啊。

有兴趣可以翻我博客里的内存优化，如果哪位dalao用内存池超越了2018rk1，麻烦私信告知我。

如果觉得不错请点赞！

---

## 作者：ysner (赞：5)

此题解题思想不难，是在i不断递增的前提下，算出1~i-1行的前k个和，与第i行前k个数依次相加，得出1~i行的前k个和，并用二叉堆维护前k个和。

但是这题数据很强,卡STL的优先队列，所以只能打手写二叉堆，只因STL常数太大了。。。。（大大加大了代码长度）

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<queue>
#include<cstdlib>
#define il inline
#define re register
using namespace std;
int h,m,n,x,y,c=0,z,e,ans,a[2][805]={},k,b[805]={},cc;//a开滚动数组节省空间 
struct node
{
    int x,y,z;
}xx,q[805];//q相当于一个手写堆，xx起中转站的作用 
il void up(int x)//用于在堆的底部加数后维护堆 
{
    while(x>1)
    {
        if(q[x].z<q[x/2].z)
        {
            swap(q[x],q[x/2]);
            x/=2;
        } else break;
    }
}
il void down(int x)//用于在堆顶部加数后维护堆
{
    x*=2;
    while(x<=h)
    {
        if(x<h&&q[x+1].z<q[x].z) x++;
        if(q[x].z<q[x/2].z)
        {
            swap(q[x/2],q[x]);
            x*=2; 
        } 
          else break;
    }
}
int main()
{
   scanf("%d%d%d",&n,&m,&k);
   for(re int i=1;i<=m;i++) 
     scanf("%d",&a[c][i]);//输入第一行 
   sort(a[c]+1,a[c]+1+m);//对第一行的数进行排序
   for(re int i=2;i<=n;i++)
   {
       cc=1-c;//滚动数组套路 
       h=0;
       for(re int j=1; j<=m; j++)
           scanf("%d",&b[j]);
       sort(b+1,b+m+1); //一一对2~n行的数进行排序 
       xx.x=1;
       for(re int j=1; j<=k; j++)//只加每行前k个数 
       {
           xx.y=j;//记录当前算出的和加的是这一行的哪个数 
           xx.z=a[c][1]+b[j];//把当前行前k个数与已得出的前几行的最小和相加
           q[++h]=xx;//在堆尾加数  
           up(h);
       }
       for(re int j=1;j<=k;j++)
       {
           xx=q[1];
           q[1]=q[h];//在堆的顶部加数（重新维护堆） 
           h--; 
           down(1);
           a[cc][j]=xx.z;//前几行数得出的最小和有序放入a[cc] 
           xx.x++;
           xx.z=a[c][xx.x]+b[xx.y];//试着把前几行次小和加上当前行的数排进去 
           q[++h]=xx;//在堆尾加数 
           up(h);
       }
       c=1-c;//滚动数组套路 
   }
   for(re int i=1;i<=k;i++) 
     cout<<a[c][i]<<" ";
   return 0;
}
```

---

## 作者：Da_Capo_ (赞：2)

```cpp
#include<bits/stdc++.h>
using namespace std;
long long dui[90009],len=0,n,m,k,ans[90009];
long long b[90009],a[90009];
void down(int x){		//向下维护大根堆；
	int l=x*2;				//找儿子；
	while(l<=len){			//要是儿子没有出界；
		if(l<len&&dui[l]<dui[l+1])l++;			//如果右儿子没出界且还比左儿子大，l就到右儿子的位置上；
		if(dui[l]>dui[x]){				//如果儿子比爸爸大，换；
		swap(dui[l],dui[x]);
		x=l;
		l=x*2;
		}
		else
		break;
	}	
}
void up(int x){			//向上维护大根堆；
	while(x>1){			//没出界；
		if(dui[x]>dui[x/2]){			//而且儿子比父亲大，换；
			swap(dui[x],dui[x/2]);
			x/=2;
		}
		else break;
	}
}
void gettop(int val){			//堆顶换值函数；
	dui[1]=val;
	down(1);				//向下维护大根堆；
}
void add(int val){				//添加函数，过程讲解略，因为懒~；
	dui[++len]=val;				
	up(len); 
}
int main(){
	scanf("%lld %lld %lld",&n,&m,&k);
	for(int i=1;i<=m;i++)			//先输入第一行的数；
		scanf("%d",&b[i]);
	sort(b+1,b+1+m);			//整理一下，为了后面找小值做铺垫；
	for(int i=2;i<=n;i++){			//从第二层开始循环；
		for(int j=1;j<=m;j++)		//这层的输入；
			scanf("%d",&a[j]);
		sort(a+1,a+1+m);		//整理一下，为了后面找小值做铺垫；
		memset(dui,0,sizeof(dui));		//因为后面把值赋给b了，方便求和；
		len=0;			//堆的长度也要归零；
		for(int j=1;j<=k;j++)		//因为b【1】是b中最小的，所以b【1】加任何值都是b中其他数不可媲美的；
			add(b[1]+a[j]);			//加入堆；
		for(int j=2;j<=k;j++){				//b中其他第k小的数；
			if(b[j]+a[1]>=dui[1])break;		//如果这个数比堆顶都大，就不要考虑了；
			else
			for(int l=1;l<=k;l++){			
				if(b[j]+a[l]<dui[1])gettop(b[j]+a[l]);		//再去讨论a中第k小的数；
				else break;			//如果这个数比堆顶都大，就不要考虑了；
			}
		}
		sort(dui+1,dui+1+len);		//整理成从小到大的堆；
		for(int j=1;j<=len;j++){		//len的长度等于k；详细见入堆；
			b[j]=dui[j];			//赋值，方便求值；
		}
	}
	for(int i=1;i<=len;i++)			//因为每次都把和赋给了b，所以直接输出b即可；
	printf("%d ",b[i]);
	return 0;
} 
 
```

---

## 作者：Strelitzia (赞：0)

#### [题目传送门](https://www.luogu.com.cn/problem/P1392)

-----------------

$\ \ \ \ \ $首先放上一道相似的题[序列合并](https://www.luogu.com.cn/problem/P1631)

$\ \ \ \ \ $这道题是本题的简易版。

$\ \ \ \ \ $就是$n=2$的情况。

$\ \ \ \ \ $如果$n=2$，最小的结果就是排序后，两个数组的第一个相加,$a_1+b_1$。

$\ \ \ \ \ $第二小的呢，显而易见是$\min{(a_1+b_2,a_2+b_1)}$，假设就是$a_1 + b_2$，第二小。

$\ \ \ \ \ $以此类推，我们可以知晓第三小，第四小的。

$\ \ \ \ \ $所以我们可以用一个大根堆维护当前的前$\texttt{k}$小的数，与当前$a_i+b_j$比较，如果根大

$\ \ \ \ \ $于当前的数，弹出，加入$a_i+b_j$，但这样会不优化会超时，只有三十分。

$\ \ \ \ \ $枚举代码如下：

```cpp
for (int i = 2 ; i <= k ; ++ i) {
			for (int j = 1 ; j <= k ; ++ j) {
				if (q.Size() < k) {
					q.push(a[i] + b[j]);
				} else {
					q.pop();
					q.push(a[i] + b[j]);
				}
			}
		
```

$\ \ \ \ \ $因为我们已经排序，所以如果$a_i+b_j$已经大于根，所以$a_{i+1}+b_j$或者是$a_i+b_{j+1}$绝对大于根了，再遍历就没有意义了，直接break。

$\ \ \ \ \ $更改后:

```cpp
for (int i = 2 ; i <= k ; ++ i) {
			for (int j = 1 ; j <= k ; ++ j) {
				if (q.Size() < k) {
					q.push(a[i] + b[j]);
				} else if (q.top() <= a[i] + b[j]) {
					break;
				} else {
					q.pop();
					q.push(a[i] + b[j]);
				}
			}
		}
```

$\ \ \ \ \ $这短短的两行，意味T或A。

$\ \ \ \ \ $此处还有一个坑点，如果用STl的优先队列，会T。

$\ \ \ \ \ $我在这卡了1个小时，自闭了。

$\ \ \ \ \ $代码如下：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define maxn 100005
using namespace std;

template<typename T>void read(T &x) {
	x = 0;T f = 1;char s = getchar();
	while(s < '0' || s > '9') {if(s == '-')f = -1;s = getchar();}
	while(s >= '0' && s <= '9') {x = x * 10 + s - 48;s = getchar();}
	x *= f;
}

template<typename T>void print(T x) {
	if(x < 0)putchar('-'),x = -x;
	if(x > 9)print(x / 10);
	putchar(x % 10 + '0');
}

int k,n,m;
int a[805],b[805];
struct Heap {
	int size,queue[maxn];
	Heap() {
		size = 0;
		for(int i = 0;  i < maxn ; ++ i)
			queue[i] = 0;
	}
	void shift_up(int i) {
		while(i > 1) {
			if(queue[i] > queue[i >> 1]) {
				int temp = queue[i];
				queue[i] = queue[i >> 1];
				queue[i >> 1] = temp;
			}
			i >>= 1;
		}
	}
	void shift_down(int i) {
		while((i << 1) <= size) {
			int nxt = i << 1;
			if(nxt < size && queue[nxt + 1] > queue[nxt])
				nxt ++;
			if(queue[i] < queue[nxt]) {
				int temp = queue[i];
				queue[i] = queue[nxt];
				queue[nxt] = temp;
				i = nxt;
			}
			else return ;
		}
	}
	int Size() {
		return size;
	}
	void push(int x) {
		queue[++ size] = x;
		shift_up(size);
	}
	void pop() {
		int temp = queue[1];
		queue[1] = queue[size];
		queue[size] = temp;
		size --;
		shift_down(1);
	}
	int top() {
		return queue[1];
	}
	bool empty() {
		return size;
	}
}q;

int main() {
	read(n);
	read(m);
	read(k);
	for (int i = 1 ; i <= m ; ++ i) {
		read(a[i]);
	}
	sort(a + 1,a + 1 + m);
	while (-- n) {
		for (int i = 1 ; i <= m ; ++ i) {
			read(b[i]);
		}
		sort(b + 1,b + 1 + m);
		for (int i = 1 ; i <= k ; ++ i) q.push(a[1] + b[i]);
		for (int i = 2 ; i <= k ; ++ i) {
			for (int j = 1 ; j <= k ; ++ j) {
				if (q.Size() < k) {
					q.push(a[i] + b[j]);
				} else if (q.top() <= a[i] + b[j]) {
					break;
				} else {
					q.pop();
					q.push(a[i] + b[j]);
				}
			}
		}
		while (q.size > k) q.pop();
		for (int i = 1 ; i <= k ; ++ i) {
			a[k - i + 1] = q.top();
			q.pop();
		}
	}
	for (int i = 1 ; i <= k ; ++ i) {
		print(a[i]),putchar(' ');
	}
	return 0;
}
```

$\ \ \ \ \ $谢谢大家♪(･ω･)ﾉ

---


# 小Z的AK计划

## 题目描述

在小 Z 的家乡，有机房一条街，街上有很多机房。每个机房里都有一万个人在切题。小 Z 刚刷完 CodeChef，准备出来逛逛。

机房一条街有 $n$ 个机房，第 $i$ 个机房的坐标为 $x_i$ ，小 Z 的家坐标为 $0$。小 Z 在街上移动的速度为 $1$，即从 $x_1$ 到 $x_2$ 所耗费的时间为 $|x_1 - x_2|$。

每个机房的学生数量不同，ACM 题目水平也良莠不齐。小 Z 到达第 $i$ 个机房后，可以花 $t_i$ 的时间想题，然后瞬间 AK；当然，也可以过机房而不入。

小 Z 现在只有 $m$ 个单位时间，之后他就该赶着去打 Codeforces 了。现在他想知道自己最多能在多少个机房 AK，希望你帮帮他。


## 说明/提示

对于 $30%$ 的数据，$n \leq 20$。

对于 $60\%$ 的数据，$n \leq 1000$。

对于 $100\%$ 的数据，$1 \leq n \leq 10^5$，$0 \leq m,x_i \leq 10^{18}$，$0 \leq t_i \leq 10^9$。

## 样例 #1

### 输入

```
2 10
1 100
5 5```

### 输出

```
1```

# 题解

## 作者：PPL_ (赞：47)

这题就一**贪心**

假设你有一种**到了机房就必须AK**的欲望

而且有超能力可以**让自己AK的机房变得WA、TLE、MLE......，然后返还你的时间**

假设你走到了一个机房，AK了之前的所有机房，但是时间超过了m，你是选择用时最少的机房WA掉，还是最多的呢(相当于路过)

答案肯定是不在用时最多的机房AK

于是按机房到家的距离从近到远排序

一个一个机房的去AK ~~dreaming~~

当你当了i机房后，于是判断m时间是否用完，如果超了，那就反复使之前用最多时间AK的机房变得WA，并返还时间，直到用的时间少于m，那么继续往前走

在路上取max就好了

还没懂就看看代码实现

```cpp
//12252024832524
#include <queue>
#include <cstdio>
#include <algorithm>
#define Max(x,y) (x>y?x:y)
using namespace std;

typedef long long LL;
const LL MAXN = 100005;
LL n,m;
struct node
{
	LL x,t;
	bool operator < (const node &px)const
	{
		return x < px.x;
	}
}cr[MAXN];//computer room 机房
priority_queue<LL> q;

LL Read()
{
	LL x = 0,f = 1;char c = getchar();
	while(c > '9' || c < '0'){if(c == '-')f = -1;c = getchar();}
	while(c >= '0' && c <= '9'){x = (x*10) + (c^48);c = getchar();}
	return x * f;
}

int main()
{
	n = Read();
	m = Read();
	for(int i = 1;i <= n;++ i)
	{
		cr[i].x = Read();
		cr[i].t = Read();
	}
	sort(cr+1,cr+n+1);//按距离排序 
	LL tim = 0,ans = 0,AK = 0;
	for(int i = 1;i <= n;++ i)
	{
		tim += cr[i].x - cr[i-1].x;//走到i机房所用时间 
		q.push(cr[i].t);//AK的欲望 
		AK++;
		tim += cr[i].t;
		while(!q.empty() && tim > m)//如果用的时间多于m，发动超能力 
		{
			AK --;
			tim -= q.top();
			q.pop();
		}
		if(tim > m)//返还所有时间，但是仍然超过了m 
			break;//别走了，再走也没时间AK了
		ans = Max(ans,AK);//取max 
	}
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：Calc_ (赞：16)

~~不会堆的蒟蒻打排序后惊奇的发现跑得比堆快
（朋友写堆用了260ms，而我只用了210ms）~~

思路；

1.把每一家机房的路程和AK时间记下来，再用另外一个数组汇总
（不边读边汇总的原因在下面）

2.用这个汇总的数据排序；

**3.重点：从 x1 到 x2 所耗费的时间为 |x1 − x2|。**

也就是说，刷完一家机房，到另一家机房所用的时间应为

 |这家机房的位置-下一家机房的位置|
 
（在这里可以简化为“下一家的位置-这家的位置”，因为机房在街上的位置一定是正的）

**所以走路时间是必须要分离出来的。**我设了一个变量"last"，来记住这家的位置，并在到达另一家机房时更新

好了上代码：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
struct AK     //定义了一个叫“AK”的结构体，防止等一下排完序数据对不上号
{
    long long int road;  //记录每一家机房的位置
    long long int time;  //记录每一家机房的AK时间
    long long int fnl;  //把上面的数据汇总
};
AK a[200000]; //定义数组
int	cmp(AK aa,AK b) //比较函数（在结构体内，所有运算都需要重新定义）
{
    return aa.fnl<b.fnl;
    }
long long int ans;//可以刷的机房数量
long long int last;//上一家机房的位置，初始为0即自己家
long long int used_time;//已使用的单位时间
int main()
{
    long long int n,m;//机房数与可用时间
    scanf("%lld%lld",&n,&m);
    for(int i = 1;i <= n;i++)
    {
    scanf("%lld%lld",&a[i].road,&a[i].time);//读入机房位置与AK时间
    a[i].fnl = a[i].road + a[i].time;//汇总
}
    sort(a+1,a+n+1,cmp);//用比较函数排序（需时少的机房肯定在前）
    for(int h = 1;;h++)
    {
        if(used_time + a[h].fnl-last > m）{printf("%lld",ans);break;}
        //判断：时间超了就终止循环并输出可刷的机房数
        else used_time += a[h].fnl-last;
        //否则就把时间加上去
        last = a[h].road;
        //**更新这家机房的位置
        ans+=1；
        //又AK了一家机房     | |
                           _____
    }
    return 0;
}
```

~~小Z怕是lmh扮的~~

---

## 作者：ahawzlc (赞：9)

思路：用 **排序 + 堆** 来实现**贪心**

不得不说这位小Z比我强太多了QAQ。

----

正片开始：

首先读入数据，处理一下从上一个机房走到本地点的路程（等会要用），然后按照当前地点到家的距离排序。

接下来就是求解部分：

首先，建立一个大根堆。然后遍历排好序的数据，要是这个房间能 AK ，那就 AK 了再走呗。要是这个机房时间不够了，就从原来那里找一个时间最大的，运用~~奥义·返还时间~~，把时间拿回来给这个机房AK。在这个过程中，要不断取$\max$。

在决策过程中，要是出现就算怎么反还时间也不够的话，说明后面的你压根就 AK 不了，所以明智的结束~~装B~~循环。

代码见下（图省事用了 pair ，因为可以不用重载运算符）。

``` cpp
#include<bits/stdc++.h>
#define int long long
#define pi pair<int,int>
#define F first
#define S second
#define mp make_pair
using namespace std;
pi a[100005];
priority_queue<pi> q;
int now,pro,sum;//now是当前时间，pro是当前题目，sum是最终答案
signed main() {
	int n,m;
	cin>>n>>m;
	for(int i=1; i<=n; i++) {
		int x,y;
		cin>>x>>y;
		a[i]=mp(x,y);
	}
	sort(a+1,a+n+1);
	for(int i=1; i<=n; i++) {
		now+=a[i].F-a[i-1].F;//加上走路的时间
		q.push(mp(a[i].S,a[i].F));
		++pro;
		now+=a[i].S;
		if(now>m) {
			while(now>m&&q.size()) {//返还时间
				pro--;
				now-=q.top().F;
				q.pop();
			}
		}
		if(now>m) {//上文所述明智选择
			break;
		}
		sum=max(sum,pro);
	}
	cout<<sum;
	return 0;
}
```

---

## 作者：Mark_ZZY (赞：7)

/\*
贪心裸题:

1.易知到了某一个点都不能可能再往回走(一定不是最优解,否则在原来就已经进去AK了);

2.因此我们想到了先对坐标排序,如果当前这个点离起点的距离已经大于了规定的疲劳值,就break(不可能走到这个点);

3.我们用一个大根堆来维护从起点走到当前这个点的已走进的机房所消耗的疲劳值(注意不包括路程的疲劳值)

如果所有的疲劳值(路程的疲劳值+机房所消耗的疲劳值)已大于规定的疲劳值,分析可知路程的疲劳值不可避免,

不可能改变,所以只能少走进一些机房,因为每一个机房都AK一次,所即将疲劳值最大的机房踢掉即可(注意,这是一个while循环的过程)

\*/
```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
#define LL long long
using namespace std;
priority_queue<LL> p;
	LL n,m,t=0,ans=0,sum=0;
	struct node{LL x,y;} a[100001];
bool cmp(node x,node y)
{
	return x.x<y.x;
}
int main()
{
	LL x,y;
	scanf("%lld %lld",&n,&m);
	for(int i=1;i<=n;i++)
	{
		scanf("%lld %lld",&x,&y);
		if(x<=m&&y<=m) a[++t].x=x,a[t].y=y;
	}
	n=t;
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++)
	{
		bool bz=false;
		p.push(a[i].y);
		sum+=a[i].y+a[i].x-a[i-1].x;
		if(sum<=m)
		{
			bz=true;
			ans++;
		}
		while(sum>m)
		{
			bz=false;
			if(bz) ans--;
			sum-=p.top();
			p.pop();
		}
	}
	printf("%lld",ans);
}
```

  
2018.6.4有更改，需要注意，被邱城锐大神Hack了。
```cpp
8 23827
6882 30879
16861 1781
15525 5729
15288 2878
6265 3603
25429 22415
7249 12656
12499 31642
```
正确结果为
```cpp
2
```

---

## 作者：夏色祭 (赞：6)

**没人发题解**

###通过率真的是低的可以（主要是样例过水导致的）

一开始看到题目没有一点头绪。。。

想了一会，然后就用时间复杂度n^3的dp乱搞，60分（喜滋滋）。

简要讲下：

f[i,j]表示去了i个机房,最后一个为j

**转移方程：f[i,j]:=x[j]+t[j]+min{f[i-1,k]}**

接下来就去看通过的dalao的代码，居然有Splay（蒟蒻的我一脸懵逼），不过最终还是找到了一个我看得懂的：堆。

思路是这样的：

先对坐标进行排序，然后去枚举1到n个机房。

如果当前机房的坐标（注意是坐标）大于m就跳出循环，然后假设我们当前机房为要到的最后一个，那么他要**走的**路程就应该为x[i]（之前已经对坐标排过序了），那么剩下的体力，就要去AK了。

用一个大根堆保存从第一个机房到当前机房**去的**机房的t[]，用一个变量保存当前大根堆中保存着的t[]的总和，然后把当前的t[i]加入大根堆（堆的常规操作put）,总和加上t[i]，接下来用个while循环，如果当前去的机房的总和小于剩下的体力就退出，否则总和需减去堆中最大那个值，也就是堆顶heap[1]（这里有种贪心的思想在里面，想要去得多，那么我们就要尽可能去t[]小的，少去大的），然后把堆顶的元素从大根堆中删除（堆的常规操作get），那么最后我去的机房数就应为大根堆里的元素个数，再在这些元素个数中取一个max为我们要的答案。

整个过程就是这样，本蒟蒻居然花了一下午去调试，真的是妖怪吧！

接下来献上我那没有jzl代码丑陋的代码

60分dp代码：

```cpp
uses math;
var
  x,y:array[0..100000]of int64;
  f:array[0..1001,0..1001]of qword;
  n,i,j,k,ans,x1:longint;
  m:int64;
procedure kp(l,r:longint);
var
  i,j:longint;
  mid:int64;
  begin
    i:=l;
    j:=r;
    mid:=x[(l+r) >> 1];
    repeat
      while x[i]<mid do inc(i);
      while x[j]>mid do dec(j);
      if i<=j then 
        begin
          x[0]:=x[i];x[i]:=x[j];x[j]:=x[0];
          y[0]:=y[i];y[i]:=y[j];y[j]:=y[0];
          inc(i);
          dec(j);
        end;
    until i>j;
    if i<r then kp(i,r);
    if l<j then kp(l,j);
  end;//快排
begin
  readln(n,m);
  for i:=1 to n do readln(x[i],y[i]);
  kp(1,n);
  for i:=1 to n do 
    begin
      f[1,i]:=x[i]+y[i];
      if x[i]+y[i]<=m then ans:=1;
    end;//边界
  for i:=2 to n do 
    for j:=i to n do 
      begin
        f[i,j]:=maxlongint shl 31;
        x1:=0;
        for k:=i-1 to j-1 do
          if f[i-1,k]<f[i,j] then begin f[i,j]:=f[i-1,k];x1:=k; end;
        inc(f[i,j],x[j]+y[j]-x[x1]);
        if f[i,j]<=m then 
          if i>ans then ans:=i; 
      end;//dp
  write(ans);
end.
```
AC代码：


```cpp
var
  heap,x,y:array[0..200001]of int64;
  n,i,j,len,ans:longint;
  m,sum,zz:int64;
procedure swap(var x,y:int64);
var
  t:int64;
  begin
    t:=x;
    x:=y;
    y:=t;
  end;
procedure kp(l,r:longint);
var
  i,j:longint;
  mid:int64;
  begin
    i:=l;
    j:=r;
    mid:=x[(l+r) >> 1];
    repeat
      while x[i]<mid do inc(i);
      while x[j]>mid do dec(j);
      if i<=j then 
        begin
          x[0]:=x[i];x[i]:=x[j];x[j]:=x[0];
          y[0]:=y[i];y[i]:=y[j];y[j]:=y[0];
          inc(i);
          dec(j);
        end;
    until i>j;
    if i<r then kp(i,r);
    if l<j then kp(l,j);
  end;//对坐标进行排序
procedure put(x:longint);
var
  son:longint;
  begin
    inc(len);
    heap[len]:=x;
    son:=len;
    while (son<>1)and(heap[son]>heap[son >> 1]) do
      begin
        swap(heap[son],heap[son >> 1]);
        son:=son >> 1;
      end; 
  end;//堆的常规操作put，不懂的同学可以去查百度
procedure get;
var
  fa,son:longint;
  begin
    dec(len);
    heap[1]:=heap[len];
    fa:=1;
    while (fa*2<=len)or(fa*2+1<=len) do 
      begin
        if (fa*2+1>len)or(heap[fa*2]>heap[fa*2+1]) 
          then son:=fa*2
          else son:=fa*2+1;
        if heap[fa]<heap[son] then 
          begin
            swap(heap[fa],heap[son]);
            fa:=son;
          end
          else break;
      end;
  end;//堆的常规操作get
begin
  readln(n,m);
  for i:=1 to n do readln(x[i],y[i]);
  kp(1,n);
  for i:=1 to n do 
    begin
      zz:=m-x[i];
      if zz<0 then break;
      put(y[i]); inc(sum,y[i]);
      while sum>zz do 
        begin
          dec(sum,heap[1]);
          get;
        end;
      if len>ans then ans:=len;
    end;//上面应该讲的很清楚了 ~~妖怪吧~~
  write(ans);
end.

```

---

## 作者：_czwjp (赞：5)

读入的距离不一定是有序的，读进来先要以距离为关键字排序，对于本身距离大于有的总时间的，或者是本身时间大于总时间的，都处理掉。然后用大根堆来存AK的机房用的时间（不要存距离）。当遇到再往里塞一个时间要超限时，就把你前面用的最大的去掉，直到能再塞，再加上本身的距离（用while来实现）。
下面是一段丑陋的AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
priority_queue<int> q;
int n,total,ans,anss;
long long m,sum;
inline int read(){
       int s=0,f=1;char c=getchar();
       while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}
       while(isdigit(c)){s=s*10+c-'0';c=getchar();}
       return s*f;
}
inline void write(int x){
       if(x<0){x=-x;putchar('-');}
       if(x>9)write(x/10);
       putchar(x%10+'0');
}
inline long long readl(){
       long long s=0,f=1;char c=getchar();
       while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}
       while(isdigit(c)){s=s*10+c-'0';c=getchar();}
       return s*f;
}
struct node{
    long long value;
    long long t;
}a[100010];
bool cmp(node a,node b){return a.t<b.t;}
int main(){
    n=read();cin>>m;
    for(int i=1;i<=n;i++){
        long long x,y;
        cin>>x>>y;
        if(y<=m&&x<=m){
            a[++total].t=x;
            a[total].value=y;
        }
    }
    sort(a+1,a+total+1,cmp);
    for(int i=1;i<=total;i++){
        sum+=a[i].value+a[i].t-a[i-1].t;
        q.push(a[i].value);
        ans++;
        while(sum>m){
            sum-=q.top();
            q.pop();
            ans--;
        }
        anss=max(anss,ans);
    }
    cout<<anss<<endl;
    return 0;
}


```

---

## 作者：Honor誉 (赞：4)

```cpp
#include<iostream>
#include<queue>
#include<algorithm>
using namespace std;
struct data
{
	long long wei,time,tot;
}a[100001];
long long n,m,sum,ans,head;
bool cmp(data a,data b)
{
	return a.tot<b.tot;
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i].wei>>a[i].time;
		a[i].tot=a[i].wei+a[i].time;//计算总和
	}
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++)
	{
		if(sum+a[i].tot-head>m)
		{
			break;
		}
		sum=sum+a[i].tot-head;
		ans++;
		head=a[i].wei;
	}
	cout<<ans<<endl;
	return 0;
}
```
//我们可以计算所需时间的总和，再进行一次排序，每次按最小值去机房AK，同时，我们用一个head记录他所在的位置，如果sum+时间-所在位置来判断是否能到达，能则更新，不能跳出循环，输出。同时，head会抵消重复走的路，相当于只走一遍。


---

## 作者：king_xbz (赞：2)

刷二叉堆的题，发现这题需要用小根堆，又不会用heap，就用了与其性质有些相似的栈过了 

code：
```cpp
#include<bits/stdc++.h>
#define int long long
#define p 6732148
#define h 2001
using namespace std;
struct node
{
	int x;
	//x表示路程 
	int t;
	//t表示时间 
	int tot;
	//tot表示路程＋时间 
}
a[p];
//定义结构体 
stack <int>q;
//定义stl里的栈 
bool cmp(node aa,node bb);
//自定义比较函数 
signed main()
{
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
	cin>>a[i].x>>a[i].t;
	a[i].tot=a[i].x+a[i].t;//输入路程，时间，并计算储存他们的总和 
}
	sort(a+1,a+n+1,cmp);//由大到小排序 
	for(int i=1;i<=n;i++)
		if(a[i].tot<=m)
		q.push(i);
		//如果路程加时间大于总时间，则直接不入栈 ；其余的入栈 
		int pos=0;
		//上一站的位置 
		int tt=0;
		//能ak的机房数 
		int tim=0;
		//已花费总时间 
	while(!q.empty())
	{
		int head=q.top();
		q.pop();
		//取栈顶元素并出栈，由于入栈顺序是tot下由大到小，所以出栈是由小到大 
		if(m-a[head].tot+pos>=tim)
		//如果总时间每次消耗的时间>当前已花费总时间 
		{
		tim+=a[head].tot-pos;
		//当前已花费时间 增加 
		pos=a[head].x;
		//储存当前位置 
		tt++;
		//ak机房加一 
	}
}
	cout<<tt;//输出 
	return 0;
}
bool cmp(node aa,node bb)
{
	return aa.tot>bb.tot;//定义按照tot由大到小排列结构体成员 
}

---

## 作者：杰森的伯恩 (赞：2)

设二元组f[i]表示当前走到了第i个机房时，剩余多少时间，最多能ak多少题，STA表示选择ak的机房的集合（包括第i个），定义二元组运算，状态转移方程为：

![dp](http://img.blog.csdn.net/20170820230035935?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTXJUaW5UaW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

表示如果时间本身就够，那么X可为空集，|x|=0，ak的题就加1，如果时间不够，那就需要在已选择ak的机房中去掉一部分来腾出时间，ak的题的数量就加上（1-去掉的机房数），在二元组运算过程中，剩余时间要保证>=0,最后答案为f[i]在i取1~n中的最大值，可是每次转移的代价太大，因此考虑优化。 由于每个机房都只能ak一次，所以考虑贪心，每次去掉耗时最大的机房，直到时间不超，这样可以用堆来维护选择ak的机房集合。
其实还可以从另外一个角度理解：


可以枚举最后ak的机房i，然后路程花费就是定值了，为x[i]，那剩下m-x[i]就能用于ak题目了，根据贪心，可以每次选择前i个机房中耗时最少的机房ak直到总时间超过m-x[i]，这个可以用堆来维护，这样每次的复杂度为O（nlogn），由于要枚举n个机房，总的时间复杂度为O（n^2logn)。可是光这样时间复杂度过高，无法忍受。考虑优化，实际上，枚举最后ak的机房时，从第i个到第i+1个时，前i+1个机房中耗时最少的并不需要重新统计，因为只是新增了第i+1个机房，所以目前的最小要么是前i个里的最小，要么就是第i+1个。


具体实现时，不必一个一个地添加，只需逆向思维，在考虑第i个机房为结束点时，只要在第i-1个机房为结束点的基础上先去掉耗时最大的直到时限不超。

因为每个机房只会进堆一次出堆一次，所以时间复杂度为O(nlogn）。

```cpp
#include<iostream>
#include<algorithm>
#define f(i,l,r) for(i=(l);i<=(r);i++)
using namespace std;
const int MAXN=100005;
struct Bar{
    long long x;
    int t;
    bool operator < (const Bar& X)const{
        return x<X.x;
    }
}a[MAXN];
int n,ans=0,sz;
long long m,sum,res;
long long heap[MAXN];
inline void pushup(int p)                   //堆的基本操作 
{
    int fa=p>>1,a=heap[p];
    while(fa&&a>heap[fa]){
        heap[p]=heap[fa];
        p=fa;
        fa>>=1;
    }
    heap[p]=a;
}
inline void pushdown(int p)
{
    int son=p<<1,a=heap[p];
    while(son<=sz){
        if(son<sz&&heap[son+1]>heap[son]) son++;
        if(a>=heap[son]) break;
        heap[p]=heap[son];
        p=son;
        son<<=1;
    }
    heap[p]=a;
}
inline void insert(int a)
{
    heap[++sz]=a;
    pushup(sz);
}
inline void Pop()
{
    heap[1]=heap[sz--];
    pushdown(1);
}
int main()
{
    ios::sync_with_stdio(false);         //关闭流同步 
    int i,j;
    cin>>n>>m;
    f(i,1,n){
        cin>>a[i].x>>a[i].t;
    }
    sort(a+1,a+1+n);
    f(i,1,n){
        res=m-a[i].x;                 //能分配给做题的时间 
        if(res<0) break;
        sum+=a[i].t;                  //做题的总时间 
        insert(a[i].t);               //将要做的题加入堆中 
        if(res-sum>=0){               //如果能分配的时间足够  
            ans=max(ans,sz);          
        }
        else{
            while(res-sum<0){         //根据贪心，每次把耗时最大的去掉，知道时间够 
                sum-=heap[1];
                Pop();
            }
            ans=max(ans,sz);          //更新答案 
        }
    }
    cout<<ans<<endl;
    return 0; 
}
```

---

## 作者：_ayaka_ (赞：0)

为什么题解只有堆和排序，这明明也是一道线段树二分的好题。

### 思路

首先显然的思路就是一个 DP。先将每个机房按照 $x_i$ 排序，$dp_i$ 表示最远走到第 $i$ 个机房时最多在几个机房 AK。这里我们可以把走到第 $i$ 个机房与 AK 一个机房这两件事分开。可得当走到第 $i$ 个机房时，小 Z 用来 AK 的时间为 $m-x_i$。

随后可以看出，我们就会想要在 $[1,i]$ 的区间内不断去 AK 需要时间最少的机房，直到时间不够用为止。而这个功能用一个线段树可以轻松实现，具体是这样的：

- 最开始先将每个机房按照 $t_i$ 排序，并将排序后的第 $i$ 个机房的位置定义为其在线段树上的位置，记录为 $id_i$；
- 接着再将每个机房按照 $x_i$ 排序，之后依次访问每个机房。当访问到第 $i$ 个机房时，先在线段树上 $id_i$ 的位置插入权值为 $t_i$ 的点，随后查询当最大时间为 $m-x_i$ 时最多可以 AK 的机房数量。实现上就是一个裸的线段树二分。

最后在每一次查询后取一个最大值即可。时间复杂度 $O(n\log n)$。

### 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define ll (k<<1)
#define rr (k<<1|1)
#define mid ((l+r)>>1)
struct node {
	int x, t, id;
} a[6000005];
bool cmp(node x, node y) {
	return x.x < y.x;
}
bool cmp2(node x, node y) {
	return x.t < y.t;
}
int n, m;
struct tree {
	int l, r, num, sum;
} t[10000005];//sum表示要把这个区间内的所有机房全部 AK 所需的时间，num 表示这个区间内机房的数量
void build(int k, int l, int r) {
	t[k].l = l;
	t[k].r = r;
	if (l == r) return ;
	build(ll, l, mid);
	build(rr, mid + 1, r);
	return ;
}
void pushup(int k) {
	t[k].num = t[ll].num + t[rr].num;
	t[k].sum = t[ll].sum + t[rr].sum;
	return ;
}
void update(int k, int c, int p) {
	if (t[k].l > c || t[k].r < c) return ;
	if (t[k].l == t[k].r) {
		t[k].num = 1;
		t[k].sum = p;
		return ;
	}
	update(ll, c, p);
	update(rr, c, p);
	pushup(k);
}
int query(int k, int num) {
	if (t[k].l == t[k].r) return (num >= t[k].sum) ? t[k].num : 0;
	if (t[k].sum <= num) return t[k].num;
	if (t[ll].sum <= num) return t[ll].num + query(rr, num - t[ll].sum);
	return query(ll, num);
}//线段树二分，不能理解可以多看看
int ans;
signed main() {
	cin >> n >> m;
	for (int i = 1; i <= n; i++) cin >> a[i].x >> a[i].t;
	sort(a + 1, a + n + 1, cmp2);
	for (int i = 1; i <= n; i++) a[i].id = i;
	sort(a + 1, a + n + 1, cmp);
	build(1, 1, n);
	for (int i = 1; i <= n; i++) {
		m -= a[i].x - a[i - 1].x;
		update(1, a[i].id, a[i].t);
		ans = max(ans, query(1, m));
	}
	cout << ans;
	return 0;
}
```

---

## 作者：2018LZY (赞：0)

这是一道贪心+堆的好题.

暴力思路:
由于所用时间其实等于走到最后一个位置的坐标(那么最后一个位置一定有选).设前面有k个机房,则直接按所用时间排序,先取用时少的,直到时间不够.复杂度:$O(n^2*\log(n))$

优化思路:可以发现每次都对前k个时间排序是极不优秀的.
考虑贪心——前面用时最多删除，直到能加入自身。(用大根堆维护时间即可)

这样每个时间只会进堆一次，出堆一次。
复杂度:$O(n*\log(n))$

代码:
```cpp
#include<queue>
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>
#define g getchar()
using namespace std;
typedef long long ll;
const int N=1e5+10;
template<class o>void qr(o&x) {
    char c=g;int f=1;x=0;
    while(!isdigit(c)){if(c=='-')f=-1;c=g;}
    while(isdigit(c))x=x*10+c-'0',c=g;
    x*=f;
}
struct node {
    ll x,t;
    bool operator <(node b)const {return x<b.x;}
}a[N];
int n,ans;ll m;
priority_queue<ll>q;
int main() {
    qr(n);qr(m);
    for(int i=1;i<=n;i++)qr(a[i].x),qr(a[i].t);
    sort(a+1,a+n+1);
    for(int i=1;i<=n;i++) {
        while(m-a[i].x<a[i].t&&q.size())
            m+=q.top(),q.pop();
        if(m-a[i].x>=a[i].t) {
            m-=a[i].t;q.push(a[i].t);
			ans=max(ans,(int)q.size());
        }
    }
    printf("%d\n",ans);
    return 0;
}
```
2020.2.7 update：发现一个错误


---

## 作者：任梦华 (赞：0)

```cpp
/*
本题目其实就是一个堆排序外加一个贪心的算法
（同机房的大佬教我的)
我们先将如果一个机房也不进最远能走到的点存起来（其他点不可能走到，放弃它们）
再用堆存我每次的花费，
超过m的时间范围时去掉最“贵”的点，
让一个比最“贵”的点“便宜”进来
*/
#include<bits/stdc++.h>
using namespace std;
const int ma=1e5+10;
int n,cnt,ans;
long long a[ma],m;//a存堆
struct EE{
    long long x;
    int y;
}e[ma];
void su(int x)//上浮操作
{
    while(x>>1>=1&&a[x>>1]<a[x])
    {
        swap(a[x>>1],a[x]);
        x>>=1; 
    }
}
void sx(int x)//下沉操作
{
    while(x<<1<=cnt)
    {
        int t=x,p=x<<1;
        if(a[p]>a[t])
        t=p;
        if(p+1<=cnt&&a[p+1]>a[t])
        t=p+1;
        if(t==x)
        break;
        swap(a[t],a[x]);
        x=t;
    }
}
void add(int x)//加入一个新值
{
    a[++cnt]=x;
    su(cnt);//上浮
}
void rm()//去掉第一个值
{
    a[1]=a[cnt--];
    sx(1);//下沉
}
bool cmp(EE c,EE d)
{
    return c.x<d.x;
}
int main()
{
    long long p=0,x;//p存我用的时间
    int y,cn=0;//cn存我需要的点的数量
    scanf("%d%lld",&n,&m);
    for(int i=1;i<=n;i++)
    {
        scanf("%lld%d",&x,&y);
        if(x<=m)//我一个机房也不进都走不到的点就放弃
        {
            e[++cn].x=x;
            e[cn].y=y;
        }
    }
    sort(e+1,e+1+cn,cmp);//从小到大排序
    for(int i=1;i<=cn;i++)
    {
        p+=e[i].x+e[i].y-e[i-1].x;//p表示我到第i个机房过程中每个机房都走的话要花费的时间
        add(e[i].y);//存入堆中
        ans++;//答案加一
        if(p>m)//时间不够了
        {
            ans--;//答案减一（减去我上面我多加的一）
            p-=a[1];//去掉花费时间最长的点
            rm();//堆的去除
        }
    }
    printf("%d",ans);
    return 0;
}
```

---


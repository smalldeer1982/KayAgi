# 【模板】左偏树/可并堆

## 题目描述

如题，一开始有 $n$ 个小根堆，每个堆包含且仅包含一个数。接下来需要支持两种操作：

1. `1 x y`：将第 $x$ 个数和第 $y$ 个数所在的小根堆合并（若第 $x$ 或第 $y$ 个数已经被删除或第 $x$ 和第 $y$ 个数在同一个堆内，则无视此操作）。

2. `2 x`：输出第 $x$ 个数所在的堆最小数，并将这个最小数删除（若有多个最小数，优先删除先输入的；若第 $x$ 个数已经被删除，则输出 $-1$ 并无视删除操作）。

## 说明/提示

**【数据规模】**

对于 $30\%$ 的数据：$n\le 10$，$m\le 10$。  
对于 $70\%$ 的数据：$n\le 10^3$，$m\le 10^3$。  
对于 $100\%$ 的数据：$n\le 10^5$，$m\le 10^5$，初始时小根堆中的所有数都在 `int` 范围内。

**【样例解释】**

初始状态下，五个小根堆分别为：$\{1\}$、$\{5\}$、$\{4\}$、$\{2\}$、$\{3\}$。

第一次操作，将第 $1$ 个数所在的小根堆与第 $5$ 个数所在的小根堆合并，故变为四个小根堆：$\{1,3\}$、$\{5\}$、$\{4\}$、$\{2\}$。

第二次操作，将第 $2$ 个数所在的小根堆与第 $5$ 个数所在的小根堆合并，故变为三个小根堆：$\{1,3,5\}$、$\{4\}$、$\{2\}$。

第三次操作，将第 $2$ 个数所在的小根堆的最小值输出并删除，故输出 $1$，第一个数被删除，三个小根堆为：$\{3,5\}$、$\{4\}$、$\{2\}$。

第四次操作，将第 $4$ 个数所在的小根堆与第 $2$ 个数所在的小根堆合并，故变为两个小根堆：$\{2,3,5\}$、$\{4\}$。

第五次操作，将第 $2$ 个数所在的小根堆的最小值输出并删除，故输出 $2$，第四个数被删除，两个小根堆为：$\{3,5\}$、$\{4\}$。

故输出依次为 $1$、$2$。

## 样例 #1

### 输入

```
5 5
1 5 4 2 3
1 1 5
1 2 5
2 2
1 4 2
2 2```

### 输出

```
1
2
```

# 题解

## 作者：hsfzLZH1 (赞：233)

左偏树是 **一种** 支持在 $O(\log_2 n)$ 的时间复杂度内进行合并的 **堆式** 数据结构。

### 一些定义

**外结点** ：左儿子或右儿子是空结点的结点。

**距离** ： 一个结点 $x$ 的距离 $dist_x$ 定义为其子树中与结点 $x$ 最近的外结点到 $x$ 的距离。特别地，定义空结点的距离为 $-1$ 。

### 左偏树的基本性质

左偏树具有 **堆性质** ，即若其满足小根堆的性质，则对于每个结点 $x$ ，有 $v_x\le v_{lc},v_x\le v_{rc}$ 。

左偏树具有 **左偏性质** ，即对于每个结点 $x$ ,有 $dist_{lc}\ge dist_{rc}$ 。

### 基本结论

1. 结点 $x$ 的距离 $dist_x=dist_{rc}+1$ 。

2. 距离为 $n$ 的左偏树至少有 $2^{n+1}-1$ 个结点。此时该左偏树的形态是一棵满二叉树。

3. 有 $n$ 的结点的左偏树的根节点的距离是 $O(\log_2 n)$ 的。

### 基本操作：合并操作

左偏树最基本的操作是合并操作。

定义 `merge(x,y)` 为合并两棵分别以 $x,y$ 为根节点的左偏树，其返回值为合并之后的根节点。

首先不考虑左偏性质，我们描述一下合并两个具有堆性质的树的过程。假设我们要合并的是小根堆。

1. 若 $v_x\le v_y$ ，以 $x$ 作为合并后的根节点；否则以 $y$ 作为合并后的根节点。为避免讨论，若有 $v_x>v_y$ ，交换 $x,y$ 。

2. 将 $y$ 与 $x$ 的其中一个儿子合并，用合并后的根节点代替与 $y$ 合并的儿子的位置，并返回 $x$ 。

3. 重复以上操作，如果 $x$ 和 $y$ 中有一个为空节点，返回 $x+y$ 。

令 $h$ 为树高， $h_x+h_y$ 每次都减少了 $1$  ，上述过程的时间复杂度是 $O(h)$ 的，当合并的树退化为一条链时，这样做的复杂度是 $O(n)$ 的。要使时间复杂度更优，就要使树合并得更 **平衡** 。我们有两种方式：

1. 每次随机选择 $x$ 的左右儿子进行合并。（有没有感觉这很像 FHQ Treap ？）

2. 左偏树。

由于左偏树中左儿子的距离大于右儿子的距离，我们 **每次将 $y$ 与 $x$ 的右儿子合并** 。由于左偏树的树高是 $O(\log_2 n)$ 的，所以单次合并的时间复杂度也是 $O(\log_2 n)$ 的。

但是，两棵左偏树按照上述方法合并后，可能不再保持左偏树的左偏性质。在每次合并完之后，判断对结点 $x$ 是否有 $dist_{lc}\ge dist_{rc}$ ，若没有则交换 $lc,rc$ ，并维护 $x$ 的距离 $dist_x=dist_{rc}+1$ ，即可维护左偏树的左偏性质。

由于合并后的树既满足堆性质又满足左偏性质，所以合并后的树仍然是左偏树。

```cpp
int merge(int x,int y)
{
    if(!x||!y)return x+y;
    if(v[y]<v[x])swap(x,y);
    rc[x]=merge(rc[x],y);
    if(dist[lc[x]]<dist[rc[x]])swap(lc[x],rc[x]);
    dist[x]=dist[rc[x]]+1;
    return x;
}
```

### 左偏树的其他基本操作

#### 插入给定值

新建一个值等于插入值的结点，将该节点与左偏树合并即可。时间复杂度 $O(\log_2 n)$ 。

#### 求最小值

由于左偏树的堆性质，左偏树上的最小值为其根节点的值。

#### 删除最小值

等价于删除左偏树的根节点。合并根节点的左右儿子即可。记得维护已删除结点的信息。

#### 给定一个结点，求其所在左偏树的根节点

我们可以记录每个结点的父亲结点 $fa_i$ ，然后暴力跳父亲结点。

```cpp
int findrt(int x)
{
    if(fa[x])return findrt(fa[x]);
    return x;
}
```

注意，虽然左偏树的距离是 $O(\log_2 n)$ 的，但是左偏树的深度最大可以是 $O(n)$ 的，这种做法的复杂度也是 $O(n)$ 的。

上面的代码让你想到了什么？并查集。我们同样可以用 **路径压缩** 的方式，求一个结点所在左偏树的根节点。

```cpp
int find(int x){return rt[x]==x?x:rt[x]=find(rt[x]);}
```

使用这种写法，需要维护 `rt[x]` 的值。

在合并两个结点 $x,y$ 时，令 `rt[x]=rt[y]=merge(x,y)` 。

在删除左偏树中的最小值时，令 `rt[lc[x]]=rt[rc[x]]=rt[x]=merge(lc[x],rc[x])` ，因为 $x$ 是之前左偏树的根节点，在路径压缩时可能有 `rt` 的值等于 $x$ ，所以 `rt[x]` 也要指向删除后的根节点。

由于 $x$ 已经被作为中间量使用得不成样子，如果之后还要用到结点 $x$ ，需要新建一个值相同的结点。

路径压缩后，可以在 $O(\log_2 n)$ 的优秀时间复杂度内找到一个点所在左偏树的根节点。

### 代码展示

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=100010;
int n,m,op,x,y;
int lc[maxn],rc[maxn],dist[maxn],rt[maxn];
bool tf[maxn];
struct node
{
    int id,v;
    bool operator<(node x)const{return v==x.v?id<x.id:v<x.v;}
}v[maxn];
int find(int x){return rt[x]==x?x:rt[x]=find(rt[x]);}
int merge(int x,int y)
{
    if(!x||!y)return x+y;
    if(v[y]<v[x])swap(x,y);
    rc[x]=merge(rc[x],y);
    if(dist[lc[x]]<dist[rc[x]])swap(lc[x],rc[x]);
    dist[x]=dist[rc[x]]+1;
    return x;
}
int main()
{
    dist[0]=-1;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)scanf("%d",&v[i].v),rt[i]=i,v[i].id=i;
    while(m--)
    {
        scanf("%d%d",&op,&x);
        if(op==1)
        {
            scanf("%d",&y);
            if(tf[x]||tf[y])continue;
            x=find(x);y=find(y);
            if(x!=y)rt[x]=rt[y]=merge(x,y);
        }
        if(op==2)
        {
            if(tf[x]){printf("-1\n");continue;}
            x=find(x);
            printf("%d\n",v[x].v);
            tf[x]=true;
            rt[lc[x]]=rt[rc[x]]=rt[x]=merge(lc[x],rc[x]);
            lc[x]=rc[x]=dist[x]=0;
        }
    }
    return 0;
} 
```

---

## 作者：引领天下 (赞：31)

折腾了几天终于把这个题A了。。。

看到手写左偏树/配对堆已经有很多题解了，而pbds却没有人介绍，我来介绍一发

首先，pbds是什么？

pbds是一个比STL还STL的库，里面封装了各种可并堆、红黑树等等数据结构，大大地方便了oier。

## 最重要的是，NOIP支持pbds了！

~~既然如此那我们当然选择封装而不是手写~~

解下来的内容大佬请略过

具体的代码里说吧

```cpp
#include <bits/stdc++.h>
#include <ext/pb_ds/priority_queue.hpp>//引用pbds的库的堆
#pragma GCC optimize(3)
using namespace std;
inline char nc(){
  	static char buf[100000],*p1=buf,*p2=buf;
  	return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
template <typename _Tp>
inline void read(_Tp &x){
    int f=1;x=0;char ch=nc();
  	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=nc();}
  	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=nc();}
  	x*=f;
}
inline void write(long long n){
    if(n==0) return;
    write(n/10);
    putchar(n%10+'0');
}
struct ${
    int s,id;
    inline bool operator < (const $ &p)const{if (s!=p.s)return s>p.s;else return id>p.id;}//注意！由于使用了pbds，只能重载运算符。而且pbds中的堆很毒瘤，它把<重载成>，然后排>，所以重载的时候要注意反着重载
};//结构体，存每个数的数值和id
inline $ g(int a,int b){$ p;p.s=a,p.id=b;return p;}//将2个int转成一个$
__gnu_pbds::priority_queue<$> q[100005];//定义一个pbds的堆
//使用__gnu_pbds::来引用pbds内的内容
int n,m,f[100005],x;
bool s[100005];//如果s[i]==1则i被删除
int find(int n){return f[n]==n?n:f[n]=find(f[n]);}//维护并查集，这里实际上可以路径压缩
int main(){
    read(n),read(m);
    for (int i=1;i<=n;i++)read(x),q[i].push(g(x,i)),f[i]=i;//读入的同时对每个i建一个堆，同时初始化并查集
    while (m--){
        read(x);
        if (x==1){
            int a,b;
            read(a),read(b);
            int fa=find(a),fb=find(b);
            if (fa==fb||s[a]||s[b])continue;//坑点1：注意不要把s[a]||s[b]写成了s[fa]||s[fb]
            if (q[fa].size()>q[fb].size())f[fb]=fa,q[fa].join(q[fb]);//按堆的大小合并
            else f[fa]=fb,q[fb].join(q[fa]);
        }else{
            int a;
            read(a);
            if (s[a]){puts("-1");continue;}
            int fa=find(a);
            write((q[fa].top()).s),puts(""),s[(q[fa].top()).id]=1,q[fa].pop();//同普通堆
        }
    }
}
```

看了一下，我的代码应该算短的。而且开了O3之后，封装的也不慢，所以向大家强烈推荐pbds！

---

## 作者：Jianuo_Zhu (赞：23)

普通的二叉堆是一颗完全二叉树，可以支持$O(1)$的查询当前堆内min/max，$O(log n)$的插入和删除节点。他支不支持合并呢？

我们可以首先改变一下堆的写法，把他用一种类似BST(二叉搜索树)的写法写出来，就可以有一种合并的方法！

先用文字描述一下：假设我们要将x和y这两个小根堆合并，我们判断一下如果x的堆顶大于y的堆顶，就交换一下x和y，然后继续合并x的某个子孩子和y。

没看懂上面那一段文字也没关系，我们上图：(图取自教练上课时的课件，应该没关系吧QAQ)

![lala](https://i.loli.net/2018/11/18/5bf16d358221f.jpg)
假设我们要合并这两棵树

![](https://i.loli.net/2018/11/18/5bf16dc32b7cb.jpg)

继续往下合并

![](https://i.loli.net/2018/11/18/5bf16e33be631.jpg)

这次合并我们发现x的堆顶大于y的堆顶了，就交换了x和y，然后继续往下合并

![](https://i.loli.net/2018/11/18/5bf16ebd7133f.jpg)

最后我们发现7没有右儿子，就直接让7的右儿子变成y就行了！！

![](https://i.loli.net/2018/11/18/5bf16f387cc36.jpg)

到此，合并正式完成！

但是我们发现这样合并完之后，堆并不再是一颗完全二叉树了，那怎么办呢？

这里就我们可以用一种贪心的思想。其实就是我之前说的继续合并x的某个儿子与y。究竟是哪个儿子呢？

我们这里定义一个值，叫做"根值"，一个节点的根值就是它到最近的叶子节点的距离。其实之前那几张图上每个节点左上角的值就是这个点的根值。

那么我们每次合并就只要合并x的根值最小的儿子和y就行了。这就叫做启发式合并(貌似)。是不是跟并查集的按秩合并有点像啊!

关于他的复杂度，我们可以感性理解为O(两个堆的堆顶的根值)，而用这种启发式合并的话，即使根值最坏也就是$logn$的(完全二叉树)，所以合并一次的复杂度就是$O(log n)$的辣！

那么左偏树又是什么呢？其实就是保证它的右儿子的根值比作儿子小，然后每次合并就只用合并x的右儿子和y就行了！同时回溯的时候发现不满足左偏树性质时就交换左右儿子(感觉没什么用啊)


>插入

就是合并一个堆和一个只有一个点的堆。

>删除

直接合并它的左右儿子就行了

>查询堆顶

直接返回堆顶就行了

关于启发式合并那一块是学了左偏树之后自己YY的，不知道是否叫这个啊？还是有什么别的名字？各位dalao轻喷啊QAQ

下面贴代码吧！指针党福利！(有想看指针版treap的可以去我的题解里)

启发式合并：(通过Luogu P3377,用时405ms)

```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<iostream>
#define DEBUG printf("PassLine:%d\n", __LINE__)
using namespace std;
const int maxn = 1e5+10; 
struct left_heap{
    int dist, val, idx;
    left_heap *ls, *rs, *fa;
    left_heap(){
        dist = val = idx = 0;
        ls = rs = fa = NULL;
    }
};
int n, m, exist[maxn];
left_heap *tr[maxn];
left_heap *getf(left_heap *x){//找到x所属的堆的根
    while(x->fa != NULL && x!=NULL) x = x->fa;
    return x;
}
left_heap *merge(left_heap *x, left_heap *y){
    if(x == NULL) return y;
    if(y == NULL) return x;
    if(x->val > y->val || (x->val == y->val && x->idx > y->idx)) swap(x, y);//如果x的堆顶的值大于y的堆顶，就交换两个堆
    if(x->ls == NULL) x->ls = merge(x->ls, y);
    else if(x->rs == NULL) x->rs = merge(x->rs, y);
    else if(x->ls->dist < x->rs->dist) x->ls = merge(x->ls, y);//左儿子的根值比右儿子小就继续合并左儿子和y
    else x->rs = merge(x->rs, y);//否则合并右儿子和y
    if(x->ls != NULL) x->ls->fa = x;
    if(x->rs != NULL) x->rs->fa = x;
    if(x->ls == NULL || x->rs == NULL) x->dist = 0;
    else x->dist = min(x->ls->dist, x->rs->dist)+1;//更新x的根值
    return x;
}
int pop(left_heap *x){
    int t = x->val;
    if(x->ls != NULL)x->ls->fa = NULL;
    if(x->rs != NULL)x->rs->fa = NULL;
    if(x->ls != NULL && x->rs != NULL)merge(x->ls, x->rs);//合并左右儿子
    exist[x->idx] = true;
    delete x;//直接在内存中删除x，以防后患+节约内存
    return t;
}
int main(){
    ios::sync_with_stdio(false);
    cin >> n >> m;
    int t;
    for(int i=1; i<=n; i++){
        cin >> t;
        left_heap *la = new left_heap;
        la->val = t; la->idx = i; tr[i] = la;
    }
    int opt, x, y;
    for(int i=1; i<=m; i++){
        cin >> opt;
        if(opt == 1){//合并操作
            cin >> x >> y;
            if(exist[x] || exist[y]) continue;
            if(x == y) continue;
            left_heap *fx = getf(tr[x]), *fy = getf(tr[y]);//找到两个堆的根
            if(fx == fy) continue;
            merge(fx, fy);//合并
        }
        if(opt == 2){
            cin >> x;
            if(exist[x] || exist[getf(tr[x])->idx]){cout << -1 << endl;continue;}
            else cout << pop(getf(tr[x])) << endl;
        }
    }
}
```

左偏树：(通过Luogu P3377, 用时363ms)

```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<iostream>
#define DEBUG printf("PassLine:%d\n", __LINE__)
using namespace std;
const int maxn = 1e5+10; 
struct left_heap{
    int dist, val, idx;
    left_heap *ls, *rs, *fa;
    left_heap(){
        dist = val = idx = 0;
        ls = rs = fa = NULL;
    }
};
int n, m, exist[maxn];
left_heap *tr[maxn];
left_heap *getf(left_heap *x){
    while(x->fa != NULL && x!=NULL) x = x->fa;
    return x;
}
left_heap *merge(left_heap *x, left_heap *y){
    if(x == NULL) return y;
    if(y == NULL) return x;
    if(x->val > y->val || (x->val == y->val && x->idx > y->idx)) swap(x, y);
    x->rs = merge(x->rs, y);
    if(x->rs != NULL)x->rs->fa = x;
    if(x->ls == NULL){x->ls = x->rs; x->rs = NULL;}
    else if(x->ls->dist < x->rs->dist) swap(x->ls, x->rs);//主要是这一步，如果左儿子比右儿子根值小，就交换左右儿子
    x->dist = (x->rs == NULL ? 0 : x->rs->dist+1);
    return x;
}
int pop(left_heap *x){
    int t = x->val;
    if(x->ls != NULL)x->ls->fa = NULL;
    if(x->rs != NULL)x->rs->fa = NULL;
    if(x->ls != NULL && x->rs != NULL)merge(x->ls, x->rs);
    exist[x->idx] = true;
    delete x;
    return t;
}
int main(){
    ios::sync_with_stdio(false);
    cin >> n >> m;
    int t;
    for(int i=1; i<=n; i++){
        cin >> t;
        left_heap *la = new left_heap;
        la->val = t; la->idx = i; tr[i] = la;
    }
    int opt, x, y;
    for(int i=1; i<=m; i++){
        cin >> opt;
        if(opt == 1){
            cin >> x >> y;
            if(exist[x] || exist[y]) continue;
            if(x == y) continue;
            left_heap *fx = getf(tr[x]), *fy = getf(tr[y]);
            if(fx == fy) continue;
            merge(fx, fy);
        }
        if(opt == 2){
            cin >> x;
            if(exist[x] || exist[getf(tr[x])->idx]){cout << -1 << endl;continue;}
            else cout << pop(getf(tr[x])) << endl;
        }
    }
}
```

最后说几句，可并堆还有好几种，如配对堆，斐波那契堆等等，大家想学的可以去看一看！

---

## 作者：feecle6418 (赞：21)

这道题目还有一个解法，即启发式合并堆。启发式合并其实就是优雅的暴力，把小的往大的合并。启发式合并这种解法代码量小，思维简单，时间复杂度不高，不失为一种好方法。

如果我们在合并两个集合时，总是把小的集合合并到大的里面，那么小的集合至少会增长到原来的两倍。而至多合并 $n-1$ 次，每个集合至多**被**合并 $log_2n$ 次，因此合并的时间复杂度是 $O(nlog_2n)$。而由于堆的存在，使得复杂度还要带一个 $log_2$。因此，启发式合并堆，时间复杂度为 $nlog_2^2n$。可以通过本题。

具体实现很简单，只需要合并时记一个 $prt_i$ 值，表示现在第 $i$ 个元素到底在哪个堆里，用类似于并查集路径压缩的方法更新。具体实现细节可以看代码。

```
// luogu-judger-enable-o2
#include<iostream>
#include<queue>
#include<cstdio>
using namespace std;
struct Node{
    int data,num;
    bool operator <(const Node tt) const {
        if(data!=tt.data)return data>tt.data;
        return num>tt.num;
    }
}a[100005];
priority_queue<Node>q[100005];
int n,m,prt[100005],del[100005];
int GetFa(int x){
    return x==prt[x]?x:prt[x]=GetFa(prt[x]);
}
void Merge(int x,int y){
    if(del[x]||del[y])return ;
    x=GetFa(x);
    y=GetFa(y);
    if(x==y)return ;
    if(q[x].size()>q[y].size())swap(x,y);
    prt[x]=y;
    while(q[x].size()){
        q[y].push(q[x].top());
        q[x].pop();
    }
}
int DeleteMin(int x){
    x=GetFa(x);
    Node t=q[x].top();
    q[x].pop();
    del[t.num]=1;
    return t.data;
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i].data);
        prt[i]=i;
        a[i].num=i;
        q[i].push(a[i]);
    }
    for(int i=1;i<=m;i++){
        int opt,x,y;
        scanf("%d%d",&opt,&x);
        if(opt==1){
            scanf("%d",&y);
            Merge(x,y);
        }
        else {
            if(del[x])puts("-1");
            else printf("%d\n",DeleteMin(x));
        }
    }
    return 0;
}

```

---

## 作者：HOOCCOOH (赞：12)

Paring Heap很好用啊，感觉比二叉堆还好写？

PS:因为不需要decrease key，无需维护father，否则可能有些繁琐


核心操作就是merge：

```cpp
struct T_{int c;T_ *l,*r;}; // 权值；左儿子右兄弟

T_ *merge_(T_ *a, T_ *b) // 合并堆a和b，返回新根 
{
  if(!a) return b; if(!b) return a;
  if(a->c > b->c) swap(a, b); // 小根堆。本题应写为先权值后编号比较 
  return b->r = a->l, a->l = b, a;
}
T_ *merges_(T_ *c) // （辅助）合并节点c和他的兄弟们 
{
  if(!c || !c->r) return c;
  T_ *a = c->r, *b = a->r; c->r = a->r = NULL;
  return merge_(merge_(c, a), merges_(b)); // Paring！ 
}
```

取最小直接访问根即可。

pop操作直接用merges\_(root->l)合并根的所有儿子，返回的就是新根


---

## 作者：MoonCake2011 (赞：4)

[抄的我自己的文章](https://www.luogu.com.cn/article/q6rixjn2)。

# 可并堆

可并堆，机翻英文 Mergeable Heap。（显然是缝合词）

有很多的可并堆，左偏树 or 右偏树、随机堆、斜堆、二项堆、配对堆、斐波那契堆、斜二项堆、基数堆。

本文会介绍**随机堆**，**斜堆**，**左偏树**，**配对堆**。

那么复习一遍二叉堆，我们直接开始。

**注：此文以小根堆为例讲解**。

## 满足堆性质的二叉树结构

并非二叉堆，在此定义这个玩意简称**基础可并堆**。

**基础可并堆**可以不满足完全二叉堆的性质。

聪明的你们想想如何合并以 $p$ 为根的**基础可并堆**与一个以 $q$ 为根的**基础可并堆**呢。

很简单，合并 $p$ 和 $q$，我们肯定要让 $p$ 和 $q$ 中小的那一个作为根。

然后将 $p$ 的任意一个儿子与 $q$ 合并（递归下去）。

于是可以很好写出代码。

```cpp
node *merge(node *p,node *q){
	if(p==null) return q;
	if(q==null) return p;
	if(p->val>q->val) swap(p,q);
	if(p->val==q->val && p->id>q->id) swap(p,q);
	p->r=merge(p->r,q);//想 merge 啥儿子 merge 啥儿子
	p->l->fa=p->r->fa=p->fa=p;
	null->val=0;//建议每次都将空指针初始化一遍
	null->l=null->r=null,null->fa=null;
	return p;
}
```

删除最小值就是删除根节点，再把根的左儿子与右儿子合并即可。

但是这样会被卡到 $O(n)$，所以考虑优化。

## 随机堆

发现随机数据下，**基础可并堆**可以做到均摊 $O(\log n)$。

于是尝试每次随机递归儿子就行了。

然后就完了？

完了。

```cpp
node *merge(node *p,node *q){
	if(p==null) return q;
	if(q==null) return p;
	if(p->val>q->val) swap(p,q);
	if(p->val==q->val && p->id>q->id) swap(p,q);
	if(rand()&1) p->r=merge(p->r,q);//随机 merge
	else p->l=merge(p->l,q);
	p->l->fa=p->r->fa=p->fa=p;
	null->val=0;//建议每次都将空指针初始化一遍
	null->l=null->r=null,null->fa=null;
	return p;
}
```

## 斜堆

每次 merge 的时候，我们发现，被递归 merge 的儿子子树可能深度要深一点吧（毕竟是合并进了另外一个堆的）。

所以直接每次向右合并，合并完交换左右儿子就可以均摊 $O(\log n)$。

当然也可以每次向左合并，合并完交换左右儿子就可以均摊 $O(\log n)$。

```cpp
node *merge(node *p,node *q){
	if(p==null) return q;
	if(q==null) return p;
	if(p->val>q->val) swap(p,q);
	if(p->val==q->val && p->id>q->id) swap(p,q);
	p->r=merge(p->r,q);
	swap(p->l,p->r);//直接交换
	p->l->fa=p->r->fa=p->fa=p;
	null->val=0;//建议每次都将空指针初始化一遍
	null->l=null->r=null,null->fa=null;
	return p;
}
```

## 左偏树 or 右偏树

**XZY：你至少讲个单次 $O(\log n)$ 的。**

**LBY：好好好，这不就来了吗？**

做骗术，做片书？

诱骗术，有篇书？

$\textcolor{white}{恭喜你与 XZY，你被做骗术和诱骗术骗了}$

左偏树上一个节点的 $dist$ 定义为它到它子树内的空节点的最短距离。

空节点的 $dist=0$。

对于左偏树上的任意节点 $dist_{sonl_x}\ge dist_{sonr_x}$。（左偏性质）

可以得到 $dist_x=dist_{sonr_x}+1$。

可以证明，一个 $n$ 个节点的左偏树，根节点的距离一定 $\le \log n$。

简单维护一下 $dist$ 即可单次 $O(\log n)$。

```cpp
node *merge(node *p,node *q){
	if(p==null) return q;
	if(q==null) return p;
	if(p->val>q->val) swap(p,q);
	if(p->val==q->val && p->id>q->id) swap(p,q);
	p->r=merge(p->r,q);
	if(p->l->dist<p->r->dist) swap(p->l,p->r);
	p->dist=p->r->dist+1;
	p->l->fa=p->r->fa=p->fa=p;
	null->l=null->r=null,null->fa=null;
	return p;
}
```

右偏树同理。

### 删除任意节点

先将那个节点的左右儿子合并。

然后自底向上更新 $dist$，按照性质交换左右儿子，直到 $dist$ 不用更新时。

均摊 $O(\log n)$。

证明：

首先 `merge` 可以保证为 $O(\log n)$。

其次，向上更新时，每个结点的 $dist$ 至少减一（否则不用更新），每个节点最多跳到 $O(\log n)$ 次。（每个节点初始 $dist\le \log n$）

## 配对堆

是大名鼎鼎的 Robert E. Tarjan 老爷子发明的。

配对堆的常数比斐波那契堆少太多了，所以一般配对堆会比斐波那契堆快一些。

[原论文](https://www.cs.cmu.edu/~sleator/papers/pairing-heaps.pdf)。

配对堆是一棵满足堆性质的带权**多叉树**，并非二叉树。

对于每个节点，它的儿子是有一个特定的从左向右的顺序的。

（借下 oi-wiki 的图）

![](https://oi-wiki.org/ds/images/pairingheap1.jpg)

一个节点需要存它的儿子中最左边的那一个，并且存下在它右边的那个儿子。

（借下 oi-wiki 的图）

![](https://oi-wiki.org/ds/images/pairingheap2.jpg)

### 合并操作

将两个堆的根节点较大者变为较小者最左边的儿子。

```cpp
inline node *merge(node *p,node *q){
	if(p==nullptr) return q;
	if(q==nullptr) return p;
	if(p->val>q->val) swap(p,q);
	q->t=p->s,p->s=q;//t 为兄弟，s 为儿子
	return p;
}
```

### 删除最小值

这个操作必须小心，很容易写假。

首先，我们先合并根节点所有儿子，然后将根节点删了。

但是如果直接合并的话，这是 $O(n)$ 的。

为了保证均摊复杂度，我们需要使用一个非常 NB 的合并方法。

先将那些儿子们相邻两个配成一对，这样会配成很多对，将所有配成对的堆用 `merge` 函数合并。（这是配对堆名字的来由）

接着将那些配对合并完的堆**从右向左（注意顺序，重要的事情说三遍:从右向左，从右向左，从右向左）** 依次用 `merge` 函数合并。

```cpp
node *merge_bros(node *p){//合并 p 的所有兄弟
		if(p==nullptr || p->t==nullptr) return p;
		node *q=p->t;
		node *d=q->t;
		p->t=q->t=nullptr;
		return merge(merge_bros(d),merge(p,q));//配对再合并
}
```

`merge_bros` 函数的递归的实现满足了**从右向左**的顺序要求。

于是可以直接写出删除最小值的操作。

```cpp
inline void pop(){
	heap_size--;
	node *T=root;
	root=merge_bros(root->s);
	delete T;
}
```

配对堆可以做到合并与查询单次 $O(1)$，删除均摊 $O(\log n)$。

配对堆的删除任意节点复杂度并没有什么确切的证明，这里就不提了，如果没有删除任意节点的话，写配对堆是比左偏树要好的。

在此给出封装的指针配对堆代码（轻微压行）。

```cpp
template<typename type>
class heap{
	size_t heap_size;
	struct node{node *s,*t;type val;}*root;
	node *merge_bros(node *p){//核心函数
		if(p==nullptr || p->t==nullptr) return p;
		node *q=p->t;node *d=q->t;p->t=q->t=nullptr;
		return merge(merge_bros(d),merge(p,q));
	}
	inline node *merge(node *p,node *q){//核心函数
		if(p==nullptr) return q;
		if(q==nullptr) return p;
		if(p->val>q->val) swap(p,q);
		q->t=p->s,p->s=q;
		return p;
	}
	public:
	inline heap<type>(){root=nullptr;}
	inline void merge(node *p){//核心函数
		if(root==nullptr){root=p;return;}
		if(p==nullptr) return;
		if(root->val>p->val) swap(p,root);
		p->t=root->s,root->s=p;
	}
	inline void merge(heap x){//合并两个堆
	    node *p=x.root;
		if(root==null){root=p;return;}
		if(p==null) return;
		if(root->val>p->val) swap(p,root);
		p->t=root->s,root->s=p;
	}
	inline void push(type x){
		heap_size++;
		node *p=new node;
		p->val=x;p->s=nullptr,p->t=nullptr;
		merge(p);
	}
	inline void pop(){
		heap_size--;
		node *T=root;
		root=merge_bros(root->s);
		delete T;
	}
	inline type top(){return root->val;}
	inline bool empty(){return !heap_size;}
	inline size_t size(){return heap_size;}
	inline void clear(){root=nullptr;}
};
```

# 例题

[【模板】左偏树/可并堆](https://www.luogu.com.cn/problem/P3377) & [罗马游戏](https://www.luogu.com.cn/problem/P2713) & [【模板】可并堆 2](https://www.luogu.com.cn/problem/P11266) & [Monkey King](https://www.luogu.com.cn/problem/P1456)。

将可并堆配合一个并查集就行了（左偏树高度可能达到 $O(n)$）。

有些可以合并集合的隐式题目也可以考虑用可并堆。

[[JLOI2015] 城池攻占](https://www.luogu.com.cn/problem/P3261)

可以对每个节点建立小根堆，存所有骑士。

然后自底向上合并，每次直接暴力去淘汰一些干不动这个城池的骑士。

对于乘与加操作，我们选择直接在左偏树 / 配对堆上打懒标记并且在一些时间下传标记就行了。

# 习题

[[BalticOI 2004] Sequence 数字序列](https://www.luogu.com.cn/problem/P4331)

[[SCOI2011] 棘手的操作](https://www.luogu.com.cn/problem/P3273)

[[APIO2012] 派遣](https://www.luogu.com.cn/problem/P1552)

[断罪者](https://www.luogu.com.cn/problem/P4971)

# 附录（平板电视）

pbds 是一个不常用的库。

在头文件 `bits/extc++.h` 里面。

或者

```cpp
#include<ext/pb_ds/tree_policy.hpp>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/priority_queue.hpp>
```

里面可以用可以合并的堆 `priority_queue`。

形式是这样的 `__gnu_pbds::priority_queue<type,排序方式(cmp),哪种类型的堆(heap_tag)>;`

`cmp` 就是与 STL 一样的什么 `greater` 和 `less`。

`heap_tag` 是特有的，代表你要用哪种堆。

用 `binary_heap_tag` 就代表用的是二叉堆，合并时间复杂度没有保证。

用 `pairing_heap_tag` 是用配对堆，效率最佳。

---

## 作者：_Weslie_ (赞：2)

左偏树，是一种可以在 $\operatorname{O}(n\log n)$ 的时间复杂度内快速合并堆的堆式数据结构。

## 0x00 约定

1. 如果没有特殊说明，下面的**堆**默认为**小根堆**。
2. 记 $ls_u$ 为节点 $u$ 的左儿子，$rs_u$ 为节点 $u$ 的右儿子。
3. $val_i$ 表示第 $i$ 个小根堆初始时包含且仅包含的数。
4. 记 $root$ 为左偏树的根节点。

## 0x10 左偏树的定义

对于一棵二叉树，我们定义外节点为子节点数小于两个的节点，定义一个节点的 $dis$ 为其到子树中最近的外节点所经过的边的数量。

例如下图中标红的节点是外节点：

![](https://cdn.luogu.com.cn/upload/image_hosting/newdzgoa.png)

那么我们可以处理节点的 $dis$。

![](https://cdn.luogu.com.cn/upload/image_hosting/qo96fw72.png)

约定：外界点的 $dis$ 为 $0$，空节点的 $dis$ 为 $-1$。

左偏树是一棵二叉树，它不仅具有堆的性质，并且是「左偏」的：每个节点左儿子的 $dis$ 都大于等于右儿子的 $dis$。

## 0x20 左偏树的性质

这一部分是后面我们做题的基本条件。

1. 堆性。本题要求是小根堆，于是 $val_u\le val_{ls_u}$ 且 $val_u\le val_{rs_u}$。
2. 左偏性。即对所有的 $u$ 有 $dis_{ls_u}\ge dis_{rs_u}$。
3. $dis$ 的性质。$dis_u=dis_{rs_u}+1$。

## 0x30 左偏树的合并

这一部分是左偏树的最核心部分。

总体过程是这样的：假设现在第一个堆根是节点 $x$，第二个堆根是节点 $y$。

如果发现 $val_y<val_x$（本题中还有其他条件，这里略过，在代码中体现），直接把两个堆交换（实质上只需要换根 $x$ 和 $y$）。

然后递归合并右儿子和 $y$ 为根的堆。

最后回溯如果发现一个堆不符合左偏性了（$dis_{ls_u}< dis_{rs_u}$），就交换左右儿子。

代码是这样的：

```
int merge(int x,int y){//返回值是当前堆的根
	if(!x||!y)return x+y;
	if((val[x]==val[y]&&x>y)||val[x]>val[y])swap(x,y);
	rs[x]=merge(rs[x],y);
	if(dis[ls[x]]<dis[rs[x]])swap(ls[x],rs[x]);
	dis[x]=dis[rs[x]]+1;
	return x;
}
```

接下来我们看图理解。

![](https://cdn.luogu.com.cn/upload/image_hosting/uiwzue58.png)

节点编号代表权值，即 $val_i=i$。

首先，两堆堆顶分别为 $1$ 和 $9$、$8$ 和 $9$ 时，都不需要换根（显然符合条件 $val_x>val_y$）。

然后堆顶来到 $10$ 和 $9$。这时需要换根，如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/mqf4r88m.png)

然后堆顶来到 $17$ 和 $10$。这时需要换根，如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/k1tmuakj.png)

然后堆顶来到 $19$ 和 $17$。这时需要换根，如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/cxfp2ihr.png)

然后我们的 $x$ 变为 $17$ 的右儿子，即空节点。根据代码中 `if(!x||!y)return x+y;` 这一行，我们直接把 $19$ 插在 $17$ 的后面。

![](https://cdn.luogu.com.cn/upload/image_hosting/owpqnvpp.png)

然后我们回溯检验左偏性。发现到 $17$ 的时候不满足左偏性（空节点 $dis$ 为 $-1$），于是左右儿子互换。发现到 $10$ 的时候不满足左偏性，于是左右儿子互换。然后发现节点 $9$ 不满足左偏性，于是互换。

![](https://cdn.luogu.com.cn/upload/image_hosting/tw2p38s6.png)

再回溯，都满足左偏性。于是最后合并完就是上面这样。


复杂度证明：由于左偏性质，每递归一层，其中一个堆的根节点的 $dis$ 就会减少 $1$,所以合并两个大小为 $n$ 和 $m$ 的堆的时间复杂度是 $\operatorname{O}(\log n+\log m)$。


## 0x40 最小值的查询

$u$ 所在堆的最小值就是这个堆的堆顶，于是我们用一个并查集来维护一个堆。

## 0x50 节点的删除

我们假设我们现在已经找到了最小值的节点 $u$，要把它删掉。

我们于是需要合并 $ls_u$ 和 $rs_u$，然后把它们（$ls_u$ 和 $rs_u$）的祖先调为新的根。

注意：$u$ 的祖先也需要调为新的根，因为子树内部还有可能有没有改变祖先，祖先还是 $u$ 的节点，如果不调整会出错。

## 0x60 模板代码

```
#include<bits/stdc++.h>
using namespace std;
const int N=100005;
int n,q,val[N];
int fa[N],ls[N],rs[N],vis[N],dis[N];

//并查集
int findd(int now){
	if(fa[now]==now)return now;
	return fa[now]=findd(fa[now]);
}
void vnion(int u,int v){
	u=findd(u);v=findd(v);
	if(u==v)return;
	fa[u]=v;
}

//核心：左偏树的合并
int merge(int x,int y){
	if(!x||!y)return x+y;
	if((val[x]==val[y]&&x>y)||val[x]>val[y])swap(x,y);
	rs[x]=merge(rs[x],y);
	if(dis[ls[x]]<dis[rs[x]])swap(ls[x],rs[x]);
	dis[x]=dis[rs[x]]+1;
	return x;
}
int main(){
	dis[0]=-1;
	scanf("%d%d",&n,&q);
	for(int i=1;i<=n;i++){
		scanf("%d",&val[i]);
		fa[i]=i;
	}
	for(int opt,u,v;q;--q){
		scanf("%d%d",&opt,&u);
		if(opt==1){
			scanf("%d",&v);
			if(vis[u]==-1||vis[v]==-1)continue;//先看 u 和 v 有没有被删除
			u=findd(u);v=findd(v);
			if(u!=v)fa[u]=fa[v]=merge(u,v);
		}
		else{
			if(vis[u]==-1){
				printf("-1\n");
				continue;
			}
			u=findd(u);
			printf("%d\n",val[u]);
			vis[u]=-1;// vis 指代节点有没有被删除。
			fa[ls[u]]=fa[rs[u]]=fa[u]=merge(ls[u],rs[u]);
		}
	}
}
```

## 0x70 例题选讲

### 0x71 P2713

几乎和模板一模一样，除了输入输出格式调一下。

### 0x72 P1456

主要问题出在合并上。设 $u$ 和 $v$ 为需要合并的最强的两只猴子。

我们先找到节点 $u$，然后合并它的左儿子和右儿子。然后将 $u$ 的权值砍半，接着把 $u$ 和左儿子和右儿子结合的左偏树合并。

然后我们对 $v$ 也是一样的操作。

最后把 $u$ 和 $v$ 的左偏树合并，总计 $5$ 次合并。

注意大根堆。

---

## 作者：zyn0309 (赞：1)

# 左偏树
## 算法简介
左偏树是一种支持将两个大小为 $n$ 的二叉堆在 $O(\log n)$ 的时间内合并的堆式数据结构。
## 算法讲解
### 二叉堆的合并
下文以小根堆为例。

对于两个二叉堆 $a$ 和 $b$，设 $a$ 为权值较小的结点，则可以将 $b$ 与 $a$ 的任意一个儿子合并，然后返回 $a$ 与 $b$ 合并后的根为 $a$，重复此过程直到 $a$ 或 $b$ 为空。

代码实现如下
```cpp
inline int merge(int a,int b){
	if(!a||!b)return a|b;
	if(t[a].val>t[b].val)swap(a,b);
	t[a].rson=merge(t[a].rson,b);
	return a;
}
```

观察上面的代码可以发现。如果一直往右儿子合并，单次合并的时间花费为两个堆向右的深度之和，因此可以考虑让每个堆向右的深度尽量小。

### 复杂度证明
定义 $ls_u$ 为结点 $u$ 的左儿子，$rs_u$ 为结点 $u$ 的右儿子，$dis_u$ 为 $u$ 所在的子树中离 $u$ 最近的空结点的距离。（若 $ls_u$ 或 $rs_u$ 为空，则 $dis_u$ 为 $1$）

定义左偏树为满足堆中每个结点都有 $dis_{ls} \ge dis_{rs}$ 的二叉堆。

容易发现左偏树有以下性质：

#### 性质一
$dis_u = dis_{rs} + 1$（因为 $dis_{ls} \ge dis_{rs}$）


#### 性质二
若以 $u$ 为结点的堆的大小为 $siz$，则 $dis_u$ 的大小为 $O(\log {siz})$。

证明：

根据 $dis_{ls} \ge dis_{rs}$，每次向右递归一层，所在结点的 $dis$ 都会减 $1$，且层数不超过所在结点的 $dis$ 的结点数至少减半，所以最多递归 $O(\log {siz})$ 层。


根据以上性质，类似于前文二叉堆合并的实现。在每次合并完后，如果 $dis_{ls} < dis_{rs}$ 就将 $ls$ 与 $rs$ 交换。根据性质二，合并大小为 $a$ 和 $b$ 的左偏树复杂度为 $O(\log {a}+\log {b})$。

代码实现：
```cpp
inline int merge(int a,int b){
	if(!a||!b){
	  if(a|b)t[a|b].dis=1;
	  return a|b;
	}
	if(t[a].val>t[b].val)swap(a,b);
	t[a].rson=merge(t[a].rson,b);
	if(t[t[a].lson].dis<t[t[a].rson].dis)swap(t[a].lson,t[a].rson);
	t[a].dis=t[t[a].rson].dis+1;
	return a;
}
```

## 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int n,m,fa[N],root[N];
bool del[N];
struct node{
	int lson,rson,dis;
	pair<int,int>val;
}t[N];
inline int find(int x){
	return (x==fa[x])?x:fa[x]=find(fa[x]);
}
inline int merge(int a,int b){
	if(!a||!b){
	  if(a|b)t[a|b].dis=1;
	  return a|b;
	}
	if(t[a].val>t[b].val)swap(a,b);
	t[a].rson=merge(t[a].rson,b);
	if(t[t[a].lson].dis<t[t[a].rson].dis)swap(t[a].lson,t[a].rson);
	t[a].dis=t[t[a].rson].dis+1;
	return a;
}
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;++i){
	  cin>>t[i].val.first;
	  fa[i]=root[i]=t[i].val.second=i;
	  t[i].dis=1;
	}
	int opt,x,y;
	for(int i=1;i<=m;++i){
	  cin>>opt;
	  if(opt==1){
	  	cin>>x>>y;
	  	if(del[x]||del[y]||find(x)==find(y))continue;
	  	root[find(y)]=merge(root[find(x)],root[find(y)]);
	  	fa[find(x)]=find(y);
	  }
	  else{
		cin>>x;
		if(del[x]){
		  cout<<"-1\n";
		  continue;
		}
		x=find(x);
		cout<<t[root[x]].val.first<<"\n";
		del[root[x]]=1;
		root[x]=merge(t[root[x]].lson,t[root[x]].rson);
	  }
	}
	return 0;
}
```

---

## 作者：H_Kaguya (赞：0)

这是一种基于归并的可并堆。  
优点是可以同时对最大值和最小值进行操作，而且内存非常连续。  
缺点是实现比较麻烦/常数比较大，且复杂度依赖均摊。  

前置知识：归并，启发式合并。  

---

现在我们尝试直接维护集合排序后的数组。  
合并两个大小分别为 $a, b$ 的数组可以直接归并，复杂度 $O(a + b)$。  

如果，很刚好，$a, b$ 同阶，那么我们就可以认为 $O(a+b) = O(\min(a, b))$，也即可以当成启发式合并来分析。  
如果 $a, b$ 相差较大复杂度无法接受，那么干脆就不合并，改为同时维护两个有序数组。  

具体来说，我们每个集合内维护若干有序数组。  
若两个数组的大小 $a, b$ 满足 $2a > b$ 或 $2b > a$，那么我们就对其进行归并。  
归并的总复杂度是不超过 $O(n \log n)$ 的。  
对于任意一个数组，其他数组的大小要么大于其两倍要么小于其一半，所以一个集合内最多只有 $O(\log n)$ 个数组。  
完成了，这就是一个可并堆了。  

不难发现如果不考虑删除的话这个就是二进制分组。  

---

原理可行，而且看上去很简单......？  

实际上实现起来可能没有那么方便。  
下面提供一种可能的实现。  

我们用 `vector` 套数组的方式来实现，数组用 `new` 关键字直接申请。  
对于每个集合，我们将其有序数组按照从小到大的顺序进行排序。  

我们先实现一个 `adjust` 函数来对集合内的有序数组进行归并。  
考虑按照从大到小的顺序依次取出这些数组，然后扔进栈里面。  
如果当前元素可以和栈顶归并，那就归并之后再扔进栈，重复此过程。  

考虑栈顶两个元素分别为 $a, b$，将要插入的元素为 $c$，我们有 $b > 2a, c \le b$。  
所以 $a, c$ 归并之后仍然有 $a + c \le 2a < b$，所以不会破坏有序的性质。  
最后把栈反着放回去就好了。  

有了 `adjust` 函数之后就方便多了。  
合并的话，对有序数组进行归并，然后 `adjust` 即可。  
删除的话，删完之后 `adjust` 一下即可。  

贴个代码。  


```cpp
#include <vector>
#include <stdio.h>
#include <algorithm>
using namespace std;
typedef long long ll;
const int sz = 100005;
const int bit = (1 << 23) - 1;
int n, m;
int lab[sz];
vector<ll*> emp;
bool cmp(const ll *a, const ll *b)
{
	return a[0] < b[0];
}
void putin(vector<ll*> &a, ll *b)
{
	while (a.size() && b[0] * 2 > a.back()[0])
	{
		ll *tmp = new ll[a.back()[0] + b[0] + 1];
		tmp[0] = a.back()[0] + b[0];
		std::merge(b + 1, b + b[0] + 1, a.back() + 1, a.back() + a.back()[0] + 1, tmp + 1, greater<ll>());
		delete[] b; b = tmp;
		delete[] a.back(); a.pop_back();
	}
	a.push_back(b);
}
struct node
{
	int siz;
	vector<ll*> val;

	void init(ll a)
	{
		siz = 1;
		val.push_back(new ll[2]);
		val[0][0] = 1; val[0][1] = a;
	}
	void lable(int a)
	{
		for (ll *i : val)
			for (int j = 1; j <= i[0]; ++j)
				lab[i[j] & bit] = a;
	}
	void adjust()
	{
		vector<ll*> ts;
		while (val.size())
		{
			putin(ts, val.back());
			val.pop_back();
		}
		while (ts.size())
		{
			val.push_back(ts.back());
			ts.pop_back();
		}
	}
	void merge(node &a)
	{
		vector<ll*> tmp; tmp.resize(val.size() + a.val.size());
		std::merge(val.begin(), val.end(), a.val.begin(), a.val.end(), tmp.begin(), cmp);
		a.val = emp; val = tmp;
		adjust(); siz += a.siz;
	}
	ll pop()
	{
		ll mn = 1e18;
		int pos;
		for (int i = 0; i < val.size(); ++i)
		{
			if (val[i][val[i][0]] < mn)
			{
				mn = val[i][val[i][0]];
				pos = i;
			}
		}
		--val[pos][0]; --siz;
		if (val[pos][0] == 0)
		{
			delete[] val[pos];
			for (int i = 1; i < val.size(); ++i)
				val[i - 1] = val[i];
			val.pop_back();
		}else
			adjust();
		lab[mn & bit] = 0;
		return mn >> 23;
	}
};
node heap[sz];
int read();
int main()
{
	int x, y;
	n = read(); m = read();
	for (int i = 1; i <= n; ++i)
	{
		heap[i].init((ll)read() << 23 | i);
		heap[i].lable(i);
	}
	while (m --> 0)
		if (read() == 1)
		{
			x = lab[read()]; y = lab[read()];
			if (x && y && x != y)
			{
				if (heap[x].siz < heap[y].siz)
					swap(x, y);
				heap[y].lable(x);
				heap[x].merge(heap[y]);
			}
		}else
		{
			x = read();
			if (lab[x])
				printf ("%lld\n", heap[lab[x]].pop());
			else
				puts("-1");
		}
	return 0;
}

```

实测用时 300ms 比左偏树慢很多，但是还是比启发式合并堆快一点的。

---

## 作者：Chenyichen0420 (赞：0)

## 思路分析

$10^5$ 的数据范围。如果我们跑最经典的 DSU 的话，那就是 $n\log^2n$ 的。这也是可并堆等最无脑的一种平替算法。

有多无脑呢？把小的合并到大的堆上。证明的话可以将整个过程倒着看，每一次操作的数的个数大小减半，抛开合并就是 $n\log n$ 的。

详讲一下：

比如说我们现在有 $n$ 堆不同的数据，总的大小是 $m$，假定每次合并是 $O(1)$，那这时候不难发现每次合并时最坏的复杂度是 $O(m)$ 的，总复杂度就是 $O(nm)$，显然不可接受。

于是我们考虑怎么去优化他。

如果你学过重链剖分的话，那么你会知道每一棵子树抛去它本身和重儿子，剩余部分的大小会至少减半。

那我们仔细想一下，如果我们合并的时候让元素更少的那一堆合并到元素更多的那一堆中，会发生什么呢？

小集合每一次合并之后规模翻倍。因此每一个元素最多只会进行 $\log m$ 次合并。这时候，其实复杂度已经被优化到了 $O(m\log m)$。

所以说，启发式合并就干了一件事：小的合并到大的里面去。而如果我们直接用这个套路去套可并堆的话，你会惊奇的发现其复杂度只有 $O(n\log^2n)$！多的 $\log$ 是堆的插入与删除的时间复杂度。

显然这个小技巧也可以用来优化很多其他的算法，比如线段树合并，并查集合并等等。

因为他足够的暴力，但却有较优秀的时间复杂度，因而可以成为一部分更高级的数据结构的平替。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, m, ps[100005];
struct node {
	int p, v;
	node(int pi = 0, int vi = 0) :p(pi), v(vi) {}
	friend bool operator<(const node& l, const node& r) {
		return l.v != r.v ? l.v > r.v : l.p > r.p;
	}
}; priority_queue<node>pq[100005];
inline void merge(int a, int b) {
	if (a == b || !a || !b) return;
	if (pq[a].size() < pq[b].size()) swap(a, b);
	while (pq[b].size())
		pq[a].emplace(pq[b].top()),
		ps[pq[b].top().p] = a, pq[b].pop();
}
int main() {
	ios::sync_with_stdio(0); cin >> n >> m;
	for (int i = 1, v; i <= n; ++i)
		cin >> v, ps[i] = i, pq[i].emplace(i, v);
	for (int i = 1, o, a, b; i <= m; ++i)
		if (cin >> o, o & 1) cin >> a >> b, merge(ps[a], ps[b]);
		else
			if (cin >> a, !pq[ps[a]].size()) cout << "-1\n";
			else {
				cout << pq[ps[a]].top().v << "\n"; int ta = ps[a]; 
				ps[pq[ta].top().p] = 0; pq[ta].pop();
			}
}
```

---


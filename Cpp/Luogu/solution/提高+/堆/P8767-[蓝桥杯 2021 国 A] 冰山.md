# [蓝桥杯 2021 国 A] 冰山

## 题目描述

一片海域上有一些冰山，第 $i$ 座冰山的体积为 $V_{i}$ 。

随着气温的变化，冰山的体积可能增大或缩小。第 $i$ 天, 每座冰山的变化量都是 $X_{i}$。当 $X_{i}>0$ 时，所有冰山体积增加 $X_{i}$；当 $X_{i}<0$ 时，所有冰山体积减少 $-X_{i}$；当 $X_{i}=0$ 时，所有冰山体积不变。

如果第 $i$ 天某座冰山的体积变化后小于等于 $0$，则冰山会永远消失。

冰山有大小限制 $k$。如果第 $i$ 天某座冰山 $j$ 的体积变化后 $V_{j}$ 大于 $k$，则它会分裂成一个体积为 $k$ 的冰山和 $V_{j}-k$ 座体积为 $1$ 的冰山。

第 $i$ 天结束前（冰山增大、缩小、消失、分裂完成后），会漂来一座体积为 $Y_{i}$ 的冰山（$Y_{i}=0$ 表示没有冰山漂来）。

小蓝在连续的 $m$ 天对这片海域进行了观察，并准确记录了冰山的变化。小蓝想知道, 每天结束时所有冰山的体积之和（包括新漂来的）是多少。

由于答案可能很大，请输出答案除以 $998244353$ 的余数。

## 说明/提示

**【样例说明】**

在本样例说明中, 用 $\left[a_{1}, a_{2}, \cdots, a_{n}\right]$ 来表示每座冰山的体积。

初始时的冰山为 [1]。

第 $1$ 天结束时，有 $3$ 座冰山： $[1,1,6]$ 。

第 $2$ 天结束时，有 $6$ 座冰山： $[1,1,2,3,3,6]$ 。

第 $3$ 天结束时，有 $5$ 座冰山： $[1,1,2,2,5]$ 。

**【评测用例规模与约定】**

对于 $40 \%$ 的评测用例, $n, m, k \leq 2000$;

对于 $60 \%$ 的评测用例, $n, m, k \leq 20000$;

对于所有评测用例, $1 \leq n, m \leq 10^5,1 \leq k \leq 10^{9}, 1 \leq V_{i} \leq k, 0 \leq Y_{i} \leq k$, $-k \leq X_{i} \leq k$ 。 

蓝桥杯 2021 国赛 A 组 G 题。

## 样例 #1

### 输入

```
1 3 6
1
6 1
2 2
-1 1```

### 输出

```
8
16
11```

# 题解

## 作者：Terrible (赞：12)

### 思路

我们尝试用堆解决这个问题。

由于处理的核心是冰山两头，于是有了一个大根堆和一个小根堆，由于两个堆需要统一删除某些值，所以我们只在堆内记录下标，在堆外记录具体数据以及它是否被删除了。

考虑每次的修改操作，修改值后不改变堆内结点的相对大小关系，不需要重构堆，但不可能每次修改所有的值，我们得想个办法规避一下。每次修改，只是整体发生了朝某个方向偏移，只需要将整体的偏移表示出来就行。

修改偏移之后还需要处理冰山消融和碎裂的情况，对着大根堆和小根堆的头部结点依次操作即可，注意到一个冰山可能产生 $10^9$ 个碎片，而多个冰山只有体积大小的区别，所以可以考虑同等体积的冰山打包处理。但是我们也不必把所有同等体积的冰山都放到一块处理，只需要把碎片们打包就行了，当然考虑到一个顶级冰山能反复碎裂，自然也要把顶级冰山也打包处理。一个顶级冰山可以碎出来 $10^9$ 个小块，这 $10^9$ 个小块还能在一天成长成顶级冰山，然后每个顶级冰山又都可以碎出来 $10^9$ 个小块，循环下去总的数量轻而易举地就可以超过 `__int128` 的范围，考虑对打包的数量也进行模处理，总的冰山数量也要进行模处理。

这样所有要点都考虑完了，开始实现吧！

![印象图](https://s3.bmp.ovh/imgs/2023/07/26/b9fcb4feddba1461.png)

### 用 STL 实现

众所周知 `std::priority_queue` 第三个模板参数可以塞一个结构体，这个结构体可以用来确定堆内各个结点的大小关系，但是具体如何操作呢？我们有时候用到小根堆可以把第三个模板参数换成 `std::greater`，我们打开库文件，可以看到它的实现：

```cpp
  template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      _GLIBCXX14_CONSTEXPR
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };
```

我们只需要仿照这个样子写一下就行了！

### 具体代码

不开 `long long` 见祖宗！模拟的部分不再多说了，如果有细节处搞不清楚可以看看下面代码：

```cpp
#include<queue>
#include<cstdio>
#include<vector>
const int N=400009,mod=998244353;
//根据下面的实现，数组大小是 n+3m，也就是 4e5 左右
long long val[N],cnt[N],_n;bool notexist[N];
//val 只允许添加不允许修改，_n 表示目前添加到的地方
//cnt 是每个 val 配套的数量，取模下的意义
//notexist 是判断是否被删除的核心依据
struct valgreater
{//STL 小根堆配套比较运算
	bool operator()(const int&i1,const int&i2)
	{return val[i1]>val[i2];}//根据下标比较对应的值
};
struct valless
{//STL 大根堆配套比较运算
	bool operator()(const int&i1,const int&i2)
	{return val[i1]<val[i2];}//根据下标比较对应的值
};
std::priority_queue<int,std::vector<int>,valless>    max_heap;//下标大根堆
std::priority_queue<int,std::vector<int>,valgreater> min_heap;//下标小根堆
int main()
{
	int n,m,k;scanf("%d%d%d",&n,&m,&k);
	//或许修改具体值比较难，不妨逆向修改标志这些值偏移量的标准，毕竟运动是相对的
	long long minval=0,maxval=k,total=0,num=0;
	//要求 minval<val<=maxval 否则会消融或分裂，val[i]-minval 才是原本的指标
	//total 记录冰山体积之和，num 记录冰山数量 
	for(int i=1;i<=n;i++)
	{
		scanf("%lld",&val[++_n]),num+=cnt[_n]=1;
		total=(total+val[_n])%mod;
		max_heap.push(_n),min_heap.push(_n);
	}
	while(m--)
	{
		int x,y;scanf("%d%d",&x,&y);
		minval-=x,maxval-=x;//修改标准，相对地看相当于修改了所有的数值
		if(x<0)//冰山减小
		{
			x=-x;
			while(!min_heap.empty())
			{
				int i=min_heap.top();
				if(notexist[i])/*什么也不做*/;
				else if(val[i]<=minval)//消融的标准水涨船高
				{
					notexist[i]=1;num=(num+mod-cnt[i])%mod;
					total=(total+mod-cnt[i]*(val[i]-minval+x)%mod)%mod;
				}
				else break;
				min_heap.pop();
			}
			total=(total+mod-num*x%mod)%mod;
		}
		else if(x>0)//冰山增大
		{
			long long ceiling=0,debris=0;
			//ceiling 顶级冰山数量，debris 生成碎片数量（模意义下）
			while(!max_heap.empty())
			{
				int i=max_heap.top();
				if(notexist[i])/*什么也不做*/;
				else if(val[i]>maxval)//分裂的标准下降了
				{
					notexist[i]=1;ceiling=(ceiling+cnt[i])%mod;
					debris=(debris+cnt[i]*(val[i]-maxval)%mod)%mod;
				}
				else break;
				max_heap.pop();
			}
			total=(total+num*x)%mod;
			if(ceiling)//如果有冰山裂开来，裂开新建两项打包处理
			{
				val[++_n]=maxval,cnt[_n]=ceiling;
				min_heap.push(_n),max_heap.push(_n);
				val[++_n]=minval+1,cnt[_n]=debris;
				min_heap.push(_n),max_heap.push(_n);
				num=(num+debris)%mod;
			}
		}
		if(y)
		{
			total=(total+y)%mod,num=(num+1)%mod;
			val[++_n]=y+minval,cnt[_n]=1;//需要根据现在的标准记录大小
			min_heap.push(_n),max_heap.push(_n);
		}
		printf("%lld\n",total);
	}
	return 0;
}
```

---

## 作者：quanjun (赞：10)

题目链接：[https://www.luogu.com.cn/problem/P8767](https://www.luogu.com.cn/problem/P8767)

鸣谢：这道题的顺利解决得到了 [7KByte](https://www.luogu.com.cn/user/119261) 大佬的大力帮助，在此再次表示感谢。

首先，我的想法是这样的：

使用一个 splay tree 来维护这些冰山的信息。

对于每次操作的 $x$ 和 $y$：
1. 先将所有节点的权值增加 $x$（这步操作只需要修改根节点的信息，然后进行一下懒惰标记即可，以后会 push_down 下去的）
2. 然后增加一个权值为 $y$ 的点（如果权值为 $y$ 的点本身就存在的话，就将其数量增加 $1$）
3. 先将权值 $\gt 0$ 且最小的节点 splay 为根节点，然后删除其左子树（因为此时根节点的左儿子的权值均 $\le 0$）
4. 再将权值 $\le k$ 且最大的节点 splay 为根节点，此时其右子树对应的节点都是权值 $\gt k$ 的，这些节点需要拆解为若干个权值为 $k$ 的节点和若干个权值为 $1$ 的节点，操作过程为：
    1. 首先需要为每一个节点维护两个信息：
        - sum 表示以该节点为根节点的子树中所有节点权值与数量的乘积之和，比如：如果该节点所在子树中有 $2$ 个权值为 $3$ 的点，$6$ 个权值为 $5$ 的点，则该节点的 sum 为 $2 \times 3 + 6 \times 5 = 36$
        - cnt 表示以该节点为根节点的自述中所有节点的数量，比如：如果该绩点所在子树中有 $2$ 个权值为 $3$ 的点，$6$ 个权值为 $5$ 的点，则该节点的 cnt 值为 $2 + 6 = 8$
    2. 然后，先计算出根节点的右儿子的 sum 值和 cnt 值，可以发现，这些节点中的每一个都会被分成 $1$ 个权值为 $k$ 的节点以及（剩余的）若干个权值为 $1$ 的节点，所以我们需要做的事情是：
        1. 删除根节点的右子树
        2. 插入 cnt 个权值为 $k$ 的节点
        3. 插入 `sum - cnt * k` 个权值为 $1$ 的节点

（注：这样讨论在下面的实现是还有一些细节没有处理，我们在下面的内容中讨论）  

具体实现时，首先由于我经常会用到变量小 `k`，所以我把题目描述中的 `k` 开成了大K（即 `K`）—— 即冰山的最大大小。  

然后我定义了一个结构体来维护 splay tree 里面的节点信息，如下：  
```c++
struct Node {
    int s[2], p;    // s[0] 左儿子 s[1] 右儿子 p 父节点
    long long v,    // 冰山体积
              num,  // 冰山个数
              cnt,  // 子树包含冰山个数
              sum,  // 子树包含冰山体积之和
              flag; // 懒惰标记

    Node() {};
    Node(long long _v, int _p) {v = _v; p = _p; s[0] = s[1] = 0; num = cnt = sum = flag = 0;}
} tr[maxn];
```
其中：  
- `s[0]` 和 `s[1]` 分别表示左儿子和右儿子节点的编号（如果没有则为 $0$）
- `v` 表示当前节点的权值（对应的就是冰山的体积）
- `num` 表示体积为 `v` 的冰山有多少个
- `cnt` 表示以当前节点为根节点的子树中包含的冰山的总数
- `sum` 表示以当前节点为根节点的子树中包含的冰山的总体积
- `flag` 是懒惰标记，它表示当前节点的所有子节点的体积需要整体增加的量

这里需要注明的是，我自己做懒惰标记的习惯是：修改当前节点信息的同时进行懒惰标记，然后将懒惰标记传给子节点的时候也会修改子节点的信息，因为写线段树的时候都是这么写的就习惯了。（因为有的大佬可能习惯是 pushdown 的时候更新当前节点，但是我已经习惯更新当前节点并进行懒惰标记，然后 pushdown 的时候一方面更新子节点，另一方面把懒惰标记传给子节点）  

然后因为具体实现是经常需要进行形如 `a = (a + b) % MOD;` 的操作，所以我添加了一个 `add` 函数方便写：  
```c++
void add(long long &a, long long b) {
    a = (a + b % MOD) % MOD;
}
```

然后就是比较重要的 push up 和 push down 操作了。

### push up
push_up 需要将子节点的信息更新到当前节点，只需要更新一下 cnt 和 sum

主要操作就是：  
```c++
tr[x].cnt = tr[x].num + tr[tr[x].s[0]].cnt + tr[tr[x].s[1]].cnt;
tr[x].sum = tr[x].num * tr[x].v + tr[tr[x].s[0]].sum + tr[tr[x].s[1]].sum;
```
需要取一下模。  

### push down
push_down 需要将当前节点的懒惰标记（flag，对应的是冰山体积的整体增量）传递给子节点并且同时更新子节点。对于一个节点来说，当传递了一个值为 `tmp` 的体积增量时：
- flag 会增加 tmp
- v 会增加 tmp
- sum 会增加 `cnt * tmp`（因为该节点的子树中所有节点对应的冰山体积都会增加 `tmp`）

主要操作是：  
```c++
void t_flag(int x, long long tmp) {
    if (x) {
        tr[x].flag += tmp;
        tr[x].v += tmp;
        add(tr[x].sum, tr[x].cnt * tmp);
    }
}

void push_down(int x) {
    if (tr[x].flag) {
        t_flag(tr[x].s[0], tr[x].flag);
        t_flag(tr[x].s[1], tr[x].flag);
        tr[x].flag = 0;
    }
}
```

### 旋转和 splay 操作
这部分的操作基本没有改动过，之前用它们解决过 AcWing 上的 splay 例题（原来的帖子：[https://www.acwing.com/file_system/file/content/whole/index/content/7428637/](https://www.acwing.com/file_system/file/content/whole/index/content/7428637/)）

对应的代码（多了一个 f_s(p, u, k) 函数用来认亲（u 是 p 的儿子，其中 k = 0 表示 u 是 p 的左儿子；k = 1 表示 u 是 p 的右儿子）：  
```c++
void f_s(int p, int u, bool k) {
    tr[p].s[k] = u;
    tr[u].p = p;
}

void rot(int x) {
    int y = tr[x].p, z = tr[y].p;
    bool k = tr[y].s[1] == x;
    f_s(z, x, tr[z].s[1]==y);
    f_s(y, tr[x].s[k^1], k);
    f_s(x, y, k^1);
    push_up(y), push_up(x);
}

void splay(int x, int k) {
    while (tr[x].p != k) {
        int y = tr[x].p, z = tr[y].p;
        if (z != k)
            (tr[y].s[1]==x) ^ (tr[z].s[1]==y) ? rot(x) : rot(y);
        rot(x);
    }
    if (!k) root = x;
}
```

### 插入操作
`ins(v, num)` 表示的是加入 `num` 个体积为 `v` 的冰山：  
```c++
void ins(long long v, long long num) {
    int u = root, p = 0;
    while (u && tr[u].v != v) {
        push_down(u);
        p = u, u = tr[u].s[v > tr[u].v];
    }
    if (!u) {
        tr[u = ++idx] = Node(v, p);
        if (p) tr[p].s[v > tr[p].v] = u;
    }
    else
        push_down(u);   // 如果不是新建的节点，需要push_down一下
    add(tr[u].num, num);
    add(tr[u].cnt, num);
    add(tr[u].sum, num * v);
    splay(u, 0);
}
```

### 调整

这里有一个 check 函数，主要用来判断当前节点对应的冰山体积是否合法：  

```c++
bool check(int u) {
    return tr[u].v > 0 && tr[u].v <= K;
}
```

然后就是 `get1()` 函数和 `get2()` 函数了。

**get1()** 函数对应的就是我上面说的第 3 步操作：  

> 3. 先将权值 $\gt 0$ 且最小的节点 splay 为根节点，然后删除其左子树（因为此时根节点的左儿子的权值均 $\le 0$）

**补充一点细节：** 如果循环结束时没有找到 $\gt 0$ 的节点（即下面代码中的 `x` 结束时仍然为 $0$），说明需要将整棵树删除。  

```c++
void get1() {
    int u = root, p = 0, x = 0;
    while (u) {
        push_down(u);
        p = u;
        if (tr[u].v > 0) {
            x = u;
            u = tr[u].s[0];
        }
        else u = tr[u].s[1];
    }
    if (x) {
        splay(x, 0);
        tr[x].s[0] = 0;
        push_up(x);
    }
    else tr[root = 0] = Node(0, 0);
}
```

**get2()** 函数对应的就是我上面说的第 4 步操作：  

> 4. 再将权值 $\le k$ 且最大的节点 splay 为根节点，此时其右子树对应的节点都是权值 $\gt k$ 的，这些节点需要拆解为若干个权值为 $k$ 的节点和若干个权值为 $1$ 的节点

**补充一点细节：** 如果循环结束时没有找到 $\gt 0$ 的节点（即下面代码中的 `x` 结束时仍然为 $0$），说明要么树是空的，要么所有节点都是 $\gt K$ 的，如果所有节点都是 $\gt K$ 的，应该处理整棵树，而不是根节点的右儿子。  

```c++
void get2() {
    int u = root, p = 0, x = 0;
    while (u) {
        push_down(u);
        p = u;
        if (tr[u].v <= K) {
            x = u;
            u = tr[u].s[1];
        }
        else u = tr[u].s[0];
    }
    int y;
    if (x) splay(x, 0), y = tr[x].s[1];
    else y = root;
    if (y) {
        long long cnt = tr[y].cnt, sum = tr[y].sum;
        if (y != root) tr[x].s[1] = 0;
        else tr[root = 0] = Node(0, 0);
        push_up(root);
        ins(K, cnt);
        ins(1, (sum - cnt * K % MOD + MOD) % MOD);
    }
}
```

完整代码如下：  
```c++
#include <bits/stdc++.h>
using namespace std;
const int maxn = 1e6 + 5;
const long long MOD = 998244353;

int n, m;
long long K;
struct Node {
    int s[2], p;    // s[0] 左儿子 s[1] 右儿子 p 父节点
    long long v,    // 冰山体积
              num,  // 冰山个数
              cnt,  // 子树包含冰山个数
              sum,  // 子树包含冰山体积之和
              flag; // 懒惰标记

    Node() {};
    Node(long long _v, int _p) {v = _v; p = _p; s[0] = s[1] = 0; num = cnt = sum = flag = 0;}
} tr[maxn];
int root, idx;

void add(long long &a, long long b) {
    a = (a + b % MOD) % MOD;
}

void push_up(int x) {
    tr[x].cnt = tr[x].num + tr[tr[x].s[0]].cnt + tr[tr[x].s[1]].cnt;
    tr[x].cnt %= MOD;
    tr[x].sum = tr[x].num * tr[x].v + tr[tr[x].s[0]].sum + tr[tr[x].s[1]].sum;
    tr[x].sum %= MOD;
    tr[x].sum = (tr[x].sum + MOD) % MOD;
}

void t_flag(int x, long long tmp) {
    if (x) {
        tr[x].flag += tmp;
        tr[x].v += tmp;
        add(tr[x].sum, tr[x].cnt * tmp);
    }
}

void push_down(int x) {
    if (tr[x].flag) {
        t_flag(tr[x].s[0], tr[x].flag);
        t_flag(tr[x].s[1], tr[x].flag);
        tr[x].flag = 0;
    }
}

void f_s(int p, int u, bool k) {
    if (p) tr[p].s[k] = u;
    tr[u].p = p;
}

void rot(int x) {
    int y = tr[x].p, z = tr[y].p;
    bool k = tr[y].s[1] == x;
    f_s(z, x, tr[z].s[1]==y);
    f_s(y, tr[x].s[k^1], k);
    f_s(x, y, k^1);
    push_up(y), push_up(x);
}

void splay(int x, int k) {
    while (tr[x].p != k) {
        int y = tr[x].p, z = tr[y].p;
        if (z != k)
            (tr[y].s[1]==x) ^ (tr[z].s[1]==y) ? rot(x) : rot(y);
        rot(x);
    }
    if (!k) root = x;
}

void ins(long long v, long long num) {
    int u = root, p = 0;
    while (u && tr[u].v != v) {
        push_down(u);
        p = u, u = tr[u].s[v > tr[u].v];
    }
    if (!u) {
        tr[u = ++idx] = Node(v, p);
        if (p) tr[p].s[v > tr[p].v] = u;
    }
    else
        push_down(u);   // 如果不是新建的节点，需要push_down一下
    add(tr[u].num, num);
    add(tr[u].cnt, num);
    add(tr[u].sum, num * v);
    splay(u, 0);
}

bool check(int u) {
    return tr[u].v > 0 && tr[u].v <= K;
}

void get1() {
    int u = root, p = 0, x = 0;
    while (u) {
        push_down(u);
        p = u;
        if (tr[u].v > 0) {
            x = u;
            u = tr[u].s[0];
        }
        else u = tr[u].s[1];
    }
    if (x) {
        splay(x, 0);
        tr[x].s[0] = 0;
        push_up(x);
    }
    else tr[root = 0] = Node(0, 0);
}

void get2() {
    int u = root, p = 0, x = 0;
    while (u) {
        push_down(u);
        p = u;
        if (tr[u].v <= K) {
            x = u;
            u = tr[u].s[1];
        }
        else u = tr[u].s[0];
    }
    int y;
    if (x) splay(x, 0), y = tr[x].s[1];
    else y = root;
    if (y) {
        long long cnt = tr[y].cnt, sum = tr[y].sum;
        if (y != root) tr[x].s[1] = 0;
        else tr[root = 0] = Node(0, 0);
        push_up(root);
        ins(K, cnt);
        ins(1, (sum - cnt * K % MOD + MOD) % MOD);
    }
}

int main() {
    scanf("%d%d%lld", &n, &m, &K);
    for (int i = 0; i < n; i++) {
        int v;
        scanf("%d", &v);
        ins(v, 1);
    }
    while (m--) {
        int x, y;
        scanf("%d%d", &x, &y);
        t_flag(root, x);
        ins(y, 1);
        get1();
        get2();
        printf("%lld\n", tr[root].sum);
    }
    return 0;
}
```


---

## 作者：meyi (赞：4)

首先相同体积的冰山可以看作是一座，额外记录一个数量即可。

然后考虑每次操作的本质，变化 $X_i$ 会导致一部分冰山消失或分裂，虽然这个过程可能会涉及 $O(n)$ 种体积的冰山，但是这些冰山不影响之后的操作，再考虑新形成的冰山，若消失则只增加 $Y_i$ 一种冰山，若分裂则增加 $1,Y_i,k$ 三种冰山，也即冰山状态数的增量是 $O(1)$ 的，势能分析可得维护这个过程的复杂度为 $O((n+m)\times \text{DS})$，其中 $\text{DS}$ 表示所用数据结构进行插入和删除操作的复杂度，笔者选用了 map，故时间复杂度为 $O((n+m)\log n)$。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
//#pragma GCC optimize("Ofast,no-stack-protector,unroll-loops")
#define ALL(v) v.begin(),v.end()
#define For(i,_) for(int i=0,i##end=_;i<i##end;++i) // [0,_)
#define FOR(i,_,__) for(int i=_,i##end=__;i<i##end;++i) // [_,__)
#define Rep(i,_) for(int i=(_)-1;i>=0;--i) // [0,_)
#define REP(i,_,__) for(int i=(__)-1,i##end=_;i>=i##end;--i) // [_,__)
typedef long long ll;
typedef unsigned long long ull;
#define V vector
#define pb push_back
#define pf push_front
#define qb pop_back
#define qf pop_front
#define eb emplace_back
typedef pair<int,int> pii;
typedef pair<ll,int> pli;
#define fi first
#define se second
const int dir[4][2]={{-1,0},{0,1},{1,0},{0,-1}},inf=0x3f3f3f3f,mod=998244353;
const ll infl=0x3f3f3f3f3f3f3f3fll;
template<class T>inline bool ckmin(T &x,const T &y){return x>y?x=y,1:0;}
template<class T>inline bool ckmax(T &x,const T &y){return x<y?x=y,1:0;}
int init=[](){return cin.tie(nullptr)->sync_with_stdio(false),0;}();
struct modint{
	int val;
	inline modint(int val_=0):val(val_){}
	inline modint &operator=(int val_){return val=val_,*this;}
	inline modint &operator+=(const modint &k){return val=val+k.val>=mod?val+k.val-mod:val+k.val,*this;}
	inline modint &operator-=(const modint &k){return val=val-k.val<0?val-k.val+mod:val-k.val,*this;}
    inline modint &operator*=(const modint &k){return val=1ll*val*k.val%mod,*this;}
    inline modint &operator^=(int k){
        modint ret=1,tmp=*this;
        for(;k;k>>=1,tmp*=tmp)if(k&1)ret*=tmp;
        return val=ret.val,*this;
    }
    inline modint &operator/=(modint k){return *this*=(k^=mod-2);}
    inline modint &operator+=(int k){return val=val+k>=mod?val+k-mod:val+k,*this;}
    inline modint &operator-=(int k){return val=val<k?val-k+mod:val-k,*this;}
    inline modint &operator*=(int k){return val=1ll*val*k%mod,*this;}
    inline modint &operator/=(int k){return *this*=((modint(k))^=mod-2);}
    template<class T>friend modint operator+(modint a,T b){return a+=b;}
    template<class T>friend modint operator-(modint a,T b){return a-=b;}
    template<class T>friend modint operator*(modint a,T b){return a*=b;}
    template<class T>friend modint operator/(modint a,T b){return a/=b;}
    friend modint operator^(modint a,int b){return a^=b;}
    friend bool operator==(modint a,int b){return a.val==b;}
    friend bool operator!=(modint a,int b){return a.val!=b;}
    inline bool operator!(){return !val;}
    inline modint operator-(){return val?mod-val:0;}
    inline modint operator++(int){modint tmp=*this;*this+=1;return tmp;}
    inline modint &operator++(){return *this+=1;}
    inline modint operator--(int){modint tmp=*this;*this-=1;return tmp;}
    inline modint &operator--(){return *this-=1;}
};
using mi=modint;
int main(){
	int t_case=1;
//	scanf("%d",&t_case);
	while(t_case--){
		int m,n,k;
		scanf("%d%d%d",&n,&m,&k);
		mi all=n,ans=0;
		map<ll,mi>cnt;
		while(n--){
			int v;
			scanf("%d",&v);
			++cnt[v],ans+=v;
		}
		ll sum=0;
		while(m--){
			int x,y;
			scanf("%d%d",&x,&y);
			if(x<0){
				while(cnt.size()&&cnt.begin()->fi+sum+x<1){
					all-=cnt.begin()->se;
					ans-=(cnt.begin()->fi+sum)%mod*cnt.begin()->se,cnt.erase(cnt.begin());
				}
				ans+=all*(mod+x),sum+=x;
			}
			if(x>0){
				mi cnt1=0,cntk=0;
				while(cnt.size()&&cnt.rbegin()->fi+sum+x>k){
					cnt1+=(cnt.rbegin()->fi+sum+x-k)%mod*cnt.rbegin()->se,cntk+=cnt.rbegin()->se;
					all-=cnt.rbegin()->se;
					ans-=(cnt.rbegin()->fi+sum)%mod*cnt.rbegin()->se,cnt.erase(prev(cnt.end()));
				}
				ans+=all*x,sum+=x;
				cnt[1-sum]+=cnt1,all+=cnt1,ans+=cnt1;
				cnt[k-sum]+=cntk,all+=cntk,ans+=k*cntk;
			}
			if(y)++cnt[y-sum],++all,ans+=y;
			printf("%d\n",ans);
		}
	}
	return 0;
}
```

---

## 作者：Na2PtCl6 (赞：2)

首先，整体加这种东西用一个 `tag` 变量就可以维护了，用不着什么区间修改。然后就用 `multiset` 维护每一个冰山的体积。冰山消失的话暴力删就可以了；冰山分裂产生的大量冰山让我们想到要用一个二元组 $(V,c)$ 来表示一种体积的冰山有 $c$ 个，这样复杂度才有保障。我们可以在删冰山和加冰山的时候顺便维护冰山总体积，于是这个题算法的部分就说完了。

最后就是一大堆细节：

- 删冰山的时候删掉的体积是 `i.V+tag-x`（调试耗时 30 分钟）

- 如果这一天冰山体积不变，那么要特判这种情况（调了一晚上也没调出来）

如果你不想写那么多细节也没关系，因为暴力就能过。。。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=998244353;
int n,m,k,a,v,x,cur,cnt,tag; 
multiset< pair<int,int> > s;

signed main(){
	scanf("%lld %lld %lld",&n,&m,&k);
	for(int i=1;i<=n;i++){
		scanf("%lld",&a);
		cur+=a;
		s.insert(make_pair(a,1));
		++cnt;
	}
	while(m--){
		scanf("%lld %lld",&x,&v);
		tag+=x;
		if(x<0&&s.size()){
			int tot=0;
			while((*s.begin()).first+tag<=0){
				auto it=*s.begin();
				tot=(tot+((it.first+tag-x+mod*2)%mod)*it.second%mod)%mod;
				cnt=(cnt-it.second+mod*2)%mod;
				s.erase(s.begin());
				if(!s.size())
					break;
			}
			cur=(cur+cnt*x%mod-tot+mod*2)%mod;
		}
		if(x>0&&s.size()){
			cur=(cur+cnt*x)%mod;
			int cntdel=0,tot1=0,tot2=0;
			auto it=s.end();--it;
			while((*it).first+tag>k){
				tot1=(tot1+(*it).second)%mod;
				tot2=(tot2+(*it).second*((*it).first+tag-k+mod*2)%mod)%mod;
				s.erase(it);
				++cntdel;
				if(!s.size())
					break;
				it=s.end();
				it--;
			}
			if(cntdel){
				s.insert(make_pair(1-tag,tot2));
				s.insert(make_pair(k-tag,tot1));
			}
			cnt=(cnt+tot2)%mod;
		}	
		if(v){
		    cur=(cur+v)%mod;
			s.insert(make_pair(v-tag,1));
			++cnt;
		}
	}
	return 0;
}
```

---

## 作者：QinYulang (赞：1)

# 思路
一道非常纯的 `STL` 题，老师说只要会势能分析，且分析对敢暴力就能过。

那我们就来分析一下，不难得出初始种类，包括新增的，最多 $O(n + m)$ 种冰山。

好，再来分析一下每次操作:

- **$x > 0$**: 
 
 1.不分裂的冰山，显然可以用一个增量 `add` 来维护。
 
 2.分裂的冰山，最多只会增加两类冰山，也就是说，冰山的增量是 $O(1)$ 的。

-  **$x < 0$**: 

 1.不消失的冰山，依然 `add` 维护。

 2.消失的冰山，种类永久消失。
 
显然可得出正解了，这里我用的是 `map`。

# 代码
```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <climits>
#include <cctype>
#include <cstring>
#include <string>
#include <vector>
#include <queue>
#include <stack>
#include <map>
#include <set>
#include <cmath>
#include <unordered_map>
#include <random>
#include <ctime>

#define LOCAL
#define int long long
namespace ly{
    namespace IO{
        #ifndef LOCAL
            constexpr auto maxn = 1 << 20;
            char in[maxn], out[maxn], *p1 = in, *p2 = in, *p3 = out;
            #define getchar() (p1 == p2 && (p2 = (p1 = in) + fread(in, 1, maxn, stdin), p1 == p2) ? EOF : *p1++)
            #define flush() (fwrite(out, 1, p3 - out, stdout))
            #define putchar(x) (p3 == out + maxn && (flush(), p3 = out), *p3++ = (x))
            class Flush{public: ~Flush(){flush();}}_;
        #endif
        namespace usr{
            template <typename type>
            inline type read(type &x){x = 0; bool flag(0); char ch = getchar(); while(!isdigit(ch)) flag ^= ch == '-', ch = getchar(); while(isdigit(ch)) x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar(); return flag ? x = -x : x;}
            template <typename type>
            inline void write(type x){x < 0 ? x = -x, putchar('-') : 0; static short Stack[50], top(0); do Stack[++top] = x % 10, x /= 10; while(x); while(top) putchar(Stack[top--] | 48);}
            inline char read(char &x){do x = getchar(); while(isspace(x)); return x;}
            inline char write(const char &x){return putchar(x);}
            inline void read(char *x){static char ch; read(ch); do *(x++) = ch; while(!isspace(ch = getchar()) && ~ch);}
            template <typename type> inline void write(type *x){while(*x) putchar(*(x++));}
            inline void read(std::string &x){static char ch; read(ch), x.clear(); do x += ch; while(!isspace(ch = getchar()) && ~ch);}
            inline void write(const std::string &x){for(int i = 0, len = x.length(); i < len; ++i)putchar(x[i]);}
            template <typename type, typename...T> inline void read(type &x, T&...y){read(x), read(y...);}
            template <typename type, typename...T>
            inline void write(const type &x, const T&...y){write(x), putchar(' '), write(y...), sizeof...(y) ^ 1 ? 0 : putchar('\n');}
            template <typename type>
            inline void put(const type &x, bool flag = 0){write(x), flag ? putchar('\n') : putchar(' ');}
        }
        #ifndef LOCAL
            #undef getchar
            #undef flush
            #undef putchar
        #endif
    } using namespace IO::usr;
} using namespace ly::IO::usr;

constexpr int mod = 998244353;
int n, q, k;
int ans = 0;
std::map <int, int> cnt;
signed main(){
    read(n, q, k);
    for(int i = 1, x; i <= n; ++i) read(x), cnt[x]++, ans = (ans + x) % mod;
    int all = n, add = 0;
    while(q--){
        int x, y;
        read(x, y);
        if(x < 0){
            while(cnt.size() && cnt.begin() -> first + add + x <= 0){
                all = (all - cnt.begin() -> second + mod) % mod;
                ans = (ans - (cnt.begin() -> first + add) % mod * cnt.begin() -> second % mod + mod) % mod;
                cnt.erase(cnt.begin());
            }
            ans = (ans + all * (x + mod) % mod) % mod;
            add += x;
        } else if(x > 0){
            int cnt1 = 0, cntk = 0;
            while(cnt.size() && cnt.rbegin() -> first + add + x > k){
                cnt1 = (cnt1 + (cnt.rbegin() -> first + add + x - k) % mod * cnt.rbegin() -> second % mod) % mod;
                cntk = (cntk + cnt.rbegin() -> second) % mod;
                all = (all - cnt.rbegin() -> second + mod) % mod;
                ans = (ans - (cnt.rbegin() -> first + add) % mod * cnt.rbegin() -> second % mod + mod) % mod;
                cnt.erase(prev(cnt.end()));
            }
            ans = (ans + all * (x + mod) % mod) % mod;
            add += x;
            all = (all + cnt1) % mod;
            all = (all + cntk) % mod;
            cnt[1 - add] = (cnt[1 - add] + cnt1) % mod;
            cnt[k - add] = (cnt[k - add] + cntk) % mod;
            ans = (ans + cnt1) % mod;
            ans = (ans + k * cntk % mod) % mod;
        }
        if(y){
            cnt[y - add] = (cnt[y - add] + 1) % mod;
            all = (all + 1) % mod;
            ans = (ans + y) % mod;
        }
        put(ans, 1);
    }
    return 0;
}
```

---


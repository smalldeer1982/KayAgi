# [COCI 2016/2017 #1] Cezar

## 题目描述

Mirko 想对 $n$ 个单词进行加密。加密过程是这样的：

1.  选择一个英文字母表的排列作为密钥。
2.  将单词中的 `a` 替换为密钥中的第一个字母，`b` 替换为密钥中的第二个字母……以此类推。

例如，以 `qwertyuiopasdfghjklzxcvbnm` 作为密钥对 `cezar` 加密后，将得到 `etmqk`。

他希望，将所有单词加密并按字典序升序排列后，最初的第 $a_i$ 个单词位于第 $i$ 位。请你判断，这能否实现。如果能，请给出任意一种可行的密钥。

## 说明/提示

#### 【样例解释】

**样例 1 解释**

以 `bacdefghijklmnopqrstuvwxyz` 为密钥加密后，得到：

- `ba`
- `ac`

字典序升序排列后，得到：

- `ac`
- `ba`

原先的第一个单词在第二位，第二个单词在第一位。符合要求。

**样例 3 解释**

以 `adbcefghijklmnopqrstuvwxyz`  为密钥加密后，得到：

- `ddd`
- `bbb`
- `ccc`

字典序升序排列后，得到：

- `bbb`
- `ddd`
- `ccc`

原先的第一个单词在第二位，第二个单词在第三位，第三个单词在第一位。符合要求。

---

#### 数据规模与约定

对于 $100\%$ 的数据，$2\le n\le 100$，$1 \leq a_i \leq n$。

所有单词的长度不超过 $100$，且只包含小写字母。

------------

#### 说明

**题目译自 [COCI2016-2017](https://hsin.hr/coci/archive/2016_2017/) [CONTEST #1](https://hsin.hr/coci/archive/2016_2017/contest1_tasks.pdf) _T3 Cezar_**。

## 样例 #1

### 输入

```
2
ab
bc
2 1 ```

### 输出

```
DA
bacdefghijklmnopqrstuvwxyz ```

## 样例 #2

### 输入

```
3
abc
bcd
add
1 2 3 ```

### 输出

```
NE ```

## 样例 #3

### 输入

```
3
bbb
ccc
ddd
2 3 1 ```

### 输出

```
DA
adbcefghijklmnopqrstuvwxyz ```

# 题解

## 作者：Eleven谦 (赞：8)

[My Blogs](https://www.cnblogs.com/Eleven-Qian-Shan/p/13675316.html)

如果图崩了或者小了，可以上面链接看，效果更佳qwq~

------------
#### 题意

这题首先需要读懂题：给出的序列 $A_i$ 代表第 $i$ 个字符串排名为 $A_i$

拿样例1来说，就是：第二个字符串 "$bc$" 排名为1，第一个字符串 "$ab$" 排名为2（说明 "$bc$" 这个字符串的字典序比 "$ab$" 小）

~~（好像很多人都理解错了）~~


------------
#### 思路

这题，一眼**拓扑**（或者**变种 $Floyd$**)

- 转换

首先，根据序列 $A_i$ 我们可以进行**字符之间的连边**——**确定字典序大小关系**（排在前面的连向排在后面的）

然后我们就将字符串间的关系转化为有向图，那么接下来就是赤裸裸的拓扑了啊！

- 拓扑

这里会遇到第一个无解（即 "$NE$"）的情况：跑拓扑的时候，一开始队列就为空（说明不存在入度为0的点，则形成了环）

判了上面这种情况，接下来就是拓扑板子。用 $ans$ 和 $ans2$ 记录拓扑序，用 $viss$ 标记这个点被找到过

接下来，我们将 $ans$ 从小到大排序，再将 $ans$ 和 $ans2$ 一一对应存入 $anss$ 中（最终输出的数组）。我们根据下面的图来理解为什么排序后直接对应即可：

![](https://cdn.luogu.com.cn/upload/image_hosting/1gxpj4kw.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

应该可以理解吧？如果不是很清楚的话，可以把样例1、3都画一下

对应的代码段就是：
```cpp
sort(ans+1,ans+1+sum);
for(int i=1;i<=sum;i++) {
     anss[ans2[i]]=ans[i];
}
for(int i=0;i<=25;i++) {
     if(vis[i]&&!viss[i]) {
        puts("NE");
        return 0;
     }
    if(!viss[i]) anss[i]=i;
}
```

- 无解

因为这题是SPJ，所以当跑拓扑序的时候可以一次多点入队

然后就是比较极端的两组数据（还是比较考细节吧）：

```
5
c
cc
ccc
cccc
ccccc
1 2 3 4 5

out:
DA
abcdefgihjklmnopqrstuvwxyz

```

```
5
d
dd
ddd
dddd
ddddd
1 2 3 5 4

out:
NE
```

发现区别了吗？

第一组数据是因为所有字符串都是相同的一个字符，且排名在前的字符串的长度永远不大于排名在后的字符串

而第二组数据就是这里出锅，所以是 "$NE$" （排名第四的字符串长度大于排名第五的字符串）

那么我们就可以在跑拓扑之前特判一下这两种情况：

设 $cnt$ 记录有多少个不同的字符

1. 若 $cnt==1$，且 $len[i]>len[j](i<j)$，则是上面第二组数据的情况，输出无解

2. 连完边后，再判断若 $cnt==1$ ，则是上面第一组数据的情况，直接输出有解然后结束程序即可


还有一种无解的情况就是：若跑完拓扑序后发现，原本是有大小关系的字符而没有在拓扑序中出现，那么也是无解，即：

```
for(int i=0;i<=25;i++) {
     if(vis[i]&&!viss[i]) {  //vis标记在大小关系比较中出现过的点
        puts("NE");
        return 0;
     }
     if(!viss[i]) anss[i]=i;
}

```

------------
#### 代码

嗯，思路和需要注意的细节就是上面讲的这么多了，接下来直接看代码吧：

```cpp
#include <bits/stdc++.h>
using namespace std;
string s[1001];
int sum,vis[1001],viss[1001],ans[20010],ans2[20010];
int n,tot,cnt,a[1001],in[1001],head[200010],anss[20010];

struct node {
	int to,net;
} e[200010];

void add(int u,int v) {
	e[++tot].to=v;
	e[tot].net=head[u];
	head[u]=tot;
}

int topo() {
	queue<int> q;
	for(int i=0;i<=25;i++) {
		if(!in[i]&&vis[i]) q.push(i);
	}
	if(!q.size()) return -1;
	while(!q.empty()) {
		bool flag=false;
		int x=q.front();
		q.pop();
		if(viss[x]) return -1;
		viss[x]=1;
		ans[++sum]=x;
		ans2[sum]=x;
		for(int i=head[x];i;i=e[i].net) {
			int v=e[i].to;
			if(--in[v]==0) {
				flag=true;
				q.push(v);
			}
		}
	}
	return sum;
}


int main() {
	scanf("%d",&n);
	for(int i=1;i<=n;i++) {
		cin>>s[i];
	}
	for(int i=1;i<=n;i++) {
		scanf("%d",&a[i]);
	}
	for(int i=1;i<n;i++) {
		int k=0,kk=0;
		while(k<s[a[i]].size()&&kk<s[a[i+1]].size()) {
			if(s[a[i]][k]!=s[a[i+1]][kk]) {
				add(s[a[i]][k]-'a',s[a[i+1]][kk]-'a');	
				if(!vis[s[a[i]][k]-'a']) cnt++,vis[s[a[i]][k]-'a']=1;
				if(!vis[s[a[i+1]][kk]-'a']) cnt++,vis[s[a[i+1]][kk]-'a']=1;
				in[s[a[i+1]][kk]-'a']++;
				break;
			}
			k++;kk++;
		}
		if(cnt==0&&s[a[i]].size()>s[a[i+1]].size()) {
			puts("NE");
			return 0;
		}
	}
	if(cnt==0) {
		puts("DA");
		for(int i=0;i<=25;i++) cout<<char(i+'a');
		return 0;
	}
	int t=topo();
	if(t==-1) {
		puts("NE");
		return 0;
	}
	sort(ans+1,ans+1+sum);
	for(int i=1;i<=sum;i++) {
		anss[ans2[i]]=ans[i];
	}
	for(int i=0;i<=25;i++) {
		if(vis[i]&&!viss[i]) {
			puts("NE");
			return 0;
		}
		if(!viss[i]) anss[i]=i;
	}
	puts("DA");
	for(int i=0;i<=25;i++) {
		cout<<char(anss[i]+'a');
	}
	return 0;
}
```

------------





---

## 作者：Cry_For_theMoon (赞：6)

[传送门](https://www.luogu.com.cn/problem/P6286)

看到字典序我第一眼以为是[这个](https://www.luogu.com.cn/problem/P3065)题的双倍exp，结果淦了半天发现好像trie上dfs不太可做。结果瞎推半天推出一个 $O(n\sum size_i\,+\,n^2\,\log_2\sum size_i)$ 的解法。最后发现这题根本不需要trie，排个序连边拓扑一通乱搞就可以 $O(n^2\sum size_i)$ 了。 但是我人傻常数大被暴力解法吊打。/kel

不说废话了，考虑有关系字符串 $A>B$，当 $A$ 是 $B$ 的前缀时，在任何顺序下都成立，当 $B$ 是 $A$ 的前缀时，在任何顺序下都不成立。这个根据字典序的定义显然。

那么若 $A,B$ 没有一个是另一个前缀，设它们的最长公共前缀长度是 $A[1..S]$ （下标从1开始方便理解）。那么 $A[S+1] > B[S+1]$ 。而 **字典树上两个单词的最长公共前缀结尾对应两个单词节点的最近公共祖先**，但是问题来了，我们修改关系的是 $S+1$ ，不是 $S$ 也不是 $S-1$。但是忘了lca的倍增板子吗？不是因为我们不知道距离，所以从大往小爬的时候，最后爬到的 $x,y$ 还要再爬1层就是最后要的lca。而这里我们最后爬到的 $x,y$ 就是 $A[S+1] ,B[S+1]$ ! 换言之。你只需要再最后return fa[x][0] 这一句之前让 $type[x] > type[y] $ 被标记就行了（$type[u]$ 是节点 $u$ 对应的字母）。

确实理论上trie的字母在边上不在点上。但是这是可以相互转化的。平常做字符串时我们通常认为字母在点上，如果是像2020省选的树那种trie合并，则字母在边上比较好做。

那么 $n^2$ 枚举字符串，每次 $\log_2\sum size_i$ 求 lca，最后拓扑就可以判断有没有解。至于构造答案，拓扑序第一个字母变成a，第二个变成b，...，以此类推输出即可。

```cpp
//COCI2016,T3
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
#include<queue>
#include<cmath>
#define next CRY_FOR_THEMOON
using namespace std;
const int MAXN=110;
char words[MAXN][MAXN];
int n,a[MAXN],edge[30][30],inv[30],topo[30],tot;
queue<int>q;
int pos[MAXN],fa[MAXN*MAXN][20],power[20],depth[MAXN*MAXN];
char ans[30];
struct Trie{
	int sz,next[MAXN*MAXN][26],type[MAXN*MAXN];
	vector<int>son[MAXN*MAXN]; 
	inline int idx(char c){return c-'a';}
	inline int mknode(int c){
		type[++sz] = c;
		return sz;
	}
	inline void insert_str(char* s,int v){
		int u = 0,len = strlen(s);
		for(int i=0;i<len;i++){
			int c = idx(s[i]);
			if(!next[u][c])next[u][c] = mknode(c);
			u=next[u][c];
		}
		pos[v] = u;
	}
	inline void dfs(int u,int f){
		fa[u][0] = f;
		depth[u] = depth[f]+1;
		for(int idx=1;power[idx]<=depth[u];idx++){
			fa[u][idx] = fa[fa[u][idx-1]][idx-1];
		}
		for(int i=0;i<26;i++){
			if(next[u][i]){
				dfs(next[u][i],u);
			}
		}
	}
	inline int lca(int x,int y){
		int flag = (depth[x] >= depth[y]);
		if(depth[x] < depth[y])swap(x,y);
		int len = log(depth[x]-depth[y])/log(2);
		for(int idx=len;idx>=0;idx--){
			if(depth[x]-power[idx]>=depth[y]){
				x=fa[x][idx];
			}
		}
		if(x==y)return x;
		int ans = 0;
		len = log(depth[x]-1) / log(2);
		for(int idx=len;idx>=0;idx--){
			if(fa[x][idx] != fa[y][idx]){
				x = fa[x][idx];y = fa[y][idx];
			}
		}
		//此时的type[x]和type[y]有大小关系
		if(!flag)swap(x,y);
		//x>y
		if(!edge[type[x]][type[y]]){
			edge[type[x]][type[y]]=1;
			inv[type[y]]++;
		}
		return fa[x][0]; 
	}
}trie;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%s",&words[i]);
		trie.insert_str(words[i],i);
	}
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	power[0] = 1;
	for(int i=1;i<20;i++){
		power[i] = power[i-1] << 1;
	}
	trie.dfs(0,0);
	for(int i=1;i<n;i++){
		for(int j=i+1;j<=n;j++){
			int x = pos[a[i]],y = pos[a[j]];
			//x要在y前
			//如果y是x的前缀，不论怎么修改都不合法
			int f = trie.lca(x,y);
			if(f==y){
				printf("NE");return 0;
			} 
			//如果x是y的前缀，无论怎么修改都合法
			if(f==x)continue; 
		}
	}
	//拓扑后看是否有环
	for(int i=0;i<26;i++){
		if(!inv[i]){
			topo[++tot] = i;
			q.push(i);
		}
	} 
	while(!q.empty()){
		int u = q.front();q.pop();
		for(int v=0;v<26;v++){
			if(edge[u][v]){
				inv[v]--;
				if(!inv[v]){
					q.push(v);
					topo[++tot] = v;
				}
			}
		}
	} 
	for(int i=0;i<26;i++){
		if(inv[i]){printf("NE");return 0;}
	}
	printf("DA\n");
	//按照拓扑序构造
	for(int i=1;i<=26;i++){
		ans[topo[i]] = 'a'+i-1;
	} 
	for(int i=0;i<26;i++){
		printf("%c",ans[i]);
	}
	return 0;
}
```


---

## 作者：ModestCoder_ (赞：4)

一开始看错了题意，错以为是每个字符串里面加密后排序，
后来才发现是字符串之间排序

那么对于两个字符串$s_{a_i},s_{a_{i+1}}$，加密后的$s_{a_i}$的字典序要小于$s_{a_{i+1}}$

可以从最高位开始比较，第一位不同的字符，比如是$c1,c2$，说明加密后的$c1<c2$，就从$c1$往$c2$连一条有向边

最终做一遍拓扑构造答案

如果有点的入度不为0，说明有环，是无解的

否则就输出构造的方案

中间我还判断了一下如果相邻的两个字符串只有长度不一样无解的情况

这道题目非常暴力，复杂度$O(n)$

Code：

```cpp
#include <bits/stdc++.h>
#define maxn 1010
using namespace std;
struct Edge{
	int to, next;
}edge[maxn * maxn];
int num, head[maxn], f[maxn], n, d[maxn], a[maxn], s[maxn][maxn], cnt[maxn];
char ans[maxn], S[maxn];
char st[maxn][maxn];
queue <int> q;

inline int read(){
	int s = 0, w = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') w = -1;
	for (; isdigit(c); c = getchar()) s = (s << 1) + (s << 3) + (c ^ 48);
	return s * w;
}

int get(){
	char c = getchar();
	for (; c < 'a' || c > 'z'; c = getchar());
	return c - 'a' + 1;
}

bool check(int x, int y){
	if (x == y) return 1;
	for (int i = head[x]; i; i = edge[i].next) return check(edge[i].to, y);
}

int getfa(int k){ return k == f[k] ? k : f[k] = getfa(f[k]); }
void addedge(int x, int y){ edge[++num] = (Edge){y, head[x]}, head[x] = num; }

int main(){
	freopen("cezar.in", "r", stdin);
	freopen("cezar.out", "w", stdout);
	n = read();
	for (int i = 1; i <= n; ++i){
		scanf("%s", st[i] + 1);
		cnt[i] = strlen(st[i] + 1);
		for (int j = 1; j <= cnt[i]; ++j) s[i][j] = st[i][j] - 'a' + 1;
	}
	for (int i = 1; i <= n; ++i) a[i] = read();
	for (int i = 1; i <= 26 * 2; ++i) f[i] = i;
	for (int i = 1; i < n; ++i){
		int idx = a[i], idy = a[i + 1];
		int l1 = cnt[idx], l2 = cnt[idy];
		int x = 0, y = 0;
		for (int j = 1; j <= min(l1, l2); ++j)
			if (s[idx][j] != s[idy][j]){
				x = s[idx][j], y = s[idy][j];
				break;
			}
		if (x == 0 && y == 0){
			if (l1 > l2){ 
				puts("NE");
				return 0;
			}
			continue;
		}
		addedge(x, y), ++d[y];
	}
	for (int i = 1; i <= 26; ++i)
		if (!d[i]) q.push(i);
	char c = 'a';
	while (!q.empty()){
		int u = q.front(); q.pop();
		ans[u] = c, ++c;
		for (int i = head[u]; i; i = edge[i].next){
			int v = edge[i].to;
			--d[v];
			if (!d[v]) q.push(v);
		}
	}
	for (int i = 1; i <= 26; ++i)
		if (d[i]) return puts("NE"), 0;
	puts("DA");
	for (int i = 1; i <= 26; ++i) printf("%c", ans[i]);
	return 0;
}
```


---

## 作者：BIG_CUTE_BUG (赞：3)

[题传](https://www.luogu.com.cn/problem/P6286)

典中典之拓扑排序。

难点就在把题目和拓扑联系在一起吧。

## 思路
看题目发现最后要得出一个合法的字母顺序。发现题目给输入，实际是不同字母间的约束条件（某在某前面），所以想到求拓扑序。

然后考虑如何建边。显然，对某个字符串 $s_i$，它会与每个在自己题目所给序后面的字符串 $s_j$，产生一条约束关系。

又字典序是由两个串第一个不同的字母决定，所以需使，$s_i$ 中第一个和 $s_j$ 不同的字母，相较于其在 $s_j$ 中对应位置的字母，字典序更小。那么对这两个字母建边，最后求出的拓扑序就是答案排列需满足的顺序。

另外，如果 $s_j$ 不是 $s_i$ 的前缀，那就是题目的矛盾情况，此时直接输出无解。

具体做法则是用 $i$ 从 $1$ 到 $n-1$，$j$ 从 $i+1$ 到 $n$ 扫一遍，然后对 $s_i$ 和 $s_j$ 用同一指针扫，直到一对不同的字母，加边。

如果这个指针遍历完了都没找到一对不同的字母，说明其中某个是某个的前缀，此时就可以特判是否无解。

此外就是十分板的拓扑排序。

还有些细节处理：

* 对没有出现的字母，进行了入度为 $-1$ 的处理。

* 拓扑中用一个 `vector` 来存拓扑序。

* 如果拓扑结束后，还有字母的入度大于 $0$，说明存在环，输出无解。

* 最后输出答案时，用了个 `cnt` 来给每个字母编号。

详见代码。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N= 1e2+ 50;
int n, ord[N], in[N];
char ans[N], wrd[N][N];
vector< int> e[N], s;
void add(int x, int y)
{
	for(int i= 1; i<= min(strlen(wrd[x]+ 1), strlen(wrd[y]+ 1)); i++)
		if(wrd[x][i]!= wrd[y][i])
		{
			e[wrd[x][i]].push_back(wrd[y][i]);
			if(in[wrd[x][i]]== -1) in[wrd[x][i]]= 0;
			if(in[wrd[y][i]]== -1) in[wrd[y][i]]= 1;
			else in[wrd[y][i]]++;
			return;
		}
	if(strlen(wrd[x]+ 1)> strlen(wrd[y]+ 1)) puts("NE"), exit(0);
}
void topo()
{
	queue< int> q;
	for(int i= 'a'; i<= 'z'; i++) if(!in[i]) q.push(i);
	while(!q.empty())
	{
		int u= q.front();
		q.pop(); s.push_back(u);
		for(auto v : e[u])
			if(!(--in[v])) q.push(v);
	}
}
signed main()
{
	scanf("%d", &n);
	for(int i= 'a'; i<= 'z'; i++) in[i]= -1;
	for(int i= 1; i<= n; i++) cin>> (wrd[i]+ 1);
	for(int i= 1; i<= n; i++) scanf("%d", &ord[i]);
	for(int i= 1; i< n; i++)
		for(int o= i+ 1; o<= n; o++)
			add(ord[i], ord[o]);
	topo();
	for(int i= 'a'; i<= 'z'; i++) if(in[i]> 0) return puts("NE"), 0; puts("DA");
	int cnt= 0;
	for(auto i : s) ans[i]= 'a'+ cnt++;
	for(int i= 'a'; i<= 'z'; i++)
	{
		if(!ans[i]) printf("%c", (char)'a'+ cnt++);
		else printf("%c", (char)ans[i]);
	}
	return 0;
}
```

---

## 作者：jingyu0929 (赞：3)

# P6286 [COCI2016-2017#1] Cezar

&emsp;[题目传送门](https://www.luogu.com.cn/problem/P6286)

&emsp;首先按照 $a[i]$ 将 $s$ 遍历一遍，遍历的过程中连边，这个边的意义是：如果 $u$ 向 $v$ 连了一条边，那么 $u$ 这个位置的字母的字典序小于 $v$ 位置的字典序。

&emsp;那么该怎么连边呢，观察两个字符串 `abcd` 和 `abdc`，如果说前面一个字符串的字典序要更小的话，那就说明 `c` 位置的字符字典序要小于 `d` 位置的，可以发现，其实就是两个字符串第一个不相同的字符。

&emsp;那么连边的时候就找到字符 $i$ 向 $i - 1$ 的第一个不一样的字符，然后将 $i$ 的这个位置的字符向 $i - 1$ 位置的字符连边。

&emsp;那么判断有没有解就是看这里有没有环，加密方案的话求一个拓扑排序，然后按照拓扑排序输出。

&emsp;照这个样子写完兴高采烈的提交，会得到 90pts 的好成绩，因为有一个无解的情况在上面没有考虑到，那就是如果 `aa` 在 `aaa` 的后面的话，那么肯定是没有解的，但是这两个第一个不相同的字符是一个空的，所以还需要加一个特判。


```cpp
#include<bits/stdc++.h>
#define ch puts("")
#define wj puts("NE")
#define yj puts("DA")
using namespace std;

const int N = 1e2 + 5, inf = 0x3f3f3f3f;

int n;
char s[N][N];
int id[N], d[N];
int ans[N];
bool st[N];
vector<int> e[N];

lwl fr() {
	lwl x = 0, flag = 1;
	char t;
	t = getchar();
	while (t < 48 || t > 57) {
		if (t == '-') flag = -1;
		t = getchar();
	}
	while (t >= 48 && t <= 57) {
		x = x * 10 + t - 48;
		t = getchar();
	}
	return x*flag;
}

void fw(lwl x) {
	if (x < 0) putchar('-'),x = -x;
	if (x > 9) {
		fw(x / 10);
	}
	putchar(x % 10 + '0');
	return ;
}

int main() {
	n = fr();
	int mxlen = 0;
	for (int i = 1; i <= n; i ++) {
		scanf("%s",s[i] + 1);
		s[i][0] = 'a';
		mxlen = max(mxlen,(int)strlen(s[i] + 1));
	}
	for (int i = 1; i <= n; i ++) id[i] = fr();
	for (int i = 1; i <= mxlen; i ++) {
		for (int t = 2; t <= n; t ++) {
			int j = id[t],k = id[t - 1];
			auto len = min(strlen(s[j] + 1),strlen(s[k] + 1));
			if ((int)len < i || st[t]) continue;
			if (s[j][i] != s[k][i] && s[j][i - 1] == s[k][i - 1]) {
				e[s[k][i] - 'a'].push_back(s[j][i] - 'a');
				d[s[j][i] - 'a'] ++;
				st[t] = true;
			}
		}
	}
    
   // 特判
	for (int i = 2; i <= n; i ++) {
		int j = id[i],k = id[i - 1];
		if (!st[i]) {
			if (strlen(s[j] + 1) < strlen(s[k] + 1)) {
				wj;
				return 0;
			}
		}
	}
   
   // 拓扑排序
	queue<int> q;
	int idx = 0;
	for (int i = 0; i < 26; i ++) {
		if (!d[i]) {
			q.push(i);
		}
	}
	while (q.size()) {
		auto u = q.front();
		q.pop();
		
		ans[++ idx] = u + 1;
		
		for (auto v : e[u]) {
			d[v] --;
			if (!d[v]) q.push(v);
		}
	}
	if (idx < 26) {
		wj;
		return 0;
	}
	yj;
	for (int i = 1; i <= 26; i ++) {
		d[ans[i]] = i - 1;
	}
	for (int i = 1; i <= 26; i ++) {
		cout << (char)(d[i] + 'a');
	}
	return 0;
}
```


---

## 作者：cysylzk123 (赞：2)

## P6286 Cezar 题解

~~众所周知这道题唯一的难点在于题意~~

在自家机房团队赛里见到的这题，一眼就看出了这是道拓扑模板。~~然后就取得了 $55$ 分的奖励分~~。下午起床对着题目愣是盯了一个小时没看出问题，结果教练一看发现是排序的时候存反了 $\dots$ 


------------


### 题意

首先我们需要知道题目的意思是什么，这时候需要仔细分析一下题面，抓一下关键点：

- 将所有单词加密并按字典序升序排列后，最初的 **第 $a_i$ 个** 单词位于 **第 $i$ 位**。

- 接下来 $n$ 行，每行一个字符串，表示 **待加密** 的单词。

注意这里指的是把给定的字符串序列的 **第 $a_i$ 个** 放在排序后数组的 **第 $i$ 位**。


------------


##### ~~拉出来鞭打一下。~~

```cpp
a_sort[b]=a[i];
```
错误打法警示后人。

------------


### 分析

很显然我们可以倒着来，先排列完在去求可能的密钥。而这个密钥的排序必然存在一些限制，那就是题目中的 **按字典序升序排列**。

这时我们来需要回顾一下 **字典序升序排列** 的性质：

- 先比较第一个字母，若第一个字母相同，则比较第二个字母在字母表中的顺序，依次类推，则可比较出该字符串的字典序大小。

- 若字符串 $A$ 为字符串 $B$ 的前缀，那么 $A$ 串应该排在 $B$ 串之前。

依照这些性质，我们可以把字典序的限制看作一条条的有向边，那么就可以按照拓扑序来分配对应的密钥。而无解的条件很明显就是图中存在环，即存在相矛盾的限制。这时候我们可以用变量 $cnt$ 来标记当前字母所分配的密钥，同时也可以用来判断是否已将 $26$ 个密钥全部分配，若没有分配完即说明无解。

同时我们在连边的时候也要考虑到第二个性质。如果字符串 $A$ 为字符串 $B$ 的前缀，且 $A$ 串排在 $B$ 串之后，那么必然无解。因为每个字母对应的密钥是一一对应的，即加密后 $A$ 串还是 $B$ 串的前缀，但没有排在 $B$ 串之前，不满足性质二。


------------


### 代码

话不多说上代码。


```cpp
#include<bits/stdc++.h>
#define LL	long long
using namespace std;
const LL M1=300,M2=30;
LL n;
string a[M1],a_sort[M1];
LL du[M1];
queue<LL>qu;
vector<LL>ve[M2];
LL ans[M2];

int main(){
	cin>>n;
	for(LL i=1;i<=n;i++) cin>>a[i];
	for(LL i=1;i<=n;i++){
		LL b;
		cin>>b;
		a_sort[i]=a[b];
	}
	
	for(LL i=1;i<n;i++){
		bool flag=true;
		for(LL j=0;j<min(a_sort[i].size(),a_sort[i+1].size());j++)
			if(a_sort[i][j]!=a_sort[i+1][j]){
				ve[a_sort[i][j]-'a'].push_back(a_sort[i+1][j]-'a');
				du[a_sort[i+1][j]-'a']++;
				flag=false;
				break;
			}
		if(flag&&a_sort[i].size()>a_sort[i+1].size()){
			cout<<"NE";
			return 0;
		}
	}
	
	for(LL i=0;i<26;i++) if(du[i]==0) qu.push(i);
	
	LL cnt=0;
	while(!qu.empty()){
		LL v=qu.front();
		qu.pop();
		ans[v]=cnt;
		cnt++;
		for(LL i=0;i<(LL)ve[v].size();i++){
			du[ve[v][i]]--;
			if(du[ve[v][i]]==0) qu.push(ve[v][i]);
		}
	}
	
	if(cnt!=26) cout<<"NE";
	else{
		cout<<"DA"<<endl;
		for(LL i=0;i<26;i++){
			cout<<(char)(ans[i]+'a');
		}
	}
	return 0;
}
```


---

## 作者：SIXIANG32 (赞：2)

首先我们达成共识，这道题我们可以把所给的字符串按照它要求的顺序排好，我们记这个叫 $str$。

这题的题意很明确，我们大概一看我们发现这道题很容易从这个顺序中确定这些字母的先后关系。举一个例子

```
abc
abd
ade
efg
```
（再次提醒：这是要求的顺序，不是输入的顺序~~哦~~）

那么我们很容易得到（下面记 $A<B$ 代表字母 $A$ 字典序在 $B$ 之前）
1. c < d
2. b < d
3. a < e

我们再来仔细思考一下这个的过程。首先只给第一个字符串我们什么也干不了，给了第二个呢？在第三位不同，第一个是 ```c```，第二个是 ```d```，所以我们就能得到 c < d。

我们再将这个东西一般化：对于字符串 $str_i$ 与 $str_j(i < j)$，下面我们记 $str_{a, b}$ 代表 $str_a$ 的第 $b$ 个字符。我们找到它们两个的最长公共前缀长度 $k$。那么应该有 $str_{i, k + 1}\not= str_{j, k + 1}$，因为 $i$ 排在前面，所以就应该有 $str_{i, k + 1} < str_{j, k + 1}$。

得到了次序关系，我们很容易想到把它连边（对于 $A<B$，连一条 $A$ 到 $B$ 的有向边），然后跑一遍拓扑排序，这样就得到所有字符的大小关系了！

---
其实这里找前缀的地方我们可以优化，因为如果每个都找一遍前缀的话，对于一个 $j$ 光是枚举 $i$ 就得花费 $O(n^2)$ 的时间，还不算上枚举公共前缀的时间。

所以我们就可以建立一棵 trie 树，按照排好后的顺序依次插入 $str_1\sim str_n$。对于 $str_i$，我们只需要在 trie 上找找找，找到第一个没有儿子 $str_{i, k}$ 的节点（也就是说找到了 $str_i$ 与前面一个字符串的最长公共前缀长度），那么我们就可以遍历这个节点的其它儿子，它们在 $str_i$ 前面插入，所以这些儿子必然比 $str_{i, k}$ 小。连边即可。

时间复杂度每次都要插入一个字符串，插入 $n$ 次，所以是 $O(n|str|)$ 的，考虑到一共就 $26$ 个字母也就是说只有 $26$ 个点，所以我们可以忽略掉拓扑排序的时间（）

---
请特别注意一点！

我们上面的考虑，似乎还没有考虑到当 $str_i$ 就是 $str_j$ 的情况。这种情况看样子就得不到任何有效信息了，也就是说我们的答案就可以是 ```abcdefghijklmnopqrstuvwxyz``` 了。

但是真的是这样吗？这里我们起码可以得到 $str_i < str_j$，但是给定的顺序不一定满足这点。所以我们需要在结束所有过程以后特判。我们也不需要把所有满足 $str_i$ 为 $str_j$ 的前缀且 $i < j$ 的数对 $(i, j)$ 找出来，事实上我们完全可以在求出答案后再检验一遍，生成加密后。如果加密后的满足要求，那么就行，否则就是无解（输出 ```NE```。）

相信很多人都因此 80pts，hack 数据

```
input:
5
d
dd
ddd
dddd
ddddd
1 2 3 5 4

output:NE

```

---

代码

```cpp
//SIXIANG
#include <iostream>
#include <queue>
#include <vector>
#include <algorithm>
#define MAXN 100000
#define QWQ cout << "QWQ" << endl;
using namespace std;
string str[MAXN + 10], tmp[MAXN + 10];
vector <int> gra[MAXN + 10];
int n, a[MAXN + 10], deg[MAXN + 10];
void link(int x, int y) {//如果 x 在 y 之前，则 x 到 y 连边 
	gra[x].push_back(y);
}
bool vis[27][27];

struct node {
	int ch[26];
	int isend;	
} T[MAXN + 10];
int root = 1, tot = 1;
void insert(string str) {
	int now = root;
	bool qwq = 0;
	for(int p = 0; p < str.size(); p++) {
		for(int i = 0; i < 26; i++) {
			if(T[now].ch[i] && i != (str[p] - 'a') && !vis[i][str[p] - 'a']) {
				gra[i].push_back(str[p] - 'a');
				vis[i][str[p] - 'a'] = 1;//vis 是用来判重边的
				deg[str[p] - 'a']++;
			}
		}
		if(T[now].ch[str[p] - 'a'])
			now = T[now].ch[str[p] - 'a'];
		else {
			T[now].ch[str[p] - 'a'] = ++tot;
			now = tot;
		}
	}
}

vector <int> output;
char ans[27];
void topo() {//拓扑排序，很容易理解
	queue <int> que;
	int cnt = 0;
	for(int p = 0; p < 26; p++)
		if(!deg[p]) que.push(p);
	while(!que.empty()) {
		int fr = que.front(); que.pop();
		cnt++;
		output.push_back(fr);
		for(int p = 0; p < gra[fr].size(); p++) {
			int v = gra[fr][p];
			deg[v]--;
			if(!deg[v]) que.push(v);
		}
	}
	if(cnt != 26) cout << "NE" << endl;
	else {
		int o = 0;
		for(int p = 0; p < output.size(); p++)
			ans[output[p]] = o++;
		for(int p = 1; p <= n; p++) {
			for(int i = 0; i < str[p].size(); i++)
				str[p][i] = char(ans[str[p][i] - 'a'] + 'a');
			tmp[p] = str[p];
		}
	
		sort(str + 1, str + n + 1);
		for(int p = 1; p <= n; p++)//最后检查一遍
			if(str[p] != tmp[p]) {
				cout << "NE" << endl;
				return ;
			}
		cout << "DA" << endl;
		for(int p = 0; p < 26; p++)
			cout << char(ans[p] + 'a'); 
	}
}
void init() {
	cin >> n;
	for(int p = 1; p <= n; p++)
		cin >> tmp[p];
	for(int p = 1; p <= n; p++)
		cin >> a[p], str[p] = tmp[a[p]];//str 就是希望的次序
	for(int p = 1; p <= n; p++)
		insert(str[p]);
	topo();
} 
int main() {
//	freopen("read.txt", "r", stdin);
//	freopen("write.txt", "w", stdout);
	init();
}
```

---

## 作者：CWzwz (赞：1)

[P6286 Cezar](https://www.luogu.com.cn/problem/P6286) 题解

------------

### 题意

求一个密钥，使加密后的单词按给定顺序排列。

### 转化

不妨设密钥为 $k_i$，其中 $i \in [1,26]$。

$k_i$，表示字母 $i$ 要替换为字母 $k_i$。

转化一下，密钥就等于，钦定字母 $i$ 是字典中的第 $k_i$ 大（重定义字典序）。然后就不用考虑替换了。

问题等价于，问一个新的字母大小顺序，使得 $n$ 个单词按给定顺序排列。

### 实现

这个很好做，图论建模。设给定顺序为 $Order_i$，只要保证 $\forall i \in [1,n)$，$s_i < s_{i + 1}$ 即可。

$s_i$ 是单词，$<$ 是**新字典序下的**字符串比较。

那么我们就有了 $n - 1$ 组形如 $s_i < s_j$ 的字符串关系。

对于每组关系，找到最小的 $k$ 使得 $s_{i_k} \neq s_{j_k}$。若存在，那么**字母 $s_{i_k}$ 的字典序小于 $s_{j_k}$**，在图中加有向边。

若不存在，分类讨论：

- $s_i$ 是 $s_j$ 前缀，根据字典序的定义，大小关系成立。

- $s_j$ 是 $s_i$ 前缀，根据字典序定义，恒不成立，输出无解。

然后要满足这些字母大小关系，拓扑即可。

最后，拓扑完之后入度数组没有清零的话，就存在环，输出无解。

设字符串长度为 $L$，时间复杂度 $O(n \times L + C)$，其中 $C = 26$。

```cpp
//Problem: P6286
#include<iostream>
#include<algorithm>
#include<string.h>
#include<queue>
#define inf 0x3f3f3f3f
#define INF 0x3f3f3f3f3f3f3f3f
#define i32 INT_MAX
#define i64 LONG_LONG_MAX
#define pii std::pair<int, int>
#define pll std::pair<long long, long long>
#define pb push_back
#define fore(i,u,v) for(int i=head[u],v;i;i=e[i].nxt)
typedef long long ll;
const int N = 105;
ll read(){ll x=0,f=1;char c=getchar();while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+(c^48);c=getchar();}return x*f;}
void print(ll x){if(x<0)putchar('-'),x=-x;if(x>9)print(x/10);putchar(x%10+48);}
char gc(){char c=getchar();while(c==' '||c=='\n')c=getchar();return c;}
void pc(char Char){std::putchar(Char);}

int n, cnte, len;
int Order[N], Len[N], head[27], in[27], List[27], ans[27];
char a[N][N];

struct edge {
    int v, nxt;
} e[N];

std::queue <int> q;

void adde(int u, int v) {
    e[++cnte] = (edge){v, head[u]};
    head[u] = cnte;
    in[v]++;
}
void TopoSort() {
    for(int i = 1; i <= 26; i++) if(!in[i]) List[++len] = i, q.push(i);
    while(!q.empty()) {
        int u = q.front();
        q.pop();
        fore(i, u, v) {
            v = e[i].v;
            in[v]--;
            if(in[v] == 0) {
                List[++len] = v;
                q.push(v);
            } 
        }
    }
}

int main() {
    // freopen("P6286_3.in", "r", stdin);
    // freopen("out.out", "w", stdout);
    std::cin >> n;
    for(int i = 1; i <= n; i++) scanf(" %s", a[i] + 1), Len[i] = strlen(a[i] + 1);
    for(int i = 1; i <= n; i++) Order[i] = read();
    for(int i = 1; i < n; i++) {
        int Flag = 0;
        for(int k = 1; k <= Len[Order[i]] && k <= Len[Order[i + 1]]; k++) {
            if(a[Order[i]][k] != a[Order[i + 1]][k]) {
                adde(a[Order[i]][k] - 'a' + 1, a[Order[i + 1]][k] - 'a' + 1);
                // std::cout << a[Order[i]][k] << ' ' << a[Order[i + 1]][k] << '\n';
                Flag = 1;
                break;
            }
        }
        if(!Flag) {
            if(Len[Order[i]] > Len[Order[i + 1]]) {
                puts("NE");
                return 0;
            }
        }
    }
    TopoSort();
    for(int i = 1; i <= 26; i++) {
        if(in[i] != 0) {
            puts("NE");
            return 0;
        }
        // std::cout << in[i] << '\n';
    }
    puts("DA");
    for(int i = 1; i <= 26; i++) ans[List[i]] = i;
    for(int i = 1; i <= 26; i++) {
        pc(ans[i] + 'a' - 1);
    }
    return 0;
}
```

---

## 作者：CMWabc123 (赞：0)

# 第一部分 题目
[题目传送门](https://www.luogu.com.cn/problem/P6286)

先普及一下恺撒密码：由于原文段过长所以扔个[链接](https://baike.baidu.com/item/%E6%81%BA%E6%92%92%E5%AF%86%E7%A0%81/4905284)

而这道题，与普通的恺撒密码不同的是，偏移量不是固定的值。

例如，原来恺撒密码的偏移类似于这样：
![恺撒密码示意图1](https://cdn.luogu.com.cn/upload/image_hosting/25saqvjs.png)

但是，在这道题中，它不再那么规整，而是变成了类似于：

|原值|a|b|c|d|...|z
|-|-|-|-|-|-|-|
|**映射**|**e**|**o**|**k**|**a**|**...**|**w**|

(不是说一定长这样，只是做一个示范)

也就是说，给你一些字符串和字典序的新比较，让你求映射。

现在，你读懂题了吗？
# 第二部分 思路
我们可以直接对字符串的大小比较进行连边，使它形成一张图。  
此时，求映射便可以直接使用**拓扑排序**（[不知道戳一下1](https://cloud.tencent.com/developer/article/2023513) [不知道戳一下2](https://baike.baidu.com/item/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/5223807)）的方法，求出来的拓扑序列即为相对大小关系。
|数字|字母|
|-|-|
|$0$|$a$|
|$1$|$b$|
|$2$|$c$|
|$3$|$d$|
|$...$|$...$|
|$25$|$z$|

输出时转化成字母即可。

#### 一句话题解：根据优先级建图的拓扑序列转字母后为答案。
# 第三部分 代码
代码还是比较短的。拓扑排序中我用的是双端队列。 ~~（用队列硬控我 $2h$ 直接破防）~~ 

```cpp
#include <bits/stdc++.h> 
using namespace std;
int n,ord[110],deg[30],ans[30],tot;
char s[110][110];
vector<int>G[30];
bool toposort(){
	deque<int>q;
	for(int i=0;i<26;i++)if(deg[i]==0)q.push_back(i);
	while(!q.empty()){
		int u=q.front();
		//cout<<u<<" ";
		q.pop_front();
		ans[u]=tot++;
		for(auto v:G[u]){
			//cout<<u<<": "<<v<<endl;
			deg[v]--;
			if(deg[v]==0){
				q.push_front(v);
			}
		}
	}
	return tot==26;
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>s[i];
	for(int i=1;i<=n;i++){
		cin>>ord[i];
		for(int j=0;;j++){
			if(s[ord[i-1]][j]==0)break;
			if(s[ord[i-1]][j]==s[ord[i]][j])continue;
			G[s[ord[i-1]][j]-'a'].push_back(s[ord[i]][j]-'a');
			deg[s[ord[i]][j]-'a']++;
			//cout<<i<<" "<<j<<endl;
			break;
		}
	}
	if(toposort()){
		cout<<"DA\n";
		for(int i=0;i<26;i++)cout<<char(ans[i]+'a');
	}else{
		cout<<"NE";
	}
	return 0;
}
```
如果大家还有不清楚的地方，欢迎在评论区询问，让我们一起成长。

代码禁止复制，共创文明洛谷。

---

## 作者：zzcsmart (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P6286)

这题其实就是一个拓扑排序。输入了以后将字母的编号、入度存好，输入后将字符串整理成有向图（字典序排在前面的放在字典序排在后面的），进行拓扑，拓扑的过程如下：

1. 创建一个队列 $\text q$ 作为 BFS 的池子。
2. 遍历字母表中的每个字母（从 $\texttt{"a"}$ 到 $\texttt{"z"}$），如果当前字母是需要进行排序的字母，并且没有前驱节点，则将其编号推入队列 $\text q$。
3. 判断：如果队列 $\text q$ 为空（出现了环），表示无法完成拓扑排序，返回 $-1$。
4. 在循环中，依次取出队列 $\text q$ 的首个字母编号 $\text x$。 
	+ 如果 $\text x$ 已经被访问过，这出现了环，返回 $-1$，表示无法完成拓扑排序。
	+ 否则，将 $\text x$ 标记为已访问，并记录到 $\text {ans}$ 和 $\text {ans2}$ 数组中。
	+ 遍历以字母 $\text x$ 为起点的边，将终点字母的入度减一。如果终点字母的入度变为 $0$，则将其编号推入队列 $\text q$。
5. 返回 $\text sum$ 的值，即拓扑排序的结果。

整个拓扑排序其结果存储在数组 $\text {ans}$ 和 $\text {ans2}$ 中，并返回排序的数量。如果无法完成拓扑排序，则返回 $-1$。

之后输出答案即可。写下来看代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2000005;
string s[1005];
int sum,vis[1005],viss[1005];
int ans[N],ans2[N],n,tot,cnt,a[N],zc[N],head[N],anss[N];
struct pos{//结构体（为存图做准备）
	int to,net;
}e[2000010];
void add(int u,int v){//链式前向星板子
	e[++tot].to=v;
	e[tot].net=head[u];
	head[u]=tot;
}
int topo(){//拓扑排序
	queue<int> q;//bfs的池子
	for(int i=0;i<=25;i++) {
		if(!zc[i]&&vis[i]) q.push(i);//把需要进行排序的字母编号推进池子
	}
	if(!q.size()) return -1;//无法完成
	while(!q.empty()){//bfs
		bool flag=false;
		int x=q.front();
		q.pop();
		if(viss[x]) return -1;//无法完成
		viss[x]=1;//访问过了
		ans[++sum]=x;//记录一下
		ans2[sum]=x;//记录一下
		for(int i=head[x];i;i=e[i].net){//拓扑排序的核心
			int v=e[i].to;//终点
			if(--zc[v]==0){//没有前驱节点
				flag=true;
				q.push(v);//推进池子
			}
		}
	}
	return sum;//返回
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>s[i];
	}
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<n;i++){
		int k=0,kk=0;//每轮循环初始化
		while(k<s[a[i]].size()&&kk<s[a[i+1]].size()) {//遍历
			if(s[a[i]][k]!=s[a[i+1]][kk]) {//当前位置上的字符不同
				add(s[a[i]][k]-'a',s[a[i+1]][kk]-'a');//加边（字母的编号）
				if(!vis[s[a[i]][k]-'a']) cnt++,vis[s[a[i]][k]-'a']=1;//没访问过,设为访问过
				if(!vis[s[a[i+1]][kk]-'a']) cnt++,vis[s[a[i+1]][kk]-'a']=1;//没访问过,设为访问过
				zc[s[a[i+1]][kk]-'a']++;//入度加一
				break;
			}
			k++;kk++;//计数器加一
		}
		if(cnt==0&&s[a[i]].size()>s[a[i+1]].size()){//无法完成
			puts("NE");
			return 0;
		}
	}
	if(cnt==0){//可以完成
		puts("DA");
		for(int i=0;i<=25;i++) cout<<char(i+'a');//不变
		return 0;
	}
	int t=topo();//拓扑排序
	if(t==-1){//拓扑后无解
		puts("NE");
		return 0;
	}
	sort(ans+1,ans+1+sum);//排个序
	for(int i=1;i<=sum;i++){
		anss[ans2[i]]=ans[i];//将ans数组中的元素按顺序赋值给anss数组
	}
	for(int i=0;i<=25;i++) {
		if(vis[i]&&!viss[i]){//访问过，但没有被后续更新过
			puts("NE");
			return 0;
		}
		if(!viss[i]) anss[i]=i;//将对应位置赋值
	}
	puts("DA");//可行
	for(int i=0;i<=25;i++){//输出答案（之前存的是字母的编号，现在要加回来）
		cout<<char(anss[i]+'a');
	}
	return 0;
}
```

感谢观看！

---

## 作者：空清虚 (赞：0)

# 背景

AG 爷调教，导致学习字典树，导致这道题我想写拓扑排序。

# 正文
首先，题意理解，最后一行数字 $a_i$ 的意思是：原先排列顺序的第 $a_i$ 个字符串，调位到第 $i$ 位。（这里很重要，读不懂就在题解区上下结合文意）

因为，能用数字就不用字符。

所以，把字符改成数字，记录字符串长度，并进行排序，为下一步做好铺垫。

```cpp
for (register int i=1;i<=n;++i)
	{
		cin>>nd;
		wd[i].nl=nd.size();
		for (register int j=0;j<wd[i].nl;++j)
			wd[i].num[j+1]=nd[j]-'`';
	}
	for (register int i=1;i<=n;++i)
	{
		scanf("%d",&tw);
		wd[tw].rk=i;
	}
	sort(wd+1,wd+1+n,cmp);
```

因为已经进行了对字符串位置的排序，所以如果有解，每一对等长字符串 $s_i$ 和 $s_{i+1}$ 从左到右扫描的第一个不相同位 $j$ 严格存在。$s_{i,j}$ 小于 $s_{i+1,j}$ ，不等长字符串也需要如此判断，但如果不等长字符串对所有位都相等，那么 $s_i$ 的长度严格小于 $s_{i+1}$ 。

综上，我们可知只有当字符串出现字符不同时才会贡献字符排序要求，而全部相等的情况不会贡献字符排序要求，所以在处理字符串的时候，只需要对不一样的字符进行入度出度记录，而相同的可以直接跳过，全部相同再做判断，即在第一层循环判断。

```cpp
for (register int i=1;i<n;++i)
	{
		bool p=0;
		for (register int j=1;j<=min(wd[i].nl,wd[i+1].nl);++j)
		{
			int fr=wd[i].num[j],to=wd[i+1].num[j];
			if (fr!=to)
			{
				if (!ed[fr][to])//ed用于记录连边
				{
					ed[fr][to]=1;
					e[fr].push_back(to);
					p=1,ou[fr]++,in[to]++;
					if (!pa[fr]) pa[fr]=1,sum++;
					if (!pa[to]) pa[to]=1,sum++;//pa记录参与排序的字符，sum是个小优化（大概）
					break;
				}
				else
				{
					p=1;
					break;
				}
				
			}
		}
		if (!p&&wd[i].nl>=wd[i+1].nl)//如果全部相等并且长度和要求相反，那么可以判断无解。
		{
			printf("NE");
			return 0;
		}
	}
```
 $sum$ 是用来记录有多少字符需要重新排序的，在拓扑中可以直接用 $sum$ 得知是否有排序关系，但没有排序的部分，即成环，拓扑完之后可以立刻判断并确认无解。

```cpp
sd=sum;
	for (register int i=1;i<27;++i)
		if (!in[i]&&pa[i]) w.push(i);
	while (!w.empty())
	{
		int wd=w.front();
		w.pop();
		sd--;
		ans[wd]=sum-sd;
		for (register int i=0;i<e[wd].size();++i)
		{
			int twd=e[wd][i];
			in[twd]--;
			if (!in[twd]) w.push(twd);
		}
	}
	if (sd>0)
	{
		printf("NE");
		return 0;
	}
```

最后输出，如果 $ans$ 数组有值的直接输出，没有从左到右按字典序把剩余的字母安排了。

# 结尾

加强看题能力和写题能力。做出来不难，在考场上能想出是拓扑还能过，难。

---

## 作者：MCAdam (赞：0)

[P6286 [COCI2016-2017#1] Cezar](https://www.luogu.com.cn/problem/P6286)

刚开始好像看错题了。。

注意是第$a_i$个单词在第$i$位置。初步的想法，肯定是维护字母的一个顺序，所以应该是按照需要插入单词。

也就是枚举$1$到$n$，处理第$a_i$个单词。

那怎么维护字母的顺序呢？考虑把单词依次插入$Trie$中，对于在同一层中字母，让先插入的字母连边连向新的字母。

![](https://cdn.luogu.com.cn/upload/image_hosting/i9uocg2x.png)

在插入第一个单词$tao$时，就是直接插入。

插入第二个单词$tan$时，$ta$是重复的，遇到一个分叉，发现之前已经插入$o$，那么$o$应该是排在$n$之前的，所以我们让字母$o$向字母$n$连一条边（注意不是在$Trie$上连边，而是建一个图）。

插入第三个单词$te$时，$t$是重复的，遇到一个分叉，发现之前已经插入$a$，让字母$a$向字母$e$连一边。

这样子把所有的字符串处理完后，对这字母构成的图跑拓扑排序。按照字母出队的顺序从小到大赋值字母。如果这张图存在环，那么就没有方案。

注意还有一种没有方案的情况，就是一个单词$A$是另一个单词$B$的前缀，并且这个$B$是先插入$Trie$中的。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
#include <vector>
using namespace std;
const int N=30;
int tot;
string s[110];
char ans[N];
bool flag=true;
int deg[N],que[N],tmp[N];
vector<int>go[N];
struct tree
{
	int cnt;
	int nxt[1000010][N];
	tree(){ cnt=1; }
	inline void insert(string x)
	{
		int p=1,len=x.length();
		for(int i=0;i<len;i++)
		{
			if(!nxt[p][x[i]-'a']) nxt[p][x[i]-'a']=++cnt;
			for(int j=0;j<26;j++)
				if(x[i]-'a'!=j&&nxt[p][j]) go[j].push_back(x[i]-'a'),deg[x[i]-'a']++;//判断是否要分叉 
			p=nxt[p][x[i]-'a'];
		}
		for(int i=0;i<26;i++)
			if(nxt[p][i]){ flag=false; break; }//前缀无解的情况 
	}
}t;
int main()
{
	int n,v,ord=0;
	char ch='a';
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		cin>>s[i];
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&v);
		t.insert(s[v]);//插入Trie中 
	}
	int head=1,tail=0;//注意这里写了字典序最小的方案 
	for(int i=0;i<26;i++)
		if(!deg[i]&&go[i].size()) que[++tail]=i;
	while(head<=tail)//拓扑排序 
	{
		int p=que[head++];
		ans[p]=++ord; tmp[ord]=p;
		for(int i=0;i<go[p].size();i++)
			if((--deg[go[p][i]])==0) que[++tail]=go[p][i];
	}
	for(int i=0;i<26;i++)
		if(deg[i]){ flag=false; break; }//存在环无解 
	if(flag)
	{
		printf("DA\n");
		for(int i=0;i<26;i++)
		{
			if(!ans[i]) ans[i]=(char)(ch++);
			else break;
		}
		for(int i=1;i<=ord;i++)
			ans[tmp[i]]=(char)(ch+i-1);
		ch=(char)(ch+ord);
		for(int i=0;i<26;i++)
			if(!ans[i]) ans[i]=(char)(ch++);
		for(int i=0;i<26;i++)
			cout<<ans[i];
	}
	else printf("NE\n");
	return 0;
}
```

---


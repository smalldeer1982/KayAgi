# [COCI 2016/2017 #4] Rima

## 题目描述

规定字符串 $A,B$ 的最长公共后缀的长度为 $\text{LCS}(A,B)$。

当 $\text{LCS}(A,B) \ge \max(|A|,|B|)-1$ 时，我们认为 $A,B$ 两个字符串押韵。

给定 $N$ 个字符串，要求从中组合出一个长度最长的字符串序列（序列长度为该序列所包含字符串的数量），使得序列中相邻两个字符串押韵。

## 说明/提示

**【样例 2 解释】**

字符串序列 $\texttt{ask-psk-sk-k}$ 长度最大，为 $4$。

**【样例 3 解释】**

没有任何两个字符串押韵，因此任何一个字符串都可以单独组成一个序列，答案为 $1$。

**【数据规模与约定】**

对于 $30\%$ 的数据，$N \le 18$。

对于 $100\%$ 的数据，$1 \le N \le 5 \times 10^5$。

**【提示与说明】**

**题目译自 [COCI 2016-2017](https://hsin.hr/coci/archive/2016_2017/) [CONTEST #4](https://hsin.hr/coci/archive/2016_2017/contest4_tasks.pdf) _T5 Rima_。**

**本题分值按 COCI 原题设置，满分 $140$。**

## 样例 #1

### 输入

```
4
honi
toni
oni
ovi```

### 输出

```
3```

## 样例 #2

### 输入

```
5
ask
psk
krafna
sk
k```

### 输出

```
4```

## 样例 #3

### 输入

```
5
pas
kompas
stas
s
nemarime```

### 输出

```
1```

# 题解

## 作者：子丑 (赞：16)

很有趣的一道题（？），模拟赛的时候没写出来，老师讲的时候是真的感觉茅塞顿开。

仔细读题，想想最终的序列能长成什么样子。不难发现，最终的序列上下相邻的两个字符串的长度差距一定为 $0$ 或 $1$。

由于没有重复的字符串，所以**一定不会**出现一个型如 $S$，$c+S$，$S$ 的子序列（此处 $S$ 代表字符串，$c$ 代表字符）。也就是说，最终的字符串长度序列不会在中间出现峰值（只可能在序列两侧出现）。

![](https://cdn.luogu.com.cn/upload/image_hosting/qplnpskt.png)

这是字符串序列最终可能出现的一种情况，我们只需要找出最多个字符串，使其形成的序列能呈现出这样的性质即可。

考虑相邻的两个字符串。将它们分别反向插入一棵 trie 树中并标记出结尾所在的点，一定会呈现出以下两种情况的任意一种。（红点、蓝点分别表示两个字符串的第一个字符，也可以理解为反向后的最后一个字符）

![](https://cdn.luogu.com.cn/upload/image_hosting/pvurage9.png)


其中，第一种情况对应长度相同、首字符不同的情况；第二种情况对应长度相差 $1$，一个字符串为另一个字符串的后缀的的情况。

---

结合上面推出来的两个结论，就可以解决这题了。首先将所有的字符串反向插入 trie 树，然后在这棵 trie 树上做一次树形 dp 即可。

我们需要找出一棵被标记节点最多的子树，这棵子树需要满足：

1. 根节点只有 $1 \sim 2$ 个子节点。
2. 除根节点外，其他所有节点均一定被标记。
3. 除根节点外，每个节点的儿子中最多只有一个节点不是叶子。

接下来是最不重要的代码。（已经尽量减少压行）

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define rep(i, a, b) for(int i=(a), i##up=(b); i<=i##up; ++i)
#define ref(i, a) for(int i=1, i##up=(a); i<=i##up; ++i)
#define rer(i, a, b) for(int i=(a), i##dn=(b); i>=i##dn; --i)

inline int read() {
	int t=0, f=1; char c;
	while(!isdigit(c=getchar())) f=c^45;
	while(isdigit(c)) t=(t<<1)+(t<<3)+(c^48), c=getchar();
	return f? t: -t;
}

const int N=5e5+5, M=3e6+5;

int n;
char s[M];

int son[M][26], ptot, cnt[M];
inline void insert(char *s) {
	int u=0, d;
	rer(i, strlen(s+1), 1) {
		d=s[i]-'a';
		if(!son[u][d]) son[u][d]=++ptot;
		u=son[u][d];
	}
	cnt[u]++;
}

int dp[M], ans;
void dfs(int u) {
	int v, siz=0, mx1=0, mx2=0;
	rep(d, 0, 25) if(v=son[u][d]) {
		dfs(v), siz+=cnt[v];
		if(mx1<dp[v]) mx2=mx1, mx1=dp[v];
		else if(mx2<dp[v]) mx2=dp[v];
	}
	if(cnt[u]) dp[u]=mx1+max(siz, 1);
	ans=max(ans, mx1+mx2+cnt[u]+max(siz-2, 0));
}

int main() {
	n=read();
	ref(i, n) scanf("%s", s+1), insert(s);
	dfs(0);
	printf("%d", ans);
}
```

听说有人想看压行版本？（并没有人想看）

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define rep(i, a, b) for(int i=(a), i##up=(b); i<=i##up; ++i)
#define ref(i, a) for(int i=1, i##up=(a); i<=i##up; ++i)
#define rer(i, a, b) for(int i=(a), i##dn=(b); i>=i##dn; --i)

inline int read() {
	int t=0, f=1; char c;
	while(!isdigit(c=getchar())) f=c^45;
	while(isdigit(c)) t=(t<<1)+(t<<3)+(c^48), c=getchar();
	return f? t: -t;
}

const int N=5e5+5, M=3e6+5;

int n;
char s[M];

int son[M][26], ptot, cnt[M];
inline void insert(char *s) {
	int u=0, d;
	rer(i, strlen(s+1), 1) son[u][d=s[i]-'a']||(son[u][d]=++ptot), u=son[u][d];
	cnt[u]++;
}
int dp[M], ans;
void dfs(int u) {
	int v, siz=0, mx1=0, mx2=0;
	rep(d, 0, 25) if(v=son[u][d]) dfs(v), siz+=cnt[v], mx1<dp[v]&&(mx2=mx1, mx1=dp[v], 1) || mx2<dp[v]&&(mx2=dp[v]);
	cnt[u]&&(dp[u]=mx1+max(siz, 1)), ans=max(ans, mx1+mx2+cnt[u]+max(siz-2, 0));
}

int main() {
	ref(i, n=read()) scanf("%s", s+1), insert(s);
	dfs(0), printf("%d", ans);
}
```

---

## 作者：封禁用户 (赞：10)

# 1.前言
原blog：[CSDN](https://blog.csdn.net/qq_37656398/article/details/94740509)

[AC记录](https://www.luogu.com.cn/record/56773814)

求关注qwq。

# 2.分析
我们考虑将每个串反转后挂到 trie 上，那么后缀就变成了前缀。

考虑在 trie 上做 DP。定义 $f[u]$ 为以编号为 $u$ 的节点结尾的单词后最多能接上的单词数量。

由于 trie 上每个节点都表示一个单词，我们需要对表示真实存在的单词的节点打上标记，以避免转移时出错。

我们画一下图就可以发现，若该节点对答案有贡献，则该节点对答案的贡献是最多的是两个儿子的 $f$ 值加上剩余的儿子的数量。

注意当 $u$ 不是一个真实的节点时，我们应将 $f[u]$ 赋为 $0$。

注意这道题卡空间，我们不能暴力开长度为 26 数组来存储儿子的信息。

# 3.code
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;

const int Maxn=5e5;
const int Maxlen=3e6;

int N;

struct Trie {
	bool is_real;
	int f;
	vector<pair<char,int> > son;
};
Trie t[Maxlen+5];
int cnt;
int ans;

void addstring(string tmp) {
	int rt=0;
	for(int i=0;i<(int)tmp.length();i++) {
		int nxt=-1;
		for(int j=0;j<(int)t[rt].son.size();j++)
			if(t[rt].son[j].first==tmp[i]) {
				nxt=t[rt].son[j].second;
				break;
			}
		if(nxt==-1) {
			nxt=++cnt;
			t[rt].son.push_back(make_pair(tmp[i],nxt));
		}
		rt=nxt;
	}
	t[rt].is_real=true;
}

void DFS(int rt) {
	int cnt_real=0;
	pair<int,int> maxx;
	maxx=make_pair(0,0);
	for(int i=0;i<(int)t[rt].son.size();i++) {
		int v=t[rt].son[i].second;
		DFS(v);
		cnt_real+=t[v].is_real;
		maxx=max(maxx,make_pair(maxx.first,t[v].f));
		maxx=max(maxx,make_pair(t[v].f,maxx.first));
		t[rt].f=max(t[rt].f,t[v].f);
	}
	if(t[rt].is_real)
		t[rt].f+=max(1,cnt_real);
	else t[rt].f=0;
	ans=max(ans,maxx.first+maxx.second+t[rt].is_real+max(0,cnt_real-2));
}

int main() {
	freopen("rima.in","r",stdin);
	freopen("rima.out","w",stdout);
	cin>>N;
	for(int i=1;i<=N;i++) {
		string s;
		cin>>s;
		reverse(s.begin(),s.end());
		addstring(s);
	}
	DFS(0);
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：lupengheyyds (赞：8)

[原题链接](https://www.luogu.com.cn/problem/P7537)

## 背景
其他题解已经讲述了本体大致的解决方法，可并没有提出此题与字典树不可分割的原因，以及从何想到字典树的。所以本篇题解主要从思路与细节进行说明。
## 分析

### 初步转化+朴素做法
观察题目我们会发现这样一个“押韵”条件。
>当 $\operatorname{LCS}(A,B)\ge \max(\left|A\right|,\left|B\right|-1)$ 时。

这说明了这两个字符串：

- 要么完全相同（“$=$”的情况）；
- 要么这两个字符串长度相同，但是第一个字符不同；
- 要么其中一个字符串刚好比另一个少了第一个字符；

可是题目后来说:
> 保证所有字符串互不相同。

所以只有了后两种情况，那么我们就可以很容易相处一个暴力解法：把每两个符合押韵的字符建一条边，形成一个图，接着在图上跑一条最长链。

这样做的时间复杂度约为 $\mathcal{O}(N^3+NS)$，可以得 $\color{Red}40$ 分。

**代码如下**：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int szl=5e5+5;
int n;
string str[szl];
vector<int> ed[szl];
bool AbleEdge(int x,int y){
	return str[x]==str[y].substr(1,str[y].size()-1)||
	str[x].substr(1,str[x].size()-1)==str[y].substr(1,str[y].size()-1)||
	str[x].substr(1,str[x].size()-1)==str[y];
}
bool vst[szl];
int DFS(int x){
	vst[x]=true;
	int cnt=0;
	int tot=1;
	for(int i=0;i<ed[x].size();i++){
		int y=ed[x][i];
		if(vst[y])continue;
		tot=max(DFS(y)+1,tot);
	}
	vst[x]=false;
	return tot;
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>str[i];
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(AbleEdge(i,j)){
				ed[i].push_back(j);
				ed[j].push_back(i);
			}
		}
	}
	int maxn=0;
	for(int i=1;i<=n;i++){
		maxn=max(maxn,DFS(i));
	}
	cout<<maxn;
	return 0;
}
```
### 进一步分析——字典树

根据上文的分析，我们会发现符合条件的两个字符串必定有大量的字符相同，若是一个一个比较会浪费大量时间，那么我们就可以自然的想到可以处理大量相同字符内容的数据结构——字典树。

所以我们应该将字符反转并放在字典树上，根据分析，此时“押韵”的字符串结尾节点的关系一定是：
- 兄弟
- 父子

接着就可以直接通过动态规划求解，类似求树的直径的方法。$d[x]$ 表示以 $x$ 为根可以到达叶子节点的最长距离，设 $y_1,y_2,\cdots,y_k$ 是节点 $x$ 在字典树上的儿子，且满足是某个字符串末尾节点。接着便分类讨论：

- 若 $x$ 是某个字符串的末尾节点。那么 $d[x]=\max\limits_{i=1}^k\{d[y_i]\}+k$。这个式子的意义是“从叶子节点到某个儿子‘最长链’，连同它所有的儿子及自己本身一起构成新的‘最长链’”。

- 若 $x$ 不是某个字符串的末尾节点。那么用 $\max\limits_{i=1}^k\{d[y_i]\}+\operatorname{second}\max\limits_{i=1}^k\{d[y_i]\}+k-2$ 更新答案。这个式子的意思是从最长链上来，经过所有的儿子，再从次长链下去。

最后就得到了答案。

时间复杂度 $\mathcal{O}(N+S)$。

温馨提示：建边不要用递归，会超时。

如果你还没看懂，就可以参考代码。

## 代码
```cpp
//Trie O(S)
#include<bits/stdc++.h>
using namespace std;
const int szls=3e6+5;
int n;
void Reverse(string &s){
	for(int i=0;i<s.size()/2;i++)
		swap(s[i],s[s.size()-i-1]);
	return;
}
bool mark[szls];
int trie[szls][26];//防止MLE
int root,cnt,num;
void Add(string s){
	int u=root;
	for(int i=0;i<s.size();i++){
		int d=s[i]-'a';
		if(trie[u][d]==0)trie[u][d]=++cnt;
		u=trie[u][d];
	}
	mark[u]=true;
	return;
}
int f[szls];//存以f为根的广义最长链 
int ans=1;
void DFS(int x){
	int maxn=0,big=0,maxi=0;
	//找最长链+次长链
	int able=0;//有效子节点个数 
	for(int i=0;i<26;i++){
		if(!trie[x][i])continue;
		int y=trie[x][i];
		DFS(y);
		if(!mark[y])continue;
		able++;
		if(maxn<f[y])big=maxn,maxn=f[y];
		else big=max(big,f[y]);
	}
	f[x]=maxn+able-(maxn!=0)+mark[x];// 最长的一个加上其他节点 
	ans=max(ans,f[x]+big-(big!=0));
	return;
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		string str;cin>>str;
		Reverse(str);
		Add(str);
	}
	DFS(root);
	cout<<ans;
	return 0;
}
``` 

---

## 作者：liudonghao (赞：4)

考虑翻转每一个字符串，这样公共后缀就变成了公共前缀。

公共前缀？建出[字典树](https://www.luogu.com.cn/problem/P8306)来。

![图炸了私信我](https://cdn.luogu.com.cn/upload/image_hosting/sujnbmv3.png)

（点权代表这个点有没有单词结尾）

那么，两个单词押韵，当且仅当它们的尾部节点在字典树上有父子或兄弟关系。

也就是说，序列中每一个单词的下一个单词可以是它的任意一个非空兄弟、非空父亲或非空儿子上。

一颗子树上，能遍历到最多点的情况应该长成下面这个样子：

![图炸了私信我](https://cdn.luogu.com.cn/upload/image_hosting/oltbsjna.png)

但注意，这种情况无法对更大的子树做出贡献，因为一旦下去就再也上不来了。

所以，不仅要记录能遍历到最多点（即深入两根枝条）的情况，也要记录只深入了一根枝条的最多点数。

还有，根节点也可能没有对应的单词。

所以，设 $dp(u,1\ or\ 0,1\ or\ 2)$ 表示在以 $u$ 为根的子树中，选/不选根，深入了$1\ or\ 2$ 根枝条的最大单词数。

设 $s$ 为 $u$ 的非空儿子数，$son(u)$ 表示 $u$ 的非空儿子集合

当 $s \geqslant 1$ 时，

$$dp(u,0,1)=\max_{v\in son(u)} dp(v,1,1)+s-1 $$

当 $s \geqslant 2$ 时，

$$dp(u,0,2)=\max_{v\in son(u),w \in son(u),v \ne w} dp(v,1,1)+dp(w,1,1)+s-2$$

上面的一遍深搜 $O(\sum|S|)$ 处理即可。

若 $u$ 非空，则 $dp(u,1,1)=dp(u,0,1)+1,\ dp(u,1,2)=dp(u,0,2)+1$

答案可能是任意 $u$ 的 $dp(u,0\ or\ 1,1\ or\ 2)$,取最大值即可。

代码：

```cpp
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
const int N = 3e6 + 10;
int m,to[N][30],val[N],n,siz[N][2][3];
void Insert(string s)
{
	int id = 0;
	for(char c : s)
	{
		if(to[id][c - 'a' + 1]) id = to[id][c - 'a' + 1];
		else
		{
			n++;
			to[id][c - 'a' + 1] = n;
			id = n;
		}
	}
	val[id]++;
}
void dfs(int u)
{
//	cout << u << endl;
	int maxx = -1,maxxx = -1,s = 0;
	for(int i = 1; i <= 26; i++)
	{
		if(to[u][i])
		{
			dfs(to[u][i]);
			if(val[to[u][i]])
			{
				s++;
				if(siz[to[u][i]][1][1] > maxx) maxxx = maxx, maxx = siz[to[u][i]][1][1];
				else if(siz[to[u][i]][1][1] > maxxx) maxxx = siz[to[u][i]][1][1];

			}
		}
	}
	if(maxxx != -1) siz[u][0][2] += maxx + maxxx;
	if(maxx != -1) siz[u][0][1] += maxx;
	if(s >= 1) siz[u][0][1] += s - 1;
	if(s >= 2) siz[u][0][2] += s - 2;
	if(val[u]) siz[u][1][2] = siz[u][0][2] + 1, siz[u][1][1] = siz[u][0][1] + 1;
}
int main()
{
	cin >> m;
	for(int i = 1; i <= m; i++)
	{
		string s; cin >> s;
		reverse(s.begin(),s.end());
		Insert(s);
	}
	dfs(0);
	int ans = -1;
	for(int i = 0; i <= n; i++) ans = max(ans,max(siz[i][0][2],siz[i][1][2]));
	for(int i = 0; i <= n; i++) ans = max(ans,max(siz[i][0][1],siz[i][1][1]));
	cout << ans << endl;
	return 0;
}
//ctj可耻！
```

---

## 作者：Kevin_Mamba (赞：3)

[双倍经验](https://www.luogu.com.cn/problem/P4471)

题意不多复述，直接进入正题。

### 解析

标签写的很清楚了。先考虑 Trie。

Trie 简单来说就是一棵树，每条边存一个字符。

从根节点到每个节点的路径都可以代表一个字符串。详见[这里](https://www.luogu.com.cn/problem/P8306)。

这样就能很快求出两个字符串的最长公共前缀（LCA）。只要**反过来**存，最长公共后缀也不在话下。

这样就能存出一棵字典树，对于表示两个字符串的节点 $u,v$（从根到当前节点），最长公共后缀就是根到 `LCA(u,v)` 表示的字符串。

这样就不难看出，**押韵的字符串要么是兄弟关系，要么是父子关系**。

就从根节点开始树形 dp。**因为只要求相邻的两个字符串押韵，前面的对不相邻的无影响**。

所以设 $f_i$ 表示节点 $i$ 表示的字符串为**最右边**的序列的最长长度（若根到节点 $i$ 不代表一个字符串（$word_i=0$），$f_i=0$），$son_i$ 代表 $i$ 的所有儿子，$siz_i$ 代表儿子的个数，$word_i$ 代表 $i$ 节点代表的字符串个数。

$f_i=\max\limits f_{son_i} + siz_i-1+word_i$。

每次更新 $ans$ 时，就取出 $i$ 为根的子树的**直径加上儿子数再减 $2$（被直径覆盖的 $2$ 个儿子不算）**。具体见代码。

### 代码实现

```cpp
#include<bits/stdc++.h>
#define il inline
#define re register 
using namespace std;

const int M=3e6+10;

int n,t[M][30],tot,word[M],f[M],son[M],ans;

char s[M];

il void insert(re char *s) {
	re int p=0,len=strlen(s);
	for(re int i=len-1;~i;i--) {
	// 反建 Trie 
		re int &to=t[p][s[i]-'a'+1];
		if(!to) to=++tot;
		p=to;
	}
	word[p]++;
}

il void dfs(re int u) {
	re int large=0,big=0,kids=0;
	// 最长链+次长链=直径。 
	for(re int i=1;i<=26;i++) {
		re int v=t[u][i];
		if(!v) continue;
		kids+=word[v];
		dfs(v);
		if(f[v]>large) {
			big=large;
			large=f[v];
		}
		else big=max(big,f[v]);
	}
	ans=max(ans,word[u]+large+big+max(kids-2,0));
	// 更新 ans 
	if(word[u]==0) f[u]=0;
	// 断层了 
	else {
		f[u]=large+max(0,(kids-1))+word[u];
		// 更新 f 
	}
}

int main() {													
	scanf("%d",&n);
	for(re int i=1;i<=n;i++) {																												
		scanf("%s",s);
		insert(s);
	}
	dfs(0);
	printf("%d",ans);
	return 0;
} 
```

---

## 作者：saixingzhe (赞：2)

# 分析
提供一种不用 trie 的做法。

两个单词押韵只有两种情况：

* 两个单词除首字母外都相等
* 其中一个单词比另一个长一，且这个单词其他字符与另一个相等

所以我们把一个单词与它本身和去掉首字母的字符串连边。

连边时我们使用 `map` 映射字符串，代码如下：

```cpp
string s[500005];
vector<int>G[1500005];
map<string,int>m;
cin>>n;
tot=n;	
for(int i=1;i<=n;i++){
	cin>>s[i];
	if(!m[s[i]])	m[s[i]]=++tot;
	if(!m[s[i].substr(1)])	m[s[i].substr(1)]=++tot;
	G[i].push_back(m[s[i]]);
	G[m[s[i]]].push_back(i);
	G[i].push_back(m[s[i].substr(1)]);
	G[m[s[i].substr(1)]].push_back(i);
}
```
我们发现连边组成的是一个森林，在每棵树上跑一遍，寻找树上带点权的最长链，我们发现单词押韵的一个后缀在 `vector` 中连边的数量即为其点权，但是这样会重复计算，每次转移需要减一，最后再加一。

对于每个点，最长链从儿子节点中由其起点的最长链转移，在转移时，我们同时记录一个第二长的儿子节点中由其起点的最长链，将其与最长的拼起来统计答案，不过不将其转移。

还有需要注意的是因为我们建边时向单词本身和去掉首字母的字符串都建了，所以数组要开三倍。

上面都写完会超时一个点，我们卡卡常，把建边的 `map`，换为 `unordered_map` 即可通过。

# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,tot,vis[1500005],cnt,ans;
string s[500005];
vector<int>G[1500005];
unordered_map<string,int>m;
int dfs(int x){
	int maxn=0,maxx=0;
	vis[x]=1;
	for(int i:G[x]){
		if(!vis[i]){
			maxx=dfs(i);
			cnt=max(cnt,maxx+maxn+(x>n?(int)G[x].size()-1:0));
			maxn=max(maxx,maxn);
		}
	}
	return maxn+(x>n?(int)G[x].size()-1:0);
}
int main(){
	cin>>n;
	tot=n;
	for(int i=1;i<=n;i++){
		cin>>s[i];
		if(!m[s[i]])	m[s[i]]=++tot;
		if(!m[s[i].substr(1)])	m[s[i].substr(1)]=++tot;
		G[i].push_back(m[s[i]]);
		G[m[s[i]]].push_back(i);
		G[i].push_back(m[s[i].substr(1)]);
		G[m[s[i].substr(1)]].push_back(i);
	}
	for(int i=1;i<=tot;i++)
		if(!vis[i]){
			cnt=0;
			ans=max({ans,dfs(i)+1,cnt+1});
		}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：zzzyyyyhhhhh (赞：2)

整体思路其他题解已经说的差不多了，本题解着重说一个细节问题。

首先建一棵后缀 trie ，记录每个串在树上结束的位置，这样树上每个节点（记为 $u$ ）的子树结束的串都拥有一个共同后缀（即 $u$ 到根节点所代表的串）。设 $f_i$ 表示以 $i$ 为根的最大答案，也就是答案序列中所有串都有相同后缀为 $i$ 到根节点代表的串。考虑转移，首先对于子节点，如果有串在这个点结束，可以直接继承答案，用字符串表示为 LCS +letter 与 LCS 连接（LCS 表示公共后缀），前面的序列不变。对于在其他子节点结束的串，答案加上这些串的数量（也就是则插入这些串，即 LCS+letter 与  LCS+otherletter  连接，再和 LCS 连接。）树形 dp 解决即可。

然后你写完了，信心满满地交了上去，却发现只有 $56$ 分。为什么呢？考虑下面一组数据

```求管理员放过
qpm
pm
m
nm
cnm
```
发现可以选择整个序列，但答案只统计了下面图圈出点的答案。

![](https://cdn.luogu.com.cn/upload/image_hosting/zvhl9597.png)

这是因为实际序列中字符串长度是可以先减再增的，可我们只能统计上单调减的答案。所以对于每个节点，在**用这个节点更新答案时**需要继承两棵最大子树的答案。

最后放上代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N = 3e6+100;
int n,m;
int trie[N][26],f[N*26],stop[N*26],cnt=1;
char in[N];
int ans;
void insert()
{
	int len=strlen(in+1);
	int now=1;
	for(int i=len;i>=1;i--)
	{
		if(trie[now][in[i]-'a'])
		{
			now=trie[now][in[i]-'a'];
		}
		else
		{
			now=trie[now][in[i]-'a']=++cnt;
		}
	}
	stop[now]++;
}
void dfs(int x)
{
	f[x]=stop[x];
	for(int i=0;i<26;i++)
	{
		if(trie[x][i])dfs(trie[x][i]);
		f[x]+=stop[trie[x][i]];
	}
	int mx=0,smx=0;
	for(int i=0;i<26;i++)
	{
		if(stop[trie[x][i]])
		{
			if(f[trie[x][i]]-stop[trie[x][i]]>mx)
			{
				smx=mx;
				mx=f[trie[x][i]]-stop[trie[x][i]];
			}
			else if(f[trie[x][i]]-stop[trie[x][i]]>smx)
			{
				smx=f[trie[x][i]]-stop[trie[x][i]];
			}
		}
	}
	f[x]+=mx;
	ans=max(ans,f[x]+smx);
}
signed main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>in+1;
		insert();
	}
	dfs(1);
	cout<<ans;
}
```

---

## 作者：DengDuck (赞：2)

我们注意到后缀不好处理，我们旋转字符串变为前缀，考虑使用字典树。

问题变成，对于一个特殊点，可以跳到特殊兄弟的位置，可以跳到特殊儿子的位置，可以跳到特殊兄弟的儿子。

这里的特殊点指字典树对于字符串末尾的标记。

我们设 $f_x$ 表示 $x$ 在其子树中移动的最大步数，显然可以先走所有儿子，再选一个深入，这个是容易求的。


当然，这个序列也可以倒过来。

我们发现有一种最长路径形如 $son_1\to fa\to son_2$，我们维护儿子 $f$ 值的最大值和次大值即可求。

时间复杂度为 $\mathcal O(n)$。

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const LL N=3e6+5;
const LL M=26;
struct node
{
	LL son[M],cnt;	
}t[N];
LL n,f[N],tot,ans;
char s[N];
void ins(char *s)
{
	LL len=strlen(s),rt=0;
	for(int i=len-1;i>=0;i--)
	{
		if(t[rt].son[s[i]-'a']==0)t[rt].son[s[i]-'a']=++tot;
		rt=t[rt].son[s[i]-'a'];
	//	cout<<rt<<endl;
	}
	t[rt].cnt++;
}
void dfs(LL x)
{
	LL mx=0,cnt=0,sec=0;
	for(int i=0;i<M;i++)
	{
		if(t[x].son[i]==0)continue;
		dfs(t[x].son[i]);
		if(f[t[x].son[i]])cnt++;
		if(f[t[x].son[i]]>mx)swap(mx,sec),mx=f[t[x].son[i]];
		else if(f[t[x].son[i]]>sec)sec=f[t[x].son[i]];
	}
	if(t[x].cnt)f[x]=1+max(mx+cnt-1,0ll),ans=max({ans,1+max(mx+sec-2+cnt,0ll)});
	ans=max({ans,f[x],max(mx+sec-2+cnt,0ll)});
//	cout<<x<<' '<<f[x]<<endl;
}
int main()
{
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%s",s);
		ins(s);
	}
	dfs(0);
	printf("%lld",ans);
}
```

---

## 作者：普通的名字 (赞：2)

由于题目涉及到后缀，不难想到用 trie 树处理。

将每个字符串翻转插入 trie，后缀就变成了前缀，方便处理。

条件 $\text{LCS}(A,B) \ge \max(|A|,|B|)-1$，说明 $\left||A|-|B|\right|\le1$。

所以两个字符串押韵当且仅当在 trie 树上二者是父子或兄弟关系。

考虑树型 DP，设 $f_i$ 表示 $i$ 所代表的字符串在序列最右边的最长序列长度，$val_i$ 表示节点 $i$ 是否（1/0）有单词，$sz_i=\sum\limits_{x\in son_i}val_x$。

显然有转移 $f_i=\max\limits_{x\in son_x}(f_x)+sz_i-1+val_i$。

如果 $val_i=0$，说明都没有字符串，$f_i=0$。

更新答案时，记录儿子 $f_{son_i}$ 的最大和次大，再加上剩余儿子和自己的 $val$。（感性理解，一条链只有两个位置是“自由”的，由此设出 DP 状态）

本题卡空间，所以建 trie 树时要动态开点。

具体实现参见代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e6+10;
int cnt=1,n,f[N],ans;
char a[N];
struct node
{
    vector<pair<int,int> > son;
    int fa,val;
}tr[N];
void insert(int rt,char a[],int len)
{
    for(int i=0;i<len;i++){
        int x=a[i]-97;
        for(auto j:tr[rt].son){
            if(j.first==x){
                rt=j.second;
                goto a;
            }
        }
        tr[rt].son.push_back(make_pair(x,++cnt));
        rt=tr[rt].son.back().second;
        a:;
    }
    tr[rt].val++;
}
void dfs(int rt)
{
    int aa=0,bb=0,x=0,y=0,sum=0;
    for(auto i:tr[rt].son){
        dfs(i.second);
        sum+=tr[i.second].val;
        f[rt]=max(f[rt],f[i.second]);
        if(f[i.second]>aa){
            bb=aa;
            aa=f[i.second];
            y=x;
            x=tr[i.second].val;
        }
        else if(f[i.second]>bb) bb=f[i.second],y=tr[i.second].val;
    }
    f[rt]+=sum-x;
    if(!tr[rt].son.size()) ans=max(ans,tr[rt].val);
    else ans=max(ans,aa+bb-x-y+sum+tr[rt].val);
    if(!tr[rt].val) f[rt]=0;
    else f[rt]++;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%s",a);
        int len=strlen(a);
        reverse(a,a+len);
        insert(1,a,len);
    }
    dfs(1);
    cout<<ans;
}
```

---

## 作者：spire001 (赞：2)

## 题意

找出 $N$ 个字符串中最长的押韵序列。

## 思路

考虑动态规划和字典树。

$dp_i$ 的含义表示以此节点为根节点最长单词序列长度。

状态转移方程为 $dp_i = dp_i + (word_{child_{i,j}} \geq 1)$。

反向建图，将图建好后将每个节点遍历一遍，如果某处有单词，更新当前最长链和次长链，最后更新答案，即 $max\{dp[i] + ma_1 + ma_2\}$。其中 $ma_i$ 指的是第 $i$ 长链。

## 代码部分

```cpp
# include <iostream>
# include <cstring>
# include <algorithm>
constexpr int N = 3e6 + 5;
constexpr int M = 5e5 + 2;
using namespace std;
int dp[N];
int ans;
struct trie{//字典树
	int child[26][N];
	int hz[N];
	int word[N];
	int tot;
	trie() {tot = 0;}
	void push(const string &s)
	{
		int p = 0;
		for(int i = 0; s[i]; i++)
		{
			int c = s[i] - 'a';
			if(!child[c][p])
				child[c][p] = ++tot;
			p = child[c][p];
			hz[p]++;
		}
		word[p]++;
	}
	void solve()
	{
		for(int i = tot; i >= 0; i--)//遍历所有节点
		{
			dp[i] = word[i];//初始化，至少会有一个长度
			int ma1 = 0, ma2 = 0;
			for(int j = 0; j < 26; j++)
				if(word[child[j][i]])
				{
					dp[i]++;
					if(dp[child[j][i]] - ma1 > 1) {ma2 = ma1;ma1 = dp[child[j][i]] - 1;}
					else if(dp[child[j][i]] - ma2 > 1) ma2 = dp[child[j][i]] - 1;
				}
			dp[i] += ma1;//这里要加上第一长链
			ans = max(ans , dp[i] + ma2);//更新答案
		}
	}
}t;
int n;
string s[M];
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cin >> n;
	for(register int i = 1; i <= n; i++) 
	{
		cin >> s[i];
		reverse(s[i].begin() , s[i].end());//反向建图
		t.push(s[i]);
	}
	t.solve();
	cout << ans;
	return 0;
}


```

---

## 作者：hnczy (赞：1)

很容易想到翻转之后建立一颗字典树，主要还是如何求出答案的问题，个人觉得其他题解没有讲的通俗易懂，所以这里补充一下，个人也是借鉴别人的题解的。

我们先设 $f_i$ 为 $i$ 这个节点（字典树上的节点）在字符串序列中是长度最小的（假设它在最左边），且这个序列的字符串长度是单调不减的，可以写出 $f_i= \max_{j\in son_i} f_j +1$，然而我们这个序列其实不一定要是长度单调递不增的，可以最短的在中间，形成一个类似“单谷”的形状，所以意味着可以往两边放序列，所以答案就是 $\max_{first}f+ \max_{first}f + \max(cnt-2,0)+flag$，$cnt$ 是子节点的数量的总和，$flag$ 是这个点是否是可选的点之一，因为这个点的所有子节点包括这个点都是押韵的，所以要加上 $\max(cnt-2,0)+flag$。当然需要减掉两边放的最大和次大的贡献。这个就是答案。

代码：
```c++
#include<bits/stdc++.h>
using namespace std;
const int N=3E6+5;
int n,ans;
string s;
struct Trie {
	int ch[N][26],tot,f[N];
	bool flag[N];
	void change(string &s) {
		int len=s.size(),p=0;
		for(int i=0; i<len; i++) {
			int t=s[i]-'a';
			if(!ch[p][t])ch[p][t]=++tot;
			p=ch[p][t];
		}
		flag[p]=1;
	}
	void dfs(int p) {
		int cnt=0,mx1=0,mx2=0;
		for(int i=0;i<26;i++){
			if(ch[p][i])dfs(ch[p][i]);
			if(flag[ch[p][i]])cnt++;
			if(f[ch[p][i]]>mx1)mx2=mx1,mx1=f[ch[p][i]];
			else if(f[ch[p][i]]>mx2)mx2=f[ch[p][i]];
		}
		if(flag[p])f[p]=mx1+max(1,cnt);
		else f[p]=0;
		ans=max(flag[p]+max(cnt-2,0)+mx1+mx2,ans);
	}
} trie;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		cin>>s;
		reverse(s.begin() ,s.end()); 
		trie.change(s); 
	}
	trie.dfs(0);
	cout<<ans; 
	return 0;
}

---

## 作者：pies_0x (赞：1)

# P7537 \[COCI 2016/2017 #4] Rima 题解

## 解题思路

接下来只讨论 $|A|\leq|B|$。

这道题我们先反转字符串将问题中的“后缀” 变为“前缀” 处理。

由于问题涉及“前缀”，我们构造一个 Trie。

接下来思考一下在 Trie 上两个串满足什么条件可以相邻。

第一种情况，两个串长度不同，则两个串长度相差只能为 $1$，而且，$A$ 为 $B$ 的前缀。对应到 Trie 上，就是父子结点。

于是，我们得到第一个结论：**在 Trie 上，父子结点对应的字符串可以相邻**。

第二种情况，两个串长度相同，此时 $A$ 和 $B$ 除最后一个字符外相等即可相邻。 对应到 Trie 上，就是兄弟结点。

于是，我们得到第一个结论：**在 Trie 上，兄弟结点对应的字符串可以相邻**。

我们已经讨论完了所有情况，接下来需要思考的便是如何构造这个最长字符串序列。

---

为使思路更易讲解，接下来提到的 Trie 所有结点对应的字符串至少有一个。

在一个 Trie 中的最长字符串序列有两种情况：

1. 包含根结点。
2. 不包含根节点。

明显第二种情况可以通过递归求得，我们只处理第一种情况。

显然包含根结点的话，根结点的子结点也都可以选择。

注意到子结点与其子结点可以相邻，但是<该子结点的兄弟结点>不能与<该子结点的子结点>相邻，所以，我们要让<该子结点>隔开<该子结点的子结点>与<该子结点的兄弟结点>。

太绕了，画个图吧：

![](https://cdn.luogu.com.cn/upload/image_hosting/tyqaplj1.png)

可是一个点难以隔开三个部分（原有两部分，不能把其他兄弟结点分开形成三个部分），故我们只能让<该子结点的子结点>处于字符串序列的两端。

所以，带孩子的结点只能有两个，并且只能和孩子一起挤在边上。

于是，我们得到的字符串序列长这样：

<子结点 x 的子结点>；<子结点 x>;<一些兄弟结点>；<根结点>；<一些兄弟结点>；<子结点 y>;<子结点 y 的子结点>。

似乎更绕了，再来个图吧：

![](https://cdn.luogu.com.cn/upload/image_hosting/scsv73dp.png)

注意到“子结点的子结点” 也可以是“子结点为根的子树”，但是这个子树是有限制的，这个<子树的子树>与<该子结点的兄弟>不可相邻，同样的也是<子树的子树>的每个结点与<该子结点的兄弟>都不满足相邻的条件。

还是给图吧，语言描述真的很困难：

![](https://cdn.luogu.com.cn/upload/image_hosting/2w4b5xvs.png)

所以，我们要保证该子树的根一定要在构成的序列的两端，否则一个结点同样无法隔开三个部分（这次是不能隔开子树根的兄弟结点）。

要保证这个，我们需要使该子树根只有一个子结点包含其子树。

## 具体实现

注意到思路中每个结点要处理两个信息：

- 它的子结点中**至多两个子结点**可以包含其子树的情况下，字符串序列的最长长度。
- 它的子结点中**至多一个子结点**可以包含其子树的情况下，字符串序列的最长长度。

显然，两个信息都可以初始化为所有结点都不包含其子树时，字符串序列的最长长度。

然后，找到每个子结点中，让其包含子树后可以提供的更多贡献最多的两个结点。

最大结点和次大结点在第一种情况下都要包含其子树。

第二种情况下显然只有最大结点包含其子树。

注意到上文思路只讨论了 Trie 所有结点对应的字符串至少有一个的情况，一般情况下需要处理的典型细节便是计算子结点允许包含子树时该子结点对应字符串不存在的情况，**这时候就没有结点可以隔开子树与子结点的兄弟，该子结点不得包含子树**。

直接开始写代码还是比较坐牢，调细节也很折磨，建议看看代码再写：

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;

#define N 500005
#define LEN 3000005

int n;
int idx=1,son[LEN][30],tot[LEN];
int dp1[LEN],dp2[LEN]; // dp1: 信息1 dp2: 信息2

void add(char s[])
{
	int len=strlen(s+1);
	int k=1;
	for(int i=1;i<=len;++i)
		if(son[k][s[i]-'a'+1])
			k=son[k][s[i]-'a'+1];
		else
			k=son[k][s[i]-'a'+1]=++idx;
	++tot[k];
}

void query(int k) // 这里建议好好看看
{
	if(!k)
		return;
	for(int i=1;i<=26;++i) // 先算子结点
		query(son[k][i]);
	int maxs=0,last=0; // 最大值和次大值
	dp1[k]=dp2[k]=tot[k];
	for(int i=1;i<=26;++i)
	{
		// 先初始化为不包含子树
		dp1[k]+=tot[son[k][i]];
		dp2[k]+=tot[son[k][i]];
		if(tot[son[k][i]]) // 注意到要排除没有点隔开不能相邻的两部分的情况，具体两部分是什么请复习思路
		{
			if(dp2[son[k][i]]-tot[son[k][i]]>=maxs)
				last=maxs,
				maxs=dp2[son[k][i]]-tot[son[k][i]];
			else if(dp2[son[k][i]]-tot[son[k][i]]>=last)
				last=dp2[son[k][i]]-tot[son[k][i]];
		}
	}
	dp1[k]+=maxs+last;
	dp2[k]+=maxs;
	for(int i=1;i<=26;++i) // 计算不包含该结点的情况下的最长长度
		dp1[k]=max(dp1[k],dp1[son[k][i]]);
		// 注意到这里不能更新 dp2，因为 dp2 要求需要有一个点来隔开不能相邻的两部分的情况（服务父亲结点的计算），这里如果更新了一个子结点的答案，那么一定不包含该结点
		// 回头注意到上面的 if 还是要特判，因为可能不存在该结点对应的字符串，固然无法满足 dp2 要求，这种情况不得参与计算
}

signed main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
	{
		char<s=new char[LEN];
		scanf("%s",s+1);
		reverse(s+1,s+strlen(s+1)+1);
		add(s);
		delete[] s;
	}
	query(1);
	printf("%d",dp1[1]);
	return 0;
}
```

[Solution record](https://www.luogu.com.cn/record/204226363)\
[First accepted record](https://www.luogu.com.cn/record/204161009)

---

## 作者：fengyaun (赞：0)

## [P7537 Rima](https://www.luogu.com.cn/problem/P7537)

### 分析

根据经验，对于此类题目不难想出应将两个押韵的单词连边，具体实现可以使用 map。

但是我们发现如果将两个押韵的单词连边就会出现环状结构，而环状结构是无法处理的，但是观察到每一个环状结构都是点双联通分量，可以考虑缩点，~~但是我们发现 tarjan 的点双写法不好写，所以不写~~，接下来就是考虑如何缩点的问题了。

我们可以观察一下，便会发现单词的可行的 LCS 的连边是呈树状的。所以可以考虑将单词的可行的 LCS 连边，建成图。

对于每一个单词，我们可以将其放到其两个可行的 LCS 中，使其加一。

然后我们就获得了一个带点权的树，由于我们将每个单词都放到了两个 LCS 中，而且单词不重，所以我们可以将边权设为 $-1$。

然后在 LCS 树上跑树的直径就可以了。

### 代码

```c++
#include<bits/stdc++.h>
using namespace std;

const int N = 1e6 + 10;

int n;

int ans;

int root;

int stamp;

int d[N];

int w[N];

string s[N];

bitset<N> vis;

unordered_map<string, int> to;

vector<int> edge[N];

void dfs(int u, int fa)
{
    vis[u] = true;
    for (auto v : edge[u])
    {
        if (v == fa || v == u) continue;
        d[v] = d[u] + w[v] - 1;
        if (d[v] > d[root]) root = v;
        dfs(v, u);
    }
} 

signed main()
{
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> s[i];
    for (int i = 1, l; i <= n; i++)
    {
        string cur = "";
        l = s[i].size();
        for (int j = 1; j < l; j++) cur += s[i][j];
        if (to[s[i]] == 0) to[s[i]] = ++stamp;
        if (to[cur] == 0) to[cur] = ++stamp;
        w[to[s[i]]]++;
        w[to[cur]]++;
    }
    for (int i = 1; i <= n; i++)
    {
        int l = s[i].size();
        string cur = "";
        for (int j = 1; j < l; j++) cur += s[i][j];
        edge[to[s[i]]].push_back(to[cur]);
        edge[to[cur]].push_back(to[s[i]]);
    }
    for (int i = 1; i <= stamp; i++)
    {
        if (vis[i]) continue;
        root = i;
        d[i] = w[i];
        dfs(i, 0);
        d[root] = w[root];
        dfs(root, 0);
        ans = max(ans, d[root]);
    }
    cout << ans;
    return 0;
}
```

---

## 作者：meifan666 (赞：0)

### 题目大意
两个单词押韵当且仅当它们的最长公共后缀的长度至少是其中较长单词的长度减一，求最长押韵序列的长度。
### 思路
看到前缀或后缀，不难想到建一棵字典树。因为后缀比较难维护，于是我们把字符串反转后建树，显然这个操作并不影响答案。

根据题意，我们发现当两个字符串押韵时，它们的末尾在字典树上，要么是父子，要么是兄弟，我们只讨论作为末尾的节点。为了使序列长度最长，当一个节点及其儿子被选时，它的其他儿子必然被选。

要是节点的儿子还能这样操作呢？我们可以发现，当一个节点选了多个儿子时，最多只有两个儿子可以继续往下递归。于是我们可以统计每个儿子的贡献值，并选取最大的两个。

整理一下思路，我们发现最终的答案是字典树上一条最长链及其儿子的总节点数，这就可以用树型
dp
解决了。

下面贴上代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n, ans;
int cnt, tr[3001000][30];
int dp[3001000][5];
int sum[3001000];
string x;
int get_int(char c) {
	return c - 'a';
}
void build(string s) {
	int len = s.size(), now = 0;
	for (int i = len - 1; i >= 0; i--) {
		if (tr[now][get_int(s[i])]==0)tr[now][get_int(s[i])] = ++cnt;
		now = tr[now][get_int(s[i])];
	}
	sum[now]++;
}
void DFS(int x) {
	dp[x][1]+=sum[x],dp[x][0]+=sum[x];
	int max1 = 0, max2 = 0, max1t = 0, max2t = 0;
	for (int i = 0; i < 26; i++) {
		if (tr[x][i]) {
			dp[x][1] += sum[tr[x][i]];
			dp[x][0] += sum[tr[x][i]];
			DFS(tr[x][i]);
			if(sum[tr[x][i]]==0)continue;
			if(dp[tr[x][i]][0]>max2||
				(dp[tr[x][i]][0]==max2&&sum[max2]>sum[tr[x][i]])){
				max2=dp[tr[x][i]][0];
				max2t=tr[x][i];
			}
			if(max2>max1){
				swap(max1,max2);
				swap(max1t,max2t);
			}
		}
	}
	dp[x][1] += max1 + max2, dp[x][0] += max1;
	if(max2t)dp[x][1]-=sum[max2t];
	if(max1t)dp[x][1]-=sum[max1t],dp[x][0]-=sum[max1t];
	ans = max(ans, max(dp[x][1], dp[x][0]));
}
signed main() {
	cin >> n;
	while (n--) {
		cin >> x;
		build(x);
	}
	DFS(0);
	if(ans==0)ans=1;
	cout << ans;
	return 0;
}
```

---

## 作者：我梦见一片焦土 (赞：0)

# [题目传送门](https://www.luogu.com.cn/problem/P7537)

[双倍经验](https://www.luogu.com.cn/problem/P4471)

# 思路：

容易想到，将字符串翻转一下，后缀就变成了前缀，然后将字符串挂到字典树上。

如果要满足两个字符串的最大公共前缀长度大于等于最长的字符串的长度 $-1$，只有两种情况。

设字符串为 $S$，字符为 $C$。那么只可能是 $S+C_1$ 和 $S+C_2$ 或者 $S$ 和 $S+C$。设 $dp_u$ 为以字符 $u$ 为结尾的字符串中，押韵字符串的最大数量。

对于一个字符串，要找最大押韵序列，它可以从自己的子节点转移过来，但是不能所有的节点都转移过来，只能有两个。

最中间的字符串找到的最大的押韵序列，就是它子节点中最大的两个孩子的数量之和。

同时，它也可以用剩余孩子，但是不能用它们的孩子。所以对于 $u$，它的最大值就是最大的两个孩子的数量加自己加剩余有的孩子的数量。

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=3e6+10;
const int INF=0x3f3f3f3f;
char s[N];
int n,ans;
struct node{
	int tr[N][26],c[N],dp[N],ix=0;
	void insert(char s[]){
		int u=0,len=strlen(s);
		for(int i=len-1;i>=0;i--){
			int v=s[i]-'a';
			if(!tr[u][v]){
                tr[u][v]=++ix;
            }
			u=tr[u][v];
		}
		c[u]++;
	}
	void dfs(int u){
		int m1=0,m2=0,cnt=0;
		for(int i=0;i<26;i++){
			int v=tr[u][i];
			if(!v){
                continue;
            }
			dfs(v);
			cnt+=c[v];
			if(dp[v]>m1){
				m2=m1;
				m1=dp[v];
			}else if(dp[v]>m2){
				m2=dp[v];
			}
		}
		if(c[u]){
			dp[u]=m1+max(cnt,1ll);
        }
		ans=max(ans,m1+m2+max(0ll,cnt-2)+c[u]);
	}
}tr;
signed main(){
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>s;
		tr.insert(s);
	}
	tr.dfs(0);
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：homo_snow (赞：0)

先来分析一下 $\operatorname{LCS}(A,B) \ge \max(|A|,|B|) - 1$ 这个条件。

1. 两个字符串 $A$，$B$ 间只有首字符不同。
2. 短的那个字符串是长的那个字符串的后缀且二者长度相差 $1$。
3. 两个字符串完全相同。

但由于保证两个字符串完全不相同，所以第三种可能排除。

考虑将字符串反转，使得后缀变成前缀，再丢进 trie 树里，这个时候如果两个字符串符合题目条件，他们树的形态一定是这样的：

![其一](https://pic.imge.cc/2024/08/10/66b6ae751a698.png)

或者：

![其2](https://pic.imge.cc/2024/08/10/66b6ae751a9fb.png)

这个时候就要用到树形 DP 了。

设 $f_x$ 为以 $x$ 为根节点的子树中，能够连起来的最大数量。

显然，想要 $f_x$ 最大，就要先选出两个 $f$ 最大的子树 $f_{son_1}$ 和 $f_{son_2}$。设 $siz$ 为以 $x$ 的儿子为单词结尾的单词数量，设 $cnt_x$ 为以当前节点结尾的单词数。

不难得到状态转移方程：

$f_x = \max(f_{son_1}) + siz-1+cnt_x$。

也可求出答案转移公式 $ans = f_{son_1}+f_{son_2}+siz-2+cnt_x$。

最后输出答案就行。

最后附上本人的丑陋代码：


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 7e5+10;
const int INF = 0x3f3f3f3f;
const int base = 509;
const int mod = 1e9+7;

int n, cnt, ans, nxt[N][27], book[N], sum[N] ,f[N];
string s[N];

void update(string s){
	int pos = 0;
	for(int i = 0; i < s.size(); i++){
		int c = s[i] - 'a' + 1;
		if(!nxt[pos][c])nxt[pos][c] = ++cnt;
		pos = nxt[pos][c];
	}
	book[pos]++;
}

void dfs(int x){
	int max1 = 0,max2 = 0,siz = 0;
	for(int i = 1; i <= 26; i++){
		int t = nxt[x][i];
		if(!t) continue;
		dfs(t);
		siz += book[t];
		if(f[t] >= max1) max2 = max1,max1 = f[t];
		else if(f[t] > max2)max2 = f[t];
	}
	ans = max(ans,max1+max2+max(siz-2,0ll)+book[x]);
	if(book[x] == 0) f[x] = 0;
	else f[x] = max1 + max(siz - 1,0ll) + book[x];
}

signed main(){
	scanf("%lld",&n);
	for(int i = 1; i <= n; i++){
		cin >> s[i];
		reverse(s[i].begin(),s[i].end());
		update(s[i]);
	}
	dfs(0);
	printf("%lld\n",ans);
	return 0;
}

```

---

## 作者：lovely_codingcow (赞：0)

## 题意

简单类说就是通过拼接字符串，实现两个字符串之间的最长公共后缀长度恰好是较长的字符串的长度 $-1$。并使得最长公共后缀长度最长。

## 思路

~~随便做即可。~~

首先我们观察到题目要求的是后缀，但是显然求后缀的算法并不是很多，于是我们考虑将其反转。然后题目就变成了求前缀。

反转完我们继续考虑怎么做，对于这种字符串的问题，我们果断猜测使用 Trie 树，或者说字典树。我们先将所有的字符串一起扔到一个字典树里面。

经过了一番的思考，我们发现在树上进行一次 DP 可以完成答案的统计。

于是我们从根据根节点开始往下 DFS 遍历整个 Trie 树。定义状态 $f_i$，我们每一次转移之前先获得子节点中 $f$ 值的最大值和次大值，用来统计答案。同时我们还要统计有多少字符串在子节点中截止。

当我们此时的状态是一个有字符串终结的状态时，我们才进行 $f_i$ 的转移，方程为 $f_i = maxn + \max(cnt,\, 1)$。其中 $maxn$ 是子节点中最大的 $f$ 值，$cnt$ 是子节点中截止的字符串的个数。

然后我们考虑如何统计答案。容易发现，对于每一个状态，其答案是 $maxn + smaxn + e_u + \max(0,\, cnt - 2)$ 其中 $e_u$ 表示在状态 $u$ 终结的字符串数量，$smaxn$ 为次大值，其余同上。

## 代码

```cpp
#include <iostream>
#include <algorithm>

#define int long long

using namespace std;

string str[500009];
int n, nxt[1000009][30], cnt, e[1000009], f[1000009], ans;

void dfs(int u, int dep) {
    int cnt = 0, maxn = 0, smaxn = 0;
    for (int i = 0; i < 26; i++) {
        if (nxt[u][i]) {
            cnt += e[nxt[u][i]];
            dfs(nxt[u][i], dep + 1);
            if (maxn < f[nxt[u][i]]) {
                smaxn = maxn;
                maxn = f[nxt[u][i]];
            } else if (smaxn < f[nxt[u][i]]) {
                smaxn = f[nxt[u][i]];
            }
        }
    }
    if (e[u]) {
        f[u] = maxn + max(cnt, 1LL);
    }
    ans = max(ans, maxn + smaxn + e[u] + max(0LL, cnt - 2));
}

signed main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> str[i];
        reverse(str[i].begin(), str[i].end());
        int p = 0;
        for (char j: str[i]) {
            if (!nxt[p][j - 'a']) {
                nxt[p][j - 'a'] = ++cnt;
            }
            p = nxt[p][j - 'a'];
        }
        e[p] += 1;
    }
    dfs(0, 0);
    cout << ans;
}
```

---

## 作者：jamesharden666 (赞：0)

# luogu p7537

## 题目思路

看到后缀，就可以将其翻转并建一颗字典树。

然后考虑在字典树上进行 dp。

![](https://cdn.luogu.com.cn/upload/image_hosting/6hrus95j.png)

染色的点就代表这是一个字符串的结尾。

通过题目，我们可以得知两个字符串的长度的绝对值不能超过 $2$，并且还得有相同前缀,所以一个点只能与其父亲和兄弟节点相连。

设 $f_u$ 代表以 $u$ 结尾的字符串为开头的序列长最多为多少，序列中的字符串仅在 $u$ 的子树中选取。

当前答案就为 $u$ 的子树的直径长与 $u$ 的儿子中不在直径的数量。

也就是两个最大的 $f_v$ 以及其它的儿子数。

其中能对答案做出贡献的点都是染色的点，没染过色的点 $f$ 值就为 $0$。

## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,f[3000000+10],cnt=1,ans=0;
char s[3000000+10];
struct node
{
    int flag;
    int son[26+10];
}t[3000000+10];
void insert()
{
    int root=1,len=strlen(s+1);
    for(int i=1;i<=len;++i)
    {
        int pos=s[i]-'a'+1;
        if(!t[root].son[pos])
            t[root].son[pos]=++cnt;
        root=t[root].son[pos];
    }
    t[root].flag=1;
}
void dfs(int root)
{
    int maxa=0,maxb=0,sum=0,tot=0;
    for(int i=1;i<=26;++i)
        if(t[root].son[i])
        {
            int v=t[root].son[i];
            sum++;
            tot+=t[v].flag;
            dfs(v);
            if(!t[v].flag)
                f[v]=0;
            if(f[v]>maxa)
            {
                maxb=maxa;
                maxa=f[v];
            }
            else if(f[v]>maxb)
                maxb=f[v];
        }
    if(tot==0)
    {
        f[root]=t[root].flag;
        ans=max(ans,f[root]);
    }
    else if(tot==1)
    {
        f[root]=maxa+t[root].flag;
        ans=max(ans,f[root]);
        if(!t[root].flag)
            f[root]=0;
    }
    else
    {
        f[root]=maxa+tot-1+t[root].flag;
        ans=max(ans,maxa+maxb+tot-2+t[root].flag);
        if(!t[root].flag)
            f[root]=0;
    }
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;++i)
    {
        scanf("%s",s+1);
        int l=strlen(s+1);
        for(int j=1;j<=l/2;++j)
            swap(s[j],s[l-j+1]);
        insert();
    }
    dfs(1);
    printf("%d",ans);
    return 0;
}
```





---

## 作者：djh0314 (赞：0)

[**洛谷**](https://www.luogu.com.cn/problem/P7537)。

## 题意

显然。

## 分析

首先，我们要求的是最长公共后缀，这显然并不便于我们分析，因此，我们要做的第一件事就是将我们输入的串翻转。

第二，分析我们条件的性质。

$\operatorname{LCP}(A,B)\ge \max(\left | A \right |,\left | B \right |  )-1$，这代表了什么，我们分析考虑。（下默认 $\left | A \right |\le\left | B \right |$）
1. $\left | A \right |<\left | B \right |-1$，显然不成立。
2. $\left | A \right |=\left | B \right |-1$，当 $A$ 是 $B$ 的前缀时成立。
3. $\left | A \right |=\left | B \right |$，$A$ 与 $B$ 的前 $|A|-1$ 都相同。

由于我们的长度不同以及题目的条件限制，我们显然不能直接线性 DP，因此，我们按照长度分类。

我们发现，由 $A$ 寻找一个长度大于他的符合条件 $B$ 是有 26 种可能的（~~或者更多，因为没有限制都是小写字母~~），但是我们由 $B$ 推至 $A$ 却是唯一的。

这让我们想到了树的性质（考试的时候没有想到 Trie 树，后来发现 Trie 一方面卡空间，另一方面限制了只能是小写字母），因此，我们将 $A$ 到 $A$ 的前 $|A|-1$ 连一条边（后称 $pre_A$）。

怎么连边呢，我们先将所有的 $s_i$ 和 $pre_{s_i}$ 给予一个 hash 值（字符串哈希即可），然后离散化，再进行连边即可，可能时间上会多一个 $\log$，但是无伤大雅，空间却只用开 $2\times n$。

~~~cpp
int cnt=0;
for(int i=1; i<=n; ++i) {
	scanf("%s",s);
	int len=strlen(s);
	ull tot=0;
	for(int j=len-1; j; --j) tot=tot*P+s[j];
	ull pre=tot;
	tot=tot*P+s[0];
	u[i]=tot,v[i]=pre;
	num[++cnt]=u[i],num[++cnt]=v[i];
}
sort(num+1,num+cnt+1);
cnt=unique(num+1,num+cnt+1)-num-1;
for(int i=1; i<=n; ++i) u[i]=lower_bound(num+1,num+cnt+1,u[i])-num;
for(int i=1; i<=n; ++i) v[i]=lower_bound(num+1,num+cnt+1,v[i])-num;
for(int i=1; i<=n; ++i) val[u[i]]=1,lj[v[i]].push_back(u[i]);
~~~


接下来解决重头戏：树形 DP。

找一下最终答案的性质，易于发现的，我们最终答案在长度上要么是单调递降，要么单调递增（与前者相同），要么是先下降后上升。放在树上可以发现，这就是我们垂下的两条链，所以，在大的方向上与树形 DP 求数的直径相同。

接下来是转移答案的过程，我们在分析时一直都忽略了一个问题，在长度相同的时候的合法情况，在树上时，这些长度相同的都会挂在同一个节点之下，这些节点我们直接取来即可，在最后将其重复贡献减去即可。

~~~cpp
inline void dfs(int now) {
	if(vis[now]) return ;//标记是否走过
	vis[now]=1;
	int tot=0;
	for(auto to:lj[now]) {
		if(!val[to]) continue;//不走构造出的不存在的 pre
		dfs(to);
		sec[now]=max(sec[now],mx[to]);
		if(sec[now]>mx[now]) swap(mx[now],sec[now]);
		++tot;
	}
	ans=max(mx[now]+sec[now]+tot-min(tot,2)+val[now],ans);//减去重复贡献
	mx[now]=mx[now]+tot-min(tot,1)+val[now];//继承最长的
}
~~~

在实现时，我们需要遍历每一个节点，包括我们构成的虚点，这样才能保证不漏记。

### 总结一下，这题考验了树形 DP 的转化能力。


---

## 作者：Richard_Whr (赞：0)

提供一个不需要题目特殊性质：保证所有串互不相同的做法。

由于没有数据验证，纯口胡，如果假了请斧正。不过也是通过了这个题的数据。

首先很显然要倒着插进字典树，然后考虑树形 dp。

我们发现两个子树能合并当且仅当都有至少一侧是当前儿子长度的串，否则不能合并。

考虑维护这个两侧的信息来帮助转移合并。

设 $f_{u,0/1/2}$ 表示以 $u$ 为根的子树，有 $0/1/2$ 侧不是符合要求长度的，也就是说不能和别人拼接的。

先不管跟的情况，合并子树：

此时 $f_{u,j}$ 的状态是代表合并了之前所有子树后的信息。

发现就是个背包，需要特别注意 $f_{u,0}+f_{v,2}$ 的合并是不合法的，需要特判（我就被坑了）

最后考虑加入跟的信息。

如果根没有串在这里结束，那好了，全都变成 $0$ 就行了。

如果有且只有一个串，那么 $f_{u,0}$ 只能为 $1$，且 $f_{u,0}+1$ 可以贡献给 $1$ 状态，$2$ 状态一定可以找到中间的一个缝插进去，因为 $2$ 状态至少是两个子树 $1$ 状态的合并。 

如果有两个以上的串，那么 $f_{u,j}+cnt$。

记得添加根之前之后都给答案贡献一次，因为跟即使是虚点也可以作为儿子的中转站。


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=3e6+10,M=26;
int tr[N][M],tot=1;
int f[N][3];
int cnt[N];
char str[N];
int n;
int res;

void insert(char s[])
{
	int u=1;
	for(int i=0;s[i];i++)
	{
		int c=s[i]-'a';
		if(!tr[u][c]) tr[u][c]=++tot;
		u=tr[u][c];	
	} 
	cnt[u]++;
}

void dfs(int u)
{
	int g[3];
	for(int c=0;c<M;c++)
	{
		int v=tr[u][c];
		if(!v) continue;
		dfs(v);
		memset(g,0,sizeof g);
		for(int j=0;j<=2;j++)
		{
			for(int k=0;k<=2 && k+j<=2;k++)
			{
				if(j==0 && k==2) continue;
				g[j+k]=max(g[j+k],f[u][j]+f[v][k]);
			}
		}
		for(int j=0;j<=2;j++) f[u][j]=max(f[u][j],g[j]);
	}
	res=max(res,max(f[u][0],max(f[u][1],f[u][2])));
	if(!cnt[u]) f[u][0]=f[u][1]=f[u][2]=0;
	else if(cnt[u]==1) 
	{
		f[u][1]+=cnt[u],f[u][2]+=cnt[u];
		f[u][1]=max(f[u][1],f[u][0]+cnt[u]);
		f[u][0]=cnt[u];
	}
	else f[u][1]+=cnt[u],f[u][2]+=cnt[u],f[u][3]+=cnt[u];
	res=max(res,max(f[u][0],max(f[u][1],f[u][2])));
}

signed main()
{
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>(str);
		int sz=strlen(str);
		reverse(str,str+sz);
		insert(str);
	}
	
	dfs(1);
	
	cout<<res<<"\n";
	
	return 0;
}
```

---

## 作者：Mortidesperatslav (赞：0)

因为后缀比较难求，所以我们考虑来一个变形。

我们容易发现，其实把每个字符串倒过来，只要把 LCS 换成 LCP 就行了，影响不大。

然后，前缀怎么做，当然是 Trie！我们可以用 Trie 维护字符集，然后我们多加一个信息，记录每个节点是否是一个字符串的末尾。

再然后，写一个简简单单的树形 dp 就好了。

因为递归可能常数过大，可能有一点点悬，所以考虑从字符的加入顺序逆序维护，因为一个节点的父亲总是比这个节点早加入。这样就解决了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int t, q, n, tr[3000005][27], ct[3000005], cnt, ans;
int til[3000005];
int f[3000005], ff[3000005];
string s;
int gvl(char x){//给字符一个非单向的散列值，节省空间
	return x - 97;
}
void ins(string str){//添加一个字符串
	int p = 0, n = str.size();
	for (int i = n - 1; i >= 0; i--){
		int vl = gvl(str[i]);
		if (tr[p][vl] == 0)//新增节点
			tr[p][vl] = ++cnt;
		p = tr[p][vl];
		ct[p]++;
		if (i == 0)
			til[p] = 1;//记录末尾
	}
}
void DPOnTree(){//dp
	int u;
	while (cnt >= 0){
		u = cnt;
		int mx = 0, smx = 0;
		for (char i = 'a'; i <= 'z'; i++){//枚举子节点
			int vl = gvl(i);
			int v = tr[u][vl];
			if (!til[v])
				continue;
			f[u] += til[v];
			if (ff[v] >= mx){
				smx = mx;
				mx = ff[v];
			}else if (ff[v] >= smx)
				smx = ff[v];
		}
		if (til[u])
			ff[u] = f[u] + mx;
		ans = max(ans, mx + smx + f[u] + til[u]);
		cnt--;
	}
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin >> n;
	for (int i = 1; i <= n; i++){
		cin >> s;
		ins(s);
	}
	DPOnTree();
	cout << ans;
}
```

---


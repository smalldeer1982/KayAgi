# 「EZEC-10」序列

## 题目背景

> 精准的解析刻画，是应该首先尝试的突破口。

——command_block 《考前小贴士》

## 题目描述

请问有多少个不同的序列 $a$，满足：
1. $a$ 的长度为 $n$。
2. $a$ 中的元素均为不大于 $k$ 的非负整数。
3. 满足 $m$ 组形如 $(x_i,y_i,z_i)$ 且 $x_i<y_i$ 的限制，每组限制的意义为 $a_{x_i} \oplus a_{y_i} = z_i$ （$\oplus$ 表示按位异或运算）。

两个序列相同，当且仅当它们所有元素均相同。

请输出答案对 $10^9+7$ []($114514\times(114\times5\times14+((1+145)\times(1+4)+(1\times14+5-1+4)))+(114\times514+(11\times(451+4)+(-1+145+14)))$)取模的结果。

## 说明/提示

【样例 $1$ 说明】

共有 $6$ 种序列：$\{0,1,0\},\{0,1,1\},\{0,1,2\},\{1,0,0\},\{1,0,1\},\{1,0,2\}$。

【数据规模与约定】

**本题采用捆绑测试。**

- Subtask 1（1 point）：$n=1$。
- Subtask 2（5 points）：$m=0$。
- Subtask 3（15 points）：$n,m,k\le 5$。
- Subtask 4（10 points）：$z_i=0$。
- Subtask 5（20 points）：$k\le 16$。
- Subtask 6（2 points）：数据随机。
- Subtask 7（47 points）：无特殊限制。

对于 $100\%$ 的数据，$1 \leq n \leq 5 \times 10^5$，$0 \le m \le 5 \times 10^5$，$0 \le z_i<2^{30}$，$1 \leq k< 2^{30}$，$1\le x_i,y_i\le n$。

【提示】

如果你不知道什么是异或，请点击[这里](https://baike.baidu.com/item/%E5%BC%82%E6%88%96#:~:text=%E5%BC%82%E6%88%96%E4%B9%9F%E5%8F%AB%E5%8D%8A,%E8%AE%A4%E4%BD%9C%E4%B8%8D%E8%BF%9B%E4%BD%8D%E5%8A%A0%E6%B3%95%E3%80%82&text=%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%9C%89%E4%B8%89%E7%A7%8D%E6%BC%94%E7%AE%97%E5%AD%90%EF%BC%9AXOR%E3%80%81eor%E3%80%81%E2%8A%95%E3%80%82)。

## 样例 #1

### 输入

```
3 1 2
1 2 1```

### 输出

```
6```

## 样例 #2

### 输入

```
5 1 12
1 2 3
```

### 输出

```
26364```

# 题解

## 作者：lndjy (赞：24)

# 序列 题解

upd:修了一下 LaTeX。

### Subtask 1

答案显然是 $k+1$。

### Subtask 2

根据乘法原理，答案为 $(k+1)^n$。

### Subtask 3

暴力枚举序列每一个数的值然后判断是否满足条件。

### Subtask 4

两个数异或和为 $0$ 就是两个数相等，那么如果把限制加边，答案就是 $k+1$ 的联通块个数次方。

### Subtask 5

根据 Sub 4，可以想到统计每个联通块的方案数乘起来。对于每个联通块，暴力枚举第一个数的值，这样所有数都是确定的。然后判断是否都不大于 $k$。

时间复杂度 $O(nk)$。

### Subtask 6

数据随机，很容易出现无解，输出 $0$ 即可。~~这个 Sub 来源是我原来没意识到这点导致最后一个子任务答案全是 $0$（（（~~

### Subtask 7

延续 Sub 4,5 的想法，我们要快速计算第一个数有多少取值。

因为异或的结合律，所以联通块每一个数都是第一个数异或路径上数的异或和，如果路径上数异或和不唯一则无解。将这些数插入 01 trie，问题就转换为“有多少个数，使它与 trie 树中所有值的异或结果最大值不超过 $x$ ”。

下面，来分析怎么解决这个问题。

我们在 trie 树上 dfs ，用 $dfs(now,d,val)$ 表示处理到了节点 $now$ ，当前为第 $d$ 位，当前值为 $val$ 。对于 trie 树上的每个节点，根据儿子个数讨论。

- 没有儿子，则代表处理到了叶子。此时若值不大于 $x$ ，则返回 $1$ 。否则返回 $0$ 。
- 有两个儿子，则无论当前位填什么数，最大值都会出现在“对面”子树中。因此，我们将当前值加上 $2^d$ ，然后递归处理 $0/1$ 两棵子树。
- 只有一个儿子（假设为 $0$ 儿子），我们判断 $val+2^d$ 不大于 $x$ 是否成立。

1. 若成立，则当前位填 $0$ 时，后面位无论填什么都满足条件，因此填 $0$ 时答案为 $2^d$ ，填 $1$ 时，当前值加上 $2^d$ ，处理 $0$ 儿子。

2. 若不成立，则当前位只能填 $0$ 。当前值不变，处理 $0$ 儿子。

这样，每个节点只会被处理一次。


时间复杂度为 $O(n\log k)$ 。

---

## 作者：绝顶我为峰 (赞：12)

好题。

我们注意到每个限制本质上是一个依赖：因为一个数确定了，另一个数也跟着确定了。这样若干个限制就构成了一个无向图，每个联通块是互相依赖的。

容易想到答案就是每个联通块可行的取值相乘。难点在于每个数不能大于 $k$ 的限制。

我们考虑一个连通块，因为异或有结合律，我们可以把联通块内的限制都集中的到一个点上，即每个数都是由联通块内某个固定的数异或一个值得到，方便处理。

在块内任选一个根 dfs，首先可以把环判掉，如果环的两边走到当前的位置异或和不同就无解了。这样以后块变成了一棵树，有若干个和树根有关的限制，现在我们要计算树根有多少种取值可以让整棵树的最大值小于等于 $k$。

这个问题等价于求异或最大值小于等于 $k$ 的个数，套路地，这种问题往往使用 01-trie 处理。

我们在 trie 上 dfs，借用数位 dp 的思想，记录走到当前位**异或最大值顶上界**的方案，然后分类讨论：

- 如果 $k$ 当前位是 $1$，那么树根怎么选都不会越界，两边分别 dfs，同时修改最大是顶上界的数量，具体地说 $0$ 儿子顶上界的是当树根前位取 $1$ 的方案，另一边同理。

- 如果 $k$ 当前位是 $0$……我们发现我们不知道树根当前位可不可以取 $1$，于是需要多加一个变量表示树根的取值是否顶上界，继续分类讨论：

  - 如果顶上界，因为树根取值也不能超过 $k$，那只能填 $0$，同时要求所有异或出来的值当前位也是 $0$。因此如果当前点有 $1$ 儿子，那就挂了，不计算贡献。否则搜索 $0$ 儿子，顶上界方案数直接继承。
  
  - 如果不顶上界，那么树根当前位 $0,1$ 都可以选。但如果当前点同时有 $0,1$ 两个儿子，那不管树根怎么选，当前位异或值一定出现 $1$，也就挂了，不计算贡献。否则搜索唯一的儿子，此时顶上界的方案数改为固定当前位选 $0/1$ 数量。
  
- 最后，搜索的边界是搜索到了叶子仍然合法，说明当前搜索到的顶上界的方案全部是合法的，于是累加答案。

最后注意一些细节就好了。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
#define int long long
struct edge
{
    int nxt,to,weight;
}e[500001<<1];
const int mod=1000000007;
int n,m,maxn,tot,h[500001],ans,ch[500001*31][2],cnt,tmp[500001];
bool vis[500001];
inline int read()
{
    int x=0;
    char c=getchar();
    while(c<'0'||c>'9')
        c=getchar();
    while(c>='0'&&c<='9')
    {
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x;
}
inline void add(int x,int y,int w)
{
    e[++tot].nxt=h[x];
    h[x]=tot;
    e[tot].to=y;
    e[tot].weight=w;
}
inline void insert(int x)
{
    int node=1;
    for(register int i=30;~i;--i)
    {
        if(!ch[node][(x>>i)&1])
            ch[node][(x>>i)&1]=++cnt;
        node=ch[node][(x>>i)&1];
    }
}
int query(int node,int val,int x,int g,bool tag)
{
    if(!ch[node][0]&&!ch[node][1])
        return val;
    if((maxn>>g)&1)
        return query(ch[node][0],val-(1ll<<g),x,g-1,tag)+query(ch[node][1],1ll<<g,x,g-1,0);
    if(tag)
    {
        if(ch[node][1])
            return 0;
        return query(ch[node][0],val,x,g-1,tag);
    }
    if(ch[node][0]&&ch[node][1])
        return 0;
    if(ch[node][0])
        return query(ch[node][0],val>>1,x,g-1,0);
    return query(ch[node][1],val>>1,x,g-1,tag);
}
void dfs(int k,int val)
{
    vis[k]=1;
    tmp[k]=val;
    for(register int i=h[k];i;i=e[i].nxt)
    {
        if(vis[e[i].to])
        {
            if(val^e[i].weight^tmp[e[i].to])
            {
                puts("0");
                exit(0);
            }
            continue;
        }
        insert(val^e[i].weight);
        dfs(e[i].to,val^e[i].weight);
    }
}
signed main()
{
    n=read(),m=read(),maxn=read();
    ans=1;
    for(register int i=1;i<=m;++i)
    {
        int x=read(),y=read(),w=read();
        add(x,y,w);
        add(y,x,w);
    }
    cnt=1;
    for(register int i=1;i<=n;++i)
        if(!vis[i])
        {
            dfs(i,0);
            ans=ans*query(1,maxn+1,maxn,30,1)%mod;
            for(register int j=1;j<=cnt;++j)
                ch[j][0]=ch[j][1]=0;
            cnt=1;
        }
    printf("%lld\n",ans);
    return 0;
}
```


---

## 作者：lnwzy (赞：12)

如果你这道题一上来就能想到把序列转换成一张图，你就已经成功一半了。~~（可惜我比赛时没想到）~~

首先，我们把题目给的条件转化为一条两个定点为 $x$ 与 $y$，边权为 $z$ 的边，整个序列就变成了一张图。

问题来了：如何迅速地求出每个点的权值？

由于条件不变，两点之间的异或和不变。我们可以在每一个联通块中任选一个起点，计算出起点与联通块中其他每个点的路径异或和。如果一个点沿着两个路径算出了两个权值，那么矛盾，特判输出 $0$。

由于路径异或和不变，一旦确定了起点，每一个点的权值都会确定。本题的核心来了：如何迅速求出起点的值？

如果起点的值异或上每一个点对应的路径权值不大于 $k$，那么这个值合法。利用这个思想，我们可以一边统计路径异或和一边把所有的路径异或和都扔到一颗 $01$ Trie 上，就像这样：

```cpp
void update(int num,int p,int b)
{
	if(b==-1)
	{
		return;
	}
	if(tree[p].son[num/(1<<b)])
	{
		update(num%(1<<b),tree[p].son[num/(1<<b)],b-1);
		return;
	}
	tree[p].son[num/(1<<b)]=++point;
	update(num%(1<<b),point,b-1);
}
int cnt=0;
void dfs1(int now,int a,int fa)
{
	vis[now]=a;
	w[now]=1;
	update(a,0,30);
	for(int i=h[now];i;i=l[i].nxt)
	{
		if(l[i].to==fa)
		{
			continue;
		}		
		if(w[l[i].to])
		{
			if(vis[l[i].to]!=(a^l[i].val))
			{
				cnt=1;
				return;//特判无解退出
			}
			continue;
		}
		dfs1(l[i].to,a^l[i].val,now);	
	}
}
```

现在核心来了：如何迅速求出起点的权值？

先放代码再解释：

```cpp
int dfs2(int now,int b,int s)
{
	if(tree[now].son[0]==0&&tree[now].son[1]==0)
	{
		if(s<=k)
		{
			return 1;	
		}
		return 0;
	}
	int ans=0;
	if(tree[now].son[0]&&tree[now].son[1])
	{
		ans+=dfs2(tree[now].son[0],b-1,s+(1<<b));
		ans+=dfs2(tree[now].son[1],b-1,s+(1<<b));
		ans%=1000000007;
		return ans;
	}
	int p;
	if(tree[now].son[0])
	{
		p=0;
	}else
	{
		p=1;
	}
	if(s+(1<<b)<=k)
	{
		ans+=(1<<b)%1000000007;
		ans+=dfs2(tree[now].son[p],b-1,s+(1<<b));
		ans%=1000000007;
	}else
	{
		ans+=dfs2(tree[now].son[p],b-1,s);	
	}
	return ans;
}
```
$now$ 指当前的节点，$b$指当前的位数，$s$ 指现在积累的权值。

从根节点开始遍历，每一个点都有三种情况：没有子节点，有一个子节点，有两个子节点。

当当前节点没有子节点时，遍历结束，进行判断，如果 $s$ 不比 $k$ 大，遍历成功，返回 $1$，否则返回 $0$。

当当前节点有一个子节点时，判断 $s$ 加 $2$ 的 $b$ 次方是否不大于 $k$，如果不大于 $k$ 这一位就既可以与当前位的数相同，又可以与当前位的数不同，当与当前位的数相同时，异或值为 $0$，后面数的异或值最大为 $2$ 的 $b$ 次方减 $1$，明显不超过 $k$，一共有 $2$ 的 $b$ 次方个数， $ans$ 加 $2$ 的 $b$ 次方，当当前位与当前值不同时，$s$ 加上 $2$ 的 $b$ 次方，继续向下统计。如果大于 $k$，说明只能与当前位相同，向下遍历。

当当前节点有两个子节点时，无论与哪个子节点的值相同，异或上另一个子节点的值都会为一，直接把累计值加上 $2$ 的 $b$ 次方后向下遍历即可。

最后放全代码：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
struct node1
{
	int son[3];
}tree[15000005];
struct node2
{
	int to;
	int val;
	int nxt;
}l[1000005];
int tot=0,h[500005],vis[500005],w[500005];
void add(int x,int y,int z)
{
	l[++tot].to=y;
	l[tot].val=z;
	l[tot].nxt=h[x];
	h[x]=tot;
}
int point=0;
void update(int num,int p,int b)
{
	if(b==-1)
	{
		return;
	}
	if(tree[p].son[num/(1<<b)])
	{
		update(num%(1<<b),tree[p].son[num/(1<<b)],b-1);
		return;
	}
	tree[p].son[num/(1<<b)]=++point;
	update(num%(1<<b),point,b-1);
}
int cnt=0;
void dfs1(int now,int a,int fa)
{
	vis[now]=a;
	w[now]=1;
	update(a,0,30);
	for(int i=h[now];i;i=l[i].nxt)
	{
		if(l[i].to==fa)
		{
			continue;
		}		
		if(w[l[i].to])
		{
			if(vis[l[i].to]!=(a^l[i].val))
			{
				cnt=1;
				return;
			}
			continue;
		}
		dfs1(l[i].to,a^l[i].val,now);	
	}
}
int k;
int dfs2(int now,int b,int s)
{
	if(tree[now].son[0]==0&&tree[now].son[1]==0)
	{
		if(s<=k)
		{
			return 1;	
		}
		return 0;
	}
	int ans=0;
	if(tree[now].son[0]&&tree[now].son[1])
	{
		ans+=dfs2(tree[now].son[0],b-1,s+(1<<b));
		ans+=dfs2(tree[now].son[1],b-1,s+(1<<b));
		ans%=1000000007;
		return ans;
	}
	int p;
	if(tree[now].son[0])
	{
		p=0;
	}else
	{
		p=1;
	}
	if(s+(1<<b)<=k)
	{
		ans+=(1<<b)%1000000007;
		ans+=dfs2(tree[now].son[p],b-1,s+(1<<b));
		ans%=1000000007;
	}else
	{
		ans+=dfs2(tree[now].son[p],b-1,s);	
	}
	return ans;
}
int main()
{
	int n,m;
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=m;i++)
	{
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		add(x,y,z);
		add(y,x,z);
	}
	long long fans=1;
	for(int i=1;i<=n;i++)
	{
		if(w[i]==0)
		{
			for(int j=0;j<=point;j++)
			{
				tree[j].son[0]=tree[j].son[1]=0;
			}
			point=0;
			dfs1(i,0,0);
			if(cnt)
			{
				printf("0");//特判无解
				return 0;
			}
			fans=fans*dfs2(0,30,0)%1000000007;//进行排列组合
		}
	}
	printf("%lld",fans);
	return 0;
}
```

---

## 作者：云浅知处 (赞：8)

很好的题。

首先条件可以转化为 $a_{y_i}=a_{x_i}\oplus z_i$，因此 $a_{x_i}$ 一旦确定了，那么 $a_{y_i}$ 同样也就确定了。

我们考虑连边：对于每条限制 $(x_i,y_i,z_i)$，我们在 $x_i,y_i$ 间连双向边，边权为 $z_i$。

那么对于一个连通块，只要一个数确定了，所有数就都确定了。只需要计算每个连通块的答案然后乘起来就行了。

我一开始以为答案就是 $k+1$，但是思考之后发现，尽管 $a_{x_i}\le k,z_i\le k$，$a_{x_i}\oplus z_i$ 的值仍然可能 $> k$。

因此问题就变为：对于每个连通块，随便选一个点 $x$，你需要求出有多少个值是「合法」的，即：对于每条 $x\to p$ 的链，链上的边权异或和与 $a_x$ 的取值异或得到的值不能超过 $k$。

直接枚举 $[0,k]$ 内的所有取值，复杂度 $O(nk)$。这就是我半年前场上的做法（

实际上可以注意到，对于一个点 $p$，对于任意一条 $x\to p$ 的路径，其边权异或和必然相同；否则答案即为 $0$。

我们可以对每个点 $p$ 求出 $x\to p$ 路径上的边权异或和，然后把这些数全都放进一个 $\text{01-Trie}$ 里。

现在就相当于要求出：有多少个数，使得它与 $\text{Trie}$ 内的所有数中异或最大值不超过 $k$。

我们从根开始往下走，依次决定每一位应该选什么。

取到第 $i$ 位时记录此时异或最大值 $S$，然后讨论这一位上能否选 $0/1$：

- 如果 $S>k$，那么直接递归终止，然后 `return` 回去。

- 当前节点有两个子节点：那么不管现在取什么都必然会出现一个 $1$。因此直接令 $S$ 加上 $2^i$，往左右子树递归即可。
- 当前节点有一个子节点：那么如果在这一位上选了相同的数，$S$ 至多加上 $2^i-1$。如果 $S+2^i-1\le k$ 那么肯定可以，因此可以直接将答案加上 $2^{i-1}$，同时将 $S$ 加上 $2^i$（相当于这一位上取了相反的数），继续递归；否则这一位上必然不能取不同的值，那么直接往相同方向递归即可。
- 当前节点是叶子结点：那么如果 $S\le k$ 就返回 $1$，否则为 $0$。

这样一来，我们相当于只遍历了一次 $\text{Trie}$，总的复杂度就是 $O(n\log V)$。其中 $V=2^{30}$ 为值域。

然后就做完了。

```cpp
#include<bits/stdc++.h>

#define int long long

using namespace std;

inline int read(){
	int x=0,f=1;char c=getchar();
	for(;(c<'0'||c>'9');c=getchar()){if(c=='-')f=-1;}
	for(;(c>='0'&&c<='9');c=getchar())x=x*10+(c&15);
	return x*f;
}

const int MN=5e5+5;
const int mod=1e9+7;
int n,m,k;

struct Trie{
	int d[MN<<5][2],tot;

	void clear(){
		for(int i=1;i<=tot;i++)d[i][0]=d[i][1]=0;
		tot=1;
	}

	void ins(int x){
		int p=1;
		for(int i=30;i>=0;i--){
			int c=(x>>i)&1;
			if(!d[p][c])d[p][c]=++tot;
			p=d[p][c];
		}
	}

	int query(int p,int S,int w){
		if(S>k)return 0;
		if(w<0)return 1;
		if(d[p][0]&&d[p][1])return (query(d[p][0],S+(1ll<<w),w-1)+query(d[p][1],S+(1ll<<w),w-1))%mod;
		else{
			int q=(d[p][0]|d[p][1]);
			if(S+(1ll<<w)-1<=k)return (query(q,S+(1ll<<w),w-1)+(1ll<<w))%mod;
			else return query(q,S,w-1);
		}
	}
}tree;

struct Edge{
	int to,cost;
	Edge(int T,int C):to(T),cost(C){}
	Edge(){}
};
vector<Edge>G[MN];
int dis[MN];
bool vis[MN];

void dfs(int u){
	vis[u]=1,tree.ins(dis[u]);
	for(auto e:G[u]){
		int v=e.to,w=e.cost;
		if(vis[v]&&(dis[v]!=(dis[u]^w))){puts("0");exit(0);}
		if(vis[v])continue;
		dis[v]=(dis[u]^w),dfs(v);
	}
}

signed main(void){

#ifndef ONLINE_JUDGE
	freopen("in.in","r",stdin);
#endif		

	n=read(),m=read(),k=read();
	for(int i=1;i<=m;i++){
		int x=read(),y=read(),z=read();
		G[x].push_back(Edge(y,z)),G[y].push_back(Edge(x,z));
	}

	int ans=1;
	for(int i=1;i<=n;i++){
		if(!vis[i])tree.clear(),dfs(i),ans=ans*tree.query(1,0,30)%mod;
	}
	cout<<ans<<endl;

	return 0;
}
```

---

## 作者：pocafup (赞：6)

验题人水题解

首先考虑没有任何限制条件。可以发现答案就是 $(k+1)^n$。

我们可以将每组限制当做一条边权为 $c$ 的双向边。由于边的特殊限制，当一个连通块中的某一个数字被确认了，我们可以直接确认整合连通块里的数字。

对于每个连通块，我们可以随机选取一个节点当做根，并且求出到所有其他节点的异或和。如果某一个连通块的异或和与题目不符，那么将不可能存在答案。

注意到连通块之间不会造成影响，因此我们只需要将每个连通块可以取值的数量算出并乘起来即可得到答案。

考虑将一个连通块里从根节点出发的所有异或和丢进 trie 内，然后你就会发现跟[这题](https://www.luogu.com.cn/problem/solution/P6824)的 trie 做法非常相似。

从最高位开始填数，我们只需要保证任何时候答案不大于 $k$ 即可，具体填法参考官方解法。

注意题目其实有一个坑点，就是这个题目的 trie 节点数实际上是 $n\log z$ 级别，严格意义上来说 trie 的空间需要开刀 $10^7+5
\times 10^6$，但题目的数据并没有卡满，而我们又开大了空间限制，所以最后决定不改数据范围（

```cpp
const int MAXN = 5e6+5;
const int MAXM = 5e6+5;
const int MAXL = 25;
const int MAXA = 23;
const ll mod = 1e9+7;
int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1};
ll n,m,t,l,k,a,b,c,pos[MAXN],dist[MAXN];
ll ans=1LL;
namespace AdjEdge{
  //var
  int head[MAXN],tot;
  struct Edge{
    int u,v,d,nxt;
  }edge[MAXM<<1];
  inline void add(int u, int v, int d=0){
    edge[++tot].u = u;
    edge[tot].v = v;
    edge[tot].d = d;
    edge[tot].nxt = head[u];
    head[u] = tot;
  }
}
using namespace AdjEdge;
namespace Trie{
  int cnt,sz;
  int ch[MAXN][3];
  inline void trie(){
		For(i,1,sz) ch[i][0] = ch[i][1] = 0;
		sz = 2;
  }
  inline void insert(int s){
    int u = 1;
    for (int i=30;i>=0;i--){
      int c = (s>>i) & 1;
      if (!ch[u][c]) ch[u][c] = sz++;
      u = ch[u][c];
    }
  }

}
using namespace Trie;
bool vis[MAXN];
inline void dfs(int u){
	insert(dist[u]);
	vis[u] = true;
	trav(i,u){
		int v = edge[i].v, d = edge[i].d;
		if (dist[v]!=-1 && (dist[u]^d)!=dist[v]) {
			cout << 0;
			exit(0);
		}//判无解
		dist[v] = dist[u]^d;
		if (!vis[v])dfs(v);
	}
}
inline ll dfs2(ll now, ll d, ll value){
	if (!ch[now][0] && !ch[now][1]) return value<=k;
	if (ch[now][0] && ch[now][1]) return dfs2(ch[now][0],d-1,value+qpow(2,d))+dfs2(ch[now][1],d-1,value+qpow(2,d));
	if (ch[now][0]){
		if (value+qpow(2,d)<=k) return qpow(2,d)+dfs2(ch[now][0],d-1,value+qpow(2,d));
		else return dfs2(ch[now][0],d-1,value);
	}else{
		if (value+qpow(2,d)<=k) return qpow(2,d) + dfs2(ch[now][1],d-1,value+qpow(2,d));
		else return dfs2(ch[now][1],d-1,value);
	}
}//填数方法
signed main(){
  n = read(); m = read(); k = read();
  For(i,1,m){
    a = read(); b = read(); c = read();
    add(a,b,c);
    add(b,a,c);
  }
	mem(dist,0xff);
	For(i,1,n) if (!vis[i]) {
		if (!head[i]) {ans = (ans*1LL*(k+1LL))%mod; continue;}
		trie(),dist[i] = 0,dfs(i);
		ans = (1LL*ans*dfs2(1,30,0))%mod;
	}
	cout << ans;
}
```

---

## 作者：123456xwd (赞：3)

按照题目的限制连边，$(x,y,z)$，构成若干个连通块。

每个连通块中取一个点作为根开始遍历，遍历到的每个点都有一个边权的异或和。

设这些和的集合为 $S$，相当于要找有多少个 $a \in[0,k]$，使得 $a\oplus x\in[0,k](x\in S)$。

考虑建立出 01-trie，然后在上面递归，设 $f(now,d,val)$ 表示当前在第 $now$ 个节点，处理到了第 $d$ 位，当前找出来的最大值为 $val$。

1. 为叶子节点，返回 $[val\le k]$。
2. 若有两个儿子，显然不论这里填写 $1$ 还是 $0$，都会造成最大值增加 $2^d$，递归两个子树即可。
3. 若只有一个儿子，设儿子为 $0$ 儿子，若 $val+2^d\le k$，代表若当前填写 $0$ 的话，剩下的选啥都可以（贡献 $2^{d}$ 的方案），若当前填写 $1$ 的话，继续处理 $0$ 儿子即可（$val\to val+2^d$）；否则当前位只能填写 $0$ 了。

时间为 $\mathcal{O}(n\log k)$。
```c++
#include<bits/stdc++.h>
#define ull unsigned long long
#define int long long
#define p_b push_back
#define m_p make_pair
#define pii pair<int,int>
#define fi first
#define se second
#define ls k<<1
#define rs k<<1|1
#define mid ((l+r)>>1)
#define gcd __gcd
#define lowbit(x) (x&(-x))
using namespace std;
int rd(){
    int x=0,f=1; char ch=getchar();
    for(;ch<'0'||ch>'9';ch=getchar())if (ch=='-') f=-1;
    for(;ch>='0'&&ch<='9';ch=getchar())x=(x<<1)+(x<<3)+(ch^48);
    return x*f;
}
void write(int x){
    if(x>9) write(x/10);
    putchar('0'+x%10);
}
const int N=5e5+5,INF=0x3f3f3f3f3f3f3f3f,mod=1e9+7;

int ch[N*31][2],tot=1;
void insert(int x){
	int u=1,tmp;
	for(int i=30;i>=0;i--){
		tmp=((x>>i)&1);
		if(!ch[u][tmp]) ch[u][tmp]=++tot;
		u=ch[u][tmp];
	}
}
int n,m,k;
vector<pii> G[N];
bool vis[N];
int dis[N];
void dfs(int u){
	vis[u]=1;insert(dis[u]);
	for(auto i : G[u]){
		int v=i.fi,w=i.se;
		if(vis[v]){//判断无解
			if(dis[v]^dis[u]^w){
				puts("0");
				exit(0);
			}
		}
		else{
			dis[v]=dis[u]^w;
			dfs(v);
		}
	}
}

int f(int now,int d,int val){
	if(d<0) return (val<=k);
	if(!ch[now][0]&&!ch[now][1]) return (val<=k);
	if(ch[now][0]&&ch[now][1]){
		val+=(1ll<<d);
		if(val>k) return 0;
		return (f(ch[now][0],d-1,val)+f(ch[now][1],d-1,val))%mod;
	} 
	int u=ch[now][0]|ch[now][1];
	if(val+(1ll<<d)<=k){
		val+=(1ll<<d);
		return ((1ll<<d)%mod+f(u,d-1,val))%mod;
	}
	return f(u,d-1,val);
}

signed main(){
	n=rd(),m=rd(),k=rd();
	for(int i=1;i<=m;i++){
		int u=rd(),v=rd(),w=rd();
		G[u].p_b(m_p(v,w));
		G[v].p_b(m_p(u,w));
	}
	int ans=1;
	for(int i=1;i<=n;i++){
		if(vis[i]) continue;
		dfs(i);
		ans*=f(1,30,0);
		ans%=mod;
		for(int i=1;i<=tot;i++) ch[i][0]=ch[i][1]=0;
		tot=1;
	}
	printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：_YyD_ (赞：2)

**题目大意:**

求有多少个长度为 $n$ 的序列 $a$ 满足，都在 $[0,k]$ 的范围内且满足 $m$ 个限制形如：
$$
a_x \bigoplus a_y  = z 
$$
**数据范围:**
$$
0 \le n, m \le 5\times10^5, 0 \le k < 230
$$

**解题思路:**

首先假设有合法方案，那么对于一个位置 $a_x$ 确定之后与它直接或间接限制的 $a_y$ 都将被确定。

我们可以设限制为一条边，然后先 dfs 判断一次是否限制之间没有冲突。

然后考虑对于每个联通块我们随意找到一个位置 $x$，那么其他的点都将被表达为:
$$
a_x \bigoplus w
$$
的形式。

然后我们要求找到有多少个 $a_x$ 满足对于所有的 $w$ 都有:
$$
a_x \bigoplus w \le k
$$
这个可以用 Trie 来做，每次封闭的是一个子树，直接处理就好了。

**时间复杂度:**

$O(n \log k)$

**Code:**

```cpp
#include<bits/stdc++.h>
#define _ ios::sync_with_stdio(false),cin.tie(0),cout.tie(0)
#define rep(i,l,r) for(long long i=l;i<=r;i++)
#define lep(i,l,r) for(long long i=l;i>=r;i--)
#define ll long long
#define ull unsigned long long
using namespace std;
const ll N=5e5+10,P=1e9+7;
struct node{
	ll to,next,w;
}a[N<<1];
ll n,m,k,tot,ls[N],z[N];
ll cnt,t[N][2],res,ans=1;
bool v[N];stack<ll > s;
void addl(ll x,ll y,ll w){
	a[++tot].to=y;
	a[tot].next=ls[x];
	ls[x]=tot;a[tot].w=w;
	return;
}
bool dfs(ll x){
	v[x]=1;s.push(z[x]);
	for(ll i=ls[x];i;i=a[i].next){
		ll y=a[i].to;
		if(v[y]){
			if((z[x]^a[i].w)!=z[y])
				return 1;
		}
		else{
			z[y]=z[x]^a[i].w;
			if(dfs(y))return 1;	
		}
	}
	return 0;
}
void Limit(ll &x,ll w,ll p){
	if(x==-1||p<0)return;
	if(!x){x=++cnt;t[x][0]=t[x][1]=0;}
	if((k>>p)&1)Limit(t[x][(w>>p)&1^1],w,p-1);
	else{
		t[x][(w>>p)&1^1]=-1;
		Limit(t[x][(w>>p)&1],w,p-1);
	}
	return;
}
void Count(ll x,ll L,ll R){
	if(L>k)return;
	if(x==-1)res-=min(R,k)-L+1;
	if(x<=0)return;
	ll mid=(L+R)>>1;
	Count(t[x][0],L,mid);
	Count(t[x][1],mid+1,R);
	return;
}
signed main()
{
	scanf("%lld%lld%lld",&n,&m,&k);
	rep(i,1,m){
		ll x,y,w;
		scanf("%lld%lld%lld",&x,&y,&w);
		addl(x,y,w);addl(y,x,w);
	}
	res=0;
	rep(i,1,n){
		if(v[i])continue;cnt=t[0][0]=0;
		if(dfs(i))return puts("0")&0;
		while(!s.empty())Limit(t[0][0],s.top(),29),s.pop();
		res=k+1;Count(1,0,(1<<30)-1);
		ans=ans*res%P;
	}
	printf("%lld\n",ans);
	return 0;
}
```
**注明:**
思路来自 QuantAsk 。

---

## 作者：Utilokasteinn (赞：1)

## [Link](https://www.luogu.com.cn/problem/P7717)

不知道这题跟数位 dp 有什么关系……

容易发现对于一组 $(x_i,y_i,z_i)$，当 $a_{x_i}$ 确定时，$a_{y_i}$ 也确定了。也就是说，当 $a_{pos}$ 确定时，所有和 $a_{pos}$ 有关的 $a_{x_i}$ 或 $a_{y_i}$ 也确定了。

我们把它建成一个图，$x_i$ 和 $y_i$ 为点，$z_i$ 为边权。设 $div_{u,v}$ 表示点 $u$ 到 点 $v$ 的路径异或和。

容易发现，只要对于连通块中任意一个点赋一个值，那么其他的点也都会确定。

现在假设找到一个联通块，任取一个点 $u$，赋值为 $val$。那么对于连通块中另外任意点 $v$，值都为 $val⊕dis_{u,v}$。显然，若一个点有多个点权，那么这个序列显然构不成。

我们可以将点 $u$ 的值赋为 $[0,k]$ 中的任意整数。但是有些值可能会使得一些点 $v$ 的值大于 $k$。

最简单的方法是枚举 $u$ 的值，然后一一判断其他点 $v$ 满不满足。时间复杂度 $\mathcal{O}(nk)$。

再观察一下题目。我们已经求出了 $dis_{u,v}$，而现在我们需要找出满足 $val⊕dis_{u,v}\le k$ 的 $val$ 的个数。

这个东西可以用 $\tt Trie$ 树来做。

我们把所有 $dis_{u,v}$ 丢进一个 $\tt 01-Trie$ 里，然后遍历 $\tt Trie$ 即可。

时间复杂度 $\mathcal{O}(n\log k)$。

代码如下：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define mod 1000000007
using namespace std;
inline int read()
{
	int s=0;char c=getchar();
	for(;!isdigit(c);c=getchar());
	for(;isdigit(c);c=getchar())
		s=s*10+c-'0';
	return s;
}
int n,m,k,ans=1;
int tot,head[500005];
struct edge{
	int to,dis,nxt;
}e[1000005];
bool vis[500005];
int dis[500005];
int cnt=1,son[500005*30][2];
inline void add(int u,int v,int w)
{
	e[++tot].to=v;
	e[tot].dis=w;
	e[tot].nxt=head[u];
	head[u]=tot;
}
inline void insert(int x)
{
	int u=1;
	for(int i=30;i>=0;i--)
	{
		int ch=(x>>i)&1;
		if(!son[u][ch])son[u][ch]=++cnt;
		u=son[u][ch];
	}
}
int query(int u,int x,int w)
{
	if(x>k)return 0;
	if(w<0)return 1;
	if(son[u][0]&&son[u][1])
		return (query(son[u][0],x+(1<<w),w-1)+query(son[u][1],x+(1<<w),w-1))%mod;
	//query(son[u][0],x+(1<<w),w-1)：第w位选1
	//query(son[u][1],x+(1<<w),w-1)：第w位选0 
	int v=max(son[u][0],son[u][1]);
	if(x+(1<<w)<=k)
		return (query(v,x+(1<<w),w-1)+(1<<w))%mod;
	//第w位选0选1都可以 
	return query(v,x,w-1);//第w位只能选相反的那一个 
}
void dfs(int u)
{
	vis[u]=true;
	insert(dis[u]);
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].to;
		if(vis[v]&&dis[v]!=(dis[u]^e[i].dis))
		{
			printf("0\n");
			exit(0);
		}
		if(vis[v])continue;
		dis[v]=dis[u]^e[i].dis;
		dfs(v);
	}
}
int main()
{
	n=read(),m=read(),k=read();
	for(int i=1;i<=m;i++)
	{
		int u=read(),v=read(),w=read();
		add(u,v,w),add(v,u,w);
	}
	for(int i=1;i<=n;i++)
		if(!vis[i])
		{
			dfs(i);
			ans=1ll*ans*query(1,0,30)%mod;
			for(int j=1;j<=cnt;j++)
				son[j][0]=son[j][1]=0;
			cnt=1;
		}
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：xiahaob (赞：0)

## solution

直接将限制改成连边。具体而言，就是将 $x_i$ 向 $y_i$ 连一条值为 $z_i$ 的边。

然后发现，判断无解是容易的。对于一个连通块。钦定一个根。然后由它出发。计算到达每一个点的路径的异或和。那么意思就是说只要确定了根的值。那么这个连通块的值就全部确定了。

那么这个问题就可以抽象成现在有一些数。要求出有多少个数 $v\in[1,k]$ 跟这些数的异或和全部小于 $k$。

直接看最大值就行了。按位考虑。将这些边权异或和的值建一颗 trie 树。

计一个状态为 $(p,b,val)$。表示在 trie 树上 $p$ 这个点，当前在 $b$ 这一位，同时对于**一些数** $v$ 与 trie 树上的所有数在 $b$ 位之前的最大值为 $val$。考虑将这些数 $v$ 能否对答案产生贡献。

- $p$ 为叶子节点。如果 $val\le k$，返回 $1$，否则返回 $0$。
- $p$ 只有 $1$ 个儿子节点。判断 $val+2^{b}-1\le k$。如果小于等于，那么答案可以增加 $2^b$。因为可以后面可以随便乱填。在 $b$ 这位和当前这位的值相同的时候。递归到 $(son,b-1,val+2^b)$。否则递归到 $(son,b-1,val)$。

- 如果 $p$ 有两个儿子。那么说明这一位无论是什么。都会对最大值贡献 $2^{b}$。 递归到 $(lson,b-1,val+2^b)$ 以及 $(rson,b-1,val+2^b)$。

时间复杂度为 $O(n\log{k})$。

### code

```cpp
#include<bits/stdc++.h>
#define int long long
#define pb(a) push_back(a);
#define fi first
#define se second
using namespace std;
inline int rd(){
    int s=0,w=1;char ch=getchar();
    for(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')w=-1;
    for(;ch>='0'&&ch<='9';ch=getchar())s=s*10+ch-'0';
    return s*w;
}
const int N=5e5+1,P=1e9+7;
typedef pair<int,int> PII;
int n,m,k,ans=1,flag;
int vis[N],rll[N];
vector<PII> a[N];
vector<int> youkino;
int tot;
int tr[N*20][2];
inline void add(int x,int y,int z){a[x].push_back({y,z});}
inline void dfs(int u){
    vis[u]=1;youkino.pb(rll[u]);
    for(PII ff:a[u]){
        int v=ff.fi,w=ff.se;
        if(vis[v]&&rll[v]!=(rll[u]^w))flag=0; 
        else if(!vis[v]){
            rll[v]=rll[u]^w;dfs(v);
        }
    }
}
inline int INS(int &x){if(!x)x=++tot;return x;}
inline void ins(int x,int p){
    for(int i=29;i>=0;--i){
        int bit=(x>>i)&1;
        p=INS(tr[p][bit]);
        // printf("%d %d\n",p,bit);
    }
}
inline int calc(int p,int b,int val){
    if(!tr[p][0]&&!tr[p][1]){
        if(val<=k)return 1;
        return 0;
    }
    int now=0;
    if(tr[p][0]&&tr[p][1]){
        now+=calc(tr[p][0],b-1,val+(1<<(b-1)));
        now+=calc(tr[p][1],b-1,val+(1<<(b-1)));
    }
    else{
        int bit=0;
        if(tr[p][0])bit=0;
        if(tr[p][1])bit=1;
        if(val+(1<<(b-1))<=k){
            now+=(1<<(b-1));//
            now+=calc(tr[p][bit],b-1,val+(1<<(b-1)));
        }
        else{
            now+=calc(tr[p][bit],b-1,val);
        }
    }
    // printf("test:%d %d %d %d\n",p,b,val,now);
    return now%P;
}
signed main(){
    n=rd();m=rd();k=rd();
    for(int i=1;i<=m;++i){
        int x=rd(),y=rd(),z=rd();
        add(x,y,z);add(y,x,z);
    }
    for(int i=1;i<=n;++i){
        if(vis[i])continue;
        youkino.clear();flag=1;
        dfs(i);//注意清空 trie .
        if(flag){
            // puts("ff");
            tot=1;for(int v:youkino)ins(v,1);
            ans=ans*calc(1,30,0)%P;
            // printf("%d\n",ans);
            for(int i=1;i<=tot;++i)tr[i][0]=tr[i][1]=0;
        }
        else{ans=0;break;}
    }
    cout<<ans;
    return 0;
}
```

---


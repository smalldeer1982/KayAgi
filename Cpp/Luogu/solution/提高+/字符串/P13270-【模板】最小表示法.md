# 【模板】最小表示法

## 题目背景

原模板题：[P1368 工艺](https://www.luogu.com.cn/problem/P1368)。

## 题目描述

若长度为 $n$ 的字符串 $s$ 中可以选择一个位置 $i$，使得 $\overline{s_i\cdots s_ns_1\cdots s_{i-1}}=t$，则称 $s$ 与 $t$ **循环同构**。字符串 $s$ 的**最小表示**为与 $s$ 循环同构的所有字符串中字典序最小的字符串。

给定一个长度为 $n$ 的字符串 $s$，请求出 $s$ 的最小表示。

## 说明/提示

对于全部数据，$1\le n\le 10^7$，字符串 $s$ 仅包含小写英文字母（ASCII $97\sim 122$）。

设置以下三档部分分，用于测试不同解法：

- 对于 $20\%$ 的数据，$n\le 10^3$；
- 对于 $50\%$ 的数据，$n\le 10^5$；
- 对于 $100\%$ 的数据，无特殊限制。

## 样例 #1

### 输入

```
10
caacabcaab```

### 输出

```
aabcaacabc```

# 题解

## 作者：MoonCake2011 (赞：7)

最小表示法竟然更新模板题了！

那我就要来写题解了。

# 暴力解法

枚举循环同构串的第一个位置，然后暴力用字符串挨个比较的方法比较。

时间复杂度 $O(n^2)$ 获得 30 分。

# 优化解法

考虑如何优化暴力解法。

首先，这循环同构看起来有点烦，所有我们选择复制一份到字符串后面。

然后再考虑如何快速进行字符串比较。

首先字符串比较需要找到字符串第一个不相等的位置。

这里我们可以用前缀哈希 + 二分 / 倍增的方式。

就可以 $O(n\log n)$ 获得 50 分。

代码如下。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=2e7+10;
int n;
string s;
unsigned int h[maxn],p[maxn];
unsigned int gethash(int l,int r){
	return h[r]-h[l-1]*p[r-l+1];
}
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>s,s=" "+s+s;
	p[0]=1;
	for(int i=1;i<=2*n;i++) h[i]=h[i-1]*131+s[i],p[i]=p[i-1]*131;
	int st=1;
	for(int i=2;i<=n;i++){
		int ans=-1;
		for(int p=30;p>=0;p--){//利用哈希比较字符串 
			if(ans+(1<<p)>n) continue;
			if(gethash(st,st+ans+(1<<p))==gethash(i,i+ans+(1<<p))) ans+=(1<<p);
		}
//		cout<<ans<<'\n';
		if(ans!=n) if(s[i+ans+1]<s[st+ans+1]) st=i;
	}
	for(int i=st;i<=st+n-1;i++) cout<<s[i];
	return 0;
}
```

# 暴力的优化解法

## 算法介绍 

这里我们尽量尝试去排除更多的无效状态

假设我们现在要比较第 $st$ 位开头和第 $i$ 开头的指针。

我们暴力找到一个 $j<n$ 使得 $st$ 到 $st+j-1$ 位与 $i$ 到 $i+j-1$ 位完全相等。

如果没找到一个合适的 $j$，那么我们易证，字符串内所有字符都相等。

如果 $st+j$ 位比第 $i+j$ 位更优，说明对于任意 $0\le k\le j$，以 $i+k$ 开头的表示都不可能成为最优解。

因为对于一个 $i+k$，$st+k$ 一定比它更优，如下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/74op6ibl.png)

这时，$i$ 就可以直接跳到 $i+j+1$ 了。

如果 $i$ 更优，我们就可以直接更新最优解并跳到 $\max(i+1,st+j+1)$ 了。（我不会告诉你这里只跳到 $i+1$ 能撞过去还跑得飞快并且时间复杂度不正确）

然后做完了？做完了。

## 代码时间

代码十分简短。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=2e7;
int n;
string s;
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>s,s=" "+s+s;
	int st=1;
	for(int i=2;i<=n;){
		int j=0;
		for(j=0;j<n && s[st+j]==s[i+j];j++);
		if(j==n) break;
		if(s[st+j]>s[i+j]){
            int m=st;
            st=i,i=max(i+1,m+j+1);
        }
		else i+=j+1;
	}
	for(int i=st;i<=st+n-1;i++) cout<<s[i];
	return 0;
}
```

## 时间复杂度证明

对于 $st+j$ 位比 $i+j$ 位更优的情况，通过 $O(j)$ 的枚举使 $i$ 前进了 $j$ 步，因为 $i$ 最多移动 $n$ 步，所以时间复杂度均摊 $O(n)$。

对于另一种情况，$i$ 和 $st$ 总共移动了至少 $j$ 步，而 $st$ 和 $i$ 都最多移动 $n$ 步，所以均摊时间复杂度 $O(n)$。

所以总复杂度 $O(n)$，可以过这道题。

---

## 作者：longyitongxue (赞：5)

题目传送门：[P1368 工艺](https://www.luogu.com.cn/problem/P1368) || [P13270 【模板】最小表示法](https://www.luogu.com.cn/problem/P13270)

# 什么是最小表示法？
首先我们先要了解什么是循环同构串。当字符串 $S$ 中选定一个位置 $i$ 满足 $S_{i\sim n}+S_{1\sim i-1}=T$，则 $T$ 是 $S$ 的循环同构串。通俗一点的来讲，以下标 $i$ 为断点，把下标 $i$ 前面的字符串拼到下标 $i$ 及后面字符串的后面，得到的新的字符串就是旧字符串的循环同构串。我们设 $S=\tt abcd$，那么 $\tt abcd,bcda,cdab,dabc$ 都是 $S$ 的循环同构串。

最小表示法就是找出字符串 $S$ 的循环同构串中字典序最小的那个。
# 如何实现？
对于循环串，我们一般采取**断环成链**的方法，断环成链指把整个字符串复制一遍，添加到原字符串的后面。接着，我们扫描这个字符串，用三个控制变量 $i,j,k$ 控制扫描，其中 $i,j$ 控制匹配起始位置，$k$ 控制匹配的长度。

我们设原字符串 $S$ 为 $\tt acacaba$，先进行断环成链操作变为 $\tt acacabaacacaba$，当 $i=1,j=3,k=3$ 时（下标从 $1$ 开始计数），我们不难发现：$S_{i+k}>S_{j+k}$，这代表着 $S_{i\sim i+k}$ 之内的任意一个位置开始的循环同构串都会被淘汰，碰到这样的情况，$i$ 只能跳到 $i+k+1$ 的位置继续比较。我们再想想，如果 $S_{j+k}>S_{i+k}$ 了怎么办呢？一个道理嘛，$S_{j\sim j+k}$ 之内的任意一个位置开始的循环同构串都会被淘汰，我们就让 $j$ 跳到 $j+k+1$ 就行了。
## 算法流程
1. 断环成链。
2. 初始化控制变量 $i=1,j=2,k=0$。（这里，$j$ 不能初始化为 $1$，因为初始化为 $1$ 后，$i$ 和 $j$ 相等，就会导致不论 $k$ 怎么变化比较的字符串都是一样的，这样就没有意义了）
3. 当 $i\le n$ 且 $j\le n$ 时，循环，比较 $S_{i+k}$ 是否等于 $S_{j+k}$。  
  $\left\{\begin{matrix}S_{i+k}=S_{j+k}&k\gets k+1\\S_{i+k}>S_{j+k}&i\gets i+k+1\\S_{i+k}<S_{j+k}&j\gets j+k+1\end{matrix}\right.$  
  若跳转后 $i=j$，则让 $j\gets j+1$。（原因见第 $2$ 步）
4. 重复上述过程，直到 $i>n$ 或 $j>n$（比较结束）。
5. 答案为 $\min\left(i,j\right)$。
## 算法流程实现代码
```cpp
int getmin(){
    for(int i=1;i<=n;i++){
        a[i+n]=a[i];
    }
    int i=1,j=2,k=0;
    while(i<=n&&j<=n){
        for(k=0;k<n&&a[i+k]==a[j+k];k++);
        if(a[i+k]>a[j+k])i=i+k+1;
        else j=j+k+1;
        if(i==j)j++;
    }
    return min(i,j);
}
```
# [AC](https://www.luogu.com.cn/record/224724982) 代码
```cpp
#include<iostream>
using namespace std;
int n;
char a[20000005];//别忘了要断环成链，要开两倍的空间！
int getmin(){
    for(int i=1;i<=n;i++){
        a[i+n]=a[i];
    }
    int i=1,j=2,k=0;
    while(i<=n&&j<=n){
        for(k=0;k<n&&a[i+k]==a[j+k];k++);
        if(a[i+k]>a[j+k])i=i+k+1;
        else j=j+k+1;
        if(i==j)j++;
    }
    return min(i,j);
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    int v=getmin();
    for(int i=0;i<n;i++){
        cout<<a[i+v];
    }
    return 0;
}
```

---

## 作者：wangliu (赞：4)

# P13270 【模板】最小表示法

蒟蒻在题解区看题解感觉好像一个人写的，有做法但没有很清晰的证明或者解释，~~我来水一篇。~~

题意挺简单的，在这里不过多赘述，直接上思路。

## 题目思路

### $20\%$ 的思路：直接暴力枚举

先将给定字符串 $s$，我们先把 $s$ 复制粘贴一份在 $s$ 后面，这样得到的新字符串 $s_1$ 中任意长度为 $n$ 的字串都与 $s$ **循环同构**。

然后用双指针维护，两个指针 $i,j$ 分别表示当前两种答案的开始位置，然后枚举字串的长度 $k$，当它们前 $k-1$ 个字符均相等，即
$$
s[i \cdots i + k - 1] = s[j \cdots j + k - 1]
$$
此时，如果 $s_{i+k} < s_{j+k}$，那么说明以 $j$ 开头的答案不优，直接 $j \leftarrow j + 1$，否则 $i \leftarrow i + 1$。

**注意**：如果 $i = j$ 那么 $j \leftarrow j + 1$，因为要保证我们是对不同的方案比较，~~否则自己和自己比了个寂寞。~~

代码如下：

```cpp
int i = 1, j = 2, k = 0;
while(i < n and j < n and k < n){
	if(s[i+k] == s[j+k]) k++;
	else{
		s[i+k] > s[j+k] ? i ++ : j ++;
		if(i == j) j++;
		k = 0;
	}
}
int v = std::min(i, j);
for(int i=0;i<n;i++) std::putchar(s[i+v]);
```

这样做的时间复杂度为 $\Theta(n^2)$，只能得到 $20$ 分。

[link](https://www.luogu.com.cn/record/226469123) ~~哎这题数据好水居然有五十分，只T了一个点……~~

### $100\%$ 的思路

我们可以发现在上述方法中，有很多不必要的比较。

当 $s_{i+k} < s_{j+k}$ 且前 $k-1$ 个字符均相同时，我们认为以 $j$ 开头的答案不优，直接 $j \leftarrow j + 1$，但是此时对于任意下标 $l$ 满足 $l \in [j,j+k]$ 都不会是答案。因为一定存在对应的下标 $r \in [i,i+k]$， 比以 $l$ 为下标的答案更优。归根结底，就是因为 $s_{i+k} < s_{j+k}$。根据这个原理，我们可以更快速的查找答案。

代码如下：

```cpp
int i = 1, j = 2, k = 0;
while(i < n and j < n and k < n){
	if(s[i+k] == s[j+k]) k++;
	else{
		s[i+k] > s[j+k] ? i += k + 1 : j += k + 1; //和上面相比只改了这一行
		if(i == j) j++;
		k = 0;
	}
}
int v = std::min(i, j);
for(int i=0;i<n;i++) std::putchar(s[i+v]);
```

时间复杂度 $\Theta(n)$，足以通过此题。

---

## 作者：MaiJingYao666 (赞：3)

# P13270 【模板】最小表示法 题解  
**什么是最小表示法？**  
看题面。  

**最小表示法有什么用？**  
最小表示法可以通过其判定多个字符串是否同构，也可以解决部分“环”类的题目。  

## 题解部分  
### $20\%$ 做法。  

首先考虑暴力如何计算，自然是将 $n$ 个字符串全部找出最小的。  

我们自然不必将 $n$ 个字符串全部创建出来，因此维护两个指针 $i$，$j$ 表示“当前最优解同构串的开始指针”和“当前枚举同构串的开始指针”，每次循环判断两者的字典序。  

随机数据最优情况下字典序判断一下就好，能达到接近 $O(n)$。但如果遇到如 $aaa···aaa$ 之类的，判断字典序的部分退化到 $O(n)$，总时间复杂度就是 $O(n^2)$。  
```cpp
int k=0,i=1,j=2;//k表示当前字典序判断的段长-1
while(j<=n && k<n){
    if(a[(i+k-1)%n+1]==a[(j+k-1)%n+1]) k++;//如果一样则枚举下一位
    else{
        if(a[(i+k-1)%n+1]>a[(j+k-1)%n+1]) i=j;
        k=0;
        j++;
    }
}
```

### $100\%$ 做法。  
我们容易发现，我们在判断众多相同字符的时候浪费了大量时间。怎么办呢？ 

我们发现如果这个字符串以 $a$，$b$ 开头（$a<b$）的两个同构串中，$[a,a+k-1]$ 和 $[b,b+k-1]$ 完全相同，那么很显然对于任一的 $0<p\le k$，以 $a+p$，$b+p$ 为开头的同构串字典序大小结果也会和上面两个同构串字典序大小结果一样。    

我们灵活运用 $i$，$j$，只将小的那个定为最优解。那么根据上面的发现，一次判别后字典序大的那一方，接下来的 $k$ 次判定一定也会输，所以直接跳到 $k+1$ 位后，最终的答案就是 $\min(i,j)$ 开头的同构串。  

然后的话，时间复杂度自然就是 $O(n)$。  

证明：显然时间复杂度均来自 $k$ 的移动。同时 $k$ 的移动会带动 $i$，$j$ 的移动，即所有会被遍历到的 $k$ 的总和等于 $i,j$ 移动步数的总和。因为 $i,j\le n$，所以移动步数 $\le 2\times n$，所以时间复杂度就是 $O(n)$ 的。  
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e7+50;
int n;
char a[N];
int main(){
	scanf("%d",&n);
	scanf("%s",a+1);
	a[0]=' ';
	int i=1,j=2,k=0;
	while(i<=n && j<=n && k<n){
		if(a[(i+k-1)%n+1]==a[(j+k-1)%n+1]) k++;
		else{
			if(a[(i+k-1)%n+1]>a[(j+k-1)%n+1]) i+=k+1;
			else j+=k+1;
			if(i==j) i++;
			k=0;
		}
	}
	i=min(i,j)-1;
	for(int t=1;t<=n;t++){
		printf("%c",a[(i+t-1)%n+1]);
	}
}
```

---

## 作者：ChenHaoQi (赞：2)

# 题意
给出一个长度为 $n$ 的字符串 $s$，求 $s$ 循环同构的所有字符串（即对 $s$ 选择所有的下标 $i$ 得到的 $\overline{s_i\cdots s_ns_1\cdots s_{i-1}}$ 串）中字典序最小的那个字符串。

我们可以将 $s$ 复制一份连接在 $s$ 后面，这样问题就转变为**求新的 $s$ 中长度为 $n$ 的字典序最小的子串**。

# 分析
最朴素的做法是枚举每个子串的开头，并一一比较。对于分别以第 $i,j$ 位为开头的子串，暴力枚举子串的长度 $k$，直至 $a_{i+k} \neq a_{j+k}$。此时若 $a_{i+k}<a_{j+k}$，则 $j\leftarrow j+1$，否则 $i\leftarrow i+1$。我们在枚举过程中保持 $i \neq j$，此时若 $\overline{s_i\cdots s_{i+n}}=\overline{s_j\cdots s_{j+n}}$，易得原字符串的所有可能子串均已被枚举，则直接输出。

因为 $i,j$ 分别最多移动 $n$ 次，每一次枚举次数为 $k(1\le k \le n)$ ，所以暴力枚举的算法时间复杂度约为 $O(n^2)$。这对于 $n \le 10^7$ 的数据范围是不可接受的，因此我们需要对算法进行优化。

可以发现，实际上当我们枚举到 $a_{i+k} \neq a_{j+k}$ 时，若 $a_{i+k}<a_{j+k}$，我们可以直接使 $j\leftarrow j+k+1$。因为对于每一个 $j<p\le j+k$，以第 $p$ 位开头的字符串枚举到第 $j+k$ 位时，第  $i+(p-j)$ 位开头的字符串在枚举到第 $i+k$ 位时显然比其更优，这利用了枚举过程中 $\overline{s_i\cdots s_{i+k-1}}=\overline{s_j\cdots s_{j+k-1}}$ 的特点。

此时由于每次移动都会跳过 $k+1$ 个字符，于是每个字符最多被比较两次，则总的比较次数不会超过 $2 \times n$，时间复杂度约为 $O(n)$，可以通过本题。

# 代码
代码非常简短，重在理解。需要特别注意小心的部分采用洛谷昨天刚更新的部分行高亮功能标注了。
```cpp lines=17
#include<iostream>
using namespace std;

int main(){
    int n;
    cin>>n;
    string s;
    cin>>s;
    s=s+s;
    int i=0,j=1;
    while(i<n && j<n){
        int k=0;
        while(k<=n && s[i+k]==s[j+k]) k++;
        if(k==n+1) break; 
        if(s[i+k]>s[j+k]) i+=k+1;
        else j+=k+1;
        if(i==j) j++; //保证i不等于j，否则可能误判
    }
    int ans=min(i,j);
    cout<<s.substr(ans,n);
    return 0;
}
```

---

## 作者：small_lemon_qwq (赞：2)

我的做法与传统做法不同。

## 暴力

[oi-wiki 的代码](https://oi-wiki.org/string/minimal-string/)。

这里换一种写法，对下文帮助更大。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
char a[20000005];
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		a[i+n]=a[i];
	}
	int ans=1;
	for(int i=2;i<=n;i++){
		for(int k=0;k<n;k++){
			if(a[ans+k]>a[i+k]){
				ans=i;
				break;
			}
			if(a[ans+k]<a[i+k])break;
		}
	}
	for(int i=ans;i<ans+n;i++){
		cout<<a[i];
	}
	return 0;
}
```

### 传统做法

这里讲的不是我的做法，讲的是最常见的 $\operatorname{O}(n)$ 做法，可以跳过。

考虑将输入的字符串破环为链，并定义 $S_x$ 表示从位置 $x$ 开始的长度为 $n$ 的连续段。

双指针枚举 $i,j$ 表示当前正在判断 $i$ 的大小和 $j$ 的大小，其中 $i$ 和 $j$ 是两个可能为最小表示法的候选值，暴力比较 $S_i$ 和 $S_j$ 哪个更大，不妨设 $a_{i+k}$ 和 $a_{j+k}$ 不同，我们不妨设 $a_{i+k}>a_{j+k}$（若相反，交换 $i,j$ 即可，但实现时无需交换），那么 $S_i$ 不能成为最小表示法，那么可以证明，对于 $\forall x\in [0,k]$，$S_{i+x}$ 一定也不是最小表示法，故直接令 $i\gets i+k+1$，则时间复杂度为 $\operatorname{O}(n)$。

给出对于 $\forall x\in [0,k]$，$S_x$ 一定也不是最小表示法的证明。

> 对于 $x\in [0,k]$，那么考虑比较 $S_{i+x}$ 与 $S_{j+x}$，那么由于 $i+k>i+x$ 且对于 $\forall y\in[x,k)$，都有 $a_{i+y}=a_{j+y}$，那么 $S_{i+x}>S_{j+x}$，所以 $S_{i+x}$ 不是最小表示法。

我只有 [Necklace](https://www.luogu.com.cn/problem/P10476) 的代码（以前写的）：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
string get(string s){
	int n=s.size();
	if(n==1)return s;
	s=" "+s+s;
	int i=1,j=2;
	while(i<=n&&j<=n){
		int k=0;
		while(k<n&&s[i+k]==s[j+k])k++;
		if(k==n)break;
		if(s[i+k]<s[j+k])swap(i,j);
		i+=k+1;
		if(i==j)i++;
	}
	return s.substr(min(i,j),n);
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	string s,t;
	cin>>s>>t;
	if(get(s)==get(t)){
		cout<<"Yes\n"<<get(s);
	}else{
		cout<<"No\n";
	}
	return 0;
}
```

## 我的做法

感觉没学过最小表示法的情况下更容易想到这个做法？

仍然输入的字符串破环为链之后，令 $a_{2\times n}=+\inf$，考虑优化暴力，令 $j$ 为当前的答案，$i$ 从 $2$ 遍历到 $n$，那么需要比较 $S_j$ 与 $S_i$（定义见上文），不妨设 $a_{j+k}\neq a_{i+k}$：

- 若 $a_{j+k}> a_{i+k}$，执行 $j\gets i$ 以及 $i\gets i+1$；
- 否则 $a_{j+k}<a_{i+k}$，和上文一样，执行 $i\gets i+k+1$ 即可。

答案就是 $j$。

代码（快读略）：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
char a[20000005];
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		a[i+n]=a[i];
	}
	a[2*n]=255;
	int i=2,j=1;
	while(i<=n){
		int k=0;
		while(k<n&&a[i+k]==a[j+k])k++;
		if(a[i+k]<a[j+k])j=i,i++;
		else i+=k+1;
	}
	for(int i=j;i<j+n;i++){
		cout<<a[i];
	}
	return 0;
}
```

快读加上就是最优解了。

---

## 作者：Belia (赞：1)

### 题意：

给定一个长度为 $n$ 的字符串 $s$，求其最小表示。最小表示定义为与 $s$ 循环同构（通过旋转得到的字符串）的所有字符串中字典序最小的那个字符串。

### 思路：

看到此题的第一眼，我就不难想到**双指针**。

在这里，我们重点讲一下双指针过程：

我们需要在 $i<n$、$j<n$ 且 $k<n$ 的条件下循环：

  - 比较 $t_{i+k}$ 和 $t_{j+k}$：

    - 若相等，则 $k$ 自增，继续比较。

    - 若不等：

      - 若 $t_{i+k} > t_{j+k}$，则 $i$ 跳到 $i+k+1$（因为 $i$ 开头的子串不可能成为最小表示）。

      - 若 $t_{i+k} < t_{j+k}$，则 $j$ 跳到 $j+k+1$（同理）。

      - 若 $i=j$，则 $j$ 自增避免重复。

      - 重置 $k=0$。

总体时间复杂度为 $\mathcal{O}(n)$，每次跳转会跳过 $k+1$ 个字符，每个字符最多被比较两次（$i$ 和 $j$ 各一次），总比较次数不超过 $2n$，可轻松通过此题。

### 代码：

建议使用 C++14 (GCC 9) 版本进行提交。

```cpp
#include<bits/stdc++.h>
#define ll long long//#define ll long long你值得拥有
using namespace std;
ll n,i=0,j=1,k=0,pos;
int main()
{
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);//cincout加速代码
    cin>>n;
    char *t=new char[2*n+1];
    cin>>t;
    for(ll i=0;i<n;i++)
    t[i+n]=t[i];
    while(i<n&&j<n&&k<n)
	{
        if(t[i+k]==t[j+k])
        k++;
		else
		{
            if(t[i+k]>t[j+k])
            i=i+k+1;
            else
            j=j+k+1;
            if(i==j)
			j++;
            k=0;
        }
    }
    pos=min(i,j);
    for(ll i=0;i<n;i++)
    cout<<t[pos+i];
    cout<<"\n";
    delete[] t;
    return 0;
}
```

最后，感谢 @[zhangruixiang](luogu://user/1293987)、@[Clare613](luogu://user/730276)、@[TemplateClass](luogu://user/735713)的帮助。

---

## 作者：pour_demain (赞：1)

说实话不知道这道题为什么还会要题解，P1368 都关了题解通道，不过既然这题开了通道就让我们来水一篇。

---

首先我们可以用简单暴力，比较 $s$ 的每一个循环同构串，找出字典序最小的那一个。时间复杂度明显爆炸，最大 $O(n^2)$。\
暴力我就不写代码了，给大家贴一个 OI wiki 上的代码，但是要注意它的代码返回的是字符串最小表示法的起始索引，而不是直接返回最小表示法。

```cpp
int k = 0, i = 0, j = 1;
while (k < n && i < n && j < n) {
  if (sec[(i + k) % n] == sec[(j + k) % n]) {
    ++k;
  } else {
    if (sec[(i + k) % n] > sec[(j + k) % n])
      ++i;
    else
      ++j;
    k = 0;
    if (i == j) i++;
  }
}
i = min(i, j);
```

---

我们考虑优化这个暴力。\
根据写字符串匹配的经验，可以考虑在原字符串中两个一样的子串，我们只用比较这两个子串后的字符的大小，两个子串后字符较大的那个子串可以直接淘汰，因为无论以该子串的任何地方作为最小表示法的起始，在另一个子串中总会有更优解。\
时间复杂度 $O(n)$，但是我不会证 /kk。

是不是很绕？说简单点就是对于两个字符，当它们前面的 $k$ 个字符相同时，我们只用比较这一个字符，就可以确定前面 $k$ 个字符有没有可能成为最优解的起始。

这里给出 OI wiki 上的代码和我的 AC 代码。

```cpp
int k = 0, i = 0, j = 1;
while (k < n && i < n && j < n) {
  if (sec[(i + k) % n] == sec[(j + k) % n]) {
    k++;
  } else {
    sec[(i + k) % n] > sec[(j + k) % n] ? i = i + k + 1 : j = j + k + 1;
    if (i == j) i++;
    k = 0;
  }
}
i = min(i, j);
```

---

```cpp
#include <bits/stdc++.h>
using namespace std;
int f(const string& s) {//计算函数，这里我返回的也是最小表示法的起始索引。
	int n = s.length();
	if (n <= 1) return 0;
	int i = 0, j = 1, k = 0;
	while (i < n && j < n && k < n) {
		char a = s[(i + k) % n];
		char b = s[(j + k) % n];
		if (a == b) {
			k++;
		} else {
			if (a > b) i += k + 1;
			else j += k + 1;
			if (i == j) j++;
			k = 0;
		}
	}
	return min(i, j);
}
int main() {
	int n;
	cin >> n;
	string s;
	cin >> s;
	int idx = f(s);
	cout << s.substr(idx) + s.substr(0, idx);//这里因为返回的是最小表示法的起始索引，所以还要处理一下输出最小表示法。
	return 0;
}
```

---

## 作者：brbrbread (赞：1)

# 最小表示法的概念      
最小表示法是一种用于处理字符串**循环同构**问题的算法。当一个字符串可以通过**循环移位**得到另一个字符串时，这两个字符串被称为循环同构。例如，字符串 ```"abc"``` 的循环同构字符串包括 ```"abc"``` 、 ```"bca"``` 和 ```"cab"``` 。最小表示法就是找到这些循环同构字符串中**字典序最小**的那个。      
# 前置知识
- 字符串循环移位：将字符串的前 $k$ 个字符移到字符串的末尾，形成新的字符串。
- 字典序：字符串比较的一种方式，按字符的 ASCII 码值逐位比较。

~~真不是为了水字数。~~
# 算法证明
我们需要证明：算法最终返回的起点一定是所有可能起点中字典序最小的。  
证明：我们运用反证法。假设存在 $m \in[i, i+k]$ 是最小表示的起点，则从 $m$ 开始的字符串 $s_m..$ 应小于所有其他起点的字符串。      
但由于 $m \ge i$ 且 $m \le i+k$，从 $m$ 开始的字符串前缀与从 $i$ 开始的字符串前缀有重叠：$s_{m..m + (i+k - m)} = s_{i + (m - i)..i + k}$。
而已知 $s_{i..i+k} > s_{j..j+k}$，且 $j$ 的位置与 $i$ 无关 $ （j \ne i）$ ，因此从 $m$ 开始的字符串会大于从 $j$ 开始的字符串（因为 $s_{m..}$ 的前缀是 $s_{i..i+k}$ 的后缀，而 $s_{i..i+k}$ 整体大于 $s_{j..j+k}$），与 “ $m$ 是最小起点” 矛盾。因此 $[i, i+k]$ 中的所有起点均不可能是最小表示。       
算法的时间复杂度由 $i、j、k$ 的总移动次数决定。三者的总移动次数不超过 $2n$，因此整体复杂度为 $O(n)$。完全可以处理题目给的数据范围。
# 思路
那我们该如何去求字符串的最小表示呢？     
我们先扩展字符串，相当于把它再复制一遍然后加到原来字符串的后面，这样做是为了便于处理循环移位。     
接下来我们初始化指针。令 ```i = 0``` 和 ```j = 1``` 分别表示两个可能的最小表示的起始位置。
令 ```k = 0``` 表示当前比较的长度。       
然后比较 ```s[i + k]```  和 ```s[j + k]```：
如果相等，$k$ 增加 $1$，继续比较下一个字符。
当它们不相等时：
如果 ```s[i + k]``` 大于 ```s[j + k]```，说明从 $i$ 开始的子串不可能是最小表示，将 $i$ 移动到 $i + k + 1$。
反之，将 $j$ 移动到 $j + k + 1$。
确保 $i$ 和 $j$ 不相等，如果相等则将 $j$ 加 $1$。     
最终，$i$ 和 $j$ 中较小的那个就是最小表示的起始位置。       
输出从起始位置截取长度为 $n$ 的子串，即为所求的最小表示。        
# code

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
string s;
int main(){
    cin>>n>>s;
    s=s+s; // 复制字符串以处理循环移位
    int i=0,j=1,k=0;
    while(i<n&&j<n&&k<n){//开始处理循环移位 
        if(s[i+k]==s[j+k]){
            k++;
        }
		else{
            if(s[i+k]>s[j+k]){
                i=i+k+1;
            }
			else{
                j=j+k+1;
            }
            if(i==j){
                j++;
            }
            k=0;
        }
    }    
    int start=min(i,j);//确定最小表示的起始位置
    cout<<s.substr(start,n); //直接输出 
    return 0;//朴实无华的结尾 
}
```
如果觉得写的好的请点个赞再走呗。     
管理大大求过 QAQ 。

---

## 作者：bnusxxxz (赞：1)

首先将原串复制一遍，此时从任意一个 $1$ 到 $n + 1$ 下标开始往后连续的 $n$ 个字符显然是原串的一个循环同构。

首先，最暴力的做法，枚举下标以 $1$ 到 $n$ 开始的长度为 $n$ 的字符串，选取字典序最小的一个。每次比较时间复杂度 $O(n)$，总共比较 $n$ 次，时间复杂度 $O(n^2)$。由于枚举了每一个可能的循环同构的串，因此一定能找到字典序最小的一个，正确性显然。

这样的做法显然不优，考虑优化这一过程。显然对于以两个不同的数 $i$ 和 $j$ 为下标开头的两个串，如果连续 $k - 1$ 位相同，第 $k$ 位以 $i$ 为下标开头的更优，则显然以 $i$ 为下标开头的循环同构串更优，不断向后推 $k$ 位（表示位 $e$），同理都有以第 $i + e$ 为下标开头的优于 $j + e$，因此这一段不需要比较，直接跳过即可。

由于确定了以每一个下标开头的循环同构的串，正确性依旧显然。由于每个字符只会被指向较后的指针扫到一次，且指向较前的指针扫描次数与此相同，因此时间复杂度为 $O(n)$。  


```cpp
#include <cstdio>
#include <iostream>
const int maxn=11000000;
int n;
char S[maxn*2];
int main(){
	std::cin>>n;
	std::cin>>S+1;
	for(int i=1;i<=n;i++)
		S[i+n]=S[i];
	int i=1,j=2,k=0;
	for(i=1,j=2,k=0;i<=n&&j<=n&&k<=n;){
		if(S[i+k]==S[j+k]) k++;
		else{
			if(S[i+k]>S[j+k]) i=i+k+1;
			else j=j+k+1;
			if(i==j) j++;
			k=0;
		}
	}
	if(i>j) i=j;
	for(int e=0;e<n;e++)
		printf("%c",S[i+e]);
	return 0;
}
```

---

## 作者：L_zaa_L (赞：1)

### 定义
一个字符串 $S$ 的最小表示法为该字符串所有循环同构字符串中字典序最小的一个。

比如：$\texttt{abca}$，对于他，循环同构字符串就有 $\texttt{aabc}$，$\texttt{caab}$，$\texttt{bcaa}$，其中字典序最小的是 $\texttt{aabc}$。那么我们说 $\texttt{aabc}$ 就是 $\texttt{abca}$ 最小表示法。

### 算法流程介绍
考虑对于一对子串 $A,B$,它们在原字符串 $S$ 中的起始位置分别为 $i,j$,且它们的前 $k$ 个字符均相同，也就是 $s[i\dots i+k-1]=s[j\dots j+k-1]$。

考虑下一个字符 $s[i+k],s[j+k]$：

1. 若 $s[i+k]>s[j+k]$，那么 $i$ 以开头的子串，一定不是 $S$ 的最小表示法。因为以 $j$ 开头的子串的字典序一定小于以 $i$ 开头的更小，因为 $i\dots i+k$ 的情况一定不比 $j\dots j+k$ 更优，则我们将 $i$ 加上 $k+1$，然后 $k$ 清零。
 
2. 若 $s[i+k]<s[j+k]$，和上面同理，则将 $j$ 加上 $k+1$。

3. 若 $s[i+k]=s[j+k]$，那么继续往后面比较，也就是 $k$ 加上一。


### Code
```cpp
int getmin(char awa[]){
    int i=1,j=2,k=0;
    while(i<=n&&j<=n&&k<=n){
        int v=awa[(i+k-1)%n+1]-awa[(j+k-1)%n+1];
        if(!v) k++;
        else{
            if(v>0) i+=k+1;
            else j+=k+1;
            if(i==j) j++;
            k=0;
        }
    }
    return min(i,j);
}
```

### 优化
因为 $i,j$ 之间的字符绝对不是该串最小表示的答案，所以在遇到下一个字符不相等时，就可以直接转换到 $\max(i+k+1,j+1)$ 或 $\max(j+k+1,i+1)$。

## Code
```cpp
int getmin(char awa[]){
    int i=1,j=2,k=0;
    while(i<=n&&j<=n&&k<=n){
        int v=awa[(i+k-1)%n+1]-awa[(j+k-1)%n+1];
        if(!v) k++;
        else{
            if(v>0) i=max(i+k+1,j+1);
            else j=max(j+k+1,i+1);
            if(i==j) j++;
            k=0;
        }
    }
    return min(i,j);
}
```

---

## 作者：GJX_Algorithm (赞：0)

# 最小表示法
## 题目背景
在字符串算法中，**循环同构**是经典问题。即一个字符串可以通过循环移动得到另一字符串。一个字符串的最小表示则是这个字符串的所有循环同构字符串中字典序**最小**的那个。
## 题目描述
给定一个字符串及其长度，输出它的最小表示。
## 算法讲解
### 暴力方法
- 定义我们当前比较的字符串的两个循环同构字符串的起始位置为 $i$ 与 $j$，当前比较到的位置为 $k$，则当前比较到的字符是 $s_{i + k}$ 与 $s_{j + k}$。

- 第一种情况：$s_{i + k} = s_{j + k}$，说明两个串的字典序相等，$k$ 加一。

- 第二种情况：$s_{i + k} < s_{j + k}$，说明 $i$ 开头的串比 $j$ 开头的串字典序要小，以 $j$ 开头的串一定不会是最小表示，$j$ 加一，$k$ 清零，重新开始比较。

- 第三种情况：$s_{i + k} > s_{j + k}$，说明 $i$ 开头的串比 $j$ 开头的串字典序要大，以 $i$ 开头的串一定不会是最小表示，$i$ 加一，$k$ 清零，重新开始比较。

- 最后最小表示起点即为 $\min(i, j)$。
### 注意事项
- 因为是循环同构串，$i + k$ 与 $j + k$ 可能超出字符串范围，可以使用取模解决或直接把原串复制一份。

- 比较过程中可能出现 $i = j$ 的情况，很明显这样比较是毫无意义的，所以此时需要~~手动~~错位操作，可以选择 $i$ 加一或 $j$ 加一。
### 暴力法代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 2e7 + 5;
int n;
char s[N];
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    scanf("%d%s", &n, s);
    int i = 0, j = 1, k = 0;
    while (i < n && j < n && k < n)
    {
        if (s[(i + k) % n] == s[(j + k) % n])
            k++;
        else
        {
            s[(i + k) % n] > s[(j + k) % n] ? i++ : j++;
            k = 0;
            if (i == j) j++;
        }
    }
    int u = min(i, j);
    for (int i = 0; i < n; i++)
        printf("%c", s[(i + u) % n]);
    return 0;
}
```
### 暴力法局限性
当你拿着自家 27 行的代码高高兴兴的提交，想着又能水一发蓝题的时候……
![](https://cdn.luogu.com.cn/upload/image_hosting/xt57l2lu.png)
~~话说为啥才 TLE 两个点。~~

为什么会这样？这里引用 OI Wiki 上的一段话：
> 该实现方法随机数据下表现良好，但是可以构造特殊数据卡掉。
>
> 例如：对于 $\texttt{aaa}\cdots\texttt{aab}$, 不难发现这个算法的复杂度退化为 $O(n^2)$。
### 优化
- 如何优化？观察暴力法全过程，我们发现，若 $s_{i + k} < s_{j + k}$，则区间 $[j, j + k]$ 的任意整数为开头的字符串都不可能是最优解，因为在区间 $[i, i + k]$ 必有一整数作为开头的字符串比它更优。

- 所以我们每次增加 $i$ 或 $j$ 的时候，可以直接增加 $k + 1$，以跳过不必要步骤节省时间。
### AC Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 2e7 + 5;
int n;
char s[N];
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    scanf("%d%s", &n, s);
    int i = 0, j = 1, k = 0;
    while (i < n && j < n && k < n)
    {
        if (s[(i + k) % n] == s[(j + k) % n])
            k++;
        else
        {
            s[(i + k) % n] > s[(j + k) % n] ? i += k + 1 : j += k + 1;
            k = 0;
            if (i == j) j++;
        }
    }
    int u = min(i, j);
    for (int i = 0; i < n; i++)
        printf("%c", s[(i + u) % n]);
    return 0;
}
```

---

## 作者：ouxiyao (赞：0)

[此题的第一代题解](https://www.luogu.com.cn/article/xieb3vqg)，也是我的第一篇题解。              
[传送门](https://www.luogu.com.cn/problem/P13270)
# 最小表示法
什么是最小表示法，题目里已经讲了。这里举个“栗子”，$s=$`bdca`，他有四个循环同构串，分别是 `abdc,bdca,dcab,cabd`，然后找出字典序最小的，是 `abdc`，这个就是 $s$ 的最小表示法。            
如何实现寻找最小表示法呢？
# 方法
把大象装进冰箱需要多少步？3步，对吧？
### Step 1：断环成链
将数组复制一遍就好了。

```cpp
for(int i = 1;i<=n;i++){
    cin>>a[i];
    a[i+n] = a[i];//断环成链。
}
```
### Step 2：三指针扫描
先整三个变量 $i,j,k$，$i$ 代表从 $i$ 到 $i+n$ 这个字符串的开头（注意前面已经断环成链），$j$ 与 $i$ 相似。$k$ 代表 $i$ 到 $i+n$ 这个字符串和 $j$ 到 $j+n$ 这个字符串第一个不一样的地方（下标以两字符串为准），如两字符串完全相同，则 $k=n$。              
接下来，就要让指针动起来：开一个 `while`，只要 $i,j$ 不超过 $n$ 就不退出，每次循环用 $k$ 找两字符串不同的地方，如果从这里判断出 $i$ 所在的字符串大，那么 $i$ 到 $i+k$ 都可以忽略掉了，即 $i=i+k+1$。$j$ 同理。                 
证明一下正确性：

```markdown
i = 1,j = 2,k = 3
c   c a b c c a b
i i+k
c c   a b c c a b
  j j+k
```
拿例子来说明，比如这种情况，比较到 $k=2$ 的时候发现 $i+k$ 的字符比 $j+k$ 大，因为之前的都相同，所以这里总会被排除，即不是最小表示法。所以 $i$ 变为 $i+k+1$，继续循环。
放代码：

```cpp
int mins(){
    int i = 1,j = 2,k = 0;//三指针扫描。
    while(i<=n&&j<=n){
        for(k = 0;k<n&&a[i+k]==a[j+k];k++);//枚举 k
        if(a[i+k]<=a[k+j])j = j+k+1;
        else if(a[k+i]>a[j+k])i = i+k+1;
        if(i==j)j++;//相等情况。
    }
    return min(i,j);
}
```
哦，还有，如果 $i=j$，$j$ 要记得加一，继续判断。$\min(i,j)$ 是最小表示法的开头。
### Step 3：输出
循环 $\min(i,j)$ 到 $\min(i,j)+n$，完事。                
完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
char a[20000010];//此处切记，数组长度为数据的两倍。
int n;
int mins(){
    int i = 1,j = 2,k = 0;//三指针扫描。
    while(i<=n&&j<=n){
        for(k = 0;k<n&&a[i+k]==a[j+k];k++);//枚举 k。
        if(a[i+k]<=a[k+j])j = j+k+1;
        else if(a[k+i]>a[j+k])i = i+k+1;
        if(i==j)j++;//相等情况。
    }
    return min(i,j);
}
int main(){
    ios::sync_with_stdio(0);//记得流解绑。
    cin>>n;
    for(int i = 1;i<=n;i++){
        cin>>a[i];//别想太多，直接cin就好了。
        a[i+n] = a[i];//断环成链
    }
    int v = mins();
    for(int i = 0;i<n;i++)cout<<a[i+v];//记得i从0开始。
    return 0;
}
```

---

## 作者：TemplateClass (赞：0)

先考虑如何暴力，为了引出正解，我们采用一种双指针的写法。我们可以枚举所有和 $S$ 循环同构的字符串（其实本质上就是枚举起始下标）。

我们用 $i, j$ 表示我们当前枚举的两个字符串的起始下标，然后通过让 $k = 1, 2, 3, \cdots, n$ 逐位枚举，若以 $i, j$ 为起始下标的字符串的第 $k$ 位不同，则让字典序较大的指针加一，然后 $k = 1$ 重新开始比较。在枚举结束后，$\min(i, j)$ 即是所求字符串的起始下标。

指针 $i, j$ 的移动次数是 $O(n)$ 的，而且比较次数也是 $O(n)$ 的，所以时间复杂度 $O(n ^ 2)$。

代码如下（片段）：

```cpp
std::cin >> n;
for(int i = 0; i < n; ++i) {
	std::cin >> s[i];
}

int i = 0, j = 1;
for(int k = 0; std::max({i, j, k}) < n; ) {
	if(s[(i + k) % n] == s[(j + k) % n]) ++k;
	else {
		if(s[(i + k) % n] > s[(j + k) % n]) ++i;
		else ++j;
		k = 0; if(i == j) ++i;
	} 
}

int ans = std::min(i, j);
for(int i = 0; i < n; ++i) {
	std::cout << s[(i + ans) % n] << " ";
}
```

我们观察到，在暴力做法中每次我们把指针 $i$ 或 $j$ 加上的数都是 $1$，这实际上是没有必要的，由于我们已经比较到了第 $k$ 位才发现不同，所以容易证明 $S _ j \sim S _ {j + k}$ 都 $> S _ i$，因而 $j$ 直接加上 $k + 1$ 即可，$i$ 的情况同理。

于是这样就 $O(n)$ 了。

```cpp
std::cin >> n;
for(int i = 0; i < n; ++i) {
	std::cin >> s[i];
}

int i = 0, j = 1;
for(int k = 0; std::max({i, j, k}) < n; ) {
	if(s[(i + k) % n] == s[(j + k) % n]) ++k;
	else {
		if(s[(i + k) % n] > s[(j + k) % n]) i += k + 1;
		else j += k + 1;
		k = 0; if(i == j) ++i;
	} 
}

int ans = std::min(i, j);
for(int i = 0; i < n; ++i) {
	std::cout << s[(i + ans) % n] << " ";
}
```

---

## 作者：Phartial (赞：0)

一个 $\mathcal{O}(n^2)$ 的做法是，维护当前的最小循环表示，每次加一个新的进来并暴力判断大小关系。

尝试优化。牢记字符串算法的核心思想：最大程度的利用之前的信息。

事实上在比较的时候已经可以排除掉一些不可能成为答案的循环表示了，假设当前正在比较的是 $s_i$ 开头的循环表示和 $s_j$ 开头的循环表示，且在 $s_{i+k}$ 和 $s_{j+k}$ 处比较出了大小为 $s_{i+k}<s_{j+k}$（这里默认 $s$ 是循环的，也就是 $s_{n+i}=s_{i}$），则对所有 $p \in [j,j+k]$，以 $s_p$ 开头的循环表示总是在 $s_{j+k}$ 这一位大于以 $s_{p-j+i}$ 开头的循环表示，于是我们可以直接将 $j$ 跳到 $j+k+1$ 来和 $i$ 进行新一轮的比较，反之亦然。

重复比较直到 $i$ 或 $j$ 跳出了 $s$ 或者 $k=n$，前者说明所有循环表示都已经扫了一遍了，于是还没有跳出 $s$ 的那个就是最小循环表示；后者说明两者相等，也就说明 $s$ 存在一个整周期且这个周期已经被扫过了，于是 $i,j$ 任取其一都为答案。

一个特殊情况是 $i=j$，此时我们只需要任取其一往后推一位即可。

每比较一位 $i+j+k$ 至少增加一，于是时间复杂度是 $\Theta(n)$ 的。

```cpp
#include <iostream>

using namespace std;

int n;
string s;

int main() {
  cin.tie(0)->sync_with_stdio(0);
  cin >> n >> s;
  int i = 0, j = 0;
  for (int k = 0; i < n && j < n && k < n; ) {
    if (i == j) {
      ++i;
    }
    if (s[(i + k) % n] == s[(j + k) % n]) {
      ++k;
    } else if (s[(i + k) % n] < s[(j + k) % n]) {
      j += k + 1, k = 0;
    } else {
      i += k + 1, k = 0;
    }
  }
  i = min(i, j);
  cout << s.substr(i) + s.substr(0, i);
  return 0;
}
```

---


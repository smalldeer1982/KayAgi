# 【模板】最小表示法

## 题目描述

小敏和小燕是一对好朋友。

他们正在玩一种神奇的游戏，叫 Minecraft。

他们现在要做一个由方块构成的长条工艺品。但是方块现在是乱的，而且由于机器的要求，他们只能做到把这个工艺品最左边的方块放到最右边。

他们想，在仅这一个操作下，最漂亮的工艺品能多漂亮。

两个工艺品美观的比较方法是，从头开始比较，如果第 $i$ 个位置上方块不一样那么谁的瑕疵度小，那么谁就更漂亮，如果一样那么继续比较第 $i+1$ 个方块。如果全都一样，那么这两个工艺品就一样漂亮。

## 说明/提示

- 对于 $20\%$ 的数据，$n\le 1000$；
- 对于 $40\%$ 的数据，$n\le 10^4$；
- 对于 $100\%$ 的数据，$n\le 3\times 10^5$。

## 样例 #1

### 输入

```
10
10 9 8 7 6 5 4 3 2 1
```

### 输出

```
1 10 9 8 7 6 5 4 3 2
```

# 题解

## 作者：xht (赞：38)

> 怎么没人用 Lyndon 分解求最小表示法呢？它这么冷门的嘛...

## Lyndon 串

对于一个字符串，若其本身就是其最小后缀，则称它为 Lyndon 串。

形式化地，对于长度为 $n$ 的字符串 $s$，若满足对于 $i \in [2,n]$，都有 $s < s[i:n]$，则称其为 Lyndon 串。

## Lyndon 分解

任意一个字符串都可以被唯一的分解成若干个字典序非严格递减的 Lyndon 串。

形式化地，对于长度为 $n$ 的字符串 $s$，存在唯一的若干个 Lyndon 串 $t_{1\dots m}$，满足 $s=t_1 + t_2 + \cdots + t_m$ 且 $t_1 \ge t_2 \ge \cdots \ge t_m$。

## Duval 算法

Duval 算法可以在 $\mathcal O(n)$ 的时间求出一个字符串的 Lyndon 分解。

维护三个指针 $i,j,k$，这三个指针将整个字符串分成了四个部分 $s[1:i-1], s[i,k-1], s[j,k-1], s[k,n]$：

- $s[1,i-1]$：这部分的 Lyndon 分解已经完成。
- $s[i,k-1]$：这部分可以被表示成 $t^c + v$，其中 $t$ 是一个 Lyndon 串，$t^c$ 表示 $t$ 循环 $c$ 次，$v$ 是 $t$ 的一个可空真前缀。
- $s[j,k-1]$：注意这部分是包含在上一个部分中的，其中 $j = k - |t|$。
- $s[k,n]$：这部分还未处理，此时正在考虑 $k$。

考虑 $k$ 有三种情况：

- $s_j = s_k$：可以将 $t$ 继续循环下去，因此 $j$ 往后移一位，考虑下一个 $k$。
- $s_j < s_k$：可以将 $t^c + v + s_k$ 合并为一个 Lyndon 串，因此 $j$ 设为 $i$，考虑下一个 $k$。
- $s_j > s_k$：可以将 $t$ 单独作为 Lyndon 分解中的一个串，然后从 $v$ 的开头开始重新考虑，因此 $i$ 设为 $v$ 的开头，$j,k$ 对应设为 $i,i+1$。

#### 【模板】[P6114 【模板】Lyndon 分解](https://www.luogu.com.cn/problem/P6114)

```cpp
const int N = 5e6 + 7;
int n, ans;
char s[N];

int main() {
	rds(s, n);
	int i = 1;
	while (i <= n) {
		int j = i, k = i + 1;
		while (k <= n && s[j] <= s[k]) j = s[j] == s[k++] ? j + 1 : i;
		while (i <= j) i += k - j, ans ^= i - 1;
	}
	print(ans);
	return 0;
}
```

## 最小表示法

一个字符串的**最小表示**定义为其所有循环同构中字典序最小的串。

形式化地，对于长度为 $n$ 的字符串 $s$，若 $p \in [1,n]$ 满足对于 $i \in [1, n]$，都有 $s[p:n] + s[1:p-1] \le s[i:n] + s[1:i-1]$，则称 $s[p:n] + s[1:p-1]$ 为 $s$ 的最小表示。

最小表示法可以使用 Lyndon 分解求出。

对于长度为 $n$ 的字符串 $s$，设 $t = s + s$，对 $t$ 进行 Lyndon 分解，找到首字符位置 $\le n$ 且最大的 Lyndon 串，这个串的首字符即最小表示法的首字符。

#### 【模板】[P1368 工艺 /【模板】最小表示法](https://www.luogu.com.cn/problem/P1368)

```cpp
const int N = 6e5 + 7;
int n, ans, s[N];

int main() {
	rd(n);
	for (int i = 1; i <= n; i++) rd(s[i]), s[i+n] = s[i];
	int i = 1;
	while (i <= n) {
		int j = i, k = i + 1;
		while (k <= n * 2 && s[j] <= s[k]) j = s[j] == s[k++] ? j + 1 : i;
		while (i <= j) i += k - j, ans = i <= n ? i : ans;
	}
	if (ans == 0) ans = n;
	for (int i = 1; i <= n; i++) print(s[ans-1+i], " \n"[i==n]);
	return 0;
}
```

#### 【例题】[UVA719 Glass Beads](https://www.luogu.com.cn/problem/UVA719)

与上一题不同的是，这题要求位置最靠前。

只有一种情况下两道题的答案不一样，那就是字符串恰好为一个循环串的时候。

那么我们换一个写法即可。

```cpp
const int N = 2e4 + 7;
int n, ans;
char s[N];

inline void solve() {
	rds(s, n);
	for (int i = 1; i <= n; i++) s[i+n] = s[i];
	int i = 1;
	while (i <= n) {
		ans = i;
		int j = i, k = i + 1;
		while (k <= n * 2 && s[j] <= s[k]) j = s[j] == s[k++] ? j + 1 : i;
		while (i <= j) i += k - j;
	}
	print(ans);
}

int main() {
	int T;
	rd(T);
	while (T--) solve();
	return 0;
}
```

## 参考资料

- OI Wiki [Lyndon 分解](https://oi-wiki.org/string/lyndon/#finding-the-smallest-cyclic-shift)
- wucstdio [题解 P6127 【【模板】Lyndon 分解】](https://www.luogu.com.cn/blog/wucstdio/solution-p6127)

---

## 作者：partychicken (赞：29)

最小表示法是用于解决字符串最小表示问题的方法（废话

### 字符串的最小表示

#### 循环同构

当字符串 $S$ 中可以选定一个位置 $i$ 满足

$$
S[i\cdots n]+S[1\cdots n-1]=T
$$

则称 $S$ 与 $T$ 循环同构

#### 最小表示

字符串 $S$ 的最小表示为与 $S$ 循环同构的所有字符串中字典序最小的字符串

### simple的暴力

我们直接比较与 $S$ 同构的所有字符串，共 $n$ 个。

每次保留当前字典序最小的字符串与剩余的字符串比较。

```c++ 
int k=0,i=0,j=1;
for(;j<n;j++)
{
    if(sec[(i+k)%n]==sec[(j+k)%n])
    {
        k++;
    }
    else
    {
        if(sec[(i+k)%n]>sec[(j+k)%n]%n)
        {
            i=j;
        }
        k=0;
    }
}
```



随机数据下表现良好，但是可以构造特殊数据卡掉。

例如：对于 $aaa\cdots aaa$ ,不难发现这个算法的复杂度退化为 $O(n^2)$

我们发现，当字符串中出现多个连续重复子串时，此算法效率降低，我们考虑优化这个过程。

### 最小表示法

#### 算法核心

考虑对于一对字符串 $A,B$ ,它们在原字符串 $S$ 中的起始位置分别为 $i,j$ ,且它们的前 $k$ 个字符均相同，即

$$
A[i...i+k-1]=B[j...j+k-1]
$$

不妨先考虑 $A[i+k]>B[j+k]$ 的情况，我们发现起始位置下标 $l$ 满足 $i\le l\le i+k$ 的字符串均不能成为答案。因为对于任意一个字符串 $S_{i+p}$（表示以 $i+p$ 为起始位置的字符串）一定存在字符串 $S_{j+p}$ 比它更优。

所以我们比较时可以跳过下标 $l\in [i,i+k]$ ,直接比较 $S_{i+k+1}$

这样，我们就完成了对于上文暴力的优化。

#### 时间复杂度

$O(n)$

~~证明：显然~~

#### 算法流程

1. 初始化指针 $i$ 为 $0$，$j$ 为 $1$；初始化匹配长度 $k$ 为 $0$
2. 比较第 $k$ 位的大小，根据比较结果跳转相应指针。若跳转后两个指针相同，则随意选一个加一以保证比较的两个字符串不同
3. 重复上述过程，直到比较结束
4. 答案为 $i,j$ 中较小的一个

#### 代码

```c++
int k=0,i=0,j=1;
while(k<n&&i<n&&j<n)
{
    if(sec[(i+k)%n]==sec[(j+k)%n])
    {
        k++;
    }
    else
    {
        sec[(i+k)%n]>sec[(j+k)%n]?i=i+k+1:j=j+k+1;
        if(i==j) i++;
        k=0;
    }
}
i=min(i,j);
```



---

## 作者：Rainbow_qwq (赞：23)

[P1368 工艺](https://www.luogu.com.cn/problem/P1368)

---

另外一篇 SAM 的题解怎么这么简略啊...我来发一个。

用后缀自动机做这题其实很简单。

样例：`10 9 8 7 6 5 4 3 2 1`

首先，我们把整个串倍长，就像这样：`10 9 8 7 6 5 4 3 2 1  10 9 8 7 6 5 4 3 2 1`

然后，最小的排列就是这个串的一个长度为 $n$ 的子串。

求长度为 $n$ 的字典序最小子串，自然可以用后缀自动机做。

对这个串建后缀自动机，然后从 $1$ 点开始，走 $n$ 步，每次都走最小的。

全是数字怎么办？那就全部开 `map<int,int>` ！

代码+注释：
```cpp
#include<bits/stdc++.h>
#define For(i,a,b) for(register int i=(a);i<=(b);++i)
#define Rep(i,a,b) for(register int i=(a);i>=(b);--i)
using namespace std;
inline int read()
{
    char c=getchar();int x=0;bool f=0;
    for(;!isdigit(c);c=getchar())f^=!(c^45);
    for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+(c^48);
    if(f)x=-x;return x;
}
#define maxn 300003
int n,a[maxn];
map<int,int>ch[maxn<<2];//全部暴力建map
int tot=1,lst=1,len[maxn<<2],fail[maxn<<2];
void append(int c)
{
	int u=++tot,p=lst;
	len[u]=len[p]+1;
	for(;p&&!ch[p][c];p=fail[p])ch[p][c]=u;
	if(!p)fail[u]=1;
	else{
		int q=ch[p][c];
		if(len[q]==len[p]+1)fail[u]=q;
		else{
			int cc=++tot;
			fail[cc]=fail[q],len[cc]=len[p]+1;
			ch[cc]=ch[q];//直接写=
			for(;p&&ch[p][c]==q;p=fail[p])ch[p][c]=cc;
			fail[q]=fail[u]=cc;
		}
	}lst=u;
}
signed main()
{
	n=read();
	For(i,1,n)a[i]=read();
	For(_,1,2)For(i,1,n)append(a[i]);
	int p=1;
	For(i,1,n){
		map<int,int>::iterator q=ch[p].begin();
        //解释：q是迭代器
        //(*q).first是这条边的值
        //(*q).second是这条边连着的下一个节点
		p=(*q).second;
		cout<<(*q).first<<' ';
	}
    return 0;
}
```

---

## 作者：AThousandSuns (赞：10)

裸的后缀数组。

建一个长为 $2n$ 的串 $S'=S+S$，那么串 $S$ 的所有变换形式都是 $S'$ 的子串。

然后求出后缀数组，前 $n$ 个后缀中排名最小的就是答案。

$a$ 不知道有多大，所以要离散化。
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=600060;
#define PB push_back
#define MP make_pair
#define lson o<<1,l,mid
#define rson o<<1|1,mid+1,r
#define FOR(i,a,b) for(int i=(a);i<=(b);i++)
#define ROF(i,a,b) for(int i=(a);i>=(b);i--)
#define MEM(x,v) memset(x,v,sizeof(x))
inline int read(){
	char ch=getchar();int x=0,f=0;
	while(ch<'0' || ch>'9') f|=ch=='-',ch=getchar();
	while(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();
	return f?-x:x;
}
int n,m,a[maxn],b[maxn],tmp[maxn],sa[maxn],rak[maxn],cnt[maxn];
void radix_sort(){
	MEM(cnt,0);
	FOR(i,1,n) cnt[rak[tmp[i]]]++;
	FOR(i,1,m) cnt[i]+=cnt[i-1];
	ROF(i,n,1) sa[cnt[rak[tmp[i]]]--]=tmp[i];
}
void Suffix_Array(){
	FOR(i,1,n) rak[tmp[i]=i]=a[i];
	radix_sort();
	for(int d=1,p=1;p<n;m=p,d<<=1){
		p=0;
		FOR(i,1,d) tmp[++p]=n-d+i;
		FOR(i,1,n) if(sa[i]>d) tmp[++p]=sa[i]-d;
		radix_sort();swap(tmp,rak);
		rak[sa[1]]=p=1;
		FOR(i,2,n) rak[sa[i]]=(tmp[sa[i]]==tmp[sa[i-1]] && tmp[sa[i]+d]==tmp[sa[i-1]+d])?p:++p;
	}
}
int main(){
	n=read();
	FOR(i,1,n) a[i]=b[i]=b[i+n]=tmp[i]=read();
	sort(tmp+1,tmp+n+1);m=unique(tmp+1,tmp+n+1)-tmp-1;
	FOR(i,1,n) a[i]=a[i+n]=lower_bound(tmp+1,tmp+m+1,a[i])-tmp;	//以上离散化
	n*=2;Suffix_Array();n/=2;
	int minid=1;
	FOR(i,2,n) if(rak[i]<rak[minid]) minid=i;	//前n个后缀中排名最小的
	FOR(i,minid,minid+n-1) printf("%d ",b[i]);	//注意要输出原数组！
}
```

---

## 作者：_l_l_ (赞：5)

## [最小表示法](https://www.luogu.com.cn/problem/P1368)

> 给定一个字符串(或数组)，可以将字符串末尾字母移动到最前面，也可以将首位字母移动到最前面，问移动若干次后，字典序最小的字符串？

我们可以使用双指针的做法，下面讲解一下双指针做法的过程与正确性：

1. `seq[i]`不等于`seq[j]`

   不妨设`seq[i] < seq[j]`
   
   由于`seq[j]`太大了，因此我们保留`seq[i]`，将`j`加1

2. `seq[i]`等于`seq[j]`

   假设从`seq[i]`与`seq[j]`开始，连续`k`个数都相等，第`k+1`个数不相等，那么：
   
   不妨设`seq[(i + k) % n] < seq[(j + k) % n]`
   
   因此以`j, (j + 1) % n, ..., (j + k) % n`开头的"答案"均可被`i, (i + 1) % n, ..., (i + k) % n`省略掉，可以将`j`加上`k + 1`
   
仔细观察发现第一种分类可以归为第二种分类k=0时的情况
因此，理论上来讲，这其实是一个**三指针做法**~~好吧我瞎编的~~

代码：
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
const int MAXN = 300001;
int seq[MAXN];
int main() {
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf("%d", &seq[i]);
    }
    int i, j, k;
    for (i = 0, j = 1, k = 0; i < n && j < n && k < n; ) {
        if (seq[(i + k) % n] == seq[(j + k) % n]) {
            k++;
        }
        else {
            seq[(i + k) % n] > seq[(j + k) % n] ? i += k + 1 : j += k + 1;
            if (i == j) i++;
            k = 0;
        }
    }
    int ans = min(i, j);
    for (k = 0; k < n; k++) {
        printf("%d ", seq[(ans + k) % n]);
    }
    return 0;
}
```

---

## 作者：luokc (赞：2)

# 最小表示法 
## 概念   
最小表示法全称**字符串的最小表示法**      
对于一个字符串，它可以从不同的位置开始顺时针或逆时针读取，从而得到不同的线性字符串表示，而最小表示法就是要找到这些表示中字典序最小的那个。
例如，对于字符串 `abc`，它的表示有 `abc`、`bca` 和 `cab`，其中字典序最小的是 `abc`。
## 思路
1.  初始化两个指针 $i$ 和 $j$，分别指向字符串的起始位置。
  
2. 用一个变量 $k$ 表示当前比较的长度，初始值为 $0$。
   
3. 比较从 $i$ 和 $j$ 开始长度为 $k$ 的子串：
    - 如果 $num_{i+k}$ 和 $num_{j+k}$ 相等，则 $k$ 加 $1$，继续比较下一个字符。
        
    - 如果 $num_{i+k}$ 小于 $num_{j+k}$，说明以 $j$ 开头的子串不可能是最小表示，将 $j$ 更新为 $j + k + 1$。
    - 如果 $num_{i+k}$ 大于 $num_{j+k}$，说明以 $i$ 开头的子串不可能是最小表示，将 $i$ 更新为 $i$ + $k$ + $1$。
4. 重复步骤 $3$，直到 $i$ 、$j$ 或 $k$ 超出字符串的长度范围。
         
5. 最后返回 $i$ 和 $j$ 中较小的那个，即为最小表示的起始位置。
       
## 代码实现


```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
// 实现最小表示法的函数，参数num是一个存储数字的向量
ll d(vector<ll>& num) {
    // 获取向量num的大小，即元素个数
    ll n = num.size();
    // 初始化两个指针i和j，分别指向字符串（这里是数字序列）的起始位置
    ll i = 0, j = 1, k = 0;
    // 当i、j都在有效范围内且比较的长度k也在有效范围内时，进行循环比较
    while (i < n && j < n && k < n) {
        // 比较从i和j开始长度为k的子串的下一个字符，计算差值
        int t = num[(i + k) % n] - num[(j + k) % n];
        // 如果差值为0，说明当前比较的字符相等，继续比较下一个字符，k加1
        if (t == 0) {
            k++;
        } else {
            // 如果差值大于0，说明以j开头的子串字典序更小，以i开头的子串不可能是最小表示
            // 将i更新为i + k + 1，即跳过不可能是最小表示的部分
            if (t > 0) {
                i = i + k + 1;
            } else {
                // 如果差值小于0，说明以i开头的子串字典序更小，以j开头的子串不可能是最小表示
                // 将j更新为j + k + 1，即跳过不可能是最小表示的部分
                j = j + k + 1;
            }
            // 如果i和j相等了，为了继续比较，将j向后移动一位
            if (i == j) {
                j++;
            }
            // 重置k为0，开始新一轮的比较
            k = 0;
        }
    }
    // 返回i和j中较小的那个，即为最小表示的起始位置
    return min(i, j);
}

int main() {
    ll n;
    // 输入数字序列的长度
    cin >> n;
    // 创建一个大小为n的向量num来存储数字序列
    vector<ll> num(n);
    // 依次输入数字序列的每个元素
    for (int i = 0; i < n; i++) {
        cin >> num[i];
    }
    // 调用函数d获取最小表示的起始位置
    ll a = d(num);
    // 按照最小表示的起始位置输出数字序列
    for (int i = 0; i < n; i++) {
        cout << num[(a + i) % n] << " ";
    }
    cout << endl;
    return 0;
}

```

---

## 作者：Refined_heart (赞：2)

一篇$\text{Suffix Tree}$的题解。

$\text{Solution:}$

显然题目要求一个环形的字符串的最小字典序字串且长度为$n.$

将原串复制后建立$\text{Suffix Tree}$即可。

之后，从根节点不断匹配当前字典序最小的字符，并将这条边上**压缩的字符**累计。

注意到$\text{Suffix Tree}$的边是压缩$\text{Trie}$所以并不好输出。代码中是暴力输出，若有问题也请看到这篇题解的大佬指出。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1.75e6+10;
const int inf=1e8;
int n,a[300010];
set<int>T;
vector<int>v;
struct SuffixTree{
	int link[MAXN],n,rem,tail,start[MAXN];
	int len[MAXN],s[MAXN],now;
	map<int,int>ch[MAXN];
	SuffixTree(){tail=now=1;n=rem=0;len[0]=inf;}
	int build(int a,int b){
		link[++tail]=1;
		start[tail]=a;len[tail]=b;
		return tail;
	}
	void Extend(int x){
		s[++n]=x;++rem;
		for(int last=1;rem;){
			while(rem>len[ch[now][s[n-rem+1]]])
				rem-=len[now=ch[now][s[n-rem+1]]];
			int &v=ch[now][s[n-rem+1]];
			int c=s[start[v]+rem-1];
			if(!v||x==c){
				link[last]=now;last=now;
				if(!v)v=build(n,inf);
				else break;
			}
			else{
				int u=build(start[v],rem-1);
				ch[u][c]=v;ch[u][x]=build(n,inf);
				start[v]+=rem-1;len[v]-=rem-1;
				link[last]=v=u;last=u;
			}
			if(now==1)--rem;
			else now=link[now];
		}
	}
}S;
char buf[1<<21],*p1=buf,*p2=buf;
inline int read(){
	#define gc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
	int s=0;
	char ch=gc();
	while(!isdigit(ch)){
		ch=gc();
	}
	while(isdigit(ch)){
		s=s*10+ch-'0';
		ch=gc();
	}
	return s;
}
void dfs(int u,int dep){
	if((int)v.size()>=n)return;
	if(dep>=inf)return;
	for(set<int>::iterator it=T.begin();it!=T.end();++it){
		int p=*it;
		if(p==inf)break;
		if(S.ch[u].count(p)){
			int R=S.start[S.ch[u][p]]+S.len[S.ch[u][p]]-1;
			int L=S.start[S.ch[u][p]],fg=0;
			for(int j=L;j<=R&&S.s[j]!=inf;++j){
				if(S.s[j]==inf){
					fg=1;
					break;
				}
				else v.push_back(S.s[j]);
			}
			if(fg)break;
			dfs(S.ch[u][p],dep+S.len[S.ch[u][p]]);
			break;
		}
	}
}
int main(){
	n=read();
	for(int i=1;i<=n;++i)a[i]=read(),T.insert(a[i]);
	for(int _=1;_<3;++_)for(int i=1;i<=n;++i)S.Extend(a[i]);
	S.Extend(inf);
	T.insert(inf);
	dfs(1,0);
	for(int i=0;i<n;++i)printf("%d ",v[i]);
	return 0;
}
```
最后问题：背模板的时候$len[v]-=rem-1$背成了$len[v]+=rem-1,$虽然答案不会错误（甚至过了$sam$模板）,但这会让$\text{Suffix Tree}$的压缩树边长度错误，导致各种运行时错误或者炸掉空间/时间。

---

## 作者：KobeBeanBryantCox (赞：1)

# P1368 【模板】最小表示法 题解

---------------

[题目传送门](https://www.luogu.com.cn/problem/P1368)。

既然是最小表示法的题目，我就来讲讲最小表示法。

--------------

## 算法介绍

### 1. 循环同构

若有一个字符串 $S=\texttt{dcab}$，则以下字符串组叫做 $S$ 的循环同构：

- $\texttt{dcab}$
- $\texttt{cabd}$
- $\texttt{abdc}$
- $\texttt{bdca}$

简单来说就是每次把 $S$ 的第一个字符拿出来放到最后，重复做 $|S|$ 次得到的字符串组。

--------------

### 2. 最小表示法

最小表示法就是用来求一个字符串的循环同构中，字典序最小的那个，在原串的起始位置。

例如在上面 $S=\texttt{dcab}$ 的例子中，字典序最小的是 $\texttt{abdc}$，在原串起始位置为 $2$（从 $0$ 开始），最小表示法就返回这个 $2$。

怎么找呢？

先破环成链（复制一遍拼到后面），比如有个字符串 $S=\texttt{acbacbc}$，破环成链后是 $S'=\texttt{acbacbcacbacbc}$。

考虑维护两个指针 $i,j$ 表示当前比较的两个循环同构的起点，和一个变量 $k$ 表示长度减一（减一是因为方便）。

对于每一组 $(i,j)$，$k$ 从 $0$ 开始枚举匹配。

比如上面 $S'$，当 $i=0,j=3,k=3$ 时匹配情况如下：

$$\begin{aligned}
&i\\
&\underline{\texttt{acb\color{blue}a}}\texttt{cbcacbacbc}\\
&\texttt{acb}\underline{\texttt{acb\color{blue}c}}\texttt{acbacbc}\\
&\texttt{ }\texttt{ }\texttt{ }j\\
\end{aligned}$$

我们发现 $S_{i+k}<S_{j+k}$，这意味着：

1. 从 $i$ 开始的循环同构要优于从 $j$ 开始的；
2. 从 $i+1$ 开始的循环同构优于从 $j+1$ 开始的；
3. $\cdots$
4. 从 $i+k$ 开始的循环同构优于从 $j+k$ 开始的。

所以所有 $j\sim j+k$ 开始的循环同构，都会被淘汰。

这个时候把 $j$ 赋值为 $j+k+1$，把 $k$ 清零，继续比较。

没看懂的可以结合代码理解。

-------------

## 正确性证明

正确性显然。现在来证明复杂度是 $O(n)$ 的。

考虑指针 $i,j$ 位移的大小。

每次比较向后扫描 $k$ 的长度，则 $i$ 或者 $j$ 会向右移动 $k$，此时 $i$ 和 $j$ 一共最多会移动 $2n$ 个位置。

所以复杂度是 $O(n)$ 的，这部分在代码也能很好地体现。

-------------

## 代码实现

我的代码并没有破环成链，不过基本思想是一样的。

```cpp
#include<bits/stdc++.h>
#define Code using
#define by namespace
#define wjb std
Code by wjb;
int in()
{
    int k=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9')
    {
        if(c=='-')f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9')k=k*10+c-'0',c=getchar();
    return k*f;
}
void out(int x)
{
    if(x<0)putchar('-'),x=-x;
    if(x<10)putchar(x+'0');
    else out(x/10),putchar(x%10+'0');
}
const int N=3e5+10;
int a[N];
int minshow(int n)
{
    int i=0,j=1,k=0; // 赋初值
    while(i<n&&j<n&&k<n) // 这是循环的条件
        if(a[(i+k)%n]==a[(j+k)%n])k++; // 如果相等，就暴力往后扫描 k
        else
        {
            if(a[(i+k)%n]>a[(j+k)%n])i+=k+1; // i 的位置劣于 j，将 i 赋值为 i+k+1
            else j+=k+1; // 否则将 j 赋值为 j+k+1
            if(i==j)i++; // 若相同是没有意义的，随便偏移一位即可
            k=0; // 清零 k 重新扫描
        }
    return min(i,j); // 此时要么 i==n，要么 j==n，返回 min(i,j) 就能得到正确的位置。注意这里如果是因为 k==n 退出的，说明字符串都是同一个字符，随便返回一个都行，所以也可以用 min(i,j)
}
int main()
{
    int n=in();
    for(int i=0;i<n;i++)a[i]=in();
    int ans=minshow(n);
    for(int i=0;i<n;i++)out(a[(i+ans)%n]),putchar(' ');
    return 0;
}
```

-----------------

若不清或有误，欢迎评论或私信。

---

## 作者：ouxiyao (赞：1)

[传送门](https://www.luogu.com.cn/problem/P1368)

# 最小表示法
在做本题前，首先，我们要知道什么是最小表示法。                  
在这之前，先讲一个概念：**循环同构串**。$n$ 为 $S$ 长度，当串 $S$ 中选一位置 $i$，$T=s[i\to n]+s[1\to(i-1)]（1\leq i\leq n)$，则 $T$ 为 $S$ 的循环同构串。                          
$S$ 的最小表示法为 $S$ 的所有循环同构串中字典序最小的那一个串。                    
举个“栗子”，设 $S={2,4,1,3}$，则他的循环同构串有 ```2,4,1,3   4,1,3,2   1,3,2,4   3,2,4,1```，很明显，第三个串是最小的。     
# 方法
### 1，断环成链
数组复制一遍即可。如 ${2,4,1,3}$，复制一遍变为 ${2,4,1,3,2,4,1,3}$。

```cpp
for(int i = 1;i<=n;i++){
    cin>>a[i];
    a[i+n] = a[i];//断环成链。
}
```

### 2，三指针 $i,j,k$ 扫描
循环中，$k$ 每一轮从 $1$ 到 $n$ 枚举一次，直到 $k\ge n$ 或 $a[i+k]!=a[j+k]$ 为止。                
当 $a[i+k] > a[k+j]$ 时，$i=i+k+1$ 否则 $j = j+k+1$。
为什么这样呢？举个例子：

```
i = 1,j = 2,k = 3
1 3 4 2   1 3 4 2
i-----i+k
1 3 4 2 1   3 4 2
  j-----j+k
```
因为 $i+k>j+k$，所以 $i$ 到 $i+k$ 中任何一个位置打头均不是最小表示法（这是因为之后每判断到这个地方均会排除一次）。$j$ 同理。           
最后，$i,j$ 总有一个等于 $n$ 的，返回不等于 $n$ 的那一个就好了。         

```cpp
int mins(){
    int i = 1,j = 2,k = 0;//三指针扫描。
    while(i<=n&&j<=n){
        for(k = 0;k<n&&a[i+k]==a[j+k];k++);//枚举 k
        if(a[i+k]<=a[k+j])j = j+k+1;
        else if(a[k+i]>a[j+k])i = i+k+1;
        if(i==j)j++;//相等情况。
    }
    return min(i,j);
}
```
对，不要忘了 $i=j$ 的情况。
### 3，输出
循环 $\min(i,j)$ 到 $\min(i,j)+n$ 并输出，完事。     
放代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[700010],n;//此处切记，数组长度为数据的两倍。
int mins(){
    int i = 1,j = 2,k = 0;//三指针扫描。
    while(i<=n&&j<=n){
        for(k = 0;k<n&&a[i+k]==a[j+k];k++);//枚举 k。
        if(a[i+k]<=a[k+j])j = j+k+1;
        else if(a[k+i]>a[j+k])i = i+k+1;
        if(i==j)j++;//相等情况。
    }
    return min(i,j);
}
int main(){
    ios::sync_with_stdio(0);//解绑。
    cin>>n;
    for(int i = 1;i<=n;i++){
        cin>>a[i];
        a[i+n] = a[i];//断环成链。
    }
    int v = mins();
    for(int i = 0;i<n;i++)cout<<a[i+v]<<' ';//i从零开始！
    return 0;
}
```
大佬不喜勿喷，有问题私信。

---

## 作者：a18981826590 (赞：0)

# [P1368 【模板】最小表示法](https://www.luogu.com.cn/problem/P1368)
## 题意简述
给定一个长度为 $l$ 的字符串 $S$，选择一个 $i(0 \le i < l)$，得到一个新字符串 $T=S[0,i]+S[i,l)$，求字典序最小的 $T$。
## 解题思路
设置两个指针 $x$ 和 $y$，初始分别指向 $S[0]$ 和 $S[1]$，将它们作为新字符串 $T_{x}$ 和 $T_{y}$ 的开头，然后一位一位地向后比较新字符串 $T_{x}$ 和 $T_{y}$ 每一位。

设当前比较第 $z(0 \le z < n)$ 位：

1. 若 $T_{x}[z]=T_{y}[z]$，将 $z$ 变为 $z+1$，继续比较下一位；
2. 若 $T_{x}[z] \ne T_{y}[z]$：
   * 若 $T_{x}[z] > T_{y}[z]$，则 $T_{x}$ 的字典序大于 $T_{y}$，故以 $T_{x}$ 中任意一位为开头的新字符串均不是原字符串的最小表示法（显然 $T_{y}$ 中相同位置为开头的新字符串字典序更小），故将 $x$ 变为 $x+z+1$；
   * 若 $T_{x}[z] < T_{y}[z]$，则 $T_{y}$ 的字典序大于 $T_{x}$，故以 $T_{y}$ 中任意一位为开头的新字符串均不是原字符串的最小表示法（显然 $T_{x}$ 中相同位置为开头的新字符串字典序更小），故将 $y$ 变为 $y+z+1$；
   * 若 $x=y$ 则将 $y$ 变为 $y+1$，因为若两者相同则新字符串相同，无法进行比较，最终将错误地认为当前新字符串即为最小表示法；将 $z$ 变为 $0$ 重新比较。

若 $x \ge n$，此时 $y<n$，则 $T_{y}$ 即为最小表示法；若 $y \ge n$，此时 $x<n$，则 $T_{x}$ 即为最小表示法；若 $z \ge n$，则 $T_{x}$ 和 $T_{y}$  均为最小表示法；得到答案。
## [AC](https://www.luogu.com.cn/record/206890156) 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[300010],n,x,y=1,z;
int main(){
	ios::sync_with_stdio(0);
	cin>>n;
	for(int i=0;i<n;i++) cin>>a[i];
	while(x<n&&y<n&&z<n){
		if(a[(x+z)%n]==a[(y+z)%n]) z++;
		else{
			if(a[(x+z)%n]>a[(y+z)%n]) x+=z+1;
			else y+=z+1;
			if(x==y) y++;
			z=0;
		}
	}
	for(int i=min(x,y);i<n;i++) cout<<a[i]<<' ';
	for(int i=0;i<min(x,y);i++) cout<<a[i]<<' ';
	return 0;
}
```

---

## 作者：TemplateClass (赞：0)

### 题意

给出一个长度为 $n$ 的字符串 $S$，求所有和 $S$ 循环同构的字符串中字典序最小的字符串。

对于 $100 \%$ 的数据，$1 \le n \le 3 \times 10 ^ 5$。

### 题解

先考虑如何暴力，为了引出正解，我们采用一种双指针的写法。我们可以枚举所有和 $S$ 循环同构的字符串（其实本质上就是枚举起始下标）。

我们用 $i, j$ 表示我们当前枚举的两个字符串的起始下标，然后通过让 $k = 1, 2, 3, \cdots, n$ 逐位枚举，若以 $i, j$ 为起始下标的字符串的第 $k$ 位不同，则让字典序较大的指针加一，然后 $k = 1$ 重新开始比较。在枚举结束后，$\min(i, j)$ 即是所求字符串的起始下标。

指针 $i, j$ 的移动次数是 $O(n)$ 的，而且比较次数也是 $O(n)$ 的，所以时间复杂度 $O(n ^ 2)$。

代码如下（片段）：

```cpp
std::cin >> n;
for(int i = 0; i < n; ++i) {
	std::cin >> s[i];
}

int i = 0, j = 1;
for(int k = 0; std::max({i, j, k}) < n; ) {
	if(s[(i + k) % n] == s[(j + k) % n]) ++k;
	else {
		if(s[(i + k) % n] > s[(j + k) % n]) ++i;
		else ++j;
		k = 0; if(i == j) ++i;
	} 
}

int ans = std::min(i, j);
for(int i = 0; i < n; ++i) {
	std::cout << s[(i + ans) % n] << " ";
}
```

我们观察到，在暴力做法中每次我们把指针 $i$ 或 $j$ 加上的数都是 $1$，这实际上是没有必要的，由于我们已经比较到了第 $k$ 位才发现不同，所以容易证明 $S _ j \sim S _ {j + k}$ 都 $> S _ i$，因而 $j$ 直接加上 $k + 1$ 即可，$i$ 的情况同理。

于是这样就 $O(n)$ 了。

```cpp
std::cin >> n;
for(int i = 0; i < n; ++i) {
	std::cin >> s[i];
}

int i = 0, j = 1;
for(int k = 0; std::max({i, j, k}) < n; ) {
	if(s[(i + k) % n] == s[(j + k) % n]) ++k;
	else {
		if(s[(i + k) % n] > s[(j + k) % n]) i += k + 1;
		else j += k + 1;
		k = 0; if(i == j) ++i;
	} 
}

int ans = std::min(i, j);
for(int i = 0; i < n; ++i) {
	std::cout << s[(i + ans) % n] << " ";
}
```

---

另：截至 2025/3/12，暴力的 $O(n ^ 2)$ 代码仍然能够通过这道模板题，甚至经过我的测试，$O(n ^ 2)$ 和 $O(n)$ 算法之间的总耗时差距小于 4ms，不知道什么时候会加强。

---


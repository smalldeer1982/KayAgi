# 背单词

## 题目背景

小明对英语一窍不通，令老师十分头疼。于是期末考试前夕，小明被逼着开始背单词……


## 题目描述

老师给了小明一篇长度为N的英语文章，然后让小明背M个单词。为了确保小明不会在背单词时睡着，老师会向他提Q个问题，每次老师随机选择一个区间L..R，小明要回答在这段文字中他背过的单词总共出现过多少次。


## 说明/提示

数据范围：

对于30%的数据，1<=N<=10^3,1<=Q<=10^3

对于60%的数据，1<=N<=10^5,1<=Q<=10^5

对于100%的数据，1<=N<=10^6,1<=M<=10,1<=Q<=10^6,1<=每个单词的长度<=N,1<=L<=R<=N

提示：数据较大，请大家尽量采取高效率的读入输出方法。


## 样例 #1

### 输入

```
3 3
abcabcbc
abc
bc
a
1 3
6 7
1 8```

### 输出

```
3
0
7
```

# 题解

## 作者：ZlycerQan (赞：11)

/\*
luogu P2353 背单词

    
由于M很小

可以进行M次kmp

    
统计出M个前缀和

    
每次输出时把 M 个前缀和扫一遍

注意区间的开闭问题

    
由于r端点的串不包含在所查询的区间内

所以要减去当前模式串的长度


\*/
```cpp
#include <cstdio>
#include <cstring>

#define Max 1000090

void read (int &now)
{
    now = 0;
    register char word = getchar ();
    while (word > '9' || word < '0')
        word = getchar ();
    while (word >= '0' && word <= '9')
    {
        now = now * 10 + word - '0';
        word = getchar ();
    }
}

int __next[Max];

void Get_Next (char *line)
{
    __next[0] = -1;

    for (int pos_1 = 0, pos_2 = -1, Len = strlen (line); pos_1 < Len; )
        if (pos_2 == -1 || line[pos_1] == line[pos_2])
        {
            pos_1 ++;
            pos_2 ++;
            __next[pos_1] = pos_2;
        }
        else
            pos_2 = __next[pos_2];
    
}

int __sum[Max][Max / 100000 + 1];

void Kmp (char *line, char *__txt, int number)
{
    for (int Len_txt = strlen (__txt), Len = strlen (line), pos_1 = 0, pos_2 = 0; pos_1 <= Len_txt; )
    {
        if (pos_2 == -1 || __txt[pos_1] == line[pos_2])
        {
            pos_1 ++;
            pos_2 ++;
        }
        else
            pos_2 = __next[pos_2];
        if (pos_2 == Len)
        {
            __sum[pos_1][number] ++;
            pos_2 = __next[pos_2];
        }
    }
}

char __txt[Max];

int length[Max];
char line[Max];

int main (int argc, char *argv[])
{
    int N, M;
    
    read (N);
    read (M);
    
    scanf ("%s", __txt);
    
    int Len_txt = strlen (__txt);
    
    for (int i = 1; i <= N; i ++)
    {
        scanf ("%s", line);
        
        Get_Next (line);
        Kmp (line, __txt, i);
        
        length[i] = strlen (line);
    }
    
    for (int i = 1; i <= Len_txt; i ++) // 把每个模式串的前缀和分开存 
        for (int j = 1; j <= N; j ++)
            __sum[i][j] += __sum[i - 1][j];
    
    for (int i = 1, x, y, Answer; i <= M; i ++)
    {
        read (x);
        read (y);
        Answer = 0;
        
        for (int j = 1; j <= N; j ++)
            if (x - 1 <= y - length[j])
                Answer += __sum[y][j] - __sum[x + length[j] - 2][j];
    
        printf ("%d\n", Answer);
    }
    return 0;
}
```

---

## 作者：夏色祭 (赞：6)

#作为第一个过此题的P党，我果断选择发波题解造福广大P党的朋友们

因为单词的数量很少，所以我们可以用一个数组sum保存到第i位时第j个单词出现了几次

那么，其实此题的思路其实就是kmp+前缀和。

注意两个地方：

1.每个单词的长度一定要用一个数组保存好，如果每次都是去length，那只有90。

2.最后对于每个区间[l,r]，答案为∑（下标为j=1,上面为n）sum[r,j]-sum[l+len[j]-2,j]，这个的原因主要是蒟蒻的我的方法有点鬼畜。。。

##具体看代码。。。

代码：

```cpp
var
  sum:array[0..1000000,1..10]of longint;
  word:array[0..11]of ansistring;
  len:array[0..11]of longint;
  n,m,i,j,l,r,x,ans:longint;
  s:ansistring;
procedure kmp(k:longint);
var
  next:array[0..1000000]of longint;
  i,j,tt,zz:longint;
  x:ansistring;
begin
  fillword(next,sizeof(next) div 2,0);
  j:=0;
  x:=word[k];
  for i:=2 to len[k] do 
    begin
      while (j>0)and(x[j+1]<>x[i]) do j:=next[j];
      if x[j+1]=x[i] then inc(j);
      next[i]:=j;
    end;//kmp的常规操作——计算next数组
  j:=0;
  tt:=0;
  for i:=1 to length(s) do
    begin
      sum[i,k]:=tt;
      while (j>0)and(x[j+1]<>s[i]) do j:=next[j];
      if x[j+1]=s[i] then inc(j);
      if j=len[k] then 
        begin
          inc(tt);
          j:=next[j];
          sum[i,k]:=tt;
        end;
    end;//在文章中匹配第k个单词
end;//kmp，计算前缀和
begin
  readln(n,m);
  readln(s);
  for i:=1 to n do 
    begin
      readln(word[i]);
      len[i]:=length(word[i]);//注意单词的长度一定要用一个数组存储
    end; 
  for i:=1 to n do kmp(i);//匹配每个单词
  for i:=1 to m do 
    begin
      readln(x,r);
      ans:=0;
      for j:=1 to n do
        begin
          if r-x+1<len[j] then continue;//如果区间的长度比这个单词的长度要小，那个这个单词肯定不会出现在这个区间里
          l:=x;
          inc(l,len[j]-1);//精髓，自己理解
          inc(ans,sum[r,j]-sum[l-1,j]);
        end;
      writeln(ans);
    end;
end.
```

---

## 作者：2huk (赞：5)

- 可以观察到单词总数 $m$ 很小，所以可以对于每一个单词求出 $l \sim r$ 中出现了多少次。

- 暴力显然是不行的。观察到这其实是**静态区间求和**的问题，可以利用前缀和解决。也就是说如果我们令 $sum_{i, j}$ 表示第 $i$ 个单词在前 $j$ 个字符中**完整地**出现了几次，那么显然第 $i$ 个单词在 $l \sim r$ 中出现了 $sum_{i, r} - sum_{i, l + len_i - 2}$（注意，不是减 $sum_{i, l - 1}$），其中 $len_i$ 表示第 $i$ 个单词的长度。

- 问题就来到了如何预处理所有的 $sum_{i, j}$。

- 首先我们要求出在原字符串的 $j - len_i + 1 \sim j$ 位置是否与第 $i$ 个单词相同。可以发现可以 KMP 或字符串 Hash 解决。然后前缀和递推即可。

- 总时间复杂度 $\mathcal(nm)$。[代码](https://www.luogu.com.cn/paste/my90z79i)。

---

## 作者：NewSjf (赞：4)

楼上的两篇题解思路都讲得挺好的了    
~~我觉得我的代码可读性比较好~~   
我就在这里补充一点点"精髓"吧    
首先这个题M很小,所以考虑跑M遍KMP,单独统计每个单词在前i个字符中的出现次数,也就是前缀和ans[i]       
至于为什么不能一起统计,和这个ans不满足区间减法有关    
区间[l,r]并不能像前缀和那样ans[r]-ans[l-1]算出来   
换句话说就是不满足区间减法    
因为我们的前缀和ans数组记录的是结束字符位于前i个字符的单词总数   
有可能某个单词的结束位置位于区间[l,r]     
但是起始位置不在这个区间     
那么简单的减法仍然会把这个'1'给算进去
换句话说我们要这个单词的起始位置和结束位置都在[l,r]才可行   
那么可行的单词里面最左端的起始位置就是l,而结束位置为l+lenth-1;也就是说在l+lenth-1之后结束的单词的才能计入答案   
即得到[l,r]的答案实际上应该统计[l+lenth-1,r]的前缀和   
如果[l,r]对应ans[r]-ans[l-1]     
那么[l+lenth-1,r]就对应ans[r]-ans[l+lenth-2];   
所以说代码里才会有那么奇怪的一句话   
还有就是注意单词长度大于寻味区间长度的情况   
关于卡常数   
首先这道题string无论怎么卡常也过不了的   
~~我就是先写了string~~   
char*+scanf*printf就比较稳了   
字符串长度要单独存起来   
EOF   
最后附上我自认为简洁的代码,希望大家有所收获   
```cpp
#include<iostream>
#include<cstring>
#include<string>
#define MAXN 1100000
using namespace std;
int nxt[12][MAXN],m,q,ans[12][MAXN],lenth[12];
char str[12][MAXN];
inline void build(int*nxt,char*s)  //初始化next数组 
{
	int t1=0,t2=nxt[0]=-1,size=strlen(s);
	while(t1<size)
		if(s[t1]==s[t2]||t2==-1)nxt[++t1]=++t2;
		else t2=nxt[t2];
}
inline void kmp(int*ans,int*nxt,char*s1,char*s2)
{
	int t1=0,t2=0,size1=strlen(s1),size2=strlen(s2);
	while(t1<size1&&t2<size2)
	{
		if(s1[t1]==s2[t2]||t2==-1)t1++,t2++;
		else t2=nxt[t2];
		if(t2==size2)                                //单词s2被找到 
			ans[t1]=1,                               //找到一个单词并且结尾位于t1 
			t2=nxt[t2];                              //abcabcabc里面找abcabc,两次出现位置可能会重复 
	}                                                //所以调到next[t2]的位置 
	for(int i=1;i<=size1;i++)ans[i]+=ans[i-1];       //ans[i]即为文章前i个字符中单词s1的出现次数 
}
int main()
{
	scanf("%d%d",&m,&q);
	for(int i=0;i<=m;i++)scanf("%s",str[i]),getchar();
	for(int i=1;i<=m;i++)
	{
		build(nxt[i],str[i]);
		kmp(ans[i],nxt[i],str[0],str[i]);
		lenth[i]=strlen(str[i]);                    //常数优化 
	}
	for(int i=1;i<=q;i++)
	{
		int l,r,tot=0;
		scanf("%d%d",&l,&r);
		for(int j=1;j<=m;j++)                       //单独统计每个单词 
		{
			if(lenth[j]<=r-l+1)                     //如果统计的区间比单词长度还小,显然这个单词不应该出现 
				tot+=ans[j][r]-ans[j][l+lenth[j]-2];  //！ 
		} 
		printf("%d\n",tot);
	}
}
```


---

## 作者：Starstream (赞：1)

### 知识点

KMP 字符串匹配，前缀和。

### 思路

观察数据范围，我们发现 $Q \leq 10^6, M \leq 10$。

于是考虑枚举每个小明背过的单词 $p$，跑 KMP 后开一个数组 $f_{i,j}$ 记录原字符串 $s$ 中模式串 $p_i$ 完全匹配且匹配位置 **左端点** 在 $s$ 前缀 $[1,j]$ 中的 $p_i$ 的个数。

不过接下来我们发现它不满足区间减法，也就是不能通过 $f_{i,r}-f_{i,l-1}$ 直接求出。

这是因为尽管 $p_i$ 左端点在区间 $[l,r]$ 中，但不能保证右端点也在此区间中。

所以查询区间 $[l,r]$ 的时候我们选择区间 $[l,r-|p_i|+1]$ 以保证这个字符串完整地在区间 $[l,r]$ 中。

预处理时间复杂度 $O(M\sum_{i=1}^{M}|p_i|)$，查询时间复杂度 $O(1)$，可以接受。

### 代码

```cpp
#include <iostream>
#include <cstring>

using namespace std;

const int N = 1000010;

int M, Q;
char p[N], s[N];
int ne[N], cnt[N];
int f[11][N];

inline void get_next(char *p)
{
    int n = strlen(p + 1);
    memset(ne, 0, sizeof ne); // 多测需要清空
    for (int i = 2, j = 0; i <= n; i ++ )
    {
        while (j && p[i] != p[j + 1]) j = ne[j];
        if (p[i] == p[j + 1]) j ++ ;
        ne[i] = j;
    }
}

inline void kmp(int id, char *s, char *p)
{
    int n = strlen(p + 1), m = strlen(s + 1);
    for (int i = 1, j = 0; i <= m; i ++ )
    {
        while (j && s[i] != p[j + 1]) j = ne[j];
        if (s[i] == p[j + 1]) j ++ ;
        if (j == n) f[id][i - j + 1] ++ ; // 如果完全匹配则在左端点为 i - j + 1 的位置 + 1
    }
}

int main()
{
    scanf("%d%d", &M, &Q);
    scanf("%s", s + 1);
    int m = strlen(s + 1);

    for (int i = 1; i <= M; i ++ )
    {
        scanf("%s", p + 1); // 读入每个模式串 p
        get_next(p); // 处理 p 的 next 数组
        kmp(i, s, p); // KMP 并处理 f 数组
        cnt[i] = strlen(p + 1); // cnt 记录 p 的长度
        for (int j = 1; j <= m; j ++ )
            f[i][j] += f[i][j - 1]; // 前缀和
    }

    int l, r;
    while (Q -- )
    {
        scanf("%d%d", &l, &r);
        int res = 0;
        for (int i = 1; i <= M; i ++ )
            if (r - cnt[i] + 1 > l - 1) // 当且仅当左端点最晚出现位置在 l - 1 之后才计入答案
                res += f[i][r - cnt[i] + 1] - f[i][l - 1];
        printf("%d\n", res);
    }

    return 0;
}
```

---

## 作者：Bulyly (赞：1)

### 前言
做了很久才注意到 $M$ 的范围，警示我们做题一定要先观察，再思考，最后才是敲代码。

### 解析
- 多次查询就要想到先维护再 $O(1)$ 查询，由于这道题的 $M$ 小，所以枚举每个单词再统计答案也是我们能接受的。

- 应该不难想到用前缀和来维护每个单词在 $i$ 点前作为起点出现的数量。

- 对于每个已知长度的单词在已知的区间之中，它的起点范围就是固定的，这个范围内起点数量用前缀和是很方便求得的。

- 前缀和数组的计算，直接套 KMP 模板即可。

下附代码：
```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N=1e6+10;
char str[N],p[N];
int start[11][N],finish[N],ne[N],w[N];
int n,m;

int main()
{
	scanf("%d%d",&n,&m);
	scanf("%s",str+1);
	int s=strlen(str+1);
	for(int i=1;i<=n;i++)
	{
		scanf("%s",p+1);
		int len=strlen(p+1);
		memset(ne,0,sizeof ne);
		for(int j=2,k=0;j<=len;j++)
		{
			while(k && p[k+1]!=p[j])  k=ne[k];
			if(p[k+1]==p[j])  k++;
			ne[j]=k;
		}
		for(int j=1,k=0;j<=s;j++)
		{
			while(k && str[j]!=p[k+1])  k=ne[k];
			if(str[j]==p[k+1])  k++;
			if(k==len)  start[i][j-k+1]++;
		}
		w[i]=len;
		for(int j=1;j<=s;j++)  start[i][j]+=start[i][j-1];
	}
	
	
	while(m--)
	{
		int l,r;
		scanf("%d%d",&l,&r);
		int ans=0;
		for(int i=1;i<=n;i++)  ans+=start[i][max(l-1,r-w[i]+1)]-start[i][l-1];
		printf("%d\n",ans);
	}
	
	
	
	return 0;
} 
```
### 题目延申

回到没有看到范围时，这样题目就变得复杂了许多。前缀和貌似是维护不了的，想做到 $O(1)$ 查询也是几乎不可能的，请教了[别人](https://www.luogu.com.cn/user/297806)说可以。

发现询问可以表示为 **左右端点均在 $[L,R]$ 的区间有多少**，考虑容斥，容斥为**左端点在 $[1,R]$，右端点在 $[L,R]$ 的区间减去左端点在 $[1,L-1]$，右端点在 $[L,R]$ 的区间。**

据此可以将一个询问拆成两个，现在我们只需维护形如左端点在 $[1,y]$，右端点在 $[x,y]$ 这样的询问即可。考虑将区间按左端点排序，将右端点一一插入树状数组。当左端点插入到 $x$ 时，$query(y)-query(x-1)$ 即为所求。时间复杂度 $n \log n$。





---

## 作者：U_Uzzz (赞：1)

很显然，这道题用暴力是不能做的，所以是需要用 KMP 做的。

对于每个单词，把它与文章进行匹配，记录每个单词在文章出现的位置（我记录的是左端点），然后进行前缀和。这样，我们就可以实现 $O(m)$ 查询该区间单词出现次数。

需要注意的是区间左右端点和单词长度，要保证单词位于区间中。

~~强烈建议用字符数组做~~

下面是代码：

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
long long a,b,NEXT[1000010],f[20][1000010],g[20],m,n;
char c[1000010],d[1000010];
void Next(){
	long long y=0;
	for(int x=2;x<=n;x++){
		while(y&&d[x]!=d[y+1]) y=NEXT[y];
        if(d[x]==d[y+1]) y++;
        NEXT[x]=y;
	}
}
void KMP(int i){
	long long y=0;
	for(int x=1;x<=m;x++){
		while(y&&d[y+1]!=c[x]) y=NEXT[y];
        if(d[y+1]==c[x]) y++;
        if(y==n) f[i][x-y+1]++,y=NEXT[y];
	}
}
int main(){
	scanf("%lld%lld",&a,&b);
	cin>>c+1;
	m=strlen(c+1);
	for(int x=1;x<=a;x++){
		cin>>d+1;
		n=strlen(d+1);
		g[x]=n;
		Next();
		KMP(x);
		for(int y=1;y<=m;y++) f[x][y]+=f[x][y-1];
		memset(NEXT,0,sizeof(NEXT));
	}
	for(int x=1;x<=b;x++){
		long long i,j,k=0;
		scanf("%lld%lld",&i,&j);
		for(int y=1;y<=a;y++) if(j-i+1>=g[y]) k+=f[y][j-g[y]+1]-f[y][i-1];
		printf("%lld\n",k);
	}
}
```

---


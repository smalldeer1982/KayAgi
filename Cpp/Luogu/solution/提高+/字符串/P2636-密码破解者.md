# 密码破解者

## 题目背景

1941 年 12 月 7 日凌晨，珍珠港驻守美军通信员截获了一份日军电报。早上 8 时日军的正式进攻就会展开，为了减少太平洋战场伤亡，你被指派去协助破解密文。情报部门已得知了密文加密的层数和每层加密的方法。由于时间紧急，你只剩 1 秒的时间来破解日军的密文。


## 题目描述

据情报得知日军共有 $3$ 种加密方式：

一、栅栏密码：

所谓栅栏密码，就是把要加密的明文分成 $L$ 个一组，然后把每组的第 $1$ 个字连起来，形成一段无规律的话。一般比较常见的是 $2$ 栏的棚栏密码。 

比如明文：`THERE IS A CIPHER`  
去掉空格后变为：`THEREISACIPHER`  
两个一组，得到：`TH ER EI SA CI PH ER`  
先取出第一个字母：`TEESCPE`  
再取出第二个字母：`HRIAIHR`  
连在一起就是：`TEESCPEHRIAIHR`  

这样就得到我们需要的密码了。  

但也可能有更多的栏数。

注：若明文长度不能整除栏数，则分组后剩下的单独为一组，如：

`THERE IS A CIPHER`，$3$ 栏加密分组为：`THE REI SAC IPH ER`

先后取出第一二三个字母(最后一组只能取前两个)，加密后为: `TRSIE HEAPR EICH`（去掉空格）。

二、维吉尼亚(Vigenère)密码：

维吉尼亚密码首先应用了“密钥”的思想，其在密码届具有十分重要的意义。

在密码学中，我们称需要加密的信息为明文，用 $M$ 表示；称加密后的信息为密文，用 $C$ 表示；而密钥是一种参数，是将明文转换为密文或将密文转换为明文的算法中输入的数据，记为 $k$。在 Vigenère 密码中，密钥 $k$ 是一个字母串，$k=k_1k_2\cdots k_n$。当明文 $M=m_1m_2\cdots m_n$ 时，得到的密文 $C=c_1c_2\cdots c_n$，其中 $c_i=m_i\oplus k_i$，运算 $\oplus$ 的规则如下表所示：

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

A -A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

B -B C D E F G H I J K L M N O P Q R S T U V W X Y Z A

C -C D E F G H I J K L M N O P Q R S T U V W X Y Z A B

D -D E F G H I J K L M N O P Q R S T U V W X Y Z A B C

E -E F G H I J K L M N O P Q R S T U V W X Y Z A B C D

F -F G H I J K L M N O P Q R S T U V W X Y Z A B C D E

G -G H I J K L M N O P Q R S T U V W X Y Z A B C D E F

H -H I J K L M N O P Q R S T U V W X Y Z A B C D E F G

I -I J K L M N O P Q R S T U V W X Y Z A B C D E F G H

J -J K L M N O P Q R S T U V W X Y Z A B C D E F G H I

K -K L M N O P Q R S T U V W X Y Z A B C D E F G H I J

L -L M N O P Q R S T U V W X Y Z A B C D E F G H I J K

M -M N O P Q R S T U V W X Y Z A B C D E F G H I J K L

N -N O P Q R S T U V W X Y Z A B C D E F G H I J K L M

O -O P Q R S T U V W X Y Z A B C D E F G H I J K L M N

P -P Q R S T U V W X Y Z A B C D E F G H I J K L M N O

Q -Q R S T U V W X Y Z A B C D E F G H I J K L M N O P

R -R S T U V W X Y Z A B C D E F G H I J K L M N O P Q

S -S T U V W X Y Z A B C D E F G H I J K L M N O P Q R

T -T U V W X Y Z A B C D E F G H I J K L M N O P Q R S

U -U V W X Y Z A B C D E F G H I J K L M N O P Q R S T

V -V W X Y Z A B C D E F G H I J K L M N O P Q R S T U

W -W X Y Z A B C D E F G H I J K L M N O P Q R S T U V

X -X Y Z A B C D E F G H I J K L M N O P Q R S T U V W

Y -Y Z A B C D E F G H I J K L M N O P Q R S T U V W X

Z -Z A B C D E F G H I J K L M N O P Q R S T U V W X Y


Vigenère 加密在操作时需要注意： 

当明文 M 的长度大于密钥 k 的长度时，将密钥 k 重复使用。 

例如，明文 M=Helloworld，密钥 k=abc 时，密文 C=Hfnlpyosnd。 


三、QWE键盘码：

随着键盘普及，也出现了相应的键盘码。


这是一个常见的键盘,在左边字母区有三行字母分别为：

QWERTYUIOP

ASDFGHJKL

ZXCVBNM

从第一排第一列开始分别用Q替代A，W替代B……M替代Z以此类推。

如 CODING 加密后即为 EGROFU.

这对于现在来说算是简单的加密方法，但对于键盘不普及的二战时期却是一大难题。


## 说明/提示

n<=1000


## 样例 #1

### 输入

```
2
YSLTRIQXSHTQTR
1 2
3```

### 输出

```
FULLSPEEDAHEAD```

# 题解

## 作者：dfydada⚡⚡⚡ (赞：8)

一共就三种加密：

1. 可以看作如果是l的倍数就放到s数组里面，如果l的倍数放完了就l减减（我怕打-号连在一起看不清）。然后在把s里面的数付值回去；
2. 就看成一个环，把密钥减去A在转换为整形
3. 把qwe的顺序和abs对应得到KXVMCNOPHQRSZYIJADLEGWBUFT

总代码：

```cpp
#include<bits/stdc++.h>
//#pragma GCC optimize(2)//O2优化
using namespace std;
typedef long long ll;
const int N=3000+10;
int n,x,y;
int len,ans;
char ch,str[N];
char s[N],w[]="KXVMCNOPHQRSZYIJADLEGWBUFT";
map<char,int> q;
ll read()
{
    ll res=0,chr=getchar();
    while(!isdigit(chr)&&chr!=EOF)
    {
    	chr=getchar();
	}
    while(isdigit(chr))
    {
        res=(res*10)+(chr-'0');
        chr=getchar();
    }
    return res;
}
int main()
{
	n=read();
	scanf("%s",s);
	len=strlen(s);
	for(int i=1;i<=len;i++)
	{
		str[i]=s[i-1];
	}
   //前面都是输入
	for(int i=1;i<=n;i++)
	{
		x=read();
		if(x==1)//第一种
		{
			cin>>y;
			for(int j=1,k=1,l=1;j<=len;j++,k+=y)
			{
				if(k>len)
				{
					l++;
					k=l;
				}
				s[k]=str[j];
			}
			memcpy(str,s,sizeof(s));
		}
		if(x==2)//第二种
		{
			cin>>ch;
			ans=ch-'a'+1;
			for(int j=ans,k=1;k<=len;j++,k++)
			{
				if(j>len)
				{
					j=1;
				}
				s[k]=str[j];
			}
			memcpy(str,s,sizeof(s));
		}
		else if(x==3)//第三种
		{
			for(int j=1;j<=len;j++)
			{
				str[j]=w[str[j]-'A'];
			}
		}
	}
	for(int i=1;i<=len;i++)
	{
		cout<<str[i];
	}
	return 0;
}

```

忠告不要抄袭

---

## 作者：Luxe877 (赞：3)

原题链接：[P2636 密码破解者](https://www.luogu.com.cn/problem/P2636)

本题是一道~~比较水~~简单字符串模拟题，题意也比较好理解。
## 大致题意
给你经过 $n$ 重加密的密文，以及密文的加密顺序及种类 $K$，让你反推原始明文并输出。

### 1.栅栏密码
其加密方式如下：以栏数 $X=2$ 为例，设原明文为 `DistortedFate`，其长度为 $len=13$。

将该明文分为 $2$ 个一段（其中最后一段若不能分为 $2$ 个一段，则独立成段）,即
`Di st or te dF at e`。

然后对于每段，每次选出第 $1$ 个字母加入到密文字符串中，即得
`明文剩余部分：i t r e F t，密文：Dsotdae`。

以此类推，经过 $2$ 次选取后该明文便被加密为密文
`DsotdaeitreFt`。

我们给密文的每一个字符标上它们在明文中的下标，如下：

```cpp
密文字符：D s o t d  a  e i t r e  F t
对应下标：1 3 5 7 9 11 13 2 4 6 8 10 12 
```

我们可以发现，下标的增长是有规律的，以原先加密时选取的次数为段,下标呈等差数列形式增长，公差为 $X$，下标增长到 $\ge len$ 时换为下一段，每段的第一个字符的下标在区间 $\lbrack1,X\rbrack$ 之间。

因此，根据这样推断的结果，我们可以写出解栅栏密码的程序如下：

```cpp
void fenceup(int x)
{
	int len=strlen(pw+1);
	char solve[10002];
	int duan=1;
	int p=duan;
	for(int i=1;i<=len;i++)
	{
		solve[p]=pw[i];
		p+=x;
		if(p>len)
		{
			duan++;
			p=duan;
		}
	}
	for(int i=1;i<=len;i++)
	{
		pw[i]=solve[i];
	}
}
```

### 2.维吉尼亚(Vigenère) 密码
其加密方式见此题：[P1079 [NOIP2012 提高组] Vigenère 密码](https://www.luogu.com.cn/problem/P1079)

由加密方式倒推，可以得到解密方式如下：

`密文字符-密钥字符=明文字符`

自然，和原加密时一样，解密时可能会导致减出来的 ASCII 码值小于字母，导致破译失败，因此在减的时候要同时 $+26$ 与取模，便可得出以下代码：

```cpp
void vigne(char scw[])
{
	int len=strlen(pw+1),l=strlen(scw),tmp=0;
	char uncode[10002];
	bool upb;
	for(int i=1;i<=len;i++)
	{
		upb=false;
		if(pw[i]>='A'&&pw[i]<='Z')
		{
			upb=true;
			pw[i]=pw[i]-'A'+'a';
		}
		if(scw[tmp]>='A'&&scw[tmp]<='Z')
		{
			scw[tmp]=scw[tmp]-'A'+'a';
		}
		uncode[i]=(pw[i]-scw[tmp]+26)%26+'a';
		if(upb)
		{
			uncode[i]=uncode[i]-'a'+'A';
		}
		tmp=(tmp+1)%l;
	}
	for(int i=1;i<=len;i++)
	{
		pw[i]=uncode[i];
	}
}
```

### 3.QWE 键盘码
其加密方式较为简单，由键盘上 `Q` 键开始为 `A`， `W` 键为 `B`，以此类推至全部字母键，只需要提前写好对应密文的数组访问即可，代码如下：

```
void keybd()
{
	char word[52]={'k','x','v','m','c','n','o','p','h','q','r','s','z','y','i','j','a','d','l','e','g','w','b','u','f','t'};
	int len=strlen(pw+1);
	bool upb;
	for(int i=1;i<=len;i++)
	{
		upb=false;
		if(pw[i]>='A'&&pw[i]<='Z')
		{
			pw[i]=pw[i]-'A'+'a';
			upb=true;
		}
		pw[i]=word[pw[i]-'a'];
		if(upb)
		{
			pw[i]=pw[i]-'a'+'A';
		}
	}
}
```

最后，处理好输入输出即可得出正解。代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
char pw[10002];
struct nd{
	int type;
	char spw[1002];
	int mvw;
}uns[1012];
void fenceup(int x)//分 X 段 
{
	int len=strlen(pw+1);
	char solve[10002];
	int duan=1;//段数
	int p=duan;//密文下标
	for(int i=1;i<=len;i++)
	{
		solve[p]=pw[i];
		p+=x;
		if(p>len)//下标超过明文长度时换为下一行统计
		{
			duan++;
			p=duan;
		}
	}
	for(int i=1;i<=len;i++)
	{
		pw[i]=solve[i];
	}
//	cout<<pw+1<<endl;
}
void vigne(char scw[])
{
	int len=strlen(pw+1),l=strlen(scw),tmp=0;
	char uncode[10002];
	bool upb;
	for(int i=1;i<=len;i++)
	{
		upb=false;
		if(pw[i]>='A'&&pw[i]<='Z')//大小写处理
		{
			upb=true;
			pw[i]=pw[i]-'A'+'a';
		}
		if(scw[tmp]>='A'&&scw[tmp]<='Z')//大小写处理
		{
			scw[tmp]=scw[tmp]-'A'+'a';
		}
		uncode[i]=(pw[i]-scw[tmp]+26)%26+'a';//解密(注意不要忘了+26、%26、+'a')
		if(upb)//大小写处理
		{
			uncode[i]=uncode[i]-'a'+'A';
		}
		tmp=(tmp+1)%l;
	}
	for(int i=1;i<=len;i++)
	{
		pw[i]=uncode[i];
	}
//	cout<<pw+1<<endl;
}
void keybd()
{
	char word[52]={'k','x','v','m','c','n','o','p','h','q','r','s','z','y','i','j','a','d','l','e','g','w','b','u','f','t'};//存储对应密文
	int len=strlen(pw+1);
	bool upb;//大写区分 
	for(int i=1;i<=len;i++)
	{
		upb=false;
		if(pw[i]>='A'&&pw[i]<='Z')//大小写处理
		{
			pw[i]=pw[i]-'A'+'a';
			upb=true;
		}
		pw[i]=word[pw[i]-'a'];
		if(upb)//大小写处理
		{
			pw[i]=pw[i]-'a'+'A';
		}
	}
//	cout<<pw+1<<endl;
}
int main()
{
	cin>>n>>pw+1;
	for(int i=1;i<=n;i++)
	{
		cin>>uns[i].type;
		if(uns[i].type==1)
		{
			cin>>uns[i].mvw;
			continue;
		}
		if(uns[i].type==2)
		{
			cin>>uns[i].spw+1;
		}
	}
	for(int i=n;i>=1;i--)
	{
		if(uns[i].type==1)
		{
			fenceup(uns[i].mvw);
			continue;
		}
		if(uns[i].type==2)
		{
			vigne(uns[i].spw+1);
			continue;
		}
		if(uns[i].type==3)
		{
			keybd();
			continue;
		}
	}
	cout<<pw+1<<endl;
	return 0;
}
```

## 注意事项（坑点）
- 1. 大小写要注意转换，解密时要化为同一形式。
- 2. Vigenère 密码解密时要加和取模 $26$。
- 3. 不要输错 QWE 键盘码的对应密文。
- 4. 建议使用 `char a[]` 类型存储明文和密文，不建议使用 `string` 类型（[本人的悲伤遭遇](https://www.luogu.com.cn/record/121023323)）。

## 后记
本题解为萌新的首篇题解，$LateX$ 在编辑的时候加载得不太好，审核大大求过。

---

## 作者：SW_Wind (赞：3)

还没有人发 C++ 的题解。。

思路不难想，主要是写代码的难度。

**注意事项：**

1. 加密是顺序给出的，所以解密要倒序处理；
2. 字符串长度似乎有点大，半 WA 半 AC 的请尝试开大数组；
3. QWE键盘码不要打错。

然后应该就没多大问题了，样例过了就应该能 AC 了。

丢代码：

```cpp
#include <bits/stdc++.h>
#define N 500020
#define ll long long
using namespace std;
inline int read(){
  int x=0,f=1;char ch=getchar();
  while(ch>'9'||ch<'0')ch=='-'&&(f=0)||(ch=getchar());
  while(ch<='9'&&ch>='0')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
  return f?x:-x;
}
char ch[N], tmp[N];
int len;
// char qwe[] = "abcdefghijklmnopqrstuvwxyz";
char qwe[] = "kxvmcnophqrszyijadlegwbuft";
bool bg[N];
int op[1020], a[1020];
string str[1020];
int main(int argc, char const *argv[]) {
  int n = read();
  scanf("%s", ch + 1);
  len = strlen(ch + 1);
  for (int i = 1; i <= len; i++)
    if (ch[i] < 'a')
      bg[i] = 1, ch[i] = tolower(ch[i]);
  for (int i = 1; i <= n; i++) {
    op[i] = read();
    if (op[i] == 1) a[i] = read();
    if (op[i] == 2) cin >> str[i];
  }
  for (int s = n; s; s--) {
    if (op[s] == 1) {
      int l = a[s];
      for (int i = 1, j = 1, k = 1; i <= len; i++, j += l) {
        if (j > len) j = ++ k;
        tmp[j] = ch[i];
      }
      memcpy(ch, tmp, sizeof tmp);
    }
    if (op[s] == 2) {
      int key_len = str[s].length();
      for (int i = 1, j = 1; i <= len; i++, j++) {
        ch[i] = 'a' + (ch[i] - tolower(str[s][j - 1]) + 26) % 26;
        if (j == key_len) j = 0;
      }
    }
    if (op[s] == 3) {
      for (int i = 1; i <= len; i++)
        ch[i] = qwe[ch[i] - 'a'];
    }
  }
  for (int i = 1; i <= len; i++)
    if (bg[i]) putchar(toupper(ch[i]));
    else putchar(ch[i]);
  puts("");
  return 0;
}
```


---

## 作者：cy2017 (赞：2)

【题目简述】

字符串处理，注意对三种加密方法的处理，以及逆向思维。

【题目分析】

坑点在于解密时应按输入加密顺序从后往前解密，以及栅栏密码密文长度不能整除栏数时的处理。


---

## 作者：BFSBFSBFSBFS (赞：1)

~~我好菜啊.~~.

题意.给出n个加密过程.给出密文求明文...

密文:加密后的字符串.

明文:加密前的字符串.

共有3种加密方式..

(方式1.)栅栏密码:

····给出栏数$x$.以明文每$x$位为1组.每次取出每组的开头字母.组成密文.

····如明文**hahehih**.$x = 3$.

····分组:**hah ehi h**.

····取开头:**heh**.剩下**ah hi**.

····再取开头**ah**和**hi**.组成密文:**hehahhi**.

····设分的组数为$p$.

····$p = (len(s)+x-1)/x$.

····$len(s)$表示密文的长度.

····观察到密文每$p$个字母是原组的开头....??

····还原过程:$x = p$.同样的方法再做1遍就回去了...但是分组要注意.

····在长度不是刚刚好的情况下.设距离刚刚好还差$y$个字符.此时分的组数为$x$.

····$y = p*x-len(s)$.

····前$x-y$组,每组分$p$个字母.后$y$组.每组分$p-1$个字母.

····因为明文最后1组少了几个啊..

····正确分组:**heh ah hi**.

····错误分组:**heh aha i**.

(方式2.)维基利亚密码:

····给出密钥$k$.

····转化小写(或大写)后.

····用**a**表示0.**b**表示1.....

····表示的数字代表字母按顺序向后的第几个字母.超过**z**从**a**开始继续.

····如明文:**haha**,密钥**abcd**.

····密文就是**hbjd**.

····若$k$长度不够.重复填充.

····既然原来是向后的.那么解密就变成向前了...

····超出**a**从**z**继续..

(方式3.)QWE键盘码(...):

····用键盘上的字母按从上到下,从左到右的顺序代替**a**到**z**..

····所以我们把键盘对应的字母存下来就好了..

····**q = a**....

最后注意.由于是密文还原明文.题目给出的是明文到密文的过程..

所以要从后往前处理..

好像数据没有小写..可以处理的方便点..

理论时间复杂度:$O(knlen(s))$.

空间$O(kn)$.

带点常数..

Diu代码..

~~1年多的坑终于填完了.-~~

```cpp
program P2636;
 var
  a,b:array[0..1001] of longint;
  c:array[0..1001] of ansistring;
  s1:array[0..1001] of ansistring;
  d:array[1..26] of char=('Q','W','E','R','T','Y','U','I','O','P','A','S','D','F','G','H','J','K','L','Z','X','C','V','B','N','M');  //对应的键盘码.其实可以直接搞原码的..
  i,n:longint;
  s:ansistring;
 procedure haha1(l:longint); //处理方式1.
  var
   i,p1,p2,p3,p4:longint;
  begin
   p1:=length(s);
   p2:=(p1+l-1) div l;       //上面的p.
   p3:=p2*l-p1;              //上面的y.
   for i:=1 to p2 do
    s1[i]:='';
   for i:=1 to p2*(l-p3) do  //处理前面几组.
    s1[(i-1) mod p2+1]:=s1[(i-1) mod p2+1]+s[i];
   dec(p2);
   p4:=(p2+1)*(l-p3)+1;
   for i:=p4 to p1 do        //后面几组..
    s1[(i-p4) mod p2+1]:=s1[(i-p4) mod p2+1]+s[i];
   s:='';
   for i:=1 to p2+1 do
    s:=s+s1[i];              //接回来..
  end;
 procedure haha2(l:longint); //处理方式2..
  var
   a:array[0..1001] of longint;
   kkkk:ansistring;
   i,p:longint;
  begin
   kkkk:=c[l];
   for i:=1 to length(kkkk) do
    begin
     kkkk[i]:=upcase(kkkk[i]);
     a[i]:=ord(kkkk[i])-65;        //相当于移位吧..
    end;
   for i:=1 to length(s) do
    begin
     p:=ord(s[i])-a[(i-1) mod length(kkkk)+1];   //注意密钥的重复使用.
     if (ord(s[i])<97) and (p<65) or (ord(s[i])>=97) and (p<97) then p:=p+26;                                    //超出字母表了..
     s[i]:=chr(p);
    end;
  end;
 procedure haha3;   //方式3..
  var
   i,j:longint;
  begin
   for i:=1 to length(s) do
    begin
     for j:=1 to 26 do
      if (s[i]=d[j]) or (chr(ord(s[i])+32)=d[j]) then break;  //找到对应的字母(储存方式不对...).
     if s[i]<='Z' then s[i]:=chr(64+j)
                  else s[i]:=chr(96+j);
    end;
  end;
 begin
  readln(n);
  readln(s);
  for i:=1 to n do
   begin
    read(a[i]);
    if a[i]=1 then read(b[i]);
    if a[i]=2 then
     begin
      readln(c[i]);
      delete(c[i],1,1);
     end;
   end;
  for i:=n downto 1 do          //注意倒序..
   case a[i] of
    1:haha1(b[i]);
    2:haha2(i);
    3:haha3;
   end;
  writeln(s);
 end.
```
(ಡωಡ).


---

## 作者：ni_ju_ge (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P2636)
## 思路
### 栅栏密码
这个密码有一定的规律，打个表说明一下：

$L=2$，明文为 `abcdef` 时，密文为 `acebdf`。\
这样仍然看不出什么，那把密文在明文中对应字母的下标列出来：$0,2,4,1,3,5$，显然，每一段都是一个等差数列，于是我们就可以写出破译的代码了：
```cpp
void getpw1(int s,string &word) {//s就是题目中的L
	string pw=word;
	int pos,x;
	pos=x=0;
	for(int i=0; i<word.size(); i++) {
		pw[pos]=word[i];
		pos+=s;
		if(pos>=word.size())pos=++x;
	}
	word=pw;
}
```
### 维吉尼亚（Vigenère）密码
根据加密方式倒推，可以得到“明文=密文-密钥”。然后处理一下溢出和大小写就行了。
```cpp
void zhuan(char &c) {//此为大小写相互转化的代码
	if('A'<=c&&c<='Z')c=c-'A'+'a';
	else c=c-'a'+'A';
}
void getpw2(string &word,string key) {
	int pos;
	bool fl;
	fl=false;
	for(int i=0; i<word.size(); i++) {
		pos=i%key.size();//这里是key，不是word
		if('A'<=key[pos]&&key[pos]<='Z')zhuan(key[pos]);
		if('A'<=word[i]&&word[i]<='Z') {
			fl=true;
			zhuan(word[i]);
		}
		word[i]=(word[i]-key[pos]+26)%26+'a';//要加26和对26取模防止溢出
		if(fl) {
			fl=false;
			zhuan(word[i]);
		}
	}
}
```
### QWE 键盘码
这个就简单很多，打表即可。
```cpp
char letter[26]= {'k','x','v','m','c','n','o','p','h','q','r','s','z','y','i','j','a','d','l','e','g','w','b','u','f','t'};//别打错了
void getpw3(string &word) {
	bool fl;
	fl=false;
	for(int i=0; i<word.size(); i++) {
		if('A'<=word[i]&&word[i]<='Z') {//仍然要处理大写字母
			fl=true;
			zhuan(word[i]);
		}
		word[i]=letter[word[i]-'a'];
		if(fl) {
			fl=false;
			zhuan(word[i]);
		}
	}
}
```
## 完整代码
```cpp
#include<bits/stdc++.h>
using namespace std;
string str,k[1145];
char letter[26]= {'k','x','v','m','c','n','o','p','h','q','r','s','z','y','i','j','a','d','l','e','g','w','b','u','f','t'};
int n,t[1145],l[1145],ls,ks;
void zhuan(char &c) {
	if('A'<=c&&c<='Z')c=c-'A'+'a';
	else c=c-'a'+'A';
}
void getpw1(int s,string &word) {
	string pw=word;
	int pos,x;
	pos=x=0;
	for(int i=0; i<word.size(); i++) {
		pw[pos]=word[i];
		pos+=s;
		if(pos>=word.size())pos=++x;
	}
	word=pw;
}
void getpw2(string &word,string key) {
	int pos;
	bool fl;
	fl=false;
	for(int i=0; i<word.size(); i++) {
		pos=i%key.size();
		if('A'<=key[pos]&&key[pos]<='Z')zhuan(key[pos]);
		if('A'<=word[i]&&word[i]<='Z') {
			fl=true;
			zhuan(word[i]);
		}
		word[i]=(word[i]-key[pos]+26)%26+'a';
		if(fl) {
			fl=false;
			zhuan(word[i]);
		}
	}
}
void getpw3(string &word) {
	bool fl;
	fl=false;
	for(int i=0; i<word.size(); i++) {
		if('A'<=word[i]&&word[i]<='Z') {
			fl=true;
			zhuan(word[i]);
		}
		word[i]=letter[word[i]-'a'];
		if(fl) {
			fl=false;
			zhuan(word[i]);
		}
	}
}
int main() {
	cin>>n>>str;
	for(int i=1; i<=n; i++) {
		cin>>t[i];
		if(t[i]==1)cin>>l[++ls];
		if(t[i]==2)cin>>k[++ks];
	}
	for(int i=n; i>=1; i--) {//倒着解出来
		if(t[i]==1)getpw1(l[ls--],str);
		if(t[i]==2)getpw2(str,k[ks--]);
		if(t[i]==3)getpw3(str);
	}
	cout<<str<<endl;
}
```

---

## 作者：Melo_DDD (赞：0)

前置芝士：[大小写转换](https://blog.csdn.net/qq_33706673/article/details/78695927)。

这是一道好的**模拟**题，感兴趣的切完可以顺手把猪国杀和鸭棋切了玩玩。

# 题目大意

这 Vigenère 密码表给我看的是云里雾里，更正常的表看[这里](https://www.luogu.com.cn/problem/P1079)。

注意输入时是顺序输入，所以往回算要倒过来。

# 题目实现

我们将三种加密方式分开搞：

-  栅栏密码：设当前下标为 $i$，分为 $j$ 栏，不难发现密文的下一个与 $i$ 同位置的字符下标为 $i +j$，根据规律求出加密前即可。显然，当下标超过总串长时，说明可以去计算第 $i+1$ 个位置了，直接更新即可，代码（相信你们能看懂，就不注释了）：

```cpp
inline void fence (int l) {
	for (int i = 1 ,j = 1 ,k = 1 ;i <= len ;i ++ ,j += l) {
		if (j > len) j = ++ k ;
		fnc[j] = s[i] ;
	}
	memcpy (s ,fnc ,sizeof fnc) ;
}
```

-  Vigenère 密码：可以发现 Vigenère 运算的规律是密文字符减密钥字符等于明文字符。注意别不小心把字符搞成数字，其方法与及时取模相类似，代码：

```cpp
inline void vigenere (string str) {
	int l = str.length () ;
	for (int i = 1 ,j = 1 ;i <= len ;i ++ ,j ++) {
		if (j == l + 1) {
			j = 1 ;
		}
		s[i] = (s[i] - tolower (str[j - 1]) + 26) % 26 + 'a' ;
	}
}
```

- QWE 键盘码：这个更简单，列出密文所对应的明文即可（打一张长度 $26$ 的小表），代码：

```cpp
char qwe[] = "kxvmcnophqrszyijadlegwbuft" ;
inline void qwe_ () {
	f (i ,1 ,len ,1) {
		s[i] = qwe[s[i] - 'a'] ;
	}
} 
```

不要用 getline，亲测会得到 $20$ pts 的高分，因为它会吃掉你的空格。

大小写转换见下，记得及时标记。

别弄混字符串下标从几开始存的。

## 代码

```cpp
#include <bits/stdc++.h>
#define f(i ,m ,n ,x) for (int i = (m) ;i <= (n) ;i += (x))
#define f_(i ,m ,n ,x) for (int i = (m) ;i >= (n) ;i -= (x))
using namespace std ;
const int N = 1007 ;
int n ,len ,op[N] ,a[N] ;
char fnc[N] ,s[N] ;
char qwe[] = "kxvmcnophqrszyijadlegwbuft" ;
bool cg[N] ;
string vig[N] ;
template <typename T> inline void read (T &x) {
	x = 0 ;
	bool flag (0) ;
	register char ch = getchar () ;
	while (! isdigit (ch)) {
		flag = ch == '-' ;
		ch = getchar () ;
	}
	while (isdigit (ch)) {
		x = (x << 1) + (x << 3) + (ch ^ 48) ;
		ch = getchar () ;
	}
	flag ? x = -x : 0 ;
}
namespace shin {
	inline void fence (int l) {
		for (int i = 1 ,j = 1 ,k = 1 ;i <= len ;i ++ ,j += l) {
			if (j > len) j = ++ k ;
			fnc[j] = s[i] ;
		}
		memcpy (s ,fnc ,sizeof fnc) ;
	}
	inline void vigenere (string str) {
		int l = str.length () ;
		for (int i = 1 ,j = 1 ;i <= len ;i ++ ,j ++) {
			if (j == l + 1) {
				j = 1 ;
			}
			s[i] = (s[i] - tolower (str[j - 1]) + 26) % 26 + 'a' ;
		}
	}
	inline void qwe_ () {
		f (i ,1 ,len ,1) {
			s[i] = qwe[s[i] - 'a'] ;
		}
	} 
}
int main () {
	read (n) ;
	cin >> s + 1 ;
	len = strlen (s + 1) ;
	f (i ,1 ,len ,1) {
		if (s[i] >= 'A' && s[i] <= 'Z') {
			cg[i] = true ;
			s[i] = tolower (s[i]) ;
		}
	}
	f (i ,1 ,n ,1) {
		read (op[i]) ;
		if (op[i] == 1) {
			read (a[i]) ;
			continue ;
		}
		if (op[i] == 2) {
			cin >> vig[i] ;
			continue ;
		}
	}
	f_ (i ,n ,1 ,1) {
		if (op[i] == 1) {
			shin :: fence (a[i]) ;
			continue ;
		}
		if (op[i] == 2) {
			shin :: vigenere (vig[i]) ;
			continue ;
		}
		shin :: qwe_ () ;
	}
	#undef f_
	f (i ,1 ,len ,1) {
		char c ;
		if (cg[i]) c = (char) toupper (s[i]) ;
		else c = s[i] ;
		cout << c ;
	}
	cout << '\n' ;
	return 0 ;
}
```

---

## 作者：IOI_AK_TLR (赞：0)

# 思路

这是一道非常好的**模拟题**。

读题我们会想到写三个函数，分别来求三种密码的解码。另外，因为题目给的顺序是加密的过程，所以解密应该倒序，只要把输入存在一个结构体里就可以了。

# 实现

代码如下。

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <string>
using namespace std;
string s;
int n;
char qwe1[27]="QWERTYUIOPASDFGHJKLZXCVBNM";
char qwe2[27]="?";
struct Node{
	int k;
	int L;
	string T;
}input[1005];
string ZL(string s, int x) //栅栏密码 
{	
	int i=0,j=0,k=0;
	string ret(s.size(),' ');
	for(;i<s.size();i++,j+=x)
	{
		if(j>=s.size())
		{
			k++;
			j=k;
		}
		ret[j]=s[i];
	}
	return ret;
}
string VIG(string s,string t) 	//维吉尼亚密码 
{
	char c;
	string ret;
	int l1=s.size();
	int l2=t.size();
	for(int i=0;i<l1;i++)
	{
		c=(s[i]-t[i%l2]+'A');
		ret+="?";
		ret[i]=(c>='A')?(c):(c+26);
	}
	return ret;
}
string QWE(string s)	//qwe密码 
{
	if(qwe2[0]=='?')	//之所以不直接初始化qwe2是因为太麻烦了。qwe1直接把键盘顺序敲上去就行了。 
	{
		for(int i=0;i<26;i++)
		{
			qwe2[qwe1[i]-'A']=i+'A';
		}
	}
	for(int i=0;i<s.size();i++)
		s[i]=qwe2[s[i]-'A'];
	return s;
}
int main()
{
	cin>>n;
	cin>>s;
	for(int i=1;i<=n;i++)
	{
		cin>>input[i].k;
		if(input[i].k==1)
			cin>>input[i].L;
		else if(input[i].k==2)
			cin>>input[i].T;
	}
	for(int i=n;i>=1;i--)
	{
		if(input[i].k==1)
		{
			s=ZL(s,input[i].L);
		}
		else if(input[i].k==2)
		{
			s=VIG(s,input[i].T);
		}
		else
		{
			s=QWE(s);
		}
	}
	cout<<s;
	return 0;
}
```


---

## 作者：cyrxdzj (赞：0)

### 一、思路

本题可以按照题目所说进行反推。

#### 1、栅栏密码

我们可以计算出密文字符所对应的明文字符位置，然后进行复原。

```cpp
string unsecret1(string password,int key)
{
	int len=password.length();
	string ans(len,'A');//初始化。
	for(int i=0,j=0,k=0;i<len;i++,j+=key)
	{
		if(j>=len)//超出范围，则重新开始下一轮。
		{
			k++;
			j=k;
		}
		ans[j]=password[i];//复制。
	}
	return ans;
}
```

#### 2、维吉尼亚密码

我们可以使用取余操作，得出密文的某个字符所对应的秘钥的某个字符，并计算出明文的字母。

需要注意，这里传入的参数必须为小写，大小写什么的之后再管。

```cpp
string unsecret2(string password,string key)
{
	string ans;
	int password_len=password.length(),key_len=key.length();
	for(int i=0;i<password_len;i++)
	{
		ans+='a'+(password[i]-tolower(key[i%key_len])/*tolower指的是将字母转换为小写字母，原本就是小写字母的不变*/+26)%26;//计算明文。
	}
	return ans;
}
```

#### 3、QWE键盘码

根据题目，我们得出了这样一个东西：

[![WFNvX8.png](https://z3.ax1x.com/2021/07/12/WFNvX8.png)](https://imgtu.com/i/WFNvX8)

由此，我们就可以得出对于这种密码的秘钥：

`kxvmcnophqrszyijadlegwbuft`

然后计算出密文某个字符对应的明文字符，就可以轻松地转换了。

```cpp
string unsecret3(string password)
{
	string key="kxvmcnophqrszyijadlegwbuft";
	string ans;
	int len=password.length();
	for(int i=0;i<len;i++)
	{
		ans+=key[password[i]-'a'];
	}
	return ans;
}
```

### 二、坑点合集

#### 1、大小写问题

字符串是有大小写的。解决方法是，设一个布尔型数组 `big`，代表字符串的某个字符是否大写。然后在输出中处理即可。

#### 2、解密顺序

一定要注意，揭秘字符串要**倒序进行**！因为加密时是按照输入顺序的，解密时就要反过来。

### 三、完整代码

```cpp
#include<iostream>
#include<string>
using namespace std;
string unsecret1(string password,int key)
{
	int len=password.length();
	string ans(len,'A');
	for(int i=0,j=0,k=0;i<len;i++,j+=key)
	{
		if(j>=len)
		{
			k++;
			j=k;
		}
		ans[j]=password[i];
	}
	return ans;
}
string unsecret2(string password,string key)
{
	string ans;
	int password_len=password.length(),key_len=key.length();
	for(int i=0;i<password_len;i++)
	{
		ans+='a'+(password[i]-tolower(key[i%key_len])+26)%26;
	}
	return ans;
}
string unsecret3(string password)
{
	string key="kxvmcnophqrszyijadlegwbuft";
	string ans;
	int len=password.length();
	for(int i=0;i<len;i++)
	{
		ans+=key[password[i]-'a'];
	}
	return ans;
}
int n;
string str;
bool big[1000];
int op[1005];
int key[1005];
string str_key[1005];
int main()
{
	cin>>n>>str;
	int len=str.length();
	for(int i=0;i<len;i++)
	{
		if(str[i]>='a'&&str[i]<='z')//小写字母。
		{
			big[i]=false;
		}
		else//大写字母。
		{
			big[i]=true;
			str[i]=str[i]-'A'+'a';//将大写字母转换为小写字母。
		}
	}
	for(int i=1;i<=n;i++)//输入并存储。
	{
		cin>>op[i];
		if(op[i]==1)
		{
			cin>>key[i];
		}
		else if(op[i]==2)
		{
			cin>>str_key[i];
		}
	}
	for(int i=n;i>=1;i--)//倒序解密。
	{
		if(op[i]==1)
		{
			str=unsecret1(str,key[i]);
		}
		else if(op[i]==2)
		{
			str=unsecret2(str,str_key[i]);
		}
		else
		{
			str=unsecret3(str);
		}
	}
	for(int i=0;i<len;i++)//输出。
	{
		char a;
		if(big[i])
		{
			a=str[i]-'a'+'A';
		}
		else
		{
			a=str[i];
		}
		cout<<a;
	}
	cout<<endl;
	return 0;//完结撒花！
}

```

By [dengzijun](https://www.luogu.com.cn/user/387836)

---


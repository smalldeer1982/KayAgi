# 【模板】AC 自动机

## 题目背景

本题原为“AC 自动机（二次加强版）”。完成本题前可以先完成 [AC 自动机（简单版）](https://www.luogu.com.cn/problem/P3808) 和 [AC 自动机（简单版 II）](https://www.luogu.com.cn/problem/P3796) 两道题，为 AC 自动机更简单的应用。

## 题目描述

给你一个文本串 $S$ 和 $n$ 个模式串 $T_{1 \sim n}$，请你分别求出每个模式串 $T_i$ 在 $S$ 中出现的次数。

## 说明/提示

对于 $100 \%$ 的数据，$1 \le n \le 2 \times {10}^5$，$T_{1 \sim n}$ 的长度总和不超过 $2 \times {10}^5$，$S$ 的长度不超过 $2 \times {10}^6$。

## 样例 #1

### 输入

```
5
a
bb
aa
abaa
abaaa
abaaabaa
```

### 输出

```
6
0
3
2
1
```

# 题解

## 作者：hyfhaha (赞：205)

因为是什么“二次加强版”，所以大家先去做一下“加强版”吧，做法差不多。

没做过的看这里:[题解【模板】AC自动机（加强版）](https://www.luogu.org/blog/juruohyfhaha/solution-p3796)，有一下变量名可能会在刚才那一篇blog出现过，所以建议大家再去过一下。

好了，看到这里大家都一定做过“加强版”了吧，那么这道题的做法也是差不多的，我们这一次不需要求出现最多的字符串啦，直接将vis数组输出就好了！（应该都知道vis数组是什么吧，就是统计每个模式串在文本串出现多少次的数组）

但重复的单词有没有影响啊！有啊！对于“加强版”，这一次重复的单词就会有影响啦，怎么办？

这道题有相同字符串要统计，设当前字符串是第i个，我们用一个Map[i]数组(不是STL那个)存((当前字符串在Trie中的那个位置)的flag)，最后把vis[Map[i]]输出就OK了。另外flag只在第一次赋值时变化，其他都不变。

代码中修改的地方：

插入字符串时insert：

```cpp
insert最后那个地方,num是上面i的意思
if(!trie[u].flag)trie[u].flag=num;			//如果是第1个就赋值flag
Map[num]=trie[u].flag;									//存Map数组
```

最后输出：

```cpp
for(int i=1;i<=n;++i)printf("%d\n",vis[Map[i]]);
```

嗯，没有问题了，交了！

？？？！怎么只有76分？TLE！！！ [提交记录](https://www.luogu.org/recordnew/show/18909224)

# AC自动机的优化

## 拓扑建图优化

让我们来分析一下刚才那个程序的时间复杂度，算了不分析了，直接告诉你吧，这样暴力去跳fail的最坏时间复杂度是O(模式串长度 · 文本串长度)。为什么？因为对于每一次跳fail我们都只使深度减1，那样深度(深度最深是模式串长度)是多少，每一次跳的时间复杂度就是多少。那么还要乘上文本串长度，就几乎是 O(模式串长度 · 文本串长度)的了。

那么模板1的时间复杂度为什么就只有O(模式串总长)。因为每一个Trie上的点都只会经过一次（打了标记），但刚才那个程序每一个点就不止经过一次了，所以时间复杂度就爆炸了。

那么我们可不可以让刚才那个程序的Trie上每个点只经过一次呢？让时间复杂度降至O(模式串总长)呢？

嗯~，还真可以！

题目看这里：[**P5357** 【模板】AC自动机（二次加强版）](https://www.luogu.org/problemnew/show/P5357)

### 做法：拓扑排序

让我们把Trie上的fail都想象成一条条有向边，那么我们如果在一个点使那个点进行一些操作，那么沿着这个点连出去的点也会进行操作（就是跳fail），所以我们才要暴力跳fail去更新之后的点。

![AC自动机](https://i.loli.net/2019/05/02/5ccaaa22cbf29.png)

我们用上面的图，我举个例子解释一下我刚才的意思。

我们先找到了编号4这个点，编号4的fail连向编号7这个点，编号7的fail连向编号9这个点。那么我们要更新编号4这个点的值，同时也要更新编号7和编号9，这就是暴力跳fail的过程。

我们下一次找到编号7这个点，还要再次更新编号9，编号9点就被更新了两次，所以时间复杂度就在这里被浪费了。

那么我们可不可以在找到的点打一个标记，最后再**一次性**将标记全部上传 来 更新其他点的ans。例如我们找到编号4，在编号4这个点打一个ans标记为1，下一次找到了编号7，又在编号7这个点打一个ans标记为1，那么打好全部标记后，我们直接从编号4开始跳fail，然后将标记ans上传，**((点i的fail)的ans)加上(点i的ans)**，最后使编号4的ans为1，编号7的ans为2，编号9的ans为2，这样的答案和暴力跳fail是一样的，并且每一个点只经过了**一次**。

最后我们将有flag标记的ans传到vis数组里，就求出了答案。

但怎么确定更新顺序呢？明显我们打了标记后肯定是从深度大的点开始更新上去的。所以更新顺序就是从深度大的到深度小的。

怎么实现呢？**拓扑排序！**

我们使每一个点向它的fail指针连一条边，明显，每一个点的出度为1（fail只有一个），入度可能很多，所以我们就不需要像拓扑排序那样先建个图了，直接往fail指针跳就可以了。但入度数组in还是要存的。

最后我们根据fail指针建好图后（想象一下，程序里不用实现的），一定是一个DAG，具体原因不解释（很简单的），那么我们就直接在上面跑拓扑排序，然后更新ans就可以了。

#### 代码实现：

首先是getfail这里，记得将fail的入度更新。

```cpp
trie[v].fail=trie[Fail].son[i]; in[trie[v].fail]++;  	//记得加上入度
```

然后是query，不用暴力跳fail了，直接打上标记就行了，很简单吧

```cpp
void query(char* s){
	int u=1,len=strlen(s);
	for(int i=0;i<len;++i)
	u=trie[u].son[s[i]-'a'],trie[u].ans++;							//直接打上标记
}
```

最后是拓扑，解释都在注释里了OwO!

```cpp
void topu(){
	for(int i=1;i<=cnt;++i)
	if(in[i]==0)q.push(i);				//将入度为0的点全部压入队列里
	while(!q.empty()){
		int u=q.front();q.pop();vis[trie[u].flag]=trie[u].ans;	//如果有flag标记就更新vis数组
		int v=trie[u].fail;in[v]--;		//将唯一连出去的出边fail的入度减去（拓扑排序的操作）
		trie[v].ans+=trie[u].ans;		//更新fail的ans值
		if(in[v]==0)q.push(v);			//拓扑排序常规操作
	}
}
```

应该还是很好理解的吧，实现起来也没有多难嘛！

# 总代码

```cpp
#include<bits/stdc++.h>
#define maxn 2000001
using namespace std;
char s[maxn],T[maxn];
int n,cnt,vis[200051],ans,in[maxn],Map[maxn];
struct kkk{
    int son[26],fail,flag,ans;
    void clear(){memset(son,0,sizeof(son)),fail=flag=ans=0;}
}trie[maxn];
queue<int>q;
void insert(char* s,int num){
    int u=1,len=strlen(s);
    for(int i=0;i<len;i++){
        int v=s[i]-'a';
        if(!trie[u].son[v])trie[u].son[v]=++cnt;
        u=trie[u].son[v];
    }
    if(!trie[u].flag)trie[u].flag=num;
    Map[num]=trie[u].flag;
}
void getFail(){
    for(int i=0;i<26;i++)trie[0].son[i]=1;
    q.push(1);
    while(!q.empty()){
        int u=q.front();q.pop();
        int Fail=trie[u].fail;
        for(int i=0;i<26;i++){
            int v=trie[u].son[i];
            if(!v){trie[u].son[i]=trie[Fail].son[i];continue;}
            trie[v].fail=trie[Fail].son[i]; in[trie[v].fail]++;
            q.push(v);
        }
    }
}
void topu(){
    for(int i=1;i<=cnt;i++)
    if(in[i]==0)q.push(i);
    while(!q.empty()){
        int u=q.front();q.pop();vis[trie[u].flag]=trie[u].ans;
        int v=trie[u].fail;in[v]--;
        trie[v].ans+=trie[u].ans;
        if(in[v]==0)q.push(v);
    }
}
void query(char* s){
    int u=1,len=strlen(s);
    for(int i=0;i<len;i++)
    u=trie[u].son[s[i]-'a'],trie[u].ans++;
}
int main(){
    scanf("%d",&n); cnt=1;
    for(int i=1;i<=n;i++){
        scanf("%s",s);
        insert(s,i);
    }getFail();scanf("%s",T);
    query(T);topu();
    for(int i=1;i<=n;i++)printf("%d\n",vis[Map[i]]);
}
```

如有需要，请看个人完整blog：[AC自动机](https://www.luogu.org/blog/juruohyfhaha/ac-zi-dong-ji)

---

## 作者：ouuan (赞：117)

> 形式上，AC 自动机基于由若干模式串构成的 Trie 树，并在此之上增加了一些 fail 边；本质上，**AC 自动机是一个关于若干模式串的 DFA（确定有限状态自动机），接受且仅接受以某一个模式串作为后缀的字符串。**
>
> 并且，与一般自动机不同的，AC 自动机还有 **关于某个模式串的接受状态**（我自己起的名字..），也就是与某个模式串匹配（以某个模式串为后缀）的那些状态，即某个模式串在 Trie 树上的终止节点在 fail 树上的整个子树。

这段话我先放上来，因为我相信绝大部分人学了 AC 自动机之后甚至不知道 AC 自动机是什么，而只知道它有什么用。

这篇题解假定你会 AC 自动机，如果不会的话，可以看[我写的教程](https://ouuan.github.io/AC自动机学习笔记)。

然后的话，很多人用 AC 自动机进行多模匹配时都会暴力跳 fail 边，但这样做复杂度是错误的，可以被类似于 `aaaaa……aaaaa` 这样的串卡掉。

正确的做法是建出 fail 树，记录自动机上的每个状态被匹配了几次，最后求出每个模式串在 Trie 上的终止节点在 fail 树上的子树总匹配次数就可以了。

参考代码：

```cpp
#include <iostream>
#include <cstdio>
#include <queue>

using namespace std;

const int N = 200010;
const int T = 200010;
const int S = 2000010;

void dfs(int u);
void add(int u, int v);

char s[S];
queue<int> q;
int head[T], nxt[T], to[T], cnt;
int n, tr[T][26], fail[T], tot = 1, match[N], siz[T];

int main()
{
    int i, j, u;

    scanf("%d", &n);

    for (i = 1; i <= n; ++i)
    {
        scanf("%s", s);
        for (u = 1, j = 0; s[j]; ++j)
        {
            int c = s[j] - 'a';
            if (!tr[u][c]) tr[u][c] = ++tot;
            u = tr[u][c];
        }
        match[i] = u; // 记录每个模式串在 Trie 树上的终止节点
    }

    for (i = 0; i < 26; ++i) tr[0][i] = 1; // 一种比较与众不同（个人认为比较正确）的 AC 自动机建法，详见上文提到的我写的博客

    q.push(1);

    while (!q.empty())
    {
        u = q.front();
        q.pop();
        for (i = 0; i < 26; ++i)
        {
            if (tr[u][i])
            {
                fail[tr[u][i]] = tr[fail[u]][i];
                q.push(tr[u][i]);
            }
            else tr[u][i] = tr[fail[u]][i];
        }
    }

    scanf("%s", s);

    for (u = 1, i = 0; s[i]; ++i)
    {
        u = tr[u][s[i] - 'a'];
        ++siz[u]; // 记录匹配次数
    }

    for (i = 2; i <= tot; ++i) add(fail[i], i); // 建 fail 树

    dfs(1); // 统计子树和

    for (i = 1; i <= n; ++i) printf("%d\n", siz[match[i]]);

    return 0;
}

void dfs(int u)
{
    int i, v;
    for (i = head[u]; i; i = nxt[i])
    {
        v = to[i];
        dfs(v);
        siz[u] += siz[v];
    }
}

void add(int u, int v)
{
    nxt[++cnt] = head[u];
    head[u] = cnt;
    to[cnt] = v;
}
```



---

## 作者：Ireliaღ (赞：26)

# ~~巨慢的~~SA解法

~~“只有SA可以吗？”~~  *(首)*

后缀数组（SA）是一个和SAM并列的强大字符串算法，在很多题中它们可以互相替代。如果没有学过，可以去[SA模板](https://www.luogu.com.cn/problem/P3809)学习一下。

在这道题中，我们对文本串$S$建立SA。如果给定一个模式串$T$，我们可以在SA上二分，用$|T| \log |S|$的复杂度求出比$T$字典序小的$S$的后缀个数。利用这个方法，在$T$后添加一个极大的字符，二分出答案$r$，再把$T$最后一个字符$-1$，二分出答案$l$，求出的$r-l$就是以$T$为前缀的$S$的后缀数，也就是$T$在$S$的出现次数

代码如下

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#define R register

using namespace std;
const int MAXN = 2e6 + 6;

int n, slen, len[MAXN], sum[MAXN];
char S[MAXN], T[MAXN], str[MAXN];

struct SuffixArray{
	int n, m;
	int sa[MAXN], rk[MAXN], tx[MAXN], tp[MAXN];	
	
	void Init(int a, int b, char *s) {
		n = a;
		m = b;
		for (R int i = 1; i <= n; i++) {
			rk[i] = s[i];
			tp[i] = i;
		}
	}
	
	void RSort() {
		for (R int i = 0; i <= m; i++) tx[i] = 0;
		for (R int i = 1; i <= n; i++) tx[rk[i]]++;
		for (R int i = 1; i <= m; i++) tx[i] += tx[i - 1];
		for (R int i = n; i >= 1; i--) sa[tx[rk[tp[i]]]--] = tp[i];
	}
	
	void Build() {
		RSort();
		for (R int w = 1, p = 1; p < n; w <<= 1, m = p) {
			p = 0;
			for (int i = 1; i <= w; i++)
				tp[++p] = n - w + i;
			for (int i = 1; i <= n; i++)
				if (sa[i] > w)
					tp[++p] = sa[i] - w;
			RSort();
			swap(rk, tp);
			rk[sa[1]] = p = 1;
			for (int i = 2; i <= n; i++)
				rk[sa[i]] = (tp[sa[i]] == tp[sa[i - 1]] && tp[sa[i] + w] == tp[sa[i - 1] + w]) ? p : ++p;
		}
	}
}SA;

int Comp(int p) {//str > S
	for (int i = 1, j = p; str[i] && S[j]; i++, j++) {
		if (str[i] < S[j]) return 0;
		if (str[i] > S[j]) return 1;
	}
	return 1;
}

int main() {
	scanf("%d", &n);
	int p = 1;
	for (int i = 1; i <= n; i++) {
		scanf("%s", T + p);
		len[i] = strlen(T + p);
		sum[i] = sum[i - 1] + len[i];
		p = sum[i] + 1;
	}
	scanf("%s", S + 1);
	slen = strlen(S + 1);
	memcpy(str + 1, S + 1, slen);
	for (int i = 1; i <= slen; i++) str[i] -= 'a' - 1;
	SA.Init(slen, 30, str);
	SA.Build();
	for (R int i = 1; i <= n; i++) {
		memcpy(str + 1, T + sum[i - 1] + 1, len[i]);
		str[len[i] + 1] = 127;
		str[len[i] + 2] = '\0';
		int ans1 = 0;
		for (R int j = 21; j >= 0; j--) {
			if (ans1 + (1 << j) > slen) continue;
			if (Comp(SA.sa[ans1 + (1 << j)]))
				ans1 += (1 << j);
		}
		str[len[i]]--;
		int ans2 = 0;
		for (R int j = 21; j >= 0; j--) {
			if (ans2 + (1 << j) > slen) continue;
			if (Comp(SA.sa[ans2 + (1 << j)]))
				ans2 += (1 << j);
		}
		printf("%d\n", ans1 - ans2);
	}
	return 0;
}
```

虽然我在这篇代码当中进行了少许卡常，但是它并不能AC这道题。实际上，用我们常用的SA来实现我前面讲的思路，根据你代码的常数大小一般会获得72~84的分数。当然，我不否定一些卡常达人可以用常用的SA通过的可能。

不难发现，我前面的代码无法通过的瓶颈在于构造$S$的SA使用了$|S| \log |S|$的时间，而这个复杂度想要跑$2 \times 10^6$也只是理论可能。所以，我们可以回到SA的模板题，复制一个$O(n)$的DC-3或者SA-IS甚至SAM构造SA来替换我代码当中的`struct SuffixArray{}`。这样，总复杂度是$O(|S| + \sum |T| \log |S|)$，可以稳定跑过此题。[提交记录](https://www.luogu.com.cn/record/31812250)

~~于是，我成功取代了duyi大佬的SAM解法，成为了全网倒数第二的通过记录~~

---

## 作者：August_Light (赞：20)

AC 自动机是一种多模字符串匹配算法。

> [[Luogu P5357]【模板】AC 自动机](https://www.luogu.com.cn/problem/P5357)
>
> 给你一个文本串 $S$ 和 $n$ 个模式串 $T_{1 \sim n}$，请你分别求出每个模式串 $T_i$ 在 $S$ 中出现的次数。
>
> $1 \le n \le 2 \times {10}^5$，$T_{1 \sim n}$ 的长度总和不超过 $2 \times {10}^5$，$S$ 的长度不超过 $2 \times {10}^6$。

下文中涉及时间复杂度的部分，$n$ 为模式串长度**之和**，$m$ 为文本串长度。

## 前置知识

- 字典树：[[Luogu P8306]【模板】字典树](https://www.luogu.com.cn/problem/P8306)。
- KMP：[[Luogu P3375]【模板】KMP](https://www.luogu.com.cn/problem/P3375)（不必要，但是最好了解其思想）。
- 自动机（DFA）基本概念：<https://oi-wiki.org/string/automaton/>。
- 自动机五要素：
  - 字符集 $\Sigma$。
  - 状态集合 $Q$。
  - 起始状态 $start$。
  - 接收状态集合 $F$。
  - 转移函数 $\delta$。$\delta(u,c)$ 中 $u,\delta(u,c) \in Q$，$c \in \Sigma$。

## Step 1：AC 自动机基于字典树

有多个模式串，考虑有什么简单的结构能解决多个字符串的问题。不难想到哈希和字典树。

哈希可能会碰撞，且看起来跟自动机相关理论没什么关系，很难扩展。

字典树可以视作自动机。

建立字典树时间复杂度 $O(n)$。

```cpp
int ins(string s) {
    int u = 0;
    for (auto ch : s) {
        int c = ch - 'a';
        if (!tr[u][c])
            tr[u][c] = ++tot;
        u = tr[u][c];
    }
    return u;
}
```

## Step 2：fail 数组的定义

多模字符串匹配是单个模式串匹配的扩展，所以考虑 KMP。

KMP 算法可以视作自动机。基于字符串 $s$ 的 KMP 自动机接受且仅接受以 $s$ 为后缀的字符串。

那么 AC 自动机就应该是：基于字符串 $s_{1 \sim n}$ 的 AC 自动机接受且仅接受以 $s_{1 \sim n}$ 任意一个为后缀的字符串。

考虑在 Trie 上定义一个类似 KMP 中 next 数组的数组。

具体地，定义 $fail(u)$ 为 $u$ 表示的字符串 **最长的** 且 **出现在 Trie 上的** **真** 后缀对应的状态。

在自动机上连上 $u$ 与 $fail(u)$ 的边，这条边被称为 fail 边。

从 OI-Wiki 偷一张图来解释：

![](https://oi-wiki.org/string/images/ac-automaton4.png)

灰色边为 Trie，黄色边为 fail 边。

例如此图中 $9$ 号连到 $2$ 号，是因为 $\texttt{she}$ 出现在 Trie 上的最长真后缀为 $\texttt{he}$，即 $2$ 号。

不难发现，这个 $fail(u)$ 当 Trie 中只有一个模式串时，就是 KMP 的 next 数组（这里的 next 数组表示 border 长度）。

**重要性质：fail 边形成一棵树**。这是 KMP 的 fail 树的应用：[[Luogu P5829]【模板】失配树](https://www.luogu.com.cn/problem/P5829)。

## Step 3：fail 如何求 & 构建 AC 自动机

自动机五要素：
- 字符集 $\Sigma$，为小写字母。
- 状态集合 $Q$，为 Trie 上的所有节点。
- 起始状态 $start$，为 Trie 的根节点 $0$。
- 接收状态集合 $F$，为所有模式串在 Trie 上的节点。
- 转移函数 $\delta$，下文着重讲解这一点。

以下 $tr$ 指原字典树。

若 $tr_{u,c}$ 存在，则 $\delta(u,c) = tr_{u,c}$，$fail(\delta(u,c)) = \delta(fail(u),c)$。

- 注意到 $fail(\delta(u,c))$ 基于 $fail(u)$，所以我们 BFS 求解 fail。

若 $tr_{u,c}$ 不存在：

- 若 $u$ 是根节点 $0$，则 $\delta(u,c) = 0$。
  - 如果没有这一条，则 $0$ 的儿子的 $fail$ 会连到自身，不满足真后缀。
- 否则 $\delta(u,c) = \delta(fail(u),c)$。

最后一条的递归与 KMP 的不断跳 next 是相同的。关于这一点，我们可以看看 KMP 自动机的 $\delta$：

$$\delta(u,c) = \begin{cases} u+1 & c = s_{u+1} \\ 0 & c \ne s_{u+1} \land u = 0 \\ \delta(next(u),c) & c \ne s_{u+1} \land u \ne 0 \end{cases}$$

再看看 AC 自动机的 $\delta$：

$$\delta(u,c) = \begin{cases} tr_{u,c} & tr_{u,c} \text{ exists} \\ 0 & tr_{u,c} \text{ does not exist} \land u = 0 \\ \delta(fail(u),c) & tr_{u,c} \text{ does not exist} \land u \ne 0 \end{cases}$$

不能说十分类似，只能说是一模一样。

代码上，我们不用重新建一个自动机，直接按照 AC 自动机的 $\delta$ 改 Trie 的结构即可。时间复杂度 $O(n |\Sigma|)$。

```cpp
// tr 原本为字典树
void bfs() {
    queue<int> q;
    for (int c = 0; c < 26; c++)
        if (tr[0][c])
            q.push(tr[0][c]);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int c = 0; c < 26; c++)
            if (tr[u][c]) {
                fail[tr[u][c]] = tr[fail[u]][c];
                q.push(tr[u][c]);
            } else
                tr[u][c] = tr[fail[u]][c];
    }
}
```

你非要新建一个自动机也不是不行。但是空间常数大一倍，没啥意义。

```cpp
// tr 为字典树
// dt 指转移函数 delta
void bfs() {
    queue<int> q;
    for (int c = 0; c < 26; c++)
        if (tr[0][c])
            q.push(dt[0][c] = tr[0][c]);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int c = 0; c < 26; c++)
            if (tr[u][c]) {
                dt[u][c] = tr[u][c];
                fail[dt[u][c]] = dt[fail[u]][c];
                q.push(dt[u][c]);
            } else
                dt[u][c] = dt[fail[u]][c];
    }
}
// 注意后文作匹配的时候要沿着 dt 而不是 tr
```

## Step 4：多模字符串匹配

接下来我们就可以把文本串作为输入给到 AC 自动机。

用一个数组记录每一个节点被走过了多少次。

建出 fail 树，DFS 子树求和，保存在 $sum$ 数组。

此时 $sum_u$ 为 $u$ 对应的字符串被匹配到的次数。原因是 fail 树上，若一节点匹配上了，则其祖先也必然匹配。

第 $i$ 个模式串对应节点的子树和即为答案。

（这一段看具体代码更容易懂。）

## 总结 & 完整代码

1. 建出 Trie 树，保存每个模式串在 Trie 上的位置。$O(n)$。
2. 把 Trie 树改造为 AC 自动机，并求出 fail 数组，建出 fail 树。$O(n |\Sigma|)$。
3. 把文本串作为输入给到 AC 自动机，在 fail 树上求和得到答案。$O(m)$。

空间复杂度为 $O(n |\Sigma| + m)$。

DFS 用了 lambda 表达式。以普通函数的形式写一个 DFS 也是没有问题的。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int MAXN = 2e5 + 5; // 模式串长度之和

int tr[MAXN][26], fail[MAXN], tot = 0;
int e[MAXN], sum[MAXN];
vector<int> G[MAXN];
int ins(string s) {
    int u = 0;
    for (auto ch : s) {
        int c = ch - 'a';
        if (!tr[u][c])
            tr[u][c] = ++tot;
        u = tr[u][c];
    }
    return u;
}
void bfs() {
    queue<int> q;
    for (int c = 0; c < 26; c++)
        if (tr[0][c])
            q.push(tr[0][c]);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int c = 0; c < 26; c++)
            if (tr[u][c]) {
                fail[tr[u][c]] = tr[fail[u]][c];
                q.push(tr[u][c]);
            } else
                tr[u][c] = tr[fail[u]][c];
    }
}

int main() { ios::sync_with_stdio(0); cin.tie(0);
    int n; cin >> n; for (int i = 1; i <= n; i++) {
        string s; cin >> s;
        e[i] = ins(s);
    }
    bfs();
    for (int u = 1; u <= tot; u++)
        G[fail[u]].push_back(u);

    string t; cin >> t;
    int u = 0;
    for (auto ch : t) {
        int c = ch - 'a';
        u = tr[u][c];
        sum[u]++;
    }
    auto dfs = [&](int u, auto&& self) -> void {
        for (auto v : G[u]) {
            self(v, self);
            sum[u] += sum[v];
        }
    };
    dfs(0, dfs);
    for (int i = 1; i <= n; i++)
        cout << sum[e[i]] << '\n';
    return 0;
}
```

---

## 作者：warzone (赞：18)

### 前言

此处仅讲AC自动机的优化,刚开始学的请右转:

[AC自动机【简单版】](https://www.luogu.org/problem/P3808)

[AC自动机【加强版】](https://www.luogu.org/problem/P3796)

顺带宣传下[yyb巨佬的博客](https://www.cnblogs.com/cjyyb/p/7196308.html)(相当透彻)

---------------------------------------

首先,既然是输出每个串(还有重复),那么只需一个vector[]存就好了

但既然是二次加强版,那肯定会有TLE

于是匹配方面马上就能看到可以优化的地方

原匹配

```cpp
unsigned int p=0;
register char c=getchar();
while('a'>c||c>'z') c=getchar();
for(;'a'<=c&&c<='z';c=getchar()){
	c-='a';
	p=all[p].next[c];
   for(register int id=p;id!=0;id=all[id].nxt)
		all[id].count++;//此处我们用一个循环来记录
}
```

很明显,此处用循环效率明显**太低了**!

如果模式串为rrrrrrr...(长度为n),将会循环n次

时间复杂度将退化为单个KMP的 O(n*m)

于是就能想到只记录AC自动机扫描到的位置,之后统一递归处理

```cpp
unsigned int p=0;
register char c=getchar();
while('a'>c||c>'z') c=getchar();
for(;'a'<=c&&c<='z';c=getchar()){
	c-='a';
	p=all[p].next[c];
	all[p].count++;
}
for(register int i=size;i>0;i--) //统一处理
	all[all[i].nxt].count+=all[i].count;
```

优化的差不多了,时间复杂度达到了稳定的 **O(n+m)**

从后往前递归，fail数应该符合这一规律

交吧! [WA?!](https://www.luogu.org/record/21885090)

--------------------------------------------

时间复杂度是够了,但为甚么答案错了?

如果是普通KMP,nxt只会指向模式串本身的前缀

但AC自动机由于是字典树,指向的不一定是前缀

因此**存储整个fail指针树,依序dfs**就真的必要了

(原以为可以多省点空间的qwq)

求nxt的时候,存儿子首选**邻接表**

```cpp
if(head[nextnxt]==0)
	head[nextnxt]=all[id].next[i];
else next[tail[nextnxt]]=all[id].next[i];
tail[nextnxt]=all[id].next[i];
next[all[id].next[i]]=0;
```
然后统计便这样写

```cpp
inline void dfs_count(int id){
	for(register int i=head[id];i!=0;i=next[i]){
		dfs_count(i);
		all[id].count+=all[i].count;
	}
}
```

于是这道题差不多就完成了~

**AC完整代码(不开O2,1.40s,35.76MB)**

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
inline int read(){
    register char c=getchar(),w=1;
    while('0'>c||c>'9'){
        if(c=='-') w=-1;
        c=getchar();
    }
    register int a=0;
    while('0'<=c&&c<='9'){
        a=a*10+c-'0'; 
        c=getchar();
    }
    return a*w;
}//快读(尽管基本没用) 
template<unsigned int size>
class QUEUE{//求nxt的队列 
    private:
		unsigned int list[size+1];
		unsigned int head,tail;
	public:
	 	QUEUE(){
	 		head=tail=0;
		}
	 	inline void push(unsigned int in){
	 		list[tail]=in;
	 		if(tail==size) tail=0;
	 		else tail++;
	 	}
	 	inline void pop(){
	 		if(head==size) head=0;
	 		else head++;
	 	}
	 	inline unsigned int top(){return list[head];}
	 	inline bool empty(){return head==tail;}
};
QUEUE<200000>q;
template<unsigned int length,unsigned int S_SIZE>
class Trie{
    private:
        struct point{
        	unsigned int next[26],nxt;
        	unsigned int count,floor,ans;
		}all[length+1];
		unsigned int size,s_size;
		unsigned int vector[S_SIZE+1],head[length+1],tail[length+1],next[length+1];
    public:
    	Trie(){//字典树初始化 
    		s_size=size=0;
		}
		inline void read(){//读入 
			unsigned int p=0;
			register char c=getchar();
			while('a'>c||c>'z') c=getchar();
			for(;'a'<=c&&c<='z';c=getchar()){
				c-='a';
				if(all[p].next[c]==0){
					size++;
					all[p].next[c]=size;
					all[size].floor=all[p].floor+1;
				}
				p=all[p].next[c];
			}
			s_size++;//更新向量 
			vector[s_size]=p; 
		}
		inline void getnxt(){//求nxt(或fail指针) 
			for(register int i=0;i<26;i++){
				if(all[0].next[i]!=0){
					all[all[0].next[i]].nxt=0;
					 
					if(head[0]==0) head[0]=all[0].next[i];
					else next[tail[0]]=all[0].next[i];
					tail[0]=all[0].next[i];
					next[all[0].next[i]]=0;
					//邻接表存nxt树儿子 
					q.push(all[0].next[i]);
				}
			}
			for(register int id;!q.empty();){
				id=q.top();q.pop();
				for(register int i=0,nextnxt;i<26;i++){
					nextnxt=all[all[id].nxt].next[i];
					if(all[id].next[i]==0){
                        all[id].next[i]=nextnxt;
                        continue;
                        
                    }
					all[all[id].next[i]].nxt=nextnxt;
						
					if(head[nextnxt]==0)
						head[nextnxt]=all[id].next[i];
					else next[tail[nextnxt]]=all[id].next[i];
					tail[nextnxt]=all[id].next[i];
					next[all[id].next[i]]=0;
					//同上	
					q.push(all[id].next[i]);
				}
			}
		}
		inline void dfs_count(int id){
			for(register int i=head[id];i!=0;i=next[i]){
				dfs_count(i);
				all[id].count+=all[i].count;
			}
		}//依序统计 
		inline void AC_auto(){
			unsigned int p=0;
			register char c=getchar();
			while('a'>c||c>'z') c=getchar();
			for(;'a'<=c&&c<='z';c=getchar()){
				c-='a';
				p=all[p].next[c];
				all[p].count++;
			}//匹配 
			dfs_count(0);
			for(register unsigned int i=1;i<=s_size;i++){
				printf("%d\n",all[vector[i]].count);
			}//输出 
		}
};
Trie<200010,200010> tree;
int main(){
    const int n=read();
	for(register int i=0;i<n;i++) tree.read();
	tree.getnxt();
	tree.AC_auto();
    return 0; 
}
```

---

## 作者：kkxhh (赞：13)

~~趁还没有人来偷偷水一篇题解~~

首先既然你在做这题想必你已经 $AC$ 了[这题](https://www.luogu.org/problemnew/show/P3808)和[这题](https://www.luogu.org/problemnew/show/P3796)，所以 $AC$ 自动机的基本操作就不用多说了

那么除了基本操作以外做这题还需要什么呢？

~~没有了~~

这题要求我们求出每个模式串在文本串中出现的次数（~~毒瘤的~~需要注意的是会有重复的字符串，所以需要在每个节点拉一个链表），实际上也就是建出 $AC$ 自动机后把文本串在上面跑一遍，每到达一个节点就把 $fail$ 树上这个节点到根路径上的每个节点计数器$+1$

于是实际上就是一个在 $fail$ 树上的树上差分

最后我们可以发现在 $build$ 时用的队列里的点倒序一下就是处理差分的顺序，然后这题就做完了

代码：
```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;

typedef struct node{
    int son[26],fail;
    int& operator [] (int x) {return son[x];}
}node;

node t[200010];
int n,tot,q[200010],head,tail,d[200010],ans[200010],hd[200010],nxt[200010];
char s[2000010];

void insert(char *s,int id){
    int cur=0,len=strlen(s);
    for(int i=0;i<len;i++){
        if(!t[cur][s[i]-'a']) t[cur][s[i]-'a']=++tot;
        cur=t[cur][s[i]-'a'];
    }
    nxt[id]=hd[cur]; hd[cur]=id;
}

void build(){
    head=1; tail=0;
    for(int i=0;i<26;i++) if(t[0][i]) q[++tail]=t[0][i];
    while(head<=tail){
        int x=q[head++];
        for(int i=0;i<26;i++){
            if(t[x][i]) t[t[x][i]].fail=t[t[x].fail][i],q[++tail]=t[x][i];
            else t[x][i]=t[t[x].fail][i];
        }
    }
}

void solve(){
    scanf("%s",s);
    int cur=0,len=strlen(s);
    for(int i=0;i<len;i++) {cur=t[cur][s[i]-'a']; d[cur]++;}
    for(int i=tot;i>=1;i--){
        for(int j=hd[q[i]];j;j=nxt[j]) ans[j]=d[q[i]];
        d[t[q[i]].fail]+=d[q[i]];
    }
}

int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++) {scanf("%s",s); insert(s,i);}
    build(); solve();
    for(int i=1;i<=n;i++) printf("%d\n",ans[i]);
    return 0;
}

```

---

## 作者：TLE自动机 (赞：8)

做了很久。。

这里给出另一种统计方法：（其余就看楼上题解吧）

bfs时把所有trie树上节点用stack存起来，
统计答案时按stack里的顺序（逆序）访问统计答案即可，不需要dfs（然而时间好像差不多。。）

为什么是正确的呢？逆序保证了在访问这个节点的fail之前它一定被访问过。可以自己画图模拟一下。。

1728ms~~本人自带大常数，勿喷~~：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#include<stack>
using namespace std;
int read(){
    int x=0,pos=1;char ch=getchar();
    for(;!isdigit(ch);ch=getchar()) if(ch=='-') pos=0;
    for(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';
    return pos?x:-x;
}
int n;char s[200001],m[2000051];int pans[10000001],siz[10000051];
int ans[200001];
int l[200001],lnk[200001];
struct ac{
    int son[30],fail,end;
}tree[10000001];
struct node{
    int v,nex;
}edge[1000001];
int tope=0,head[1000001];
void add(int from,int to){
    edge[++tope].v=to;
    edge[tope].nex=head[from];
    head[from]=tope;
}
int tot=0;
void insert(int cnt){
    int now=0;int len=l[cnt];
    for(int i=0;i<len;i++){
        if(!tree[now].son[s[i]-'a']){
            tree[now].son[s[i]-'a']=++tot;
            memset(tree[tot].son,0,sizeof(tree[tot].son));
        }
        now=tree[now].son[s[i]-'a'];
    }
    lnk[cnt]=now;
    return;
}
stack<int>st;
void bfs(){
    queue<int>q;
    for(int i=0;i<26;i++){
        if(tree[0].son[i]) {
            tree[tree[0].son[i]].fail=0; 
            q.push(tree[0].son[i]);
        }
    }
    while(!q.empty()){
        int now=q.front();
        q.pop();
        for(int i=0;i<26;i++){
            if(tree[now].son[i]){
                int nex=tree[now].son[i];
                tree[nex].fail=tree[tree[now].fail].son[i];
                q.push(nex);
            }else tree[now].son[i]=tree[tree[now].fail].son[i];
        }
        st.push(now);
    }
}
void search(){
    int now=0,len=strlen(m);
    for(int i=0;i<len;i++){
        now=tree[now].son[m[i]-'a'];
        siz[now]++;
    }
    now=0;
    while(!st.empty()){
    	now=st.top();st.pop();
    	siz[tree[now].fail]+=siz[now];
    }
    return;
}
int main(){
    n=read(); 
    tot=0;
    for(int i=1;i<=n;i++){
        scanf("%s",s);
        int len=strlen(s);
        l[i]=len;
        insert(i);
    }
    scanf("%s",m);
    bfs();
    search();
    for(int i=1;i<=n;i++){
    	printf("%d\n",siz[lnk[i]]);
    }
    return 0;
} 
```


---

## 作者：linjunye (赞：6)

#### 前言：

若想获得更好的阅读体验，请先做这两题：
- [P3808 AC 自动机（简单版）](https://www.luogu.com.cn/problem/P3808)
- [P3796 AC 自动机（简单版 II）](https://www.luogu.com.cn/problem/P3796)

如果你不懂 AC 自动机，可以阅读此博客：

[yyb 大佬的博客](https://www.cnblogs.com/cjyyb/p/7196308.html)

#### 第一次提交
初看题目，可以发现，与 AC 自动机（简单版 II）差不多。

这里不再赘述，直接看代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
struct tree{
	int fail,son[30],end;
}T[200010];
int cnt;
struct Ans{
	int tot;
}ans[200010];
void build(string s,int pos){//构造字典树 
	int len=s.size();
	int root=0;
	for(int i=0;i<len;i++){
		if(!T[root].son[s[i]-'a'])
			T[root].son[s[i]-'a']=++cnt;
		root=T[root].son[s[i]-'a'];
	}
	T[root].end=pos;//以这个字母为结尾的单词下标 
	return; 
}
void Fail(){//构造指针 
	queue<int>Q;
	for(int i=0;i<26;i++){
		if(T[0].son[i]){
			T[T[0].son[i]].fail=0;
			Q.push(T[0].son[i]);
		}
	}
	while(!Q.empty()){
		int d=Q.front();
		Q.pop();
		for(int i=0;i<26;i++){
			if(T[d].son[i]){
				T[T[d].son[i]].fail=T[T[d].fail].son[i];
				Q.push(T[d].son[i]);
			}
			else T[d].son[i]=T[T[d].fail].son[i];
		}
	}
	return;
}
void query(string s){
	int len=s.size();
	int root=0;
	for(int i=0;i<len;i++){
		root=T[root].son[s[i]-'a'];
		for(int j=root;j;j=T[j].fail)
			ans[T[j].end].tot++;
	}
	return;
}
int n;
string s[200010],text;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>s[i];
		build(s[i],i);
	}
	T[0].fail=0;
	Fail();
	cin>>text;
	query(text);
	for(int i=1;i<=n;i++)
		cout<<ans[i].tot<<"\n";
	return 0;
}
```
然后——
![](https://cdn.luogu.com.cn/upload/image_hosting/9gfhwakm.png)
#### 第二次提交
上次提交不仅有 WA，还有 TLE。

于是我们重新阅读题干。

**数据不保证任意两个模式串不相同。**

原来如此，那么我们需要将 `T[root].end=pos;` 改为：
```cpp
	if(!T[root].end)T[root].end=pos;//此单词没出现，记录 
	Map[pos]=T[root].end;//Map[i]代表第i个模式串与的第T[root].end个模式串相同 
```
（补充：`T[root].end` 代表节点 root 所记录的字符为一个模式串的末尾。）

所以，我们的输出也要做一些小小的改动。
```cpp
printf("%d\n",ans[Map[i]]);//ans就是存答案的数组
```
但是，第二次提交也不能 AC。~~还 AC 自动机呢……~~
![](https://cdn.luogu.com.cn/upload/image_hosting/q97wgylp.png)
#### 第三次提交 拓扑排序优化
为什么 AC 自动机会 TLE？那是因为某些数据能将 AC 自动机的 $\Theta(n)$ 卡成 $\Theta(nm)$。

（说明：时间复杂度中的 $n$ 为 $\sum\limits_{i=1}^{n}t_{i}$，$m$ 为文本串 $S$ 的长度。）

我们可以通过建图来验证上面的说法。
![](https://cdn.luogu.com.cn/upload/image_hosting/ch8ebhgr.png)
如图，假设我们先访问节点三，则根据 Fail 指针，会依次跳到节点五、节点十。

再假设后面，我们访问到节点五，则根据 Fail 指针，会跳到节点十，节点十就重复访问了，我们的时间就浪费在这些地方。

这时，我们肯定可以想到一点：

我们可以将访问到的节点打上标记，最后再把节点“上传”，就可以实现一个十分稳定的 AC 自动机了。

想法的确不错，可是我们该怎么知道先从最下面开始呢？

欸，还真有，那就是使用拓扑排序！

我们把 Fail 指针看作一条边，则以这种方式造的图一定是 DAG（原理见下）。

那么，入度为零的点就是末尾了！

[附代码](https://www.luogu.com.cn/paste/wfynr6cu)。
#### “拓扑排序优化”的原理
这里讲述到 Fail 指针的工作目的。

我们先定义一个名词——Fail 链：由 Fail 指针构成的链。

接下来开始讲正事。

Fail 指针，顾名思义，就是匹配失败时，跳到其他节点，该节点与此节点有某些相似之处。

那么，一旦匹配不到这个字符，就会跳出，并且不会再次出现在这个 Fail 链中（不然你还是会不匹配），于是这个 Fail 链是 DAG。

也就是说，入度为零的点，必定是一个 Fail 链的末尾（否则将有其他节点指向它）。

那么，因为我们的“上传”是从末尾加起，将不会造成节点的重复，因此效率大大提高。

那么，打标记的时间复杂度为 $\Theta(m)$，拓扑排序的时间复杂度为 $\Theta(n)$，总的时间复杂度是 $\Theta(n+m)$。

---

## 作者：lzkAK2009 (赞：6)

建议大家先通过[AC 自动机（简单版 II）](https://www.luogu.com.cn/problem/P3796)，了解 AC 自动机原理。本题方法就是对简单版的优化。

加强版通常都是优化时间或内存，既然本题中内存按照简单版建数组没有问题，那就是优化时间了。但简单版中哪部分代码需要优化呢？

如果我们计算代码的时间复杂度，就会发现这段循环跳 fail 边效率极低：
```cpp
void query (string x) {
	int len = x.length (), now = 0;
	for (int i = 0; i < len; i++) {
		int c = x[i] - 'a';
		now = trie[now][c];
		for (int j = now; j; j = fail[j])
			vis[j]++;
	}
}
``````
看一下下面的例子（手画勿喷

![](https://cdn.luogu.com.cn/upload/image_hosting/v1ed9ogf.png)

红色的边是 fail 边。可以看出，在这个例子中，刚才的方法时间复杂度会被卡到 $O(n \lvert S \rvert)$，算法就退化为了 $n$ 次 KMP 算法。我们需要一种避免循环的方法，在询问结束后再处理答案。这就是——
## 拓扑建图优化
如果我们把刚才图中的 fail 边单独拿出，就会发现

![](https://cdn.luogu.com.cn/upload/image_hosting/lbybrozs.png)

fail 边连接起来的点构成了一棵树！

这是因为每个点都会有 $1$ 个 fail，trie 树的根节点没有 fail，边数比点数少 $1$，就构成了一棵树。

因此，我们可以在这棵树上进行拓扑排序，用入度小的点的答案更新入度大的点，这样就能在跑 AC 自动机时不跳 fail 边，跑完后统一更新答案，顺便把答案赋给原字符串。

拓扑排序代码：
```cpp
void topu () {
	queue <int> q;
	for (int i = 1; i <= cnt; i++)
		if (!in[i])
			q.push (i); //入度为0入队
	while (!q.empty ()) {
		int u = q.front ();
		q.pop ();
		for (auto it = flag[u].begin (); it != flag[u].end (); it++)
			ans[*it] = vis[u]; //u点对应的所有字符串
		int v = fail[u];
		vis[v] += vis[u];//更新u点fail边指向的点答案
		in[v]--; 
		if (!in[v])
			q.push (v); //入度为0入队
	}
}
``````
这里的 in 数组需要在添加 fail 边时维护，那么 flag 数组为什么会有“begin”“end”呢？题目中提到数据不保证任意两个模式串不相同，因此我们把 flag 数组设为 vector，把一个点对应的字符串都加进去。其他的细节代码中有注释。
## 最终代码
```cpp
#include <bits/stdc++.h>

#define N 200003

using namespace std;

int n, trie[N][26], fail[N], cnt, in[N], vis[N], ans[N];

string t, s;

vector <int> flag[N]; //点对应的字符串

void add (string x, int id) { //建trie树
	int len = x.length (), now = 0;
	for (int i = 0; i < len; i++) {
		int c = x[i] - 'a';
		if (!trie[now][c])
			trie[now][c] = ++cnt;
		now = trie[now][c];
	}
	flag[now].push_back (id);
}

void get_fail () { //添加fail边
	queue <int> q;
	for (int i = 0; i < 26; i++)
		if (trie[0][i])
			q.push (trie[0][i]);
	while (!q.empty ()) {
		int u = q.front ();
		q.pop ();
		for (int i = 0; i < 26; i++) {
			if (trie[u][i]) {
				fail[trie[u][i]] = trie[fail[u]][i];
				in[fail[trie[u][i]]]++; //fail边指向的点入度+1
				q.push (trie[u][i]);
			}
			else trie[u][i] = trie[fail[u]][i];
		}
	}
}

void query (string x) { //查询答案
	int len = x.length (), now = 0;
	for (int i = 0; i < len; i++) {
		int c = x[i] - 'a';
		now = trie[now][c];
		vis[now]++; //不需跳fail边
	}
}

void topu () { //拓扑排序
	queue <int> q;
	for (int i = 1; i <= cnt; i++)
		if (!in[i])
			q.push (i);
	while (!q.empty ()) {
		int u = q.front ();
		q.pop ();
		for (auto it = flag[u].begin (); it != flag[u].end (); it++)
			ans[*it] = vis[u];
		int v = fail[u];
		vis[v] += vis[u];
		in[v]--;
		if (!in[v])
			q.push (v);
	}
}

int main () {
	ios::sync_with_stdio (false);
	cin.tie (nullptr);
	cout.tie (nullptr);
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> t;
		add (t, i);
	}
	cin >> s;
	get_fail ();
	query (s);
	topu ();
	for (int i = 1; i <= n; i++)
		cout << ans[i] << "\n";
	return 0;
}
``````

---

## 作者：tq20191005 (赞：5)

参考了楼上用拓扑排序优化的,用指针写的,另外用了unordered_map优化了输入重复串的问题,遇见相同的字符串可以记录之前字符串出现的位置.
```
#include<iostream>
#include<cstring>
#include<string>
#include<queue>
#include<vector>
#include<unordered_map>
using namespace std;
typedef struct Trie Trie;
vector<Trie*>arr;//存入AC自动机中所有的节点
struct Trie {
	Trie* links[26];
	Trie* fail;
	bool flag;//记录是否是字符串
	int postion, in, ans;//postion 记录该字符串的位置 默认为 -1 , in 为该节点的入度 ans 为距离
	Trie() {
		memset(links, 0, sizeof links);
		flag = false; fail = 0, postion = -1, in = ans = 0;
	}
};
void Insert_string(string str, Trie* p, int postion) {
	for (auto vi : str) {
		int ch = vi - 'a';
		if (p->links[ch] == nullptr)
			p->links[ch] = new Trie();
		p = p->links[ch];
	}
	p->flag = true, p->postion = postion;
}
void Build_fail(Trie* root) {
	queue<struct Trie*>qu; qu.push(root);
	while (!qu.empty()) {
		auto first = qu.front(); qu.pop();
		for (int i = 0; i < 26; ++i) {
			if (first->links[i]) {
				arr.push_back(first->links[i]);
				qu.push(first->links[i]);
				if (first == root)
					first->links[i]->fail = root;
				else {
					auto father = first->fail;
					while (father) {
						if (father->links[i]) {
							first->links[i]->fail = father->links[i];
							++first->links[i]->fail->in;//fail 指向的节点入度 +1
							break;
						}
						father = father->fail;
					}
					if (father == nullptr)first->links[i]->fail = root;
				}
			}
		}
	}
}
void ac(string text, Trie* root) {
	auto p = root;
	for (auto vi : text) {
		int ch = vi - 'a';
		while (p && p->links[ch] == nullptr)p = p->fail;
		if (p == nullptr) { p = root; continue; }
		p = p->links[ch];
		++p->ans;
	}
}
int main(void) {
	ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
	int n; cin >> n;
	Trie A;
	string str, text;
	vector<int>postion(n + 1);
	unordered_map<string, int>mp;
	for (int i = 1; i <= n; ++i) {
		cin >> str;
		if (mp.count(str)) {
			postion[i] = -mp[str]; continue;//如果该字符串之前插入了,那么 vector<i> 记录之前该字符串的位置
		}
		mp.insert({ str,i });
		Insert_string(str, &A, i);
	}
	Build_fail(&A);
	cin >> text;//文本串
	ac(text, &A);

	//拓扑排序
	queue<Trie*>qu;
	for (auto vi : arr)//入度为 0 的节点入队
		if (!vi->in)qu.push(vi);
	while (!qu.empty()) {
		auto tmp = qu.front(); qu.pop();
		tmp->fail->ans += tmp->ans;
		--tmp->fail->in;
		if (tmp->flag)
			postion[tmp->postion] += tmp->ans;
		if (!tmp->fail->in)
			qu.push(tmp->fail);
	}


	for (int i = 1; i <= n; ++i) {
		if (postion[i] < 0)//这个位置的字符串与 -postion[i] 位置的字符串相同
			cout << postion[-postion[i]] << endl;
		else
			cout << postion[i] << endl;
	}
	return 0;
}
```

---


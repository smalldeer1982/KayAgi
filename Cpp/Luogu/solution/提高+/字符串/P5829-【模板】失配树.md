# 【模板】失配树

## 题目描述

给定一个字符串 $s$，定义它的 **$k$ 前缀** $\mathit{pre}_k$ 为字符串 $s_{1\dots k}$，**$k$ 后缀** $\mathit{suf}_k$ 为字符串 $s_{|s|-k+1\dots |s|}$，其中 $1 \le k \le |s|$。

定义 $\bold{Border}(s)$ 为**对于 $i \in [1, |s|)$，满足 $\mathit{pre}_i = \mathit{suf}_i$** 的字符串 $\mathit{pre}_i$ 的集合。$\bold{Border}(s)$ 中的每个元素都称之为字符串 $s$ 的 $\operatorname{border}$。

有 $m$ 组询问，每组询问给定 $p,q$，求 $s$ 的 **$\boldsymbol{p}$ 前缀** 和 **$\boldsymbol{q}$ 前缀** 的 **最长公共 $\operatorname{border}$**  的长度。

## 说明/提示

样例 $2$ 说明：

对于第一个询问，$2$ 前缀和 $18$ 前缀分别是 ``zz`` 和 ``zzaaccaazzccaacczz``，由于 ``zz`` 只有一个 $\operatorname{border}$，即 ``z``，故最长公共 $\operatorname{border}$ 长度为 $1$。

---

对于 $16\%$ 的数据，$s$ 中的字符全部相等。

对于 $100\%$ 的数据，$1\leq p,q \le |s|\leq 10^6$，$1 \leq m \leq 10^5$，$s_i \in [\texttt{a}, \texttt{z}]$。

## 样例 #1

### 输入

```
aaaabbabbaa
5
2 4
7 10
3 4
1 2
4 11
```

### 输出

```
1
1
2
0
2
```

## 样例 #2

### 输入

```
zzaaccaazzccaacczz
3
2 18
10 18
3 5
```

### 输出

```
1
2
0
```

# 题解

## 作者：WYXkk (赞：29)

# P5829 【模板】失配树 题解
## 题意简述
给你一个串 $S$，定义一个字符串的 $\text{border}$ 为它的非本身的既是它的前缀又是它的后缀的字符串，$m$ 次询问，每次询问给定两个数 $i,j$，询问 $S_{1...i}$ 和 $S_{1...j}$ 的最长公共 $\text{border}$。

$1\le|S|\le10^6,1\le i,j\le|S|,1\le m\le10^5$，字符集为 $26$ 个小写字母。
## 解法
首先我们来看另外一个与它相关的问题：如何求出一个字符串的所有 $\text{border}$？

如果一个字符串既是 $S$ 的前缀又是 $S$ 的后缀，那么我们把 $S$ 自己平移一下就可以前后重合，然后我们就可以继续匹。。。。。诶？这不是 $\text{KMP}$ 么？

所以我们对原串 $\text{KMP}$ 一遍，然后就可以发现，$S_{1\cdots next(|S|)}$ 和 $S_{|S|-next(|S|)+1\cdots |S|}$ 是完全一样的！于是 $S^\prime=S_{1\cdots next(|S|)}$ 就是 $S$ 的一个 $\text{border}$。

那么 $S$ 是否还有其他 $\text{border}$ 呢？有。根据上文，$S^{\prime\prime}= S_{1\cdots next(next(|S|))}$ 是 $S^\prime=S_{1\cdots next(|S|)}$ 的一个 $\text{border}$，于是 $S^{\prime\prime}$ 既是 $S^\prime$ 的前缀又是 $S^\prime$ 的后缀。由于 $S^\prime$ 既是 $S$ 的后缀又是 $S$ 的前缀，所以 $S^{\prime\prime}$ 既是 $S$ 的前缀的前缀又是 $S$ 的后缀的后缀，所以 $S^{\prime\prime}$ 既是 $S$ 的前缀又是 $S$ 的后缀，也是 $S$ 的 $\text{border}$。

以此类推，我们可以得到，$S$ 的所有 $\text{border}$ 为：$S_{1\cdots next(|S|)},S_{1\cdots next(next(|S|))},S_{1\cdots next(next(next(|S|)))},\cdots$。

我们再来看看原题：求两个前缀的最长公共 $\text{border}$。

老套路，先对原串 $\text{KMP}$ 一遍，于是我们可以通过跳两个前缀的 $next$ 求到两个前缀的所有 $\text{border}$。

等等，这不是暴力求 $\text{LCA}$ 的思路吗？先暴力找到所有祖先，再判断相交。

所以我们可以通过 $next$ 数组建一棵树出来（可以发现这就是只有一个字符串的 $\text{AC}$ 自动机的 $fail$ 树，所以我们也叫它 $fail$ 树），容易发现两个前缀的最长公共 $\text{border}$ 就是它们在 $fail$ 树上的 $\text{LCA}$（当它们是祖先—后代关系时除外，此时结果是祖先的父亲）。

综上所述，本题的做法如下：

- 对原串 $\text{KMP}$ 一遍，求出 $next$ 数组；
- 构建 $fail$ 树；
- 在 $fail$ 树上跑 $\text{LCA}$（倍增和 $\text{tarjan}$ 都可以）。

代码如下：
```cpp
#include<cstdio>
#include<iostream>
#include<fstream>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
#define Set(a) memset(a,0,sizeof(a))
#define F(i,a,b) for(register int i=a,i##end=b;i<=i##end;++i)
#define UF(i,a,b) for(register int i=a,i##end=b;i>=i##end;--i)
#define openf(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
#define re register
#define ri re int
#define il inline
typedef long long ll;
typedef unsigned long long ull;
template<typename T> inline T rd(T& x)
{
	T f=1;x=0;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(; isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(T)(c-'0');
	x*=f;
	return x;
}
ll rd(){ll x;rd(x);return x;}
inline int max(int a,int b){return a>b?a:b;}
inline int min(int a,int b){return a<b?a:b;}
const int inf=1<<30;

const int N=1000005;
int fa[N][22],n,m,dep[N];char s[N];
int main()
{
	scanf("%s",s+1);n=strlen(s+1);
	fa[0][0]=fa[1][0]=0,dep[0]=0,dep[1]=1;
	for(ri i=2,j=0;i<=n;++i)
	{
		while(j!=0&&s[j+1]!=s[i]) j=fa[j][0];
		if(s[j+1]==s[i]) ++j;
		fa[i][0]=j,dep[i]=dep[j]+1;
	}
	//以上为kmp
	//以下为倍增lca
	F(i,1,21) F(j,1,n) fa[j][i]=fa[fa[j][i-1]][i-1];
	rd(m);
	while(m--)
	{
		int x,y;rd(x);rd(y);if(dep[x]<dep[y]) swap(x,y);
		UF(i,21,0) if(dep[fa[x][i]]>=dep[y]) x=fa[x][i];
		UF(i,21,0) if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i];
		printf("%d\n",fa[x][0]);
	}
	return 0;
}
```
突然感觉这题有种强行二合一的感觉（
****
倍增不开 $-\text O2$ 太慢了，有几个点会 $900ms$。。。这里再贴个 $\text{tarjan}$ 的
```cpp
#include<cstdio>
#include<iostream>
#include<fstream>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
#define Set(a) memset(a,0,sizeof(a))
#define F(i,a,b) for(register int i=a,i##end=b;i<=i##end;++i)
#define UF(i,a,b) for(register int i=a,i##end=b;i>=i##end;--i)
#define openf(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
#define re register
#define ri re int
#define il inline
typedef long long ll;
typedef unsigned long long ull;
template<typename T> inline T rd(T& x)
{
	T f=1;x=0;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(; isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(T)(c-'0');
	x*=f;
	return x;
}
ll rd(){ll x;rd(x);return x;}
inline int max(int a,int b){return a>b?a:b;}
inline int min(int a,int b){return a<b?a:b;}
const int inf=1<<30;

const int N=1000005;
int next[N],n,m;char s[N];
int fa[N];int get(int x){return fa[x]==x?x:fa[x]=get(fa[x]);}void merge(int x,int y){if((x=get(x))!=(y=get(y)))fa[x]=y;}
bool vis[N];
int head[N],to[2*N],nxt[2*N],tot;void add(int u,int v){to[++tot]=v;nxt[tot]=head[u];head[u]=tot;}//graph
int head2[N],to2[2*N],nxt2[2*N],num[2*N],tot2;void add2(int u,int v,int w){to2[++tot2]=v;num[tot2]=w;nxt2[tot2]=head2[u];head2[u]=tot2;}//query
int ans[N],x[N],y[N];
void tarjan(int x)
{
	vis[x]=true;
	for(ri i=head[x];i;i=nxt[i]) if(!vis[to[i]]) {tarjan(to[i]);merge(to[i],x);}
	for(ri i=head2[x];i;i=nxt2[i]) if(vis[to2[i]]) ans[num[i]]=get(to2[i]);
}
int main()
{
	scanf("%s",s+1);n=strlen(s+1);
	next[0]=next[1]=0;F(i,1,n) fa[i]=i;
	for(ri i=2,j=0;i<=n;++i)
	{
		while(j!=0&&s[j+1]!=s[i]) j=next[j];
		if(s[j+1]==s[i]) ++j;
		next[i]=j;
	}
	F(i,1,n) add(next[i],i);
	rd(m);
	F(i,1,m){rd(x[i]);rd(y[i]);add2(x[i],y[i],i);add2(y[i],x[i],i);}
	tarjan(0);
	F(i,1,m) printf("%d\n",(ans[i]==x[i]||ans[i]==y[i])?next[ans[i]]:ans[i]);
	return 0;
}
```


---

## 作者：_虹_ (赞：19)

[几年不更新一次的博客](https://www.luogu.com.cn/blog/RainbowCat/)

**前排Orz出题人和扶苏爷。**

完全没听说过border树这个东西。。。。。

但是我们可以发现，border的定义和我们做kmp时所求的fail数组基本一致。

一个显然的结论是，对于A<--fail--B<--fail--C，A与C显然能也形成border。

根据这个传递性，我们就可以在fail数组上倍增，二分最靠右的交汇点编号，让两个点倍增去跳即可，O(nlog^2n)。

回忆树上倍增lca，这里之所以要二分的原因就是没法把两个点提到同一高度（这里相当于以编号作为高度，因此每个点高度都不同）。

模仿树上倍增的套路，按照fail链长度给每个点设置一下高度，树上倍增即可。时间复杂度O(nlogn)，即O(能过)。

要注意的是因为border不能是整个串，所以两个点必须都跳至少一次。

~~（不知道这个是不是border树）~~

不过本题并没必要显式的连边建一颗树出来。

```cpp
#include <cstring>
#include <algorithm>
#include <cstdio>
using namespace std;
const int kmaxlog=25;
const int kmaxn=1000000+5;
const int ml=21;
int fail[kmaxn];
int fa[kmaxn][kmaxlog];
int dis[kmaxn];
char s[kmaxn];
int n,q;
void init()
{
	int p=0;
	for(int i=2;i<=n;++i)
	{
		while(p&&s[p+1]!=s[i])
			p=fail[p];
		if(s[p+1]==s[i])++p;
		fail[i]=p;
		dis[i]=dis[p]+1;
		fa[i][0]=p;
	}
	for(int k=1;k<=ml;++k)
	{
		for(int i=1;i<=n;++i)
			fa[i][k]=fa[fa[i][k-1]][k-1];
	}
}
int jmp(int x,int h)
{
	if(dis[x]<=h)return x;
	for(int i=ml;i>=0;--i)
	{
		if(dis[fa[x][i]]>h)
			x=fa[x][i];
	}
	return fa[x][0];
}
int lca(int x,int y)
{
	if(dis[x]<dis[y])swap(x,y);
	x=jmp(x,dis[y]);
	for(int i=ml;i>=0;--i)
	{
		if(fa[x][i]!=fa[y][i])
		{
			x=fa[x][i];
			y=fa[y][i];
		}
	}
	return fa[x][0];
}
int a,b;
int main()
{
	scanf("%s%d",&s[1],&q);
	n=strlen(s+1);
	init();
	while(q--)
	{
		scanf("%d%d",&a,&b);
		printf("%d\n",lca(a,b));
	}
	return 0;
}
```

刚看到题时候傻了以为hash就能搞，还看错了题，日常丢人。

---

## 作者：苏联小渣 (赞：16)

~~写于 2022 七夕第二天，如果失配了，没关系，写写失配树，一发 AC 解千愁！~~

## 前置知识

### Border

对于一个字符串的 $s$，其 Border 定义为既是 $s$ 的前缀又是 $s$ 的后缀的子串。如对于字符串 `abcababc`，其 Border 就是 `abc`。对于 Border 有如下性质：

**性质 $1$**：对于字符串 $s$ 的 Border $x,y$，若 $|x| < |y|$ 则 $x$ 是 $y$ 的 Border。

**性质 $2$**：若 $s[1,n]$ 的 Border 长度为 $x$，则 $s[1,n-1]$ 的 Border 长度为 $x-1$。

根据性质 $1$，我们可以得到如下结论：

**结论 $1$**：找到 $s$ 的所有 Border 的方法是，首先找到 $s$ 的最长 Border $B(s)$，再找到 $B(s)$ 的最长 Border $B(B(s))$，如此查找下去，直到找不到为止。


### KMP 字符串匹配

根据性质 $2$ 我们可以得出找字符串 $s$ 最长 Border 的方法，这里不再赘述，如果不会可以去看 [P3375 【模板】KMP字符串匹配](https://www.luogu.com.cn/problem/P3375)（这个是前置知识）

### 树上倍增求 LCA

[P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)

下面默认大家都会了 Border 的定义性质及 KMP 与 LCA。

---

## 失配树

容易发现失配树就是以上几个板子拼接起来的。

考虑对于字符串 `abaabaaba`，现在我们要求出其所有 Border。

首先其最长 Border 为 `abaaba`，`abaaba` 的最长 Border 为 `aba`，`aba` 的最长 Border 为 `a`，`a` 没有 Border，至此结束。

我们发现上面的所有 Border 组成了一个链式结构：$\texttt{abaaba} \to \texttt{aba} \to \texttt{a}$，其中 $\to$ 右边所有字符串是 $\to$ 左边所有字符串的 Border。

容易发现我们可以把一个字符串所有子串 $s[1,i]$（也就是 $s$ 的所有前缀，题面中的 $p,q$ 满足该要求）的所有 Border 放到一棵树中，其中满足从根节点到任意结点所组成的一条链上，对于一个结点 $x$ 表示的前缀子串，所有满足 $\text{dep}(x')<\text{dep}(x)$ 的 $x'$ 表示的前缀子串都是 $x$ 的 Border。

具体我们举一个例子来说明：

以样例 $1$ 为例，对于字符串 `aaaabbabbaa`，其 $nxt$ 数组（就是 KMP 中出现的那个，$nxt_i$ 表示 $s[1,i]$ 的最长 Border 长度）的值分别为 $\{0, 1, 2, 3, 0, 0, 1, 0, 0, 1, 2\}$。对于 $nxt$ 数组，我们可以发现：

- 若 $nxt_i=nxt_j$，则 $i,j$ 的 Border 相同。

- $s[1,i]$ 的最长 Border 的最长 Border 就是 $s[1,nxt_i]$ 的最长 Border。

所以我们从后往前枚举，如果一个点没有被访问过就用一个 while 循环来建边，方案如下：

- 对于 $p \in [1,n]$，若 $nxt_p$ 未被访问过，就建一条边 $(nxt_p,p)$，再令 $p \gets nxt_p$，不断循环，直到 $p$ 被访问过或 $p=0$ 为止。

对于样例，我们画个图来表示这棵树：

![](https://cdn.luogu.com.cn/upload/image_hosting/7bexf4a3.png)

对照样例手玩一遍就会发现对于从根节点开始的一条链上的任一结点 $x$，在同一条链上且深度比其小的点 $x'$，$s[1,x']$ 都是 $s[1,x]$ 的 Border。

失配树还有一个性质，就是在从根结点到 $x$ 结点的链上，所有满足 $\text{dep}(x')<\text{dep}(x)$ 的 $x'$ 都有 $x'<x$。

所以我们预处理出 $nxt$ 数组后再从后往前遍历建立出这颗树（好吧就叫它失配树），但此时我们应如何求出前缀 $p,q$ 的最长公共 Border 呢？

根据上面的内容~~不厌其烦地再重复一遍~~对于一个点 $x$，其所有 Border 就是从 $x$ 的父亲到根节点组成的点集，其中任意一点 $x' \ne 0,s[1,x']$ 都是 $s[1,x]$ 的 Border。

两个呢？就是两条链的公共部分。

最长呢？结点编号尽量大，就是深度尽量深。

合在一起呢？就是两个点的**最近公共祖先**。

所以，我们在建好的失配树上进行树上倍增求 LCA 即可。

注意，若求出来的 LCA 是 $p,q$ 的其中一个，那就要输出 LCA 的父亲，因为我们规定了一个字符串的 Border 不能是它本身。

其实树是可以不用建的，因为我们只关注一个点的父亲；但为了更直观我还是把树建了出来。

以上就是这个叫做失配树的东西，个人感觉它作为模板貌似没啥用，但确实是一道练习字符串和树相结合的好题。

### Code：

```c++
#include <bits/stdc++.h>
using namespace std;
char s[1000010];
int t, p, x, y, n, kmp[1000010], vis[1000010], h[1000010], dep[1000010], f[1000010][23];
struct node{
	int x, y, next;
}d[4000010];
void add(int x, int y){
	d[++p].y = y, d[p].next = h[x], h[x] = p;
}
void dfs(int x, int fa){
	dep[x] = dep[fa] + 1;
	for (int i=0; i<=20; i++){
		f[x][i+1] = f[f[x][i]][i];
	}
	for (int i=h[x]; i; i=d[i].next){
		int y = d[i].y;
		if (y == fa) continue;
		f[y][0] = x;
		dfs(y, x);
	}
}
int LCA(int x, int y){
	if (dep[x] < dep[y]) swap(x, y);
	for (int i=21; i>=0; i--){
		if (dep[f[x][i]] >= dep[y]) x = f[x][i];
		if (x == y) return x;
	}
	for (int i=21; i>=0; i--){
		if (f[x][i] != f[y][i]){
			x = f[x][i], y = f[y][i];
		}
	}
	return f[x][0];
}
int main(){
	scanf ("%s", s+1);
	n = strlen(s+1);
	for (int i=2, j=0; i<=n; i++){
		while (j && s[i] != s[j+1]) j = kmp[j];
		if (s[i] == s[j+1]) j ++;
		kmp[i] = j;
	}
	for (int i=1; i<=n; i++){
		printf ("%d ", kmp[i]);
	}
	for (int i=n; i>=1; i--){
		if (!vis[i]){
			vis[i] = 1;
			int tmp = i;
			while (1){
				if (!tmp) break;
				add(tmp, kmp[tmp]);
				add(kmp[tmp], tmp);
				tmp = kmp[tmp];
				if (vis[tmp]) break;
				vis[tmp] = 1;
			}
		}
	}
	dfs(0, n+1);
	scanf ("%d", &t);
	while (t --){
		scanf ("%d%d", &x, &y);
		int lca = LCA(x, y);
		if (lca == x || lca == y) lca = f[lca][0];
		printf ("%d\n", lca);
	}
	return 0;
}
//求一个字符串所有 border：nxt[nxt[nxt...]] 对此建树即可 
```

---

## 作者：一扶苏一 (赞：16)

# 【字符串】【P5830】 【模板】失配树

## Description

给定一个长度为 $n$ 的字符串 $S$，有 $m$ 次询问，每次询问给定 $S$ 的两个前缀，求它们的最长公共 ``border`` 的长度。

最长公共 ``border`` 的含义为，对于一个字符串 $T$，设其 ``Border`` 集合为所有既是 $S$ 的前缀子串又是 $S$ 的后缀子串的集合，两个字符串的最长公共 ``border`` 为两个字符串的 ``Border`` 集合的交集中长度最长的字符串。

## Limitations

$1 \leq n \leq 10^6$

$1 \leq m \leq 10^5$

## Solution

**注意，这篇题解不是这个模板的标准做法，也不是最简单的做法。**

~~两个前缀的最长公共 border 即为他们在 border 树上的 LCA~~

因为刚起床就被 ``fa姐姐`` 拉来验题，脑袋昏昏忘记了这个结论，只能再口胡一个铁憨憨做法。

注意到所求的 ``border`` 一定既是第一个字符串的后缀，又是第二个字符串的后缀，因此一定是两个字符串的公共后缀 ，同时注意到由于这两个字符串的前缀是相同的，所以如果一个字符串 $T$ 既是其中任意一个串的 ``border``，又是两个串的公共后缀，那么它一定是两个串的公共 ``border``。并且这个条件显然也是必要条件，因此我们在求出两串的 ``lcp`` 以后只需要在其中任意一个串上找到其最长的长度不超过 ``lcp`` 长度的 ``border``，那么该串即为两串的最长公共 ``border``。

假设我们已经求出了两串的 ``lcp`` 长度，那么问题就只剩下对一个字符串求其最长的长度不超过某数的 ``border``。

我们考虑对每个前缀，将它向它的最长 ``border`` 连一条边，那么显然这个图有 $(n + 1)$ 个节点， $n$ 条边，又因为这个图是联通的，根据树的判定定理，这个图是一棵树，若规定 $0$ 是这棵树的根，数学归纳可得每个节点的父节点为该节点所代表的前缀的最长 ``border``。因为一个节点的 ``border`` 显然比该节点的长度小，所以任何一个节点到根所在的链上，若将节点按深度从小到大排列，则其所代表的前缀长度一定是单调递增的。因此我们只需要对整棵树进行 ``dfs``，同时用一个栈维护当前节点到根的链，然后在栈里二分即可找到所求的串。

求 ``border`` 的方法见 [【P3375】KMP字符串匹配](https://www.luogu.com.cn/problem/P3375)。

而求两个前缀的 ``lcp``，可以对原串建立一个 ``SAM``，两个前缀在 ``parent`` 树上所对应节点的 ``LCA`` 即为他们的 ``lcp``。也可以将原串反过来，转化为求两个后缀的最长公共前缀，求出 ``SA`` 后用 ``height`` 数组解决。

但是扶苏既不愿意将原串反过来求 ``SA`` 在写个 ``ST``，也担心毒瘤出题人卡了空间以后 ``SAM`` 建出来会爆空间，因此扶苏选择了 二分+hash 求出其 ``lcp``。

显然公共后缀的长度满足二分性，因此只要选择一个满足前缀可减性的 ``hash`` 函数就可以 $O(1)$ check 了。

考虑时间复杂度：二分求 ``lcp`` 的复杂度是 $O(m \log n)$，在 ``border`` 树上二分的复杂度是 $O(m \log n)$，因此总时间复杂度  $O(n + m \log n)$。

## Code

本来扶苏写了个四模数 ``hash``，然后被卡常了就尝试减少模数个数，最后发现单模数就可以了（雾

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>

const int maxh = 4;
const int maxm = 100005;
const int maxn = 1000005;

const int MOD[] = {998244353, 1000000007, 1000000009, 1145141};

int n, m, top = -1;
char S[maxn];
int border[maxn], ans[maxm], stk[maxn];
std::vector<int> son[maxn], query[maxn];

struct HASH {
  int md;
  ll hash[maxn], inv[maxn];

  ll mpow(const int a, int d, const int p) {
    ll ret = 1, tmp = a;
    while (d) {
      if (d & 1) {
        (ret *= tmp) %= p;
      }
      (tmp *= tmp) %= p;
      d >>= 1;
    }
    return ret;
  }

  void build(const int x) {
    md = x;
    ll tmp = 1, iv = mpow(100, x - 2, x);
    inv[0] = 1;
    for (int i = 1; i <= n; ++i) {
      hash[i] = (hash[i - 1] + (S[i] - 'a') * tmp) % md;
      inv[i] = inv[i - 1] * iv % md;
      (tmp *= 100) %= md;
    }
  }

  bool check(const int x, const int y, const int len) {
    ll h1 = (hash[x] - hash[x - len]) * inv[x - len] % md, h2 = (hash[y] - hash[y - len]) * inv[y - len] % md;
    if (h1 < 0) h1 += md;
    if (h2 < 0) h2 += md;
    if (h1 != h2) {
      return false;
    } else {
      return true;
    }
  }
};
HASH h[maxh];

int ReadStr(char *p);
void dfs(const int u);

int main() {
  freopen("1.in", "r", stdin);
  n = ReadStr(S);
  for (int i = 0; i < maxh; ++i) {
    h[i].build(MOD[i]);
  }
  for (int i = 2, j = 0; i <= n; ++i) {
    while (j && (S[j + 1] != S[i])) {
      j = border[j];
    }
    if (S[j + 1] == S[i]) {
      ++j;
    }
    son[border[i] = j].push_back(i);
  }
  son[0].push_back(1);
  qr(m);
  for (int p, q, Ans, i = 1; i <= m; ++i) {
    p = q = Ans = 0; qr(p); qr(q);
    for (int l = 1, r = std::min(p, q) - 1, mid = (l + r) >> 1; l <= r; mid = (l + r) >> 1) {
      bool flag = true;
      for (int i = 0; i < maxh; ++i) if ((flag = h[i].check(p, q, mid)) == false) {
        break;
      }
      if (flag) {
        l = (Ans = mid) + 1;
      } else {
        r = mid - 1;
      }
    }
    ans[i] = Ans;
    query[std::min(p, q)].push_back(i);
  }
  dfs(0);
  for (int i = 1; i <= m; ++i) {
    qw(ans[i], '\n', true);
  }
  return 0;
}

int ReadStr(char *p) {
  auto beg = p;
  do *(++p) = IPT::GetChar(); while ((*p >= 'a') && (*p <= 'z'));
  *p = 0;
  return p - beg - 1;
}

void dfs(const int u) {
  stk[++top] = u;
  for (auto v : query[u]) {
    int w = ans[v]; ans[v] = 0;
    for (int l = 1, r = top, mid = (l + r) >> 1; l <= r; mid = (l + r) >> 1) if (stk[mid] <= w) {
      ans[v] = stk[mid];
      l = mid + 1;
    } else {
      r = mid - 1;
    }
  }
  for (auto v : son[u]) {
    dfs(v);
  }
  --top;
}

```





---

## 作者：Tweetuzki (赞：13)

注意到 $\operatorname{border}$ 满足几个性质：

- $\bold{Border}(s)$ 中所有元素的都小于 $\lvert s \rvert$。
- $\bold{Border}(s)$ 中任意一个元素的 $\operatorname{border}$ 都是 $\bold{Border}(s)$ 的一个子集。
- 若我们设 $f_s$ 为 $\bold{Border}(s)$ 中最大的元素，那么有递推式 $\bold{Border}(s) = \bold{Border}(s[1 \ldots f_s]) \bigcup \{ f_s \}$。

$f_s$ 其实就是失配指针，可以用一次 kmp 来求。

这些性质理解起来挺显然的，大概就是 $f_s$ 作为 $s$ 的 $\operatorname{border}$，在前缀和后缀都出现一次。而 $\bold{Border}([1 \ldots f_s])$ 是 $f_s$ 在前缀出现时，$f_s$ 的后缀与前缀相同的那些位置，然后这个后缀可以联系到 $s$ 的后缀那个 $f_s$ 来，于是就把 $s$ 的后缀和 $f_s$ 的前缀（也是 $s$ 的前缀）建立了联系，即为 $s$ 其他的 $\operatorname{border}$。

根据第一条和第三条，我们可以建一棵树，使得 $i$ 号点在树上的父亲为 $f_{s[1 \ldots i]}$。这样一来，对于每个后缀，它的 $\operatorname{border}$ 集合内所有点就是它的所有祖先。

得到树以后，求 $\boldsymbol{p}$ 前缀和 $\boldsymbol{q}$ 前缀的最长公共 $\operatorname{border}$ 就是 $p$ 与 $q$ 在树上的最近公共祖先。倍增或其他方法维护即可。

特别地，如果最近公共祖先与 $p$ 或 $q$ 重合，要再往上跳一格，因为自己不是自己的 $\operatorname{border}$。

复杂度 $\mathcal{O}\left((\lvert s \rvert + m) \log \lvert s \rvert \right)$。

```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>

const int MaxN = 1000000 + 5, MaxM = 100000 + 5;
const int MaxLog = 20;

int N, M;
char S[MaxN];
int Fail[MaxN];
int Fa[MaxLog + 1][MaxN], Dep[MaxN];

void init() {
  scanf("%s", S + 1);
  N = strlen(S + 1);
  scanf("%d", &M);
}

inline int getLca(int u, int v) {
  if (Dep[u] < Dep[v]) std::swap(u, v);
  int d = Dep[u] - Dep[v];
  for (int i = MaxLog; i >= 0; --i)
    if (d & (1 << i)) u = Fa[i][u];
  if (u == v) return u;
  for (int i = MaxLog; i >= 0; --i)
    if (Fa[i][u] != Fa[i][v]) {
      u = Fa[i][u];
      v = Fa[i][v];
    }
  return Fa[0][u];
}

void solve() {
  for (int i = 2, j = 0; i <= N; ++i) {
    while (j > 0 && S[i] != S[j + 1]) j = Fail[j];
    if (S[i] == S[j + 1]) j++;
    Fail[i] = j;
  }
  for (int u = 1; u <= N; ++u) {
    Fa[0][u] = Fail[u];
    Dep[u] = Dep[Fail[u]] + 1;
    for (int i = 1; (1 << i) <= Dep[u]; ++i)
      Fa[i][u] = Fa[i - 1][Fa[i - 1][u]];
  }
  for (int q = 1; q <= M; ++q) {
    int x, y;
    scanf("%d %d", &x, &y);
    int l = getLca(x, y);
    if (l == x || l == y) printf("%d\n", Fa[0][l]);
    else printf("%d\n", l);
  }
}

int main() {
  init();
  solve();
  return 0;
}
```

---

## 作者：木木！ (赞：10)

作为目前最优解 ~~只有九个通过啊喂~~，提供一下我的做法。

首先，看到 border，很容易想到 KMP。然后就写了个 `min(nxt[a],nxt[b])`，拿到了 16pts。因为如果一个前缀有 border 长度为 3，它不一定有 border 长度为 2。

解决方法类似这样子：

```
while(a!=b)
{
    while(a>b)
    {
        a = nxt[a];
    }
    while(b>a)
    {
        b = nxt[b];
    }
}
```

很显然这样干会 T 飞。因为 KMP 的时间复杂度是均摊证明的，这样做很容易被卡到 $\Theta(nm)$。

有一种做法是，将 `nxt[i]` 作为 `i` 的父节点，建立一颗树，然后在树上求 `LCA`，时间复杂度为 ST 表 LCA $\Theta(n\log n+m)$ 或树链剖分 $\Theta(n+m\log n)$。

但是，这里提供一个不一样的做法。

观察到一个字符串 `s` 的循环节长度即为 `n-nxt[n]`，即 `s` 是由有限（可能为 1）次重复的 `n-nxt[n]` 再加上几个剩余字符组成的，对于字符串的每一个前缀，都有此性质。

然后可以根据循环节长度进行分类讨论。具体细节可能还是代码比较清晰。

每次循环都至少让 i,j 中某一个数至少折半，时间复杂度 $\Theta(n+m\log n)$。

附 AC 代码：

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

char str[1000005];
int nxt[1000005];

void buildnxt(int n)
{
	for(int i=2; i<=n; ++i)
	{
		int j = nxt[i-1];

		while(j && str[j+1]!=str[i])
		{
			j = nxt[j];
		}

		if(str[j+1] == str[i])
		{
			nxt[i] = j+1;
		}
	}
}

int bordering(int i,int j)
{
	while(i != j)
	{
		if(!i || !j)
		{
			return 0;
		}

		const int loopi = i-nxt[i];
		const int loopj = j-nxt[j];

		if(loopi == loopj)  // 循环节长度相同
		{
			if(i%loopi == j%loopj) // 之后余下来的一段也相同
			{
				return min(i/loopi,j/loopj)*loopi + i%loopi;
			}
			else
			{
				i = i%loopi ? i%loopi : loopi; // 这里判断是为了防止过早地跳到 0
				j = j%loopj ? j%loopj : loopj;
			}
		}
		else
		{
			if(loopi > loopj)  // 这里必须要跳较大的，防止其中一个串为另一个串的循环节
			{
				i %= loopi;
			}
			else
			{
				j %= loopj;
			}
		}
	}
	return i;
}

int main()
{
	scanf("%s",str+1);

	buildnxt(strlen(str+1));

	int m;
	scanf("%d",&m);
	for(int i=1; i<=m; ++i)
	{
		int a,b;
		scanf("%d%d",&a,&b);
		printf("%d\n",bordering(nxt[a],nxt[b]));
	}
}
```

---

## 作者：KAMIYA_KINA (赞：8)

## Tag
字符串，最近公共祖先。

## Description

给定一个字符串 $S$，一共 $m$ 次询问，每一次询问字符串 $S$ 的前缀 $p$ 与前缀 $q$ 的最长公共 border。
$\texttt{data range:} |S| \leq 10^6, m \leq 10^5$.


## Solution

有一个非常显然的结论，就是**一个字符串的 border 一定包含了比其短的所有该字符串的 border**。

对于找出一个字符串的 border 我们有非常优秀的 KMP 算法可以做到线性的时间复杂度求出一个单字符串的所有前缀的最长 border。

由于我们要求最长公共 border，所以直观的感受一下将失配指针看成当前点的父亲节点，然后形成的一颗树就是整个字符串的失配树，我们要做的就是查询两个点的最近公共祖先就可以了。

还有一个性质就是所有点的父亲节点一定小于当前节点，所以我们无需建树，可以线性的预处理，$O(\lg n)$ 的查询两个节点的最近公共祖先，用树剖即可。

## Code

```cpp
constexpr int N = 1e6 + 10;

char s[N];

int fa[N], son[N], top[N], sz[N], dep[N];
int lca(int x, int y) {
    while(top[x] ^ top[y]) {
        if(dep[top[x]] < dep[top[y]]) swap(x, y);
        x = fa[top[x]];
    }
    return dep[x] < dep[y] ? x : y;
}

void solve() {
    scanf("%s", s + 1);
    int n = strlen(s + 1);
    for(int i = 2, j = 0; i <= n; i++) {
        while(j && s[j + 1] != s[i]) j = fa[j];
        if(s[i] == s[j + 1]) j++;
        fa[i] = j;
    }// KMP 过程
    ROF(i, n, 1) {
        sz[i]++;
        if(fa[i]) sz[fa[i]] += sz[i];
        if(sz[i] >= sz[son[fa[i]]]) son[fa[i]] = i;
    }
    FOR(i, 1, n) {
        dep[i] = dep[fa[i]] + 1;
        if(son[fa[i]] != i) top[i] = i;
        else top[i] = top[fa[i]];
    }// 树剖预处理
    int q = rd;
    while(q--) {
        int x = fa[rd], y = fa[rd];
        cout << lca(x, y) << '\n';
    }
    return ;
}
```

## Final

树剖的常数大概是倍增 lca 常数的 $\frac 23$ 左右，而且预处理的时间和空间复杂度都是线性的，非常优秀，开了 O2 之后是最优解第一面除了一帮子写取模跳父亲的人之外的最快的了。

细节：由于一个前缀的 border 不能是他自己，所以一定要先往自己的父亲跳一下。

~~安利：希望大家多写树剖 lca 不要写倍增 lca，阿里嘎多。~~

---

## 作者：EnofTaiPeople (赞：6)

首先一个道理：Border 的 Border 是 Border，且最长 Border 的 最长 Border 是次长 Border。很明显，Border 的关系是一棵树，两点的最长公共 Border 是他们的 LCA。

求所有前缀的最长 Border 可以使用 Z 算法，LCA 可以使用实现简单的 Link-Cut-Tree。

需要注意的一个坑点是：Border 不能是自己，所以当 LCA 是两数之一时，要再往上跳一格，代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+6;
char buf[N+5],*p1,*p2,c;
#define gc (p1==p2&&(p2=(p1=buf)+fread(buf,1,N,stdin),p1==p2)?EOF:*p1++)
inline void read(int &x){
	for(c=gc;c<'0'||c>'9';c=gc);
	for(x=0;c>='0'&&c<='9';x=x*10+c-'0',c=gc);
}
char st[N];
int z[N],n,Q,f[N],q[N],t[N][2],yf[N];
#define Tp(x) (t[f[x]][1]==x)
#define In(x) (t[f[x]][0]==x||Tp(x))
inline void rot(int x){
	int y=f[x],z=f[y],k=Tp(x),w=t[x][!k];
	if(t[t[x][!k]=y][k]=w)f[w]=y;
	if(In(y))t[z][Tp(y)]=x;f[f[y]=x]=z;
}
inline int Access(int x){
	int y,F;for(y=0;x;x=f[y=x]){
		for(F=f[x];In(x);rot(x),F=f[x])
			if(In(F))rot(Tp(x)^Tp(F)?x:F);t[x][1]=y;
	}return y;
}
int main(){
	while(!isalpha(c=gc));int i,l=1,r=0,ml=1;
	for(st[++n]=c;isalpha(c=gc);st[++n]=c);
	for(f[1]=n+1,i=2;i<=n;++i){
		if(i<ml+z[ml])if(z[i-ml+1]<ml+z[ml]-i)z[i]=z[i-ml+1];
						else z[i]=ml+z[ml]-i;
		while(st[i+z[i]]==st[z[i]+1])++z[i];
		q[++r]=i;if(i+z[i]>=ml+z[ml])ml=i;
		while(l<=r&&q[l]+z[q[l]]<=i)++l;
		yf[i]=f[i]=l<=r?i-q[l]+1:n+1;
	}read(Q);
	while(Q--){
		read(l),read(r),Access(l),ml=Access(r);
		if(ml==l||ml==r)ml=yf[ml];
		printf("%d\n",ml==n+1?0:ml),fflush(stdout);
	}
	return 0;
}
```

---

## 作者：xiezheyuan (赞：4)

[也许有更好的阅读体验](https://www.cnblogs.com/zheyuanxie/p/fail-tree.html)

## 简介

失配树（简称 Fail 树），是基于 KMP 的算法，可以高效的解决复杂的字符串前缀后缀关系问题。

前置知识：

- KMP 算法（求失配数组）
- 最近公共祖先（LCA）

希望大家看完这篇文章后可以理解失配树。

## 引入

先来看一道题（校内模拟题·改）

> 给你一个字符串 $S$，你需要从它的非空前缀集合 $\operatorname{Pre}$ 中选择一些字符串组成一个集合 $Q$，使得集合 $Q$ 中任意两个字符串 $A,B$，$A$ 不是 $B$ 的后缀。求极大的集合 $Q$，输出 $Q$ 中的所有字符串（可能有多组合法答案，输出其中任意一组）。
>
> $2 \leq |S| \leq 10^{6}$

一个朴素的思路是，对于 $\operatorname{Pre}$ 中的字符串，翻转后插入一个字典树中。最后找字典树的所有叶子节点即可。不难证明，这个算法是正确的。

可是这个算法是 $O(n^2)$的。无法通过本题。究其原因，是因为字典树中存在许多多余元素。比如字符串 `abcdabghiab`，建出来的字典树……

如何解决呢？我们可以考虑，跳过中间的多余元素。如何跳过？也就是说如何从 $\operatorname{border}$ 指向包含它的字符串？当然是 $\operatorname{KMP}$ 中的失配数组！于是我们自然的想到连边 $(\operatorname{nxt}_i,i)$。然后找叶子。复杂度降到了 $O(n)$。

## P5829 【模板】失配树

> 给定一个字符串 $s$，
有 $m$ 组询问，每组询问给定 $p,q$，求 $s$ 的 **$\boldsymbol{p}$ 前缀** 和 **$\boldsymbol{q}$ 前缀** 的 **最长公共 $\operatorname{border}$**  的长度。
>
> $1\leq p,q \le |s|\leq 10^6$，$1 \leq m \leq 10^5$，$s_i \in [\texttt{a}, \texttt{z}]$

先建出失配树，对于第一个样例，失配树如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/n5moeip5.png)

然后发现，最长公共前缀不就是在失配树上的最近公共祖先吗？

注意：

- 如果 $\operatorname{LCA}(p,q) \in \{p,q\}$，那么答案其实是 $\operatorname{father}(\operatorname{LCA}(p,q))$。
- 如果你使用的是树剖求 LCA，那么记住不能以 $0$ 为根。

## 参考代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 1000005;

struct edge {
	int nxt, to;
} g[N << 1];
int head[N << 1], ec;
void add(int u, int v) {
	g[++ec].nxt = head[u];
	g[ec].to = v;
	head[u] = ec;
}

int root;
int siz[N], son[N], fa[N], top[N], dep[N];
void dfs1(int u, int father, int deep) {
	dep[u] = deep;
	siz[u] = 1;
	fa[u] = father;
	for (int i = head[u]; i >= 0; i = g[i].nxt) {
		int v = g[i].to;
		dfs1(v, u, deep + 1);
		siz[u] += siz[u];
		if (siz[v] >= siz[son[u]]) {
			son[u] = v;
		}
	}
}

void dfs2(int u, int father, int t) {
	top[u] = t;
	if (son[u])dfs2(son[u], u, t);
	for (int i = head[u]; i >= 0; i = g[i].nxt) {
		int v = g[i].to;
		if (v == son[u]) {
			continue;
		}
		dfs2(v, u, v);
	}
}

int lca(int x, int y) {
	int fx = top[x], fy = top[y];
	while (fx != fy) {
		if (dep[fx] < dep[fy]){
			swap(fx, fy);
			swap(x, y);
		}
		x = fa[fx], fx = top[x];
	}
	if (dep[x] > dep[y]) {
		return y;
	}
	else return x;
}

namespace KMP{
    int nxt[1000005];
    char s[1000005];
    int n;
    void kmp(){
        n = strlen(s+1);
        add(n+1,1);
        for(int i=2,j=0;i<=n;i++){
            while(j&&s[i]!=s[j+1]){
                j=nxt[j];
            }
            if(s[i]==s[j+1]){
                j++;
            }
            nxt[i]=j;
            if(j!=0){
                add(j,i);
            }
            else{
                add(n+1,i);
            }
        }
    }
}

int m;

signed main(){
    memset(head,-1,sizeof(head));
    ec=-1;
    cin>>(KMP::s+1)>>m;
    KMP::kmp();
    dfs1(KMP::n+1,0,1);
    dfs2(KMP::n+1,0,KMP::n+1);
    while(m--){
        int p,q;
        cin>>p>>q;
        int LCA = lca(p,q);
        if(LCA == p || LCA == q){
            LCA = fa[LCA];
        }
        if(LCA==(KMP::n+1))LCA=0;
        cout<<LCA<<'\n';
    }
    return 0;
}
```

[AC Record](https://www.luogu.com.cn/record/88848010)

---

## 作者：Leap_Frog (赞：3)

### P.S.
感觉这个东西看上去挺好理解的，自己稍微看了下题解，就乱搞搞出来了。  
这里说一下自己对这个东西的理解。  
前置知识：KMP，LCA

### Description.
$\text{pre}_i=S[1:i],\text{suf}_i=S[|S|-i+1:|S|]$  
$\text{Border}(s)=\{\text{pre}_i|i\in[1,|S|)\land \text{pre}_i=\text{suf}_i\}$  
$F(i,j)=\max\{\text{len}_x|x\in\text{Border}(\text{pre}_i)\land x\in\text{Border}(\text{pre}_j)\}$  
多组询问，给定 $i$ 和 $j$，求 $F(i,j)$。  

### Solution.
设 $\text{MaxBorder}$ 表示所有 $\text{Border}$ 中长度最大值。
- 定理：$\text{Border}(s)=\text{MaxBorder}(s)\bigcup\text{Border}(\text{MaxBorder}(s))$  
证明如下（其实直接画图就好了  
	- $\text{Border}(s)\subseteq\text{MaxBorder}(s)\bigcup\text{Border}(\text{MaxBorder}(s))$  
    设 $n=\text{len}_s,m=\text{len}_{\text{MaxBorder}(s)},m_x=\text{len}_{\text{Border}(s)},m_x\neq m$  
    那么我们有 $s[1:m]=s[n-m+1:n],s[1:m_x]=s[n-m_x+1:n]$  
    所以我们有 $s[m-m_x+1:m]=s[n-m_x+1:n]=s[1:m_x]$  
    所以 $m_x$ 对应的 $\text{Border}(s)\in\text{MaxBorder}(s)$  
    $\therefore \text{Border}(s)\subseteq\text{MaxBorder}(s)\bigcup\text{Border}(\text{MaxBorder}(s))$
    - $\text{Border}(s)\supseteq\text{MaxBorder}(s)\bigcup\text{Border}(\text{MaxBorder}(s))$  
    首先，肯定有 $\text{Border}(s)\supseteq\text{MaxBorder}(s)$  
    设 $n=\text{len}_s,m=\text{len}_{\text{MaxBorder}(s)},m_x=\text{len}_{\text{Border}(\text{MaxBorder}(s))}$  
    那么有 $s[1:m]=s[n-m+1:n],s[1:m_x]=s[m-m_x+1:m]$  
    所以有 $s[n-m_x+1:n]=s[m-m_x+1:m]=s[1:m_x]$  
    $\therefore\text{Border}(\text{MaxBorder}(s))\subseteq\text{Border}(s)$  
- 定理证必（草，$\LaTeX$ 杀人。

那么我们得到一个串的所有 $\text{Border}$ 都可以通过跳 $\text{MaxBorder}$ 来得到。  
我们设一个串的父亲为它的 $\text{MaxBorder}$，那么一个串的所有 $\text{Border}$ 就是它的所有祖先。  
所以两个串的最长公共 $\text{Border}$ 是它们的 $\text{LCA}$ （一些**特殊情况**先不管。  
于是我们建出那棵树，然后直接倍增求 $\text{LCA}$ 就好了（树剖显然也可以。  

特殊情况：一个串的 $\text{Border}$ 是它的严格祖先。  
所以如果互为祖先关系的两个串的 $\text{Border}$ 必须是它的父亲，而不是 $\text{LCA}$。  
而 $\text{MaxBorder}$ 可以用 KMP 求出。  

如果还看不懂可以参考代码注释。

### Coding.
```cpp
//愿你和你重要的人能够再次重逢！
#include<bits/stdc++.h>
using namespace std;typedef long long ll;
template<typename T>inline void read(T &x)
{
	x=0;char c=getchar(),f=0;
	for(;c<48||c>59;c=getchar()) if(!(c^45)) f=1;
	for(;c>=48&&c<=57;c=getchar()) x=(x<<1)+(x<<3)+(c^48);
	f?x=-x:0;
}
int Q,dep[1000005],nxt[1000005][20],n;char c[1000005];
inline int LCA(int x,int y)
{
	if(dep[x]<dep[y]) swap(x,y);
	for(int i=19;~i;i--) if(dep[nxt[x][i]]>=dep[y]) x=nxt[x][i];
	for(int i=19;~i;i--) if(nxt[x][i]!=nxt[y][i]) x=nxt[x][i],y=nxt[y][i];
	return nxt[x][0];
}
int main()
{
	scanf("%s",c+1),n=strlen(c+1),read(Q),nxt[1][0]=dep[1]=0;
	for(int i=2,k=0;i<=n;i++)//KMP
	{
		while(k&&c[k+1]!=c[i]) k=nxt[k][0];//而这个树中肯定有一个拓扑序是 [1,n]
		if(c[k+1]==c[i]) dep[i]=dep[nxt[i][0]=++k]+1;else dep[i]=dep[nxt[i][0]=k]+1;
	}
	//for(int i=1;i<=n;i++) printf("%d%c",dep[i],i==n?'\n':' ');
	for(int i=1;i<20;i++) for(int j=1;j<=n;j++) nxt[j][i]=nxt[nxt[j][i-1]][i-1];
	for(int x,y;Q--;) read(x),read(y),printf("%d\n",LCA(x,y));//倍增 LCA
	return 0;
}
```

---

## 作者：Acerkaio (赞：1)

想失配？来发[【模板】失配树](https://www.luogu.com.cn/problem/P5829)

## 0x0001 思路：


我们可以发现一个事实，一个字符串的 `border` 的 `border` 也是这个字符串的 `border`

题目要求 $s$ 长度为 $p$ 的前缀 和长度为 $q$ 前缀的最长公共 `border` 的长度，那么可知，如果两个前缀都有 `border` 那么可能包含着一个 `border`，是两个前缀的 `border`，也是他们 `border` 的 `border`，诶，怎么这么耳熟，这不是找最近公共祖先吗。


那么是个人都知道了，我们先把这一个串找一遍 `border`，也就是跑 `KMP` 算法，这样就把任意前缀长度的 `border` 找出来，把其与其 `border` 建边，跑一遍最近公共祖先就好了。

## 0x0002 CODE：

```cpp
#include <bits/stdc++.h>


using namespace std;
inline int read() {
	int x=0,f=1;
	char ch=getchar();
	while (ch<'0'||ch>'9') {
		if (ch=='-') f=-1;
		ch=getchar();
	}
	while (ch>='0'&&ch<='9') {
		x=x*10+ch-48;
		ch=getchar();
	}
	return x*f;
}
inline void write(int x) {
	if(x < 0)putchar('-'),x = -x;
	if(x > 9)write(x / 10);
	putchar(x % 10 ^ 48);
}
struct Node {
	int next, y;
} f[1919810];
int tot, head[1000001];
inline void add(int x, int y) {
	f[++tot].y = y;
	f[tot].next = head[x];
	head[x] = tot;
}
int n = NULL, m, p, q;
int d[1000010], dp[1000010][22], border[1000010];
inline int lca(int x, int y) {
	if (d[x] < d[y])
		swap(x, y);
	for (int i = log2(n) + 1; i >= 0; i--)
		if (d[x] - (1 << i) >= d[y])
			x = dp[x][i];

	if (x == y) 
		return x;

	for (int i = log2(n) + 1; i >= 0; i--) 
		if(dp[x][i] == dp[y][i]) continue;
		else x = dp[x][i], y = dp[y][i];
		
	return dp[x][0];
}
signed main() {
	string s;
	cin >> s;
	n = s.size();
	s = " " + s;
	int j = 0;
	for (int i = 2;  i <= n; i++) {
		while (s[j + 1] != s[i] && j) j = border[j];
		if (s[j + 1] == s[i]) j++;
		border[i] = j;
		dp[i][0] = j; d[i] = d[j] + 1;
	}
	for (int i = 1; i <= log2(1e6) + 1; i++) {
		for (int j = 1; j <= n; j++) {
			dp[j][i] = dp[dp[j][i - 1]][i - 1];
		}
	}
	cin >> m;
	while (m--) {
		cin >> p >> q;
		cout << lca(dp[p][0], dp[q][0]) << '\n';
	}
	return 0;
}
```

---

## 作者：raincity (赞：1)

[更好的阅读体验](https://blog.calvincheng1231.org.cn/default/44.html)

## 分析
首先 KMP 求 $fail$。

则有 $\bold{Border}(s_1s_2\ldots s_i)=fail_i\bigcup\bold{Border}(s_1s_2\ldots s_{fail_i})$。

建立一棵树，使得 $fa_i=fail_i$，那么 $\bold{Border}(s_1s_2\ldots s_i)$ 就是这棵树上 $i$ 的所有祖先（不包括自己）。

查询 $p$ 前缀和 $q$ 前缀，就是查找这棵树上 $fa_p$ 和 $fa_q$ 的 LCA。

这棵树就是**失配树**。

## 解决
这里倍增貌似比较好写，因为可以直接知道 $fa_i$。

其他题解没有提到的一点：

其他题解里面求的是 $p$ 和 $q$ 的 LCA，而不是 $fa_p$ 和 $fa_q$ 的 LCA。但是 $x \not \in \bold{Border}(s_1s_2\ldots s_x)$，所以需要稍微修改倍增找 LCA 的。其他题解说是 “正常的倍增求 LCA”，其实是不对的。

正常的倍增求 LCA 中，要在将 $x$ 和 $y$ 跳到同一层之后判断 $x$ 和 $y$ 是否相等，如果相等就返回 $x$，但是在本题中不应该判，因为如果 $x=y$，说明 $x$ 是 $y$ 的祖先或者 $y$ 是 $x$ 的祖先，，所以仍然应该返回 $fa_x$。
 
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>

using namespace std;

const int N = 1e6 + 5, Log = 20;
int n, m, fail[N], dep[N], fa[N][Log];
char ch[N];

void getFail() {
	fail[1] = 0;
	for (int i = 2, j = 0; i <= n; i++) {
        while (j > 0 && ch[i] != ch[j + 1]) j = fail[j];
        if (ch[i] == ch[j + 1])
            j++;
        fail[i] = j;
    }
}

void prework() {
	getFail();
	for (int i = 1; i <= n; i++) {
		dep[i] = dep[fail[i]] + 1, fa[i][0] = fail[i];
		for (int j = 1; j < Log; j++) fa[i][j] = fa[fa[i][j - 1]][j - 1];
	}
}

int lca(int x, int y) {
	if (dep[x] < dep[y])
		x ^= y ^= x ^= y;
	for (int i = Log - 1; i >= 0; i--)
		if (dep[fa[x][i]] >= dep[y])
			x = fa[x][i];
	for (int i = Log - 1; i >= 0; i--)
		if (fa[x][i] != fa[y][i])
			x = fa[x][i], y = fa[y][i];
	return fa[x][0];
}

void read(int &ret) {
	ret = 0;
	char ch = getchar();
	while (ch < '0' || ch > '9') ch = getchar();
	while (ch >= '0' && ch <= '9') ret = ret * 10 + ch - '0', ch = getchar();
}

int main() {
	scanf("%s", ch + 1);
	n = strlen(ch + 1);
	prework();
	read(m);
	while (m--) {
		int x, y;
		read(x), read(y);
		printf("%d\n", lca(x, y));
	}
	return 0;
}

```

---

## 作者：A_Pikachu (赞：1)

### [题目传送门](https://www.luogu.com.cn/problem/P5829)
（如果 $\LaTeX$ 炸了，请到博客[观看](https://www.luogu.com.cn/blog/thats-me/ti-jie-p5829-mu-ban-shi-pei-shu-post)）

$\Large\mathscr{Part\,\,0\;\;}\text{前置知识}$

[$\color{#00ffff}\text{简单のKMP}$](https://www.luogu.com.cn/problem/P3375)

[$\color{#00ffff}\text{简单のLCA}$](https://www.luogu.com.cn/problem/P3379)

**以下内容默认读者已掌握前置知识**

$\Large\mathscr{Part\,\,1\;\;}\text{基本思路}$

注意到 $KMP$ 中的 $next[\ |s|\ ]$ 表示的正好是 $\textbf{Border}(s)$ 中最长元素的长度，而且 $\textbf{Border}(s)$ 中的每一个元素的 $\rm{border}$ 均是 $\textbf{Border}(s)$ 的子集，并且具有传递性。所以可以考虑建一棵有根树 $T$，将 $KMP$ 中的 $next$ 数组替换为 $fa$ 数组，$fa[\ |s|\ ]$ 意为 $s$ 在 $T$ 中的父亲节点，特别地，对于 $\forall next[\ |s|\ ]=0$，$fa[\ |s|\ ]=\varnothing$。则 $s$ 的 **$p$ 前缀** 和 **$q$ 前缀** 在 $T$ 上的 $LCA$ 即为它们的最长公共 $\rm{border}$。

~~证明起来也很容易~~

首先，根据我们的定义，可知对于字符串 $s$ 的前缀， $|\ fa[\ |s|\ ]\ |<|s|$。现在设对于 $s$ 的 **$p$ 前缀** 和 **$q$ 前缀** $s_p$ 和 $s_q$ 在 $T$ 上的 $LCA$ 为 $s_i$。由于 $s_i$ 在之前 $next$ 数组的定义下同时为 $s_p$ 和 $s_q$ 的前后缀，而 $s_i$ 的祖先的长度均小于 $s_i$；同时为 $s_p$ 和 $s_q$ 的前后缀且长度大于 $s_i$ 的字符串定为 $s_i$ 的后代，但这与 $s_i$ 是 $s_p$ 和 $s_q$ 的 $LCA$ 矛盾。所以 $s_i$ 即为 $s$ 的 **$p$ 前缀** 和 **$q$ 前缀** 的最长公共 $\rm{border}$。特别地，如果 $s_i=s_p$ 或 $s_i=s_q$，因为一个字符串的前后缀不包含本身，所以此时要再往上跳一个父亲节点。最终，$|s_i|$ 即为所求答案。

$\Large\mathscr{Part\,\,2\;\;}\text{Code}$

~~其实就是一个二合一~~

```cpp
#include <cstdio>
#include <cstring>
const int N=1e6+5,Log=22;
char b[N]; // 原串
int T,m,fa[Log][N],dep[N],q,w,l;
int lca(int x,int y){ // 正常の倍增LCA
	if(dep[x]>dep[y]) x^=y^=x^=y;
	for(int i=Log-1; ~i; i--) if(dep[fa[i][y]]>=dep[x]) y=fa[i][y];
	if(x==y) return fa[0][x]; // 注意，若两个子串的LCA为其中一个子串，返回的是深度低的子串的父亲
	for(int i=Log-1; ~i; i--){
		if(fa[i][x]!=fa[i][y]){
			x=fa[i][x];
			y=fa[i][y];
		}
	}
	return fa[0][x];
}
int main(){
	scanf("%s%d",b+1,&T);
	m=strlen(b+1);
	int j=0;
	dep[1]=1; // 预处理
	for(int i=2; i<=m; i++){ // 正常のKMP
		while(j&&b[i]!=b[j+1]) j=fa[0][j];
		if(b[i]==b[j+1]) ++j;
		dep[i]=dep[fa[0][i]=j]+1;
		for(int k=1; k<Log; k++){ // 预处理fa数组
			fa[k][i]=fa[k-1][fa[k-1][i]];
		}
	}
	while(T--){ // 直接处理
		scanf("%d%d",&q,&w);
		printf("%d\n",lca(q,w));
	}
	return 0;
}
```

时间复杂度 $\Theta(\ (|s|+m)\cdot \log_2|s|\ )$，过这题[$\color{black}\small\text{绰绰有余}$](https://www.luogu.com.cn/record/34286933)。

---

## 作者：Anaxagoras (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P5829)

### 0x01 前置知识

[KMP](https://oi.wiki/string/kmp/)

[LCA](https://oi.wiki/graph/lca/)

### 0x02 思路

对于一个学过 $\operatorname{KMP}$ 的人来说，看到 $\operatorname{border}$ 就会想到用失配数组（以下叫做 $next$）实现，因为 ~~看名字和题目这么像肯定要~~ $next$ 求的就是 $\operatorname{border}$，但是 $\Theta(\min(p,q))$ 枚举求最长公共 $\operatorname{border}$ 是不行的，这里就要用到失配树。

最长的 $\operatorname{border}$ 就是 $next(\left|S\right|)$，而一个串往往不止一个 $\operatorname{border}$，$next(next(\left|S\right|))$ 也可以证明是原串的 $\operatorname{border}$，以此类推，$next(next(next(\left|S\right|))),next(next(next(next(\left|S\right|))))\dots$ 都是原串的 $\operatorname{border}$。那么，我们可以将 $i$ 与 $next(i)$ 建边。如图，我们以样例一为例（0 为根）：

![样例 1](https://pic.imgdb.cn/item/6393d9c5b1fccdcd36f548c5.png)



这样，一个节点的祖先都是以这个节点结尾的子串的  $\operatorname{border}$，所以 $p$ 与 $q$ 的 $\operatorname{LCA}$ 就是答案（注意，如果 $p$ 是 $q$ 的祖先，或 $q$ 是 $p$ 的祖先，那么祖先的父亲才是答案，因为一个串的 $\operatorname{border}$ 不能是自己本身）。

### 0x03 AC Code

```cpp
//by olkieler 
#include <bits/stdc++.h>
#define int long long
#define N 1000005
#define M 1005
#define mod 998244353
#define ios ios::sync_with_stdio(0);cin.tie(0)
#define test cout << "ASDF\n"
#define inf INT_MAX
#define linf LLONG_MAX
#define pint pair<int, int>
#define mp make_pair
using namespace std;
int fa[N][25];
int depth[N];
string st;
inline int LCA(int x,int y)
{
    if (depth[x] < depth[y])
    {
        swap(x, y);
    }
    while (depth[x] > depth[y])
    {
        x = fa[x][(int)log2(depth[x]-depth[y])];
    }
    if (x == y)
    {
        return fa[x][0];
    }
    for (int i = log2(depth[x]); ~i; i--)
    {
        if (fa[x][i] != fa[y][i])
        {
            x = fa[x][i];
            y = fa[y][i];
        }
    }
    if (fa[x][0] == x || fa[x][0] == y)
    {
    	x = fa[x][0];
    }
    return fa[x][0];
}
signed main()
{
	ios;
	int m, len, j = 0;
	cin >> st >> m;
	len = st.size();
	st = " " + st;
	for (int i = 2; i <= len; i ++)
	{
		while (j > 0 && st[j + 1] != st[i])
		{
			j = fa[j][0];
		}
		if (st[j + 1] == st[i])
		{
			j ++;
		}
		fa[i][0] = j;
		depth[i] = depth[j] + 1;
	}
	for (int i = 1; i <= 20; i ++)
	{
		for (int j = 1; j <= len; j ++)
		{
			fa[j][i] = fa[fa[j][i - 1]][i - 1];
		}
	}
	for (int asdf = 1; asdf <= m; asdf ++)
	{
		int p, q;
		cin >> p >> q;
		cout << LCA(p, q) << '\n';
	}
	return 0;
}
```

---

## 作者：glorious_dream (赞：0)

### 题目大意：

给定一个串 $S$，定义 $border$ 为它的非本身的既是它的前缀又是它的后缀的字符串，每次询问 $i$，$j$ 求出前 $i$ 个和前 $j$ 个字符的最长公共 $border$ 长度。

### 算法分析：

根据题目的描述，会发现这道题本质上是 $KMP$，求出每一个点的前缀和后缀匹配的长度，设为 $kmp$ 数组。然后就是这道题的精髓。

这里需要建一个失配树，也就是每一个点的 $kmp$ 数组向这个点连一条边。(个人感觉跟 $AC$ 自动机的 $fail$ 树有异曲同工之妙。)这时会发现，会建成一个树，父亲节点就是 $kmp$ 数组的值，儿子节点就是该点。

最后，题目的要求相当于求两个点的 $LCA$，用倍增求即可。

注意细节，如果这两个点本身就有 $border$ 关系，那么需要输出 $dep$ 小的点的父亲节点。也很好实现，把倍增中的中途 $x=y$ 返回删去，直接最后返回即可。

具体细节看代码吧。

### 总代码：

```cpp
#include<bits/stdc++.h>
#define re register
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch == '-') f=-1 ; ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48) ; ch=getchar();}
	return x*f;
}
inline void print(int x){
	if(x/10) print(x/10);
	putchar(x%10+'0');
}
const int M = 2e6+10;
char s[M];
int head[M],dep[M],f[M][21],kmp[M];
int cnt,ans,m,len;
struct edge{
	int to,nxt;
}e[M];
void add(int u,int v){ //加边
	e[++cnt].to = v;
	e[cnt].nxt = head[u];
	head[u] = cnt;
}
void pre(){ //kmp匹配
	int j=0;
	for(re int i(2) ; i<=len ; ++i){
		while(j && s[i]!=s[j+1]) j=kmp[j];
		if(s[i] == s[j+1]) j++;
		kmp[i] = j;
	}
}
void dfs(int u){
	for(re int i(head[u]) ; i ; i=e[i].nxt){
		int v = e[i].to;
		dep[v] = dep[u]+1; //该节点的深度是它父节点的深度+1
		f[v][0] = u; //该节点的父亲是u
		for(re int i(1) ; i<=20 ; ++i) f[v][i] = f[f[v][i-1]][i-1];
      //求倍增数组
		dfs(v); //往下dfs
	}
}
void work(){
	for(re int i(1) ; i<=len ; ++i) add(kmp[i],i); //建失配树
	dfs(0); //别忘了从0开始dfs
}
int lca(int x,int y){ //常规求lca
	if(dep[x]<dep[y]) swap(x,y);
	for(re int i(20) ; i>=0 ; --i) if(dep[f[x][i]]>=dep[y]) x=f[x][i];
	for(re int i(20) ; i>=0 ; --i) if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];
	return f[x][0];
}
signed main(){
	scanf("%s",s+1);
	m=read();
	len = strlen(s+1);
	pre();
	work();
	while(m--){
		int x=read(),y=read(); //每次询问即可
		printf("%d\n",lca(x,y));
	}
	return 0;
}

```


---

## 作者：jijidawang (赞：0)

Border 论入门题 .

我要宣传博客！！！[Border Theory](https://www.cnblogs.com/CDOI-24374/p/16009595.html) .
***

> **Definition 1**（maxBorder）
> 
> 一个字符串 $s$ 的最长 Border 为 $\operatorname{maxBorder}(s)$ .

***

> **Lemma 1**（Border 的传递性）
>
> 若 $s_0$ 是 $s_1$ 的 Border，$s_2$ 是 $s_1$ 的 Border，则 $s_2$ 是 $s_0$ 的 Border .

证明显然 .

然后因为 **Lemma 1**，一个前缀的 Border 一定也是一个前缀，于是


> **Definition 2**（fail 指针）
>
> 一个字符串 $s$ 的一个前缀的的最长 Border 的下标，记作 $fail_i$ .


于是一个东西的 Border 关系就可以表示为一棵树（可以叫 fail 树或者 Border 树） .

对于一个字符串 $s$ 的所有前缀 $t=\operatorname{pre}(s,i)$，连接有向边 $t\to fail_t$，于是我们对于一个前缀不断跳 $fail$ 就可以找到它的所有 Border（也就是说 $t$ 的所有祖先都是 $t$ 的 Border）

然后显然深度越深字符串长度越长，这可以通过 Border 的定义得到 .

于是两个前缀的最长公共 Border 就是它们对应 fail 树上的 LCA 了！

注意因为知道 Border 不是自己，所以如果 LCA 找到一个原有的字符串那么就要跳一次父亲 .

代码：
```cpp
// 因为是拿俩板子拼起来的，可能比较丑
// 话说树剖跑得真的慢（

#include <bits/stdc++.h>
using namespace std;
const int N = 1e6 + 500;
typedef long long ll;
typedef char str[N];
int n, m, r;
int fa[N], dep[N], siz[N], son[N], top[N], dfn[N], rnk[N], cc;
vector<int> g[N];
inline void addedge(int u, int v){g[u].emplace_back(v);}
inline void ade(int u, int v){addedge(u, v); addedge(v, u);}
void dfs1(int u)
{
	siz[u] = 1;
	for (auto v : g[u])
	{
		if (fa[u] == v) continue;
		dep[v] = dep[u] + 1;
		fa[v] = u;
		dfs1(v);
		siz[u] += siz[v];
		if (!son[u]|| (siz[v] > siz[son[u]])) son[u] = v;
	}
}
void dfs2(int u, int t)
{
	top[u] = t;
	rnk[++cc] = u; dfn[u] = cc;
	if (!son[u]) return ;
	dfs2(son[u], t);
	for (auto v : g[u])
		if ((v != son[u]) && (v != fa[u])) dfs2(v, v);
}
int lca(int u, int v)
{
	while (top[u] != top[v])
	{
		if (dep[top[u]] > dep[top[v]]) u = fa[top[u]];
		else v = fa[top[v]];
	}
	return dep[u] > dep[v] ? v : u;
}
str s;
int l, nxt[N];
void getnxt()
{
	nxt[1] = 0; int j = 0;
	for (int i=2; i<=l; i++)
	{
		while (j && (s[i] != s[j+1])) j = nxt[j];
		if (s[i] == s[j+1]) ++j;
		nxt[i] = j;
	}
}
int main()
{
    scanf("%s", s+1); l = strlen(s+1);
    getnxt();
	for (int i=1; i<=l; i++) ade(i, nxt[i]);
    scanf("%d", &m);
	dfs1(r); dfs2(r, r);
	int u, v;
	while (m--)
	{
		scanf("%d%d", &u, &v);
		int x = lca(u, v);
		if ((x == u) || (x == v)) printf("%d\n", fa[x]);
		else printf("%d\n", x);
	} return 0;
}
```

---

## 作者：peterwuyihong (赞：0)

题意：给定一个字符串，进行若干次询问两个前缀的最长公共 $\text{border}$ 长度。

把每个位置的 $\pi$ 连到这个点，根节点是 $0$，$\pi=0$ 就表示没有 $\text{border}$，也没有什么关系，然后注意到每组询问中的答案必然是 $\{x,\pi_x,\pi_{\pi_x}\ldots,y,\pi_y,\pi_{\pi_y}\ldots\}$，然后本质就是对两个节点做一下最近公共祖先就行了。

注意到如果公共祖先就是其中一个的话，还要往前跳一步来满足需要。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define rep(i,j,k) for(int i=j;i<=(k);i++)
signed main(){
  ios::sync_with_stdio(NULL);
  string s;
  cin>>s;
  int n=s.size();
  vector<int>pi(n);
  vector<int>top(n+1),dep(n+1),fa(n+1),siz(n+1),son(n+1,-1);
  vector<vector<int> >g(n+1);
  rep(i,1,n-1){
    int j=pi[i-1];
    while(j&&s[i]!=s[j])j=pi[j-1];
    if(s[i]==s[j])j++;
    pi[i]=j;
  }
  rep(i,1,n)g[pi[i-1]].push_back(i);
  function<void(int)>dfs1=[&](int x){
    siz[x]=1;
    for(int y:g[x]){
      dep[y]=dep[x]+1;
      fa[y]=x;
      dfs1(y);
      siz[x]+=siz[y];
      if(son[x]==-1||siz[son[x]]<siz[y])son[x]=y;
    }
  };
  function<void(int,int)>dfs2=[&](int x,int t){
    top[x]=t;
    if(son[x]==-1)return;	
    dfs2(son[x],t);
    for(int y:g[x])
    if(y!=son[x])dfs2(y,y);
  };
  dfs1(0);dfs2(0,0);
  int m;
  cin>>m;
  auto lca=[&](int x,int y){
    while(top[x]!=top[y]){
      if(dep[top[x]]<dep[top[y]])swap(x,y);
      x=fa[top[x]];
    }
    if(dep[x]>dep[y])swap(x,y);
    return x;
  };
  while(m--){
    int x,y;
    cin>>x>>y;
    int u=lca(x,y);
    if(u==x||u==y)u=fa[u];
    cout<<u<<endl;
  }
}
```

---

## 作者：lgswdn_SA (赞：0)

字符串 $s$ 的 **border** $i$ 满足 $s$ 的长 $i$ 的前后缀相等。我们设 $s$ 的 $\text{max border}$ 表示 $\text{border}$ 集合中最大（长）的一个。显然，$\text{max border}$ 即 KMP 中的 $\text{next}$。（因为 KMP 的第一部分就是一个自我匹配寻找 $\text{border}$ 的过程）。

如何求出 $\text{border}$ 集合？我们有性质 $\text{border}(s)=\text{border}(s[1,next_s]) \cup next_s$。这样，我们不断地跳 $next$ 就能求出一个串的 $\text{border}$。

有没有办法求出所有前缀的 $\text{border}$ 呢？显然是可以的。由于一个前缀的 $\text{border}$ 依赖于这个前缀的一个前缀的 $\text{border}$，我们可以建立一种树的关系。考虑 $next_i$ 作为 $i$ 在这样的树上的父亲节点（感觉是不是可以叫 border tree），那么前缀 $s[1,i]$ 的 $\text{border}$ 集合就为点 $i$ 的所有祖先节点。

题目要求两个前缀的最长公共 $\text{border}$，显然这个最长公共 $\text{border}$ 就是它们两个前缀在这棵树上的除去自己的 LCA。

```cpp
int n,m,nxt[N],d[N],f[N][29];
char s[N];
vector<int>e[N];

void kmp(int j=0) {
	e[0].push_back(1);
	rep(i,2,n) {
		while(j&&s[i]!=s[j+1]) j=nxt[j];
		if(s[j+1]==s[i]) j++;
		nxt[i]=j, e[j].push_back(i);
	}
}
void dfs(int u) {
	rep(h,1,20) f[u][h]=f[f[u][h-1]][h-1];
	for(auto v:e[u]) {
		d[v]=d[u]+1, f[v][0]=u;
		dfs(v);
	}
}
int lca(int u,int v) {
	if(d[u]<d[v]) swap(u,v);
	per(h,20,0) if(d[f[u][h]]>=d[v]) u=f[u][h];
	per(h,20,0) if(f[u][h]!=f[v][h]) u=f[u][h], v=f[v][h];
	return f[u][0];
}

int main() {
	scanf("%s",s+1); n=strlen(s+1), m=read();
	kmp();
	d[0]=1; dfs(0);
	rep(i,1,m) {
		int p=read(), q=read();
		printf("%d\n",lca(p,q));
	}
	return 0;
}
```

---


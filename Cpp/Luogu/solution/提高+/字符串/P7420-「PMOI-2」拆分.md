# 「PMOI-2」拆分

## 题目背景

### 如果您不看样例解释中的提示，那么您极可能做不出来！

![](https://cdn.luogu.com.cn/upload/image_hosting/n87yncfw.png)

## 题目描述

lhm 手中有一个字符串 $a$ 和它的子串 $b$，现你需要拆分字符串 $a$。

设 $c(s,b)$ 表示从字符串 $s$ 中选出一些互不重叠的、与 $b$ 相同的子串的最大子串数量。

若将 $a$ 拆分为 $k$ 组，第 $i$ 组记为 $p_i$，你需要保证：
- $k \geq 2$，
- $c(p_{i+1},b)>c(p_i,b)\ (i \in[1,k-1])$，
- $c(p_1,b)\geq 1$。

两种拆分方案不同当且仅当拆分出的组数不等或 $\exist i$，对应的 $c(p_i,b)$ 不等。

求不同的拆分方案总数，答案对 $899678209$ 取模。

## 说明/提示

【样例解释】

拆分的方式分别为：

`noi noinonoi noiionoinoinoionoi`，个数分别为 $1,2,5$。

`noi noinonoin oiionoinoinoionoi`，个数分别为 $1,2,4$。

`noino inonoinoiion oinoinoionoi`，个数分别为 $1,2,3$。

`noi noinonoinoi ionoinoinoionoi`，个数分别为 $1,3,4$。

`noi noinonoinoiionoinoinoionoi`，个数分别为 $1,7$。

`noinoi nonoinoiionoinoinoionoi`，个数分别为 $2,6$。

`noinoinonoi noiionoinoinoionoi`，个数分别为 $3,5$。

`noin oinonoinoiionoinoinoionoi`，个数分别为 $1,6$。

`noinoinono inoiionoinoinoionoi`，个数分别为 $2,5$。

`noinoinonoin oiionoinoinoionoi`，个数分别为 $3,4$。

**提示：样例解释足以说明可以拆分子串**。

【数据规模与约定】

请仔细阅读本栏。

**本题采用捆绑测试。**  

设 $n = c(a,b)$，$|a|=l_1$，$|b|=l_2$。  

| Subtask | 特殊性质 | 空间限制 | 分值 | 
| :----------: | :----------: | :----------: | :----------: |
| 1 | $l_1\leq 30$ | 256MiB | 9 |
| 2 | $n \le 300$ | 256MiB | 11 |
| 3 | $n \le 2000$ | 256MiB | 17 |
| 4 | $n \le 25000$ | 256MiB | 37 |
| 5 | 无 | 64MiB | 26 |

对于 $100\%$ 的数据，$0\le n\le2\times10^5$，$2\le l_2\le l_1\le10^6$，$b_1 \neq b_{l_2}$，$a$ 和 $b$ 只包含小写字母。

## 样例 #1

### 输入

```
noinoinonoinoiionoinoinoionoi
noi```

### 输出

```
10```

# 题解

## 作者：TianTian2008 (赞：9)

无需多项式，直接转换一下题意然后 dp 即可。

首先可以发现拆分和字符串具体内容无关，只和 $n$ 也就是 $c(a,b)$ 有关。

第一反应是求元素总和等于 $n$ 的上升序列的数量，但观察一下样例就知道这是假的。

为什么呢？看样例，$n=8$ 却可以拆分成 $\text{noi(1)noinonoin(2)oiionoinoinoionoi(4)}$ 总和为 $7$ 的上升序列。观察发现，这时第二段多拿了一个 $\text n$，导致一个原本会产生贡献的 $\text{noi}$ 被拆开而没有产生贡献。

具体地，一个长为 $k$ 的上升序列元素总和是 $[n-k+1,n]$ 都是合法，因为每次拆出一个新段时都可能拆开一个 $b$ 串使贡献少 $1$。

然后就很简单了，设 $f_{i,j}$ 表示长为 $i$ 元素总和为 $j$ 的上升序列的个数，显然有 $f_{i,j}=f_{i-1,j-i}+f_{i,j-i}$。

元素总和为 $n$ 的上升序列长度是 $O(\sqrt n)$ 级别的，因此 dp 的时间复杂度为 $O(n\sqrt n)$

注意会卡内存，滚动数组优化一下。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#define bas 917
#define mod 899678209
using namespace std;
typedef long long ll;
ll n,m,n1,n2,h1[1000010],h2,f[2][200010],ans;
char str[1000010];
int main() {
	scanf("%s",str+1);
	n1=strlen(str+1);
	for(int i=1;i<=n1;++i) h1[i]=(h1[i-1]*bas+str[i]-'a'+1)%mod;
	scanf("%s",str+1);
	n2=strlen(str+1);
	ll pw=1;
	for(int i=1;i<=n2;++i) {
		h2=(h2*bas+str[i]-'a'+1)%mod;
		pw=pw*bas%mod;
	}
	for(int i=n2;i<=n1;++i)
		if(((h1[i]-h1[i-n2]*pw)%mod+mod)%mod==h2) {
			++n;
			i+=n2-1;
		}
	ll l=1,r=n,mid;
	while(l<=r) {
		mid=l+r>>1;
		if((mid*(mid+1)>>1)<=n) {
			m=mid;
			l=mid+1;
		}
		else r=mid-1;
	}
	if((m*(m+1)>>1)<n) ++m;
	f[0][0]=1;
	for(int i=1;i<=m;++i) {
		ll x=i&1,y=x^1;
		for(int j=0;j<=n;++j)
			if(i>j) f[x][j]=0;
			else {
				f[x][j]=f[y][j-i]+f[x][j-i];
				if(f[x][j]>=mod) f[x][j]-=mod;
			}
		if(i==1) continue;
		for(int j=n-i+1;j<=n;++j) {
			ans+=f[x][j];
			if(ans>=mod) ans-=mod;
		}
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：qwaszx (赞：4)

~~把关键限制放数据范围里的出题人事屑~~

字符串的部分就不说了，考虑对于 $n$ 算出题目要求的拆分的方案数. 这就是

$$
\begin{aligned}
&\sum_K \sum_{j=n-K+1}^{n}[t^Kx^j]\prod_{i\geq 1}(1+tx^i)
\\=&\sum_K[t^Kx^n]\frac{1-x^K}{1-x}\prod_{i\geq 1}(1+tx^i)
\\=&\sum_K[t^Kx^n]\frac{1}{1-x}\prod_{i\geq 1}(1+tx^i)-\sum_K[t^Kx^n]\frac{1}{1-x}\prod_{i\geq 1}(1+(tx)x^i)\\
=&[x^n]\frac{x}{1-x}\prod_{i\geq 2}(1+x^i)
\end{aligned}
$$

如果允许做 FFT，那么可以通过取 ln 的方法计算后面的乘积；如果不允许，注意到后面差不多就是个划分数的 OGF，所以可以 $O(n\sqrt{n})$ 计算，不过适用性更广的做法是展开这个无穷乘积. 设

$$
F(x,t)=\prod_{i\geq 0}(1+tx^i)
$$

那么有

$$
F(x,tx)=\prod_{i\geq 0}(1+tx^{i+1})=\frac{1}{1+t}F(x,t)
$$

两边按 $t$ 展开可以得到

$$
[t^n]F(x,t)=\frac{x^{n-1}}{1-x^n}[t^{n-1}]F(x,t)
$$

所以我们得到展开式

$$
F(x,t)=\sum_{i\geq 0}t^ix^{\binom{i}{2}}\prod_{j=1}^i\frac{1}{1-x^j}
$$

注意当 $\binom{i}{2}>n$ 时对答案就没有贡献了，所以只需要计算 $\Theta(\sqrt{n})$ 项，复杂度还是 $\Theta(n\sqrt{n})$

---


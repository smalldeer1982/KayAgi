# [COCI 2015/2016 #2] SAVEZ

## 题目描述

有一个秘密行星 S4 居住着一种奇特的动物，它们的学名是 Loda。Savez 协会派出了一个由 Henrik 将军领导的小组来研究 Loda。Henrik 发现，Loda 有心灵传输的能力，他想在他的军队里雇佣他们。

一只 Loda 由 $N$ 个字符串组成，其中第 $i$ 个字符串记为 $x_i$。研究表明，Loda 能进行的心灵传输次数取决于组成它的字符串的一个特殊子序列（不一定是连续的）。字符串 $x_i$ 和 $x_j\ (i<j)$ 都可以在该子序列中，当且仅当字符串 $x_j$ 以 $x_i$ 开头并以 $x_i$ 结尾。一只 Loda 可以进行的心灵传输次数是组成它的字符串的合法的最长子序列的长度，而你就需要确定它可以进行心灵传输的次数。

## 说明/提示

**【样例 1 解释】**

一个最长的子序列为 `A AA AAA`。

**【样例 3 解释】**

子序列中的字符串允许相等，因此一个最长的子序列为 `A A A` 或 `B B B`。

**【数据范围】**

对于 $100\%$ 的数据，$1\le N \le 2\times 10^6，1\le |x_i| \le 2\times 10^6$，**保证 $\sum |x_i|\le10^6$**。

**【说明】**

**本题数据点得分依原题，满分 120**。

题目译自 [COCI 2015-2016](https://hsin.hr/coci/archive/2015_2016/) [CONTEST #2](https://hsin.hr/coci/archive/2015_2016/contest2_tasks.pdf) **T4 SAVEZ**。

## 样例 #1

### 输入

```
5
A
B
AA
BBB
AAA```

### 输出

```
3```

## 样例 #2

### 输入

```
5
A
ABA
BBB
ABABA
AAAAAB```

### 输出

```
3```

## 样例 #3

### 输入

```
6
A
B
A
B
A
B```

### 输出

```
3```

# 题解

## 作者：ADay (赞：10)

[更逊的阅读体验](https://www.cnblogs.com/aday526/p/solution-p7861.html)


模拟赛原题，赛时一直在肝另一题就没做 ![](//www.aday.fun/kk)

## Solution

求最长子序列的题，显然可以 $\mathsf{dp}$，方程为 $f_i=\max\limits_{j<i}\{f_j\}+1(x_j\,\text{为}\,x_i\,\text{的前缀和后缀})$。

考虑怎么判断一个字符串为另一个字符串的的前缀和后缀。我们有一个很妙的做法：把字符串 $s_{1\cdots n}$ 正反合在一起组成 $n$ 个**字符二元组**，即 $(s_1,s_n)(s_2,s_{n-1})\dots(s_n,s_1)$，那么这样就只用判断 $x_j$ 组成的二元组是否是 $x_i$ 的二元组的前缀就好了。

对于这些二元组，我们可以直接建 $\mathsf{Trie}$，把每个字符串的二元组当成一个字符集为 $26\times26$ 的字符串插入，在插入的过程中如果当前节点是某个字符串的结尾就直接进行 $\mathsf{dp}$，并在插入完时的结点记录此字符串编号即可。

关于实现，由于这棵 $\mathsf{Trie}$ 的每条边有两个字符 `ab`，我们可以把它转化为一个数 `(a-'A')*26+(b-'A')`，并用 $\mathsf{unordered\_map}$ 实现动态开点的子节点列表。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e6+5;
int n,m,ans,tot,f[N],id[N];char s[N];
unordered_map<int,unordered_map<int,int>>g;//Trie
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%s",s+1);m=strlen(s+1);
        int u=0;
        for(int j=1;j<=m;j++){
            f[i]=max(f[i],f[id[u]]+1);
            int w=(s[j]-'A')*26+s[m-j+1]-'A';//正反合并
            if(g[u].find(w)==g[u].end())g[u][w]=++tot;//动态开点
            u=g[u][w];
        }if(id[u])f[i]=max(f[i],f[id[u]]+1);
        ans=max(ans,f[i]);id[u]=i;
    }printf("%d\n",ans);
    return 0;
}
```

最后祝各位 $\texttt{CSP2021 rp++!}$



---

## 作者：DiruiXiao (赞：5)

## P7861 [COCI2015-2016#2] **SAVEZ**

~~大水题，题有难度但数据太水了，直接前后缀判回文串都有116pts~~

**【题意简述】**

给定 $n$ 个字符串组成一个字符串序列，要求选出一组最长的子序列满足任意 $s_j$ 能够作为 $s_i$ 的前缀和后缀。

**【解题思路】**

首先一个很明显的性质，设前 $j$ 中最长子序列的长度为 $l$，若有 $s_i$ 对于 $s_j$ 满足题目中的性质，则 $j$ 处的最长子序列可以从 $i$ 转移而来。

思考如何快速判断有多少对字符串 $(s_i,s_j)$ 满足题目中的性质（$j < i$）。

考虑到类似 `ABA` 和 `ABABA` 的串在判断的时候有大量的重复运算，因此可以使用字典树来优化冗余运算。

但是如果只存储字符串的顺序序列就只能够快速判断前缀是否相同。一个暴力的办法是开两个 `Trie` 树，但是更简单的方式则是开一个二维 `Trie` 同时存储该字符串的顺序位置的字符和倒序位置的字符。但是显然开一个 `Trie[MAXN][26][26]` 会 MLE，于是出现了一种奇妙的操作 --- `map` 中套 `map` 建树。外层 `map` 的 `key` 表示动态节点编号，`value` 的类型是个 `map` 即普通 `trie` 的节点。对于每个节点的字符，考虑头加尾算 `hash` 值维护。

最后在每次 `insert` 一个字符串时，按照对应方式插入，若当前节点已经是之前某个字符串的结尾，就比较 `cnt[x]+1` 和 `ans` 的大小即可（`cnt[x]` 存储了以编号为 $x$ 的节点作为结尾的最长子序列长度）。

**【AC代码】**

```cpp
#include<bits/stdc++.h>
#define MAXN 2000005
using namespace std;
char s[5000050];
unordered_map<int, unordered_map<int, int> > trie;
int cnt[MAXN], tot;
inline int insert(char *str) {
	int len = strlen(str);
	int x = 0, ans = 1;
	for (int j = 0; j < len; ++j) {
		int v = str[j] - 'A', u = str[len - j - 1] - 'A';
		int ch = v * 27 +  u;
		if (trie[x].find(ch) == trie[x].end()) {
			trie[x][ch] = ++tot;
		}
		ans = max(cnt[trie[x][ch]] + 1, ans);
		x = trie[x][ch];
	}
	cnt[x] = max(ans, cnt[x]);
	return ans;
}

int main() {
	int N, ans = 0; scanf("%d", &N);
	for (int i = 1; i <= N; ++i) {
		scanf("%s", s);
		ans = max(ans, insert(s));
	}
	printf("%d\n", ans);
	return 0;
}
```



---

## 作者：if_OF (赞：2)

# 思路

题目中要求我们找出子序列 $x$ 使得 $x$ 最长且满足其中靠后的字符串都以它之前的字符串作为结尾，即下图所示：

![图片](https://cdn.luogu.com.cn/upload/image_hosting/15w7kmgy.png)

我们需要比较字符串的开头和结尾是否相等且在之前出现过，因此我们使用哈希将开头和结尾存起来。

由于我们要的并不是回文串，所以我们需要将开头与结尾的哈希值用不同的方法分别求。

对于在开头的部分：$hash=(hash+hashpow_j\times tr_j)\mod M$，其中 $hashpow_j$ 表示进制数的 $j$ 次方，M为取模的数。

对于在结尾的部分：$hash=(hash\times hashnum+str_j)\mod M$，其中 $hashnum$ 表示进制数，M为取模的数。

接下来，为了确定开头和结尾的字符串在之前有没有出现过，我们用一个 map 存一下每个哈希值对应的最长的序列长度 $dp_{hash}$。然后再取最大的 $dp_{hash}$ 再 $+1$ 就好啦！

我的代码用了双哈希避免哈希碰撞，但实测单哈希也能过。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int hash_code1=114;
const int hash_code2=514;//太臭力！
const int mod=1000000007;
long long hasheachnum1[1000006];
long long hasheachnum2[1000006];
void geth()
{
	hasheachnum1[0]=1;
	hasheachnum2[0]=1;
	for(int i=1;i<1000006;i++)//求hashpow[i]
	{
		hasheachnum1[i]=(hasheachnum1[i-1]*hash_code1)%mod;
		hasheachnum2[i]=(hasheachnum2[i-1]*hash_code2)%mod;
	}
	return;
}
int main()
{
	geth();
    string loda;
	int N,ans=0;
	scanf("%d\n",&N);
	map<pair<int,int>,int> dp;//经过实测，map里面不能塞struct作为下标，所以用pair存双哈希
	for(int i=1;i<=N;i++)
	{
		cin>>loda;
		long long hashx1=0,hashx2=0;//开头的哈希
		long long hashy1=0,hashy2=0;//结尾的哈希
		int l=loda.size(),temp=0;
		for(int j=0;j<l;j++)
		{
			hashx1=(hashx1+hasheachnum1[j]*(int)loda[j])%mod;
			hashx2=(hashx2+hasheachnum2[j]*(int)loda[j])%mod;
			hashy1=(hashy1*hash_code1+(int)loda[l-j-1])%mod;
			hashy2=(hashy2*hash_code2+(int)loda[l-j-1])%mod;
			if(hashx1==hashy1 && hashx2==hashy2 && temp<dp[{hashx1,hashx2}])//如果前后的哈希值相等就更新dp值
				temp=dp[{hashx1,hashx2}];
		}
		dp[{hashx1,hashx2}]=temp+1;
		if(temp>=ans)
			ans=temp+1;
	}
	printf("%d\n",ans);
}
```

---

## 作者：Gmt丶FFF (赞：2)

做这题的心路历程十分神奇。

看到题，想到哈希匹配。

对于每一个 $x_i$ 若可以为 $x_j$ 的前缀和后缀，处理 $x_i$ 的哈希值，求 $x_j$ 的前缀和后缀哈希即可。

然后本机上跑不过，就进行了分裂循环，优化调用 map 次数等等一系列优化。

~~结果发现数据比我想象中的水的多。~~

还是放一下第一次做的代码：[代码](https://www.luogu.com.cn/paste/vbpfyil8)

设 $dp_i$ 代表以第 $i$ 个字符结尾的字序列长度最大值。

然后利用 map 存储之前每个字符串的哈希值，最后如果本次前缀和后缀都能匹配上之前的哈希值，那么可以进行转移。

$dp_i=\max(dp_j+1)\hspace{0.1cm}\text{(初始}\hspace{0.1cm}dp_i=1)$

最后求 $\max(dp_i)$ 即可。

复杂度 $O(\sum_{i=1}^{n}x_i\times\log(n))$。

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<map>
#define int long long
using namespace std;
const int N=2e6+5;
const int mod1=1e15+37;
const int mod2=212370440130137957ll;
map<int,int>vis1,vis2;
int n,dp[N];
char s[N];
inline void read()
{
	int cnt=0;
	char ch=getchar();
	while(ch==' '||ch=='\n')ch=getchar();
	while(ch!=' '&&ch!='\n')
	{
		s[++cnt]=ch;
		ch=getchar();
	}
	s[++cnt]='\0';
}
signed main()
{
	//freopen("savez.in","r",stdin);
	//freopen("savez.out","w",stdout);
	scanf("%lld",&n);
	int ans=0;
	for(int i=1;i<=n;i++)
	{
		scanf("%s",s+1);
		int len=strlen(s+1);
		int num1=0,num2=0,lim1=1,lim2=1;
		int num3=0,num4=0;
		dp[i]=1;
		for(int j=1;j<=len;j++)
		{
			num1=num1+(s[j]-'A'+2)*lim1;
			num1%=mod1;
			num2=num2+(s[j]-'A'+2)*lim2;
			num2%=mod2;
			num3=num3*30+(s[len-j+1]-'A'+2);
			num3%=mod1;
			num4=num4*30+(s[len-j+1]-'A'+2);
			num4%=mod2;
			lim1*=30;
			lim1%=mod1;
			lim2*=30;
			lim2%=mod2;
			int _1=vis1[num1],_2=vis2[num2],_3=vis1[num3],_4=vis2[num4];
			if(_1&&_3&&_1==_2&&_2==_3&&_3==_4)dp[i]=max(dp[i],dp[_1]+1);
		}
		vis1[num1]=i,vis2[num2]=i;
		ans=max(ans,dp[i]);
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：小铭同学lym (赞：2)

## P7861 题解

[题目](https://www.luogu.com.cn/problem/P7861)

题目让我们判断 $s_i$ 是否是 $s_j$ 的开头结尾。首先想到字符串哈希，这样仍然不优美，暴力判断点对是 $O(n^2)$ 的。

如果这个时候卡住了，不妨往其他方面想想。看到前缀，我们自然地想到 Trie。那么这道题就做完一半了。

注意题目求的是 **子序列**，那么这个子序列必定是相邻的两个字符串满足条件。这样想到一个朴素 DP：设 $f_i$ 表示做到 $i$ 的最长长度，那么如果 $j>i$ 并且 $s_i$ 与 $s_j$ 满足条件，就可以 $f_i\to f_j$。具体地，是：
$$
f_j=\max{f_i+1}
$$
 这样不好直接转移是 $O(n^2)$ 的。回到开始的想法，我们为什么不在 Trie 上 DP 呢？回想一下一个字符串插入的过程，如果说我们在插入时，碰到一个 Trie 上的节点，是之前一个字符串的结尾，那么是不是可以字符串哈希 $O(1)$ 判断这个节点对应的字符串是不是上述的 $i$ 了？这样，我们再标记一下每个字符串结尾节点即可。

但是你会发现这道题只有 64MB，卡空间，直接 ```trie[N][26]``` 会 MLE，十分毒瘤。一般地，我们的 Trie 数组是 ```trie[N][26]```。但是啊，显然不会有 $2\times 10^6$ 个节点。于是考虑优化，换成 ```trie[26][N]```，将它看成26个 ```unordered_map``` 即可。至此，这道题做完了。

[code](https://www.luogu.com.cn/paste/uvtw7mdn)

---

## 作者：Cells (赞：1)

## 题意

一般来说我没有描述题意的习惯，但是我这回得描述一下，因为样例会误导人。

给你一些字符串，你需要构造一个序列 $a$，使得序列中的每一对 $i < j$，都有 $a_i < a_j$，且 $x_{a_i}$ 一个字母不落地全部出现在 $x_{a_j}$ 的开头和结尾，求这个序列的最长长度。

## 思路

很明显如果说 $i < j < k$，那么 $x_{a_j}$ 包含在 $x_{a_k}$ 中，因为 $x_{a_i}$ 包含在 $x_{a_j}$ 中，所以 $x_{a_i}$ 必定包含在 $x_{a_k}$ 中。

比较朴素的想法，考虑前面的每个字符串，然后看当前的字符串能不能拼在前面的字符串所在最长序列的后面。这里有个小贪心，为什么是最长的序列，因为既然都是包含关系，必然不会影响后面接上的字符串，所以选择最长的。

但是不对，因为时间复杂度是平方的。

我们继续观察，发现只有当前面一部分和后面一部分相同的时候才后可能匹配上字符串。到这个地方，当前字符串需要自我匹配，还需要匹配前面的字符串，很难不想到哈希。

开一个 `map`，将哈希值映射到对应字符串所在的最长序列的长度，用两个指针从前后开始扫，如果说这个点的哈希值相同，说明当前的字串可能对应一个字符串，然后用对应 `map` 值加一更新当前答案，最后把自己哈希值对应的答案改掉。

代码还是很简单的，时间复杂度 $O(\sum |x_i| \log{n})$，轻松跑到最优解。

## Code

```c++
//# pragma GCC optimize("Ofast")
# include <bits/stdc++.h>
# define fr front
# define il inline
# define fir first
# define sec second
# define vec vector
# define it iterator
# define pb push_back
# define lb lower_bound
# define ub upper_bound
# define all(x) x.begin(), x.end()
# define mem(a, b) memset(a, b, sizeof(a))

# define lc (t[p].l)
# define rc (t[p].r)
# define ls(x) (x << 1)
# define rs(x) (x << 1 | 1)
# define lson ls(p), l, mid
# define rson rs(p), mid + 1, r

# define sqr(x) ((x) * (x))
# define bpc __builtin_popcount
# define lowbit(x) ((x) & (-(x)))
# define geti(x, i) (((x) >> (i)) & 1)
# define set1(x, i) ((x) | (1 << (i)))
# define set0(x, i) ((x) & (~(1 << (i))))

# define debug1(x) cerr << #x << " = " << x << " "
# define debug2(x) cerr << #x << " = " << x << "\n"
# define bug cerr << "--------------------------\n"

# define each1(i, x) for(auto (i) : (x))
# define each2(i, x) for(auto (&i) : (x))
# define rep(i, a, b) for(int i = (a); i <= (b); ++ i)
# define pre(i, a, b) for(int i = (a); i >= (b); -- i)
# define G(i, h, u, ne) for(int i = (h[(u)]); i; i = (ne[(i)]))
# define reps(i, a, b, c) for(int i = (a); i <= (b); i += (c))
# define pres(i, a, b, c) for(int i = (a); i >= (b); i -= (c))
using namespace std;

using DB = double;
using LL = long long;
using LDB = long double;
using PII = pair<int, int>;
using ULL = unsigned long long;

const int N = 2e6 + 10, P = 13331;
const int INF1 = 0x3f3f3f3f, INF2 = INT_MAX;
const LL INF3 = (LL)1e18, INF4 = 0x3f3f3f3f3f3f3f3f, INF5 = LLONG_MAX;

int n, m, mx, ans;
char s[N];

ULL h1, h2, mul[N];

map<ULL, int> mp;//hash值映射到序列长度 

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	cin >> n;
	mul[0] = 1;
	rep(i, 1, N - 10) mul[i] = mul[i - 1] * P;
	
	while(n --){
		cin >> s + 1;
		m = strlen(s + 1);
		int i = 1, j = m;
		mx = 1;
		h1 = h2 = 0;
		while(i <= m){
			h1 = h1 * P + s[i];
			h2 = h2 + mul[m - j] * s[j];
			if(h1 == h2){
				mx = max(mx, mp[h1] + 1);
			}
			
			i ++, j --;
		}
		
//		rep(i, 1, m) cout << s[i];
//		cout << " " << h1 << " " << h2 << "\n";
		mp[h1] = mx;
		ans = max(ans, mx);
	}
	
	cout << ans;
	
	return 0;
}
```

心裡的眼淚模糊了視線，你已快看不見……

---

## 作者：封禁用户 (赞：1)

### Solution
设定两个指针 $p$ 和 $q$，每次推移 $p$ 和 $q$，如果 `s.substr(0, p+1) == s.substr(q)`（可以用 `Hash` 在 $O(1)$ 的时间复杂度内进行判断），就更新答案（用个 `Map` 记录在传输这趟之前已经传输了多少字符串），最后再把 `Map[这个字符串]` 更新一下（答案 $+1$ ）。时间复杂度 $O(\sum x_i)$，足以通过本题。

### Code
```cpp
#include<bits/stdc++.h>
#define Rep(i, n) for(int i=0; i< (int)(n); i++)
#define Rpp(i, n) for(int i=1; i<=(int)(n); i++)
#define For(i, s, e) for(int i=(int)(s); i< (int)(e); i++)
#define Frr(i, s, e) for(int i=(int)(s); i<=(int)(e); i++)
#define Mem0(Cont) memset(Cont, 0, sizeof(Cont))
#define Tc int T; cin >> T; while(T--)
#define Pow 123456789876543217ull
#define Pinf 0x3f3f3f3f3f3f3f3fLL
#define Ninf 0xcfcfcfcfcfcfcfcfLL
#define int long long
#define Mint unsigned long long
//#define Files
using namespace std;
 
int n, res;
map <Mint, int> Map;
 
signed main()
{
#ifdef Files
    freopen(".in", "r", stdin);
    freopen(".out", "w",stdout);
#endif
    ios_base :: sync_with_stdio(0), cin.tie(0), cout.tie(0);
     
    cin >> n; Rpp(i, n)
    {
        string s; cin >> s;
        int Max = 0;
        Mint l=0, r=0, nP=1;
        Rep(j, s.size())
        {
            l = l*Pow + (s[j]-'A'+1); //推移指针，动态算 Hash
            r = (s[(int)s.size()-1-j] - 'A' + 1) * nP + r;
            if(l == r) Max = max(Max, Map[l]); //两边一样，更新答案
            nP *= Pow;
        }
        if(Max+1 > res) res = Max+1; //更新最终答案
        Map[l] = Max+1;
    } cout << res << endl;
     
    return 0;
}
```

---

## 作者：CQ_Bab (赞：0)

# 思路
## 56pts

考虑 Dp，我们设 $f_i$ 为选到了第 $i$ 个串第 $i$ 个必选能选的最多数量，那么转移为 $f_i=\max(f_i,f_j+1)$ 条件为 $s_i$ 的前 $len_j$ 个和后 $len_j$ 个都等于 $s_j$（这个可以用 Hash 判断)，时间复杂度 $O(n^2)$。

## 100pts

注意到 $\sum |s_i|\leq 10^6$ 所以考虑枚举前一个串 $s_j$ 的长度为 $x$ 如果满足 $s_i$ 的前 $x$ 个和后 $x$ 个相等就可以从 Hash 值与 $s_i$ 的前 $x$ 个相等且长度也为 $x$ 的串 $s_j$ 转移过来，那么考虑将状态修改为 $f_i$ 表示整个串的 Hash 值为 $i$ 是能选的最多的数量。所以对于每一个串枚举上一个串的长度 $x$ 如果 $s_i$ 的前 $x$ 个与后 $x$ 个相等，那么将此串能选的最多的数量与 $f_{hash_{i,1,x}}+1$ 取 $\max$，最后再将 $f_{hash_{i,1,len_i}}$ 更新为此串能接的最大值即可，因为 hash 值很大考虑用 map 维护 Dp 即可，时间复杂度 $O(\sum|s_i|\times \log(n))$。
# 代码
```cpp
#include <bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
#include <ext/rope>
using namespace __gnu_pbds;
using namespace std;
#define pb push_back
#define rep(i,x,y) for(register int i=x;i<=y;i++)
#define rep1(i,x,y) for(register int i=x;i>=y;--i)
#define in(x) scanf("%d",&x)
#define fire signed
#define il inline
int T=1;
int n;
const int N=1e6+10;
string se;
int len[N];
struct node{
	vector<int>ha;
}s[N];
int jc[N];
const int mod=998244353,ba=131;
il int has(int i,int j,int x) {
	return (0ll+(s[x].ha[j]-1ll*s[x].ha[i-1]*jc[j-i+1]%mod)%mod+mod)%mod;
}
map<int,int>mp;
void solve() {
	in(n);
	jc[0]=1;
	rep(i,1,1000000) jc[i]=1ll*jc[i-1]*ba%mod;
	rep(i,1,n) {
		cin>>se;
		se=" "+se;
		len[i]=se.size()-1;
		s[i].ha=vector<int>(len[i]+2);
		rep(j,1,len[i]) s[i].ha[j]=(0ll+(1ll*s[i].ha[j-1]*ba%mod+(se[j]-'A'+1))%mod+mod)%mod;
	}
	int ans=false;
	rep(i,1,n) {
		int res=false;
		rep(j,1,len[i]) if(has(1,j,i)==has(len[i]-j+1,len[i],i)) res=max(res,mp[has(1,j,i)]);
		if(res+1>ans) ans=res+1;
		mp[has(1,len[i],i)]=res+1;
	}
	printf("%d\n",ans);
}
fire main() {
	while(T--) {
		solve();
	}
	return false;
}
```

---


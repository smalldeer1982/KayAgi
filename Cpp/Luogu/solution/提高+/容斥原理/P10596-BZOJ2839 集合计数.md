# BZOJ2839 集合计数

## 题目背景

题目来自原 BZOJ，我们承认题面及原数据的版权均属于原 BZOJ 或将题目授权给 BZOJ 使用的出题人。如果您是版权所有者且认为我们侵犯了您的权益，可联系我们。

## 题目描述

一个有 $N$ 个元素的集合有 $2^N$ 个不同子集（包含空集），现在要在这 $2^N$ 个集合中取出若干集合（至少一个），使得它们的交集的元素个数为 $K$，求取法的方案数，答案模 $10^9+7$。

## 说明/提示

**【样例解释】**

假设原集合为 $\{A,B,C\}$，则满足条件的方案为：$\{AB,ABC\}$，$\{AC,ABC\}$，$\{BC,ABC\}$，$\{AB\}$，$\{AC\}$，$\{BC\}$

**【数据范围】**

对于 $100\%$ 的数据，$1\leq N\leq 1000000$，$0\leq K\leq N$。

## 样例 #1

### 输入

```
3 2```

### 输出

```
6```

# 题解

## 作者：wyyqwq (赞：36)

容斥。

考虑从 $n$ 个数里选出 $k$ 个为交的方案数为 $\binom{n}{k}$ ，剩下 $n-k$ 个数，共有 $2^{n-k}$ 个集合，这些集合选出若干个集合的方案数是 $2^{2^{n-k}} - 1$ ，答案为 $\binom{n}{k} 2^{2^{n-k}} - 1$ 。

然后想一想发现，这个东西会算重，因为在 $n-k$ 个数里选会重复，这个式子意义应为交至少为 $k$ ，然后容斥一下，答案即为
$$
\binom{n}{k} \sum_{i=0}^{n} (-1)^{i}\binom{n}{i}2^{2^{n-k}} - 1
$$

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

const int N = 1e6 + 7;
const int mod = 1000000007;
int qpow(int a, int b, int md) {
    int res = 1;
    while(b) {
        if(b & 1) res = res * a % md;
        a = a * a % md;
        b >>= 1;
    }
    return res % md;
}
int fac[N], infac[N];
int getc(int a, int b) {
    // if(a == 0) return b;
    return fac[a] % mod * infac[b] % mod * infac[a - b] % mod;
}
signed main() {
    int n, k;
    cin >> n >> k;
    fac[0] = infac[0] = 1;
    for(int i = 1; i < N; i ++) {
        fac[i] = fac[i - 1] * i % mod;
        infac[i] = qpow(fac[i], mod - 2, mod) % mod;
    }   
    int ans = 0;
    int p = getc(n, k);
    n -= k;
    for(int i = n; i >= 0; i --) {
        if(i % 2 == 0) {
            ans = (ans + getc(n, i) % mod * (qpow(2ll, qpow(2ll, n - i, mod - 1), mod) - 1) % mod) % mod;
        }
        else {
            ans = (ans - getc(n, i) % mod * (qpow(2ll, qpow(2ll, n - i, mod - 1), mod) - 1) % mod + mod) % mod;
        }
        ans %= mod;
    }
    cout << (ans * p + mod) % mod << endl;
}  
```

---

## 作者：2huk (赞：34)

> 选自 [容斥原理 & 二项式反演](https://www.cnblogs.com/2huk/p/18169274)。

## 2 二项式反演

### 2.1 反演

对于两个数列 $g(x), f(x)$ 而言，若它们之间存在某种对应关系，使得不仅能从 $f(x)$ 推出 $g(x)$，还能从 $g(x)$ 反推出 $f(x)$，那么这个反推的过程就叫做反演。

形象化地，若原数列为 $g(n)$，新数列为 $f(n)$，且满足 $f(n) = \sum\limits_{i=0}^n a_{n, i} \times g(i)$，那么反演就是我们通过 $f(n)$ 得到 $g(n)$，即 $g(n) = \sum\limits_{i=0}^n b_{n, i} \times f(i)$，那么我们可以这样表示：
$$
f(n) = \sum\limits_{i=0}^x a_{n, i} \times g(i) \Longleftrightarrow g(n) = \sum\limits_{i=0}^n b_{n, i} \times f(i)
$$
事实上，通过 $g(x)$ 反推回 $f(x)$ 可以用 $\Theta(n^3)$ 的复杂度解 $n$ 元一次方程组。但是在一些特殊的对应关系例，反演会化出一些优美的形式，例如莫比乌斯反演，单位根反演，子集反演，二项式反演等。

### 2.2 容斥原理与二项式反演

全集 $U = \{S_1, S_2, \dots, S_n\}$ 且满足任意 $i$ 个集合的并集、交集的大小都相同。

设 $f(n)$ 表示 $n$ 个集合的交集的大小，$g(n)$ 表示 $n$ 个集合的补集的交集的大小，有：
$$
g(n) = \left|\bigcap_{i=1}^n S_i\right| = |U| - \left|\bigcup_{i=1}^n \overline{S_i}\right| = \left|U\right| + \sum_{i=0}^n (-1)^i \sum_{1 \le a_1 < \dots < a_i \le n }\left|\bigcap_{j=1}^i \overline{S_{a_j}} \right| = \sum_{i=0}^n (-1)^i\dbinom ni f(i)
$$
以及：
$$
f(n) = \left|\bigcap_{i=1}^n \overline{S_i}\right| = |U| - \left|\bigcup_{i=1}^n S_i\right| = \left|U\right| + \sum_{i=0}^n (-1)^i \sum_{1 \le a_1 < \dots < a_i \le n }\left|\bigcap_{j=1}^i S_{a_j} \right| = \sum_{i=0}^n (-1)^i\dbinom ni g(i)
$$
可得：
$$
g(n) = \sum_{i=0}^n (-1)^i\dbinom ni f(i) \Longleftrightarrow f(n) = \sum_{i=0}^n (-1)^i\dbinom ni g(i)
$$

### 2.3 形式

- 形式一：

$$
g(n) = \sum_{i=0}^n (-1)^i\dbinom ni f(i) \Longleftrightarrow f(n) = \sum_{i=0}^n (-1)^i\dbinom ni g(i)
$$

- 形式二：

$$
g(n) = \sum_{i=0}^n \dbinom ni f(i) \Longleftrightarrow f(n) = \sum_{i=0}^n (-1)^{n - i}\dbinom ni g(i)
$$

实际上这个式子中的 $f(i)$ 等于形式一中的 $(-1)^if(i)$，代入即可。

- 形式三：

$$
g(n) = \sum_{i=n}^N \dbinom Ni f(i) \Longleftrightarrow f(n) = \sum_{i=n}^N (-1)^{N - i}\dbinom Ni g(i)
$$

这个式子是「至多」和恰好的转化。

- 形式四：

$$
g(n) = \sum_{i=n}^N \dbinom in f(i) \Longleftrightarrow f(n) = \sum_{i=n}^N(-1)^{i - n} \dbinom in g(i)
$$

这个式子是「至少」和恰好的转化。

**注意**：这里的「至少」与「至多」的概念并不是朴素的：

1. 「至少」：钦定了 $i$ 个性质，剩下的性质不作限制。
2. 「至多」：钦定了 $i$ 个性质不作限制，剩下的必须满足性质。

---

#### 2.4.2 集合计数[$^{\text{BZOJ 2839}}$](https://hydro.ac/d/bzoj/p/2839)

> - 给定 $n, k$。令 $S_0 = \{1, 2, 3, \dots, n\},S_1 = \{S \mid S \subseteq S_0\}$，求有多少 $S_1$ 的子集 $S$ 满足 $\left|\bigcap\limits_{S \in S_1} S\right| = k$。
> - $k \le n \le 10^6$。

仍然是钦定。设 $f(k)$ 表示「至少」$k$ 个元素是集合的交集，即钦定 $k$ 个元素作为集合的交集，剩余不做限制的方案数，会有重复。有：
$$
f(k) = \dbinom nk \left(2^{2^{n-k}}-1\right)
$$
设 $g(k)$ 表示恰好 $k$ 个元素是集合的交集的方案数，有：
$$
f(k) = \sum_{i=k}^n \dbinom ik g(i)
$$
二项式反演得：
$$
g(k) = \sum_{i=k}^n(-1)^{i-k} \dbinom ik f(i) = \sum_{i=k}^n(-1)^{i-k} \dbinom ik \dbinom ni \left(2^{2^{n-i}}-1\right)
$$
$g(k)$ 即为所求。时间复杂度 $\Theta(n)$。

---

## 作者：yanbinmu (赞：11)

## 前置知识

### 二项式反演

**定理 1**：若 $\displaystyle{g(n) = \sum \limits_{i=m}^n \binom{n}{i} f(i)}$，则 $\displaystyle{f(n) = \sum \limits_{i=m}^n (-1)^{n-i} \binom{n}{i} g(i)}$。

$m$ 为一常数。

**证明**：
$$
\begin{aligned}
& \sum \limits_{i=m}^n (-1)^{n-i} \binom{n}{i} g(i) \\
= & \sum \limits_{i=m}^n (-1)^{n-i} \binom{n}{i} \sum \limits_{j=m}^i \binom{i}{j} f(j) \\
= & \sum \limits_{i=m}^n \sum \limits_{j=m}^i (-1)^{n-i} \binom{n}{i} \binom{i}{j} f(j) \\
= & \sum \limits_{j=m}^n \sum \limits_{i=j}^n (-1)^{n-i} \binom{n}{i} \binom{i}{j} f(j) \\
= & \sum \limits_{j=m}^n \sum \limits_{i=j}^n (-1)^{n-i} \binom{n}{j} \binom{n-j}{n-i} f(j) \\
= & \sum \limits_{j=m}^n \binom{n}{j} f(j) \sum \limits_{i=j}^n (-1)^{n-i} \binom{n-j}{n-i} \\
= & \sum \limits_{j=m}^n \binom{n}{j} f(j) [n-j=0] \\
= & f(n)
\end{aligned}
$$
**适用范围**：

两种记法：

1. 记 $f(n)$ 是**恰好** $n$ 个元素满足某个条件的方案数，$g(n)$ 是从 $n$ 个元素中**选出 $i\ (0 \leq i \leq n)$ 个元素**满足条件的方案数之和，容易得到 $\displaystyle{g(n) = \sum \limits_{i=0}^n \binom{n}{i} f(i)}$；

2. 记 $f(n)$ 是 $n$ 个元素中**恰有** $m$ 个元素满足某个条件的方案数，$g(n)$ 是 $n$ 个元素中**先选择 $m$ 个元素**，再令这些元素满足条件的方案数，容易得到 $\displaystyle{g(n) = \sum \limits_{i=m}^n \binom{n}{i} f(i)}$。

注：这里 $g(n)$ 的方案会重复算，因为对某个恰有 $i$ 个元素满足条件的方案有 $\displaystyle{\binom{n}{i}}$ 种选定的方法。

## 题目描述

一个有 $N$ 个元素的集合有 $2^N$ 个不同子集（包含空集），现在要在这 $2^N$ 个集合中取出若干集合（至少一个），使得它们的交集的元素个数为 $K$，求取法的方案数，答案模 $10^9+7$。

## 分析

设 $f_n$ 为交集元素个数**恰好为 $n$ 的方案数**，$g_n$ 为**选出 $i$ 个子集**满足交集元素为 $n$ 的方案数。

易得 $\displaystyle{g_n = \sum \limits_{i=0}^n \binom{n}{i} f_i}$，我们发现这满足二项式反演的条件，所以可得：

$$
\displaystyle{f(k) = \sum \limits_{i=0}^k (-1)^{k-i} \binom{k}{i} g(i)) = \sum \limits_{i=k}^n (-1)^{i-k} \binom{i}{k} g(i)}
$$
那如何求 $g_i$ 呢？

我们可以先确定 $i$ 个交集中的元素，那么剩下的就是 $N - i$ 个元素，我们用这些集合去构造集合，然后在对于每个集合并上那 $i$ 个元素，就可以构造出一个组子集使得交集元素为 $i$。

而用 $n-i$ 个元素都可以选或不选，所以共有 $2^{N-i}$ 个集合，在其中选若干个集合有 $2^{2^{N-i}}$ 种情况，再去掉一个空集，所以是 $2^{2^{N-i}} - 1$ 种方案。

所以 $\displaystyle{g_i = \binom{N}{i}(2^{2^{N-i}} - 1)}$。

综上，$\displaystyle{f(k) = \sum \limits_{i=k}^N (-1)^{i-k} \binom{i}{k} \binom{N}{i} (2^{2^{N-i}}-1)}$。

所以我们预处理组合数，再用 $O(N)$ 求出 $f_i$。	

## 代码

```C++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll Mod = 1000000007;
ll fac[1000005], inv[1000005];
ll qpow(ll a, ll b){
    ll res = 1;
    while(b){
        if(b & 1){
            res *= a;
            res %= Mod;
        }
        a *= a;
        a %= Mod;
        b >>= 1;
    }
    return res;
}
ll C(ll n, ll m){
    return fac[n] * inv[m] % Mod * inv[n-m] % Mod;
}
int main(){
    int N, K;
    scanf("%d %d", &N, &K);
    fac[0] = 1;
    for(int i = 1;i <= N;i ++ ){
        fac[i] = fac[i - 1] * i;
        fac[i] %= Mod;
    }
    inv[0] = 1;
    inv[N] = qpow(fac[N], Mod - 2);
    for(int i = N - 1;i >= 1;i -- ){
        inv[i] = inv[i + 1] * (i + 1);
        inv[i] %= Mod;
    }
    ll a = 2;
    ll ans = 0;
    for(int i = N;i >= K;i -- ){
        ll t = C(i, K) * (a - 1) % Mod * C(N, i) % Mod;
        if((i - K) % 2 == 1){
            t *= -1;
        }
        ans = ((ans + t) % Mod + Mod) % Mod;
        a *= a;
        a %= Mod;   
    }
    printf("%lld", ans);
    return 0;
}
```
## 题外话
顶楼的wyyqwq曾说过：“我的人生刚刚开始，多想和她一直在一起，我真的很喜欢她！！”
备注：旧事重提

---

## 作者：Lyrella (赞：5)

# 简要题意

一个有 $N$ 个元素的集合有 $2N$ 个不同子集（包含空集），现在要在这 $2N$ 个集合中取出若干集合（至少一个），使得它们的交集的元素个数为 $K$，求取法的方案数，答案模 $10^9+7$。

数据范围：$1\le K\le N\le10^6$。

# 题解

我们设 $f(i)$ 表示选出子集大小恰好为 $i$ 的方案数，然而我们发现这个东西不好转移。**但是**，如果我们先求出一个**限制条件少一点但是比较好求**的东西 $g(i)$ 再去求 $f(i)$ 就会简单许多（也许。

于是就有 $g(i)$ 表示钦定 $i$ 个元素在交集中（其他元素不考虑），这样 $g(i)$ 就比较好求了，我们可以把 $g(i)$ 的式子写出来：$g(i)={n\choose i}(2^{2^{n-i}}-1)$。为什么呢？首先我们需要从 $n$ 个元素中选择 $i$ 个元素，所以有 $n\choose i$，然后对于剩下 $n-i$ 个元素，我们可以列举出可能存在的集合的可能，也就是 $2^{n-i}$ 种可能，对于这些集合我们可以选可以不选，但是题目要求至少选一个，所以就是一个 $2^{n-i}$ 元集去掉空集，然后选的元素与不选的元素之间互有影响所以是乘法原理。

然后就是去找 $f$ 与 $g$ 的关系了。其实对于 $g$，我们还有另一种求法：$g(i)=\sum^n_{j=i}{j\choose i}f(j)$。其实就是对于选出子集大小恰为 $j$ 的方案中再去选出 $i$ 个，与第一种方法等价。

然后看到后面这坨直接**二项式反演**就可以得到：
$$
f(i)=\sum^n_{j=i}(-1)^{j-i}{j\choose i}{n\choose j}(2^{2^{n-j}}-1)
$$
然后直接算就行。

# 代码

```cpp
signed main(){
    n = rd(), k = rd();
    fac[0] = bs[0] = 1;
    for(int i = 1; i <= n; ++i)fac[i] = fac[i - 1] * i % mod, bs[i] = bs[i - 1] * 2 % (mod - 1);
    inv[n] = qmi(fac[n], mod - 2);
    for(int i = n - 1; i; --i)inv[i] = inv[i + 1] * (i + 1) % mod;
    for(int i = k; i <= n; ++i){
        ll op = qmi(- 1, i - k);
        ll t1 = C(i, k), t2 = C(n, i);
        ll tt = (qmi(2, bs[n - i]) - 1 + mod) % mod;
        (ans += op * t1 % mod * t2 % mod * tt % mod + mod) %= mod;
    }
    cout << ans;
    return 0;
}
```

---

## 作者：hzoi_Shadow (赞：5)

[题目传送门](https://www.luogu.com.cn/problem/P10596)

# 前置知识

[二项式反演](https://oi-wiki.org/math/combinatorics/combination/#%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%8F%8D%E6%BC%94) | [乘法原理](https://oi-wiki.org/math/combinatorics/combination/#%E4%B9%98%E6%B3%95%E5%8E%9F%E7%90%86) | [扩展欧拉定理](https://oi-wiki.org/math/number-theory/fermat/#%E6%89%A9%E5%B1%95%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86) | [容斥原理](https://oi-wiki.org/math/combinatorics/inclusion-exclusion-principle/)

# 解法

考虑二项式反演。

设 $f_{m}$ 表示交集中恰好有 $m$ 个元素的方案数，$g_{m}$ 表示交集中至少有 $m$ 个元素的方案数，即 $g_{m}=\sum\limits_{i=m}^{n}\dbinom{i}{m}f_{i}$，那么有 $f_{m}=\sum\limits_{i=m}^{n}(-1)^{i-m}\dbinom{i}{m}g_{i}$。

现在问题转化为怎么求 $g_{m}$。先钦定选出的 $m$ 个元素，此时方案数为 $\dbinom{n}{m}$；接着剩下的 $n-m$ 个元素一共可以组成 $2^{n-m}$ 个集合（包括空集），又因为这些集合中至少要选 $1$ 个，故状态转移方程为 $g_{m}=\dbinom{n}{m}(2^{2^{n-m}}-1)$。

由 $\begin{aligned} 2^{2^{n-m+1}}=2^{2^{n-m} \times 2}=2^{2^{n-m}+2^{n-m}}=(2^{2^{n-m}})^{2} \end{aligned}$ 倒序处理即可。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long 
#define ull unsigned long long
#define sort stable_sort 
#define endl '\n'
const ll p=1000000007;
ll g[1000010],jc[1000010],inv[1000010],jc_inv[1000010];
ll C(ll n,ll m,ll p)
{
	return (n>=m&&n>=0&&m>=0)?((jc[n]*jc_inv[m]%p)*jc_inv[n-m]%p):0;
}
int main()
{
	ll n,k,i,mi=2,f=0;
	cin>>n>>k;
	inv[1]=1;
	jc[0]=jc_inv[0]=jc[1]=jc_inv[1]=1;
	for(i=2;i<=n;i++)
	{
		inv[i]=(p-p/i)*inv[p%i]%p;
		jc[i]=jc[i-1]*i%p;
		jc_inv[i]=jc_inv[i-1]*inv[i]%p;
	}	
	for(i=n;i>=k;i--)
	{
		g[i]=C(n,i,p)*mi%p;
		mi=mi*mi%p;
	}
	for(i=k;i<=n;i++)
	{
		f=(f+((i-k)%2==0?1:-1)*C(i,k,p)*g[i]%p+p)%p;
	}
	cout<<f<<endl;
	return 0;
}
```

---

## 作者：COsm0s (赞：3)

对于**恰好** $k$ 个元素的计数题，二项式反演是一个常见的做法。

我们设 $f_i$ 为**至少**选择 $i$ 个元素作为交集的方案数，$g_i$ 为**恰好**选择 $i$ 个元素作为交集的方案数。

则交集 $i$ 种元素的贡献为 $\binom{n}{i}$。

而剩下只包含其他 $n-i$ 个元素集合都可以随便选（除了空集），这部分贡献即 $2^{2^{n-i}}-1$。

所以 $f_i=\binom{n}{i}\times(2^{2^{n-i}}-1)$。

对于“至少”和“恰好”的关系，我们有：

$g_i=\sum\limits^n_k (-1)^{n-k}\times \binom{i}{k}\times f_i$。

代入上面 $f_i$ 的式子，则可得到答案：

$g_k=\sum\limits^n_k (-1)^{n-k}\times \binom{i}{k}\times \binom{n}{i}\times(2^{2^{n-i}}-1)$。

对于组合数，观察到其有一项恒定，所以可以递推得到。

对于 $2^{2^{n-i}}$，我们不能在算指数的时候直接取模。一种可行的方法是扩展欧拉定理。由于 $mod$ 是质数，所以 $\varphi(mod)=mod-1$。

但其实我们并不需要这样。发现 $2^{2^{k}}=(2^{2^{k-1}})^2$，倒着枚举 $g_i$ 然后不断更新 $2^{2^{n-i}}$ 即可。

```cpp
int Ck[N], Cn[N];
int Solve() {
	int n, k, bas = 2, ans = 0; 
	cin >> n >> k;
	Cn[0] = 1, Ck[k] = 1;
	REP(i, 1, n) {
		Cn[i] = Cn[i - 1] * (n - i + 1) % mod * qpow(i, mod - 2) % mod;
		if(i > k) Ck[i] = Ck[i - 1] * i % mod * qpow(i - k, mod - 2) % mod;
	}
	DOW(i, n, k) {
		int cur = (i - k & 1) ? -1 : 1;
		ans += cur * Ck[i] * Cn[i] % mod * (bas - 1) % mod;
		ans = (ans % mod + mod) % mod;
		bas = bas * bas % mod;
	}
	cout << ans << '\n';
    return 0;
}
```

---

## 作者：_HCl_ (赞：2)

蒟蒻刚学二项式反演，写篇题解记录一下。

# BZOJ2839 题解

**题意简述**

对于大小为 $n$ 的集合，在其 $2^n$ 个子集中取出至少一个，使其交集大小为 $K$，求方案数。

**思路引导**

考虑二项式反演。设 $f(k)$ 表示交集大小恰好为 $k$ 的取出方案数，设 $F(k)$ 表示交集大小至少为 $k$ 的取出方案数。那么有：
$$
F(k)=\sum_{i=k}^n\binom ikf(i)
$$

其组合意义为，对于每一个交集大小为 $i$ 的取出方案，在这 $i$ 个数中可以任选 $k$ 个数作为 $F(k)$ 中的 $k$。

根据二项式反演，得到：

$$
f(k)=\sum_{i=k}^n(-1)^{i-k}\binom ikF(i)
$$

接下来考虑求出 $F(i)$。首先在全集中钦定 $i$ 个数作为 $F(i)$ 中的 $i$。那么剩下的 $n-i$ 个数是可以任意取的，取出的集合和钦定的 $k$ 个数拼接即是方案中的若干子集。

对于剩下的 $n-i$ 个数，其有 $2^{n-i}$ 个子集，对于每一个子集我们都可以选择取或不取，即 $2^{2^{n-i}}$ 种方案。但注意不能取空集，所以实际上是 $(2^{2^{n-i}}-1)$ 种方案。

综上，我们有：

$$
F(i)=\binom ni(2^{2^{n-i}}-1)
$$

代入，得到：
$$
f(k)=\sum_{i=k}^n(-1)^{i-k}\binom ik\binom ni(2^{2^{n-i}}-1)
$$

在视快速幂算法时间复杂度为常数的情况下，其时间复杂度为 $\mathcal{O}(n)$。

但是注意，在模质数 $P$ 意义下计算 $2^{2^{n-i}}$ 时，需要进行另外的处理。根据扩展欧拉定理：
$$
2^{2^{n-i}}\equiv2^{2^{n-i}\bmod \varphi(P)}\equiv2^{2^{n-i}\bmod (P-1)}\pmod P
$$

**代码**

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,k;
int fac[1000001],iv[1000001];
int qpow(int x,int y,int MOD=1e9+7){
	int res=1;
	for(;y;y>>=1,x=x*x%MOD)if(y&1)res=res*x%MOD;
	return res;
}
int MOD=1e9+7;
int C(int n,int m){
	return fac[n]*iv[m]%MOD*iv[n-m]%MOD;
}
signed main(){
	cin>>n>>k;
	int ans=0;
	fac[0]=1;
	for(int i=1;i<=n;++i)fac[i]=fac[i-1]*i%MOD;
	iv[n]=qpow(fac[n],MOD-2);
	for(int i=n-1;i>=0;i--)iv[i]=iv[i+1]*(i+1)%MOD;
	for(int i=k;i<=n;++i){
		int z=(i-k)&1?-1:1;
		(ans+=MOD+z*(C(i,k)*C(n,i)%MOD*(qpow(2,qpow(2,n-i,MOD-1))-1)%MOD))%=MOD;
	}
	cout<<ans;
}
```

---

## 作者：xyz105 (赞：2)

$$\begin{Bmatrix}\color{red}\LARGE\bold{Solution}\\\normalsize\texttt{No.008 }\bold{P10596}\end{Bmatrix}\times\footnotesize\texttt{ By Xyz105}$$


~~我做这题的时候难度还是绿的。~~


### 题目描述

一个集合的幂集 是由 该集合的所有子集（包含空集和全集） 构成的集族。  
有一个 $N$ 个元素的集合 $A$，要求从 $A$ 的幂集中取出若干集合（至少一个），使得它们的交集的元素个数为 $K$，求取法的方案数，答案模 $10^9+7$。


### 解题思路

直接计算是不太好做的。可以考虑二项式反演的方向，即用 交集元素个数**至少**为 $K$ 的方案数 来推出 交集元素个数**恰好**为 $K$ 的方案数。

> **二项式反演**。设 $f(i)$ 为“至少为 $i$”的方案数，$g(i)$ 为“恰好为 $i$”的方案数。对于 $j>i$，$g(j)$ 会对 $f(i)$ 贡献 $\dbinom{j}{i}$ 次，有：
> $$\begin{aligned}&f(i)=\sum_{j=i}^n\binom{j}{i}g(j)\\\Leftrightarrow& g(i)=\sum_{j=i}^n(-1)^{j-i}\binom{j}{i}f(j)\end{aligned}$$
> 证明此处就不细讲了，详情见 [OI-Wiki](https://oi-wiki.org/math/combinatorics/combination/#%E8%AF%81%E6%98%8E)。

问题变为如何求出“交集元素个数至少为 $K$”的方案数。

考虑一个集合 $S$ 满足 $S\subseteq A$ 且 $|S|=K$，即在 $A$ 中选出一个大小为 $K$ 的子集 $S$，并且要求 $S$ 必须被选出来的交集所包含。这样做是为了保证“元素个数至少为 $K$”的下限。

因为选出来的交集必须包含 $S$，所以从 $A$ 的幂集中选出的所有集合也必须全都包含 $S$。显然在 $A$ 的幂集中，包含 $S$ 的集合个数为 $2^{N-K}$（可以理解为，$S$ 内的 $K$ 个元素必须有，$S$ 外的 $N-K$ 个元素有和没有随便）。

在这 $2^{N-K}$ 个集合中，选出至少一个就可以使得选出来的交集包含 $S$，所以总共有 $2^{2^{N-K}}-1$ 种选法（减 $1$ 是因为这些集合不能一个都不选）。

集合 $S$ 的大小 $K$ 固定，所以在 $A$ 中选子集 $S$ 有 $\dbinom{N}{K}$ 种选法。因此“交集元素个数至少为 $K$”的方案数”就是 $\dbinom{N}{K}\cdot(2^{2^{N-K}}-1)$。

设 $f(i)$ 为“至少为 $i$”的方案数，$g(i)$ 为“恰好为 $i$”的方案数。刚才得出 $f(i)=\dbinom{N}{i}(2^{2^{N-i}}-1)$，套用 $g(K)=\sum_{j=K}^n(-1)^{j-K}\binom{j}{K}f(j)$ 即可求出最终答案 $g(K)$。


### 参考代码

本人在代码中使用 `more[]` 表示 $f$，用的公式变形是 $g(K)=\sum_{j=0}^{n-K}(-1)^j\binom{j+K}{K}f(j+K)$。

发现 $2^{2^i}$ 的求法是可以优化的。因为 $2^{2^i}=2^{2^{i-1}\cdot 2}=(2^{2^{i-1}})^2$，所以可将 $2^{2^i}$ 递推预处理。我把它存到数组 `a[]` 里了。

```cpp
#include <iostream>
#include <cstdio>
using namespace std;

typedef long long ll;

const ll MOD = 1e9 + 7;

const int MAXN = 1e6 + 10;

ll fac[MAXN], ifac[MAXN], a[MAXN]; // a_i = 2^{2^i}.
ll n, k, more[MAXN], ans;

inline ll pow_(ll a, ll b, ll p)
{
	ll res = 1;
	for (; b; b >>= 1, a = a * a % p)
		if (b & 1) res = res * a % p;
	return res;
}

inline ll C(ll n, ll m)
	{return fac[n] * ifac[m] % MOD * ifac[n - m] % MOD;}

int main()
{
	fac[0] = ifac[0] = 1;
	for (ll i = 1; i < MAXN; i++) fac[i] = fac[i - 1] * i % MOD;
	ifac[MAXN - 1] = pow_(fac[MAXN - 1], MOD - 2, MOD);
	for (ll i = MAXN - 2; i; i--) ifac[i] = ifac[i + 1] * (i + 1) % MOD;
	
	a[0] = 2;
	for (int i = 1; i < MAXN; i++) a[i] = a[i - 1] * a[i - 1] % MOD;
	
	cin >> n >> k;
	for (ll i = 0; i <= n; i++)
		more[i] = C(n, i) * (a[n - i] - 1) % MOD;
	for (int i = 0; i <= n - k; i++)
		ans = (ans + (i & 1 ? MOD - 1 : 1) * C(k + i, k) % MOD * more[k + i]) % MOD;
	cout << ans;
	
	return 0;
}
```

---

## 作者：Starrykiller (赞：2)

让 cz 搬的题目，来写篇题解。/tx

考虑二项式反演，设 $g(i)$ 为交集大小至少为 $i$ 的方案数，$f(i)$ 为交集大小恰好为 $i$ 的方案数。


显然有 $\displaystyle g(i)=\sum_{n\ge i}{n\choose i}f(n)$，反演得 $\displaystyle f(i)=\sum_{n\ge i}(-1)^{n-i}{n\choose i} g(n)$。

考虑怎么算 $g(i)$。先钦定交集中的元素，那么就是 $\displaystyle {N\choose i}$；剩下一共有 $(N-i)$ 个元素。我们只需要从剩下元素的集合中选取若干个（至少一个）子集即可。剩下元素的集合有 $2^{N-i}$ 个子集；选取若干个子集的方案就是 $2^{2^{N-i}}-1$（减去空集的方案数）。

所以我们得到了 $\displaystyle g(i)={N\choose i}\cdot \left(2^{2^{N-i}}-1\right)$，直接反演即可。注意指数要对 $(10^9+6)$ 取模。

---

## 作者：Istruggle (赞：1)

我们令 $f_k$ 表示的交集的元素个数**恰好**为 $k$，令 $g_k$ 表示的交集的元素个数**至少**为 $k$。根据二项式反演可得：

$$f_k = \sum_{i=k}^{n}\left (-1 \right )^{i-k}\binom{i}{k}g_i$$

下面考虑如何求 $g_k$。

我们先钦定其中的 $k$ 个元素为交集的元素，则方案数为 $\binom{n}{k}$，这表示在选出的集合中这 $k$ 个元素一定选，这些钦定的集合还有 $n-k$ 个元素可以选，枚举这 $n-k$ 个元素选或不选共有 $2^{n-k}$ 种方案，由于不能不选，所以 $g_k = \binom{n}{k} ( 2^{2^{n-k}}-1)$。最终答案为 $f_k$。

#### 参考代码
```cpp
#include<bits/stdc++.h>
#define int long long
const int mod=1e9+7,N=1e6+5;
using namespace std;
int n,k,fac[N],inv[N];
int c(int a,int b){return fac[a]*inv[b]%mod*inv[a-b]%mod;}
int qpow(int a,int b,int p){
	int res=1;
	while(b){
		if(b&1) res=res*a%p;
		a=a*a%p;
		b>>=1; 
	}
	return res;
}
int f[N],g[N];
signed main(){
	scanf("%lld%lld",&n,&k);
	fac[0]=1;
	for(int i = 1;i<=n;i++) fac[i]=fac[i-1]*i%mod;
	inv[n]=qpow(fac[n],mod-2,mod);
	for(int i = n-1;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;
	for(int i = 0;i<=n;i++)
	f[i]=c(n,i)*(qpow(2,qpow(2,n-i,mod-1),mod)-1)%mod;
	for(int i = k;i<=n;i++){
		int x;
		if((i-k)%2==1) x=-1;
		else x=1;
		int tmp=c(i,k)*f[i]%mod;
		tmp*=x; 
		g[k]=(g[k]+tmp+mod)%mod;
	}
	printf("%lld",g[k]);
}
```

---

## 作者：_Kenma_ (赞：1)

# P10596 解题报告

## 前言

NOIP 结束后来补数学了。

## 思路分析

看起来就像容斥。

设 $f_i$ 表示钦定共同选 $i$ 个数的方案。

根据组合意义，不难列出：

$$f_i = \binom{n}{i} (2^{2^{n-i}}-1)$$

稍微解释一下，就是从 $n$ 个数中钦定 $i$ 个数，然后在剩下的合法子集中随意选，子集中的非钦定的数也随便选。

设 $g_i$ 表示恰好共同选 $i$ 个数的方案。

根据二项式反演，可以写出：

$$g_k=\sum_{i=k}^{n}(-1)^{i-k}\binom{i}{k}f_i$$

将 $f_i$ 带入，得：

$$g_k=\sum_{i=k}^{n}(-1)^{i-k}\binom{i}{k}\binom{n}{i} (2^{2^{n-i}}-1)$$

$g_k$ 就是我们要求的答案。

可以预处理 $2^{2^i}$ 以及组合数，做到 $O(n\log n)$。

## 代码实现

```cpp

#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=1e9+7;
int n,k,flag,ans,fac[1000005],bpow[1000005];
int binpow(int a,int b){
	if(!b) return 1;
	int res=binpow(a,b/2);
	if(b&1) return res*res%mod*a%mod;
	else return res*res%mod;
}
int C(int n,int m){
	return fac[n]*binpow(fac[n-m],mod-2)%mod*binpow(fac[m],mod-2)%mod;
}
signed main(){
	cin>>n>>k;
	fac[0]=1;
	bpow[0]=2;
	for(int i=1;i<=n;i++){
		fac[i]=fac[i-1]*i%mod;
		bpow[i]=bpow[i-1]*bpow[i-1]%mod;
	}
	for(int i=k;i<=n;i++){
		if((i-k)&1) flag=-1;
		else flag=1;
		ans=((ans+flag*C(i,k)*C(n,i)%mod*(bpow[n-i]-1+mod)%mod)%mod+mod)%mod;
	}
	cout<<ans;
	return 0;
}

```

## 后记

一道非常好的帮助初学者理解二项式反演的题目。

---

## 作者：a_sad_soul (赞：1)

### 二项式反演

我们可以枚举交集的情况数，为 $\binom{n}{k}$。

那么，设交集大小至少为 $i$ 的方案数为 $f_i$，那么容易处理得$\large f_i=\binom{n}{i}(2^{2^{i}}-1)$。原因是一共有 $2^n$ 种不同的集合时，对于每个集合，将元素划分到两个不同集合又是有 $2^x$ 种情况，其中 $x$ 为集合大小，那么除开空集，总方案数为 $2^{2^i}-1$ 种。

那么根据二项式反演，得到答案为 $\large\sum_{i=k}^{n}\binom{i}{k}(-1)^{i-k}f_i$。

剩下就是处理子集方案数的方法了。这里提供一个不需要欧拉定理的方式。

由于 $\large 2^{2^n}=(2^{2^{n-1}})^2$，那么令 $up_i$ 为该值，初始时 $up_0=2$。于是有 $up_i=(up_{i-1})^2$ 这个递推式，直接求即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAXN = 1e6+10;
ll fac[MAXN],rev[MAXN];
const ll mod = 1e9+7;
ll ksm(ll a,ll b){
    ll re=1;
    while(b){
        if(b&1)re=re*a%mod;
        a=a*a%mod;
        b>>=1;
    }
    return re;
}
ll C(int n,int m){
    return fac[n]*rev[m]%mod*rev[n-m]%mod;
}
int n,k;
void Init(){
    fac[0]=1;
    for(int i=1;i<=n;++i)fac[i]=fac[i-1]*i%mod;
    rev[n]=ksm(fac[n],mod-2);
    for(int i=n-1;~i;--i)rev[i]=rev[i+1]*(i+1)%mod;
}
ll f[MAXN];
ll up[MAXN];
int main(){
    scanf("%d%d",&n,&k);
    Init();
    up[0]=2;
    for(int i=1;i<=n;++i)up[i]=up[i-1]*up[i-1]%mod;
    for(int i=0;i<=n;++i)f[i]=C(n,i)*(up[n-i]-1)%mod;
    ll ans=0;
    for(int i=k;i<=n;++i)ans=(ans+((i-k)&1?mod-1:1)*f[i]%mod*C(i,k)%mod)%mod;
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：XiaoQuQu (赞：1)

题目大意：一个有 $N$ 个元素的集合有 $2^N$ 个不同子集（包含空集），现在要在这 $2^N$ 个集合中取出若干集合（至少一个），使得它们的交集的元素个数为 $K$，求取法的方案数，答案模 $10^9+7$。

为表述方便，不妨设这 $i$ 个元素分别为 $1\sim n$。

前置知识：二项式反演。

考虑设 $g(x)$ 为我们选择恰好 $x$ 个数，要求选出若干个集合他们的交集里是这 $x$ 个数的方案数，这个东西由于是“恰好”不好计数，考虑设 $f(x)$ 表示说我们钦定 $x$ 个数他一定要在这若干个集合的交集中的方案数。

$f(x)$ 是好求的，我们直接从集合中钦定 $x$ 个数一定要在若干个集合的交集中（其他数在不在我不关心），然后考虑包含这 $x$ 个数的集合数量，显然除了这 $x$ 个数必选以外，其余的数可选可不选，所以这部分的数量是 $2^{n-x}$ 的。然后对于这些包含这 $x$ 个数的集合，对于每个集合来说我们也是可选可不选，所以最终这部分的答案是 ${n\choose x}\times(2^{2^{n-x}}-1)$，这部分的 $-1$ 是因为要排除掉空集。

接下来考虑如果 我们已知 $g$，如何用 $g$ 表示出 $f$（以方便我们用二项式反演从 $f$ 反推回 $g$），显然$f(x)=\sum_{i=x}^ng(i)\times{n\choose i}$，代表说我们对于每一个 $i\ge x$，我们恰好选 $i$ 个数的方案数之和就是钦定 $x$ 个数的方案数。然后对这个式子用一下二项式反演：
$$
f(x)=\sum_{i=x}^n{n\choose i}\times g(i)\Leftrightarrow g(x)=\sum_{i=x}^n(-1)^i\times{n\choose i}\times{i\choose x}\times(2^{2^{n-i}}-1)
$$
最后用一遍扩展欧拉定理就做完了，时间复杂度 $O(n\log n)$，如果预处理 $2^{2^i}$ 可以做到 $O(n)$。

```cpp
const int MAXN = 1e6 + 5, mod = 1e9 + 7;
int n, k, fac[MAXN], ifac[MAXN];

int quickpow(int a, int b, int p = mod) {
	int ret = 1;
	while (b) {
		if (b & 1) ret = ret * a % p;
		a = a * a % p; b >>= 1;
	}
	return ret;
}

int C(int n, int m) {
	if (n < m) return 0;
	return fac[n] * ifac[m] % mod * ifac[n - m] % mod;
}

void work() {
	cin >> n >> k;
	fac[0] = 1;
	for (int i = 1; i <= n; ++i) fac[i] = fac[i - 1] * i % mod;
	ifac[n] = quickpow(fac[n], mod - 2);
	for (int i = n; i; i--) ifac[i - 1] = ifac[i] * i % mod; 
	int ans = 0, coff = 1;
	for (int i = k; i <= n; ++i) {
		ans = ans + coff * C(i, k) * C(n, i) % mod * quickpow(2, quickpow(2, n - i, mod - 1)) % mod;
		ans = (ans % mod + mod) % mod;
		coff = -coff;
	}
	cout << ans << endl;
}
```

---

## 作者：wawa123 (赞：0)

# 前言
本题是蒟蒻学完二项式反演之后第一道没看题解切出来的题，因此写下此题解。

宣传[博客](https://www.luogu.com.cn/article/3esx9g0h)
二项式反演。
# 分析
看题目，**恰好**为 $k$，一眼二项式反演。

设 $f_i$ 表示交集元素**恰好有 $k$ 个**。

$g_i$ 表示交集元素**至少有 $k$ 个**。

此时 
$$g(k)=\sum_{i=k}^nC_i^kf(i) $$

二项式反演得：

$$f(k)=\sum_{i=n}^k(-1)^{i-n}C_i^ng(i)$$

我们看看 $g_i$ 是什么。

计算他，我们可以先考虑**钦定 $i$ 个元素**，表示这 $i$ 个元素**一定**是交集中的元素，这是 $C_n^i$ 的。

然后其余的 $n-i$ 个元素就瞎弄了，他们在不在交集里**无所谓**。不在可以，在了的话也符合**至少 $i$ 个**的性质。这个东西是 $2^{2^{n-i}}$ 的（考虑钦定完之后能用的集合只剩 $2^{n-i}$，然后我们把集合当成元素，再计算一遍）

所以 $g_i=C_n^i2^{2^{n-i}}$。

答案自然就出来了，但是要注意到 $2^{2^{n-i}}$ 会需要扩展欧拉定理。


```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e6+5,mod=1e9+7;
ll g[N],n,k,fac[N];
inline ll qsm(ll a,ll b,ll mod){ll t=1;a%=mod;while(b){if(b&1)t=t*a%mod;a=a*a%mod;b>>=1;}return t;}
inline ll inv(ll x){return qsm(x,mod-2,mod);}
inline ll c(ll n,ll m){return fac[n]*inv(fac[m]*fac[n-m])%mod; }
int main(){
	fac[0]=1;for(int i=1;i<N;i++)fac[i]=i*fac[i-1]%mod;
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n>>k;
	for(int i=0;i<=n;i++){
		g[i]=c(n,i)*qsm(2,qsm(2,n-i,mod-1),mod)%mod;//首先钦定这i个元素，
//		其余的n-i个元素，肆意组合 
	}
	ll genshin=0;
	for(int i=k;i<=n;i++){
		if((i-k)&1){genshin=(genshin-c(i,k)*g[i])%mod;}
		else{genshin=(genshin+c(i,k)*g[i])%mod;}
	}
	cout<<(genshin%mod+mod)%mod;
	return 0;
}
```

---


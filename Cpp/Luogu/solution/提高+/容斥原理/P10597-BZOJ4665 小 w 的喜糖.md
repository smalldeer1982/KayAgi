# BZOJ4665 小 w 的喜糖

## 题目背景

题目来自原 BZOJ，我们承认题面及原数据的版权均属于原 BZOJ 或将题目授权给 BZOJ 使用的出题人。如果您是版权所有者且认为我们侵犯了您的权益，可联系我们。

---

废话不多说，反正小 w 要发喜糖啦！！

## 题目描述

小 w 一共买了 $n$ 块喜糖，发给了 $n$ 个人，每个喜糖有一个种类。这时，小 w 突发奇想，如果这 $n$ 个人相互交换手中的糖，那会有多少种方案使得每个人手中的糖的种类都与原来不同。

两个方案不同当且仅当，存在一个人，他手中的糖的种类在两个方案中不一样。

## 说明/提示

对于所有数据，$1\leq A_i \leq n \leq 2000$。

## 样例 #1

### 输入

```
6
1
1
2
2
3
3```

### 输出

```
10```

# 题解

## 作者：Anonymely (赞：9)

直接计数不好计，原因在于直接做必须要记下每种颜色数剩多少。

注意到限制 **糖的种类与原来不同** 的反面 **糖的种类与原来相同** 是相对好做的，且每种颜色在该限制下独立。

故考虑二项式反演，定义 $m$ 为颜色总数，$x_i$ 表示颜色为 $i$ 的位置有多少个，$y_i$ 表示颜色为 $i$ 的位置中**钦定** $y_i$ 个满足**糖的种类与原来相同**（即不满足题目条件），$g_i$ 表示**钦定** $\sum y = i$ 的方案数，$f_i$ 表示**恰好**有 $i$ 个位置不满足条件的方案数。

我们要求 $f_0$，根据二项式反演（实际上就是容斥）我们有 $f_0 = \sum_{i=0}^n(-1)^ig_i$，问题转化为求 $g_i$。

对于一组确定的 $y$，方案数为：

$$\frac{(n-\sum y_i)!}{(x_i - y_i)!}\prod \binom{x_i}{y_i}$$

即对于每一种颜色先选出 $y_i$ 个位置不变，剩下的为多重集排列。

对该式子做背包即可做到 $O(n^2)$，虽然有三重循环但实际是 $O(n^2)$ 的，原因是对于任意两个不同颜色的数都只算了一遍贡献。

当然也可以看成 $m$ 个总项数和为 $n$ 的多项式相乘，可以做到 $O(n\log^2n)$。

---

## 作者：ddxrS_loves_zxr (赞：9)

直接算答案并不好做，我们可以先求出**至少**有 $j$ 个人与原来拿到糖果相同的方案数，然后容斥求出答案。

记第 $i$ 种糖果的个数为 $c_i$，我们先假设同种类的糖果存在差异，最后统计答案时直接除以每个 $c_i!$ 就行了。

具体的，我们可以设 $f_{i,j}$ 表示前 $i$ 种糖果中至少有 $j$ 个人得到的糖果与原来的糖果相同的方案数。

转移时，我们还要枚举当前种类的糖果选取了 $k$ 颗，转移系数就是从 $c_i$ 颗糖果中选 $k$ 颗，且这 $k$ 颗糖果有顺序的放在原本拿着这 $c_i$ 颗糖果中的 $k$ 个人的方案数，也就是 $C_{c_i}^{k}\times A_{c_i}^{k}$。

转移方程为 $f_{i,j}=\sum\limits_{k=0}^{ \min(c_i,j)}f_{i-1,j-k}\times C_{c_i}^{k}\times A_{c_i}^{k}$。

最后容斥答案就为 $\sum\limits_{i=0}^{n}(-1)^i\times f_{m,i}\times (n-i)!$，$m$ 为糖果种类数。

不要忘了除以 $c_i!$。

时间复杂度为 $O(n^2)$。

代码：

```cpp
#include<bits/stdc++.h>
typedef long long ll;
using namespace std;
const ll mod = 1e9 + 9;
ll qpow(ll a, ll b) {
	ll ans = 1;
	while(b) {
		if(b & 1) ans = ans * a % mod;
		a = a * a % mod;
		b >>= 1; 
	}
	return ans;
}
int n, m, a[2005];
ll fct[2005], inv[2005], dp[2005][2005], ans;
ll C(int n, int m) {return fct[n] * inv[m] % mod * inv[n - m] % mod;}
ll A(int n, int m) {return fct[n] * inv[n - m] % mod;}
int main() {
	scanf("%d", &n);
	fct[0] = inv[0] = 1;
	for(int i = 1; i <= n; i++) fct[i] = fct[i - 1] * i % mod, inv[i] = qpow(fct[i], mod - 2);
	for(int i = 1, b; i <= n; i++) scanf("%d", &b), a[b]++;
	dp[0][0] = 1;
	for(int i = 1; i <= n; i++)
		for(int j = 0; j <= n; j++)
			for(int k = 0; k <= a[i] && k <= j; k++)
				(dp[i][j] += dp[i - 1][j - k] * C(a[i], k) % mod * A(a[i], k) % mod) %= mod;
	for(int i = 0, opt = 1; i <= n; i++) (ans += opt * dp[n][i] * fct[n - i] % mod) %= mod, opt *= -1;
	for(int i = 1; i <= n; i++) ans = ans * inv[a[i]] % mod;
	printf("%lld\n", (ans + mod) % mod);
	return 0;
}
```

---

## 作者：Mr_罗 (赞：5)

## Part -1 更新记录

$\tt{2024.7.19}$ 创建，提交审核，捉虫，提交审核，等待审核。

$\tt{2024.7.20}$ 捉虫，提交审核。

$\tt{2024.7.21}$ 被打回，修改，提交审核，通过审核。

## Part 0 前言

没有题解，来写一篇。

## Part 1 思路

考虑容斥。

先假设所有糖本质不同。

设 $f_{i,j}$ 表示前 $i$ 种糖 **至少** 有 $j$ 个人不变的情况数，转移呼之欲出：枚举当前糖不变的人数 $k$ ，挑出 $k$ 人再随便放回来，暴力转移，即
$$f_{i,j}=\sum_{k=0}^{c_i}f_{i-1,j-k}\binom{c_i}{k}c_i^{\underline{k}}$$
其中 $c_i$ 表示第 $i$ 种糖的数量，$a^{\underline{b}}=a(a-1)\cdots(a-b+1)$ 表示 $a$ 的 $b$ 阶下降幂（也就是 $a$ 中挑 $b$ 个排列，即排列数 $A_{a}^b=\dfrac{a!}{(a-b)!}$）。

然后用一堆 **至少** 容斥出 **恰好**，即
$$\text{res}=\sum\limits_{i=0}^n(-1)^{i}(n-i)!\cdot f_{m,i}$$
其中 $m$ 表示不同颜色的种类数。

最后干掉前面的假设，把每种情况都干掉同色糖当成不同种的数量，得到答案：
$$\text{ans}=\dfrac{\text{res}}{\prod\limits_{i=1}^mc_i!}$$

## Part 2 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

// #define CF

#define ll long long
#define ul unsigned ll
#define i7 __int128_t
#define db double
#define DB long db
#define pii pair<int, int>
#define fi first
#define se second
#define rep(i, l, r) for (int i = (int)(l), i##End = (int)(r); i <= i##End; i = -~i)
#define per(i, r, l) for (int i = (int)(r), i##End = (int)(l); i >= i##End; i = ~-i)
#define TT(T) template<typename T>

constexpr int N = 2005;
constexpr ll mod = 1000000009;
int n, m;
ll ans;
int c[N], s[N];
ll f[N][N];
ll fac[N], inv[N];

TT(T) void chkmx(T &a, ll b) { a < b && (a = b); }
TT(T) void chkmn(T &a, ll b) { a > b && (a = b); }
TT(T) void modad(T &a, ll b) { a += b, a >= mod && (a -= mod); }
TT(T) void modsu(T &a, ll b) { a -= b, a < 0 && (a += mod); }
TT(T) void modml(T &a, ll b) { (a *= b) %= mod; }
ll mdadd(ll a, ll b) { a += b; return (a >= mod ? a - mod : a); }
ll mdsub(ll a, ll b) { return (a >= b ? a - b : a - b + mod); }
ll mdmul(ll a, ll b) { return a * b % mod; } // what's Montgomery Algorithm?

ll qpow(ll a, ll b = ::mod - 2, ll mod = ::mod)
{
    ll ml = 1, bs = a;
    while (b) ((b & 1) && (modml(ml, bs), 114514)), modml(bs, bs), b >>= 1;
    return ml;
}

ll C(ll n, ll m) { return (n < m ? 0 : mdmul(fac[n], mdmul(inv[m], inv[n - m]))); }

void solve()
{
    scanf("%d", &n);
    rep(i, 1, n)
    {
        int t; scanf("%d", &t);
        c[t]++;
    }
    sort(c + 1, c + n + 1, greater<int>());
    while (c[m + 1]) m++;
    fac[0] = 1; rep(i, 1, n) fac[i] = mdmul(fac[i - 1], i);
    inv[n] = qpow(fac[n]); per(i, n - 1, 0) inv[i] = mdmul(inv[i + 1], i + 1);
    f[0][0] = 1;
    rep(i, 1, m) s[i] = s[i - 1] + c[i];
    rep(i, 1, m) rep(j, 0, s[i]) rep(k, 0, min(j, c[i])) modad(f[i][j], mdmul(mdmul(f[i - 1][j - k], C(c[i], k)), mdmul(fac[c[i]], inv[c[i] - k])));
    rep(i, 0, n) ((i & 1) ? modsu<ll> : modad<ll>)(ans, mdmul(fac[n - i], f[m][i]));
    rep(i, 1, m) modml(ans, inv[c[i]]);
    printf("%lld\n", ans);
}

int main()
{
    int _;
    #ifdef CF
    scanf("%d", &_);
    #else
    _ = 1;
    #endif
    while (_--) solve();
    return 0;
}
```

---

## 作者：cike_bilibili (赞：4)

## P10597 [statement](https://www.luogu.com.cn/problem/P10597)


考虑超集反演，很容易设出状态 $f_{i,j}$ 表示前 $i$ 种颜色至少有 $j$ 个相同的方案数，实际上是保证一定有 $j$ 个相同，其余任选。

考虑转移，实际上可以分为两个部分，相同的和不相同的，一定要分别乘上贡献，记 $cnt_i$ 表示颜色 $i$ 的个数，$sum_i=\sum_{j=1}^i cnt_j$，有转移：

$$ f_{i,j}=\sum_{k=0}^{\min (j,cnt_i)} f_{i-1,j-k} \left( \begin{array}{c} cnt_i \\ k \end{array} \right) \left( \begin{array}{c} sum_i-j \\ cnt_i-k \end{array} \right) $$

前者表示相同的合并，后者表示任选的合并，最后反演求出答案即可。

---

## 作者：hstt (赞：3)

每个人选哪颗糖和前面的选择有关，也会影响后面的选择，难以记录。

这道题启发我们把同一种糖放在一起考虑，运用 DP 求出至少有 $0\sim n$ 个人的糖与原来相同的方案数，进行容斥。

设 $dp_{i,j}$ 为前 $i$ 种糖中至少有 $j$ 个人的糖与原来相同的方案数。

显然答案为 $\sum\limits_{i=0}^n(-1)^i dp_{n,i}$。

假设最后固定了 $t$ 个人与原来相同，其他人任意打乱就有 $(n-t)!$ 种方案。但是对于有 $k$ 颗被固定的第 $i$ 种糖，一个方案可能的 $(cnt_i-k)!$ 种置换是等价的，我们在 dp 时就可提前除去。

得到递推式为：

$$dp_{i,j}=\sum_{k=0}^{\min(j,cnt_i)} \frac{dp_{i-1,j-k}{cnt_i \choose k}}{(cnt_i-k)!}$$

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2005,MOD=1e9+9; 
int n,ans;
int jc[N],inv[N];
int cnt[N]; 
int dp[N][N]; 
int ksm(int x,int y=MOD-2) {
	int ret=1;
	while(y) {
		if(y&1) ret=1ll*ret*x%MOD;
		x=1ll*x*x%MOD;
		y>>=1;
	}
	return ret;
}
int C(int x,int y) {
	return 1ll*jc[x]*inv[y]%MOD*inv[x-y]%MOD;
}
int main() {
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n;
	jc[0]=1;
	for(int i=1;i<=n;i++) jc[i]=1ll*jc[i-1]*i%MOD;
	inv[n]=ksm(jc[n]);
	for(int i=n;i;i--) inv[i-1]=1ll*inv[i]*i%MOD;
	for(int i=1,x;i<=n;i++) cin>>x,++cnt[x];
	int sum=0;
	dp[0][0]=1;
	for(int i=1;i<=n;i++) {
		sum+=cnt[i];
		for(int j=0;j<=sum;j++)
			for(int k=0;k<=cnt[i]&&k<=j;k++)
				(dp[i][j]+=1ll*dp[i-1][j-k]*C(cnt[i],k)%MOD*inv[cnt[i]-k]%MOD)%=MOD;
	}
	for(int i=0;i<=n;i++)
		(ans+=((i&1)?-1ll:1ll)*dp[n][i]*jc[n-i]%MOD)%=MOD;//这里乘上任意打乱的方案数 $(n-i)!$ 就是题解中设的 $dp_{n,i}$
	cout<<(ans+MOD)%MOD;
	return 0;
}
```

---

## 作者：CmsChase (赞：2)

# P10597 [BZOJ4665] 小 w 的喜糖

## 一、题意简述

有 $n$ 个人，每人手上拿着一种编号为 $1\sim n$ 的喜糖，允许同种喜糖出现多次。现在要重新分配这些喜糖，使得每个人拿到的喜糖种类与原来**不同**，问有多少种不同的分配方案。答案对 $10^9+9$ 取模。

- $1 \le n \le 2000$
- $1 \le A_i \le n$

## 二、思路分析

### 1. 观察本质：多重集错排

若糖的种类都不同，那么就是经典的错排问题；但这里可能有多人原来拿的是同一种喜糖，即每种喜糖数量 $c_1,c_2,\dots,c_m$ 不一。

我们需要在这些种类总数确定的条件下，枚举多少人“原地不动”，再容斥掉这些情况。

### 2. 容斥建模

设恰好有 $j$ 个人拿回了原来的糖，则这些人是“非法”的，我们要从总方案中排除。由容斥原理：

$$
\text{ans} = \sum_{j=0}^{n} (-1)^j \times S(j)
$$

其中 $S(j)$ 表示“恰好有 $j$ 人拿到原来喜糖”的方案数。

我们设每种喜糖的数量为 $c_1,c_2,\dots,c_m$，那么我们可以从每个 $c_t$ 中选 $f_t$ 个人保持原糖，总体满足：

$$
f_1 + f_2 + \cdots + f_m = j
$$

此时方案数为：

$$
\prod_{t=1}^{m} \binom{c_t}{f_t} \cdot \frac{(n-j)!}{\prod_{t=1}^m (c_t - f_t)!}
$$

乘上容斥符号后汇总即可。

### 3. 多项式卷积转移

上述枚举 $f_1+f_2+\cdots+f_m=j$ 的过程其实可以通过多项式卷积实现：

对每个糖种 $t$ 构造多项式：

$$
P_t(x) = \sum_{f=0}^{c_t} \binom{c_t}{f} \cdot \frac{1}{(c_t - f)!} \cdot x^f
$$

那么将所有 $P_t$ 依次相乘，得到的 $dp[j]$ 即为 $\sum_{f_1+\cdots+f_m = j} \prod \binom{c_t}{f_t} \cdot \frac{1}{(c_t - f_t)!}$。

最后乘上 $(n-j)!$，累加容斥系数即可。

## 三、代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int M = 1e9 + 9;

int add(int a,int b){a+=b;return a>=M?a-M:a;}
int mul(ll a,ll b){return a*b%M;}
int mpow(int a,int e=M-2){ll r=1;while(e){if(e&1)r=r*a%M;a=1LL*a*a%M;e>>=1;}return r;}

int main(){
    int n; cin >> n;
    vector<int> a(n), cnt(n+1);
    for (int &i : a) cin >> i, cnt[i]++;
    
    vector<ll> fac(n+1), ifac(n+1);
    fac[0] = 1;
    for(int i = 1; i <= n; i++) fac[i] = fac[i-1] * i % M;
    ifac[n] = mpow(fac[n]);
    for(int i = n; i; i--) ifac[i-1] = ifac[i] * i % M;

    vector<ll> dp(n+1); dp[0] = 1;

    for(int v = 1; v <= n; v++) if(cnt[v]){
        int c = cnt[v];
        vector<ll> p(c+1);
        for(int j = 0; j <= c; j++)
            p[j] = fac[c] % M * ifac[j] % M * ifac[c-j] % M * ifac[c-j] % M;
        
        vector<ll> tdp(n+1);
        for(int i = 0; i <= n; i++) if(dp[i])
            for(int j = 0; j <= c; j++)
                if(i+j <= n)
                    tdp[i+j] = (tdp[i+j] + dp[i] * p[j]) % M;
        dp.swap(tdp);
    }

    ll ans = 0;
    for(int j = 0; j <= n; j++){
        ll t = dp[j] * fac[n-j] % M;
        if(j & 1) ans = (ans - t + M) % M;
        else ans = (ans + t) % M;
    }
    cout << ans;
}
```

## 四、复杂度分析
预处理阶乘与逆元：$O(n)$

多项式 DP 转移：每类糖种次数不超过 $n$，总转移 $O(n^2)$

最后累加 $O(n)$

整体复杂度 $O(n^2)$，对于 $n \le 2000$ 是可以接受的。

## 五、总结
浅浅总结一波

这道题简单来说核心在于把容斥的组合公式转换为多项式乘法计算，构造出的多项式项系数有点特殊，需要用组合数和阶乘倒数来表示。

理解了这个转化后，就能处理很多类似的“错位重排”问题。

*End*

---

## 作者：封禁用户 (赞：2)

设 $f(i)$ 表示钦定 $i$ 个人不变，$g(i)$ 为恰好 $i$ 个人不变。

那么有关系式 $f(i) = \sum\limits_{j = i} ^ n {j \choose i} g(j)$，那么 $g(i) = \sum\limits_{j = i} ^ n (-1) ^ {j - i} f(j) {j \choose i}$。

再思考一下 $f(i)$ 其实是好算的。

$$
f(i) = {n \choose i} (n - i) !
$$

但是这个转移是明显有算重的，因为相同颜色的内部进行了交换后被多次计算。

那就通过 dp，让它在被选的时候去掉重复的，设 $dp(i, j)$ 表示前 $i$ 个人钦定了 $j$ 个。

记 $cnt_i$ 表示第 $i$ 种颜色的数量，

$$
dp(i, j) = \sum\limits_{k = 0} ^ j \frac{dp(i - 1, j - k) {cnt_i \choose k}}{(cnt_i - k)!}
$$
注意的是这里只是将没钦定的数去掉了重复的，但是并没有计算没有钦定的数的方案，所以最后对于 $dp(n, j)$ 还需要乘上 $(n - j) !$。

这样就做到了不重不漏计算了 $f(i)$。

最后答案为 $g(0)$，通过关系式计算就可以了。

---

## 作者：jr_zch (赞：2)

# 小 w 的喜糖

## 解题思路

首先发现，颜色相同的糖之间没有区别。

那么发现这个限制其实没有什么用，如果我们想求的是每颗糖都不同的方案数的话，令 $m$ 为颜色种类数，一个合法的答案就可以被拆分出 $\prod_{i=1}^m cnt_i!$ 种方案。最后把方案数除去这部分重复贡献即可。

由于题目要求的是**每个人都要与原来的不同**，直接算显然不太可行，那么考虑容斥。

遂可以设状态 $f_{i,j}$ 表示前 $i$ 个数存在有任意 $j$ 个相同的方案数。

讨论第 $i$ 个数是否相同……于是根本就转移不了，相同和不相同的情况都存在后效性。

注意到产生后效性的根本原因是决策为不相同时，要考虑选择一个其它颜色来填这个空，这一步选择的方案数既受到以前决策的影响，也会影响到后续决策。

**但是这并不会改变相同数的数量。**

**所以可以将这部分贡献延后到最后去整体的计算。**

没错，贡献不仅可以提前算还可以延后算。

具体而言就是先不考虑那些不相同的数，钦定完哪些数是相同的之后，由于我们想求的方案数是**存在** $j$ 个数相同即可，剩下的那些已经无所谓了，乱放就行了，代价即为 $(n-j)!$。

现在是只用讨论第 $i$ 个数相同时的贡献了，发现依然有后效性，但是后效性仅存在于同色之间。

注意到每种颜色的人都是等价的，于是考虑对每种颜色分别枚举该颜色内有多少个相同的，转移类似背包，贡献可以容易的用组合数计算。

具体地，设 $f_{i,j}$ 表示前 $i$ 种颜色，存在 $j$ 个相同的方案数。

转移即为 $f_{i,j}=\sum_{k=0}^{\min(cnt_i,j)} f_{i-1,j-k} \times C_{cnt_i}^k \times A_{cnt_i}^k$。

这样基本上就做完了，时间复杂度 $O(n^2)$。

## Code：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int maxn=2e3+7,mod=1e9+9;
int n,len,ans;
int a[maxn],c[maxn],f[maxn][maxn],fac[maxn],finv[maxn];

int qpow(int x,int y){
	if(!y) return 1;
	if(y==1) return x;
	int val=qpow(x,y>>1ll);
	if(y&1ll) return val*val%mod*x%mod;
	else return val*val%mod;
}

inline int calc(int x,int y){
	if(x<y) return 0;
	return fac[x]*finv[y]%mod*finv[x-y]%mod;
}

signed main(){
	//预处理阶乘和逆元 
	scanf("%lld",&n),fac[0]=1;
	for(int i=1;i<=n;i++) fac[i]=fac[i-1]*i%mod;
	finv[n]=qpow(fac[n],mod-2);
	for(int i=n-1;i>=0;i--) finv[i]=finv[i+1]*(i+1)%mod;
	for(int i=1;i<=n;i++) scanf("%lld",&a[i]),c[a[i]]++;
	sort(a+1,a+1+n);
	len=unique(a+1,a+1+n)-a-1;
	f[0][0]=1;
	//DP 部分 
	for(int i=1,pre=0;i<=len;i++){
		pre+=c[a[i]];
		for(int k=0;k<=c[a[i]];k++){
			for(int j=k;j<=pre;j++){
				f[i][j]=(f[i][j]+f[i-1][j-k]*calc(c[a[i]],k)%mod*calc(c[a[i]],k)%mod*fac[k])%mod;
			}
		}
	}
	//容斥部分 
	for(int i=0;i<=n;i++){
		if(i&1) ans=(ans-f[len][i]*fac[n-i]%mod+mod)%mod;
		else ans=(ans+f[len][i]*fac[n-i])%mod;
	}
	//开头提到的去重 
	for(int i=1;i<=len;i++) ans=ans*finv[c[a[i]]]%mod;
	printf("%lld",ans);
	return 0;
}
```

$$\text{Thanks for your reading}$$

---

## 作者：Engulf (赞：1)

考虑二项式反演，套路地设
- $g(k)$ 表示恰好 $k$ 个人手中的糖的种类与原来相同的方案数；
- $f(k)$ 表示钦定 $k$ 个人手中的糖的种类与原来相同的方案数。

$$f(k) = \sum_{i=k}^n\binom{i}{k} g(i) \Longleftrightarrow g(k) = \sum_{i=k}^n\binom{i}{k}(-1)^i f(i)$$

问题转化为求 $f$。

$n$ 个人相互交换，相当于随意排列，这与数组 $a$ 的初始形态无关，考虑将 $a$ 排序并去重便于处理。记糖的种类有 $m$ 个，第 $i$ 种糖共有 $c_i$ 个。

题目对两种方案不同的定义为：两个方案不同当且仅当，存在一个人，他手中的糖的种类在两个方案中不一样。这是不方便我们计数的，不妨先假设所有糖都有标号，最后把答案除以 $\prod\limits_{i=1}^{m}c_i!$ 即可去掉标号。

考虑 dp，设 $dp_{i, j}$ 表示考虑了前 $i$ 种糖，钦定了 $j$ 个人手中的糖种类不变。那对于第 $i$ 种糖，可以钦定 $0 \sim \min(j, c_i)$ 个有当前这种糖的人，记钦定 $k$ 个人，有 $\binom{c_i}{k}$ 种钦定方式，选好后，这 $c_i$ 种糖任意排列在这 $k$ 个位置，有 $\dfrac{c_i!}{(c_i - k)!}$ 种排列方式，根据乘法原理和加法原理，得到转移方程

$$dp_{i,j} = \sum_{k=0}^{\min(c_i, j)}dp_{i-1,j - k}\binom{c_i}{k}\dfrac{c_i!}{(c_i - k)!}$$

$dp_{m, i}$ 得到的是选定并排列好 $i$ 个不变的人，剩下的 $n - i$ 个人还没排列呢，他们自然是可以任意排列，所以乘上 $(n-i)!$。

$$f(i) = dp_{m, i}(n-i)!$$

答案为

$$g(0) = \sum_{i=0}^{n}(-1)^i f(i) = \sum_{i=0}^{n}(-1)^i dp_{m, i}(n-i)!$$

别忘了去掉标号，最终答案

$$\boxed{\dfrac{\sum\limits_{i=0}^{n}(-1)^i dp_{m, i}(n-i)!}{\prod\limits_{i=1}^m c_i!}}$$

$\Theta(n^2)$，因为你会感性地发现枚举 $i$ 和枚举 $k$ 的总和其实是 $n$。

---

## 作者：LastKismet (赞：1)

# Sol
“与原来的糖种类不同”不好求，转化为“与原来的糖种类相同”会好求很多。那么我们就是要求最后恰好 $0$ 个人与原来的糖种类相同的方案数。

经典容斥，二项式定理，考虑 $f(i)$ 表示钦定 $i$ 个人与原来的糖种类相同的方案数，最后答案是简单的：
$$
\sum_{i=0}^{n}(-1)^if(i)
$$

然后我们发现，$f(i)$ 也不是很好做的样子，如何呢？

本题中有多个种类相同的糖，使得问题变得复杂，我们先将之视作种类不同，最后答案统一乘上 $\prod\limits_{i=1}^na_i!^{-1}$ 即可。记 $a_i$ 为第 $i$ 种糖的个数。

$n$ 足够小，考虑二维 DP，记 $f(i,j)$ 为考虑前 $i$ 种糖，至少有 $j$ 个不变的方案数。

至少有 $j$ 个不变是经典的，我们钦定 $j$ 个数不参与交换，剩下的任意重排即可。为方便转移，在转移时不处理剩下的数任意重排的方案数，而在更新答案时一并更新。可得：
$$
f(i,j)=\sum_{k=0}^{a_i}f(i-1,j-k)\binom{a_i}{k}a_i^{\underline k}
$$

$\binom{a_i}{k}$ 就是从当前种糖中选出 $k$ 个位置钦定不变的方案数。最后 $a_i^{\underline k}$ 的系数是因为我们将所有糖视作各不相同，因此这些位置的糖可能不是原来的糖，而仅仅是同种的糖，需要额外处理。

# Code
```cpp
int n;
int c[N],a[N],s[N];
mint jc[N],iv[N];
mint f[N][N];

#define C(n,m) (jc[n]*iv[m]*iv[(n)-(m)])
#define A(n,m) (jc[n]*iv[(n)-(m)])
inline void init(int n){
    jc[0]=1;rep(i,1,n)jc[i]=jc[i-1]*i;
    iv[n]=1/jc[n];per(i,n,1)iv[i-1]=iv[i]*i;
}
inline void Main(){
    read(n);
    rep(i,1,n)read(c[i]),++a[c[i]];
    rep(i,1,n)s[i]=s[i-1]+a[i];
    f[0][0]=1;
    rep(i,1,n)rep(j,0,s[i])rep(k,0,min(j,a[i]))f[i][j]+=f[i-1][j-k]*C(a[i],k)*A(a[i],k);
    mint ans=0;
    rep(i,0,n)ans+=(i&1?-1:1)*f[n][i]*jc[n-i];
    rep(i,1,n)ans*=iv[a[i]];
    put(ans);
}
```

---

## 作者：ForwardStar (赞：1)

属于一类错排问题，于是正难则反，可以设 $g(i)$ 为恰好有 $i$ 个人的糖与原来相同的方案数，答案即为 $g(0)$。可以发现还是难啊！于是考虑二项式反演，设 $f(i)$ 为至少有 $i$ 个人糖与原来相同，显然：
$$
f(n)=\sum_{i=0}^{n}C_{n}^ig(i)
$$
据二项式反演，有：
$$
g(0)=\sum_{i=0}^{n}C_{i}^{0}(-1)^{i-0}f(i)=\sum_{i=0}^{n}(-1)^{i}f(i)
$$  
求得 $f(i)$ 即可。  
可以将相同的糖合并，得到 $m$ 种糖，第 $i$ 种糖有 $cnt_i$ 个。设 $dp_{i,j}$ 为选到第 $i$ 种糖时，有 $j$ 个人的糖和原来相同的方案数。为方便理解和计算，我们可以先将两个种类相同的糖看作是不同的，那么易得以下状态转移方程：
$$
dp_{i,j}=\sum_{k=0}^{\min(cnt_i,j)}C_{cnt_i}^kA_{cnt_i}^kdp_{i-1,j-k}
$$
可以理解为先选其中 $k$ 个人钦定为不变的，再选 $k$ 颗相同的糖分给他们。  
那么又有：
$$
f_i=\frac{dp_{m,i}(n-i)!}{\prod\limits_{j=0}^{m}cnt_j!}
$$
可以理解为，现将剩下的 $n-i$ 随意排列，再除掉相同糖之间的顺序。

---

## 作者：xzz_cat6 (赞：1)

# P10597 BZOJ4665 小 w 的喜糖
## Problem
给定 $n$ 个数，求有多少种排列满足：对于任意一个位置，其原先的数与现在的数不相等。

## Solution
首先我们先认为相同的糖是不同的，这样算出答案之后乘上 $\prod \frac{1}{t_i!}$ 即可，其中 $t_i$ 为第 $i$ 种颜色的个数。

接下来考虑二项式反演，令 $f(i)$ 表示至少 $i$ 个人拿到的糖与原先的种类相同的方案数，$g(i)$ 表示恰有 $i$ 个人拿到的糖与原先种类相同的方案数，根据二项式反演可得：
$$
f(n)=\sum_{i-n}^{N}\binom{i}{n}g(i)\Longleftrightarrow g(n)=\sum_{i=n}^{N}(-1)^{i-n}\binom{i}{n}f(i)
$$
答案即为 $g(0)$ 于是只需求出 $f(i)$ 即可，我们考虑 dp 求出它。设 $dp(i,j)$ 表示枚举到第 $i$ 种颜色，钦定了 $j$ 个人拿到的糖与原先种类相同，转移为：
$$
dp(i,j)=\sum_{p=0}^{\min(j,t_i)}dp(i-1,j-p)\times \binom{t_i}{p}\times t_i^{\underline p}
$$
而 $f(i)$ 就等于 $dp(n,i)\times (n-i)!$，代入求出 $g(0)$ 即可，复杂度 $O(n^2)$。
## Code
```cpp
#include<bits/stdc++.h>
#define int long long
#define N 2005
#define mod 1000000009
using namespace std;
int n,a[N],dp[N][N],ans,t[N];
int fac[N],inv[N];
int C(int a,int b){
	return fac[a]*inv[b]%mod*inv[a-b]%mod;
}
int A(int a,int b){
	return fac[a]*inv[a-b]%mod;
}
int qpow(int a,int b){
	int res=1;
	while(b){
		if(b&1)	res=res*a%mod;
		a=a*a%mod,b>>=1;
	}
	return res;
}
signed main(){
	cin>>n,fac[0]=1;
	for(int i=1;i<=n;i++)	cin>>a[i],t[a[i]]++;
	for(int i=1;i<=n;i++)	fac[i]=fac[i-1]*i%mod;
	inv[n]=qpow(fac[n],mod-2);
	for(int i=n-1;i>=0;i--)	inv[i]=inv[i+1]*(i+1)%mod;
	dp[0][0]=1;
	for(int i=1,sum=t[1];i<=n;i++,sum+=t[i]){
		for(int j=0;j<=sum;j++){
			int x=t[i],l=min(x,j);
			for(int p=0;p<=l;p++){
				dp[i][j]+=dp[i-1][j-p]*C(x,p)%mod*A(x,p)%mod;
				if(dp[i][j]>=mod)	dp[i][j]-=mod;
			}
		}
	}
	for(int i=0;i<=n;i++){
		int tmp=dp[n][i]*fac[n-i]%mod;
		if(i&1)	tmp=mod-tmp;
		ans+=tmp;
		if(ans>=mod)	ans-=mod;
	}
	for(int i=1;i<=n;i++)	ans=ans*inv[t[i]]%mod;
	cout<<ans<<'\n';
	return 0;
} 
```

---

## 作者：Laoshan_PLUS (赞：0)

# [BZOJ4665 小 w 的喜糖](https://www.luogu.com.cn/problem/P10597)

这道题可以说是二项式反演的经典应用。

第一次转化，题目中说使每个人手里的糖都不相同，类似于错排问题，而我们显然是不好直接进行处理的。于是考虑转化为计算使一部分人手里的糖与原来相同的方案数，如果记作 $g(i)$，那么答案就是 $g(0)$。

第二次转化，看到**恰好**，于是用二项式反演转化为求**钦定**。记钦定的方案为 $f(i)$，则二项式反演的公式为
$$
g(i)=\sum_{j=i}^n(-1)^{j-i}\binom jif(j)
$$
既然我们只需要求出 $g(0)$，那么根据上述公式，就有
$$
g(0)=\sum_{j=0}^n(-1)^jf(j)
$$
考虑如何求出 $f(0),f(1),\dots,f(n)$。不妨用 DP 来求解，设 $\mathit{dp}(i,j)$ 表示枚举到第 $i$ 种喜糖，钦定 $j$ 个人拿到的糖和原来相同的方案数。发现同种喜糖是相同的，而这一限制比较麻烦，不妨认为所有喜糖都是互不相同的，而我们只需在最后给答案乘上 $\prod\frac1{c_i!}$ 即可，其中 $c_i$ 是第 $i$ 种喜糖的数量。这样我们就暂时不用考虑去重问题，有转移方程
$$
\mathit{dp}(i,j)=\sum_{k=0}^{\min(j,c_i)}\mathit{dp}(i-1,j-k)\times\binom{c_i}k\times\mathrm A_{c_i}^k
$$
简单来说就是枚举在所有钦定的人中，有多少人的糖在当前种类里，即 $k$。那么我们首先要从原来就是这种糖的人中选出 $k$ 个人，然后再挑出 $k$ 个糖按顺序放在这些人手上。所以会先乘排列数然后乘组合数。

边界条件显然是 $\mathit{dp}(0,0)=1$。这样算下来之后，我们的 $f(i)$ 实际上是 $\mathit{dp}(m,i)\times(n-i)!$，因为 $\mathit{dp}(i,j)$ 的转移方程里只计算了钦定的方案数，而没有计算钦定以外的人随意排列的方案数。

那么现在我们有了 $f(i)$，就能算出 $g(0)$，然后再乘上 $\prod\frac1{c_i!}$，这个题就做完了。

```cpp
#include<bits/stdc++.h>
using namespace std;

using ll=long long;
constexpr int MAXN=2005;
constexpr ll MOD=1e9+9;
int n,c[MAXN],m;
ll fac[MAXN],inv[MAXN];
ll f[MAXN][MAXN];
ll power(ll a,ll b){
    ll res=1;
    for(;b;a=a*a%MOD,b>>=1)if(b&1)res=res*a%MOD;
    return res;
}
void init(int n){
	fac[0]=1;
	for(int i=1;i<=n;i++) fac[i]=fac[i-1]*i%MOD;
	inv[n]=power(fac[n],MOD-2);
	for(int i=n-1;~i;i--) inv[i]=inv[i+1]*(i+1)%MOD;
}
ll C(int n,int m){
	if(n<m) return 0;
	return fac[n]*inv[m]%MOD*inv[n-m]%MOD;
}
ll A(int n,int m){
	if(n<m) return 0;
	return fac[n]*inv[n-m]%MOD;
}

int main(){
	cin.tie(nullptr)->sync_with_stdio(0);
	cin>>n;
	init(n);
	for(int i=1,x;i<=n;i++) cin>>x,c[x]++,m=max(m,x);
	f[0][0]=1;
	for(int i=1,pre=c[1];i<=m;i++,pre+=c[i])
		for(int j=0;j<=pre;j++)
			for(int k=0;k<=min(j,c[i]);k++)
				f[i][j]=(f[i][j]+f[i-1][j-k]*C(c[i],k)%MOD*A(c[i],k))%MOD;
	ll ans=0;
	for(int i=0;i<=n;i++) ans=(ans+f[m][i]*fac[n-i]*(i&1?-1:1))%MOD;
	for(int i=1;i<=m;i++) ans=ans*inv[c[i]]%MOD;
	cout<<(ans+MOD)%MOD<<'\n';
	return 0;
}
```

---

## 作者：Jerrywang09 (赞：0)

正难则~反~考虑容斥原理。

对于每个 $k$，求钦定 $k$ 个人没有拿错的排列数。设 $c_1\cdots c_n$ 表示每种糖原来有几个人拿，$d_1\cdots d_n$ 表示每种糖钦定了几个人没有拿错。则有限制：
1. $d_i\le c_i$；
2. $\sum_{i=1}^n d_i=k$。

每种糖先钦定哪些人没有拿错，剩下的人可重排列，因此方案数为：
$$
(n-k)!\prod_{i=1}^n \binom {c_i} {d_i} \frac 1 {(c_i-d_i)!}
$$

设 $f(i,j)$ 表示前 $i$ 种糖钦定了 $j$ 个的人的方案数，把 $d_i$ 看成物品，即可背包 DP。最后容斥统计答案。

```cpp
// BZOJ4665 小 w 的喜糖
#include <cstdio>
#include <iostream>
#define ll long long
#define rep(i, s, t) for(int i=s; i<=t; ++i)
#define debug(x) cerr<<#x<<":"<<x<<endl;
const int N=2005, mod=1e9+9;
using namespace std;
char buf[1<<21], *p1=buf, *p2=buf;
#define gc() (p1==p2 && (p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
inline int read()
{
    int x=0, f=1; char c=gc();
    while(c<'0' || c>'9') c=='-' && (f=-1), c=gc();
    while('0'<=c && c<='9') x=(x<<3)+(x<<1)+c-'0', c=gc();
    return x*f;
}

inline ll qp(ll x, ll y=mod-2)
{
    ll res=1;
    for(; y; y>>=1, x=x*x%mod) if(y&1) res=res*x%mod;
    return res;
}
int n, c[N]; ll fac[N], inv[N], f[N][N], C[N][N];
inline void upd(ll &x, ll y) {x=x+y<mod?x+y:x+y-mod;}

int main()
{
#ifdef Jerrywang
    freopen("E:/OI/in.txt", "r", stdin);
#endif
    n=read(); fac[0]=1;
    rep(i, 1, n) c[read()]++, fac[i]=fac[i-1]*i%mod;
    inv[n]=qp(fac[n]);
    for(int i=n; i; i--) inv[i-1]=inv[i]*i%mod;
    rep(i, 0, n)
    {
        C[i][0]=1;
        rep(j, 1, i) C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;
    }
    f[0][0]=1; int sum=0;
    rep(i, 1, n)
    {
        rep(j, 0, sum) if(f[i-1][j])
            rep(k, 0, c[i])
                upd(f[i][j+k], f[i-1][j]*C[c[i]][k]%mod*inv[c[i]-k]%mod);
        sum+=c[i];
    }
    ll ans=0;
    rep(k, 0, n)
        ans=(ans+(k&1?-1:1)*fac[n-k]*f[n][k]%mod+mod)%mod;
    printf("%lld", ans);

    return 0;
}
```

---


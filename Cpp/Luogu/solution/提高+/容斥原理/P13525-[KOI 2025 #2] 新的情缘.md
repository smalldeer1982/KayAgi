# [KOI 2025 #2] 新的情缘

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

$N$ 对已经分手的伴侣为了寻找新的情缘而聚集在一起。每对伴侣由 1 名男性和 1 名女性组成，这 $N$ 对伴侣总共由 $N$ 名不同的男性和 $N$ 名不同的女性构成。他们分别坐在编号从 1 到 $2N$ 的 $2N$ 张椅子上，并满足以下条件。

*   没有两个人坐在同一张椅子上。也就是说，每张椅子上恰好只坐了 1 个人。
*   第 $i$ 对分手的伴侣中，男性坐在 $L_i$ 号椅子上，女性坐在 $R_i$ 号椅子上。($1 \le i \le N$)
*   $1 \le L_i < R_i \le 2N(1 \le i \le N)$
*   不存在满足 $L_i < L_j < R_i < R_j$ 的情况。($1 \le i, j \le N$)

他们计划组成 $N$ 对满足以下条件的新伴侣。

*   新伴侣必须由 1 名男性和 1 名女性组成，并且每个人都必须恰好属于 1 对新伴侣。
*   每个人都必须与不是自己原配的人配对。
*   对于任意一对新伴侣，如果男性所坐椅子的编号为 $l$，女性所坐椅子的编号为 $r$，则必须满足 $l < r$。

例如，我们来考虑 $N=3$ 且 $L_1=1, R_1=6, L_2=2, R_2=3, L_3=4, R_3=5$ 的情况。坐在 1 号椅子的男性和坐在 6 号椅子的女性是已经分手的伴侣，因此不能成为新伴侣。坐在 4 号椅子的男性和坐在 3 号椅子的女性虽然不是分手的伴侣，但由于男性所坐椅子的编号更大，因此也不能成为新伴侣。

反之，坐在 1 号椅子的男性和坐在 3 号椅子的女性可以成为新伴侣。坐在 2 号椅子的男性和坐在 5 号椅子的女性，以及坐在 4 号椅子的男性和坐在 6 号椅子的女性，也都可以成为新伴侣。通过这种方式，可以组成满足条件的 3 对新伴侣。

你需要计算组成 $N$ 对新伴侣的不同方法的总数。两种组成 $N$ 对新伴侣的方法被认为是不同的，是指存在一对新伴侣，它只在其中一种方法中出现。

对于上面给出的例子，可以证明组成 3 对伴侣的方法是唯一的。因此，这种情况的答案是 1。

方法的数量可能非常大，请输出其对 $10^9 + 7$ 取模后的余数。

在一次输入中，你需要解决 $T$ 个测试用例。

## 说明/提示

### 限制条件

*   所有给定的数都是整数。
*   $1 \le T \le 100$
*   $1 \le N \le 3\,000$
*   如果将所有测试用例的 $N$ 的总和记为 $S$，则 $1 \le S \le 3\,000$。
*   $1 \le L_i < R_i \le 2N(1 \le i \le N)$
*   $L_1, L_2, \cdots, L_N, R_1, R_2, \cdots, R_N$ 互不相同。
*   不存在满足 $L_i < L_j < R_i < R_j$ 的情况。($1 \le i, j \le N$)

### 子任务

1.  (11 分) $N \le 8, S \le 800$。
2.  (32 分) $N \le 16, S \le 1\,600$。
3.  (20 分) $N \le 100, S \le 2\,000$，且不存在满足 $L_i < L_j < R_j < L_k < R_k < R_i$ 的情况 ($1 \le i, j, k \le N$)。
4.  (27 分) $N \le 100, S \le 2\,000$。
5.  (10 分) 无额外限制条件。

## 样例 #1

### 输入

```
5
1
1 2
2
1 4
2 3
3
1 6
2 5
3 4
3
1 6
2 3
4 5
4
1 8
5 6
2 7
3 4```

### 输出

```
0
1
2
1
6```

# 题解

## 作者：chen_zhe (赞：4)

### 子问题 1

我们把坐在 $L_i$ 号椅子上的男人和坐在 $R_i$ 号椅子上的女人成为新情侣的情况称为 $L_i$ 和 $R_i$ 被匹配。每个 $L_i$ 匹配的 $R_j$ 是 $R_1, R_2, \dots, R_N$ 中的一个，并且都各不相同，因此需要检查的情况有 $N!$ 种。当固定了每个 $L_i$ 匹配的 $R_j$ 后，只需检查 $i \ne j, L_i < R_j$ 这两个条件，这可以在 $O(N)$ 的时间复杂度内完成。因此，可以用 $O(N \times N!)$ 的时间复杂度解决此问题。

### 子问题 2

接下来，我们假设已经将 $R_1, R_2, \dots, R_N$ 排好序，使其满足 $R_1 < R_2 < \dots < R_N$。我们按 $R_1, R_2, \dots, R_N$ 的顺序来为它们选择匹配的 $L_i$。设当前已匹配的 $L_i$ 的集合为 $S$，我们用 `dp[S]` 来定义能够达到该状态的方案数。与 $R_j$ 匹配的 $L_i$ 必须满足 $L_i \notin S, L_i < R_j, i \ne j$，匹配后 $S$ 会变为 $S \cup \{L_i\}$。在为 $R_j$ 选择匹配对象之前，$|S| = j-1$，因此对于每个 $S$，会发生 $O(N)$ 次 `dp` 状态转移。$S$ 可以用长度为 $N$ 的位掩码来表示，因此可能的 $S$ 的数量为 $O(2^N)$。因此，可以用 $O(N \times 2^N)$ 的时间复杂度解决此问题。

也存在使用容斥原理的解法。关于这一点，我们在子问题 5 的解法中进行了阐述。

### 子问题 3

我们将 $(L_i, R_i)$ 看作是编号为 $i$ 的顶点，对于满足 $L_i < L_j < R_j < R_i$ 的 $(i, j)$，我们添加一条连接顶点 $i$ 和顶点 $j$ 的边，来构造一个图。根据问题条件，每个连通分量都是一棵树，而在子问题 3 中，每个连通分量都是一条链。

我们按 $R_1, R_2, \dots, R_N$ 的顺序，考虑 $R_i$ 所属的连通分量的结束位置。此时，如果存在未匹配的 $R_i$，那么这样的 $R_i$ 将永远无法被匹配。因此，$R_i$ 所属连通分量中的 $L_i$ 和 $R_i$ 只会在该连通分量内部发生匹配。通过这个逻辑，可以用数学归纳法证明，不存在向连通分量外部的匹配。因此，对每个连通分量独立地解决问题，然后将各自的答案相乘，即可得到整个问题的答案。

当连通分量是一条链时，问题等价于计算满足所有 $i$ 都有 $p_i \ne i$ 的排列数量。这就是著名的“错排问题”（derangement），可以在 $O(N)$ 的时间复杂度内计算。设排列的长度为 $n$，且 $p_n=x$。$x$ 可能的值有 $n-1$ 种。如果 $p_1=n$，则情况与长度为 $n-2$ 的问题相同。否则，存在某个 $x \ne y$ 使得 $p_y=n$。如果我们将 $p_y$ 删去，并将 $p_x$ 改为 $x$，得到的新排列 $Q$ 是一个长度为 $n-1$ 的错排，且与 $P$ 一一对应。因此，设长度为 $n$ 的错排数量为 $D_n$，则有 $D_n = (n-1)(D_{n-1} + D_{n-2})$ 成立。因此，子问题 3 可以在 $O(N)$ 的时间复杂度内解决。

### 子问题 4

对于连接顶点 $i$ 和 $j$ 的边，如果 $L_i < L_j < R_j < R_i$，我们就称 $i$ 是 $j$ 的父节点。对于每个连通分量，不存在父节点的顶点是唯一的，我们可以把它看作是树的根。由于树的根被定义了，所以子树、祖先等也都能很好地定义。

我们定义 `dp[s][j]` 为只考虑 $s$ 号顶点的子树时，有 $j$ 对男女未被匹配的方案数。我们通过 DFS 来计算 `dp`。设 $s$ 号顶点的孩子为 $v_1, v_2, \dots, v_k$。（其中 $R_{v_1} < R_{v_2} < \dots < R_{v_k}$）
我们定义 `dp2[v_i][j]` 为只考虑 $v_1, v_2, \dots, v_i$ 号顶点的子树时，有 $j$ 对男女未被匹配的方案数。为了计算 `dp2[v_{i+1}]`，我们需要将 `dp2[v_i]` 和 `dp[v_{i+1}]` 合并。此时，我们可以从 $v_1, v_2, \dots, v_i$ 号顶点的子树中未匹配的男人中选出 $z$ 个，从 $v_{i+1}$ 号顶点的子树中未匹配的女人中选出 $z$ 个进行匹配。用公式表示就是 `dp2[v_{i+1}][x+y-z] += dp2[v_i][x] * dp[v_{i+1}][y] * C(x,z) * C(y,z) * z!`。（$a \leftarrow b$ 表示将 $b$ 的值累加到变量 $a$ 中）

为了将 `dp2[v_k]` 的结果转移到 `dp[s]`，我们需要对当前顶点对应的 $L_s$ 和 $R_s$ 进行匹配。
- 如果 $L_s$ 和 $R_s$ 都不匹配，则 `dp[s][j+1] += dp2[v_k][j]`。
- 如果只匹配 $L_s$ 或 $R_s$ 中的一个，则有 2 种选择（选 $L_s$ 或 $R_s$），以及 $j$ 种选择匹配对象的方式，总共有 $2j$ 种情况。即 `dp[s][j] += dp2[v_k][j] * 2j`。
- 如果 $L_s$ 和 $R_s$ 都匹配，则选择匹配对象的方式各有 $j$ 种，相乘得到 $j^2$ 种情况。即 `dp[s][j-1] += dp2[v_k][j] * j^2`。

设各连通分量的根为 $r_1, r_2, \dots, r_c$，则答案为 `dp[r_1][0] * dp[r_2][0] * ... * dp[r_c][0]`。
根据实现方式，时间复杂度为 $O(N^3)$ 或 $O(N^4)$。

### 子问题 5

我们用容斥原理来思考。对于 $S=\{i_1, i_2, \dots, i_k\}$，我们强制 $L_i$ 和 $R_i$ 匹配（当 $i \in S$ 时），而当 $i \notin S$ 时，我们忽略 $L_i$ 和 $R_i$ 不能匹配的条件，进行匹配。设这种情况的方案数为 $f(S)$，根据容斥原理，答案为 $\sum (-1)^{|S|} f(S)$。如果直接实现，时间复杂度为 $O(N \times 2^N)$，可以解决子问题 1 和 2。

对于一个固定的 $S$，我们按 $R_1, R_2, \dots, R_N$ 的顺序来考虑为 $R_j$ 进行匹配。如果 $j \in S$，我们定义 $a_j=-1$，并将 $R_j$ 与 $L_j$ 匹配。如果 $j \notin S$，我们定义 $a_j$ 为 $R_j$ 可以匹配的 $L_i$ 的数量，并从中任选一个进行匹配。此时，可以发现 $a_1 a_2 \dots a_N = (-1)^{|S|} f(S)$。另一方面，设 $i$ 号顶点的祖先为 $p_1, p_2, \dots, p_d$。当 $i \notin S$ 时，$a_i$ 的值与满足 $j \notin S$ 的 $p_j$ 的数量加 1 是相同的。我们基于这个事实来进行 `dp`。

我们定义 `dp[s][j]` 为当 $s$ 的祖先中不属于 $S$ 的元素有 $j-1$ 个时，$s$ 的子树内所有 $a_i$ 的乘积之和。也就是说，$a_s$ 只能是 $j$ 或 $-1$。当 $a_s=j$ 时，到其孩子节点时，$j$ 的值会增加 1。而当 $a_s=-1$ 时，到其孩子节点时，$j$ 的值保持不变。将此分别写成公式就是：`dp[s][j] += (dp[v_1][j+1] * ... * dp[v_k][j+1]) * j`，以及 `dp[s][j] += (dp[v_1][j] * ... * dp[v_k][j]) * (-1)`。

答案是 `dp[r_1][1] * dp[r_2][1] * ... * dp[r_c][1]`。时间复杂度为 $O(N^2)$。

```cpp
#include <bits/stdc++.h>

using namespace std;
using ll = long long;

constexpr int MOD = 1e9 + 7;

int a[6060];
ll dp[6060][3030], dp2[6060][3030];

void dfs(int s, int e, int lim){
    fill(dp[s]+1, dp[s]+lim+1, 1);
    fill(dp2[s]+1, dp2[s]+lim+2, 1);

    for (int i=s+1;i<e;i=a[i]+1){
        dfs(i, a[i], lim+1);
        for (int j=1;j<=lim+1;j++){
            dp2[s][j] = dp2[s][j] * dp[i][j] % MOD;
        }
    }
    
    for (int j=1;j<=lim;j++){
        dp[s][j] = dp2[s][j+1] * j % MOD;
        dp[s][j] -= dp2[s][j];
        if (dp[s][j] < 0) dp[s][j] += MOD;
    }
}

void solve(){
    int n;
    scanf("%d", &n);

    for (int i=1;i<=n;i++){
        int x, y;
        scanf("%d %d", &x, &y);
        a[x] = y;
    }

    ll ans = 1;
    for (int i=1;i<=n*2;i=a[i]+1){
        dfs(i, a[i], 1);
        ans = ans * dp[i][1] % MOD;
    }

    printf("%lld\n", ans);
}

int main(){
    int t;
    scanf("%d", &t);
    while(t--) solve();
}
```

---

## 作者：Ryanhao (赞：0)

:::info[生活小技巧]
碰到区间包含类型的问题可以试图转换成树。
:::

## 思路

我们可以试图把本题转换成森林：把分手的 CP 俩的座位连成线段，看成一段区间，再把直接包含关系的两个区间连边，如图。

:::align{center}
![](https://cdn.luogu.com.cn/upload/image_hosting/owo5xciv.png)
:::

考虑使用容斥原理统计答案。我们先允许分手的 CP 复合。如上图，我们可以用类似括号序列的思想，枚举所有人，如果是男生，加入一个东西中，如果是女生，从中选出一个男生。显然对于每一位女生来说，她能选的男友数就是当前节点的深度[^1]（默认根的深度为 $1$），那么总的答案就是所有节点的深度的乘积。

[^1]: 为什么感觉有点炸裂？？？

别忘了题目不允许分手又复合的情况出现。我们令 $c_u$ 表示 $u$ 的祖先中的没有复合的 CP 数量，答案当然也是 $\prod\limits_{i=1}^{n} c_i$。我们使用树上 DP，设 $f_{u,i}$ 为当 $u$ 的祖先中有 $i$ 对复合的 CP 时，以 $u$ 为根的子树的答案数。我们令 $v \in \operatorname{son}u$。转移的话，分两种情况，$v$ 是否复合：如果 $v$ 复合，对 $u$ 的贡献就是 $-f_{v,i}$（因为我们要减去 CP 复合的情况），否则就是 $f_{v,i+1}\times i$（参考前面允许复合的统计）。

总答案就是 $\prod\limits_{r} f_{r,1}$，其中 $r$ 表示森林中每棵树的根。

## ACCode

```cpp
#include <cstdio>
#include <algorithm>
#include <vector>
#include <cstring>
#include <stack>
using namespace std;
typedef long long ll;
#ifdef __unix__
#define getchar getchar_unlocked
#endif 

int read() {
	int x = 0; char c = getchar();
	while (c < '0' || c > '9')
		c = getchar();
	while (c >= '0' && c <= '9') {
		x = (x<<1)+(x<<3)+(c^'0'); 
		c = getchar();
	} 
	return x;
}

const int maxn = 3e3+5;
const ll mod = 1e9+7;

vector<int> G[maxn];
bool isr[maxn]; 
ll f[maxn][maxn],tmp[maxn];
int col[maxn<<1];

void ddd(int u, int d) {
	for (int v : G[u]) ddd(v,d+1);
	for (int i = 1; i <= d+1; i++) tmp[i] = 1;
	for (int v : G[u])
		for (int i = 1; i <= d+1; i++)
			tmp[i] = tmp[i]*f[v][i]%mod;
	for (int i = 1; i <= d; i++) 
		f[u][i] = ((tmp[i+1]*i%mod-tmp[i])%mod+mod)%mod;
}

int mian() {
	int n = read();
	for (int i = 1; i <= n; i++)
		col[read()] = col[read()] = i;
	stack<int> s;
	for (int p = 1; p <= (n<<1); p++) {
		// 类似括号序列建树 
		if (s.empty()) {
			s.push(col[p]);
			isr[col[p]] = 1;
			// 如果是根就标记 
		} else if (s.top() != col[p]) {
			G[s.top()].push_back(col[p]);
			s.push(col[p]);
		} else s.pop();
	}
	ll ans = 1;
	for (int r = 1; r <= n; r++)
		if (isr[r]) {
			ddd(r,1);
			ans = ans*f[r][1]%mod;
		}
	printf("%lld\n",ans);
	return n;
}

int main() {
	int T = read();
	while (T--) {
		int n = mian();
		for (int i = 1; i <= n; i++) {
			col[i] = isr[i] = 0;
			G[i].clear();
		} // 多测不清空，__________ 
	}
	return 0;
}
```

---


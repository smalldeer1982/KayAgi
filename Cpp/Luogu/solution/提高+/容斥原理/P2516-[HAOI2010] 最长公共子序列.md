# [HAOI2010] 最长公共子序列

## 题目描述

字符序列的子序列是指从给定字符序列中随意地（不一定连续）去掉若干个字符（可能一个也不去掉）后所形成的字符序列。令给定的字符序列$X=\{x_0,x_1,\cdots ,x_{m-1}\}$，序列$Y=\{y_0,y_1,\cdots ,y_{k-1}\}$ 是 $X$ 的子序列，存在 $X$ 的一个严格递增下标序列 $\{i_0,i_1,\cdots,i_{k-1}\}$ ，使得对所有的$j=0,1,\cdots,k-1$ ，有 $x_{ij}=y_j$ 。例如，$X=\verb!"ABCBDAB"!$ ，$Y=\verb!"BCDB"!$ 是 $X$ 的一个子序列。对给定的两个字符序列，求出他们最长的公共子序列长度，以及最长公共子序列个数。


## 样例 #1

### 输入

```
ABCBDAB.
BACBBD.```

### 输出

```
4
7```

# 题解

## 作者：FlashHu (赞：90)

一进来就看到一个多月前秒了此题的ysn和YCB%%%

最长公共子序列的$O(n^2)$的求解，Dalao们想必都很熟悉了吧！不过蒟蒻突然发现，用网格图貌似可以很轻松地理解这个东东？

设字符串长度为$n,m$，那么想象我们有一个$n+1$行$m+1$列的网格图，只能从左下角往右、上两个方向走。定义每条路径的长度都为$1$。记第$i$行第$j$列为$(i,j)$。

~~话说网格图真tm难画~~

![](https://cdn.luogu.com.cn/upload/pic/31692.png)

求最长公共子序列本质上是在两个序列中寻找最多的配对，而且这些配对的位置在序列中的位置也要分别递增。

那么，如果$x_i$与$y_j$相等，那么我们就从$(i-1,j-1)$向$(i,j)$连一条边。这在网格图中分明是一条条捷径，那么我们要寻找最长公共子序列，可不可以转化为寻找最短路，或者说寻找经过捷径次数最多的路径呢？

![](https://cdn.luogu.com.cn/upload/pic/31700.png)

这个模型是很巧妙的，满足了配对的位置在序列中的位置分别递增（因为只能往右、上走）。

那么再看第二问。显然在这个模型中，不同的公共子序列对应的，不是至少有一条边不相同的路径，而是至少有一条**捷径**不相同的路径。那么这个该怎么DP呢？

设到达$(i,j)$最多能经过的捷径数（即序列的两个前缀的最长公共子序列长度）为$mf_{i,j}$，方案数为$f_{i,j}$。显然$(i,j)$可以从$(i-1,j)$和$(i,j-1)$转移，如果$x_i=y_j$那么还可以从$(i-1,j-1)$转移（$mf$加上$1$）。依次转移，如果新的$mf$更大则直接覆盖原信息，如果$mf$相等则$f$相加。

然而，再次注意不同路径的定义。那么是不是可能存在这样一种情况：到$(i-1,j-1)$的一条路径，分别转移给了$(i-1,j)$和$(i,j-1)$，而再一次转移给了$(i,j)$，没有经过不同的捷径，却计算了两遍！显然只有$mf_{i-1,j-1}=mf_{i,j}$的时候上述情况才会发生，那么这时我们从$f_{i,j}$减去$f_{i-1,j-1}$即可。

思路都清晰了。在开始码DP之前，我们还需要注意这个DP的过程，每行只会从上一行转移，于是使用滚动数组优化空间，防止MLE。

```cpp
#include<bits/stdc++.h>
#define RG register
#define I inline
#define R RG int
#define G c=getchar()
using namespace std;
typedef long long LL;
const int N=5009,YL=1e8;
char x[N],y[N];
int ff[N],gg[N],mff[N],mgg[N];
int main(){
    scanf("%s%s",x+1,y+1);
    R n=strlen(x+1)-1,m=strlen(y+1)-1,i,j,*f=ff,*g=gg,*mf=mff,*mg=mgg;
    g[0]=1;for(j=0;j<=m;++j)f[j]=1;
    for(i=1;i<=n;++i,swap(f,g),swap(mf,mg)){//滚动数组
        memset(g +1,0,m<<2);//注意清空
        memset(mg+1,0,m<<2);
        for(j=1;j<=m;++j){//三方向转移
            if(x[i]==y[j])mg[j]=mf[j-1]+1,g[j]=f[j-1];
            if(mf[j]>mg[j])mg[j]=mf[j],g[j]=f[j];//覆盖
            else if(mf[j]==mg[j])(g[j]+=f[j])%=YL;//相加
            if(mg[j-1]>mg[j])mg[j]=mg[j-1],g[j]=g[j-1];
            else if(mg[j-1]==mg[j])(g[j]+=g[j-1])%=YL;
            if(mf[j-1]==mg[j])(g[j]+=YL-f[j-1])%=YL;//减掉重复的部分
        }
    }
    printf("%d\n%d\n",mf[m],f[m]);
    return 0;
}
```

---

## 作者：ysner (赞：48)

题目大意：给定两个长度为n,m字符串，求最长公共子序列长度和方案数

题解：第一问相信大家都会...f[i][j]表示第一个字串前i个，第二个字串前j个最长子序列的长度f[i][j]={max(f[i][j-1],f[i-1][j]) or f[i-1][j-1]+1(a[i]=b[j])}

然后第二个问，我们考虑f[i][j]=k,那么就加上f[i-1][j]和f[i][j-1]中=k的方案数。

如果a[i]=b[j],那么还要算上f[i-1][j-1]的方案数；但是如果a[i]!=b[j]且f[i-1][j-1]=k，就要减去它的方案数了。

另外，一定要开滚动数组（一次只存两状态即可），否则MLE等着你。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<cstdlib>
#include<algorithm> 
#define mod 100000000
#define ll long long
#define re register 
using namespace std;
int f[2][5005]={},r[2][5005]={};//必须开滚动数组，不开绝对爆空间,由于动态规划中，一个阶段的决策只受上一个阶段的影响，
//因此可以将以前的状态覆盖掉。只要存两个状态，故只开第一个下标为0~1的二维数组  
//r[i][j]存第一个字串前i个（一直被轮换），第二个字串前j个最长子序列的个数 
char s1[5005]={},s2[5005]={};
int n,m;
int main()
{    
    scanf("%s",s1+1);//s1+1代表从s1[1]开始读入数据，s[0]不读入 
    n=strlen(s1+1)-1;
    scanf("%s",s2+1);
    m=strlen(s2+1)-1;
    re int now=1,pre=0;//这两个变量用来判断两个状态中哪个是以前状态（pre），哪个是现在状态（now）（滚动数组的产物） 
    for(re int k=0;k<=m;k++)
      r[0][k]=1;//初始化，长度为0最长子序列方案数为1（第一个序列长度为0） 
    r[1][0]=1;//长度为0最长子序列方案数为1（第二个序列长度为0） 
    for(re int i=1;i<=n;i++)
    {
        for(re int j=1;j<=m;j++)
        {
            f[now][j]=max(f[pre][j],f[now][j-1]);
            r[now][j]=0;//后面的方案数都是由前面加过来的 
            if(s1[i]==s2[j])f[now][j]=max(f[now][j],f[pre][j-1]+1); 
            if(s1[i]==s2[j]&&f[now][j]==f[pre][j-1]+1) r[now][j]+=r[pre][j-1];
            if(f[pre][j]==f[now][j]) r[now][j]+=r[pre][j];
            if(f[now][j-1]==f[now][j]) r[now][j]+=r[now][j-1];//加上f[i-1][j]和f[i][j-1]中=k的方案数
            if(f[pre][j-1]==f[now][j]) r[now][j]-=r[pre][j-1];//如果a[i]!=b[j]且f[i-1][j-1]=k，就要减去它的方案数
            r[now][j]=(r[now][j]+mod)%mod;//+mod可以省略 
        }
        now=pre;pre=1-pre;//滚动    
    }
    printf("%d\n%d",f[pre][m],r[pre][m]);
    return 0;
}
```

---

## 作者：PigAunt (赞：22)

# P2516 [HAOI2010]最长公共子序列

## 问题分析

在最长公共子序列问题的基础上，本题要求输出最长公共子序列（后文简称LCS）的个数。

难点：**尽管 LCS 长度固定， LCS 不一定只有一种**。

要找到 LCS 的个数，我们可以从转移的过程入手。
若以 $d(i, j)$ 表示序列 $A$ 从 $1$ 到 $i$，序列 $B$ 从 $1$ 到 $j$ 的LCS长度，那么 $d(i, j)$ 可能有以下三种转移方式：

+ $d(i, j) = d(i - 1, j - 1) + 1,  a_i = b_j$
+ $d(i, j) = d(i - 1, j)$
+ $d(i, j) = d(i, j - 1)$

可以发现，要求长度为 $d(i, j)$ 的 LCS 的个数，只需要知道长度为 $d(i, j)$ 转移来源的 LCS 的个数，我们就可以推出最终的答案。

因此，如果用 $num(i, j)$ 表示长度为 $d(i, j)$ 的 LCS 的个数，$num(i, j)$ 就可以如此转移：

+ 若从 $d(i - 1, j - 1)$ 转移：$num(i, j) = num(i, j) + num(i - 1, j - 1),  a_i = b_j$
+ 若从 $d(i - 1, j)$ 转移：$num(i, j) = num(i, j) + num(i - 1, j)$
+ 若从 $d(i, j - 1)$ 转移：$num(i, j) = num(i, j) + num(i, j - 1)$

特殊情况：如果 $d(i - 1, j)$ 和 $d(i, j - 1)$ 都从 $d(i - 1, j - 1)$ 转移，即 $a_i \neq b_j \land d(i, j) = d(i - 1, j - 1)$，就多加了一次，应当减去，即：

+ $num(i, j) = num(i, j) - num(i - 1, j - 1), a_i \neq b_j \land d(i, j) = d(i - 1, j - 1)$

## 细节问题

+ 内存限制125MB,若使用 `int d[5005][5005]` 和 `int num[5005][5005]`开二维数组，空间约为191MB，需要使用滚动数组压缩空间。
+ 取模应当每步取模，但本题数据并没有卡这个地方。如果卡了这个地方，一般开 `long long` 可以过。
+ 如果使用 `std::string` 作为字符串容器，数组 `d[t][j]` 和 `num[t][j]` 仍要从1开始，否则会出现越界问题。

## 代码实现

```cpp
#include <iostream>
 
const int N = 5005, MOD = 1e8;
 
int la, lb, d[2][N], num[2][N], t = 0;
std::string a, b;
 
int main()
{
    std::cin >> a >> b;
    la = a.length(), lb = b.length();
    la--, lb--;
    
    for (int i = 0; i <= lb; i++)
    	num[0][i] = 1;
    num[1][0] = 1;
    
    for (int i = 1; i <= la; i++, t ^= 1)
    {
        for (int j = 1; j <= lb; j++)
        {
        	num[t ^ 1][j] = 0;
            if (a[i - 1] == b[j - 1])
            {
                d[t ^ 1][j] = d[t][j - 1] + 1;
                num[t ^ 1][j] += num[t][j - 1];
            }
            else
            {
            	d[t ^ 1][j] = std::max(d[t][j], d[t ^ 1][j - 1]);
            }
            
            if (d[t ^ 1][j] == d[t ^ 1][j - 1])
            {
            	num[t ^ 1][j] += num[t ^ 1][j - 1];
            }
            if (d[t ^ 1][j] == d[t][j])
            {
            	num[t ^ 1][j] += num[t][j];
            }
            if (a[i - 1] != b[j - 1] && d[t ^ 1][j] == d[t][j - 1])
            {
            	num[t ^ 1][j] -= num[t][j - 1];
            }
            num[t ^ 1][j] = num[t ^ 1][j] % MOD;
        }
    }

    std::cout << d[t][lb] << std::endl
              << (num[t][lb] + MOD) % MOD << std::endl;
    return 0;
}
```

---

## 作者：Suzt_ilymtics (赞：19)

[题目传送](https://www.luogu.com.cn/problem/P2516)

[更好的阅读体验？](https://www.cnblogs.com/Silymtics/p/15036609.html)

## Description

> 求两个字符串 $a,b$ 的最长公共子序列以及出现次数。

## Solution

看数据范围感觉是个 $O(nm)$  DP，可是我不会写唉，那先把暴力搞出来吧。


设 $f_{l,r}$ 表示第一个字符串匹配到 $l$，第二个字符串匹配到 $r$，并且子序列以 $a_l,b_r$ 为结尾的最长长度。同时记录一个 $g_{l,r}$ 表示出现次数。

可以推出一个比较显然的转移方程：

$$f_{l,r} = \max\{f_{i,j} + 1\}(1 \le i < l,1 \le j < r,a_i = b_j)$$

$$g_{l,r} = \sum_{i=1}^{l-1}\sum_{j=1}^{r-1}g_{i,j}(f_{l,r} = f_{i,j}+1)$$

复杂度 $O(n^2m^2)$，期望得分 $40pts$。

考虑优化，观察这些状态从哪转移的。

![](https://cdn.luogu.com.cn/upload/image_hosting/su04udty.png)

假设我们现在更新 $f_{l,r}$。

我们需要知道什么？黄色矩阵中的最大值。

更新 $g_{l,r}$ 呢，黄色矩阵中所有拥有最大值的 $f_{i,j}$ 所对应的 $g_{i,j}$ 的和。

所以我们可以设 $Max_i = \max_{0\le x<l} \{ f_{x,i}\}, cnt_{i,y} = \sum_{j=0}^{l-1}g_{i,j}(f_{i,j}=y)$。

因为 $Max_i$ 和 $cnt_{i,y}$ 维护的都是 $0 \sim l-1$ 行的情况，所以我们需要不断更新他们的值。

注意所有的这一行的信息都必须在这一行扫完后再更新。

在递推每一行时，记录一个 `nowM` 和 `sum` 分别表示到当前列之前的最大值，和最大值的出现次数。这样就可以把经过的每一列的信息合并在一起，方便更新 $f_{l,r}$ 的值。

时间复杂度 $O(nm)$。

开这么多二维数组一定会被卡空间。

我们发现 $g_{l,r}$ 每次只需要存一行留着更新即可，前面的几行都没有用。

然后发现 $f_{l,r}$ 在状态转移过程中根本没涉及到第一维什么事，直接压掉。

只留下一个二维数组，空间应该够用了。

但是我们发现 $cnt_{i,y}$ 只会用到它这一列的最大值 $Max_i$ 所对应的数。那么我们只对 $cnt_{i,Max_i}$ 维护即可，又压掉一维！

几个注意的点：

- 更新时候的大前提 $a_l=b_r$ 还是要保留的。
- 但是在记录 `nowM` 和 `sum` 时，不管两个字符是否相等都要更新。
- 如果你想给 $f$ 初始化极小值，那么在 $f_r < 0$ （压维后） 时就不要更新对应的 $cnt_r$ 了。

## Code

```cpp
/*
Work by: Suzt_ilymics
Problem: 不知名屑题
Knowledge: 垃圾算法
Time: O(能过)
*/
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<queue>
#define LL long long
#define orz cout<<"lkp AK IOI!"<<endl

using namespace std;
const int MAXN = 1e5+5;
const int INF = 1e9+7;
const int mod = 1e8;

int n, m;
char a[5010], b[5010];
int f[5010], Max[5050], cnt[5050], p[5050];

int read(){
    int s = 0, f = 0;
    char ch = getchar();
    while(!isdigit(ch))  f |= (ch == '-'), ch = getchar();
    while(isdigit(ch)) s = (s << 1) + (s << 3) + ch - '0' , ch = getchar();
    return f ? -s : s;
}

int main()
{
    scanf("%s", a + 1); scanf("%s", b + 1);
    n = strlen(a + 1), m = strlen(b + 1); 
    memset(f, 128, sizeof f);
    memset(Max, 128, sizeof Max);
    f[0] = 0; Max[0] = 0; cnt[0] = 1;
    for(int l = 1; l <= n; ++l) {
        for(int r = 1, nowM = 0, sum = 0; r <= m; ++r) {
            if(nowM < Max[r - 1]) nowM = Max[r - 1], sum = cnt[r - 1];
            else if(nowM == Max[r - 1]) sum = (sum + cnt[r - 1]) % mod;
            if(a[l] != b[r]) continue;
            f[r] = nowM + 1;
            p[r] = sum;
        }
        for(int r = 0; r <= m; ++r) {
            if(f[r] < 0) continue;
            if(Max[r] < f[r]) Max[r] = f[r], cnt[r] = p[r];
            else if(Max[r] == f[r]) cnt[r] = (cnt[r] + p[r]) % mod;
            p[r] = 0;
        }
    }
    printf("%d\n%d", f[m] - 1, cnt[m]);
    return 0;
}
```

---

## 作者：Singularity0909 (赞：10)

这是本蒟蒻在洛谷上AC的第二道紫题Orz，听了队友的讲解我对这题的递推过程颇有感触，特此给出详细解析。

**a、b两个字符串的最长公共子序列的长度是唯一的，但最长公共子序列不是唯一的。**

用f[i][j]表示**a的前i位字符子串和b的前j位字符子串的最长公共子序列**（下称lcm(i, j)）的长度，g[i][j]表示**lcm(i, j)的种数**。

要求最长公共子序列的长度并不难，易知状态转移方程为：f[i][j] = i == j ? f[i][j] = a[i] == b[j] ? f[i - 1][j - 1] + 1 : max(f[i - 1][j], f[i][j - 1])。

要求最长公共子序列的种数，可以给每个状态下的情况分类讨论：

①a[i]和b[j]都属于所有的lcm(i, j)。

②a[i]属于所有的lcm(i, j)，b[j]并非属于所有的lcm(i, j)。

③a[i]并非属于所有的lcm(i, j)，b[j]属于所有的lcm(i, j)。

④a[i]和b[j]都并非属于所有的lcm(i, j)。

若a[i] = b[j]，则f[i][j] = f[i - 1][j - 1] + 1，对应情况①。

若f[i][j] = f[i][j - 1]，则b[j]并非属于所有的lcm(i, j)（可根据逆否命题推断），对应的情况包括②④。

若f[i - 1][j] = f[i][j]，则a[i]并非属于所有的lcm(i, j)（可根据逆否命题推断），对应的情况包括③④。

若f[i][j] = f[i - 1][j - 1]，则对应情况④，**并且此时也必满足其上两种的条件**。

以上4种条件的结论涵盖各种情况，综上有：

if (a[i] == b[j]) g[i][j] += g[i - 1][j - 1]

if (f[i][j] == f[i][j - 1]) g[i][j] += g[i][j - 1]

if (f[i][j] == f[i - 1][j]) g[i][j] += g[i - 1][j]

if (f[i][j] == f[i - 1][j - 1]) g[i][j] -= g[i - 1][j - 1]（容斥原理）

滚动数组优化，k表示i状态，k ^ 1表示i - 1状态。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int maxn = 5e3 + 10, mod = 1e8;
int n, m, k;
char ch, a[maxn], b[maxn];
ll f[2][maxn], g[2][maxn];

int main()
{
    for (int i = 1; (ch = getchar()) != '.'; a[i] = ch, n = i, i++) ;
    getchar();
    for (int i = 1; (ch = getchar()) != '.'; b[i] = ch, m = i, i++) ;
    for (int i = 0; i <= m; i++) g[0][i] = 1; g[1][0] = 1;
    for (int i = 1; i <= n; i++, k ^= 1)
    {
        for (int j = 1; j <= m; j++)
        {
            g[k ^ 1][j] = 0;
            f[k ^ 1][j] = (a[i] == b[j]) ? f[k][j - 1] + 1 : max(f[k][j], f[k ^ 1][j - 1]);
            if (a[i] == b[j]) g[k ^ 1][j] += g[k][j - 1];
            if (f[k ^ 1][j] == f[k ^ 1][j - 1]) g[k ^ 1][j] += g[k ^ 1][j - 1];
            if (f[k ^ 1][j] == f[k][j]) g[k ^ 1][j] += g[k][j];
            if (f[k ^ 1][j] == f[k][j - 1]) g[k ^ 1][j] -= g[k][j - 1];
            g[k ^ 1][j] %= mod;
        }
    }
    printf("%lld\n%lld\n", f[k][m], g[k][m]);
    return 0;
}
```

---

## 作者：天梦 (赞：9)

## P2516

[题目](https://www.luogu.com.cn/problem/P2516)

相信求 lcs 大家都会，我们重点来说求 lcs 的个数。

### 1一些定义

1.  $s_{i,j}$ 表示字符串 $s$ 从下标 $i$ 到下标 $j$ 的字符组成的字符串。
2. 说一个字符在 lcs 中当且仅当存在一个两个字符串的 lcs 方案，满足该字符在其中。

### 2状态

设 $f_{i,j}$ 表示考虑 $a_{1,i}$ 和 $b_{1,j}$ 的 lcs 长度。

设 $g_{i,j}$ 表示考虑 $a_{1,i}$ 和 $b_{1,j}$ 的 lcs 个数。

其中 $a,b$ 是题目中给出的两个字符串。

### 3转移

我们先看状态 $f$ 的转移：
$$
f_{i,j}=f_{i-1,j-1}+1(a_i=b_j)\\
f_{i,j}=\max (f_{i-1,j},f_{i,j-1})(a_i\not=a_j)
$$
所以我们同样分别讨论以上两重情况 $g$ 的转移。

#### 3.1第一种情况

因为 $f_{i,j}=f_{i-1,j-1}+1$ 我们考虑 $a_i,b_j$ 的使用情况，可以得出以下事实：

1.  $a_i,b_j$ 不可能同时不在 lcs 中。
2.  $a_i,b_j$ 可能只有其中一个在 lcs 中，也可能两个都在。

所以我们这样来计算 $g$，我们把 $g$ 划分成三个情况：

1. 包含 $a_i,b_j$。
2. 包含 $a_i$，不包含 $b_j$。
3. 包含 $b_j$，不包含 $a_i$。

对应以上三种情况，我们有以下转移：
$$
g_{i,j}=g_{i-1,j-1}\\
g_{i,j}=g_{i,j-1}\\
g_{i,j}=g_{i-1,j}
$$
很显然，$2$ 满足时有 $f_{i,j}=f_{i,j-1}$，$3$ 满足时有 $f_{i,j}=f_{i-1,j}$，后者同时也是前者的充分条件。因为我们是从 $f_{i-1,j-1}$ 转移 到 $f_{i,j}$ 的，所以一定存在情况 $1$。

这里举一个例子： $a=\text{CBCAA},b=\text{ABCACABACA}$。

这个例子三个情况都满足。

#### 3.2第二种情况

我们考虑 $f_{i,j}$ 是从那个地方转移的。我们同时也考虑一下 $a_i,b_j$ 的包含情况。

显然 $a_i,b_j$ 不能同时包含在 lcs 中。

如果 $f_{i-1,j}>f_{i,j-1}$ 那么在 lcs 中，$b_j$一定包含，所以有转移：$g_{i,j}=g_{i-1,j}$。 

同理，我们也有：
$$
f_{i-1,j}<f_{i,j-1}\to g_{i,j}=g_{i,j-1}
$$
考虑一下如果 $f_{i,j-1}=f_{i-1,j}$，说明什么？

这说明该 lcs 中既有包含 $a_i$ 的情况，也有包含 $b_j$ 的情况。

这时 $g_{i,j-1}$ 由两部分构成，一部分包含 $a_i$，另一部分不包含（即 $g_{i-1,j-1}$ ）。 $g_{i-1,j}$ 同理。

这个时候，我们在考察 $f_{i,j}$ 和 $f_{i-1,j-1}$ 。

如果 $f_{i,j}\not=f_{i-1,j-1}$，说明我们所有的 lcs 都包含 $a_i$ 或 $b_j$，所以有：$g_{i,j}=g_{i-1,j}+g_{i,j-1}$ ，否则，说明存在一些 lcs 不包含 $a_i$，也不包含 $b_j$ ，如果直接加的话 $g_{i-1,j-1}$ 会被算重，所以我们减去，有：$g_{i,j}=g_{i-1,j}+g_{i,j-1}-g_{i-1,j-1}$。

#### 4代码

```c++
#include<bits/stdc++.h>
#define dd double
#define ld long double
#define ll long long
#define ull unsigned long long
#define N 5010
#define M number
using namespace std;

const int INF=0x3f3f3f3f;
const int mod=1e8;

inline int Max(int a,int b){
    return a<b?b:a;
}

template<typename T>  inline void read(T &x) {
	x=0; int f=1;
	char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c == '-') f=-f;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0';
	x*=f;
}

template<typename T>  inline void write(T x) {
	if(x < 0) x=-x,putchar('-');
	if(x > 9) write(x / 10);
	putchar(x%10+'0');
}

template<typename T>  inline void writeln(T x) {
	write(x);
	puts("");
}

char a[N],b[N];
int lena,lenb,f[N][N],g[N][N],ans;

int main(){
    freopen("1.in","r",stdin);
    scanf("%s%s",a+1,b+1);
    lena=strlen(a+1);lenb=strlen(b+1);
    lena--;lenb--;
    g[0][0]=1;
    for(int i=1;i<=lena;i++) g[i][0]=1;
    for(int i=1;i<=lenb;i++) g[0][i]=1;
    for(int i=1;i<=lena;i++){
        for(int j=1;j<=lenb;j++){
            if(a[i]==b[j]){
                f[i][j]=f[i-1][j-1]+1;
                g[i][j]=g[i-1][j-1]%mod;
                bool op=0;
                if(f[i][j]==f[i-1][j]) (g[i][j]+=g[i-1][j])%=mod;
                if(f[i][j]==f[i][j-1]) (g[i][j]+=g[i][j-1])%=mod;
            }
            else{
                f[i][j]=Max(f[i][j-1],f[i-1][j]);
                if(f[i-1][j]>f[i][j-1]) g[i][j]=g[i-1][j]%mod;
                else if(f[i-1][j]<f[i][j-1]) g[i][j]=g[i][j-1]%mod;
                else if(f[i][j]!=f[i-1][j-1]) g[i][j]=(g[i-1][j]+g[i][j-1])%mod;
                else g[i][j]=(g[i][j-1]+g[i-1][j]-g[i-1][j-1])%mod;
            }
        }
    }
    writeln(f[lena][lenb]);
    write(g[lena][lenb]);
}
```

而这样会爆空间，所以我们用滚动数组优化。

```c++
#include<bits/stdc++.h>
#define dd double
#define ld long double
#define int long long
#define ull unsigned long long
#define N 5010
#define M number
using namespace std;

const int INF=0x3f3f3f3f;
const int mod=1e8;

inline int Max(int a,int b){
    return a<b?b:a;
}

template<typename T>  inline void read(T &x) {
	x=0; int f=1;
	char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c == '-') f=-f;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0';
	x*=f;
}

template<typename T>  inline void write(T x) {
	if(x < 0) x=-x,putchar('-');
	if(x > 9) write(x / 10);
	putchar(x%10+'0');
}

template<typename T>  inline void writeln(T x) {
	write(x);
	puts("");
}

char a[N],b[N];
int lena,lenb,f[3][N],g[3][N],ans;

signed main(){
    freopen("1.in","r",stdin);
    scanf("%s%s",a+1,b+1);
    lena=strlen(a+1);lenb=strlen(b+1);
    lena--;lenb--;
//    for(int i=1;i<=lena;i++) g[i][0]=1;
    for(int i=0;i<=lenb;i++) g[0][i]=1;
    g[1][0]=1;
    for(int i=1;i<=lena;i++){
        for(int j=1;j<=lenb;j++){
            int ni=(i&1);int lai=ni^1; 
            if(a[i]==b[j]){
                f[ni][j]=f[lai][j-1]+1;
                g[ni][j]=g[lai][j-1]%mod;
                if(f[ni][j]==f[lai][j]) (g[ni][j]+=g[lai][j])%=mod;
                if(f[ni][j]==f[ni][j-1]) (g[ni][j]+=g[ni][j-1])%=mod;
            }
            else{
                f[ni][j]=Max(f[ni][j-1],f[lai][j]);
                if(f[lai][j]>f[ni][j-1]) g[ni][j]=g[lai][j]%mod;
                else if(f[lai][j]<f[ni][j-1]) g[ni][j]=g[ni][j-1]%mod;
                else if(f[ni][j]!=f[lai][j-1]) g[ni][j]=(g[lai][j]+g[ni][j-1])%mod;
                else g[ni][j]=((g[ni][j-1]+g[lai][j]-g[lai][j-1])%mod+mod)%mod;
            }
        }
    }
    writeln(f[lena&1][lenb]);
    write(g[lena&1][lenb]);
}
```

预处理一定要全~~就是因为这个找不出错来~~



---

## 作者：Coros_Trusds (赞：6)

[更好的阅读体验](https://www.cnblogs.com/Coros-Trusds/p/15671305.html)

# 题目大意

给定两个字符串 $a,b$，求出 $a,b$ 的最长公共子序列长度以及 $a,b$ 的公共子序列个数。

# 题目分析

先考虑第一问，令 $dp1[i][j]$ 表示 $a$ 前 $i$ 和 $b$ 前 $j$ 个字符的最长公共子序列长度。

若 $a[i]=b[j]$，即当前字符相同，那么一定要选这儿，$dp1[i][j]=dp1[i-1][j-1]+1$。

否则 $dp1[i][j]=\max(dp1[i-1][j],dp1[i][j-1])$。

参考代码：

```cpp
for (int i = 1;i <= n; ++ i){
    for (int j = 1;j <= m; ++ j){
        dp1[i][j] = a[i] == b[j] ? dp1[i - 1][j - 1] + 1 : max(dp1[i - 1][j],dp1[i][j - 1]);
    }
}
printf("%d\n",dp1[n][m]);
```
-----
难点是第二问：求 $a,b$ 的公共子序列个数。

令 $dp2[i][j]$ 表示 $a$ 前 $i$ 和 $b$ 前 $j$ 个字符的公共子序列个数。

这里用 $\operatorname{lcm}(i,j)$ 表示 $a$ 的前 $i$ 个和 $b$ 的前 $j$ 个中的最长公共子序列。

我们分情况讨论：

1. $a[i]\in \operatorname{lcm}(i,j),b[j]\in \operatorname{lcm}(i,j)$

2. $a[i]\in \operatorname{lcm}(i,j),b[j]\not \in \operatorname{lcm}(i,j)$

3. $a[i]\not\in \operatorname{lcm}(i,j),b[j]\in \operatorname{lcm}(i,j)$

4. $a[i]\not\in \operatorname{lcm}(i,j),b[j]\not\in\operatorname{lcm}(i,j)$

若 $a[i]=b[j]$，则 $dp1[i][j]=dp1[i-1][j-1]+1$，即情况 $1$。

于是有 $dp2[i][j]\gets dp2[i][j]+dp2[i-1][j-1]$。

若 $dp1[i][j]=dp1[i][j-1]$，此时对应情况 $2$ 和 $4$。

于是有 $dp2[i][j]\gets dp2[i][j]+dp2[i][j-1]$。

若 $dp1[i][j]=dp1[i-1][j]$，此时对应情况 $3$ 和 $4$。

于是有 $dp2[i][j]\gets dp2[i][j]+dp2[i-1][j]$。

若 $dp1[i][j]=dp1[i-1][j-1]$，此时对应情况 $4$。满足该条件，则必然满足前两种情况，根据容斥原理，于是有 $dp2[i][j]\gets dp2[i][j]-dp2[i-1][j-1]$。

-----

令 $n$ 为 $a$ 的长度，$m$ 为 $b$ 的长度，则：

时间复杂度为 $O(nm)$，空间复杂度为 $O(nm)$，空间只有 $\verb!125MB!$，并且发现转移之和前一种情况有关，使用滚动数组优化。

---

注意事项：

+ 不开 `_________` 见 `_______`。

+ 方案数取差时注意负数情况。

# 代码

```cpp
//2021/12/9

#define _CRT_SECURE_NO_WARNINGS

#include <iostream>

#include <cstdio>

#include <climits>//need "INT_MAX","INT_MIN"

#include <algorithm>

#include <cstring>

#define int long long

#define enter() putchar(10)

#define debug(c,que) cerr<<#c<<" = "<<c<<que

#define cek(c) puts(c)

#define blow(arr,st,ed,w) for(register int i=(st);i<=(ed);i++)cout<<arr[i]<<w;

#define speed_up() cin.tie(0),cout.tie(0)

#define endl "\n"

#define Input_Int(n,a) for(register int i=1;i<=n;i++)scanf("%d",a+i);

#define Input_Long(n,a) for(register long long i=1;i<=n;i++)scanf("%lld",a+i);

#define mst(a,k) memset(a,k,sizeof(a))

namespace Newstd
{
	inline int read()
	{
		int x=0,k=1;
		char ch=getchar();
		while(ch<'0' || ch>'9')
		{
			if(ch=='-')
			{
				k=-1;
			}
			ch=getchar();
		}
		while(ch>='0' && ch<='9')
		{
			x=(x<<1)+(x<<3)+ch-'0';
			ch=getchar();
		}
		return x*k;
	}
	inline void write(int x)
	{
		if(x<0)
		{
			putchar('-');
			x=-x;
		}
		if(x>9)
		{
			write(x/10);
		}
		putchar(x%10+'0');
	}
}

using namespace Newstd;

using namespace std;

const int mod=1e8,ma=5005;

char a[ma],b[ma];

int dp1[2][ma],dp2[2][ma];
//dp2[i][j]:a 的前 i 个,b 的前 j 个中所有最长公共子序列的个数 

int n,m;

#undef int

int main(void)
{
	#define int long long
	
	scanf("%s%s",a+1,b+1);
	
	n=strlen(a+1)-1,m=strlen(b+1)-1;
	
	int st=0;
	
	for(register int i=0;i<=m;i++)
	{
		dp2[0][i]=1;
	}
	
	dp2[1][0]=1;
	
	for(register int i=1;i<=n;i++)
	{
		for(register int j=1;j<=m;j++)
		{
			dp2[st^1LL][j]=0;
			
			if(a[i]==b[j])
			{
				dp1[st^1LL][j]=dp1[st][j-1]+1;
			}
			
			else
			{
				dp1[st^1LL][j]=max(dp1[st][j],dp1[st^1LL][j-1]);
			}
			
			if(a[i]==b[j])
			{
				dp2[st^1LL][j]+=dp2[st][j-1];//dp2[i][j]+=dp2[i-1][j-1]
			}
			
			if(dp1[st^1LL][j]==dp1[st^1LL][j-1])//dp1[i][j]==dp1[i][j-1] 
			{
				dp2[st^1LL][j]+=dp2[st^1LL][j-1];//dp2[i][j]+=dp2[i][j-1]
			}
			
			if(dp1[st^1LL][j]==dp1[st][j])//dp1[i][j]==dp1[i-1][j]
			{
				dp2[st^1LL][j]+=dp2[st][j];//dp2[i][j]+=dp2[i-1][j]
			}
			
			if(dp1[st^1LL][j]==dp1[st][j-1])//dp1[i][j]==dp1[i-1][j-1]
			{
				dp2[st^1LL][j]-=dp2[st][j-1];//dp2[i][j]-=dp2[i-1][j-1]
			}
			
			dp2[st^1LL][j]=(dp2[st^1LL][j]+mod)%mod;
		}
		
		st^=1LL;
	}
	
	printf("%lld\n%lld\n",dp1[st][m],dp2[st][m]);
	
	return 0;
}
```

---

## 作者：autoint (赞：6)

# 前言
感觉这几篇仅有的题解都没说清楚，并且有些还是错的，我再发一篇吧。
# 分析
首先lcs（最长公共子序列）肯定是板子。但这题要求我们不能光记lcs是怎么打的，因为没这部分分，并且另外一个方程的转移要用到状态的定义。在此定义状态：

设题设字符串为$S$,$T$,然后定义字符串的前缀$i$表示字符串开头至$i$位置构成的字符串,例如$S$的前缀$i$表示$S_1\sim S_i$。

$f(i,j)$表示$S$的前缀$i$和$T$的前缀$j$的lcs的长度，根据广为人知的lcs算法,
$$f(i,j)=\max\left\{f(i-1,j),f(i,j-1),(f(i-1,j-1)+1)*[S_i==T_j]\right\}$$
前两个转移式子表示不匹配$S_i$和$T_j$，最后的式子表示$S_i$和$T_j$匹配并将其贡献计入答案。

考虑新状态$g(i,j)$表示同上解释的lcs的匹配方式对数。那么如何转移呢？首先若$f(i,j)$等于不匹配转移式子，那么就不匹配转移式子对应的$g$应计入答案，因为若$f$不改变，那么匹配方式及其对数也应不变。然后考虑两种特殊情况：
1. $$f(i,j)=f(i-1,j-1)\&S_i\neq T_j$$它描述的是$S_i$和$T_j$都不做出贡献而直接转移重复的情况，那么根据容斥原理，就应减去$g(i-1,j-1)$。
2. $$f(i,j)=f(i-1,j-1)+1\&S_i=T_j$$它描述的是$S_i$和$T_j$匹配并做出贡献的情况。那么新增的匹配方式对数等于$S$的后缀$i-1$和$T$的后缀$j-1$的lcs的匹配方式对数，因为在原匹配序列中末尾都加一个元素匹配方式对实际上是没改变的。所以应加上$g(i-1,j-1)$。

### 复杂度
时间是$O(n\cdot m)$的，没问题。但是朴素代码空间复杂度也是$O(n\cdot m)$的，128MB要炸空间，于是要用滚动数组。
# 代码
借鉴[kiddingme12138](/space/show?uid=13740)的，他的代码（以及很多人的）虽然能AC但是有错，即特殊情况2中无论$f(i,j)$最终是否等于$f(i-1,j-1)+1$只要$S_i=T_j$那么就加上$g(i-1,j-1)$。~~望加强数据。~~
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<map>
#define rg register
using namespace std;

const int MAXN=5e3+7;
const int mod=1e8;
int n,m;
char S[MAXN],T[MAXN];
int f[2][MAXN],g[2][MAXN];

int main()
{
//	freopen("lcs.in","r",stdin);
//	freopen("lcs.out","w",stdout);
	scanf("%s",S+1);
	n=strlen(S+1)-1;
	scanf("%s",T+1);
	m=strlen(T+1)-1;
	int cur=0;
	for(rg int i=0;i<=m;++i)
		g[cur][i]=1;
	for(rg int i=0;i<=n;++i)
	{
		cur^=1;g[cur][0]=1;
		for(rg int j=1;j<=m;++j)
		{
			g[cur][j]=0;
			f[cur][j]=max(f[cur^1][j],f[cur][j-1]);
			if(S[i]==T[j])
				f[cur][j]=max(f[cur][j],f[cur^1][j-1]+1);
			if(f[cur][j]==f[cur^1][j])
				g[cur][j]+=g[cur^1][j];
			if(f[cur][j]==f[cur][j-1])
				g[cur][j]+=g[cur][j-1];
			if(S[i]==T[j]&&f[cur][j]==f[cur^1][j-1]+1)
				g[cur][j]+=g[cur^1][j-1];
			if(S[i]!=T[j]&&f[cur][j]==f[cur^1][j-1])
				g[cur][j]-=g[cur^1][j-1];
			g[cur][j]=(g[cur][j]+mod)%mod;
		}
	}
	printf("%d\n%d",f[cur][m],g[cur][m]);
}
```



---

## 作者：kiddingme12138 (赞：4)

这题看着很简单（某神犇曰：“水题”），可是如果和我一样对lcs问题动规状态的理解不够透彻的话，感觉还是挺难的

第一问，裸的lcs，不多赘述

第二问，考虑像前一问一样划分阶段。g[i][j]表示字符串a的前i个字符和字符串b的前j个字符可能组成的最长公共子序列个数

考虑转移：

先说一下一个会tle的方法。对于每个g[i][j]的转移，有4种决策。

a[i]和b[j]匹配；

a[i]和b[某]匹配，b[j]不匹配；

a[某]和b[j]匹配，a[i]不匹配；

a[i]和b[j]都不匹配

其中只有不影响lcs的决策才能选

代码大概长这样：
```cpp
for(int i=1;i<=n;i++) g[i][0]=1,alast[i]=acur[a[i]-'A'],acur[a[i]-'A']=i;
for(int i=1;i<=m;i++) g[0][i]=1,blast[i]=bcur[b[i]-'A'],bcur[b[i]-'A']=i;
for(int i=0;i<30;i++) acur[i]=bcur[i]=0;
for(int i=1;i<=n;i++)
{
	acur[a[i]-'A']=i;
	for(int j=0;j<30;j++) bcur[j]=0;
	for(int j=1;j<=m;j++)
	{
		bcur[b[j]-'A']=j;
		f[i][j]=getmax(f[i-1][j],f[i][j-1]);
		if(a[i]==b[j]) f[i][j]=getmax(f[i][j],f[i-1][j-1]+1);
		if(f[i-1][j-1]==f[i][j]) g[i][j]=g[i-1][j-1];
		for(int k=acur[b[j]-'A'];k&&f[k-1][j-1]+1==f[i][j];k=alast[k]) g[i][j]+=g[k-1][j-1];
		for(int k=bcur[a[i]-'A'];k&&f[i-1][k-1]+1==f[i][j];k=blast[k]) g[i][j]+=g[i-1][k-1];
		if(a[i]==b[j]) g[i][j]-=g[i-1][j-1];
		g[i][j]%=mo;
	}
}
```
正确性应该是有的，毕竟我拍了好久。然后就喜闻乐见的tle了。。。


重新考虑转移：

之前的转移主要慢在这两步：a[i]和b[某]匹配，b[j]不匹配；a[某]和b[j]匹配，a[i]不匹配；
再想一下状态的定义：g[i][j]表示字符串a的前i个字符和字符串b的前j个字符可能组成的lcs个数

然后就会发现，好像可以直接用容斥原理O(1)求出啊：
g[i][j-1]+g[i-1][j]-g[i-1][j-1]

理解一下这个式子

g[i][j-1]为b[j]不匹配,a[i]和b[某]匹配或a[i]不匹配

g[i-1][j]为a[i]不匹配,a[某]和b[j]匹配或b[j]不匹配

g[i-1][j-1]为a[i],b[i]都不匹配

这样式子的结果不就刚好是转移比较慢的两个决策的结果了吗

最后注意滚动数组，因为128mb是33554432个int，然后两个5000*5000的数组就是50000000，爆了

AC代码如下：
```cpp
#include <cstdio>
#include <cstring>
#include <vector>
#include <iostream>
#define getmax(a,b) (((a)>(b))?(a):(b))
using namespace std;
const int maxn=5005,mo=100000000;
int n,m,f[2][maxn],g[2][maxn];
char a[maxn],b[maxn];
int main()
{
	scanf("%s%s",a+1,b+1);
	a[0]=b[0]='#';
	n=strlen(a)-2,m=strlen(b)-2;
	int cur=0;
	for(int i=0;i<=m;i++) g[cur][i]=1;
	for(int i=1;i<=n;i++)
	{
		cur^=1;g[cur][0]=1;
		for(int j=1;j<=m;j++)
		{
			g[cur][j]=0;
			f[cur][j]=getmax(f[1-cur][j],f[cur][j-1]);
			if(a[i]==b[j])
			{
				f[cur][j]=getmax(f[cur][j],f[1-cur][j-1]+1);
				g[cur][j]=g[1-cur][j-1];
				if(f[cur][j]==f[cur][j-1]) g[cur][j]+=g[cur][j-1];
				if(f[cur][j]==f[1-cur][j]) g[cur][j]+=g[1-cur][j];
			}
			else
			{
				if(f[cur][j]==f[1-cur][j]) g[cur][j]+=g[1-cur][j];
				if(f[cur][j]==f[cur][j-1]) g[cur][j]+=g[cur][j-1];
				if(f[1-cur][j-1]==f[cur][j]) g[cur][j]-=g[1-cur][j-1];
			}
			g[cur][j]=(g[cur][j]+mo)%mo;
		}
	}
	printf("%d\n%d\n",f[cur][m],g[cur][m]);
}
```
（话说这题我做了两个小时。。。省选凉透了啊。。。）

---

## 作者：IceKylin (赞：3)

# P2516 最长公共子序列 题解
### [原题链接](https://www.luogu.com.cn/problem/P2516)
### [更好的阅读体验？](https://www.luogu.com.cn/blog/std-IK/p2516-ti-xie)
 
这是一道经典的 **动态规划** 问题，但第二问的加入，使此题又变得富有新意。

注：**最长公共子序列** 简称 **LCS**，下文不再赘述。

设第一个字符串为 ${S1}$，第二个字符串为 ${S2}$，${S1}$ 长度为 ${n}$，${S2}$ 长度为 ${m}$。

设 ${dp(i,j)}$ 表示 ${S1}$ 的前 ${i}$ 个字符与 ${S2}$ 的前 ${j}$ 个字符的 LCS 的 **长度**。

设 ${f(i,j)}$ 表示 ${S1}$ 的前 ${i}$ 个字符与 ${S2}$ 的前 ${j}$ 个字符的 LCS 的 **方案数**。

------------

第一问，求 **LCS 的长度**，相信大家都已经学过了，这里直接给出转移方程：

- ${dp(i,j)=\max\{dp(i-1,j),dp(i,j-1),dp(i-1,j-1)+1\}\quad(S1_i=S2_j)}$

- ${dp(i,j)=\max\{dp(i-1,j),dp(i,j-1)\}}\quad(S1_i\ne S2_j)$

**边界条件**：

- ${dp(i,0)=0}$

- ${dp(0,j)=0}$

答案即为 ${dp(n,m)}$。

------------

接下来考虑第二问，求 **LCS 的方案数**，可以从 ${dp(i,j)}$ 的转移方程中找到突破口。

- 从 ${dp(i-1,j)}$ 处转移：${f(i,j)\gets f(i,j)+f(i-1,j)}$。

- 从 ${dp(i,j-1)}$ 处转移：${f(i,j)\gets f(i,j)+f(i,j-1)}$。

- 从 ${dp(i-1,j-1)}$ 处转移：${f(i,j)\gets f(i,j)+f(i-1,j-1)\quad(S1_i=S2_j)}$。

**特殊情况**：

如果 ${dp(i-1,j)}$ 和 ${dp(i,j-1)}$ 都从 ${dp(i-1,j-1)}$ 处转移，那么由第二问的转移方程可得 ${f(i-1,j-1)}$ 被计算了 **两次**，根据 **容斥原理**，需要减去一次，即：${f(i,j)\gets f(i,j)-f(i-1,j-1)}$。转移条件：显然在这种情况下有 ${S1_i\ne S2_j}$，所以只需判断 ${dp(i,j)=dp(i-1,j-1)}$ 即可。

**边界条件**：

- ${f(0,0)=1}$

- ${f(0,j)=1}$

- ${f(1,0)=1}$

答案即为 ${f(n,m)}$。

------------

最后，此题还有三处 **细节**：

1. 内存限制为 125MB，直接开 ${nm}$ 的数组会有 **爆空间** 的风险，所以可以用 **滚动数组** 压掉第一维。

2. 读入的两个字符串末尾各有一个英文句号，需要将其忽略。

3. 数据不卡取模，不需要每一步运算后都取模。

P.S. 此题时间复杂度为 ${O(nm)}$。

## AC代码
```cpp
//By IceKylin
#include<bits/stdc++.h>
#define mod (int)(1e8)
#define maxn 5030
using namespace std;
int dp[2][maxn],f[2][maxn];
char s1[maxn],s2[maxn];


int main(){
	ios::sync_with_stdio(false);
	cin>>(s1+1)>>(s2+1);
	int n=strlen(s1+1)-1;
	int m=strlen(s2+1)-1; 
	int k=1;
    for(int i=0;i<=m;++i)f[0][i]=1;
	f[1][0]=1;
    for(int i=1;i<=n;++i,k=1-k)
    for(int j=1;j<=m;++j){
        f[k][j]=0;
        dp[k][j]=max(dp[k][j-1],dp[1-k][j]);
        if(s1[i]==s2[j]){
			dp[k][j]=max(dp[k][j],dp[1-k][j-1]+1);
			if(dp[k][j]==dp[1-k][j-1]+1)f[k][j]+=f[1-k][j-1];
		}
		if(dp[k][j]==dp[1-k][j])f[k][j]+=f[1-k][j];
		if(dp[k][j]==dp[k][j-1])f[k][j]+=f[k][j-1];
		if(dp[k][j]==dp[1-k][j-1])f[k][j]-=f[1-k][j-1];
		f[k][j]%=mod;
    }
    cout<<dp[1-k][m]<<'\n'<<f[1-k][m];
    return 0;
}
```


---

## 作者：nullqtr_pwp (赞：2)

# P2516 Solution

这道题第一问不算难，难在第二问的计算。

设 $f(i,j)$ 表示字符串 A 的前 $i$ 个字符与字符串 B 的前 $j$ 个字符的最长公共子序列**长度**，那么有 $f(i,j)=\max\lbrace f(i-1,j),f(i,j-1),f(i-1,j-1)+[a_i=b_j]\rbrace$，这里不做过多说明。

其次，设 $g(i,j)$ 表示字符串 A 的前 $i$ 个字符与字符串 B 的前 $j$ 个字符的最长公共子序列**出现次数**，它是由长度以及匹配情况来决定的。

先更新出 $f(i,j)$ 的值，转移方程在上面。

如果说 $f(i,j)=f(i-1,j)$，那么代表着 $a_i$ 不在最长公共子序列中，那么 $g(i,j)=g(i,j)+g(i-1,j)$

同理，如果 $f(i,j)=f(i,j-1)$，那么 $g(i,j)=g(i,j)+g(i,j-1)$（累加起来）

再考虑如果 $a_i=b_j$ 的情况，在这种情况下，如果 $f(i,j)=f(i-1,j-1)+1$，则证明 $a_i$ 与 $b_j$ 在最长公共子序列中，则有 $g(i,j)=g(i,j)+g(i-1,j-1)$

但是如果出现 $f(i-1,j-1)=f(i,j)$ 的情况，则 $f(i-1,j)=f(i,j-1)=f(i-1,j-1)=f(i,j)$，则有 $g(i-1,j)=g(i,j-1)=g(i-1,j-1)$，容易得知这种情况下 $g(i,j)$ 被加了两次 $g(i-1,j-1)$，所以 $g(i,j)=g(i,j)-g(i-1,j-1)$，由容斥原理消去一次。

这个转移涉及了减法，答案又得取模，所以可能出现负数取模，需要注意。

**考虑到只有 $125$ MB 的内存，所以需要开滚动数组**

Code：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn=5005,mod=100000000;
char a[maxn],b[maxn];
int f[maxn][2],g[maxn][2],x=1,y=0;
signed main(){
	scanf("%s%s",a+1,b+1);
	int n=strlen(a+1)-1,m=strlen(b+1)-1;
	for(int i=0;i<=m;i++) g[i][0]=1;
	g[0][1]=1;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			f[j][x]=max(f[j][y],f[j-1][x]);
			g[j][x]=0;
			if(a[i]==b[j]){
				f[j][x]=max(f[j][x],f[j-1][y]+1);
				if(f[j-1][y]+1==f[j][x]) g[j][x]+=g[j-1][y];
			}
			if(f[j][x]==f[j][y]) g[j][x]+=g[j][y];
			if(f[j][x]==f[j-1][x]) g[j][x]+=g[j-1][x];
			if(f[j][x]==f[j-1][y]) g[j][x]-=g[j-1][y];
			g[j][x]+=mod<<1;
			g[j][x]%=mod;//防止出现负数取模寄掉
		}
		x=y;
		y=1-y;
	}
	printf("%lld\n%lld",f[m][y],g[m][y]);
}
```


---

## 作者：Lgx_Q (赞：2)

我们试试换一种方法做普通的 LCS。

---

设 $f[i][j]$ 表示在 $X[1...i]$ 和 $Y[1...j]$ 中选择的 LCS 的长度，其中 $Y[j]$ 必须被包含在 LCS，$s[i][j]$为其方案数。

方程：

当 $X[i]≠Y[j]$，有：
$$f[i][j]=f[i-1][j]$$
$$s[i][j]=s[i-1][j]$$
（由于 $Y[j]$ 必取，因此只能抛弃 $X[i]$）

当 $X[i]==Y[j]$，有：
$$f[i][j]=max\{f[i-1][k]\}(1≤k≤j)$$
$$s[i][j]=sum\{s[i-1][k]\}(1≤k≤j,f[i][j]=f[i-1][k])$$

最后 $max\{f[|X|][j]\}(1≤j≤|Y|)$ 和 $sum\{s[|X|][j]\}(1≤j≤|Y|,f[|X|][j]=max\{f[|X|][s]\}(1≤s≤|Y|))$ 为答案。

时间复杂度 $O(|X||Y|^2)$。

---

### 时间优化

这样的做法拿不了满分，会 ```TLE```。

我们会发现，其实随着 $j$ 的增长，我们的决策 $k$ 选择范围也随之单调递增，我们当然可以一边计算 $f[i][j]$ 时，一边用变量 $vk$ 来存 $max\{f[i-1][k]\}(1≤k≤j)$，用 $sum$ 来存 $sum\{s[i-1][k]\}(1≤k≤j,f[i][j]=f[i-1][k])$。$vk$ 和 $sum$ 可以在循环 $j$ 时不断更新。

注意：每次 $i$ 的循环开始， $vk$ 清 $0$，但 $sum$ 要赋值为 $1$。因为当 $f[i][j]$ 赋值成功为 $sum$ 时，如果 $max\{f[i-1][k]\}(1≤k≤j)$ 仍为 $0$，那么 $sum$ 就不会被覆盖（即 $1≤sum$）,$f[i][j]$ 也能为 $1$。

时间复杂度 $O(|X||Y|)$

---

### 空间优化

本题的数据有 $5000*5000$，内存仅有 $125mb$，用滚动数组即可大大减小空间。

---

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
/*
f[i][j]表示在 A[1...i],B[1...j] 中取字母，其中 B[j] 必取。
1.A[i]!=B[j]
f[i-1][j]

s[i][j]=s[i-1][j]
2.A[i]=B[j]
f[i-1][j],f[i-1][k]

s[i][j]=sum{s[i-1][k1],s[i-1][k2],...}(f[i-1][k]为最大)
*/
string a,b;
int n,m,dp[2][5005],s[2][5005],sum=1,vk;
int ans,cnt;
int main()
{	
    cin>>a>>b;
    n=a.size()-1,m=b.size()-1;
    a=' '+a,b=' '+b;
    for(int i=1;i<=n;i++)
    {
    	for(int j=1;j<=m;j++)
    	{
    		if(a[i]!=b[j])
    		{
    			dp[i&1][j]=dp[(i-1)&1][j];
    			s[i&1][j]=s[(i-1)&1][j];
    		}
    		else
    		{
    			if(vk+1>dp[(i-1)&1][j])
    			{
    				dp[i&1][j]=vk+1;
    				s[i&1][j]=sum;
    			}
    			else if(vk+1<dp[(i-1)&1][j])
    			{
    				dp[i&1][j]=dp[(i-1)&1][j];
    				s[i&1][j]=s[(i-1)&1][j];
    			}
    			else
    			{
    				dp[i&1][j]=vk+1;
    				s[i&1][j]=((long long)s[(i-1)&1][j]+sum)%100000000;
    			}
    		}
    		if(dp[(i-1)&1][j]==vk)
    		{
    			sum=((long long)sum+s[(i-1)&1][j])%100000000;
    		}
    		else if(dp[(i-1)&1][j]>vk)
    		{
    			vk=dp[(i-1)&1][j];
    			sum=s[(i-1)&1][j];
    		}
    	}
    	vk=0,sum=1;
    }
    for(int j=1;j<=m;j++)
    	ans=max(ans,dp[n&1][j]);
    for(int j=1;j<=m;j++)
    	if(dp[n&1][j]==ans)cnt=((long long)cnt+s[n&1][j])%100000000;
    printf("%d\n%d",ans,cnt);
    return 0;
}
```

---

## 作者：CPPfive (赞：2)

## 题目分析
首先观察数据范围，我们需要一个 $\mathcal{O}(N\times M)$ 的解决方法，而本题的状态数就是 $N\times M$ 个，因此转移必须是 $\mathcal{O}(1)$ 的。

然后我们先解决第一问。我们用 $a_{i}$ 和 $b_{i}$ 分别表示第一个和第二个字符串的第i个字符，用 $f_{i,j}$ 来表示第一个字符串的前 $i$ 个字符与第二个字符串的前 $j$ 个字符所能取到的最长公共子串长度，那么很显然有转移式：
$$f_{i,j}=\max(f_{i,j-1},f_{i-1,j},(f_{i-1,j-1}+1)\times(a_{i}=b_{j}))$$

式子的意思是：如果 $a_{i}$ 与 $b_{j}$ 相等，那么有可能从 $f_{i-1,j-1}$ 转移过来，并且无论怎样都可以从 $f_{i-1,j}$ 与 $f_{i,j-1}$ 转移过来。在所有可能的转移中找最大值即可。

那么对于第二小问，我们不妨用类似的方法，用 $g_{i,j}$ 表示第一个字符串的前 $i$ 个字符与第二个字符串的前 $j$ 个字符所能取到的最长公共子串的个数。那么实际上 $g_{i,j}$ 也是可以用与上面很类似的方法转移的。

唯一需要注意的地方是由于计算的是方法数，因此会出现重复计算。思考后发现重复的情况只会出现在 $g_{i-1,j}$ 与 $g_{i,j-1}$ 之间，即当 $f_{i-1,j}=f_{i,j-1}=f_{i-1,j-1}$ 时，$g_{i-1,j-1}$ 会在 $g_{i,j}$ 中被算两遍（如果 $g_{i,j}$ 是从 $g_{i-1,j}$ 和 $g_{i,j-1}$ 转移过来的话），因此把它去掉就好了。

最后，由于两维数组开不下，随便选一维滚掉。

## 代码
```cpp
//洛谷P2516 

#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int MAXN=5050,MOD=1e8;
string s1,s2;
int N1,N2;                    //两个字符串的长度 
pair<int,int> f[2][MAXN];     //dp的两个值放在pair里 
int id=1;                     //记录当前数组和上一次dp的数组 

int main()
{
	cin >> s1 >> s2;N1=s1.length()-1,N2=s2.length()-1;
	f[0][0]=f[1][0]=make_pair(0,1);
	for(int i=1;i<=N2;++i){
		f[0][i]=make_pair(0,1);
	}
	for(int i=1;i<=N1;++i,id^=1){
		for(int j=1;j<=N2;++j){
			if(s1[i-1]==s2[j-1]){
				f[id][j]=make_pair(f[id^1][j-1].first+1,f[id^1][j-1].second);
			}
			else f[id][j]=make_pair(0,1);
			
			//将有可能重复计算的情况单独处理 
			if(f[id^1][j].first==f[id][j-1].first&&f[id^1][j].first==f[id^1][j-1].first){
				if(f[id^1][j].first>f[id][j].first) f[id][j]=make_pair(f[id^1][j].first,((LL)f[id^1][j].second+f[id][j-1].second-f[id^1][j-1].second)%MOD);   
			}
			else{
				if(f[id^1][j].first>f[id][j].first) f[id][j]=f[id^1][j];
				else if(f[id^1][j].first==f[id][j].first) f[id][j].second=(f[id^1][j].second+f[id][j].second)%MOD;
				if(f[id][j-1].first>f[id][j].first) f[id][j]=f[id][j-1];
				else if(f[id][j-1].first==f[id][j].first) f[id][j].second=(f[id][j-1].second+f[id][j].second)%MOD;
			}
			
			//长度为0的字符串方案数只能是1 
			if(f[id][j].first==0) f[id][j].second=1;
		}
	}
	
	printf("%d\n%d\n",f[id^1][N2].first,f[id^1][N2].second);
	
	return 0;
}
```


---

## 作者：August_Light (赞：1)

# P2516 [HAOI2010] 最长公共子序列 题解

[题目传送门](https://www.luogu.com.cn/problem/P2516)

## 题意简述

给定两个字符串 $S$ 和 $T$，长度为 $n$ 和 $m$，求它们的最长公共子序列（LCS）长度和个数。

两个 LCS 不同当且仅当取出的**位置**不同。

$n,m \le 5000$，字符串全部由大写字母组成。

## 解法

### Q1

设 $f_{i,j}$ 为 $S$ 的前 $i$ 个字符和 $T$ 的前 $j$ 个字符的 LCS 长度。

当 $S_i = T_j$ 时，$f_{i,j} = f_{i-1,j-1} + 1$。

否则，$f_{i,j} = \max(f_{i-1,j}, f_{i,j-1})$。

不需要特别考虑边界情况。

### Q2

设 $g_{i,j}$ 为 $S$ 的前 $i$ 个字符和 $T$ 的前 $j$ 个字符的 LCS 个数。

1. 若 $f_{i,j} = f_{i-1,j}$，那么我们把 $g_{i,j}$ 加上 $g_{i-1,j}$。否则，这意味着在 $i-1$ 和 $j$ 根本没有这么长的 LCS，这部分答案为 $0$。

2. 同理，若 $f_{i,j} = f_{i,j-1}$，也有类似的式子。

3. 若 $S_i = T_j$，我们要把 $g_{i,j}$ 加上 $g_{i-1,j-1}$，因为这种情况下 $i-1$ 和 $j-1$ 的所有当时的 LCS 都增长了 $1$，变成了现在的 LCS。

4. 若 $S_i \ne T_j$ 且 $f_{i,j} = f_{i-1,j-1}$，因为 $i-1$ 和 $j-1$ 通过转移 1 和 转移 2 被转移了两次，所以要把 $g_{i,j}$ 减去 $g_{i-1,j-1}$。

边界情况：$g_{i,0} = 1$，$g_{0,j} = 1$。

### 总结

视 $n,m$ 同阶，时间复杂度 $O(n^2)$，空间复杂度用滚动数组压成 $O(n)$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 5000 + 5;
const int MOD = 1e8;

int n, m;
char S[MAXN], T[MAXN];
int f[2][MAXN]; // f[i][j] = S 的前 i 个字符 和 T 的前 j 个字符 的 LCS 长度
int g[2][MAXN]; // g[i][j] = S 的前 i 个字符 和 T 的前 j 个字符 的 LCS 个数

int main() {
    scanf("%s", S+1); n = strlen(S+1)-1;
    scanf("%s", T+1); m = strlen(T+1)-1;

    int cur = 0;

    for (int j = 0; j <= m; j++)
        g[cur][j] = 1;

    for (int i = 1; i <= n; i++) {
        cur ^= 1;

        // 计算 f
        for (int j = 1; j <= m; j++)
            if (S[i] == T[j])
                f[cur][j] = f[cur^1][j-1] + 1;
            else
                f[cur][j] = max(f[cur^1][j], f[cur][j-1]);

        // 计算 g
        g[cur][0] = 1;
        for (int j = 1; j <= m; j++) {
            g[cur][j] = 0;

            if (f[cur][j] == f[cur^1][j])
                (g[cur][j] += g[cur^1][j]) %= MOD;

            if (f[cur][j] == f[cur][j-1])
                (g[cur][j] += g[cur][j-1]) %= MOD;

            if (S[i] == T[j])
                (g[cur][j] += g[cur^1][j-1]) %= MOD;

            if (f[cur][j] == f[cur^1][j-1] && S[i] != T[j])
                g[cur][j] = ((g[cur][j] - g[cur^1][j-1]) % MOD + MOD) % MOD;
        }
    }
    printf("%d\n%d\n", f[cur][m], g[cur][m]);
    return 0;
}
```

---

## 作者：lkytxdy (赞：1)

## P2516 [HAOI2010]最长公共子序列

> 给出两个串 $a,b$，求最长公共子序列的长度及方案数，后者对 $10^8$ 取模。
>
> $|a|,|b|\leq 5000$。


设 $f_{i,j}$ 表示 $a_{1\sim i}$ 与 $b_{1\sim j}$ 的最长公共子序列长度，则 $f_{i,j}=\max\{f_{i-1,j-1}+[a_i=b_j],f_{i-1,j},f_{i,j-1}\}$。

考虑 $g_{i,j}$ 表示方案数，但是会重复计算。具体来说，经过 $f_{i-1,j},f_{i,j-1}\to f_{i,j}$ 后，如果 $a_i\neq b_j$ 而 $f_{i,j}=f_{i-1,j-1}$，那么必然满足 $f_{i,j}=f_{i-1,j}$ 且 $f_{i,j}=f_{i,j-1}$，也就是 $g_{i-1,j},g_{i,j-1}$ 都贡献进了 $g_{i,j}$。考虑 $g_{i-1,j},g_{i,j-1}$ 分别是什么，暂记 $S$ 表示最长公共子序列，前者包括了 $a_i\not\in S,b_j\not\in S$ 或 $a_i\not\in S,b_j\in S$ 的情况，后者包括了 $a_i\not\in S,b_j\not\in S$ 或 $a_i\in S,b_j\not\in S$ 的情况，不难发现 $a_i\not\in S,b_j\not\in S$ 的情况被重复计算了，所以应减去 $g_{i-1,j-1}$。

时间复杂度 $\mathcal O(nm)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e3+5,mod=1e8;
int n,m,cur=1,pre;
char a[N],b[N];
struct node{
	int v,cnt;
	friend void operator+=(node &a,node b){
		node c;
		c.v=max(a.v,b.v),c.cnt=((a.v==c.v)*a.cnt+(b.v==c.v)*b.cnt)%mod,a=c;
	}
}f[2][N];
signed main(){
	scanf("%s%s",a+1,b+1),n=strlen(a+1)-1,m=strlen(b+1)-1;
	for(int i=0;i<=n;i++){
		swap(cur,pre);
		for(int j=0;j<=m;j++) f[cur][j]={0,0};
		for(int j=0;j<=m;j++){
			if(!i&&!j) f[cur][j]={0,1};
			if(i) f[cur][j]+=f[pre][j];
			if(j) f[cur][j]+=f[cur][j-1];
			if(i&&j){
				if(a[i]==b[j]) f[cur][j]+={f[pre][j-1].v+1,f[pre][j-1].cnt};
				else f[cur][j]+={f[pre][j-1].v,mod-f[pre][j-1].cnt};
			}
		}
	}
	printf("%d\n%d\n",f[cur][m].v,f[cur][m].cnt);
	return 0;
}
```



---

## 作者：快斗游鹿 (赞：0)

## 思路

先看第一问，比较简单。设 $f_{i,j}$ 表示第一个字符串的前 $i$ 个和第二个字符串的前 $j$ 个能找到的最长公共子序列的长度。

考虑转移。当 $s_i=t_j$，即当前两个字符串字符相同，则 $f_{i,j}=f_{i-1,j-1}+1$，最长公共子序列的长度加一。

否则，$f_{i,j}=\max(f_{i-1,j},f_{i,j-1})$。

接着看第二问，如何统计个数。设 $c_{i,j}$ 表示第一个字符串的前 $i$ 个和第二个字符串的前 $j$ 个能找到的最长公共子序列的个数。如果 $s_i=t_j$，$c_{i,j}+=c_{i-1,j-1}$。而若 $f_{i-1,j}=f_{i,j}$，$c_{i,j}+=c_{i-1,j}$，因为两者最长公共子序列长度相等。同理，若 $f_{i,j-1}=f_{i,j}$，$c_{i,j}+=c_{i,j-1}$。但需要注意，如果 $f_{i-1,j-1}=f_{i,j}$，我们要减去 $c_{i-1,j-1}$。因为这一部分被我们重复计算了。

本题卡空间，需要使用滚动数组优化空间。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e3+5;
const int mod=1e8;
int f[2][N],cnt[2][N],now;
string s,t;
int read(){
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return x*f;
}
int main(){
	cin>>s>>t;
	int n=s.length();
	int m=t.length();
	for(int j=0;j<=m;j++)cnt[0][j]=1;
	cnt[1][0]=1;
	for(int i=1;i<n;i++,now^=1){
		for(int j=1;j<m;j++){
			if(s[i-1]==t[j-1]){
				f[now^1][j]=f[now][j-1]+1;
			}
			else f[now^1][j]=max(f[now][j],f[now^1][j-1]);
			cnt[now^1][j]=0;
			if(s[i-1]==t[j-1]){
				cnt[now^1][j]+=cnt[now][j-1];
				cnt[now^1][j]%=mod;
			} 
			if(f[now][j]==f[now^1][j]){
				cnt[now^1][j]+=cnt[now][j];
				cnt[now^1][j]%=mod;
			}
			if(f[now^1][j-1]==f[now^1][j]){
				cnt[now^1][j]+=cnt[now^1][j-1];
				cnt[now^1][j]%=mod;
			}
			if(f[now][j-1]==f[now^1][j]){
				cnt[now^1][j]-=cnt[now][j-1];
				cnt[now^1][j]%=mod;
			}
		}
	}
	cout<<f[now][m-1]<<endl;
	cout<<(cnt[now][m-1]%mod+mod)%mod;
	return 0;
}

```


---

## 作者：0x3F (赞：0)

对于第一问，有一个显而易见的思路：设 $dp_{i,j}$ 表示 $X$ 的长为 $i$ 的前缀和 $Y$ 的长为 $j$ 的前缀的 LCS 的长度，转移方程为 $dp_{i,j}=\max\{dp_{i-1,j},dp_{i,j-1},dp_{i-1,j-1}+[a_{i}=b_{j}]\}$。

现在考虑第二问，只要同时记录 $cnt_{i,j}$ 表示 LCS 的数量，就可以了。

但是仔细想一想会发现有问题：对于相同的 LCS，会被转移多次，从而也会被计算多次。我们要让同一个 LCS 只有一种转移方法，具体地：可以强制让 $j$ 先增加，$i$ 后增加。

可以这样做：

记 $dp1_{i,j}$ 表示 $A_i$ 和 $B_j$ 都必须被选取。

$dp2_{i,j}$ 表示 $A_i$ 必须被选取，$B_j$ 没有限制。

$dp3_{i,j}$ 表示 $A_i$ 和 $B_j$ 都没有限制。

转移方式为：

$dp1_{i,j}=dp3_{i-1,j-1}+1$，当 $A_i=B_j$

$dp2_{i,j}=\min\{dp1_{i,j},dp2_{i,j-1}\}$

$dp3_{i,j}=\min\{dp2_{i,j},dp3_{i-1,j}\}$

这时再记录 $cnt1,cnt2,cnt3$ 就可以了。我是用结构体实现的。

还有，这题卡空间，需要使用滚动数组。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int _ = 5010;
char arr[_], brr[_];
int n, m;
struct node {
	int val;
	int cnt;
} dp1[_][2], dp2[_][2], dp3[_][2];
inline node Mg(node a, node b) {
	if (a.val > b.val) {
		return a;
	} else if (a.val < b.val) {
		return b;
	} else {
		return node{a.val, (a.cnt + b.cnt) % 100000000};
	}
}
int main() {
	cin >> (arr+1) >> (brr+1);
	n = strlen(arr+1) - 1;
	m = strlen(brr+1) - 1;
	for (int i = 0; i <= n; i++) {
		dp1[i][0] = dp2[i][0] = dp3[i][0] = node{-1, 0};
	}
	for (int j = 1; j <= m; j++) {
		for (int i = 0; i <= n; i++) {
			dp1[i][j&1] = dp2[i][j&1] = dp3[i][j&1] = node{-1, 0};
		}
		for (int i = 1; i <= n; i++) {
			if (arr[i] == brr[j]) dp1[i][j&1] = Mg(node{dp3[i-1][(j-1)&1].val + 1, dp3[i-1][(j-1)&1].cnt}, node{1, 1});
			dp2[i][j&1] = Mg(dp1[i][j&1], dp2[i][(j-1)&1]);
			dp3[i][j&1] = Mg(dp2[i][j&1], dp3[i-1][j&1]);
		}
	}
	cout << dp3[n][m&1].val << endl << dp3[n][m&1].cnt << endl;
	return 0;
}
```


---

## 作者：Natori (赞：0)

>[P2516 [HAOI 2010] 最长公共子序列](https://www.luogu.com.cn/problem/P2516)

好久都没写题解了。

感觉这题应该是中等偏下难度的蓝，评紫有点过了。

下设两个字符串去掉最后的 ```.``` 后为 $a,b$，设 $n,m$ 同级。

对于第一问，使用朴素的 $\mathcal{O}(n^2)$ $\text{DP}$ 即可：设 $f_{i,j}$ 为考虑 $a$ 的前 $i$ 个字符，$b$ 的前 $j$ 个字符时， $\text{LCS}$ 的长度。

边界条件 $f_{0,0}=0$。

枚举 $i,j$，则有转移：

$$f_{i,j}=\max \{f_{i-1,j},f_{i,j-1},(f_{i-1,j-1}+1) \times [a_i=b_j] \}$$

在第一问的基础上，第二问同样考虑 $\text{DP}$：设 $g_{i,j}$ 为考虑 $a$ 的前 $i$ 个字符，$b$ 的前 $j$ 个字符时，长度为 $f_{i,j}$ 的 $\text{LCS}$ 个数。

边界条件 $\forall i \in [0,n],g_{i,0}=1$，$\forall j \in [0,m],g_{0,j}=1$。

转移分几种情况：

- $f_{i,j}=f_{i-1,j}$ 时，根据加法原理，$g_{i,j} \leftarrow g_{i,j}+g_{i-1,j}$。

- 同理，$f_{i,j}=f_{i,j-1}$ 时，$g_{i,j} \leftarrow g_{i,j}+g_{i,j-1}$。

- $a_i=b_j$ 且 $f_{i,j}=f_{i-1,j-1}+1$ 时，$g_{i,j} \leftarrow g_{i,j}+g_{i-1,j-1}$。

注意上面三种情况是不互相矛盾的。

然而，$a_i \ne b_j$ 但 $f_{i,j}=f_{i-1,j-1}$ 时，$g_{i,j}$ 要减去 $g_{i-1,j-1}$。

因为此时 $g_{i-1,j-1}$ 已经贡献到了 $g_{i-1,j}$ 和 $g_{i,j-1}$，而后两者又都对 $g_{i,j}$ 有贡献，这样就导致 $g_{i-1,j-1}$ 被多算了一次，需要减掉。

时间/空间复杂度都是 $\mathcal{O}(n^2)$，但由于空间限制是 $\text{125 MB}$，所以需要使用滚动数组，于是空间复杂度被优化至 $\mathcal{O}(n)$，实测仅需 $\text{808 KB}$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e3+7,mod=1e8;
int qplus(int x,int y){
	int res=x+y;
	if(res>=mod)
		return res-mod;
	if(res<0)
		return res+mod;
	return res;
}
int n,m;
char a[N],b[N];
int f[2][N],g[2][N];
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>(a+1)>>(b+1);
	n=strlen(a+1)-1;
	m=strlen(b+1)-1;
	g[1][0]=1;
	for(int i=0;i<=m;i++)
		g[0][i]=1;
	for(int i=1;i<=n;i++){
		/*由于是滚动数组，转移之前一定要清空*/
		for(int j=1;j<=m;j++)
			f[i&1][j]=g[i&1][j]=0;
		for(int j=1;j<=m;j++){
			/*更新 f*/
			f[i&1][j]=max(f[i&1^1][j],f[i&1][j-1]);
			if(a[i]==b[j])
				f[i&1][j]=max(f[i&1][j],f[i&1^1][j-1]+1);
			/*更新 g*/
			if(f[i&1][j]==f[i&1^1][j])
				g[i&1][j]=qplus(g[i&1][j],g[i&1^1][j]);
			if(f[i&1][j]==f[i&1][j-1])
				g[i&1][j]=qplus(g[i&1][j],g[i&1][j-1]);
			if(a[i]==b[j]&&f[i&1][j]==f[i&1^1][j-1]+1)
				g[i&1][j]=qplus(g[i&1][j],g[i&1^1][j-1]);
			if(a[i]!=b[j]&&f[i&1][j]==f[i&1^1][j-1])
				g[i&1][j]=qplus(g[i&1][j],-g[i&1^1][j-1]);
		}
	}
	cout<<f[n&1][m]<<'\n'<<g[n&1][m];
	return 0;
}
```

---


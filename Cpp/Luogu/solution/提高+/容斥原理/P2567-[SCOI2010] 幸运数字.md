# [SCOI2010] 幸运数字

## 题目背景

四川 NOI 省选 2010。


## 题目描述

在中国，很多人都把 $6$ 和 $8$ 视为是幸运数字！lxhgww 也这样认为，于是他定义自己的“幸运号码”是十进制表示中只包含数字 $6$ 和 $8$ 的那些号码，比如 $68$，$666$，$888$ 都是“幸运号码”！但是这种“幸运号码”总是太少了，比如在 $[1,100]$ 的区间内就只有 $6$ 个（$6$，$8$，$66$，$68$，$86$，$88$），于是他又定义了一种“近似幸运号码”。lxhgww 规定，凡是“幸运号码”的倍数都是“近似幸运号码”，当然，任何的“幸运号码”也都是“近似幸运号码”，比如 $12$，$16$，$666$ 都是“近似幸运号码”。

现在 lxhgww 想知道在一段闭区间 $[a, b]$ 内，“近似幸运号码”的个数。

## 说明/提示

对于 $30\%$ 的数据，保证 $1\le a\le b\le10^6$。

对于 $100\%$ 的数据，保证 $1\le a\le b\le10^{10}$。


## 样例 #1

### 输入

```
1 10```

### 输出

```
2```

# 题解

## 作者：yybyyb (赞：69)

~~成功轰下你谷rk1，甚至超越了一个打表选手~~  
这题思路很明显吧，先搞出来所有范围内的合法数字，然后直接容斥，  
容斥的话显然没有别的办法解决，只能够爆搜，  
那么我们就来大力剪枝：  
1.如果当前的所有选定的数的$lcm$大于$r$直接退出，这不显然吗。。  
2.如果一个合法数字是另外一个合法数字的倍数，那么这个数没有意义，这不还是显然吗。  
3.把合法的所有数字从大往小排序，这样爆搜的时候更快突破边界。  
好了，这样子就可以在洛谷上$AC$了，然而$BZOJ$总时限并过不去。  
接着剪枝，现在因为所有数都不满足是另外一个数的倍数，  
所以合并任意两个数的时候，$lcm$的最小情况就是乘上一个$3$。    
所以对于所有$>r/3$的合法数字，显然不能够和任何一个数合并了，  
所以这一部分可以拿出来直接提前算好，再用剩下的数字爆搜就好啦。  
~~也许底下那个题解说只提前考虑r/2的值就是没我快的原因吧。。。~~
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
#define ll long long
int tot;
ll a[5050],ret,l,r;
void dfs(ll x){if(x>r)return;if(x)a[++tot]=x;dfs(x*10+6);dfs(x*10+8);}
const int MOD=1000000007;
bool check(ll a,ll b)
{
	int A=a/MOD,B=b/MOD;
	if(A*B)return true;
	return a*b>r;
}
void calc(int x,ll s,int cnt)
{
    if(x>tot&&s!=1)
    {
        if(cnt&1)ret+=r/s-l/s;
        else ret-=r/s-l/s;
        return;
    }
    if(x>tot)return;
    calc(x+1,s,cnt);
	ll d=a[x]/__gcd(s,a[x]);
    if(!check(s,d))calc(x+1,s*d,cnt+1);
}
bool vis[5050];
ll Work()
{
	dfs(0);sort(&a[1],&a[tot+1]);
	int t=0;
	for(int i=1;i<=tot;++i)
		for(int j=1;j<i;++j)
			if(a[i]%a[j]==0){vis[i]=true;break;}
	for(int i=1;i<=tot;++i)
		if(!vis[i])
		{
			if(a[i]<=r/3)a[++t]=a[i];
			else ret+=r/a[i]-l/a[i];
		}
	tot=t;reverse(&a[1],&a[tot+1]);calc(1,1,0);
	return ret;
}
int main()
{
	cin>>l>>r;--l;
	cout<<Work()<<endl;
	return 0;
}

```

---

## 作者：xyz32768 (赞：39)

先预处理$[1,10^{10}]$内的所有幸运号码。

对于一个幸运号码$X$，在$[A,B]$中$X$的倍数的个数，就是

$\lfloor\frac{B}{X}\rfloor-\lceil\frac{A}{X}\rceil+1$。

然而，两个幸运号码对应的近似幸运号码可能有交集。考虑到这一点，就可以用容斥，也就是：

选$1$个幸运号码$-$选$2$个幸运号码的lcm$+$选$3$个幸运号码的lcm$-...$

但是直接做是$2^{2046}$的，啃腚会TLE。考虑$3$个剪枝：

1、发现对于两个幸运号码$a,b$，如果$a|b$，那么对于所有的$b|x$就一定有$a|x$，因此这样的$b$是不必要的。去掉所有这样的$b$后，还剩下$943$个幸运号码。
2、当前的lcm一旦大于$B$就不再继续搜索。这样复杂度就能大大降低。

3、将预处理出的幸运号码从大到小排序，使lcm能更快地超越上界$B$。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 1e4 + 5;
ll A, B, a[N], num[N], Ans;
int tot, n; bool mark[N];
void dfs1(int dep, int cnt, ll now, ll x) {
    if (dep > cnt) return (void) (a[++tot] = now);
    dfs1(dep + 1, cnt, now + x * 6, x * 10);
    dfs1(dep + 1, cnt, now + x * 8, x * 10);
}
void sieve() {
    int i, j;
    for (i = 1; i <= tot; i++) {
        if (!mark[i]) num[++n] = a[i];
        for (j = i + 1; j <= tot; j++)
            if (a[j] % a[i] == 0) mark[j] = 1;
    }
}
ll Cnt(ll l, ll r, ll PYZ) {
    l = l / PYZ + (l % PYZ != 0); r /= PYZ;
    return r - l + 1;
}
void dfs2(int dep, int cnt, ll val) {
    if (val > B) return;
    if (dep > n) {
        if (cnt == 0) return;
        Ans += Cnt(A, B, val) * ((cnt & 1) ? 1 : -1);
        return;
    }
    dfs2(dep + 1, cnt, val);
    ll tmp = val / __gcd(val, num[dep]);
    if (1.0 * tmp * num[dep] <= B)
        dfs2(dep + 1, cnt + 1, tmp * num[dep]);
}
bool comp(ll a, ll b) {return a > b;}
int main() {
    int i; cin >> A >> B;
    for (i = 1; i <= 10; i++) dfs1(1, i, 0, 1);
    sieve(); sort(num + 1, num + n + 1, comp);
    cout << (dfs2(1, 0, 1), Ans) << endl;
    return 0;
}
```

---

## 作者：critnos (赞：35)

关于更多分块打表的内容，可以参见我写的日报 [浅谈打表与其技巧](https://www.luogu.com.cn/blog/203623/guan-yu-da-biao)

分块打表如闪电般的啪的一下就过了，很快啊！

这题还不用卡表长，真是分块打表好的入门题（

先 dfs 出所有的幸运数字，发现只有 2046 个。

```cpp
void dfs(ll d)
{
	if(d>up) return;
	if(d) a[++cnt]=d;
	dfs(d*10+6),dfs(d*10+8);
}
```


然后我们需要设计出一个函数他支持求 $[l,r]$ 中近似幸运数字的个数

枚举幸运数字，利用类似埃筛和 P1835 的做法筛出来。

$10^{10}$ 的数据范围的话，表长选 $b=2\times 10^6$ 差不多。

```cpp
int ask(ll l,ll r)
{
	int i,s=0;
	memset(t,0,sizeof(t));
	for(i=1;i<=cnt;i++)
		for(ll p=a[i],j=r/p*p;j>=l;j-=p)
			t[j-l]=1;
	for(ll j=l;j<=r;j++)
		s+=t[j-l];
	return s;
}
```
然后就可以利用这个函数进行打表：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll a[100005];
int cnt;
const ll up=1e10;
void dfs(ll d)
{
	if(d>up) return;
	if(d) a[++cnt]=d;
	dfs(d*10+6),dfs(d*10+8);
}
const int bl=2e6;
bool t[bl+5];
int ask(ll l,ll r)
{
	int i,s=0;
	memset(t,0,sizeof(t));
	for(i=1;i<=cnt;i++)
		for(ll p=a[i],j=r/p*p;j>=l;j-=p)
			t[j-l]=1;
	for(ll j=l;j<=r;j++)
		s+=t[j-l];
	return s;
}
signed main()
{
	freopen("out","w",stdout);
   dfs(0);
    ll i,j,l,r;
    for(i=0;i+bl<=up;i+=bl)
    {
    	l=i+1,r=i+bl;
    	printf("%d,",ask(l,r));
	}
}
```
跑了 8s 就出来了，很快啊！

最后还可以利用这个函数做最终的提交程序：https://www.luogu.com.cn/paste/c1lr3rkh

---

## 作者：Night_Aurora (赞：17)

和楼下思想差不多

预处理出幸运数，把有倍数关系的两个数中较大的数删掉，从大到小排序组成真幸运数数列

再DFS+微量剪枝来容斥

取件查询[l,r]可以转换为前缀r和l-1的查询

但是遇到了一个很大的问题

6E+9秒出，7E+9就卡死了

因为这之间多出了一倍的真幸运数，导致运行时间翻指数倍

于是考虑一下怎么优化

对于>R/2的真幸运数，它对答案的贡献每个有且仅有1

因为<=R/2的真幸运数都不是>R/2的真幸运数的因数，且>R/2的那些数只有本身对答案有贡献，翻倍就会超过R而失去贡献

所以对于求前缀R的伪幸运数个数，我们只保留<=R/2的那些幸运数来DFS，再加上>R/2且<=R的真幸运数

因为前缀查询最大1E+10，/2=5E+5 刚好能秒出

---
果然玄学出奇迹啊

[代码](http://paste.ubuntu.com/25423772/)


---

## 作者：封禁用户 (赞：13)

很明显，这题用容斥来做。

![容斥原理](https://imgconvert.csdnimg.cn/aHR0cDovL3d3dy5jcHBibG9nLmNvbS9pbWFnZXMvY3BwYmxvZ19jb20vdmljaS8wMDAucG5n?x-oss-process=image/format,png)

先预处理出所用小于 $b$ 的幸运数字，然后进行排序，筛选出不是其它幸运数字倍数的数字，再从大到小排序，方便来进行剪枝优化。

**注意由于可能爆 long long，所以比较时应先转浮点数。**

注意 $p$ 要取两数的最小公倍数。

满分代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
long long s[10010],num[10010],a,b,ans = 0;
int cnt = -1,n = 0;
void dfs(long long p)
{
	if(p > b) return;
	num[++cnt] = p;
	dfs(p*10+6);
	dfs(p*10+8);
}
void get(int t,long long p,int u)
{
	ans += (b/p - (a-1)/p) * u;
	for(int i = t+1;i <= n;++i) 
		if(1.0*p/__gcd(p,s[i])*s[i] <= b)
			get(i,p/__gcd(p,s[i])*s[i],-u);	
}
int main()
{
	scanf("%lld%lld",&a,&b);
	dfs(0);
	sort(num+1,num+cnt+1);
	for(int i = 1;i <= cnt;++i)
	{
		if(!num[i]) continue; 
		for(int j = i+1;j <= cnt;++j)
			if(num[j] % num[i] == 0)	
				num[j] = 0;
	}
	for(int i = 1;i <= cnt;++i) 
		if(num[i])
			s[++n] = num[i];
	reverse(s + 1,s + n + 1);
	get(0,1,1);
	cout<<b - a + 1 - ans;		
	return 0;
} 
```


---

## 作者：pengzy___ (赞：6)

正如题目标签所说，这是一道 $dfs$ 剪枝 + 容斥原理的题目。

### 思路：

首先，要从所有的数里面筛出幸运数字。

如果从 $1$ 到 $10^{10}$ 循环，那是肯定会超时的。

用如下代码进行递归，求出含有 $6$ 和 $8$ 的幸运数字：
```cpp
init(6);
init(8);
void init(ll x)
{
	if(x>=MAX)return;//若超出了范围则返回
	v.push_back(x);//将递归到的数放入vector中
	init(x*10+6);//递归含有6的幸运数字
	init(x*10+8);//递归含有8的幸运数字
}
```

现在，所有的幸运数字就都在 $v$ 数组里了。

对于一个幸运数字 $x$，在区间 $[L,R]$ 中，会有 $\frac{(R-L+1)}{x}$ 个 $x$ 的倍数，也就是近似幸运数字（除 $x$ 之外）。但是，对于任意的多个幸运数字，无法保证它们的倍数，也就是近似幸运数字是不重复的，这样，那个数就被计算了多次。我们考虑用容斥原理筛掉被计算多次的数。

假设在区间 $[L,R]$ 中，有 $a,b$ 两个幸运数字，并且 $L$ 和 $R$ 之间的距离无限，那么当一个近似幸运数字是 $lcm(a,b)$ 的倍数时，它就重复地被统计了 $\frac{(R-L+1)}{lcm(a,b)}$ 次。

众所周知，$lcm(a,b)=a\times b/gcd(a,b)$

容斥原理：$\frac{(R-L+1)}{a}+\frac{(R-L+1)}{b}+\frac{(R-L+1)}{c}-\frac{(R-L+1)}{lcm(a,b)}-\frac{(R-L+1)}{lcm(a,c)}-\frac{(R-L+1)}{lcm(b,c)}+\frac{(R-L+1)}{lcm(a,b,c)}$

小优化，两个幸运数字若成倍数关系，则删去较大的幸运数字。

当 $lcm(a,b)$ 大于范围时就不能操作了，所以要给记录下来的幸运数字排序。

### 代码：
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const ll MAX=1e10;
ll L,R,ans;
vector<ll> v,t;//v记录幸运数字
inline ll read()//十年OI一场空，不开longlong见祖宗
{
	ll x=0,f=1;char c=getchar();//x和f一定要开longlong！！！卡了我一天
	while(!isdigit(c)){if(c=='-')f=-1,c=getchar();}
	while(isdigit(c)){x=x*10+c-48,c=getchar();}
	return x*f;
}
void write(ll x)
{
	if(x>9)write(x/10);
	if(x<0)putchar('-'),x=-x;
	putchar(x%10+'0');
}
ll GCD(ll a,ll b)//辗转相除法求gcd，也可以用__gcd
{
	return a?GCD(b%a,a):b;
}
void init(ll x)
{
	if(x>=MAX)return;
	v.push_back(x);
	init(x*10+6);
	init(x*10+8);
}
void dfs(int pos,ll lcm,ll x,int cnt)//容斥
{
	if(pos==-1) {
		if(cnt) {
			if(cnt&1)ans+=x/lcm;
			else ans-=x/lcm;
		}
		return;
	}
	__int128 gcd=GCD(lcm,v[pos]);//不用__int128会爆
	if(lcm/gcd*v[pos]<=x)
	    dfs(pos-1,lcm/gcd*v[pos],x,cnt+1);
	dfs(pos-1,lcm,x,cnt);
}
ll solve(ll n)
{
	ans=0;
	ll m=upper_bound(v.begin(),v.end(),n)-v.begin();
	dfs(m-1,1,n,0);
	return ans;
}
int main()
{
	init(6);
	init(8);
	sort(v.begin(),v.end());//排序
	for(ll num1:v) {//将多余的倍数去除
   //等同于for(ll i=0;i<v.size();i++)num1=v[i];
		bool f=true;
		for(ll num2:t)
		    if(num1%num2==0) {
		    	f=false;
		    	break;
			}
		if(f)t.push_back(num1);
	}
	swap(t,v);//O(1)的时间内交换地址，v得到了去重后的结果
	L=read(),R=read();
	write(solve(R)-solve(L-1));
	return 0;
}
```

从愚人节就开始想，到今天清明节才做好。

感谢 @frelion 巨佬教我

---

## 作者：I_am_AKed_by_NOI (赞：4)

前置芝士：容斥原理。

### 预处理

容易发现， $[1,10^{10}]$ 之间的幸运数字的总数只有 $2046$，我们可以直接使用 dfs 把他们预处理出来，接着从小到大排序。

程序如下：

```
void p_dfs(ll p)
{
	if(p>r) //如果 p 大于右边界就退出
	{
		return;
	}
	lucky[++cnt]=p; //将幸运数字 p 保存到数组中 
	p_dfs(p*10+6); //下一位是 6
	p_dfs(p*10+8); //下一位是 8
}
```
### 核心部分

已经计算出了幸运数字，现在考虑近似幸运数字的个数。

在 $[l,r]$ 这个区间中，幸运数字 $x$ 的出现次数为 $\lfloor \frac{r}{x} \rfloor-\lfloor\frac{l-1}{x}\rfloor$。但是两个幸运数字的倍数，即近似幸运号码可能有交集，所以需要容斥，

就是这个： 选 $1$ 个幸运数字 $-$ $[l,r]$ 之间数值为 $2$ 个幸运数字的 lcm 的个数 $+$ $[l,r]$ 之间数值为 $3$ 个幸运数字的 lcm 的个数......

然后拥有了这个代码（此代码看词来复杂度极高，但是多个幸运数字的 lcm 很大，很容易超过 $r$，所以复杂度其实挺小的）：

```
ll calc(ll x) //求 [l,r] 之间 x 出现了几次
{
	return r/x-(l-1)/x; 
}
ll _lcm(ll a,ll b) //求 a,b 的 lcm
{
	return a*b/__gcd(a,b);
}
ll dfs(ll last,ll lcm,ll opt)
//last 是上一个幸运数字的位置
//lcm 是前几个幸运数字的 lcm
//opt 是当前要加要减（在容斥中的符号有变化）
{
	ll ans=0;
	for(int i=last;i<2047;i++) //枚举每一个幸运数字
	{
		ll tmp1=_lcm(lcm,lucky[i]); //加上这个数字的 lcm
		if(tmp1<=r && tmp1>0) //不超过上界，并且要 >0（小余 0 就溢出了）
		{
			ans+=opt*calc(tmp1); //累加答案
			ans+=dfs(i+1,tmp1,-opt); //记得变符号
		}
	}
	return ans;
}
```

~~然后就 T 了……~~

[TLE 记录](https://www.luogu.com.cn/record/101737951)

### 剪枝

发现一点：如果有两个幸运数字 $x,y$ 并且 $x \bmod y=0$，那么 $y$ 根本没有用，因为是 $y$ 倍数的近似幸运数字一定是 $x$ 的倍数。

所以我们可以在预处理时将 $y$ 给去除，这样子剩下的幸运数字会少很多，大概 $1000$ 左右吧，此时就可以通过了。



---

## 作者：XioasDog (赞：4)

# P2567幸运数字

### Description

计算 $[l,r]$ 之间有多少个数满足含 $6$ 或含 $8$，或者是含 $6$ 或含 $8$ 的数的倍数。

### Solution

容斥。

我们要先找出幸运数字，才能检索近似幸运数字。这一部分直接跑一个搜索即可。

接下来考虑使用dfs求解。

搜索的意义很简单，就是在 $[a,b]$ 内，是 $k$ 的倍数的数的个数。

对于每个 $k$，答案显然为 $\lfloor b/k \rfloor -\lceil a/k \rceil +1$。

但搜索的复杂度奇高无比，故考虑剪枝。

剪枝的过程也十分好理解，即当 $x>b$（$x$ 意同上方）时可以停止搜索；此外，可以将原序列进行从大到小排序，使 $x$ 尽快大于 $b$ 。

此时的代码依旧错误，原因是我们算重了很多（譬如 $6$ 在算 $2$ 和 $3$ 的时候都算了），考虑容斥。

令 $f_x$ 指在题目区间内 $x$ 的倍数个数，则 $Ans=f_a+f_b+f_c...-f_{\rm{lcm}(a,b)}-f_{\rm {lcm}(a,c)}-f_{\rm{ lcm}(b,c)}...+f_{\rm {lcm}(a,b,c)}+...$ 

### Code

```cpp
#include <iostream>
#include <algorithm>
#include <cmath>
#define int long long
using namespace std;

const int N=1e6+9;
int a,b,ans;
int l[N],tot,luc[N],len;
bool mark[N];
void dfs(int sta){
    if(sta>b)return;
    if(sta)l[++tot]=sta;
    bfs(sta*10+6);
    bfs(sta*10+8);
}
bool cmp(int a,int b){return a>b;}
__int128 gcd(__int128 a,__int128 b){
    if(!b)return a;
    else return gcd(b,a%b);
}
__int128 lcm(__int128 a,__int128 b){
	if(!a)return b;
	return a/gcd(a,b)*b;
}
void dfs_(int t,int num,__int128 lsm){
	if(lsm>b)return;
    if(t>len){
    	if(!lsm)return;
        int jud=(num%2)?1:-1;
        ans+=jud*(floor(1.0*b/lsm)-ceil(1.0*a/lsm)+1);
        return;
    }   
    dfs_(t+1,num+1,lcm(lsm,luc[t]));
    dfs_(t+1,num,lsm);
}

signed main(){
    scanf("%lld%lld",&a,&b);
    dfs(0);
    for(int i=1;i<=tot;i++){
        if(!mark[i])luc[++len]=l[i];
        for(int j=i+1;j<=tot;j++)
            if(!(l[j]%l[i]))mark[j]=true;
    }//筛去已经是倍数的幸运数字
    sort(luc+1,luc+1+len,cmp);
    dfs_(1,0,0);
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：pengzy___ (赞：2)

正如题目标签所说，这是一道 $dfs$ 剪枝 + 容斥原理的题目。

### 思路：

首先，要从所有的数里面筛出幸运数字。

如果从 $1$ 到 $10^{10}$ 循环，那是肯定会超时的。

用如下代码进行递归，求出含有 $6$ 和 $8$ 的幸运数字：
```cpp
init(6);
init(8);
void init(ll x)
{
	if(x>=MAX)return;//若超出了范围则返回
	v.push_back(x);//将递归到的数放入vector中
	init(x*10+6);//递归含有6的幸运数字
	init(x*10+8);//递归含有8的幸运数字
}
```

现在，所有的幸运数字就都在 $v$ 数组里了。

对于一个幸运数字 $x$，在区间 $[L,R]$ 中，会有 $\frac{(R-L+1)}{x}$ 个 $x$ 的倍数，也就是近似幸运数字（除 $x$ 之外）。但是，对于任意的多个幸运数字，无法保证它们的倍数，也就是近似幸运数字是不重复的，这样，那个数就被计算了多次。我们考虑用容斥原理筛掉被计算多次的数。

假设在区间 $[L,R]$ 中，有 $a,b$ 两个幸运数字，并且 $L$ 和 $R$ 之间的距离无限，那么当一个近似幸运数字是 $lcm(a,b)$ 的倍数时，它就重复地被统计了 $\frac{(R-L+1)}{lcm(a,b)}$ 次。

众所周知，$lcm(a,b)=a\times b/gcd(a,b)$

容斥原理：$\frac{(R-L+1)}{a}+\frac{(R-L+1)}{b}+\frac{(R-L+1)}{c}-\frac{(R-L+1)}{lcm(a,b)}-\frac{(R-L+1)}{lcm(a,c)}-\frac{(R-L+1)}{lcm(b,c)}+\frac{(R-L+1)}{lcm(a,b,c)}$

小优化，两个幸运数字若成倍数关系，则删去较大的幸运数字。

当 $lcm(a,b)$ 大于范围时就不能操作了，所以要给记录下来的幸运数字排序。

### 代码：
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const ll MAX=1e10;
ll L,R,ans;
vector<ll> v,t;//v记录幸运数字
inline ll read()//十年OI一场空，不开longlong见祖宗
{
	ll x=0,f=1;char c=getchar();//x和f一定要开longlong！！！卡了我一天
	while(!isdigit(c)){if(c=='-')f=-1,c=getchar();}
	while(isdigit(c)){x=x*10+c-48,c=getchar();}
	return x*f;
}
void write(ll x)
{
	if(x>9)write(x/10);
	if(x<0)putchar('-'),x=-x;
	putchar(x%10+'0');
}
ll GCD(ll a,ll b)//辗转相除法求gcd，也可以用__gcd
{
	return a?GCD(b%a,a):b;
}
void init(ll x)
{
	if(x>=MAX)return;
	v.push_back(x);
	init(x*10+6);
	init(x*10+8);
}
void dfs(int pos,ll lcm,ll x,int cnt)//容斥
{
	if(pos==-1) {
		if(cnt) {
			if(cnt&1)ans+=x/lcm;
			else ans-=x/lcm;
		}
		return;
	}
	__int128 gcd=GCD(lcm,v[pos]);//不用__int128会爆
	if(lcm/gcd*v[pos]<=x)
	    dfs(pos-1,lcm/gcd*v[pos],x,cnt+1);
	dfs(pos-1,lcm,x,cnt);
}
ll solve(ll n)
{
	ans=0;
	ll m=upper_bound(v.begin(),v.end(),n)-v.begin();
	dfs(m-1,1,n,0);
	return ans;
}
int main()
{
	init(6);
	init(8);
	sort(v.begin(),v.end());//排序
	for(ll num1:v) {//将多余的倍数去除
   //等同于for(ll i=0;i<v.size();i++)num1=v[i];
		bool f=true;
		for(ll num2:t)
		    if(num1%num2==0) {
		    	f=false;
		    	break;
			}
		if(f)t.push_back(num1);
	}
	swap(t,v);//O(1)的时间内交换地址，v得到了去重后的结果
	L=read(),R=read();
	write(solve(R)-solve(L-1));
	return 0;
}
```

$2022.4.1-2022.4.4$

感谢 @frelion 巨佬教我

---

## 作者：Pwtking (赞：1)

主要思想：容斥。

首先我们先搜索出数据范围内的所有幸运数字，接下来用容斥原理爆搜即可。

这里需要注意几点：

爆搜肯定会超时，考虑剪枝：不选超过 $b$ 范围的数和**是其他幸运数字的数**，同时将我们选出的最终幸运数字序列从大到小排序使 $\operatorname{lcm}$ 尽量快的超过上届。

其次，最终合法的数字会爆 long long，所以要开 __int128 或者将数字转化为浮点数，否则会超时。

---


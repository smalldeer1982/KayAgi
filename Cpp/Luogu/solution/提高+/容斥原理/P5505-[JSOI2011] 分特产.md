# [JSOI2011] 分特产

## 题目描述

JYY 带队参加了若干场 $\text{ACM/ICPC}$ 比赛，带回了许多土特产，要分给实验室的同学们。

JYY 想知道，把这些特产分给 $n$ 个同学，一共有多少种不同的分法？当然，JYY 不希望任何一个同学因为没有拿到特产而感到失落，所以每个同学都必须至少分得一个特产。

例如，JYY 带来了 $2$ 袋麻花和 $1$ 袋包子，分给 $A$ 和 $B$ 两位同学，那么共有 $4$ 种不同的
分配方法：

 $A$：麻花， $B$：麻花、包子

 $A$：麻花、麻花， $B$：包子

 $A$：包子， $B$：麻花、麻花

 $A$：麻花、包子， $B$：麻花

## 样例 #1

### 输入

```
5 4
1 3 3 5```

### 输出

```
384835```

# 题解

## 作者：Booksnow (赞：65)

# 容斥原理

## 解决方案

看了一下这道题的题解，我觉得没有人阐释清楚在容斥的时候**为什么会出现一加一减**的情况，所以自己附上一篇题解

我们设$g[i]$表示**刚好**有i个同学**没有土特产**，由于每个同学都**至少要获得一个土特产**，那么显然$g[0]$即为我们的答案。

### 接下来我们考虑如何求解g[0]

设$f[i]$表示**至少**有i个同学**没有土特产**，要想求解$g[0]$，我们得先解决f数组

### 求解f数组

我们可以根据$f[i]$的定义，**强制规定有i个同学没有土特产**，然后我们就能通过**隔板法**求得剩下的同学分特产的方案数。这里再仔细说明一下，$f[i]$表示的是**至少**有$i$个同学**没有土特产**，所以我们强制规定的作用就在于**维护f数组的这个性质**，又因为**至少**，所以我们不用保证剩下的同学每个人必须有特产，不了解**隔板法**的同学可以自己去百度上搜索一下，这里我便不再仔细阐述，单走一个在**可以为空的情况下**隔板的公式，既是将$m$个东西随意分给$n$个人的方案数为

$C_{m+n-1}^{n-1}$

然后我们**分别处理**每个特产分出去的方案数，**最后的乘积就是答案**。然后由于强制哪个同学也不确定，而规定$i$个同学不能选到的方案数其实就是**从$n$个人里面选出$i$个人的组合数**，即为

$C_n^i$

所以，综上所述

$f[i]=C_n^i\times\prod_j^mC_{a[j]+n-i-1}^{n-i-1}$

解释一下减去i的原因，$i$为强制没有特产的人数，所以后面分特产的人数就要**减去$i$**。

### 为什么最后的答案为$ans=\sum_{i=0}^{n-1} (-1)^if[i]$

其实我们可以发现，例如计算至少有一个人没有分到的方案数时，假设我们在**规定$x$不能选到时**，处理将特产分给剩下的$n-1$个人的时候，可能会出现有人分不到特产的情况，我们**有一种情况刚好是$y$没有分到特产**，那么在规定$y$不能选到时，我们也能找到$x$分不到特产的情况，我们忽略当规定某个人不能分到且另一个人刚好也没有分到的情况时其他人分到特产情况的方案数，原因是我们可以发现，对于$x$和$y$来说，当他们找到对方时，其他人分到特产的方案数是不变的。**所以我们可以默认在$f[1]$中，$g[2]$是被计算了两次的**，**因为在规定x不分到特产的情况下会出现y分不到特产的情况，但在y规定分不到特产时也会出现x分不到特产的情况**，所以说$g[2]$被计算了两次，我们以样例为例，可以发现

$f[0]=g[0]+g[1]+g[2]+g[3]+g[4]$

$f[1]=g[1]+g[2]*2+g[3]*3+g[4]*4$

$f[2]=g[2]+g[3]*3+g[4]*6$

$f[3]=g[3]+g[4]*4$

$f[4]=g[4]$

我们可以发现，通过上述的$ans$公式计算，答案刚好为$g[0]$，多试几次后发现这个规律具有**普遍性**，所以

$ans=\sum_{i=0}^{n-1} (-1)^iC_n^i\times\prod_j^mC_{a[j]+n-i-1}^{n-i-1}$

即为我们的答案，附上AC代码

## code

```
#include <bits/stdc++.h>
#pragma GCC optimize(2)
#pragma GCC optimize(3,"Ofast","inline")
using namespace std;
const int N=2010,MOD=1000000007;
typedef long long ll;
int n,m;
ll ans,a[N],c[N][N];    
 
inline void intial()    //初始化组合数 
{
    c[0][0]=1;
    for(int i=1;i<=N-5;i++){
        c[i][0]=1;
        for(int j=1;j<=i;j++)
            c[i][j]=(c[i-1][j]+c[i-1][j-1])%MOD;
    }
}
 
int main()
{
    intial();
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)    
        scanf("%lld",&a[i]);
    //设数组g[i]表示 刚好 有i个同学没有土特产，显然g[0]就是答案
    //设f[i]表示 至少 有i个同学没有土特产，通过计算发现每个f[i]可能会重复计算g[i]，以样例为例 
    //f[0]=g[0]+g[1]+g[2]+g[3]+g[4]
    //f[1]=g[1]+g[2]*2+g[3]*3+g[4]*4
    //f[2]=g[2]+g[3]*3+g[4]*6
    //f[3]=g[3]+g[4]*4
    //f[4]=g[4]
    //根据容斥原理得到公式： 
    //ans=f[0] -f[1]+f[2]-f[3]+...+(-1)(n次方)f[n] 
    for(int i=0;i<n;i++){        //强制任一i个同学没有特产，那么有c[n][i]种方法 
        ll res=c[n][i];             //隔板法，再通过可重复组合计算易得： 
        for(int j=1;j<=m;j++)        //m个东西随意分给n个人方案数为c[m+n-1][n-i-1],一共的方案数就要把这些土特产的方案数全部乘起来 
            res=res*c[a[j]+n-i-1][n-i-1]%MOD;
        if(i&1) ans=(ans-res+MOD)%MOD;      //求得f[i]后根据ans公式即可求解 
        else ans=(ans+res+MOD)%MOD; 
    }
    printf("%d\n",ans); 
    return 0;
}
```


---

## 作者：莫奈的崖径 (赞：25)

$qwq$为什么组合&容斥的题目难度都评的好高。

## 题意(简化版本)
有$n$个有标号的盒子和$m$种有标号的球，每种球有$a[i]$个，求每个盒子至少放一种球的总方案数。

## 分析
 
直接求合法方案数好像比较复杂，不如我们考虑补集转换？

总方案数（每个盒子可以为空）-不合法方案数=合法方案数（没有盒子为空）

根据简化后的题意，很自然地想到$TwelveFoldWay$，我们可以先考虑每一种$a[i]$的情况，也就是把$a[i]$个无标号的球放在$n$个有标号的盒子里，允许有空盒，也就是经典的$ULB$问题，方案数就应该是$C(n+a[i]-1,n-1)$，根据乘法原理，所以最后$m$种球的总方案就应该是$\prod_{i=1}^{m}C(n+a[i]-1,n-1)$。

那么现在考虑不合法方案数，如果总方案数中是可以有空的盒子，那么我们的不合法方案数就可以是：一个盒子为空，两个盒子为空...一直到有$n-1$个盒子为空的情况。

假设现在我们在求有$x$个盒子为空的情况，就相当于把$a[i]$个球放进了$n-x$个盒子当中，方案数$C(n-x+a[i]-1,n-x-1)$，根据乘法原理，有i个盒子为空对答案的贡献就应该是$\prod_{j=1}^{m}C(n-i+a[j]-1,n-i-1)$，又考虑到盒子是有标号的，我们选择不同的盒子为空，方案数也不同，于是就要在方案数基础上$*$一个$C(n,i)$，那么，有i个盒子为空的总贡献就应该是

$C(n,i)*\prod_{j=1}^{m}C(n-i+a[j]-1,n-i-1)$

已经到了这一步，相信大家就已经看出来接下来就是一个容斥了，那么最终的通式就应该是：

$\sum_{i=0}^{n-1}(-1)^iC(n,i)\prod_{j=1}^{m}C(n+a[j]-i-1,n-i-1)$

## AC代码

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define int long long
const int mod=1e9+7;
int c[2005][2005],n,m,a[2005];
int pow(int a,int b)
{
	int ans=1;
	while(b)
	{
		if(b&1)ans=ans*a%mod;
		a*a%mod;
		b>>=1;
	}
	return ans;
}
signed main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	scanf("%d",&a[i]);
	for(int i=0;i<=2000;i++)
	c[i][i]=c[i][0]=1;
	for(int i=1;i<=2000;i++)
		for(int j=1;j<=i;j++)
		c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;
	int ans=0;
	for(int i=0;i<=n-1;i++)
	{
		int cnt=1;
		for(int j=1;j<=m;j++)
		cnt=cnt*c[n+a[j]-i-1][n-i-1]%mod,cnt%=mod;
		if(i%2)ans=(ans-cnt*c[n][i]%mod+mod)%mod;
		else ans=(ans+cnt*c[n][i]%mod)%mod;
	}
	printf("%d\n",ans);
	return 0;	
}
```


---

## 作者：George1123 (赞：19)

到蒟蒻的博客小窝里教教蒟蒻容斥 $\to$ [$\tt George1123$](https://www.cnblogs.com/Wendigo/p/13373984.html)

---
## 题面

> [JSOI2011 分特产](https://www.luogu.com.cn/problem/P5505)

> 有 $n$ 个不同的盒子和 $m$ 种不同的球，第 $i$ 种球有 $a_i$ 个，用光所有球，求使每个盒子不空的方案数。

> 数据范围：$1\le n,m,a_i\le 1000$。

---
## 蒟蒻语

今天做了几道黑题，蒟蒻的做法非常蒟蒻，看上去很厉害其实很废，巨佬的做法是容斥，秒杀一切。

所以蒟蒻拿这道水题讲讲自己的做法。希望巨佬教蒟蒻容斥 $\tt /kel$。

---
## 蒟蒻解

看到盒子不能空，先二项式反演。

$f(i)$ 表示 $i$ 个盒子空，剩下非空的方案数；$g(i)$ 表示 $i$ 个盒子空，剩下随意。

$$g(i)=\sum_{x=i}^n {x\choose i}f(x)\Longleftrightarrow f(i)=\sum_{x=i}^n{x\choose i}(-1)^{x-i}g(x)$$

然后考虑 $g(i)$ 怎么求：因为 $n-i$ 个可以空可以不空，所以可以构造生成函数：

$$\left(\prod_{j=1}^m(1+x_j+x_j^2+x_j^3+\cdots)\right)^{n-i}$$

$g(i)$ 就等于 $\prod_{j=1}^mx_j^{a_j}$ 的项数。

所以可以每个 $x_j$ 分开来考虑，用隔板法，得出：

$$g(i)={n\choose i}\prod_{j=1}^m{a_j+n-i-1\choose n-i-1}$$

然后答案就是（当 $x=n$ 时 $n-x-1=-1$，所以结果为 $0$，不需要枚举）：

$$f(0)=\sum_{x=0}^{n-1}(-1)^{x}{n\choose x}\prod_{j=1}^m{a_j+n-x-1\choose n-x-1}$$

---
## 代码

跟巨佬的代码是一样的，只不过推导过程不同。

```cpp
#include <bits/stdc++.h>
using namespace std;

//Start
typedef long long ll;
typedef double db;
#define mp(a,b) make_pair(a,b)
#define x first
#define y second
#define be(a) a.begin()
#define en(a) a.end()
#define sz(a) int((a).size())
#define pb(a) push_back(a)
const int inf=0x3f3f3f3f;
const ll INF=0x3f3f3f3f3f3f3f3f;

//Data
const int N=1e3,T=N<<1;
const int mod=1e9+7;
int n,m,a[N],c[T+1][T+1];
int g(int x){
    int res=c[n][x];
    for(int i=0;i<m;i++)
        res=(ll)res*c[a[i]+n-x-1][n-x-1]%mod;
    return res;
}

//Main
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    cin>>n>>m;
    for(int i=0;i<=T;i++){
        c[i][0]=c[i][i]=1;
        for(int j=1;j<=i-1;j++)
            c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;
    }
    for(int i=0;i<m;i++) cin>>a[i];
    int ans=0;
    for(int i=0;i<n;i++){
        if(i&1) (ans+=mod-g(i))%=mod;
        else (ans+=g(i))%=mod;
    }
    cout<<ans<<'\n';
    return 0;
}
```
---
**祝大家学习愉快！**

---

## 作者：ycyaw (赞：17)

考虑容斥，$ans=(>=0$个人没分到的方案$)-(>=1$个人没分到的方案$)+(>=2$个人没分到的方案$)$...

考虑计算$>=i$个人没分到的方案，每个特产分开算，最后乘起来。根据插板法，第$k$个特产的方案为$C(a[k]+n-i-1,n-i-1)$。然后还要乘上强制哪$i$个人没分到的方案，即$C(n,i)$。

设$>=i$个人没分到的方案为$f[i]$，则$ans=\sum\limits_{i=0}^{n-1}(-1)^i\times f[i]$。

$Code\ Below:$
```cpp
#include<bits/stdc++.h>
#define ts cout<<"ok"<<endl
#define int long long
#define hh puts("")
#define pc putchar
#define mo 1000000007
//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
//char buf[1<<21],*p1=buf,*p2=buf;
using namespace std;
int n,m,a[1005],C[2005][2005],ans;
inline int read(){
    int ret=0,ff=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-') ff=-ff;ch=getchar();}
    while(isdigit(ch)){ret=(ret<<3)+(ret<<1)+ch-'0';ch=getchar();}
    return ret*ff;
}
void write(int x){
    if(x<0){x=-x;putchar('-');}
    if(x>9) write(x/10);
    putchar(x%10+48);
}
int work(int x){
    x=n-x;
    int res=1;
    for(int i=1;i<=m;i++) res=res*C[a[i]+x-1][x-1]%mo;
    return res*C[n][n-x]%mo;    
}
signed main(){
    n=read(),m=read();
    for(int i=1;i<=m;i++) a[i]=read();
    for(int i=0;i<=2000;i++) C[i][0]=1;
    for(int i=1;i<=2000;i++)
        for(int j=1;j<=i;j++)
            C[i][j]=(C[i-1][j]+C[i-1][j-1])%mo;
    for(int i=0;i<=n-1;i++){//>=i个人没分到的方案 
        if(i&1) ans=(ans-work(i)+mo)%mo;
        else ans=(ans+work(i))%mo;
    }
    write(ans);
    return 0;
}
```


---

## 作者：Constant (赞：10)

# 题意简述：

有 $n$ 个有标号的抽屉和 $m$ 种有标号的水果，每种水果有 $a[i]$ 个，求每个抽屉至少放一种水果的总方案数。

# Solution

先看一个简单的问题，有 $m$ 个相同的小球，放到 $n$ 个相同的盒子里，盒子不为空，问有多少种放置方案？

采用隔板法，$m$ 个小球排成一排，在 $m - 1$ 个空隙中插入 $n - 1$ 块隔板，总共形成 $n$ 个部分，每个部分就是一个盒子，总共有 $C_{\ m-1}^{\ n-1}$ 种方案。

若盒子可以为空，问有多少种放置方案？

可以看做有 $m + n$ 个元素，在 $m + n - 1$ 个空隙里插入 $n - 1$ 块隔板，总共形成 $n$ 个部分，每个部分包含若干个元素，如果某部分只包含一个元素，则这个元素就看作盒子，且没有得到小球；若某部分包含 $k$ 个元素，则这部分就看作 $k - 1$ 个小球放入 $1$ 个盒子中。总共有 $C_{\ m+n-1}^{\ n-1}$ 种方案。

对于本题，考虑一种特产一种特产的分，设第 $j$ 种特产，有 $a [ j ]$ 个，若有 $i$ 个人没有得到特产，则剩下的 $n − i$ 个人分，且也可能某些人存在分不到的情况，方案为 $C_{\ a[j]+n-i-1}^{\ n-i-1}$ ，同时，每个人编号不同，还需要选择 $i$ 个人出来，这 $i$ 个人肯定不能分到特产，所以至少 $i$ 个人没有分到特产的方案数为： $C_{a[j]+n-i-1}^{n-i-1}$  ，其中 $1\le j\le m$  ，表示的是一种特产一种特产的分，而分步用乘法。

设 $f [ i ]$ 表示至少 $i$ 个人没有分到特产的方案数。

我们有： $f[i]=C_n^i\prod_{j=1}^m C_{\ a[j]+n-i-1}^{\ n-i-1}$  。

设有 $3$ 个人分别是  $A , B , C $  ， $f [ 1 ]$ 包含的情况有，     $A(B,C),B(A,C),C(A,B)$ ，括号外的表示选出来肯定分不到的人，括号里的表示可能分不到的人。可以发现，对于两人分不到的情况减了两次，因此需要加上 $f [ 2 ] $ 包含的情况，这样就得到刚好 $1$ 个人分不到、刚好 $2$ 个人分不到的方案数，为 $f[1]-f[2]$ 。

根据容斥原理，那么刚好 $1$ 个人、$2$ 个人、…  $n-1$ 个人的分不到的总的方案数为：

$f[1]-f[2]+f[3]-f[4]....f[n-1]$。

用 $f [ 0 ]$ 表示至少 $0$ 个人分不到的方案数，减去上面的方案数，就是刚好 $0$  个人分不到的方案数，即最后的答案：

$ans=\sum_{i=0}^{n-1}(-1)^i\times f[i]$。

时间复杂度为 $O(N^2)$ 。

下面是我的代码

```cpp
#include<bits/stdc++.h>
#define M 1000000007
#define ll long long
using namespace std;
ll ans,C[3005][3005],n,m,a[100005],f[100005];
ll T(ll x)
{
	if(x%2==1) return -1;
	else return 1;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(ll i=1;i<=m;i++) scanf("%d",&a[i]);
	C[1][1]=1;
	for(ll i=0;i<=2000;i++)
	C[i][i]=C[i][0]=1;
	for(ll i=2;i<=2000;i++)
	{
		for(ll j=1;j<=i;j++)
		{
			C[i][j]=(C[i-1][j-1]+C[i-1][j])%M;	
		//	cout<<C[i][j]<<" ";	
		}
	//	cout<<endl;
	}
	for(ll i=0;i<=n-1;i++)
	{
		ll s=1;
		for(ll j=1;j<=m;j++)
		{
			s=((s%M)*(C[n-i+a[j]-1][n-i-1]%M))%M;
		}
		if(i%2)ans=(ans-s*C[n][i]%M+M)%M;
		else ans=(ans+s*C[n][i]%M)%M;
	}
	cout<<ans%M;
	return 0;
} 
```


---

## 作者：hehelego (赞：6)

扔子集反演.
$$g(S)=\sum_{T\subseteq S}f(T)$$
$$f(S)=\sum_{T\subseteq S}(-1)^{|S|-|T|}g(T)$$

---

首先人是有序的,然后至少一个特产的约束太烦了,如果没有这个约束的话...  

可以分别考虑特产,比如特产$k$有$a_k$个,分给$n$个人,即为$\sum_{i=1}^nx_i=a_k(x_i\geq 0)$的解计数.这和某经典模型很类似,我们令$y_i=x_i+1(y_i\gt 0)$,带入得到$\sum_{i=1}^n y_i=a_k+n(y\gt 0)$.这是经典问题,插板法解决它,$a_k+n$个球分为$n$个非空组,考虑从除了首尾外,两球之间的空隙(共$n+a_k-1$个),选出$n-1$个即划分为一组,发现组合意义和问题的解是意义对应的,所以这里答案是$\binom{a_k+n-1}{n-1}$.  

回到问题,我们设$g(S)$为拿到特产的必要条件为$x\in S$的分配方案计数,其中$S\subseteq \{1,2,3\dots n\}$.根据之前的分析,$g(S)=\prod_{i=1}^m \binom{|S|+a_i-1}{|S|-1}$,特别的$g(\phi)=0$(这是符合实际意义和式子统一的唯一可能取值.)  
再设$f(S)$为拿到特产等价于$x\in S$的分配方案数量,可以发现,$g(S)=\sum_{T\subseteq S}f(T)$,利用开头的式子可以求出$f$了.  

---

根据上文定义,答案即为
$$
f(\{1,2\dots n\})=\sum_{S}(-1)^{n-|S|}g(S)
$$
于是得到优秀的$O(m2^n)$做法(大雾).  

我们发现,不论是实际意义还是计算式,$g(S)$实际上是个关于$|S|$的函数,记为$G(|S|)$,我们不再枚举$S$而是枚举$|S|$,这样的子集有$\binom{n}{|S|}$个.
$ans=\sum_{i=0}^n\binom{n}{i}(-1)^{n-i}G(i)$.

得到了$O(V^2+nm)$的优秀做法,其中$V$是$n+max(a_i)$,对于本题是2000,这部分是用来算组合数的.  



----

扔程序跑路.
```cpp
#include <bits/stdc++.h>
int read(){
	int x=0;char c;
	do{c=getchar();}while(!isdigit(c));
	do{x=x*10+c-'0';c=getchar();}while(isdigit(c));
	return x;
}
typedef long long Int;
const Int mod=Int(1e9)+7LL;
// 我也不知道为什么有这东西...
// 可能是用来算(-1)^(n-i)的吧...
// 反正一个logn的因子不至于卡掉对吧qwq.
Int qpow(Int a,Int p){
	Int r=1; while(p){
		if(p&1) r=r*a%mod;
		a=a*a%mod; p>>=1;
	} return r;
}
const int N=2000+10;
int n,m,a[N],binom[N][N];
int main(){
	n=read(); m=read();
	for(int i=0;i<m;i++) a[i]=read();

	binom[0][0]=1; for(int i=1;i<N;i++){
		binom[i][0]=binom[i][i]=1;
		for(int j=1;j<i;j++)
			binom[i][j]=(binom[i-1][j]+binom[i-1][j-1])%mod;
	}
	Int ans=0; for(int i=1;i<=n;i++){
		Int tmp=1; //tmp->G(i)
		for(int j=0;j<m;j++) tmp=tmp*binom[i+a[j]-1][i-1]%mod;
		ans=(ans+tmp*qpow(mod-1,n-i)%mod*binom[n][i]%mod)%mod;
	} std::cout<<ans<<std::endl;
	return 0;
}

```



~~后排推荐已故社团minori的作品Eden*~~


---

## 作者：caidzh (赞：4)

~~真的是二项式反演套路题~~

实际上是一个非常简单的容斥啦

## 题目大意：

有$n$个人和$m$种物品，第$i$种物品有$a_i$个，同种物品之间没有区别。现在要将这些物品分给这些人，使得每个人至少分到一个物品，求方案数模$10^9+7$。其中，$n\le1000,m\le1000,a_i\le1000$

## $Solution$

每个人至少分到一个物品实在不是一个好条件，为了贯彻二项式反演的原则，我们把这个条件转化成选择$0$个人不被分到物品

然后我们搞一个“钦定”类条件出来：定义$f(i)$为钦定$i$个人不被分到物品，显然：

$$f(k)=\sum_{i=k}^n\dbinom{i}{k}g(i)$$

考虑求$f$，显然如果我们钦定了$k$个不被分配，那么接下来就是对于每个物品做一个插板法求方案数（把$a_i$个物品分给$n-k$个人，每个人都要被分到），这个非常简单

所以我们表示一下$f(k)=\dbinom{n}{k}\prod_{i=1}^m\dbinom{a_i+n-k-1}{n-k-1}$

反演后求出$g$，这题就做完了
```cpp
#include<bits/stdc++.h>
using namespace std;
int inline read(){
    int num=0,neg=1;char c=getchar();
    while(!isdigit(c)){if(c=='-')neg=-1;c=getchar();}
    while(isdigit(c)){num=(num<<3)+(num<<1)+c-'0';c=getchar();}
    return num*neg;
}
const int maxn=1010,mod=1e9+7;
int n,m,a[maxn],fac[maxn<<2],inv[maxn<<2],f[maxn],ans;
int Pow(int x,int y){
	int ans=1;while(y){if(y&1)ans=1ll*ans*x%mod;x=1ll*x*x%mod;y>>=1;}return ans;
}int C(int x,int y){return 1ll*fac[x]*inv[y]%mod*inv[x-y]%mod;}
int main()
{
	n=read();m=read();fac[0]=1;inv[0]=1;
	for(int i=1;i<=m;i++)a[i]=read();
	for(int i=1;i<=maxn*4;i++)fac[i]=1ll*fac[i-1]*i%mod;
	for(int i=1;i<=maxn*4;i++)inv[i]=Pow(fac[i],mod-2);
	for(int i=0;i<=n;i++)f[i]=C(n,i);
	for(int i=0;i<=n;i++)
		for(int j=1;j<=m;j++)
			f[i]=1ll*f[i]*C(a[j]+n-i-1,a[j])%mod;
	for(int i=0;i<=n;i++)
		if(i&1)ans=((ans-f[i])%mod+mod)%mod;
		else ans=(ans+f[i])%mod;
	printf("%d",ans);return 0;
}
```


---

## 作者：huangxuhan (赞：4)

 考虑$f(k)$为$k$个人一个特产都没有分到的方案数，根据容斥原理答案为

------------
$\sum_{k=0}^{n-1}{(-1)^{k}\binom{n}{k}}f(k)$

------------
那现在考虑$f(k)$如何求：此时可以当成另外$x$个人分所有特产，此时每个人分到的可以取$0$ (因为容斥)，所以

------------
$f(k)=\prod_{i=1}^{m}{\binom{a_{i}+(n-k)-1}{(n-k)-1}}$

------------
  
于是问题得到解决  
求组合数的方法:  

- 费马小定理$a^{-1}\equiv a^{p-2}\pmod{p}$，其中$p$为质数
- $\frac{1}{i! }\equiv \frac{i+1}{(i+1)!}\pmod{p}$所以可以线性预处理求出$i!$与$n!$的逆元，于是可以计算组合数

------------
 

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#define ll long long
using namespace std;
ll fac[10010],inv[10010],mod=1e9+7;
ll power(ll a,ll b)
{
	ll ans=1%mod;a%=mod;
	for (;b;b>>=1)
	{
		if (b&1) ans=ans*a%mod;
		a=a*a%mod;
	}
	return ans;
}
ll a[10010],n,m;
ll C(ll n,ll m)
{
	return (fac[n]*inv[n-m]%mod)*inv[m]%mod;
}
inline ll read()
{
    ll x=0,f=1;char ch;
	do{ch=getchar();if(ch=='-')f=-1;}while(ch>'9'||ch<'0');
	do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');	
	return f*x;
}
ll ans=0,f[10010];
int main()
{
	fac[0]=1;
    for (int i=1;i<=10000;i++) fac[i]=fac[i-1]*i%mod;
    inv[10000]=power(fac[10000],mod-2);
    for (int i=9999;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;
    inv[0]=1;
    n=read();m=read();
	for (int i=1;i<=m;i++)a[i]=read();
	for (int i=0,k=1;i<n;i++,k=-k)
    {
    	f[i]=1;
    	for (int j=1;j<=m;j++) f[i]=f[i]*C(a[j]+n-i-1,n-i-1)%mod;
		ans=(ans+k*C(n,i)*f[i]+mod)%mod;
    }
    cout<<(ans+mod)%mod<<endl;       
}
```


---

## 作者：Karry5307 (赞：4)

### 题意

有$n$种特产，第$i$种特产有$a_i$个。要把这些特产分给$m$个人，使得每个人都至少分得一个特产，求分法种数。

$\texttt{Data Range:}n,m,a_i\leq10^3$

### 题解

好久没有见过如此小清新的容斥题了qwq

先考虑没有每个人至少一个的限制，那么答案就是可重组合，也就是

$$f(n)=\prod\limits_{i=1}^{m}C_{a_i+n-1}^{n-1}$$

然后既然有了这个限制不太好处理的话。那么容斥做肯定可以。

考虑至少有$t$个同学没有的情况，那么钦定前$t$个同学没有特产，后面的有不有都无所谓，因为这里求的是**至少**$t$个同学没有，所以答案为$f(n-t)$
。

于是可以容斥出答案，就是这个：

$$\sum\limits_{i=0}^n(-1)^if(n-i)$$

### 代码

跑的还是挺快的啊qwq

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef int ll;
typedef long long int li;
const ll MAXN=5e3+51,MOD=1e9+7;
ll cnt,ccnt,maxn,res,coeff;
ll fact[MAXN],finv[MAXN],num[MAXN];
inline ll read()
{
    register ll num=0,neg=1;
    register char ch=getchar();
    while(!isdigit(ch)&&ch!='-')
    {
        ch=getchar();
    }
    if(ch=='-')
    {
        neg=-1;
        ch=getchar();
    }
    while(isdigit(ch))
    {
        num=(num<<3)+(num<<1)+(ch-'0');
        ch=getchar();
    }
    return num*neg;
} 
inline ll qpow(ll base,ll exponent)
{
	ll res=1;
	while(exponent)
	{
		if(exponent&1)
		{
			res=(li)res*base%MOD; 
		}
		base=(li)base*base%MOD,exponent>>=1;
	}
	return res;
} 
inline void setup(ll cnt)
{
	fact[0]=fact[1]=finv[0]=1;
	for(register int i=2;i<=cnt;i++)
	{
		fact[i]=(li)fact[i-1]*i%MOD;
	}
	finv[cnt]=qpow(fact[cnt],MOD-2);
	for(register int i=cnt-1;i;i--)
	{
		finv[i]=(li)finv[i+1]*(i+1)%MOD;
	}
}
inline ll comb(ll m,ll n)
{
	return (li)fact[m]*finv[n]%MOD*finv[m-n]%MOD;
}
int main()
{
	cnt=read(),ccnt=read();
	for(register int i=0;i<ccnt;i++)
	{
		num[i]=read(),maxn=max(maxn,num[i]); 
	}
	setup(cnt+maxn);
	for(register int i=0;i<=cnt;i++)
	{
		coeff=1;
		for(register int j=0;j<ccnt;j++)
		{
			coeff=(li)coeff*comb(num[j]+cnt-i-1,cnt-i-1)%MOD;
		}
		coeff=(li)coeff*comb(cnt,i)%MOD;
		res=(res+((i&1)?MOD-coeff:coeff))%MOD;
	}
	printf("%d",res);
}
```

---

## 作者：LCGUO (赞：3)

这题应该是容斥原理。

由于考虑每个物品分给谁不容易，所以我们可以倒着考虑。

由于对每个人分到的特产是什么没有要求，我们就考虑至少 $x$ 个人没收到特产的方案。

将每个特产分开算，最后求他们的累乘就可以了。

---

对于第 $i$ 个特产，它的方案数就是将 $a_i$ 个特产分给 $n-x$ 个人。根据插板法，它的方案数就是 $C^{n-x-1}_{n-x+a_i-1}$。

又因为每个人是不一样的，所以在分配时，还要考虑选择那 $x$ 个人的方案，也就是 $C^x_n$，所以方案数就是 $C^{n-x-1}_{n-x+a_i-1} \times C^x_n$。

最后用容斥减掉不合法的情况就ok了。

---

代码如下，$p_i$ 是容斥系数：

```cpp
#include<bits/stdc++.h>
#define rint register long long
#define int long long
using namespace std;
inline int read(){
    int s=0,f=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=0;c=getchar();}
    while(c>='0'&&c<='9')s=(s<<1)+(s<<3)+c-48,c=getchar();
    return f?s:-s;
}
const int Mod=1e9+7;
int n,m,a[1010],p[4010],ans;
int fac[4010],inv[4010];
int power(int a,int b){
    int res=1;
    while(b){
        if(b&1) res=1ll*res*a%Mod;
        a=1ll*a*a%Mod; b>>=1;
    }
    return res%Mod;
}
int C(int n,int m){
    if(m>n) return 0;
    if(n==0||m==0) return 1;
    return 1ll*fac[n]*inv[n-m]%Mod*inv[m]%Mod;
}
signed main(){
    fac[1]=1; p[0]=1; p[1]=-1;
    for(rint i=2;i<=4000;++i){
        fac[i]=1ll*fac[i-1]*i%Mod;
        p[i]=p[i-1]*(-1);
    }
    inv[4000]=power(fac[4000],Mod-2);
    for(rint i=4000;i>1;--i) inv[i-1]=1ll*inv[i]*i%Mod;
    n=read(); m=read();
    for(rint i=1;i<=m;++i) a[i]=read();
    for(rint k=0;k<=n;++k){
        int cnt=1;
        for(rint i=1;i<=m;++i)
            cnt=1ll*cnt*C(a[i]+n-k-1,n-k-1)%Mod;
        ans=1ll*(ans+p[k]*C(n,k)%Mod*cnt%Mod+Mod)%Mod;
    }
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：pomelo_nene (赞：2)

题意转化：给定 $n$ 个有标号的盒子（同学）和 $m$ 种共 $\displaystyle \sum_{i=1}^m a_i$ 个无标号的小球（特产），要求每个盒子不为空。

考虑到直接计算不为空的合法的太麻烦了，于是先计算所有合法方案，再减去有空缺的答案，就是我们问题的答案了。

### 处理前半部分

首先引入十二重计数法。盒子和小球均为有标号，并且要求每个盒子不为空。对于每一个 $a_i$，每一问都是 [十二重计数法](https://www.luogu.com.cn/problem/P5824) 的第 $\text{IX}$ 问。对于 $a_i$ 来说，它的贡献是 $C_{n+a_i-1}^{n-1}$。于是前半部分的答案就是：

$$\displaystyle \prod_{i=1}^m C_{n+a_i-1}^{n-1}=\sum_{i=0}^0 (-1)^i C_{n}^i \prod_{j=1}^m C_{n+a_j-i-1}^{n-i-1}$$

### 处理后半部分

如果盒子有空，如何处理？不能很好的处理的原因之一就是我们无法确定有多少个盒子是空的。于是枚举有多少个盒子为空。假设现在有 $p$ 个盒子**是**空的，原问题就变成了在 $n-p$ 个**有标号**的盒子中，放入共 $m$ 种共 $\displaystyle \sum_{i=1}^m a_i$ 个无标号的小球。又分别考虑每一个 $a_i$，其实这又是前半部分的问题。又因为有 $p$ 个**有标号**盒子是空的，这样的情况有 $C_{n}^i$ 种，所以对于 $p$ 个盒子是空的的情况还要乘上 $C_n^i$。注意这部分的答案需要容斥，有盒子是空的的情况一共包含只有 $1$ 个盒子是空的，减去 $2$ 个盒子是空的，再加上 $3$ 个盒子是空的，以此类推。这里需要**加上**的贡献即为：

$$\displaystyle \sum_{i=1}^n (-1)^i C_n^i \prod_{j=1}^m C_{n+a_j-i-1}^{n-i-1}$$

---

前半部分已经写成和后半部分的式子形状一致了，可以直接合并。答案即为：

$$\displaystyle \sum_{i=0}^n (-1)^i C_n^i \prod_{j=1}^m C_{n+a_j-i-1}^{n-i-1}$$

可以预处理组合数，$O(n^2)$ 解决。（假设 $n,m$ 同阶）

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const LL MOD=1000000007;
LL C[2005][2005],n,m,a[1005];
int main(){
	C[0][0]=1;
	for(LL i=1;i<=2000;++i)	for(LL j=0;j<=i;++j)	C[i][j]=(C[i-1][j]+((j==0)?0:C[i-1][j-1]))%MOD;
	scanf("%lld %lld",&n,&m);
	for(LL i=1;i<=m;++i)	scanf("%lld",&a[i]);
	LL k=1,ans=0;
	for(LL i=0;i<n;++i)
	{
		LL p=C[n][i];
		for(LL j=1;j<=m;++j)	p*=C[n+a[j]-i-1][n-i-1],p%=MOD;
		ans+=k*p;
		ans%=MOD;
		k=-k;
	}
	printf("%lld",(ans%MOD+MOD)%MOD);
	return 0;
}
```

---

## 作者：foreverlasting (赞：1)

[题面](https://www.lydsy.com/JudgeOnline/problem.php?id=4710)

正式开始学习容斥！

这道题可以当做容斥的模板题了吧！记$f[i]$表示至多有$i$个人获得了特产的方案数，这可以通过隔板法直接得出。然后我们发现因为是至多$i$个人，而我们要求的恰好$n$个人，所以这里可以通过容斥原理求出刚好$n$个人有特产的方案数。想一想，我们加上了$f[n]$个方案数，显然这里有一批方案是小于等于$n-1$个人选择的。那么我们就减去$C(n,n-1)*f[n-1]$的方案数，同理，这里多减去了小于等于$n-2$个人选择的。因此，不断加减下去，就能得出最终的答案。

code:
```
//2018.9.6 by ljz
#include<bits/stdc++.h>
using namespace std;
#define res register int
#define LL long long
#define inf 0x3f3f3f3f
#define eps 1e-15
inline int read(){
    res s=0;
    bool w=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=1;ch=getchar();}
    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();
    return w?-s:s;
}
inline void _swap(res &x,res &y){
    x^=y^=x^=y;
}
inline int _abs(const res &x){
    return x>0?x:-x;
}
inline int _max(const res &x,const res &y){
    return x>y?x:y;
}
inline int _min(const res &x,const res &y){
    return x<y?x:y;
}
const int N=1e4+10;
const int kcz=1e9+7;
namespace MAIN{
    int n,m;
    int inv[N],fac[N];
    inline void pre(){
        inv[0]=inv[1]=fac[0]=fac[1]=1;
        for(res i=2;i<=N-10;i++)fac[i]=(LL)fac[i-1]*i%kcz,inv[i]=(LL)(kcz-kcz/i)*inv[kcz%i]%kcz;
        for(res i=2;i<=N-10;i++)inv[i]=(LL)inv[i-1]*inv[i]%kcz;
    }
    inline int C(res x,res y){
        return (LL)fac[x]*inv[y]%kcz*inv[x-y]%kcz;
    }
    int f[N];
    int ans;
    inline void add(res &x,const res &y){
        x+=y;
        x>kcz?x=x%kcz:1;
        x<0?x=(x%kcz+kcz)%kcz:1;
    }
    inline void MAIN(){
        pre();
        n=read(),m=read();
        for(res i=1;i<=n;i++)f[i]=1;
        for(res i=1;i<=m;i++){
            res x=read();
            for(res j=1;j<=n;j++)
                f[j]=(LL)f[j]*C(j+x-1,j-1)%kcz;
        }
        for(res i=n,cur=0;i;i--,cur^=1)
            if(cur)add(ans,kcz-(LL)f[i]*C(n,i)%kcz);
            else add(ans,(LL)f[i]*C(n,i)%kcz);
        printf("%d\n",(ans%kcz+kcz)%kcz);
    }
}
int main(){
    MAIN::MAIN();
    return 0;
}
```

---


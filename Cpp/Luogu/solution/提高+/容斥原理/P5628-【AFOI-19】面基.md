# 【AFOI-19】面基

## 题目背景

一伙人吃完午饭准备看考场，IY ，SY，QM，MY 和 UU 早就约好在当天下午面基。然后众人一致同意把安排行程的锅甩到了 IY 身上。

（IY：？？？？为什么是我）

（QM：给你吃糖）

（IY：好的没问题，包在我身上。）

## 题目描述

IY 所在的城市有 $n$ 个路口，$n-1$ 条道路把各个路口连接起来，道路是双向的。换言之， IY 所在的城市构成了一棵树。两个不相同路口的距离定义为其简单路径上的道路条数，一个路口与自己的距离为$0$。

我们再定义一条道路的重要度。若一条道路无法使用，会导致有 $t$ 对路口无法相互抵达，则$t$就是该道路的重要度。如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/ap2etu10.png)

(3,4)之间的道路的重要度就为$9$。因为(1,4)(2,4)(3,4)(1,5)(2,5)(3,5)(1,6)(2,6)(3,6)要相互抵达都要经过这条边。

IY 得到了一个很不好的消息，有一个路口正在施工（但是 IY 不知道施工的位置）。施工的范围影响到了距施工点距离为 $k$ 的地方，距离施工点距离小于等于 $k$ 的路口已经全部关闭了。这使得一行人不能经过受影响的路口和与这些路口直接相连的道路。

IY 不得不考虑到最坏的情况，由于他不知道施工的位置，所以他想知道，施工所影响道路的重要度的总和最大是多少。

## 说明/提示

- **样例解释**

样例$1$：就是题面中的图例，若施工位置在 $3$ 或 $4$ 号路口，则会影响的道路重要度总和为$19$。找不出比 $19$ 更大的值。

样例$2$：满足成链的特殊性质。

- **数据范围**

对于前 $20\%$测试点，$n \le 100,0 \le k \le 7$

对于前 $40\%$ 的数据 ：保证数据随机

特殊地：第三个测试点仅有$k==0$

对于 $100\%$的数据：$n \le 30000,0 \le k \le 200$

特殊地：第十个测试点由树退化成了一条链

## 样例 #1

### 输入

```
6 0
1 3
3 2
5 4
3 4
4 6```

### 输出

```
19```

## 样例 #2

### 输入

```
5 1
1 2
2 3
3 4
4 5```

### 输出

```
20```

# 题解

## 作者：素质玩家孙1超 (赞：18)

这道题目是那天打比赛时想~~骗~~更多的分但想不到正解

眼看着就要吃晚饭了，马上飞去小店买面包吃回来时想出的乱搞做法

### 大致题意

给你一棵树，每条边有一个重要度：若一条道路无法使用，会导致有 t对路口无法相互抵达，则t就是该道路的重要度。

施工会使以某一个点的周围与之距离不超过k的点被删，从而与之连的边被删，求被删的边的重要度和的最大值

------------

正解是树上容斥~~然而我这么菜怎么会想到正解~~

 而我介绍的方法是玄学乱搞

### 思路：

对于处理边权（重要度），我们dfs搜一遍，边权就是以该边左端点为根的子树大小乘上剩下端点数

具体处理方法(size[i]表示以i为根的子树大小,in[k]表示第k条边的重要度)

```cpp
inline void dfs(int x,int father)
{
	size[x]=1;
	for(int k=First[x];k;k=Next[k])
	{
		if(to[k]==father) continue;
		dfs(to[k],x);
		size[x]+=size[to[k]];
		in[k]=size[to[k]]*(n-size[to[k]]);
	}
}
```

那么处理好了边权，我们这么找出施工中的那个点呢？

相信大家都能想到朴素算法，对于每一个点搜索并记录，

但是如果是链的话，时间复杂度k * n，而菊花图则会被卡到n * n，

显然容易超时,这时我们怎么办呢？

### 下面开始~~胡说~~讲解重点

(注:这种想法十分不严谨，但不失为骗分好方法)

我们需要考虑选择什么样的点作为起点更有可能使得结果最大

这时候想到重要度的定义，如果一条边重要度大的话，那么被这条边分开的两个连通块的点数的乘积就会多

我们可以~~不严谨~~地认为，在重要度大的边附近的边重要度大的概率大

相反，在比较边界的地方，重要度小的边附近的边重要的小的概率大

那么，我们就考虑记录每个点连接的边的重要度之和，并按此排序

先从我们认为最优的开始搜索

在搜索得快时间超限的时候把他打断，输出此时的答案即可满分

（我自己比赛时在dfs最里层加了一个计数的变量,当他大于10000000时打断~~最后还跑得挺快~~）

上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int Maxn=3e4+5;
#define int long long 
int ans,number;
inline int R()
{
	char c;int sign=1,res=0;
	while((c=getchar())>'9'||c<'0') if(c=='-') sign=-1;
	res+=c-'0';
	while((c=getchar())>='0'&&c<='9') res=res*10+c-'0';
	return res*sign;
}//读入优化 
int First[Maxn],Next[Maxn*2],to[Maxn*2],cnt,n,K;
int in[Maxn*2],size[Maxn];
struct Point
{
	int we,id;
}a[Maxn];//记录每个点连结的边的重要度和其编号 
bool cmp(Point x,Point y)
{
	return x.we>y.we;
}
inline void add(int z,int y)
{
	Next[++cnt]=First[z];
	First[z]=cnt;
	to[cnt]=y;//加边 
}
inline void dfs(int x,int father)//第一边预处理的dfs 
{
	size[x]=1;
	for(int k=First[x];k;k=Next[k])
	{
		if(to[k]==father) continue;
		dfs(to[k],x);
		size[x]+=size[to[k]];//记录子树大小 
		in[k]=size[to[k]]*(n-size[to[k]]);//计算边的重要度 
		a[x].we+=in[k];//统计点的权值（连出去的边的重要度和） 
		a[to[k]].we+=in[k];
	}
}
int now;
inline void dfs2(int x,int father,int num)
{//x为该节点，father为其父亲,num为其到最初点的距离 
	if(num>K) return;
	number++;//计数 
	for(int k=First[x];k;k=Next[k])
	{
		if(to[k]==father) continue;
		now+=in[k];//统计重要度 
		dfs2(to[k],x,num+1);
	}
	return;
}
signed main()
{
	n=R();K=R();int x,y;
	for(int i=1;i<=n;i++) a[i].id=i;
	for(int i=1;i<n;i++)
	{
		x=R();y=R();
		add(x,y);add(y,x);
	}//加边 
	dfs(1,0);//预处理 
	for(int i=1;i<=cnt;i+=2) 
	in[i]=in[i+1]=max(in[i],in[i+1]);
	//第2i-1条与第2i为同一条边，只是方向不同 
	sort(a+1,a+1+n,cmp);//按权值排序 
	for(int i=1;i<=n;i++)
	{
		now=0;
		if(number>10000000) break;//及时退出，防止tle 
		dfs2(a[i].id,0,0);//记录答案 
		if(now>ans) ans=now;//更新答案 
	}
	printf("%lld\n",ans);
}
```

觉得好别忘点个赞再走qwq

---

## 作者：Froggy (赞：10)

### 一道dp好题

~~旁边有位神仙说这道题是割点,我..吐血~~(明明是一颗树嘛!)

思路:

$dp_{u,j}$表示距离节点$u$小于$j$的边权之和

随便选个根,先算出边权(就是边两侧节点数的乘积,即$size_{u} \times (n-size_{u})$ 

(size为子树大小)

再两遍dfs

第一遍统计子树,第二遍统计父亲

统计子树好弄

直接: $dp_{u,j}= \sum\limits_{v \in son}dp_{v,j-1}+val_{u->v} \ \ \ $ ($val$为边权)

第二遍统计父亲

对于每个节点,先更新自己再更新儿子

很显然,$dp_{u,j}$一定是要先加上$dp_{fa,j-1}+val_{fa->u}$,但由于$dp_{fa,j-1}$已经算过一边以$u$为根的子树,所以还要减掉$dp_{u,j-2}$ (容斥一下)

所以:

$dp_{u,j} =dp_{u,j}+dp_{fa,j-1}+val_{fa->u}-dp_{u,j-2}$

**注意:** $j$要倒序循环,$j=1$时要特判

最后取个max就是答案了

*code:*

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
typedef long long ll;
#define N 30030
inline int read(){
    int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<3)+(x<<1)+c-'0';
        c=getchar();
    }
    return x*f;
}
int n,k,cnt;
int head[N];
ll siz[N],ans,dp[N][202];
struct Edge{
	int to,nxt;
	ll val;
}edge[N<<1];
void add(int a,int b){
	cnt++;
	edge[cnt].to=b;
	edge[cnt].val=0;
	edge[cnt].nxt=head[a];
	head[a]=cnt;
}
void init(int u,int fa){
	siz[u]=1;
	for(int i=head[u];i;i=edge[i].nxt){
		int v=edge[i].to;
		if(v==fa)continue;
		init(v,u);
		edge[i].val=edge[i^1].val=siz[v]*(n-siz[v]);
		siz[u]+=siz[v];
	}
}
void dfs1(int u,int fa){
	dp[u][0]=0;
	for(int i=head[u];i;i=edge[i].nxt){
		int v=edge[i].to;
		if(v==fa)continue;
		dfs1(v,u);
		for(int j=1;j<=k+1;j++){
			dp[u][j]+=edge[i].val+dp[v][j-1];
		}
	}
}
void dfs2(int u,int fa,ll Val){
	if(fa!=0){
		for(int j=k+1;j>=2;j--){
			dp[u][j]+=dp[fa][j-1];
			dp[u][j]-=dp[u][j-2]; 
		}
		dp[u][1]+=Val;//细节特判
	}
	for(int i=head[u];i;i=edge[i].nxt){
		int v=edge[i].to;
		if(v==fa)continue;
		dfs2(v,u,edge[i].val);
	}
}
int main(){
	n=read(),k=read();cnt=1;
	for(int i=1;i<=n-1;i++){
		int u=read(),v=read();
		add(u,v),add(v,u);
	}
	init(1,0);//算边权
	dfs1(1,0);//统计子树
	dfs2(1,0,0);//统计父亲
	for(int i=1;i<=n;i++){
		ans=max(ans,dp[i][k+1]);
	}
	cout<<ans<<endl;
	return 0;
}

```

[*Froggy's blog*](https://www.luogu.org/blog/1445353309froggy/)

#### 呱!!


---

## 作者：hgckythgcfhk (赞：5)

### 前言

首先，这是蒟蒻的第一篇题解（~~当然，那篇乱搞被打回的不算~~），然后，如果你想学树上 dp + 容斥的正解，请跳过此题解。

### 建图

关于建图，其他题解也说的很明白了，边权等于删掉这条边所产生的两个联通快的节点个数的乘积，但我的做法中，还会给每个点赋上该点的所有边的边权之和的点权。

### 核心部分

按点权排序，与其他题解的按边排序不同，按点权排序的正确性更有保证，考虑如果存在一个点的点权不是最大，该点作为答案的概率非常小，即使是答案，也一定离点权最大的点很近，因为边权是平方级的，所以边权的差会很大，导致点权的差很大，由于点权等于边权的和，对于随机的数据来说，点权的差也基本大于等于平方级，如果不选最大的点，至少在这个点上会减少平方级的贡献，考虑到可能会有点权相等的点，所以要对所有点权最大的点遍历，但点不会太多，可以用反证法证明这样的点要么是重心，要么与重心相邻，证明比较复杂，但这个结论是显然的，也就是说，我们可以只判断 $O(1)$ 个点，把时限卡到除输入外 $5ms$ 一定能过，然后就抢到了本题最优解。

关于按边权排序，显然也是正确的，但是我们习惯处理点，并不习惯处理边，而且用 vector 存图的话还需要额外开一个结构体，对于链式前向星，本身就很不方便，~~主要是我不会~~。

这里介绍一个很简单但不容易想到的小技巧，sort 的 cmp 函数不仅可以重载结构体的排序，也可以实现直接从大到小排序，比较方式可以是比较数组中以这两个元素为下标的值，这很好理解，因为这就是基础的语法，但第一次见不一定能想到。

这个做法虽然是乱搞但正确性和时间复杂度有保证，起码在本题数据范围和稍微大一点的范围下构造不出卡掉这个做法的数据，即使可以，随机交换几个元素的枚举顺序，或者随机在点权上加上一个不大的扰动值，可以以几乎可以忽略不计的出错率卡过所有数据，而且，想卡这个做法，必须人工构造数据，但这不好构造，比如对于本题数据，卡到 $5ms$ 也过了，几乎是只枚举了一次。

而且越大的数据，不是最大点权的概率越小，对于 $5\times10^{6}$ 的范围，可以只枚举 $5$ 轮以内，枚举过程用 bfs 实现，再卡一下常一定能过，正解做法是 $O(nk)$ 的，所以 $5\times10^{6}$ 的数据能卡掉正解，卡不掉这种做法，这种做法唯一的瓶颈就是排序，所以时间复杂度是 $O(n\log n)$ 的，程序很短，随手写的不刻意压行只有 $25$ 行，而且还有压行空间。

### 程序如下
```
#include<bits/stdc++.h>
using namespace std;
#define void inline void
#define int register unsigned short
#define ll unsigned long long
#define rr register ll
const unsigned short N=30001;vector<unsigned short>a[N];vector<ll>w[N];
ll dp[N];unsigned short s[N],f[N],k,n;bitset<N>b;
void dfs(int u){s[u]=1;for(int i=0;i<a[u].size();++i){int v=a[u][i];
	if(v==f[u])continue;f[v]=u;dfs(v);s[u]+=s[v];}}unsigned short d[N];
inline ll bfs(int u){rr ans=0;static unsigned short q[N<<1],l,r;q[0]=u;b[u]=1,l=r=0;
	d[u]=0;while(l<=r){int t=q[l++];for(int i=0;i<a[t].size();++i){int v=a[t][i];
	if(b[v])continue;ans+=w[t][i];if(d[t]>=k)continue;q[++r]=v;b[v]=1;d[v]=d[t]+1;}}
	b.reset(),memset(d,0,sizeof d);return ans;}
#define add(u,v) a[u].emplace_back(v);a[v].emplace_back(u)
void dpdate(int u){for(int i=0;i<a[u].size();++i){int v=a[u][i];
	if(v==f[u]){w[u].emplace_back(s[u]*(n-s[u]));continue;}
	w[u].emplace_back(s[v]*(n-s[v]));dpdate(v);}}
inline ll max(ll a,ll b){return a>b?a:b;}unsigned short id[N];
inline bool cmp(const int &a,const int &b){return dp[a]<dp[b];}
signed main(){ios::sync_with_stdio(0);unsigned t=clock();
	cin>>n>>k;for(int i=n-1;i;--i){int u,v;cin>>u>>v;add(u,v);}dfs(1);ll ans=0;
	dpdate(1);for(int i=n,j;i;--i){dp[i]=n-s[i];for(j=0;j<a[i].size();++j)dp[i]+=w[i][j];}
	for(int i=1;i<=n;++i)id[i]=i;sort(id+1,id+n+1,cmp);
	for(int i=n;i;--i){ans=max(ans,bfs(id[i]));if(clock()-t>500)break;}cout<<ans;}
```

如果你愿意写快读，完全能把最优解抢走，但 $126ms$ 不是这个做法的极限，只是我懒得写快读，懒得卡常了，预计卡常卡到极限能卡进 $40ms$。

---

## 作者：Tommy_clas (赞：5)

前言：我不大懂标签里的容斥做法，我自己的做法是不需要容斥的换根$DP$。

[传送门](https://www.luogu.org/problem/P5628)

题目大意：给定一棵大小为$n$的树，定义一条边的权值为树上经过该条边的不同路径的数量，同时定义树上两点的距离为两点连成的路径经过的边的数量，选出其中某一个点，将到该点的距离不大于$k$的点全部涂黑（包括选出的点），能得到的分数是这些点连出的边的权值的和（不重复），求得到分数的最大值。

首先是求出每条边的边权，这个比较容易，经过一条边的路径的数量其实就是边两端的端点所形成的子树的大小之积，因为只要分别在边的两侧任选两个点，这两个点之间的路径就一定能经过这条边。

形式化的：$v(u,v)=siz[u]\times siz[v]$

求出每条边的边权之后，然后考虑进行树形$DP$

我们不妨先设树的根为$1$，再将边权转化为点权，设$v[i]$表示到$i$到它的父亲的边的权值，同时设$v[1]=0$，设$DP$数组$dp[i][j]$表示在以$i$为根的子树中，到$i$的距离不超过$j$的点的点权之和。

至于转移，我们设$y$是$x$的儿子，那么有：

$dp[x][j]=\sum_{y=x_{son}}dp[y][j-1]+v[y](1≤j≤k+1)$

至于为什么要$k+1$，因为我们将边权变为了点权，所以到$x$距离为$k$的点连出的边的另一端的点到$x$的距离其实是$k+1$的。

这样，我们就能处理出每个点的子树对它的答案的贡献，然而，除了$dp[1][k+1]$以外，没有一个是我们要求的最后答案。这时候我们就需要用上换根$DP$了

换根$dp$的过程是在$dfs$中进行的。

我们设一个动态修改的$DP$数组$dp2[i][j]$表示当以$i$的某个儿子为树根时，以$i$为根的子树的$dp$值。

首先考虑怎么转移$dp2[x][j]$，大概分为以下步骤：

1. 将$dp[x][j]$原封不动地复制过来。

2. 删除将要$dfs$的儿子$y$对$x$的贡献。

3. 加上$x$的父亲$last$对$x$的贡献。

综上，我们可以得到$dp2[x][j]$的转移式：

$dp2[x][j]=dp[x][j]-dp[y][j-1]-v[y]+dp2[last][j-1]+v[x](1≤j≤k+1)$

注意！$dp2[x][j]$只对$x$将要遍历的儿子$y$有用，所以当递归回溯到$x$以后，我们还要重新求一遍$dp2[x][j]$。

然后是求出每个点的答案。

$ans[x]=\begin{cases}dp[x][k+1](x=1)&\\dp[x][k+1]+v[x]+dp2[last][k](x≠1)&\end{cases}$

最后输出答案的最大值即可。

时间复杂度$O(nk)$

上代码：
```cpp
#include<cstdio>
#include<iostream>
#define N 30005
#define ll long long
using namespace std;
int n,k,head[N],cnt,siz[N];
ll v[N],dp[N][205],dp2[N][205],maxn;
struct edge
{
	int to,nxt;
}w[2*N];
void add(int x,int y)
{
	w[++cnt]=(edge){y,head[x]};
	head[x]=cnt;
}
void dfs(int x,int last)
{
	siz[x]=1;
	for(int i=head[x];i;i=w[i].nxt)
	{
		int y=w[i].to;
		if(y==last)continue;
		dfs(y,x);
		siz[x]+=siz[y];
	}
	v[x]=(ll)siz[x]*(n-siz[x]);
}
void dfs1(int x,int last)
{
	dp[x][0]=0;
	for(int i=head[x];i;i=w[i].nxt)
	{
		int y=w[i].to;
		if(y==last)continue;
		dfs1(y,x);
		for(int j=1;j<=k;j++)
			dp[x][j]+=dp[y][j-1]+v[y];
	}
}
void dfs2(int x,int last)
{
	if(x==1)maxn=max(maxn,dp[x][k]);
	else maxn=max(maxn,dp[x][k]+v[x]+dp2[last][k-1]);
	for(int i=head[x];i;i=w[i].nxt)
	{
		int y=w[i].to;
		if(y==last)continue;
		dp2[x][0]=dp[x][0];
		for(int j=1;j<=k;j++)
			dp2[x][j]=dp[x][j]-dp[y][j-1]-v[y]+dp2[last][j-1]+v[x];
		dfs2(y,x);
	}
}
int main()
{
	scanf("%d %d",&n,&k);
	k++;
	for(int i=1,x,y;i<n;i++)
		scanf("%d %d",&x,&y),add(x,y),add(y,x);
	dfs(1,0);
	dfs1(1,0);
	dfs2(1,0);
	printf("%lld\n",maxn);
	return 0;
}
```


---

## 作者：saxiy (赞：5)

#### 题目分析：

树上容斥。

首先暴力和正解都需要先一遍 dfs $O(n)$ 处理出每条边的重要度，随便找一个根，遍历所有的节点，当前边的重要度就是子树的大小乘以剩下的节点数，即边的另一端节点数。

#### 暴力 40pts：

一种很容易想出来的暴力，枚举每个点，统计这个点施工带来的影响，取最大值，菊花图复杂度 $O(n^2)$。

下面给出暴力核心代码，仅供参考。

```cpp
ll dfs_m(int p, int fa, int d) {
	ll res = 0;
	//前向星存图，i与i^1为一条无向边，val[i>>1]为这条边的重要度
	for(int i = head[p];i;i = nxt[i])//受影响的边
		if(to[i] != fa) res += val[i >> 1];
	if(d) {//还能影响下一个距离的点
		for(int i = head[p];i;i = nxt[i])
			if(to[i] != fa)//继续受影响的点
				res += dfs_m(to[i], p, d - 1);
	}
	return res;
}
```

对于小数据 && 随机图能过，#10一条链也是专门让给dfs跑的，#4图随机但 $n$ 很大，我的实现跑不过。

#### 树上容斥 100pts：

设 $f[i][j]$ 为第 $i$ 个节点影响距离为 $j$ 时影响的边重要度之和，考虑其递推式。

- 阐述 1

相比之下 $f[i][j]$ 比 $f[i][j-1]$ 的影响大了一圈，而相邻节点的 $f[v][j-1]$ 包含了多的这一圈的影响度，可以尝试由相邻结点转移来，但 $f[v][j-1]$ 还多包含了 $i$ 点这边距离 $j-2$ 内的点，依次减去 $f[i][j-2]$ 再求和就得到了离 $i$ 距 $j-1$~$j$ 的点的影响度，最后加上 $f[i][j-2]$ 即为 $f[i][j]$ 的值。

- 阐述 2

想得到 $f[i][j]$ ,于是将相邻节点的 $f[v][j-1]$ 加起来（草稿纸上手模一下），发现距离 $i$ 为 $j-2$ 内的点 **多算了** $du[i]-1$ 次（$du[i]$ 为 $i$ 点在无向图上的度），减去 $f[i][j-2]\times (du[i]-1)$ 即是 $f[i][j]$ 的值。

**边界条件：**

$$f[i][-1]=0,f[i][0]=\sum_{e\in edge[i]}val[e]$$

最后枚举 $f[i][k-1]$ ，取最大值即为答案。

**复杂度分析：** 枚举 `j` $k$次 $O(k)$，枚举每个点 $O(n)$ ，枚举每个点相连的边（平摊每个点两条边） $O(1)$ ，总复杂度 $O(n\times k)$ 。

#### 代码实现：

```cpp
#include <bits/stdc++.h>
#define N 30005
#define K 205
using namespace std;
typedef long long ll;

int n, k;
int head[N], to[N << 1], nxt[N << 1], cnt = 2;
//边从2开始标号，一条无向边分为的两个有向边编号只有最后一bit位不同
//所以对于一组对边，重要度同为val[i >> 1]。
ll f[N][K], val[N];

void addedge(int u, int v) {
	to[cnt] = v;
	nxt[cnt] = head[u];
	head[u] = cnt++;
}

int dfs(int p, int fa) {//处理重要度O(n)
	int s = 1;
	for(int i = head[p];i;i = nxt[i])
		if(to[i] != fa) {
			int v = dfs(to[i], p);
			val[i >> 1] = (ll)v * (n - v);
			s += v;
		}
	return s;//返回子树大小
}

int main() {
	scanf("%d%d", &n, &k);
	k++;//注意+1方便处理奇怪的边界。。
	int a, b;
	for(int i = 1;i < n;i++) {
		scanf("%d%d", &a, &b);
		addedge(a, b);
		addedge(b, a);
	}
	dfs(1, 0);
	for(int i = 1;i <= n;i++)//边界条件
		for(int j = head[i];j;j = nxt[j])
			f[i][1] += val[j >> 1];
	for(int j = 2;j <= k;j++)//状态转移
		for(int i = 1;i <= n;i++) {
			f[i][j] = f[i][j - 2];
			for(int m = head[i];m;m = nxt[m])
				f[i][j] += f[to[m]][j - 1] - f[i][j - 2];
		}
	ll maxx = 0;
	for(int i = 1;i <= n;i++)//取最大值
		maxx = max(maxx, f[i][k]);
	printf("%lld", maxx);
	return 0;
}
```

---

## 作者：米奇 (赞：3)

## 题解

维护一个子树的前缀和$sum[u][i]$，表示在$u$的子树中距离$u<=i$的所有点权和（把边权放到点上）。

然后枚举点，向上m层，每条边都在和枚举的点的LCA处统计。

## 代码
```cpp
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#include<bits/stdc++.h>
using namespace std;
#define next Next
#define last Last
#define int long long
const int N=30005;
int n,m,top,F[N],head[N],Ans1[N],a[N],sz[N],val[N],f[N][205],size[N][205];
struct node{
    int too,next;
}edge[N*2];
#define gc getchar
//char buf[1<<21],*p1=buf,*p2=buf;
//inline int gc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}
inline int read()
{
    int ret=0,f=0;char c=gc();
    while(!isdigit(c)){if(c=='-')f=1;c=gc();}
    while(isdigit(c)){ret=ret*10+c-48;c=gc();}
    if(f)return -ret;return ret;
}
void add(int a,int b)
{
    edge[++top].too=b;edge[top].next=head[a];head[a]=top;
}
void dfs(int u,int fa)
{
    F[u]=fa;
    for(int i=0;i<=m;i++)size[u][i]=a[u];
    for(int i=head[u];i;i=edge[i].next)
    {
        int v=edge[i].too;
        if(v==fa)continue;
        dfs(v,u);
        for(int j=1;j<=m;j++)
            size[u][j]+=size[v][j-1];
    }
}
void solve(int u)
{
    int x=u,y,sum=size[u][m];
    for(int i=1;i<=m;i++)
    {
        y=F[x];
        if(y==0)break;
        if(i==m){sum+=a[y];x=y;break;}
        sum+=size[y][m-i]-size[x][m-i-1];
        x=y;
    }
    Ans1[u]=sum+val[x];
}
void suan(int u,int fa)
{
	sz[u]=1;
	for(int i=head[u];i;i=edge[i].next)
	{
		int v=edge[i].too;
		if(v==fa)continue;
		suan(v,u);
		val[v]=sz[v]*(n-sz[v]);
		a[u]+=sz[v]*(n-sz[v]);
		sz[u]+=sz[v];
	}
}
signed main()
{
    n=read();m=read();
    for(int i=1;i<n;i++)
    {
        int x=read(),y=read();
        add(x,y);
        add(y,x);
    }
    suan(1,0);
    dfs(1,0);
    for(int i=1;i<=n;i++)solve(i);
    int ans=0;
    for(int i=1;i<=n;i++)ans=max(ans,Ans1[i]);
    cout<<ans;
}
```

---

## 作者：cz666 (赞：2)

## 玄学暴力AC思路：

就把题意描述的这个图构建出来，并在构建过程中记录每个点与它相连的边对的权值和。

暴力模拟删点，如果删完某个点会导致整个图的边都删去，那就直接输出所有边的边权和。

我们发现......这样 $T$ 飞了（废话）......

再经过思考，因为边权与该边两边的点的个数有关，并不是随机边权，所以更大的答案应该是在删掉该点能对答案贡献较大的一些点之中。

~~反正也是暴力想不出正解，不妨改一改试一试~~，那么就对所有点删去后的贡献从大到小排个序然后选删去贡献最大的 $500$ 个点一个个计算答案并取max，发现居然通过了所有测试数据，并且效率还挺高的！（震惊！）

## 关于Hack...

本蒟蒻赛后在家里对拍了一下午还是没有对拍出错......也许是我造数据造得太水了......

如果有同学有 $hack$ 数据的构造方法欢迎在讨论区告诉我，谢谢。

## 暴力代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define dd c=getchar()
inline int read(){int s=0,w=1;char c;while (dd,c>'9' || c<'0') if (c=='-') w=-1;while (c>='0' && c<='9') s=s*10+c-'0',dd;return s*w;}
inline void write(int x){if (x<0) putchar('-'),x=-x;if (x>=10) write(x/10);putchar(x%10|'0');}
inline void wln(int x){write(x);putchar(10);}
inline void wlk(int x){write(x);putchar(32);}
#undef dd
const int maxn=30003;
int edge[maxn<<1],nxt[maxn<<1],val[maxn<<1],dep[maxn],ppp[maxn];
int vis[maxn],ans[maxn],head[maxn],fa[maxn],son[maxn],cnt;
inline void add(int u,int v){
	edge[++cnt]=v;nxt[cnt]=head[u];head[u]=cnt;
	edge[++cnt]=u;nxt[cnt]=head[v];head[v]=cnt;
}
inline int build(int x,int f){
	fa[x]=f;dep[x]=dep[f]+1;son[x]=1;
	for (int i=head[x];i;i=nxt[i])
	 if (edge[i]!=f) son[x]+=build(edge[i],x);
	return son[x];
}//建树时顺便统计子树大小方便得出边权
inline void give_value(int x,int f,int tot){
	for (int i=head[x];i;i=nxt[i])
	 if (edge[i]!=f){
	 	val[i]=son[edge[i]]*(tot-son[edge[i]]);
	 	if (edge[i-1]==x) val[i-1]=val[i];
		else val[i+1]=val[i];
		give_value(edge[i],x,tot);
	}
}//赋予边权
inline int solve(int x,int f,int full){
	if (!full) return 0;int now=ppp[x];
	for (int i=head[x];i;i=nxt[i]) if (edge[i]==f) now-=val[i];
	for (int i=head[x];i;i=nxt[i])
	 if (edge[i]!=f) now+=solve(edge[i],x,full-1);
	return now;
}//暴力寻找被毁掉的点并统计答案
signed main(){
	int n=read(),k=read();
	for (int i=1;i<n;++i) add(read(),read());
	int sum=build(1,0);sum=0;give_value(1,0,n);
	for (int i=1;i<2*n;i+=2) sum+=val[i];
	for (int i=1;i<=n;++i) for (int j=head[i];j;j=nxt[j]) ppp[i]+=val[j];
	int T=min(500ll,n),Ans=0;while(T--){
		int Maxn=0,Maxp=0;
		for (int i=1;i<=n;++i) if (Maxn<ppp[i]&&!vis[i]) Maxn=ppp[i],Maxp=i;
		vis[Maxp]=1;ans[Maxp]=solve(Maxp,Maxp,k+1);
		if (ans[Maxp]==sum) return wln(sum),0;
		Ans=max(Ans,ans[Maxp]);
	}//改进后的O(500*N)的暴力...
/*
	for (int i=1;i<=n;++i){
		ans[i]=solve(i,i,k+1);
		if (ans[i]==sum) return wln(sum),0;
	}
	int Ans=0;
	for (int i=1;i<=n;++i) Ans=max(Ans,ans[i]);
//一开始最普通的O(N^2)暴力...
*/
   	return wln(Ans),0;
}
```


---

## 作者：moosssi (赞：0)

树形 dp ，先预处理边权：乘法原理，边两边节点数之积。

然后很容易想到 dp 方程 $f_{x,j}$ 表示：距离节点 $x$ 距离小于 $j$ 的边权和。

直接转移不好做，先考虑子树内的转移 $f_{x,j}+=f_{v,j-1}+edge_i$ （ $v$ 是 $x$ 的子节点，$1\leq j\leq k+1$ ）

到 $x$ 距离小于 $j$ ，那么到 $v$ 的距离自然要减一，因为这里只统计了子树内的答案，所以还要加上 $x$ 和 $v$ 之间的边权。

再考虑如何统计子树外的答案的转移，如果像上面一样转移将对象 $v$ 替换成 $fa$ 会重复计算 $x$ 子树内的一部分，只需容斥一下，减去 $f_{x,j-2}$ 即可。

注意：枚举 $j$ 的顺序，$j=1$ 时要特判，还要 `long long` 。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=30005;
int head[N],ver[N*2],net[N*2],edge[N*2],tot;
int n,k,siz[N];
ll f[N][205],ans;
void add(int a,int b){
	net[++tot]=head[a];
	head[a]=tot;
	ver[tot]=b;
}
void dfs1(int x,int fa){
	siz[x]=1;
	for(int i=head[x];i;i=net[i]){
		int v=ver[i];
		if(v==fa)continue;
		dfs1(v,x);
		edge[i]=(n-siz[v])*siz[v];
		siz[x]+=siz[v];
	}
}
void dfs2(int x,int fa){
	for(int i=head[x];i;i=net[i]){
		int v=ver[i];
		if(v==fa)continue;
		dfs2(v,x);
		for(int j=1;j<=k+1;j++){
			f[x][j]+=edge[i]+f[v][j-1];
		}
	}
}
void dfs3(int x,int fa){
	for(int i=head[x];i;i=net[i]){
		int v=ver[i];
		if(v==fa)continue;
		for(int j=k+1;j>=2;j--){
			f[v][j]+=f[x][j-1]-f[v][j-2];
		}
		f[v][1]+=edge[i];
		dfs3(v,x);
	}
}
int main(){
	scanf("%d%d",&n,&k);
	for(int i=1;i<n;i++){
		int a,b;
		scanf("%d%d",&a,&b);
		add(a,b);
		add(b,a);
	}
	dfs1(1,0);
	dfs2(1,0);
	dfs3(1,0);
	for(int i=1;i<=n;i++){
		ans=max(ans,f[i][k+1]);
	}
	printf("%lld",ans);
	return 0;
} 
```


---


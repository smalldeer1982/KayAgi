# [JSOI2015] 染色问题

## 题目描述

萌萌家有一个棋盘，这个棋盘是一个 $n \times m$ 的矩形，分成 $n$ 行 $m$ 列共 $n \times m$ 个小方格。   
现在萌萌和南南有 $C$ 种不同颜色的颜料，他们希望把棋盘用这些颜料染色，并满足以下规定：   

1. 棋盘的每一个小方格既可以染色（染成 $C$ 种颜色中的一种），也可以不染色。   
2. 棋盘的每一行至少有一个小方格被染色。   
3. 棋盘的每一列至少有一个小方格被染色。   
4. 每种颜色都在棋盘上出现至少一次。  
 
以下是一些将 $3  \times 3$ 棋盘染成 $C=3$ 种颜色（红、黄、蓝）的例子（下图已更新）： 
  
![](https://cdn.luogu.com.cn/upload/image_hosting/7s4j5elx.png)    

请你求出满足要求的不同的染色方案总数。只要存在一个位置的颜色不同，即认为两个染色方案是不同的。

## 说明/提示

对于$100\%$的数据，$1 \le n,m,c \le 400$。

## 样例 #1

### 输入

```
2 2 3```

### 输出

```
60```

# 题解

## 作者：凉城無愛 (赞：59)

ps:感觉容斥对初学者而言很玄学（至少本人刚开始接触时是这样...），所以想写一篇题解，仔细分析容斥到底如何运用到题目中。


### 容斥

* 容斥解决的是满足多个条件的方案数的问题，这里可以把每个条件转化为集合（如果对集合的运算还不是很了解的同学，可以先了解集合的基本运算，这会对容斥的理解帮助很大），例：

  * $|U|$：所有情况的方案数
  * $S_i$：满足条件$i$的方案数
  * $   \begin{aligned} \left|\bigcup_{i=1}^{n}S_i\right|\end{aligned} $：满足任一一个条件的方案数
  * $ \begin{aligned} \left|\bigcap_{i=1}^{n}S_{i}\right|\end{aligned} $：全部条件都满足的方案数

* 容斥的核心思想是对“至少(至多)”和“恰好（一般是）”之间的转换，重点是弄清楚**哪种方案数容易求**，相关的式子如下：

  * $\begin{aligned} \left|\bigcup_{i=1}^{n}S_i\right|=\sum_{m=1}^n(-1)^{m-1}\sum_{a_i<a_{i+1} }\left|\bigcap_{i=1}^mS_{a_i}\right| \end{aligned}$
  * $  \begin{aligned}\left|\bigcap_{i=1}^{n}S_i\right|=|U|-\left|\bigcup_{i=1}^n\overline{S_i}\right|  \end{aligned}$
  

* 问题描述：

  > 一个$n\times m$的棋盘，用$c$种颜色染色，求满足条件的方案数
  > - 棋盘的每一个小方格既可以染色（染成$c$种颜色中的一种），也可以不染色。
  > - 棋盘的每一行至少有一个小方格被染色。
  > - 棋盘的每一列至少有一个小方格被染色。
  > - 每种颜色都在棋盘上出现至少一次。

  * 看上去很难，既要考虑颜色，又要考虑每一行，每一列，感觉特别不可做...
  * 我们先将颜色单独考虑。
  * 发现“出现至少一次”可以看成每种颜色都要用，即$ \begin{aligned} \left|\bigcap_{i=1}^{n}S_{i}\right|\end{aligned} $，而我们发现如果有某几种颜色不用，其它颜色不考虑用不用的方法好像很好求（（其它颜色数+1）^要填的格子数），即$ \begin{aligned} \left|\bigcap_{i=1}^{n}\overline{S_{i}}\right|\end{aligned} $。通过式子一和式子二共同转化，$  \begin{aligned}\left|\bigcap_{i=1}^{n}S_i\right|=|U|-\left|\bigcup_{i=1}^n\overline{S_i}\right|  =|U|- \sum_{m=1}^n(-1)^{m-1}\sum_{a_i<a_{i+1} }\left|\bigcap_{i=1}^mS_{a_i}\right|  \end{aligned} $
  * $ \begin{aligned} \sum_{a_i<a_{i+1} }\left|\bigcap_{i=1}^m\overline{S_{a_i}}\right| \end{aligned} $的意义是**所有组**$m$个颜色不用的方案数，组数就是$c$种颜色中选$m$种颜色，即$ \binom{C}{m}$组，为了表述方便，我们设$f[i]$表示在棋盘上用最多用$i$种颜色满足要求一、二的方案数（这个待会去求），而一组的答案就为$f[c-m]$，与组数相乘即可，而全集是$f[c]$（最多用$c$种颜色就是所有情况）。所以答案为$ans=f[c]-\sum_{i=1}^{c}f[c-i]*\binom{c}{i}*(-1)^{i-1}$
  * 类似的，计算$f[i]$的时候所要考虑的要求一、二，也可以通过上面的容斥分析得到。还是通过上面的式子转化，不过此时的$ \begin{aligned} \sum_{a_j<a_{j+1} }\left|\bigcap_{j=1}^k\overline{S_{a_j}}\right| \end{aligned} $就是**所有组**$k$列完全不涂色的方案数，一组的答案这么统计：对每一行单独考虑，答案数为$(i+1)^{m-k}$，可是一行不能全为空，就要减去一，$n$行都是独立的，相乘就是$((i+1)^{m-k}-1)^n$。这里全集就是当$k=0$时的值（0列完全不涂色就是所有的情况），所以$f[i]=((i+1)^m-1)^{n}-\sum_{k=1}^{m}*\binom{m}{k}*((i+1)^k-1)^n*(-1)^{k-1}$
  * 综合起来就可以了。
* 代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll mod=1e9+7;
ll n,m,c,f[410],C[410][410];
ll ksm(ll x,int y){
	ll ans=1;
	while(y){
		if(y&1)ans=ans*x%mod;
		x=x*x%mod,y=y>>1;
	}
	return ans;
}
int main(){
	cin>>n>>m>>c;
	for(int i=0;i<=400;i++){
		C[i][0]=1;
		for(int j=1;j<=i;j++){
			C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;
		}
	}
	for(ll i=1;i<=c;i++){
		ll st=0,k=1;
		for(int j=m;j>=1;j--,k=k*(i+1)%mod){
			if(j&1)
				st=(st+ksm(k-1,n)*C[m][j])%mod;
			else
				st=(st-ksm(k-1,n)*C[m][j]%mod+mod)%mod;
		}
		f[i]=(ksm(ksm(i+1,m)-1,n)-st+mod)%mod;
	}
	ll ans=f[c],an1=0;
	for(int i=1;i<=c;i++){
		if(i&1)
			an1=(an1+f[c-i]*C[c][i])%mod;
		else
			an1=(an1-f[c-i]*C[c][i]%mod+mod)%mod;
	}
	cout<<(ans-an1+mod)%mod;
	return 0;
}

```


---

## 作者：jiangby (赞：26)

容斥傻子题，首先可以想到限制最多多少种颜色，设为$F[i]$,所以答案
$$
	ans=\sum_{i=0}^{C}F[i]*\binom{C}{i}*(-1)^{c-i}
$$
,于是问题转换为了求$F[i]$,发现同样需要满足至少出现一次，仍可以容斥令所以考虑有多少列没选，可以写出
$$
F[i]=\sum_{j=1}^{m}\binom{m}{j}*((i+1)^{j}-1)^n*(-1)^{m-j}
$$
时间复杂度$O(mclog_n)$
```
#include<bits/stdc++.h>
#define ll long long
#define ld long double
#define pint pair<int,int>
#define mk(x,y) make_pair(x,y)
#define fir first
#define sec second
#define Rep(x,y,z) for(int x=y;x<=z;++x)
#define Red(x,y,z) for(int x=y;x>=z;--x)
using namespace std;
const int MAXN=405,Mod=1e9+7;
inline int read(){
	int p=1,x=0;char ch=getchar();
	while(ch<'0'||ch>'9')ch=='-'?p=-1:0,ch=getchar();
	while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return p*x;
}
int n,m,c,F[MAXN],C[MAXN][MAXN];
inline void pre(int n=400){Rep(i,0,n){C[i][0]=1;Rep(j,1,i)C[i][j]=(C[i-1][j-1]+C[i-1][j])%Mod;}}
inline int Fp(int x,int k){int ans=1;for(;k;x=1ll*x*x%Mod,k>>=1)if(k&1)ans=1ll*ans*x%Mod;return ans;}
int main(){
//	freopen("std.in","r",stdin);
//	freopen("std.out","w",stdout);
	n=read(),m=read(),c=read(),pre();
	Rep(i,1,c){
		int tmp=0;
		for(int j=m,opt=1;j>=1;j--,opt=Mod-opt)
			tmp=(tmp+1ll*C[m][j]*Fp(Fp(i+1,j)-1,n)%Mod*opt)%Mod;
		F[i]=tmp;
	}int tmp=0;
	for(int i=c,opt=1;i>=1;i--,opt=Mod-opt)tmp=(tmp+1ll*C[c][i]*F[i]%Mod*opt)%Mod;
	cout<<tmp<<'\n';
	return 0;
}


```



---

## 作者：辰星凌 (赞：23)

# **【题解】染色问题 [JSOI2015][P6076]**

[$\mathcal{My}\ \mathcal{Blog}$](https://www.cnblogs.com/Xing-Ling/p/13355716.html)

传送门：[染色问题 $\text{[JSOI2015][P6076]}$](https://www.luogu.com.cn/problem/P6076)

## **【题目描述】**

给出一个 $n\times m$ 的棋盘，有 $c$ 种颜色，现要对每个格子染色（可以不染），求满足每行至少有一个被染、每列至少有一个被染且每种颜色至少染了一个格子的方案数。

## **【分析】**

> 组合意义天地灭,代数推导保平安。 —— tiger0133

大家好像都是考虑容斥,咱这里有个不需要费脑子的二项式反演……（这句也是从[别人的博客里](https://www.luogu.com.cn/blog/command-block/solution-cf997c)嫖来的awa）

发现要统计的方案需满足条件“至少balabala”，不禁想到另一道题 [$\text{CF997C}$](https://www.luogu.com.cn/problem/CF997C)。类似地设 $g(i,j,k)$ 表示“至少balabala”，$f(i,j,k)$ 表示“恰好balabala”。  
但这里的 $f,g$ 都不好直接计算，而且值得注意的是，我们为了做反演而定义的“至少”与题目里的“至少”意义是不一样的。  
定义的“至少”真正含义为：钦定 $k$ 个满足“balabala”，其余随便。这样统计出来会有大量的重复计算。所以就算求出了 $f,g$ 数组，要转换成答案还需进一步容斥。


正难则反，可以**反过来设计状态**：

$f(i,j,k)$： **恰好**有 $i$ 行、$j$ 列一个都没染 且 **恰好** $k$ 种颜色没使用的方案数。

$g(i,j,k)$： **至少**有 $i$ 行、$j$ 列一个都没染 且 **至少** $k$ 种颜色没使用的方案数。

$g(i,j,k)$ 这个东西是可以直接算的，它等于 $C_{n}^{i}C_{m}^{j}C_{c}^{k}(c-k+1)^{(n-i)(m-j)}$ 。

而答案为 $f(0,0,0)$ 。

剩下的二项式反演就很套路了。

易知：$g(x,y,z)=\sum\limits_{i=x}^{n}\sum\limits_{j=y}^{m}\sum\limits_{k=z}^{c}C_{i}^{x}C_{j}^{y}C_{k}^{z}f(i,j,k)$

由高维二项式反演可得：

$f(x,y,z)=\sum\limits_{i=x}^{n}\sum\limits_{j=y}^{m}\sum\limits_{k=z}^{c}(-1)^{i+j+k-x-y-z}C_{i}^{x}C_{j}^{y}C_{k}^{z}g(i,j,k)$

则：  
$\begin{aligned}f(0,0,0)&=\sum\limits_{i=0}^{n}\sum\limits_{j=0}^{m}\sum\limits_{k=0}^{c}(-1)^{i+j+k-0}C_{i}^{0}C_{j}^{0}C_{c}^{0}g(i,j,k)\\&=\sum\limits_{i=0}^{n}\sum\limits_{j=0}^{m}\sum\limits_{k=0}^{c}(-1)^{i+j+k}C_{n}^{i}C_{m}^{j}C_{c}^{k}(c-k+1)^{(n-i)(m-j)}\end{aligned}$

直接暴算复杂度 $O(nmc \log_2(nm))$ 比较悬，枚举的时候把 $k$ 放在最外层，然后预处理 $c-k+1$ 的前 $nm$ 次幂，即可优化到 $O(nmc)$ 。

### **【Code】**

```cpp
#include<algorithm>
#include<cstring>
#include<cstdio>
#define LL long long
#define Re register int 
using namespace std;
const int N=403,P=1e9+7;
int n,m,K,ans,Mi[N*N],jc[N],inv[N],invjc[N];
inline void in(Re &x){
    int f=0;x=0;char ch=getchar();
    while(ch<'0'||ch>'9')f|=ch=='-',ch=getchar();
    while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    x=f?-x:x;
}
inline int C(Re m,Re n){return (LL)jc[n]*invjc[m]%P*invjc[n-m]%P;}
int main(){
//    freopen("123.txt","r",stdin);
    in(n),in(m),in(K),inv[1]=jc[0]=jc[1]=invjc[0]=invjc[1]=1;
    for(Re i=2;i<=max(max(n,m),K);++i)inv[i]=(LL)inv[P%i]*(P-P/i)%P,jc[i]=(LL)jc[i-1]*i%P,invjc[i]=(LL)invjc[i-1]*inv[i]%P;
    for(Re k=0;k<=K;++k){
        Mi[0]=1;
        for(Re i=1;i<=n*m;++i)Mi[i]=(LL)Mi[i-1]*(K-k+1)%P;
        for(Re i=0;i<=n;++i)
            for(Re j=0;j<=m;++j)
                (ans+=(LL)((i+j+k&1)?P-1:1)*C(i,n)%P*C(j,m)%P*C(k,K)%P*Mi[(n-i)*(m-j)]%P)%=P;
    }
    printf("%d\n",ans);
}
```


---

## 作者：uniqueharry (赞：12)

### [染色问题题解](https://www.luogu.com.cn/problem/P6076)

前排提示：本题解的解释很细致，某些部分可能到了繁琐的程度，但是浅显易懂，请各位根据需求选择。

四个条件：

1.棋盘的每一个小方格既可以染色（染成 $C$ 种颜色中的一种），也可以不染色。

2.棋盘的每一行至少有一个小方格被染色。

3.棋盘的每一列至少有一个小方格被染色。

4.每种颜色都在棋盘上出现至少一次。

转变成问题：用 $C$ 种颜色， $n$ 行满足条件，$m$ 列满足条件。

那么如何切入问题呢？考虑用最简单的方式计算出的答案具有怎样的含义。

现在一共有 $n\times m$ 个格子，每个格子一共有 $c$ 种颜色 + 空白共 $c+1$中选择，共有 $(c+1)^{nm}$ 个方案，而这对应的是：

#### 最多用 $C$ 种颜色，最多有 $n$ 行，$m$ 列满足条件的方案总数。

那么首先研究如何通过“最多有 $x$”的方案数得出“恰好有 $x$”的方案数：

令最多为 $f_i$，恰好为 $g_i$，则有：

$g_i = \sum\limits_{j=1}^{i-1}(-1)^{i-j}C^j_if_j$

我最开始困惑过一个非常愚蠢的问题，为什么不能直接通过 $f_i - f_{i-1}$ 计算 $g_i$呢？

原因很简单， $f_{i-1}$ 一共有 $i$ 种，而这 $i$ 种两两之间是有很多交集的，所以仍然需要容斥来解决。

那么如果设行，列满足情况时，最多用 $i$ 种颜色的方案数为 $f_i$，那么答案即为：

$f_c = \sum\limits_{i=1}^{c-1} (-1)^{c-i}C^i_cf_i$

而计算 $f_i$，我们有两种途径：

一是按照刚才类似的方法再容斥两次得出答案，时间复杂度 $O(nmc\log n)$

第二种时间复杂度更加优秀，也体现了一种常见的思想：

先给出式子：

$f_i = \sum\limits_{j=1}^n(-1)^{n-j}C_n^j((i+1)^j-1)^m$

逐步解释：

1.枚举的 $j$ :最多使 $j$ 行满足条件。

2.$(-1)^{n-j}$:容斥，和刚才分析的类似。

3.$C^j_n$：$n$ 行选 $j$ 行，和刚才分析的类似。

4.$((i+1)^j-1)^m$：这个做法的精髓。对于某一列考虑选中的 $j$ 行，每行都有 $i+1$ 种填法，但因为题目要求，不能全部选空白，所以要减去 1，而对于每一列情况都相同，所以使用乘法原理，再带一个 $m$ 次幂。

时间复杂度 $O(nc\log n)$

---

## 作者：囧仙 (赞：11)

不动脑子就可以做出来的二项式反演题。

## 题解

观察发现题目给出的 $2,3,4$ 三个限制可以用以下语言表述：

- 棋盘中**恰好**有 $n$ 行被染了色。
- 棋盘中**恰好**有 $m$ 列被染了色。
- 棋盘中**恰好**出现了一共 $c$ 种颜色。

二项式反演可以用来做这样一类转化：将「某种东西**恰好**有 $x$ 个」的方案数转化为计算「某种东西**不超过** $x$ 个」的方案数。

首先给出二项式反演的式子：

$$
f(n)=\sum_{i=0}^n \binom{n}{i}g(i)\iff g(n)=\sum_{i=0}^n\binom{n}{i}(-1)^{n-i}f(i)
$$

在证明之前，我们会频繁用到二项式定理。即：

$$(a+b)^n=\sum_{i=0}^n\binom{n}{i}a^ib^{n-i}$$

二项式反演的证明：

$$
\begin{aligned}
\sum_{i=0}^n\binom{n}{i}(-1)^{n-i}f(i)&=\sum_{i=0}^n\binom{n}{i}(-1)^{n-i}\sum_{j=0}^i\binom{i}{j}g(j)\cr
&=\sum_{i=0}^n\sum_{j=0}^i\binom{n}{i}\binom{i}{j}(-1)^{n-i}g(j) \cr
&=\sum_{i=0}^n\sum_{j=0}^i\binom{n}{j}\binom{n-j}{i-j}(-1)^{n-i}g(j) \cr
&=\sum_{j=0}^n\binom{n}{j}g(j)\sum_{i=j}^n\binom{n-j}{i-j}(-1)^{n-i} \cr
&=\sum_{j=0}^n\binom{n}{j}g(j)\sum_{i=0}^{n-j}\binom{n-j}{i}(-1)^{n-j-i} \cr
&=\sum_{j=0}^n\binom{n}{j}g(j)\cdot 0^{n-j} \cr
&=g(n)
\end{aligned}
$$

现在开始做这题。假设我们所求为 $f(n,m,c)$ 为「在 $n\times m$ 的棋盘里用 $c$ 种颜色满足题设要求」的方案数。那么设 $g(n,m,c)$ 为「在 $n\times m$ 的棋盘里用不超过 $c$ 种颜色满足其他要求（每行每列至少有一个方块上色）」，那么就有：

$$g(n,m,c)=\sum_{i=0}^c \binom{c}{i}f(n,m,i)\iff f(n,m,c)=\sum_{i=0}^c \binom{c}{i}(-1)^{c-i}g(n,m,i)$$

下面考虑计算出 $g(n,m,c)$。如法炮制，我们设 $\varphi(n,m,c)$ 为「在 $n\times m$ 的棋盘里用不超过 $c$ 种颜色，有不超过 $m$ 列有颜色，并且有 $n$ 行至少有一个方块被染色」的方案数，接着是设 $\psi(n,m,m)$ 为「在 $n\times m$ 的棋盘里用不超过 $c$ 种颜色，有不超过 $m$ 列有颜色，并且有不超过 $n$ 行有颜色」于是：

$$\begin{aligned}\varphi(n,m,c)=\sum_{i=0}^m\binom{m}{i}g(n,i,c)&\iff g(n,m,c)=\sum_{i=0}^m\binom{m}{i}(-1)^{m-i}\varphi(n,i,c) \cr
\psi(n,m,c)=\sum_{i=0}^n\binom{n}{i}\varphi(i,m,c)&\iff \varphi(n,m,c)=\sum_{i=0}^n\binom{n}{i}(-1)^{n-i}\psi(i,m,c)\end{aligned}$$

考虑 $\psi(n,m,c)$ 的含义。在 $n\times m$ 的矩形里每个格子都可以任意上色 $1\sim c$ 内的颜色，或者该格子不上色，每个格子互不制约，由乘法原理可得：

$$\psi(n,m,c)=(c+1)^{nm}$$

于是可以推知 $\varphi(n,m,c)$ 的表达式：

$$\varphi(n,m,c)=\sum_{i=0}^n\binom{n}{i}(-1)^{n-i}(c+1)^{im}=((c+1)^m-1)^n$$

进而得到 $g(n,m,c)$ 的表达式：

$$g(n,m,c)=\sum_{i=0}^m\binom{m}{i}(-1)^{m-i}((c+1)^i-1)^n$$

最后得到 $f(n,m,c)$ 的表达式：

$$f(n,m,c)=\sum_{i=0}^c \binom{c}{i}(-1)^{c-i}\sum_{j=0}^m\binom{m}{j}(-1)^{m-j}((i+1)^j-1)^n$$

稍微整理一下：

$$f(n,m,c)=\sum_{i=0}^c\sum_{j=0}^m \binom{c}{i}\binom{m}{j}(-1)^{c+m-i-j}((i+1)^j-1)^n$$

预处理出 $\binom{i}{j},i=1,2,\cdots 400,j=1,2\cdots 400$，那么就可以在 $\mathcal O(nm\log (nmc))$ 的时间复杂度内解决该题。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int INF =2147483647;
int n,m,c;
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
    return ret*w;
}
const int MOD =1e9+7;
int pwr(int x,int y){
    int r=1; while(y){
        if(y&1) r=1ll*x*r%MOD; x=1ll*x*x%MOD,y>>=1;
    }
    return r;
}
const int MAXN=400+3;
int C[MAXN][MAXN],t=400,ans;
int main(){
    n=qread(),m=qread(),c=qread();
    up(0,t,i) C[i][i]=C[i][0]=1;
    up(1,t,i) up(1,t,j) C[i][j]=(C[i-1][j]+C[i-1][j-1])%MOD;
    up(0,c,i) up(0,m,j){
        int u=1ll*C[c][i]*C[m][j]%MOD*pwr((pwr(i+1,j)-1),n)%MOD;
        if((c+m-i-j)&1) ans=(ans-u+MOD)%MOD;
        else            ans=(ans+u)%MOD;
    }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：zhaoyp (赞：6)

设 $h(x)$ 为至多用 $x$ 种颜色的方案数，$p(x)$ 为恰好用 $x$ 种颜色的方案数。则有：

$$h(c) = \sum\limits_{i=0}^c \dbinom{c}{i} p(i)$$

反演得：

$$p(c) = \sum\limits_{i=0}^c(-1)^{c-i} \dbinom{c}{i} h(i)$$

在保证每行都会被染的情况下，$f(x)$ 为至多使用 $i$ 种颜色，至多保证 $x$ 列合法的方案数，$g(x)$ 为恰好保证 $x$ 列合法的方案数。则有：

$$f(m) = \sum\limits_{j=0}^m \dbinom{m}{j} g(j)$$

反演得：

$$g(m) = \sum\limits_{j=0}^m(-1)^{m-j} \dbinom{m}{j} f(j)$$

其中

$$f(k) = ((i+1)^k-1)^n$$

考虑每个格子有 $i + 1$ 种方案，每行有 $k$ 个要染的，再减去全为 $0$ 的方案即可。

综上：

$$ans = \sum\limits_{i=0}^c(-1)^{c-i} \dbinom{c}{i} h(i)$$

$$h(i) = \sum\limits_{j=0}^m(-1)^{m-j} \dbinom{m}{j} ((i+1)^j-1)^n$$


---

## 作者：EnofTaiPeople (赞：5)

该用什么就推什么吧，二项式反演用于将恰好的问题转换为至多或至少问题。

考虑先将此问题转换为至多类型：

不妨设 $p(n,m,c)$ 为至多有 $n$ 行，$m$ 列，$c$ 种颜色的方案数，显然每一个方格都有 $c+1$ 种选择，故 $p(n,m,c)=(c+1)^{nm}$。

设 $h(n,m,c)$ 表示恰好有 $n$ 行的方案数，有 $p(n,m,c)=\sum\limits_{i=0}^n\dbinom n ih(i,m,c)$；
设 $g(n,m,c)$ 表示恰好有 $n$ 行 $m$ 列的方案数，有 $h(n,m,c)=\sum\limits_{i=0}^m\dbinom m ig(n,i,c)$；
设 $f(n,m,c)$ 表示恰好有 $n$ 行 $m$ 列，$c$ 种颜色的方案数，有 $g(n,m,c)=\sum\limits_{i=0}^c\dbinom c if(n,m,i)$。

显然，对于 $G(n)=\sum\limits_{i=0}^n\dbinom n iF(i)$，我们需要用 $G$ 倒推 $F$。

具体地，我们有：$F(n)=\sum\limits_{i=0}^n\dbinom n i(-1)^{n-i}G(i)$，具体推导如下：

$\sum\limits_{i=0}^n\dbinom n i(-1)^{n-i}G(i)=\sum\limits_{i=0}^n\dbinom n i(-1)^{n-i}\sum\limits_{j=0}^i\dbinom i j(-1)F(j)$

$=\sum\limits_{i=0}^n\sum\limits_{j=0}^i\dbinom n i\dbinom i j(-1)^{n-i}F(j)$

$=\sum\limits_{i=0}^n\sum\limits_{j=0}^i\dbinom n j\dbinom{n-j}{i-j}(-1)^{n-i}F(j)$

$=\sum\limits_{j=0}^n\dbinom n jF(j)\sum\limits_{i=j}^n\dbinom{n-j}{i-j}(-1)^{n-i}$

$=\sum\limits_{i=0}^n\dbinom n iF(i)\sum\limits_{j=0}^{n-i}\dbinom{n-i}j(-1)^{n-i-j}$

$=\sum\limits_{i=0}^n\dbinom n iF(i)[n-i=0]$

$=F(n)$。

于是，我们可以开始反演啦！

$h(n,m,c)=\sum\limits_{i=0}^n\dbinom n i(-1)^{n-i}(c+1)^{im}=\sum\limits_{i=0}^n((c+1)^{m}-1)^n$；

$g(n,m,c)=\sum\limits_{i=0}^m\dbinom m i(-1)^{m-i}((c+1)^i-1)^n$

$f(n,m,c)=\sum\limits_{i=0}^c\dbinom c i(-1)^{c-i}\sum\limits_{j=0}^m\dbinom m j(-1)^{m-j}((i+1)^j-1)^n$

$=\sum\limits_{i=0}^c\sum\limits_{j=0}^m\dbinom c i\dbinom m j(-1)^{c+m-i-j}((i+1)^j-1)^n$。

可以预处理组合数，然后快速幂，时间复杂度 $O(mc)\log_2(n+m+c)$：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=405,M=1e9+7;
using ll=long long;
int C[N][N],n,m,c,p,ans;
int qp(int a,int x){
    int res=1;for(;x;a=ll(a)*a%M,x>>=1)
        if(x&1)res=ll(res)*a%M;return res;
}
int f[N][N],g[N][N],h[N][N];
int main(){
    scanf("%d%d%d",&n,&m,&c);
    p=max({n,m,c});
    int i,j,k;
    for(i=0;i<=p;++i)
        for(C[i][0]=j=1;j<=i;++j)
            C[i][j]=(C[i-1][j-1]+C[i-1][j])%M;
    for(i=0;i<=c;++i)
        for(j=0;j<=m;++j){
            ll dat=(((c^i^m^j)&1)?M-1:1);
            dat=dat*C[c][i]%M*C[m][j]%M;
            dat=dat*qp(qp(i+1,j)-1,n)%M;
            if((ans+=dat)>=M)ans-=M;
        }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：ChengJY_ (赞：3)

个人认为是道很好的组合加容斥练习题。

### Solution

考虑将行，列，颜色的限制分开处理。

先限制颜色。

令 $f(i)$ 为只使用 $i$ 种颜色，满足行列限制的方案数，
$$
ans=\sum\limits_{i=0}^c\dbinom{c}{i}(-1)^{c-i}f(i)
$$
再限制列。

令 $g(i,j)$ 为只是用 $i$ 种颜色，只填 $j$ 列的方案数。
$$
f(i)=\sum\limits_{j=0}^m\dbinom{m}{j}(-1)^{c-j}g(i,j)
$$
最后
$$
g(i,j)=((i+1)^j-1)^n
$$
带入求解即可，时间复杂度 $O(mc\log n)$ 。

### Code

```
#include<bits/stdc++.h>
#define N 505
#define int long long
using namespace std;

int read(){
    int x=0,w=1;
    char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return x*w;
}

const int mod = 1e9+7;
int n,m,c,ans;
int fac[N],ifac[N],a[N],f[N];

int qpow(int x,int k){
    int res=1;
    while(k){
        if(k&1) res=res*x%mod;
        x=x*x%mod;k>>=1;
    }
    return res;
}
void init(){
    fac[0]=ifac[0]=1;
    for(int i=1;i<=400;++i) fac[i]=fac[i-1]*i%mod;
    ifac[400]=qpow(fac[400],mod-2);
    for(int i=399;i>=1;--i) ifac[i]=ifac[i+1]*(i+1)%mod;
}
int C(int x,int y){ return fac[x]*ifac[y]%mod*ifac[x-y]%mod; }

signed main(){
    init();
    n=read();m=read();c=read();
    for(int i=0;i<=c;++i)
        for(int j=m,opt=1;j>=0;--j,opt*=-1){
            int x=opt*C(m,j)*qpow((qpow(i+1,j)-1+mod)%mod,n)%mod;
            f[i]=(f[i]+x+mod)%mod;
        }
    for(int i=c,opt=1;i>=0;--i,opt*=-1) ans=(ans+opt*C(c,i)%mod*f[i]%mod+mod)%mod;
    printf("%lld\n",ans);
    //for(int i=0;i<=c;++i) cout<<f[i]<<endl;
    return 0;
}
```



---

## 作者：Elma_ (赞：3)

> [P6076 [JSOI2015]染色问题](https://www.luogu.com.cn/problem/P6076)

考虑容斥。枚举有 $i$ 行， $j$ 列不填，$k$ 种颜色不用的方案数，不难得到答案为：

$$\sum_{i=0}^{n} \sum_{j=0}^{m} \sum_{k=0}^{c} (-1)^{i+j+k}\dbinom{n}{i} \dbinom{m}{j} \dbinom{c}{k}(c-k+1)^{(n-i)(m-j)}$$

$$= (-1)^{i+j+k}\sum_{k=0}^{c}(c-k+1)^{(n-i)(m-j)}\sum_{i=0}^{n} \sum_{j=0}^{m} \dbinom{n}{i} \dbinom{m}{j} \dbinom{c}{k}$$

组合数可以最开始就预处理出来，中间 $(c-k+1)$ 的次幂也可以在枚举 $k$ 的时候预处理，总的时间复杂度为 $O(cnm)$。

代码还是贴一下吧，不过似乎只有会敲和懒得敲。注意从 $0$ 开始枚举。

```cpp
#include <cmath>
#include <queue>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define ll long long
using namespace std;

inline int read() {
	int x = 0, w = 1;char ch = getchar();
	while (ch > '9' || ch < '0') { if (ch == '-')w = -1;ch = getchar(); }
	while (ch >= '0' && ch <= '9')x = x * 10 + ch - '0', ch = getchar();
	return x * w;
}

const int maxn = 405;
const int mod = 1e9 + 7;

int n, m, c, ans;
int fac[maxn], ifac[maxn], cpow[maxn * maxn];

inline int qpow(int a, int b) {
	int res = 1;
	for (;b;b >>= 1, a = 1ll * a * a % mod) {
		if (b & 1) res = 1ll * res * a % mod;
	}
	return res;
}
inline void init(int n) {
	fac[0] = 1;
	for (int i = 1;i <= n;i++) fac[i] = 1ll * fac[i - 1] * i % mod;
	ifac[n] = qpow(fac[n], mod - 2);
	for (int i = n;i;i--) ifac[i - 1] = 1ll * ifac[i] * i % mod;
}
inline int C(int n, int m) {
	return 1ll * fac[n] * ifac[m] % mod * ifac[n - m] % mod;
}

int main(void) {
	init(maxn);
	n = read(), m = read(), c = read();
	for (int k = 0;k <= c;k++) {
		for (int i = cpow[0] = 1;i <= n * m;i++) {
			cpow[i] = 1ll * cpow[i - 1] * (c - k + 1) % mod;
		}
		for (int i = 0;i <= n;i++) {
			for (int j = 0;j <= m;j++) {
				int val = 1ll * C(n, i) * C(m, j) % mod * C(c, k) % mod * cpow[(n - i) * (m - j)] % mod;
				(i + j + k) & 1 ? ans = (ans - val + mod) % mod : ans = (ans + val) % mod;
			}
		}
	}
	printf("%d\n", ans);
	return 0;
}
```


---

## 作者：hehelego (赞：2)

好卡常数啊QAQ...  
我这辣鸡机子跑10s的程序,扔过去就AC了...我也不知道怎们办了

-----

### insight
这个计数约束的至少一个非常烦啊QAQ...如果是至多就非常好做了...考虑至多用$c$种颜色去染$r$个格子,可以不染色,那么方案数是$(c+1)^r$非常好做.  
我们考虑做一个它们之间的转换,而这个东西就是喜闻乐见的容斥.

### sol

不要任何约束$all=(c+1)^{nm}$,我们尝试算出所有不合法方案,对于三个约束条件,我们列出这些集合.
$$A_i=(\text{至少}i\text{行没有染色})$$
$$B_i=(\text{至少}i\text{行没有染色})$$
$$C_i=(\text{至少}i\text{颜色没有使用})$$
我们要求的就是$|(\cup A_i)\cup(\cup B_j)\cup(\cup C_k)|$容斥一下,对于展开式中的这样一个三类集合分别有a b c个的一项.
$aA\cap bB\cap kC$它的系数是$(-1)^{a+b+k+1}$.  
它的意义是至少$(am+bn-ab)$个格子没颜色,最多用$c-k$种颜色,可以不染色,于是$|aA\cap bB\cap kC|$就是$(c-k+1)^{nm-(am+bn-ab)}$了.  
这样a个A类集合,b个B类,k个C类的集合交起来的项有$\binom{n}{a}\binom{m}{b}\binom{C}{k}$个.

我们枚举$(a,b,k)$满足$0\leq a\leq n,0\leq b\leq m,0\leq k\leq C$然后暴力求幂就做完了…复杂度$O((cnm)^3\log R)$,其中$R=nm$.~~卡一卡是可以过的.~~

然后这里求幂的地方,底数和指数分别在$[0,C+1],[0,nm]$中,我们递推求出每个可能用到的幂,这样就没有$log$了,还砍掉了一些实现的常数.另外那个$\binom{x}{y}$暴力递推就行了,它不是瓶颈,复杂度小于预处理幂的部分. 于是这样总复杂度做到了$O(cnm)$.  

~~不卡还是可以过的~~. 


### code

```cpp
#include <bits/stdc++.h>
int read(){
	int x=0;char c;
	do{c=getchar();}while(!isdigit(c));
	do{x=x*10+c-'0';c=getchar();}while(isdigit(c));
	return x;
}
const int N=400+10;
const int mod=int(1e9)+7LL;
int binom[N][N],pow_tbl[N][N*N];
int n,m,C;
int qpow(int a,int p){ return pow_tbl[a][p]; }
int solve(int i,int j,int k){
	if(i+j+k==0) return 0;
	int cnt=n*m-(i*m+j*n-i*j);
	return qpow(C-k+1,cnt);
}
void init(){
	binom[0][0]=1;
	for(int i=1;i<N;i++){
		binom[i][0]=binom[i][i]=1;
		for(int j=1;j<i;j++) binom[i][j]=(binom[i-1][j-1]+binom[i-1][j])%mod;
	}
	for(int bs=0;bs<=C+1;bs++){
		pow_tbl[bs][0]=1;
		for(int i=1;i<=n*m;i++) pow_tbl[bs][i]=1LL*pow_tbl[bs][i-1]*bs%mod;
	}
}
int main(){
	n=read();m=read();C=read(); init();
	std::cerr<<1.0*clock()/CLOCKS_PER_SEC<<std::endl;
	int all=qpow(C+1,n*m);int ta=0,tb=0;
	for(int i=0;i<=n;i++) for(int j=0;j<=m;j++) for(int k=0;k<=C;k++){
		int f=i+j+k;int qwq=solve(i,j,k);
		qwq=1LL*qwq*binom[n][i]%mod*binom[m][j]%mod*binom[C][k]%mod;
		if(f&1) ta=(ta+qwq)%mod;
		else tb=(tb+qwq)%mod;
	}
	int tmp=(ta-tb+mod)%mod;
	std::cout<<(all-tmp+mod)%mod<<std::endl;
	std::cerr<<1.0*clock()/CLOCKS_PER_SEC<<std::endl;
	return 0;
}
```




---

## 作者：wmy_goes_to_thu (赞：2)

容斥，容斥，再容斥！

这里提供一个不用脑子随便容斥的做法。

首先，所有颜色都得有这个条件比较麻烦，所以首先这样容斥：

$C_c^c \times f_c-C_c^{c-1} \times f_{c-1}+\dots+(-1)^n \times f_0$，其中 $f_i$ 的意义是用 $i$ 种颜色不需要用到所有颜色的染色。接着，我们来求 $f_k$。

其实，这里可以再用一个容斥，根据几行几列来做。如果是 $i$ 行 $j$ 列，那么这部分的贡献应该是 $(-1)^{i+j} \times C_n^i \times C_m^j  \times (k+1)^{(n-i) \times (m-j)}$，这里 $(n-i) \times (m-j)$ 的意思就是去掉 $i$ 个行和 $j$ 个列。

然后就可以求出答案了，因为取模的原因，ans 最终可能是负数，需要再模一下。

复杂度分析：正常

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int cc[2005][2005],p[160005];
int main()
{
	int n,m,c;
	cin>>n>>m>>c;
	cc[0][0]=1;
	for(int i=1;i<=2000;i++)
	{
		cc[i][0]=1;
		for(int j=1;j<=i;j++)cc[i][j]=(cc[i-1][j-1]+cc[i-1][j])%1000000007;
	}
	int ans=0,flag=1;
	for(int i=c;i>=0;i--)
	{
		p[0]=1;
		for(int j=1;j<=160000;j++)p[j]=1ll*p[j-1]*(i+1)%1000000007;
		int ff=0;
		for(int j=0;j<=n;j++)for(int k=0;k<=m;k++)
		{
			int tt=1;
			if(j+k&1)tt=-1;
			ff=(ff+1ll*tt*cc[n][j]*cc[m][k]%1000000007*p[(n-j)*(m-k)])%1000000007;
		}
		ans=(ans+1ll*flag*cc[c][i]*ff)%1000000007;
		flag=-flag;
	}
	cout<<(ans%1000000007+1000000007)%1000000007<<endl;
	return 0;
}
```

---

## 作者：Sktic (赞：2)

update:2020-08-24 优化题解风格，添加 $\LaTeX$ 公式

### Solution
看完题目，可发现共有 $n + m + c$ 个限制条件：$n$ 行、$m$ 列、$c$ 种颜色
我们将它们进行容斥，得到
$$ans=\sum_{i=0}^{..}\sum_{j=0}^{...}\sum_{k=0}^{.}(-1)^{i+j+k} \dbinom{n}{i }\dbinom{m}{j} \dbinom{c}{k}(c-k+1)^{(n-i)(m-j)}$$
$$=\sum^n_{i=0}\sum^c_{j=0}(-1)^{(i+k}\dbinom{n}{i}\dbinom{c}{k}\sum^m_{j=0}(-1)^j\dbinom{m}{j}[(c-k+1)^{n-i}]^{m-j}$$
$$=\sum^n_{i=0}\sum^c_{k=0}(-1)^{i+k}\dbinom{n}{i}\dbinom{c}{k}[(c-k+1)^{n-i}-1]^{m}$$

我们先预处理组合数，就可以 $O(n^2logn)$ 计算。

---

## 作者：james1BadCreeper (赞：0)

设 $f(i)$ 代表最多使用 $i$ 种颜色完成目标的方案数。考虑 $S_i$ 代表有第 $i$ 种颜色的方案集合。“每个颜色都至少出现一次”为 $\displaystyle\left|\bigcap_{i=1}^{n}S_i\right|$，可以写为：

$$
\begin{aligned}
&\left|U\right|-\left|\bigcup_{i=1}^{n}\overline{S_i}\right|\\
=&\left|U\right| - \sum_{m=1}^n(-1)^{m-1}\sum_{a_i<a_{i+1} }\left|\bigcap_{i=1}^m\overline{S_{a_i}}\right|
\end{aligned}
$$

后面这个 $\displaystyle\left|\bigcap_{i=1}^m\overline{S_{a_i}}\right|$ 是说至少不选 $m$ 种颜色，有 $\dbinom{c}{m}$ 种选择方式，单个选择方式有 $f[c-m]$ 种合法方案数。可以使用容斥原理计算，那么最终：

$$
\begin{aligned}
ans&=f(c)-\displaystyle\sum\limits_{i=1}^c(-1)^{i-1}\binom{c}{i}\times f[c-i]\\
&=\displaystyle\sum\limits_{i=0}^c(-1)^{i}\binom{c}{i}\times f[c-i]
\end{aligned}
$$

$f$ 也可以使用类似的方式计算出来。$S_i$ 代表第 $i$ 列有颜色的方案集合，然后推导出来的 $\displaystyle\left|\bigcap_{i=1}^k\overline{S_{a_i}}\right|$ 就是 $a_1\cdots a_k$ 这 $k$ 列没有颜色，那么：

$$
f_i=\sum_{k=0}^{m}(-1)^{k}\binom{m}{k}((i+1)^{m-k}-1)^n
$$

```cpp
#include <iostream>
#include <cstdio>

using namespace std;
typedef long long i64;
const int MOD = 1000000007;

i64 poww(int a, int b) {
    int res = 1;
    for (; b; b >>= 1, a = 1ll * a * a % MOD)
        if (b & 1) res = 1ll * res * a % MOD;
    return res;
}

void add(i64 &a, int t) {
    a = ((a + t) % MOD + MOD) % MOD;
}

int n, m, c;
int C[405][405];
i64 f[405];

int main(void) {
    for (int i = 0; i <= 400; ++i) {
        C[i][0] = 1;
        for (int j = 1; j <= i; ++j) 
            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % MOD;
    }
    scanf("%d%d%d", &n, &m, &c);
    for (int i = 1; i <= c; ++i)
        for (int k = 0; k <= m; ++k)
            add(f[i], (k & 1 ? -1 : 1) * C[m][k] * poww(poww(i + 1, m - k) - 1, n) % MOD);
    i64 ans = 0;
    for (int i = 0; i <= c; ++i)
        add(ans, (i & 1 ? -1 : 1) * C[c][i] * f[c - i] % MOD);
    printf("%lld\n", ans);
    return 0;
}
```

---

## 作者：yukari1735 (赞：0)

前置知识：经典容斥，可以在我的 [blog](https://www.cnblogs.com/yukari1735/p/16913859.html) 里了解一下

容斥套容斥。

我们考虑一个一个地通过容斥把这些条件去掉，先令元素是所有染色方案，第 $i$ 个颜色的出现次数是 $c_i$，条件集合是 $\{c_1=0,c_2=0,\dots\}$ 套用容斥模型消掉最后一个条件，注意到这些颜色的地位是等价的，我们枚举条件集合大小化简式子，答案就是

$$\begin{aligned}
&\sum_{S\subseteq U}(-1)^{|S|}f(S)\\
=&\sum_{i=0}^c\binom{c}{i}(-1)^{|S|}s(c-i)\\
\end{aligned}$$

其中 $s(c)$ 是只用 $\leq c$ 种颜色不考虑第颜色条件的涂色方案数。

接下来再容斥掉行列限制，若第 $i$ 行全不染那么 $q_i=0$，令条件集合是 $\{q_1=0,q_2=0,\dots\}$，每一行的地位也是等价的，我们得到

$$\begin{aligned}
s(c)=&\sum_{S\subseteq U}(-1)^{|S|}f(S)\\
=&\sum_{i=0}^n\binom{n}{i}(-1)^is'(c,n-i)\\
\end{aligned}$$

其中 $s'(n,i)$ 是只用 $\leq n$ 种颜色，假设地图只有 $i$ 行后不考虑行和颜色条件的涂色方案数，只需考虑不允许有空列，剩下随便填，显然就是

$$s(c,i)=\bigg((c+1)^{i}-1\bigg)^m$$

（考虑先填出一列合法的，然后再拼出 $m$ 列）

时间复杂度 $O(nc\log m)$。

```cpp
# include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int N = 5e5 + 225;
const ll Mod = 1e9 + 7;

int n , m , c;

ll Pow( ll x , ll y ){
  ll res = 1;
  while( y ){
    if( y & 1 ) res = res * x % Mod;
	x = x * x % Mod , y >>= 1;
  }
  return res;
}

ll f[ N ] , invf[ N ] , g[ N ];

ll Binom( int p , int q ){ return f[ p ] * invf[ q ] % Mod * invf[ p - q ] % Mod; }

ll G( int p , int q ){ return Pow( ( Pow( p + 1 , q ) - 1 + Mod ) % Mod , m ); }

ll F( int p ){
  ll res = 0;
  for( int i = 0 ; i <= n ; i ++ ) res = ( res + ( ( i & 1 ) ? Mod - 1 : 1 ) * Binom( n , i ) % Mod * G( p , n - i ) % Mod ) % Mod;
  return res;
}

int main(){
  scanf( "%d%d%d" , & n , & m , & c );
  f[ 0 ] = invf[ 0 ] = 1;
  int wq = max( max( n , m ) , c );
  for( int i = 1 ; i <= wq ; i ++ ) f[ i ] = f[ i - 1 ] * i % Mod;
  invf[ wq ] = Pow( f[ wq ] , Mod - 2 );
  for( int i = wq - 1 ; i >= 1 ; i -- ) invf[ i ] = invf[ i + 1 ] * ( i + 1 ) % Mod;
  ll ans = 0;
  for( int i = 0 ; i <= c ; i ++ ) ans = ( ans + ( ( i & 1 ) ? Mod - 1 : 1 ) * Binom( c , i ) % Mod * F( c - i ) ) % Mod;
  printf( "%lld\n" , ans );
  return 0;
}
```

---

## 作者：lzp101001 (赞：0)

### 前言

让我们一起揭开容斥原理朦胧的面纱

容斥原理被广泛应用于求解一些集合的面积并，对应到实际问题上是求解统计时容易出现重复计算的方案数的问题

### 简要题意
给出一个 $n * m$ 的棋盘，有 $c$ 种颜色，现要对每个格子染色（可以不染），求满足每行至少有一个被染、每列至少有一个被染且每种颜色至少染了一个格子的方案数。

### 思路启发

假设我们已经求出了每个$f [ i ]$，它表示只用 $0$~ $i$ 种颜色（且满足行列要求）的方案数

怎么利用它来求出原问题的答案呢？

考虑 $f [ c ]$ ，它代表的是只用 $0~c$ 种颜色的方案数，而我们希望求得的是只用 $c$ 种颜色的方案数，如果让 $f [ c ]$ 减去只用 $0\sim c-1$ 种颜色的方案数是不是就可以了呢？

Nope.

很容易手玩出：这样会重复多次减去相同的方案，我们还需要把多减去的 _补回来_ 

这样推导下去，我们会发现它就是一个容斥原理的题目


公式：$ans=\sum_{i=0}^c(-1)^iC_{c}^{c-i}f[c-i]$

------------

接下来考虑如何求每个 $f [ i ]$

利用上面的思想，依次考虑只填 $0\sim k$ 列的方案数

对于每一行，当前 $k$ 列的涂色方案数为 $i+1$ 的 $k$ 次方 ，但是要去掉每个位置都不填的那一种方案

公式：$f[i]=\sum_{k=0}^m(-1)^kC_{m}^{m-k}[(i+1)^{m-k}-1]^n$

------------

AC代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline void read(ll &V){
    ll f=1,x=0; char ch=getchar();
    while(ch<'0'||ch>'9'){ if(ch=='-') f=-1; ch=getchar();}
    while(ch>='0'&&ch<='9') x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    V=f*x;
}
const ll p=1000000007;
const ll N=410;
ll m,n,c;
ll f[N];
ll C[N][N];
ll pre[N];
void inits(ll n){
	for(ll i=0;i<=n;i++){
		for(ll j=0;j<=i;j++){
			if(!j) C[i][j]=1;
			else C[i][j]=(C[i-1][j]+C[i-1][j-1])%p;
		}
	}
}
ll qmi(ll a,ll b){
	ll res=1;
	while(b){
		if(b&1) res=res*a%p;
		a=a*a%p;
		b>>=1;
	}
	return res;
}
ll X(ll x){
	if(x&1) return -1;
	else return 1;
}
int main(){
    inits(400);
    read(n),read(m),read(c);
    for(ll i=0;i<=c;i++){
    	pre[0]=1;
    	for(ll k=1;k<=m;k++){
    		pre[k]=pre[k-1]*(i+1)%p;
		}
    	for(ll k=0;k<=m;k++){
    		f[i]=(f[i]+X(k)*C[m][k]%p*qmi((pre[m-k]-1+p)%p,n)%p+p)%p;
		}
	}
	ll ans=0;
	for(ll i=0;i<=c;i++){
		ans=(ans+X(i)*C[c][i]%p*f[c-i]%p+p)%p;
	}
	cout<<ans;
    return 0;
}
```

---

## 作者：yyxmy (赞：0)

这道题限制看上去可真多， 不过数据范围比较小， 一个限制一个限制来做就可以了。

首先我们可以考虑颜色的限制， 即让所有颜色都出现在方格中， 对于出现空行和空列的情况， 先不去考虑。 那么怎样使得所有颜色都出现在方格中呢。

令$d[i]$表示恰好出现$i$种颜色的方案数， 这个显然直接求是不太好求的， 那么可以容斥一下， 令$g[i]$表示至多出现了$i$种颜色的方案数， 通过二项式反演可以得到， 

$d[n] = \sum_{i=1}^{n} (-1)^{n-i}C(n,j) * g[j]$ ；  
至于$g[j]$那就十分好求了， 

$g[j] = (j + 1) ^ {tot}$， $tot$表示格子数。

现在我们可以令$w[i][j]$为 $i*j$的方格中， 所有颜色均出现过， 可能存在空行与空列的方案数。这个通过上面的公式来求就好了。求得这个之后，相当于去掉了颜色的限制， 只有行和列的限制了。 

可以先去掉行的限制， 再去掉列的限制。令$p[i][j]$为每一行都有颜色的方案数， 容斥一下可以得到

$p[i][j] = w[i][j] - \sum_{k=1}^{i-1} p[k][j] * C(i, k)$

 这个其实也可以二项式反演一波， 不过不影响复杂度， O($n^2m$)算一下就好了。
 
 然后再来考虑列的限制，想必列的你已经会了， 和上面差不多， 康康代码就行， 
 我就不再赘述了。
 
 可能代码用的变量和上面有所不同， 不过应该还是挺明了的。
 ```cpp
#include<bits/stdc++.h>
#define mod 1000000007
#define reg register
#define maxn 405
using namespace std;
int n, m, c, fac[maxn], ifac[maxn], inv[maxn];
int g[maxn][maxn], d[maxn], p[maxn][maxn];
int ksm(int u, int v){
    int s = 1;
    for(int i = v; i; i >>= 1){
        if(i & 1) s = 1ll * s * u % mod;
        u = 1ll * u * u % mod;
    }
    return s;
}
int inc(int x, int y){
    return x + y >= mod ? x + y - mod : x + y;
}
int C(int x, int y){
    return 1ll * fac[x] * ifac[y] % mod * ifac[x - y] % mod;
}
int get(int x, int y, int digit){
    int ans = 0;
    for(int i = digit; i >= 0; i--){
        int hh = ksm(i + 1, x * y); 
        int x = 1ll * C(digit, i) * hh % mod;
        if(digit - i & 1) ans = inc(ans, mod - x);
        else ans = inc(ans, x);
    }
    return ans;
}
int main(){
    cin >> n >> m >> c;
    fac[0] = 1; ifac[0] = 1; inv[0] = 1;
    for(int i = 1; i < maxn; i++){
        fac[i] = 1ll * fac[i - 1] * i % mod;
        inv[i] = (i == 1) ? 1 : 1ll * inv[mod % i] * (mod - mod / i) % mod;
        ifac[i] = 1ll * ifac[i - 1] * inv[i] % mod;
    }
   for(int i = 1; i <= n; i++) 
        for(int j = 1; j <= m; j++)
            p[i][j] = get(i, j, c);
    for(int j = 1; j <= m; j++)
        for(int i = 1; i <= n; i++){
            g[i][j] = p[i][j];
            for(int k = 0; k < i; k++){
                int x = 1ll * C(i, k) * g[k][j] % mod;
                g[i][j] = inc(g[i][j], mod - x);
            }
        }
    for(int j = 1; j <= m; j++){
        d[j] = g[n][j];
        for(int k = 1; k < j; k++){
            int x = 1ll * C(j, k) * d[k] % mod;
            d[j] = inc(d[j], mod - x);
        }
    }
    cout << d[m] << endl;
}
```


---


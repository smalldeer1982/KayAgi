# [蓝桥杯 2020 国 B] 质数行者

## 题目背景

小蓝在玩一个叫质数行者的游戏。

## 题目描述

游戏在一个 $n \times m \times w$ 的立体方格图上进行, 从北到南依次标号为第 $1$ 行到 第 $n$ 行, 从西到东依次标号为第 $1$ 列到第 $m$ 列, 从下到上依次标号为第 $1$ 层到 第 $w$ 层。

小蓝要控制自己的角色从第 $1$ 行第 $1$ 列第 $1$ 层移动到第 $n$ 行第 $m$ 列第 $w$ 层。每一步, 他可以向东走质数格、向南走质数格或者向上走质数格。每走到 一个位置, 小蓝的角色要稍作停留。

在游戏中有两个陷阱, 分别为第 $r_{1}$ 行第 $c_{1}$ 列第 $h_{1}$ 层和第 $r_{2}$ 行第 $c_{2}$ 列第 $h_{2}$ 层。这两个陷阱的位置可以跨过, 但不能停留。也就是说, 小蓝不能控制角 色某一步正好走到陷阱上，但是某一步中间跨过了陷阱是允许的。

小蓝最近比较清闲, 因此他想用不同的走法来完成这个游戏。所谓两个走法不同, 是指小蓝稍作停留的位置集合不同。

请帮小蓝计算一下，他总共有多少种不同的走法。

提示：请注意内存限制, 如果你的程序运行时超过内存限制将不得分。

## 说明/提示

**【样例说明】**

用 $(r, c, h)$ 表示第 $r$ 行第 $c$ 列第 $h$ 层, 可能的走法有以下几种:

1. $(1,1,1)-(1,3,1)-(1,6,1)-(3,6,1)-(5,6,1)$ 。

2. $(1,1,1)-(1,3,1)-(3,3,1)-(3,6,1)-(5,6,1)$ 。

3. $(1,1,1)-(1,3,1)-(3,3,1)-(5,3,1)-(5,6,1)$ 。

4. $(1,1,1)-(3,1,1)-(3,3,1)-(3,6,1)-(5,6,1)$ 。

5. $(1,1,1)-(3,1,1)-(3,3,1)-(5,3,1)-(5,6,1)$ 。

6. $(1,1,1)-(3,1,1)-(5,1,1)-(5,3,1)-(5,6,1)$ 。

7. $(1,1,1)-(3,1,1)-(5,1,1)-(5,4,1)-(5,6,1)$ 。

8. $(1,1,1)-(1,4,1)-(1,6,1)-(3,6,1)-(5,6,1)$ 。

9. $(1,1,1)-(1,6,1)-(3,6,1)-(5,6,1)$ 。

10. $(1,1,1)-(3,1,1)-(3,6,1)-(5,6,1)$ 。

11. $(1,1,1)-(3,1,1)-(5,1,1)-(5,6,1)$ 。

**【评测用例规模与约定】**

对于 $30 \%$ 的评测用例 $1 \leq n, m, w \leq 50$ 。

对于 $60 \%$ 的评测用例 $1 \leq n, m, w \leq 300$ 。

对于所有评测用例, $1 \leq n, m, w \leq 1000,1 \leq r_{1}, r_{2} \leq n, 1 \leq c_{1}, c_{2} \leq m$, $1 \leq h_{1}, h_{2} \leq w$, 陷阱不在起点或终点, 两个陷阱不同。

蓝桥杯 2020 年国赛 B 组 J 题。

## 样例 #1

### 输入

```
5 6 1
3 4 1 1 2 1```

### 输出

```
11```

# 题解

## 作者：DerrickLo (赞：4)

定义 $path(x,y,z)$ 表示 从 $(0,0,0)$ 走到 $(x,y,z)$ 的方案数。

显然的经过容斥得到，若 $r1\le r2,c1\le c2,h1\le h2$，则 $ans=path(n,m,w)-path(r1,c1,h1)\times path(n-r1,m-c1,w-h1)-path(r2,c2,h2)\times path(n-r2,m-c2,w-h2)+path(r1,c1,h1)\times path(r2-r1,c2-c1,h2-h1)\times path(n-r2,m-c2,w-h2)$

若 $r1\ge r2,c1\ge c2,h1\ge h2$ 同理。

否则， $ans=path(n,m,w)-path(r1,c1,h1)\times path(n-r1,m-c1,w-h1)-path(r2,c2,h2)\times path(n-r2,m-c2,w-h2)$

那我们可以定义 $f(x,a)$ 表示用 $a$ 个质数走到 $x$ 的方案数，集合 $P$ 表示全体素数。

那我们就可以得到 $f(x,a)=\displaystyle{\sum_{b\in P,b\le x}f(x-b,a-1)}$。

则 $\space path(x,y,z)$

$\begin{aligned}
&=\displaystyle{\sum_{i\le x,j\le y,k\le z}C_{i+j+k}^i\times C_{j+k}^{j}\times f(x,i)\times f(y,j) \times f(z,k)}\\
&=\displaystyle{\sum_{i\le x,j\le y,k\le z}\frac{(i+j+k)!}{i!\times(j+k)!}\times\frac{(j+k)!}{j!\times k!}\times f(x,i)\times f(y,j) \times f(z,k)}\\
&=\displaystyle{\sum_{i\le x,j\le y,k\le z}(i+j+k)!\space\times\frac{f(x,i)}{i!}\times\frac{f(y,j)}{j!}\times\frac{f(z,k)}{k!}}\\
&=\displaystyle{\sum_{l\le x+y,i+j=l}\frac{f(x,i)}{i!}\times\frac{f(y,j)}{j!}\space\sum_{k\le z}(l+k)!\space\times \frac{f(z,k)}{k!}}
\end{aligned}$

复杂度为 $O(n^2)$。

```cpp
#include<bits/stdc++.h>
#define int long long
#define mod 1000000007
using namespace std;
int n,m,w,r1,r2,c1,c2,h1,h2,prime[]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997,10000};
int f[1005][1005],C[3005][3005],fac[3005],inv[3005];
int path(int x,int y,int z){
	int ans=0;
	for(int l=0;l<=x+y;l++){
		int aa=0,bb=0;
		for(int i=0;i<=l;i++)if(i<=x&&l-i<=y){
			aa+=f[x][i]*inv[i]%mod*f[y][l-i]%mod*inv[l-i]%mod;
		}
		for(int k=0;k<=z;k++)bb+=fac[l+k]*f[z][k]%mod*inv[k]%mod;
		aa%=mod,bb%=mod;
		ans+=aa*bb%mod;
	}
	return ans%mod;
}
int ksm(int x,int y){
	int res=1;
	while(y){
		if(y&1)res=res*x%mod;
		x=x*x%mod;
		y>>=1; 
	}
	return res;
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	f[0][0]=1;
	for(int i=1;i<=1000;i++)for(int j=1;j<=i/2;j++){
		for(int k=0;;k++){
			if(prime[k]>i)break;
			f[i][j]+=f[i-prime[k]][j-1];
			f[i][j]%=mod;
		}
	} 
	fac[0]=1;
	for(int i=1;i<=3000;i++)fac[i]=fac[i-1]*i%mod;
	inv[3000]=ksm(fac[3000],mod-2);
	for(int i=2999;~i;i--)inv[i]=inv[i+1]*(i+1)%mod; 
	cin>>n>>m>>w>>r1>>c1>>h1>>r2>>c2>>h2;
	n--,m--,w--,r1--,c1--,h1--,r2--,c2--,h2--;
	if(r1>=r2&&c1>=c2&&h1>=h2){
		swap(r1,r2);
		swap(c1,c2);
		swap(h1,h2);
	}
	if(r1<=r2&&c1<=c2&&h1<=h2){
		int ans=(path(n,m,w)-path(r1,c1,h1)*path(n-r1,m-c1,w-h1)%mod-path(r2,c2,h2)*path(n-r2,m-c2,w-h2)%mod+path(r1,c1,h1)*path(r2-r1,c2-c1,h2-h1)%mod*path(n-r2,m-c2,w-h2)%mod+3ll*mod)%mod;
		cout<<ans;
		return 0;
	}
	int ans=(path(n,m,w)-path(r1,c1,h1)*path(n-r1,m-c1,w-h1)%mod-path(r2,c2,h2)*path(n-r2,m-c2,w-h2)%mod+3ll*mod)%mod;
	cout<<ans;
	return 0;
}
```

---

## 作者：meyi (赞：4)

首先发现这道题和 [P5376 [THUPC2019] 过河卒二](https://www.luogu.com.cn/problem/P5376) 差不多，都是要求不经过一些障碍点从定点到达另一个定点的方案数，区别是这题维数高一点，只有两个障碍点，且两题走法不一样。

但是并不影响我们使用容斥原理，显然不妨设起点为 $s(1,1,1)$，终点为 $t(n,m,w)$，障碍点 $u(r_1,c_1,h_1),v(r_2,c_2,h_2)$，点 $a(x_1,y_1,z_1)$ 走到点 $b(x_2,y_2,z_2)$ 的方案数为 $f_{a,b}$，那么答案即为 $f_{s,t}-f_{s,u}\times f_{u,t}-f_{s,v}\times f_{v,t}+f_{s,u}\times f_{u,v}\times f_{v,t}+f_{s,v}\times f_{v,u}\times f_{u,t}$。

进一步的，我们并不关心实际起点和终点在哪里，只关心他们的相对位置，也即 $f_{a,b}=g_{x_2-x_1,y_2-y_1,z_2-z_1}$，因此只需求出 $g$ 即可。

更进一步的，容易发现每次行动只会修改一维的值，也即三个维度互不影响，我们只关心操作顺序和三个维度各自的操作次数，不妨设 $h_{i,j}$ 表示只考虑一个维度时走到 $i$ 操作了 $j$ 次的方案数，则有 

$$g_{x,y,z}=\sum\limits_{i=1}^x \sum\limits_{j=1}^y \sum\limits_{k=1}^z \binom{i+j+k}{i}\binom{j+k}{j}h_{x,i}h_{y,j}h_{z,k}$$

$$=\sum\limits_{i=1}^x \sum\limits_{j=1}^y \sum\limits_{k=1}^z \frac{(i+j+k)!}{i!(j+k)!}\frac{(j+k)!}{j!k!}h_{x,i}h_{y,j}h_{z,k}$$

$$=\sum\limits_{i=1}^x \sum\limits_{j=1}^y \sum\limits_{k=1}^z (i+j+k)!\frac{h_{x,i}}{i!}\frac{h_{y,j}}{j!}\frac{h_{z,k}}{k!}$$

$$=\sum\limits_{i+j=1}^{x+y} \frac{h_{x,i}}{i!}\frac{h_{y,j}}{j!}\sum\limits_{k=1}^z (l+k)!\frac{h_{z,k}}{k!}$$

上面这个东西和 $h$ 都能在 $O(n^2)$ 时间复杂度内预处理出来，故总时间复杂度 $O(n^2)$。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
//#pragma GCC optimize("Ofast,no-stack-protector,unroll-loops")
#define ALL(v) v.begin(),v.end()
#define For(i,_) for(int i=0,i##end=_;i<i##end;++i) // [0,_)
#define FOR(i,_,__) for(int i=_,i##end=__;i<i##end;++i) // [_,__)
#define Rep(i,_) for(int i=(_)-1;i>=0;--i) // [0,_)
#define REP(i,_,__) for(int i=(__)-1,i##end=_;i>=i##end;--i) // [_,__)
typedef long long ll;
typedef unsigned long long ull;
#define V vector
#define pb push_back
#define pf push_front
#define qb pop_back
#define qf pop_front
#define eb emplace_back
typedef pair<int,int> pii;
typedef pair<ll,int> pli;
#define fi first
#define se second
const int dir[4][2]={{-1,0},{0,1},{1,0},{0,-1}},inf=0x3f3f3f3f,mod=1e9+7;
const ll infl=0x3f3f3f3f3f3f3f3fll;
template<class T>inline bool ckmin(T &x,const T &y){return x>y?x=y,1:0;}
template<class T>inline bool ckmax(T &x,const T &y){return x<y?x=y,1:0;}
int init=[](){return cin.tie(nullptr)->sync_with_stdio(false),0;}();
struct modint{
	int val;
	inline modint(int val_=0):val(val_){}
	inline modint &operator=(int val_){return val=val_,*this;}
	inline modint &operator+=(const modint &k){return val=val+k.val>=mod?val+k.val-mod:val+k.val,*this;}
	inline modint &operator-=(const modint &k){return val=val-k.val<0?val-k.val+mod:val-k.val,*this;}
    inline modint &operator*=(const modint &k){return val=1ll*val*k.val%mod,*this;}
    inline modint &operator^=(int k){
        modint ret=1,tmp=*this;
        for(;k;k>>=1,tmp*=tmp)if(k&1)ret*=tmp;
        return val=ret.val,*this;
    }
    inline modint &operator/=(modint k){return *this*=(k^=mod-2);}
    inline modint &operator+=(int k){return val=val+k>=mod?val+k-mod:val+k,*this;}
    inline modint &operator-=(int k){return val=val<k?val-k+mod:val-k,*this;}
    inline modint &operator*=(int k){return val=1ll*val*k%mod,*this;}
    inline modint &operator/=(int k){return *this*=((modint(k))^=mod-2);}
    template<class T>friend modint operator+(modint a,T b){return a+=b;}
    template<class T>friend modint operator-(modint a,T b){return a-=b;}
    template<class T>friend modint operator*(modint a,T b){return a*=b;}
    template<class T>friend modint operator/(modint a,T b){return a/=b;}
    friend modint operator^(modint a,int b){return a^=b;}
    friend bool operator==(modint a,int b){return a.val==b;}
    friend bool operator!=(modint a,int b){return a.val!=b;}
    inline bool operator!(){return !val;}
    inline modint operator-(){return val?mod-val:0;}
    inline modint operator++(int){modint tmp=*this;*this+=1;return tmp;}
    inline modint &operator++(){return *this+=1;}
    inline modint operator--(int){modint tmp=*this;*this-=1;return tmp;}
    inline modint &operator--(){return *this-=1;}
};
using mi=modint;
int main(){
	int m,n,w;
	scanf("%d%d%d",&n,&m,&w),--n,--m,--w;
	int mx=max({n,m,w});
	V<bool>a(mx+1);
	a[0]=a[1]=true;
	V<int>pri;
	FOR(i,2,mx+1)if(!a[i]){
		pri.pb(i);
		for(int j=i<<1;j<=mx;j+=i)a[j]=true;
	}
	V<V<mi>>f(mx+1);
	For(i,mx+1)f[i].resize((i>>1)+1);
	f[0][0]=1;
	For(i,mx-1)For(j,f[i].size())if(f[i][j].val)for(int k:pri){
		if(i+k>mx)break;
		f[i+k][j+1]+=f[i][j];
	}
	mx=(n>>1)+(m>>1)+(w>>1);
	V<mi>fac(mx+1);
	fac[0]=1;
	For(i,mx)fac[i+1]=fac[i]*(i+1);
	V<mi>ifac(mx+1);
	ifac[mx]=1/fac[mx];
	Rep(i,mx)ifac[i]=ifac[i+1]*(i+1);
	auto calc=[&](int x,int y,int z){
		V<mi>g(f[x].size()+f[y].size()-1);
		For(i,f[x].size()){
			mi tmp=f[x][i]*ifac[i];
			For(j,f[y].size())g[i+j]+=tmp*f[y][j]*ifac[j];
		}
		mi ret=0;
		For(k,f[z].size()){
			mi sum=0;
			For(l,g.size())sum+=fac[k+l]*g[l];
			ret+=sum*f[z][k]*ifac[k];
		}
		return ret;
	};
	int c1,c2,h1,h2,r1,r2;
	scanf("%d%d%d%d%d%d",&r1,&c1,&h1,&r2,&c2,&h2),--r1,--c1,--h1,--r2,--c2,--h2;
	mi ans=calc(n,m,w)-calc(r1,c1,h1)*calc(n-r1,m-c1,w-h1)-calc(r2,c2,h2)*calc(n-r2,m-c2,w-h2);
	if(r1<=r2&&c1<=c2&&h1<=h2)ans+=calc(r1,c1,h1)*calc(r2-r1,c2-c1,h2-h1)*calc(n-r2,m-c2,w-h2);
	if(r2<=r1&&c2<=c1&&h2<=h1)ans+=calc(r2,c2,h2)*calc(r1-r2,c1-c2,h1-h2)*calc(n-r1,m-c1,w-h1);
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：HD0X (赞：3)

题意略。

首先有一个最朴素的想法，设 $f_{i,j,k}$ 表示走到该点方案数，再在提前筛出来的质数中枚举一下走的步数，特判一下陷阱点即可。时间复杂度 $O(n^3 \times cnt)$，其中 $cnt$ 为质数个数 $(cnt \le 168)$。

容易发现对于一种方案，三个维度是独立的。所以设 $f_{i,j}$ 表示选 $j$ 个质数（有序），走的距离为 $i$ 的方案数，容易做到 $O(n^2 \times cnt)$。然后走到 $(n,m,w)$ 的方案数即是：

$$
\sum_{i=0}^{n} \sum_{j=0}^{m} \sum_{k=0}^{w} f_{n-1,i} \times f_{m-1,j} \times f_{w-1,k} \times C_{i+j+k}^{i} \times C_{j+k}^{j}
$$

其中 $i,j,k$ 分别表示在三个维度上走的步数，减一是因为初始在 $(1,1,1)$。

再简单容斥一下，就是减去过一个陷阱点再到终点，如果可能的话再加上同时经过两个陷阱点再到终点的方案数。复杂度为 $O(n^3)$，瓶颈在于计算答案。

考虑展开组合式，即是：
$$
\frac{(i+j+k)! (j+k)!}{i! j! k! (j+k)!}\\
$$
也就是：
$$
\frac{(i+j+k)!}{i! j! k!}
$$
把 $i,j$ 剥离出来，即是：
$$
\frac{(i+j)!}{i! j!} \times \frac{A_{i+j+k}^{k}}{k!}
$$
原式可化为：
$$
\sum_{i=0}^{n} \sum_{j=0}^{m} \frac{(i+j)!}{i! j!} \times f_{n-1,i} \times f_{m-1,j} \sum_{k=0}^{w}  f_{w-1,k} \times \frac{A_{i+j+k}^{k}}{k!}
$$
发现后面的式子只和 $i+j$ 有关。所以可以预处理后面的式子，只枚举 $i+j$ 和 $k$。

设 $pre_{c}$ 表示 $\sum_{k=0}^{w}  f_{w-1,k} \times \frac{A_{c+k}^{k}}{k!}$，可以 $n^2$ 处理，就做完了。

总结一下，先筛出质数，再预处理阶乘逆元和 $f$ 数组。然后在容斥时每一次去 solve 一下，具体见代码。时间复杂度为 $O(n^2 \times cnt)$，瓶颈在于预处理 $f$，最慢的点不超过100ms。

小细节，枚举很多东西时都可以除以二~~因为最小质数为2~~。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN=1010,mod=1e9+7;
int n,m,w,fac[1510],inv[1510];
int f[MAXN][510],r1,c1,h1,r2,c2,h2;
int pri[200],cnt,pre[MAXN];
bool vis[MAXN];
int qkp(int x,int y)
{
	int res=1;
	while(y)
	{
		if(y&1) res=1ll*res*x%mod;
		x=1ll*x*x%mod;
		y/=2;
	}
	return res;
}
int A(int x,int y)
{
	return 1ll*fac[y]*inv[y-x]%mod;
}
void init()
{
	int l=max(n,max(m,w)),r=m+n+w;
	for(int i=2;i<=l;i++)
	{
		if(!vis[i])
		{
			pri[++cnt]=i;
			for(int j=i;j<=l;j+=i)
			{
				vis[j]=1;
			}
		}
	}
	f[0][0]=1;
	for(int i=1;i<=l/2;i++)
	{
		for(int j=1;j<=cnt;j++)
		{
			for(int k=pri[j];k<=l;k++)
			{
				(f[k][i]+=f[k-pri[j]][i-1])%=mod;
			}
		}
	}
	fac[0]=1;
	for(int i=1;i<=r/2;i++) fac[i]=1ll*fac[i-1]*i%mod;
	inv[r/2]=qkp(fac[r/2],mod-2);
	for(int i=r/2-1;i>=0;i--) inv[i]=1ll*inv[i+1]*(i+1)%mod;
}
int solve(int n,int m,int w)
{
	int ans=0;
	if(!w) for(int c=0;c<=n/2+m/2;c++) pre[c]=1;
	else
	{
		for(int c=0;c<=n/2+m/2;c++)
		{
			pre[c]=0;
			for(int i=0;i<=w/2;i++)
			{
				pre[c]=(pre[c]+1ll*f[w][i]*A(i,c+i)%mod*inv[i]%mod)%mod;
			}
		}
	}
	for(int i=0;i<=n/2;i++)
	{
		for(int j=0;j<=m/2;j++)
		{
			ans=(ans+1ll*f[n][i]*f[m][j]%mod*fac[i+j]%mod*inv[i]%mod*inv[j]%mod*pre[i+j]%mod)%mod;
		}
	}
	return ans;
}
signed main()
{
	cin>>n>>m>>w;
    init();
	cin>>r1>>c1>>h1>>r2>>c2>>h2;
	--n,--m,--w,--r1,--r2,--c1,--c2,--h1,--h2;//坐标转距离
	int ans=((solve(n,m,w)-1ll*solve(n-r1,m-c1,w-h1)*solve(r1,c1,h1)%mod-1ll*solve(n-r2,m-c2,w-h2)*solve(r2,c2,h2)%mod)%mod+mod)%mod;
	if(r1<=r2 && c1<=c2 && h1<=h2)
	{
		(ans+=1ll*solve(r1,c1,h1)*solve(r2-r1,c2-c1,h2-h1)%mod*solve(n-r2,m-c2,w-h2)%mod)%=mod;
	}
	else if(r1>=r2 && c1>=c2 && h1>=h2)
	{
		(ans+=1ll*solve(r2,c2,h2)*solve(r1-r2,c1-c2,h1-h2)%mod*solve(n-r1,m-c1,w-h1)%mod)%=mod;
	}//若大小关系相同才有可能
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：hsiviter (赞：1)

## 题意

从 $(1,1,1)$ 出发，一次只能走质数格且不经过 $(r_1.c_1.h_1)$ 和 $(r_2,c_2,h_2)$，求到达 $(n,m,w)$ 的方案数，答案对 $1000000007$（即 $10^9+7$）取模。

## 思路

看到题目限制不能经过给定的两个点，自然想到容斥，我们记 $f(A,B)$ 为从 $A(x_1,y_1,z_1)$ 到达 $B(x_2,y_2,z_2)$ 的方案数 $(x_1 \le x_2,y_1 \le y_2,z_1 \le z_2)$，记 $S(1,1,1)$, $P_1(r_1,c_1,h_1)$, $P_2(r_2,c_2,h_2)$, $T(n,m,w)$，那么有：

$$ ans=f(S,T)-f(S,P_1) \times f(P_1,T)-f(S,P_2) \times f(P_2,T)-f(S,P_1) \times f(P_1,P_2) \times f(P_2,T) $$

下面考虑 $f(A,B)$ 如何计算。

只能走质数格的条件比较麻烦，我们先来考虑没有这一条件如何求解。

类似于二维的情况，记 $x=x_2-x_1$, $y=y_2-y_1$, $z=z_2-z_1$ ,那么有

$$ f(A,B) = C_{x+y+z}^z C_{x+y}^y $$

其意义为：一共走 $x+y+z$ 步，需要向上走 $z$ 步，方案数为 $C_{x+y+z}^z$；需要向东走 $y$ 步，由于向上已经考虑过了，所以方案数为 $C_{x+y}^y$，需要向南走 $x$ 步，由于向上和向东已经考虑过了，所以方案数为 $C_x^x=1$.

现在回到走质数格的限制，观察上面的式子，可以发现我们不关心走的步伐（即走一次的长度），而是次数（即这一段多少次走完） ，也即是说我们要求出**某一段长用一些次数走完**的方案数。

所以记 $g[len][cnt]$ 表示使用 $cnt$ 个质数走 $len$ 的长度的方案数，则有

$$ g[len][cnt] = \sum_{p \in Prime}^{p \le len} g[len-p][cnt-1] $$

初态： $g[0][0]=1$。

依据此，我们得到：

$$ f(A,B) = \sum_{i=0}^{\lfloor \frac{x}{2}\rfloor} \sum_{j=0}^{\lfloor \frac{y}{2}\rfloor} \sum_{k=0}^{\lfloor \frac{z}{2}\rfloor} C_{i+j+k}^kC_{i+j}^j \times g[x][i] \times g[y][j] \times g[z][k] $$

时间复杂度 $O(nmw)$，可以得到 $60pts$。

继续优化，发现瓶颈主要在枚举 $i,j,k$ 上，如果可以在枚举 $i$ 的时候直接计算 $j$ 多好。

当然可以，记 $sum=i+j$，则有

$$\begin{aligned}
    f(A,B)  &= \sum_{i=0}^{\lfloor \frac{x}{2}\rfloor} \sum_{j=0}^{\lfloor \frac{y}{2}\rfloor} \sum_{k=0}^{\lfloor \frac{z}{2}\rfloor} \frac{(i+j+k)!}{i! \times j! \times k!} \times g[x][i] \times g[y][j] \times g[z][k] 
    \\
            &= \sum_{i=0}^{\lfloor \frac{x}{2}\rfloor} \sum_{j=0}^{\lfloor \frac{y}{2}\rfloor} \sum_{k=0}^{\lfloor \frac{z}{2}\rfloor} (i+j+k)! \times \frac{g[x][i]}{i!} \times \frac{g[y][j]}{j!} \times \frac{g[z][k]}{k!} 
    \\
            &= \sum_{sum=0}^{sum \le \lfloor \frac{x}{2}\rfloor + \lfloor \frac{y}{2}\rfloor} \sum_{i=0}^{sum} \frac{g[x][i]}{i!} \times \frac{g[y][sum-i]}{(sum-i)!} \sum_{k=0}^{\lfloor \frac{z}{2}\rfloor} (sum+k)! \times \frac{g[z][k]}{k!}  
\end{aligned}$$

时间复杂度 $O(n(m+w))$，可以得到 $100pts$。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define ull unsigned long long
const int N=3e3+10;
const int mod=1e9+7;
int pr[]={0,
2,3,5,7,11,13,17,19,23,29,
31,37,41,43,47,53,59,61,67,71,
73,79,83,89,97,101,103,107,109,113,
127,131,137,139,149,151,157,163,167,173,
179,181,191,193,197,199,211,223,227,229,
233,239,241,251,257,263,269,271,277,281,
283,293,307,311,313,317,331,337,347,349,
353,359,367,373,379,383,389,397,401,409,
419,421,431,433,439,443,449,457,461,463,
467,479,487,491,499,503,509,521,523,541,
547,557,563,569,571,577,587,593,599,601,
607,613,617,619,631,641,643,647,653,659,
661,673,677,683,691,701,709,719,727,733,
739,743,751,757,761,769,773,787,797,809,
811,821,823,827,829,839,853,857,859,863,
877,881,883,887,907,911,919,929,937,941,
947,953,967,971,977,983,991,997,
},cnt=168;// 1000 以内的质数
ll g[N][N],M;
ll fac[N],invfac[N];
struct rec{
    int x,y,z;
}s,p1,p2,t;
ll expow(ll a,ll b){
    ll res=1;
    while(b){
        if(b&1) res=res*a%mod;
        b>>=1;a=a*a%mod;
    }
    return res;
}
void init(int n){
    // 预处理 g
    g[0][0]=1;
    for(int i=1;i<=n;i++){// 距离
        for(int j=1;j<=i/2;j++){// 个数
            for(int k=1;k<=cnt&&pr[k]<=i;k++){// 每个质数
                g[i][j]=(g[i][j]+g[i-pr[k]][j-1])%mod;
            }
        }
    }
    // 预处理阶乘
    n*=3;// i+j+k<3000
    fac[0]=1;
    for(int i=1;i<=n;i++) fac[i]=fac[i-1]*i%mod;
    invfac[n]=expow(fac[n],mod-2);
    for(int i=n-1;i>=0;i--) invfac[i]=invfac[i+1]*(i+1)%mod;
}
ll f(rec a,rec b){
    ll res=0;
    int x=b.x-a.x,y=b.y-a.y,z=b.z-a.z;
    if(x<0||y<0||z<0) return res;// 空集
    for(int sum=0;sum<=x/2+y/2;sum++){
        ll ans1=0;
        for(int i=0;i<=sum;i++){
            int j=sum-i;
            if(i<=x/2&&j<=y/2)
                ans1=(ans1+(g[x][i]*invfac[i]%mod)*(g[y][j]*invfac[j]%mod))%mod;
        }
        ll ans2=0; 
        for(int k=0;k<=z/2;k++) ans2=(ans2+g[z][k]*invfac[k]%mod*fac[sum+k])%mod;
        res=(res+ans1*ans2)%mod;
    }
    return res;
}
int n,m,w;
int r1,c1,h1;
int r2,c2,h2;
int main(){
    scanf("%d %d %d",&n,&m,&w);
    scanf("%d %d %d",&r1,&c1,&h1);
    scanf("%d %d %d",&r2,&c2,&h2);
    s={1,1,1};
    p1={r1,c1,h1};
    p2={r2,c2,h2};
    t={n,m,w};
    init(max(max(n,m),w));
    if(r2<=r1&&c2<=c1&&h2<=h1) swap(p1,p2);
    ll ans1=f(s,t);
    ll ans2=f(s,p1)*f(p1,t)%mod;
    ll ans3=f(s,p2)*f(p2,t)%mod;
    ll ans4=sf(s,p1)*f(p1,p2)%mod*f(p2,t)%mod;
    printf("%lld\n",((ans1-ans2-ans3+ans4)%mod+mod)%mod);// 容斥
    return 0;
}
```

---

## 作者：Yorg (赞：1)

# 思路

首先考虑暴力 dp 。

显然，我们可以暴力做 dp，大概是 $\mathcal{O}(n^3 \omega)$，其中 $\omega$ 是质数的个数。

考虑优化。

你注意到只有两个障碍点，这个好像很重要。  
考虑「容斥原理」，正难则反，记 $a \to b$ 的方案数为 $f_{a, b}$，设起点和终点分别为 $s, t$，两个特殊点分别为 $u, v$：

$$
ans = f_{s, t} - \left[
    f_{s, u} \times f_{u, t} + f_{s, v} \times f_{v, t} -
    \left(
        f_{s, u} \times f_{u, v} \times f_{v, t} + f_{s, v} \times f_{v, u} \times f_{u, t}
    \right)
\right]
$$

然后考虑如何求解 $f$，发现这相当于走一个矩阵，从左下到右上。

---

因为直接 dp 肯定不优，考虑组合数学计算。

首先我们发现，这个问题很像之前的经典问题，在之前的问题中：

$$
ans = \binom{x + y + z}{x} \binom{y + z}{y}
$$

即在 $x + y + z$ 次操作中，挑选 $x$ 次作为横向移动，然后再剩下的 $y + z$ 次操作中挑选 $y$ 次作为纵向移动，剩下的就不用计算组合数了。

但是在这个问题中，要要求每次走的长度为质数，应该怎么处理呢？

还是考虑操作次数中的组合数，考虑预处理出 $g_{i, j}$，表示使用 $i$ 个质数走 $j$ 长度的方案数，这个可以在 $\mathcal{O}(n^2 \omega)$ 时间内预处理。

先考虑 $g$ 的转移：

$$
g_{0, 0} = 1 \\
g_{i, j} = \sum_{p = 1}^{cnt} \left[ pri_p \leq j \right] \times g_{i - 1, j - pri_p}
$$

考虑：

$$ 
f(x, y, z) =
\sum_{i = 1}^{\lfloor \frac{x}{2} \rfloor}\sum_{j = 1}^{\lfloor \frac{y}{2} \rfloor}\sum_{k = 1}^{\lfloor \frac{z}{2} \rfloor}
\binom{i + j + k}{i} \binom{j + k}{j} g_{i, x} \cdot g_{j, y} \cdot g_{k, z}
$$

这个时间复杂度是 $\mathcal{O}(n^3)$，这比直接 `dp` 只快一个 $\omega$，还需要优化。

这个多半只能对柿子进行优化，考虑减少 $\sum$ 的个数。

拆解：

$$
\begin{aligned}
f(x, y, z)
& = \sum_{i = 1}^{\lfloor \frac{x}{2} \rfloor} \sum_{j = 1}^{\lfloor \frac{y}{2} \rfloor} \sum_{k = 1}^{\lfloor \frac{z}{2} \rfloor}
\binom{i + j + k}{i} \binom{j + k}{j} g_{i, x} \cdot g_{j, y} \cdot g_{k, z} \\
& = \sum_{i = 1}^{\lfloor \frac{x}{2} \rfloor} \sum_{j = 1}^{\lfloor \frac{y}{2} \rfloor} \sum_{k = 1}^{\lfloor \frac{z}{2} \rfloor}
\frac{(i + j + k)!}{i!(j + k)!} \frac{(j + k)!}{j!k!} g_{i, x} \cdot g_{j, y} \cdot g_{k, z} \\
& = \sum_{i = 1}^{\lfloor \frac{x}{2} \rfloor} \sum_{j = 1}^{\lfloor \frac{y}{2} \rfloor} \sum_{k = 1}^{\lfloor \frac{z}{2} \rfloor}
\frac{(i + j + k)!}{i!j!k!} g_{i, x} \cdot g_{j, y} \cdot g_{k, z} \\
& = \sum_{sum=0}^{\lfloor \frac{x}{2} \rfloor + \lfloor \frac{y}{2} \rfloor} \sum_{i=0}^{sum} \frac{g_{i, x}}{i!} \times \frac{g_{sum - i, y}}{(sum-i)!} \sum_{k=0}^{\lfloor \frac{z}{2} \rfloor} (sum+k)! \times \frac{g_{k, z}}{k!}
\end{aligned}
$$

你注意到，这个可以通过预处理来做到 $\mathcal{O}(n^2)$，最终的时间复杂度是 $\mathcal{O}(n^2 \omega) - \mathcal{O}(n^2)$。

具体的，预处理 $\displaystyle h_{sum} = \sum_{k=0}^{\lfloor \frac{z}{2} \rfloor} (sum+k)! \times \frac{g_{k, z}}{k!}$。

$$
\begin{aligned}
f(x, y, z)
& = \sum_{sum=0}^{\lfloor \frac{x}{2} \rfloor + \lfloor \frac{y}{2} \rfloor} \sum_{i=0}^{sum} \frac{g_{i, x}}{i!} \times \frac{g_{sum - i, y}}{(sum-i)!} h_{sum}
\end{aligned}
$$

# 实现

## 框架
首先处理 $g$，然后根据下面的公式来处理 $f_{a, b}$，带进去计算即可：

$$
\sum_{sum=0}^{\lfloor \frac{x}{2} \rfloor + \lfloor \frac{y}{2} \rfloor} \sum_{i=0}^{sum} \frac{g_{i, x}}{i!} \times \frac{g_{sum - i, y}}{(sum-i)!} \sum_{k=0}^{\lfloor \frac{z}{2} \rfloor} (sum+k)! \times \frac{g_{k, z}}{k!}
$$

常见的错误：
枚举 $sum, i$ 时，需要确保 $j$ 在正确的范围内。

## 代码
[传送门](https://www.luogu.com.cn/paste/n4ct652k)。

# 总结

容斥原理计算非法方案数。  
【数据删除】，见了这么多次还是想不到，纯【数据删除】。

同类型问题，往往可以通过预处理转化为组合数学问题。  
拆柿子有时候会有用，做不到就试试看。  
这个题其实是把 dp 转化为组合数学，通过移动式子去掉了 $j + k$，把一些求和部分提取出来，一般提出 $i + j$ 可以解决这样的问题。

---


# ZHY 的表示法

## 题目描述

ZHY 称一个正整数 $x$ 是**可被表示的**，当且仅当存在一个实数 $y$，满足 $\lfloor \frac y {x_1} \rfloor+\lfloor \frac y {x_2} \rfloor+\cdots + \lfloor \frac y {x_n} \rfloor=x$。现在，ZHY 想知道区间 $[l,r]$ 中有多少个正整数是可被表示的。

## 说明/提示

**样例解释**

当 $x=5$ 时，取 $y=6$ 成立。  
当 $x=6$ 时，取 $y=8$ 成立。  
当 $x=7$ 时，取 $y=9$ 成立。  
当 $x=8$ 时，取 $y=10$ 成立。  
当 $x=10$ 时，取 $y=12$ 成立。  

故 $5,6,7,8,10$ 是可被表示的，可以证明，对于任意实数 $y$，$\lfloor \frac y {2} \rfloor+\lfloor \frac y {3} \rfloor\ne 9$。故答案为 $5$。

----

**数据范围**

对于 $30\%$ 的数据，$l \le r \le 10^5$。

对于另外 $10\%$ 的数据，$n=1$。

对于 $100\%$ 的数据，$1\le n \le 25$，$1 \le l \le r \le 10^9$，$1 \le x_1,x_2,\cdots,x_n \le 10^9$。

## 样例 #1

### 输入

```
2 5 10
2 3```

### 输出

```
5```

# 题解

## 作者：smqa (赞：10)

[题目](https://www.luogu.com.cn/problem/P9489)

首先发现是求 $[l,r]$ 之间的答案，所以我们前缀和一下，输出 $ans_r-ans_{l-1}$ 即可。

因为最终要向下取整，容易发现 $y$ 是正数还是实数没有什么区别，由此知道如果 $y$ 能被表示，那一定是由 $x_i$ 的倍数凑出来的。

假设我们要求 $ans_p$，应二分得到最大的 $q_{max}$ 满足
$$
\lfloor \frac {q_{max}} {x_1} \rfloor+\lfloor \frac {q_{max}} {x_2} \rfloor+\cdots + \lfloor \frac {q_{max}} {x_n} \rfloor \le p
$$
由此，$[1,p]$ 中的每一个可以被表示的数都可以被 $[1,q_{max}](q∈N_+)$ 中的数表示。

------------

由于 $[1,q](q∈N_+)$ 中的数可能会表示出重复的数，所以我们进行容斥：


设两个不同的数 $q_1,q_2 (q_1 \lt q_2)$ 表示出了相同的数。

在随意两个不同的数的限制下（即 $q_1,q_2 (q_1 \lt q_2)$ 表示出的数字可以不同时），对于 $\forall i∈[1,n]$ 来说，$\lfloor \frac {q_1}  {x_i} \rfloor \le \lfloor \frac {q_2} {x_i} \rfloor$。


而为了使它相同，我们要求对于 $\forall i∈[1,n]$ 来说，$\lfloor \frac {q_1}  {x_i} \rfloor = \lfloor \frac {q_2} {x_i} \rfloor$。

此时会发现假设有一个 $q$ 且对于 $\forall i∈[1,n]$ 来说，$x_i \nmid q$，则这个 $q$ 没有意义，因为一定有另一个数 $q_{new}$ 保证 $\exist i∈[1,n] \ x_i | q_{new}$，且与 $q$ 表示出一样的数。

原因：下取整后剩下的数一定是 $x_i$ 的倍数，所以分子上的数只需要是 $x_i$ 的倍数即可。

此时将问题转换成 $[1,q_{max}]$ 中 $x_i$ 的倍数有多少。

首先是容斥的基本式子：
$$
|\bigcup_{i=1}^nA_i|=\sum_{i=1}^n|A_i|-\sum_{i,j: \ 1 \le i \lt j \le n}|A_i \cap A_j|+\sum_{i,j,k: \ 1 \le i \lt j \lt k\le n}|A_i \cap A_j \cap A_k|- \cdots +(-1)^{n-1}|A_1 \cap \cdots \cap A_n|
$$
这个式子可以进行化简，假设 $B$ 表示含有所有 $A_i$ 的集合，则式子变为：
$$
|\bigcup_{i=1}^nA_i|=\sum_{C \subseteq B} (-1)^{|C|-1} |\bigcap_{e∈C} e|
$$

综上，本题的式子也就呼之欲出。

设 $K$ 表示所有 $x_i$ 表示的集合，答案如下。
$$
\sum_{s\subseteq K}(-1)^{|K|-1} \lfloor \frac {q_{max}} {lcm \ s} \rfloor
$$

代码不放了。

------------

题外话：

yzr 和 zhy！仙品！金婚！纯爱！爽！

（为了说题外话我写了一整篇题解，管理员大大求过）

---

## 作者：喵仔牛奶 (赞：7)

# Solution

- 可以表示出的取值一定能被为某个 $x_i$ 的倍数的 $y$ 表示出。
- 根据上面的结论，一个为 $x_i$ 倍数的 $y$ 与一个被表示出的值**一一对应**。
- 故统计 $y$ 的个数即可。二分出最大的合法取值，然后容斥。
- 时间复杂度 $\mathcal{O}(2^n+\log l)$。

证明：
- 一个不为倍数的 $y$ 可以一直 $-1$ 直至为倍数。这期间不会改变式子取值。
- 不同的为倍数的 $y$ 式子取值不同，所以唯一对应。
 
Upd：
- 2023.8.11 被 Hack 了，已改正。

# Code
```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
using namespace std;
namespace Milkcat {
	typedef __int128 LL;
	typedef pair<LL, LL> pii;
	const int N = 1e6 + 5;
	int n, l, r, a[N];
	LL lcm(LL x, LL y) { return x * y / __gcd(x, y); }
	LL dfs(LL dep, LL sum, LL lmt, LL cof, LL cnt) {
		if (sum > lmt) return 0;
		if (dep > n) return (cnt >= 1) * lmt / sum * cof;
		return dfs(dep + 1, sum, lmt, cof, cnt) + dfs(dep + 1, lcm(sum, a[dep]), lmt, -cof, cnt + 1);
	}
	LL solve(int m) {
		LL l = 1, r = 1e18;
		while (l <= r) {
			LL mid = (l + r) >> 1, qwq = 0;
			for (int i = 1; i <= n; i ++) qwq += mid / a[i];
			if (qwq <= m) l = mid + 1;
			else r = mid - 1;
		}
		return dfs(1, 1, r, -1, 0);
	}
	int main() {
		cin >> n >> l >> r;
		for (int i = 1; i <= n; i ++) cin >> a[i];
		cout << (long long)(solve(r) - solve(l - 1)) << '\n';
		return 0;
	}
}
int main() {
    int T = 1;
    while (T --) Milkcat::main();
    return 0;
}

```

---

## 作者：Galex (赞：6)

设 $V(x)$ 表示 $[1,x]$ 中有多少个正整数是可被表示的，那么答案就是 $V(r)-V(l-1)$。于是只需考虑如何求出 $V(x)$。

首先，发现 $y$ 是实数还是整数对结果并无影响。于是考虑二分出最大的 $Y$ 满足 $\lfloor \frac Y {x_1} \rfloor+\lfloor \frac Y {x_2} \rfloor+\cdots + \lfloor \frac Y {x_n} \rfloor\le x$，则 $[1,x]$ 中所有可被表示的正整数一定能够被一个正整数 $y\le Y$ 表示出来。

那么答案是否就是 $Y$ 呢？显然不是。因为可能会有两个不同的 $y$ 表示出了相同的 $x$。

于是考虑去重。考虑两个不同的 $y_1,y_2$ 在什么情况下表示出来的数是一样的。不妨设 $y_1<y_2$，则对于 $\forall i \in [1,n]$，有 $\lfloor \frac {y_1} {x_i} \rfloor \le \lfloor \frac {y_2} {x_i} \rfloor$。那么只有当对于 $\forall i \in [1,n]$，有 $\lfloor \frac {y_1} {x_i} \rfloor = \lfloor \frac {y_2} {x_i} \rfloor$ 时，$y_1$ 和 $y_2$ 表示出来的数是相等的。

于是我们可以发现，如果一个 $y$ 不能任何一个 $x_i$ 整除，这个 $y$ 是没有价值的，因为一定存在另一个 $y'$ 使得 $y$ 与 $y'$ 表示出来的数相同，且 $y'$ 能够其中一个 $x_i$ 整除。

那么问题转化为 $[1,Y]$ 中有多少个正整数至少是一个 $x_i$ 的倍数，直接 $2^n$ 容斥。即
$$
Y-\sum_{S\subseteq \{1,2,\cdots,n \}} (-1)^{|S|} \times \lfloor \frac Y {\text{lcm}_{i \in S}\{x_i\}}\rfloor 
$$

---

## 作者：rui_er (赞：3)

容易想到将所求差分，变为 $[1,r]$ 的答案减去 $[1,l-1]$ 的答案。

直觉告诉我们所谓的“实数 $y$”就是没事闲的，其实只需要整数就可以。然后这种酷似整除分块的结构提示我们很多 $y$ 的取值都是多余的，只需要保留所有是 $x_i$ 的倍数的取值就做到了不重不漏。

要求 $[1,k]$ 的答案，我们可以先二分出最大的满足 $\sum\lfloor\frac{y}{x_i}\rfloor\le k$ 的 $y_{\max}$，然后不超过 $y_{\max}$ 的是 $x_i$ 的倍数的数的个数即为答案。

这是一个经典容斥，记 $X$ 为所有 $x_i$ 构成的集合，答案即为：

$$
\sum\limits_{S\subseteq X}(-1)^{|S|-1}\left\lfloor\frac{y_{\max}}{\operatorname{lcm}S}\right\rfloor
$$

需要注意的是 $\operatorname{lcm}S$ 可能特别巨大，在计算过程中超过 $y_{\max}$ 了就可以退出了。

容斥复杂度好像写高了，不过也过了，防 hack 就不放代码了。

---

## 作者：2huk (赞：1)

> - 定义：
>   - 一个实数 $y$ 能**表示**一个正整数 $x$，当且仅当 $\lfloor \frac y {x_1} \rfloor+\lfloor \frac y {x_2} \rfloor+\cdots + \lfloor \frac y {x_n} \rfloor=x$。
>   - 一个正整数 $x$ 是**可被表示的**，当且仅当存在一个实数 $y$ 能**表示** $x$。
> - $\color{red}n \le 25$，$r, x_i \le 10^9$。

首先差分，设 $f(x)$ 表示 $1 \sim x$ 内**可被表示的**整数数量，那么 $f(r) - f(l - 1)$ 即为答案。接下来考虑求解 $f(x)$。

首先因为有下取整，所以 $y$ 是一般实数还是整数就无所谓了。只需要考虑 $y \in \mathbb N$ 的情况。

二分出最大的 $z$ 使得 $\sum \lfloor \frac z{y_i} \rfloor \le x$。那么如果 $1 \sim x$ 中的某个数是**可被表示的**，就一定能被某个 $1 \sim z$ 中的数**表示**。

我们定义：

- 一个实数 $y$ 能够**严格表示**一个正整数 $x$，当且仅当 $y$ 为能**表示** $x$ 的实数中的最小值。
- 一个实数 $y$ 是**可严格表示的**，当且仅当存在一个正整数 $x$ 使得 $y$ 可以**严格表示** $x$。

那么**可被表示的**数和**可严格表示的**数一一对应。所以问题转化成 $1 \sim z$ 中有多少**可严格表示的**数。

感性理解如果 $t \in [1, z]$ 且 $t$ 是**可严格表示的**的，那么 $t$ 一定是至少一个 $x_i$ 的倍数。于是就可以容斥了：
$$
\sum_{S \subseteq \{1, 2, \dots, n\}} (-1)^{|S| + 1} \left\lfloor \dfrac {z}{\operatorname{lcm}_{v \in S}\{x_v\}}\right\rfloor
$$

---

## 作者：luogu_gza (赞：1)

首先转化为一个前缀的答案。

其实实数和正数毫无区别。

你发现如果一个数可以被表示出来，就相当于它可以被 $x$ 的倍数所凑出来。

考虑容斥，最终的上界是令 $\sum_{i=1}^{n}\lfloor \frac{y}{a} \rfloor \leq k$ 的最大 $a$，其中 $k$ 就是所求的前缀的右端点。

答案就长这个样子。

$$\sum_{s \subseteq X}(-1)^{|s|+1} \lfloor \frac{a}{\operatorname{lcm}(s)} \rfloor$$

其中，一个集合的 $\operatorname{lcm}$ 就是其中所有元素的 $\operatorname{lcm}$ 的值。

实现上还有一点细节，就是 $\operatorname{lcm}$ 的值可能巨大，所以中途的值大于 $a$ 了就 `break`。

[record](https://www.luogu.com.cn/record/126307874)

是拿小号开的重现赛，如果看不到代码的话私我，我给一个链接。

---

## 作者：_fairytale_ (赞：0)

>埋怨我较真也好 嘲笑我笨拙也罢
>
>若这样能让你记住我 那就原谅你吧
>
>只要还活着的话 只要不愿放弃的话
>
>即使不尽人意也请笑一笑吧

怎么大家都会做这个题。/ll

记 $f(y)=\sum\lfloor\dfrac{y}{x_i}\rfloor$。

首先差分开，转化为问 $[1,p]$ 中有多少个数满足条件。

接下来二分一个最大的 $y$ 满足 $f(y)\le p$，则 $f(i),i\in[1,y]$ 中的每个数都可以表示 $[1,p]$ 中的一个数。但是 $f(i)$ 中显然有重的，所以我们要去重。如果 $i$ 不是某一个 $x$ 的倍数，那么必然有一个 $x$ 的倍数 $j$ 满足 $f(j)=f(i)$，所以我们只需要考虑是某些 $x$ 的倍数的 $i$。

这样就足够了。我们把所有 $x$ 的倍数在数轴上找出来，把这个数轴分成若干段，每段只取到最左边的数作为 $i$，显然相邻两段的 $f$ 互不相同，所以若 $i\ne j$，则 $f(i)\ne f(j)$。

接下来就是找 $[1,y]$ 中是某些 $x$ 的倍数的数有多少个，这是简单的容斥问题。

```cpp
#include<bits/stdc++.h>
bool Mst;
#define ll long long
#define rep(x,qwq,qaq) for(int x=(qwq);x<=(qaq);++x)
#define per(x,qwq,qaq) for(int x=(qwq);x>=(qaq);--x)
using namespace std;
#define infll 0x3f3f3f3f3f3f3f3f
#define maxn 35
int n,l,r;
int x[maxn];
ll lcm[(1<<25)];
int solve(int p){
    ll l=0,r=1e18,y=0,ans=0;
	while(l<=r){
		ll res=0,mid=(l+r)/2;
		rep(i,1,n)res+=mid/x[i];
		if(res>p)r=mid-1;
		else y=mid,l=mid+1;
	}
	rep(S,1,(1<<n)-1){
		ans+=(__builtin_popcount(S)&1?1ll:-1ll)*y/lcm[S];
	}
	return ans;
}
bool Med;
signed main() {
	cerr<<(&Mst-&Med)/1024.0/1024.0<<" MB\n";
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n>>l>>r;
	rep(i,1,n)cin>>x[i];
	lcm[0]=1;
	rep(S,1,(1<<n)-1){
		lcm[S]=1;
		rep(i,1,n){
			if((S>>(i-1))&1){
				int T=S^(1<<(i-1));
				lcm[S]=min((__int128)infll,(__int128)lcm[T]*x[i]/__gcd(lcm[T],0ll+x[i]));
				break;
			}
		}
	}
	cout<<solve(r)-solve(l-1);
	return 0;
}
```

---

## 作者：jasonliujiahua (赞：0)

# P9489

[题目传送门](https://www.luogu.com.cn/problem/P9489)
## 题意简述：
一个正整数 $x$ 是可被表示的，当且仅当存在一个实数 $y$，满足 $\left \lfloor \frac{y}{x_1} \right \rfloor+\left \lfloor \frac{y}{x_2} \right \rfloor+\cdots +\left \lfloor \frac{y}{x_n} \right \rfloor=x$。给定 $n,l,r,x_i(1\le i \le n)$，请求出区间 $[l,r]$ 中有多少个正整数是可被表示的。
$1\le n \le 25 ,1 \le l \le r \le 10^9 ,1\le x_i(1\le i \le n) \le 10^9$。
## 题目分析：
### Step 1：构造
如果我们能构造一个 $x$ 到 $y$ 的一一对应，就可以将 $x$ 的个数转换成带有一定条件的 $y$ 的个数，可能这里 $y$ 比 $x$ 更好计算（因为条件比较集中）。

那么这个“一定条件”是什么呢？显然每个 $y$ 都唯一对应一个 $x$，因此只需让每一个 $x$ 都对应唯一一个 $y$ 即可。我们可以发现 $x$ 实际上只与 $y$ 除以 $x_i$ 的商有关，和余数无关。因此考虑若存在 $y_1,y_2(y_1<y_2)$ 除以 $x_i$ 的商一样时，只统计 $y_1$。显然随着 $y$ 增加，$x$ 一定单调不降，因此若产生一个**新**的 $x$，实际上就意味着 $x$ 增加了，因此可以发现按此方法 $x$ 关于 $y_1$ 的函数是单调的，并且显然可以发现 $y_1$ 关于 $x$ 的函数也是单调的，因此 $x$ 和 $y_1$ 一一对应（当然，你也可以直接感性理解，毕竟所有 $y$ 中有且仅有一个最小的嘛）。
### Step 2：计算
可以发现，在 $y$ 增大的过程中，若某一时刻 $y$ 刚好是某个 $x_i$ 的倍数，那么 $y$ 除以 $x_i$ 的商就会改变，$x$ 就会改变，答案就应加 $1$。同时若将区间 $[l,r]$ 改成 $[1,r]-[1,l-1]$，问题变成了：**统计有多少个 $y$ 是某一个 $x_i$ 的倍数，并使 $x$ 在区间 $[1,a]$ 内**。

可以发现我们已经成功用 $y$ 替代了 $x$，可是并没有用 $x$ 的范围找到 $y$ 的范围，所以接下来就处理这步。由于前面说过 $x$ 关于 $y$ 具有单调性，因此考虑二分，即可得出 $y$ 的范围 $[1,Y]$。

接下来用容斥计算 $[1,Y]$ 内各个 $x_i$ 的倍数所组成的集合的**并集**，显然要考虑容斥。由于 $n$ 很小，直接 $O(2^n)$ 状压当前统计哪些 $x_i$ 的公倍数，然后用公倍数的个数容斥即可得到最终的答案。

## 参考代码：

**【注：代码中变量名可能和题目还有上面的分析不一样，请注意区分】**
```c++
#include<bits/stdc++.h>
using namespace std;
#define int __int128
#define ll __int128
const int maxn=30;
int n,l,r,a[maxn];
inline int read()
{
	int x=0,f=1;
	char ch=getchar();
	while(!isdigit(ch))
	{
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(isdigit(ch))
	{
		x=(x<<3)+(x<<1)+ch-'0';
		ch=getchar();
	}
	return x*f;
}
void init()
{
	n=read(),l=read(),r=read();
	for(int i=1;i<=n;i++) a[i]=read();
}
bool check(int x,int y)
{
    int tmp=0;
    for(int i=1;i<=n;i++) tmp+=y/a[i];
    return (tmp<=x);
}
inline int lcm(int x,int y)
{
    return x*y/__gcd(x,y);
}
ll find(int x)
{
    ll nn=((1<<n)-1),res=0;
    for(int s=1;s<=nn;s++)
    {
        ll cnt=__builtin_popcount(s),sum=1;
        for(int i=1;i<=n;i++)
        {
            if(!(s&(1<<(i-1)))) continue;
            sum=lcm(sum,a[i]);
            if(sum>x) break;
        }
        if(cnt&1) res+=(x/sum);
        else res-=(x/sum);
    }
    return res;
}
ll work(int m)
{
    int x=0,y=2e18,res=0;
    while(x<=y)
    {
        int mid=(x+y)>>1;
        if(check(m,mid))
        {
            res=mid;
            x=mid+1;
        }
        else y=mid-1;
    }
    return find(res);
}
void print(int x)
{
	if(x<0) x=-x;
	if(x<10) 
	{
		putchar(x+'0');
		return;
	}
	print(x/10);
	putchar(x%10+'0');
}
signed main()
{
    init();
    print(work(r)-work(l-1));
    return 0;
}
```

---


# 高效清理

## 题目背景

清理炸弹设计理念图：

![](https://cdn.luogu.com.cn/upload/image_hosting/mjfmevu2.png)

## 题目描述

真寻的房间太大了，但是作为家里蹲，她又懒得打扫，于是美波里发明了一款清理炸弹给真寻使用。

真寻的房间由 $n$ 行 $m$ 列的方砖组成，第 $i$ 行第 $j$ 列的方砖上的灰尘数量为 $a_{i,j}$。

真寻将会使用 $k$ 次清理炸弹，第 $i$ 次她会在第 $x_i$ 行第 $y_i$ 列的方砖上使用能量值为 $p_i$ 的清理炸弹，这将会使 $(x_i,y_i)$ 的灰尘数量减少 ${p_i}^2$，$(x_i,y_i)$ 外围第一圈的方砖上的灰尘数量减少 $(p_i-1)^2$，外围第二圈的方砖上的灰尘数量减少 $(p_i-2)^2$ $\cdots$ 外围第 $(p_i-1)$ 圈的方砖上的灰尘数量减少 $1$。

当然，灰尘数量不能为负数，所以若某次操作前，某块方砖上的灰尘数量小于它将要减少的灰尘数量，那么它的灰尘数量将变为 $0$。

请你输出真寻使用完 $k$ 次清理炸弹后，每块方砖上的灰尘数量。

## 说明/提示

**样例** $\mathbf{1}$ **解释**

第一次操作在方砖 $(2,4)$ 上使用能量值为 $2$ 的“清理炸弹”，使 $(2,4)$ 的灰尘数量减少 $4$，$(1,3),(1,4),(1,5),(2,3),(2,5),(3,3),(3,4),(3,5)$ 的灰尘数量减少 $1$；

第二次操作在方砖 $(3,3)$ 上使用能量值为 $2$ 的“清理炸弹”，使 $(3,3)$ 的灰尘数量减少 $4$，$(2,2),(2,3),(2,4),(3,2),(3,4),(4,2),(4,3),(4,4)$ 的灰尘数量减少 $1$。

**数据范围**

对于所有数据，$1\leq n,m,p_i\leq 10^3$，$1\leq k\leq 10^6$，$0\leq a_{i,j}\leq 10^{12}$，$1\leq x_i\leq n$，$1\leq y_i\leq m$。

本题共 $11$ 个数据点，**采用捆绑测试**，子任务及数据点分配如下：

| 子任务编号 | 数据点编号 | 特殊性质 | 分值 |
| :-: | :-: | :-: | :-: |
| $0$ | $1\sim 4$ | $n,m,k\leq 300$ | $10$ |
| $1$ | $5$ | $p_i\leq 3$ | $10$ |
| $2$ | $6\sim 7$ | $k\leq 10^3$ | $20$ |
| $3$ | $8\sim 9$ | $n,m\leq 300$ | $20$ |
| $4$ | $10\sim 11$ | 无特殊限制 | $40$ |

## 样例 #1

### 输入

```
4 5 2
7 5 4 6 5
2 4 7 9 5
6 4 5 3 5
1 2 3 0 7
2 4 2
3 3 2```

### 输出

```
7 5 3 5 4
2 3 5 4 4
6 3 0 1 4
1 1 2 0 7```

## 样例 #2

### 输入

```
6 7 3
6 4 7 8 4 6 1
4 5 4 6 7 5 9
1 4 3 0 7 1 3
4 6 0 7 9 0 0
1 2 3 4 4 5 8
4 7 6 8 7 4 9
5 5 3
2 3 4
3 6 2```

### 输出

```
2 0 0 0 0 5 1 
0 0 0 0 2 3 8 
0 0 0 0 1 0 1 
0 2 0 0 0 0 0 
0 1 1 0 0 0 7 
4 7 5 4 3 0 8 ```

# 题解

## 作者：Undead2008 (赞：7)

将每个炸弹拆成若干个以该炸弹为中心的正方形矩形加一个值的形式，二维前缀和即可做到单次操作 $O(n)$。

观察到二维前缀和所需要修改的权值是四个等差数列，如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/o3ytukai.png)

对两条斜线分别进行二维差分即可维护。时间复杂度为 $O(nm+k)$。

```cpp
#include"bits/stdc++.h"
using namespace std;
#define int long long
const int maxn = 3010;
const int B = 1010;
const int maxm = 1000100;
int n,m,k,v[maxn][maxn];
int a[maxn][maxn],b[maxn][maxn],Sa[maxn][maxn],Sb[maxn][maxn],S[maxn][maxn];
signed main(){
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			cin>>v[i][j];
	for(int i=1,x,y,p;i<=k;i++){
		cin>>x>>y>>p;p--;
		x+=B,y+=B;
		Sa[x-p][y-p]+=1;
		a[x-p+1][y-p+1]+=2;
		a[x+1][y+1]-=2;
		a[x+2][y+2]-=2;
		a[x+p+2][y+p+2]+=2;
		Sa[x+p+2][y+p+2]-=1;
		Sb[x-p][y+p+1]-=1;
		b[x-p+1][y+p]-=2;
		b[x+1][y]+=2;
		b[x+2][y-1]+=2;
		b[x+p+2][y-p-1]-=2;
		Sb[x+p+2][y-p-1]+=1;
	}
	for(int i=1;i<maxn;i++)
		for(int j=1;j<maxn;j++)
			a[i][j]+=a[i-1][j-1];
	for(int i=1;i<maxn;i++)
		for(int j=1;j<maxn;j++)
			Sa[i][j]=Sa[i][j]+a[i][j]+Sa[i-1][j-1];
	for(int i=1;i<maxn;i++)
		for(int j=maxn-2;j>=0;j--)
			b[i][j]+=b[i-1][j+1];
	for(int i=1;i<maxn;i++)
		for(int j=maxn-2;j>=0;j--)
			Sb[i][j]=Sb[i][j]+b[i][j]+Sb[i-1][j+1];
	for(int i=0;i<maxn;i++)
		for(int j=0;j<maxn;j++)
			S[i][j]+=Sb[i][j];
	for(int i=0;i<maxn;i++)
		for(int j=0;j<maxn;j++)
			S[i][j]+=Sa[i][j];
	for(int i=1;i<maxn;i++)
		for(int j=1;j<maxn;j++)
			S[i][j]+=S[i-1][j]+S[i][j-1]-S[i-1][j-1];
	for(int i=1;i<=n;i++,cout<<endl)
		for(int j=1;j<=m;j++)
			cout<<max(0ll,v[i][j]-S[i+B][j+B])<<' ';
}
```

---

## 作者：P_VICVIC_R (赞：4)

~~之前还在想为什么一道差分前缀和通过数这么低……是我菜了，好难调啊！！~~

---

### 前置：

二维前缀和，**二阶**差分（**多阶差分**），**二维**差分。

## 题意不赘述

## 思路：

首先**静态二维区间修改**很容易想到**二维差分+二维前缀和**吧。（你非要往~~二维树状数组~~或是~~二维线段树~~上想我也没办法。）

那么问题来了：我们要如何一圈一圈往里面修改呢？

我们发现第 $i$ 圈和第 $i+1$ 圈的减掉的值分别是 $(p-i)^2$ 和 $(p-(i+1))^2$，相差 $2p-2i-1$。

那么我们从内向外做差分（或从外向内也行），差分的位置如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/f0fms6j7.png)

至于怎么差分就不讲，不会自己学。

这里有个小细节，差分有可能会跑到负下标的地方，例子：$\texttt{1 1 6}$，

因为 $n,m,p_i$ 最大就 $1000$，所以我们可以开三倍空间：

- 前 $1000$ 留给负下标；

- 后 $1000$ 留给 $\max(x_i,y_i)+p_i>1000$ 的情况；

注意统一偏移就行。

前缀和就跑 $3000 \times 3000$，时间也够。

核心代码：

```c++
while(k--){
        int x,y,p;
        cin>>x>>y>>p;
        int li=1;
        for(int i=1;i<=p;i++){//Cnt 是统一的偏移量1000
			diff[Cnt+x+p-i+1][Cnt+y+p-i+1]-=li;
			diff[Cnt+x-p+i][Cnt+y-p+i]-=li;
			diff[Cnt+x-p+i][Cnt+y+p-i+1]+=li;
			diff[Cnt+x+p-i+1][Cnt+y-p+i]+=li;
             li+=2;
        }
    }
```

时间复杂度 $O(kp)$，可以拿60分。

那么我们怎们优化呢？

我们发现差分的值是个等差数列，举个例子：

- $P$ 为 $7$ 时：

  1. 则从外到内减去的值分别是：
     $$
     \text{1,4,9,16,25,36,49}
     $$
     

  2. 先差分一遍（前一位补 $0$）：
     $$
     \text{0,1,3,5,7,9,11,13}
     $$
     

  3. 再差分一遍（二阶差分）：
     $$
     \text{1,2,2,2,2,2,2}
     $$
     

  4. 再再差分（是不是算三阶差分了……）：
     $$
     \text{1,1,0,0,0,0,0,-2}
     $$

没懂？图来了（图上的差分是正的，最后一步改成减就行）：

![](https://cdn.luogu.com.cn/upload/image_hosting/pcix8nx8.png)

第一遍差分：

![](https://cdn.luogu.com.cn/upload/image_hosting/qar4rtlm.png)

注意下标顺序是从上往下，从左往右。

这个时候我们把每一条斜线单独出来，用一维差分的方式进行差分。

有下图

![](https://cdn.luogu.com.cn/upload/image_hosting/p10h53a9.png)

为什么差分这么多遍呢？因为到现在你直接修改都还是 $O(p)$ 的，时间复杂度依然只能拿 $60$ 分……

最后再差分：

![](https://cdn.luogu.com.cn/upload/image_hosting/sp5v179n.png)

终于可以 $O(1)$ 修改了……

看懂了吧（不懂没办法了），再来梳理一下：

1. 输入不讲；

2. 对于每次修改我们在两个二维数组中进行差分（一个是从左下到右上，另一个是从左上到右下的两个用一维规则的差分数组）；

3. 用一维前缀和规则斜着跑差分数组还原二阶差分；

4. 再跑一遍还原一阶差分；

5. 把两个还原好的差分加到一个二维数组里面；

6. 二维前缀和还原；

7. 原数据剪掉还原好的值，判断是否小于 $0$，输出；

## code :

只放修改和还原的部分代码（对应上文中的二到五）：

```c++
    while(q--){
            int x,y,p;
            cin>>x>>y>>p;
            x+=Cnt;
            y+=Cnt;
            Ddif[x][y]-=2;
            Ddif[x+1][y+1]-=2;
            Udif[x-1][y]+=2;
            Udif[x-2][y+1]+=2;
            Ddif[x+p][y+p]+=1;
            Ddif[x+1+p][y+1+p]+=1;
            Ddif[x-p][y-p]+=1;
            Ddif[x+1-p][y+1-p]+=1;
            Udif[x-1-p][y+p]-=1;
            Udif[x-2-p][y+p+1]-=1;
            Udif[x-1+p][y-p]-=1;
            Udif[x-2+p][y-p+1]-=1;
        }
    for(int i=1;i<=3000;i++)
        for(int j=1;j<=3000;j++)
            Ddif[i][j]+=Ddif[i-1][j-1];
    for(int i=3000;i>=1;i--)
        for(int j=1;j<=3000;j++)
        	Udif[i][j]+=Udif[i+1][j-1];
    for(int i=1;i<=3000;i++)
        for(int j=1;j<=3000;j++)
            Ddif[i][j]+=Ddif[i-1][j-1];
    for(int i=3000;i>=1;i--)
        for(int j=1;j<=3000;j++)
            Udif[i][j]+=Udif[i+1][j-1];
```

### 结语：很好一道题，但真的不是很好写，~~调死我了。~~

---

## 作者：CoderMeow (赞：2)

# P10266 高效清理  题解

## 前言

对很基础的算法的考察，但具体实现并不容易。个人感觉做法是可以很快想到的，但有一些细节值得注意。

## 题意简述

给出 $n$ 行 $m$ 列的方阵，每个格有一个初始数 $a_{i,j}$。给出 $k$ 个操作，每次操作指定 $x, y, p$，以 $(x, y)$ 为中心，将其数值减去 $p^2$，其外围一圈八个数值减去 $(p-1)^2$，以此类推直至外围第 $(p-1)$ 圈，减去 $1$。求出最终方阵值，不足 $0$ 的输出 $0$。

## 解题过程

首先，从此，维护的数值将是每个格子上要减去的数值，那么每一个减法操作在此体现为加法，从而方便讨论与处理。最终将原方阵减去该方阵即得所求。

首先最朴素的算法，对于每个操作，将以其为中心的 $p \times p$ 的方阵一个个算上要减去的数值，复杂度 $O(mnk)$，显然过于低效。

注意到是一个静态的修改问题，只会在最终查询，想到差分。由于是二维的，则要用到二维的差分。但差分是对于区间加或减同一数值的，想到可以把 $p$ 圈修改转为 $p$ 层的，具体是最底层 $+1$，次底层 $+3$，再次层 $+5$。那么第 $a$ 圈（视 $(x,y)$ 为第 $0$ 圈）所得到的加和为 $1+3+5+\cdots +(2p-2a-1)=(p-a)^2$，符合要求。维护二维差分，每次操作以 $(x,y)$ 为中心，要对 $p$ 个正方形做区间加。由于 $n,m$ 同级，此处复杂度中皆记为 $n$，则复杂度为 $O(n^2+kn)$。值得注意的是由于 $p$ 可能较大以致需要维护的差分超出方阵大小，应在原方阵四周留出 $10^3$ 层的空间。目前为止，单次操作的复杂度过大，仍无法通过。

观察做的差分，可以发现每次操作所要修改的差分数组部分构成两条斜线，形如 $1, 3, 5, 7, \dots, 7, 5, 3, 1$ 和 $-1, -3, -5, \dots, -5, -3, -1$，分别在正副对角线上。这是好维护的，可以对于第一次的二维差分数组在正副对角线上再进行差分。此处仍不为区间加同一数值，而是加两等差数列，那么需要两次差分即可实现 $O(1)$ 的单次操作维护。那么最终复杂度 $O(nm+k)$。可以通过。

## 实现

需要推一下的细节比较多。可以自行画图模拟一些小的例子，尽量不要直接照抄一些循环边界、下标部分。

```cpp
# include <cstdio>
# include <vector>

using namespace std;

int read() {
    int x = 0;
    int f = 1;

    int c = getchar();
    while ((c < '0') || (c > '9')) {
        if (c == '-') {
            f = -1;
        }
        c = getchar();
    }

    while ((c >= '0') && (c <= '9')) {
        x = x * 10 + c - '0';
        c = getchar();
    }

    return x * f;
}
long long readL() {
    long long x = 0;
    int f = 1;

    int c = getchar();
    while ((c < '0') || (c > '9')) {
        if (c == '-') {
            f = -1;
        }
        c = getchar();
    }

    while ((c >= '0') && (c <= '9')) {
        x = x * 10 + c - '0';
        c = getchar();
    }

    return x * f;
}
void write(long long x) {
    if (x < 0) {
        putchar('-');
        x = -x;
    }

    if (x > 9) {
        write(x / 10);
    }
    putchar(int(x % 10) + '0');
}

int main() {
    int n, m, k;
    scanf("%d %d %d", &n, &m, &k);

    vector<vector<long long>> dust(n, vector<long long>(m));
    for (auto & line: dust) {
        for (auto & a: line) {
            a = readL();
        }
    }

    int border = 1000;
    int N = n + 1000 + 1;
    int M = m + 1000 * 2;
    // 为了节省时空，舍去纵向上超出下界的部分，因为这里的差分值不会对上方所要维护的部分造成任何影响。

    vector<vector<long long>> diff12(N, vector<long long>(M, 0));  // 二维差分的正对角线的二次差分
    vector<vector<long long>> diff22(N, vector<long long>(M, 0));  // 二维差分的副对角线的二次差分

    while (k--) {
        int x, y, p;
        x = read() - 1;
        y = read() - 1;
        p = read();

        diff12[border + x - p + 1][border + y - p + 1] += 1;
        diff12[border + x - p + 2][border + y - p + 2] += 1;
        if (border + x + 1 < N) {
            diff12[border + x + 1][border + y + 1] -= 2;
            if (border + x + 2 < N) {
                diff12[border + x + 2][border + y + 2] -= 2;
                if (border + x + p + 1 < N) {
                    diff12[border + x + p + 1][border + y + p + 1] += 1;
                    if (border + x + p + 2 < N) {
                        diff12[border + x + p + 2][border + y + p + 2] += 1;
                    }
                }
            }
        }  // 由于没有开超出下界部分的数组，故需要判断是否越界。

        diff22[border + x - p + 1][border + y + p] -= 1;
        diff22[border + x - p + 2][border + y + p - 1] -= 1;
        if (border + x + 1 < N) {
            diff22[border + x + 1][border + y] += 2;
            if (border + x + 2 < N) {
                diff22[border + x + 2][border + y - 1] += 2;
                if (border + x + p + 1 < N) {
                    diff22[border + x + p + 1][border + y - p] -= 1;
                    if (border + x + p + 2 < N) {
                        diff22[border + x + p + 2][border + y - p - 1] -= 1;
                    }
                }
            }
        }  // 同上
    }

    // 操作的处理结束。O(nm) 将差分的内容还原为原方阵。
    vector<vector<long long>> diff11(N, vector<long long>(M, 0));  // 二维差分的正对角线的差分
    vector<vector<long long>> diff21(N, vector<long long>(M, 0));  // 二维差分的副对角线的差分

    for (int i = 0; i < M; ++i) {
        diff11[0][i] = diff12[0][i];
    }
    for (int i = 0; i < N; ++i) {
        diff11[i][0] = diff12[i][0];
    }
    for (int i = 1; i < N; ++i) {
        for (int j = 0; (i + j < N) && (j + 1 < M); ++j) {
            diff11[i + j][j + 1] = diff11[i + j - 1][j] + diff12[i + j][j + 1];
        }
    }
    for (int i = 1; i < M; ++i) {
        for (int j = 0; (i + j < M) && (j + 1 < N); ++j) {
            diff11[j + 1][i + j] = diff11[j][i + j - 1] + diff12[j + 1][i + j];
        }
    }

    for (int i = 0; i < M; ++i) {
        diff21[0][i] = diff22[0][i];
    }
    for (int i = 0; i < N; ++i) {
        diff21[i][M - 1] = diff22[i][M - 1];
    }
    for (int i = 0; i < M - 1; ++i) {
        for (int j = 0; (i - j >= 0) && (j + 1 < N); ++j) {
            diff21[j + 1][i - j] = diff21[j][i - j + 1] + diff22[j + 1][i - j];
        }
    }
    for (int i = 1; i < N; ++i) {
        for (int j = 0; (M - j - 2 >= 0) && (i + j < N); ++j) {
            diff21[i + j][M - j - 2] = diff21[i + j - 1][M - j - 1] + diff22[i + j][M - j - 2];
        }
    }

    vector<vector<long long>> diff2D1(N, vector<long long>(M, 0));  // 由正对角线换原来的二维差分
    vector<vector<long long>> diff2D2(N, vector<long long>(M, 0));  // 由副对角线换原来的二维差分

    for (int i = 0; i < M; ++i) {
        diff2D1[0][i] = diff11[0][i];
    }
    for (int i = 0; i < N; ++i) {
        diff2D1[i][0] = diff11[i][0];
    }
    for (int i = 1; i < N; ++i) {
        for (int j = 0; (i + j < N) && (j + 1 < M); ++j) {
            diff2D1[i + j][j + 1] = diff2D1[i + j - 1][j] + diff11[i + j][j + 1];
        }
    }
    for (int i = 1; i < M; ++i) {
        for (int j = 0; (i + j < M) && (j + 1 < N); ++j) {
            diff2D1[j + 1][i + j] = diff2D1[j][i + j - 1] + diff11[j + 1][i + j];
        }
    }

    for (int i = 0; i < M; ++i) {
        diff2D2[0][i] = diff21[0][i];
    }
    for (int i = 0; i < N; ++i) {
        diff2D2[i][M - 1] = diff21[i][M - 1];
    }
    for (int i = 0; i < M - 1; ++i) {
        for (int j = 0; (i - j >= 0) && (j + 1 < N); ++j) {
            diff2D2[j + 1][i - j] = diff2D2[j][i - j + 1] + diff21[j + 1][i - j];
        }
    }
    for (int i = 1; i < N; ++i) {
        for (int j = 0; (M - j - 2 >= 0) && (i + j < N); ++j) {
            diff2D2[i + j][M - j - 2] = diff2D2[i + j - 1][M - j - 1] + diff21[i + j][M - j - 2];
        }
    }

    vector<vector<long long>> diff2D(N, vector<long long>(M, 0));  // 二维差分
    for (int i = 0; i < N; ++i) {
        for (int j = 0; j < M; ++j) {
            diff2D[i][j] = diff2D1[i][j] + diff2D2[i][j];
        }
    }

    vector<vector<long long>> effects(N, vector<long long>(M, 0));  // 原数组
    for (int i = 0; i < N; ++i) {
        effects[i][0] = diff2D[i][0];
    }
    for (int i = 0; i < M; ++i) {
        effects[0][i] = diff2D[0][i];
    }
    for (int i = 1; i < N; ++i) {
        for (int j = 1; j < M; ++j) {
            effects[i][j] = diff2D[i][j] + effects[i - 1][j] + effects[i][j - 1] - effects[i - 1][j - 1];
        }
    }

    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            write(max(0ll, dust[i][j] - effects[border + i][border + j]));  // 将加法转为减法；注意对 0 取 max
            putchar(' ');
        }
        putchar('\n');
    }

    return 0;
}

```

---

## 作者：Link_Cut_Y (赞：1)

不妨称两点 $(x_0, y_0), (x_1, y_1)$ 之间的距离为 $d =\max\{|x_0 - x_1|, |y_0 - y_1|\}$。

每次使用清理炸弹，都会逐层清理灰尘。距离炸弹位置距离相等的称为同一层。与炸弹距离为 $d$ 的一层可以称其为第 $d$ 层。

首先我们发现，相邻两层之间减少量的差有一定的规律。不妨设相邻两层分别为第 $i$ 层和第 $(i +1)$ 层。那么两层减少量的差 $\Delta = (p - i) ^ 2 - (p - i - 1) ^ 2 = 2p - 2a - 1$。

这时一个暴力思路是，从中心炸弹的位置开始做二维差分。可以做到 $O(kp)$。期望得分 $60$ 分。

```cpp
int n, m, k, a[N][N], s[N][N], S[N][N];
signed main() {
	read(n, m, k);
	rep(i, 1, n) rep(j, 1, m) read(a[i + d][j + d]);
	rep(i, 1, k) {
		int x, y, p;
		read(x, y, p);
		x += d, y += d;
		rop(j, 0, p) 
			s[x - j][y - j] -= 2 * p - 2 * j - 1,
			s[x + j + 1][y - j] += 2 * p - 2 * j - 1,
			s[x - j][y + j + 1] += 2 * p - 2 * j - 1,
			s[x + j + 1][y + j + 1] -= 2 * p - 2 * j - 1;
	} rep(i, 1, n + d) rep(j, 1, m + d) 
		S[i][j] = S[i - 1][j] + S[i][j - 1] - S[i - 1][j - 1] + s[i][j];
	rep(i, 1, n) {
		rep(j, 1, m)
			write(a[i + d][j + d] + S[i + d][j + d] < 0 ? 0 : a[i + d][j + d] + S[i + d][j + d]);
		puts("");
	} return 0;
}
```

接下来考虑对这个思路进行优化。不难发现，我们的差分数组有一定的规律：可以看做四条中心是同一个点的线段拼在一起。举个例子，当输入是：

```
10 10 1
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
5 5 3
```

时，$s$ 数组应为：

```
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 -1 0 0 0 0 1 0 0
0 0 0 -3 0 0 3 0 0 0
0 0 0 0 -5 5 0 0 0 0
0 0 0 0 5 -5 0 0 0 0
0 0 0 3 0 0 -3 0 0 0
0 0 1 0 0 0 0 -1 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
```

以 $(5, 5)$ 为中心的四条对角线呈现等差数列的形式，不难使用二阶差分实现。复杂度便为 $O(nm)$。

代码实现比较丑陋。

```cpp
const int N = 3010;
const int d = 1010;
int n, m, k;
LL a[N][N], s[N][N], S[N][N];
int ss1[N][N], ss2[N][N], ss3[N][N], ss4[N][N];
int sss1[N][N], sss2[N][N], sss3[N][N], sss4[N][N];
int s1[N][N], s2[N][N], s3[N][N], s4[N][N];
signed main() {
	read(n, m, k);
	rep(i, 1, n) rep(j, 1, m) read(a[i + d][j + d]);
	rep(i, 1, k) {
		int x, y, p; read(x, y, p); x += d, y += d;
		ss1[x][y] -= 2 * p - 1; ss1[x - p][y - p] += 2 * p - 1;
		ss2[x + 1][y + 1] -= 2 * p - 1; ss2[x + p + 1][y + p + 1] += 2 * p - 1;
		ss3[x + 1][y] += 2 * p - 1; ss3[x + p + 1][y - p] -= 2 * p - 1;
		ss4[x][y + 1] += 2 * p - 1; ss4[x - p][y + p + 1] -= 2 * p - 1;
		
		s1[x - p][y - p] -= 2 * p - 2; s2[x + p + 1][y + p + 1] -= 2 * p - 2;
		s3[x + p + 1][y - p] += 2 * p - 2; s4[x - p][y + p + 1] += 2 * p - 2;
		
		sss1[x - 1][y - 1] += 2; sss1[x - p][y - p] -= 2;
		sss2[x + 2][y + 2] += 2; sss2[x + p + 1][y + p + 1] -= 2;
		sss3[x + 2][y - 1] -= 2; sss3[x + p + 1][y - p] += 2;
		sss4[x - 1][y + 2] -= 2; sss4[x - p][y + p + 1] += 2;
	} 
    
	dep(i, n + d, 1) dep(j, m + d, 1)
	    ss1[i][j] += ss1[i + 1][j + 1];
	rep(i, 1, n + d) rep(j, 1, m + d)
	    ss2[i][j] += ss2[i - 1][j - 1];
	rep(i, 1, n + d) dep(j, m + d, 1)
	    ss3[i][j] += ss3[i - 1][j + 1];
	dep(i, n + d, 1) rep(j, 1, m + d)
	    ss4[i][j] += ss4[i + 1][j - 1];
	
	dep(i, n + d, 1) dep(j, m + d, 1)
	    sss1[i][j] += sss1[i + 1][j + 1];
	rep(i, 1, n + d) rep(j, 1, m + d)
	    sss2[i][j] += sss2[i - 1][j - 1];
	rep(i, 1, n + d) dep(j, m + d, 1)
	    sss3[i][j] += sss3[i - 1][j + 1];
	dep(i, n + d, 1) rep(j, 1, m + d)
	    sss4[i][j] += sss4[i + 1][j - 1];
	
	rep(i, 1, n + d) rep(j, 1, m + d)
	    sss1[i][j] += s1[i][j], sss2[i][j] += s2[i][j], 
	    sss3[i][j] += s3[i][j], sss4[i][j] += s4[i][j];
	
	dep(i, n + d, 1) dep(j, m + d, 1) sss1[i][j] += sss1[i + 1][j + 1];
	rep(i, 1, n + d) rep(j, 1, m + d) sss2[i][j] += sss2[i - 1][j - 1];
	rep(i, 1, n + d) dep(j, m + d, 1) sss3[i][j] += sss3[i - 1][j + 1];
	dep(i, n + d, 1) rep(j, 1, m + d) sss4[i][j] += sss4[i + 1][j - 1];
	
    rep(i, 1, n + d) rep(j, 1, m + d) s[i][j] = ss1[i][j] + ss2[i][j] + ss3[i][j] + ss4[i][j] +
        sss1[i][j] + sss2[i][j] + sss3[i][j] + sss4[i][j]; 
	rep(i, 1, n + d) rep(j, 1, m + d) 
		S[i][j] = S[i - 1][j] + S[i][j - 1] - S[i - 1][j - 1] + s[i][j];
	rep(i, 1, n) {
		rep(j, 1, m)
			printf("%lld ", a[i + d][j + d] + S[i + d][j + d] < 0ll ? 0ll : a[i + d][j + d] + S[i + d][j + d]);
		puts("");
	} return 0;
}
```

---


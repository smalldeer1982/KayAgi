# 「ACOI2020」学园祭

## 题目背景

![T4](https://s2.ax1x.com/2020/01/12/lopWDS.md.png)

秋天，是学习之秋，食欲之秋，更是，学园祭之秋！随着时间流逝，学园祭也越来越近。终于等到这一天，可是没想到在冲绳岛上邂逅到女装的渚同学的勇次竟然来了！中村 莉櫻（Nakamura Rio）见到这个情况，忙给渚同学换上女装。没办法，勇次已经来了，于是渚同学鼓起勇气迈出了第一步。（为什么自顾自地加提示框啊喂！）

## 题目描述

莉櫻为了利用这个人傻钱多的少爷，尽全力提高消费额，努力地暗示渚同学。没办法，于是渚同学想了一下，提出了一个问题：

给出一个 $n$，定义：
$$
\Gamma(0)=1,\Gamma(n)={n!}
$$

$$
A_i^j=\frac{\Gamma(i)}{\Gamma(j)}
$$
求
$$
\sum_{i=1}^n \sum_{j=1}^i \sum_{k=1}^j \gcd(A_{i-j}^j \times \Gamma(j),A_{j-k}^k \times \Gamma(k)) 
$$

渚同学念着莉櫻举起的对话板上写的字：如果不能在规定时间回答出问题的话，就要把菜单全部买一遍哦！

尽管勇次钱多，但是他并不想吃得太多，因为这个问题有 $T$ 个小问题！

**由于答案可能太大，请将答案对 $10086001$ 取模。**

## 说明/提示

#### 数据范围
**本题采用捆绑测试**。

- Subtask 1（20 points）：$T \leq 10^3$，$n \leq 10^2$。   
- Subtask 2（30 points）：$T \leq 10^6$，$n \leq 5 \times 10^3$。  
- Subtask 3（50 points）：$T \leq 10^6$，$n \leq 10^6$。   

对于 $100\%$ 的数据，$1 \leq T,n \leq 10^6$。

## 样例 #1

### 输入

```
5
1
2
3
4
5
```

### 输出

```
1
4
10
20
36
```

# 题解

## 作者：Alex_Wei (赞：25)

~~写篇小学生也能看懂的题解，不需要找规律。~~

虽然看起来有一丢丢麻烦，但如果你认真读一定能看懂 ~

$\rm{Subtask\ 1}$ 无脑 $\Theta(n)$ 预处理阶乘，再 $\Theta(n^4)$ 预处理 $n\in[1,10^2]$ 的所有答案最后 $\Theta(1)$ 回答询问即可。

---

首先化简一下题目给出的柿子

$$\sum_{i=1}^n\sum_{j=1}^i\sum_{k=1}^j\gcd(\frac{(i-j)!}{j!}\times j!,\frac{(j-k)!}{k!}\times k!)$$

即

$$\sum_{i=1}^n\sum_{j=1}^i\sum_{k=1}^j\gcd((i-j)!,(j-k)!)$$

即

$$\sum_{i=1}^n\sum_{j=1}^i\sum_{k=1}^j\min(i-j,j-k)!$$

感觉题目直接给出上式就行了，~~学过数学的都会化简吧。~~

但上面这坨柿子感觉不太可做的样子，看来是我太弱了$\rm{.webp}$。

- 为了说明方便，在下文中我们定义 $x$ 为 $i-j$，$y$ 为 $j-k$。

---

$$\sum_{i=1}^n\sum_{j=1}^i\sum_{k=1}^j\min(x,y)!$$

不难发现 $x,y$ 一定满足以下条件：

- $x,y$ 为非负整数。（废话

- $x+y\leq n-1$。

于是乎，我们就知道 $\min(x,y)$ 的最大值不会超过 $\lfloor\frac{n-1}{2}\rfloor$。

然后柿子就可以化简为这样：

$$\sum_{a=0}^{\lfloor\frac{n-1}{2}\rfloor}a!\times z_a$$

其中 $z_a$ 为当 $\min(x,y)=a$ 时 $i,j,k$ 共有多少种取值，$0\leq a\leq \lfloor\frac{n-1}{2}\rfloor$。

是不是感觉可做了许多$\rm{.jpeg}$。

---

我们考虑如何快速算出 $z_a$。

- 在此之前，我们先想想：如果我们确定了 $x,y$，那么 $i,j,k$ 共有多少种取值。

   有一点是可以肯定的：一旦 $x,y$ 被确定，那么 $i,j,k$ 中的**任意**两个数也就相应地确定下来了。
   
   不妨设确定的两个数为 $j,k$，用含 $k,x,y$ 的柿子表示 $i$ 就是 $i=k+x+y$。
   
   给定 $i\leq n,k\ge 1$ 的限制，得 $1\leq k\le n-x-y$。
   
   也就是说，如果 $x,y$ 确定，那么相应的 $i,j,k$ 共有 $(n-x-y)-1+1=n-x-y$ 种取值。

- 然后我们考虑当 $\min(x,y)=a$ 时 $x,y$ 有哪些情况。

   易想到为 $x=a,y\in[a,n-a-1]$ 或 $x\in[a,n-a-1],y=a$。
   
   注意到 $x=a,y=a$ 被包含在两种情况中，计算时要减去。
   
   很容易就可以算出 $x=a,y\in[a,n-a-1]$ 时 $i,j,k$ 共有多少种取值：
   
   $$\sum_{b=a}^{n-a-1}n-a-b$$
   
   化简得
   
   $$\sum_{b=1}^{n-2a}b$$
   
   带入等差数列求和公式，即
   
   $$\frac{(1+n-2a)\times(n-2a)}{2}$$
   
   反之亦然，即 $x,y$ 交换顺序后取值数不变，所以
   
   $$z_a=2\times\frac{(1+n-2a)\times(n-2a)}{2}-(n-2a)$$
   
   注意最后那个 $n-2a$ 是 $x=a,y=a$ 时重复计算的情况数。
   
   上式仍能化简，得
   
   $$\begin{aligned}z_a&=(1+n-2a)\times(n-2a)-(n-2a)\\&=(n-2a)+(n-2a)\times(n-2a)-(n-2a)\\&=(n-2a)^2\end{aligned}$$

于是我们就能光速求出 $z_a$。

---

将 $z_a$ 的公式带入原式，得

$$\sum_{a=0}^{\lfloor\frac{n-1}{2}\rfloor}a!\times (n-2a)^2$$

这样我们就可以 $\Theta(n)$ 求答案，可过 $\rm{Subtask\ 2}$。

---

这样好像还是不够快，怎么办？！

好像没有能够 $\Theta(1)$ 计算的方法啊$\rm{.png}$。

不慌，当然有：

考虑把上式用完全平方公式拆开来，得

$$\sum_{a=0}^{\lfloor\frac{n-1}{2}\rfloor}a!\times n^2-a!\times4a\times n+a!\times 4a^2$$

然后 $\Theta(n)$ 预处理出 $a!$，$a!\times 4a$，$a!\times 4a^2$ 的前缀和，就可以做到 $\Theta(1)$ 计算了，可过 $\rm{Subtask\ 3}$。

---

附上不长的代码。

```
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5,mod=10086001;
long long frc[N],pre1[N],pre2[N],pre3[N],ans[N],n,t,q,u;
int main(){
	frc[0]=pre1[0]=1;
	for(int i=1;i<N>>1;i++){
		frc[i]=(frc[i-1]*i)%mod;
		pre1[i]=(pre1[i-1]+frc[i])%mod;
		pre2[i]=(pre2[i-1]+frc[i]*4*i)%mod;
		pre3[i]=(pre3[i-1]+frc[i]*4*i%mod*i)%mod;
	}//预处理部分
	scanf("%lld",&t);
	while(t--){
		scanf("%lld",&q);
		u=(q-1)/2;
		printf("%lld\n",((pre1[u]*q%mod*q-pre2[u]*q+pre3[u])%mod+mod)%mod);
	}//计算询问部分
	return 0; 
}
```

如果发现笔误或学术上的错误，请在右侧评论区指出或直接私信我 qwq。

完结撒花 ~ 码字不易，点个赞呗 awa。

$\rm{Upd\ on\ 2020.2.2}$ 修改一处笔误。

---

## 作者：WYXkk (赞：22)

首先，我们肯定要把题目给的式子化简一下：

$$\begin{aligned}&\sum_{i=1}^n\sum_{j=1}^i\sum_{k=1}^i\gcd(A_{i-j}^j\times\Gamma(j),A_{j-k}^k\times\Gamma(k))\\=&\sum_{i=1}^n\sum_{j=1}^i\sum_{k=1}^i\gcd(\dfrac{\Gamma(i-j)}{\Gamma(j)}\times\Gamma(j),{\Gamma(j-k)\over\Gamma(k)}\times\Gamma(k))\\=&\sum_{i=1}^n\sum_{j=1}^i\sum_{k=1}^i\gcd(\Gamma(i-j),\Gamma(j-k))\\=&\sum_{i=1}^n\sum_{j=1}^i\sum_{k=1}^i\Gamma(\min(i-j,j-k))\end{aligned}$$

最后一步：$\gcd(a!,b!)=\gcd(b!(b+1)(b+2)\cdots a,b!)=b!$（不妨设 $a\ge b$）。

接下来，我们发现化简不下去了，于是我们就要祭出神器——

**找 规 律**

首先，我们写个 $O(n^3)$ 的暴力算前几项：

```cpp
#include<cstdio>
#include<iostream>
#include<fstream>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
#define Set(a) memset(a,0,sizeof(a))
#define F(i,a,b) for(register int i=a,i##end=b;i<=i##end;++i)
#define UF(i,a,b) for(register int i=a,i##end=b;i>=i##end;--i)
#define openf(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
#define re register
#define ri re int
#define il inline
typedef long long ll;
typedef unsigned long long ull;
template<typename T> inline T rd(T& x)
{
	T f=1;x=0;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(; isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(T)(c-'0');
	x*=f;
	return x;
}
ll rd(){ll x;rd(x);return x;}
inline int max(int a,int b){return a>b?a:b;}
inline int min(int a,int b){return a<b?a:b;}
const int inf=1<<30;

const int N=1001;
const ll p=10086001;
ll jc[N];
ll ans[N];
int main()
{
	int n=20;jc[0]=1;
	F(i,1,n) jc[i]=jc[i-1]*i%p;
	F(t,1,n) F(i,1,t) F(j,1,i) F(k,1,j) ans[t]+=jc[min(i-j,j-k)];
	F(i,1,n) cout<<"ans["<<i<<"]="<<ans[i]<<endl;
	return 0;
}
```

结果：$1\;4\;10\;20\;36\;60\;98\;156\;258\;428\;786\;1452\;\cdots$

并没有什么规律。

于是我们使用 **差 分** 大法：$1\;3\;6\;10\;16\;24\;38\;58\;102\;170\;358\;666\;\cdots$

仍然没有什么规律。

于是我们继续差分：$1\;2\;3\;4\;6\;8\;14\;20\;44\;68\;188\;308\;\cdots$

似乎有些规律了？

那么我们再差分一次：$1\;1\;1\;1\;2\;2\;6\;6\;24\;24\;120\;120\;\cdots$

于是我们得出结论：$\Delta^3Ans_i=(\lfloor\dfrac {i-1}2\rfloor)!$，这里 $\Delta$ 是差分的意思，右上角的数字代表差分的次数。

那么我们直接处理好阶乘，然后处理好 $\Delta^3Ans$，然后前缀和三次，就搞定了。

查询的时候直接输出即可。

$\texttt{code:}$

```cpp
#include<cstdio>
#include<iostream>
#include<fstream>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
#define Set(a) memset(a,0,sizeof(a))
#define F(i,a,b) for(register int i=a,i##end=b;i<=i##end;++i)
#define UF(i,a,b) for(register int i=a,i##end=b;i>=i##end;--i)
#define openf(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
#define re register
#define ri re int
#define il inline
typedef long long ll;
typedef unsigned long long ull;
template<typename T> inline T rd(T& x)
{
	T f=1;x=0;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(; isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(T)(c-'0');
	x*=f;
	return x;
}
ll rd(){ll x;rd(x);return x;}
inline int max(int a,int b){return a>b?a:b;}
inline int min(int a,int b){return a<b?a:b;}
const int inf=1<<30;

const int N=1000000;
const ll p=10086001;
ll jc[N+5];
ll ans[N+5];
ll mod(ll x){return x>=p?x-=p:x;}
int main()
{
	jc[0]=1;F(i,1,N) jc[i]=jc[i-1]*i%p;
	F(i,1,N) ans[i]=jc[(i-1)>>1];
	F(i,1,N) ans[i]=mod(ans[i]+ans[i-1]);
	F(i,1,N) ans[i]=mod(ans[i]+ans[i-1]);
	F(i,1,N) ans[i]=mod(ans[i]+ans[i-1]);
	int T=rd();
	while(T--) printf("%lld\n",ans[rd()]);
	return 0;
}
```
据说这种做法在时间和码长上均吊打 std（

---

## 作者：do_while_true (赞：3)

# 题目描述

定义：

$$
\Gamma (0)=1,\Gamma (n)=n!
\\
A_{i}^j=\frac{\Gamma (i)}{\Gamma (j)}
$$

求

$$
\sum_{i=1}^n\sum_{j=1}^i\sum_{k=1}^{j}\gcd(A_{i-j}^j\times \Gamma (j),A_{j-k}^k\times \Gamma (k))
$$

# $\mathcal{Solution}$

式子看起来挺花里胡哨的，把里面的东西简单展开一下其实就是求
$$
\sum_{i=1}^n\sum_{j=1}^i\sum_{k=1}^{j}\gcd((i-j)!,(j-k)!)
\\
\sum_{i=1}^n\sum_{j=1}^i\sum_{k=1}^{j}\min(i-j,j-k)!
$$
遇到多个求和号在一起有很多突破的方向，这里选择考虑贡献。

这个 $\min$ 似乎很难搞，但是终究是对若干个阶乘求和，则考虑对于一个 $d$ ，计算 $d!$ 的贡献，容易发现 $d$ 在 $\left[1,\left \lfloor \frac{n-1}{2} \right \rfloor\right ]$内。

上面那个式子放在数轴上考虑，其实就是取出两个连在一起的区间 $[k,j],[j,i]$，答案加上这两个区间较短区间的长度的阶乘。（这里的区间长度为右端点减左端点，即所求式子中的形式，后同）

把这两个区间合并成一个区间 $[k,i]$，因为较短的区间长度为 $d$，则 $[k,i]$ 长度至少为 $2d$。

当 $[k,i]$ 的长度 $len=2d$ 时没有区别，当 $len>2d$ 时较短区间在左侧或右侧都可以。

那么就可以写出答案的式子：
$$
\sum_{d=1}^{\left \lfloor \frac{n-1}{2} \right \rfloor}d!\left(\sum_{len=2d+1}^{n}\sum_{i=1}^{n-len}2+\sum_{i=1}^{n-2d}1\right)
$$
$d,len$ 均为上文定义，$i$ 是枚举的大区间的左端点，也就是上文中 $[k,i]$ 的 $k$。

后面的括号的左半部分是 $len>2d$ 时的贡献次数，右半部分是 $len=2d$ 时的贡献次数。

化简一下：
$$
\sum_{d=1}^{\left \lfloor \frac{n-1}{2} \right \rfloor}d!\left(2\sum_{len=2d+1}^{n}(n-len)+(n-2d)\right)
\\
\sum_{d=1}^{\left \lfloor \frac{n-1}{2} \right \rfloor}d!\left(\sum_{len=0}^{n-2d}len+(n-2d)\right)
\\
\sum_{d=1}^{\left \lfloor \frac{n-1}{2} \right \rfloor}d!\left(2\times\frac{(n-2d)(n-2d-1)}{2}+(n-2d)\right)
\\
\sum_{d=1}^{\left \lfloor \frac{n-1}{2} \right \rfloor}d!\left(n-2d\right)^2
$$
最后这个东西长的十分好看，事实上也很好求，把里面的完全平方式展开一下：
$$
n^2\sum_{d=1}^{\left \lfloor \frac{n-1}{2} \right \rfloor}d!-n\sum_{d=1}^{\left \lfloor \frac{n-1}{2} \right \rfloor}d!4d+\sum_{d=1}^{\left \lfloor \frac{n-1}{2} \right \rfloor}d!4d^2
$$
发现里面三个求和号都能在 $\mathcal{O}(n)$ 的复杂度内预处理，预处理后直接计算即可。

时间复杂度 $\mathcal{O}(\max{n}+T)$

```cpp
#include<iostream>
#include<cstdio>
#define ll long long 
const ll mod = 10086001;
template <typename T> T Max(T x, T y) { return x > y ? x : y; }
template <typename T> T Min(T x, T y) { return x < y ? x : y; }
template <typename T> T Add(T x, T y) { return (x + y > mod) ? (x + y - mod) : (x + y); }
template <typename T> T Mod(T x) { return (x >= mod) ? (x - mod) : x; }
template <typename T>
T& read(T& r) {
	r = 0; bool w = 0; char ch = getchar();
	while(ch < '0' || ch > '9') w = ch == '-' ? 1 : 0, ch = getchar();
	while(ch >= '0' && ch <= '9') r = r * 10 + (ch ^ 48), ch = getchar();
	return r = w ? -r : r;
}
const int N = 1000100;
ll fac[N], f1[N], f2[N], f3[N];
int T, n[N], mx;
signed main() {
	read(T);
	for(int i = 1; i <= T; ++i) mx = Max(mx, read(n[i]));
	fac[0] = f1[0] = 1;
	for(int i = 1; i <= mx; ++i)
		fac[i] = fac[i-1] * i % mod,
		f1[i] = Add(f1[i-1], fac[i]),
		f2[i] = Add(f2[i-1], fac[i] * 4 * i % mod),
		f3[i] = Add(f3[i-1], fac[i] * 4 * i % mod * i % mod);
	for(int i = 1; i <= T; ++i) {
		int m = (n[i]-1)/2;
		printf("%lld\n", Add(Mod(1ll * n[i] * n[i] % mod * f1[m] % mod - n[i] * f2[m] % mod + mod), f3[m]));
	}
	return 0;
}
```

---

## 作者：JohnVictor (赞：3)

这道水题那么水，但是那个式子让人恶心，所以我们要用最短的代码把它切掉qwq.首先定义$g[i]$就是要求的数组.

首先手玩一下gcd里面的式子就可以知道这是$min(i-j,j-k)!$.

我们考虑每个数的阶乘在这里面出现几次.

比如说是$x$的阶乘，有三种情况：

$i-j=x,j-k>x$和$i-j>x,j-k=x$还有$i-j=j-k=x$.

这个不太好算，有3个变量，所以压掉一维.

为了达到这个目的，对于要求的数组做查分，那么只用考虑$i=n$的情况就可以了,这样由于$k \ge1$可以得知$(i-j)+(j-k)\le n-1$,

那么三种情况分别有$n-1-2x,n-1-2x,1$种，加起来变成$2n-2x-1$.

所以$\delta _1 g[i]$（意为$g[i]$的一阶差分）$=\sum (2n-2x-1)x!$,$x$的定义域是$2n-2x-1 \ge 0$.

这个也不是特别好求，所以求出$\delta _2 g[i]$,这个就几乎变成了阶乘数组的前缀和，但是有一点细节.

具体细节可以上我的（10行）代码了.

```cpp
#include<bits/stdc++.h>//为了压行，没有using namespace std
const long long p=10086001;//为了压行，不能舒服地写ll了
long long f[1000005],g[1000005],n=1e6+3,t;
int main(){
    scanf("%d",&t);f[0]=1;//边界情况，题目中定义0!=1
	for(int i=1;i<=n;i++)f[i]=i*f[i-1]%p,g[i]=(g[i-1]+f[(i-1)/2])%p;//求出g[i]的二阶差分
	for(int i=1;i<=n;i++)g[i]+=g[i-1],g[i]%=p;//查分的反操作是前缀和
	for(int i=1;i<=n;i++)g[i]+=g[i-1],g[i]%=p;//前面做了二阶差分，这里就要做两次前缀和
	while (t--)scanf("%d",&n),printf("%d\n",g[n]);
}//return 0可以不写（为了压行）
```


---

## 作者：lgvc (赞：2)

设 $f_i = \sum_{j=1}^i \sum_{k=1}^j \gcd(A_{i-j}^j \times \Gamma(j),A_{j-k}^k \times \Gamma(k)) $

可以化简，得到 ：

$f_i = \sum_{j=1}^i \sum_{k=1}^j \gcd(\Gamma(i-j),\Gamma(j-k)) $

考虑递推的求出 $f_i$ ：

对于任意 $1\le k \le j \le i$

1.  $k>1$

此时 $\gcd(\Gamma(i-j),\Gamma(j-k))$ = $\gcd(\Gamma((i-1)-(j-1)),\Gamma((j-1)-(k-1)))$

所以此时，所有的 $2 \le k \le j \le i$ 对 $f_i$ 的贡献是 $f_{i-1}$。

2. $k=1$

此时，相当要求出 : 

$\sum_{j=1}^i \Gamma(\min(j-1,i-j))$

$= \sum_{j=1}^{\frac{i-1}{2}} \Gamma(j) + \sum_{j=1}^{\frac{i-2}{2}} \Gamma(j)$

前缀和预处理求出。

时间复杂度 $O(T+maxN)$。

code : 

```
#include <bits/stdc++.h>
#define int long long
#define MOD 10086001
static char buf[1000000],*paa=buf,*pd=buf;
static char buf2[1000000],*pp=buf2;
#define getchar() paa==pd&&(pd=(paa=buf)+fread(buf,1,1000000,stdin),paa==pd)?EOF:*paa++
inline void pc(char ch){
	if(pp-buf2==1000000) fwrite(buf2,1,1000000,stdout),pp=buf2;
	*pp++=ch;
}
inline void pcc(){
	fwrite(buf2,1,pp-buf2,stdout);
	pp=buf2;
}
inline int read(void){
	int w=1;
	register int x(0);register char c(getchar());
	while(c<'0'||c>'9'){if(c=='-') w=-1;c=getchar();}
	while(c>='0'&&c<='9')x=(x<<1)+(x<<3)+(c^48),c=getchar();
	return w*x;
}
void write(int x){
	static int sta[20];
	int top=0;
	do{
		sta[top++]=x%10,x/=10;
	}while(x);
	while(top) pc(sta[--top]+48);
}
void we(int x){
	write(x);
	pc('\n');
}
int T,f[10000009],p[1000009];
signed main(void) {
	T=read();
	f[1]=1;
	p[0]=1;for(int i=1;i<=1000000;i++) p[i]=p[i-1]*i%MOD;
	for(int i=1;i<=1000000;i++) p[i]=(p[i]+p[i-1]%MOD);
	for(int i=2;i<=1000000;i++) {
		f[i]=f[i-1];
		f[i]+=p[(i-1)/2];
		f[i]+=p[(i-2)/2];
	}
	for(int i=2;i<=1000000;i++) {
		f[i]+=f[i-1];
		f[i]%=MOD;
	}	
	while(T--) we(f[read()]);
	pcc();
	return 0;
}

```

---

## 作者：zfio (赞：1)

按照套路，像这样一大堆 $\sum$ 套在一起的极其吓唬人的式子，一般都有以下几种解决方式：

1. 推式子，可能式子会变得比较简单可做，单纯的推式子题一般需要用一些比较高级的数学知识或者一些奇思妙想来解决。

2. 考虑转化式子的含义，从而简化求解过程。

3. 对于数据范围比较小的，可以考虑每增加一个的影响， $O(1)$ 转移，递推求解。

4. ……

这道题 $n$ 的范围只有1e6，于是考虑可不可以递推求解。

## 推导

首先直接看原式肯定啥都看不出来，我们直接代入他所给的那个函数的定义，原式即可化为：

$$\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{i}\sum\limits_{k=1}^{j}\, \gcd(\,(i-j)!\,, \, (j-k)!\,)$$


**注意：题目中的函数定义了 $0!=1$**

发现第二个 $\sum$ 的范围被第 $i$ 限制，第三个 $\sum$ 的范围又被 $j$ 限制。

所以我们需要考虑 $i$ 每变大 1 所带来的影响。

例如：

当 $i=3$ 时，答案会在原有基础上增加以下内容：


| 原式 | 等价于 |
| :-----------: | :-----------: |
| $\gcd (\,(3-1)!\, , \, (1-1)!\,)$ | $\gcd (\, 2! \, , \, 0! \,)$ |
| $\gcd (\,(3-2)!\, , \, (2-1)!\,)$ | $\gcd (\, 1! \, , \, 1! \,)$ |
| $\gcd (\,(3-2)!\, , \, (2-2)!\,)$ | $\gcd (\, 1! \, , \, 0! \,)$ |
| $\gcd (\,(3-3)!\, , \, (3-1)!\,)$ | $\gcd (\, 0! \, , \, 2! \,)$ |
| $\gcd (\,(3-3)!\, , \, (3-2)!\,)$ | $\gcd (\, 0! \, , \, 1! \,)$ |
| $\gcd (\,(3-3)!\, , \, (3-3)!\,)$ | $\gcd (\, 0! \, , \, 0! \,)$ |

再考虑当 $i=4$ 时，答案会在原有基础上增加以下内容：

| 原式 | 等价于 |
| :-----------: | :-----------: |
| ${\color{Red} \gcd (\,(4-1)!\, , \, (1-1)!\,)}$ | ${\color{Red} \gcd (\, 3! \, , \, 0! \,)}$ |
| ${\color{Red} \gcd (\,(4-2)!\, , \, (2-1)!\,)}$ | ${\color{Red} \gcd (\, 2! \, , \, 1! \,)}$ |
| $\gcd (\,(4-2)!\, , \, (2-2)!\,)$ | $\gcd (\, 2! \, , \, 0! \,)$ |
| ${\color{Red} \gcd (\,(4-3)!\, , \, (3-1)!\,)}$ | ${\color{Red} \gcd (\, 1! \, , \, 2! \,)}$ |
| $\gcd (\,(4-3)!\, , \, (3-2)!\,)$ | $\gcd (\, 1! \, , \, 1! \,)$ |
| $\gcd (\,(4-3)!\, , \, (3-3)!\,)$ | $\gcd (\, 1! \, , \, 0! \,)$ |
| ${\color{Red} \gcd (\,(4-4)!\, , \, (4-1)!\,)}$ | ${\color{Red} \gcd (\, 0! \, , \, 3! \,)}$ |
| $\gcd (\,(4-4)!\, , \, (4-2)!\,)$ | $\gcd (\, 0! \, , \, 2! \,)$ |
| $\gcd (\,(4-4)!\, , \, (4-3)!\,)$ | $\gcd (\, 0! \, , \, 1! \,)$ |
| $\gcd (\,(4-4)!\, , \, (4-4)!\,)$ | $\gcd (\, 0! \, , \, 0! \,)$ |

发现 **$i=4$ 时答案的增加量**是在 **$i=3$ 时的答案增加量**的基础上**增加了一部分**(已标红)而来的。

我们把标红部分提取出来：

$i=4: 0!, \, 1!, \, 1!, \, 0!$

如果你继续往下写：

| $i=5: 0!, \, 1!, \, 2!, \, 1!, \, 0!$ |
| :------- |
| $i=6: 0!, \, 1!, \, 2!, \, 2!, \, 1!, \,0!$ |
| $i=7: 0!, \, 1!, \, 2!, \,3!, \, 2!, \, 1!, \,0!$ |
| $i=8: 0!, \, 1!, \, 2!, \,3!, \, 3!, \, 2!, \, 1!, \,0!$ |
| $i=9: 0!, \, 1!, \, 2!, \,3!, \,4!, \, 3!, \, 2!, \, 1!, \,0!$ |
| ....... |

你会发现，每一次**答案增加量**的**增加量**的**增加量**为

$${\color{Blue}i \; mod \; 2 == 1 \; ? \; (\left \lfloor \frac{i-1}{2} \right \rfloor)! \; : \;  (\left \lfloor \frac{i-2}{2} \right \rfloor)!}$$

然后我们就可以愉快地递推啦。

这题在数学题里算是挺好做的了。

定义 $f[i]$ 为 $i$ 的**答案**，$g[i]$ 为 $i$ 的**答案的增加量**，$res$ 为**答案增加量的增加量**。（其实 $g[i]$ 也没必要开个数组，直接开个 $res$ 一样的中间变量记一下就行）。

具体转移请参见代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 1e6 + 10;
const int mod = 10086001;
ll f[maxn];
ll g[maxn];
ll jc[maxn];
ll res;
int main() {
    jc[0] = 1;
    for (int i = 1; i <= 1000000; ++i) jc[i] = jc[i - 1] * i % mod;
    f[1] = 1;
    g[1] = 1;
    res = 1;
    for (int i = 2; i <= 1000000; ++i) {
    	res = res + (i & 1 ? jc[(i - 1) / 2] : jc[(i - 2) / 2]);
        if (res >= mod) res %= mod;
        g[i] = g[i - 1] + res;
        if (g[i] >= mod) g[i] %= mod;
        f[i] = f[i - 1] + g[i];
        if (f[i] >= mod) f[i] %= mod;
    }	
    int T;
    cin >> T;
    while (T--) {
        ll n;
        scanf("%lld", &n);
        cout << f[n] << '\n';
    }
    return 0;
}
```

---

## 作者：_7thRC_CB_CRP_ (赞：0)

# Solution

~~真搞不懂为什么偏要用函数替代阶乘符号。~~

$$
\begin{aligned}
&=\sum_{i=1}^m\sum_{j=1}^i\sum_{k=1}^j\gcd(\frac{(i-j)!}{j!}j!,\frac{(j-k)!}{k!}k!)
\\
&=\sum_{i=1}^m\sum_{j=1}^i\sum_{k=1}^j\gcd((i-j)!,(j-k)!)
\\
&=\sum_{i=1}^m\sum_{j=1}^i\sum_{k=1}^j\min(i-j,j-k)!
\\
&=\sum_{i=0}^{\lfloor \frac{m} 2\rfloor}i!a_i
\end{aligned}
$$

令 $a_i$ 为 $\min(i-j,j-k)=i$ 的个数。

则：

$$
\begin{aligned}
a_x&=\sum_{i=2x+1}^m (i-2x)+\sum_{i=1}^{m-2x} (m-2x-i)
\\
&=\sum_{i=1}^{m-2x}i+\sum_{i=1}^{m-2x-1}i
\\
&=\frac{(m-2x)(m-2x+1)+(m-2x-1)(m-2x)}{2}
\\
&=(m-2x)^2
\end{aligned}
$$

那么代入原式：

$$\sum_{x=0}^{\lfloor \frac{m} 2\rfloor}(m-2x)^2x!$$

拆开：

$$\sum_{x=0}^{\lfloor \frac{m} 2\rfloor}m^2x!-4mx(x!)+4x^2x!$$

我们把每一项拆开，然后把固定的提出来发现只需枚举这三个式子 $x!,x(x!),x^2x!$ 的前缀即可。

这样大家都做得出来了吧。

---

## 作者：hundunqidian (赞：0)

# Luogu P6042 
------------
## STEP 1：转化题意
 $$\begin{aligned} \sum _ {i = 1} ^ n \sum _ {j = 1} ^ i \sum _ {k = 1} ^ j \min(i - j,j - k)!\end{aligned} $$

2023.11.17upd：发现上面的式子漏了一个阶乘，如有误导，深感抱歉。

## STEP 2：求解
我们考虑枚举结果的做法，即求 $\min(i - j,j - k)=a$ 的出现次数。

分类讨论：
		
1. $\ i - j = j - k = a$，有 $ n - 2a $ 次。

2. $\ i - j = a $，$ j - k > a $，有 $ (n-2a-1)+(n-2a-2)+ \cdots\ +2+1 $ 次。


3. $\ i - j > a $，$ j - k = a $，有 $ (n-2a-1)+(n-2a-2)+ \cdots\ +2+1$ 次（同上）。

总计 $ (n-2a)^2 $ 次。

答案即求：

$$\begin{aligned} \sum _ {a = 0} ^  {\lfloor{ n-1 \over 2 } \rfloor} \end{aligned} \ (n-2a)^2\times a!  $$

~~完结撒花。~~

我们发现本题 $T,n \le 10^6 $，上面 $ O(Tn) $ 的做法不能通过此题。
## STEP 3：处理多测
考虑预处理结果，然后 $O(1)$ 回答。

但上面的式子并不容易预处理，考虑可否拆解之。

用完全平方公式拆解 $(n-2a)^2\times a! $ 得： $n^2\times a!-4\times a\times n\times a!+4\times a^2\times a!$，我们可以对每一项分别预处理，由于 $n$ 是常量，我们只对含 $a$ 的部分预处理即可，即预处理 $a!$，$4a\times a!$，$4a^2\times a!$ 的前缀和。

## STEP 4：代码
部分变量解释：

$ fac[i]=i! $

$ pre1[a]$：$a! $ 的前缀和。

$ pre2[a]$：$a!\times 4a $ 的前缀和。

$ pre3[a]$：$a!\times 4a^2 $ 的前缀和。

答案即：

$$ pre1[{\lfloor{(n-1)\over2 }\rfloor}]\times n^2-pre2[{\lfloor{(n-1)\over2}\rfloor}]\times n+pre3[{\lfloor{(n-1)\over2}\rfloor}] $$

注意计算时加模数防止出现负数。


------------

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int const X=1e6+100,P=10086001;
int T,n,t;
int fac[X],pre1[X],pre2[X],pre3[X];
signed main(){
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
	fac[0]=pre1[0]=1;
	for(int i=1;i<=5e5+10;i++){
		fac[i]=fac[i-1]*i%P;
		pre1[i]=(pre1[i-1]+fac[i])%P;
		pre2[i]=(pre2[i-1]+fac[i]*4*i%P)%P;
		pre3[i]=(pre3[i-1]+fac[i]*4*i%P*i%P)%P;
	}
	cin>>T;
	while(T--){
		cin>>n;
		t=(n-1)>>1;
		cout<<(pre1[t]*n%P*n%P-pre2[t]*n%P+pre3[t]+P)%P<<'\n'; //此处记得+P
	}
	return 0;
} 
```

---

## 作者：Christophe_ (赞：0)

容易发现，所求即为 $\sum\limits_{i=1}^{n}{\sum\limits_{j=1}^{i}{\sum\limits_{k=1}^{j}{\min(i-j,j-k)!}}}$ .

直接枚举原式是 $O(n^3)$ 的，但是枚举 $\min(i-j,j-k)$ 是 $O(n)$ 的，我们可以考虑以此来减少枚举量.

枚举 $t=\min(i-j,j-k)$，$t$ 的下界显然是 $0$.

对于每一个间隔 $t$，分情况讨论：

- $t=\min(i-j,j-k)=i-j$，即 $j=i-t$：

对于每一个 $i$，我们考虑放置 $k \le i-t$ 且 $(i-t)-k ≥ t$ 的方案数，

即 $k∈[1,i-2t]$，故方案数为 $i-2t$，

显然 $i$ 的下界为 $2t+1$，上界为 $n$，

故此时整体对答案的贡献为 $t!\times(\sum\limits_{i=2t+1}^{n}{i-2t})$ ，

同时这种情况中 $t$ 的上界为 $\lfloor \frac{n-1}{2} \rfloor$ .

- $t=\min(i-j,j-k)=j-k$，即 $j=k+t$：

对于每一个 $k$，我们考虑放置 $i ≥ k+t$ 且 $ i-(k+t) > t$ 的方案数

（注意：这里没有取到等号是因为 $i-j=j-k$ 在上一种情况中已经算过，需要避免重复计数），

即 $i∈[k+2t+1,n]$，故方案数为 $n-2t-k$，

显然 $k$ 的下界为 $1$，上界为 $n-2t-1$，

故此时整体对答案的贡献为 $t!\times(\sum\limits_{k=1}^{n-2t-1}{n-2t-k})$ ，

同时这种情况中 $t$ 的上界为 $\lfloor \frac{n-2}{2} \rfloor$ .

进一步分析可知，当 $t=\lfloor \frac{n-1}{2} \rfloor$ 时，$k=n-2t$，第二种情况的式子对答案的贡献为 $0$，不会造成影响，因此 $t$ 的上界统一为 $\lfloor \frac{n-1}{2} \rfloor$.

因此所求即为：

$\sum\limits_{t=0}^{\lfloor \frac{n-1}{2} \rfloor}{t!\times (\sum\limits_{i=2t+1}^{n}{i-2t}+\sum\limits_{k=1}^{n-2t-1}{n-2t-k})}$

暴力拆开求和，得到所求为：

$\sum\limits_{t=0}^{\lfloor \frac{n-1}{2} \rfloor}{t!\times (\frac{(n+2t+1)(n-2t)}{2}-2t(n-2t)+(n-2t-1)n-2t(n-2t-1)-\frac{(n-2t-1)(n-2t)}{2})}$

化简后即为（附 [化简用工具](https://www.wolframalpha.com/input?i=%28n%2B2t%2B1%29%28n-2t%29%2F2-2t%28n-2t%29%2B%28n-2t-1%29n-2t%28n-2t-1%29-%28n-2t-1%29%28n-2t%29%2F2)）：

$\sum\limits_{t=0}^{\lfloor \frac{n-1}{2} \rfloor}{t!\times (n-2t)^2}$

展开并暴力将最外层的求和式拆开，可得：

$n^2(\sum\limits_{t=0}^{\lfloor \frac{n-1}{2} \rfloor}{t!})-4n(\sum\limits_{t=0}^{\lfloor \frac{n-1}{2} \rfloor}{t!\times t})+4(\sum\limits_{t=0}^{\lfloor \frac{n-1}{2} \rfloor}{t!\times t^2})$

预处理各自的前缀和即可 $O(1)$ 回答单次询问，时间复杂度 $O(n+T)$.

代码如下：

```cpp
// Problem: P6042 「ACOI2020」学园祭
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P6042
// Memory Limit: 128 MB
// Time Limit: 500 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N=1e6+3,P=10086001;
inline int read(){
    int ret=0,f=1; 
	char ch=getchar();
    while(ch<'0'||ch>'9'){ if(ch=='-') f=-f; ch=getchar(); }
    while(ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=getchar();
    return ret*f;
}
inline void write(int x){        
    if(x<0){ putchar('-'); x=-x; }      
    if(x>9) write(x/10);     
    putchar(x%10+'0');     
}
int T,n,maxt,ans;
LL t0[N],t1[N],t2[N],s0[N],s1[N],s2[N];
int main(){
	T=read();
	t0[0]=1,t1[0]=0,t2[0]=0;
	s0[0]=t0[0],s1[0]=t1[0],s2[0]=t2[0];
	for(int t=1;t<N;++t){
		t0[t]=t0[t-1]*t%P;
		t1[t]=t0[t]*t%P;
		t2[t]=t1[t]*t%P;
	}
	for(int t=1;t<N;++t){
		s0[t]=(s0[t-1]+t0[t])%P;
		s1[t]=(s1[t-1]+t1[t])%P;
		s2[t]=(s2[t-1]+t2[t])%P;
	}
	while(T--){
		n=read();
		maxt=(n-1)>>1;
		ans=(((LL)n*n%P*s0[maxt]%P-4*n*s1[maxt]%P+4*s2[maxt]%P)%P+P)%P;
		write(ans),putchar('\n');
	}
	return 0;
}
```



---


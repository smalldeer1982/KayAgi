# [ZJOI2007] 报表统计

## 题目描述

小 Q 的妈妈是一个出纳，经常需要做一些统计报表的工作。今天是妈妈的生日，小 Q 希望可以帮妈妈分担一些工作，作为她的生日礼物之一。

经过仔细观察，小 Q 发现统计一张报表实际上是维护一个非负整数数列，并且进行一些查询操作。

在最开始的时候，有一个长度为 $n$ 的整数序列 $a$，并且有以下三种操作：
        
- `INSERT i k`：在原数列的第 $i$ 个元素后面添加一个新元素 $k$；如果原数列的第 $i$ 个元素已经添加了若干元素，则添加在这些元素的最后（见样例说明）。
- `MIN_GAP`：查询相邻两个元素的之间差值（绝对值）的最小值。
- `MIN_SORT_GAP`：查询所有元素中最接近的两个元素的差值（绝对值）。

于是小 Q 写了一个程序，使得程序可以自动完成这些操作，但是他发现对于一些大的报表他的程序运行得很慢，你能帮助他改进程序么？

## 说明/提示

#### 样例输入输出 1 解释

一开始的序列为 $\{5,3,1\}$。

执行操作 `INSERT 2  9` 将得到 $\{5,3,9,1\}$，此时 `MIN_GAP` 为 $2$，`MIN_SORT_GAP` 为 $2$。

再执行操作 `INSERT 2  6` 将得到：$\{5,3, 9, 6, 1\}$。

注意这个时候原序列的第 $2$ 个元素后面已经添加了一个 $9$，此时添加的 $6$ 应加在 $9$ 的后面。这个时候 `MIN_GAP` 为 $2$，`MIN_SORT_GAP` 为 $1$。

---


#### 数据规模与约定

对于全部的测试点，保证 $2 \le n, m \le 5\times10^5$，$1 \leq i \leq n$，$0 \leq a_i, k \leq 5 \times 10^8$。

## 样例 #1

### 输入

```
3 5
5 3 1
INSERT 2 9
MIN_SORT_GAP
INSERT 2 6
MIN_GAP
MIN_SORT_GAP
```

### 输出

```
2
2
1
```

# 题解

## 作者：cmd2001 (赞：125)

```plain
首先这题不用手写平衡树，不用堆，只用两个数组，两个multiset和一个变量就好了......
然而语文神题不好看懂......
首先理解题意：我们无非就是把这个序列分成n段，在每一段结尾插入新元素。
比如说样例，我们可以理解为：
[5][3,9,6][1]。
其中括号括起来的为每一段所含的元素。
我们首先维护两个数组，st[]和ed[]表示每一段开头的元素和结尾的元素。我们在更新相邻差值的时候只用考虑新插入的值和原结尾的差以及和下一段开头的差就好了。
这样，我们维护两个 multiset<int> ，一个叫 full ，表示全部 元素(存在的数值)。另一个叫 delta ，表示全部 差值 。
插入新元素的时候，我们把他在 full 中找到前驱后继分别作差，更新 排序后最小差 。
然后在 delta 中删除 现在本段结尾与下一段开头的差 ，插入 新值与当前本段结尾的差 和 新值与下一段开头的差 。
注意必须用 multiset ， 因为同样的键值可能出现多次。
另外删除时要 erase 掉 find 后的 iterator ，不能直接 erase 数值，否则就把出现多次的同一个数值全删了......
最后上代码。大牛分站O2信仰跑。
```
```cpp
#include<cstdio>
#include<set>
#include<cstdlib>
#include<cctype>
using namespace std;
const int maxn=5e5+1e2;
const int inf=0x3f3f3f3f;

multiset<int> delta,full;
int st[maxn],ed[maxn];
int srt=inf;
int n,m;

inline void update_srt(int x)
{
    multiset<int>::iterator it = full.lower_bound(x);
    int nw = *it - x;
    --it;
    nw = min( nw , x - *it );
    srt = min( srt , nw );
    full.insert(x);
}

inline void replac(int pos,int x)
{
    delta.insert( abs( x - ed[pos] ) );
    if( pos != n )
        delta.erase( delta.find( abs( st[pos+1] - ed[pos] ) ) ),
        delta.insert( abs( st[pos+1] - x ) );
    ed[pos] = x;
}

inline int getint()
{
    int ret = 0 , fix = 1;
    char ch = getchar();
    while( !isdigit(ch) )
    {
        if( ch == '-' )
            fix = -1;
        ch = getchar();
    }
    while( isdigit(ch) )
        ret = ret * 10 + ( ch - '0' ),
        ch = getchar();
    return ret * fix;
}

int main()
{
    static char str[1<<5];
    n = getint() , m = getint();
    for(int i=1;i<=n;i++)
        st[i] = ed[i] = getint();
    
    full.insert(inf),
    full.insert(-inf);
    for(int i=1;i<n;i++)
        delta.insert( abs( st[i+1] - ed[i] ) );
    for(int i=1;i<=n;i++)
        update_srt(st[i]);
    for(int i=1,pos,x;i<=m;i++)
    {
        scanf("%s",str);
        if( *str == 'I' )
        {
            pos = getint() , x = getint();
            update_srt(x);
            replac(pos,x);
        }
        else if( str[4] == 'S' )
            printf("%d\n",srt);
        else
            printf("%d\n",*delta.begin());
    }
    return 0;
}
```

---

## 作者：皎月半洒花 (赞：39)

这个题是真毒瘤……我足足调试了19个小时，换了四种不同的写法，跑去问了机房里炒鸡厉害的大佬$qyf$3次才把它在$TLE$的条件下开$O_2AC$了$ORZZZZ$.

代码量$7k$（由于不会写成员函数所以代码长的很）

所以我是真的菜。

哦，这道题的难度在我这个不会写成员函数的蒟蒻看来，应该算是一道好题了，因为它并没有其他的紫题那样水。

哦，您觉得简单，那您强好了。

那么其实很显然，这个题我们可以用堆（失败），可以用$STL$ 里的$set$，也可以用两棵平衡树。而在这里我由于不想手写堆，所以用的$STL$结果炸了。

那么，一棵平衡树维护最小不相邻差值，一棵平衡树维护最小相邻差值，前者不带删除，后者带删除。

## 维护不相邻最小差值：

每次插入一个数时，找它的前驱后继，然后更新答案变量$minn$.

## 维护相邻最小差值：

我们记录一下原序列每个元素之后插入的元素中最后插入的数。然后每次$insert$之后删除一次插入两次即可。

$Code$:

我辣鸡，凑合着看吧。

当然，我不会写成员函数（其实是一开始没用成员函数之后，写了一半懒得用了）。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#define MAXN 500001
#define Inf 2147483600
#define ll long long

using namespace std;
struct tree{
    ll v,sub,son[2],f,cnt;
}s[MAXN<<1],S[MAXN<<1];
ll minn=Inf,root,wz,num[MAXN],base[MAXN],i,now,res,pre,suffix,fa;
ll _res,_wz,_root,_now,_fa,_rank,_old_root;

inline long long qread(){
    long long num=0;
    char ch=getchar();
    while(!isdigit(ch)){
        ch=getchar();
    }
    while(isdigit(ch)){
        num=(num<<1)+(num<<3)+ch-'0';
        ch=getchar();
    }
    return num;
}
/*___________________________________________________________*/
inline ll my_abs(ll x){
    return x>0?x:-x;
}
inline bool which(ll x){
    return x==s[s[x].f].son[1];
}
inline void update(ll x){
    if(x){
    s[x].sub=s[x].cnt;
    if(s[x].son[0])s[x].sub+=s[s[x].son[0]].sub;
    if(s[x].son[1])s[x].sub+=s[s[x].son[1]].sub;
    }
}
inline void rotate(ll x){
    ll fnow=s[x].f,ffnow=s[fnow].f;
    bool w=which(x);
    s[fnow].son[w]=s[x].son[w^1];
    s[s[fnow].son[w]].f=fnow;
    s[fnow].f=x;
    s[x].f=ffnow;
    s[x].son[w^1]=fnow;
    if(ffnow){
        s[ffnow].son[s[ffnow].son[1]==fnow]=x;
    }
    update(fnow);
}
inline void splay(ll x,ll goal){
    for(ll qwq;(qwq=s[x].f)!=goal;rotate(x)){
        if(s[qwq].f!=goal){
            rotate(which(x)==which(qwq)?qwq:x);
        }
    }
    if(goal==0){
        root=x;
    }
}
inline void insert(ll x){
    if(!root){
        wz++;
        s[wz].son[0]=s[wz].son[1]=s[wz].f=0;
        root=wz;
        s[wz].sub=s[wz].cnt++;
        s[wz].v=x;
        return ;
    } 
    now=root,fa=0;
    while(1){
        if(x==s[now].v){
            s[now].cnt++;
            update(now);
            update(fa);
            splay(now,0);
            break;
        }
        fa=now;
        now=s[now].son[s[now].v<x];
        if(!now){
            wz++;
            s[wz].son[0]=s[wz].son[1]=0;
            s[wz].f=fa;
            s[wz].sub=s[wz].cnt++;
            s[fa].son[s[fa].v<x]=wz;
            s[wz].v=x;
            update(fa);
            splay(wz,0);
            break; 
        }
    }
}
inline ll find_pre(){
    res=s[s[root].son[0]].v,now=s[root].son[0];
    if(s[root].cnt>1)
    return s[root].v;
    while(s[now].son[1]){
        res=s[s[now].son[1]].v;
        now=s[now].son[1];
    }
    return res;
}
inline ll find_suffix(){
    res=s[s[root].son[1]].v,now=s[root].son[1];
    if(s[root].cnt>1)
    return s[root].v;
    while(s[now].son[0]){
        res=s[s[now].son[0]].v;
        now=s[now].son[0];
    }
    return res;
}
inline void init_insert(ll now){
    insert(now); 
    suffix=find_suffix();
    pre=find_pre();
    if(suffix!=Inf){
        minn=min(minn,my_abs(suffix-now));
    }   
    if(pre!=-Inf){
        minn=min(minn,my_abs(pre-now));
    }
}

/*___________________________________________________________*/

inline bool S_which(ll x){
    return x==S[S[x].f].son[1];
}
inline void S_clear(ll x){
    S[x].cnt=S[x].son[1]=S[x].son[0]=S[x].f=S[x].sub=S[x].v=0;
    if(x==-wz)_wz--;
}
inline void S_update(ll x){
    if(x){
    S[x].sub=S[x].cnt;
    if(S[x].son[0])S[x].sub+=S[S[x].son[0]].sub;
    if(S[x].son[1])S[x].sub+=S[S[x].son[1]].sub;
    }
}
inline void S_rotate(ll x){
    ll fnow=S[x].f,ffnow=S[fnow].f;
    bool w=S_which(x);
    S[fnow].son[w]=S[x].son[w^1];
    S[S[fnow].son[w]].f=fnow;
    S[fnow].f=x;
    S[x].f=ffnow;
    S[x].son[w^1]=fnow;
    if(ffnow){
        S[ffnow].son[S[ffnow].son[1]==fnow]=x;
    }
    S_update(fnow);
}
inline void S_splay(ll x,ll goal){
    for(ll qwq;(qwq=S[x].f)!=goal;S_rotate(x)){
        if(S[qwq].f!=goal){
            S_rotate(S_which(x)==S_which(qwq)?qwq:x);
        }
    }
    if(goal==0){
        
        _root=x;
    }
}
inline void S_insert(ll x){
    if(!_root){
        _wz++;
        S[_wz].son[0]=S[_wz].son[1]=S[_wz].f=0;
        _root=_wz;
        S[_wz].sub=S[_wz].cnt++;
        S[_wz].v=x;
        return ;
    } 
    _now=_root,_fa=0;
    while(1){
        if(x==S[_now].v){
            S[_now].cnt++;
            S_update(_now);
            S_update(_fa);
            S_splay(_now,0);
            break;
        }
        _fa=_now;
        _now=S[_now].son[S[_now].v<x];
        if(!_now){
            _wz++;
            S[_wz].son[0]=S[_wz].son[1]=0;
            S[_wz].f=_fa;
            S[_wz].sub=S[_wz].cnt++;
            S[_fa].son[S[_fa].v<x]=_wz;
            S[_wz].v=x;
            S_update(_fa);
            S_splay(_wz,0);
            break; 
        }
    }
}
inline ll S_find_pre(){
    _now=S[_root].son[0];
    while(S[_now].son[1]){
        _now=S[_now].son[1];
    }
    return _now;
}
inline ll S_find_rank(ll x){
    _now=_root,_rank=0;
    while(1){
        if(x<S[_now].v){
            _now=S[_now].son[0];
        }
        else {
            _rank+=(S[_now].son[0]?S[S[_now].son[0]].sub:0);
            if(x==S[_now].v){
                S_splay(_now,0);
                return _rank+1;
            }
            _rank+=S[_now].cnt;
            _now=S[_now].son[1];
        }
    }	
        
}
inline ll S_find_num(ll x){
    _now=_root;
    while(1){
        if(S[_now].son[0]&&x<=S[S[_now].son[0]].sub){
            _now=S[_now].son[0];
        }
        else {
            ll temp=(S[_now].son[0]?S[S[_now].son[0]].sub:0)+S[_now].cnt;
            if(x<=temp)return S[_now].v;
            x-=temp;
            _now=S[_now].son[1];
        }
    }
} 
inline void S_delete(ll x){
    int hhh=S_find_rank(x);
    if(S[_root].cnt>1){
        S[_root].cnt--;
        S_update(_root);
        return ;
    }
    if(!S[_root].son[0]&&!S[_root].son[1]){
        S_clear(_root);
        _root=0;
        return ;
    }
    if(!S[_root].son[0]){
        _old_root=_root;
        _root=S[_root].son[1];
        S[_root].f=0;
        S_clear(_old_root);
        return ;
    }
    if(!S[_root].son[1]){
        _old_root=_root;
        _root=S[_root].son[0];
        S[_root].f=0;
        S_clear(_old_root);
        return ;
    }
    int left_max=S_find_pre(),_old_root=_root;
    S_splay(left_max,0);
    S[_root].son[1]=S[_old_root].son[1];
    S[S[_old_root].son[1]].f=_root;
    S_clear(_old_root);
    S_update(_root);
}

/*___________________________________________________________*/

int main(){
    ll a,n,m,b;
    char s[20];
    cin>>n>>m;
    insert(Inf);
    insert(-Inf);
    for(i=1;i<=n;i++){
        base[i]=num[i]=qread();
        if(i!=1)S_insert(my_abs(base[i-1]-base[i]));
        init_insert(base[i]);
    }
    for(register int i=1;i<=m;i++){
        scanf("%s",s);
        int ss=strlen(s);
        if(ss==7) {
            printf("%d\n",S_find_num(1));
            continue;
        }
        else if(ss==12){
            printf("%d\n",minn);
        	continue;
        }
        else {
            a=qread();
            b=qread();
            if(a<n){
            S_delete(my_abs(num[a]-base[a+1]));
            S_insert(my_abs(b-base[a+1]));
            }
            S_insert(my_abs(b-num[a]));
            init_insert(b);
            num[a]=b;
            continue;
        }
    }
}
```

# $\color{gold}Think$  $~$ $\color{silver}Twice$ $,$ $\color{cyan}Code$ $~$ $\color{red}Once.$


---

## 作者：onglu (赞：37)

看了半天怎么就没有Splay+堆的题解呢。。  
题意是很简单的。。  
就是一开始有$n$个元素，每个元素相当于一个队列，总的序列是所有队列按顺序拼接起来的序列，有下面三种操作。  
操作一：在原序列第$k$个队列插入一个$x$  
操作二：查询总序列里面相邻元素的差值的绝对值的最小值。  
操作三：查询总序列里面所有元素差值的绝对值的最小值。 

第一个操作应该是建立在二，三操作的基础上进行的。。  
我们先对二，三操作进行讨论。  
  
第三个操作比较简单，我们只要建立一个平衡树，每次插入元素之后，查询这个元素和排名相邻的元素的差值，然后统计出最小值就可以了。  
  
重点是第二个操作。  
发现如果我们插入一个元素，这个元素会打破一对元素的相邻关系，并且建立两队相邻关系，每次的答案就是所有的相邻关系中差值最小的一对。  
差值最小的一对很容易用堆来维护，我们的问题就变成了维护一个可以删除的堆。  
  
这个堆也很容易实现。。  
我们开两个堆，第一个堆储存已经插入的数，第二个堆储存已经删除的数，每次弹出时我们只需要判断两堆的堆顶是不是一样，如果一样就同时弹掉，直到堆顶不一样。  
  
那么第一个操作就是这两个操作的结合了吧。。不讲了。。  
注意平衡树判断前驱，后继的时候要注意判断当前元素是否有多个，如果有多个的话说明最小值是零。  
  
同时有一个卡常小技巧。。  
最小值是一直向着$0$贴近的，不会变成负数也不会变大，所以当我们发现最小值变成$0$的时候，我们就不需要再进行平衡树操作了（卡了这个之后我代码快了700ms）。  
当然最开始的时候我们要对所有的数据进行初始化，确定每个数据在最终的数组中的位置。(不然用vector好像也是可以的，没试过，你们可以去试试）  
  
下面就直接贴代码（常熟巨大不开氧气2336ms,开了氧气也是830ms）
```cpp
#include <bits/stdc++.h>
#define fa(x) tree[x].fa
#define son(x,k) tree[x].ch[k]
#define cnt(x) tree[x].cnt
#define val(x) tree[x].val
#define siz(x) tree[x].siz
using namespace std;
const int N=5e6+1009;
const int inf=(1<<31)-1;
struct Hp{
	priority_queue<int>q1,q2;
	Hp(){
		while(!q1.empty())q1.pop();
		while(!q2.empty())q2.pop();
	}
	void Insert(int x){
		q1.push(-x);
	}
	void Delete(int x){
		q2.push(-x);
	}
	int Top(){
		while(!q2.empty()&&!q1.empty()){
			if(q1.top()!=q2.top())return -q1.top();
			q1.pop();q2.pop();
		}
	}
}Heap;
int read(){
	char c;int num,f=1;
	while(c=getchar(),!isdigit(c))if(c=='-')f=-1;num=c-'0';
	while(c=getchar(), isdigit(c))num=num*10+c-'0';
	return f*num;
}
int abs(int x){return x<0?-x:x;}
int rt,tot;
int n,m,pos[N],minn=(1<<31)-1;
int ord[N][10],a[N],b[N];

struct Node{
    int fa,ch[2],siz,cnt,val;
}tree[N];
bool chk(int x){return son(fa(x),1)==x;}
void update(int x){siz(x)=siz(son(x,0))+siz(son(x,1))+cnt(x);}
int New(int x,int pre){
    tot++;
    if(pre)son(pre,x>val(pre))=tot;
    son(tot,0)=son(tot,1)=0;
    cnt(tot)=siz(tot)=1;
    val(tot)=x;fa(tot)=pre;
    return tot;
}
void rotate(int x){
    int y=fa(x),z=fa(y),k=chk(x);
    son(z,chk(y))=x;fa(x)=z;
    son(y,k)=son(x,k^1);fa(son(x,k^1))=y;
    son(x,k^1)=y;fa(y)=x;
    update(y);update(x);
}
void splay(int x,int goal=0){
    while(fa(x)!=goal){
        int y=fa(x),z=fa(y);
        if(z!=goal){
            if(chk(y)==chk(x))rotate(y);
            else rotate(x);
        }
        rotate(x);
    }
    if(!goal)rt=x;
}
void Insert(int x){
    int cur=rt,p=0;
    while(cur&&val(cur)!=x)
        p=cur,cur=son(cur,x>val(cur));
    if(cur)cnt(cur)++;
    else cur=New(x,p);
    splay(cur);
}
void Find(int x){
    if(!rt)return ;
    int cur=rt;
    while(son(cur,x>val(cur))&&val(cur)!=x)
        cur=son(cur,x>val(cur));
    splay(cur);
}
int Pre(int x){
    Find(x);
    if(val(rt)<x||(val(rt)==x&&cnt(rt)>1))return rt;
    int cur=son(rt,0);
    while(son(cur,1))cur=son(cur,1);
    return cur;
}
int Succ(int x){
    Find(x);
    if(val(rt)>x||(val(rt)==x&&cnt(rt)>1))return rt;
    int cur=son(rt,1);
    while(son(cur,0))cur=son(cur,0);
    return cur;
}
int main()
{
	n=read();m=read();
	Insert(inf);Insert(-inf);
	for(int i=1;i<=n;i++){
		int x=read();
		pos[i]=x;
		b[i]++;
	}
	for(int i=1;i<=m;i++){
		char c[19];
		scanf("%s",c);
		int len=strlen(c);
		if(len==6){
			ord[i][0]=1;
			ord[i][1]=read();
			ord[i][2]=read();
			b[ord[i][1]]++;
			ord[i][3]=b[ord[i][1]];
		}else if(len==7)ord[i][0]=2;
		else ord[i][0]=3;
	}
	for(int i=1;i<=n;i++){
		if(i!=1)Heap.Insert(abs(pos[i]-pos[i-1]));
		if(minn!=0){
			Insert(pos[i]);
			int xx=val(Succ(pos[i])),yy=val(Pre(pos[i]));
			if(xx!=inf&&xx!=-inf)minn=min(minn,xx-pos[i]);
			if(yy!=inf&&yy!=-inf)minn=min(minn,pos[i]-yy);
		}
		a[b[i-1]+1]=pos[i];
		b[i]+=b[i-1];
	}
	for(int i=1;i<=m;i++){
		if(ord[i][0]==1){
			if(minn!=0) Insert(ord[i][2]);
			a[b[ord[i][1]-1]+ord[i][3]]=ord[i][2];
			
			Heap.Insert(abs(a[b[ord[i][1]-1]+ord[i][3]]-a[b[ord[i][1]-1]+ord[i][3]-1]));
			Heap.Insert(abs(a[b[ord[i][1]-1]+ord[i][3]]-a[b[ord[i][1]]+1]));
			Heap.Delete(abs(a[b[ord[i][1]]+1]-a[b[ord[i][1]-1]+ord[i][3]-1]));
			if(minn!=0){
				int xx=val(Succ(ord[i][2])),yy=val(Pre(ord[i][2]));
				if(xx!=inf&&xx!=-inf)minn=min(minn,xx-ord[i][2]);
				if(yy!=inf&&yy!=-inf)minn=min(minn,ord[i][2]-yy);
			}
		}else if(ord[i][0]==2)
			printf("%d\n",Heap.Top());
		else printf("%d\n",minn);
	}
	return 0;
}
```

---

## 作者：mulberror (赞：28)

# 前言
洛谷和网上的题解都好复杂哦，或者是`stl`水过。  
我就是冲着平衡树的标签来的，应该没有人和我想到一块去了。（希望管理员能通过这一篇题解，我觉得这篇博客写的挺好的，~~如果可以希望能置顶~~）  
窝的语文不怎么好，所以会有一些表达上的累赘或者是含糊不清，望各大佬海涵。  
日常宣传博客：[【传送门】](https://www.cnblogs.com/chhokmah/p/10645928.html)

-----
# 前置芝士
首先你一定要会平衡树（BST）。  
什么平衡树都可以，只要是能过掉[【模板】普通平衡树](https://www.luogu.org/problemnew/show/P3369)的都可以。  
关于平衡树的详细操作这里就不一一赘述了。  

------
# 正解
这一道题目看到的时候不能盲目思考能不能用一个数据结构一下子维护所有的正确答案，对于这一道题目是很难实现的。~~反正蒟蒻是实现不了~~
我们将这个问题一层一层的剖析一下。  

## 第一个操作
插入操作，因为是在每一个原来的数后面插入一个数。  
那么很容易想到用不定长数组`vector`来实现。  
因为这个满足`vector`的结尾插入和不妨碍其他数组的性质。  

## 第二个操作
查询相邻两个元素之间的差值（绝对值）的最小值。  
比较容易想到，如果我们已经处理好了之前的答案，那么只有在插入的时候会影响这个答案。这句话很重要。  
而且改变的肯定是一个`vector`的队尾和下一个`vector`的队首之间的答案。  
那么我们就将所有队尾和下一个`vector`的队首的差值维护一下。    
但是有修改的操作，所以我们每一次插入一个数，那么会造成以下两种情况：  
我们假设我们的数组是`v[n][n]`的`vector`，当前我们插入的数是第`x`个数组，权值为`Val`。每一个`vector`的结尾是`v[x].tail`，每一个`vector`的头是`v[x].head`。  

* 减少一个答案，也就是`v[x].tail`和`v[x+1].head`之间的答案  
* 增加两个答案，也就是`v[x].tail`和`k`和`v[x+1].head`和`k`之间的答案。  

反观上面两种情况，因为我们是维护最小值，那么可以用可修改的堆来维护，但是我比较弱，又比较懒，就写了一个带插入和删除的`Treap`，然后我们每一次需要输出答案的时候，只需要找到这个`Treap`中的最小值，也就是一直往左儿子走就可以了。  

## 第三个操作
这个操作就比较裸了，因为我们知道和当前这个数要差值最小，那么只有可能是他的前驱和后继。  
这个又是平衡树可以实现的操作，那么我们只需要一个可以实现查找前驱和后继的`BST`就可以了。窝还是用了`Treap`来实现。  

**ps.需要注意下，因为我们第三个操作只是在修改的时候有操作，如果没有插入操作前，我们这个做法就是错的，那么就预处理排序一下，然后得到最小的差值就可以了**

## 总结一下
* 操作1：`vector`暴力加入
* 操作2：`treap`维护差值
* 操作3：`treap`维护数值

------
# 复杂度分析
空间复杂度：$O(n)$  
时间复杂度：$O(nlogn)$  
代码复杂度：比较低。  
思维难度：比较低。

-----
# 代码
```cpp
#include <bits/stdc++.h>
#pragma GCC optimize(2)
#define inf 0x3f3f3f3f
#define pb push_back
#define N 1000005
using namespace std;
template <typename T>
inline void read(T &x) {//快读不说
    x = 0; T fl = 1; char ch = 0;
    for (; ch < '0' || ch > '9'; ch = getchar())
        if (ch == '-') fl = -1;
    for (; ch >= '0' && ch <= '9'; ch = getchar())
        x = (x << 1) + (x << 3) + (ch ^ 48);
    x *= fl;
}
vector<int> v[N];
map<int, int> mp;
struct Treap {//treap模板，有需要可以copy
    int tot, rt;
    struct node {
        int val, ch[2], rd, cnt, sz;
        void Init(int Val) { val = Val, rd = rand() % 233; sz = cnt = 1; ch[1] = ch[0] = 0; }
    }tr[N];
    void pushup(int nod) { tr[nod].sz = tr[tr[nod].ch[0]].sz + tr[tr[nod].ch[1]].sz + tr[nod].cnt; }
    void rotate(int &nod, int d) {
        int k = tr[nod].ch[d]; tr[nod].ch[d] = tr[k].ch[d ^ 1]; tr[k].ch[d ^ 1] = nod;
        pushup(nod); pushup(k); nod = k; 
    }
    void ins(int &nod, int val) {
        if (!nod) { nod = ++ tot; tr[nod].Init(val); }
        else {
            tr[nod].sz ++; 
            if (tr[nod].val == val) { tr[nod].cnt ++; return; }
            int d = val > tr[nod].val; 
            ins(tr[nod].ch[d], val);
            if (tr[nod].rd > tr[tr[nod].ch[d]].rd) rotate(nod, d);
        }
    }
    void del(int &nod, int val) {
    	if (!nod) return;
    	if (tr[nod].val == val) {
    		if (tr[nod].cnt > 1) { tr[nod].cnt --, tr[nod].sz --; return; } 
    		int d = tr[tr[nod].ch[0]].rd > tr[tr[nod].ch[1]].rd;
    		if (!tr[nod].ch[1] || !tr[nod].ch[0]) nod = tr[nod].ch[1] + tr[nod].ch[0];
    		else rotate(nod, d), del(nod, val);
		}
		else tr[nod].sz --, del(tr[nod].ch[tr[nod].val < val], val);
	}
    int pre(int nod, int val) {
        if (!nod) return -inf;
        if (tr[nod].val > val) return pre(tr[nod].ch[0], val);
        else return max(tr[nod].val, pre(tr[nod].ch[1], val));
    }
    int suc(int nod, int val) {
        if (!nod) return inf;
        if (tr[nod].val < val) return suc(tr[nod].ch[1], val);
        else return min(tr[nod].val, suc(tr[nod].ch[0], val));
    }
    int Get_Min(int nod) {
    	if (!nod) return inf;
    	return min(tr[nod].val, Get_Min(tr[nod].ch[0]));
	}
}tp, tp2;//两个treap
int ans, n, m;
char opt[5];
int a[N];
int main() {
    srand(19260817);//随机种子
    read(n); read(m); ans = inf;
    for (int i = 1; i <= n; i ++) { v[i].clear(); read(a[i]); v[i].pb(a[i]); tp.ins(tp.rt, a[i]); }
    for (int i = 2; i <= n; i ++) tp2.ins(tp2.rt, abs(v[i][0] - v[i - 1][0]));
    sort(a + 1, a + 1 + n); for (int i = 2; i <= n; i ++) ans = min(ans, a[i] - a[i - 1]);//预处理出操作3的答案
    for (int i = 1; i <= m; i ++) {
        scanf("%s", opt);
        if (opt[0] == 'I') {
			int x, k; read(x); read(k);
			int lst = tp.pre(tp.rt, k), nxt = tp.suc(tp.rt, k); 
			tp.ins(tp.rt, k); //插入当前的数
			ans = min(ans, min(abs(lst - k), abs(nxt - k)));//查找前驱和后继来更新答案
			tp2.del(tp2.rt, abs(v[x][(int)v[x].size() - 1] - v[x + 1][0])); //删除原先答案
			tp2.ins(tp2.rt, abs(v[x][(int)v[x].size() - 1] - k)); 
			tp2.ins(tp2.rt, abs(k - v[x + 1][0])); //加入现在答案
			v[x].pb(k); //插入这个数
        }
        if (opt[4] == 'G') printf("%d\n", tp2.Get_Min(tp2.rt));//查找最小差值
        if (opt[4] == 'S') printf("%d\n", ans);
    }
    return 0;
}
```
----
# 总结一下
这里我并没有把`sort`看成`stl`因为太习惯了。  
我觉得吧，我并不是对`stl`有偏见，虽然`stl`在考场的时候可以救命，但是在平时的训练我还是尽可能的少用`stl`，像平衡树这种东西，多敲敲除了费时间，对于自己的代码能力还是有帮助的。  
自己层层剖析问题的能力还是需要加强。（我果然是一个蒟蒻）  
这个程序在`bzoj`上过不掉，好像超时了，但是在洛谷还是稳稳的过掉了。

---

## 作者：一叶知秋。 (赞：19)

感谢 @[cmy962085349](https://www.luogu.org/space/show?uid=32483) 提供的hack数据，已经改对了。

------------

先声明，我好像是题解里写双fhq treap里唯一能过的...（最后两个点啊）

------------

思路:首先看题目，MIN_GAP_SORT明显是求它的前驱与后继(可能有相同的)，所以就用平衡树，但是又要求两个相邻的数的差，就可以有再开一个平衡树存放差值

实现:抛开~~奇奇怪怪的的~~题面，主要考虑这三个操作：

1、INSERT i k:

这个很简单，用链表就行了（数组模拟的），但是要注意，插入的时候，要接着上一个在这插入的，还要做双向链表，数组要记得开两倍

最重要的是，插入了以后，这个数的前一个数与后一个数的差要在存放相邻两个数的差的fhq treap里删除，并插入这个数与前一个数的差和这个数与后一个数的差要存进去

2、MIN_GAP:

做完插入，就在存差的fhq treap查rank1好了(最左边的那个节点)

3、MIN_SORT_GAP:

为了避免查前驱与后继时出现自己(不是另一个与自己相同的数)，所以插入时(分裂后，合并前，这样正好符合查前驱与后继的标准)就比较取小，询问时直接输出就好了


P.S. 这道题写两个平衡树过后面两个点很关键的是卡常(O2也随你了)!原本T后面两个点的代码加上  与用 char而不用string 就过了，所以，卡常有的时候还是很重要的!(或者我人丑常数大吧)

再P.S. 似乎经过 @[cmy962085349](https://www.luogu.com.cn/user/32483) 的hack数据更正以后，似乎并不需要过于卡常了（说明题解里双平衡树还是因为写错了而T了后面两个点），似乎不用cin与cout就能过，不需要加什么 register 了（~~虽然我还是加了~~）

再再P.S. 又被hack了。。。 感谢 @[剑起头落地](https://www.luogu.com.cn/user/116251)指出在

```cpp
delete_val(abs(a[j+1]-a[b[j+1]]));
```

前应加上

```cpp
if(j<n)
```


附上AC代码:

```cpp
#include<cstdio>
#include<cstdlib>
#include<ctime>
#include<iostream>
using namespace std;

struct tree{//存每个值的数(不是差)
    int size,val,dat,l,r;
}tr[1000005];//数组记得开两倍

int s_tr,root,n,m,x,y,z,a[1000005],b[1000005],c[1000005];

int min_sort_gap;//MIN_SORT_GAP的答案

inline int abs(int a){
    return a<0?-a:a;
}

inline int min(int a,int b){
    return a<b?a:b;
}

//fhq treap常规操作

inline int new_tr(int val){
    tr[++s_tr].val=val;
    tr[s_tr].size=1;
    tr[s_tr].dat=rand();
    return s_tr;
}

inline void update(int p){
    tr[p].size=tr[tr[p].l].size+tr[tr[p].r].size+1;
}

void split(int p,int k,int &x,int &y){
    if(!p){
        x=y=0;
        return;
    }
    if(tr[p].val<=k)x=p,split(tr[p].r,k,tr[p].r,y);
    else y=p,split(tr[p].l,k,x,tr[p].l);
    update(p);
}

int merge(int x,int y){
    if(!x||!y)return x+y;
    if(tr[x].dat>tr[y].dat){
        tr[x].r=merge(tr[x].r,y);
        update(x);
        return x;
    }
    else {
        tr[y].l=merge(x,tr[y].l);
        update(y);
        return y;
    }
}

inline int Max(int x){//一棵fhq(可能是分裂后)中最大的
    while(tr[x].r)x=tr[x].r;
    return tr[x].val;
}

inline int Min(int y){//一棵fhq(可能是分裂后)中最大的
    while(tr[y].l)y=tr[y].l;
    return tr[y].val;
}

inline void insert(int val){
    split(root,val,x,y);
    if(tr[x].size)//要有才行
        min_sort_gap=min(min_sort_gap,abs(val-Max(x)));
    if(tr[y].size)//要有才行
        min_sort_gap=min(min_sort_gap,abs(Min(y)-val));
    root=merge(merge(x,new_tr(val)),y);
}

//存差值的fhq treap

struct tree1{
    int size,val,dat,l,r;
}tr1[1000005];

int s_tr1,root1;

inline int new_tr1(int val){
    tr1[++s_tr1].val=val;
    tr1[s_tr1].size=1;
    tr1[s_tr1].dat=rand();
    return s_tr1;
}

inline void update1(int p){
    tr1[p].size=tr1[tr1[p].l].size+tr1[tr1[p].r].size+1;
}

void split1(int p,int k,int &x,int &y){
    if(!p){
        x=y=0;
        return;
    }
    if(tr1[p].val<=k)x=p,split1(tr1[p].r,k,tr1[p].r,y);
    else y=p,split1(tr1[p].l,k,x,tr1[p].l);
    update1(p);
}

int merge1(int x,int y){
    if(!x||!y)return x+y;
    if(tr1[x].dat>tr1[y].dat){
        tr1[x].r=merge1(tr1[x].r,y);
        update1(x);
        return x;
    }
    else {
        tr1[y].l=merge1(x,tr1[y].l);
        update1(y);
        return y;
    }
}

inline void insert1(int val){
    split1(root1,val,x,y);
    root1=merge1(merge1(x,new_tr1(val)),y);
}

inline void delete_val(int val){//这棵fhq要能支持删除
    split1(root1,val,x,z);
    split1(x,val-1,x,y);
    y=merge1(tr1[y].l,tr1[y].r);
    root1=merge1(merge1(x,y),z);
}

inline int Min1(int y){
    while(tr1[y].l)y=tr1[y].l;
    return tr1[y].val;
}

char s[101];//卡常

inline int read(){//卡常
    int r=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9')r=(r<<1)+(r<<3)+c-'0',c=getchar();
    return r*f;
}

int main(){
    srand(time(0));
    n=read(),m=read();
    min_sort_gap=1e9+10;
    for(register int i=1;i<=n;i++){//卡常
        a[i]=read();
        insert(a[i]);
    }
    for(register int i=1;i<n;i++)//卡常减少if
        insert1(abs(a[i+1]-a[i])),c[i]=i+1;
    for(register int i=2;i<=n;i++)//卡常减少if，n+1是因为可能在第n个后面插入
        b[i]=i-1;
    b[n+1]=n;
    int cnt=n;
    for(register int i=1;i<=m;i++){//卡常
        scanf("%s",s);
        if(s[0]=='I'){
            int j=read(),k=read();
            if(j<n)delete_val(abs(a[j+1]-a[b[j+1]]));//因为插入后不在一起了，删除
            insert1(abs(a[b[j+1]]-k));//插入后多了两个差值(不算删除的)
            if(j<n)insert1(abs(k-a[j+1]));//可能插在第n个的后面
            a[++cnt]=k;//放进数组，这件事一定要在上述操作以后做，不然若连续插入在第n个数以后就挂了，因为第一次cnt+1后会直接取代n+1,b[n+1]也就没什么用了
            b[cnt]=b[j+1];//数组模拟链表
            c[cnt]=j+1;
            c[b[j+1]]=cnt;//记得修改前一个与后一个的指向
            b[j+1]=cnt;
            insert(k);
        }
        else {
            if(s[4]=='G')printf("%d\n",Min1(root1));//整棵fhq里最小的
            else printf("%d\n",min_sort_gap);
        }
    }
    return 0;
}
```

再次感谢 @[cmy962085349](https://www.luogu.com.cn/user/32483) 与 @[剑起头落地](https://www.luogu.com.cn/user/116251)

~~完结偷偷撒花!~~(✿✿ヽ(°▽°)ノ✿)

---

## 作者：chenzida (赞：10)

首先，这题我使用了值域线段树做，以纪念dhx老师在zjoi考场上发明值域线段树，Orz。

**默认已会值域线段树，建议在看本题解前，先自行思考20min**

### 操作思路

#### MIN_SORT_GAP

对于这个东西，我们需要一个 $ins$，也就是往值域线段树中插入一个数。还需要一个能查询值域线段树中最接近的两个值的差。

$ins$ 好说，就是基本操作，但是最接近的两个值的差怎么做呢？我们用 $tr[rt].ans$ 来代表在值域线段树中，以 $rt$ 为根的子树中最接近的两个数的差。这样的话每次询问直接输出 $tr[1].ans$ 即可。

那我们怎么转移呢？

以 $rt$ 为根的子树中最接近的两个数的差有三种情况，都在左子树中，都在右子树中以及跨子树。如果是前两种的话，直接继承并取 $\min$ 即可。由于是值域线段树，所以子树直接满足单调关系，所以如果是第三种情况一定是右子树中的最小值和左子树中的最大值直接的差，再和前两种情况取一下 $\min$ 即可。

#### MIN_GAP

那这个我们怎么处理呢？

由于是相邻的两个，所以每次 INERT 对这个的影响就不像整体最小值那么简单了。如果在两个值中间插入了一个值，那么对于整个的答案的影响就是多了两个值（和前驱的差以及和后继的差），然后少了1个值（前驱后继直接的差）。

所以我们要首先知道前驱后继，然后用权值线段树实现一个 $ins$ 和一个 $del$ 即可。

那我们怎么实现前驱后继呢？我们要插入一个元素之后，使后面的元素的位置都不变，同时还能维护前驱后继，自然就能想到链表了。

使用双向链表维护一下前驱后继，我们就能做了。

然后就是查询，查询就很简单了，直接查询最小值，也就是 $tr[1].mn$ 即可。

### 具体优化

首先，由于空间不允许 $O(n\log w)$（$w$ 是值域），所以我们必须要进行离散化，也就是我们先离线下来，将所有有可能出现的值都处理下来，然后对于一个离散之后的值域来做。

具体就是先用链表模拟一遍全过程，然后用 $al$ 数组将所有数都处理出来，之后对 $al$ 排序去重，最后用 $num$ 接收，然后每次遇到的值 $val$ 对应的权值线段树上的结点 $x$ 一定满足 $num[x]=val$，至于这个 $x$ ，有两种可行的做法， $map$ 处理和 $num$ 中二分，这里面，我选择第二种，因为 2007 的zjoi是不让用 $STL$ 的。确定了位置之后，实现一下之前的操场就好了。

我的做法常数较大，由于评测机波动，不开 O2 不保证能通过本题。

### 最后

最后吐槽一句：好多题解其实都可以被 $hack$ ，这给我对拍造成了极大的麻烦。。。以至于我调了6h+，最后还是写了个暴力和自己对拍的。。。

还有，看到讨论区有些题解用STL做之后说简单，觉得这题不配放到ZJOI里面，但是那时候不让用STL啊。。。这题要是用一个set那还有什么劲啊

upd：那时候连 $string$ 也不能用。。。

### 代码：

```
#include<bits/stdc++.h>
using namespace std;
const int NR=5e5+10; 
void Min(int& x,int y){x=min(x,y);}
void Max(int& x,int y){x=max(x,y);}
int n,m;
int a[NR];
int al[NR*5],xx;
int now[NR];
char s[NR][10];
int in1[NR],in2[NR];
int num[NR*5];
int all;
struct Chtholly
{
	int l,r,x;
}lb[NR*3];
struct Nd{int l,r,mn,mx,ans,num;};
struct Tree
{
	int cnt;
	Nd tr[NR*6];
	void Init(){tr[0].mx=0;tr[0].ans=tr[0].mn=0x3f3f3f3f;cnt=0;}
	int newnode()
	{
		int x=++cnt;
		tr[x].l=tr[x].r=0;
		tr[x].mn=tr[x].ans=0x3f3f3f3f;
		tr[x].mx=0;return x;
	}
	void clear(int &rt)
	{
		tr[rt].l=tr[rt].r=tr[rt].mx=tr[rt].num=0;
		tr[rt].mn=tr[rt].ans=0x3f3f3f3f;rt=0;
	}
	void update(int rt)
	{
		tr[rt].mx=max(tr[tr[rt].l].mx,tr[tr[rt].r].mx);
		tr[rt].mn=min(tr[tr[rt].l].mn,tr[tr[rt].r].mn);
		tr[rt].ans=min(tr[tr[rt].l].ans,tr[tr[rt].r].ans);
		if(tr[rt].l&&tr[rt].r)Min(tr[rt].ans,tr[tr[rt].r].mn-tr[tr[rt].l].mx);
	}
	void ins(int &rt,int l,int r,int x,int val)
	{
		if(!rt)rt=newnode();
		Min(tr[rt].mn,val),Max(tr[rt].mx,val);
		if(l==r){tr[rt].num++;if(tr[rt].num>1)tr[rt].ans=0;return;}
		int mid=(l+r>>1);
		if(x<=mid)ins(tr[rt].l,l,mid,x,val);
		else ins(tr[rt].r,mid+1,r,x,val);
		update(rt);
	}
	void del(int &rt,int l,int r,int x)
	{
		if(l==r)
		{
			if(tr[rt].num>1)tr[rt].num--;
			else clear(rt);return;
		}
		int mid=(l+r>>1);
		if(x<=mid)
		{
			bool flag=(r==l+1&&tr[tr[rt].l].num==1);
			del(tr[rt].l,l,mid,x);
		}
		else del(tr[rt].r,mid+1,r,x);
		update(rt);
	}
	int querymin(){return tr[1].mn;}
	int querym(){return tr[1].ans;}
}A,B;
int mp(int x)
{
	int l=1,r=xx,ans=-1;
	while(l<=r)
	{
		int mid=(l+r>>1);
		if(x<=num[mid])ans=mid,r=mid-1;
		else l=mid+1;
	}
	return ans;
}
int bl[NR*5];
void msort(int l,int r)
{
	if(l>=r) return;
	int mid=(l+r>>1);
	msort(l,mid),msort(mid+1,r);
	for(int i=l;i<=r;i++)bl[i]=al[i];
	int i=l,j=mid+1,t=l-1;
	while(t<r)
	{
		if(i>mid){al[++t]=bl[j++];continue;}
		if(j>r){al[++t]=bl[i++];continue;}
		if(bl[i]<=bl[j])al[++t]=bl[i++];
		else al[++t]=bl[j++];
	}
}
int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch<='9'&&ch>='0'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return x*f;
}
int main()
{
//	freopen("1.in","r",stdin);
//	freopen("1.out","w",stdout);
	n=read(),m=read();
	a[1]=read();al[++xx]=a[1];
	for(int i=2;i<=n;i++)
		a[i]=read(),al[++xx]=a[i],al[++xx]=abs(a[i]-a[i-1]);
	for(int i=1;i<=n;i++)now[i]=i;all=n;
	for(int i=1;i<=n;i++)lb[i].l=i-1,lb[i].r=i+1,lb[i].x=a[i];
	lb[n].r=NR*2-1;lb[NR*2-1].x=lb[0].x=0x3f3f3f3f;
	for(int i=1;i<=m;i++)
	{
		cin>>s[i];
		if(s[i][0]!='I')continue;
		in1[i]=read(),in2[i]=read();
		al[++xx]=in2[i];
		al[++xx]=abs(lb[lb[now[in1[i]]].r].x-lb[now[in1[i]]].x);
		lb[++all].r=lb[now[in1[i]]].r;
		lb[lb[all].r].l=all;
		lb[now[in1[i]]].r=all;
		lb[all].l=now[in1[i]];
		lb[all].x=in2[i];
		al[++xx]=abs(in2[i]-lb[lb[all].l].x);
		al[++xx]=abs(lb[lb[all].r].x-in2[i]);
		now[in1[i]]=all;
	}
	memset(lb,0,sizeof(lb));
	msort(1,xx);int xxx=xx;xx=0;
	for(int i=1;i<=xxx;i++)
	{
		if(al[i]==al[i-1]&&i!=1)continue;
		num[++xx]=al[i];
	}
	for(int i=1;i<=n;i++)now[i]=i;all=n;
	for(int i=1;i<=n;i++)lb[i].l=i-1,lb[i].r=i+1,lb[i].x=a[i];
	lb[n].r=NR*2-1;lb[NR*2-1].x=lb[0].x=0x3f3f3f3f;A.Init(),B.Init();
	int rootA=0,rootB=0;
	for(int i=1;i<=n;i++)B.ins(rootB,1,xx,mp(a[i]),a[i]);
	for(int i=2;i<=n;i++)A.ins(rootA,1,xx,mp(abs(a[i]-a[i-1])),abs(a[i]-a[i-1]));
	for(int i=1;i<=m;i++)
	{
		if(s[i][0]=='I')
		{
			B.ins(rootB,1,xx,mp(in2[i]),in2[i]);
			int Xx=abs(lb[now[in1[i]]].x-lb[lb[now[in1[i]]].r].x);
			lb[++all].r=lb[now[in1[i]]].r;
			lb[lb[all].r].l=all;lb[now[in1[i]]].r=all;
			lb[all].l=now[in1[i]];lb[all].x=in2[i];
			int xX=abs(lb[all].x-lb[lb[all].l].x);
			int XX=abs(lb[all].x-lb[lb[all].r].x);
			A.del(rootA,1,xx,mp(Xx));A.ins(rootA,1,xx,mp(xX),xX);A.ins(rootA,1,xx,mp(XX),XX);
			now[in1[i]]=all;
		}
		else if(s[i][4]=='S')printf("%d\n",B.querym());
		else printf("%d\n",A.querymin());
	}
	return 0;
}
/*
3 2
6 7 3 
INSERT 1 0
MIN_GAP
*/



---

## 作者：良月澪二 (赞：10)

### 这是一份可以卡过去的纯$STL$

两个$multiset$，一个$adjoin$记录相邻的差值，一个$al$记录所有的元素

一个优先队列存所有元素的最小差值

一个$map$存$adjoin$中元素的出现个数

这题的插入比较奇怪

插入多次之后一个数后面的序列中中间的数就没有作用了，对答案起到影响的只有头尾元素，所以两个数组记录每个点后方序列的头和尾

每次插入操作都要更新，注意细节就好

由于$STL$用的很多

读优输优$O_2$一个都不能少

第一次$A$卡到了$2493ms$

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <complex>
#include <algorithm>
#include <climits>
#include <queue>
#include <map>
#include <ctime>
#include <set>
#include <vector>
#include <iomanip>
#define A 1000010
#define B 2010

using namespace std;
typedef long long ll;
const int inf = 2000000000;
map<ll, ll> df;
multiset<ll> adjoin, al;
priority_queue<ll, vector<ll>, greater<ll> > q;
int n, m, s[A], e[A], x, y;
template<class T> void read(T &x) {
    x = 0; char ch = getchar();
    while (!isdigit(ch)) ch = getchar();
    while (isdigit(ch)) x = x * 10 + (ch ^ 48), ch = getchar();
}
void operate1() {
    read(x); read(y);
    //更新相邻元素最小差值
    if (x != n) {
        int tmp = abs(e[x] - s[x + 1]);
        if (!--df[tmp]) adjoin.erase(tmp);
    }
    if (++df[abs(y - e[x])] == 1) adjoin.insert(abs(y - e[x]));
    if (++df[abs(y - s[x + 1])] == 1) adjoin.insert(abs(y - s[x + 1]));
    e[x] = y;
    //更新那个优先队列
    q.push(min(y - *--al.lower_bound(y), *al.lower_bound(y) - y));
    al.insert(y);
}
void write(int x) {
    if (x < 0) putchar('-'), x = -x;
    if (x > 9) write(x / 10);
    putchar(x % 10 + '0');
}

int main(int argc, char *argv[]) {
    read(n); read(m);
    al.insert(inf); al.insert(-inf);
    for (int i = 1; i <= n; i++) {
        read(x);
        q.push(min(x - *--al.lower_bound(x), *al.lower_bound(x) - x));
    	al.insert(x);
        s[i] = e[i] = x;
        if (i == 1) continue;
        if (++df[abs(s[i] - s[i - 1])] == 1) adjoin.insert(abs(s[i] - s[i - 1]));
    }
    for (int i = 1; i <= m; i++) {
        char opt[12];
        scanf("%s", opt);
        switch (opt[4]) {
        	case 'R' : operate1(); break;
        	case 'S' : write(q.top()); puts(""); break;
        	case 'G' : write(*adjoin.begin()); puts(""); break;
        	default : break;
		}
    }
}
```

---

## 作者：Twilight_ (赞：10)

主要思路大概也是差不多的，对于两种询问分别用线段树与平衡树来维护。

1.MIN_SORT_GAP:
显然平衡树简单操作，来一发前驱、后继即可。

2.MIN_GAP:这一个我用的是线段树：可以注意到插入元素的操作，如果是在一个元素之后反复插入，这些元素之间更新出来的最小值是不会发生改变的。只有元素与元素之间会有不断的插入而导致最小值变大。所以用线段树单点修改+维护区间min值，相邻插入值（中间不会再出现新的数字）之间可以直接暴力维护。

代码如下：
```
#include <bits/stdc++.h>
using namespace std;
#define INF 99999999999LL
#define maxn 2000000 
#define int long long
int n, m, tot, M1 = INF, M2 = INF, a[maxn];
int b[maxn], root;
struct tree
{
	int l, r, num;  
}T[maxn];

struct node
{
	int v, ch[2], fa;
}P[maxn];

int read()
{
	int x = 0, k = 1;
	char c;
	c = getchar();
	while(c < '0' || c > '9') { if(c == '-') k = -1; c = getchar();}
	while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
	return x * k;
}

struct Splay_Balanced_Tree
{
	void rotate(int x)
	{
		int f = P[x].fa, gf = P[f].fa;
		int k = x == P[f].ch[1];
		P[x].fa = gf;
		if(gf) P[gf].ch[f == P[gf].ch[1]] = x;
		P[f].ch[k] = P[x].ch[k ^ 1], P[P[x].ch[k ^ 1]].fa = f;
		P[f].fa = x, P[x].ch[k ^ 1] = f;
	}
	
	void Splay(int x, int goal)
	{
		while(P[x].fa != goal)
		{
			int f = P[x].fa, gf = P[f].fa;
			if(gf != goal) (P[f].ch[1] == x) ^ (P[gf].ch[1] == f) ? rotate(x) : rotate(f);
			rotate(x);
		}
		if(goal == 0) root = x; 
	}
	
	void ins(int x)
	{
		int u = root, ff = 0;
		while(u && P[u].v != x)
		{
			ff = u;
			u = P[u].ch[P[u].v < x];
		}
		if(!u)
		{
			u = ++ tot;
			P[u].fa = ff;
			if(ff) P[ff].ch[P[ff].v < x] = u;
			P[u].v = x;
			Splay(u, 0);
		} 
	}
	
	void Find(int x)
	{
		int u = root;
		if(!u) return;
		while(P[u].v != x && P[u].ch[P[u].v < x]) u = P[u].ch[P[u].v < x];
		Splay(u, 0);
	}
	
	int next(int x, int k)
	{
		Find(x);
		int u = root;
		if(P[u].v == x) return P[u].v;
		if((P[u].v < x && !k) || (P[u].v > x && k)) return P[u].v;
		u = P[u].ch[k];
		while(P[u].ch[k ^ 1]) u = P[u].ch[k ^ 1];
		return P[u].v;
	}
}SBT;

struct Segament_Tree
{
	void build(int p, int l, int r)
	{
		T[p].l = l, T[p].r = r;
		if(l == r) 
		{
			T[p].num = abs(a[l] - a[l - 1]);
			return;
		}
		int mid = (l + r) >> 1;
		build(p << 1, l, mid), build(p << 1 | 1, mid + 1, r);
		T[p].num = min(T[p << 1].num, T[p << 1 | 1].num);
	}
	
	void update(int p, int x, int num)
	{
		int mid = (T[p].l + T[p].r) >> 1;
		if(T[p].l == T[p].r)
		{
			T[p].num = num;
			return;
		}
		if(x <= mid) update(p << 1, x, num);
		else update(p << 1 | 1, x, num);
		T[p].num = min(T[p << 1].num, T[p << 1 | 1].num);
	}
}SGT;

signed main()
{
	n = read(), m = read();
	SBT.ins(INF), SBT.ins(- INF);
	a[0] = a[n + 1] = INF;
	for(int i = 1; i <= n; i ++)
	{
		a[i] = read();
		if(i != 1) 
		{
			int l = SBT.next(a[i], 0), r = SBT.next(a[i], 1);
			M2 = min(M2, min(abs(l - a[i]), abs(r - a[i])));
		}
		SBT.ins(a[i]);
		b[i] = a[i];
	}
	SGT.build(1, 1, n);
	for(int i = 1; i <= m; i ++)
	{
		string s;
		cin >> s;
		if(s[0] == 'I')
		{
			int x = read(), y = read();
			int l = SBT.next(y, 0), r = SBT.next(y, 1);
			M2 = min(M2, min(abs(l - y), abs(r - y)));
			SBT.ins(y);
			M1 = min(M1, abs(b[x] - y));
			SGT.update(1, x + 1, abs(a[x + 1] - y));
			b[x] = y;
		}
		else if(s[4] == 'G') printf("%lld\n", min(M1, T[1].num));
		else printf("%lld\n", M2);
	}
	return 0;
}
```


---

## 作者：Treeloveswater (赞：10)

超级大水题。竟然是省选难度的？

一棵无比简单的连update都不用写的splay+一个带删除的堆，完美搞定。

操作一：没必要搞一棵splay。我们只用开一个lq[500001][2]的数组记录这个点的前面和后面就行。

操作二：带修改的小根堆

操作三：把所有数扔到splay里，按大小为关键字，再插入的时候取个max的差值就好了。

完美解决，特别好写~

完结，撒花~

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;
int tot,n,m,a,k,minans=1e7;
struct node
{
    int data;
    node *son[2],*pre;
    bool judge();
    void setson(node *child,int lr);
}pool[1000001],*null,*root;
int heap1[1500001],delheap[1000001],lq[500001][3];
char s[25];
bool node::judge(){return pre->son[1]==this;}
void node::setson(node *child,int lr){son[lr]=child;if(child!=null)child->pre=this;}
node *getnew(int value)
{
    node *now=pool+ ++tot;
    now->data=value;
    now->pre=now->son[1]=now->son[0]=null;
    return now;
}
int ab(int x)
{
    return x<0?-x:x;
}
void rotate(node *&now)
{
    node *dad=now->pre,*grandfa=now->pre->pre;
    int lr=now->judge();
    dad->setson(now->son[lr^1],lr);
    now->setson(dad,lr^1);
    now->pre=grandfa;
    if(grandfa!=null) grandfa->son[grandfa->son[1]==dad?1:0]=now;
}
void splay(node *now,node *tar)
{
    for(;now->pre!=null;rotate(now))
    if(now->pre->pre!=tar)
    now->judge()==now->pre->judge()?rotate(now->pre):rotate(now);
    if(tar==null)root=now;
}
void in(int *heap,int value)
{
    heap[++heap[0]]=value;
    int now=heap[0],nxt;
    while(now>1)
    {
        nxt=now>>1;
        if(heap[nxt]<heap[now])break;
        swap(heap[nxt],heap[now]);
        now=nxt;
    }
}
void del(int *heap)
{
    heap[1]=heap[heap[0]--];
    int now=1,nxt;
    while(now*2<=heap[0])
    {
        nxt=now<<1;
        if(heap[nxt]>heap[nxt+1]&&nxt<heap[0])nxt++;
        if(heap[now]<heap[nxt])break;
        swap(heap[now],heap[nxt]);
        now=nxt;
    }
}
void insert(int value)
{
    node *newone=getnew(value);
    node *now=root,*last=null;
    while(now!=null)
    {
        last=now;
        if(ab(newone->data-now->data)<minans)minans=ab(newone->data-now->data);
        if(now->data>=newone->data) now=now->son[0];
        else now=now->son[1];
    }
    if(last==null) root=newone;
    else
    {
        if(ab(newone->data-last->data)<minans)minans=ab(newone->data-last->data);
        if(last->data>=newone->data) last->setson(newone,0);
        else last->setson(newone,1);
    }
}
int main()
{
    null=pool;
    null->data=0;
    null->pre=null->son[1]=null->son[0]=null;
    root=null;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&lq[i][1]);
        lq[i][2]=lq[i][1];
        if(i>1)in(heap1,ab(lq[i][1]-lq[i-1][2]));
        insert(lq[i][1]);
    }
    for(int i=1;i<=m;i++)
    {
        scanf("%s",s);
        if(s[0]=='I')
        {
            scanf("%d%d",&a,&k);
            if(a<n)
            {
                in(delheap,ab(lq[a][2]-lq[a+1][1]));
                in(heap1,ab(k-lq[a+1][1]));
            }
            in(heap1,ab(k-lq[a][2]));
            lq[a][2]=k;
            insert(k);
        }
        else
        {
            int length=strlen(s);
            if(length<10)
            {
                while(heap1[1]==delheap[1])
                {
                    del(heap1);
                    del(delheap);
                }
                printf("%d\n",heap1[1]);
            }
            else
                printf("%d\n",minans);
        }
    }
}
```

---

## 作者：周道_Althen (赞：7)

~~好像还没有fhq_treap的题解呢，周道来钻个空~~

---

$\ \ \ \ \ \ \,$第一次看见这个题：想了一会，woc，三颗平衡树，好麻烦呀，先放一放。

$\ \ \ \ \ \ \,$第二次看见这个题：想了一会，woc，平衡树加线段树，好麻烦呀，先放一放。

$\ \ \ \ \ \ \,$第三次看见这个题：想了一会，woc，一棵权值平衡树加一棵位置平衡树，好麻烦呀，先放一放。

$\ \ \ \ \ \ \,$第四次看见这个题：想了一会，woc，一棵平衡树加堆，好麻烦呀……诶等等，好像可以就开两个差不多的平衡树就行了……

----

$\ \ \ \ \ \ \,$写的时候脑袋有点懵，不过还是肝好了呢。

$\ \ \ \ \ \ \,$当他插入的时候，显然可以发现，就是在堆里面删除元素：$abs(head[id+1]-tail[id])$；然后插入两个新元素：$abs(head[id+1]-new)$，$abs(new-tail[id])$。然后新的 $tail[id]$ 再附上 $new$。每次询问 $MIN\_GAP$ 就是询问堆里面的最小值了。

$\ \ \ \ \ \ \,$支持删除，插入，查询权值最小，显然可以用平衡树去搞。

$\ \ \ \ \ \ \,$对于第二种询问，单独插入一个元素，我们需要在集合里面查找他的前驱和后继，便可以计算最小的差值，显然这个询问的答案是单调的，所以我们开全局变量去记录。

$\ \ \ \ \ \ \,$支持插入，查前驱，查后继，显然可以又用平衡树去搞。

$\ \ \ \ \ \ \,$这里我用了我喜欢的$Fhq_Treap$，然后前驱后继是直接查的，其实可以通过$pushup$上传最大最小值，但是不知道为什么会慢一点，然后卡了会儿常，代码有点丑：

```cpp
#include<algorithm>
#include<iostream>
#include<cstdlib>
#include<cstring>
#include<cctype>
#include<cstdio>
#include<vector>
#include<string>
#include<queue>
#include<stack>
#include<cmath>
#include<ctime>
#include<map>
#include<set>
using namespace std;
const int inf=0x7fffffff;
const double eps=1e-10;
const double pi=acos(-1.0);
//char buf[1<<15],*S=buf,*T=buf;
//char getch(){return S==T&&(T=(S=buf)+fread(buf,1,1<<15,stdin),S==T)?0:*S++;}
inline int read(){
  int x=0,f=1;char ch;ch=getchar();
  while(ch<'0'||ch>'9'){if(ch=='-') f=0;ch=getchar();}
  while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch&15);ch=getchar();}
  if(f)return x;else return -x;
}
const int N=1000010;
int ans=inf;
inline int Abs(const int &a){if(a<0)return -a;return a;}
inline int min(const int &a,const int &b){if(a<b)return a;return b;}
inline int max(const int &a,const int &b){if(a>b)return a;return b;}
struct fhq_treap_val{
  #define lson ls[rt]
  #define rson rs[rt]
  int val[N],size[N],key[N];
  int ls[N],rs[N];
  int root,cnt;
  void pushup(int rt){size[rt]=size[lson]+size[rson]+1;}
  int merge(int a,int b){
    if(!a||!b)return a|b;
    if(key[a]<key[b]){rs[a]=merge(rs[a],b);pushup(a);return a;}
    else {ls[b]=merge(a,ls[b]);pushup(b);return b;}
  }
  void split(int rt,int x,int &a,int &b){
    if(!rt){a=b=0;return;}
    if(val[rt]<=x){a=rt;split(rson,x,rson,b);}
    else{b=rt;split(lson,x,a,lson);}
    pushup(rt);
  }
  int Max(int rt){while(rson)rt=rson;return val[rt];}
  int Min(int rt){while(lson)rt=lson;return val[rt];}
  int newnode(int x){
    int rt=++cnt;
    val[rt]=x;
    size[rt]=1;key[rt]=rand();
    lson=rson=0;
    return rt;
  }
  void Insert(int x){
    int a,b;
    split(root,x,a,b);
    int rt=newnode(x);
    root=merge(merge(a,rt),b);
  }
  void Insert_2(int x){
    int a,b;
    split(root,x,a,b);
    if(size[a])ans=min(ans,abs(x-Max(a)));
    if(size[b])ans=min(ans,abs(Min(b)-x));
    int rt=newnode(x);
    root=merge(merge(a,rt),b);
  }
  void Delete(int x){
    int a,b,c;
    split(root,x,a,c);
    split(a,x-1,a,b);
    b=merge(ls[b],rs[b]);
    root=merge(merge(a,b),c);
  }
}T1,T2;
int n,m,a[N],b[N],id,g;
char op[20];
int main()
{
  srand(time(NULL));
  n=read();m=read();
  for(int i=1;i<=n;i++)a[i]=b[i]=read();
  for(int i=1;i<n;i++)T1.Insert(Abs(a[i+1]-a[i]));
  for(int i=1;i<=n;i++)T2.Insert_2(a[i]);
  while(m--){
    scanf("%s",op);
    if(op[0]=='I'){
      id=read();g=read();
      T2.Insert_2(g);
      if(id!=n){
        T1.Delete(Abs(a[id+1]-b[id]));
        T1.Insert(Abs(a[id+1]-g));
      }
      T1.Insert(Abs(b[id]-g));
      b[id]=g;
    }
    else if(op[4]=='G')printf("%d\n",T1.Min(T1.root));
    else printf("%d\n",ans);
  }
  return 0;
}

```




---

## 作者：万弘 (赞：4)

发一篇浅显易懂的题解.

由题意,每个位置可能有多个元素,很显然可以用vector维护之.

考虑min_gap会被什么东西影响.首先,在序列开始时,
$$min\_gap=\min_{i=2}^n\{|a_i-a_{i-1}|\}$$
(只有一个元素就先不考虑vector)

其次,在$x$位置最后加入一个元素$val$的影响:  
记$x$位置原本最后的元素是$pre$(即`a[x].back()`),$x+1$位置(如果存在)开始的元素是$nxt$(即`a[x+1].front()`)

- 原本的$|pre-nxt|$不能再对$min\_gap$产生贡献(这里"产生贡献"是指选某个元素在$min\_gap$的可选集合中(注意这是个可重集)),把它从$min\_gap$的可选集合中删除.
- $|pre-val|$产生贡献,加入$min\_gap$的可选集合
- $|val-nxt|$产生贡献,加入$min\_gap$的可选集合

然后`a[x].push_back(val)`就好了.  
这个集合,显然可以用平衡树维护.我用了FHQ_Treap.询问的结果就是FHQ_Treap中的最小值

min_sort_gap呢?
考虑每加入一个元素$val$,记其前驱为$pre$,后继为$nxt$

则$val-pre$,$nxt-val$产生贡献,加入$min\_sort\_gap$的可选集合.注意到这个集合是单调不减的,可以用一个变量$minval$维护.为了查找前驱后继,可以再建一棵平衡树,存所有数.由于我写了一个FHQ_Treap类,就可以一起定义这两棵FHQ_Treap了.

时间复杂度$O((n+m)log(n+m))$.XJOI上给了10s,洛谷只有2.5s,实际运行可能会TLE,需要卡常.比如注意到正在有用的只有`a[x].back(),a[x].front()`,实现时可以不用vector,只记录这两个元素.minval最小是0,是0后不需要再考虑它的更新等.

```cpp
/**********/省略快读
#define MAXN 1000011
struct fhq_Treap封装
{
    struct node
    {
        ll son[2];
        ll val,data;
        ll size;
    }t[MAXN];
#define rt t[cur]
#define tl t[rt.son[0]]
#define tr t[rt.son[1]]
    ll root,cnt;
    ll newnode(ll val)
    {
        t[++cnt]=node{0,0,val,rand(),1};
        return cnt;
    }
    void pushup(ll cur)
    {
        rt.size=tl.size+tr.size+1;
    }
    fhq_Treap()//初始化,塞入两个极值
    {
        srand(time(0));

        cnt=0;
        newnode(-INF),newnode(INF);
        root=1,t[1].son[1]=2;t[2].data=t[1].data-1;
    }
    void split(ll cur,ll k,ll& x,ll& y)
    {
        if (!cur)
        {
            x=y=0;
            return;
        }
        if (rt.val<=k)
        {
            x=cur;split(rt.son[1],k,rt.son[1],y);
        }
        else y=cur,split(rt.son[0],k,x,rt.son[0]);
        pushup(cur);
    }
    ll merge(ll x,ll y)
    {
        if (!x||!y)return max(x,y);
        if (t[x].data<t[y].data)
        {
            t[y].son[0]=merge(x,t[y].son[0]);
            pushup(y);
            return y;
        }
        else
        {
            t[x].son[1]=merge(t[x].son[1],y);
            pushup(x);
            return x;
        }
    }
    void insert(ll val)
    {
        ll x,y;
        split(root,val,x,y);
        root=merge(merge(x,newnode(val)),y);
    }
    void erase(ll val)
    {
        ll x,y,z;
        split(root,val,x,y);
        split(x,val-1,x,z);
        z=merge(t[z].son[0],t[z].son[1]);
        root=merge(merge(x,z),y);
    }
    ll _Qkth(ll cur,ll k)
    {
        if (k<=tl.size)return _Qkth(rt.son[0],k);
        if (k<=tl.size+1)return rt.val;
        return _Qkth(rt.son[1],k-tl.size-1);
    }
    ll Qkth(ll k)
    {
        return _Qkth(root,k+1);
    }
    ll Qpre(ll val)//为了处理重复元素,这里Qpre返回的是不大于val的最大值
    {
        ll x,y;
        split(root,val,x,y);
        ll res=_Qkth(x,t[x].size);
        root=merge(x,y);
        return res;
    }
    ll Qnxt(ll val)//同理,不小于val的最小值
    {
        ll x,y;
        split(root,val-1,x,y);
        ll res=_Qkth(y,1);
        root=merge(x,y);
        return res;
    }
}t1,t2;//the gaps,the numbers
ll a[MAXN],b[MAXN],minval=INF;//a[x]即a[x].front(),b[x]即a[x].back()
char op[19];
int main()
{
    ll n=read(),m=read();
    for (int i = 1; i <= n; ++i)
    {
        ll x=read();
        a[i]=b[i]=x;
        if (i>1)t1.insert(abs(a[i]-b[i-1]));
        umin(minval,x-t2.Qpre(x));
        umin(minval,t2.Qnxt(x)-x);
        t2.insert(x);
    }
    for (int i = 1; i <= m; ++i)
    {
        scanf("%s",op);
        if (op[0]=='I')
        {
            ll x=read(),val=read();
            if (x<n)
            {
                t1.erase(abs(b[x]-a[x+1]));
                t1.insert(abs(val-a[x+1]));
            }
            t1.insert(abs(b[x]-val));
            b[x]=val;
            if (minval)
            {
                umin(minval,val-t2.Qpre(val));
                umin(minval,t2.Qnxt(val)-val);
                t2.insert(val);
            }
        }
        else if (op[4]=='G')printf("%lld\n",t1.Qkth(1));
        else printf("%lld\n",minval);
    }
    return 0;
}
```

---

## 作者：Lauzun (赞：4)

$2019.11.05$ $update:$ 新增一份带注释的代码，更方便食用

本篇题解和 $@$[雨幕散影_小初](https://www.luogu.org/user/135659)共同完成。

这题可真是论 $STL$ 的妙用了 $qwq$

小萌新大概看了一下，目前题解里应该没有代码量比这个短的 _~~(也没有常数比这个大的)~~_ 

用 $multiset$ 和 $vector$ 解决

$vector$ 用来处理添加数的操作，给初始每个数的下标都建一个 $vector$，然后将初始的数放进去，需要添加的话直接在这个下标的 $vector$ 里 $push$ _ $back$ 需要添加的数字即可

然后就需要两个 $multiset$ 分别解决两个询问。

对于第一个询问，需要一个 $multiset($下称 $gap$ $)$ 储存相邻两个数字的差，每次加入数字的话，如果向 $x$ 和 $y$ 之间加入 $v$, 那么就需要先从 $gap$ 中取出 $x$ 和 $y$ 的差，然后再插入 $v$ 与 $x$ 以及 $v$ 与 $y$ 的差$($这也是为什么我们需要开这个 $multiset$，而不是仅仅只记录最小差值，因为这样的话就无法取出 $x$ 和 $y$ 的差$)$ 

注意计算相邻两个数的差值就需要用 $vector$ 了，用 $v$ 和 $v$ 要插入的位置的 $vector$ 的前一个数字$(x)$以及 $v$ 要插入的位置的下一个 $vector$ 的第一个数字$(y)$分别作差

因为 $multiset$ 自带排序，所以回答第一个询问的话只需要简单地输出 $gap$ 的 $begin$ 即可

对于第二个询问，我们也需要一个 $multiset($下称 $sort$ _ $gap$ $)$ 储存每个数字，这里也用到了 $multiset$ 自带排序的性质。

然后我们需要一个 $ans$ 来记录此时排序后两两之间的差值最小值，这里需要注意的是因为有序的原因，所以询问二的答案只会更小而不会更大。

每次插入一个数字，只需要用 $lower$ _ $bound$ 在 $sort$ _ $gap$ 中找到第一个大于等于插入数字的地方，用它和插入后它左右两边的数字更新一下 $ans$，最后别忘了把它扔到 $sort$ _ $gap$ 里

大概就是这样，然后需要处理几个细节$:$

- 比如 $lower$ _ $bound$ 在 $sort$ _ $gap$ 里查询的时候要注意边界，不要访问了空指针，这里的建议是给 $multiset$ 里扔一个 $-inf$ 和 $inf$，这样子就不会越界了。用 $multiset$ 的话就是边界问题一定要注意，一不小心调用了空指针就直接见祖宗了$($我就是这样卡了一个小时$)$

- 因为用了 _~~臭名昭著~~_ 的 $STL$ 导致常数极大 _~~(但小萌新就是喜欢啊QvQ)~~_ 一定要吸氧，不然也见祖宗。

- 还有一个小但致命的细节，不要在 $min$ 函数里进行指针的 $++$ 或 $--$ 操作，会奇妙的 $WA$，因为这个也卡了不少时间。。。

- 在 $vector$ 里计算前后差值的时候一定要注意如果是在最后一个数后面插入数字，那么只需要记录它和前一个数字的差，而不需要记录它和后一个数的差$($因为它就是最后一个数字啊$)$，不然无限爆 $0$

码量不大但细节还比较多。。。

$STL$ 万岁！！！

```cpp
#include<iostream>
#include<algorithm>
#include<vector>
#include<set>
#define maxn 500005
#define inf 999999999
using namespace std;
int n, m, u, v, ans = inf, a[maxn];
multiset<int> sort_gap, gap;
string s;
vector<int> mp[maxn];

inline int get_min(int v) {
	multiset<int>::iterator gg = sort_gap.lower_bound(v);
	int cur = *gg - v, tmp = v - *(-- gg);
	return min(cur, tmp);
}

signed main() {
	ios::sync_with_stdio(false);
	cin >> n >> m;
	for(int i = 1; i <= n; i ++) cin >> a[i], mp[i].push_back(a[i]);
	sort_gap.insert(inf), sort_gap.insert(- inf);
	for(int i = 2; i <= n; i ++) gap.insert(abs(a[i] - a[i - 1]));
	for(int i = 1; i <= n; i ++) ans = min(ans, get_min(a[i])), sort_gap.insert(a[i]);
	while(m --) {
		cin >> s;
		if(s == "INSERT") {
			cin >> u >> v;
			if(u != n) {
				gap.erase(gap.find(abs(mp[u][mp[u].size() - 1] - mp[u + 1][0])));
				gap.insert(abs(v - mp[u + 1][0]));
			}
			gap.insert(abs(mp[u][mp[u].size() - 1] - v));
			mp[u].push_back(v);
			ans = min(ans, get_min(v));
			sort_gap.insert(v);
		}
		if(s == "MIN_SORT_GAP") cout << ans << endl;
		if(s == "MIN_GAP") cout << *gap.begin() << endl;
	}
} 
```

以下是有注释的代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=500005,inf=999999999;
int n,m,u,v,hvx=inf,a[N];
multiset<int> lbh,lys;//来自机房的两位巨佬，lbh表示求询问"MIN_SORT_GAP"，lys则是另一个"MIN_GAP" 
string s;
vector<int> mp[N];//vector存储每个点后面新增加的数，好像可以用数组？(蒟蒻并不会啊--逃-- 
inline int get_min(int v)
{
	multiset<int>::iterator lb=lbh.lower_bound(v);
	int cur=*lb-v,tmp=v-*(--lb);//注意这里用--lb而不是lb--，由于指针的特性能快一点 
	return min(cur,tmp);//一定不要在algorithm库中的min函数里--，因为这个调试了好久 
}
signed main()
{
	ios::sync_with_stdio(false);
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i],mp[i].push_back(a[i]);
	lbh.insert(inf),lbh.insert(-inf);//插入正负无穷可以避免后面插入操作中对指针越界的判断 
	for(int i=2;i<=n;i++)lys.insert(abs(a[i]-a[i-1]));
	for(int i=1;i<=n;i++)hvx=min(hvx,get_min(a[i])),lbh.insert(a[i]);
	while(m--)
	{
		cin>>s;
		if(s=="INSERT")
		{
			cin>>u>>v;
			if(u!=n)
			{
				lys.erase(lys.find(abs(mp[u][mp[u].size()-1]-mp[u+1][0])));//小技巧，用来清除multiset中的一个元素 
				lys.insert(abs(v-mp[u+1][0]));//这里每次进来新值可能会将原来的值破坏，所以我们先把加数后被影响的值删掉再加入新值 
			}
			lys.insert(abs(mp[u][mp[u].size()-1]-v));
			mp[u].push_back(v);
			hvx=min(hvx,get_min(v));lbh.insert(v);
		}
		if(s=="MIN_SORT_GAP")cout<<hvx<<endl;//再次借用学习OI时长近五年的学长统计自己的答案 
		if(s=="MIN_GAP")cout<<*lys.begin()<<endl;//multiset默认从小到大，输出指针begin的值即为答案 
	}
	return (^_^);//皮一下，很开心(记得删掉。。。 
}
```

(也不知道能不能过，希望吧。。。

---

## 作者：nnn233 (赞：2)

# 题解：P1110 [ZJOI2007] 报表统计

看到题解区没有我这种做法，于是来写一发题解。

开两棵 **FHQ Treap**，一棵使用**排名分裂**，用来维护操作二查询相邻最小差，我们将其称为 **排名树**；另一棵使用**权值分裂**，维护操作三全局最小差，我们将其称为**权值树**。

## 备注
本人编码习惯，有看不懂的代码应该是这里来的。
```cpp
#define lc t[u].ls
#define rc t[u].rs
```

## 操作三
先讲操作三是因为这个是最好处理的，使用**权值树**，每次插入一个数的时候就查询这个数的**前驱**和**后继**，然后尝试**更新答案**，查询时直接输出当前答案即可。

## 操作一
我们主要来讲**排名树**如何插入，其他题解几乎没有使用排名分裂的，原因大概是**排名树**不能查找**指定编号在中序遍历中的位置**。

之前在做 [P2596 [ZJOI2006] 书架](https://www.luogu.com.cn/problem/P2596) 恰好就学到一种办法，只要知道数 $x$ 在 Treap 中的**节点编号**，就能找到它在**中序遍历中的位置**。

在建树的时候我们记录**原数列**第 $i$ 数在 Treap 中的**节点编号**是 $id_i$，再维护**每个节点的父亲** $fa_u$。

每个节点的父亲我们顺手在 $update$ 合并节点信息时维护一下就行。

当我们要插入一个数 $k$ 到**原数列**第 $i$ 个数后面时，我们通过 $id_i$ 找到 Treap 中对应原数列第 $i$ 数的节点 $u$，然后每次将它向**树根**跳,如果它是**右儿子**,那么就将它**父亲的左子树的值以及父亲的大小**计入结果。

我们用一个函数来实现这个功能。
```cpp
inline int id(int u){
    int res=t[t[u].ls].siz+1;
    while(u!=root){
        if(t[t[u].fa].rs==u)res+=t[t[t[u].fa].ls].siz+1;
        u=t[u].fa;
    }
    return res;
}
```
题目中还说
>如果原数列的第 $i$ 个元素已经添加了若干元素，则添加在这些元素的最后（见样例说明）。

我们用一个数组 $cntt_i$ 表示原数列第 $i$ 个元素后面已经插入了 $cntt_i$ 个元素。

在执行操作一时，我们先找到原数列的第 $i$ 个元素在中序遍历中的位置，再加上 $cntt_i$ 即是我们要插入的位置。
![](https://cdn.luogu.com.cn/upload/image_hosting/vroyeip3.png)

对于权值树就相对简单的多，直接插入即可。

操作一代码
```cpp
if(s[0]=='I'){
    scanf("%d%d",&i,&k);
    j=id(i);//寻找原数列的第i个数在排名树中的位置
    j+=cntt[i];
    ++cntt[i];
    //操作排名树
    split(root,j,L,R);
    root=merge(merge(L,newnode(k)),R);
    //操作权值树
    vsplit(vroot,k,L,R);
    mini=min(mini,abs(kth(L,t[L].siz)-k));//查询前驱尝试更新答案
    mini=min(mini,abs(kth(R,1)-k));//查询后继尝试更新答案
    vroot=merge(merge(L,newnode(k)),R);
}
```

## 操作二
我们在排名树中来维护相邻最小差，因为排名树有个性质，一个节点的子树所有节点是一段连续的区间，我们可以维护区间最左点的值和区间最右点的值,再维护区间相邻最小差。

节点 $u$ 的这个区间的相邻最小差一定是一下四种

- 左子区间的相邻最小差
- 右子区间的相邻最小差
- $ls.r$ 与 $u$ 的差
- $rs.l$ 与 $u$ 的差
![](https://cdn.luogu.com.cn/upload/image_hosting/dx6vihb5.png)

我们在 $update$ 函数中对这些信息进行维护
```cpp
inline void update(int u){
    t[u].gap=1145141919;//区间相邻最小差
    t[u].siz=1;
    t[u].l=t[u].r=t[u].v;
    if(lc){ 
        t[u].siz+=t[lc].siz;
        t[u].l=t[lc].l;
        t[u].gap=min(t[u].gap,abs(t[u].v-t[lc].r));
        t[u].gap=min(t[u].gap,t[lc].gap);
        t[lc].fa=u;
    }
    if(rc){
        t[u].siz+=t[rc].siz;
        t[u].r=t[rc].r;
        t[u].gap=min(t[u].gap,abs(t[u].v-t[rc].l));
        t[u].gap=min(t[u].gap,t[rc].gap);
        t[rc].fa=u;
    }
}
```
时间复杂度:所有操作基于 FHQ Treap ，最大的计算次数是树的层数也就是 $O(\log n)$，总的时间复杂度为 $O((n+m)\log n)$

至此这道题就差不多解决了，还有不懂的就看代码或者私聊我吧。

[AC记录](https://www.luogu.com.cn/record/181551565)
## CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int mod=1e9+7;
const int N=2e6+50,M=5e6;
int n,m,q;
#define lc t[u].ls
#define rc t[u].rs
struct FHQtreap{
    int ls,rs;
    int pri;
    int siz,v,fa,l,r,gap;
}t[N];
int cnt,root,vroot,mini=1145141919;
int cntt[N];
inline int newnode(int x){
    t[++cnt]=(FHQtreap){0,0,rand(),1,x,0,x,x,1145141919};
    return cnt;
}
inline void update(int u){
    t[u].gap=1145141919;
    t[u].siz=1;
    t[u].l=t[u].r=t[u].v;
    if(lc){ 
        t[u].siz+=t[lc].siz;
        t[u].l=t[lc].l;
        t[u].gap=min(t[u].gap,abs(t[u].v-t[lc].r));
        t[u].gap=min(t[u].gap,t[lc].gap);
        t[lc].fa=u;
    }
    if(rc){
        t[u].siz+=t[rc].siz;
        t[u].r=t[rc].r;
        t[u].gap=min(t[u].gap,abs(t[u].v-t[rc].l));
        t[u].gap=min(t[u].gap,t[rc].gap);
        t[rc].fa=u;
    }
}
inline void split(int u,int x,int &L,int &R){//排名分裂
    if(u==0)return (void)(L=R=0);
    if(t[t[u].ls].siz+1<=x)L=u,split(t[u].rs,x-t[t[u].ls].siz-1,t[u].rs,R);
    else                   R=u,split(t[u].ls,x,L,t[u].ls);
    update(u);
}

inline void vsplit(int u,int x,int &L,int &R){//权值分裂
    if(u==0)return (void)(L=R=0);
    if(t[u].v<=x)L=u,vsplit(t[u].rs,x,t[u].rs,R);
    else R=u,vsplit(t[u].ls,x,L,t[u].ls);
    update(u);
}
inline int merge(int L,int R){
    if(!L||!R)return L|R;
    if(t[L].pri>t[R].pri){t[L].rs=merge(t[L].rs,R),update(L);return L;}
    else                 {t[R].ls=merge(L,t[R].ls),update(R);return R;}
}
inline int id(int u){
    int res=t[lc].siz+1;
    while(u!=root){
        if(t[t[u].fa].rs==u)res+=t[t[t[u].fa].ls].siz+1;
        u=t[u].fa;
    }
    return res;
}
inline int kth(int u,int k){
    if(!u||t[u].siz<k)return -11451419;
    if(t[lc].siz+1==k)return t[u].v;
    if(t[lc].siz>=k)return kth(lc,k);
    if(t[lc].siz+1<k)return kth(rc,k-t[lc].siz-1);
}
signed main(){
    srand(time(NULL));
    // freopen("in.in","r",stdin);
    // freopen("a.out","w",stdout);
    scanf("%d%d",&n,&m);
    for(int i=1,a;i<=n;++i){
        scanf("%d",&a);
        root=merge(root,newnode(a));
    }
    int L,R;
    for(int i=1;i<=n;++i){
        vsplit(vroot,t[i].v,L,R);
        mini=min(mini,abs(kth(L,t[L].siz)-t[i].v));
        mini=min(mini,abs(kth(R,1)-t[i].v));
        vroot=merge(merge(L,newnode(t[i].v)),R);
    }
    int i,k,j;
    char s[20];
    while(m--){
        scanf("%s",s);
        if(s[0]=='I'){
            scanf("%d%d",&i,&k);
            j=id(i);//寻找原数列的第i个数在排名树中的位置
            j+=cntt[i];
            ++cntt[i];
            //操作排名树
            split(root,j,L,R);
            root=merge(merge(L,newnode(k)),R);
            //操作权值树
            vsplit(vroot,k,L,R);
            mini=min(mini,abs(kth(L,t[L].siz)-k));//查询前驱尝试更新答案
            mini=min(mini,abs(kth(R,1)-k));//查询后继尝试更新答案
            vroot=merge(merge(L,newnode(k)),R);
        }
        if(s[4]=='G')cout<<t[root].gap<<"\n";
        if(s[4]=='S')cout<<mini<<"\n";
    }
    return 0;
}
/*
文件名: p1110.cpp
创建时间: 2024-10-11 18:33:41
作者: nnn233
*/
```

---

## 作者：doby (赞：2)

用Treap，常数略大，需要在夜深人静评测姬比较空闲的时候提交

保存每个位置上最前和最后的数，用来在插入时更新相邻的差值

开两棵平衡树，一棵维护所有数，另一棵维护相邻元素的差值

插入时要将之前的差值弹出

合理减小常数，可以减少第二棵树更新答案的次数，在修改时打上标记，在询问的时候再更新答案

同时，当MINSORTGAP的答案==0时就可以不再更新第一棵生成树

这样就差不多能跑过去了
```cpp
#include<cstdio>
#include<cstdlib>
using namespace std;
int n,m,opt,x,y,mg,msg=519260817,ch,tot1,tot2,root1,root2,f[500010],l[500010],out;
char c,s[50];
struct Treap
{
	int l,r,val,cnt,size,dat;
}t1[1000010],t2[1000010];
int read()
{
	out=0,c=getchar();
	while(c<48||c>57){c=getchar();}
	while(c>=48&&c<=57){out=(out<<3)+(out<<1)+(c&15),c=getchar();}
	return out;
}
int min(int a,int b)
{
	return a<b?a:b;
}
int New1(int val)
{
	t1[++tot1].val=val,t1[tot1].cnt=1,t1[tot1].size=1,
	t1[tot1].dat=rand()%19260817;
	return tot1;
}
void Update1(int p)
{
	t1[p].size=t1[t1[p].l].size+t1[t1[p].r].size+t1[p].cnt;
}
void Zig1(int &p)
{
	int q=t1[p].l;
	t1[p].l=t1[q].r,t1[q].r=p,p=q;
	Update1(t1[q].r);Update1(p);
}
void Zag1(int &p)
{
	int q=t1[p].r;
	t1[p].r=t1[q].l,t1[q].l=p,p=q;
	Update1(t1[q].l);Update1(p); 
}
void Insert1(int &p,int val)
{
	if(!p){p=New1(val);return;}
	if(val==t1[p].val){++t1[p].cnt;Update1(p);return;}
	if(val<t1[p].val)
	{
		Insert1(t1[p].l,val);
		if(t1[p].dat<t1[t1[p].l].dat){Zig1(p);}
	}
	else
	{
		Insert1(t1[p].r,val);
		if(t1[p].dat<t1[t1[p].r].dat){Zag1(p);}
	}
	Update1(p);
}
int GP(int val)
{
	int ans=1,p=root1;
	while(p)
	{
		if(val==t1[p].val){return val;}
		if(t1[p].val<val&&t1[p].val>t1[ans].val){ans=p;}
		p=val<t1[p].val?t1[p].l:t1[p].r; 
	}
	return t1[ans].val;
}
int GS(int val)
{
	int ans=2,p=root1;
	while(p)
	{
		if(val==t1[p].val){return val;}
		if(t1[p].val>val&&t1[p].val<t1[ans].val){ans=p;}
		p=val<t1[p].val?t1[p].l:t1[p].r; 
	}
	return t1[ans].val;
}
int New2(int val)
{
	t2[++tot2].val=val,t2[tot2].cnt=1,t2[tot2].size=1,
	t2[tot2].dat=rand()%19260817;
	return tot2;
}
void Update2(int p)
{
	t2[p].size=t2[t2[p].l].size+t2[t2[p].r].size+t2[p].cnt;
}
void Zig2(int &p)
{
	int q=t2[p].l;
	t2[p].l=t2[q].r,t2[q].r=p,p=q;
	Update2(t2[q].r);Update2(p);
}
void Zag2(int &p)
{
	int q=t2[p].r;
	t2[p].r=t2[q].l,t2[q].l=p,p=q;
	Update2(t2[q].l);Update2(p); 
}
void Insert2(int &p,int val)
{
	if(!p){p=New2(val);return;}
	if(val==t2[p].val){++t2[p].cnt;Update2(p);return;}
	if(val<t2[p].val)
	{
		Insert2(t2[p].l,val);
		if(t2[p].dat<t2[t2[p].l].dat){Zig2(p);}
	}
	else
	{
		Insert2(t2[p].r,val);
		if(t2[p].dat<t2[t2[p].r].dat){Zag2(p);}
	}
	Update2(p);
}
void Delete(int &p,int val)
{
	if(!p){return;}
	if(val==t2[p].val)
	{
		if(t2[p].cnt>1){--t2[p].cnt;Update2(p);return;}
		if(t2[p].l||t2[p].r)
		{
			if(!t2[p].r||t2[t2[p].l].dat>t2[t2[p].r].dat){Zig2(p);Delete(t2[p].r,val);}
			else{Zag2(p);Delete(t2[p].l,val);}
			Update2(p);
		}
		else{p=0;}
		return;
	}
	val<t2[p].val?Delete(t2[p].l,val):Delete(t2[p].r,val);
	Update2(p);
}
int GVBR(int p,int rank)
{
	if(!p){return 1019260817;}
	if(t2[t2[p].l].size>=rank){return GVBR(t2[p].l,rank);}
	if(t2[t2[p].l].size+t2[p].cnt>=rank){return t2[p].val;}
	return GVBR(t2[p].r,rank-t2[t2[p].l].size-t2[p].cnt);
}
void Build()
{
	New1(-1019260817);New1(1019260817);
	New2(-1019260817);New2(1019260817);
	root1=1,t1[1].r=2,
	root2=1,t2[1].r=2;
	Update1(root1);
	Update2(root2);
}
int main()
{
	Build();
	n=read(),m=read(),f[n+1]=1019260817,ch=1;
	for(int i=1;i<=n;++i)
	{
		f[i]=read(),l[i]=f[i],
		msg=min(msg,min(GS(f[i])-f[i],f[i]-GP(f[i])));
		if(i>1){Insert2(root2,abs(f[i]-f[i-1]));}
		Insert1(root1,f[i]);
	}
	while(m--)
	{
		scanf("%s",s);
		for(int i=0;;++i)
		{
			if(s[i]=='E'){opt=0;break;}
			if(s[i]=='G'){opt=1;break;}
			if(s[i]=='O'){opt=2;break;}
		}
		if(!opt)
		{
			x=read(),y=read();
			Delete(root2,abs(f[x+1]-l[x]));
			Insert2(root2,abs(y-l[x]));
			Insert2(root2,abs(f[x+1]-y));
			msg=min(msg,min(GS(y)-y,y-GP(y))),l[x]=y,ch=1;
			Insert1(root1,y);
		}
		if(opt==1)
		{
			if(ch){ch=0;mg=GVBR(root2,2);}
			printf("%d\n",mg);
		}
		if(opt==2){printf("%d\n",msg);}
	}
	return 0;
}
```

---

## 作者：7KByte (赞：2)

平衡树好题   

----------------

不废话，步入正题   


我先把题意补充一下，对于$INSERT\ \ i\ \ k$  操作，并不是以元素为坐标在元素后面添加一个数，而是以分段为单位，在第$i$段末端加入一个
元素$k$，例如样例  
```
[5][3][1]
```
在第2段插入9
```
[5][3,9][1]
```
在第2段插入6
```
[5][3,9,6][1]
```
如果在第3段插入$x$ 
```
[5][3,9,6][1,x]
```
分段只是方便说明插入操作，相邻段之间的差值也要计算  


-------------------------

因为有了分段，所以我们可以进行更方便的处理

对于每一段的表示，记录一个$prev$和$last$(在我程序中是$x$数组和$y$数组)，对于插入操作，我们只用修改对应分段的$last$  



---------------
对于$MIN\_GAP$询问  
我们构造一棵平衡树，保存当前的相邻差值的最小值(为什么用平衡树？因为后面有删除操作)  
最开始的$n-1$个差值记得先加入  
对于每个$INSERT$操作  
- 如果加入的地方不是最后一段，就要把操作前这一段与下一段相邻的差值删除   
- 加入该数与前面一个数的差值  
- 如果加入的地方不是最后一段，则加入这个数与下一段的第一个数的差值  

见代码
```cpp
scanf("%d%d",&p,&q);
if(p!=n)remove(root,abs(x[p+1]-y[p]));
insert(root,abs(q-y[p]));
y[p]=q;
if(p!=n)insert(root,abs(x[p+1]-y[p]));
//后面的先不用管
Min=min(Min,min(abs(q-getprev_(q)),abs(q-getnext_(q))));
insert_(root_,q);
```
每次询问的答案即是平衡树中的最小值

-----------------------

对于$MIN\_SORT\_GAP$询问  
建议先看这道题：[营业额统计](https://www.luogu.org/problemnew/show/P2234)  
与这道题非常相似，只是换了一种问法  
再开一棵平衡树，存加入的元素的值，
开一个元素$Min$保留当前答案，每次加入数的时候找前驱后继与它的差值保留最小值  
别忘了最开始的n个数也要按顺序加进去   
现在你应该明白上面代码的最后两行什么意思


---------------------
手打两棵平衡树真心不容易，发泄一下  
开始用了$STL\ set$和$STL\ string$  
结果开了$O2$还是$TLE$，改成手打平衡树和$char$数组后，不开$O2$也能$AC$。  
奉上我的长达$6KB$的代码：  
```cpp
\\自认为码风还挺好看的
\\前面平衡树模板可以跳过  
\\特别注意，如果您的平衡树是数组模拟且没有栈优化的内存回收，平衡树的元素一定要开到2000000，因为有删除操作
#include<bits/stdc++.h>
#define INF (1<<30)
using namespace std;
struct node{
	int l,r,data,val,size,cnt;
}a[2000005],b[2000005];
int pop=0,root;
int New(int data){
	pop++;
	a[pop].l=a[pop].r=0;
	a[pop].data=data;
	a[pop].val=rand();
	a[pop].size=1;
	a[pop].cnt=1;
	return pop;
}
void updata(int p){
	a[p].size=a[a[p].l].size+a[a[p].r].size+a[p].cnt;
}
void build(){
	root=New(-INF);
	a[root].r=New(INF);
	updata(root);a[0].cnt=a[0].data=a[0].size=a[0].val=0;
}
void zig(int &p){
	int q=a[p].l;
	a[p].l=a[q].r;
	a[q].r=p;p=q;
	updata(a[p].r);
	updata(p);
}
void zag(int &p){
	int q=a[p].r;
	a[p].r=a[q].l;
	a[q].l=p;p=q;
	updata(a[p].l);
	updata(p);
}
void insert(int &p,int data){
	if(p==0){
		p=New(data);
		return;
	}
	if(data==a[p].data){
		a[p].cnt++;
		updata(p);
		return;
	}
	if(data<a[p].data){
		insert(a[p].l,data);
		if(a[a[p].l].val>a[p].val)zig(p);
		else updata(p);
		return;
	}
	if(data>a[p].data){
		insert(a[p].r,data);
		if(a[a[p].r].val>a[p].val)zag(p);
		else updata(p);
		return;
	}
}
void remove(int &p,int data){
	if(p==0)return;
	if(a[p].data==data){
		if(a[p].cnt>1){
			a[p].cnt--;
			updata(p);
			return;
		}
		if(a[p].l||a[p].r){
			if(a[p].r==0||a[a[p].l].val>a[a[p].r].val)
			  zig(p),remove(a[p].r,data);
			else zag(p),remove(a[p].l,data);
			updata(p);return;
		}
		p=0;return;
	}
	if(data<a[p].data)remove(a[p].l,data);
	else remove(a[p].r,data);updata(p);
}
int getprev(int data){
	int ans=1;
	int p=root;
	while(p){
		if(data>a[p].data){
			if(a[p].data>=a[ans].data)
			  ans=p;
			p=a[p].r;
		}
		else p=a[p].l;
	}
	return a[ans].data;
}
int getnext(int data){
	int ans=2;
	int p=root;
	while(p){
		if(data<a[p].data){
			if(a[p].data<=a[ans].data);
			  ans=p;
			p=a[p].l;
		}
		else p=a[p].r;
	}
	return a[ans].data;
}
int getvalbyrank(int p,int rank){
	if(p==0)return 0;
	if(a[a[p].l].size>=rank)return getvalbyrank(a[p].l,rank);
    if(a[a[p].l].size+a[p].cnt>=rank)return a[p].data;
    return getvalbyrank(a[p].r,rank-a[p].cnt-a[a[p].l].size);
}
int getrankbyval(int p,int val){
	if(p==0)return 0;
	if(val==a[p].data) return a[a[p].l].size+1;
	if(val<a[p].data)return getrankbyval(a[p].l,val);
	return getrankbyval(a[p].r,val)+a[a[p].l].size+a[p].cnt;
}
int top=0,root_;
int New_(int data){
	top++;
	b[top].l=b[top].r=0;
	b[top].data=data;
	b[top].val=rand();
	b[top].size=1;
	b[top].cnt=1;
	return top;
}
void updata_(int p){
	b[p].size=b[b[p].l].size+b[b[p].r].size+b[p].cnt;
}
void build_(){
	root_=New_(-INF);
	b[root_].r=New_(INF);
	updata_(root_);b[0].cnt=b[0].data=b[0].size=b[0].val=0;
}
void zig_(int &p){
	int q=b[p].l;
	b[p].l=b[q].r;
	b[q].r=p;p=q;
	updata_(b[p].r);
	updata_(p);
}
void zag_(int &p){
	int q=b[p].r;
	b[p].r=b[q].l;
	b[q].l=p;p=q;
	updata_(b[p].l);
	updata_(p);
}
void insert_(int &p,int data){
	if(p==0){
		p=New_(data);
		return;
	}
	if(data==b[p].data){
		b[p].cnt++;
		updata_(p);
		return;
	}
	if(data<b[p].data){
		insert_(b[p].l,data);
		if(b[b[p].l].val>b[p].val)zig_(p);
		else updata_(p);
		return;
	}
	if(data>b[p].data){
		insert_(b[p].r,data);
		if(b[b[p].r].val>b[p].val)zag_(p);
		else updata_(p);
		return;
	}
}
void remove_(int &p,int data){
	if(p==0)return;
	if(b[p].data==data){
		if(b[p].cnt>1){
			b[p].cnt--;
			updata_(p);
			return;
		}
		if(b[p].l||b[p].r){
			if(b[p].r==0||b[b[p].l].val>b[b[p].r].val)
			  zig_(p),remove_(b[p].r,data);
			else zag_(p),remove_(b[p].l,data);
			updata_(p);return;
		}
		p=0;return;
	}
	if(data<b[p].data)remove_(b[p].l,data);
	else remove_(b[p].r,data);updata_(p);
}
int getprev_(int data){
	int ans=1;
	int p=root_;
	while(p){
		if(b[p].data==data)return data;
		if(data>b[p].data){
			if(b[p].data>=b[ans].data)
			  ans=p;
			p=b[p].r;
		}
		else p=b[p].l;
	}
	return b[ans].data;
}
int getnext_(int data){
	int ans=2;
	int p=root_;
	while(p){
		if(b[p].data==data)return data;
		if(data<b[p].data){
			if(b[p].data<=b[ans].data);
			  ans=p;
			p=b[p].l;
		}
		else p=b[p].r;
	}
	return b[ans].data;
}
int getvalbyrank_(int p,int rank){
	if(p==0)return 0;
	if(b[b[p].l].size>=rank)return getvalbyrank_(b[p].l,rank);
    if(b[b[p].l].size+b[p].cnt>=rank)return b[p].data;
    return getvalbyrank_(b[p].r,rank-b[p].cnt-b[b[p].l].size);
}
int getrankbyval_(int p,int val){
	if(p==0)return 0;
	if(val==b[p].data) return b[b[p].l].size+1;
	if(val<b[p].data)return getrankbyval_(b[p].l,val);
	return getrankbyval_(b[p].r,val)+b[b[p].l].size+b[p].cnt;
}
int n,m,x[500005],y[500005];
#define oo 0x3f3f3f3f
int main()
{
	srand(time(0));
	build();build_();
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
    	scanf("%d",&x[i]);
    	y[i]=x[i];
	}
	int Min=0x7fffffff;
	for(int i=1;i<n;i++){
		insert(root,abs(x[i+1]-y[i]));
	}
	insert_(root_,x[1]);
	for(int i=2;i<=n;i++){
		Min=min(Min,min(abs(x[i]-getprev_(x[i])),abs(x[i]-getnext_(x[i]))));
		insert_(root_,x[i]);
	}
	char t[1000];int p,q;
    for(int i=1;i<=m;i++){
    	scanf("%s",t);
        if(t[0]=='I'){
        	scanf("%d%d",&p,&q);
        	if(p!=n)remove(root,abs(x[p+1]-y[p]));
        	insert(root,abs(q-y[p]));
        	y[p]=q;
        	if(p!=n)insert(root,abs(x[p+1]-y[p]));
        	Min=min(Min,min(abs(q-getprev_(q)),abs(q-getnext_(q))));
        	insert_(root_,q);
		}
		else if(t[4]=='G'){
			printf("%d\n",getvalbyrank(root,2));
		}
		else{
			printf("%d\n",Min);
		}
	}
    return 0;
}
```

---

## 作者：吾王美如画 (赞：2)

wa了半年的题目，今天终于调出来了qaq，写篇题解纪念下。

----
这真是道语文题。题目的意思其实是。给你n个队列，每次加数到队尾。操作3是问在所有的数中最小的差。而操作2是问相邻的数间最小的差，且第i个队列的队尾和第i+1个队列的队头是相邻的

- 对于操作3，直接把所有数字丢到平衡树里，再查询前后缀就行。
- 对于操作2，我们要维护的是所有相邻的数的差的最小值。由于修改的特性，每次在第a个队列加一个数字，会增加两个差，一个是与之前队尾的差，另一个是与a+1队头的差。还会减少一个之前队尾和a+1队头的差（这是显而易见的吧）。在这过程中我们发现，根本没必要记录每个队列里的数，因为跟操作完全不相干。只需记录队头和队尾就好了。
- 操作2肯定是可以拿平衡树做的。但我看到有大佬拿2个堆当作一个带删除的堆来维护也是极巧的。我们把以前存在过的所以差都丢进第一个小根堆，要删除的丢进第二个小根堆。如果两个堆的堆顶相同，直接弹出，直到堆顶不相同。此时的MIN_GAP就是第一个堆的堆顶，因为它绝对是最小的，且目前存在。

最后一些细节问题大家直接见代码啦
```cpp
#include<bits/stdc++.h>
#define MAXN 501000
#define INF 2047483647
using namespace std;
int sum=0,R=0;
int son[MAXN][2],num[MAXN],size[MAXN],tree[MAXN],rd[MAXN],n,m;
int MIN_SORT_GAP=INF,MIN_GAP=INF;
void up(int now){
     size[now]=size[son[now][0]]+size[son[now][1]]+num[now];
}
void rotate(int &now,int d){
     int to=son[now][!d];
     son[now][!d]=son[to][d];
     son[to][d]=now;
     up(now);
     up(to);
     now=to;
}
void change(int &now,int x){
     if (!now){now=++sum;size[now]=num[now]=1;tree[now]=x;rd[now]=rand();return;}
     else if(tree[now]==x){num[now]++;size[now]++;return;}; 
     int tmp=(x>tree[now]);
     change(son[now][tmp],x);
     if (rd[now]>rd[son[now][tmp]])rotate(now,!tmp);
     up(now);
}
int pre(int now,int x){
    if(!now)return -INF;
    if (tree[now]>x)return pre(son[now][0],x);
    else if (tree[now]==x)return tree[now];
    else return max(tree[now],pre(son[now][1],x));
}
int suc(int now,int x){
    if(!now)return INF;
    if (tree[now]<x)return suc(son[now][1],x);
    else if (tree[now]==x)return tree[now];
    else return min(tree[now],suc(son[now][0],x));
}
int end[500010],sta[500010];
int main(){
	//freopen("test1.out","w",stdout);
    cin>>n>>m;
    memset(son,0,sizeof(son));
    change(R,INF);
    change(R,-INF);
    priority_queue<int>q1,q2;
    while(!q1.empty())q1.pop();
    while(!q2.empty())q2.pop();
    for(int i=1;i<=n;i++){
            scanf("%d",&sta[i]);
            end[i]=sta[i];
            MIN_SORT_GAP=min(MIN_SORT_GAP,abs(sta[i]-pre(R,sta[i])));
            MIN_SORT_GAP=min(MIN_SORT_GAP,abs(suc(R,sta[i])-sta[i]));
            change(R,sta[i]);
            if (i!=1)q1.push(-abs(sta[i]-sta[i-1]));
    }
    MIN_GAP=-q1.top();
    for(int i=1;i<=m;i++){
            string s;
            int a,b;
            cin>>s;
            if (s=="MIN_GAP") {
				cout<<MIN_GAP<<endl;
				continue;
			}
            if (s=="MIN_SORT_GAP"){
				cout<<MIN_SORT_GAP<<endl;
				continue;
			}
            
            scanf("%d%d",&a,&b);
            if (a!=n){
				q1.push(-abs(b-sta[a+1]));
            	q2.push(-abs(end[a]-sta[a+1]));
			}
            q1.push(-abs(b-end[a]));
            end[a]=b;
            while(q1.top()==q2.top()){q1.pop();q2.pop();};
            MIN_GAP=-q1.top();
            
            if (MIN_SORT_GAP==0)continue;
            MIN_SORT_GAP=min(MIN_SORT_GAP,abs(b-pre(R,b)));
            MIN_SORT_GAP=min(MIN_SORT_GAP,abs(suc(R,b)-b));
            change(R,b);
    }
    return 0;
}
```


---

## 作者：FutaRimeWoawaSete (赞：1)

这道题考虑平衡树做法。  
很明显我们直接套平衡树很难维护第二个操作，于是我们~~放弃思考~~，再套一个线段树维护第二个操作即可。  
主要想讲一下线段树维护第二个操作的思想与该题注意点。  
经观察发现，我们的insert其实很有特点，那就是每次插入曾经插入过的位置时，那些曾经在该位置插入好的元素之间的差值是恒定不变的，所以一次insert真正改变的只有当前插入的这个值与上一个在当前位置插入的值与下一个位置的初始元素。有点费解的一句话，在这里举样例理解。  
样例初始时是这样的：   
```cpp
5 3 1
```
2位置插入了一个元素9：  
```cpp
5 3 9 1
```
又在2位置插入了一个元素6：
```cpp
5 3 9 6 1
```
我们观察插入6时，改变的相当于只有他和9的差值与1的差值。  
假如我们还要在2位置插入一个7的话：   
```cpp
5 3 9 6 7 1
```
这就更直观放映出来刚才的结论了，3 9 6完全不变了，变的只有7与6以及7与1的差值。  
但是此时又有一个问题：一次插入可能会使答案变大，比如我本来答案是1 1的值0，但是假如此时我们在中间插入10000，答案就要变大了对吧。  
所以说我们还需要维护最小差值，考虑线段树单点修改即可。  
这就是大体做法吧。  
# PS
接下来讲讲细节吧。  
我们在维护初始的MIN_SORT_GAP值时，我们其实可以边加入边维护。很多人可能会想这样做可能会导致前面插入的数据正确性有问题，于是就全部插入后先删掉该元素更新一次再还原这个元素。其实这么做没有必要而且还有可能WA掉，其实我们只要边插入边维护初始值就可以了。  
因为我们在没插入完所有数时，虽然我们在这一次不一定得到正确的前驱或者后继，但是这也说明了一个情况：我们此时正确的前驱或者后继还未插入。所以在后面插入这个数的前驱或者后继时就可以更新到这个值，所以可以边加边维护。  
再解释一下，因为对于每个数的前驱后继在所有都插入完后（即保证每个的正确性后）其实都重复贡献了一次，我们只需要一次就行了不是吗？  
可能还是有点模糊，倘若还是没懂就自己举例理解吧。  
# 还有几个小点：  
1.线段树维护时，建议令a[0] = a[n + 1] = INF，然后build时直接ans[p] = abs(a[l] - a[l - 1])即可；  
2.平衡树插入INF，-INF，~~老问题了~~；  
3.一个偷懒小技巧——因为我们查询的是1~n，所以不用写query直接return ans[1]即可；  
# 上代码：  
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
using namespace std;
const int Len = 1e6 + 5,Inf = 99999999999LL;
int read()
{
	int x = 0, k = 1;
	char c;
	c = getchar();
	while(c < '0' || c > '9') { if(c == '-') k = -1; c = getchar();}
	while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
	return x * k;
}
int ls(int x){return x << 1;}
int rs(int x){return x << 1 | 1;}
int n,m,opt,x,tot,root,ans[Len << 2],a[Len],b[Len],wh,ans1 = Inf,ans2 = Inf;
int last[Len];
struct node
{
	int ch[2],size,cnt,ff,val;
}t[Len];
void rotate(int x)
{
	int y = t[x].ff,z = t[y].ff,k = t[y].ch[1] == x;
	t[z].ch[t[z].ch[1] == y] = x;
	t[x].ff = z;
	//
	t[y].ch[k] = t[x].ch[k ^ 1];
	t[t[x].ch[k ^ 1]].ff = y;
	//
	t[x].ch[k ^ 1] = y;
	t[y].ff = x; 
}
void Splay(int x,int goal)
{
	while(t[x].ff != goal)
	{
		int y = t[x].ff,z = t[y].ff;
		if(z != goal) (t[y].ch[1] == x) ^ (t[z].ch[1] == y) ? rotate(x) : rotate(y);
		rotate(x);
	}
	if(goal == 0) root = x;
}
void insert(int x)
{
	int u = root,ff = 0;
	while(u && t[u].val != x) ff = u,u = t[u].ch[x > t[u].val];
	if(!u)
	{
		u = ++ tot;
		if(ff) t[ff].ch[x > t[ff].val] = u;
		t[u].ch[0] = t[u].ch[1] = 0;
		t[u].cnt = t[u].size = 1,t[u].val = x,t[u].ff = ff;
		Splay(u , 0);
	}
}
void Find(int x)
{
	int u = root;
	if(!u) return;
	while(t[u].ch[x > t[u].val] && t[u].val != x) u = t[u].ch[x > t[u].val];
	Splay(u , 0);
}
int Next(int x,int f)
{
	Find(x);
	int u = root;
	if(t[u].val == x) return x;
	if((t[u].val > x && f) || (t[u].val < x && !f)) return t[u].val;
	u = t[u].ch[f];
	while(t[u].ch[f ^ 1]) u = t[u].ch[f ^ 1];
	return t[u].val;
}
void push_up(int p){ans[p] = min(ans[ls(p)],ans[rs(p)]);}
void build(int p,int l,int r)
{
	if(l == r){ans[p] = abs(a[l] - a[l - 1]) ; return;}
	int mid = (l + r) >> 1;
	build(ls(p) , l , mid);
	build(rs(p) , mid + 1 , r);
	push_up(p);
}
void update(int p,int l,int r,int idx,int x)
{
	if(l == r)
	{
		ans[p] = x;
		return;
	}
	int mid = (l + r) >> 1;
	if(idx <= mid) update(ls(p) , l , mid , idx , x);
	else update(rs(p) , mid + 1 , r , idx , x);
	push_up(p);
}
char s[15];
void Update(int x){ans2 = min(ans2,min(abs(x - Next(x , 0)) , abs(x - Next(x , 1))));}
signed main()
{
	insert(Inf),insert(-Inf);
	n = read() , m = read();
	a[0] = a[n + 1] = Inf;
	for(int i = 1; i <= n; i ++) 
	{
		last[i] = a[i] = read();
		if(i != 1) Update(a[i]);
		insert(a[i]);
	}
	build(1 , 1 , n);
	while(m --)
	{
		scanf("%s",s);
		int lens = strlen(s);
		if(lens == 6)
		{
			wh = read(),x = read();
			Update(x);
			insert(x);
			ans1 = min(ans1 , abs(x - last[wh]));
			update(1 , 1 , n  , wh + 1, abs(x - a[wh + 1]));
			last[wh] = x;
		}
		else if(lens == 7) printf("%d\n",min(ans1 , ans[1]));
		else if(lens == 12) printf("%d\n",ans2);
	}
	return 0;
}
```
# 完结撒花！

---

## 作者：MikukuOvO (赞：1)

手写平衡树固然是可以的，但是我们要善用$STL$。

考虑到两个询问间没有什么关系，因此我们分开维护。

维护两个$multiset$,对于所有元素就维护元素本身，找到时候$lower$ $_$ $bound$然后和相邻两个值去$min$即可。

对于相邻元素我们维护两个数组$a$，$b$，分别是原数组和修改的这里我们维护相邻元素差值，支持插入和删除。

时间复杂度$O(nlogn)$。

代码意会即可，有很多$define$这里没粘。

```cpp
const int N=5e5+5;

int n,m;
int a[N],b[N];
multiset<int>t,s;
multiset<int>::iterator it;

int main()
{
    fio();
    gi(n),gi(m);
    for(int i=1;i<=n;++i) gi(a[i]),b[i]=a[i],t.insert(a[i]);
    char op[15];
    int x,y,z,min2=INF;
    for(int i=2;i<=n;++i) s.insert(abs(a[i]-a[i-1]));
    it=t.begin();
    ++it;
    for(;it!=t.end();++it)
    {
        --it,x=*it;
        ++it,y=*it;
        min2=min(min2,abs(x-y));
    }
    while(m--)
    {
        cin>>op;
        if(op[0]=='I')
        {
            gi(x),gi(y);
            s.insert(abs(y-b[x]));
            if(x!=n) s.erase(s.find(abs(b[x]-a[x+1]))),s.insert(abs(y-a[x+1]));
            b[x]=y;
            it=t.lower_bound(y);
            --it,x=*it;
            ++it,z=*it;
            min2=min({min2,abs(x-y),abs(y-z)});
            t.insert(y);
        }
        else if(op[4]=='G')
        {
            it=s.begin();
            print(*it),putchar(10);
        }
        else print(min2),putchar(10);
    }
    end();
}
```

---

## 作者：风随逐影 (赞：1)

# STL_multiset的经典应用——代替平衡树

### 一道真正意义上有思维难度的STL题目

如果询问一个区间（最值/求和），我们是无法用STL做的

但是此题询问的是整个数组的最值，这就给了我们可乘之机

对于全元素的最小差，我们维护一个单调数列（multiset），用一个全局变量记录答案即可

对于相邻元素最小差，因为涉及到删除不能用全局变量维护，用一个支持插入删除排序的multiset维护即可

[原题解](https://www.luogu.org/blog/cmd2001/solution-p1110)
```
const int N=5e5+10,inf=0x3f3f3f3f;
int n,m,st[N],ed[N],d=inf;
multiset<int>full,delta;
typedef multiset<int>::iterator It;
void update(int x){
	It it=full.lower_bound(x);
	It lt=it;lt--;
	d=min(d,min(*it-x,x-*lt));
	full.insert(x);
}
void change(int pos,int x){
	delta.insert(abs(x-ed[pos]));
	if(pos!=n){
		delta.insert(abs(x-st[pos+1]));
		It it=delta.find(abs(ed[pos]-st[pos+1]));
		delta.erase(it);
	}
	ed[pos]=x;
}
int main(){
	//fin;
	read(n),read(m);
	go(i,1,n) read(st[i]),ed[i]=st[i];
	full.insert(inf),full.insert(-inf);
	//更方便地处理前驱后继，而不用考虑没有前驱/后继的情况 
	go(i,1,n-1) delta.insert(abs(st[i+1]-ed[i]));
	go(i,1,n) update(st[i]);
	char s[20];
	for(int i=1,pos,x;i<=m;++i){
		scanf("%s",s);
		if(s[0]=='I'){
			read(pos),read(x);
			update(x),change(pos,x);
		}
		else if(s[4]=='S') printf("%d\n",d);
		else printf("%d\n",*delta.begin());
	}
	return 0;
}
```


---

## 作者：HOOCCOOH (赞：1)

**STL大法好，set把你保**

MIN\_SORT\_GAP用set维护，插入前lower\_bound找最接近的值，更新最小值，然后insert

MIN\_GAP用堆维护，在a,b之间插入c时，把abs(a-b)从堆中删除，然后插入abs(a-c)和abs(b-c)

(由于本蒟蒻只会用stl堆，不支持删除，所以用了两个堆来达到删除指定数值，具体见代码)

记得插入的时候，找到真正与当前相邻的节点，因为之前可能已经插入了一些节点，所以用链表来O(1)找到当前相邻。

代码比较丑，但比手写某树和某堆方便多了

```cpp

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <cctype>
#include <set>
using namespace std;
typedef long long ll;

int iRead()
{
    int ret = 0;
    int ch;
    while(!isdigit(ch = getchar()) && ch != '-');
    bool bm = (ch == '-'); if(bm) ch = getchar();
    while(ret = ret * 10 + (ch - '0'), isdigit(ch = getchar()));
    return bm ? -ret : ret;
}

void iReadstr(char *p)
{
    int ch;
    while(isspace(ch = getchar()));
    while(*p++ = ch, !isspace(ch = getchar()));
    *p = '\0';
}

const int N = 1500003;
const int INF = 0x7FFFFFFF;
int n, m;
struct iT
{
    int val;
    iT *l, *r;
}ss[N], *sp = ss;
iT *arr[N];
int ss1[N], *pss1 = ss1;
int ss2[N], *pss2 = ss2;
set<int> s;
int ans2 = INF;

bool iCmp(int a, int b) {return a > b;}

void iUp(int val)
{
    if(ans2)
    {
        pair<set<int>::iterator, bool> pr = s.insert(val);
        if(pr.second)
        {
            set<int>::iterator it;
            if(pr.first != s.begin())
            {
                it = pr.first;
                ans2 = min(ans2, abs(*--it - val));
            }
            if(++pr.first != s.end())
                ans2 = min(ans2, abs(*pr.first - val));
                
        }
        else
            ans2 = 0;
    }
}

int iAns1()
{
    while(pss2 != ss2 && ss1[0] == ss2[0])
    {
        pop_heap(ss1, pss1--, iCmp);
        pop_heap(ss2, pss2--, iCmp);
    }
    return ss1[0];
}

void iInsert(iT *c, int val)
{
    iT *nc = sp++;
    *nc = (iT){val, c, c->r};
    
    if(c->r->val != INF)
    {
        *pss2++ = abs(c->val - c->r->val);
        push_heap(ss2, pss2, iCmp);
    }
    
    c->r->l = nc;
    c->r = nc;
    
    *pss1++ = abs(c->val - c->r->val);
    push_heap(ss1, pss1, iCmp);
    if(c->r->r->val != INF)
    {
        *pss1++ = abs(c->r->val - c->r->r->val);
        push_heap(ss1, pss1, iCmp);
    }
}

int main()
{
    n = iRead(), m = iRead();
    for(int i = 0; i < n; ++i)
    {
        int c = iRead();
        arr[i] = sp++;
        arr[i]->val = c;
        iUp(c);
        if(i)
        {
            *pss1++ = abs(c - arr[i - 1]->val);
            push_heap(ss1, pss1, iCmp);
        }
    }
    *(arr[n] = sp++) = (iT){INF, arr[n - 1], NULL};
    for(int i = 0; i < n; ++i)
    {
        if(i)
            arr[i]->l = arr[i - 1];
        if(i != n - 1)
            arr[i]->r = arr[i + 1];
    }
    
    char str[20];
    while(m--)
    {
        int a, b;
        iReadstr(str);
        switch(str[4])
        {
            case 'R':
                a = iRead(), b = iRead();
                iInsert(arr[a]->l, b);
                iUp(b);
                break;
                
            case 'G':
                printf("%d\n", iAns1());
                break;
                
            default:
                printf("%d\n", ans2);
        }
    }
    
    return 0;
}

```

---

## 作者：上进的z君 (赞：1)

**目测很麻烦。只用STL库会超时。**

所以建了两棵树维护MIN\_GAP和MIN\_SORT\_GAP。

代码很长。

```cpp

#include<set>  
#include<queue>  
#include<vector>  
#include<cstdio>  
#include<cstdlib>  
#include<cstring>  
#include<iostream>  
#include<algorithm>  
using namespace std;  
const int N = 500010;  
#define Sets(T,a,b,c){T[a].s[c] = b; T[b].p = a;}  
#define rep(i,n) for(int i=1;i<=n;i++)  
#define For(i,l,r) for(int i=l;i<=r;i++)  
  
struct tnode{  
int s[2],v,p,num;  
}T1[N<<1],T2[N<<1];  
  
int kth,val,A[N],Last[N],MSG=2147483647,n,m;  
int cnt,root1,root2,tot1,tot2,y,z;  
  
int read(){  
int num = 0; char ch = getchar();  
int q = 0;  
while(ch<'0'||ch>'9') {  
if(ch=='-') q = 1;  
ch = getchar();  
}  
while(ch>='0'&&ch<='9'){  
num = num * 10 + ch-'0';  
ch = getchar();  
}  
 return (q==1)?(-num):num;  
 }  
   
 void Rot(tnode T[],int x){  
 //cnt++;  
int y = T[x].p , z = T[y].p;  
 int lx = T[y].s[1] == x , ly = T[z].s[1] == y;  
 Sets(T,y,T[x].s[!lx],lx);  
 Sets(T,z,x,ly);  
 Sets(T,x,y,lx^1);  
 }  
   
 void Splay(tnode T[],int i,int goal,int &root){  
 while(T[i].p!=goal){  
 if(T[T[i].p].p!=goal) Rot(T,T[i].p);  
 Rot(T,i);  
 }  
 if(!goal) root = i;  
 }  
   
 void Insert_1(int V,int i){  
 if(!i){  
 root1 = ++tot1;T1[root1].num = 1;T1[root1].p = 0;T1[root1].v = V;  
 return;  
 }  
 MSG = min(MSG,abs(V-T1[i].v));  
 if(T1[i].v==V)   T1[i].num++;  
 else{  
 if(!T1[i].s[V>T1[i].v]){  
 T1[i].s[V>T1[i].v] = ++tot1;T1[tot1].p = i;T1[tot1].v = V; T1[tot1].num = 1;  
 Splay(T1,tot1,0,root1);  
 }  
 else Insert_1(V,T1[i].s[V>T1[i].v]);  
 }  
 }  
   
 void Insert_2(int V,int i){  
 if(!i){  
 root2 = ++tot2;T2[root2].num = 1;T2[root2].p = 0;T2[root2].v = V;  
 return;  
 }  
 if(T2[i].v==V)   T2[i].num++;  
 else{  
 if(!T2[i].s[V>T2[i].v]){  
 T2[i].s[V>T2[i].v] = ++tot2;T2[tot2].p = i;T2[tot2].v = V; T2[tot2].num = 1;  
 Splay(T2,tot2,0,root2);  
 }  
 else Insert_2(V,T2[i].s[V>T2[i].v]);  
 }  
 }  
   
 int prev(int i){  
 int Next = T2[i].s[0];  
 while(T2[Next].s[1]) Next = T2[Next].s[1];  
 return Next;  
 }  
   
 void Delete(int i){  
 if(T2[i].num>1) {  
 T2[i].num--;  
 return;  
 }  
 Splay(T2,i,0,root2);  
 if(T2[i].s[0]){  
 Splay(T2,prev(i),i,root2);  
 Sets(T2,T2[i].s[0],T2[i].s[1],1);  
 T2[T2[i].s[0]].p = 0;  
root2 = T2[i].s[0];  
}else{  
if(T2[i].s[1]){root2 = T2[i].s[1];T2[T2[i].s[1]].p = 0;}  
else           root2 = 0;  
}  
T2[i].num = T2[i].p = T2[i].s[0] = T2[i].s[1] = T2[i].v = 0;  
}  
  
int Min(int root2){  
int Next = T2[root2].s[0];  
if(!Next) return T2[root2].v;  
while(T2[Next].s[0]) Next =T2[Next].s[0];  
return T2[Next].v;  
}  
  
int find(int V,int i){  
if(V==T2[i].v) return i;  
else           return find(V,T2[i].s[V>T2[i].v]);  
}  
  
void Build1(int l,int r,int &i,int p){  
if(l>r) return;  
int m = (l+r) >> 1;  
T1[i=++tot1].p = p; T1[i].v = A[m]; T1[i].num++;  
Build1(l,m-1,T1[i].s[0],i);  
Build1(m+1,r,T1[i].s[1],i);  
}  
  
void Build2(int l,int r,int &i,int p){  
if(l>r) return;  
int m = (l+r) >> 1;  
T2[i=++tot2].p = p; T2[i].v = Last[m];T2[i].num++;  
Build2(l,m-1,T2[i].s[0],i);  
Build2(m+1,r,T2[i].s[1],i);  
}  
  
int main(){  
n = read(); m = read();  
rep(i,n){  
A[i] = read();  
if(i>1) Last[i-1] = abs(A[i] - A[i-1]);  
}  
sort(Last+1,Last+n);  
Build2(1,n-1,root2,0);  
rep(i,n) Last[i] = A[i];  
sort(A+1,A+n+1);For(i,1,n-1) MSG=min(MSG,abs(A[i]-A[i+1]));  
Build1(1,n,root1,0);  
rep(i,n) A[i] = Last[i];   
char op[20];int troot;  
rep(i,m){  
scanf("%s",&op);  
if(op[0]=='I'){  
kth = read() , val = read();  
if(kth<n) {  
troot = find(abs(Last[kth]-A[kth+1]),root2);  
Delete(troot);  
}  
Insert_2(abs(val-Last[kth]),root2);  
if(kth<n) Insert_2(abs(val-A[kth+1]),root2);  
Insert_1(val,root1);  
Last[kth] = val;  
continue;  
}  
if(op[4]=='S') printf("%d\n",MSG);  
if(op[4]=='G') printf("%d\n",Min(root2));  
}  
//printf("%d\n",cnt);  
return 0;  
}

```

---

## 作者：弦巻こころ (赞：0)

## 弱智错误调了3h,我菜死了 /kk

由于这是道平衡树练习题,所以我就不用stl了 ~~(其实我也不会)~~

首先看到题,题意大致为,维护一个序列,支持:**插入,查询相邻元素差的绝对值的最小值,查询所有元素差的最小值**

因为我没什么脑子,也想不到什么其他的,就只能想到,用一颗平衡树维护相邻元素差的绝对值的最小值,用另一颗平衡树维护所有元素差的最小值.

首先对于第二个,显然是比较好处理的,只要在每次插入时求下前驱后继,然后求差,最后对ans取min即可

对于第一个,也不是很麻烦,我们写个带删除的平衡树就可以了,每次插入时,将**被断掉的那个差值**删掉(也就是删掉**abs(a[x+1]-a[to[x]]**),再插入**前面和后面与自己的差值(abs(a[to[x]]-y与abs(a[x+1]-y))** 


因为是插在x+1前面,所以不是跟x取差而是跟x+1取差

思路不难,就是实现起来有点麻烦,具体可以看注释.

另外这份代码跑最后一个点用了2.1s,~~常数好大,希望能被叉掉~~,如果我的splay有什么能让常数变小的地方,请私信我,thks.


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1304005;
int tot[2],ans=1e9,rt[2],n,m,a[N],cnt;
int num[N][2],son[N][2][2],sz[N][2],rec[N][2],fa[N][2],to[N];
//a是编号值,to是上一次操作编号,其他是平衡树常用数组,就不说了
//ty为0代表所有元素差,1则代表相邻的元素差
void clear(int x,int ty){//清空
    num[x][ty]=rec[x][ty]=fa[x][ty]=sz[x][ty]=son[x][1][ty]=son[x][0][ty]=0;
}
int get(int x,int ty){//获取自己在哪里
    return son[fa[x][ty]][1][ty]==x;
}
void update(int x,int ty){//更新
    if(x) sz[x][ty]=rec[x][ty]+sz[son[x][0][ty]][ty]+sz[son[x][1][ty]][ty];
}
void connect(int x,int y,int z,int ty){//链接
    if(x) fa[x][ty]=y; if(y) son[y][z][ty]=x;
}
void rotate(int x,int ty){//上旋
    int f=fa[x][ty],gf=fa[f][ty],fs=get(x,ty),gs=get(f,ty);
    connect(son[x][fs^1][ty],f,fs,ty);
    connect(f,x,fs^1,ty);connect(x,gf,gs,ty);
    update(f,ty);update(x,ty);
}
void splay(int x,int ty){//splay操作
    for(int f;f=fa[x][ty];rotate(x,ty))
        if(fa[f][ty]) rotate(get(x,ty)==get(f,ty)?f:x,ty);     
    rt[ty]=x;
}
//前面全是splay部分

int find(int x,int ty,int op){
//这里,我偷懒将求前驱后继和求最左边的儿子写在了一起,建议分开写,我就出锅了,还调了3h /kk
    int now=son[rt[ty]][x^1][ty];
    while(son[now][x^op][ty]) now=son[now][x^op][ty];//op为1代表求最左边的儿子
    if(op&&!now) return rt[ty]; 
    return now;
}
void check(int x,int ty){
    if(!ty&&ans){//更新所有元素差值最小值
        int pr=find(1,0,0),nt=find(0,0,0);
        ans=min(abs(x-num[pr][0]),min(abs(num[nt][0]-x),ans));
    }   
}
void insert(int x,int ty){//插入操作
    if(!rt[ty]){
        num[++tot[ty]][ty]=x;
        sz[tot[ty]][ty]=rec[tot[ty]][ty]=1;
        rt[ty]=tot[ty];return;
    }
    int now=rt[ty],f=0;
    while(1){
        if(num[now][ty]==x){
            sz[now][ty]++;rec[now][ty]++;
            update(f,ty);splay(now,ty);
            if(!ty)ans=0;//如果有相同的值ans直接变0
            return;
        }
        f=now; now=son[f][x>num[f][ty]][ty];
        if(!now){
            num[++tot[ty]][ty]=x;
            sz[tot[ty]][ty]=rec[tot[ty]][ty]=1;
            son[f][x>num[f][ty]][ty]=tot[ty];
            fa[tot[ty]][ty]=f;update(f,ty);
            splay(tot[ty],ty);check(x,ty);//更新ans
            return ;
        }
    }
}
void findd(int x){//查询当前x的位置并旋到根
    int now=rt[1];
    while(num[now][1]!=x&&now) {
        now=num[now][1]>x?son[now][0][1]:son[now][1][1];
    }
    if(!now) exit(0);
    splay(now,1);
}
void del(int x){//删除操作看个人写法,基本上都不太一样
    findd(x);
    int now=rt[1];
    if(rec[now][1]>1){//如果还有不止一个就直接减
        rec[now][1]-=1;sz[now][1]-=1;
        return;
    }
    if(!son[now][1][1]&&!son[now][0][1]){//如果都删光了就rt置0
        clear(now,1);rt[1]=0;return;
    }
    if(!son[now][0][1]){//没有左儿子就将右儿子提到根
        fa[rt[1]=son[now][1][1]][1]=0;
        clear(now,1);return;
    }
    if(!son[now][1][1]){//和上面相同
        fa[rt[1]=son[now][0][1]][1]=0;
        clear(now,1);return;
    }
//如果两个儿子都有,就将前驱提到根,再把右儿子连到前驱然后直接删掉自己
    int nxt=find(1,1,0);rt[1]=nxt;splay(nxt,1);
    connect(son[now][1][1],nxt,1,1); clear(now,1);  
}
void ins(int x,int y){//删掉被挡住的加入新的两个差值
    if(ans)insert(y,0);
    int now=abs(a[x+1]-a[to[x]]);
    if(x!=n)del(now);
    now=abs(a[to[x]]-y);insert(now,1);
    if(x!=n)now= abs(a[x+1]-y),insert(now,1);
    //注意当x=n时,不会删除,也只会加一个差值
    to[x]=++cnt,a[cnt]=y;
}
int main(){
    scanf("%d%d",&n,&m);
    insert(-1e9,0);insert(1e9,0);//加上+-inf防止前驱后驱出锅
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
        if(i!=1) insert(abs(a[i]-a[i-1]),1);
        if(ans)insert(a[i],0);to[i]=i;
    }char c[20];cnt=n;
    for(int i=1,x,y;i<=m;i++){
        scanf("%s",c);
        if(c[4]=='G') printf("%d\n",num[find(1,1,1)][1]);
        if(c[4]=='S') printf("%d\n",ans);
        if(c[4]=='R'){
            scanf("%d%d",&x,&y);
            ins(x,y);
        }
    }
}
```

~~代码大概算平衡树里比较短的了~~

---

## 作者：caeious (赞：0)

这里提供一种lazy堆+set的写法  
速度不算快(最大点1700ms)因为堆也用的STL, 但代码不到2KB.
## 因为没有模板所以在这里讲讲lazy堆是什么
**lazy堆**是一种支持插入一个数，查询并弹出最值，删除一个数的数据结构，可以利用两个堆来实现。记这两个堆分别为$a$, $b$, 在插入时向$a$中push，删除改为向$b$中push。等到查询最值时，若发现$a$的最值与$b$的最值相等，说明$a$中的这个值是**被删除过却没有pop掉的（lazy思想所在!）**，从而执行$a.pop(), b.pop()$即可，否则这个最值并没有被删除，返回即可。
#### 查询min的示例
![](https://cdn.luogu.com.cn/upload/pic/59972.png)
#### 用途
multiset也可以实现这些功能，但常数大于lazy堆（就像明明有set为什么要用堆一样)。
## Min Gap的维护
建一个lazy堆维护相邻两数gap的集合，一开始将相邻两数差的绝对值插入。  
记原数列第i个数及在此数后插入的数共有$n_i$个，依次为$a_{i,1},a_{i,2},\cdots,a_{i,n_i}$。执行$insert(i,k)$时，数列由$\cdots a_{i,n_i},a_{i + 1,1}\cdots $变为$\cdots a_{i,n_i},k,a_{i + 1,1}\cdots $，所以删除$|a_{i,n_i} - a_{i + 1,1}|$，插入$|a_{i,n_i} - k|$和$|k - a_{i + 1,1}|$即可。（在$i=n$时，$|a_{i,n_i} - a_{i + 1,1}|$和$|k - a_{i + 1,1}|$两项不需要插入/删除）
## Min Sort Gap的维护
注意到这个值单调不增，所以用set维护这些数，每次新插入一个数$x$时，找到$y$ = set中小于x的最大的数(lower bound - 1), $z$ = set中大于等于$x$的最小的数(lower bound)，用$x - y$, $z - x$更新答案即可。

这里有个trick，在初始化时向set里插入-inf，inf两数，这样找y,z时就不会越界了。  
## Code
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <queue>
#include <utility>
#include <cassert>
#include <set>
#define maxn 500005
using namespace std;
typedef long long ll;
const int inf = 0x3f3f3f3f;
inline int getint(){
  char c; int res = 0, sig = 1;
  for(c = getchar();c < '0' || c > '9';c = getchar()) if(c == '-') sig = -1;
  for(;c >= '0' && c <= '9';c = getchar()) res = res * 10 + (c - '0');
  return res * sig;
}
int n,m;
int fir[maxn],ed[maxn];
struct Heap{
  priority_queue <int,vector <int>,greater<int> > que,lazy;
  void push(int x){
    que.push(x);
  }
  int top(){
    while(que.top() == lazy.top()) que.pop(), lazy.pop();
    return que.top();
  }
  void erase(int x){
    lazy.push(x);
  }
}hp;
set <int> st;
typedef set <int> :: iterator Ite;
char fl[15];
int sortgap = inf;
int main(){
  n = getint(), m = getint();
  st.insert(-inf);
  st.insert(inf);
  for(int i = 1;i <= n;i++){
    fir[i] = ed[i] = getint();
    if(i > 1) hp.push(abs(fir[i] - fir[i - 1]));
    Ite it = st.lower_bound(fir[i]);
    sortgap = min(sortgap,*it - fir[i]);
    sortgap = min(sortgap,fir[i] - *(--it));
    st.insert(fir[i]);
  }
  while(m--){
    scanf("%s",fl);
    if(fl[0] == 'I'){
      int pos = getint(), val = getint();
      if(pos < n) hp.erase(abs(fir[pos + 1] - ed[pos]));
      hp.push(abs(val - ed[pos]));
      if(pos < n) hp.push(abs(val - fir[pos + 1]));
      Ite it = st.lower_bound(val);
      sortgap = min(sortgap,*it - val);
      sortgap = min(sortgap,val - *(--it));
      st.insert(val);
      ed[pos] = val;
    }else if(fl[4] == 'G'){
      printf("%d\n",hp.top());
    }else if(fl[4] == 'S'){
      printf("%d\n",sortgap);
    }
  }
  return 0;
}
```


---

## 作者：qwaszx (赞：0)

~~舒老师说这题事大水题然而我对拍给他拍出来一堆错~~

操作一在某个位置后面插入.拿个链表维护就好了.

操作二需要支持查询最小的相邻位置差，那么拿堆维护，插入的时候删掉原来的再加上新的.

关于删除，我看有很多人是开了两个堆来进行删除的.然而我们其实可以手写这一操作.记录每个位置在堆中的编号就好了.见代码.

操作三拿平衡树维护一个前驱后继就好了.

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#define inf 1000000007
using namespace std;
const int N=2e6;
struct Node{int ch[2],w,rnd,cnt;}a[N];
struct Q{int id,w;bool operator <(const Q &a)const{return w<a.w;}};
int n,m,w[N],lst[N],fst[N],node_cnt,root;
char st[100];
int abs1(int x){return x>0?x:-x;}
void rotate(int &u,int f)
{
	int v=a[u].ch[f^1];
	a[u].ch[f^1]=a[v].ch[f],a[v].ch[f]=u;
	u=v;
}
void ins(int &root,int w)//Treap
{
	if(!root)
	{
		root=++node_cnt;Node *z=a+root;
		z->w=w,z->rnd=rand()<<15|rand();
		z->ch[0]=z->ch[1]=0;z->cnt=1;return;
	}
	if(w==a[root].w){return;}
	int d=w>a[root].w;
	ins(a[root].ch[d],w);
	if(a[a[root].ch[d]].rnd<a[root].rnd)rotate(root,d^1);
}
int prep(int w)
{
	int o=root,lst=-inf;
	while(o)
	{
		if(w>=a[o].w)lst=a[o].w,o=a[o].ch[1];
		else o=a[o].ch[0];
	}
	return lst;
}
int succ(int w)
{
	int o=root,lst=inf;
	while(o)
	{
		if(w<=a[o].w)lst=a[o].w,o=a[o].ch[0];
		else o=a[o].ch[1];
	}
	return lst;
}
struct Heap
{
	int id[N],size;
	Q a[N];
	void push(Q x)
	{
		a[++size]=x;int o;
		for(o=size;o>1;o>>=1)
			if(a[o]<a[o>>1])id[a[o>>1].id]=o,swap(a[o],a[o>>1]);
			else{id[x.id]=o;return;}//删除就体现在id这个数组上.维护每个位置对应的堆中编号
		if(o==1)id[x.id]=1;
	}
	void pop(int pos)//只要找到堆中位置就可以删除任意节点啦
	{
		pos=id[pos];a[pos]=a[size--];
		for(int o=pos,son;(o<<1|1)<=size;o=son)
		{
			son=(o<<1|1)>size||a[o<<1]<a[o<<1|1]?(o<<1):(o<<1|1);
			if(a[son]<a[o])id[a[son].id]=o,swap(a[o],a[son]);
			else{id[a[o].id]=o;return;}
		}
	}
	Q top(){return a[1];}
}q;
int main()
{
	scanf("%d%d",&n,&m);int ans2=inf;
	for(int i=1;i<=n;i++)
	{
		scanf("%d",w+i);
		if(i!=1){q.push((Q){i,abs1(w[i]-w[i-1])});ans2=min(ans2,min(w[i]-prep(w[i]),succ(w[i])-w[i]));}
		ins(root,w[i]);lst[i]=i-1;
	}
	lst[n+1]=n;
	for(int i=2;i<=m+1;i++)
	{
		scanf("%s",st+1);
		if(st[1]=='I')
		{
			int x;
			scanf("%d%d",&x,w+i+n);if(x!=n)q.pop(x+1);
			lst[i+n]=lst[x+1],lst[x+1]=i+n;
			if(x!=n)q.push((Q){x+1,abs1(w[x+1]-w[i+n])});
			q.push((Q){i+n,abs1(w[i+n]-w[lst[i+n]])});
			ans2=min(ans2,min(w[i+n]-prep(w[i+n]),succ(w[i+n])-w[i+n]));ins(root,w[i+n]);//前驱后继各拿出来比一下.
		}
		else
			if(st[5]=='G')
			{
				Q t=q.top();printf("%d\n",t.w);
			}
			else printf("%d\n",ans2);
	}
}
```

---

## 作者：程就未来 (赞：0)

这道题我用了2棵平衡树做的。
### INSERT操作
把插入的数加到链表里面，用数组模拟链表，在加进去的时候，我们需要更新MIN_GAP的值。MIN_GAP的值用平衡树维护。
先删除插入位置两边的数，再在平衡树中插入新加的数与左右两边数的差。
```cpp
struct Link{//数组模拟链表
	int head[N]  , nxt[N] , tot , val[N];
	void init (){//预处理
		tot = n;
		memset(head , 0 , sizeof(head));
		for(register int i = 1 ; i <= n ; i ++) {
			head[i] = i; val[i] = a[i];
			if(i > 1) T4.insert(abs(a[i] - a[i - 1]));
		} 
	}
	inline void insert(int x , int y) { 
		int pre = val[head[x]];
		nxt[++tot] = head[x];
		val[tot] = y;
		head[x] = tot;
		if(x != n) T4.Remove(abs(pre - val[x + 1]));
		T4.insert(abs(pre - y));
		if(x != n) T4.insert(abs(y - val[x + 1]));
	}
} lk;
```

### MIN_GAP操作
如何修改上文已经提到，答案就是这棵平衡树中的最小值。
平衡树我用fhq_treap实现的，因为方便写。
```cpp
struct fhq_treap2 {
	int ch[N][2] , size[N] , val[N] , key[N] , tot , root;
	inline void pushup(int rt) {size[rt] = size[ch[rt][0]] + size[ch[rt][1]] + 1;}
	int New(int x) {//一些fhq_treap的基本操作
	    val[++tot] = x; size[tot] = 1;
	    key[tot] = rand();
	    ch[tot][0] = ch[tot][1] = 0;
	    return tot;
	}
	inline void split(int rt , int x , int &a , int &b) {
	    if(!rt) {a = b = 0;return;}
	    if(val[rt] <= x) a = rt , split(ch[rt][1] , x , ch[rt][1] , b);
	    else b = rt , split(ch[rt][0] , x , a , ch[rt][0]);
	    pushup(rt);
	}
	inline int merge(int a , int b) {
	    if(!a || !b) return a + b;
	    if(key[a] < key[b]) {
	        ch[a][1] = merge(ch[a][1] , b); 
	        pushup(a); return a;
	    } else {
	        ch[b][0] = merge(a , ch[b][0]);
	        pushup(b); return b;
	    }
	}
	inline int Min() {//取最小值
		int rt = root;
		while(ch[rt][0]) rt = ch[rt][0];
		return val[rt];
	}	
	inline void insert(int v) {
		int x = 0 , y = 0;
		split(root , v , x , y);
		root = merge(merge(x , New(v)) , y);
	}	
	inline void Remove(int v) {
	    int x = 0 , y = 0 , z = 0;
	    split(root , v , x , z);
	    split(x , v - 1 , x , y);
	    y = merge(ch[y][0] , ch[y][1]);
	    root = merge(merge(x , y) , z);
	}
}T4;

```
### MIN_SORT_GAP操作
再用一棵平衡树维护，按权值排序。

pre 是插入的数的前驱

nxt 是插入的数的后继

val 是插入的数

每次插入时在原来的答案，val-pre , nxt - val中取最小值即可
```cpp
struct fhq_treap {
	int ch[N][2] , size[N] , val[N] , key[N] , tot , root , msgap;
	inline void pushup(int rt) {size[rt] = size[ch[rt][0]] + size[ch[rt][1]] + 1;}
	inline int New(int x) {
	    val[++tot] = x; size[tot] = 1;
	    key[tot] = rand();
	    ch[tot][0] = ch[tot][1] = 0;
	    return tot;
	}
	inline void split(int rt , int x , int &a , int &b) {
	    if(!rt) {a = b = 0;return;}
	    if(val[rt] <= x) a = rt , split(ch[rt][1] , x , ch[rt][1] , b);
	    else b = rt , split(ch[rt][0] , x , a , ch[rt][0]);
	    pushup(rt);
	}
	inline int merge(int a , int b) {
	    if(!a || !b) return a + b;
	    if(key[a] < key[b]) {
	        ch[a][1] = merge(ch[a][1] , b); 
	        pushup(a); return a;
	    } else {
	        ch[b][0] = merge(a , ch[b][0]);
	        pushup(b); return b;
	    }
	}
	inline int kth(int rt , int x) {
	    while(1) {
	        if(x <= size[ch[rt][0]]) rt = ch[rt][0];
	        else if(x > size[ch[rt][0]] + 1) {
	            x = x - size[ch[rt][0]] - 1;
	            rt = ch[rt][1];
	        } else return rt;
	    } 
	}
    inline int find(int x) {
    	int rt = root;
    	while(val[rt] != x && ch[rt][x > val[rt]]) rt = ch[rt][x > val[rt]];
    	return val[rt];
	}
    inline int prev(int v) {
	    int x = 0 , y = 0;
	    split(root , v - 1 , x , y);
	    int ans = kth(x , size[x]);
	    root = merge(x , y);
	    return ans;
	}
	inline int succ(int v) {
	    int x = 0 , y = 0;
	    split(root , v , x , y);
	    int ans = kth(y , 1);
	    root = merge(x , y);
	    return ans;
	}
	inline void insert(int v) {
		if(v != INF && v != -INF && msgap != 0) {//剪枝，如果当前答案已经为0，就不必更新了。
			if(find(v) == v) msgap = 0;
			else {
				int pre = val[prev(v)] , nxt = val[succ(v)];
				msgap = min(msgap , min(abs(v - pre) , abs(v - nxt)));
			} 
		}
		int x = 0 , y = 0;
		split(root , v , x , y);
		root = merge(merge(x , New(v)) , y);
	}	
	void init() {
		msgap = INF; root = 0;
		sort(a + 1 , a + n + 1);
		insert(INF) , insert(-INF);
		for(int i = 1 ; i <= n ; i ++) insert(a[i]);
	}
}T3;
```
我的代码常数较大，要卡常才能过。
### code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e6 + 9 , INF = 1e9;

int n , m , a[N];

struct fhq_treap2 {
	int ch[N][2] , size[N] , val[N] , key[N] , tot , root;
	inline void pushup(int rt) {size[rt] = size[ch[rt][0]] + size[ch[rt][1]] + 1;}
	int New(int x) {
	    val[++tot] = x; size[tot] = 1;
	    key[tot] = rand();
	    ch[tot][0] = ch[tot][1] = 0;
	    return tot;
	}
	inline void split(int rt , int x , int &a , int &b) {
	    if(!rt) {a = b = 0;return;}
	    if(val[rt] <= x) a = rt , split(ch[rt][1] , x , ch[rt][1] , b);
	    else b = rt , split(ch[rt][0] , x , a , ch[rt][0]);
	    pushup(rt);
	}
	inline int merge(int a , int b) {
	    if(!a || !b) return a + b;
	    if(key[a] < key[b]) {
	        ch[a][1] = merge(ch[a][1] , b); 
	        pushup(a); return a;
	    } else {
	        ch[b][0] = merge(a , ch[b][0]);
	        pushup(b); return b;
	    }
	}
	inline int Min() {
		int rt = root;
		while(ch[rt][0]) rt = ch[rt][0];
		return val[rt];
	}	
	inline void insert(int v) {
		int x = 0 , y = 0;
		split(root , v , x , y);
		root = merge(merge(x , New(v)) , y);
	}	
	inline void Remove(int v) {
	    int x = 0 , y = 0 , z = 0;
	    split(root , v , x , z);
	    split(x , v - 1 , x , y);
	    y = merge(ch[y][0] , ch[y][1]);
	    root = merge(merge(x , y) , z);
	}
}T4;

struct Link{
	int head[N]  , nxt[N] , tot , val[N];
	void init (){
		tot = n;
		memset(head , 0 , sizeof(head));
		for(register int i = 1 ; i <= n ; i ++) {
			head[i] = i; val[i] = a[i];
			if(i > 1) T4.insert(abs(a[i] - a[i - 1]));
		} 
	}
	inline void insert(int x , int y) {
		int pre = val[head[x]];
		nxt[++tot] = head[x];
		val[tot] = y;
		head[x] = tot;
		if(x != n) T4.Remove(abs(pre - val[x + 1]));
		T4.insert(abs(pre - y));
		if(x != n) T4.insert(abs(y - val[x + 1]));
	}
} lk;

struct fhq_treap {
	int ch[N][2] , size[N] , val[N] , key[N] , tot , root , msgap;
	inline void pushup(int rt) {size[rt] = size[ch[rt][0]] + size[ch[rt][1]] + 1;}
	inline int New(int x) {
	    val[++tot] = x; size[tot] = 1;
	    key[tot] = rand();
	    ch[tot][0] = ch[tot][1] = 0;
	    return tot;
	}
	inline void split(int rt , int x , int &a , int &b) {
	    if(!rt) {a = b = 0;return;}
	    if(val[rt] <= x) a = rt , split(ch[rt][1] , x , ch[rt][1] , b);
	    else b = rt , split(ch[rt][0] , x , a , ch[rt][0]);
	    pushup(rt);
	}
	inline int merge(int a , int b) {
	    if(!a || !b) return a + b;
	    if(key[a] < key[b]) {
	        ch[a][1] = merge(ch[a][1] , b); 
	        pushup(a); return a;
	    } else {
	        ch[b][0] = merge(a , ch[b][0]);
	        pushup(b); return b;
	    }
	}
	inline int kth(int rt , int x) {
	    while(1) {
	        if(x <= size[ch[rt][0]]) rt = ch[rt][0];
	        else if(x > size[ch[rt][0]] + 1) {
	            x = x - size[ch[rt][0]] - 1;
	            rt = ch[rt][1];
	        } else return rt;
	    } 
	}
    inline int find(int x) {
    	int rt = root;
    	while(val[rt] != x && ch[rt][x > val[rt]]) rt = ch[rt][x > val[rt]];
    	return val[rt];
	}
    inline int prev(int v) {
	    int x = 0 , y = 0;
	    split(root , v - 1 , x , y);
	    int ans = kth(x , size[x]);
	    root = merge(x , y);
	    return ans;
	}
	inline int succ(int v) {
	    int x = 0 , y = 0;
	    split(root , v , x , y);
	    int ans = kth(y , 1);
	    root = merge(x , y);
	    return ans;
	}
	inline void insert(int v) {
		if(v != INF && v != -INF && msgap != 0) {
			if(find(v) == v) msgap = 0;
			else {
				int pre = val[prev(v)] , nxt = val[succ(v)];
				msgap = min(msgap , min(abs(v - pre) , abs(v - nxt)));
			} 
		}
		int x = 0 , y = 0;
		split(root , v , x , y);
		root = merge(merge(x , New(v)) , y);
	}	
	void init() {
		msgap = INF; root = 0;
		sort(a + 1 , a + n + 1);
		insert(INF) , insert(-INF);
		for(int i = 1 ; i <= n ; i ++) insert(a[i]);
	}
}T3;

inline int read() {
	int s = 0 , w = 1; char ch = getchar();
	while(ch < 48 || ch > 57) {if(ch == '-') w = -1; ch = getchar();}
	while(ch >= 48 && ch <= 57) s = (s << 1) + (s << 3) + (ch ^ 48) , ch = getchar();
	return s * w; 
}

inline void write(int x) {
    if(x < 0)putchar('-'), x *= (-1);
    if(x > 9)write(x / 10);
    putchar(x % 10 + '0');
}

int main() {
	srand(time(NULL));
	n = read() , m = read();	
	for(register int i = 1 ; i <= n ; ++ i) a[i] = read();
	T4.tot = T4.root = 0;
	lk.init(); 
	T3.init();
	for(register int i = m ; i >= 1 ; -- i){
		char s[20];
		scanf("%s",s);
		if(s[0] == 'I') {
			int p = read() , x = read();
			lk.insert(p , x); 
			T3.insert(x);
		} else if(s[0] == 'M' && s[4] == 'G') write(T4.Min()) , putchar('\n');
		else write(T3.msgap) , putchar('\n');
	}
	return 0;
}

```

---

## 作者：冒泡ioa (赞：0)

> [题目链接](https://www.luogu.org/problemnew/show/P1110)  
> [个人博客](http://bubbleioa.top/archives/755)

## 题解
又是一道题一晚上系列(数据结构一生之敌)

调了很久的原因其实是写错了一个变量,其实还是很简单的

这里用的平衡树是Treap

你可以把原始数列看成n个链表,首尾相连的那种,但是我们要分段存  
用vector就很舒服

然后对于第三个操作,其实只要每次进入平衡树的元素查找下前驱后继与它本身作差取最小值即可(这里的前驱后继是**非严格**的)

对于第二个操作,每次插入一个元素,总会创造两个差值关系并且减去一个差值关系  
我们可以用两个**小根堆**分别维护产生的差值和删去的差值,每次询问时,不断弹出顶端相同元素后,第一个堆顶就是答案了

这种做法还是有点慢的(最慢1500ms,开了O2 790ms),如果当年省选不开O2的话有点悬

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=600304,INF=0x7fffffff;
int pos[MAXN];//可以不用
int minn=INF;
vector<int>b[MAXN];

struct delhp{
    priority_queue<int>q1,q2;
    void insert(int kind,int x){
        if(kind==1)q1.push(-x);//小根堆
        else q2.push(-x);
    }
    int top(){
        while(q1.size()&&q2.size()){
            if(q1.top()!=q2.top())return -q1.top();
            q1.pop();q2.pop();
        }
    }
}q;

struct Treap{
    int l,r;
    int val,dat;
    int cnt,size;
}a[MAXN];
int tot,root;

int read(){
    int x=0,f=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
    while(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}

void update(int p){
    a[p].size=a[a[p].l].size+a[a[p].r].size+a[p].cnt;
}

int New(int x){
    a[++tot].val=x;
    a[tot].dat=rand();
    a[tot].size=a[tot].cnt=1;
    return tot;
}

void build(){
    New(-INF);New(INF);
    a[1].r=2;
    root=1;
    update(root);
}

void zig(int &p){
    int q=a[p].l;
    a[p].l=a[q].r;a[q].r=p;p=q;
    update(a[p].r);update(p);
}

void zag(int &p){
    int q=a[p].r;
    a[p].r=a[q].l;a[q].l=p;p=q;
    update(a[p].l);update(p);
}

void insert(int &p,int val){
    if(p==0){
        p=New(val);
        return;
    }
    if(val==a[p].val){
        a[p].cnt++;
        update(p);
        return;
    }
    if(val<a[p].val){
        insert(a[p].l,val);
        if(a[a[p].l].dat>a[p].dat)zig(p);
    }
    else {
        insert(a[p].r,val);
        if(a[a[p].r].dat>a[p].dat)zag(p);
    }
    update(p);
}

int GetPre(int val){
    int ans=1;
    int p=root;
    while(p){
        if(val==a[p].val){
            if(a[p].cnt>1)return a[p].val;
            else if(a[p].l>0){
                p=a[p].l;
                while(a[p].r>0)p=a[p].r;
                ans=p;
            }
            break;
        }
        if(a[p].val<val&&a[p].val>a[ans].val)ans=p;
        p=val<a[p].val?a[p].l:a[p].r;
    }
    return a[ans].val;
}

int GetNext(int val){
    int ans=2;
    int p=root;
    while(p){
        if(val==a[p].val){
            if(a[p].cnt>1)return a[p].val;
            else if(a[p].r>0){
                p=a[p].r;
                while(a[p].l>0)p=a[p].l;
                ans=p;
            }
            break;
        }
        if(a[p].val>val&&a[p].val<a[ans].val)ans=p;
        p=val<a[p].val?a[p].l:a[p].r;
    }
    return a[ans].val;
}

int main(){
    int n=read(),m=read();
    build();
    for(int i=1;i<=n;i++){
        int x=read();
        pos[i]=x;
        b[i].push_back(x);
        if(i!=1)q.insert(1,abs(pos[i]-pos[i-1]));
        if(minn!=0){//维护操作3
            insert(root,pos[i]);
            int xx=GetNext(pos[i]);
            int yy=GetPre(pos[i]);
            if(xx!=INF&&xx!=-INF)minn=min(minn,xx-pos[i]);
            if(yy!=INF&&yy!=-INF)minn=min(minn,pos[i]-yy);
        }
    }
    for(int i=1;i<=m;i++){
        char s[20];
        scanf("%s",s);
        int len=strlen(s);
        if(len==6){
            int x=read(),k=read();
            b[x].push_back(k);
            if(minn!=0)insert(root,k);
            q.insert(1,abs(k-*(b[x].end()-2)));//*号为解除引用,如果不加上则返回的是迭代器
            if(b[x+1].size()){//防止越界RE
                q.insert(1,abs(k-*(b[x+1].begin())));
                q.insert(2,abs(*(b[x].end()-2)-*(b[x+1].begin())));
            }
            if(minn!=0){
                int xx=GetNext(k);
                int yy=GetPre(k);
                if(xx!=INF&&xx!=-INF)minn=min(minn,xx-k);
                if(yy!=INF&&yy!=-INF)minn=min(minn,k-yy);
            }
        }
        else if(len==7){
            printf("%d\n",q.top());
        }
        else {
            printf("%d\n",minn);
        }
    }
    return 0;
}
```

---

## 作者：Smokey_Days (赞：0)

```cpp
#include<iostream>
#include<cstdio>
#include<set>
#define LS (X<<1)
#define RS (X<<1|1)
#define MID ((L+R)>>1)
/*
lp1110 ZJOI2007 报表统计
事实上对于第一类询问和第二类询问我们可以分别处理。
第二类询问的处理方法是非常显然的。由于只有插入而没有删除操作，因此，第二类询问的答案只会缩小、不会增大。
故而，我们对整个数列的值维护一个Splay，每一次插入一个新的数以后，用它和它的前驱与它和它的后继的差的绝对值来更新第二类的答案。
这可以用multiset来简易地实现。
对于第一类询问，我们发现，维护这个值其实并不是难点——用线段树或者平衡树都可以轻松实现。问题在于，如何在插入新的数之后保持这个值。
我们仔细思考，发现，对于任意一段区间来说，它对答案的贡献只有三个：这个区间的答案，这个区间的左端点和这个区间的右端点。
故而，我们建一棵线段树或者平衡树，维护这三个信息（个人认为线段树比较科学。）每一次修改则修改对应的节点，然后递归向上更新即可。
这样就做完了，个人觉得实现难度还是比较低的。
*/
inline int Abs(int X){
	return X>0?X:-X;
}

inline int Min(int A,int B){
	return A<B?A:B;
}

std::multiset<int> st;
int ansS=0x3f3f3f3f;
int n,m,a[500005];

class SegmentTree{
	private:
		class Node{
			public:
				int l;
				int r;
				int dlt;
			inline Node(){
				dlt=0x3f3f3f3f;
			}
			inline void init(int V){
				l=r=V;
			}
			inline void psh(int V){
				dlt=Min(dlt,Abs(r-V));
				r=V;
			}
		};
		Node tr[1100000];
		inline void updt(int X){
			tr[X].l=tr[LS].l;
			tr[X].r=tr[RS].r;
			tr[X].dlt=Min(Min(tr[LS].dlt,tr[RS].dlt),Abs(tr[LS].r-tr[RS].l));
		}
		inline void build(int L,int R,int X){
			if(L>R){
				return;
			}
			if(L==R){
				tr[X].init(a[L]);
				return;
			}
			build(L,MID,LS),build(MID+1,R,RS);
			updt(X);
		}
		inline void push(int L,int R,int X,int A,int V){
			if(L>R){
				return;
			}
			if(L==R){
				tr[X].psh(V);
				return;
			}
			A>MID?push(MID+1,R,RS,A,V):push(L,MID,LS,A,V);
			updt(X);
		}
		inline void prnt(int L,int R,int X){
			if(L>R){
				return;
			}
			if(L==R){
				printf("%d:[%d,%d,%d] ",X,tr[X].l,tr[X].r,tr[X].dlt);
				return;
			}
			prnt(L,MID,LS),prnt(MID+1,R,RS);
		}
	public:
		inline void PUSH(int X,int K){
			push(1,n,1,X,K);
		}
		inline void BUILD(){
			build(1,n,1);
		}
		inline int QUERYG(){
			return tr[1].dlt;
		}
		inline void PRINT(){
			prnt(1,n,1);
			puts("");
		}
};

inline void STPUSH(int K){
	st.insert(K);
	std::multiset<int> ::iterator it=st.find(K);
	int ans1,ans2;
	++it;
	if(it!=st.end()){
		ans1=*it;
	}else{
		ans1=0x3f3f3f3f;
	}
	--it;
	if(it!=st.begin()){
		--it;
		ans2=*it;
	}else{
		ans2=0x3f3f3f3f;
	}
	ans1=Abs(K-ans1),ans2=Abs(K-ans2);
	ansS=Min(ansS,Min(ans1,ans2));
}

SegmentTree T;
void init(){
	scanf("%d%d",&n,&m);
	int x;
	for(int i=1;i<=n;++i){
		scanf("%d",a+i);
		STPUSH(a[i]);
	}
	T.BUILD();
	char op[10];
	int k;
	for(int i=1;i<=m;++i){
		std::cin>>op;
		switch(op[4]){
			case 'R':{
				scanf("%d%d",&x,&k);
				T.PUSH(x,k);
				STPUSH(k);
				break;
			}
			case 'G':{
				printf("%d\n",T.QUERYG());
				break;
			}
			case 'S':{
				printf("%d\n",ansS);
				break;
			}
			case 'P':{
				T.PRINT();
				break;
			}
		}
	}
}

int main(){
	init();
	return 0;
}
```

---

## 作者：bztMinamoto (赞：0)

emm……楼下的代码都看不太懂……我一个刚学了点splay的菜鸡有点懵……

说实话我只会用裸的splay，于是开个struct封装一下然后建两个splay就好了

先说一下要用到的。我们用两个splay，A来存相邻两个数的差值，用B来存所有数的值。h[i]表示插入后原第i个元素的第一个值（即原来的第i个元素），用t[i]表示插入后第i个元素的结尾元素

对于INSERT操作，A删除abs（h[i+1]-t[i]）（原来结尾与下一个的差值），再插入新生成的两个差值。B直接插入，顺便找前缀和后缀更新最小值minx

对于MIN_GAP操作，我们直接查找A里最小的元素

对于MIN_SORT_GAP，我们直接输出minx即可

emm……然后O2信仰跑一跑……
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cctype>
#include<cmath>
#define rint register int
using namespace std;
template<class T>inline bool cmin(T&a,const T&b){a>b?a=b,1:0;}
const int inf=0x3f3f3f3f,N=1000050;
inline int read(){
    #define num ch-'0'
    char ch;bool flag=0;int res;
    while(!isdigit(ch=getchar()))
    (ch=='-')&&(flag=true);
    for(res=num;isdigit(ch=getchar());res=res*10+num);
    (flag)&&(res=-res);
    #undef num
    return res;
}
int h[N],t[N],minx=inf;
struct Splay{
    struct node{
        int v,father,ch[2];
        int sum,recy;
    } e[N];
    int n,root;
    void update(int x){
        e[x].sum=e[e[x].ch[0]].sum+e[e[x].ch[1]].sum+e[x].recy;
    }
    int identify(int x){
        return e[e[x].father].ch[1]==x;
    }
    void connect(int x,int f,int son){
        e[x].father=f,e[f].ch[son]=x;
    }
    void rotate(int x){
        int y=e[x].father,z=e[y].father;
        int yson=identify(x),zson=identify(y);
        int b=e[x].ch[yson^1];
        connect(b,y,yson),connect(y,x,(yson^1)),connect(x,z,zson);
        update(y),update(x);
    }
    void splay(int x,int goal){
        while(e[x].father!=goal){
            int y=e[x].father,z=e[y].father;
            if(z!=goal)
            (identify(x)^identify(y))?rotate(x):rotate(y);
            rotate(x);
        }
        if(goal==0) root=x;
    }
    void push(int v){
        int now=root,f=0;
        while(now&&e[now].v!=v){
            f=now;
            now=e[now].ch[v>e[now].v];
        }
        if(now) e[now].recy++;
        else{
            now=++n;
            if(f) e[f].ch[v>e[f].v]=now;
            e[n].ch[0]=e[n].ch[1]=0;
            e[n].father=f,e[n].v=v;
            e[n].recy=e[n].sum=1;
        }
        splay(now,0);
    }
    void find(int v){
        int now=root;
        if(!now) return;
        while(e[now].ch[v>e[now].v]&&v!=e[now].v)
        now=e[now].ch[v>e[now].v];
        splay(now,0);
    }
    int Next(int v,int f){
        find(v);
        int now=root;
        if((e[now].v>v&&f)||(e[now].v<v&&!f)) return now;
        now=e[now].ch[f];
        while(e[now].ch[f^1]) now=e[now].ch[f^1];
        return now;
    }
    int Next2(int v,int f){
        find(v);
        int now=root;
        if((e[now].v>=v&&f)||(e[now].v<=v&&!f)) return now;
        now=e[now].ch[f];
        while(e[now].ch[f^1]) now=e[now].ch[f^1];
        return now;
    }
    void pop(int v){
        int lower=Next(v,0);
        int upper=Next(v,1);
        splay(lower,0),splay(upper,lower);
        int del=e[upper].ch[0];
        if(e[del].recy>1){
            e[del].recy--;
            splay(del,0);
        }
        else e[upper].ch[0]=0;
        update(upper),update(lower);
    }
    int get(){
        int now=root,v=2;
        if(e[now].sum<v) return false;
        while(true){
            int y=e[now].ch[0];
            if(v>e[y].sum+e[now].recy){
                v-=e[y].sum+e[now].recy;
                now=e[now].ch[1];
            }
            else if(e[y].sum>=v) now=y;
            else return e[now].v;
        }
    }
    void init(){n=root=0;push(inf),push(-inf);}
}A,B;
inline void pushb(int v){
	int lower=B.Next2(v,0);
	int upper=B.Next2(v,1);
	cmin(minx,min(abs(B.e[lower].v-v),abs(B.e[upper].v-v)));
	B.push(v);
}
int n,m;
int main(){
	//freopen("testdata.in","r",stdin);
	A.init(),B.init();
	n=read(),m=read();
	for(rint i=1;i<=n;i++) h[i]=t[i]=read();
	h[n+1]=inf;
	for(rint i=2;i<=n;i++)
	A.push(abs(h[i]-h[i-1]));
	for(rint i=1;i<=n;i++)
	pushb(h[i]);
	while(m--){
		char c[20];int i,k;
		scanf("%s",c);
		if(c[0]=='I'){
			i=read(),k=read();
			A.pop(abs(h[i+1]-t[i]));
			A.push(abs(k-h[i+1])),A.push(abs(k-t[i]));
			pushb(k);
			t[i]=k;
		}
		else if(c[4]=='G') printf("%d\n",A.get());
		else printf("%d\n",minx);
	}
    for(;;);//防抄
	return 0;
}
```

---

## 作者：hongzy (赞：0)

$Treap$ $+$ $Multiset$ 卡常过的此题.

**维护$MIN\_GAP$**：$Multiset$（可重集）。对于$N$个元素，每个元素只需记录第一个（$first$）和最后一个（$last$）是谁，中间的元素对答案没有影响。

每次把整数$y$加入元素$x$的时候，首先把$abs(last(x)  - first(x+1))$删除，因为它们不相邻了。再把$abs(y -last(x))$、$abs(y-first(x+1))$丢进$Multiset$.删除操作直接$find+erase$，不需要二分.

**维护$MIN\_SORT\_GAP$**：$Treap$.每加入一个新元素，找一下前驱和后继更新答案，然后丢进去.

**卡常**：可以用$fread$手写$getchar$，再手写读入.

**核心代码**：

```cpp
int v[500010][2], sz[500010]; //v记录首末位，sz记录是否元素>1 
int N, M, msg(2e9 + 10);

multiset<int> t2;

void update_msg(int x) {      //找前驱后继更新MIN_SORT_GAP 
	msg = min(msg, min(x - pre(root, x), after(root, x) - x));
}

int main() {
	N = read(), M = read();
	for(int i=1, x; i<=N; i++) {
		x = v[i][0] = read();
		update_msg(x), insert(root, x);          //把x丢进Treap 
		if(i > 1) t2.insert(abs(x - v[i-1][0])); //把相邻之差丢进 Multiset
	}
	char buf[21];
	for(int i=1, x, y; i<=M; i++) {
		read_s(buf);
		if(buf[4] == 'R') {
			x = read(), y = read();
			if(x < N) t2.erase(t2.find(abs(v[x+1][0] - v[x][sz[x]])));
			t2.insert(abs(y - v[x][sz[x]]));
			if(x < N) t2.insert(abs(y - v[x+1][0]));  //一个删除两个插入 
			v[x][sz[x] ? 1 : (sz[x] = 1)] = y;        //尾部加入元素 
			update_msg(y), insert(root, y);           //把y丢进Treap 
		} else if(buf[4] == 'G') write(*(t2.begin())); //直接输出 multiset最小元素 
		else write(msg);                               //直接输出MIN_SORT_GAP 
	}
	return 0;
}
```

---

## 作者：I_AM_HelloWord (赞：0)

很容易就可以看出是平衡树操作的裸题，

设en[x]表示第x元素的链的末端的数字是多少。

nxt[x]表示第x元素的链的末端的后面一个数字，即x[i+1]

弄个前驱和后继就可以解决第3个问题，第二个问题只需插入abs(en[x]-new),abs(nxt[x]-new)然后注意删除abs(en[x]-nxt[x])。

但是就弄俩平衡树会被卡掉3个点，我写的SBT都过不了，不知道为什么。

所以我们第二个问题考虑换个数据结构维护。

用堆吧，二叉堆就行了，不需要左偏树。在我们需要的堆中插入abs(en[x]-new),abs(nxt[x]-new)，然后再另一个堆中插入我们需要删除的abs(en[x]-nxt[x])，如果两个堆顶相等，就都弹掉，理论复杂度没有变，事实上我觉得常数还变大了，不知道为什么就0.5s就过了。


参考代码：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int INF=0x3f3f3f3f;
const int N=3*500010;
int n,m,x[N],nxt[N],en[N];
struct SBT{
    int root,NodeCnt;
    int key[N],left[N],right[N],s[N];
    void clear(){
        root=NodeCnt=0;
        memset(key,0,sizeof(key));
        memset(left,0,sizeof(left));
        memset(right,0,sizeof(right));
        memset(s,0,sizeof(s));
    }
    void zag(int &t){
        int p=right[t];
        right[t]=left[p];
        left[p]=t;
        s[p]=s[t];
        s[t]=s[left[t]]+s[right[t]]+1;
        t=p;
    }
    void zig(int &t){
        int p=left[t];
        left[t]=right[p];
        right[p]=t;
        s[p]=s[t];
        s[t]=s[left[t]]+s[right[t]]+1;
        t=p;
    }
    void maintain(int &t,bool flag){
        if (!flag){
            if (s[left[left[t]]]>s[right[t]])zig(t);
            else{
                if (s[right[left[t]]]>s[right[t]]){
                    zag(left[t]);zig(t);
                }else return;
            }
        }else{
            if (s[right[right[t]]]>s[left[t]])zag(t);
            else{
                if (s[left[right[t]]]>s[left[t]]){
                    zig(right[t]);zag(t);
                }else return;
            }
        }
        maintain(left[t],false);
        maintain(right[t],true);
        maintain(t,false);
        maintain(t,true);
    }
    void insert(int &t,int x){
        if (!t){key[t=++NodeCnt]=x;s[t]=1;return;}
        s[t]++;
        if (x<key[t])insert(left[t],x);
            else insert(right[t],x);
        maintain(t,x>=key[t]);
    }
    int erase(int &p,int x){
        s[p]--;int tmp;
        if (x==key[p] || (x<key[p] && !left[p]) || (x>key[p] && !right[p])){
            tmp=key[p];
            if (!left[p] || !right[p])p=left[p]+right[p];
            else key[p]=erase(left[p],key[p]+1);
            return tmp;
        }
        if (x<key[p])tmp=erase(left[p],x);else tmp=erase(right[p],x);
        return tmp;
    }
    int pred(int &t,int x){
        if (!t)return -INF;
        if (x==key[t])return x;
        if (x<key[t])return left[t]?pred(left[t],x):-INF;
        return max(pred(right[t],x),key[t]);
    }
    int succ(int &t,int x){
        if (!t)return INF;
        if (x==key[t])return x;
        if (x>key[t])return right[t]?succ(right[t],x):INF;
        return min(succ(left[t],x),key[t]);
    }
    int minx(int &rt){
        int now=rt;
        while (left[now])now=left[now];
        return key[now];
    }
}T,T0;
int f(int a){
    return a>0?a:-a;
}
int read(){
    int x=0,f=1;char ch=getchar();
    while (ch<'0' || ch>'9'){if (ch=='-')f=-1;ch=getchar();}
    while ('0'<=ch && ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return x*f;
}
int main(){
    n=read(),m=read();
    T.clear();T0.clear();
    int &rt=T.root,&o=T0.root,ans1=INF,ans2=INF;
    nxt[n]=INF;
    for (int i=1;i<=n;i++){
        x[i]=read();
        en[i]=x[i];nxt[i-1]=x[i];
        if (i!=1)ans2=min(ans2,min(f(T.pred(rt,x[i])-x[i]),f(T.succ(rt,x[i])-x[i])));
        T.insert(rt,x[i]);
        if (i!=1)ans1=min(ans1,f(x[i]-x[i-1]));
        if (i!=1)T0.insert(o,f(x[i]-x[i-1]));
    }
    int cnt=0;
    for (int i=1;i<=m;i++){
        char opt[20];
        scanf("%s",opt);
        int l=strlen(opt);
        if (l==6){
            int x=read(),y=read();
            ans2=min(ans2,min(f(T.pred(rt,y)-y),f(T.succ(rt,y)-y)));
            T.insert(rt,y);
            T0.insert(o,f(en[x]-y));
            T0.insert(o,f(nxt[x]-y));
            T0.erase(o,f(en[x]-nxt[x]));
            en[x]=y;
        }else if (l==7){ printf("%d\n",T0.minx(o));
        }else printf("%d\n",ans2);
    }
    return 0;
}
```

---

## 作者：Log_x (赞：0)

方法楼下的，只是给出了另一种写法：二叉堆换左偏树，Splay换Treap。

这题能很好地利用左偏树，首先利用队列两两合并O(n)建堆，在删除时可不必像二叉堆那样建两个堆懒惰删除，只需开一个数组inx[x]，记录原始数列中第x个元素在插入后管辖的最后一个元素与第x+1个元素的差值绝对值在左偏树中的序号，在插入新元素时利用左偏树的删除任意节点来删除inx[x]并更新即可。

不过效率并没有显著加快（果然蒟蒻），仅作为Treap和左偏树的练手题仍然也是个不错的选择。






 




```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
const int Maxn = 0x3f3f3f3f;
const int N = 5e5 + 5, M = N << 1;
int T, n, m, rTp, Ans = Maxn, x, y, str[N], edt[N];
int pos[M], lc[M], rc[M], vis[M], h[M], inx[N]; char s[15];
int tl[M], tr[M], dis[M], key[M], fa[M], E, rt;
template <class T> inline void CkMin(T &a, const T b) {if (a > b) a = b;}
template <class T> inline void Swap(T &a, T &b) {a ^= b; b ^= a; a ^= b;}
template <class T> inline T Min(const T a, const T b) {return a < b? a : b;}
inline int Abs(const int x) {return x < 0 ? ~x + 1 : x;}
inline int get()
{
    char ch; bool f = false; int res = 0;
    while (((ch = getchar()) < '0' || ch > '9') && ch != '-');
    if (ch == '-') f = true;
     else res = ch - '0';
    while ((ch = getchar()) >='0' && ch <= '9')
        res = (res << 3) + (res << 1) + ch - '0';
    return f? ~res + 1 : res;
}
inline void put(int x)
{
    if (x < 0)
      x = ~x + 1, putchar('-');
    if (x > 9) put(x / 10);
    putchar(x % 10 + 48);
}
//
//左偏树：
//(1) 合并 
inline int Merge(int x, int y)
{
    if (!x) return y;
    if (!y) return x;
    if (key[x] > key[y]) Swap(x, y);
    tr[x] = Merge(tr[x], y); fa[tr[x]] = x;
    if (dis[tl[x]] < dis[tr[x]]) Swap(tl[x], tr[x]); 
    dis[x] = tr[x] ? dis[tr[x]] + 1 : 0; return x;
} 
//(2) 删除任意节点 
inline void Delte(const int x)
{
    int q = fa[x],
        p = Merge(tl[x], tr[x]);
    fa[p] = q;
    if (x == rt) rt = p;
    if (q) (tr[q] == x? tr[q] : tl[q]) = p;
    while (q)
    {
        if (dis[tl[q]] < dis[tr[q]]) Swap(tl[q], tr[q]);
        if (dis[tr[q]] + 1 == dis[q]) return ;
        dis[q] = dis[tr[q]] + 1; q = fa[q];
    }
}
//(3) 插入 
inline void Push(const int vi) {key[++E] = vi; rt = Merge(rt, E);}
//
//Treap:
//(1)左右旋 
inline void Zig(int &x)
{
    int y = lc[x];
    lc[x] = rc[y], rc[y] = x;
    x = y;
}
inline void Zag(int &x)
{
    int y = rc[x];
    rc[x] = lc[y], lc[y] = x;
    x = y;
}
//(2)插入 
inline void Insert(int &x, const int vi)
{
    if (!x)
    {
        pos[x = ++T] = rand(); vis[x] = vi;
        return ;
    }
    CkMin(Ans, Abs(vi - vis[x])); 
    if (vi == vis[x]) return ;
    if (vi < vis[x])
    {
        Insert(lc[x], vi);
        if (pos[lc[x]] < pos[x]) Zig(x); 
    }
    else
    {
        Insert(rc[x], vi);
        if (pos[rc[x]] < pos[x]) Zag(x);
    }
}
int main()
{
    n = get(); m = get();
    Insert(rTp, str[1] = edt[1] = get());
    int t = 0, w = 0;
    for (int i = 2; i <= n; ++i)  
    {
        Insert(rTp, str[i] = edt[i] = get());
        h[++w] = inx[i - 1] = ++E;
        key[h[w]] = Abs(str[i] - edt[i - 1]);
    }
    for (int i = 1; i < n - 1; ++i) // 利用队列O(n)建堆
     h[++w] = Merge(h[t], h[t + 1]), t += 2;
    rt = h[w];
    while (m--)
    {
        scanf("%s", s);
        if (s[0] == 'I')
        {
            x = get(); y = get();
            if (x < n)
            {
                Delte(inx[x]);
                Push(Abs(y - str[x + 1]));
                inx[x] = E; // 更新inx[x] 
            }
            Push(Abs(edt[x] - y));
            edt[x] = y; 
            Insert(rTp, y);
        }
        else if (s[4] == 'G')
         put(key[rt]), putchar('\n');
        else 
         put(Ans), putchar('\n');
    }
    return 0;
}

```

---

## 作者：Jμdge (赞：0)

为什么这题这么水 ~~我都wa了好几遍~~ ...

本来打着心爱的 FHQ ，后来发现 STL 可以解决于是就...

# noteskey

其实这里就两个操作，询问（的代码复杂度）是 O(1) 的【雾

每一个修改对于 ans1 的贡献就是减去了一对原本相邻的元素差值，并且加上了另外两对元素差值，对于 ans2 就是直接更新了一下答案（与平衡树中前驱后继的差值）


# more

话说想常数更小一点的话可以用[这个堆的黑科技](https://www.cnblogs.com/Judge/p/10557516.html)替换掉 s1 ~~（然后 s2 也可以改成 set 了）~~，虽说原版的是大根堆，不过多加几个负号就能变成小根堆了23333333

不得不说这题还是比较水的，毕竟 STL 的 set 可以水过去

# code

3000 ms+

```
//by Judge
#pragma GCC optimize("Ofast")
#pragma GCC optimize(3)
#include<bits/stdc++.h>
#define fp(i,a,b) for(register int i=(a),I=(b)+1;i<I;++i)
#define IT multiset<int>::iterator
using namespace std;
const int M=5e5+3;
typedef int arr[M];
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline int abs(int x){return x<0?-x:x;}
inline void cmin(int& a,int b){a=a<b?a:b;}
inline int read(){ int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} inline void reads(string& s){ char c=getchar();
	for(;!isalpha(c);c=getchar()); s="";
	for(;isalpha(c)||c=='_';c=getchar()) s+=c;
} char sr[1<<21],z[20];int CCF=-1,Z;
inline void Ot(){fwrite(sr,1,CCF+1,stdout),CCF=-1;}
inline void print(int x,char chr='\n'){
    if(CCF>1<<20)Ot();if(x<0)sr[++CCF]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++CCF]=z[Z],--Z);sr[++CCF]=chr;
} int n,m,ans2=2e9,a[M],b[M];
string opt; multiset<int> s1,s2;
int main(){ n=read(),m=read(); int x,y; a[0]=a[n+1]=2e9;
	fp(i,1,n){ a[i]=b[i]=read(); IT it=s2.lower_bound(a[i]);
		if(it!=s2.end()) cmin(ans2,abs(*it-a[i]));
		if(it!=s2.begin()) --it,cmin(ans2,abs(a[i]-*it)); s2.insert(a[i]);
	} fp(i,1,n) s1.insert(abs(a[i+1]-b[i]));
	fp(kkk,1,m){ reads(opt),n=opt.length();
		if(n==6){ x=read(),y=read();
			s1.erase(s1.lower_bound(abs(a[x+1]-b[x]))),
			s1.insert(abs(b[x]-y)),b[x]=y,s1.insert(abs(a[x+1]-b[x]));
			IT it=s2.lower_bound(y); if(it!=s2.end()) cmin(ans2,abs(*it-y));
			if(it!=s2.begin()) --it,cmin(ans2,abs(y-*it)); s2.insert(y);
		} else if(n==7) print(*s1.begin()); else print(ans2);
	} return Ot(),0;
}
```

# code +1

2000 ms-
```
//by Judge
#pragma GCC optimize("Ofast")
#pragma GCC optimize(3)
#include<bits/stdc++.h>
#define fp(i,a,b) for(register int i=(a),I=(b)+1;i<I;++i)
#define IT set<int>::iterator
using namespace std;
const int M=5e5+3;
typedef int arr[M];
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline int abs(int x){return x<0?-x:x;}
inline void cmin(int& a,int b){a=a<b?a:b;}
inline int read(){ int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} inline void reads(string& s){ char c=getchar();
	for(;!isalpha(c);c=getchar()); s="";
	for(;isalpha(c)||c=='_';c=getchar()) s+=c;
} char sr[1<<21],z[20];int CCF=-1,Z;
inline void Ot(){fwrite(sr,1,CCF+1,stdout),CCF=-1;}
inline void print(int x,char chr='\n'){
    if(CCF>1<<20)Ot();if(x<0)sr[++CCF]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++CCF]=z[Z],--Z);sr[++CCF]=chr;
} int n,m,ans2=2e9,a[M],b[M]; string opt; set<int> s2;
struct Heap{ priority_queue<int> q1,q2;
    inline void push(int x){q1.push(-x);}
    inline void erase(int x){q2.push(-x);}
    inline void pop(){for(;q2.size()&&q1.top()==q2.top();q1.pop(),q2.pop());if(q1.size())q1.pop();}
    inline int top(){for(;q2.size()&&q1.top()==q2.top();q1.pop(),q2.pop());return -q1.top();}
    inline int top2(){int val,ret; val=top(),pop(),ret=top(),push(val); return -ret;}
    inline int size(){return q1.size()-q2.size();}
}s1;
int main(){ n=read(),m=read(); int x,y; a[0]=a[n+1]=2e9;
	fp(i,1,n){ a[i]=b[i]=read(); IT it=s2.lower_bound(a[i]);
		if(it!=s2.end()) cmin(ans2,abs(*it-a[i]));
		if(it!=s2.begin()) --it,cmin(ans2,abs(a[i]-*it)); s2.insert(a[i]);
	} fp(i,1,n) s1.push(abs(a[i+1]-b[i]));
	fp(kkk,1,m){ reads(opt),n=opt.length();
		if(n==6){ x=read(),y=read(),s1.erase(abs(a[x+1]-b[x]));
			s1.push(abs(b[x]-y)),b[x]=y,s1.push(abs(a[x+1]-b[x]));
			IT it=s2.lower_bound(y); if(it!=s2.end()) cmin(ans2,abs(*it-y));
			if(it!=s2.begin()) --it,cmin(ans2,abs(y-*it)); s2.insert(y);
		} else if(n==7) print(s1.top()); else print(ans2);
	} return Ot(),0;
}
```




---


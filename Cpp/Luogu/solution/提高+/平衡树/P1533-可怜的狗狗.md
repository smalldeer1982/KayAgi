# 可怜的狗狗

## 题目描述

小卡家有  $n$ 只狗，由于品种、年龄不同，每一只狗都有一个不同的漂亮值。漂亮值与漂亮的程度成反比（漂亮值越低越漂亮），吃饭时，狗狗们会按顺序站成一排等着主人给食物。

可是嘉嘉真的很懒，他才不肯喂这么多狗呢，这多浪费时间啊，于是他每次就只给第  $i$ 只到第  $j$ 只狗中第  $k$ 漂亮的狗狗喂食（好狠心的人啊）。而且为了保证某一只狗狗不会被喂太多次，他喂的每个区间  $[i,j]$ 不互相包含。

## 说明/提示

$1\le n \le 3\times 10^5 ,1\le m \le5\times10^4,0\le a_i<2^{31}$，且 $a_i$ 互不相同。

## 样例 #1

### 输入

```
7 2
1 5 2 6 3 7 4
1 5 3
2 7 1
```

### 输出

```
3
2
```

# 题解

## 作者：浅色调 (赞：33)

### 思路：

　　先吐槽一般数据较水～～

　　本来想打个暴力，于是码了一个莫队+权值线段树维护，时间复杂度$O(n\sqrt{n}logn)$（显然过不了啊！～），结果$AC$还进了最优解第一页。

　　首先就是常规的莫队离线，记录区间，排序。

　　对原数离散化，再构建权值线段树，每次维护一个数的增减，查询整个区间第$k$大，记录$ans$就$OK$了。
  
$\quad$这里我安利一波权值线段树：
	
$\quad$1、插入操作：其实就是单点修改，对于离散后的数每次找到它所在的叶子节点，使其权值增减$1$（说明这个数出现了一次或者减少了一个），并维护一段区间的数出现的个数（即区间求和）

$\quad$2、查询操作：询问第$k$小的数时，从整个区间$[1,n]$开始递归，当左儿子区间$[l,mid]$中出现的数个数大于等于$k$时，查询左儿子，否则查询右儿子中的第$k-sum[l,mid]$小的数(即左儿子中已有$sum[l,mid]<k$个数，那么整个区间第$k$小的数在右儿子里，且是右儿子中的第$k-sum[l,mid]$小的数)，当查询到$l==r$时返回$l$就$ok$了。

$\quad$欢迎来踩博客[five20](http://www.cnblogs.com/five20/p/8962105.html)（蒟蒻写题解不易，转载请注明出处，万分感谢！）

### 代码：
```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
#define il inline
#define ll long long
#define lson l,m,rt<<1
#define rson m+1,r,rt<<1|1
using namespace std;
const int N=300005;
int tr[N<<2],n,m,pos[N],a[N],ans[N];
struct node{
	int l,r,k,id;
}q[N];
struct numm{
	int v,id;
	bool operator < (const numm a)const{return v<a.v;}
}nm[N];
il bool cmp(node a,node b){return pos[a.l]==pos[b.l]?a.r<b.r:a.l<b.l;}
il int gi(){
	int a=0;char x=getchar();bool f=0;
	while((x<'0'||x>'9')&&x!='-')x=getchar();
	if(x=='-')x=getchar(),f=1;
	while(x>='0'&&x<='9')a=a*10+x-48,x=getchar();
	return f?-a:a;
}
il void pushup(int rt){tr[rt]=tr[rt<<1]+tr[rt<<1|1];}
il void update(int k,int c,int l,int r,int rt){
	if(l==k&&r==k){tr[rt]+=c;return;}
	tr[rt]+=c;
	int m=l+r>>1;
	if(k<=m)update(k,c,lson);
	else update(k,c,rson);
	pushup(rt);
}
il int query(int k,int l,int r,int rt){
	if(l==r)return l;
	int m=l+r>>1;
	if(tr[rt<<1]>=k)return query(k,lson);
	else return query(k-tr[rt<<1],rson);
}
int main(){
	n=gi(),m=gi();
	int s=int(sqrt(n));
	for(int i=1;i<=n;i++)nm[i].v=gi(),nm[i].id=i,pos[i]=(i-1)/s+1;
	sort(nm+1,nm+n+1);
	for(int i=1;i<=n;i++)a[nm[i].id]=i;
	for(int i=1;i<=m;i++)q[i].l=gi(),q[i].r=gi(),q[i].k=gi(),q[i].id=i;
	sort(q+1,q+m+1,cmp);
	for(int i=1,l=1,r=0;i<=m;i++){
		while(r<q[i].r)update(a[++r],1,1,n,1);
		while(r>q[i].r)update(a[r--],-1,1,n,1);
		while(l<q[i].l)update(a[l++],-1,1,n,1);
		while(l>q[i].l)update(a[--l],1,1,n,1);
		ans[q[i].id]=nm[query(q[i].k,1,n,1)].v;
	}
	for(int i=1;i<=m;i++)printf("%d\n",ans[i]);
	return 0;
}
```

---

## 作者：Karnage (赞：16)

# P1533 【可怜的狗狗】

[原题链接](https://www.luogu.org/problemnew/show/P1533)

**题意**：给你一列数，以及m个询问，每次求$l$,$r$区间内的第$k$小数

做法很多，主席树、整体二分都可以，我用的是离线+Treap(~~主要是上午刚学了平衡树来骗点经验~~)

## 做法：

首先肯定是将询问排序，至于如何排，一开始我以为要分块，结果发现题目中有这句话：

```
而且为了保证某一只狗狗不会被喂太多次，他喂的每个区间（i,j）不互相包含。
```
这样一来只要一左端点为第一关键字，右端点为第二关键字从小到大就行了

**具体：** 定义左右指针$l$,$r$表示当前左右端点，由于排序后询问区间的左右端点单调递增，就有了以下操作：
```cpp
while(r<que[i].r) Insert(root,w[++r]);
while(l<que[i].l) Remove(root,w[l++]);
ans[que[i].id]=getval(root,que[i].k+1);
```
意为，当左右指针小于询问的左右端点时，不断右移，完成后查询并记录即可。~~十分无脑~~

### 注意点：
1.一开始Treap中会插入$inf$和$-inf$，因此查询时要将$k+1$

2.右移指针时一定要先移$r$后移$l$（即先插入后删除），否则会出锅

3.排序前要记录每个询问的初始位置，最后按顺序输出

### Code：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;

const int N=3e5+2,inf=2147483647;
int n,m,tot,root,w[N],ans[N];
struct node {
    int l,r,k,id;
} que[50005];
struct treap {
    int l,r,val,data,size;
} a[N];

int New(int val) {
    a[++tot].val=val;
    a[tot].data=rand();
    a[tot].size=1;
    return tot;
}

void update(int p) {
    a[p].size=a[a[p].l].size+a[a[p].r].size+1;
}

void build() {
    New(-inf),New(inf);
    root=1,a[1].r=2;
    update(root);
}

int getval(int p,int rank) {
    if(!p) return inf;
    if(a[a[p].l].size>=rank) return getval(a[p].l,rank);
    if(a[a[p].l].size+1==rank) return a[p].val;
    return getval(a[p].r,rank-a[a[p].l].size-1);
}

void zag(int &p) {
    int q=a[p].r;
    a[p].r=a[q].l,a[q].l=p,p=q;
    update(a[p].l),update(p);
}

void zig(int &p) {
    int q=a[p].l;
    a[p].l=a[q].r,a[q].r=p,p=q;
    update(a[p].r),update(p);
}

void Insert(int &p,int val) {
    if(!p) {
        p=New(val);
        return;
    }
    if(val<a[p].val) {
        Insert(a[p].l,val);
        if(a[p].data<a[a[p].l].data) zig(p);
    } else {
        Insert(a[p].r,val);
        if(a[p].data<a[a[p].r].data) zag(p);
    }
    update(p);
}

void Remove(int &p,int val) {
    if(!p) return;
    if(val==a[p].val) {
        if(a[p].l||a[p].r) {
            if(!a[p].r||a[a[p].l].data>a[a[p].r].data) zig(p),Remove(a[p].r,val);
            else zag(p),Remove(a[p].l,val);
            update(p);
        } else p=0;
        return;
    }
    val<a[p].val?Remove(a[p].l,val):Remove(a[p].r,val);
    update(p);
}

bool cmp(const node &p,const node &q) {
    if(p.l!=q.l) return p.l<q.l;
    return p.r<q.r;
}

int main() {
    build();
    scanf("%d%d",&n,&m);
    for(int i=1; i<=n; ++i) scanf("%d",&w[i]);
    for(int i=1; i<=m; ++i) scanf("%d%d%d",&que[i].l,&que[i].r,&que[i].k),que[i].id=i;
    sort(que+1,que+m+1,cmp);
    for(int i=1,l=1,r=0; i<=m; ++i) {
        while(r<que[i].r) Insert(root,w[++r]);
        while(l<que[i].l) Remove(root,w[l++]);
        ans[que[i].id]=getval(root,que[i].k+1);
    }
    for(int i=1; i<=m; ++i) printf("%d\n",ans[i]);
    return 0;
}

---

## 作者：misinclair (赞：12)

在这里mark一下整体二分的做法。

我们考虑如果只有一个询问，我们可以通过$O(nlogn)$二分出来

具体而言，就是我们二分一个权值，把小于等于这个权值的数标为1，把大于这个权值的数标为0，那么我们询问这个区间的和，记为$sum$，容易发现如果$k\leq sum$说明我们二分的权值大了，需要变小（保留$mid$），否则，则要变大。

那么这道题目怎么做呢

首先我们并不关心每个数的具体大小，只关心他们的相对大小关系，所以不妨先离散化一下。

我们二分一个权值，可以将所有小于等于这个权值的扔到一个队列里，将所有大于这个权值的扔到另一个队列里，不难发现如果我们对于一个询问区间和的查询，如果结果小于其$k$，那么这个权值还要变大一些，那么我们也将其扔进第二个队列，同时其$k$值需要减去这个询问的结果，否则的话，则表明这个二分的结果偏大，我们将其扔到第一个队列里。然后我们对于两个队列再进行二分。

对于第一个队列，将二分的权值变大。对于第二个队列，将二分的权值变小。

终止条件，当我们二分到$l=r$时就可以对这个队列的询问操作的答案标为$l$，总的时间复杂度是$O(nlog^2n)$，而空间复杂度是$O(n)$的。
是不是很优越呢喵~

```cpp
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>

using namespace std;

inline int read() {
	char c = getchar(); int x = 0, f = 1;
	while(!isdigit(c)) {if(c == '-') f = -1; c = getchar();}
	do {x = x * 10 + (c ^ 48); c = getchar();} while(isdigit(c));
	return x * f;
}

const int N = 4e5 + 29;
struct data {
	int l, r, k, id, type; 
} opt[N], q1[N], q2[N];
int a[N], b[N], c[N], bit[N], ans[N], ch[N];
int n, m, cnt;

void add(int x, int v) {
	while(x <= n) {
		bit[x] += v;
		x += x & -x;
	}
}

int sum(int x) {
	int res = 0;
	while(x) {
		res += bit[x];
		x -= x & -x;
	}
	return res;
}

void solve(int sb, int se, int l, int r) {
	if(sb > se) return;
	if(l == r) {
		for(int i = sb; i <= se; ++i)
			if(opt[i].type) ans[opt[i].id] = l;
		return;
	}
	int mid = (l + r) >> 1, cur = 0;
	int cnt1 = 0, cnt2 = 0;
	for(int i = sb; i <= se; ++i) {
		if(!opt[i].type) {
			if(opt[i].k <= mid) {
				add(opt[i].id, 1);
				ch[++cur] = opt[i].id;
				q1[++cnt1] = opt[i];
			} else q2[++cnt2] = opt[i];
		} else {
			int tmp = sum(opt[i].r) - sum(opt[i].l - 1);
			if(opt[i].k <= tmp) q1[++cnt1] = opt[i];
			else {
				opt[i].k -= tmp;
				q2[++cnt2] = opt[i];
			}
		}
	}
	for(int i = 1; i <= cur; ++i) add(ch[i], -1);
	for(int i = 1; i <= cnt1; ++i)
		opt[sb + i - 1] = q1[i];
	for(int i = 1; i <= cnt2; ++i)
		opt[sb + i - 1 + cnt1] = q2[i];
	solve(sb, sb + cnt1 - 1, l, mid);
	solve(sb + cnt1, se, mid + 1, r);
}

int main() {
	n = read(), m = read();
	for(int i = 1; i <= n; ++i) {
		a[i] = read(); b[i] = a[i];
	}
	sort(b + 1, b + n + 1);
	int tot = unique(b + 1, b + n + 1) - b - 1;
	for(int i = 1; i <= n; ++i) {
		int p = lower_bound(b + 1, b + tot + 1, a[i]) - b;
		c[p] = a[i]; a[i] = p;
		opt[++cnt] = (data) {0, 0, p, i, 0};
	}
	for(int i = 1; i <= m; ++i) {
		int left = read(), right = read(), k = read();
		opt[++cnt] = (data) {left, right, k, i, 1};
	}
	solve(1, cnt, 1, tot);
	for(int i = 1; i <= m; ++i)
		printf("%d\n", c[ans[i]]);
	return 0;
}

```

---

## 作者：YuRuiH_ (赞：9)

[获得更好的阅读？](https://www.avg.cx/index.php/archives/134/)


[P1533 可怜的狗狗](https://www.luogu.org/problem/P1533 "P1533 可怜的狗狗")


------------

这道题看上去标签是 *高级数据结构* 实际上就是一个裸的主席树，我看大佬们直接*平衡树*，*莫队* 啥的，反正我也不会，就水一发主席树的题解吧。！！

直接裸的主席树模板就可以，他说大小规则是小的最大，所以就很简单了呀。

代码丑，勿怪。

```
#include <iostream>
#include <cstdio>
#include <queue>
#include <algorithm>
#include <cstring>

#define LL long long
#define rg register

template<class T>
inline void read(T &x)
{
	x=0;
	bool f=0;
	char c=getchar();
	for(;!isdigit(c);c=getchar())
		f^=c=='-';
	for(;isdigit(c);c=getchar())
		x=x*10+(c^48);
	x=f?-x:x;
}

const int MAXN=3e5+10;

int a[MAXN],b[MAXN],T[MAXN],n,m;

int NodeNum,L[MAXN<<5],R[MAXN<<5],sum[MAXN<<5];

//-----------------主席树部分------------------- 
	
int build(int l,int r)
{
	int num=++NodeNum;
	if(l!=r)
	{
		int mid=(l+r)>>1;
		L[num]=build(l,mid);
		R[num]=build(mid+1,r);
	}
	return num;
}
		
int Update(int pre,int l,int r,int val)
{		
	int num=++NodeNum;
	L[num]=L[pre];
	R[num]=R[pre];
	sum[num]=sum[pre]+1;
	if(l!=r)
	{
		int mid=(l+r)>>1;
		if(val<=mid)
			L[num]=Update(L[pre],l,mid,val);	
		else
			R[num]=Update(R[pre],mid+1,r,val);
		return num;
	}
	return num;
}
	
int query(int u,int v,int l,int r,int k)
{
	if(l==r)
		return b[l];
	int mid=(l+r)>>1;
	int num=sum[L[v]]-sum[L[u]];
	if(num>=k)
		return query(L[u],L[v],l,mid,k);
	else
		return query(R[u],R[v],mid+1,r,k-num);
}

//--------------------------------------------------

int main()
{
	read(n),read(m);
	for(rg int i=1;i<=n;i++)
	{
		read(a[i]);
		b[i]=a[i];
	}
	std::sort(b+1,b+n+1);
	int size=std::unique(b+1,b+n+1)-b-1;//去重离散 
	T[0]=build(1,size);
	for(rg int i=1;i<=n;i++)
	{
		int x=std::lower_bound(b+1,b+size+1,a[i])-b;//离散 
		T[i]=Update(T[i-1],1,size,x);
	}
	for(rg int i=1,l,r,k;i<=m;i++)
	{
		read(l),read(r),read(k);
		printf("%d\n",query(T[l-1],T[r],1,size,k));//查询 
	}
}

---

## 作者：yzhang (赞：7)

### [更好的阅读](https://www.cnblogs.com/yzhang-rp-inf/p/10015943.html)

### [原题传送门](https://www.luogu.org/problemnew/show/P1533)

### [莫队介绍](https://www.cnblogs.com/yzhang-rp-inf/p/9991671.html),[Splay介绍](https://www.cnblogs.com/yzhang-rp-inf/p/9957906.html)

离线的题目，莫队是不错的解决方法

先把询问排一下序

剩下就套一个莫队的板子

每来一只狗就把漂亮值插入平衡树

每去掉一只狗就把漂亮值从平衡树中删掉

每次查询查平衡树中第k小

```cpp
#pragma GCC optimize("O3")
#include <bits/stdc++.h>
#define N 800005
#define M 50005
using namespace std;
inline char nc(){
    static char buf[100000],*p1=buf,*p2=buf; 
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++; 
}
inline int read()
{
    register int x=0,f=1;register char ch=nc();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=nc();}
    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=nc();
    return x*f;
}
inline void write(register int x)
{
    if(!x)putchar('0');if(x<0)x=-x,putchar('-');
    static int sta[20];register int tot=0;
    while(x)sta[tot++]=x%10,x/=10;
    while(tot)putchar(sta[--tot]+48);
}
struct Splay{
	int v,fa,ch[2],sum,rec;
}tree[N];
int tot=0;
inline void update(register int x)
{
	tree[x].sum=tree[tree[x].ch[0]].sum+tree[tree[x].ch[1]].sum+tree[x].rec;
}
inline bool findd(register int x)
{
	return tree[tree[x].fa].ch[0]==x?0:1;
}
inline void connect(register int x,register int fa,register int son)
{
	tree[x].fa=fa;
	tree[fa].ch[son]=x;
} 
inline void rotate(register int x)
{
	int Y=tree[x].fa;
	int R=tree[Y].fa;
	int Yson=findd(x);
	int Rson=findd(Y);
	int B=tree[x].ch[Yson^1];
	connect(B,Y,Yson);
	connect(Y,x,Yson^1);
	connect(x,R,Rson);
	update(Y),update(x);
}
inline void splay(register int x,register int to)
{
	to=tree[to].fa;
	while(tree[x].fa!=to)
	{
		int y=tree[x].fa;
		if(tree[y].fa==to)
			rotate(x);
		else if(findd(x)==findd(y))
			rotate(y),rotate(x);
		else
			rotate(x),rotate(x);
	}	
}
inline int newpoint(register int v,register int fa)
{
	tree[++tot].fa=fa;
	tree[tot].v=v;
	tree[tot].sum=tree[tot].rec=1;
	return tot; 
}
inline void Insert(register int x)
{
	int now=tree[0].ch[1];
	if(tree[0].ch[1]==0)
	{
		newpoint(x,0);
		tree[0].ch[1]=tot;
	}
	else
	{
		while(19260817)
		{
			++tree[now].sum;
			if(tree[now].v==x)
			{
				++tree[now].rec;
				splay(now,tree[0].ch[1]);
				return;
			}
			int nxt=x<tree[now].v?0:1;
			if(!tree[now].ch[nxt])
			{
				int p=newpoint(x,now);
				tree[now].ch[nxt]=p;
				splay(p,tree[0].ch[1]);
				return;
			}
			now=tree[now].ch[nxt];
		}
	}
}
inline int find(register int v)
{
	int now=tree[0].ch[1];
	while(19260817)
	{
		if(tree[now].v==v)
		{
			splay(now,tree[0].ch[1]);
			return now;
		}
		int nxt=v<tree[now].v?0:1;
		if(!tree[now].ch[nxt])
			return 0;
		now=tree[now].ch[nxt];
	}
}
inline void delet(register int x)
{
	int pos=find(x);
	if(!pos)
		return;
	if(tree[pos].rec>1)
	{
		--tree[pos].rec;
		--tree[pos].sum;
	}
	else
	{
		if(!tree[pos].ch[0]&&!tree[pos].ch[1])
			tree[0].ch[1]=0;
		else if(!tree[pos].ch[0])
		{
			tree[0].ch[1]=tree[pos].ch[1];
			tree[tree[0].ch[1]].fa=0;
		}
		else
		{
			int left=tree[pos].ch[0];
			while(tree[left].ch[1])
				left=tree[left].ch[1];
			splay(left,tree[pos].ch[0]);
			connect(tree[pos].ch[1],left,1);
			connect(left,0,1);
			update(left);
		}
	}
}
inline int arank(register int x)
{
	int now=tree[0].ch[1];
	while(19260817)
	{
		int used=tree[now].sum-tree[tree[now].ch[1]].sum;
		if(x>tree[tree[now].ch[0]].sum&&x<=used)
		{
			splay(now,tree[0].ch[1]);
			return tree[now].v;
		}
		if(x<used)
			now=tree[now].ch[0];
		else
			x-=used,now=tree[now].ch[1];
	}
}
struct query{
	int l,r,id,bl,k;
}q[M];
int a[N],blocksize=0,ans[M];
inline bool cmp(register query a,register query b)
{
	return a.bl!=b.bl?a.l<b.l:((a.bl&1)?a.r<b.r:a.r>b.r);
}
int main()
{
	int n=read(),m=read();
	blocksize=sqrt(m);
	for(register int i=1;i<=n;++i)
		a[i]=read();
	for(register int i=1;i<=m;++i)
	{
		int l=read(),r=read(),k=read();
		q[i]=(query){l,r,i,l/blocksize,k};
	}
	sort(q+1,q+m+1,cmp);
	int l=1,r=0;
	for(register int i=1;i<=m;++i)
	{
		int ll=q[i].l,rr=q[i].r;
		while(ll<l)
			Insert(a[--l]);
		while(rr>r)
			Insert(a[++r]);
		while(ll>l)
			delet(a[l++]);
		while(rr<r)
			delet(a[r--]);
		ans[q[i].id]=arank(q[i].k);
	}
	for(register int i=1;i<=m;++i)
		write(ans[i]),puts("");
	return 0;
}
```

---

## 作者：Nemlit (赞：7)

## [原文地址](https://www.cnblogs.com/bcoier/p/10519718.html)

首先这道题目，当然可以作为[主席树](https://www.cnblogs.com/bcoier/p/10293521.html)的模板来做，但是这道题目有令一种解法

发现操作允许离线，我们考律莫队

首先建一棵权值线段树，我们可以查询权值线段树里的值的第K大，所以我们可以利用莫队进行删减操作（其实和主席树差不多？）。

PS：由于保证所有数据不重复，离散化的时候就没必要去重了。

```
#include<bits/stdc++.h>
using namespace std;
#define il inline
#define re register
#define file(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
#define inf 123456789
il int read()
{
    re int x = 0, f = 1; re char c = getchar();
    while(c < '0' || c > '9') { if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - 48, c = getchar();
    return x * f;
}
#define rep(i, s, t) for(re int i = s; i <= t; ++ i)
#define drep(i, s, t) for(re int i = t; i >= s; -- i)
#define Next(i, u) for(re int i = head[u]; i; i = e[i].next)
#define ls k * 2
#define rs k * 2 + 1
#define maxn 300005
struct node{int x, y, k, id;}q[maxn];
struct pax{int id, val;}p[maxn];
int n, m, val[maxn], ans[maxn], bl, l = 1, r, Val[maxn << 2];
il bool cmp1(pax a, pax b){return a.val < b.val;}
il bool cmp(node a, node b){return (a.x / bl == b.x / bl) ? (a.y < b.y) : (a.x < b.x);}
il void add(int k, int l, int r, int opt, int v)
{
	Val[k] += opt;
	if(l == r && l == v) return;
	int mid = (l + r) >> 1;
	if(v <= mid) add(ls, l, mid, opt, v);
	else add(rs, mid + 1, r, opt, v);
}
il int query(int k, int l, int r, int v)
{
	if(l == r) return l;
	int lmid = Val[ls], mid = (l + r) >> 1;
	if(v <= lmid) return query(ls, l, mid, v);
	else return query(rs, mid + 1, r, v - lmid);
}
il void add(int x){add(1, 1, n, 1, val[x]);}
il void del(int x){add(1, 1, n, -1, val[x]);}
int main()
{
	file(a);
	n = read(), m = read(), bl = pow(n, 0.666);
	rep(i, 1, n) p[i].id = i, p[i].val = read();
	rep(i, 1, m) q[i].id = i, q[i].x = read(), q[i].y = read(), q[i].k = read();
	sort(p + 1, p + n + 1, cmp1);
	rep(i, 1, n) val[p[i].id] = i;
	sort(q + 1, q + m + 1, cmp);
	rep(i, 1, m)
	{
		while(r < q[i].y) add(++ r);
		while(r > q[i].y) del(r --);
		while(l < q[i].x) del(l ++);
		while(l > q[i].x) add(-- l);
		ans[q[i].id] = p[query(1, 1, n, q[i].k)].val;
	}
	rep(i, 1, m) printf("%d\n", ans[i]);
	return 0;
} 
```

---

## 作者：pengym (赞：7)

对于这种区间第k小的问题，一般可以用主席树，划分树或线段树可以做。但蒟蒻太弱了，都不会（除了线段树），又刚好最近新学了treap，便用treap打了一遍，可以帮助自己掌握treap求第k小数的打法，以及删除，插入等操作。（另外treap是和刘汝佳大白书学的，风格可能与刘汝佳差不多）

本题主要思路是：把需要求的区间排序（一定记得按原顺序编号），之后再简单的处理一下就行了（建议自己画图与程序一起理解）

下附代码：

 
```cpp
#include<queue>
#include<cmath> 
#include<cstdio> 
#include<cstring> 
#include<iostream> 
#include<algorithm> 
#define N 310000
using namespace std;
inline void read(int &x) 
{ 
    x=0; 
    int p=1; 
    char c=getchar(); 
    while(!isdigit(c)){if(c=='-')p=-1;c=getchar();} 
    while(isdigit(c)) {x=(x<<1)+(x<<3)+(c^'0');c=getchar();} 
    x*=p; 
}
struct node
{
    node *ch[2];
    int v,r,s;
    int cmp(int x)const
    {
        if(x==v)return -1;
        return x<v?0:1;
    }
    void maintain()
    {
        s=1;
        if(ch[0]!=NULL)s+=ch[0]->s;
        if(ch[1]!=NULL)s+=ch[1]->s;
    }
};
struct xg
{
    int l,r,k;
    int num;
    bool operator < (const xg &rs)const
    {
        return l<rs.l;
    }
}e[N];
int a[N];
node *root;
void rotate(node *&o,int d)
{
    node *k=o->ch[d^1];
    o->ch[d^1]=k->ch[d];
    k->ch[d]=o;    
    k->maintain();
    o->maintain();
    o=k;
}
void insert(node *&o,int x)//插入
{
    if(o==NULL)
    {
        o=new node;
        o->v=x;o->r=rand();o->ch[0]=o->ch[1]=NULL;
    }
    else 
    {
        int d=x<o->v?0:1;
        insert(o->ch[d],x);
        if(o->ch[d]->r > o->r)rotate(o,d^1);
    }
    o->maintain();
}
void remove(node *&o,int x)//删除
{
    int d=o->cmp(x);
    if(d==-1)
    {
        node *u=o;
        if(o->ch[0]==NULL)o=o->ch[1],delete u;
        else if(o->ch[1]==NULL)o=o->ch[0],delete u;
        else
        {
            int d2=(o->ch[0]->r > o->ch[1]->r?1:0);
            rotate(o,d2);
            remove(o->ch[d2],x);
        }
    }else remove(o->ch[d],x);
    if(o)o->maintain();
}
int minkth(node *o,int k)//第k小
{
    if(o==NULL||k<=0||k>o->s)return 0;
    int sum=(o->ch[0]==NULL?0:o->ch[0]->s);
    if(k==sum+1)return o->v;
    else if(k<=sum)return minkth(o->ch[0],k);
    else return minkth(o->ch[1],k-sum-1);
}
int ans[N];//存答案
int main() 
{ 
    srand(4531534);
    int n,m;
    read(n);read(m);
    int x;
    read(x);
    a[1]=x;
    root=new node;
    for(int i=2;i<=n;i++)
    read(a[i]);
    for(int i=1;i<=m;i++)
    {
        read(e[i].l);read(e[i].r);read(e[i].k);
        e[i].num=i;//编号
    }
    sort(e+1,e+m+1);
    root->v=a[e[1].l];root->r=rand();root->ch[0]=root->ch[1]=NULL;//处理第一个点
    for(int i=e[1].l+1;i<=e[1].r;i++)
    insert(root,a[i]);
    ans[e[1].num]=minkth(root,e[1].k);
    for(int i=2;i<=m;i++)
    {
        if(e[i].l<e[i-1].r)
        {for(int j=e[i-1].l;j<e[i].l;j++)remove(root,a[j]);
        if(e[i-1].r<e[i].r)for(int j=e[i-1].r+1;j<=e[i].r;j++)insert(root,a[j]);
        }
        else 
        {
            for(int j=e[i-1].l;j<=e[i-1].r;j++)remove(root,a[j]);
            for(int j=e[i].l;j<=e[i].r;j++)insert(root,a[j]);
        }
        ans[e[i].num]=minkth(root,e[i].k);
    }
    for(int i=1;i<=m;i++)
    printf("%d\n",ans[i]);
    return 0; 
} 

```

---

## 作者：Rbu_nas (赞：5)

这题我本来以为只是一道清新的小水题，然而却调了我一上午 TAT

看到区间第 k 小立刻联想到平衡树，但是问题在于这是有区间范围的嗷，每次都重新把区间里的点都加进来肯定 gg，所以就可以离线然后[莫队](https://blog.sengxian.com/algorithms/mo-s-algorithm)求解

这道题要注意先插入再删除，就是说我们默认我们的左右端点 $l$，$r$ 是在询问范围 $[ql,\ qr]$ 前的，这样子添加点肯定没有影响。但如果不这样的话，若询问给出 $[2,\ 3]$ 这样的区间，而我们的左右端点一开始是 $l = 1, r = 0$ 的，树里面也没有点，开始移动时会先删除 $l = 1$ 呀，然后 $l+1\ \to \ l=2$，但我们删除 $l = 1$ 就会挂啊，因为树没有节点，然后程序就会奇奇怪怪的把第一只狗的颜值弄进树了emm

另外就是很多平衡树题目题解里都会先插入 $inf$ 与 $-inf$，我认为**部分**题目其实不需要啊，因为不存在什么查找会越界吧。如果是我理解错误麻烦大佬能指出orz

这里给出 fhqTreap 与 vector 的代码实现。

```cpp
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <iostream>
#include <algorithm>

using namespace std;

const int inf = 2100000000;
const int N = 300007;

template < class T > inline void read(T &x)
{
    x = 0; bool f = 1; register char ch = getchar();
    for(; ch < '0' || ch > '9'; ch = getchar())
        if(ch == '-') f = 0;
    for(; ch >= '0' && ch <= '9'; ch = getchar())
        x = (x << 1) + (x << 3) + (ch ^ 48);
    x = f ? x : -x;
}

int n, m;
int a[N], Ans[N];
int root, cnt;

struct fhqTreap
{
    int l, r;
    int val, key;
    int size;
};
fhqTreap tr[N << 1];

inline void pushUp(int p) {
    tr[p].size = tr[tr[p].l].size + tr[tr[p].r].size + 1;
}

inline int newnode(int val)
{
    ++cnt; tr[cnt].l = tr[cnt].r = 0;
    tr[cnt].val = val, tr[cnt].key = rand();
    tr[cnt].size = 1; return cnt;
}

void split(int p, int val, int &x, int &y)
{
    if(!p)
    {
        x = y = 0;
        return ;
    }
    if(tr[p].val <= val)
    {
        x = p;
        split(tr[p].r, val, tr[p].r, y);
    }
    else
    {
        y = p;
        split(tr[p].l, val, x, tr[p].l);
    }
    pushUp(p);
}

int merge(int x, int y)
{
    if(!x || !y) return x | y;
    if(tr[x].key > tr[y].key)
    {
        tr[x].r = merge(tr[x].r, y);
        pushUp(x); return x;
    }
    else
    {
        tr[y].l = merge(x, tr[y].l);
        pushUp(y); return y;
    }
}

int kthNum(int p, int k)
{
    if(k <= tr[tr[p].l].size)
        return kthNum(tr[p].l, k);
    else if(k == tr[tr[p].l].size + 1)
        return p;
    else
    {
        k -= (tr[tr[p].l].size + 1);
        return kthNum(tr[p].r, k);
    }
}

//以上为 fhq-treap 板子

struct captainMo { int l, r, k, id, block; };
captainMo q[N];

inline bool cmp(captainMo a, captainMo b) {
    return (a.block ^ b.block) ? a.block < b.block : (a.block & 1) ? a.r < b.r : a.r > b.r;
}

//使用奇偶性排序加速，这里不细讲。

inline void del(int t)
{
    int val = a[t], x, y, z;
    split(root, val, x, y);
    split(x, val - 1, x, z);
    z = merge(tr[z].l, tr[z].r);
    root = merge(merge(x, z), y);
}

//树中删除下标为 t 的狗的颜值

inline void add(int t)
{
    int val = a[t], x, y;
    split(root, val, x, y);
    root = merge( merge(x, newnode(val)), y );
}

//添加下标为 t 的狗的颜值

signed main()
{
    srand(1******7);
    read(n); read(m);

	//块的大小设为 n/√(m*2/3) 玄学加速
    register int S = n / sqrt((m << 1) / 3);
    for(register int i = 1; i <= n; ++i) read(a[i]);
    for(register int i = 1; i <= m; ++i)
    {
        read(q[i].l), read(q[i].r), read(q[i].k);
        q[i].id = i, q[i].block = q[i].l / S;
    }
    sort(q + 1, q + m + 1, cmp);
	
    //莫队操作
    register int l = 1, r = 0;
    for(register int i = 1; i <= m; ++i)
    {
        while(l > q[i].l) add(--l);
        while(r < q[i].r) add(++r);
        while(l < q[i].l) del(l++);
        while(r > q[i].r) del(r--);
        Ans[q[i].id] = tr[kthNum(root, q[i].k)].val;
        //记录此询问的位置的答案
    }
    for(register int i = 1; i <= m; ++i) printf("%d\n", Ans[i]);
    return 0;
}

```

```cpp
#pr\
agma GCC optimize(3)
#include <bits/stdc++.h>

using namespace std;

const int inf = (1 << 30);
const int N = 300007;

template < class T > inline void read(T &x)
{
    x = 0; bool f = 1; register char ch = getchar();
    for(; ch < '0' || ch > '9'; ch = getchar())
        if(ch == '-') f = 0;
    for(; ch >= '0' && ch <= '9'; ch = getchar())
        x = (x << 1) + (x << 3) + (ch ^ 48);
    x = f ? x : -x;
}

int n, m;
int a[N], Ans[N];

vector < int > v;

struct captainMo { int l, r, k, id, block; };
captainMo q[N];

inline bool cmp(captainMo a, captainMo b) {
    return (a.block ^ b.block) ? a.block < b.block : (a.block & 1) ? a.r < b.r : a.r > b.r;
}

inline void del(int t) {
    v.erase(lower_bound(v.begin(), v.end(), a[t]));
}
inline void add(int t) {
    v.insert(lower_bound(v.begin(), v.end(), a[t]), a[t]);
}

signed main()
{
    read(n); read(m);
    v.push_back(inf); v.push_back(-inf);
    //这里是为了不 lower_bound 出界 RE
    
    register int S = n / sqrt((m << 1) / 3);
    for(register int i = 1; i <= n; ++i) read(a[i]);
    for(register int i = 1; i <= m; ++i)
    {
        read(q[i].l), read(q[i].r), read(q[i].k);
        q[i].id = i, q[i].block = q[i].l / S;
    }
    sort(q + 1, q + m + 1, cmp);
	
    register int l = 1, r = 0;
    for(register int i = 1; i <= m; ++i)
    {
        while(l > q[i].l) add(--l);
        while(r < q[i].r) add(++r);
        while(l < q[i].l) del(l++);
        while(r > q[i].r) del(r--);
        Ans[q[i].id] = v.at(q[i].k + 1);
        //插入了-inf且不会被删除，所以排名+1
    }
    for(register int i = 1; i <= m; ++i) printf("%d\n", Ans[i]);
    return 0;
}

```

---

## 作者：SunnCloud (赞：4)

看到大佬们写了很多~~我看不懂的~~复杂题解

~~作为蒟蒻的~~我就想尝试一下有没有简单**一点**的方法

# 解题思路
第一眼看到这个题目，嗯......询问区间，应该是莫队。

再定睛一看，不互相包含?这也就意味着若将询问区间按 $l$ 排列,  $r$ 也一定是有序的。

所以呢？直接**vector暴力二分查找**插入/删除，根本不用莫队优化

不多说，上代码
# **代码部分**
```
#include<bits/stdc++.h>
using namespace std;
int n,m,a[500500],ans[500500];
vector <int> V;
struct md{
    int x,y,k,num;
} q[500500];//其中x表示左边界，y表示右边界，k表示询问第几大，num表示询问编号
bool cmp(md a,md b)
{
    return a.x!=b.x?a.x<b.x:a.y<b.y;//由于不包含，卡常等玄学优化都不需要
}
int main()
{
cin>>n>>m;
for(int i=1;i<=n;i++)//读入（快读都懒得写= =）
    cin>>a[i];
int l=1,r=1;
V.push_back(a[1]);
for(int i=1;i<=m;i++)
{
    cin>>q[i].x>>q[i].y>>q[i].k;
    q[i].num=i;
}
sort(q+1,q+1+m,cmp);//按询问区间的左边界排序，此时右边界也是有序的
for(int i=1;i<=m;i++)
{
    while(r<q[i].y)//更新r，二分查找插入a[r]
    {
        r++;
        V.insert(upper_bound(V.begin(),V.end(),a[r]),a[r]);
    }
    while(l<q[i].x)//更新l，二分查找删除a[l]
    {
        V.erase(lower_bound(V.begin(),V.end(),a[l]));
        l++;
    }
    ans[q[i].num]=V[q[i].k-1];//离线记录答案
}
for(int i=1;i<=m;i++)cout<<ans[i]<<endl;//输出（懒得写快输= =）
return 0;
}//结束了？结束了。总时间复杂度O(nlogn)
```
~~PS: STL大法好~~

---

## 作者：critnos (赞：3)

个人认为这题应该是紫啊，不是主席树，就是平衡树。

这道题有一个重要的性质：

>而且为了保证某一只狗狗不会被喂太多次，他喂的每个区间（i,j）不互相包含。

这就说明，对于两个区间 $[l_1,r_1]$ 和 $[l_2,r_2]$，如果 $l_1< l_2$，那么 $r_1$ 也必然 $< r_2$。

为什么呢？因为如果 $r_1\ge r_2$ 那么 $[l_1,r_1]$ 就包含了 $[l_2,r_2]$。

这里有一个特性：任意两个区间的 $l$ 或 $r$ 均不相等。这个请读者自行证明。

如果把莫队进行魔改，以 $l$ 按递增顺序排列，那 $r$ 同样递增。

这时候莫队的两个指针 $L$ 和 $R$ 只会往后跳，不会向前了。

证一下时间复杂度：排序 $m\log m$。其实可以使用计数排序，这样可以做到 $O(n)$ 排序。但在此题中 $m$ 远远小于 $n$，所以还是使用快排。下面让两个指针 $L$ 和 $R$ 跳完，因为 $L$ 和 $R$ 最多跳 $n$ 次，每次更新指针的复杂度是 $\log n$（使用平衡树维护），所以时间复杂度为 $n\log n$。每次查询区间第 $k$ 小（即在平衡树里求排名第 $k$ 小的数）时间复杂度 $\log n$，共查询 $m$ 次。总时间复杂度 $m(\log m+\log n)+n\log n$，可以视作 $O(n\log n)$。

代码比主席树短得多，因为平衡树使用了~~平板电视大法~~ pb_ds 。

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
using namespace std;
using namespace __gnu_pbds;
tree<double,null_type,less<double>,rb_tree_tag,tree_order_statistics_node_update> t;
struct ask
{
	int l,r,w,k;
	friend bool operator <(const ask &qwq,const ask &qaq)
	{
		return qwq.l<qaq.l;
	}
}q[50005];
int a[300005],ans[300005];
const double mf=1e-6;
int main()
{
    int m,n,l=1,r=0,i,j;
    scanf("%d%d",&n,&m);
    for(i=1;i<=n;i++)
    	scanf("%d",&a[i]);
    for(i=0;i<m;i++)
    {
    	scanf("%d%d%d",&q[i].l,&q[i].r,&q[i].k);
    	q[i].w=i;
	}	
    sort(q,q+m);
    for(i=0;i<m;i++)
    {
    	while(r<q[i].r) t.insert(a[++r]+r*mf);
    	while(l<q[i].l) t.erase(l*mf+a[l++]);
    	ans[q[i].w]=*t.find_by_order(q[i].k-1);
	}
    for(i=0;i<m;i++)
    	printf("%d\n",ans[i]);
}
```

---

## 作者：「QQ红包」 (赞：3)

题解 by redbag

这里提供一种用树状数组的解法

思路：先离散a数组

然后读入询问，

将询问排序（第一关键字：左端 第二关键字：右端）

然后一个一个处理

将左端之前的删去

将左端到右端中没有加到树状数组的加上去

最后二分找第k小

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
int a[300010];//点的个数
struct node
{
    int x,y,k,d;//x→y第k小，d：原编号 
} q[51000];//询问 
int ans[51000];//存结果 
int i,j,n,m;
int t[301000];//树状数组 
int h[301000];
bool cmp(node aa,node bb)//关键字1：左端 关键字2：右端 
{
    if (aa.x==bb.x) return aa.y<bb.y;
    return aa.x<bb.x;
} 
void xg(int k,int p)//树状数组之 
{
    while (k<=n)
    {
        t[k]+=p;
        k+= k & -k;
    } 
} 
int qh(int k)
{
    int sum=0;
    while (k>=1)
    {
        sum+=t[k];
        k-= k & -k; 
    } 
    return sum;
}
int main()
{
    scanf("%d%d",&n,&m);
    for (i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
        h[i]=a[i];
    }
    sort(h+1,h+n+1);//h:排好序的数组 
    for (i=1;i<=m;i++)
    {
        scanf("%d%d%d",&q[i].x,&q[i].y,&q[i].k);
        q[i].d=i;
    }
    int he=1;int ta=0;
    sort(q+1,q+m+1,cmp);//排序
    for (i=1;i<=m;i++)
    {
        while (ta<q[i].y)//把之前没有加过的元素加到树状数组中 
        {
            ta++;
            xg(lower_bound(h+1,h+n+1,a[ta])-h,1);//同下 
        }
        while (he<q[i].x)//删去前面加过的元素 
        {
            xg(lower_bound(h+1,h+n+1,a[he])-h,-1);
            //lower_bound(h+1,h+n+1,a[he])-h：找h[1]~h[ht]中第一个>=a[ta]的h[i]的下标i 
            he++;
        }
        int l=1;
        int r=n;
        int mid;
        while (l<r)//二分找第k小数 
        {
            mid=(l+r)>>1;
            if (qh(mid)>=q[i].k) r=mid; else l=mid+1;
        }
        ans[q[i].d]=h[l]; 
    } 
    for (i=1;i<=m;i++) printf("%d\n",ans[i]);
    return 0;
}
```
还有一个treap的解法
    
    

```cpp
//treap版 
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<string>
#include<vector>
#include<algorithm>
#include<map>
#include<set>
#include<list>
#include<cstdlib>
#define For(i,a,b)for(i=(int)a;i<=int(b);++i)
#define nu NULL
using namespace std;
//--------------------------------------------------------------
struct node
{
    node* ch[2];//0:左子树 1:右子树
    int s;//存节点个数
    int v;//存值
    int w;//随机优先级 
    node()//初始化 
    {
        s=1;
        v=0;
        w=rand();
        ch[0]=NULL;
        ch[1]=NULL;
    } 
};
node* root; 
struct node1
{
    int x,y,k,d;//d: 编号 
} q[50010];
int n,m,k;//j:循环控制变量
int ans[50010];//存结果
int a[300000];//存原数组 
bool cmp(node1 aa,node1 bb)//q：排序用 
{
    if (aa.x==bb.x) return aa.y<bb.y;
    return aa.x<bb.x;
} 
//--------------------------------------------------------------
void maintain(node* &u)//修改节点个数 
{
    u->s=1;//自己也算QAQ 
    if (u->ch[0]!=NULL) u->s+=u->ch[0]->s;//加上左子树的节点数 
    if (u->ch[1]!=NULL) u->s+=u->ch[1]->s;//加上右子树的节点数 
}
void turn(node* &u,int d)//d:0左旋，1：右旋 
{
    node* k=u->ch[d^1];//挖出右子树 
    u->ch[d^1]=k->ch[d];//右子树的左子树变成当前根节点的右子树 
    k->ch[d]=u;//原本右子树的根节点作为整个树的根节点，左子树变成原本的那棵树 
    maintain(u);//重新统计节点个数 ,先把树的左子树的统计了，才能统计整个树的 
    maintain(k);//统计 
    u=k;//传过去 
}
void ins(node* &u,int x)//把x插到树u中去
{
    if (u==NULL)
    {
        u=new node;//建树 
        u->v=x; 
    } else
    {
        int d=x < u->v ? 0:1;
        ins(u->ch[d],x);//根据大小插入到对应子树（左子树/右子树 
        if (u->ch[d]->w > u->w) turn(u,d^1);//左子树的w大于父节点的w就右旋
        //另一个子树其实可以不用管因为没有修改  
    }
    maintain(u);//然后又要更新QAQ 
}
void remove(node* &u,int x)
{
    if (u->v==x)//找到要删除的点了
    {
        if (u->ch[0]!=NULL && u->ch[1]!=NULL)//有左右子树
        {
            int d=u->ch[0]->w >u->ch[1]->w ? 1:0; //左子树的W大于右子树的W 右旋 
            turn(u,d);//左旋/右旋 
            remove(u->ch[d],x);// 然后旋的哪个方向就扫那边的子树，例如：右旋之后，在右子树中扫x 
        } 
        else if (u->ch[0]==NULL)//左子树为空直接删去，拿右子树补上 
             u=u->ch[1]; 
             else u=u->ch[0];
    } 
    else
    {
        if (x<u->v) remove (u->ch[0],x);//x小于u->v 扫左子树 
        else remove(u->ch[1],x); //否则扫右子树 
    } 
    if (u!=NULL) maintain(u);//更新节点个数，这个经常要改 QAQ 
} 
int sum(node* u,int k)
{
    if (u==NULL||k > u->s||k<=0) return 0;//k<0或者k比节点个数还大，肯定会出事 
    int ss=0;
    if (u->ch[0]!=NULL) ss=u->ch[0]->s;//求左子树节点个数 
    if (k==ss+1) return u->v;//比k小的数 刚好等于k-1，返回值 
    if (k<=ss)return sum(u->ch[0],k);//比k小的数>k-1搜左子树 
    else  return (sum(u->ch[1],k-ss-1));//比k小的数<k，搜右子树 
}
int read()//读入优化 
{
    int x=0,flag=1;
    char a=getchar();
    while (a<'0'||a>'9')
    {
        if (a=='-') flag=-1;
        a=getchar();
    }
    while (a>='0'&&a<='9') 
    {
        x=x*10+(a-'0');
        a=getchar();
    }
    return x*flag;
} 
//-------------------------------------------------------------- 
int main()
{
//    freopen("1.in","r",stdin);
//    freopen("1.out","w",stdout);
    int i,j;
    srand(937);//似乎937快些QAQ
    n=read();
    m=read();
    for (i=1;i<=n;i++)
    a[i]=read();//读入每个数
    for (i=1;i<=m;i++)
    {
        q[i].x=read();
        q[i].y=read();
        q[i].k=read();
        q[i].d=i;
    }
    sort(q+1,q+m+1,cmp);//排序，第一关键字：x，第二关键字：y  
//    for (i=1;i<=n;i++) printf("%d ",a[i]);
//    puts("");
//    for (i=1;i<=m;i++) printf("233-%d %d %d %d\n",q[i].x,q[i].y,q[i].k,q[i].d);
//    puts(""); 
    int he=1,ta=0;
    for (i=1;i<=m;i++) 
    {
        while (ta<q[i].y)
        {
            ta++;
            ins(root,a[ta]);//y前面没加到treap里的全都加上去 
        }
        while (he<q[i].x)
        {
            remove(root,a[he]);//删去x前面的 
            he++;
        }
        ans[q[i].d]=sum(root,q[i].k);//求和 
    }
/*    int t;
    For(i,q[1].x,q[1].y)ins(root,a[i]);//把a[i]加到树中 
    ans[q[1].d]=sum(root,q[1].k);//求解 
    // int t;
    For(k,2,m)
    {
        t=min(q[k-1].y,q[k].x-1);
        For(i,q[k-1].x,t)remove(root,a[i]);//删去q[k].x前面的点 
        t=max(q[k-1].y+1,q[k].x);
        For(i,t,q[k].y)ins(root,a[i]);//增加该段没有加进去的点 
        ans[q[k].d]=sum(root,q[k].k);//求解 
    }*/
    for (i=1;i<=m;i++) printf("%d\n",ans[i]); 
    return 0;
}
```

---

## 作者：henry_y (赞：3)

[同步于我的blogs](https://www.cnblogs.com/henry-1202/p/10090698.html)

## $fhq\ treap$做法

没人写$fhq\ treap$做法，那我就补一篇qwq

看到这题第一时间想主席树，然后发现我还没学主席树，于是就写了平衡树做法（当然树状数组+二分的套路也是可以的，但是两个$log$的复杂度太优秀了就不写了）

其实和treap的写法差不多，也是排序一遍然后插入，删除，求$kth$

不过好写很多，主体就40+行，注意一开始那个节点的值一定要大...

我开$0x3f$然后挂了一个上午...

（其实一开始还写了莫队来着但是发现不需要）

```cpp
#include <bits/stdc++.h>

#define ll long long
#define inf 0x7fffffff
#define il inline

namespace io {

    #define in(a) a=read()
    #define out(a) write(a)
    #define outn(a) out(a),putchar('\n')

    #define I_int int
    inline I_int read() {
        I_int x = 0 , f = 1 ; char c = getchar() ;
        while( c < '0' || c > '9' ) { if( c == '-' ) f = -1 ; c = getchar() ; }
        while( c >= '0' && c <= '9' ) { x = x * 10 + c - '0' ; c = getchar() ; }
        return x * f ;
    }
    char F[ 200 ] ;
    inline void write( I_int x ) {
        if( x == 0 ) { putchar( '0' ) ; return ; }
        I_int tmp = x > 0 ? x : -x ;
        if( x < 0 ) putchar( '-' ) ;
        int cnt = 0 ;
        while( tmp > 0 ) {
            F[ cnt ++ ] = tmp % 10 + '0' ;
            tmp /= 10 ;
        }
        while( cnt > 0 ) putchar( F[ -- cnt ] ) ;
    }
    #undef I_int

}
using namespace io ;

using namespace std ;

#define N 300010
#define int long long 

int n , tot = 0, root = 1; 

//fhq-treap
struct fhq_treap {
    int siz , val , lc , rc , rnk ;
} t[N] ;
void pushup(int rt) {t[rt].siz = t[t[rt].lc].siz + t[t[rt].rc].siz + 1 ;}
void split(int &a , int &b , int val , int rt) {
    if(!rt) { a = b = 0 ; return ; }
    if(t[rt].val <= val) a = rt , split(t[a].rc , b , val , t[rt].rc) ;
    else b = rt , split(a , t[b].lc , val , t[rt].lc) ;
    pushup(rt) ;
}
void merge(int a , int b , int &rt) {
    if(!a || !b) {rt = a + b ; return ;}
    if(t[a].rnk < t[b].rnk) rt = a , merge(t[a].rc , b , t[rt].rc) ;
    else rt = b , merge(a , t[b].lc , t[rt].lc) ;
    pushup(rt) ;
} 
int new_node(int val) {
    t[++tot] = (fhq_treap) {1 , val , 0 , 0 , rand()} ;
    return tot ;
}
inline void insert(int val) {
    int x = 0 , y = 0 , z = new_node(val) ;
    split(x , y , val , root) ;
    merge(x , z , x) ; merge(x , y , root) ;
}
void Del(int val) {
    int x = 0 , y = 0 , z = 0 ;
    split(x , y , val , root) ; split(x , z , val - 1 , x) ;
    merge(t[z].lc , t[z].rc , z) ; merge(x , z , x) ; merge(x , y , root) ;
}
inline int find_val(int rnk , int rt) {
	while(t[t[rt].lc].siz + 1 != rnk) {
		if(t[t[rt].lc].siz >= rnk) rt = t[rt].lc ;
		else rnk -= t[t[rt].lc].siz + 1 , rt = t[rt].rc ;
	}
	return t[rt].val ;
}
//fhq-treap end

struct query {
    int l , r , val , id;
} q[N] ;
int ans[N] , a[N] , block ;

bool cmp(query a , query b) {
    return a.l == b.l ? a.r < b.r : a.l < b.l ;
}

signed main() {
#ifndef ONLINE_JUDGE
    freopen("1.in","r",stdin);
    freopen("1.out","w",stdout);
#endif
    srand((unsigned)time(0)) ;
    n = read() ; int m = read() ;
    new_node(inf) ; t[1].siz = 0 ;
    for(int i = 1 ; i <= n ; i ++) a[i] = read() ;
    for(int i = 1 ; i <= m ; i ++) q[i] = (query) {read() , read() , read() , i} ;
    block = sqrt(n) ; sort(q + 1 , q + m + 1 , cmp) ;
    q[0].l = 1 ;
    for(int i = 1 ; i <= m ; i ++) {
        for(int cur = q[i-1].r + 1 ; cur <= q[i].r ; cur ++) insert(a[cur]) ;
        for(int cur = q[i-1].l ; cur < q[i].l ; cur ++) Del(a[cur]) ;
        ans[q[i].id] = find_val(q[i].val , root) ;
    }
    for(int i = 1 ; i <= m ; i ++) outn(ans[i]) ;
}
```

---

## 作者：rediserver (赞：2)

# P1533 可怜的狗狗

[原体地址](https://www.luogu.com.cn/problem/P1533)  
[Github题解](https://github.com/jerrykcode/luogu)  
这道题2019年12月31号晚上写完，但是有段错误，直到2020年1月2号中午才调式完并且AC.  
21世纪20年代我写的首篇题解，希望通过QAQ  
## 思路

离线+SBT平衡树  
查询排名第k的元素，可以使用根据结点数量维护平衡的SBT平衡树。  

首先对区间排序，  
把第一个区间的元素插入SBT，计算第k小的元素  
然后保留第一个区间与第二个区间的交集，  
删除第一个区间有而第二个区间没有的元素，  
插入第二个区间有而第一个区间没有的元素。  
此时SBT中存储的就是第二个区间的元素啦，然后计算第k小的元素。  
若两个区间没有交集，那么就相当于删除第一个区间的所有元素，然后插入第二个区间的所有元素。  
以此类推第3个，第4个，第5个区间...  
因为区间排序过，且区间无相互包含，所以每个元素最多被插入一次，删除一次。  
  
在每个区间中，第k小的元素，有k-1个元素小于它。  
那么在SBT中递归查询就可以啦。  
实现一个函数，在SBT中查询有k个元素小于它的元素(给这个函数传入k-1即可)  
从根结点开始，若k正好等于左子树的size，那么说明正好有k个元素小于根结点，也就是说根结点就是要找的元素。  
若k小于左子树的size，那么待查询结点一定小于根结点，则递归查找左子树中有k个结点小于它的元素。  
若k大于左子树的size，那么待查询结点一定大于根结点，并且在右子树中还有 k - 左子树的size - 1个结点小于它(-1是因为根结点也小于它)，  
那么递归查找右子树中有 k - 左子树的size - 1个元素小于它的元素。    
(若左子树不存在，左子树的size就是0)  
## 代码

```cpp
#include <cstdio>
#include <cstdlib>
#include <algorithm>
using namespace std;

template<typename T>
class SBT {
public:
	void insert(T key);
	void remove(T key);
	T rank(int k);

	SBT() : tree_(NULL) {}
	~SBT() {
		deleteTree(tree_);
	}
	
private:
	typedef struct TNode {
		T key;
		int size;
		struct TNode *left, *right;
		TNode(T key) : key(key), size(1), left(NULL), right(NULL) {}
	} *Tree;

	int getSize(Tree t) { return t ? t->size : 0; }

	Tree leftRotate(Tree t);
	Tree rightRotate(Tree t);
	Tree maintain(Tree t);
	Tree maintainLeft(Tree t);
	Tree maintainRight(Tree t);
	Tree insert(Tree t, T key);
	Tree remove(Tree t, T key);
	T rank(Tree t, int k);
	void deleteTree(Tree t);

private:
	Tree tree_;
};

struct Query {
	int start, end;
	int k;
	int index;
	static bool compare(Query a, Query b) {
		return a.start < b.start;
	}
};

int main() {
	int n, m;
	scanf("%d %d", &n, &m);
	int * arr = new int[n];
	Query * queries = new Query[m];
	for (int i = 0; i < n; i++)
		scanf("%d", arr + i);
	int l, r, k;
	for (int i = 0; i < m; i++) {
		scanf("%d %d %d", &l, &r, &k);
		l--; r--; k--; //l和r减一是为了让下标从0开始，k减一是因为SBT中查询排名第k的元素，也是从0开始排名的。从1开始当然也可以，但我的恶习是从0开始qwq
		queries[i].start = l;
		queries[i].end = r;
		queries[i].k = k;
		queries[i].index = i;
	}
	sort(queries, queries + m, Query::compare);
	int * ans = new int[m];
	SBT<int> sbt;
	int start = 0, end = 0;
	sbt.insert(arr[0]); //初始化
	for (int i = 0; i < m; i++) {
		//start和end表示上一个区间的起止位置
		//queries[i].start和queries[i].end是现在要的区间起止位置
		//for循环外的初始化相当于在最开始增加了[0, 0]区间，目的是为了让代码容易写一点(好像也不一定欸)
		for (int j = start; j <= min(end, queries[i].start - 1); j++) //删除掉上一个区间有而本区间没有的元素，注意这个min可以使得代码在两个区间有无相交的情况下都正常运行
			sbt.remove(arr[j]);
		for (int j = max(end + 1, queries[i].start); j <= queries[i].end; j++) //插入本区有而上一个区间没有的元素，同样注意max
			sbt.insert(arr[j]);
		//至此，SBT中存储的已经是本区间元素了
		start = queries[i].start;
		end = queries[i].end;
		ans[queries[i].index] = sbt.rank(queries[i].k); //查询
	}
	free(arr);
	free(queries);	
	for (int i = 0; i < m; i++)
		printf("%d\n", ans[i]);
	free(ans);
	return 0;
}


//下面都是实现SBT的冗长代码
template<typename T>
void SBT<T>::insert(T key) {
	tree_ = insert(tree_, key);
}

template<typename T>
void SBT<T>::remove(T key) {
	tree_ = remove(tree_, key);
}

template<typename T>
T SBT<T>::rank(int k) {
	return rank(tree_, k);
}

template<typename T>
typename SBT<T>::Tree SBT<T>::leftRotate(SBT<T>::Tree t) {
	Tree k = t->right;
	t->right = k->left;
	k->left = t;
	k->size = t->size;
	t->size = getSize(t->left) + getSize(t->right) + 1;
	return k;
}

template<typename T>
typename SBT<T>::Tree SBT<T>::rightRotate(SBT<T>::Tree t) {
	Tree k = t->left;
	t->left = k->right;
	k->right = t;
	k->size = t->size;
	t->size = getSize(t->left) + getSize(t->right) + 1;
	return k;
}

template<typename T>
typename SBT<T>::Tree SBT<T>::maintain(SBT<T>::Tree t) {
	t = maintainLeft(t);
	return maintainRight(t);	
}

template<typename T>
typename SBT<T>::Tree SBT<T>::maintainLeft(SBT<T>::Tree t) {
	if (t == NULL || t->left == NULL) return t;
	if (t->left->left && t->left->left->size > getSize(t->right)) {
		t = rightRotate(t);
		t->right = maintain(t->right);
		t = maintain(t);
	}
	else if (t->left->right && t->left->right->size > getSize(t->right)) {
		t->left = leftRotate(t->left);
		t = rightRotate(t);
		t->left = maintain(t->left);
		t->right = maintain(t->right);
		t = maintain(t);
	}
	return t;
}

template<typename T>
typename SBT<T>::Tree SBT<T>::maintainRight(SBT<T>::Tree t) {
	if (t == NULL || t->right == NULL) return t;
	if (t->right->right && t->right->right->size > getSize(t->left)) {
		t = leftRotate(t);
		t->left = maintain(t->left);
		t = maintain(t);
	}
	else if (t->right->left && t->right->left->size > getSize(t->left)) {
		t->right = rightRotate(t->right);
		t = leftRotate(t);
		t->left = maintain(t->left);
		t->right = maintain(t->right);
		t = maintain(t);
	}
	return t;
}

template<typename T>
typename SBT<T>::Tree SBT<T>::insert(SBT<T>::Tree t, T key) {
	if (t == NULL) {
		return new TNode(key);
	}
	t->size++;
	if (key < t->key) {
		t->left = insert(t->left, key);
		t = maintainLeft(t);
	}
	else {
		t->right = insert(t->right, key);
		t = maintainRight(t);
	}
	return t;
}


template<typename T>
typename SBT<T>::Tree SBT<T>::remove(SBT<T>::Tree t, T key) {
	// (t == NULL) return NULL;
	t->size--;
	if (key == t->key){
		if (t->left && t->right) {
			if (t->left->size > t->right->size) {
				Tree left_max = t->left;
				while (left_max->right) {
					left_max = left_max->right;
				}
				t->key = left_max->key;
				t->left = remove(t->left, left_max->key);
				t = maintainRight(t);
			}
			else {
				Tree right_min = t->right;
				while (right_min->left) {
					right_min = right_min->left;
				}
				t->key = right_min->key;
				t->right = remove(t->right, right_min->key);
				t = maintainLeft(t);
			}
		}
		else {
			Tree tmp = t;
			t = t->left ? t->left : t->right;
			delete tmp;
		}
	}
	else if (key < t->key) {
		t->left = remove(t->left, key);
		t = maintainRight(t);
	}
	else {
		t->right = remove(t->right, key);
		t = maintainLeft(t);
	}
	return t;
}


//从0开始排名，好处是排名k的意思就是有k个元素小于它，从1开始排名那就是k-1了。。
template<typename T>
T SBT<T>::rank(SBT<T>::Tree t, int k) {
	//if (t == NULL) return 0xffffffff;
	int left_size = getSize(t->left);
	if (k == left_size) {
		return t->key;
	}
	else if (k < left_size) {
		return rank(t->left, k);
	}
	else {
		return rank(t->right, k - left_size - 1);
	}
}

template<typename T>
void SBT<T>::deleteTree(SBT<T>::Tree t) {
	if (t == NULL) {
		return;
	}
	deleteTree(t->left);
	deleteTree(t->right);
	delete t;
}

```


---

## 作者：LordLeft (赞：2)

这道题目要求还是比较简单，只要求一个区间第$K$大

说到区间第$K$大，我们自然就想到了~~主席树~~划分树

划分树是一种专门(也只能)求解区间第$K$大的数据结构，和线段树类似，每个节点是一条长线段，左右儿子就是当前节点小于等于区间中位数的数和大于等于区间中位数的数

这样建树之后，我们可以用类似二叉查找树的方式查询区间第$K$大，因为按照上面的方式建好树之后，每个左儿子相对于右儿子是有序的，我们可以利用这个性质来缩小查询区间，和差分差不多

区间中位数有一个简单的技巧，把原序列排序后，中间的值就对应区间中位数

更具体的内容可以[看这里](https://www.luogu.org/blog/LordLeft-PHUCC/leng-men-shuo-ju-jie-gou-qian-tan-hua-fen-shu)

```cpp
#include<iostream>
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>
using namespace std;
int read(){
	int w=0;
	bool s=0;
	char c=getchar();
	while(!isdigit(c)){
		s=(c=='-');
		c=getchar();
	}
	while(isdigit(c)){
		w=w*10+c-'0';
		c=getchar();
	}
	return s?-w:w;
}
const int N=300005,M=20;
int n,m;
struct Tree{
	#define mid ((le+ri)>>1)
	#define lson le,mid,dep+1
	#define rson mid+1,ri,dep+1
	struct Node{
		int num[N],toleft[N];
	};
	Node t[M];
	int sorted[N];
	void build(int le,int ri,int dep){
		if(le==ri){
			return;
		}
		int key=sorted[mid];
		int equ=mid-le+1;
		for(int i=le;i<=ri;i++){
			if(t[dep].num[i]<key){
				equ--;
			}
		}
		int tl=0;
		int it1=le-1,it2=mid;
		for(int i=le;i<=ri;i++){
			int now=t[dep].num[i];
			if(now<key||(now==key&&equ)){
				if(now==key){
					equ--;
				}
				tl++;
				t[dep+1].num[++it1]=now;
			}
			else{
				t[dep+1].num[++it2]=now;
			}	
			t[dep].toleft[i]=tl;	
		}
		build(lson);
		build(rson);
	}
	int query(int le,int ri,int dep,int x,int y,int z){
		if(le==ri){
			return t[dep].num[le];
		}
		int tl=0,del=t[dep].toleft[y];	
		if(le!=x){
			tl=t[dep].toleft[x-1];
			del-=tl;
		}	
		int nx,ny;	
		if(del>=z){
			nx=le+tl;
			ny=nx+del-1;
			return query(lson,nx,ny,z);
		}
		else{	
			nx=mid+1+x-tl-le;
			ny=nx+y-x-del;
			return query(rson,nx,ny,z-del);
		}	
	}	
};
Tree T;
int main(){
	n=read(),m=read();
	for(int i=1;i<=n;i++){
		T.t[0].num[i]=read();
		T.sorted[i]=T.t[0].num[i];
	}
	sort(T.sorted+1,T.sorted+1+n);
	T.build(1,n,0);
	int x,y,z;
	for(int i=1;i<=m;i++){
		x=read(),y=read(),z=read();
		int ans=T.query(1,n,0,x,y,z);
		printf("%d\n",ans);
	}
	return 0;
}
```

---

## 作者：玫葵之蝶 (赞：2)

题解：

我第一感觉是：这不是主席树裸题吗？

然后：这用不着主席树吧。。。

Then：离线，然后vector暴力平衡树乱搞就好了呀！

打代码…………

然后愉快地交了上去，就只有90，TLE了一个点。

果然暴力平衡树还是过不了300000呀。

然后就搞出来我原来的Splay，贴了上去，信心满满地又交了一次。

60，2WA，2TLE，我就放弃了。

重新看这个题，我发现，我就可以搞权值线段树呀，以我自带的小常数，应该不会T的。

打代码………..

AC！
宣传一发blog：[玫葵之蝶的blog](http://blog.csdn.net/stone41123/article/details/78152563)

正题：

这个题可以离散化，还要离线下来，将询问区间按左端点排序，然后维护一段区间，不断移动左右端点，添加区间内的值，删除被排出区间外的值，每次不断移动直到与询问区间重合，统计答案，最后按顺序输出就好了。

（p.s：主席树其实就是好多棵权值线段树，我这个就是主席树的简化版，不过跑的快）

代码：

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstdlib>
#include<vector>
#define ll long long
using namespace std;
inline int read(){
    int x=0;char ch=' ';int f=1;
    while(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();
    if(ch=='-')f=-1,ch=getchar();
    while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();
    return x*f;
}
int n,m,size;
int a[300001];
struct block{
    int l,r,k,id;
    inline bool operator < (const block& y) const {
        return l<y.l;
    }
}b[50001];
int ans[50001];
int c[300001];
inline int Hash(int x){
    return lower_bound(c+1,c+size+1,x)-c;
}
int sum[300001<<2];
void update(int rt,int l,int r,int x,int v){
    if(l==r){
        sum[rt]+=v;
        return;
    }
    int mid=l+r>>1;
    if(x<=mid)update(rt<<1,l,mid,x,v);
    else update(rt<<1|1,mid+1,r,x,v);
    sum[rt]=sum[rt<<1]+sum[rt<<1|1];
}
int kth(int rt,int l,int r,int k){
    if(l==r)return c[l];
    int mid=l+r>>1;
    if(k<=sum[rt<<1])return kth(rt<<1,l,mid,k);
    else return kth(rt<<1|1,mid+1,r,k-sum[rt<<1]);
}
int main(){
    n=read();m=read();
    for(int i=1;i<=n;i++){
        a[i]=read();
        c[i]=a[i];
    }
    sort(c+1,c+n+1);
    size=unique(c+1,c+n+1)-c-1;
    
    for(int i=1;i<=m;i++){
        b[i].l=read();b[i].r=read();b[i].k=read();b[i].id=i;
    }
    sort(b+1,b+m+1);
    int l=1,r=0;
    for(int i=1;i<=m;i++){
        while(r<b[i].r){
            update(1,1,size,Hash(a[++r]),1);
        }
        while(l<b[i].l){
            update(1,1,size,Hash(a[l++]),-1);
        }
        ans[b[i].id]=kth(1,1,size,b[i].k);
    }
    for(int i=1;i<=m;i++){
        printf("%d\n",ans[i]);
    }
    return 0;
}
```

---

## 作者：奈芙莲 (赞：2)

这题不要求修改。。可以离线乱搞。。（最后一篇题解了吧。。）

先把所有询问读进来，按左端点排序。。离散化一下。。

用树状数组维护一下。。。下面的redbag dalao 应该说的很清楚了。。

我就贴代码好了。。还是有地方不一样的吧。。

主要是将原数组映射到了1~ n，再开一个数组保存原来的数字。这样每次更新的时候就不用二分了。。

```cpp
#include<cstdio>
#include<algorithm>
#define ri register int
#define fp(i,a,b) for(ri i=a,I=b;i<=I;++i)
#define file(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
using namespace std;
char ss[1<<17],*A=ss,*B=ss;
//#define gc getchar
inline char gc(){return A==B&&(B=(A=ss)+fread(ss,1,1<<17,stdin),A==B)?EOF:*A++;}
template<class T>inline void read(T&x){
    ri f=1,c;while(c=gc(),c<48||57<c)if(c=='-')f=-1;x=c^48;
    while(c=gc(),47<c&&c<58)x=(x<<3)+(x<<1)+(c^48);x*=f;
}
char sr[1<<20],z[20];int C=-1,Z;
template<class T>inline void wer(T x){
    if(x<0) sr[++C]='-',x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);sr[++C]='\n';
}
const int N=3e5+5,M=5e4+5;
int n,m,siz,a[N],c[N],ans[M],mp[N];
struct node{
    int l,r,k,id;
    inline bool operator<(const node&r)const{return l<r.l;}
}b[M];
//树状数组相关
int t[N];
inline void update(ri x,ri v){for(;x<=n;x+=x&-x)t[x]+=v;}
inline int  query(ri x){ri res=0;for(;x;x-=x&-x)res+=t[x];return res;} 
inline bool cmp(ri x,ri y){return a[x]<a[y];}
int main(){
    read(n);read(m);
    fp(i,1,n) read(a[i]),c[i]=i;
    sort(c+1,c+n+1,cmp);fp(i,1,n) mp[i]=a[c[i]],a[c[i]]=i;
    fp(i,1,m)read(b[i].l),read(b[i].r),read(b[i].k),b[i].id=i;
    sort(b+1,b+m+1);b[0].l=1,b[0].r=0;
    fp(i,1,m){
        fp(j,b[i-1].r+1,b[i].r) update(a[j],1);
        fp(j,b[i-1].l,b[i].l-1) update(a[j],-1);
        ri l = 1,r = n, mid;
        while(l < r){
            mid = l + r >> 1;
            if(query(mid) >= b[i].k) r = mid;
            else l = mid + 1; 
        }
        ans[b[i].id] = mp[l];
    }
    fp(i,1,m) wer(ans[i]);
    fwrite(sr,1,C+1,stdout);
}
```

---

## 作者：EternalEpic (赞：1)

提供一个好想的本题做法。用可持久化线段树维护。

看到静态第K小我很高兴，因为可以用主席树（可持久化sgt）做。

考虑将值域离散化，并用权值线段树维护，我们可以得到全局排名。

而可持久化后，root[pos]维护了一棵以序列中1~pos的数建立的权值线段树。

那么使用相减可以知道l~r中某个数的出现次数。

考虑同步遍历以root[l - 1]和root[r]为根的树。

如果左子树大小之差小于kth，则答案在左子树中，递归执行。

若大于等于kth，则kth -= sum[L[p]] - sum[L[q]]然后在右子树中递归。

若遍历到叶子节点，则为答案，可返回。

离散化：

```cpp
	read(n), read(m);
	for (int i = 1; i <= n; i++) read(a[i]), b[i] = a[i];
	sort(b + 1, b + n + 1); tot = unique(b + 1, b + n + 1) - (b + 1);
	T.build(root[0], 1, tot);
	for (int i = 1; i <= n; i++) {
		int tmp = lower_bound(b + 1, b + tot + 1, a[i] + 1) - (b + 1);
		T.update(root[i], root[i - 1], 1, tot, tmp);
	}
```


代码：

```cpp
int n, m, tot, a[Maxn], b[Maxn], root[Maxn];
struct PresidentTree {
	int sum[Maxn * 40], L[Maxn * 40], R[Maxn * 40], cnt;
	PresidentTree(void) { cnt = 0; Ms(sum, 0); }
	inline void build(int &pos, int l, int r) {
		pos = ++cnt; if (l == r) return; register int mid = l + r >> 1;
		build(L[pos], l, mid), build(R[pos], mid + 1, r);
	}
	
	inline void update(int &pos, int pre, int l, int r, int idx) {
		pos = ++cnt; L[pos] = L[pre], R[pos] = R[pre], sum[pos] = sum[pre] + 1;
		if (l == r) return; register int mid = l + r >> 1;
		if (idx <= mid) update(L[pos], L[pre], l, mid, idx);
		else update(R[pos], R[pre], mid + 1, r, idx);
	}
	
	inline int query(int p, int q, int l, int r, int kth) {
		if (l == r) return l;
		register int cnt = sum[L[p]] - sum[L[q]], mid = l + r >> 1;
		if (kth <= cnt) return query(L[p], L[q], l, mid, kth);
		else return query(R[p], R[q], mid + 1, r, kth - cnt);
	}
} T;
```

作者不易，希望支持！谢谢！



---

## 作者：Belongbb (赞：1)

说实话，这道题我用线段树的。。。

先要进行离散处理，用一个类似映射表的数组存出现过的值。

用线段树维护当前区间内的狗的漂亮值取第k小的


```delphi
type
  dd=record
     k,l,r,g:longint;
     end;

var
  que:array[1..50000] of dd;
  ans:array[1..50000] of longint;
  a,li:array[1..300000] of int64;
  f:array[1..1200000] of longint;
  i,j,n,m,maxai,t:longint;

procedure sort(l,r: longint);
      var
         i,j,x: longint;
         y:dd;
      begin
         i:=l;
         j:=r;
         x:=que[(l+r) div 2].l;
         repeat
           while que[i].l<x do
            inc(i);
           while x<que[j].l do
            dec(j);
           if not(i>j) then
             begin
                y:=que[i];
                que[i]:=que[j];
                que[j]:=y;
                inc(i);
                j:=j-1;
             end;
         until i>j;
         if l<j then
           sort(l,j);
         if i<r then
           sort(i,r);
      end;

procedure sort2(l,r: longint);
      var
         i,j:longint;
         x,y:int64;
      begin
         i:=l;
         j:=r;
         x:=li[(l+r) div 2];
         repeat
           while li[i]<x do
            inc(i);
           while x<li[j] do
            dec(j);
           if not(i>j) then
             begin
                y:=li[i];
                li[i]:=li[j];
                li[j]:=y;
                inc(i);
                j:=j-1;
             end;
         until i>j;
         if l<j then
           sort2(l,j);
         if i<r then
           sort2(i,r);
      end;

procedure add(t,l,r,x:longint);
var
  mid:longint;
begin
  inc(f[t]);
  if l=r then exit;
  mid:=(l+r) div 2;
  if x<=li[mid] then add(t*2,l,mid,x)
                else add(t*2+1,mid+1,r,x);
end;

procedure search(t,l,r,k,num:longint);
var
  mid:longint;
begin
  if l=r then
    begin
    ans[que[num].g]:=li[l];
    exit;
    end;
  mid:=(l+r) div 2;
  if k<=f[t*2] then search(t*2,l,mid,k,num)
               else search(t*2+1,mid+1,r,k-f[t*2],num);
end;

procedure del(t,l,r,x:longint);
var
  mid:longint;
begin
  dec(f[t]);
  if l=r then exit;
  mid:=(l+r) div 2;
  if x<=li[mid] then del(t*2,l,mid,x)
                else del(t*2+1,mid+1,r,x);
end;

begin
  readln(n,m);
  maxai:=0;
  for i:=1 to n do
    begin
    read(a[i]);
    li[i]:=a[i];
    end;
  sort2(1,n);
  maxai:=1;
  for i:=2 to n do
    if li[i]<>li[i-1] then begin inc(maxai);li[maxai]:=li[i];end;{离散处理}
  readln;
  for i:=1 to m do
    begin
    readln(que[i].l,que[i].r,que[i].k);
    que[i].g:=i;
    end;
  sort(1,m);
  fillchar(f,sizeof(f),0);
  for i:=que[1].l to que[1].r do add(1,1,maxai,a[i]);
  i:=1;
  search(1,1,maxai,que[1].k,1);
  for i:=2 to m do
    begin
    for j:=que[i-1].r+1 to que[i].r do add(1,1,maxai,a[j]);
    for j:=que[i-1].l to que[i].l-1 do del(1,1,maxai,a[j]);
    search(1,1,maxai,que[i].k,i);
    end;
  for i:=1 to m do
    writeln(ans[i]);
end.
```

[color=red]就这样，我还水了很久。。。[/color]


---

## 作者：Y_B_Y (赞：0)

对于我这个刚学完**莫队+用树状数组实现的平衡树**的蒟蒻来说,第一个想到的解法就是它门俩了,恰好这一题对这个做法的复杂度很友好.

![](https://cdn.luogu.com.cn/upload/image_hosting/34a0v1d4.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/rrro11x9.png)

如果还没学过莫队的可以通过[一只小兵大佬的题解](https://www.luogu.com.cn/blog/I-O-I/solution-p2709)了解莫队的基本原理,然后再通过[zcy大佬比较精简的代码](https://www.luogu.com.cn/blog/zcysky/solution-p2709)来作为模板(两篇题解所属[题目](https://www.luogu.com.cn/problem/P2709)),~~反正我就是这么学的~~

如果没学过平衡树的可以通过[songhn大佬的题解](https://songhn.blog.luogu.org/solution-p3369)学习树状数组实现的平衡树

然后来讲讲思路.由于莫队可以**维护一段区间**,而平衡树可以**快速求出区间中第k小的数**.
所以我们可以在莫队维护区间时将**进入区间的数加入平衡树中**,把**出区间的数从平衡树中删除**,再将得出数存入用于输出的数组中(因为莫队会打乱顺序,所以我们要在存题目给的区间的结构体中存号序号),最后一起输出就可以了

细节看代码吧,几乎就是把两个模板拼在一起

### 上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+5;
int n,opt[N],a[N],l[N],tr[N],tot,sz,ot[N];
inline int read()
{
    char c=getchar();int sum=0,f=1;
    while(!(c>='0'&&c<='9')) {if(c=='-') f=-1;c=getchar();}
    while(c>='0'&&c<='9') {sum=((sum<<1)+(sum<<3))+(c-'0');c=getchar();}
    return sum*f;
}
int lb(int x){return x&(-x);}//lowbit
void add(int w,int x)//线段树的add操作
{
	for(int i=w;i<=tot;i+=lb(i))
	{
		tr[i]+=x;
	}
}
int pm(int x)//求第x小
{
	int t=0;
	for(int i=19;i>=0;i--)
	{
		t+=1<<i;
		if(t>tot||tr[t]>=x) t-=1<<i;
		else x-=tr[t];
	}	
	return l[t+1];
}
int gt(int x){return lower_bound(l+1,l+tot+1,x)-l;}//离散化
struct hh
{
	int l,r,id,k;
	int qj;
}q[N];//存题目给的区间
int cmp(hh s1,hh s2)
{
	if(s1.qj==s2.qj) return s1.r<s2.r;
	else return s1.qj<s2.qj;
}//莫队的排序需要
int main()
{
	n=read();int m=read();
	for(int i=1;i<=n;i++) a[i]=read(),l[++tot]=a[i];//l用于离散化(树状数组实现的平衡树需要)
	sort(l+1,l+tot+1);//用于离散化的排序
	tot=unique(l+1,l+tot+1)-l-1;//离散化
	int sz=(int)sqrt(n);//莫队的操作
	for(int i=1;i<=m;i++)//输入区间
	{
		q[i].l=read();q[i].r=read();q[i].k=read();
		q[i].id=i;//存序号
		q[i].qj=((q[i].l-1)/sz)+1;//莫队的操作
	}
	sort(q+1,q+m+1,cmp);//莫队的排序
	int l=1,r=0;//莫队需要的一些变量,l表示区间左端点,r反之
	for(int i=1;i<=m;i++)//莫队+平衡树
	{
		while(l>q[i].l) l--,add(gt(a[l]),1);//加入平衡树
		while(l<q[i].l) add(gt(a[l]),-1),l++;//删除
		while(r<q[i].r) r++,add(gt(a[r]),1);//加入
		while(r>q[i].r) add(gt(a[r]),-1),r--;//删除
	    ot[q[i].id]=pm(q[i].k);//存答案
	}
	for(int i=1;i<=m;i++) cout<<ot[i]<<'\n';//输出
	return 0;//完美结束
}
```


---

## 作者：嚯呀嚯呀 (赞：0)

**莫队+treap**

算是对之前学的一个复习吧

不会莫队或平衡树的同学可以先去看看[洛谷P3369](https://www.luogu.org/problemnew/show/P3369)和[洛谷P3901](https://www.luogu.org/problemnew/show/P3901)

**这里写一下对于莫队的自己的一些理解**

就是莫队(while)的时候，4个指针移动的顺序，应该是先写从里向外的扩展，然后再写从外向里的

#### 什么意思呢？
**就是先默认你现在处理的范围比你要求的范围小，扩展再写缩小的范围**

这对后面的问题处理没有影响，但是对第1个问题的求解有影响

因为我们一开始l=1 r=0;我们的第一个问题是[2,4],如果我们先缩小范围，再扩大范围的话，会误把1这个位置的元素删去

### 应该没有想错吧，如果写错了dalao私信指导我一下吧

然后就是平衡树的三种基本操作了：插入，删除，找第k大

**Code:(Pascal)：**
```
var
  root,sizen,ll,rr:longint;
  block,i,j,m,n,k,p:longint;
  a,rnd,v,w,l,r,size:array[0..1000005]of longint;
  x,y,num,ans,z:array[0..50005]of longint;
procedure qs(l,r:longint);
var
  i,j,mid1,mid2,a1:longint;
begin
  i:=l; j:=r;
  mid1:=x[(l+r) div 2]; mid2:=y[(l+r) div 2];
  repeat
    if i div block=j div block then
      begin
        while x[i]<mid1 do inc(i);
        while x[j]>mid1 do dec(j);
        if not(i>j) then
          begin
            a1:=x[i]; x[i]:=x[j]; x[j]:=a1;
            a1:=y[i]; y[i]:=y[j]; y[j]:=a1;
            a1:=z[i]; z[i]:=z[j]; z[j]:=a1;
            a1:=num[i]; num[i]:=num[j]; num[j]:=a1;
            inc(i); dec(j);
          end;
      end
    else
      begin
        while y[i]<mid2 do inc(i);
        while y[j]>mid2 do dec(j);
        if not(i>j) then
          begin
            a1:=x[i]; x[i]:=x[j]; x[j]:=a1;
            a1:=y[i]; y[i]:=y[j]; y[j]:=a1;
            a1:=z[i]; z[i]:=z[j]; z[j]:=a1;
            a1:=num[i]; num[i]:=num[j]; num[j]:=a1;
            inc(i); dec(j);
          end;
      end;
  until i>j;
  if i<r then qs(i,r);
  if l<j then qs(l,j);
end;
procedure update(k:longint);
begin
  size[k]:=size[l[k]]+size[r[k]]+w[k];
end;
procedure rturn(var k:longint);
var
  child:longint;
begin
  child:=l[k]; l[k]:=r[child]; r[child]:=k;
  size[child]:=size[k]; update(k); k:=child;
end;
procedure lturn(var k:longint);
var
  child:longint;
begin
  child:=r[k]; r[k]:=l[child]; l[child]:=k;
  size[child]:=size[k]; update(k); k:=child;
end;
procedure put(var k:longint; x:longint);
begin
  if k=0 then
    begin
      inc(sizen); k:=sizen;
      rnd[k]:=random(20*n+5); w[k]:=1;
      v[k]:=x; size[k]:=1;
      exit;
    end;
  inc(size[k]);
  if x=v[k] then inc(w[k])
  else
    if x>v[k] then
      begin
        put(r[k],x);
        if rnd[r[k]]<rnd[k] then lturn(k);
      end
    else
      begin
        put(l[k],x);
        if rnd[l[k]]<rnd[k] then rturn(k);
      end;
end;
procedure delete(var k:longint; x:longint);
begin
  if k=0 then exit;
  if v[k]=x then
    begin
      if w[k]>1 then
        begin dec(size[k]); dec(w[k]); exit; end;
      if l[k]*r[k]=0 then
        k:=l[k]+r[k]
      else
        begin
          if rnd[l[k]]<rnd[r[k]] then
            begin rturn(k); delete(k,x); end
          else
            begin lturn(k); delete(k,x); end;
        end;
    end
  else
    begin
      if x>v[k] then
        begin dec(size[k]); delete(r[k],x); end
      else
        begin dec(size[k]); delete(l[k],x); end;
    end;
end;
function get(k,x:longint):longint;
begin
  if x<=size[l[k]] then
    exit(get(l[k],x))
  else
    if x>size[l[k]]+w[k] then
      exit(get(r[k],x-size[l[k]]-w[k]))
  else
    exit(v[k]);
end;
begin
  randomize;
  readln(n,m);
  block:=trunc(sqrt(n));
  for i:=1 to n do
    read(a[i]);
  readln;
  for i:=1 to m do
    begin
      readln(x[i],y[i],z[i]);
      num[i]:=i;
    end;
  qs(1,m);
  ll:=1; rr:=0;
  for i:=1 to m do
    begin
      while ll>x[i] do
        begin
          dec(ll); put(root,a[ll]);
        end;
      while rr<y[i] do
        begin
          inc(rr); put(root,a[rr]);
        end;
      while ll<x[i] do
        begin
         delete(root,a[ll]); inc(ll);
        end;
      while rr>y[i] do
        begin
          delete(root,a[rr]); dec(rr);
        end;
      ans[num[i]]:=get(root,z[i]);
    end;
  for i:=1 to m do
    writeln(ans[i]);
end.

```

---

## 作者：I_AM_HelloWord (赞：0)

静态主席树的题目大多可以用离线+线段树+二分搞一搞。

但是，这么明显的主席树模板题，更P3834一毛一样。

[主席树详解传送门。](http://blog.csdn.net/no1\_terminator/article/details/77601599)

这里就简单的讲一下主席树吧。

就是把a[1]...a[i]一次插入以第i个节点区间[1..n]为根的线段树中去，那么区间[i..j]中某个数的出现次数就可以用sum[j]-sum[i]搞一搞就行了，

如果直接建n个线段树，会需要O(n^2logn),

我们再考虑从i转移到i+1时只是插入了一个点，结合线段树的点修改知识，我们知道这次插入只是影响了logn个点，所以其他的直接用指针传递，不需要新建了。有时间再学学Treap吧。。


参考代码：

```cpp
#include<cstdio>
#include<algorithm>
const int N=3e5+5;
const int M=N*21;
using namespace std;
struct President_Tree{
    int sum,L,R;
}T[M];
int n,m,totn=0,T_cnt=1;
int root[N],b[N],a[N];
int read(){
    int x=0,f=1;char ch=getchar();
    while (ch<'0' || ch>'9'){if (ch=='-')f=-1;ch=getchar();}
    while ('0'<=ch && ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return x*f;
}
void insert(int &now,int x,int l=1,int r=totn){
    T[T_cnt++]=T[now];now=T_cnt-1;
    T[now].sum++;
    if (l==r)return;
    int mid=(l+r)>>1;
    if (x<=mid)insert(T[now].L,x,l,mid);
        else insert(T[now].R,x,mid+1,r);
}
int query(int i,int j,int k,int l=1,int r=totn){
    if (l==r)return l;
    int mid=(l+r)>>1,t=T[T[j].L].sum-T[T[i].L].sum;
    if (k<=t)return query(T[i].L,T[j].L,k,l,mid);
        else return query(T[i].R,T[j].R,k-t,mid+1,r);
}
int main(){
    n=read(),m=read();
    for (int i=1;i<=n;i++)
        b[i]=a[i]=read();
    sort(b+1,b+n+1);
    totn=unique(b+1,b+n+1)-b-1;
    root[0]=0;
    for (int i=1;i<=n;i++){
        root[i]=root[i-1];
        int rk=lower_bound(b+1,b+totn+1,a[i])-b;
        insert(root[i],rk);
    }
    for (int i=1;i<=m;i++){
        int ql=read(),qr=read(),k=read();
        printf("%d\n",b[query(root[ql-1],root[qr],k)]);
    }
    return 0;
}
```

---

## 作者：Log_x (赞：0)

##主席树解法

考虑这么一种解法：我们每次询问二分答案 ans ，然后求出区间中漂亮值小于等于 ans 的狗狗个数，进而可以判断真正的答案与 ans 的大小关系。那么现在只需考虑如何求出区间中小等于某个漂亮值的个数。

一种方式是每次将询问区间排序，然后二分求解。但由于有多次询问，所以不可能每次都排序一遍。

现在我们考虑能否预处理一些东西来求解。首先我们将所有数**离散化**。

考虑维护 n 棵权值线段树（也就是主席树），第 i 棵权值线段树维护的是位置区间 [1, i] 中小等于第 i 只狗漂亮值的狗狗个数，现在我们查询区间 [l, r] 内漂亮值小等于 ans 的狗狗个数，相当于我们分别查询第r棵权值线段树的 [1, ans] 这个区间内的狗狗个数 cnt1 ，以及第 l - 1 棵权值线段树的 [1, ans] 这个区间内的狗狗个数 cnt2 ，那么 cnt1 - cnt2 就是我们所要求的答案，这就相当于序列前缀和的用法。

进一步地，我们发现其实并不用真正地去二分，我们可以直接在权值线段树上“走”。

更具体的说，假设现在要求区间里的第 k 小漂亮值，我们分别记录目前在第 r 棵和第 l - 1 棵权值线段树的节点 u, v 上，当前节点代表的权值区间为 [L, R] 。根据权值线段树上每个节点所维护的区间内的狗狗个数 sum ，我们可以直接计算出位置区间 [l, r] 内，第 i 只狗的漂亮值落在权值区间 [L, (L+R) / 2] 内的个数 cnt = sum[lc[u]] - sum[lc[v]]，假如 cnt ≥ k ，则说明答案在左子树中，两个节点 u,v 都向左子树走；否则说明答案在右子树，且是右子树中的第 k-cnt  小漂亮值。我们可以递归下去求解。这个算法其实就是在权值线段树上二分。

最后附上**代码：**








```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
const int Maxn = 0x3f3f3f3f;
const int N = 3e5 + 5, M = N * 22; 
struct point
{
    int lc, rc, sum;
    #define l(x) tr[x].lc
    #define r(x) tr[x].rc
    #define s(x) tr[x].sum
}tr[M];
int a[N], b[N], rt[N], n, QAQ, m, T;
inline int get()
{
    char ch; bool f = false; int res = 0;
    while (((ch = getchar()) < '0' || ch > '9') && ch != '-');
    if (ch == '-') f = true;
     else res = ch - '0';
    while ((ch = getchar()) >='0' && ch <= '9')
        res = (res << 3) + (res << 1) + ch - '0';
    return f? ~res + 1 : res;
}
inline void put(int x)
{
    if (x < 0)
      x = ~x + 1, putchar('-');
    if (x > 9) put(x / 10);
    putchar(x % 10 + 48);
}
inline void Ins(const int y, int &x, const int l, const int r, const int vi)
{
    tr[x = ++T] = tr[y]; ++s(x);
    if (l == r) return ;
    int mid = l + r >> 1;
    if (vi <= mid) Ins(l(y), l(x), l, mid, vi);
     else Ins(r(y), r(x), mid + 1, r, vi);
}
inline int Que(const int x, const int y, const int l, const int r, const int k)
{
    if (l == r) return l;
    int Del = s(l(y)) - s(l(x)), mid = l + r >> 1;
    if (k <= Del) return Que(l(x), l(y), l, mid, k);
     else return Que(r(x), r(y), mid + 1, r, k - Del);
}
inline void Init()
{
    sort(b + 1, b + n + 1);
    m = unique(b + 1, b + n + 1) - b - 1;
    for (int i = 1; i <= n; ++i) 
     a[i] = lower_bound(b + 1, b + m + 1, a[i]) - b;
    l(0) = r(0) = s(0) = 0;
    for (int i = 1; i <= n; ++i)
     Ins(rt[i - 1], rt[i], 1, m, a[i]);
}
int main()
{
    n = m = get(); QAQ = get();
    for (int i = 1; i <= n; ++i) a[i] = b[i] = get();
    Init(); int u, v;
    while (QAQ--)
    {
        u = get(); v = get();
        put(b[Que(rt[u - 1], rt[v], 1, m, get())]), putchar('\n');
    }
    return 0;
}

```

---

## 作者：sxyzhml (赞：0)

离散，区间排序，然后把每一个区间与前一个重复的保留不重复的删去，再添加这个区间剩下不重复的一部分……每一次单独拎出来做，塞到树里……

```delphi
 
   for j:=z[i] to z[i-1]-1 do
   change(pos[j],1);
   for j:=y[i]+1 to y[i-1] do
 change(pos[j],-1);
  ans[num[i]]:=b[num[get(k[i])]];

```
```delphi

function get(tun:longint):longint;  
var i,now:longint;  
begin  
get:=0; 
 now:=0;  
  for  i:=20 downto 0 do 
 begin  get:=get+1 shl i; 
 if (get>n) or (now+tree[get]>=tun) then 
  get:=get-1 shl i 
    else  
  now:=now+tree[get];
  end;  
 get:=get+1; 
  end; 

```

---

## 作者：kuansoudafahao (赞：0)

# 题目大意

给定一些区间（不会出现包含的情况），每次问区间里面第k小的数是什么。

# 题意分析

先来吐槽一波，洛谷原创=数据原创。

好吧，进入正题，原题是[这里](http://poj.org/problem?id=2761)。

注意：我这篇题解适合有treap基础的同学食用。

我的思路就是先把区间排个序，然后每次把区间里面的数丢进treap里面，然后乱搞，思路应该跟各位dalao差不多。但在poj上面怎么都过不了，结果到了luogu上面一次AC。嗯，是时候加强一下数据了。。。。。。

我来说一下我错的原因吧。就是如果有相同的数进到treap里面之后，我们肯定要把一个数放在一个数的右子树（你喜欢放在左子树也ok，反正我是左子树小于，右子树大于等于）。但是我们可能会在左旋、右旋等乱搞操作之后，把这个数搞到了左子树去了，就好像下面这种情况（圆里的是键值）：

![](https://cdn.luogu.com.cn/upload/pic/28330.png)

然后当我们想要删除这个数的时候，我们就会先找到父节点3，然后往右子树里找，然后我们就这样错了。。。。。。感觉我的表达似乎不太清晰233.

我的解决方法就是：我们删除的时候，不是删点，而是删权值。大家还是对比一下我先后的程序吧。

原来在poj上错了、在luogu上过了的程序：
```c++
#include <cstdio>
#include <time.h>
#include <cstdlib>
#include <algorithm>
#include <cstring>
#define cls(a) (memset(a,0,sizeof(a)))
using namespace std;

const int maxn=2000005;
const int maxm=500005;
int N,n,m,Root;
int val[maxn],W[maxn],Lson[maxn],Rson[maxn],Size[maxn],a[maxn],ans[maxm];
struct tmp
{
	int l,r,place,rank;
	bool operator < (const tmp &a) const
	{
		return (a.l==l)?(r<a.r):(l<a.l);
	}
}num[maxm];

int Newnode(int);
void insert(int &root,int x);
void Lrotate(int &x);
void Rrotate(int &x);
void maintain(int);
int findkth(int,int);
void remove(int &root,int x);

int main()
{
	srand(19260817);	
	scanf("%d%d",&n,&m);
	W[0]=-1;
	for(int i=1; i<=n; i++)
		scanf("%d",a+i);
	for(int i=1; i<=m; i++)
	{
		scanf("%d%d%d",&num[i].l,&num[i].r,&num[i].place);
		num[i].rank=i;
	}
	sort(num+1,num+m+1);
	int head=1,tail=0;
	for(int i=1; i<=m; i++)
	{
		while(tail<num[i].r)	
			insert(Root,Newnode(a[++tail]));
		while(head<num[i].l)	
			remove(Root,head++);//注意这里，我的点的编号是从1到N，所以这里删的是点的编号。
		ans[num[i].rank]=val[findkth(Root,num[i].place)];
	}
	for(int i=1; i<=m; i++)
		printf("%d\n",ans[i]);
	return 0;
}

void remove(int &root,int x)//这里我们删的是一个点
{
	if(root==0)
		return;
	if(root==x)//如果当前点就是我们要找的
	{
		if(!Lson[x]&&!Rson[x])
		{
			root=0;
			return;
		}
		if(W[Lson[x]]>W[Rson[x]])
		{
			Rrotate(root);
			remove(Rson[root],x);
		}else
		{
			Lrotate(root);
			remove(Lson[root],x);
		}
	}else	if(val[x]<val[root])
		remove(Lson[root],x);
	else 	remove(Rson[root],x);
	maintain(root);
}

int findkth(int root,int k)
{
	if(!root)
		return 0;
	int cnt=Size[Lson[root]];
	if(k<=cnt)
		return findkth(Lson[root],k);
	if(k==cnt+1)
		return root;
	return findkth(Rson[root],k-cnt-1);
} 

void insert(int &root,int x)
{
	if(!root)
	{
		root=x;
		return;
	}
	if(val[x]<val[root])
		insert(Lson[root],x);
	else	insert(Rson[root],x);
	if(W[Lson[root]]>W[root])
		Rrotate(root);
	if(W[Rson[root]]>W[root])
		Lrotate(root);
	maintain(root);
}

void maintain(int root)
{
	if(!root)
		return;
	Size[root]=Size[Lson[root]]+Size[Rson[root]]+1;
}

void Lrotate(int &x)
{
	int y=Rson[x];
	Rson[x]=Lson[y];
	Lson[y]=x;
	maintain(x);
	x=y;
}

void Rrotate(int &x)
{
	int y=Lson[x];
	Lson[x]=Rson[y];
	Rson[y]=x;
	maintain(x);
	x=y;
}

int Newnode(int v)
{
	int x=++N;
	val[x]=v;Lson[x]=Rson[x]=0;
	Size[x]=1;W[x]=rand();
	return x;
}
```

双OJ AC的程序：
```c++
#include <cstdio>
#include <time.h>
#include <cstdlib>
#include <algorithm>
#include <cstring>
#define cls(a) (memset(a,0,sizeof(a)))
using namespace std;

const int maxn=2000005;
const int maxm=500005;
int N,n,m,Root;
int val[maxn],W[maxn],Lson[maxn],Rson[maxn],Size[maxn],a[maxn],ans[maxm];
struct tmp
{
	int l,r,place,rank;
	bool operator < (const tmp &a) const
	{
		return (a.l==l)?(r<a.r):(l<a.l);
	}
}num[maxm];

int Newnode(int);
void insert(int &root,int x);
void Lrotate(int &x);
void Rrotate(int &x);
void maintain(int);
int findkth(int,int);
void remove(int &root,int x);

int main()
{
	srand(19260817);	
	scanf("%d%d",&n,&m);
	W[0]=-1;
	for(int i=1; i<=n; i++)
		scanf("%d",a+i);
	for(int i=1; i<=m; i++)
	{
		scanf("%d%d%d",&num[i].l,&num[i].r,&num[i].place);
		num[i].rank=i;
	}
	sort(num+1,num+m+1);
	int head=1,tail=0;
	for(int i=1; i<=m; i++)
	{
		while(tail<num[i].r)	
			insert(Root,Newnode(a[++tail]));
		while(head<num[i].l)	
			remove(Root,a[head++]);//这里我们删的是权值
		ans[num[i].rank]=val[findkth(Root,num[i].place)];
	}
	for(int i=1; i<=m; i++)
		printf("%d\n",ans[i]);
	return 0;
}

void remove(int &root,int v)
{
	if(val[root]==v)//如果当前点的权值就是我们要找的
	{
		if(!Lson[root]&&!Rson[root])
		{
			root=0;
			return;
		}
		if(W[Lson[root]]>W[Rson[root]])
		{
			Rrotate(root);
			remove(Rson[root],v);
		}else
		{
			Lrotate(root);
			remove(Lson[root],v);
		}
	}else	if(v<val[root])
		remove(Lson[root],v);
	else 	remove(Rson[root],v);
	maintain(root);
}

int findkth(int root,int k)
{
	if(!root)
		return 0;
	int cnt=Size[Lson[root]];
	if(k<=cnt)
		return findkth(Lson[root],k);
	if(k==cnt+1)
		return root;
	return findkth(Rson[root],k-cnt-1);
} 

void insert(int &root,int x)
{
	if(!root)
	{
		root=x;
		return;
	}
	if(val[x]<val[root])
		insert(Lson[root],x);
	else	insert(Rson[root],x);
	if(W[Lson[root]]>W[root])
		Rrotate(root);
	if(W[Rson[root]]>W[root])
		Lrotate(root);
	maintain(root);
}

void maintain(int root)
{
	if(!root)
		return;
	Size[root]=Size[Lson[root]]+Size[Rson[root]]+1;
}

void Lrotate(int &x)
{
	int y=Rson[x];
	Rson[x]=Lson[y];
	Lson[y]=x;
	maintain(x);
	x=y;
}

void Rrotate(int &x)
{
	int y=Lson[x];
	Lson[x]=Rson[y];
	Rson[y]=x;
	maintain(x);
	x=y;
}

int Newnode(int v)
{
	int x=++N;
	val[x]=v;Lson[x]=Rson[x]=0;
	Size[x]=1;W[x]=rand();
	return x;
}
```

---


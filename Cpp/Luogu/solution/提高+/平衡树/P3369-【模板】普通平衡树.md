# 【模板】普通平衡树

## 题目描述

您需要动态地维护一个可重集合 $M$，并且提供以下操作：

1. 向 $M$ 中插入一个数 $x$。
2. 从 $M$ 中删除一个数 $x$（若有多个相同的数，应只删除一个）。
3. 查询 $M$ 中有多少个数比 $x$ 小，并且将得到的答案加一。
4. 查询如果将 $M$ 从小到大排列后，排名位于第 $x$ 位的数。
5. 查询 $M$ 中 $x$ 的前驱（前驱定义为小于 $x$，且最大的数）。
6. 查询 $M$ 中 $x$ 的后继（后继定义为大于 $x$，且最小的数）。

对于操作 3,5,6，**不保证**当前可重集中存在数 $x$。
 

## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le n \le 10^5$，$|x| \le 10^7$

来源：Tyvj1728 原名：普通平衡树

在此鸣谢


## 样例 #1

### 输入

```
10
1 106465
4 1
1 317721
1 460929
1 644985
1 84185
1 89851
6 81968
1 492737
5 493598```

### 输出

```
106465
84185
492737```

# 题解

## 作者：天上一颗蛋 (赞：2340)

平衡树的板题，用Treap实现。

具体参见注释，写的很详细了，包括了原理，实现以及注意事项

~~蒟蒻写个注释板子写了两天，太弱了QAQ~~

感谢[niiick](https://www.luogu.org/space/show?uid=60885)指导

# Code
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
#include<algorithm>
#include<climits>
typedef long long LL;
using namespace std;
int RD(){
    int out = 0,flag = 1;char c = getchar();
    while(c < '0' || c >'9'){if(c == '-')flag = -1;c = getchar();}
    while(c >= '0' && c <= '9'){out = out * 10 + c - '0';c = getchar();}
    return flag * out;
    }
//第一次打treap，不压行写注释XD
const int maxn = 1000019,INF = 1e9;
//平衡树，利用BST性质查询和修改，利用随机和堆优先级来保持平衡，把树的深度控制在log N，保证了操作效率
//基本平衡树有以下几个比较重要的函数：新建，插入，删除，旋转
//节点的基本属性有val(值)，dat(随机出来的优先级)
//通过增加属性，结合BST的性质可以达到一些效果，如size(子树大小，查询排名)，cnt(每个节点包含的副本数)等
int na;
int ch[maxn][2];//[i][0]代表i左儿子，[i][1]代表i右儿子
int val[maxn],dat[maxn];
int size[maxn],cnt[maxn];
int tot,root;
int New(int v){//新增节点，
	val[++tot] = v;//节点赋值
	dat[tot] = rand();//随机优先级
	size[tot] = 1;//目前是新建叶子节点，所以子树大小为1
	cnt[tot] = 1;//新建节点同理副本数为1
	return tot;
	}
void pushup(int id){//和线段树的pushup更新一样
	size[id] = size[ch[id][0]] + size[ch[id][1]] + cnt[id];//本节点子树大小 = 左儿子子树大小 + 右儿子子树大小 + 本节点副本数
	}
void build(){
	root = New(-INF),ch[root][1] = New(INF);//先加入正无穷和负无穷，便于之后操作(貌似不加也行)
	pushup(root);//因为INF > -INF,所以是右子树，
	}
void Rotate(int &id,int d){//id是引用传递，d(irection)为旋转方向，0为左旋，1为右旋
	int temp = ch[id][d ^ 1];//旋转理解：找个动图看一看就好(或参见其他OIer的blog)
	ch[id][d ^ 1] = ch[temp][d];//这里讲一个记忆技巧，这些数据都是被记录后马上修改
	ch[temp][d] = id;//所以像“Z”一样
	id = temp;//比如这个id，在上一行才被记录过，ch[temp][d]、ch[id][d ^ 1]也是一样的
	pushup(ch[id][d]),pushup(id);//旋转以后size会改变，看图就会发现只更新自己和转上来的点，pushup一下,注意先子节点再父节点
	}//旋转实质是({在满足BST的性质的基础上比较优先级}通过交换本节点和其某个叶子节点)把链叉开成二叉形状(从而控制深度)，可以看图理解一下
void insert(int &id,int v){//id依然是引用，在新建节点时可以体现
	if(!id){
		id = New(v);//若节点为空，则新建一个节点
		return ;
		}
	if(v == val[id])cnt[id]++;//若节点已存在，则副本数++;
	else{//要满足BST性质，小于插到左边，大于插到右边
		int d = v < val[id] ? 0 : 1;//这个d是方向的意思，按照BST的性质，小于本节点则向左，大于向右
		insert(ch[id][d],v);//递归实现
		if(dat[id] < dat[ch[id][d]])Rotate(id,d ^ 1);//(参考一下图)与左节点交换右旋，与右节点交换左旋
		}
	pushup(id);//现在更新一下本节点的信息
	}
void Remove(int &id,int v){//最难de部分了
	if(!id)return ;//到这了发现查不到这个节点，该点不存在，直接返回
	if(v == val[id]){//检索到了这个值
		if(cnt[id] > 1){cnt[id]--,pushup(id);return ;}//若副本不止一个，减去一个就好
		if(ch[id][0] || ch[id][1]){//发现只有一个值，且有儿子节点,我们只能把值旋转到底部删除
			if(!ch[id][1] || dat[ch[id][0]] > dat[ch[id][1]]){//当前点被移走之后，会有一个新的点补上来(左儿子或右儿子)，按照优先级，优先级大的补上来
				Rotate(id,1),Remove(ch[id][1],v);//我们会发现，右旋是与左儿子交换，当前点变成右节点；左旋则是与右儿子交换，当前点变为左节点
				}
			else Rotate(id,0),Remove(ch[id][0],v);
			pushup(id);
			}
		else id = 0;//发现本节点是叶子节点，直接删除
		return ;//这个return对应的是检索到值de所有情况
		}
	v < val[id] ? Remove(ch[id][0],v) : Remove(ch[id][1],v);//继续BST性质
	pushup(id);
	}
int get_rank(int id,int v){
	if(!id)return 1;//若查询值不存在，返回；因为最后要减一排除哨兵节点，想要结果为-1这里就返回0
	if(v == val[id])return size[ch[id][0]] + 1;//查询到该值，由BST性质可知：该点左边值都比该点的值(查询值)小，故rank为左儿子大小 + 1
	else if(v < val[id])return get_rank(ch[id][0],v);//发现需查询的点在该点左边，往左边递归查询
	else return size[ch[id][0]] + cnt[id] + get_rank(ch[id][1],v);//若查询值大于该点值。说明询问点在当前点的右侧，且此点的值都小于查询值，所以要加上cnt[id]
	}
int get_val(int id,int rank){
	if(!id)return INF;//一直向右找找不到，说明是正无穷
	if(rank <= size[ch[id][0]])return get_val(ch[id][0],rank);//左边排名已经大于rank了，说明rank对应的值在左儿子那里
		else if(rank <= size[ch[id][0]] + cnt[id])return val[id];//上一步排除了在左区间的情况，若是rank在左与中(目前节点)中，则直接返回目前节点(中区间)的值
	else return get_val(ch[id][1],rank - size[ch[id][0]] - cnt[id]);//剩下只能在右区间找了，rank减去左区间大小和中区间，继续递归
	}
int get_pre(int v){
	int id = root,pre;//递归不好返回，以循环求解
	while(id){//查到节点不存在为止
		if(val[id] < v)pre = val[id],id = ch[id][1];//满足当前节点比目标小，往当前节点的右侧寻找最优值
		else id = ch[id][0];//无论是比目标节点大还是等于目标节点，都不满足前驱条件，应往更小处靠近
		}
	return pre;
	}
int get_next(int v){
	int id = root,next;
	while(id){
		if(val[id] > v)next = val[id],id = ch[id][0];//同理，满足条件向左寻找更小解(也就是最优解)
		else id = ch[id][1];//与上方同理
		}
	return next;
	}
int main(){
	build();//不要忘记初始化[运行build()会连同root一并初始化，所以很重要]
	na = RD();
	for(int i = 1;i <= na;i++){
		int cmd = RD(),x = RD();
		if(cmd == 1)insert(root,x);//函数都写好了，注意：需要递归的函数都从根开始，不需要递归的函数直接查询
		else if(cmd == 2)Remove(root,x);
		else if(cmd == 3)printf("%d\n",get_rank(root,x) - 1);//注意：因为初始化时插入了INF和-INF,所以查询排名时要减1(-INF不是第一小，是“第零小”)
		else if(cmd == 4)printf("%d\n",get_val(root,x + 1));//同理，用排名查询值得时候要查x + 1名，因为第一名(其实不是)是-INF
		else if(cmd == 5)printf("%d\n",get_pre(x));
		else if(cmd == 6)printf("%d\n",get_next(x));
		}
	return 0;
	}
```
---

# Upd 20.08.09
高考完了回来看看

首先是回复一下评论区的问题：

### By @Van_Darkholmcnt ：cnt数组记的副本数指的是什么 
副本数记录的是当前节点对应数的个数，比如说有 $3$ 个大小为 $1$ 的数，$1$对应节点的 $cnt$ 就为 $3$

### By @性别男爱好女 ：为什么优先级是随机的  
本篇题解注重的是代码对 $Treap$ 的实现，随机优先级的复杂度为 $O(log$ $N)$ 是经过了严谨的证明的。很惭愧，怀着一丝丝功利心搞竞赛的我并没有想过要去了解这个算法的本质，所以以我目前的水平无法解决你的问题。但若是真的感兴趣的话可以参照：

### “
   _我们可以看到，如果一个二叉排序树节点插入的顺序是随机的，这样我们得到的二叉排序树大多数情况下是平衡的，即使存在一些极端情况，但是这种情况发生的概率很小，所以我们可以这样建立一颗二叉排序树，而不必要像AVL那样旋转，可以证明随机顺序建立的二叉排序树在期望高度是O(logn)，但是某些时候我们并不能得知所有的带插入节点，打乱以后再插入。所以我们需要一种规则来实现这种想法，并且不必要所有节点。也就是说节点是顺序输入的，我们实现这一点可以用Treap。（摘自百度百科）_ 
### ”

### By @daisijie  @garbage2 ：有关随机数
$rand()$ 是包括在 #$include <stdlib.h>$ 库中的函数

随机数种子的作用是提供（生成）一个序列来取随机数，在一次运行中，即使种子相同，第二个生成的随机数也和第一个生成的随机数没有必然联系。

但运行两次程序，第二次运行生成的随机数必定和第一次生成的相同

所以是不需要用 srand((unsigned)time(0)) 初始化的

[可以参照这篇博客](https://blog.csdn.net/qq_42900286/article/details/89433759)

# Upd 22.07.27

### 关于数据加强版Hack
[当时这篇讨论说的很明白了](https://www.luogu.com.cn/discuss/313582)，但是被刷下去了大伙也看不到，这里补一下传送门。代码本身是没得错的，感谢小伙伴们指出：D


# 写在最后
回洛谷看看，是怀着一丝敬佩的。

竞赛加分取消后，身边不知多少人多少学校将 $OI$ 扔进了垃圾堆。

我这个人吧是那种不爱看重成绩去什么什么很好的大学才有出路。

但即便是我，也不能说当初选择信息竞赛没有考虑过功利。

谁不曾梦想过金牌保送清北呢？

肉麻的话我说不出，也不想说。

但你们，仍然坚持着的你们，实实在在地仍挺直着不屈的脊背。

你们是凭着一片热忱还坚守着这片土地啊！

也许有一天，你发现，付出了许多的你，和也许没那么努力的其他人相比，都能踏入挺厉害的大学，都有着美好的前程。

你也许会浮想联翩：要是我当初没踏足 $OI$ ，我会不会在一个更好的地方？

这时，请不要后悔。

**绕远的路，总有风景。**

![](https://cdn.luogu.com.cn/upload/image_hosting/g638uuva.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/628nccfu.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/5cq796y2.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/i6gwjxsu.png)

---

## 作者：北极鹅 (赞：886)

看了那么多Splay、Treap、SBT、替罪羊树的题解，是时候来一篇此题历史最快的代码了。

**红黑树**，同样是一种自平衡二叉搜索树，由Rudolf Bayer最先提出，当时被称为平衡二叉B树（其实红黑树本质就是一棵B-tree），后来被Leo J. Guibas和Robert Sedgewick修改为"红黑树"。

# 红黑树具有如下性质：

1.红黑树是一棵平衡二叉搜索树，其中序遍历单调不减。

2.节点是红色或黑色。

3.根节点是黑色。

4.每个叶节点(也有称外部节点的，目的是将红黑树变为真二叉树，即NULL节点，空节点)是黑色的。

5.每个红色节点的两个子节点都是黑色。(换句话说，从每个叶子到根的所有路径上不能有两个连续的红色节点)

6.从根节点到每个叶子的所有路径都包含相同数目的黑色节点（这个数值叫做黑高度）。

如下面一棵树就是红黑树（请自行脑补外部节点）：

![](https://cdn.luogu.com.cn/upload/pic/14509.png)

而这几棵树就不是：

![](https://cdn.luogu.com.cn/upload/pic/14510.png)

红黑树有几个变种，如AA树等，就此题而言，我将使用自己实现的最常见的**红黑树模版**。
```cpp
#include <cstdio>
#include <cctype>
#include <cassert>
using namespace std;

//#define __REDBLACK_DEBUG

#define bro(x) (((x)->ftr->lc == (x)) ? ((x)->ftr->rc) : ((x)->ftr->lc))
#define islc(x) ((x) != NULL && (x)->ftr->lc == (x))
#define isrc(x) ((x) != NULL && (x)->ftr->rc == (x))

template<typename T>
class redblacktree {
	protected:
		struct Node;

		Node* _root;	////根节点位置
		Node* _hot;	////临时维护的节点

		void init(T);
		void connect34(Node*, Node*, Node*, Node*, Node*, Node*, Node*);
		void SolveDoubleRed(Node*);	////双红修正
		void SolveDoubleBlack(Node*);	//双黑修正
		Node* find(T, const int);	////允许重复的查找
		Node* rfind(T, const int);	////不允许重复的查找
		Node* findkth(int, Node*);
		int find_rank(T, Node*);
#ifdef __REDBLACK_DEBUG
		void checkconnect(Node*);
		void previs(Node*, int);
		void invis(Node*, int);
		void postvis(Node*, int);
#endif

	public:

		struct iterator;

		redblacktree() : _root(NULL), _hot(NULL) {}

		int get_rank(T);
		iterator insert(T);
		bool remove(T);
		int size();
        bool empty();
		iterator kth(int);
		iterator lower_bound(T);
		iterator upper_bound(T);
#ifdef __REDBLACK_DEBUG
		void vis();
		void correctlyconnected();
#endif
};
```
其中定义宏__REDBLACK_DEBUG是为了方便调试，提交的时候可以注释掉。

宏islc()、isrc()是用来判断是否为左右儿子节点的，宏bro(x)返回节点x的兄弟。

# 节点

下面，根据需要维护的信息，我们可以轻松写出节点Node的结构体：
```cpp

template <typename T>
struct redblacktree<T>::Node {
	T val;	////节点信息
	bool RBc;	////节点颜色，若为true，则节点为Red;否则节点为Black.
	Node* ftr;	////父亲
	Node* lc;	////左儿子
	Node* rc;	////右儿子
	int s;		////域

	Node(	T v = T(), bool RB = true,
	        Node* f = NULL, Node* l = NULL, Node* r = NULL ,int ss = 1	)
		: val(v), RBc(RB), ftr(f), lc(l), rc(r), s(ss) {}

	Node* succ() {		////删除节点时用到的替代节点
		Node* ptn = rc;
		while(ptn->lc != NULL) {
			--(ptn->s);
			ptn = ptn->lc;
		}
		return ptn;
	}

	Node* left_node() {		////直接前驱
		Node* ptn = this;
		if(!lc) {
			while(ptn->ftr && ptn->ftr->lc == ptn)
				ptn = ptn->ftr;
			ptn = ptn->ftr;
		} else {
			ptn = ptn->lc;
			while(ptn->rc) {
				ptn = ptn->rc;
			}
		}
		return ptn;
	}

	Node* right_node() {	////直接后继
		Node* ptn = this;
		if(!rc) {
			while(ptn->ftr && ptn->ftr->rc == ptn)
				ptn = ptn->ftr;
			ptn = ptn->ftr;
		} else {
			ptn = ptn->rc;
			while(ptn->lc) {
				ptn = ptn->lc;
			}
		}
		return ptn;
	}

	void maintain() {	////维护域s
		s = 1;
		if(lc) s += lc->s;
		if(rc) s += rc->s;
	}
};
```
# 迭代器

迭代器的结构体也很容易写出来啦：
```cpp
template <typename T>
struct redblacktree<T>::iterator {
	private:

		Node* _real__node;

	public:

		iterator& operator++() {
			_real__node = _real__node->right_node();
			return *this;
		}

		iterator& operator--() {
			_real__node = _real__node->left_node();
			return *this;
		}

		T operator*() {
			return _real__node->val;
		}

		iterator(Node* node_nn = NULL) : _real__node(node_nn) {}
		iterator(T const& val_vv) : _real__node(rfind(val_vv, 0)) {}
		iterator(iterator const& iter) : _real__node(iter._real__node) {}

};
```
# 插入、双红现象及其修正

插入比较好写，只需要将节点作为红色节点插入（保证不违反性质6，但可能违反性质5，毕竟性质5比性质6容易修正），然后判断是否出现双红现象，修正该节点即可。
```cpp
template <typename T>
typename
redblacktree<T>::iterator redblacktree<T>::insert(T v) {
	Node* ptn = find(v, 1);
	if(_hot == NULL) {
		init(v);
		return iterator(_root);
	}
	ptn = new Node(v, true, _hot, NULL, NULL, 1);
	if(	_hot->val <= v	)
		_hot->rc = ptn;
	else
		_hot->lc = ptn;
	SolveDoubleRed(ptn);
	return iterator(ptn);
}

template <typename T>
void redblacktree<T>::init(T v) {
	_root = new Node(v, false, NULL, NULL, NULL, 1);
#ifdef __REDBLACK_DEBUG
	++blackheight;
#endif
}
```
此处使用了函数find，和rfind一样，第一个参数是待寻找值，第二个参数是每个路过的节点域的增加值（插入为1，删除为-1，普通查找为0）：
```cpp
template <typename T>
typename
redblacktree<T>::Node* redblacktree<T>::find(T v, const int op) {
	Node* ptn = _root;	////从根节点开始查找
	_hot = NULL;	////维护父亲节点
	while(ptn != NULL) {
		_hot = ptn;
		ptn->s += op;
		if(ptn->val > v)
			ptn = ptn->lc;
		else
			ptn = ptn->rc;
	}
	return ptn;
}

template <typename T>
typename
redblacktree<T>::Node* redblacktree<T>::rfind(T v, const int op) {
	Node* ptn = _root;
	_hot = NULL;
	while(ptn != NULL && ptn->val != v) {
		_hot = ptn;
		ptn->s += op;
		if(ptn->val > v)
			ptn = ptn->lc;
		else
			ptn = ptn->rc;
	}
	return ptn;
}
```
## 双红修正

至于双红修正，可以分为以下三种情况：

### 1.没有出现双红。

这一点很重要，一定要加在SolveDoubleRed()里面判断，因为不论是直接插入还是上溢都有可能出现这种情况。

![](https://cdn.luogu.com.cn/upload/pic/14511.png)

直接return返回就好，不解释……

### 2.父亲为红色（则父亲非根，祖父非空），叔叔bro(父亲)为黑色（注意：可能是叶子NULL，需要判断；祖父可能是根，需要判断）。(RR-1)

![](https://cdn.luogu.com.cn/upload/pic/14513.png)

若修正节点x是祖父g的左儿子的左儿子或右儿子的右儿子（即互为同向祖孙关系），将g单旋一次（将x的父亲p伸展到g位置），再将g染红、p染黑即可；若x不是g的同向孙子，需要将x的父亲p旋转一次，再旋转g一次（将x伸展到g位置），最后将g染红、x染黑即可。

### 3.父亲为红色，叔叔为红色。(RR-2)

![](https://cdn.luogu.com.cn/upload/pic/14516.png)

双红修正中唯一需要迭代或递归的情况。将祖父g染红、叔叔u和父亲p染黑，双红缺陷就会上溢两层，下一步就是修正g的双红缺陷啦！

但要注意的是，g有可能是树根。如果这种情况上溢到了树根，只需要将g再染黑即可，此时全树黑高度增加1。虽然这样可能会遍历整棵树的O(log n)个节点，但是分摊意义下，SolveDoubleRed()的时间复杂度为O(1)。可以用势能分析法证明。

### 因此可以轻松写出SolveDoubleRed()函数啦：
```cpp
template <typename T>
void redblacktree<T>::SolveDoubleRed(Node* nn) {
	while((!(nn->ftr)) || nn->ftr->RBc) {
		if(nn == _root) {
			_root->RBc = false;
#ifdef __REDBLACK_DEBUG
			++blackheight;
#endif
			return;
		}
		Node* pftr = nn->ftr;
		if(!(pftr->RBc)) return;			////No double-red
		Node* uncle = bro(nn->ftr);
		Node* grdftr = nn->ftr->ftr;
		if(uncle != NULL && uncle->RBc) {	////RR-2
			grdftr->RBc = true;
			uncle->RBc = false;
			pftr->RBc = false;
			nn = grdftr;
		} else {							////RR-1
			if(islc(pftr)) {
				if(islc(nn)) {
					pftr->ftr = grdftr->ftr;
					if(grdftr == _root) _root = pftr;
					else if(grdftr->ftr->lc == grdftr) grdftr->ftr->lc = pftr;
					else grdftr->ftr->rc = pftr;
					connect34(pftr, nn, grdftr, nn->lc, nn->rc, pftr->rc, uncle);
					pftr->RBc = false;
					grdftr->RBc = true;
				} else {
					nn->ftr = grdftr->ftr;
					if(grdftr == _root) _root = nn;
					else if(grdftr->ftr->lc == grdftr) grdftr->ftr->lc = nn;
					else grdftr->ftr->rc = nn;
					connect34(nn, pftr, grdftr, pftr->lc, nn->lc, nn->rc, uncle);
					nn->RBc = false;
					grdftr->RBc = true;
				}
			} else {
				if(islc(nn)) {
					nn->ftr = grdftr->ftr;
					if(grdftr == _root) _root = nn;
					else if(grdftr->ftr->lc == grdftr) grdftr->ftr->lc = nn;
					else grdftr->ftr->rc = nn;
					connect34(nn, grdftr, pftr, uncle, nn->lc, nn->rc, pftr->rc);
					nn->RBc = false;
					grdftr->RBc = true;
				} else {
					pftr->ftr = grdftr->ftr;
					if(grdftr == _root) _root = pftr;
					else if(grdftr->ftr->lc == grdftr) grdftr->ftr->lc = pftr;
					else grdftr->ftr->rc = pftr;
					connect34(pftr, grdftr, nn, uncle, pftr->lc, nn->lc, nn->rc);
					pftr->RBc = false;
					grdftr->RBc = true;
				}
			}
			return;
		}
	}
}
```
## 统一重平衡

为了简化代码，旋转操作都使用了统一重平衡函数connect34()
```cpp

template <typename T>
void redblacktree<T>::connect34(	Node* nroot,	Node* nlc,		Node* nrc,
                                    Node* ntree1,	Node* ntree2,	Node* ntree3,	Node* ntree4) {
	nlc->lc = ntree1;
	if(ntree1 != NULL) ntree1->ftr = nlc;
	nlc->rc = ntree2;
	if(ntree2 != NULL) ntree2->ftr = nlc;
	nrc->lc = ntree3;
	if(ntree3 != NULL) ntree3->ftr = nrc;
	nrc->rc = ntree4;
	if(ntree4 != NULL) ntree4->ftr = nrc;
	nroot->lc = nlc;
	nlc->ftr = nroot;
	nroot->rc = nrc;
	nrc->ftr = nroot;
	nlc->maintain();
	nrc->maintain();
	nroot->maintain();
}
```

# 两种bound

lower_bound(v)、upper_bound(v)两个函数，分别返回红黑树中不大于v的最大的元素、大于v的最小的元素。可以用rfind(v, 0)实现，但此处注重效率，可以另写查找算法：
```cpp
template <typename T>
typename
redblacktree<T>::iterator redblacktree<T>::lower_bound(T v) {
	Node* ptn = _root;
	while(ptn) {
		_hot = ptn;
		if(ptn->val < v) {
			ptn = ptn->rc;
		} else {
			ptn = ptn->lc;
		}
	}
	if(_hot->val < v) {
		ptn = _hot;
	} else {
		ptn = _hot->left_node();
	}
	return iterator(ptn);
}

template <typename T>
typename
redblacktree<T>::iterator redblacktree<T>::upper_bound(T v) {
	Node* ptn = _root;
	while(ptn) {
		_hot = ptn;
		if(ptn->val > v) {
			ptn = ptn->lc;
		} else {
			ptn = ptn->rc;
		}
	}
	if(_hot->val > v) {
		ptn = _hot;
	} else {
		ptn = _hot->right_node();
	}
	return iterator(ptn);
}
```
# 寻找第k大

就像快速选择一样，非常简单对不对？
```cpp
template <typename T>
typename
redblacktree<T>::iterator redblacktree<T>::kth(int rank) {
	return iterator(findkth(rank, _root));
}

template <typename T>
typename
redblacktree<T>::Node* redblacktree<T>::findkth(int rank, Node* ptn) {
	if(!(ptn->lc)) {
		if(rank == 1) {
			return ptn;
		} else {
			return findkth(rank - 1, ptn->rc);
		}
	} else {
		if(ptn->lc->s == rank - 1) return ptn;
		else if(ptn->lc->s >= rank) return findkth(rank, ptn->lc);
		else return findkth(rank - (ptn->lc->s) - 1, ptn->rc);
	}
}
```
# 找到元素的名次

更简单了有木有？
```cpp
template <typename T>
int redblacktree<T>::get_rank(T v) {
	return find_rank(v, _root);
}

template <typename T>
int redblacktree<T>::find_rank(T v, Node* ptn) {
	if(!ptn) return 1;
	else if(ptn->val >= v) return find_rank(v, ptn->lc);
	else return (1 + ((ptn->lc) ? (ptn->lc->s) : 0) + find_rank(v, ptn->rc));
}
```
# 其他接口

介绍删除之前，我们可以做一些比较简单的接口操作，如size()、empty()。
```cpp
template <typename T>
int redblacktree<T>::size() {
	return _root->s;
}

template <typename T>
bool redblacktree<T>::empty() {
	return !_root;
}
```
# 删除、双黑现象及其修正

俗话说：老鼠拉木锨，大头在后边。删除和双黑修正是红黑树最令人恶心和窒息的操作，许多大学教材对此闭口不谈，连清华的《数据结构》也讲述地十分混乱（但编者邓俊辉教授绝对是我的恩人，2017提高组NOIP考试之前偶然瞥了一眼《数据结构》里面的希尔排序那一章，里面一个数论问题吸引了我的注意，于是我不经意间记下了那个公式：x(g, h) = g\*h - g - h，第二天看到题我笑了，AC了D1T1）。

不说我的故事了，也不说邓教授的书了，下面直接进删除：
```cpp
template <typename T>
bool redblacktree<T>::remove(T v) {
	Node* ptn = rfind(v, -1);
	if(!ptn) return false;
	Node* node_suc;
	while(ptn->lc || ptn->rc) {	////迭代寻找真后继
		if(!(ptn->lc)) {
			node_suc = ptn->rc;
		} else if(!(ptn->rc)) {
			node_suc = ptn->lc;
		} else {
			node_suc = ptn->succ();
		}
		--(ptn->s);
		ptn->val = node_suc->val;
		ptn = node_suc;
	}
	if(!(ptn->RBc)) {
		--(ptn->s);
		SolveDoubleBlack(ptn);
	}
	if(ptn == _root) {
		_root = NULL;
		delete ptn;
		return true;
	}
	if(ptn->ftr->lc == ptn)
		ptn->ftr->lc = NULL;
	else
		ptn->ftr->rc = NULL;
	delete ptn;
	return true;
}
```
看似非常简单对不对？只是因为我没有给出那一百来行的SolveDoubleBlack()代码……

## 双黑修正

双黑修正比较厉害，情况一共四种，同样只有一种情况需要迭代或递归。双黑修正不容易理解的就是SolveDoubleBlack(Node* x)的参数x。必黑的节点x代表，x的左右儿子黑高度均相等，即若以x作为根，子树x并不存在双黑缺陷，但x比兄弟bro(x)的黑高度少1，因此需要修正。

双黑修正的4种情况如下：

### 1.兄弟为红色(BB-1)

许多教材将此情况最后判断，同时也认为是需要递归的情况，但我认为不必，首先判断这个情况，可以兼顾效率和代码可读性。

![](https://cdn.luogu.com.cn/upload/pic/14521.png)

旋转父亲p，将b伸展到p位置，然后染黑b、染红p，于是将问题转化到了BB-2R或BB-3。

### 2.兄弟和父亲都为黑色，且兄弟没有红儿子(BB-2B)

根据我的跟踪记录，在一些插入操作居多的数据（如百科词条、医院药品记录、核电站控制系统等现实情况），此情况几乎不会发生，但只要出现全树黑高度减少1的情况，BB-2B就一定发生且下溢到根节点了。

![](https://cdn.luogu.com.cn/upload/pic/14523.png)

染红兄弟b，双黑缺陷下溢到了父亲p，问题转化为了BB-1、BB-2B、BB-2R或BB-3中的一个。

如果被修正节点为根节点，只需要直接返回即可，此时全树黑高度减少1。

### 3.兄弟是黑色，没有红儿子，父亲为红色(BB-2R)

相当简单了吧，不用我介绍，聪明的读者应该也能想到:

![](https://cdn.luogu.com.cn/upload/pic/14524.png)

染红b，染黑p，然后就完成修正了。

### 4.兄弟是黑色，有红儿子(BB-3)

同样不需要转化问题：

![](https://cdn.luogu.com.cn/upload/pic/14525.png)

如果侄子c是父亲p的同向孙子的话，旋转p使兄弟b伸展到p位置，并将b染为p的颜色，p、c染黑即可；如果c不是p的同向孙子，伸展c到p的位置，并将c染为p的颜色，然后染黑p即可。

### 于是双黑修正SolveDoubleBlack的代码也很容易写出啦：
```cpp
template <typename T>
void redblacktree<T>::SolveDoubleBlack(Node* nn) {
	while(nn != _root) {
		Node* pftr = nn->ftr;
		Node* bthr = bro(nn);
		if(bthr->RBc) {					////BB-1
			bthr->RBc = false;
			pftr->RBc = true;
			if(_root == pftr) _root = bthr;
			if(pftr->ftr) {
				if(pftr->ftr->lc == pftr)
					pftr->ftr->lc = bthr;
				else
					pftr->ftr->rc = bthr;
			}
			bthr->ftr = pftr->ftr;
			if(islc(nn)) {
				connect34(bthr, pftr, bthr->rc, nn, bthr->lc, bthr->rc->lc, bthr->rc->rc);
			} else {
				connect34(bthr, bthr->lc, pftr, bthr->lc->lc, bthr->lc->rc, bthr->rc, nn);
			}
			bthr = bro(nn);
			pftr = nn->ftr;
		}
		if(bthr->lc && bthr->lc->RBc) {	////BB-3
			bool oldRBc = pftr->RBc;
			pftr->RBc = false;
			if(pftr->lc == nn) {
				if(pftr->ftr) {
					if(pftr->ftr->lc == pftr)
						pftr->ftr->lc = bthr->lc;
					else
						pftr->ftr->rc = bthr->lc;
				}
				bthr->lc->ftr = pftr->ftr;
				if(_root == pftr) _root = bthr->lc;
				connect34(bthr->lc, pftr, bthr, pftr->lc, bthr->lc->lc, bthr->lc->rc, bthr->rc);
			} else {
				bthr->lc->RBc = false;
				if(pftr->ftr) {
					if(pftr->ftr->lc == pftr)
						pftr->ftr->lc = bthr;
					else
						pftr->ftr->rc = bthr;
				}
				bthr->ftr = pftr->ftr;
				if(_root == pftr) _root = bthr;
				connect34(bthr, bthr->lc, pftr, bthr->lc->lc, bthr->lc->rc, bthr->rc, pftr->rc);
			}
			pftr->ftr->RBc = oldRBc;
			return;
		} else if(bthr->rc && bthr->rc->RBc) {	////BB-3
			bool oldRBc = pftr->RBc;
			pftr->RBc = false;
			if(pftr->lc == nn) {
				bthr->rc->RBc = false;
				if(pftr->ftr) {
					if(pftr->ftr->lc == pftr)
						pftr->ftr->lc = bthr;
					else
						pftr->ftr->rc = bthr;
				}
				bthr->ftr = pftr->ftr;
				if(_root == pftr) _root = bthr;
				connect34(bthr, pftr, bthr->rc, pftr->lc, bthr->lc, bthr->rc->lc, bthr->rc->rc);
			} else {
				if(pftr->ftr) {
					if(pftr->ftr->lc == pftr)
						pftr->ftr->lc = bthr->rc;
					else
						pftr->ftr->rc = bthr->rc;
				}
				bthr->rc->ftr = pftr->ftr;
				if(_root == pftr) _root = bthr->rc;
				connect34(bthr->rc, bthr, pftr, bthr->lc, bthr->rc->lc, bthr->rc->rc, pftr->rc);
			}
			pftr->ftr->RBc = oldRBc;
			return;
		}
		if(pftr->RBc) {					////BB-2R
			pftr->RBc = false;
			bthr->RBc = true;
			return;
		} else {						////BB-2B
			bthr->RBc = true;
			nn = pftr;
		}
	}
#ifdef __REDBLACK_DEBUG
	--blackheight;
#endif
}
```
# Debug的代码

为了方便调试，我在写红黑树板子的同时也写了一些调试代码：
```cpp
#ifdef __REDBLACK_DEBUG

int blackheight(0);

template <typename T>	////先序遍历
void redblacktree<T>::previs(Node* ptn, int cnt) {
	if(ptn == NULL) {
		if(blackheight == -1) blackheight = cnt;
		assert(blackheight == cnt);
		return;
	}
	printf("%d %s %d \n", ptn->val, ptn->RBc ? "Red" : "Black", ptn->s);
	if(!(ptn->RBc)) ++cnt;
	previs(ptn->lc, cnt);
	previs(ptn->rc, cnt);
}

template <typename T>	////中序遍历
void redblacktree<T>::invis(Node* ptn, int cnt) {
	if(ptn == NULL) {
		if(blackheight == -1) blackheight = cnt;
		assert(blackheight == cnt);
		return;
	}
	if(!(ptn->RBc)) ++cnt;
	invis(ptn->lc, cnt);
	printf("%d %s %d \n", ptn->val, ptn->RBc ? "Red" : "Black", ptn->s);
	invis(ptn->rc, cnt);
}

template <typename T>	////后序遍历
void redblacktree<T>::postvis(Node* ptn, int cnt) {
	if(ptn == NULL) {
		if(blackheight == -1) blackheight = cnt;
		assert(blackheight == cnt);
		return;
	}
	if(!(ptn->RBc)) ++cnt;
	postvis(ptn->lc, cnt);
	postvis(ptn->rc, cnt);
	printf("%d %s %d \n", ptn->val, ptn->RBc ? "Red" : "Black", ptn->s);
}

template <typename T>	////输出所有序遍历的接口
void redblacktree<T>::vis() {
	printf("BlackHeight:\t%d\n", blackheight);
	printf("------pre-vis------\n");
	previs(_root, 0);
	printf("------in-vis------\n");
	invis(_root, 0);
	printf("------post-vis------\n");
	postvis(_root, 0);
}

template <typename T>	////验证所有节点与父亲的连接是否正常、域s是否维护正常
void redblacktree<T>::checkconnect(Node* ptn) {
	if(!ptn) return;
	assert(ptn->s > 0);
	if(ptn->lc && ptn->lc->ftr != ptn) {
		printf("Oops! %d has a lc %d, but it failed to point its ftr!\n", ptn->val, ptn->lc->val);
	}
	if(ptn->rc && ptn->rc->ftr != ptn) {
		printf("Oops! %d has a rc %d, but it failed to point its ftr!\n", ptn->val, ptn->rc->val);
	}
	int sss = ptn->s;
	if(ptn->lc) sss -= ptn->lc->s;
	if(ptn->rc) sss -= ptn->rc->s;
	if(sss - 1) {
		printf("Damn! %d's size is %d, but the sum of its children's size is %d!\n", ptn->val, ptn->s, ptn->s - sss);
	}
	checkconnect(ptn->lc);
	checkconnect(ptn->rc);
}

template <typename T>
void redblacktree<T>::correctlyconnected() {
	checkconnect(_root);
}
#endif
```
# 主程序

板子都有了，这个最好写了不是？
```cpp
inline
int readint() {
	int ret(0);
	int sgn(1);
	char c;
	while(isspace(c = getchar()));
	if(c == '-') {
		sgn = -1;
		c = getchar();
	}
	while(isdigit(c)) {
		ret = (ret << 3) + (ret << 1) + c - '0';
		c = getchar();
	}
	return ret * sgn;
}
#define ri readint()

int opt, x;

int tot;

redblacktree<int> my_tree;

int main() {
	register int i;
	tot = ri;
	redblacktree<int>::iterator it;
	for(i = 0; i < tot; ++i) {
		opt = ri;
		x = ri;
		switch(opt) {
			case 1:
				my_tree.insert(x);
				break;
			case 2:
				my_tree.remove(x);
				break;
			case 3:
				printf("%d\n", my_tree.get_rank(x));
				break;
			case 4:
				it = my_tree.kth(x);
				printf("%d\n", *it);
				break;
			case 5:
				it = my_tree.lower_bound(x);
				printf("%d\n", *it);
				break;
			case 6:
				it = my_tree.upper_bound(x);
				printf("%d\n", *it);
				break;
			default:
				break;
		}
	}

	return 0;
}
```
# 总结

红黑树应该是除哈希表外最快的搜索结构了（哈希表由于占内存太大，实际情况常常不用）。很多人认为红黑树太难写，就放弃学习它。我认为红黑树代码并不麻烦，和线段树的难度差不多，如果学会了会很容易写出来。

写于2018年2月15日，祝大家除夕快乐，拜个早年。

---

## 作者：皎月半洒花 (赞：467)

2025.2.5 upd：由于可能会查询到不存在于原序列的元素，因此在查询时改为了先插入、再查询、再删除。 

---

辣么，我要介绍我自学的 Splay 了，虽然跟大佬们讲得会有些重复，但是自认为把一些玄妙的东西点出来了 qwq。

# 引言

首先，我并没觉得 Splay 有多难……代码长的原因也就最多是因为不用指针太麻烦……就好像你链表不用指针而用数组模拟，在插入删除的时候就有你好受的了 qnq,更何况树形结构更为麻烦，在树上的操作也更加花样繁多。总之，麻烦。

但是 Splay 在我眼中却更像是一种可以放诸四海而皆可用的算法,不但可以有效替代二叉搜索树、AVL 树等数据结构，也不会由于 Treap 的随机键值而靠脸拿分（其实大多数情况下，只要没有因为被大佬 % 而 rp--，Treap 也是不错的选择），并且时间复杂度也是很可观的。

那么无论怎样，在学习一种新的、我喜欢的东西之前，总是要送一句话勉励自己，并抨击那些认为这种高级数据结构没有什么学的必要的人：

$\color{cyan}{A}$ $\color{cyan}{person}$ $\color{cyan}{who}$ $\color{cyan}{is}$ $\color{cyan}{regarded}$ $\color{cyan}{as}$ $\color{cyan}{a}$ $\color{cyan}{loser}$ $\color{cyan}{isn't}$ $\color{cyan}{those}$ $\color{cyan}{ordinarys}$ $\color{cyan}{,but}$ $\color{cyan}{the}$ $\color{cyan}{satisfieds}$ 

## 最怕你一生庸碌无为，却总是安慰自己平凡可贵

那么开始吧！

## 一. 旋转是个什么东西？？？

旋转这个操作呢，在之前的数据结构中，可谓见所未见，闻所未闻（瞎扯淡ing）。那么我们就先从旋转开始研究吧！

由于是建立在一株二叉搜索树上的，所以当时是一条链时，旋转并不会影响树的结构 qwqqq。

于是，二叉搜索树的旋转，完！

_________________

诶，骗你的啦，怎么可能完，你要知道每个节点可都是还有子节点的，如果直接旋转的话，就会出现一个节点有三个子节点的情况——这可不是我们想看到的，因为瞬间你的一棵 $\rm BT$ 就毁灭了。

为了满足 $\rm BST$ 的特性，我们可以得出一个宝贵的规律来：

我们定义一个结点与他父亲的关系是 $x$，那么在旋转时，他的父亲成为了他的 $!x$ 儿子,并且那个上文中所说的“多余结点”，同时也是当前节点的 $!x$ 儿子，但在旋转之后需要成为当前节点的“前”父节点的 $x$ 儿子。


$Talk$ $is$ $\color{silver}{cheap}$ $,show$ $you$ $the$ $\color{silver}{code}$:

```cpp
inline void update(int x){
	if(x){
		sub_size[x]=cnt[x];
		if(sons[x][1])sub_size[x]+=sub_size[sons[x][1]];
	    if(sons[x][0])sub_size[x]+=sub_size[sons[x][0]];
	}
	return ;
}
inline bool get_which(int x){
	return sons[f[x]][1]==x;
}
inline void rotate(int x){
	int father=f[x],g_father=f[father];
	bool which_son=get_which(x);//当前节点的关系
	sons[father][which_son]=sons[x][which_son^1];
	f[sons[father][which_son]]=father;
	sons[x][which_son^1]=father;
	f[father]=x;
	f[x]=g_father;
	if(g_father){
		sons[g_father][get_which(father)]=x;
	}
	update(x);
	update(father);
}
```

`son` 表示每个节点的左右儿子，`f` 表示每个节点的父亲 `sub_size[i]` 表示以 $i$ 为根的子树的大小。

> 诶，那为什么要记录子树大小啊？
>
> 为了方便执行之后的 $zz$ 操作啊！

接下来我们看 Splay 操作，其实这个操作十分地简单，不过是拼命地向上旋转至根节点而已，但在这其中还有些地方值得注意：

$\mathcal{1.}$ 如果爷爷节点、父节点与自己不共线，那么就是这样
![](https://cdn.luogu.com.cn/upload/pic/17965.png)

这时实际上并不会怎样……你就不断旋转就行了$qwq$

$\mathcal{2.}$如果三个节点共线的话，那么就先要旋转父节点，因为如果先旋转子节点的话，我们就会发现原来华丽的一条链的结构被破坏，接下来的一系列操作即会导致这棵树失衡，所以应该先旋转父节点，再旋转子节点 $qwq$。

![](https://cdn.luogu.com.cn/upload/pic/17966.png)

╮(￣▽￣")╭虽然我不是很想做效果图，但是为了你们我忍了（逃

那么接下来是当三个点共线时的两种处理方式的不同结果：
![](https://cdn.luogu.com.cn/upload/pic/17969.png)

实质上就是说，我们在链很长的时候，每次执行先旋父节点再旋当前节点的操作，一次总操作之后，这条链的深度会减半。

$Talk$ $is$ $\color{silver}{cheap}$ $,show$ $you$ $the$ $\color{silver}{code}$:

```cpp
inline void splay(int x){
	for (int fa;fa=f[x];rotate(x))  
      if (f[fa])  
        rotate((get_which(x)==get_which(fa))?fa:x);  
    root=x;  
}
```
诶，上图画的好像不是很浅显，因为节点数太少了，但是无论如何，本蒟蒻用机房的 XP 画图做图很难受的...

____________________

那么接下来……那些二叉搜索树的插入删除操作我就不赘述了，因为本身二叉搜索树就可以支持找前驱后继、找排名找数，所以只需要注意以下两点：

1.每次进行有关点的操作时都要 Splay 一次，因为要维护树的随机性，可以理解为维护复杂度。

2.注意第一条中的“有关点”，比如当给出排名找数的时候，由于其实跟这个点没什么关系，所以不用 Splay 。

$\rm Show~ The~ Whole ~Code$：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
#define MAXN 1000000
int f[MAXN],cnt[MAXN],value[MAXN],sons[MAXN][2],sub_size[MAXN],whole_size,root;                 
inline int qread(){
    int res=0,k=1;
    char c=getchar();
    while(!isdigit(c)){
        if(c=='-')k=-1;
        c=getchar();
    }
    while(isdigit(c)){
        res=(res<<1)+(res<<3)+c-48;
        c=getchar();
    }
    return res*k;
}
inline void S_Clear(int x){
    sons[x][0]=sons[x][1]=f[x]=sub_size[x]=cnt[x]=value[x]=0; 
}
inline bool get_which(int x){
    return sons[f[x]][1]==x;
}
inline void update(int x){
    if (x){  
        sub_size[x]=cnt[x];  
        if (sons[x][0]) sub_size[x]+=sub_size[sons[x][0]];  
        if (sons[x][1]) sub_size[x]+=sub_size[sons[x][1]];  
    }  
    return ;
}
inline void rotate(int x){
    int father=f[x],g_father=f[father],which_son=get_which(x);
    sons[father][which_son]=sons[x][which_son^1];
    f[sons[father][which_son]]=father;
    sons[x][which_son^1]=father;
    f[father]=x;
    f[x]=g_father;
    if(g_father){
        sons[g_father][sons[g_father][1]==father]=x;
    }
    update(father);
    update(x);
}
inline void splay(int x){
    for (int fa;fa=f[x];rotate(x))  
      if (f[fa])  
        rotate((get_which(x)==get_which(fa))?fa:x);  
    root=x;  
}
inline void insert(int x){
    if(!root){
        whole_size++;
        sons[whole_size][0]=sons[whole_size][1]=f[whole_size]=0;
        root=whole_size;
        sub_size[whole_size]=cnt[whole_size]++;
        value[whole_size]=x;
        return ;
    } 
    int now=root,fa=0;
    while(1){
        if(x==value[now]){
            cnt[now]++;
            update(now);
            update(fa);
            splay(now);
            break;
        }
        fa=now;
        now=sons[now][value[now]<x];
        if(!now){
            whole_size++;
            sons[whole_size][0]=sons[whole_size][1]=0;
            f[whole_size]=fa;
            sub_size[whole_size]=cnt[whole_size]=1;
            sons[fa][value[fa]<x]=whole_size;
            value[whole_size]=x;
            update(fa);
            splay(whole_size);
            break; 
        }
    }
    
}
inline int find_num(int x){ 
    int now=root;
    while(1){
        if(sons[now][0]&&x<=sub_size[sons[now][0]])
        now=sons[now][0];
        else {
            int temp=(sons[now][0]?sub_size[sons[now][0]]:0)+cnt[now];
            if(x<=temp)return value[now];
            x-=temp;
            now=sons[now][1];
        }
    }
}

inline int find_rank(int x){
      int now=root,ans=0;  
    while(1){  
        if (x<value[now])  
          now=sons[now][0];  
        else{  
            ans+=(sons[now][0]?sub_size[sons[now][0]]:0);  
            if (x==value[now]){  
                splay(now); return ans+1;  
            }  
            ans+=cnt[now];  
            now=sons[now][1];  
        }  
    }  
}
inline int find_pre(){
    int now=sons[root][0];
    while(sons[now][1])now=sons[now][1];
    return now;
}
inline int find_suffix(){
    int now=sons[root][1];
    while(sons[now][0])now=sons[now][0];
    return now;
}
inline void my_delete(int x){
    int hhh=find_rank(x);
    if (cnt[root]>1){
    cnt[root]--; 
    update(root); 
    return;
    }  
    if (!sons[root][0]&&!sons[root][1]) {
    S_Clear(root);
    root=0;
    return;
    }  
    if (!sons[root][0]){  
        int old_root=root; 
        root=sons[root][1];
        f[root]=0; 
        S_Clear(old_root); 
        return;  
    }  
     
    else if (!sons[root][1]){  
        int old_root=root; 
        root=sons[root][0]; 
        f[root]=0; 
        S_Clear(old_root); 
        return;  
    } 
    int left_max=find_pre(),old_root=root;  
    splay(left_max);  
    sons[root][1]=sons[old_root][1];  
    f[sons[old_root][1]]=root;  
    S_Clear(old_root);  
    update(root);  
}

   
int main(){
    int m,num,be_dealt;
    cin>>m;
    for(int i=1;i<=m;i++){
       num=qread();
       be_dealt=qread();
        switch(num)
        {
            case 1:insert(be_dealt);break;
            case 2:my_delete(be_dealt);break;
            case 3:insert(be_dealt) ; printf("%d\n",find_rank(be_dealt));my_delete(be_dealt);break;
            case 4:printf("%d\n",find_num(be_dealt));break;
            case 5:insert(be_dealt);printf("%d\n",value[find_pre()]);my_delete(be_dealt);break;
            case 6:insert(be_dealt);printf("%d\n",value[find_suffix()]);my_delete(be_dealt);break;
        }
    }
    return 0;
}
```

---

## 作者：arfa (赞：276)

强势图解 $\texttt{FHQ Treap}$。

首先说一说 $\texttt{FHQ Treap}$ 的优点,好理解,上手快,代码一般很短,可持久化等。

重要的是不用旋转。

$\texttt{FHQ Treap}$ 同时也借用了 $\texttt{Treap}$ 的特点,每一个节点拥有两个权值,一个是二叉树权值 $tree$,另一个是 $heap$。其次,它基于两个操作,一个是分裂 $\texttt{Split}$,另一个是 $\texttt{Merge}$。

$\texttt{Split}$ 的意思就是将这颗二叉树按某种条件掰开两半。这道题是按权值的大小掰开。假如一棵树要以 $\texttt{6}$ 来掰开,如图 : (下方都是 $tree$ 值)

![](https://i.loli.net/2019/02/23/5c70f2d1b0d50.png)

然后大力开花

![](https://i.loli.net/2019/02/23/5c70f2f76c4dc.png)

约定 : 分裂后左边的树为 $x$,右边的树为 $y$,它们的根为 $X$ 和 $Y$。

那么合并呢? 就是大力将两棵树合在一起。

那么这两个操作有什么用呢?

$$\large\texttt{Insert}$$

首先是插入一个数字 $k$。

我们想,如果我们按照 $k$ 掰开整颗树,然后将 $k$ 强行套进去,然后再合起来是不是就可以呢了。

图解 : (假如 $\texttt{Insert}\ 5$)

![](https://i.loli.net/2019/02/23/5c70f511e0404.png)

然后是 $\texttt{FHQ Treap}$ 的插入 (博主没有考虑 $heap$ 值,所以大家先感性理解)

![](https://i.loli.net/2019/02/23/5c70f674ddf72.png)

代码?

```pascal
procedure Insert(val:longint);
var x,y,o:longint;
begin
	x:=0; y:=0; Add(val); o:=n; // 新建一个节点,左树的根为 x,右树的根诶 y
	Split(root,x,y,val); // 这一个分裂操作会返回 x,y,还会将一些边改变
	Merge(x,x,o); Merge(root,x,y); // 将 x 树和新节点合并,形成的新树跟 y 节点合并
end;
```
我们可以依赖 $\texttt{Merge}$ 来维护堆的性质。
 

$$\large\texttt{Delete}$$

众所周知,$\texttt{BST}$ 的删除无比麻烦。

$\texttt{FHQ Treap}$ 可真是嗨到不行。

我们可以知道,如果我们把一个点的左儿子和右儿子合在一起,那么这个点就会变成 $\texttt{JO}$ 极生物。

我们要删除节点 $k$。

首先我们要把这棵树分成以 $k$ 领导的树和非 $k$ 领导的树,就是大力掰开。然后把以 $k$ 领导的树的左儿子和右儿子合起来,将 $k$ 丢入虚无。然后再合并新合成的树和非 $k$ 领导的树。

图解 : (假如我们 $\texttt{Delete}\ 9$)

![](https://i.loli.net/2019/02/23/5c70fa1c92768.png)

```pascal
procedure Delete(val:longint);
var x,y,o:longint;
begin
	x:=0; y:=0; o:=0;
	Split(root,x,y,val); // 分裂成 x,y 树 
   	Split(x,x,o,val-1); // 分裂成 x',o 树
	Merge(o,son[o,0],son[o,1]); // 将 o 树的根干掉,然后变成新的 o 树
	Merge(x,x,o); // o+x' 树=x树
   	Merge(root,x,y); // x+y树
end;
```

$$\large\texttt{Query}$$

这个操作是查询第 $K$ 大,要按照普通的查询方法来搞。

```pascal
function Query(now,k:longint):longint;
begin
	Query:=0;
	if size[son[now,0]]+1=k then exit(tree[now]);
	if size[son[now,0]]>=k then Query:=Query(son[now,0],k) else
	Query:=Query(son[now,1],k-size[son[now,0]]-1);
end;
```

$$\large\texttt{Rank}$$

求数字 $k$ 的排名。

我们再次大力掰开,把 $k-1$ 这个点拿出来。这个时候根 $x$ 都是 $\leq k-1$ 的 (也就是 $< k$)。然后我们把它的 $size$ 拿出来,加个一就好了。

```pascal
function Rank(k:longint):longint;
var x,y:longint;
begin
	x:=0; y:=0; Split(root,x,y,k-1);
	Rank:=size[x]+1; Merge(root,x,y);
end;
```

$$\large\texttt{Precursor}$$

求数字 $k$ 的前缀。

你按照 $k-1$ 掰开这棵树,就可以保证这棵树都是 $< k$ 的,然后找最大值。

图解 : ($\texttt{Precursor}\ 5$)

![](https://i.loli.net/2019/02/23/5c70fc769faf7.png)

```pascal
function Precursor(k:longint):longint;
var x,y:longint;
begin
	x:=0; y:=0; Split(root,x,y,k-1);
	Precursor:=Query(x,size[x]);
	Merge(root,x,y);
end;
```

$$\large\texttt{Next}$$

求数字 $k$ 的后继。

你按照 $k$ 掰开这棵树,就可以保证这棵树都是 $\ge k$ 的,然后找最小值。

```pascal
function Next(k:longint):longint;
var x,y:longint;
begin
	x:=0; y:=0; Split(root,x,y,k);
	Next:=Query(y,1);
	Merge(root,x,y);
end;
```
$$\large\texttt{Split}$$

激动人心的时候到了。


$son[i,0/1]$ 为左右儿子。

按照 $tree$ 来分裂。

图解 : (红色圈代表现在所在的节点,蓝色、橙色代表经过红色圈后所推出这一部分在左树还是右树,灰色代表未知)

![](https://i.loli.net/2019/02/23/5c7117fb8b454.png)

```pascal
procedure Split(now:longint;var a,b:longint;val:longint);
begin
	// now 为现在的节点,a,b 为分裂的树,val 为要掰开的值
	if now=0 then begin a:=0; b:=0; exit; end; // 结束分裂
	if tree[now]<=val then // 如果这个 tree 值要放在左边
	begin a:=now; Split(son[now,1],son[a,1],b,val); end // 那么这个树 a 的右儿子还是可能会大于 val 的,所以给 b
	else begin b:=now; Split(son[now,0],a,son[b,0],val); end; // 同理
	size[now]:=size[son[now,0]]+size[son[now,1]]+1;
end;
```
注意,$\texttt{Split}$ 会让整棵树分为两棵树 (连边上),然后会返回两个权值为两棵树的根。

一次分裂的时间复杂度为 $O(Height)$,期望为 $O(\log N)$。 (如果你将大佬的生日编入随机,那么你的期望效率将会大大提升)

$$\large\texttt{Merge}$$

满足 $heap$ 来合并。

因为分裂成 $x,y$ 树,那么 $y$ 树中的任意一个点的值肯定是大于 $x$ 树的。因此我们只需要确定父子关系,这由 $heap$ (小根堆) 决定。如果 $x$ 中的某点的 $a$ 的 $heap$ 小于 $y$ 中的 $b$ 的 $heap$,那么 $b$ 肯定是 $a$ 的右儿子,反之 $a$ 为 $b$ 的左儿子。

图解 : (以下圈外是 $heap$ 值,橙色部分为被选入儿子的部分)

![](https://miao.su/images/2019/02/26/311dac211f88e48ebe83f.png)


![](https://miao.su/images/2019/02/26/5a1e4d427469dee695f95.png)

这样一次的时间复杂度最多是 $O(x_{Height}+y_{Height})$,期望也是 $O(\log N)$。

```pascal
procedure Merge(var now:longint;a,b:longint);
begin
	if (a=0)or(b=0) then begin now:=a+b; exit; end; // 一个树为空了,另一个树整体插入
	if (heap[a]<heap[b]) then // 如果 a 树为 b 树的父亲,
 // 又因为 b 树肯定是大于 a 树的,所以 b 树是 a 树的右后代,继续往右边合并,而左儿子不管
	begin now:=a; Merge(son[now,1],son[a,1],b); end 
	else begin now:=b; Merge(son[now,0],a,son[b,0]); end; // 同理
	size[now]:=size[son[now,0]]+size[son[now,1]]+1;
end;
```

$$\large\texttt{Code}$$

```pascal
Uses math;

Const
	RP=2006212; 
	total=100010;

var
	size,tree,heap:array[-1..total*2] of longint;
	son:array[-1..total*2,-1..2] of longint;
	i,m,n,k,root,order:longint;

procedure Add(val:longint); begin inc(n); size[n]:=1; tree[n]:=val; heap[n]:=random(RP); end;

procedure Split(now:longint;var a,b:longint;val:longint);
begin
	if now=0 then begin a:=0; b:=0; exit; end;
	if tree[now]<=val then
	begin a:=now; Split(son[now,1],son[a,1],b,val); end
	else begin b:=now; Split(son[now,0],a,son[b,0],val); end;
	size[now]:=size[son[now,0]]+size[son[now,1]]+1;
end;

procedure Merge(var now:longint;a,b:longint);
begin
	if (a=0)or(b=0) then begin now:=a+b; exit; end;
	if (heap[a]<heap[b]) then
	begin now:=a; Merge(son[now,1],son[a,1],b); end
	else begin now:=b; Merge(son[now,0],a,son[b,0]); end;
	size[now]:=size[son[now,0]]+size[son[now,1]]+1;
end;

procedure Insert(val:longint);
var x,y,o:longint;
begin
	x:=0; y:=0; Add(val); o:=n;
	Split(root,x,y,val);
	Merge(x,x,o); Merge(root,x,y);
end;

procedure Delete(val:longint);
var x,y,o:longint;
begin
	x:=0; y:=0; o:=0;
	Split(root,x,y,val); Split(x,x,o,val-1);
	Merge(o,son[o,0],son[o,1]);
	Merge(x,x,o); Merge(root,x,y);
end;

function Query(now,k:longint):longint;
begin
	Query:=0;
	if size[son[now,0]]+1=k then exit(tree[now]);
	if size[son[now,0]]>=k then Query:=Query(son[now,0],k) else
	Query:=Query(son[now,1],k-size[son[now,0]]-1);
end;

function Rank(k:longint):longint;
var x,y:longint;
begin
	x:=0; y:=0; Split(root,x,y,k-1);
	Rank:=size[x]+1; Merge(root,x,y);
end;

function Precursor(k:longint):longint;
var x,y:longint;
begin
	x:=0; y:=0; Split(root,x,y,k-1);
	Precursor:=Query(x,size[x]);
	Merge(root,x,y);
end;

function Next(k:longint):longint;
var x,y:longint;
begin
	x:=0; y:=0; Split(root,x,y,k);
	Next:=Query(y,1);
	Merge(root,x,y);
end;

begin
	randomize; root:=1; Add(maxlongint); heap[root]:=-maxlongint;
	read(m);
	for i:=1 to m do
	begin
		read(order,k);
		Case order of
			1 : Insert(k);
			2 : Delete(k);
			3 : writeln(Rank(k)); // Get num's rank
			4 : writeln(Query(root,k)); // Get rank's num
			5 : writeln(Precursor(k));
			6 : writeln(Next(k));
		end;
	end;
end.
```

本文可能会有细节错误 ~~(有锅)~~ 之类的,已有发现敬请提出。

博主书写不易,敬请单连。关于一些奇奇怪怪的东西,请看 :[关于普通平衡树的均摊复杂度的优化](https://www.luogu.org/blog/acking/guan-yu-pu-tong-ping-heng-shu-di-jun-tan-fu-za-du-di-you-hua)。

---

## 作者：songhn (赞：212)

## 树状数组实现平衡树

有关平衡树的问题很多时候其实是可以用树状数组或是set来处理的，但似乎题解很少有这方面的说明~~赶紧水一发~~

本题值域范围不大，所以可以之间在线做，但一般开到$10^9$，这时候就需要离散化三连sort,unique,lower_bound，在离散化之后树状数组用来维护值域

首先对于操作1，直接在x对应的位置+1就好了，操作2同理

操作3只要查询x-1的前缀和就是比x的小的所有的数，+1就是排名了

操作4就是找到前缀和中第一个大于等于x的对应的数，因为前缀和其实就是排名

操作5和6同理，5中比如比x小的有k个数，我只要正好找到前缀和中第一个大于等于k对应的数就好了，需要注意的是两个操作的实现有一些不同
```cpp
if(p[i]==5) printf("%d\n",query(sum(hash(a[i])-1)));
if(p[i]==6) printf("%d\n",query(sum(hash(a[i]))+1));
```
为什么查询前驱
从$sum(i-1)$里找而后继要从$sum(i)+1$而不是$sum(i+1)$里找呢，这是因为我们为了离散化方便把查询排名的x也插了进去，这个地方可能是没有数的，$sum(i+1)$就和$sum(i)$一样了，所以这样处理
而如何查询第一个前缀和大于等于x对应的数呢，这里有两种方法，一种就是二分，还有一种就是通过树状数组的性质来处理，二分似乎之前有一篇题解提到过，这里介绍第二种方法

首先树状数组其实是一颗二叉树，让我们看这幅图
![](https://timgsa.baidu.com/timg?image&quality=80&size=b99999_300&sec=1533061471546&di=db3fad4bf880fe5c58c064c91714f5dd&imgtype=jpg&src=http%3A%2F%2Fimg2.imgtn.bdimg.com%2Fit%2Fu%3D1927451027%2C3617440677%26fm%3D214%26gp%3D0.jpg)
**图片来源网络**

我们发现二的幂次方维护的值从开头开始的，假设我们现在在8这个点，维护的是8的前缀和，但这个值已经比k大了，不满足最小，所以我们跳到4，其实就相当于往左儿子走，假如5是符合要求的，那我们从4跳到6(+$2^1$)发现不可以，再跳到5($+2^0$)发现可以，之后返回，所以时间复杂度是和$logn$有关的，总以通过

接下来是代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=100050;
inline int read()
{
	int x=0,t=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')t=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();
	return x*t;
}
int n,q[maxn],a[maxn],p[maxn],tot=0,c[maxn];
int hash(int x){return lower_bound(q+1,q+1+tot,x)-q;}
int lowbit(int x){return x&-x;}
void add(int x,int p)
{
	while(x<=tot)
	{
		c[x]+=p;
		x+=lowbit(x);
	}
}
int sum(int x)
{
	int res=0;
	while(x)
	{
		res+=c[x];
		x-=lowbit(x);
	}
	return res;
}
int query(int x)
{
	int t=0;
	for(int i=19;i>=0;i--)
	{
		t+=1<<i;
		if(t>tot||c[t]>=x) t-=1<<i;
		else x-=c[t];
	}
	return q[t+1];
}
int main()
{
	n=read();
	for(int i=1;i<=n;i++)
	{
		p[i]=read(),a[i]=read();
		if(p[i]!=4) q[++tot]=a[i];
	}
	//hash
	sort(q+1,q+1+tot);
	tot=unique(q+1,q+1+tot)-(1+q);
	for(int i=1;i<=n;i++)
	{
		if(p[i]==1) add(hash(a[i]),1);
		if(p[i]==2) add(hash(a[i]),-1);
		if(p[i]==3) printf("%d\n",sum(hash(a[i])-1)+1);
		if(p[i]==4) printf("%d\n",query(a[i]));
		if(p[i]==5) printf("%d\n",query(sum(hash(a[i])-1)));
		if(p[i]==6) printf("%d\n",query(sum(hash(a[i]))+1));
	}
	return 0;
} 
```

---

## 作者：ezoixx130 (赞：131)

# 替罪羊树

## 介绍

在众多的平衡树之中，大部分依赖旋转（单旋或双旋）来维持平衡，但是有一些平衡树是不依赖于旋转操作。替罪羊树便是其中一种。

替罪羊树基于一种**暴力重构**的操作来保证平衡，具体来说，就是定义一个平衡因子$alpha$，当某个节点x的某棵子树的$x.ch.size>x.size*alpha$\*时便将这棵以x为根的子树拍扁重构。


 ![](https://cdn.luogu.com.cn/upload/pic/11602.png) 

一个需要重构的例子


## 重构方法

重构的目的是让该子树将变得平衡，那么如何进行重构使得该树变得平衡呢？

具体方法是：

1、将该树拍扁，存入数组或者vector中。


 ![](https://cdn.luogu.com.cn/upload/pic/11603.png) 

拍扁后的样子


2、重新建树（每次取区间中点作为根，然后递归两边为左右子树建树）


 ![](https://cdn.luogu.com.cn/upload/pic/11601.png) 

建树过程


# 时间复杂度分析

这样重构一次的时间复杂度为$O(n)$（n为子树大小），但是实际上替罪羊树的单次插入时间复杂度并不会达到$O(nlogn)$，因为一个$size=t$的子树需要插入$Ω(t)$个点才会被重构，所以可以通过势能分析来证明替罪羊树的单次操作的均摊时间复杂度为$O(logn)$，具体证明这里不详细展开。


## 经典操作

下面来看插入和删除操作：

插入：

插入操作和普通二叉搜索树无大异，唯一不同的是，在递归返回时需要判断该子树是否需要重构。

删除：

这里的删除不是真正意义上的删除，而是给要删除的点打一个标记，在该节点需要被重构时删除掉。

rank和kth操作也无大差别。


## 平衡因子的取值范围：

显然，$alpha$的取值范围在0.5~1的范围内，一般取0.7较为合适。太大的$alpha$会使得树变深，太小则会引起过多的重构。


## 模版代码：

（P3369普通平衡树）

    
    
    
    
    
    
    
    
    
    
    
    
    

```cpp
    #include <bits/stdc++.h>
    using std::vector;
    const double alpha=0.7;
    struct node{
        node *l,*r;
        int val,size,cnt;
        bool deleted;
        bool isbad(){return l->cnt>alpha*cnt+5||r->cnt>alpha*cnt+5;}
        void maintain(){size=!deleted+l->size+r->size;cnt=1+l->cnt+r->cnt;}
    };
    node *null;
    void dfs(node *o,vector<node*> &v)
    {
        if(o==null)return;
        dfs(o->l,v);
        if(!o->deleted)v.push_back(o);
        dfs(o->r,v);
        if(o->deleted)delete o;
    }
    node *build(vector<node*> &v,int l,int r)
    {
        if(l>=r)return null;
        int mid=(l+r)>>1;
        node *o=v[mid];
        o->l=build(v,l,mid);
        o->r=build(v,mid+1,r);
        o->maintain();
        return o;
    }
    void rebuild(node* &o)
    {
        vector<node*> v;
        dfs(o,v);
        o=build(v,0,v.size());
    }
    void insert(int x,node* &o)
    {
        if(o==null)
        {
            o=new node;
            o->l=o->r=null;
            o->deleted=false;
            o->size=o->cnt=1;
            o->val=x;
            return;
        }
        else
        {
            ++o->size;
            ++o->cnt;
            if(x>=o->val)
                insert(x,o->r);
            else
                insert(x,o->l);
            if(o->isbad())rebuild(o);
        }
    }
    int rank(node *now,int x)
    {
        int ans=1;
        while(now!=null)
        {
            if(now->val>=x)now=now->l;
            else
            {
                ans+=now->l->size+!now->deleted;
                now=now->r;
            }
        }
        return ans;
    }
    int kth(node *now,int x)
    {
        while(now!=null)
        {
            if(!now->deleted && now->l->size+1==x)
                return now->val;
            if(now->l->size>=x)now=now->l;
            else
            {
                x-=now->l->size+!now->deleted;
                now=now->r;
            }
        }
    }
    void erase(node *o,int rk)
    {
        if(!o->deleted && rk==o->l->size+1)
        {
            o->deleted=1;
            --o->size;
            return;
        }
        --o->size;
        if(rk<=o->l->size+!o->deleted)
            erase(o->l,rk);
        else
            erase(o->r,rk-o->l->size-!o->deleted);
    }
    node *root;
    int main()
    {
        null=new node;
        root=null;
        int n;
        scanf("%d",&n);
        while(n--)
        {
            int op,x;
            scanf("%d%d",&op,&x);
            if(op==1)insert(x,root);
            if(op==2)erase(root,rank(root,x));
            if(op==3)printf("%d\n",rank(root,x));
            if(op==4)printf("%d\n",kth(root,x));
            if(op==5)printf("%d\n",kth(root,rank(root,x)-1));
            if(op==6)printf("%d\n",kth(root,rank(root,x+1)));
        }
    } 

```

---

## 作者：wasa855 (赞：75)

# Treap详解
## Treap=Tree+Heap   
Treap中每个节点有2个值，其中一个满足二叉查找树的性质，一个满足大根堆的性质。把满足二叉查找树性质的值称作```data```，把满足大根堆性质的值称作```value```。 对于Treap来说，当前节点的```data```值大于左儿子，小于右儿子。当前节点的```value```值小于儿子节点的值。    
每个节点的```data```我们无法改变，为了保证Treap的平衡性，我们需要让每个节点的```value```均为随机值，这样我们就可以保证这棵树“基本平衡”。   
## 统计
$up$：计算儿子数
``` cpp
void up(int x)
{
	t[x].siz=t[t[x].left].siz+t[t[x].right].siz+1;
}
```

## 旋转   
![rorate](https://cdn.luogu.com.cn/upload/pic/44303.png)   
右旋就是，让当前节点降为自己的右儿子，让左儿子代替自己，并让自己左儿子的右儿子成为自己的左儿子。    
左旋相反，让当前节点降为自己的左儿子，让右儿子代替自己，并让自己右儿子的左儿子成为自己的右儿子。  
注：代码中的```now```加上了```&```是为了可以在函数中同时更改```now```的值。如上图右旋时，原来```now```指向$A$节点，运行完函数后指向$B$节点。
``` cpp
void right_rorate(int &now)
{
	int tmp=t[now].left;
	t[now].left=t[tmp].right;
	t[tmp].right=now;
	t[tmp].siz=t[now].siz;
	up(now);
	now=tmp;
}
void left_rorate(int &now)
{
	int tmp=t[now].right;
	t[now].right=t[tmp].left;
	t[tmp].left=now;
	t[tmp].siz=t[now].siz;
	up(now);
	now=tmp;
}
```
旋转实例：![Eg](https://cdn.luogu.com.cn/upload/pic/44308.png)   
![eg2](https://cdn.luogu.com.cn/upload/pic/44309.png)
## 插入   
给节点随机分配一个优先级(```value```)，先把要插入的点插入到一个叶子上，然后跟维护堆一样，我们维护一个 **小根堆**，如果当前节点的优先级比它的儿子大就旋转，**如果当前节点是根的左儿子就右旋，如果当前节点是根的右儿子就左旋。**  
``` cpp
void insert(int &now,int data)
{
	if(now==0)
	{
		now=++cnt;
		t[now].siz=1;
		t[now].data=data;
		t[now].value=rand()*rand()%19620817;
		return ;
	}
	t[now].siz++;
	if(data>=t[now].data)
	{
		insert(t[now].right,data);
	}
	else
	{
		insert(t[now].left,data);
	}
	if(t[now].left!=0&&t[now].value>t[t[now].left].value)
	{
		right_rorate(now);
	}
	if(t[now].right!=0&&t[now].value>t[t[now].right].value)
	{
		left_rorate(now);
	}
	up(now);
}
```

## 删除   
因为$Treap$满足堆性质，所以只需要把要删除的节点旋转到叶节点上，然后直接删除就可以了。   
具体的方法：   
如果该节点的左子节点的优先级小于右子节点的优先级，右旋该节点，使该节点降为右子树的根节点，然后访问右子树的根节点，继续操作；    
反之，左旋该节点,使该节点降为左子树的根节点，然后访问左子树的根节点，继续操作，直到变成可以直接删除的节点。 
（即：让```value```的结点旋到上面，满足堆的性质）   
``` cpp
void erase(int &now,int data)
{
	t[now].siz--;
	if(t[now].data==data)
	{
		if(t[now].left==0&&t[now].right==0)
		{
			now=0;
			return ;
		}
		if(t[now].left==0||t[now].right==0)
		{
			now=t[now].left+t[now].right;
			return ;
		}
		if(t[t[now].left].value<t[t[now].right].value)
		{
			right_rorate(now);
			erase(t[now].right,data);
			return ;
		}
		else
		{
			left_rorate(now);
			erase(t[now].left,data);
			return ;
		}
	}
	if(t[now].data>=data)
	{
		erase(t[now].left,data);
	}
	else
	{
		erase(t[now].right,data);
	}
	up(now);
}
```
## 查询排名
显然，若```t[now].data<data```，则在```now```的右子树中仍有部分小于```data```的数，所以在加上```t[t[now].left].siz+1```的同时还需在```now```的右子树中继续递归。反之，则只需在左子树中递归
``` cpp
int rank(int now,int data)
{
	if(now==0)
	{
		return 0;
	}
	if(data>t[now].data)
	{
		return t[t[now].left].siz+1+rank(t[now].right,data);
	}
	return rank(t[now].left,data);
}
```

## 查询排名为$x$的数   
若左子树的大小刚好为$x-1$，则当前节点的```data```即为所求结果。   
若左子树的大小大于$x-1$，则在右子树中递归查找。   
若左子树的大小小于$x-1$，则在左子树中递归查找。   
``` cpp
int find(int now,int rank)
{
	if(rank==t[t[now].left].siz+1)
	{
		return t[now].data;
	}
	if(rank>t[t[now].left].siz+1)
	{
		return find(t[now].right,rank-t[t[now].left].siz-1);
	}
	return find(t[now].left,rank);
}
```

## 查询前驱
函数定义：
``` cpp
int query_pre(int now,int data)
```
若```now==0```，则不存在返回值（```return 0```）。  
若当前节点的值大于等于```data```，则在右子树中找。（必须包含等于！！！）   
若当前节点的值小于```data```，则在左子树中找，若找不到，则返回当前节点的值。（不能有等于！！！）   
``` cpp
int query_pre(int now,int data)
{
	if(now==0)
	{
		return 0;
	}
	if(t[now].data>=data)
	{
		return query_pre(t[now].left,data);
	}
	int tmp=query_pre(t[now].right,data);
	if(tmp==0)
	{
		return t[now].data;
	}
	return tmp;
}
```

## 查询后继
与前驱几乎相同（略）
``` cpp
int query_suf(int now,int data)
{
	if(now==0)
	{
		return 0;
	}
	if(t[now].data<=data)
	{
		return query_suf(t[now].right,data);
	}
	int tmp=query_suf(t[now].left,data);
	if(tmp==0)
	{
		return t[now].data;
	}
	return tmp;
}
```

[洛谷P3369](https://www.luogu.org/problemnew/show/P3369)完整代码：
``` cpp
#include<bits/stdc++.h>
using namespace std;
struct Treap
{
	int data;
	int value;
	int left;
	int right;
	int siz;
};
Treap t[100005];
int cnt;
int root;
void up(int x)
{
	t[x].siz=t[t[x].left].siz+t[t[x].right].siz+1;
}
void right_rorate(int &now)
{
	int tmp=t[now].left;
	t[now].left=t[tmp].right;
	t[tmp].right=now;
	t[tmp].siz=t[now].siz;
	up(now);
	now=tmp;
}
void left_rorate(int &now)
{
	int tmp=t[now].right;
	t[now].right=t[tmp].left;
	t[tmp].left=now;
	t[tmp].siz=t[now].siz;
	up(now);
	now=tmp;
}
void insert(int &now,int data)
{
	if(now==0)
	{
		now=++cnt;
		t[now].siz=1;
		t[now].data=data;
		t[now].value=rand()*rand()%19620817;
		return ;
	}
	t[now].siz++;
	if(data>=t[now].data)
	{
		insert(t[now].right,data);
	}
	else
	{
		insert(t[now].left,data);
	}
	if(t[now].left!=0&&t[now].value>t[t[now].left].value)
	{
		right_rorate(now);
	}
	if(t[now].right!=0&&t[now].value>t[t[now].right].value)
	{
		left_rorate(now);
	}
	up(now);
}
void erase(int &now,int data)
{
	t[now].siz--;
	if(t[now].data==data)
	{
		if(t[now].left==0&&t[now].right==0)
		{
			now=0;
			return ;
		}
		if(t[now].left==0||t[now].right==0)
		{
			now=t[now].left+t[now].right;
			return ;
		}
		if(t[t[now].left].value<t[t[now].right].value)
		{
			right_rorate(now);
			erase(t[now].right,data);
			return ;
		}
		else
		{
			left_rorate(now);
			erase(t[now].left,data);
			return ;
		}
	}
	if(t[now].data>=data)
	{
		erase(t[now].left,data);
	}
	else
	{
		erase(t[now].right,data);
	}
	up(now);
}
int rank(int now,int data)
{
	if(now==0)
	{
		return 0;
	}
	if(data>t[now].data)
	{
		return t[t[now].left].siz+1+rank(t[now].right,data);
	}
	return rank(t[now].left,data);
}
int find(int now,int rank)
{
	if(rank==t[t[now].left].siz+1)
	{
		return t[now].data;
	}
	if(rank>t[t[now].left].siz+1)
	{
		return find(t[now].right,rank-t[t[now].left].siz-1);
	}
	return find(t[now].left,rank);
}
int query_pre(int now,int data)
{
	if(now==0)
	{
		return 0;
	}
	if(t[now].data>=data)
	{
		return query_pre(t[now].left,data);
	}
	int tmp=query_pre(t[now].right,data);
	if(tmp==0)
	{
		return t[now].data;
	}
	return tmp;
}
int query_suf(int now,int data)
{
	if(now==0)
	{
		return 0;
	}
	if(t[now].data<=data)
	{
		return query_suf(t[now].right,data);
	}
	int tmp=query_suf(t[now].left,data);
	if(tmp==0)
	{
		return t[now].data;
	}
	return tmp;
}
int main()
{
	srand(19620817);
	int n;
	cin>>n;
	int opt,data;
	for(int i=1;i<=n;i++)
	{
		scanf("%d %d",&opt,&data);
		if(opt==1)
		{
			insert(root,data);
		}
		if(opt==2)
		{
			erase(root,data);
		}
		if(opt==3)
		{
			printf("%d\n",rank(root,data)+1);
		}
		if(opt==4)
		{
			printf("%d\n",find(root,data));
		}
		if(opt==5)
		{
			printf("%d\n",query_pre(root,data));
		}
		if(opt==6)
		{
			printf("%d\n",query_suf(root,data));
		}
	}
	return 0;
}
```   
注：本文部分图片来自[Brave_Cattle的Blog](https://www.cnblogs.com/BCOI/p/9072444.html)（自己学的时候参考的）

---

## 作者：noip (赞：53)

我说呀

作为一个自认为对平衡树这套理论深有研究的人

对每种平衡树（正常的）做个评价吧

1.RedBlackTree

碾压性的速度优势和代码量

可以分裂合并，但是是log方的，可以可持久化

非常厉害的一个DS

没人写

2.ScapegoatTree

代码量小，随机数据下非常快，然而还是不如RBT

不能分裂合并，可以部分可持久化

但是在卡链的数据或者构造数据下表现就一般了

3.Treap（旋转式）

代码量小，速度较快

不能分裂合并，可以可持久化

挺好的东西

4.Treap（非旋转式）

代码量小，速度非常慢（这个其实看写法，正常人写的都很慢）

可以分裂合并可持久化，功能挺多的

但是速度实在慢

5.Splay

代码量一般，速度非常慢

可以分裂合并，不能可持久化

一般人学的平衡树

6.AVLTree

代码量较大，速度一般

如果修改少查询多的话AVL会很有优势，因为AVL的查询非常快

可以分裂合并，可持久化，但是分裂合并不怎么好写

好像没什么人会？

7.SizeBalancedTree

所谓的“自己发明的平衡树”

反正我感觉就是AVL然后强行重量平衡。。。

论文中他说速度可以吊打红黑树？

然而实际上是被RBT吊打出了一条街

好像还是有些人去学的

8.DigitalSearchTree（其实就是Trie和值域线段树）

效率较高，代码量较低

可以分裂合并，可持久化

但是空间较大，为了解决空间问题可以动态开点（多log）或者离线离散化

9.RRFGT

效率较高，代码量最小

可以分裂合并，可持久化

通用化的数据结构

嘿嘿嘿

10.B树系列

这个我也不会

11.值域分块

效率一般，毕竟有根号

也不是很好写

12.排序向量树（其实就是个vector）

非常好写，复杂度O( nm )。。。

但是因为常数问题所以可以过题

而且查kth是O( 1 ) 的

其他的高论东西希望大家补充

毕竟我很菜，即将退役，基本上也不会什么东西


---

## 作者：Great_Influence (赞：47)

来一发$leafytree$题解。(今年论文新出的神秘数据结构)

当你写二叉平衡树的时候，因为每个节点的儿子数不同导致讨论冗杂，容易出错。并且常用的几个数据结构中，$treap$适用范围较小，$splay$常数巨大且不支持可持久化，替罪羊树等其余数据结构代码量大或复杂，细节多，不易实现。那么，有没有一种神奇的数据结构，能够解决这个问题呢?

~~你为什么不问问神奇海螺呢?~~

答案就是$leafytree$。

$leafytree$是一种奇妙的数据结构。它由叶子节点和辅助节点组成。其主要信息存储在叶子节点上，辅助节点可以理解为线段树的非最后一层节点。这也是它名称的由来。每个辅助节点都有$2$个儿子节点，用来连接整棵树。这样存储可以轻易算出辅助节点共有$n-1$个($n$是叶子节点总数)。因此，它的空间复杂度为$2n$。使用时需要注意空间问题。~~然而1e5的数据只要用9M根本不方~~

#### 1.插入和维护平衡

$leafytree$和其它的二叉搜索树一样，需要保证左边的节点权值大于右边的节点。因此，我们可以选择递归的方法来插入节点。对每个节点其下辖存储区间内的最大值(即右端点)。每次插入时，将左子树的最大点和插入节点的权值作比较。选择节点所属范围的一边即可。插入的时候加入一个叶子节点的同时也会加入一个辅助节点。

然而极易发现，这种插入方法可以被轻松卡成一条链。这样明显是不行的。因此考虑使用一些方法来维护平衡。可以再次引入替罪羊树中的平衡因子思想，如果失衡到某一个子树的$size$比全树的$size$乘上平衡因子还要小，则认为其已经失衡，需要维护。

维护失衡的方法可以选择拍扁重建，也可以选择$rotate$。因为拍扁重建和替罪羊树基本一样，所以在此不再介绍。

考虑用$rotate$来维护平衡。

定义一个节点的平衡度为$\displaystyle\frac{size[l]}{size[x]}$(假设此时左子树比右子树小)。考虑单旋和双旋对平衡度的影响。

例如单旋:(如下图，设$size[Y]>size[a]$)

![此处应有图片](https://cdn.luogu.com.cn/upload/pic/20330.png)

![此处也应有图片](https://cdn.luogu.com.cn/upload/pic/20331.png)

设$X$旋转前的平衡度为$\rho_1$,$Y$旋转前的平衡度为$\rho_2$，旋转后分别为$\gamma_1$和$\gamma_2$。

通过简单计算可以知道:

$\gamma_1=\displaystyle\frac{\rho_1}{\rho_1+(1-\rho_1)\rho_2}$

$\gamma_2=\rho_1+(1-\rho_1)\rho_2$

同理，对于双旋，有:(图见下方)

$\gamma_1=\displaystyle\frac{\rho_1}{\rho_1+(1-\rho_1)\rho_2\rho_3}$

$\gamma_2=\displaystyle\rho_1+(1-\rho_1)\rho_2\rho_3$

$\gamma_3=\displaystyle\frac{\rho_2(1-\rho_3)}{1-\rho_2\rho_3}$

![此处仍然是图片](https://cdn.luogu.com.cn/upload/pic/20333.png)

![此处是另一幅图片](https://cdn.luogu.com.cn/upload/pic/20334.png)

此时考虑对于平衡因子$\alpha$的选取。可以证明，当$\displaystyle\alpha<1-\frac{\sqrt2}{2}$时，可以通过这两种操作来使新的节点平衡度处于$[\alpha,1-\alpha]$之内。当然此时选择$\displaystyle\alpha=1-\frac{\sqrt2}{2}$最合适。

至于维护的方法，就是当发现树失衡时，根据较小树的平衡度$\rho$进行讨论。如果$\displaystyle\rho<\frac{1-2\alpha}{1-\alpha}$时，进行一次单旋。否则进行一次双旋。



我的代码中有一个$newnode$函数和一个$delet$函数，是用来回收节点的，可以不写。



代码:

```cpp
inline bool isr(int x){return x==son[fa[x]][1];}

inline void	rotate(int x)//简单平衡树的旋转操作(一模一样)
{
	static int f,ff,k;f=fa[x];ff=fa[f];k=isr(x);
	son[fa[son[x][k^1]]=f][k]=son[x][k^1];
	son[fa[x]=ff][isr(f)]=x;
	son[fa[f]=x][k^1]=f;
	refresh(f);refresh(x);
	if(f==rt)rt=x;
}

const double alp=1-sqrt(2)/2,lim=(1-2*alp)/(1-alp);

inline void maintain(int x)//保持平衡
{
	static int dir;
	if(son[x][0])//非叶子节点才需要维护平衡
	{
		if(sz[son[x][0]]<sz[x]*alp)dir=1;//找到较小的一个子树
		else if(sz[son[x][1]]<sz[x]*alp)dir=0;
		else return;//没有失衡则跳出
		if(sz[son[son[x][dir]][dir^1]]>=sz[son[x][dir]]*lim)//分情况分类讨论
			rotate(son[son[x][dir]][dir^1]);
		rotate(son[x][dir]);
	}
}

void insert(int now,int x)
{
	if(!rt){rt=newnode(x);return;}//特判根节点
	if(sz[now]==1)//找到叶子结点
	{
		fa[son[now][0]=newnode(x)]=now;//开启新节点，当前叶子结点下放
		fa[son[now][1]=newnode(ma[now])]=now;
		if(x>ma[now])swap(son[now][0],son[now][1]);
	}
	else insert(son[now][x>ma[son[now][0]]],x);//向下递归
	refresh(now);//维护
	maintain(now);
}
```

####2.删除

发现因为节点只会删去叶子结点，所以只需要将结点直接删去，其父亲叶子结点由另一棵子树代替，也被删除。



代码:

```cpp
void del(int now,int x)
{
	int dir=x>ma[son[now][0]],t;
	if(sz[son[now][dir]]==1)//找到叶子结点
	{
		delet(son[now][dir]);//直接删掉
		fa[t=son[now][dir^1]]=fa[now];//用另一棵子树替代辅助节点并删除
		son[fa[now]][isr(now)]=t;
		delet(now);
		if(now==rt)rt=t;//特判根的情况
		now=t;
	}
	else del(son[now][dir],x);//向下递归
	refresh(now);//维护
	maintain(now);
}
```

####3.求结点rank

这个和普通平衡树基本一样。但是因为每个节点的$size$实际上只是叶子结点数量，所以分类讨论的细节大大减少。



代码:

```cpp
int find_by_order(int now,int x)
{
	if(sz[now]==1)return now;//找到叶子结点即返回
	if(sz[son[now][0]]>=x)return find_by_order(son[now][0],x);//递归查找
	else return find_by_order(son[now][1],x-sz[son[now][0]]);
}
```

####4.找到第k大元素

和普通平衡树差不多。同样也少了很多细节。



代码:

```cpp
int order_of_key(int now,int x)
{
	if(x<=mi[now])return 0;//数字不在范围内则返回0
	if(sz[now]==1)return 1;//找到叶子返回1
	if(ma[son[now][0]]>=x)return order_of_key(son[now][0],x);//递归求解
	else return sz[son[now][0]]+order_of_key(son[now][1],x);
}
```

#### 5.查找前驱/后继

直接按照定义来查找就可以了。



代码:

```cpp
int pre(int now,int x)
{
	if(sz[now]==1)return now;
	if(mi[son[now][1]]>=x)return pre(son[now][0],x);
	else return pre(son[now][1],x);
}

int suf(int now,int x)
{
	if(sz[now]==1)return now;
	if(ma[son[now][0]]>x)return suf(son[now][0],x);
	else return suf(son[now][1],x);
}
```

经过测试，本程序速度优秀。在自带大常数情况下，在我自己打的几种不同平衡树中，仅次于$01trie$(如果这也算的话)。



整体代码:

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)
#define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;--i)
#define For(i,a,b) for(i=(a),i<=(b);++i)
#define Forward(i,a,b) for(i=(a),i>=(b);--i)
#define Chkmin(a,b) a=a<b?a:b
#define Chkmax(a,b) a=a>b?a:b
#define pb push_back

inline void read(int &x)
{
    static const int BUFSIZE = 1048576;
    static char buf[BUFSIZE];
    static char *bufnow = buf;
    static char *bufmax = buf;
    if (bufnow == bufmax) {
        bufmax = buf + fread(buf, 1, BUFSIZE, stdin);
        bufnow = buf;
    }
    static int c,f;
    f=1;
    c = *bufnow++;
    for (;!isdigit(c)&&(c^'-');c = *bufnow++) {
            if (bufnow == bufmax) {
            bufmax = buf + fread(buf, 1, BUFSIZE, stdin);
            bufnow = buf;
        }
    }
    if(!isdigit(c)){f=-1;c=*bufnow++;}
    x = 0;
    for (;isdigit(c);c = *bufnow++) {
        x = (x << 1) + (x << 3) + c - 48;
        if (bufnow == bufmax) {
            bufmax = buf + fread(buf, 1, BUFSIZE, stdin);
            bufnow = buf;
        }
    }
    x*=f;
}

inline void write(int a,char ed='\n')
{
	static short s[13],tp;
	if(!a){putchar('0'),putchar(ed);return;}
	for(tp=0;a;a/=10)s[++tp]=a%10;
	for(;tp;putchar(s[tp--]^48));
	putchar(ed);
}
using namespace std;

const int MAXN=2e5+27;

static int n;

namespace leafy_tree
{
	const double alp=1.0-sqrt(2)/2,lim=(1-2*alp)/(1-alp);

	static int sz[MAXN],fa[MAXN],son[MAXN][2],ma[MAXN],mi[MAXN],rt;

	inline void refresh(int h)
	{
		if(son[h][0])
		{
			mi[h]=mi[son[h][0]];ma[h]=ma[son[h][1]];
			sz[h]=sz[son[h][0]]+sz[son[h][1]];
		}
	}

	inline bool isr(int x){return x==son[fa[x]][1];}

	inline void	rotate(int x)
	{
		static int f,ff,k;f=fa[x];ff=fa[f];k=isr(x);
		son[fa[son[x][k^1]]=f][k]=son[x][k^1];
		son[fa[x]=ff][isr(f)]=x;
		son[fa[f]=x][k^1]=f;
		refresh(f);refresh(x);
		if(f==rt)rt=x;
	}

	inline void maintain(int x)
	{
		static int dir;
		if(son[x][0])
		{
			if(sz[son[x][0]]<sz[x]*alp)dir=1;
			else if(sz[son[x][1]]<sz[x]*alp)dir=0;
			else return;
			if(sz[son[son[x][dir]][dir^1]]>=sz[son[x][dir]]*lim)
				rotate(son[son[x][dir]][dir^1]);
			rotate(son[x][dir]);
		}
	}

	static int sta[MAXN],tp;

	inline int newnode(int x)
	{
		ma[sta[tp]]=mi[sta[tp]]=x;sz[sta[tp]]=1;
		return sta[tp--];
	}
	
	void insert(int now,int x)
	{
		if(!rt){rt=newnode(x);return;}
		if(sz[now]==1)
		{
			fa[son[now][0]=newnode(x)]=now;
			fa[son[now][1]=newnode(ma[now])]=now;
			if(x>ma[now])swap(son[now][0],son[now][1]);
		}
		else insert(son[now][x>ma[son[now][0]]],x);
		refresh(now);
		maintain(now);
	}

	inline void delet(int x)
	{son[x][0]=son[x][1]=fa[x]=sz[x]=0;sta[++tp]=x;}

	void del(int now,int x)
	{
		int dir=x>ma[son[now][0]],t;
		if(sz[son[now][dir]]==1)
		{
			delet(son[now][dir]);
			fa[t=son[now][dir^1]]=fa[now];
			son[fa[now]][isr(now)]=t;
			delet(now);
			if(now==rt)rt=t;
			now=t;
		}
		else del(son[now][dir],x);
		refresh(now);
		maintain(now);
	}

	int find_by_order(int now,int x)
	{
		if(sz[now]==1)return now;
		if(sz[son[now][0]]>=x)return find_by_order(son[now][0],x);
		else return find_by_order(son[now][1],x-sz[son[now][0]]);
	}

	int order_of_key(int now,int x)
	{
		if(x<=mi[now])return 0;
		if(sz[now]==1)return 1;
		if(ma[son[now][0]]>=x)return order_of_key(son[now][0],x);
		else return sz[son[now][0]]+order_of_key(son[now][1],x);
	}

	int pre(int now,int x)
	{
		if(sz[now]==1)return now;
		if(mi[son[now][1]]>=x)return pre(son[now][0],x);
		else return pre(son[now][1],x);
	}

	int suf(int now,int x)
	{
		if(sz[now]==1)return now;
		if(ma[son[now][0]]>x)return suf(son[now][0],x);
		else return suf(son[now][1],x);
	}
}

using namespace leafy_tree;

inline void work()
{
	read(n);
	Rep(i,1,(n<<1)+10)sta[i]=i;tp=(n<<1)+10;
	static int opt,x;
	insert(rt,-2147483647);
	insert(rt,2147483647);
	Rep(i,1,n)
	{
		read(opt);read(x);
		switch(opt)
		{
			case 1:insert(rt,x);break;
			case 2:del(rt,x);break;
			case 3:printf("%d\n",order_of_key(rt,x));break;
			case 4:printf("%d\n",ma[find_by_order(rt,x+1)]);break;
			case 5:printf("%d\n",ma[pre(rt,x)]);break;
			case 6:printf("%d\n",ma[suf(rt,x)]);break;
		}
	}
}

inline void file()
{
	#ifndef ONLINE_JUDGE
	freopen("water.in","r",stdin);
	freopen("water.out","w",stdout);
	#endif
}

int main()
{
	file();
	work();
	cerr<<1.0*clock()/CLOCKS_PER_SEC<<endl;
	return 0;
}
```

####ex.leafy tree的其他扩展

$leafy tree$的作用远不止通过模板题。

它能够支持可持久化，且时间复杂度稳定$O(logn)$，常数比$FHQ$要更小。

它能够合并与分裂，时间复杂度为$O(logn)$，且常数比$FHQ$小。

~~总之就是比FHQ好用~~

并且它的形式和线段树相似，区间操作更加简单。

尽早学习，也可以作为一种常数优秀的简单平衡树来使用吧。

---

## 作者：Tibrella (赞：43)

更好的阅读体验 & 后续更新都在[我的博客](https://blog.tibrella.space/post/skip-list/)了，里面还有一份加了泛型的封装跳表类。

## 引入

跳表（跳跃表）能够维护一个数的集合（作用类似普通平衡树），查找时间复杂度为 $\Theta(\log n)$，与平衡树一样基于链表结构。由于不需要平衡树那么多旋转什么的，所以效率比较高，一般认为性能能打红黑树。除此以外，链表的特性使它能够以线性时间遍历某个子段。Redis 的 zset 就是用跳表实现的。

## 定义

![](https://pic.imgdb.cn/item/64e35f5c661c6c8e548c71fb)

上面这个东西叫链表。

我们知道，链表只支持线性时间访问，所以不能二分。我们如果想维护一个有序序列的话，虽然插入删除很快，但是找到一个值对应的位置很慢。

我们又知道，链表的访问形式实际上是一个一个遍历，而它有 $n$ 个元素，这是它 $\Theta(n)$ 复杂度随机访问的根源所在。

那我们是不是可以给链表精简一下呢？比如说，我给链表多加几层，每层减少一半的元素，像这样：

![](https://pic.imgdb.cn/item/64e362b4661c6c8e549b0cc6)

（蓝色方框括起来的是一个节点，实现的时候我们不需要把上面几层显式地建出来，只需要创建对应层的指针即可。）

![](https://pic.imgdb.cn/item/64e36359661c6c8e549d534b)

这样的话，我就能像上图这样找到 $78$ 这个节点了。

橙色路径是原有路径，走了 $4$ 次。而上面的绿色路径只走了 $\log_2 4 = 2$ 个次。好好好，那我这样建的话，我就能在链表上二分了！  
实际上这个东西叫完美跳表。

跳表分两种，一种是上面的完美跳表（暂且这样叫）。这个东西最大的特点就是过于理想化了。如果加上插入删除的话，维护对应层的指针就太难了，每次都得更新。

另一种是基于随机化的跳表。  
要随机化的东西叫做 $level$。一个跳表节点的 $level$，代表着这个节点同时存在于 $1 \sim level$ 层的链表中。比如说，上图的 $1$ 节点 $level = 3$，$23$ 节点 $level = 1$。  
取 $level$ 的方式类似于抛硬币，计算 $level$ 时，如果硬币正面朝上，就 $+1$ 并继续抛；如果反面朝上，则停止。通过这样定下节点 $level$ 的跳表就是我们今天要实现的跳表。

## 基本实现

为了方便演示，这里就不再封装跳表了，其实跟着教程一边走一边封装也是可行的。

### 一些变量

`int level` 记录跳表的最高 level。

`Node head` 为了防止过多的边界的分类讨论，建立一个空结点当头节点。

### 节点

动态分配内存太慢了，如果用动态分配的，我还不如直接 STL。

所以开好数组作为预分配的空间，然后我们可以开一个指针记录分配到了哪一个位置。需要创建新节点的时候直接返回一个 `++tot` 即可。

```cpp
struct Node {
    int key, level;
    Node* nxt[MAX_LEVEL];
} space[N], *tot = space;
```

此处 `level` 的含义是：该节点存在于 0 到 `level` - 1 层的链表中，与前文定义 1 到 `level` 不同。

垃圾回收可以自己实现，待会的整体演示里面会放。

分配一个新节点空间，返回新节点的指针：

```cpp
#define new_node() (++tot)
```

创建一个值为 `key` 高度为 `level` 的节点：

```cpp
Node* create_node(int level, int key) {
    Node* res = new_node();
    res->level = level;
    res->key = key;
    return res;
}
```

### 随机生成 level

前面说了，是抛硬币。

所以我们可以直接借用一些[随机数生成器](https://oi.wiki/misc/random/#%E9%A2%84%E5%AE%9A%E4%B9%89%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8)。

然后我们肯定不能让层数无限大啊，所以需要设置一个 `MAX_LEVEL` 作为最大层数。

```cpp
#define MAX_LEVEL 12

std::random_device seed;
std::minstd_rand rng(seed());

int random_level() {
    int res = 1;
    while (res < MAX_LEVEL && (rng() & 1)) {
        ++res;
    }
    return res;
}
```

本人做了测试，在随机种子 + 1000 次取值的测试下，梅森缠绕和线性同余两种算法通过 `& 1` 求出来的平均值基本上就是 $0.5\pm 0.03$，而且线性同余性能远比梅森缠绕高。然后用 PCG 算法测试了一下，发现 PCG 官方给的 C++ 实现能够做到 $0.5\pm 0.02$，性能接近线性同余，但是这玩意考场上得自己实现，所以还是用线性同余吧。  


### 插入节点

声明：

```cpp
void insert(int key);
```

三步走：找到需要插入的位置，插入节点，更新对应 level 的链表。

首先我们直接从高 level 开始跳，跳不了了就跳低一级的 level 即可找到需要插入的位置。  
同时记录每一个 level 的当前位置之前的节点。（即可能需要更新后向指针的节点）。

```cpp
Node *cur = head;  // current

for (int lev = level - 1; lev != -1; --lev) {
    while (cur->nxt[lev] && cur->nxt[lev]->key < key)
        cur = cur->nxt[lev];  // 存在满足要求的点就跳
    update[lev] = cur;
}
```

细节：可能当前 level 还没有到跳表可能达到的最高 level，但是当前这个节点随机到的 level 值在这两个数中间，所以需要将 `level` 到 `MAX_LEVEL` 这段补全为 `head`：

```cpp
int lev = random_level(); // 当前节点的 level 值
if (lev > level) {
    for (int i = level; i < lev; ++i)
        update[i] = head;

    level = lev;
}
```

创建节点：

```cpp
cur = create_node(lev, key);
```

执行插入操作，即对于每一层链表，更新前一个节点的指针，并让当前节点的后向指针指向后一个节点。

```cpp
for (int i = lev - 1; i > -1; --i) {  // 普通链表插入操作
    cur->nxt[i] = update[i]->nxt[i];
    update[i]->nxt[i] = cur;
}
```

### 删除节点

和插入类似。

```cpp
void erase(int key) {
    nodePointer cur = head;  // current

    for (int lev = level - 1; lev != -1; --lev) {
        while (cur->nxt[lev] && cur->nxt[lev]->key < key)
            cur = cur->nxt[lev];  // 存在满足要求的点就跳
        update[lev] = cur;
    }

    cur = cur->nxt[0];
    for (int i = 0; i < level; ++i)
        if (update[i]->nxt[i] == cur)
            update[i]->nxt[i] = cur->nxt[i];
        else
            break;

    while (level > 1 && !head->nxt[level - 1])  // 更新当前最大层数
        --level;
}
```

额外要注意的是，可能跳表的最高层就这一个节点，删了就没了，所以要判断并更新最大层数。

### 查找结点

实际上上面两个函数的第一部分就相当于查找。

```cpp
bool find(int key) {
    Node* cur;

    for (int lev = level - 1; lev > -1; --lev)
        while (cur->nxt[lev] && cur->nxt[lev]->key < key)
            cur = cur->nxt[lev];  // 存在满足要求的点就跳

    return cur->nxt[0] ? cur->nxt[0]->key == key : false;
}
```

查找前驱后继的方法也差不多，前驱就是查找后直接返回 `cur` 而不是 `cur->nxt[0]`，后继可以跳到 `cur->nxt[lev]->key <= key` 的位置之后返回 `cur->nxt[0]->key`。最后的代码中有体现。

## 随机访问（按排名查询）

上面其实已经实现了跳表的基本功能了，但是显然，目前实现的功能都可以用平衡树替代，而且平衡树还能够按照数的排名查询。

由于维护的是有序序列，所以按照数的排名查询相当于随机访问。

接下来我们来实现跳表的随机访问。具体方法：维护每个后向指针的“跨度”（span），即它跳了几个节点。

形式化来说，设指针 $ptr$ 从第 $a$ 个节点指向第 $b$ 个节点，则 $ptr$ 的跨度为 $b-a$

除此以外，我们还需要维护一个长度 `length`，在每次 `erase` 和 `insert` 的时候加减一下就好了。

### 重写智能指针

~~啥是智能指针？不太清楚，但是我感觉维护一个 span 的指针实在太智能了！~~

我们需要给指针记录一个“跨度”，那就维护一个结构体作为指针，存原来的裸指针和跨度。

总的来说，需要构造函数并重载一个运算符，一个类型转换。

```cpp
struct nodePointer {
    int span;
    Node* pointer;
    nodePointer() {
        this->pointer = nullptr; // 构造函数，将指针初始化为空
    }
    nodePointer(Node* node) {
        this->pointer = node;  // 如果提供了指针就用提供的
    }
    Node* operator->() {
        return pointer; // 指针原有的箭头运算符，访问 nodePointer->x 相当于访问 pointer->x
    }
    operator Node*() const {
        return pointer; // 智能指针转换为裸指针，直接返回 pointer 就好了
    }
};
```

不要在所有地方都使用 `nodePointer`，我们只在需要维护跨度的地方使用就好了。  
编写代码时一定要注意类型的使用，比如说 `unsigned` `long` 不应乱用之类的。如果错误地更新 `span`，而你滥用了 `nodePointer`，可能就没那么容易找到问题了。

博主因为滥用 `unsigned`，跳表调了两天多。

需要维护跨度的地方只有跳转用的指针，即 `nxt[]`。

更改后的代码：

```cpp
struct Node {
    int key, level;
    struct nodePointer {
        int span;
        Node* pointer;
        nodePointer() {
            this->pointer = nullptr; // 构造函数，将指针初始化为空
        }
        nodePointer(Node* node) {
            this->pointer = node;  // 如果提供了指针就用提供的
        }
        Node* operator->() {
            return pointer; // 指针原有的箭头运算符，访问 nodePointer->x 相当于访问 pointer->x
        }
        operator Node*() const {
            return pointer; // 智能指针转换为裸指针，直接返回 pointer 就好了
        }
    };
    nodePointer nxt[MAX_LEVEL];
} space[N];
using nodePointer = typename Node::nodePointer; // 为了方便书写，缩一下
```


### 重写插入函数

开一个数组记录每一层“上一个节点”的位置（利用跨度）。

```cpp
int lst_pos[MAX_LEVEL];
```

然后在函数开头找位置的时候顺便把它处理出来：

```cpp
for (int lev = level - 1; lev > -1; --lev) {
    // 更新 lst_pos
    if (lev == level - 1)
        lst_pos[lev] = 0; // 默认得是 0
    else
        lst_pos[lev] = lst_pos[lev + 1]; // 否则从上一层继承

    while (cur->nxt[lev] && cur->nxt[lev]->key < key) {
        lst_pos[lev] += cur->nxt[lev].span; // 更新
        cur = cur->nxt[lev];  // 存在满足要求的点就跳
    }
    update[lev] = cur;
}
```

插入的时候计算一下就好了。

![](https://pic.imgdb.cn/item/64ecae10661c6c8e54e969bb.webp)

然后 `level` 大于这个节点的指针跨度要加一。

结合代码理解。

```cpp
for (int i = 0; i < lev; ++i) {  // 普通链表插入操作
    cur->nxt[i] = update[i]->nxt[i];
    update[i]->nxt[i].pointer = cur; // 这里不要直接让 nxt[i] = cur，因为后面还要用到 nxt[i].span
    cur->nxt[i].span = update[i]->nxt[i].span - (lst_pos[0] - lst_pos[i]); // lst_pos[0] 实际上就是上一个节点的位置
    update[i]->nxt[i].span = lst_pos[0] - lst_pos[i] + 1;
}
for (int i = lev; i < level; ++i) ++update[i]->nxt[i].span; // 维护高于新节点的指针的跨度
```

别忘了 `++length`。

### 重写删除函数

把要删掉的指针的 `span` 加起来赋值给新指针就好了。

和 `insert` 一样，别忘记比当前节点高的指针跨度要 `-1`。

```cpp
for (int i = 0; i < level; ++i)
    if (update[i]->nxt[i] == cur)
        update[i]->nxt[i].pointer = cur->nxt[i], update[i]->nxt[i].span += cur->nxt[i].span - 1;  // 跨度直接扔给前面那个指针就行了
    else
        --update[i]->nxt[i].span;
```

### 随机访问（按照排名查询）

```cpp
int findrk(int k) {
    assert(k <= length && k); // k 不满足要求就异常
    Node* cur = head;
    for (int lev = level - 1; lev > -1 ; --lev)
        while (cur->nxt[lev] && k - cur->nxt[lev].span > 0) {
            k -= cur->nxt[lev].span;
            cur = cur->nxt[lev];  // 存在满足要求的点就跳
        }
    return cur->nxt[0]->key;
}
```

### 微调

我们可以对 `MAX_LEVEL` 和选取 `level` 的概率进行微调。

比如说下面的普通平衡树代码，把选取层数的 $p$ 改成了 $\frac 14$，即 `(rng() & 1) && (rng() & 1)`，`MAX_LEVEL` 设为了 $7$，经测试这样比较快，在无快读不开 O2 的情况下吊打 Splay/FHQ/Treap，加了快读 O2 之后不知道为啥跑不过我之前写的指针 FHQ 了。另外数组 Treap 始终被吊打。~~这就是指针带给我的自信~~

## 复杂度分析

### 空间复杂度

设定了最高 `level`，所以空间复杂度只能是 $\Theta(n)$ 的。

### 时间复杂度

见 [OI Wiki](https://oi.wiki/ds/skiplist/#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)

## 后记

实际上跳表最大的优点是能够顺序访问，这点是很多平衡树做不到的，FHQ Treap 分裂区间之后中序遍历是可以的，但是常数太大。

**等我把跳表模板题搞出来，他们都得死！**

## 完整代码



```cpp
#include <iostream>
#include <random>

using std::cin;
using std::cout;

using i32 = int;
using i64 = long long;

std::random_device seed;
std::minstd_rand rng(seed());

const i32 MAX_LEVEL = 7;

#define N 100005

struct Node {
    i32 level;
    i64 key;

    struct ptr {
        Node* pointer;
        i32 span;

        ptr() {
            pointer = nullptr;
            span = 0;
        }
        ptr(Node* x) {
            pointer = x;
            span = 0;
        }
        operator Node*() const& {
            return pointer;
        }
        Node* operator->() const& {
            return pointer;
        }
    } nxt[MAX_LEVEL];

} space[N], *rubbin[N];
Node* tot = space;
Node* head = space;
i32 bintop;

#define new_node() (bintop ? rubbin[bintop--] : ++tot)
#define del_node(x) (rubbin[++bintop] = (x))

i32 level;  // global max level now
i32 length;

i32 random_level() {
    i32 res = 1;
    while (res < MAX_LEVEL && (rng() & 1) && (rng() & 1))
        ++res;
    return res;
}

Node* create_node(const i32& level, const i64& key) {
    Node* res = new_node();
    res->key = key;
    res->level = level;
    return res;
}

void insert(const i64& key) {
    Node* cur = head;
    Node::ptr update[MAX_LEVEL];
    i32 lst_pos[MAX_LEVEL + 1];
    lst_pos[level] = 0;

    for (i32 l = level - 1; l > -1; --l) {
        lst_pos[l] = lst_pos[l + 1];

        while (cur->nxt[l] && cur->nxt[l]->key < key) {
            lst_pos[l] += cur->nxt[l].span;
            cur = cur->nxt[l];
        }
        update[l] = cur;
    }

    i32 lev = random_level();

    if (lev > level) {
        for (i32 i = level; i < lev; ++i) {
            update[i] = head;
            update[i]->nxt[i].span = length;
            lst_pos[i] = 0;
        }
        level = lev;
    }

    cur = create_node(lev, key);

    for (i32 i = 0; i < lev; ++i) {
        cur->nxt[i] = update[i]->nxt[i];
        cur->nxt[i].span = update[i]->nxt[i].span - (lst_pos[0] - lst_pos[i]);
        update[i]->nxt[i].pointer = cur;
        update[i]->nxt[i].span = lst_pos[0] - lst_pos[i] + 1;
    }

    for (i32 i = lev; i < level; ++i)
        ++update[i]->nxt[i].span;

    ++length;
}

void erase(const i64& key) {
    Node* cur = head;
    Node::ptr update[MAX_LEVEL];
    for (i32 l = level - 1; l > -1; --l) {
        while (cur->nxt[l] && cur->nxt[l]->key < key)
            cur = cur->nxt[l];
        update[l] = cur;
    }

    cur = cur->nxt[0];

    for (i32 i = 0; i < level; ++i)
        if (update[i]->nxt[i] == cur)
            update[i]->nxt[i].span += cur->nxt[i].span - 1, update[i]->nxt[i].pointer = cur->nxt[i].pointer;
        else
            --update[i]->nxt[i].span;

    while (level > 1 && !head->nxt[level - 1])
        --level;

    del_node(cur);
    --length;
}

i32 get_rk(const i64& key) {
    Node* cur = head;
    i32 res = 0;
    for (i32 l = level - 1; l > -1; --l) {
        while (cur->nxt[l] && cur->nxt[l]->key < key) {
            res += cur->nxt[l].span;
            cur = cur->nxt[l];
        }
    }
    return res + 1;
}

i64 find_by_rk(i32 k) {
    Node* cur = head;
    for (i32 l = level - 1; l > -1; --l) {
        while (cur->nxt[l] && k - cur->nxt[l].span > 0) {
            k -= cur->nxt[l].span;
            cur = cur->nxt[l];
        }
    }
    return cur->nxt[0]->key;
}

Node* prev(const i64& key) {
    Node* cur = head;
    for (i32 l = level - 1; l > -1; --l) {
        while (cur->nxt[l] && cur->nxt[l]->key < key)
            cur = cur->nxt[l];
    }
    return cur;
}

Node* next(const i64& key) {
    Node* cur = head;
    for (i32 l = level - 1; l > -1; --l) {
        while (cur->nxt[l] && cur->nxt[l]->key <= key)
            cur = cur->nxt[l];
    }
    return cur->nxt[0];
}

int main() {
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    i32 n;
    i32 op, x;
    cin >> n;
    while (n--) {
        cin >> op >> x;
        switch (op) {
            case (1): insert(x); break;
            case (2): erase(x); break;
            case (3): cout << get_rk(x) << '\n'; break;
            case (4): cout << find_by_rk(x) << '\n'; break;
            case (5): cout << prev(x)->key << '\n'; break;
            case (6): cout << next(x)->key << '\n'; break;
        }
        // cout.flush();
    }

    return 0;
}
```

## 参考文献

[《跳跃表数据结构与算法分析》](https://juejin.cn/post/7186285617259479098?searchId=202308281935209342639207B2B0163904#heading-5) 纪卓志 George

[《跳表》](https://oi.wiki/ds/skiplist/) OI Wiki


---

## 作者：MyukiyoMekya (赞：35)

~~平衡树的模板题怎么可以用平衡树写呢？~~

本篇题解使用**动态开点权值线段树**，**没有使用任何STL和离线等操作来维护**

不会动态开点权值线段树的同学先去学习

0. 因为值域范围是 $[-1e7,1e7]$，操作个数是 $1e5$ ，所以加入 `1` 个数最多会开 $log_22e7$ 大约 `25` 个节点，所以线段树节点信息数组大小应开到 $25 * 100000 = 2500000$，这里保险开了 $3000000=3*10^6$

操作1和2这里不讲，too simple

1. 操作 `4` ：查询当前节点内第 $k$ 小值时，如果 $k$ 小于等于左子树内数的个数，那么说明第 $k$ 小数在左子树内，直接进去；否则，这个数肯定在右子树内了，这时候我们只要查询右子树内的第 `k - 左子树内数的个数` 小值就行了

2. 操作 `3` ：直接查询 $[-1e7,x-1]$ 范围内有多少数，$+1$ 输出就行了

3. 操作 `5` ：我们先查询出 $[-1e7,x-1]$ 范围内有多少数，设为 $m$，然后用操作 `4` 查询第 `m` 小值就行了

4. 操作 `6` ：和操作 `5` 类似，查询出 $[-1e7,x]$ 范围内有多少数，设为 $m$ ，$x$ 的后继的数当然是第 $m+1$ 小数，所以用操作 `4` 查询第 $m+1$ 小的数就行了

```cpp
// This code wrote by chtholly_micromaker(MicroMaker)
#include <bits/stdc++.h>
#define reg register
using namespace std;
const int MaxN=100050;
const int MaxTR=3000050;
template <class t> inline void read(t &s)	// 快读
{
	s=0;
	reg int f=1;
	reg char c=getchar();
	while(!isdigit(c))
	{
		if(c=='-')
			f=-1;
		c=getchar();
	}
	while(isdigit(c))
		s=(s<<3)+(s<<1)+(c^48),c=getchar();
	s*=f;
	return;
}
#define lson ls[u]
#define rson rs[u]
int val[MaxTR],ls[MaxTR],rs[MaxTR];
int ndcnt=1;
inline void pushup(int u)
{
	val[u]=val[lson]+val[rson];
	return;
}
inline int modify(int &u,int l,int r,int p,int k)
{
	if(!u)
		u=++ndcnt;
	if(l==r)
	{
		val[u]+=k;
		return u;
	}
	reg int mid=(l+r)>>1;
	if(p<=mid)
		modify(lson,l,mid,p,k);
	else
		modify(rson,mid+1,r,p,k);
	pushup(u);
	return u;
}
inline int query(int u,int l,int r,int ql,int qr)
{
	if(!u)
		return 0;
	if(ql<=l&&r<=qr)
		return val[u];
	reg int mid=(l+r)>>1,ans=0;
	if(ql<=mid)
		ans+=query(lson,l,mid,ql,qr);
	if(mid<qr)
		ans+=query(rson,mid+1,r,ql,qr);
	return ans;
}
inline int kth(int u,int l,int r,int k)
{
	if(!u)
		return -1;
	if(l==r)
		return l;
	reg int mid=(l+r)>>1;
	if(k<=val[lson])
		return kth(lson,l,mid,k);
	else
		return kth(rson,mid+1,r,k-val[lson]);
	return -1;
}
signed main(void)
{
	int n;cin>>n;
	reg int opt,x;
	reg int rt=1;
	for(int i=1;i<=n;++i)
	{
		read(opt);read(x);
		if(opt==1)
			modify(rt,-1e7,1e7,x,1);
		else if(opt==2)
			modify(rt,-1e7,1e7,x,-1);
		else if(opt==3)
			printf("%d\n",query(1,-1e7,1e7,-1e7,x-1)+1);
		else if(opt==4)
			printf("%d\n",kth(1,-1e7,1e7,x));
		else if(opt==5)
		{
			reg int t=query(1,-1e7,1e7,-1e7,x-1);
			printf("%d\n",kth(1,-1e7,1e7,t));
		}
		else
		{
			reg int t=query(1,-1e7,1e7,-1e7,x)+1;
			printf("%d\n",kth(1,-1e7,1e7,t));
		}
	}
	return 0;
}
```

---

## 作者：MashPlant (赞：29)

B树的常见使用场景在于文件读写，然而因为其内存的连续性(一个节点内可以存放大量数据)，在节点内进行的二分搜索可以比其他平衡树的搜索速度更快。

大家可以稍微感受一下B树的力量。56ms AC，这是所有真的用平衡树做这道题的提交里面速度最快的。作为对比，我的红黑树是68ms。

这里是完整代码，懒得讲解了，注释里说的都很清楚。

```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
using namespace std;
template <typename K, int BF>
class BTree
{
  public:
    typedef std::pair<K, int> value_type;

  private:
    struct Node
    {
        value_type values[2 * BF - 1];
        Node *child[2 * BF] = {nullptr};
        Node *p = nullptr;
        int keyNum = 0, size = 0;
        bool isLeaf = true;
        const K &key(int i) const { return values[i].first; }
        int &cnt(int i) { return values[i].second; }
        Node(Node *p = nullptr) : p(p) {}
    };
    Node *root = nullptr;
    static bool pairComp(const value_type &lhs, const K &rhs) { return lhs.first < rhs; }
    template <typename T>
    static void shiftBy(T *ptr, int length, int shift) { memmove(ptr + shift, ptr, length * sizeof(T)); }
    static int calcSize(Node *x)
    {
        if (!x)
            return 0;
        int nsz = 0;
        for (int i = 0; i < x->keyNum; ++i)
            nsz += getSize(x->child[i]) + x->cnt(i);
        nsz += getSize(x->child[x->keyNum]);
        return nsz;
    }
    static int getSize(Node *x)
    {
        if (!x)
            return 0;
        return x->size;
    }
    //把where孩子分成两个节点，都作为x的孩子
    void split(Node *x, int where)
    {
        Node *z = new Node(x);
        Node *y = x->child[where];
        z->isLeaf = y->isLeaf;
        memmove(z->values, y->values + BF, (BF - 1) * sizeof(value_type));
        if (!y->isLeaf)
        {
            memmove(z->child, y->child + BF, BF * sizeof(Node *));
            for (int i = 0; i < BF; ++i)
                z->child[i]->p = z;
        }
        z->keyNum = y->keyNum = BF - 1;
        shiftBy(x->child + where + 1, x->keyNum - where, 1); //注意child本身keyNum多一个
        x->child[where + 1] = z;
        shiftBy(x->values + where, x->keyNum - where, 1);
        new (x->values + where) value_type(y->values[BF - 1]);

        y->size = calcSize(y), z->size = calcSize(z);
        ++x->keyNum;
    }
    void insertEmpty(Node *x, const K &key)
    {
        while (true)
        {
            int i = lower_bound(x->values, x->values + x->keyNum, key, pairComp) - x->values;
            if (i != x->keyNum && !(key < x->values[i].first)) //重复插入
            {
                ++x->cnt(i);
                while (x)
                    ++x->size, x = x->p;
                return;
            }
            if (x->isLeaf)
            {
                shiftBy(x->values + i, x->keyNum - i, 1);
                x->values[i] = {key, 1};
                ++x->keyNum;
                while (x)
                    ++x->size, x = x->p;
                return;
            }
            if (x->child[i]->keyNum == 2 * BF - 1)
            {
                split(x, i);
                if (x->key(i) < key)
                    ++i;
                else if (!(key < x->key(i)))
                {
                    ++x->cnt(i);
                    while (x)
                        ++x->size, x = x->p;
                    return;
                }
            }
            x = x->child[i];
        }
    }

    void merge(Node *x, int i) //将x的i孩子与i+1孩子合并，用x的i键作为分隔，这两个孩子都只有BF-1个孩子，合并后有2*BF-1个
    {
        Node *y = x->child[i], *z = x->child[i + 1];
        y->keyNum = 2 * BF - 1;
        y->values[BF - 1] = std::move(x->values[i]);
        memmove(y->values + BF, z->values, (BF - 1) * sizeof(value_type));
        if (!y->isLeaf)
        {
            memmove(y->child + BF, z->child, BF * sizeof(Node *));
            for (int j = BF; j <= 2 * BF - 1; ++j)
                y->child[j]->p = y;
        }
        shiftBy(x->values + i + 1, x->keyNum - i - 1, -1);
        shiftBy(x->child + i + 2, x->keyNum - i - 1, -1);

        --x->keyNum;
        y->size = calcSize(y);
    }
    void erase(Node *x, const K &key)
    {
        int i = lower_bound(x->values, x->values + x->keyNum, key, pairComp) - x->values;
        if (i != x->keyNum && !(key < x->values[i].first)) //找到key了
        {
            if (x->cnt(i) > 1)
            {
                --x->cnt(i);
                while (x)
                    --x->size, x = x->p;
                return;
            }
            if (x->isLeaf) //x是叶节点，直接删除
            {
                shiftBy(x->values + i + 1, --x->keyNum - i, -1); //需要移动的内存是x->keyNum-i-1
                while (x)
                    --x->size, x = x->p;
            }
            else
            {
                if (x->child[i]->keyNum >= BF) //前驱所在孩子有足够的孩子(以应对它的孩子的需求)
                {
                    Node *y = x->child[i];
                    while (!y->isLeaf)
                        y = y->child[y->keyNum]; //找前驱
                    x->values[i] = y->values[y->keyNum - 1];
                    if (x->cnt(i) != 1) //y的对应节点cnt有多个，那么沿路减size;只有一个的话删除的时候会处理
                    {
                        y->cnt(y->keyNum - 1) = 1;
                        while (y != x)
                            y->size -= x->cnt(i) - 1, y = y->p;
                    }

                    erase(x->child[i], x->key(i));
                }
                else if (x->child[i + 1]->keyNum >= BF) //后继所在孩子有足够的孩子
                {
                    Node *y = x->child[i + 1];
                    while (!y->isLeaf)
                        y = y->child[0]; //找后继
                    x->values[i] = y->values[0];
                    if (x->cnt(i) != 1)
                    {
                        y->cnt(0) = 1;
                        while (y != x)
                            y->size -= x->cnt(i) - 1, y = y->p;
                    }

                    erase(x->child[i + 1], x->key(i));
                }
                else //都没有,那么把这两个节点都合并到y中，并且挪动x的孩子和键
                {
                    merge(x, i);
                    if (root->keyNum == 0) //keyNum==0只是没有键了，但是还可能有一个孩子，这时根变成这个孩子
                        root = x->child[i], root->p = nullptr;
                    erase(x->child[i], key);
                }
            }
        }
        else if (!x->isLeaf) //没有找到key,只要保证x->child[i]->keyNum足够多即可无脑递归，然而很难保证
        {
            if (x->child[i]->keyNum == BF - 1)
            {
                Node *y = x->child[i];
                if (i >= 1 && x->child[i - 1]->keyNum >= BF) //左兄弟，取走它的最大孩子
                {
                    //找相邻的兄弟借节点，类似旋转操作,把x的一个键移入要删的key所在孩子，把它的兄弟的一个key和孩子移入x
                    //但是从左还是右借并不完全一样，所以不能一概处理
                    Node *z = x->child[i - 1];
                    shiftBy(y->values, y->keyNum, 1);
                    //是否需要考虑析构的问题？z的keyNum已经减了，不可能再去析构z->values[z->keyNum - 1]了
                    //所以，value的构造必须要用new不能用=，从而避开=的资源释放
                    //但是value的移动似乎应该是bitwise的，考虑std::move
                    new (y->values) value_type(std::move(x->values[i - 1]));
                    new (x->values + i - 1) value_type(std::move(z->values[z->keyNum - 1]));
                    if (!y->isLeaf)
                    {
                        shiftBy(y->child, y->keyNum + 1, 1);
                        y->child[0] = z->child[z->keyNum], y->child[0]->p = y;
                    }

                    --z->keyNum, ++y->keyNum;
                    y->size = calcSize(y), z->size = calcSize(z);
                    erase(y, key);
                }
                else if (i < x->keyNum && x->child[i + 1]->keyNum >= BF) //右兄弟,取走它的最小孩子
                {
                    Node *z = x->child[i + 1];
                    new (y->values + y->keyNum) value_type(std::move(x->values[i]));
                    new (x->values + i) value_type(std::move(z->values[0]));
                    if (!y->isLeaf) //y和z深度一样，isLeaf情况相同
                    {
                        y->child[y->keyNum + 1] = z->child[0], y->child[y->keyNum + 1]->p = y;
                        shiftBy(z->child + 1, z->keyNum, -1);
                    }
                    shiftBy(z->values + 1, z->keyNum - 1, -1);

                    --z->keyNum, ++y->keyNum;
                    y->size = calcSize(y), z->size = calcSize(z);
                    erase(y, key);
                }
                else //两个兄弟都没有节点借,那么将它与随便左右哪个兄弟合并，然而还是要特判一下
                {
                    if (i != 0)
                        --i; //i==0时，y与y+1合并仍放于y；否则y与y-1合并放于y-1
                    y = x->child[i];
                    merge(x, i);
                    if (root->keyNum == 0)
                        root = y, root->p = nullptr;
                    erase(y, key);
                }
            }
            else
                erase(x->child[i], key);
        }
    }

  public:
    BTree() : root(new Node) {}
    void insert(const K &key)
    {
        //沿路向下分裂满节点,每次分裂成左右一半，孩子的中间key留在父亲节点中用于分隔两个新孩子
        //insertEmpty只保证了当前节点有空间(来容纳它的孩子的分裂)，不保证key需要去的孩子节点也有空间
        if (root->keyNum == 2 * BF - 1)
        {
            Node *x = new Node;
            x->isLeaf = false, x->child[0] = root, x->size = root->size; //+1操作由insertEmpty来做
            root->p = x, root = x;
            split(x, 0); //split接受参数：node的满子节点下标
        }
        insertEmpty(root, key);
    }
    void erase(const K &key) { erase(root, key); }
    int next(const K &key)
    {
        Node *x = root;
        int ret;
        while (x)
        {
            int i = lower_bound(x->values, x->values + x->keyNum, key, pairComp) - x->values;
            if (x->values[i].first == key)
                ++i;
            if (i != x->keyNum)
                ret = x->values[i].first;
            x = x->child[i];
        }
        return ret;
    }
    int prev(const K &key)
    {
        Node *x = root;
        int ret;
        while (x)
        {
            int i = lower_bound(x->values, x->values + x->keyNum, key, pairComp) - x->values;
            if (i)
                ret = x->values[i - 1].first;
            x = x->child[i];
        }
        return ret;
    }
    int rank(const K &key)
    {
        Node *x = root;
        int ret = 0;
        while (x)
        {
            if (x->key(x->keyNum - 1) < key)
            {
                ret += x->size - getSize(x->child[x->keyNum]);
                x = x->child[x->keyNum];
                continue;
            }
            for (int i = 0; i < x->keyNum; ++i)
            {
                if (x->key(i) < key)
                    ret += getSize(x->child[i]) + x->cnt(i);
                else if (x->key(i) == key)
                    return ret + getSize(x->child[i]) + 1;
                else
                {
                    x = x->child[i];
                    break;
                }
            }
        }
        return ret;
    }
    int kth(int k)
    {
        Node *x = root;
        while (true)
        {
            for (int i = 0; i <= x->keyNum; ++i)
            {
                //const int csz = getSize(x->child[i]) + (i == x->keyNum ? 1 : x->cnt(i));
                const int lb = getSize(x->child[i]) + 1, ub = getSize(x->child[i]) + (i == x->keyNum ? 1 : x->cnt(i));
                if (k >= lb && k <= ub)
                    return x->key(i);
                if (k < lb)
                {
                    x = x->child[i];
                    break;
                }
                k -= ub;
            }
        }
    }
};
struct io_t
{
    char p[1 << 23], *s;
    char e[1 << 24], *t;
    int a[24];
    io_t() : s(p), t(e)
    {
        //freopen("in.txt", "r", stdin);
        fread(s, 1, sizeof p, stdin);
    }
    ~io_t()
    {
        //freopen("out.txt", "w", stdout);
        fwrite(e, 1, t-e, stdout);
    }
    operator int()
    {
        static int v, j;
        v = 0, j = 0;
        while (*s < '0')
            j = *s++ == '-';
        do
            v = v * 10 + *s++ - '0';
        while (*s > ' ');
        return j ? -v : v;
    }
    void print(int v)
    {
        static int *q = a;
        static int cnt = 0;
        ++cnt;
        if (!v)
            *t++ = '0';
        else
        {
            if (v < 0)
                *t++ = '-', v = -v;
            while (v)
                *q++ = v % 10 + '0', v /= 10;
            while (q != a)
                *t++ = *--q;
        }
        *t++ = '\n';
    }
} ip;
int main()
{
    BTree<int, 35> bt;
    int n = ip, opt, x;
    while (n--)
    {
        opt = ip, x = ip;
        switch (opt)
        {
        case 1:
            bt.insert(x);
            break;
        case 2:
            bt.erase(x);
            break;
        case 3:
            ip.print(bt.rank(x));
            break;
        case 4:
            ip.print(bt.kth(x));
            break;
        case 5:
            ip.print(bt.prev(x));
            break;
        case 6:
            ip.print(bt.next(x));
            break;
        }
    }
    return 0;
}

```

---

## 作者：G我就是菜G (赞：17)

## 本题splay写法
### 1. 思想
平衡树本质就是一颗二叉搜索树，利用旋转保证其查找 $\log n$ 的时间复杂度
每个节点保存 5 个信息：

- $num$ 表示该节点存的数
- $son[0..1]$ 表示左右儿子的编号
- $fa$ 表示该节点的父节点的编号
- $size$ 表示以该节点为根节点的节点个数
- $same$ 表示与该节点数相同的个数

定义如下：
```cpp
int cnt,root,n,i,x,opt,ans,now;
struct node{
    int son[3],fa,num,size,same;
}t[2000010];
```

同时，该树还有一个超级根节点 $t[0]$，其右节点就是树根

### 2. 功能全解
**1. 跟新当前节点的 $size$ 值（$update$）**

值为其左儿子，右儿子和自己 $same$ 值之和
```cpp
void update(int i)
{
    t[i].size=t[t[i].son[0]].size+t[t[i].son[1]].size+t[i].same;
}
```

**2. 查询这是哪个儿子（$whichson$）**

如果是左儿子就返回0，否则返回1
```cpp
int whichson(int i)
{
    if (t[t[i].fa].son[0]==i) return 0;
    else return 1;
}
```

**3. 旋转（$rotate$）**

旋转分为左旋和右旋

设当前节点为 $i$
1. 左旋

当 $i$ 为左儿子时，需左旋
```cpp
if (!which(x)) then 
{
    t[t[x].son[1]].fa=fa;
    t[p].son[0]=t[x].son[1];
    t[x].son[1]=fa;
}
```

2. 右旋

当 $i$ 为右儿子时，需右旋
```cpp
if (which(x)) then 
{
    t[t[x].son[0]].fa=fa;
    t[p].son[1]=t[x].son[0];
    t[x].son[0]=fa;
}
```

经过观察，我们可把左旋和右旋合在一起（自己体会）
```cpp
void rotate(int x)
{
    int fa=t[x].fa,gfa=t[fa].fa;
    int whichx=whichson(x),whichfa=whichson(fa);
    t[t[x].son[!whichx]].fa=fa;
    t[fa].son[whichx]=t[x].son[!whichx];
    t[x].son[!whichx]=fa;
    t[gfa].son[whichfa]=x;
    t[fa].fa=x;
    t[x].fa=gfa;
    update(fa);update(x);
}
```

**4. Spaly（核心操作）**

每次查询/插入操作以后都要把新节点旋转到根节点，保证其深度为 $\log n$

用 $splay(x,y)$ 表示把 $x$ 结点转到 $y$ 结点下面

每次旋转判断 $whichson(x)$ 是否与 $whichson(t[x].fa)$ 相等

如果相等，则先旋转 $t[x].fa$，再旋转 $x$

如果不等，则先旋转 $x$，再旋转 $x$

否则会形成单选，无法保证深度为 $\log n$（不懂得同学可以自己拿一条链式数据试一下）
```cpp
void splay(int x,int y)
{
    int fa,gfa;
    if (x==y) return;
    while (t[x].fa!=y)
    {
        fa=t[x].fa;gfa=t[fa].fa;
        if (gfa!=y)
        {
            if (whichson(fa)==whichson(x)) rotate(fa);
            else rotate(x);
        }
        rotate(x);
    }
    if (!y) root=x;
}
```

**5. 插入（insert）**

设当前节点为 $i$，插入的数值为 $x$，当前节点的父亲为 $fa$
1. 当 $i=0$ 时

新加入一个节点
```cpp
if (!i)
{
    nt++;
    t[cnt].fa=fa;
    t[cnt].num=x;t[cnt].size=t[cnt].same=1;
    if (x<t[fa].num) t[fa].son[0]=cnt;
    else t[fa].son[1]=cnt;
    if (cnt==1) root=1;
    now=cnt;
    return;
}
```

当发现 $x$ 已存在
```cpp
if (x==t[i].num)
{
    t[i].size++;t[i].same++;
    now=i;
    return;
} 
```

否则如果 $x<t[i].num$ 则向左，否则向右
```cpp
if (x<t[i].num) insert(t[i].son[0],x,i);
else insert(t[i].son[1],x,i);
update(i);  \\别忘记update
```

**6. 找 $x$ 的排名（findrank）**

和普通二叉查找树一样，如果 $x$ 比 $t[i].num$ 大，则向右走，同时用 $sum$ 记录其排名，否则用 $fa$ 记录改节点，然后向左走，最后 $splay(fa,0)$，返回 $sum$

```cpp
int findrank(int x)
{
    int i=root,sum=0,fa=0;
    while (i)
    {
        if (t[i].num<x)
        {
            sum+=t[t[i].son[0]].size+t[i].same;
            fa=i;i=t[i].son[1];
        }
        else
        {
            fa=i;i=t[i].son[0];
        }
    }
    splay(fa,0);
    return sum;
}
```

**7. 找排名为 $k$ 的节点（findnum）**

发现当前 $k$ 比 $t[t[i].son[0]].size+t[i].same$ 大，则 $k-=t[t[i].son[0]].size+t[i].same$ 向右走，如果 $k\le t[i].same$ 则直接返回 $t[i].num$，否则 $k-=t[i].num$，向左走
```cpp
int findnum(int x)
{
    int i=root,sum=0;
    while (i)
    {
        if (t[t[i].son[0]].size+t[i].same>=x)
        {
            if (t[t[i].son[0]].size<x) return i;
            sum=i;i=t[i].son[0];
        }
        else
        {
            x-=t[t[i].son[0]].size+t[i].same;
            sum=i;i=t[i].son[1];
        }
    }
    return sum;
}
```

**8. 前缀（pred）**

从根节点开始，当 $t[i].num\geq x$ 时，直接向左走，否则用 $sum$ 记录该节点，向右走，最后返回 $sum$
```cpp
int pred(int x)
{
    int i=root,sum=0;
    while (i)
    {
        if (t[i].num>=x) i=t[i].son[0];
        else
        {
            sum=i;i=t[i].son[1];
        }
    }
    return sum;
}
```

**9. 后缀（succ）**

从根节点开始，当 $t[i].num\leq x$ 时，直接向右走，否则用 $sum$ 记录该节点，向左走，最后返回 $sum$
```cpp
int succ(int x)
{
    int i=root,sum=0;
    while (i)
    {
        if (t[i].num<=x) i=t[i].son[1];
        else
        {
            sum=i;i=t[i].son[0];
        }
    }
    return sum;
}
```

**10. 删除（del）**

删除有点复杂，所以我们放在最后，具体是先将 $x$ 的前缀节点 $splay$ 到根节点，然后将 $x$ 的后缀 $splay$ 到根节点下面，然后 $t[t[root].son[1]].son[0]$ 就是 $x$ 节点，同时其左右儿子都是空的，只需要直接删除就行了，同时为了避免没有前后缀的情况，最早要插入 `0x7f7f7f7f`
```cpp
void del(int x)
{
    int predd=pred(x),succc=succ(x);
    splay(predd,0);splay(succc,root);
    int rs=t[root].son[1],rsls=t[rs].son[0];
    if (t[rsls].same>1)
    {
        t[rsls].same--;t[rsls].size--;
    }
    else
    {
        t[rs].son[0]=0;
        t[rsls].same--;t[rsls].size--;
    }
    update(rs);update(root);
}
```

#### 3. 完整代码
```cpp
#include <bits/stdc++.h>

using namespace std;

int cnt,root,n,i,x,opt,ans,now;
struct node{
    int son[3],fa,num,size,same;
}t[2000010];


void update(int i)
{
    t[i].size=t[t[i].son[0]].size+t[t[i].son[1]].size+t[i].same;
}


int whichson(int i)
{
    if (t[t[i].fa].son[0]==i) return 0;
    else return 1;
}


void rotate(int x)
{
    int fa=t[x].fa,gfa=t[fa].fa;
    int whichx=whichson(x),whichfa=whichson(fa);
    t[t[x].son[!whichx]].fa=fa;
    t[fa].son[whichx]=t[x].son[!whichx];
    t[x].son[!whichx]=fa;
    t[gfa].son[whichfa]=x;
    t[fa].fa=x;
    t[x].fa=gfa;
    update(fa);update(x);
}


void splay(int x,int y)
{
    int fa,gfa;
    if (x==y) return;
    while (t[x].fa!=y)
    {
        fa=t[x].fa;gfa=t[fa].fa;
        if (gfa!=y)
        {
            if (whichson(fa)==whichson(x)) rotate(fa);
            else rotate(x);
        }
        rotate(x);
    }
    if (!y) root=x;
}


void insert(int i,int x,int fa)
{
    if (!i)
    {
        cnt++;
        t[cnt].fa=fa;
        t[cnt].num=x;t[cnt].size=t[cnt].same=1;
        if (x<t[fa].num) t[fa].son[0]=cnt;
        else t[fa].son[1]=cnt;
        if (cnt==1) root=1;
        now=cnt;
        return;
    }
    if (x==t[i].num)
    {
        t[i].size++;t[i].same++;
        now=i;
        return;
    }
    if (x<t[i].num) insert(t[i].son[0],x,i);
    else insert(t[i].son[1],x,i);
    update(i);
}


int findnum(int x)
{
    int i=root,sum=0;
    while (i)
    {
        if (t[t[i].son[0]].size+t[i].same>=x)
        {
            if (t[t[i].son[0]].size<x) return i;
            sum=i;i=t[i].son[0];
        }
        else
        {
            x-=t[t[i].son[0]].size+t[i].same;
            sum=i;i=t[i].son[1];
        }
    }
    return sum;
}


int findrank(int x)
{
    int i=root,sum=0,fa=0;
    while (i)
    {
        if (t[i].num<x)
        {
            sum+=t[t[i].son[0]].size+t[i].same;
            fa=i;i=t[i].son[1];
        }
        else
        {
            fa=i;i=t[i].son[0];
        }
    }
    splay(fa,0);
    return sum;
}


int pred(int x)
{
    int i=root,sum=0;
    while (i)
    {
        if (t[i].num>=x) i=t[i].son[0];
        else
        {
            sum=i;i=t[i].son[1];
        }
    }
    return sum;
}


int succ(int x)
{
    int i=root,sum=0;
    while (i)
    {
        if (t[i].num<=x) i=t[i].son[1];
        else
        {
            sum=i;i=t[i].son[0];
        }
    }
    return sum;
}


void del(int x)
{
    int predd=pred(x),succc=succ(x);
    splay(predd,0);splay(succc,root);
    int rs=t[root].son[1],rsls=t[rs].son[0];
    if (t[rsls].same>1)
    {
        t[rsls].same--;t[rsls].size--;
    }
    else
    {
        t[rs].son[0]=0;
        t[rsls].same--;t[rsls].size--;
    }
    update(rs);update(root);
}


int main()
{
    scanf("%d",&n);
    insert(root,0x7f7f7f7f,0);
    insert(root,-0x7f7f7f7f,0);
    for (int i=1;i<=n;i++)
    {
        scanf("%d%d",&opt,&x);
        if (opt==1)
        {
            insert(root,x,0);
            splay(now,0);
        }
        if (opt==2)
        {
            del(x);
        }
        if (opt==3)
        {
            printf("%d\n",findrank(x));
        }
        if (opt==4)
        {
            ans=findnum(x+1);
            printf("%d\n",t[ans].num);
            splay(ans,0);
        }
        if (opt==5)
        {
            ans=pred(x);
            printf("%d\n",t[ans].num);
            splay(ans,0);
        }
        if (opt==6)
        {
            ans=succ(x);
            printf("%d\n",t[ans].num);
            splay(ans,0);
        }
    }
    return 0;
}
```

---

## 作者：灵乌路空 (赞：14)

# 平衡结合

## 引入

[Luogu P3369 【模板】普通平衡树](https://www.luogu.com.cn/problem/P3369)

>您需要写一种数据结构来维护一些数。  
>有 $n$ 次操作，每种操作是下列 6 种之一：  
>1. 插入 $x$ 数。  
>2. 删除 $x$ 数(若有多个相同的数，因只删除一个)。  
>3. 查询 $x$ 数的排名（排名定义为比当前数小的数的个数 +$1$）。  
>4. 查询排名为 $x$ 的数。  
>5. 求 $x$ 的前驱（前驱定义为小于 $x$，且最大的数）。  
>6. 求 $x$ 的后继（后继定义为大于 $x$，且最小的数）。
>
>$1\le n\le 10^5$。

本题显然可使用平衡树，权值线段树等方法维护，它们查询修改的复杂度是平衡的，均为 $O(\log n)$ 级别。  
可以在修改，查询次数同级时获得较优的时间复杂度。  

但在某些情况下，修改与查询次数可能是不平衡的，这时可通过其他手段来处理该问题：  
考虑分块解法，修改 $O(1)$，查询 $O(\sqrt{n})$ ，在修改数大于查询数时，可以获得更优的时间复杂度。  

这就是一种平衡结合。  
根据修改与查询次数的关系，通过调整维护的手段，使总的复杂度达到更低级别。

## 分块解法

操作数量较少，**先对出现的数离散化**，设离散化后值域为 $[1,n]$。  
查询数的排名与某排名对应的数，考虑对值域分块，设块大小为 $T$。  
维护每个数出现的次数，及值域分块后每块内所有数出现的个数。  

操作 1，2，插入删除操作，$O(1)$ 单点修改即可。  

操作 3，查询排名操作，即查询该数左侧所有数的出现次数。  
整块直接查询，散块暴力，复杂度上界 $O(\frac{n}{T} + T)$。  

操作 4，查询某排名对应的数，大力枚举即可。  
从小到大枚举整块，累计维护值域内所有数出现次数之和。  
当累计值 + 最后一个枚举到的整块 $\ge x$ 时，说明答案就在该块中。  
再顺序枚举答案所在整块中的数，累计出现次数直至 $\ge x$ 即得。   
复杂度上界 $O(\frac{n}{T} + T)$。  

操作 5，查询前驱。  
先枚举 $x$ 所在散块内 $< x$ 的数，检查是否存在。  
再枚举 $x$ 之前的整块，直至找到一个内部有数的整块。  
答案就在该整块中，降序枚举找到最大的存在的数即可。  
复杂度上界 $O(\frac{n}{T} + T)$。  

操作 6，查询后继，同操作 5 大力枚举，找到第一个存在的 $>x$ 的数，复杂度相同。


设块大小为 $\sqrt{n}$，操作 3 ~ 6 的复杂度均为 $O(\sqrt n)$，总复杂度上界 $O(n\sqrt{n})$。  
当修改次数 > 查询次数时复杂度较优。

代码

```cpp
//知识点：分块
/*
By:Luckyblock
*/
#include <algorithm>
#include <cctype>
#include <cmath>
#include <cstdio>
#include <cstring>
#define ll long long
const int kMaxn = 1e5 + 10;
const int kMaxSqrtn = 320;
const int kInf = 1e9 + 2077;
//=============================================================
struct Operation {
  int opt, x;
} q[kMaxn];
int n, block_size, block_num, L[kMaxSqrtn], R[kMaxSqrtn], bel[kMaxn];
int cnt[kMaxn], cntblock[kMaxSqrtn];
int data_num, max_data, data[kMaxn], map[kMaxn];
//=============================================================
inline int read() {
  int f = 1, w = 0;
  char ch = getchar();
  for (; !isdigit(ch); ch = getchar())
    if (ch == '-') f = -1;
  for (; isdigit(ch); ch = getchar()) w = (w << 3) + (w << 1) + (ch ^ '0');
  return f * w;
}
void Prepare() { //离线操作，并离散化。
  n = read();
  for (int i = 1; i <= n; ++ i) {
    q[i] = (Operation) {read(), read()};
    if (q[i].opt != 4) data[++ data_num] = q[i].x; //注意操作 4 的参数不需要离散化。
  }
  data[0] = - kInf;
  std :: sort(data + 1, data + data_num + 1);
  for (int i = 1; i <= data_num; ++ i) {
    if (data[i] != data[i - 1]) max_data ++;
    data[max_data] = data[i];
  }
  for (int i = 1; i <= n; ++ i) {
    if (q[i].opt == 4) continue;
    int origin = q[i].x;
    q[i].x = std :: lower_bound(data + 1, data + max_data + 1, q[i].x) - data;
    map[q[i].x] = origin;
  }
}
void PrepareBlock() {
  block_size = (int) sqrt(max_data);
  block_num = max_data / block_size;
  for (int i = 1; i <= block_num; ++ i) {
    L[i] = (i - 1) * block_size + 1;
    R[i] = i * block_size;
  }
  if (R[block_num] < max_data) {
    block_num ++;
    L[block_num] = R[block_num - 1] + 1;
    R[block_num] = max_data;
  }
  for (int i = 1; i <= block_num; ++ i) {
    for (int j = L[i]; j <= R[i]; ++ j) {
      bel[j] = i;
    }
  }
}
void Insert(int val_) { //O(1) 插入
  cnt[val_] ++;
  cntblock[bel[val_]] ++;
}
void Delete(int val_) { //O(1) 删除
  cnt[val_] --;
  cntblock[bel[val_]] --;
}
int QueryRank(int val_) { //查询给定数值的排名
  int belval = bel[val_], ret = 0;
  for (int i = L[belval]; i < val_; ++ i) ret += cnt[i]; //注意 <val_
  for (int i = 1; i < belval; ++ i) ret += cntblock[i];
  return ret + 1;
}
int QueryVal(int rank_) { //查询给定排名对应的数
  int size = 0, ret, belval;
  for (belval = 1; belval <= block_num; ++ belval) {
    if (size + cntblock[belval] >= rank_) break;
    size += cntblock[belval];
  }
  for (ret = L[belval]; ret <= R[belval]; ++ ret) {
    if (size + cnt[ret] >= rank_) break;
    size += cnt[ret];
  }
  return ret;
}
int QueryAhead(int val_) { //查询前驱
  int belval = bel[val_];
  for (int i = val_ - 1; i >= L[belval]; -- i) {
    if (cnt[i]) return i;
  }
  for (int i = belval - 1; i; -- i) {
    if (! cntblock[i]) continue;
    for (int j = R[i]; j >= L[i]; -- j) {
      if (cnt[j]) return j;
    }
  }
}
int QueryBack(int val_) { //查询后继
  int belval = bel[val_];
  for (int i = val_ + 1; i <= R[belval]; ++ i) {
    if (cnt[i]) return i;
  }
  for (int i = belval + 1; i <= block_num; ++ i) {
    if (! cntblock[i]) continue;
    for (int j = L[i]; j <= R[i]; ++ j) {
      if (cnt[j]) return j;
    }
  }
}
void koishi() {
  int satori;
}
//=============================================================
int main() {
  Prepare();
  PrepareBlock();
  for (int i = 1; i <= n; ++ i) {
    int opt = q[i].opt, x = q[i].x;
    if(opt == 1) Insert(x);
    if(opt == 2) Delete(x);
    if(opt == 3) printf("%d\n", QueryRank(x));
    if(opt == 4) printf("%d\n", map[QueryVal(x)]);
    if(opt == 5) printf("%d\n", map[QueryAhead(x)]);
    if(opt == 6) printf("%d\n", map[QueryBack(x)]);
  }
  return 0; 
}
```

## 一个例子

[可能是集训题的无出处题](http://114514.cn)  

>给定一长度为 $n$ 的数列 $a$，参数 $w$，$q$ 次询问。  
>每次询问给定参数 $l,r$，求忽略出现次数 $>w$ 的数后，区间 $[l,r]$ 内第 $k$ 小值。   
>$1\le n,q,a_i,w\le10^5$。 

忽略出现次数 $>w$ 的数，没法上主席树。  
但显然可以莫队套平衡树，当枚举的区间内某个数首次出现时插入，出现次数 $=0$ 或 $> w$ 时删除。  

$n,a_i$ 同级，修改和查询的复杂度相同，均为 $O(\log n)$。  
块大小为 $T$ 时，总复杂度为 $O((\frac{n^2}{T}+qT)\log n + q\log n)$。  
块大小为 $\frac{n}{\sqrt{q}}$ 时最优，总复杂度为 $O(n\sqrt{q}\log n+ q\log n)$，过不了。  

发现块大小为 $T$ 时，莫队中一共有 $\frac{n^2}{T}+qT$ 次修改操作，但只有 $q$ 次查询操作。  
考虑平衡结合，按照上述方法，使用分块维护区间第 $k$ 小值。  
单次修改复杂度变为 $O(1)$，查询变为 $O(\sqrt{n})$，总复杂度 $O(\frac{n^2}{T}+qT + q\sqrt{n})$。  
块大小取 $\frac{n}{\sqrt{q}}$ 时最优，总复杂度为 $O(n\sqrt{q} + q\sqrt{n})$。

## 两个例子

[P4867 Gty的二逼妹子序列](https://www.luogu.com.cn/problem/P4867) 

>给定一长度为 $n$ 的数列 $a$，$m$ 次询问。  
>每次询问给定参数 $l,r,a,b$，求区间 $[l,r]$ 内权值 $\in [a,b]$ 的数的种类数。   
>$1\le a_i\le n\le 10^5$，$1\le m\le 10^6$。

---

发现莫队比较便于维护种类数，套一个莫队消去区间的限制。  
考虑值域的限制，权值线段树进行维护。  
单次 修改/查询 复杂度均为 $O(\log n)$。  
设块大小为 $\dfrac{n}{\sqrt{m}}$，总复杂度为 $O(n\sqrt{m}\log n + m\log n)$。

只有单点修改，考虑对值域分块，维护块内不同的数的个数，可在莫队左右端点移动顺便维护。  
查询时，在查询值域内的完整块直接统计答案，不完整块暴力查询。  
设块大小为 $\dfrac{n}{\sqrt{m}}$，单次修改复杂度 $O(1)$，查询复杂度 $\sqrt{n}$，总复杂度为 $O(n\sqrt{m} +m\sqrt{n})$。

代码详见：[我的 Blog](https://www.cnblogs.com/luckyblock/p/13611018.html)。

---

## 作者：tiger2005 (赞：14)

这道题大家使用的都是常见平衡树吧……

我这里提供一个Trie树的解法吧。

> 字典树，又称单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。    From Baidu

我们可以设置一个基数base，将需要处理的数表示为base进制数，然后可以建立一个储存数组的Trie树

也就是说，在base为2的情况下，我们将读入的数字强制转换为定长的二进制数，然后根据每一位的数值判断走向，走到对应的位置。

在本代码中，base设置为2（主要是考虑到代码容易写）

每个节点需要维护的值如下:

```
maxx[u]  :以该节点为根 的Trie子树中 所有叶子节点 储存的数 的最大值
minn[u]  :以该节点为根 的Trie子树中 所有叶子节点 储存的数 的最小值
siz[u]   :以该节点为根 的Trie子树中 叶子节点 的个数
pcs[u]   :该节点储存的数出现了多少次(仅叶子节点)
number[u]:该节点代表的数字(仅叶子节点)
```

添加操作其实很明显了，拿出数的每一个二进制位，之后添加节点并走下去，最后更改叶子节点信息。

代码如下：

```cpp
void add_number(int u){
	int p=u,curr=1; //curr表示当前节点
	for(int i=depth-1;i+1;i--){
		int v=(p>>i)&1;//该位
		if(!c[curr][v])	c[curr][v]=++idx,fa[idx]=curr;
                //在没有对应节点的时候，新建一个
		maxx[curr]=max(maxx[curr],u);//沿途更新max值
		minn[curr]=min(minn[curr],u);//这是min值
		++siz[curr];curr=c[curr][v];//记录size并往下走
	}
	++siz[curr];number[curr]=u;++pcs[curr];maxx[curr]=minn[curr]=u;
        //保存叶节点的信息
}
```

删除也是类似的，我们可以沿着路径往下走，找到该叶子节点对其操作即可。

但是，max和min不能在向下的过程中改变，因为你无法知道这个节点会不会被完全删除（也就是对应数的数量为0）

所以，采用线段树的push_up算法，将max和min向上推，就能得到真正的max和min了。

代码如下

```cpp
void del_number(int u){
	int p=u,curr=1;
	for(int i=depth-1;i+1;i--){
		int v=(p>>i)&1;
		if(!c[curr][v])	return;
		curr=c[curr][v];
	}//以上同前面的添加操作
	--pcs[curr];--siz[curr];//改变pcs和siz
	if(pcs[curr]==0)	maxx[curr]=-1,minn[curr]=0x3f3f3f3f;
        //没有对应数字的时候，设置最值为极端值
	for(curr=fa[curr];curr;curr=fa[curr]){
		--siz[curr];//更改大小
		maxx[curr]=max(maxx[c[curr][0]],maxx[c[curr][1]]);
		minn[curr]=min(minn[c[curr][0]],minn[c[curr][1]]);
        	//改变最大值和最小值
	}
}
```

查询rank需要siz数组辅助。

我们知道，在一个分叉的地方（不妨假设1边在右边，0边在左边），右边任意一个数都比左边任意一个数大。

---

证明：在此处开始分叉，说明之前的二进制位相同，所以前面的二进制位可以忽略。

去掉这些不影响判断的位后，右边的数最高位为1，左边的数最高为为0。

又因为两者的二进制长度相同（等长的二进制数去除相等的位数），那么右边的数就比左边的数大了。

---

我们看回问题，我们还是顺着二进制位往下走，当一个二进制位为1的时候，我们可以将答案加上左子树大小，因为这些数都比询问的数更小。

最后得出的答案就是小于询问数的数个数，加上1输出就行了。

代码：

```cpp
int rk(int u){
	int p=u,curr=1,ret=0;
	for(int i=depth-1;i+1;i--){
		int v=(p>>i)&1;
		if(v)	ret+=siz[c[curr][0]];//是1的时候加上左子树大小
		if(!c[curr][v])	return ret+1;//子树为空的时候直接返回
		curr=c[curr][v];//跳到子树
	}
	return ret+1;
}
```

查询第几个数也是需要siz函数的。根据刚才的证明，在一个节点下，右边的数都是偏大的，那么左边的数就是以该节点为子树中较小的数。

我们径直向下走，当左子树的大小大于等于询问数的话，我们就可以大胆的往左子树走。否则，我们就将询问数减去左子树大小，跳到右子树。这个方法的正确性是显然的，有兴趣的可以自己证明一下。

代码：

```cpp
int dfn(int u){
	int curr=1;//当前位置
	for(int i=depth-1;i+1;i--){
		if(siz[c[curr][0]]<u)	u-=siz[c[curr][0]],curr=c[curr][1];
        	//在左子树大小较小的时候，跳到右子树
		else	curr=c[curr][0];
        	//否则，跳到左子树
	}
	return number[curr];
	//返回
}
```

查询前驱后继就要使用max和min了，因为这个判断不那么简单。

我们在这里只看后继，前驱同理。

我们首先可以证明，假如在寻找后继的时候，已经确定下来的前几位和询问数的前几位不一样，那么我们只用放心取这个子树的最小值就行。

为什么？因为寻找后继的过程中，确定下来的前几位应该不小于比询问数的前几位，那么根据前面的理论，剩下的数怎么取都比询问数大，之后就是根据后继中“最小”的定义，得到我们的命题是成立的。

代码如下：

```cpp
int next(int u){
	int p=u,curr=1;
	bool flag=false; //前几位是否不一样
	for(int i=depth-1;i+1;i--){
		int v=(p>>i)&1;
		if(flag)	v=(siz[c[curr][0]]?0:1);
		//不一样？尽量往左走！
		else if(v==0 && (siz[c[curr][v]]==0 || maxx[c[curr][v]]<=u))	v=1,flag=true;
		//我们取不一样只有在“走投无路”的时候
		//因为我们要尽量贴边走
		//“走投无路”有两种情况
		//1:左子树没有数
		//2:左子树的最大值比询问数还要小
		curr=c[curr][v];
	}
	return number[curr];
	//结束
}
```

前驱对称处理，代码详见最后的代码。

最后就是真正的代码了。

P.S. :由于负数在二进制里面非常难搞，本人建议直接转换为自然数处理。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int depth=30,maxi=100010;
int c[maxi*depth][2],idx=1,fa[maxi*depth];
int number[maxi*depth],pcs[maxi*depth],siz[maxi*depth];
int maxx[maxi*depth],minn[maxi*depth],N;
void add_number(int u){
	int p=u,curr=1;
	for(int i=depth-1;i+1;i--){
		int v=(p>>i)&1;
		if(!c[curr][v])	c[curr][v]=++idx,fa[idx]=curr;
		maxx[curr]=max(maxx[curr],u);
		minn[curr]=min(minn[curr],u);
		++siz[curr];curr=c[curr][v];
	}
	++siz[curr];number[curr]=u;++pcs[curr];maxx[curr]=minn[curr]=u;
}
void del_number(int u){
	int p=u,curr=1;
	for(int i=depth-1;i+1;i--){
		int v=(p>>i)&1;
		if(!c[curr][v])	return;
		curr=c[curr][v];
	}
	--pcs[curr];--siz[curr];
	if(pcs[curr]==0)	maxx[curr]=-1,minn[curr]=0x3f3f3f3f;
	for(curr=fa[curr];curr;curr=fa[curr]){
		--siz[curr];
		maxx[curr]=max(maxx[c[curr][0]],maxx[c[curr][1]]);
		minn[curr]=min(minn[c[curr][0]],minn[c[curr][1]]);
	}
}
int rk(int u){
	int p=u,curr=1,ret=0;
	for(int i=depth-1;i+1;i--){
		int v=(p>>i)&1;
		if(v)	ret+=siz[c[curr][0]];
		if(!c[curr][v])	return ret+1;
		curr=c[curr][v];
	}
	return ret+1;
}
int dfn(int u){
	int curr=1;
	for(int i=depth-1;i+1;i--){
		if(siz[c[curr][0]]<u)	u-=siz[c[curr][0]],curr=c[curr][1];
		else	curr=c[curr][0];
	}
	return number[curr];
}
int prev(int u){
	int p=u,curr=1;
	bool flag=false;
	for(int i=depth-1;i+1;i--){
		int v=(p>>i)&1;
		if(flag)	v=(siz[c[curr][1]]?1:0);
		else if(v && (siz[c[curr][v]]==0 || minn[c[curr][v]]>=u))	v=0,flag=true;
		curr=c[curr][v];
	}
	return number[curr];
}
int next(int u){
	int p=u,curr=1;
	bool flag=false;
	for(int i=depth-1;i+1;i--){
		int v=(p>>i)&1;
		if(flag)	v=(siz[c[curr][0]]?0:1);
		else if(v==0 && (siz[c[curr][v]]==0 || maxx[c[curr][v]]<=u))	v=1,flag=true;
		curr=c[curr][v];
	}
	return number[curr];
}
int main(){
	memset(maxx,-1,sizeof(maxx));
	memset(minn,0x3f,sizeof(minn));
	scanf("%d",&N);
	for(int i=1,a,b;i<=N;i++){
		scanf("%d%d",&a,&b);
		if(a==1)	add_number(b+1e7);
		if(a==2)	del_number(b+1e7);
		if(a==3)	printf("%d\n",rk(b+1e7));
		if(a==4)	printf("%d\n",dfn(b)-(int)1e7);
		if(a==5)	printf("%d\n",prev(b+1e7)-(int)1e7);
		if(a==6)	printf("%d\n",next(b+1e7)-(int)1e7);
	}
	return 0;
}
```

---

## 作者：hicc0305 (赞：11)

## 非旋转treap了解一下

个人觉得比旋转treap好打很多，不用搞来搞去转来转去。。

非旋转treap主要通过两个操作:合并(merge)，分离(divide)完成几乎这里的所有操作（除了查询排名）。

### Merge
首先我们要知道，我们不能随便合一下，我们要维护Treap的性质，也就是二叉查找树+堆。以一个随机的key值来维护堆，结点的权值val来维护二叉查找树。

我们已知棵子树的根l和r(l<r)，我们比较l和r的key值，因为我们维护的是一个小根堆，如果l的key比较小，让l为合并的树的根结点，然后r往l的右子树递归。反之，r把l踢下去，r为根结点，然后l往r的左子树递归。比如说l做了根结点，r也找到了合适的位置，那么我们可以把r直接接上去了，然后把原来l上的被踢掉的部分取出来，往刚接上去的部分在重新找它的位置。。借来借去，踢来踢去，最后接好的结点越来越多。。然后就合完了。。

图：

![](https://cdn.luogu.com.cn/upload/pic/27744.png)

具体可以看代码：
```cpp
int merge(int l,int r)
{
	if(!l) return r;//l没有了，全部合完了那么r接上即可，返回根r
	if(!r) return l;//同理
	if(tr[l].key<tr[r].key)//l的key小，l当当前子树的根
	{
		tr[l].ch[1]=merge(tr[l].ch[1],r);//往右子树递归
		update(l);
		return l;
	}
	else
	{
		tr[r].ch[0]=merge(l,tr[r].ch[0]);
		update(r);
		return r;
	}
}
```

### Divide
就是把权值小于等于k的结点全部分在一个子树l中，大于的分在另一个子树r中。其实就是按照二分查找的方式向下找，当前结点小于k的话往右子树找，然后当前结点加入左子树。反一下就不讲了

恕我不一步一步画了：

![](https://cdn.luogu.com.cn/upload/pic/27752.png)

```cpp
void divid(int u,int x,int &l,int &r)//注意取地址符，传过来的参数会跟着更新
{
	if(!u)
	{
		l=0,r=0;
		return;
	}
	if(tr[u].val<=x) l=u,divid(tr[u].ch[1],x,tr[u].ch[1],r);//这里很巧妙，也就是让x的右子结点变成右子节点的右子树中，被分出来的左子树的根。好绕。。。
	else r=u,divid(tr[u].ch[0],x,l,tr[u].ch[0]);//反过来一样的
	update(u);
}
```
### Insert
以权值k为分界值，分出左子树l和右子树r，在把这三个东西重新合并起来，两两合并merge(merge(l,k),r)，插入完成。这应该不用画图也能懂。

### Delete
以k为分界值，分出l,p，在l里，在以k-1为分界值分出，l,r，这样把k分离了出来（比k小的，比k大的，都分出去了），然后，合并k的左右子树，形成新的r，再把l,r,合并即可。

图：
![](https://cdn.luogu.com.cn/upload/pic/27765.png)

### 求k的排名
把整棵树以k-1为分界值分了，那么小于k的节点全在左树内，输出左树的size即可

### 找第k大
这不用多讲，二叉查找树基本操作，根据每个结点的size（当前子树的结点总数）递归即可
```cpp
int kth(int u,int k)
{
	if(k<=tr[tr[u].ch[0]].siz) return kth(tr[u].ch[0],k);
    else
    {
        if(k==tr[tr[u].ch[0]].siz+1) return u;
        else 
        {
            k-=tr[tr[u].ch[0]].siz+1;
            return kth(tr[u].ch[1],k);
        }
    }
} 
```

### 前驱
把整棵树以k-1为分界值分了，那么小于k的节点全在左树内，在左子树里找到排名为最后的结点权值即可，也就是排名为左子树的siz的点。当然还有合回来。。

### 后继
差不多的，自己想去

## 代码
不多解释了，结合上面应该能看懂
```cpp
#include<ctime>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
int n,root,cnt=0;
struct Treeeeee
{
	int ch[2],fa,val,key,siz;
}tr[100100];
void Add(int x)
{
	cnt++;
	tr[cnt].siz=1,tr[cnt].val=x,tr[cnt].key=rand();
	tr[cnt].ch[0]=tr[cnt].ch[1]=0;
}
void update(int x)
{
	tr[x].siz=tr[tr[x].ch[0]].siz+tr[tr[x].ch[1]].siz+1;
}
void divid(int u,int x,int &l,int &r)
{
	if(!u)
	{
		l=0,r=0;
		return;
	}
	if(tr[u].val<=x) l=u,divid(tr[u].ch[1],x,tr[u].ch[1],r);
	else r=u,divid(tr[u].ch[0],x,l,tr[u].ch[0]);
	update(u);
}
int merge(int l,int r)
{
	if(!l) return r;
	if(!r) return l;
	if(tr[l].key<tr[r].key)
	{
		tr[l].ch[1]=merge(tr[l].ch[1],r);
		update(l);
		return l;
	}
	else
	{
		tr[r].ch[0]=merge(l,tr[r].ch[0]);
		update(r);
		return r;
	}
}
int kth(int u,int k)
{
	if(k<=tr[tr[u].ch[0]].siz) return kth(tr[u].ch[0],k);
    else
    {
        if(k==tr[tr[u].ch[0]].siz+1) return u;
        else 
        {
            k-=tr[tr[u].ch[0]].siz+1;
            return kth(tr[u].ch[1],k);
        }
    }
} 
int main()
{
	int l,r,p;
	srand(time(NULL));
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		int k,x;
		scanf("%d%d",&k,&x);
		if(k==1)
		{
			divid(root,x,l,r);
			Add(x);
			root=merge(merge(l,cnt),r);
		}
		else if(k==2)
		{
			divid(root,x,l,p);
			divid(l,x-1,l,r);
			r=merge(tr[r].ch[0],tr[r].ch[1]);
			root=merge(merge(l,r),p);
		}
		else if(k==3)
		{
			divid(root,x-1,l,r);
            printf("%d\n",tr[l].siz+1);
            root=merge(l,r);
		}
		else if(k==4) printf("%d\n",tr[kth(root,x)].val);
		else if(k==5)
		{
			divid(root,x-1,l,r);
            printf("%d\n",tr[kth(l,tr[l].siz)].val);
            root=merge(l,r);
		}
		else
		{
			divid(root,x,l,r);
            printf("%d\n",tr[kth(r,1)].val);
            root=merge(l,r);
		}
	}
	return 0;
}
```

---

## 作者：first_fan (赞：9)

$\sf\large\text{Size Balanced Tree}$(节点大小平衡树，下简称SBT)是陈启峰在WC2007提出的一种新型平衡树。

SBT的高度为log n，其核心操作maintain()复杂度O(1)，其他操作均为O(log n)，所以是平衡树中非常优秀的一种。其主要通过子树大小来维持其平衡性质。

和其他平衡树一样，SBT支持大部分较为常规的操作：

* "以x为根的子树"在下文中简称为"x子树"

```cpp
insert(x,val):向x子树插入值为val的结点
del(x,val):删除x子树中值为val的结点
find(x,val):查找x子树中值为val的结点
rank(x,val):返回x子树中val的排名
kth(x,k):返回x子树中排名第k的结点(大小排序均可)
pre(x,val):返回x子树中val的前驱
suc(x,val):返回x子树中val的后继
```

$\sf\large\text{1.SBT的结点定义}$

```cpp
#define ls(x) t[x].l
#define rs(x) t[x].r
//下文中的ls,rs均为此处宏定义
struct SBT
{
	int l;//左子树
	int r;//右子树
	int val;//值
	int siz;//子树大小
}t[maxn];
```

SBT有一个特殊的性质需要维护:某子树的大小大于等于其兄弟子树的大小。

直观写出来就是：

```cpp
t[ls(i)].siz>=max(t[rs(rs(x))].siz,t[ls(rs(x))].siz);
t[rs(i)].siz>=max(t[ls(ls(x))].siz,t[rs(ls(x))].siz);
```

$\sf\large\text{2.SBT的左右旋}$

SBT也是需要旋转的，且同样分为左右旋两种。

![](https://i.loli.net/2019/10/20/MU1AmnYzRbjoV6c.png)

我们列出旋转前后的状态，即

```cpp
左旋前:
根:rt	左子树的根:L
右子树的根:R_rt	右子树的子树:R_l,R_r
左旋后:
根:R_rt	右子树的根:R_r
左子树的根:rt	左子树的子树:L,R_l

右旋前:
根:rt	右子树的根:R
左子树的根:L_rt	右子树的子树:L_l,L_r
右旋后:
根:L_rt	左子树的根:L_l
右子树的根:rt	右子树的子树:L_r,R
```

左右旋代码实现：

```cpp
void lrot(int &x)
{
	int y=rs(x);
	rs(x)=ls(y);
	ls(y)=x;
	t[y].siz=t[x].siz;
	t[x].siz=t[ls(x)].siz+t[rs(x)].siz+1;
	x=y;
}

void rrot(int &x)
{
	int y=ls(x);
	ls(x)=rs(y);
	rs(y)=x;
	t[y].siz=t[x].siz;
	t[x].siz=t[ls(x)].siz+t[rs(x)].siz+1;
	x=y;
}
```

$\sf\large\text{3.SBT的维护}$

首先，假设一株满足条件的SBT长这样：

![](https://i.loli.net/2019/10/20/khYEgfinPvxerM3.png)

此时有A.siz,B.siz≤R.siz并且C.siz,D.siz≤L.siz

每当插入一个值的时候，平衡树的平衡性就可能被打破，所以我们要使用O(1)的`maintain(x)`对x子树进行修复操作。

插入后，可能会出现以下的四种情况:

```cpp
* t[ls(ls(x))].siz>t[rs(x)].siz
* t[ls(rs(x))].siz>t[rs(x)].siz
* t[rs(rs(x))].siz>t[ls(x)].siz
* t[rs(ls(x))].siz>t[ls(x)].siz
```

直接分类处理会很复杂。但SBT的对称性质使我们只用讨论两种情况：

$\sf 1.t[ls(ls(x))].siz>t[rs(x)].siz$

看到上图，对于T子树，此时的情况就是A.siz>R.siz，显然此时就导致平衡性质受损。

第一步，我们先将其右旋，得到下面这株可能仍然不满足性质的树：

![](https://i.loli.net/2019/10/20/AGUZCcN69DI2kjo.png)

之所以说可能仍不满足性质，是因为C.siz>B.siz或D.siz>B.siz的情况可能发生，所以有必要再次使用maintain(T)。这样一来，L的右子树就会被多次调整，不过别担心，每次调整都是O(1)的。

$\sf 1.t[rs(ls(x))].siz>t[rs(x)].siz$

（为了直观，此处增加结点数）上述情况在下图中表示为：B.siz>R.siz

![](https://i.loli.net/2019/10/20/8VOo7kwPWxZFQCT.png)

那么对称地，我们先进行左旋，得到：

![](https://i.loli.net/2019/10/20/TMjQJtFUi1aRBXl.png)

不同的是，接下来我们还要进行一次右旋，得到:

![](https://i.loli.net/2019/10/20/rsWMngUahG2qvZw.png)

有同学可能就会问了：左旋右旋过后这棵树就很不稳定了，怎么办？

答：没事，至少图中的小子树还是满足性质的，所以只要maintain一下L和T就可以让L,T子树平衡。最后再来一次maintain(B)即可。

情况3,4与上述两种情况分别相反，对应操作即可，此处不再赘述。

maintain采用递归实现，具有一定的对称美感。

```cpp
void maintain(int &x,bool lr)
{
	if(lr)//左边
	{
		if(t[ls(ls(x))].siz>t[rs(x)].siz)//#1
		{
			rrot(x);
		}
		else if(t[rs(ls(x))].siz>t[rs(x)].siz)//#2
		{
			lrot(ls(x));
			rrot(x);
		}
		else
		{
			return ;
		}
	}
	else//右边
	{
		if(t[rs(rs(x))].siz>t[ls(x)].siz)//#3
		{
			lrot(x);
		}
		else if(t[ls(rs(x))].siz>t[ls(x)].siz)//#4
		{
			rrot(rs(x));
			lrot(x);
		}
		else
		{
			return ;
		}
	}
	maintain(ls(x),1);
	maintain(rs(x),0);
	maintain(x,0);
	maintain(x,1);
}
```

$\sf\large\text{4.插入元素}$

SBT的插入和其他平衡树基本一致,只是向非空子树插入元素时要maintain一下:

```cpp
void insert(int &x,int val)
{
	if(x==0)
	{
		x=++cnt;
		ls(x)=rs(x)=0;
		t[x].siz=1;
		t[x].val=val;
	}
	else
	{
		t[x].siz++;
		if(val<t[x].val)
		{
			insert(ls(x),val);
		}
		else
		{
			insert(rs(x),val);
		}
		maintain(x,val<t[x].val);
	}
}
```

$\sf\large\text{5.查找前驱\&后继}$

查找前驱函数pre()，我们传入三个参数：

* x:当前子树
* p:保存的前驱结点
* val:查找值

```cpp
int pre(int &x,int p,int val)
{
	if(!x)
	{
		return p;
	}
	if(t[x].val>=val)
	{
		return pre(ls(x),p,val);
	}
	else
	{
		return pre(rs(x),x,val);
	}
}
```

后继同理：

```cpp
int suc(int &x,int p,int val)
{
	if(!x)
	{
		return p;
	}
	if(t[x].val>val)
	{
		return suc(ls(x),x,val);
	}
	else
	{
		return suc(rs(x),p,val);
	}
}
```

$\sf\large\text{6.删除元素}$

删除元素的操作与BST的删除基本一致。删除之后maintain也是没有必要的，其原因是：

>虽然不能保证删完后还是SBT，但是树的最大深度不会变化，时间复杂度也并不变化，maintain就显得多余了。

删除有两种主流方法，均可使用：

1.后继替换

```cpp
int del(int &x,int val)
{
	t[x].siz--;
	if(val>t[x].val)
	{
		del(rs(x),val);
		return ;
	}
	else if(val<t[x].val)
	{
		del(ls(x),val);
		return ;
	}
	
	if(ls(x)&&!rs(x))
	{
		int reg=x;
		x=ls(x);
		return reg;
	}
	else if(!ls(x)&&rs(x))
	{
		int reg=x;
		x=rs(x);
		return reg;
	}
	else if(!ls(x)&&!rs(x))
	{
		int reg=x;
		x=0;
		return reg;
	}
	else
	{
		int reg=rs(x);
		while(ls(res))
		{
			reg=ls(reg);
		}
		t[x].val=t[reg].val;
		del(rs(x),t[reg].val);
	}
}//reg是临时暂存变量
```

2.前驱替换


```cpp

int del(int &x,int val)
{
	int reg;
	t[x].size--;
	if((val==t[x].val)||(val<t[x].val&&!ls(x))||(val>t[x].val&&!rs(x)))
	{
		reg=t[x].val;
		if(ls(x)&&rs(x))
		{
			t[x].val=del(ls(x),t[x].val+1);
		}
		else
		{
			x=ls(x)+rs(x);
		}
	}
	else if(val>t[x].val)
	{
		reg=del(rs(x),val);
	}
	else if(val<t[x].val)
	{
		reg=del(ls(x),val);
	}
	return reg;
}
```

$\sf\large\text{7.一系列的查询操作}$

1.最值查询(单向爬树)

```cpp
int extremum(int x,bool minmax)
{
	if(minmax)//最小值
	{
		while(ls(x))
		{
			x=ls(x);
		}//一直向左爬
	}
	else//最大值
	{
		while(rs(x))
		{
			x=rs(x);
		}//一直向右爬
	}
	return t[x].val;
}
```

2.查询第k小

```cpp
int kth(int &x,int k)
{
	int cur=t[ls(x)].siz+1;
	if(cur==k)
	{
		return t[x].val;
	}
	else if(cur>k)
	{
		return kth(ls(x),k);
	}
	else
	{
		return kth(rs(x),k-cur);
	}
}
```

若要查询第k大，则对几个选择结构中的内容进行交换并调整即可。

3.查找排名

```cpp
int rank(int &x,int val)
{
	if(val==t[x].val)
	{
		return t[ls(x)].siz+1;
	}
	else if(val<t[x].val)
	{
		return rank(ls(x),val);
	}
	else
	{
		rank(rs(x),val)+t[ls(x)].siz+1;
	}
}
```

关于树高log n的证明以及maintain时间复杂度O(1)的证明，陈启峰在论文中有提到，详见[此处](https://www.luogu.org/blog/firstfan/SBT-prove)。

最后，以[LuoGu3369](https://www.luogu.org/problem/P3369)作为例题，[SBT的代码实现见此](https://www.luogu.org/paste/1iktxkt4)，用时142ms，已经算是很优秀的平衡树了。

---

## 作者：XYstarabyss (赞：8)

# Part 1：算法介绍

顾名思义，WBLT（Weight Balanced Leafy Tree） 是一种把 WBT（Weight Balanced Tree）和 LT（Leafy Tree）杂交形成的数据结构。

那么什么是 WBT 呢？其实它就是在每一个节点上面储存这个节点下子树大小，通过保持左右子树的大小关系在一定范围来保证树高，以达到平衡的目的。

那么什么是 LT 呢？其实它就是维护的原始信息仅存储在树的 **叶子节点** 上，而非叶子节点仅用于维护子节点信息和维持数据结构的形态的树。广为人知的线段树就是一种 LT。

接下来我们探讨一下 WBLT 的一些性质。

1. WBLT 的每个节点都要记录四个数据：权值 $v$、这个节点下子树大小 $s$、左儿子 $l$、右儿子 $r$。
2. 我们规定每个非叶子节点一定有两个子节点，这个节点要维护其子节点信息的合并。
3. 显然，大部分平衡树每个非叶子节点的右儿子的权值大于等于左儿子的权值。
4. 在 WBLT 中，还有所有非叶子节点的权值等于右儿子的权值。容易推出，每一个节点的权值就是以之为根的子树中的最大权值。

这样听起来 WBLT 很像所有叶子从左到右递增的一棵维护区间最大值的动态开点线段树了。

接下来我们讨论它的操作。为了方便理解，先给出一些定义。

```
#define l(x) t[x].l
#define r(x) t[x].r
const int vr(2);//维护平衡的参数，下面再讲用途
struct wbl{
    int l,r,v,s;
}t[8000005];
```

更新节点编号为 $x$ 的节点的信息的代码。

```
void pushup(int x){
    //如果没有左儿子那么就是叶子节点
    if (!l(x))    return (void)(t[x].s = 1);//叶子大小设定为1
    //如果x是非叶子节点，维护x的s和v
    t[x].s = t[l(x)].s + t[r(x)].s,t[x].v = t[r(x)].v;
}
```

在 $a,b$ 两个节点分别作为左、右儿子连到给定的 $x$ 上的代码。

```
void merge(int &x,int a,int b){
    t[x = ++ cnt] = {a,b,t[b].v,t[a].s + t[b].s};
  //根据上面给的性质建就行了
}
```

使树保持平衡的关键代码。

```
void bal(int x){//检查x的左右子树是否失衡
    if (t[l(x)].s > t[r(x)].s * vr)//如果左子树比右子树大比较多
        merge(r(x),r(l(x)),r(x)),
        l(x) = l(l(x));//这两行为右旋
    else if (t[r(x)].s > t[l(x)].s * vr)//反之
        merge(l(x),l(x),l(r(x))),
        r(x) = r(r(x));//则左旋
}
```
结合图片理解一下。

![](https://cdn.luogu.com.cn/upload/image_hosting/quth9gva.png)

那么如何插入一个节点呢？

```
void ins(int x,int v){//x为当前节点，v为要插入的值
    if (!l(x))//找到叶子了，把这一个节点变成非叶子节点
        t[l(x) = ++ cnt] = {0,0,min(v,t[x].v),1},//在它的左儿子放它原来的值与插入的值中较小的
        t[r(x) = ++ cnt] = {0,0,max(v,t[x].v),1};//在它的右儿子放它原来的值与插入的值中较大的
    else
        ins((t[l(x)].v >= v) ? l(x) : r(x),v);
    //不是叶子继续往下搜，通过将插入值与当前节点值比较来判断应该前往当前节点的左子树还是右子树
    pushup(x),bal(x);//维护数据结构
}
```

是不是还算比较简单？

删除一个节点的代码和插入的长的差不多。

```
void del(int x,int v,int fa){//x为当前节点，v为要【数据删除】的值，注意保存一下当前节点的父亲节点
    if (!l(x)){//找到叶子了
        if (t[l(fa)].v == v)         t[fa] = t[r(fa)];
        else if (t[r(fa)].v == v)    t[fa] = t[l(fa)];
    }//可以理解为插入过程的逆过程，即找到与要删除的值权值相等的一个叶子节点，将它和它的父亲节点删除，并用其父亲的另一个儿子代替父亲的位置。
    else
        del((t[l(x)].v >= v) ? l(x) : r(x),v,x),pushup(x),bal(x);
    //和ins一样
}
```

查找 $v$ 的排名。

```
int rnk(int x,int v){
    if (!l(x))    return 1;//如果都到叶子节点了这个值在这个子树的排名肯定是1
    return (t[l(x)].v >= v) ? rnk(l(x),v) : rnk(r(x),v) + t[l(x)].s;
    //不然将查询值与当前节点值比较来判断应该前往当前节点的左子树还是右子树，如果是右子树排名加上左子树的大小
}
```

查询第 $s$ 大的数。

```
int kth(int x,int s){
    if (t[x].s == s)    return t[x].v;//如果到的这个子树大小与s一样那么第s大的数就是当前节点的权值，因为“每一个节点的权值就是以之为根的子树中的最大权值”。
    return (t[l(x)].s >= s) ? kth(l(x),s) : kth(r(x),s - t[l(x)].s);
    //不然将查询值与当前节点左儿子的s比较来判断应该前往当前节点的左子树还是右子树，如果是右子树要求的子树大小减去左子树的大小
}
```

然后……就写完了？？？极短平衡树实现？？？

# Part 2：正确性证明

首先 WBLT 达到理想的满二叉树平衡状态时有 $2 \times n - 1$ 个节点，树高为 $\log_2(n) + 1$，所以一次操作理论上平均最坏的时间复杂度为 $\log_2(n) + 1$，约为 $\log n$。

然后注意到 WBLT 维护平衡的方式与 WBT 一样，所以它保持平衡方式的正确性可由 WBT 的 $\alpha$- 平衡得证。$\alpha$- 平衡是啥？可以参考 [这个](https://oi-wiki.org/ds/wblt/#%E7%BB%B4%E6%8A%A4%E5%B9%B3%E8%A1%A1)，如果您很奆还可以参考 [这个](https://yoichihirai.com/bst.pdf)。据之所述，WBLT 的时间复杂度在本题就为 $O(n\log n)$，我就不再赘述了。

然后根据 $\alpha$- 平衡，文中的`vr`实际上是 $\frac{1}{\alpha}$，即重构参数的倒数。文中平衡方式只写了单旋，平均速度很不错，但是时间复杂度有可能在毒瘤数据下假掉。可以考虑写双旋做法以更好地维护平衡。

双旋代码如下（建议看懂了上文中的单旋操作再看这个带双旋的操作）：

```
const int vr(3),vr2(2);
void rot(int x,bool flag){//旋，flag为0为右旋，为1为左旋
    if (!flag)
        merge(r(x),r(l(x)),r(x)),
        l(x) = l(l(x));
    else
        merge(l(x),l(x),l(r(x))),
        r(x) = r(r(x));
}
#define a(x,y) ((y) ? t[x].r : t[x].l) //简写
void bal(int x){//新的维护平衡代码
    f(0,1,i)//考虑两种情况，下面仅以i = 0的情况为例
        if (t[a(x,i)].s > t[a(x,i ^ 1)].s * vr){//如果x的左子树比右子树大得多
            if (t[a(a(x,i),i ^ 1)].s > t[a(a(x,i),i)].s * vr2)//如果x左子树的右子树比x左子树的左子树大得多（避免旋转后仍然不平衡）
                rot(a(x,i),i ^ 1);//先左旋一下x的左子树（在较大子树上先进行一次相反的旋转操作）
            return rot(x,i);//右旋x
        }
}
#undef a //关掉简写
```

这个 `vr2` 又是什么东西呢？它就是 $\alpha$- 平衡中的 $\frac{1 - 2\alpha}{1 - \alpha}$，维护双旋用的。

WBLT 的优缺点：

优点：实现简单，常数小，支持区间操作，可持久化，可以分裂和合并，总体来说是比较优秀的平衡树。

缺点：需要约两倍的空间，如果不注意垃圾回收，及时回收无用的节点（像我一样）就无法保证空间是线性的。

那怎么样垃圾回收呢？

其实很简单。你先开个栈（垃圾桶）：

```
int stk[200005],top(0);
```

把类似于 `t[x = ++ cnt] = {a,b,c,d}` 的代码全部改成 `t[x = ((top) ? (stk[top --]) : (++ cnt))] = {a,b,c,d}`，意义为如果垃圾桶里面还有点编号先用垃圾桶里的，不然再额外开点。

注意一下代码中有哪些地方抛弃了节点，如

```
merge(r(x),r(l(x)),r(x)),
l(x) = l(l(x));
```

这个右旋代码很明显抛弃了节点`l(x)`，所以我们要将它改成

```
merge(r(x),r(l(x)),r(x)),
stk[++ top] = l(x)/*垃圾要扔到垃圾桶里面*/,l(x) = l(l(x));
```

左旋亦然。

再比如说`del`操作显然要删点，所以

```
if (!l(x)){
    if (t[l(fa)].v == v)         t[fa] = t[r(fa)];
    else if (t[r(fa)].v == v)    t[fa] = t[l(fa)];}
```

改成

```
if (!l(x)){
    stk[++ top] = l(fa),stk[++ top] = r(fa);//垃圾要扔到垃圾桶里面
    if (t[l(fa)].v == v)         t[fa] = t[r(fa)];
    else if (t[r(fa)].v == v)    t[fa] = t[l(fa)];}
```

这样，

```
struct wbl{
    int l,r,v,s;
}t[8000005];
```

就能改成

```
struct wbl{
    int l,r,v,s;
}t[200005];
```

也就不用怕炸空间了。

# Part 3：示例代码

> $Talk ~is ~cheap,show ~me ~the ~code.$


```cpp
#include <bits/stdc++.h>
using namespace std;
#define f(n,m,i) for (register int i(n);i <= m;++ i)
#define nf(n,m,i) for (register int i(n);i >= m;-- i)
#define mf(n,m,i,j) for (register int i(n);i <= m;i += j)
#define nmf(n,m,i,j) for (register int i(n);i >= m;i -= j)
#define dbug(x) cerr << (#x) << ':' << x << ' ';
#define ent cerr << '\n';
#define max(a,b) (((a) > (b)) ? (a) : (b))
#define min(a,b) (((a) < (b)) ? (a) : (b))
#define ll long long
#define gc getchar_unlocked
#define pc putchar_unlocked
#define l(x) t[x].l
#define r(x) t[x].r
int ip(){
    int num(0),fu(1);
    char c(gc());
    while (c < '0' || c > '9'){
        if (c == '-')   fu = -fu;
        c = gc();}
    while (c >= '0' && c <= '9')
        num = num * 10 + c - '0',c = gc();
    return fu * num;
}
void op(int num){
    if (num < 0)    pc('-'),num = -num;
    if (num > 9)    op(num / 10);
    pc(48 ^ (num % 10));
}
int n,opt,rt,cnt;
const int vr(2);
struct wbl{
    int l,r,v,s;
}t[8000005];
void merge(int &x,int a,int b){        t[x = ++ cnt] = {a,b,t[b].v,t[a].s + t[b].s};}
void pushup(int x){
    if (!l(x))    return (void)(t[x].s = 1);
    t[x].s = t[l(x)].s + t[r(x)].s,t[x].v = t[r(x)].v;
}
void bal(int x){
    if (t[l(x)].s > t[r(x)].s * vr)
        merge(r(x),r(l(x)),r(x)),
        l(x) = l(l(x));
    else if (t[r(x)].s > t[l(x)].s * vr)
        merge(l(x),l(x),l(r(x))),
        r(x) = r(r(x));
}
void ins(int x,int v){
    if (!l(x))
        t[l(x) = ++ cnt] = {0,0,min(v,t[x].v),1},
        t[r(x) = ++ cnt] = {0,0,max(v,t[x].v),1};
    else
        ins((t[l(x)].v >= v) ? l(x) : r(x),v);
    pushup(x),bal(x);
}
void del(int x,int v,int fa){
    if (!l(x)){
        if (t[l(fa)].v == v)         t[fa] = t[r(fa)];
        else if (t[r(fa)].v == v)    t[fa] = t[l(fa)];}
    else
        del((t[l(x)].v >= v) ? l(x) : r(x),v,x),pushup(x),bal(x);
}
int rnk(int x,int v){
    if (!l(x))    return 1;
    return (t[l(x)].v >= v) ? rnk(l(x),v) : rnk(r(x),v) + t[l(x)].s;
}
int kth(int x,int s){
    if (t[x].s == s)    return t[x].v;
    return (t[l(x)].s >= s) ? kth(l(x),s) : kth(r(x),s - t[l(x)].s);
}
int main(){
    n = ip(),t[rt = ++ cnt] = {0,0,INT_MAX,1};//建根节点
    f(1,n,i){
        int opt(ip()),x(ip());
        if (opt == 1)         ins(rt,x);
        else if (opt == 2)    del(rt,x,-1);
        else if (opt == 3)    op(rnk(rt,x)),pc('\n');
        else if (opt == 4)    op(kth(rt,x)),pc('\n');
        else if (opt == 5)    op(kth(rt,rnk(rt,x) - 1)),pc('\n');//查前驱相当于查这个值的排名，找第（该排名 - 1）个数。
        else                  op(kth(rt,rnk(rt,x + 1))),pc('\n');//查后继相当于查这个值 + 1的排名，找第该排名个数。注意：可能有多个相等的值，所以要这么写。
    }
    return 0;
}
```

---

## 作者：ACAね (赞：8)

# 指针Splay题解

## 前言
[博客](https://www.luogu.org/blog/LLCSBlog/solution-p3369)食用效果更佳

Splay是像我这样的小蒟蒻一开始学的平衡树。

虽然Splay常数不小，但是功能十分全面，既可以当区间树也可以当平衡树(当然这两者不可兼顾)

看到题解里一堆dalao写数组,但是Splay本来是应该用指针实现的（据说这样常数会小很多）,于是蒟蒻就开始写起了指针Splay。。。

出人意料，数组Splay我一遍A,指针我居然调试了将近一年（真事）~~我果然太蒟了~~。~~似乎明白了大家为什么都不用指针~~。

但是，从一遍遍的调试之间，我还是学到了不少东西，比如如何增加代码的可调试性，如何考虑到方方面面~~以防止RE~~。这可能也是一种进步。最后发现，其实指针Splay也挺好(nan)打，更重要的是，指针也更方便理解。

为了希望大家少走点弯路.~~带大家入调试大坑~~本蒟蒻觉得有必要写一份详细的指针Splay题解.

大部分资料来源于网络。

~~Spaly最快了233~~

## 正文
(本文假设大家都对二叉查找树有基本理解，不再赘述一些常识.~~网上的讲的比我好多了~~)（本文默认节点左小右大）
## 一些前置函数

### 获取节点的大小
```cpp
inline unsigned int size(tree x){return x?x->size:0;}/*防止x为空导致访问NULL的信息(RE)*/
```
### 维护节点大小
```cpp
inline void pushup(tree x){x->size=size(x->ch[0])+size(x->ch[1])+x->cnt;}//一个节点的大小等于它的左子树的大小+右子树大小+本身的个数(可以有重复)
```
### 获取节点是它父亲的那个儿子
```cpp
inline bool wson(tree son,tree par)//0为左儿子，一为右儿子
{
	if(!par)return 0;//父亲为空防止RE
	return par->ch[1]==son;
}
```
### 建立父子关系
```cpp
inline void buildfather(tree son,tree par,bool which)//0表示变为左儿子，1表示变为右儿子
{
	if(son)son->par=par;
	if(par)par->ch[which]=son;
	else root=son;//如果父亲为空，自然其为根。
}
```
### 旋转操作
![](https://cdn.luogu.com.cn/upload/pic/26263.png)

旋转操作是Splay Tree的核心操作
它通过旋转在不破坏BST的性质的情况下，调整树的结构。

图中可以看出C>Q>B>P>A.

我们的目标是将P转到Q的位置

直接交换肯定不行，这破坏了BST的性质。

事实上，我们可以看出，A与C的位置一定是固定的。

P,Q是我们需要交换的节点，所以我们可以通过对B进行换位来保证BST的性质不被破坏。以右旋为例。右图仍然有C>Q>B>P>A.

这样就成功实现了上旋的操作

个人习惯将左右旋转写在一个函数中
```cpp
inline void rotate(tree x)
{
	tree p=x->par,g=p->par;//这里导致我调试了一年。
	bool r=wson(x,p);//本来我仿照的数组的题解，将wson(x)表示x为它的父亲的哪一个孩子。但是旋转过程中父子关系产生了变化，于是就必须提前记录好par,与grandpar.
	buildfather(x,g,wson(p,g));//将x提到p的位置。就必须将g的儿子（p）的位置变成x。所以这里用了wson(p,g).
	buildfather(x->ch[!r],p,r);//x->ch[!r]即为图中的B.
	buildfather(p,x,!r);//将p设为x的儿子，在原来B的位置上
	pushup(p);//这里为什么不需要pushup(x)，Splay函数会给出相关解释
}
```
### Splay操作
Splay是SplayTree的核心操作(废话)。
它通过rotate，单旋与双旋来维护Splay Tree的深度。
如果不理解双旋(或者是Spaly教的忠实信奉着)可以参考[网上资料](https://www.zhihu.com/question/40777845)

这里因为是主要讲解指针，所以不再赘述。
```cpp
inline void Splay(tree x,tree y)//将x转到y的下方
{
	while(x->par!=y)//直到x的父亲是y.
	{
		tree p=x->par,g=p->par;//同rotate及时预处理好p与g.(虽然这里没有必要)
		if(x->par->par!=y)wson(x,p)^wson(p,g)?rotate(x):rotate(p);//如果成一条链就先转p,反之转两次x
        rotate(x);
	}
	pushup(x);//填坑，因为你每一次rotate都将x向上转，那么你的x的size一定会一直改变，所以在rotate里面pushup(x)没有意义。只需要在最后pushup(x)即可。
}
```
### Insert操作
建树时，当然可以预先读入数据构建完美的Splay.
这里只给出Insert.~~毕竟复杂度也没差多少~~
```cpp
inline void insert(int val)
{
	if(!root)//特判root为空情况
	{
		root=new node(val,NULL);
		return;
	}
	for(tree x=root;x;x=x->ch[val>=x->val])//从root向下插入，每次判断应当走哪边
	{
		if(x->val==val)//如果已经有这个元素了。则cnt++.
		{
			x->cnt++;
			Splay(x,NULL);//维护Splay深度
			return;
		}
		if(!x->ch[val>=x->val])//如果到了空，也就是没有这个节点
		{
			x->ch[val>=x->val]=new node(val,x);//新建一个节点，C++的new和delete较慢，这里为了友好一点就不用内存池了233.
			Splay(x->ch[val>=x->val],NULL);
			return;
		}
	}
}
```
### Find操作
同普通BST
```cpp
inline void find(int val)
{
	tree x=root;
	while(x/*root为空*/&&x->ch[val>x->val]/*这里因为要精确查找所以将>=分开成了>与=两种情况*/&&val!=x->val/*找到了*/)x=x->ch[val>x->val];
	if(x)Splay(x,NULL);//记得在每个操作都要Splay
}
```
### Delete操作
这是一个比较复杂的点.

你当然也可以将前驱旋转到根，后继旋转到右子树，然后直接删除右子树的左子树。但这样需要提前插入INF与-INF(或特判)，个人认为比较容易出错，毕竟你的Splay里多了两个节点，findkth(k),需要将k++(INF永远比你大)）

详见注释
```cpp
inline int del(int val)
{
	find(val);//将值为val的点转到根 
	if(root->val!=val)return;//找不到
	tree x=root;
	if(x->cnt>1)x->cnt--;//多于一个。 
	else 
	if(!x-ch[0])//有一子树为空 
	{
		root=x->ch[1];//root转移到另外一边 
		if(root)root->par=NULL;//防止RE. 
		delete x;//回收x 
	}
	else//两子树都非空 
	{
		tree k=x->ch[0];//找到左子树中最大的一个 
		while(k->ch[1])k=k->ch[1];
		Splay(k,x);//将他旋转到左子树的根上 
		root=k,root->par=NULL;//这个时候左子树的右子树肯定为空 
		buildfather(x->ch[1],root,1);//再将右子树转移到左子树的右子树 
		delete x;//回收x 
	}
}
```
这里理解可能有些难度，可以考虑手玩一下。
### kth操作
这个不难，但是一定要画出图，不能想当然!
```cpp
inline int findkth(int k)
{
	tree x=root;
	assert(size(x)>=k);//元素个数一定要至少有k个,且没有第0大 
    assert(k);//你可以选择无视这两句话
	while(x)
	{
		if(size(x->ch[0])+x->cnt>=k&&size(x->ch[0])<k)return x->val;//如果你左子树的大小加上你的个数>=k并且你左子树的大小<k那么你就是第k大
		if(size(x->ch[0])>=k)x->ch[0];//如果左子树大小
		else k-=size(x->ch[0])+x->cnt,x=x->ch[1]; //
	}
	return -2147483647;//出现未知错误 (树的构建可能出现问题)（如果你其他地方正确，这里并不会有用）
}	
```
### 前驱与后继(pre&nxt)操作
前驱就是比你小的最大的一个
后继就是比你大的最小的一个
所以前驱就是左子树的最右一个
后继同理
这里只对于前驱做出说明
```cpp
inline int pre(int val)
{
	insert(val);//插入val,它会被转到root
	tree x=x->root->ch[0];
	while(x->ch[1])x=x->ch[1];//找到比val小的最大的数
	del(val);//再删掉
	return x->val;
}
inline int nxt(int val)
{
	insert(val);
	tree x=x->root->ch[1];
	while(x->ch[0])x=x->ch[0];
	del(val);
	return x->val;
}
```
## 完整代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define IL inline
#define RG register
#define gi getint()
#define pi(k) putint(k)
#define gc getchar()
#define File(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)
IL int getint()
{
    RG int xi=0;
    RG char ch=gc;
    bool f=0;
    while(ch<'0'|ch>'9')ch=='-'?f=1:f,ch=gc;
    while(ch>='0'&ch<='9')xi=(xi<<1)+(xi<<3)+ch-48,ch=gc;
    return f?-xi:xi;
}
IL void putint(int k)
{
    if(k<0)k=-k,putchar('-');
    if(k>=10)putint(k/10);
    putchar(k%10+'0');
}
struct SplayTree{
	struct node;
	typedef node* tree;
	struct node{
		tree ch[2],par;
		int size,val,cnt;
		node(int value,tree fa)
		{
			val=value,par=fa;
			size=1,cnt=1;
			ch[0]=ch[1]=NULL; 
		}
	}*root;
	SplayTree(){root=NULL;}
	inline int size(tree x){return x?x->size:0;}
//	#define size(x) (x?x->size:0)
	inline void pushup(tree x){if(x)x->size=size(x->ch[0])+size(x->ch[1])+x->cnt;}
	inline void buildfather(tree son,tree par,bool which)
	{
		if(son)son->par=par;
		if(par)par->ch[which]=son;
		else root=son;
	}
	inline bool wson(tree son,tree par)
	{
		if(!par)return 0;
		return par->ch[1]==son;
	}
	inline void rotate(tree x)
	{
		tree p=x->par,g=p->par;
		bool r=wson(x,p);
		buildfather(x,g,wson(p,g));
		buildfather(x->ch[!r],p,r);
		buildfather(p,x,!r);
		pushup(p);
	}
	inline void Splay(tree x,tree y)
	{
		while(x->par!=y)
		{
			tree p=x->par,g=p->par;
			if(x->par->par!=y)wson(x,p)^wson(p,g)?rotate(x):rotate(p);
			rotate(x);
		}
		pushup(x);
	}
	inline void insert(int val)
	{
		if(!root)
		{
			root=new node(val,NULL);
			return;
		}
		for(tree x=root;x;x=x->ch[val>=x->val])
		{
			if(x->val==val)
			{
				x->cnt++;
				Splay(x,NULL);
				return;
			}
			if(!x->ch[val>=x->val])
			{
				x->ch[val>=x->val]=new node(val,x);
				Splay(x->ch[val>=x->val],NULL);
				return;
			}
		}
	}
	inline void find(int val)
	{
		tree x=root;
		while(x&&x->ch[val>x->val]&&val!=x->val)x=x->ch[val>x->val];
		if(x)Splay(x,NULL);
	}
	inline int findkth(int k)
	{
		tree x=root;
		assert(size(x)>=k);
        assert(k);
		while(x)
		{
			if(size(x->ch[0])+x->cnt>=k&&size(x->ch[0])<k)return x->val;
			if(size(x->ch[0])>=k)x=x->ch[0];
			else k-=size(x->ch[0])+x->cnt,x=x->ch[1]; 
		}
		return -2147483647;
	}
	inline void del(int val)
	{
		find(val);
		if(root->val!=val)return;
		tree x=root;
		if(x->cnt>1)x->cnt--;
		else 
		if(!x->ch[0])
		{
			root=x->ch[1];
			if(root)root->par=NULL; 
			delete x;
		}
		else
		{
			tree k=x->ch[0];
			while(k->ch[1])k=k->ch[1];
			Splay(k,x);
			root=k,root->par=NULL;
			buildfather(x->ch[1],root,1); 
			delete x;
		}
	}
	inline int pre(int val)
	{
		insert(val);
		tree x=root->ch[0];
		while(x->ch[1])x=x->ch[1];
		del(val);
		return x->val;
	}
	inline int nxt(int val)
	{
		insert(val);
		tree x=root->ch[1];
		while(x->ch[0])x=x->ch[0];
		del(val);
		return x->val;
	}
}bt; 
int main(void)
{
	int n=gi;
    int a;
    for(RG int i=1; i<=n; i++)
        switch(gi)
        {
            case 1:
                a=gi;
                bt.insert(a);
                break;
            case 2:
                a=gi;
                bt.del(a);
                break;
            case 3:
                a=gi;
                bt.find(a);
                printf("%d\n",bt.size(bt.root->ch[0])+1);//这能理解吗
                break;
            case 4:
                a=gi;
                printf("%d\n",bt.findkth(a));
                break;
            case 5:
                a=gi;
                printf("%d\n",bt.pre(a));
                break;
            case 6:
                a=gi;
                printf("%d\n",bt.nxt(a));
                break;
        }
    return 0;
}
```

---

## 作者：langmouren (赞：6)

# PBDS
## 前言
什么？数据加强版？我不信！

本题解初步介绍了 pbds 库，并对 pbds 库在本题进行了应用。

## 什么是 pbds 库
它是一个扩展库，我们可以使用以下头文件来方便的引用它（有的人喜欢叫它平板电视库（雾））。

```cpp
#include<bits/extc++.h>
using namespace __gnu_pbds;
```

## DevC++ 人机时刻
由于神秘原因，windows 下的 DevC++ 无法直接使用 `#include<bits/extc++.h>`，我们可以点击下面的报错：

![1](https://cdn.luogu.com.cn/upload/image_hosting/gjvllhkd.png)

他会转到这个界面：

![2](https://cdn.luogu.com.cn/upload/image_hosting/2mrwgsfp.png)

我们可以在其中选择需要的引用，粘贴到自己的文件中代替 `#include<bits/extc++.h>`，这样就不会报错了.

## 它能干什么
它封装了 hash、tree、trie、priority_queue 四种数据结构，在这里我们使用到了 tree。

## 为什么要使用
1. 它避免了长篇大论地编写平衡树代码，而是直接让我们使用封装好的版本。
2. 它**可以**在 NOI 系列比赛中使用。

## 如何声明

```cpp
tree<数据类型,无映射,排列方式,树的类型,更新方式> 变量名称;

数据类型：int、long long 等，一般使用 long long
无映射：使用 null_type
排列方式：less 从小到大 greater 从大到小，本题使用 less<long long>
树的类型：rd_tree、ov_tree、splay_tree，看名字就知道是什么树，建议使用 rd_tree 即红黑树，因为它快。
更新方式：除非你需要自写 update，否则使用 tree_order_statistics_node_update。
```

## 如何使用

```cpp
tre.insert(x); //插入x;
tre.erase(x); //删除x;
tre.order_of_key(x); //返回x的排名;
tre.find_by_order(k); //返回第k小的值的迭代器;
tre.lower_bound(x); //返回第一个大于等于x的元素的迭代器;
tre.upper_bound(x); //返回第一个大于x的元素的迭代器;

tre.join(b); //树的合并;
tre.split(a,b); //树的分裂;
```

## 使用时注意事项
1. 红黑树会自动去重，所以以其作为树的类型时，我们要对数据进行哈希，一般使用 long long 作为数据类型，将其左移，再加上循环中的 $i$。
2. 数据很（毒）大（瘤）的时候可能会卡掉哈希，可以通过数据结构记录读入时间作为不重复变量，重载运算符；或是修改左移位数（它总不能移多少都卡吧？！）。

## 代码实现

```cpp
#include<bits/stdc++.h>
#include<bits/extc++.h>
using namespace std;
using namespace __gnu_pbds;

tree<long long,null_type,less<long long>,rb_tree_tag,tree_order_statistics_node_update> tre;

int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		long long op,k;
		scanf("%lld%lld",&op,&k);
		if(op==1) tre.insert((k<<20)+i);
		else if(op==2) tre.erase(tre.lower_bound(k<<20));
		else if(op==3) printf("%lld\n",tre.order_of_key(k<<20)+1);
		else if(op==4) printf("%lld\n",(*tre.find_by_order(k-1))>>20);
		else if(op==5) printf("%lld\n",(*--tre.lower_bound(k<<20))>>20);
		else printf("%lld\n",(*tre.upper_bound((k<<20)+n))>>20);
	}
	return 0;
}
```
超绝代码量。

### 其他
[提交记录](https://www.luogu.com.cn/record/201703451)

更多 pbds 库用法可见[洛谷日报](https://www.luogu.com.cn/article/tk8rh0c9)。

---

## 作者：IGA_Indigo (赞：5)

（内容很长，请大家耐心观看，如果是有基础的选手，可以从具体操作开始看。）

（本文有图有详解，有朴素易懂不加修饰的裸板子代码，适合新手食用）
## 题目大意
要求研究出一个在线的数据结构 $M$，要求可以在 $M$ 中维护下列操作。
- 插入一个数 $x$。
- 删除一个数 $x$（有多个的话仅删除一个）。
- 查询一个数 $x$ 的排名（比 $x$ 小的数的个数 $+1$）。
- 查询将 $M$ 中排名为 $x$ 的数。
- 查询比 $x$ 小的最大的数（前驱）。
- 查询比 $x$ 大的最小的数（后继）。

暴力不行，我们的数据范围要求在 $1\le n \le 10^5$ 下解决问题。
## 大体思路
数据结构题，平衡树模板题，至于具体是哪种平衡树，只能说都可以，自己擅长哪个就在考试时用哪个。

### 前置知识

二叉搜索树和堆。

我们起码要知道，平衡树基于二叉搜索树，一个节点的左子树全都比当前节点小，一个节点的右子树全都比当前节点大。

### 写在前面，推荐原因
我在这里主要写 fhq Treap，这是一种无需旋转的 Treap 平衡树，而且支持可持久化，代码很短，明显好想。

不过在动态树实现时略差于 splay（其他时候基本都优于），在这里我们只用做普通平衡树。

在查找速度上弱于 AVL 这种严格平衡树，但只是常数上的问题，AVL 弱点也明显，就是在插入删除上十分缓慢，因为要经常旋转，而无旋的 fhq Treap 就会快上不少。

关于随机键值有小概率依旧退化成链的可能，可能性不大，在大数据下用随机数抽到链？我估计可以转博彩行业了... ...

### 较优的随机数生成算法
梅森旋转算法，虽然质量只是较高，但是效率很快，况且在算法竞赛上好写。
```cpp
mt19937 randd(random_device{}());
```
其用**线性反馈移位寄存器**产生随机数，并且周期为 $2^{19937}−1$（是一个梅森素数，因此而得名），说明这个寄存器是 $19937$ 级的，他生成随机数的方式就是用这个寄存器一直移位旋转，以保证他的均匀分布。其代码很玄学，这里就不再放出来，有兴趣的可以自行学习。
### 具体操作
- 定义

首先定义一棵树。
```cpp
struct node{
	int l,r;
	int v;
	int rnd;
	int siz;
}t[100005];
```
- 下放

再定义好一个下放函数。

修改时要随时下放哦~

一定注意不要写错，别忘了 $+1$，不然很难调的。
```cpp
void push_up(int x){//size 的下传
	t[x].siz=t[t[x].l].siz+t[t[x].r].siz+1;
}

- 定义新节点
如果我们需要定义节点，我们需要这样操作。
```cpp
int newnode(int x){
	t[++tot].v=x;
	t[tot].rnd=rand();
	t[tot].siz=1;
	return tot;
}
```
很简单，因为要在插入函数中快速使用赋值，我们才 `return tot;` 的，事实上 `void` 也可以，后面 $insert$ 的时候我们要把当前点赋值为 $tot$。

**正片开始！**

注意，我在讲解中省略了分裂操作的 `int& l,int& r` 两个参数，这个按照具体代码实现很好填，但是讲解时加上显得冗余。
#### 插入
我们首先知道，一棵 fhq treap 是基于分裂和合并的，所以我们在插入的时候，需要先将整棵树**分裂**，插入后再**合并**，粗暴地说，就是把这棵树扒成两半，塞进去节点，再安起来。

就像下图这样。

![](https://cdn.luogu.com.cn/upload/image_hosting/jo3roofn.png)
（纯手绘，有点丑，凑合看）

先**分裂**成两棵树，然后将这个新节点先与切出来的左树**合并**，再把这颗混合树和右树**合并**。

下面我们具体讲讲分裂操作和合并操作。

- 分裂

![](https://cdn.luogu.com.cn/upload/image_hosting/5phec9s8.png)

这是一颗普通的树，现在他要开始裂开了，我们要按照 $6$ 这个值来分裂，也就是大于 $6$ 的都在左边，小于等于 $6$ 的都在右边。

![](https://cdn.luogu.com.cn/upload/image_hosting/qo1jui0n.png)

代表第一步：$8 > 6$，不是 $1.8>6$ 啦！
![](https://cdn.luogu.com.cn/upload/image_hosting/w7z0s4ro.png)

这样一步一步的向下找，然后最后建立一个新结点。将走过的边删掉，用遍历到的当前根节点连接当前节点。
![](https://cdn.luogu.com.cn/upload/image_hosting/gl5v7p9w.png)

这里就忽略 $7 > 6$ 吧（才不是忘写了）。

![](https://cdn.luogu.com.cn/upload/image_hosting/9efrwxej.png)

最后把所有连向新加节点的边全部删除，删掉所有无用的笔画，我们得到最终的图。

总结一下，我们实际是要找符合二叉搜索树的左子树和右子树给当前要求处理的这个点的 $v$，把点传进来（从根节点开始往后查的子树结点）之后，先查一下这个点是否是空树，是的话直接返回走，不是的话按照 $t[x].v$ 的大小找他需要的子树，最后下放一下更新 $len$ 即可。

```cpp
void split(int x,int v,int& l,int& r){
	if(!x){
		l=0;r=0;
		return ;
	}
	if(v>=t[x].v){
		l=x;
		split(t[x].r,v,t[x].r,r);
	}
	else{
		r=x;
		split(t[x].l,v,l,t[x].l);
	}
	push_up(x);
}
```
补充说明一点，**分裂是整棵树分成两半**，后期有大作用。

- 合并

我们按照按照给的**随机值**来排序，小的那个成为合并后新树的树根，大的那个成为他的左/右子树，若其小的那个本身就有左/右子树，大的那个把他抢过来即可。

就像下图那样（我又要展示我的美术功力了）。
![](https://cdn.luogu.com.cn/upload/image_hosting/yin85afu.png)
对于当前根节点，抢夺左儿子。
![](https://cdn.luogu.com.cn/upload/image_hosting/qgfjoyt7.png)
然后回到自己父亲，连到右树的根节点。

不要忘记删除 $4$ 和 $6$ 之间的边。

配合代码食用一下吧。
```cpp
int merge(int x,int y){
	if(!x||!y){
		return x+y;
	}
	if(t[x].rnd<t[y].rnd){
		t[x].r=merge(y,t[x].r);
		push_up(x);
		return x;
	}
	else{
		t[y].l=merge(x,t[y].l);
		push_up(y);
		return y ;
	}
```

注意一点，`merge(x,y)` 中我们能够满足左边全部节点的权值不大于 $y$ 的要求。为什么呢？我们可以看到，我们在函数中的判断要么是 $x$ 为根，$y$ 为他的右子树（if 语句里），要么是 $y$ 为根，$x$ 为他的左子树，递归实现，根据二叉排序树的性质，$x$ 的权值定然必须要比 $y$ 小的。

这时候我们可以学习插入了，插入讲究一个先分后合。

```cpp
void insert(int v){
	int x,y;
	split(root,v,x,y);
	int xx=newnode(v);
	root=merge(merge(x,xx),y);
}
```

解释一点，$root$ 更新那里，不要以为分裂下去了之后就是在子树里面改了，**分裂是整棵树分成两半**，我们这里修改只是怕最上面的根节点 $rnd$ 大被换下去。
### 删除
还是基于分裂和删除，我们直接看操作方式。
![](https://cdn.luogu.com.cn/upload/image_hosting/mu12pvr6.png)

先从根节点按照 $x$ **分裂**成三棵树，一颗大于 $x$，一颗小于 $x$，一颗等于 $x$。

不管那颗等于 $x$ 的，将大于的和小于的**合并**。

代码有详解。
```cpp
void delet(int v){
	int x,y,z;
	split(root,v,x,z);//先把最左边和最右边的子树找出来
	split(x,v-1,x,y);//然后查中间那个，split求的是第一个小于等于v-1的子树
	y=merge(t[y].l,t[y].r);//光删他一个点，子树留着
	root=merge(merge(x,y),z);//他仨重新合并，找到根节点 
}
```
### 求点 $x$ 的排名
点 $x$ 的排名就是分裂后小于 $x$ 的子树 $size+1$。

我们这里直接调用 `split(r,v-1)` 即可。

千万记得求完答案要合并。

```cpp
void qrank(int v){
	int x,y;
	split(root,v-1,x,y);
	cout<<t[x].siz+1<<endl;
	merge(x,y);
}
```
### 求排名为 $k$ 的点
按二叉搜索树的性质来搜。

- 若当前节点左子树的 $siz+1$ 恰好是 $k$，那当前节点就是排名为 $k$ 的点，直接输出。
- 若 $k<siz+1$，从左子树里面找排名为 $k$ 的点。
- 若 $k>siz+1$，从右子树里面找排名为 $k-siz-1$ 的点。

知道为什么有 $+1$ 和 $-1$ 吗？因为当前节点也是节点（这像话吗）。
```cpp
void whorank(int x,int k){
	int siz=t[t[x].l].siz;
	if(k==siz+1){
		cout<<t[x].v<<endl;
		return ;
	}
	else if(k<=siz){
		whorank(t[x].l,k);
		return ;
	}
	else{
		whorank(t[x].r,k-siz-1);
		return ;
	}
}
```
### 前驱与后继
整个看下来，前驱与后继就 so easy 了。
- 前驱

我们按照 $v-1$ 来分裂，输出比他小的树里最大值即可。

在找最大值的时候，我们可以在这棵树里面找排名为这棵树 $siz$ 的数是几。

最后别忘了把他们合并起来。

```cpp
void qqq(int v){
	int x,y;
	split(root,v-1,x,y);
	whorank(x,t[x].siz);
	root=merge(x,y);
}
```
- 后继

和前驱相反，按照 $v$ 来分裂，输出比他大的树里最小值。

这时候我们就要找大的那棵树里面排名第 $1$ 的了。

```cpp
void qhj(int v){
	int x,y;
	split(root,v,x,y);
	whorank(y,1);
	root=merge(x,y);
}
```
## 总结
写了这么多，总得有点总结。

是不是感觉平衡树也不是这么难？主要是要感谢 fhq，写下的平衡树简单快捷。

一定要注意，Treap 是对权值形成二叉搜索树，不要跟文艺平衡树搞混了。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
mt19937 rnd(random_device{}());
struct node{
	int l,r;
	int v;
	int rnd;
	int siz;
}t[100005];
int tot=0,root=0;//现在结点的数量和根节点
void push_up(int x){//size 的下传
	t[x].siz=t[t[x].l].siz+t[t[x].r].siz+1;
}
int newnode(int x){
	t[++tot].v=x;
	t[tot].rnd=rnd();
	t[tot].siz=1;
	return tot;
}
void split(int x,int v,int& l,int& r){
	if(!x){
		l=0;
		r=0;
		return ;
	}
	if(v>=t[x].v){
		l=x;
		split(t[x].r,v,t[x].r,r);
	}
	else{
		r=x;
		split(t[x].l,v,l,t[x].l);
	}
	push_up(x);
}
int merge(int x,int y){
	if(!x||!y){
		return x+y;
	}
	if(t[x].rnd<t[y].rnd){
		t[x].r=merge(t[x].r,y);
		push_up(x);
		return x;
	}
	else{
		t[y].l=merge(x,t[y].l);
		push_up(y);
		return y;
	}
}
void insert(int v){
	int x,y;
	split(root,v,x,y);
	int xx=newnode(v);
	root=merge(merge(x,xx),y);
}
void delet(int v){
	int x,y,z;
	split(root,v,x,z);//先把最左边和最右边的子树找出来
	split(x,v-1,x,y);//然后查中间那个，split求的是第一个小于等于v-1的子树
	y=merge(t[y].l,t[y].r);//光删他一个点，子树留着
	root=merge(merge(x,y),z);//他仨重新合并，找到根节点 
}
void qrank(int v){
	int x,y;
	split(root,v-1,x,y);
	cout<<t[x].siz+1<<endl;
	merge(x,y);
}
void whorank(int x,int k){
	int siz=t[t[x].l].siz;
	if(k==siz+1){
		cout<<t[x].v<<endl;
		return ;
	}
	else if(k<=siz){
		whorank(t[x].l,k);
		return ;
	}
	else{
		whorank(t[x].r,k-siz-1);
		return ;
	}
}
void qqq(int v){
	int x,y;
	split(root,v-1,x,y);
	whorank(x,t[x].siz);
	root=merge(x,y);
}
void qhj(int v){
	int x,y;
	split(root,v,x,y);
	whorank(y,1);
	root=merge(x,y);
}
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		int op,x;
		cin>>op>>x;
		if(op==1){
			insert(x);
		}
		else if(op==2){
			delet(x);
		}
		else if(op==3){
			qrank(x);
		}
		else if(op==4){
			whorank(root,x);
		}
		else if(op==5){
			qqq(x);
		}
		else{
			qhj(x);
		}
	}
	return 0;
}
```

---

## 作者：NCC79601 (赞：5)

没看到写得很透彻的$Treap$题解，作为初学者还是自己写一篇吧。
# $Treap$
定义：如果一棵二叉树$T$满足$\forall x\in T$，$x>$ $x$左子树中的所有节点，且$x<$ $x$右子树中的所有节点，则$T$可被称为二叉查找树$BST$ $(Binary$ $Search$ $Tree)$。

顾名思义，$Treap=Tree+Heap$，所以$Treap$平衡树其实质上就是一个把堆套在树上的结构。如果我们需要对一个序列进行插入、删除、求前驱后继、求第$k$大数、求排名等操作，如果只是简单地建立一棵$BST$来跑的话，**复杂度和树的高度有关** 。其最坏复杂度是$O(n)$，例如输入数据有序的时候，树直接就变成一条链了。所以我们希望可以在维护$BST$性质的情况下，尽可能地把树的高度压缩，这样就可以降低时间复杂度了。

而对于一棵$BST$，有两个操作：右旋$(Zig)$和左旋$(Zag)$，它们不会改变$BST$性质，却可以改变节点间的父子关系。
# $Zig$操作
![zig.jpg](https://img.ffis.me/images/2019/03/09/zig.jpg)
具体步骤为：

1. 把蓝色节点接到红色节点的左儿子上面。由于**蓝色节点一定小于红色节点而大于绿色节点**，因此可以把它接到红色节点的左儿子上面。
2. 把绿色点的右儿子替换为红色节点。
3. 把红色节点维护的节点数信息更新到绿色节点上。
4. 将$Zig$之后的红色节点维护的节点数信息更新，然后把红色节点换掉。
* 注意，更新节点数信息的时候**一定不要**更新成$Zig$后变成树根的那个点，而更新的是$Zig$后**变成树根右儿子的那个点**。这里被坑了。

```cpp
inline void Zig(int &x) {
	int k = l(x);
	l(x) = r(k), r(k) = x;
	s(k) = s(x);
	update(x); // attention!!
	x = k;
	return;
}
```

# $Zag$操作
![zag.jpg](https://img.ffis.me/images/2019/03/09/zag.jpg)
$Zag$与$Zig$操作无异，只是$l$与$r$互换。$Zig$和$Zag$互为逆操作。
```cpp
inline void Zag(int &x) {
	int k = r(x);
	r(x) = l(k), l(k) = x;
	s(k) = s(x);
	update(x); // attention!!
	x = k;
	return;
}
```
# 维护方式
我们与$BST$建立一个完全对应的小根堆，每次新建节点的时候就随机为节点分配一个优先级，并且用$Zig$和$Zag$维护小根堆。由于堆的性质，其高度为$log(n)$，因此用这种方法就可以在维持$BST$性质的前提下把$BST$的高度压缩到$log(n)$，因此接下来所有的操作最坏复杂度就全部变成$log(n)$级别了。

# 插入节点
插入结点的时候有两种情况：

1. 当前插入位置是空点，则直接在这里新建一个节点，并且初始化节点属性。
2. 当前插入位置不是空点，先更新当前节点维护的节点数。若插入值和当前节点值相等，直接把$c(x)+1$；若插入值小于当前节点值，则在左子树中插入，并且维护堆属性：若左儿子的优先级小于当前节点的优先级，就$Zig$一下；同样地，若插入值大于当前节点值，则在右子树中插入，并且维护堆属性：若右儿子的优先级小于当前节点的优先级，就$Zag$一下。

这样就完成了对节点的插入。
```cpp
inline void Insert(int &x, int v) {
	if(!x) {
		x = ++id;
		v(x) = v, c(x) = s(x) = 1;
		l(x) = r(x) = 0;
		p(x) = rand();
		return;
	}
	s(x)++;
	if(v(x) == v)
		c(x)++;
	else {
		if(v < v(x)) {
			Insert(l(x), v);
			if(p(l(x)) < p(x))
				Zig(x);
		} else {
			Insert(r(x), v);
			if(p(r(x)) < p(x))
				Zag(x);
		}
	}
	return;
}
```

# 删除节点
删除节点的时候有两种大情况：
1. 当前节点值等于删除节点值，若当前节点计数$\ge1$则直接$c(x)-1,s(x)-1$即可；若当前节点计数为$1$，则：①如果该点为链节点$($只有一个儿子$)$，直接把它替换为儿子即可；②如果该点有左右儿子，那么就类似于堆的删除，若左儿子优先级小于右儿子则$Zig$，再继续删除；否则$Zag$后再继续删除。
2. 当前节点不等于删除节点值，那么**先更新**$s(x)$，若删除节点值小于当前节点值则从左节点继续开始删除；若删除节点值大于当前节点值则从右节点继续开始删除。
```cpp
inline void Delete(int &x, int v) {
	if(v(x) == v) {
		if(c(x) > 1)
			c(x)--, s(x)--;
		else
			if(!l(x) || !r(x))
				x = l(x) + r(x);
				// x = l(x) ? l(x) : r(x);
			else
				if(p(l(x)) < p(r(x)))
					Zig(x), Delete(x, v);
				else
					Zag(x), Delete(x, v);
		return;
	}
	s(x)--; // attention!! 
	if(v < v(x))
		Delete(l(x), v);
	else
		Delete(r(x), v);
	return;
}
```
# 查找第$k$大数
直接从根开始查找。对于查询的序数$k$，可知：如果$k\in(s(l(x)), s(l(x))+c(x)]$，则比$k$小的就只有$s(l(x))$个，因此$v(x)$就是答案。从树根开始查找，只要$x\neq0$，则：
1. 若$k\in(s(l(x)), s(l(x))+c(x)]$，则直接返回$v(x)$。
2. 若$k\notin(s(l(x)), s(l(x))+c(x)]$，①$k\le s(l(x))$，则查询的点在左子树内，因此把$x$更新为$l(x)$，再继续查找；②$k>s(l(x))$，则查询的点在左子树内，因此把$k$更新为$k-s(l(x))-c(x)$，把$x$更新为$r(x)$，即在右子树里查找第$k-s(l(x))-c(x)$大节点$($等价于更新之前的查找$)$，然后继续查找。
```cpp
inline int QueryKth(int k) {
	int x = root, _k = k;
	while(x) {
		if(_k > s(l(x)) && _k <= s(l(x)) + c(x))
			return v(x);
		if(_k <= s(l(x)))
			x = l(x);
		else
			_k -= s(l(x)) + c(x), x = r(x);
	}
	return 0;
}
```
# 查找前驱与后继
这里定义：$x$的前驱指序列中小于$x$的最大数；$x$的后继指序列中大于$x$的最小数。$($有些地方的定义和这个不一样$)$

求前驱与求后继的思路相似，这里以前驱为例：
用$res$维护答案。从根节点开始搜索，只要$x\neq0$，则：

1. 如果当前节点值小于查找值，则把$res$更新为当前节点值，然后把$x$更新为$r(x)$以寻找右子树中是否还有更优的解。
2. 如果当前节点值大于查找值，则把$x$更新为$l(x)$以寻找左子树中是否有小于查找值的节点。后继的算法与前驱相似，但略有区别，不再赘述。

```cpp
inline int QueryPre(int v) {
	int x = root, res = -INF;
	while(x) {
		if(v(x) < v)
			res = v(x), x = r(x);
		else
			x = l(x);
	}
	return res;
}

inline int QuerySuf(int v) {
	int x = root, res = INF;
	while(x) {
		if(v(x) > v)
			res = v(x), x = l(x);
		else
			x = r(x);
	}
	return res;
}
```

# 获取排名
最后就是利用$Treap$求查找值在序列中的排名。维护一个当前累计排名$rank$，从根节点开始，只要$x\neq0$，则：

1. 如果当前节点值等于查找值，直接返回$rank+s(l(x))+1$。
2. 如果当前节点值小于查找值，则把$x$更新为$l(x)$；如果当前节点值大于查找值，先把$rank$更新为$rank+s(l(x))+c(x)$，表示当前已有$rank+s(l(x))+c(x)$个节点小于查找值。
最后返回$rank$即可。

```cpp
inline int QueryRank(int v) {
	int x = root, rank = 0;
	while(x) {
		if(v(x) == v)
			return rank + s(l(x)) + 1;
		if(v < v(x))
			x = l(x);
		else
			rank += s(l(x)) + c(x), x = r(x);
	}
	return rank;
}
```

---
完整代码：
```cpp
//code
#include<bits/stdc++.h>
#include<ctime>
#define l(x) tree[x].lson
#define r(x) tree[x].rson
#define v(x) tree[x].val
#define p(x) tree[x].pri
#define c(x) tree[x].cnt
#define s(x) tree[x].size
using namespace std;

const int MAXN = 100010;
const int INF = 1 << 30;

struct TREE {
	int lson, rson, val, pri, cnt, size;
} tree[MAXN];
int id = 0, root = 0;
int n, o, opt;

inline int read() {
	int res = 0, uz = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9') {
		if(ch == '-')
			uz = -1;
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9') {
		res = (res << 3) + (res << 1) + (ch ^ '0');
		ch = getchar();
	}
	return res * uz;
}

inline void update(int &x) {
	s(x) = s(l(x)) + s(r(x)) + c(x);
	return;
}

inline void Zig(int &x) {
	int k = l(x);
	l(x) = r(k), r(k) = x;
	s(k) = s(x);
	update(x); // attention!!
	x = k;
	return;
}

inline void Zag(int &x) {
	int k = r(x);
	r(x) = l(k), l(k) = x;
	s(k) = s(x);
	update(x); // attention!!
	x = k;
	return;
}

inline void Insert(int &x, int v) {
	if(!x) {
		x = ++id;
		v(x) = v, c(x) = s(x) = 1;
		l(x) = r(x) = 0;
		p(x) = rand();
		return;
	}
	s(x)++;
	if(v(x) == v)
		c(x)++;
	else {
		if(v < v(x)) {
			Insert(l(x), v);
			if(p(l(x)) < p(x))
				Zig(x);
		} else {
			Insert(r(x), v);
			if(p(r(x)) < p(x))
				Zag(x);
		}
	}
	return;
}

inline void Delete(int &x, int v) {
	if(v(x) == v) {
		if(c(x) > 1)
			c(x)--, s(x)--;
		else
			if(!l(x) || !r(x))
				x = l(x) + r(x);
			else
				if(p(l(x)) < p(r(x)))
					Zig(x), Delete(x, v);
				else
					Zag(x), Delete(x, v);
		return;
	}
	s(x)--; // attention!! 
	if(v < v(x))
		Delete(l(x), v);
	else
		Delete(r(x), v);
	return;
}

inline int QueryKth(int k) {
	int x = root, _k = k;
	while(x) {
		if(_k > s(l(x)) && _k <= s(l(x)) + c(x))
			return v(x);
		if(_k <= s(l(x)))
			x = l(x);
		else
			_k -= s(l(x)) + c(x), x = r(x);
	}
	return 0;
}

inline int QueryPre(int v) {
	int x = root, res = -INF;
	while(x) {
		if(v(x) < v)
			res = v(x), x = r(x);
		else
			x = l(x);
	}
	return res;
}

inline int QuerySuf(int v) {
	int x = root, res = INF;
	while(x) {
		if(v(x) > v)
			res = v(x), x = l(x);
		else
			x = r(x);
	}
	return res;
}

inline int QueryRank(int v) {
	int x = root, rank = 0;
	while(x) {
		if(v(x) == v)
			return rank + s(l(x)) + 1;
		if(v < v(x))
			x = l(x);
		else
			rank += s(l(x)) + c(x), x = r(x);
	}
	return rank;
}

int main() {
	srand(time(NULL)); // attention!!
	n = read();
	while(n--) {
		opt = read(), o = read();
		switch(opt) {
			case 1: {
				Insert(root, o);
				break;
			}
			case 2: {
				Delete(root, o);
				break;
			}
			case 3: {
				printf("%d\n", QueryRank(o));
				break;
			}
			case 4: {
				printf("%d\n", QueryKth(o));
				break;
			}
			case 5: {
				printf("%d\n", QueryPre(o));
				break;
			}
			default: {
				printf("%d\n", QuerySuf(o));
				break;
			}
		}
	}
	return 0;
}
```
written at 2019/03/08/23:51

---

## 作者：Terminal_P (赞：4)

## 0. 前置条件
阅读此题解前，请确保你已经通过 [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)。  
本题解将会使用权值线段树求解。~~其实是因为蒟蒻不会写平衡树~~  
以下是本题解代码所用到的头文件、常量和宏定义。
```C++
#include <bits/stdc++.h>
#define endl "\n"
#define mid ((l + r) >> 1)
#define ls (pos << 1)
#define rs (pos << 1 | 1)
using namespace std;
const int N = 1e5 + 200;
```
## 1. 题目描述
给出 $n$ 次操作。
您需要动态地维护一个可重集合 $M$，并且提供以下操作：
1. 向 $M$ 中插入一个数 $x$。
2. 从 $M$ 中删除一个数 $x$（若有多个相同的数，应只删除一个）。
3. 查询 $M$ 中有多少个数比 $x$ 小，并且将得到的答案加一。
4. 查询如果将 $M$ 从小到大排列后，排名位于第 $x$ 位的数。
5. 查询 $M$ 中 $x$ 的前驱（前驱定义为小于 $x$，且最大的数）。
6. 查询 $M$ 中 $x$ 的后继（后继定义为大于 $x$，且最小的数）。

$1 \le n \le 10^5, |x| \le 10^7$。
## 2. 权值线段树的概念与性质
权值线段树本质上仍然是一棵线段树，不过其维护的并非给定的数列，而是一个桶。  
线段树的叶子结点表示的是**集合中此节点对应值的数的个数**。
## 3. 权值线段树的建立与修改
对于绝大部分用权值线段树维护的桶，初始值均置为 $0$，无需建树。  
由于权值线段树一般只实现单点修改，因此无需 `push_down()` 函数和 `Lazy-Tag`，致使其修改操作较为简单。  
以下是实现操作 $1 \sim 2$ 的函数。
```C++
int t[N << 2];
int n;
void pushup(int pos) { t[pos] = t[ls] + t[rs]; }
void update(int type, int x, int l, int r, int pos) {
  if (l == x && l == r) {
    if (type == 1) {
      t[pos]++;
    } else if (type == 2) {
      t[pos]--;
    }
    t[pos] = max(0, t[pos]);
    return;
  }
  if (x <= mid) {
    update(type, x, l, mid, ls);
  } else {
    update(type, x, mid + 1, r, rs);
  }
  pushup(pos);
}
```
## 4. 查询前缀和
操作 $3$ 即查询桶的前缀和。线段树板子，不再赘述。
```C++
int query(int st, int ed, int l, int r, int pos) {
  if (st <= l && r <= ed) {
    return t[pos];
  }
  int res = 0;
  if (st <= mid) {
    res += query(st, ed, l, mid, ls);
  }
  if (mid + 1 <= ed) {
    res += query(st, ed, mid + 1, r, rs);
  }
  return res;
}
```
## 5. 查询排名
对于操作 $4$，我们可以这样考虑：对于一个父节点，
 - 如果它的左孩子的权值 $\ge$ 给定的排名，说明要查询的元素位于左子树中，递归进入。
 - 反之说明要查询的元素位于右子树中，此时排名**应减去左子树的权值**，再递归进入右子树。
```C++
int getrank(int x, int l, int r, int pos) {
  if (l == r) {
    return l;
  }
  if (x <= t[ls]) {
    return getrank(x, l, mid, ls);
  } else {
    return getrank(x - t[ls], mid + 1, r, rs);
  }
}
```
## 6. 查询前驱与后继
**这里是难点。**
由题意得 $p$ 是 $x$ 的前驱，当且仅当：
 - $p < x$。
 - $p$ 的权值非 $0$。
 - $\forall k \in (p, x)$，$k$ 的权值均为 $0$。

由贪心思想可得，要查询一个数的前驱，应优先查询**右子树**是否存在此数的前驱。此时找到的数显然可以满足第 $3$ 个性质。  
当我们找到的叶子结点不满足以上要求时返回 $0$ 表示无解。  
**当右子树无解时，再寻找左子树。**  
求后继的代码与查询前驱的代码类似，不再赘述。
```C++
int findlower(int x, int l, int r, int pos) {
  if (l == r) {
    return (l < x && t[pos] != 0) ? l : 0;
  }
  int res = 0;
  if (mid + 1 < x && t[rs] != 0) {
    res = findlower(x, mid + 1, r, rs);
  }
  if (res != 0) {
    return res;
  }
  return findlower(x, l, mid, ls);
}
int findupper(int x, int l, int r, int pos) {
  if (l == r) {
    return (l > x && t[pos] != 0) ? l : 0;
  }
  int res = 0;
  if (mid > x && t[ls] != 0) {
    res = findupper(x, l, mid, ls);
  }
  if (res != 0) {
    return res;
  }
  return findupper(x, mid + 1, r, rs);
}
```
## 7. 离散化
注意到 $x$ 的值域较大且可能存在负数，考虑离散化后再处理。  
先存储各个询问的内容，离散化结束后再一一处理。  
以下是几个注意事项。  
1. 对于操作 $4$，不应将 $x$ 的值存入离散化数组。实测可能出现一些奇怪的问题。
2. 离散化数组中应加入两个大于值域范围的哨兵（此处取 $-2 \times 10^7$ 和 $2 \times 10^7$）。
3. 离散化数组的下标**应从 $1$ 开始**。我也不知道这是为什么，但是不这样就会错。~~可能是我太弱的原因吧。~~
```C++
vector<int> Z;
int OP[N], X[N];
int bns(int x) { return lower_bound(Z.begin(), Z.end(), x) - Z.begin() + 1; }
signed main() {
  ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
  cin >> n;
  for (int i = 1; i <= n; ++i) {
    cin >> OP[i] >> X[i];
    if (OP[i] != 4) Z.push_back(X[i]);
  }
  Z.push_back(-2e7);
  Z.push_back(2e7);
  sort(Z.begin(), Z.end());
  Z.erase(unique(Z.begin(), Z.end()), Z.end());
  int m = Z.size();
  for (int i = 1; i <= n; i++) {
    int op = OP[i], x = X[i];
    if (op == 1 || op == 2) {
      update(op, bns(x), 1, m, 1);
    } else if (op == 3) {
      cout << query(1, bns(x) - 1, 1, m, 1) + 1 << endl;
    } else if (op == 4) {
      cout << Z[getrank(x, 1, m, 1) - 1] << endl;
    } else if (op == 5) {
      cout << Z[findlower(bns(x), 1, m, 1) - 1] << endl;
    } else if (op == 6) {
      cout << Z[findupper(bns(x), 1, m, 1) - 1] << endl;
    }
  }
  return 0;
}
```
## 8. 合并后代码
```C++
/*
书本试卷堆积的角落里
找到没贴邮票泛黄的信
不禁幻想回到那个雨季
说出 反复练习 却没说的话语
—— 鸽稀拉 《回信》

In the corner where books and test papers are piled up
Found a yellowed letter without a stamp
I can't help but fantasize about returning to that rainy season
"Saying words that have been repeatedly practiced but not spoken"
- Reply (by Gexila)
*/
#include <bits/stdc++.h>
#define endl "\n"
#define mid ((l + r) >> 1)
#define ls (pos << 1)
#define rs (pos << 1 | 1)
using namespace std;
const int N = 1e5 + 200;
int t[N << 2];
int n;
vector<int> Z;
int OP[N], X[N];
int bns(int x) { return lower_bound(Z.begin(), Z.end(), x) - Z.begin() + 1; }
void pushup(int pos) { t[pos] = t[ls] + t[rs]; }
void update(int type, int x, int l, int r, int pos) {
  if (l == x && l == r) {
    if (type == 1) {
      t[pos]++;
    } else if (type == 2) {
      t[pos]--;
    }
    t[pos] = max(0, t[pos]);
    return;
  }
  if (x <= mid) {
    update(type, x, l, mid, ls);
  } else {
    update(type, x, mid + 1, r, rs);
  }
  pushup(pos);
}
int query(int st, int ed, int l, int r, int pos) {
  if (st <= l && r <= ed) {
    return t[pos];
  }
  int res = 0;
  if (st <= mid) {
    res += query(st, ed, l, mid, ls);
  }
  if (mid + 1 <= ed) {
    res += query(st, ed, mid + 1, r, rs);
  }
  return res;
}
int getrank(int x, int l, int r, int pos) {
  if (l == r) {
    return l;
  }
  if (x <= t[ls]) {
    return getrank(x, l, mid, ls);
  } else {
    return getrank(x - t[ls], mid + 1, r, rs);
  }
}
int findlower(int x, int l, int r, int pos) {
  if (l == r) {
    return (l < x && t[pos] != 0) ? l : 0;
  }
  int res = 0;
  if (mid + 1 < x && t[rs] != 0) {
    res = findlower(x, mid + 1, r, rs);
  }
  if (res != 0) {
    return res;
  }
  return findlower(x, l, mid, ls);
}
int findupper(int x, int l, int r, int pos) {
  if (l == r) {
    return (l > x && t[pos] != 0) ? l : 0;
  }
  int res = 0;
  if (mid > x && t[ls] != 0) {
    res = findupper(x, l, mid, ls);
  }
  if (res != 0) {
    return res;
  }
  return findupper(x, mid + 1, r, rs);
}
signed main() {
  ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
  cin >> n;
  for (int i = 1; i <= n; ++i) {
    cin >> OP[i] >> X[i];
    if (OP[i] != 4) Z.push_back(X[i]);
  }
  Z.push_back(-2e7);
  Z.push_back(2e7);
  sort(Z.begin(), Z.end());
  Z.erase(unique(Z.begin(), Z.end()), Z.end());
  int m = Z.size();
  for (int i = 1; i <= n; i++) {
    int op = OP[i], x = X[i];
    if (op == 1 || op == 2) {
      update(op, bns(x), 1, m, 1);
    } else if (op == 3) {
      cout << query(1, bns(x) - 1, 1, m, 1) + 1 << endl;
    } else if (op == 4) {
      cout << Z[getrank(x, 1, m, 1) - 1] << endl;
    } else if (op == 5) {
      cout << Z[findlower(bns(x), 1, m, 1) - 1] << endl;
    } else if (op == 6) {
      cout << Z[findupper(bns(x), 1, m, 1) - 1] << endl;
    }
  }
  return 0;
}
/*
By Terminal_P  >_P
Copyright 2025. All Rights Reserved.
Luogu: Terminal_P
Bilibili: Terminal_P
Netease Music: Terminal_P
QQ ID: 2705680938
QQ Group ID: 945817959
Nice to meet you.
*/
```
[AC 记录 #R214860234](https://www.luogu.com.cn/record/214860234)   
若有不妥请在下面指出，谢谢各位！

---

## 作者：StayAlone (赞：3)

选自 [抛弃随机，保持理性——Leafy Tree 到 WBLT](https://www.luogu.com.cn/article/icwj6l9s)

这篇文章讲解了 Leafy Tree。以它实现的加权平衡树码量与 FHQ 相近，结构与线段树类似，可以像 FHQ Treap 一样分裂合并，同样支持文艺平衡树和可持久化。更重要的是，它的常数远远优于 FHQ Treap。缺点是节点数量为两倍，~~但是这能叫缺点吗？哪个数据结构题卡二倍空间~~。

**若没有特殊说明，文中的图片均为原创。**

**文章中所有代码的测试结果均在洛谷 C++14 (GCC 9) 环境下获得。**

## 概述

Leafy 指将维护的信息记录在叶子节点上，与之对应的是 Nodey。

对于 Leafy Tree，它的叶子节点记录数列，非叶子节点记录左右儿子的值的较大值（由于左儿子的值一定不大于右儿子值，因此直接记录右儿子的值），节点数量为 $2n-1$，且非叶子节点的儿子数量均为 $2$。

## Leafy Tree 实现二叉搜索树

若依次将 `inf 1 14 51 4 19 9 8 10` 插入，可以得到这样的一棵树：

![](https://s1.ax1x.com/2023/01/13/pSKIUVf.png)


其中方点是叶子结点，圆点是非叶子结点。叶子节点的值排成了一个有序数列，非叶子节点上的值为右儿子的值。

利用 Leafy Tree 的性质，可以轻松地实现二叉搜索树。

**下面的代码中尽量使用了非递归写法。即使要改成递归写法也是很容易的，而且没有本质上的区别。**

当且仅当 $siz_x = 1$ 时，节点 $x$ 为叶节点。

规定 $lp_x,rp_x$ 分别是 $x$ 节点的左右儿子，$val_x$ 表示 $x$ 节点的值，$siz_x$ 表示 $x$ 子树内的叶子结点数量。

其中 $siz_x,val_x$ 也可以这样定义：

- $x$ 是叶子节点时，$siz_x = 1$，$val$ 的定义详见新建节点；
- 否则，$siz_x = siz_{lp_x} + siz_{rp_x}, val_x = val_{rp_x}$。

若不作说明，默认被操作数为 $k$。

### 新建节点

无需说明。

```cpp
il int newnode(int k) {
	siz[++tot] = 1; val[tot] = k;
	return tot;
}
```

### 查找排名

首先记录一个 $cnt$，初值为 $0$。其含义为小于等于 $k$ 的值的数量，需要在查询过程中进行累加。

- 当前节点不是叶子节点时，若 $val_{lp_{now}} \geq k$，则 $now \leftarrow lp_{now}$，即在左子树中查询 $k$ 的排名。反之，则 $now \leftarrow rp_{now}$，即在右子树中查询 $k$ 的排名，**同时**，将 $cnt$ 累加 $siz_{lp_{now}}$。原理是找到第一个大于等于 $k$ 的位置，而在这个过程中，$val_{lp_{now}} \geq k$ 时，这个位置一定在左边，反之，这个位置一定在右边，并且左边的所有数都小于 $k$，所以要累加计数器。

- 当前节点是叶子节点时，返回 $cnt + 1$ 即为答案。

```cpp
il int find_rnk(int k) {
	int now = rt, cnt = 0;
	while (true) {
		if (siz[now] == 1) return cnt + 1;
		else if (val[lp[now]] >= k) now = lp[now];
		else cnt += siz[lp[now]], now = rp[now];
	}
}
```

### 查找第 $k$ 小

- 当前节点不是叶子节点时，若 $siz_{lp_{now}} \geq k$，则 $now \leftarrow lp_{now}$，即在左子树中查询第 $k$ 小。反之，则 $k\leftarrow k-siz_{lp_{now}},now \leftarrow rp_{now}$，即在右子树中查询排除左边数量的第 $k$ 小。

- 当前节点是叶子节点时，返回 $val_{now}$ 即为答案。

```cpp
il int find_kth(int k) {
	int now = rt;
	while (true) {
		if (siz[now] == 1) return k == 1 ? val[now] : -1;
		else if (siz[lp[now]] >= k) now = lp[now];
		else k -= siz[lp[now]], now = rp[now];
	}
}
```

### 查找前驱

先找到 $k$ 的排名 $p$，输出第 $p - 1$ 小。

```cpp
il int find_pre(int k) {
	return find_kth(find_rnk(k) - 1);
}
```

### 查找后继

几乎一致，不再赘述。

```cpp
il int find_suc(int k) {
	return find_kth(find_rnk(k + 1));
}
```

### 插入

- 当前节点不是叶子节点时，若 $k \leq val_{lp_{now}}$，则将 $k$ 插入左子树；反之插入右子树。

- 当前节点是叶子节点时，新建两个点 $p, q$。让这两个点的值分别等于 $val_{now}$ 和 $k$，再钦定 $val_p < val_q$，令 $now$ 变为非叶子节点，其左儿子为 $p$，右儿子为 $q$。采用递归实现，**注意回溯时要更新节点信息。**

举个例子。把开头的数列拿过来。若已经将 `inf 1 14 51 4 19 9 8` 插入，现在插入 $10$。首先沿着 $val$ 找到红色叶子节点进行插入操作：

![](https://s1.ax1x.com/2023/01/12/pSu6C8K.png)

红色节点不再是叶子节点。新建点 $p, q$，值为红色节点的值和 $k$，再使 $val_p < val_q$，分别作为红色节点的左右儿子。

![](https://s1.ax1x.com/2023/01/13/pSKIJKI.png)

```cpp
il void pushup(int x) {
	siz[x] = siz[lp[x]] + siz[rp[x]];
	val[x] = val[rp[x]];
}

il void insert(int now, int k) {
	if (siz[now] == 1) {
		int p = newnode(val[now]), q = newnode(k);
		if (val[p] > val[q]) swap(p, q);
		lp[now] = p, rp[now] = q;
		return pushup(now);
	}
	insert(k <= val[lp[now]] ? lp[now] : rp[now], k);
	pushup(now);
}
```

特殊地，初始时没有任何节点，此时使根节点 $rt$ 等于插入的第一个元素即可。

**为了避免各种边界，一般提前插入一个永远不会删除的数。否则可能出现树被删空的情况，增加冗余讨论。**

```
rt = newnode(INT_MAX);
```

除了第一个元素，每一次插入都会新建两个节点，因此一共有 $2n - 1$ 个节点。

### 删除

这里保证被删数存在。

这里没有写垃圾回收，原因是大部分时候可以认为在删除操作上的垃圾回收没有意义。

理解了插入操作后，删除操作也很容易。找到了待删除的叶子结点后，将其父亲的属性均设为兄弟，然后删除该节点和其兄弟节点。

这里的实现是如果要删 $now$ 的儿子，直接修改 $now$，避免了记录父亲。

第一种实现：

```cpp
il void delt(int now, int k) {
	if (val[lp[now]] >= k) {
		if (siz[lp[now]] == 1) {
			val[now] = val[rp[now]]; siz[now] = siz[rp[now]];
			lp[now] = lp[rp[now]]; rp[now] = rp[rp[now]];
		} else delt(lp[now], k), pushup(now);
	} else {
		if (siz[rp[now]] == 1) {
			val[now] = val[lp[now]]; siz[now] = siz[lp[now]];
			rp[now] = rp[lp[now]]; lp[now] = lp[lp[now]];
		} else delt(rp[now], k), pushup(now);
	}
}
```

这份 delete 有一些需要注意的点：

1. 若修改后是叶子结点，不能 pushup。发现如果修改的是 $now$ 的儿子，无需 pushup。综上，仅在回溯时 pushup。

2. 赋值属性时，这里可以发现，如果删除左儿子，则先赋值左儿子，再赋值右儿子；反之，先赋值右儿子，再赋值左儿子。如果脑子累，可以用更巧妙的方式避免这个优先级问题——**引用**。相当于直接把儿子的编号提上来，如下图：

例如在上面的树中删去 $4$。首先找到该叶子节点及其父节点。

![](https://s1.ax1x.com/2023/01/13/pSKIYrt.png)

删除后剩下右儿子子树。

![](https://s1.ax1x.com/2023/01/13/pSKI8xA.png)

将原父节点的编号直接赋为右儿子的编号。

![](https://s1.ax1x.com/2023/01/13/pSKI32d.png)

删除完成。

![](https://s1.ax1x.com/2023/01/13/pSKItqP.png)


```cpp
il void delt(int &now, int k) {
	if (val[lp[now]] >= k) {
		if (siz[lp[now]] == 1) now = rp[now];
		else delt(lp[now], k), pushup(now);
	} else {
		if (siz[rp[now]] == 1) now = lp[now];
		else delt(rp[now], k), pushup(now);
	}
}
```

两种实现的区别在于，第一种相当于分别更新左右子树的编号，而第二种是直接修改了子树根节点的编号。

这些操作可以轻松卡到单次 $\mathcal O(n)$，总时间复杂度 $\mathcal O(nq)$。

可以通过没有删除操作的 [P5076](https://www.luogu.com.cn/problem/P5076)，也可以尝试提交 [P3369](https://www.luogu.com.cn/problem/P3369) 验证删除的正确性。由于其优秀的常数和数据的水分，在 P3369 中可以获得 $88$ 的好成绩。

附上完整的操作代码：

```cpp
struct LEAFY {
	int lp[MAXN], rp[MAXN], val[MAXN], siz[MAXN], tot;
	int rt;
	
	il void pushup(int x) {
		siz[x] = siz[lp[x]] + siz[rp[x]];
		val[x] = val[rp[x]];
	}
	
	il int newnode(int k) {
		siz[++tot] = 1; val[tot] = k;
		return tot;
	}
	
	il int find_rnk(int k) {
		int now = rt, cnt = 0;
		while (true) {
			if (siz[now] == 1) return cnt + 1;
			else if (val[lp[now]] >= k) now = lp[now];
			else cnt += siz[lp[now]], now = rp[now];
		}
	}
	
	il int find_kth(int k) {
		int now = rt;
		while (true) {
			if (siz[now] == 1) return k == 1 ? val[now] : -1;
			else if (siz[lp[now]] >= k) now = lp[now];
			else k -= siz[lp[now]], now = rp[now];
		}
	}
	
	il int find_pre(int k) {
		return find_kth(find_rnk(k) - 1);
	}
	
	il int find_suc(int k) {
		return find_kth(find_rnk(k + 1));
	}
	
	il void insert(int now, int k) {
		if (siz[now] == 1) {
			int p = newnode(val[now]), q = newnode(k);
			if (val[p] > val[q]) swap(p, q);
			lp[now] = p, rp[now] = q;
			return pushup(now);
		}
		insert(k <= val[lp[now]] ? lp[now] : rp[now], k);
		pushup(now);
	}
	
	il void delt(int &now, int k) {
		if (val[lp[now]] >= k) {
			if (siz[lp[now]] == 1) now = rp[now];
			else delt(lp[now], k), pushup(now);
		} else {
			if (siz[rp[now]] == 1) now = lp[now];
			else delt(rp[now], k), pushup(now);
		}
	}
} T;

int main() {
	int q; read(q); T.rt = T.newnode(INT_MAX); T.insert(T.rt, INT_MIN + 1);
	int op, x;
	while (q--) {
		read(op, x);
		if (op == 1) T.insert(T.rt, x);
		else if (op == 2) T.delt(T.rt, x);
		else if (op == 3) printf("%d\n", T.find_rnk(x) - 1);
		else if (op == 4) printf("%d\n", T.find_kth(x + 1));
		else if (op == 5) printf("%d\n", T.find_pre(x));
		else printf("%d\n", T.find_suc(x));
	}
	rout;
}
```

## Leafy Tree 实现加权平衡树 / 复杂度证明

加权平衡树（Weight Balanced Tree），通过 Leafy Tree 实现即 Weight Balanced Leafy Tree（WBLT）。

定义一个节点的权重 $weight_x=siz_x$。如果一个节点满足 $\min\{weight_{lp_x}, weight_{rp_x}\}\geq \alpha \cdot weight_x$，则称这个节点是 $\alpha$ 加权平衡的。显然 $0<\alpha \leq \dfrac{1}{2}$，这里简单证一下：

> 设正整数 $x\leq y$，满足 $\min\{x, y\}\geq \alpha \cdot (x + y)$，则 $x\geq \alpha\cdot(x+y)$，进而 $\alpha\leq\dfrac{x}{x + y}$。显然 $\dfrac{x}{x + y}\leq \dfrac{1}{2}$，则 $\alpha \leq \dfrac{1}{2}$。

若一棵子树 $T$ 的所有非叶子节点均满足 $\alpha$ 加权平衡，则认为这棵子树是 $\alpha$ 加权平衡的。

一棵含有 $n$ 个元素的加权平衡树的高度 $h$ 满足 $h\leq \log_{\frac{1}{1-\alpha}} n=\mathcal O(\log n)$。

*两个旋转图图源：论文*

这里使用旋转维护加权平衡树的平衡。

当插入或删除一个节点后，树的形态发生变化。其中被影响到权重的点是一条链。考虑依次处理这些节点。

设这棵树的一个子树 $T$ 中，除根节点外的所有节点均满足 $\alpha$ 加权平衡。我们可以用一次单旋或双旋操作使 $T$ 满足 $\alpha$ 加权平衡。

定义一个节点 $x$ 的平衡度为 $\dfrac{weight_{lp_x}}{weight_x}$。

![](https://s1.ax1x.com/2023/01/13/pSKIuVK.png)

如图，设 $x,y$ 旋转前的平衡度分别为 $\rho_1,\rho_2$，旋转后的平衡度分别为 $\gamma_1,\gamma_2$。可以得到 $\gamma_1=\dfrac{\rho_1}{\rho_1+\rho_2(1-\rho_1)},\gamma_2=\rho_1+\rho_2(1-\rho_1)$。论文中没有给出证明，自己胡了一个有点丑的推导过程。~~如果有更好的方法请不吝赐教。~~

**注意这里的 $weight_x$ 均表示旋转前的值。**

先展开各式。
$$
\begin{aligned}
\rho_1=\dfrac{weight_{lp_x}}{weight_{lp_x}+weight_{rp_x}}\Rightarrow weight_{lp_x}=\rho_1(weight_{lp_x} + weight_{rp_x})\\
\rho_2=\dfrac{weight_{lp_y}}{weight_{lp_y}+weight_{rp_y}}\Rightarrow weight_{lp_y}=\rho_2(weight_{lp_y} + weight_{rp_y})\\

\end{aligned}
$$

由定义得

$$
\gamma_1=\dfrac{weight_{lp_x}}{weight_{lp_x} + weight_{lp_y}}
$$

代入 $weight_{lp_x}, weight_{lp_y}$ 得

$$
\begin{aligned}
\gamma_1&=\dfrac{\rho_1(weight_{lp_x} + weight_{rp_x})}{\rho_1(weight_{lp_x} + weight_{rp_x}) + \rho_2(weight_{lp_y} + weight_{rp_y})}\\
&=\dfrac{\rho_1}{\rho_1+\rho_2\frac{weight_{lp_y}+weight_{rp_y}}{weight_{lp_x}+weight_{rp_x}}}
\end{aligned}
$$

观察旋转前图像得 $weight_{lp_y}+weight_{rp_y}=weight_{rp_x}$，再次代入得

$$
\begin{aligned}
\gamma_1&=\dfrac{\rho_1}{\rho_1+\rho_2\frac{weight_{rp_x}}{weight_{lp_x}+weight_{rp_x}}}\\
&=\dfrac{\rho_1}{\rho_1+\rho_2(1-\frac{weight_{lp_x}}{weight_{lp_x}+weight_{rp_x}})}\\

&=\dfrac{\rho_1}{\rho_1+\rho_2(1-\rho_1)}
\end{aligned}
$$

$\gamma_2$ 的证明比较简单：

由定义得

$$
\gamma_2=\dfrac{weight_{lp_x}+weight_{lp_y}}{weight_{lp_x} + weight_{lp_y} + weight_{rp_y}}
$$

由 $weight_{lp_y}+weight_{rp_y}=weight_{rp_x}$，代入得

$$
\begin{aligned}
\gamma_2&=\dfrac{weight_{lp_x}+weight_{lp_y}}{weight_{lp_x} + weight_{rp_x}}\\
&=\rho_1+\dfrac{weight_{lp_y}}{weight_{lp_x} + weight_{rp_x}}\\
&=\rho_1+\rho_2\dfrac{weight_{lp_y}+weight_{rp_y}}{weight_{lp_x} + weight_{rp_x}}\\
&=\rho_1+\rho_2\dfrac{weight_{rp_x}}{weight_{lp_x} + weight_{rp_x}}\\
&=\rho_1+\rho_2(1-\rho_1)
\end{aligned}
$$

![](https://s1.ax1x.com/2023/01/13/pSKImb6.png)

如图，设 $x,y,z$ 旋转前的平衡度分别为 $\rho_1,\rho_2,\rho_3$，旋转后的平衡度分别为 $\gamma_1,\gamma_2,\gamma_3$。可以得到 $\gamma_1=\dfrac{\rho_1}{\rho_1+\rho_2\rho_3(1-\rho_1)},\gamma_2=\rho_1+\rho_2\rho_3(1-\rho_1),\gamma_3=\dfrac{\rho_2(1-\rho_3)}{1-\rho_2\rho_3}$。证明方法与单旋时类似，不再赘述。

可以证明当 $\alpha\leq 1-\frac{\sqrt 2}{2}$ 时，通过这两种操作，使得操作后的这些节点的平衡度在 $[\alpha,1-\alpha]$ 内。

当 $\rho_2 < \frac{1-2\alpha}{1-\alpha}$ 时，执行一次单旋，否则执行一次双旋。

------------------

下面在 $lp, rp$ 的同时定义左儿子是 $ch_0$，右儿子是 $ch_1$。

。。。旋转和维护平衡按照上面的规则写就好了。$\alpha$ 取 $1-\frac{\sqrt 2}{2}\approx 0.29$。nalemy 称取 $0.25$ 会更快，不过作者不太懂这方面的内容。

```cpp
il void rotate(int x, bool d) {  // d 表示将哪个儿子旋转到 x 的位置
	swap(lp[x], rp[x]);
	swap(lp[ch(x, d ^ 1)], rp[ch(x, d ^ 1)]);
	swap(ch(ch(x, d ^ 1), d ^ 1), ch(x, d));
	pushup(ch(x, d ^ 1)); pushup(x);
}

il void maintain(int x) {
	int d;
	if (siz[x] == 1) return;
	if (siz[lp[x]] < siz[x] * alpha) d = 1;
	else if (siz[rp[x]] < siz[x] * alpha) d = 0;
	else return;
	if (siz[ch(ch(x, d), d ^ 1)] * (1 - alpha) >= siz[ch(x, d)] * (1 - 2 * alpha))
		rotate(ch(x, d), d ^ 1);
	rotate(x, d);
}
```

只需要在树的形态发生改变时——插入/删除后，对每一个回溯时的节点进行 maintain 操作维护平衡即可。其余操作显然与实现二叉搜索树的代码没有任何差异。

贴上更改后的插入删除代码。

```cpp
il void insert(int now, int k) {
	if (siz[now] == 1) {
		int p = newnode(val[now]), q = newnode(k);
		if (val[p] > val[q]) swap(p, q);
		lp[now] = p, rp[now] = q;
		return pushup(now);
	}
	insert(k <= val[lp[now]] ? lp[now] : rp[now], k);
	pushup(now); maintain(now);
}

il void delt(int &now, int k) {
	if (val[lp[now]] >= k) {
		if (siz[lp[now]] == 1) {
			now = rp[now];
		} else delt(lp[now], k), pushup(now), maintain(now);
	} else {
		if (siz[rp[now]] == 1) {
			now = lp[now];
		} else delt(rp[now], k), pushup(now), maintain(now);
	}
}
```

时间复杂度 $\mathcal O(n\log n)$。在 [P6136](https://www.luogu.com.cn/problem/P6136) 中，WBLT 的常数优势体现得非常明显。稍有优化的 FHQ-Treap（即尽量不依靠分裂合并操作以减小常数）在 13.5s 左右，不优化的 FHQ-Treap 在 16s 左右，贺了一份旋转 Treap 在 12.5s 左右，[WBLT](https://www.luogu.com.cn/record/101211140) 在 8.5s 左右。

不过总时间的比较反而有些片面。若仔细对比每个测试点，会发现在一些测试点上 WBLT 对于 Treap 达到 $2\sim 4$ 倍的碾压；而相对来看，有些 WBLT 稍慢的测试点差距并不明显。

**更多拓展应用参见文首的博客。**

```cpp
struct LEAFY {
	int lp[MAXN], rp[MAXN], val[MAXN], siz[MAXN], tot;
	int st[MAXN], len;
	int rt, x, y; const double alpha = 0.29;
	#define ch(x, d) ((d) ? rp[x] : lp[x])
	
	il void pushup(int x) {
		siz[x] = siz[lp[x]] + siz[rp[x]];
		val[x] = val[rp[x]];
	}
	
	il int newnode(int k) {
		int p = len ? st[len--] : ++tot;
		siz[p] = 1; val[p] = k; lp[p] = rp[p] = 0;
		return p;
	}
	
	il int find_rnk(int k) {
		int now = rt, cnt = 0;
		while (true) {
			if (siz[now] == 1) return cnt + 1;
			else if (val[lp[now]] >= k) now = lp[now];
			else cnt += siz[lp[now]], now = rp[now];
		}
	}
	
	il int find_kth(int k) {
		int now = rt;
		while (true) {
			if (siz[now] == 1) return k == 1 ? val[now] : -1;
			else if (siz[lp[now]] >= k) now = lp[now];
			else k -= siz[lp[now]], now = rp[now];
		}
	}
	
	il int find_pre(int k) {
		return find_kth(find_rnk(k) - 1);
	}
	
	il int find_suc(int k) {
		return find_kth(find_rnk(k + 1));
	}
	
	il void rotate(int x, bool d) {
		swap(lp[x], rp[x]);
		swap(lp[ch(x, d ^ 1)], rp[ch(x, d ^ 1)]);
		swap(ch(ch(x, d ^ 1), d ^ 1), ch(x, d));
		pushup(ch(x, d ^ 1)); pushup(x);
	}
	
	il void maintain(int x) {
		int d;
		if (siz[x] == 1) return;
		if (siz[lp[x]] < siz[x] * alpha) d = 1;
		else if (siz[rp[x]] < siz[x] * alpha) d = 0;
		else return;
		if (siz[ch(ch(x, d), d ^ 1)] * (1 - alpha) >= siz[ch(x, d)] * (1 - 2 * alpha)) rotate(ch(x, d), d ^ 1);
		rotate(x, d);
	}
	
	il void insert(int now, int k) {
		if (siz[now] == 1) {
			int p = newnode(val[now]), q = newnode(k);
			if (val[p] > val[q]) swap(p, q);
			lp[now] = p, rp[now] = q;
			return pushup(now);
		}
		insert(k <= val[lp[now]] ? lp[now] : rp[now], k);
		pushup(now); maintain(now);
	}
	
	il void delt(int &now, int k) {
		if (val[lp[now]] >= k) {
			if (siz[lp[now]] == 1) now = rp[now];
			else delt(lp[now], k), pushup(now), maintain(now);
		} else {
			if (siz[rp[now]] == 1) now = lp[now];
			else delt(rp[now], k), pushup(now), maintain(now);
		}
	}
} T;

int main() {
	int n, m; read(n, m); T.rt = T.newnode(INT_MAX); T.insert(T.rt, INT_MIN + 1);
	rep1(i, 1, n) T.insert(T.rt, read());
	int op, x, S = 0, ans = 0;
	while (m--) {
		read(op, x); x ^= S;
		if (op == 1) T.insert(T.rt, x);
		else if (op == 2) T.delt(T.rt, x);
		else if (op == 3) ans ^= (S = T.find_rnk(x) - 1);
		else if (op == 4) ans ^= (S = T.find_kth(x + 1));
		else if (op == 5) ans ^= (S = T.find_pre(x));
		else ans ^= (S = T.find_suc(x));
	} printf("%d", ans);
}
```

---

## 作者：ivyjiao (赞：3)

这题有多少种解法啊？

这里介绍一种时间复杂度正确的且不是 pbds 的做法，类似 pbds，在 `__gnu_cxx` 库里。

---

一眼望去，这题的六个操作都可以用 vector 实现，那就直接用 vector 做行不行？

需要熟练运用 $\text{insert},\text{erase}$ 等操作，思路十分简单，在这里不提了。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,op,x;
vector <int> vec; 
int main(){
    scanf("%d",&n);
    while(n--){
        scanf("%d %d",&op,&x);
        if(op==1) vec.insert(lower_bound(vec.begin(),vec.end(),x),x);
        else if(op==2) vec.erase(lower_bound(vec.begin(),vec.end(),x));
        else if(op==3) printf("%d\n",lower_bound(vec.begin(),vec.end(),x)-vec.begin()+1);
        else if(op==4) printf("%d\n",vec[x-1]);
        else if(op==5) printf("%d\n",vec[lower_bound(vec.begin(),vec.end(),x)-vec.begin()-1]);
        else printf("%d\n",vec[upper_bound(vec.begin(),vec.end(),x)-vec.begin()]);
    }
}
```

---

但是 vector 的 $\text{insert}$ 和 $\text{erase}$ 是 $O(n)$ 的，只不过做了很多优化。

所以 vector 是能被卡掉的，虽然我没在网上找到像是卡掉 SPFA 一样的卡掉 vector 教程，但是肯定是能卡掉的。

但是 [rope](https://oi-wiki.org/ds/block-list/) 的 $\text{insert}$ 和 $\text{erase}$ 都是严格 $O(\log n)$ 的！本题 $1\leq n\leq 10^5$，$O(\log n)$ 完全可过，时间复杂度 $O(n\log n)$，由于其常数巨巨巨大，在 $n\leq 10^5$ 的情况下（不是本题，另外一道题）都能被卡到 $900ms$，经测试其常数约为 vector 的四倍，所以实际速度和 $O(n\sqrt n)$ 没什么太大区别，也不能通过 $n\leq 1.1\times 10^6$ 的加强版。

之所以说这个是因为很多人以为它跟块状链表放在一起就误认为它的 $O(\sqrt n)$ 的数据结构，实际上原文也说了：

> 由于 rope 并不是真正的用块状链表来实现，所以它的时间复杂度并不等同于块状链表，而是相当于可持久化平衡树的复杂度 $O(\log n)$。

~~感觉这个东西比 rb_tree_tag 都要冷门？~~

代码：

```cpp
#include<bits/stdc++.h>
#include<bits/extc++.h>
using namespace std;
using namespace __gnu_cxx;
int n,op,x;
rope<int>a; 
int main(){
    cin>>n;
    while(n--){
        cin>>op>>x;
        if(op==1) a.insert(lower_bound(a.begin(),a.end(),x)-a.begin(),x);
        if(op==2) a.erase(lower_bound(a.begin(),a.end(),x)-a.begin(),1);
        if(op==3) cout<<lower_bound(a.begin(),a.end(),x)-a.begin()+1<<endl;
        if(op==4) cout<<a[x-1]<<endl;
        if(op==5) cout<<a[lower_bound(a.begin(),a.end(),x)-a.begin()-1]<<endl;
        if(op==6) cout<<a[upper_bound(a.begin(),a.end(),x)-a.begin()]<<endl;
    }
}
```

---

## 作者：masonxiong (赞：1)

# 引入

在 OI 里面我们经常会遇到一些需要用到平衡树的题。虽然其中大部分题都可以用 `std::set` 解决，但是总有那么一些东西是 `std::set` 解决不了的，比如查排名之类的。

那么这个时候，我们要么用 pbds 里面的 `tree` 要么自己写平衡树。但 pbds 里面的平衡树用起来非常麻烦，要记一堆什么乱七八糟的玩意，还不好调。那么我们最好的方案便是自己写一个平衡树。

但平衡树的码量是众所周知的大，动不动就上百行，而且一般都是写半小时调两小时，写完平衡树考试都结束了。再加上大部分平衡树维护平衡的方式都非常难记，各种左右乱转和分类讨论完全写不了。

上回书说到，我们[用字典树实现了平衡树](https://www.luogu.com.cn/article/e1pc7u61)。虽然它跑的快、代码短、功能多，但是空间占用多一个 $\log w$ 使得其无法通过[加强版平衡树模板](https://www.luogu.com.cn/problem/P6136) 并且只能维护极其有限的一些类型的数据，我们需要一些更好的方法。

那么我们直接给出更好理解的方法：**使用块状链表来写平衡树**。

---

# 中心思想

我们将需要维护的有序数列划分成 $l$ 段，平均每段有 $m$ 个元素。

由于数列的有序性，你在查找的时候可以整块整块地跳，找到目标块之后再在该块内进行查找，总体时间复杂度是 $O(l+m)$。插入时只会使得一个块内的元素被移动，为 $O(l+m)$。

根据均值不等式，$l,m\ge 0\implies l+m\ge 2\sqrt{l\cdot m}=2\sqrt{n}$，当且仅当 $l=m=\sqrt n$ 时等号成立。此时我们发现，时间复杂度来到了 $O(\sqrt n)$。

当然，为了保证 $l,m\approx\sqrt n$，你需要动态记录块长度，若某个块长度过大，则把它分裂成两个小块；如果某个块过小，则尝试把它接到旁边一个块上。

具体实现上，你可以用 `std::vector` 套 `std::vector`，使得外层块查找也可以二分，时间复杂度虽然没变，但是常数会小很多。

---

# 具体实现

平衡树的基本操作无非就是这 6 个：

- 插入。
- 删除。
- 由值查排名。
- 由排名查值。
- 查前驱。
- 查后继。

我们一个一个拆解它们。

---

## 辅助操作：块分裂

用于维护块长不过大。一般来说，我们控制分裂阈值为 $2\sqrt n$。

```cpp
void split(BlockList::iterator block) {
    // 检查并分裂 block 所指向的块。
    if (block->size() > BlockSize << 1) {
        // 此块大小达到了分裂阈值。
        block = std::prev(blockList.emplace(std::next(block), std::make_move_iterator(block->begin() + BlockSize), std::make_move_iterator(block->end())));
        // 将此块的后半部分移动到一个新块上，并将这个新块插入到这个块的后面，更新此块的迭代器位置。
        // 这种使用 emplace 以及 make_move_iterator 的实现方法使用了原位构造以及移动迭代器，常数会小很多。
        block->resize(BlockSize);
        // 更新此块大小。
    }
}

```

---

## 辅助操作：块合并

用于维护块长不过小。一般来说，如果两个块合并起来的大小也没有超过 $2\sqrt n$，我们就把它们并起来。

```cpp
void merge(BlockList::iterator block) {
    // 检查并合并 block 所指向的块以及其后面一个块。
    if (std::next(block) != blockList.end() && block->size() + std::next(block)->size() < BlockSize << 1) {
        // 两块大小之和达到了合并要求。
        block->insert(block->end(), std::make_move_iterator(std::next(block)->begin()), std::make_move_iterator(std::next(block)->end()));
        // 将后面一个块并到这个块的最后。
        blockList.erase(std::next(block));
        // 后面的块此时已经空了，可以直接抹掉。
    }
}
```

---

## 插入

先找到待插入值所应当在的块，然后在这个块内查询待插入值所应当在的位置，然后插入它，最后检查分裂。

```cpp
void insert(const Value& value) {
    // 插入 value。
	auto block = std::upper_bound(blockList.begin(), blockList.end(), value, [](const Value& value, const Block& block) -> bool { return block.back() >= value; });
    // 二分查找第一个满足 block.back() >= value 的块（value 所应当在的块），若没有则为 blockList.end()。
    if (block == blockList.end()) {
        // 不存在这样的块，说明 value 比现有的所有元素都大，应当插入到最后面。
        if (blockList.empty()) {
            // 特判数列为空的情况，此时需要单开一个块。
            blockList.emplace_back(1, value);
        } else {
            blockList.back().push_back(value);
            // 将其插入到最后一个块的后面。
            split(std::prev(blockList.end()));
            // 检查分裂最后一个块。
        }
    } else {
        block->insert(std::lower_bound(block->begin(), block->end(), value), value);
        // 二分查找 value 应当插入到的位置，然后插入它。
        split(block);
        // 检查分裂这个块。
    }
}
```

---

## 删除

先找到待删除值所应当在的块，然后在这个块内查询待删除值所应当在的位置，然后删除它，最后检查合并。

```cpp
void erase(const Value& value) {
    // 删除 value。
    auto block = std::upper_bound(blockList.begin(), blockList.end(), value, [](const Value& value, const Block& block) -> bool { return block.back() >= value; });
    // 二分查找第一个满足 block.back() >= value 的块（value 所应当在的块），若没有则为 blockList.end()。
    block->erase(std::lower_bound(block->begin(), block->end(), value));
    // 在此块内二分查找并删除 value。
    if (block->empty())
        // 特判此块被删空的情况，此时需要直接抹掉这个块。
        blockList.erase(block);
    else
        merge(block);
        // 检查合并这个块。
}
```

---

## 由值查排名

先找到待查询值所应当在的块，然后累加这个块之前所有块的大小（因为这些块的元素显然都比待查询值小），然后在这个块内统计比待查询元素小的元素个数，加上去即可。

```cpp
std::size_t queryRank(const Value& value) {
    // 由值查排名。
    auto block = std::upper_bound(blockList.begin(), blockList.end(), value, [](const Value& value, const Block& block) -> bool { return block.back() >= value; });
    // 二分查找第一个满足 block.back() >= value 的块（value 所应当在的块），若没有则为 blockList.end()。
    return std::accumulate(blockList.begin(), block, std::size_t(0), [](std::size_t sum, const Block& block) -> std::size_t { return sum + block.size(); })
           // 累加这个块之前所有块的大小。
        +  (block == blockList.end() ?
                // 不存在这样的块，说明 value 比现有的所有元素都大，比它小的元素都已经被统计完了。
                0 
            :
                std::lower_bound(block->begin(), block->end(), value) - block->begin());
                // 在此块内二分查找比 value 小的元素个数。
}
```

---

## 由排名查值

一个一个跳块，直到跳过的所有块的大小之和大于所查询的排名为止，然后取最后一个块的相应元素。

```cpp
const Value& queryValue(std::size_t rank) {
    // 由排名查值。
    auto block = std::find_if(blockList.begin(), blockList.end(), [&rank](const Block& block) -> bool {
        if (block.size() > rank)
            // 此块包含该排名。
            return true;
        rank -= block.size();
        // 累加排名的一种方法。
        return false;
    });
    // 查询该排名所在的块。
    return block->at(rank);
}
```

---

## 查前驱

先找到待查询值所应当在的块，然后在这个块内找它的前驱即可。如果这个块的开头都不是它的前驱，说明它的前驱是前一个块的最后一个元素。

```cpp
const Value& queryPrecursor(const Value& value) {
    // 查前驱。
    auto block = std::upper_bound(blockList.begin(), blockList.end(), value, [](const Value& value, const Block& block) -> bool { return block.back() >= value; });
    // 二分查找第一个满足 block.back() >= value 的块（value 所应当在的块），若没有则为 blockList.end()。
    return block == blockList.end() || block->front() >= value ?
               // 这个块的开头不是它的前驱或这个块不存在。
               std::prev(block)->back()
            :
               // 在这个块内查询 value 的前驱。
               *std::prev(std::lower_bound(block->begin(), block->end(), value));
}
```

---

## 查后继

先找到待查询值最后一次出现的块，然后在这个块内找它的后继即可。

```cpp
const Value& querySuccessor(const Value& value) {
    // 查后继。
    auto block = std::upper_bound(blockList.begin(), blockList.end(), value, [](const Value& value, const Block& block) -> bool { return block.back() > value; });
    // 二分查找第一个满足 block.back() > value 的块（value 最后一次出现的块）。
    return *std::upper_bound(block->begin(), block->end(), value);
}
```

---

以上，平衡树六大基本操作全部实现。

至此，一锤定音。  
尘埃，已然落定。

- [平衡树模板题](https://www.luogu.com.cn/problem/P3369)[通过记录](https://www.luogu.com.cn/record/215948418) & [卡常通过记录](https://www.luogu.com.cn/record/215950581)。

完整版代码非常简短，不含主函数只有 $40$ 行。

```cpp
using Value = std::int32_t;
using Block = std::vector<Value>;
using BlockList = std::vector<Block>;

constexpr std::size_t BlockSize = 512;

BlockList blockList;

inline void split(BlockList::iterator block) noexcept { block->size() > BlockSize << 1 && (block = std::prev(blockList.emplace(std::next(block), std::make_move_iterator(block->begin() + BlockSize), std::make_move_iterator(block->end()))), block->resize(BlockSize), true); }
inline void merge(BlockList::iterator block) noexcept { std::next(block) != blockList.end() && block->size() + std::next(block)->size() < BlockSize << 1 && (block->insert(block->end(), std::make_move_iterator(std::next(block)->begin()), std::make_move_iterator(std::next(block)->end())), blockList.erase(std::next(block)), true); }

void insert(const Value& value) noexcept {
	auto block = std::upper_bound(blockList.begin(), blockList.end(), value, [](const Value& value, const Block& block) -> bool { return block.back() >= value; });
    block == blockList.end() ? (blockList.empty() ? void(blockList.emplace_back(1, value)) : (blockList.back().push_back(value), split(std::prev(blockList.end())))) : (block->insert(std::lower_bound(block->begin(), block->end(), value), value), split(block));
}

void erase(const Value& value) noexcept {
    auto block = std::upper_bound(blockList.begin(), blockList.end(), value, [](const Value& value, const Block& block) -> bool { return block.back() >= value; });
    block->erase(std::lower_bound(block->begin(), block->end(), value)), block->empty() ? void(blockList.erase(block)) : merge(block);
}

std::size_t queryRank(const Value& value) noexcept {
    auto block = std::upper_bound(blockList.begin(), blockList.end(), value, [](const Value& value, const Block& block) -> bool { return block.back() >= value; });
    return std::accumulate(blockList.begin(), block, std::size_t(0), [](std::size_t sum, const Block& block) -> std::size_t { return sum + block.size(); }) + (block == blockList.end() ? 0 : std::lower_bound(block->begin(), block->end(), value) - block->begin());
}

const Value& queryValue(std::size_t rank) noexcept {
    auto block = std::find_if(blockList.begin(), blockList.end(), [&rank](const Block& block) -> bool { if (block.size() > rank) return true; rank -= block.size(); return false; });
    return block->at(rank);
}

const Value& queryPrecursor(const Value& value) noexcept {
    auto block = std::upper_bound(blockList.begin(), blockList.end(), value, [](const Value& value, const Block& block) -> bool { return block.back() >= value; });
    return block == blockList.end() || block->front() >= value ? std::prev(block)->back() : *std::prev(std::lower_bound(block->begin(), block->end(), value));
}

const Value& querySuccessor(const Value& value) noexcept {
    auto block = std::upper_bound(blockList.begin(), blockList.end(), value, [](const Value& value, const Block& block) -> bool { return block.back() > value; });
    return *std::upper_bound(block->begin(), block->end(), value);
}
```

---

---

## 作者：Imerance1018 (赞：1)

## Solution

使用 trie 来实现平衡树。

我们发现，通过在一个数的前面加前导 $0$ 将其补成 $8$ 位，就可以将数字的比较大小转换成字符串按字典序比较大小。

所以就等价于维护一个大小为 $10$ 的字符集，支持插入，删除，给值查排名和给排名查值。（求前驱和后继可以使用操作 $3$ 和操作 $4$ 嵌套得到）

我们需要在 trie 的每个子节点上维护 $sz$ 表示以此节点为根的子树权值和。

插入和删除是 trie 的基本操作，在这里不多讲。


对于给值 $x$ 查排名，到第几层就加上连边小于 $x$ 第几位的节点的 $sz$ 和,再走到连边等于 $x$ 第几位的节点，一直到底，最后输出时把答案加 $1$ 即可。

反之，给排名 $x$ 查值，到第几层就累加 $sz$ 和直到和大于 $x$ 为止，然后选定此节点到下一层。

最后要注意：由于可能有负数，所以输入时要把维护的值加上 $10^7$，输出时再减回去。

### Tips

trie 的优点在于思路清晰，好写好调，常数小。

时间复杂度 $O(n\log{n})$，但常数小，跑得很快。

使用普通 trie 空间复杂度较大，为 $O(n\log{W})$，$W$ 为值域，在此题可以通过，但是加强版不行。（当然你可以用压缩 trie 去写来把空间降到 $O(n)$，但是就不如 treap 等平衡树好写了）

## Code
```cpp
//比平衡树简单多了
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+10;
int q,rt,tot,K=1e7;
struct Trie
{
	int val[N][10],sz[N];
	void insert(int x)
	{
		int now=0,tmp=K;
		for(int i=7;i>=0;i--)
		{
			if(!val[now][x/tmp])val[now][x/tmp]=++tot,sz[tot]=0;
			sz[now]++;
			now=val[now][x/tmp];
			x%=tmp;
			tmp/=10;
		}
		sz[now]++;
	}
	void delett(int x)
	{
		int now=0,tmp=K;
		for(int i=7;i>=0;i--)
		{
			sz[now]--;
			now=val[now][x/tmp];
			x%=tmp;
			tmp/=10;
		}
		sz[now]--;
	}
	int query1(int x)
	{
		int now=0,res=0,tmp=K;
		for(int i=7;i>=0;i--)
		{
			for(int j=0;j<x/tmp;j++)if(val[now][j]!=0)res+=sz[val[now][j]];
			if(val[now][x/tmp]==0)break; 
			now=val[now][x/tmp];
			x%=tmp;
			tmp/=10;
		}
		return res+1;
	}
	int query2(int x)
	{
		int now=0,res=0,tmp=K;
		for(int i=7;i>=0;i--)
		{
			int sum=0,pos=0;
			for(int j=0;j<10;j++)
			{
				if(sz[val[now][j]]==0||val[now][j]==0)continue;
				sum+=sz[val[now][j]];
				if(sum>=x)
				{
					x-=(sum-sz[val[now][j]]);
					pos=j;
					break;
				}
			}
			now=val[now][pos];
			res+=pos*tmp;
			tmp/=10;
		}
		return res;
	}
}tree;
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>q;
	while(q--)
	{
		int opt,x;
		cin>>opt>>x;
		if(opt==1)tree.insert(x+K);
		else if(opt==2)tree.delett(x+K);
		else if(opt==3)cout<<tree.query1(x+K)<<"\n";
		else if(opt==4)cout<<tree.query2(x)-K<<"\n"; 
		else if(opt==5)cout<<tree.query2(tree.query1(x+K)-1)-K<<"\n"; 
		else if(opt==6)cout<<tree.query2(tree.query1(x+1+K))-K<<"\n";
	}
	return 0;
}
``````

---

## 作者：wjyppm1403 (赞：1)

[更全面的阅读体验](https://worldcpu.github.io/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8.html)

给出一个很新颖的做法——树状数组。

# 1. 树状数组二分介绍

## 1.1 题目类型和结构特点

对于本题中，我们不难想到使用的是权值树状数组，但是查询前后第 $k$ 小却很难，这里我们需要用到树状数组二分的技巧。

类似于线段树二分，树状数组当然也可以二分。

它解决的是如下一类问题：

> 对于序列 $a$，存在分割点 $q$ 使得小于等于 $q$ 的位置满足某个限制，而大于 $q$ 的位置不满足限制，求 $q$。

注意！这里我们是对整个序列进行二分，而非对任意位置开始二分。

考虑最后一个前缀和小于等于 $v$ 的位置，满足序列每个元素非负，则存在分割点 $q$ 满足小于等于 $q$ 的位置的前缀和小于等于 $v$ ，而大于 $q$ 的位置的前缀和大于 $v$ ，那么 $q$ 即为所求。

当然，我们可以直接通过二分树状数组的手段，做到一个 $O(Q \log^{2} n)$ 的一个复杂度，但是还可以更优。

我们考虑树状数组的结构，树状数组每一个节点存储了区间 $[p-\operatorname{lowbit}(p)+1,p]$ 的信息，观察区间，其长度都是以 2 的次幂进行增长，也就是说树状数组天然就是一个适合倍增的一个场所，见下图蓝色实例。

![](https://cdn.luogu.com.cn/upload/image_hosting/qr0y51o8.png)

## 1.2 实现细节与正确性证明

于是我们可以考虑倍增，我们初始化两个变量，当前位置 $p$ 和对应的前缀和 $s$，初始权为 0。

我们从大到小枚举 $1\le 2^{k} \le n$，尝试将 $p$ 加上 $2^{k}$。检查 $s+\sum\limits_{i=p+1}^{p+2^{k}} a_{i}\le v$ 是否成立，因为 $k$ 从小到大枚举，此时 $\operatorname{lowbit}(p)>2^{k}$，那么显然有 $\operatorname{lowbit}(p+2^{k})=2^{k}$，因为树状数组中 $t[i]$ 中填的是 $[i-\operatorname{lowbit}(i)+1,i]$ 这个区间的信息，那么也就是说 $t[p+2^{k}]=\sum\limits_{i=p+1}^{p+2^{k}} a_{i}$。

那么就可以这么做：
- 初始化两个变量，当前位置 $p$ 和对应的前缀和 $s$，初始权为 0。
- 从大到小枚举 $1\le 2^{k} \le n$。
	- 若 $p+2^{k}\le n$ 且 $s+t[p+2^{k}]\le v$。则 $p\leftarrow p+2^{k},s\leftarrow s+t[p+2^{k}]$。
	- 若 $p+2^{k}>n$，啥也不做超范围了。

$p$ 一定等于最终求的 $q$，否则 $p$ 在过程一定会变得更大。

分析时间复杂度，因为我们查询树状数组节点信息是 $O(1)$ 的，而枚举幂是 $O(\log n)$ 的，加上询问我们的时间复杂度即为 $O(Q \log n)$，利用树状数组区间长度是 2 的幂这一特性，我们利用倍增就可以达到二分的效果。

有了树状数组二分，我们就可以完成第 $k$ 小的查询。

查询如下：

```cpp
    int getkth(int x)
    {
        int p = 0, s = 0;
        for (int i = 20; i >= 0; i--)
        {
            int np=p+(1<<i);// 新的p
            if(np>tot) continue; // 如果超出范围就continue
            int ns=s+t[np]; // 新的s
            if(ns<x){ // 判断是否满足
                s=ns;
                p=np;
            }
        }
        return p+1;// 因为我们ns的判断条件是小于，所以点在p的后面
    }
```

# 2 代码实现

而对于维护其他操作也很简单，因为我们用的是权值树状数组，对于前三个操作实现简单，后两个操作可以用上面的函数即可实现，实现代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int MN = 2e5 + 15,P=1e5+1;
int n, m, tot, op[MN], a[MN], b[MN];

namespace ly
{
    namespace IO
    {
        #ifndef LOCAL
            constexpr auto maxn=1<<20;
            char in[maxn],out[maxn],*p1=in,*p2=in,*p3=out;
            #define getchar() (p1==p2&&(p2=(p1=in)+fread(in,1,maxn,stdin),p1==p2)?EOF:*p1++)
            #define flush() (fwrite(out,1,p3-out,stdout))
            #define putchar(x) (p3==out+maxn&&(flush(),p3=out),*p3++=(x))
            class Flush{public:~Flush(){flush();}}_;
        #endif
        namespace usr
        {
            template<typename type>
            inline type read(type &x)
            {
                x=0;bool flag(0);char ch=getchar();
                while(!isdigit(ch)) flag^=ch=='-',ch=getchar();
                while(isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
                return flag?x=-x:x;
            }
            template<typename type>
            inline void write(type x)
            {
                x<0?x=-x,putchar('-'):0;
                static short Stack[50],top(0);
                do Stack[++top]=x%10,x/=10;while(x);
                while(top) putchar(Stack[top--]|48);
            }
            inline char read(char &x){do x=getchar();while(isspace(x));return x;}
            inline char write(const char &x){return putchar(x);}
            inline void read(char *x){static char ch;read(ch);do *(x++)=ch;while(!isspace(ch=getchar())&&~ch);}
            template<typename type>inline void write(type *x){while(*x)putchar(*(x++));}
            inline void read(string &x){static char ch;read(ch),x.clear();do x+=ch;while(!isspace(ch=getchar())&&~ch);}
            inline void write(const string &x){for(int i=0,len=x.length();i<len;++i)putchar(x[i]);}
            template<typename type,typename...T>inline void read(type &x,T&...y){read(x),read(y...);}
            template<typename type,typename...T>
            inline void write(const type &x,const T&...y){write(x),putchar(' '),write(y...),sizeof...(y)^1?0:putchar('\n');}
            template<typename type>
            inline void put(const type &x,bool flag=1){write(x),flag?putchar('\n'):putchar(' ');}
        }
        #ifndef LOCAL
            #undef getchar
            #undef flush
            #undef putchar
        #endif
    }using namespace IO::usr;
}using namespace ly::IO::usr;

struct BIT
{
    int t[MN];

    int lowbit(int x)
    {
        return x & -x;
    }

    void update(int x, int k)
    {
        while (x < MN)
        {
            t[x] += k;
            x += lowbit(x);
        }
    }

    int query(int x)
    {
        int ret = 0;
        while (x)
        {
            ret += t[x];
            x -= lowbit(x);
        }
        return ret;
    }

    int getkth(int x)
    {
        int p = 0, s = 0;
        for (int i = 20; i >= 0; i--)
        {
            int np=p+(1<<i);// 新的p
            if(np>tot) continue; // 如果超出范围就continue
            int ns=s+t[np]; // 新的s
            if(ns<x){ // 判断是否满足
                s=ns;
                p=np;
            }
        }
        return p+1;// 因为我们ns的判断条件是小于，所以点在p的后面
    }

} bit;

int main()
{
    ios::sync_with_stdio(0);
    cout.tie(0);
    read(n);
    for (int i = 1; i <= n; i++)
    {
        read(op[i]);
        read(a[i]);
        a[i]+=P;
    }
    for (int i = 1; i <= n; i++)
    {
        if (op[i] == 1)
        {
            bit.update(a[i], 1);
        }
        if (op[i] == 2)
        {
            bit.update(a[i], -1);
        }
        if (op[i] == 3)
        {
            cout << bit.query(a[i] - 1)+1<< '\n';
        }
        if (op[i] == 4)
        {
            cout<<b[bit.getkth(a[i])]<<'\n';
        }
        if(op[i]==5){
            cout<<b[bit.getkth(bit.query(a[i]-1))]<<'\n';
        }
        if(op[i]==6){
            cout<<b[bit.getkth(bit.query(a[i])+1)]<<'\n';
        }
    }
    return 0;
}
```

---


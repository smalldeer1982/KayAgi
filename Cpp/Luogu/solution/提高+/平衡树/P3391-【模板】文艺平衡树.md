# 【模板】文艺平衡树

## 题目描述

您需要写一种数据结构（可参考题目标题），来维护一个有序数列。  

其中需要提供以下操作：翻转一个区间，例如原有序序列是 $5\ 4\ 3\ 2\ 1$，翻转区间是 $[2,4]$ 的话，结果是 $5\ 2\ 3\ 4\ 1$。


## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1 \le n, m \leq 100000 $，$1 \le l \le r \le n$。


## 样例 #1

### 输入

```
5 3
1 3
1 3
1 4```

### 输出

```
4 3 2 1 5```

# 题解

## 作者：皎月半洒花 (赞：631)

嗯呐……我发现本蒟做这种题总会被卡……并且总是被一些奇奇怪怪的东西卡死……呃不是算法，是打代码时不细心，导致调试了好长时间 ORZ。

那么，Splay 的基础操作[戳这里](https://www.luogu.org/blog/pks-LOVING/more-senior-data-structure-te-bie-qian-di-qian-tan-splay)。

那么对于区间反转这种操作，我们由于原数列的顺序已经给定，所以不能按照权值排序，所以选择按照点的编号建立一棵二叉搜索树。

诶，所以啊，不用一个个 `insert` 编号，我们只需要进行一下递归建树即可——建树可以仿照线段树的建树 qwq。

那么就类似这样：
```cpp
struct Splay_tree{
	int f,sub_size,cnt,value,tag;
	int son[2];
}s[MAXN];
inline void update(int x){
	if(x){
	s[x].sub_size=s[x].cnt;
	if(s[x].son[0])s[x].sub_size+=s[s[x].son[0]].sub_size;
    if(s[x].son[1])s[x].sub_size+=s[s[x].son[1]].sub_size;
	}
}
int build_tree(int l, int r, int fa) {
        if(l > r) { return 0; }
        int mid = (l + r) >> 1;
        int now = ++ wz;
        s[now].f=fa;
	    s[now].son[0]=s[now].son[1]=0;
		s[now].cnt++;
    	s[now].value=original[mid];
		s[now].sub_size++;
        s[now].son[0] = build_tree(l, mid - 1, now);
        s[now].son[1] = build_tree(mid + 1, r, now);
        update(now);
        return now;
}
```
emmmm 码风还算是中规中矩吧。

那么我们现在已经有一棵编号树了(并且由于递归建树，一开始是平衡的)，我们要对它进行区间翻转操作。那么实际上我们可以发现，在反转区间 $l\sim r$ 的时候，我们可以考虑利用 Splay 的性质，将 $l-1$ 翻转至根节点，再将 $r+1$ 翻转至根节点的右儿子，类似这样：

![](https://cdn.luogu.com.cn/upload/pic/18083.png)

emmm 本蒟蒻用英文作图只是因为会使风格更简约 $qwq$。

但在这里还是需要注意，我们为了方便，在 $1$ 号节点之前和 $n$ 号节点之后又加了两个节点并赋值为 $\rm -INF$ 和 $\rm INF$，作为虚点，既满足二叉搜索树的性质，又可以让我们在翻转 $1\sim n$ 时不会 GG。

那么实际上，在我们把当前区间确定下来之后，我们就要开始进行反转操作。而对于反转操作，我们可以不断替换子节点的左右子树达到此目的。

比如对于 $1\sim 5$ 这个序列，我们反转 $2\sim 4$ 这个区间，过程就是这样：

首先建树，在这里用一个可行的树来举个栗子：
![](https://cdn.luogu.com.cn/upload/pic/18097.png)

那么实际上我们如果反转 $2\sim 4$ 那么我们需要先将 $1$ 和 $5$ 旋转上去，类似这样：

![](https://cdn.luogu.com.cn/upload/pic/18102.png)

那么实际上我们翻转两个子树就相当于反转 $2\sim 4$ qwq。

但在这个地方我们可以考虑打个标记，标记的存在就只在于记录现在对于当前节点应不应该翻转两个子树。

$\color{gold}Talk$ $is$ $\color{silver}{cheap}$ $,\color{gold}show$ $you$ $the$ $\color{silver}{code}$ :


```cpp
inline void pushdown(int x){
    if(x&&s[x].tag){
    	s[s[x].son[1]].tag^=1;
    	s[s[x].son[0]].tag^=1;
    	swap(s[x].son[1],s[x].son[0]);
    	s[x].tag=0;
    }	
}
inline int find(int x){
	int now=root;
	while(1)
	{
	    pushdown(now);
		if(x<=s[s[now].son[0]].sub_size){
			now=s[now].son[0];
		}	
		else  {
		x-=s[s[now].son[0] ].sub_size + 1;
	    if(!x)return now;
	    now=s[now].son[1];
		}
	}
}
inline void reverse(int x,int y){
	int l=x-1,r=y+1;
	l=find(l),r=find(r);
	splay(l,0);
	splay(r,l);
	int pos=s[root].son[1];
	pos=s[pos].son[0];
	s[pos].tag^=1;//标记最初打在操作区间的根节点上
}
```
然后还有些需要注意的，注释了 qwq。

还有，$copy$ 别人的 $code$ 可耻 qnq。

```cpp
#include<iostream>
using namespace std;
#define MAXN 1000007
#define INF 100000089
struct Splay_tree{
	int f,sub_size,cnt,value,tag;
	int son[2];
}s[MAXN];
int original[MAXN],root,wz;
inline bool which(int x){
	return x==s[s[x].f].son[1];
}
inline void update(int x){
	if(x){
	s[x].sub_size=s[x].cnt;
	if(s[x].son[0])s[x].sub_size+=s[s[x].son[0]].sub_size;
    if(s[x].son[1])s[x].sub_size+=s[s[x].son[1]].sub_size;
	}
}
inline void pushdown(int x){
    if(x&&s[x].tag){
    	s[s[x].son[1]].tag^=1;
    	s[s[x].son[0]].tag^=1;
    	swap(s[x].son[1],s[x].son[0]);
    	s[x].tag=0;
    }	
}
inline void rotate(int x){
	int fnow=s[x].f,ffnow=s[fnow].f;
	pushdown(x),pushdown(fnow);
	bool w=which(x);
	s[fnow].son[w]=s[x].son[w^1];
	s[s[fnow].son[w]].f=fnow;
	s[fnow].f=x;
	s[x].f=ffnow;
	s[x].son[w^1]=fnow;
	if(ffnow){
		s[ffnow].son[s[ffnow].son[1]==fnow]=x;
	}
	update(fnow);
}
inline void splay(int x,int goal){
	for(int qwq;(qwq=s[x].f)!=goal;rotate(x)){
		if(s[qwq].f!=goal){//这个地方特别重要，原因是需要判断的是当前的父亲有没有到目标节点，而如果把“qwq”改成“x”……就会炸 
			rotate(which(x)==which(qwq)?qwq:x);
		}
	}
	if(goal==0){
		root=x;
	}
}

int build_tree(int l, int r, int fa) {
        if(l > r) { return 0; }
        int mid = (l + r) >> 1;
        int now = ++ wz;
        s[now].f=fa;
	    s[now].son[0]=s[now].son[1]=0;
		s[now].cnt++;
    	s[now].value=original[mid];
		s[now].sub_size++;
        s[now].son[0] = build_tree(l, mid - 1, now);
        s[now].son[1] = build_tree(mid + 1, r, now);
        update(now);
        return now;
}
inline int find(int x){
	int now=root;
	while(1)
	{
	    pushdown(now);
		if(x<=s[s[now].son[0]].sub_size){
			now=s[now].son[0];
		}	
		else  {
		x-=s[s[now].son[0] ].sub_size + 1;
	    if(!x)return now;
	    now=s[now].son[1];
		}
	}
}
inline void reverse(int x,int y){
	int l=x-1,r=y+1;
	l=find(l),r=find(r);
	splay(l,0);
	splay(r,l);
	int pos=s[root].son[1];
	pos=s[pos].son[0];
	s[pos].tag^=1;
}
inline void dfs(int now){
	pushdown(now);
	if(s[now].son[0])dfs(s[now].son[0]);
	if(s[now].value!=-INF&&s[now].value!=INF){
		cout<<s[now].value<<" ";
	}
	if(s[now].son[1])dfs(s[now].son[1]);
}
int main(){
	int n,m,x,y;
	cin>>n>>m;
	original[1]=-INF,original[n+2]=INF;
	for(int i=1;i<=n;i++){
		original[i+1]=i;
	}
	root=build_tree(1,n+2,0);//有一个良好的定义变量习惯很重要……重复定义同一个变量（比如全局的和局部的同名）那么就会发生覆盖。 
	for(int i=1;i<=m;i++){
		cin>>x>>y;
		reverse(x+1,y+1);
	}
	dfs(root);
}
```

---

## 作者：UperFicial (赞：328)

# $\texttt{FHQ-Treap yyds}$

### 前言

这题搞得我吐了![/px](https://cdn.luogu.com.cn/upload/pic/62246.png)

不过第一次写模板题题解还是很开心的呀![/cy](https://cdn.luogu.com.cn/upload/pic/62225.png)

感觉这道题题解质量都不高啊……

这里也会讲清楚此题题解并没有提及的一些重要问题。

看懂本篇题解，你需要了解 $\texttt{FHQ-Treap}$ 的前置芝士。

题目连接：[$\text{Link}$](https://www.luogu.com.cn/problem/P3391)

### 题意简述

给定一个长度为 $n$ 序列，第 $i$ 项初始为 $i$。

支持区间翻转操作，即翻转区间 $[l,r]$。

输出 $m$ 次翻转操作后的序列。

$1\le n,m\le 10^5$。

### 题目解析

这道题我是用的 $\texttt{FHQ-Treap}$，毕竟很好写。

既然都用 $\texttt{FHQ-Treap}$，那么大概率会有的一个想法就是：把 $[l,r]$ 这段区间在这棵平衡树上裂出来，然后再搞。

先别着急怎么裂，假设我们已经裂出来这棵树了，那么，这棵树里每个子节点的权值 $v$ 肯定有 $l\le v\le r$。

假设我们分裂出如下的一棵根节点为 $u$ 的一棵树（图中字母为编号）。

![](https://cdn.luogu.com.cn/upload/image_hosting/1jndp39v.png)

如果不考虑翻转的情况下，这棵树是要按照**中序遍历**来输出，即 $\texttt{c-a-d-u-b}$

但如果翻转了呢？就把中序遍历给翻过来，也就是 $\texttt{b-u-d-a-c}$。

考虑我们到底肝了个什么事。

发现，其实就是把这棵树里，每一个节点的两个左右孩子调换后，得到的新树再进行中序遍历，所以上面的这棵树就变成了下面这个样子：

![](https://cdn.luogu.com.cn/upload/image_hosting/z7b670bt.png)

于是，我们一个初步的思路就是：分裂出对应的树后，从根开始，每一层的每一个节点都将两个儿子调换。

但是考虑我们这样的复杂度是多少，我们要进行分裂出来的树的节点的个数次调换，那么复杂度就是 $\mathcal{O}(r-l+1)$，最坏情况 $\mathcal{O}(n)$，跟朴素暴力一个德行，直接上天。

考虑优化，引入线段树那里的懒标记的思想。

还以这棵树为例，前提这棵树是分裂好的了：

![](https://cdn.luogu.com.cn/upload/image_hosting/1jndp39v.png)

现在想对这棵树进行翻转，我们可以先不翻转，而是记上要翻转的名义，那么在哪记？当然是这棵树的根节点也就是 $u$ 了。这里的标记是需要将原有的懒标记**取反**的，因为假设这同一个区间翻转了两次，就相当于啥都没干，取反两次翻转的名义也就没了。这样既省了时间复杂度，又省了代码复杂度。

现在问题又来了，我们光知道哪个树需要翻转，但是我们并没有真正地更改儿子，输出的时候怎么办。

这也是懒标记的精髓，用它的时候再更新。当我们要进行分裂、合并时，对于目前的节点 $u$，如果它有翻转的名义，也就是被标有懒标记了，那么，它的两个儿子其实就要调换了，而点 $u$ 的懒标记也就随之消失，因为已经它的儿子已经调换了。

而它的两个儿子调换之后，不光它们要调换，它们的后代也都要调换，所以它们也会承接父亲的懒标记，注意，这里的承接是指的取反，也跟上面讲述的同理，是为了节省翻多次的时间，这里不再赘述。

故到此，我们就实现了标记下传：

```cpp
inline void push_down(int u)
{
	tag[u]=false;
	Swap(ch[u][0],ch[u][1]);
	tag[ch[u][0]]^=1;
	tag[ch[u][1]]^=1; 
	return;
}
```
之后还有一个问题：在分裂或合并时什么时候下传标记。

这个问题我想了半天，因为我太 $\texttt{naive}$ 了。因为我们在分裂的时候，对于一个节点 $u$，它的两个儿子就可能会改变，这样一来，假设我们在分裂之后来下传，可能会传到两个假儿子，就导致了 [$\texttt{\color{red}WA}$](https://www.luogu.com.cn/record/51863995)。~~没人发现这个可以点吗~~

所以，只有我们在分裂之前下传，才能传到真儿子中。当然，合并也是同理的。

这样一来，又有一个问题，我们在进行 `push_down` 时，会调换两个儿子，那这样怎么能保证 $\texttt{treap}$ 的性质？

其实，这道题，它跟权值是没有关系的，我们只关心每个子树内节点的顺序如何，我们维护的其实就是翻转后的中序遍历（个人理解）。

所以说我们回到本文开头笔者未解答的问题，怎么分裂出那棵需要翻转的子树？

由于我很 $\texttt{naive}$，一直都是按照权值来分裂，然后一直爆蛋。因为当你下传标记的时候，这个树就已经满足不了**二叉搜索树的性质**了。

~~那咋办，分裂不了啥都玩完了了，洗洗睡吧。~~![/youl](https://cdn.luogu.com.cn/upload/pic/69020.png)

既然我们不能按权值分，我们可以按照子树的大小来分！也就是 $\texttt{FHQ-Treap}$ 另一种经典分裂途径。

这样分裂，简单来说，就是分出权值的效果，但又不需要权值。

然后假设我们有如下的一棵树。

![](https://cdn.luogu.com.cn/upload/image_hosting/h5tjccjf.png)

圈内代表节点编号，红字代表节点的值。

它显然不满足 $\texttt{BST}$ 的性质，因为我们维护的是中序遍历。

那么目前，此序列即为 $\texttt{2-3-5-1-4}$ 这是按照对此树中序遍历得来的。

有一个很显然的性质：对于目前序列一个连续的区间，在这棵树中所对应的节点也是相连的。

那么也很显然，我们只要分裂两次就能分裂出我们先要的区间。

那么分裂就显而易见了，对于翻转 $[l,r]$，我们先把 $[1,l-1]$ 这个区间分裂，也就是大小为 $l-1$ 的子树分裂，然后对于这个 $[l,n]$ 的这个树，我们分裂出大小 $r-l+1$ 的一棵树。这个只要你知道啥是按大小分裂都能想清楚吧。

之后就是输出了，当然就是按照中序遍历输出，但还有一个问题，有些节点可能标记没下传下去，遍历的时候也要下传。

呼，讲完了，此生最长的一片题解了![/cy](https://cdn.luogu.com.cn/upload/pic/62225.png)

[$code$](https://paste.ubuntu.com/p/bwpzbrf6HG/)

时间复杂度：$\mathcal{O}(n\log n)$，树的深度约为 $\log n$。

空间复杂度：$\mathcal{O}(n)$。

求赞![/kel](https://cdn.luogu.com.cn/upload/pic/62226.png)

$$\texttt{The End.by UF}$$




---

## 作者：Margatroid (赞：75)

看了一圈发现大家都是用的很清真的splay，这里介绍一种用STL强行混分的做法

`rope`是STL内置的一颗平衡树，详细的文档可以见[这里](https://www.sgi.com/tech/stl/Rope.html)~~虽然是洋文版的~~

`rope`一般用来维护字符串，当然，对于这个题，我们让它维护序列

`rope`相比与`string`，可以实现高效的分裂和合并，我们可以利用这个性质来进行一波操作

但是。。它封装的这么严，怎么打标记呢？

其实是不用打标记的

我们维护一正一反两个`rope`，翻转操作就是交换它们的对应区间

然后就没有了。。缺点是常数很大。。。

下面是代码qwq


``` cpp
//
// Created by margatroid on 17-9-17.
//

#include<bits/stdc++.h>
#include<ext/rope>
using namespace std;
using namespace __gnu_cxx;
inline char getc()
{
    static char buf[1 << 18], *fs, *ft;
    return (fs == ft && (ft = (fs = buf) + fread(buf, 1, 1 << 18, stdin)), fs == ft) ? EOF : *fs++;
}
inline int gn()
{
    register int k = 0, f = 1;
    register char c = getc();
    for(; !isdigit(c); c = getc()) if(c == '-') f = -1;
    for(; isdigit(c); c = getc()) k = k * 10 + c - '0';
    return k * f;
}
rope<int> str, rstr;
int n, m;
inline void rev(int st, int ed)
{
    if (st >= ed + 1) return;
    ed++;
    rope<int> tmp = str.substr(st + str.begin(), ed + str.begin());
    str = str.substr(0 + str.begin(), st + str.begin()) + rstr.substr(n - ed + rstr.begin(), n - st + rstr.begin()) + str.substr(ed + str.begin(), str.length() + str.begin());
    rstr = rstr.substr(rstr.begin(), n - ed + rstr.begin()) + tmp + rstr.substr(n - st + rstr.begin(), rstr.length() + rstr.begin());
}
int main()
{
    n = gn(), m = gn();
    for (int i = 1; i <= n; ++i)
        str.append(i), rstr.append(n - i + 1);
    for (int i = 1; i <= m; ++i)
    {
        int l, r;
        l = gn(), r = gn();
        rev(l - 1, r - 1);
    }
    for (int i = 0; i < str.length(); ++i)
        printf("%d ", str[i]);
    puts("");
}
```

---

## 作者：违规用户名76G!ihcm (赞：67)

## 大家好，我非常喜欢暴力数据结构，于是我就用分块过了这道题。

## 而且比大多数平衡树跑得快。

这个题对序列分块肯定是不可取的。

块状链表又难写又慢。

所以考虑对时间分块，根号重构。（虽然块状链表好像类似，但是我的做法好写得多）

考虑原序列经过几次翻转之后得到的序列，**是由原序列的一些子区间，正序或者逆序拼成的**，比如:

原序列：$[1,2,3,4,5,6,7,8,9,10,11,12]$

翻转 $[5,11]$：$[1,2,3,4,11,10,9,8,7,6,5,12]$

翻转 $[1,7]$：$[9,10,11,4,3,2,1,8,7,6,5,12]$

在原序列上的子区间是 $[9,10,11]$，$[4,3,2,1]$，$[8,7,6,5]$，$[12]$。

而且有一个非常好的性质就是**每次操作最多增加常数个子区间**。

因为对于上个状态的某个子区间，如果它和这次翻转的区间没有交，那么它不会动。

如果它被这次翻转的区间包含，那么它会被翻转，并且换个位置，数量不会增加。

如果它与这次翻转的相交，那么它会最多裂开成 $3$ 个区间（即它包含翻转的区间的情况，别的情况都会裂开成两个），其中有一个区间被翻转，换位置，剩下的区间不动。

一个区间最多与 $2$ 个不相交的区间相交且没有包含关系，所以每次最多增加两个区间。

回到这个题上，考虑维护每个子区间，而不是原序列。

每次修改暴力枚举所有子区间，看一下它们会变成什么，这个的复杂度是 $O(\text{区间个数})$ 的。

但是每次操作后都有可能增加几个子区间，到后面每次操作就趋近 $O(n)$ 了，所以考虑**根号重构**。

也就是说，一旦当前区间个数超过了某个阈值 $B$，就 $O(n)$ 求一下当前的序列，这样现在这个序列就又能用 $1$ 个区间表示啦。

比如：

$[1,2,3,4,5,6,7,8,9,10,11,12]$

翻转 $[4,10]$

$[1,2,3],[10,9,8,7,6,5,4],[11,12]$

翻转 $[7,10]$

$[1,2,3],[10,9,8],[4,5,6,7],[11,12]$

翻转 $[2,11]$

$[1],[11],[7,6,5,4],[8,9,10],[3,2],[12]$

这时候觉得区间有点多，重构一下。

$[1,11,7,6,5,4,8,9,10,3,2,12]$

注意这个时候原序列已经没关系了，只用把当前序列表示成**上一次重构时的一些子区间，正序或逆序拼成的。**

翻转 $[3,7]$

$[1,11],[8,4,5,6,7],[9,10,3,2,12]$


翻转 $[7,8]$

$[1,11],[8,4,5,6],[9],[7],[10,3,2,12]$

这个做法的时间复杂度是 $O(mB+\frac{m}{B}n)$ 的（因为每次操作要遍历 $O(B)$ 个区间，每 $B$ 个询问要 $O(n)$ 求一边当前序列）

取 $B=\sqrt{n}$ 时，时间复杂度达到 $O(m\sqrt n)$，而且常数非常小，实测 $B\in [200,800]$ 的时候跑的速度都差不多。

具体实现的时候需要记一下每个子区间在当前序列的位置，以及它们在上一次重构时的位置，还有是否被取反。

分裂子区间的时候就直接加到后面。

重构的时候直接把所有区间都删了，换成 $[1,n]$。

### 代码（还挺好写的）：

```cpp
#include <iostream>
using namespace std;
const int bl=400;//阈值大小
int a[100005],b[100005],cnt,n,q;//cnt表示子区间个数
struct node{//子区间
	int l1,l2,r2,f;//l1是原序列上左端点的位置，
	//l2,r2是现序列上的位置，f是是否翻转，由于r1-l1一定=r2-l2，所以r1就不记了
}s[405];
inline void rev(int l,int r){//翻转区间 [l,r]
	for(int i=1;i<=cnt;i++){//遍历所有子区间
		if(s[i].r2<l||s[i].l2>r) continue;//没有交直接跳过
		if(l>s[i].l2){//右边相交，要分裂
			if(!s[i].f) s[++cnt]={l-s[i].l2+s[i].l1,l,s[i].r2,0},s[i]={s[i].l1,s[i].l2,l-1,0};
			else s[++cnt]={s[i].l1,l,s[i].r2,1},s[i]={s[i].l1+s[i].r2-l+1,s[i].l2,l-1,1};
			//计算分裂完的两个区间的信息
		}
		if(r<s[i].r2){//左边相交，同理，代码上只是把l换成了r+1
			if(!s[i].f) s[++cnt]={r+1-s[i].l2+s[i].l1,r+1,s[i].r2,0},s[i]={s[i].l1,s[i].l2,r+1-1,0};
			else s[++cnt]={s[i].l1,r+1,s[i].r2,1},s[i]={s[i].l1+s[i].r2-r,s[i].l2,r,1};
		}
		if(s[i].r2<l||s[i].l2>r) continue;//分裂完不相交
		s[i].l2=r-s[i].l2+l,s[i].r2=r-s[i].r2+l,swap(s[i].l2,s[i].r2),s[i].f^=1;
		//计算翻转后区间的信息
	}
}
inline void qwq(){//重构
	for(int i=1;i<=cnt;i++){//把每个区间的值暴力赋过去
		if(s[i].f) for(int j=s[i].r2;j>=s[i].l2;j--) b[j]=a[s[i].l1++];
		else for(int j=s[i].l2;j<=s[i].r2;j++) b[j]=a[s[i].l1++];
	}
	cnt=1,s[cnt]={1,1,n,0},swap(a,b);//删掉原来所有区间
}
int main(int argc, char** argv) {
	scanf("%d%d",&n,&q);
	for(int i=1;i<=n;i++) a[i]=i;
	s[++cnt]={1,1,n,0};//一开始只有整个一个区间
	while(q--){
    	int l,r;
		scanf("%d%d",&l,&r),rev(l,r);
		if(cnt>bl) qwq();//如果区间数大于阈值，就重构
	}
	qwq();//算最终的答案，相当于一次重构
	for(int i=1;i<=n;i++) printf("%d ",a[i]);
	return 0;
}
```

有评论的话我可能半年之内回不了，因为被禁言了/cy

有什么 bug 或者假了或者被踩了私信联系我

求过审

---

## 作者：vectorwyx (赞：31)

普通平衡树实现的各种操作都是基于大小关系，回想一下，它之所以能实现那么多操作，最本质的原因是它巧妙地依据元素的大小关系建树，小的元素放在左子树，大的元素放在右子树，这样中序遍历的结果就恰恰是一个递增序列。而这题要实现的变成了对给定序列的若干个区间进行翻转操作，而翻转操作实际上改变的是**前后关系**。这就启发我们对普通平衡树做一些修改，改为**依靠元素的前后关系建树，靠前的元素在左子树，靠后的元素在右子树**，然后在进行区间翻转时维护这一性质，那么最后得到的中序遍历就是整个序列经过若干次区间翻转操作后的结果。

这样做的难点就在于如何在进行区间翻转时维护整棵树的性质不变。我们先从最特殊的情况想起，如果说整棵树的高度为 $2$，比如只有 $3$ 个结点：根、左儿子、右儿子，那么翻转整个区间显然相当于把根结点的左儿子和右儿子互换。如果高度大于 $2$，我们只需要**自上而下地把每一个结点的左右子树互换**。证明如下：

设整棵树的深度为 $n$，已知当 $n=2$ 时结论成立，求证：假设 $n=k-1$ 时结论成立，则 $n=k$ 时结论也成立。设该树的高度为 $k$，根结点为 $b$，左子树的中序遍历序列为 $A$，右子树的中序遍历序列为 $C$，那么互换前的中序遍历就是 $AbC$，互换后是 $C'bA'$，由于 $n=k-1$ 时结论成立，因此 $C'$ 是 $C$ 翻转的结果，$B'$ 是 $B$ 翻转的结果，故 $C'bA'$ 是 $AbC$ 翻转的结果，结论得证。

因此对整个序列做翻转就相当于自上而下地把树上的每一个结点的左右子树互换。但如果是对区间 $[l,r]$ 做翻转呢？我们该如何使这段区间恰好对应着一棵完整的子树？这里 Splay 就派上用场了，我们只需要**将序列里的第 $l-1$ 个元素旋转到根结点，把第 $r+1$ 个元素旋转到根结点的右儿子处**，由于我们是按照前后关系建树的，并且 $[l,r]$ 这段区间的元素都在 $a_{l-1}$ 的后面、$a_{r+1}$ 的前面，所以在旋转结束后**根结点的右儿子的左子树就恰好对应着 $[l,r]$ 这段区间**，这就是所谓的 Splay 提取区间（事实上普通平衡树的删除操作就是提取区间的一个特殊情况）。那翻转区间 $[l,r]$ 就相当于对这棵子树自上而下地进行互换操作。

至于如何找到第 $l-1$ 和第 $r+1$ 个元素，这相当于查找第 $k$ 前的元素，也就是说在中序遍历上排第 $k$ 的元素，直接套用 splay 的查找第 $k$ 小的函数即可 。还有一点要注意，就是当 $l=1$ 或 $r=n$ 时第 $l-1$ 或第 $r+1$ 个元素会不存在，为了防爆，我们需要事先把正无穷和负无穷插入树中。

不过，如果你每次都把要进行互换操作的子树直接从头到尾互换一遍，那时间复杂度会爆炸。这里我们要借鉴一下线段树的 lazy tag 思想，给每个结点打一个懒标记表示以它为根的子树被互换了多少次。如果我用不到它的子结点，那它的懒标记就在那放着，等到我用到它的子结点时再把标记下放。同时，由于对一颗子树互换两次等于不互换，因此懒标记只需要记录 $0/1$ 值。

代码如下（点个赞再走吧QAQ，谢谢您！）：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#define ll long long
#define fo(i,x,y) for(register int i=x;i<=y;++i)
#define go(i,x,y) for(register int i=x;i>=y;--i)
using namespace std;
inline int read(){ int x=0,fh=1; char ch=getchar(); while(!isdigit(ch)){ if(ch=='-') fh=-1; ch=getchar(); } while(isdigit(ch)){ x=(x<<1)+(x<<3)+ch-'0'; ch=getchar(); } return x*fh; }

const int N=1e5+5,inf=1e9;
int data[N],ch[N][2],fa[N],siz[N],root,tag[N],tot,a[N],cnt[N];

inline int son(int &x){return x==ch[fa[x]][1];}
inline void push_up(int &x){siz[x]=siz[ch[x][0]]+siz[ch[x][1]]+cnt[x];}

inline void push_down(int x){//把x的懒标记下放到它的两个儿子 
	if(tag[x]==0) return;
	int lt=ch[x][0],rt=ch[x][1];
	tag[lt]^=tag[x];
	swap(ch[lt][0],ch[lt][1]);
	tag[rt]^=tag[x];
	swap(ch[rt][0],ch[rt][1]);
	tag[x]=0;
}

inline void rotate(int x){//rotate函数 
	int y=fa[x],z=fa[y],sx=son(x),sy=son(y),b=ch[x][!sx];
	push_down(y);push_down(x);
	//注意，rotate函数会改变以y为根和以x为根的子树的结构，因此要在旋转之前先把它们的懒标记下放
	//其余的与splay模板一致 
	if(z) ch[z][sy]=x; else root=x;fa[x]=z;
	ch[x][!sx]=y;fa[y]=x;
	ch[y][sx]=b;if(b) fa[b]=y;
	push_up(y);push_up(x);
}

inline void splay(int x,int aim){//splay函数，与模板无异 
	while(fa[x]!=aim){
		int y=fa[x],z=fa[y];
		if(z==aim) rotate(x);
		else if(son(x)^son(y)) rotate(x),rotate(x);
		else rotate(y),rotate(x);
	}
}

inline int get_kth(int k){//查找第k前的函数，与模板无异 
	k--;
	int now=root;
	while(now){
		if(siz[ch[now][0]]>k) push_down(now),now=ch[now][0];
		else if(siz[ch[now][0]]+cnt[now]>k) return now;
		else k-=siz[ch[now][0]]+cnt[now],push_down(now),now=ch[now][1];
	}
}

inline void reverse(int L,int R){//翻转[L,R]这段区间 
	int p1=get_kth(L),p2=get_kth(R+2);
	//printf("reverse(%d,%d)\n",L,R);
	//printf("p1=%d p2=%d\n",p1,p2);
	splay(p1,0);splay(p2,root);//splay提取区间 
	int p3=ch[p2][0];
	tag[p3]^=1;//打标记 
	swap(ch[p3][0],ch[p3][1]);
}

int build(int L,int R){//根据初始的序列建树 
	if(L>R) return 0;
	//printf("build(%d,%d)\n",L,R);
	int mid=(L+R)>>1,now=a[mid];
	if(now==-inf||now==inf) now=++tot;
	data[now]=a[mid];
	cnt[now]=siz[now]=1;
	if(L==R) return now;
	int lt=build(L,mid-1);
	ch[now][0]=lt;fa[lt]=now;
	int rt=build(mid+1,R);
	ch[now][1]=rt;fa[rt]=now;
	push_up(now);
	return now;
}

void get_ans(int now){//输出中序遍历 
	push_down(now);
	if(ch[now][0]) get_ans(ch[now][0]);
	if(data[now]!=-inf&&data[now]!=inf) printf("%d ",data[now]);
	if(ch[now][1]) get_ans(ch[now][1]);
}

int main(){
	int n=read(),m=read();
	a[1]=-inf;a[n+2]=inf;//为了防爆，提取将负无穷和正无穷插入树中 
	fo(i,2,n+1) a[i]=i-1;
	tot=n;
	root=build(1,n+2);
	fo(i,1,m){
		//printf("root=%d\n",root);
		//fo(j,1,tot) printf("%d:data=%d,fa=%d,ch0=%d,ch1=%d,siz=%d,tag=%d\n",j,data[j],fa[j],ch[j][0],ch[j][1],siz[j],tag[j]);
		int l=read(),r=read();
		reverse(l,r);
	} 
	//printf("root=%d\n",root);
	//fo(j,1,tot) printf("%d:data=%d,fa=%d,ch0=%d,ch1=%d,siz=%d,tag=%d\n",j,data[j],fa[j],ch[j][0],ch[j][1],siz[j],tag[j]);
	get_ans(root);
	return 0;
}
/*
-------------------------------------------------
*/
```

---

## 作者：Tiffake (赞：12)

### 题目描述
给你 $n$ 个数，有 $m$ 次区间翻转操作，最后输出这 $n$ 个数。

$1\le n,m\le10^5$。
### 思路
既然是区间操作，线段树（`WBLT`）凭什么不能维护？

考虑一下区间翻转的对于一堆小区间的影响。可以发现其实质就是将这堆小区间先对调所有的位置顺序，然后再对每个小区间内部翻转。  
在线段树上的操作如下图所示：
![](https://cdn.luogu.com.cn/upload/image_hosting/taep7zan.png)
而对小区间内部翻转，不就相当于不断交换这个区间左区间和右区间吗？这个操作可以简单地打上懒标记维护。

但是该如何实现这样对调一堆区间的操作呢？可以先跑一遍查找组成翻转区间的一堆小区间，然后用栈把他们存下来。接着再跑一遍，把对应的区间改为栈顶的区间，同时打上懒标记即可。由线段树的性质可知，这些小区间的数量是 $O(\log n)$ 的。

不过相信大家也看到了，这样操作会改变线段树的形态，多翻转几次树高就变成 $O(n)$ 了。因此需要采用根据子树大小平衡的 `WBLT` 实现。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+1;
struct node{
	int ls,rs,l,r,sz,v;
	bool lz,rv;//lz是子区间翻转的懒标记，rv是判断区间是否需要对调的标记
	node(){ls=rs=l=r=sz=0;}
}s[N<<2];
int tot,n,m,a[N],tmp[64],top;//tmp维护的是组成询问区间的一堆小区间
inline void crtup(int k,int ls,int rs){//由底向上更正下标
	s[rs].l=s[ls].r+1,s[k].r=s[rs].r=s[ls].r+s[rs].sz,s[k].l=s[ls].l;
	s[k].sz=s[ls].sz+s[rs].sz;
}
inline void crtdown(int k,int ls,int rs){//由顶向下更正下标
	if(!s[ls].sz&&!s[rs].sz)return;
	s[ls].l=s[k].l,s[ls].r=s[k].l+s[ls].sz-1;
	s[rs].l=s[ls].r+1,s[rs].r=s[k].r;
}
inline void revnode(int&k){//对调某个小区间
	return s[k].rv=0,k=tmp[top--],void();
}
inline void merge(int k,int x,int y){
	s[k].l=s[x].l,s[k].r=s[y].r,s[k].sz=s[x].sz+s[y].sz;
	s[k].ls=x,s[k].rs=y;
}
inline void pushdown(int k){
	if(s[k].lz&&s[k].ls&&s[k].rs)swap(s[k].ls,s[k].rs),s[s[k].ls].lz^=1,s[s[k].rs].lz^=1,s[k].lz=0;
	//下传懒标记时需要注意判断是否有儿子
	crtdown(k,s[k].ls,s[k].rs);
}
inline void equil(int k){//WBLT的平衡操作
	int ls=s[k].ls,rs=s[k].rs,x;
	if(min(s[ls].sz,s[rs].sz)*3>max(s[ls].sz,s[rs].sz))return;
	pushdown(ls),pushdown(rs);
	if(s[ls].sz>s[rs].sz)
		if(s[s[ls].ls].sz>=s[s[ls].rs].sz)s[k].ls=s[ls].ls,merge(ls,s[ls].rs,rs),s[k].rs=ls;
		else pushdown(x=s[ls].rs),merge(ls,s[ls].ls,s[x].ls),merge(x,s[x].rs,rs),s[k].rs=x;
	else
		if(s[s[rs].ls].sz<=s[s[rs].rs].sz)s[k].rs=s[rs].rs,merge(rs,ls,s[rs].ls),s[k].ls=rs;
		else pushdown(x=s[rs].ls),merge(rs,s[x].rs,s[rs].rs),merge(x,ls,s[x].ls),s[k].ls=x;
}
#define ls s[k].ls
#define rs s[k].rs
void build(int k,int l,int r){
	s[k].l=l,s[k].r=r;
	if(l==r)return s[k].v=l,s[k].sz=1,void();
	ls=k<<1,rs=k<<1|1,build(ls,l,(l+r)>>1),build(rs,((l+r)>>1)+1,r);
	crtup(k,ls,rs);
}
#define mid s[ls].r
void find(int k,int x,int y){
	if(x<=s[k].l&&s[k].r<=y)return tmp[++top]=k,void();
	pushdown(k);
	if(x<=mid)find(ls,x,y);
	if(y>mid)find(rs,x,y);
}
#undef mid
void rev(int k,int x,int y){
	if(x<=s[k].l&&s[k].r<=y)return s[k].rv=1,s[k].lz^=1,void();
	pushdown(k);
	int mid=s[ls].r;
	if(x<=mid)rev(ls,x,y);//注意及时更新
	if(s[ls].rv)revnode(ls);
	if(y>mid)rev(rs,x,y);
	if(s[rs].rv)revnode(rs);
	crtup(k,ls,rs);
}
void eql(int k,int x,int y){//平衡操作
	if(x<=s[k].l&&s[k].r<=y)return;
	pushdown(k);
	int mid=s[ls].r;
	if(x<=mid)eql(ls,x,y);
	if(y>mid)eql(rs,x,y);
	equil(k);
}
void ask(int k){
	if(s[k].l==s[k].r)return cout<<s[k].v<<' ',void();
	pushdown(k);
	ask(ls),ask(rs);
}
int x,y;
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>m,build(1,1,n),tot=n<<2;
	while(m--){
		cin>>x>>y,x+=s[1].l-1,y+=s[1].l-1;//更正下标
		find(1,x,y),rev(1,x,y),eql(1,x,y);
	}
	ask(1);//输出
	return 0;
}
```

---

## 作者：在想Peach (赞：12)

## 此解法为一种基于复杂度平衡思想的链表信息维护算法

### 关于此类问题的另一种同复杂度算法：块状链表 在此不做阐述。

### [文艺平衡树](https://www.luogu.com.cn/problem/P3391)

可以发现假使此序列为一个链表,第一个c点表示为观察点，r点为另一个观察点，d点为第一个序列点，如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/00b4nlis.png)

假使进行一段区间的反转，如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/lptgd5qd.png)

可以将相关两条链删除，如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/ez9h7tnb.png)

连上新链，如图所示:

![](https://cdn.luogu.com.cn/upload/image_hosting/mw83s7a3.png)

显然，由于观察点的位置必定不变，自观察点开始向后遍历输出即为答案。

那么对于每次修改，寻找到区间两头的确切点就是必要的。

显然每次从观察点依次向后跳的复杂度为O（n），那么如何快速找到某位置的点就是解决问题的关键。

假若进行倍增的跳跃方式，那么每次寻找的复杂度是O（logn）的，但进行修改后的更新复杂度却是O（nlogn）的，显然无法使用。

此时假若每个点不再存储logn个向后跳的边（即倍增数组），改为只存储第一个相邻的点和距离自己k（常数）距离的点，以观察点为例，且此时k=3，如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/g63wm69j.png)

此时寻找操作只需先每次跳到距离自己为k的点，直到距离不超过k时再依次向后跳，此时复杂度为O(max(n/k,k))。

关于修改，假若对如下区间反转，如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/w7gssi9d.png)

那么涉及到相邻点的边只有两个修改，而关于长度为k的边（此时k=3）对于反转区间内需要修改的点仅为如图横线下所示6（min(2*k,r-l+1)）个点，易证区间外需要修改的点数也不超过2*k个。

因为相距修改区间距离超过k的点必定不会被涉及，所以可知修改复杂度为O(k)。

此时发现两种操作呈乘积相关，根据复杂度平衡可知k取sqrt(n)时理论复杂度最低，总体为O(n*sqrt(n))。

最后自观察点向后遍历输出即为本题最终答案。

本代码由于常数问题无法通过本题

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,nxt[100007][2],f[100007][2];
inline void init(){
	memset(nxt,-1,sizeof(nxt));memset(f,-1,sizeof(f));
	nxt[0][1]=1;f[0][1]=k;
	for(int i=1;i<=n;i++){
		nxt[i][0]=i-1;nxt[i][1]=i+1;
		if(i-k>=0)f[i][0]=i-k;if(i+k<=n)f[i][1]=i+k;
		}
	nxt[n+1][0]=n;f[n+1][0]=n-k;
}
inline void go_slow(int &x,bool &to){int u=nxt[x][to];to^=(nxt[u][to^1]!=x);x=u;}
inline void go_fast(int &x,bool &to){int u=f[x][to];to^=(f[u][to^1]!=x);x=u;}
inline int find(int x,bool &to){
	if(x>n||x<0)return -1;
	int now=0;to=1;register int i;
	for(i=1;i<=x/k;i++)go_fast(now,to);
	for(i=1;i<=x%k;i++)go_slow(now,to);
	return now;
}
inline void update(int x,bool tox,int y,bool toy,int len){
	for(int i=1;i<=min(k,len);i++){
		int g=x;bool tt=tox^1;
		go_fast(g,tt);f[g][tt^1]=y;
		g=y;tt=toy^1;
		go_fast(g,tt);f[g][tt^1]=x;
		swap(f[x][tox^1],f[y][toy^1]);
		go_slow(x,tox);go_slow(y,toy);
	}
}
signed main(){
	scanf("%d%d",&n,&m);k=sqrt(n);init();
	int x,y,len,g;bool tox,toy,tt;
	while(m--){tox=1;toy=1;
		scanf("%d%d",&x,&y);len=y-x+1;
		x=find(x,tox);y=find(y,toy);
		update(x,tox,y,toy^1,len);
		g=x;tt=tox^1;
		go_slow(g,tt);nxt[g][tt^1]=y;
		g=y;tt=toy;
		go_slow(g,tt);nxt[g][tt^1]=x;
		swap(nxt[x][tox^1],nxt[y][toy]);
		}
	int now=0;bool tonow=1;
	for(int i=1;i<=n;++i)go_slow(now,tonow),printf("%d ",now);
	return 0;
}
```



---

## 作者：Great_Influence (赞：10)

因为$leafytree$支持区间分裂与合并，因此所有$FHQ$能做的题$leafytree$也能做。

至于这道题，肯定是直接提取区间，然后打上反转标记后合并即可。

那么问题在于$merge$和$split$的写法。

$merge$的写法看似复杂，其实十分简单。可以按照$leafytree$的$maintain$的写法魔改$FHQ$的$merge$。这里我们分以下几种情况分类讨论。

1. $\min\{sz[u],sz[v]\}\ge \frac{\alpha}{1-\alpha}\max\{sz[u],sz[v]\}$:
这种情况我们发现直接新建一个节点，然后将$u$和$v$接在下面，整棵树仍然平衡。

接下来的$2$种情况默认$sz[u]\ge sz[v]$，$sz[u]<sz[v]$的对称写一下即可。

2.$sz[lson[u]]\ge \alpha(sz[u]+sz[v])$:

我们发现，如果将$rson[u]$和$v$合并，这棵树和左边的$lson[u]$两棵树满足第一种情况。

3.其他情况:

这时候我们将$rson[u]$拆开形成左右两棵子树，然后我们分别将这两棵子树和$lson[u]$以及$v$分别合并，然后再做判断。可以知道，这样进行一次操作后，左右两棵树的相对大小差会减小(至于多少就有点难算)。

经过某种神秘的证明，可以得到它的时间复杂度为稳定$\log(\frac{\max\{sz[u],sz[v]\}}{\min\{sz[u],sz[v]\}})$的。这个复杂度证明非常奇妙，因此论文内并没有证明。

$split$与$FHQ$的一模一样。复杂度为$O(sz[u])$。

这是一个稳定复杂度的算法，在树很平衡的情况下速度极快。

代码:

```cpp
#include<bits/stdc++.h>
#define Rep(i,a,b) for(register int i=(a);i<=(b);++i)
#define Repe(i,a,b) for(register int i=(a);i>=(b);--i)
#define pb push_back
#define mp make_pair
#define eb emplace_back
#define ef emplace_front
#define ob pop_back
#define of pop_front
#define Chkmax(a,b) a=a>b?a:b
#define Chkmin(a,b) a=a<b?a:b
typedef unsigned long long uint64;
typedef unsigned int uint32;
typedef long long ll;

using namespace std;

namespace IO
{
    const uint32 Buffsize=1<<15,Output=1<<23;
    static char Ch[Buffsize],*S=Ch,*T=Ch;
    inline char getc()
    {
        return((S==T)&&(T=(S=Ch)+fread(Ch,1,Buffsize,stdin),S==T)?0:*S++);
    }
    static char Out[Output],*nowps=Out;
    
    inline void flush(){fwrite(Out,1,nowps-Out,stdout);nowps=Out;}

    template<typename T>inline void read(T&x)
    {
        x=0;static char ch;T f=1;
        for(ch=getc();!isdigit(ch);ch=getc())if(ch=='-')f=-1;
        for(;isdigit(ch);ch=getc())x=x*10+(ch^48);
        x*=f;
    }

    template<typename T>inline void write(T x,char ch='\n')
    {
        if(!x)*nowps++='0';
        if(x<0)*nowps++='-',x=-x;
        static uint32 sta[111],tp;
        for(tp=0;x;x/=10)sta[++tp]=x%10;
        for(;tp;*nowps++=sta[tp--]^48);
        *nowps++=ch;
    }
}
using namespace IO;

inline void file()
{
#ifndef ONLINE_JUDGE
    FILE*DSA=freopen("water.in","r",stdin);
    FILE*SDU=freopen("water.out","w",stdout);
#endif
}

const int MAXN=1e5+7;

static int n,m;

void init(){read(n),read(m);}

namespace leafy_tree
{
	const double alp=1-sqrt(2)/2,lim=(1-2*alp)/(1-alp),spl=alp/(1-alp);
	const int NODE=2e5+7;
	static int sz[NODE],nm[NODE],son[NODE][2],rt,e,rev[NODE],sta[NODE],fa[NODE];

	void refresh(int h){if(son[h][1]){sz[h]=sz[son[h][0]]+sz[son[h][1]];}}

	void make_tree(int&h,int l,int r)
	{
		h=++e;
		if(l==r){sz[h]=1,nm[h]=l;return;}
		int mid=(l+r)>>1;
		make_tree(son[h][0],l,mid);
		make_tree(son[h][1],mid+1,r);
		refresh(h);
	}

	void pushdown(int h)
	{
		if(son[h][0]&&rev[h])
		{
			swap(son[h][0],son[h][1]);
			rev[son[h][0]]^=1,rev[son[h][1]]^=1;
			rev[h]=0;
		}
	}

	inline int newnode(){return sta[e--];}

	inline void del(int u)
	{
		fa[son[u][0]]=fa[son[u][1]]=0;
		nm[u]=fa[u]=son[u][0]=son[u][1]=rev[u]=sz[u]=0;
		sta[++e]=u;
	}

	int merge(int u,int v)
	{
		if(!u||!v)return u|v;
		pushdown(u),pushdown(v);
		
		if(sz[u]>=sz[v]&&sz[v]>=sz[u]*spl||sz[v]>=sz[u]&&sz[u]>=sz[v]*spl)
		{
			register int cur=newnode();
			son[cur][0]=u,son[cur][1]=v;
			refresh(cur);
			return cur;
		}
		if(sz[u]>=sz[v])
		{
			pushdown(u);
			register int ls=son[u][0],rs=son[u][1];
			del(u);
			if(sz[ls]>=alp*(sz[ls]+sz[rs]+sz[v]))
				return merge(ls,merge(rs,v));
			else
			{
				pushdown(rs);
				register int lls=son[rs][0],rrs=son[rs][1];
				del(rs);
				return merge(merge(ls,lls),merge(rrs,v));
			}
		}
		else
		{
			pushdown(v);
			register int ls=son[v][0],rs=son[v][1];
			del(v);
			if(sz[rs]>=alp*(sz[u]+sz[ls]+sz[rs]))
				return merge(merge(u,ls),rs);
			else
			{
				pushdown(ls);
				register int lls=son[ls][0],rrs=son[ls][1];
				del(ls);
				return merge(merge(u,lls),merge(rrs,rs));
			}
		}
	}

	typedef pair<int,int>PII;

	PII split(int h,int x)
	{
		if(!x)return mp(0,h);
		if(!son[h][0])return mp(h,0);
		register PII y;
		pushdown(h);
		int ls=son[h][0],rs=son[h][1];
		del(h);
		if(sz[ls]>=x)
		{
			y=split(ls,x);
			return mp(y.first,merge(y.second,rs));
		}
		else
		{
			y=split(rs,x-sz[ls]);
			return mp(merge(ls,y.first),y.second);
		}
	}

	void dfout(int u)
	{
		pushdown(u);
		if(son[u][0])dfout(son[u][0]),dfout(son[u][1]);
		else write(nm[u],' ');
	}

	inline void reverse(int l,int r)
	{
		register PII y,z;
		y=split(rt,l-1);
		z=split(y.second,r-l+1);
		rev[z.first]^=1;
		rt=merge(y.first,merge(z.first,z.second));
	}
}
using namespace leafy_tree;

inline void solve()
{
	make_tree(rt,1,n),e=0;
	static int l,r;
	Rep(i,1,m)
	{
		read(l),read(r);
		reverse(l,r);
	}
	dfout(rt);
	flush();
}

int main()
{
	file();
    init();
    solve();
    return 0;
}
```

---

## 作者：dblark (赞：4)

这道题连Pascal题解一篇都没有……

所以让我来发一篇吧。/滑稽

由于我太弱了，只能写正解splay。。。

具体的原理，百度一下，那些C++大佬已经讲的很清楚了。

这里奉上调了好几天的代码：

```pas
//Splay Tree
var
  a,s,l,r,f:array[0..100002]of longint;//a是原值，s是子树的节点数，l和r表示左儿子和右儿子，f表示父亲
  o:array[0..100002]of boolean;//标记
  n,m,i,x,y,root:longint;
procedure pushup(x:longint);
begin
  s[x]:=s[l[x]]+s[r[x]]+1;
end;
procedure pushdown(x:longint); //标记下传
var
  t:longint;
begin
  if o[x] then
  begin
    o[l[x]]:=not o[l[x]];
    o[r[x]]:=not o[r[x]];
    t:=l[x];
    l[x]:=r[x];
    r[x]:=t;
    o[x]:=false;
  end;
end;
procedure rotate(x:longint);   //旋转
var
  y,z:longint;
begin
  y:=f[x];
  z:=f[y];
  if l[z]=y then
    l[z]:=x
  else
    r[z]:=x;
  f[x]:=z;
  if l[y]=x then
  begin
    l[y]:=r[x];
    f[r[x]]:=y;
    r[x]:=y;
  end
  else
  begin
    r[y]:=l[x];
    f[l[x]]:=y;
    l[x]:=y;
  end;
  f[y]:=x;
  pushup(x);
  pushup(y);
end;
procedure splay(x,t:longint);  //伸展
begin
  while f[x]<>t do
  begin
    if f[f[x]]<>t then
      if (l[f[x]]=x) xor (l[f[f[x]]]=f[x]) then
        rotate(x)
      else
        rotate(f[x]);
    rotate(x);
  end;
  if t=0 then
    root:=x;
end;
procedure insert(x,k,n:longint);//插入节点，n表示第几个节点
var
  t:longint;
begin
  t:=0;
  while x>0 do
  begin
    t:=x;
    if k<a[x] then
      x:=l[x]
    else
      x:=r[x];
  end;
  if t>0 then
    if k<a[t] then
      l[t]:=k
    else
      r[t]:=k;
  a[n]:=k;
  l[n]:=0;
  r[n]:=0;
  s[n]:=1;
  f[n]:=t;
  o[n]:=false;
  splay(n,0);
end;
function kth(k:longint):longint;//查询第k小
var
  x:longint;
begin
  x:=root;
  while true do
  begin
    pushdown(x);
    if s[l[x]]+1=k then
      exit(x);
    if s[l[x]]>=k then
      x:=l[x]
    else
    begin
      dec(k,s[l[x]]+1);
      x:=r[x];
    end;
  end;
end;
procedure reverse(x,y:longint);//翻转
begin
  x:=kth(x);
  y:=kth(y+2);
  splay(x,0);
  splay(y,x);
  o[l[r[x]]]:=not o[l[r[x]]];
end;
begin
  read(n,m);
  root:=0;
  for i:=1 to n+2 do           //build
    insert(root,i,i);
  for i:=1 to m do
  begin
    read(x,y);
    reverse(x,y);
  end;
  for i:=2 to n+1 do
    write(kth(i)-1,' ');
  writeln;
end.
```

---

## 作者：zhou2414 (赞：2)

# 思路
~~由于题面上有平衡树，所以用平衡树。~~

我使用序列之王——~~splay~~ fhq_treap 来写这道题，对于 fhq_treap 来说，这题的代码难度十分低。

常规的平衡树按照元素的大小来决定其在左子树还是右子树。在本题中则不一样。

发现本题所需的操作与元素大小没有关系，而是与元素间的相对位置有很大关系。所以考虑以**元素下标**为关键字建立平衡树。这样可以方便我们进行后续的操作。
## 区间反转
以下所说大小均指下标大小。

首先考虑区间反转过后到底发生了什么。

对于一个序列：$1$，$2$，$3$，$4$，$5$。

将其反转后得到：$5$，$4$，$3$，$2$，$1$。

发现任意两个元素的大小关系发生了颠倒。

回忆一下二叉搜索树的性质：
> 比根节点小的元素都在左子树上，比根节点大的元素都在右子树上。

当反转后，所有元素的大小关系颠倒，那么原本大于根节点的都变为了小于根节点的，原本小于根节点的都变为了大于根节点的。
### 实现
那么很显然，对于区间反转操作，只要将该区间内的元素分裂出来，然后将其左右儿子颠倒，同时递归下去即可，无需像其他平衡树一样的复杂操作。~~所以 fhq-treap yyds！~~

考虑在平衡树上加上懒标记。显然交换两次后相当于没交换，所以可以用异或维护懒标记。懒标记下放时只需交换左右儿子即可。
### 代码

```cpp
void pd(ll id){//push_down
	if(tr[id].lazy){
		swap(lson,rson);
		tr[lson].lazy^=tr[id].lazy;
		tr[rson].lazy^=tr[id].lazy;
		tr[id].lazy=0;
	}
}
```
~~非常简单~~。
# 正确性证明
平衡树的实质是维护左右子树的大小关系，即 $w_{left}<w_{root}<w_{right}$。而区间反转就是将所有这样的关系颠倒。因而交换区间内所有节点的左右儿子即可。
# 时间复杂度分析
每次操作只需将要反转的区间分裂出来，然后打上懒标记即可，复杂度 $O(\log n)$。下放懒标记时间复杂度 $O(1)$。

所以总的时间复杂度为 $O(n\log n)$。
# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define lson tr[id].ls
#define rson tr[id].rs
#define il inline
il void write(ll x) {
	if (x < 0) {
		putchar('-');
		x = -x;
	}
	if (x > 9)write(x / 10);
	putchar(x % 10 + 48);
}
il ll read() {
	char ch = getchar();
	ll f = 1, x = 0;
	while (ch < 48 || ch > 57) {
		if (ch == '-')f = -1;
		ch = getchar();
	}
	while (ch >= 48 && ch <= 57) {
		x = x * 10 + ch - 48;
		ch = getchar();
	}
	return x * f;
}
const ll N = 100009;
ll n, m;
struct TREE {
	ll ls, rs;
	bool lazy;
	ll v, siz, p;
} tr[N];
ll cnt, root;
void pu(ll id) {
	tr[id].siz = tr[lson].siz + tr[rson].siz + 1;
}
void pd(ll id) {
	if (tr[id].lazy) {
		swap(lson, rson);
		tr[lson].lazy ^= tr[id].lazy;
		tr[rson].lazy ^= tr[id].lazy;
		tr[id].lazy = 0;
	}
}
il void fen(ll id, ll x, ll &l, ll &r) { //将前x个与第x+1到n个节点分开
	if (!id) {
		l = r = 0;
		return;
	}
	pd(id);
	if (x >= tr[lson].siz + 1) {
		l = id;
		fen(rson, x - tr[lson].siz - 1, tr[id].rs, r);
	} else {
		r = id;
		fen(lson, x, l, tr[id].ls);
	}
	pu(id);
}
il ll he(ll u, ll v) {
	if (u == 0 || v == 0)return u + v;
	pd(u);
	pd(v);
	if (tr[u].p <= tr[v].p) {
		tr[u].rs = he(tr[u].rs, v);
		pu(u);
		return u;
	} else {
		tr[v].ls = he(u, tr[v].ls);
		pu(v);
		return v;
	}
}
il void new_node(ll x) {
	cnt++;
	tr[cnt].v = x;
	tr[cnt].siz = 1;
	tr[cnt].p = rand();
}
il void dfs(ll id) {
	if (!id)return;
	if (tr[id].lazy) {
		swap(tr[id].ls, tr[id].rs);
		tr[lson].lazy = tr[lson].lazy ? 0 : 1;
		tr[rson].lazy = tr[rson].lazy ? 0 : 1;
		tr[id].lazy = 0;
	}
	dfs(lson);
	write(tr[id].v);
	putchar(' ');
	dfs(rson);
}
int main() {
	n = read();
	m = read();
	for (int i = 1; i <= n; i++) {
		new_node(i);
		root = he(root, cnt);
	}
	for (int i = 1; i <= m; i++) {
		ll l = read(), r = read();
		ll lr, rr, mr;
		fen(root, r, lr, rr);
		fen(lr, l - 1, lr, mr);
		tr[mr].lazy = tr[mr].lazy ? 0 : 1;
		root = he(he(lr, mr), rr);
	}
	dfs(root);
	return 0;
}
```

---


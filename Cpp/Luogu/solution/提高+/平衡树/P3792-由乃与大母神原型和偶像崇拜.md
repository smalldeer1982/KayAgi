# 由乃与大母神原型和偶像崇拜

## 题目背景

 ![](https://cdn.luogu.com.cn/upload/pic/5702.png) 

由乃最近没事干，去研究轻拍学去了

就是一个叫做flip flappers，轻拍翻转小膜女的番

 ![](https://cdn.luogu.com.cn/upload/pic/5703.png) 

然后研究的过程中她看到了一个叫做大母神原型的东西

大母神不仅是部落保护神，而且是部落间互相识别的标记（以后泛化为不同的图形符号、服饰和祭祀仪式），在部落联盟出现后，具有领导力的部落神祇，上升为整个联盟的共神，进而成为酋邦和王国的共神

 ![](https://cdn.luogu.com.cn/upload/pic/5709.png) 

大概就是说这个东西是母系社会时候的偶像，然后象征着母亲可以创造生命也可以毁灭生命什么什么的，分别是善母与恶母，既孕育一切，又吞噬一切

然后我们熟知的神话里面就有大母神，比如女娲其实就是个大母神。。。

 ![](https://cdn.luogu.com.cn/upload/pic/5716.png) 

原始部落时期的大母神既具有生育和哺乳的能力，也具有保护部落、带来丰收的神力。

到了神话时期，大母神进一步分化，演变出形形色色的女神，分别象征了女性能量的不同面向：孕育女神、大地女神、爱与美女神、保护女神、战争女神、丰收女神、智慧女神、命运女神……

这些是善母

 ![](https://cdn.luogu.com.cn/upload/pic/5717.png) 

世间的事物总是两面性的：一切生命诞生于土地，最终要回归土地；创造的必然也拥有毁灭的能力。大母神也同样具有痛苦、恐怖、吞噬和危险的一面。

比如童话故事里面的女巫，其实就是大母神的另一面的体现，也就是恶母

糖果屋的故事讲的就是韩赛尔和格雷特被继母赶出家里，因为没饭吃了，然后进了森林发现了一个糖果屋，里面有个女巫，专门吃小孩子

然而如果我们仔细想想这个故事，会发现它没有那么简单

比如说，女巫真的是吃小孩子吗？如果女巫是个善良的老婆婆，无偿救助在森林里面困住的小孩子呢？

还有就是当韩赛尔和格雷特杀死了女巫，回到家中发现她们的继母也死了

这是否意味着她们实际上杀死的是她们的继母？

所以这个故事本质上讲的是她们杀了她们的母亲，也就是打败了大母神

很多神话故事里面都有打败大母神的情节


## 题目描述

 ![](https://cdn.luogu.com.cn/upload/pic/5706.png) 

你看到这里也许已经觉得由乃精神不正常了

然而由乃自从不小心##了自己的##后早就不正常了

由乃研究了很久大母神原型，但是仍然一脸懵逼

于是就出数据结构题骗钱去了

由乃：给你一个序列，每次询问一个区间是否是值域连续段

zzy：你把题意说详细点

由乃：就是说不能有重复数字，比如1 2 2 3就不行，然后4 2 3 1就可以

yql：sb分块

ddd：sb bitset

由乃：woc你们好树链啊，我。。我带修

zzq：#######sb题

由乃：我就是要出原题

 ![](https://cdn.luogu.com.cn/upload/pic/5710.png) 

给你一个长为 $n$ 的序列 $a$

每次两个操作：

1. 修改 $x$ 位置的值为 $y$

2. 查询区间 $[l,r]$ 是否可以重排为值域上连续的一段

![](https://cdn.luogu.com.cn/upload/pic/5705.png)


## 说明/提示

对于 $30\%$ 的数据，$n,m \le 500$

对于 $60\%$ 的数据，$n,m \le 100000$

对于 $100\%$ 的数据，$n,m \le 500000$

初始值的值域小于 $2.5\times 10^7$，修改操作的 $y$ 小于等于 $n$。

2s

## 样例 #1

### 输入

```
5 5
1 2 3 4 5
2 1 5
2 2 3
2 3 3
1 3 4
2 3 5```

### 输出

```
damushen
damushen
damushen
yuanxing```

# 题解

## 作者：noip (赞：224)

 ![](https://cdn.luogu.com.cn/upload/pic/5779.png) 

其实Flip Flappers这个番

讲的就是糖果屋的故事，这点从ED上就可以看出来

现实生活和幻想世界相邻，cocona可以到达幻想世界

 ![](https://cdn.luogu.com.cn/upload/pic/5780.png) 

 ![](https://cdn.luogu.com.cn/upload/pic/5781.png) 

然而cocona可以到达幻想世界是因为她妈是唯一一个可以联通幻想世界和现实世界的人

从最开始就可以发现cocona在奇怪的世界里面，比如她的兔子啊，她住的地方啊。。。

 ![](https://cdn.luogu.com.cn/upload/pic/5782.png) 

 ![](https://cdn.luogu.com.cn/upload/pic/5783.png) 

因为她妈一直潜伏在她身体里面的那个碎片上。。。

cocona和papika一对百合经过艰苦战斗，终于打败了大母神

这个大母神就是mimi，cocona的母亲

然后papika其实是个20岁的人了。。。之前经过了玄学返老还童了。。。

所以说这个番讲的是两个人杀了其中一个人的母亲。。。

有毒。。。

然后。。。

这之后她的世界变正常了。。。

变的。。。正常了。。。

 ![](https://cdn.luogu.com.cn/upload/pic/5784.png) 

 ![](https://cdn.luogu.com.cn/upload/pic/5785.png) 

都以为现实世界和幻想世界的联系切断了

但是最后cocona重新见到了papika。。。

然后。。。又回到了pure illusion？

欢迎大家来研究轻拍学


太。。。厉害了


哦对了忘了说题解了

两个做法

第一个是线段树维护区间min区间max区间和区间平方和

然后通过min和max算出如果这个是连续段，其和和平方和应该是多少

这样就可以了

大概是hash的思想

还有一个是线段树维护区间min区间max，区间每个数值前驱位置的max

不过要麻烦一点


---

## 作者：ouuan (赞：41)

我用的是随机映射+异或和判断连续，由于可以方便地用树状数组维护，混了个最优解..

# 整体思路

1. 把每个数都映射到一个随机数上。

2. 通过求区间内原数的和来判断，这个区间如果连续，值域应该在哪个区间。举个例子，区间长度为 $3$，区间和为 $9$，那么如果这个区间的值连续，值域就应该是 $2$ ~ $4$。

3. 预处理出随机序列的前缀异或和，然后就可以求出，这个区间如果连续，映射到的随机数异或和应该是多少。举个例子，如果值域应该是 $2$ ~ $4$，映射到的随机数分别为 $p_2,\,p_3,\,p_4$，可以通过前缀异或和算出 $p_2\oplus p_3\oplus p_4$（$\oplus$表示异或），如果区间内这三个数映射到的随机数的异或和等于 $p_2\oplus p_3\oplus p_4$，就可以认为这个区间是连续的。

序列的前缀和、序列映射到的随机数的前缀异或和都可以用树状数组维护。

# 具体实现与细节

## 随机数生成

这个随便生成就好了..怕被卡的话可以把 `time(0)` 作为生成随机数的参数之一。推荐用 unsigned long long 自然溢出，也可以用 int 对大质数取模，int 自然溢出貌似过不了。

## 离散化

由于值域是 $10^9$，肯定不能生成 $10^9$ 个随机数，所以需要离散化。

直接离散化的话可能会导致本不连续的值连续，有两种解决方法。

### 一、

这种方法比较优美自然。离散化的时候把每个值+1放到离散化数组里，这样原本不连续的数离散化后也不连续。

### 二、

这种方法稍微麻烦一点，然而常数会小一些。记录一下离散化数组中每个数是否和前一个数一样，如果离散化用的数组叫做 $lsh$（已经排好序），令 $dif_i=[lsh_i=lsh_{i-1}]$，求出 $dif$ 的前缀和 $blo_i$ ，那么 $blo_i$ 相同的数就是在一个连续块里的。令 $f_i=[blo_{a_i}=blo_{a_{i-1}}]$（也就是这一位是否和前一位在一个连续块里），再用一个树状数组维护 $f$ 的前缀和，就可以快速查询一个区间内的所有值是否都在同一个连续块里。

## 修改

修改的时候如果是用方法一离散化的，直接在树状数组里更新和还有异或和就可以了。如果是用方法二离散化的，还要更新修改的位置以及修改的位置的下一个位置的 $f$。

## 树状数组维护前缀异或和

这个跟维护前缀和是一样的..把+换成^就可以了。

# 参考代码

由于我方法二的代码写的太丑了，这里就只放方法一的代码..

```cpp
#include <iostream>
#include <cstdio>
#include <cctype>
#include <ctime>
#include <algorithm>

using namespace std;

const int N=500010;

typedef unsigned long long ull;

int read()
{
	int out=0;
	char c;
	while (!isdigit(c=getchar()));
	for (;isdigit(c);c=getchar()) out=out*10+c-'0';
	return out;
}

void asum(int p,int x); //维护和的树状数组
ull qsum(int p);
void axor(int p,ull x); //维护异或和的树状数组
ull qxor(int p);

int n,m,a[N],lsh[N<<2],tot,op[N],x[N],y[N]; //op、x、y是先把询问存下来，方便离散化
ull p[N<<2],pre[N<<2],sum[N],xsum[N]; //p是随机数，pre是随机数的前缀异或和，后面两个是树状数组

int main()
{
	int i,l,r,mid;
	
	n=read();
	m=read();
	
	for (i=1;i<=n;++i)
	{
		lsh[++tot]=a[i]=read();
		lsh[++tot]=a[i]+1; //离散化的时候把值+1也放进去，这样不连续的值离散化后也不连续
	}
	
	for (i=1;i<=m;++i)
	{
		op[i]=read();
		x[i]=read();
		y[i]=read();
		if (op[i]==1)
		{
			lsh[++tot]=y[i];
			lsh[++tot]=y[i]+1;
		}
	}
	
	sort(lsh+1,lsh+tot+1);
	tot=unique(lsh+1,lsh+tot+1)-lsh;
	
    p[0]=time(0); //~~欢迎大家来卡我~~如果真被卡了我就换成梅森旋转好了..
	for (i=1;i<tot;++i)
	{
		p[i]=p[i-1]*1000000007+19260817; //生成随机数
		pre[i]=pre[i-1]^p[i]; //求随机序列的前缀异或和
	}
	
	for (i=1;i<=n;++i)
	{
		a[i]=lower_bound(lsh+1,lsh+tot,a[i])-lsh; //离散化
		asum(i,a[i]); //初始化前缀和
		axor(i,p[a[i]]); //初始化前缀异或和
	}
	
	for (i=1;i<=m;++i)
	{
		if (op[i]==1)
		{
			y[i] = lower_bound(lsh + 1, lsh + tot, y[i]) - lsh;
			asum(x[i],y[i]-a[x[i]]); //更新前缀和
			axor(x[i],p[y[i]]^p[a[x[i]]]); //更新前缀异或和
			a[x[i]]=y[i]; //更新单点的值
		}
		else
		{
			mid=(qsum(y[i])-qsum(x[i]-1))/(y[i]-x[i]+1); //算出l、r，代表如果区间连续，值域的范围
			l=mid-(y[i]-x[i])/2;
			if ((y[i]-x[i])&1) r=mid+(y[i]-x[i])/2+1;
			else r=mid+(y[i]-x[i])/2;
			if (l<=0||r>=tot) puts("yuanxing");
			else if ((qxor(y[i])^qxor(x[i]-1))==(pre[r]^pre[l-1])) puts("damushen"); //判断实际的区间异或和与值域内异或和是否相等
			else puts("yuanxing");
		}
	}
	
	return 0;
}

void asum(int p,int x)
{
	for (;p<=n;p+=(p&-p)) sum[p]+=x;
}
ull qsum(int p)
{
	ull out=0;
	for (;p;p-=(p&-p)) out+=sum[p];
	return out;
}

void axor(int p,ull x)
{
	for (;p<=n;p+=(p&-p)) xsum[p]^=x;
}
ull qxor(int p)
{
	ull out=0;
	for (;p;p-=(p&-p)) out^=xsum[p];
	return out;
}
```

---

## 作者：Suiseiseki (赞：27)

**这一道题的保证正确性做法。**

我们记录区间最大最小值，若最大最小之差等于序列长度且序列中无重复元素，则一定可行，那么，维护每一个点前驱（指在它之前和它的权值相同的元素）即可（~~惯用套路~~），查询区间内前驱最大值是否再区间左端即可。

然后打了一份代码交上去，发现MLE了3个点，只有70分，对于离散化中的map和记录前驱的set，做一个内存回收即可。

代码：
```cpp
#include <set>
#include <map>
#include <cstdio>
using namespace std;
const int Maxn=500000;
int n,m;
map<int,int> id_buc;
set<int> num[Maxn+5];
int sta[Maxn+5],top;
int a[Maxn+5],b[Maxn+5],pre[Maxn+5];
int id_tot;
int get_id(int x){
	if(id_buc.count(x)>0){
		return id_buc[x];
	}
	if(top>0){
		return id_buc[x]=sta[top--];
	}
	id_tot++;
	num[id_tot].insert(0);
	return id_buc[x]=id_tot;
}
struct Segment_Node_Val{
	int minn,maxn;
	int pre_max;
};
Segment_Node_Val make_SNV(int val,int pre){
	static Segment_Node_Val ans;
	ans.minn=ans.maxn=val;
	ans.pre_max=pre;
	return ans;
}
struct Segment_Node{
	Segment_Node_Val val;
}seg[1048577];
int mn(int a,int b){
	return a<b?a:b;
}
int mx(int a,int b){
	return a>b?a:b;
}
Segment_Node_Val push_up(Segment_Node_Val p,Segment_Node_Val q){
	Segment_Node_Val ans;
	ans.minn=mn(p.minn,q.minn);
	ans.maxn=mx(p.maxn,q.maxn);
	ans.pre_max=mx(p.pre_max,q.pre_max);
	return ans;
}
void build(int root,int left,int right){
	if(left==right){
		seg[root].val=make_SNV(a[left],pre[left]);
		return;
	}
	int mid=(left+right)>>1;
	build(root<<1,left,mid);
	build(root<<1|1,mid+1,right);
	seg[root].val=push_up(seg[root<<1].val,seg[root<<1|1].val);
}
void update(int root,int x,Segment_Node_Val v,int left=1,int right=n){
	if(left==right){
		seg[root].val=v;
		return;
	}
	int mid=(left+right)>>1;
	if(x<=mid){
		update(root<<1,x,v,left,mid);
	}
	else{
		update(root<<1|1,x,v,mid+1,right);
	}
	seg[root].val=push_up(seg[root<<1].val,seg[root<<1|1].val);
}
Segment_Node_Val query(int root,int l,int r,int left=1,int right=n){
	if(l<=left&&r>=right){
		return seg[root].val;
	}
	int mid=(left+right)>>1;
	if(r<=mid){
		return query(root<<1,l,r,left,mid);
	}
	if(l>mid){
		return query(root<<1|1,l,r,mid+1,right);
	}
	return push_up(query(root<<1,l,r,left,mid),query(root<<1|1,l,r,mid+1,right));
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		b[i]=get_id(a[i]);
		pre[i]=*(--num[b[i]].end());
		num[b[i]].insert(i);
	}
	build(1,1,n);
	int op,l,r;
	set<int>::iterator it;
	Segment_Node_Val tmp;
	for(int i=1;i<=m;i++){
		scanf("%d",&op);
		if(op==1){
			scanf("%d%d",&l,&r);
			it=num[b[l]].find(l);
			it++;
			if(it!=num[b[l]].end()){
				pre[(*it)]=pre[l];
				update(1,(*it),make_SNV(a[*it],pre[*it]));
			}
			it--;
			num[b[l]].erase(it);
			if(num[b[l]].size()==1){
				id_buc.erase(a[l]);
				sta[++top]=b[l];
			}
			a[l]=r;
			b[l]=get_id(a[l]);
			num[b[l]].insert(l);
			it=num[b[l]].find(l);
			it--;
			pre[l]=(*it);
			it++;
			it++;
			if(it!=num[b[l]].end()){
				pre[*it]=l;
				update(1,*it,make_SNV(a[*it],pre[*it]));
			}
			update(1,l,make_SNV(a[l],pre[l]));
		}
		else{
			scanf("%d%d",&l,&r);
			tmp=query(1,l,r);
			if(tmp.maxn-tmp.minn+1==r-l+1&&tmp.pre_max<l){
				puts("damushen");
			}
			else{
				puts("yuanxing");
			}
		}
	}
	return 0;
}
```

---

## 作者：syzf2222 (赞：12)

思路：线段树+带修莫队

考虑到只要使这个区间的最大值减去最小值等于区间大小，并且区间内无重复数字。

区间极值可以用线段树维护。

无重复数字可以用带修莫队搞定。

时间复杂度$O(n\sqrt n)$

注意：理论上块长为$n^{\frac 23}$最佳，可是这里只有$n^{\frac 12}$能过（不吸氧都能过！）

```cpp
#include<bits/stdc++.h>
const int maxn=5*1e5+10;
struct node{
	int mi,mx;
}tr[maxn<<2];
int n,m,a[maxn];
inline int read(){
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+c-'0';c=getchar();}
	return x*f;
}
inline void build(int h,int l,int r){
	if(l==r){
		tr[h].mi=tr[h].mx=a[l];
		return;
	}
	int mid=(l+r)>>1;
	build(h<<1,l,mid);
	build(h<<1|1,mid+1,r);
	tr[h].mi=std::min(tr[h<<1].mi,tr[h<<1|1].mi);
	tr[h].mx=std::max(tr[h<<1].mx,tr[h<<1|1].mx);
}
int ans[maxn],cnt1,cnt2;
struct change{
	int pos,col;
}c[maxn];
struct quest{
	int l,r,id,bl,br,ti;
}q[maxn];
int cnt[maxn*50],now,len;
inline void update(int h,int l,int r,int x,int y){
	if(l==r){
		tr[h].mi=tr[h].mx=y;
		return;
	}
	int mid=(l+r)>>1;
	if(mid>=x)update(h<<1,l,mid,x,y);
	else update(h<<1|1,mid+1,r,x,y);
	tr[h].mi=std::min(tr[h<<1].mi,tr[h<<1|1].mi);
	tr[h].mx=std::max(tr[h<<1].mx,tr[h<<1|1].mx);
}
inline int qmax(int h,int l,int r,int x,int y){
	if(l>y||r<x)return -1e9;
	if(l>=x&&r<=y)return tr[h].mx;
	int mid=(l+r)>>1;
	return std::max(qmax(h<<1,l,mid,x,y),qmax(h<<1|1,mid+1,r,x,y));
}
inline int qmin(int h,int l,int r,int x,int y){
	if(l>y||r<x)return 1e9;
	if(l>=x&&r<=y)return tr[h].mi;
	int mid=(l+r)>>1;
	return std::min(qmin(h<<1,l,mid,x,y),qmin(h<<1|1,mid+1,r,x,y));
}
inline int cmp(quest x,quest y){
	return (x.bl^y.bl)?(x.bl<y.bl):((x.br^y.br)?(x.br<y.br):((x.br&1)?(x.ti<y.ti):(x.ti>y.ti)));
}
int main(){
	n=read(),m=read();
	len=pow(n,0.5);
	for(int i=1;i<=n;i++)
		a[i]=read();
	build(1,1,n);
	int opt,x,y;
	for(int i=1;i<=m;i++){
		opt=read(),x=read(),y=read();
		if(opt==1){
			cnt1++;
			c[cnt1].pos=x;
			c[cnt1].col=y;
			update(1,1,n,x,y);
		}else{
			cnt2++;
			q[cnt2].l=x;
			q[cnt2].r=y;
			q[cnt2].id=cnt2;
			q[cnt2].bl=x/len;
			q[cnt2].br=y/len;
			q[cnt2].ti=cnt1;
			ans[cnt2]=(qmax(1,1,n,x,y)-qmin(1,1,n,x,y)==y-x);
		}
	}
	std::sort(q+1,q+1+cnt2,cmp);
	int l=1,r=0,tim=0;
	for(int i=1;i<=cnt2;i++){
		if(!ans[q[i].id])continue;
		while(l<q[i].l)now-=!(--cnt[a[l++]]);
		while(l>q[i].l)now+=!(cnt[a[--l]]++);
		while(r<q[i].r)now+=!(cnt[a[++r]]++);
		while(r>q[i].r)now-=!(--cnt[a[r--]]);
		while(tim>q[i].ti){
			if(q[i].l<=c[tim].pos&&q[i].r>=c[tim].pos){
				now-=!--cnt[a[c[tim].pos]];
				now+=!cnt[c[tim].col]++;
			}
			std::swap(c[tim].col,a[c[tim].pos]);
			tim--;
		}
		while(tim<q[i].ti){
			tim++;
			if(l<=c[tim].pos&&r>=c[tim].pos){
				now-=!--cnt[a[c[tim].pos]];
				now+=!cnt[c[tim].col]++;
			}
			std::swap(c[tim].col,a[c[tim].pos]);
		}
		ans[q[i].id]=(now==q[i].r-q[i].l+1);
	}
	for(int i=1;i<=cnt2;i++)
		if(ans[i])puts("damushen");
		else puts("yuanxing");
	return 0;
}
```

---

## 作者：da32s1da (赞：9)

我们不用 平方和 和 立方和，我们用$2^i$来判断。

当然就是$hash$啦！。

我们取$4$个模数：$1000000007,1001100007,1001000107,1010010007\ \ $~~都是质数~~。

当一段区间是连续的，除了**最大值和最小值**的限制外，还有$4$个$hash$值相同。

比如$\ x...y\ $是连续的，则有$$\sum_{i=x}^y2^i=\sum_{i=Min}^{Max}2^i=2^{Max+1}-2^{Min}$$

~~~
#include<cstdio>
using namespace std; 
typedef long long LL;
const int N=5e5+50;
const int mod[4]={1000000007,1001100007,1001000107,1010010007};
int n,m,opt,x,y;
inline int max(int u,int v){return u>v?u:v;}
inline int min(int u,int v){return u<v?u:v;}
int tre[N<<3][4],Max[N<<3],Min[N<<3];
int max_val,min_val,mod_val[4];
int ksm(int u,int op){
    int res=1,v=2;
    for(;u;u>>=1,v=1ll*v*v%mod[op])
    if(u&1)res=1ll*res*v%mod[op];
    return res;
}
void mktree(int now,int ls,int rs){
    if(ls==rs){
        scanf("%d",&x);
        Max[now]=Min[now]=x;
        for(int i=0;i<4;i++)
        tre[now][i]=ksm(x,i);
        return;
    }
    int noww=now<<1,nrs=ls+rs>>1;
    mktree(noww,ls,nrs);
    mktree(noww|1,nrs+1,rs);
    for(int i=0;i<4;i++)
    tre[now][i]=(tre[noww][i]+tre[noww|1][i])%mod[i];
    Max[now]=max(Max[noww],Max[noww|1]);
    Min[now]=min(Min[noww],Min[noww|1]);
}
void change(int now,int ls,int rs,int mb,int val){
    if(ls>mb||rs<mb)return;
    if(ls==rs){
        Max[now]=Min[now]=x;
        for(int i=0;i<4;i++)
        tre[now][i]=ksm(x,i);
        return;
    }
    int noww=now<<1,nrs=ls+rs>>1;
    change(noww,ls,nrs,mb,val);
    change(noww|1,nrs+1,rs,mb,val);
    for(int i=0;i<4;i++)
    tre[now][i]=(tre[noww][i]+tre[noww|1][i])%mod[i];
    Max[now]=max(Max[noww],Max[noww|1]);
    Min[now]=min(Min[noww],Min[noww|1]);
}
void qsth(int now,int ls,int rs,int zuo,int you){
    if(ls>you||rs<zuo)return;
    if(ls>=zuo&&rs<=you){
        max_val=max(max_val,Max[now]);
        min_val=min(min_val,Min[now]);
        for(int i=0;i<4;i++)
        mod_val[i]=(mod_val[i]+tre[now][i])%mod[i];
        return;
    }
    int noww=now<<1,nrs=ls+rs>>1;
    qsth(noww,ls,nrs,zuo,you);
    qsth(noww|1,nrs+1,rs,zuo,you);
}
int main(){
    scanf("%d%d",&n,&m);
    mktree(1,1,n);
    for(int i=1;i<=n;i++){
        scanf("%d%d%d",&opt,&x,&y);
        if(opt==1)change(1,1,n,x,y);
        else{
            max_val=0;min_val=mod[3];
            for(int j=0;j<4;j++)mod_val[j]=0;
            qsth(1,1,n,x,y);
            if(max_val-min_val!=y-x){
                puts("yuanxing");
                continue;
            }
            //判断最大值减最小值是否等于区间长度
            y=0;
            for(int j=0;j<4;j++){
                x=(ksm(max_val+1,j)-ksm(min_val,j)+mod[j])%mod[j];
                if(x!=mod_val[j]){y=1;break;}
                //判断4个hash值
            }
            puts(y?"yuanxing":"damushen");
        }
    }
}
~~~

~~最大点1800ms。~~

我们冒着WA的风险，只用了$10^9+7$这一个模数，也能AC。

~~最大点400ms。~~

我们受到[P5110 块速递推](https://www.luogu.org/problemnew/show/P5110)的启发，将$2$的幂次分块打表。做到单次$O(1)$。

```
#include<cstdio>
#include<iostream>
using namespace std;
const int N=5e5+50;
const int M=32767;
const int mod=1e9+7;
typedef long long LL;
int n,m,opt,x,y;
int _2[2][M+1];
#define getchar() (S==T&&(T=(S=BB)+fread(BB,1,1<<15,stdin),S==T)?EOF:*S++)
char BB[1<<20],*S=BB,*T=BB;
inline void rad(int &_){
    static char ch;
    while(ch=getchar(),ch<'0'||ch>'9');_=ch-48;
    while(ch=getchar(),ch>='0'&&ch<='9')_=_*10+ch-48;
}
//inline int max(int u,int v){return u>v?u:v;}
//inline int min(int u,int v){return u<v?u:v;}
int tre[N<<3],Max[N<<3],Min[N<<3];
int max_val,min_val;
LL mod_val;
void mktree(int now,int ls,int rs){
    if(ls==rs){
        rad(x);
        Max[now]=Min[now]=x;
        tre[now]=1ll*_2[0][x&M]*_2[1][x>>15]%mod;
        return;
    }
    int noww=now<<1,nrs=(ls+rs)>>1;
    mktree(noww,ls,nrs);
    mktree(noww|1,nrs+1,rs);
    tre[now]=(tre[noww]+tre[noww|1])%mod;
    Max[now]=max(Max[noww],Max[noww|1]);
    Min[now]=min(Min[noww],Min[noww|1]);
}
void change(int now,int ls,int rs,int mb,int val){
    if(ls>mb||rs<mb)return;
    if(ls==rs){
        Max[now]=Min[now]=x;
        tre[now]=1ll*_2[0][x&M]*_2[1][x>>15]%mod;
        return;
    }
    int noww=now<<1,nrs=(ls+rs)>>1;
    change(noww,ls,nrs,mb,val);
    change(noww|1,nrs+1,rs,mb,val);
    tre[now]=(tre[noww]+tre[noww|1])%mod;
    Max[now]=max(Max[noww],Max[noww|1]);
    Min[now]=min(Min[noww],Min[noww|1]);
}
void qsth(int now,int ls,int rs,int zuo,int you){
    if(ls>you||rs<zuo)return;
    if(ls>=zuo&&rs<=you){
        max_val=max(max_val,Max[now]);
        min_val=min(min_val,Min[now]);
        mod_val+=tre[now];
        return;
    }
    int noww=now<<1,nrs=(ls+rs)>>1;
    qsth(noww,ls,nrs,zuo,you);
    qsth(noww|1,nrs+1,rs,zuo,you);
}
int main(){
    rad(n);rad(m);
    _2[0][0]=1;
    for(int i=1;i<=M;++i)_2[0][i]=(_2[0][i-1]<<1)%mod; 
    _2[1][0]=1;_2[1][1]=(_2[0][M]<<1)%mod;
    for(int i=2;i<=M;++i)_2[1][i]=1ll*_2[1][i-1]*_2[1][1]%mod;
    //分块打表
    mktree(1,1,n);
    for(int i=1;i<=m;++i){
        rad(opt);rad(x);rad(y); 
        if(opt==1)change(1,1,n,x,y);
        else{
            max_val=mod_val=0;min_val=mod;
            qsth(1,1,n,x,y);
            if(max_val-min_val!=y-x){
                puts("yuanxing");
                continue;
            }
            mod_val%=mod;++max_val;
            x=(1ll*_2[0][max_val&M]*_2[1][max_val>>15]%mod-1ll*_2[0][min_val&M]*_2[1][min_val>>15]%mod+mod)%mod;
            puts(x==mod_val?"damushen":"yuanxing");
        }
    }
}
```

~~拿到了最优解第6(目前)~~

---

## 作者：critnos (赞：9)

~~事实上这道题没什么难的~~

因为不太好维护，所以考虑使用一些正确率高的假做法。

这是 lxl 给出的官方题解：

>第一个是线段树维护区间min区间max区间和区间平方和

>然后通过min和max算出如果这个是连续段，其和和平方和应该是多少

然后我试了一下，用 `unsigned long long` 自然溢出，会发现只拿了 $73 \ \text{pts}$。

应该是要用一个优秀一些的模数。

但是取模好慢啊！

所以维护 $3$ 次方和就行了。。。

讲明白一点，通过求区间的 $\max,\min$ 求出这个区间的左右端点，然后用公式验证这个区间的和是否符合连续区间的性质。

二次方的公式：$\sum_{i=1}^n i^2=\dfrac n 6 \times (n+1) \times (2\times n+1)$。

三次方的公式：$\sum_{i=1}^n i^3=(\sum_{i=1}^n i)^2$。

然后这个括号里的就是一个等差数列求和。。。

代码就不给辣

---

## 作者：wyx150137 (赞：9)

首先我先轻轻的斥责一下这题卡一个 $nlog(n)$ 算法常数的暴行……


容易发现一段区间合法当且仅当一段区间的 $Max$ 减去一段区间的 $Min$ 等于区间的长度，但是只满足这个我们是没法保证他一定是对的……因为可能存在重复的数字


考虑一段区间如果每个数字的 $next$ 即下一次出现的位置都 $>r$ 则一定没有重复的数字，这是经典套路【划掉


那么我们线段树维护一下区间每一个数字的 $next$ 的最小值就行辣


注意到需要动态修改前驱和后继，所以我们需要大力对每个元素开一个平衡树维护出所有元素他的位置，这样就能快速查询前驱和后继了，当然需要离散权值。


我当时考试的时候大力写了一发然后交上去 $MLE$ 了，非常绝望，可能是 STL 的锅吧……但是注意到这个算法是能保证正确性是完全正确的。


虽然我后来交的也是 hash 过掉的本题但是只维护和，平方和是肯定不行的，这个概率其实撞上的还是挺大的，毕竟是一坨数字，为了保证正确其实可以维护一坨数字的异或和等等等等


放一个第一个做法的代码供对此算法感兴趣的同学学习借鉴,当然，并不能过，只有 70pts


```cpp
#include <set>
#include <map>
#include <stdio.h>
#include <string.h>
#include <iostream>
#include <algorithm>
using namespace std;
const int inf = 1e9+7;
const int N = 500000+5;
const int M = 1048576+5;
inline int read() {
    int x=0,f=1;char ch = getchar();
    while(ch < '0' || ch > '9'){if(ch == '-')f=-1;ch = getchar();}
    while(ch >='0' && ch <='9'){x=(x<<1)+(x<<3)+ch-'0';ch = getchar();}
    return x*f;
}

int Max[M], Min[M], tr[M], nxt[M], last[M];
int a[N];

map <int,int> mp;
set <int> s[M];

inline void build(int k,int l,int r) {
    if(l==r) {
        Max[k] = Min[k] = a[l];
        tr[k] = nxt[l];
        return;
    }
    int mid = (l+r) >> 1;
    build(k<<1,l,mid);
    build(k<<1|1,mid+1,r);
    Max[k] = max(Max[k<<1], Max[k<<1|1]);
    Min[k] = min(Min[k<<1], Min[k<<1|1]);
    tr[k] = min(tr[k<<1], tr[k<<1|1]);
}

inline void change(int k,int l,int r,int pos,int val,int _temp) {
    if(l==r) {
        Max[k] = Min[k] = val;
        tr[k] = _temp;
        return;
    }
    int mid = (l+r) >> 1;
    if(pos <= mid) change(k<<1,l,mid,pos,val,_temp);
    else change(k<<1|1,mid+1,r,pos,val,_temp);
    Max[k] = max(Max[k<<1], Max[k<<1|1]);
    Min[k] = min(Min[k<<1], Min[k<<1|1]);
    tr[k] = min(tr[k<<1], tr[k<<1|1]);
}

void ask(int k,int l,int r,int x,int y,int &temp1,int &temp2,int &temp3) { // Max Min nxt_Min
    if(x <= l && r <= y) {
        if(temp1 < Max[k]) temp1 = Max[k];
        if(temp2 > Min[k]) temp2 = Min[k];
        if(temp3 > tr[k])  temp3 = tr[k];
        return;
    }
    int mid = (l+r) >> 1;
    if(x <= mid) ask(k<<1, l, mid, x, y, temp1, temp2, temp3);
    if(y > mid) ask(k<<1|1, mid+1 , r, x, y, temp1, temp2, temp3);
}

int cnt;

int main() {
//    freopen("tt.in","r",stdin);
    int n = read(), m = read();
    for(int i=1;i<=n;++i) a[i] = read();
    for(int i=n;i>=1;--i) {
        if(!mp[a[i]]) {
            mp[a[i]] = ++cnt;
            last[cnt] = n + 1;
            s[cnt].insert(0);
            s[cnt].insert(n+1);
        }
        nxt[i] = last[mp[a[i]]];
        last[mp[a[i]]] = i;
    }
    for(int i=1;i<=n;++i) s[mp[a[i]]].insert(i);
    build(1,1,n);
    set <int> :: iterator it;
    for(int i=1;i<=m;++i) {
        int opt = read();
        if(opt == 1) {
            int x = read(), y = read(), temp = mp[a[x]], temp2, temp3;
            s[temp].erase(s[temp].find(x));
            it = s[temp].upper_bound(x);
            temp3 = (*it); it --;     temp2 = (*it); // temp2  x  temp3
            if(temp2 > 0) change(1,1,n,temp2,a[temp2],temp3);
            a[x] = y;
            
            if(!mp[y]) {
                mp[y] = ++cnt;
                s[cnt].insert(0);
                s[cnt].insert(n+1);
            }
            
            temp = mp[y];
            it = s[temp].upper_bound(x); 
            temp3 = (*it); it --; temp2 = (*it); // temp2 x temp3
            if(temp2 > 0) change(1,1,n,temp2,a[temp2],x);
            s[temp].insert(x);
            change(1,1,n,x,a[x], temp3);
        }
        else {
            int temp1 = 0, temp2 = inf, temp3 = inf;
            int x = read(), y = read();
            ask(1,1,n,x,y,temp1,temp2,temp3);
            if(temp1 - temp2 + 1 == y - x + 1 && temp3 > y) puts("damushen");
            else puts("yuanxing");
        }
    }
}
```




---

## 作者：w33z8kqrqk8zzzx33 (赞：3)

考虑乱搞，怎么乱搞呢？

我们希望有一个哈希函数 $f(a)$，把一个序列转换成一个正整数，使得：

 1. 如果 $a$ 是 $b$ 的一个重排列，那么 $f(a) = f(b)$；
 2. 如果 $a$ 不是 $b$ 的一个重排列，大概率的 $f(a) \neq f(b)$；
 3. $f([i,i+1,i+2,\dots,i+k])$ 可以快速计算；
 4. 在一个带修改的序列 $A$ 上面 $f(A[i:i+k])$ 可以快速计算；

这样子的函数很多，有一个通用函数类型就是 

$$f_{(k,p)}(A)=\sum k^{A_i}\pmod p$$

这样的函数如果想防止卡很简单，可以用两个这个哈希函数然后随机选两个 $(k,p)$ 使得 $p$ 是质数，但是应为这里的数据还不算毒，所以就固定两个 $(k,p)$：$(37,10^9+7)$ 和 $(41,10^9+7)$。

看一看为什么满足以上的四个性质：

 1. 显然，应为加法交换
 2. 应为 $f(a) = a^b \pmod{10^9+7}$ 的周期很大（当 $a\neq 1$），并且 $|f(a)-f(a-1)|$ 也很大，同长度的撞哈希序列很少
 3. $k^{[i,i+1,i+2,\dots,i+k]}$ 形成一个等比数列，可以直接计算乘法逆元套入等比数列和方程。
 4. 直接用树状数组维护。

最后要的东西就是计算子序列排序完成的序列 $[i,i+1,i+2,\dots,i+k]$ 的 $i$ 是什么，这个可以直接用线段树维护。

代码：

```cpp
// writer: w33z8kqrqk8zzzx33
#include <bits/stdc++.h>
using namespace std;

// begin fast read template by CYJian (source: https://www.luogu.com.cn/paste/i11c3ppx)

namespace io {
	const int __SIZE = (1 << 21) + 1;
	char ibuf[__SIZE], *iS, *iT, obuf[__SIZE], *oS = obuf, *oT = oS + __SIZE - 1, __c, qu[55]; int __f, qr, _eof;
	#define Gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, __SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)
	inline void flush () { fwrite (obuf, 1, oS - obuf, stdout), oS = obuf; }
	inline void gc (char &x) { x = Gc(); }
	inline void pc (char x) { *oS ++ = x; if (oS == oT) flush (); }
	inline void pstr (const char *s) { int __len = strlen(s); for (__f = 0; __f < __len; ++__f) pc (s[__f]); }
	inline void gstr (char *s) { for(__c = Gc(); __c < 32 || __c > 126 || __c == ' ';)  __c = Gc();
		for(; __c > 31 && __c < 127 && __c != ' '; ++s, __c = Gc()) *s = __c; *s = 0; }
	template <class I> inline bool gi (I &x) { _eof = 0;
		for (__f = 1, __c = Gc(); (__c < '0' || __c > '9') && !_eof; __c = Gc()) { if (__c == '-') __f = -1; _eof |= __c == EOF; }
		for (x = 0; __c <= '9' && __c >= '0' && !_eof; __c = Gc()) x = x * 10 + (__c & 15), _eof |= __c == EOF; x *= __f; return !_eof; }
	template <class I> inline void print (I x) { if (!x) pc ('0'); if (x < 0) pc ('-'), x = -x;
		while (x) qu[++ qr] = x % 10 + '0',  x /= 10; while (qr) pc (qu[qr --]); }
	struct Flusher_ {~Flusher_(){flush();}}io_flusher_;
} using io::pc; using io::gc; using io::pstr; using io::gstr; using io::gi; using io::print;

// end fast read template by CYJian

#define iter(i, a, b) for(int i=(a); i<(b); i++)
#define rep(i, a) iter(i, 0, a)
#define rep1(i, a) iter(i, 1, (a)+1)
#define log(a) cerr<<"\033[32m[DEBUG] "<<#a<<'='<<(a)<<" @ line "<<__LINE__<<"\033[0m"<<endl
#define all(a) a.begin(), a.end()
#define fi first
#define se second
#define pb push_back
#define mp make_pair
 
using ll=long long;
using pii=pair<int, int>;
//#define int ll
const int MOD = 1000000007;

int aray[500005];
int val[2000006];
void segt_build(int idx, int l, int r) {
	if(l == r) { val[idx] = 0xFFFFFFF; return; }
	if(r-l == 1) { val[idx] = aray[l]; return; }
	segt_build(2*idx, l, (l+r)/2);
	segt_build(2*idx+1, (l+r)/2, r);
	val[idx] = min(val[2*idx], val[2*idx+1]);
}
void segt_upd(int idx, int l, int r, int i, int v) { // [l, r)
	if(i < l || r <= i) return;
	if(l == i && r == i+1) { val[idx] = v; return; }
	segt_upd(2*idx, l, (l+r)/2, i, v);
	segt_upd(2*idx+1, (l+r)/2, r, i, v);
	val[idx] = min(val[2*idx], val[2*idx+1]);
}
int segt_get(int idx, int l, int r, int il, int ir) { // [l, r), [il, ir)
	if(ir <= l || r <= il) return 0xFFFFFFF;
	if(il <= l && r <= ir) return val[idx];
	return min(segt_get(2*idx, l, (l+r)/2, il, ir), segt_get(2*idx+1, (l+r)/2, r, il, ir));
}

int bit_N;
int bit[500004][2];

inline int lb(const int& x) { return x & (-x); }
void bit_upd(int lc, int id, int v) { 
	lc++;
	while(lc <= bit_N) { 
		bit[lc][id] += v; 
		bit[lc][id] -= (bit[lc][id] >= MOD ? MOD : 0);
		lc += lb(lc); 
	} 
}
int bit_get(int lc, int id) { 
	lc++;
	int ans = 0; 
	while(lc) { 
		ans += bit[lc][id]; 
		ans -= (ans >= MOD ? MOD : 0);
		lc -= lb(lc); 
	} 
	return ans;
}

int gsm1[65536][2];
int gsm2[65536][2];
int inv[2];

constexpr int BASE1 = 37;
constexpr int BASE2 = 41;

inline int ex(int b, int e) { return 1ll * gsm1[e&65535][b] * gsm2[e>>16][b] % MOD; }

int qpow(int b, int e) {
	int ans = 1;
	while(e) {
		if(e & 1) ans = 1ll * ans * b % MOD;
		b = 1ll * b * b % MOD;
		e >>= 1;
	}
	return ans;
}

void initex() {
	gsm1[0][0] = gsm1[0][1] = gsm2[0][0] = gsm2[0][1] = 1;
	gsm1[1][0] = BASE1; 
	inv[0] = qpow(BASE1-1, MOD-2);
	gsm2[1][0] = qpow(BASE1, 65536);
	gsm1[1][1] = BASE2;
	inv[1] = qpow(BASE2-1, MOD-2);
	gsm2[1][1] = qpow(BASE2, 65536);
	iter(i, 2, 65536) {
		gsm1[i][0] = 1ll * gsm1[i-1][0] * gsm1[1][0] % MOD;
		gsm1[i][1] = 1ll * gsm1[i-1][1] * gsm1[1][1] % MOD;
		gsm2[i][0] = 1ll * gsm2[i-1][0] * gsm2[1][0] % MOD;
		gsm2[i][1] = 1ll * gsm2[i-1][1] * gsm2[1][1] % MOD;
	}
}

signed main() {
    ios_base::sync_with_stdio(false); cin.tie(0);
	initex();
	int n, m; gi(n), gi(m);
	bit_N = n+2;
	rep(i, n) {
		gi(aray[i]);
		bit_upd(i, 0, ex(0, aray[i]));
		bit_upd(i, 1, ex(1, aray[i]));
	}
	segt_build(1, 0, n);
	int tmp, tmp2;
	while(m--) {
		int o, a, b; gi(o), gi(a), gi(b);
		if(o == 1) {
			a--;
			segt_upd(1, 0, n, a, b);
			tmp = ex(0, b) - ex(0, aray[a]);
			tmp += (tmp < 0 ? MOD : 0);
			bit_upd(a, 0, tmp);
			tmp = ex(1, b) - ex(1, aray[a]); 
			tmp += (tmp < 0 ? MOD : 0);
			bit_upd(a, 1, tmp);
			aray[a] = b;
		}
		else {
			a--;
			int mi = segt_get(1, 0, n, a, b), sz = b - a;
			tmp = 1ll * (MOD + ex(0, mi + sz) - ex(0, mi)) * inv[0] % MOD;
			tmp2 = bit_get(b-1, 0) - bit_get(a-1, 0);
			tmp2 += (tmp2 < 0 ? MOD : 0);
			if(tmp != tmp2) pstr("yuanxing\n");
			else {
				tmp = 1ll * (MOD + ex(1, mi + sz) - ex(1, mi)) * inv[1] % MOD;
				tmp2 = bit_get(b-1, 1) - bit_get(a-1, 1);
				tmp2 += (tmp2 < 0 ? MOD : 0);
				if(tmp != tmp2)	pstr("yuanxing\n");
				else pstr("damushen\n");
			}
		}
	}
}
```

---

## 作者：kkxhh (赞：2)

怕被各种毒瘤数据卡于是同时维护了**区间最大最小值，区间和，区间平方和和区间立方和**

试了下讨论区里的几组hack数据都没问题，~~希望不会被hackqwq~~

顺便给大家介绍两个神奇的~~（网上搜的）~~公式

## $\sum_{i=1}^{n}i^{2}=\frac{n(n+1)(2n+1)}{6}$

## $\sum_{i=1}^{n}i^{3}=[\frac{n(n+1)}{2}]^{2}$

## 代码如下:

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
#define lt (o<<1)
#define rt ((o<<1)|1)

typedef long long ll;
typedef struct node{
    ll min,max,sum,sum2,sum3;
    //sum为区间和，sum2为区间平方和，sum3为区间立方和
}node;

const ll mod=1000007,INF=100000000000000000;
node t[2000010];
ll n,m,a[500010],opt,k1,k2,kmin,kmax,ks,ks2,ks3;

inline ll read(){
    ll num=0,k=1; char c=getchar();
    while(c>'9' || c<'0') k=(c=='-')?0:k,c=getchar();
    while(c>='0' && c<='9') num=num*10+c-'0',c=getchar();
    return k?num:-num;
}

void pushup(ll o){
    t[o].sum=t[lt].sum+t[rt].sum; t[o].sum2=(t[lt].sum2+t[rt].sum2)%mod; t[o].sum3=(t[lt].sum3+t[rt].sum3)%mod;
    t[o].min=min(t[lt].min,t[rt].min); t[o].max=max(t[lt].max,t[rt].max);
}

void build(ll o,ll l,ll r){
    if(l==r){
        t[o].min=t[o].max=t[o].sum=a[l];
        t[o].sum2=a[l]*a[l]%mod; t[o].sum3=t[o].sum2*a[l]%mod;
        return;
    }
    ll mid=(l+r)>>1;
    build(lt,l,mid); build(rt,mid+1,r);
    pushup(o);
}

void update(ll o,ll l,ll r,ll q,ll x){
    if(l==r){
        t[o].min=t[o].max=t[o].sum=x;
        t[o].sum2=x*x%mod; t[o].sum3=t[o].sum2*x%mod;
        return;
    }
    ll mid=(l+r)>>1;
    if(q<=mid) update(lt,l,mid,q,x);
    else update(rt,mid+1,r,q,x);
    pushup(o);
}

void query(ll o,ll l,ll r,ll ql,ll qr){
	if(r<ql || l>qr) return;
    if(ql<=l && qr>=r){
        kmin=min(kmin,t[o].min); kmax=max(kmax,t[o].max);
        ks+=t[o].sum; ks2=(ks2+t[o].sum2)%mod; ks3=(ks3+t[o].sum3)%mod;
        return;
    }
    ll mid=(l+r)>>1;
    if(l<=mid) query(lt,l,mid,ql,qr);
    if(r>=mid+1) query(rt,mid+1,r,ql,qr);
}

ll qs2(ll x) {return x*(x+1)%mod*(2*x+1)%mod;} //1^2+2^2+..+n^2的和，因为模意义下除法很麻烦把除法移到了等式的另一边

ll qs3(ll x) {return x*(x+1)%mod*x%mod*(x+1)%mod;} //1^3+2^3+..+n^3的和

int main(){
    n=read(); m=read();
    for(int i=1;i<=n;i++) a[i]=read();
    build(1,1,n);
    while(m--){
        opt=read(); k1=read(); k2=read();
        if(opt==1) update(1,1,n,k1,k2);
        if(opt==2){
            kmin=INF; kmax=-INF; ks=ks2=ks3=0;
            query(1,1,n,k1,k2);
            if(kmax-kmin!=k2-k1) printf("yuanxing\n");
            else if(ks!=(kmax+kmin)*(kmax-kmin+1)/2) printf("yuanxing\n");
            else if(ks2*6%mod!=((qs2(kmax)-qs2(kmin-1))%mod+mod)%mod) printf("yuanxing\n");
            else if(ks3*4%mod!=((qs3(kmax)-qs3(kmin-1))%mod+mod)%mod) printf("yuanxing\n");
            else printf("damushen\n");
        }
    }
    return 0;
}

```

---

## 作者：t0vd (赞：1)

想了一种神奇的做法。

把序列的每个数 $a_i$ 表示为一个项 $x^{a_i}$，对于一段区间 $[l,r]$，它的区间和 $\sum_{i=l}^rx^{a_i}$ 是一个多项式。

设区间 $[l,r]$ 的最小值为 $v$（即 $v=\min\{a_i|l\le i\le r\}$），则区间 $[l,r]$ 满足条件当且仅当区间和 $\sum_{i=l}^rx^{a_i}$ 与多项式 $x^m\cdot\sum_{i=0}^{r-l}x^i$ 相等。

判断两个多项式是否相等有一种经典的随机化算法：随机质数 $x$ 和 $p$，在模 $p$ 意义下把 $x$ 代入算出多项式的值模 $p$ 的结果，判断是否相等，多次随机提高正确率（一般随机两次基本上没问题了？）。

我的实现方法是先随机两个 $10^8$ 级别的质数 $x_1,x_2$ 和两个 $10^9$ 级别的质数 $p_1,p_2$，$x_1<p_1$，$x_2<p_2$，预处理 $x_1,x_2$ 的幂以及幂的前缀和（模 $p_1,p_2$ 意义下），然后用线段树维护区间最小值、$\sum_{i=l}^rx_1^{a_i}\bmod p_1$ 和 $\sum_{i=l}^rx_2^{a_i}\bmod p_2$ 的值，询问时查询区间的这两个和判断对不对即可。

每次询问复杂度 $O(\log n)$，正确性的话……感觉很靠谱，不知道能不能卡掉。


---

## 作者：Holy_Push (赞：1)

先规定：$max(l,r)$表示$l$到$r$中$a[i]$的最大值，$min,sum,sqr,cub$同理，分别表示最小值、区间和、区间平方和、区间立方和。

显然如果题目能保证$a[i]$任意时刻互不相同的话，那很容易想到，如果能重排为连续的一段的化，就要满足$max(l,r)-min(l,r)=r-l+1$

可惜本题并没有规定$a[i]$互不相同，所以单纯这样的判断是不够的。

所以我们加上二重保险：**区间和**。

如果$l$~$r$能重排为连续的一段的话，那么$l$~$r$的区间和应该为$\frac{(max+min)(max-min+1)}{2}$。

然而这样很容易就会被卡。比如$1,3,3,3,5$。

所以我们加上三重保险：**区间平方和**。

如果$l$~$r$能重排为连续的一段的话，那么$l$~$r$的区间和应该为$\sum_{i=l}^ri^2$。

然而听说这样还是会被卡，所以我们加上四重保险：**区间立方和**

如果$l$~$r$能重排为连续的一段的话，那么$l$~$r$的区间和应该为$\sum_{i=l}^ri^3$。

有这样四重保险，要卡也很难卡了吧。

所以我们只要维护区间最大值最小值、区间和、区间平方和、区间立方和三样东西。考虑到区间平方和和区间立方和会很大，所以我们可以找一个模数（比如$1e9+7$），比较它们取模后的结果是否一样即可。

最后给出一些公式：

$\sum_{i=1}^ni^2=\frac{1}{6}n(n+1)(2n+1)$

$\sum_{i=1}^ni^3=\frac{n^2(n+1)^2}{4}$

然后这道题就做完啦！

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int mo=1e9+7,N=500001;

int n,m,a[N];

void read(int &x)
{
	x=0;char s=getchar();
	while (!isdigit(s)) s=getchar();
	while (isdigit(s)) {x=(x<<1)+(x<<3)+s-'0';s=getchar();}
}

struct node
{
	int min,max,sum,sqr,cub;
} t[N*6];

int ksm(int x,int y)
{
	if (!y) return 1;
	ll d=ksm(x,y/2);
	if (y&1) return (ll)d*d%mo*x%mo;
	return (ll)d*d%mo;
}

int inv2=ksm(2,mo-2),inv6=ksm(6,mo-2);

void build(int i,int l,int r)
{
	if (l==r)
	{
		t[i].min=t[i].max=t[i].sum=a[l];
		t[i].sqr=(ll)a[l]*a[l]%mo;t[i].cub=(ll)a[l]*a[l]%mo*a[l]%mo;
		return;
	}
	int mid=(l+r)>>1,ls=i<<1,rs=ls|1;
	build(ls,l,mid);build(rs,mid+1,r);
	t[i].min=min(t[ls].min,t[rs].min);t[i].max=max(t[ls].max,t[rs].max);
	t[i].sum=(t[ls].sum+t[rs].sum)%mo;t[i].sqr=(t[ls].sqr+t[rs].sqr)%mo;t[i].cub=(t[ls].cub+t[rs].cub)%mo;
}

void update(int i,int l,int r,int x,int y)
{
	if (l==r)
	{
		t[i].min=t[i].max=t[i].sum=y;
		t[i].sqr=(ll)y*y%mo;t[i].cub=(ll)y*y%mo*y%mo;
		return;
	}
	int mid=(l+r)>>1,ls=i<<1,rs=ls|1;
	if (mid>=x) update(ls,l,mid,x,y); else update(rs,mid+1,r,x,y);
	t[i].min=min(t[ls].min,t[rs].min);t[i].max=max(t[ls].max,t[rs].max);
	t[i].sum=(t[ls].sum+t[rs].sum)%mo;t[i].sqr=(t[ls].sqr+t[rs].sqr)%mo;t[i].cub=(t[ls].cub+t[rs].cub)%mo;
}

int sqqz(int x)
{
	return (ll)x*(x+1)%mo*(2*x+1)%mo*inv6%mo;
}

int sqr(int x) {return (ll)x*x%mo;}

int cuqz(int x)
{
	return sqr((ll)x*(x+1)%mo*inv2%mo);
}

int getmax(int i,int l,int r,int x,int y)
{
	if (l>=x&&r<=y) return t[i].max;
	int mid=(l+r)>>1;
	if (mid>=y) return getmax(i<<1,l,mid,x,y);
	if (mid<x) return getmax(i<<1|1,mid+1,r,x,y);
	return max(getmax(i<<1,l,mid,x,y),getmax(i<<1|1,mid+1,r,x,y));
}

int getmin(int i,int l,int r,int x,int y)
{
	if (l>=x&&r<=y) return t[i].min;
	int mid=(l+r)>>1;
	if (mid>=y) return getmin(i<<1,l,mid,x,y);
	if (mid<x) return getmin(i<<1|1,mid+1,r,x,y);
	return min(getmin(i<<1,l,mid,x,y),getmin(i<<1|1,mid+1,r,x,y));
}

int getsum(int i,int l,int r,int x,int y)
{
	if (l>=x&&r<=y) return t[i].sum;
	int mid=(l+r)>>1;
	if (mid>=y) return getsum(i<<1,l,mid,x,y);
	if (mid<x) return getsum(i<<1|1,mid+1,r,x,y);
	return (getsum(i<<1,l,mid,x,y)+getsum(i<<1|1,mid+1,r,x,y))%mo;
}

int getsqr(int i,int l,int r,int x,int y)
{
	if (l>=x&&r<=y) return t[i].sqr;
	int mid=(l+r)>>1;
	if (mid>=y) return getsqr(i<<1,l,mid,x,y);
	if (mid<x) return getsqr(i<<1|1,mid+1,r,x,y);
	return (getsqr(i<<1,l,mid,x,y)+getsqr(i<<1|1,mid+1,r,x,y))%mo;
}

int getcub(int i,int l,int r,int x,int y)
{
	if (l>=x&&r<=y) return t[i].cub;
	int mid=(l+r)>>1;
	if (mid>=y) return getcub(i<<1,l,mid,x,y);
	if (mid<x) return getcub(i<<1|1,mid+1,r,x,y);
	return (getcub(i<<1,l,mid,x,y)+getcub(i<<1|1,mid+1,r,x,y))%mo;
}

int main()
{
	read(n);read(m);
	for (int i=1;i<=n;i++) read(a[i]);
	build(1,1,n);
	for (int i=1;i<=m;i++)
	{
		int opt,x,y;read(opt),read(x),read(y);
		if (opt==1) update(1,1,n,x,y);
		if (opt==2) 
		{
			int r=getmax(1,1,n,x,y),l=getmin(1,1,n,x,y),sm=getsum(1,1,n,x,y),sq=getsqr(1,1,n,x,y),cu=getcub(1,1,n,x,y);
			if (r-l!=y-x) {puts("yuanxing");continue;}
			if (sm!=(ll)(l+r)*(r-l+1)%mo*inv2%mo) {puts("yuanxing");continue;}
			if (sq!=(sqqz(r)-sqqz(l-1)+mo)%mo) {puts("yuanxing");continue;}
			if (cu!=(cuqz(r)-cuqz(l-1)+mo)%mo) {puts("yuanxing");continue;}
			puts("damushen");
		}
	}
}
```



---


# 【模板】可持久化线段树 1（可持久化数组）

## 题目背景

**UPDATE : 最后一个点时间空间已经放大**

2021.9.18 增添一组 hack 数据 by @panyf

标题即题意

有了可持久化数组，便可以实现很多衍生的可持久化功能（例如：可持久化并查集）

## 题目描述

如题，你需要维护这样的一个长度为 $ N $ 的数组，支持如下两种操作：


1. 在某个历史版本上修改某一个位置上的值。

2. 访问某个历史版本上的某一位置的值。


此外，每进行一次操作，就会生成一个新的版本。版本编号即为当前操作的编号（从 $1$ 开始编号，版本 $0$ 表示初始状态数组）。

**对于操作 $2$，即为生成一个完全一样的版本，不作任何改动**。即，询问生成的版本是询问所访问的那个版本的复制。

## 说明/提示

### 数据规模

对于 $30\%$ 的数据，$ 1 \leq N, M \leq {10}^3 $。

对于 $50\%$ 的数据，$ 1 \leq N, M \leq {10}^4 $。

对于 $70\%$ 的数据，$ 1 \leq N, M \leq {10}^5 $。

对于 $100\%$ 的数据：

- $ 1 \leq N, M \leq {10}^6$；
- $1 \leq p \leq N$；
- 设当前是第 $x$ 次操作，$0 \leq v < x$；
- $-{10}^9 \leq a_i,c  \leq {10}^9$。

### 样例说明

所有操作结束后，总共生成了 $11$ 个版本，编号为 $0 \sim 10$，依次为：

版本 $0$：`59 46 14 87 41`，

版本 $1$：`59 46 14 87 41`，

版本 $2$：`14 46 14 87 41`，

版本 $3$：`57 46 14 87 41`，

版本 $4$：`88 46 14 87 41`，

版本 $5$：`88 46 14 87 41`，

版本 $6$：`59 46 14 87 41`，

版本 $7$：`59 46 14 87 41`，

版本 $8$：`88 46 14 87 41`，

版本 $9$：`14 46 14 87 41`，

版本 $10$：`59 46 14 87 91`。

## 样例 #1

### 输入

```
5 10
59 46 14 87 41
0 2 1
0 1 1 14
0 1 1 57
0 1 1 88
4 2 4
0 2 5
0 2 4
4 2 1
2 2 2
1 1 5 91```

### 输出

```
59
87
41
87
88
46```

# 题解

## 作者：hyfhaha (赞：595)

本篇blog主要是给自己（大家）看的。

感谢[longlongzhu123](https://www.luogu.org/space/show?uid=57525)奆佬（此人初二LCT）的指点，使本蒟蒻可以快速开始主席树入门。

# what is 主席树？
$ \ \ \ \ \ \ \ $主席树这个名字只不过是OIer们在思考政(zhe)治(xue)的时候发明的好(du)听(liu)的名字。其实主席树的大名叫“可持久化线段树”，一听这名字就知道主席树很毒瘤，所以他的发明者叫黄嘉泰（hjt***(什么鬼啊?)）。

### 分步理解“可持久化线段树”
$ \ \ \ \ \ \ \ $首先我们先来理解人尽皆知的小名“主席树”，我们可以先看到“主席”这两个字，嗯，很好，很霸气，读起来朗朗上口，所以我们可以知道主席树是一个很**霸气**的东西，~~以上扯淡~~。再来看“树”，从这个字我们可以看出主席树的本质是一棵树，那是一棵什么树，结什么果呢，下面看主席树的大名“可持久化线段树”。

$ \ \ \ \ \ \ \ $看“可持久化”这四个字，很好理解，主席树十分**持久**，因为它可持久化。那什么叫持久呢，“可持久化”定义：可以支持回退，访问之前版本的数据结构；支持回退操作的意思就是可以访问未经过其他操作的版本，也就是说返回到了以前的版本。那么我们继续看“线段树”这几个字眼，十分熟悉！相信大家肯定学过线段树，如果没学过$\color{red} \large \text{线段树}$的话，那就可以跳过这篇blog了。我们可以知道主席树是基于**线段树**的一种**数据结构**WOW。

$ \ \ \ \ \ \ \ $综上所述，主席树是一种~~霸气的~~，持久的，基于线段树的**数据结构**。

------------
## 主席树基本原理
$ \ \ \ \ \ \ \ $前文说了，线段树与主席树的本质是一样的，只不过主席树可持久化，那么难点就在于怎么支持可持久化。

$ \ \ \ \ \ \ \ $我们想要支持回退操作就可以对每一次修改操作都进行一次复制，将未进行操作的线段树版本进行复制，再对原线段树版本进行修改，那么我们就可以访问到旧版本的线段树了。不过现在问题来了，这样的空间复杂度将会乘上一个m，变成O(n*m)。不用说，肯定会陷入mle中不可自拔。

$ \ \ \ \ \ \ \ $那我们来分析一下单点修改的线段树：![主席树1](https://cdn.luogu.com.cn/upload/pic/46128.png)

$ \ \ \ \ \ \ \ $我们发现只有橙颜色经过的结点才被修改过。那么我们就可以思考，我们可不可以只对这些节点进行修改呢？答案当然是可以的，主席树的基本思想就是只对进行修改的结点进行复制。那么主席树是长什么样子的呢，下面一起来看一下吧。![主席树2](https://cdn.luogu.com.cn/upload/pic/46147.png)

$ \ \ \ \ \ \ \ $看着怎么恶心的图，相信大家还是可以发现这个图中主席树的一些性质：

1、每一次修改增加的节点个数为log(n)。

2、增加的非叶子结点会连向一个是其他版本的节点，一个是连向新节点。

3、主席树有很多根……

4、对于每一个根都可以构成一棵完整的线段树。

5、每一个节点都有可能有不只一个爸爸……

$ \ \ \ \ \ \ \ $所以我们可以知道主席树只会对部分节点进行复制，并且每一次复制的节点个数是log(n)。我们每一次想询问一个版本的线段树，就可以在那个版本的根构成的线段树中询问。

但同时也延伸出许多问题：

1、怎么构建新节点？怎么给新节点编号？怎么连边？

2、怎么访问子节点？

3、怎么存根？

$ \ \ \ \ \ \ \ $很明显这些问题在线段树中完全不会出现，我们可以感觉到主席树在建树的代码中会和线段树不同。

现在给出刚才问题的答案：

1、直接开一块内存池存新节点。编号为此时总节点数个数+1。开结构体存子节点编号；线段树建什么边，一指了事。

2、访问子节点编号，不是像线段树一样乘2或乘2+1，而是在结构体存子节点编号。

3、另外开个数组存。

------------

代码主要和线段树差不多，下面就看代码吧。

# 代码  P3919 【模板】可持久化数组

所以我们定义一个节点要存三个信息：左儿子，右儿子，权值
```cpp
struct kkk{
	int l,r,val;
}tree[maxn];
```
新建节点：
```cpp
int clone(int node){
	top++;
	tree[top]=tree[node];//全部信息都传到新节点
	return top;
}
```
建树其实就是新建节点的过程：
```cpp
int maketree(int node,int begin,int end){
	node=++top;
	if(begin==end){
		tree[node].val=a[begin];
		return top;
	}
	int mid=(begin+end)>>1;
	tree[node].l=maketree(tree[node].l,begin,mid);
	tree[node].r=maketree(tree[node].r,mid+1,end);
	return node;
}
```
更新和线段树很像：
```cpp
int update(int node,int begin,int end,int x,int val){
	node=clone(node);	//更新就要新建节点 
	if(begin==end){
		tree[node].val=val;
	}else{
		int mid=(begin+end)>>1;
		if(x<=mid)
			tree[node].l=update(tree[node].l,begin,mid,x,val);	//访问左子树 
		else
			tree[node].r=update(tree[node].r,mid+1,end,x,val);	//访问右子树 
	}
	return node;
}
```
询问也一样：
```cpp
int query(int node,int begin,int end,int x){
	if(begin==end){
		return tree[node].val;
	}else{
		int mid=(begin+end)>>1;
		if(x<=mid)
			return query(tree[node].l,begin,mid,x);	//访问左子树 
		else
			return query(tree[node].r,mid+1,end,x);	//访问右子树 
	}
}
```
那么主席树的操作部分就写完了QwQ

再来看主程序，里面看根怎么存储：
```cpp
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	root[0]=maketree(0,1,n);	//root[i]为i版本的根编号，刚开始编号为0 
	for(int i=1;i<=m;i++){
		scanf("%d%d%d",&rt,&mode,&x);
		if(mode==1){
			scanf("%d",&y);
			root[i]=update(root[rt],1,n,x,y);	//保存版本 
		}
		else{
			printf("%d\n",query(root[rt],1,n,x));	//输出 
			root[i]=root[rt];					//新建版本 
		}
	}
}
```
那么这道题就写完了。~~（其实我觉得一看图就懂了，代码什么的都是假的）~~

---

## 作者：pigeonN (赞：37)

听说stl拓展的rope过不了，那我们就手撸一个吧（笑

（这个rope是没有再平衡功能的版本，不过也能过

我们先看看基本rope的节点结构
```cpp
template<typename T> class RopeNode
{
    friend class Rope<T>;
private:
    RopeNode<T>() = default;
    RopeNode<T>(T t);
    RopeNode<T>(vector<T> & s);
    int Height = 0;//用于平衡操作
                   //不过基于本题实践，不平衡也是可以的
                   //所以下面不会包含再平衡操作
    int Size = 0;
    int Begin = 0;//维护的串在Data中的开始下标
                  //只在叶子节点中可能不为0
    RopeNode<T>* Lson = nullptr;
    RopeNode<T>* Rson = nullptr;
    vector<T>* Data = nullptr;//只在叶子节点不为空指针
};
```

可以看出rope是一颗二叉树，并且维护串的大小以及节点高度。

我们再来看看rope所支持的基本操作

1，Connect 返回将两个rope连接后的结果，不改变原来的两个串，我们保证这个操作花费常数时间，接下来看代码。
```cpp
template<typename T>
RopeNode<T> * Rope<T>::Connect(RopeNode<T> * Left, RopeNode<T> * Right)
{
    if (Left == nullptr) return Right;
    if (Right == nullptr) return Left;
    if (GetHeight(Left->Lson) > GetHeight(Left->Rson) && GetHeight(Left->Lson) > GetHeight(Right))
    {
        return UncheckConnect(Left->Lson, UncheckConnect(Left->Rson, Right));
    }
    if (GetHeight(Right->Rson) > GetHeight(Right->Lson) && GetHeight(Right->Rson) > GetHeight(Left))
    {
        return UncheckConnect(UncheckConnect(Left, Right->Lson), Right->Rson);
    }
    //上述两个if是检查是否能将其中一个串放到另一个串的子树中，并不增加树的高度
    return UncheckConnect(Left, Right);
}

```
```cpp
template<typename T>
RopeNode<T> * Rope<T>::UncheckConnect(RopeNode<T> * Left, RopeNode<T> * Right)
{
    RopeNode<T>* ConnectNode = new RopeNode<T>();
    ConnectNode->Lson = Left;
    ConnectNode->Rson = Right;
    ConnectNode->Height = max(GetHeight(Left), GetHeight(Right)) + 1;//高度信息可以不维护，不过为了说明这玩意是可以进行平衡的，我就暂且保留这部分了
    ConnectNode->Size = GetSize(Left) + GetSize(Right);
    MemoryPool.push_back(ConnectNode);
    return ConnectNode;
}
```

2 Substring 返回一个子串，不改变原来的串，这个操作将花费O（height）的时间，看代码。
```cpp
template<typename T>
RopeNode<T> * Rope<T>::Substring(RopeNode<T> * R, int Start, int Len)
{
    if (R == nullptr) return R;
    if (Start <= 0 && Len >= GetSize(R)) return R;
    if (R->Data != nullptr)
    {
        RopeNode<T>* SubNode = new RopeNode<T>(*R);
        SubNode->Begin = R->Begin + (Start > 0 ? Start : 0);
        SubNode->Size = min(R->Size, Len);
        return SubNode;
    }
    RopeNode<T>* Left, *Right;
    if (Start + Len <= GetSize(R->Lson))return Substring(R->Lson, Start, Len);
    if (Start >= GetSize(R->Lson)) return Substring(R->Rson, Start - GetSize(R->Lson), Len);
    Left = Substring(R->Lson, Start, GetSize(R->Lson) - Start);
    Right = Substring(R->Rson, 0, Len - (GetSize(R->Lson) - Start));
    return Connect(Left, Right);
}
```
这个操作就很容易看懂了，不多加说明。

有了两个基本操作之后我们就可以编写我们需要的Change和Fetch操作了

Change操作
```cpp
template<typename T>
RopeNode<T>* Rope<T>::Change(RopeNode<T>* R, int Index, T t)
{
    if (Index < 0 || Index >= GetSize(R)) return R;
    RopeNode<T>* Left = nullptr, *Right = nullptr;
    if (Index > 0) Left = Substring(R, 0, Index);
    if (Index < GetSize(R) - 1) Right = Substring(R, Index + 1, GetSize(R) - Index - 1);
    RopeNode<T>* MidRope = new RopeNode<T>(t);
    MemoryPool.push_back(MidRope);
    return Connect(Left, Connect(MidRope, Right));
}
```
Fetch操作

```cpp
template<typename T>
T Rope<T>::Fetch(RopeNode<T> * R, int Index)
{
    if (R->Data != nullptr) return (*(R->Data))[R->Begin + Index];
    if (Index >= GetSize(R->Lson))
    {
        return Fetch(R->Rson, Index - GetSize(R->Lson));
    }
    else return Fetch(R->Lson, Index);
}
```

可以看出rope的所有操作都不会改变原本的串，这是一个函数式的数据结构。

至于如何查询对应版本则和其他做法一样，保存对应版本的根即可。

以下是完整AC代码

```cpp
#define _CRT_SECURE_NO_WARNINGS
#pragma once
#include<vector>
#include<algorithm>
#include<stdio.h>
using std::vector;
template<typename T> class Rope;
template<typename T> class RopeNode
{
    friend class Rope<T>;
private:
    RopeNode<T>() = default;
    RopeNode<T>(T t);
    RopeNode<T>(vector<T> & s);
    int Height = 0;
    int Size = 0;
    int Begin = 0;
    RopeNode<T>* Lson = nullptr;
    RopeNode<T>* Rson = nullptr;
    vector<T>* Data = nullptr;
};
template<typename T> class Rope
{
public:
    void MakeEmpty();
    RopeNode<T>* Init(vector<T>& v);
    T Fetch(RopeNode<T>* R, int Index);
    RopeNode<T>* Change(RopeNode<T>* R, int Index, T t);
    inline int GetHeight(RopeNode<T>* R);
    inline int GetSize(RopeNode<T>*R);
    RopeNode<T>* Connect(RopeNode<T>* Left, RopeNode<T>* Right);
    RopeNode<T>* UncheckConnect(RopeNode<T>* Left, RopeNode<T>* Right);
    RopeNode<T>* Substring(RopeNode<T>* R, int Start, int Len);
    vector<RopeNode<T>*>  MemoryPool;
};

#define max(x,y) (x)>(y)?(x):(y)
#define min(x,y) (x)<(y)?(x):(y)
template<typename T>
RopeNode<T>::RopeNode(T t)
    :Size(1)
{
    Data = new vector<T>{ t };
}
template<typename T>
RopeNode<T>::RopeNode(vector<T> & s)
    :Size(s.size())
{
    Data = new vector<T>(s);
}
template<typename T>
void Rope<T>::MakeEmpty()
{
    for (auto i : MemoryPool)
    {
        if (i != nullptr) delete i->Data;
        delete i;
    }
    MemoryPool.clear();
}

template<typename T>
RopeNode<T>* Rope<T>::Init(vector<T>& v)
{
    MakeEmpty();
    RopeNode<T>* R = new RopeNode<T>(v);
    MemoryPool.push_back(R);
    return R;
}

template<typename T>
inline int Rope<T>::GetHeight(RopeNode<T> * R)
{
    return R ? R->Height : -1;
}

template<typename T>
inline int Rope<T>::GetSize(RopeNode<T> * R)
{
    return R ? R->Size : 0;
}

template<typename T>
RopeNode<T> * Rope<T>::Connect(RopeNode<T> * Left, RopeNode<T> * Right)
{
    if (Left == nullptr) return Right;
    if (Right == nullptr) return Left;
    if (GetHeight(Left->Lson) > GetHeight(Left->Rson) && GetHeight(Left->Lson) > GetHeight(Right))
    {
        return UncheckConnect(Left->Lson, UncheckConnect(Left->Rson, Right));
    }
    if (GetHeight(Right->Rson) > GetHeight(Right->Lson) && GetHeight(Right->Rson) > GetHeight(Left))
    {
        return UncheckConnect(UncheckConnect(Left, Right->Lson), Right->Rson);
    }
    return UncheckConnect(Left, Right);
}

template<typename T>
T Rope<T>::Fetch(RopeNode<T> * R, int Index)
{
    if (R->Data != nullptr) return (*(R->Data))[R->Begin + Index];
    if (Index >= GetSize(R->Lson))
    {
        return Fetch(R->Rson, Index - GetSize(R->Lson));
    }
    else return Fetch(R->Lson, Index);
}

template<typename T>
RopeNode<T>* Rope<T>::Change(RopeNode<T>* R, int Index, T t)
{
    if (Index < 0 || Index >= GetSize(R)) return R;
    RopeNode<T>* Left = nullptr, *Right = nullptr;
    if (Index > 0) Left = Substring(R, 0, Index);
    if (Index < GetSize(R) - 1) Right = Substring(R, Index + 1, GetSize(R) - Index - 1);
    RopeNode<T>* MidRope = new RopeNode<T>(t);
    MemoryPool.push_back(MidRope);
    return Connect(Left, Connect(MidRope, Right));
}

template<typename T>
RopeNode<T> * Rope<T>::UncheckConnect(RopeNode<T> * Left, RopeNode<T> * Right)
{
    RopeNode<T>* ConnectNode = new RopeNode<T>();
    ConnectNode->Lson = Left;
    ConnectNode->Rson = Right;
    ConnectNode->Height = max(GetHeight(Left), GetHeight(Right)) + 1;
    ConnectNode->Size = GetSize(Left) + GetSize(Right);
    MemoryPool.push_back(ConnectNode);
    return ConnectNode;
}

template<typename T>
RopeNode<T> * Rope<T>::Substring(RopeNode<T> * R, int Start, int Len)
{
    if (R == nullptr) return R;
    if (Start <= 0 && Len >= GetSize(R)) return R;
    if (R->Data != nullptr)
    {
        RopeNode<T>* SubNode = new RopeNode<T>(*R);
        SubNode->Begin = R->Begin + (Start > 0 ? Start : 0);
        SubNode->Size = min(R->Size, Len);
        return SubNode;
    }
    RopeNode<T>* Left, *Right;
    if (Start + Len <= GetSize(R->Lson))return Substring(R->Lson, Start, Len);
    if (Start >= GetSize(R->Lson)) return Substring(R->Rson, Start - GetSize(R->Lson), Len);
    Left = Substring(R->Lson, Start, GetSize(R->Lson) - Start);
    Right = Substring(R->Rson, 0, Len - (GetSize(R->Lson) - Start));
    return Connect(Left, Right);
}
Rope<int> Array;
vector<RopeNode<int>*> Root;
int main(void)
{
    int n, m, i;
    vector<int> init;
    scanf("%d %d", &n, &m);
    for (i = 0; i < n; ++i)
    {
        int t;
        scanf("%d", &t);
        init.push_back(t);
    }
    Root.push_back(Array.Init(init));
    for (i = 0; i < m; ++i)
    {
        int ver, opt, loc, val;
        scanf("%d %d %d", &ver, &opt, &loc);
        if (opt == 2)
        {
            printf("%d\n", Array.Fetch(Root[ver], loc-1));
            Root.push_back(Root[ver]);
        }
        else
        {
            scanf("%d", &val);
            Root.push_back(Array.Change(Root[ver], loc-1, val));
        }

    }
    Array.MakeEmpty();
}
```




---

## 作者：Fading (赞：30)

可持久化数组，可以访问历史版本的数组。

我们考虑使用可持久化数据结构——主席树，如果不理解可以左转模板。

主席树对数组的每一个前缀建树。我们都知道其中$root$数组表示前缀$1..i$主席树的根。
那我们现在换一种方式建树，我们对每一次操作带来的版本建线段树，维护数组的权值。

什么意思呢？看图(我们设这个数组为a={1,2,3,4})：

![](https://cdn.luogu.com.cn/upload/pic/29608.png)

我们发现，这棵线段树叶子节点的权值就是它所对应数组内数的权值，这和普通线段树是类似的。

### 但是我们令非叶子节点的权值为空。这只是为了方便二分查找而设置的。

所以我们在查询数组内数的值时，直接单点询问就可以了，时间复杂度$O(logN)$

```
int query(int rt,int l,int r,int kkk){
    if (l==r) return tree[rt].sum;
    int mid=(l+r)>>1;
    if (kkk<=mid) return query(tree[rt].l,l,mid,kkk);
    else return query(tree[rt].r,mid+1,r,kkk);
}
主程序内：
query(树根,1,n,访问数组的下标);

```
我们令初始状态为第$0$个状态，这个树根即为$root[0]$。
如果我们把$a[4]$改为$5$呢？我们新建一个根$root[1]$

和主席树一样，数组$a[1]$、$a[2]$没有变化，直接连接，和主席树一样。

![](https://cdn.luogu.com.cn/upload/pic/29609.png)

创造右节点。

![](https://cdn.luogu.com.cn/upload/pic/29610.png)

然后$a[3]$也没有变化，连接

![](https://cdn.luogu.com.cn/upload/pic/29611.png)

随后，创造新的叶子节点($a[4]=5$)

代码和主席树神似。
```
void build(int &rt,int l,int r){
    rt=++cnt;
    if(l==r){tree[rt].sum=a[l];return;}
    int mid=(l+r)>>1;
    build(tree[rt].l,l,mid);build(tree[rt].r,mid+1,r);
}//初始建设
void update(int num,int &rt,int l,int r){
    tree[++cnt]=tree[rt]; rt=cnt; 
    int mid=(l+r)/2;
    if (l==r){tree[rt].sum=aaaa; return;}
    if (num<=mid) update(num,tree[rt].l,l,mid);
    else update(num,tree[rt].r,mid+1,r);
}//更新
```
时间复杂度$O(logN)$，我们发现，这次修改我们创造了一个新树根($root[1]$),这恰好表示了第一次修改后的状态。

这么一来，回到某一个状态，就很简单了，若要访问某一个状态i，访问或更新时直接使用$root[i]$即可。

代码如下：
```
#include<bits/stdc++.h>
#define res register int 
#define ll long long
#define jsz inline
using namespace std;
int cnt,n,a[1000660],m,root[1000660],aaaa;
jsz int read(){
    int x=0,f=1;char ch=getchar();
    while (!isdigit(ch)){
        if (ch=='-')f=-1;
        ch=getchar();
    }
    while (isdigit(ch)){
        x=x*10+ch-48;
        ch=getchar();
    }
    return x*f;
}
struct ZXT{
    int l,r,sum;
}tree[20006660];
jsz void build(int &rt,int l,int r){
    rt=++cnt;
    if(l==r){tree[rt].sum=a[l];return;}
    int mid=(l+r)>>1;
    build(tree[rt].l,l,mid);build(tree[rt].r,mid+1,r);
}
jsz void update(int num,int &rt,int l,int r){
    tree[++cnt]=tree[rt]; rt=cnt; 
    int mid=(l+r)/2;
    if (l==r){tree[rt].sum=aaaa; return;}
    if (num<=mid) update(num,tree[rt].l,l,mid);
    else update(num,tree[rt].r,mid+1,r);
}
jsz int query(int rt,int l,int r,int kkk){
    if (l==r) return tree[rt].sum;
    int mid=(l+r)>>1;
    if (kkk<=mid) return query(tree[rt].l,l,mid,kkk);
    else return query(tree[rt].r,mid+1,r,kkk);
}
int main(){
    n=read();m=read();
    for (res i=1;i<=n;i++) a[i]=read();
    build(root[0],1,n);
    for (res i=1;i<=m;i++){
        int xxxx=read();int yyyy=read();
        if (yyyy==1){
            int zzzz=read();aaaa=read();
            root[i]=root[xxxx];
            update(zzzz,root[i],1,n);
        }else{
            int zzzz=read();
            printf("%d\n",query(root[xxxx],1,n,zzzz));
            root[i]=root[xxxx];
        }
    }
}
```

---

## 作者：UhhhQQQU (赞：13)

 _**前置知识：线段树**_ 

可持久化数组可以用可持久化线段树或者可持久化平衡树实现，在本篇题解中，~~因为本蒟蒻只会可持久化线段树，~~ 我们先来研究一下如何使用可持久化线段树实现可持久化数组。

>引入

首先，我们对这一题的第一想法是对每一个历史版本新建一个数组~~别注意题目标题，那不重要~~。但是，题目庞大的数据范围会使它MLE，那么，我们就需要一种数据结构来优化空间，它就是——可持久化线段树。

>原理

可持久化线段树，就是把题目中的数据，放入线段树的**叶子节点**中操作。等等，放在线段树里？？？这不是更会MLE吗？

本蒟蒻的回答：



其实是不会的。

原理是什么呢？其实，我们对于每一次修改操作，并不用多新建一个线段树，而只用新建一条从根节点到链就可以了。只用新建一条链的原因是因为我们的线段树是以叶子节点储存数据的，我们要以从根节点到这一个叶子节点上所有节点的数据新建出一条链。（如果不理解的话就联系一下线段树的修改操作）（注意：可持久化线段树是新建节点，而不是修改节点数据，因为存储历史版本）

不理解的话可以看一下下图。
![题解](https://cdn.luogu.com.cn/upload/pic/56149.png)

可持久化线段树在每一次新建操作只用新建O(logn)个节点，所以它比朴素的算法在空间上要优化多了！

>代码

其实这里还有一个关于历史版本的数组rt[]，但非常简单，就不用多说了。

```
#include<cstdio>
int n,m,rt[1000010],cnt;//cnt记录版本的序号 
struct tree{
	int ls,rs,value;
}t[21000010];
inline void read(int &x,char ch=getchar(),bool f=0)
{
	for(x=0;ch>'9'||ch<'0';f=ch=='-',ch=getchar());
	for(;ch>='0'&&ch<='9';x=(x<<3)+(x<<1)+(ch^48),ch=getchar());
	(f)&&(x=-x);
}
void build(int &point,int l,int r)
{
	point=++cnt;
	if(l==r)
	{
		read(t[point].value);
		return;
	}
	int mid=(l+r)>>1;
	build(t[point].ls,l,mid);
	build(t[point].rs,mid+1,r);
}
void change(int &point,int last,int l,int r,int pos,int value)
{
	point=++cnt,t[point]=t[last];
	if(l==r)
	{
		t[point].value=value;
		return;
	}
	int mid=(l+r)>>1;
	if(pos<=mid)change(t[point].ls,t[last].ls,l,mid,pos,value);
	else change(t[point].rs,t[last].rs,mid+1,r,pos,value);
}
int que(int point,int l,int r,int loc)
{
	if(l==r)return t[point].value;
	int mid=(l+r)>>1;
	if(loc<=mid)return que(t[point].ls,l,mid,loc);
	else return que(t[point].rs,mid+1,r,loc);
}
int main()
{
	read(n),read(m);
	build(rt[0],1,n);
	for(int i=1,last,flag,x,y,loc;i<=m;i++)
	{
		read(last),read(flag);
		if(flag==1)
		{
			read(x),read(y);
			change(rt[i],rt[last],1,n,x,y);
		}
		else
		{
			read(loc);
			printf("%d\n",que(rt[last],1,n,loc));
			rt[i]=rt[last];//注意新建的版本序号 
		}
	}
}
```

可持久化数组在可持久化算法中是一个非常重要的知识点，请大家好好记住！

~~哪一位大佬可以教我可持久化平衡树鸭。。。~~

---

## 作者：USSENTERPRISE (赞：6)

# $0.$ 前言
~~出题出挂了，来好好学主席树了~~

### 前置知识

线段树

没了

# $1.$ 简介

对于使用线段树，我们可以较好地解决“带修改的全局第k大（或小）问题”。但是对于某个区间进行求第k大（或小）操作就不是那么容易了。

## $1.1$ “可持久化”

可持久化一词在数据结构中十分常见。“可持久化”的意思就是“带有历史版本的”数据结构。而在我们所接触到的基本数据结构中（如数组、并查集、平衡树等）都有各自的可持久化版本。

## $1.2$ 主席树的引出

主席树，又名 **“可持久化线段树”**。~~至于为什么叫“主席树”我也不是特别明白~~。其基本状态就是一个可以查询多个历史版本的线段树。

## $1.3$ 模板题

 [P3834 【模板】可持久化线段树 1（主席树）](https://www.luogu.com.cn/problem/P3834)

>## 题目背景
>
>这是个非常经典的主席树入门题——静态区间第 $k$ 小
>
>## 题目描述
>
>如题，给定 $n$ 个整数构成的序列，将对于指定的闭区间查询其区间内的第 $k$ 小值。

>## 输入格式
>第一行包含两个正整数 $n,m$，分别表示序列的长度和查询的个数。

>第二行包含 $n$ 个整数，表示这个序列各项的数字。

>接下来 mm 行每行包含三个整数 $l,r,k$ , 表示查询区间 $[l,r]$ 内的第 $k$ 小值。

>## 输出格式

>输出包含 $m$ 行，每行一个整数，依次表示每一次查询的结果

# $2.$ 主席树

## $2.1$ 朴素思想

根据上文所说，主席树就是带有历史版本的线段树。如果要维护历史版本，最普通的思想就是建立多个完整的线段树，并在其上面进行操作。

但是很明显这个方案是不可行的。对于一个时间复杂度在 $O(nlogn)$ 级别上的算法来说，数据通常在 $10^5 - 10^6$。如果维护的历史版本过多，会导致空间复杂读过大(每个历史版本的空间都在 $n<<2$ 即 $n*4$ 的级别上)。

## $2.2$ 正解

对于每次修改，几乎没有对全局所有节点的修改。所以在进行修改时我们只需要将被修改的点建立一个新的“存档”就可以完成修改。

一般的我们只需要新建从根开始向下经过的每一个点就行了。（如下图所示）



## $2.3$ 模板题解决思路

模板题要求查询区间内第k小。根据以往经验我们可以选择运用“权值线段树”解决问题。

对于题目要求的区间查询，我们可以运用前缀和的思想解决问题，即用 $ [1,l-1] $ 中的数据与 $[1,r]$ 中的数据做差得出区间内的“权值线段树”（而不用以爆炸的复杂度为每次询问建树）

## $2.3$ 代码实现（以模板题为例）

### 主席树的建立

对于主席树我们并不能像线段树那样通过公式（$ls=now<<1,\ rs=now<<1|1$）计算出其左右儿子的下标，所以我们就需要建立起数组（或结构体解决）记录节点信息

```cpp
const int N=2e5+15;
int rt[N],ls[N<<5],rs[N<<5],sum[N<<5],tot;
```

然后就是建树了。

建树的时候对于模板题我们需要先建一个空的树，作为以后修改的基准点。

```cpp
void build(int &o,int l,int r){
	o=++tot;
	if(l==r) return;
	int mid=(l+r)>>1;
	build(ls[o],l,mid);
	build(rs[o],mid+1,r);
}
```
~~（真的和线段树建树一模一样呢（大雾））~~

### 修改

我们知道，对于一颗树，如果想要从根访问某个叶子节点，我们需要经过一条链。由于在线段树的单点修改中，我们经过链上的点都需要被修改，所以我们只需要增加这一条链的副本即可。

```cpp
	
inline int modify(int o,int l,int r,int p){
	int oo=++tot;
	ls[oo]=ls[o],rs[oo]=rs[o],sum[oo]=sum[o]+1;
	if(l==r) return oo;
	int mid=(l+r)>>1;
	if(p<=mid) ls[oo]=modify(ls[oo],l,mid,p);
	else rs[oo]=modify(rs[oo],mid+1,r,p);
	return oo;
}

```

### 模板题的查询

模板题的查询和线段树的基本相同。在查询的时候可以想象一颗线段树，每个节点的值是以 $rt[r]$ 为根的线段树相应节点的值减去 $rt[l-1]$ 为根的线段树相应节点的值（可以类比前缀合理解）

对于这样一个线段树就可以运用已有知识解决。

```cpp
inline int query(int L,int R,int l,int r,int k){
	int ans,mid=(l+r)>>1,x=sum[ls[R]]-sum[ls[L]];
	if(l==r) return l;
	if(x>=k) ans=query(ls[L],ls[R],l,mid,k);
	else ans=query(rs[L],rs[R],mid+1,r,k-x);
	return ans;
}
```


# $3.$  最重要的应用之一 —— 可持久化数组

主席树可以较好地维护一个“支持查询历史版本的”线段树，对于可持久化数组我们可以利用其支持历史版本的特点，实现可持久化

## $3.1$ 模板题

- [P3919 【模板】可持久化数组（可持久化线段树/平衡树）](https://www.luogu.com.cn/problem/P3919)

> ### 题目描述
>如题，你需要维护这样的一个长度为 NN 的数组，支持如下几种操作
>
>1. 在某个历史版本上修改某一个位置上的值
>
>2. 访问某个历史版本上的某一位置的值
>
>此外，每进行一次操作（对于操作2，即为生成一个完全一样的版本，不作任何改动），就会生成一个新的版本。版本编号即为当前操作的编号（从1开始编号，版本0表示初始状态数组）
>
>### 输入格式
>输入的第一行包含两个正整数 $N,M$, 分别表示数组长度和操作的个数
>
>第二行包含 $N$ 个整数，依次为初始状态下数组各位的值 (依次为 $a_i$, $1\leq i \leq N$ )
>
>接下来 $M$ 行包含 $3$ 或 $4$ 个整数，代表两种操作之一 ($i$ 为基于的历史版本号)：
>
>> $1.$ 对于操作 $1$ , 格式为 $ v_i\ 1\ loc_i\ value_i$ 即在版本 $v_i$ 的基础上， 将 $a_{loc_i}$ 修改为 $value_i$
>>
>> $2.$ 对于操作 $2$ , 格式为 $ v_i\ 2\ loc_i\ $ 即访问版本 $v_i$ 中 $a_{loc_i}$ 的值， 生成一样版本的对象应为 $v_i$
>
>### 输出格式
>输出包含若干行，依次为每个操作 $2$ 的结果。

## $3.2$ 解决思路

利用主席树解决

我们可以原数组存放在$rt[0]$的树的叶子节点，对于每一次修改直接修改即可

## $3.3$ 代码
```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cctype>
#include<algorithm>
#include<cmath>
#include<queue>

using namespace std;

#define rg register
#define ll long long
#define ull unsigned long long

namespace Enterprise{

	inline int read(){
		rg int s=0,f=0;
		rg char ch=getchar();
		while(not isdigit(ch)) f|=(ch=='-'),ch=getchar();
		while(isdigit(ch)) s=(s<<1)+(s<<3)+(ch^48),ch=getchar();
		return f?-s:s;
	}
	
	const int N=1e6+15;
	int val[N<<5],rt[N],ls[N<<5],rs[N<<5],a[N],tot;
	int n,m;
	
	inline int build(int l,int r){
		int o=++tot;
		if(l==r){ val[o]=a[l];return o; }//遍历到叶子节点赋值
		int mid=(l+r)>>1;
		ls[o]=build(l,mid);
		rs[o]=build(mid+1,r);
		return o;
	}
	
	inline int change(int pre,int l,int r,int x,int v){
		int o=++tot;
		ls[o]=ls[pre],rs[o]=rs[pre],val[o]=val[pre];
		if(l==r){
			val[o]=v;//在叶子节点处修改
			return o;
		}
		int mid=(l+r)>>1;
		if(x<=mid) ls[o]=change(ls[pre],l,mid,x,v);
		else rs[o]=change(rs[pre],mid+1,r,x,v);
		return o;
	}
	
	inline int query(int now,int l,int r,int x){//与正常线段树单点查询无异
		if(l==r) return val[now];
		int mid=(l+r)>>1;
		if(x<=mid) return query(ls[now],l,mid,x);
		else return query(rs[now],mid+1,r,x);
	}
	
	inline void main(){
		n=read(),m=read();
		for(rg int i=1;i<=n;i++) a[i]=read();
		rt[0]=build(1,n);
		for(rg int i=1;i<=m;i++){
			int ver=read(),opt=read(),x=read();
			if(opt==1){
				int v=read();
				rt[i]=change(rt[ver],1,n,x,v);
			}else{
				rt[i]=rt[ver];//直接将当前版本节点编号赋成要求的版本编号。这样可以快捷地完成新建立一个和v_i相同的版本
				printf("%d\n",query(rt[ver],1,n,x));
			}
		}
	}
}

signed main(){
	Enterprise::main();
	return 0;
}
```

# $4.$ 主席树时空复杂度分析

## $4.1$ 时间复杂度

主席树的基本操作的线段树思想大体一致，时间复杂度也基本一致。

对于建树，时间复杂度为 $O(nlogn)$

由于这里查询和修改都是单点操作，所以时间复杂度为 $O(logn)$

所总体时间复杂度基本为 $O((m+n)logn)$

## $4.2$ 空间复杂度

对于 $rt[0]$ 来说，空间复杂度=正常线段树空间复杂度，即最坏 $O(4n)$

对于每次修改，由于仅修改了 $logn$ 个节点，所以所有新建版本的最坏复杂度为 $O(mlogn)$ 

## $4.3$ 小声bb

一般的对于所有节点及其对应值（如节点值，左右儿子等）我们可以开20倍空间，或者 $maxn<<5$ 处理。 ~~各位大佬肯定已经知道了~~。

---

## 作者：arfa (赞：2)


 划分树是一种来解决区间第 $K$ 大的一种数据结构,其常数,理解难度都要比主席树低很多。同时,划分树紧贴"第 $K$ 大"，所以是一种基于排序的一种数据结构。**建议先学完主席树再看划分树哦**。

 ### 建树

 划分树的建树比较简单,但是相对于其他树来说比较复杂。
 ![](https://s1.ax1x.com/2018/08/31/Pvaer6.png)

 如图,每一层都有一个看似无序的数组。其实,每一个被红色标记的数字都是**要分配到左儿子的**。而分配的规则是什么?就是与**这一层的中位数**做比较, $\leq$ 左边,否则右边。但是这里要注意一下:并不是严格的 $\leq$ **左边,否则右边**。因为中位数可能有相同,而且与 $N$ 的奇偶有一定关系。下面的代码展示会有一个巧妙的运用,大家可以参照代码。

 我们不肯能每一次都对每一层排序,这样子不说常数,就算是理论复杂度也过不去。我们想,找中位数,一次排序就够了。为什么? 比如,我们求 $l,r$ 的中位数,其实就是在排完序过后的 $num[mid]$。


 两个关键数组:
 ```
 tree[log(N),N]   : 也就是树,要存下所有的值,空间复杂度 O(N log N)。
 toleft[log(N),n] : 也就是每一层 1~i 进入左儿子的数量,这里需要理解一下,这是一个前缀和。还有,这个东西不分是在哪一个节点,但是分那一层(没有关系)。 
 ```

 ```pascal
 procedure Build(left,right,deep:longint); // left,right 是左右区间,deep是第几层
 var
 	i,mid,same,ls,rs,flag:longint; // 其中 flag 是用来平衡左右两边的数量的
 begin
 	if left=right then exit; // 到底层了
 	mid:=(left+right) >> 1;
 	same:=mid-left+1;
 	for i:=left to right do 
 		if tree[deep,i]<num[mid] then
 			dec(same);

 	ls:=left; // 分配到左儿子的第一个指针
 	rs:=mid+1; // 分配到右儿子的第一个指针
 	for i:=left to right do
 	begin
 		flag:=0;
 		if (tree[deep,i]<num[mid])or((tree[deep,i]=num[mid])and(same>0)) then // 分配到左边的条件
 		begin
 			flag:=1; tree[deep+1,ls]:=tree[deep,i]; inc(ls);
 			if tree[deep,i]=num[mid] then // 平衡左右个数
 				dec(same);
 		end
 		else
 		begin
 			tree[deep+1,rs]:=tree[deep,i]; inc(rs);
 		end;
 		toleft[deep,i]:=toleft[deep,i-1]+flag;
 	end;
 	Build(left,mid,deep+1); // 继续
 	Build(mid+1,right,deep+1);
 end;
 ```

 ### 查询

 那我们先扯一下主席树的内容。在用主席树求区间第 $K$ 小的时候,我们以 $K$ 为基准,向左就向左,向右要减去向左的值,在划分树中也是这样子的。

 查询难理解的,在于**区间缩小**这种东西。下图,我查询的是 $3$ 到 $7$,那么下一层我就只需要查询 $2$ 到 $3$ 了。当然,我们定义 $left,right$ 为缩小后的区间(目标区间), $l,r$ 还是我所在节点的区间。那为什么要标出目标区间呢? 因为那是**判定答案在左边,右边的基准**。

 ![](https://s1.ax1x.com/2018/08/31/Pvduyq.png)


 ```pascal
 function Query(left,right,k,l,r,deep:longint):longint;
 var
 	mid,x,y,cnt,rx,ry:longint;
 begin
 	if left=right then // 写成 l=r 也无妨,因为目标区间也一定有答案
 		exit(tree[deep,left]);
 	mid:=(l+r) >> 1;
 	x:=toleft[deep,left-1]-toleft[deep,l-1]; // l 到 left 的去左儿子的个数
 	y:=toleft[deep,right]-toleft[deep,l-1]; // l 到 right 的去左儿子的个数
 	ry:=right-l-y; rx:=left-l-x; // ry 是 l 到 right 去右儿子的个数,rx 则是 l 到 lefr 去右儿子的个数
 	cnt:=y-x; // left 到 right 左儿子的个数
 	if cnt>=k then // 主席树常识啦
 		Query:=Query(l+x,l+y-1,k,l,mid,deep+1) // l+x 就是缩小左边界,l+y-1 就是缩小右区间。对于上图来说,就是把 1 和 2 放弃了。
 	else
 		Query:=Query(mid+rx+1,mid+ry+1,k-cnt,mid+1,r,deep+1); // 同样是缩小区间,只不过变成了右边而已。注意要 k-cnt。
 end;
 ```

 ### 理论复杂度和亲测结果

 时间复杂度 : 一次查询只需要 $O(\log\ n)$,$m$次询问,就是 $O(m\ \log\ n)$。

空间复杂度 : 只需要存储 $O(n\ \log\ n)$ 个数字。

 亲测结果:  主席树 : $1482ms$、划分树 : $889ms$。 (非递归,常数比较小)



 ### 后记

 大家可以试着去写非递归版哦。参考博文 : [传送门](https://blog.csdn.net/littlewhite520/article/details/70250722)。

---


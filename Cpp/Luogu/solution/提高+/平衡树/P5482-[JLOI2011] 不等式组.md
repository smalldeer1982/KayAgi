# [JLOI2011] 不等式组

## 题目描述

旺汪与旺喵最近在做一些不等式的练习。这些不等式都是形如 $ax+b>c$ 的一元不等式。当然，解这些不等式对旺汪来说太简单了，所以旺喵想挑战旺汪。旺喵给出一组一元不等式，并给出一个数值。旺汪需要回答的是 $x=k$ 时成立的不等式的数量。聪明的旺汪每次都很快就给出了答案。你的任务是快速的验证旺汪的答案是不是正确的。

## 说明/提示

#### 样例 1 说明

第 $1$ 条添加到不等式组的不等式为 $x+1>1$，第 $2$ 条为 $−2x+4>3$。所以第 $1$ 个询问的时候只有第 $2$ 条不等式可以成立，故输出 `1`。

然后删除第 $1$ 条不等式，再询问的时候依然是只有第 $2$ 条不等式可以成立，故输出 $1$ 。

再删除第 $2$ 条不等式后，因为不等式组里面没有不等式了，所以没有不等式可以被满足，故输出 $0$。

继续加入第 $3$ 条不等式 $8x+9>100$，当 $x=k=10$ 时有 $8\times 10+9=89<100$，故也没有不等式可以被满足，依然输出 $0$。

#### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $n\leq 10^3$。
- 对于 $40\%$ 的数据，保证 $n\leq 10^4$。
- 对于 $100\%$ 的数据，保证 $1\leq n\leq 10^5$，$a,b,c\in[-10^8,10^8]$，$k\in[-10^6,10^6]$。

## 样例 #1

### 输入

```
9
Add 1 1 1
Add -2 4 3
Query 0
Del 1
Query 0
Del 2
Query 0
Add 8 9 100
Query 10```

### 输出

```
1
1
0
0```

# 题解

## 作者：MY（一名蒟蒻） (赞：36)

[原题传送门](https://www.luogu.com.cn/problem/P5482)

**欢迎各位大佬来踩！**

这题是[lxl 由乃](https://www.luogu.com.cn/user/3296#main)上课时讲的一道例题，刚听了回放，参考了一下题解写出了本文。

## Part 0 对题目的理解
lxl yyds！

![](https://cdn.luogu.com.cn/upload/image_hosting/lb5fs01o.png)

以上出自lxl的课件。
## Part 1 想法
![](https://cdn.luogu.com.cn/upload/image_hosting/r1dejfxx.png)

以上还是出自lxl的课件。

让我们来说人话。

1. 首先，对于每一个不等式$ax+b > c$，我们可以把它转换成一个分式$x > (c-b)/a$。由于a可能为负，我们需要分类讨论。
2. 又$∵x(也就是k)$ $∈$ $[$ −$10^6$ $ , $ $10^6$ $]$，$∴$我们要开**两个**值域上的树状数组。
3. 当$x > (c-b)/a$时，`x > floor((c*1.0-b)/a)`，即下取整的$(c-b)/a$。同理当$x < (c-b)/a$时，`x < ceil((c*1.0-b)/a)`，即上取整的$(c-b)/a$。

那么所谓**注意细节**指的是什么呢。
## Part 2 “注意细节”
1. a有可能为0，需要特判，否则会RE
2. 对于一些**恒成立或恒不成立**的不等式，需要特殊记录
3. 树状数组防负数需要离散化
4. 下取整和整除是两个概念。我之前就一直搞不懂还特意发了个[铁汁](https://www.luogu.com.cn/discuss/show/279667)。如果您还是不明白我放两张图直观感受一下。

![](https://cdn.luogu.com.cn/upload/image_hosting/s9vta4wa.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/d5y4gh2u.png)
## Part 3 Code
具体的注释在代码里了，请结合讲解食用。
```cpp
//分类思想+转化思想 
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <cstdlib>

using namespace std;

const int N=1e6+10,M=1e5+10;

int n,C[N*2],c[N*2],top,kind[M],k[M],cnt;
//kind：哪一类不等式；	k：不等式合法需要的 k (k=(c-b)/a)；
//C/c：两类不等式（k < x | k > x） 
//cnt：恒成立不等式个数； 
bool used[M];//记录这个不等式是否被删除 
char s[20];

void modify(int x,int y,int t[])//不要问我为什么起这个名字，问就是lxl 
{
	x+=N;//防负数 
	for(;x<=2e6+10;x+=x&(-x))//lowbit(x)=x&(-x)
		t[x]+=y;
	return ;
}

int sum(int x,int t[])
{
	x+=N;
	int res=0;
	for(;x;x-=x&(-x))
		res+=t[x];
	return res;
}

int main()
{
// 	freopen("work.in","r",stdin); freopen("work.out","w",stdout);
	scanf("%d",&n);
	int x,y,z;
	while(n--)
	{
		while(1)
		{
			scanf("%s",s);//输入操作 
			if(s[0] == 'A' || s[0] == 'Q' || s[0] == 'D')
				break ;
		}
		if(s[0] == 'A')
		{
			scanf("%d%d%d",&x,&y,&z);
			if(!x)//x=0 不等式转化为 b > c 
			{
				if(y > z)
				{
					cnt++;
					kind[++top]=3;//表示恒成立 
				}
				else kind[++top]=0;//恒不成立
			}
			if(x > 0)//x > (c-b)/a
			{
				k[++top]=floor((z*1.0-y)/x);//下取整 
				kind[top]=1;//表示合法的 k < x
				//k < x 且k已经上溢  
				if(k[top] > 1e6) kind[top]=0;//表示恒不成立 
				else if(k[top] < -1e6)//k < x 且k已经下溢 
				{
					cnt++;//恒成立 
					kind[top]=3;
				}
				else modify(k[top],1,C);
			}
			if(x < 0)//同理，可类比上面理解
			{
				k[++top]=ceil((z*1.0-y)/x);
				kind[top]=2;
				if(k[top] < -1e6) kind[top]=0;
				else if(k[top] > 1e6)
				{
					cnt++;
					kind[top]=3;
				}
				else modify(k[top],1,c);
			}
		}
		if(s[0] == 'Q')
		{
			scanf("%d",&x);
			printf("%d\n",sum(x-1,C)+(sum(1e6,c)-sum(x,c))+cnt);
			//合法的(k < x) + 合法的(k > x) + 恒成立 
		}
		if(s[0] == 'D')//Delete
		{
			scanf("%d",&x);
			if(used[x]) continue ;
			used[x]=true;
			if(kind[x] == 3) cnt--;
			if(kind[x] == 1) modify(k[x],-1,C);
			if(kind[x] == 2) modify(k[x],-1,c);
		}
	}
// 	fclose(stdin); fclose(stdout);
	return 0;
}
```
# Thank you for your reading!

---

## 作者：Laser_Crystal (赞：20)

怎么感觉题解区里没有和我马蜂相似的啊（~~代码也抄不来~~），于是调试了无数小时，，，

主要思想是把一个不等式转化为一个数，然后丢进平衡树去维护就好惹（我写的是可旋$Treap$）

在浙教版初中数学8年级上我们学过如何计算一个不等式的解，按照题意，我们可以推导出$ax+b>c$这个不等式的解：

1. 当$a>0$时，可以解得不等式的解为$x>\frac{c-b}{a}$
2. 当$a<0$时，可以解得不等式的解为$x<\frac{c-b}{a}$
3. 当$a=0$时，需分两种情况考虑，若$b>c$，则有无数解，反之则无解

我们把情况一和情况二分别放进不同的平衡树维护，单独计算无数解的情况。

但是如果平衡树的节点权值是$double$的话，会因为浮点误差可能会WA。并且因为k是整数，维护浮点数很浪费时间空间，于是我们考虑对不同的解进行取整。

* 对于$a>0$，我们考虑对这个解进行下取整
* 对于$a<0$，我们考虑对这个解进行上取整

但是如过直接用$floor$和$ceil$会因为精度误差WA掉好多点，因此我们考虑如下办法：

```cpp
//下取整；
ceil((c-b)/a)-1
//上取整
floor((c-b)/a)+1
```

然后建立平衡树，把这些算出来的丢进去

平衡树弄完了然后呢？

我们可以发现：

* 对$a>0$的不等式，x不大于k就行
* 对$a<0$的不等式，x不小于k就行

这不就是查询k的升\降次的排名吗！

注意维护一下不等式是否存在，因为可能会重复删去相同的不等式。

### Code

（那啥，代码比较长，，，但是自认为马蜂不错
```cpp
#include<bits/stdc++.h> 
using namespace std;
int n;
int T,R1,R2,size,S;//T维护恒成立的情况
int x[100005],y[100005],z[100005];
bool f[100005];
int  res[100005];
struct node{
	int l,r,size,rnd,w;//Treap的板子
	int v;
}tree1[100005],tree2[100005];//tree1维护a>0的情况，tree2维护a<0的情况
inline void update1(int k){tree1[k].size=tree1[tree1[k].l].size+tree1[tree1[k].r].size+tree1[k].w;}
inline void update2(int k){tree2[k].size=tree2[tree2[k].l].size+tree2[tree2[k].r].size+tree2[k].w;}
inline void Rt1(int &k)
{
	int t=tree1[k].l;tree1[k].l=tree1[t].r;tree1[t].r=k;
	tree1[t].size=tree1[k].size; update1(k);k=t;
}
inline void Rt2(int &k)
{
	int t=tree2[k].l;tree2[k].l=tree2[t].r;tree2[t].r=k;
	tree2[t].size=tree2[k].size; update2(k);k=t;
}
inline void Lt1(int &k)
{
	int t=tree1[k].r;tree1[k].r=tree1[t].l;tree1[t].l=k;
	tree1[t].size=tree1[k].size;update1(k);k=t;
}
inline void Lt2(int &k)
{
	int t=tree2[k].r;tree2[k].r=tree2[t].l;tree2[t].l=k;
	tree2[t].size=tree2[k].size;update2(k);k=t;
}
inline void insert1(int &k,int x)
{
	if(k==0) 
	{
		k=++size; 
		tree1[k].size=tree1[k].w=1;tree1[k].v=x;tree1[k].rnd=rand();	
		return;
	}
	tree1[k].size++;
	if(tree1[k].v==x) {tree1[k].w++;return;}
	if(x>tree1[k].v)
	{
		insert1(tree1[k].r,x);
		if(tree1[tree1[k].r].rnd<tree1[k].rnd) Lt1(k);
	} 
	else
	{
		insert1(tree1[k].l,x);
		if(tree1[tree1[k].l].rnd>tree1[k].rnd) Rt1(k);
	}	
}
inline void insert2(int &k,int x)
{
	if(k==0) 
	{
		k=++size; 
		tree2[k].size=tree2[k].w=1;tree2[k].v=x;tree2[k].rnd=rand();	
		return;
	}
	tree2[k].size++;
	if(tree2[k].v==x) {tree2[k].w++;return;}
	if(x>tree2[k].v)
	{
		insert2(tree2[k].r,x);
		if(tree2[tree2[k].r].rnd<tree2[k].rnd) Lt2(k);
	} 
	else
	{
		insert2(tree2[k].l,x);
		if(tree2[tree2[k].l].rnd>tree2[k].rnd) Rt2(k);
	}	
}
inline void del1(int &k,int x)
{
	if(k==0) return;
	if(tree1[k].v==x)
	{
		if(tree1[k].w>1) {tree1[k].w--;tree1[k].size--;return;}
		if(tree1[k].l*tree1[k].r==0) k=tree1[k].l+tree1[k].r;
		else if(tree1[tree1[k].l].rnd<tree1[tree1[k].r].rnd)  Rt1(k),del1(k,x);
		else Lt1(k),del1(k,x);
	}
	else if(x>tree1[k].v)  tree1[k].size--,del1(tree1[k].r,x);
	else tree1[k].size--,del1(tree1[k].l,x);
}
 void del2(int &k,int x)
{
	if(k==0) return;
	if(tree2[k].v==x)
	{
		if(tree2[k].w>1) {tree2[k].w--;tree2[k].size--;return;}
		if(tree2[k].l*tree2[k].r==0) k=tree2[k].l+tree2[k].r;
		else if(tree2[tree2[k].l].rnd<tree2[tree2[k].r].rnd)  Rt2(k),del2(k,x);
		else Lt2(k),del2(k,x);
	}
	else if(x>tree2[k].v)  tree2[k].size--,del2(tree2[k].r,x);
	else tree2[k].size--,del2(tree2[k].l,x);
}
inline int rk1(int k,int x)
{
	if(k==0) return 0;
	else if(tree1[k].v==x) return tree1[tree1[k].l].size+1;
	else if(x>tree1[k].v) return tree1[tree1[k].l].size+tree1[k].w+rk1(tree1[k].r,x);
	else return rk1(tree1[k].l,x);
}
inline int rk2(int k,int x)
{
	if(k==0) return 0;
	else if(tree2[k].v==x) return tree2[tree2[k].r].size+1;
	else if(x<tree2[k].v) return tree2[tree2[k].r].size+tree2[k].w+rk2(tree2[k].l,x);
	else return rk2(tree2[k].r,x);
}
int main()
{
	cin>>n;
	memset(f,0,sizeof(f));
	while(n--)
	{
		string c;
		cin>>c;
		if(c=="Add")
		{
			++S;
			scanf("%d%d%d",&x[S],&y[S],&z[S]);
			f[S]=1;
			if(x[S]>0)  res[S]=floor((z[S]-y[S])/(1.0*x[S]))+1，insert1(R1,res[S]);
			else if(x[S]==0){if(y[S]>z[S]) T++;}
			else if(x[S]<0) res[S]=ceil((z[S]-y[S])/(x[S]*1.0))-1，insert2(R2,res[S]);
		}
		else if(c=="Del")
		{
			int d; cin>>d; 
			if(f[d])
			{
				if((x[d]==0)&&(y[d]>z[d])) T--;
				if(x[d]>0) del1(R1,res[d]);
				if(x[d]<0) del2(R2,res[d]);
				f[d]=0;
			}
		}
		else if(c=="Query")
		{
			int k; cin>>k;
			cout<<rk1(R1,k)+T+rk2(R2,k)<<endl;
		}
	}
	return 0;
}
```

这道题就做完了喵$φ(>ω<*) $

---

## 作者：Guitar_Jasmine (赞：11)

这题的细节是真滴多（这里提供的是树状数组写法）。

直接讲做法:
* 发现这题k的范围是$[-1e6,1e6]$，那其实就可以不用管$a,b,c$的大小了，大的可以直接特判出去。
* 对于每个$Add\ a\ b\ c$，我们先把它进行分类：
1. 无论$x$取值如何都不会被统计进答案，可以不用管它们。
1. 无论$x$取值如何都会被统计进答案，我们用一个$spe$变量单独记下来就好。
1. $x<k$的**不确定**会不会被加入答案的，直接把$k$放进数组$c1$，也就是$c1[k]++$。
1. $x>k$的**不确定**会不会被加入答案的，直接把$k$放进数组$c2$。

(分好类就方便了下面的分类讨论)
* 解这个不等式首先肯定要对$a$进行分类讨论：

1. $$a>0$$ 
也就是说 $x>\frac{c-b}{a}$ ，令$k=\frac{c-b}{a}$，如果$k>1e6$，那就是上述1.的情况(因为$x$的取值不可能大于$1e6$，所以是一个铁定不会被统计进答案的情况)，同理，如果$k<-1e6$(说明是2.的情况)，那直接$spe++$，如果$-1e6\leq k\leq1e6$，那么把$k$下取整(因为如果满足$x>k$就一定满足$x>\lfloor k \rfloor$)然后扔进$c2$就好了(属于情况4.)。

2. $$a<0$$
这种情况和上述类似，如果属于情况1.或情况2.(注意这里判断情况1.和情况2.的条件不同)还是相同的处理，否则，就属于情况3.了，先把$k$上取整(因为$x<k$一定有$x<\lceil k \rceil$)，然后直接扔进$c1$。

3. $$a=0$$
这是最简单的一种情况，属于情况非1.及2.,这个判断很简单就不赘述了。

* 最后怎么算答案呢？对于一个询问$k$：

$ans=spe+\sum_{i=1}^{1e6}c1[i]+\sum_{i=k+1}^{1e6}c2[i]$

式子应该显然吧(根据上面分类讨论应该很好推出答案)，然后发现这就是一个前缀和，用一个树状数组维护一下就好了。
时间复杂度：$O(nlogk)$

* 上代码(前面bb这么多代码注释就少写了一点哈)

```
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>

using namespace std;

const int N=1000001;
int n,c1[N*2+10],c2[N*2+10],tx[N],ty[N],tot,spe,tz[N];

/*
ty[i]表示第i个Add a b c的类型（1<<30代表情况2.，-(1<<30)表示情况1.）
tx[i]表示第i个Add a b c的k值 （ty[i]==1<<30 or ty[i]==-(1<<30)的情况下你可以认为它不存在）
*/

//树状数组板子(因为树状数组不能出现0所以给每个x都加上了一个N)
int lowbit(int x)
{
	return x&(x^(x-1));
}

void add(int x,int k,int c[])
{
	x+=N;
	while(x<=2000001)
	{
		c[x]+=k;
		x+=lowbit(x);
	}
}

int getsum(int x,int c[])
{
	x+=N;
	int ans=0;
	while(x)
	{
		ans+=c[x];
		x-=lowbit(x);
	}
	return ans;
}

void work()
{
	scanf("%d",&n);
	char s[10];
	int x,y,z;
	while(n--)
	{
		scanf("%s",s);
		if(s[0]=='A')
		{
			scanf("%d %d %d",&x,&y,&z);
			if(x==0)
			{
				if(y>z)
					spe++,ty[++tot]=1<<30;
				else
					ty[++tot]=-(1<<30);
			}
			else if(x<0)
			{
				//先把k值算出来（记在tx里），然后分情况讨论
				tx[++tot]=(ceil)((z*1.-y)/x),ty[tot]=2;
				if(tx[tot]>1000000)
					spe++,ty[tot]=1<<30;
				else if(tx[tot]<-1000000)
					ty[tot]=-(1<<30);
				else
					add(tx[tot],1,c2);
			}
			else
			{
				//同上
				tx[++tot]=(floor)((z*1.-y)/x),ty[tot]=1;
				if(tx[tot]>1000000)
					ty[tot]=-(1<<30);
				else if(tx[tot]<-1000000)
					ty[tot]=1<<30,spe++;
				else
					add(tx[tot],1,c1);
			}
		}
		else if(s[0]=='D')
		{
			//Delete 没什么技术含量
			scanf("%d",&x);
			if(tz[x])
				continue;
			tz[x]=1;
			if(ty[x]==1<<30)
				spe--;
			else if(ty[x]==1)
				add(tx[x],-1,c1);
			else if(ty[x]==2)
				add(tx[x],-1,c2);
		}
		else
		{
			//输出答案
			scanf("%d",&x);
			printf("%d\n",getsum(x-1,c1)+getsum(1000000,c2)-getsum(x,c2)+spe);
		}
	}
}

int main()
{
	//freopen("P5482.in","r",stdin);
	//freopen("P5482.out","w",stdout);
	work();
	return 0;
}

```


---

## 作者：vectorwyx (赞：9)

平衡树裸题，就是细节有点多。

当 $x=k$ 时不等式 $ax+b>c$ 成立需要按照 $a$ 分三种情况讨论：若 $a>0$，则 $k>\frac{c-b}{a}$ 时不等式成立，由于 $k$ 是整数，所以这个式子等价于 $k\ge \lfloor \frac{c-b}{a}\rfloor+1$；若 $a=0$，则 $b>c$ 时不等式成立；若 $a<0$，则 $k<\frac{c-b}{a}$ 时不等式成立，同上，等价于 $k\le \lceil\frac{c-b}{a}\rceil-1$。

因此我们可以建两棵平衡树，一棵存 $a>0$ 的不等式，以 $\lfloor \frac{c-b}{a}\rfloor+1$ 作为权值；一棵存 $a<0$ 的不等式，以 $\lceil\frac{c-b}{a}\rceil-1$ 作为权值，那么查询操作就相当于在第一棵平衡树里查询权值 $\le k$ 的数的数量和在第二棵平衡树里查询权值 $\ge k$ 的数的数量，再加上满足 $a=0$ 且 $b>c$ 的不等式的个数（这个简单记录一下就好）。剩下的就是板子了。

另外，一个不等式可能被删除多次，因此我们还需要开一个数组记录第 $i$ 个不等式是否已被删除。

代码如下：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#define ll long long
#define fo(i,x,y) for(register int i=x;i<=y;++i)
#define go(i,x,y) for(register int i=x;i>=y;--i)
using namespace std;
inline int read(){ int x=0,fh=1; char ch=getchar(); while(!isdigit(ch)){ if(ch=='-') fh=-1; ch=getchar(); } while(isdigit(ch)){ x=(x<<1)+(x<<3)+ch-'0'; ch=getchar(); } return x*fh; }

const int N=1e5+5,inf=1e9;

struct Tree{
	int data[N],siz[N],cnt[N],fa[N],ch[N][2],tot,root;
	
	inline int son(int x){return x==ch[fa[x]][1];}
	inline void push_up(int x){siz[x]=siz[ch[x][0]]+siz[ch[x][1]]+cnt[x];} 
	
	inline void rotate(int x){
		int y=fa[x],z=fa[y],sx=son(x),sy=son(y),b=ch[x][!sx];
		if(z) ch[z][sy]=x; else root=x; fa[x]=z;
		ch[x][!sx]=y; fa[y]=x;
		ch[y][sx]=b; if(b) fa[b]=y;
		push_up(y),push_up(x);
	}
	
	inline void splay(int x,int aim){
		while(fa[x]!=aim){
			int y=fa[x],z=fa[y];
			if(z==aim) rotate(x);
			else if(son(x)^son(y)) rotate(x),rotate(x);
			else rotate(y),rotate(x);
		}
	}
	
	void insert(int &now,int x){
		//printf("insert(%d,%d)\n",now,x);
		if(!now){
			now=++tot;
			siz[now]=cnt[now]=1;
			data[now]=x;
			return;
		}
		if(x<data[now]) insert(ch[now][0],x),fa[ch[now][0]]=now;
		else if(x==data[now]) cnt[now]++;
		else insert(ch[now][1],x),fa[ch[now][1]]=now;
		push_up(now);
	}
	
	inline int fin(int x){
		int now=root;
		while(now){
			if(x<data[now]) now=ch[now][0];
			else if(x==data[now]) return now;
			else now=ch[now][1];
		}
		return 0;
	}
	
	inline int get_kth(int k){
		--k;
		int now=root;
		while(now){
			int lt=ch[now][0],rt=ch[now][1];
			if(siz[lt]>k) now=lt;
			else if(siz[lt]+cnt[now]>k) return now;
			else k-=siz[lt]+cnt[now],now=rt;
		}
		return 0;
	}
	
	inline int get_pre(int x){
		int now=root,ans=0;
		while(now){
			if(data[now]<x) ans=now,now=ch[now][1];
			else now=ch[now][0];
		}
		return ans;
	}
	
	inline int get_suc(int x){
		int now=root,ans=0;
		while(now){
			if(data[now]>x) ans=now,now=ch[now][0];
			else now=ch[now][1];
		}
		return ans;
	}
	
	void del(int x){
		int p1=get_pre(x),p2=get_suc(x);
		splay(p1,0);splay(p2,root);
		int p=ch[p2][0];
		cnt[p]--,siz[p]--;
		if(!cnt[p]) fa[p]=0,ch[p2][0]=0;
		push_up(p2),push_up(p1);
	}
	
	int get_rank(int x,int od){
		int now=root,ans=0;
		while(now){
			if(od==0){
				if(data[now]<=x) ans+=siz[ch[now][0]]+cnt[now],now=ch[now][1];
				else now=ch[now][0];				
			}else{
				if(data[now]>=x) ans+=siz[ch[now][1]]+cnt[now],now=ch[now][0];
				else now=ch[now][1];	
			}
		}
		return ans;
	}
	Tree(){
		root=tot=siz[1]=cnt[1]=1;data[1]=inf;
		insert(root,-inf);
	}
	void outit(){
		printf("root=%d tot=%d\n",root,tot);
		fo(i,1,tot) printf("%d:data=%d siz=%d cnt=%d fa=%d ch0=%d ch1=%d\n",i,data[i],siz[i],cnt[i],fa[i],ch[i][0],ch[i][1]);
	}
}Splay[2];

char s[10];
int fl[N],num[N],d[N],top;

int main(){
	//注意特判a=0的情况 
	int n=read(),cn=0;
	//memset(fl,-1,sizeof fl);
	fo(i,1,n){
		//Splay[0].outit();Splay[1].outit();
		scanf("%s",s);
		if(s[0]=='A'){
			++top;
			int a=read(),b=read(),c=read();
			if(a==0){
				cn+=(b>c);
				num[top]=(b>c);
				fl[top]=-1;
			} 
			else if(a>0){
				fl[top]=0;
				int x=floor(1.0*(c-b)/a)+1;
				Splay[0].insert(Splay[0].root,x);
				int p=Splay[0].fin(x);
				Splay[0].splay(p,0);
				num[top]=p;
			}else{
				fl[top]=1;
				int x=ceil(1.0*(c-b)/a)-1;
				Splay[1].insert(Splay[1].root,x);
				int p=Splay[1].fin(x); 
				Splay[1].splay(p,0);		
				num[top]=p;		
			}
		}
		if(s[0]=='D'){
			int k=read();
			if(d[k]) continue;
			d[k]=1;
			if(fl[k]==-1){
				cn-=num[k];
				continue;
			} 
			Splay[fl[k]].del(Splay[fl[k]].data[num[k]]);
		}
		if(s[0]=='Q'){
			int k=read();
			printf("%d\n",cn+Splay[0].get_rank(k,0)+Splay[1].get_rank(k,1)-2);
		}
	}
	return 0;
}
/*
-------------------------------------------------
*/
```


---

## 作者：_CHO (赞：4)

貌似还没有线段树的题解？

那我来一发


------------

这题细节是真的多


既然是用线段是来做，显然需要维护两棵树，分别维护$a>0$ 和$a<0$的情况，其中$a=0$的情况特判，简单分析可以得到如下结论

现有不等式$ax+b>c$

当$a>0$时,有  $x>\frac{c-b}{a}$

当$a<0$时，有

当$a=0$时,若$c-b>=0$,则无解，否则解集为$R$

关于$a=0$的情况特判即可，于是维护$a$不为$0$时等不等式右侧，分别把他们塞进线段树中，对于每一个给定的$k$，只需查询对应的值域区间即可。

另外一个坑点就是$\frac{c-b}{a}$ 的范围可能很大，而k的范围很小，所以此处应该特判。

~~其实楼上都已经讲得很详细了我只是想水一个线段树~~


Code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 1e+6+100;
struct bds{
	int a,b,c;
	bool del;
};
int n,spe;
bds cd[maxn];
int sumv[2][maxn<<3];
inline void add_bds(int cnt,int a,int b,int c){
	cd[cnt].a=a;cd[cnt].b=b;cd[cnt].c=c;
	cd[cnt].del=0;
}
inline void pushup(int o){
	sumv[0][o]=sumv[0][o<<1]+sumv[0][o<<1|1];
	sumv[1][o]=sumv[1][o<<1]+sumv[1][o<<1|1];
}
inline void optadd(int o,int l,int r,int q,int v,int p){
	if(l==r){
		sumv[p][o]+=v;
		return ;
	}
	int mid=l+r>>1;
	if(q<=mid) optadd(o<<1,l,mid,q,v,p);
	else optadd(o<<1|1,mid+1,r,q,v,p);
	pushup(o);
}
inline int query(int o,int l,int r,int ql,int qr,int p){
	if(ql<=l&&r<=qr) return sumv[p][o];
	int mid=l+r>>1;
	int res=0;
	if(ql<=mid) res=query(o<<1,l,mid,ql,qr,p);
	if(qr>mid) res += query(o<<1|1,mid+1,r,ql,qr,p);
	return res;
}
inline void del(int x){
	cd[x].del = true;
	bds t = cd[x];
	t.c-=t.b;
	if(!t.a){
		if(t.c<0) --spe;
	}else if(t.a<0){
		if(ceil((double)t.c/t.a)< -1e6 ) return ;
		else if(ceil((double)t.c/t.a)>maxn) --spe;
		else optadd(1,-maxn,maxn,ceil((double)t.c/t.a),-1,0);
	}else{
		if(floor((double)t.c/t.a)>maxn)return ;
		else if(floor((double)t.c/t.a)<-maxn) --spe;
		else optadd(1,-maxn,maxn,floor((double)t.c/t.a),-1,1);
	}
}

int main(){
	cin>>n;
	for(register int ii=1,cnt=0;ii<=n;++ii){
		char s[10];int a,b,c,i,k;
		scanf("%s",s);
		if(s[0]=='A'){
			scanf("%d%d%d",&a,&b,&c);
			add_bds(++cnt,a,b,c);
			c-=b;
			if(!a){
				if(c<0) ++spe;
			}else if(a<0){
				if(ceil((double)c/a)<-maxn) continue;
				else if(ceil((double)c/a)>maxn) ++spe;
				else optadd(1,-maxn,maxn,ceil((double)c/a),1,0);
			}else{
				if(floor((double)c/a)>maxn)continue;
				else if(floor((double)c/a)<-maxn) ++spe;
				else optadd(1,-maxn,maxn,floor((double)c/a),1,1);
			}
		}
		if(s[0]=='D'){
			scanf("%d",&i);
			if(cd[i].del) continue;
			del(i);
		}
		if(s[0]=='Q'){
			scanf("%d",&k);
			printf("%d\n",spe+query(1,-maxn,maxn,k+1,maxn,0)+query(1,-maxn,maxn,-maxn,k-1,1));
		}
	}
	return 0;
}
```


---

## 作者：AquaRio (赞：4)

### [我的博客](http://39.105.95.125/index.php/archives/162/)

### 题目传送门：[P5482](https://www.luogu.org/problem/P5482)

## 分析：

按a的正负来分情况，然后树状数组维护即可。

经过变形之后，不等式可以分为3种情况：
 
 
1. 当 $a>0$ ，可以变成 $x > $ 上取整的  $\frac{c-b}{a}$，并且在[-1e6,1e6]范围内加一。
2. 当 $a=0$ ，若 $b>c$ 则恒成立，否则就丢进去不管他。
3. 当 $a<0$ ，可以变成 $x < $ 下取整的  $\frac{c-b}{a}$,并且在[-1e6,1e6]范围内加一。

注意一下细节就可以过了qaq。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100009;
const int M=20000009;
const int F=1000009;
const double eps=1e-9;
struct qaq{
	int a[M],n;
	qaq(){
		memset(a,0,sizeof a);
		n=2*F;
	}
	void add(int x,int v){
		for(;x<=n;x+=x&-x) a[x]+=v;
	}
	int query(int x){
		int ans=0;
		for(;x;x-=x&-x)ans+=a[x];
		return ans;
	}
}t;

int line[N],li,ty[N];
bool vis[N];
int x,y,z,n;
char s[11];

int main(){
	cin>>n;
	while(n--){
		cin>>s;
		if(s[0]=='A'){
			vis[++li]=0;
			cin>>x>>y>>z;
			if(x==0){
				if(y>z) t.add(1,1),line[li]=1;
				else line[li]=2;
				ty[li]=-1;
			}
			else {
				if(x>0) line[li]=min((int)max(floor((double)(z-y)/x+1),-F+1.0),F)+F,t.add(line[li],1),ty[li]=1;
				else line[li]=min((int)max(ceil((double)(z-y)/x-1),-F+1.0),F)+F,t.add(1,1),t.add(line[li]+1,-1),ty[li]=0;
			}
		}
		else if(s[0]=='D'){
			cin>>x;
			if(!vis[x]){
				vis[x]=1;
				if(ty[x]==1) t.add(line[x],-1);
				else if(ty[x]==0) t.add(1,-1),t.add(line[x]+1,1);
				else if(ty[x]==-1&&line[x]==1) t.add(1,-1);
			}
		}
		else if(s[0]=='Q'){
			cin>>x;
			cout<<t.query(x+F)<<endl;
		}
	}
	return 0;
}
```

---

## 作者：zsaskk (赞：3)

分享一下平衡树（treap）的做法。

首先讲一下我做这道题的经历。

第一反应：树状数组or线段树可做。但我为了练习平衡树，没有选择这种做法，然后就调试了无数小时。。。

下面是写题时的几个要点。

第一点：对于$ax+b>c$这个不等式，根据基本的数学知识，应当对$a$的正负进行讨论，这一点会在代码中体现。

第二点：由于题目中给出的不等号是小于号，我们要考虑怎样写才能满足这种关系。
下面给出一种解决方法。~~我做这道题时，就是因为这里没想好改了很久。~~
```
对于上取整：
floor((c-b)*1.0/a)+1
对于下取整：
ceil((c-b)*1.0/a)-1
```

第三点：考虑用何种方法维护两种关系。

题解区有的人打了两棵树，这里给另一种方法，分类存储。具体见代码。

第四点：这道题使用的平衡树和正常的模板不太一样，因为我们要求的排名的定义不太一样。

未尽之处，代码中会给注释。



------------
```
#include<bits/stdc++.h>
using namespace std;
#define reg register
#define maxsize 100010
#define inf 2000000005 
#define chk_digit(c) (c>='0'&&c<='9')
inline int read(){
	reg int x=0,f=1;reg char c=getchar();
	while(!chk_digit(c)) { if(c=='-') f=-1;c=getchar(); }
	while(chk_digit(c)) x=x*10+c-'0',c=getchar();
	return x*f;
}
inline char get_char(){
	reg char c=getchar();
	while(c==' '||c=='\n') c=getchar();
	return c;
}
int n,vis[maxsize],tot[3],root[3],tmp,belong[maxsize],num[maxsize],alr[maxsize],all,value[maxsize];
struct TREAP{ int l,r,val,rand_num,times,size; }tr[3][maxsize];
//给出的维护方法就是平衡树开二维存储，操作中注明所用的是哪个，但码量较小，易于调试。 
inline int New(int num,int val) { tr[num][++tot[num]].val=val,tr[num][tot[num]].rand_num=rand(),tr[num][tot[num]].times=tr[num][tot[num]].size=1;return tot[num]; }
inline void update(int num,int p) { tr[num][p].size=tr[num][tr[num][p].l].size+tr[num][tr[num][p].r].size+tr[num][p].times; }
inline void build(int num) { srand(time(0)),New(num,-inf),New(num,inf),root[num]=1,tr[num][1].r=2,update(num,root[num]); }
inline int get_rank(int num,int p,int val) {//与其说是求“排名 ”，更合适的说法是求<=x的数有多少个 
	if(!p) return 0;
	if(val==tr[num][p].val) return tr[num][tr[num][p].l].size+tr[num][p].times;//注意这里与模板的区别 
	if(val<tr[num][p].val)  return get_rank(num,tr[num][p].l,val); 
	return get_rank(num,tr[num][p].r,val)+tr[num][tr[num][p].l].size+tr[num][p].times;;
}
inline void zig(int num,int &p) { int q=tr[num][p].l;tr[num][p].l=tr[num][q].r,tr[num][q].r=p,p=q,update(num,tr[num][p].r),update(num,p); }
inline void zag(int num,int &p) { int q=tr[num][p].r;tr[num][p].r=tr[num][q].l,tr[num][q].l=p,p=q,update(num,tr[num][p].l),update(num,p); }
inline void insert(int num,int &p,int val) {
	if(!p) { p=New(num,val);return; }
	if(val==tr[num][p].val) { ++tr[num][p].times,update(num,p);return; }
	if(val<tr[num][p].val) {
		insert(num,tr[num][p].l,val);
		if(tr[num][p].rand_num<tr[num][tr[num][p].l].rand_num) zig(num,p);
	}
	else {
		insert(num,tr[num][p].r,val);
		if(tr[num][p].rand_num<tr[num][tr[num][p].r].rand_num) zag(num,p);
	}
	update(num,p);
}
inline void remove(int num,int &p,int val) {
	if(!p) return;
	if(val==tr[num][p].val) {
		if(tr[num][p].times>1) {
			--tr[num][p].times,update(num,p);
			return;
		}
		if(tr[num][p].l|tr[num][p].r) {
			if(tr[num][p].r==0||tr[num][tr[num][p].l].rand_num>tr[num][tr[num][p].r].rand_num) 
				zig(num,p),remove(num,tr[num][p].r,val);
			else zag(num,p),remove(num,tr[num][p].l,val);
			update(num,p);
		}
		else p=0;
		return;
	}
	val<tr[num][p].val?remove(num,tr[num][p].l,val):remove(num,tr[num][p].r,val);
	update(num,p);
}
int main(){
	build(1),build(2);
	n=read();
	int tent=0;
	for(reg int i=1;i<=n;++i) {
		char opt;int a,b,c;
		opt=get_char();
		if(opt=='A') {
			++tent,a=read(),b=read(),c=read();
			if(a==0&&b>c) { ++tmp,alr[tent]=1; }//对于a的取值的不同处理 
			if(a>0) value[tent]=1,belong[tent]=1,insert(1,root[1],floor((c-b)*1.0/a)+1),num[tent]=floor((c-b)*1.0/a)+1;//当形式可化为x>c，因为x为整数，如x=3，对于c属于[2.0,3.0），将他们改写为3，在上边的平衡树写法下不改变结果。 
			if(a<0) value[tent]=1,++all,belong[tent]=2,insert(2,root[2],ceil((c-b)*1.0/a)-1),num[tent]=ceil((c-b)*1.0/a)-1;//推理过程与上一个类似。 
		}
		if(opt=='Q') {
			int ans=tmp;a=read();
			ans+=get_rank(1,root[1],a)+(all-get_rank(2,root[2],a-1));//这里由于两棵平衡树的排序方法是一样的，要稍作转化。
			//求a-1的排名是因为对于 x等于2，c属于（2,3],都成立，但是这样的c会被写作2，所以考虑求1的排名，再做转化 
			printf("%d\n",ans);
		}
		if(opt=='D'&&!vis[a=read()]) {//避免重复删除 
			if(!value[a]) { if(alr[a]) --tmp; }
			else if(value[a]){
				remove(belong[a],root[belong[a]],num[a]);
				if(belong[a]==2) --all;
			}
			vis[a]=1;
		}
	}
}
```


---

## 作者：程门立雪 (赞：2)


你需要维护一堆不等式。

1.插入一个 $ax+b>c$ 的不等式。

2.删除第 $i$ 个插入的不等式。

3.查询 $x=k$ 的时候成立的不等式个数。

**题解：**
将式子进行变形。
 
分类讨论， 当 $a > 0$ 时，$x >\frac{c- b}a$ , 当 $a = 0$ 时， $c - b < 0$, 当 $a < 0$ 时， $x < \frac{c- b}a$​。

将插入的不等式变成了，$\frac{c_i - b_i}{a_i}$​ 这样一个值。

设 $d_i = \frac{c_i - b_i}{a_i}$​​​， 当前问题就转化成了要维护一个数据结构满足插入一个 $d_i$​​​​, 删除一个 $d_i$​​​, 查询有多少个 $k > d_i$​​， 对于其中的恒等式，恒不等式要进行特殊的标记。

可以直接取整， 将浮点数的值域映射到一个整数区间上。

对于大于和小于，需要开两个值域上的树状树组，单点修改， 然后每次插入取个整，查询直接查前缀和。

实现了平衡树的功能。

```c
/*
Source:luogu 5482
konwledge: 树状数组，注意细节  
           floor 是向下取整，直接除是向零取整，在负数会相差1
*/
#include <iostream>
#include <cstdio>
#include <cmath>
#define orz cout << "AK IOI"
#define lowbit(x) (x & (-x)) 

using namespace std;
const int maxn = 1e5 + 10;
const int maxk = 1e6 + 10;

inline int read() 
{
	int f = 0, x = 0; char ch = getchar();
	while(!isdigit(ch)) f |= (ch == '-'), ch = getchar();
	while(isdigit(ch)) x = x * 10 + (ch ^ 48), ch = getchar();
	return f ? -x : x;
}
inline void print(int X)
{
	if(X < 0) {X = ~(X - 1); putchar('-');}
	if(X > 9) print(X / 10);
	putchar(X % 10 + '0');
}
int n, cnt, top, k[maxn], type[maxn];//k 记录使当前不等式合法的k 
int t1[maxk << 1], t2[maxk << 1];
bool vis[maxn];
void build(int x, int y)
{
	x += maxk;
	for( ; x <= 2e6 + 10; x += lowbit(x)) t1[x] += y;
}
void build2(int x, int y)
{
	x += maxk;
	for( ; x <= 2e6 + 10; x += lowbit(x)) t2[x] += y;
}
int query(int x, int t[])
{
	x += maxk;
	int res = 0;
	for( ; x; x -= lowbit(x)) res += t[x];
	return res;
}
int main()
{
	//freopen(".in","r",stdin);
    //freopen(".out","w",stdout);
    n = read();
    for(int i = 1; i <= n; i++)
    {
    	char opt[6];
    	cin >> opt;
    	if(opt[0] == 'A')
    	{
    		int a = read(), b = read(), c = read();
    		if(a == 0)//进行分类讨论
			{
				if(b > c)
				{
					cnt++; 
					type[++top] = 3;//恒成立 
				}
				else type[++top] = 0;//恒不成立 
			} 
			if(a > 0)
			{
				k[++top] = floor((double(c) - b) / a);//因为是大于号，向下取整 
				type[top] = 1;
				if(k[top] > 1e6) type[top] = 0;
				else if(k[top] < -1e6)
				     {
				     	 cnt++;//恒成立
						 type[top] = 3; 
					 }
					 else build(k[top], 1);
			}
			if(a < 0)
			{
				k[++top] = ceil((double(c) - b) / a);//向上取整 
				type[top] = 2;
				if(k[top] < -1e6) type[top] = 0;
				else if(k[top] > 1e6)
				     {
				     	 cnt++;//恒成立
						 type[top] = 3; 
					 }
					 else build2(k[top], 1);
			}
		}
		if(opt[0] == 'D')
		{
			int x = read();
			if(vis[x] == 1) continue;
			vis[x] = 1;
			if(type[x] == 3) cnt--;
			if(type[x] == 1) build(k[x], -1);
			if(type[x] == 2) build2(k[x], -1);
		}
		if(opt[0] == 'Q')
		{
			int k = read();
			printf("%d\n", cnt + query(k - 1, t1) + query(1e6, t2) - query(k, t2));
		}
	} 
	return 0;
}
```


---

## 作者：小恐 (赞：2)

写完这道题，深深的感觉到了自己的菜……

目标：将每个不等式化成4种情况：

1. 不小于某一个数就有解。
2. 不超过某一个数就有解。
3. 永远有解。
4. 永远无解。

原不等式$a\times x+b>c$能转换为$a\times x>c-b$，此时明显要分类讨论一下。

1. 当$a>0$时，转换为$x>\dfrac{c-b}{a}$，这时我们只需求出$x$的最小可能值，记为$res$，如果给的数比它大就说明成立，明显属于第1种情况。但c++的整除有点奇怪，最后反复试验得知：
	1. 当$c-b\ge0$时，```res=(c-b)/a+1```
   2. 当$c-b<0$时，```res=(c-b)%a==0?(c-b)/a+1:(c-b)/a```

	注意到$q\in[-10^6,10^6]$。所以当$res>10^6$时，不可能有$q$成立，属于第4种情况。当$res<-10^6$时，所有$q$都有解，属于第3种情况。
2. 当$a=0$时，转换为$c-b<0$，分下类：
	1. $c-b<0$，所有$q$都有解，属于第3种情况
   2. $c-b\ge0$，所有$q$都无解，属于第4种情况
3. 当$a<0$时，转换为$x<\dfrac{c-b}{a}$，这时我们只需求出$x$的最大可能值，记为$res$，如果给的数比它小就说明成立，明显属于第2种情况。但c++的整除有点奇怪，最后反复试验得知：
	1. 当$c-b\ge0$时，```res=(c-b)/a-1```
   2. 当$c-b<0$时，```res=(c-b)%a==0?(c-b)/a-1:(c-b)/a```

	注意到$q\in[-10^6,10^6]$。所以当$res<-10^6$时，不可能有$q$成立，属于第4种情况。当$res>10^6$时，所有$q$都有解，属于第3种情况。
    
现在所有的不等式都可以转换成如上形式，所以询问读入一个$x$时的答案为不超过$x$的第一种情况的个数，不少于$x$的第二种情况的个数，第三种情况的个数。这个可以开2个数组，$a_i=$ 第一种（第二种）情况$res=i$的个数。因为可能有负数，所以加一个$10^6+1$。然后用树状数组维护一下前缀和。第二种情况可以反一下，大的在前。

然后是删除，删除就对应的情况减1就行，因为这题同一个点有可能删好几次，所以记录一下，别老减。

有点晕？上代码吧：
```cpp
#include<stdio.h>
using namespace std;
const int NR=1e5+5;
const int MR=1e6+5;
const int INF=0x3f3f3f3f;
typedef long long LL;
inline int read()
{
	int x=0;
	int bei=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')
			bei=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=x*10+ch-'0';
		ch=getchar();
	}
	return x*=bei;
}
int n;
char ch[10];
int op[NR],res[NR];
bool book[NR];
int cnt;
int bitree1[MR<<1],bitree2[MR<<1];
inline int lowbit(int x)
{
	return (-x)&x;
}
void modify1(int x,int k)
{
	for(int i=x;i<(MR<<1);i+=lowbit(i))
		bitree1[i]+=k;
}
int query1(int x)
{
	int ans=0;
	for(int i=x;i;i-=lowbit(i))
		ans+=bitree1[i];
	return ans;
}
void modify2(int x,int k)
{
	for(int i=x;i<(MR<<1);i+=lowbit(i))
		bitree2[i]+=k;
}
int query2(int x)
{
	int ans=0;
	for(int i=x;i;i-=lowbit(i))
		ans+=bitree2[i];
	return ans;
}
int main()
{
//	freopen("P5482.in","r",stdin);
//	freopen("P5482.out","w",stdout);
	n=read();
	int id=0;
	for(int i=1;i<=n;++i)
	{
		scanf("%s",ch+1);
		if(ch[1]=='A')
		{
			++id;
			int a=read(),b=read(),c=read();
			c-=b;
			if(a>0)
			{
				op[id]=1;
				if(c>=0)
					res[id]=c/a+1;
				else
					res[id]=c%a==0?c/a+1:c/a;
				if(res[id]>1e6)
					op[id]=4;
				else if(res[id]<-1e6)
					op[id]=3,++cnt;
				else
					modify1(res[id]+1e6+1,1);
			}
			else if(a<0)
			{
				op[id]=2;
				if(c>=0)
					res[id]=c/a-1;
				else
					res[id]=c%a==0?c/a-1:c/a;
				if(res[id]>1e6)
					op[id]=3,++cnt;
				else if(res[id]<-1e6)
					op[id]=4;
				else
					modify2(1e6-res[id]+1,1);
			}
			else
			{
				if(c<0)
					op[id]=3,++cnt;
				else
					op[id]=4;
			}
		}
		else if(ch[1]=='D')
		{
			int x=read();
			if(book[x])
				continue;
			if(op[x]==1)
				modify1(res[x]+1e6+1,-1);
			else if(op[x]==2)
				modify2(1e6-res[x]+1,-1);
			else if(op[x]==3)
				--cnt;
			book[x]=1;
		}
		else
		{
			int x=read();
			printf("%d\n",cnt+query1(x+1e6+1)+query2(1e6-x+1));
		}
	}
	return 0;
}

```

感谢阅读。

---

## 作者：Keith_2006 (赞：2)

## P5482 [JLOI2011] 不等式组 题解

[更好的阅读体验](https://www.luogu.com.cn/blog/106510/solution-5482)

UPD：修复了小错误，感谢 @唱歌的向日葵 dalao 指出错误。

#### 这是一道细节很多（并且很恶心）的树状数组题目

萌新写题解，如果有不对的地方欢迎指出。

---

### 题目大意

有三种操作：

- 加入一条形如 $ax+b>c$ 的不等式。
- 删除一条不等式
- 统计 $x=k$ 时不等式成立的个数，并输出。

其中 $1 \leq n \leq 10^5$，$a,b,c \in [-10^8,10^8]$，$k \in [-10^6,10^6]$。

---

### 题目分析

首先，看到这个数据范围和询问的方式，应该可以想到要使用一种数据结构维护。

如果做过类似的题目的话，看到这种“在线查询、修改单个数值，询问整体”的题目也应该能想到要利用**权值树状数组**（树状数组里面存一个权值对应的信息）。

那么现在问题来了，怎么维护树状数组呢？

假如我们现在已经知道了每一个不等式的解集，那么可以考虑使用树状数组求前缀和的方式解决。

举个例子，加入我们有这样 $n$ 条不等式：$x \geq k_1,x \geq k_2,\cdots,x \geq k_n$，我们要求的是 $x=k$ 时有多少条成立。

可以这样搞：对于每一个 $k_i$，在树状数组第 $k_i$ 位置上 $+1$，最后的答案就等于对第 $k$ 位求前缀和。

这样我们就能用树状数组维护的。

但是，将会产生以下问题：

1. 求出的 $k_i$ 可能是小数。
2. 求出的 $k_i$ 中的符号不确定，且是大于或小于号，不带等号。

对于这两个问题，我们需要制订一套方案，把不等式的**解集转化为 $x \leq k_i$ 或者 $x \geq k_i$**。

我这里给出一套方案：

我们设 $p=\dfrac{c-b}{a}$

对于 $a>0$ 的不等式，原始解集为 $x>p$，则将其转化为 $x \geq \lfloor p \rfloor+1$。
对于 $a<0$ 的不等式，原始解集为 $x<p$，则将其转化为 $x \leq \lceil p \rceil-1$

可以分别对正数、负数、整数、小数验证这个规律，都是对结果没有影响的。

这样的话，我们由于有两种($\leq$和$\geq$)不等式，**我们需要维护两个树状数组，在查询的时候要分别计算然后求和**。

你以为这样就完了吗？其实还有很多的细节。

比如说，我们算出来的 $k_i$ 可能是负的，而一般的树状数组维护的权值最小为 $1$，所以对于符号为 $\geq$ 的情况，我们需要把 $k$ 值整体向右平移 $10^6+1$，使得所有的 $k_i$ 位于 $[1,2 \times 10^6+1]$ 中。具体的，如果原始解集为 $x \geq k_i$，那么**实际插入的位置将是 $k_i+10^6+1$**。

还有一个大坑点，就是**对于 $\leq$ 的情况，我们不能直接查询左侧的前缀和，应该查询右侧前 $k$ 个数值的前缀和。**（可以自己感性理解一下）

这里有两种解决方案：

1. 将区间转置,正常查询前缀和。具体的，如果原始解集为 $x \leq k_i$，那么实际插入的位置将是 $2 \times 10^6-(k_i+10^6+1)=10^6+1-k_i$。
2. 利用前缀和的思想，在查询时，输出 $\operatorname{query}(2 \times 10^6)-\operatorname{query}(k-1)$。

我个人选择了第一种。

还有一个问题，也就是说**如果出现了 $a=0$ 以及 $|k|>10^6$ 的情况，就不能正常地利用树状数组去维护**。这种情况可以参考其他的几篇题解，主要思路就是搞一个变量，统计在所有情况都会被统计的数量，在询问的时候加上。对于那些无论如何都不会被统计的情况，直接忽略就好。

删除部分没有太多技术含量，要注意一点：**需要加入一个数组，统计这一条不等式是否已经被删除！**（我就因为这个被卡了一个晚上）

---

### 代码实现

代码方面，我们主要需要两个数组：`op[N]` 以及 `k[N]`。

`op[i]` 表示第 $i$ 次询问操作的符号：

- $1$ 代表 $\geq$ 号
- $2$ 代表 $\leq$ 号
- $3$ 代表无论如何都会被计算
- $4$ 代表无论如何都不会被计算

`k[i]` 表示第 $i$ 个添加的经过处理后的不等式解集。

变量 `all` 表示无论如何都会被计算不等式的数目。注意，在删除的时候，如果删除了这一种情况的，`all` 要减一。

下面是代码，和其他题解的大同小异，在细节实现上不太一样。（比较丑，仅供参考）：

注释都在上面，这里面就没写注释。

~~这么丑的代码你们也看不懂要什么注释~~

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cctype>
#include <vector>
#include <queue>
#include <cmath>

#define ll long long

using namespace std;

inline int read() {
	int x=0,f=1;
	char ch=getchar();
	while (!isdigit(ch)) {if (ch=='-') f=-1;ch=getchar();}
	while (isdigit(ch)) x=x*10+ch-'0',ch=getchar();
	return x*f;
}

const int N=2e6+5;

int n;
int c1[N],c2[N],k[N],op[N],del[N];

inline int lowbit(int x) {
	return x&-x;
}

inline void add(int x,int k,int c[]) {
	for (int i=x;i<=N;i+=lowbit(i)) {
		c[i]+=k;
	}
}

inline int query(int x,int c[]) {
	int ans=0;
	for (int i=x;i;i-=lowbit(i)) {
		ans+=c[i];
	}
	return ans;
}

int main() {
	n=read();
	int cnt=0,all=0;
	for (int i=1;i<=n;i++) {
		char opt[10];
		scanf("%s",opt);
		if (opt[0]=='A') {
			cnt++;
			int a=read(),b=read(),c=read();
			double num;
			if (a==0) {
				if (b>c) {
					all++;
					op[cnt]=3;
				} else op[cnt]=4;
				continue;
			} else if (a<0) op[cnt]=2;
			else op[cnt]=1;
			num=(double)(c-b)/(double)a;
			if (op[cnt]==1) {
				if (num>1e6) {
					op[cnt]=4;
				} else if (num<-1e6) {
					op[cnt]=3;
					all++;
				} else {
					k[cnt]=(int)floor(num)+1;
					add(k[cnt]+1e6+1,1,c1);
				}
			} else {
				if (num>1e6) {
					op[cnt]=3;
					all++;
				} else if (num<-1e6) {
					op[cnt]=4;
				} else {
					k[cnt]=(int)ceil(num)-1;
					add(1e6+1-k[cnt],1,c2);
				}
			}
		} else if (opt[0]=='D') {
			int x=read();
			if (del[x]) continue;
			del[x]=1;
			if (op[x]==3) {
				all--;
				continue;
			}
			if (op[x]==4) continue;
			if (op[x]==1) {
				add(k[x]+1e6+1,-1,c1);
			} else {
				add(1e6+1-k[x],-1,c2);
			}
		} else {
			int x=read();
			printf("%d\n",query(x+1e6+1,c1)+query(1e6+1-x,c2)+all);
		}
	}
	return 0;
}
```

这份代码跑的还是很快的，总共 400 ms 左右，时间复杂度很显然是 $\mathcal{O}(n \log k)$ 的。

---

如果觉得有帮助，可以点一个赞啊。

大家也可以看一看我万年不更新的博客咯 qwq


---

## 作者：世墨 (赞：2)

## fhq treap做法

### 我们先来理一理思路

题中包含三个操作：
#### 1. 添加不等式
	
显然对于不等式 $ax+b>c$的解可以分为三类
	
###### (1：对于$a>0$ 可以得到 $x>(c-b)/a$，即$x_{min}=floor((c-b)/a)+1$ 

###### (2：对于$a<0$ 可以得到 $x<(c-b)/a$，即$x_{max}=ceil((c-b)/a)-1$

###### (3：对于$a==0$ 可以得到 $if(b>c)$ 有无穷多解，$else$ 无解

注：$floor$ 表示下取整，$ceil$ 表示上取整，请自行分类是否整除的情况并考虑取值是否可以取到

#### 2.删除之前添加的不等式

用一个bool记录一下是否已经被删除即可，基本删除操作可行

#### 3.询问 $x=k$ 时不等式成立的数量

根据上面$1$ 里的三个分类，可以发现

###### 在 $(1$ 中，若 $k>=x_{min}$ 则成立

###### 在 $(2$ 中，若 $k<=x_{max}$ 则成立

###### 在 $(3$ 中，与 $k$ 无关

———————————————————————————————————————

### 考虑代码实现

想到，$fhq \ \ treap$可以轻松询问某一值在 $treap$ 中的 $rank$

那么我们只要建树，搞到 $rank$，那么所有取值边界比 $k\ \ $ 大 $or$ 小的不等式均可行

问题在于，有一部分不等式有上界，一部分有下界，一部分无穷解，一部分无解，没法判断怎么办？

#### ~~靠码量碾压一切~~

对于有上\下界的，各开一棵 $fhq\ \ treap$，对于有无穷解的，记个数，无解的记 $0$

##### 这道题坑点比较多，还是值得好好写一写的（坑点记录在文末）

代码扔在下面

```cpp
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f
using namespace std;

bool delt[100010];//记录是否被删除
int size[100010],ch[100010][2],val[100010],rk[100010],tot,root,x,y,z;

inline void update(int x){size[x]=size[ch[x][0]]+size[ch[x][1]]+1;}

inline int NEW(int x){size[++tot]=1;val[tot]=x;rk[tot]=rand();return tot;}

inline void split(int now,int k,int &x,int &y){//左小右大 
	if(!now)x=y=0;
	else {
		if(val[now]<=k)
			x=now,split(ch[now][1],k,ch[now][1],y);
		else 
			y=now,split(ch[now][0],k,x,ch[now][0]);
		update(now);
	}
}

inline int merge(int x,int y){
	if(!x||!y)return x+y;
	if(rk[x]<rk[y]){
		ch[x][1]=merge(ch[x][1],y);
		update(x);return x;
	}
	else {
		ch[y][0]=merge(x,ch[y][0]);
		update(y);return y;
	}
}

inline void insert(int k){split(root,k,x,y);root=merge(merge(x,NEW(k)),y);}

inline int query(int k){
	split(root,k,x,y);
	int res=size[x];
	//printf("MIN have %d\n",res);
	root=merge(x,y);
	return res;
}

inline void del(int v){//删除 
	split(root,v,x,z);
	split(x,v-1,x,y);
	y=merge(ch[y][0],ch[y][1]);
	root=merge(merge(x,y),z);
}
//以上为第一棵treap，记录有下界的不等式下界

int size1[100010],ch1[100010][2],val1[100010],rk1[100010],tot1,root1,xx,yy,zz;

inline void update1(int x){size1[x]=size1[ch1[x][0]]+size1[ch1[x][1]]+1;}

inline int NEW1(int x){size1[++tot1]=1;val1[tot1]=x;rk1[tot1]=rand();return tot1;}

inline void split1(int now,int k,int &x,int &y){//左大右小 
	if(!now)x=y=0;
	else {
		if(val1[now]>=k)
			x=now,split1(ch1[now][1],k,ch1[now][1],y);
		else 
			y=now,split1(ch1[now][0],k,x,ch1[now][0]);
		update1(now);
	}
	return ;
}

inline int merge1(int x,int y){
	if(!x||!y)return x+y;
	if(rk1[x]<rk1[y]){
		ch1[x][1]=merge1(ch1[x][1],y);
		update1(x);return x;
	}
	else {
		ch1[y][0]=merge1(x,ch1[y][0]);
		update1(y);return y;
	}
}

inline void insert1(int k){split1(root1,k,xx,yy);root1=merge1(merge1(xx,NEW1(k)),yy);}

inline int query1(int k){
	split1(root1,k,xx,yy);
	int res=size1[xx];
	root1=merge1(xx,yy);
	return res;
}

inline void del1(int v){//删除 
	split1(root1,v,xx,zz);
	split1(xx,v+1,xx,yy);
	yy=merge1(ch1[yy][0],ch1[yy][1]);
	root1=merge1(merge1(xx,yy),zz);
}
//第二棵，记录有上界的不等式上界

int basic,n,in[100010],got[100010],num;

inline void add(){//插入不等式
	num++; int a,b,c,k;
	scanf("%d%d%d",&a,&b,&c);
    c=c-b;//这里把c化成c-b了
	if(a>0){k=floor(c*1.0/a)+1;insert(k);in[num]=1;got[num]=k;}
    //这个in[]记录了这个不等式的类型，方便删除的时候找它
    //这个got[]记录这个不等式解的边界值，用于删除
	else if(a<0){k=ceil(c*1.0/a)-1;insert1(k);in[num]=2,got[num]=k;}
	else if(a==0){
		in[num]=3;
		if(c<0)basic++,got[num]=1;//这个basic用来记录无穷解的数量
		else got[num]=0;
	}
}

int main(){
	cin>>n;int a;string key;
	for(int i=1;i<=n;i++)
	{
		cin>>key;
		if(key=="Add")add();
		if(key=="Query"){
			scanf("%d",&a);
			printf("%d\n",basic+query(a)+query1(a));
		}
		if(key=="Del"){
			scanf("%d",&a);
			if(delt[a])continue;//有重复删的坑点
			delt[a]=1;
			if(in[a]==1)del(got[a]);
			if(in[a]==2)del1(got[a]);
			if(in[a]==3)basic-=got[a];
		}
	}
	return 0;
}
```

坑点：重复删除同一个不等式，无解不等式和无穷解不等式的删除，
~~以及两只fhp带来的无限手残~~

##### 完结撒花！ \（^~^）/




---

## 作者：SamariumPhosphide (赞：1)

因为 $ax+b>c$，解这个不等式，可以分类讨论：

+ $a > 0$，则 $x > \frac{c -b}{a}$
+ $a = 0$，若 $b>c$，则 $x \in \text{R}$；否则 $x$ 无解。
+ $a < 0$，则 $x < \frac{c-b}{a}$。

其中 $a=0$ 的情况可以特判， 另外两种情况分别使用一个平衡树进行维护。第一个平衡树中的每个节点表示 $x > val$ ，第二个平衡树中每个节点表示 $x < val$。 每次插入或删除时，判断 $a$ 的正负号，并将 $\frac{c-b}{a}$  插入对应的平衡树。每次查询时首先把需要查询的 $k$ 分别插入到两个平衡树中，并将其 splay 到根节点。对于第一个平衡树，直接查询有多少个数比 $k$ 小，也就是 $sz[ch[rt][0]]$；对于第二个平衡树，直接查询有多少个数比 $k$ 大，也就是 $sz[ch[x][1]]$。然后再加上 $a=0$ 的不等式满足的数量即可。最后从平衡树中删除 $k$ 。注意删除时要特判这个数有没有已经被删除。

最后贴上有一点注释的代码。~~不知道为什么我要写嘤语注释~~

```cpp
#include <cstdio>

const int N = 100007;

struct bst {
  int n, root, tot, ch[N][2], par[N], cnt[N], sz[N];
  double val[N];

  bool chk(int x) { return ch[par[x]][1] == x; }

  void pushup(int x) { sz[x] = cnt[x] + sz[ch[x][0]] + sz[ch[x][1]]; }

  void rotate(int x) {
    int y = par[x], z = par[y], k = chk(x), w = ch[x][k ^ 1];
    ch[y][k] = w, par[w] = y;
    ch[z][chk(y)] = x, par[x] = z;
    ch[x][k ^ 1] = y, par[y] = x;
    pushup(y);
    pushup(x);
  }

  void splay(int x, int goal = 0) {
    while (par[x] != goal) {
      int y = par[x], z = par[y];
      if (z != goal) {
        if (chk(x) == chk(y))
          rotate(y);
        else
          rotate(x);
      }
      rotate(x);
    }
    if (!goal) {
      root = x;
    }
  }

  void find(double x) {
    int cur = root;
    while (ch[cur][x > val[cur]] && x != val[cur]) {
      cur = ch[cur][x > val[cur]];
    }
    splay(cur);
  }

  int pre(double x) {
    find(x);
    if (val[root] < x) return root;
    int cur = ch[root][0];
    while (ch[cur][1]) {
      cur = ch[cur][1];
    }
    return cur;
  }

  int succ(double x) {
    find(x);
    if (val[root] > x) return root;
    int cur = ch[root][1];
    while (ch[cur][0]) {
      cur = ch[cur][0];
    }
    return cur;
  }

  void rm(double x) {
    int last = pre(x), nxt = succ(x);
    splay(last), splay(nxt, last);
    int del = ch[nxt][0];
    if (cnt[del] > 1) {
      cnt[del]--;
      splay(del);
    } else {
      ch[nxt][0] = 0;
      splay(nxt);
    }
  }

  int kth(double k) {
    int cur = root;
    while (1) {
      if (ch[cur][0] && k <= sz[ch[cur][0]]) {
        cur = ch[cur][0];
      } else if (k > sz[ch[cur][0]] + cnt[cur]) {
        k -= sz[ch[cur][0]] + cnt[cur];
        cur = ch[cur][1];
      } else {
        return cur;
      }
    }
  }

  void insert(double x) {
    int cur = root, p = 0;
    while (cur && val[cur] != x) {
      p = cur;
      cur = ch[cur][x > val[cur]];
    }
    if (cur) {
      cnt[cur]++;
    } else {
      cur = ++tot;
      if (p) {
        ch[p][x > val[p]] = cur;
      }
      cnt[cur] = sz[cur] = 1;
      val[cur] = x, par[cur] = p;
    }
    splay(cur);
  }

  int rank(double x) {
    find(x);
    return sz[ch[root][0]];
  }
};

bst less, more;
int m, tot, zero;
double para[N]; // (c - b) / a
bool negative[N], deleted[N]; // whether a is negative, whether it is already deleted
char op[10];

signed main() {
  scanf("%d", &m);
  less.insert(1e9);
  less.insert(-1e9);
  more.insert(1e9);
  more.insert(-1e9);
  for (int i = 1; i <= m; i++) {
    scanf("%s", op);
    if (*op == 'A') {
      int a, b, c;
      scanf("%d %d %d", &a, &b, &c);
      tot++;
      if (a > 0) {
        more.insert((double)(c - b) / a);
        para[tot] = (double)(c - b) / a;
        negative[tot] = false;
      } else if (a == 0) {
        if (b > c) {
          zero++;
          para[tot] = -2e9; // this indicates that any number is ok
        } else {
          para[tot] = 2e9;  // this indicates that no number satisfies the inequality
        }
      } else {
        less.insert((double)(c - b) / a);
        para[tot] = (double)(c - b) / a;
        negative[tot] = true;
      }
    } else if (*op == 'D') {
      int i;
      scanf("%d", &i);
      double todelete = para[i];
      bool isnegative = negative[i];
      if (deleted[i]) continue;
      if (para[i] == -2e9) {
        zero--;
        deleted[i] = true;
      } else if (para[i] == 2e9) {
        deleted[i] = true;
      } else if (isnegative) {
        less.rm(para[i]);
        deleted[i] = true;
      } else {
        more.rm(para[i]);
        deleted[i] = true;
      }
    } else {
      int k;
      scanf("%d", &k);
      more.insert(k);
      less.insert(k);
      more.find(k);
      less.find(k);
      printf("%d\n", more.sz[more.ch[more.root][0]] - 1 + less.sz[less.ch[less.root][1]] - 1 + zero);
      more.rm(k);
      less.rm(k);
    }
  }
  return 0;
}
```





---

## 作者：EricQian (赞：1)

[P5482 [JLOI2011]不等式组](https://www.luogu.com.cn/problem/P5482)

超烦人的细节题！（本人调了两天 QAQ ）

这里介绍一种只用到**一只树状数组**的写法（离线）。

树状数组的下标是：所有**可能出现的数据**进行**离散化**之后的值。

其含义为：当 $x$ 离散化后值为 $i$ 时能满足的不等式个数为 $query(i)$ 个。

### 1. 处理数据

首先我们先读入所有数据，并对数据处理：

$\text{Add} ~a_i~b_i~c_i$ ：

若 $a_i>0$ 将 $a_ix+b_i>c_i$ 转化成 $x\ge t_i$ 的形式 。

若 $a_i<0$ 将 $a_ix+b_i>c_i$ 转化成 $x\le t_i$ 的形式 。

并将 $t_i$ 丢进离散化的序列中。

注意：所有的除法运算都是向 $0$ 取整，还要注意除法变号问题等等。

$\text{Del}$ ：

在处理 $\text{Add}$ 时提前记录第 $x$ 个 $\text{Add}$ 操作所对应的输入操作编号。

$\text{Query}$ ：

将 $k_i$ 丢进离散化序列中。

之后将序列中的数离散化，给 $\text{Add}$ 中的 $t_i$ 和 $\text{Query}$ 中的$k_i$ 都附上一个离散化后的值（ $Instead_i$ ） 。

### 2. 计算答案

$\text{Add}$ ：

若 $a_i>0$ 则在 $[t_i,+\infty)$ 区间内的 $Instead_x$ 都可以使不等式成立。

同理，若 $a_i<0$ 则在 $(-\infty,t_i]$ 区间内的 $Instead_x$ 都可以使不等式成立。

在区间内加 $1$ 即可 。

$\text{Del}$ 和 $\text{Add}$ 几乎一致，变为区间减 $1$ 。

$\text{Query}~k_i$ 即可直接查询并输出 $Query(Instead_i)$ 。

最后附上 100pts 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define Maxn 100005
#define inf 0x7f7f7f7f
typedef long long ll;
inline int rd()
{
	 int x=0;
     char ch,t=0;
     while(!isdigit(ch = getchar())) t|=ch=='-';
     while(isdigit(ch)) x=x*10+(ch^48),ch=getchar();
     return x=t?-x:x;
}
int n,tmp,tot,cnt;
map<int,int> mp;
int Ins_val[Maxn],hist[Maxn];
struct Data
{
	 int opt,t,Ins;
	 int pre,used; 
}a[Maxn];
int tree[Maxn];
inline int lowbit(int x){ return x&(-x); }
void add(int x,int k)
{
	 while(x<=tot+1) tree[x]+=k,x+=lowbit(x);
}
int query(int x)
{
	 int ret=0;
	 while(x) ret+=tree[x],x-=lowbit(x);
	 return ret;
}
int main()
{
     //freopen(".in","r",stdin);
     //freopen(".out","w",stdout);
	 n=rd();
	 string opt;
	 for(int i=1,x,y,z,A,B,C;i<=n;i++)
	 {
	 	 cin>>opt;
	 	 if(opt=="Add")
		 {
		 	 A=rd(),B=rd(),C=rd(),hist[++cnt]=i;
			 a[i].opt=2-(A>=0); // 当 a>=0 时 opt=1 ，否则 opt=2 
			 if(A==0) a[i].t=(B>C)?(-inf+1):inf;
			 else if(A>0) a[i].t=(C-B)/A+(((C-B)>=0)?1:(((C-B)/A*A==(C-B))?1:0));
			 else a[i].t=(C-B)/A-(((C-B)>=0)?1:(((C-B)/A*A==(C-B))?1:0));
			 Ins_val[++tmp]=a[i].t;
		 }
	 	 if(opt=="Del")
		 {
		 	 a[i].pre=hist[rd()];
			 a[i].opt=a[a[i].pre].opt+2; // 当 a>=0 时 opt=3 ，否则 opt=4 
			 a[i].t=a[a[i].pre].t;
		 }
	 	 if(opt=="Query") a[i].opt=5,a[i].t=rd(),Ins_val[++tmp]=a[i].t;
	 }
	 sort(Ins_val+1,Ins_val+1+tmp);
	 Ins_val[0]=-inf;
	 for(int i=1;i<=tmp;i++) if(Ins_val[i]!=Ins_val[i-1]) mp[Ins_val[i]]=++tot;
	 for(int i=1;i<=n;i++) a[i].Ins=mp[a[i].t];
	 for(int i=1;i<=n;i++)
	 {
	 	 if(a[i].t==inf) continue; // a==0 && b<c
	 	 if(a[i].opt==1) add(tot+1,-1),add(a[i].Ins,1); //  a>0 || (a==0 && b>c)
	 	 if(a[i].opt==2) add(a[i].Ins+1,-1),add(1,1); //  a<0 
	 	 if(a[i].opt==3 && !a[a[i].pre].used) add(tot+1,1),add(a[i].Ins,-1),a[a[i].pre].used=1; // a>0 || (a==0 && b>c)
	 	 if(a[i].opt==4 && !a[a[i].pre].used) add(a[i].Ins+1,1),add(1,-1),a[a[i].pre].used=1; // a<0
	 	 if(a[i].opt==5) printf("%d\n",query(a[i].Ins));
	 }
     //fclose(stdin);
     //fclose(stdout);
     return 0;
}
```

---

## 作者：Remake_ (赞：1)

由幼儿园知识可得：

若$a=0$且$b>c$，则此不等式的解集为$x\in \mathbb{R}$。

若$a=0$且$b\leq c$，则此不等式的解集为$x\in\varnothing$。

若$a>0$，则此不等式的解集为$x>\frac{c-b}{a}$。

若$a<0$，则此不等式的解集为$x<\frac{c-b}{a}$。

接下来我们的思路是对于$a=0$，$a>0$，$a<0$分别统计，$a=0$时直接用一个变量记录$b>c$的个数，同时删除$a=0$且$b>c$的不等式时那个变量也要对应减少。对于后两者，我们发现解集显然满足单调性（因为是$1$次不等式），所以两个都按照升序维护然后分别二分查找一下就得到满足的不等式个数了。

接下来看看代码实现。

此题正解是平衡树或树状数组不用说，但是写起来好麻烦啊~~事实上是因为我只会理论不会代码实现~~。紧接着我们看到$n\leq10^5$，嗯，数据不是5e5，卡不掉维克托。

所以可以利用插排的思想去维护，删除的话可以利用二分查找。

代码贼好写，稍微注意一下细节即可AC：

```cpp
#include <bits/stdc++.h>
using namespace std;
vector<long long> v1, v2;
long long n, a[100005], b[100005], c[100005], ii, k, tot, cnt;
unordered_map<long long, bool> mp;
string opt;
int main()
{
    cin >> n;
    v1.push_back(0x7fffffffffffffff);
    v2.push_back(0x7fffffffffffffff);
    for (int i = 1; i <= n; i++)
    {
        cin >> opt;
        if (opt == "Add")
        {
            cin >> a[++tot] >> b[tot] >> c[tot];
            if (a[tot] == 0 && b[tot] > c[tot])
                ++cnt;
            if (a[tot] > 0)
                v1.insert(upper_bound(v1.begin(), v1.end(), floor((c[tot] - b[tot]) * 1.0 / a[tot])), floor((c[tot] - b[tot]) * 1.0 / a[tot]));
            if (a[tot] < 0)
                v2.insert(upper_bound(v2.begin(), v2.end(), ceil((c[tot] - b[tot]) * 1.0 / a[tot])), ceil((c[tot] - b[tot]) * 1.0 / a[tot]));
        }
        if (opt == "Del")
        {
            cin >> ii;
            if (!mp[ii])
            {
                mp[ii] = 1;
                if (a[ii] == 0 && b[ii] > c[ii])
                    --cnt;
                if (a[ii] > 0)
                    v1.erase(lower_bound(v1.begin(), v1.end(), floor((c[ii] - b[ii]) * 1.0 / a[ii])));
                if (a[ii] < 0)
                    v2.erase(lower_bound(v2.begin(), v2.end(), ceil((c[ii] - b[ii]) * 1.0 / a[ii])));
            }
        }
        if (opt == "Query")
        {
            cin >> k;
            cout << cnt + (lower_bound(v1.begin(), v1.end(), k) - v1.begin()) + (v2.end() - upper_bound(v2.begin(), v2.end(), k) - 1) << endl;
        }
    }
}
```


---

## 作者：Troubadour (赞：0)

[传送门](https://www.luogu.com.cn/problem/P5482)

这道题细节挺多的。

因为给出的都是一元一次不等式，所以我们可以轻松的把它解出来，得到 $x$ 的取值范围。

那么，问题就转化为：有 $n$ 个区间 $[l_i,r_i](1\le i \le n)$，需要支持以下三种操作：

- 添加一个区间；
- 删除一个区间；
- 查询对于 $x=k$ ，$x$在多少个区间内。 

然后我们很愉快的看到，$|k|\in [-10^{6},10^{6}]$，所以我们把区间算出来之后，对于那些出界的，直接无视就可以了。

接下来我们来考虑解不等式的一些细节：

$a>0$ 时，可以得到
$$x>\frac{c-b}a$$
所以，我们得到的区间就是 $[\lceil\frac{c-b}a\rceil+1,10^6]$。

$a<0$ 时，可以得到
$$x<\frac{c-b}a$$
所以，我们得到的区间就是 $[-10^6,\lfloor\frac{c-b}a\rfloor+1]$。

$a=0$ 时，不用管什么区间了，直接判断是否成立，新开一个变量记录恒成立的出现次数，统计时直接加上。

区间操作，我们就很容易想到：可以对值域开一棵权值线段树，然后把这些区间一个一个的刷上去，每次给区间内的每个节点加 $1$，统计时直接查询，再加上那些恒成立的即可。一开始我还在想用不用考虑下标的正负问题，事实证明完全不需要考虑。

接下来我们来考虑删除操作：

很容易发现，像这样线段树上操作是可逆的。因为保证操作合法，所以我们只需要给这个区间加上一个 $-1$ 就当做删除了。

对于那些恒成立的或恒不成立的不等式，特判一下即可。

这道题还有一个坑点，就是可能多次删除同一个不等式，所以我们还得给它们加上一个标记。

最后，这道题卡精度，请务必注意。
### Code：
```
#include<bits/stdc++.h>
#pragma warning(disable:4996)
namespace CCCP
{
	int debug;
	const int N = 2e6 + 5;
	struct Inequality
	{
		int l, r, tag;
	}q[N];//所有的区间
	int always;//恒成立不等式的数量
	int cnt, g[N], a[N], n, tot;
	struct seg
	{
		int l, r, val, lazy;
	}f[N << 3];//下面是线段树的基本操作
	inline int len(int p)
	{
		return f[p].r - f[p].l + 1;
	}
	void update(int p)
	{
		f[p].val = f[p << 1].val + f[p << 1 | 1].val;
	}
	void brush(int p, int k)
	{
		f[p].val += len(p)*k;
		f[p].lazy += k;
	}
	void push_down(int p)
	{
		brush(p << 1, f[p].lazy);
		brush(p << 1 | 1, f[p].lazy);
		f[p].lazy = 0;
	}
	void build(int p, int l, int r)
	{
		f[p].l = l;f[p].r = r;
		if (l == r)
		{
			f[p].val = 0;
			return;
		}
		int mid = (l + r) >> 1;
		build(p << 1, l, mid);
		build(p << 1 | 1, mid + 1, r);
	}
	void modify(int p, int l, int r, int k)
	{
		if (l <= f[p].l&&f[p].r <= r)
		{
			brush(p, k);
			return;
		}
		push_down(p);
		int mid = (f[p].l + f[p].r) >> 1;
		if (mid >= l) modify(p << 1, l, r, k);
		if (mid < r) modify(p << 1 | 1, l, r, k);
		update(p);
	}
	int query(int p, int l, int r)
	{
		if (l <= f[p].l && f[p].r <= r) return f[p].val;
		push_down(p);
		int res = 0;
		int mid = (f[p].l + f[p].r) >> 1;
		if (mid >= l) res += query(p << 1, l, r);
		if (mid < r) res += query(p << 1 | 1, l, r);
		return res;
	}
	void work()
	{
		scanf("%d", &n);
		build(1, -1e6, 1e6);
		for (int i = 1;i <= n;i++)
		{
			char opt[10];
			int a, b, c, j, k;
			scanf("%s", opt);
			if (opt[0] == 'A')
			{
				int i = ++tot;
				q[i].l = -1e6, q[i].r = 1e6;
				scanf("%d%d%d", &a, &b, &c);
				if (a == 0)
				{
					if (b > c) always++,q[i].tag = 3;
					else q[i].tag = 2;
					continue;
				}
				if (a < 0) q[i].r = std::min((int)ceil(1.0*(c - b) / a) -1, 1000000);//控制边界。为什么这里不写1e6？因为1e6默认double类型，直接和整型比较会CE，而我懒得加强转
				else q[i].l = std::max((int)floor(1.0*(c - b) / a) + 1, 1*-1000000);
				if (q[i].l > 1e6 || q[i].r < -1e6)
				{
					q[i].tag = 2;//就当恒不成立了
					continue;
				}
				modify(1, q[i].l, q[i].r, 1);//加入一个区间，给这个区间内所有节点+1
			}
			else if (opt[0] == 'D')
			{
				scanf("%d", &j);
				if (q[j].tag == 1||q[j].tag==2)continue;//特判已经删过的和恒不成立的
				else if (q[j].tag == 3)
				{
					always--,q[j].tag = 1;
					continue;
				}//特判恒成立的
				q[j].tag = 1;
				modify(1, q[j].l, q[j].r, -1);//删除一个区间，给这个区间内所有节点-1.
			}
			else
			{
				scanf("%d", &k);
				printf("%d\n", query(1, k , k ) + always);
			}
		}
	}
}
int main()
{
	return CCCP::work(), 0;
}
```

---

## 作者：SmallTownKid (赞：0)

显然的平衡树，但可以使用vector+二分代替。

分类讨论： $a>0,a<0,a=0$ 。

 $a<0$ 时， $x$ 需要严格小于一个数，$a>0$ 时， $x$ 需要严格大于一个数。

 $a=0$ 时直接特判就可以，恒成立或恒不成立。

建立两棵平衡树，维护单调性就可以了。

需要注意的是，由于要删除第 $i$ 个插入的，我们没法直接访问下标，因为vector的下标随时在发生变化，所以可以考虑在vector中删除 $i$ 下标对应的值，也算是一个技巧吧。

还有，为了防止二分查找到一个奇奇怪怪的数，要先放入一个极大值。但最后要再 $-1$ 。这种下标的问题推荐画个图自己算一下，不然很容易出错。

```
#include<bits/stdc++.h>
#define int long long
const int INF=1e18;
using namespace std;
int idx,n,cnt;
string str;
vector<int> g1,g2;//g1维护a<0时的答案，g2维护a>0时的答案
map<int,int> mp;
int a[1000010],b[1000010],c[1000010];
signed main()
{
	cin>>n;
	g1.push_back(INF);
	g2.push_back(INF);
	while(n--)
	{
		cin>>str;
		if(str[0]=='A')
		{
			idx++;//第几次插入 
			scanf("%lld%lld%lld",&a[idx],&b[idx],&c[idx]);
			if(a[idx]<0)
			{
				int x=ceil(1.0*(c[idx]-b[idx])/(a[idx]));
				g1.insert(lower_bound(g1.begin(),g1.end(),x),x);
				//要成立这个数必须要严格小于x 
			}
			if(a[idx]>0)
			{
				int x=floor(1.0*(c[idx]-b[idx])/a[idx]);
				g2.insert(lower_bound(g2.begin(),g2.end(),x),x);
			}
			if(a[idx]==0&&b[idx]>c[idx])
			{
				cnt++;
			} 
		}
		if(str[0]=='D')
		{
			int x;
			scanf("%lld",&x);
			if(!mp[x])
			{
				mp[x]=1;
				if(a[x]==0&&b[x]>c[x])
				cnt--;
				if(a[x]<0)//由于下标不方便删除，删除下标对应的值，二分查找即可 
				{
					int num=ceil(1.0*(c[x]-b[x])/(a[x]));
					g1.erase(lower_bound(g1.begin(),g1.end(),num));
				}
				if(a[x]>0)
				{
					int num=floor(1.0*(c[x]-b[x])/a[x]);
					g2.erase(lower_bound(g2.begin(),g2.end(),num));
				}
			}
		}
		if(str[0]=='Q')
		{
			int x;
			scanf("%lld",&x);
			int ans1=g1.end()-upper_bound(g1.begin(),g1.end(),x)-1;
			int ans2=lower_bound(g2.begin(),g2.end(),x)-g2.begin();
			printf("%lld\n",cnt+ans1+ans2);
		}
	}
	return 0;
} 
```

---

## 作者：Zesty_Fox (赞：0)

先来分析一下题目。

显然，对于每一个添加的不等式，有3种情况：

1. $a<0$ 。此时可转换为 $x < {{a} \over {c-b}} $ 。

   但是，我们发现 $ {a} \over {c-b} $ 这货是实数，容易产生误差，不好处理。

   但我们又发现，询问的 $k$ 一定是整数。于是，我们可以把上面不等式转换为整数。

   怎么转换？显然对于 $\forall x \in \mathbb{Z} ,  x < a  \iff x< \lceil a \rceil$。

   所以，这不就转化成 $x < \lceil {{a} \over {c-b}} \rceil$ 了吗。

2. $a=0$ 。此时直接判断是否有 $b>c$ 。若有，则在树状数组中全部 $+1$ ；反之则不变。

3. $a>0$ 。与第一种情况类似，可以转化成 $x > \lfloor {{a} \over {c-b}} \rfloor$ 。

那么，我们只要把上面提到的 $\lceil {{a} \over {c-b}} \rceil$ 、 $ \lfloor {{a} \over {c-b}} \rfloor $ 和询问提到的所有数放在一起离散化一下，用树状数组统计即可。

最后注意一个坑人的点：一个不等式可能被多次删除，这时候就不要重复统计了。

Code：(236ms)

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
using namespace std;
typedef long long ll;
const int N=100010;
struct Operation{int typ,a,b,c,val;}p[N];
int n,cnt,id[N<<1],cntd,raw[N<<1],vis[N<<1];
//raw即为离散化数组；id[i]则记第i条添加的不等式序号为多少
struct TA{//树状数组+查分
#define lowbit(x) ((x)&(-(x)))
    int c[N<<1];
    inline void add(int x,int val){
        for(;x<=cnt+1;x+=lowbit(x)) c[x]+=val;
    }
    inline void modify(int l,int r,int val){ //区间加
        add(l,val);add(r+1,-val);
    }
    int query(int x){//单点查询
        int res=0;
        for(;x>0;x-=lowbit(x)) res+=c[x];
        return res;
    }
#undef lowbit
}ta;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){ //先把操作存起来
        char op[8];int a,b,c;
        scanf("%s",op);
        if(op[0]=='A'){
            scanf("%d%d%d",&a,&b,&c);
            p[i]=(Operation){1,a,b,c};
            if(a<0) p[i].val=ceil(1.0*(c-b)/a);
            else if(a>0) p[i].val=floor(1.0*(c-b)/a);
            id[++cntd]=i;
            raw[++cnt]=p[i].val;
        }
        if(op[0]=='Q'){
            scanf("%d",&a);
            p[i]=Operation{2,a};
            raw[++cnt]=a;
        }
        if(op[0]=='D'){
            scanf("%d",&a);
            p[i]=Operation{3,a};
        }
    }
    sort(raw+1,raw+cnt+1);cnt=unique(raw+1,raw+cnt+1)-raw-1;
    for(int i=1;i<=n;i++){
        //把所有的数值改为离散化后的值
        if(p[i].typ==1) p[i].val=lower_bound(raw+1,raw+cnt+1,p[i].val)-raw;
        if(p[i].typ==2) p[i].a=lower_bound(raw+1,raw+cnt+1,p[i].a)-raw;
    }
    for(int i=1;i<=n;i++){
        if(p[i].typ==1){
            //判断+修改
            if(p[i].a<0) ta.modify(1,p[i].val-1,1);
            else if(p[i].a>0) ta.modify(p[i].val+1,cnt,1);
            else ta.modify(1,cnt,p[i].b>p[i].c?1:0);
        }
        if(p[i].typ==2) printf("%d\n",ta.query(p[i].a));
        if(p[i].typ==3){
            int x=id[p[i].a];
            if(vis[x]) continue;
            vis[x]=1;
            if(p[x].a<0) ta.modify(1,p[x].val-1,-1);
            else if(p[x].a>0) ta.modify(p[x].val+1,cnt,-1);
            else ta.modify(1,cnt,p[x].b>p[x].c?-1:0);
        }
    }
    return 0;
}
```



---

## 作者：logwzc (赞：0)

# 平衡树做法
先对a的正负情况分类。

a = 0，如果b > c 那么恒成立，否则恒不成立。

a > 0，这时我们可以求出一个最小的x使不等式成立。

a < 0，这时我们可以求出一个最大的x使不等式成立。

考虑统计答案。

对a > 0的不等式，假如我们算得的x不大于k，那么就是合法的。

对a < 0的不等式，假如我们算得的x不小于k，那么就是合法的。

所以我们对a > 0和a < 0的不等式各建一颗平衡树。答案 = 恒成立 + 第一颗平衡树中不大于k的数的数量 + 第二颗平衡树中不小于k的数的数量。

代码 (可旋Treap)
```cpp
#include<bits/stdc++.h>
#define N 100010
using namespace std;
template<typename T> void Read(T &X){
	X=0;char C=getchar();T Sig=1;
	for (;!isdigit(C);C=getchar()) if (C=='-') Sig=-1;
	for (; isdigit(C);C=getchar()) X=(X<<3)+(X<<1)+C-'0';
	X*=Sig;
}
int Q;
int root1,root2,tot,len;
struct node{
	int v,type;
	bool flag;
};
node rec[N];
int extra;
inline int rand(){
	static int seed=12345;
	return seed=(int)seed*432841LL%2147483647;
}
struct tree{
	int val,data,cnt,size,son[2];
	void crt(int x){
		val=x;
		data=rand();
		size=cnt=1;
		return;
	}
};
tree tr[N];
#define ls tr[p].son[0]
#define rs tr[p].son[1]
void update(int p){
	tr[p].size=tr[ls].size+tr[rs].size+tr[p].cnt;
	return;
}
void rotate(int &p,int d){
	int son=tr[p].son[d];
	tr[p].son[d]=tr[son].son[d^1];
	tr[son].son[d^1]=p;
	update(p);
	update(p=son);
	return;
}
void insert(int &p,int x){
	if (!p){
		p=++tot;
		tr[p].crt(x);
		return;
	}
	tr[p].size++;
	if (tr[p].val==x){
		tr[p].cnt++;
		return;
	}
	int d=x>tr[p].val;
	insert(tr[p].son[d],x);
	if (tr[tr[p].son[d]].data<tr[p].data) rotate(p,d);
	return;
}
void delet(int &p,int v){
	if (!p) return;
	if (tr[p].val==v){
		if (tr[p].cnt>1){
			tr[p].size--;
			tr[p].cnt--;
			return;
		}
		bool d=tr[ls].data>tr[rs].data;
		if (!ls||!rs) p=ls+rs;
		else rotate(p,d),delet(p,v);
	}
	else{
		tr[p].size--;
		delet(tr[p].son[v>tr[p].val],v);
	}
	return;
}
int rk1(int p,int v){
	if (!p) return 0;
	if (tr[p].val==v) return tr[ls].size+tr[p].cnt;
	if (tr[p].val>v) return rk1(ls,v);
	return rk1(rs,v)+tr[ls].size+tr[p].cnt;
}
int rk2(int p,int v){
	if (!p) return 0;
	if (tr[p].val==v) return tr[rs].size+tr[p].cnt;
	if (tr[p].val>v) return rk2(ls,v)+tr[rs].size+tr[p].cnt;
	return rk2(rs,v);
}
int main(){
	Read(Q);
	while (Q--){
		char ch;
		ch=getchar();
		for (;ch!='A'&&ch!='Q'&&ch!='D';ch=getchar());
		if (ch=='A'){
			int a,b,c;
			Read(a);Read(b);Read(c);
			c-=b;
			rec[++len].flag=true;
			if (!a){
				if (c<0){
					extra++;
					rec[len].type=2;
				}
				else rec[len].type=3;
			}
			else if (a>0){
				c++;
				rec[len].v=c/a;
				if (c>0&&c%a) rec[len].v++;
				insert(root1,rec[len].v);
			}
			else{
				c++;
				rec[len].v=c/a;
				if (c>0&&c%a) rec[len].v--;
				rec[len].type=1;
				insert(root2,rec[len].v);
			}
		}
		else if (ch=='D'){
			int id;
			Read(id);
			if (!rec[id].flag) continue;
			rec[id].flag=false;
			if (rec[id].type==1) delet(root2,rec[id].v);
			else if (!rec[id].type) delet(root1,rec[id].v);
			else if (rec[id].type==2) extra--;
		}
		else{
			int k;
			Read(k);
			printf("%d\n",rk1(root1,k)+rk2(root2,k)+extra);
		}
	}
	return 0;
}

```


---


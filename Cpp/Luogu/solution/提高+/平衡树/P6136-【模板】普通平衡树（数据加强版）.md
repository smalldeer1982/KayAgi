# 【模板】普通平衡树（数据加强版）

## 题目背景

本题是 P3369 数据加强版，**扩大数据范围**并增加了**强制在线**。

**题目的输入、输出和原题略有不同**，但需要支持的操作相同。

## 题目描述

您需要动态地维护一个可重集合 $M$，并且提供以下操作：

1. 向 $M$ 中插入一个数 $x$。
2. 从 $M$ 中删除一个数 $x$（若有多个相同的数，应只删除一个）。
3. 查询 $M$ 中有多少个数比 $x$ 小，并且将得到的答案加一。
4. 查询如果将 $M$ 从小到大排列后，排名位于第 $x$ 位的数。
5. 查询 $M$ 中 $x$ 的前驱（前驱定义为小于 $x$，且最大的数）。
6. 查询 $M$ 中 $x$ 的后继（后继定义为大于 $x$，且最小的数）。

本题**强制在线**，保证所有操作合法（操作 $2$ 保证存在至少一个 $x$，操作 $4,5,6$ 保证存在答案）。

## 说明/提示

### 样例解释

样例加密前为：
```plain
6 7
1 1 4 5 1 4
2 1
1 9
4 1
5 9
3 8
6 1
1 0
```

### 限制与约定

对于 $100\%$ 的数据，$1\leq n\leq 10^5$，$1\leq m\leq 10^6$，$0\leq a_i,x\lt 2^{30}$。

**本题输入数据较大，请使用较快的读入方式。**

---

$\text{upd 2022.7.22}$：新增加 $9$ 组 Hack 数据。

## 样例 #1

### 输入

```
6 7
1 1 4 5 1 4
2 1
1 9
4 1
5 8
3 13
6 7
1 4
```

### 输出

```
6
```

# 题解

## 作者：EternalAlexander (赞：196)

发现毒瘤们想强迫我们写平衡树，因此，我们考虑怎么不写平衡树。

发现有个东西叫做 01trie。这玩意可以当平衡树用，不会的可以看[这里](https://www.luogu.com.cn/blog/GeorgeJia/solution-p3369)。

然而并不能通过这个题，因为可恶的毒瘤们卡了空间，而 01trie 的空间复杂度是 $O(n\log w)$，其中 $w$ 是值域。

然而，这棵树的叶节点数量是 $O(n)$ 的，因此，假如我们能通过某种办法把它的所有单链压缩起来，这棵树上的节点数就会变成 $O(n)$。因为所有 $n$ 个叶节点的虚树大小只有 $O(n)$。

![](https://cdn.luogu.com.cn/upload/image_hosting/o1yziaa2.png)

实现起来，大概就是和普通 01trie 一样地从根节点向下匹配，然后假如遇到失配，就分裂当前节点。

如果你学习过[后缀树](https://www.luogu.com.cn/blog/EternalAlexander/xuan-ku-hou-zhui-shu-mo-shu)，你会发现这个东西的实现方式和后缀树非常类似。

这样，空间复杂度可以达到 $O(n)$，我们就能愉快地不写平衡树而通过本题了。


```cpp
#include <bits/stdc++.h>
const int maxn = 2000005,lim=30;
const int base=1e7;
int g(int x,int i){return (x>>i)&1;}
int reverse(int x){
	int ans=0;
	for(int i=0;i<lim;++i)ans+=g(x,i)<<(lim-i-1);
	return ans;
}
struct compressed_trie {
	int ch[maxn*2][2],d[maxn*2],v[maxn*2],pt[maxn*2],size[maxn*2],tl=1;
	int newnode(int p,int dep){
		pt[++tl]=p;d[tl]=dep;return tl;
	}void insert(int x,int det){
		int v1=x;x=reverse(x);
		int rt=1,rem=0,last=0;
		for(int i=0;i<lim;++i){
			rem++;int c1=g(x,i);
			while(i>d[rt]){
				if(!ch[rt][c1]){
					ch[rt][c1]=newnode(x>>i,lim);
					v[tl]=v1;
					size[ch[rt][c1]]=det;
					return;
				}last=rt;rem=i-d[rt];rt=ch[rt][c1];
				size[last]+=det;
			}int c2=g(pt[rt],rem-1);
			if(c1!=c2){
				int u=newnode(pt[rt],i-1);size[u]=size[rt]+det;
				ch[u][c2]=rt;ch[u][c1]=newnode(x>>i,lim);
				ch[last][g(pt[rt],0)]=u;
				pt[rt]>>=(rem-1);
				last=u;rt=ch[u][c1];rem=1;size[rt]+=det;v[rt]=v1;
				return;
			}
		}size[rt]+=det;
	}int rank(int x){
		insert(x,0);
		x=reverse(x);int rt=1,ans=0;	
		for(int i=0;i<lim;++i){
			int c1=g(x,i);
			while(i>d[rt]){
				if(c1==1)ans+=size[ch[rt][0]];
				rt=ch[rt][c1];
			}
		}return ans;
	}int kth(int x,int rt=1){
		if(rt==1)insert(x,0);
		if(!ch[rt][0]&&!ch[rt][1])return v[rt];
		if(x<=size[ch[rt][0]])return kth(x,ch[rt][0]);
		else return kth(x-size[ch[rt][0]],ch[rt][1]);
	}	
}T; 
int opt,t,n,q,sum,lastans;
int main() {
	T.d[1]=-1;
    scanf("%d%d",&n,&q);
    for(int i=1;i<=n;++i){scanf("%d",&t);T.insert(t,1);}
	while (q--) {
		scanf("%d %d",&opt,&t);t^=lastans;
		if (opt==1) T.insert(t, 1);
		if (opt==2) T.insert(t, -1);
		if(opt<=2)continue;
		if (opt==3)lastans=T.rank(t)+1;
		if (opt==4)lastans=T.kth(t);
		if (opt==5)lastans=T.kth(T.rank(t));
		if (opt==6)lastans=T.kth(T.rank(t+1)+1);
		sum^=lastans;
	}printf("%d",sum);
	return 0;
}
```



---

## 作者：zhy137036 (赞：125)

FHQ-Treap 是平衡树中码量很小的一种。

- 特点
- 操作
  - 分裂
  - 合并
  - 插入
  - 删除
  - 查询排名
  - 根据排名找数
  - 前驱
  - 后继
- 复杂度
- 代码

## 特点

Treap 这个词是由 Tree 和 Heap 组合形成的，可以看出 Treap 是查找树和堆的结合，因此中文叫树堆。

每个结点除保存一个值两个子节点外，还保存一个随机权；不过不保存父结点，这就是 Treap 码量小的原因。

和其他平衡树一样，Treap 的中序遍历 值单调不减；而根据堆的性质，每个结点的权小于两个子结点的权。

Treap 分为有旋和无旋两种，而无旋 Treap 是由范浩强发明的，所以又叫 FHQ-Treap。

本文要介绍无旋 Treap。

## 操作

### 分裂

分裂操作是将一个 Treap 分成 $x,y$ 两个 Treap。其中 $x$ 中每一个结点的值都小于 $k$，而 $y$ 中每一个结点的值都大于等于 $k$。

举个例子（$k=4$）：

![](https://cdn.luogu.com.cn/upload/image_hosting/jubdyomh.png)

（上图中的数均代表值而非权或编号）

如果当前子树的根的值大于等于 $k$，就继续分裂左子树，并将分出来的右边的子树作为根节点的左子树；否则分裂右子树，并将分出来的左边的子树作为根节点的右子树。

上面这段话对应到上图就是，因为根节点的值 $5$ 大于等于 $k=4$，所以继续分裂以 $2$ 为根的子树，分出来 $\left\{1,2,3\right\}$ 和 $\left\{4\right\}$ 两个子树，并将 $\left\{4\right\}$ 作为 $5$ 的左子树；  
（继续分裂以 $2$ 为根的子树）因为 $2$ 小于 $k=4$，所以继续分裂以 $4$ 为根的子树，分出来 $\left\{3\right\}$ 和 $\left\{4\right\}$ 两个子树，并将 $\left\{3\right\}$ 作为 $2$ 的右子树。

（上面混淆了值和编号，是为了让句子简洁一些）

认真读完上面的话之后，可以看出要用递归实现。

函数 `split` 接受一个根和一个 $k$，返回分裂后的两棵子树的根。

```
struct pair{//要返回两个值，得用 pair
	int a,b;
	pair(int a_=0,int b_=0) { a=a_; b=b_; }//构造函数
};
pair split(int u,int k){//u 是根
	if(!u) return pair(0,0);//空树返回空
	if(key[u]<k){//如果值小于 k
		pair t=split(son[u][1],k);//分裂右子树
        //son[u][0]表示左子节点，son[u][1]表示右子节点
		son[u][1]=t.a;//将左边的子树作为根的右子树
		pushup(u);//重新计算子树大小
		return pair(u,t.b);//返回（结合上面的图应该可以理解）
	}else{//反之同理
		pair t=split(son[u][0],k);
		son[u][0]=t.b;
		pushup(u);
		return pair(t.a,u);
	}
}
```

### 合并

合并是将 $x,y$ 两个 Treap 合并为一个 Treap（$x$ 中的每一个结点的值都小于等于 $y$ 中每一个结点的值）

![](https://cdn.luogu.com.cn/upload/image_hosting/bheudsa4.png)

（其中绿色的数代表随机权）

比较两个树根的权，权大的作为权小的子结点，继续合并子树。

比如这张图，因为 $2>1$，所以将 $\left\{1,2,3\right\}$ 作为 $\left\{4,5,6,7,8\right\}$ 的根的左子树，继续合并 $\left\{1,2,3\right\}$ 和 $\left\{4\right\}$；  
因为 $2<3$，所以将 $\left\{4\right\}$ 作为 $\left\{1,2,3\right\}$ 的根的右子树，继续合并 $\left\{3\right\}$ 和 $\left\{4\right\}$。  
. . . . . . 

`merge` 函数接受两个参数，为两棵树的根；返回合并后的根。

```cpp
int merge(int u,int v){
	if(!u||!v) return u+v;//如果任何一棵树为空，返回另一棵树
	if(wei[u]<wei[v]){//比较随机权
		son[u][1]=merge(son[u][1],v);
        //将右子树和另一棵树合并，作为右子树
		pushup(u);//重新计算子树大小
		return u;//最终根为 u
	}else{//反之同理
		son[v][0]=merge(u,son[v][0]);
		pushup(v);
		return v;
	}
}
```

### 插入结点

比如，要插入一个值为 $k$ 的结点，怎么办呢？

先将申请一个新的结点，作为一棵树 $y$；并将原来的树分裂成 $x,z$ 两棵树。  
然后依次合并 $x,y,z$，就完成了。

```cpp
void insert(int k){
	key[++cnt]=k; wei[cnt]=rand1(); size[cnt]=1;
    //申请一个节点，作为一棵树，其大小为 1
	pair t=split(root,k);//以 k 为关键值分裂
	root=merge(merge(t.a,cnt),t.b);//依次合并，更新根
}
```

### 删除结点

删除比较巧妙，先将树分裂成 $x,y,z$ 三棵树；其中 $x$ 的每个结点的值均小于 $k$，$y$ 的每个结点的值均为 $k$，$z$ 的每个结点的值均大于 $k$。

然后目标就是要在 $y$ 中删除仅一个结点，怎么办呢？

做法是，直接合并 $y$ 的左右两棵子树，根节点就被删除掉了。

接下来的事情都知道了，依次合并 $x,y,z$。

```cpp
void eraser(int k){
	pair x,y;
	x=split(root,k);
    //将整棵树分为小于 k 的和大于等于 k 的
	y=split(x.b,k+1);
    //将大于等于 k 的分为等于 k 的和大于 k 的
	y.a=merge(son[y.a][0],son[y.a][1]);
    //直接合并 y.a 的两棵子树
	root=merge(x.a,merge(y.a,y.b));
    //依次合并起来，更新根
}
```

### 查询排名

直接分裂，并将值小于 $k$ 的树的大小加一，返回。

```cpp
int find1(int k){
	int re;
	pair t=split(root,k);//分裂
	re=size[t.a]+1;//将值小的树的结点数 +1 作为答案
	root=merge(t.a,t.b);//合并回去
	return re;//返回
}
```

### 根据排名找数

这次没法分裂合并了qwq。

![](https://cdn.luogu.com.cn/upload/image_hosting/izyszovf.png)

这次结点上的数就是结点编号了，因为结点的值和权没有用。

比如要找第 $3$ 个数，让我们从根节点开始。

首先，$1$ 号结点的左子树有 $4$ 个结点，那第 $3$ 个结点肯定在左子树了，于是去找左子树的第 $3$ 个结点；  
然后，发现 $2$ 号结点的左子树只有 $1$ 个结点，那第 $3$ 个结点肯定在右子树了，于是去找 $2$ 号结点的右子树的第 $1$ 个结点；  
接着，发现 $5$ 号结点的左子树有 $1$ 个结点，那第 $1$ 个结点肯定在左子树了，于是去找 $5$ 号结点的左子树的第 $1$ 个结点；  
最后，发现 $8$ 号结点的左子树只有 $0$ 个结点，那 $8$ 号结点自己肯定就是答案了，于是返回自己的值。

有循环和递归两种实现方式。

```cpp
int find2(int k){
	int pos=root;//当前结点初始为根
	while(pos){
		if(k==size[son[pos][0]]+1) return key[pos];
        //如果要找的正是当前结点，直接返回
		if(k<=size[son[pos][0]]) pos=son[pos][0];
        //如果要找的在左子树，当前节点转为左子节点
		else { k-=size[son[pos][0]]+1; pos=son[pos][1]; }
        //否则不仅当前结点转为右子节点，还要将 k 减去左子树大小+1
	}
}
```

```cpp
int find2(int u,int k){
	if(k==size[son[u][0]]+1) return key[u];
    //如果要找的正是当前结点，返回本节点
	if(k<=size[son[u][0]]) return find2(son[u][0],k);
    //如果要找的在左子树，返回左子树的第 k 个结点
	else return find2(son[u][1],k-size[son[u][0]]-1);
    //否则返回右子树的结点，还是要减去那个数
}
```

###  前驱

什么叫“小于 $k$，且最大的数”？不就是前面的那个数吗，所以直接查找排名比 $k$ 的排名少一的数。

```cpp
int lst(int k) { return find2(find1(k)-1); }
```

### 后继

值相同的结点可能不止一个，所以不能找后面的那个数了，但是可以将值加一，查询它的排名，并找到对应的值。

不好理解？看下面的例子：

```plain
1,1,2,2,4,4,5,5
```

要找 $2$ 的后继。  
先查询 $3$ 的排名，即小于 $3$ 的元素个数 $+1$，查询结果为 $5$。  
查询第 $5$ 个数，为 $4$。结束。

```cpp
int nxt(int k) { return find2(find1(k+1)); }
```

## 复杂度

对于一个数集，排序后就是 Treap 的中序遍历；而根肯定是随机权最小的结点，因此期望位置在正中间；所以这棵树期望平衡；所以复杂度为 $O(\log n)$。

## 完整代码

```cpp
#include<cstdio>
#define maxn 1100010
struct pair{
	int a,b;
	pair(int a_=0,int b_=0) { a=a_; b=b_; }
};
int read(){
    int ans=0; char ch=getchar();
    while(ch>'9'||ch<'0')ch=getchar();
    while(ch<='9'&&ch>='0'){
        ans=ans*10+ch-'0';
        ch=getchar();
    }
    return ans;
}
int key[maxn],wei[maxn],size[maxn],son[maxn][2];
int n,m,cnt,ans,seed=1,root,last;
int rand1() { return seed*=19260817; }
inline void pushup(int u)
	{ size[u]=size[son[u][0]]+size[son[u][1]]+1; }
pair split(int u,int k){
	if(!u) return pair(0,0);
	if(key[u]<k){
		pair t=split(son[u][1],k);
		son[u][1]=t.a;
		pushup(u);
		return pair(u,t.b);
	}else{
		pair t=split(son[u][0],k);
		son[u][0]=t.b;
		pushup(u);
		return pair(t.a,u);
	}
}
int merge(int u,int v){
	if(!u||!v) return u+v;
	if(wei[u]<wei[v]){
		son[u][1]=merge(son[u][1],v);
		pushup(u);
		return u;
	}else{
		son[v][0]=merge(u,son[v][0]);
		pushup(v);
		return v;
	}
}
void insert(int k){
	key[++cnt]=k; wei[cnt]=rand1(); size[cnt]=1;
	pair t=split(root,k);
	root=merge(merge(t.a,cnt),t.b);
}
void eraser(int k){
	pair x,y;
	x=split(root,k);
	y=split(x.b,k+1);
	y.a=merge(son[y.a][0],son[y.a][1]);
	root=merge(x.a,merge(y.a,y.b));
}
int find1(int k){
	int re;
	pair t=split(root,k);
	re=size[t.a]+1;
	root=merge(t.a,t.b);
	return re;
}
int find2(int k){
	int pos=root;
	while(pos){
		if(k==size[son[pos][0]]+1) return key[pos];
		if(k<=size[son[pos][0]]) pos=son[pos][0];
		else { k-=size[son[pos][0]]+1; pos=son[pos][1]; }
	}
}
int lst(int k) { return find2(find1(k)-1); }
int nxt(int k) { return find2(find1(k+1)); }
int main(){
	n=read(); m=read();
	for(int i=1;i<=n;i++){
		int a=read();
		insert(a);
	}
	for(int i=1;i<=m;i++){
		int o=read(),x; x=read();
		if(o==1) insert(x^last);
		if(o==2) eraser(x^last);
		if(o==3) { last=find1(x^last); ans^=last; }
		if(o==4) { last=find2(x^last); ans^=last; }
		if(o==5) { last=lst(x^last); ans^=last; }
		if(o==6) { last=nxt(x^last); ans^=last; }
	}
	printf("%d\n",ans);
	return 0;
}
```

[记录](/record/32383047)

---

## 作者：BFqwq (赞：83)

## WBLT

由于考虑到等会有又是一堆 splay，treap，顾先为 WBLT 党占个坑。

WBLT 是一种 leafy tree。所谓 leafy tree，就是指所有的信息放在叶节点上，然后内部节点维护叶节点的合并信息。

这好像很像我们熟悉的线段树，因此，线段树就是一类 leafy tree。

因此 WBLT 的查询操作与线段树十分相似，需要走到叶节点才能完成查询。

#### 先看看变量

```cpp
const int ratio=4; 
struct lef{
	int v,w,ls,rs;
}t[maxn*80];
int rt,tot,ans,lastans;
void nnd(int &o,int v,int w,int ls,int rs){
    o=++tot;
    t[o]=(lef){v,w,ls,rs};
}
```

$ratio$ 是一个旋转因数，可以自行设置，一般来说 $4$ 是一个比合适的数字。

这个因数在修改中有用。

$v$ 是指这棵子树内最大的树的值。

$w$ 是指这棵子树的重量，也就是**叶**节点数量。注意**不**包括内部节点的数量。

$ls,rs$ 为左右儿子。

#### 查询操作

查询操作和线段树的写法没有什么区别。
```
int qrk(int o,int k) {
    if(t[o].w==1) return 1;
    if(k<=t[t[o].ls].v)return qrk(t[o].ls,k);
    else return t[t[o].ls].w+qrk(t[o].rs,k);
}
int qnm(int o,int k) {
    if(t[o].w==1) return t[o].v;
    if(k<=t[t[o].ls].w)return qnm(t[o].ls,k);
    else return qnm(t[o].rs,k-t[t[o].ls].w);
}
int pre(int rk,int x){
	return qnm(rt,qrk(rt,x)-1);
}
int suf(int rk,int x){
	return qnm(rt,qrk(rt,x+1));
}
```

对于查排名，只要不断比较该值与左边节点的 $v$ 值大小，确定进入左子树还是右子树。

查询 $kth$ 则不断比较与该节点左边节点的 $w$ 大小。

#### 调整操作

当左右节点的 $w$ 相差过大时（一般认定是一边大于另一边的 $ratio$ 倍）我们就需要做出调整。

调整的方式如下：如果右子树过大，则将左子树和右子树的左子树合并成一棵子树，右子树的右子树独立作一颗子树。

具体一点，是建立一个新节点作为当前节点的左儿子，新节点的左儿子是原来的 $ls$，新节点的右儿子是原来右儿子的 $ls$。

原来右儿子的 $rs$ 做当前节点的 $rs$。

左子树过大同理。

```cpp
void merge(int &o,int x,int y){
	nnd(o,t[y].v,t[x].w+t[y].w,x,y);
}
void maintain(int o){
    if(t[t[o].ls].w>t[t[o].rs].w*ratio){
		merge(t[o].rs,t[t[o].ls].rs,t[o].rs);
		t[o].ls=t[t[o].ls].ls;
	}
	if(t[t[o].rs].w>t[t[o].ls].w*ratio){
		merge(t[o].ls,t[o].ls,t[t[o].rs].ls);
		t[o].rs=t[t[o].rs].rs;
	}
}
```

由于我们是从下往上层层调整的，因此不用担心左儿子的右儿子过大这种事。

可以说，这一步保证了树的复杂度。

#### 插入操作

我们找到比这个数小的最大叶节点（或是大的最小叶节点），然后将这个叶节点分裂。

具体的方法为这个叶节点新建两个子节点，分别记录原来的数和新数。

然后原节点就作一个内部节点。

在修改的时候一路往上调整。

```cpp
void pushup(int o){
    if(!t[o].ls){
		t[o].w=1; 
		return;
	}
    t[o].w=t[t[o].ls].w+t[t[o].rs].w;
	t[o].v=t[t[o].rs].v;
}
void ins(int o,int x){
    if(t[o].w==1){
		nnd(t[o].ls,min(t[o].v,x),1,0,0);
		nnd(t[o].rs,max(t[o].v,x),1,0,0);
	}
    else{
		ins(x>t[t[o].ls].v?t[o].rs:t[o].ls,x);
	}
    pushup(o);maintain(o);
}
```
#### 删除操作

先找到要删掉的叶节点，然后判断。

如果这个叶节点的父节点没有另一个子节点，则直接删掉。

如果有另一个子节点，则让另一个子节点上位代替父节点的位置。

同样，一路调整。



```
void del(int o,int x){
    int wh,el;
    if(x<=t[t[o].ls].v) wh=t[o].ls,el=t[o].rs;
    else wh=t[o].rs,el=t[o].ls;
    if(t[wh].w==1)
        if(x==t[wh].v){
            t[o].ls=t[el].ls;
            t[o].rs=t[el].rs;
            t[o].v=t[el].v;
        }
		else return;
    else del(wh,x);
    pushup(o);maintain(o);  
}
```
#### 初始化

一开始要先建立一个根节点。一般来说，根节点的值选择 $inf$。（因为一开始根节点也是叶节点）

#### 代码
```
#include <bits/stdc++.h>
using namespace std;
inline int read(){
	register int x=0;
	register bool f=0;
	register char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-') f=1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<3)+(x<<1)+c-48;
		c=getchar();
	}
	return f?-x:x;
}
char cr[200];int tt;
inline void print(int x,char k='\n') {
    if(!x) putchar('0');
    if(x < 0) putchar('-'),x=-x;
    while(x) cr[++tt]=x%10+'0',x/=10;
    while(tt) putchar(cr[tt--]);
    putchar(k);
}
const int maxn=100010;
const int ratio=4; 
struct lef{
	int v,w,ls,rs;
}t[maxn*80];
int rt,tot,ans,lastans;
void nnd(int &o,int v,int w,int ls,int rs){
    o=++tot;
    t[o]=(lef){v,w,ls,rs};
}
void merge(int &o,int x,int y){
	nnd(o,t[y].v,t[x].w+t[y].w,x,y);
}
void pushup(int o){
    if(!t[o].ls){
		t[o].w=1; 
		return;
	}
    t[o].w=t[t[o].ls].w+t[t[o].rs].w;
	t[o].v=t[t[o].rs].v;
}
void maintain(int o){
    if(t[t[o].ls].w>t[t[o].rs].w*ratio){
		merge(t[o].rs,t[t[o].ls].rs,t[o].rs);
		t[o].ls=t[t[o].ls].ls;
	}
	if(t[t[o].rs].w>t[t[o].ls].w*ratio){
		merge(t[o].ls,t[o].ls,t[t[o].rs].ls);
		t[o].rs=t[t[o].rs].rs;
	}
}
int qrk(int o,int k) {
    if(t[o].w==1) return 1;
    if(k<=t[t[o].ls].v)return qrk(t[o].ls,k);
    else return t[t[o].ls].w+qrk(t[o].rs,k);
}
int qnm(int o,int k) {
    if(t[o].w==1) return t[o].v;
    if(k<=t[t[o].ls].w)return qnm(t[o].ls,k);
    else return qnm(t[o].rs,k-t[t[o].ls].w);
}
void ins(int o,int x){
    if(t[o].w==1){
		nnd(t[o].ls,min(t[o].v,x),1,0,0);
		nnd(t[o].rs,max(t[o].v,x),1,0,0);
	}
    else{
		ins(x>t[t[o].ls].v?t[o].rs:t[o].ls,x);
	}
    pushup(o);maintain(o);
}
void del(int o,int x){
    int wh,el;
    if(x<=t[t[o].ls].v) wh=t[o].ls,el=t[o].rs;
    else wh=t[o].rs,el=t[o].ls;
    if(t[wh].w==1)
        if(x==t[wh].v){
            t[o].ls=t[el].ls;
            t[o].rs=t[el].rs;
            t[o].v=t[el].v;
        }
		else return;
    else del(wh,x);
    pushup(o);maintain(o);  
}
int pre(int rk,int x){
	return qnm(rt,qrk(rt,x)-1);
}
int suf(int rk,int x){
	return qnm(rt,qrk(rt,x+1));
}
signed main(){
    int n=read(),m=read();
    nnd(rt,2147483647,1,0,0);
    for(int i=1;i<=n;i++){
    	int a=read();ins(rt,a);
	}
    while(m--){
        int opt=read(),x=read()^lastans;
        switch(opt){
            case 1:ins(rt,x);break;
            case 2:del(rt,x);break;
            case 3:lastans=qrk(rt,x);break;
            case 4:lastans=qnm(rt,x);break;
            case 5:lastans=pre(rt,x);break;
            case 6:lastans=suf(rt,x);break;
        }
        if(opt!=1&&opt!=2) ans^=lastans; 
    }
    print(ans);
    return 0;
}
```
















---

## 作者：AnneKH (赞：41)

## Splay

>
>伸展树（$\operatorname{Splay\ Tree}$），也叫分裂树，是一种二叉排序树，它能在 $\operatorname O(\log n)$ 内完成插入、查找和删除操作。它由丹尼尔·斯立特 Daniel Sleator 和 罗伯特·恩卓·塔扬 Robert Endre Tarjan 在1985年发明的。
>
>在伸展树上的一般操作都基于伸展操作：假设想要对一个二叉查找树执行一系列的查找操作，为了使整个查找时间更小，被查频率高的那些条目就应当经常处于靠近树根的位置。于是想到设计一个简单方法， 在每次查找之后对树进行重构，把被查找的条目搬移到离树根近一些的地方。伸展树应运而生。伸展树是一种自调整形式的二叉查找树，它会沿着从某个节点到树根之间的路径，通过一系列的旋转把这个节点搬移到树根去。
>
>它的优势在于不需要记录用于平衡树的冗余信息。
>

- 和大部分平衡树一样，Splay_Tree 中每个节点的左子树所有节点都比它小，右子树所有节点都比它大。每个节点要维护以下信息：
	- 值（$value$）
    - 重复次数（$count$）
    - 子树大小（$size$）
    - 家长编号（$mother$）
    - 孩子编号（$daughter_{0, 1}$）

- 时间复杂度简单证明（直观感受一下）：

	- 如果数据随机，那么树一定平衡；
    - 如果数据不随机，那么每次将要访问的节点搬移至根，可应付不随机的数据。

- 考虑如何旋转。

	- 考虑将某一结点上旋。
    
    ![](https://cdn.luogu.com.cn/upload/image_hosting/2dbxqdu8.png)
    
    ```cpp
	    //旋转相关代码
        bool inline get_id(unsigned int const x) const {
	        return tree[tree[x].mother].daughter[1] == x;
	    }
	    void const inline upto(unsigned int const x) {
	        tree[x].size =
	            tree[tree[x].daughter[0]].size + tree[tree[x].daughter[1]].size
	            + tree[x].count;
	    }
	    void const inline connect
	        (unsigned int const x, unsigned int const y, bool const id) {
	        tree[x].mother = y, tree[y].daughter[id] = x;
	    }
	    void const inline rotate(unsigned int const x) {
	        unsigned int const m(tree[x].mother), g(tree[m].mother);
	        bool const id(get_id(x)), mid(get_id(m));
	        connect(tree[x].daughter[!id], m, id), upto(m),
	        connect(m, x, !id), upto(x), connect(x, g, mid);
	    }
	    ```
    
    - 那么将一个节点旋转到指定位置，就可以一直将这个节点上旋。然而这种做法可能会被毒瘤出题人卡掉。
    
    - 一种可行解是：
    	- 如果节点 $x$、$x$ 的家长、$x$ 的祖父母在一条链上，则先旋转 $x$ 的家长，再旋转 $x$；
        - 如果不在一条链上，则旋转两次 $x$。
        ```cpp
        //旋转节点到指定位置代码
		    void const inline splay(unsigned int const x, unsigned int root) {
		        root = tree[root].mother;
		        while (tree[x].mother not_eq root)
		            if (tree[tree[x].mother].mother == root) rotate(x);
		            else
		                if (get_id(x) == get_id(tree[x].mother))
		                    rotate(tree[x].mother), rotate(x);
		                else
		                    rotate(x), rotate(x);
		    }
		    void const inline Splay(unsigned int const x) {
		        splay(x, root), root = x;
		    }
    	```
        
**旋转是 Splay_Tree 时间复杂度的保证，在每次操作后都尽量旋转。**

以下是题目要求操作的实现。比较简单。可以略过直接看代码。

- 插入 $value$
	- 从根节点走到一个值与 $value$ 相等的节点或空节点，将该节点的 $count$ 增加一或新建一个节点。（在过程中将路径上所有 $size$ 增加 $1$。）

- 删除 $value$
	- 从根节点走到值与 $value$ 相等的节点，将该点 $count$ 减少 $1$。（在过程中将路径上所有 $size$ 减少 $1$。）

- 查询排名
	- 从根节点走下来，假如走到右子树，就将答案加上左子树大小与子树根节点 $count$ 的值。
    
- 查询某排名的数。
	- 类似查询排名，当发现要查询的排名正好在当前节点中的话就返回。
    
- 查询 $value$ 的前驱
	- 一种可行的方法是查询排名为 $value$ 的排名减一的数。
    - 也可以不断逼近 $value$，更新答案。
    
- 查询 $value$ 的后继
	- 同理查询前驱。

```cpp
template<typename T = unsigned int>
class Balanced_Binary_Tree {
private:
    struct Point {
        T value;
        unsigned int count;
        unsigned int size;
        unsigned int daughter[2], mother;
        Point() { size = count = 0, mother = daughter[1] = daughter[0] = 0; }
        Point(T const value) {
            this->value = value,
            size = count = 1, mother = daughter[1] = daughter[0] = 0;
        }
    } tree[N + M + 1];
    unsigned int length, size, root;
    bool inline get_id(unsigned int const x) const {
        return tree[tree[x].mother].daughter[1] == x;
    }
    void const inline upto(unsigned int const x) {
        tree[x].size =
            tree[tree[x].daughter[0]].size + tree[tree[x].daughter[1]].size
            + tree[x].count;
    }
    void const inline connect
        (unsigned int const x, unsigned int const y, bool const id) {
        tree[x].mother = y, tree[y].daughter[id] = x;
    }
    void const inline rotate(unsigned int const x) {
        unsigned int const m(tree[x].mother), g(tree[m].mother);
        bool const id(get_id(x)), mid(get_id(m));
        connect(tree[x].daughter[!id], m, id), upto(m),
        connect(m, x, !id), upto(x), connect(x, g, mid);
    }
    void const inline splay(unsigned int const x, unsigned int root) {
        root = tree[root].mother;
        while (tree[x].mother not_eq root)
            if (tree[tree[x].mother].mother == root) rotate(x);
            else
                if (get_id(x) == get_id(tree[x].mother))
                    rotate(tree[x].mother), rotate(x);
                else
                    rotate(x), rotate(x);
    }
    void const inline Splay(unsigned int const x) {
        splay(x, root), root = x;
    }
public:
    Balanced_Binary_Tree() { size = length = 0; }
    void const inline Insert(T const x) {
        if (not size++) {
            tree[root = ++length] = Point(x), connect(root, 0, 0);
            return;
        }
        for (unsigned int register i(root); ++tree[i].size, true;) {
            if (tree[i].value == x)
                { ++tree[i].count, Splay(i); return; }
            else {
                bool id(tree[i].value < x);
                if (not tree[i].daughter[id]) {
                    tree[++length] = Point(x), connect(length, i , id),
                    Splay(length);
                    return;
                }
                else
                    i = tree[i].daughter[id];
            }
        }
    }
    void const inline Delete(T const x) {
        --size;
        for (
            unsigned int register i(root);
            tree[i].size--;
            i = tree[i].daughter[x > tree[i].value]
        )
            if (tree[i].value == x) {
                if (--tree[i].count) { Splay(i); return; }
                Splay(i);
                if (not tree[i].daughter[0])
                    { connect(root = tree[i].daughter[1], 0, 0); return; }
                if (not tree[i].daughter[1])
                    { connect(root = tree[i].daughter[0], 0, 0); return; }
                unsigned int j(tree[i].daughter[0]);
                while (tree[j].daughter[1]) j = tree[j].daughter[1];
                splay(j, tree[i].daughter[0]);
                connect(tree[i].daughter[1], tree[i].daughter[0], 1),
                upto(tree[i].daughter[0]),
                connect(root = tree[i].daughter[0], 0, 0);
                return;
            }
    }
    unsigned int inline Get_Ranking(T const x) {
        unsigned int r(1);
        for (unsigned int register i(root); i;)
            if (tree[i].value == x)
                { Splay(i); return tree[tree[i].daughter[0]].size + 1; }
            else
                if (tree[i].value < x)
                    r += tree[tree[i].daughter[0]].size + tree[i].count,
                    i = tree[i].daughter[1];
                else
                    i = tree[i].daughter[0];
        return r;
    }
    unsigned int inline Get_Rank(unsigned int const x) {
        unsigned int r(1);
        for (unsigned int register i(root); true;) {
            if (
                r + tree[tree[i].daughter[0]].size <= x
                and x < r + tree[tree[i].daughter[0]].size + tree[i].count
            ) { Splay(i); return tree[i].value; }
            else
                if (x < r + tree[tree[i].daughter[0]].size)
                    i = tree[i].daughter[0];
                else
                    r += tree[tree[i].daughter[0]].size + tree[i].count,
                    i = tree[i].daughter[1];
        }
    }
    T inline Get_Less(T const x) {
        T r; unsigned int register li;
        for (unsigned int register i(root); i;)
            if (tree[i].value >= x) li = i, i = tree[i].daughter[0];
            else r = tree[li = i].value, i = tree[i].daughter[1];
        Splay(li);
        return r;
    }
    T inline Get_Greater(T const x) {
        T r; unsigned int register li;
        for (unsigned int register i(root); i;)
            if (tree[i].value <= x) li = i, i = tree[i].daughter[1];
            else r = tree[li = i].value, i = tree[i].daughter[0];
        Splay(li);
        return r;
    }
};
```

---

## 作者：phigy (赞：39)

# Treap

平衡树怎么能少了 treap 这么好写、好看又重要的东西。

---

平衡树学起来有点困难但有时候只要掌握了关键的一点。

就学会了。

Treap 是 Tree 和 Heap 的结合。

其中 Tree 指 BST , 这两个东西为前置知识比较简单，不做阐述。

学了 BST 的人都知道它容易被卡。

所以在有 num 的情况下我们添加一个第二关键字。

使第二关键字保证堆的性质。

这样才能使每次操作复杂度平均为 $O(log n)$

但是如何才能使第二关键字保证堆的性质呢？

这个时候就要用到旋转了！

```cpp
        A                         
       / \              
      B   C               
         / \              
        D   E      
```

然后旋转

```cpp
        C
       / \
      A   E
     / \   
    B   D
    
```

手模一下很好理解。

此时大小关系没变，但树的形状变了。

这是左旋。

而把过程逆过来就是右旋。

这个有什么用呢？

我们需要树的第一关键字满足BST。

又要第二关键字满足heap。

如果用heap原本的移动方式维护第二关键字。

会轻易破坏第一关键字。

而我们将移动A和B，改为旋转就能，

**在保证第一关键字正确的情况下，维护第二关键字！**

这就是Treap的核心！

----

代码时间：

```cpp
#include<bits/stdc++.h>

#define inf 2000000005
using namespace std;

const int maxn=(2000000);
int cnt=0,R=0;
int size[maxn],treap[maxn],num[maxn],rd[maxn],BST[maxn][2];

void pushup(int i)
{
    size[i]=size[BST[i][0]]+size[BST[i][1]]+num[i];
}

void rotate(int &i,int d)
{
    int k=BST[i][d^1];
    BST[i][d^1]=BST[k][d];
    BST[k][d]=i;
    pushup(i);
    pushup(k);
    i=k;
}

void insert(int &i,int x)
{
    if (i==0)
    {
        i=++cnt;
        size[i]=1;
        num[i]=1;
        treap[i]=x;
        rd[i]=rand();
        return;
    }
    if (treap[i]==x)
    {
        num[i]++;
        size[i]++;
        return;
    }
    if(x>treap[i])
    {
        insert(BST[i][1],x);
        if (rd[i]<rd[BST[i][1]])
        {
            rotate(i,0);
        }
    }
    else
    {
        insert(BST[i][0],x);
        if (rd[i]<rd[BST[i][0]])
        {
            rotate(i,1);
        }
    }
    pushup(i);
}

void remove(int &i,int x)
{
    if (i==0)
    {
        return;
    }
    if (x<treap[i])
    {
        remove(BST[i][0],x);
    }
    else if (x>treap[i])
    {
        remove(BST[i][1],x);
    }
    else
    {
        if (BST[i][0]==0 && BST[i][1]==0)
        {
            num[i]--;
            size[i]--;
            if (num[i]==0)
            {
                i=0;
            }
        }
        else if (BST[i][0] && BST[i][1]==0)
        {
            rotate(i,1);
            remove(BST[i][1],x);
        }
        else if (BST[i][0]==0 && BST[i][1])
        {
            rotate(i,0);
            remove(BST[i][0],x);
        }
        else if (BST[i][0] && BST[i][1])
        {
            if(rd[BST[i][0]]>rd[BST[i][1]])
            {
                rotate(i,1);
                remove(BST[i][1],x);
            }
            else
            {
                rotate(i,0);
                remove(BST[i][0],x);
            }
        }
    }
    pushup(i);
}

int rank(int i,int x)
{
    if (i==0)
    {
        return 1;
    }
    if (treap[i]==x)
    {
        return size[BST[i][0]]+1;
    }
    if (treap[i]<x)
    {
        return size[BST[i][0]]+num[i]+rank(BST[i][1],x);
    }
    if (treap[i]>x)
    {
        return rank(BST[i][0],x);
    }
}

int find(int i,int x)
{
    if (i==0)
    {
        return 0;
    }
    if (size[BST[i][0]]>=x)
    {
        return find(BST[i][0],x);
    }
    else if (size[BST[i][0]]+num[i]<x)
    {
        return find(BST[i][1],x-num[i]-size[BST[i][0]]);
    }
    else
    {
        return treap[i];
    }
}

int front(int i,int x)
{
    if (i==0)
    {
        return -inf;
    }
    if (treap[i]>=x)
    {
        return front(BST[i][0],x);
    }
    else
    {
        return max(treap[i],front(BST[i][1],x));
    }
}

int back(int i,int x)
{
    if (i==0)
    {
        return inf;
    }
    if (treap[i]<=x)
    {
        return back(BST[i][1],x);
    }
    else
    {
        return min(treap[i],back(BST[i][0],x));
    }
}

int main()
{
    int n,m,last=0,ans=0;
    cin>>n>>m;
    for (int i=1;i<=n;i++)
    {
        int x;
        scanf("%d",&x);
        insert(R,x);
    }
    for (int i=1;i<=m;i++)
    {
        int opt,x;
        scanf("%d %d",&opt,&x);
        x^=last;
        if (opt==1)
        {
            insert(R,x);
        }
        else if (opt==2)
        {
            remove(R,x);
        }
        else if (opt==3)
        {
            last=rank(R,x);
            ans^=last;
        }
        else if (opt==4)
        {
            last=find(R,x);
            ans^=last;
        }
        else if (opt==5)
        {
            last=front(R,x);
            ans^=last;
        }
        else if (opt==6)
        {
            last=back(R,x);
            ans^=last;
        }
    }
    cout<<ans;
    return 0;
}
```
推荐洛谷日报：[地址](https://www.luogu.com.cn/blog/HOJQVFNA/qian-xi-treap-ping-heng-shu)

大佬勿喷

## 感谢管理员审核！！！！

---

## 作者：VictorYuan (赞：32)

看到题目的时候我一阵窃喜，因为上个月我刚刚研究了vector水平衡树怎么扩展，奋战两天后得到[这样的结果](https://www.luogu.com.cn/blog/ysl/kai-fa-vector)。（建议先看完此题解，再看此博客）

但是因为这道题的n和m都较小，所以里面很多优化是不需要的，所以用块状vector做此题拥有代码简练，通俗易懂且速度快，空间小的优点。（可能是理解起来最简单，空间最小的做法）

由于m比n大得多，所以我下面用m代替原题中的n+m，同时为了方便，用size表示某vector中元素个数。

首先你要知道，vector的insert和erase是O(size)的，但常数特别小（如果卡满还是比bitset慢一半，随机数据好一点）（所以大概可以写成是O(size/w)？），然后还要知道vector怎么做普通平衡树（原版）。

这里假设大家都知道了（不知道的也不会来做这个题吧），我们发现这里m=1e6,直接套用那个做法时间复杂度是O(m^2)的，虽然它的常数特别小，但也没有小到这个程度，妥妥的TLE。

然后我们尝试优化：我们发现在这个做法中，只有insert和erase是O(size) 的，而其他操作都是O(log)或O(1)的，极度不平衡。众所周知，我们有一个处理复杂度不平衡情况的做法是分块。所以我们可以尝试用分块优化这个暴力。

但是由于元素会实时改变所以没法直接分块，要用块状链表之类的东西，所以我把这个东西叫块状vector。

具体而言：把一个大vector拆成若干个小vector，要保证这些vector都是有顺序的，即下一个vector中的元素都不小于上一个vector中的元素，同时一个vector内部也要保证有序。

首先考虑重构操作，由于m较小，所以我们甚至不需要真的写块状链表，每进行t次操作后可以暴力全局重构，每次重构时间复杂度是O(m)的，所以这一部分是O(m^2/t)的，此外我们要决定重构块长，记为len,表示重构结束每个vector中有len个元素。

**uodate**:我已经找到了更好的写法方便的重构方法：不管t的限制，只有当某一个块被删成空块或长度大于2*len的时候再重构（更靠近块状链表的做法），这样有一个好处是数据弱的时候可以大幅度减少重构次数，最坏情况下也是每len次操作就要重构一次，所以不会造成负优化，由于数据较水，我把len开的很小也没有出现大量重构的现象，于是这个做法现在成了最优解，这里是[提交记录](https://www.luogu.com.cn/record/31181649)。

然后就是平衡树部分的操作了。

首先要写一个work()函数，表示我们要找到某个元素在第几个块，具体实现可以从第一个vector开始每次比较这个vector开头的元素和我当前要查询的元素哪个更大，遇到第一个比它大的，就返回上一个vector。

插入:先调用work(),然后正常的二分insert就好了。

删除:先调用work(),然后正常的二分找到它的位置然后erase。

查排名：先找到它在哪一块，然后答案就是它前面所有的vector的size和加上当前vector中比它小的元素个数，最后+1.（注意这里排名指的是比它小的元素的个数+1，它自己不一定真的出现某个在vector中）

查第k小：从第一个vector开始，每次判断k与这个vetor的size大小，如果k>size,说明它不在这个vector内，将k减size，然后继续查找下一个vector，否则这个元素就在这个vector内，直接返回vector中第k个元素就好了。

求x的前驱：先找到x的排名k，然后返回第k-1小。

求x的后继：先找到x+1的排名k，然后返回第k小。

分析复杂度：由于每块长为len,所以共有m/len个块，所以我们的work()函数时间复杂度是 O(m/len)的，其他6个函数本质上都需要调用一次work()函数所以都要算上，此外查排名有一个O(log len) 的二分，前驱后继（为了好写）调用了排名函数所以也要带这个log，insert和erase除了带这个log还额外附加一个O((len+t)/w),其中w是个大常数,加t的原因是可能多次只向一个vector插入会使它产生无法忽略的变长。

所以最慢的操作依旧为insert,复杂度O(m/len + log len + (len+t)/w);

算上重构的时间，总的时间复杂度为O( m^2/t + m( m/len +log len +(len+t)/w ) )，这里取 len=t=1e4 即可通过本题。

**update**:由于今天发现vector的常数没有我想象的那么小，所以把len和t开的再小一点可能会更好。

但事实上此做法还有较高的拓展性，具体做法我已经放在最开头的链接的博客里了，用合理的方法优化此做法能在m=1e7的时候仍不输平衡树，而且可能也有很多我不知道的常数优化，但由于比较复杂，我个人也没有写过块状链表，所以我没有代码实现，那么欢迎大家实现一下那个做法。

按t重构的话还有一个细节：如果t>len,那么有可能会在两次重构期间删完某个vector,边界条件变得难以处理，一个实现简单的解决方法就是删到某 vector为空时直接重构。此外最后一个vector由于长度不足len,所以无论t和len怎么设，都有可能被删完，这时特判一下，如果最后一个vector被删完了直接把vector的数量-1就好了。

最后贴上简单易懂的代码，有一些实现细节看代码吧：（按t重构）

```cpp
#include<bits/stdc++.h>
#define ll long long
#define find() lower_bound(v[i].begin(),v[i].end(),x)
#define gc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
using namespace std;
inline int read()
{
	static char buf[1<<21],*p1,*p2;
	int f=0,c=1; char ch=gc();
	while(ch<'0'||ch>'9') { if(ch=='-') c=-1; ch=gc(); }
	while(ch>='0'&&ch<='9') { f=f*10+ch-'0'; ch=gc(); }
	return c*f;
}
const int t=10000,len=10000;//每t次操作重构一次，每个vector的长度为len 
int a[1234567];
vector <int> v[1000];
int op,x,y,n,m,sz,tot,cnt,lst,ans;//sz记有几个vector 
void init(int flag=0)//重构 
{
	if(!flag) tot=0; cnt=0; 
	for(int i=1;i<=sz;++i)
	{
		int m=v[i].size();
		for(int j=0;j<m;++j)
			a[++tot]=v[i][j];
		v[i].clear();
	}
	sz=tot/len+(tot%len!=0);
	sz=max(sz,1);//特判一下没有元素的情况 
	for(int i=1;i<sz;++i)
		for(int j=0;j<len;++j) 
			v[i].push_back(a[++cnt]);
	while(cnt<tot) v[sz].push_back(a[++cnt]);
}
int work(int x)//定位x在那一块 
{
	int i=1;
	while(i<=sz&&v[i][0]<x) ++i;
	--i;  
	return max(1,i);//有可能x是最小的元素会返回0，特判一下 
}
void insert(int x) { int i=work(x); v[i].insert(find(),x); }
void erase(int x) 
{ 
	int i=work(x); 
	if(find()!=v[i].end()) v[i].erase(find()); //有可能它就是下一个块开头的元素，特判一下
	else v[i+1].erase(v[i+1].begin());
	if(v[sz].size()==0) sz=max(sz-1,1);//最后一块由于不完整，是有可能被删完的 
}
int rnk(int x) 
{ 
	int i=work(x),ans=0;
	for(int j=1;j<i;++j) ans+=v[j].size();
	return ans+(find()-v[i].begin())+1;
}
int kth(int x)
{
	for(int i=1;i<=sz;++i)
	{
		if(x<=v[i].size()) return v[i][x-1]; 
		x-=v[i].size();
	}
}
int pre(int x) { return kth(rnk(x)-1); }
int nxt(int x) { return kth(rnk(x+1)); }
int main()
{
//	freopen("test.in","r",stdin);
//	freopen("test.out","w",stdout);
	n=read(); m=read();
	for(int i=1;i<=n;++i) a[i]=read();
	sort(a+1,a+n+1);
	tot=n; init(1);//开始的时候由于n>len,  所以这里要重构 
	while(m--)
	{
		if(m%t==0) init();//重构 
		op=read(); x=read()^lst;
		if(op==1) insert(x);
		if(op==2) erase(x);
		if(op==3) lst=rnk(x);
		if(op==4) lst=kth(x);
		if(op==5) lst=pre(x);
		if(op==6) lst=nxt(x);
		if(op>=3) ans^=lst;
	}
	cout<<ans;
	return 0;
}
```



---

## 作者：Infiltrator (赞：22)

[$\Large\color{#FFBBFF}\textit{Tian-Xing's blog}$](https://Tian-Xing.github.io)

------------

# $1.1$ $Leafy \ Tree$ 

### 定义

>$Leafy \ Tree$ 是一种二叉树，其每个节点要么为叶子，要么有两个儿子。其信息完全储
存在叶子上面，每个非叶节点存储的信息是其儿子的信息的合并。

例如线段树就是一种$Leafy \ Tree$，每个节点上存的信息是左右子节点的信息之和。

在用$Leafy \ Tree$实现重量平衡树的功能的时候，每个节点的权值为其右子节点的权值，重量为左右节点重量之和，每个叶子节点的权值为集合中的数。

使用$Leafy \ Tree$实现重量平衡树的方法叫$WBLT(Weight \ Balanced \ Tree + Leafy \ Tree)$。

因为只有叶子节点存储集合中的数，所以$WBLT$使用的节点数是别的种类的平衡树的两倍。

但是$WBLT$可持久化比较方便，速度也很快，一般来讲比$Splay$快，和替罪羊树差不多。

# $1.2$ 加权平衡树

### 定义

>加权平衡树（$Weight \ Balanced \ Tree$，也叫 $BB[\alpha]$ 树，重量平衡树）是一种储存子树大小的二叉搜索树。即一个结点包含以下字段：值、左儿子、右儿子、子树大小。

>重量平衡树中如果一个节点$x$满足$min(weight_{x.left},weight_{x.right}) ≥\alpha \times weight_x$,则称这个节点是$\alpha$加权平衡的，显然$0 < \alpha \leq \frac{1}{2}$。一棵含有$n$个元素的加权平衡树的高度$h$满足$h \leq \log_{\frac{1}{1 - \alpha}} n = O(\log n)$。

替罪羊树就是一种重量平衡树。

当节点的某个儿子$x$的大小小于了$\alpha \times$节点$x$的大小，就需要进行操作使其平衡。

在替罪羊树里我们通过重构整个$x$节点的子树使其$\alpha$加权平衡。

在$WBLT$中我们通过旋转或者重构的方式使其$\alpha$加权平衡。

通过旋转使节点平衡的$WBLT$有单旋和双旋的写法，虽然单旋也挺快但是单旋的复杂度是错误的，而且一般比双旋慢。

不过单旋倒是应该也没有人卡。

# $2.1$ $Leafy \ Tree$实现二叉搜索树

首先先来看不用加权平衡的操作。

### $Pushup$

```cpp
void Pushup(int k) 
{ 
   tr[k].v = tr[tr[k].son[1]].v; 
   tr[k].siz = tr[tr[k].son[0]].siz + tr[tr[k].son[1]].siz; 
   return; 
}
```

按照定义进行$Pushup$即可。

### $Recycle$和$Id$

```cpp
int Id() { return poolsize ? pool[poolsize--] : ++num; };

void Recycle(int x) { pool[++poolsize] = x; return; }
```

因为$WBLT$使用节点比较多，为了节省空间可以对删掉的节点进行回收操作。开一个栈表示可以使用的编号，每次删除时把编号丢进栈里即可。

### $Newnode$

```cpp
int Newnode(int x)
{
    int k = Id();
    tr[k].siz = 1;
    tr[k].v = x;
    tr[k].son[0] = tr[k].son[1] = 0;
    return k;
}
```

新建一个权值为$x$的节点，返回其标号。

### $Merge$

```cpp
int Merge(int x, int y)
{
    int k = Id();
    tr[k].son[0] = x; tr[k].son[1] = y;
    Pushup(k);
    return k;
}
```

新建一个节点将两个节点的信息合并，返回新建的节点的编号。

### $Insert$

```cpp
void Insert(int &k, int x)
{
    if (!k) { k = Newnode(x); return; }
    if (tr[k].siz == 1) 
    { 
    	k = x > tr[k].v ? Merge(k, Newnode(x)) : Merge(Newnode(x), k); 		 
        return;
    }
    else Insert(tr[k].son[x > tr[tr[k].son[0]].v], x);
    Pushup(k); Maintain(k);
    return;
}
```
$WBLT$里的节点不是叶子节点就一定有两个子节点，按顺序走到叶子节点然后建立一个新的节点，其儿子是新插入的节点和原来该位置上的节点。

### $Delete$

```cpp
void Delete(int &k, int x)
{
    if (tr[k].siz == 1) { Recycle(k); k = 0; return; }
    int d = x > tr[tr[k].son[0]].v;
    if (tr[tr[k].son[d]].siz == 1) Recycle(k), Recycle(tr[k].son[d]), k = tr[k].son[d ^ 1];
    else Delete(tr[k].son[d], x), Pushup(k), Maintain(k);
    return;
}
```

一路往下走找到要删除的节点的父亲节点，然后用父亲节点的另外一个儿子代替父亲节点。

其它基础操作和普通二叉搜索树的操作基本类似这里不再赘述，只需记住$WBLT$每个节点用于比较的权值不是该节点的权值而是该节点的左儿子的权值，因为左儿子的权值是左儿子所在子树的最大值，若最大值都没有贡献更小的值必然没有贡献。

# $2.2$ $WBLT$

$WBLT$出现的不平衡状态大致分为两种。

![](https://cdn.luogu.com.cn/upload/image_hosting/s7om6vtn.png)

这种情况，只存在节点$x$有子节点$weight_{x.son} < \alpha \times weight_x$，进行一次单旋即可。

![](https://cdn.luogu.com.cn/upload/image_hosting/hds58ra8.png)

这种情况，既存在节点$x$有子节点$weight_{x.son} < \alpha \times weight_x$，又存在该子节点的另一侧节点$weight_{x.son.son \oplus 1}\times \frac{1 - 2 \times \alpha}{1 - \alpha}$，就进行两次旋转。

$\alpha$一般设为$0.29$，相对应的$\frac{1 - 2 \times \alpha}{1 - \alpha}$一般为$0.6$，不同的平衡树题可以将$\alpha$进行微调，效率会发生变化。

### $Rotate$

```cpp
void Rotate(int k, int d)
{
    int temp = tree[k].son[d ^ 1];
    tree[k].son[d ^ 1] = tree[k].son[d];
    tree[k].son[d] = tree[tree[k].son[d ^ 1]].son[d];
    tree[tree[k].son[d ^ 1]].son[d] = tree[tree[k].son[d ^ 1]].son[d ^ 1];
    tree[tree[k].son[d ^ 1]].son[d ^ 1]=temp;
    Pushup(tree[k].son[d ^ 1]);
    Pushup(k);
}
```

因为不同于$Splay$和$Treap$，我们不需要再使用该节点的编号，所以直接旋转完之后将编号交换。

可以通过上面的$Merge$函数简化$Rotate$操作。

```cpp
void Rotate(int k, int d)
{
    if (d)
    {
        tr[k].son[0] = Merge(tr[k].son[0], tr[tr[k].son[1]].son[0]);
        Recycle(tr[k].son[1]); 
        tr[k].son[1] = tr[tr[k].son[1]].son[1];
        Pushup(tr[k].son[0]); Pushup(k); 
    }
    else
    {
        tr[k].son[1] = Merge(tr[tr[k].son[0]].son[1], tr[k].son[1]);
        Recycle(tr[k].son[0]);
        tr[k].son[0] =  tr[tr[k].son[0]].son[0];
        Pushup(tr[k].son[1]); Pushup(k);
    }
    return;
}
```

### $Maintain$

```cpp
void Maintain(int k)
{
    int d;
    if (tr[tr[k].son[0]].siz < tr[k].siz * alpha) d = 1;
    else if (tr[tr[k].son[1]].siz < tr[k].siz * alpha) d = 0;
    else return; 
    if (tr[tr[tr[k].son[d]].son[d ^ 1]].siz >= tr[tr[k].son[d]].siz * aalpha) Rotate(tr[k].son[d], d ^ 1);
    Rotate(k, d);
    return;
}
```

在插入和删除的时候从叶子节点往上依次维护平衡即可。

# 参考资料

我是从成都七中王思齐的$IOI2018$国家集训队论文学习的$WBLT$，具体的复杂度证明可以去看看这篇论文。

---

## 作者：hsfzLZH1 (赞：18)

## 替罪羊树

替罪羊树是一种不依靠旋转操作来保证平衡的平衡树。其思想在支持修改的 k-D Tree 中也有应用。

替罪羊树除了保证平衡的操作之外，其余操作都与一般的二叉搜索树相同。

替罪羊树的核心思想是：如果一个子树不满足特定的平衡条件，就将整棵子树 **重构** 使之平衡。

设一个常数 $\alpha$ ，若一个点左右子树大小在该子树中的占比大于 $\alpha$ ，说明子树失衡，需要重构。在有删除操作的题目中，替罪羊树采用惰性删除，即标记该结点已经被删除，但保留其在树上的位置，若一个子树中未被标记删除的节点占比小于 $\alpha$ ，则该子树也需要重构。

**重构操作：** 先中序遍历整棵替罪羊树，按顺序排列所有未删除结点，然后通过笛卡尔树建树方法或者类似于线段树的建树方法将这些结点构成一棵深度为 $O(\log n)$ 的二叉搜索树。分析可知，该操作时间复杂度为 $O(n)$ 。

一般来说，常数 $\alpha$ 的取值在 $0.7$ 左右。 $\alpha$ 保证了所有子树的平衡与未删除结点的数量，所以替罪羊树的深度是 $O(\log n)$ 的。每个刚重构完的 $n$ 个结点的子树，至少需要再加入 $n(\alpha-\frac 1 2)$ 个结点，才会再次重构，所以重构次数也是有保证的。一般认为，当 $\alpha$ 的值合适的时候，替罪羊树上单次操作的时间复杂度是 $O(\log n)$ 的。

#### 参考代码

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=1100010;
int n,op,x,q,lstans,ans;
double a=0.725;
int rt,cur,val[maxn],lc[maxn],rc[maxn],cnt[maxn],siz[maxn],siz2[maxn],sum[maxn];
int t,g[maxn];
void print(int x){if(!x)return;print(lc[x]);if(cnt[x])g[++t]=x;print(rc[x]);}
void maintain(int x)
{
	siz[x]=siz[lc[x]]+siz[rc[x]]+(cnt[x]?1:0);
	siz2[x]=siz2[lc[x]]+siz2[rc[x]]+1;
	sum[x]=sum[lc[x]]+sum[rc[x]]+cnt[x];
}
int build(int l,int r)
{
	if(l>r)return 0;
	if(l==r){lc[g[l]]=rc[g[l]]=0;maintain(g[l]);return g[l];}
	int mid=(l+r)>>1;
	lc[g[mid]]=build(l,mid-1);rc[g[mid]]=build(mid+1,r);
	maintain(g[mid]);
	return g[mid];
}
void rebuild(int&x){t=0;print(x);x=build(1,t);}
bool bad(int x){return sum[x]&&(a*siz2[x]<=max(siz2[lc[x]],siz2[rc[x]])||a*siz2[x]>=siz[x]);}
void insert(int&x,int v)
{
	if(!x){x=++cur;val[x]=v;cnt[x]=1;maintain(x);return;}
	if(v==val[x])cnt[x]++;
	else if(v<val[x])insert(lc[x],v);
	else insert(rc[x],v);
	maintain(x);
	if(bad(x))rebuild(x);
}
void erase(int&x,int v)
{
	if(v==val[x])cnt[x]--;
	else if(v<val[x])erase(lc[x],v);
	else erase(rc[x],v);
	maintain(x);
	if(bad(x))rebuild(x);
}
int rnk(int x,int v)
{
	if(!x)return 1;
	if(v==val[x])return sum[lc[x]]+1;
	if(v<val[x])return rnk(lc[x],v);
	return sum[lc[x]]+cnt[x]+rnk(rc[x],v);
}
int kth(int x,int k)
{
	if(!x)return -1;
	if(sum[lc[x]]<k&&k<=sum[lc[x]]+cnt[x])return val[x];
	if(k<=sum[lc[x]])return kth(lc[x],k);
	return kth(rc[x],k-sum[lc[x]]-cnt[x]);
}
int pre(int v){return kth(rt,rnk(rt,v)-1);}
int suf(int v){return kth(rt,rnk(rt,v+1));}
int main()
{
	scanf("%d%d",&n,&q);t=n;
	for(int i=1;i<=n;i++)scanf("%d",g+i),insert(rt,g[i]);
	while(q--)
	{
		scanf("%d%d",&op,&x);x^=lstans;
		if(op==1)insert(rt,x);
		if(op==2)erase(rt,x);
		if(op==3)lstans=rnk(rt,x);
		if(op==4)lstans=kth(rt,x);
		if(op==5)lstans=pre(x);
		if(op==6)lstans=suf(x);
		if(3<=op&&op<=6)ans^=lstans;
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Yyxxxxx (赞：18)

平衡树板子题，没啥好说的   
我这个蒟蒻整一个 AVL 树的题解吧    
学习自大佬[AgOH](https://www.luogu.com.cn/user/109757)在此感谢   
# 树旋转
### 旋转操作是非常重要的，所以我放在最开头讲
先来看看  旋转口诀  ：

## 左旋拎右左挂右，右旋拎左右挂左——AgOH

------------
显然你还是不懂，那我来解释一下
###### 左旋
令$ Now $ 结点为当前结点  
令$ R $为$ Now $结点的右子树  
令$ RL $为$ R $结点的左子树
- 拎右：把$R$“拎”到$Now$的位置作为$ Now $的父亲，并且把$ Now $作为$ R $ 的左儿子   
这个时候，我们发现$ R $结点居然有两棵左子树$ (Now,RL) $，太令人气愤了，这可不行  
- 左挂右：那么我们看看应该把$ RL $放在哪里，根据二叉搜索树的性质。   
$ RL $原本是$ R $的左儿子，那他现在就要在$ R $的左子树上。   
$ R $原来在$ Now $的右子树上，这导致了$ RL $现在也要在$ Now $的右子树上。
现在这棵树上$ Now $在$ R $的右子树上，所以要满足$ RL $在$ Now $的右子树上且$ RL $在$ R $的左子树上，就直接让$ Now $的右子树是$ RL $就可以了。
- 左挂右的简单理解：现在$ Now $的右儿子变成自己的父节点，那$ Now $就没有右子树了，所以直接令$ RL $为其右子树就行了。
- 总结：左旋就是把当前结点的右儿子“拎起来”，作为当前结点的父节点当前节点作为它的左儿子（拎右）而把它原来的左儿子“挂到”当前节点的右边，作为当前节点的右儿子（左挂右）。    
```cpp
inline void lx(int &now)
{
    int r=avl[now].r;//右子树
    avl[now].r=avl[r].l;//左挂右
    avl[r].l=now;//拎右
    now=r;//还是拎右
    updata(avl[now].l);//更新，先更新子树，在更新父亲
    updata(now);//更新
}
```



------------
如果你理解了左旋，那右旋就是复读机啊（没理解请反复理解）如果你理解了觉得没有必要浪费时间再读一遍直接跳过
###### 右旋
令$ Now $ 结点为当前结点  
令$ L $为$ Now $结点的左子树  
令$ LR $为$ L $结点的右子树
- 拎左：把$ L $“拎”到$ Now $的位置作为$ Now $的父亲，并且把$ Now $作为$ L $ 的右儿子。   
这个时候，我们发现$ L $结点居然有两棵右子树$ (Now,LR) $，太令人气愤了，这可不行。  
- 右挂左：那么我们看看应该把$ LR $放在哪里，根据二叉搜索树的性质。   
$ LR $原本是$ L $的右儿子，那他现在就要在$ L $的右子树上。   
$ L $原来在$ Now $的左子树上，这导致了$ LR $现在也要在$ Now $的左子树上。
现在这棵树上$ Now $在$ L $的左子树上，所以要满足$ LR $在$ Now $的左子树上且$ LR $在$ L $的右子树上，就直接让$ Now $的左子树是$ LR $就可以了。
- 右挂左的简单理解：现在$ Now $的左儿子变成自己的父节点，那$ Now $就没有左子树了，所以直接令$ LR $为其左子树就行了。
- 总结：右旋就是把当前结点的左儿子“拎起来”，作为当前结点的父节点当前节点作为它的右儿子（拎左）而把它原来的右儿子“挂到”当前节点的左边，作为当前节点的左儿子（右挂左）。  
```cpp
inline void rx(int &now)
{
    int l=avl[now].l;//左子树
    avl[now].l=avl[l].r;//右挂左
    avl[l].r=now;//拎左
    now=l;//还是拎左
    updata(avl[now].r);//更新
    updata(now);//更新
} 
```    
## 概念
紧接着从头来看  
- 平衡因子$(BF,Balance Factor)$   
某节点的平衡因子=左子树高-右子树高（右子树高-左子树高）  
```cpp
inline int getBF(int now)
{
    return avl[avl[now].l].height-avl[avl[now].r].height;
}
```

- 如何维护$ AVL $树平衡？  
如果我们要保持平衡树平衡，那么我们就要让它更像一棵树，而不是像一条链。   
所以我们要让一个结点的平衡因子的绝对值，也就是左子树高和右子树的高度差的绝对值不超过$ 1 $。或者说差只能为$ 1,0,-1 $。   
若该节点的平衡因子绝对值超过$1$，就认为该子树不平衡。
## 操作
-  LL （左左）  
对于本操作的定义是：当前结点的左子树过高了(BF>1)，左子树的左子树比较高(BF>0)。    
_**注意：左子树的平衡因子需要不平衡，而左子树的左子树只要比左子树的右子树高就行了，并不要求不平衡。**_  
那么对于该结点进行右旋操作   
-  LR （左右）  
对于本操作的定义是：当前结点的左子树过高了(BF>1)，左子树的右子树比较高(BF>0)。    
_**注意：左子树的平衡因子需要不平衡，而左子树的左子树只要比右子树的左子树高就行了，并不要求不平衡。**_  
那么对于该结点的左结点进行左旋操作(L)，再对该节点进行右旋操作(R)  
按照操作名称的顺序旋转即可。
-  RR （右右）  
对于本操作的定义是：当前结点的右子树过高了(BF>1)，右子树的右子树比较高(BF>0)。    
那么对于该结点进行左旋操作   
-  RL （右左）   
对于本操作的定义是：当前结点的右子树过高了(BF>1)，右子树的左子树比较高$(BF>0)$。    
那么对于该结点的右结点进行右旋操作(R)，再对该节点进行左旋操作(L)   
```cpp
inline void check(int &now)
{
    int nBF=getBF(now);
    if(nBF>1)//L
    {
        int lBF=getBF(avl[now].l);
        if(lBF>0)//LL
            rx(now);
        else //RR
            lx(avl[now].l),rx(now);
    }
    if(nBF<-1)//R
    {
        int rBF=getBF(avl[now].r);
        if(rBF<0)//RR
            lx(now);
        else //RL
            rx(avl[now].r),lx(now);
    }
    else if(now) updata(now);//如果平衡，更新节点
}
```
- 加点  
新节点的大小为1。  
```cpp
inline void newnode(int &now,int val)
{
    avl[now=++cnt].val=val;
    avl[cnt].size=1;
}
```
- 更新   
当前节点的大小为左右子树大小的和加一（自己也要算）
当前结点的高度为左右子树高度中更大的加一（自己也要算）
```cpp
inline void updata(int now)
{
    avl[now].size=avl[avl[now].l].size+avl[avl[now].r].size+1;
    avl[now].height=max(avl[avl[now].l].height,avl[avl[now].r].height)+1;
}
```
- 插入
```cpp
void ins(int &now,int val)
{
    if(!now)newnode(now,val);//如果没有结点，加点
    else if(val<avl[now].val)ins(avl[now].l,val);//二叉搜索树性质，值比当前小结点，往左子树插入
    else ins(avl[now].r,val);//否则往右子树插入
    check(now);//自底向上检查，旋转
}
```
- 删除   
直接用后继（找右儿子的左儿子，直到该节点没有左儿子）替换当前结点
```cpp
int find(int &now,int fa)//寻找后继
{
    int res;
    if(!avl[now].l)     //找到了要的后继
    {
        res=now;      //返回值
        avl[fa].l=avl[now].r;//父亲的左儿子改成该点的右儿子
    }
    else                //没找到
    {
        res=find(avl[now].l,now); //递归
        check(now);     //自底向上检查，旋转
    }
    return res;         //返回结点编号
}
void del(int &now,int val)
{
    if(val==avl[now].val)   //删除当前结点
    {
        int l = avl[now].l,r = avl[now].r;  
        if(!l||!r) now=l+r;  //如果无儿或单儿，很简单如果l或r等于0，就返回另一个，否则返回0；
        else 
        {
            now = find(r,r);    //找后继，替换当前
            if(now!=r)          //如果后继不是原来的右儿子
                avl[now].r=r;   //后继的右儿子改成原来的右儿子
            avl[now].l=l;       //把左儿子连上后继
        }
    }
    else if(val<avl[now].val) del(avl[now].l,val);//如果比当前节点值小，往左删
    else del(avl[now].r,val);//否则，往右删
    check(now);                 //自底向上检查，旋转
}
```
- 查排名
```cpp
int getrank(int val)           
{
    int now=root,rank=1;//从根节点找
    while(now)
    {
        if(val<=avl[now].val)//按照二叉搜索树性质，比当前结点值小往左找
            now=avl[now].l;
        else//否则往右找
        {
            rank+=avl[avl[now].l].size+1;//比左子树及当前节点都大，把排名加上左子树大小加上当前节点
            now=avl[now].r;
        }
    }
    return rank;//返回
}
```
- 查值
```cpp
int getnum(int rank)
{
    int now=root;//从根节点找
    while(now)
    {
        if(avl[avl[now].l].size+1==rank)//如果正好就是该节点
            break;//退出循环
        else if(avl[avl[now].l].size>=rank)/如果排名没有左子树的结点数量大
            now=avl[now].l;//往左找
        else
        {
            rank-=avl[avl[now].l].size+1;//否则，在右子树找排名扣掉左子树的大小扣掉当前节点
            now=avl[now].r//往右找;
        }
    }
    return avl[now].val;//返回当前结点的值
}
```
## 实现  
```cpp
int main()
{
    int t;
    scanf("%d",&t);
    while(t--)//多组数据
    {
        int opt,x;
        scanf("%d%d",&opt,&x);
        switch(opt)
        {
        case 1:
            ins(root,x);//插入
            break;
        case 2:
            del(root,x);//删除
            break;
        case 3:
            printf("%d\n",getrank(x));//查排名
            break;
        case 4:
            printf("%d\n",getnum(x));//查值
            break;
        case 5:
            printf("%d\n",getnum(getrank(x)-1));//前驱，比x排名小一的数
            break;
        case 6:
            printf("%d\n",getnum(getrank(x+1)));//后继，比x小一的排名的值
            break;
        }
    }
    return 0;
}
```
## $Code  $
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+10;
struct Node
{
    int l,r;
    int val;
    int height,size;
}avl[maxn];
int cnt,root;
inline void newnode(int &now,int val)
{
    avl[now=++cnt].val=val;
    avl[cnt].size=1;
}
inline void updata(int now)
{
    avl[now].size=avl[avl[now].l].size+avl[avl[now].r].size+1;
    avl[now].height=max(avl[avl[now].l].height,avl[avl[now].r].height)+1;
}
inline int getBF(int now)
{
    return avl[avl[now].l].height-avl[avl[now].r].height;
}
inline void lx(int &now)
{
    int r=avl[now].r;
    avl[now].r=avl[r].l;
    avl[r].l=now;
    now=r;
    updata(avl[now].l);
    updata(now);
}
inline void rx(int &now)
{
    int l=avl[now].l;
    avl[now].l=avl[l].r;
    avl[l].r=now;
    now=l;
    updata(avl[now].r);
    updata(now);
}
inline void check(int &now)
{
    int nBF=getBF(now);
    if(nBF>1)
    {
        int lBF=getBF(avl[now].l);
        if(lBF>0)
            rx(now);
        else 
            lx(avl[now].l),rx(now);
    }
    if(nBF<-1)
    {
        int rBF=getBF(avl[now].r);
        if(rBF<0)
            lx(now);
        else 
            rx(avl[now].r),lx(now);
    }
    else if(now) updata(now);
}
void ins(int &now,int val)
{
    if(!now)newnode(now,val);
    else if(val<avl[now].val)ins(avl[now].l,val);
    else ins(avl[now].r,val);
    check(now);
}
int find(int &now,int fa)
{
    int res;
    if(!avl[now].l)
    {
        res=now;
        avl[fa].l=avl[now].r;
    }
    else
    {
        res=find(avl[now].l,now);
        check(now);
    }
    return res;
}
void del(int &now,int val)
{
    if(val==avl[now].val)
    {
        int l=avl[now].l;
        int r=avl[now].r;
        if(!l||!r)now=l+r;
        else 
        {
            now=find(r,r);
            if(now!=r)
                avl[now].r=r;
            avl[now].l=l;
        }
    }
    else if(val<avl[now].val)del(avl[now].l,val);
    else del(avl[now].r,val);
    check(now);
}
int getrank(int val)
{
    int now=root,rank=1;
    while(now)
    {
        if(val<=avl[now].val)
            now=avl[now].l;
        else
        {
            rank+=avl[avl[now].l].size+1;
            now=avl[now].r;
        }
    }
    return rank;
}
int getnum(int rank)
{
    int now=root;
    while(now)
    {
        if(avl[avl[now].l].size+1==rank)
            break;
        else if(avl[avl[now].l].size>=rank)
            now=avl[now].l;
        else
        {
            rank-=avl[avl[now].l].size+1;
            now=avl[now].r;
        }
    }
    return avl[now].val;
}
int main()
{
    int t;
    scanf("%d",&t);
    while(t--)
    {
        int opt,x;
        scanf("%d%d",&opt,&x);
        switch(opt)
        {
        case 1:
            ins(root,x);
            break;
        case 2:
            del(root,x);
            break;
        case 3:
            printf("%d\n",getrank(x));
            break;
        case 4:
            printf("%d\n",getnum(x));
            break;
        case 5:
            printf("%d\n",getnum(getrank(x)-1));
            break;
        case 6:
            printf("%d\n",getnum(getrank(x+1)));
            break;
        }
    }
    return 0;
}
```

这段代码只能$\color{darkgreen}{AC}$[$[P3369]$](https://www.luogu.com.cn/problem/P3369)   
但是，我们根据题意：
- 把数组开大一点
- 把$int$改成$long$ $long$
- 把主函数稍微改一下，先加点，然后记录一下`last`

就可以把这题过了？是的！
## 真·$Code$
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn = 2e6+10;
struct node
{
	int l,r;
	int val;
	int size,height;
}avl[maxn];
int cnt,root;
inline void newnode(int &now,int val)
{
	avl[now=++cnt].val=val;
	avl[now].size=1;
}
inline void updata(int now)
{
	avl[now].size=avl[avl[now].l].size+avl[avl[now].r].size+1;
	avl[now].height=max(avl[avl[now].l].height,avl[avl[now].r].height)+1;
}
inline void lx(int &now)
{
	int r=avl[now].r;
	avl[now].r=avl[r].l;
	avl[r].l=now;
	now=r;
	updata(avl[now].l);
	updata(now);
}
inline void rx(int &now)
{
	int l=avl[now].l;
	avl[now].l=avl[l].r;
	avl[l].r=now;
	now=l;
	updata(avl[now].r);
	updata(now);
}
int getBF(int now)
{
	return avl[avl[now].l].height-avl[avl[now].r].height;
}
inline void check(int &now)
{
	int nBF=getBF(now);
	if(nBF>1)//L
	{
		int lBF=getBF(avl[now].l);
		if(lBF>0)//LL
			rx(now);
		else //LR
			lx(avl[now].l),rx(now);
	}
	if(nBF<-1)//R
	{
		int rBF=getBF(avl[now].r);
		if(rBF<0)//RR
			lx(now);
		else //RL
			rx(avl[now].r),lx(now);
	}
	else if(now)updata(now);
}
inline void ins(int &now,int val)
{
	if(!now)newnode(now,val);
	else if(val<avl[now].val)ins(avl[now].l,val);
	else ins(avl[now].r,val);
	check(now);
}
int find(int &now,int fa)
{
	int res;
	if(!avl[now].l)
	{
		res=now;
		avl[fa].l=avl[now].r;	
	}	
	else 
	{
		res=find(avl[now].l,now);
		check(now);
	}
	return res;
} 
void del(int &now,int val)
{
	if(val==avl[now].val)
	{
		int l=avl[now].l,r=avl[now].r;
		if(!l||!r)now=l+r;
		else 
		{
			now=find(r,r);
			if(now!=r)avl[now].r=r;
			avl[now].l=l;
		}
	}
	else if(val<avl[now].val)
		del(avl[now].l,val);
	else del(avl[now].r,val);
	check(now);
}
int getrank(int val)
{
	int now=root,rank=1;
	while(now)
	{
		if(val<=avl[now].val)now=avl[now].l;
		else
		{
			rank+=avl[avl[now].l].size+1;
			now=avl[now].r;
		}
	}
	return rank;
}
int getnum(int rank)
{
	int now=root;
	while(now)
	{
		if(avl[avl[now].l].size+1==rank)break;
		else if(avl[avl[now].l].size>=rank)now=avl[now].l;
		else 
		{
			rank-=avl[avl[now].l].size+1;
			now=avl[now].r;
		}
	}
	return avl[now].val;
}
signed main()
{
	int n,t;
    scanf("%lld%lld",&n,&t);
    for(int i=1,v;i<=n;i++)scanf("%lld",&v),ins(root,v);
    int lst=0,ans=0;
    while(t--)
    {
        int opt,x;
        scanf("%lld%lld",&opt,&x);x^=lst;
        switch(opt)
        {
        case 1:ins(root,x);break;
        case 2:del(root,x);break;
        case 3:lst=getrank(x);break;
        case 4:lst=getnum(x);break;
        case 5:lst=getnum(getrank(x)-1);break;
        case 6:lst=getnum(getrank(x+1));break;
        }
        if(opt>=3&&opt<=6)ans^=lst;
    }
    printf("%lld",ans);
    return 0;
} 
```

























---

## 作者：BFqwq (赞：16)

## RBT

昨天已经发过一篇题解了qaq

但是莫名其妙还想发一篇玩玩。

居然有 AVL 树了，怎么能缺少我们可爱的红黑树呢QAQ

其实红黑树写起来并不难，主要注意一下两个修正就行了qaq

查询同其操作，插入的时候大力分类讨论。

红黑树的基础操作戳[这里](https://www.luogu.com.cn/blog/bfqaq/qian-tan-hong-hei-shu)

贴个代码（逃

```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read(){
	register int x=0;
	register bool f=0;
	register char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-') f=1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<3)+(x<<1)+c-48;
		c=getchar();
	}
	return f?-x:x;
}
char cr[200];int tt;
inline void print(int x,char k='\n') {
    if(!x) putchar('0');
    if(x < 0) putchar('-'),x=-x;
    while(x) cr[++tt]=x%10+'0',x/=10;
    while(tt) putchar(cr[tt--]);
    putchar(k);
}
const int inf=2147483647;
const int maxn=1100100;
struct rbt{
	int v,sz,cnt;
	bool col;
	int fa,ch[2];
}t[maxn*4];
int st[maxn*4],top,rt,tot,n,m,ans,lastans;
void pushup(int o){
	t[o].sz=t[t[o].ch[0]].sz+t[t[o].ch[1]].sz+t[o].cnt;
}
bool get(int o){
	return t[t[o].fa].ch[1]==o;
}
int newnode(int v){
	int o=top?st[top--]:++tot;
	t[o]=(rbt){v,1,1,1,0,0,0};
    return o;
}
void rotate(int o,bool c){
	int s1=t[o].ch[!c];
	t[o].ch[!c]=t[s1].ch[c];
	if (t[s1].ch[c])
		t[t[s1].ch[c]].fa=o;
    t[s1].fa=t[o].fa;
    if(!t[o].fa)
		rt=s1;
    else 
		t[t[o].fa].ch[get(o)]=s1;
    t[s1].ch[c]=o;
    t[o].fa=s1;
    pushup(o);
    pushup(s1);
}
void ins_fix(int o) {
	while(t[t[o].fa].col){
        int f=t[o].fa,gf=t[f].fa;
        bool wh=!get(f);
        int ul=t[gf].ch[wh];
        if(t[ul].col) {
            t[f].col=t[ul].col=0;
            t[gf].col=1;
            o=gf;
        }
		else{
			if(o==t[f].ch[wh])
            	rotate(o=f,!wh);
			else{
            	t[gf].col=1;
            	t[f].col=0;
            	rotate(gf,wh);
        	}
    	}
    }
    t[rt].col=0;
}
void ins(int v) {
    int o=rt,f=0;
    while(o){
        t[o].sz++,f=o;    
        if(v==t[o].v){
            t[o].cnt++;
            return;
        }
        o=t[o].ch[v>t[o].v];
    }
    o=newnode(v);
    if(f) t[f].ch[v>t[f].v]=o;
    else rt=o;
    t[o].fa=f;
    ins_fix(o);
}
int kth(int k) {
    int tmp;
    int o=rt;
    for (;o;) {
        tmp=t[t[o].ch[0]].sz;
        if (tmp+1<=k&&k<=tmp+t[o].cnt)
			break;
        else{
			if (k<=tmp)
				o=t[o].ch[0];
			else{
				k-=tmp+t[o].cnt;
				o=t[o].ch[1];
			}
		}
    }
    return t[o].v;
}
void update(int o){
	for(int i=o;i;i=t[i].fa){
		t[i].sz--;
	}
}
void del_fix(int o) {
    while(o!=rt&&!t[o].col) {
        bool wh=!get(o);
        int f=t[o].fa,ul=t[f].ch[wh];
        if(t[ul].col){
            t[ul].col=0;
            t[f].col=1;
            rotate(f,!wh);
            ul=t[f].ch[wh];
        }
		else{
			if(!t[t[ul].ch[0]].col&&!t[t[ul].ch[1]].col){
            	t[ul].col=1;
				o=f;
        	}
			else{
            	if(!t[t[ul].ch[wh]].col){
                	t[t[ul].ch[!wh]].col=0;
                	t[ul].col=1;
                	rotate(ul,wh);
                	ul=t[f].ch[wh];
            	}
            	t[ul].col=t[f].col;
            	t[t[ul].ch[wh]].col=t[f].col=0;
            	rotate(f,!wh);
            	break;
        	}
    	}
    }
    t[o].col=0;
}
void del(int v) {
	int o=rt;
	while(o&&t[o].v!=v){
		o=t[o].ch[t[o].v<v];
	}
    if(!o)return;
    if(t[o].cnt>1) {        
        t[o].cnt--;
        update(o);
        return;
    }
    int d=o,g=0;
    if(t[o].ch[0]&&t[o].ch[1]){
        d=t[o].ch[1];
        while(t[d].ch[0])
			d=t[d].ch[0];
    }
    g=t[d].ch[!t[d].ch[0]];
    t[g].fa=t[d].fa;
    if(!t[d].fa)
		rt=g;
    else t[t[d].fa].ch[get(d)]=g;
    if(o!=d){
    	t[o].v=t[d].v;
    	t[o].cnt=t[d].cnt;
	}
    update(t[d].fa);
    for(int i=t[d].fa;i&&t[d].cnt>1&&i!=o;i=t[i].fa){
    	t[i].sz-=t[d].cnt;
    	t[i].sz++;
    }
    if (!t[d].col) del_fix(g);
    st[++top]=d;
}
int rnk(int v) {
	ins(v);
    int tmp=0,sum=0;
    int o=rt;
    for (;o;) {
        tmp=t[t[o].ch[0]].sz;
        if(v==t[o].v)
			break;
        else{
			if(v<t[o].v)
				o=t[o].ch[0];
        	else{
				sum+=tmp+t[o].cnt,
				o=t[o].ch[1];
        	}
    	}
    }
    del(v);
    return sum+tmp+1;
}
int suf(int v) {
    int res=inf;
    int o=rt;
    for(;o;){
        if(t[o].v>v){
			res=t[o].v,
			o=t[o].ch[0];
		}
        else 
			o=t[o].ch[1];
    }
	return res;
}
int pre(int v) {
    int res=-inf;
    int o=rt;
    for(;o;){
        if(t[o].v<v){
			res=t[o].v,o=t[o].ch[1];
        }
        else
            o=t[o].ch[0];
    }
	return res;
}
signed main(){
	n=read();m=read();
	for(int i=1;i<=n;i++){
		int a=read();
		ins(a);
	}
    while(m--){
        int opt=read(),v=read()^lastans;
        if(opt==1) ins(v);
        if(opt==2) del(v);
        if(opt==3) lastans=rnk(v);
        if(opt==4) lastans=kth(v);
        if(opt==5) lastans=pre(v);
        if(opt==6) lastans=suf(v);
        if(opt!=1&&opt!=2)ans^=lastans;
    }
    print(ans);
    return 0;
}
```


---

## 作者：Alarm5854 (赞：12)

首先，推销一下我的新博客：https://yce3216037.github.io/post/luo-gu-p6136-ti-jie

这道题目怎么能没有AVL树呢？其实，在P3369，我就写了一篇AVL树的题解，链接在这里（第二篇可能没有图片，见谅），我就不再赘述了：  
https://www.luogu.com.cn/blog/YCE-22/solution-p3369  
https://yce3216037.github.io/post/luo-gu-p3369-ti-jie  

唯一需要注意的是，要找排名的数不一定有，所以还需要增加一个查找函数，代码如下：
```cpp
inline AVLtree Find(AVLtree& p, int x) {
	if (!p) return NULL;//找不到就返回空，否则就返回地址
	if (p->data == x) return p;
	if (p->data > x) return Find(p->ls, x);
	return Find(p->rs, x);
}
inline AVLtree find(int x) {
	return Find(root, x);
}
```
如果找不到这个数，就将这个数改为它的后继，所以，还需要预先加一个极大值来保证能过找到这个排名。

### 代码如下：
```cpp
#include<cstdio>
#include<algorithm>
#define int long long
using namespace std;
FILE *fin, *fout;
inline int read(int &x) {//快读，这题常数优化很重要
	char c = 0; int f = x = 0;
	while (c < 48 || c > 57) {
		if (c == -1) return 0;
		if (c == '-') f = 1; c = fgetc(fin);
	}
	while (c > 47 && c < 58) x = (x << 3) + (x << 1) + (c & 15), c = fgetc(fin);
	if (f) x = -x; return 1;
}
template<class T, class... Args> inline int read(T &x, Args&... args) {
	return read(x) + read(args...);
}
inline int write(int x) {
	if (x < 0) return fputc(45, fout), write(-x);
	if (x > 9) write(x / 10);
	return fputc((x % 10) | 48, fout), 1;
}
struct AVLnode;
typedef AVLnode* AVLtree;
struct AVLnode {//这个部分在之前P3369中的题解已经详细讲述了，这里我就不写注释了。
	int data, high;
	int freq, size;
	AVLtree ls, rs;
	AVLnode(): data(0), high(1), freq(1), size(1), ls(NULL), rs(NULL){}
	AVLnode(int a): data(a), high(1), freq(1), size(1), ls(NULL), rs(NULL){}
};
inline int GetSize(AVLtree p) {
	if (p == NULL) return 0;
	return p->size;
}
inline int GetHigh(AVLtree p) {
	if (p == NULL) return 0;
	return p->high;
}
struct AVL {
	AVLtree root;
	inline void update(AVLtree& p) {
		p->size = GetSize(p->ls) + GetSize(p->rs) + p->freq;
		p->high = max(GetHigh(p->ls), GetHigh(p->rs)) + 1;
	}
	inline void LeftPlus(AVLtree& p) {
		AVLtree q;
		q = p->ls;
		p->ls = q->rs;
		q->rs = p;
		update(p);
		update(q);
		p = q;
	}
	inline void RightPlus(AVLtree& p) {
		AVLtree q;
		q = p->rs;
		p->rs = q->ls;
		q->ls = p;
		update(p);
		update(q);
		p = q;
	}
	inline void LeftRight(AVLtree& p) {
		RightPlus(p->ls);
		LeftPlus(p);
	}
	inline void RightLeft(AVLtree& p) {
		LeftPlus(p->rs);
		RightPlus(p);
	}
	inline void Insert(AVLtree &p, int x) {
		if (p == NULL) {
			p = new AVLnode(x);
			return;
		}
		if (p->data == x) {
			++(p->freq);
			update(p);
			return;
		}
		if (p->data > x) {
			Insert(p->ls, x), update(p);
			if (GetHigh(p->ls) - GetHigh(p->rs) == 2) {
				if (x < p->ls->data)
					LeftPlus(p);
				else
					LeftRight(p);
			}
		}
		else {
			Insert(p->rs, x), update(p);
			if (GetHigh(p->rs) - GetHigh(p->ls) == 2) {
				if (x > p->rs->data)
					RightPlus(p);
				else
					RightLeft(p);
			}
		}
		update(p);
	}
	inline void insert(int x) {
		Insert(root, x);
	}
	inline AVLtree Find(AVLtree& p, int x) {//只不过多了一个查找操作
		if (!p) return NULL;
		if (p->data == x) return p;
		if (p->data > x) return Find(p->ls, x);
		return Find(p->rs, x);
	}
	inline AVLtree find(int x) {
		return Find(root, x);
	}
	inline void Erase(AVLtree& p, int x) {
		if (p == NULL) return;
		if (p->data > x) {
			Erase(p->ls, x), update(p);
			if (GetHigh(p->rs) - GetHigh(p->ls) == 2) {
				if (GetHigh(p->rs->rs) >= GetHigh(p->rs->ls))
					RightPlus(p);
				else
					RightLeft(p);
			}
		}
		else if(p->data < x) {
			Erase(p->rs, x), update(p);
			if (GetHigh(p->ls) - GetHigh(p->rs) == 2) {
				if (GetHigh(p->ls->ls) >= GetHigh(p->ls->rs))
					LeftPlus(p);
				else
					LeftRight(p);
			}
		}
		else {
			if (p->freq > 1) {
				--(p->freq);
				update(p);
				return;
			}
			if (p->ls && p->rs) {
				AVLtree q = p->rs;
				while (q->ls) q = q->ls;
				p->freq = q->freq;
				p->data = q->data, q->freq = 1;
				Erase(p->rs, q->data);
				update(p);
				if (GetHigh(p->ls) - GetHigh(p->rs) == 2) {
					if (GetHigh(p->ls->ls) >= GetHigh(p->ls->rs))
						LeftPlus(p);
					else
						LeftRight(p);
				}
			}
			else {
				AVLtree q = p;
				if (p->ls) p = p->ls;
				else if (p->rs) p = p->rs;
				else p = NULL;
				delete q;
				q = NULL;
			}
		}
		if (p == NULL) return;
		update(p);
	}
	inline void erase(int x) {
		Erase(root, x);
	}
	inline int get_val(AVLtree p, int rank) {
		if (GetSize(p->ls) >= rank) return get_val(p->ls, rank);
		if (GetSize(p->ls) + p->freq >= rank) return p->data;
		return get_val(p->rs, rank - GetSize(p->ls) - p->freq);
	}
	inline int GetVal(int rank) {
		return get_val(root, rank);
	}
	inline int get_rank(AVLtree p, int val) {
		if (p->data == val) return GetSize(p->ls) + 1;
		if (p->data > val) return get_rank(p->ls, val);
		return get_rank(p->rs, val) + GetSize(p->ls) + p->freq;
	}
	inline int GetRank(int val) {
		return get_rank(root, val);
	}
	inline int GetPrev(int val) {
		AVLtree ans = new AVLnode(-1LL << 42), p = root;
		while (p) {
			if (p->data == val) {
				if (p->ls) {
					p = p->ls;
					while (p->rs)
						p = p->rs;
					ans = p;
				}
				break;
			}
			if (p->data < val && p->data > ans->data) ans = p;
			p = p->data < val ? p->rs : p->ls;
		}
		return ans->data;
	}
	inline int GetNext(int val) {
		AVLtree ans = new AVLnode(1LL << 42), p = root;
		while (p) {
			if (p->data == val) {
				if (p->rs) {
					p = p->rs;
					while (p->ls)
						p = p->ls;
					ans = p;
				}
				break;
			}
			if (p->data > val && p->data < ans->data) ans = p;
			p = p->data < val ? p->rs : p->ls;
		}
		return ans->data;
	}
};
AVL a;
int n, m, x, opt, last, ans;
signed main() {
	#ifdef ONLINE_JUDGE
	fin = stdin;
	fout = stdout;
	#else
	fin = fopen("P6136.in", "rb");
	fout = fopen("P6136.out", "wb");
	#endif
	read(n, m), a.insert(1LL << 42);//极大值先插入
	for (int i = 1; i <= n; ++i) read(x), a.insert(x);//边读入边插入
	for (int i = 1; i <= m; ++i) {
		read(opt, x), x ^= last;//输入经过加密，要先解密
		switch(opt) {
			case 1: a.insert(x); break;
			case 2: a.erase(x); break;
			case 3:
				if (!a.find(x)) x = a.GetNext(x);//如果找不到，就改为后继
				last = a.GetRank(x), ans ^= last; break;
			case 4: last = a.GetVal(x), ans ^= last; break;
			case 5: last = a.GetPrev(x), ans ^= last; break;
			case 6: last = a.GetNext(x), ans ^= last; break;
		}
	}
	write(ans);
	return 0;
}
```

---

## 作者：小蒟蒻皮皮鱼 (赞：9)

fhq treap

简要回顾treap：

treap=tree+heap

它的形态是一棵二叉树，每个点的权值满足二叉搜索树的性质，每个点的随机值满足小根堆的性质

fhq treap的核心操作有两个：分裂和合并

分裂：对于给定的权值k，将一棵树分裂成两个，使得分裂后的两棵树一棵权值全部小于等于k，另一棵权值全部大于k，并且依旧满足分裂前的性质

![](https://cdn.luogu.com.cn/upload/image_hosting/mw0h5gfn.png)

如上图，每一个点前面的数表示权值，后面的数表示随机值

当我们遍历到一个点时，如果它的权值小于k，那么它的左子树会被分到左边的树里，然后我们遍历它的右儿子，如果大于等于k，则把它的右子树分到右边的树里，然后遍历他的左儿子。

比如这里我们令$k = 5$，那么我们一个子树里面是3的左子树和5的左子树，另一个子树里面是7的右子树和6的右子树

![](https://cdn.luogu.com.cn/upload/image_hosting/l4qwq22l.png)

```cpp
void split(int cnt, int k, int &x, int &y)//注意传址符 
{
	if(!cnt)//到达递归边界 
	{
		//这个时候有两种情况
		//如果是第一次分裂，则初始化0
		//如果到了叶子节点，x和y会在回溯的时候改变 
		x = y = 0;
		return;
	}
	if(T[cnt].val <= k)
	{
		x = cnt;//加入到x 
		split(T[cnt].r, k, T[cnt].r, y);
		//遍历右子树
		//之所以把r放到x的位置上是因为r的左子树也有可能在x中 
	}
	else//和上面反过来 
	{
		y = cnt;
		split(T[cnt].l, k, x, T[cnt].l);
	}
    Update(cnt);
}
```

合并：将两个子树按照随机值合并(因为要保证树的深度所以要按照随机值)

由于我们已经保证了两个子树权值的大小关系，所以只需每次让随机值小的在上面就行了

 ```cpp
int merge(int x, int y)
{
	if(x == 0) return y;
	if(y == 0) return x;
	if(T[x].pri <= T[y].pri)
	{//x小，把y接在右边 
		T[x].r = merge(T[x].r, y);
		Update(x);
		return x;
	}
	if(T[x].pri > T[y].pri)
	{//y小，把x接在左边 
		T[y].l = merge(x, T[y].l);
		Update(y);
		return y;
	}
}
 ```



第k大：

把握二叉搜索树的性质

```cpp
int kth(int cnt, int k)
{
	if(T[T[cnt].l].siz + 1 == k) return T[cnt].val;//这个数为根
	if(T[T[cnt].l].siz >= k) return kth(T[cnt].l, k);//在左区间
	else return kth(T[cnt].r, k - T[T[cnt].l].siz - 1);//右区间：排名-左儿子和自己
}
```

接下来是操作：

```cpp
if(opt == 1)
{//添加
	int x, y;
	split(root, a, x, y);//分离<=x和>x
	root = merge(merge(x, New(a)), y);//把x添加进去
}
if(opt == 2)
{//删除
	int x, y, z;
	split(root, a, x, y);//分离<=x和>x
	split(x, a - 1, x, z);//在<=x中分离<x和=x
	z = merge(T[z].l, T[z].r);//在=x中删除一个x
	root = merge(merge(x, z), y);//将剩余的合并
}
if(opt == 3)
{//查询x排名
	int x, y;
	split(root, a - 1, x, y);//分离<x和>=x
	cout << T[x].siz + 1 << endl;//x的排名为<=x的数的个数
	root = merge(x, y);//合并
}
if(opt == 4)
{//查询排名x的数
	cout<< kth(root, a) << endl;
}
if(opt == 5)
{//求x前驱
	int x, y;
	split(root, a - 1, x, y);//分离<x和>=x
	cout << kth(x, T[x].siz) << endl;//前驱就是<x的数的个数的那个数
	root = merge(x, y);//合并
}
if(opt == 6)
{//求x后继
	int x, y;
	split(root, a, x, y);//分离<=x和>x
	cout << kth(y, 1) << endl;//>x中最小的那个数
	root = merge(x, y);//合并
}
```

对于这道题，要注意的就是$N$的范围。极限数据treap里面的点最多可能有$1100000$个
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1100005;
int read()
{
	int ans = 0;
	char c = getchar(), last = ' ';
	while(c < '0' || c > '9') last = c, c = getchar();
	while(c >= '0' && c <= '9') ans = (ans << 1) + (ans << 3) + c - '0', c = getchar();
	if(last == '-') ans = - ans;
	return ans;
}
int ecnt;
struct tree
{
	int l, r, siz, rad, val;
}t[N<<2];
unsigned long long seed = 1;
int Rand()
{
	seed *= 260817;
	return int(seed);
}
void update(int cnt)
{
	t[cnt].siz = t[t[cnt].l].siz + t[t[cnt].r].siz + 1;
}

int New(int x)
{
	t[++ecnt].val = x;
	t[ecnt].rad = Rand();
	t[ecnt].siz = 1;
	return ecnt;
}

void split(int cnt, int k, int &x, int &y)
{
	if(!cnt)
	{
		x = y = 0;
		return;
	}
	if(t[cnt].val <= k)
	{
		x = cnt;
		split(t[cnt].r, k, t[cnt].r, y);
	}
	if(t[cnt].val > k)
	{
		y = cnt;
		split(t[cnt].l, k, x, t[cnt].l);
	}
	update(cnt);
}

int merge(int x, int y)
{
	if(x == 0) return y;
	if(y == 0) return x;
	if(t[x].rad <= t[y].rad)
	{
		t[x].r = merge(t[x].r, y);
		update(x);
		return x;
	}
	else if(t[x].rad > t[y].rad)
	{
		t[y].l = merge(x, t[y].l);
		update(y);
		return y;
	}
}

int kth(int cnt, int k)
{
	if(t[t[cnt].l].siz + 1 == k) return t[cnt].val;
	if(t[t[cnt].l].siz >= k) return kth(t[cnt].l, k);
	else return kth(t[cnt].r, k - t[t[cnt].l].siz - 1);
}

int n, m, rt;
int last = 0, ans = 0;

int main()
{
	//freopen("1.in", "r", stdin);
	//freopen("1.out", "w", stdout); 
	//srand(time(0));
	scanf("%d%d", &n, &m);
	int x, y, z, k, opt;
	for(int i = 1; i <= n; i ++)
	{
		k = read();
		split(rt, k, x, y);
		rt = merge(merge(x, New(k)), y);
	}
	for(int i = 1; i <= m; i ++)
	{
		opt = read(), k = read();
		k ^= last;
		if(opt == 1) 
		{
			split(rt, k, x, y);
			rt = merge(merge(x, New(k)), y);
		}
		if(opt == 2)
		{
			split(rt, k, x, y);
			split(x, k - 1, x, z);
			z = merge(t[z].l, t[z].r);
			rt = merge(merge(x, z), y); 
		}
		if(opt == 3)
		{
			split(rt, k - 1, x, y);
			last = t[x].siz + 1;
			ans ^= last;
			//printf("%lld\n", last);
			rt = merge(x, y);
		}
		if(opt == 4)
		{
			last = kth(rt, k);
			ans ^= last;
			//printf("%lld\n", last);
		}
		if(opt == 5)
		{
			split(rt, k - 1, x, y);
			last = kth(x, t[x].siz);
			ans ^= last;
			//printf("%lld\n", last);
			rt = merge(x, y);
		}
		if(opt == 6)
		{
			split(rt, k, x, y);
			last = kth(y, 1);
			ans ^= last;
			//printf("%lld\n", last);
			rt = merge(x, y);
		}
	}
	printf("%d", ans);
}
```

---

## 作者：EternalEpic (赞：9)

事实上，如果不需要全局平衡二叉树之类的玩意，也不写AVL，RBT之类的代码繁琐的复杂平衡树，**FHQTreap** 其实可以满足大部分oi比赛中平衡树的性能，也较简单（适合小白学）。

这一题，正常的**FHQTreap**就可以过，不需要特殊种子异或各种卡常，可能是大家写法的不同吧，我就来展示一下自己的代码。

**FHQTreap**是用**merge**和**split**来维护二叉树形状的二叉树，它和**Treap**一样有堆的性质，用随机优先级来维护。

**split**指将一棵树以**val**分裂为两棵树，一颗所有的节点都小于等于**val**，另一则大于。

**merge**就是用堆的优先级重新将两棵树合并。

我们只需在插入删除时执行两种操作，就可以让它不退化。

```cpp
enum {
	Maxn = 1000005
};

struct FHQTreap {
	int lson[Maxn], rson[Maxn], data[Maxn];
	int rnd[Maxn], sze[Maxn], root, tot, seed;
	FHQTreap(void) {
		Ms(lson, 0), Ms(rson, 0), Ms(data, 0);
		Ms(rnd, 0), Ms(sze, 0), root = tot = 0, seed = 1;
	}
	
	inline int _rand(void) { return seed *= 482711; }
	inline void pushup(int pos) { sze[pos] = sze[lson[pos]] + sze[rson[pos]] + 1; }
	inline void split(int pos, int val, int &x, int &y) {
		if (!pos) { x = y = 0; return; }
		if (data[pos] <= val) x = pos, split(rson[pos], val, rson[pos], y);
		else y = pos, split(lson[pos], val, x, lson[pos]); pushup(pos);
	}
	
	inline int merge(int x, int y) {
		if (!x || !y) return x + y;
		if (rnd[x] < rnd[y]) return rson[x] = merge(rson[x], y), pushup(x), x;
		else return lson[y] = merge(x, lson[y]), pushup(y), y;
	}
	
	inline void insert(int val) {
		int x, y, pos = ++tot;
		data[pos] = val, sze[pos] = 1, rnd[pos] = _rand();
		split(root, val, x, y);
		root = merge(merge(x, pos), y);
	}
	
	inline void remove(int val) {
		int x, y, z;
		split(root, val - 1, x, y);
		split(y, val, y, z); if (!y) return;
		y = merge(lson[y], rson[y]);
		root = merge(x, merge(y, z));
	}
	
	inline int query_rank(int val) {
		int x, y, ret;
		split(root, val - 1, x, y);
		ret = sze[x] + 1; root = merge(x, y);
		return ret;
	}
	
	inline int select(int kth) {
		int pos = root;
		while (kth != sze[lson[pos]] + 1)
			if (kth <= sze[lson[pos]]) pos = lson[pos];
			else kth -= sze[lson[pos]] + 1, pos = rson[pos];
		return data[pos];
	}
	
	inline int pred(int val) { return select(query_rank(val) - 1); }
	inline int succ(int val) { return select(query_rank(val + 1)); }
} treap;
```


---

## 作者：那一条变阻器 (赞：7)

# 大爱替罪羊树

------------

懂替罪羊树的dalao可以直接看最后这道题的程序。

------------

那么就从[这道题](https://www.luogu.com.cn/problem/P3369)开始讲替罪羊树吧。

#### 概念/思想

替罪羊树属于平衡树的一种，但是他维护平衡的方式不是复杂的旋转，而是直接把这棵子树直接掰下来拍扁重建，再放回去就okk了~~所以暴力天下第一啊~~。

#### 实现：

0. 变量名的定义/含义：
```cpp
struct node{
	int ls , rs , tsize/*真正的大小，包括删除的*/ , fsize/*只有真正存在的点的大小*/ , date/*值*/ , f/*是否存在*/; 
};
node a[400040];
int root/*根节点*/ , pool/*内存池的指针*/ , poi/*存储中序遍历后的数组的指针*/ , n;
double alpha = 0.75;
int memo[400040]/*内存池*/ , c[400040]/*存储中序遍历后的数*/;
```
内存池：因为动态开点会很慢，不如提前申请空间，要用的时候从里面取就是了。注意！因为我们程序里面的树[层序遍历](https://baike.sogou.com/v538762.htm?fromTitle=%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86)的点并不是有序的，所以这样给点是没问题的（就像有可能节点$3$的儿子可能是$6$和$11$，而父亲又为$33$）。

而为什么说$tsize$和$fsize$分为包括了删除了的和不包括删除了的呢？因为替罪羊树是惰性删除，只是打个标记而已，真正的删除在重建的时候。

1. 核心操作：判断是否拍扁

这里对于一棵树是否需要拍扁，我们用到一个东西，叫平衡因子，当这个树总的大小乘一个平衡因子的时候，还没有其中大的那个儿子的子树大时，就重建。平衡因子一般取0.5 ~ 1，但是由于太小的话，拍扁次数就太多了，太大的话，拍扁次数太少了，都不行，所以一般是去0.7 ~ 0.8，我一般用$0.75$。

```cpp
bool cheak(int now){	//判断是否重建 
	if((double)a[now].fsize * alpha >= (double)max(a[a[now].ls].fsize , a[a[now].rs].fsize)) return true;
	return false;
}
```
2. 插入：

这个就跟普通的二叉查找树一样的了，只不过插完后要判断一下是否重建。
```cpp
void insert(int &now , int t){	//插入数t 
	if(!now){
		now = memo[pool--];	//从内存池偷一个节点 
		a[now].date = t;
		a[now].f = a[now].fsize = a[now].tsize = 1;
		a[now].ls = a[now].rs = 0;
		return;
	}
	a[now].fsize++ , a[now].tsize++;	//下面会更新一个节点，所以上面的每一个节点都要加一 
	if(a[now].date >= t) insert(a[now].ls , t);
	else insert(a[now].rs , t);
	if(!cheak(now)) rebuild(now);	//插入一个点后可能会不平衡的 
}
```
3. 建树/重建：

当我们的需要重建时，这颗树也一定是一颗二叉查找树，所以中序遍历一定是有序的，所以我们只需要进行一次中序遍历，然后对这个序列，从中间开始往两边二分进行建树（如果这里不是很懂的话可以先看看代码，然后手推一下，为什么对于一个有序序列从中间开始建树是平衡的）。
```cpp
void dfs(int now){	//中序遍历 
	if(!now) return;
	dfs(a[now].ls);
	if(a[now].f) c[++poi] = now;
	else memo[++pool] = now;	//在这里真正删除点 ，然后把这个点丢回内存池 
	dfs(a[now].rs);
}
void build(int l , int r , int &now){	//建树 
	int mid = (l + r) / 2;
	now = c[mid];
	if(l == r){	//叶子节点 
		a[now].ls = a[now].rs = 0;
		a[now].fsize = a[now].tsize = 1;
		return;
	}
	if(l < mid) build(l , mid - 1 , a[now].ls); //在l=mid的时候再进行就会出现l>r的情况，直接令他左儿子为0就可以了 
	else a[now].ls = 0;
	build(mid + 1 , r , a[now].rs);	//因为除法总是向下取整，所以mid总是小于r的，所以不会出现l>r的情况 
	a[now].fsize = a[a[now].ls].fsize + a[a[now].rs].fsize + 1;	//更新 
	a[now].tsize = a[a[now].ls].tsize + a[a[now].rs].tsize + 1;
}
void rebuild(int &now){	//重建 
	poi = 0;	//记得清0！ 
	dfs(now);
	if(poi) build(1 , poi , now);	//有可能这一颗树都是被过惰性过标记的，所以要判断一下是否有节点 
	else now = 0;
}
```
4. 查找排名为rk的数：

这个也跟二叉查找树一样的，不断判断，然后看是否到达即可。注意判断的那里因为惰性标记所以不一样（具体为什么可以看下面的delet删除函数）。
```cpp
int ft(int rk){	//查找排名为rk的数 
	int now = root;
	while(now){	//递推查找（也可以递归的，只不过要重新写一个函数，麻烦点） 
		if(a[now].f && a[a[now].ls].fsize + 1 == rk) return a[now].date;
		else if(a[a[now].ls].fsize >= rk) now = a[now].ls;
		else{
			rk -= a[a[now].ls].fsize + a[now].f;
			now = a[now].rs;
		}
	}
}
```
5. 查找数t的排名：

也跟二叉查找数一样，注意下对排名的统计是每次走右子树时累加左子树的个数（具体为什么还是看delet删除函数）。
```cpp
int frk(int t){
	int now = root , ans = 1;
	while(now){	//递推查找（也可以递归的，只不过要重新写一个函数，麻烦点）
		if(a[now].date >= t) now = a[now].ls;
		else{
			ans += a[a[now].ls].fsize + a[now].f;
			now = a[now].rs;
		}
	}
	return ans;
}
```
6. 删除排名为rk的数/删除数k：

这里的删除只是打上标记而已，具体看代码吧~（上面的问题也都在代码里面）
```cpp
void delet(int &now , int rk){	//删除排名为rk的数 
	if(a[now].f && a[a[now].ls].fsize + 1 == rk){
		/*解释一下不是这样写的：a[a[now].ls].fsize + a[now].f == rk
		因为有可能这我们走的这一条路有很多被删除了点（只打了标记），但是a[a[now].ls].fsize的值有可能为rk，
		实际上是还没有到达那个该删除的点的 ， 
		所以一个先判断一下这个点先是否存在，再进行删除 */
		a[now].f = 0;	//惰性删除，只是打个标记，在中序遍历时才真正删除
		a[now].fsize--;
		return;
	}
	a[now].fsize--;	//跟insert那个操作很像，下面删掉一个节点，所以一个将fsize减一，但是tsize不用减 
	if(a[a[now].ls].fsize + a[now].f >= rk) delet(a[now].ls , rk);	
	else delet(a[now].rs , rk - a[a[now].ls].fsize - a[now].f);
	/*解释一下为什么rk要减去左子树和根节点
	因为我们来到的是一颗新的子树，要减去左边的排名才可以进入新的子树，相当于把树不断变小，排名也不断变小了
	但是左子树为什么不用减呢？
	因为我们某个点的排名应该是从这个点往右子树走时累加左子树之和，所以这里是不能累加排名的（可以看下ft和frk函数里面的操作） 
	这个地方可能很不好理解，可以自己画图模拟一下，会好很多
	这可能就是只可意会不可言传吧~*/
}
void rdelet(int t){	//删除值为t的数 
	delet(root , frk(t));
	if((double)a[root].tsize * alpha >= a[root].fsize) rebuild(root);	//删除太多了，惰性标记的节点太多也会降低查找速度 
}
```

------------

上完整代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
struct node{
	int ls , rs , tsize/*真正的大小，包括未删除的*/ , fsize/*只有真正存在的点的大小*/ , date/*值*/ , f/*是否存在*/; 
};
node a[400040];
int root/*根节点*/ , pool/*内存池的指针*/ , poi/*存储中序遍历后的数组的指针*/ , n;
double alpha = 0.75;
int memo[400040]/*内存池*/ , c[400040]/*存储中序遍历后的数*/;
bool cheak(int now){	//判断是否重建 
	if((double)a[now].fsize * alpha >= (double)max(a[a[now].ls].fsize , a[a[now].rs].fsize)) return true;
	return false;
}
void dfs(int now){	//中序遍历 
	if(!now) return;
	dfs(a[now].ls);
	if(a[now].f) c[++poi] = now;
	else memo[++pool] = now;	//在这里真正删除点 ，然后把这个点丢回内存池 
	dfs(a[now].rs);
}
void build(int l , int r , int &now){	//建树 
	int mid = (l + r) / 2;
	now = c[mid];
	if(l == r){	//叶子节点 
		a[now].ls = a[now].rs = 0;
		a[now].fsize = a[now].tsize = 1;
		return;
	}
	if(l < mid) build(l , mid - 1 , a[now].ls); //在l=mid的时候再进行就会出现l>r的情况，直接令他左儿子为0就可以了 
	else a[now].ls = 0;
	build(mid + 1 , r , a[now].rs);	//因为除法总是向下取整，所以mid总是小于r的，所以不会出现l>r的情况 
	a[now].fsize = a[a[now].ls].fsize + a[a[now].rs].fsize + 1;	//更新 
	a[now].tsize = a[a[now].ls].tsize + a[a[now].rs].tsize + 1;
}
void rebuild(int &now){	//重建 
	poi = 0;	//记得清0！ 
	dfs(now);
	if(poi) build(1 , poi , now);	//有可能这一颗树都是被过标记的，所以要判断一下是否有节点 
	else now = 0;
}
void insert(int &now , int t){	//插入数t 
	if(!now){
		now = memo[pool--];	//从内存池偷一个节点 
		a[now].date = t;
		a[now].f = a[now].fsize = a[now].tsize = 1;
		a[now].ls = a[now].rs = 0;
		return;
	}
	a[now].fsize++ , a[now].tsize++;	//下面会更新一个节点，所以上面的每一个节点都要加一 
	if(a[now].date >= t) insert(a[now].ls , t);
	else insert(a[now].rs , t);
	if(!cheak(now)) rebuild(now);	//插入一个点后可能会不平衡的 
}
void delet(int &now , int rk){	//删除排名为rk的数 
	if(a[now].f && a[a[now].ls].fsize + 1 == rk){
		/*解释一下不是这样写的：a[a[now].ls].fsize + a[now].f == rk
		因为有可能这我们走的这一条路有很多被删除了点（只打了标记），但是a[a[now].ls].fsize的值有可能为rk，
		实际上是还没有到达那个该删除的点的 ， 
		所以一个先判断一下这个点先是否存在，再进行删除 */
		a[now].f = 0;	//惰性删除，只是打个标记，在中序遍历时才真正删除
		a[now].fsize--;
		return;
	}
	a[now].fsize--;	//跟insert那个操作很像，下面删掉一个节点，所以一个将fsize减一，但是tsize不用减 
	if(a[a[now].ls].fsize + a[now].f >= rk) delet(a[now].ls , rk);	
	else delet(a[now].rs , rk - a[a[now].ls].fsize - a[now].f);
	/*解释一下为什么rk要减去左子树和根节点
	因为我们来到的是一颗新的子树，要减去左边的排名才可以进入新的子树，相当于把树不断变小，排名也不断变小了
	但是左子树为什么不用减呢？
	因为我们某个点的排名应该是从这个点往右子树走时累加左子树之和，所以这里是不能累加排名的（可以看下ft和frk函数里面的操作） 
	这个地方可能很不好理解，可以自己画图模拟一下，会好很多
	这可能就是只可意会不可言传吧~*/
}
int ft(int rk){	//查找排名为rk的数 
	int now = root;
	while(now){	//递推查找（也可以递归的） 
		if(a[now].f && a[a[now].ls].fsize + 1 == rk) return a[now].date;
		else if(a[a[now].ls].fsize >= rk) now = a[now].ls;
		else{
			rk -= a[a[now].ls].fsize + a[now].f;
			now = a[now].rs;
		}
	}
}
int frk(int t){
	int now = root , ans = 1;
	while(now){	//递推查找（也可以递归的）
		if(a[now].date >= t) now = a[now].ls;
		else{
			ans += a[a[now].ls].fsize + a[now].f;
			now = a[now].rs;
		}
	}
	return ans;
}
void rdelet(int t){	//删除值为t的数 
	delet(root , frk(t));
	if((double)a[root].tsize * alpha >= a[root].fsize) rebuild(root);	//删除太多了，惰性标记的节点太多也会降低查找速度 
}
int main(){
	cin >> n;
	for(int i = 400000; i >= 1; i--) memo[++pool] = i;	//预处理内存池 
	while(n--){
		int opt , x;
		cin >> opt >> x;
		if(opt == 1) insert(root , x);
		if(opt == 2) rdelet(x);
		if(opt == 3) cout << frk(x) << endl;
		if(opt == 4) cout << ft(x) << endl;
		if(opt == 5) cout << ft(frk(x) - 1) << endl;	//根据程序和题目，自己可以想下为什么输出前驱和后继的方式不一样 
		if(opt == 6) cout << ft(frk(x + 1)) << endl;
		/*解释为什么驱和后继的方式不一样：
		因为有可能有多个一样的数，查找后继的时候加一就可以找到后面的第一个比他大的数
		即使这个数字不存在，由于我们程序编程的方式，也是可以找到正确的数哒 
		然后找前驱的时候不能ft(frk(x - 1))，因为这个数字如果不存在的话，找到的就是x - 1后面一个数，也就是原数*/
	}
	return 0;
}
```

------------

那么这道题的话，在上面的程序的主程序改一下就行了。

下面就直接给出代码了qwq：

```cpp
#include <bits/stdc++.h>
using namespace std;
int read(){
    int ans = 0;
	char ch = getchar();
    while(ch > '9' || ch < '0') ch = getchar();
    while(ch <= '9' && ch >= '0'){
        ans = ans * 10 + ch - '0';
        ch = getchar();
    }
    return ans;
}
struct node{
	int ls , rs , f , tsize , fsize , date;
};
node a[2000010];
int memo[2000010] , c[2000010] , ha[2000010];
double alpha = 0.75;
int n , m , root , pool , poi , last , ans;
bool cheak(int now){
	if((double)a[now].fsize * alpha >= (double)max(a[a[now].ls].fsize , a[a[now].rs].fsize)) return true;
	return false;
}
void dfs(int now){
	if(!now) return;
	dfs(a[now].ls);
	if(a[now].f) c[++poi] = now;
	else memo[++pool] = now;
	dfs(a[now].rs);
}
void build(int l , int r , int &now){
	int mid = (l + r) / 2;
	now = c[mid];
	if(l == r){
		a[now].ls = a[now].rs = 0;
		a[now].fsize = a[now].tsize = 1;
		return;
	}
	if(l < mid) build(l , mid - 1 , a[now].ls);
	else a[now].ls = 0;
	build(mid + 1 , r , a[now].rs);
	a[now].fsize = a[a[now].ls].fsize + a[a[now].rs].fsize + 1;
	a[now].tsize = a[a[now].ls].tsize + a[a[now].rs].tsize + 1;
}
void rebuild(int &now){
	poi = 0;
	dfs(now);
	if(poi) build(1 , poi , now);
	else now = 0;
}
void insert(int &now , int t){
	if(!now){
		now = memo[pool--];
		a[now].date = t;
		a[now].fsize = a[now].tsize = a[now].f = 1;
		a[now].ls = a[now].rs = 0;
		return;
	}
	a[now].fsize++ , a[now].tsize++;
	if(a[now].date >= t) insert(a[now].ls , t);
	else insert(a[now].rs , t);
	if(!cheak(now)) rebuild(now);
}
int ft(int rk){
	int now = root;
	while(now){
		if(a[now].f && a[a[now].ls].fsize + 1 == rk) return a[now].date;
		if(a[a[now].ls].fsize + a[now].f >= rk) now = a[now].ls;
		else{
			rk -= a[a[now].ls].fsize + a[now].f;
			now = a[now].rs;
		}
	}
}
int frk(int t){
	int now = root , ans = 1;
	while(now){
		if(a[now].date >= t) now = a[now].ls;
		else{
			ans += a[a[now].ls].fsize + a[now].f;
			now = a[now].rs;
		}
	}
	return ans;
}
void delet(int &now , int rk){
	if(a[now].f && a[a[now].ls].fsize + 1 == rk){
		a[now].f = 0;
		a[now].fsize--;
		return;
	}
	a[now].fsize--;
	if(a[now].f + a[a[now].ls].fsize >= rk) delet(a[now].ls , rk);
	else delet(a[now].rs , rk - a[now].f - a[a[now].ls].fsize);
}
void rdelet(int t){
	delet(root , frk(t));
	if(a[root].tsize * alpha >= a[root].fsize) rebuild(root);
}
int main(){
	n = read() , m = read();
	for(int i = 1; i <= n; i++) ha[i] = read();
	sort(ha + 1 , ha + n + 1);	//手动中序遍历 
	for(int i = 2000000; i >= 1; i--) memo[i] = ++pool;
	for(int i = 1; i <= n; i++){
		c[i] = i;	//模拟dfs操作 
		a[i].date = ha[i];	//把值放回去 
		a[i].f = 1;	//这个点存在 
	}
	pool -= n;	//用了n个内存，内存池里面取n出来 
	build(1 , n , root);	//建树 
	while(m--){
		int opt , x , y;
		opt = read() , x = read();
		x = last ^ x;
		if(opt == 1) insert(root , x);
		if(opt == 2) rdelet(x);
        if(opt == 3) y = frk(x) , ans = ans ^ y , last = y;
        if(opt == 4) y = ft(x) , ans = ans ^ y , last = y;
        if(opt == 5) y = ft(frk(x) - 1) , ans = ans ^ y , last = y;
        if(opt == 6) y = ft(frk(x + 1)) , ans = ans ^ y , last = y;
	}
	cout << ans;
	return 0;
}
```

------------

吐槽：这道题数据还是有点水吧，比较未加强数据的直接搬过来能AC，可能是为了卡朝鲜树之类的数据结构吧。

---

## 作者：K0stlin (赞：7)

## AVL树是一种让每个节点的左右子树高度相差不超过1的平衡树，所以查找的常数很小，而修改略大

看到有AVL树的题解了，在此不多赘述。

但是他是用指针写的可能会慢，所以发一篇数组实现的（希望在学完AVL树后看看本代码。

CODE:
```cpp
#include <cstdio>
const int N=1e5+1e6+5;
int n,m,k,x,cnt,root,last,ans;
struct jd {
	int l,r,val,size;
	int ht;//树高
}t[N]; 
inline int read(){
	int x=0,flag=0;char ch=getchar();
	while(ch<'0'||ch>'9'){flag|=(ch=='-');ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return flag?-x:x;
}
inline int newt(int val) {
	t[++cnt]=(jd) {0,0,val,1,0};
	return cnt;
}
inline int mx(int x,int y) {return x>y?x:y;}

inline int bf(int now) {return t[t[now].l].ht-t[t[now].r].ht;}
inline void update(int now) {
	t[now].size=t[t[now].l].size+t[t[now].r].size+1;
	t[now].ht=mx(t[t[now].l].ht,t[t[now].r].ht)+1;
}
inline void lt(int &now) {//左旋
	int y=t[now].r;
	t[now].r=t[y].l;
	t[y].l=now;
	now=y;
	update(t[now].l);
	update(now); 
}
inline void rt(int &now) {//右旋
	int y=t[now].l;
	t[now].l=t[y].r;
	t[y].r=now;
	now=y;
	update(t[now].r);
	update(now);
}

inline void ch(int &now) {//对now子树进行维护
	int s=bf(now);
	if(s>1) {
		int ss=bf(t[now].l);
		if(ss>0) rt(now);//LL
		else lt(t[now].l),rt(now);//LR
	}
	else if(s<-1){
		int ss=bf(t[now].r);
		if(ss<0) lt(now);//RR
		else rt(t[now].r),lt(now);//RL
	}
	else if(now) update(now);
}

void ins(int &now,int val) {
	if(!now) now=newt(val);
	else if(t[now].val<=val) ins(t[now].r,val);
	else ins(t[now].l,val);
	ch(now);
}

void del(int &now,int val) {//我是使用将其旋转至叶子节点后删除的
	if(t[now].val==val) {
		if(!t[now].l||!t[now].r)now=t[now].l^t[now].r;
		else if(bf(now)<0) rt(now),del(now,val);//右子树高，旋转至左儿子位置可略减小维护的常数
		else lt(now),del(now,val);//同上
	}
	else if(val>=t[now].val) del(t[now].r,val);
	else del(t[now].l,val);
	ch(now);
}

inline int rank(int val) {
	int now=root,s=0;
	while(now) {
		if(t[now].val>=val) now=t[now].l;
		else s+=t[t[now].l].size+1,now=t[now].r;
	}
	return s+1;
}

inline int num(int val) {
	int now=root;
	while(now) {
		if(t[t[now].l].size+1==val)
			return t[now].val;
		if(t[t[now].l].size>=val) now=t[now].l;
		else val=val-t[t[now].l].size-1,now=t[now].r;
	}
}
int main() {
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	n=read();m=read();
	for(int i=1;i<=n;++i)
		ins(root,read());
	while(m--) {
		k=read();x=read();
		x^=last;
		switch(k) {
			case 1:
				ins(root,x);
				break;
			case 2:
				del(root,x);
				break;
			case 3:
				ans^=last=rank(x);
				break;
			case 4:
				ans^=last=num(x);
				break;
			case 5:
				ans^=last=num(rank(x)-1);
				break;
			case 6:
				ans^=last=num(rank(x+1));
				break;
		}
	}
	printf("%d\n",ans);
	return 0;
}

```
-完-

---

## 作者：feecle6418 (赞：7)

好像还没有替罪羊树的题解。我来发一个。

替罪羊树的核心思想很简单，就是假如子树不平衡了，就暴力重构。

具体地，假如一颗子树中左儿子大小远大于右儿子（或者反过来），就应该重构这棵子树。“远大于”是模糊的说法，实现的时候可以取“3 倍”这个阈值。

怎么重构？把子树有序地压到 vector 里面，从中间往两边递归连边，类似于建线段树，就能建出完全平衡的一颗子树了。

跑得很快，远快于普通的 Splay。不加快读，最大的点不到一秒。因此，在需要卡常的题目中，都可以考虑替罪羊树。

具体实现看代码。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#define MaxN 1100005
using namespace std;
struct Scape_Goat_Tree{
	int ls[MaxN],rs[MaxN],fa[MaxN],val[MaxN],size[MaxN],all[MaxN];
	int exi[MaxN];
	int tot,top,stack[MaxN],root;
	Scape_Goat_Tree():tot(0),top(0),root(0){}
	void PushUp(int p){
		all[p]=all[ls[p]]+all[rs[p]]+1;
		size[p]=size[ls[p]]+size[rs[p]]+exi[p];
	}
	bool NeedRefac(int p){
		return all[ls[p]]>all[p]*0.75||all[rs[p]]>all[p]*0.75;
	}
	int GetNewNode(int v,int father){
		int p;
		if(top)p=stack[top--];
		else p=++tot;
		ls[p]=rs[p]=0;
		exi[p]=size[p]=all[p]=1;
		fa[p]=father;
		val[p]=v;
		return p;
	}
	void DFS(int p,vector<int> &tmp){
		if(ls[p])DFS(ls[p],tmp);
		if(exi[p])tmp.push_back(p);
		else stack[++top]=p;
		if(rs[p])DFS(rs[p],tmp);
	}
	int Rebuild(int l,int r,vector<int> &tmp){
		if(l>r)return 0;
		int mid=(l+r)>>1,p=tmp[mid];
		ls[p]=Rebuild(l,mid-1,tmp);
		rs[p]=Rebuild(mid+1,r,tmp);
		fa[ls[p]]=fa[rs[p]]=p;
		PushUp(p);
		return p;
	}
	void Refactor(int &p){
		vector<int> tmp;
		int ftmp=fa[p];
		DFS(p,tmp);
		p=Rebuild(0,tmp.size()-1,tmp);
		fa[p]=ftmp;
	}
	int GetRank(int v){
		int p=root,ans=1;
		while(p){
			if(v<=val[p])p=ls[p];
			else {
				ans+=size[ls[p]]+exi[p];
				p=rs[p];
			}
		}
		return ans;
	}
	int GetKth(int k){
		if(k<=0)return -2147483647;
		if(k>size[root])return 2147483647;
		int p=root;
		while(p){
			if(size[ls[p]]+1==k&&exi[p])return val[p];
			if(size[ls[p]]>=k)p=ls[p];
			else k-=size[ls[p]]+exi[p],p=rs[p];
		}
	}
	int InsRet(int &p,int father,int v){
		if(!p){
			p=GetNewNode(v,father);
			return 0;
		}
		int res;
		if(v<=val[p])res=InsRet(ls[p],p,v);
		else res=InsRet(rs[p],p,v);
		PushUp(p);
		if(NeedRefac(p))res=p;
		return res;
	}
	void Insert(int v){
		int p=InsRet(root,0,v);
		if(!p)return ;
		if(p==root)Refactor(root);
		else {
			int father=fa[p];
			if(p==ls[father])Refactor(ls[father]);
			else Refactor(rs[father]);
		}
	}
	void DelKth(int p,int k){
		size[p]--;
		if(exi[p]&&k==size[ls[p]]+exi[p]){
			exi[p]=0;
			return ;
		}
		if(k<=size[ls[p]])DelKth(ls[p],k);
		else DelKth(rs[p],k-size[ls[p]]-exi[p]);
	}
	void Delete(int v){
		DelKth(root,GetRank(v));
		if(size[root]<all[root]*0.75)Refactor(root);
	}
	int Pred(int v){
		return GetKth(GetRank(v)-1);
	}
	int Succ(int v){
		return GetKth(GetRank(v+1));
	}
}tree;
int main(){
	int n,q,ans=0,la=0;
	scanf("%d%d",&n,&q);
	while(n--){
		int x;
		scanf("%d",&x);
		tree.Insert(x);
	}
	while(q--){
		int opt,x;
		scanf("%d%d",&opt,&x),x^=la;
		if(opt==1)tree.Insert(x);
		if(opt==2)tree.Delete(x);
		if(opt==3)ans^=(la=tree.GetRank(x));
		if(opt==4)ans^=(la=tree.GetKth(x));
		if(opt==5)ans^=(la=tree.Pred(x));
		if(opt==6)ans^=(la=tree.Succ(x));
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：X_G_H_D_S_G_S_D_H (赞：6)

**Size Balanced Tree**

看到题解里没有优秀的 SBT 算法，本蒟蒻就来写一下这种效率很高的算法吧。~~其实我只是觉得它的名字很好听。~~

同时由于我在查询此算法有关文章时，发现大部分人都没有 $cnt$ 数组，这样会浪费一部分空间，于是在思考之后，本蒟蒻写了一种带有 $cnt$ 数组的 SBT 。

下面是我定义的结构体。
```
struct node
{
	int ch[2],size,sz,cnt;
	//ch表示左右儿子的编号
	//size表示以此节点为根的子树大小
	//sz表示此节点表示的数值大小
	//cnt表示sz出现的次数，也就是此节点的大小
}tree[2000000];
```

SBT 是由我国的陈启峰同学发明的一种平衡树算法。

SBT 的主要性质是：
- $x.left.size\ge\max(x.right.left.size,x.right.right.size)$
- $x.right.size\ge\max(x.left.left.size,x.left.right.size)$

简单来说，兄弟的子树大小一定要大于自己的任意一个儿子。

所以为了维护这条性质，我们要引入一个 SBT 特有的函数， $\operatorname{maintain}$ 。

其中要用到旋转操作 $\operatorname{rotate}$ ，这里的做法与 splay ， treap 等算法的旋转操作相似，在这里就只放出代码了，我将左旋与右旋放在了同一个函数里。
```cpp
int update(int x)
{
	tree[x].size=tree[tree[x].ch[0]].size+tree[tree[x].ch[1]].size+tree[x].cnt;
	return 0;
}
int rotate(int &x,int gx)//gx表示旋转的方向
{
	int son=tree[x].ch[gx^1];
	tree[x].ch[gx^1]=tree[son].ch[gx];
	tree[son].ch[gx]=x;
	tree[son].size=tree[x].size;
	update(x);
	x=son;
	return 0;
}
```
接下来，树在插入节点之后不符合 SBT 的性质有四种情况，其中左边与右边情况对称，在这里我们只讨论左子树较小的情况。

1. $x.left.size\ge x.right.right.size$

此时我们的操作是，直接将 $x$ 节点左旋，即 $\operatorname{rotate}(x,0)$ ，此时我们会发现，现在的根节点的左子树失衡，于是进行  $\operatorname{maintain}(x.left)  ,\operatorname{maintain}(x)$ 即可。

2. $x.left.size\ge x.right.left.size$

这个操作比上一种情况复杂一些，我们要先将 $x$ 节点的右儿子右旋，再将 $x$ 节点左旋，此时会发现现在的根节点的左右节点均不平衡，所以要对根的左右儿子以及根本身再次进行 $\operatorname{maintain}$ 操作。

3. 与第一种情况对称。

4. 与第二种情况对称。

然而，由于我们加入了 $cnt$ 数组，如果在旋转之后我们再次对根节点再次操作，就有可能发生死循环，所以我选择，将下面两行的 $\operatorname{maintain}$ 操作删去。~~所以说这是一种很懒的数据结构。~~

于是我们就可以写出代码，如下。
```cpp
int matain(int &x,int gx)//gx表示哪个子树的size增加了
{
	if(gx)
	{
		if(tree[tree[x].ch[0]].size<tree[tree[tree[x].ch[1]].ch[1]].size)//情况1
			rotate(x,0);
		else if(tree[tree[x].ch[0]].size<tree[tree[tree[x].ch[1]].ch[0]].size)//情况2
		{
			rotate(tree[x].ch[1],1);
			rotate(x,0);
		}
		else
		return 0;
	}
	else
	{
		if(tree[tree[x].ch[1]].size<tree[tree[tree[x].ch[0]].ch[0]].size)//情况3
			rotate(x,1);
		else if(tree[tree[x].ch[1]].size<tree[tree[tree[x].ch[0]].ch[1]].size)//情况4
		{
			rotate(tree[x].ch[0],0);
			rotate(x,1);
		}
		else
		return 0;
	}
	matain(tree[x].ch[1],1);
	matain(tree[x].ch[0],0);
	//matain(x,1);原版SBT有的操作，我将其删去
	//matain(x,0);这样保证了正确性，但也牺牲了一点点常数
	return 0;
}
```

其他的问题就是根据二叉搜索树的性质，完成题目中要求的六个操作了。
1. 插入。

较简单，具体见注释。
```cpp
int add(int &x,int sz)
{
	if(x==0)//如果没有此数值的节点，就新建一个节点
	{
		x=++step;
		tree[x].cnt=1;
		tree[x].size=1;
		tree[x].sz=sz;
		return 0;
	}
	tree[x].size++;
	if(tree[x].sz==sz)//正是此数值的节点
	{
		tree[x].cnt++;
		return 0;//由于左右子树都没有变化，所以不用maintain
	}
	else if(tree[x].sz<sz)
		add(tree[x].ch[1],sz);
	else
		add(tree[x].ch[0],sz);
	matain(x,tree[x].sz<sz);//第二个参数表示哪棵子树size增大
	return 0;
}
```
2. 删除。

这一部分我重点说一下，我这个函数的功能是，从平衡树中删除 $sl$  个 $sz$ 。

在删除的时候分为三种情况：第一种，节点的 $cnt$ 数量足够多，那么直接减去。

第二种，节点要被直接删除，如果此节点没有左子树或没有右子树，那么很简单，将有的那一颗嫁接到要删除的位置即可。

最后第三种，没有特殊情况，那么先寻找自己的直接后驱，然后直接将后驱所在节点替换当前节点，然后删除此后驱节点。在这里要注意，由于后驱节点将当前节点完全替换，那么就要将下方的后驱节点删除彻底，而且由于直接后驱可以知道，该后驱节点没有左子树，所以会在那里执行第二种情况，也就是说， $\operatorname{del}$ 函数在一次删除中，删除不同数值的次数至多只有两次。

由于在删除之后，树的最大深度不会增大，所以不需要进行 $\operatorname{maintain}$ 。~~真的是一种很懒的算法了。~~
```cpp
int del(int &x,int sz,int sl)//
{
	tree[x].size-=sl;//路径上的节点子树大小减小sl
	if(tree[x].sz==sz)
	{
		if(tree[x].cnt>sl)
			tree[x].cnt-=sl;//第一种情况
		else if((!tree[x].ch[0])||(!tree[x].ch[1]))
			x=tree[x].ch[0]+tree[x].ch[1];//第二种情况
		else
		{
			int temp=tree[x].ch[1];
			while(tree[temp].ch[0])
				temp=tree[temp].ch[0];//找直接后驱
			tree[x].sz=tree[temp].sz;
			tree[x].cnt=tree[temp].cnt;//替换
			del(tree[x].ch[1],tree[temp].sz,tree[temp].cnt);
        		//将后驱彻底删除
		}
		return 0;
	}
	if(tree[x].sz<sz)
		del(tree[x].ch[1],sz,sl);
	else
		del(tree[x].ch[0],sz,sl);
	return 0;
}

```
3.求排名。

从根向下遍历，往右子树走则加上左子树的大小以及当前节点的大小，在这里由于树的结构不会变化，参数就没有用引用，同时也没有使用递归。
```cpp
int rank(int sz)
{
	int x=root,res=0;
	while(x)
	{
		if(tree[x].sz==sz)//如果数值相等，则不用遍历下去，直接返回即可
			return res+tree[tree[x].ch[0]].size+1;
		if(tree[x].sz<sz)//sz>tree[x].sz说明左子树中的点和此节点本身都小于sz
		{
			res+=tree[tree[x].ch[0]].size+tree[x].cnt;//于是res加上这些数量
			x=tree[x].ch[1];
		}
		else
			x=tree[x].ch[0];
	}
	return res+1;//如果不在树里，res储存的就是小于sz的数的数量
}
```
4.求排名对应的数。

可以视为 $\operatorname{rank}$ 的一种逆操作，具体看注释。
```cpp
int arrank(int wz)//这里直接用了这个wz表示在以x为根的子树上的排名
{
	int x=root;
	while(x)
	{
		if(tree[x].cnt+tree[tree[x].ch[0]].size<wz)//说明排名wz的节点在x的右子树上
		{
			wz-=tree[x].cnt+tree[tree[x].ch[0]].size;
			x=tree[x].ch[1];
            		//减去之后表示在右子树上的排名，同时把x变为右儿子
		}
		else if(tree[tree[x].ch[0]].size<wz)//表示不在左子树上，也就是说明结果就是当前节点
			return tree[x].sz;
		else//不在右子树不在根节点，那么就在左子树
			x=tree[x].ch[0];
	}
	return 0;
}
```
5.求前驱。

我们先设置一个虚拟的前驱 $maxx$ ，并赋值极小值，在遍历过程中，如果既是前驱，又大于 $maxx$ ，则更新。
```cpp
int qianqu(int sz)
{
	int x=root,maxx=-2147483647;
	while(x)
	{
		if(tree[x].sz<sz&&tree[x].sz>maxx)//如果满足条件就更新
			maxx=tree[x].sz;
		if(tree[x].sz<sz)
			x=tree[x].ch[1];
		else
			x=tree[x].ch[0];
	}
	return maxx;
}
```
6.求后驱。 

与求前驱操作没什么区别，看注释吧。
```cpp
int houqu(int sz)
{
	int x=root,minn=2147483647;//由于后驱要尽量小，所以取极大值
	while(x)
	{
		if(tree[x].sz>sz&&tree[x].sz<minn)//条件与上边刚好相反
			minn=tree[x].sz;
		if(tree[x].sz<=sz)
			x=tree[x].ch[1];
		else
			x=tree[x].ch[0];
	}
	return minn;
}
```
到这里SBT的六种操作全部完成，下面放出完整代码。

不要忘了强制在线的 $last$ 哦。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>

using namespace std;

int n,m,root,step,last=0,ans=0;
int Read()
{
	int sum=0,sig=1;
	char ch=getchar();
	while(!isdigit(ch)&&ch!='-')
		ch=getchar();	
	if(ch=='-')
	{
		sig=-1;
		ch=getchar();
	}
	while(isdigit(ch))
	{
		sum=sum*10+ch-'0';
		ch=getchar();
	}
	return sum*sig;
}

struct node
{
	int ch[2],size,sz,cnt;
	//ch表示左右儿子的编号
	//size表示以此节点为根的子树大小
	//sz表示此节点表示的数值大小
	//cnt表示sz出现的次数，也就是此节点的大小
}tree[2000000];

int update(int x)
{
	tree[x].size=tree[tree[x].ch[0]].size+tree[tree[x].ch[1]].size+tree[x].cnt;
	return 0;
}
int rotate(int &x,int gx)//gx表示旋转的方向
{
	int son=tree[x].ch[gx^1];
	tree[x].ch[gx^1]=tree[son].ch[gx];
	tree[son].ch[gx]=x;
	tree[son].size=tree[x].size;
	update(x);
	x=son;
	return 0;
}
int matain(int &x,int gx)//gx表示哪个子树的size增加了
{
	if(gx)
	{
		if(tree[tree[x].ch[0]].size<tree[tree[tree[x].ch[1]].ch[1]].size)//情况1
			rotate(x,0);
		else if(tree[tree[x].ch[0]].size<tree[tree[tree[x].ch[1]].ch[0]].size)//情况2
		{
			rotate(tree[x].ch[1],1);
			rotate(x,0);
		}
		else
		return 0;
	}
	else
	{
		if(tree[tree[x].ch[1]].size<tree[tree[tree[x].ch[0]].ch[0]].size)//情况3
			rotate(x,1);
		else if(tree[tree[x].ch[1]].size<tree[tree[tree[x].ch[0]].ch[1]].size)//情况4
		{
			rotate(tree[x].ch[0],0);
			rotate(x,1);
		}
		else
		return 0;
	}
	matain(tree[x].ch[1],1);
	matain(tree[x].ch[0],0);
	//matain(x,1);原版SBT有的操作，我将其删去
	//matain(x,0);这样保证了正确性，但也牺牲了一点点常数
	return 0;
}
int add(int &x,int sz)
{
	if(x==0)//如果没有此数值的节点，就新建一个节点
	{
		x=++step;
		tree[x].cnt=1;
		tree[x].size=1;
		tree[x].sz=sz;
		return 0;
	}
	tree[x].size++;
	if(tree[x].sz==sz)//正是此数值的节点
	{
		tree[x].cnt++;
		return 0;//由于左右子树都没有变化，所以不用maintain
	}
	else if(tree[x].sz<sz)
		add(tree[x].ch[1],sz);
	else
		add(tree[x].ch[0],sz);
	matain(x,tree[x].sz<sz);//第二个参数表示哪棵子树size增大
	return 0;
}
int del(int &x,int sz,int sl)//
{
	tree[x].size-=sl;//路径上的节点子树大小减小sl
	if(tree[x].sz==sz)
	{
		if(tree[x].cnt>sl)
			tree[x].cnt-=sl;//第一种情况
		else if((!tree[x].ch[0])||(!tree[x].ch[1]))
			x=tree[x].ch[0]+tree[x].ch[1];//第二种情况
		else
		{
			int temp=tree[x].ch[1];
			while(tree[temp].ch[0])
				temp=tree[temp].ch[0];//找直接后驱
			tree[x].sz=tree[temp].sz;
			tree[x].cnt=tree[temp].cnt;//替换
			del(tree[x].ch[1],tree[temp].sz,tree[temp].cnt);
        		//将后驱彻底删除
		}
		return 0;
	}
	if(tree[x].sz<sz)
		del(tree[x].ch[1],sz,sl);
	else
		del(tree[x].ch[0],sz,sl);
	return 0;
}

int rank(int sz)
{
	int x=root,res=0;
	while(x)
	{
		if(tree[x].sz==sz)//如果数值相等，则不用遍历下去，直接返回即可
			return res+tree[tree[x].ch[0]].size+1;
		if(tree[x].sz<sz)//sz>tree[x].sz说明左子树中的点和此节点本身都小于sz
		{
			res+=tree[tree[x].ch[0]].size+tree[x].cnt;//于是res加上这些数量
			x=tree[x].ch[1];
		}
		else
			x=tree[x].ch[0];
	}
	return res+1;//如果不在树里，res储存的就是小于sz的数的数量
}
int arrank(int wz)//这里直接用了这个wz表示在以x为根的子树上的排名
{
	int x=root;
	while(x)
	{
		if(tree[x].cnt+tree[tree[x].ch[0]].size<wz)//说明排名wz的节点在x的右子树上
		{
			wz-=tree[x].cnt+tree[tree[x].ch[0]].size;
			x=tree[x].ch[1];
            		//减去之后表示在右子树上的排名，同时把x变为右儿子
		}
		else if(tree[tree[x].ch[0]].size<wz)//表示不在左子树上，也就是说明结果就是当前节点
			return tree[x].sz;
		else//不在右子树不在根节点，那么就在左子树
			x=tree[x].ch[0];
	}
	return 0;
}
int qianqu(int sz)
{
	int x=root,maxx=-2147483647;
	while(x)
	{
		if(tree[x].sz<sz&&tree[x].sz>maxx)//如果满足条件就更新
			maxx=tree[x].sz;
		if(tree[x].sz<sz)
			x=tree[x].ch[1];
		else
			x=tree[x].ch[0];
	}
	return maxx;
}
int houqu(int sz)
{
	int x=root,minn=2147483647;//由于后驱要尽量小，所以取极大值
	while(x)
	{
		if(tree[x].sz>sz&&tree[x].sz<minn)//条件与上边刚好相反
			minn=tree[x].sz;
		if(tree[x].sz<=sz)
			x=tree[x].ch[1];
		else
			x=tree[x].ch[0];
	}
	return minn;
}
int main()
{
	n=Read();
	m=Read();
	for(int p,i=1;i<=n;i++)
	{
		p=Read();
		add(root,p);
	}
	for(int k,temp,i=1;i<=m;i++)
	{
		temp=Read();
		k=Read()^last;
		if(temp==1)
			add(root,k);
		else if(temp==2)
			del(root,k,1);
		else if(temp==3)
			last=rank(k);
		else if(temp==4)
			last=arrank(k);
		else if(temp==5)
			last=qianqu(k);
		else
			last=houqu(k);
		if(temp>=3)
		ans^=last;
	}
	cout<<ans;
	return 0;
}
```
跑的很快，在这道题目里不到五秒。

至此，本蒟蒻的第一篇题解结束了，希望有所帮助，同时欢迎提出问题和建议。




---

## 作者：Starlight237 (赞：5)

upd：缩进挂掉了，所以更新一下！

指针版WBLT。

每个操作的思路同之前数组版的题解，此处不再赘述，仅叙述几个指针版需要注意的：

1.关于空指针

- 众所周知，有一种十分烦人的指针，叫做空指针（NULL）。在树形数据结构中，我们常常会不可避免地访问到空指针（例如一个节点只有右儿子，我们却访问了它的左儿子）。通常的方式是凡是访问了指针，都判断一下。然而这样效率十分低下，大量分支的存在使得代码冗长，常数变大，不易调试，可读性降低等问题。  
- 我们可以考虑新开一个节点```Node *null;```来表示空指针。这样，即使我们遇到了一个为空的指针rt，并且试图访问```rt->siz```（应当为0），也不用担心会出现RE or WA。
- 写代码时一定要注意节点的初始化，切不可有可能被访问到的指针为空却没有被赋为null的情况。
- null节点指向的对象不应当在任何时候被修改。

2.数组要开大，因为有null这样的很多多余指针。

3.关于码风

- 为了卡常数（而不是压行）略有些毒瘤。  
三目就不说了，然后```a&&(b,0)```这样的东西表示```if(a)b;```而```a||(b,0)```表示```if(!a)b;```这里用了短路运算的特点。


## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define reg register
#define IOSIZE 1000000
extern "C"{
namespace io{
	static char in[IOSIZE],*p=in,*pp=in,out[IOSIZE],*q=out,ch[20],*t=ch;
	inline char gc(){return p==pp&&(pp=(p=in)+fread(in,1,IOSIZE,stdin),p==pp)?EOF:*p++;}
	inline int read(){
		reg int x=0;reg char ch,f=0;
		while(!isdigit(ch=gc()))f|=ch=='-';
		while(isdigit(ch))x=(x<<1)+(x<<3)+(ch^48),ch=gc();
		return f?-x:x;
	}
	inline void write(int x){
		!x&&(*q++=48),x<0&&(*q++='-',x=-x);
		while(x)*t++=x%10+48,x/=10;
		while(t!=ch)*q++=*--t;
		*q++='\n';
	}
	inline void flush(){fwrite(out,1,q-out,stdout);}
}}
#define rd io::read
#define wt io::write
const int rat=4,maxn=2000001;
static int n,m,tot;
static struct Node{
	int siz,val;
	Node *ls,*rs;
	Node(){}
	Node(int siz,int val,Node *ls,Node *rs):siz(siz),val(val),ls(ls),rs(rs){}
}*null,*root,tr[maxn<<1],*pl[maxn<<1];
#define newNode(a,b,c,d) (&(*pl[tot++]=Node(a,b,c,d)))
inline void pushup(Node *cur){
	cur->ls->siz&&(cur->siz=cur->ls->siz+cur->rs->siz,cur->val=cur->rs->val);
}
inline Node *merge(Node *a,Node *b){return newNode(a->siz+b->siz,b->val,a,b);}
inline void maintain(Node *cur){
	cur->ls->siz>cur->rs->siz*rat&&(
		cur->rs=merge(cur->ls->rs,cur->rs),pl[--tot]=cur->ls,cur->ls=cur->ls->ls
	),
	cur->rs->siz>cur->ls->siz*rat&&(
		cur->ls=merge(cur->ls,cur->rs->ls),pl[--tot]=cur->rs,cur->rs=cur->rs->rs
	);
}
void ins(Node *cur,int val){
	cur->siz==1?
		cur->ls=newNode(1,min(val,cur->val),null,null),
		cur->rs=newNode(1,max(val,cur->val),null,null),0
	:(ins(val>cur->ls->val?cur->rs:cur->ls,val),0);
	pushup(cur),maintain(cur);
}
void del(Node *cur,int val){
	cur->ls->siz==1&&cur->ls->val==val?
		pl[--tot]=cur->ls,pl[--tot]=cur->rs,*cur=*cur->rs,0
	:cur->rs->siz==1&&cur->rs->val==val?
		pl[--tot]=cur->rs,pl[--tot]=cur->ls,*cur=*cur->ls,0
	:(del(val>cur->ls->val?cur->rs:cur->ls,val),0);
	pushup(cur),maintain(cur);
}
int Find(Node *cur,int k){
	return cur->siz==1?cur->val:
	k>cur->ls->siz?Find(cur->rs,k-cur->ls->siz):Find(cur->ls,k);
}
int Rank(Node *cur,int val){
	return cur->siz==1?1:
	val>cur->ls->val?cur->ls->siz+Rank(cur->rs,val):Rank(cur->ls,val);
}
inline int Pre(int val){return Find(root,Rank(root,val)-1);}
inline int Nxt(int val){return Find(root,Rank(root,val+1));}
int main(){
	freopen("1.in","r",stdin);
	n=rd(),m=rd();
	reg int lst=0,ans=0;
	null=new Node(0,0,NULL,NULL);
	root=new Node(1,2147483647,null,null);
	for(reg int i=0;i<(maxn<<1);++i)pl[i]=&tr[i];
	for(reg int i=1,x;i<=n;++i)x=rd(),ins(root,x);
	for(reg int x,y,i=0;i<m;++i){
		y=rd(),x=rd()^lst;
		switch(y){
			case 1:ins(root,x);break;
			case 2:del(root,x);break;
			case 3:ans^=(lst=Rank(root,x));break;
			case 4:ans^=(lst=Find(root,x));break;
			case 5:ans^=(lst=Pre(x));break;
			case 6:ans^=(lst=Nxt(x));break;
		}
	}wt(ans);
	io::flush();
	return 0;
}
```

---

## 作者：Anita_Hailey (赞：3)

# AVL

这是一篇AVL树(比题解区的那几篇快不知道哪去了..搞不懂他
们的avl树为啥这么慢，尤其是拿数组的那位...)（无意冒犯

这篇AVL树甚至和题解区的另一棵RBT相当..测速度时的心情是爆炸的 qwq

avl相比于 splay 算是很古老的数据结构吧。但是效率不错，毕竟 RBT 就是 avl 的变种

avl树是我唯二会的平衡树，剩下那个是 ScapeGoat....作为一个从来不写 treap 的人（点背）

还是要说一下,,写代码，就要常数小...写个avl能跑到八秒.那还不如 fhq_treap 呢...

采用哨兵结点来防止奇怪的RE,,我已经因为这个RE无数遍了..

细节都已经加了注释

献上代码写的特别用心..

希望大家的代码也可以


```cpp
#include <bits/stdc++.h>

using namespace std;

#define gc() getchar()
#define pc(i) putchar(i)

template <typename KYN>
inline KYN read()
{
	KYN x = 0;
	char ch = gc();
	bool f = 0;
	while(!isdigit(ch))
	{
		f = (ch == '-');
		ch = gc();
	}
	while(isdigit(ch))
	{
		x = x * 10 + (ch - '0');
		ch = gc();
	}
	return f ? -x : x;
}

template <typename KYN>
void put(KYN x)
{
	if(x < 0)
	{
		x = -x;
		pc('-');
	}
	if(x < 10) {
		pc(x + 48);
		return;
	}
	put(x / 10);
	pc(x % 10 + 48);
	return ;
}

#define vit std::vector <int>:: iterator 
#define vi std::vector <int>
#define lbd(i, j, k) lower_bound(i, j, k)
#define pii std::pair <int, int>
#define mkp(i, j) std::make_pair(i, j)
#define lowbit(i) (i & -i)
#define ispow(i) (i == lowbit(i))
#define rdi() read <int> ()
#define rdl() read <long long> ()
#define pti(i) put <int> (i), putchar(' ')
#define ptl(i) put <long long> (i), putchar(' ')

typedef long long ll;
typedef double db;
typedef long double ldb;
typedef unsigned long long ull;
typedef unsigned int ui;

const int Maxn = 1e6  + 1e5 + 111;

namespace RSX_love_KYN
{

// 不要问我为啥叫这个namespace,qwq

const int MAXN = 1e6  + 1e5 + 111;

template <typename KYN>
class avlTree
{
	private:
	//结点声明
	// 其实写不写 private 完全看你心情
	struct avlNode;
	typedef avlNode *avl;
	struct avlNode
	{
		avl ls, rs;
		int size, height, num;
		KYN data;
		void update() 
		{
			this->size = this->ls->size + this->rs->size + this->num;
			this->height = max(this->ls->height , this->rs->height) + 1;
		}
	};
	// 不要抄代码哟...
	protected:
	// 大概是友元的意思
   avl rot, null, tot, deleted[MAXN];
	avlNode memory[MAXN];
	int deltop;
     	// 这里使用了内存池的操作，具体可以看 Marser 的 blog 他的ScapeGoat 跑的飞快
	inline avl init(KYN x)
	{
		avl tmp = deltop ? deleted[deltop--] : tot++;
		tmp->ls = tmp->rs = null;
		tmp->size = tmp->num = tmp->height = 1;
		tmp->data = x;
		return tmp;
	}
	//这是说新建一个结点出来
	
	inline avl Single_left(avl T)
	{
		avl a = T->ls;
		T->ls = a->rs;
		a->rs = T;
		T->update();
		a->update();
		return a;
	}
	// 左单旋
	inline avl Single_right(avl T)
	{
		avl a = T->rs;
		T->rs = a->ls;
		a->ls = T;
		T->update();
		a->update();
		return a;
	}
	// 右单旋
	inline avl double_left(avl T)
	{
		T->ls = Single_right(T->ls);
		return Single_left(T);
	}
	// 左双旋
	inline avl double_right(avl T)
	{
		T->rs = Single_left(T->rs);
		return Single_right(T);
	}
	// 右双旋，下面是添加操作
	avl insert(avl T, KYN x)
	{
		 // 已经到了 null 直接新建即可
		if(T == null) return init(x);
		if(x == T->data)
		{
        		//原先有这个点 
			++(T->num);
			T->update();
			return T;
		}
		if(x < T->data)
		{
    		    // 插到左子树
			T->ls = insert(T->ls, x);
			T->update();
     		       // 同时更新这个节点的size和height
			if(T->ls->height - T->rs->height == 2)
			{
            // 如果达到了不平衡
				if(x < T->ls->data) T = Single_left(T);// 这时时左单旋因为插到了左子树的左边
				else T = double_left(T);
			}
		}
		else
		{// 右边同理
			T->rs = insert(T->rs, x);
			T->update();
			if(T->rs->height - T->ls->height == 2)
			{
				if(T->rs->data < x) T = Single_right(T);
				else T = double_right(T);
			}
		}
		return T;
	}
	
	avl erase(avl T, KYN x)
	{
		if(T == null) return null;// 没有找到直接返回
		if(x < T->data)
		{// 在左子树里删除
			T->ls = erase(T->ls, x);
			T->update();
			if(T->rs->height - T->ls->height == 2)
			{//要是不平衡了
				if(T->rs->rs->height >= T->rs->ls->height) T = Single_right(T);
				else T = double_right(T);
			}
		}
		else if(T->data < x)
		{//删除右子树的
			T->rs = erase(T->rs, x);
			T->update();
			if(T->ls->height - T->rs->height == 2)
			{//要是不平衡了
				if(T->ls->ls->height >= T->ls->rs->height) T = Single_left(T);
				else T = double_left(T);
			}
		}
		else
		{//假如这个点就是
			if(T->num > 1)
			{//超过一个直接删
				--(T->num);
				T->update();
				return T;
			}
			if(T->ls != null && T->rs != null)
			{//左右都有字树，拿出右子树最小的
				avl p = T->rs;
				while(p->ls != null) p = p->ls;
				T->num = p->num;
				T->data = p->data, p->num = 1;
				T->rs = erase(T->rs, T->data);
				T->update();
				if(T->ls->height - T->rs->height == 2)
				{
					if(T->ls->ls->height >= T->ls->rs->height) T = Single_left(T);
					else T = double_left(T);
				}
			}
			else
			{//都没有直接删
				avl p = T;
				if(T->ls != null) T = T->ls;
				else if(T->rs != null) T = T->rs;
				else T = null;
				deleted[++deltop] = p;
			}
		}
		return T;
	}
	
	KYN get_rank(avl T, KYN x) 
	{//这个就没什么技术含量，其他的题解都有
	    // 但是我之前无限TLE的原因就是如果这个点比多有的结点都都大，那就返回 节点数 + 1，一定要返回
		int ans = 0;
		while(T != null)
		{
			if(T->data == x) { return ans + T->ls->size + 1; }
			else if(x < T->data) { T = T->ls; }
			else { ans += T->ls->size + T->num; T = T->rs; }
		}
		return ans + 1;
	}
	
	KYN get_data(avl T, int rank)
	{//同样
		while(T != null)
		{
			if(T->ls->size >= rank) T = T->ls;
			else if(T->ls->size + T->num >= rank) { return T->data; }
			else { rank -= T->num + T->ls->size; T = T->rs; }
		}
	}
	
	avl makeempty(avl x)
	{//清空一棵树
		if(x == null) return null;
		x->ls = makeempty(x->ls);
		x->rs = makeempty(x->rs);
		deleted[++deltop] = x;
		return null;
	}
	
	void output(avl x)
	{// debug用的
		if(x == null) return;
		output(x->ls);
		put <KYN> (x->data);
		putchar(' ');
		output(x->rs);
	}
	
	avl find(avl T, KYN x)
	{// 显得没事干写的，就是为了调试TLE用的
		while(T != null) {
			if(T->data == x) return T;
			else if(T->data > x) { T = T->ls; }
			else { T = T->rs; }
		}
		return null;
	}
	
	public:	
	KYN prv(KYN x)
	{
		KYN ans = KYN(-1 << 30);
		avl tmp = rot;
		while(tmp != null)
		{
			if(tmp->data == x)
			{
				if(tmp->ls != null)
				{
					tmp = tmp->ls;
					while(tmp->rs != null) tmp = tmp->rs;
					ans = tmp -> data;
				}
				break;
			}
			if(tmp->data < x && ans < tmp->data) ans = tmp->data;
			tmp = tmp->data < x ? tmp->rs : tmp->ls;
		}
		return ans;
	}
	
	KYN next(KYN x) {
		KYN ans = KYN(1 << 30);
		avl tmp = rot;
		while(tmp != null)
		{
			if(tmp->data == x)
			{
				if(tmp->rs != null)
				{
					tmp = tmp->rs;
					while(tmp->ls != null) tmp = tmp->ls;
					ans = tmp->data;
				}
				break;
			}
			if(x < tmp->data && tmp->data < ans) ans = tmp->data;
			tmp = tmp->data < x ? tmp->rs : tmp->ls;
		}
		return ans;
	}// 前驱和后继不多说了
	
	avlTree()
	{
		deltop = 0;
		null = new avlNode;
		null->ls = null->rs = null;
		null->size = null->height = null->num = 0;
		rot = null;
		tot = memory;//构造函数
	}
	
	inline void insert(KYN x) { rot = insert(rot, x); return ; }
	
	inline void erase(KYN x) { rot = erase(rot, x); }
	
	inline int get_rank(KYN x) { return get_rank(rot, x); }
	
	inline KYN get_data(int x) { return get_data(rot, x); }
	
	void clear() { rot = makeempty(rot); }
	
	bool find(KYN x) { return find(rot, x) != null; }
	
	void output() { output(rot); }
	
	KYN operator[] (int k) { return get_data(k); }
	
	int size() { return rot->size; }
};

}

using namespace RSX_love_KYN;

int n, opt, x, m, last = 0, tmp, ans;

avlTree <int> tree;

int main() {
#ifdef _DEBUG
	freopen("P6136_2.in", "r", stdin);
#endif
	n = rdi(); m = rdi();
	while(n--) tree.insert(rdi());
	while(m--) {
		opt = rdi(); x = rdi();
		x ^= last;
		switch (opt)
		{
			case 1: tree.insert(x); break;
			case 2: tree.erase(x); break;
			case 3: last = tree.get_rank(x); ans ^= last; break;
			case 4: last = tree[x]; ans ^= last; break;
			case 5: last = tree.prv(x); ans ^= last; break;
			case 6: last = tree.next(x); ans ^= last; break;
		}
	}
	pti(ans);
	return 0;
}
```

彩蛋：没写模板类之前比写模板类快..


---


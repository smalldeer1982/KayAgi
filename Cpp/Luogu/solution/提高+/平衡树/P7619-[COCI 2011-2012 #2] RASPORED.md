# [COCI 2011/2012 #2] RASPORED

## 题目描述

Mirko 的比萨店是城里最好的，镇上所有的居民每天午餐都吃比萨饼。而且 Mirko 的送货服务很快，送货时间可以忽略不计。但是 Mirko 只有一个小烤箱，一次只能烤一个比萨饼。

我们将城里的 $N$ 个居民从 $1$ 到 $N$ 编号，他们计划吃午餐的时间为 $L_i$，Mirko 需要为他们烘焙比萨的所需时间为 $T_i$。

如果一个居民在他计划吃午餐时间的前 $K$ 个时间单位收到了他的比萨饼，那么 Mirko 会得到 $K$ 元小费。相应地，如果一个居民在他计划吃午餐时间的后 $K$ 个时间单位才收到了他的比萨饼，那么 Mirko 必须向居民付款 $K$ 元。如果比萨饼准时送到，Mirko 不会得到小费，但是也不用付任何费用。

请你帮助 Mirko 安排一天的比萨烘焙顺序，使得他一天赚取的**总小费最大**。

**注意：**

1. 一天从时间单位 $0$ 开始，你可以认为这一天是无限长的。

2. 居民们有时会改变他们的 $T_i,L_i$。

## 说明/提示

#### 【样例 1 解释】

最优的比萨烘焙顺序为 $(1,3,2)$。这样的话，第 $1$ 个比萨在第 $2$ 个时间单位送达，第 $3$ 个比萨在第 $5$ 个时间单位送达，第 $2$ 个比萨在第 $10$ 个时间单位送达。

第 $1$ 个比萨由于早送了 $8$ 个时间单位，所以 Mirko 得到了 $8$ 元小费；第 $2$ 个比萨由于迟送了 $1$ 个时间单位，所以 Mirko 需要付 $1$ 元；第 $3$ 个比萨由于迟送了 $4$ 个时间单位，所以 Mirko 需要付 $1$ 元。因此最大的总小费为 $3$。

经过第 $1$ 次修改后，比萨烘焙顺序没有变，小费变成了 $5,0,-3$。

经过第 $2$ 次修改后，比萨烘焙顺序变为 $(1,2,3)$，小费变成了 $5,0,-11$。

#### 【数据范围】

对于 $50\%$ 的数据，$1 \le T_i,T_j \le 10^3$。

对于 $100\%$ 的数据，$1 \le N,C \le 2 \times 10^5$，$0 \le L_i,L_j \le 10^5$，$1 \le T_i,T_j \le 10^5$，$1 \le R_j \le N$。

#### 【说明】

本题分值按 COCI 原题设置，满分 $150$。

题目译自 **[COCI2011-2012](https://hsin.hr/coci/archive/2011_2012/) [CONTEST #2](https://hsin.hr/coci/archive/2011_2012/contest2_tasks.pdf)** ___T6 RASPORED___。

## 样例 #1

### 输入

```
3 2
10 2
6 5
4 3
1 6 1
3 0 10```

### 输出

```
3
2
-11```

## 样例 #2

### 输入

```
4 2
3 2
0 3
4 3
4 1
3 0 4
1 4 5```

### 输出

```
-8
-13
-18```

## 样例 #3

### 输入

```
6 7
17 5
26 4
5 5
12 4
8 1
18 2
3 31 3
4 11 5
4 19 3
5 23 2
6 15 1
5 19 1
3 10 4```

### 输出

```
27
59
56
69
78
81
82
58```

# 题解

## 作者：7KByte (赞：6)

评分虚高。

首先获得的小费只和考煎饼的顺序有关。我们令烤煎饼的顺序为排列 $p$，那么不难直接写出答案。

$$Ans=\sum\limits_{i=1}^n L_{p_i}-\sum\limits_{j=1}^{i}T_{p_j}$$ 

直接拆开算。

$$Ans=\sum\limits_{i=1}^n L_i-\sum\limits_{i=1}^{n}(n-i+1)T_{p_i}$$ 

前者可以 $\mathcal{O}(1)$ 维护。

对于后者，如果单次查询，我们直接对 $T$ 从小到达排序。

我们还需要支持单点修改，也就是要在线维护每个数比它小的有多少个数，和比它小的数之和。

值域很小，直接开两个树状数组维护即可。

```cpp
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define pre(i,a,b) for(int i=a;i>=b;i--)
#define N 200005
#define int long long
using namespace std;
int n,m,u[N],t[N],o[N],c[N][2],sum;
inline void add(int x,int y,int op){for(;x<=N-5;x+=x&-x)c[x][op]+=y;}
inline int ask(int x,int op){int sum=0;for(;x;x-=x&-x)sum+=c[x][op];return sum;}
signed main(){
	scanf("%lld%lld",&n,&m);
	rep(i,1,n)scanf("%lld%lld",&u[i],&t[i]),o[i]=t[i],sum+=u[i],add(t[i],1,0),add(t[i],t[i],1);
	sort(o+1,o+n+1);rep(i,1,n)sum-=o[i]*(n-i+1);
	printf("%lld\n",sum);
	while(m--){
		int x;scanf("%lld",&x);
		sum -= u[x];add(t[x],-1,0);add(t[x],-t[x],1);
		int cur = ask(t[x],0),now = ask(t[x],1);
		sum += t[x] * (n - cur) + now;
		scanf("%lld%lld",&u[x],&t[x]);
		sum += u[x];
		cur = ask(t[x],0),now=ask(t[x],1);
		sum -= t[x] * (n - cur) + now;
		add(t[x],1,0);add(t[x],t[x],1);
		printf("%lld\n",sum);
	}
	return 0;
}
```

---

## 作者：南阳刘子骥 (赞：4)


我们首先考虑没有修改的情况。

首先，我们假设已经给所有的居民分配好了一个烘焙披萨的方案，并用 $pos_i$ 代表第 $i$ 位居民的披萨是第 $pos_i$ 个烘焙的。

这样的话，我们设 $C_i$ 为从第 $i$ 名居民身上获取的小费数额（如果为负数则表示需要向该位居民支付的数额的相反数），那么就会有如下的式子：

$$
C_i = L_i - \sum_{j=1}^{pos_i} T_j
$$

那么对于 Mirko 收获小费的总和 $\sum_{i=1}^n C_i$，我们可以推一下式子：

$$
\begin{aligned}
\sum_{i=1}^n C_i &= \sum_{i=1}^n (L_i - \sum_{j=1}^{pos_i} T_j) \\
&= \sum_{i=1}^n L_i - \sum_{i=1}^n \sum_{j=1}^{pos_i} T_j \\
&= \sum_{i=1}^n L_i - \sum_{i=1}^n T_i \times (n- pos_i + 1)
\end{aligned}
$$

最后一步是这样推出来的：

对于 $T_i$ 来说，它会在计算所有 $pos_j \geq pos_i$ 的 $j$ 的时候被计算到，所以总共就是 $\sum_{j=pos_i}^n T_i$，即 $T_i \times (n-pos_i + 1)$。

----

然后看带修改的。

我们看刚才推出来的式子，可以看出我们能够对于 $L$ 与 $T$ 分开考虑，而事实上我们也就是这样做的。

我们对于一开始没有被修改时的数据计算出一个 $suml = \sum_{i=1}^n L_i$，然后再计算出一个 $sumt = \sum_{i=1}^n T_i \times (n- pos_i + 1)$。  
我们最终输出的数值就是 $suml-sumt$。

假设我们有了一个新的修改，将 $(L_x,T_x)$ 修改为 $(L_y,T_y)$。

对于 $suml$，其只需要变为 $suml-L_x+L_y$ 即可。

对于 $sumt$，我们可以看成首先从数列里面删除了一个 $T_x$，然后再插入了一个 $T_y$；其中 $T_x$ 删除前的位置是 $pos_x$，$T_y$ 删除后的位置是 $pos_y$。

我们可以将删除和插入分开讨论，也可以只讨论改变位置的元素。

如果分开讨论删除和插入的话，我们的分析过程是这个样子的：

1. 对于 $\forall T_i < T_x$，我们的 $pos_i$ 不会变，但是 $n$ 会因删除而减小 $1$；而对于 $\forall T_i \geq T_x$，我们的 $pos_i$ 和 $n$ 都会减小 $1$ 而最终抵消；对于 $T_x$，我们需要减去它的贡献。

所以我们的 $sumt$ 在删除 $T_x$ 之后会变成这个样子：
$$
sumt \to sumt - T_x \times (n - pos_x + 1) - \sum_{T_i<T_x} T_i
$$

2. 对于 $\forall T_i < T_x$，我们的 $pos_i$ 不会变，但是 $n$ 会因插入而增大 $1$；而对于 $\forall T_i \geq T_x$，我们的 $pos_i$ 和 $n$ 都会增大 $1$ 而最终抵消；对于 $T_y$，我们需要加上它的贡献。

所以我们的 $sumt$ 在插入 $T_y$ 之后会变成这个样子：
$$
sumt \to sumt + T_x \times (n - pos_y + 1) + \sum_{T_i<T_x} T_i
$$

如果只讨论改变位置的元素的话，我们的分析过程是这个样子的：

1. 如果 $T_x < T_y$，那么对于 $\{T_i | pos_i \in (pos_x,pos_y)\}$，其 $pos_i$ 会减少 $1$，从而导致 $sumt$ 减少 $\sum_{pos_i \in (pos_x,pos_y)} T_i$。

1. 如果 $T_x > T_y$，那么对于 $\{T_i | pos_i \in (pos_y,pos_x)\}$，其 $pos_i$ 会增加 $1$，从而导致 $sumt$ 增加 $\sum_{pos_i \in (pos_x,pos_y)} T_i$。

总的来看，我们的变化量可以看做 $\sum_{T_i<T_x} T_i - \sum_{T_i<T_x} T_i$。

再加上 $T_y$ 的贡献，减去$T_x$ 的贡献，我们推出的式子跟上面的是一样的。

----

于是我们就需要一种数据结构，支持

1. 插入和删除元素
2. 查询小于一个元素的数字个数
3. 查询小于一个元素的数字之和

树状数组、权值线段树和平衡树均可。

我这里使用的是替罪羊树。

对于不知道替罪羊树的人，我在这里安利一下[我的博客](https://kaiserwilheim.github.io/OI/scapegoat-tree/)，同时也给出[OI-Wiki](https://oi-wiki.org/ds/sgt/)关于替罪羊树的讲解。

替罪羊树虽然比较慢，但是所有的操作时间复杂度均摊之后都是 $O(\log n
)$ 级别的。

这里粘一下代码：

``` cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N = 200010;
ll n, m;
double alpha = 0.75;
struct Scapegoat
{
	int ls, rs;
	ll w, wn;
	int s, sz, sd;
	ll sum;
}tr[N];
int cnt, rt;
void calc(int p)
{
	tr[p].s = tr[tr[p].ls].s + tr[tr[p].rs].s + 1;
	tr[p].sz = tr[tr[p].ls].sz + tr[tr[p].rs].sz + tr[p].wn;
	tr[p].sd = tr[tr[p].ls].sd + tr[tr[p].rs].sd + (tr[p].wn != 0);
	tr[p].sum = tr[tr[p].ls].sum + tr[tr[p].rs].sum + tr[p].wn * tr[p].w;
}
bool canrbu(int p)
{
	return tr[p].wn && (alpha * tr[p].s <= ( double )max(tr[tr[p].ls].s, tr[tr[p].rs].s) || ( double )tr[p].sd <= alpha * tr[p].s);
}//can rebuild
int ldr[N];
void rbuunf(int &ldc, int p)
{
	if(!p)return;
	rbuunf(ldc, tr[p].ls);
	if(tr[p].wn)ldr[ldc++] = p;
	rbuunf(ldc, tr[p].rs);
}//rebuild-unfold
int rbubld(int l, int r)
{
	if(l >= r)return 0;
	int mid = (l + r) >> 1;
	tr[ldr[mid]].ls = rbubld(l, mid);
	tr[ldr[mid]].rs = rbubld(mid + 1, r);
	calc(ldr[mid]);
	return ldr[mid];
}//rebuild-build
void rbuild(int &p)
{
	int ldc = 0;
	rbuunf(ldc, p);
	p = rbubld(0, ldc);
}//rebuild
void insert(int &p, ll k)
{
	if(!p)
	{
		p = ++cnt;
		if(!rt)rt = 1;
		tr[p].w = k;
		tr[p].ls = tr[p].rs = 0;
		tr[p].wn = tr[p].s = tr[p].sz = tr[p].sd = 1;
		tr[p].sum = k;
	}
	else
	{
		if(tr[p].w == k)tr[p].wn++;
		else if(tr[p].w < k)insert(tr[p].rs, k);
		else insert(tr[p].ls, k);
		calc(p);
		if(canrbu(p))rbuild(p);
	}
}
void loschn(int &p, ll k)
{
	if(!p)return;
	if(tr[p].w == k)
	{
		if(tr[p].wn)tr[p].wn--;
	}
	else
	{
		if(tr[p].w < k)loschn(tr[p].rs, k);
		else loschn(tr[p].ls, k);
	}
	calc(p);
	if(canrbu(p))rbuild(p);
}//löschen，delete是关键字就不用了
ll uprgtr(int p, ll k)
{
	if(!p)
		return 0;
	else if(tr[p].w == k && tr[p].wn)
		return tr[tr[p].ls].sz;
	else if(tr[p].w < k)
		return tr[tr[p].ls].sz + tr[p].wn + uprgtr(tr[p].rs, k);
	else
		return uprgtr(tr[p].ls, k);
}//相当于是使用greater<>函数排序之后的upper_bound
//输出的结果是小于某个元素的数的个数
ll uprsum(int p, ll k)
{
	if(!p)
		return 0;
	else if(tr[p].w == k && tr[p].wn)
		return tr[tr[p].ls].sum;
	else if(tr[p].w < k)
		return tr[tr[p].ls].sum + tr[p].wn * tr[p].w + uprsum(tr[p].rs, k);
	else
		return uprsum(tr[p].ls, k);
}//跟上面差不多，输出的是小于某个元素的数之和
ll suml, sumt;
ll l[N], t[N];
int main()
{
	scanf("%lld%lld", &n, &m);
	int temp[N];
	for(int i = 1; i <= n; i++)
	{
		scanf("%lld%lld", &l[i], &t[i]);
		suml += l[i];
		insert(rt, t[i]);
		temp[i] = t[i];
	}
	sort(temp + 1, temp + 1 + n);
	for(int i = 1; i <= n; i++)
		sumt += (n - i + 1) * temp[i];
	printf("%lld\n", suml - sumt);
	while(m--)
	{
		int a;
		ll b, c;
		scanf("%d%lld%lld", &a, &b, &c);
		suml -= l[a] - b;
		l[a] = b;
		ll sum1 = uprsum(rt, t[a]), cnt1 = uprgtr(rt, t[a]);
		loschn(rt, t[a]);
		insert(rt, c);
		ll sum2 = uprsum(rt, c), cnt2 = uprgtr(rt, c);
		sumt += c * (n - cnt2) + sum2 - t[a] * (n - cnt1) - sum1;
		t[a] = c;
		printf("%lld\n", suml - sumt);
	}
    return 0;
}
```

感谢阅读~qwq

---

## 作者：xfrvq (赞：4)

[P7619 [COCI2011-2012#2] RASPORED](/problem/P7619)

## 闲话

抱着 **一棵 FHQ 走天下**的心态做这题，~~一交就 6 页，不愧是我~~

但是，**FHQ 真的几乎万能！！**

## 读题

对于能赚到的消费，可以看做 $\sum (lunch_i-time_i)$

化简：$\sum lunch_i-\sum time_i$

前者是固定的，而后者又可以理解为 $\sum(bake_i\times$ 他的餐第几个被做 $)$（ $time$ 是做到他共用了多久，$bake$ 是单独做他的要用多久）

不难看出，让时间少的先做，时间多的后做是最优的。

此时最优情况答案 $=\sum(bake_i\times rank(bake_i))$

## 修改操作

由于 $bake_i$ 会为答案作 $bake_i\times rank(bake_i)$ 的贡献，那么假如一个数 $a$ 从 $rank\,\rm x$ 变成 $rank\,\rm y$ 它做出的贡献变化应该是这样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/vdfs297y.png)

可以理解为容斥原理（大概

以 $x\lt y$ 举例。对于在 $x,y$ 外的，贡献都没有变。排名为 $x$ 的数贡献变成了 $y$，$x+1\sim y$ 全部 ${}-1$。

对于排名 $x$ 的贡献变成 $y$，会对答案造成 $(y-x)\times a$ 的影响。  
对于排名在 $x+1\sim y$ 区间内所有数的和 $sum$，会对答案造成 $sum$ 的影响。

## FHQ

对于情况 1，$(y-x)\times a$ 只需要用到平衡树的排名查询。  
对于情况 2，维护所有排名小于 $x$ 数的和 $-$ 所有排名小于 $y$ 的数和。

那么我们只需要给 FHQ 开一个 $sum$ 数组，记录子树和，查询小于 $a$ 的数的和，需要分裂出 $\lt a$ 与 $\ge a$，最后左边的子树和就是答案。

## 实现

由于修改的查询排名操作会出现删除元素后排名不对的情况，因此有较好的实现方案如下：

```
a=old_value
b=new_value
x=rank(a)
ans-=x*a
ans-=sum(x)
erase(x)
insert(y)
y=rank(b)
ans+=y*b
ans+=sum(y)
```

如果认真阅读上面的文字，不难写出代码

[**「代码不放，详见提交记录」**](https://www.luogu.com.cn/record/54905827)

~~喜获 50pts MLE！！！~~

## 优化

为什么会 MLE？其中很大的一个原因是：**删除次数太多，造成很大的空间浪费**。

优化这样的方法，就是在删除同时，**记录可用的空间**，申请空间时，**看看有没有可以回收的空间**。

```cpp
int use[maxn],top = 0,now;
int new_node(int x){
	if(top) now = use[top],--top;// 有可以回收的空间就用
	else now = ++cnt;// 否则新开空间
	siz[now] = 1;
	val[now] = x;
	sum[now] = 1LL * x;
	heap[now] = rand();
	return now;
}
void erase(int k){
	split(rt,k,x,z);
	split(x,k - 1,x,y);
	newy = merge(lc[y],rc[y]);
	use[++top] = y;// 加到可以回收的空间之中
	lc[y] = rc[y] = 0;// 清空很重要！！
	rt = merge(merge(x,newy),z);
}
```

[**「代码不放，详见提交记录」**](https://www.luogu.com.cn/record/56648550)

这样，~~你就获得了 TLE~~/cy

没开 O2 是 $\tt 50pts$，$\tt 1200ms$，开了就会快一些。

## 最后优化

常数以及算法本质的优化。

+ `fread` 快读加速
+ 去掉 `define int long long` 而在要开的地方开 `ll` 会快很多
+ FHQ $\mathcal O(n)$ 建树
+ O2 非常重要！！快很多！！

## AC Code

```cpp
#include<stdio.h>
#include<stdlib.h>
#include<algorithm>
typedef long long ll;
const int maxn = 2e5 + 1;
static char buf[100000],*p1=buf,*p2=buf;
#define getchar() p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++
inline int read(){// fread+快读
    register int x = 0,f = 1;
    register char c = getchar();
    for(;c < '0' || c > '9';c = getchar());
    for(;c >= '0' && c <= '9';c = getchar())
        x = x * 10 + (c ^ 48);
    return x;
}
int n,m;
ll ans1 = 0,ans2 = 0;// 在要开ll的地方才开
int use[maxn],top = 0,now;
int lunch[maxn],bake[maxn];
int tmp[maxn],j,b,l;
int lc[maxn],rc[maxn],val[maxn],heap[maxn],siz[maxn],cnt = 0,rt;
ll sum[maxn];
int new_node(int x){
	if(top) now = use[top],--top;
	else now = ++cnt;
	siz[now] = 1;
	val[now] = x;
	sum[now] = 1LL * x;
	heap[now] = rand();
	return now;
}
void push_up(int i){
	siz[i] = 1 + siz[lc[i]] + siz[rc[i]];
	sum[i] = 1LL * val[i] + sum[lc[i]] + sum[rc[i]];
}
int merge(int x,int y){
	if(!x || !y) return x + y;
	if(heap[x] < heap[y]){
		rc[x] = merge(rc[x],y);
		push_up(x);
		return x; 
	} else {
		lc[y] = merge(x,lc[y]);
		push_up(y);
		return y;
	}
}
void split(int i,int k,int& x,int& y){
	if(!i) x = y = 0;
	else {
		if(val[i] <= k){
			x = i;
			split(rc[i],k,rc[i],y);
		} else {
			y = i;
			split(lc[i],k,x,lc[i]);
		}
		push_up(i);
	}
}
int build(int l,int r){
	if(l == r) return new_node(tmp[l]);
	int mid = l + r >> 1; 
	return merge(build(l,mid),build(mid + 1,r));
}
int x,y,z,newy,ret;
ll res;
void insert(int k){
	split(rt,k,x,y);
	rt = merge(merge(x,new_node(k)),y);
}
void erase(int k){
	split(rt,k,x,z);
	split(x,k - 1,x,y);
	newy = merge(lc[y],rc[y]);
	use[++top] = y;
	lc[y] = rc[y] = 0;
	rt = merge(merge(x,newy),z);
}
int rank(int k){
	split(rt,k - 1,x,y);
	ret = siz[x] + 1;
	rt = merge(x,y);
	return n + 1 - ret;
}
ll summary(int k){
	split(rt,k - 1,x,y);
	res = sum[x];
	rt = merge(x,y);
	return res;
}
int main(){
	n = read(),m = read();
	for(int i = 1;i <= n;++i){
		lunch[i] = read(),bake[i] = read();
		ans1 += lunch[i];
		tmp[i] = bake[i];
	}
	std::sort(tmp + 1,tmp + n + 1);
	rt = build(1,n);
	for(int i = 1;i <= n;++i)
	    ans2 += 1LL * tmp[i] * (n - i + 1);
	printf("%lld\n",ans1 - ans2);
	while(m--){
		j = read(),l = read(),b = read();
		ans1 += l - lunch[j],lunch[j] = l;
		ans2 -= summary(bake[j]) + 1LL * rank(bake[j]) * bake[j];// 需要的地方强转ll
		erase(bake[j]);
		bake[j] = b;
		insert(bake[j]);
		ans2 += summary(bake[j]) + 1LL * rank(bake[j]) * bake[j];
		printf("%lld\n",ans1 - ans2);
	}
    return 0;
}
```
---

调了 20 天终于才 AC，完结撒花qwq~

---

## 作者：Kelvin2009 (赞：2)

这是一道权值线段树。

首先，有加有扣保证了减法的单向性：客服需求时减去当前准备时为所得小费（可能为负）。

可以发现，所有的当前准备时是一堆连续的前缀和。

要得小费总和，把正号挪一边，负号撇另一边。

可以发现，正号的一边很容易修改，负号的一边是二阶前缀和，还要求最小。

显然二阶前缀和相当于各数前权为从 $n$ 至 1 的总和，显然该数越大，其分配到的权值越小（逆序和最小）。

权值线段树维护，顺便处理二阶前缀和。

---

代码：

---


```cpp
#include<bits/stdc++.h>
using namespace std;
const int range=2e5+5;
int n,m;
long long k,T,L,sum;
int t[range],l[range];
struct SGT
{
	#define lson (pos<<1)
	#define mid ((l+r)>>1)
	#define rson (pos<<1|1)
	struct sgt_tree
	{
		int tim;
		long long sum,ans;
		sgt_tree()
		{
			tim=0;
			sum=ans=0ll;
		}
	}tree[range<<2];
	inline void push_up(int pos)
	{
		tree[pos].tim=tree[lson].tim+tree[rson].tim;
		tree[pos].ans=tree[lson].ans+tree[rson].tim*tree[lson].sum+tree[rson].ans;
		tree[pos].sum=tree[lson].sum+tree[rson].sum;
	}
	inline void change(int pos,int l,int r,int qpos,int op)
	{
		if(l==r)
		{
			tree[pos].tim+=op;
			if(op==1) tree[pos].ans+=tree[pos].sum+l;
			else tree[pos].ans-=tree[pos].sum;
			tree[pos].sum+=op*l;
			return ;
		}
		if(qpos<=mid) change(lson,l,mid,qpos,op);
		else change(rson,mid+1,r,qpos,op);
		//cout << pos << ":" << "[" << l << "," << r << "]" << tree[pos].sum  << " " << tree[pos].ans << endl;
		push_up(pos);
		return ;
	}
	#undef mid
	#undef lson
	#undef rson
}sgt;
int main()
{
	
	//freopen("cake.in","r",stdin);
	//freopen("cake.out","w",stdout);
	int ran=2e5;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d",&t[i],&l[i]);
		sgt.change(1,1,ran,l[i],1);
		sum+=t[i];
		//cout << endl << sgt.tree[1].ans << endl;
	}
	printf("%lld\n",sum-sgt.tree[1].ans);
	while(m--)
	{
		scanf("%d%d%d",&k,&T,&L);
		sum+=T-t[k];
		sgt.change(1,1,ran,l[k],-1);
		sgt.change(1,1,ran,L,1);
		t[k]=T,l[k]=L;
		printf("%lld\n",sum-sgt.tree[1].ans);
	}
	return 0;
}
```

---

## 作者：zzxLLL (赞：2)

给个线段树的。

---

发现答案只和做比萨的顺序有关。

如何安排这个顺序？容易猜出结论是按照 $T$ 从小到大。下面证明这个结论：

假设第 $i$ 个人的比萨排在第 $p_i$ 个做，第 $j$ 个比萨是第 $r_j$ 个人的（即 $p_{r_i} = r_{p_i} = i$），那么总的小费应该是 $\sum\limits_{i = 1}^n(L_i - \sum\limits_{j = 1}^{p_i} T_{r_j})$。

而 $p$ 又是 $1 \sim n$ 的排列，所以上式又等于 $\sum\limits_{i = 1}^n L_i - \sum\limits_{i = 1}^n (n - p_i+ 1)T_i$。

要使整个柿子的值最大就要使后半部分最小，根据排序不等式，当 $T_i$ 不断变大，$(n - p_i + 1)$ 不断变小（即 $p_i$ 不断变大）的时候取到最小值。所以 $p_i$ 应随着 $T$ 变大而变大，即 $T$ 按照从小到大做。

---

然后看修改。

前半部分是好维护的，看后半部分的维护。

按照上面的结论，$T$ 从小到大排序。然后修改了其中一个 $T_i$，假设原先 $T_i$ 的排名是 $x$，修改后排名变成了 $y$，那么排名 $x \sim y$ 对应比萨的顺序都要向左/向右移动一位（取决于 $T_i$ 变大/变小）。

也就是这段区间内的 $p_i$ 会加/减 $1$，对于整个柿子的值的影响，可以发现是这一段的 $T$ 之和。

然后再减去原来 $T_i$ 在位置 $x$ 的贡献，加上 $T_i '$ 在位置 $y$ 的贡献即可。

发现需要一个数据结构，支持区间和，查询一个数的排名。发现值域只有 $10^5$，考虑权值线段树，时间复杂度 $O(n \log V)$。

```cpp
#include<cstdio>
#include<algorithm>
const int M=2e5+10,V=2e5;

int n,c,t[M],l[M],ord_t[M];
long long ans;

struct node{
	int l,r,cnt;
	long long val;
}tr[M<<2];
#define lc(k) (k<<1)
#define rc(k) (k<<1|1)
void pushup(int k){
	tr[k].val=tr[lc(k)].val+tr[rc(k)].val;
	tr[k].cnt=tr[lc(k)].cnt+tr[rc(k)].cnt;
}
void build(int k,int l,int r){
	tr[k].l=l,tr[k].r=r;
	if(l==r) return;
	int mid=(l+r)>>1;
	build(lc(k),l,mid),build(rc(k),mid+1,r);
}
void modify(int k,int p,int v,int c){
	if(tr[k].l==tr[k].r){
		tr[k].val+=v,tr[k].cnt+=c;
		return;
	}
	int mid=(tr[k].l+tr[k].r)>>1;
	if(p<=mid) modify(lc(k),p,v,c);
	else modify(rc(k),p,v,c);
	pushup(k);
}
long long qval(int k,int l,int r){
	if(l<=tr[k].l&&tr[k].r<=r) return tr[k].val;
	int mid=(tr[k].l+tr[k].r)>>1;
	long long ret=0;
	if(l<=mid) ret+=qval(lc(k),l,r);
	if(r>mid)  ret+=qval(rc(k),l,r);
	return ret;
}
int qcnt(int k,int l,int r){
	if(l<=tr[k].l&&tr[k].r<=r) return tr[k].cnt;
	int mid=(tr[k].l+tr[k].r)>>1,ret=0;
	if(l<=mid) ret+=qcnt(lc(k),l,r);
	if(r>mid)  ret+=qcnt(rc(k),l,r);
	return ret;
}

int main(){
	scanf("%d%d",&n,&c);
	for(int i=1;i<=n;i++)
		scanf("%d%d",&l[i],&t[i]),ord_t[i]=t[i];
	std::sort(ord_t+1,ord_t+1+n);
	for(int i=1;i<=n;i++)
		ans+=1ll*l[i]-1ll*(n-i+1)*ord_t[i];
	printf("%lld\n",ans);
	
	build(1,1,V);
	for(int i=1;i<=n;i++) modify(1,t[i],t[i],1);
	
	for(int i=1,r,l0,t0;i<=c;i++){
		int tcnt; long long tval;
		scanf("%d%d%d",&r,&l0,&t0);
		modify(1,t[r],-t[r],-1);
		tcnt=qcnt(1,1,t[r]),tval=qval(1,1,t[r]);
		ans=ans-l[r]+1ll*(n-tcnt)*t[r]+tval;
		
		l[r]=l0,t[r]=t0;
		tcnt=qcnt(1,1,t[r]),tval=qval(1,1,t[r]);
		ans=ans+l[r]-1ll*(n-tcnt)*t[r]-tval;
		modify(1,t[r],t[r],1);
		
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：stripe_python (赞：1)

以此题解纪念 % 你赛考场上最接近 AC 的一道紫题。以下是考场思路。

注意到小费只与比萨顺序有关，记 $pre$ 为 $L$ 前缀和，则答案为

$$
\sum_{i=1}^{n} T_i-\sum_{i=1}^{n} pre_i
\\=\sum_{i=1}^{n} T_i-\sum_{i=1}^{n} \sum_{j=i}^{i} L_i
\\=\sum_{i=1}^{n} T_i-\sum_{i=1}^{n} (n-i+1)L_i
$$

$\sum_{i=1}^{n}$ 可以 $O(1)$ 维护，则需要使得 $\sum_{i=1}^{n} (n-i+1)L_i$ 最小。观察系数 $n-i+1$，可以发现 $L$ 需要升序排列。

所以 $O(nq \log n)$ 的思路就是每次查询时暴力排序，然后 $O(n)$ 计算。考场 50pts 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 2e5 + 5;
int n, q, k;
long long sum = 0;
long long b[N], c[N], t[N];

long long get() {
	for (int i = 1; i <= n; i++) b[i] = c[i];
	sort(b + 1, b + n + 1);
	long long res = 0;
	for (int i = 1; i <= n; i++) {
		res += 1LL * (n - i + 1) * b[i];
	}
	return res;
}

void _main() {
	cin >> n >> q;
	for (int i = 1; i <= n; i++) {
		cin >> t[i] >> c[i];
		sum += t[i];
	}
	cout << sum - get() << '\n';
	while (q--) {
		cin >> k;
		sum -= t[k];
		cin >> t[k] >> c[k];
		sum += t[k];

		cout << sum - get() << '\n';
	}
}
```

提交后你会获得 [Link](https://www.luogu.com.cn/record/179239140)。

考虑用 $O(\log n)$ 回答。问题是：

维护一个有序数组 $c$，支持单点修改和查询 $\sum_{i=1}^{n} (n-i+1)c_i$。

发现值域为 $10^5$ 级别。可以用两个值域树状数组维护。一棵放小于某元素的元素之和，一棵放小于某元素的元素数目，按柿子维护贡献，复杂度 $O(n\log n+q\log w)$。

然后考场上没写完。以下是赛后代码。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 2e5 + 5;
long long n, q, k, x, b[N], c[N], t[N];

struct BIT {
	long long tr[N];
	constexpr int lowbit(int x) {return x & -x;}
	void add(int x, long long c) {for (; x < N; x += lowbit(x)) tr[x] += c;}
	long long sum(int x) {
		long long res = 0; for (; x != 0; x -= lowbit(x)) {
			res += tr[x];
		} return res;
	}
} bit1, bit2;
// bit1放小于某元素的元素之和，bit2放小于某元素的元素数目 

long long get() {
	for (int i = 1; i <= n; i++) b[i] = c[i];
	sort(b + 1, b + n + 1);
	long long res = 0;
	for (int i = 1; i <= n; i++) {
		res += 1LL * (n - i + 1) * b[i];
	}
	return res;
}

long long sum, res;
void _main() {
	cin >> n >> q;
	for (int i = 1; i <= n; i++) {
		cin >> t[i] >> c[i];
		sum += t[i];
		bit1.add(c[i], c[i]), bit2.add(c[i], 1);
	}
	cout << sum - (res = get()) << '\n';
	while (q--) {
		cin >> k;
		sum -= t[k];
		cin >> t[k] >> x;
		sum += t[k];   
		
		res -= c[k] * (n - bit2.sum(c[k] - 1)) + bit1.sum(c[k] - 1);
		bit1.add(c[k], -c[k]), bit2.add(c[k], -1);
		c[k] = x;
		res += c[k] * (n - bit2.sum(c[k] - 1)) + bit1.sum(c[k] - 1);
		bit1.add(c[k], c[k]), bit2.add(c[k], 1);
		cout << sum - res << '\n';
	}
}
```

---

## 作者：Melo_DDD (赞：1)

诶，我啥时候可以场切紫了啊。降了告诉我一声。

牛逼题。

根据人类直觉，要给 $T_i$ 较小的先送，下面给出证明。

我们设第 $i$ 个人就是第 $i$ 个被送披萨的人（我们可以对原来的顺序进行任意排列），那么送披萨给他的时间是 $\sum_{j=1}^{i}T_j$，他获得的小费是 $L_i-\sum_{j=1}^{i}T_j$（可能是负的）。那么 Mirko 获得的总共小费是 $$\sum_{i=1}^{n}(L_i-\sum_{j=1}^{i}T_j)=\sum_{i=1}^{n}L_i-\sum_{i=1}^{n}T_i\times(n-i+1)$$。

解释一下 $\sum_{i=1}^{n}T_i\times(n-i+1)$ 是怎么来的，我们发现对于 $\sum_{j=1}^{i}T_j$ 这个式子，对于任意一个 $i$ 和另外一个 $k$，当且仅当 $k\ge i$ 的时候 $T_i$ 会被 $k$ 包含到。所有大于等于 $i$ 的 $k$ 一共有 $n-i+1$ 个，那么就一共减去了 $n-i+1$ 个 $T_i$。

那么通过这个式子，我们可以发现什么？

- 无论如何排列，$L_i$ 都不会影响到最后的答案。
- $i$ 越小，$T_i$ 被减去的次数就越多。

综上，我们可以发现，我们只需要把更小的 $T_i$ 放到更前面，就可以让减数最小化，也就是答案最大。

在没有修改的情况下，我们只需要对所有的 $T_i$ 升序排序在进行计算就可以了。

当我们改变一个人的 $L_i$ 和 $T_i$ 的时候，我们可以看做将这个人原来的 $L_i$ 和 $T_i$ 删除，再把新的加上。

首先考虑删除操作会对答案产生什么影响，当我们把一个人的 $L_i$ 和 $T_i$ 删除时，显然原来的答案会减去 $L_i$，同时。总数变为 $n-1$，他后面的第 $j$ 个人变成了第 $j-1$ 个人，对于前面的人，式子变成了 $\sum_{j=1}^{i-1}(n-1-j+1)\times T_j$，注意前面的符号是减号，所以答案相比原来增加了 $\sum_{j=1}^{i-1}T_j$（如果想不明白，带入原式展开就好了）。后面的人的系数是 $n-1-(j-1)+1=n-j+1$ 不变，但是注意后面的人全都减去了一个 $T_i$，把 $T_i$ 删除后答案还会增加 $T_i$ 乘上后面的人数。

增加操作其实就是反过来，自己推一推就好了，最后会发现答案是增加了一个 $L_i$，减少了 $\sum_{j=1}^{i-1}T_j$，还有一个后面的数量乘上 $T_i$。

怎么维护呢？注意到我们需要支持单点删（减）、增（加），同时求区间和，~~平衡树非常合适但是我不会~~可以用线段树，注意到 $T$ 和 $L$ 值域很小，所以可以对值域建树。

代码（代码中我的 $L$ 和 $T$ 是反的）：


```cpp
#include <bits/stdc++.h>
#define int long long
#define f(i ,m ,n ,x) for (int i = (m) ;i <= (n) ;i += (x))
using namespace std ;
template < typename T > inline void read ( T &x ) {
	x = 0 ;
	bool flag (0) ;
	register char ch = getchar () ;
	while (! isdigit (ch)) {
		flag = ch == '-' ;
		ch = getchar () ;
	}
	while (isdigit (ch)) {
		x = (x << 1) + (x << 3) + (ch ^ 48) ;
		ch = getchar () ;
	}
	flag ? x = -x : 0 ;
} 
const int N = 2e5 + 7 ;
int n ,q ,l[N] ,c[N] ,t[N] ,ans ;
struct segment_tree {
	int l ,r ,val ,tot ;
	#define l(cur) ttt[cur].l
	#define r(cur) ttt[cur].r
	#define val(cur) ttt[cur].val
	#define tot(cur) ttt[cur].tot
} ttt[N << 2] ; 
// cnt 记录个数，就是当前这个点前面有多少个点
// val 记录值，用来统计区间和
#define ls (cur) << 1 
#define rs (cur) << 1 | 1
namespace melo {
	inline void pushup (int cur) {
		val (cur) = val (ls) + val (rs) ;
		return (void) (tot (cur) = tot (ls) + tot (rs)) ;
	}
	inline void build (int cur ,int l ,int r) {
		l (cur) = l ,r (cur) = r ;
		if (l == r) 
			return ;
		int mid = l + r >> 1 ;
		melo :: build (ls ,l ,mid) ;
		melo :: build (rs ,mid + 1 ,r) ;
	}
	inline void modify (int cur ,int x ,int k ,int m) {
		if (l (cur) == r (cur)) {
			val (cur) += k ;
			return (void) (tot (cur) += m) ;
		}
		int mid = l (cur) + r (cur) >> 1 ;
		if (x <= mid) 
			melo :: modify (ls ,x ,k ,m) ;
		else 
			melo :: modify (rs ,x ,k ,m) ;
		melo :: pushup (cur) ;
	}
	inline int query (int cur ,int nowl ,int nowr ,bool flag = false) {
		if (nowl <= l (cur) && nowr >= r (cur)) {
			if (flag) 
				return tot (cur) ;
			else 
				return val (cur) ;
		}
		int mid = l (cur) + r (cur) >> 1 ,ans = 0 ;
		if (nowl <= mid && l (cur) <= nowr) 
			ans += melo :: query (ls ,nowl ,nowr ,flag) ;
		if (nowr > mid && r (cur) >= nowl) 
			ans += melo :: query (rs ,nowl ,nowr ,flag) ;
		return ans ;
	}
} // 很板的单点修改加上区间查询
// 注意是对 T 数组建树（在我的代码里是 L）
signed main () {
	//freopen ("cake.in" ,"r" ,stdin) ;
	//freopen ("cake.out" ,"w" ,stdout) ;
	read (n) ,read (q) ;
	f (i ,1 ,n ,1) {
		read (t[i]) ,read (l[i]) ;
		c[i] = l[i] ;
	}
	sort (c + 1 ,c + n + 1) ; // 一定要排序
	f (i ,1 ,n ,1) 
		ans += t[i] - (n - i + 1) * c[i] ;
	cout << ans << '\n' ;
	melo :: build (1 ,1 ,1e5) ; // 值域一定要开够
	f (i ,1 ,n ,1) 
		melo :: modify (1 ,l[i] ,l[i] ,1) ; // 初始化，在所对应的值的点上加
	while (q --) {
		int k ,tt ,ll ;
		read (k) ,read (tt) ,read (ll) ;
		melo :: modify (1 ,l[k] ,- l[k] ,-1) ; // 删除
		int a = melo :: query (1 ,1 ,l[k]) ,b = melo :: query (1 ,1 ,l[k] ,1) ; // 求他前面有多少个数以及前面的数的和
		ans -= t[k] ;
		ans += (n - b) * l[k] ; // n - b 就是后面的数的个数
		ans += a ;
		t[k] = tt ,l[k] = ll ;
		ans += t[k] ;
		a = melo :: query (1 ,1 ,l[k]) ,b = melo :: query (1 ,1 ,l[k] ,1) ;
		ans -= (n - b) * l[k] ;
		ans -= a ;
		melo :: modify (1 ,l[k] ,l[k] ,1) ; // 增加
		cout << ans << '\n' ;
	}
	return 0 ;
}
```

---

## 作者：封禁用户 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P7619)

首先获得的小费只和做披萨的顺序有关。我们令做蛋糕的顺序为排列 $p$，那么不难直接写出答案。
$$
ans=\sum_{i=1}^n L_{p_i}-\sum
_{j=1}^i T_{p_j}
$$
直接拆开算。
$$
ans=\sum_{i=1}^n L_i-\sum_{i=1}^n (n-i+1) \times T_{p_i}
$$
前者可以 $O(1)$ 维护。

对于后者，如果单次查询，我们直接对 $T$ 从小到大排序。

我们还需要支持单点修改，也就是要在线维护每个数比它小的有多少个数，和比它小的数之和。

值域很小，直接开两个树状数组维护即可。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N= 2* 1e5+ 5;
int l[N], t[N], a[N];
int tr1[N* 4], tr2[N* 4];
int n, m; 
int lowbit(int x)
{
	return x& (- x);
}
void add1(int u, int x)
{
	for(int i=u; i<N; i+= lowbit(i)) tr1[i]+= x;
	return ;
}
void add2(int u, int x)
{
	for(int i=u; i<N; i+= lowbit(i)) tr2[i]+= x;
	return ;
}
int query1(int x)
{
	int sum= 0;
	for(int i=x; i; i-= lowbit(i)) sum+= tr1[i];
	return sum; 
}
int query2(int x)
{
	int sum= 0;
	for(int i=x; i; i-= lowbit(i)) sum+= tr2[i];
	return sum; 
}
signed main()
{	
	cin>> n>> m;
	int ans1= 0;
	for(int i=1; i<=n; i++) 
	{
		scanf("%lld%lld", &l[i], &t[i]);
		a[i]= t[i];
		ans1+= l[i];
		add1(t[i], t[i]); add2(t[i], 1);
	} 
	sort(t+ 1, t+ n+ 1);
	int ans2= 0;
	for(int i=1; i<=n; i++) ans2+= (n- i+ 1)* t[i];
	printf("%lld\n", ans1- ans2);
	while(m-- )
	{
		int u, x, y; scanf("%lld%lld%lld", &u, &x, &y);
		ans1= ans1- l[u]+ x; l[u]= x;
		ans2-= a[u]* (n- query2(a[u]- 1))+ query1(a[u]- 1);
		add2(a[u], -1); add1(a[u], -a[u]);
		a[u]= y;
		add2(a[u], 1); add1(a[u], a[u]);
		ans2+= a[u]* (n- query2(a[u]- 1))+ query1(a[u]- 1);
		printf("%lld\n", ans1- ans2);
	}
	return 0;
}
```

---

## 作者：__Louis__ (赞：0)

## 题解：P7619 [COCI2011-2012#2] RASPORED


### 题目大意

有两个长度为 $n$ 序列 $A,B$，每一次可以交换 $A_i,B_i$ 和 $A_j,B_j$，你需要最大化以下算式。

$$ \sum_{i=1}^{i \le n} B_i - \sum_{i=1}^{i \le n} \sum_{j=1}^{j \le i} A_j  $$

同时，有 $C$ 次修改，每次修改后查询。
### 思路

#### 50pts：桶思想

首先，对于以上算式，肯定有贪心的想法，即把小的放在前面。

观察第一档部分分，发现值域很小，于是可以通过桶的思想和等差数列求和公式 $O(T)$ 算出答案。

#### code for 50pts


```cpp
// 考场50pts
#include<bits/stdc++.h>
using namespace std;
#define int long long 
#define inf 0x3f3f3f3f3f3f3f 
const int maxv=1e3+10;
const int maxn=1e5+10;
int ans,n,m;
int c[maxn],w[maxn];
int arr[maxv];
int same(int d,int a1){
	return (2*a1+d-1)*d/2;
} 
int get(int n){
	int sum=0;
	int p=n,q;
	for(int i=1;i<maxv&&p;i++){
		q=p-arr[i]+1;
		sum+=same(arr[i],q)*i;
		p-=arr[i];
	}
	return sum;
}
signed main(){
//	freopen("pizza.in","r",stdin);
//	freopen("pizza.out","w",stdout);
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%lld%lld",&w[i],&c[i]);
		ans+=w[i];
		arr[c[i]]++;
	}
	int a;
	printf("%lld\n",ans-get(n)); 
	for(int i=1;i<=m;i++){
		scanf("%lld",&a);
		ans-=w[a];
		arr[c[a]]--;
		scanf("%lld%lld",&w[a],&c[a]);
		ans+=w[a];
		arr[c[a]]++;
		printf("%lld\n",ans-get(n)); 
	}
}
```
#### 正解：权值线段树（平衡树）

因为50pts的暴力做法可以通过计算排名等方式优化，于是想到平衡树或者权值线段树。

这里只介绍权值线段树的做法。

首先，把桶的大小变成 $10^5$，然后考虑如何合并线段树。

首先，需要维护三个值：区间内的和，区间内的答案以及区间内事件个数（就是取餐人的个数）。

合并时，区间和以及区间事件个数直接相加。而答案可以利用这个图来理解。

![](https://cdn.luogu.com.cn/upload/image_hosting/fwn7y8sw.png)

其中 $t$ 表示事件个数，$sum$ 表示和。于是有：

$$ ans_x = ans_l+ ans_r+sum_l*t_r$$

然后每一次修改时单点修改，答案为 $ans_1$。

#### code for 100pts(150pts)


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define inf 0x3f3f3f3f3f3f3f3f
const int maxn=2e5+10;

struct node{
	int da,t,sum;
}tree[maxn<<2];
inline int ls(int x){
	return x<<1;
}
inline int rs(int x){
	return x<<1|1;
}
void push_up(int x){
	tree[x].sum=tree[ls(x)].sum+tree[rs(x)].sum;
	tree[x].t=tree[ls(x)].t+tree[rs(x)].t;
	tree[x].da=tree[ls(x)].da+tree[rs(x)].da+tree[rs(x)].t*tree[ls(x)].sum;
}
void insert(int x,int l,int r,int p){
	if(l==r){
		tree[x].t++;
		tree[x].sum+=p;
		tree[x].da+=tree[x].t*p;
		return;
	}
	int mid=(l+r)>>1;
	if(mid>=p) insert(ls(x),l,mid,p);
	else insert(rs(x),mid+1,r,p);
	push_up(x);
}
void del(int x,int l,int r,int p){
	if(l==r){
		tree[x].da-=tree[x].t*p;
		tree[x].t--;
		tree[x].sum-=p;
		return;
	}
	int mid=(l+r)>>1;
	if(mid>=p) del(ls(x),l,mid,p);
	else del(rs(x),mid+1,r,p);
	push_up(x);
} 
int c[maxn],w[maxn];
signed main(){
//	freopen("pizza.in","r",stdin);
//	freopen("pizza.out","w",stdout);
	int n,m;
	scanf("%lld%lld",&n,&m);
	int a;
	int ans=0;
	for(int i=1;i<=n;i++){
		scanf("%lld%lld",&w[i],&c[i]);
		ans+=w[i];
		insert(1,1,1e5,c[i]);
	}
	printf("%lld\n",ans-tree[1].da);
	for(int i=1;i<=m;i++){
		scanf("%lld",&a);
		ans-=w[a];
		del(1,1,1e5,c[a]);
		scanf("%lld%lld",&w[a],&c[a]);
		ans+=w[a];
		insert(1,1,1e5,c[a]);
		printf("%lld\n",ans-tree[1].da);
	}
}
```

---

## 作者：青鸟_Blue_Bird (赞：0)

此题解使用平衡树解决。

## 1、原始情况

首先，我们考虑未修改的情况。设 $L_i$ 为吃饭时间，$a_i$ 为制作所需时间。对于 $n$ 个居民，假设我们不对做披萨的顺序进行修改，即按照原始顺序的话，可以写出答案：

$ans = (L_1 - a_1) + [L_2 - (a_1 + a_2)] + [L_3 - (a_1 + a_2 + a_3)] ......$ 

以此类推，整理后即可得到：

$ans = (L_1 + L_2 + L_3 + ..... + L_n) - [na_1 + (n-1)a_2 + (n-2)a_3 + ...... + a_n]$

不难看出，送披萨的先后顺序对于 $L_i$ 来说是没有影响的。而对于后半部分，我们要想使得总答案最大，肯定要使得 $a_1$ 最小， $a_2$ 次大，以此类推。因此，只需要通过一次排序，我们便能轻松求出修改前最大的小费收益。

## 2、修改

接下来考虑每次的修改。首先，对于 $L_i$ 的变化，我们直接加减即可。重点考虑 $a_i$ 的变化。不妨如此假设：令 $a_i$ 原先的排名为 $l$, 而其修改后的排名为 $r (l \le r)$, 可以看到，只有区间 $(l,r)$ 内部的数受到了影响，他们的系数全部减小 $1$, 即对于该次修改，我们要减掉 $\sum a_i (i \in (l,r))$。当 $l \ge r$ 的时候同理，反过来即可。

## 3、具体操作
考虑到我们需要提取一定区间内部的所有数，使用 FHQ-Treap 可以很好的解决这个问题。在传统写法的基础上，记 $w$ 为每个节点的子树大小之和，方便快速查询。 ~~(想法来自线段树)~~

细节处理请见代码注释。
## 4、后记
- 不开 **long long** 见祖宗！
- 每次修改后的数据应该保留，手摸样例可以发现。

上代码（常数略大，大家可自行优化一下。）

```
#include <bits/stdc++.h>
using namespace std;
#define N 2000010
#define ll long long
#define int long long

template <class T>
inline void read(T& a){
	T x = 0, s = 1;
	char c = getchar();
	while(!isdigit(c)){ if(c == '-') s = -1; c = getchar(); }
	while(isdigit(c)){ x = x * 10 + (c ^ '0'); c = getchar(); }
	a = x * s;
	return ;
}

int n, Q;
struct people{
  int L, T; 
  int id; 
} a[N]; 

bool cmp1(people a, people b){
  return a.T < b.T; 
}

bool cmp2(people a, people b){
  return a.id < b.id; 
}

ll ans = 0; 

/*经典 FHQ-Treap 写法，不过多解释。*/
int root = 0; 

struct node{
  int siz, val, ch[2]; 
  int pri, w;     // w 为总和， val 为当前点的值
} t[N]; 

#define lson ch[0]
#define rson ch[1]

int tot = 0;
inline int build(int x){
  t[++tot].siz = 1;
  t[tot].val = x; 
  t[tot].pri = rand(); 
  t[tot].lson = t[tot].rson = 0;
  t[tot].w = x; 
  return tot; 
}

inline void pushup(int now){
  t[0].siz = t[0].w = t[0].val = 0; 
  t[now].siz = t[t[now].lson].siz + t[t[now].rson].siz + 1; 
  t[now].w = t[t[now].lson].w + t[t[now].rson].w + t[now].val; 
  return ; 
}

void split(int now, int key, int& x, int& y){  // 分裂
  if(!now){
    x = y = 0;
    return ; 
  }
  if(t[now].val <= key){
    x = now; 
    split(t[now].rson, key, t[now].rson, y); 
  }
  else {
    y = now; 
    split(t[now].lson, key, x, t[now].lson); 
  }
  pushup(now); 
  return ; 
}

int merge(int x, int y){
  if(!x || !y) return x + y;
  if(t[x].pri > t[y].pri){
    t[x].rson = merge(t[x].rson, y); 
    pushup(x);
    return x; 
  }
  else{
    t[y].lson = merge(x, t[y].lson); 
    pushup(y);
    return y; 
  }
  return 0; 
}

void insert(int key){
  int x, y; 
  split(root, key - 1, x, y); 
  root = merge(merge(x, build(key)), y); 
  return ; 
}

void del(int key){
  int x, y, z; 
  split(root, key, x, z); 
  split(x, key - 1, x, y); 
  if(y) y = merge(t[y].lson, t[y].rson); 
  root = merge(merge(x, y), z); 
  return ; 
}

int get_ans(int ori, int key){  // 处理每次修改后 T 的变化
  if(ori == key) return 0; 
  int x, y, z, sum = 0; 
  split(root, ori, x, y);         /*对于大小相同的重复节点的处理：直接把当前点认作排名最后的一个点。因为他们的先后顺序不影响答案.*/
  sum += (n - t[x].siz + 1) * ori;   
  root = merge(x, y); 
  del(ori); 
  // 消除原有影响

  insert(key); 
  if(key > ori){   // 注意分类讨论，提取区间内的所有数，建议画图讨论
    split(root, ori, x, z); 
    split(z, key, y, z); 
    sum -= t[y].w - key; 
    root = merge(merge(x, y), z); 
  }
  else {
    split(root, ori, x, z); 
    split(x, key, x, y); 
    sum += t[y].w; 
    root = merge(merge(x, y), z); 
  }
  split(root, key, x, y);   // 不要忘了这个数自己
  sum -= (n - t[x].siz + 1) * key; 
  root = merge(x, y); 
  return sum; 
}

signed main(){
  read(n); read(Q);
  for(int i = 1; i <= n; i++){
    read(a[i].L), read(a[i].T); 
    a[i].id = i; 
  }
  sort(a + 1, a + n + 1, cmp1); 
  for(int i = 1; i <= n; i++){
    ans += a[i].L; 
    ans -= (n - i + 1) * a[i].T; 
  }
  cout << ans << endl; 
  for(int i = 1; i <= n; i++)
    insert(a[i].T); 
  sort(a + 1, a + n + 1, cmp2); 
  while(Q--){
    int opt, L, T; 
    read(opt), read(L), read(T); 
    ans -= a[opt].L; 
    ans += L; 
    a[opt].L = L; 
    ans += get_ans(a[opt].T, T); 
    a[opt].T = T; 
    printf("%lld\n", ans); 
  }
  return 0;
}
```


---

## 作者：junee (赞：0)

# P7619 题解

## 前置知识

树状数组。

## 题目分析

这个题和 [https://www.luogu.com.cn/problem/P10673](P10673) 很像。

思考一下这个过程，很容易知道答案为 $\sum\limits_{i=1}^n l_i -\sum\limits_{i=1}^n\sum\limits_{j=1}^i t_i$。

这个也容易想到，最多可以获得 $\sum\limits_{i=1}^n l_i$，然后减去每一个人等前面人的做匹萨的时间。

发现这个式子与 $l_i$ 无关，只与 $t_i$ 有关，将后面一部分化简一下得到 $\sum\limits_{i=1}^n(n-i+1)\times t_i$。很容易想到时间越小越先做，这是显然的。

用两个权值树状数组维护这个东西，用权值线段树也可以，时间复杂度为 $O(C\log V)$，$V$ 为值域。

## Code

```
#include<iostream>
#include<iomanip>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<random>
#include<chrono>
using namespace std;
mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());
typedef long long LL;
const int N=2e5+10;
int n,m;
LL t[N],l[N],a[N],sum=0;
LL tr1[N],tr2[N];
void add(LL tr[],int x,LL k){
	for(;x<N;x+=x&-x)tr[x]+=k;
}
LL ask(LL tr[],int x){
	LL res=0;
	for(;x;x-=x&-x)res+=tr[x];
	return res;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>t[i]>>l[i];
		sum+=t[i];
		add(tr1,l[i],l[i]);
		add(tr2,l[i],1);
	}
	LL res=0;
	for(int i=1;i<=n;i++)a[i]=l[i];
	sort(a+1,a+1+n);
	for(int i=1;i<=n;i++)res+=1LL*(n-i+1)*a[i];
	cout<<sum-res<<'\n';
	while(m--){
		int x,k,c;
		cin>>x>>k>>c;
		sum+=k-t[x];
		t[x]=k;
		res-=l[x]*(n-ask(tr2,l[x]-1))+ask(tr1,l[x]-1);
		add(tr1,l[x],-l[x]);
		add(tr2,l[x],-1);
		l[x]=c;
		res+=l[x]*(n-ask(tr2,l[x]-1))+ask(tr1,l[x]-1);
		add(tr1,l[x],l[x]),add(tr2,l[x],1);
		cout<<sum-res<<'\n'; 
	}
	return 0;
}

```

---


# [HNOI2010] 物品调度

## 题目描述

现在找工作不容易，Lostmonkey 费了好大劲才得到 fsk 公司基层流水线操作员的职位。流水线上有 $n$ 个位置，从 $0$ 到 $n - 1$ 依次编号，一开始 $0$ 号位置是空的，其它的位置 $i$ 上有编号为 $i$ 的盒子。Lostmonkey 要按照以下规则重新排列这些盒子。

规则由五个数描述，$q, p, m, d, s$，$s$ 表示空位的最终位置。

首先生成一个序列 $c$，$c_0=0$，$c_{i+1}=(c_i\times q+p)\bmod m$。

接下来从第一个盒子开始依次生成每个盒子的最终位置 $pos_i$，$pos_i=(c_i+d\times x_i+y_i)\bmod n$，$x_i,y_i$ 是为了让第 $i$ 个盒子不与之前的盒子位置相同的由你设定的非负整数，且 $pos_i$ 还不能为 $s$。

如果有多个序列 $x,y$ 满足要求，你需要选择 $y$ 的字典序最小的，当 $y$ 相同时选择 $x$ 字典序最小的。这样你得到了所有盒子的最终位置，现在你每次可以把某个盒子移动到空位上，移动后原盒子所在的位置成为空位。

问把所有的盒子移动到最终位置所需的最少步数。

## 说明/提示

**【样例解释】**

第 $1$ 个到第 $7$ 个盒子的最终位置依次是：$[2, 5, 6, 4, 1, 0, 7]$。

**【数据范围】**

对于 $30 \%$ 的数据，$n \le 100$，  
对于 $100 \%$ 的数据，$1 \le t \le 20$，$1 \le n \le 100000$，$0 \le s < n$。

其余所有数字均为不超过 $100000$ 的正整数。

**【提示】**

计算过程可能超过整型范围。

## 样例 #1

### 输入

```
1
8 3 5 2 7 4```

### 输出

```
6```

# 题解

## 作者：赫鲁老七 (赞：11)

为毛出题人不好好出数据啊 ...

这个 $pos_i=(c_i+d\times x_i+y_i)\operatorname{mod}n$ 看上去很有迷惑性啊，感觉是一个xjb写的式子然而并不是这样。

首先它这个 $d$ 是个定值，也就是说当我们确定了一个 $y_i$ 的时候，可选的位置一定是 $y_i+c_i,y_i+c_i+d,y_i+c_i+2\cdot d \dots$   抽象点看的话发现每个点都有一个出边，其中 $x$ 指向 $(x+d)\operatorname{mod} n$。

因为每个点都有一个出边而且固定步长为 $d$，所以这本质上是 $\gcd(n,d)$ 个长度为 $\frac n{\gcd (n,d)}$ 的环。

所以 $y_i$ 实际上就确定了要在哪个环中找空位置，$x_i$ 就是确定了要在当前的环中找第几个空位。

所以一个暴力做法就是从小到大枚举 $y_i$，然后从小到大枚举 $x_i$，如果当前位置能放就放，否则找 $x_i+d$ 。如果当前环满了就将 $y_i+1$，然后继续找。

因为在同一个环内的步长固定为 $d$，所以在同一个环内找的时候可以拿并查集优化，每个点的祖先是这个点加若干个 $d$ 之后的第一个空位。最开始每个点的祖先是自己，如果点 $x$ 被占用，那就让 $father[x]=(x+d)\operatorname{mod} n$。

然而只优化找 $x_i$ 的过程是不够的， $n$ 个长度为 $1$ 的环就能卡掉了。所以还要优化找 $y_i$ 的过程，因为找 $y_i$ 的步长固定为 $1$，所以我们也对每个环弄一个并查集，每个环的祖先是从这个环加若干个 $1$ 之后第一个还有空位的环。最开始每个点的祖先是自己，如果环 $x$ 被填满，那就让 $father[x]=(x+1)\operatorname{mod} n$。

大体思路就是这样，但是还有一点小细节。假设 $p$ 是我们找到的第一个有空位的环，这时候 $y_i$ 就已经确定了对吧，所以我们要做的就是让 $x_i$ 最小。所以算出当 $x_i=0$ 时那个式子的值就是 $c_i+p-belong[c_i] \operatorname{mod} tot$，其中 $belong[i]$ 表示位置 $i$ 所在的环的编号，$tot$ 表示总环数，然后从这个值再往下找就吼了。

```cpp
#include<bits/stdc++.h>
using std::min;
using std::max;
using std::swap;
using std::vector;
typedef double db;
typedef long long ll;
#define pb(A) push_back(A)
#define pii std::pair<int,int>
#define all(A) A.begin(),A.end()
#define mp(A,B) std::make_pair(A,B)
const int N=1e5+5;

int pos[N],vis[N];
int c[N],belong[N];
int n,q,p,m,d,s,tot;

struct bcj{
    int father[N];

    void init(){for(int i=0;i<n;i++) father[i]=i;}

    int find(int x){return father[x]==x?x:father[x]=find(father[x]);}

}A,B;

int getint(){
    int X=0,w=0;char ch=getchar();
    while(!isdigit(ch))w|=ch=='-',ch=getchar();
    while( isdigit(ch))X=X*10+ch-48,ch=getchar();
    if(w) return -X;return X;
}

void rem(int x){
    int r1=A.find(x),r2=A.find((r1+d)%n);
    if(r1!=r2) A.father[r1]=r2;
    else{
        r1=B.find(belong[x]),r2=B.find((r1+1)%tot);
        B.father[r1]=r2;
    }
}

int calc(int x,int y){
    return (x-y+tot)%tot;
}

signed main(){
    int T=getint();
    while(T--){
        n=getint(),s=getint(),q=getint(),p=getint(),m=getint(),d=getint()%n;
        A.init(),B.init();tot=0;
        for(int i=1;i<n;i++) c[i]=(1ll*c[i-1]*q+p)%m;
        memset(belong,-1,sizeof belong);
        for(int i=0;i<n;i++){
            if(belong[i]==-1){
                for(int j=i;belong[j]<0;j=(j+d)%n)
                    belong[j]=tot;
                tot++;
            }
        } 
        rem(s);pos[0]=s;
        for(int i=1;i<n;i++){ 
            c[i]%=n;
            int pp=B.find(belong[c[i]]);
            int qq=A.find((c[i]+calc(pp,belong[c[i]]))%n);
            pos[i]=qq;rem(qq);
        } 
        int ans=0;memset(vis,0,sizeof vis);
        for(int i=0;i<n;i++){
            if(!vis[i]){
                vis[i]=1;int now=i;
                int cnt=1,flag=now==s;
                while(!vis[pos[now]]){
                    now=pos[now];vis[now]=1;
                    cnt++;if(now==s) flag=1;
                }
                if(flag) ans+=cnt-1;
                else if(cnt>1) ans+=cnt+1;
            }
        } printf("%d\n",ans);
    } return 0;
}

```



---

## 作者：「QQ红包」 (赞：8)

如果我们已经求出了pos数组，则存在若干个循环节，如果循环节长度为1，不管，如果包含空位置，则ans=ans+L-1（空位置的话就不用移了）否则 ans=ans+L+1（还要把空位置移出去）

考虑如何求pos数组。可以用并查集。

`find(i)` 表示从i开始找找到的最近的空位置的编号，初始 `fa[i]=i;`

$ y_i $ 我们从小到大枚举( $ y_i+1 $ 相当于 $ c_i+1 $ ) ，$x_i $ 的话就用并查集搞。

代码比较好懂？

```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
#define ll long long
using namespace std;
void qmax(int &x,int y) {if (x<y) x=y;}
void qmin(int &x,int y) {if (x>y) x=y;}
inline int read()
{
    char s;
    int k=0,base=1;
    while((s=getchar())!='-'&&s!=EOF&&!(isdigit(s)));
    if(s==EOF)exit(0);
    if(s=='-')base=-1,s=getchar();
    while(isdigit(s)){k=k*10+(s^'0');s=getchar();}
    return k*base;
}
inline void write(int x)
{
    static char cnt,num[15];cnt=0;
    if (!x)
    {
        putchar('0');
        return;
    }
    for (;x;x/=10) num[++cnt]=x%10;
    for (;cnt;putchar(num[cnt--]+48));
}
const int maxn=100000+100;
int fa[maxn],T;
int n,s,q,p,m,d;
int vis[maxn],cir[maxn],pos[maxn],c[maxn];
int full[maxn];
int find(int x)
{
    if (!full[cir[x]]) return fa[x]==x?x:fa[x]=find(fa[x]);
    return find(fa[x]=(x+1)%n); //相当于yi+1
}
void work()
{
    for (int i=0;i<=n;i++) fa[i]=i;
    c[0]=0;
    for (int i=1;i<n;i++) c[i]=(c[i-1]*q+p)%m;
    for (int i=0;i<n;i++)
    {//初始化
        fa[i]=i;
        cir[i]=-1;pos[i]=0;vis[i]=0;
        c[i]%=n;full[i]=0;
    }
    for (int i=0;i<n;i++)
        for (int j=i;cir[j]==-1;j=(j+d)%n)
            cir[j]=i;//标记一个环
    if (d==0) full[cir[s]]=1;pos[0]=s;//空位置
    fa[s]=find((s+d)%n);//处理空位置
    for (int i=1,x,y;i<n;i++)//求pos
    {
        x=find(c[i]),y=find((x+d)%n);
        pos[i]=x;
        if (x==y) full[cir[x]]=1;//说明目前所在的环放满了
        else fa[x]=y;//x位置被放了，就往下推一个
    }
    int ans=0,sz=0;
    for (int i=0;i<n;i++)
    {//找出每一个循环节并更新
        if (!vis[i])
        {
            int j=i;
            sz=0;
            while (!vis[j])
            {
                sz++;
                vis[j]=1;
                j=pos[j];
            }
            if (sz>1)
            {//记答案
                if (i==0) ans+=sz-1; else ans+=sz+1;
            }
        }
    }
    printf("%d\n",ans);
}
int main()
{
#ifdef ylx
    freopen("p3207.in","r",stdin);
    freopen("p3207.out","w",stdout);
#endif
    T=read();
    while (T--)
    {
        n=read();s=read();
        q=read();p=read();
        m=read();d=read();
        work();
    }
    return 0;
}
```

---

## 作者：i207M (赞：7)

一不小心hack掉所有题解的数据（本题解能过）：

```
1
100000 1 1 100000 100000 100000
```

by [ztb](https://www.luogu.org/discuss/show/91318)

首先大体思路和前面的题解是一样的。首先要读对题，$x_i,y_i$相互独立。

然后我们要确定每个点的位置。这时大部分题解就采用了暴力枚举y的方法，然后可以被卡为$O(N^2)$。

下面介绍两个解决方案：

1. 对每个环也建一个并查集，环与环之间连边，这样当某个环满了的时候，直接跳过这个环。 by ztb

2. 我的方法：

首先，注意到$x+kd\mod n$所在的环，是所有$\mod gcd(d,n)$与x同余的数。我们用set存所有没有空的环。然后距离点i最近的环，要么是$>=i \mod gcd(d,n)$最小的，要么就是加了一圈回到起点，$\mod gcd(d,n)$最小的，分类讨论即可。

具体实现可以看代码。

```cpp
#define N 100005
int n,S,D,G;
int c[N],f[N],p[N];
il int gcd(int a,int b)
{
	return b?gcd(b,a%b):a;
}
int find(int x)
{
	return x==f[x]?x:f[x]=find(f[x]);
}
set<pairint>st;
bool vis[N];
void clear()
{
	mem0(vis); st.clear();
}
signed main()
{
#ifdef M207
	freopen("in.in","r",stdin);
	// freopen("out.out","w",stdout);
#endif
	int T,Q,P,Md;
	in(T);
	while(T--)
	{
		clear();
		in(n),in(S),in(Q),in(P),in(Md),in(D);
		Q%=Md,P%=Md,G=gcd(D,n);
		for(ri i=1; i<n; ++i) c[i]=((LL)c[i-1]*Q+P)%Md;
		for(ri i=0; i<n; ++i) c[i]%=n;
		for(ri i=0; i<n; ++i) f[i]=i;
		for(ri i=0,con=n/G,tar=S%G; i<G; ++i)
			if(i!=tar) st.insert(mp(i,con));
			else
			{
				p[0]=S;
				f[S]=find((S+D)%n);
				if(con>1) st.insert(mp(i,con-1));
			}
		for(ri i=1; i<n; ++i)
		{
			auto it=st.lower_bound(mp(c[i]%G,0));
			if(it!=st.end())
			{
				int t1=it->fi,t2=it->se; st.erase(it);
				p[i]=find((c[i]+t1-c[i]%G)%n);
				f[p[i]]=find((p[i]+D)%n);
				if(t2>1) st.insert(mp(t1,t2-1));
			}
			else
			{
				it=st.begin();
				int t1=it->fi,t2=it->se; st.erase(it);
				p[i]=find(((c[i]/G+1)*G+t1)%n);
				f[p[i]]=find((p[i]+D)%n);
				if(t2>1) st.insert(mp(t1,t2-1));
			}
		}
		int ans=0;
		for(ri i=0; i<n; ++i)
			if(!vis[i])
			{
				int x=i,cnt=0;
				while(!vis[x]) vis[x]=1,++cnt,x=p[x];
				if(i==0) ans+=cnt-1;
				else if(cnt>1) ans+=cnt+1;
			}
		out(ans);
	}
	return 0;
}
```

---

## 作者：ywy_c_asm (赞：6)

~~orz这题实在是太神辣……我把网上的所有题解都翻遍了都没搞明白……~~

首先这题需要我们认真阅读这句话和这个式子：

### **1.如果有多个xi，yi满足要求，你需要选择yi最小的，当yi相同时选择xi最小的。**

### **2.**$\large{pos_i=}(c_i+y_i+d*x_i)\%n$

这里要说一句我做这题得出的教训，长成这样的式子在OI中差不多都是用来生成随机数的，因此我做这题的时候就以为这只是个没啥卵用的式子就没去深入研究它……所以做题千万不要想当然……

那么这式子究竟有啥特点呢？我们发现$d$是个定值，假设$y_i$固定的话，我们让$x_i$不断增大，那么就相当于在模$n$剩余系下给一个数不断地加$d$，容易想到这个会出环，我们想当$x_i$加到$n$的时候这个模$n$剩余系下的数就相当于回到了原位置，所以这个过程中必定会产生环。

然后来解释下第一句话的意思，就是相当于我们从小到大枚举$y_i$，再从小到大枚举$x_i$，只要找到第一个二元组$(y_i,x_i)$能够使得$pos_i$这个数没在前面出现过，就结束枚举。所以我们需要先求出$pos[]$，再去在这个$pos$数组的基础上找一个最小方案，这两者之间是独立的（~~突然发现我好像在解释题意~~不过话说回来这题题面是真的绕……）。

那么我们就“按题意模拟”（对你没有看错就是模拟）对每个$i$从$0$开始枚举$y_i$，我们结合一下上面的式子想一下这是在干嘛？这不就是枚举起点吗？换句话说我们在枚举到了哪个环毕竟一个起点确定一个环，然后我们要让$x_i$最小对吧，也就是说我们要从$c_i+y_i$出发不断地$d$步$d$步的跳，直到跳到一个没有被用过的点为止，这个是啥？这个是并查集能够加速的（当然链表似乎也可以）。

这玩意实现起来其实想想也是能想出来的，我们对$0$~$n-1$的数用并查集维护这个数下一步能够到达的可用的位置，另外再开个数组记一下这个点有没有被删除，原因就是如果一个点指向的位置被删除了那么这个点所在环就全都不可用了，我们就得接着枚举$y_i$直到找到一个能用的环为止。一个点$p$删除了就让他指向$(p+d)\%n$即可。

这里有个细节，就是空位最后是必须在$s$的，那么我们不妨把空位也看成一个能搬的箱子，并且他最后必须搬到$s$也就是说我们强制让$pos_0=s$。

这玩意复杂度为$O(\text{玄学})$，反正这样暴力枚举能过……~~不要问我为啥~~

然后我们来解决本题的后半部分：在$pos[]$的基础上求最小移动次数。

开始的时候我由于太naive然后以为把$pos[]$求出来然后我们每次把空位对应的物品放到空位上不就行了吗……显然这样不对，我们求出来的$pos[]$实质上是一个置换，而置换是能够被分解为多个环的，我刚才的想法只能把空位局限在一个环里。所以我们考虑两种环（显然自环就不用考虑了）：

1.空位一开始就在这个环里，换句话说就是0与$s$都在这个环里（别忘了我们已经让0指向$s$了），那么就可以在这**一个环里**用我的那种想法了，这个移动的次序也正是这个环倒过来啊（不明白的可以画一下），所以步数为环长-1。

2.空位本来并不在这个环里，但是我们不借助空位就不能进行环内的移动，所以我们必须先把一个位置搬到空位上，把空位引进来，然后转化为上面那种情况，最后把那个东西搬回来即可。显然跟上面相比多移动了两次就是环长+1。

然后就做完了……

上代码~（代码其实相当的短……）

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define ll long long
using namespace std;
namespace ywy{
	int ints[100001],pos[100001];
	unsigned char bv[100001];
	ll c[100001];
	int find(int n){//并查集 
		if(ints[n]==n)return(n);
        return(ints[n]=find(ints[n]));
	}
	void ywymain(){
		int t;cin>>t;
		while(t){
			t--;
			int n,s,q,p,m,d;
			cin>>n>>s>>q>>p>>m>>d；
			for(register int i=0;i<ni++)ints[i]=i,bv[i]=0;//初始化 
			pos[0]=s;bv[s]=1;
			ints[s]=(s+d)%n;//先把s用掉 
			for(register int i=1;i<n;i++)c[i]=(c[i-1]*q+p)%m;
			for(register int i=1;i<n;i++){
				int y=0;
				while(bv[find((y+c[i])%n)])y++;//枚举可行的y 
				pos[i]=find((y+c[i])%n);
				bv[pos[i]]=1;
				ints[pos[i]]=find((pos[i]+d)%n);
			}
			memset(bv,0,sizeof(bv));
			int ans=0；
			for(register int i=0;i<n;i++){
				if(bv[i]||pos[i]==i)continue;
				int cur=i,l=0;
				unsigned char bswitch=0;
				while(!bv[cur]){//遍历环 
					if(!cur)bswitch=1;
					bv[cur]=1;cur=pos[cur];l++;
				}
				if(bswitch)ans+=(l-1);//有0 
				else ans+=(l+1);
			}cout<<ans<<endl;
		}
	}
}
int main(){
	ywy::ywymain();return(0);//再见程序 
}
```

---

## 作者：Time_tears (赞：3)

读完这道题，我们可以从柿子上找思路
因为 $C_i=(C_{i-1}\times q+p)\bmod m$

而 $pos_i=(C_i+d×x_i+y_i)\bmod n$，此处要求 $y_i$ 尽量小，$y_i$ 最小时 $x_i$ 尽量小

 所以我们其实可以看出，$C_i$ 和 $pos_i$ 都是一个恒定的值
 
 于是我们可以直接算，所以这根本不是一道求最优解的问题，只是一道普通求解的问题

 然后我们考虑怎么算 $pos_i$，因为我们可以发现，若 $C$ 和 $y$ 的值固定，那么 $x$ 就是一个类似跳环的东西，我们每次跳步长为 $d$ ，一直跳到一个没有到过的位置即可，这个过程我们可以用并查集来加速跳环，而且我们又注意到，环的个数其实是 $\frac{n}{\gcd(n,d)}$)，所以在 $d=n$ 时如果一个一个跳环，可以轻松卡到 $O(n^2)$，所以我们在记录环时，也要记录从它开始第一个没有被走到的环是哪一个，同样用并查集即可。

~~丑陋的代码~~

```
#include<cstdio>
#include<cstring>
#define N 100005
using namespace std;
int q,p,m,fb[N],c[N],vis[N],tot;
int n,T,d,S,pos[N],fa[N],bl[N];
inline int read() {
	int s=0,f=0;
	char ch=getchar();
	while(ch<48||ch>57)f=(ch=='-'),ch=getchar();
	while(ch>47&&ch<58)s=(s<<1)+(s<<3)+(ch^48),ch=getchar();
	return f?-s:s;
}
int Finda(int x) {
	return x==fa[x]?x:fa[x]=Finda(fa[x]);
}
int Findb(int x) {
	return x==fb[x]?x:fb[x]=Findb(fb[x]);
}
void Ins(int x) {
	int r1=Finda(x),r2=Finda((x+d)%n);
	if(Finda(r1)!=Finda(r2))fa[Finda(r1)]=r2;
	else {
		r1=Findb(bl[x]),r2=Findb((r1+1)%tot);
		fb[Findb(r1)]=r2;
	}
}
int main() {
	int T=read();
	while(T--) {
		n=read(),S=read(),q=read(),p=read(),m=read(),d=read(),tot=0;
		for(int i=1; i<=n; ++i)c[i]=(1ll*c[i-1]*q+p)%m,c[i-1]%=n;
		memset(bl,-1,sizeof(bl));
		memset(vis,0,sizeof(vis));
		for(int i=0; i<n; ++i)
			if(bl[i]==-1) {
				int j=i;
				while(bl[j]==-1)bl[j]=tot,(j+=d)%=n;
				++tot;
			}
		for(int i=0; i<n; ++i)fa[i]=i;
		for(int i=0; i<tot; ++i)fb[i]=i;
		Ins(S),pos[0]=S;
		for(int i=1; i<n; ++i) {
			int x=Findb(bl[c[i]]),y=Finda((c[i]+(x-bl[c[i]]+tot)%tot)%n);
			pos[i]=y,Ins(y);
		}
		int ans=0;
		for(int i=0; i<n; ++i)
			if(!vis[i]) {
				vis[i]=1;
				int now=i,bj=now==S,cnt=1;
				while(!vis[pos[now]]) {
					now=pos[now],vis[now]=1;
					++cnt,bj|=now==S;
				}
				if(bj)ans+=cnt-1;
				else if(cnt>1)ans+=cnt+1;
			}
		printf("%d\n",ans);
	}
	return 0;
}
```


---

## 作者：huangrenheluogu (赞：2)

没有并查集。

$(c_i+dx_i+y_i)\operatorname{mod}n$，容易想到是在环上以 $\gcd(n,d)$ 的步长走。

于是，总的序列被分成了 $\gcd(n,d)$ 个环，$y$ 控制是哪一个环上走，$x$ 控制走环的第几步。

对于第 $i(0\le i\lt \gcd(n,d))$ 个环，显然可以非常容易地处理出从 $i$ 开始走第 $j$ 次走到哪一个位置。

处理 $pos$ 的部分，尽量向后跳的环的数量尽可能少，跳了最小的 $y$ 步之后，要求在该环上向后跳的步数尽可能少。

发现这两个东西都可以用线段树/set 维护，每次找到后面第一个还有可以选择的 $x/y$ 的值。

注意，是 $x$ 要尽可能小，而不是 $xd\operatorname{mod}n$ 尽可能小，所以 set 应该记录 $x$ 而不是 $xd\operatorname{mod} n$，同时需要记录一个数它是所在环的第几个，方便跳下一个。

处理出 $pos$ 之后是简单的。

对于 $i\to pos_i$ 连边，显然可以分成若干个环。下面讨论中的环不考虑自环。

对于 $0$ 所在的环，大小为 $sz$，可以让 $0$ 一个一个换下去，这样需要 $sz-1$ 次操作。

对于没有 $0$ 的环，大小为 $sz$，需要把 $0$ 先换到这个环里，然后进行 $sz-1$ 次操作之后再把 $0$ 换出去，因此需要 $sz+1$ 次操作。

找到所有这样的环统计即可。

前面算 $pos$ 的复杂度为 $O(n\log n)$，后面计算答案的复杂度为 $O(n)$。

```cpp
#include<bits/stdc++.h>
#define int long long
#define mid (l + r >> 1)
#define ls (p << 1)
#define rs (p << 1 | 1)
using namespace std;
const int N = 1e5 + 5, inf = 0x3f3f3f3f3f3f3f3f;
int T, n, p, q, m, d, S, c[N], now, Gcd, ans;
int pos[N], minn[N << 2], tmp, to[N], sum;
bool vis[N];
set<int> s[N];
vector<int> vec[N];
inline void build(int p, int l, int r){
	if(l == r){
		minn[p] = !s[l].size() ? inf : l;
		return ;
	}
	build(ls, l, mid);
	build(rs, mid + 1, r);
	minn[p] = min(minn[ls], minn[rs]);
}
inline void modify(int p, int l, int r, int x){
	if(l == r){
		minn[p] = inf;
		return ;
	}
	if(mid >= x) modify(ls, l, mid, x);
	else modify(rs, mid + 1, r, x);
	minn[p] = min(minn[ls], minn[rs]);
}
inline int query(int p, int l, int r, int x, int y){
	if(x <= l && r <= y) return minn[p];
	int res = inf;
	if(mid >= x) res = min(res, query(ls, l, mid, x, y));
	if(mid < y) res = min(res, query(rs, mid + 1, r, x, y));
	return res;
}
inline void solve(){
	for(int i = 0; i < n; i++) vis[i] = 0;
	for(int i = 0; i < n; i++) vec[i].clear();
	for(int i = 0; i < n; i++) s[i].clear();
	scanf("%lld%lld%lld%lld%lld%lld", &n, &S, &q, &p, &m, &d);
	for(int i = 0; i < n; i++) to[i] = -1, vis[i] = 1;
	Gcd = __gcd(d, n);
	for(int i = 0; i < Gcd; i++){
		for(int j = i, k = 0; !(~to[j]); j = (j + d) % n, k++){
			to[j] = k;
			vec[i].push_back(j);
			if(j == S) continue ;
			s[i].insert(k);
			sum++;
		}
	}
//	for(int i = 0; i < n; i++){
//		if(to[i] == -1){
//			cerr << T << ' ' << i << endl;
//			exit(0);
//		}
//	}
	build(1, 0, Gcd - 1);
	for(int i = 1; i < n; i++) c[i] = (c[i - 1] * q + p) % m;
//	for(int i = 1; i < n; i++) printf("%lld %lld\n", i, c[i]);
	auto it = s[0].end();
	for(int i = 1; i < n; i++){
		now = c[i] % Gcd;
		now = query(1, 0, Gcd - 1, now, Gcd - 1);
		if(now == inf) now = minn[1];
		tmp = now - c[i] % Gcd;
		if(tmp < 0) tmp += Gcd;
		it = s[now].lower_bound(to[(c[i] + tmp) % n]);
		if(it == s[now].end()) it = s[now].begin();
		pos[i] = vec[now][(*it)];
		s[now].erase(it);	
		if(!s[now].size()) modify(1, 0, Gcd - 1, now);
	}
	pos[0] = S;
	ans = 0;
//	for(int i = 0; i < n; i++) printf("%lld %lld\n", i, pos[i]);
	for(int i = 0; i < n; i++){
		if(i == pos[i] || !vis[i]) continue ;
		tmp = 1;
		for(int j = pos[i]; j != i; j = pos[j]) tmp++, vis[j] = 0;
		if(i == 0) ans += tmp - 1;
		else ans += tmp + 1;
	}
	printf("%lld\n", ans);
}
signed main(){
//	freopen("data.in", "r", stdin);
//	freopen("code.out", "w", stdout);
	scanf("%lld", &T);
	while(T--){
		solve();
	}
	return 0;
}
```

---

## 作者：Tx_Lcy (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P3207)
## 思路
货真价实的神仙题，但是有许多像我一样的萌新看不懂 dalao 们的题解，于是我这里做一些人性化的解释，本人也是看了 @「QQ红包」 dalao 的题解才懂的。

首先我们看到这个柿子：$pos_i=(c_i+d \times x_i+y_i) \bmod m$，我们发现这个东西非常的奇妙啊，如果我们确定了 $c_i$ 和 $y_i$，$pos_i$ 的值只与 $x_i$ 有关，并且 $x_i$ 增加 $1$ $pos_i$ 就增加 $d$，显然，我们在进行最多 $m$ 次运算后会发现它神奇的出现了一个环。

然后我们考虑如何维护这个环，暴力枚举显然是会超时的，于是我们想到用并查集维护这个神奇的东西。

我们首先需要搞出如何表示一个环，由于 $d$ 是一个定值，所以只需要环的起点即可表示，我们不妨设环的起点为环中编号最小的那个点。

接下来我们就可以预处理出每个节点在哪个环里，时间复杂度 $O(n)$。

接下来考虑并查集的过程，设 $fa_i$ 表示距离 $i$ 最近的在环 $i$ 上的空节点，$man_i$ 表示 $i$ 所在的环是否装满了，接下来我们就可以很轻松的做第一问了。

第二问其实也不难，我们将 $i$ 与 $pos_i$ 连边，显然会出现若干个环，设某个环的大小为 $siz$。若这个环中存在 $0$，那么 $ans$ 加上 $siz-1$，否则 $ans$ 加上 $siz+1$。

## 代码

见其他题解。

---

## 作者：lhm_ (赞：2)

考虑题目所给出的式子：$pos_i=(c_i+dx_i+y_i) \bmod n$，当 $y_i$ 一定时，随着 $x_i$ 的增大，得到的值会出现循环，即形成环。不难发现对于 $x_i,y_i$ 的不同取值，$c_i+y_i$ 可以看作对应一个环和该环的起始位置，$x_i$ 对应到该环最终到达的位置。

因为要先保证 $y_i$ 最小，再保证 $x_i$ 最小，暴力的想法就是先枚举 $y_i$，再枚举 $x_i$，即先枚举是哪一个环，再枚举该环上的位置，判断是否该位置已经被占用，若没被占用就让当前的 $i$ 占用，若被占用就继续枚举。

发现可以用并查集来优化这两个枚举的过程，当一个环内的位置都被占用后，将其用并查集指向下一个环，当一个位置被占用后，将其用并查集指向下一个位置。这样的话，通过并查集就能快速的找到环和其对应的位置。

确定完 $pos$ 后，考虑如何计算最少步数。考虑到 $pos$ 为原序列的一个置换，将 $i$ 向 $pos_i$ 连边后，发现形成的图为若干个环，因此该置换是由若干个轮换组成的。考虑每一个轮换，当一个轮换中包含空位 $0$ 时，其对答案的贡献为轮换长度减一，因为除了空位 $0$ 以为，每个位置都要进行相应的移动，当一个轮换中不包含空位 $0$ 时，其对答案的贡献为轮换长度加一，因为其还需将空位 $0$ 移动进来和移动出去。

```cpp
#include<bits/stdc++.h>
#define maxn 100010
using namespace std;
typedef long long ll;
template<typename T> inline void read(T &x)
{
    x=0;char c=getchar();bool flag=false;
    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    if(flag)x=-x;
}
int T,n,s,q,p,m,d,ans,tot;
int bel[maxn],c[maxn],pos[maxn];
bool vis[maxn];
struct node
{
    int fa[maxn];
    int find(int x)
    {
        return fa[x]==x?x:fa[x]=find(fa[x]);
    }
}A,B;
void add(int x)
{
    int a=A.find(x),b=A.find((x+d)%n);
    if(a!=b) A.fa[a]=b;
    else B.fa[B.find(bel[x])]=B.find((bel[x]+1)%tot);
}
void clear()
{
    ans=tot=0;
    memset(bel,-1,sizeof(bel));
    memset(vis,0,sizeof(vis));
}
int main()
{
    read(T);
    while(T--)
    {
        clear(),read(n),read(s),read(q),read(p),read(m),read(d);
        for(int i=1;i<n;++i) c[i]=((ll)c[i-1]*q+p)%m;
        for(int i=0;i<n;++i)
        {
            if(bel[i]!=-1) continue;
            int x=i;
            while(bel[x]==-1) bel[x]=tot,x=(x+d)%n;
            tot++;
        }
        for(int i=0;i<n;++i) A.fa[i]=i,c[i]%=n;;
        for(int i=0;i<tot;++i) B.fa[i]=i;
        add(s),pos[0]=s;
        for(int i=1;i<n;++i)
        {
            int p1=B.find(bel[c[i]]),p2=A.find((c[i]+(p1-bel[c[i]]+tot)%tot)%n);
            pos[i]=p2,add(p2);
        }
        for(int i=0;i<n;++i)
        {
            if(vis[i]||i==pos[i]) continue;
            int x=i,len=0;
            while(!vis[x]) vis[x]=true,x=pos[x],len++;
            ans+=i?len+1:len-1;
        }
        printf("%d\n",ans);
    }
    return 0;
}
```

---

## 作者：zzw4257 (赞：2)

### 题意
>有一些参数:$d$,序列$\{c_i\}$
有$n$个位置($[0,n)$),初始空位为$0$,要求结束空位为$s$
移动方法如下，对$i$号棋子可以构造参数$x,y$,使其落到$pos_i=(c_i+dx+y)\pmod{n}$号位置
求最少移动次数

### Solution
首先本题其实不是最值问题而是优化问题


最值策略很ZZ，就是找到$y$尽量小时$x$尽量小的空位
这样做实际上是$y$确定$x$变动跳的环而$x$找$y$对应环的空位子

考虑用两个并查集维护环上最近空位，以及环之间最近非满环

对算出的$pos_i$,问题变为一个许多个置换用最少轮换来拼凑

考虑大小为$cnt$的一个置换若其中有结束空位则只需要$cnt-1$次轮换

若无空位即有$1$(某一个换出空位$0$)+$cnt-1$(缺一个内部换)+$1$(空位换回来)=$cnt+1$次轮换

```cpp
#include<bits/stdc++.h>
#define re register
#define N 100001
#define INF 0x3f3f3f3f
using namespace std;
typedef long long ll;
int fa[N],pos[N],Case,n,q,p,m,d,s,ans;
ll c[N];
char vis[N];
inline int getf(re int x){return x==fa[x]?x:fa[x]=getf(fa[x]);}
int main(void){
	re int i,tot,last,y;re char flag;
	scanf("%d",&Case);
	while(Case--){
		cin>>n>>s>>q>>p>>m>>d;
		for(i=0;i<n;++i)fa[i]=i,vis[i]=0;
		vis[pos[0]=s]=1,fa[s]=(s+d)%n;
		for(i=1;i<n;++i)c[i]=(1ll*c[i-1]*q+p)%m;
		for(i=1;i<n;++i){
            y=0;while(vis[getf((y+c[i])%n)])++y;
            vis[pos[i]=getf((y+c[i])%n)]=1;
            fa[pos[i]]=getf((pos[i]+d)%n);
		}
		memset(vis,0,sizeof vis),ans=0;
		for(i=0;i<n;++i)if(!vis[i]&&pos[i]!=i){
			last=i,tot=0,flag=0;
			while(!vis[last]){
				if(!last)flag=1;
				vis[last]=1;last=pos[last];++tot;
			}
			flag?ans+=(tot-1):ans+=(tot+1);
		}
		printf("%d\n",ans);
	}
	return 0;
}
```

---

## 作者：bztMinamoto (赞：2)

[传送门](https://www.luogu.org/problemnew/show/P3207)

完了题目看错了……还以为所有的$x,y$都要一样……结果题解都没看懂……

先考虑如果已经求出了所有的$pos$要怎么办，那么我们可以把$0$也看做是一个箱子，然后最后每个箱子都在一个环里。

如果是自环无视，如果$0$在这个环里就用$0$做每次的中介把所有都换到正确的位置上，总共要$L-1$次，否则的话把$0$换进环里然后换完之后再换出去，总共要换$L+1$次

我们发现随着$x$的增大，$pos$肯定是形成一个环的……随意就枚举$y$的值，然后看看这个环上还有没有空位可以放，有的话就放进去。总之就是用并查集维护，每次放完之后指向下一个能放的位置，即$x+D$
```
//minamoto
#include<bits/stdc++.h>
#define R register int
#define fp(i,a,b) for(R i=a,I=b+1;i<I;++i)
#define fd(i,a,b) for(R i=a,I=b-1;i>I;--i)
using namespace std;
char buf[1<<21],*p1=buf,*p2=buf;
inline char getc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}
int read(){
    R res,f=1;char ch;
    while((ch=getc())>'9'||ch<'0')(ch=='-')&&(f=-1);
    for(res=ch-'0';(ch=getc())>='0'&&ch<='9';res=res*10+ch-'0');
    return res*f;
}
const int N=1e5+5;
int n,S,Q,P,M,D,x,y,ans,cnt,tot,fa[N],C[N],pos[N];bool vis[N];
int find(R x){return fa[x]==x?x:fa[x]=find(fa[x]);}
void merge(R x,R y){fa[find(x)]=find(y);}
void solve(){
	n=read(),S=read(),Q=read(),P=read(),M=read(),D=read();
	fp(i,1,n-1)C[i]=(1ll*C[i-1]*Q+P)%M;fp(i,0,n-1)fa[i]=i;
	memset(vis,0,sizeof(vis)),pos[0]=S,vis[S]=true,merge(S,(S+D)%n);
	fp(i,1,n-1){
		x=find(C[i]%n),y=0;
		while(vis[x])++y,x=find((C[i]+y)%n);
		pos[i]=x,vis[x]=1,merge(x,(x+D)%n);
	}
	memset(vis,0,sizeof(vis)),ans=cnt=0;
	fp(i,0,n-1)if(!vis[i]){
		tot=0,x=i;
		while(!vis[x])++tot,vis[x]=true,x=pos[x];
		if(tot>1)ans+=tot,++cnt;
	}ans+=pos[0]?cnt-2:cnt;printf("%d\n",ans);
}
int main(){
//	freopen("testdata.in","r",stdin);
	int T=read();
	while(T--)solve();
	return 0;
}
```

---

## 作者：huhangqi (赞：1)

题目的变量很多，看起来很恶心。

所以先整理一下每个字母和数组的用处。

+ $p,q,m$ 用来确定数组 $c$

+ $c$ 用来改变每个位置的选择，$x,y$可以给每个数自己选择，配合 $d$ 得到最终位置

+ $s$ 表示空着的位置

+ $n$ 表示位置的数量

+ $pos$ 代表最终的位置

其中只有 $x,y$ 给我们自己选择，然后我们需要让 $y$ 和 $x$ 的字典序最小，然后求最短步数。

显然主要问题在于怎样才能在满足条件的情况下构造出 $y$ 和 $x$ 的序列。

位置的式子为 $c_i+x_id+y_i$，由于我们希望优先增加 $x$ 而不是增加 $y$，所以我们就会发现不断增加 $x$ 的值会形成一个环，而在几个环之间的位置转化则需要改变 $y$ 的值。

那么我们思路就很明确了，先在这个环中寻找位置，如果有，那么选择最近的，否则选择下一个环，一次类推。

那么只需要考虑怎么优化这个过程即可，直接通过并查集优化，将使用了的位置连向下一个空位，如果没有空位了，那么就选择下一个环。

由于有双变量，我们使用两个并查集，分别存储在同一个环上的点之间的关系以及两个环之间的关系。

那么这样就可以得到最优的序列了。

最后求解答案，如果几个互相影响的点其中包含空位，那么直接按照顺序直接移动到自己的位置即可，那么只需要计算每一个物品移动一次即可，而如果没有空位，那么先将一个移动到空位，再进行移动。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n,s,q,p,m,d,c[100005],h[100005],id,w[100005];
bool vis[100005];
struct BCJ{
	int fa[100005];
	void init(){
		for(int i=0;i<=n;i++)fa[i]=i;
	}
	int find(int x){
		if(x==fa[x])return x;
		return fa[x]=find(fa[x]);
	}
}b1,b2;
void del(int x){
	int tmp1=b1.find(x),tmp2=b1.find((x+d)%n);
	if(tmp1!=tmp2){
		b1.fa[tmp1]=tmp2;
	}
	else {
		tmp1=b2.find(h[x]),tmp2=b2.find((h[x]+1)%id);
		b2.fa[tmp1]=tmp2;
	}
}
signed main(){
	cin>>T;
	while(T--){
		cin>>n>>s>>q>>p>>m>>d;
		b1.init(),b2.init();
		d%=n;
		for(int i=1;i<=n;i++)c[i]=(c[i-1]*q+p)%m;
		for(int i=0;i<n;i++)h[i]=-1;
		id=0;
		for(int i=0;i<n;i++){
			if(h[i]!=-1)continue;
			for(int j=i;h[j]==-1;j=(j+d)%n)h[j]=id;
			id++;
		}
		del(s);
		w[0]=s;
		for(int i=1;i<n;i++){
			c[i]%=n;
			int tmp=b2.find(h[c[i]]);
			int tmp2=b1.find((c[i]+(tmp-h[c[i]]+id)%id)%n);
			w[i]=tmp2;
			del(tmp2);
		}
		int ans=0;
		memset(vis,0,sizeof(vis));
		for(int i=0;i<n;i++){
			if(vis[i])continue;
			vis[i]=1;
			bool fl=0;
			int cnt=1,tmp=i;
			if(tmp==s)fl=1;
			while(!vis[w[tmp]]){
				tmp=w[tmp];
				vis[tmp]=1;
				cnt++;
				if(tmp==s)fl=1;
			}
			if(fl)ans+=cnt-1;
			else if(cnt!=1)ans+=cnt+1;
		}
		cout<<ans<<endl;
	}
	return 0;
}
``````

---


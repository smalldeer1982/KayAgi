# 上帝造题的七分钟 2 / 花神游历各国

## 题目背景

XLk 觉得《上帝造题的七分钟》不太过瘾，于是有了第二部。


## 题目描述

"第一分钟，X 说，要有数列，于是便给定了一个正整数数列。

第二分钟，L 说，要能修改，于是便有了对一段数中每个数都开平方(下取整)的操作。

第三分钟，k 说，要能查询，于是便有了求一段数的和的操作。

第四分钟，彩虹喵说，要是 noip 难度，于是便有了数据范围。

第五分钟，诗人说，要有韵律，于是便有了时间限制和内存限制。

第六分钟，和雪说，要省点事，于是便有了保证运算过程中及最终结果均不超过 $64$ 位有符号整数类型的表示范围的限制。

第七分钟，这道题终于造完了，然而，造题的神牛们再也不想写这道题的程序了。"

——《上帝造题的七分钟·第二部》

所以这个神圣的任务就交给你了。


## 说明/提示

对于 $30\%$ 的数据，$1\le n,m\le 10^3$，数列中的数不超过 $32767$。

对于 $100\%$ 的数据，$1\le n,m\le 10^5$，$1\le l,r\le n$，数列中的数大于 $0$，且不超过 $10^{12}$。

## 样例 #1

### 输入

```
10
1 2 3 4 5 6 7 8 9 10
5
0 1 10
1 1 10
1 1 5
0 5 8
1 4 8```

### 输出

```
19
7
6```

# 题解

## 作者：XG_Zepto (赞：226)

## 思路

[首发于个人博客。](https://www.xgzepto.cn/post/bzoj-3038)


我不会支持区间开方的数据结构，所以我选择暴力单点修改，树状数组区间查询。

因为1e12的数开方6次就变成了1，所以需要修改的次数实际上很少，用并查集可以跳过小于等于1的数，然后。。。树状数组单点修改即可。没开O2，最慢的点大概就是250ms，还是比较快的。

## 代码

非常短。。。

树状数组两行搞定，并查集一行搞定。

修改的时候判断一下是不是小于等于1，是的话就更新一下fa数组，具体看一下注释。

```
#include <bits/stdc++.h>
#define maxn 100100
#define ll long long
using namespace std;
ll tree[maxn*4],a[maxn];int fa[maxn],m,n,q,l,r,t;
int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}//并查集，路径压缩
void add(int x,ll y){while(x<=n)tree[x]+=y,x+=(x&-x);}
ll qry(int x){ll r=0;while(x)r+=tree[x],x-=(x&-x);return r;}
int main(){
	scanf("%d",&n);for (int i=1;i<=n;i++)
	scanf("%lld",&a[i]),add(i,a[i]),fa[i]=i;scanf("%d",&m);fa[n+1]=n+1;
	while(m--){scanf("%d%d%d",&q,&l,&r);if (l>r) swap(l,r); 
		if (q==1) printf("%lld\n",qry(r)-qry(l-1));
		else for (int i=l;i<=r;add(i,(t=(int)sqrt(a[i]))-a[i]),a[i]=t,fa[i]=(a[i]<=1)?i+1:i,i=(find(i)==i)?i+1:fa[i]);
	}
    //上面这行信息量很大。。。做了单点修改的操作，a数组保存了每个点的实际值，当a[i]<=1的时候，直接跳到下一个点，结束。可以手算一下，就能很快理解了。
}
```

---

## 作者：SuperJvRuo (赞：115)

这道题的关键在于，sqrt(1)==1


也就是说，如果一个区间的最大值为1，我们就可以直接跳过这段区间的修改。只有最大值大于1时才有修改的必要。


而题中的数值大小范围在(0,1e12)之间。

我们可以用计算器得知：

![](https://cdn.luogu.com.cn/upload/pic/13485.png)

每个数至多六次开平方便可得到1


每次暴力修改复杂度为logn，总复杂度nlogn。数据范围只有1e5，因此不用在意常数的影响。


```cpp
#include<cstdio>
#include<cctype>
#include<cstring>
#include<cmath>
#define LL long long

const int INF = 1000000010;

LL int Read()//快读
{
    LL x = 0;char c = getchar();
    while(!isdigit(c))
        c = getchar();
    while(isdigit(c))
    {
        x = (x << 3) + (x << 1) + c -'0';
        c = getchar();
    }
    return x;
}

struct Node
{
    int l, r;
    LL sum, maxn;
}seg_tree[400000];  

void Update(int p)//向上修改
{
    seg_tree[p].sum = seg_tree[p << 1].sum + seg_tree[p << 1 | 1].sum;
    seg_tree[p].maxn = seg_tree[p << 1].maxn > seg_tree[p << 1 | 1].maxn ? seg_tree[p << 1].maxn : seg_tree[p << 1 | 1].maxn;
}

LL num[100005];

void Build(int p, int l, int r)
{
    seg_tree[p].l = l;
    seg_tree[p].r = r;
    if(l == r)
    {
        seg_tree[p].sum = seg_tree[p].maxn = num[l];
        return;
    }
    int mid = l + r >> 1;
    Build(p << 1, l, mid);
    Build(p << 1 | 1, mid + 1, r);
    Update(p);
}

void Change(int p, int l, int r)
{
    if(seg_tree[p].l == seg_tree[p].r)
    {
        seg_tree[p].sum = sqrt(seg_tree[p].sum);
        seg_tree[p].maxn = sqrt(seg_tree[p].maxn);
        return;
    }
    int mid = seg_tree[p].l + seg_tree[p].r >> 1;
    if(l <= mid && seg_tree[p << 1].maxn > 1)
        Change(p << 1, l, r);
    if(mid < r && seg_tree[p << 1 | 1].maxn > 1)
        Change(p << 1 | 1, l, r);
    
    //当maxn > 1时暴力修改
    
    Update(p);
}

LL Query(int p, int l, int r)
{
    if(l <= seg_tree[p].l && seg_tree[p].r <= r)
        return seg_tree[p].sum;
    int mid = seg_tree[p].l + seg_tree[p].r >> 1;
    LL ans = 0;
    if(l <= mid)
        ans += Query(p << 1,l,r);
    if(mid < r)
        ans += Query(p << 1 | 1,l,r);
    return ans;
}

int main()
{
    int n = Read();
    for(int i = 1; i <= n; ++i)
        num[i] = Read();
    Build(1, 1, n);
    
    int m = Read(), opt, l, r;
    while(m--)
    {
        opt = Read(), l = Read(), r = Read();
        if(l > r)
        {
            int swap = l;
            l = r;
            r = swap;
        }
        if(opt == 0)
            Change(1,l,r);
        else
            printf("%lld\n",Query(1,l,r));
    }
    return 0;
}
```

---

## 作者：Gary818 (赞：85)

### [P4145花神游历各国](https://www.luogu.org/problem/P4145)  
 **时隔4个月再看这道题，瞬间神清其爽，理解了不少**       
排版。。。没问题吧QAQ  
主要说下本人对线段树在不同阶段的理解，希望对后来的OIer们有所帮助  
简单说下A这道题的历程  
3.10 开始着手这道题，纯暴力水40分  
3.12 写了快读，开了O2试图卡过去（当时好蠢  
3.13 乱搞一通，弄成10分，彻底放弃  
4.01 于是时间来到了愚人节，第一发直接爆0，最后借助题解一脸懵逼的抄过了  


然后，就一直放到了今天，说实话，最近两天再肝线段树专题，所以对线段树又有了新的理解和认识  

这个题在线段树的具体分类上叫做**小清新线段树**，虽然我也不知道为啥要这样叫。小清新线段树的概念是由 jiry_2 提出的,区别于**zkw(重口味)** 线段树命名。   
定义是这样的：小清新线段树可以归为一类结合时间复杂度分析以及懒标记应用的非传统线段树。  
反正我理解成了带着剪枝的普通线段树。  
具体的，小清新线段树除了传统的zkw线段树操作，还可以维护区间整除、区间mod数、把数变成欧拉函数等各种骚操作。  
zkw和小清新最大的区别：前者常数小、跑的快，但是后者要通过势能分析确定时间复杂度，从而确定代码怎么写（跑的也不慢，但是要因题而异qwq  



具体来看题  
### [P4145花神游历各国](https://www.luogu.org/problem/P4145)  
对于这道题，有个唯一的考点，就是在如何取根号上，由于期间信息无法快速更新，所以无法使用延迟标记lazytag**（哦，这太可怕了QAQ）** ，所以大家都注意到了$ 10^9 $最多开5次就不变了，所以我们可以考虑每次把修改暴力递归下去，直到当前区间已经全是0或1为止，然后return就好了。    
似乎这题目前只有这一种解法，所以说不是非常的新鲜，**本题解主要就是记录一种思想和历程，学习一种结构，一定要搞清楚原理后再回头看看，有时候会柳暗花明又一村**   
关于代码嘛，大家的其实都大同小异，喏   
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
#define int long long
#define ls k<<1
#define rs k<<1|1
using namespace std;

const int maxn=1000005;
int n,m;
int a[maxn],maxx[maxn<<2],sum[maxn<<2];

inline int read(){
    int x=0,w=1;
    char ch=getchar();
    for(;ch>'9'||ch<'0';ch=getchar()) if(ch=='-') w=-1;
    for(;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';
    return x*w;
}

inline void up(int k){
    maxx[k]=max(maxx[ls],maxx[rs]);
    sum[k]=sum[ls]+sum[rs];
}

inline void build(int k,int l,int r){
    if(l==r){
        sum[k]=maxx[k]=a[l];
        return;
    }
    int mid=(l+r)>>1;
    build(ls,l,mid);
    build(rs,mid+1,r);
    up(k);
}

inline void change(int k,int l,int r,int L,int R){
    if(l==r && l>=L && r<=R){
        sum[k]=maxx[k]=sqrt(sum[k]);
        return ;
    }   
    int mid=(l+r)>>1;
    if(L<=mid && maxx[ls]>1) change(ls,l,mid,L,R);
    if(mid<R && maxx[rs]>1) change(rs,mid+1,r,L,R);
    up(k);
}

inline int query(int k,int l,int r,int L,int R){
    if(L<=l && r<=R) return sum[k];
    int mid=(l+r)>>1;
    int ans=0;
    if(L<=mid) ans+=query(ls,l,mid,L,R);
    if(mid<R) ans+=query(rs,mid+1,r,L,R);
    return ans;
}

signed main(){
        n=read();
        memset(sum,0,sizeof sum);
        memset(maxx,0,sizeof maxx);
        for(int i=1;i<=n;i++) a[i]=read();
        build(1,1,n);
        m=read();
        while(m--){
            int op=read(),l=read(),r=read();
            if(l>r) swap(l,r);
            if(op==0) change(1,1,n,l,r);
            else cout<<query(1,1,n,l,r)<<endl;
        }
        cout<<endl;
}
```  
线段树是个非常美妙的东东，日均一棵树，有易于身心健康

---

## 作者：MloVtry (赞：39)

分块让人快乐。

当a[i]=1时，开方便不再有意义。

加上每个数不大于le12，所以每个数至多被开方6次。

直接分块暴力，维护区间和和一个标记表示是否每个元素都为1。

如果每次区间开方只不涉及完整的块，不超过2√n个元素，直接暴力即可。

如果涉及了一些完整的块，这些块经过几次操作以后就会都变成 1，区间修改时跳过那些全为 1 的块即可。

体感一下复杂度和每个元素被开方次数有关，所以是可行的。

```cpp
#define ll long long
#include<iostream>
#include<cstdio>
#define N 100005
#include<cmath>
#define B 400
using namespace std;
int bg[N],l[N],r[N],fl[N],n,m;
ll a[N],sum[N];
void Turn()
{
    int u,v;scanf("%d%d",&u,&v);if(u>v) swap(u,v);
    if(bg[u]==bg[v])
    {
        if(fl[bg[u]]) return;
        for(int i=u;i<=v;++i) sum[bg[u]]-=a[i],a[i]=sqrt(a[i]),sum[bg[u]]+=a[i];
        if(sum[bg[u]]==r[bg[u]]-l[bg[u]]+1) fl[bg[u]]=1;
    }
    else
    {
        for(int i=bg[u]+1;i<bg[v];++i)
        {
            if(fl[i]) continue;
            for(int j=l[i];j<=r[i];++j) sum[i]-=a[j],a[j]=sqrt(a[j]),sum[i]+=a[j];
            if(sum[i]==r[i]-l[i]+1) fl[i]=1;
        }
        for(int i=u;i<=r[bg[u]];++i) sum[bg[u]]-=a[i],a[i]=sqrt(a[i]),sum[bg[u]]+=a[i];
        for(int i=l[bg[v]];i<=v;++i) sum[bg[v]]-=a[i],a[i]=sqrt(a[i]),sum[bg[v]]+=a[i];
        if(sum[bg[u]]==r[bg[u]]-l[bg[u]]+1) fl[bg[u]]=1;
        if(sum[bg[v]]==r[bg[v]]-l[bg[v]]+1) fl[bg[v]]=1;
    }
}
void Ask()
{
    int u,v;ll ans=0;scanf("%d%d",&u,&v);if(u>v) swap(u,v);
    if(bg[u]==bg[v])
    {
        for(int i=u;i<=v;++i) ans+=a[i];
    }
    else
    {
        for(int i=bg[u]+1;i<bg[v];++i) ans+=sum[i];
        for(int i=u;i<=r[bg[u]];++i) ans+=a[i];
        for(int i=l[bg[v]];i<=v;++i) ans+=a[i];
    }
    printf("%lld\n",ans);
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;++i)
    {
        scanf("%lld",&a[i]);
        bg[i]=i/B;
        l[bg[i]]=!l[bg[i]]?i:l[bg[i]];
        r[bg[i]]=i;sum[bg[i]]+=a[i];
    }scanf("%d",&m);
    for(int i=1;i<=m;++i)
    {
        int fl;scanf("%d",&fl);
        if(fl) Ask();
        else Turn();
    }
    return 0;
}
```

---

## 作者：Plus_Ultra (赞：35)

一. 前言

上课时老师讲了这道题，用的是树状数组+并查集，看一楼大佬用的也是这种方法，但是因为我太弱了，没有看懂（也有点晃眼），就写了一发题解来加深记忆，同时希望可以帮到和我一样的萌新.

二. 具体解法

- 通过观察可以得到，在此题数据范围内一个数开方 6 次就一定会变成 1 ，我们就没必要再对这个数开方了，可以利用并查集直接跳过.

- 我们用并查集维护这样的东西：

      对于第 i 个数 a[ i ],当 a[ i ] 不等于 1 时，他的祖先是他自己,即 f[ i ] = i,当 a[ i ] = 1 时，f[ i ] = 下一个不等于 1 的数的位置 j （i < j <=n+1）,这里要注意 f[ n + 1 ] = n + 1.
      
      然后我们在 l ~ r 区间内寻找祖先是自己的数修改即可，具体可用指针不断更新，find 找祖先.
      
- 然后我们用树状数组维护即可.

三. 代码

加了个快读没开 O2 最慢点 45ms, 开 O2 最慢点29ms，代码去掉空行后40来行，也是比较短了.

下面上代码（我知道各位大佬也不需要代码）：

```
#include<iostream>
#include<cmath>

#define LL long long
#define N 100010

using namespace std;

LL c[N<<2],a[N],f[N],n,m,x,l,r,t;

LL find(LL x)
{
	return f[x]==x?x:f[x]=find(f[x]);//一定路径压缩，我T了七八次。。。 
}

void add(LL x,LL y)
{
	for(;x<=n;x+=x&-x)  c[x]+=y;
}

LL ask(LL x)
{
	LL res=0;
	for(;x;x-=x&-x)  res+=c[x];
	return res;
}//普通的树状数组add和ask函数 

int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		add(i,a[i]);
		f[i]=i;
	}//初始化 
	f[n+1]=n+1;//因为n要合并到n+1 
	
	cin>>m;
	for(int i=1;i<=m;i++)
	{
		cin>>x>>l>>r;
		if(l>r)  swap(l,r);//交换 
		if(x)  cout<<ask(r)-ask(l-1)<<'\n';
		else while(l<=r)//这里直接用l模拟指针 
		{
			LL t=(LL)sqrt(a[l]);//要减少a[l]-t
			add(l,t-a[l]);a[l]=t;//更新 
			f[l]=a[l]<=1?l+1:l;//开方到1后直接把父亲更改为下一个数 
			l=f[l]==l?l+1:find(f[l]);//如果这个数没有开方到1，到下一个数，否则找下一个为1的数 
		}
	}
	
	return 0;
}
```

###  _[Plus Ultra!](https://www.luogu.org/blog/OnePunchManGO/)_ 

---

## 作者：Gypsophila (赞：20)

10分钟竟然切了道蓝题，开森

------------
**题目大意**：

一个序列，支持区间开方与求和操作。

**算法**：线段树实现**开方修改**与区间求和

**分析**：
-  显然，这道题的求和操作可以用线段树来维护
- 但是如何来实现区间开方呢
- 大家有没有这样的经历：玩计算器的时候，**把一个数疯狂的按开方，最后总会变成 $1$，之后在怎样开方也是 $1$ ($\sqrt1=1$)**
- 同样的，$\sqrt0=0$
- **所以，只要一段区间里的所有数全都 $\leq 1$ 了，便可以不去修改它**

**实现**：
- 线段树维护区间和 $sum$ 与最大值 $Max$
- 在修改过程中，只去修改 $Max > 1$ 的区间
- 到了叶子节点对$sum$和$Max$进行开方就行了

**复杂度**：
- 每个数 $\leq 10 ^ {12}$,所以至多开方$6$次便可以得到$1$
- 每次操作是 $\log n$的，总复杂度$O(n \log n)$

**注意事项**：
- **请使用long long**
- **可能 $l > r$**~~(把我坑了)~~

**代码**:

```cpp
#include <iostream>
#include <cstdlib>
#include <cmath>
#include <cstdio>

using namespace std;
typedef long long LL;
const int MAXN = 100100;

int n, m;
int cnt;
LL a[MAXN];
struct node
{
	int left, right;
	LL s, Max;
	node *ch[2];
}pool[MAXN << 2], *root;

inline void pushup(node *r)
{
	r->s = r->ch[0]->s + r->ch[1]->s;
	r->Max = max(r->ch[0]->Max, r->ch[1]->Max);
}

inline void Build_Tree(node *r, int left, int right)
{
	r->left = left;
	r->right = right;
	if(left == right)
	{
		r->s = r->Max = a[left];
		return ;
	}
	int mid = (left + right) / 2;
	node *lson = &pool[++cnt];
	node *rson = &pool[++cnt];
	r->ch[0] = lson;
	r->ch[1] = rson;
	Build_Tree(lson, left, mid);
	Build_Tree(rson, mid + 1, right);
	pushup(r);
}

inline void change(node *r, int left, int right)
{
	if(r->left == r->right)
	{
		r->s = sqrt(r->s);
		r->Max = sqrt(r->Max);
		return ;
	}
	
	int mid = (r->left +r-> right) / 2;
	if(left <= mid && r->ch[0]->Max > 1) change(r->ch[0], left, right);
	if(mid < right && r->ch[1]->Max > 1) change(r->ch[1], left, right);
	pushup(r);
}

inline LL query(node *r, int left, int right)
{
	if(r->left == left && r->right == right)
		return r->s;
	if(r->ch[0]->right >= right) return query(r->ch[0], left, right);
	else if(r->ch[1]->left <= left) return query(r->ch[1], left, right);
	else
		return query(r->ch[0], left, r->ch[0]->right) + 
		       query(r->ch[1], r->ch[1]->left, right);
}
int main()
{
    scanf("%d", &n);
    root = &pool[0];
    for(int i = 1; i <= n; i++) scanf("%lld", &a[i]);
    scanf("%d", &m);
    Build_Tree(root, 1, n);
    for(int i = 1; i <= m; i++)
    {
    	int opt, l, r;
    	scanf("%d%d%d", &opt, &l, &r);
    	if(l > r) swap(l, r);
    	if(opt) printf("%lld\n", query(root, l, r));
    	else change(root, l, r);
	}
 	return 1; //防抄
}
```





---

## 作者：tcswuzb (赞：18)

本蒟蒻对线段树的又一次透彻

有一次考试考的这道题

蒟蒻信心慢慢的打了这篇代码

```cpp
#pragma GCC optimize(3)
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<cstdlib>
#include<string>
#include<queue>
#include<map>
#include<stack>
#include<list>
#include<set>
#include<deque>
#include<vector>
#include<ctime>
#define ll long long
#define inf 0x7fffffff
#define N 500008
#define IL inline
#define M 1008611
#define D double
#define ull unsigned long long
#define R register
using namespace std;
template<typename T>void read(T &a)
{
    T x=0,f=1;char ch=getchar();
    while(!isdigit(ch))
    {
        if(ch=='-')f=0;ch=getchar();
    }
    while(isdigit(ch))
    {
        x=(x<<1)+(x<<3)+ch-'0';ch=getchar();
    }
    a=f?x:-x;
}
/*-------------OI使我快乐-------------*/
ll num[N];
ll n,m;
IL void xiugai(ll le,ll ri){
	if(le==ri) {
		num[le]=floor(sqrt(num[le]));
	    return;
	}
	ll mid=(le+ri)>>1;
	xiugai(le,mid);xiugai(mid+1,ri);
}
IL ll qury(ll le,ll ri){
	if(le==ri) return num[le];
	ll mid=(le+ri)>>1;
	return qury(le,mid)+qury(mid+1,ri);
}
int main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
    read(n);
    for(R ll i=1;i<=n;++i) read(num[i]);
    read(m);
    while(m--){
    	ll key,xi,yi;
    	read(key);read(xi);read(yi);
    	if(xi>yi) swap(xi,yi);
    	if(key==0) xiugai(xi,yi);
    	else printf("%lld\n",qury(xi,yi));
	}
//	fclose(stdin);
//	fclose(stdout);
	return 0;
}

```

当时蒟蒻天真的以为这篇代码会打出二分logn的复杂度

可是现实 [十分残酷](https://www.luogu.org/record/show?rid=10416051)

只拿了暴力分 只好去查询正解

# 正解 ： 玄学线段树


-----------------------------------吐槽时间--------------------------------------

首先，一个小定理 ：

0×0=0 ∴sqrt(0)=0

1×1=1 ∴sqrt(1)=1

所以 但一个数列中的数值 只是1或者0时 直接pass

而一个数（<=10^12） 顶多开方加下取整不到10次

就为成为这个完美的数值

∴我们给线段树维护的序列 打上标记

# 全是 1 或 0 就直接pass

暴力开方到目标状态不会耗费太多时间

完美AC

# CODE：

```cpp
#pragma GCC optimize(3)
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<cstdlib>
#include<string>
#include<queue>
#include<map>
#include<stack>
#include<list>
#include<set>
#include<deque>
#include<vector>
#include<ctime>
#define ll long long
#define inf 0x7fffffff
#define N 500008
#define IL inline
#define M 1008611
#define D double
#define ull unsigned long long
#define R register
using namespace std;
template<typename T>void read(T &a)
{
    T x=0,f=1;char ch=getchar();
    while(!isdigit(ch))
    {
        if(ch=='-')f=0;ch=getchar();
    }
    while(isdigit(ch))
    {
        x=(x<<1)+(x<<3)+ch-'0';ch=getchar();
    }
    a=f?x:-x;
}
/*-------------OI使我快乐-------------*/
struct node{
	ll num;
	bool flag;//序列是否为目标序列的标记
}tre[N];
ll n,m;
ll zhi[N];
IL void build(ll si,ll le,ll ri){
	if(le==ri){
		tre[si].num=zhi[le];
		tre[si].flag=(tre[si].num==1 || tre[si].num==0);
		return;
	}
	ll mid=(le+ri)>>1;
	build(si<<1,le,mid);build(si<<1|1,mid+1,ri);
	tre[si].num=tre[si<<1].num+tre[si<<1|1].num;
	tre[si].flag=tre[si<<1].flag&tre[si<<1|1].flag;//标记维护
}
IL void update(ll si,ll lenow,ll rinow,ll le,ll ri){
	if(tre[si].flag) return;//是则直接pass
	if(lenow==rinow) 
	{
		tre[si].num=floor(sqrt(tre[si].num));
		tre[si].flag=(tre[si].num==1 || tre[si].num==0);
		return;
	}
	ll mid=(lenow+rinow)>>1;
	if(le<=mid) update(si<<1,lenow,mid,le,ri);
	if(mid<ri) update(si<<1|1,mid+1,rinow,le,ri);
	tre[si].num=tre[si<<1].num+tre[si<<1|1].num;
	tre[si].flag=tre[si<<1].flag&tre[si<<1|1].flag;//维护标记
}
IL ll qury(ll si,ll lenow,ll rinow,ll le,ll ri){
	if(le<=lenow && rinow<=ri){
		return tre[si].num;
	}
	ll mid=(lenow+rinow)>>1,ans=0;
	if(le<=mid) ans+=qury(si<<1,lenow,mid,le,ri);
	if(mid<ri) ans+=qury(si<<1|1,mid+1,rinow,le,ri);
	return ans;
}
int main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
    read(n);
    for(R int i=1;i<=n;++i) read(zhi[i]);
    build(1,1,n);
	read(m);
	while(m--){
		ll key,xi,yi;
		read(key);read(xi);read(yi);
		if(xi>yi) swap(xi,yi);
		if(key==0) update(1,1,n,xi,yi);
		if(key==1) printf("%lld\n",qury(1,1,n,xi,yi));
		
	}
//	fclose(stdin);
//	fclose(stdout);
	return 0;
}

```

NOIP 2018 即将到来 

衷心祝愿各位 RP++ 全场AK

---

## 作者：Out_of_control (赞：17)

#  _**本蒟蒻接触OI半年来第一篇题解**_ 


------------
##  _**好吧，进入正题————分块裸题**_ 

------------
相同的题[数列分块入门 5](https://loj.ac/problem/6281)
&[GSS4](https://www.luogu.com.cn/problem/SP2713)


------------
这道题的话，其他很多数据结构也能解决，比如线段树什么的，但我们考虑分块做法。~~（因为代码简单）~~


----------
# _**分块**_ ：
将原序列处理成若干个小块，目的是尽量地达到处理和询问之间的平衡。每次修改时如果是成块的就可以进行打mark（标记）等操作，否则暴力修改，每次查询时成块的可以做到O(1)或O(logn)查询，其余直接暴力查询。

## 再来看本题
求和操作不难实现只需要统计每块内数的总和

关键就是开方操作了，因为你无法对一整块进行开方操作。

但是，我们考虑到由于开方是向下取整，对于一个数，开方几次后就
变成了1，从后再开方就没有意义了，那么我们只要对一整块都为1的
块打一下标记，这些数以后不用进行开方操作，其余的暴力处理即可。

其实不难发现，即使是开方，操作量也不是很大 就拿最大值 2^31来
说 开5次平方就已经小于2接近1了 所以当一个数已经小于等于1的时
候 开方也没有什么意义了（向下取整不是0就是1 1^n=1 0^n=0） 同
理，我们参照上面的思路开多一个数组标记这个块内的数是不是全都
小于等于1了，是的话直接不用更新就ok

具体实现看代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int maxn=1e5+5;
ll n,m,N,l,r,c,op;
ll s[maxn];ll ans;
int pos[maxn];//标记数所在的块 
bool vis[maxn];//标记当前块是否需要继续开方
ll sum[maxn];//当前块内数的总和 

void check_sqrt(int p)//判断
{
	if(vis[p]>0)
	return;
	vis[p]=1;sum[p]=0;
	for(int i=(p-1)*m+1;i<=p*m;i++)
	{
		s[i]=sqrt(s[i]);
		sum[p]+=s[i];
		if(s[i]>1)
		vis[p]=0; 
	} 
}

void change(ll l,ll r,ll c)//开方修改 
{
	if(!vis[pos[l]])
	{
		for(ll i=l;i<=min(pos[l]*m,r);i++)
		{
			sum[pos[i]]-=s[i];
			s[i]=sqrt(s[i]);
			sum[pos[i]]+=s[i];
		}
		vis[pos[l]]=1;
		for(ll i=(pos[l]-1)*m+1;i<=pos[l]*m;i++)//判断 
		if(s[i]>1)
		{
			vis[pos[l]]=0;
			break;
		}
	}
	if(pos[l]!=pos[r]&&vis[pos[r]]==0)
	{
		
		for(ll i=(pos[r]-1)*m+1;i<=r;i++)
		{
			sum[pos[i]]-=s[i];
			s[i]=sqrt(s[i]);
			sum[pos[i]]+=s[i];
		}
		vis[pos[r]]=1;
		for(ll i=(pos[r]-1)*m+1;i<=pos[r]*m;i++)//判断 
		if(s[i]>1)
		{
			vis[pos[r]]=0;
			break;
		}		
	}
	for(ll i=pos[l]+1;i<=pos[r]-1;i++)
	check_sqrt(i);
}

void getsum(ll l,ll r)//求和 
{
	ans=0;
	for(ll i=l;i<=min(pos[l]*m,r);i++)
	ans=ans+s[i];
	if(pos[l]!=pos[r])
	{
		for(ll i=(pos[r]-1)*m+1;i<=r;i++)
		ans=ans+s[i]; 
	}
	for(ll i=pos[l]+1;i<=pos[r]-1;i++)
	ans=ans+sum[i];
	printf("%lld\n",ans);
}

int main(){
	scanf("%lld",&n);m=sqrt(n);
	for(int i=1;i<=n;i++)
	scanf("%lld",&s[i]);
	cin>>N;
	for(int i=1;i<=n;i++)//标记数所在的块 
	pos[i]=(i-1)/m+1;
	for(int i=1;i<=n;i++)
	sum[pos[i]]+=s[i];
	for(int i=1;i<=N;i++)
	{
		scanf("%lld%lld%lld",&op,&l,&r);
		if(l>r)
		swap(l,r);
		if(op==0)
		change(l,r,c);
		if(op==1)
		getsum(l,r);
	}
	return 0;
} 
```
#### ~~最后，我爱分块，我爱暴力~~






---

## 作者：dblark (赞：9)

没有Pascal题解，来一发~~~

个人认为这是线段树经典题（当然其实也可以用分块）。

首先，直接进行区间修改是不存在的，所以只能用单点修改。

不过，这样的效率很低。考虑像搜索一样剪枝。

显然，$\lfloor \sqrt{1} \rfloor=1$，所以当一个点等于$1$时就没有更新的必要了。

同理，当一个区间里面全是$1$的话，也就没有更新的必要了。这里说数列中的每个数都大于$0$，我们只要判断区间和是否等于$r-l+1$就行了。

于是可以轻松的写出代码（线段树版）：

```pas
var
  a:array[1..100000]of int64;
  s:array[1..400000]of int64;  //线段树一般数组开4倍
  n,q,i,l,r,x,t:longint;
procedure pushup(x:longint);   //向上更新
begin
  s[x]:=s[x*2]+s[x*2+1];
end;
procedure build(l,r,x:longint);//建树
begin
  if l=r then
  begin
    s[x]:=a[l];
    exit;
  end;
  build(l,(l+r) div 2,x*2);
  build((l+r) div 2+1,r,x*2+1);
  pushup(x);
end;
procedure update(l,r,tl,tr,x:longint);//更新
begin
  if l=r then                  //单点修改
  begin
    s[x]:=trunc(sqrt(s[x]));
    exit;
  end;
  if (l>=tl) and (r<=tr) and (s[x]=r-l+1) then//把全是1的区间剪枝剪掉了
    exit;
  if tl<=(l+r) div 2 then
    update(l,(l+r) div 2,tl,tr,x*2);
  if tr>(l+r) div 2 then
    update((l+r) div 2+1,r,tl,tr,x*2+1);
  pushup(x);
end;
function query(l,r,tl,tr,x:longint):int64;//查询
begin
  if (l>=tl) and (r<=tr) then
    exit(s[x]);
  query:=0;
  if tl<=(l+r) div 2 then
    inc(query,query(l,(l+r) div 2,tl,tr,x*2));
  if tr>(l+r) div 2 then
    inc(query,query((l+r) div 2+1,r,tl,tr,x*2+1));
  pushup(x);
end;
begin
  read(n);
  for i:=1 to n do
    read(a[i]);
  build(1,n,1);
  read(q);
  for i:=1 to q do
  begin
    read(x,l,r);
    if l>r then                //一个需要注意的地方！r可能大于l
    begin
      t:=l;
      l:=r;
      r:=t;
    end;
    if x=0 then
      update(1,n,l,r,1)
    else
      writeln(query(1,n,l,r,1));
  end;
end.
```

---

## 作者：Ameyax (赞：4)

开方什么鬼啊，只能暴力修改...


但是$\sqrt{1}=1$，$\sqrt{0}=0$，而且开方也不过$log$次，那就可以很暴力的优化了。。


注意输入数据可能有$l>r$，~~我知道题面上写的有，这与我忘记判断并不矛盾~~


```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define ls x << 1
#define rs x << 1 | 1
const int MAX = 110000;
int n, m;
int read()
{
    int x = 0, f = 1; char ch = getchar();
    while (!isdigit(ch)) { if (ch == '-') f = -1; ch = getchar(); }
    while (isdigit(ch)) { x = x * 10 + ch - '0'; ch = getchar(); }
    return x * f;
}
struct SegmentTree
{
    int sum[MAX << 2]; bool tag[MAX << 2];
    void pushup(int x, int l, int r)
    {
        sum[x] = sum[ls] + sum[rs];
        tag[x] = (tag[ls] & tag[rs]);
    }
    void update(int x, int l, int r, int L, int R)
    {
        if (tag[x]) return;
        if (l == r)
        {
            sum[x] = sqrt(sum[x]);
            if (sum[x] == 0 || sum[x] == 1)
                tag[x] = 1;
            return;
        }
        int mid = (l + r) >> 1;
        if (L <= mid) update(ls, l, mid, L, R);
        if (R > mid) update(rs, mid + 1, r, L, R);
        pushup(x, l, r);
    }
    int query(int x, int l, int r, int L, int R)
    {
        if (L <= l && r <= R)
            return sum[x];
        int mid = (l + r) >> 1, re = 0;
        if (L <= mid) re += query(ls, l, mid, L, R);
        if (R > mid) re += query(rs, mid + 1, r, L, R);
        return re;
     }
     void buildtree(int x, int l, int r)
     {
         if (l == r)
         {
             sum[x] = read();
             tag[x] = (sum[x] == 0 || sum[x] == 1);
             return;
         }
         int mid = (l + r) >> 1;
         buildtree(ls, l, mid);
         buildtree(rs, mid + 1, r);
         pushup(x, l, r);
     }
} sgt;
main()
{
    n = read();
    sgt.buildtree(1, 1, n);
    m = read();
    while (m--)
    {
        int opt = read(), L = read(), R = read();
        if (L > R) swap(L, R);
        if (opt) printf("%lld\n", sgt.query(1, 1, n, L, R));
        else sgt.update(1, 1, n, L, R);
    }
    return 0;
}
```

---

## 作者：decoqwq (赞：2)

/*$upd\ on 2018/11/6$*/

之前的博客链接$404$了，已经修复qwq

~~我爱分块~~

听说开根和分块更配哦

这道题一看就是分块裸题啊$\text{qwq}$

$\text{orz}$线段树$\text{dalao}$们

我们对于每个块，统计出它的总和，以及他现在是不是$1$

因为发现基本上$\sqrt{\sqrt{\sqrt{\sqrt{\sqrt{\sqrt n}}}}}$都等于$1$了，所以我们对每个块，最多开$6$次方，打个标记关于其是否全为$1$即可

然后边块角块暴力开根，记得要先用总和减去当前值，开根后再加上，就可以算出答案了

每次边块角块修改后也统计一下是否全为$1$，说不定用几次$O(\sqrt n)$时间复杂度的操作就可以大大减小常数~~对于非洲人来说很有必要的~~

还有就是关于分块块大小的问题，我这里是按照理论最优$\sqrt{\frac{n+2}{3}}$处理的，[具体证明可以看我的博客](http://blog.illusionalsky.cn/184/)

上代码qwq
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int belong[100010],isone[4000],sum[4000];
int a[100010],n,m,block;
void update(int blockn)
{
    for(int i=(blockn-1)*block+1;i<=blockn*block;i++)
    {
        if(a[i]!=1)
        {
            isone[blockn]=0;
            return ;
        }
    }
    isone[blockn]=1;
}
void getsqrt(int l,int r)
{
    int flag=0;
    for(int i=l;i<=min(r,belong[l]*block);i++)
    {
        if(isone[belong[l]])
        {
            flag=1;
            break;
        }
        sum[belong[i]]-=a[i];
        a[i]=sqrt(a[i]);
        sum[belong[i]]+=a[i];
    }
    if(!flag)
    {
        update(belong[l]);
    }
    flag=0;
    if(belong[l]!=belong[r])
    {
        for(int i=(belong[r]-1)*block+1;i<=r;i++)
        {
            if(isone[belong[r]])
            {
                flag=1;
                break;
            }
            sum[belong[i]]-=a[i];
            a[i]=sqrt(a[i]);
            sum[belong[i]]+=a[i];
        }
        if(!flag)
        {
            update(belong[r]);
        }
    }
    for(int i=belong[l]+1;i<belong[r];i++)
    {
        if(isone[i])
        {
            continue;
        }
        for(int j=(i-1)*block+1;j<=i*block;j++)
        {
            sum[i]-=a[j];
            a[j]=sqrt(a[j]);
            sum[i]+=a[j];
        }
        update(i);
    }
}
int query(int l,int r)
{
    int ans=0;
    for(int i=l;i<=min(r,belong[l]*block);i++)
    {
        ans+=a[i];
    }
    if(belong[l]!=belong[r])
    {
        for(int i=(belong[r]-1)*block+1;i<=r;i++)
        {
            ans+=a[i];
        }
    }
    for(int i=belong[l]+1;i<belong[r];i++)
    {
        ans+=sum[i];
    }
    return ans;
}
main()
{
    cin>>n;
    block=sqrt((n+2)/3);
    for(int i=1;i<=n;i++)
    {
        belong[i]=(i-1)/block+1;
        scanf("%lld",&a[i]);
        sum[belong[i]]+=a[i];
    }
    cin>>m;
    for(int i=1;i<=m;i++)
    {
        int opt,l,r;
        scanf("%lld%lld%lld",&opt,&l,&r);
        if(l>r)
        {
            swap(l,r);
        }
        if(opt==0)
        {
            getsqrt(l,r);
        }
        else
        {
            printf("%lld\n",query(l,r));
        }
    }
} 
```

---

## 作者：KingBenQi (赞：2)

/*区间修改全部下放到叶子节点 
对于开方到0或1不用再修改的点打标记
*/
```
#include<bits/stdc++.h>
using namespace std;
#define N 100005 
#define LL long long
inline int gi(){
    char ch=getchar();int x=0,q=0;
    while(ch<'0' || ch>'9') ch=='-'?q=1:0,ch=getchar();
    while(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();
    return q?(-x):x;
}
LL n,m;
LL sum[N<<2];
bool flag[N<<2];
void pushup(int now){
	sum[now]=sum[now<<1]+sum[now<<1|1];
	flag[now]=flag[now<<1]&&flag[now<<1|1];
} 
void build (int L,int R,int now){
	int mid=(L+R)>>1;
	if(L==R){
		sum[now]=gi();
		if (sum[now]==0||sum[now]==1) flag[now]=1;
		return ;
	}
	build (L,mid,now<<1);
	build (mid+1,R,now<<1|1);
	pushup(now);
}
void update(int L,int R,int l,int r,int now){
	int mid=(l+r)>>1;
	if(l==r){
		sum[now]=(LL)(sqrt(sum[now]));
		if(sum[now]==0||sum[now]==1) flag[now]=1;
		return ;
	}
	if(L<=mid&&!flag[now<<1])
	  update(L,R,l,mid,now<<1);
	if(mid<R&&!flag[now<<1|1])
	  update(L,R,mid+1,r,now<<1|1);
	pushup(now);
}
LL query(int L,int R,int l,int r,int now){
	LL Sum=0;
	int mid=(l+r)>>1;
	if(L<=l&&R>=r){
		return sum[now];
	}
	if(L<=mid)
	  Sum+=query(L,R,l,mid,now<<1);
	if(mid<R)
	  Sum+=query(L,R,mid+1,r,now<<1|1);
	return Sum;
}
int main(){
	n=gi();
	build (1,n,1);
	m=gi();
	int x,l,r;
	for(int i=1;i<=m;i++){
		x=gi();l=gi();r=gi();
		if(x==1){
			cout<<query(l,r,1,n,1)<<endl;
		}
		if(x==2){
			update(l,r,1,n,1);
		}
	}
	return 0;
}


```

---

## 作者：Mr_浓氨 (赞：1)

这道题特别好的线段树的题(你说什么,不支持开方,纯线段树做不了QAQ),那是不可能的,既然一棵做不了,就开两棵啊,(???两棵怎么做QAQ),其实仔细的研(wan)究(ji)题(suan)目(qi),就会发现,每个点最多被修改不到十次.最后,他就会神奇的变成01字串QAQ,那这个字串有什么性质呢?当然是最大值为一了(这不等于白说吗QAQ),但你注意,最大值,哇又是一棵线段树,那么两棵线段树就出来了,so,让我们在研究另外一棵线段树(其实我推了13个小时的pushdown,真的,是至少13个小时).如果你发现不会,那么直接暴力搜到底就行了啊.像这样

```cpp
if(nl>r||nr<l)
{
	return;
}
if(nl==nr)
{
	tree[v].max=tree[v].val=sqrt(tree[v].val);
	return;
}
```

惊不惊喜,意不意外,(这还是线段树吗??)当然是了,但是有极其大的常数,好解说到此,开始贴代码.

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#include<iomanip>
#include<ctime>
#include<cstdlib>
#include<queue>
#include<vector>
#include<map>
#include<stack>
#include<cmath>
#define ll long long
using namespace std;
ll n;
inline ll read()
{
	ll x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9')
	{
		if(c=='-')
		{
			f=-1;
		}
		c=getchar();
	}
	while(c>='0'&&c<='9')
	{
		x=x*10+c-'0';
		c=getchar();
	}
	return x*f;
}
struct node
{
	ll max,val,lazy;
}tree[4000001];
inline void build(ll v,ll l,ll r)
{
	if(l==r)
	{
		tree[v].val=tree[v].max=read();
		return;
	}
	ll mid=(l+r)>>1;
	build(v<<1,l,mid);
	build(v<<1|1,mid+1,r);
	tree[v].max=max(tree[v<<1].max,tree[v<<1|1].max);
	tree[v].val=tree[v<<1].val+tree[v<<1|1].val;
}
inline ll query(ll v,ll l,ll r,ll nl,ll nr)
{
	if(nl>=l&&nr<=r)
	{
		return tree[v].val;
	}
	if(nl>r||nr<l)
	{
		return 0;
	}
	ll mid=(nl+nr)>>1;
	return query(v<<1,l,r,nl,mid)+query(v<<1|1,l,r,mid+1,nr);
}
inline ll querym(ll v,ll l,ll r,ll nl,ll nr)
{
	if(nl>=l&&nr<=r)
	{
		return tree[v].max;
	}
	if(nl>r||nr<l)
	{
		return 0;
	}
	ll mid=(nl+nr)>>1;
	return max(query(v<<1,l,r,nl,mid),query(v<<1|1,l,r,mid+1,r));
}
inline void add(ll v,ll l,ll r,ll nl,ll nr)
{
	if(nl>r||nr<l)
	{
		return;
	}
	if(nl==nr)
	{
		tree[v].max=tree[v].val=sqrt(tree[v].val);
		return;
	}
	ll mid=(nl+nr)>>1;
	if(tree[v<<1].max>1)
	{
		add(v<<1,l,r,nl,mid);
	}
	if(tree[v<<1|1].max>1)
	{
		add(v<<1|1,l,r,mid+1,nr);
	}
	tree[v].val=tree[v<<1].val+tree[v<<1|1].val;
	tree[v].max=max(tree[v<<1].max,tree[v<<1|1].max);
}
int main()
{
	n=read();
	build(1,1,n);
	int m=read();
	while(m--)
	{
		ll judge=read(),x=read(),y=read();
		ll l=min(x,y),r=max(x,y);
		if(judge==0)
		{
			ll pop=querym(1,l,r,1,n);
			if(pop<=1)
			{
				continue;
			}
			else
			{
				add(1,l,r,1,n);
			}
		}
		else
		{
			printf("%lld\n",query(1,l,r,1,n));
		}
	}
	return 0;
}

```

---

## 作者：Owen_codeisking (赞：1)

# [更好的阅读体验戳这里](https://www.cnblogs.com/owencodeisking/p/9736440.html)

好吧，楼下有分块的解法，那么我就再阐述一遍好了

本以为暴力分块为$TLE$的，结果发现吊打线段树，用奇技淫巧的卡常技术卡到第一页

[评测记录](https://www.luogu.org/record/show?rid=11363506)

其实这道题就是数列分块入门$5$嘛，发现一个数只能被不超过$6$次开方，那么暴力修改，用一个标记看看整块是否有大于$1$的数

那么我就献上一个未卡常的分块解法

$Code\ Below:$
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn=100000+10;
ll n,m,a[maxn],sum[330],v[330],pos[maxn],blo;

void change(ll x){
    if(!v[x]){
        v[x]=1;sum[x]=0;
        for(ll i=(x-1)*blo+1;i<=x*blo;i++){
            a[i]=sqrt(a[i]);
            sum[x]+=a[i];
            if(a[i]>1) v[x]=0;
        }
    }
}

void update(ll l,ll r){
    if(!v[pos[l]]){
        for(ll i=l;i<=min(pos[l]*blo,r);i++){
            sum[pos[i]]-=a[i];
            a[i]=sqrt(a[i]);
            sum[pos[i]]+=a[i];
        }
        v[pos[l]]=1;
        for(ll i=(pos[l]-1)*blo+1;i<=min(pos[l]*blo,n);i++){
            if(a[i]>1){v[pos[l]]=0;break;}
        }
    }
    if(pos[l]!=pos[r]){
        if(!v[pos[r]]){
            for(ll i=(pos[r]-1)*blo+1;i<=r;i++){
                sum[pos[i]]-=a[i];
                a[i]=sqrt(a[i]);
                sum[pos[i]]+=a[i];
            }
            v[pos[r]]=1;
            for(ll i=(pos[r]-1)*blo+1;i<=min(pos[r]*blo,n);i++){
                if(a[i]>1){v[pos[r]]=0;break;}
            }
        }
    }
    for(ll i=pos[l]+1;i<=pos[r]-1;i++) change(i);
}

ll query(ll l,ll r){
    ll ans=0;
    for(ll i=l;i<=min(pos[l]*blo,r);i++) ans+=a[i];
    if(pos[l]!=pos[r])
        for(ll i=(pos[r]-1)*blo+1;i<=r;i++) ans+=a[i];
    for(ll i=pos[l]+1;i<=pos[r]-1;i++) ans+=sum[i];
    return ans;
}

int main()
{
    scanf("%lld",&n);blo=sqrt(n);
    for(ll i=1;i<=n;i++){
        scanf("%lld",&a[i]);
        pos[i]=(i-1)/blo+1;
        sum[pos[i]]+=a[i];
    }
    scanf("%lld",&m);
    ll opt,l,r;
    while(m--){
        scanf("%lld%lld%lld",&opt,&l,&r);
        if(l>r) swap(l,r);
        if(opt==0) update(l,r);
        else printf("%lld\n",query(l,r));
    }
    return 0;
}
```

---

## 作者：vocaloid (赞：1)

线段树 / 分块。

和隔壁的 GSS 重到了呢……

这道题还是非常简单的，考虑怎么处理开方操作，注意到最大的数 $10^{12}$ 最多被开方 $log_210^{12}=39$ 次，所以最多每个位置处理 $39$ 次，即 $\text{O}(39\times 100000)$，显然是可以接受的，所以我们记录一下区间最大值，可以用线段树，也可以用分块。

线段树：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define MAXN 100005
using namespace std;
int n,m;
ll a[MAXN],t[MAXN<<2],maxn[MAXN<<2];
void PushUp(int rt)
{
    t[rt]=t[rt<<1]+t[rt<<1|1];
    maxn[rt]=max(maxn[rt<<1],maxn[rt<<1|1]);
}
void BuildSegmentTree(int rt,int l,int r)
{
    if(l==r)
    {
        t[rt]=maxn[rt]=a[l];
        return;
    }
    int mid=l+r>>1;
    BuildSegmentTree(rt<<1,l,mid);
    BuildSegmentTree(rt<<1|1,mid+1,r);
    PushUp(rt);
}
void Modify(int rt,int l,int r,int tl,int tr)
{
    if(l==r)
    {
        t[rt]=sqrt(t[rt]);
        maxn[rt]=t[rt];
        return;
    }
    int mid=l+r>>1;
    if(tl<=mid && maxn[rt<<1]>1) Modify(rt<<1,l,mid,tl,tr);
    if(tr>mid && maxn[rt<<1|1]>1) Modify(rt<<1|1,mid+1,r,tl,tr);
    PushUp(rt);
}
ll Query(int rt,int l,int r,int tl,int tr)
{
    if(tl<=l && r<=tr) return t[rt];
    int mid=l+r>>1;
    ll res=0;
    if(tl<=mid) res+=Query(rt<<1,l,mid,tl,tr);
    if(tr>mid) res+=Query(rt<<1|1,mid+1,r,tl,tr);
    return res;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
    BuildSegmentTree(1,1,n);
    scanf("%d",&m);
    while(m--)
    {
        int opt,x,y;
        scanf("%d %d %d",&opt,&x,&y);
        if(x>y) swap(x,y);
        if(!opt) Modify(1,1,n,x,y);
        else printf("%lld\n",Query(1,1,n,x,y));
    }
    return 0;
}
```

分块：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define MAXN 200005
using namespace std;
int n,m,unt,pos[MAXN];
ll sum[MAXN],val[MAXN];
bool fg[MAXN];
template <typename T> void Read(T &x)
{
    int fu=1;
    x=0;
    char ch=getchar();
    for(;!isdigit(ch);ch=getchar()) if(ch=='-') fu=-1;
    for(;isdigit(ch);ch=getchar()) x=(x<<3)+(x<<1)+(ch-48);
    x*=fu;
}
void ModifyBlock(int x)
{
    if(fg[x]) return;
    fg[x]=1;
    sum[x]=0;
    for(int i=(x-1)*unt+1;i<=x*unt;i++)
    {
        val[i]=sqrt(val[i]);
        sum[x]+=val[i];
        if(val[i]>1) fg[x]=0;
    }
}
void Modify(int l,int r)
{
    for(int i=l;i<=min(pos[l]*unt,r);i++)
    {
        sum[pos[l]]-=val[i];
        val[i]=sqrt(val[i]);
        sum[pos[l]]+=val[i];
    }
    if(pos[l]!=pos[r])
    {
        for(int i=(pos[r]-1)*unt+1;i<=r;i++)
        {
            sum[pos[r]]-=val[i];
            val[i]=sqrt(val[i]);
            sum[pos[r]]+=val[i];
        }
    }
    for(int i=pos[l]+1;i<=pos[r]-1;i++) ModifyBlock(i);
}
ll Query(int l,int r)
{
    ll res=0;
    for(int i=l;i<=min(pos[l]*unt,r);i++) res+=val[i];
    if(pos[l]!=pos[r]) for(int i=(pos[r]-1)*unt+1;i<=r;i++) res+=val[i];
    for(int i=pos[l]+1;i<=pos[r]-1;i++) res+=sum[i];
    return res;
}
int main()
{
    scanf("%d",&n);
    unt=sqrt(n);
    for(int i=1;i<=n;i++) Read(val[i]);
    for(int i=1;i<=n;i++)
    {
        pos[i]=(i-1)/unt+1;
        sum[pos[i]]+=val[i];
    }
    Read(m);
    while(m--)
    {
        int opt,x,y;
        Read(opt);
        Read(x);
        Read(y);
        if(x>y) swap(x,y);
        if(!opt) Modify(x,y);
        else printf("%lld\n",Query(x,y));
    }
    return 0;
}
```

---

## 作者：yzhang (赞：0)

### [更好的阅读](https://www.cnblogs.com/yzhang-rp-inf/p/9954162.html)

#### [原题传送门](https://www.luogu.org/problemnew/show/P4145)

#### 这道题实际和GSS4是一样的，只是输入方式有点区别

#### [GSS4传送门](https://www.luogu.org/problemnew/show/SP2713#sub)

这道题暴力就能过qaq（这里暴力指线段树）

数据比较水

开方修改在线段树中枚举叶节点sqrt

查询区间和线段树基本操作

这就可以ac

#### 下面有两个优化，没在代码中体现

1.加开方的懒标记

2.最大的数很小，只要开方6次就可以变成1

所以线段树中再记录区间最大值

当最大值是1时，就可以不用开方

暴力的代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN=100005;
long long a[MAXN];
long long f[MAXN<<2];
long long read(long long &x)
{
    long long f=1;char ch=getchar();
    x=0;
    while(ch<'0' || ch>'9')
    {
        if(ch=='-')
        f=-1;
        ch=getchar();
    }

    while(ch>='0' && ch<='9')
    {
        x=x*10+ch-'0';
        ch=getchar();

    }
    return x*f;
}
int readline(int &x)
{
    int f=1;char ch=getchar();
    x=0;
    while(ch<'0' || ch>'9')
    {
        if(ch=='-')
        f=-1;
        ch=getchar();
    }
    while(ch>='0' && ch<='9')
    {
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}
void build(int root,int left,int right)
{
    if(left==right)
    {
        f[root]=a[left];
        return;
    }
    int mid=(left+right)/2;
    build(2*root,left,mid);
    build(2*root+1,mid+1,right);
    f[root]=f[2*root]+f[2*root+1];
}

void update(int root,int left,int right,int qleft,int qright)
{
    int mid,ans,i;
    if(right-left+1==f[root])
        return;
    if(left==right)
    {
        f[root]=sqrt(f[root]);
        return;
    }	
    mid=(left+right)/2;
    if(qleft<=mid)
        update(2*root,left,mid,qleft,qright);
    if(mid<qright)
        update(2*root+1,mid+1,right,qleft,qright);
    f[root]=f[root*2]+f[root*2+1];
}
long long query(int root,int left,int right,int qleft,int qright)
{
    long long ans=0;
    if(qleft<=left&&right<=qright)
        return f[root];
    int mid=(left+right)/2;
    if(qleft<=mid)
        ans=query(2*root,left,mid,qleft,qright);
    if(mid<qright)
        ans+=query(2*root+1,mid+1,right,qleft,qright);
    return ans;
}
int main()
{
    int n,i,x,y,j,way,k=0,m;
    scanf("%d",&n);
    for(i=1;i<=n;i++)
        read(a[i]);
    build(1,1,n);
    readline(m);
    for(i=1;i<=m;i++)
    {
        readline(way);readline(x);readline(y);
        if(x>y)
        	swap(x,y);
        if(way==1)
            printf("%lld\n",query(1,1,n,x,y));
        else 
            update(1,1,n,x,y);
    }
    return 0;
}
```

---

## 作者：Newuser (赞：0)

（线段树做法，可以并查集做，并查集类似于BZOJ疯狂的馒头）
查询操作是一个简单的线段树求和操作
重点在修改操作

考虑到当一个单点的值如果为1或0时，这个点开根号之后没有意义不会改变值。因此我们对这样的点作一个标记，如果碰到这个点就不修改。

对于一般的结点，则当两个儿子都被做了标记，那么就给这个点加标记，以后不对该结点进行修改操作（如果操作之后其sum值依然不会变）

平均时间复杂度为O(nlogn) 

代码：

	#include<cstdio>
    #include<iostream>
	#include<cmath>
	#define ll long long 
	#define maxn 100005
	using namespace std;


	void read(ll &x) 
	{

    bool flag = false;
    char c=getchar();
    while((c<'0' || c>'9') && c != '-')c=getchar();
    if (c == '-') {
        x = 0;
        flag = true;
    } else {
        x = c - '0';
    }
    c = getchar();
    while(c>='0' && c<='9') {
        x=x*10+c-'0';
        c=getchar();
    }
    x = flag ? -x : x;
    return;
	} 

	struct node{
	ll a,b,c;
	bool lazy;
	}z[maxn<<3];
	ll n,a[maxn];

	void maketree(ll p,ll l,ll r)
	{
	z[p].a=l; z[p].b=r;
	if(l==r){ z[p].c=a[l]; if(z[p].c==1||z[p].c==0)z[p].lazy=1; return; }
	maketree(p<<1,l,((l+r)>>1));
	maketree(p<<1|1,((l+r)>>1)+1,r);
	z[p].c=z[p<<1].c+z[p<<1|1].c;
		if(z[p<<1].lazy==1&&z[p<<1|1].lazy==1) z[p].lazy=1;
	}



	void update(ll p,ll &x,ll &y)
	{

	if(z[p].a==z[p].b)
	{
		z[p].c=floor(sqrt(z[p].c));
		if(z[p].c==1||z[p].c==0){ z[p].lazy=1; }
		return;
	}
    
	if(y>=z[p<<1].a&&x<=z[p<<1].b&&(!z[p<<1].lazy))

    update(p<<1,x,y);
    
	if(y>=z[p<<1|1].a&&x<=z[p<<1|1].b&&(!z[p<<1|1].lazy)) update(p<<1|1,x,y);
	z[p].c=z[p<<1].c+z[p<<1|1].c;
	if(z[p<<1].lazy==1&&z[p<<1|1].lazy==1) z[p].lazy=1;
	}

	ll getsum(ll p,ll &x,ll &y)
	{
	if(x<=z[p].a&&z[p].b<=y)
	{
		return z[p].c;
	}
	ll sum=0;
	if(y>=z[p<<1].a&&x<=z[p<<1].b) sum+=getsum(p<<1,x,y);
	if(y>=z[p<<1|1].a&&x<=z[p<<1|1].b) sum+=getsum(p<<1|1,x,y);
	return sum;
	}

	int main()
	{
	ll i;
	read(n);
	for(i=1;i<=n;i++)
	{
		read(a[i]);
	}
	maketree(1,1,n);
	ll m,ask,x,y;
	read(m);
	while(m--)
	{
		read(ask); read(x); read(y);
        if(x>y) swap(x,y);
		if(ask==1)
		{
			printf("%lld\n",getsum(1,x,y));
		}
		else update(1,x,y);
	}
	}

---


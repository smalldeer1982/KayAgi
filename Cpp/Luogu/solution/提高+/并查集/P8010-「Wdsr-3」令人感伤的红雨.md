# 「Wdsr-3」令人感伤的红雨

## 题目背景



秋静叶是在秋季掌管落叶的神明。在秋季即将迎来落幕之时，因她的力量使然，山里会变得火红一片。同时，将红叶变为落叶也是她工作的一环。

秋穰子是在秋季掌管丰收的神明。与秋静叶的职责相反，她掌管着秋天果实的成熟、秋粮的收获。

交织着快乐与忧愁的秋天，怎能让人不有感而发呢？

## 题目描述

秋穰子和秋静叶是掌管秋天的神灵，因而控制着田地的收成。具体而言，有 $n$ 块田依次排列，第 $i$ 块田的丰收程度为 $a_i$。秋之姐妹会据此得出一年的年成。

在综合考察了各方面因素后，秋之姐妹得出了收获第 $l$ 块至第 $r$ 块田地可以获得的作物总量 $\Omega(l,r)$。具体定义如下：

$$
\begin{aligned}
\Alpha(l,r)&=\max_{i=l}^r\{i\times[a_i=\max_{j=l}^r\{a_j\}]\}\cr
\Beta(l,r)&=\max_{i=l}^r\{\min_{j=1}^i\{\Alpha(j,i)\}\}-\min_{i=l}^r\{\max_{j=1}^i\{\Alpha(j,i)\}\}\cr
\Omega(l,r)&=\min_{i=l}^r\{\min_{j=i}^r\{|\Beta(i,j)|\}\}
\end{aligned}$$

在**提示说明**部分有相关符号的解释。

---

由于相关因素的影响，田地的丰收程度会发生变化。因此秋之姐妹会对 $a$ 进行 $q$ 次操作：

1. 形如 $\colorbox{f0f0f0}{\verb!1 x y!}$，表示让 $a_1,a_{2},a_{3},\cdots ,a_x$ **分别加上** $y$。
2. 形如 $\colorbox{f0f0f0}{\verb!2 l r!}$，表示询问 $\Omega(l,r)$ 的值。

## 说明/提示

样例 $3$ 见下发的附件 $\textbf{\textit{sequence3.in}}/\textbf{\textit{sequence3.ans}}$。

#### 数据范围及约定

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|}\hline
\textbf{Subtask} & \bm{n,q\le} & \textbf{特殊性质} & \textbf{分值}\cr\hline
1 & 100 & - & 10\cr\hline
2 & 5\times 10^3 & - &15\cr\hline
3 & 10^5 & \text{A} &10\cr\hline
4 & 10^5 & \text{B} &5\cr\hline
5 & 10^5 & - &30\cr\hline
6 & 6\times 10^6 & - & 30\cr\hline
\end{array}
$$

**特殊性质** $\textbf{A}$：保证对于任意的 $i\in[1,n-1]$，都有 $a_i<a_{i+1}$。  
**特殊性质** $\textbf{B}$：保证没有操作 $1$。

对于全部数据，保证 $1 \leq n,q \leq 6\times10^6$，$a_i,y_i\in[0,10^9]$，$1\le x_i\le n$，$1\le l_i\le r_i \le n$。

#### 符号解释

- $[P]$ 是艾弗森括号，其中 $P$ 是一个条件。如果 $P$ 为真，则该式子的值为 $1$；否则为 $0$。也就是说，  
$$[P]=\begin{cases}1 & \text{$P$ 为真}\cr 0 & \text{$P$ 为假}\end{cases}$$  
- $\min\limits_{i=l}^r\{P\}$ 表示当 $i$ 取 $l,l+1,l+2,\cdots,r$ 时，表达式 $P$ 的取值的最小值；同理定义了 $\max\limits_{i=l}^r\{P\}$。

#### 提示

本题输入输出量较大，请注意常数因子的影响。

## 样例 #1

### 输入

```
6 3
1 1 4 5 1 4
2 3 5
1 2 5
2 3 5```

### 输出

```
0
1```

## 样例 #2

### 输入

```
10 6
1 3 5 7 8 12 14 15 17 18
2 5 9
1 3 10
2 4 5
1 1 10
2 4 6
2 1 10```

### 输出

```
0
1
3
0```

# 题解

## 作者：I_am_Accepted (赞：12)

## Preface

赛场上一开始打的暴力，$O(n\log^2n)$ 的线段树 + 二分拿了 70 pts，没想到 100 pts 代码只写了这么点（如下 Code，没压行）。

不过还是给这个 D 题和出题人 @[八云蓝](https://www.luogu.com.cn/user/149196) 好评。

## Analysis

线段树 + 二分就不讲了。~~反正读者人均 AK 月赛水平~~

下文将 $\alpha(n)$（反阿克曼函数）看作常数处理。

不要被题目中的 $A(l,r),B(l,r),\Omega(l,r)$ 吓到，题目中的 $A(l,r)$ 翻译成人话就是**数组中区间 $[l,r]$ 内的最大值位置，相同的取靠右的**。

其实认真推导一下，$\Omega(l,r)=\max(0,|l-A(1,r)|)$，接下来问题就在维护 $A(1,x)$ 上了。

本白内障 OIer 漏看的条件：$y\in[0,10^9]$。

就是说修改操作只有**前缀加一个非负数**。

我们将 $a_x=\max\limits_{i=1}^x(a_i)$ 的所有 $x$ 存入 $\{b\}$。

发现**操作只会让 $\{b\}$ 内元素只减不增。**

我们尝试均摊 $O(n)$ 吧！

**算法**（丑图预警）：

**初始化**：

将 $f_x$ 记为小于等于 $x$ 的最大 $\{b\}$ 中的元素。

$\{b\}$ 中元素依次指向下一个建链表，边权记为两者 $a$ 值之差。

![](https://cdn.luogu.com.cn/upload/image_hosting/v8bjvobs.png)

**询问** $A(1,x)$：

类似并查集，将 $x$ 一直跳 $f_x$（可路径压缩），终点即为 $A(1,x)$。

![](https://cdn.luogu.com.cn/upload/image_hosting/l66dxnlp.png)

**修改** $[1,x]$ 加上 $y$：

将 $x$ 跳到 $A(1,x)$，将链表中的边权 $-y$，如果边权 $<0$ 将 $A(1,x)$ 链表中的后继从 $\{b\}$ 中删除，重复直至停止。

![](https://cdn.luogu.com.cn/upload/image_hosting/gj8a7cjv.png)

所以这个算法叫做什么名字呢？~~不知道的话就叫 ZSJ 链表并查集吧（doge）~~

**Upd:**

当然，本蒟蒻的语文非常得垃圾，所以这里写上 @[Konata28](https://www.luogu.com.cn/user/177029) 的语言：

首先，初始的序列肯定有一个单调递增的峰，假设是 $x_1,x_2,x_3,\dots$（即我的 $\{b\}$）。

那么 $[x_{i},x_{i+1})$ 之间的查询的结果都会是 $x_{i}$。

然后我们发现因为是前缀加非负整数，所以 $[x_i,x_{i+1})$ 区间内的查询答案，要么是 $x_i$，要么是因为修改之后的 $x_{i-1}$ 大于 $x_i$ 了导致合并到 $x_{i-1}$ 里面了，$x_{i-2},x_{i-3},\dots$ 同理。

所以我们可以初始化集合，$[x_i,x_{i+1})$ 内的数都在 $x_i$ 的集合内。

如果因为修改导致的 $x_{i-1}>x_i$（即链表边权 $<0$），那么就把 $x_i$ 的集合合并到 $x_{i-1}$ 的中。

## Code

```cpp
#define For(i,j,k) for(register int i=j;i<=k;i++)
#define N 6000100
int n,q,a[N];
int nxt[N],c[N],f[N];
inline int gf(int x){return f[x]==x?x:f[x]=gf(f[x]);}//get father
signed main(){
	n=read(),q=read();//fast read
	For(i,1,n) a[i]=read();
	For(i,1,n) f[i]=i;
	For(i,1,n) nxt[i]=n+1;//list
	For(i,1,n) c[i]=-1;//the delta(cost) to nxt[i]
	int tmp=1;
	For(i,2,n){
		if(a[i]>=a[tmp]){
			nxt[tmp]=i;
			c[tmp]=a[i]-a[tmp];
			tmp=i;
		}else f[i]=tmp;
	}
	int op,x,y,del;
	while(q--){
		op=read(),x=read(),y=read();
		if(op==1){
			tmp=gf(x);
			c[tmp]-=y;
			while(nxt[tmp]<n+1 && c[tmp]<0){
				del=nxt[tmp];//delete it
				c[tmp]+=c[del];
				nxt[tmp]=nxt[del];
				f[del]=tmp;
				nxt[del]=n+1;
				c[del]=-1;
			}
		}else write(max(0,x-gf(y))),pc('\n');//fast write 
	}
    return 0;
}
```

---

## 作者：Tmbcan (赞：4)

## [P8010 「Wdsr-3」令人感伤的红雨](https://www.luogu.com.cn/problem/P8010)
提供一个 $O(n\log{n})$ 的卡常做法。

### 思路

我们先来看这令人头大的三堆函数。    

首先我们可以发现 $A(l,r)$ 指的是 $l\sim r$ 中**最靠右的最大值**出现的**位置**。  
令 $S_i = A(1,i)$，那么序列 $S_n$ 一定单调**不降**。  

所以有：
$$
 \begin{aligned}
&\min\limits_{j=1}^i\{A(j,i)\} = A(1,i)\\
&\max\limits_{j=1}^i\{A(j,i)\} = A(i,i)=i
 \end{aligned}
$$
那么我们可以对 $B(l,r)$ 中关于 $A(j,i)$ 的两个式子做进一步转化：
$$
 \begin{aligned}
&\max\limits_{i=l}^r\{\min\limits_{j=1}^i\{A(j,i)\}\} = \max\limits_{i=l}^r\{A(1,i)\} = A(1,r)\\
&\min_{i=l}^r\{\max_{j=1}^i\{A(j,i)\}\} = \min\limits_{i=l}^r\{i\} = l
 \end{aligned}
$$
于是我们得到了 $B(l,r)$ 关于 $A(l,r)$ 的转化：
$$
 \begin{aligned}
&B(l,r) = A(1,r)-l\\
\end{aligned}
$$

那么我们能得到 $\Omega(l,r)$ 关于 $A(i,j)$ 的转化：
$$
 \begin{aligned}
&\Omega(l,r) = \min\limits_{i=l}^{r}\{\min\limits_{j=i}^r\{\mid A(1,j)-i\mid \}\}
\end{aligned}
$$

我们发现，在 $\min\limits_{j=i}^r\{\mid A(1,j)-i\mid\}$ 中，由于 $A(1,j)-i$ 单调不增且不大于零，所以我们可以得到：  
$$
 \begin{aligned}
&\Omega(l,r) = \mid A(1,r)-l\mid = l-A(1,r)
\end{aligned}
$$

其实就是要维护 $l\sim r$ 中 $A(1,r)$ 到 $l$ 的距离。如果此时 $l<A(1,r)$，则**不存在答案**，应输出 0。

维护**区间最大值的位置**，我们考虑用**线段树**。在左右区间合并时做分类讨论即可。  


### 卡常

由于线段树的 $\log n$ 过大，以正常的常数根本无法通过 $6\times10^6$ 的数据。  
但是理论来讲 2.5 秒是可以通过 $2\times 10^8$ 的，所以我们需要运用一些卡常技巧。

**注意，接下来介绍的方法，缺少任何一个，都无法通过本题的最后两个测试点。作者亲测。**

1. 使用 **zkw** 而不是递归线段树（这一步是最重要的，如果你不会 zkw 可以看我的[这篇文章](https://www.luogu.com.cn/article/sr9hp0dw)）。
 2. 使用**标记永久化**（省掉一半常数）。
 3. 使用**快读**，功能性**函数全部手写**，而不是使用自带函数或者判断语句（很重要很重要）。
 4. 使用 **C++98** 而不是 C++14（可以让你从 2.52 秒变成 2.41 秒）。
 5. 维护的信息用结构体存，并把合并函数改为**重载运算符**。
 6. 查询和修改函数都**搬到主函数里**（可以让你从 2.56 秒变成 2.52 秒）。

具体内容见代码。

### 代码

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>//头文件不多说
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
template <typename T>
inline void read(T&x){//快读，实测超级快读不搭配其他技巧也过不了
	int w=0;x=0;
	char ch = getchar();
	while(ch<'0' || ch>'9'){
		if(ch=='-') w=1;
		ch = getchar();
	}
	while(ch>='0' && ch<='9'){
		x = (x<<1)+(x<<3)+(ch^48);
		ch = getchar();
	}
	if(w) x=-x;
}
template <typename T,typename...Args>
inline void read(T&t,Args&...args){
	read(t);read(args...);
}
template <typename T>
inline T Max(T x,T y){//实测手写会比自带的max、if和三目运算快
  return (x > y ? x : y);
}
const int N = 6e6+10;
int n,m;
int P=1,DEP=0;
struct Tree{//用结构体内存访问比较连续
	ll mx; int pos;
	Tree(){
		mx = 0; pos = 0;
	}
	Tree(ll tmx,int tpos){
		mx = tmx; pos = tpos;
	}
	inline Tree operator + (const Tree&G) const{//实测重载运算符比外层调用函数快
		if(mx==G.mx) return Tree(mx,Max(pos,G.pos));
		else if(mx>G.mx) return Tree(mx,pos);
		else return G;
	}
}tr[N*3];
ll tag[N*3];
int main(){
// 	freopen("in.in","r",stdin);
// 	freopen("out.out","w",stdout);
	
	read(n,m);
	while(P<=n+1) P<<=1;
	for(int i=1,x;i<=n;++i){
		read(x); tr[i+P] = Tree(1ll*x,i);//直接读入省掉建树的常数
	}
	for(int i=P-1;i;--i) tr[i] = tr[i<<1]+tr[i<<1|1];//用重载运算符
	for(int i=1,opt,x,y;i<=m;++i){
		read(opt,x,y);
		if(opt==1){//把update内容搬到主函数里
			int l = 1+P-1,r = x+P+1; ll k = 1ll*y;
			while(l^1^r){
				if(~l&1) tr[l^1].mx+=k,tag[l^1]+=k;
				if(r&1) tr[r^1].mx+=k,tag[r^1]+=k;
				l>>=1;r>>=1;//直接更新，实测比写push_up函数快
				tr[l] = tr[l<<1]+tr[l<<1|1];
				tr[l].mx += tag[l];//标记永久化要加累加标记值
				tr[r] = tr[r<<1]+tr[r<<1|1];
				tr[r].mx += tag[r];
			}
			for(l>>=1; l ;l>>=1){//更新上传
				tr[l] = tr[l<<1]+tr[l<<1|1];
				tr[l].mx += tag[l];
			}
		}
		else{//把query内容搬到主函数里
			int l = 1+P-1,r = y+P+1; Tree resl,resr;
			while(l^1^r){
				if(~l&1) resl = resl+tr[l^1];//注意左右区间合并顺序
				if(r&1) resr = tr[r^1]+resr;
				l>>=1;r>>=1;
				resl.mx += tag[l];//累加标记值
				resr.mx += tag[r];
			}
			printf("%d\n",Max(0,x-(resl+resr).pos));//没有答案输出0
		}
	}

	// fclose(stdin);
 	// fclose(stdout);
	return 0;
}
```

---

## 作者：囧仙 (赞：3)

## $\small \textbf{Subtask 1}$

直接按照题目当中给出的式子模拟即可。

## $\small \textbf{Subtask 2,3,4}$

显然，我们需要对题目中给出的柿子下手。

$$
\begin{aligned}
\Alpha(l,r)&=\max_{i=l}^r\{i\times[a_i=\max_{j=l}^r\{a_j\}]\}\cr
\Beta(l,r)&=\max_{i=l}^r\{\min_{j=1}^i\{\Alpha(j,i)\}\}-\min_{i=l}^r\{\max_{j=1}^i\{\Alpha(j,i)\}\}\cr
\Omega(l,r)&=\min_{i=l}^r\{\min_{j=i}^r\{|\Beta(i,j)|\}\}
\end{aligned}$$

观察 $\Alpha(l,r)$ 的意义。容易发现，$\Alpha(l,r)$ 的值就是区间 $[l,r]$ 当中，最大值所在的位置。那么可以提取到这样一些关键信息：

- $\Alpha(l,r)\le \Alpha(l,r+1)$，当且仅当 $a_{r+1}$ 是 $[l,r+1]$ 当中的**非严格**最大值时取大于号，并且此时 $\Alpha(l,r+1)=r+1$。  
- $\Alpha(l,r)\le \Alpha(l-1,r)$，当且仅当 $a_{l-1}$ 是 $[l-1,r]$ 当中的**严格**最大值时取大于号，并且此时 $\Alpha(l-1,r)=l-1$。

这两个性质可以为我们处理 $\Beta(l,r)$ 提供帮助。

- 由性质 $1$ 可得 $\Alpha(1,i)\le \Alpha(2,i)\le\cdots\le \Alpha(i,i)$，因此 $\min_{j=1}^i\{\Alpha(j,i)\}=\Alpha(1,i)$。那么 $\Beta(l,r)$ 当中靠左的柿子就已经被化简为了 $\max_{i=l}^r\{\Alpha(1,i)\}$。再用一遍这个性质，可以进一步化简为 $\Alpha(1,r)$。  
- 由性质 $1$ 可得 $\Alpha(i,i)\ge \cdots \ge \Alpha(2,i)\ge \Alpha(1,i)$，因此 $\max_{j=1}^i\{\Alpha(j,i)\}=\Alpha(i,i)=i$。那么 $\Beta(l,r)$ 当中靠右的柿子可以被化简为 $\min_{i=l}^r\{i\}=l$。

于是可以得到，

$$
\begin{aligned}
\Beta(l,r)&=\Alpha(1,r)-l \cr
\Omega(l,r)&=\min_{i=l}^r\{\min_{j=i}^r\{|\Alpha(1,j)-i|\}\} \cr
\end{aligned}
$$

现在我们考虑随着 $j$ 的增大，$\Alpha(1,j)$ 会如何变化。显然，$\Alpha(1,j)$ 必然会不小于 $\Alpha(1,i)$ 而不大于 $\Alpha(1,r)$。尤为注意的是，**一旦** $\bm{\Alpha(1,j)}$ **的值发生改变，那么改变后的值就是** $\bm j$。此时的 $j$ 肯定是不小于 $i$ 的，因此随着 $i$ 的枚举总能得到此时的 $|\Alpha(1,j)-i|=0$ 最小。

那么可以改写 $\Omega(l,r)$：

$$\Omega(l,r)=\begin{cases} 0 & \Alpha(1,l-1)\neq \Alpha(1,r)\cr l-\Alpha(1,l-1) & \Alpha(1,l-1)= \Alpha(1,r)\cr\end{cases}$$

因此我们需要实现一种结构，可以执行下面两种操作：

- 查询 $a_1,a_2,\cdots,a_x$ 当中最靠右的最大值的位置。  
- 前缀加。具体而言，对于 $i=1,2,\cdots,x$，让 $a_i$ 加上 $y\quad(y>0)$。

直接暴力计算就能通过 $\textrm{Subtask 2}$；每次修改后 $\mathcal O(n)$ 计算一遍 $\Alpha(1,i)$ 的值，查询的时候 $\mathcal O(1)$ 回答，即可通过 $\textrm{Subtask 4}$。

$\textrm{Subtask 3}$ 维护起来也不会很难。

## $\small \textbf{Subtask 5}$

同样是使用 $\textrm{Subtask 2}$ 的思路。不过是换成线段树维护区间最大值的位置而已。假设现在要对线段树上的节点 $[l,r]$ 进行区间加操作，那么分为三类：

- 如果前缀加的区间整个包含了 $[l,r]$，那么打上区间加的 $\text{tag}$，区间最大值的位置不变。  
- 如果前缀加的区间包含了左子树和部分右子树，那么就递归处理右子树；计算下左子树的最大值，和右子树比较一下，更新 $[l,r]$ 的答案。  
- 如果前缀加的区间仅包含部分右子树，那么就递归处理左子树，更新答案。

这样子总体复杂度就是 $\mathcal O(n\log n)$，可以通过该 $\textrm{Subtask}$。

## $\small \textbf{Subtask 6}$

容易证明这样一件事情：如果 $\Alpha(1,t)=s$，那么 $s=\Alpha(1,s)$。因为如果 $s$ 左侧还存在比 $a_s$ 大的数字 $a_u$，那么 $\Alpha(1,t)$ 同样也会指向 $u$。现在考虑将 $\Alpha(1,t)$ 相同的那些位置放在同一个集合里，容易发现这些集合都是连续的区间；同时由于本题前缀加的特殊性，集合之间**只会发生合并**而不会发生分裂一类的事情（读者可以自行证明/感性理解）。

因此考虑维护这些区间。我们需要存储一个区间内 $a_i$ 的最大值、最左侧元素的位置、最右侧元素的位置。为了将一个元素和其区间对应上，我们还需要一个并查集。

这些区间如果发生合并，那么肯定是从修改位置 $x$ 往后的区间开始**依次**合并，直到碰到一个不能合并的区间。还有一个重点，就是对于前缀加操作打上 $\text{tag}$。一个区间 $u$ 被打上的 $\text{tag}$ 的含义是，**这个区间比右侧区间整体大上** $\mathbf{tag}_{\bm u}$。那么在执行合并判断时，需要加上该 $\mathrm{tag}$；同时在合并区间以后，需要将它的 $\mathrm{tag}$ 加在自己的 $\mathrm{tag}$ 上作为更新。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int INF =2147483647;
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
    return ret*w;
}
const int MAXN=6e6+3;
int n,x,q; i64 A[MAXN],X[MAXN];
namespace DSU{
    int F[MAXN],S[MAXN],L[MAXN],R[MAXN];
    void iit(int n){up(1,n,i) F[i]=i,S[i]=1,L[i]=R[i]=i;}
    int gtf(int x){return x==F[x]?x:F[x]=gtf(F[x]);}
    int mrg(int u,int v){
        int a=gtf(u),b=gtf(v); if(a==b) return -1;
        if(S[a]>S[b]){
            L[a]=min(L[a],L[b]),R[a]=max(R[a],R[b]);
            F[b]=a,S[a]+=S[b]; return a;
        } else {
            L[b]=min(L[a],L[b]),R[b]=max(R[a],R[b]);
            F[a]=b,S[b]+=S[a]; return b;
        }
    }
}
namespace Slv{
    void op1(int x,int y){
        int p=DSU::gtf(x),l=DSU::L[p],r=DSU::R[p];
        X[l]+=y;
        while(r!=n&&A[l]+X[l]>A[r+1]){
            X[l]+=X[r+1],p=DSU::mrg(p,DSU::gtf(r+1));
            l=DSU::L[p],r=DSU::R[p];
        }
    }
    void op2(int l,int r){
        int x=(l==1?0:DSU::L[DSU::gtf(l-1)]);
        int y=        DSU::L[DSU::gtf(r  )] ;
        if(x!=y) printf("0\n"); else printf("%d\n",l-x);
    }
    void op3(int x){
        printf("%d\n",DSU::L[DSU::gtf(x)]);
    }
}
int main(){
    n=qread(),q=qread(); DSU::iit(n);
    up(1,n,i){
        A[i]=qread();
        if(x==0||A[i]>=A[x]) x=i;
        else                 DSU::mrg(i,x);
    }
    up(1,q,i){
        int op=qread(); 
        if(op==1){int x=qread(),y=qread(); Slv::op1(x,y);}
        if(op==2){int l=qread(),r=qread(); Slv::op2(l,r);}
        if(op==3){int x=qread(); Slv::op3(x);}  //Debug.
    }
    return 0;
}
```

---

## 作者：Cxny (赞：2)

非常巧妙的一道题。

## Solution
对于题目中给出的一堆柿子，我们先进行化简。

---

$\text{A}$ 是区间 $[l,r]$ 间**最大的 [最大值出现位置]** ，也即最靠右侧的最大值的位置。

容易发现当 $l$ **保持不变，$r$ 逐渐增大**时，$\text{A}$ 的值**单调不降**；类似地，当 $r$ **保持不变， $l$ 逐渐减小**时，$\text{A}$ 的值**单调不增**。证明显然。

---

对于 $\text{B}$，由于上述性质，有
$$\min_{j=1}^i\{A(j,i)\}=A(1,i)$$
$$\max_{j=1}^i\{A(j,i)\}=A(i,i)=i$$
可以得出
$$
\text{B}(l,r)=\max_{i=l}^r\{\text{A}(1,i)\}-l=\text{A}(1,r)-l
$$

---

对于 $\Omega$，
$$
\Omega(l,r)=\min_{i=l}^{r}\{\min_{j=i}^r\{|\text{B}(i,j)|\}\}
=\min_{i=l}^{r}\{\min_{j=i}^r\{|\text{A}(1,j)-i|\}\}
$$
等价于选出两点 $i,j$ 满足 $l\le i\le j\le r$，使得 $\text{A}(1,j)$ 尽可能接近 $i$。

分类讨论，

对于确定的 $j$，若存在 $i,j$ 使得 $\text{A}(1,j)=i$，即 $\Omega(l,r)=0$，则等价于 $l\le\text{A}(1,j)\le r$。

由于 $\text{A}(1,j)\le j\le r$，$\text{A}(1,j)\le r$ 自然成立。

由于 $\text{A}(x,y)$ 随 $y$ 增大单调不减，因此若原式成立，则 $\text{A}(1,r)\ge l$ 必然成立。

---

否则对于任意 $j\in [l,r]$，$\text{A}(1,j)<l$ 且所有 $\text{A}(1,j)$ 相等。因此$\min_{j=i}^r\{|\text{A}(1,j)-i|\}=\min_{j=i}^r\{l-\text{A}(1,j)\}$。

---

原问题转化为动态维护 $i$ 到**前一个前缀最大值**的距离，需要支持前缀加操作。

考虑使用并查集维护，每个根节点即代表前缀最大值点。

**注意：** 此并查集不支持按秩合并！

对于查询操作，直接在并查集上查询即可。

而对于修改操作，每次前缀加会导致**前缀最大值序列中连续的一段不再满足条件**。

由于删除后这些点一去不复返，因此链表维护，由势能分析可知此部分总时间复杂度为 $\text{O}(n)$。

总时间复杂度为 $\text{O}(n\log n)$，瓶颈在于并查集无法按秩合并。

实现时注意判断条件能否取等。

完整代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long // int main() -> signed
#define ll long long
const int maxn = 6e6 + 10;
struct lk{
	int x, nxt, pre;
	ll tag;
}lk[maxn];
int cnt = 0, head, ind[maxn];
int n, q, a[maxn], f[maxn];
int st[maxn], top;
inline int getf(int x){return f[x] == x ? x : f[x] = getf(f[x]);}
void merge(int x, int y){
	int fx = getf(x), fy = getf(y);
	if(fx != fy) f[fy] = fx;
}
void addlk(int x){
	lk[++cnt].x = x, lk[cnt].nxt = head, lk[head].pre = cnt, head = cnt;
}
void erase(int x){
	lk[lk[x].pre].nxt = lk[x].nxt, lk[lk[x].nxt].pre = lk[x].pre;
}
signed main(){
	scanf("%lld%lld", &n, &q), iota(f + 1, f + n + 1, 1);
	for(int i = 1; i <= n; i++) scanf("%lld", &a[i]);
	st[top = 1] = 1;
	for(int i = 2; i <= n; i++){
		if(a[i] < a[st[top]]) merge(st[top], i);
		else st[++top] = i;
	}
	for(int i = n; i >= 1; i--) if(getf(i) == i) addlk(i), ind[i] = cnt;
	while(q--){
		int opt, x, y;
		scanf("%lld%lld%lld", &opt, &x, &y);
		if(opt == 2){
			if(getf(y) >= x) puts("0");
			else printf("%lld\n", llabs(x - getf(x)));
		}else{
			x = getf(x); int qwq = x; ll tag = -y;
			x = lk[ind[x]].nxt;
			for(; x; x = lk[x].nxt){
				tag += lk[x].tag;
				if(a[lk[x].x] + tag < a[qwq]) erase(x), merge(qwq, lk[x].x);
				else break;
			}
			if(x) lk[x].tag += tag - lk[x].tag;
		}
	}
	return 0;
}
```

---


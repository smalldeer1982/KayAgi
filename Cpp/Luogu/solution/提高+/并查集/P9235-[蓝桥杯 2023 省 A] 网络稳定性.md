# [蓝桥杯 2023 省 A] 网络稳定性

## 题目描述

有一个局域网，由 $n$ 个设备和 $m$ 条物理连接组成，第 $i$ 条连接的稳定性为 $w_i$。

对于从设备 $A$ 到设备 $B$ 的一条经过了若干个物理连接的路径，我们记这条路径的稳定性为其经过所有连接中稳定性最低的那个。

我们记设备 $A$ 到设备 $B$ 之间通信的稳定性为 $A$ 至 $B$ 的所有可行路径的稳定性中最高的那一条。

给定局域网中的设备的物理连接情况，求出若干组设备 $x_i$ 和 $y_i$ 之间的通信稳定性。如果两台设备之间不存在任何路径，请输出 $-1$。

## 说明/提示

【评测用例规模与约定】

对于 $30 \%$ 的评测用例，$n,q \leq 500$，$m \leq 1000$；

对于 $60 \%$ 的评测用例，$n,q \leq 5000$，$m \leq 10000$；

对于所有评测用例，$2 \leq n,q \leq 10^5$，$1 \leq m \leq 3 \times 10^5$，$1 \leq u_i,v_i,x_i,y_i \leq n$，$
1 \leq w_i \leq 10^6$，$u_i \neq v_i$，$x_i \neq y_i$。

## 样例 #1

### 输入

```
5 4 3
1 2 5
2 3 6
3 4 1
1 4 3
1 5
2 4
1 3```

### 输出

```
-1
3
5```

# 题解

## 作者：meyi (赞：19)

提供一种与 kruskal 相关做法相比代码难度显著减少的做法，灵感来源于 ICPC 2023 第一场网络赛。

化简题意后发现，这题本质是将边按边权从大到小排序后依次插入原图，询问两个点在什么时候会连通，允许离线。

每插入一条边本质就是在合并两个连通块，很自然地想到启发式合并。

利用启发式合并的思想，我们将每个询问挂在它的两个端点上，在合并两个联通块时，处理较小的连通块中的询问。

判断询问是否已成立的方法也很简单，只需查询该询问中的另一个端点是否在我们将要合并的连通块内即可，时间复杂度 $O(\alpha(n))$。

对于未成立的询问，只需将其合并到另一个连通块内便于之后查询即可。

有些读者可能发现一个询问在两个点上，会不会造成重复查询呢？会不会影响该做法的正确性呢？请自行思考，理解它才真正理解了本做法。

时间复杂度 $O(n \log n\alpha(n))$。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
//#pragma GCC optimize("Ofast,no-stack-protector,unroll-loops")
#define ALL(v) v.begin(),v.end()
#define For(i,_) for(int i=0,i##end=_;i<i##end;++i) // [0,_)
#define FOR(i,_,__) for(int i=_,i##end=__;i<i##end;++i) // [_,__)
#define Rep(i,_) for(int i=(_)-1;i>=0;--i) // [0,_)
#define REP(i,_,__) for(int i=(__)-1,i##end=_;i>=i##end;--i) // [_,__)
typedef long long ll;
typedef unsigned long long ull;
#define V vector
#define pb push_back
#define pf push_front
#define qb pop_back
#define qf pop_front
#define eb emplace_back
typedef pair<int,int> pii;
typedef pair<ll,int> pli;
#define fi first
#define se second
const int dir[4][2]={{-1,0},{0,1},{1,0},{0,-1}},inf=0x3f3f3f3f,mod=1e9+7;
const ll infl=0x3f3f3f3f3f3f3f3fll;
template<class T>inline bool ckmin(T &x,const T &y){return x>y?x=y,1:0;}
template<class T>inline bool ckmax(T &x,const T &y){return x<y?x=y,1:0;}
int init=[](){return cin.tie(nullptr)->sync_with_stdio(false),0;}();
int main(){
	int m,n,q;
	scanf("%d%d",&n,&m);
	V<int>x(m),y(m),z(m);
	For(i,m)scanf("%d%d%d",&x[i],&y[i],&z[i]),--x[i],--y[i];
	V<V<pii>>to(n);
	scanf("%d",&q);
	For(i,q){
		int u,v;
		scanf("%d%d",&u,&v);
		--u,--v;
		to[u].eb(v,i),to[v].eb(u,i);
	}
	V<int>fa(n,-1);
	function<int(int)>find=[&](int k){return fa[k]<0?k:fa[k]=find(fa[k]);};
	V<int>id(m);
	iota(ALL(id),0);
	sort(ALL(id),[&](int x,int y){return z[x]>z[y];});
	V<int>ans(q,-1);
	for(int i:id){
		int fx=find(x[i]),fy=find(y[i]);
		if(fx==fy)continue;
		if(-fa[fx]<-fa[fy])swap(fx,fy);
		for(pii &j:to[fy])if(find(j.fi)==fx)ans[j.se]=z[i];else to[fx].pb(j);
		fa[fx]+=fa[fy],fa[fy]=fx;
	}
	For(i,q)printf("%d\n",ans[i]);
	return 0;
} 
```


---

## 作者：__ex (赞：13)

### 算法：Kruskal + 倍增 LCA

不难想到，它只要求最小值最大的一条路径，那么对于每个连通块内，在保证它连通的前提下只用找较长的边（断掉较短的边也可通过较长的边使它连通，且通过较长的边的路径一定不劣于短边的路径），也就是每个连通块都可以断一些边使之成为它的最大生成树。

然后就是询问，找它们的最近公共祖先，并在倍增的时候顺便倍增求一下最小值就可以了（参考倍增找祖先）。

### CODE

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
template<typename T>inline T read(){
	T a=0;bool s=0;
	char ch=getchar();
	while(ch>'9' || ch<'0'){
		if(ch=='-')s^=1;
		ch=getchar();
	}
	while(ch>='0' && ch<='9'){
		a=(a<<3)+(a<<1)+(ch^48);
		ch=getchar();
	}
	return s?-a:a;
}
const ll mn=1e6+10;
const ll mod=1e9+7;
ll head[mn],fa[mn],tot;
ll n,m,q,dep[mn],f[mn][20],minn[mn][20];
pair<ll,pair<ll,ll> > o[mn];
struct Eg{
	ll ver,nex,len;
}e[mn<<1];
ll find(ll now){
    if(fa[now]==now)return now;
    return fa[now]=find(fa[now]);
}
inline bool merge(ll a,ll b){
    ll p=find(a),q=find(b);
    if(p==q)return 0;
    fa[q]=p;return 1;
}
inline void add_edge(ll sta,ll end,ll len){
	e[++tot].ver=end;
	e[tot].nex=head[sta];
	e[tot].len=len;
	head[sta]=tot;
}
void dfs(ll now,ll fa){
	dep[now]=dep[fa]+1;
	f[now][0]=fa;
	for(ll i=1;1<<i<dep[now];i++)
		f[now][i]=f[f[now][i-1]][i-1],
        minn[now][i]=min(minn[f[now][i-1]][i-1],minn[now][i-1]);
	for(ll i=head[now];i;i=e[i].nex){
		ll sub=e[i].ver;
        if(sub==fa)continue;
        minn[sub][0]=e[i].len;
 		dfs(sub,now);
	}
}
inline ll lca(ll a,ll b){
    if(a==b)return 0;
    ll ans=0x3f3f3f3f3f3f3f3f;
    if(dep[a]>dep[b])swap(a,b);
    for(ll i=19;i>=0;i--)
        if(dep[f[b][i]]>=dep[a])
            ans=min(ans,minn[b][i]),b=f[b][i];
    if(a==b)return ans;
    for(ll i=19;i>=0;i--)
        if(f[a][i]!=f[b][i])
            ans=min(ans,min(minn[a][i],minn[b][i])),a=f[a][i],b=f[b][i];
    return min(ans,min(minn[a][0],minn[b][0]));
}
int main(){
    memset(minn,0x3f,sizeof(minn));
    n=read<ll>();m=read<ll>();q=read<ll>();
    for(ll i=1;i<=m;i++){
        ll u=read<ll>(),v=read<ll>(),w=read<ll>();
        o[i]=make_pair(w,make_pair(u,v));
    }
    sort(o+1,o+m+1,greater<pair<ll,pair<ll,ll> > >());
    for(ll i=1;i<=n;i++)
        fa[i]=i;
    for(ll i=1,cnt=0;i<=m && cnt<n-1;i++){
        if(merge(o[i].second.first,o[i].second.second))
            add_edge(o[i].second.first,o[i].second.second,o[i].first),
            add_edge(o[i].second.second,o[i].second.first,o[i].first),cnt++;
    }
    for(ll i=1;i<=n;i++)
        if(!dep[i])dfs(i,0);
    for(ll i=1;i<=q;i++){
        ll a=read<ll>(),b=read<ll>();
        if(find(a)!=find(b))
            {puts("-1");continue;}
        printf("%lld\n",lca(a,b));
    }
	return 0;
}
```

---

## 作者：Genius_Star (赞：12)

### 思路：
#### 1.多源最短路
考场直接 Floyd 算出任意两点间的稳定性，$n^3$ 拿 30pts 跑路。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,q;
int dp[5005][5005];
void solve(){
    memset(dp,-1,sizeof(dp));
    cin>>n>>m>>q;
    while(m--){
        int u,v,x;
        cin>>u>>v>>x;
        dp[u][v]=max(dp[u][v],x);   //选稳定性最大的一条路
        dp[v][u]=max(dp[v][u],x);
    }
    for(int k=1;k<=n;k++){
        for(int i=1;i<=n;i++){
            for(int j=1;j<=n;j++){
                if(i!=j&&j!=k&&i!=k){   //用 以K中转的路径 更新dp[i][j]
                    dp[i][j]=max(dp[i][j],min(dp[i][k],dp[k][j]));
                }
            }
        }
    }
    while(q--){
        int x,y;
        cin>>x>>y;
        cout<<dp[x][y]<<endl;
    }
 
}
 
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
 
    solve();
 
    return 0;
}
```
#### 2.kruskal 重构树
重构树听上去高端，实则就是在 kruskal 建最大生成树的过程中额外建点、赋权。

比如，$u$ 和 $v$ 当前不在一个集合里，通过 $w$ 这条边合并时。

新开一个点 $x$，令 $x$ 是 $u$ 和 $v$ 的父亲，而 $x$ 的权值为 $w$。

查询时，查 $u$ 和 $v$ 的 LCA 的权值即可，即为最大连通路径上的最小连通权值。

因为按权值从大到小遍历，已经通过权值大的边，使得点之间尽可能连通了。

LCA 的意思就是求最近公共祖先。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=4e5+10,M=3e5+10,K=20;
int n,m,q,u,v,par[N],a[N],f[N][K],dep[N];
bool vis[N];
vector<int> E[N];
struct edge{
	int u,v,w;
}e[M];
int find(int x){
	return par[x]==x?x:par[x]=find(par[x]);
}
bool cmp(edge a,edge b){
	return a.w>b.w;
}
void dfs(int u,int fa){
	vis[u]=1;
	f[u][0]=fa;
	dep[u]=dep[fa]+1;
	for(auto &v:E[u]){
		if(v==fa)continue;
		dfs(v,u);
	}
}
int lca(int u,int v){
	if(dep[u]<dep[v])swap(u,v);
	int d=dep[u]-dep[v];
	for(int i=K-1;i>=0;--i){
		if(d>>i&1)u=f[u][i];
	}
	if(u==v)return u;
	for(int i=K-1;i>=0;--i){
		if(f[u][i]!=f[v][i])u=f[u][i],v=f[v][i];
	}
	return f[u][0];
}
int main(){
	scanf("%d%d%d",&n,&m,&q);
	for(int i=1;i<=n+m;++i){
		par[i]=i;
	}
	for(int i=1;i<=m;++i){
		scanf("%d%d%d",&e[i].u,&e[i].v,&e[i].w);
	}
	sort(e+1,e+m+1,cmp);
	int cur=n;
	for(int i=1;i<=m;++i){
		int u=e[i].u,v=e[i].v,w=e[i].w;
		u=find(u),v=find(v);
		if(u==v)continue;
		++cur;
		par[u]=par[v]=cur;
		E[cur].push_back(u);
		E[cur].push_back(v);
		a[cur]=w;
	}
	for(int i=cur;i>=1;--i){
		if(!vis[i])dfs(i,0);
	}
	for(int j=1;j<K;++j){
		for(int i=1;i<=cur;++i){
			f[i][j]=f[f[i][j-1]][j-1];
		}
	}
	while(q--){
		scanf("%d%d",&u,&v);
		if(find(u)!=find(v)){
			puts("-1");
			continue;
		}
		printf("%d\n",a[lca(u,v)]);
	}
	return 0;
}
```


---

## 作者：Fze_8 (赞：11)




## 前置知识

- 最近公共祖先（LCA)

- $\text{Kruskal}$ 重构树


## 简化题意

>[P9235  网络稳定性](https://www.luogu.com.cn/problem/P9235)

> 给一个有边权的无向图，给你点 $u$ 到另一个点 $v$ 所有的路径上最大的边权最小是多少。

## solution

先来介绍一下 $\text{Kruskal}$ 重构树。这个算法是最小生成树的 $\text{Kruskal}$ 算法的延申，大体思路是相近的。

**构造方法**

1. 把最小生成树上的边从小到大排序，像最小生成树那样判断连通性即是否加边。

2.  假设可以连边，我们就把这条边的**边权**作为另外两点所在集合根节点的父节点。

3. 如果此时遍历完所有的边，即构造完成，得到了重构树。

那么重构树都有些什么优秀的性质呢？ 

首先一定是一颗二叉树，因为所有的连边过程都是**边权节点**与两个不相连的根节点相连。其次原图中两个点间所有路径上的边最大权值的最小值一定是构造树上两点的 lca 权值。

那么，对于这一道题，我们该如何去使用？因为这题求的是路径上的最大值的最小值，那么我们就在排序的时候把边按照边权从大到小排序就好了，具体的求 lca 我们使用倍增树剖都是可以的。代码实现的话需要注意构造出来的不一定是一颗树，而很可能是森林，所以需要每一次判断连通性去初始化树剖。

核心部分的代码  

```cpp
void kruskal()
{
	sort(e+1,e+m+1,cmp);
	for(int i=1;i<=n;++i) f[i]=i;
	for(int i=1;i<=m;++i)
	{
		int u=find(e[i].u),v=find(e[i].v);
		if(u==v) continue;
		val[++cnt]=e[i].w;
		f[cnt]=f[u]=f[v]=cnt;
		add(u,cnt),add(v,cnt);
	}
	for(int i=1;i<=cnt;++i)
	{
		if(vis[i]) continue;   /*这里有效处理森林*/
		int rt=find(i);
		dfs1(rt),dfs2(rt,rt); 
	}
}
```
[完整代码](https://www.luogu.com.cn/paste/4rpl30az)


## 推荐习题

 - [P4197 Peaks](https://www.luogu.com.cn/problem/P4197) 
 
 - [P4768 [NOI2018] 归程](https://www.luogu.com.cn/problem/P4768)
 
 - [P4899 [IOI2018] werewolf 狼人](https://www.luogu.com.cn/problem/P4899)



---

## 作者：AzureHair (赞：8)

**P3379 最近公共祖先【黄】+P3366 最小生成树【橙】=P9235 网络稳定性【蓝】。**

看到题干发现就是让你找两点之间路径长度最小值最大的路径，然后输出最小的值。考虑到你要让最小值尽可能大，而且还是构建一棵树，就能发现是让你构造一棵最大生成树。

证明方法：

如果存在一条最小值更大的路径上的最小值为 $v_2$，当前路径最小值为 $v_1$，由于 $v_2>v_1$ 所以 $v_2$ 会提前被选入生成树，故不存在该情况，证毕。

所以解决了第一部分的问题，还有一个求两点间路径长度最小值最大的路径的路径最小值，一棵树上的路径是唯一的，可以发现是 LCA 的板子，在寻找最近公共祖先的同时利用相同的思路倍增求链上最小值即可。

把这道题作为图论康复训练的我花了一个半小时才写出来。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,q,fa[100010],head[100010],cnt=0,dep[100010],f[100010][21],lg[100010],s[100010][21],vis[100010];//fa为并查集，dep记录深度，f[i][j]记录i向上2^j后的节点
//lg预处理log2的值，s[i][j]记录i节点向上跳2^j步中的最短边长，vis用于记录该节点是否访问过 
struct node//记录边用于最大生成树 
{
	int from,to,v;
	bool operator <(const node a) const
	{
		return v>a.v;
	}
}t[300010];
struct node1//存图，用于LCA 
{
	int next,to,v;
}e[600010];
int find(int x)//并查集 
{
	if(x==fa[x]) return x;
	int tmp=find(fa[x]);
	fa[x]=tmp;
	return tmp;
}
void add(int from,int to,int v)//建图 
{
	e[++cnt].next=head[from];
	e[cnt].to=to;
	e[cnt].v=v;
	head[from]=cnt;
}
void dfs(int x,int fath,int k)//预处理f，s的值用于LCA 
{
	vis[x]=1;
	dep[x]=dep[fath]+1;f[x][0]=fath;s[x][0]=k;
	for(int i=1;i<=lg[dep[x]];i++)
	{
		f[x][i]=f[f[x][i-1]][i-1];
		s[x][i]=min(s[x][i-1],s[f[x][i-1]][i-1]);
	}
	for(int i=head[x];i;i=e[i].next)
	{
		int to=e[i].to;
		if(to==fath)
		{
			continue;
		}
		dfs(to,x,e[i].v);
	}
}
int lca(int x,int y)//倍增LCA 
{
	if(dep[x]<dep[y])//使x深度更大 
	{
		swap(x,y);
	}
	int ans=1145141919810;
	while(dep[x]>dep[y])
	{
		ans=min(ans,s[x][lg[dep[x]-dep[y]]-1]); 
		x=f[x][lg[dep[x]-dep[y]]-1];//使深度大的x向上跳 
	}
	if(x==y)//y是y和x的最近公共祖先 
	{
		return ans;
	}
	for(int i=lg[dep[x]]-1;i>=0;i--)
	{
		if(f[x][i]!=f[y][i])
		{
		    ans=min(ans,min(s[x][i],s[y][i]));
			x=f[x][i];y=f[y][i];//x,y一起往上跳 
		}
	}
	return min(ans,min(s[x][0],s[y][0]));//返回路径中最短边长 
}

signed main()
{
	cin>>n>>m>>q;
	for(int i=1;i<=n;i++)
	{
		lg[i]=lg[i-1]+(1<<lg[i-1]==i);//预处理log2 
	}
	for(int i=1;i<=m;i++)
	{
		cin>>t[i].from>>t[i].to>>t[i].v;
	}
	for(int i=1;i<=n;i++)
	{
		fa[i]=i;//并查集初始化别忘了 
	}
	sort(t+1,t+m+1);//按照边长从大到小排序 
	int now=0;
	for(int i=1;i<=m;i++)
	{
		while(find(t[i].from)==find(t[i].to))
		{
			i++;
			if(i>m)
			{
				break;
			}
		}
		if(i>m)
		{
			break;
		}
		fa[find(t[i].to)]=find(t[i].from);
		add(t[i].from,t[i].to,t[i].v);
		add(t[i].to,t[i].from,t[i].v);//选的边建图 
		now++;
	}
	for(int i=1;i<=n;i++)
	{
		fa[i]=find(i);
	}
	for(int i=1;i<=n;i++)
	{
		if(!vis[i])
		{
			dfs(i,0,0);//对于每一颗树进行LCA预处理 
		}
	}
	for(int i=1;i<=q;i++)
	{
		int x,y;
		cin>>x>>y;
		if(fa[x]!=fa[y])
		{
			cout<<-1<<endl;
			continue;
		}
		cout<<lca(x,y)<<endl;//输出结果，快乐AC 
	}
	return 0;
}
```
祝大家早日AC。

---

## 作者：Coffee_zzz (赞：6)

本文主要讲解处理图不连通的方法。

首先图连通的情况很好处理，先跑一遍 Kruskal 再跑一边树上倍增就可以。

考虑图不连通时怎么处理。

容易想到一种解决方法是对每个连通块都跑一个 Kruskal 和树上倍增，但实现起来较为复杂。

而还有一种解决方法如下：

建立一个虚根 $S$，将 $1\sim n$ 中的每一个点都与 $S$ 相连，将这些边的边权都设为 $0$，并对整个图跑 Kruskal 和树上倍增。如果对于任意一个询问，树上倍增得到的答案为 $0$，则输出 $-1$，否则输出该答案。

由于只有当两个点在原图不连通时，才会经过新加的边权为 $0$ 的边，所以这样做是正确的。

最后放一下代码。

```c++
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+5,M=3e5+5,L=17,inf=1e9;
int to[M<<1],val[M<<1],nxt[M<<1],head[N],cnt,n,m,q;
int fa[N],f[N][L],ans[N][L],dep[N];
vector <int> a,b,c;
struct Nod{
	int u,v,w;
};
bool operator < (Nod x,Nod y){
	return x.w<y.w;
}
void add(int u,int v,int w){
	to[++cnt]=v;
	val[cnt]=w;
	nxt[cnt]=head[u];
	head[u]=cnt;
}
int get(int x){
	if(fa[x]==x) return x;
	else return fa[x]=get(fa[x]);
}
void init(int u,int fat,int s){
	f[u][0]=fat,ans[u][0]=s,dep[u]=dep[fat]+1;
	for(int i=1;i<L;i++) f[u][i]=f[f[u][i-1]][i-1],ans[u][i]=min(ans[u][i-1],ans[f[u][i-1]][i-1]);
	for(int i=head[u];i;i=nxt[i]){
		if(to[i]==fat) continue;
		else init(to[i],u,val[i]);
	}
}
void solve(){
	priority_queue <Nod> pq;
	int u,v,w,x,y;
	for(int i=0;i<a.size();i++){
		u=a[i],v=b[i],w=c[i];
		pq.push({u,v,w});
	}
	while(!pq.empty()){
		u=pq.top().u,v=pq.top().v,w=pq.top().w;
		pq.pop();
		x=get(u),y=get(v);
		if(x==y) continue;
		else fa[x]=y,add(u,v,w),add(v,u,w);
	}
	init(n+1,0,0);
}
int work(int x,int y){
	int res=inf;
	if(dep[x]<dep[y]) swap(x,y);
	for(int i=L-1;i>=0;i--) if(dep[f[x][i]]>=dep[y]) res=min(res,ans[x][i]),x=f[x][i];
	if(x==y) return res;
	for(int i=L-1;i>=0;i--) if(f[x][i]!=f[y][i]) res=min(res,ans[x][i]),res=min(res,ans[y][i]),x=f[x][i],y=f[y][i];
	res=min(res,ans[x][0]),res=min(res,ans[y][0]);
	return res;
}
signed main(){
	ios::sync_with_stdio(0);
	cin>>n>>m>>q;
	int u,v,w;
	for(int i=1;i<=n+1;i++) fa[i]=i;
	for(int i=1;i<=m;i++){
		cin>>u>>v>>w;
		a.push_back(u),b.push_back(v),c.push_back(w);
	}
	for(int i=1;i<=n;i++) a.push_back(i),b.push_back(n+1),c.push_back(0); //连新边
	solve();
	for(int i=1;i<=q;i++){
		cin>>u>>v;
		int res=work(u,v);
		if(res==0) cout<<-1<<endl;
		else cout<<res<<endl;
	}
	return 0;
}
```

---

## 作者：WhisperingWillow (赞：5)

传送门：[link](https://www.luogu.com.cn/problem/P9235)


很多题解都没有讲明白为什么要用克鲁斯卡尔算法跑一遍最大生成树，~~本蒟蒻根本听不懂~~。

首先，让我们看这样一个图。


![](https://cdn.luogu.com.cn/upload/image_hosting/io49zyoi.png)

正常人肯定会先选大的边权走，并且使图成为一颗森林(因为图可能不连通)。

最优方法明显是选 $6,5,3$ 三条边。

这里就需要用到克鲁斯卡尔算法了。

- 前置知识：[并查集](https://www.luogu.com.cn/problem/P3367)

具体流程如下。

1. 先从大到小，根据边权排序每条边。
2. 如果这条边的两个端点不连通，则合并他们。
3. 最后，根据选的边，我们获得了一个森林。

那么，有了森林之后，该怎么处理询问呢？

- 前置知识 [静态区间最值](https://www.luogu.com.cn/problem/P3865)


1. 如果给出的 $x,y$ 不是同一棵树，证明它们无法联通，输出 ```-1```。
2. 否则和普通 LCA 一样，先使 $x,y$ 到达同一深度，再往上跳，每次跳二的次幂，这里运用了倍增的思想。
3. 再通过记录 w 数组维护区间 RMQ 获取最终答案。

最后，请给作者点上一个大大的赞！

### Main Code

```cpp
inline void kru()
{
    sort(edge1+1, edge1+m+1, CMP); 
    for(int i=1; i<=n; i++)
        f[i]=i;
    for(int i=1; i<=m; i++)
        if(find(edge1[i].x)!=find(edge1[i].y)){
            f[find(edge1[i].x)]=find(edge1[i].y);
            addedge(edge1[i].x, edge1[i].y, edge1[i].dis);
            addedge(edge1[i].y, edge1[i].x, edge1[i].dis);  //无向图，双向加边 
        }
    return ;
}
inline void dfs(int node)
{
    vis[node]=true;
    for(int i=head[node]; i; i=edge2[i].next){ 
        int to=edge2[i].to;
        if(vis[to]) continue;
        deep[to]=deep[node]+1; 
        fa[to][0]=node; 
        w[to][0]=edge2[i].w; 
        dfs(to);
    }
    return ;
}
inline int lca(int x, int y)
{
    int ans=INF;
    if(deep[x]>deep[y]) swap(x,y);
    for(int i=20; i>=0; i--)
        if(deep[fa[y][i]]>=deep[x]){
            ans=min(ans, w[y][i]); 
            y=fa[y][i];
        }
    if(x==y) return ans; 
    for(int i=20; i>=0; i--)
        if(fa[x][i]!=fa[y][i]){
            ans=min(ans, min(w[x][i], w[y][i])); 
            x=fa[x][i]; 
            y=fa[y][i]; 
        }
    ans=min(ans, min(w[x][0], w[y][0])); 
   return ans;
}
inline void init(){
	for(int i=1; i<=20; i++)
        for(int j=1; j<=n; j++){
            fa[j][i]=fa[fa[j][i-1]][i-1]; 
            w[j][i]=min(w[j][i-1], w[fa[j][i-1]][i-1]);
    }
}
```


---

## 作者：joyslog (赞：4)

给定一个 $n$ 个点，$m$ 条边的无向图，边有边权。

有 $q$ 次询问，每次给出两个点 $x,y$，求出它们之间所有简单路径上最小边权的最大值。

$2 \leq n,q \leq 10^5$，$1 \leq m \leq 3 \times 10^5$，$1 \leq u_i,v_i,x_i,y_i \leq n$，$
1 \leq w_i \leq 10^6$，$u_i \neq v_i$，$x_i \neq y_i$。

### 题解

本题就是瓶颈路的模板。我们直接使用 Kruskal 重构树来解决这个问题。

下面来介绍一下这个算法：

我们把边权从大到小排序，跑一遍 Kruskal。在 Kruskal 加边 $(u, v, w)$ 时，我们新建一个节点 $p$，并且连边 $p\to \text{find}(u), p\to \text{find}(v)$，再把 $u,v$ 在并查集中与 $p$ 合并，把 $p$ 的点权设为 $w$。

这样一来，我们构建出一个二叉堆，其中叶子节点为原图上的点，其余节点都代表了原图的一条边，点权为原图的边权。

可以发现，原图中两个点之间的所有简单路径上最小边权的最大值 = 最大生成树上两个点之间的简单路径上的最小值 = Kruskal 重构树上两点之间的 LCA 的权值。

这里我使用树剖求 LCA，常数较小，暂时是洛谷上的最优解。

假设 $n,m$ 范围同阶，则时间复杂度：$\mathcal{O}(n\log n)$。

```cpp
#include <bits/stdc++.h>
#define pb emplace_back
using namespace std;
typedef long long ll;

inline ll read() {
    ll ret = 0, w = 1; char c = getchar();
    while(!isdigit(c))    {if(c == '-')    w = -1; c = getchar();}
    while(isdigit(c))    {ret = (ret << 1) + (ret << 3) + (c ^ 48); c = getchar();}
    return ret * w;
}
inline void write(ll x) {
    if(x < 0)  putchar('-'), x = -x;
    if(x > 9)  write(x / 10);
    putchar(x % 10 + 48);
}

const int MAX_N = 3e5 + 10;
int n, m, q, tot, cnt, ecnt;
int W[MAX_N], hson[MAX_N], siz[MAX_N], fa[MAX_N], fir[MAX_N], dep[MAX_N], top[MAX_N];

struct edge {
	int u, v, w;
	edge() {}
	edge(int _u, int _v, int _w) :
		u(_u), v(_v), w(_w) {}
} E[MAX_N];
struct e {
	int v, nxt;
	e() {}
	e(int _v, int _nxt) :
		v(_v), nxt(_nxt) {}
} G[MAX_N];
void AddEdge(int u, int v) {
	G[++ecnt] = e(v, fir[u]);
	fir[u] = ecnt; 
}

struct dsu {
	int fa[MAX_N];
	dsu() {}
	dsu(int n) {
		for(int i = 1; i <= n; i++)
			fa[i] = i;	
	}	
	int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]);}
	int merge(int u, int v) { return fa[find(u)] = find(v);}
} D;
void kruskal() {
	sort(E + 1, E + m + 1, [](edge lhs, edge rhs) {return lhs.w > rhs.w;});
	tot = n;
	for(int i = 1, u, v, fu, fv, w; i <= m; i++) {
		u = E[i].u, v = E[i].v, w = E[i].w;
		fu = D.find(u), fv = D.find(v);
		if(fu == fv)	continue;
		tot++;
		D.merge(fu, tot);
		D.merge(fv, tot);
		AddEdge(tot, fu);
		AddEdge(tot, fv);
		W[tot] = w;
		if(++cnt == n - 1)	return;
	}
}

void dfs1(int u) {
	siz[u] = 1;
	hson[u] = -1;
	for(int i = fir[u], v; i; i = G[i].nxt) {
		v = G[i].v;
		dep[v] = dep[u] + 1;
		fa[v] = u;
		dfs1(v);
		siz[u] += siz[v];
		if(hson[u] == -1 || siz[v] > siz[hson[u]])	hson[u] = v;
	}
}
void dfs2(int u, int tp) {
	top[u] = tp;
	if(hson[u] != -1)	dfs2(hson[u], tp);
	for(int i = fir[u], v; i; i = G[i].nxt) {
		v = G[i].v;
		if(v != hson[u])	dfs2(v, v);
	}
}
int lca(int u, int v) {
	while(top[u] != top[v]) {
		if(dep[top[u]] > dep[top[v]])	u = fa[top[u]];
		else	v = fa[top[v]];
	}
	return dep[u] > dep[v] ? v : u;
}

int main() {
	n = read(), m = read(), q = read();
	D = dsu(2 * n + 2);
	for(int i = 1, u, v, w; i <= m; i++) {
		u = read(), v = read(), w = read();
		E[i] = edge(u, v, w);
	}
	kruskal();
	dfs1(tot);
	dfs2(tot, tot);
	for(int i = 1, x, y, f; i <= q; i++) {
		x = read(), y = read();
		if(D.find(x) != D.find(y))	write(-1);
		else {
			f = lca(x, y);
			write(W[f]);
		}
		putchar('\n');
	}
	return 0;
}
```

---

## 作者：Asimplename (赞：2)

[传送门](https://www.luogu.com.cn/problem/P9235)

此题显然需要维护路径上的信息，所以可以考虑使用 ``LCA`` 实现。但是题目中给的是一张图，所以我们需要求出这张图的最大生成树，舍弃边权较小的边，对于每个询问，在求出其 ``LCA`` 的同时维护最小值即可。

需要注意的是图可能不连通，所以我们在 ``dfs`` 求结点深度时需要对于每个连通块都求一遍。

```cpp
#include<iostream>
#include<cmath>
#include<vector>
#include<algorithm>
using namespace std;
struct kru{
	int x,y,z;
}bian[300010];
struct edge{
	int next;
	int to;
	int w;
}e[600010];
int n,m,q;
int fa[100010];
int numEdge;
int head[100010];
int jump[100010][30];
int cost[100010][30];
int depth[100010];
int a,b;
bool cmp(kru a, kru b){
	return a.z > b.z;
}
int Find(int x){
	if(fa[x] != x){
		fa[x] = Find(fa[x]);
	}
	return fa[x];
}
void AddEdge(int from, int to, int w){
	numEdge ++;
	e[numEdge].next = head[from];
	e[numEdge].to = to;
	e[numEdge].w = w;
	head[from] = numEdge;
}
void dfs(int x){
	for(int i = head[x]; i != 0; i = e[i].next){
		int y = e[i].to;
		int w = e[i].w;
		if(! depth[y]){
			depth[y] = depth[x] + 1;
			jump[y][0] = x;
			cost[y][0] = w;
			dfs(y);
		}
	}
} 
void Init(){
	for(int i = 1; i <= n; i ++){
		if(depth[i] == 0){
			depth[i] = 1;
			dfs(i);
		}
	}
	for(int j = 1; (1 << j) <= n; j ++){
		for(int i = 1; i <= n; i ++){
			if(depth[i] - (1 << j) >= 1){
				jump[i][j] = jump[jump[i][j - 1]][j - 1];
				cost[i][j] = min(cost[i][j - 1], cost[jump[i][j - 1]][j - 1]);
			}
		}
	}
}
int LCA(){
	int ans = 2e9;
	if(depth[a] > depth[b]){
		swap(a, b);
	}
	for(int i = log2(n); i >= 0; i --){
		if(depth[jump[b][i]] >= depth[a]){
			ans = min(ans, cost[b][i]);
			b = jump[b][i];
		}
	}
	if(a == b){
		return ans;
	}
	for(int i = log2(n); i >= 0; i --){
		if(jump[a][i] >= 1 && jump[b][i] != jump[a][i]){
			ans = min(ans, cost[a][i]);
			ans = min(ans, cost[b][i]);
			a = jump[a][i];
			b = jump[b][i];
		}
	}
	ans = min(ans, cost[a][0]);
	ans = min(ans, cost[b][0]);
	return ans;
}
int main (){
	cin >> n >> m >> q;
	for(int i = 1; i <= m; i ++){
		cin >> bian[i].x >> bian[i].y >> bian[i].z;
	}
	sort(bian + 1, bian + 1 + m, cmp);
	for(int i = 1; i <= n; i ++){
		fa[i] = i;
	}
	for(int i = 1; i <= m; i ++){
		int p1 = Find(bian[i].x);
		int p2 = Find(bian[i].y);
		if(p1 != p2){
			fa[p2] = p1;
			AddEdge(bian[i].x, bian[i].y, bian[i].z);
			AddEdge(bian[i].y, bian[i].x, bian[i].z); 
		}
	}
	Init();
	while(q --){
		cin >> a >> b;
		if(Find(a) != Find(b)){
			cout << "-1" << endl;
		}
		else{
			cout << LCA() << endl;
		}
	}
	return 0;
}
```

---

## 作者：D2T1 (赞：2)

比较套路的题被我做成诈骗题/kk

题意是：给定图上任意两点，求其所有路径中权值最大的路径，路径的权值定义为路径上最小边权。

最小值最大刚开始以为是二分。但是一看数据范围发现不是很可做。

然后考虑生成树。将最大生成树建出来，可以发现任意两个点肯定有一条最优路径就是树上的这个路径。

反证法：如果存在另一条 $a$ 到 $b$ 的路径严格优于树上的这条路径，考虑这条更优路径上边权最小的边 $e_1$，树上这条路径边权最小的边 $e_2$，有条件得 $e_1$ 边权大于 $e_2$ 边权。那么 $e_1$ 必然在 $e_2$ 之前先考虑是否加入生成树。但此时因为不存在 $e_2$ 这条边，那么 $a$ 和 $b$ 肯定是不联通的，所以 $e_1$ 在生成树中，矛盾。

好了啊。求出每个连通块的最大生成树，然后倍增或者别的方法维护一下树上路径就行。

```cpp
//P9235
#include <bits/stdc++.h>
using namespace std;

const int N = 3e5 + 10;
int n, m, q, fa[N][20], w[N][20], vis[N], dep[N];
vector<pair<int, int> > g[N];

struct edge{
	int u, v, w;
} e[N];
bool cmp(edge a, edge b){
	return a.w > b.w;
}

int f[N];
int gf(int x){
	if(x == f[x]){
		return x;
	}
	return f[x] = gf(f[x]);
}

void dfs(int x, int faa){
	vis[x] = 1;
	dep[x] = dep[faa] + 1;
	for(auto i : g[x]){
		int y = i.first, z = i.second;
		if(y == faa){
			continue;
		}
		fa[y][0] = x;
		w[y][0] = z;
		for(int i = 1; i < 20; ++ i){
			fa[y][i] = fa[fa[y][i-1]][i-1];
			w[y][i] = min(w[y][i-1], w[fa[y][i-1]][i-1]);
		}
		dfs(y, x);
	}
}
int lca(int x, int y){
	int ans = 0x3f3f3f3f;
	if(dep[x] < dep[y]){
		swap(x, y);
	}
	for(int i = 19; i >= 0; -- i){
		if(dep[fa[x][i]] >= dep[y]){
			ans = min(ans, w[x][i]);
			x = fa[x][i];
		}
	}
	if(x == y){
		return ans;
	}
	for(int i = 19; i >= 0; -- i){
		if(fa[x][i] != fa[y][i]){
			ans = min(ans, w[x][i]);
			ans = min(ans, w[y][i]);
			x = fa[x][i];
			y = fa[y][i];
		}
	}
	return min(ans, min(w[x][0], w[y][0]));
}

int main(){
	scanf("%d%d%d", &n, &m, &q);
	for(int i = 1; i <= m; ++ i){
		scanf("%d%d%d", &e[i].u, &e[i].v, &e[i].w);
	}
	sort(e + 1, e + m + 1, cmp);
	for(int i = 1; i <= n; ++ i){
		f[i] = i; 
	}
	for(int i = 1; i <= m; ++ i){
		if(gf(e[i].u) != gf(e[i].v)){
			f[gf(e[i].u)] = gf(e[i].v);
			g[e[i].u].push_back(make_pair(e[i].v, e[i].w));
			g[e[i].v].push_back(make_pair(e[i].u, e[i].w));
		}
	}
	dep[0] = 1;
	for(int i = 1; i <= n; ++ i){
		if(!vis[i]){
			dfs(i, 0);
		}
	}
	for(int i = 1; i <= q; ++ i){
		int x, y;
		scanf("%d%d", &x, &y);
		if(gf(x) != gf(y)){
			puts("-1");
		} else {
			printf("%d\n", lca(x, y));
		}
	}
	return 0;
}
```

---

## 作者：arrow_king (赞：1)

[双倍经验](https://www.luogu.com.cn/problem/P1967)

题意：一个图，求一条路径上的最小边权。

# 思路

一个图不好办，但是可以找最大生成树，因为想要使得沿路的边权最小值最大，走最大生成树一定不劣。

这样子图就变成了树，问题也就变成了树上路径边权最小值。

### ~~直接树剖走~~

大法师两次，树剖一下，对每次询问直接用线段树维护链上最小值，时间复杂度 $O(n\log^2 n)$，但是常数比较小。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<algorithm>
using namespace std;
#define ll long long
#define il inline
#define N 100005
#define M 600005
#define lc(x) x<<1
#define rc(x) (x<<1)|1
il ll read() {
	ll x=0,f=1;char c=getchar();
	while(c<'0'||c>'9') {if(c=='-') {f=-1;} c=getchar();}
	while(c>='0'&&c<='9') {x=(x<<3)+(x<<1)+(c^48);c=getchar();}
	return x*f;
}
struct Edge {
	int next,from,to,w;
};
struct sgt {
	int l,r;
	int minn;
};
sgt tr[N<<2];
Edge edge[M],_edge[M];
int n,m,q,a[N],fa[N];
int head[N],num_edge;
int dep[N],laozuzong[N],siz[N],son[N];
int seg[N],rev[N],top[N],tot;
il void add_edge(int from,int to,int w) {
	edge[++num_edge].next=head[from];
	edge[num_edge].from=from;
	edge[num_edge].to=to;
	edge[num_edge].w=w;
	head[from]=num_edge;
}
il bool cmp(const Edge a,const Edge b) {
	return a.w>b.w;
}
il int findf(int x) {
	if(fa[x]==x) return x;
	return fa[x]=findf(fa[x]);
}
il void dfs1(int u,int f) {
	if(f<0) {
		dep[u]=1;
		laozuzong[u]=f;
	}
	else {
		dep[u]=dep[f]+1;
		laozuzong[u]=laozuzong[f];
	}
	fa[u]=f,siz[u]=1,son[u]=0;
	for(int i=head[u];i;i=edge[i].next) {
		int v=edge[i].to;
		if(v==f) continue;
		a[v]=edge[i].w;
		dfs1(v,u);
		siz[u]+=siz[v];
		if(siz[son[u]]<siz[v]) son[u]=v;
	}
}
il void dfs2(int u,int f) {
	if(son[u]!=0) {
		seg[son[u]]=++tot;
		rev[tot]=son[u];
		top[son[u]]=top[u];
		dfs2(son[u],u);
	}
	for(int i=head[u];i;i=edge[i].next) {
		int v=edge[i].to;
		if(v!=f&&!seg[v]) {
			seg[v]=++tot;
			rev[tot]=v;
			top[v]=v;
			dfs2(v,u);
		}
	}
}
il void push_up(int now) {
	tr[now].minn=min(tr[lc(now)].minn,tr[rc(now)].minn);
}
il void build(int now,int l,int r) {
	tr[now].l=l,tr[now].r=r;
	if(l==r) {
		tr[now].minn=a[rev[l]];
		return;
	}
	int mid=(l+r)>>1;
	build(lc(now),l,mid);
	build(rc(now),mid+1,r);
	push_up(now);
}
il int query(int qx,int qy,int l,int r,int now) {
	if(qx<=l&&r<=qy) return tr[now].minn;
	int mid=(l+r)>>1,ans=1e9;
	if(qx<=mid) ans=min(ans,query(qx,qy,l,mid,lc(now)));
	if(mid<qy) ans=min(ans,query(qx,qy,mid+1,r,rc(now)));
	return ans;
}
il int getmin(int x,int y) {
	int fx=top[x],fy=top[y],ans=1e9;
	while(fx!=fy) {
		if(dep[fx]<dep[fy]) {
			swap(x,y);
			swap(fx,fy);
		}
		ans=min(ans,query(seg[fx],seg[x],1,n,1));
		x=fa[fx];
		fx=top[x];
	}
	if(dep[x]>dep[y]) swap(x,y);
	ans=min(ans,query(seg[son[x]],seg[y],1,n,1));
	return ans;
}
int main() {
	n=read(),m=read(),q=read();
	for(int i=1;i<=m;i++) {
		int x=read(),y=read(),z=read();
		add_edge(x,y,z);
		add_edge(y,x,z);
	}
	sort(edge+1,edge+num_edge+1,cmp);
	for(int i=1;i<=num_edge;i++) _edge[i]=edge[i];
	for(int i=1;i<=n;i++) head[i]=0,fa[i]=i;
	num_edge=0;
	for(int i=1;i<=2*m;i++) {
		int u=_edge[i].from,v=_edge[i].to;
		int fu=findf(u),fv=findf(v);
		if(fu!=fv) {
			add_edge(u,v,edge[i].w);
			add_edge(v,u,edge[i].w);
			fa[fv]=fu;
		}
	}
	for(int i=1;i<=n;i++) if(!seg[i]) {
		seg[i]=++tot;
		rev[tot]=i;
		top[i]=i;
		dfs1(i,-i);
		dfs2(i,-i);
	}
	build(1,1,n);
	for(int i=1;i<=q;i++) {
		int x=read(),y=read();
		if(laozuzong[x]!=laozuzong[y]) {
			puts("-1");
			continue;
		}
		printf("%d\n",getmin(x,y));
	}
	return 0;
}

```

---

## 作者：Bulyly (赞：1)

- **题意：** 定义路径的权值为路径上的边的最小值，给出点对 $(u,v)$ ，求出在所有路径中权值最大的一条。

------------
- 首先点对之间的最大权值路径一定在它们的最大生成树上面。**证明**：因为在 Kruscal 算法中，边的值是有序排列的，显然第一次使该点对能联通的边一定是最大的。

- 从该结论出发，即在该生成树中求点对路径上边的最大值。显然用树剖可以轻松做到。

注意：不是每个点都互相联通，所以实际上处理的是森林，具体处理可参考代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
const int N=3e5+10,M=N<<1;
int n,m,q;
struct edge{
	int a,b,c;
	bool sg;
	bool operator<(const edge &t) const{
		return c>t.c;
	}
}E[M];
int p[N];
int e[M],ne[M],h[N],w[M],idx;
int id[N],top[N],dw[N],nw[N],cnt;
int sz[N],dep[N],son[N],fa[N];

struct SegTree{
	int l,r;
	ll minn;
}tr[N<<2];

int find(int x){
	return p[x]==x?p[x]:p[x]=find(p[x]);
}

void add(int a,int b,int c){
	e[++idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx;
}

void dfs1(int u,int f,int d){
	sz[u]=1,fa[u]=f,dep[u]=d;
	for(int i=h[u];i;i=ne[i]){
		int j=e[i];
		if(j==son[u]||j==fa[u])  continue;
		dw[j]=w[i];
		dfs1(j,u,d+1);
		sz[u]+=sz[j];
		if(sz[son[u]]<sz[j])  son[u]=j;
	}
}

void dfs2(int u,int t){
	top[u]=t,id[u]=++cnt,nw[cnt]=dw[u];
	if(!son[u])  return;
	dfs2(son[u],t);
	for(int i=h[u];i;i=ne[i]){
		int j=e[i];
		if(j==son[u]||j==fa[u])  continue;
		dfs2(j,j);
	}
}

void pushup(int u){
	tr[u].minn=min(tr[u<<1].minn,tr[u<<1|1].minn);
}

void build(int u,int l,int r){
	tr[u].l=l,tr[u].r=r;
	if(l==r)  tr[u].minn=nw[r];
	else{
		int mid=l+r>>1;
		build(u<<1,l,mid);
		build(u<<1|1,mid+1,r);
		pushup(u);
	} 
}

ll query(int u,int l,int r){
	if(tr[u].l>=l&&tr[u].r<=r)  return tr[u].minn;
	int mid=tr[u].l+tr[u].r>>1;
	ll res=1e9;
	if(l<=mid)  res=min(res,query(u<<1,l,r));
	if(r>mid)  res=min(res,query(u<<1|1,l,r));
	return res;
}

ll query_path(int u,int v){
	if(find(u)!=find(v))  return -1;
	ll res=1e9;
	while(top[u]!=top[v]){
		if(dep[top[u]]<dep[top[v]])  swap(u,v);
		res=min(res,query(1,id[top[u]],id[u]));
		u=fa[top[u]];
	}
	if(dep[u]<dep[v])  swap(u,v);
	res=min(res,query(1,id[v]+1,id[u]));
	return res;
}

int main(){
	
	scanf("%d%d%d",&n,&m,&q);
	for(int i=1;i<=m;i++){
		int a,b,c;
		scanf("%d%d%d",&a,&b,&c);
		E[i]={a,b,c};
	}
	sort(E+1,E+m+1);
	for(int i=1;i<=n;i++)  p[i]=i;
	for(int i=1;i<=m;i++)  {
		int a=E[i].a,b=E[i].b,c=E[i].c;
		if(find(a)!=find(b)){
			p[find(a)]=find(b);
			E[i].sg=1;
		}
	}
	for(int i=1;i<=m;i++){
		if(E[i].sg){
			add(E[i].a,E[i].b,E[i].c);
			add(E[i].b,E[i].a,E[i].c);
		}
	}
	for(int i=1;i<=n;i++)  
		if(!sz[i]){
			dfs1(i,0,1);
			dfs2(i,i);
		}  
	
	build(1,1,n);
	while(q--){
		int a,b;
		scanf("%d%d",&a,&b);
		printf("%lld\n",query_path(a,b));
	}
	
	return 0;
} 
```


---


# 电王的传送迷宫

## 题目背景

电王天天玩传送门。

## 题目描述

给出一个大小为 $n\times m$ 的二维网格图。

网格上的 `.` 是可以通行的路径，`#` 是不能通行的障碍。

你每次可以走到一个与当前位置四连通的且不超过边界的点。

严格来说，若你当前在点 $(x,y)$，你可以走到 $(x-1,y),(x+1,y),(x,y-1),(x,y+1)$ 中的一个，并且保证在任意时刻你的坐标 $(x,y)$ 应该满足 $1\le x\le n,1\le y\le m$。

我们从起点 $(sx,sy)$ 出发，你希望知道到达任意一个位置至少要走几步。

但这太简单了，于是精通传送门的电王在这个网格图上建造了 $p$ 个传送门，它们的坐标分别为 $(a_1,b_1),(a_2,b_2),...,(a_p,b_p)$。

而电王也设计了 $q$ 个终点，它们的坐标分别为 $(c_1,d_1),(c_2,d_2),...,(c_q,d_q)$。

假如你使用了 $i$ 次传送门，当你到达任意一个传送门，你可以选择直接传送到点 $(c_{i+1},d_{i+1})$。而第 $q$ 次传送后，所有的传送门都会失效。

**所以，传送到的位置只与你传送的次数有关，而与你到达了哪个传送门没有任何关系，我们可以认为所有传送门都是等价的。**

**保证 $p$ 个传送门和 $q$ 个终点的位置都不是障碍。**

保证对于任意输入给出的坐标对应的位置上都是可以通行的路径，且这些坐标一定两两不同。

但电王有的时候并不想知道到去往任意点最少要移动几步，可能他只想知道到一个终点 $(tx,ty)$ 的最少移动步数，我们会在输入格式中了解这个测试点电王的喜好（保证 $tx,ty$ 不是一个障碍）。

## 说明/提示

样例解释：

我们以从起点 $(3,4)$ 去往 $(1,1)$ 为例：首先 $(3,4)\to(2,4)$，然后使用传送门，第一次传送到 $(1,4)$。然后 $(1,4)\to (2,4)$，第二次使用传送门，到达点 $(2,1)$，最后 $(2,1)\to(1,1)$，我们使用了两次传送门，行走了 $3$ 步，所以这个路径方案的移动次数是 $3$，可以证明不存在比这更优的方案了。

**本题采用捆绑测试**。

| $\text{Subtask}$ | 分数 | $n,m,p,q$ | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $10$ | $p=q=0$ | 无特殊限制 |
| $2$ | $20$ | $p=1$ | 无特殊限制 |
| $3$ | $20$ | $1\le n,m,p,q\le 500$ | 无特殊限制 |
| $4$ | $20$ | 无特殊限制 | $A$ |
| $5$ | $10$ | 无特殊限制 | $B$ |
| $6$ | $20$ | 无特殊限制 | 无特殊限制 |

$A$：保证 $opt=1$。

$B$：保证网格中不存在不可通行的障碍 `#`。

对于所有数据，满足 $1\le n,m\le 1000,0\le p,q\le n\times m,0 \leq opt \leq 1$。

## 样例 #1

### 输入

```
0
3 4
.#..
..#.
....
3 4 1 2 
2 4
1 4
2 1```

### 输出

```
3 -1 2 1
2 3 -1 1
3 2 1 0```

# 题解

## 作者：_LiWenX_ (赞：5)

暴力做法是直接建出分层图，然后 01bfs，复杂度是 $O(nm q)$ 的，这里就不再赘述。

首先，由于第 $i$ 次传送到的点是不同的，所以可以考虑先设 $f_i$ 表示到 $(c_i,d_i)$ 的最小代价，然后考虑求解这个 $f$，由于传送门之间本质相同，所以 $f_i$ 就是 $f_{i-1}$ 加上离 $(c_{i-1},d_{i-1})$ 最近的传送门到它的距离。

那么，我们可以新建节点 $s$，让 $s$ 向所有的传送门连一条边权为 $0$ 的边，然后其他相邻网格连 $1$ 权的边，以 $s$ 为源点跑单源最短路，得到数组 $dis_{1,x,y}$ 就是从距离 $(x,y)$ 最近的传送门到它的距离，然后套用刚刚的转移方式可以预处理出 $f$，如果最短路使用迪杰斯特拉算法是 $O(nm\log n)$ 的，但是使用 01bfs 算法可以做到 $O(nm)$，然后考虑 01bfs 在干什么，其实就是将所有传送门提前入队一次，再跑边权为 $1$ 的最短路，所以可以直接使用 bfs 解决这个问题。

预处理完 $f$ 后，可以直接想到一个暴力做法：新建节点 $s$，$s$ 向 $(a_i,b_i)$ 连边权为 $f_i$ 的边，向起点连边权为 $0$ 的边，然后跑最短路，这样显然是对的，但是复杂度是 $O(nm\log n)$，无法通过。沿用刚刚的思路，我们发现只有这些 $s$ 出发的边是特殊的，直接使用迪杰斯特拉不优，我们希望可以将它改造为 bfs。这依然是可行的，我们发现 bfs 和迪杰斯特拉唯一的区别是我们把一个优先队列变成了一个普通队列，这是因为对于边权为 $1$ 的图，在队列直接向后插入元素可以保证队列元素是单调的，我们希望依然在这个图上也可以保持这个性质，事实上也很简单，我们从小到大考虑一个传送门的终点 $(c_i,d_i)$，我们先假装在跑一个普通的 bfs，对于这个 bfs 的队列，最大值与最小值相差必然不超过 $1$，设队列队首元素的值为 $k$，那么如果 $f_i\le k+1$，此时插入 $f_i$ 进入队列末尾是依然满足的 bfs 的性质的，然后你发现这样也一直满足这是一个优先队列的要求，所以直接维护一个指针 $p$，在 bfs 每一轮拓展之后，若满足 $f_p\le k+1$，则拓展指针 $p$ ，将 $(c_i,d_i)$ 加入队列，即可满足要求。这部分的时间复杂度为 $O(nm)$

所以总复杂度就是 $O(nm)$，由于这只是 T2，所以没有卡 $O(nm\log n)$ 的做法。

代码如下：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int opt,n,m,p,q;
int id(int x,int y){return (x-1)*m+y;}
char ch[1005*1005];
struct edge{
	int from,to;
}e[1005*1005*10];int head[1005*1005],siz;
void addedge(int x,int y){
	e[++siz].to=y;
	e[siz].from=head[x],head[x]=siz;
}
int b[1005*1005],f[1005*1005],dis1[1005*1005],dis2[1005*1005];
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin>>opt>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>ch[id(i,j)];
			dis1[id(i,j)]=dis2[id(i,j)]=1e15;
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(ch[id(i,j)]=='#') continue;
			if(i-1>=1&&ch[id(i-1,j)]!='#') addedge(id(i,j),id(i-1,j));
			if(i+1<=n&&ch[id(i+1,j)]!='#') addedge(id(i,j),id(i+1,j));
			if(j-1>=1&&ch[id(i,j-1)]!='#') addedge(id(i,j),id(i,j-1));
			if(j+1<=m&&ch[id(i,j+1)]!='#') addedge(id(i,j),id(i,j+1));
		}
	}
	int sx,sy,fir,tx,ty,ed=0;
	cin>>sx>>sy;fir=id(sx,sy);
	cin>>p>>q;
	if(opt==1) cin>>tx>>ty,ed=id(tx,ty);
	queue<int> Q;
	for(int i=1;i<=p;i++){
		int x,y;cin>>x>>y;
		Q.push(id(x,y));
		dis1[id(x,y)]=0;
	}
	for(int i=1;i<=q;i++){
		f[i]=1e15;
		int x,y;cin>>x>>y;
		b[i]=id(x,y);
	}
	b[0]=fir;
	while(!Q.empty()){
		int now=Q.front();Q.pop();
		for(int i=head[now];i;i=e[i].from){
			int u=e[i].to;
			if(dis1[u]>dis1[now]+1){
				dis1[u]=dis1[now]+1;
				Q.push(u);
			}
		}
	}
	for(int i=1;i<=q;i++){
		if(dis1[b[i-1]]>=1e15) continue;
		f[i]=f[i-1]+dis1[b[i-1]];
	}
	Q.push(b[0]);
	int pos=1;
	dis2[b[0]]=0;
	while(!Q.empty()){
		int now=Q.front();Q.pop();
		for(int i=head[now];i;i=e[i].from){
			int u=e[i].to;
			if(dis2[u]>dis2[now]+1){
				dis2[u]=dis2[now]+1;
				Q.push(u);
			}
		}
		while(pos<=q&&(Q.empty()||f[pos]<=dis2[Q.front()]+1)){
			Q.push(b[pos]);
			dis2[b[pos]]=min(dis2[b[pos]],f[pos]);
			pos++;
		}
	}
	if(opt){
		if(dis2[ed]>=1e15) cout<<-1;
		else cout<<dis2[ed];
		return 0;
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(dis2[id(i,j)]>=1e15) cout<<-1<<' ';
			else cout<<dis2[id(i,j)]<<' ';
		}cout<<'\n';
	}
} 
```

---

## 作者：封禁用户 (赞：4)

设地图大小为 $s=nm$，传送入口为 $P_x$，出口为 $Q_i$，起点为 $Q_0$，终点为 $T_y$，$\to$ 为最短路径，$\Rightarrow$ 为传送。

很明显，最短路径只能是以下中的一种：

- $Q_0 \to T_y$；
- $Q_0 \to P_x \Rightarrow Q_1 \to T_y$；
- $Q_0 \to P_x \Rightarrow Q_1 \to P_x \Rightarrow Q_2 \to T_y$；
- $Q_0 \to P_x \Rightarrow Q_1 \to P_x \Rightarrow Q_2 \to P_x \Rightarrow Q_3 \to T_y$；
- ………………………………………………………………………
- $Q_0 \to P_x \Rightarrow Q_1 \to P_x \Rightarrow Q_2 \to P_x \Rightarrow Q_3 \to \ldots \Rightarrow Q_n \to T_y$。

因此，我们要求出 $Q_i \to P_x$ 的长度，并以此求出 $Q_0 \to \ldots \to Q_i \to T_y$ 的长度。


---


很明显，求 $Q_i \to P_x$ 的长度时，$(q+1)$ 遍 BFS 是不可取的。然而，由于这 $(q+1)$ 遍 BFS 的终点都是 $P_x$，我们可以以 $P_x$ 为起点反向进行 BFS，这样就可以在 $O(s)$ 内求出 $Q_i \to P_x$ 的长度了。

举个例子：

|$\color{red} Q_2\color{black}/\color{blue} P_x$|$.$|$\color{red} Q_3\color{black}/\color{red} Q_4$|$\#$|$\color{red} Q_5$|
|:-:|:-:|:-:|:-:|:-:|
|$\#$|$\#$|$\#$|$\#$|$\#$|
|$.$|$\#$|$\color{red} Q_6$|$.$|$\color{blue} P_x$|
|$\#$|$\#$|$.$|$\#$|$\#$|
|$\color{red} Q_1$|$.$|$.$|$.$|$\color{green} Q_0$|

初始状态：

|$0$|||$\#$||
|:-:|:-:|:-:|:-:|:-:|
|$\#$|$\#$|$\#$|$\#$|$\#$|
||$\#$|||$0$|
|$\#$|$\#$||$\#$|$\#$|
|||$\color{white}.$|||

最终状态（$6$ 轮 BFS 后）：

|$0$|$1$|$2$|$\#$||
|:-:|:-:|:-:|:-:|:-:|
|$\#$|$\#$|$\#$|$\#$|$\#$|
||$\#$|$2$|$1$|$0$|
|$\#$|$\#$|$3$|$\#$|$\#$|
|$6$|$5$|$4$|$5$|$6$|

因此 $Q_{[0,6]} \to P_x$ 的长度分别为 $6,6,0,2,2,+\infty,2$**（$Q_5$ 无法到达 $P_x$）**，$Q_0 \to Q_{[0,6]}$（走传送门）的长度分别为 $0,6,12,12,14,16,+\infty$**（$Q_6$ 无法通过这一方式到达，因为 $Q_5$ 无法到达 $P_x$）**。


---


求 $Q_0 \to \ldots \to Q_i \to T_y$ 的长度时，我们仍然可以 BFS，对每个可能的最短路径长度 BFS 一轮即可。当目前长度等于 $Q_0 \to Q_i$（走传送门）的长度，且 $Q_i$ 还没有入队时，我们要将 $Q_i$ 入队。

我们继续使用上面的例子。

初始状态：

||||$\#$||
|:-:|:-:|:-:|:-:|:-:|
|$\#$|$\#$|$\#$|$\#$|$\#$|
||$\#$||||
|$\#$|$\#$||$\#$|$\#$|
|||||$0$|

$6$ 轮 BFS 后：

||||$\#$||
|:-:|:-:|:-:|:-:|:-:|
|$\#$|$\#$|$\#$|$\#$|$\#$|
||$\#$|$4$|$5$|$6$|
|$\#$|$\#$|$3$|$\#$|$\#$|
|$4$|$3$|$2$|$1$|$0$|

**在第 $6$ 轮 BFS 中，由于 $Q_0 \to Q_1$（走传送门）的长度为 $6$，此时 $Q_1$ 应当入队。但 $Q_1$ 在此之前已经入队，因此不再将 $Q_1$ 入队。**

**在第 $7 \sim 11$ 轮 BFS 中，虽然此时没有新结点入队，但不能结束 BFS，因为 $Q_2 \sim Q_5$ 还没有入队（$Q_6$ 走传送门无法到达，不需要入队）。**

$12$ 轮 BFS 后：

|$12$||$12$|$\#$||
|:-:|:-:|:-:|:-:|:-:|
|$\#$|$\#$|$\#$|$\#$|$\#$|
||$\#$|$4$|$5$|$6$|
|$\#$|$\#$|$3$|$\#$|$\#$|
|$4$|$3$|$2$|$1$|$0$|

**$Q_2,Q_3$ 入队。**

$13$ 轮 BFS 后：

|$12$|$13$|$12$|$\#$||
|:-:|:-:|:-:|:-:|:-:|
|$\#$|$\#$|$\#$|$\#$|$\#$|
||$\#$|$4$|$5$|$6$|
|$\#$|$\#$|$3$|$\#$|$\#$|
|$4$|$3$|$2$|$1$|$0$|

**在第 $14$ 轮 BFS 中，$Q_4$ 应当入队，但它在此之前已经入队。**

$16$ 轮 BFS 后：

|$12$|$13$|$12$|$\#$|$16$|
|:-:|:-:|:-:|:-:|:-:|
|$\#$|$\#$|$\#$|$\#$|$\#$|
||$\#$|$4$|$5$|$6$|
|$\#$|$\#$|$3$|$\#$|$\#$|
|$4$|$3$|$2$|$1$|$0$|

**在第 $16$ 轮 BFS 中，$Q_5$ 入队。**

**$Q_6$ 不需要入队，并且从第 $17$ 轮 BFS 开始不再有新结点入队，因此 BFS 结束。**


---


然而，上面的做法会 TLE，因为路径长度可以达到 $qs=10^{12}$**（因此答案要开 `long long`）**。

优化很简单：当队列内没有结点时，将当前处理的最短路径长度直接设为使得下一个 $Q_i$ 入队的最短路径长度。例如，在上面的例子中，当第 $6$ 轮 BFS 结束后，可以直接跳到第 $12$ 轮 BFS，跳过第 $7 \sim 11$ 轮 BFS。

最终的时间复杂度为 $O(s)$，空间复杂度为 $O(s)$。


---


上面例子对应的输入输出数据如下：

**输入：**

```plain
0
5 5
...#.
#####
.#...
##.##
.....
5 5 2 6
3 5
1 1
5 1
1 1
1 3
1 3
1 5
3 3
```

**输出：**

```plain
12 13 12 -1 16
-1 -1 -1 -1 -1
-1 -1 4 5 6
-1 -1 3 -1 -1
4 3 2 1 0
```


---


**AC Code：**

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
char s[1012][1012];
int ans[1012][1012];
int res[1012][1012];
bool alr[1012][1012];
int px[1000012],py[1000012],qx[1000012],qy[1000012];
int fir[1000012];
signed main()
{
    memset(s,'#',sizeof s);
    memset(ans,-1,sizeof ans);
    memset(res,-1,sizeof res);
    memset(alr,0,sizeof alr);
    ios::sync_with_stdio(0);
    int o;
    cin>>o;
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            cin>>s[i][j];
    int sx,sy,p,qq,tx,ty;
    cin>>sx>>sy>>p>>qq;
    ans[sx][sy]=0;
    if(o) cin>>tx>>ty;
    for(int i=1;i<=p;i++)
        cin>>px[i]>>py[i];
    for(int i=1;i<=qq;i++)
        cin>>qx[i]>>qy[i];
    queue<pair<int,int> > q;
    int cnt=0;
    for(int i=1;i<=p;i++)
    {
        q.push(make_pair(px[i],py[i]));
        alr[px[i]][py[i]]=true;
    }
    while(!q.empty())
    {
        int ct=q.size();
        while(ct--)
        {
            pair<int,int> u=q.front();
            q.pop();
            res[u.first][u.second]=cnt;
            if(s[u.first][u.second+1]=='.'&&!alr[u.first][u.second+1])
            {
                alr[u.first][u.second+1]=true;
                q.push(make_pair(u.first,u.second+1));
            }
            if(s[u.first+1][u.second]=='.'&&!alr[u.first+1][u.second])
            {
                alr[u.first+1][u.second]=true;
                q.push(make_pair(u.first+1,u.second));
            }
            if(s[u.first][u.second-1]=='.'&&!alr[u.first][u.second-1])
            {
                alr[u.first][u.second-1]=true;
                q.push(make_pair(u.first,u.second-1));
            }
            if(s[u.first-1][u.second]=='.'&&!alr[u.first-1][u.second])
            {
                alr[u.first-1][u.second]=true;
                q.push(make_pair(u.first-1,u.second));
            }
        }
        cnt++;
    }
    fir[1]=res[sx][sy];
    for(int i=2;i<=qq;i++)
    {
        if(res[qx[i-1]][qy[i-1]]==-1||fir[i-1]==-1) fir[i]=-1;
        else fir[i]=fir[i-1]+res[qx[i-1]][qy[i-1]];
    }
    fir[qq+1]=-1;
    memset(alr,0,sizeof alr);
    q.push(make_pair(sx,sy));
    alr[sx][sy]=true;
    cnt=0;
    int now=1;
    while(!q.empty()||fir[now]!=-1)
    {
        if(q.empty()) cnt=fir[now];
        while(fir[now]==cnt)
        {
            if(!alr[qx[now]][qy[now]])
            {
                q.push(make_pair(qx[now],qy[now]));
                alr[qx[now]][qy[now]]=true;
            }
            now++;
        }
        int ct=q.size();
        while(ct--)
        {
            pair<int,int> u=q.front();
            q.pop();
            ans[u.first][u.second]=cnt;
            if(s[u.first][u.second+1]=='.'&&!alr[u.first][u.second+1])
            {
                alr[u.first][u.second+1]=true;
                q.push(make_pair(u.first,u.second+1));
            }
            if(s[u.first+1][u.second]=='.'&&!alr[u.first+1][u.second])
            {
                alr[u.first+1][u.second]=true;
                q.push(make_pair(u.first+1,u.second));
            }
            if(s[u.first][u.second-1]=='.'&&!alr[u.first][u.second-1])
            {
                alr[u.first][u.second-1]=true;
                q.push(make_pair(u.first,u.second-1));
            }
            if(s[u.first-1][u.second]=='.'&&!alr[u.first-1][u.second])
            {
                alr[u.first-1][u.second]=true;
                q.push(make_pair(u.first-1,u.second));
            }
        }
        cnt++;
    }
    if(o) cout<<ans[tx][ty];
    else
    {
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=m;j++)
                cout<<ans[i][j]<<' ';
            cout<<endl;
        }
    }
    return 0;
}
```

---

## 作者：sbno333 (赞：2)

这是一篇 $O(nm\log nm)$ 的题解。

这是一道练习建图很好的题目。

首先发现求最少步数，而且有很多非常规走法，自然的思路是最短路建图。

考虑如何建图。

分层图显然是不优秀的。

我们考虑能否在一层把图建出来。

当然是在传送门和终点之间建边啦，问题是怎么建边呢？

我们发现如果想要到达一个节点，我们可能需要传送 $x\le q$ 次。

我们的策略是贪心找到最近的传送门，然后到达一号终点以后重复上述过程，直到到 $x$ 传送门，然后最短路到终点。

为什么呢？

考虑 $x=1$ 的时候为什么到最近传送门，假设不需要，那么就是到别的传送门或者不使用传送门，对于第一种情况，发现这样到终点显然是不优秀的，对于第二种情况，我们最短路直接去终点，这是自然的，不需要特别考虑。

对 $x>1$，我们显然要连续传送 $x$ 次到，否则是自然地，不需要特别考虑。

此时我们要尽快完成 $x$ 次，假设对于 $y<x$ 是成立这一点的，我们到了 $x-1$，发现按照 $x=1$ 也是这么走，数学归纳法得证。

于是我们就有了一个贪心策略。

考虑寻找最近传送门，发现可以把终点变为最短路里的终点，传送门变为起点，然后弄一个超级起点 $0$ 边权连接所有传送门，然后跑最短路，可以得到每个终点距离最近传送门的距离。

设第 $i$ 最近是 $f_i$。

则到达 $i$ 终点需要我们到达最近传送门后，走 $\sum\limits_{x=1}^{i-1} f_i$ 的距离。

于是我们可以做一个前缀和处理。

然后让距离起点最近的传送门连接每个终点为对应的值。

然后跑最短路即可。

值得注意的是，两点最短路可能达到 $10^{12}$，因为可能每次传送都白传送，然后原先的图起点与终点不在一个联通块，必须传送 $q$ 次才可以通过传送到达，于是乎答案可能高达 $10^{12}$，前缀和如果极大值设的太大，可能爆`long long`。

所以极大值应设在 $10^{12}\sim10^{13}$。

~~这个小点调了一个小时~~。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define endl "\n"
#define pii pair<int,int>
const int A=1e13+7,B=1e13;
bool opt;
struct st{
	int v,w,ne;
}sd[35100009];
int h[2100009];
int inn;
int n,m;
int zz;
int fx[19][2]={0,1,0,-1,1,0,-1,0};
int ans[2000009];
int ffx[2000009];
int as[2000009];
bool vis[2000009];
priority_queue<pii,vector<pii>,greater<pii> > q;
int gt(int x,int y){
	if(x>n||x<1||y>m||y<1){
		return 0;
	}
	return (x-1)*m+y;
}
bool a[2009][2009];
void add(int u,int v,int w){
	sd[++inn].v=v;
	sd[inn].w=w;
	sd[inn].ne=h[u];
	h[u]=inn;	
}
void cl(){
	memset(h,0,sizeof(h));
	inn=0;
	for(int i=0;i<2000009;i++){
		ans[i]=A;
	}
	memset(vis,0,sizeof(vis));
}
void jt(){
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(a[i][j]){
				for(int k=0;k<4;k++){
					if(a[i+fx[k][0]][j+fx[k][1]]){
						add(gt(i,j),gt(i+fx[k][0],j+fx[k][1]),1);
					}
				}
			}
		}
	}
}

int c[2000009];
int d[2000009];
void dijkstra(int s){
	ans[s]=0;
	q.push({0,s});
	while(q.size()){
		int t;
		t=q.top().second;
		q.pop();
		if(vis[t]){
			continue;
		}
		vis[t]=1;
		for(int i=h[t];i;i=sd[i].ne){
			
			if(!vis[sd[i].v]&&ans[sd[i].v]>ans[t]+sd[i].w){
				ans[sd[i].v]=ans[t]+sd[i].w;
				q.push({ans[sd[i].v],sd[i].v});
			}
		}
	}
}
signed main(){int s,t;
	std::ios::sync_with_stdio(0);
	cin.tie(0);
	cin>>opt;
	cin>>n>>m;
	cl();
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			char t;
			cin>>t;
			if(t=='.'){
				a[i][j]=1;
			}
		}
	}
	jt();
	
	int p,q;
	int sx,sy;
	cin>>sx>>sy>>p>>q;
	s=gt(sx,sy);
	zz=n*m;
	dijkstra(s);
	for(int i=1;i<=zz+10;i++){
		ffx[i]=ans[i];
	}
	cl();
	jt();
	if(opt){
		cin>>sx>>sy;
		t=gt(sx,sy);
	}
	int gg;
	gg=0;
	ffx[gg]=A;
	for(int i=1;i<=p;i++){
		int x,y;
		cin>>x>>y;
		c[i]=gt(x,y);
		if(ffx[c[i]]<=ffx[gg]){
			gg=c[i];
		}
	}
	for(int i=1;i<=q;i++){
		int x,y;
		cin>>x>>y;
		d[i]=gt(x,y);
	}
	zz=n*m+10;
	for(int i=1;i<=p;i++){
		add(zz,c[i],0);
	}
	dijkstra(zz);
	for(int i=1;i<=zz+10;i++){
		as[i]=ans[i];
	}
	cl();
	jt();
	zz=n*m;
	as[d[0]]=0;
	for(int i=1;i<=q;i++){
		as[d[i]]+=as[d[i-1]];
	}
	for(int i=1;i<=q;i++){
		add(gg,d[i],as[d[i-1]]);
	}
	dijkstra(s);
	if(!opt){
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				cout<<(ans[gt(i,j)]<B?ans[gt(i,j)]:-1)<<" ";
			}
			cout<<endl;
		}
	}else{
		cout<<(ans[t]<B?ans[t]:-1);
	}
	return 0;
}
```

---

## 作者：Night_sea_64 (赞：2)

首先，题目中明显地说了，传送到哪里只跟你传送几次有关系。所以你想要传送，只需要到离你最近的入口就可以了。这个可以以所有入口为起点跑一遍 bfs，$O(nm)$ 解决。

然后呢，可以考虑求出传送 $i$ 次到达第 $i$ 个出口的最少步数。这里可以递推，可以看出一定是传送 $i-1$ 次的答案加上第 $i-1$ 个出口离最近的入口的距离。

最后，以这 $q$ 个出口作为 $q$ 个起点再跑一遍。每个起点初始距离是有值的，所以要使用优先队列。

然后这题就做完了。感觉思维就绿题难度，评蓝可能是因为代码比较难写。

```cpp
#include<iostream>
#include<queue>
#include<cstring>
#define int long long
using namespace std;
int opt,n,m,in,out,tx,ty;
int inx[1000010],iny[1000010];
int outx[1000010],outy[1000010];
char a[1010][1010];
int dx[]={0,-1,0,1,0};
int dy[]={0,0,-1,0,1};
struct node{int x,y,step;};
bool operator<(const node &x,const node &y){
    return x.step>y.step;
}
int d1[1010][1010];//每个位置到传送入口
bool flag[1010][1010];
int d2[1000010];//使用了i次传送的最短距离
int d3[1010][1010];//最终答案
void bfs1()//算d1
{
    queue<node>q;
    memset(flag,0,sizeof(flag));
    memset(d1,999999,sizeof(d1));
    for(int i=1;i<=in;i++)
    {
        q.push({inx[i],iny[i],0});
        flag[inx[i]][iny[i]]=1;
        d1[inx[i]][iny[i]]=0;
    }
    while(!q.empty())
    {
        int x=q.front().x,y=q.front().y;
        q.pop();
        for(int i=1;i<=4;i++)
        {
            int nx=x+dx[i],ny=y+dy[i];
            if(nx<1||nx>n||ny<1||ny>m)continue;
            if(a[nx][ny]=='#')continue;
            if(flag[nx][ny])continue;
            flag[nx][ny]=1,d1[nx][ny]=d1[x][y]+1;
            q.push({nx,ny,d1[x][y]+1});
        }
    }
}
void bfs2()//算d3
{
    priority_queue<node>q;
    memset(flag,0,sizeof(flag));
    memset(d3,999999,sizeof(d3));
    for(int i=0;i<=out;i++)
    {
        q.push({outx[i],outy[i],d2[i]});
        d3[outx[i]][outy[i]]=d2[i];
    }
    while(!q.empty())
    {
        int x=q.top().x,y=q.top().y;
        q.pop();
        if(flag[x][y])continue;
        flag[x][y]=1;
        for(int i=1;i<=4;i++)
        {
            int nx=x+dx[i],ny=y+dy[i];
            if(nx<1||nx>n||ny<1||ny>m)continue;
            if(a[nx][ny]=='#')continue;
            if(d3[x][y]+1<d3[nx][ny])
            {
                d3[nx][ny]=d3[x][y]+1;
                q.push({nx,ny,d3[x][y]+1});
            }
        }
    }
}
signed main()
{
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    cin>>opt>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)cin>>a[i][j];
    cin>>outx[0]>>outy[0]>>in>>out;
    if(opt)cin>>tx>>ty;
    for(int i=1;i<=in;i++)cin>>inx[i]>>iny[i];
    for(int i=1;i<=out;i++)cin>>outx[i]>>outy[i];
    bfs1();
    for(int i=1;i<=out;i++)
    {
        d2[i]=d2[i-1]+d1[outx[i-1]][outy[i-1]];
        if(d2[i]>1e18)
        {
            for(int j=i;j<=out;j++)d2[j]=1e18;
            break;
        }
    }
    bfs2();
    if(!opt)
    {
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=m;j++)
            {
                if(d3[i][j]<1e18)cout<<d3[i][j]<<" ";
                else cout<<"-1 ";
            }
            cout<<"\n";
        }
    }
    else
    {
        if(d3[tx][ty]<1e18)cout<<d3[tx][ty]<<endl;
        else cout<<-1<<endl;
    }
    return 0;
}
```

---

## 作者：哈哈人生 (赞：1)

# 前言
个人认为这是一道神题（也可能是我少见多怪了），故写此题解来纪念一发。

~~同学半个小时就切了这题了，我太菜了，哭。~~

# 思路
如果建一个 $q$ 层的分层图，复杂度是 $O(nmq)$，看一眼数据范围发现不仅时间要炸空间也要炸。考虑空间优化成 $O(nm+q)$。

我们发现，起点 $(sx,sy)$ 到一个的最短路一定长成：先走若干（可以为 $0$）轮传送门，每次走的时候从起点 $(sx,sy)$ 或传送终点 $(c_i,d_i)$ 走到最近的传送门，然后再一步步的前往。证明可以这样想：因为这条路的每个关键点之间（起点 $(sx,sy)$ 和传送终点 $(c_i,d_i)$）的路都是最短的，加起来一定也是最短的。

把 $c_0,d_0$ 分别赋值为 $sx,sy$，我们从 $(c_i,d_i)$ 走到最近的传送门的路长为 $f_i$，那么一个点 $(u,v)$ 的最短路就是 $\sum_{i=0}^{x} f_i+y$，其中 $x(x<q)$ 为通过传送门到达的最后一个传送终点，$y$ 为从传送门到达的最后一个传送终点一步步走向 $(u,v)$ 的路长。由于传送门和传送终点固定的，所以 $f_i$ 也都是固定的且正好有 $q$ 个，我们可以在 $O(nm)$ 的时间里预处理出来（进行一遍广度优先搜索，从每个传送门走向每个传送终点）。

所以我们发现了如下建图方式（有向图）：
1. 相邻且都不为障碍的两点相互连边，边权为 $1$。这里处理的是 $\sum_{i=0}^{x} f_i+y$ 中的 $y$。
2. 起点 $(sx,sy)$ 向每个传送终点 $(c_i,d_i)(1\le i\le q)$ 连一条长度为 $\sum_{j=0}^{i-1} f_j$ 的边（因为每个传送终点只有前面被走了后面才能走，所以要把 $j\le i-1$ 的 $f_j$ 一起加起来）。这里处理的是 $\sum_{i=0}^{x} f_i+y$ 中的 $\sum_{i=0}^{x} f_i$。

建完图后跑 Dijkstra 即可。时间复杂度 $O(nm\log(nm))$。

# 代码
我在代码中把一个点 $(x,y)$ 压缩成了一个数 $(x-1)\times m+y$ 了，好跑最短路。

代码建议多封装函数，好调。


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int dx[4]= {0,0,-1,1},dy[4]= {-1,1,0,0},inf=1e18;
int op,n,m,b[1005*1005],c[1005*1005],d[1005*1005],e[1005*1005],dp[1005][1005],book[1005][1005];
int sx,sy,p,q,tx,ty;
int di,si,dis[1005*1005];
char a[1005][1005];
bool vis[1005*1005];
struct A {
	int x,y,bs,bj;
} tmp;
queue<A> qu;
struct B{
	int to,w;
};
vector<B> v[1005*1005];
struct node{
	int p,d;
};
bool operator <(node a,node b){
	return a.d>b.d;
}
priority_queue<node> qu2;
void bfs() {//预处理
	for(int i=1; i<=p; i++) {
		book[b[i]][c[i]]=i;
		dp[b[i]][c[i]]=0;
		qu.push({b[i],c[i],0,i});
	}
	while(!qu.empty()) {
		tmp=qu.front();
		qu.pop();
		for(int i=0; i<4; i++) {
			int nx=tmp.x+dx[i],ny=tmp.y+dy[i];
			if(nx<1||ny<1||nx>n||ny>m||a[nx][ny]=='#'||book[nx][ny])continue;
			book[nx][ny]=tmp.bj;
			dp[nx][ny]=tmp.bs+1;
			qu.push({nx,ny,tmp.bs+1,tmp.bj});
		}
	}
}
int xyto(int x,int y){//压缩点的函数
	return (x-1)*m+y;
}
int pto1(int p){//把压缩的数变回点的函数
	return (int)ceil(1.0*p/m);
}
int pto2(int p){
	if(p%m)return p%m;
	else return m;
}
void build(){//建图
	di=n*m;
	si=xyto(sx,sy);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(a[i][j]=='#')continue;
			for(int k=0;k<4;k++){
				int nx=i+dx[k],ny=j+dy[k];
				if(nx<1||ny<1||nx>n||ny>m||a[nx][ny]=='#')continue;
				v[xyto(i,j)].push_back({xyto(nx,ny),1});
			}
		}
	}
	int sum=0;
	d[0]=sx,e[0]=sy;
	for(int i=1;i<=q;i++){
		int j=book[d[i-1]][e[i-1]];
		sum+=dp[d[i-1]][e[i-1]];
		if(j==0)break;
		v[xyto(sx,sy)].push_back({xyto(d[i],e[i]),sum});
	}
}
void dik(){//跑最短路
	for(int i=0;i<=di;i++)dis[i]=inf;
	dis[si]=0;
	qu2.push(node{si,dis[si]});
	while(!qu2.empty()){
		int u=qu2.top().p;		
		qu2.pop();
		if(vis[u])continue;
		vis[u]=1;
		for(int i=0;i<v[u].size();i++){
			int to=v[u][i].to,w=v[u][i].w;
			if(dis[to]>dis[u]+w){
				dis[to]=dis[u]+w;
				qu2.push(node{to,dis[to]});
			}
		}
	}
}
void hui(){//统计答案
	for(int i=1;i<=n*m;i++)dp[pto1(i)][pto2(i)]=dis[i];
}
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>op>>n>>m;
	for(int i=1; i<=n; i++) {
		for(int j=1; j<=m; j++) {
			cin>>a[i][j];
			dp[i][j]=inf;
		}
	}
	cin>>sx>>sy>>p>>q;
	if(op==1)cin>>tx>>ty;
	for(int i=1; i<=p; i++)cin>>b[i]>>c[i];
	for(int i=1; i<=q; i++)cin>>d[i]>>e[i];
	bfs();
	build();
	dik();
	hui();
	if(op==0) {
		for(int i=1; i<=n; i++) {
			for(int j=1; j<=m; j++) {
				if(dp[i][j]!=inf)cout<<dp[i][j]<<" ";
				else cout<<-1<<" ";
			}
			cout<<"\n";
		}
	} else cout<<(dp[tx][ty]==inf?-1:dp[tx][ty]);
	return 0;
}
```

---

## 作者：under_the_time (赞：1)

## 题意

> 给定一个 $n\times m$ 的地图，有些点不能走；其中有 $p$ 个传送点和 $q$ 个传送终点（统称为特殊点）。如果在路径中进行了 $k$ 次传送，那么在这之后第一次使用传送点，传送到的位置为第 $k+1$ 个传送终点。$q$​ 次传送后无法使用传送点，传送不计入步数。求从给定一点出发到其他点的最短路。经过传送点时可以选择是否传送。
>
> $n,m\le10^3$，$p,q\le n\times m$。保证特殊点的坐标两两不同。

## 思路

第一眼分层图，然后发现边数爆炸，考虑将原本的 $O(nmq)$ 的边数降到 $O(nm+q)$。我们想一下传送的情景。观察到每次传送起点随意终点固定，如果我们想要通过传送门走到第 $k$ 个传送终点，那么我们先直接从起点出发，走到最近的传送门，传送到第一个传送终点；然后从第一个传送终点再走到最近的传送门，传送到第二个，以此类推，刷传送门刷 $k$ 次就到了。于是一条最短路一定长成：先无脑刷 $0$ 轮或若干轮传送门，每次刷的时候从传送终点走到最近的传送门；然后再从某一个传送终点出发徒步前往。

刷传送门的过程我们考虑直接从起点向每个传送终点建一条边表示，跑最短路，然后就做的差不多了。

## 实现

每次 bfs 或者 Dijkstra 的时候带两个坐标很不爽，于是我们将每个坐标映射成一个唯一的数，比如说对于坐标 $(x,y)$，那么映射值即为 $m(x-1)+y$。先遍历地图上的每个点，把上下左右能走的点进行连边，边的端点都是坐标的映射值。这样代码就会好写很多。

第一步需要处理出每个传送终点和起点到最近的传送点的距离。我们考虑反着来，以每个传送点为起点走，实现方法就是 bfs 初始时把每个传送门都扔进队列里。然后我们按照顺序建边即可。如果发现某一个传送终点或者起点走不到传送门那么就停止继续建边。注意这一步新建的边的边权要开 `long long`。

第二步就是跑最短路了，上个 Dijkstra；由于点数和边数同阶所以用堆优化版本即可。$opt$ 为 $0$ 为 $1$ 同个做法做就行。时间复杂度 $O(nm\log (nm))$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 1e3 + 5, maxm = maxn * maxn;
char mp[maxn][maxn];
int n, m;
int getid(int x, int y) { return (x - 1) * m + y; }
// pair<int, int> getpos(int id) { return { id / m + 1, id % m }; }
const int WAY[] = { 0, 1, 0, -1, 0 };
#define ll long long
namespace Graph {
    struct Edge { int to, nxt; ll val; } e[(maxm << 2) + maxm];
    int head[maxm], ecnt = 0;
    void addEdge(int u, int v, ll w) {
        if (u == v) return ; // 可能可以防一下起点为传送点或者传送终点，不加应该问题不大。
        e[++ ecnt] = Edge { v, head[u], w };
        head[u] = ecnt;
    }
    void create_graph() { // 建图
        for (int i = 1; i <= n; i ++)
            for (int j = 1; j <= m; j ++) if (mp[i][j] != '#')
                for (int k = 0; k < 4; k ++) {
                    int x = i + WAY[k], y = j + WAY[k + 1];
                    if (x < 1 || y < 1 || x > n || y > m || mp[x][y] == '#') continue;
                    addEdge(getid(i, j), getid(x, y), 1);
                }
    }
} using namespace Graph;
int pc, qc; int target[maxm], door[maxm];
ll dis[maxm]; queue<int> q; bool vis[maxm];
int start, end;
const ll inf = 1e18;
void create_door_path() { // 建从起点向各个传送点的边。
    for (int i = 1; i <= n; i ++) for (int j = 1; j <= m; j ++)
        dis[getid(i, j)] = inf;
    for (int i = 1; i <= pc; i ++)
        dis[door[i]] = 0, q.push(door[i]), vis[door[i]] = 1;
    while (!q.empty()) {
        int u = q.front(); q.pop(); 
        for (int i = head[u], v; i; i = e[i].nxt) {
            if (vis[v = e[i].to]) continue;
            vis[v] = 1, dis[v] = dis[u] + 1, q.push(v);
        }
    }
    if (dis[start] == inf) return ;
    ll w = dis[start]; addEdge(start, target[1], w);
    for (int i = 1; i < qc; i ++) {
        if (dis[target[i]] == inf) return ;
        w += dis[target[i]], addEdge(start, target[i + 1], w);
    }
}
priority_queue<pair<ll, int> > p;
void solve() { // 跑 Dijkstra。
    for (int i = 1; i <= n; i ++) for (int j = 1; j <= m; j ++)
        dis[getid(i, j)] = inf, vis[getid(i, j)] = 0;
    p.push({dis[start] = 0, start});
    while (!p.empty()) {
        int u = p.top().second; p.pop();
        if (vis[u]) continue; vis[u] = 1; ll w;
        for (int i = head[u], v; i; i = e[i].nxt) {
            if (dis[u] + (w = e[i].val) < dis[v = e[i].to]) {
                dis[v] = dis[u] + w;
                if (!vis[v]) p.push({-dis[v], v});
            }
        }
    }
}
int main() {
    int subtask; scanf("%d", &subtask);
    scanf("%d %d", &n, &m);
    for (int i = 1; i <= n; i ++) scanf("%s", mp[i] + 1);
    int sx, sy, tx, ty; scanf("%d %d %d %d", &sx, &sy, &pc, &qc);
    if (subtask == 1) scanf("%d %d", &tx, &ty); 
    start = getid(sx, sy);
    for (int i = 1, x, y; i <= pc; i ++) 
        scanf("%d %d", &x, &y), door[i] = getid(x, y);
    for (int i = 1, x, y; i <= qc; i ++)
        scanf("%d %d", &x, &y), target[i] = getid(x, y);
    create_graph(), create_door_path(), solve();
    if (subtask == 1) return printf("%lld", dis[getid(tx, ty)] == inf ? -1 : dis[getid(tx, ty)]), 0;
    for (int i = 1; i <= n; i ++)
        for (int j = 1; j <= m; j ++)
            printf("%lld%c", dis[getid(i, j)] == inf ? -1 : dis[getid(i, j)], " \n"[j == m]);
    return 0;
}
```

---

## 作者：huangrenheluogu (赞：0)

思考其实并不困难，但是细节没有考虑周全，赛时没 A，就不想写 T3 了。

注：记题解中传送门为传送出来的点（共 $q$ 个），可传送点就是 $p$ 个点中的一个。

为了方便，不妨记 $(sx,sy)$ 为第 $0$ 个传送门。

考虑这 $q$ 个传送门需要按照顺序到达非常神秘，可以发现到达第 $i$ 个传送门的路径形如到达第 $i-1$ 个传送门，然后从第 $i-1$ 个传送门到达最近的可传送的点，就到达了第 $i$ 个传送门。

前面是一个子问题，第 $i-1$ 个传送门到最近可以传送的点可以以 $p$ 个可传送点为源点跑最短路就可以了。

这样，处理出了到达第 $i$ 个传送门的距离，钦定第 $i$ 个传送门是最后一次传送出来的位置，然后跑多源最短路就可以了。

需要注意的点（赛时没有想到）：由于可以传送 $\mathcal{O}(q)$ 次，每次可以走 $\mathcal{O}(nm)$ 的路径，所以应该开 long long。赛时以为最长路径是 $\mathcal{O}(nm)$ 的，于是爆了。

开始写了 Dijsktra，写到一半发现可以 bfs，但是懒的改了。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1005, inf = 0x3f3f3f3f3f3f3f3f;
int n, m, p, q, opt, sx, sy, tx, ty;
bool mp[N][N], vis[N][N];
char s[N];
int dist[N][N], dis[N * N], x, y, nx, ny;
int dx[4] = {0, 1, 0, -1};
int dy[4] = {1, 0, -1, 0};
struct node{
	int x, y;
}a[N * N];
struct Node{
	int x, y, dist;
}tp;
inline bool operator < (Node x, Node y){
	return x.dist > y.dist;
}
priority_queue<Node> Q;
inline void Dijkstra(){
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= m; j++){
			vis[i][j] = 0;
		}
	}
	while(!Q.empty()){
		tp = Q.top();
		Q.pop();
		x = tp.x, y = tp.y;
		if(vis[x][y]) continue ;
		vis[x][y] = 1;
		for(int i : {0, 1, 2, 3}){
			nx = x + dx[i], ny = y + dy[i];
			if(mp[nx][ny] || nx < 1 || nx > n || ny < 1 || ny > m) continue ;
			if(dist[nx][ny] > tp.dist + 1){
				dist[nx][ny] = tp.dist + 1;
				Q.push({nx, ny, tp.dist + 1});
			}
		}
	}
}
signed main(){
//	freopen("data.in", "r", stdin);
//	freopen("code.out", "w", stdout);
	scanf("%lld", &opt);
	scanf("%lld%lld", &n, &m);
	for(int i = 1; i <= n; i++){
		scanf("%s", s + 1);
		for(int j = 1; j <= m; j++){
			mp[i][j] = s[j] == '#' ? 1 : 0;
		}
	}
	memset(dist, 0x3f, sizeof(dist));
	scanf("%lld%lld%lld%lld", &sx, &sy, &p, &q);
	if(opt) scanf("%lld%lld", &tx, &ty);
	a[0] = {sx, sy};
	for(int i = 1; i <= p; i++){
		scanf("%lld%lld", &x, &y);
		dist[x][y] = 0;
		Q.push({x, y, 0});
	}
	for(int i = 1; i <= q; i++){
		scanf("%lld%lld", &a[i].x, &a[i].y);
	}
	Dijkstra();
	memset(dis, 0x3f, sizeof(dis));
	dis[0] = 0;
	for(int i = 1; i <= q; i++){
		dis[i] = min(dis[i], dis[i - 1] + dist[a[i - 1].x][a[i - 1].y]);
	}
	memset(dist, 0x3f, sizeof(dist));
	for(int i = 0; i <= q; i++){
		if(dis[i] == inf) continue ;
		dist[a[i].x][a[i].y] = min(dist[a[i].x][a[i].y], dis[i]);
		Q.push({a[i].x, a[i].y, dis[i]});
	}
	Dijkstra();
	if(opt){
		printf("%lld\n", dist[tx][ty] == inf ? -1ll : dist[tx][ty]);
	}
	else{
		for(int i = 1; i <= n; i++){
			for(int j = 1; j <= m; j++){
				if(dist[i][j] == inf) printf("%lld ", -1ll);
				else printf("%lld ", dist[i][j]);
			}
			puts("");
		}
	}
	return 0;
}
```

---

## 作者：SamHJD (赞：0)

> 给出一个 $n\times m$  的网格，有些地方有障碍。有 $p$ 个传送门，第 $i$ 次传送会传送至 $(c_i,d_i)$，不消耗时间，最多传送 $q$ 次。你可以从一个格子走到其上下左右相邻的一个格子，或在传送门处选择传送，求起点 $(sx,sy)$ 到达每个位置的最短时间。

设到某位置一共用了 $k$ 次传送，观察从起点到第 $k$ 次传送结束的这段路径，我们每次都是从当前位置走到距离最近的一个传送门并传送，于是设 $near_{i,j}$ 表示 $(i,j)$ 到最近的传送门的距离，则传送 $k$ 次的最短时间为 $t_i=near_{sx,sy}+\sum_{i=1}^{k-1}near_{c_i,d_i}$，$near_{i,j}$ 可以使用 bfs 处理出。

建立一个源点，向 $(c_i,d_i)$ 连一条长为 $t_i$ 的边，网格上的点向上下左右建长为 $1$ 的边，跑 dijkstra 即可。

```cpp
//INF 的大小需要注意，tim 数组可能会爆 long long

#include<bits/stdc++.h>
#define int long long
#define rep(i,k,n) for(int i=k;i<=n;++i)
#define per(i,n,k) for(int i=n;i>=k;--i)
using namespace std;
template<typename T>
inline void read(T &x){
	x=0;int f=1;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(c-'0');
	x*=f;
}
const int N=1010,INF=0x3f3f3f3f3f;
int OP,n,m,mp[N][N],id[N][N],tot,near[N][N],vis[N][N],isp[N][N];
int sx,sy,P,Q,tx,ty;
int A[N*N],B[N*N],C[N*N],D[N*N],tim[N*N];
int dx[]={0,1,-1,0,0};
int dy[]={0,0,0,1,-1};
void get_distance(){
	queue<pair<int,int> > q;
	rep(i,1,n) rep(j,1,m) near[i][j]=INF;
	rep(i,1,n) rep(j,1,m) vis[i][j]=0;
	rep(i,1,P){
		q.push({A[i],B[i]});
		vis[A[i]][B[i]]=1;
		near[A[i]][B[i]]=0;	
	}
	while(!q.empty()){
		pair<int,int> now=q.front();
		q.pop();
		rep(i,1,4){
			int TX=now.first+dx[i],TY=now.second+dy[i];
			if(TX<=n&&TY<=m&&TX>=1&&TY>=1&&mp[TX][TY]==0&&vis[TX][TY]==0){
				near[TX][TY]=near[now.first][now.second]+1;
				vis[TX][TY]=1;
				q.push({TX,TY});
			}
		}
	}
}
struct node{
	int x,y;
	bool operator <(const node &b) const{
		return x*y<b.x*b.y;
	}
};
priority_queue<pair<int,node> > q;
int dis[N][N];
void dijkstra(){
	rep(i,1,n) rep(j,1,m) vis[i][j]=0,dis[i][j]=INF;
	q.push({0,{sx,sy}});dis[sx][sy]=0;
	rep(i,1,Q){
		if(tim[i]>=INF) continue;
		q.push({-tim[i],{C[i],D[i]}}),dis[C[i]][D[i]]=tim[i];
	}
	while(!q.empty()){
		node now=q.top().second;
		q.pop();
		if(vis[now.x][now.y]) continue;
		vis[now.x][now.y]=1;
		rep(i,1,4){
			int TX=now.x+dx[i],TY=now.y+dy[i];
			if(TX<=n&&TY<=m&&TX>=0&&TY>=0&&mp[TX][TY]==0){
				if(dis[TX][TY]>dis[now.x][now.y]+1){
					dis[TX][TY]=dis[now.x][now.y]+1;
					dis[TX][TY]=min(dis[TX][TY],INF);
					q.push({-dis[TX][TY],{TX,TY}});
				}
			}
		}
	}
}
signed main(){
	read(OP);read(n);read(m);
	rep(i,1,n) rep(j,1,m){
		char c;cin>>c;
		if(c=='.') mp[i][j]=0;
		else mp[i][j]=1;
	}
	read(sx);read(sy);read(P);read(Q);
	if(OP==1) read(tx),read(ty);
	rep(i,1,P) read(A[i]),read(B[i]);
	rep(i,1,Q) read(C[i]),read(D[i]);
	get_distance();
	C[0]=sx;D[0]=sy;
	rep(i,1,Q){
		tim[i]=tim[i-1]+near[C[i-1]][D[i-1]];
		tim[i]=min(tim[i],INF);
	}
	dijkstra();
	if(OP==1){
		if(dis[tx][ty]>=INF||mp[tx][ty]) printf("-1");
		else printf("%lld",dis[tx][ty]);
		return 0;
	}
	rep(i,1,n){
		rep(j,1,m){
			if(mp[i][j]||dis[i][j]>=INF) printf("-1 ");
			else printf("%lld ",dis[i][j]);
		}
		puts("");
	}
	return 0;
}
```

---


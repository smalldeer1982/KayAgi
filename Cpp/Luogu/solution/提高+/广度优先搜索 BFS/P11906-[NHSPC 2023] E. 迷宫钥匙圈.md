# [NHSPC 2023] E. 迷宫钥匙圈

## 题目描述

小咪到夜市玩游戏，赢得了一副钥匙圈。这副钥匙圈上有个迷宫面板，里面有许多小钢珠：

![](https://cdn.luogu.com.cn/upload/image_hosting/dq75b0np.png)

将钥匙圈的面板向左或向右旋转 $90$ 度，可以使每颗仍在迷宫内的小钢珠向下掉落，直到该小钢珠掉出迷宫，碰到迷宫挡板，或碰到其他仍在迷宫内的小钢珠为止。更明确地说，这座迷宫可以用 $N\times M$ 的二维矩阵表示，一次的 $90$ 度旋转会将迷宫变换为 $M\times N$ 的二维矩阵，其中

* 一次 $90$ 度左旋转会将位置 $(i, j)$ 变换为位置 $(M-j+1, i)$。
* 一次 $90$ 度右旋转会将位置 $(i, j)$ 变换为位置 $(j, N-i+1)$。

此外，若旋转后位置 $(i, j)$ 有一颗小钢珠，则

* 若存在某个 $i' > i$ 满足 $(i', j)$ 为迷宫挡板，则
   1. 设最小的 $i'$ 为 $i^*$。
   1. 若 $(i, j), (i+1, j), \ldots, (i^*-1, j)$ 间恰好有 $k$ 颗小钢珠，则原位置 $(i, j)$ 的小钢珠会掉到位置 $(i^*-k, j)$。
* 否则，该小钢珠将掉出迷宫。

给定迷宫与小钢珠的初始位置，请算出至少需要向左或向右旋转 $90$ 度几次，才能使每颗小钢珠都掉出迷宫。

以下是一个迷宫大小为 $10\times7$ 的例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/5rb8przv.png)

## 说明/提示

### 测试数据限制

* $1 \le n \le 15$。
* $1 \le m \le 15$。
* 对任意 $i \in \{1, 2, \ldots, n\}$ 与 $j \in \{1, 2, \ldots, m\}$，$s_{i, j}$ 只能是 ``b``、``s``、或 ``w``。
* 满足 $s_{i, j}$ 为 ``b`` 的 $(i, j)$ 对数介于 $1$ 与 $3$ 之间。
* 给定的迷宫保证不会有不稳定的状况，即若 $s_{i, j}$ 为 ``b``，则必定存在某个 $i^* > i$ 满足
  1. $s_{i^*, j}$ 为 ``w``。
  1. $s_{i, j}, s_{i+1, j}, \ldots, s_{i^*-1, j}$ 均为 ``b``。
* $n$ 与 $m$ 皆为整数。

### 评分说明

本题共有三组子任务，条件限制如下所示。
每一组可有一或多个测试数据，该组所有测试数据皆需答对才可获得该组分数。

|  子任务  |  分数  | 额外输入限制 |
| :------: | :----: | ------------ |
| 1 | $37$ | 迷宫里的小钢珠数量为 $1$ |
| 2 | $29$ | 迷宫里的小钢珠数量不超过 $2$ |
| 3 | $34$ | 无额外限制 |

## 样例 #1

### 输入

```
10 7
w w w w w w w
w s s s s s w
w s s s s s w
w s w w w s w
w s s s w s w
w s b b w s w
w w w w w s w
s s s s s s w
s s s s s s w
w w w w w w w```

### 输出

```
7```

## 样例 #2

### 输入

```
5 3
s w s
s s s
w b w
w b w
s w s```

### 输出

```
5```

## 样例 #3

### 输入

```
5 3
s w s
w s w
s b s
w b w
s w s```

### 输出

```
-1```

# 题解

## 作者：wangyizhi (赞：3)

[**题目传送门**](https://www.luogu.com.cn/problem/P11906)

诈骗题。

就是写起来有点恶心。。。（当然也可能是我的问题。。。）

## 题目分析

以下记小钢珠的数量为 $k$。

感觉直接不是很能做？看到 $n,m\le 15$，$k\le 3$，果断暴力。

称当前小钢珠的位置和重力方向为一个局面。将每个局面看作一个点，那么两种操作就是点之间的边（废话），且一个点只有两条出边。

显然点数是 $O((nm)^k)$ 的，则边数也是 $O((nm)^k)$ 的。注意到这个数大概在 $10^7\sim 10^8$ ，于是果断 bfs，然后就过了。具体模拟就不说了，实在不行的可以看代码。实测常数很小，不卡常最慢的点也只跑了 15ms。

## AC Code

```cpp
#include<bits/stdc++.h>
//#include<bits/extc++.h>
using namespace std;
using ll=long long;
using ld=long double;
//#define int ll
using pii=pair<int,int>;
//bool Mst;
const int N=16;
bool mp[N][N];
int nxt[4][N][N];
int dx[4]={1,0,-1,0};
int dy[4]={0,1,0,-1};
bitset<100000000> to;
map<int,int> en;
int n,m,k;
struct pt
{
	int x,y;
};
struct node
{
	int dir;
	pt a[3];
	node(pt a0={0,0},pt a1={0,0},pt a2={0,0},int d=0){dir=d,a[0]=a0,a[1]=a1,a[2]=a2;}
	inline int get()
	{
		return dir*N*N*N*N*N*N+a[2].x*N*N*N*N*N+a[2].y*N*N*N*N+a[1].x*N*N*N+a[1].y*N*N+a[0].x*N+a[0].y;
	}
	inline void tagall()
	{
		to[node(a[0],a[1],a[2],dir).get()]=1;
		to[node(a[0],a[2],a[1],dir).get()]=1;
		to[node(a[1],a[0],a[2],dir).get()]=1;
		to[node(a[1],a[2],a[0],dir).get()]=1;
		to[node(a[2],a[0],a[1],dir).get()]=1;
		to[node(a[2],a[1],a[0],dir).get()]=1;
	}
};
inline node turn(node nd,int op)
{
	nd.dir=(nd.dir+op+4)%4;
	for(int i=0;i<k;i++) if(nd.a[i].x<n&&nd.a[i].y<m)
	{
		if(nd.dir&1) nd.a[i]={nd.a[i].x,nxt[nd.dir][nd.a[i].x][nd.a[i].y]-dy[nd.dir]};
		else nd.a[i]={nxt[nd.dir][nd.a[i].x][nd.a[i].y]-dx[nd.dir],nd.a[i].y};
	}
	int tmp[N][N];
	memset(tmp,0,sizeof(tmp));
	for(int i=0;i<k;i++)
	{
		if(nd.a[i].x<0||nd.a[i].y<0||nd.a[i].x==n||nd.a[i].y==m) nd.a[i].x=n,nd.a[i].y=m;
		else
		{
			while(tmp[nd.a[i].x][nd.a[i].y]) nd.a[i].x-=dx[nd.dir],nd.a[i].y-=dy[nd.dir];
			tmp[nd.a[i].x][nd.a[i].y]=1;
		}
	}
	return nd;
}
//bool Med;
signed main()
{
//	cerr<<"Memory Size: "<<abs((&Med)-(&Mst))/1024.0/1024<<" MB\n";
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>m;
	node st,eee;
	int ans=-1;
	st.dir=0;
	for(int i=0;i<n;i++) for(int j=0;j<m;j++)
	{
		char op;
		cin>>op;
		if(op=='w') mp[i][j]=1;
		else mp[i][j]=0;
		if(op=='b') eee.a[k]={n,m},st.a[k++]={i,j};
	}
	for(int i=0;i<4;i++) eee.dir=i,en[eee.get()]=1;
	for(int i=0;i<m;i++) nxt[0][n-1][i]=mp[n-1][i]?n-1:-114;
	for(int i=n-2;i>=0;i--) for(int j=0;j<m;j++) nxt[0][i][j]=mp[i][j]?i:nxt[0][i+1][j];
	for(int i=0;i<n;i++) nxt[1][i][m-1]=mp[i][m-1]?m-1:-114;
	for(int j=m-2;j>=0;j--) for(int i=0;i<n;i++) nxt[1][i][j]=mp[i][j]?j:nxt[1][i][j+1];
	for(int i=0;i<m;i++) nxt[2][0][i]=mp[0][i]?0:-114;
	for(int i=1;i<n;i++) for(int j=0;j<m;j++) nxt[2][i][j]=mp[i][j]?i:nxt[2][i-1][j];
	for(int i=0;i<n;i++) nxt[3][i][0]=mp[i][0]?0:-114;
	for(int j=1;j<m;j++) for(int i=0;i<n;i++) nxt[3][i][j]=mp[i][j]?j:nxt[3][i][j-1];
	queue<pair<node,int>> q;
	q.push({st,0}),st.tagall();
	while(q.size())
	{
		node p=q.front().first;int dis=q.front().second;q.pop();
		if(en[p.get()])
		{
			ans=dis;
			break;
		}
		{
			node pp=turn(p,1);
			if(!to[pp.get()]) pp.tagall(),q.push({pp,dis+1});
		}
		{
			node pp=turn(p,-1);
			if(!to[pp.get()]) pp.tagall(),q.push({pp,dis+1});
		}
	}
	cout<<ans<<"\n";
	return 0;
}
```

---

## 作者：SunburstFan (赞：0)

## [P11906 [NHSPC 2023] E. 迷宫钥匙圈](https://www.luogu.com.cn/problem/P11906)

### 题目大意

给定一个由字母表示的迷宫面板,每一次将迷宫向左或向右旋转 $90$ 度，所有还在迷宫内的小钢珠会按照特定规则“下落”——直到掉出迷宫、碰到挡板或碰到其它已停稳的小钢珠。求至少需要多少次旋转（仅允许左旋或右旋）才能使所有小钢珠都掉出迷宫。

### 解题思路

搜索题。

将迷宫看作二维矩阵，每次旋转分别实现左旋或右旋操作。

对于旋转后的矩阵，逐列模拟小钢珠的下落过程：
   - 找到每个小钢珠下降路径中最先遇到的挡板，并根据该列已有的小钢珠数确定最终落点；
   - 若该列没有挡板，则对应的小钢珠会掉出迷宫（状态中移除）。
  
将每一次旋转后的状态（迷宫中小钢珠的位置配置）作为一个状态节点，用 BFS 从初始状态开始搜索：
   - 当某状态下迷宫中已无小钢珠时，即找到答案，输出所需旋转次数；
   - 若遍历所有可能状态都无法清空小钢珠，则输出 $-1$。

```cpp
#include<iostream>
#include<cstring>
#include<queue>
#include<array>

using namespace std;

const int N=17;

int f[N][N][N][N][N][N][2];
char s[N+1][N+1];
int n,m;

namespace sunburstfan{
    int check(int x,int y){
        if(x+y==0)return 1;
        if(x<1||x>n)return 1;
        if(y<1||y>m)return 1;
        return 0;
    }

    bool left_rotate(int x[3],int y[3],int res,queue<array<int,7>>&q){
        int xx[3]={0},yy[3]={0},d[3]={0};
        
        for(int i=0;i<=2;i++){
            if(check(x[i],y[i])){
                xx[i]=x[i];
                yy[i]=y[i];
                continue;
            }
            xx[i]=x[i];
            for(int j=y[i]-1;j>=0;j--){
                if(!j||s[x[i]][j]=='w'){
                    yy[i]=j+(j>0);
                    break;
                }
            }
        }
        
        if(check(xx[0],yy[0])&&check(xx[1],yy[1])&&check(xx[2],yy[2])){
            return true;
        }
        
        for(int i=0;i<=2;i++){
            d[i]=0;
            for(int j=0;j<=2;j++){
                if(j==i)continue;
                if(x[j]==x[i]&&y[j]<y[i]&&y[j]>=yy[i])d[i]++;
            }
        }
        
        for(int i=0;i<=2;i++)yy[i]+=d[i];
        
        if(f[xx[0]][yy[0]][xx[1]][yy[1]][xx[2]][yy[2]][1]>res+1){
            f[xx[0]][yy[0]][xx[1]][yy[1]][xx[2]][yy[2]][1]=res+1;
            q.push({xx[0],yy[0],xx[1],yy[1],xx[2],yy[2],1});
        }
        
        return false;
    }

    bool right_rotate(int x[3],int y[3],int res,queue<array<int,7>>&q){
        int xx[3]={0},yy[3]={0},d[3]={0};
        
        for(int i=0;i<=2;i++){
            if(check(x[i],y[i])){
                xx[i]=x[i];
                yy[i]=y[i];
                continue;
            }
            xx[i]=x[i];
            for(int j=y[i]+1;j<=m+1;j++){
                if(j>m||s[x[i]][j]=='w'){
                    yy[i]=j-(j<=m);
                    break;
                }
            }
        }
        
        if(check(xx[0],yy[0])&&check(xx[1],yy[1])&&check(xx[2],yy[2])){
            return true;
        }
        
        for(int i=0;i<=2;i++){
            d[i]=0;
            for(int j=0;j<=2;j++){
                if(j==i)continue;
                if(x[j]==x[i]&&y[j]>y[i]&&y[j]<=yy[i])d[i]++;
            }
        }
        
        for(int i=0;i<=2;i++)yy[i]-=d[i];
        
        if(f[xx[0]][yy[0]][xx[1]][yy[1]][xx[2]][yy[2]][1]>res+1){
            f[xx[0]][yy[0]][xx[1]][yy[1]][xx[2]][yy[2]][1]=res+1;
            q.push({xx[0],yy[0],xx[1],yy[1],xx[2],yy[2],1});
        }
        
        return false;
    }

    bool up_rotate(int x[3],int y[3],int res,queue<array<int,7>>&q){
        int xx[3]={0},yy[3]={0},d[3]={0};
        
        for(int i=0;i<=2;i++){
            if(check(x[i],y[i])){
                xx[i]=x[i];
                yy[i]=y[i];
                continue;
            }
            yy[i]=y[i];
            for(int j=x[i]-1;j>=0;j--){
                if(!j||s[j][y[i]]=='w'){
                    xx[i]=j+(j>0);
                    break;
                }
            }
        }
        
        if(check(xx[0],yy[0])&&check(xx[1],yy[1])&&check(xx[2],yy[2])){
            return true;
        }
        
        for(int i=0;i<=2;i++){
            d[i]=0;
            for(int j=0;j<=2;j++){
                if(j==i)continue;
                if(y[j]==y[i]&&x[j]<x[i]&&x[j]>=xx[i])d[i]++;
            }
        }
        
        for(int i=0;i<=2;i++)xx[i]+=d[i];
        
        if(f[xx[0]][yy[0]][xx[1]][yy[1]][xx[2]][yy[2]][0]>res+1){
            f[xx[0]][yy[0]][xx[1]][yy[1]][xx[2]][yy[2]][0]=res+1;
            q.push({xx[0],yy[0],xx[1],yy[1],xx[2],yy[2],0});
        }
        
        return false;
    }

    bool down_rotate(int x[3],int y[3],int res,queue<array<int,7>>&q){
        int xx[3]={0},yy[3]={0},d[3]={0};
        
        for(int i=0;i<=2;i++){
            if(check(x[i],y[i])){
                xx[i]=x[i];
                yy[i]=y[i];
                continue;
            }
            yy[i]=y[i];
            for(int j=x[i]+1;j<=n+1;j++){
                if(j>n||s[j][y[i]]=='w'){
                    xx[i]=j-(j<=n);
                    break;
                }
            }
        }
        
        if(check(xx[0],yy[0])&&check(xx[1],yy[1])&&check(xx[2],yy[2])){
            return true;
        }
        
        for(int i=0;i<=2;i++){
            d[i]=0;
            for(int j=0;j<=2;j++){
                if(j==i)continue;
                if(y[j]==y[i]&&x[j]>x[i]&&x[j]<=xx[i])d[i]++;
            }
        }
        
        for(int i=0;i<=2;i++)xx[i]-=d[i];
        
        if(f[xx[0]][yy[0]][xx[1]][yy[1]][xx[2]][yy[2]][0]>res+1){
            f[xx[0]][yy[0]][xx[1]][yy[1]][xx[2]][yy[2]][0]=res+1;
            q.push({xx[0],yy[0],xx[1],yy[1],xx[2],yy[2],0});
        }
        
        return false;
    }
}
using namespace sunburstfan;

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    
    memset(f,0x3f,sizeof(f));
    
    cin>>n>>m;
    int sx1=0,sy1=0,sx2=0,sy2=0,sx3=0,sy3=0;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin>>s[i][j];
            if(s[i][j]=='b'){
                if(!sx1)sx1=i,sy1=j;
                else if(!sx2)sx2=i,sy2=j;
                else if(!sx3)sx3=i,sy3=j;
            }
        }
    }
    
    queue<array<int,7>>q;
    int id=0;
    f[sx1][sy1][sx2][sy2][sx3][sy3][0]=0;
    q.push({sx1,sy1,sx2,sy2,sx3,sy3,id});
    
    while(!q.empty()){
        int x[3],y[3];
        x[0]=q.front()[0],y[0]=q.front()[1];
        x[1]=q.front()[2],y[1]=q.front()[3];
        x[2]=q.front()[4],y[2]=q.front()[5];
        id=q.front()[6];
        q.pop();
        
        int res=f[x[0]][y[0]][x[1]][y[1]][x[2]][y[2]][id];
        
        if(!id){
            if(left_rotate(x,y,res,q)){
                cout<<res+1;
                return 0;
            }
            
            if(right_rotate(x,y,res,q)){
                cout<<res+1;
                return 0;
            }
        }
        else{
            if(up_rotate(x,y,res,q)){
                cout<<res+1;
                return 0;
            }
            
            if(down_rotate(x,y,res,q)){
                cout<<res+1;
                return 0;
            }
        }
    }
    
    cout<<-1;
    return 0;
}
```

---

## 作者：DengStar (赞：0)

[在博客园中查看](https://www.cnblogs.com/dengstar/p/18779895/solution-NHSPC2023)

> bfs，模拟

直接 bfs 就好。

由于小钢珠的个数不超过 $3$ 个，所以可以用坐标集合 $\{(x_{1}, y_{1}), (x_{2}, y_{2}), (x_{3}, y_{3})\}$ 加上方向来表示一个状态。对于已经掉出迷宫的小钢珠，不妨用 $(-1, -1)$ 来表示。因此状态的个数为 $O(n^3m^3)$。

转移时，不妨把旋转迷宫想象成改变重力的方向。可以直接模拟求出旋转后小钢珠的新位置。如果只有一个小钢珠，模拟沿重力方向下落的过程，直到掉出迷宫或者碰到障碍。如果有多个小钢珠，还要考虑小钢珠之间互相阻挡的问题。我的做法比较暴力：对每个小钢珠分别模拟掉落的过程，但途中遇到别的小钢珠也要停止。由于只有 $3$ 个小钢珠，所以模拟 $3$ 次以后一定能得到正确的位置。精细实现的话肯定更快，但能过就不要给自己增加代码难度了。

细节可能有点多，下面列举几个，其余见代码（在开头的链接中）：

1. 所有小钢珠都是相同的，所以存储小钢珠坐标时应该使用无序容器（`set` 等），而非 `vector` 等有序容器。

1. 又由于用 $(-1, -1)$ 表示掉出去的小钢珠，所以小钢珠的坐标可能相同，因此应该用 `multiset` 存储小钢珠的坐标。

[AC 记录](https://www.luogu.com.cn/record/208831682)

---


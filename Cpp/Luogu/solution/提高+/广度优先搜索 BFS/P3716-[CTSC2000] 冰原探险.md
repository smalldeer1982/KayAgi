# [CTSC2000] 冰原探险

## 题目描述

传说中，南极有一片广阔的冰原，在冰原下藏有史前文明的遗址。整个冰原被横竖划分成了很多个大小相等的方格。在这个冰原上有 $N$ 个大小不等的矩形冰山，这些巨大的冰山有着和南极一样古老的历史。

每个矩形冰山至少占据一个方格，且其必定完整地占据方格。冰山和冰山之间不会重叠，也不会有边或点相连。以下两种情况均是不可能出现的：

![](https://cdn.luogu.com.cn/upload/pic/5096.png)

$\text{ACM}$ 探险队在经过多年准备之后决定在这个冰原上寻找遗址。根据他们掌握的资料，在这个冰原上一个大小为一格的深洞中，藏有一个由史前人类制作的开关。而唯一可以打开这个开关的是一个占据接近一格的可移动的小冰块。显然，在南极是不可能有这样小的独立冰块的，所以这块冰块也一定是史前文明的产物。他们在想办法把这个冰块推到洞里去，这样就可以打开一条通往冰原底部的通道，发掘史前文明的秘密。冰块的起始位置与深洞的位置均不和任何冰山相邻。

这个冰原上的冰面和冰山都是完全光滑的，轻轻的推动冰块就可以使这个冰块向前滑行，直到撞到一座冰山就在它的边上停下来。冰块可以穿过冰面上所有没有冰山的区域，也可以从两座冰山之间穿过（见下图）。冰块只能沿网格方向推动。


 ![](https://cdn.luogu.com.cn/upload/pic/5097.png) 

请你帮助他们以最少的推动次数将冰块推入深洞中。


## 说明/提示

$1 \leq N \leq 4000$

样例解释：移动方案如图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/y6sx7ya7.png)

## 样例 #1

### 输入

```
2
1 1
5 5
1 3 3 3
6 2 8 4```

### 输出

```
3```

# 题解

## 作者：Juan_feng (赞：11)

这倒题目的思路真的不是很难想，要说代码实现起来也不是很困难，可能小细节比较多，**而且数据范围是个大坑点**......

**小蒟蒻考场上就栽在负数上面了......100->30 而且看了好半天才发现可以有负数...... 小蒟蒻想着自己的坑点都顺利跳过去了，没想到出了个出了个这么大的锅，maxx的初始全设成的0......各位dalao就权当是看个笑话吧，当然如果能帮到dalao们的话那就是小蒟蒻的荣幸了qwqwq**

### 下面讲一下具体的做法：

就是一个简单的广搜，不过如果一步一步去走的话一定会TLE，那么来考虑一下其他的方法，其实也不难像，冰块的数量不算多，可以在广搜的时候枚举所有冰块，求出距离当前点上下左右最近的冰块(没有冰块的话就返回极大或极小值），判断一下能否直接跳到终点，这里稍微讲一下，从一个点能直接跳到终点当且仅当这个点和终点在同一条线上，且中间没有任何冰块。（可以根据之前找出的当前点4个方向最近的冰块来判断当前点与终点之间是否有冰块）

**至于最短时间的问题，用map保存一下状态对应的时间就行了**

然后似乎也就没什么了呀qwqwq

那么代码如下：

```
#include <iostream>
#include <cmath>
#include <algorithm>
#include <queue>
#include <cstring>
#include <cstdio>
#include <map>
#define maxn 100010
#define re register
#define FOR(i, l, r) for(re int i = l; i <= r; ++i)
using namespace std;

int n, m, c, r, t, x, y, z, xq, yq, xz, yz, d1, d2, d3, d4;
struct hz {
    int h;
    int l;
    inline bool operator <(const hz &o) const { //使用结构体作为map的key需要重载小于号 
        if(h == o.h)
          return l < o.l;
        return h < o.h;
    }
};

struct bs {
    int a1;
    int b1;
    int a2;
    int b2;
}ss[5000];

queue<hz> q;
map<hz, int> mmp;

inline void bfs() {
    while(!q.empty()) {
        hz hh = q.front();
        re int xx = hh.h, yy = hh.l;
        re int rt[5];  
        rt[1] = -999999999;// 一定要赋为极小值，考试就是死在这里了... 
		rt[2] = 0x7fffffff; rt[3] = -999999999; rt[4] = 0x7fffffff;
        FOR(i, 1, m) { //处理四个边界距离距离当前节点最近的冰块（是否有冰块） 
            if(ss[i].a1 <= xx && ss[i].a2 >= xx && yy > ss[i].b2)
              rt[1] = max(rt[1], ss[i].b2);
            if(ss[i].a1 <= xx && ss[i].a2 >= xx && yy < ss[i].b1)
              rt[2] = min(rt[2], ss[i].b1);
            if(ss[i].b1 <= yy && ss[i].b2 >= yy && xx < ss[i].a1)
              rt[4] = min(rt[4], ss[i].a1);
            if(ss[i].b1 <= yy && ss[i].b2 >= yy && xx > ss[i].a2)
              rt[3] = max(rt[3], ss[i].a2);
        }
        FOR(i, 1, 4) { //走这4个边界，如果可以走则加入队列 1234分别代表上下左右 
            if(i == 1) { 
                if(xx == xz && yy > yz && rt[1] < yz){ //如果能直接到达终点 
                    printf("%d", mmp[hh]);return;
                }
                if(rt[1] == -999999999) //如果没有冰块 
                  continue;
                hz hhh; hhh.h = xx; hhh.l = rt[1]+1;
                if(!mmp[hhh]) {
                    mmp[hhh] = mmp[hh] + 1;
                    q.push(hhh);
                }
            }
            if(i == 2) {
                if(xx == xz && yy < yz && rt[2] > yz) { // 同上 
                    printf("%d", mmp[hh]); return;
                }
                if(rt[2] == 0x7fffffff)
                  continue;
                hz hhh; hhh.h = xx; hhh.l = rt[2]-1;
                if(!mmp[hhh]) { //不重复走 & 记录时间 
                    mmp[hhh] = mmp[hh] + 1;
                    q.push(hhh);
                }
            }
            if(i == 3) {
                if(yy == yz && xx > xz && rt[3] < xz) { 
                    printf("%d", mmp[hh]); return;
                }
                if(rt[3] == -999999999)
                  continue;
                hz hhh; hhh.h = rt[3]+1; hhh.l = yy;
                if(!mmp[hhh]) {
                    mmp[hhh] = mmp[hh] + 1;
                    q.push(hhh);
                }
            }
            if(i == 4) {
                if(yy == yz && xx < xz && rt[4] > xz) {
                    printf("%d", mmp[hh]); return;
                }
                if(rt[4] == 0x7fffffff)
                  continue;
                hz hhh; hhh.h = rt[4]-1; hhh.l = yy;
                if(!mmp[hhh]) {  
                    mmp[hhh] = mmp[hh] + 1;
                    q.push(hhh);
                }
            }
        }
        q.pop();
    }
    printf("0");
    return;
}

int main() {
    scanf("%d", &m);
    scanf("%d%d", &xq, &yq); 
    scanf("%d%d", &xz, &yz);
    FOR(i, 1, m) {
        scanf("%d%d%d%d", &ss[i].a1, &ss[i].b1, &ss[i].a2, &ss[i].b2);
    }
    hz hh;
    hh.h = xq;
    hh.l = yq;
    q.push(hh);
    mmp[hh] = 1;
    bfs();
}
```

---

## 作者：EternalHeart1314 (赞：8)

### [题目传送门](https://www.luogu.com.cn/problem/P3716)

# 题意

要把一个冰块从 $(sx, sy)$ 推到 $(tx, ty)$。

中途有 $n$ 个冰川，推冰块时，冰块会一直朝**一个方向**~~漂移~~，直到推到 $(ts, ty)$ 或碰到冰川。

# 思路

由于冰块会一直漂移，如果我们模拟冰块漂移的话，时间复杂度肯定爆炸，因为这题它根本没给 $x$ 和 $y$ 的范围，天知道它会不会是 $10^9$，所以我们只能每次枚举所有冰川，看看冰块往四个方向分别会漂移到哪个位置。

知道了冰块会碰到那个冰川，就可以跑 BFS 了。

注意要判断冰块能直接漂移到 $(tx, ty)$ 的情况。

时间复杂度 $O(n^2)$。

位运算那里解释一下：

$$
(-(i \land 1) \oplus -INF) + (i \land 1)
=
\begin{cases}
-INF \quad i \bmod 2 = 0\\
INF \quad i \bmod 2 = 1
\end{cases}
$$

可以自己模拟一下。

目前是你谷最优解第一页。

# Code
```cpp
#include<iostream>
#include<queue>
#include<map>
#define fi first
#define se second
#define mp make_pair
using namespace std;
const int N(4096), INF(1e9);

int n, sx, sy, tx, ty, x, y, d[4], x1[N], y1[N], x2[N], y2[N];
map <int, map<int, int> > dis;

void bfs() {
	queue <pair<int, int> > q;
	q.push(mp(sx, sy));
	bool flag = false;
	while(q.size()) {
		x = q.front().fi, y = q.front().se;
		q.pop();
		d[0] = d[2] = -INF, d[1] = d[3] = INF;
		for(int i = 1; i <= n; ++ i) {
			if(x1[i] <= x && x <= x2[i]) {
				if(y2[i] < y) {
					d[0] = max(d[0], y2[i] + 1);
				}
				if(y1[i] > y) {
					d[1] = min(d[1], y1[i] - 1);
				}
			}
			if(y1[i] <= y && y <= y2[i]) {
				if(x2[i] < x) {
					d[2] = max(d[2], x2[i] + 1);
				}
				if(x1[i] > x) {
					d[3] = min(d[3], x1[i] - 1);
				}
			}
		}
		if(x == tx && (ty < y && d[0] < ty || ty > y && d[1] > ty) || y == ty && (tx < x && d[2] < tx || tx > x && d[3] > tx)) {
			dis[tx][ty] = dis[x][y] + 1;	//注意 || 和 && 的优先级 
			return ;
		}	//压了 
		for(int i = 0; i < 4; ++ i) {
			if(d[i] != (-(i & 1) ^ -INF) + (i & 1) && !(i < 2 ? dis[x][d[i]] : dis[d[i]][y])) {
				dis[i < 2 ? x : d[i]][i < 2 ? d[i] : y] = dis[x][y] + 1;
				q.push(i < 2 ? mp(x, d[i]) : mp(d[i], y));
			}	//严重压了 
		}	//位运算好闪，拜谢位运算 
	}
}

int main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin >> n >> sx >> sy >> tx >> ty;
	for(int i = 1; i <= n; ++ i) {
		cin >> x1[i] >> y1[i] >> x2[i] >> y2[i];
	}
	bfs();
	cout << dis[tx][ty];
	return 0;
}
```

### 珍惜生命，远离抄袭

---

## 作者：__3E24AC7002AD9292__ (赞：4)

这一题呢也是很水的搜索+大模拟。

这题最大的坑点就是 **连个坐标范围都没有**，所以保险起见是肯定不能用暴力搜的。

发现本题的一个性质：每次推箱子推完之后，不是落入坑中，就是推到冰山旁。

先考虑落入坑的情况，如果冰块与坑的连线是水平或者竖直的线，而且线段之间没有冰山，说明可以再花一步直接将冰块推进坑里。

然后考虑推到冰山旁的情况，可以枚举每个冰山，然后计算方向和距离，根据四个方向（上下左右）来找对于该方向最近的冰山，冰块可以直接跳到较近的冰山旁，这比一格格地走快多了。**注意如果某个方向没有冰山就不能走，我就踩坑了**。

走到一个格子可以在 `map` 上记录一下，不重复搜索经过了的格子。

然后这题如果选择使用 DFS 的话，不能保证第一次找到的路径是最优的，因此就要不断找最小值，导致时间复杂度过高。而 BFS 就可以解决这个问题，因为维护的数据结构不同。这也是对于迷宫、图等最短路问题采用 BFS 的缘故。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define mpr make_pair
#define ff make_pair
#define fr first
#define sc second
inline int read(){
	int res=0,f=1;char c=getchar();
	while (c<'0'||c>'9') {if (c=='-') f=-1;c=getchar();}
	while (c>='0'&&c<='9') {res=res*10+(c-'0');c=getchar();}
	return res*f;
}
int n,x,y,x2,y2,a[5005][4],maxn[8];
map<pair<int,int>,bool>mp;
pair<int,int>w[8];
void dis(int i,int x,int y){
	const int lx=a[i][0],ly=a[i][1],rx=a[i][2],ry=a[i][3];
	if (lx<=x&&rx>=x&&ly<=y&&ry>=y) return;
	if (lx<=x&&rx>=x){
		if (y<ly){
			if (maxn[1]>ly-y) maxn[1]=ly-y,w[1]=mpr(x,ly-1);
		}
		else{
			if (maxn[2]>y-ry) maxn[2]=y-ry,w[2]=mpr(x,ry+1);
		}
	}
	if (ly<=y&&ry>=y){
		if (x<lx){
			if (maxn[3]>lx-x) maxn[3]=lx-x,w[3]=mpr(lx-1,y);
		}
		else{
			if (maxn[4]>x-rx) maxn[4]=x-rx,w[4]=mpr(rx+1,y);
		}
	}
}
int bfs(int ax,int ay,int fx,int fy){
	queue<pair<pair<int,int>,int> >que;
	que.push(mpr(mpr(ax,ay),0));
	while (!que.empty()){
		const int x=que.front().fr.fr,y=que.front().fr.sc,dep=que.front().sc;
		que.pop();
		if (x==fx&&y==fy) return dep;
		if (x==fx||y==fy){
			for (int i=1;i<=4;i++) maxn[i]=1e18;
			for (int i=1;i<=n;i++) dis(i,x,y);
			if (x==fx){
				if (y<fy&&maxn[1]>fy-y) return dep+1;
				else if (y>fy&&maxn[2]>y-fy) return dep+1;
			}
			if (y==fy){
				if (x<fx&&maxn[3]>fx-x) return dep+1;
				else if (x>fx&&maxn[4]>x-fx) return dep+1;
			}
		}
		for (int i=1;i<=4;i++) maxn[i]=1e18;
		for (int i=1;i<=n;i++) dis(i,x,y);
		for (int i=1;i<=4;i++){
			if (maxn[i]==1e18) continue;
			const int cx=w[i].fr,cy=w[i].sc;
			if (mp[ff(cx,cy)]) continue;
			que.push(mpr(mpr(cx,cy),dep+1));
			mp[ff(cx,cy)]=1;
		}
	}
	return 0;
}
signed main(){
	n=read(),x=read(),y=read(),x2=read(),y2=read();
	for (int i=1;i<=n;i++) for (int j=0;j<4;j++) a[i][j]=read();
	cout<<bfs(x,y,x2,y2);
	return 0;
}

```


---

## 作者：shzr (赞：4)

$\quad$似乎网上没有看到坐标离散化的题解？那我就来发一篇好了。~~虽然好像比别的做法还慢一些~~。  

$\quad$看到这种坐标范围非常大的题目第一感觉就是离散化，因为有用的坐标挺少的。将起点终点一并放进离散化队列里，横纵坐标分别离散化即可。这样就可以获得$70$分，错在哪里呢？  

$\quad$ 这道题的问题在于有的东西不能直接离散化之后就当不存在了，比如两座山之间有一条窄窄的通道，离散化之后就....消失了？不过因为我们的冰块本身只有一格的宽度，所以每两个坐标如果不是严格相邻，离散化时只需要再插入一个空节点表示空隙。  

$\quad$ 之后可以直接$BFS$,可以用$map$作为$vis$数组,也可以用$bitset$.虽然复杂度听起来比另一种每次暴力找相邻点的做法要优秀,实际运行中却慢不少.
	
  ```cpp
# include <cstdio>
# include <iostream>
# include <map>
# include <algorithm>
# include <bitset>
# include <queue>
# define R register int

using namespace std;

const int dx[]={-1,0,0,1};
const int dy[]={0,-1,1,0};
const int maxn=4003;
const int knc=16103;
int n,N,M;
map <int,int> m;
int x[knc],y[knc],sx,sy,ex,ey,a[maxn],b[maxn],c[maxn],d[maxn];
bitset <knc> ic[knc],vis[knc];
struct node
{
	int x,y,v;
};
queue <node> q;

int bfs ()
{
	node a,b;
	a.x=sx,a.y=sy,a.v=0;
	q.push(a);
	while(q.size())
	{
		a=q.front();
		q.pop();
		int x=a.x,y=a.y;
		vis[x][y]=1;
		if(a.x==ex&&a.y==ey) return a.v;
		for (R d=0;d<4;++d)
		{
			x=a.x,y=a.y;
			while(ic[x][y]==0) 
			{
				x+=dx[d],y+=dy[d];
				if(x>N||y>M||x<1||y<1) break;
				if(ic[x][y]) break;
				if(x==ex&&y==ey) 
					return a.v+1;
			}
			if(x>N||y>M||x<1||y<1) continue;
			if(!ic[x][y]) continue;
			x-=dx[d],y-=dy[d];
			if(vis[x][y]) continue;
			if(ic[x][y]) continue;
			vis[x][y]=1;
			b.x=x,b.y=y,b.v=a.v+1;
			q.push(b);
		}
	}
	return 0;
}

int read ()
{
	R x=0,f=1;
	char c=getchar();
	while(!isdigit(c)) { if(c=='-') f=-f; c=getchar(); }
	while(isdigit(c)) x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return x*f;
}

int main()
{
	n=read();
    sx=read(),sy=read(),ex=read(),ey=read();
    x[++x[0]]=sx,x[++x[0]]=ex;
    y[++y[0]]=sy,y[++y[0]]=ey;
    for (R i=1;i<=n;++i)
    {
        a[i]=read(),b[i]=read(),c[i]=read(),d[i]=read();
        x[++x[0]]=a[i],x[++x[0]]=c[i];
        y[++y[0]]=b[i],y[++y[0]]=d[i];
    }
    sort(x+1,x+1+x[0]);
    sort(y+1,y+1+y[0]);
    int cnt=0;
    for (R i=1;i<=x[0];++i)
    {
        if(i==1)
        	cnt++;
        else
        {
        	if(x[i]!=x[i-1]) 
			{
				cnt++;
        		if(x[i-1]+1!=x[i]) cnt++;
			}
		}
        m[ x[i] ]=cnt;
    }
    N=cnt;
    for (R i=1;i<=n;++i)
        a[i]=m[ a[i] ],c[i]=m[ c[i] ];
    sx=m[sx],ex=m[ex];
    cnt=0;
    m.clear();
    for (R i=1;i<=y[0];++i)
    {
        if(i==1)
        	cnt++;
        else
        {
        	if(y[i]!=y[i-1]) 
			{
				cnt++;
        		if(y[i-1]+1!=y[i]) cnt++;
			}
		}
        m[ y[i] ]=cnt;
    }
    M=cnt;
    for (R i=1;i<=n;++i)
        b[i]=m[ b[i] ],d[i]=m[ d[i] ];
    sy=m[sy],ey=m[ey];
    for (R i=1;i<=n;++i)
        for (R j=a[i];j<=c[i];++j)
            for (R z=b[i];z<=d[i];++z)
            	ic[j][z]=1;
    
	printf("%d",bfs());
    return 0;
}
```

---

## 作者：Victorique (赞：3)

更好的视觉效果请参照蒟蒻的博客：[[CTSC2000]冰原探险](http://www.cnblogs.com/victorique/p/9021260.html)

## Solution

看上去比较不容易出思路的一道题目。如果这个题坐标范围比较小的话，我们想想是不是可以搞一个bool矩阵直接暴力判断bfs。那么这个题就没有什么难度了。~~好了，上代码。~~ 那么出题人就故意不写坐标范围，明摆着就是让你这么做然后挂掉的。

那么我们就只能用结构体来保存坐标。经过仔细排查可以发现，我们从一个地方推冰块，那么它就一定要撞到一座冰山，嗯，那么我们就可以预处理出来从一条边能到达的边分别是哪些就可以了，然后从初始点上下左右试一试，最后出解。然后还有一个，从一个横着的边上只能左右推，从一个竖着的边上只能上下推。

那就没什么其他的了，不过代码确实，不短。

## Code

```cpp
#include <iostream>
#include <cmath>
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <queue>
#define re register
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int inf = 0x3f3f3f3f;
int A,B,C,D,cnt;
int tot,head[16005],nxt[50005],to[50005],n,num,vis[200001];
int h[200001][2],front,tail;
struct po{
	int a,b,c,d,p[10];
}s[4005];
inline int read()
{
	int x=0,c=1;
	char ch=' ';
	while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
	while(ch=='-') c*=-1,ch=getchar();
	while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();
	return x*c;
}
inline int Up(int x,int y)
{
	int ans=0,maxx=-inf;
	for(re int i=1;i<=n;i++){
		int a=s[i].a,b=s[i].b,c=s[i].c,d=s[i].d;
		if(c+1<=x&&y>=b&&y<=d&&maxx<c+1){
			maxx=c+1;
			ans=s[i].p[2];
		}
	}
	if(y==D&&C<=x&&maxx<C) ans=cnt;
	return ans;
}
inline int Down(int x,int y)
{
	int ans=0,minn=inf;
	for(re int i=1;i<=n;i++){
		int a=s[i].a,b=s[i].b,c=s[i].c,d=s[i].d;
		if(a-1>=x&&y>=b&&y<=d&&minn>a-1){
			minn=a-1;
			ans=s[i].p[1];
		}
	}
	if(y==D&&C>=x&&minn>C) ans=cnt;
	return ans;
}
inline int Left(int x,int y)
{
	int ans=0,maxx=-inf;
	for(re int i=1;i<=n;i++){
		int a=s[i].a,b=s[i].b,c=s[i].c,d=s[i].d;
		if(d+1<=y&&x>=a&&x<=c&&maxx<d+1){
			maxx=d+1;ans=s[i].p[4];
		}
	}
	if(x==C&&D<=y&&maxx<D) ans=cnt;
	return ans;
}
inline int Right(int x,int y)
{
	int ans=0,minn=inf;
	for(re int i=1;i<=n;i++){
		int a=s[i].a,b=s[i].b,c=s[i].c,d=s[i].d;
		if(b-1>=y&&x>=a&&x<=c&&minn>b-1){
			minn=b-1;
			ans=s[i].p[3];
		}
	}
	if(x==C&&D>=y&&minn>D) ans=cnt;
	return ans;
}
inline void add(int from,int too)
{
	nxt[++num]=head[from];
	to[num]=too;
	head[from]=num;
}
inline int bfs()
{
	front=0;tail=1;
	h[tail][1]=1;
	h[tail][2]=0;
	while(front<=tail){
		int now=h[++front][1],dep=h[front][2];
		for(re int i=head[now];i;i=nxt[i]){
			int v=to[i];
			if(v==cnt) return dep+1;
			if(!vis[v]){
				vis[v]=1;
				h[++tail][1]=v;
				h[tail][2]=dep+1;
			}
		}
	}
	return 0;
}
int main() 
{
    n=read();
    A=read();B=read();C=read();D=read();
    for(re int i=1;i<=n;i++){
    	s[i].a=read();s[i].b=read();s[i].c=read();s[i].d=read();
    }
    cnt=1;
    for(re int i=1;i<=n;i++)
    	for(re int j=1;j<=4;j++) s[i].p[j]=++cnt;
    ++cnt;
	int x;
	x=Up(A,B); if(x) add(1,x);
	x=Down(A,B); if(x) add(1,x);
	x=Left(A,B); if(x) add(1,x);
	x=Right(A,B); if(x) add(1,x);
	for(re int i=1;i<=n;i++){
		int a=s[i].a,b=s[i].b,c=s[i].c,d=s[i].d;
		int x;
		x=Up(a,b-1); if(x) add(s[i].p[3],x);
		x=Up(a,d+1); if(x) add(s[i].p[4],x);
		x=Down(c,b-1); if(x) add(s[i].p[3],x);
		x=Down(c,d+1); if(x) add(s[i].p[4],x);
		x=Left(a-1,b); if(x) add(s[i].p[1],x);
		x=Left(c+1,b); if(x) add(s[i].p[2],x);
		x=Right(a-1,d); if(x) add(s[i].p[1],x);
		x=Right(c+1,d); if(x) add(s[i].p[2],x);
	}
	cout<<bfs();
    return 0;
}

```



---

## 作者：JYX0924 (赞：3)

这道题直接广搜即可。

对于当前考虑到的点，暴力枚举一下每一座冰山，然后向外扩展即可。

存坐标的时候，注意坐标中有负数，可以离散化或者使用 ```map```。

下面是我的 AC 代码。


```c
#include<bits/stdc++.h>
#define ll long long 
#define maxn 4005
using namespace std;
struct node {ll x,y,xx,yy;} a[maxn];
struct edge {ll row,col,cnt;};
ll n,x,y,X,Y;
queue<edge> q;
map<int,map<int,int> > vis;
void bfs()
{
	q.push({x,y,0});
	while(!q.empty())
	{
		edge tt=q.front(); q.pop();
		int row=tt.row,col=tt.col,pos,now;
		if(vis[row][col]==1) continue;
		vis[row][col]=1;
		//右 
		pos=1e9,now=-1;
		for(int i=1;i<=n;i++)
		{
			ll t1=a[i].x,t2=a[i].xx,t3=a[i].y,t4=a[i].yy;
			if(t1<t2) swap(t1,t2),swap(t3,t4);
			if(t1>=row&&row>=t2&&min(t3,t4)<pos&&min(t3,t4)>col) pos=min(t3,t4),now=i;
		}
		if(now==n) {cout<<tt.cnt+1; return;}
		if(now!=-1) q.push({row,pos-1,tt.cnt+1});
		//左 
		now=-1; pos=-1e9;
		for(int i=1;i<=n;i++)
		{
			ll t1=a[i].x,t2=a[i].xx,t3=a[i].y,t4=a[i].yy;
			if(t1<t2) swap(t1,t2),swap(t3,t4);
			if(t1>=row&&row>=t2&&max(t3,t4)>pos&&max(t3,t4)<col) pos=max(t3,t4),now=i;
		}
		if(now==n) {cout<<tt.cnt+1; return;}
		if(now!=-1) q.push({row,pos+1,tt.cnt+1});
		//下 
		now=-1; pos=1e9; 
		for(int i=1;i<=n;i++)
		{
			ll t1=a[i].x,t2=a[i].xx,t3=a[i].y,t4=a[i].yy;
			if(t3>t4) swap(t3,t4),swap(t1,t2);
			if(t4>=col&&col>=t3&&min(t1,t2)<pos&&min(t1,t2)>row) pos=min(t1,t2),now=i;
		}
		if(now==n) {cout<<tt.cnt+1; return;}
		if(now!=-1) q.push({pos-1,col,tt.cnt+1});
		//上 
		now=-1; pos=-1e9;
		for(int i=1;i<=n;i++)
		{
			ll t1=a[i].x,t2=a[i].xx,t3=a[i].y,t4=a[i].yy;
			if(t3>t4) swap(t3,t4),swap(t1,t2);
			if(t4>=col&&col>=t3&&max(t1,t2)>pos&&max(t1,t2)<row) pos=max(t1,t2),now=i;
		}
		if(now==n) {cout<<tt.cnt+1; return;}
		if(now!=-1) q.push({pos+1,col,tt.cnt+1});
	}
	cout<<"0";
}
int main()
{
	ios::sync_with_stdio(false); cin.tie(0);
	cin>>n>>x>>y>>X>>Y; x=-x,y=-y; X=-X,Y=-Y;
	for(int i=1;i<=n;i++) cin>>a[i].x>>a[i].y>>a[i].xx>>a[i].yy,a[i].x=-a[i].x,a[i].y=-a[i].y,a[i].xx=-a[i].xx,a[i].yy=-a[i].yy;
	a[++n].x=a[n].xx=X,a[n].y=a[n].yy=Y; bfs();
	return 0;
}
```
谢谢大家！！！

---

## 作者：FallingFYC_ (赞：2)

[原题](https://www.luogu.com.cn/problem/P3716)

---
### 思路

简单的广搜。

没给坐标范围，~~肯定有诈~~不能用数组存，所以扩展时只能对于每个方向，枚举每座冰山（一次），看是否能滑到它面前的位置上，如果可以，取离当前位置最近的滑行到的位置。标记用 `map`。可以把深洞也看成一座冰山，这样如果移动到深洞面前，判断一下前面是不是深洞就行了。

---
### 代码
```cpp
#include <iostream>
#include <map>
#include <queue>
#include <utility>
#define mkp(a , b) make_pair(a , b)
using namespace std;
const int INF = 2e9;
const pair<int , int> U = mkp(0 , -INF) , D = mkp(0 , INF) , L = mkp(-INF , 0) , R = mkp(INF , 0);
struct Node
{
    int x , y , step;
};
int n , x1 , y1 , x2 , y2 , ix1[4005] , iy1[4005] , ix2[4005] , iy2[4005];
map<pair<int , int> , bool> book;
int main()
{
    cin >> n;
    cin >> x1 >> y1 >> x2 >> y2;
    for (int i = 1 ; i <= n ; i++)
        cin >> ix1[i] >> iy1[i] >> ix2[i] >> iy2[i];
    ix1[++n] = x2; iy1[n] = y2; ix2[n] = x2; iy2[n] = y2;//把深洞看成一座冰山
    
    queue<Node> q;
    q.push({x1 , y1 , 0}); book[mkp(x1 , y1)] = true;
    while (!q.empty())
    {
        Node now = q.front();
        q.pop();
        pair<int , int> u = U , d = D , l = L , r = R; //初始化极值
        //枚举冰山，扩展
        for (int i = 1 ; i <= n ; i++)
        {   
            if (ix1[i] <= now.x && now.x <= ix2[i])
            {
                if (now.y < iy1[i])
                {
                    if (iy1[i] - 1 < d.second) d = mkp(now.x , iy1[i] - 1);
                }
                else if (now.y > iy2[i])
                {
                    if (iy2[i] + 1 > u.second) u = mkp(now.x , iy2[i] + 1);
                }
            }
            else if (iy1[i] <= now.y && now.y <= iy2[i])
            {
                if (now.x < ix1[i])
                {
                    if (ix1[i] - 1 < r.first) r = mkp(ix1[i] - 1 , now.y);
                }
                else if (now.x > ix2[i])
                {
                    if (ix2[i] + 1 > l.first) l = mkp(ix2[i] + 1 , now.y);
                }
            }
        }
        if (u == mkp(x2 , y2 + 1) || d == mkp(x2 , y2 - 1) || l == mkp(x2 + 1 , y2) || r == mkp(x2 - 1 , y2))//如果在深洞面前，输出
        {
            cout << now.step + 1;
            return 0;
        }
        if (u != U && !book[u]) {book[u] = true; q.push({u.first , u.second , now.step + 1});}
        if (d != D && !book[d]) {book[d] = true; q.push({d.first , d.second , now.step + 1});}
        if (l != L && !book[l]) {book[l] = true; q.push({l.first , l.second , now.step + 1});}
        if (r != R && !book[r]) {book[r] = true; q.push({r.first , r.second , now.step + 1});}
    }
    cout << 0;
    return 0;
}
```

---

## 作者：Erica_N_Contina (赞：1)

## 题意

推箱子。你有一个箱子，要把它推到目的地。当往一个方向推动箱子，箱子会一直运动直到前方有障碍物。问最小操作数。

## 思路

bfs 题目第一步看什么——数据范围。

很明显矩形的数量适中，但是坐标的范围，嗯？我们不知道啊。那么我们要注意这一点，也许坐标的值很大（回来才想到还有可能有负数），那么我们就不能一步步去找了。

那么既然每次推动一个箱子要遇到障碍物才停下来，那么我们在 bfs 时就不要一步步走了。相比也很容易知道一步步走肯定会挂。那么我们就要一次从当前点向某一个方向走到最远可以到达的点。现在一个问题就是，对于某个点 $(i,j)$，我们怎么知道往某个方向走最远能到达哪里呢？

矩形的数量不多，我们可以尝试枚举所有矩形。那么我们每次从一个点转移到另外的点的复杂度就是 $O(N)$ 的。相比这题的步数是不会超过N的数量级的，所以我们可以尝试一下 $O(N^2)$ 的算法。

然后这道题就与 bfs 无异了。只不过在记录 $vis$ 数组时，我们需要使用 map 中存储。

还有一点需要注意，就是如果一个方向上没有冰山，那么我们不能往这个方向推，否则冰块会掉出这个世界。还有一种情况就是当前可以直接到达终点，那么就去终点。

## 代码

注意本题坐标轴很奇怪。

```C++
/*////////ACACACACACACAC///////////
       . Code  by  Ntsc .
       . Earn knowledge .
/*////////ACACACACACACAC///////////

#include<bits/stdc++.h>
#define int long long
#define db double
#define rtn return
using namespace std;

const int N=1e4;
const int M=1e5;
const int Mod=1e5;
const int INF=1e18;

int sx,sy,n,tx,ty;

map<int,map<int,int> > vis;

struct node{
	int x,y,xx,yy;
}w[N];

struct loc{
	int x,y;
};

queue<loc> q;

void bfs(int sx,int sy){
	q.push((loc){sx,sy
	});
	
	while(q.size()){
		int x=q.front().x,y=q.front().y;
		q.pop();
		
//		cerr<<":at:"<<x<<","<<y<<endl;
		
		if(x==tx&&y==ty){
//			if(vis[x][y]%10==2)vis[x][y]--;
			cout<<vis[x][y]<<endl;
			return ;
		}
		
		int slim=-INF,xlim=INF,zlim=-INF,ylim=INF;//记录该点往上下左右能到达的最远位置 
		for(int i=1;i<=n;i++){//枚举矩形障碍物 
			if(w[i].x<=x&&w[i].xx>=x){
				//对竖向有影响
				if(w[i].yy<y)slim=max(slim,w[i].yy+1);
				if(w[i].y>y)xlim=min(xlim,w[i].y-1);
			} 
			if(w[i].y<=y&&w[i].yy>=y){
				//对横向有影响
				if(w[i].xx<x)zlim=max(zlim,w[i].xx+1);
				if(w[i].x>x)ylim=min(ylim,w[i].x-1);
			}
		}
		
		int xx=x,yy=y;
		if(x==tx){
			if(ty>y){
				//终点在正下方
				if(xlim>=ty){
					yy=ty;
					vis[xx][yy]=vis[x][y]+1;
					q.push((loc){xx,yy
					});
					continue;
				}
			}
			if(ty<y){
				//终点在正上方
				if(slim<=ty){
					yy=ty;
					vis[xx][yy]=vis[x][y]+1;
					q.push((loc){xx,yy
					});
					continue;
				} 
			}
		}
		if(y==ty){
			if(tx>x){
				//终点在右边
				if(ylim>=tx){
					xx=tx;
					vis[xx][yy]=vis[x][y]+1;
					q.push((loc){xx,yy
					});
					continue;
				} 
			}
			if(tx<x){
				//终点在左边
				if(zlim<=tx){
					xx=tx;
					vis[xx][yy]=vis[x][y]+1;
					q.push((loc){xx,yy
					});
					continue;
				} 
			}
		}
		
		for(int i=0;i<4;i++){//对于四个方向分类讨论,上下左右
			int xx=x,yy=y;
			if(i==0){
				if(slim==-INF)continue;
				yy=slim;
				if(vis[xx][yy])continue;
				vis[xx][yy]=vis[x][y]+1;
				q.push((loc){xx,yy
				});
			}if(i==1){
				if(xlim==INF)continue;
				yy=xlim;
				if(vis[xx][yy])continue;
				vis[xx][yy]=vis[x][y]+1;
				q.push((loc){xx,yy
				});
			}if(i==2){
				if(zlim==-INF)continue;
				xx=zlim;
				if(vis[xx][yy])continue;
				vis[xx][yy]=vis[x][y]+1;
				q.push((loc){xx,yy
				});
			}if(i==3){
				if(ylim==INF)continue;
				xx=ylim;
				if(vis[xx][yy])continue;
				vis[xx][yy]=vis[x][y]+1;
				q.push((loc){xx,yy
				});
			}
			
		}
	}
	
	cout<<0<<endl;//无解 
}

signed main(){
	cin>>n;
	
	cin>>sx>>sy>>tx>>ty;
	for(int i=1;i<=n;i++){
		cin>>w[i].x>>w[i].y>>w[i].xx>>w[i].yy;
	}
	
	bfs(sx,sy);
	
	return 0;
}

```


（终于 A 了 qwq）



---

## 作者：wizard（偷开O2 (赞：0)

一道宽搜的好题。

怎么那么多题解都讲得很略啊。

### 题意

在一个图上有几座阻挡性冰山，你现在需要将一个冰块从起点推到中点。这个冰块具有的性质是：如果你从任意方向推他，他就会一直朝着这个方向移动知道撞到冰山。

### 分析

我们如果对冰块分析的话，考虑数据范围可能会炸。所以我们转而对不会发生移动的冰山进行分析。

考虑一个冰山，题目会给出每个冰山左上角和右下角的坐标，所以我们就可以直接得到这个冰山四条边的情况，对于每条边，如果有一个冰块的一条边撞到了这个冰山，那么这个冰块必定会受到限制：冰块不能继续向撞边方向运动。

对于所有冰山，假设他们上下左右边的定位分别是：$yu,yd,xl,xr$，所以冰块的停止点只能是：$yu-1,yd+1,xl-1,xr+1$。

预处理出这四个定位，就大大缩小了我们的处理范围。

![ice mountain](https://cdn.luogu.com.cn/upload/image_hosting/92n5byvh.png)

扔一个胡画的图放这，我来说说具体的预处理方法。

我们先考虑怎样冰块停在这个冰山旁边的状态，如果他停在冰山任意一侧，那么就一定要[满足这几个条件](https://www.luogu.com.cn/paste/uhf5wgrr)。

具体实现出来就是：

```cpp
int Right(int x,int y){
	int ans=0,maxx=-inf;
	for(int i=1;i<=n;i++){
		if(nowb<=y&&y<=nowd&&maxx<nowc+1&&nowc+1<=x){
			maxx=nowc+1;
		}
	}
	if(y==D&&C<=x&&maxx<C)ans=cnt;
	return ans;
}
int Left(int x,int y){
	int ans=0,minn=inf;
	for(int i=1;i<=n;i++){
		if(nowb<=y&&y<=nowd&&x<=nowa-1&&nowa-1<minn){
			minn=nowa-1;
		}
	}
	if(y==D&&C>=x&&minn>C)ans=cnt;
	return ans;
}
int Up(int x,int y){
	int ans=0,maxx=-inf;
	for(int i=1;i<=n;i++){
		if(nowa<=x&&x<=nowc&&maxx<nowd+1&&nowd+1<=y){
			maxx=nowd+1;
		}
	}
	if(x==C&&D<=y&&maxx<D)ans=cnt;
	return ans;
}
int Down(int x,int y){
	int ans=0,minn=inf;
	for(int i=1;i<=n;i++){
		if(nowa<=x&&x<=nowc&&y<=nowb-1&&nowb-1<minn){
			minn=nowb-1;
		}
	}
	if(x==C&&D>=y&&minn>D)ans=cnt;
	return ans;
}
```

既然我们已经知道了单步骤的最终状态，直接从初态开始广搜就行。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long 
const int maxn=2e5+10;
const int inf=0x3f3f3f3f;
int n,A,B,C,D;
int cnt;
int head[maxn],tot;
int vis[maxn];
struct node{
	int a,b,c,d;
	int pos[15];
}mo[maxn]; 
int Right(int x,int y){
	int ans=0,maxx=-inf;
	for(int i=1;i<=n;i++){
		int nowa=mo[i].a;
		int nowb=mo[i].b;
		int nowc=mo[i].c;
		int nowd=mo[i].d;
		if(nowb<=y&&y<=nowd&&maxx<nowc+1&&nowc+1<=x){
			maxx=nowc+1;
			ans=mo[i].pos[2];
		}
	}
	if(y==D&&C<=x&&maxx<C)ans=cnt;
	return ans;
}
int Left(int x,int y){
	int ans=0,minn=inf;
	for(int i=1;i<=n;i++){
		int nowa=mo[i].a;
		int nowb=mo[i].b;
		int nowc=mo[i].c;
		int nowd=mo[i].d;
		if(nowb<=y&&y<=nowd&&x<=nowa-1&&nowa-1<minn){
			minn=nowa-1;
			ans=mo[i].pos[1];
		}
	}
	if(y==D&&C>=x&&minn>C)ans=cnt;
	return ans;
}
int Up(int x,int y){
	int ans=0,maxx=-inf;
	for(int i=1;i<=n;i++){
		int nowa=mo[i].a;
		int nowb=mo[i].b;
		int nowc=mo[i].c;
		int nowd=mo[i].d;
		if(nowa<=x&&x<=nowc&&maxx<nowd+1&&nowd+1<=y){
			maxx=nowd+1;
			ans=mo[i].pos[4];
		}
	}
	if(x==C&&D<=y&&maxx<D)ans=cnt;
	return ans;
}
int Down(int x,int y){
	int ans=0,minn=inf;
	for(int i=1;i<=n;i++){
		int nowa=mo[i].a;
		int nowb=mo[i].b;
		int nowc=mo[i].c;
		int nowd=mo[i].d;
		if(nowa<=x&&x<=nowc&&y<=nowb-1&&nowb-1<minn){
			minn=nowb-1;
			ans=mo[i].pos[3];
		}
	}
	if(x==C&&D>=y&&minn>D)ans=cnt;
	return ans;
}
struct edge{
	int y,nxt;
}e[maxn];
void add(int x,int y){
	e[++tot]=(edge){y,head[x]};
	head[x]=tot;
}
queue <pair<int,int> > h;
int bfs(){
	h.push(make_pair(1,0));
	while(!h.empty()){
		int now=h.front().first,dep=h.front().second;
		h.pop();
		for(int i=head[now];i;i=e[i].nxt){
			int to=e[i].y;
			if(to==cnt)return dep+1;
			if(!vis[to]){
				vis[to]=1;
				h.push(make_pair(to,dep+1));
			}
		}
	}
	return 0;
}
signed main(){
	cin >>n;
	cin >>A>>B>>C>>D;
	for(int i=1;i<=n;i++){
		cin >> mo[i].a >> mo[i].b >> mo[i].c >> mo[i].d;
	}
	cnt=1;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=4;j++){
			mo[i].pos[j]=++cnt;
		}
	}++cnt;
	if(Right(A,B))add(1,Right(A,B));
	if(Left(A,B))add(1,Left(A,B));
	if(Up(A,B))add(1,Up(A,B));
	if(Down(A,B))add(1,Down(A,B));
	for(int i=1;i<=n;i++){
		int a=mo[i].a;
		int b=mo[i].b;
		int c=mo[i].c;
		int d=mo[i].d;
		if(Right(a,b-1))add(mo[i].pos[3],Right(a,b-1));
		if(Right(a,d+1))add(mo[i].pos[4],Right(a,d+1));
		if(Left(c,b-1))add(mo[i].pos[3],Left(a,b-1));
		if(Left(c,d+1))add(mo[i].pos[4],Left(a,d+1));
		if(Up(a-1,b))add(mo[i].pos[1],Up(a-1,b));
		if(Up(c+1,b))add(mo[i].pos[2],Up(c+1,b));
		if(Down(a-1,d))add(mo[i].pos[1],Down(a-1,d));
		if(Down(c+1,d))add(mo[i].pos[2],Down(c+1,d));
	}
	cout << bfs() <<endl;
	return 0;
}
```

---


# [NOIP 2009 提高组] 最优贸易

## 题目背景

本题原题数据极弱，Subtask 0 中的测试点为原题测试点，Subtask 1 中的测试点为 Hack 数据。

## 题目描述

$C$ 国有 $n$ 个大城市和 $m$ 条道路，每条道路连接这 $n$ 个城市中的某两个城市。任意两个城市之间最多只有一条道路直接相连。这 $m$ 条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为 $1$ 条。

$C$ 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。

商人阿龙来到 $C$ 国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设 $C$ 国 $n$ 个城市的标号从 $1\sim n$，阿龙决定从 $1$ 号城市出发，并最终在 $n$ 号城市结束自己的旅行。在旅游的过程中，任何城市可以重复经过多次，但不要求经过所有 $n$ 个城市。阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品――水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来 $C$ 国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。

假设 $C$ 国有 $5$ 个大城市，城市的编号和道路连接情况如下图，单向箭头表示这条道路为单向通行，双向箭头表示这条道路为双向通行。

![](https://cdn.luogu.com.cn/upload/image_hosting/flre534z.png)

假设 $1\sim n$ 号城市的水晶球价格分别为 $4,3,5,6,1$。

阿龙可以选择如下一条线路：$1\to2\to3\to5$，并在 $2$ 号城市以 $3$ 的价格买入水晶球，在 $3$ 号城市以 $5$ 的价格卖出水晶球，赚取的旅费数为 $2$。

阿龙也可以选择如下一条线路：$1\to4\to5\to4\to5$，并在第 $1$ 次到达 $5$ 号城市时以 $1$ 的价格买入水晶球，在第 $2$ 次到达 $4$ 号城市时以 $6$ 的价格卖出水晶球，赚取的旅费数为 $5$。

现在给出 $n$ 个城市的水晶球价格，$m$ 条道路的信息（每条道路所连接的两个城市的编号以及该条道路的通行情况）。请你告诉阿龙，他最多能赚取多少旅费。

## 说明/提示

【数据范围】

输入数据保证 $1$ 号城市可以到达 $n$ 号城市。

对于 $10\%$ 的数据，$1\leq n\leq 6$。

对于 $30\%$ 的数据，$1\leq n\leq 100$。

对于 $50\%$ 的数据，不存在一条旅游路线，可以从一个城市出发，再回到这个城市。

对于 $100\%$ 的数据，$1\leq n\leq 100000$，$1\leq m\leq 500000$，$1\leq  x,y\leq  n$，$1\leq  z\leq  2$，$1\leq $ 各城市的编号 $\leq  n$。

水晶球价格 $\leq 100$。

NOIP 2009 提高组 第三题

## 样例 #1

### 输入

```
5 5 
4 3 5 6 1 
1 2 1 
1 4 1 
2 3 2 
3 5 1 
4 5 2 ```

### 输出

```
5```

# 题解

## 作者：fy1234567ok (赞：508)

# 分层图状态转移 + SPFA

其实此题可以**不用强连通分量缩点**，还有更优美的解法，**只需40行代码**。

主要思想是类似“分层图”，或者类似“DAG”（有向无环图）的状态转移思想，特别是针对这种状态量相互影响的问题，分层图思想很实用。

## 分析

读完这道题，可以发现这样的事实：

- 你可以在图上任意走动

- 最终答案只与你的买入与卖出价格有关（我们就把买入卖出价值作为边权）

- 如果你买入了一个水晶球，你是没有不卖它的道理的（显然咯，买了不卖血亏...）

暴力算法不难得出：

我只关心我在哪里买了这个水晶球，在哪里把它卖出去，并且，我能否从起点走到我的买入点，从买入点走到卖出点，然后在走到 $n$ 

因此，先枚举两个点再bfs检查能否到达，然后更新答案。

而此题的难点在与你如何知道你是否能够到达买入，卖出，终点（即上两行 并且 后面我说的话），和你能否把所有可能的情况考虑在内。

分层图可以很好的解决这个问题。


由于可以任意走动，所以我们可以建一张图，令图上的边全都是 $0$ ，表示我的走动对我最终的结果没有影响。


考虑某个点 $i$ ，它买入或者卖出水晶球的花费是 $v_i$ 。

那么：
**当我们进行买入操作**，我们就建立一条**有向边**转移到一张新图上，边的大小为 $-v_i$ ，它从第一层的点 $i_{0}$  ~~指向点 $i$ 所能到达的点（在第二层图上）~~  _指向第二层的点 $i_{1}$_  。而这张新图就是我们的第二层图。

它表示：假如我选择走了这条边，就是我在这个点买了这个水晶球，我不会反悔，并且我接下来考虑在某个点卖它。

**当我们进行卖出操作**，我们建立一条有向边转移到第三层图上，边的大小为 $v_i$，它从第二层的点 $i_{1}$  ~~指向点 $i$ 所能到达的点（在第二层图上）~~  _指向第三层的点 $i_{2}$_  。

它表示：假如我选择走了这条边，就是我在这个点卖了这个水晶球，我不会反悔，并且我接下来考虑走向终点。

> 注：不能指向 $i$ 下一层到达的点，因为这样意思就变成了：我在这个点买入了水晶球，*并且我一定从这个点走出去*。多了一层意思就不一样了

可以发现，从第一层图走到第二层图走到第三层图走到终点，这就是一个合法的决策。

对于**任何**一种决策都可以抽象为我从 $1$点 走到点 $x$ 买入，然后走到点 $y$ 卖出, 然后走到点 $n$。而每一种决策都在图中对应了一条从 $1_0$ 到 $x_0$ 到 $x_1$ 到 $y_1$ 到 $y_2$ 到 $n_2$ 的路径。   

![](https://cdn.luogu.com.cn/upload/image_hosting/0hulu3d3.png)

所以分层图把所有合法的决策都考虑到了。而我们要求的最大收益就正好对应了图上的从 $1_0$ 到 $n_2$ 最长的路径。

> 注：当然也可以把边权都改成负的求个最短路(因为不存在负环也是可以的)

### 最后解释一下为什么我们要分层：

因为当你分了层，你就可以从还未买入这个状态，转移到已经买入准备卖出这个状态，然后在转移到从卖出点走向终点的状态。由于有向边的建立，你不能从第二/三层走回第一层图，这保证了你只做一次买卖，而不是无限做买卖，符合了题目的要求


而我们最终的答案，就是求从第一层图的 $1$ 号点，走道第三层图的 $n$ 号点的最长路,如图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/fxq0pi14.png)

到此，这道题就解完了。

### UPDATE 2020.10.6

其实2年前我已经退役，抱歉鸽了这么久才更新。感谢在评论中帮我指出错误，提出建议的大佬们。这次更新修改了建模，符号加入了LaTeX, 优化了代码。Hack数据已经可以通过了。如果发现了其他问题，欢迎在评论区中讨论，感谢各位的支持。

# 代码如下

``` cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e5 + 5;

int n, m, d[maxn*3], inq[maxn*3];
vector<pair<int, int>> G[maxn*3];

#define t(x,i) (x+i*n)  // t(x,i) 表示第i层的x
// 建立x->y边的函数, 不用加 make_pair是 C++11特性
#define add(x, y) G[t(x,0)].push_back({t(y,0), 0}), G[t(x,1)].push_back({t(y,1),0}), G[t(x,2)].push_back({t(y,2),0})

void spfa(int s) {
    for(int i = 1;i <= n*3;i++) d[i] = INT_MIN; // 这里n*3别漏了, INT_MIN 是C++内置最小值常量
    d[s] = 0; 
    queue<int> Q; inq[s] = true; Q.push(s);
    while(!Q.empty()) {
        int x = Q.front(); Q.pop(); inq[x] = false;
        for(auto [v, len] : G[x])  // C++17 特性, 等价于 int v = G[x][i].first, len = G[x][i].second;
            if(d[v] < d[x] + len) {
                d[v] = d[x] + len;
                if(!inq[v]) { Q.push(v); inq[v] = true; }
            } 
    }
}

int main() {
    ios_base::sync_with_stdio(0); cin.tie(0); // 加速cin, cout
    cin >> n >> m;
    for(int i = 1, v;i <= n; ++i) {
        cin >> v;
        G[t(i,0)].push_back({t(i,1), -v});
        G[t(i,1)].push_back({t(i,2), v});
    }
    for(int i = 1,x,y,z;i <= m; ++i) {
        cin >> x >> y >> z; add(x, y);
        if(z == 2) add(y, x);
    }
    spfa(t(1,0));
    cout << d[t(n,2)] << endl;
    return 0;
}
```

---

## 作者：ctzm (赞：20)

前言：经历了[这个帖子](https://www.luogu.com.cn/discuss/557686)和[这个帖子](https://www.luogu.com.cn/discuss/972147)两次 hack 后，题解区就只剩下分层图最长路了，唯一的 Tarjan 也被 hack 掉，只是保存下来而已。

原本我加在自己的练习题单，准备当成分层图做，结果学校学 Tarjan 时又有这个题……那就两种都写一遍吧。

分层图写得很顺利，很快就过了，但看大家的提交记录，**好家伙，全在分层图**，并且最长路写 dij 的居然都能过，真的不怕最长路被卡到 WA/TLE 吗？？？

很少一部分人依然坚持写 Tarjan，但是基本也被后来加的数据 hack 了，作为一个 SPFA 被卡怕的人，我决定写一篇 Tarjan 题解，以让 Tarjan 党能够使用最喜欢的稳定线性做法通过本题，~~而不是某个已经【【】】的东西~~。

## 题意简述

一个商人在有向图上从 $1$ 走到 $n$，点 $i$ 处买和卖货物的价格都是 $w_i$，商人至多只能买和卖商品一次，问最多盈利多少。

$n \le 10^5$，$m \le 5 \times 10^5$，$1 \le w_i \le 100$。

## Solution

缩点题目的一般套路：在 DAG（有向无环图）上非常好做（往往是拓扑序上 DP）+ 一个强连通分量可以经过一定处理变成一个点，并且答案不受影响。

看到部分分的描述：“不存在一条旅游路线，可以从一个城市出发，再回到这个城市。”

这句话本质上就是在说：“这个图是个 DAG（有向无环图）。”

记 $f_i$ 为“从 $1$ 到 $i$ 的所有路径中，经过的点的货物价格的最小值”，假设我们在点 $v$ 卖出货物，那么最大利润就是 $w_v - f_v$。正确性是显然的：卖出价一定，想让利润变大，就得降低成本，贪心地选择可能经过的最小的成本就好了。

如何求 $f_i$？首先，边界情况 $f_1$ 一定为 $w_1$，然后对于 DAG 上的每条边 $(u,v)$，有 $f_v = \min(f_v,\min(f_u,w_v))$，转移按拓扑序枚举点连接的边就好了，没有后效性的。

考虑并不是 DAG，也就是有环的情况：用 Tarjan 缩点，此处不细讲 Tarjan 算法，顺便记录每个强连通分量里所有点的 $w_i$ 最大值和最小值，记为 $maxw$ 和 $minw$。

缩完点重新建边后，对于每条边 $(u,v)$，转移式变为  $f_v = \min(f_v,\min(f_u,minw_v))$，统计答案方法就变为 $maxw_i - f_i$，正确性留给大家自行思考。

注意，这道题有坑！统计答案时（假设枚举到点 $i$ 作为卖出点），必须满足从 $1$ 可达 $i$，也从 $i$ 可达 $n$ 才能计入答案。

如何判断这两个条件？第一个条件可以偷懒，只对节点 $1$ 跑一遍 Tarjan。Tarjan 的本质其实还是深搜，只是在上面记录信息以缩点，如果 $1$ 到达不了某个点， Tarjan 也不会找到它，忽略掉就好。

第二个条件有点难处理，毕竟你不可能每个点都深搜一遍吧。一个简单易想易写的方案是，对缩点后产生的 DAG 建反图，然后从点 $n$ 所在的 SCC 跑深搜，被访问到了就是满足这个条件的。

有些题目也会考到这种“单汇”的最短路或者可达性之类的东西，通常的最短路 / 搜索都是“单源”的，只需要建个反图就能转化为“单汇”。

### code


```cpp

int n,m,cnt,scc,a[100010],dp[100010],dfn[100010],low[100010],col[100010],miw[100010],maw[100010];
vector<int> v[100010],V[100010],v_[100010];
stack<int> s;
bool vis[100010];
/*
cnt为tarjan的时间戳，scc为scc个数
a为价格，col表示每个点属于哪个scc
miw/maw表示每个scc内的最小/最大价格
v/V/v_表示原图/缩点后图/缩点后反图
s为tarjan的栈，vis是dfs中的访问标记 
*/
void tarjan(int x){
	dfn[x]=low[x]=++cnt;
	s.push(x);
	for(int i:v[x]){
		if(!dfn[i]){
			tarjan(i);
			low[x]=min(low[x],low[i]);
		}
		else if (!col[i]){
			low[x]=min(low[x],dfn[i]);
		}
	}
	if(low[x]==dfn[x]){
		scc++;
		miw[scc]=1e9;//初始化 
		maw[scc]=-1;
		while(1){
			int tmp=s.top();
			col[tmp]=scc;
			miw[scc]=min(miw[scc],a[tmp]);//记录最小值和最大值 
			maw[scc]=max(maw[scc],a[tmp]);
			s.pop();
			if(tmp==x)break;
		}
	}
}
void dfs(int x){
	vis[x]=1;
	for(int i:v_[x])if(!vis[i])dfs(i);
}
void solve(){
	int ans=0;
	memset(dp,0x3f,sizeof dp);
	dp[col[1]]=miw[col[1]];
	for(int _=scc;_>=1;_--){//tarjan 保证了逆序枚举是一种合法的拓扑序，当然你想写正常拓扑也行 
		for(int i:V[_]){
			dp[i]=min(dp[i],min(dp[_],miw[i]));//DAG dp 核心转移 
		}
	}
	for(int i=1;i<=scc;i++)if(vis[i])ans=max(ans,maw[i]-dp[i]);//统计答案注意是否可达n 
	cout<<ans;
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=m;i++){
		int u,V_,t;
		cin>>u>>V_>>t;
		v[u].push_back(V_);
		if(t==2)v[V_].push_back(u);//注意双向边 
	}
	tarjan(1);
	for(int i=1;i<=n;i++){
		for(int j:v[i]){
			if(col[i]!=col[j]&&col[i]&&col[j]){//注意，我们没跑完 整个图，意味着有些点的col为0，不应该加入，所以要特判 
				V[col[i]].push_back(col[j]);
				v_[col[j]].push_back(col[i]);	
			}
		}
	}
	dfs(col[n]);//如果 col[n] == 0 其实没有影响 上面的特判保证了点 0 不会向任何点连边 
	solve();





	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/200076626)，不过感觉 tarjan 写这题坑点挺多，目前能通过所有 hack 数据，不过感觉不久也会被 hack 掉……就这样吧。

---

## 作者：Gypsophila (赞：13)

安利 [Blog](https://www.cnblogs.com/acfunction/p/10060606.html)

### Solution

考虑原图是 DAG 时怎么做。

拓扑排序 + dp ，令 dp[i] 表示 $1$ 到 $i$ 的路径上最小的卖出价格。转移方程就是对每一个可以到达这个点的 dp 取个 min ，计算答案便是 $\max \limits _{i} \{val_i - dp_i \}$ ，其中 val 是商品价格。dp 在拓扑序上随便转移一下就好

考虑题目怎么做便十分显然，直接缩点得到一张 DAG ，贪心的让缩完的点的卖出价格是该点中价值最大的，卖入的是该点中价值最小的。然后就可以用在 DAG 上转移的方法来做就可以了

`A Very Important Thing` :

在更新答案的时候，需要判断这个点是否能到达 n 点所在的强连通分量里。实现方法是在 反图上 dfs 一遍就可以判断出那些点能够到达终点。

### Code 

```cpp
#include <bits/stdc++.h>
#define INF 1000000000
using namespace std;
const int N = 100100;
const int M = 500500; 
int n, m, val[N], cnt, dfn[N], low[N], tot, U[N], V[N], ind[N], ins[N], vis[N]; 
int scc, bel[N], Max[N], Min[N], List[N], ans, dp[N], sta[N], top, z[N]; 
struct edge {
  int v; edge *next; 
}pool[M * 6], *head[N], *h[N], *hh[N];
inline void addd(int u, int v) {
  edge *p = &pool[++cnt];
  p->v = v, p->next = hh[u], hh[u] = p;
}
inline void add(int u, int v) {
  edge *p = &pool[++cnt];
  p->v = v, p->next = h[u], h[u] = p; 
}
inline void addedge(int u, int v) {
  edge *p = &pool[++cnt];
  p->v = v, p->next = head[u], head[u] = p; 
}
inline void tarjan(int u) {
  dfn[u] = low[u] = ++tot; ins[u] = 1, sta[++top] = u; 
  for(edge *p = head[u]; p; p = p->next) {
    int v = p->v; 
    if(!dfn[v]) tarjan(v), low[u] = min(low[u], low[v]);
    else if(ins[v]) low[u] = min(low[u], dfn[v]); 
  } if(low[u] == dfn[u]) {
    ++scc;
    while(sta[top + 1] != u) {
      Max[scc] = max(Max[scc], val[sta[top]]);
      Min[scc] = min(Min[scc], val[sta[top]]); 
      bel[sta[top]] = scc; ins[sta[top--]] = 0; 
    }
  }
}
inline void toposort() {
  tot = 0; queue <int> Q; 
  while(!Q.empty()) Q.pop();
  for(int i = 1; i <= scc; i++)
    if(!ind[i]) Q.push(i);
  while(!Q.empty()) {
    int u = Q.front(); Q.pop();
    List[++tot] = u;
    for(edge *p = h[u]; p; p = p->next) {
      int v = p->v; ind[v]--;
      if(ind[v] == 0) Q.push(v); 
    }
  }
}
inline void dfs(int u) {
  if(vis[u]) return ; vis[u] = 1; 
  for(edge *p = hh[u]; p; p = p->next) dfs(p->v); 
}
int main() {
  scanf("%d %d", &n, &m); 
  for(int i = 1; i <= n; i++) scanf("%d", &val[i]);
  for(int i = 1; i <= n; i++) Min[i] = INF, Max[i] = -INF;
  for(int i = 1; i <= m; i++) {
    scanf("%d %d %d", &U[i], &V[i], &z[i]);
    addedge(U[i], V[i]); 
    if(z[i] == 2) addedge(V[i], U[i]); 
  } 
  for(int i = 1; i <= n; i++) 
    if(!dfn[i]) tarjan(i); 
  for(int i = 1; i <= m; i++) {
    int x = bel[U[i]], y = bel[V[i]];
    if(x != y) { add(x, y), ind[y]++, addd(y, x); 
      if(z[i] == 2) add(y, x), ind[x]++, addd(x, y); 
    }
  } toposort(); dfs(bel[n]); 
  for(int i = 1; i <= scc; i++) dp[i] = Min[i]; 
  for(int i = 1; i <= scc; i++) {
    int u = List[i]; 
    if(vis[u]) ans = max(ans, Max[u] - dp[u]);
    for(edge *p = h[u]; p; p = p->next) {
      int v = p->v; dp[v] = min(dp[v], dp[u]); 
    }
  } 
  printf("%d\n", ans);
  return 0; 
} 
```

---

## 作者：HPXXZYY (赞：11)

这题的解法花样百出，个人感觉**分层图+最短路**最简单。


------------

首先，让我们讲讲什么是分层图。

分层图就是把一个图分成很多很多的层，每一层都有不同的含义，然后感觉题目所述，把某些层间连接起来，然后，用图论的算法就可以把题目解出来了。

然后代码实现起来也很简单，最简单的方法是把所以的点原样复制，即第$i$层的第$j$个点为$n \times i +j$。

------------
回到本题，我们可以把原图分成三份，第一层表示没买也没卖，第二层表示进行了买，第三层表示即进行了买和卖。

然后，同一层的图间互相连边，因为移动不需要花费，所以边权恒为$0$。

最后，考虑层与层间如何移动。很显然只能从第一层转移到第二层（必须先买再卖对吧！），边权为$-cost[i]$（$cost[i]$表示第$i$点的花费），第二层转移到第三层（否则就会不买就卖！），边权为$cost[i]$。

最后，跑一遍最**长**路就可以了。答案可以为$d[3\times n]$，也可以是$max\{d[n],d[3\times n]\}$



------------
**【代码】：**
```cpp
本代码仅仅略去头文件，其余皆正确！
#define gc getchar()
#define g(c) isdigit(c)
inline int read(){
	char c=0;int x=0;bool f=0;
	while (!g(c)) f=c=='-',c=gc;
	while (g(c)) x=x*10+c-48,c=gc;
	return f?-x:x;
}//快读
const int N=100100;
const int M=500100;
struct node{
	int next,to,len;
}e[M*6+N*2];int h[N*3],tot;
inline void add(int a,int b,int w){
	e[++tot]=(node){h[a],b,w};h[a]=tot;
}
int d[N*3];bool vis[N*3];
inline void spfa_algorithm(int s){
	memset(d,128,sizeof(d));
	memset(vis,1,sizeof(vis));
	queue<int> q;q.push(s);d[s]=0;
	while (q.size()){
		int u=q.front();q.pop();vis[u]=true;
		for(int i=h[u];i;i=e[i].next){
			register int to=e[i].to;
			if (d[to]<d[u]+e[i].len){
				d[to]=d[u]+e[i].len;
				if (vis[to]){
					vis[to]=false;
					q.push(to);
				}
			}
		}
	}
}//因为有负边所以必须要spfa
int n,m,cost[N];
inline void read_the_date(){
	n=read();m=read();
	for(int i=1;i<=n;i++){
		cost[i]=read();
		add(i,i+n,-cost[i]);
		add(i+n,i+2*n,cost[i]);
	}
	for(int i=1;i<=m;i++){
		register int u=read(),v=read(),z=read();
		add(u,v,0);add(u+n,v+n,0);add(u+2*n,v+2*n,0);
		if (z==2) add(v,u,0),add(v+n,u+n,0),add(v+2*n,u+2*n,0);
	}
}//注意如何建边
inline int HPXXZYY(){
	read_the_date();
	spfa_algorithm(1);
	cout<<max(d[n],d[3*n]);
	return 0;
}
int main(){
	return HPXXZYY();
}
```

---

## 作者：寒冰大大 (赞：8)

看了下题解，发现说的tarjan+dagdp……

然后翻到第三页才发现一个dagdp

然后呢，感觉讲的不是很清楚，而且压行，用了好多玄学操
作。。

关键是还没有注释，于是果断自己来一发

喜欢我的博客就来[康康](https://www.cnblogs.com/zsx6/)

另外关于后效性的讨论：

##### 首先这个图不存在环了，如果存在环的话，该点入队次数必然高于该点入度，这个拿来用就好了

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<queue>
#include<cstring>
#include<vector>
#include<stack>
#include<algorithm>

using namespace std;

int n,m,head[100050],size;
int bd[100050],a[100050],zd[100050],zx[100500],mmx=-1,dt,cnt;
int dfn[100050],low[100050],ins[100050],ind[100500]; 
int f[100050];

stack <int> s;

struct edge{
	int next,to;
}e[1008600],looker[1008600];

void addedge(int next,int to)
{
	e[++size].next=head[next];
	e[size].to=to;
	head[next]=size;
}

void tarjan(int t)  //tarjan缩点 
{
	dfn[t]=low[t]=++dt;
	s.push(t);
	ins[t]=1;
	int i,j;
	for(i=head[t];i;i=e[i].next)
	{
		j=e[i].to;
		if(!dfn[j]) tarjan(j),low[t]=min(low[t],low[j]);
		else if(ins[j]) low[t]=min(low[t],dfn[j]);
	}
	j=0;  //j一定要清零不然有些情况要炸 比如 自环之类的  
	if(dfn[t]==low[t])
	{
		cnt++;
		while(t!=j)
		{
			j=s.top();
			s.pop();
			ins[j]=0;
			bd[j]=cnt;
		}
	}
}

void dagdp(int s)
{
	queue <int> q;
	q.push(bd[s]);
	f[bd[s]]=max(f[bd[s]],zd[bd[s]]-zx[bd[s]]);  //这个刷不刷都不用管反正都是0 
	while(!q.empty())
	{
		int t=q.front();
		q.pop();
		int i,j; 
		for(i=head[t];i;i=e[i].next)
		{
			j=e[i].to;
			ind[j]--; 
            zx[j]=min(zx[j],zx[t]);//保留这个点的最小值，因为买的时候可以从一个价格低的地方带过来。 
            f[j]=max(f[j],max(zd[j]-zx[j],f[t]));//判断一下，有三种情况 ： 从另外的点带过来，这个点卖，上个点卖 
			if(!ind[j])
			{
				q.push(j);  //当每个能刷新该点的点都被完成刷新后才可以刷这个点[无后效性原则] 
			}
		}
		
	}
}

int main()
{
	int i,j;
	scanf("%d %d",&n,&m);
	for(i=1;i<=n;i++)
	scanf("%d",&a[i]);
	for(i=1;i<=m;i++)
	{
		int t1,t2,t3;
		scanf("%d %d %d",&t1,&t2,&t3);
		if(t3==1) 
		{
		addedge(t1,t2);
		looker[size].next=t1;
		looker[size].to=t2;	  //保留一个边集的备份，以便从新建边 
		}
		if(t3==2)
		{
		addedge(t2,t1);
		addedge(t1,t2);  //双向边不考虑，因为它们必然在一个强连通分量里面 
		} 
	}
	for(i=1;i<=n;i++)
	if(!dfn[i]) tarjan(i);
	memset(zd,-1,sizeof(zd));  //最大值赋为-1，最小值赋为0x3f3f3f3f 
	memset(zx,0x3f,sizeof(zx));
	int sz=size;
	memset(head,0,sizeof(head));
	size=0;
	for(i=1;i<=sz;i++)
	{
		int aa,bb;
		aa=looker[i].next;
		bb=looker[i].to;
		aa=bd[aa];
		bb=bd[bb];
		if(aa==bb) continue;
		addedge(aa,bb);  
		ind[bb]++; //每个点的入度就是该点最大能被刷新的次数 
	}
	for(i=1;i<=n;i++)
	{
		zd[bd[i]]=max(zd[bd[i]],a[i]);
		zx[bd[i]]=min(zx[bd[i]],a[i]);    //因为是一个强连通分量每个点可以互相通达，因此记录售价的最高和最低就可以了 
	}
	dagdp(1);
	printf("%d",f[bd[n]]);
	return 0;
}
```



---

## 作者：fairfriendZ (赞：8)

对于这道题，我有两种思路。

---

****一·****
__多层图 + spfa 法__ 
---

实际上，已经有相当多的题解对这一方法进行了说明，但我还是再讲一遍（主要是我觉得我码风挺好，想分享一下代码）。

多层图：多层图实际上我认为是一种将二维图转换成三维图的思维方式，当然实际代码不需要。我们想到此题可以构建三层图来分别表示每个点的三个状态，即原始，已买，已卖。此题难度主要在于想清楚如何确定两点之间连线的权值，思考一下发现，在每个单独层内部的边权大小对答案毫无影响！

再思考，各不同层点之间的边权大小要如何确定呢？我们可以想到，因为各层点之间所代表的不同状态，所以可以得出边权就是当前点的价值！那么一至二层图的边权就为负价值（因为初始钱数为 $0$），二至三层图边权就为正钱数（因为把东西卖掉又赚了钱）。

如图（感谢 [songge888](https://www.luogu.com.cn/user/911013) 借我的图）：[点此观看](https://smms.app/image/kqiUHstVyWcPAev)

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
struct fvv{
    int v;
    int w;
};
queue<int >q;
vector<fvv >g[500900];
int dis[500900];
int val[500900];
bool vis[500900];
int n,m,s;
int read(){
    int k=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9')k=k*10+c-'0',c=getchar();
    return k*f;
}
void spfa(){
    q.push(s),vis[s]=1,dis[s]=0;
    while(!q.empty()){
        int fv=q.front();
        q.pop();
        vis[fv]=0;
        for(int i=0;i<g[fv].size();i++){
            if(dis[g[fv][i].v]<dis[fv]+g[fv][i].w){
                dis[g[fv][i].v]=dis[fv]+g[fv][i].w;
                // if(cnt[g[fv][i]>n)return;
                if(vis[g[fv][i].v]!=1)q.push(g[fv][i].v),vis[g[fv][i].v]=1;
            }
        }
    }
}
signed main(){
    // freopen("t4.in","r",stdin);
    // freopen("t4.out","w",stdout);
    n=read(),m=read(),s=1;
    for(int i=1;i<=n;i++){
        val[i]=read();
    }
    for(int i=1;i<=m;i++){
        int u=read(),v=read(),w=read();
        if(w==1){// 以二维存三维
            g[u].push_back({v,0});
            g[u+n].push_back({v+n,0});    
            g[u+2*n].push_back({v+2*n,0});
        }
        else{
            g[u].push_back({v,0});
            g[u+n].push_back({v+n,0});    
            g[u+2*n].push_back({v+2*n,0});
            g[v].push_back({u,0});
            g[v+n].push_back({u+n,0});    
            g[v+2*n].push_back({u+2*n,0});
        }
        // g[v].push_back({u,w});
    }
    for(int i=1;i<=200900;i++)dis[i]=-1e18;
    for(int i=1;i<=n;i++){
        g[i].push_back({i+n,-val[i]});
        g[i+n].push_back({i+2*n,val[i]});
    }
    spfa();
    cout<<max(dis[3*n],max(dis[2*n],dis[n]));
}
/*
多层图法
*/
```
---

****二·****
 __双端 spfa 法__ 
---

在传奇击杀王击杀题解（详见讨论 972147）后，我是唯一一篇发双端 spfa（虽然我也不知道之前有没有人发）的题解。但我之所以发，就是因为它极为优秀，无论是官方数据还是 hack，它均能以远超多层图的速度跑完。

双端 spfa 本质上是在图中跑两遍 spfa，从而达到记录最大最小值的效果。它的关键点在于想到逆向存图（因为要从 $n$ 到 $1$ 找最大值）和想到如何改 spfa 内部使其可以记录当前点的点值为前面已走过的点中点值最大/最小的值（有点像 tarjan 但 tarjan 要回头）。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
queue<int >q;
vector<int >g[200900];
vector<int >g2[200900];
int dis[200900],dis1[200900];
int val[200900],vis[200900];
int n,m,s;
int read(){
    int k=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9')k=k*10+c-'0',c=getchar();
    return k*f;
}
void spfa(){
    q.push(s),vis[s]=1,dis[s]=val[s];
    while(!q.empty()){
        int fv=q.front();
        q.pop();
        vis[fv]=0;
        for(int i=0;i<g[fv].size();i++){
            if(dis[g[fv][i]]>min(dis[fv],val[g[fv][i]])){//记录最小值
                dis[g[fv][i]]=min(dis[fv],val[g[fv][i]]);
                if(vis[g[fv][i]]!=1)q.push(g[fv][i]),vis[g[fv][i]]=1;
            }
        }
    }
}
void spfa1(){
    q.push(n),vis[n]=1,dis1[n]=val[n];
    while(!q.empty()){
        int fv=q.front();
        q.pop();
        vis[fv]=0;
        for(int i=0;i<g2[fv].size();i++){
            if(dis1[g2[fv][i]]<max(dis1[fv],val[g2[fv][i]])){//记录最大值
                dis1[g2[fv][i]]=max(dis1[fv],val[g2[fv][i]]);
                if(vis[g2[fv][i]]!=1)q.push(g2[fv][i]),vis[g2[fv][i]]=1;
            }
        }
    }
}
signed main(){
    freopen("p1073.in","r",stdin);
    freopen("p1073.out","w",stdout);
    n=read(),m=read(),s=1;
    for(int i=1;i<=n;i++){
        val[i]=read();
    }
    for(int i=1;i<=m;i++){
        int u=read(),v=read(),w=read();
        if(w==1){
            g[u].push_back(v);
            g2[v].push_back(u);//建两个不同的反向图
        }
        else{
            g[u].push_back(v);
            g2[v].push_back(u);    
            g[v].push_back(u);
            g2[u].push_back(v);    
        }
    }
    for(int i=1;i<=n;i++){
        dis[i]=1e18;
    }
    spfa();
    for(int i=1;i<=n;i++){
        vis[i]=0;
    }
    while(!q.empty())q.pop();
    for(int i=1;i<=n;i++)dis1[i]=0;
    spfa1();
    int ans=-1e18;
    for(int i=1;i<=n;i++){
        ans=max(ans,dis1[i]-dis[i]);//求最大差值
    }
    cout<<ans;
}
/*
双spfa法
*/
``` 
写完这题可以去过一下 [hack 数据](https://www.luogu.com.cn/problem/U496445)（击杀大量题解，战绩可查）。

---

## 作者：EricWay1024 (赞：8)

### BFS搜索，预处理剪枝。

First and foremost, 我们要把从终点往回走不能到达的点统统删掉。此之谓预处理。此法优势有二：
- 不再需要对那些不能抵达的点进行搜索
- 在所有进行搜索的点，我都可以抵达终点，因此做完交易我就可以更新最大利润，而不用继续走了


在这道题里，商人一共可以有三种状态：还没买，买了还没卖，卖了在找终点。但是因为我们做了预处理，所以第三种状态就消失了。因此状态的定义是：
- pos：商人所在的位置
- val：如果没买，等于0；如果买了没卖，等于进价。

一个状态不能搜索两次。这利用vis数组解决。（幸而这题的数据规模还是可以开的下的。）

状态的转移：
- 走
- 如果没买，买
- 如果买了没卖，卖

剪枝：

- 预处理中发现不能走到的点，不走
- //之前没有做预处理，有一个剪枝是：在卖了在找终点的状态下，如果利润没有目前最高利润大，我就不找终点了
- //想了一个剪枝，但是没有做：统计所有点最贵的价格，如果在此处买，并以最贵的价格出售，仍然不超过目前的最高利润，剪枝




```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 100010
#define M 1000010
#define P 110

int price[N];

struct GRAPH{
	int head[N];
	int next[M];
	int to[M];
	int tot;
	
	void add(int u, int v){
		tot++;
		next[tot]=head[u];
		head[u]=tot;
		to[tot]=v;
	}
};

GRAPH g, revg;

bool reach[N];
bool vis[N][P];

int n, m;
int best;

struct STATE{
	int pos;
	int val; //没买=0；求善待沽=进价；
};

int read(){
	int x=0; int sign=1;
	char c=getchar();
	while(c>'9' || c<'0') {
		if (c=='-') sign=-1;
		c=getchar();
	}
	while(c>='0' && c<='9'){
		x=(x<<3)+(x<<1); 
		x+=c-'0';
		c=getchar();
	}
	return x*sign;
}

void prework(){
	queue<int> q;
	q.push(n);
	reach[n]=1;
	while(q.size()){
		int u=q.front(); q.pop();
		for (int i=revg.head[u]; i; i=revg.next[i]){
			int v=revg.to[i];
			if (reach[v]) continue;
			q.push(v);
			reach[v]=1;
		}
	}
}

void bfs(){
	queue<STATE> q;
	q.push((STATE){1, 0});
	while(q.size()){
		STATE u=q.front(); q.pop();
		//printf("pos=%d, val=%d, sold=%d\n", u.pos, u.val, u.sold);
		//不鬻，走 
		for (int i=g.head[u.pos]; i; i=g.next[i]){
			STATE v; 
			v.pos=g.to[i]; 
			v.val=u.val;
			if (!reach[v.pos]) continue;
			if (vis[v.pos][v.val]) continue;
			q.push(v);
			vis[v.pos][v.val]=1;
		}
		
		
		if(!u.val){ //没买 
			STATE v;
			v.pos=u.pos;
			v.val=price[u.pos];
			
			if (vis[v.pos][v.val]) continue;
			q.push(v);
			vis[v.pos][v.val]=1;
		}
		
		if (u.val){ //出售 
			int profit=price[u.pos]-u.val;
			best=max(best, profit);
		}
	}
}

int main(){
	n=read(); m=read();
	for (int i=1; i<=n; i++) price[i]=read();
	for (int i=1; i<=m; i++){
		int x=read(), y=read(), z=read();
		g.add(x, y);
		if (z==2) g.add(y, x);
		revg.add(y, x);
		if (z==2) revg.add(x, y);
	}
	prework();
	bfs();
	cout<<best;
	return 0;
}
```

---

## 作者：神之右大臣 (赞：7)

大家都是两遍SPFA吗(或是tarjan)？我这里就是一遍dp啊；

首先判断对于一个点u，是否可以从一号点走到这里，并且可以从u走到n号点； 对于这样的点我们打上标记；

那么抛出水晶球的点一定是从打上标记的点中选出一个；(自己可以理解一下)

然后跑一遍dp，dp[i]表示从点1到点i的若干条路径中，所经过的点的权值最小的值；

比较明显的发现dp[v]可以从dp[u]继承过来(v是u的儿子),所以具有优美的DP性质；

最后ans=max(w[i]-dp[i]);

dp可以通过bfs来实现；

```cpp
#include <bits/stdc++.h>
#define cin std::ios::sync_with_stdio(false); cin
#define cout std::ios::sync_with_stdio(false); cout
using namespace std;
int n,m;
struct littlestar{
	int to;
	int nxt;
}star[1000010],star2[1000010];
int head[1000010],cnt,head2[1000010],cnt2;
inline void add(int u,int v)
{
	star[++cnt].to=v;
	star[cnt].nxt=head[u];
	head[u]=cnt;
}
inline void add2(int u,int v)
{
	star2[++cnt].to=v;
	star2[cnt].nxt=head2[u];
	head2[u]=cnt;
}
int w[1000010];
queue<int> q;
int bo1[1000010],bo2[1000010];
void bfs1(int s)
{
	while(q.size()) q.pop();
	q.push(s);
	bo1[s]=1;
	while(q.size()){
		int u=q.front();
		q.pop();
		for(register int i=head[u];i;i=star[i].nxt){
			int v=star[i].to;
			if(!bo1[v]){
				bo1[v]=1;
				q.push(v);
			}
		}
	}
}
void bfs2(int s)
{
	while(q.size()) q.pop();
	q.push(s);
	bo2[s]=1;
	while(q.size()){
		int u=q.front();
		q.pop();
		for(register int i=head2[u];i;i=star2[i].nxt){
			int v=star2[i].to;
			if(!bo2[v]){
				bo2[v]=1;
				q.push(v);
			}
		}
	}
}
int f[1000010];
int vis[1000010];
void SPFA()
{
	while(q.size()) q.pop();
	for(register int i=1;i<=n;i++) f[i]=999999999;
	q.push(1);
	f[1]=w[1];
	vis[1]=1;
	while(q.size()){
		int u=q.front();
		q.pop();
		vis[u]=0;
		for(register int i=head[u];i;i=star[i].nxt){
			int v=star[i].to;
			if(!vis[v]){
				vis[v]=1;
				if(f[v]==999999999){
					f[v]=min(f[u],w[v]);
					q.push(v);
				}
				else{
					if(f[u]<f[v]){
						f[v]=f[u];
						q.push(v);
					}
				}
			}
		}
	}
}
int main()
{
	cin>>n>>m;
	for(register int i=1;i<=n;i++){
		cin>>w[i];
	}
	for(register int i=1;i<=m;i++){
		int u,v,w;
		cin>>u>>v>>w;
		if(w==1){
			add(u,v);
			add2(v,u);
		}
		else{
			add(u,v);
			add2(v,u);
			add(v,u);
			add2(u,v);		
		}
	}
	bfs1(1);
	bfs2(n);
	SPFA();
	int ans=0;
	for(register int i=1;i<=n;i++){
		if(bo1[i]&&bo2[i]){
			ans=max(w[i]-f[i],ans);
		}
	}
	cout<<ans<<endl;
}
```

---

## 作者：Ngo123 (赞：7)

本题使用 **SPFA** 算法进行求解。

在读完题后，根据题目让我们求最多能赚取多少差价，我们可以考虑如下解决方式：

先用 SPFA 算法求出：

从 $1$ 到 $i$ 的所有路径中，水晶球的最低价格 $minv_{i}$。

从 $i$ 到 $n$ 的所有路径中，水晶球的最高价格 $maxv_{i}$。

求解过程中需要注意的点：

我们对于求解从 $1$ 到 $i$ 的所有路径中，水晶球的最低价格时，就按照初始的建图方式，使用 SPFA 求解即可。

但当对于求解从 $i$ 到 $n$ 的所有路径中，水晶球的最高价格时，则需要建反图，再使用 SPFA 算法进行求解。

最后从 $1$ 到 $n$ 枚举每个城市，求出每个省市的 $maxv_{i}-minv_{i}$ 的最大值，即为阿龙能赚取的最高差价。

以下是我的代码：
```
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5+5;
vector <int> e[N],g[N];
bool vis[N];
int ans,minv[N],maxv[N],price[N],n,m,x,y,z;
void spfa1(int s)
{
	memset(minv,0x3f,sizeof minv);
	memset(vis,0,sizeof vis);
	queue <int> q; q.push(s);
	minv[s] = price[s],vis[s] = 1;
	while(q.size())
	{
		int x = q.front(); q.pop();
		vis[x] = 0;
		for(auto y:e[x])
			if(minv[y] > min(minv[x],price[y]))
			{
				minv[y] = min(minv[x],price[y]);
				if(!vis[y]) q.push(y),vis[y] = 1;
			}
	}
}
void spfa2(int s)
{
	memset(maxv,-0x3f,sizeof maxv);
	memset(vis,0,sizeof vis);
	queue <int> q; q.push(s);
	maxv[s] = price[s],vis[s] = 1;
	while(q.size())
	{
		int x = q.front(); q.pop();
		vis[x] = 0;
		for(auto y:g[x])
			if(maxv[y] < max(maxv[x],price[y]))
			{
				maxv[y] = max(maxv[x],price[y]);
				if(!vis[y]) q.push(y),vis[y] = 1;
			}
	}
}
int main()
{
	cin>>n>>m;
	for(int i = 1;i<=n;i++) cin>>price[i];
	while(m--)
	{
		cin>>x>>y>>z;
		e[x].push_back(y);
		g[y].push_back(x);
		if(z==2) e[y].push_back(x),g[x].push_back(y);
	}
	spfa1(1); spfa2(n);
	for(int i = 1;i<=n;i++)
		ans = max(ans,maxv[i]-minv[i]);
	cout << ans << endl;
	return 0;
}
```

---

## 作者：songge888 (赞：6)

upd $2025/1/17$：修改错别字
### 题意概括

给你一个长度为 $n$ 的序列 $a_n$，代表权值。

从节点 $1$ 到节点 $n$ 有若干条路径，路径上任意取两个点 $x$ 和 $y$，满足：

- $x$ 比 $y$ 先访问。
- $a_y-a_x$ 尽可能地大。 

 求最大的 $a_y-a_x$。

### 思路

考虑分层图。

什么是分层图？

> 分层图是一种在图论中用于解决特定问题的建模方法。它通过将原始图复制成多层结构，每一层代表不同的状态或决策次数，从而在这些层之间建立特定的连接，以满足问题的约束条件。 —ChatGPT

就以这个题举例。

我们需要进行**买入**和**卖出**两次操作，当买了在第 $i$ 个城市买了水晶球时，代价是 $-a_i$，卖出的代价是 $a_i$，不买不卖就是 $0$。

我们可以建三层图，第一层代表没买也没卖，第二层代表买了但没卖，第三层代表买了也卖了。

如图：

![graph _5_-topaz-upscale-4x.png](https://s2.loli.net/2025/01/13/kqiUHstVyWcPAev.png)

在这个图上跑最长路就好了。

#### 关于建图：

对于第 $i$ 个点，对 $i$ 和 $i+n$ 连一条边权为 $-a_i$ 的边，$i+n$ 和 $i+2 \times n$ 连一条边权为 $a_i$ 的边。($1$)

对于每一对 $u,v$，$u$ 和 $v$ 连一条边权 $0$ 的边，$u+n$ 和 $v+n$ 连一条边权 $0$ 的边，$u+2\times n$ 和 $v+2\times n$ 连一条边权 $0$ 的边。($2$)

（上面的图都能体现）。

**参考代码：**

```c++
for(int i=1;i<=n;i++){
	cin>>w[i];
	g[i].push_back({i+n,-w[i]});
	g[i+n].push_back({i+2*n,w[i]});
}//第一种情况
g[u].push_back({v,0});
g[u+n].push_back({v+n,0});
g[u+2*n].push_back({v+2*n,0});
//第二种情况
```

时间复杂度：$O(3nm)$。

### Code

```c++
#include<bits/stdc++.h>
#define int long long
#define bug cout<<"___songge888___"<<'\n';
using namespace std;
int n,m;
struct lyl{
	int v,w;
};
vector<lyl> g[500010];
int w[500010],vis[500010],dis[500010];
queue<int> q;
void spfa(int s){
	q.push(s);
	dis[s]=0;
	vis[s]=1;
	while(!q.empty()){
		int u=q.front();
		q.pop();
		vis[u]=0;
		for(auto [v,w]:g[u]){
			if(dis[v]<dis[u]+w){
				dis[v]=dis[u]+w;
				if(!vis[v]){
					vis[v]=1;
					q.push(v);
				}
			}
		}
	}
	return ;
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>w[i];
		g[i].push_back({i+n,-w[i]});
		g[i+n].push_back({i+2*n,w[i]});
	}
	for(int i=1;i<=m;i++){
		int u,v,op;
		cin>>u>>v>>op;
		if(op==1){
			g[u].push_back({v,0});
			g[u+n].push_back({v+n,0});
			g[u+2*n].push_back({v+2*n,0});
		}
		else{
			g[u].push_back({v,0});
			g[u+n].push_back({v+n,0});
			g[u+2*n].push_back({v+2*n,0});
			g[v].push_back({u,0});
			g[v+n].push_back({u+n,0});
			g[v+2*n].push_back({u+2*n,0});
		}
	}
	memset(dis,128,sizeof dis);
	spfa(1);
	cout<<max(dis[n],dis[3*n]);
	return 0;
}

```

---

## 作者：Tomwsc (赞：3)

# P1073 [NOIP2009 提高组] 最优贸易 题解

各位大佬都用了分层图，但却只用了一种写法，蒟蒻过来补充另外一种写法。

## 思路

对于这一类问题，我们考虑分层图。

何为分层图？即将一张图分成好多层，同时在这么多张图中连边，然后通过一些算法来实现解题的目的。当题目中的边权会改变或者有特殊边（比如有 $k$ 次机会边权变为 $0$）时就有分层图的用武之地了。

对于这道题目，因为它给的是点权，所以我们首先想到把点权转边权。即将 $u$ 到 $v$ 的路径的边权赋为 $v$ 节点的点权。

随后，容易发现在购买水晶球时，因为要花钱，所以边权为负。同时，在卖出水晶球时，边权又为正了。**边权会改变**这不就符合了使用分层图的特点吗！

所以，我们可以建 $3$ 层图。哪 $3$ 层？

1. 第一层表示还没有买水晶球。
2. 第二层表示买了水晶球，但没有卖出去。
3. 第三层表示已经卖出了水晶球。

建好了图，现在我们考虑连边：

- 不难想到对于同一层的节点，相连的边权应为 $0$。
- 第一层的节点到第二层的节点，因为要买水晶球，所以边权应为 $-w$，即边权的相反数。
- 第二层的节点到第三层的节点，因为已经卖出了水晶球，所以边权就是 $w$。

答案就是第一层中 $1$ 号节点到第三层中 $n$ 号节点的最长路。

## 代码实现

### 分层图

为了实现分层图的多层，我们通常有两种操作：

1. 在连边时实现层与层之间相连。各位大佬都讲得很好了，我这里重点给大家讲第二种。
  
2. 正常连边，然后把最短路数组和 bool 数组都开成二维：$dis[n][layer]$ 与 $flag[n][layer]$。其中 $n$ 是节点数量，$layer$ 是层数。往 spfa 的队列加一个 $pair$ 保存层数。经过这两个操作，多层的图就被存放在了数组里。然后，我们在跑最长路（或最短路）时就可以对其进行转移，即层与层之间的转移。需要注意的是，转移需要考虑是否已经是顶层，同时，同一层之间要记得松弛。

### 注意事项

- 对于这道题目，由于第一层到第二层是负边权，所以我们需要特殊处理。

- 因为可以在自己所在的节点上买卖水晶球，所以要在同一个节点上连边（自环）。

- 要跑最长路，数组记得要赋极小值。

- 不要忘了，在答案小于 $0$ 时输出 $0$。

### 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int MAXN = 1e5 + 10 , MAXM = 1e6 + 10;
int n , m;
int a[MAXN];
int he[MAXN] , to[MAXM] , ne[MAXM] , w[MAXM];
int idx;
int dis[MAXN][5];
bool flag[MAXN][5];
int cnt;

inline void add(int a , int b , int c) {
	to[++ idx] = b;
	w[idx] = c;
	ne[idx] = he[a];
	he[a] = idx;
	return;
}

inline void spfa() {
	queue<pair<int , int> >q;
	q.push(make_pair(1 , 1));
	memset(dis , 0xcf , sizeof(dis));
	dis[1][1] = 0;
	while(!q.empty()) {
		int u = q.front().first;
		int layer = q.front().second;
		q.pop();
		flag[u][layer] = false;
		for(register int i = he[u];i;i = ne[i]) {
			int v = to[i];
			if(layer == 1) {
				if(dis[v][layer + 1] < dis[u][layer] - w[i]) {
					dis[v][layer + 1] = dis[u][layer] - w[i];
					if(!flag[v][layer + 1]) {
						flag[v][layer + 1] = true;
						q.push(make_pair(v , 2));
					}
				}
				if(dis[v][layer] < dis[u][layer]) {
					dis[v][layer] = dis[u][layer];
					if(!flag[v][layer]) {
						flag[v][layer] = true;
						q.push(make_pair(v , 1));
					}
				}
			} else {
				if(layer + 1 <= 3 && dis[v][layer + 1] < dis[u][layer] + w[i]) {
					dis[v][layer + 1] = dis[u][layer] + w[i];
					if(!flag[v][layer + 1]) {
						flag[v][layer + 1] = true;
						q.push(make_pair(v , layer + 1));
					}
				}
				if(dis[v][layer] < dis[u][layer]) {
					dis[v][layer] = dis[u][layer];
					if(!flag[v][layer]) {
						flag[v][layer] = true;
						q.push(make_pair(v , layer));
					}
				}
			}
		}
	}
	return;
}
					
signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> m;
	for(register int i = 1;i <= n;i ++) {
		cin >> a[i];
		add(i , i , a[i]);
	}
	while(m --) {
		int x , y , z;
		cin >> x >> y >> z;
		if(z == 1)
			add(x , y , a[y]);
		else {
			add(x , y , a[y]);
			add(y , x , a[x]);
		}
	}
	spfa();
	if(dis[n][3] > 0)
		cout << dis[n][3];
	else
		cout << 0;
	return 0;
}
```

---

## 作者：XCDRF_ (赞：3)

# P1073 \[NOIP2009 提高组] 最优贸易

[原题传送门](https://www.luogu.com.cn/problem/P1073)

[更好的阅读体验](https://www.luogu.com.cn/article/l1losgoo)

## 解题思路

可以考虑分层图。

什么是分层图，顾名思义，就是有很多层的图，可以用来解决一些能使边权改变的题。

以本题举例。我们可以在任意一个城市进行买入和卖出操作，设现在在 $i$ 号城市，买入操作对答案的贡献就是 $-a_i$，卖出操作对答案的贡献就是 $a_i$，不买不卖就是 $0$。

此时，我们可以建三层图，分别代表没买没卖，买了但没卖，买了也卖了。每层内的点互相连边，层与层之间对应点互相连边。层内的点互相连边的边权为 $0$，第一层连向第二层的边边权为 $-a_i$，第二层连向第三层的边边权为 $a_i$。答案就是第一层的 $1$ 号点到第三层的 $n$ 号点间的最长路。

## 注意事项

1. 本题的建图方式比较特殊，第一层的编号就是原编号，第二层的编号是原编号加 $n$，第三层的编号是原编号加 $2\times n$，具体请参见代码。
2. 本题存在负权边，需要用 spfa 跑最长路。
3. 不要忘记将 dis 数组初始化为最小值。

## 参考代码

```cpp
#include<iostream>
#include<queue>
#include<cstring> 
#define id(x,y) (x+y*n)//x号点在第y层的编号
using namespace std;
const int N=3e5+5,M=3e6+5;
int n,m,tot;
int a[N],dis[N],head[N];
bool vis[N];
queue<int> q;
struct Edge{
	int nxt,to,w;
}edge[M];
void add(int x,int y,int w){
	edge[++tot]={head[x],y,w};
	head[x]=tot;
}
void spfa(int s){
	memset(dis,128,sizeof(dis));//赋初值
	dis[s]=0;
	vis[s]=1;
	q.push(s);
	while(!q.empty()){
		int t=q.front();
		q.pop();
		vis[t]=0;
		for(int i=head[t];i;i=edge[i].nxt){
			int j=edge[i].to;
			if(dis[j]<edge[i].w+dis[t]){
				dis[j]=edge[i].w+dis[t];
				if(!vis[j]){
					q.push(j);
					vis[j]=1;
				}
			}
		}
	}
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		add(id(i,0),id(i,1),-a[i]);//第一层向第二层连边
		add(id(i,1),id(i,2),a[i]);//第二层向第三层连边
	}
	for(int i=1,x,y,op;i<=m;i++){
		cin>>x>>y>>op;
		if(op==1)
			for(int j=0;j<=2;j++) add(id(x,j),id(y,j),0);//单向边
		else if(op==2)
			for(int j=0;j<=2;j++) add(id(x,j),id(y,j),0),add(id(y,j),id(x,j),0);//双向边
	}
	spfa(1);
	cout<<(dis[3*n]<0?0:dis[3*n]);
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/197418184)

最后再推荐几个分层图的题，[P2939](https://www.luogu.com.cn/problem/P2939)，[P4568](https://www.luogu.com.cn/problem/P4568)，[P4822](https://www.luogu.com.cn/problem/P4822)，感兴趣的可以去做一下。

---

## 作者：zsq9 (赞：2)

[AC 记录](https://www.luogu.com.cn/record/199473138)

声明：这题是 **我们老师讲了方法**，我才会做的，**不是自己想出来的**，~~**我没有这个实力**~~。

## 题目大意

$C$ 国有 $n$ 个大城市和 $m$ 条道路，这 $m$ 条道路中有一部分为单向通行的道路，一部分为双向通行的道路，

设 $C$ 国 $n$ 个城市的标号从 $1\sim n$，阿龙决定从 $1$ 号城市出发，并最终在 $n$ 号城市结束自己的旅行。在旅游的过程中，任何城市可以重复经过多次，但不要求经过所有 $n$ 个城市。选择一个经过的城市买入水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。这个贸易只进行最多一次。

现在给出 $n$ 个城市的水晶球价格，$m$ 条道路的信息。他最多能赚取多少旅费。

## 思路

这题我们可以考虑分层图，因为读这题我们可以发现，我们得到的旅费，只与买入的价格和卖出的价格有关，所以直接找最少买入的价格和最多卖出的价格，但是问题是有可能回不了终点，所以暴力还要枚举回终点过不去，所以就可以考虑分层图，我们可以建三层图，当买入时就连一条有向边到第二层图上，边权就是 $-$ 花费的钱，当买出时就连一条有向边连到第三层图上，边权就是花费的钱，从第一到第三层图上的最长路就是答案。

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int N,M;
int price[100025];
int que[300021];
int maxpf[100025],mingp[100025];
struct line{
	int num;
	line *next;
	line(int _num, line *_next){ num=_num; next=_next; }
}*head[100025],*tmp;
void BFS() {
    int s = 0, f = 1, i = 0, j = 0, k = 0;
    que[0] = 1;  // 从城市1开始
    mingp[1] = price[1];  // 初始城市1的最低价格为它自己的价格
    maxpf[1] = 0;  // 初始最大利润为0
    for (; s != f; s = (s + 1) % 300020) {  // 广度优先搜索
        i = que[s];  // 当前城市
        tmp = head[i];  // 获取当前城市的邻接城市
        if (price[i] - mingp[i] > maxpf[i])  // 如果可以获得更大的利润，则更新最大利润
            maxpf[i] = price[i] - mingp[i];

        // 遍历所有邻接城市
        for (; tmp; tmp = tmp->next) {
            j = tmp->num;
            if (mingp[j] > price[j] || mingp[j] > mingp[i] || maxpf[j] < maxpf[i]) {
                // 如果能更新邻接城市的最低价格和最大利润，则更新，并将该城市入队
                mingp[j] = min(price[j], mingp[i]);
                maxpf[j] = max(maxpf[j], maxpf[i]);
                que[f] = j;
                f = (f + 1) % 300020;
            }
        }
    }
}

int main() {
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    cin >> N >> M; 
    for (int i = 1; i <= N; i++) 
        cin >> price[i];  

    int x, y, kind;
    for (int i = 1; i <= M; i++) {
        cin >> x >> y >> kind;  
        head[x] = new line(y, head[x]);  // 将城市 x 到城市 y 的边添加到邻接表中
        if (kind == 2) 
            head[y] = new line(x, head[y]);  // 如果是双向道路，反向也添加一条边
    }

    memset(mingp, 0x7f, sizeof mingp);  // 初始化最小价格为一个极大的值
    BFS(); 
    cout << maxpf[N];  
    return 0;
}

```

---

## 作者：万弘 (赞：2)

## 分层图入门
在一些图论题中,可能会有多个状态,如[此题](https://www.luogu.org/problemnew/show/P1073),此时**分层图**很有效

分层图,就是将同一个图复制多次,用一些边将这些图连接，再把这些图看为一个整体，在这个整体上跑一些算法。

此题就可以这样做：

1.建立原图（边权为0）同时在复制的图（复制两个，一个称为“买图”，一个称为“卖图”）中也这样做；  
2.将原图与“买图”的对应点连接，边权为买入价（正数数）；  
3.将“买图”与“卖图”的对应点连接，边权为卖出价（负数）；  
4.从原图中的点1开始跑最短路，到“卖图”的点n的距离的相反数即为答案  

**由于有负边权，所以必须用SPFA**

还是有一定思维难度的，复杂度$O(m)-O(nm)$（SPFA就是这样..不过亲测可过）

```cpp
//by wh
//time O(km)~O(nm)
#include<iostream>
#include<cstdio>
typedef long long ll;
#define maxn 400004
#define maxm 2000004
ll n,m;
struct Edge//邻接表存图
{
	ll v,w,nxt;
}e[maxm];
ll cnt=0,last[maxn];
void adde(ll u,ll v)//在三个图中增加u->v的边，边权为0
{
	++cnt;
	e[cnt].v=v;e[cnt].w=0;
	e[cnt].nxt=last[u];last[u]=cnt;
	++cnt;
	e[cnt].v=(v+n);e[cnt].w=0;
	e[cnt].nxt=last[u+n];last[u+n]=cnt;
	++cnt;
	e[cnt].v=(v+n*2);e[cnt].w=0;
	e[cnt].nxt=last[u+n*2];last[u+n*2]=cnt;
}

ll dis[maxn];//到各个点的最短距离
bool inq[maxn];
struct que//queue 手打队列
{
	ll a[maxn],h,t;
	void start()
	{
		h=t=1;
	}
	void push(ll x)
	{
		a[t++]=x;
		if(t>maxn)t=1;
	}
	void pop()
	{
		++h;
		if(h>maxn)h=1;
	}
	ll front()
	{
		return a[h];
	}
	bool empty()
	{
		return h==t;
	}
}q;
void SPFA()
{
	for(ll i=1;i<=n*3;++i)dis[i]=1ll<<60;
	dis[1]=0;
	q.start();
	q.push(1);inq[1]=1;
	ll u,v,w;
	while(!q.empty())
	{
		u=q.front();
		q.pop();inq[u]=0;
		for(ll i=last[u];i;i=e[i].nxt)
		{
			v=e[i].v,w=e[i].w;
			if(dis[v]>dis[u]+w)
			{
				dis[v]=dis[u]+w;
				if(!inq[v])
				{
					q.push(v);inq[v]=1;
				}
			}
		}
	}
}
int main()
{
	scanf("%lld%lld",&n,&m);
	ll t,u,v;
	for(ll i=1;i<=n;++i)
	{
		scanf("%lld",&t);
		++cnt;//跨图连边，即步骤2&3
		e[cnt].v=(i+n);e[cnt].w=t;
		e[cnt].nxt=last[i];last[i]=cnt;
		++cnt;
		e[cnt].v=(i+n*2);e[cnt].w=-t;
		e[cnt].nxt=last[i+n];last[i+n]=cnt;
	}
	for(ll i=1;i<=m;++i)
	{
		scanf("%lld%lld%lld",&u,&v,&t);
		adde(u,v);
		if(t==2)adde(v,u);
	}
	SPFA();
	printf("%lld",-dis[n*3]);
	return 0;
}
```

比较奇妙的

---

## 作者：jiangyulin_David (赞：1)

# 题目大意

一张图中有若干有向边和若干无向边，第 $i$ 个节点有一个价格 $p[i]$，对于所有的路径 $1 \rightarrow u \rightarrow v \rightarrow n$（$1,u,v,n$ 可以相等），求 $p[v] - p[u]$ 的最大值。

# 分析与实现
前往[云剪贴板](/paste/9xwplo9d)查看完整代码。

## 朴素做法

设价格最大值为 $K$，我们高兴地发现 $K \le 100$，于是 $\mathrm O(NK)$ 的做法可以通过本题。

我们可以考虑一种贪心：枚举 $1$ 可达的买入节点（$u$）并选择卖出节点（$v$），使得 $u$ 可达 $v$、$v$ 可达 $n$ 且 $v$ 的**价格**（$p[v]$）**最大**。

> 注：我们称 $u$ 可达 $v$ 当且仅当存在路径 $u \rightarrow v$。

由于我们实际上只关心价格，因此对于某一结点 $u$，**所有可达的价格相同的节点都是等价的**，于是我们只需要维护 $u$ 到每种价格节点的可达性，然后直接枚举所有可能的价格 $k$ 来更新答案。

接下来考虑具体实现，因为只需要维护可达性，可以用搜索来实现，为了方便，接下来的实现全部使用 BFS。

> 值得注意的是，使用 BFS 维护「所有节点到某一结点 (单汇) 的可达性」**必须要建反图**，因为 BFS 只能用前驱节点更新后继节点，不像 DFS 可以通过回溯的方式用后继节点更新前驱节点，因此必须要将其转化为「某一结点到所有节点 (单源) 的可达性」。

且慢……，如果我们以每一个节点为源点跑 BFS，那么复杂度不就达到 $\mathrm O(N^2)$ 了吗？

但是还记得我说过吗？所有可达的价格相同的节点都是等价的，于是我们就可以使用「多源 BFS」，即一开始将所有价格为 $k$ 的节点压入队列。枚举所有的价格跑 BFS，就能在 $\mathrm O(NK)$ 的复杂度下实现了。

具体地，考虑路径 $1 \rightarrow u \rightarrow v(p[v]=k) \rightarrow n$ 我们需要维护三个可达性，分别是 $1 \rightarrow u$、$u \rightarrow v(p[v]=k)\color{grey}(\rightarrow n)$ 和 $v \rightarrow n$，这里使用三个 BFS 来实现：

> 注意我们在买入点考虑卖出价格时，要保证能通过该价格的节点到达终点，因此需维护 $u \rightarrow v(p[v]=k)~{\rightarrow n}$。

```cpp
// un[u]: u -> n 
// ukn[k][u] u -> v(p[v] == k) -> n
// ou[u]: one -> u

#define Push(st, x) if(!st[x]) st[x] = 1, q.push(x)
void bfs_n() {
    queue<int> q;
    Push(un, n);
    while(q.size()) {
        int u = q.front(); q.pop();
        for(int v : H[u]) Push(un, v);
    }
}
void bfs_k(int k) {
    queue<int> q;
    for(int u = 1; u <= n; u++)
        if(un[u] && p[u] == k) Push(ukn[k], u);
    while(q.size()) {
        int u = q.front(); q.pop();
         for(int v : H[u]) Push(ukn[k], v);
    }
}
void bfs_1() {
    queue<int> q;
    Push(ou, 1);
    while(q.size()) {
        int u = q.front(); q.pop();
        for(int k = 1; k < K; k++)
            if(ukn[k][u]) ans = max(ans, k - p[u]);
        for(int v : G[u]) Push(ou, v);
    }
}
```

其中 `G` 为正图而 `H` 为反图。

注意在 `bfs_1()` 中对于每一个 $1$ 可达的节点枚举价格更新答案。

> 这里实际上有一个显然的（同时也是符合贪心策略的）优化：
> ```cpp
> for(int k = 1; k < K; k++)
>     if(ukn[k][u]) ans = max(ans, k - p[u]);
> ```
> 可以改为
> ```cpp
> for(int k = K - 1; k; k--)
>     if(ukn[k][u]) { ans = max(ans, k - p[u]); break; }
> ```

## 贪心优化

容易发现，对于一个节点 $u$，我们其实并没有必要维护其到每种价格节点的可达性，根据刚才的贪心策略，我们实际上只需要维护 $u$ **可达节点的最大价格**。

我们可以用一个 $mx[u]$ 来维护 $u$ 可达节点的最大价格，从大到小枚举 $k$ 跑 BFS，如果遇到 $mx[v] > k$，那么就不将该节点压入队列。这样一来，每个节点在 BFS 中最多入队一次，复杂度就来到了 $\mathrm O(N+K)$，`bfs_k()` 和 `bfs_1()` 实现如下：

```cpp
void bfs_k(int k) {
	queue<int> q;
    for(int u = 1; u <= n; u++)
        if(un[u] && p[u] == k && mx[u] < k) mx[u] = k, q.push(u);
	while(q.size()) {
		int u = q.front(); q.pop();
 		for(int v : H[u]) if(mx[v] < k) mx[v] = k, q.push(v);
	}
}
void bfs_1() {
	queue<int> q;
	ou[1] = 1, q.push(1);
	while(q.size()) {
		int u = q.front(); q.pop();
		ans = max(ans, mx[u] - p[u]);
		for(int v : G[u]) if(!ou[v]) ou[v] = 1, q.push(v);
	}
}
```

## 离散化优化

在 P1073 这道题目中，这一复杂度已经是最优的了，然而价格的大小实际上对输入开销没有影响。因此在该情景下，价格可以达到很大，此时 $\mathrm O(N+K)$ 的复杂度就显得不那么优了，我们可能需要一个复杂度只和 $N$ 相关的算法。

不妨将 $K$ 的范围扩大到 $1 \le K \le 10^9$（其实还可以扩大到更大，不过没什么必要）。

此时枚举 $K$ 种价格会超时，但是我们实际上只有 $N$ 个节点，也就是最多只有 $N$ 种存在的颜色，因此我们可以将价格离散化，或者将节点按照价格降序排序并枚举，这里提供前一种写法，只需要在主函数略微改动即可：

```cpp
...
set<int> P;
...
int main() {
    ...
	for(int u = 1; u <= n; u++) cin >> p[u], P.insert(p[u]);
    ...
	for(int k : P) bfs_k(k);
    ...
}
```

## 一点减少代码行数的奇技淫巧

注意到三个 BFS 函数的结构极为相似，我们实际上可以通过 lambda 表达式的方式进行复用，这里以朴素写法为例：

```cpp
...
void bfs(vector<int> (&M)[N], int (&st)[N], function<bool(int)> push, function<void(int)> op) {
	queue<int> q;
	for(int u = 1; u <= n; u++) if(push(u)) st[u] = 1, q.push(u);
	while(q.size()) {
		int u = q.front();
		q.pop();
		op(u);
		for(int v : M[u]) if(!st[v]) st[v] = 1, q.push(v);
	}
}
int main() {
    ...
	bfs(H, un, [](int u){ return u == n; }, [](int _){});
	for(int k = 1; k < K; k++) bfs(H, ukn[k], [&k](int u){ return un[u] && p[u] == k; }, [](int _){});
	bfs(G, ou, [](int u){ return u == 1; }, [](int u){
		for(int k = K - 1; k; k--)
			if(ukn[k][u]) { ans = max(ans, k - p[u]); return; }
	});
    ...
}
```

## 关于分层图解法

在 Luogu [该题的题解区](/problem/solution/P1073)中，有很多选手使用了**分层图**来解决这道题目。问题在于，这道题的设计（一次买入一次卖出）使得图中必然有负权边，因此只能使用能够处理负权边的 SPFA 来解决这个问题。

令我惊奇的是，在这道题中 SPFA 并没有被卡掉，仔细思考一下可以发现，SPFA 的时间复杂度不会来到 $\mathrm O(MN)$ 的原因还是本题中 $K$ 极小的范围。这张图上的路径长度在区间 $[-K, K]$，因此每个节点被更新的次数**一定不大于** $\bm{2K}$，因而 SPFA 解法的复杂度实际上是 $\mathrm O(NK)$。

---

## 作者：longlong_int (赞：1)

# 本题思路

设 $i$ 号节点的水晶球价格为 $w_i$。

使用**分层图**算法，即将图复制三份，第一份表示未进行买卖时，第二份图表示买了球后的状态，第三份图表示买完且已卖出时的状态。

## 边权设置

由于题目中说可以在图中任意移动，即代价为 $0$，每层图内部边权设为 $0$ 即可。

在第 $i$ 个节点买需要花费 $w_i$ 的钱，即资金变化为 $-w_i$，所以从第一层图的 $i$ 号节点到第二层图的 $i$ 号节点需要连一条边权为 $-w_i$ 的边。

同理，从从第二层图的 $i$ 号节点到第三层图的 $i$ 号节点需要连一条边权为 $w_i$ 的边。

## 答案

答案为卖完后（第三层）$n$ 号节点的最大花费。即**从第一层 $\textbf{1}$ 号节点到第三层 $\textbf{\textit{n}}$ 号节点的最长路**。

### 考虑输出 $\textbf{0}$ 的情况

输出 $0=0+\dots+0+(-w_i)+w_i+0+\dots+0$，即为在同一个节点买入/卖出，等同于不买入/卖出。

# AC Code

```cpp
#include <bits/stdc++.h>
#define endl '\n'
typedef long long ll;
using namespace std;

const int N = 1e5 + 10;
int arr[N], n, m, dis[N * 3], cnt[N * 3];
bool vis[N * 3];
vector<pair<int, int> > graph[N * 3];
queue<int> q;

void spfa()
{
	memset(dis, 63, sizeof dis);
	memset(vis, 0, sizeof vis);
	memset(cnt, 0, sizeof cnt);
	while (!q.empty()) q.pop();
	dis[1] = 0;
	vis[1] = true;
	q.push(1);
	while (!q.empty())
	{
		int u = q.front();
		q.pop();
		vis[u] = false;
		for (auto i: graph[u])
		{
			if (dis[i.first] > dis[u] + i.second)
			{
				dis[i.first] = dis[u] + i.second;
				if (!vis[i.first])
				{
					q.push(i.first);
					vis[i.first] = true;
					cnt[i.first]++;
				}
			}
		}
	}
	return;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
    {
        cin >> arr[i];
        graph[i].push_back(make_pair(n + i, arr[i])); // 注意这里的小处理，因为要求最长路 = 边权取负后的最短路
        graph[n + i].push_back(make_pair(2 * n + i, -arr[i]));
    }
    for (int i = 1; i <= m; i++)
    {
        int x, y, z;
        cin >> x >> y >> z;
        graph[x].push_back(make_pair(y, 0));
        graph[n + x].push_back(make_pair(n + y, 0));
        graph[2 * n + x].push_back(make_pair(2 * n + y, 0));
        if (z == 2)
        {
            graph[y].push_back(make_pair(x, 0));
            graph[n + y].push_back(make_pair(n + x, 0));
            graph[2 * n + y].push_back(make_pair(2 * n + x, 0));
        }
    }

    spfa();

    cout << -dis[3 * n] << endl; // 前面边权取负，这里取最短路的相反数即为最长路
    return 0;
}
```

---

## 作者：huanhuanonly (赞：1)

介绍一种基于 bfs 的分层图做法。

## 分析

根据题意，题目可以转换为：

有 $n\,(1\leq{n}\leq{10^5})$ 座城市和 $m\,(1\leq{m}\leq{5\times{10^5}})$ 条道路，每座城市都有一个权值 $w_i\,(1\leq{w_i}\leq{100})$，求从城市 $1$ 到城市 $n$ 的所有路径中的 $\max\left\{w_i-w_j\right\}$，其中城市 $i$ 比城市 $j$ 先到达或者 $i=j$。

对于每座城市 $i$，我们只需要在他的节点信息中记录下从城市 $1$ 到城市 $i$ 的所有路径中分别有哪些权值，每座城市最多有 $2^{\max\{w_i\}}$ 种可能，所以我们的状态分层分为 $2^{\max\{w_i\}}$ 层，可以用 $\max\{w_i\}$ 个二进制位来表示。

现在有 $f_{i,j}\;(1\leq{i}\leq{n},1\leq{j}\leq{\max\limits_{k=1}^{n}\{w_k\}})$ 表示：
- 如果 $f_{i,j}=1$，则表示从城市 $1$ 到城市 $i$ 的所有路径中存在一个城市的权值为 $j$；
- 否则，$f_{i,j}=0$。

由于 $f_{i,j}\in\{0,1\}$，可以使用 `std::bitset` 进行优化：

```cpp
std::vector<std::bitset<101>> f(n + 1);
```

从当前城市 $i$ 到下一个城市 $j$ 的状态转移方程为：

$$f_{j}\coloneqq{f_i}\cup\{w_j\}$$

初始状态为：

$$f_{1,w_1}\coloneqq1$$

值得注意的是，最后的答案并不是 $\max\{j\}-\min\{j\}\quad(f_{n,j}=1)$，因为无法确定权值出现的顺序，正确的做法是在每次转移的时候一并取最大值。

再考虑一种特殊情况，通过这条路径无法到达城市 $n$，或者，走到城市 $n$ 后继续往下走，但没有路再可以返回到城市 $n$，这种情况下经过了城市 $n$ 到后面的城市是不能更新答案的，因为题目要求终点必须是城市 $n$，为此，我们可以先进行一次预处理，标记出所有不能到达城市 $n$ 的城市。

其中一种做法是，先建一张反图，默认标记所有城市，然后使用 bfs 从城市 $n$ 出发，取消所有能到达的城市的标记。

最后，使用 bfs 从城市 $1$ 出发（永远不经过被标记的城市），跑一遍状态转移就能得到答案。

## 完整代码

```cpp
#include <bits/stdc++.h>

int main(void)
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr), std::cout.tie(nullptr);

    int n, m;
    std::cin >> n >> m;

    std::vector<int> v(n + 1);

    for (int i = 1; i <= n; ++i)
    {
        std::cin >> v[i];
    }

    using bset = std::bitset<101>;

    struct edge
    {
        int point;
        bset bs;
    };

    std::vector<std::vector<edge>> e(n + 1);

    for (int i = 1; i <= m; ++i)
    {
        int x, y, z;
        std::cin >> x >> y >> z;

        e[x].push_back(edge{y, {}});

        if (z == 2)
        {
            e[y].push_back(edge{x, {}});
        }
    }
    
    // 用于标记不能到达城市 n 的点
    std::vector<bool> deleted(n + 1, true);

    {
        // 反向边
        std::vector<std::vector<int>> re(n + 1);

        for (int u = 1; u < e.size(); ++u)
        {
            for (const auto& [v, bs] : e[u])
            {
                re[v].push_back(u);
            }
        }

        std::queue<int> que;
        que.push(n);
        deleted[n] = false;

        while (not que.empty())
        {
            int cur = que.front();
            que.pop();

            for (int i : re[cur])
            {
                if (deleted[i])
                {
                    deleted[i] = false;
                    que.push(i);
                }
            }
        }
    }

    // 直接使用 vis 数组做状态转移，同样也可以标记是否走过
    std::vector<bset> vis(n + 1);

    int ans = 0;

    auto bfs = [&]() -> void
    {
        std::queue<edge> que;
        que.push({1, bset{}.set(v[1])});
        vis[1].set(v[1]);

        while (not que.empty())
        {
            auto cur = que.front();
            que.pop();

            for (const auto& i : e[cur.point])
            {
                if (deleted[i.point])
                {
                    continue;
                }

                auto next = cur.bs;
                next.set(v[i.point]);

                if ((vis[i.point] & next) == next)
                {
                    continue;
                }

                vis[i.point] |= next;
                
                if (auto f = vis[cur.point]._Find_first(); f != vis[cur.point].size())
                {
                    ans = std::max(ans, v[i.point] - static_cast<int>(f));
                }
                
                que.push({i.point, next});
            }
        }
    };

    bfs();

    std::cout << ans;

    return 0;
}
```

虽然这种做法无需使用 Dijkstra 或 SPFA，但分的层数多，每个点都最多可以走 $\max\{w_i\}$ 次，~~也是能和 SPFA 一样被卡的hhh~~。[提交记录](https://www.luogu.com.cn/record/217787778)。

---


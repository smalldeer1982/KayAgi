# 【模板】2-SAT

## 题目描述

有 $n$ 个布尔变量 $x_1\sim x_n$，另有 $m$ 个需要满足的条件，每个条件的形式都是 「$x_i$ 为 `true` / `false` 或 $x_j$ 为 `true` / `false`」。比如 「$x_1$ 为真或 $x_3$ 为假」、「$x_7$ 为假或 $x_2$ 为假」。

2-SAT 问题的目标是给每个变量赋值使得所有条件得到满足。

## 说明/提示

$1\leq n, m\leq 10^6$ , 前 $3$ 个点卡小错误，后面 $5$ 个点卡效率。

由于数据随机生成，可能会含有（ 10 0 10 0）之类的坑，但按照最常规写法的写的标程没有出错，各个数据点卡什么的提示在标程里。

## 样例 #1

### 输入

```
3 1
1 1 3 0```

### 输出

```
POSSIBLE
0 0 0```

# 题解

## 作者：Anguei (赞：504)

## 什么是 2-SAT？
首先，把「2」和「SAT」拆开。SAT 是 Satisfiability 的缩写，意为可满足性。即一串布尔变量，每个变量只能为真或假。要求对这些变量进行赋值，满足布尔方程。

举个例子：教练正在讲授一个算法，代码要给教室中的多位同学阅读，代码的码风要满足所有学生。假设教室当中有三位学生：Anguei、Anfangen、Zachary_260325。现在他们每人有如下要求：

+ **Anguei**: 我要求代码当中满足下列条件之一：
  1. 不写 `using namespace std;` （ $\neg a$）
  2. 使用读入优化 （$b$）
  3. 大括号不换行 （$\neg c$）
+ **Anfangen**: 我要求代码当中满足下条件之一：
  1. 写 `using namespace std;` （$a$）
  2. 使用读入优化 （$b$）
  3. 大括号不换行 （$\neg c$）
+ **Zachary_260325**：我要求代码当中满足下条件之一：
  1. 不写 `using namespace std;` （$\neg a$）
  2. 使用 `scanf` （$\neg b$）
  3. 大括号换行 （$c$）
 
我们不妨把三种要求设为 $a,b,c$，变量前加 $\neg$ 表示「不」，即「假」。上述条件翻译成布尔方程即：$(\neg a\vee b\vee\neg c) \wedge (a\vee b\vee\neg c) \wedge (\neg a\vee\neg b\vee c)$。其中，$\vee$ 表示或，$\wedge$ 表示与。（就像集合中并集交集一样）

现在要做的是，为 ABC 三个变量赋值，满足三位学生的要求。

Q: 这可怎么赋值啊？暴力？

A: 对，这是 SAT 问题，已被证明为 **NP 完全** 的，只能暴力。

Q: 那么 2-SAT 是什么呢？

A: 2-SAT，即每位同学 **只有两个条件**（比如三位同学都对大括号是否换行不做要求，这就少了一个条件）不过，仍要使所有同学得到满足。于是，以上布尔方程当中的 $c,\neg c$ 没了，变成了这个样子：$(\neg a\vee b) \wedge (a\vee b) \wedge (\neg a\vee\neg b)$

## 怎么求解 2-SAT 问题？
**使用强连通分量。** 对于每个变量 $x$，我们建立两个点：$x, \neg x$ 分别表示变量 $x$ 取 `true` 和取 `false`。所以，**图的节点个数是两倍的变量个数**。**在存储方式上，可以给第 $i$ 个变量标号为 $i$，其对应的反值标号为 $i + n$**。对于每个同学的要求 $(a \vee b)$，转换为 $\neg a\rightarrow b\wedge\neg b\rightarrow a$。对于这个式子，可以理解为：「若 $a$ 假则 $b$ 必真，若 $b$ 假则 $a$ 必真」然后按照箭头的方向建有向边就好了。综上，我们这样对上面的方程建图：

| 原式 | 建图 |
| :----------- | :----------- |
| $\neg a\vee b$     | $a\rightarrow b\wedge\neg b\rightarrow\neg a$ |
| $a \vee b$         | $\neg a\rightarrow b\wedge\neg b\rightarrow a$ |
| $\neg a\vee\neg b\space \space $ | $a\rightarrow\neg b\wedge b\rightarrow\neg a$ |

于是我们得到了这么一张图：

![built](https://s1.ax1x.com/2018/08/22/PTAjy9.png)

可以看到，$\neg a$ 与 $b$ 在同一强连通分量内，$a$ 与 $\neg b$ 在同一强连通分量内。**同一强连通分量内的变量值一定是相等的**。也就是说，如果 $x$ 与 $\neg x$ 在同一强连通分量内部，一定无解。反之，就一定有解了。

但是，对于一组布尔方程，可能会有多组解同时成立。要怎样判断给每个布尔变量赋的值是否恰好构成一组解呢？

这个很简单，只需要 **当 $x$ 所在的强连通分量的拓扑序在 $\neg x$ 所在的强连通分量的拓扑序之后取 $x$ 为真** 就可以了。在使用 Tarjan 算法缩点找强连通分量的过程中，已经为每组强连通分量标记好顺序了——**不过是反着的拓扑序**。所以一定要写成 `color[x] < color[-x]` 。

时间复杂度：$O(N + M)$

## 说了这么多，咋不上代码啊？
核心代码在下面。
### 建图
```cpp
n = read(), m = read();
for (int i = 0; i < m; ++i) {
    // 笔者习惯对 x 点标号为 x，-x 标号为 x+n，当然也可以反过来。
    int a = read(), va = read(), b = read(), vb = read();
    if (va && vb) { // a, b 都真，-a -> b, -b -> a
        g[a + n].push_back(b);
        g[b + n].push_back(a);
    } else if (!va && vb) { // a 假 b 真，a -> b, -b -> -a
        g[a].push_back(b);
        g[b + n].push_back(a + n);
    } else if (va && !vb) { // a 真 b 假，-a -> -b, b -> a
        g[a + n].push_back(b + n);
        g[b].push_back(a);
    } else if (!va && !vb) { // a, b 都假，a -> -b, b -> -a
        g[a].push_back(b + n);
        g[b].push_back(a + n);
    }
}
```
当然，还有更精简的位运算建图方式，可以免去上面的四个 if：
```cpp
n = read(), m = read();
for (int i = 0; i < m; ++i) {
    int a = read(), va = read(), b = read(), vb = read();
    g[a + n * (va & 1)].push_back(b + n * (vb ^ 1));
    g[b + n * (vb & 1)].push_back(a + n * (va ^ 1));
}
```


### 找环
```cpp
// 注意所有东西都要开两倍空间，因为每个变量存了两次
void tarjan(int u) {
    low[u] = dfn[u] = ++dfsClock;
    stk.push(u); ins[u] = true;
    for (const auto &v : g[u]) {
        if (!dfn[v]) tarjan(v), low[u] = std::min(low[u], low[v]);
        else if (ins[v]) low[u] = std::min(low[u], dfn[v]);
    }
    if (low[u] == dfn[u]) {
        ++sccCnt;
        do {
            color[u] = sccCnt;
            u = stk.top(); stk.pop(); ins[u] = false;
        } while (low[u] != dfn[u]);
    }
}
// 笔者使用了 Tarjan 找环，得到的 color[x] 是 x 所在的 scc 的拓扑逆序。
for (int i = 1; i <= (n << 1); ++i) if (!dfn[i]) tarjan(i);
```
### 输出
```cpp
for (int i = 1; i <= n; ++i)
    if (color[i] == color[i + n]) { // x 与 -x 在同一强连通分量内，一定无解
        puts("IMPOSSIBLE");
        exit(0);
    }
puts("POSSIBLE");
for (int i = 1; i <= n; ++i)
    print((color[i] < color[i + n])), putchar(' '); // 如果不使用 Tarjan 找环，请改成大于号
puts("");
```

---

## 作者：Piwry (赞：38)

貌似少有题解解释 “取拓扑序较大者” 这步的正确性，于是这里就补充个简短的证明

另外在我查阅资料时，还发现有以 wiki 为代表的另一种 2-sat 做法，主要区别在最后一步；由于没什么实现价值，这里就不展开了。有兴趣可以参考 [“2-SAT 解法浅析”](https://www.oschina.net/uploads/doc/sat2_sjtu_zhaoshuang.pdf), [wiki(en)](https://en.wikipedia.org/wiki/2-satisfiability)

## 解析

### Part 0 - 导入

一般我们求解 2-sat 的过程为：

1. 建图（具体略）
2. 对图求出强联通分量，并求出缩点后的拓扑序
3. 若存在对应同一个变量的两个结点在同一个分量内，即无解
4. 否则一定有解；对每个变量取所在分量拓扑序较大的那个对应结点，一定能构造出一组合法解

其中不太显然的地方主要在 $\text{4.}$

### Part 1 - 引理

设变量 $x_i$ 对应的结点为 $u_{i, p}, p\in \{0, 1\}$

先考虑这样一个引理：

> 引理 $1.$ 若存在边 $(u_{i, p}, u_{j, q})$，那么一定对应地存在边 $(u_{j, q\text{ xor }1}, u_{i, p\text{ xor }1})$

考虑我们建图的连边规则，这是显然的（即若有要求 「$x_i=b_1$ 或 $x_j=b_2$」，那么 $x_i$ 对应的不满足要求的结点（$u_{i, b_1\text{ xor }1}$）就会向 $x_j$ 对应的满足要求的结点（$u_{j, b_2}$）连一条有向边；另一条边亦然）

更进一步地，有如下引理：

> 引理 $2.$ 若存在路径（单向）$p(u_{i, p}, u_{j, q})$，那么一定对应地存在路径 $p(u_{j, q\text{ xor }1}, u_{i, p\text{ xor }1})$

对路径上每一条边运用 $\text{引理 1.}$ 即可得到

### Part 2 - 证明

再考虑我们算法的 $\text{4.}$；不妨用反证法证明其正确性

记 $f(u_{i, p})$ 表示 $u_{i, p}$ 所在分量的（缩点后的）拓扑序

设有 $f(u_{i, p})<f(u_{i, p\text{ xor }1}) [1], f(u_{j, q})>f(u_{j, q\text{ xor }1}) [2]$，且存在路径（单向）$P_1=p(u_{j, q}, u_{i, p})$。显然这由我们的算法会得到一个非法的结果

考虑 $\text{引理 2.}$，得出也存在路径 $P_2=p(u_{i, p\text{ xor }1}, u_{j, q\text{ xor }1})$。由 $P_1$ 可推出 $f(u_{j, q})<f(u_{i, p}) [3]$，由 $P_2$ 可推出 $f(u_{i, p\text{ xor }1})<f(u_{j, q\text{ xor }1}) [4]$。联立 $[1], [3], [4]$ 可得 $f(u_{j, q})<f(u_{j, q\text{ xor }1})$，这和作为前提的 $[2]$ 是矛盾的；由此可推得算法的 $\text{4.}$ 是正确的

（这部分作图可能会更直观w）

## CODE

仅供参考

```cpp
#include <cstdio>
#include <algorithm>
using std::min;

/*------------------------------IO------------------------------*/

namespace IO_number{
	int read(){
		int x =0; char c =getchar(); bool f =0;
		while(c < '0' || c > '9') (c == '-') ? f =1, c =getchar() : c =getchar();
		while(c >= '0' && c <= '9') x =(x<<1)+(x<<3)+(48^c), c =getchar();
		return (f) ? -x : x;
	}
	
	void write(const int &x){
		if(x/10)
			write(x/10);
		putchar('0'+x%10);
	}
}
using namespace IO_number;

/*------------------------------Graph------------------------------*/

const int MAXN =1e6+20;

int first[MAXN<<1], tote;
struct edge{
	int to, nxt;
}e[MAXN<<1];

inline void addedge(const int &u, const int &v){
	++tote, e[tote].to =v, e[tote].nxt =first[u], first[u] =tote;
}

/*------------------------------Tarjan------------------------------*/

int scc_id[MAXN<<1], Scc_id;

int dfn[MAXN<<1], low[MAXN<<1], Dfn;
int stk[MAXN<<1], stk_top;
bool instk[MAXN<<1];

void tarjan(const int &u){
	low[u] =dfn[u] =++Dfn;
	stk[stk_top++] =u;
	instk[u] =1;
	for(int l =first[u]; l; l =e[l].nxt){
		if(!dfn[e[l].to]){
			tarjan(e[l].to);
			low[u] =min(low[u], low[e[l].to]);
		}
		else if(instk[e[l].to])
			low[u] =min(low[u], dfn[e[l].to]);
	}
	if(low[u] == dfn[u]){
		++Scc_id;
		while(stk[stk_top] != u){
			scc_id[stk[stk_top-1]] =Scc_id;
			instk[stk[stk_top-1]] =0;
			--stk_top;
		}
	}
}

/*------------------------------Main------------------------------*/

int main(){
	int n =read(), m =read();
	for(int t =0; t < m; ++t){
		int i =read(), a =read(), j =read(), b =read();
		/* [1, n] -> false, [n+1, 2n] -> true */
		// x_i, x_j 均不满足不能同时成立 //
		addedge(i+(a^1)*n, j+b*n);
		addedge(j+(b^1)*n, i+a*n);
	}
	
	for(int i =1; i <= 2*n; ++i){
		if(!dfn[i])
			tarjan(i);
		if(i <= n && scc_id[i] == scc_id[i+n])
			return puts("IMPOSSIBLE") && 0;
	}
	puts("POSSIBLE");
	for(int i =1; i <= n; ++i)
		write((scc_id[i+n] < scc_id[i])), putchar(' ');
}
```

---


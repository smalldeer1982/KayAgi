# 「CGOI-3」残暴圣所

## 题目背景

终于打过春二心门的 ac 来到了春三，并决定预测一下残暴圣所（Ferocious Sanctuary）的难度。

[![](https://cdn.luogu.com.cn/upload/image_hosting/xolrra48.png?x-oss-process=image/resize,m_lfit,h_340,w_450)](//www.bilibili.com/video/BV1Cg411v7Ji)

## 题目描述

为了通关残暴圣所，ac 需要在接下来的 $2n$ 个时刻进行 $n$ 次操作。第 $i$ 次操作需要在时刻 $l_i$ 按下某个按键，此后一直按住这个按键，直到时刻 $r_i$ 松开它（$l_i<r_i$）。在每个时刻，ac 要么按下一个按键，要么松开一个按键，但是可以同时按住多个按键。

第 $i$ 次操作形成了一个操作区间 $[l_i,r_i]$，满足 $l_i$ 严格递增。并且，由于残暴圣所的关卡设计，任意两个操作形成的操作区间之间，要么不交，要么包含。

ac 设计了 $2n$ 个难度系数 $a_1,a_2,\dots,a_{2n}$。第 $i$ 次操作的难度可以用 $a_{l_i}\times a_{r_i}$ 来评估，而通关残暴圣所的难度即为所有操作的难度之和。

然而，由于 ac 卡在了残暴圣所的第一面，所以他并不知道每个操作的操作区间。在给定 $n$ 和 $\{a\}$ 的前提下，请你计算对于所有可能的情况，通关残暴圣所的难度之和，对 $998244353$ 取模。

#### 形式化题意：

给定一个长为 $2n$ 的数列 $a_1,a_2,\dots,a_{2n}$。

定义“区间组”由 $n$ 个区间组成，第 $i$ 个区间为 $[l_i,r_i]\ (1\le l_i<r_i\le2n)$，求所有满足下列条件的区间组的 $\sum_{i=1}^na_{l_i}\times a_{r_i}$ 之和对 $998244353$ 取模：

1. $l_1,r_1,l_2,r_2,\dots,l_n,r_n$ 是 $1,2,\dots,2n$ 的一个排列。
2. $\forall 1\le i<n$，$l_i<l_{i+1}$。
3. $\forall i,j$，$[l_i,r_i]\cap[l_j,r_j]=\varnothing$ 或 $[l_i,r_i]\sube[l_j,r_j]$ 或 $[l_j,r_j]\sube[l_i,r_i]$。


## 说明/提示

#### 样例说明

对于样例 1，可能的两个操作区间只有两种情况：

1. $[1,2],[3,4]$，通关难度为 $a_1a_2+a_3a_4=1612986$。
2. $[1,4],[2,3]$，通关难度为 $a_1a_4+a_2a_3=1078706$。

难度之和为 $1612986+1078706=2691692$，对 $998244353$ 取模后仍为 $2691692$。

以下几种情况是不合法的：

1. $[3,4],[1,2]$，因为要求 $l_i$ 严格递增，而 $l_1\ge l_2$。
2. $[1,1],[2,4]$，因为要求 $l_i<r_i$，而 $l_1\ge r_1$。
3. $[1,3],[2,3]$，因为要求在每个时刻，要么按下一个按键，要么松开一个按键，而第三个时刻松开了两个按键，第四个时刻没有按下或松开任何一个按键。
4. $[1,3],[2,4]$，因为要求任意两个操作区间不交或包含，而这两个区间之间有交，并且没有包含关系。

---

#### 数据范围

对于 $10\%$ 的数据，$n\le15$。

对于 $30\%$ 的数据，$n\le200$。

对于 $50\%$ 的数据，$n\le3000$。

对于另 $5\%$ 的数据，$a_i=1$。

对于 $100\%$ 的数据，$1\le n\le5\times10^5$，$0\le a_i<998244353$。

## 样例 #1

### 输入

```
2
114 514 1919 810```

### 输出

```
2691692```

## 样例 #2

### 输入

```
3
1 1 4 5 1 4```

### 输出

```
98```

## 样例 #3

### 输入

```
8
275272885 418731188 289662326 114331587 192436268 885936831 877490593 508774565 633402863 149033362 995239139 494498006 168828873 138947653 983144753 844326228```

### 输出

```
349824160```

# 题解

## 作者：Register_int (赞：5)

题面中的神奇区间包含条件，本质上就是括号序列。所以先把题面换成人能听懂的语言：求出所有括号序列中每对括号的权值之和。

考虑枚举一对括号，计算这对括号会对多少种括号序列产生贡献。填入这一对括号后，括号内的部分可以乱填，去掉这对括号后括号外也可以乱填。设 $c_i$ 为卡特兰数的第 $i$ 项，那么括号 $[l,r]$ 产生贡献的括号序列种数为 $c_{\frac{r-l-1}2}\times c_{\frac{2n-r+l-1}2}$。枚举括号就可以通过 $50$ 分。

接下来把暴力的柿子列出来大力推导，其中约定 $b_{2n-i+1}=a_i$。
$$
\begin{aligned}
&\sum^{n}_{i=1}\sum^n_{j=i}(a_{2i-1}\times a_{2j}+a_{2i}\times a_{2j+1})\times c_{j-i}\times c_{n-j+i-1}\\
=&\sum^{n-1}_t\sum^{n-t}_{i=1}(a_{2i-1}\times a_{2(t+i)}+a_{2i}\times a_{2(t+i)+1})\times c_{t}\times c_{n-t-1}\\
=&\sum^{n-1}_tc_{t}\times c_{n-t-1}\sum^{n-t}_{i=1}(a_{2i-1}\times a_{2(t+i)}+a_{2i}\times a_{2(t+i)+1})\\
=&\sum^{n-1}_tc_{t}\times c_{n-t-1}\sum^{n-t}_{i=1}(a_{2i-1}\times b_{2n-2(t+i)+1}+a_{2i}\times b_{2n-2(t+i)})\\
=&\sum^{n-1}_tc_{t}\times c_{n-t-1}\sum^{n-t}_{i=1}(a_{2i-1}\times b_{2(n-t)-2i+1}+a_{2i}\times b_{2(n-t)-2i})\\
=&\sum^{n-1}_tc_{t}\times c_{n-t-1}\sum^{2(n-t)}_ia_i\times b_{2(n-t)-i}\\
\end{aligned}
$$
设 $A(x)=\sum^{2n}_ia_ix^i$，$B(x)=\sum^{2n}_ib_ix^i$，$f(x)=A(x)B(x)$，则：
$$
\begin{aligned}
=&\sum^{n-1}_tc_{t}\times c_{n-t-1}\sum^{2(n-t)}_ia_i\times b_{2(n-t)-i}\\
=&\sum^{n-1}_tc_{t}\times c_{n-t-1}\times[x^{2(n-t)}]f(x)\\
\end{aligned}
$$
一次卷积即可。

# AC 代码 
```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

namespace polynomial {
//	by Register_int.
}

using namespace polynomial;

const int MAXN = 1e6 + 10;

int n, m; ll c[MAXN], ans;

poly<ll> f, g;

int main() {
	scanf("%d", &n), m = n << 1, c[0] = 1, f.resize(m + 1), g.resize(m + 1);
	for (int i = 1; i <= m; i++) scanf("%lld", &f[i]), g[m - i + 1] = f[i]; f *= g;
	for (int i = 1; i <= n; i++) c[i] = c[i - 1] * (4 * i - 2) % mod * inv(i + 1) % mod;
	for (int i = 0; i < n; i++) ans = (ans + c[i] * c[n - i - 1] % mod * f[n - i << 1] % mod) % mod;
	printf("%lld", ans);
}
```

---

## 作者：TernaryTree (赞：0)

多项式练手题。

考虑拆贡献，枚举一对括号在总答案中做的贡献。

长为 $2n$ 的合法括号序列的个数是 $\textrm{Catalan}[n]$，$\textrm{Catalan}$ 是卡特兰数列，可以预处理。对于当前括号里面的部分是一个合法括号串，方案数为 $\textrm{Catalan}\left[\dfrac{j-i-1}{2}\right]$。而将 $[i,j]$ 区间扔掉，将 $[1,i-1]$ 与 $[j+1,2n]$ 合并也能得到合法括号串，方案数为 $\textrm{Catalan}\left[\dfrac{2n-j+i-1}{2}\right]$。因此这对括号做出的贡献即为

$$
\sum_{i=1}^{2n}
  \sum_{j=i+1}^{2n}
    \textrm{Catalan}\left[\dfrac{j-i-1}{2}\right]
    \textrm{Catalan}\left[\dfrac{2n-j+i-1}{2}\right]
    a[i]a[j]\ \  [j-i\bmod 2=1]
$$

设 $j-i=t$，则原式变为

$$
\begin{aligned}
&\sum_{t\bmod 2=1}^{2n}
  \sum_{i=1}^{n-t}
    \textrm{Catalan}\left[\dfrac{t-1}{2}\right]
    \textrm{Catalan}\left[\dfrac{2n-t-1}{2}\right]
    a[i]a[i+t] \\
=&\sum_{t\bmod 2=1}^{2n}
    \textrm{Catalan}\left[\dfrac{t-1}{2}\right]
    \textrm{Catalan}\left[\dfrac{2n-t-1}{2}\right]
    \sum_{i=1}^{n-t}a[i]a[i+t] \\
\end{aligned}
$$

后面这个东西是一个经典的多项式优化。设 $b[i]=a[n-i]$，则 $a[i+t]=b[n-t-i]$。则

$$
\begin{aligned}
&\sum_{i=1}^{n-t}a[i]a[i+t] \\
=&\sum_{i=1}^{n-t}a[i]b[n-t-i]
\end{aligned}
$$

将 $a,b$ 作为系数整成多项式 $A(x),B(x)$，则上式即为

$$[x^{n-t}](A*B)(x)$$

$998244353$ 是 NTT 模数，使用 NTT 即可。时间复杂度 $\Theta(n\log n)$。

[Code](https://www.luogu.com.cn/paste/q3qd0n02)。

---

## 作者：daniEl_lElE (赞：0)

多项式经典题。、

## 思路

先换 $\sum$，枚举 $i,j$，判断 $a_{i}\times a_{j}$ 被多少个括号序列给包含了。

不难发现长度为 $2x$ 的括号序列数量为[卡特兰数](https://baike.baidu.com/item/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/6125746?fr=aladdin)第 $x$ 项（令其为 $H_x$，当 $x$ 不为自然数时 $H_x=0$）

不难发现式子变成了 $\sum_{i=1}^n\sum_{j=i+1}^na_i\times a_j\times H_{\frac{j-i-1}{2}}\times H_{\frac{i-1+2\times n-j}{2}}$。

令 $G_x=H_{\frac{x-1}{2}}\times H_{\frac{2\times n-1-x}{2}}$。不难发现对于所有 $j-i=x$，$a_i\times a_j$ 的系数均为 $G_x$。考虑这个 $j-i$，是一个经典的差卷积式子。所以我们可以在 $\Theta(n\log n)$ 的时间复杂度内解决本题。

## 代码

```

signed main(){
	init();
	int n=read(),m,ans=0;n*=2;
	for(int i=0;i<n;i++) a[i]=read(),b[i]=a[i]; m=n;//将正方向与反方向的 a[i] 卷起来
	reverse(b,b+n);//翻转做差卷积
	t=1;//卷积模板 开头
	int len=0;
	while(t<=n+m) t*=2,len++;
	for(int i=0;i<t;i++) id[i]=(id[i>>1]>>1)|((i&1)<<(len-1));
	for(int i=2;i<=t;i*=2) g[i][1]=qp(3,(mod-1)/i),g[i][0]=qp(g[i][1],mod-2);
	ntt(a,1); ntt(b,1)
	for(int i=0;i<t;i++) f[i]=a[i]*b[i]%mod;
	ntt(f,0);
	int x=qp(t,mod-2);
	for(int i=0;i<n;i++) (f[i]*=x)%=mod;//卷积模板 结尾
	reverse(f,f+n);//差卷积翻转回来
	for(int i=1;i<n;i+=2) (ans+=f[i]*Ca((i-1)/2)%mod*Ca((n-i-1)/2)%mod)%=mod;//Ca 表示卡特兰数，式子如上。
	cout<<ans;
	return 0;
}
```

---


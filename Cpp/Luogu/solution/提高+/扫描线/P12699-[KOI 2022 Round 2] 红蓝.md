# [KOI 2022 Round 2] 红蓝

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

在坐标平面上有 $N$ 个红色点和 $M$ 个蓝色点。给定自然数 $W$ 和 $H$。

第 $i$ 个 ($1 \leq i \leq N$) 红色点的坐标是 $(r_{xi}, r_{yi})$，第 $j$ 个 ($1 \leq j \leq M$) 蓝色点的坐标是 $(b_{xj}, b_{yj})$。

所有点的坐标都是不同的。

我们需要放置一个宽度为 $W$，高度为 $H$ 的矩形，该矩形的边与坐标轴平行，并且它的四个顶点是整数坐标。我们希望最大化矩形内包含的红色点与蓝色点数量之差。

矩形包含点的条件是：如果矩形的左下角坐标为 $(a, b)$，且点的坐标为 $(x, y)$，那么该点包含在矩形内当且仅当满足 $a \leq x \leq a+W$ 且 $b \leq y \leq b+H$。

我们要求得这个差值的最大值，并找到符合这个最大差值的矩形位置。

下图展示了在平面上有 3 个红色点和 4 个蓝色点的情况。为了说明问题，红色点用圆圈表示，蓝色点用三角形表示。

![](https://cdn.luogu.com.cn/upload/image_hosting/1j8grh16.png)

假设 $W = 5$，$H = 3$，那么如果将矩形的左下角放在 $(3, 3)$，矩形内包含 1 个红色点和 3 个蓝色点，这时点的数量差为 2。无论矩形放置在哪里，点的数量差都不会大于 3，因此答案是 2。

![](https://cdn.luogu.com.cn/upload/image_hosting/fxgmqc3b.png)

## 说明/提示

**约束条件**

- $1 \leq N, M \leq 100\,000$
- $1 \leq W, H \leq 10^9$
- $1 \leq r_{xi}, r_{yi} \leq 10^9$ ($1 \leq i \leq N$)
- $1 \leq b_{xj}, b_{yj} \leq 10^9$ ($1 \leq j \leq M$)

**子任务**

1. （5 分）$1 \leq N, M, W, H, r_{xi}, r_{yi}, b_{xj}, b_{yj} \leq 50$
2. （11 分）$1 \leq N, M, W, H, r_{xi}, r_{yi}, b_{xj}, b_{yj} \leq 1\,000$
3. （15 分）$1 \leq N, M \leq 100$
4. （9 分）$1 \leq N, M \leq 1\,000$
5. （60 分）无额外约束条件

## 样例 #1

### 输入

```
3 4 5 3
3 2
2 5
7 6
1 2
4 3
3 6
7 4```

### 输出

```
2
3 3```

## 样例 #2

### 输入

```
3 3 4 4
1 1
2 2
3 3
1 3
3 1
4 4```

### 输出

```
2
-2 -2```

# 题解

## 作者：ImposterAnYu (赞：3)

~~神人题目，写死人~~

提供一个线段树+离散化+类似双指针~~或者说，两根扫描线~~的做法。

我们先将横坐标和纵坐标离散化，然后用一上一下两根线夹住一个高度差不超过 $H$ 的矩形（底自然是无限长啦），在块内加入所有的红点和蓝点，加入红点时在线段树上右端点为 $x_i$ 离散化后的值，左端点为 $x_i + W$ 离散化后的值这段区间加 $1$（因为这段区间上的点作为答案矩形**右下角**的点时都可以覆盖到这个点），而蓝点则在这段区间上 $-1$。

随后，我们在线段树上维护最大值和最小值，这样查询时我们只要得到全局的最大值和最小值的绝对值，就可以算出两种颜色之差的最大值了。

进一步我们可以发现：因为矩形规定了高度为 $H$ ，所以下线向上移动时上线可以同时向上移动。~~这个过程像极了双指针。~~

所以，我们可以先把下线放在最底部，逐步向上移动上线直到和下线的距离即将超过 $H$，并在向上移动上线的同时加入上线扫过的点；接下来，使用线段树维护答案**以及取得该答案的位置**，并更新答案；最后，将在下线上的点删除，并将下线上移一个位置。反复操作直到扫完所有的点，即可得到答案。

最后两个要注意的点：

1. 上下线可能出现的位置有 $3(n + m)$ 个，数组别开小了。
2. 我们得到的取到答案的点在矩形的右下角，所以输出时横坐标要减去 $W$。如果不想减的话，可以把上面提到的区间 $[x_i,x_i + W]$ 改成 $[x_i - W,x_i]$，这样就可以得到左下角的点。


```cpp
#include <bits/stdc++.h>
#define int1 int
#define N 600000
#define M 1200000
#define INF 1145141919
#define ls (d << 1)
#define rs (d << 1 | 1)
using namespace std;
int1 n,nm,m,H,W,i,l[N + 5],r[N + 5],y[N + 5],v[N + 5];
vector<int1> aty[N + 5];//把纵坐标相同的点记录在一起
int1 siz[N + 5];
int1 lth[2],lsh[2][N + 5];//离散化用的
int1 maxn[M + 5],minn[M + 5],tag[M + 5];//区间最大值/区间最小值/懒标记
int1 maxp[M + 5],minp[M + 5];//区间最大值出现的位置/区间最小值出现的位置
int1 ans,ansx,ansy;
int1 read(){
	int1 x = 0,f = 1;
	char ch = getchar();
	while(!isdigit(ch)){
		if(ch == '-'){
			f = -1;
		}
		ch = getchar();
	}
	while(isdigit(ch)){
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
	return x * f;
}
void uprint(int1 x){
	if(x > 9){
		uprint(x / 10);
	}
	putchar(x % 10 ^ 48);
	return ;
}
void print(int1 x){
	if(x < 0){
		putchar('-');
		x = -x;
	}
	uprint(x);
	return ;
}
void ps(int1 x){
	print(x);
	putchar(' ');
	return ;
}
void pe(int1 x){
	print(x);
	putchar('\n');
	return ;
}
void push_up(int1 d){//上传，更新答案
	if(maxn[ls] >= maxn[rs]){
		maxp[d] = maxp[ls];
		maxn[d] = maxn[ls];
	}else{
		maxp[d] = maxp[rs];
		maxn[d] = maxn[rs];
	}
	if(minn[ls] <= minn[rs]){
		minp[d] = minp[ls];
		minn[d] = minn[ls];
	}else{
		minp[d] = minp[rs];
		minn[d] = minn[rs];
	}
	return ;
}
void build(int1 d,int1 l,int1 r){//建树，初始化最大值/最小值出现的位置
	if(l == r){
		maxp[d] = minp[d] = l;
		return ;
	}
	int1 mid = (l + r) >> 1;
	build(ls,l,mid);
	build(rs,mid + 1,r);
	push_up(d);
	return ;
}
void f(int1 d,int1 k){//修改节点
	maxn[d] += k,minn[d] += k,tag[d] += k;
	return ;
}
void push_down(int1 d){//标记下传
	if(tag[d]){
		f(ls,tag[d]);
		f(rs,tag[d]);
		tag[d] = 0;
	}
	return ;
}
void change(int1 d,int1 l,int1 r,int1 x,int1 y,int1 k){//区间修改
	if(x <= l && r <= y){
		f(d,k);
		return ;
	}
	push_down(d);
	int1 mid = (l + r) >> 1;
	if(x <= mid){
		change(ls,l,mid,x,y,k);
	}
	if(y > mid){
		change(rs,mid + 1,r,x,y,k);
	}
	push_up(d);
	return ;
}
void comp(int1 s,int1 x,int1 y){
	if(s > ans){
		ans = s,ansx = x,ansy = y;
	}
	return ;
}
int main(){
	n = read(),m = read(),W = read(),H = read();
	for(i = 1; i <= n; i++){
		int1 xx = read(),yy = read(),xxx = xx + W;//读入红点
		lth[0]++;
		l[i] = xx,r[i] = xxx,y[i] = yy,v[i] = 1;//并预处理点可以贡献到的位置（区间）
		lsh[0][lth[0]] = xx;
		lth[1]++;
		lsh[1][lth[1]] = yy;
		lth[0]++;
		lsh[0][lth[0]] = xxx;
		lth[1]++;
		lsh[1][lth[1]] = yy + H;//记录矩形上下边可能出现的位置
		lth[1]++;
		lsh[1][lth[1]] = yy - H;//同上
	}
	nm = n + m;
	for(i = n + 1; i <= nm; i++){//对蓝点的处理基本一样，只是贡献从1变成了-1
		int1 xx = read(),yy = read(),xxx = xx + W;
		lth[0]++;
		l[i] = xx,r[i] = xxx,y[i] = yy,v[i] = -1;
		lsh[0][lth[0]] = xx;
		lth[1]++;
		lsh[1][lth[1]] = yy;
		lth[0]++;
		lsh[0][lth[0]] = xxx;
		lth[1]++;
		lsh[1][lth[1]] = yy + H;
		lth[1]++;
		lsh[1][lth[1]] = yy - H;
	}
	sort(lsh[0] + 1,lsh[0] + lth[0] + 1);
	lth[0] = unique(lsh[0] + 1,lsh[0] + lth[0] + 1) - lsh[0];//离散化横坐标
	sort(lsh[1] + 1,lsh[1] + lth[1] + 1);
	lth[1] = unique(lsh[1] + 1,lsh[1] + lth[1] + 1) - lsh[1];//离散化纵坐标
	for(i = 1; i <= nm; i++){
		l[i] = lower_bound(lsh[0] + 1,lsh[0] + lth[0] + 1,l[i]) - lsh[0];
		r[i] = lower_bound(lsh[0] + 1,lsh[0] + lth[0] + 1,r[i]) - lsh[0];
		y[i] = lower_bound(lsh[1] + 1,lsh[1] + lth[1] + 1,y[i]) - lsh[1];
		aty[y[i]].push_back(i);//将纵坐标为y[i]的点存储起来，方便加点/删点
		siz[y[i]]++;//这里手动记录了一下aty[y[i]].size()
	}
	build(1,1,lth[0]);//建树
	for(int1 L = 1,R = 0; L <= lth[1]; ){//枚举下线离散化后的位置
		int1 limit = lsh[1][L] + H;//确定“上线”的“上限”（（（
		while(lsh[1][R + 1] <= limit && R < lth[1]){
			R++;//移动上线
			for(i = 0; i < siz[R]; i++){//同时加点
				int1 pos = aty[R][i];
				change(1,1,lth[0],l[pos],r[pos],v[pos]);
			}
		}
		if(L <= R){//如果上下线位置合法
			comp(abs(maxn[1]),lsh[0][maxp[1]],lsh[1][L]);//更新答案（注意记得把坐标离散回去）
			comp(abs(minn[1]),lsh[0][minp[1]],lsh[1][L]);			
		}
		for(i = 0; i < siz[L]; i++){//删点
			int1 pos = aty[L][i];
			change(1,1,lth[0],l[pos],r[pos],-v[pos]);
		}
		L++;//移动下线
	}
	pe(ans);
	ps(ansx - W),pe(ansy);//得到的点是右下角的，所以横坐标-W
	return 0;
}
```

两条线只会把每个点各遍历一遍，所以时间复杂度为 $O((n + m)\log (n + m))$。

---

## 作者：hjhAKIOI (赞：2)

## P12699 [KOI 2022 Round 2] 红蓝 题解

[题目链接](https://www.luogu.com.cn/problem/P12699)

发现这道题和[窗口的星星](https://www.luogu.com.cn/problem/P1502)很像，考虑使用扫描线。

对于每个点，设它的坐标是 $(x,y)$，那么可以看作它在 $x$ 开始生效，在 $x+W+1$ 失效。

扫描线的同时，维护一棵线段树。线段树的第 $i$ 个叶子节点表示在此时生效的点中，纵坐标在 $[i,i-h]$ 范围内的点的红蓝数量差（不取绝对值）。那么我们可以维护区间的最大值、最小值，每次更新答案时分别用最大值的绝对值和最小值的绝对值更新答案（易证正确性）。

如何维护呢？我们发现，加入一个点 $(x,y)$，会影响的区间实际上是 $[y,y+h]$。也就是说，只要对区间 $[y,y+h]$ 进行区间加就可以了；删除一个点也是同理。一个红点生效，可以看作区间加一，失效则区间减一；一个蓝点生效，可以看作区间减一，失效则区间加一。这样，我们就可以正确维护这个线段树。

发现还要输出方案，那么在线段树上额外维护最大、最小值的位置即可。

于是套上扫描线即可。~所以其实是扫描线板子~

一些小细节：

1. 值域很大，要离散化。
2. 一共有 $2n+2m$ 条线，数组不要开小了。

至此就完美解决了。以下是代码：

```cpp
#include<iostream>
#include<algorithm>
#include<cmath> 
using namespace std;
const int N=5e5+5;
int n,m,h,w,T,ans[3];
int tmp[N]; 

struct Point{
	int x,y1,y2,c;
	bool operator<(const Point &o)const{
		return x<o.x;
	}
}a[N];

int Val(int x){
	return lower_bound(tmp+1,tmp+T+1,x)-tmp;
}

struct SgmTree{
	int mx,mn,p1,p2,add;
}t[N<<2];

void up(int p){
	if(t[p<<1].mx<t[p<<1|1].mx) t[p].mx=t[p<<1|1].mx,t[p].p1=t[p<<1|1].p1;
	else t[p].mx=t[p<<1].mx,t[p].p1=t[p<<1].p1;
	if(t[p<<1].mn>t[p<<1|1].mn) t[p].mn=t[p<<1|1].mn,t[p].p2=t[p<<1|1].p2;
	else t[p].mn=t[p<<1].mn,t[p].p2=t[p<<1].p2;
}

void build(int p,int l,int r){
	if(l==r){
		t[p].p1=t[p].p2=l;
		return;
	}
	int mid=(l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	up(p);
}

void down(int p){
	if(t[p].add){
		t[p<<1].add+=t[p].add;
		t[p<<1|1].add+=t[p].add;
		t[p<<1].mn+=t[p].add,t[p<<1].mx+=t[p].add;
		t[p<<1|1].mn+=t[p].add,t[p<<1|1].mx+=t[p].add;
		t[p].add=0;
	}
}

void change(int p,int l,int r,int L,int R,int v){
	if(l<=L&&r>=R){
		t[p].add+=v,t[p].mn+=v,t[p].mx+=v;
		return;
	}
	down(p);
	int mid=(L+R)>>1;
	if(l<=mid) change(p<<1,l,r,L,mid,v);
	if(r>mid) change(p<<1|1,l,r,mid+1,R,v);
	up(p);
}

void update(int v,int x,int y){//更新答案
	if(v>ans[0]) ans[0]=v,ans[1]=x,ans[2]=y;
}

int main(){
	cin>>n>>m>>w>>h;
	for(int i=1;i<=n;i++){
		int x,y;
		cin>>x>>y;
		a[2*i-1]={x,y,y+h,1};
		a[2*i]={x+w+1,y,y+h,-1};
		tmp[2*i-1]=y,tmp[2*i]=y+h;
	}
	for(int i=1;i<=m;i++){
		int x,y;
		cin>>x>>y;
		a[2*n+2*i-1]={x,y,y+h,-1};
		a[2*n+2*i]={x+w+1,y,y+h,1};
		tmp[2*n+2*i-1]=y,tmp[2*n+2*i]=y+h;
	}
	sort(tmp+1,tmp+2*n+2*m+1);
	T=unique(tmp+1,tmp+2*n+2*m+1)-tmp-1;//离散化
	sort(a+1,a+2*n+2*m+1);
	build(1,1,T);
	for(int i=1,j;i<=2*n+2*m;i=j+1){//扫描线
		j=i;
		while(a[j+1].x==a[i].x) j++;//把横坐标相同的一起处理
		for(int k=i;k<=j;k++) change(1,Val(a[k].y1),Val(a[k].y2),1,T,a[k].c);
		update(abs(t[1].mn),a[i].x,tmp[t[1].p2]);
		update(abs(t[1].mx),a[i].x,tmp[t[1].p1]);
	}
	cout<<ans[0]<<endl<<ans[1]-w<<' '<<ans[2]-h;
	return 0;
}
```

---

## 作者：Zskioaert1106 (赞：1)

题目传送门：[P12699 [KOI 2022 Round 2] 红蓝](https://www.luogu.com.cn/problem/P12699)

许久前初学扫描线时调不对的题，今日过了写发题解。

### 题目分析

看到数量差值最大，这个信息是套一个绝对值的，因此可以转化为：给红点赋一个正权，给蓝队赋负权，求一个矩形区域内点权和的最大值和最小值。

思考矩形放置在哪里时一个点 $(x,y)$ 可以贡献上。答案是 $(x-W,x,y-H,y)$ 的矩形区域。因此可以将每个点的贡献范围整成矩形，这样我们求的就是所有地方的单点最大/最小值了。

因此可以把每个矩形拆成上下两条边来扫描线。对于红点，下边权为 $1$，上边权为 $-1$，蓝点相反。注意这里上边的纵坐标是 $y+1$，因为在 $y$ 处该点仍能贡献。

然后就是正常的线段树维护区间极值和坐标了。

### 代码实现

扫描线要开二倍空间，红蓝点又各有 $n,m$ 个，所以最终线段树开的是 $2\times 2\times 4=16$ 倍的 $n$ 空间。

:::info[代码]{open}
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
const int N=400005;
int n,m,w,h,x[N],tot,ans,ansx,ansy;
struct line{
	int x1,x2,y;
	short p;
}a[N];
bool cmp(line a,line b){
	return a.y<b.y;
}
struct Segment_tree{
    int L,R;
    int mx,mn;
    int mxx,mnx;// 坐标
    int tag;
}s[N<<2];
void pushup(int u){
	if(s[u<<1].mx>s[u<<1|1].mx)s[u].mx=s[u<<1].mx,s[u].mxx=s[u<<1].mxx;
	else s[u].mx=s[u<<1|1].mx,s[u].mxx=s[u<<1|1].mxx;
	if(s[u<<1].mn<s[u<<1|1].mn)s[u].mn=s[u<<1].mn,s[u].mnx=s[u<<1].mnx;
	else s[u].mn=s[u<<1|1].mn,s[u].mnx=s[u<<1|1].mnx;
}
void build(int u,int l,int r){
    s[u].L=x[l],s[u].R=x[r];
    if(l<r){
        int mid=(l+r)/2;
        build(u*2,l,mid),build(u*2+1,mid+1,r);
        pushup(u);
    }
    else s[u].mxx=s[u].mnx=x[l];
}
void pushdown(int u){
	if(s[u].tag){
		s[u<<1].tag+=s[u].tag,s[u<<1|1].tag+=s[u].tag;
		s[u<<1].mx+=s[u].tag,s[u<<1|1].mx+=s[u].tag;
		s[u<<1].mn+=s[u].tag,s[u<<1|1].mn+=s[u].tag;
		s[u].tag=0;
	}
}
void update(int u,int l,int r,short p){
	if(l<=s[u].L&&s[u].R<=r){
		s[u].tag+=p;
		s[u].mx+=p,s[u].mn+=p;
	}
	else if(l<=s[u].R&&s[u].L<=r){
		pushdown(u);
		update(u<<1,l,r,p),update(u<<1|1,l,r,p);
		pushup(u);
	}
}
int main(){
    cin>>n>>m>>w>>h;
    for(int i=1,x1,x2,y1,y2;i<=n;i++){
    	cin>>x2>>y2;
    	x1=x2-w,y1=y2-h;
    	y2++;
    	x[++tot]=x1;
    	a[tot].x1=x1,a[tot].x2=x2,a[tot].y=y1,a[tot].p=1;
    	x[++tot]=x2;
    	a[tot].x1=x1,a[tot].x2=x2,a[tot].y=y2,a[tot].p=-1;
	}
    for(int i=1,x1,x2,y1,y2;i<=m;i++){
    	cin>>x2>>y2;
    	x1=x2-w,y1=y2-h;
    	y2++;
    	x[++tot]=x1;
    	a[tot].x1=x1,a[tot].x2=x2,a[tot].y=y1,a[tot].p=-1;
    	x[++tot]=x2;
    	a[tot].x1=x1,a[tot].x2=x2,a[tot].y=y2,a[tot].p=1;
	}
	sort(a+1,a+1+tot,cmp);
	sort(x+1,x+1+tot);
	tot=unique(x+1,x+1+tot)-x-1;
	build(1,1,tot);
	for(int i=1;i<=(n+m)*2;i++){
		update(1,a[i].x1,a[i].x2,a[i].p);
		if(a[i].y<a[i+1].y){
			if(abs(s[1].mx)>ans){
				ans=abs(s[1].mx);
				ansx=s[1].mxx,ansy=a[i].y;
			}
			if(abs(s[1].mn)>ans){
				ans=abs(s[1].mn);
				ansx=s[1].mnx,ansy=a[i].y;
			}
		}
	}
	cout<<ans<<'\n'<<ansx<<' '<<ansy;
    return 0;
}
```
:::

[AC 记录](https://www.luogu.com.cn/record/229306943)。

---


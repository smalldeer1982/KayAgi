# [HNOI2015] 菜肴制作

## 题目描述

知名美食家小 A 被邀请至 ATM 大酒店，为其品评菜肴。ATM 酒店为小 A 准备了 $n$ 道菜肴，酒店按照为菜肴预估的质量从高到低给予 $1$ 到 $n$ 的顺序编号，预估质量最高的菜肴编号为 $1$。

由于菜肴之间口味搭配的问题，某些菜肴必须在另一些菜肴之前制作，具体的，一共有 $m$ 条形如 $i$ 号菜肴必须先于 $j$ 号菜肴制作的限制，我们将这样的限制简写为 $(i,j)$。

现在，酒店希望能求出一个最优的菜肴的制作顺序，使得小 A 能尽量先吃到质量高的菜肴：

也就是说，

1. 在满足所有限制的前提下，$1$ 号菜肴尽量优先制作。

2. 在满足所有限制，$1$ 号菜肴尽量优先制作的前提下，$2$ 号菜肴尽量优先制作。

3. 在满足所有限制，$1$ 号和 $2$ 号菜肴尽量优先的前提下，$3$ 号菜肴尽量优先制作。

4. 在满足所有限制，$1$ 号和 $2$ 号和 $3$ 号菜肴尽量优先的前提下，$4$ 号菜肴尽量优先制作。

5. 以此类推。

例 1：共 $4$ 道菜肴，两条限制 $(3,1)$、$(4,1)$，那么制作顺序是 $3,4,1,2$。

例 2：共 $5$ 道菜肴，两条限制 $(5,2)$、$(4,3)$，那么制作顺序是 $1,5,2,4,3$。

例 1 里，首先考虑 $1$，因为有限制 $(3,1)$ 和 $(4,1)$，所以只有制作完 $3$ 和 $4$ 后才能制作 $1$，而根据 3，$3$ 号又应尽量比 $4$ 号优先，所以当前可确定前三道菜的制作顺序是 $3,4,1$；接下来考虑 $2$，确定最终的制作顺序是 $3,4,1,2$。

例 $2$ 里，首先制作 $1$ 是不违背限制的；接下来考虑 $2$ 时有 $(5,2)$ 的限制，所以接下来先制作 $5$ 再制作 $2$；接下来考虑 $3$ 时有 $(4,3)$ 的限制，所以接下来先制作 $4$ 再制作 $3$，从而最终的顺序是 $1,5,2,4,3$。现在你需要求出这个最优的菜肴制作顺序。无解输出 `Impossible!`（首字母大写，其余字母小写）

## 说明/提示

**【样例解释】**

第二组数据同时要求菜肴 $1$ 先于菜肴 $2$ 制作，菜肴 $2$ 先于菜肴 $3$ 制作，菜肴 $3$ 先于菜肴 $1$ 制作，而这是无论如何也不可能满足的，从而导致无解。

**【数据范围】**

$100\%$ 的数据满足 $n,m\le 10^5$，$1\le t\le 3$。

$m$ 条限制中可能存在完全相同的限制。

## 样例 #1

### 输入

```
3
5 4
5 4
5 3
4 2
3 2
3 3
1 2
2 3
3 1
5 2
5 2
4 3```

### 输出

```
1 5 3 4 2 
Impossible! 
1 5 2 4 3```

# 题解

## 作者：xyz32768 (赞：97)

看到题目，可以想到拓扑排序。但是如果要求字典序最小的排列，那就错了。

可以举出反例：$4$种菜肴，限制为$<2,4><3,1>$，

那么字典序最小的是$2,3,1,4$，但题目要求的最优解是$3,1,2,4$。

继续考虑，可以发现，如果最后一个数字在合法范围内尽可能大，那么这样是绝对有利的。

因为如果设最后一个数字是$x$，那么除了$x$之外的所有数都不会被放到最后一个位置。

而这样就可以让前面所有小于$x$的数都尽量靠前（大于$x$的数，虽然也能靠前，但由于$x$的位置已经固定，因此没有用），达到题目的目标。

因此，最优解就是符合条件的排列中，**反序列**的字典序**最大**的排列。

所以，在反图上跑拓扑排序，求最大字典序。在实现上，由于需要多次找出队列中的最大值，因此用堆代替队列。

代码：

```cpp
#include <cmath>
#include <queue>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
const int N = 3e5 + 5;
priority_queue<int> Hea;
int n, m, ecnt, nxt[N], adj[N], go[N], cnt[N], ans[N];
void add_edge(int u, int v) {
    nxt[++ecnt] = adj[u]; adj[u] = ecnt; go[ecnt] = v; cnt[v]++;
}
void work() {
    int i, x, y, tot = 0; ecnt = 0; memset(adj, 0, sizeof(adj));
    memset(cnt, 0, sizeof(cnt)); n = read(); m = read(); bool flag = 0;
    for (i = 1; i <= m; i++) {
        x = read(); y = read();
        add_edge(y, x); if (x == y) flag = 1;
    }
    if (flag) return (void) puts("Impossible!");
    for (i = 1; i <= n; i++) if (!cnt[i]) Hea.push(i);
    while (!Hea.empty()) {
        int u = Hea.top(); Hea.pop(); ans[++tot] = u;
        for (int e = adj[u], v; e; e = nxt[e])
            if (!(--cnt[v = go[e]])) Hea.push(v);
    }
    if (tot < n) return (void) puts("Impossible!");
    for (i = n; i; i--) printf("%d ", ans[i]);
    printf("\n");
}
int main() {
    int T = read();
    while (T--) work();
    return 0;
}
```

---

## 作者：newbiechd (赞：64)

# [HNOI2015]菜肴制作贪心的证明

[广告](https://www.cnblogs.com/cj-chd/p/11780098.html)

先吐槽一句为什么网上都没人证这个东西，我觉得一点也不显然啊。。。

判环不用说了，现在处理一个DAG。考虑按题意模拟：建反图（边从后选的点连向先选的点），每次找全局最小的点，并把候选集合缩小为这个点在图上的所有后继，再在当前候选集合中选择最小的点并把候选集合更新为它的后继，不断重复此过程直至候选集合只有一个点，就把这个点从图上删除并放到答案序列的末尾。这种做法最后得到的答案序列的正确性是显然的。

观察一下数据范围，发现直接模拟不太能做。考虑每次选了全局最小点，这个点和它的后继在答案序列上一定会占据一段前缀，并且这个点一定在这段前缀的最后一个位置，因此把这些点在图上删掉并不会影响其它点的决策，而且处理这个点的后继就是一个子问题。我们每次都取当前的全局最小点并把它和它的后继在图上删除，最后删掉的点一定是当前没有入度的最大的点，这个点一定会被放在答案序列的末尾，如果把这个点删除，剩下的所有点又成为了一个子问题。这样我们就得到了正确的决策：每次取当前没有入度的最大的点删除并放到答案序列的末尾。实际上就是到处说的拿大根堆拓扑排序的拓扑反序。



---

## 作者：ppip (赞：46)

> 最优解就是符合条件的排列中，反序列的字典序最大的排列。

这是最高赞题解的结论。然而，没人证明这玩意儿。

（本文仅提供证明。如何求字典序最大的请左转）。

定义两个拓扑序中更优的一个为“最小序”更小的拓扑序。

求证：一个 DAG 的拓扑序中“最小序”最小的的一个拓扑序，是反向字典序最大的一个。

证明：

首先，当 $|V|=1$ 时结论显然。

其次，假设结论对于 $|V|<n$ 均成立。设图 $G=(V,E)$ 中最小点编号为 $x$，其中 $|V|=n$，则整个点集分为两部分：

- $S=\{z\ |$ 存在一条路径 $z\to x\}$
- $T=V-S$

特别地，有 $x\in S$。

---

Lemma 1：令 $m:=|S|$。则最小序最小的拓扑序 $a$ 一定满足 $\{a_x|1\leq x\leq m\} = S$ 且 $a_m=x$。

证明：由于 $x$ 在拓扑序上的位置越小，最小序就越小，所以 $x$ 尽可能靠前更优。由拓扑序的定义，$S - \{x\}$ 中的所有点在拓扑序上一定排在 $x$ 之前。

所以 $a_p=x$ 是 $p\geq m$ 的充分条件。于是最小的最小序满足 $p=m$。

---

现将整个图可以分成三个子图，其点集分别为 $S-\{x\}$、$\{x\}$ 和 $T$。

由于 $|S| + |T| = n$，所以 $|S-\{x\}|,|T| < n$，由假设得其结论成立。

因为 $x$ 是编号最小的，将 $x$ 向后移不能获得更大的反向字典序。而 $S-\{x\},T$ 的结论已证。于是对于图 $G$ 结论成立。

所以对于任意的 DAG，由数学归纳法得结论均成立。

证毕。

---

## 作者：2024sdhkdj (赞：29)

[题目传送门](https://www.luogu.com.cn/problem/P3243)

这题一开始苦苦调错一上午，样例都没过，交上去只有[十分](https://www.luogu.com.cn/paste/u221n1i5)，~~于是看了下题解以后~~知道了错因。可能有许多人和我错在同样的地方，以下为我自己的见解，仅供参考。
## 题意描述：

这题的题意很好懂，就是给定 $n$ 菜肴和 $m$ 个限制条件，对于每个限制条件 $x$ 和  $y$，表示 $x$ 号菜肴必须先于 $y$ 号菜肴。让你求出在满足最小号的菜肴尽量靠前的前提下次小号的菜肴也尽量靠前、次小号的菜肴尽量靠前的前提下次次小号的菜肴也尽量靠前。（注意**不是字典序**！！！我就是这里理解有误才至错的！！！）以此类推，最优的菜肴制作顺序。如若无解，则输出 `Impossible!`。

## 算法分析：

按照我以前的思路，按照先选的菜肴 $\Rightarrow$ 后选的菜肴的方式建边，然后直接在上面拓扑排序，最后在判环输出即可。可这样是行不通的，不信？我们看两个例子：

第一个例子：

假设存在一组数据为：
~~~
1
6 4
5 3
3 1
6 4
4 2
~~~
根据题意，可以得出如下关系：

$5 \Rightarrow 3 \Rightarrow 1$，

$6 \Rightarrow 4 \Rightarrow 2$。

（我们定义一串关系为一条**链**，$5,6$ 等位于一条链首位的为**链头**，$1,2$ 等位于一条链末尾的为**链尾**，下同。）

按照我们原来的思路，拓扑排序的结果为：$531642$，乍一看确实是正确的，但还有第二组数据：
~~~
1
6 4
5 4
4 2
6 3
3 1
~~~
根据题意，可以得出如下关系：

$5 \Rightarrow 4 \Rightarrow 2$，

$6 \Rightarrow 3 \Rightarrow 1$。

可以看到，这组数据与原来的不同就是 $6$ 与 $5$ 的位置调换。如果还是按照原来的思路，则拓扑排序的结果为：$542631$，然而符合题目要求的正确答案却是 $631542$。于是可以发现，这种思路的错误之处在于我们是按照**链头**的顺序考虑的（即上边第二个样例中的 $5 < 6$ 所以误判优先删除 $5$ 号菜肴开始的关系链），而题意是根据**链尾**的顺序实现的，因此需要每一次优先考虑删除**链尾**最小的**链**。

好了，问题找到了，那么该如何实现呢？

暴力找链尾肯定是行不通的，于是我们可以反向建边，然后根据链头（原来的链尾）从大到小按次删点删边，存入 $ans$ 数组里，然后倒着输出。至于为什么倒着输出，是因为我们是反向建边，且是从大到小的顺序；而输出是正向的，从小到大的顺序。这里还有一个问题，如何排序呢？

**~~[CJT](https://www.luogu.com.cn/user/926432) 直呼优先队列大法好！！！~~**

没错，这里推荐一种很实用的 STL：优先队列。它可以自定义优先级，在入队时顺便完成排序，非常方便。想了解具体可以看这篇[博客](https://blog.csdn.net/weixin_36888577/article/details/79937886?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169250321716800185867974%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169250321716800185867974&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-79937886-null-null.142^v93^chatsearchT3_1&utm_term=%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97&spm=1018.2226.3001.4187)。

## AC 代码
~~~
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int t,n,m,x,y,cnt;
int in[N],ans[N];
vector<int> vec[N];
priority_queue<int,vector<int>,less<int> >que;//也可以写成默认状态priority_queue<int>que;
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
	cin>>t;
	while(t--){
		cin>>n>>m;
		cnt=0;
		for(int i=1;i<=n;i++)
			ans[i]=in[i]=0;
		for(int i=1;i<=n;i++)
			vec[i].clear();//多测不清空，十年OI一场空
		for(int i=1;i<=m;i++){
			cin>>x>>y;
			in[x]++;
			vec[y].push_back(x);//反向建边
		}
		for(int i=1;i<=n;i++)
			if(!in[i])
				que.push(i);
		while(!que.empty()){
			int u=que.top();//优先队列打乱了原序，所以只能用top，而不能用front！！！ 
			que.pop();
			for(int i=0;i<vec[u].size();i++){
				int x=vec[u][i];
				in[x]--;//解放连边
				if(!in[x])
					que.push(x);
			}
			ans[++cnt]=u;//记录答案
		}
		if(cnt<n)
			cout<<"Impossible!";
		else
			for(int i=cnt;i>=1;i--)//倒着输出，原因看“算法分析”
				cout<<ans[i]<<" ";
		cout<<endl;
	}
	return 0;
}
~~~
[AC 记录](https://www.luogu.com.cn/record/121898870)

[我的 BLOG](https://www.luogu.com.cn/blog/hsb0507/)

---

## 作者：§durance®旋律 (赞：19)

# P3243 [HNOI2015] 菜肴制作 题解
本人码风自认为还是很好懂的。。初学拓扑的小伙伴们可以参考我的代码~~自己~~过 AC 哦。  
这里同样也有一些我做题时遇到的坑点。
   
 ~~2021.11.15    听说发题解能让自己 CSP rp++~~
 
------------
# 进入正题
相信葛伟小伙伴们都能看出来，这是一道练手**拓扑排序**的经典好题，练习模板的同时，还需有一丢丢思维上的拓展。   
~~由紫直接降级一挡，可见本题只要注意到了丢分点是完全可以轻松水过    da！~~   
由于之前的题解已经较详细地讲了拓扑排序的原理和代码实现，在这里我就不多跟大家赘述了。现在我们破题，说一下几点代码实现当中的注意事项。_以下三项是层层递进的，所以请按照顺序阅读。祝阅读愉快！_ 
 
------------
## 1. 关于维护
解决这道题，传统的栈或者是队列肯定是不行的（这样只能是先找到的入度为 0 的点进容器，并不能保证顺序）。所以优先队列就十分有必要了。我一开始想的是建小根堆维护，不说了，很惨，只有 10 分。苦苦思索终于想到：

**小根堆，只能维护同！一！次！删边之后，多个入度为 0 的点的字典序。而不能从全局考虑将小的排前面。**     
样例第三组数据就很好地排掉小根堆的做法。
![](https://cdn.luogu.com.cn/upload/image_hosting/4m4mp18h.png)   ~~（手写很丑，自行忽略）~~   
排掉点 1 之后，剩下入度为 0 的点是 4 号和 5 号。小根堆维护过后肯定是 4 号点先进堆，而不是 5 号。与题意相悖。   
因此，需要再认真读题。  

------------

1. 在满足所有限制的前提下，1 号菜肴尽量优先制作。  
2. 在满足所有限制，1 号菜肴尽量优先制作的前提下，2 号菜肴尽量优先制作。    
......     
可以看出，此题不是从入度为 0 的点开始扫，而是按字典序，对于每一个点考察她的入度，逆！向！操作。若有，则再处理其入度...

------------

## 2. 关于建图
上文说了，此题不应先从入度为 0 的点考虑。需要进行反推，找到入度。所以，正向建图直接帕斯。同理维护拓扑数组后正向输出也不可取。

所以，既然题目是从逆向找入度，我们为什么不能也反其道而行之，从正向找出度呢？反向建图的必要性也就体现出来了。  

而这时，关于第一个坑点，我们也反其道而行之，用大根堆维护。这样又能保证每次删边之后大的往前放，又有效地解决了逆向思维的问题，岂不美哉？  

同理，维护拓扑顺序的数组，一定是在题目约束下最大的最靠前。这时我们再来一手逆序输出，就能使最小的最靠前啦。  

~~其实神犇们已经讨论过建反图的思路，我在这里就是更详细地介绍一下，再帮助大家理解理解。没有抄袭之嫌哈~~   

------------
## 3. 关于判环
本蒟蒻一开始打了快 30 行的 SPFA 判环。。。快打完了才发现根本没必要单独操作。。   
不过就单纯练习而言，多打一遍 SPFA 也不为过。毕竟，巩固知识嘛。  
其实，若是所给点能全部装进拓扑数组，就相当于所有点都是合法的。删边之后入度都会为 0。这样自然就不是环。所以只要数组元素正好为 n，就无环。反之则有。

------------
## 4. 关于初始化
先吐槽初始化真的要坑死我了（疯狂跳 WA)。

**多组数据请务必确定与之相关的每一个变量，每一个数组都要初始化！真的很重要！**
------------
# 代码
 _双手奉上(代码比较简洁，适合初学者理解，码风问题不喜勿喷)——_ 
 ```c
#include<iostream>
#include<cstring>
#include<queue>
#include<cstdio>
using namespace std;
int t,n,m,cnt,cmt;
int indegree[500005],head[500005],topo[500005];//topo[]用来存拓扑序，indegree[]即为入度
priority_queue<int> q;//大根堆
struct edge
{
	int to,next;
}edge[500005];//最喜欢的链式前向星

void add(int u,int v)
{
	edge[++cnt].to=v;
	edge[cnt].next=head[u];
	head[u]=cnt;
	indegree[v]++;
}

bool judge()//拓扑+判环
{
	for(int i=1;i<=n;i++) 
	{
		if(indegree[i]==0) q.push(i); 
	}
	while(!q.empty())
	{
		int top=q.top();
		q.pop();
		topo[++cmt]=top;
		for(int i=head[top];i;i=edge[i].next)
		{
		   int end=edge[i].to;
		   if(--indegree[end]==0) q.push(end); 	
		}	
	}
	if(cmt==n) return true;
	else return false;
}

int main()
{
	cin>>t;
	while(t--)
	{
		cin>>n>>m;
		cnt=0,cmt=0;
		memset(head,-1,sizeof head);
		memset(topo,0,sizeof topo);//温馨提示：0x7fffffff和1e8都不能用memset
		memset(indegree,0,sizeof indegree);
		for(int i=1;i<=m;i++)
		{
			int x,y;
			cin>>x>>y;
			add(y,x);//反向建边
		}
		if(judge()) 
		{
			for(int j=n;j>=1;j--) cout<<topo[j]<<" ";//逆序输出
			cout<<endl;
		}
		else cout<<"Impossible!"<<endl;
	}
	return 0;//完结撒花
}

---

## 作者：Luckies (赞：9)

## 前言

今天考试考到这道题，挂惨了。

## 题意

有 $n$ 道菜肴，编号为 $1 \sim n$。有 $m$ 个条件，形如 $(i, j)$，表示菜肴 $i$ 必须在菜肴 $j$ 之前制作。需求出一个菜肴的制作顺序，满足：

1. 在满足所有限制的前提下，$1$ 号菜肴尽量优先制作。

2. 在满足所有限制，$1$ 号菜肴尽量优先制作的前提下，$2$ 号菜肴尽量优先制作。

3. $\dots\dots$

4. 以此类推。

如果无解，输出 ```Impossible!```。

### 形式化

给定 $n$ 个点，$m$ 条边的有向图，需求出其拓扑序，满足在拓扑序合法的前提下，点 $1$ 优先且点 $i(i \in |V|, i \ne 1) $ 在点 $i - 1$ 优先的前提下优先。无解输出 ```Impossible!```。

## 解法

首先给出一个错解，这东西是我考场胡的，但是可能对后面有帮助。

对于每一个点 $x$，求出它往后的所有路径上经过的点的最小权值 $mi_x$（包括 $x$）。然后使用堆进行拓扑排序，以 $mi_x$ 为第一关键字，$x$ 为第二关键字，就像这样:

![](https://cdn.luogu.com.cn/upload/image_hosting/zhwrxz19.png)

它的正确拓扑序为：$1, 3, 4, 5, 2$。

但是，它是错误的，不管是正确性还是时间。

我们来看这个例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/d9wkd2ta.png)

在这个图中，正确的拓扑序为 $6, 5, 2, 4, 3, 1$，可这种方法跑出来的答案是 $6, 4, 3, 5, 2, 1$。可以发现，$5$ 和 $4$ 这两个点的 $mi$ 是相等的，并且有公共的终点。这个时候，只要把两条路径中间的点调一下，这样贪心就是错误的。

关于时间，我采用的是 DFS，对于每个入度为 $0$ 的节点，跑一遍 DFS，但是这样的最坏时间复杂度为 $\Theta(\frac{n^2}{4})$，直接被卡飞。

我们可以对这个错解修改一下。

对于每个点 $x$，它的子节点为 $y_1, y_2, \dots, y_k$，在拓扑序中选择的先后顺序是这样的：将 $y_1, y_2, \dots, y_k$ 往后的路径经过的点排序，然后按这些序列的字典序大小来选择。

按照刚刚的错解，错误的原因是多条路径上的最小值可能相等。那就一个一个从小到大比较啊，这样就是对的了。

这样做的朴素时间复杂度为 $\Theta(n^2)$，但是可以使用 ```bitset``` 优化一下，可以将时间复杂度降为 $\Theta(\frac{n^2}{w})$，算了一下单次大概 $3 \cdot 10^7$ 的样子，数据组数小于等于 $3$，那么就是 $9 \cdot 10^7$，稍微卡一卡即可通过。

接下来讲时间复杂度正确的算法。

可以发现，我们刚才的分析都是正着分析的，但是这样是不好维护的，因为字典序小不一定是最优解。

那么我们倒着想。小的要在前面，那么大的就要在后面。在拓扑序合法的情况下，尽量把大的放在后面。那么这样就可以把小的数都尽量靠前。

那么，只需要在反图上跑字典序最大的拓扑序，然后反转一下即为答案。

字典序最大的拓扑序可以使用大根堆。

### AC Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e5 + 5;
int t, n, m, in[N], IN[N], mi[N];
vector<int> e[N], ans;
void init()
{
    ans.clear();
    for(int i = 1; i <= n; i++)
        e[i].clear();
    memset(in, 0, sizeof(in));
    memset(IN, 0, sizeof(IN));
    // memset(mi, 0x3f, sizeof(mi));
    return;
}
void topo_sort()
{
    priority_queue<int> q;
    for(int i = 1; i <= n; i++)
        if(!in[i])
            q.push(i);
    int cnt = 0;
    while(!q.empty())
    {
        int x = q.top();
        q.pop();
        cnt++;
        ans.push_back(x);
        for(auto y : e[x])
            if(!--in[y])
                q.push(y);
    }
    if(cnt != n)
    {
        cout << "Impossible!\n";
        return;
    }
    reverse(ans.begin(), ans.end());
    for(auto i : ans)
        cout << i << " ";
    cout << "\n";
    return;
}
void solve()
{
    cin >> n >> m;
    init();
    for(int i = 1; i <= m; i++)
    {
        int x, y;
        cin >> x >> y;
        e[y].push_back(x);
        in[x]++;
    }
    // for(int i = 1; i <= n; i++)
    //     cout << mi[i] << " ";
    // cout << "\n";
    // for(int i = 1; i <= n; i++)
    //     for(int j = i + 1; j <= n; j++)
    //     if(!vis[i][j])
    //     {
    //         vis[i][j] = vis[j][i] = true;
    //         e[i].push_back(j);
    //         in[j]++;
    //     }
    topo_sort();
    return;
}
signed main()
{
    // freopen("dishes.in", "r", stdin);
    // freopen("dishes.out", "w", stdout);
    cin >> t;
    while(t--)
        solve();
    return 0;
}
```

---

## 作者：M_CI (赞：6)

### P0：序

考试时脑抽写拓扑写了一大堆[破烂](https://www.luogu.com.cn/paste/k0310mwg)，只对了样例（悲）。

### P1：思路

#### P1-1：考场思路

考试时一眼拓扑，但跑字典序最小的拓扑后发现错了，就改为了上面的破烂。

首先会想到要把编号小的尽量放在前面，编号大的尽量放后面，然后就求出了最小字典序的拓扑序。但这样就会 AC 吗？并不是。样例即可卡掉：

```
3
5 4
5 4
5 3
4 2
3 2
3 3
1 2
2 3
3 1
5 2
5 2
4 3
```

输出

```
1 5 3 4 2
Impossible!
1 4 3 5 2
```

答案

```
1 5 3 4 2 
Impossible! 
1 5 2 4 3
```

显然错误。

#### P1-2：考后重构

分析样例，发现越大的数放到越后面收益是越大的，也就是说，按这种规则排的拓扑序最优。

正解就是如上所述，但是建图要正图改反图，小根堆改大根堆来维护，还要倒序输出求出的字典序最大的拓扑序，即可 AC。

### P2：代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int t,n,m,tot,in[100010],ans[100010];
vector<int> g[100010];

int main () {
	cin>> t;
	while (t--) {
		cin>> n>> m;
		tot=0;
		memset (in,0,sizeof (in));
		memset (ans,0,sizeof (ans));
		for (int i=1;i<=n;i++)
			g[i].clear ();
		for (int i=1;i<=m;i++) {
			int u,v;
			cin>> u>> v;
			g[v].push_back (u);
			in[u]++;
		}
		priority_queue<int> q;
		for (int i=1;i<=n;i++)
			if (!in[i])
				q.push (i);
		while (!q.empty ()) {
			int u=q.top ();
			q.pop ();
			ans[++tot]=u;
			for (int v: g[u])
				if (!(--in[v]))
					q.push (v);
		}
		if (tot!=n) puts ("Impossible!");
		else {
			for (int i=tot;i>=1;i--)
				cout<< ans[i]<< " ";
			puts ("");
		}
	}
	return 0;
}
```

完结撒花！

---

## 作者：AKPC (赞：6)

### 思路
CSPS 模拟考的题目。

考试的时候首先想到了拓扑，这点很显然，然后一开始以为是字典序最小，用了个优先队列维护原先队列顺序，优先节点编号较小的点跑拓扑。

但是到测样例的时候才发现不是字典序排的，导致重构了代码，所以各位做题还是要先确认你是否完全读懂题目了。

仔细读题之后，可以发现，如果最后一个数字在合法范围内尽可能大，那么这样是绝对有利的，越大的数字放在后面会更优。

那是不是在遇到分叉的时候，选择走到每个分支后能到达的节点最小的那个分支呢？不是的，比如 $(4\to2)(4\to3)(2\to1)(3\to1)$ 这种情况，并不是考虑后面的 $1$。

所以说在正图范围内，并不好找到一个具有正确性的，时间复杂度也正确的（毕竟可以暴力）一种算法，那就考虑反图，也就是建反边。

建反图之后显然先考虑跑反图的拓扑。然后你会惊奇的发现，反图拓扑的字典序最大，就是正确答案序列的逆序。所以把反图拓扑序的逆序输出即可。

AC 代码的话就是将我最开始写在最前面的思路，正图改成反图，优先队列从小到大改成从大到小（字典序最小改成字典序最大），正序输出改成逆序输出，然后就过了。
### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
inline int read(){
	int x=0;bool f=1;register char c=getchar();
	while(c<48||c>57){if(c=='-') f=0;c=getchar();}
	while(c>=48&&c<=57){x=x*10+(c^48);c=getchar();}
	return f?x:-x;
}
int T,n,m,t[100005],ans[100005],tip;
vector<int>e[100005];
priority_queue<int,vector<int>,less<int> >que;
signed main(){
	T=read();
	while (T--){
		for (int i=1;i<=n;i++){
			while (e[i].size()!=0) e[i].pop_back();
			t[i]=0;
		}
		while (!que.empty()) que.pop();
		n=read(),m=read(),tip=0;
		for (int i=1;i<=m;i++){
			int y=read(),x=read();
			e[x].push_back(y),t[y]++;
		}
		for (int i=1;i<=n;i++) if (t[i]==0) que.push(i),t[i]=-1;
		while (!que.empty()){
			const int ci=que.top();
			que.pop(),ans[++tip]=ci;
			for (int i=0;i<e[ci].size();i++) if (--t[e[ci][i]]==0) que.push(e[ci][i]);
		}
		if (tip!=n) puts("Impossible!");
		else{
			for (int i=tip;i>=1;i--) cout<<ans[i]<<' ';
			cout<<'\n';
		}
	}
	return 0;
}

```

---

## 作者：NBest (赞：2)

这道题难点就在如何贪心，这里要我们让最小的尽可能优先做而不是字典序最小，那我们让大的尽可能后做，是不是就可以把最小的尽可能优先做呢？而这样相当于是反过来的序列字典序最大，所以我们跑个反图最大字典序拓扑即可，即建反图以后用优先队列维护最大点。
## $Code$
```cpp
const int N=1e5+5;
int inn[N],ans[N],tot;
vector<int>f[N];
priority_queue<int>Q;
int main(){
    for(int T=read();T--;tot=0){
        int n=read(),m=read();
        for(int i=1;i<=n;i++)f[i].clear(),inn[i]=0;
        for(int i=1;i<=m;i++){
            int u=read(),v=read();
            f[v].push_back(u),inn[u]++;
        }
        for(int i=1;i<=n;i++)if(!inn[i])Q.push(i);
        while(!Q.empty()){
            int x=Q.top();Q.pop();
            ans[++tot]=x;
            for(int y:f[x])
                if(!--inn[y])Q.push(y);
        }
        if(tot==n)for(int i=n;i;--i)printf("%d ",ans[i]);
        else printf("Impossible!");
        puts("");
    }
    return 0;
}
```

---

## 作者：him的自我修养 (赞：1)

# [题目传送门](https://www.luogu.com.cn/problem/P3243)

# 题意
题意很明确，给出 $n$ 道菜品，还有 $m$ 个限制条件 $(u,v)$ 表示 $u$ 号菜品要在 $v$ 前制作。$1$ 号菜品的期待值最高，$n$ 最低，问怎么做菜，才能让期待值最高的菜品优先上来。

# 思路
不是字典序！

不是字典序！

不是字典序！

重要的事情说三遍，比如我们举出例子
```
6 4
5 4
4 2
6 3
3 1
```
直接拓扑排序的答案是 $542631$，而题目要求的答案是 $631542$。这组数据分成了两条链。
```
5->4->2
6->3->1
```
如果按照字典序，我们会先做这条链。```5->4->2``` 
但实际上要选择 ```6->3->1``` 这条链。我们发现了问题，我们是按照链头最小做菜的，但是题目要求我们按照链尾最小做菜。所以我们考虑反向建图，这样就可以解决链头链尾的问题啦。

接下来考虑用一种可以维护顺序的队列，所以就想到了优先队列啦！

# code
```
#include <bits/stdc++.h>
using namespace std;
int n,m,q;
int ans[100010];
vector <int> g[100010];
int cnt[100010];
void solve(){
	cin >>n>>m;
	for(int i=1;i<=n;i++){
		ans[i]=cnt[i]=0;
		g[i].clear();
	}
	for(int i=1;i<=m;i++){
		int x,y;
		cin >>x>>y;
		cnt[x]++;
		g[y].push_back(x);
	}
	priority_queue<int> q;
	for(int i=1;i<=n;i++){
		if(!cnt[i]){
			q.push(i);
		}
	}
	int tail=0;
	while(!q.empty()){
		int x=q.top();
		q.pop();
		for(int i=0;i<g[x].size();i++){
			cnt[g[x][i]]--;
			if(!cnt[g[x][i]]){
				q.push(g[x][i]);
			}
		}
		ans[++tail]=x;
	}
	if(tail!=n){
		cout <<"Impossible!\n";
		return ;
	}
	for(int i=n;i>=1;i--){
		cout <<ans[i]<<" ";
	}
	cout <<endl;
}
int main(){
	cin >>q;
	while(q--){
		solve();
	}
	return 0;
}
```

---

## 作者：_H17_ (赞：1)

## 题目分析

读题的时候如果看见类似 $x$ 号菜肴必须先于 $y$ 号菜肴制作类似的限制时（类似表示 $x,y$ 有先后、连接关系），就要想到拓补排序。

本题目出现问题判掉就输出 `Impossible` 否则输出答案。

示例代码（仅拓补，B3644）：

## Topo Sort

找所有入度是 $0$ 的点入队，把连着这个点的所有边遍历，并将其的入度减去 $1$ 然后重新判入度，是 $0$ 入队，这样依次排序。

注意：如果有环会出现问题，需要判断。

```cpp
#include<bits/stdc++.h>
#define N 111
template<typename T> inline void read(T &x) {
	x = 0; char c = getchar(); bool flag = false;
	while (!isdigit(c)) { if (c == '-') flag = true; c = getchar(); }
	while (isdigit(c)) x = x * 10 + (c ^ 48), c = getchar();
	if (flag)	x = -x;
}
using namespace std;
int n;
vector<int> ve[N];
int ind[N];
int que[N];//本人喜欢STL队列
void topo() {
	int front = 0, rear = 0;
	for (int i = 1; i <= n; ++i) if (!ind[i]) que[++rear] = i;//入队
	while (front < rear) {
		int cur = que[++front];
		for (unsigned i = 0; i < ve[cur].size(); ++i) {//遍历边
			int to = ve[cur][i];
			--ind[to];//入度-1
			if (!ind[to]) que[++rear] = to;//重新判断&入队
		}
	}
	for (int i = 1; i <= n; ++i) printf("%d ", que[i]);
	puts("");
}
int main() {
	read(n);
	for (int i = 1; i <= n; ++i) {
		int to; read(to);
		while (to) ve[i].push_back(to), ind[to]++, read(to);//vector存图
	}
	topo();
	return 0;
}
```

感谢 [jiazhaopeng](/user/221897) 提供代码。

## 代码实现（本题，亲自写）

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3e5+1;
priority_queue<int>q;
int n,m,rd[N],go[N],ans[N];
vector<int>edge[N];//vector存图
void Main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        edge[i].clear();
    bool f=0;
    int tot=0;
    memset(rd,0,sizeof(rd));//初始化
    for(int i=1,x,y;i<=m;i++){
        cin>>x>>y;
        edge[y].push_back(x);//注意反过来
        rd[x]++;
        if(x==y)
            f=1;//自环
    }
    if(f){
        cout<<"Impossible!\n";
        return;
    }
    for(int i=1;i<=n;i++)
        if(!rd[i])
            q.push(i);//初始入队
    while(!q.empty()){
        int t=q.top();
        q.pop();
        ans[++tot]=t;//因为是STL的需要新开ans维护
        for(auto p:edge[t])
            if(!(--rd[p]))
                q.push(p);
    }//更新队列
    if(tot<n){
        cout<<"Impossible!\n";
        return;
    }//有环
    for(int i=n;i>=1;i--)
        cout<<ans[i]<<" \n"[i==1];//注意倒着
    return;
}
int main() {
    int _;
    for(cin>>_;_;_--)
        Main();//多组数据
    return 0;
}
```

---

## 作者：NFGase (赞：0)

本题是我的第一道蓝题，故我认为这道题稍难。

在本题解中，会列出一些坑点供大家参考。

这道题由优先制作这一关键词可知是一道拓扑排序的题，于是我想用邻接矩阵，但是我交之后错了，那是因为普通的数组会爆，但我不喜欢写链式前向星，故使用了`vector`的二维数组。

但是这道题比较特殊，由教练提醒，这道题需要跑反图，这是比较坑的一点。

还有，要注意需要得到一个队列的最大值，那么普通的标准库实现的队列是不行的，因为不能直接访问任意元素，再就是自己实现的，但是遍历有点慢，其他的数据结构又太复杂，所以我们只能使用优先队列，又称之为堆。

代码可能过长，就放在[云剪贴板](https://www.luogu.com.cn/paste/arxlyofs)内。

[记录](https://www.luogu.com.cn/record/135123335)

---

## 作者：idgg007 (赞：0)

### 思路

翻译翻译题面，相当与是对一个有向图求拓扑序，并且要使得编号最小的尽量提前，在该条件满足情况下，使得次小也尽量提前。这很明显不是一个求最小拓扑序的问题。我们可以构造一个特殊数据卡掉这种思路。

```json
5 3
4 2
3 1
5 1
```

对应图：

![](https://cdn.luogu.com.cn/upload/image_hosting/nijwv701.png)

我们可以很显然的看到，当进行拓扑排序最小拓扑序时会得出 `3 4 2 5 1 ` 这样的结果，但是这个显然不对，要想要使得 $1$ 提前其结果应该是 `3 5 1 4 2` 。要使得 $1$ 先出来，必须要让 $3$ 和 $5$ 尽量早出（尽量提前），此时，对于每个在拓扑排序的队列里的点而言，排序就变得及其困难，但是如果将顺序反过来，在反图上跑拓扑排序，事情就变成了尽可能让 $1$ 号点最后出队。也就是说当队列只剩下 $1$ 时，$1$ 就已经被尽可能的提前了。因此只需要反向建边，然后再对反图跑一遍拓扑排序最大拓扑序即可。（queue 用 private_queue 即可）

对于存在环的情况，最后答案的长度不会等于 $n$ ，输出 `Impossible!` 即可

### 代码：

```c++
#include <iostream>
#include <vector>
#include <queue>
#include <list>
using namespace std;
struct Edge
{
    int to;
    Edge *nextEdge;
};
int T, N, M;
list<Edge> edges;
priority_queue<int> que;
vector<Edge *> head;
vector<int> DU;
vector<int> Ans;
void AddEdge(const int &from, const int &to)
{
    edges.push_back({to, head[from]});
    head[from] = &edges.back();
}
void topology()
{
    while (!que.empty())
    {
        int top = que.top();
        que.pop();
        Ans.push_back(top);
        for (Edge *e = head[top]; e; e = e->nextEdge)
        {
            DU[e->to]--;
            if (!DU[e->to])
            {
                que.push(e->to);
            }
        }
    }
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin >> T;
    while (T)
    {
        T--;
        cin >> N >> M;
        head.assign(N + 1, NULL);
        edges.clear();
        Ans.clear();
        DU.assign(N + 1, 0);
        for (int i = 0, a, b; i < M; i++)
        {
            cin >> a >> b;
            AddEdge(b, a);
            DU[a]++;
        }
        for (int i = 1; i <= N; i++)
        {
            if (DU[i] == 0)
            {
                que.push(i);
            }
        }
        topology();
        if (Ans.size()!=N)
        {
            cout << "Impossible!\n";
        }
        else
        {
            for (int i = Ans.size() - 1; i >= 0; i--)
            {
                cout << Ans[i] << " ";
            }
            cout << endl;
        }
    }
    return 0;
}
```



---


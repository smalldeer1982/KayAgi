# [CSP-S2020] 函数调用

## 题目描述

函数是各种编程语言中一项重要的概念，借助函数，我们总可以将复杂的任务分解成一个个相对简单的子任务，直到细化为十分简单的基础操作，从而使代码的组织更加严密、更加有条理。然而，过多的函数调用也会导致额外的开销，影响程序的运行效率。

某数据库应用程序提供了若干函数用以维护数据。已知这些函数的功能可分为三类：

1. 将数据中的指定元素加上一个值；
2. 将数据中的每一个元素乘以一个相同值；
3. **依次**执行若干次函数调用，保证不会出现递归（即不会直接或间接地调用本身）。

在使用该数据库应用时，用户可一次性输入要调用的函数序列（一个函数可能被调用多次），在**依次**执行完序列中的函数后，系统中的数据被加以更新。某一天，小 A 在应用该数据库程序处理数据时遇到了困难：由于频繁而低效的函数调用，系统在执行操作时进入了无响应的状态，他只好强制结束了数据库程序。为了计算出正确数据，小 A 查阅了软件的文档，了解到每个函数的具体功能信息，现在他想请你根据这些信息帮他计算出更新后的数据应该是多少。

## 说明/提示

**【样例 #1 解释】**

$1$ 号函数功能为将 $a_1$ 的值加一。$2$ 号函数功能为所有元素乘 $2$。$3$ 号函数将先调用 $1$ 号函数，再调用 $2$ 号函数。

最终的函数序列先执行 $2$ 号函数，所有元素的值变为 $2, 4, 6$。

再执行 $3$ 号函数时，先调用 $1$ 号函数，所有元素的值变为 $3, 4, 6$。再调用 $2$ 号函数，所有元素的值变为 $6, 8, 12$。

**【数据范围】**

| 测试点编号 | $n, m, Q \le$ | $\sum C_j$ | 其他特殊限制 |
| :----------: | :----------: | :----------: | :----------: |
| $1 \sim 2$ | $1000$ | $= m - 1$ | 函数调用关系构成一棵树 |
| $3 \sim 4$ | $1000$ | $\le 100$ | 无 |
| $5 \sim 6$ | $20000$ | $\le 40000$ | 不含第 $2$ 类函数或不含第 $1$ 类函数 |
| $7$ | $20000$ | $= 0$ | 无 |
| $8 \sim 9$ | $20000$ | $= m - 1$ | 函数调用关系构成一棵树 |
| $10 \sim 11$ | $20000$ | $\le 2 \times 10^5$ | 无 |
| $12 \sim 13$ | $10^5$ | $\le 2 \times 10^5$ | 不含第 $2$ 类函数或不含第 $1$ 类函数 |
| $14$ | $10^5$ | $= 0$ | 无 |
| $15 \sim 16$ | $10^5$ | $= m - 1$ | 函数调用关系构成一棵树 |
| $17 \sim 18$ | $10^5$ | $\le 5 \times 10^5$ | 无 |
| $19 \sim 20$ | $10^5$ | $\le 10^6$ | 无 |

对于所有数据：$0 \le a_i \le 10^4$，$T_j \in \{1,2,3\}$，$1 \le P_j \le n$，$0 \le V_j \le 10^4$，$1 \le g^{(j)}_k \le m$，$1 \le f_i \le m$。

## 样例 #1

### 输入

```
3
1 2 3
3
1 1 1
2 2
3 2 1 2
2
2 3
```

### 输出

```
6 8 12```

## 样例 #2

### 输入

```
10
1 2 3 4 5 6 7 8 9 10
8
3 2 2 3
3 2 4 5
3 2 5 8
2 2
3 2 6 7
1 2 5
1 7 6
2 3
3
1 2 3```

### 输出

```
36 282 108 144 180 216 504 288 324 360
```

## 样例 #3

### 输入

```
见附件中的 call/call3.in```

### 输出

```
见附件中的 call/call3.ans```

# 题解

## 作者：小菜鸟 (赞：268)

好题（

考场上以为T4完全不可做，于是拼命想这题

并且成功在考试结束前9分钟过大样例改命了（

---

### 题意简述

有一个长度为$n$的序列，$m$个操作，操作有如下三种：

* 1.单点加
* 2.全局乘
* 3.以一定顺序调用其他操作，保证不直接或间接调用自身

---

开始我也考虑线段树...然而复杂度显然萎掉

T4又不敢开

所以直接考虑正解。

我们发现当只有操作1的时候，答案可以直接计算而不需要处理

所以我们就把所有操作都转化为操作1

---

假如没有操作3，那么就有一种很显然的做法：

维护一个乘法标记，记录当前全局已经被乘了多少。接下来的加法都乘上乘法标记的逆元。

然而在乘0的时候会出问题，为了方便处理可以倒着扫。这样就不用特判0了。

---

假如没有操作2，那么也有一种很显然的做法：

函数调用很自然地形成一个DAG，那就建一个DAG出来（

把输入数据里被调用的$Q$个函数连接成一个主函数，将它的调用次数设为$1$

然后从主函数出发进行拓扑排序，递推出每一个函数的调用次数，最后直接处理每个操作1

---

然后有一个很关键的想法

**某个函数被调用后序列被乘k，等价于这个函数被执行k次**

于是操作2或3的情况都可以统一转化成改变操作1的执行次数

于是就结束了...

---

至于具体实现

先用一个拓扑排序或记搜把每个函数执行一次后序列被乘的倍数算出来

再用一个拓扑排序递推出每个函数等价的执行次数

---

考场代码，注释很详细是后来加的

```cpp
#include<cstdio>
#include<algorithm>
#include<vector>
#include<queue>

const int N=100005,P=998244353;

int n,m,Q;
std::vector<int> G1[N],G2[N];
//为了求快（写代码快，不是运行快）考试时的图我全用vector了，，，
//G2是函数调用图，G1是G2的反图用于第一遍拓扑排序

int cnt[N];//记录每个函数的执行次数

int data[N],tp[N],mul[N],add[N],pos[N];
//data：原序列
//tp：记录每个操作的类型
//mul：记录每个操作执行一次后会把序列乘多少，操作1和3初始化为1，操作2初始化为读入数据、
//add：记录操作1的加数
//pos：记录操作1的操作位置




int deg1[N];
void topo1()//用于算出每个函数执行完会将序列乘多少
//事实上用记忆化搜索更简单，，，
{
	static std::queue<int> q;
	for(int i=0;i<=m;++i)
	{
		deg1[i]=G2[i].size();
		if(deg1[i]==0)q.push(i);
	}
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		for(int i=0;i!=G1[u].size();++i)
		{
			int v=G1[u][i];
			mul[v]=(long long)mul[v]*mul[u]%P;//直接递推，很容易
			--deg1[v];
			if(deg1[v]==0)q.push(v);
		}
	}
}





int deg2[N];
void topo2()//用于算出每个函数的调用次数
{
	static std::queue<int> q;
	for(int i=0;i<=m;++i)
	{
		deg2[i]=G1[i].size();
		if(deg2[i]==0)q.push(i);
	}
	while(!q.empty())
	{
		int u=q.front();
		int now_mul=1;//当前函数内的乘法标记
		q.pop();
		for(int i=G2[u].size();i!=0;--i)
         //注意这里要倒着遍历边表
         //因为每个函数执行完乘的倍数只影响在它前面执行的函数
		{
			int v=G2[u][i-1];
			cnt[v]=(cnt[v]+(long long)cnt[u]*now_mul)%P;
             //当前乘法标记可以转化为前一个函数的执行次数
			now_mul=(long long)now_mul*mul[v]%P;
			--deg2[v];
			if(deg2[v]==0)q.push(v);
		}
	}
}



#include<cctype>
char gc()
{
	static char buf[1<<16],*p1=buf,*p2=buf;
	if(p1==p2)
	{
		p2=(p1=buf)+fread(buf,1,1<<16,stdin);
		if(p1==p2)return EOF;
	}
	return *p1++;
}

template<typename _Tp>
void read(_Tp &x)
{
	x=0;
	char c=gc();
	while(!isdigit(c))c=gc();
	while(isdigit(c))x=x*10-48+c,c=gc();
}


int main()
{
	read(n);
	for(int i=1;i<=n;++i)read(data[i]);
	read(m);
	mul[0]=1;
	for(int i=1;i<=m;++i)
	{
		read(tp[i]);
		if(tp[i]==1)
		{
			read(pos[i]),read(add[i]);
			mul[i]=1;
		}
		if(tp[i]==2)
		{
			read(mul[i]);
		}
		if(tp[i]==3)
		{
			mul[i]=1;
			int len;
			read(len);
			for(int j=0;j<len;++j)
			{
				int v;
				read(v);
				G1[v].push_back(i);
				G2[i].push_back(v);
			}
		}
	}
	read(Q);
	cnt[0]=1;//把0号函数作为主函数
	for(int i=0;i<Q;++i)
	{
		int x;
		read(x);
		G2[0].push_back(x);
		G1[x].push_back(0);
	}
	topo1();
	topo2();
	for(int i=1;i<=n;++i)data[i]=(long long)data[i]*mul[0]%P;
    //！！！不要忘记主函数本身的乘法标记对答案的影响！！！
	for(int i=1;i<=m;++i)
	{
		if(tp[i]==1)//对于每个操作1，由于没有了操作2和3的影响，可以直接计算答案
		{
			data[pos[i]]=(data[pos[i]]+(long long)cnt[i]*add[i])%P;
		}
	}
	for(int i=1;i<=n;++i)
	{
		printf("%d ",data[i]);
	}
}
```

---

后话：

说实话我觉得这题真的不难，，，只是一开始没想清楚就开始写导致代码很多细节没注意改了半天

T4因为这题写得太久而没时间看，暴力也没打...

虽然T2极限数据没注意挂了但靠着这题还是成功翻盘了（

然而也挺冒险的，，，要是最后这题还是没调出来那后两题就血本无归了

（赛后口胡了一个自以为有问题的T4做法，一看题解居然是对的233333

---

## 作者：AK_Dream (赞：195)

### 题解
第一眼看像是数据结构题？

后来发现这题压根不用数据结构

考虑对于给出的操作建一个图：对于所有操作3，按顺序向它调用的函数连边，这样会得到一个DAG

对于乘法操作，在最后给所有数组元素乘上就好了，关键在于每个加法操作最后乘了一个多大的系数

假设整个数组只有一个元素，对它依次执行：+1, \*3, +2, \*2

那么+1操作实际上就有一个2*3=6的系数，+2有2的系数，所以假设原来这个元素是 $x$，那它最后会是 $6x+1\times 6+ 2\times 2$

发现一个加法操作带的系数就等于它后面的所有乘法操作之积，所以可以倒着进行操作，一边记录已进行的所有乘法操作的积是多少，这样就能计算出每次加法操作带的系数是多少

至此，只含1,2操作的情况就处理完了，接下来考虑3操作

对于图上的每个点(代表着一种操作)，维护一个mul属性，表示执行一次这个操作会给累计的积乘上多少

对于1类操作，它的mul=1；对于2类操作，它的mul就等于它要乘上的值；而对于3类操作，它的mul等于它直接连向的所有点的mul之积

![](https://i.loli.net/2020/11/09/9OWKnCjdG6ey8Ix.png)

如图，点2的mul为2，点3的mul为3，所以点1的mul为6，那么执行一次操作1就会让前面执行过的所有的加法操作再乘上6的系数

按照拓扑序倒序扫一遍或者直接dfs即可处理出mul

然后倒着进行 $q$ 次操作，就可以求得每次操作(类型1或3)带着多少系数，记作sum，然后再把类型3的节点的sum下传到它所包含的类型1节点即可

但是有些类型3的操作既包含加法又包含乘法怎么办？

![108_2.png](https://i.loli.net/2020/11/09/9vnfbWSctpzADRO.png)

考虑这样一张图 假设编号为1的操作的sum是 $x$，那么+2这个操作的sum应该额外增加 $3x$，同理+1的sum应增加 $12x$

所以下传sum时，假设一个点 $x$ 的sum是 $S$，它的儿子是 $y_1,y_2,\cdots y_k$，
那么 $y_i$ 的sum就应该增加 $S$ 乘上 $y_{i+1}\sim y_k$ 的mul之积

最后，让数组的每个元素乘上所有 $q$ 次操作的mul，再遍历所有加法操作计算应该加多少即可

### 代码
```cpp
#include <bits/stdc++.h>
#define N 1000005
using namespace std;
typedef long long ll;

template <typename T>
inline void read(T &num) {
	T x = 0; char ch = getchar();
	for (; ch > '9' || ch < '0'; ch = getchar());
	for (; ch <= '9' && ch >= '0'; ch = getchar()) x = (x << 3) + (x << 1) + (ch ^ '0');
	num = x; 
}

const ll mod = 998244353;
int n, m, Q, F[N];
int head[N], pre[N<<1], to[N<<1], sz, inde[N];
ll a[N];

inline void addedge(int u, int v) {
	pre[++sz] = head[u]; head[u] = sz; to[sz] = v; inde[v]++;
}

struct oper {
	int tp, p;
	ll v, mul, sum; 
} b[N];

queue<int> q;
int ord[N], bnbn;
void toposort() { //拓扑排序
	for (int i = 1; i <= m; i++) if (!inde[i]) q.push(i);
	while (!q.empty()) {
		int x = q.front(); q.pop();
		ord[++bnbn] = x;
		for (int i = head[x]; i; i = pre[i]) {
			int y = to[i];
			inde[y]--;
			if (!inde[y]) q.push(y);
		}
	}
}

void getmul() { //计算节点的mul
	for (int i = m; i; i--) {
		int x = ord[i];
		for (int j = head[x]; j; j = pre[j]) {
			int y = to[j];
			b[x].mul = b[x].mul * b[y].mul % mod;
		}
	} 
}

void getsum() { //下传节点的sum
	for (int i = 1; i <= m; i++) {
		int x = ord[i]; ll now = 1;
		for (int j = head[x]; j; j = pre[j]) {
			int y = to[j];
			b[y].sum = (b[y].sum + b[x].sum * now % mod) % mod;
			now = now * b[y].mul % mod;
		}
	}
}

int main() {
	read(n); 
	for (int i = 1; i <= n; i++) read(a[i]); 
	read(m);
	for (int i = 1; i <= m; i++) {
		read(b[i].tp);
		if (b[i].tp == 1) {
			read(b[i].p); read(b[i].v);
			b[i].mul = 1;
		} else if (b[i].tp == 2) {
			read(b[i].v); b[i].mul = b[i].v;
		} else {
			read(b[i].p); b[i].mul = 1;
			for (int j = 1, x; j <= b[i].p; j++) {
				read(x);
				addedge(i, x);
			}
		}
	}
	toposort(); 
	getmul();
	read(Q); ll now = 1;
	for (int i = 1; i <= Q; i++) read(F[i]);
	for (int i = Q; i; i--) {
		int x = F[i]; b[x].sum = (b[x].sum + now) % mod;
		now = now * b[x].mul % mod;
	}
	getsum();
	for (int i = 1; i <= n; i++) a[i] = a[i] * now % mod;
	for (int i = 1; i <= m; i++) {
		if (b[i].tp == 1) {
			a[b[i].p] = (a[b[i].p] + b[i].v * b[i].sum % mod) % mod;
		}
	}
	for (int i = 1; i <= n; i++) printf("%lld ", a[i]);
	return 0; 
} 

```

---

## 作者：Alex_Wei (赞：133)

upd on 2020.11.17：补充说明。

[题目传送门](https://www.luogu.com.cn/problem/P7077)。

不妨将题目看成：将所有数乘上 $mult$，再给某些数加上 $add_i$，其中 $mult$ 是所有被调用的 type II 函数给所有数乘的 $V_j$ 之积。

不难发现函数的调用关系是 DAG，建完图后可以一遍 dfs 求出 $mul_i$ 表示第 $i$ 个函数调用后会将所有数乘上 $mul_i$。

现在只要求出 $add_i$ 即可：

想一下，如果一个 type I 函数被调用之后，所有数又乘上了 $mult$，那么就相当于该函数产生了 $mult$ 倍的贡献，这启发我们用数组 $f_i$ 表示第 $i$ 个函数对**它所调用的**单点加法产生了 $f_i$ 倍的贡献。

可以先把每个函数在一开始调用时的产生的贡献求出，**对于 type III 函数，不进行下传递归**，最后再用拓扑排序更新真正的 $f_i$。

一开始的贡献可以**倒序处理**所有函数调用：

- 如果调用 I 类函数，那么 $f_i\gets f_i+mult$。
- 如果调用 II 类函数，那么 $mult\gets mult\times V_i$。
- 如果调用 III 类函数，那么 $f_i\gets f_i+mult$，$mult\gets mult\times mul_i$。

为什么要倒序处理：一开始计算的贡献 $f_i$ 是**在调用该函数后所有数被乘了 $f_i$**，因此需要倒序处理。

最后拓扑排序时，对于每个函数：

- 如果是 I 类函数，那么 $add_{P_i}\gets add_{P_i}+f_i\times V_i$。

- 如果是 III 类函数，那么**从后往前处理所有调用的函数**（原因同上）：
	
  对于每个被调用的函数 $j$，$f_j\gets f_j+f_i$。
  
  **此时 $j$ 被调用前一个调用的函数 $pre$ 相当于产生了 $f_i\times mul_j$ 倍的贡献，因为调用 $pre$ 后调用 $j$ 将所有数乘上了 $mul_j$，也就是说调用 $pre$ 产生的单点加法贡献被放大了 $mul_j$ 倍**，此时我们将 $f_i\gets f_i\times mul_j$。
  
  但是这样会导致原来的 $f_i$ 被覆盖，那么用一个变量代替 $f_i$ 即可。

最后每个数输出 $a_i\times mult+add_i$ 即可。

感觉可以通过差分做到线性时间区间修改，要是我就加强了（

时间，空间复杂度 $O(n+m)$。读入量较大，建议使用快读。

---

拿样例 $1$ 举个例子：

不难求出 $mul=\{1,2,2\}$。此时 $mult=1$。

调用的函数分别为 $2,3$，那么我们倒序处理调用：

首先是 $3$，$f_3\gets f_3+mult=1$，$mult\gets mult\times mul_3=2$。

然后是 $2$，$mult\gets mult\times mul_2=4$。

此时 $mult=4$，$f=\{0,0,1\}$，度数 $deg=\{1,1,0\}$。

接下来拓扑排序，因为 $3$ 的入度为 $0$ 所以首先被压入队列。

- 对于队首函数 $3$，倒序处理所有其调用的函数：

  设变量 $z\gets f_3=1$。

  - 首先是 $2$：
  
    $deg_2\gets deg_2-1=0$，入度为 $0$ 被压入队列。
    
    $f_2\gets f_2+z=1$（没有必要）。
    
    $z\gets z\times mul_2=2$。
    
  - 然后是 $1$：
    
    $deg_1=\gets deg_1-1=0$，入度为 $0$ 被压入队列。
    
    $f_1\gets f_1+z=2$。
    
    $z\gets z\times mul_1=2$（没有必要）。

- 对于队首函数 $2$，不做任何操作。

- 对于队首函数 $1$，$add_{pos_1}\gets add_{pos_1}+f_1\times V_1=0+2\times 1=2$。

最后分别输出：  
$a_1\times mult+add_1=1\times 4+2=6$；  
$a_2\times mult+add_2=2\times 4+0=8$；  
$a_3\times mult+add_3=3\times 4+0=12$。

---

非考场代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

#define ll long long
inline ll read(){
	ll x=0,sign=0; char s=getchar();
	while(s>'9'||s<'0')sign|=s=='-',s=getchar();
	while(s<='9'&&s>='0')x=(x<<1)+(x<<3)+s-'0',s=getchar();
	return sign?-x:x;
}

const int N=1e5+5;
const int mod=998244353;

int n,m,c,a[N],deg[N],func[N];
int tp[N],pos[N],val[N];
ll mu=1,mul[N],dp[N],add[N];
vector <int> e[N];
queue <int> q;

bool vis[N];
void dfs(int id){
	vis[id]=1,mul[id]=(tp[id]==2?val[id]:1);
	for(int it:e[id]){
		if(!vis[it])dfs(it);
		mul[id]=mul[id]*mul[it]%mod;
	}
}

int main(){
	n=read(); for(int i=1;i<=n;i++)a[i]=read();
	m=read();
	for(int i=1;i<=m;i++){
		tp[i]=read();
		if(tp[i]==1)pos[i]=read(),val[i]=read();
		else if(tp[i]==2)val[i]=read();
		else{
			c=read();
			while(c--){
				int to=read();
				e[i].push_back(to),deg[to]++;
			}
		}
	} c=read();
	for(int i=1;i<=m;i++)if(!vis[i]&&!deg[i])dfs(i);
	for(int i=1;i<=c;i++)func[i]=read();
	for(int i=c,f=func[i];i;i--,f=func[i]){
		if(tp[f]==1)dp[f]=(dp[f]+mu);
		else if(tp[f]==2)mu=mu*val[f]%mod;
		else dp[f]=(dp[f]+mu),mu=mu*mul[f]%mod;
	} for(int i=1;i<=m;i++)if(!deg[i])q.push(i);
	while(!q.empty()){
		int t=q.front(); q.pop();
		if(tp[t]==1)add[pos[t]]=(add[pos[t]]+dp[t]*val[t])%mod;
		ll z=dp[t]; reverse(e[t].begin(),e[t].end());
		for(int p:e[t]){
			deg[p]--; if(!deg[p])q.push(p);
			dp[p]=(dp[p]+z)%mod,z=z*mul[p]%mod;
		}
	} for(int i=1;i<=n;i++)cout<<(a[i]*mu+add[i])%mod<<" ";
	return 0;
}
```

---

## 作者：Calculatelove (赞：78)

upd：修改了 $\LaTeX$ 和~~错别字~~。

题目链接：[Link](https://www.luogu.com.cn/problem/P7077)。

## Solution

- 不难看出，如果我把每个函数看成一个点。  
  那么对于每个 $T_j = 3$  的函数 $j$，我让 $j$ 向 $g_1^{(j)}, g_2^{(j)}, ..., g_{C_j}^{(j)}$ 连边的话，会得到一张 DAG。

- 记 " 调用函数 $i$ 会使全局乘多少倍 " 为 $\text{mul}_i$，该数组可以在 DAG 上记忆化搜索求出。
- 注意到影响到答案最后取值的操作只有 " 单点加 " 和 " 全局乘 " 两种操作。  
  那么我可以尝试把最终序列上，第 $i$ 个位置上的数表示为下列该式的形式：

$$
a_i \times b + k_i
$$

- 其中：
  - $a_i$ 表示：初始序列中第 $i$ 个位置上的值。
  - $b$ 表示：所有操作结束后，" 全局乘 " 的倍数。
  - $k_i$ 表示：所有 " 单点加 " 操作对第 $i$ 个位置的贡献。

- 那现在关键是在于如何求出每个 $k_i$。
- 一个重要的思想是：如果我进行了一次 " 值为 $a$ 的单点加 "，然后我进行了一次 " 值为 $b$ 的全局乘 "，那么我可以看作是进行了 $b$ 次 " 值为 $a$ 的单点加 "。
- 记 " 函数 $i$ 进行了多少次 " 为 $f_i$，对于每次调用，先在节点上打上标记，最后再用拓扑排序向下传递贡献。
- 具体地，**倒序处理**每一个调用（因为只有时间更靠后的 " 全局乘 " 才能影响到 " 单点加 "），假设说我这次要调用第 $i$ 个函数，那么：
  - 令 $f_i \gets f_i + b$。
  - 令 $b \gets b \times \text{mul}_i$。

- 然后考虑拓扑排序，假设说我这次要处理第 $i$ 个函数，那么：
  - 若 $T_i = 1$，则令 $k_{P_i} \gets k_{P_i} + V_i \times f_i$。
  - 若 $T_i = 2$，则无视该操作。
  - 若 $T_i = 3$，则**倒序处理**每一个调用，假设说我现在要将贡献传递给函数 $j$，那么：
  	   > - $f_j \gets f_j + f_i$
       > - $f_i \gets f_i \times \text{mul}_j$。

- 拓扑排序完直接输出 $a_i \times b + k_i$ 即可。
- 时间复杂度 $\mathcal{O(n + m + Q)}$。

## Code

```c++
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>
#include <vector>

using namespace std;

inline int read() {
	int x = 0, f = 1; char s = getchar();
	while (s < '0' || s > '9') { if (s == '-') f = -f; s = getchar(); }
	while (s >= '0' && s <= '9') { x = x * 10 + s - '0'; s = getchar(); }
	return x * f;
}

const int N = 100100;
const int mod = 998244353;

int n;

int a[N];

int m;

struct operation {
	int opt;
	int pos, val;
	vector<int> g;
} T[N];

int mul[N];

void calc(int u) {
	if (mul[u] != -1) return;

	switch (T[u].opt) {
		case 1: {
			mul[u] = 1;

			break;
		}

		case 2: {
			mul[u] = T[u].val;

			break;
		}

		case 3: {
			mul[u] = 1;
			for (int i = 0; i < (int)T[u].g.size(); i ++) {
				int v = T[u].g[i];
				calc(v);
				mul[u] = 1ll * mul[u] * mul[v] % mod;
			}

			break;
		}
	}
}

int Q;
int idx[N];

int b;
int f[N];

int deg[N];

int k[N];

void topsort() {
	queue<int> q;

	for (int i = 1; i <= m; i ++)
		if (deg[i] == 0) q.push(i);

	while (q.size()) {
		int u = q.front(); q.pop();

		switch (T[u].opt) {
			case 1: {
				k[T[u].pos] = (k[T[u].pos] + 1ll * f[u] * T[u].val) % mod; 

				break;
			}

			case 2: {
				break;
			}

			case 3: {
				for (int j = T[u].g.size() - 1; j >= 0; j --) {
					int v = T[u].g[j];
					f[v] = (f[v] + f[u]) % mod;
					f[u] = 1ll * f[u] * mul[v] % mod;
					if (-- deg[v] == 0) q.push(v);
				}

				break;
			}
		}
	}
}

int main() {
	n = read();

	for (int i = 1; i <= n; i ++)
		a[i] = read();

	m = read();

	for (int i = 1; i <= m; i ++) {
		T[i].opt = read();

		switch (T[i].opt) {
			case 1: {
				T[i].pos = read(), T[i].val = read();

				break;
			}

			case 2: {
				T[i].val = read();

				break;
			}

			case 3: {
				int C = read();
				for (int j = 1; j <= C; j ++) {
					int x = read();
					T[i].g.push_back(x);
				}

				break;
			}
		} 
	}

	memset(mul, -1, sizeof(mul));
	for (int i = 1; i <= m; i ++)
		if (mul[i] == -1) calc(i); 

	Q = read();

	for (int i = 1; i <= Q; i ++)
		idx[i] = read();

	b = 1;
	for (int i = Q; i >= 1; i --) {
		switch (T[idx[i]].opt) {
			case 1: {
				f[idx[i]] = (f[idx[i]] + b) % mod;

				break;
			}

			case 2: {
				b = 1ll * b * T[idx[i]].val % mod;

				break;
			}

			case 3: {
				f[idx[i]] = (f[idx[i]] + b) % mod;
				b = 1ll * b * mul[idx[i]] % mod;

				break;
			}
		}
	}

	for (int u = 1; u <= m; u ++) {
		if (T[u].opt != 3) continue;

		for (int j = 0; j < (int)T[u].g.size(); j ++) {
			int v = T[u].g[j];
			deg[v] ++;
		} 
	}

	topsort();

	for (int i = 1; i <= n; i ++)
		printf("%d ", (1ll * a[i] * b + k[i]) % mod);
	puts("");

	return 0;
}
```

---

## 作者：OMG_wc (赞：31)

看着像数据结构，其实是一道 DP 题。

首先考虑没有 $3$ 操作时的情形，很显然变成了一道水题：对每个加操作，只需把加的数再乘上其后所有乘操作的积，也就是倒着计算一遍就好了。

现在有了 $3$ 操作，就是在原题基础上加了图论知识，因为不存在递归，所以画出的图是一个 DAG。

有一个很naive的思路是，把所有函数展开，但是对于 DAG 来说还是会非常长，只能骗部分分，于是考虑用 DP 来算这些贡献。

对于建图，可以建一个 0 号结点表示主函数，然后连边到 $f_i$ ，这样就有唯一的入口了，方便后面的计算。

观察样例二，在草稿纸上推出结果（其实这个样例并不怎么好，推出 $42$ 这个系数，然后考虑怎么计算）。这一步一定要尝试，不然以下解法你可能会看不懂，并且还需要多画几个图~~（我自己画了几个非常美妙的图，可惜这里空白的地方太小了）~~。

既然是 DAG，可以先求出拓扑序，方便后面的计算。~~鉴于有些人不会写拓扑排序（不存在的）~~，这里我的方法**不需要拓扑排序，只要两次记忆化搜索**。

首先 $d[i]$ 表示后续所有二操作结点的积，这个直接一遍记忆化搜索就求出来了。因为数组有初值（也可以看成 $n$ 个加操作丢进图里，不过好像没有必要），这些初值显然需要乘以 $d[0]$ 。

在上面记忆化搜索的同时，对每条边 $u\rightarrow v$，需要维护一个“右兄弟积“，也就是 $v$ 右边的 $u$ 的其他子结点的 $d[i]$ 之积。这个东西其实是在给第二次 DP 做准备，右兄弟积是**一次调用 $u$ 函数后  $u$ 的后代里的二操作 对  $v$ 的后代的一操作 的乘积贡献**，而 $v$ 的后代真正需要的贡献还需要考虑 $u$ 的祖先（所以才需要第二次 DP）。注意这个东西是存在边上，而不是存在点上的，一定要搞清楚这一点。

定义 $f[i]$ 表示到 $i$ 结点为止的后继总积，初始时 $f[0]=1$，其他入口值都是 $0$ （这些函数根本不会被调用），我们现在的目的就是把这个 $f$ 值一点点的往下传到操作一的结点上。注意 $DAG$ 和树的区别，在 DAG 中结点的父节点不唯一，你需要把这些父节点的下传都结算完，再能把当前结点的贡献往下传。这里拓扑排序就派上用场了，但记忆化搜索也可以，只需反向建图即可。

特别注意，$n$ 是数组的大小，$m$ 才是结点数，不要搞反。

记忆化搜索代码如下，时间复杂度 $O(n+m+\sum C_i)$：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int INF = 0x3f3f3f3f;
const LL mod = 998244353;
const int N = 100005;

// d[i]表示全局积 f[i] 表示后继积
int a[N], op[N], b[N], c[N];
LL d[N], f[N];
vector<pair<int, int> > G[N], H[N];
LL dfs(int u) {
    if (~d[u]) return d[u];
    d[u] = op[u] == 2 ? c[u] : 1;
    LL s = 1;
    for (int i = G[u].size() - 1; i >= 0; i--) {
        int v = G[u][i].first;
        G[u][i].second = s;
        d[u] = d[u] * dfs(v) % mod;
        s = s * d[v] % mod;  // 所有右兄弟的积
    }
    return d[u];
}
LL dfs2(int u) {
    if (~f[u]) return f[u];
    f[u] = 0;
    for (int i = 0; i < H[u].size(); i++) {
        int v = H[u][i].first, w = H[u][i].second;
        f[u] = (f[u] + w * dfs2(v)) % mod;
    }
    return f[u];
}
int main() {
    // freopen("call.in", "r", stdin);
    // freopen("call.out", "w", stdout);
    int n, m, q;
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
    scanf("%d", &m);
    for (int i = 1; i <= m; i++) {
        scanf("%d", &op[i]);
        if (op[i] == 1) {
            scanf("%d %d", &b[i], &c[i]);
        } else if (op[i] == 2) {
            scanf("%d", &c[i]);
        } else {
            int t;
            scanf("%d", &t);
            while (t--) {
                int v;
                scanf("%d", &v);
                G[i].push_back({v, 0});
            }
        }
    }
    scanf("%d", &q);
    while (q--) {
        int v;
        scanf("%d", &v);
        G[0].push_back({v, 0});
    }
    memset(d, -1, sizeof d);
    memset(f, -1, sizeof f);
    dfs(0);
    for (int i = 1; i <= n; i++) {
        a[i] = a[i] * d[0] % mod;
    }
    for (int u = 0; u <= m; u++) {
        for (int i = 0; i < G[u].size(); i++) {
            int v = G[u][i].first, w = G[u][i].second;
            H[v].push_back({u, w});
        }
    }
    f[0] = 1;
    for (int i = 1; i <= m; i++) {
        if (op[i] == 1) {
            a[b[i]] = (a[b[i]] + dfs2(i) * c[i]) % mod;
        }
    }
    for (int i = 1; i <= n; i++) {
        printf("%d%c", a[i], " \n"[i == n]);
    }
    return 0;
}
```

拓扑排序版本的代码：https://www.luogu.com.cn/paste/9s7z9nm6

---

## 作者：幻影星坚强 (赞：28)

前言：考场上因为某些原因这题写挂了，而且错误真的很小，赛后真正改代码的时间为半分钟（）。

在这里分享一下自己考场上写这道题的思考过程（那个考场因为读题错误调了2h没调出来的错误就不说了）

- **分析**

我们肯定不能计算出每个点被选择后对于全部加的影响。所以我们需要计算出的必然是选择每个点后会让他所能到达的操作1与2的点造成什么影响。我们来考虑怎么做。

既然出题人给了我们只有乘和只有加的部分分，我们就以此为突破口。

- **1.只有乘**

因为乘会对全局产生影响，所以我们只要计算出它每次操作乘了多少。

因为图是一张DAG，而且已知一些没有出度的点的值，每个节点的贡献的乘积为所指向的所有节点的乘积，所以我们可以在反图上跑拓扑排序。

![](https://cdn.luogu.com.cn/upload/image_hosting/5qp40k0k.png)

我们以这张图为例。   
一开始$x_1,x_2,x_3,x_4$被加入队列，于是$2$的贡献被乘$x_1$，$3$的贡献被乘$x_2$，$4$的贡献为$x_3 \times x_4$。   
之后$4$被加入队列，$2$与$3$都乘上了$x_3 \times x_4$，贡献分别变成了$x_1  \times x_3 \times x_4$ 与 $x_1  \times x_3 \times x_4$，$2,3$被加入队列。   
之后$1$被乘上$x_1  \times x_3 \times x_4$ 与 $x_1  \times x_3 \times x_4$，贡献为$x_1  \times x_3 \times x_4 \times x_1  \times x_3 \times x_4$。

用这样的方法，我们可以知道选择一个点后会对全局乘操作乘多少。

```cpp
void Top1()
{
	queue<int>q;
	for (int i = 1; i <= m; ++ i)
	{
		if(ru1[i] == 0)
		q.push(i);
	}
	while(!q.empty())
	{
		int now = q.front();
		q.pop();
		for (int i = _front[now]; i; i = _eg[i].from)
		{
			int to = _eg[i].to;
			mul[to] *= mul[now];
			mul[to] %= MOD;
			-- ru1[to];
			if(ru1[to] == 0)
			q.push(to);
		}
	}
}//乘操作拓扑排序部分

```

- **2.只有加**

一个点被加的次数就相当于一个点到达的次数，也就是从起点到该点的方式总数，这个也可以通过拓扑排序完成。而由于有多个询问，所以我们可以将这些询问点的值首先都加上$1$，相当于这些点都有一种额外的到达方式，为直接从此处开始。

![](https://cdn.luogu.com.cn/upload/image_hosting/5qp40k0k.png)

还是这张图，假设询问$1,2,4$。那么首先把$1,2,4$的到达方式都设为$1$，然后开始拓扑排序。   
一开始$1$加入队列，并且能到$2,3$，所以$2,3$的值加上$1$的值，于是$2$的值变为$2$，$3$的值变为$1$。同时$2,3$加入队列。   
之后$2$能到$x_1, 4$，于是$x_1$的值变为$2$，$4$的值变为$3$。$3$能到$x_2, 4$，于是$x_2$的值变为$1$，$4$的值变为$4$。$4$被加入队列   
最后$4$能到$x_3,x_4$，于是$x_3, x_4$的值都变为$4$。

于是我们可以知道每个点被加了多少次，最后直接计算答案。

```cpp

void Top1.5()
{
	queue<int>q;
	for (int i = 1; i <= m; ++ i)
	{
		if(ru2[i] == 0)
		q.push(i);
	}
	while(!q.empty())
	{
		int now = q.front();
		q.pop();
		for (int i = front[now]; i; i = eg[i].from)
		{
			int to = eg[i].to;
			-- ru2[to];
			val[to] += val[now] % MOD;
			val[to] %= MOD;
			if(ru2[to] == 0)
			q.push(to);
		}
	}
}
...
//以下为主程序的计算贡献部分
for (int i = 1; i <= m; ++ i)
{
	if(t[i] == 1)
	a[pos[i]] += val[i] * v[i] % MOD, a[pos[i]] %= MOD; 
}//v[i]表示这个函数所加的值,val[i]表示到达次数
```
- **2.5.树**

出题人给了个树的部分分，~~我并不知道有什么用，反正上面两个已经能推出正解了。~~


- **3.加和乘都有**

最大的问题在于每个乘会对前面的加操作造成影响，所以我们对于每个加操作还要得到在他后面执行所有乘操作的影响。

我们先来考虑只有一个询问的函数的情况

对于每一次下传贡献，我们只要考虑这个函数后面的操作所造成的乘操作对于这次加贡献的影响。因为路径上的每一个点都会考虑，所以不会有遗漏。

(其实对于乘操作我们可以理解成使得该点前面执行这些边的路径都分裂成几条，到达的方式也会乘上这个值)

具体看图：

![](https://cdn.luogu.com.cn/upload/image_hosting/frayncgx.png)

其实这就是样例2

$1$的执行顺序为$2, 3$，$2$的执行顺序是$mul_1,4$，$3$的执行顺序是$4,mul_2$，$4$的执行顺序不重要。

我们对于每一条边都求出这条边会分裂成几条边。

现在假设已经求出$2,mul_1$的乘积贡献为$mul_1$，$3,mul_2$的贡献为$mul_2$。$4,add_1,add_2$的贡献为$1$。

对于$2$节点，我们从后往前看他所要到达的节点。最开始是$mul_1$，他不会分裂，即为1条，之后的道路都会分裂成$mul_1$条，后来到$4$，他分裂成了$mul_1$条，后面的道路会分裂成$mul_1 \times 1$条，后面发现没了，结束。

对于$1$节点，我们从前往后看他所要到达的节点。最开始是$2$，他不会分裂，即为1条，之后的道路都会分裂成$mul_1$条，后来到$3$，他分裂成了$mul_1$条，后面的道路会分裂成$mul_1 \times mul_2$条，后面发现没了，结束。

其他的节点也是同样的处理方式。

于是我们将分裂成的条数变为边权，在转移的时候顺便乘上边权即可

```cpp
void Top2()
{
	queue<int>q;
	for (int i = 1; i <= m; ++ i)
	{
		if(ru2[i] == 0)
		q.push(i);
	}
	while(!q.empty())
	{
		int now = q.front();
		q.pop();
		for (int i = front[now]; i; i = eg[i].from)
		{
			int to = eg[i].to;
			-- ru2[to];
			val[to] += val[now] * eg[i].w % MOD;//乘上分裂成的条数
			val[to] %= MOD;
			if(ru2[to] == 0)
			q.push(to);
		}
	}
}
...
//以下为主函数的处理分裂条数部分
for (int now = 1; now <= m; ++ now)
{
	long long mu = 1;
	for (int i = b[now].size() - 1; i >= 0; -- i)
	{
		int to = b[now][i];
		_add(now, to, mu);
		mu *= mul[to];
		mu %= MOD;
	}
}
```

而有多次询问的处理也很简单，在只有加的时候我们是把所有的询问函数的初始值设为$1$，而对前面的询问函数有影响的操作只有乘，所以我们把初始值设为后面所有执行函数造成的乘贡献之积，则这个询问节点所造成的的贡献之值都会乘上后面所有执行函数造成的乘贡献之积，也就相当于这些加操作都乘上了后面的乘操作。

```cpp
for (int i = q; i >= 1; -- i)
{
	val[que[i]] += mu;
	val[que[i]] %= MOD;
	mu *= mul[que[i]];
	mu %= MOD;
}
```

之后每个值先乘上所有乘操作带来的贡献，再加上所有的加操作带来的贡献即可

以下是代码~~（注：是考场上有一行错误的代码，但非算法错误）~~

update:避免被D还是放上正确的代码（）

```cpp
#include <iostream>
#include <cstdio>
#include <vector>
#include <queue>
#include <cstring>
using namespace std;
const int N = 1e5 + 10;
const int M = 1e6 + 10;
const long long MOD = 998244353;
int n, m, q;
/*1 
0 
1 
1 1 1 
2 1 1 */
struct bian
{
	int from, to;
	long long w;
}eg[M], _eg[M];
int front[N], num;
void add(int x, int y)
{
	eg[++ num].to = y;
	eg[num].from = front[x];
	front[x] = num;
}
void _add(int x, int y, long long w)
{
	eg[++ num].to = y;
	eg[num].from = front[x];
	front[x] = num;
	eg[num].w = w;
}
int _front[N], _num;
void add1(int x, int y)
{
	_eg[++ _num].to = y;
	_eg[_num].from = _front[x];
	_front[x] = _num;
}
int t[N], pos[N];
long long v[N], a[N];
int ru1[N], ru2[N];
long long val[N];
int sf[N];
long long mul[N];
vector<int>b[N];
void Top1()
{
	queue<int>q;
	for (int i = 1; i <= m; ++ i)
	{
		if(ru1[i] == 0)
		q.push(i);
	}
	while(!q.empty())
	{
		int now = q.front();
		q.pop();
		for (int i = _front[now]; i; i = _eg[i].from)
		{
			int to = _eg[i].to;
			mul[to] *= mul[now];
			mul[to] %= MOD;
			-- ru1[to];
			if(ru1[to] == 0)
			q.push(to);
		}
	}
}
void Top2()
{
	queue<int>q;
	for (int i = 1; i <= m; ++ i)
	{
		if(ru2[i] == 0)
		q.push(i);
	}
	while(!q.empty())
	{
		int now = q.front();
		q.pop();
		for (int i = front[now]; i; i = eg[i].from)
		{
			int to = eg[i].to;
			-- ru2[to];
			val[to] += val[now] * eg[i].w % MOD;
			val[to] %= MOD;
			if(ru2[to] == 0)
			q.push(to);
		}
	}
}
int que[N];
void dfs(int o)
{
	if(sf[o] == 1)
	return;
	sf[o] = 1;
	for (int i = front[o]; i; i = eg[i].from)
	{
		int to = eg[i].to;
		dfs(to);
	}
}
int main()
{
	scanf("%d", &n);
	for (int i = 1; i <= n; ++ i)
	{
		scanf("%lld", &a[i]);
	}
	scanf("%d", &m);
	for (int i = 1; i <= m; ++ i)
	{
		int op;
		scanf("%d", &op);
		t[i] = op;
		if(op == 1)
		{
			scanf("%d%lld", &pos[i], &v[i]);
		}
		if(op == 2)
		{
			scanf("%lld", &v[i]);
		}
		if(op == 3)
		{
			int g;
			scanf("%d", &g);
			for (int j = 1; j <= g; ++ j)
			{
				int x;
				scanf("%d", &x);
				b[i].push_back(x);
				add(i, x);
			}
		}
	}
	num = 0;
	scanf("%lld", &q);
	for (int i = 1; i <= q; ++ i)
	{
		int x;
		scanf("%lld", &x);
		que[i] = x;
		dfs(x);
	}
	for (int i = 1; i <= m; ++ i)
	{
		mul[i] = 1;
		if(t[i] == 2)
		mul[i] = v[i];
		for (int j = front[i]; j; j = eg[j].from)
		{
			int to = eg[j].to;
			if(t[i] != 1)
			{
				add1(to, i);
				++ ru1[i];
			}
		}
	}
	Top1();
	memset(front, 0, sizeof(front));
	memset(eg, 0, sizeof(eg));
	for (int now = 1; now <= m; ++ now)
	{
		if(sf[now] == 0)continue;
		long long mu = 1;
		for (int i = b[now].size() - 1; i >= 0; -- i)
		{
			int to = b[now][i];
			++ ru2[to];
			_add(now, to, mu);
			mu *= mul[to];
			mu %= MOD;
		}
	}
	long long mu = 1;
	for (int i = q; i >= 1; -- i)
	{
		(val[que[i]] += mu) %= MOD;
		mu *= mul[que[i]];
		mu %= MOD;
	}
	Top2();
	for (int i = 1; i <= n; ++ i)
	{
		a[i] *= mu;
		a[i] %= MOD;
	}
	for (int i = 1; i <= m; ++ i)
	{
		if(t[i] == 1)
		a[pos[i]] += val[i] * v[i] % MOD, a[pos[i]] %= MOD; 
	}
	for (int i = 1; i <= n; ++ i)
	{
		printf("%lld ", a[i]);
	}
}
```


---

## 作者：little_prince (赞：23)

[函数调用](https://www.luogu.com.cn/problem/P7077)

这真是一道极好的思维题，让现阶段建立思维能力完全不够的我在考场上吃了大亏，长了大智。

首先读完题后会以为只是个线段树2模板，但是很快发现函数间的调用关系是很多的，如果真的要写线段树，只能拿20pts。

然后分析本题性质。**函数间的调用不构成递归**。说明函数间的调用关系构成一个DAG图。

怎么下手呢？这考场上我居然完全不知道。**先单独分类！**（数据范围有4个点都提示了……）

如果说只有操作2（只有乘法，注意乘法的对象是**全体**），那么完全可以直接统计每一个调用的函数的mul之积，也就是调用这个函数以后整体共又乘了多少。然后直接计算即可。这个很简单。

如果说只有操作1，我们可以选择去由上而下去积累函数调用的次数，即可以写成
$$cnt[v] = cnt[v] + cnt[u]$$
的形式依次递推到每个真正实行加操作的函数上，然后再直接统计即可。

这样**分类简化问题**的思想，自己怎么会没有？

然后再考虑同时有操作1和操作2的问题，如果不好想，可以先再草稿纸上把函数调用关系画成一棵树（这也是根据数据范围想部分分的思路！）。这里开始详细阐述这种处理方法。

#### 一.函数关系处理初探

首先我们要有一个意识，就是我们最开始的做法不能具体到每一个加、乘函数上，否则那样的时间复杂度一定会到
$ O(Qm)$上，T飞掉。然后我们发现，函数调用之间由于先后顺序是有一定的影响的。

我们想一想，如果执行完一个函数（该函数为调用其他函数的类型或者是加函数）以后再去调用一个乘函数（假设是乘2），那么**对于之前所有的对原数组产生累加影响的函数，所带来的影响，是不是相当于乘了2？** 再仔细想想就可以得到一个结论：

### 后执行的函数的mul之积（该函数下所有乘函数的积）设为K，对前面执行的函数的影响，等价于增加了前面函数执行的次数K次。

这是本题考虑函数影响的核心。我们用$cnt[x]$表示函数$x$的调用次数，那么有
$$totmul = 1;$$
每一次
$$cnt[x] += totmul;$$
$$totmul * = mul[x] $$

#### 二.计算函数影响

现在，我们已经通过上面的方法统计了当前Q个函数的执行次数，已经考虑了函数之间互相的影响。那么对于一个函数$x$，我们已知调用次数$cnt[x]$，那么现在不能着急地去求加函数影响！如果那样时间复杂度又上来了！我们应该类似于线段树标记下传的思想，**把调用次数依次按拓扑序下传，最后得到在Q个函数的影响内每一个函数的调用次数** 。这个也是核心！

细想一下，我们发现如果当前下传的这个子节点$y$之后有乘函数，那么这个子节点的调用次数又会受到这个乘函数的影响。因此我们**倒序循环$x$的每一个出节点，如果有乘函数的影响，类似于上面的记一个nowmul**。
如下，
$$cnt[y] += cnt[x] * nowmul;$$
$$nowmul * = mul[x] $$

因此我们就统计出了所有函数的调用次数，本题也就基本解决啦。其实可以发现，最后统计的cnt只对加函数最有用，这个完全可以感性理解哦。

### PS：

#### 拓扑序记得入度为0了才能进队！！！
统计两遍拓扑序，其实就是想只考虑Q个函数所影响的DAG图范围。

附上改了好久好久的代码……

```
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const LL MOD = 998244353ll;
inline LL read(){
	LL f=1,r=0;char c=getchar();
	while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
	while(isdigit(c)){r=r*10+c-'0';c=getchar();}
	return f*r; 
}
const int MAXN = 1e6 + 19;
int n,m,Q,f[MAXN],T[MAXN],P[MAXN],V[MAXN],rd[MAXN];
LL a[MAXN];
vector <int> g[MAXN];
void init(){
	n = read();
	for(int i = 1;i <= n; i++) a[i] = read();
	m = read();
	for(int i = 1;i <= m; i++)
	{
		T[i] = read();
		if(T[i]==1) P[i]=read(),V[i]=read();
		else if(T[i]==2) V[i]=read();
		else if(T[i]==3){
			int lx,x;
			lx = read();
			for(int j = 1;j <= lx; j++)
			x = read(),g[i].push_back(x),rd[x]++;
		}
	}
	Q = read();
	for(int i = 1;i <= Q; i++) f[i]=read();
}
queue <int> q;
int Tuo[MAXN],isfc[MAXN];
void tuopu(){
	for(int i = 1;i <= Q; i++) isfc[f[i]] = true; 
	for(int i = 1;i <= m; i++) if(!rd[i]) q.push(i); 
	while(!q.empty()){
		int x=q.front();q.pop();
		for(int i = 0;i < g[x].size(); i++)
		{
			int y = g[x][i];
			rd[y]--;
			if(!rd[y]) q.push(y);
			if(isfc[x]) isfc[y] = true;
		}
	}
	while(!q.empty()) q.pop();
	memset(rd,0,sizeof(rd));
	for(int i = 1;i <= m; i++)
	if(isfc[i]){
		for(int j = 0;j < g[i].size(); j++) 
		rd[g[i][j]]++;
	}
	for(int i = 1;i <= m; i++) if(isfc[i] && !rd[i]) q.push(i);
	while(!q.empty()){
		int x=q.front();q.pop();
		Tuo[++Tuo[0]] = x;
		for(int i = 0;i < g[x].size(); i++)
		{
			int y = g[x][i];
			rd[y]--;
			if(!rd[y]) q.push(y);
		}
	}
//	for(int i = 1;i <= Tuo[0]; i++) printf("Tuo[%d] = %d\n",i,Tuo[i]);
}
LL tot_mul,mul[MAXN],cnt[MAXN];
void prepare(){
	for(int i = 1;i <= m; i++) mul[i] = T[i] == 2 ? V[i] : 1ll;
	for(int i = Tuo[0];i;i--)
	{
		int x = Tuo[i];
		for(int j = 0;j < g[x].size(); j++)
		mul[x] = (mul[x] % MOD * (mul[g[x][j]] % MOD) + MOD) % MOD;
	}
	tot_mul = 1ll;
	for(int i = Q;i;i--)
	{
		int x = f[i];
		cnt[x] = (cnt[x] + tot_mul) % MOD;
		tot_mul = (tot_mul % MOD * (mul[x] % MOD) + MOD) % MOD;
	}
}
void solve(){
	LL now_mul = 1ll;
	for(LL i = 1;i <= Tuo[0];i++)
	{
		LL x = Tuo[i];now_mul = 1ll;
		for(LL j = g[x].size() - 1;j >= 0; j--)
		{
			LL y = g[x][j];
			cnt[y] = (cnt[y] % MOD + now_mul % MOD * (cnt[x] % MOD) + MOD) % MOD;
			now_mul = (now_mul % MOD * (mul[y] % MOD) + MOD) % MOD;
		}
	}
}
void print(){
	for(int i = 1;i <= n; i++) a[i] = a[i] % MOD * (tot_mul%MOD) % MOD;
	for(int i = 1;i <= m; i++)
	if(T[i]==1)
	{
		a[P[i]] = a[P[i]] % MOD + V[i] % MOD * (cnt[i] % MOD) % MOD;
	}
//	for(int i = 1;i <= m; i++) printf("cnt[%d] = %d\n",i,cnt[i]);
	for(int i = 1;i <= n; i++) cout<<a[i] % MOD<<" ";	
}
int main(){
	//freopen("data.in","r",stdin);
	//freopen("data.out","w",stdout);
	init();
	tuopu();
	prepare();
	solve();
	print();
	return 0;
}
```
由于本人学术不精，思想借助了几篇题解，只希望给像我一样弱的同道者一些帮助。里面longlong和int很有点乱，望谅解。

---

## 作者：zjjws (赞：14)

$\texttt{data-2020-11-13}$

修正了部分错误，以及增添了一些描述。

---

#### 考场经历

考场上打了只有加和只有乘的两种特殊情况，然后没时间了，因为 T1 调了太久。

感觉树的形态的部分分是没有用的，都能打树的情况了满分无非就是加个拓扑。（当然也可能有什么我没想到的高妙骗分手段）

---

#### Solution

在只有加或乘的情况下，只需要拓扑传递执行次数便可，因为此时满足交换律。

然后就考虑：如何从特殊到一般？在乘和加同时存在的时候，就必须要考虑运算顺序了。

然后就发现其实只有一个地方会有影响：对于每个加法操作 $i$，后面所有的乘法操作 $j$ 都会对其产生 $\times p_j$ 的贡献。

那如果能够做到快速求出每个加法操作被哪些乘法操作所影响（$\prod p_j$ 即为贡献），我就可以将乘法操作看成是**对加法操作执行次数**的计算。必然，原数列自然也可以看成一堆加法操作。

思路分析完了，接下来考虑如何实现刚刚嘴巴 AC 的这个东西。

首先这个 $\prod p_j$ 有两部分，为了讲清楚，我需要画点图。

![](https://cdn.luogu.com.cn/upload/image_hosting/2otmj37s.png)

拓扑图中的各点即表示一种操作，边的方向为从上向下（因为画图工具不便所以没有箭头），其中出度为 $0$ 的点 $d,f$ 是操作 $1$ 或 $2$ ，其余点都是操作 $3$。

左上角那个字符串即为大小为 $m$ 的操作序列。

对于每一个操作 $3$，设其编号为 $y$，它都可以拆分成为一个只由操作 $1$ 和操作 $2$ 组成的序列 $q_y$。拆分完之后，对于 $q_y$ 中每一个加法，它的贡献分为两部分：

设拆分后的序列长度为 $k_{...}$

所有外部的贡献：

$$\prod_{i=y+1}^m \prod_{j=1}^{k_i}v_{q_{i,j}}\times [typ_{q_{i,j}}=2]$$

以及内部自己贡献：

对于元素 $q_{y,i}$，有贡献：

$$\prod_{j=i+1}^{k_y}v_{q_{y,j}}\times [typ_{q_{y,j}}=2]$$

这个式子看不懂怎么办？也没有关系，你也可以听我口胡。

你需要计算拆开以后**对于每一个加法在自己后面所有乘法的权值积**，也就是这个加法的**执行次数**。

首先这个操作序列很烦，你就可以新建一个操作 $m+1$，其类型为 $3$，然后执行顺序就是输入的那一串。

那么此时所有的“序列”指的就是每个操作 $3$ 的操作执行序列了。

那么假设我们已经能够求出刚刚我说的那个东西，就可以跑一遍拓扑，初始只有操作 $m+1$ 有一个**权值**为 $1$，表示这个操作的**实际加法执行次数**，然后跑拓扑的时候传递下去。并且每次传递，是要乘上"边权"的。

这个"边权"，实际指的是：自己后面所有操作拆分后的**所有乘法操作的积**。

很容易发现这个东西是可以合并的，因为不会出现递归（自己调用自己），算当前某个点的贡献的时候，它所需调用的东西的信息都已经处理好了，可以倒着跑一遍拓扑来求出的。

信息合并的处理的话，我是维护了一个后缀积 $s$，其中 $s_0$ 就是上面所说的这个**操作拆分后所有乘法操作的积**这一项，然后因为**顺序和可重**这两个因素，所以并不是向上传递，而是向下调用。

后缀积的含义，就是前面那个式子：

$$\prod_{i=y+1}^m \prod_{j=1}^{k_i}v_{q_{i,j}}\times [typ_{q_{i,j}}=2]$$

然后因为当前在处理的时候，后面那个 $\prod$ 的值已经处理好了，可以直接写成：

$$\prod_{i=y+1}^m s_{0,q_{i}}$$


#### 注意点

因为是 vector，调用时可能会越界一位，所以在后缀积末尾赛一个 $1$ 进去，这样就不用特判了。

如果还没懂可以康康代码，自认为代码还是比较清晰的。

```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;
const int N=1e5+3;
const int K=1e6+3;
const int M=998244353;
inline int rin()
{
    int s=0;
    bool bj=false;
    char c=getchar();
    for(;(c>'9'||c<'0')&&c!='-';c=getchar());
    if(c=='-')bj=true,c=getchar();
    for(;c>='0'&&c<='9';c=getchar())s=(s<<1)+(s<<3)+(c^'0');
    if(bj)s=-s;
    return s;
}
struct milk
{
    LL ads;//实际加法执行次数
    int typ;
    int p,v;//如题意
    int d_1,d_2;//反/正跑拓扑时用到的度数
    vector<int>c;//反着跑拓扑的边
    vector<int>C;//正边
    vector<int>s;//后缀积
}t[N];
LL a[N];
int b[K];
int d[N];
int n,m,q;
inline void Work_1(int now)
{
    if(t[now].typ==2)t[now].s.push_back(t[now].v);
    if(t[now].typ==3)
    {
        int tail=0;
        LL j=1;
        for(int i=t[now].C.size()-1;i>=0;i--)b[tail++]=(j=j*t[t[now].C[i]].s[0]%M);//处理后缀积，这样可以不用写逆元
        for(int i=tail-1;i>=0;i--)t[now].s.push_back(b[i]);
    }
    t[now].s.push_back(1);
}
inline void Tp_1()
{
    int i,j;
    int head=1,tail=0;
    for(i=1;i<=m;i++)if(!t[i].d_1)d[++tail]=i;
    for(;head<=tail;)
    {
        int now=d[head++];
        Work_1(now);
        for(i=t[now].c.size()-1;i>=0;i--)
        {
            int to=t[now].c[i];
            t[to].d_1--;
            if(!t[to].d_1)d[++tail]=to;
        }
    }
    return;
}
inline void Tp_2()
{
    int i,j;
    int head=1,tail=0;
    for(i=1;i<=m;i++)if(!t[i].d_2)d[++tail]=i;
    for(;head<=tail;)
    {
        int now=d[head++];
        t[now].ads%=M;
        for(i=t[now].C.size()-1;i>=0;i--)
        {
            int to=t[now].C[i];
            t[to].d_2--;
            if(!t[to].d_2)d[++tail]=to;
            t[to].ads+=t[now].ads*t[now].s[i+1]%M;
        }
    }
    return;
}
int main()
{
    int i,j;
    for(n=rin(),i=1;i<=n;i++)a[i]=rin();
    for(m=rin(),i=1;i<=m;i++)
    {
        t[i].typ=rin();
        t[i].ads=0;
        if(t[i].typ<=1)t[i].p=rin();
        if(t[i].typ<=2)t[i].v=rin();
        if(t[i].typ==3)
        {
            for(t[i].d_1=j=rin();j>0;j--)
            {
                int x=rin();
                t[i].C.push_back(x);
                t[x].c.push_back(i);
                t[x].d_2++;
            }
        }
    }
    t[++m].typ=3;
    t[m].ads=1;
    for(t[m].d_1=q=rin();q>0;q--)
    {
        int x=rin();
        t[m].C.push_back(x);
        t[x].c.push_back(m);
        t[x].d_2++;
    }
    Tp_1();//第一遍拓扑预处理信息
    Tp_2();//第二遍拓扑处理答案
    for(i=1;i<=n;i++)a[i]=(a[i]*t[m].s[0]%M);//直接将原数组乘上所有操作拆分开后的乘法积
    for(i=1;i<=m;i++)if(t[i].typ==1)a[t[i].p]+=t[i].ads*t[i].v%M;
    for(i=1;i<=n;i++)printf("%lld ",a[i]%M);printf("\n");
    return 0;
}
```


---

## 作者：JayJessy (赞：7)

~~难道有人看题解不点赞的吗？~~
## 题目解析
我们发现题目一共有三种操作：单点加，区间乘，调用其他操作。~~我还以为是线段树~~……  
接下来我们一步一步考虑：


------------
如果没有第三种操作，那我们可以倒序遍历每个操作，维护每个元素加的次数 $cnt$，和全局乘数 $mul$。


------------
如果没有第二种操作，那我们就加一个 $0$ 号点，连向每个 $f_i$，再把每个操作三连边到它调用的函数，发现最终会形成一个 DAG（俗称大哥图）。接下来我们使用拓扑排序，算出每个函数调用的次数 $cnt_i$。


------------
我们可以发现，其实上述两种情况可以合并，只要算出 $mul$ 和 $cnt_i$ 就能求出答案。

好啦，下面是……  
## AC 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=1e5+10,mod=998244353;
queue<ll> q;
vector<ll> e1[N],e2[N];
ll n,m,Q,a[N],t[N],p[N],v[N],in[N],mul[N],cnt[N];
void get_mul() {
	for(ll i=0; i<=m; i++) {
		in[i]=e2[i].size();
		if(!in[i]) q.push(i);
	}
	while(!q.empty()) {
		ll u=q.front();
		q.pop();
		for(ll v:e1[u]) {
			mul[v]=mul[v]*mul[u]%mod;
			in[v]--;
			if(!in[v]) q.push(v);
		}
	}
}
void get_cnt() {
	for(ll i=0; i<=m; i++) {
		in[i]=e1[i].size();
		if(!in[i]) q.push(i);
	}
	while(!q.empty()) {
		ll u=q.front();
		q.pop();
		ll n_mul=1;
		for(ll i=e2[u].size()-1; i>=0; i--) {//注意这里要到序遍历，因为后面的乘操作会影响前面的，但前面的不会影响后面的
			ll v=e2[u][i];
			cnt[v]=(cnt[v]+n_mul*cnt[u])%mod;
			n_mul=n_mul*mul[v]%mod;
			in[v]--;
			if(!in[v]) q.push(v);
		}
	}
}
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	for(ll i=1; i<=n; i++) cin>>a[i];
	cin>>m;
	for(ll i=1; i<=m; i++) {
		cin>>t[i];
		mul[i]=1;
		if(t[i]==1) cin>>p[i]>>v[i];
		else if(t[i]==2) cin>>mul[i];
		else {
			ll c,g;
			cin>>c;
			while(c--) {
				cin>>g;
				e1[g].push_back(i);
				e2[i].push_back(g);
			}
		}
	}
	cin>>Q;
	mul[0]=cnt[0]=1;
	while(Q--) {
		ll f;
		cin>>f;
		e1[f].push_back(0);
		e2[0].push_back(f);
	}
	get_mul(),get_cnt();
	for(ll i=1; i<=n; i++) a[i]=a[i]*mul[0]%mod;
	for(ll i=1; i<=m; i++)
		if(t[i]==1) a[p[i]]=(a[p[i]]+cnt[i]*v[i])%mod;
	for(ll i=1; i<=n; i++) cout<<a[i]<<" ";
	return 0;
}
```
完结撒花~~

---

## 作者：Piwry (赞：7)

可惜考试时根本没时间思考这道题......

在【继续调大模拟 T1】和【开后面几题】中选择了前者 \fad。

## 解析

如果第 $2$ 类函数或第 $1$ 类函数只存在一种，那么按拓扑顺序扫一遍（用类似懒标记的思想）就能得到答案。

可以发现最后每个元素的值一定是形如 $k_r\cdot(\cdots(k_1\cdot(k_0\cdot a_i+d_0)+d_1)\cdots)+d_r$ 的形式，其中 $k_r\cdots k_1\cdot k_0\cdot a_i$ 可以很方便的算出来（不管加操作就行了）；因此我们将注意力放到后面一坨 $d_i$ 的和上。

可以想到，对于 $d_i$，我们可以用类似秦九昭的方式计算所有 $d_i$ 的贡献；而对于每层（第 $3$ 类函数，或者是**初始的询问序列**）乘上的 $k_i$，实际上就是在该函数**后调用的函数**的乘操作的贡献。

还是利用刚才懒标记的思想，但我们在下传时多记录一个权 $w$（这个 $w$ 可以通过按调用顺序倒序下传标记，并且预处理每个函数执行后“会乘多少”得到），表示**该函数调用产生的所有 $d$ 要乘上多少**。具体实现时其实还发现这东西和调用次数能用一个变量记，对于某个函数被多次调用的每次调用的权也可以直接合并；因为它们的含义都是给 $d$ 乘上某个数值，因此单纯地加在一起就行了。

## CODE

一些细节的实现可见代码，且总体来说应该不难理解。

```cpp
#include <cstdio>
#include <vector>
#include <queue>
using std::vector;
using std::queue;

const int MAXN =1e5+20, M =998244353;

/*------------------------------IO------------------------------*/

int read(){
	int x =0; char c =getchar();
	while(c < '0' || c > '9') c =getchar();
	while(c >= '0' && c <= '9') x =(x<<1)+(x<<3)+(48^c), c =getchar();
	return x;
}

void write(const int &x){
	if(x/10)
		write(x/10);
	putchar('0'+x%10);
}

/*------------------------------Topology------------------------------*/

vector<int> out[MAXN];

int in[MAXN];
int arr[MAXN];

inline void Topo(const int &m){
	queue<int> q;
	for(int i =1; i <= m; ++i)
		if(in[i] == 0)
			q.push(i);
	int tot =0;
	while(!q.empty()){
		int nw =q.front();
		q.pop();
		arr[tot++] =nw;
		for(int i =0; i < (int)out[nw].size(); ++i){
			--in[out[nw][i]];
			if(in[out[nw][i]] == 0)
				q.push(out[nw][i]);
		}
	}
}

/*------------------------------Array------------------------------*/

int typ[MAXN], P[MAXN], V[MAXN];

int query[MAXN];

/*------------------------------Work------------------------------*/

int sum_mul[MAXN];/*每个函数被调用后，会乘多少*/

void work1(const int &m){/*预处理 sum_mul*/
	for(int i =m-1; i >= 0; --i){
		int nw =arr[i];
		if(typ[nw] == 1)
			sum_mul[nw] =1;
		else if(typ[nw] == 2)
			sum_mul[nw] =V[nw];
		else{
			sum_mul[nw] =1;
			for(int j =0; j < (int)out[nw].size(); ++j)
				sum_mul[nw] =1ll*sum_mul[nw]*sum_mul[out[nw][j]]%M;
		}
	}
}

int tag[MAXN];/*若不为 0，表示该函数被调用，并给出该次调用附加的 "权值"*/

int work2(const int &totq){/*按照询问序列打标记*/
	int w =1;
	for(int i =totq-1; i >= 0; --i){
		tag[query[i]] =(tag[query[i]]+w)%M;
		w =1ll*w*sum_mul[query[i]]%M;/*注意后面询问对前面询问的权的贡献*/
	}
	return w;
}

int add[MAXN], mul[MAXN];

void work3(const int &m){/*按拓扑顺序枚举，下传标记*/
	for(int i =0; i < m; ++i){
		int nw =arr[i];
		if(tag[nw]){
			if(typ[nw] == 1)
				add[P[nw]] =(add[P[nw]]+1ll*tag[nw]*V[nw]%M)%M;
			else if(typ[nw] == 2)
				;
			else{
				int w =tag[nw];
				for(int j =(int)out[nw].size()-1; j >= 0; --j){
					tag[out[nw][j]] =(tag[out[nw][j]]+w)%M;
					w =1ll*w*sum_mul[out[nw][j]]%M;
				}
			}
		}
	}
}

/*------------------------------Main------------------------------*/

int a[MAXN];

int main(){
//	freopen("call.in", "r", stdin);
//	freopen("call.out", "w", stdout);
	int n =read();
	for(int i =1; i <= n; ++i)
		a[i] =read();
	int m =read();
	for(int i =1; i <= m; ++i){
		int t =read();
		typ[i] =t;
		if(t == 1)
			P[i] =read(), V[i] =read();
		else if(t == 2)
			V[i] =read();
		else{
			int C =read();
			for(int k =0; k < C; ++k){
				int g =read();
				out[i].push_back(g);
				++in[g];
			}
		}
	}
	int totq =read();
	for(int i =0; i < totq; ++i)
		query[i] =read();
	
	Topo(m);
	work1(m);
	int Mul =work2(totq);
	work3(m);
	
	for(int i =1; i <= n; ++i)
		write((1ll*a[i]*Mul%M+add[i])%M), putchar(' ');
}
```

---

## 作者：wenhao801 (赞：5)

## CSP-S 2020 T3 函数调用

### 题面

给你一个长度为 $n$ 的序列 $\{a_i\}$ 和 $m$ 个函数，函数的功能分为三类：

- 对序列上的某个位置单点加某个数 $V$
- 对序列整体乘某个数 $V$
- 依次执行 $C$ 个函数 $g_1, g_2, \cdots, g_C$，保证不出现递归。

现在给你一串长度为 $Q$ 的执行序列 $\{f_i\}$，求执行这些函数后 $\{a_i\}$ 的值，对 $998244353$ 取模。

$n, m, Q \le 10^5, \sum C \le 10^6,0 \le a_i, V \le 10^4$。

### 题解

为了方便，把三种函数分别称为函数 1、2、3。

基本思想：如果在线地做，无疑非常困难，因为执行一个函数可能影响到很多 $\{a_i\}$ 中的点。我们考虑离线的思路，把某次函数执行后，后面函数对它的影响考虑出来，这样就可以对每个函数分开计算、合并，而不用把所有函数粘在一块儿往前推了。

考虑对于执行序列中的每个函数，算出这个函数执行后，接下来的函数会把当前的序列**整体乘**多少，也就是把[这次执行造成的影响]整体乘多少。

于是简化问题。

首先把[序列 $\{a_i\}$ 赋初值]转化为 $n$ 次单点加。

然后，对于序列中的每个函数，我们可以把 [这个函数执行后，序列整体乘了多少] 预处理出来，记作 $\text{mul}_i$，其中：

- 对于函数 1，$\text{mul} = 1$；
- 对于函数 2，$\text{mul} = V$；
- 对于函数 3，$\text{mul} = \prod \text{mul}_{g}$。

然后做一个 $\text{mul}$ 的后缀积 $\text{suf}_i = \prod_{j = i}^Q \text{mul}_j$，表示从第 $i$ 个函数开始执行到末尾，序列会总体乘上多少。

于是现在对于执行序列中的每个函数 $f_i$，执行它造成的影响会被乘 $\text{suf}_{i+1}$。举个例子：

> 下标为 $1$ 的函数功能为整体 $\times 3$；
>
> 下标为 $2$ 的函数功能为单点 $+2$；
>
> 下标为 $3$ 的函数功能为依次执行下标为 $1$、$2$ 的函数；
>
> 执行序列为 $3\ 1\ 3\ 2\ 1$。
>
> 此时处理出的 $\text{mul}_1 = 3, \text{mul}_2 = 1, \text{mul}_3 = 3$；$\text{suf}_1 = 81, \text{suf}_2 = 27, \text{suf}_3 = 9, \text{suf}_4 = 3, \text{suf}_5 = 3$，
>
> 所以执行一次[执行序列]相当于执行 $(27 + 3)$ 倍的下标为 $3$ 的函数；$3$ 倍的下标为 $2$ 的函数；下标为 $1$ 的函数功能为整体乘，其影响已经被计算过，所以略去。

于是你就可以把每种函数要执行的倍数算出来。

如果你把函数的调用关系扔到图上，就相当于你现在有一张 DAG，一些点上面有要处理的倍数，出度不为 $0$ 的点就属于函数 3，而出度为 $0$ 的点属于函数 1 或 2。

现在我们需要做的事情是计算 3 操作的贡献。我们已经知道了每个操作要做的倍数，且操作之间不会互相影响，所以我们可以采取在图上 push 的方式，每次把 3 操作的贡献分解到它执行的每一个操作上，也就是将当前操作分解为 $cnt_1$ 倍的操作 $g_1$，$cnt_2$ 倍的操作 $g_2$，$\dots$，$cnt_C$ 倍的操作 $g_C$。

$cnt$ 的计算实际上也是一个 $\text{mul}$ 的后缀积过程。假设操作被执行了 1 倍，那么实际上有

$$\begin{aligned} cnt_1 &= \prod_{i = 2}^C\text{mul}_{g_i} \\ cnt_2 &= \prod_{i = 3}^C\text{mul}_{g_i} \\ &\vdots \\ cnt_{C-1} &= \text{mul}_{g_C}\\ cnt_C &= 1 \end{aligned}$$

挨个往下 push 就行了，最终的操作过程是一个拓扑排序。这样把更大的 3 操作转化为更小的 3 操作，最终转化为 1,2 操作，就能够直接实现了。

如果最终你来到一个函数 2，你其实不用管它，因为它造成给函数 1 的影响已经被计算过了；如果你来到了一个函数 1，那么直接在原序列的那个位置上加上 [倍数 $\times V$] 即可。

时间复杂度 $O(n+m+\sum C)$。

附：这种方法并不需要管全体乘 $0$ 的情况，因为它对前面函数造成的影响和全体乘一个其他数没有本质区别。

考场代码：

```c++
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cstdio>
#include <queue>

using namespace std;

inline int read () {
	int ret = 0, t = 1; char c = getchar();
	while ((c < '0' || c > '9') && c != '-') c = getchar();
	if (c == '-') t = -1, c = getchar();
	while (c >= '0' && c <= '9') ret = ret * 10 + c - '0', c = getchar();
	return ret * t;
}

const int mod = 998244353, MAXN = 2200200;
int n;

int m, Q;
struct ope { int type, p, v; } a[MAXN];
int f[MAXN], tmp[MAXN];

struct Edge { int nex, to; } edge[MAXN];
int head[MAXN], cnt, ind[MAXN];
void add (int u, int v) {
	edge[++cnt].to = v; edge[cnt].nex = head[u];
	head[u] = cnt; ++ind[v];
}
int mul[MAXN], now[MAXN]; bool vis[MAXN];
void dfs (int x) {
	if (vis[x]) return;
	vis[x] = true;
	for (int i = head[x]; i; i = edge[i].nex) {
		int j = edge[i].to;
		dfs(j); mul[x] = 1ll * mul[x] * mul[j] % mod;
	}
}

queue <int> que;
int ans[MAXN];

int main () {
	n = read();
	int i, j;
	for (i = 1; i <= n; i++) tmp[i] = read();
	m = read();
	for (i = 1; i <= n; i++) a[i + m].type = 1, a[i + m].p = i, a[i + m].v = tmp[i], f[i] = i + m;
	for (i = 1; i <= m; i++) {
		a[i].type = read();
		if (a[i].type == 1) a[i].p = read(), a[i].v = read();
		if (a[i].type == 2) a[i].v = read();
		if (a[i].type == 3) {
			a[i].v = read();
			for (j = 1; j <= a[i].v; j++) tmp[j] = read();
			for (j = 1; j <= a[i].v; j++) add(i, tmp[j]);
		}
	}
	int Q = read(); Q += n, m += n;
	for (i = n + 1; i <= Q; i++) f[i] = read();
	for (i = 1; i <= m; i++) {
		if (a[i].type == 2) mul[i] = a[i].v;
		else mul[i] = 1;
	}
	for (i = 1; i <= m; i++) if (a[i].type == 3 && !vis[i]) dfs(i);
	int Mul = 1;
	for (i = Q; i >= 1; i--) {
		now[f[i]] = (now[f[i]] + Mul) % mod;
		Mul = 1ll * Mul * mul[f[i]] % mod;
	}
	for (i = 1; i <= m; i++) if (!ind[i]) que.push(i);
	while (!que.empty()) {
		int x = que.front(); que.pop();
		int pre = 1;
		for (i = head[x]; i; i = edge[i].nex) {
			j = edge[i].to;
			now[j] = (now[j] + 1ll * pre * now[x] % mod) % mod;
			pre = 1ll * pre * mul[j] % mod;
			--ind[j]; if (!ind[j]) que.push(j);
		}
		if (a[x].type == 1) ans[a[x].p] = (ans[a[x].p] + 1ll * now[x] * a[x].v % mod) % mod;
	}
	for (i = 1; i <= n; i++) printf("%d ", (ans[i] + mod) % mod);
	return 0;
}
```

---

## 作者：dengjunhaodejia09 (赞：2)

总结 csp-s2020，正好写篇题解，如果想看历年 csp 总结，可看我专栏。

发现每一个加法操作我们知道他要乘多少我们就可以算答案了，考虑怎么算出要乘多少。

首先可以拓扑排序算出调用一个点要乘多少，就是子结点要乘多少的乘积，拓扑排序可轻松算出。


```cpp
  for(int i=1;i<=m;i++){
        if(ru[i]==0){
            q.push(i);
        }
    }
    while(q.size()){
        int id=q.front();
        q.pop();
        for(int i=0;i<g[id].size();i++){
            int v=g[id][i];
            ru[v]--;
            if(ru[v]==0){
                q.push(v);
            }
            Ans_cheng_yuchuli[v]*=Ans_cheng_yuchuli[id];
            Ans_cheng_yuchuli[v]%=mod;
        }
    }
```
然后对于每个加法用它后面乘的与当前函数乘的进行更新，就是用后出现的函数的乘积与拓扑排序调用过程后面的乘积计算，拓扑排序，注意乘法有结合律就行了。

```cpp
for(int i=Q;i>=1;i--){
        Ans_cheng_daan[XX[i]]+=Cheng;
        Ans_cheng_daan[XX[i]]%=mod;
        Cheng*=Ans_cheng_yuchuli[XX[i]];
        Cheng%=mod;
    }
    for(int i=1;i<=n;i++){
        a[i]=a[i]*Cheng%mod;
    }
    for(int i=1;i<=m;i++){
        if(Ru[i]==0){
            q.push(i);
        }
    }
    while(q.size()){
        int id=q.front();
        q.pop();
        int CC=1;
        for(int i=vec[id].size()-1;i>=0;i--){
            int v=vec[id][i];
            Ru[v]--;
            if(Ru[v]==0){
                q.push(v);
            }
            Ans_cheng_daan[v]+=Ans_cheng_daan[id]*CC;
            Ans_cheng_daan[v]%=mod;
            CC*=Ans_cheng_yuchuli[v];
            CC%=mod;
        }
    }
```
最后用加法统计答案即可。

完整代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int mod=998244353;
int a[200005],n;
int read(){
    int ch=getchar(),f=1,x=0;
    for(;!isdigit(ch);ch=getchar())f=(ch=='-'?-1:1);
    for(;isdigit(ch);ch=getchar())x=(x<<1)+(x<<3)+(ch^48);
    return x*f;
}
int Opt[200005],X[200005],Y[200005];
vector<int> vec[200005];
int Ans_cheng_daan[200005],ru[200005],Ru[200005],Ans_cheng_yuchuli[200005];
vector<int> g[200005];
int XX[200005];
signed main(){
    n=read();
    for(int i=1;i<=n;i++){
        a[i]=read();
    }
    int m=read();
    for(int i=1;i<=m;i++){
        Opt[i]=read();
        if(Opt[i]==1){
            X[i]=read();
            Y[i]=read();
            Ans_cheng_yuchuli[i]=1;
        }else if(Opt[i]==2){
            X[i]=read();
            Ans_cheng_yuchuli[i]=X[i];
        }else{
            X[i]=read();
            for(int j=1;j<=X[i];j++){
                int x=read();
                g[x].push_back(i);
                vec[i].push_back(x);
                ru[i]++;
                Ru[x]++;
            }
            Ans_cheng_yuchuli[i]=1;
        }
    }
    queue<int> q;
    for(int i=1;i<=m;i++){
        if(ru[i]==0){
            q.push(i);
        }
    }
    while(q.size()){
        int id=q.front();
        q.pop();
        for(int i=0;i<g[id].size();i++){
            int v=g[id][i];
            ru[v]--;
            if(ru[v]==0){
                q.push(v);
            }
            Ans_cheng_yuchuli[v]*=Ans_cheng_yuchuli[id];
            Ans_cheng_yuchuli[v]%=mod;
        }
    }
    int Q=read();
    int Cheng=1;
    for(int i=1;i<=Q;i++){
        XX[i]=read();
    }
    for(int i=Q;i>=1;i--){
        Ans_cheng_daan[XX[i]]+=Cheng;
        Ans_cheng_daan[XX[i]]%=mod;
        Cheng*=Ans_cheng_yuchuli[XX[i]];
        Cheng%=mod;
    }
    for(int i=1;i<=n;i++){
        a[i]=a[i]*Cheng%mod;
    }
    for(int i=1;i<=m;i++){
        if(Ru[i]==0){
            q.push(i);
        }
    }
    while(q.size()){
        int id=q.front();
        q.pop();
        int CC=1;
        for(int i=vec[id].size()-1;i>=0;i--){
            int v=vec[id][i];
            Ru[v]--;
            if(Ru[v]==0){
                q.push(v);
            }
            Ans_cheng_daan[v]+=Ans_cheng_daan[id]*CC;
            Ans_cheng_daan[v]%=mod;
            CC*=Ans_cheng_yuchuli[v];
            CC%=mod;
        }
    }
    for(int i=1;i<=m;i++){
        if(Ru[i]==0 && Opt[i]==1){
            a[X[i]]+=Ans_cheng_daan[i]*Y[i]%mod;
            a[X[i]]%=mod;
        }
    }
    for(int i=1;i<=n;i++){
        cout<<a[i]<<' ';
    }
    return 0;
}
```

---

## 作者：ZHR100102 (赞：2)

# 转化

这题一共有三种操作，不太好搞。而第一个函数看起来就比较可做，第三个函数显然就是让你拓扑转移，于是我们考虑第二个操作怎么处理。

当我们进行一个操作一后，假设当前节点的增量为 $ad$。此时如果再进行一次操作二，全局乘上 $mul$，那么该节点最终的增量为 $ad\times mul$。根据乘法的定义，我们可以把这个增量转化为对该节点进行 $mul$ 次操作一。

这就启发了我们考虑每个操作一会被执行多少次，显然是这个操作后面的操作的后缀积。

于是这题最关键的一步转化就做完了。

# 拓扑

因为操作三是要依次执行操作，也就是说它的子操作执行时，乘上的操作次数可能不相同。

因此，我们可以先预处理出每个操作完成之后会给全局乘上什么数，以便后面的计算。这可以通过倒着拓扑一遍处理。

接下来就要转移函数执行次数了，我们定义 $dp_i$ 表示该操作要被执行的次数。

显然，我们可以倒着枚举执行的操作，维护该操作内部的后缀积 $nmul$，进行如下转移：

$$dp_v \gets dp_v+dp_u \times nmul$$

这就保证了前面的操作一定会算上后面函数的乘积了。

那么该如何初始化呢？同样是倒序枚举它给定的操作，维护一个后缀积，处理到某个操作的初始值时，其初始值就是当前的后缀积。

最后统计答案是容易的，因为只剩下操作一了，只要我们依次累计上答案即可。注意原来的值要乘上所有操作的全局积。

时间复杂度 $O(m)$。

# 实现

这题码量较大，再次梳理一遍代码过程：
1. 倒着拓扑一遍，计算出每个函数操作之后给全局乘了多少。
2. 倒着操作所有函数调用，实时维护一个后缀乘积，然后给各函数打标记。
3. 顺着拓扑一遍，对于第三种函数，我们倒着枚举它的出边，然后进行转移，转移之后乘上对应节点的全局乘贡献。

# 代码

以上三个步骤在代码中被拆分成了三个函数来实现。

注意所有时候都要取模。

```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
#define lc (p<<1)
#define rc ((p<<1)|1)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> pi;
const ll mod=998244353;
int n,m,rd[100005],frd[100005],q,opf[100005];
ll a[100005],mul[100005],dp[100005],allmul,ad[100005];
struct node{
    int tp,p;
    ll v;
}f[100005];
vector<int>g[100005],fg[100005];
void topo1()
{
    queue<int>q;
    for(int i=1;i<=m;i++)
    {
        if(frd[i]==0)q.push(i);
        if(f[i].tp==2)mul[i]=f[i].v;
        else mul[i]=1;
    }
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        for(auto v:fg[u])
        {
            mul[v]=(mul[v]*mul[u])%mod;
            frd[v]--;
            if(frd[v]==0)q.push(v);
        }
    }
}
void init()
{
    ll nmul=1;
    for(int i=q;i>=1;i--)
    {
        dp[opf[i]]=(dp[opf[i]]+nmul)%mod;
        nmul=(nmul*mul[opf[i]])%mod;
    }
    allmul=nmul;
}
void topo2()
{
    queue<int>q;
    for(int i=1;i<=m;i++)if(rd[i]==0)q.push(i);
    ll nmul=1;
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        nmul=1;
        for(int i=g[u].size()-1;i>=0;i--)
        {
            int v=g[u][i];
            dp[v]=(dp[v]+dp[u]*nmul%mod)%mod;
            nmul=(nmul*mul[v])%mod;
            rd[v]--;
            if(rd[v]==0)q.push(v);
        }
    }
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i];
    cin>>m;
    for(int i=1;i<=m;i++)
    {
        int tp,p,v;
        cin>>tp;
        if(tp==1)
        {
            cin>>p>>v;
            f[i]={1,p,v};
        }
        else if(tp==2)
        {
            cin>>v;
            f[i]={2,0,v};
        }
        else
        {
            cin>>p;
            for(int j=1;j<=p;j++)
            {
                int to;
                cin>>to;
                g[i].push_back(to);
                rd[to]++;
                fg[to].push_back(i);
                frd[i]++;
            }
            f[i]={3,p,0};
        }
    }
    cin>>q;
    for(int i=1;i<=q;i++)cin>>opf[i];
    topo1();
    init();
    topo2();
    for(int i=1;i<=m;i++)if(f[i].tp==1)ad[f[i].p]=(ad[f[i].p]+dp[i]*f[i].v%mod)%mod;
    for(int i=1;i<=n;i++)cout<<(allmul*a[i]%mod+ad[i])%mod<<" ";
    return 0;
}
```

---

## 作者：寄风 (赞：1)

## $\texttt{call}$

### $10\texttt{pts}$

考虑没有 $3$ 操作，直接上线段树 $2$ 维护即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int a[1000005] , n , m , mod;
namespace seg{  
    int d[1000005] , add[1000005] , mul[1000005];
    #define lson (p << 1)
    #define rson (p << 1 | 1)
    #define mid ((l + r) >> 1)
    inline void pushup(int p){
        d[p] = d[lson] + d[rson];
    }
    inline void build(int p , int l , int r){
        add[p] = 0;
        mul[p] = 1;
        if(l > r) return ;
        if(l == r){
            d[p] = a[l];
            add[p] = 0;
			mul[p] = 1;
            return ;
        }
        build(lson , l , mid);
        build(rson , mid + 1 , r);
        pushup(p);
    }
    inline void pushdown(int p , int l , int r){
        (((d[lson] *= mul[p]) %= mod) += (mid - l + 1) * add[p]) %= mod;
        (((d[rson] *= mul[p]) %= mod) += (r - mid) * add[p]) %= mod;
        (mul[lson] *= mul[p]) %= mod;
        (mul[rson] *= mul[p]) %= mod;
        (((add[lson] *= mul[p]) %= mod) += add[p]) %= mod;
        (((add[rson] *= mul[p]) %= mod) += add[p]) %= mod;
        add[p] = 0;
        mul[p] = 1;
    }
    inline void updateadd(int p , int v , int s , int t , int l , int r){
        if(s <= l && r <= t){
            (d[p] += (r - l + 1) * v) %= mod;
            (add[p] += v) %= mod;
            return ;
        }
        pushdown(p , l , r);
        if(s <= mid) updateadd(lson , v , s , t , l , mid);
        if(t > mid) updateadd(rson , v , s , t , mid + 1 , r);
        pushup(p);
    }
    inline void updatemul(int p , int v , int s , int t , int l , int r){
        if(s <= l && r <= t){
            (d[p] *= v) %= mod;
            (add[p] *= v) %= mod;
            (mul[p] *= v) %= mod;
            return ;
        }
        pushdown(p , l , r);
        if(s <= mid) updatemul(lson , v , s , t , l , mid);
        if(t > mid) updatemul(rson , v , s , t , mid + 1 , r);
        pushup(p);
    }
    inline int query(int p , int s , int t , int l , int r){
        // cerr<<"JC: "<<p<<' '<<d[p]<<' '<<s<<' '<<t<<' '<<l<< ' '<<r<<'\n';
        if(s <= l && r <= t){
            return d[p];
        }
        pushdown(p , l , r);
        int ans = 0;
        if(s <= mid) (ans += query(lson , s , t , l , mid)) %= mod;
        if(t > mid) (ans += query(rson , s , t , mid + 1 , r)) %= mod;
        return ans;
    }
    inline void updateadd(int s , int t , int v){
        updateadd(1 , v , s , t , 1 , n);
    }
    inline void updatemul(int s , int t , int v){
        updatemul(1 , v , s , t , 1 , n);
    }
    inline int query(int s , int t){
        return query(1 , s , t , 1 , n);
    }
    #undef lson
    #undef rson
}
using namespace seg;
int q[1000005] , op[1000005] , p[1000005] , v[1000005];
signed main(){
    freopen("call.in" , "r" , stdin);
    freopen("call.out" , "w" , stdout);
    cin >> n;
    mod = 998244353;
    for(int i = 1;i <= n;i++){
        cin >> a[i];
    }
    cin >> m;
    build(1 , 1 , n);
    // for(int i = 1;i <= n;i++){
    //     cout << query(i , i) << ' ';
    // }
    // cout << '\n';
    for(int i = 1;i <= m;i++){
        cin >> op[i] >> p[i];
        if(op[i] == 1){
            cin >> v[i];
            // updateadd(p , p , v);
        }
        if(op[i] == 2){
            // updateadd(1 , n , v);
        }
    }
    int q;
    cin >> q;
    while(q--){
        int x;
        cin >> x;
        if(op[x] == 1){
            updateadd(p[x] , p[x] , v[x]);
        }
        else{
            updatemul(1 , n , p[x]);
        }
    }
    for(int i = 1;i <= n;i++){
        cout << query(i , i) << ' ';
    }
}
```

### $70\texttt{pts}$

暴力递归 $3$ 操作，直接执行即可。

预计得分 $70$ ~ $75\texttt{pts}$。

```cpp

#include <bits/stdc++.h>
using namespace std;
#define int long long
int a[1000005] , n , m , mod;
namespace seg{  
    int d[1000005] , add[1000005] , mul[1000005];
    #define lson (p << 1)
    #define rson (p << 1 | 1)
    #define mid ((l + r) >> 1)
    inline void pushup(int p){
        d[p] = d[lson] + d[rson];
    }
    inline void build(int p , int l , int r){
        add[p] = 0;
        mul[p] = 1;
        if(l > r) return ;
        if(l == r){
            d[p] = a[l];
            add[p] = 0;
			mul[p] = 1;
            return ;
        }
        build(lson , l , mid);
        build(rson , mid + 1 , r);
        pushup(p);
    }
    inline void pushdown(int p , int l , int r){
        (((d[lson] *= mul[p]) %= mod) += (mid - l + 1) * add[p]) %= mod;
        (((d[rson] *= mul[p]) %= mod) += (r - mid) * add[p]) %= mod;
        (mul[lson] *= mul[p]) %= mod;
        (mul[rson] *= mul[p]) %= mod;
        (((add[lson] *= mul[p]) %= mod) += add[p]) %= mod;
        (((add[rson] *= mul[p]) %= mod) += add[p]) %= mod;
        add[p] = 0;
        mul[p] = 1;
    }
    inline void updateadd(int p , int v , int s , int t , int l , int r){
        if(s <= l && r <= t){
            (d[p] += (r - l + 1) * v) %= mod;
            (add[p] += v) %= mod;
            return ;
        }
        pushdown(p , l , r);
        if(s <= mid) updateadd(lson , v , s , t , l , mid);
        if(t > mid) updateadd(rson , v , s , t , mid + 1 , r);
        pushup(p);
    }
    inline void updatemul(int p , int v , int s , int t , int l , int r){
        if(s <= l && r <= t){
            (d[p] *= v) %= mod;
            (add[p] *= v) %= mod;
            (mul[p] *= v) %= mod;
            return ;
        }
        pushdown(p , l , r);
        if(s <= mid) updatemul(lson , v , s , t , l , mid);
        if(t > mid) updatemul(rson , v , s , t , mid + 1 , r);
        pushup(p);
    }
    inline int query(int p , int s , int t , int l , int r){
        // cerr<<"JC: "<<p<<' '<<d[p]<<' '<<s<<' '<<t<<' '<<l<< ' '<<r<<'\n';
        if(s <= l && r <= t){
            return d[p];
        }
        pushdown(p , l , r);
        int ans = 0;
        if(s <= mid) (ans += query(lson , s , t , l , mid)) %= mod;
        if(t > mid) (ans += query(rson , s , t , mid + 1 , r)) %= mod;
        return ans;
    }
    inline void updateadd(int s , int t , int v){
        updateadd(1 , v , s , t , 1 , n);
    }
    inline void updatemul(int s , int t , int v){
        updatemul(1 , v , s , t , 1 , n);
    }
    inline int query(int s , int t){
        return query(1 , s , t , 1 , n);
    }
    #undef lson
    #undef rson
}
using namespace seg;
int q[1000005] , op[1000005] , p[1000005] , v[1000005];
vector<int>xx[1000005];
inline void zx(int id){
    if(op[id] == 1){
        updateadd(p[id] , p[id] , v[id]);
        return ;
    }
    if(op[id] == 2){
        updatemul(1 , n , p[id]);
        return ;
    }
    for(auto V : xx[id]){
        zx(V);
    }
}
signed main(){
    // freopen("call.in" , "r" , stdin);
    // freopen("call.out" , "w" , stdout);
    cin >> n;
    mod = 998244353;
    for(int i = 1;i <= n;i++){
        cin >> a[i];
    }
    cin >> m;
    build(1 , 1 , n);
    // for(int i = 1;i <= n;i++){
    //     cout << query(i , i) << ' ';
    // }
    // cout << '\n';
    for(int i = 1;i <= m;i++){
        cin >> op[i] >> p[i];
        if(op[i] == 1){
            cin >> v[i];
            // updateadd(p , p , v);
        }
        if(op[i] == 2){
            // updateadd(1 , n , v);
        }
        if(op[i] == 3){
            for(int j = 1 , tp;j <= p[i];j++){
                cin >> tp;
                xx[i].push_back(tp);
            }
        }
    }
    int q;
    cin >> q;
    while(q--){
        int x;
        cin >> x;
        zx(x);
    }
    for(int i = 1;i <= n;i++){
        cout << query(i , i) << ' ';
    }
}
```

### $100\texttt{pts}$

注意到一个乘法操作其实影响的只是原数值和在这个操作之前的加法操作。

考虑把乘法操作转换为加法操作。

所以你可以先在 DAG 上拓扑排序或者搜索一遍得到这个乘法系数对吧，然后你就可以拓扑排序把所有乘法操作的影响全都算出来。

那么最后直接单点执行加法操作即可。

那就做完了。

```cpp

#include <bits/stdc++.h>
using namespace std;
#define int long long
int matt = 1;
int n , m , q;
//dp[i]代表
int dat[1000005] , add[1000005] , dp[1000005] , f[10000005] , mul[10000005] , op[1000005] , p[10000005] , v[1000005] , c[1000005] , in[1000005];
constexpr int mod = 998244353;
vector <int> a[1000005];
bool vis[1000005];
inline void dfs(int now){
    vis[now] = true;
    if(op[now] == 2){
        mul[now] = v[now];
    }
    else{
        mul[now] = 1;
    }
    for(auto v : a[now]){
        if(!vis[v]) dfs(v);
        mul[now] *= mul[v];
        mul[now] %= mod;
    }
}
int cheng = 1;
inline void topo(){
    queue <int> q;
    for(int i = 1;i <= m;i++){
        if(!in[i]) q.push(i);
    }
    while(q.size()){
        int f = q.front();
        q.pop();
        if(op[f] == 1){
            add[p[f]] += dp[f] * v[f];
        }
        if(op[f] == 3){
            int tmp = dp[f];   
            reverse(a[f].begin() , a[f].end());
            for(auto v : a[f]){
                dp[v] += tmp;
                dp[v] %= mod;
                tmp *= mul[v];
                tmp %= mod;
                in[v]--;
                if(!in[v]) q.push(v);
            }
        }
    }
}
signed main(){
    cin >> n;
    for(int i = 1;i <= n;i++) cin >> dat[i];
    cin >> m;
    for(int i = 1;i <= m;i++){
        cin >> op[i];
        if(op[i] == 1) cin >> p[i] >> v[i];
        else if(op[i] == 2) cin >> v[i];
        else{
            cin >> c[i];
            for(int j = 1;j <= c[i];j++){
                int val;
                cin >> val;
                a[i].push_back(val);
                in[val]++;
            }
        }
    }
    for(int i = 1;i <= m;i++){
        if(!vis[i] && !in[i]) dfs(i);
    }
    cin >> q;
    for(int i = 1;i <= q;i++){
        cin >> f[i];
    }
    for(int i = q;i;i--){
        int now = f[i];
        if(op[now] == 1) dp[now] += cheng , dp[now] %= mod;
        if(op[now] == 2) cheng *= v[now] , cheng %= mod;
        if(op[now] == 3) dp[now] += cheng , cheng *= mul[now] , cheng %= mod;
    }
    topo();
    for(int i = 1;i <= n;i++) dat[i] *= cheng , dat[i] += add[i] , dat[i] %= mod;
    for(int i = 1;i <= n;i++) cout << dat[i] << ' ';
    return 0;
}
```

---

## 作者：weiyiqian (赞：0)

题目要求我们维护三种操作：
1. 单点加；
2. 区间乘；
3. **依次**调用函数。

容易想到函数的调用关系构成了一张图，题目数据中的特殊性质“函数调用关系构成一棵树”和 $∑C_j≤10^6$ 都给出了提示，而题目保证不会出现递归函数则说明这是一张有向无环图即 DAG。

接下来考虑如何维护操作 1 和操作 2。

先考虑操作 2，比较简单，直接把所有区间乘全部乘起来即可。具体地，建一个反向图，做一遍拓扑把所有的乘数乘到根节点上。

再考虑操作 1。我们发现具体增加的数值比较难维护，因为在图中一个出度不为 0 的点可能有多个子节点。因此我们考虑维护**加操作最终乘上的系数**，这样就不用具体到某个加操作上了。  
令 $cnt_u$ 为 $u$ 操作中加操作乘上的系数，则有 $cnt_u=cnt_u+cnt_v\times nemul$，其中 $u$ 为 $v$ 当前子节点，$nemul$ 为 $v$ 所有遍历过的子节点的乘数之积。拓扑跑一遍即可。


---

注：
1. 为了方便，我们可以用一个虚拟源点（节点 0）连向最后操作序列中的每个操作。
2. 题目要求**依次**执行函数，所以要用邻接表存图。


---

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N=1e5+10,mod=998244353;
int n,p[N],v[N],d[N],m;
LL mul[N],add[N],cnt[N],a[N];
vector<int> e1[N],e2[N];//e1为正向图，e2为反向图
void get_mul(){//乘数
    queue<int> q;
    for(int i=0;i<=m;i++){
        d[i]=e1[i].size();
        if(!d[i]) q.push(i);
    }
    while(q.size()){
        int t=q.front();
        q.pop();
        for(int j:e2[t]){
            mul[j]=mul[j]*mul[t]%mod;
            if(!--d[j]) q.push(j);
        }
    }
}
void get_cnt(){//加操作系数
    queue<int> q;
    for(int i=0;i<=m;i++){
        d[i]=e2[i].size();
        if(!d[i]) q.push(i);
    }
    while(q.size()){
        int t=q.front();
        q.pop();
        LL ne=1;
        for(int i=e1[t].size()-1;i>=0;i--){
            int j=e1[t][i];
            cnt[j]=(cnt[j]+cnt[t]*ne)%mod;
            ne=ne*mul[j]%mod;
            if(!--d[j]) q.push(j);
        }
    }
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    cin>>m;
    for(int i=1;i<=m;i++){
        mul[i]=1;
        int op;
        cin>>op;
        if(op==1) cin>>p[i]>>v[i];
        else if(op==2) cin>>mul[i];
        else{
            int c;
            cin>>c;
            while(c--){
                int g;
                cin>>g;
                e1[i].push_back(g);
                e2[g].push_back(i);
            }
        }
    }
    int q;
    cin>>q;
    while(q--){
        int x;
        cin>>x;
        e1[0].push_back(x);
        e2[x].push_back(0);
    }
    mul[0]=cnt[0]=1;
    get_mul(),get_cnt();
    for(int i=1;i<=n;i++) a[i]=a[i]*mul[0]%mod;
    for(int i=1;i<=m;i++) a[p[i]]=(a[p[i]]+cnt[i]*v[i])%mod;
    for(int i=1;i<=n;i++) cout<<a[i]<<" ";
    return 0;
}
```

---

## 作者：我梦见一片焦土 (赞：0)

# [题目传送门](https://www.luogu.com.cn/problem/P7077)

# 思路：

我们把函数看作节点，调用关系看作有向边（调用连向被调用），因为没有递归调用，所以这是一个 DAG（有向无环图）。

由于乘法是区间的，所以最终每个 $a_i$ 都可以表示为 $a_i \times k +b_i$。其中 $k$ 就是函数序列中每个函数的 $mul$ 值之积，其中 $mul_i$ 的定义如下：

- $i$ 是类型 $1$ 函数：$mul_i=1$。
- $i$ 是类型 $2$ 函数：$mul_i=v$。
- $i$ 是类型 $3$ 函数：$mul_i=\displaystyle\prod_{i \rarr j}{mul_j}$。

这样 $k$ 就计算出来了。

我们接下来要计算 $b_i$，那么需要知道每个 $1$ 类函数被执行了多少次，我们记第 $1$ 类函数 $x$ 被执行的次数为 $cnt_x$，那么 $b_i=\displaystyle\sum_{T_j=1,P_j=i}v_j*cnt_j$。

先考虑没有类型 $2$ 函数的情况，我们只需要对于调用的每个函数 $i$，将 $cnt_i \larr cnt_i+1$，然后再 DAG 上递推，把父节点的 $cnt$ 推给子节点即可。最后对于每个叶子结点（类型 $1,2$ 的函数）中类型为 $1$ 的函数 $i$，将 $cnt_i*v_i$ 加给 $p_i$ 即可。

如果有类型 $2$ 函数，我们推给子节点的 $cnt$ 可能会乘上一个系数，假设我们当前遍历到节点 $u$，有 $s$ 个子节点，对于第 $i$ 个子节点 $son_i$，$u$ 对 $son_i$ 的贡献是 $cnt_u*cur$，其中 $cur=\displaystyle\prod_{j=i+1}^s mul_i$。这是因为后面函数的“乘”操作会影响到前面的函数。所以我们可以倒序遍历子节点，累乘贡献即可。

相应地，主函数中为 $sum$ 赋初值也需要累乘贡献。

也可以这样思考：序列初始为 $0$，第 $i$ 位增加 $a_i$ 作为 $n$ 个函数额外放在其他函数前执行。这样输出就不用管 $a_i \times k$ 了，只要输出 $b_i$ 即可。

代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e6+10;
const int INF=0x3f3f3f3f;
const int mod=998244353;
int read(){
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-'){
            f=-1;
        }
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}
void write(int x){
    if(x<0){
        putchar('-');
        x=-x;
    }
    if(x>9){
        write(x/10);
    }
    putchar(x%10+'0');
    return;
}
int n,m,q,cur=1,a[N],deg[N],fun[N],p[N],v[N],ord[N],tn,mul[N],cnt[N];
vector<int> G[N];
queue<int> que;
void topo(){
	for(int i=1;i<=m;i++){
		if(!deg[i]){
            que.push(i);
        }
    }
	while(!que.empty()){
		int u=que.front();
		que.pop();
        ord[++tn]=u;
		for(int i:G[u]){
			deg[i]--;
			if(!deg[i]){
                que.push(i);
            }
		}
	}
}
void getmul(){
	for(int i=m;i>=1;i--){
		int u=ord[i];
		for(int j:G[u]){
            mul[u]=mul[u]*mul[j]%mod;
        }
	}
}
void getsum(){
	for(int i=1;i<=m;i++){
		int u=ord[i],cur=cnt[u];
		for(int j:G[u])
			cnt[j]=(cnt[j]+cur%mod)%mod,
			cur=cur*mul[j]%mod;
	}
}
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
        cin>>a[i];
    }
	cin>>m;
	for(int i=1,op;i<=m;i++){
		cin>>op;
		if(op==1){
			cin>>p[i]>>v[i];
			mul[i]=1;
		}else if(op==2){
			cin>>v[i];
			mul[i]=v[i];
		}else{
			int c,v;
			cin>>c;
			mul[i]=1;
			while(c--){
				cin>>v;
				G[i].emplace_back(v);
				deg[v]++;
			}
		}
	}
	for(int i=1;i<=m;i++){
        reverse(G[i].begin(),G[i].end());
    }
	topo();
	getmul();
	cin>>q;
	for(int i=1;i<=q;i++){
        cin>>fun[i];
    }
	for(int i=q;i>=1;i--){
		int u=fun[i];
		cnt[u]=(cnt[u]+cur)%mod;
		cur=cur*mul[u]%mod;
	}
	getsum();
	for(int i=1;i<=n;i++){
        a[i]=a[i]*cur%mod;
    }
	for(int i=1;i<=m;i++){
		if(p[i]){
            a[p[i]]=(a[p[i]]+v[i]*cnt[i]%mod)%mod;
        }
	}
	for(int i=1;i<=n;i++){
        cout<<a[i]<<" ";
    }
	return 0;
}
```
完结撒花~

---

## 作者：FatLLion (赞：0)

~~所以为什么标签里要有动态规划？~~

个人是用图和拓扑解的，一开始看到操作 3 的时候就敏锐发掘这道题应该可以用图写，结合我想了一会的线段树的思维，可以用类似线段树的那种延迟标记的思想，将操作 2 和操作 3 尽数转换为操作 1。

不难发现，操作 3 本身不会对数组进行更改，但是其调用的函数会，所以不难想到先建一个超级源点，然后把操作 3 的调用函数依次建边的思想。

这里注意一下，因为延迟标记本身的性质，一个操作 2 只会影响其之前的操作，所以为了方便，我们需要建个反图跑一遍拓扑，记录每种操作的调用次数，最后求解。

整体做法大概就是先用一个拓扑跑一遍反图得到每个操作的乘法标记，然后再跑一遍拓扑正图得到每个操作的调用次数，最后用 for 循环求解即可。

最后便是代码：

```c++
#include <bits/stdc++.h>
using namespace std;
#define ll long long
const int INF = 1e9;
const int N = 1e5+100;
const int MOD = 998244353; 

void read (int &x) {
    int f = 1;x = 0;
    char ch = getchar();
    while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar();}
    while (ch >= '0' && ch <= '9') { x = x*10+ch-'0'; ch = getchar();}
    x *= f;
}

void print (int x) {
    if (x<0) putchar('-'), x = -x;
    if (x<10) putchar(x+'0');
    else print(x/10), putchar(x%10+'0');
}

vector <int> to1[N], to2[N];

struct O {
	int type, mul, add, no, pos, cnt;
}op[N];

int n, m, q, a[N], in1[N], in2[N];

void topo1 () {
	queue <int> q;
	for (int i = 0;i <= m;i++) if (!to2[i].size()) q.push(i);
	for (int i = 0;i <= m;i++) in1[i] = to2[i].size();
	while (!q.empty()) {
		int fr = q.front();
		q.pop();
		for (int i = 0;i < to1[fr].size();i++) {
			int v = to1[fr][i];
			op[v].mul = (ll)op[v].mul*op[fr].mul%MOD;
			--in1[v];
			if (!in1[v]) q.push(v);
		}
	}
}

void topo2 () {
	queue <int> q;
	for (int i = 0;i <= m;i++) if (!to1[i].size()) q.push(i);
	for (int i = 0;i <= m;i++) in2[i] = to1[i].size();
	while (!q.empty()) {
		int fr = q.front();
		q.pop();
		int now = 1;
		for (int i = to2[fr].size();i != 0;i--) {
			int v = to2[fr][i-1];
			op[v].cnt = (op[v].cnt+(ll)op[fr].cnt*now)%MOD;
			now = (ll)now*op[v].mul%MOD;
			--in2[v];
			if (!in2[v]) q.push(v);
		}
	}
}

int main () {
	//freopen("xxx.in", "r", stdin);
	//freopen("xxx.out", "w", stdout);
	read(n);
	op[0].mul = 1;
	for (int i = 1;i <= n;i++) read(a[i]);
//	for (int i = 1;i <= n;i++) cout << a[i] << endl;
	read(m);
	for (int i = 1;i <= m;i++) {
		read(op[i].type);
		if (op[i].type == 1) read(op[i].pos), read(op[i].add), op[i].mul = 1;
		else if (op[i].type == 2) read(op[i].mul);
		else {
			op[i].mul = 1;
			int l; read(l);
			while (l--) {
				int tmp; read(tmp);
				to1[tmp].push_back(i), to2[i].push_back(tmp); // 建反图和正图，用于分别的统计和计算 
			}
		}
	} 
	read(q);
	op[0].cnt = 1;
//	op[0].mul = 1;
	while (q--) {
		int pos; read(pos);
		to1[pos].push_back(0);
		to2[0].push_back(pos);
	}
	topo1();
	topo2();
	for (int i = 1;i <= n;i++) a[i] = (ll)a[i]*op[0].mul%MOD;
	for (int i = 1;i <= m;i++) if (op[i].type == 1) a[op[i].pos] = (a[op[i].pos]+(ll)op[i].cnt*op[i].add)%MOD;
	for (int i = 1;i <= n;i++) printf("%d ", a[i]);
	return 0;
}

```

---


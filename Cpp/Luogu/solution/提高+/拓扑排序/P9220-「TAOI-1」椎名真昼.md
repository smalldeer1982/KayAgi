# 「TAOI-1」椎名真昼

## 题目背景

**请注意赛后题目添加了多测。因此请将您的赛时代码进行修改后再提交。**

## 题目描述

你正在看轻小说，突然你的家长走了进来，于是你假装在写 OI 题目。

Alice 和 Bob 正在玩一款游戏，给定一个有向图，每个点初始有一个颜色（黑或白）。

双方轮流进行操作，Alice 先手，每次操作选定一个节点，将所有从该点开始，能到达的点（包括自身）颜色翻转。如果某次操作后所有节点都变为白色，则进行该次操作的人胜利。

假如双方都采用最优策略使得自己胜利，或者如果自己无法胜利，使得对方无法胜利。

给你节点的初始状态，请你求出最终的胜者，亦或者，没有胜者。

---

定义点 $u$ 能到达点 $v$，当且仅当存在数列 $(a_1,a_2,a_3,\cdots,a_k)$，其中 $k \ge 1$，使得 $\forall i \in [1,k)$，存在有向边 $a_i \to a_{i+1}$，且 $a_1=u$，$a_k=v$。

## 说明/提示

### 数据范围

**本题采用捆绑测试**。

- Subtask 1（5 points）：$n \leq 2$，$m \leq 1$，$T=1$。
- Subtask 2（15 points）：$n \leq 5$，$m \leq 8$，$T=1$。
- Subtask 3（25 points）：保证所有点的初始颜色相同。
- Subtask 4（55 points）：无特殊限制。

对于所有测试数据，$1 \leq n \leq 10^5$，$1 \leq m \leq 2 \times 10^5$，$1 \le T \le 15$。

### 样例解释

在第一组数据中，Alice 可以先手对节点 $1$ 进行操作。操作后所有节点变为白色。

在第二组数据中，双方都没有必胜的方法，因此双方会互相拖延对方阻止对方获胜。

---

「据说如果无论如何都输出 `N` 的话，有 $45\%$ 的几率能够得到正确答案？」

「怎么可能，不会真的有人造出这么蠢的数据吧……」

## 样例 #1

### 输入

```
2
2 1
1 0
2 1
3 2
1 0 1
1 2
2 3```

### 输出

```
AN```

# 题解

## 作者：251Sec (赞：19)

如果 Alice 能够一步胜利，就判 Alice 胜利。如果 Alice 第一步无法胜利，并且 Alice 第一步不论如何操作，Bob 都能在第二步胜利，就判 Bob 胜利。否则直接判平局。

理由：若某个玩家第 $k$ 步不存在必胜方法，而他在第 $(k+2)$ 步存在必胜方法，那么另一个玩家可以在第 $(k+1)$ 步选择抵消该玩家第 $k$ 步的影响，与第 $(k+2)$ 步必胜矛盾。所以该玩家在 $(k+2)$ 步不必胜。显然由数学归纳法可知 $\forall k\geq 3$，第 $k$ 步没有必胜法。

我们可以对这个图跑 Tarjan 算法缩点。如果一个强连通分量内有异色点就可以直接判断平局。否则我们会得到一个 DAG。

### 判断 Alice 必胜局面

对 DAG 跑拓扑排序，直到遇到第一个黑点，显然 Alice 第一步只能对这个点进行操作。那么我们从这个点出发搜索，如果遇到白点，则 Alice 必不胜。如果搜索完成之后有未被访问过的黑点，则 Alice 必不胜。否则 Alice 必胜。

### 判断 Bob 必胜局面

下文将入度为 $0$ 的节点简记为“根节点”。（注意根节点可能不唯一）

若存在至少一个根节点为白色，可以发现 Bob 必胜当且仅当所有节点为白色。这是因为 Alice 先手可以操作这个根节点，Bob 后手为了把它变回白色必定会选择这个点。而这就会使得整个图回到最开始的状态。

若所有根节点均为黑色且存在至少两个根节点，那么 Bob 必胜当且仅当 $n=2$。这是因为如果 $n > 2$，Alice 可以选择两个根节点以外的一个点。Bob 显然无法一步操作把所有根节点全部变白。

若所有根节点均为黑色且只有一个根节点。那么 Alice 一定可以操作某个根节点以外的点，使得整个图不是全黑。因而 Bob 无法胜利。注意一个边界情况：如果只有两个点，一黑一白，黑点连边向白点，则 Bob 必胜。

综上，Bob 必胜的 DAG 共有三种：

1. 两个孤立黑点。

2. 两个点，一条边。其中边的方向自黑点向白点。

3. 所有点均为白点。

---

由此，本题目完成。时空复杂度均为 $O(n+m)$。

---

## 作者：InoueTakina (赞：4)

key observation：如果某个人没有必胜策略，他总是可以操作上一轮的人操作的节点。

这说明了如果先手有必胜策略，他必然在第一轮胜利。

考虑其第一轮胜利的条件，当且仅当存在一个黑色节点能够到达其他所有黑色节点，且无法到达任意一个白色节点。

注意到若一个强连通分量内有异色点，则上述条件一定不满足，缩点后在 DAG 上 dp 即可。

考虑后手，后手如果要胜利则必须在第二轮胜利。考察入度为 $0$ 的白点，若存在，当且仅当全图为白色时后手胜利。

若不存在，则当且仅当存在如下情况后手胜利：只有两点，黑点连白点；两个孤立黑点。

否则直接判平局。

---

## 作者：JustPureH2O (赞：2)

[更好的阅读体验](https://justpureh2o.cn/articles/9220)

题目地址：[P9220](https://www.luogu.com.cn/problem/P9220)

> Alice 和 Bob 正在玩一款游戏，给定一个有向图，每个点初始有一个颜色（黑或白）。
>
> 双方轮流进行操作，Alice 先手，每次操作选定一个节点，将所有从该点开始，能到达的点（包括自身）颜色翻转。如果某次操作后所有节点都变为白色，则进行该次操作的人胜利。
>
> 假如双方都采用最优策略使得自己胜利，或者如果自己无法胜利，使得对方无法胜利。
>
> 给你节点的初始状态，请你求出最终的胜者，亦或者，没有胜者。
>
> 定义点 $u$ 能到达点 $v$，当且仅当存在数列 $(a_1,a_2,a_3,\cdots,a_k)$，其中 $k \ge 1$，使得 $\forall i \in [1,k)$，存在有向边 $a_i \to a_{i+1}$，且 $a_1=u$，$a_k=v$。
>
> 对于所有测试数据，${1 \leq n \leq 10^5}$，${1 \leq m \leq 2 \times 10^5}$，${1 \le T \le 15}$。

首先，如果这个游戏无法在两步及以内结束的话，就可以直接算平局了。因为若是超过两步，认为自己会输的那一方将会想尽办法不让你赢，具体表现就是重复另一方先前的操作，让图变为另一方操作前的状态，最终陷入死循环。因此我们只需关注一步定胜负和两步定胜负的情况。

根据题目中对两点能互相到达的定义，我们很容易知道——若对某个 $\texttt{SCC}$ 中的点进行一次操作，那么同处于这个 $\texttt{SCC}$ 的其他点的颜色也都会翻转（但不止这些点的颜色被翻转）。这启发我们处理出原图中的所有强连通分量。此时不难发现，如果某个 $\texttt{SCC}$ 中存在异色点，那么无论怎么翻转，它们都不会变为统一颜色，于是这种情况可以直接判成平局；否则我们就把这个强连通分量染成内部点的颜色。

处理出所有的强连通分量后，我们再把一个强连通分量整体看作一个新点，建在新图上（即缩点），此时新图必定是一个有向无环图 $\texttt{DAG}$。那么如果在某个强连通分量中的某个点上进行操作，新图中该强连通分量的子节点一定也会受到影响从而变化颜色。至此我们便理清了操作与颜色翻转之间的规律。

---

现在来讨论必胜局面。因为游戏不会超过两轮，所以如果先手的 $\texttt{Alice}$ 想要获胜，她就必须在第一轮胜利，否则要么 $\texttt{Bob}$ 胜、要么平局。也因此，在新建的有向无环图上，有且仅能存在一个节点，使得它的子树包含新图中所有的黑色 $\texttt{SCC}$，且不包含任何白色 $\texttt{SCC}$。这样一来先手 $\texttt{Alice}$ 才能一次把这些黑色点转化成白色从而获胜。如果这个子树不完全是黑色 $\texttt{SCC}$，或者是存在多个节点满足要求，都不能保证 $\texttt{Alice}$ 获胜（但也不代表必输，因为还存在平局）。

再来看 $\texttt{Bob}$ 这边，他如果想要获胜，就只能抓住第二轮这唯一的机会。有三种可能性：

1. 全图均为白色节点。这样 $\texttt{Alice}$ 只能选择白色节点染黑，此时 $\texttt{Bob}$ 只需重复她的操作即可恢复全图到全白的状态。
2. 仅有两个孤立的黑色 $\texttt{SCC}$。此时 $\texttt{Alice}$ 选择其一染白，$\texttt{Bob}$ 仅需染白另一个即可。
3. 一个白色 $\texttt{SCC}$ 和一个黑色 $\texttt{SCC}$，并且仅有一条有向边从黑点指向白点。此时无论 $\texttt{Alice}$ 开局选择染哪个点，$\texttt{Bob}$ 总能在第二轮把全图染成白色而获胜。

其他情况即为二人平局。**注意多测清空**！

```cpp
#include <bits/stdc++.h>
#define N 100010
#define M 200010
using namespace std;

struct Edge {
    int to, ne;
} edges[M], dag[M];

int h[N], hs[N], idx = 0, idx1 = 0;
int scc_cnt = 0, dfs_cnt = 0;
int dfn[N], low[N];
int scc_id[N];
vector<int> scc[N];
stack<int> stk;
bool st[N];
bool in_stk[N];
bool color[N], scc_color[N];
int deg[N];

void add(int u, int v) {
    // 建原图
    idx++;
    edges[idx].to = v;
    edges[idx].ne = h[u];
    h[u] = idx;
}

void shrink(int u, int v) {
    // 建缩点后的图
    idx1++;
    dag[idx1].to = v;
    dag[idx1].ne = hs[u];
    hs[u] = idx1;
}

bool tarjan(int u) {
    stk.push(u);
    in_stk[u] = true;
    dfn[u] = low[u] = ++dfs_cnt;

    for (int i = h[u]; ~i; i = edges[i].ne) {
        int j = edges[i].to;
        if (!dfn[j]) {
            tarjan(j);
            low[u] = min(low[u], low[j]);
        } else if (in_stk[j]) {
            low[u] = min(low[u], dfn[j]);
        }
    }
    if (dfn[u] == low[u]) {
        scc_cnt++;
        int t;
        do {
            t = stk.top();
            stk.pop();
            in_stk[t] = false;
            scc_id[t] = scc_cnt;       // 每个点对应的 SCC 编号
            scc[scc_cnt].push_back(t); // 维护 SCC 内的节点
        } while (t != u);
        // 如果同一个 SCC 内存在异色节点，即为无解（平局）
        for (int i = 1; i < scc[scc_cnt].size(); i++) {
            if (color[scc[scc_cnt][i]] ^ color[scc[scc_cnt][i - 1]]) return false;
        }
        scc_color[scc_cnt] = color[scc[scc_cnt][0]]; // 同色，给 SCC 染色
    }
    return true;
}

void init() {
    idx = 0;
    idx1 = 0;
    while (!stk.empty()) stk.pop();
    for (int i = 1; i <= scc_cnt; i++) scc[i].clear();
    scc_cnt = dfs_cnt = 0;
    memset(st, false, sizeof st);
    memset(scc_id, 0, sizeof scc_id);
    memset(dfn, 0, sizeof dfn);
    memset(low, 0, sizeof low);
    memset(in_stk, false, sizeof in_stk);
    memset(deg, 0, sizeof deg);
    memset(h, -1, sizeof h);
    memset(hs, -1, sizeof hs);
}

int getFirstBlack() {
    // 拓扑排序找出第一个黑色 SCC
    queue<int> topo;
    for (int i = 1; i <= scc_cnt; i++) {
        if (!deg[i]) topo.push(i);
    }
    while (!topo.empty()) {
        int t = topo.front();
        topo.pop();
        if (scc_color[t]) return t;
        for (int i = hs[t]; ~i; i = dag[i].ne) {
            int j = dag[i].to;
            if (--deg[j] == 0) topo.push(j);
        }
    }
    return 0;
}

bool dfs(int u) {
    // 检查黑色子树中是否混有白色 SCC
    bool ret = scc_color[u];
    st[u] = true;
    for (int i = hs[u]; ~i; i = dag[i].ne) {
        int j = dag[i].to;
        if (st[j]) continue;
        ret &= dfs(j);
    }
    return ret;
}

bool check() {
    for (int i = 1; i <= scc_cnt; i++) {
        if (scc_color[i] && !st[i]) return false; // 子树必须包含新图中所有的黑色 SCC
    }
    return true;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    int t, m, n;
    cin >> t;
    while (t--) {
        init();
        cin >> n >> m;
        for (int i = 1; i <= n; i++) cin >> color[i];
        int u, v;
        for (int i = 1; i <= m; i++) {
            cin >> u >> v;
            add(u, v);
        }
        bool tmp = true;
        for (int i = 1; i <= n; i++) {
            if (!dfn[i]) {
                if (!tarjan(i)) {
                    tmp = false;
                    cout << 'N';
                    break;
                }
            }
        }
        if (!tmp) continue; // 同 SCC 存在异色节点，直接判无解（平局）
        bool b2w = true;
        for (int i = 1; i <= scc_cnt; i++) {
            for (int a: scc[i]) {
                for (int j = h[a]; ~j; j = edges[j].ne) {
                    int k = edges[j].to;
                    if (scc_id[a] != scc_id[k]) {
                        // 缩点建图
                        shrink(scc_id[a], scc_id[k]);
                        b2w &= !scc_color[scc_id[k]] && scc_color[scc_id[a]]; // 存在一黑一白，检查是否是黑点指向白点
                        deg[scc_id[k]]++; // 维护入度
                    }
                }
            }
        }
        int start = getFirstBlack();
        if (dfs(start) && check()) cout << 'A'; // Alice
        else if (!start && !color[1]) cout << 'B'; // Bob 情况1
        else if (scc_cnt == 2 && scc_color[1] & scc_color[2]) cout << 'B'; // Bob 情况2
        else if (scc_cnt == 2 && b2w) cout << 'B'; // Bob 情况3
        else cout << 'N';
    }
    return 0;
}
```

$\texttt{The End}$

---

## 作者：elbissoPtImaerD (赞：2)

博弈论好玩。

首先发现若分出胜负则操作次数不会超过 $2$。  
策略：若当前操作者发现无法获胜，则会选择重复对手的操作，使局态不变。

A 第一手会尝试让自己必胜，若 A 不能必胜，则尝试让 B 必败。  
然后 B 考虑自己是否必胜，若 B 不能必胜，则重复 A 操作。

我们只需考虑：对于原图，能否操作一次全白，若能，则 A 必胜，否则，若不论第一次操作如何都能在第二步使图全白，则 B 必胜，否则，必和。

观察到一次操作和点对连通性有关，尝试 SCC 缩点。

若存在一个 SCC 不同色，则必和。

然后按拓扑序考虑。

若第一个黑点能恰好覆盖所有黑点，则 A 必胜。

考察入度为 $0$ 的白点，若存在，则需要全白 B 必胜。

若不存在，则 $n\le 2$，且黑 SCC 连向白 SCC，或者两个孤 SCC 方可 B 必胜。

代码有点又臭又长。

```cpp
il void Solve()
{
  int n,m;
  rd(n),rd(m);
  ve<int>a(n);
  for(int&x:a) rd(x);
  ve<ve<int>>G(n);
  for(int u,v;m--;rd(u),rd(v),--u,--v,G[u].pb(v));
  if(sd count(all(a),0)==n) return wrt('B'),void();
  auto c=[&]
  {
    int t=0,pc=0;
    sd stack<int>S;
    ve<int>dfn(n),low(n),vis(n),c(n);
    sd function<void(int)>_T=[&](int u)
    {
      dfn[u]=low[u]=++t,S.ep(u),vis[u]|=1;
      for(int v:G[u])
        if(dfn[v]) vis[v]&&cn(low[u],dfn[v]);
        else _T(v),cn(low[u],low[v]);
      if(low[u]==dfn[u])
      {
        int _;
        do _=S.top(),c[_]=pc,vis[_]&=0,S.pop();
        while(_^u);
        ++pc;
      }
      return;
    };
    for(int i=0;i<n;++i) if(!dfn[i]) _T(i);
    return c;
  }();
  int ans=[&]
  {
    int nn=*sd max_element(all(c))+1;
    ve<ve<int>>GG(nn);
    for(int u=0;u<n;++u) for(int v:G[u]) if(c[u]^c[v]) GG[c[u]].pb(c[v]);
    ve<int>b(nn,-1);
    for(int i=0;i<n;++i)
      if(!~b[c[i]]) b[c[i]]=a[i];
      else if(b[c[i]]^a[i]) b[c[i]]=2;
    if(sd count(all(b),2)) return -1;
    if(nn<=2)
    {
      if(nn==1) return 1;
      if(GG[0].size()+GG[1].size()==0&&b[0]==1&&b[1]==1) return 0;
    }
    auto ord=[&]
    {
      sd queue<int>q;
      ve<int>d(nn);
      for(int u=0;u<nn;++u) for(int v:GG[u]) ++d[v];
      for(int u=0;u<nn;++u) if(!d[u]) q.ep(u);
      ve<int>ord;
      for(;q.size();)
      {
        int u=q.front();
        q.pop(),ord.pb(u);
        for(int v:GG[u]) if(!--d[v]) q.ep(v);
      }
      return ord;
    }();
    int rt=0;
    for(;b[ord[rt]]^1;++rt);
    ve<int>vis(nn);
    sd function<void(int)>dfs=[&](int u)
    {
      vis[u]|=1;
      for(int v:GG[u]) dfs(v);
      return;
    };
    dfs(ord[rt]);
    bool tg=true;
    for(int i=0;i<nn;++i) tg&=b[i]==vis[i];
    return tg?1:nn^2?-1:0;
  }();
  wrt(~ans?ans?'A':'B':'N');
  return;
}
```

[$\color{green}{\checkmark}$](https://www.luogu.com.cn/record/141283961)

---

## 作者：xiaoliebao1115 (赞：0)

简单博弈。

肯定先缩点，分三种情况讨论。

- 平局：一个强连通分量里面有多种颜色。
- 先手胜：显然必须一次操作，因为多次操作的胜利方法必然可以被后手阻拦，同理可得后手必须两次操作获胜。那么只需要判断对于一个最浅的黑点操作后，是否会完全变成白点。
- 后手胜：全是白点、两个单独黑点、黑连向白的点对。
- 注意剩下情况亦是平局。

复杂度 $O(n)$。

写代码注意多测清空。

---

## 作者：MSavannah (赞：0)

## Solution

注意到一个**关键性质**：最多两次操作就可以分出胜负。

如果 Alice 获胜，一定是在第一轮，如果 Bob 获胜意味着无论 Alice 第一步做什么他都会在第二轮获胜。不然两人平局。感性理解一下，如果当前玩家发现自己没有必胜策略，那么他只要重复对手的操作，一定能是局势保持不变，使对方也没法获胜。

将图缩点之后，如果同一个强连通分量中出现了两种颜色必然二人平局。


**Alice 必胜**：

从一个黑点可以到达所有黑点且不经过任何一个白点。（将缩点后得到的 DAG 拓扑排序，从遇到的第一个黑点开搜）。

**Bob 必胜**：

设入度为 $0$ 的点的集合为 $S$。

如果 $S$ 中有白点，只有当所有点都是白色的时候 Bob 赢。（考虑如果不全是白点 Alice 只需要操作这个白点，Bob 就必须操作这个点把它变回来，导致平局）。

如果 $S$ 中全是黑点，只有在缩点后还剩两个点且两个点要么都是孤立黑点，要么两点之间有边且边指向白点的时候 Bob 赢。（否则 Alice 都可以选一个不再 $S$ 集合中的点使图上节点不全黑或者陷入平局）。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define pb push_back
const int N=200010;
int T,n,m,a[N],u,v,b[N],deg[N],vis[N];
vector<int>g[N],nw[N],stk,rt;
int dfn[N],low[N],tim,scc[N],sc,wt,bl,flag;
void tarjan(int x)
{
	dfn[x]=low[x]=++tim;stk.pb(x);
	for(auto y:g[x])
	{
		if(!dfn[y]) tarjan(y),low[x]=min(low[x],low[y]);
		else if(!scc[y]) low[x]=min(low[x],dfn[y]);
	}
	if(dfn[x]==low[x])
	{
		scc[x]=++sc;
		while(stk.back()!=x) scc[stk.back()]=sc,stk.pop_back();
		stk.pop_back();
	}
}
void topo()
{
	queue<int>q;
	for(int i=1;i<=sc;i++) if(!deg[i]) q.push(i);
	while(!q.empty())
	{
		int x=q.front();q.pop();rt.pb(x);
		for(auto y:nw[x]) if(!--deg[y]) q.push(y);
	}
}
void dfs(int x)
{
	vis[x]=1;
	for(auto y:nw[x]) dfs(y);
}
void init()
{
	tim=sc=wt=bl=flag=0;rt.clear();stk.clear();
	for(int i=1;i<=n;i++) 
	g[i].clear(),nw[i].clear();
	for(int i=1;i<=n;i++)
	vis[i]=dfn[i]=low[i]=deg[i]=b[i]=scc[i]=0;
}
void solve()
{
	scanf("%d %d",&n,&m);
	int sum=0;init();
	for(int i=1;i<=n;i++) 
	{
		scanf("%d",&a[i]);
		if(!a[i]) sum++;
	}
	for(int i=1;i<=m;i++) scanf("%d %d",&u,&v),g[u].pb(v);
	if(sum==n){printf("B");return ;}
	for(int i=1;i<=n;i++) if(!dfn[i]) tarjan(i);
	for(int x=1;x<=n;x++)
	for(auto y:g[x]) 
	if(scc[x]!=scc[y]) nw[scc[x]].pb(scc[y]),deg[scc[y]]++;
	for(int i=1;i<=sc;i++) b[i]=-1;
	for(int i=1;i<=n;i++) 
	{
		if(b[scc[i]]==-1) b[scc[i]]=a[i];
		else{if(b[scc[i]]!=a[i]) {flag=1;break;}}
	}
	if(flag){printf("N");return ;}
	int tot=0;
	for(int i=1;i<=sc;i++) if(!deg[i]) tot++;
	if(sc==1){printf("A");return ;}
	if(sc==2)
	{
		if(nw[1].size()+nw[2].size()==0&&b[1]==1&&b[2]==1){printf("B");return ;}
		if((deg[1]==0&&b[1]==1&&deg[2]==1&&b[2]==0)||(deg[2]==0&&b[2]==1&&deg[1]==1&&b[1]==0)){printf("B");return ;}
	}
	topo();
	int pos=0;
	for(int i=0;i<rt.size();i++) if(b[rt[i]]==1) {pos=i;break;}
	dfs(rt[pos]);
	for(int i=1;i<=sc;i++) if(vis[i]!=b[i]) flag=1;
	if(!flag) {printf("A");return ;}
	else {printf("N");return ;} 
}
int main()
{
	scanf("%d",&T);
	while(T--){solve();}
	return 0;
}

```

---

## 作者：WhisperingWillow (赞：0)

[椎名真昼](https://www.luogu.com.cn/problem/P9220)

发现一个人若在本次操作不能获胜，则在下一次操作时仍然不能获胜，因为对方重复他的操作即可。

问题转化为：

- 若 Alice 能直接获胜，Alice 胜。
- 若 Bob 无论 Alice 怎么选都能获胜，Bob 胜。
- 否则必然平局。

考虑判断这个问题。

现将原图缩点，若一个环中存在异色点，我们直接判断平局，因为无论如何操作必然仍存在异色点。

找到任意一个黑色点对其进行操作，若可以，则 Alice 获胜，否则 Alice 无法获胜。

记入度为 $0$ 的节点为“根”，因为图中无环，则。

则若有至少一个根为白色，则 Alice 必然操作该节点导致 Bob 也必然操作该节点，所以 Bob 在此时必胜仅当所有点都是白色。

若所有根节点均为黑色且存在至少两个根，则 Bob 必胜仅当 $n=2$，因为若 $n>2$，Alice 可以选择一个非根节点使得 Bob 无法一次操作两个黑色根节点。

若所有根节点均为黑色且存在一个根，所以根与所有节点联通，则 Alice 可以操作某个根节点以外的点使得图中节点不是全黑，如果只有两个点，一黑一白，黑点连向白点，则 Bob 必胜。

Alice 的选点策略如下：
- 若出度为 $0$ 的点为黑色，则直接选择该点。
- 否则选择出度为 $0$ 的点的父亲。

这也解释了为什么有 Bob 的必胜态情况。


---


# [HNOI2004] 树的计数

## 题目描述

一个有 $n$ 个节点的树，设它的节点分别为 $v_1,v_2,\ldots,v_n$，已知第 $i$ 个节点 $v_i$ 的度数为 $d_i$，问满足这样的条件的不同的树有多少棵。


## 说明/提示

$1\le n\le 150$，保证满足条件的树不超过 $10^{17}$ 个。

## 样例 #1

### 输入

```
4                     
2 1 2 1
```

### 输出

```
2```

# 题解

## 作者：TheLostWeak (赞：53)

[在博客查看](https://www.cnblogs.com/chenxiaoran666/p/Luogu2290.html)

**大致题意：** 给定每个点的度数，让你求有多少种符合条件的无根树。

### 前言：$prufer$序列

#### 简介

$prufer$序列应该是一个比较实用的东西。

据$hl666$大佬说，一切与度数有关的树上计数问题，都可以用它以及它的性质来解决。

而听说$ZJOI$最近特别喜欢出计数题，所以有必要学一学。

#### 转化$1$：从无根树到$prefur$序列

现在，给你一棵树，我们要考虑如何把它变成$prefur$序列。

![](https://cdn.luogu.com.cn/upload/pic/54939.png)

我们需要重复进行以下操作，直至树中只剩下两个点：

- 找到一个**度数为$1$**，且**编号最小**的点。（其中编号最小保证了后面将会提到的$prufer$序列的唯一对应性，同时也方便从$prufer$序列转化回无根树）
- 把这个点的父亲节点加入序列，然后把这个点从树中删除。

然后我们就得到了一个长度为$n-2$的序列，这就是$prufer$序列。

所以它有什么实际意义呢？

~~我也不知道。~~

以上面的图为例，我们可以模拟这一过程如下：

- 找到$4$号节点，将其父结点加入序列，然后将其删去。此时序列：$\{2\}$。
- 找到$5$号节点，将其父结点加入序列，然后将其删去。此时序列：$\{2,3\}$。
- 找到$3$号节点，将其父结点加入序列，然后将其删去。此时序列：$\{2,3,1\}$。
- 找到$6$号节点，将其父结点加入序列，然后将其删去。此时序列：$\{2,3,1,2\}$。
- 找到$2$号节点，将其父结点加入序列，然后将其删去。此时序列：$\{2,3,1,2,1\}$。

所以，最后得到的$prufer$序列就是$\{2,3,1,2,1\}$。

#### 转化$2$：从$prufer$序列到无根树

还是以刚才那棵树为例吧，我们要考虑如何把它的$prefur$序列变回它本身。

我们需要重复进行以下操作，直至点集中只剩下两个点：（初始化所有点都在点集中）

- 取出$prufer$序列最前面的元素$x$。
- 取出**在点集中**的、且**当前**不在$prufer$序列中的最小元素$y$。（这恰好呼应了前面提到过的选取编号最小的节点）
- 在$x,y$之间连接一条边。（注意前面的取出相当于删除）

最后，我们在点集中剩下的两个点中连一条边。

显然这有$n-1$条边，且绝对不会形成环，因此它是一棵树，且就是原树。

以上面的序列为例，我们可以模拟这一过程如下：

- 取出$2,4$连边。此时$prufer$序列：$\{3,1,2,1\}$，点集：$\{1,2,3,5,6,7\}$。
- 取出$3,5$连边。此时$prufer$序列：$\{1,2,1\}$，点集：$\{1,2,3,6,7\}$。
- 取出$1,3$连边。此时$prufer$序列：$\{2,1\}$，点集：$\{1,2,6,7\}$。
- 取出$2,6$连边。此时$prufer$序列：$\{1\}$，点集：$\{1,2,7\}$。
- 取出$1,2$连边。此时$prufer$序列：$\{\}$，点集：$\{1,7\}$。

最后再在$1,7$间连边，就可以得到原树了。

#### $prufer$序列的性质及相关结论

讲了这么多，我们最关键的还是$prufer$序列的一些性质，以及与其有关的一些结论。（~~毕竟前面也提到过，我也不知道这东西有什么实际意义~~）

- **重要性质：$prufer$序列与无根树一一对应。**

  这应该显然吧，通过前面的介绍应该可以直接得出。

  而由这个性质，我们才能推导出后面的结论。

- **度数为$d_i$的节点会在$prufer$序列中出现$d_i-1$次**。

  当某个节点度数为$1$时，会直接被删掉，否则每少掉一个相邻的节点，它就会在序列中出现$1$次。

  因此共出现$d_i-1$次。

- **一个$n$个节点的完全图的生成树个数为$n^{n-2}$。**

  对于一个$n$个点的无根树，它的$prufer$序列长为$n-2$，而每个位置有$n$种可能性，因此可能的$prufer$序列有$n^{n-2}$种。

  又由于$prufer$序列与无根树一一对应，因此生成树个数应与$prufer$序列种树相同，即$n^{n-2}$。

- **对于给定度数为$d_{1\sim n}$的一棵无根树共有$\frac{(n-2)!}{\prod_{i=1}^n(d_i-1)!}$种情况**。

  由上面的性质可以知道，度数为$d_i$的节点会在$prufer$序列中出现$d_i-1$次。

  则就是要求出$d_i-1$个$i(1\le i\le n)$的全排列个数。

  而上面那个式子就是可重全排列公式。（即**全排列个数**除以**重复元素内部的全排列个数**）

大致就是这些。

### 解法

现在回到这道题，这显然是一道利用$prufer$序列求解的裸题。

考虑到由$prufer$序列得到的结论：**对于给定度数为$d_{1\sim n}$的一棵无根树共有$\frac{(n-2)!}{\prod_{i=1}^n(d_i-1)!}$种情况**。

套公式即可。

### 高精/质因数分解/$Python$

等等，答案小于$10^{17}$？

这看似在$long\ long$范围内，但是我们前面有除法啊！运算过程中肯定会爆$long\ long$！

然后就有$3$种做法：

- 高精。
- 质因数分解。即把每个质因数出现的次数记下来，然后除法就变成了减法。最后相乘即可。
- $Python$！~~自带高精，写这种题目的必备利器。~~

我自然是选择了$Python$。

最后提醒一句，需要**判无解**！

### 代码

```python
n=(int)(input())#读入n
if n==1:#特判n=1的情况
    x=(int)(input());#读入唯一的节点度数
    if x==0:print(1);#如果这个节点度数为0，说明只有一种解法
    else:print(0);#否则，无解
    exit();#退出程序
f=[0 for i in range(n+5)];f[0]=1;#建立阶乘数组
for i in range(1,n+1):f[i]=f[i-1]*i;#预处理阶乘
ans=f[n-2];tot=0;s=input().split();#初始化ans为(n-2)!，用tot统计度数和来判断是否无解
for i in range(n):
    x=(int)(s[i]);
    if x==0:print(0);exit();#如果存在某个点度数为0，说明图不连通，输出0
    tot+=x-1;ans//=f[x-1];#统计度数和，更新答案
if(tot==n-2):print(ans);#如果度数和为n-2，输出ans
else:print(0);#否则无解
```

---

## 作者：行吟啸九州 (赞：18)

一个古老的题，那个年代，不知道为什么，竟然没有取模，非常神奇，如果有取模的话，最优的复杂度应该是$O(n)$的。

这个题是一个简单的$prufer$序列板子题，[点这里学prufer序列](https://www.cnblogs.com/zwfymqz/p/8869956.html)。

题面不难转化成有$n\ -\ 2$个位置，要放$n$个数，数$i$要占$d[i] \ -\ 1$个位置。

这就变成了一个简单的组合数问题，$ans \ =  \prod_{i=1}^n\ C_{d[i] - 1} ^ {sum}$，其中sum为剩余的位置数。

如果取模$998244353$的话，可以直接这么$O(n)$通过，不过因为没有取模，需要预处理组合数，复杂度$O(n ^ 2)$。

需要特判几下，比如只有$n = 1$时可以存在某个点的度数为$0$，且点的度数和必须是$2n - 2$。
```cpp
#include<bits/stdc++.h> 
using namespace std;
#define N 155
#define ll long long
#define For(i, j, n) for(register int i = j ; i <= n ; ++i)
int n, sum, d[N];
ll ans = 1, C[N][N];

int main(){
	scanf("%d", &n);
	For(i, 1, n){
		scanf("%d", &d[i]), sum += d[i] - 1;
		if(!d[i] && n ^ 1) return printf("0"), 0;
	}
	if(n == 1) return printf("%d", !d[1]), 0;
	if(sum ^ (n - 2)) return printf("0"), 0;
	For(i, 0, N - 2) C[i][0] = 1; 
	For(i, 1, N - 2) For(j, 1, i) C[i][j] = C[i - 1][j - 1] + C[i - 1][j];
	For(i, 1, n) ans = ans * C[sum][d[i] - 1], sum -= d[i] - 1;
	printf("%lld", ans);
	return 0;	
}
```

---

## 作者：Timmy_ (赞：11)

# 提供一种全新的做法

其实一样，只不过用到了逆元。

本文介绍没那么详细，如果想从原理上了解做法，请移目楼上或楼下（应该没有楼下了吧）

根据 Prüfer 序列，我们可以把问题转化成这样。

给定 $n-2$ 个数，其中有 $n$ 种，每种有 $d_i-1$ 个，求排列组合方式。

很容易得出公式 $ \frac{n!}{\prod_{i = 1}^{n} \operatorname{max}(d_i-1,1)}$ (取 max 是因为防止乘 0 )

为什么呢？

因为 Prüfer 序列。

已知 Prüfer 每出现一个点代表该有一个与该节点相连的数删除（定义），所以得如果其中一个点在 Prüfer 序列里出现了 $k$ 次就代表该数有 $k+1$ 的入度（因为最后自己删除的时候不算，但多一个入度）。

关于 Prüfer 序列的定义清自行查看（抱歉我没时间写了 qwq）

全新的地方在于哪里？

众所周知，如果你再运算当中进行了取模，但最后算完之后结果是小于模数的，那答案跟没取模的会是一模一样的。

那么我们就可以找一个比答案还大的质数去当模数，直接去算硬算这个公式，其中除法用到逆元

完

# AC CODE
```cpp
#include <iostream>
using namespace std;
#define int long long
const int mod=100000000000000000+3;
const int N=2e2+5;
int n;
int d[N];
int qpow(int a,int b)
{
	if(a==0)
		return 1;
	int sum=1;
	while(b>0)
	{
		if(b&1)
			sum=(__int128)sum*a%mod;
		a=(__int128)a*a%mod;
		b/=2;
	}
	return sum;
}
int jc(int key)
{
	int sum=1;
	int i;
	for(i=1; i<=key; i++)
		sum=(__int128)sum*i%mod;
	return sum;
}
signed main()
{
	ios::sync_with_stdio(0);
	int i,j;
	cin>>n;
	for(i=1; i<=n; i++)
		cin>>d[i];
	int ans=jc(n-2);
   这部分是特判，具体请看其他题解（懒）
   //
	int temp=0,maxn=0,minx=1e9;
	for(i=1; i<=n; i++)
		temp+=d[i],maxn=max(maxn,d[i]),minx=min(minx,d[i]); 
	if(n==1)
	{
		cout<<!d[1]<<endl;
		return 0;
	}
	if(temp!=n+n-2 || (n!=1 && minx==0))
	{
		cout<<0<<endl;
		return 0;
	}
   //
	for(i=1; i<=n; i++)
		ans=(__int128)ans*qpow(jc(d[i]-1),mod-2)%mod;
	cout<<ans<<endl;
	return 0;
}

```











---

## 作者：bloodstalk (赞：4)

# Prüfer 序列
Prüfer 序列可以将一个带标号 $n$ 个节点的无根树用 $[1,n]$ 中的 $n-2$ 个整数表示。

其实就是完全图的生成树与数列之间的双射，因为这个性质，所以 Prüfer 数列常用在组合计数问题上。

Prüfer 序列是这样建立的：每次选择一个编号最小的叶节点并删掉它，然后在序列中记录它连接到的那个节点，重复 $n-2$ 次后就只剩下两个节点，就结束了。

由它建树的过程，我们可以发现一个性质:每个节点在序列中出现的次数是其度数减 $1$。

有了这个性质，我们回到本题上来。

> 给定每个点的度数，求出有多少符合条件的无根树。

设每个点的度数是 $d_i$，先给出答案：
$$
\frac{(n-2)!}{\displaystyle \prod_{i=1}^n(d_i-1)!}
$$
从 Prüfer 序列的角度来看，由 Prüfer 序列的性质 2，我们可以知道度数为 $d_i$ 的点会在 Prüfer 序列中出现 $d_i-1$ 次，那么这其实就是可重集排列数了，总共 $n-2$ 个位置，每个 $d_i$ 会出现 $d_i-1$ 次，套上可重集排列数的公式，就是答案。

还需要注意一些特判，比如 $n=1$ 或者 $\sum d_i \not= 2n-2$ 的情况，后者是铁定无解的，前者要看 $d_1$，如果是 $0$，答案就是 $1$，其余都是 $0$。

这个题可以用高精，也可以用质因数分解，化除为减。这里我选用了后者的方法，具体的地方可以看代码。

# Code
```cpp
#include<bits/stdc++.h>
//#define int long long
#define ll long long
#define next nxt
#define re register
#define il inline
const int N = 150 + 5;
using namespace std;
int max(int x,int y){return x > y ? x : y;}
int min(int x,int y){return x < y ? x : y;}

int n,cnt;
int p[N][N],du[N],tot;//p[i][j]表示i!的质因子j的次数，第二维相当于一个桶
ll ans;

il int read()
{
	int f=0,s=0;
	char ch=getchar();
	for(;!isdigit(ch);ch=getchar()) f |= (ch=='-');
	for(; isdigit(ch);ch=getchar()) s = (s<<1) + (s<<3) + (ch^48);
	return f ? -s : s;
}

il void Calc(int x)
{
	int t = x;
	cnt = 0;
	for(re int i=2;i*i<=x;i++)
	{
		if(x % i == 0) 
		{
			p[t][i] = 1;
			x /= i;
			while(x % i == 0) p[t][i]++ , x /= i; 
		}
	}
	if(x > 1) p[t][x] = 1;
}

signed main()
{
	n = read();
	if(n == 1)
	{
		du[1] = read();//特判
		if(!du[1]) cout << 1;
		else cout << 0;
		return 0;
	}
	for(re int i=1;i<=n;i++) { du[i] = read(); tot += du[i]; if(!du[i]) return printf("0"),0; }
	if(tot != 2 * n - 2) return printf("0"),0;//是否是一颗树的形态
	for(re int i=1;i<=n;i++)
	{
		Calc(i);//先算i的质因子分解
		for(re int j=1;j<=n;j++) p[i][j] += p[i-1][j];//再把(i-1)!的加上
	}
	for(re int i=1;i<=n;i++)
	{
		for(re int j=1;j<=n;j++)
			p[n-2][j] -= p[du[i]-1][j];//除法变到指数上就是减法
	}
	ans = 1;
	for(re int i=1;i<=n;i++)
	{
		if(p[n-2][i])
		{
			for(re ll j=1;j<=p[n-2][i];j++)
				ans *= i;//最后答案保证<=10^17，因此可以通过
		}
	}
	cout << ans;
	return 0;
}  
```
时间复杂度 $O(n^2)$，可以通过。





---

## 作者：WorldMachine (赞：3)

Prüfer 序列将无根树与特定序列之间建立起了双射。具体地说，每一次将编号最小的叶节点删去，并在序列末尾添加其相邻的节点编号，直到只剩下 $2$ 个节点为止，那么就将一棵具有 $n$ 个点的树转化成了长度为 $n-2$ 的、元素在 $[1,n]$ 之间的数列，并且是双射。

对于这题，每个节点 $i$ 会在序列中出现 $d_i-1$ 次，使用多重集排列公式：
$$
\dfrac{(n-2)!}{\prod\limits_{i=1}^n(d_i-1)!}
$$
为了防止计算过程中爆炸，可以使用大于 $10^{17}$ 的素数作为模数进行运算。

特判 $n=1$ 的情况，答案为 $1$。
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef __int128 lll;
const int N = 155;
const ll p = ll(1e17) + 3;
int n, d[N], sd;
ll fac[N], inv[N], ans;
ll qpow(ll a, ll b) {
	ll c = 1;
	while (b) {
		if (b & 1) c = (lll)c * a % p;
		a = (lll)a * a % p, b >>= 1;
	}
	return c;
}
int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> d[i], sd += d[i];
	if (sd != (n - 1) << 1) return cout << 0, 0;
	if (n == 1) return cout << 1, 0;
	fac[0] = 1;
	for (int i = 1; i <= n; i++) fac[i] = (lll)fac[i - 1] * i % p;
	inv[n] = qpow(fac[n], p - 2);
	for (int i = n - 1; ~i; i--) inv[i] = (lll)inv[i + 1] * (i + 1) % p;
	ans = fac[n - 2];
	for (int i = 1; i <= n; i++) ans = (lll)ans * inv[d[i] - 1] % p;
	cout << ans;
}
```

---

## 作者：spire001 (赞：2)

## P2290 题解

### 前言
Hack 说的对，但是我无脑压位高精。

### 题目分析
见度数，知 `prufer`（其实我培训的时候才知道有这种东西，简直太菜了）。

那么这道题用到的性质是一个 `prufer` 序列中一个节点编号出现的次数，是这棵树中这个节点的度数减一。

那么这个题就转换成了一个排列问题。

答案就是：
$$
\frac{(n-2)!}{\prod\limits_{i=1}^{n}(a_i-1)!}
$$

就可以做了，题目本意是不让你写高精，但如果你和我一样直接分子除以分母相乘之后的结果的话，你可能得考虑一下高精。

### ~~刺激~~的代码
```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>
#include <cassert>
#include <numeric>
#include <iomanip>
#include <climits>
#define NEED_POW
// #define FFT_MULTI
#ifdef NEED_POW
#include <cmath>
#endif

using namespace std;

typedef long long LL;

constexpr int N = 160;

using namespace std;
#ifdef FFT_MULTI

typedef struct complex
{
  static constexpr double PI = 3.141592653589793238;
  complex(const double _x = 0, const double _y = 0) : x(_x), y(_y) {}
  double x, y;
  inline static complex omega(const int k, const int n)
  {
    return complex(cos(2.0 * k * PI / (double)n), sin(2.0 * k * PI / (double)n));
  }
  inline complex operator+(const complex Q) const
  {
    return complex(x + Q.x, y + Q.y);
  }
  inline complex operator-(const complex Q) const
  {
    return complex(x - Q.x, y - Q.y);
  }
  inline complex operator*(const complex Q) const
  {
    return complex(x * Q.x - y * Q.y, x * Q.y + y * Q.x);
  }
  inline complex conj() const { return complex(x, -y); }
  friend complex conj(const complex A) { return A.conj(); }
  inline complex abs() { return hypot(x, y); }
  friend ostream &operator<<(ostream &os, const complex Q)
  {
    return os << '(' << Q.x << ", " << Q.y << ")", os;
  }
} Comp;
void FFT_base_virt_change(const int n, vector<Comp> &f, const bool inv)
{
  if (n == 1)
    return;
  const int m = n >> 1;

  vector<Comp> f1(m + 1), f2(m + 1);

  for (int i = 0; i != m; i++)
  {
    f1[i] = f[i << 1];
    f2[i] = f[i << 1 | 1];
  }

  FFT_base_virt_change(m, f1, inv);
  FFT_base_virt_change(m, f2, inv);

  const Comp _w_multi = Comp(cos(2.0 * Comp::PI / n), sin((inv ? -1.0 : 1.0) * 2.0 * Comp::PI / n));
  Comp _w0 = Comp(1, 0);

  for (int i = 0; i != m; i++, _w0 = _w0 * _w_multi)
  {
    if (!(i & 32767))
      _w0 = Comp(cos(2.0 * i * Comp::PI / n), sin((inv ? -1.0 : 1.0) * 2.0 * i * Comp::PI / n)); // 这个地方很有可能有误差, 所以需要不时重新计算减小误差

    // 从 1 到 32768 效果是显著的, 然而从 32768 到更大的数, 效果并不明显

    f[i] = f1[i] + _w0 * f2[i];
    f[i + m] = f1[i] - _w0 * f2[i];
  }

  return;
}
#endif
struct bint
{
  bint()
  {
    food = 0;
    num.clear();
  }
#ifdef FFT_MULTI
  vector<long long> num;
#else
  vector<int> num;
#endif

  bool food;
  void clear()
  {
    food = 0;
    num.clear();
  }
  void qdl()
  {
    while (!num.empty() && !num.back())
      num.pop_back();
  }

  bint(const int _num) { *this = _num; }
  bint(const long long _num) { *this = _num; }
  bint(const double _num) { *this = (long long)_num; }
  bint(const long double _num) { *this = (long long)_num; }
  bint(const char *_num)
  {
    food = false;
    _push(_num);
  }
  bint(const string _num)
  {
    food = false;
    _push(_num);
  }
  //	bint(const size_t _num) {*this = (long long)_num;}
  bint(const long _num) { *this = (int)_num; }
  bint(const unsigned long _num) { *this = (long long)_num; }
  bint(const unsigned long long _num) { *this = (long long)_num; }
  operator bool() const { return num.size(); }
  operator int() const
  {
    int f = food ? -1 : 1;
    int k = 0;
    for (auto u = (int)num.size() - 1; u >= 0; u--)
    {
      int v = num[u];
      k = ((k << 10) - (k << 4) - (k << 3)) + v;
    }
    // for(auto u:this->num) k = k * 1000 + u;
    return k * f;
  }
  operator long long() const
  {
    int f = food ? -1 : 1;
    long long k = 0;
    for (auto u = (int)num.size() - 1; u >= 0; u--)
    {
      int v = num[u];
      k = ((k << 10) - (k << 4) - (k << 3)) + v;
    }
    return k * f;
  }
  operator double() const
  {
    int f = food ? -1 : 1;
    double k = 0;
    for (auto u = (int)num.size() - 1; u >= 0; u--)
    {
      int v = num[u];
      k = k * 1000.0 + v;
    }
    return k * f;
  }
  operator long double() const
  {
    int f = food ? -1 : 1;
    long double k = 0;
    for (auto u = (int)num.size() - 1; u >= 0; u--)
    {
      int v = num[u];
      k = k * 1000.0 + v;
    }
    return k * f;
  }
  size_t len()
  {
    qdl();
    return num.size();
  }
  short operator[](const size_t &_nums) const
  {
    if (_nums > num.size() * 3)
      return false;
    return num[num.size() - _nums];
  }
  void _push(const string s)
  {
    _push(s.c_str());
    return;
  }
  void _push(const char *s)
  {
    int l = strlen(s), _begin = 0;
    while (s[_begin] == '-' && l > 1)
      _begin++, food = !food;
    while (s[_begin] == '0' && l > 1)
      _begin++;
    int i = l - 1;
    for (i = l - 1; i > _begin + 2; i -= 3)
    {
      short _num = 0;
      for (int j = i - 2; j <= i; j++)
      {
        _num = (_num << 1) + (_num << 3) + (s[j] ^ 48);
      }
      num.push_back(_num);
    }
    if (i >= 0)
    {
      short _num = 0;
      for (int j = _begin; j <= i; j++)
      {
        _num = (_num << 1) + (_num << 3) + (s[j] ^ 48);
      }
      if (_num)
        num.push_back(_num);
    }
  }
  bint jueduizhi()
  {
    bint t = *this;
    t.food = false;
    return t;
  }
  //	template <typename T>
  //	void operator = (T _num)
  //	{
  //		if(_num < 0) food = true , _num = - _num;
  //		//string s = to_string(_num);
  //		string s;
  //		while(_num)
  //		{
  //			s = (char(_num % 10 ^ 48)) + s;
  //			_num /= 10;
  //		}
  //		clear();
  //		_push(s);
  //		return ;
  //	}被废弃的int赋值

  friend istream &operator>>(istream &is, bint &_n)
  {
    _n.clear();
    string s;
    while (!cin.eof() && !isdigit(cin.peek()))
      if (cin.get() == '-')
        _n.food = !_n.food;
    is >> s;
    while (s.front() == '0' && s.size() > 1)
      s = s.substr(1);
    int l = s.size();
    int i = l - 1;
    for (i = l - 1; i > 2; i -= 3)
    {
      short _num = 0;
      for (int j = i - 2; j <= i; j++)
      {
        _num = (_num << 1) + (_num << 3) + (s[j] ^ 48);
      }
      _n.num.push_back(_num);
    }
    if (i >= 0)
    {
      short _num = 0;
      for (int j = 0; j <= i; j++)
      {
        _num = (_num << 1) + (_num << 3) + (s[j] ^ 48);
      }
      if (_num)
        _n.num.push_back(_num);
    }

    return is;
  }
  friend ostream &operator<<(ostream &os, const bint &_n)
  {
    const int l = _n.num.size();
    if (!l)
    {
      os << 0;
      return os;
    }
    if (_n.food)
      cout.put('-');
    os << _n.num[l - 1];
    for (int i = l - 2; i >= 0; i--)
      os << setw(3) << right << setfill('0') << _n.num[i];
    return os;
  }
  struct Compare_type
  {
    typedef short __cmp_return_type;
    __cmp_return_type operator()(const bint &A, const bint &B) const
    {
      if (A.food != B.food)
        return A.food ? -1 : 1;
      if (A.num.size() != B.num.size())
        return A.food ? (A.num.size() < B.num.size() ? 1 : -1) : (A.num.size() < B.num.size() ? -1 : 1);
      int siz = A.num.size();
      for (int i = siz - 1; i >= 0; i--)
      {
        if (A.num[i] != B.num[i])
          return A.food ? (A.num[i] < B.num[i] ? 1 : -1) : (A.num[i] < B.num[i] ? -1 : 1);
      }
      return 0;
    }
  } __cmp;
  bool operator<(const bint &Q) const
  {
    return __cmp(*this, Q) == -1;
  }
  bool operator<=(const bint &Q) const
  {
    return __cmp(*this, Q) <= 0;
  }
  bool operator==(const bint &Q) const
  {
    return __cmp(*this, Q) == 0;
  }
  bool operator>=(const bint &Q) const
  {
    return __cmp(*this, Q) >= 0;
  }
  bool operator>(const bint &Q) const
  {
    return __cmp(*this, Q) == 1;
  }
  bool operator!=(const bint &Q) const
  {
    return __cmp(*this, Q);
  }
  bint operator-() const
  {
    bint Q = *this;
    Q.food = !Q.food;
    return Q;
  }
  friend bool operator!(bint Q)
  {
    Q.qdl();
    return !Q.num.size();
  }
  bint operator++(int)
  {
    bint tmp = *this;
    ++(*this);
    return tmp;
  }
  bint operator++()
  {
    if (!(*this))
    {
      num.push_back(1);
    }
    else if (!food)
    {
      int l = num.size();
      num.front()++;
      for (int i = 0; i < l - 1; i++)
      {
        if (num[i] > 999)
        {
          num[i] -= 1000;
          num[i + 1]++;
        }
        else
          break;
      }
      if (num.back() > 999)
      {
        num.back() -= 1000;
        num.push_back(1);
      }
    }
    else
    {
      int l = num.size();
      num.front()--;
      for (int i = 0; i < l - 1; i++)
      {
        if (num[i] < 0)
        {
          num[i] += 1000;
          num[i + 1]--;
        }
        else
          break;
      }
    }
    qdl();
    return *this;
  }
  bint operator--()
  {
    if (!(*this))
    {
      food = 1;
      num.push_back(1);
    }
    else
    {
      food = !food;
      ++(*this);
      food = !food;
    }
    return *this;
  }
  bint operator--(int)
  {
    bint tmp = *this;
    --(*this);
    return tmp;
  }

  bint operator+(const bint &Q) const
  {
    bint ans;
    if (-(*this) == Q)
      return ans;
    int lQ = Q.num.size(), lthis = num.size();
    if (Q.food & food)
      ans.food = true;
    else if (Q.food && !food)
      return *this - (-Q);
    else if (!Q.food && food)
      return Q - -(*this);
    int lmax = max(lQ, lthis);
    ans.num.push_back(0);
    short tmp;
    for (int i = 1; i <= lmax; i++)
    {
      if (i <= lQ)
        ans.num.back() += Q.num[i - 1];
      if (i <= lthis)
        ans.num.back() += num[i - 1];
      if (ans.num.back() >= 1000)
      {
        tmp = ans.num.back();
        ans.num.back() %= 1000;
        ans.num.push_back(tmp / 1000);
      }
      else
        ans.num.push_back(0);
    }
    ans.qdl();
    return ans;
  }
  bint operator-(const bint &Q) const
  {
    bint ans;
    if (food ^ Q.food)
    {
      if (food)
        return -(-*this + Q);
      else
        return *this + (-Q);
    }
    else if (food)
      return -Q - (-*this);
    if (*this < Q)
    {
      ans = Q - *this;
      ans.food = true;
      return ans;
    }
    int lQ = Q.num.size(), lthis = num.size();
    ans.num.push_back(0);
    for (int i = 0; i < lthis; i++)
    {
      if (i < lQ)
        ans.num.back() += num[i] - Q.num[i];
      else
        ans.num.back() += num[i];
      if (ans.num.back() < 0)
      {
        int tmp = ans.num.back();
        ans.num.back() = tmp + 1000;
        ans.num.push_back(-1);
      }
      else
        ans.num.push_back(0);
    }
    ans.qdl();
    return ans;
  }
  bint operator<<(const bint &Q) const
  {
    if (!*this)
      return *this;
    bint ans;
    bint tmp = Q;
    ans = *this;
    const int _kong = 0;
    while (!ans.num.empty() && tmp--)
      ans.num.insert(ans.num.begin(), _kong);
    return ans;
  }
  bint operator<<=(const bint &Q)
  {
    if (!*this)
      return *this;
    bint tmp = Q;
    const int _kong = 0;
    while (tmp--)
      num.insert(num.begin(), _kong);
    return *this;
  }

  bint operator<<(int wei) const
  {
    if (!wei)
      return *this;
    bint k = *this;
    const int _kong = 0;
    for (int i = 1; i <= wei; i++)
      k.num.insert(k.num.begin(), _kong);
    return k;
  }
  void operator<<=(int wei)
  {
    if (!wei)
      return;
    int _kong = 0;
    for (int i = 1; i <= wei; i++)
      num.insert(num.begin(), _kong);
    return;
  }
  bint operator>>(const bint &wei) const
  {
    bint ans;
    if (!wei)
      return *this;
    if (wei >= (int)num.size())
      return ans;
    bint k = *this, tmp = wei;
    while (!k.num.empty() && tmp--)
      k.num.erase(k.num.begin());
    return k;
  }
  bint operator>>=(const bint &wei)
  {
    if (!wei)
      return *this;
    if (wei >= (int)num.size())
      return (bint)0;
    bint tmp = wei;
    while (!num.empty() && tmp--)
      num.erase(num.begin());
    return *this;
  }
  bint operator>>(int wei) const
  {
    if (!wei)
      return *this;
    bint k = *this;
    while (!k.num.empty() && wei--)
      k.num.erase(k.num.begin());
    return k;
  }
  void operator>>=(int wei)
  {
    if (!wei)
      return;
    while (!num.empty() && wei--)
      num.erase(num.begin());
    return;
  }
#ifdef FFT_MULTI

  void FFT_base_copy_to(vector<Comp> &_copy_to) const
  {
    for (size_t i = 0u; i != num.size(); i++)
      _copy_to[i] = (Comp(num[i], 0));
    // for (size_t i = num.size(); i != _copy_to.size(); i++)
    //   _copy_to[i] = (0);
    return;
  }
  void FFT_base_copy_by(const vector<Comp> &_copy_by, const size_t _len, const int _n)
  {
    for (size_t i = 0u; i != _len; i++)
      num.push_back(_copy_by[i].x / _n + 0.7);
    return tohead();
  }
  friend bint FFT_base(const bint &A, const bint &B)
  {
    const int la = (int)A.num.size(), lb = (int)B.num.size();

    const int lc = la + lb;
    bint ans;
    int _n;
    for (_n = 1; _n < lc; _n <<= 1)
      ;

    vector<Comp> _fa(_n + 1, 0), _fb(_n + 1, 0);

    A.FFT_base_copy_to(_fa);
    B.FFT_base_copy_to(_fb);

    FFT_base_virt_change(_n, _fa, false);
    FFT_base_virt_change(_n, _fb, false);

    for (int i = 0; i != _n; i++)
      _fa[i] = _fa[i] * _fb[i];

    FFT_base_virt_change(_n, _fa, true);
    return ans.FFT_base_copy_by(_fa, lc - 1, (size_t)_n), ans;
  }
#endif
  bint operator*(const bint &Q) const
  {
    int lQ = Q.num.size(), lthis = num.size();
    bint ans;
    if (Q.food ^ food)
      ans.food = true;
    if (!Q || !(*this))
      return ans;
#ifdef FFT_MULTI
    if (min(lQ, lthis) >= 5000)
    {
      return ans.food ? -FFT_base(*this, Q) : FFT_base(*this, Q);
    }
#endif
    ans.num.resize(lQ + lthis);
    if (min(lQ, lthis) > 1000) // 2 * 1024 * 1000 * 1000逼近INT_MAX
    {
      for (int i = 0; i < lQ; i++)
      {
        if (!(i & 1023))
          ans.tohead(); // x & 1023 == x % 1024
        for (int j = 0; j < lthis; j++)
          ans.num[i + j] += Q.num[i] * num[j];
      }
    }
    else
    {
      for (int i = 0; i < lQ; i++)
        for (int j = 0; j < lthis; j++)
          ans.num[i + j] += Q.num[i] * num[j];
    }
    ans.tohead();
    ans.qdl();
    return ans;
  }
  bint operator/(const bint Q) const
  {
    bool f;
    bint tmp, ans;
    if (!(*this))
      return ans;
    bint t1 = *this, t2 = Q;
    int lt2 = Q.num.size(), lt1 = num.size();
    int deltal = lt1 - lt2;
    f = food ^ Q.food;
    t1.food = t2.food = false;

    if (deltal < 0)
      return ans;
    const bint wei1 = 1;
    t2 <<= deltal;
    while (~deltal)
    {
      if (!t1 || !t2)
        break;
      int _l = 1, _r = 1000, _mid = 0;
      while (_l < _r)
      {
        _mid = (_l + _r) >> 1;
        if (t2 * _mid <= t1)
          _l = _mid + 1; // 草，一直没发现这里是小于等于
        else
          _r = _mid;
      }
      _l--;
      t1 -= _l * t2;
      ans += ((bint)_l << deltal);
      t2 >>= 1;
      deltal--;
    } // 除法的时候你压位越狠反倒越慢
    // 现在除法也非常快了,粗略的算一下,复杂度大概为O(log2(k1) * log(1000)(*this) * log2(*this)), 1 <= k1 < 1000
    return (f ? -ans : ans);
    //    	if(t1 < t2) return ans;
    //    	for(int i = lt1 - 1; i >= lt1-lt2; i--)
    //    		if(num[i] < Q.num[i - lt1 + lt2])
    //    			goto CONTINUE;
    //    	tmp = t2 << lt1 - lt2;
    //    	while(t1 >= tmp)
    //    	{
    //    		t1 = t1 - tmp;
    //    		k++;
    //		}
    //		ans = k;
    //		ans.qdl();
    //		ans = (ans << lt1 - lt2) + t1 / t2;
    //		return (f? -ans : ans);
    //		CONTINUE:;
    //		tmp = t2 << lt1 - lt2 - 1;
    //    	while(t1 >= tmp)
    //    	{
    //    		t1 = t1 - tmp;
    //    		k++;
    //		}
    //		ans = k;
    //		ans.qdl();
    //		ans = (ans << lt1 - lt2 - 1) + t1 / t2;
    //		return (f ? -ans : ans);被废弃的极慢的除法
  }
  bint operator%(const bint &Q) const
  {
    bint tmp = *this / Q;
    tmp = tmp * Q;
    return *this - tmp;
  }
  void operator+=(const bint &Q)
  {
    *this = *this + Q;
    return;
  }
  void operator-=(const bint &Q)
  {
    *this = *this - Q;
    return;
  }
  void operator*=(const bint &Q)
  {
    *this = *this * Q;
    return;
  }
  void operator/=(const bint &Q)
  {
    *this = *this / Q;
    return;
  }
  void operator%=(const bint &Q)
  {
    *this = *this % Q;
    return;
  }
  void operator=(int _num)
  {
    clear();
    if (_num < 0)
      _num = -_num, food = true;
    while (_num)
    {
      num.push_back(_num % 1000);
      _num /= 1000;
    }
    return;
  }

  void operator=(const char *_s)
  {
    return clear(), _push(_s), void();
  }

  void operator=(long long _num)
  {
    clear();
    if (_num < 0)
      _num = -_num, food = true;
    while (_num)
    {
      num.push_back(_num % 1000);
      _num /= 1000;
    }
    return;
  }
  template <typename T>
  void operator=(const T &_num)
  {
    clear();
    *this = _num;
    return;
  }
  template <typename T>
  bool operator<(const T &_num) const { return *this < (bint)_num; }
  template <typename T>
  bool operator<=(const T &_num) const { return *this <= (bint)_num; }
  template <typename T>
  bool operator>(const T &_num) const { return *this > (bint)_num; }
  template <typename T>
  bool operator>=(const T &_num) const { return *this >= (bint)_num; }
  template <typename T>
  bool operator==(const T &_num) const { return *this == (bint)_num; }
  template <typename T>
  bool operator!=(const T &_num) const { return *this != (bint)_num; }
  template <typename T>
  friend bool operator>=(const T &_num, const bint &Q) { return Q <= (bint)_num; }
  template <typename T>
  friend bool operator<=(const T &_num, const bint &Q) { return (bint)_num <= Q; }
  template <typename T>
  friend bool operator>(const T &_num, const bint &Q) { return Q < (bint)_num; }
  template <typename T>
  friend bool operator<(const T &_num, const bint &Q) { return Q > (bint)_num; }
  template <typename T>
  friend bool operator==(const T &_num, const bint &Q) { return Q == (bint)_num; }
  template <typename T>
  friend bool operator!=(const T &_num, const bint &Q) { return Q != (bint)_num; }
  template <typename T>
  bint operator+(const T &_num) const { return *this + (bint)_num; }
  template <typename T>
  bint operator+=(const T &_num) { return *this = *this + (bint)_num; }
  template <typename T>
  bint operator-(const T &_num) const { return *this - (bint)_num; }
  template <typename T>
  bint operator-=(const T &_num) { return *this = *this - (bint)_num; }
  template <typename T>
  bint operator*(const T &_num) const { return *this * (bint)_num; }
  template <typename T>
  bint operator*=(const T &_num) { return *this = *this * (bint)_num; }
  template <typename T>
  bint operator/(const T &_num) const { return *this / (bint)_num; }
  template <typename T>
  bint operator/=(const T &_num) { return *this = *this / (bint)_num; }
  template <typename T>
  bint operator%(const T &_num) const { return *this % (bint)_num; }
  template <typename T>
  bint operator%=(const T &_num) { return *this = *this % (bint)_num; }
  template <typename T>
  friend bint operator+(const T &_num, const bint &Q) { return (bint)_num + Q; }
  template <typename T>
  friend bint operator+=(T &_num, const bint &Q) { return _num = (bint)_num + Q; }
  template <typename T>
  friend bint operator-(const T &_num, const bint &Q) { return (bint)_num - Q; }
  template <typename T>
  friend bint operator-=(T &_num, const bint &Q) { return _num = (bint)_num - Q; }
  template <typename T>
  friend bint operator*(const T &_num, const bint &Q) { return (bint)_num * Q; }
  template <typename T>
  friend bint operator*=(T &_num, const bint &Q) { return _num = (bint)_num * Q; }
  template <typename T>
  friend bint operator/(const T &_num, const bint &Q) { return (bint)_num / Q; }
  template <typename T>
  friend bint operator/=(T &_num, const bint &Q) { return _num = (bint)_num / Q; }
  template <typename T>
  friend bint operator%(const T &_num, const bint &Q) { return (bint)_num % Q; }
  template <typename T>
  friend bint operator%=(T &_num, const bint &Q) { return _num = (bint)_num % Q; }
  /*--------------------extra part-------------------------*/
  void tohead() // 将进位写成函数，最好不内联.
  {
    int _siz = num.size();
    for (int i = 0; i != _siz; i++)
    {
      if (num[i] >= 1000)
      {
        if (i == _siz - 1)
        {
          num.push_back(num[i] / 1000);
          num[i] %= 1000;
          continue;
        }
        else
        {
          num[i + 1] += num[i] / 1000;
          num[i] %= 1000;
        }
      }
    }
    return;
  }
#if defined(NEED_POW) || defined(FFT_MULTI)
  bint power_base(const int base, const int index) const
  {
    bint ans = 1;
    long long con_mulnum = 1ll;
    int mul_num = log(INT_MAX) / log(base);
    for (int i = 1; i <= mul_num; i++)
      con_mulnum *= base;
    bint con_mulnum_bint = con_mulnum;
    bint base_bint = base;
    for (int i = index / mul_num; i >= 1; i--)
      ans *= con_mulnum_bint;
    for (int i = index % mul_num; i >= 1; i--)
      ans *= base_bint;
    return ans;
  }
  bint operator^(int index) const
  {
    if (*this < 0)
      return index & 1 ? -((-*this) ^ index) : (-*this ^ index);
    if (*this <= 1)
      return *this;
    if (*this <= 100 && index <= 100)
    {
      int tmp = *this;
      return power_base(tmp, index);
    }
    bint res = 1, ans = *this;
    while (index)
    {
      if (index & 1)
        res *= ans;
      index >>= 1;

      ans *= ans;
    }
    return res;
  }
#endif
};
// 新科技
bint operator"" _big(const unsigned long long _Q)
{
  return (bint)_Q;
}
bint operator"" _big(const char *_s, const std::size_t L) noexcept
{
#ifdef __ASSERT_H_
  assert(strlen(_s) == L);
#endif
  return (bint)_s;
}

/*
已经支持
#define int bint
定义方式:
bint s = 1 或 bint s = 1_big
bint s = 1ll
int num = 10;bint s = num;
bint s = "1145141919810654654654654654654654654654654654654" 或 bint s = "1145141919810654654654654654654654654654654654654"_big
读入方式:
bint s; cin >> s;
输出方式
bint s; cout << s;
*/

int n, a[N], tong[N];
bint jc[N];

vector<bint> v;

int main()
{
  cin >> n;

  int x = 0;

  for (int i = 1; i <= n; i++) 
  {
    cin >> a[i];
    // if (i == 1) a[i] = 141;
    // else if (i == 2) a[i] = 9;
    // else a[i] = 1;
    if (a[i] >= n) 
      return cout << 0 << endl, 0;
    a[i]--; x += a[i] + 1;
  }

  if (x != n * 2 - 2) // 判断合法
    return cout << 0 << endl, 0;
  if (n == 1 && a[1] == -1) // 记得特判一下
    return cout << 1 << endl, 0;

  jc[0] = 1;
  for (int i = 1; i <= n; i++) jc[i] = jc[i - 1] * i;

  bint ans = jc[n - 2];

  for (int i = 1; i <= n; i++)
    if (a[i] > 1)
      ans /= jc[a[i]];
  
  cout << ans << endl;

  return 0;
}

/*
begin: 2024年8月15日09:35:05
debug: 2024年8月15日10:30:11
finish: 2024年8月15日10:57:07
*/
```

---

## 作者：BlackHoles (赞：2)

**注**：大部分题解不详细或者代码难懂。本片题解较为详细，请耐心观看。

### 前置知识

Prüfer 序列，排列组合知识。

### 前置知识讲解

#### Prüfer 序列

对于大小为 $n$ 的一颗树，Prüfer 序列能将其转化为长度为 $n-2$ 的一个序列，其中序列元素是节点的编号，且满足性质：对于度数为 $d$ 的点，其编号在序列中出现次数为 $d-1$。

**重点知识**：树与 Prüfer 序列是一一对应的，建立着一种双射关系。这意味着树的方案数是序列的的方案数，本题因此转化为求 Prüfer 序列的方案数。

#### 排列组合公式

我们知道，对于有限多重集的排列，$S$ 是一个多重集，若它有 $k$ 个不同的元素，第 $i$ 中元素出现次数为 $n_i$，大小为 $n$，易知 $n=\sum_{i=1}^{k}n_i$。则 $S$ 的 $n$ 排列的个数为 $\frac{n!}{\prod_{i=1}^{k}n_i!}$。

### 正解

考虑求 Prüfer 序列的方案数。

根据其性质，Prüfer 序列大小为 $n-2$，其中对于每个非叶子节点 $i$，其编号出现次数为 $d_i-1$。

套用有限多重集公式，方案数即为 $\frac{(n-2)!}{\prod_{i=1}^{n}(d_i-1)!}$。

注意到求答案过程中答案可能为天文数字，又根据题目提醒答案一定不超过 $10^{17}$，因此我们取一个大于此数的素数当作模数即可，我选取的是 $10^{17}+3$ 这个大质数。

最后，因为有除法运算，我们需要根据费马小定理求出逆元，根据公式计算即可。

### 细节全讲

一棵树的节点个数为 $n$，则边数为 $n-1$，度数和应为边数的 $2$ 倍，以此特判无解。

若 $n=1$，特判答案为 $1$。

### 代码

代码中有详细注释！

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef __int128 Int; // 部分位置需要使用，防止溢出
const int N = 155;
const ll mod = 100000000000000003; // 选取的大模数 
int n, d[N], dr[N]; // 节点个数与度数
ll mul[N], invf[N]; // 阶乘和逆元
ll ans; // 答案
int sum; // 度数和
ll fastPow(ll base, ll power, ll mod) { // 快速幂
  	ll res = 1;
  	while (power) {
        if (power & 1ll)
            res = (Int)res * base % mod;
        base = (Int)base * base % mod;
        power >>= 1ll;
  	}
  	return res;
}
int main(void) {
  	cin.tie(0), cout.tie(0);
  	cin >> n;
  	for (int i = 1; i <= n; ++i)
    		cin >> d[i];
    for (int i = 1; i <= n; ++i)
    		sum += d[i];
  	if (sum != ((n-1) << 1)) { // 判断是否存在合法的树
        cout << 0;
        return 0;
  	}
  	if (n == 1) { // 特判
        cout << 1;
        return 0;
  	}
  	for (int i = 1; i <= n; ++i)
        dr[i] = d[i] - 1;
  	mul[0] = 1;
  	for (int i = 1; i < N; ++i) // 求阶乘
        mul[i] = (Int)mul[i-1] * (Int)i % (Int)mod;
  	ans = mul[n-2];
  	for (int i = 0; i < N; ++i) // 求逆元
        invf[i] = fastPow(mul[i], mod-2ll, mod);
  	for (int i = 1; i <= n; ++i) { // 根据公式计算答案
        if (!dr[i]) continue;
        ans = (Int)ans * invf[dr[i]] % mod;
  	}
  	cout << ans;
  	return 0;
}
```

---

## 作者：封禁用户 (赞：1)

首先你需要知道 Prüfer 序列是什么。

略过基本上用不到的具体过程，Prüfer 序列就是一个可以把一棵有 $n$ 个节点的无根树映射到一个长度为 $n-2$ 的序列上的东西，且树和序列之间构成双射。

简单说一下构造方式吧。

> 每次选当前剩余的所有点中，编号最小的度数为 $1$ 的点，将它连向的父节点编号插入序列末尾，并将这个点以及这条边删除。
>
> 最后整棵树只剩 $2$ 个点的时候结束。

那么就得到了一个长度为 $n-2$ 的序列。可以发现这个序列可以随便选随便排，总能找到唯一对应的一棵树。

这个题就转化成了让 $i$ 在长度为 $n-2$ 的序列中出现 $d_i - 1$ 的方案数，显然就是可重集上的全排列了，答案为：

$$
\frac {(n-2)!} {\prod _{i=1} ^n (d_i - 1)!}
$$

但是不取模，所以要预处理分解质因数。

然后你信心满满地写上去交了一分，发现 WA 了一坨。

因为需要不少特判。

- 当 $\displaystyle \sum _{i=1} ^n (d_i - 1) \ne n - 2$ 时，显然无解。

- 当存在度数为 $0$ 的点时，如果 $n \ne 1$，也无解。

然后就可以了。

```cpp
int n,d[N],c[N];

vector <int> ps,fac[N];
bitset <N> isp;
il void get_ps(int n=N-1)
{
	rep(i,2,n)
	{
		isp[i] || (ps.pb(i),fac[i]={i},1);
		for(int j=0;j<ps.size() && i*ps[j]<=n;++j)
		{
			isp[i*ps[j]]=1;
			(fac[i*ps[j]]=fac[i]).pb(ps[j]);
			if(!(i%ps[j])) break;
		}
	}
}

il void solve()
{
	read(n),_::r(d,n);
	
	if(gsum(d+1,d+n+1)-n!=n-2) return write((int)0);
	if(mnele(d+1,d+n+1)<=0 && n>1) return write((int)0);
	
	rep(i,1,n-2) for(auto j:fac[i]) ++c[j];
	rep(x,1,n) rep(i,1,d[x]-1) for(auto j:fac[i]) --c[j];
	
	int ans=1; for(auto p:ps) rep(i,1,c[p]) ans*=p;
	write(ans);
}

il void init()
{
	get_ps();
}
```

---

华风夏韵，洛水天依！

---

## 作者：Your_Name (赞：1)

### 题解
因为 Prüfer 序列与树的一一对应关系和每个点的出现次数为度数减一的性质，所以我们可以使用 Prüfer 序列把树的个数转化为序列的个数。

那么问题就是把每个度数减一个点安排进长度为 $n-2$ 的序列。

这是好办的，我们直接记录每次还剩几个位置，再用组合数放进去，最后用乘法原理计数即可。最后要注意要判断度数之和的无解和 $n=1$ 的情况。

因为数据范围很小，于是直接 $n^2$ 预处理，没有除所以不用取模。
### AC_Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N = 200;
int n, d[N], mx, ans = 1, c[N][N], sum;
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    cin >> n;
    for(int i = 0; i <= n; i ++)c[i][0] = 1;
    for(int i = 1; i <= n; i ++){
        for(int j = 1; j <= i; j ++){
            c[i][j] = c[i - 1][j - 1] + c[i - 1][j];
        }
    }
    mx = n - 2;
    for(int i = 1; i <= n; i ++){
        int x;
        cin >> x;
        sum += x;
        ans *= c[mx][x - 1];
        mx -= x - 1;
    }
    if(sum != n * 2 - 2){
        cout << 0;
        return 0;
    }
    if(n == 1){
        cout << 1;
        return 0;
    }
    cout << ans;
    return 0;
}
```
_完结撒花。_

---

## 作者：TH911 (赞：1)

> [题目传送门](https://www.luogu.com.cn/problem/P2290)

# 题意分析

对于这种关于树上度数的计数问题，一般会考虑**使用 Prüfer 序列求解**（[Prüfer 序列参见此处](https://www.luogu.com.cn/problem/P6086)）。

Prüfer 序列（Prufer 序列）的主要作用就是将无根树与序列相互转换，每一个确定的无根树都对应一个确定的 Prüfer 序列。

那么对于这道题目，假如树确定了，那么对应的 Prüfer 序列。因此满足条件的树的棵数即 **Prüfer 序列的数量**。

由 Prüfer 序列的性质：

* Prüfer 长度为 $n-2$。
* 设非叶节点 $i$ 的度数为 $d_i$，则 $i$ 在序列中出现次数为 $d_i-1$。

如果不考虑重复的 Prüfer 序列，则总数量即对于 $n-2$ 个元素进行全排列，即 $(n-2)!$。

但是由于 Prüfer 序列中会有重复的元素，因此要去除一些序列。重复的次数即 $\prod\limits_{i=1}^n(d_i-1)!$。因为每一个重复节点出现之后，交换这些重复节点是没有影响的。单个节点 $i$ 的重复数量是 $(d_i-1)!$，乘起来即可。

故，答案为：
$$
\dfrac{(n-2)!}{\prod\limits_{i=1}^n(d_i-1)!}
$$

## 小技巧

可以发现，这个题目**不需要取模**。

这也就意味着，无法再预处理阶乘快速计算。

有一种方法是将 $1\sim n-2$ 放入数组存起来，每次除 $(d_i-1)!$ 时就 $1\sim d_i-1$ 找到其倍数暴力除。最后再将数组中剩余的数乘起来即可。

但是有没有更好的方法呢？

肯定是有的。因为答案不超过 $10^{17}$，因此我们可以找一个大于 $10^{17}$ 的质数 $P$ 作为**模数**；但是这样**对于答案没有任何影响**。

而有了 $P$，我们也就可以预处理阶乘、逆元了，从而可以快速计算。

寻找 $P$ 的话，可以写 Miller-Rabin 素性判断，但是没必要。可以直接写 $\mathcal O\left(\sqrt n\right)$ 的质数判断，因为在 $10^{18}$ 附近就有一个质数 $10^{18}+3$。（事实上，$10^{17}+3$ 也是的，但是我想从 $10^{18}$ 开始找）

对于这种常用特殊质数，个人建议还是背一点比较好。（比如 $10^9+7,10^9+9,998244353$）

# AC 代码

```cpp
//#include<bits/stdc++.h>
#include<algorithm> 
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
typedef __int128 lll;
typedef long long ll;
constexpr const ll N=150,P=1000000000000000003ll;
int n,d[N+1];
ll fact[N+1];
template<typename T>
T qpow(T base,T n){ 
	T ans=1;
	while(n){
		if(n&1){
			ans=(lll)ans*base%P;
		}
		base=(lll)base*base%P;
		n>>=1;
	}
	return ans;
}
ll C(int n,int m){
	if(n<0||m<0||n<m){
		return 0;
	} 
	return (__int128)fact[n]*qpow((lll)fact[n]*fact[n-m]%P,(lll)P-2)%P;
}
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	
	fact[0]=1;
	for(int i=1;i<=N;i++){
		fact[i]=(__int128)i*fact[i-1]%P;
	}
	cin>>n;
	int sum=0;
	for(int i=1;i<=n;i++){
		cin>>d[i];
		sum+=d[i];
	}
	if(sum!=2*n-2){
		cout<<0<<'\n';
		return 0;
	}
	if(n==1){
		cout<<!d[1]<<'\n'; 
		return 0;
	}
	ll ans=fact[n-2];
	for(int i=1;i<=n;i++){
		ans=(__int128)ans*qpow(fact[d[i]-1],P-2)%P;
	}
	cout<<ans<<'\n';
	
	cout.flush(); 
	
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```

---

## 作者：strcmp (赞：1)

做这道题，你只需要一个知识：**Prüfer 序列中出现了 $d_i - 1$ 次的结点，度数为 $d_i$。**

问题转化为，有多少个长度为 $n - 2$ 的序列，满足数字 $i$ 的出现次数是 $d_i - 1$。

这个问题大概是小学组合计数的难度，考虑数字 $1$ 有 $\binom{n - 2}{d_1 - 1}$ 种取法，数字 $2$ 在数字 $1$ 的基础上有 $\binom{n - 2 - d_1 + 1}{d_2 - 1}$ 种取法。递归下去，令 $s_k \leftarrow \sum\limits_{i = 1}^{k} d_i - 1$。根据乘法原理，有答案为 $\prod\limits_{i = 1}^{n} \binom{n - 2 - s_{i - 1}}{d_i - 1}$。

其实就是多重集排列公式。

时间复杂度 $\Theta(n^2)$，瓶颈在求组合数。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long int ll;
using pll = pair<ll, ll>;
const int maxn = 4e5 + 10;
const ll inf = 1145141919810520LL;
const ll mod = 998244353LL; 
int n; ll d[maxn], s[maxn], c[205][205];
int main() {
	scanf("%d", &n); int cd = 0, sum = 0;
	for (int i = 1; i <= n; i++) scanf("%lld", &d[i]), sum += d[i], cd |= !d[i];
	if (n == 1) printf("%d\n", (int)!d[1]), exit(0);
	else if (cd == 1 && n > 1) puts("0"), exit(0);
	else if (sum != 2 * n - 2) puts("0"), exit(0);
	for (int i = 0; i <= n - 2; i++) c[i][0] = 1;
	for (int i = 1; i <= n - 2; i++) {
		for (int j = 1; j <= i; j++) {
			c[i][j] = c[i - 1][j] + c[i - 1][j - 1];
		}
	}
	ll ans = 1;
	for (int i = 1; i <= n; i++) {
		s[i] = s[i - 1] + d[i] - 1;
		if (n - 2 - s[i - 1] < 0 || d[i] - 1 < 0 || n - s[i - 1] > n || d[i] - 1 > n) { ans = 0; break; }
		ans = ans * c[n - 2 - s[i - 1]][d[i] - 1];
	}
	printf("%lld\n", ans);
	return 0;
}
```


---

## 作者：wxzzzz (赞：1)

### 思路

前置：[prufer 序列](https://www.cnblogs.com/wangxuzhou-blog/p/advanced-graph-theory.html#prufer%E5%BA%8F%E5%88%97)

因为 prufer 序列和树成一一映射关系，因此 prufer 序列排列数相当于树的个数。

又因为 prufer 的性质：

> 一个节点在其所在树的 prufer 序列中的出现次数为它在原树上的度数减 $1$。

因此题目就转化为了：数 $i$ 有 $d_i$ 个，求能组成的不同排列数。

即多重集的排列数公式：$\dfrac{(n-2)!}{\displaystyle\prod_{i=1}^n(d_i-1)!}$。

但是朴素计算 $(n-2)!$ 会超出 long long 的范围。

可以想到分解质因数，统计每个质因数 $p_i$ 的计算次数 $cnt_{p_i}$。

答案乘 $p_i$ 相当于 $cnt_{p_i}\gets cnt_{p_i}+1$，答案除 $p_i$ 相当于 $cnt_{p_i}\gets cnt_{p_i}-1$。

最终答案即为 $\displaystyle\prod_{i\in P}i^{cnt_i}$。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, sum, cntp, p[155], cnt[155];
long long ans;
bool flag[155];
vector<int> clac(int x) {
    vector<int> ret;

    for (int i = 1; i <= cntp; i++) {
        while (!(x % p[i])) {
            ret.push_back(p[i]);
            x /= p[i];
        }
    }

    return ret;
}
int main() {
    cin >> n;
    flag[1] = 1;

    for (int i = 2; i <= n; i++)
        for (int j = 2; j <= n / i; j++)
            flag[i * j] = 1;

    for (int i = 1; i <= n; i++)
        if (!flag[i])
            p[++cntp] = i;

    for (int i = 2; i <= n - 2; i++) {
        vector<int> fac = clac(i);

        for (auto j : fac)
            cnt[j]++;
    }

    for (int i = 1, d; i <= n; i++) {
        cin >> d, sum += d;

        for (int j = 2; j < d; j++) {
            vector<int> fac = clac(j);

            for (auto k : fac)
                cnt[k]--;
        }

        if (d > n - 1) {
            cout << '0';
            return 0;
        }
    }

    if (sum != n * 2 - 2) {
        cout << '0';
        return 0;
    }

    ans = 1;

    for (int i = 1; i <= cntp; i++)
        for (int j = 1; j <= cnt[p[i]]; j++)
            ans *= p[i];

    cout << ans;
    return 0;
}
```

---

## 作者：Fenki_lo (赞：0)

[前置芝士：prufer 序列](https://oiwiki.org/graph/prufer/)

[P2290 [HNOI2004] 树的计数 ](https://www.luogu.com.cn/problem/P2290)
# 题意
有一棵 $n$ 个节点的树，钦定第 $i$ 个节点的度数为 $d_i$，求这样的树共有几棵。

答案在 $10^{17}$ 之内。
# 思路
钦定了每个节点的度数，实际上就是钦定了每个数在 prufer 序列中出现的次数，因此使用多重排列计算答案几棵。**注意，是排列为不是组合，这是因为尽管在 prufer 序列内相同的数，它们代表的节点是完全不同的。**

因此答案为

$$\displaystyle
\frac{(n-2)!}{\prod_{i=1}^{n}(d_i-1)!}
$$

还有两种无解情况，记得要特判：

- 总度数不等于 $2n-2$。

- 有节点度数为 $0$ 且总节点数不为 $1$。
# 代码
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll N=1e6+90;
ll n,a[N];
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n;
	int p=0;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		p+=a[i];
		if(a[i]==0&&n!=1){
			cout<<0;
			return 0;
		}
	}
	if(p!=n*2-2) cout<<0;
	else{
		ll ans=1,t=0;
		for(int i=1;i<=n;i++){
			for(ll j=1;j<a[i];j++){
				t++;
				ans=ans*t/j;
			}
		}
		cout<<ans;
	}
	return 0;
}
```

---

## 作者：xwh_hh (赞：0)

前置知识：Prüfer 序列（[OI Wiki 链接](https://oi-wiki.org/graph/prufer/)，也可参照其他题解）。  
Prüfer 序列生成方式：对于一棵无根树，每次取出编号最小的叶节点加入序列，并从原树中删除，直到原树只剩下 $2$ 个节点。  
通过 Prüfer 序列还原原树：类似 Prüfer 序列生成方式，此处留给读者自行思考。  
**Prüfer 序列与无根树是一一对应的！**  
从 Prüfer 序列中，我们不难得到一个结论：若树上某节点 $u$ 在 Prüfer 序列中出现了 $i$ 次，则 $u$ 的度数必为 $i+1$，反之亦然（证明留给读者，可从什么时候 $u$ 会被加入 Prüfer 序列，为什么要 $+1$ 方面考虑）。  
于是问题转化为：给定一个序列中个元素出现次数，求序列的数量，这不就是多重组合数问题吗？  
别高兴太早，由于这题没有取模，预处理阶乘会爆 `long  long`，甚至会爆掉 `__int128`。不过没关系，由于答案不超过 $10^{17}$，可以认为是求答案对一个大于 $10^{17}$ 的数取模的结果，此处我选的数为 $2691416224710346279$（是一个质数），然后用 `__int128` 防止乘法溢出即可。  
注：由于 Prüfer 序列 是针对点数大于 $1$ 的树定义的，故须特判 $n=1$。  
还要记得判无解（度数和应为 $2n-2$，点数大于 $1$ 的树不应有节点度数为零）！  
代码如下：  
```cpp
#include<bits/stdc++.h>
using namespace std;
__int128 s[155],n; 
__int128 d[155];
inline __int128 readint(){
	__int128 ans=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-') f=-f;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		ans=(ans<<3)+(ans<<1)+c-48;
		c=getchar();
	}
	return ans*f;
} 
#define mod 2691416224710346279
__int128 pw(__int128 a,__int128 b=mod-2,__int128 c=mod){//逆元 
	__int128 res=1,now=a;
	while(b){
		if(b&1) res=res*now%mod;
		b>>=1;
		now=now*now%mod;
	}
	return res;
}
signed main(){
	d[0]=1;
	for(__int128 i=1;i<=150;i++) d[i]=d[i-1]*i%mod;//预处理阶乘 
	n=readint();
	if(n==1){//特判
		if(readint()==0) cout<<"1\n";  else cout<<"0\n";
		return 0;
	}
	__int128 sum=0;
	for(__int128 i=1;i<=n;i++){
		s[i]=readint();
		if(!s[i]) {
			cout<<"0\n"; return 0;
		}
		sum+=s[i]; s[i]--;
	}
	if(sum!=n*2-2) {
		cout<<"0\n"; return 0;
	}
	__int128 tot=d[n-2];
	for(__int128 i=1;i<=n;i++){
		tot*=pw(d[s[i]]); tot%=mod;
	}
	cout<<(long long)tot;
	return 0;
}
```

---

## 作者：Zhangikun (赞：0)

## 前置知识：
prufer 序列。

## 思路：
我们都知道，prufer 序列有以下性质：

1. 可以与树互相转化。

2. 对于 $n$ 个点的树，转化成 prufer 序列后序列里有 $n-2$ 个元素。

3. 对于树上一个点，它在 prufer序列中的出现次数是它在树中的度数减去 $1$。

根据这些性质，我们可以转换问题：

构造一棵树转化为构造一个 prufer 序列。

那么就成了多重集的全排列问题：$n-2$ 个元素，$n$ 种元素，第 $i$ 种元素有 $deg_i-1$ 个（$deg_i$ 为点 $i$ 的度数）。

套公式就是：

$${(n-2)!\over (deg_1-1)!\times (deg_2-1)!\times...\times (deg_n-1)!}$$

但是我们正常算可能会溢出，所以我们用一个模数（$10^{17}+3$ 就可以）再用乘法逆元即可。因为总答案不会超过 $10^{17}$，所以不会影响正确性。

## 代码：
```cpp
#include<bits/stdc++.h>
#define int __int128//因为1e17*1e17爆long long，所以用它
using namespace std;
const int cxk=155,mod=100000000000000003ll;
int fastpow(int x,int y)
{
    int lcq=1,pw=x%mod;
    for(int i=0;i<=62;i++,pw=pw*pw%mod)
        if(y>>i&1)
            lcq=lcq*pw%mod;
    return lcq;
}
int read()//输入
{
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
void print(int x)//输出
{
    if(x<=9)
        cout<<(signed)(x);
    else
    {
        print(x/10);
        cout<<(signed)(x%10);
    }
}
int jc[cxk],n,deg[cxk],sum;
signed main()
{
	n=read();
    if(n==0)//特判一下
        cout<<1,exit(0);
    jc[0]=1;//0的阶乘等于1
    for(int i=1;i<=n;i++)
    {
        jc[i]=jc[i-1]*i%mod;//算阶乘
        deg[i]=read();
        sum+=deg[i];
        if((deg[i]<1&&n!=1)||deg[i]>=n)
            cout<<0,exit(0);
    }
    if(sum!=n*2-2)
        cout<<0,exit(0);
    int ans=jc[n-2];
    for(int i=1;i<=n;i++)
        ans=ans*fastpow(jc[deg[i]-1],mod-2)%mod;//乘逆元
    print(ans);
}
```

---

## 作者：Pwtking (赞：0)

Prufer 序列裸题。

简单的介绍一下这个神奇的数列：

- **定义**：一颗无根树，每次将度数为1的节点的父亲加入序列，并将其删除，最终得到一个长度为 $n-2$ 的序列。

- **将 Prufer 序列转化为无根树**：每次取出序列中最前面的数，将一个在点集中且最小的数与其连边，最后将序列最靠前的数和刚刚在点集中取出的数在分别在序列和点集中删去。最后将剩下的两个未连边的点连边即可。

- **Prufer 序列性质：** 


- 度数为 $d_i$ 的节点只会在序列中出现 $d_i-1$ 次。

- 生成 $n$ 节点的完全图（树）有 $n^{n-2}$ 种（Cayley 定理）。

- 生成每一种树的方式有 $(n-1)!$ 种（Cayley 定理）。

- 对于给定度数 $d_{ 1-n}$ 的 $n$ 个节点，共有 $\frac{(n-2)!}{\prod_{i=1}^{n} (d_i-1)!} $ 种形成树的方式。

其中第二条和第三条由第一条推导而出，第四条由第二和第三条推导而出。

辅助做题结论：对于 $n$ 个结点形成的树，$ {\textstyle \sum_{i=1}^{n}(d_i-1)}=n-2 $。



------------

接下来看本题，本题即为需要利用上面写到的第四条性质，即为答案： $\frac{(n-2)!}{\prod_{i=1}^{n} (d_i-1)!} $ 。

而最后你会发现 $(n-2)!$ 超出 $10^{18}$ 范围了，所以要边乘边除，并且注意特判：若根度数为 $0$ 输出 $0$。

---

## 作者：VinstaG173 (赞：0)

首先，看到度数限制，就想到用 prufer 序列。

一棵树的 prufer 序列的生成方式就是以 $1$ 为根，每次选定编号最小的叶子，删除之并将它的父亲加入序列，直到只剩下两个点。

我们得到一个 prufer 序列后可以还原出树。具体地，每次设序列中的第一个点为 $x$，序列中不存在且没有父亲的编号最小点为 $y$，则连边 $x \to y$。最后连 $1$ 和没有父亲的唯一的点即可。

根据以上的生成方式和构造，我们可以实现树和序列的对应。

又因为对于任意一个长为 $n-2$ 的序列，第 $i$ 步时序列里还有 $n-1-i$ 个数，还有 $n-i$ 个点没有父亲，所以一定可以找到满足要求的点，故这个序列必定作为某棵树的 prufer 序列与之对应。

又由于定义中“最小”的确定性，不存在两棵树拥有相同的 prufer 序列，也没有两个序列能对应到同一棵树。这个的证明很容易，略去。

再给出一个结论：一个点的度数为 $d$ 则它在 prufer 序列里出现了 $d-1$ 次。这个结论很好证，只要注意到除 $1$ 号点外的每个点被它的所有儿子各塞进序列一次，$1$ 号点恰有一个儿子没有把它塞进序列，就是显然的了。

于是我们得到满足题目要求的树就是对应一个由 $d_1-1$ 个 $1$，$d_2-1$ 个 $2$，$\dots$，$d_n-1$ 个 $n$ 组成的序列对应回去的树。因此由双射结论我们只要求这样的序列的个数就行了。这种序列的个数可以直接上可重排列公式，显然我们把同样值的数全看作不同的能得到 $(n-2)!$ 种排列，然后去重，$k$ 个同样的数被计算了 $k!$ 次，因此最后的结果就是 $\dfrac{(n-2)!}{\prod_{i=1}^n(d_i-1)!}$。需要判断无解情况。

由于答案在计算过程中直接用阶乘相除会爆，最大可能到 $148!$ 远超 `__int128` 范围，所以我们可以用处理每个质数幂次的方法避免计算过大的数。只要对阶乘进行预处理就好了。

Code:
```cpp
#include<cstdio>
#define rg register
#define ll long long
int pr[37]=
{
	2,3,5,7,11,
	13,17,19,23,29,
	31,37,41,43,47,
	53,59,61,67,71,
	73,79,83,89,97,
	101,103,107,109,113,
	127,131,137,139,149
};
int n,d;
int cnt;
ll ans=1;
int res[37];
int fac[37][173];
int main()
{
	scanf(" %d",&n);
	for(rg int i=2,j;i<n;++i)
	{
		j=i;
		for(rg int k=0;k<35;++k)
		{
			fac[k][i]=fac[k][i-1];
			while(j%pr[k]==0)++fac[k][i],j/=pr[k];
		}
	}
	for(rg int i=0;i<35;++i)res[i]=fac[i][n-2];
	for(rg int i=0;i<n;++i)
	{
		scanf(" %d",&d);cnt+=d;if(d>=n)ans=0;
		for(rg int j=0;j<35;++j)res[j]-=fac[j][d-1];
	}
	if(cnt!=((n-1)<<1))ans=0;
	for(rg int i=0;i<35;++i)
	{
		while(res[i]>0)ans*=pr[i],--res[i];
	}
	printf("%lld\n",ans);
	return 0;
}
```

---


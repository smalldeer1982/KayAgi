# 漫长的小纸带

## 题目背景

You can also see the pdf at the bottom of the chinese problem statement.

小 $ \zeta $ 是一个喜欢打暴力的 OIer。在每次模拟赛中，他秉持着“10 分钟想不出来正解那就把暴力糊上去”的理念，每次都稳定地拿到很高的分数；平时训练时，他会关注题目的部分分，针对部分分任务进行求解，有时在部分分求解上使用的时间比这个题正解的思考都长。

## 题目描述

小 $ \zeta $ 经过了几年的暴力训练，暴力水平更是炉火纯青。在 S-PSC 2077 的比赛中，他惊喜的发现第二题《漫长的小纸带》是一道很困难的题目，正适合他这种暴力选手发挥。

这道题目是多测题目，在某个测试点内有 $ n $ 组数据，第 $ i $ 组数据的规模为 $ a_i $。他写出了一个暴力程序，对于一段连续的数据，程序解决这段数据需要消耗的时间为这段数据中出现的不同的 $ a_i $ 的种类数平方。形式化地讲，对于一个从第 $ l $ 组到第 $ r $ 组的连续的数据段，记 $ S=\{a_i|l \le i \le r\} $，程序需要消耗 $ |S|^2 $ 的时间来一起解决它们。

现在，他给你 $ n $ 和 $ n $ 组数据的规模，请找到一种将这些数据划分成若干个数据段的方案，使得程序消耗的总时间最短。

## 说明/提示

**【样例 3 解释】**

分段方式为：

* 第一段 $ \{1\} $，消耗为 $ 1 $。
* 第二段 $ \{2\} $，消耗为 $ 1 $。
* 第三段 $ \{1\} $，消耗为 $ 1 $。
* 第四段 $ \{4\} $，消耗为 $ 1 $。
* 第五段 $ \{1,2,1,1,2\} $，消耗为 $ 4 $。

故程序总共消耗的时间为 $ 8 $。

**【数据范围】**

对于 $ 100\% $ 的数据，$ 1 \le n \le 2 \times 10^5 $，$ 1 \le a_i \le 10^9 $。

**提示：本题开启捆绑测试。**

| 子任务编号 | $ n \le $ | 特殊性质 | 分数 |
|:-:|:-:|:-:|:-:|
| $ 1 $ | $ 10 $ | - | $ 8 $ |
| $ 2 $ | $ 300 $ | - | $ 8 $ |
| $ 3 $ | $ 2000 $ | - | $ 16 $ |
| $ 4 $ | - | A | $ 16 $ |
| $ 5 $ | - | B | $ 24 $ |
| $ 6 $ | - | - | $ 28 $ |

特殊性质 A：所有的 $ a_i $ 在 $ [1,10^9] $ 内等概率随机生成，且本子任务只有 $ 1 $ 个测试点。

特殊性质 B：$ 1 \le a_i \le 1000 $。


## 样例 #1

### 输入

```
5
1 2 3 4 5```

### 输出

```
5```

## 样例 #2

### 输入

```
6
1 2 2 1 2 3```

### 输出

```
5```

## 样例 #3

### 输入

```
9
1 2 1 4 1 2 1 1 2```

### 输出

```
8```

## 样例 #4

### 输入

```
21
1 2 1 2 1 2 1 2 1 2 3 4 5 6 7 1 2 1 2 1 2```

### 输出

```
13```

# 题解

## 作者：哈哈人生 (赞：26)

# 题外话
好久没写题解了，碰巧遇到了这题。\
这题挺有意思的。

# 思路
读完题后，可发现最终答案和不同数字的个数有关，和具体数值无关，所以先把 $a_i$ 离散化。然后考虑动态规划，设 $dp_i$ 表示前 $i$ 个数分段所得的最小值。先写个最简单的思路，易得转移式为 $dp_i=min_{j=0}^{i-1} dp_j+w^2$，其中 $dp_0=0$，$w$ 表示的是 $a_j$ 到 $a_i$ 之间不同数字的个数。对于每个 $i$，从大到小枚举 $j$，顺便用桶记录不同数字的个数，$n^2$ 的做法就被我们找到了，加一个小优化可得 $48$ 分。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,a[200005],b[200005],dp[200005];
int lsh[200005],tot=0;
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i],lsh[++tot]=a[i];
	sort(lsh+1,lsh+tot+1);
	tot=unique(lsh+1,lsh+tot+1)-lsh-1;
	for(int i=1;i<=n;i++)a[i]=lower_bound(lsh+1,lsh+tot+1,a[i])-lsh;
	for(int i=1;i<=n;i++){
		dp[i]=1e18;
		int w=1;
		b[a[i]]=i;
		for(int j=i-1;j>=0;j--){
			if(w*w>=dp[i])break;//小优化
			dp[i]=min(dp[i],dp[j]+w*w);
			if(b[a[j]]!=i)w++,b[a[j]]=i;
		}
	}
	cout<<dp[n];
	return 0;
}
```

那这个思路是不是陷入瓶颈了呢？再重新想一下哪些转移位置是真的有用的。设 $dp_i$ 是从某个位置 $j$ 上转移来的，而 $j$ 若满足 $a_{j-1}$ 是在 $a_j$ 到 $a_i$ 中出现过的，那么其显然不如从位置 $j-1$ 上转移，因为多一个已出现的 $a_{j-1}$ 无任何增加的花费，所以此时位置 $j$ 无用，也就是说最优的 $dp_i$ 一定不是从 $j$ 转移过来的。把这个规律普遍化一下，就会发现对于 $dp_i$ 来说，一个位置 $j$ 真正有用就需要满足不存在 $j+1\le k\le i$，使得 $a_k=a_j$。我们可以用一个桶来存所有数字最后出现的位置，再用 ``set`` 来维护之间的先后顺序，每次转移都从 ``set`` 中所存的位置一一尝试选取最优解。但这样乍一看，``set`` 的大小最多也是 $i$，似乎还是 $n^2$ 的时间复杂度。但别忘了我们还有一个小优化：``if(w*w>=dp[i])break;``。之前这个优化的作用不明显是因为每个位置可能数字出现过也有可能没出现过，构造特定数据还是能使循环执行接近 $i$ 次。但这回我们每访问 ``set`` 中的一个位置，$w$ 必定加一，因为我们存的是每个数字最后一次出现的位置。所以这个代码就使我们的时间复杂度变为 $O(n\sqrt n)$（$dp_i$ 的最大取值也不过是 $i$，而且显然会小很多），并且大概率跑不满。

正解代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,a[200005],b[200005],dp[200005];
int lsh[200005],tot=0; 
set<int> s;
typedef int type;
inline type read(){
	type x=0,f=1;
	char ch=getchar();
	while(!isdigit(ch)){
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return x*f;
}
inline void write(type x){
	if(x<0)putchar('-'),x=-x;
	if(x>9)write(x / 10);
	putchar(x%10+'0');
}
signed main(){
	n=read();
	for(int i=1;i<=n;i++)a[i]=read(),lsh[++tot]=a[i];
	sort(lsh+1,lsh+tot+1);
	tot=unique(lsh+1,lsh+tot+1)-lsh-1;
	for(int i=1;i<=n;i++)a[i]=lower_bound(lsh+1,lsh+tot+1,a[i])-lsh;
	for(int i=1;i<=n;i++){
		dp[i]=1e18;
		if(b[a[i]])s.erase(s.find(-b[a[i]]));
		int w=1;
		for(auto it=s.begin();it!=s.end();it++){
			int j=-*it;
			dp[i]=min(dp[i],dp[j]+w*w);
			w++;
			if(w*w>=dp[i])break;
		}
		dp[i]=min(dp[i],w*w);
		b[a[i]]=i,s.insert(-i);//存-i是在使set从大往小排列位置
	}
	write(dp[n]);
	return 0;
}
```

# 后记
点个赞吧。

---

## 作者：Super_Cube (赞：10)

# Solution

卡了接近 1h 的常，终于战胜。

设 $dp_i$ 表示前 $i$ 个数分成若干段的最小代价，枚举上一次分界点，有转移：$dp_i=\displaystyle\min_{j=1}^i dp_{j-1}+f(j,i)^2$，其中 $f(l,r)$ 表示 $l\sim r$ 中的数字种类数。时间复杂度 $O(n^2)$，无法通过。

注意到 $dp_i$ 上界为 $i$，即每个数单独划分成段，而转移式中有 $f(j,i)^2$ 这一项，所以只有当 $f(j,i)\le\sqrt i$ 时才有意义。

于是考虑枚举 $f(j,i)$ 的取值来进行转移，这样复杂度降至 $O(n\sqrt n)$。具体的，设 $p_j$ 表示最靠前的位置使得 $[p_j,i]$ 中恰有 $j$ 种不相同的值，那么转移式为 $dp_i=\displaystyle\min_{j=1}^{\sqrt i}dp_{p_j-1}+j^2$。

问题是如何求 $p_j$？有个很明显的事情是当 $i$ 变大时，$p_j$ 不减。所以可利用指针往后扫做到动态维护，均摊下来是 $O(n)$。因为一共 $\sqrt n$ 个指针，所以这一块复杂度也为 $O(n\sqrt n)$。

---

## 作者：Moya_Rao (赞：9)

# 废话
赛时暴力乱打，鼓捣出来 $48$ 分，做不下去了。  
赛后发现这道题是绿，过了一阵子又变成了蓝，这也太不均匀了吧，最后一题都只是个绿呢，比这题简单多了，哈哈。

# 题目大意
给定你一个长度为 $n$ 的序列 $a$，你要把这个序列分成若干段，每段的代价是这一段数字种类数的平方，序列总代价是这若干段的代价之和。现在要你求出最小的总代价。

# 思路
奇怪的动态规划，好吧也不是那么奇怪啦。

我们一开始可以想到暴力。  
怎么暴力呢？先定义 $dp_i$ 表示结尾为 $i$ 的前缀序列所需的最小代价，答案就是 $dp_n$ 了，状态应该很好想吧。  
具体操作呢，要首先暴力算出两个端点之间的数字种类数，时间复杂度为 $O(n^2)$；接着枚举每个右端点 $i$，看看它被划分在的那个区域里，左端点是谁，枚举这个左端点 $j$，利用之前预处理出来的答案更新 $dp_i$，当然一开始要初始化为极大值啦。这一段所需时间也是 $O(n^2)$ 的。  
用这种暴力思路，加上奇奇怪怪的直接输出 $n$ 做法，$48$ 分水灵灵到手啦，哈哈！

可是我们并不满足于这么点儿分，继续想想看。

如果暂且不考虑预处理所需时间，那我们的 DP 过程，瓶颈就在于枚举左端点 $j$，太浪费时间了。因为有的左端点 $j$ 是毫无意义的，因为第 $j-1$ 个数有可能是 $j \sim i$ 之间出现过的，把它加进来代价不会变，那最优的转移方案就一定不是 $j$ 了，不管怎么样 $j-1$ 就不会比它差呀。

那么我们就可以维护每一种数字出现的最后一次。没必要预处理我告诉你，用一个 `set` 神器，一边做 DP 一边更新就可以了。当然你要先调整一下这个 `set` 的存储顺序，是从大到小而不是默认的从小到大，因为这样更方便于我们计算种类数，是吧？  
具体怎么维护呢？简单，我们用一个 $id$ 数组存下当前位置前面所有数中每种数字出现的最后一次，也是跟随 DP 更新的。那么每次来一个新的 $i$，我们就判断一下，$id_{a_i}$ 里是否存在值。如果存在，那么要把这个值从我们的 `set` 中删去！因为它不是最后一个了，再留在里边，`set` 就维护不下去了。每次更新完 $dp_i$，就把 $i$ 扔到 `set` 里边去，等着后面使用它来更新就得啦。

等一等，别着急编代码，还有一个问题呢。我们不是有一个 $id$ 数组么？可是你看看数据范围，$1 \le a_i \le 10^9$，不能直接开一个 $10^9$ 大小的数组，会爆空间。怎么办？简单，离散化一下就得了。你可以看看我代码中的神奇离散化方法，可方便了，用上一个 `map` 就行！

好啦，这样就完美解决啦，其实上也不难吧？就是很难理解而已嘛。

# [AC](https://www.luogu.com.cn/record/191128698) 代码
你们最爱看的代码来咯！

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 2e5+5;
int n,a[N],id[N],cnt,dp[N];
map< int,int > kk;
set< int,greater<int> > st;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        if(!kk[a[i]])kk[a[i]]=++cnt;
        a[i]=kk[a[i]];
    }
    memset(dp,0x3f,sizeof(dp));
    dp[0]=0;
    for(int i=1;i<=n;i++){
        if(id[a[i]])st.erase(st.find(id[a[i]]));
        int w=1;
        for(auto it=st.begin();it!=st.end();it++){
            int p=(*it);
            dp[i]=min(dp[i],dp[p]+w*w);
            if(w*w>=dp[i])break;
            w++;
        }
        dp[i]=min(dp[i],w*w);
        dp[i]=min(dp[i],dp[i-1]+1);
        id[a[i]]=i;st.insert(i);
    }
    cout<<dp[n];
    return 0;
}
```

请点赞，谢谢！

---

## 作者：船酱魔王 (赞：5)

# T4. paper

## 题意回顾

长度为 $ n $ 的序列分段，使得每段出现的颜色种类数的平方的和最小。

$ 1 \le n \le 2 \times 10^5 $。

## 分析

> 观察 1：每个序列的答案必然不小于它的前缀。

对于这个序列的划分方式，在前缀部分上的断点作用到前缀上，前缀上每个段的颜色种类数都不会超过完整的序列。

> 观察 2：不存在一个段的颜色数超过 $ \sqrt{n} $。

首先把每个数独立分成一段代价为 $ n $，则若存在颜色数超过 $ \sqrt{n} $ 的段，那么那个段本身的代价就超过 $ n $ 了，一定不是最优的。

考虑设计 $ dp_i $ 表示前 $ i $ 个数构成的前缀，最小代价为多少。可以设计转移 $ dp_i=\min_{j \le \sqrt{n}}\{dp_{lst_{i,j}-1}+j^2\} $，这里 $ lst_{i,j} $ 为最小的满足 $ lst_{i,j} $ 到 $ i $ 构成的连续子序列颜色数为 $ j $ 的 $ lst_{i,j} $。

考虑如何求出这个 $ lst_{i,j} $？需要知道前 $ i $ 个字符构成的前缀中每个颜色出现的最靠右位置，我们只需要知道最靠右的 $ \sqrt{n} $ 个这样的位置即可。可以用插入排序的方式更新维护。

## AC 代码

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
const int N = 2e5 + 5;
const int S = 654;
int n;
int a[N];
struct node {
	int pos;
	int val;
} b[S + 3];
int dp[N];
int main() {
	scanf("%d", &n);
	for(int i = 1; i <= n; i++) scanf("%d", &a[i]);
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= S; j++) {
			if(b[j].val == a[i]) {
				b[j].pos = i;
				for(int k = j; k >= 2; k--) swap(b[k], b[k - 1]);
				break;
			}
		}
		if(b[1].val != a[i]) {
			b[S].val = a[i], b[S].pos = i;
			for(int j = S - 1; j >= 1; j--) swap(b[j], b[j + 1]);
		}
		dp[i] = i;
		for(int j = 1; j < S; j++) {
			dp[i] = min(dp[b[j + 1].pos] + j * j, dp[i]);
		}
	}
	printf("%d\n", dp[n]);
	return 0;
}
```

---

## 作者：End_Sunset (赞：4)

## 省流 ：非 std 做法，线段树优化dp
# 思路  
### 一些约定
* 定义数据 $i$ 的颜色为 $a_i$。
* 定义数据段的大小为其所含种类数，即 $|S|$。
* 定义 $l$ 组到 $r$ 组数据段的长度为 $r-l+1$ 。
## $O(n^3)$
注意到题目要求*最优序列划分*，一个常见思路就是DP。

设状态 $f_i$ 表示长为 $i$ 的前缀最优划分的价值，转移考虑往一段已经计算出最优价值的前缀后拼接一段数据段，即
$$ f_i+ w(i+1,j) \to f_j $$
其中 $w(l,r)$ 表示这个数据段的价值，即该数据段大小的平方。我们将该式表示为更一般的形式：
$$ f_i=\min\limits_{0\le j <i} \{ f_j+w(i+1,j) \} $$
初始条件为 $f_0=0$, 输出答案为 $f_n$。  $w(l,r)$的计算可以考虑丢进 set 或 map 中去重后求 $size$。

## $O(n^2)$ 
考虑对 $w(l,r)$ 优化 ：
- 我们发现在计算 $f_i$ 时，$w(j,i)$ 比 $w(j+1,i)$ 多了 $a_j$ 这一个元素，于是我们可以从后往前枚举 $j$。
- 联想 [HH的项链](https://www.luogu.com.cn/problem/P1972) 中的 trick， 在计算 $f_i$ 时我们把每种颜色产生的贡献钦定在区间 $[1,i]$ 中最后一个点。此时
  $$ w(i,j)=(\sum\limits_{i\le k \le j} val_k)^2$$
  > ### Example3
  > ```
  > 9
  > 1 2 1 4 1 2 1 1 2
  > ```
  > 在计算 $f_5$ 时，$val$ 序列应是这样的：  
  > `0 1 0 1 1 0 0 0 0`  
  > 在计算 $f_7$ 时，$val$ 则是这样的：  
  > `0 0 0 1 0 1 1 0 0`
  >
结合这两种优化，我们从后往前维护 $val$ 后缀和，每次计算时将其平方即为 $w(i,j)$。那么如何获得 $val$ 序列呢？   

这是容易的，我们令 $pre_i$ 为左边离它最近的同颜色数据的下标，外层循环遍历到 $i$ 时:
```cpp
val[i]++,val[pre[i]]--;
```
这样我们获得了转移 $O(n)$ 的算法，总复杂度 $O(n^2)$。

## $O(n\sqrt{n}+n\log n)$  
众所周知 1D/1D DP 永远没有 $O(n^2)$ 正解，于是考虑使用数据结构优化 $\min$ 的转移。考虑使用线段树维护
$$f_i+w(i+1,now)$$ 
即单点价值与一段后缀和的平方的和。

那么原先单点修改 $val[pre_i]$ 和 $val[i]$ 变成对区间 $[pre_i+1,i]$ 做区间加一后维护平方。我们无法对区间加1后迅速获得其平方后的最小值，所以区间修改仍需要递归到叶子作修改后再合并，复杂度仍是 $O(n)$的。

维护区间平方最小值是不可做的，但是观察 Substack 3 我们获得一个重要性质
> 每个数据段的大小不会超过 $\sqrt n$。

> 证明 : 由于可以单个数据分为一段,所以 $f_n \le n$，又因为大小超过 $\sqrt n$ 的数据段代价超过 $n$，所以不存在大小超过 $\sqrt n$ 的数据段

这个观察启发我们对暴力修改进行优化，对于 $val_i>\sqrt n$ 的我们打上标记,此后不再做修改。事实上我们不需要给每个点都上一个标记，由上文提到的单调性，$val_i$ 应是单调递减，于是大于 $\sqrt n$ 的一定是一段前缀，于是我们可以设一个指针 $L$ 指向这段前缀的后一个数，每次修改查询区间 $[l,r]$ 时，将 $max(l,L) \to l$， 再 $l \to r$ 的暴力修改时，实时维护 $L$ 即可。

> 为什么这样做复杂度是对的？

> 由于每个点最多会被加 $\sqrt n$ 次，所有点总共会加不到 $n\sqrt n$ 次，所以区间修改的复杂度均摊是 $O(\sqrt n)$
## 实现上的问题
* 因为 $a_i \le 10^9$ ，故需先离散化后求 $pre$ 数组。
* 为了方便线段树维护，$f$ 数组整体后移一位。具体实现细节见代码。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ls (p<<1)
#define rs (p<<1|1)
#define pii pair<int,int>
#define fst first
#define scd second
#define ll long long
const int N=2e5+5,mod=998244353;

int n,cnt;
int val[N],f[N],tr[N<<2],pre[N],lst[N],a[N]; 
pii num[N];
int lim,L;
void upd(int p,int l,int r,int ql,int qr){  //区间暴力修改 
	if(qr<l||r<ql) return;
	if(l==r){
		val[l]++;
		if(val[l]>=lim) L++;
		tr[p]=val[l]*val[l]+f[l];
		return;
	}
	int mid=(l+r)>>1;
	upd(ls,l,mid,ql,qr);
	upd(rs,mid+1,r,ql,qr);
	tr[p]=min(tr[ls],tr[rs]);
}
void mdy(int p,int l,int r,int pos){  //线段树单点修改 
	if(l==r){
		tr[p]=f[l];
		return;
	}
	int mid=(l+r)>>1;
	if(pos<=mid) mdy(ls,l,mid,pos);
	else mdy(rs,mid+1,r,pos);
	tr[p]=min(tr[ls],tr[rs]);
}
int qry(int p,int l,int r,int ql,int qr){  //区间询问最小值 
	if(qr<l||r<ql) return 2e9;
	if(ql<=l&&r<=qr) return tr[p];
	int mid=(l+r)>>1;
	return min(qry(ls,l,mid,ql,qr),qry(rs,mid+1,r,ql,qr));
}
int main(){
	cin>>n; lim=sqrt(n)+1;
	//离散化 
	for(int i=1; i<=n; i++) cin>>num[i].fst,num[i].scd=i;
	sort(num+1,num+n+1);
	for(int i=1; i<=n; i++){
		if(num[i].fst!=num[i-1].fst) ++cnt;
		a[num[i].scd]=cnt;
	}
	//求 pre 数组
	for(int i=1; i<=n; i++){
		pre[i]=lst[a[i]];
		lst[a[i]]=i;
	}
	f[1]=0; L=1;  //代码中f[i+1]记录的值为f[i],L为合法区间左端点指针 
	for(int i=1; i<=n; i++){
		upd(1,1,n+1,max(L,pre[i]+1),i);
		f[i+1]=qry(1,1,n+1,L,i);
		mdy(1,1,n+1,i+1);
	}
	cout<<f[n+1]<<"\n";
}
```

---

## 作者：Lucyna_Kushinada (赞：3)

提供一种理论复杂度为 $O(n \sqrt{n}\log^2 n )$ 但远远跑不满的做法。

观察到一个大段的花费是段中数的种类数 $k$ 的平方，假设让这个大段种每个数自成一小段，则花费是大段的长度 $l$，是花费的上限，所以我们分出来的段必须都满足 $k^2\le l$，不然还不如每个数自成一小段。

为了方便叙述，这里令 $cnt_{l,r}$ 为 $[l,r]$ 中数的种类数。

我们设 $dp_i$ 为划分前 $i$ 个数后的最小花费，则有转移 $dp_i=\min_{j=1}^{i}(dp_{j-1}+cnt^2_{j,i})$，不过这样的复杂度是 $O(n^2)$ 的，不足以通过此题，顺着上面 $k^2\le l$ 的限制，我们考虑枚举种类数 $k$。

对于每个 $k$，我们要找出满足 $cnt_{j,i}=k$ 的最小的 $j$，因为显然 $dp_j$ 是单调不减的，$j$ 越小越好，这里我们可以使用二分来解决，那么如何得到 $cnt_{j,i}$ 的值呢，我们用树状数组求区间种类数即可，这是一个经典的技巧，可以参考[P1972 [SDOI2009] HH的项链](https://www.luogu.com.cn/problem/P1972)的做法。

代码如下。


```cpp
#include<bits/stdc++.h>
using namespace std;

#define rep(i,l,r) for(int i=(l);i<=(r);++i)
#define per(i,l,r) for(int i=(r);i>=(l);--i)
#define pr pair<int,int>
#define fi first
#define se second
#define pb push_back

#define N 201145
#define int long long

int n,a[N],dp[N],idx[N];
vector<int>tmp;

struct BIT{
	int tr[N];
	#define lb(x) (x&-x)
	
	inline void upd(int k,int d){
		while(k<=n){
			tr[k]+=d;
			k+=lb(k);
		}
	}
	
	inline int ask(int k){
		int ans=0;
		
		while(k){
			ans+=tr[k];
			k-=lb(k);
		}
		
		return ans;
	}
}b;

inline int qry(int l,int r){
	return b.ask(r)-b.ask(l-1);
}

signed main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	
	cin>>n;
	rep(i,1,n){
		cin>>a[i];
		tmp.pb(a[i]);
	}
	
	sort(tmp.begin(),tmp.end());
	
	rep(i,1,n){//离散化
		a[i]=lower_bound(tmp.begin(),tmp.end(),a[i])-tmp.begin()+1;
	}
	
	b.upd(1,1);
	dp[1]=1;
	idx[a[1]]=1;
	
	rep(i,2,n){
		if(idx[a[i]]){
			b.upd(idx[a[i]],-1);
		}
		b.upd(i,1);//树状数组求区间种类数
		idx[a[i]]=i;
		
		dp[i]=1e18;//初始化
		
		rep(num,1,n){
			int st=i-num*num+1;//计算枚举区间右端点
			
			if(st<=0)break;//num最多只能取到约sqrt(i)
			
			int res=qry(st,i);
			
			if(res!=num){//如果最大左端点都不满足种类数为num就跳过
				continue;
			}
			
			int l=1,r=st,mid=(l+r)>>1,idx=st;
			
			while(l<=r){//二分最小左端点
				mid=(l+r)>>1;
				int tmp=qry(mid,i);
				
				if(tmp==num){
					idx=mid;
					r=mid-1;
				}
				else{
					l=mid+1;
				}
			}
			
			dp[i]=min(dp[i],dp[idx-1]+res*res);
		}
	}
	
	cout<<dp[n];
	
	return 0;
}
```

甚至不需要大力卡常，调出来就过了。

---

## 作者：mbzdf (赞：2)

## 思路

一眼 DP。

### 部分分（暴力）

设 $f_i$ 表示前 $i$ 个数的最小花费，易得 $f_i = \min_{j = 0}^{i - 1} f_j + |S|^2$，其中 $S=\{a_ k|j≤k≤i\}$。

那么如果暴力，则复杂度为 $O(n^3\log n)$，仅能得 $16$ 分。

想一下优化。

容易想到，对于每个 $f_i$，从 $i - 1$ 开始，向 $1$ 枚举 $j$，若要记录 $S=\{a_k|j\le k\le i\}$，只需要每次往 $S$ 里添加 $a_j$，就不需要枚举 $k$ 了。

那么我们使用 `set` 存储 $S$，如此转移，时间复杂度为 $O(n^2\log n)$，得到了 $32$ 分。

---

### 正解

我们发现，最优的划分方式一定不会出现一个 $S$ 使 $|S| > \sqrt n$。

这启发我们思考复杂度带根号的解。

新增一个数组 $g_{i, j}$，表示以 $a$ 数组中以第 $i$ 个数为结尾，共包含不大于 $j$ 种数字的最大连续子序列的长度且 $j \le \sqrt n$。

怎么转移呢？

想一下，$g_{i, j}$ 表示的是在 $a$ 上取 $[i - g_{i, j} + 1, i]$ 的区间的长度。

如果 $g_{i - 1, j}$ 的答案里包含 $a_i$，那么 $g_{i, j}$ 就相当于直接在 $g_{i - 1, j}$ 表示的序列里再加上一个 $a_i$ 而不改变 $j$，而如果不包含，则只能在 $g_{i - 1, j - 1}$ 表示的序列里加上 $a_i$，$a_i$ 是新的，所以 $j$ 要加上 $1$。

怎么判断 $g_{i - 1, j}$ 的答案里包不含 $a_i$ 呢？

设 $lst_i$ 表示 $a$ 中，上一个等于 $a_i$ 的数的下标。

那如果 $lst_i$ 在  $[i - g_{i - 1, j} + 1, i - 1]$ 中，那这个区间就包含 $a_i$，反之则不包含。

得到转移方程

$g_{i, j} = 
\begin{cases}
g_{i - 1, j} + 1 & (i - g_{i - 1, j} \le lst_i) \\
g_{i - 1, j - 1} + 1 & (i - g_{i - 1, j} > lst_i)\\
\end{cases}$

那么我们就可以以 $O(n\sqrt n)$ 的复杂度求出所有 $g_{i,j}$。

再想如何用 $g$ 优化 $f$。

容易想到对于每一个 $f_i$，枚举 $j(1 \le j \le \sqrt n)$，让 $f_i = \min f_{i - g_{i, j}} + j^2$。

最终 $f_i$ 的转移方程为

$f_i = \min_{j = 1}^{\sqrt n} f_{i - g{-i, j}} + j^2$。

每一个 $f_i$ 用 $O(\sqrt n)$ 的复杂度求出来，那么所有 $f_i$ 用 $O(n \sqrt n)$  的时间复杂度求出来。

最终时间复杂度为 $O(n\sqrt n)$，空间复杂度为 $O(n\sqrt n)$，得分 $100$ 分。

---

## 代码
```cpp
#include <iostream>
#include <cstring>
#include <cmath>
#include <unordered_map>
using namespace std;

const int maxn = 2e5;
const int sqrtmaxn = sqrt(maxn);

int a[maxn + 5];
int lst[maxn + 5];

int g[maxn + 5][sqrtmaxn + 5];
int f[maxn + 5];

int main()
{
	int n, sqrtn;
	scanf("%d", &n), sqrtn = sqrt(n);
	unordered_map<int, int> s;
	for(int i = 1; i <= n; ++i)
	{
		scanf("%d", a + i);
		lst[i] = s[a[i]];
		s[a[i]] = i;
	}
	for(int i = 1; i <= n; ++i)
	{
		for(int j = 1; j <= sqrtn; ++j)
		{
			if(i - g[i - 1][j] <= lst[i])
				g[i][j] = g[i - 1][j] + 1;
			else g[i][j] = g[i - 1][j - 1] + 1;
		}
		f[i] = i;
		for(int j = 1; j <= sqrtn; ++j)
		{
			int tmp = g[i][j];
			f[i] = min(f[i], f[i - tmp] + j * j);
		}
	}
	printf("%d\n", f[n]);
	return 0;
}
```

---

## 作者：lilong (赞：2)

首先不难写出 $O(n^2)$ 的 dp。设当前在第 $i$ 个位置，从前面选择一个位置 $j$，并加上 $[j+1,i]$ 这一段的贡献（可以预处理），取最小值即可。


```cpp
#include <iostream>
#include <cstdio>
#include <map>

using namespace std;

map<int,int> vis;
int f[2001],g[2001][2001];
int n,a[2001];

signed main()
{
	cin >> n;
	for( int i = 1 ; i <= n ; i ++ )
		cin >> a[i];
	for( int i = 1 ; i <= n ; i ++ )
	{
		vis.clear();
		for( int j = i ; j <= n ; j ++ )
		{
			g[i][j] = g[i][j - 1];
			if( !vis[a[j]] )
				vis[a[j]] = 1,g[i][j] ++;
		}
	}
	for( int i = 1 ; i <= n ; i ++ )
	{
		f[i] = g[1][i] * g[1][i];
		for( int j = 1 ; j < i ; j ++ )
			f[i] = min( f[i] , f[j] + g[j + 1][i] * g[j + 1][i] );
	}
	cout << f[n];
	return 0;
}
```


考虑优化。读题可以发现一个显然的性质，即答案一定不会超过 $n$（每个数据都为一个连续段）。因此对于任意一个连续段的种类数量都不应超过 $\sqrt{n}$，在 $n=2\times 10^5$ 时为 $448$ 左右。

不妨改变思路，以当前的 $i$ 为右端点，枚举种类数量，并求出等于该种类数量的**最左端点** $j$（这一段的贡献相同，取最左能保证前面的贡献尽可能小），从 $j-1$ 转移即可。时间复杂度 $O(n \sqrt{n} )$。

如何动态维护每个最左端点？对于新加进来的 $a_i$，更新对应的计数器，同时将**上一次的左端点**向右移动至种类数量符合（类似双指针的思路）。由于最多有 $\sqrt{n}$ 种数，在每个种类数量下每个 $a_i$ 被更新 $2$ 次，故时间复杂度也是 $O( n \sqrt{n} )$。

实现时一些注意点：

- 数组不要开 long long，否则会 MLE。
- $a$ 数组先离散化，方便直接用数组统计，否则使用 map 可能会 TLE。


```cpp
#include <iostream>
#include <cstdio>
#include <map>
#include <algorithm>

using namespace std;

int cnt[200001][452];
int f[200001],tot[452];
int n,m,a[200001],b[200001],d[200001];

signed main()
{
	cin >> n;
	for( int i = 1 ; i <= n ; i ++ )
		cin >> a[i],b[i] = a[i],f[i] = i;
	sort( b + 1 , b + n + 1 );
	m = unique( b + 1 , b + n + 1 ) - b - 1;
	for( int i = 1 ; i <= 450 ; i ++ )
		d[i] = 1;
	for( int i = 1 ; i <= n ; i ++ )
		a[i] = lower_bound( b + 1 , b + m + 1 , a[i] ) - b;
	for( int i = 1 ; i <= n ; i ++ )
	{
		for( int j = 1 ; j <= 450 ; j ++ )
		{
			if( !cnt[a[i]][j] )
			{
				tot[j] ++;
				cnt[a[i]][j] ++;
			}
			else cnt[a[i]][j] ++;
			while( tot[j] > j )
			{
				cnt[a[d[j]]][j] --;
				if( cnt[a[d[j]]][j] == 0 )
					tot[j] --;
				d[j] ++;
			}
			if( tot[j] == j )
				f[i] = min( f[i] , f[d[j] - 1] + j * j );
			//cout << i << ' ' << j << ' ' << d[j] << '\n';
		}
//		cout << f[i] << endl;
	}
	cout << f[n];
	return 0;
}
```

---

## 作者：porse114514 (赞：1)

# P11311 漫长的小纸带 题解
## 题意
给定一个长为 $n$ 数组 $a$，将他分成若干段，每段的代价为这一段数字个数的平方，求最小代价。
## 思路
看到分段、最小代价这些字眼，于是考虑 dp：

设 $dp_i$ 表示 $1$ 到 $i$ 的最小代价，$s_{i,\,j}$ 为 $i$ 到 $j$ 的不同数字个数。

考虑这个状态可以由那些状态得来，发现可以枚举 $i$ 所在块的长度 $k$，此时 $dp_i=dp_{i-k}+s_{i,\,j}^2$，状态转移方程有了，便可 dp，复杂度 $O(n^2)$，能拿 32pts（卡常可卡到 48pts）

考虑怎么优化，我们发现当我们考虑 $1$ 到 $i$ 时，如果分成 $i$ 块，则总代价为 $i$，所以不可能存在某一块的数字个数大于 $\sqrt i$，所以我们枚举 $k$ 的时候，有用的 $k$ 仅当：
- 当前块数字个数不大于 $\sqrt i$；
- 当前块大小为 $k+1$ 时数字个数会增加（否则 $k+1$ 一定更优）

于是我们可以改变枚举方法，令以 $j$ 为右端的块，数字种类数为 $i$，块的左端点最左到 $pre_{i,\,j}$。这个东西的大小只有 $n\sqrt n$，也可以通过双指针 $O(n\sqrt n)$ 求。

于是我们有了新的转移方程：
$$\large dp_{i,\,j}=\large \max_{j=1}^{\lfloor\sqrt i\rfloor}dp_{pre_{j,\,i}-1}+j^{2}$$

## Code
```cpp
#include <bits/stdc++.h>
using namespace std;

constexpr int maxn = 200010;

int n, a[maxn], l, r, pre[490][maxn], sum, dp[maxn], ls[maxn], tot, t[maxn];
map <int, int> v;

void pu(int x) {//加入
	if (!(t[x]++)) {
		sum++;
	}
	return ;
}
void po(int x) {//删除
	if (!(--t[x])) {
		sum--;
	}
	return ;
}

signed main() {
	ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
	
	cin >> n;//读入
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
		ls[i] = a[i];
	}
	
	sort(ls + 1, ls + 1 + n);//本做法必须离散化，要不然双指针就TLE了
	ls[0] = 0;
	for (int i = 1; i <= n; i++) {
		if (ls[i] != ls[i - 1]) {
			v[ls[i]] = ++tot;
		}
	}
	for (int i = 1; i <= n; i++) {
		a[i] = v[a[i]];
	}
	
	for (int i = 1; i <= sqrt(n); i++) {//双指针求pre
		l = 1, r = 0;
		sum = 0;
		for (int j = 1; j <= tot; j++) {
			t[j] = 0;
		}
		for (int j = 1; j <= n; j++) {
			pu(a[++r]);
			while (sum > i) po(a[l++]);
			pre[i][j] = l;
		}
	}
	
	dp[1] = 1;
	for (int i = 2; i <= n; i++) {//dp转移
		dp[i] = maxn;
		for (int j = 1; j <= sqrt(i); j++) {
			dp[i] = min(dp[pre[j][i] - 1] + j * j, dp[i]);
		}
	}
	
	cout << dp[n];//输出
	
	return 0;
}
```

---

## 作者：gavinliu266 (赞：1)

# 思路
首先很容易得到 $O(n^2)$ 的做法，即记 $dp_i$ 为前 $i$ 个数的最优解，然后枚举断点，记 $f(l, r)$ 为区间 $[l, r]$ 内不同数的个数，则 $dp_i = \min \limits _{j=1} ^{i-1} \{dp_{j-1}+f(j,i)^2\}$。

然后很明显的一点就是如果一段不同数个数超过 $\sqrt{n}$，则贡献超过每一个分一段的 $n$，可以直接舍去。

但是这样会被形如 `7 1 1 1 1 1 1 1` 的数据卡到 $O(n^2)$。

然后我们来考虑贪心一下：如果存在 $l \le r < i$，满足 $f(l,i)=f(r+1,i)$，由于 $dp$ 明显单调不降，所以 $dp_{l-1}+f(l,i) \le dp_r+f(r+1,i)$，也就是说，我们要尽可能将断点向前推。

所以考虑维护数组 $p$，$p_i$ 表示从当前位置向前，保证区间内不同数目不超过 $i$ 时能达到的最小下标，这里只要维护到 $p_{\sqrt{n}}$ 即可，然后 $dp_i=\min \limits _{j=1} ^{\sqrt{n}} \{dp_{p_j-1}+j^2\}$。

因为新加一个数时 $p_i$ 单调不降，所以可以暴力移动，一个位置共移动 $n$ 次，有 $\sqrt{n}$ 个，所以这一步时间复杂度 $O(n\sqrt{n})$，又 dp 转移总时间复杂度也是 $O(n\sqrt{n})$，所以总时间复杂度就是 $O(n\sqrt{n})$。

# 代码实现
写完了，听说很卡常，但实际上常数只要不爆炸就可以。

可惜我第一次把常数写炸了，然后调了一会，才通过。

不废话了，代码。
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std;
const int N = 2e5 + 5;
const int L = 460;
int n;
int a[N], c[N], p[L], _c[L];
int dp[N], cnt[N][L];
inline int read() {
    int x = 0;
    char c = getchar();
    while(c < '0' || c > '9') c = getchar();
    while(c >= '0' && c <= '9')
        x = x * 10 + c - '0', c = getchar();
    return x;
}
int main() {
    n = read();
    int k = sqrt(n) + 1;
    for(int i = 1; i <= n; ++i)
        c[i] = a[i] = read();
    sort(c + 1, c + n + 1);
    int csiz = unique(c + 1, c + n + 1) - c - 1;
    for(int i = 1; i <= k; ++i)
        p[i] = 1;
    for(int i = 1; i <= n; ++i) {
        dp[i] = 0x3f3f3f3f;
        a[i] = lower_bound(c + 1, c + csiz + 1, a[i]) - c;
        for(int j = 1; j <= k; ++j) {
            if((++cnt[a[i]][j]) == 1) {
                if((++_c[j]) > j) {
                    while((--cnt[a[p[j]++]][j]) > 0);
                    --_c[j];
                }  // 因为每次只会超出一个，所以扫描时只要把一个的数量变为 0 就可以停止了
            }
            dp[i] = min(dp[i], dp[p[j] - 1] + j * j);
        }
    }
    printf("%d\n", dp[n]);
}
```
[记录](https://www.luogu.com.cn/record/190866046)。

---

## 作者：_Kenma_ (赞：1)

# P11311 解题报告

## 前言

怎么蓝了，那就写篇题解吧。

## 思路分析

套路地，设 $f_i$ 表示到第 $i$ 位的最小答案，易得转移：

$$f_i=f_j+cal(j+1,i)^2,j<i$$

其中 $cal(l,r)$ 表示区间 $[l,r]$ 的不同颜色种类数。

~~然后你大胆猜测有决策单调性，大力二分队列维护就做完了。~~

注意到答案上界为 $n$，也就是把序列断成 $n$ 段，每段代价为 $1$。

因此，我们的合法转移区间 $[j+1,i]$，其中的颜色种类数必然 $\le \sqrt{n}$。

使用刷表法转移。考虑用一个链表记录当前每种颜色下一次出现的位置，用 set 维护这些位置。每次转移时，只需要转移 set 中当前颜色的 $\sqrt{n}$ 个后继就行了。

不难发现复杂度是 $O(n\sqrt{n}\log n)$ 的，感谢良心出题人没有卡 set 的巨大常数。

## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[200005],b[200005],pre[200005],suf[200005],f[200005],vis[200005];
set<int> s;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		b[i]=a[i];
	}
	sort(b+1,b+1+n);
	int cnt=unique(b+1,b+1+n)-b-1;
	for(int i=1;i<=n;i++){
		a[i]=lower_bound(b+1,b+1+n,a[i])-b;
	}
	for(int i=1;i<=n;i++){
		suf[pre[a[i]]]=i;
		pre[a[i]]=i;
	}
	s.insert(n+1);
	for(int i=1;i<=n;i++){
		if(!vis[a[i]]) s.insert(i); 
		vis[a[i]]=1;
	}
	memset(f,0x3f,sizeof(f));
	f[0]=0;
	for(int i=1;i<=n;i++){
		set<int>::iterator it=s.begin();
		it=next(it);
		for(int j=1;j*j<=n && it!=s.end();j++,it=next(it)){
			f[(*it)-1]=min(f[(*it)-1],f[i-1]+j*j);
		}
		s.erase(i);
		if(suf[i]){
			s.insert(suf[i]);
		}
	}
	cout<<f[n];
	return 0;
}
```

---

## 作者：MarsCheng (赞：0)

# P11311 漫长的小纸带

看到题目，很显然是一个 dp，同时我们可以很快想到通过枚举上一分割点的方式转移，即

$$
dp_i = \min_{j=0}^{i - 1} (dp_j + s_{j + 1, i}^2)
$$

其中 $s_{l,r}$ 表示 $l$ 到 $r$ 中不同的 $a_i$ 的数量，显然这是 $O(n^2)$ 的，考虑优化。

注意到一个显然的事实，$dp_i$ 是不可能超过 $n$ 的，因为就算一个一个的处理都只需要 $n$ 的时间。所以当 $s_{j + 1, i}^2$ 项超过 $n$ 时就不需要考虑了，也就是说我们只需要枚举 $s_{j + 1, i}$ 在 $1$ 到 $\sqrt n$ 中的情况。

同时，由于 $s_{l,r}$ 在 $r$ 不变 $l$ 递减时是非严格单调递增的，同时 $dp_i$ 非严格单调递增，所以可以考虑维护使 $s_{l,r}=x$ 的最小的 $l$ 作为决策点。每一次枚举 $\sqrt n$ 个决策点即可。

时间复杂度 $O(n \sqrt n)$，凭借 vector 优秀的常数可过。

## Code

代码里面注释的还挺详细的（大概吧）

```cpp
#include <bits/stdc++.h>

const int N = 2e5 + 7, inf = 1e9;

struct Line {
    int l, r;
};
int n, sqn, a[N], dp[N];
// 决策点
// chp[i] 表示在当时对于所有 chp[i].l <= l <= chp[i].r
// 都有 s(l,r) = i + 1
std::vector<Line> chp;

inline int sqr(int x) {
    return x * x;
}

int main() {
    scanf("%d", &n), sqn = ceil(sqrt(n));
    for (int i = 1; i <= n; ++i)
        scanf("%d", &a[i]);
    for (int i = 1; i <= n; ++i) {
        // 维护决策点
        for (auto it = chp.begin(); it != chp.end(); ++it)
            if (a[it->r] == a[i]) {
                // 上一个相同的原本会使 s 加一，但由于已经存在了这一个 a
                // 所以需要把这个区间与以前的合并
                if (it != chp.begin())
                    (it - 1)->l = it->l;
                chp.erase(it);
                break;
            }
        // 添加新的决策点
        chp.insert(chp.begin(), {chp.empty() ? 1 : chp.front().r + 1, i});
        // 因为 s <= sqrt(n)
        while (chp.size() > sqn)
            chp.pop_back();

        // dp 转移
        dp[i] = inf;
        for (int it = 0; it < chp.size(); ++it)
            dp[i] = std::min(dp[i], dp[chp[it].l - 1] + sqr(it + 1));
    }
    printf("%d\n", dp[n]);
    return 0;
}
```

---

## 作者：Big_Dinosaur (赞：0)

DP。

设 $dp_i$ 为前 $i$ 组数据需要消耗的最小耗时，则 $dp_i=\min^{i}_{j=1} dp_i+|S|^2$，$S$ 为 $j+1\sim i$ 中不同数的个数。

这个 DP 是 $n^2$ 的，考虑优化。

可以发现 $dp$ 数组的性质：

1. $dp_i$ 答案只可能从满足 $j=1$ 或 $a_j\ne a_k(j+1\le k\le i)$ 的 $j$ 转移。容易想到，如果一段数组的前一个数在该段数组中出现过，将它加入该段数组后该段数组不同数字个数不变，用时不变。这之前的时间由于少了一个数，减少了，更优。
2. $dp_i\le i$。每一段只有一个数即可。
3. 由 $2$ 得到能转移得到更优解的 $j$ 只有 $\lfloor\sqrt{i}\rfloor$ 个，这样额外的贡献小于等于 $i$。

set 维护每一个数最后一次出现位置所构成的序列，对最大的 $\lfloor\sqrt{i}\rfloor$ 个转移即可。

时间复杂度为 $O(n\log n + n\sqrt{n})$。前者为 set 的复杂度，后者为 DP 的。

```cpp
#include<bits/stdc++.h>
#define int long long
#define ri register int
#define pii pair<int,int>
#define mp make_pair
#define fi first
#define se second
using namespace std;
namespace IO{
	char ibuf[(1<<20)+1],*iS,*iT;
	#if ONLINE_JUDGE
		#define gh() (iS==iT?iT=(iS=ibuf)+fread(ibuf,1,(1<<20)+1,stdin),(iS==iT?EOF:*iS++):*iS++)
 	#else
		#define gh() getchar()
	#endif
	inline int r(){
		int o=1,p=0;
		char q=gh();
		while(q<'0'||q>'9'){if(q=='-')o=-1;q=gh();}
		while(q>='0'&&q<='9'){p=(p<<1)+(p<<3)+(q^48);q=gh();}
		return o*p;
	}
	inline char gc(){char q=gh();while(q<=' ')q=gh();return q;}
	inline string gs(){string s="";char g=gh();while(g<=' ')g=gh();while(g>' '){s+=g;g=gh();}return s;}
	inline void Wi(int _){
		if(_==0)return;if(_<0){_=-_;putchar('-');}
		Wi(_/10);putchar((_%10)^48);
	}
	inline void wln(int J){if(J==0)putchar('0');else Wi(J);putchar('\n');}
	inline void w(int J){if(J==0)putchar('0');else Wi(J);}
	inline void ww(int J){if(J==0)putchar('0');else Wi(J);putchar(' ');}
}
using namespace IO;
namespace D1n0{
	int T,n,a[211111],ma,k,dp[211111];
	map<int,int>mp;//维护位置
	set<int,greater<int> >s;//维护序列
	inline void zyt(){
		n=r();
		memset(dp,1,sizeof dp);dp[0]=0;
		s.insert(0);
		for(ri i=1;i<=n;++i){
			a[i]=r();
			int ls=mp[a[i]];
			mp[a[i]]=i;
			set<int,greater<int> >::iterator it;
			int S=0;
			if(ls!=0)s.erase(ls);s.insert(i);
			for(it=s.begin();it!=s.end();++it){
				++S;
				dp[i]=min(dp[i],dp[*it]+(S-1)*(S-1));
				if(S*S>i)break;
			}
		}
		wln(dp[n]);
	}
}
signed main(){D1n0::zyt();}
```

---

## 作者：Null_h (赞：0)

## 前言

场切，但是原题，红温。

## 思路

发现形式很 dp，记 $f_i$ 表示前 $i$ 个分成若干组所需要的最小代价。可以通过枚举最后一段的长度进行朴素转移，但是显然复杂度上天。

考虑优化转移过程。

对于一个 $f_i$：

首先显然会有一种每个数自成一组的分割方案，答案为序列长度，因为区间的贡献是元素种类的平方，所以这个元素种类最大为 $\sqrt{i}$。

以及对于所有元素种类相同最后一个区间，显然最长的最优，我们记录每一次出现新元素时的位置，仅利用这些位置进行转移即可得到最优解，这个位置可以通过 $i-1$ 处的位置信息直接维护，滚动掉一维即可。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=2e5+10;
int f[2][510],a[N],g[2][510],dp[N];
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		if(a[i]==a[i-1])i--,n--;
	}
	int w=sqrt(n)+1;
	for(int i=1;i<=n;i++){
		int t=i%2;
		int x=0;
		g[t][++x]=a[i-1];
		f[t][x]=i-1;
		dp[i]=dp[i-1]+1;
		for(int j=1;j<=w;j++){
			if(g[t^1][j]==a[i]){
				continue;	
			}
			g[t][++x]=g[t^1][j];
			f[t][x]=f[t^1][j];
			dp[i]=min(dp[i],dp[f[t][x]]+x*x);
			if(f[t][x]==0||x>w)break;
		}
	}
	cout<<dp[n];
	return 0;
}
```

---

## 作者：Helloworldwuyuze (赞：0)

# P11311 题解

## Des

给定序列 $a_n$，将这 $n$ 个数分成若干段，每一段的代价是颜色数量的平方，求怎么划分能够得到最小代价。

### Sol

首先，很显然的，这个问题有一个上界是 $n$，也就是每个点单独放在一段。

也就是说，对于我们划分的一段区间 $[l,r]$，它里面的颜色数量最多是 $\sqrt n$ 的。多于 $\sqrt n$ 的地方我们并不会转移过来。

考虑动态规划。我们设 $f_i$ 表示考虑到第 $i$ 个位置的最小代价，显然的，我们可以得到一个这样的转移方程：
$$
f_i = \min_{j=0}^{i-1} f_j + w^2(j+1,i)
$$
这里 $w(l,r)$ 表示 $[l,r]$ 内的颜色数量。

很显然，对于固定的一个 $i$ 来说，代价函数 $w(j,i)$ 对于 $j$ 是单调不增的。而我们又只关心那些使得 $w(j,i)\le \sqrt n$ 的 $j$。而如果有 $j_1,j_2$ 使得 $w(j_1,i) = w(j_2,i)$，那么我们一定取 $j_1,j_2$ 中更小的那个转移过来。

这样下来，一个点 $i$ 就只会有 $O(\sqrt n)$ 个决策点可以转移过来。接下来考虑我们如何维护这些决策点。

考虑到维护决策点相当于维护每个 $w(j,i)$ 中最小的 $j$，那么先考虑如何维护 $w(j,i)$。

注意到一个颜色 $a_i$ 只会给从上一个 $a_i$ 出现的地方 $+1$ 到 $i$，也就是 $[lst_{a_i}+1,i]$ 的地方贡献一个颜色，因此区间加单点查询即可维护 $w$ 数组。

而每一次必然有 $w(lst_{a_i},i) = w(lst_{a_i}+1,i)+1$，这是因为 $lst_{a_i}$ 这个地方是从 $i$ 往前第一次出现的 $a_i$。

因此，在修改过后就一定有 $w(lst_{a_i},i) = w(lst_{a_i}+1,i)$，也就是说，原来处于 $lst_{a_i}+1$ 的决策点完全可以被 $lst_{a_i}$ 取代，而之前与之后的都是区间加一，并不影响前后大小关系，因此只有 $lst_{a_i}+1$ 会被删除。

这样，我们每次区间加，然后删去一个决策点，再删掉那些颜色数量已经超过 $\sqrt n$ 的决策点，再遍历全部决策点求最小值，再把 $i$ 加入决策点中即可。

注意到我们还需要一个区间加单点求和的数据结构，这会使复杂度变成 $O(n\sqrt n\log n)$，显然不可接受。

但是注意到修改操作只会进行 $O(n)$ 次，而查询操作会进行 $O(n\sqrt n)$ 次，因此写一个 $O(\sqrt n)$ 修改 $O(1)$ 查询的块块平衡复杂度即可。

另外，那些决策点可以使用 `set` 维护，因为每个决策点只会被删除一次加入一次，所以复杂度正确。总复杂度 $O(n\sqrt n+n\log n)$，其中 $n\log n$ 可以忽视。

### Code

```cpp
using namespace std;
const int INF = 0x3f3f3f3f;
typedef pair<int,int> PII;
typedef pair<int,PII> PIII;
typedef pair<int,bool*> PIB;
const int N = 2e5 + 10;
const int M = 1e6 + 10;
const int B = 400;
inline int max(int x,int y){ return x<y ? y : x; }
inline int min(int x,int y){ return x<y ? x : y; }

int n, a[N], f[N], b[N], tot;
set<int> opt;

int blk[N], le[N], ri[N], s[N], tag[N], cnt;
void init(){
	for(int i=1;i<=n;++i){
		blk[i] = (i-1)/B+1;
		le[i] = (blk[i]-1)*B + 1;
		ri[i] = blk[i] * B;
	}
	cnt = blk[n];
}
inline void update(int l,int r){
	if(blk[l] == blk[r]){
		for(int i=l;i<=r;++i)	++s[i];
		return ;
	}
	for(int i=l;i<=ri[l];++i)	++s[i];
	for(int i=le[r];i<=r;++i)	++s[i];
	for(int i=blk[l]+1;i<blk[r];++i)	++tag[i];
}
inline int query(int x){ return s[x] + tag[blk[x]]; }

int lst[N];

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cin>>n; init();
	for(int i=1;i<=n;++i)	cin>>a[i], b[++tot] = a[i];
	sort(b+1, b+1+tot);
	tot = unique(b+1, b+1+tot) - b - 1;
	for(int i=1;i<=n;++i)	a[i] = lower_bound(b+1, b+1+tot, a[i]) - b;
	opt.insert(0);
	memset(f, 0x3f, sizeof(f));
	f[0] = 0;
	for(int i=1;i<=n;++i){
		update(lst[a[i]]+1, i);
		if(lst[a[i]] != 0)	opt.erase(lst[a[i]]);
		while(true){
			int x = *opt.begin();
			if(query(x+1) * query(x+1) <= n)	break;
			opt.erase(x);
		}
		for(int x : opt){
			f[i] = min(f[i], f[x] + query(x+1) * query(x+1));
		}
		opt.insert(i), lst[a[i]] = i;
	}
	cout<<f[n]<<endl;
	return 0;
}
```

---

## 作者：Lele_Programmer (赞：0)

# P11311 题解

场切蓝，还可以。

## 思路

考虑动态规划，设 $f_i$ 为 $1$ 到 $i$ 的最短耗时，设 $j$ 表示最后一个段内种类数，那么外层枚举 $i$，内层枚举所有可能的 $j$，状态转移方程为 $f_i = \min(f_i, f_k+j^2)$，这里的 $k$ 表示应该从前面哪一个状态转移得到。很容易想到 $k$ 的值应当尽可能小，因为随着区间长度的增加，总耗时是逐渐递增的，尽量从耗时更小的地方转移。

那么记 $p_{i,j}$ 为，以 $i$ 为结束点，种类数为 $j$ 的段，左端点能够达到的最左端的位置，所以上文 $k=p_{i,j}-1$。

现在考虑一下上文所说枚举 $j$ 的值域，假设一个段内种类数为 $j$，那么耗费 $j^2$，当段长度小于 $j^2$ 时，将其全部切分为长度为 $1$ 的段似乎更划算，如果长度刚好为 $j^2$，那么等价于全部切分为长度为 $1$ 的段，所以，仅当存在一个段长度大于 $j^2$ 时，对应的 $j$ 才有可能对最小值做出贡献，因此 $j^2 < 2 \times 10^5$，即 $j < \sqrt{2 \times 10^5}$，此处负值舍去。

这样一来，状态转移的部分时间复杂度是 $\mathcal{O}(n \sqrt{n})$ 的。

接下来考虑如何构建 $p$ 数组。可以先枚举种类数 $t$，然后用双指针，从左往右扫。当种类数没有达到 $t$ 时，右端点向右移动。当恰好等于 $t$ 时，记录答案，然后右端点向右移动（因为尽可能让区间更长，左端点才能更靠左）。当大于 $t$ 时，左端点向右移动。

枚举的种类数最多为 $\sqrt{n}$，双指针是从左往右扫一遍，所以这一步总时间复杂度也为 $\mathcal{O}(n \sqrt{n})$。

最后发现读入的数字达到了 $10^9$ 级别，数组下标需要用到这些数字，因此做一遍离散化，这里需要排个序，时间复杂度 $\mathcal{O}(n \log n)$。

所以算法总时间复杂度是 $\mathcal{O}(n \log n + n \sqrt{n})$，可以通过。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

#define endl '\n'
#define FRR(file) freopen(file,"r",stdin)
#define FRW(file) freopen(file,"w",stdout)
#define TIMESTAMP cerr<<fixed<<setprecision(3)<<clock()*1.0/CLOCKS_PER_SEC<<"s"<<endl;
#define _rep(i,a,b) for (rint i=(a);i<=(b);++i)
#define _reps(i,a,b,c) for (int i=(a);i<=(b);c)
#define _rrep(i,a,b) for (int i=(a);i>=(b);--i)
#define _rreps(i,a,b,c) for (int i=(a);i>=(b);c)
#define _iter(i,a) for (auto i=a.begin();i!=a.end();++i)
#define _graph(i,u) for (int i=h[u];~i;i=ne[i])
#define rint register int
#define LL long long
typedef pair<int,int> pii;

namespace IO {
    inline void read(int &a) {
        int sym=1,num=0;
        char c=getchar();
        while (c<'0' || c>'9') {
            if (c=='-') {
                sym=-1;
            }
            c=getchar();
        }
        while (c>='0' && c<='9') {
            num=num*10+c-'0';
            c=getchar();
        }
        a=sym*num;
    }
    inline void write(int a) {
        if (a<0) {
            putchar('-');
            a*=-1;
        }
        if (a>=10) {
            write(a/10);
        }
        putchar(a%10+'0');
    }
}

using IO::read;

const int N=200005;
const int M=450;
const int inf=2e9;

int n;
int arr[N];
vector<int> nums;
int las[N];
int cnt[N],dif;
int p[N][M];
int f[N];

inline void add(int k) {
    if (!cnt[k]) dif++;
    cnt[k]++;
}

inline void del(int k) {
    cnt[k]--;
    if (!cnt[k]) dif--;
}

int main() {
    read(n);
    _rep(i,1,n) read(arr[i]),nums.emplace_back(arr[i]);
    sort(nums.begin(),nums.end());
    nums.erase(unique(nums.begin(),nums.end()),nums.end());
    _rep(i,1,n) arr[i]=lower_bound(nums.begin(),nums.end(),arr[i])-nums.begin();
    _rep(i,1,n) _rep(j,1,M-1) p[i][j]=inf;
    _rep(t,1,M-1) {
        rint l=1,r=0;
        while (r<=n) {
            if (dif==t) p[r][t]=l;
            if (r==n) break;
            if (dif>t && r-l+1>=t*t) del(arr[l++]);
            else add(arr[++r]);
        }
        while (l<=r) {
            if (dif==t) p[r][t]=min(p[r][t],l);
            del(arr[l++]);
        }
    }
    // _rep(i,1,n) {
    //     _rep(j,1,M-1) {
    //         if (j*j>n) break;
    //         printf("p[%d][%d] = %d\n",i,j,p[i][j]);
    //     }
    // }
    _rep(i,1,n) f[i]=inf;
    f[0]=0;
    _rep(i,1,n) {
        _rep(j,1,M-1) {
            if (p[i][j]==inf) continue;
            f[i]=min(f[i],f[p[i][j]-1]+j*j);
        }
        // printf("f[%d] = %d\n",i,f[i]);
    }
    printf("%d",f[n]);
    return 0;
}
```

---

## 作者：Jerry_heng (赞：0)

（一）

观察到答案最大为 $n$，那么但个区间最大不同元素数最大为 $\sqrt n$。

设 $dp_i$ 表示处理到第 $i$ 位时的最小答案。 $dp$  数组单调不减，那么对于以 $i$ 为右端点的划分区间，如果其中不同的数的个数一样，那么左端点越小越好。

而随着右端点的增加，不同的数的个数为 $j$ 的最小左端点 $now_j$ 也单调不减。而且只需要考虑 $j\le \sqrt n$ 即可。

可以用 map 处理每个数前后与其相同的数的位置。

（二）

AC 代码。

```cpp
//2024-11-24 20:18:27
#include<bits/stdc++.h>
#define db double
#define pb push_back
#define eb emplace_back
#define fi first
#define se second
#define mkp make_pair
#define pii pair<int,int>
#define int long long
using namespace std;
bool MBE;
inline int read(){
    int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-f;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    return x*f; 
}
const int mxn=2e5+10;
int dp[mxn],sum[mxn],las[mxn],nxt[mxn],n,a[mxn],now[mxn];
map<int,int>mp;
signed main(){
    #ifndef ONLINE_JUDGE
    freopen("in.txt","r",stdin);
    freopen("out.txt","w",stdout);
    #endif
   	n=read();
   	for(int i=1;i<=n;i++){
   		a[i]=read();
   		las[i]=mp[a[i]];
   		mp[a[i]]=i;
   	}
   	mp.clear();
   	for(int i=1;i<=n;i++){
   		mp[a[i]]=n+1;
   		dp[i]=1e18;
   	}
   	for(int i=n;i>=1;i--){
   		nxt[i]=mp[a[i]];
   		mp[a[i]]=i;
   	}
   	int p=sqrt(n);
   	dp[1]=1;
   	for(int j=1;j<=p;j++)
   		now[j]=1,sum[j]=1;
   	for(int i=2;i<=n;i++){
   		for(int j=1;j<=p;j++){
   			if(las[i]<now[j])sum[j]++;
   			while(sum[j]>j){
   				if(nxt[now[j]]>i)sum[j]--;
   				now[j]++;
   			}
   			dp[i]=min(dp[i],dp[now[j]-1]+(sum[j]*sum[j]));
   		}
   	}
   	printf("%lld\n",min(dp[n],n));
    bool MED;
    cerr<<(&MED-&MBE)/1048576.0<<" MB, "<<1000*clock()/CLOCKS_PER_SEC<<" ms\n";
    return 0;
}
```

---

## 作者：I_will_AKIOI (赞：0)

对于这种划分区间的题，做多了很容易想到 dp，设 $f_i$ 表示当前区间划分到 $i$ 的最小花费。然后可以枚举 $j$ 来转移，在枚举的过程中顺便记录 $[j+1,i]$ 的数字种类数，朴素 dp 可以做到 $O(n^2)$。

接着想办法优化。发现一种最简单的分割方式就是一个数分一段，这样的花费是 $n$，于是在转移过程中数字的种类数不能超过 $\sqrt{n}$ 个，想办法记录一下 $i$ 之前最晚出现前 $\sqrt{n}$ 种的数字的位置，只需要枚举这些位置即可进行转移，可以开一个 set 维护，时间复杂度为 $O(n \sqrt{n} \log n)$，注意需要初始化一下 $f_i$ 为数字种类数和 $i$ 的最小值。

```cpp
#include<bits/stdc++.h>
#define N 200005
using namespace std;
struct Data
{
	int x,y;
	bool operator<(const Data &w)const{return w.y<y;}
};//重载运算符，按位置从大到小排序
int n,m,tot,cnt,f[N],a[N];
map<int,int>vis;
set<Data>s;//维护数字出现的种类和位置
int main()
{
	ios::sync_with_stdio(0);
	cin>>n;
	m=sqrt(n);
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++)
	{ 
		if(vis[a[i]]) s.erase(Data{a[i],vis[a[i]]});//这个数字之前出现过，更新出现位置
		else tot++;
		s.insert(Data{a[i],i});
		if(s.size()>m) s.erase(*s.rbegin());//数字种类数超过根号n个，删除最先出现的
		vis[a[i]]=i;
		f[i]=min((long long)i,(long long)tot*tot);//初始化
		cnt=-1;
		for(auto now:s) cnt++,f[i]=min(f[i],f[now.y]+cnt*cnt);//转移
	}
	cout<<f[n];
	return 0;
}
```

---

## 作者：arrow_king (赞：0)

> 定义一个区间的代价为这个区间出现的数种类数的平方。给定一个长为 $n$ 的数列 $a_1,a_2,\dots,a_n$，求将该数列分成若干个区间后所有区间代价和的最小值。$n\le2\times10^5$，$1\le a_i\le10^9$。

这里是暴力分块优化 dp 做法。

$a_i$ 值域这么大肯定没用，直接离散化。

考虑一个朴素的 dp。套路地设 $dp_i$ 表示考虑到 $i$ 时的最小花费，那么有转移
$$
dp_i=\min_{1\le j\le i}\{dp_{j-1}+cnt(j,i)^2\}
$$
其中 $cnt(l,r)$ 表示区间内不同数的个数。定义 $dp_0=0$。

直接优化好像很难（我们还没有讨论 $cnt$ 的求法呢），但是我们有核心结论：

> 结论：最优划分中每个区间的 $cnt\le\sqrt n$。
>
> 如果最优策略中存在一个不满足该性质的区间 $[l,r]$，那么它的代价一定 $\gt r-l+1$。考虑将其拆分，每个数划成一个区间，此时的代价是 $r-l+1$，与假设不符。

由此我们得知每个 $i$ 的有效转移点只有 $\sqrt n$ 个（每个颜色 $cnt$ 只去最后一个）。考虑暴力维护这些决策点并统计答案。

然而我们还不知道怎么维护每个区间的 $cnt$。考虑到我们在一次转移中只会用到以 $i$ 为后缀的 $cnt$，因此使用一个数据结构来维护。当加入 $a_i$ 时，我们找到上一次 $a_i$ 的出现位置（记为 $pre_i$），那么 $\forall j\in(pre_i,i]$，$cnt(j,i)$ 都会因为 $a_i$ 而增加 $1$。因此变成了区间加单点查询的问题。

在维护决策点时，由于 $pre_i$ 是上一次 $a_i$ 出现的位置，因此 $cnt(pre_i+1,i)$ 一定比 $cnt(pre_i,i)$ 小 $1$，此时增加 $1$ 后与之相等，所以要删去（只留下最靠前的那一个）。同时我们暴力遍历每个待选决策点，看一下此时的颜色数和 $\sqrt n$ 的关系，如果大于 $\sqrt n$ 就把这个点删掉。可以用 set 维护决策点，每个决策点都只会被删除一次，总复杂度是 $O(n\log n)$。

然而对于每个决策点都要查询一次 $cnt$，用带 $\log$ 的数据结构太慢。因此我们用 $O(\sqrt n)$ 修改、$O(1)$ 单点查询的分块维护 $cnt$。

总时间复杂度是 $O(n\sqrt n)$，可以通过。（max time 493ms）

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<algorithm>
#include<cmath>
#include<set>
using namespace std;
#define int long long
#define ll long long
#define il inline
#define N 200005
#define sqr 450 
il ll read() {
	ll x=0,f=1;char c=getchar();
	while(c<'0'||c>'9') {if(c=='-') {f=-1;} c=getchar();}
	while(c>='0'&&c<='9') {x=(x<<3)+(x<<1)+(c^48);c=getchar();}
	return x*f;
}
const ll INF=0x3f3f3f3f3f3f3f3fll;
int n,a[N],bin[N],tot,sq;
int lst[N],pre[N];
int belong[N],st[sqr],ed[sqr],val[N],tag[sqr];
ll dp[N];
set<int> s;
il void modify(int l,int r,int v) {
	int bl=belong[l],br=belong[r];
	if(bl==br) {
		for(int i=l;i<=r;i++) val[i]+=v;
		return;
	}
	for(int i=l;i<=ed[bl];++i) val[i]+=v;
	for(int i=bl+1;i<br;++i) tag[i]+=v;
	for(int i=st[br];i<=r;++i) val[i]+=v;
}
il int query(int p) {
	return val[p]+tag[belong[p]];
}
vector<int> dbin;
il void del(int pos) {
	dbin.push_back(pos);
}
il ll sq2(ll x) {return x*x;}
signed main() {
	n=read(),sq=sqrt(n);
	for(int i=1;i<=n;i++) a[i]=read(),bin[i]=a[i];
	sort(bin+1,bin+n+1),tot=unique(bin+1,bin+n+1)-bin-1;
	for(int i=1;i<=n;i++) {
		a[i]=lower_bound(bin+1,bin+tot+1,a[i])-bin;
		pre[i]=lst[a[i]];lst[a[i]]=i;
	}
	for(int i=1;i<=sq;i++) st[i]=ed[i-1]+1,ed[i]=(n/sq)*i;
	ed[sq]=n;
	for(int i=1;i<=sq;i++) for(int j=st[i];j<=ed[i];j++) belong[j]=i;
	for(int i=1;i<=tot;i++) lst[i]=0;
	for(int i=1;i<=sq;i++) {
		ll cnt=0;dp[i]=INF;
		for(int j=i;j>=1;j--) {
			if(!lst[a[j]]) ++cnt;
			lst[a[j]]=1;
			dp[i]=min(dp[i],dp[j-1]+cnt*cnt);
		}
		for(int j=i;j>=1;j--) lst[a[j]]=0;
	}
	for(int i=sq,cnt=0;i>=1;i--) {
		if(!lst[a[i]]) ++cnt;
		lst[a[i]]=1;
		modify(i,i,cnt);
	}
	for(int i=sq;i>1;i--) if(query(i)!=query(i-1)) s.insert(i);
	s.insert(1);
	for(int i=sq+1;i<=n;i++) {
		modify(pre[i]+1,i,1);
    if(pre[i]!=0) del(pre[i]+1);
		for(auto p:s) {
			if(query(p)>sq) del(p);
			else break;
		}
		for(auto p:dbin) s.erase(p);
		dbin.clear();
		s.insert(i);
		dp[i]=INF;
		for(auto p:s) dp[i]=min(dp[i],dp[p-1]+sq2(query(p)));
	}
	printf("%lld\n",dp[n]);
	return 0;
}

```

---


# [SDOI2010] 所驼门王的宝藏

## 题目描述

在宽广的非洲荒漠中，生活着一群勤劳勇敢的羊驼家族。被族人恭称为“先知”的 AlpacaL.Sotomon 是这个家族的领袖，外人也称其为“所驼门王”。所驼门王毕生致力于维护家族的安定与和谐，他曾亲自率军粉碎河蟹帝国主义的野蛮侵略，为族人立下赫赫战功。所驼门王一生财宝无数，但因其生性节俭低调，他将财宝埋藏在自己设计的地下宫殿里，这也是今天 Henry Curtis 故事的起点。Henry 是一个爱财如命的贪婪家伙，而又非常聪明，他费尽心机谋划了这次盗窃行动，破解重重机关后来到这座地下宫殿前。

整座宫殿呈矩阵状，由 $R \times C$ 间矩形宫室组成，其中有 $N$ 间宫室里埋藏着宝藏，称作藏宝宫室。宫殿里外、相邻宫室间都由坚硬的实体墙阻隔，由一间宫室到达另一间只能通过所驼门王独创的移动方式——传送门。所驼门王为这 $N$ 间藏宝宫室每间都架设了一扇传送门，没有宝藏的宫室不设传送门，所有的宫室传送门分为三种：

1. “横天门”：由该门可以传送到同行的任一宫室；
2. “纵寰门”：由该门可以传送到同列的任一宫室；
3. “任意门”：由该门可以传送到以该门所在宫室为中心周围 $8$ 格中任一宫室（如果目标宫室存在的话）。

深谋远虑的 Henry 当然事先就搞到了所驼门王当年的宫殿招标册，书册上详细记录了每扇传送门所属宫室及类型。而且，虽然宫殿内外相隔，但他自行准备了一种便携式传送门，可将自己传送到殿内任意一间宫室开始寻宝，并在任意一间宫室结束后传送出宫。整座宫殿只许进出一次，且便携门无法进行宫室之间的传送。不过好在宫室内传送门的使用没有次数限制，每间宫室也可以多次出入。

现在 Henry 已经打开了便携门，即将选择一间宫室进入。为得到尽多宝藏，他希望安排一条路线，使走过的不同藏宝宫室尽可能多。请你告诉 Henry 这条路线最多行经不同藏宝宫室的数目。

## 说明/提示

数据规模和约定：

![](https://cdn.luogu.com.cn/upload/pic/1594.png)


## 样例 #1

### 输入

```
10 7 7
2 2 1
2 4 2
1 7 2
2 7 3
4 2 2
4 4 1
6 7 3
7 7 1
7 5 2
5 2 1```

### 输出

```
9```

# 题解

## 作者：Sue_Shallow (赞：41)

一个着实很水但是细节颇多的Tarjan题~~ 

恩没错，这道题的难点其实并不是很多，但是由于其细节非常多，于是导致这道题的AC率比较低。。   

我们来分析这道题目：怎么跟Tarjan扯上了关系呢？？  

首先我们考虑建图：关于这三个门，我们按照最平常的思路应该是对于三种门无一例外暴力前向星add()。  

但是想像一下假如我们有这样一组数据使某一行全部都是横天门，或者说某一列全部都是纵寰门，那么我们的建图就会跑到大概$O(n^{2})$或者$O(n^{2})$的速度，建图都成$n^{2}$了这还做啥。于是我们考虑优化。

那么由于各自的门的特殊性，我肯应该分开建图，也就是三种算法，对于每一行的横天门，我们将其建成一个环，对于每一列的纵寰门，我们也将其建成一个环。因为我们知道：每一行的所有横天门之间肯定都是相互通达，而每一列的所有纵寰门之间也肯定是相互通达的。所以我们可以说：

当你到达了某一行的一个横天门的时候，你就到达了这一行所有的横天门，当你到达了某一列的纵寰门的时候，你就到达了这一列所有的纵寰门。

于是我们完全可以将其建成一个环。而Tarjan的用途就来了。我们可以利用Tarjan将这两种环缩成点。而对于自由门本人并没有想到比暴力建边更好的方法，于是就暴力建边啦~~~。  

而对于这个建环的过程其实我们也是可以有一定的优化的，比如sort。当我们要建横天门的时候，我们肯定是想快点循环到当前行所有的横天门，于是我们就有了这么一个sort函数：
```
//我们这个sort函数的意思就是将同一行的所有横天门放到前面。 
bool xf_cmp(st1 a,st1 b){
    if(a.x!=b.x) return a.x<b.x;
    //不是同一行我们自然不用管 
    if(a.opt==1) return 1;
    //如果是横天门就先把他放在前面 
    if(b.opt==1) return 0; 
    return a.y<b.y;
}
```
然后对于纵寰门其实也是一个道理。
```
bool yf_cmp(st1 a,st1 b){
    if(a.y!=b.y) return a.y<b.y;
    if(a.opt==2) return 1;
    //如果是纵寰门就先把他放在前面 
    if(b.opt==2) return 0;
    return a.x<b.x;
}
```

接下来是真正的建环，我们在这里定义了一个first:表示每一次循环到的第一个横门。last:表示上一次扫到的横门。
```
    sort(point+1,point+all+1,xf_cmp);
    //我们想尽量快的循环到所有横天门，于是这个sort就是为了吧所有的横天门放在前面
	int first=1,last=1;
    //对于每一次循环到的第一个横门，我们记为first
    //规定last变量是上一个扫到的横门
    for(int i=1;i<=all;i++){ //横向建环 (横天门)
        if(point[i].x!=point[i+1].x){//相邻两个输入的坐标不在同一行
            if(first!=last)
            add(point[last].number,point[first].number);
            //我们连边肯定要连初始序号的啦
            last=first=i+1;
        }
        else{//在同一行
            if(point[last].opt==1)
            //如果i和i+1在同一行并且i是横天门就把last和i+1连起来
            add(point[last].number,point[i+1].number);
            if(point[i+1].opt==1)//如果i+1点是横天门
            last=i+1;//因为last是指上一个扫到的横天门，而且i+1是横天门，所以就更新last
            if(point[first].opt!=1)//如果first点不是横天门 
            //first要更新，last肯定也要更新 
            last=first=i+1;//那么更新last和first 
        }
    }
```

其实以上的过程就是利用了这个first和last的不断变换的过程进行建边.....然后纵寰门也是一样。

暴力建边自不必说，在这里我们有一个很头疼的问题，就是宝藏公室的记录。因为这里是一个有x,y的图，所以图的连边包括宝藏宫室的记录都比较麻烦。我们在这里引入一个STL里面的pair就很好解决了。pair就是对组，包含两个元素，我们可定义为是一个点的横纵坐标，然后就可以很愉快的用map了。

因为pair和map的引用，这个tarjan的建图就会很恶心（~~因为Yeasion并不喜欢用指针.....~~）但其实如果明白了Tarjan的原理，一切都并不难了。

我们首先扫描Tarjan之后的整个前向星，记录from和to在旧图中不属于一个点的位置，然后可以再定义一个map：mat进行记录，然后清空前向星的head之后我们就可以定义一个map指针从mat的头指向尾然后添加。当然这个mat的pair指的就是原来符合条件的前向星咯(belong[edge[i].from],belong[edge[i].to])。
```
for(int i=1;i<=total;i++){//for整个前向星 
        int f=edge[i].from;
        int t=edge[i].to;
        if(belong[f]!=belong[t])//如果在新图中不属于一个点 
        mat[pir(belong[f],belong[t])]=1;
    }
    memset(head,0,sizeof(head)); total=0;
    //清空前向星留下在新图接着用咯~~ 
    for(it=mat.begin();it!=mat.end();it++){
        add(it->first.first,it->first.second); 
        //it->first.first表示mat这个map的第一个元素的pair中的前面 
        //it->first.second表示mat的第一个元素的pair中的后面那个元素 
        ind[it->first.second]++;
    }
```
然后我们现在有了一个有向无环的图，然后我们要在这上面跑最长路（边权为1嘛），然后大家肯定就都知道怎么做了...DP啊，DAG上跑DP就是了！
```
 for(int i=1;i<=cnt;i++){
        if(ind[i]==0){//入度为0 从入度为0开始跑 
        //因为我们可以知道从入度不为0的节点开始跑的ans一定小于从入度为0的节点开始跑的ans 
            dfs(i,0);//入度为0当然没有前前驱节点咯 
            ans=max(ans,dp[i]);//取max 
        }
    }
void dfs(int now,int fa){//动规 
//now是当前节点，fa是从哪里来的节点。可以理解为树上的父亲节点。 
    if(dp[now]>sum[now])return ;
    dp[now]=sum[now];
    for(int i=head[now];i;i=edge[i].next){
        if(edge[i].to==fa) continue;
        dfs(edge[i].to,now);
        dp[now]=max(dp[now],dp[edge[i].to]+sum[now]);
        //要知道，在新图中跑过了i节点就相当于是在就图中跑了sum[i]个宝藏室
    }
}
```
恩没错就是这样，那么我们整个题就跑完了，最后我们输出ans就可以了。
```
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<utility>
#include<map>
#define MAXN 100010
#define pir pair<int,int> 
using namespace std;
int all,n,m,ind[MAXN];
map<pir,bool>mat;//就是记录新图的连边。哪些边可以连（基于新图。
map<pir, int>tre;//用来记录某一个有宝藏的坐标位置的序号
map<pir,bool>::iterator it;//::iterator是STL里,代表指针
int dx[9]={0,-1,-1,-1,0,0,1,1,1};
int dy[9]={0,-1,0,1,-1,1,-1,0,1};
struct st1{
    int x;//横坐标 
    int y;//纵坐标 
    int opt;//门的类型 
    int number;//因为要sort所以肯定要记录初始序号啦 
}point[MAXN];
struct st2{//前向星用 
    int from;
    int to;
    int next;
}edge[MAXN*100];
int total,head[MAXN];
void add(int f,int t){//前向星 
    total++;
    edge[total].from=f;
    edge[total].to=t;
    edge[total].next=head[f];
    head[f]=total;
}
bool xf_cmp(st1 a,st1 b){
    if(a.x!=b.x) return a.x<b.x;
    if(a.opt==1) return 1;
    //如果是横天门就先把他放在前面 
    if(b.opt==1) return 0; 
    return a.y<b.y;
}
bool yf_cmp(st1 a,st1 b){
    if(a.y!=b.y) return a.y<b.y;
    if(a.opt==2) return 1;
    //如果是纵寰门就先把他放在前面 
    if(b.opt==2) return 0;
    return a.x<b.x;
}
inline int read()
{  
   int s=0,w=1;  
   char ch=getchar();  
   while(ch<='0'||ch>'9')
   {
        if(ch=='-')
            w=-1;
        ch=getchar();
    }  
   while(ch>='0'&&ch<='9')
   s=s*10+ch-'0',ch=getchar();  
   return s*w;  
} 
int Yeasion[MAXN];//Yeasion[i]表示i的dfs序 
int Nein[MAXN];//Nein[i]表示i节点所能回到的最早的节点的编号 
int ken,top,stack[MAXN];
bool insta[MAXN];//flag[i]表示i是不是被访问过，insta[i]表示在不在栈中。 
int belong[MAXN],cnt;
int sum[MAXN];
void Tarjan(int now){//基本的Tarjan 
    Yeasion[now]=Nein[now]=++ken;
    stack[++top]=now; insta[now]=1;
    for(int i=head[now];i;i=edge[i].next){
        if(!Yeasion[edge[i].to]){
            Tarjan(edge[i].to);
            Nein[now]=min(Nein[now],Nein[edge[i].to]);
        }
        else if(!belong[edge[i].to])
        Nein[now]=min(Nein[now],Yeasion[edge[i].to]);
    }
    if(Yeasion[now]==Nein[now]){
        cnt++; int pass;
        do{
            pass=stack[top--];
            belong[pass]=cnt;
            sum[cnt]++; //记录cnt含原图中点的个数 
            insta[pass]=0;
        }while(pass!=now);
    }
}
int ans,dp[MAXN];       
void dfs(int now,int fa){//动规 
//now是当前节点，fa是从哪里来的节点。可以理解为树上的父亲节点。 
    if(dp[now]>sum[now])return ;
    dp[now]=sum[now];
    for(int i=head[now];i;i=edge[i].next){
        if(edge[i].to==fa) continue;
        dfs(edge[i].to,now);
        dp[now]=max(dp[now],dp[edge[i].to]+sum[now]);
        //要知道，在新图中跑过了i节点就相当于是在就图中跑了sum[i]个宝藏室
    }
}
int main(){
    all=read(); n=read(); m=read();
    for(int i=1;i<=all;i++){
        point[i].x=read();
        point[i].y=read();
        point[i].opt=read();
        point[i].number=i;
        tre[pir(point[i].x,point[i].y)]=i;
        //记录坐标为(point[x],point[y])的点的序号为i
    }
    sort(point+1,point+all+1,xf_cmp);
    //我们想尽量快的循环到所有横天门，于是这个sort就是为了吧所有的横天门放在前面
    int first=1,last=1;
    //对于每一次循环到的第一个横门，我们记为first
    //规定last变量是上一个扫到的横门
    for(int i=1;i<=all;i++){ //横向建环 (横天门)
        if(point[i].x!=point[i+1].x){//相邻两个输入的坐标不在同一行
            if(first!=last)
            add(point[last].number,point[first].number);
            //我们连边肯定要连初始序号的啦
            last=first=i+1;
        }
        else{//在同一行
            if(point[last].opt==1)
            //如果i和i+1在同一行并且i是横天门就把last和i+1连起来
            add(point[last].number,point[i+1].number);
            if(point[i+1].opt==1)//如果i+1点是横天门
            last=i+1;//因为last是指上一个扫到的横天门，而且i+1是横天门，所以就更新last
            if(point[first].opt!=1)//如果first点不是横天门 
            //first要更新，last肯定也要更新 
            last=first=i+1;//那么更新last和first 
        }
    }
    sort(point+1,point+all+1,yf_cmp);
    first=1,last=1;//别忘了重置first和last 
    //同理，我们要想尽快的循环完所有的纵寰门，那么sort吧所有的纵寰门排在前面
    //然后循环结构基本和上面是完全一样的qwq 
    for(int i=1;i<=all;i++){  //纵向建环 (纵寰门) 
        if(point[i].y!=point[i+1].y){
        //纵寰门可不要打成point[i].x！！照搬上文是不行滴 
            if(first!=last)
            add(point[last].number,point[first].number);
            last=i+1; first=i+1;
            //将last和first都更新为i+1。 
        }
        else{
            if(point[last].opt==2)
            add(point[last].number,point[i+1].number);
            if(point[i+1].opt==2)
            last=i+1;
            if(point[first].opt!=2)
            last=first=i+1;
        }
    } 
 	for(int i=1;i<=all;i++)
     if(point[i].opt==3){
     	for(int j=1;j<=8;j++)
     	if(tre.count(pir(point[i].x+dx[j],point[i].y+dy[j])))
     	add(point[i].number,tre[pir(point[i].x+dx[j],point[i].y+dy[j])]);
     }    
    for(int i=1;i<=all;i++)
    //因为一行上的横天门和一列上的纵寰门我们都已经连成了一个环。
    //所以肯定是强连通分量，所以我们就可以利用Tarjan进行缩点 
    if(!Yeasion[i]) Tarjan(i);
    //因为一次tarjan不一定能够遍历完所有的点 所以放在for里面
    //因为tarjan已经完成了，所以下面我们用到新图的节点都应该在belong[]里面。 
    for(int i=1;i<=total;i++){//for整个前向星 
        int f=edge[i].from;
        int t=edge[i].to;
        if(belong[f]!=belong[t])//如果在新图中不属于一个点 
        mat[pir(belong[f],belong[t])]=1;
    }
    memset(head,0,sizeof(head)); total=0;
    //清空前向星留下在新图接着用咯~~ 
    for(it=mat.begin();it!=mat.end();it++){
        add(it->first.first,it->first.second); 
        //it->first.first表示mat这个map的第一个元素的pair中的前面 
        //it->first.second表示mat的第一个元素的pair中的后面那个元素 
        ind[it->first.second]++;
    }
    //上面的操作简而言之就是：旧图中的edge如果在新图中依然可以连，就把他们连起来。
    for(int i=1;i<=cnt;i++){
        if(ind[i]==0){//入度为0 从入度为0开始跑 
        //因为我们可以知道从入度不为0的节点开始跑的ans一定小于从入度为0的节点开始跑的ans 
            dfs(i,0);//入度为0当然没有前前驱节点咯 
            ans=max(ans,dp[i]);//取max 
        }
    }
    printf("%d",ans); return 0;
}
```
Blog's Address：www.cnblogs.com/Yeasio-Nein

---

## 作者：yingjz (赞：33)

### 思路

如果我们能把整张图（$R \times C$）开出来的话那么问题就转化为：给出一个有向图，求最多一次能经过的点的数量，其中点可以重复经过。

由于点可以重复经过所以可以考虑缩点，缩点以后直接在 *DAG* 上 $DP$ 即可，方程：
$$
dp[v] = \max\{dp[u] + val[v]\}
$$
其中 $val[v]$ 表示 $v$ 这个强连通分量的点的数量。

那么现在的问题就是由于 $R, C$ 非常大，边的数量非常大（边数 $O(n^2)$），不能直接存下。边的数量的瓶颈在于“横天门”和“纵寰门”，所以一个常规的思路对于每行和每列建一个特殊的点，这样就不用点到点的连边，边的数量降到了 $O(n)$。

> （这是一个例子）
>
> [![luo2403.png](https://i.loli.net/2019/05/14/5cda801045d3725916.png)](https://i.loli.net/2019/05/14/5cda801045d3725916.png)

### 实现

$1$ ~ $R$ 是每一行的特殊点；

$R+1$ ~ $R + C$ 是每一列的特殊点；

$R+C+1$ ~ $R + C + n$ 是藏宝宫室。

```c++
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <algorithm>
using namespace std;

const int N = 100007, T = 2100007, M = 1000007;
const int dx[8] = {1, 1, 1, 0, 0, -1, -1, -1};
const int dy[8] = {1, 0, -1, 1, -1, 1, 0, -1};
int n, r, c, t, edc, edu[M], edv[M];
int ecnt, head[T], nxt[M], vet[M];
int qhead, qtail, que[T], f[T], in[T];
int stac[T], top, val[T], col[T], stamp, dfn[T], low[T], cnt;
bool instac[T];
struct Node {
	int x, y, t;
	bool operator <(const Node &ano) const { 
		return x < ano.x || x == ano.x && y < ano.y;
	}
} a[N]; 

inline void add(int u, int v) {
	edu[++edc] = u; edv[edc] = v;
	
	vet[++ecnt] = v; nxt[ecnt] = head[u];
	head[u] = ecnt;
}

inline void eadd(int u, int v) {
	vet[++ecnt] = v; nxt[ecnt] = head[u];
	head[u] = ecnt;
}

void tarjan(int u) {
	dfn[u] = low[u] = ++stamp;
	stac[++top] = u; instac[u] = true;
	for (int e = head[u]; e; e = nxt[e]) {
		int v = vet[e];
		if (!dfn[v]) {
			tarjan(v); low[u] = min(low[u], low[v]);
		} else if (instac[v]) 
			low[u] = min(low[u], dfn[v]);
	}
	if (dfn[u] == low[u]) {
		col[u] = ++cnt; val[cnt] = u > r + c;
		while (stac[top] != u) {
			col[stac[top]] = cnt;
			val[cnt] += (stac[top] > r + c);
			instac[stac[top--]] = false;
		}
		instac[stac[top--]] = false;
	}
}

int getid(int x, int y) {
	int l = 1, r = n;
	while (l <= r) {
		int mid = (l + r) >> 1;
		if (a[mid].x == x && a[mid].y == y) return mid;
		else if (a[mid].x < x || a[mid].x == x && a[mid].y < y) l = mid + 1;
		else r = mid - 1;
	}
	return -1;
}

int main() {
	scanf("%d%d%d", &n, &r, &c);
	for (int i = 1; i <= n; ++i) 
		scanf("%d%d%d", &a[i].x, &a[i].y, &a[i].t);
	sort(a + 1, a + 1 + n);
	for (int i = 1; i <= n; ++i) {
		//处理额外点对当前点的连边
		add(a[i].x, r + c + i); 
		add(r + a[i].y, r + c + i);
		//处理当前点对其它点的连边
		if (a[i].t == 1) add(r + c + i, a[i].x);
		else if (a[i].t == 2) add(r + c + i, r + a[i].y);
		else {
			for (int k = 0; k < 8; ++k) {
				int x = a[i].x + dx[k], y = a[i].y + dy[k];
				if (x >= 1 && x <= r && y >= 1 && y <= c) {
					int id = getid(x, y);
					if (id != -1) add(r + c + i, r + c + id);
				} 
			}
		}
	}
	//缩点 
	t = r + c + n; 
	for (int i = 1; i <= t; ++i)
		if (!dfn[i]) tarjan(i);
	ecnt = 0; memset(head, 0, sizeof(head));
	for (int i = 1; i <= edc; ++i)
	 	if (col[edu[i]] != col[edv[i]]) {
		 	eadd(col[edu[i]], col[edv[i]]);
		 	++in[col[edv[i]]];
		 }
	//拓扑排序
	qhead = 0; qtail = -1;
	for (int i = 1; i <= cnt; ++i) 
		if (!in[i]) {
			que[++qtail] = i;
			f[i] = val[i];
		}
	while (qhead <= qtail) {
		int u = que[qhead++];
		for (int e = head[u]; e; e = nxt[e]) {
			int v = vet[e];
			f[v] = max(f[v], f[u] + val[v]);
			if (--in[v] == 0) que[++qtail] = v;
		}
	}
	//统计答案
	int ans = 0;
	for (int i = 1; i <= cnt; ++i)
		ans = max(ans, f[i]);
	printf("%d\n", ans);
	return 0;
}
```



---

## 作者：爱迪生 (赞：14)

## 其实主要难度在建图&&存图
## 存完图后就是强连通分量缩点+拓扑排序就行了
### 那怎么存图呢QAQ??
#### 因为$R*C$最大是$10^{12}$
#### 所以直接硬存肯定不行
### 机智的我想到了这样一个存图方法：
1. 自由门直接看一下周围有没有点就行了
1. 对于每行（列）都建一个新的点（这一行（列）代表的点），这个点连接着行（列）上的每一个点
1. 横天门向他所在的这一行代表点连一条边
1. 纵寰门向他所在的这一列代表点连一条边

### 这样就OK了！！
### 好了不说废话了，上代码：
```c++
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <iostream>
#include <cstdlib>
#include <queue>
#include <cassert>
#define N 2500000
using namespace std;
int n,r,c,target[N],last[N],prev[N],cnt;
bool used[N],used1[N];
int target1[N],last1[N],prev1[N],cnt1,s[N],cnts;
int size[N];
int fa[N];
int target2[N],last2[N],prev2[N],cnt2,ind[N],fro[N];
int dp[N];
int dx[8]={0,1,1,1,0,-1,-1,-1},dy[8]={1,1,0,-1,-1,-1,0,1};
int q[N];
struct gz{
    int x,y,type,id;
    long long z;
}a[200000];
long long count(long long x,long long y)
{
    return (x-1)*c+y;
}
void add1(int x,int y)
{
    target[++cnt]=y;
    fro[cnt]=x;
    prev[cnt]=last[x];
    last[x]=cnt;
}
void add2(int x,int y)
{
    target1[++cnt1]=y;
    prev1[cnt1]=last1[x];
    last1[x]=cnt1;
}
void add3(int x,int y)
{
    ind[y]++;
    target2[++cnt2]=y;
    prev2[cnt2]=last2[x];
    last2[x]=cnt2;
}
bool cmp(gz a,gz b)
{
    return ((long long)(a.x-1)*c+a.y)<((long long)(b.x-1)*c+b.y);
}
int ef(long long x)
{
    int l=1,r=n;
    while(l<r-1)
    {
        int mid=(l+r)/2;
        if(a[mid].z<=x)
            l=mid;
        else
            r=mid-1;
    }
    if(a[r].z==x)
        return r;
    if(a[l].z==x)
        return l;
    return 0;
}
void dfs(int x)
{
    used[x]=1;
    int ptr=last[x];
    while(ptr)
    {
        int y=target[ptr];
        if(used[y]!=1)
        {
            dfs(y);
        }
        ptr=prev[ptr];
    }
    s[++s[0]]=x;
}
void dfs1(int x,int fat)
{
    used1[x]=1;
    fa[x]=fat;
    int ptr=last1[x];
    while(ptr)
    {
        int y=target1[ptr];
        if(used1[y]==0)
        {
            dfs1(y,fat);
        }
        ptr=prev1[ptr];
    }
}
int main()
{
    scanf("%d%d%d",&n,&r,&c);
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d%d",&a[i].x,&a[i].y,&a[i].type);
        a[i].z=count(a[i].x,a[i].y);
        a[i].id=i;
        add1(n+a[i].x,i);
        add2(i,n+a[i].x);
        add1(n+r+a[i].y,i);
        add2(i,n+r+a[i].y);
        if(a[i].type==1)
        {
            add1(i,n+a[i].x);
            add2(n+a[i].x,i);
        }
        if(a[i].type==2)
        {
            add1(i,n+r+a[i].y);
            add2(n+r+a[i].y,i);
        }
    }
    sort(a+1,a+n+1,cmp);
    for(int i=1;i<=n;i++)
    {
        if(a[i].type==3)
        {
            for(int j=0;j<=7;j++)
            {
                long long x=a[i].x+dx[j];
                long long y=a[i].y+dy[j];
                int k=ef(count(x,y));
                if(k!=0)
                {
                    add1(a[i].id,a[k].id);
                    add2(a[k].id,a[i].id);
                }
            }
        }
    }
    n=n+r+c;
    for(int i=1;i<=n;i++)
    {
        if(used[i]==0)
            dfs(i);
    }
    for(int i=s[0];i>=1;i--)
    {
        if(used1[s[i]]==0)
            dfs1(s[i],s[i]);
    }
    for(int i=1;i<=n-r-c;i++)
    {
        size[fa[i]]++;
    }
    for(int i=1;i<=cnt;i++)
    {
        int x=target[i];
        int y=fro[i];
        if(fa[x]!=fa[y])
            add3(fa[y],fa[x]);
    }
    int h=1,t=0;
    for(int i=1;i<=n;i++)
    {
        if(fa[i]==i&&ind[i]==0)
        {
            dp[i]=size[i];
            q[++t]=i;
        }
    }
    int ans=0;
    while(h<=t)
    {
        int x=q[h++];
        ans=max(ans,dp[x]);
        int ptr=last2[x];
        while(ptr)
        {
            int y=target2[ptr];
            dp[y]=max(dp[y],dp[x]+size[y]);
            ind[y]--;
            if(ind[y]==0)
            {
                q[++t]=y;
            }
            ptr=prev2[ptr];
        }
    }
    printf("%d",ans);
    
    return 0;
}
```

---

## 作者：lzx2005 (赞：13)

首先，我们可以由三种传送门的定义得出一个大致的图论模型——把每个宫室看作一个点，有宝藏的宫室可以通过传送门向其他宫室连出有向边，并且每个有宝藏的宫室点权为  $1$，其他宫室点权为。答案即为所有路径中点权和的最大值。

而对于传送门的连边我们容易想到以下方法：

1. 对于每一个“横天门”，我们向同一行的所有宫室连出一条有向边。
2. 对于每一个“纵寰门”，我们向同一列的所有宫室连出一条有向边。
3. 对于每一个“任意门”，我们向“九宫格”内的另外八个宫室连出一条有向边。

由于每个宫室可以经过多次，每个传送门可以使用多次，所以同一个强连通分量内的点一定可以归到同一条路径上，并且不影响其他强连通分量的决策。所以，将建好的图 Tarjan 缩点后建新图拓扑 DP 求最长链。记边数为 $E$ ，缩点 + DP 部分时间复杂度 $O(N+E)$，建图部分时空复杂度 $O(E)$。按上述建图方法可通过测试点 $1\sim 4$，得 $40$ 分。

不难发现，本题的复杂度瓶颈在于 $E$，所以考虑缩小 $E$ 的规模。容易想到：没有宝藏的宫室，既没有对其他宫室的出边，也没有对答案有贡献的点权，可以忽略不计，不参与建图。

则建边方法转化为：

1. 对于每一个“横天门”，我们向同一行的所有有宝藏的宫室连出一条有向边。
2. 对于每一个“纵寰门”，我们向同一列的所有有宝藏的宫室连出一条有向边。
3. 对于每一个“任意门”，我们向“九宫格”内的另外八个宫室中有宝藏的连出一条有向边。

这样一来，$E$ 的规模大大下降。可得 $40\sim 70$ 分不等。

显然，对于满分做法而言，$E$ 的规模仍需进一步缩小。

我们发现，最初的建边方法经过优化后效率已经提高不少，但是在某些特殊的数据下发生退化。例如所有的传送门均为”横天门“，并且所有传送门都在同一行，在这种情况下，$E$ 的规模仍然达到了 $N^2$ 级别，显然不能满足题目要求。

考虑如何优化该种情况下的建边复杂度。我们有一个经典的思想，我们新建出 $R+C$ 个节点。令节点 $1\sim R$ 表示每一行，节点 $R+1\sim R+C$ 表示每一列，节点 $R+C+1\sim R+C+N$ 表示有宝藏的宫室。

那么，建边方式发生如下变化：

1. 对于每一个“横天门”，我们向表示这一行的节点连出一条有向边。
2. 对于每一个“纵寰门”，我们向表示这一列的节点连出一条有向边。
3. 对于每一个“任意门”，我们向“九宫格”内的另外八个宫室中有宝藏的连出一条有向边。
4. 对于节点 $1\sim R$，向这一行所有有宝藏的宫室连出一条有向边。
5. 对于节点 $R+1\sim R+C$，向这一列所有有宝藏的宫室连出一条有向边。

这样一来，对于 $4,5$ 两个操作，连出的边的总数固定在 $2\times N$ 条。而对于 $1,2$ 两个操作，一个“横天门“或一个”纵寰门“显然只会对外连出一条边。对于操作 $3$ 显然连出的边不会超过 $8\times N$ 条。那么，最坏情况下，$E=2\times N+8\times N=10\times N\leq 10\times 10^5$ 。 可以通过本题。

部分细节问题：

1. 数组大小应开至 $R+C+N\le 10^6+10^6+10^5=2.1\times 10^6$ 。
2. 对于”任意门“周围的宫室是否有宝藏可以使用 STL map 储存，但常数较大，需要开启 O2 优化，有兴趣的选手可以考虑使用哈希表进一步优化时间复杂度。

参考程序：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define re register
#define ll long long
inline int read()
{
	int f=1,lzx=0;char c=getchar();
	while(c>'9'||c<'0'){if(c=='-')f=-f;c=getchar();}
	while(c<='9'&&c>='0'){lzx=lzx*10+c-'0';c=getchar();}
	return lzx*f;
}
map<pair<int,int>,int> mapp;
int dx[10]={-1,-1,-1,0,0,1,1,1},dy[10]={-1,0,1,-1,1,-1,1,0};
const int N=1e7+10;
int xx[N],yy[N],from[N],to[N],cnt,head[N],dis[N],dfn[N],low[N],stak[N],top,Time,col[N],disa[N],col_cnt;
inline void add(int x,int y)
{
	from[++cnt]=head[x];
	head[x]=cnt;
	to[cnt]=y;
	return;
}
int from_new[N],to_new[N],cnt_new,head_new[N],f[N],ru[N];
inline void add_new(int x,int y)
{
	from_new[++cnt_new]=head_new[x];
	head_new[x]=cnt_new;
	to_new[cnt_new]=y;
	return;
}
inline void Tarjan(int x)
{
	dfn[x]=low[x]=++Time;stak[++top]=x;
	for(re int i=head[x];i;i=from[i])
	{
		int v=to[i];
		if(!dfn[v])
		{
			Tarjan(v);
			low[x]=min(low[x],low[v]);
		}
		else if(!col[v])low[x]=min(low[x],dfn[v]);
	}
	if(dfn[x]==low[x])
	{
		col[x]=++col_cnt;
		disa[col[x]]=dis[x];
		while(stak[top]!=x)
		{
			col[stak[top]]=col[x];
			disa[col[x]]+=dis[stak[top]];
			top--;
		}
		top--;
	}
	return;
}
int main()
{
	int n=read(),r=read(),c=read();
	for(re int i=1;i<=n;i++)
	{
		dis[r+c+i]=1;
		int x=read(),y=read(),z=read();
		add(x,r+c+i);add(y+r,r+c+i);
		if(z==1)add(r+c+i,x);
		if(z==2)add(r+c+i,y+r);
		if(z==3)xx[i]=x,yy[i]=y;
		mapp[make_pair(x,y)]=i;
	}
	for(re int i=1;i<=n;i++)if(xx[i])
		for(re int j=0;j<8;j++)
			if(mapp[make_pair(xx[i]+dx[j],yy[i]+dy[j])])
				add(r+c+i,mapp[make_pair(xx[i]+dx[j],yy[i]+dy[j])]+r+c);		
	for(re int i=1;i<=r+c+n;i++)
		if(!dfn[i])
			Tarjan(i);
	for(re int i=1;i<=n+r+c;i++)
		for(re int j=head[i];j;j=from[j])
		{
			int v=to[j];
			if(col[i]!=col[v])
			{
				add_new(col[i],col[v]);
				ru[col[v]]++;
			}
		}
	queue<int> q;
	for(re int i=1;i<=col_cnt;i++)
		if(!ru[i])
		{
			f[i]=disa[i];
			q.push(i);
		}
	while(!q.empty())
	{
		int u=q.front();
		for(re int i=head_new[u];i;i=from_new[i])
		{
			int v=to_new[i];ru[v]--;
			f[v]=max(f[v],f[u]+disa[v]);
			if(!ru[v])q.push(v);
		}
		q.pop();
	}
	int ans=0;
	for(re int i=1;i<=col_cnt;i++)
		ans=max(ans,f[i]);
	cout<<ans<<endl;
	return 0;
}
```



---

## 作者：YoungNeal (赞：11)

题解在博客[食用](https://www.cnblogs.com/YoungNeal/p/9123725.html)效果更佳哦~


## Solution

一眼 $Tarjan$ 缩点拓扑求最长路。

然而如果直接暴力建边的话会$T$上天，因为这题要建的边贼多，比如说一行全是横门，暴力建边是两两之间都建的，最坏复杂度 $O(n^2)$。

考虑优化建图。

观察到一行的横门或者一列的纵门一定是在同一个连通分量里的，所以我们对于同一行的横门或者同一行的纵门就没必要两两连边了，保证直接连成一个环就好了。

但是如果一行中有很多横门，同时也有很多其他的门，那么还是会每个横门向每个别的种类的门连边，边数还是太多。

但是因为一行中的横门是一个环，所以对于一行中的其它宫室，只需从环上向这个宫室连一条边就够了。

于是得到了下面成型的算法思路：

我们对于每一行的横门，每一列的纵门，还有自由门分开建图。

第一遍建出横门向外连的所有边。第二遍建出纵门向外连的所有边。第三遍建出自由门向外连的所有边。

我们模拟第一次建边。

因为要优化建边过程的复杂度，我们想尽可能的先循环到横门，所以可以先排序一遍，这样的话如果当前不是横门就可以直接 $break$ 掉了。

对于所有宫室，我们按照行数排序，保证一行上的所有宫室都会一块循环到。如果行数相同，那么我们优先将横门排在前面。

对于循环到的每一行的第一个横门，我们将其记为 $first$，同时规定 $last$ 变量是上一个扫到的横门。

然后开始扫这一行的宫室。

如果当前宫室是横门，那么 $add(last,now)$,同时令 $last=now$。

否则，$add(last,now)$。

最后，$add(last,first)$。

这就完成了一行的扫描。

纵门也是同理。

对于自由门，我没有想出太好的建边方案，于是直接暴力枚举每个自由门周围的八个格子是否有宝藏。这里可以用 $STL$ 的 $map$ 来存储每个点是否有宝藏，但是我这里因为害怕被卡常，手写了个 $Hash$ 表。

其它就没什么了。

~~我还毒瘤的加上了fread快读~~    
~~毒瘤的cnblogs说自由门是敏感词汇qwq~~

## Code

```cpp
#include<queue>
#include<cstdio>
#include<cctype>
#include<algorithm>
#define N 100005
#define mod 10007
#define ll long long
#define min(A,B) ((A)<(B)?(A):(B))
#define max(A,B) ((A)>(B)?(A):(B))

int x,n,m;
bool in[N];
int cnt,tot,sum;
int head2[N],deg[N];
std::queue<int> topo;
int stk[N],top,dis[N];
int head[N],belong[N];
int dfn[N],low[N],sze[N];
int hshhead[mod+2],hshcnt;

int dx[]={-1,0,1,0,1,1,-1,-1};
int dy[]={0,1,0,-1,1,-1,1,-1};

struct Edge{
    int to,nxt;
}edge[N<<3],edge2[N<<3];

struct HASH{
    ll data;
    int nxt,idx;
}h[N<<2];

void hshadd(ll x,ll z,int i){
    h[++hshcnt].data=z;
    h[hshcnt].idx=i;
    h[hshcnt].nxt=hshhead[x];
    hshhead[x]=hshcnt;
}

struct Node{
    int a,b,c,id;
}type[N];

bool cmp1(Node x,Node y){
    if(x.a!=y.a) return x.a<y.a;
    if(x.c==1) return 1;
    if(y.c==1) return 0;
    return x.b<y.b;
}

bool cmp2(Node x,Node y){
    if(x.b!=y.b) return x.b<y.b;
    if(x.c==2) return 1;
    if(y.c==2) return 0;
    return x.a<y.a;
}

void add(int x,int y){
    edge[++cnt].to=y;
    edge[cnt].nxt=head[x];
    head[x]=cnt;
}

void add2(int x,int y){
    edge2[++cnt].to=y;
    edge2[cnt].nxt=head2[x];
    head2[x]=cnt;
}

inline char nc(){
    static const int BS=1<<22;
    static unsigned char buf[BS],*st,*ed;
    if(st==ed) ed=ed+fread(st=buf,1,BS,stdin);
    return ed==st?EOF:*st++;
}
//#define nc getchar
inline int getint(){
    int x=0;char ch;
    while(!isdigit(ch=nc()));
    while(isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=nc();
    return x;
}

void tarjan(int now){
    dfn[now]=low[now]=++sum;
    stk[++top]=now;in[now]=1;
    for(int i=head[now];i;i=edge[i].nxt){
        int to=edge[i].to;
        if(!dfn[to]){
            tarjan(to);
            low[now]=min(low[now],low[to]);
        }
        else if(in[to])
            low[now]=min(low[now],dfn[to]);
    }
    if(low[now]==dfn[now]){
        int y;belong[now]=++tot;
        do{
            sze[tot]++;
            y=stk[top--];
            in[y]=0;
            belong[y]=tot;
        }while(y!=now);
    }
}

void Hash(){
    for(int i=1;i<=x;i++){
        ll p=1LL*(type[i].a-1)*m+type[i].b;
        ll q=p%mod;
        hshadd(q,p,i);
    }
}

int hsh(ll q){
    ll p=q%mod;
    for(int i=hshhead[p];i;i=h[i].nxt){
        if(h[i].data==q)
            return h[i].idx;
    }
    return 0;
}

signed main(){
    x=getint(),n=getint(),m=getint();
    for(int i=1;i<=x;i++){
        type[i].a=getint();
        type[i].b=getint();
        type[i].c=getint();
        type[i].id=i;
    }
    Hash();
    std::sort(type+1,type+1+x,cmp1);
    for(int i=1;i<=x;i++){
        if(type[i].c==1){
            int fina=0;
            int fist,last=0;
            for(int j=i;j<=x and type[i].a==type[j].a;j++){
                fina=j;
                if(type[i].c==type[j].c){
                    if(!last){
                        last=type[j].id;
                        fist=last;
                        continue;
                    }
                    add(last,type[j].id);
                    last=type[j].id;
                }
                else add(type[i].id,type[j].id);
            }
            if(last!=fist)
                add(last,fist);
            i=fina;
        }
    }
    std::sort(type+1,type+1+x,cmp2);
    for(int i=1;i<=x;i++){
        if(type[i].c==2){
            int fina=0;
            int fist,last=0;
            for(int j=i;j<=x and type[i].b==type[j].b;j++){
                fina=j;
                if(type[i].c==type[j].c){
                    if(!last){
                        last=type[j].id;
                        fist=type[j].id;
                        continue;
                    }
                    add(last,type[j].id);
                    last=type[j].id;
                }
                else add(type[i].id,type[j].id);
            }
            if(last!=fist)
                add(last,fist);
            i=fina;
        }
    }
    for(int i=1;i<=x;i++){
        for(int k=0;k<8;k++){
            if(type[i].c!=3) continue;
            int nx=type[i].a+dx[k];
            int ny=type[i].b+dy[k];
            int p=hsh(1LL*(nx-1)*m+ny);
            if(!p)
                continue;
            add(type[i].id,p);
        }
    }    
    for(int i=1;i<=x;i++){
        if(!dfn[i]) 
            tarjan(i);
    }
    cnt=0;
    for(int i=1;i<=x;i++){
        for(int p=head[i];p;p=edge[p].nxt){
            int to=edge[p].to;
            if(belong[i]==belong[to]) continue;
            deg[belong[to]]++;
            add2(belong[i],belong[to]);
        }
    }
    int ans=0;
    for(int i=1;i<=tot;i++){
        if(!deg[i]){
            topo.push(i);
            dis[i]=sze[i];
            ans=max(ans,sze[i]);
        }
    }
    while(topo.size()){
        int u=topo.front();topo.pop();
        for(int i=head2[u];i;i=edge2[i].nxt){
            int to=edge2[i].to;
            dis[to]=max(dis[to],dis[u]+sze[to]);
            ans=max(ans,dis[to]);
            deg[to]--;
            if(!deg[to])
                topo.push(to);
        }
    }
    printf("%d\n",ans);
    return 0;
}
```



---

## 作者：碳六灵 (赞：6)

# 我热爱根号数据结构,所以我用了kdtree来做此题

考虑这三种连边分别为:

1,横天门即一个$1\times c$的矩阵内的点连边

2,纵寰门即一个$r \times 1$的矩阵内的点连边

3,任意门即一个$3 \times 3$的矩阵内的点连边

这不就是矩阵连边吗????

直接上二维线段树或者$kdtree$即可

二维线段树连边可以参考[炸弹(一维线段树连边+缩点)](https://www.luogu.org/problem/P5025)

对于$kdtree$如果像线段树一样直接用$kdtree$上的对应点连向其他点,且每个结点的权值为$1$,会发现对于根所有点都可以到达会无限输出$n$,所以需要考虑另外一种建图方式

对于$kdtree$上的点可以是作为虚点,每个虚点都对应上了原有的实点(即输出给出的点)

对于初始化,每个虚点向其两个儿子和对于实点连边即可

对于每个点的门类型再每个实点向可连边虚点连边即可

然后就像普通的一样跑$tarjan+Dp$即可

复杂度$O(n\sqrt n)$

~~不开O2还过不了~~

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <vector>
typedef long long ll;
#define inc(i) (++ (i))
#define dec(i) (-- (i))
#define Rep(i , a , b) for(int i = (a) , i##Limit = (b) ; i <= i##Limit ; inc(i))
#define rep(i , a , b) for(int i = (a) , i##Limit = (b) ; i >= i##Limit ; dec(i))
using namespace std;

inline int read() {
	int Num = 0; char C = getchar();
	while(!isdigit(C)) C = getchar();
	while(isdigit(C)) Num = Num * 10 + C - 48 , C = getchar();
	return Num;
}
const int N = 200000 + 7;
int n , r , c , opt[N] , D , tot , Root , Id[N] , P[N] , Cnt , W[N] , In[N];
struct YYZ {
	int X[2] , id;
}A[N];
struct NFO {
	int L[2] , R[2] , Son[2];
	YYZ x;
}T[N];
vector <int> E[N] , F[N];
inline void Add(int u , int v) {
	if(u && v) F[u].push_back(v);
}
inline void Update(int u) {
	Rep(i , 0 , 1) {
		T[u].L[i] = T[u].R[i] = T[u].x.X[i];
		Rep(j , 0 , 1) if(T[u].Son[j])
			T[u].L[i] = min(T[u].L[i] , T[T[u].Son[j]].L[i]) , T[u].R[i] = max(T[u].R[i] , T[T[u].Son[j]].R[i]);
	}
}
int Build(int l , int r , int DD) {
	if(l > r) return 0;
	int u = inc(tot) , Mid = (l + r) >> 1;
	D = DD , nth_element(A + l , A + 1 + Mid , A + 1 + r , [](YYZ A , YYZ B){ return A.X[D] < B.X[D]; });
	T[u].x = A[Mid] , T[u].Son[0] = Build(l , Mid - 1 , DD ^ 1) , T[u].Son[1] = Build(Mid + 1 , r , DD ^ 1);
	Add(u , T[u].Son[0]) , Add(u , T[u].Son[1]) , Add(u , T[u].x.id);
	Update(u);
	return u;
}
void Get(int u , int l , int r , int d , int U) {
	if(min(T[u].R[0] , r) < max(T[u].L[0] , l) || min(T[u].R[1] , U) < max(T[u].L[1] , d)) return;
	if(l <= T[u].L[0] && r >= T[u].R[0] && d <= T[u].L[1] && U >= T[u].R[1]) {
		P[inc(Cnt)] = u;
		return;
	}
	if(T[u].x.X[0] >= l && T[u].x.X[0] <= r && T[u].x.X[1] >= d && T[u].x.X[1] <= U) P[inc(Cnt)] = T[u].x.id;
	Get(T[u].Son[0] , l , r , d , U) , Get(T[u].Son[1] , l , r , d , U);
}
int DFN[N] , Low[N] , Nowtime , Col[N] , col , Stack[N] , top , Dp[N] , Ans;
bool ins[N] , Book[N];
void Tarjan(int u) {
	DFN[u] = Low[u] = inc(Nowtime);
	Stack[inc(top)] = u , ins[u] = 1;
	for(auto v: F[u]) {
		if(!DFN[v]) {
			Tarjan(v);
			Low[u] = min(Low[u] , Low[v]);
		}
		else if(ins[v]) Low[u] = min(Low[u] , DFN[v]);
	}
	if(Low[u] == DFN[u]) {
		Col[u] = inc(col) , W[col] += (u <= n) , ins[u] = 0;
		while(Stack[top] != u) Col[Stack[top]] = col , W[col] += (Stack[top] <= n) , ins[Stack[top]] = 0 , dec(top);
		dec(top);
	}
}
void DP(int u) {
	Book[u] = 1 , Dp[u] = W[u];
	for(auto v : E[u]) {
		if(!Book[v]) DP(v);
		Dp[u] = max(Dp[u] , Dp[v] + W[u]);
	} Ans = max(Ans , Dp[u]);
}

int main() {
	n = read() , r = read() , c = read() , tot = n;
	Rep(i , 1 , n) A[i].X[0] = read() , A[i].X[1] = read() , opt[i] = read() , A[i].id = i;
	Root = Build(1 , n , 0);
	Rep(i , 1 , n) {
		Cnt = 0;
		if(opt[A[i].id] == 1) Get(Root , A[i].X[0] , A[i].X[0] , 1 , c);
		else if(opt[A[i].id] == 2) Get(Root , 1 , r , A[i].X[1] , A[i].X[1]);
		else Get(Root , A[i].X[0] - 1 , A[i].X[0] + 1 , A[i].X[1] - 1 , A[i].X[1] + 1);
		Rep(j , 1 , Cnt) Add(A[i].id , P[j]);
	}
	Rep(i , 1 , tot) if(!DFN[i]) Tarjan(i);
	Rep(i , 1 , tot) for(auto v: F[i]) if(Col[i] != Col[v]) E[Col[i]].push_back(Col[v]) , inc(In[Col[v]]);
	Rep(i , 1 , col) if(!In[i]) DP(i);
	printf("%d\n" , Ans);
	return 0;
}
```

---

## 作者：hzoi_liuchang (赞：4)

## 分析
先放一张图便于理解
![](https://img2020.cnblogs.com/blog/1996139/202007/1996139-20200725192052969-1367869743.png)

这一道题如果暴力建图会被卡成$n^{2}$

实际上，在我们暴力建图的时候，有很多边都是重复的

假如一行当中有许多横天门的话，我们就不必要把这一行当中的所有点和每一个横天门都连上一条边

因为横天门之间是相互联通的，无论我们走到哪一个横天门，都可以走到同一行的另一个横天门

因此，我们可以先把这些横天门连成一个环，在这些横天门中选取一个点作为代表，连向同一行中不是横天门的点

对于纵寰门也是如此

剩下的任意门直接暴力扫一遍建边即可
## 代码
``` cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=2e6+5;
int head[maxn],tot=1;
inline int read(){
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0' || ch>'9'){
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while(ch>='0' && ch<='9'){
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x*f;
}
int dx[10]={0,0,1,-1,1,1,-1,-1};
int dy[10]={1,-1,0,0,-1,1,-1,1};
struct asd{
    int to,next;
}b[maxn];
void ad(int aa,int bb){
    b[tot].to=bb;
    b[tot].next=head[aa];
    head[aa]=tot++;
}
struct jll{
    int jlx,jly,jlb,id;
}jl[maxn];
int n,r,c,nx,ny,nb,rd[maxn];
int dfn[maxn],low[maxn],dfnc,sta[maxn],top,js,shuyu[maxn],siz[maxn];
void tar(int xx){
    dfn[xx]=low[xx]=++dfnc;
    sta[++top]=xx;
    for(int i=head[xx];i!=-1;i=b[i].next){
        int u=b[i].to;
        if(!dfn[u]){
            tar(u);
            low[xx]=min(low[u],low[xx]);
        } else if(!shuyu[u]){
            low[xx]=min(low[xx],dfn[u]);
        }
    }
    if(dfn[xx]==low[xx]){
        js++;
        while(1){
            int now=sta[top--];
            shuyu[now]=js;
            siz[js]++;
            if(now==xx) break;
        }
    }
}
map<pair<int,int>,bool> mp;
struct asd2{
    int to,next,val;
}b2[maxn];
int h2[maxn],t2=1;
void ad2(int aa,int bb,int cc){
    b2[t2].to=bb;
    b2[t2].next=h2[aa];
    b2[t2].val=cc;
    h2[aa]=t2++;
}
int f[maxn],ans=0;
void tp(){
    queue<int> q;
    q.push(0);
    while(!q.empty()){
        int now=q.front();
        q.pop();
        for(int i=h2[now];i!=-1;i=b2[i].next){
            int u=b2[i].to;
            rd[u]--;
            f[u]=max(f[u],f[now]+b2[i].val);
            if(rd[u]==0) q.push(u);
        }
    }
}
bool cmplh(jll aa,jll bb){
    if(aa.jlb==bb.jlb && aa.jlx==bb.jlx) return aa.jly<bb.jly;
    if(aa.jlb==bb.jlb) return aa.jlx<bb.jlx;
    return aa.jlb<bb.jlb;
}
bool cmpll(jll aa,jll bb){
    if(aa.jlb==bb.jlb && aa.jly==bb.jly) return aa.jlx<bb.jlx;
    if(aa.jlb==bb.jlb) return aa.jly<bb.jly;
    if(aa.jlb==2) return 1;
    return 0;
}
bool cmpry(jll aa,jll bb){
    return aa.jlb>bb.jlb;
}
map<pair<int,int>,int> mpp;
int htm[maxn],ztm[maxn];
int main(){
    memset(head,-1,sizeof(head));
    memset(h2,-1,sizeof(h2));
    n=read(),r=read(),c=read();
    for(int i=1;i<=n;i++){
        jl[i].jlx=read();
        jl[i].jly=read();
        jl[i].jlb=read();
        jl[i].id=i;
        mpp[make_pair(jl[i].jlx,jl[i].jly)]=jl[i].id;
    }
    sort(jl+1,jl+1+n,cmplh);
    for(int i=1;i<=n;i++){
        if(jl[i].jlb!=1) break;
        int ks=jl[i].id;
        while(jl[i].jlx==jl[i+1].jlx && jl[i+1].jlb==1){
            ad(jl[i].id,jl[i+1].id);
            i++;
        }
        ad(jl[i].id,ks);
        htm[jl[i].jlx]=jl[i].id;
    }
    sort(jl+1,jl+1+n,cmpll);
    for(int i=1;i<=n;i++){
        if(jl[i].jlb!=2) break;
        int ks=jl[i].id;
        while(jl[i].jly==jl[i+1].jly && jl[i+1].jlb==2){
            ad(jl[i].id,jl[i+1].id);
            i++;
        }
        ad(jl[i].id,ks);
        ztm[jl[i].jly]=jl[i].id;
    }
    sort(jl+1,jl+1+n,cmpry);
    for(int i=1;i<=n;i++){
        if(jl[i].jlb!=3) break;
        int nx=jl[i].jlx,ny=jl[i].jly;
        for(int j=0;j<8;j++){
            int mx=nx+dx[j];
            int my=ny+dy[j];
            if(mpp[make_pair(mx,my)]){
                ad(jl[i].id,mpp[make_pair(mx,my)]);
            }
        }
    }
    for(int i=1;i<=n;i++){
        if(jl[i].jlb==1) continue;
        int ks=jl[i].id;
        if(htm[jl[i].jlx]!=0) ad(htm[jl[i].jlx],jl[i].id);
    }
    for(int i=1;i<=n;i++){
        if(jl[i].jlb==2) continue;
        int ks=jl[i].id;
        if(ztm[jl[i].jly]!=0) ad(ztm[jl[i].jly],jl[i].id);
    }
    for(int i=1;i<=n;i++){
        if(!dfn[i]) tar(i);
    }
    for(int i=1;i<=n;i++){
        for(int j=head[i];j!=-1;j=b[j].next){
            int u=b[j].to;
            if(shuyu[i]!=shuyu[u] && mp[make_pair(shuyu[i],shuyu[u])]==0){
                ad2(shuyu[i],shuyu[u],siz[shuyu[u]]);
                rd[shuyu[u]]++;
                mp[make_pair(shuyu[i],shuyu[u])]=1;
            }
        }
    }
    for(int i=1;i<=js;i++){
        if(rd[i]==0){
            ad2(0,i,siz[i]);
            rd[i]++;
        }
    }
    tp();
    for(int i=1;i<=js;i++){
        ans=max(ans,f[i]);
    }
    printf("%d\n",ans);
    return 0;
}
```


---

## 作者：Ebola (赞：3)

这题很明显是Tarjan缩点+DAG上DP，但这题的难点在于优化建边

对于前40分，还是比较好拿的，只要n方建边，跑一遍Tarjan，建出DAG就可以了

不知道为什么，很多人都说要拓扑排序，但我认为直接在DAG上跑DP就可以了，排这个序有什么意义呢？

那么在DAG上DP时，为了达到O(n)级别，需要注意剪枝。设dp[x]表示从x出发的路径中，点权和最大的路径的点权和，那么可以列出DP方程：dp[x]=max{w[x]+dp[y]}（x有一条边直接到y），其中w[x]表示缩点后这个强连通分量所包含的原点数量。不难想到，如果dp[x]>w[x]，说明x点已经完成了DP，没必要重复进行，因此DP过程中搜索到一个这样的点时可以直接退出

那么要AC这题，需要优化建边。试想，根据暴力建边法，假如所有的门都在同一行，且都是“横天门”，那么就会建出N²条边来，但其实缩点后这些边都没有了，那么这些边肯定有很多是冗余的

考虑一个强连通分量的构成，不难想到，如果让所有可以互相联通的点构成一个环，而不是两两连边，它们最终还是会形成强连通分量，且边数大大减少

那么我们可以将同一行的“横天门”建成一个环，同一列的“纵寰门”建成一个环，至于“自由门”，暴力建边未尝不可。建边过程细节颇多，需要注意不能建了环就忽略了可以到达的其它门。将两种门分开来建边，建边前进行排序，是一种比较好的处理办法，也不排除有更妙的方法

```cpp
#include<bits/stdc++.h>
#define pii pair<int,int>
using namespace std;

int read()
{
	int x=0;char c=getchar();
	while(c<'0'||c>'9') c=getchar();
	while(c>='0'&&c<='9')x=x*10+c-'0',c=getchar();
	return x;
}

const int N=100010;
struct Edge{int from,to,next;} e[100*N];
int h[N],sum=0;
struct DOOR{int x,y,ty,id;} door[N];
int pre[N],low[N],dfn=0;
int scc[N],w[N],tot=0;
stack<int> sta;
int deg[N],dp[N];
map<pii,int> H;
map<pii,bool> mat;
map<pii,bool>::iterator it;

bool cmp1(const DOOR &a,const DOOR &b)
{
	if(a.x!=b.x) return a.x<b.x;
	if(a.ty==1) return 1;
	if(b.ty==1) return 0;
	return a.y<b.y;
}

bool cmp2(const DOOR &a,const DOOR &b)
{
	if(a.y!=b.y) return a.y<b.y;
	if(a.ty==2) return 1;
	if(b.ty==2) return 0;
	return a.x<b.x;
}

void add_edge(int u,int v)
{
	sum++;
	e[sum].from=u;
	e[sum].to=v;
	e[sum].next=h[u];
	h[u]=sum;
}

void Tarjan(int u)
{
	pre[u]=low[u]=++dfn;
	sta.push(u);
	for(int tmp=h[u];tmp;tmp=e[tmp].next)
		if(!pre[e[tmp].to])
		{
			Tarjan(e[tmp].to);
			low[u]=min(low[u],low[e[tmp].to]);
		}
		else if(!scc[e[tmp].to]) low[u]=min(low[u],pre[e[tmp].to]);
	if(pre[u]==low[u])
	{
		int o;
		tot++;
		do{
			o=sta.top();
			scc[o]=tot;
			w[tot]++;
			sta.pop();
		}while(u!=o);
	}
}

void dfs(int u,int fa)
{
	if(dp[u]>w[u]) return;
	dp[u]=w[u];
	for(int tmp=h[u];tmp;tmp=e[tmp].next)
	{
		int v=e[tmp].to;
		if(v==fa) continue;
		dfs(v,u);
		dp[u]=max(dp[u],dp[v]+w[u]);
	}
}

int main()
{
	int n=read(),r=read(),c=read();
	for(int i=1;i<=n;i++)
	{
		door[i].x=read();
		door[i].y=read();
		door[i].ty=read();
		door[i].id=i;
		H[pii(door[i].x,door[i].y)]=i;
	}
	sort(door+1,door+1+n,cmp1);
	int first=1,last=1;
	for(int i=1;i<=n;i++)
		if(door[i].x!=door[i+1].x)
		{
			if(last!=first) add_edge(door[last].id,door[first].id);
			last=first=i+1;
		}
		else
		{
			if(door[last].ty==1) add_edge(door[last].id,door[i+1].id);
			if(door[i+1].ty==1) last=i+1;
			if(door[first].ty!=1) last=first=i+1;
		}
	sort(door+1,door+1+n,cmp2);
	first=1,last=1;
	for(int i=1;i<=n;i++)
		if(door[i].y!=door[i+1].y)
		{
			if(last!=first) add_edge(door[last].id,door[first].id);
			last=first=i+1;
		}
		else
		{
			if(door[last].ty==2) add_edge(door[last].id,door[i+1].id);
			if(door[i+1].ty==2) last=i+1;
			if(door[first].ty!=2) last=first=i+1;
		}
	for(int i=1;i<=n;i++)
		if(door[i].ty==3)
		{
			int x=door[i].x,y=door[i].y;
			if(H.count(pii(x-1,y-1))) add_edge(door[i].id,H[pii(x-1,y-1)]);
			if(H.count(pii(x-1,y))) add_edge(door[i].id,H[pii(x-1,y)]);
			if(H.count(pii(x-1,y+1))) add_edge(door[i].id,H[pii(x-1,y+1)]);
			if(H.count(pii(x,y-1))) add_edge(door[i].id,H[pii(x,y-1)]);
			if(H.count(pii(x,y+1))) add_edge(door[i].id,H[pii(x,y+1)]);
			if(H.count(pii(x+1,y-1))) add_edge(door[i].id,H[pii(x+1,y-1)]);
			if(H.count(pii(x+1,y))) add_edge(door[i].id,H[pii(x+1,y)]);
			if(H.count(pii(x+1,y+1))) add_edge(door[i].id,H[pii(x+1,y+1)]);
		}
	for(int i=1;i<=n;i++)
		if(!pre[i]) Tarjan(i);
	for(int i=1;i<=sum;i++)
	{
		int u=e[i].from,v=e[i].to;
		if(scc[u]!=scc[v]) mat[pii(scc[u],scc[v])]=1;
	}
	memset(h,0,sizeof(h));sum=0;
	for(it=mat.begin();it!=mat.end();it++)
	{
		add_edge(it->first.first,it->first.second);
		deg[it->first.second]++;
	}
	int ans=0;
	for(int i=1;i<=tot;i++)
		if(deg[i]==0)
		{
			dfs(i,0);
			ans=max(ans,dp[i]);
		}
	cout<<ans<<endl;
	return 0;
}

```

---

## 作者：xyz32768 (赞：3)

- 容易想到，如果在第$i$个藏宝宫室可以传送到第$j$个藏宝宫室，就连一条$i->j$的有向边，$Tarjan$强连通分量缩点之后，在**新图**上找出一条路径，使得这条路径上的所有点对应的强连通分量大小之和最大，这个可以按照拓扑序进行递推来实现。

- 但是，在建图上存在一个问题，**从横天门或纵寰门引出的边可能特别多**。在极端情况下，$10^5$个横天门在同一行里出现，这样时空复杂度都是无法承受的。考虑这一点进行优化：由于在同一行的横天门一定属于同一个强连通分量，所以在建边时，只需要对在同一行的横天门构建出一个环即可，不需要两两进行连边。而此行内的其他宫室，只需要从这个环中的任意一点向这个宫室连边即可。对于纵寰门也是一样。

- 此外，在建图的实现上有一些小技巧，具体见代码。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
const int N = 1e5 + 5, M = 2e6 + 5, R = 1e6 + 5;
int n, ecnt, nxt[M], adj[N], go[M], dfn[N], low[N], times, sum, num[N],
top, stk[N], bel[N], ecnt2, nxt2[M], adj2[N], go2[M], tot, st[N], ed[N],
las[R], now[R], nex[R], row[N], cnt[N], res[N], H, T, Q[N]; bool ins[N];
struct cyx {int x, y, t, id;} a[N];
void add_edge(int u, int v) {
    nxt[++ecnt] = adj[u]; adj[u] = ecnt; go[ecnt] = v;
}
void add_edge2(int u, int v) {
    nxt2[++ecnt2] = adj2[u]; adj2[u] = ecnt2; go2[ecnt2] = v;
}
bool comp1(cyx a, cyx b) {
    if (a.x != b.x) return a.x < b.x;
    return a.t < b.t;
}
bool comp2(cyx a, cyx b) {
    if (a.y != b.y) return a.y < b.y;
    return a.t < b.t;
}
bool comp3(cyx a, cyx b) {
    if (a.x != b.x) return a.x < b.x;
    return a.y < b.y;
}
void Tarjan(int u) {
    dfn[u] = low[u] = ++times; ins[stk[++top] = u] = 1;
    for (int e = adj[u], v; e; e = nxt[e])
        if (!dfn[v = go[e]]) {
            Tarjan(v);
            low[u] = min(low[u], low[v]);
        }
        else if (ins[v]) low[u] = min(low[u], dfn[v]);
    if (dfn[u] == low[u]) {
        num[bel[u] = ++sum] = 1; ins[u] = 0; int v;
        while (v = stk[top--], v != u) num[bel[v] = sum]++, ins[v] = 0;
    }
}
void topo() {
    int i; H = T = 0;
    for (i = 1; i <= sum; i++) if (!cnt[i]) Q[++T] = i, res[i] = num[i];
    while (H < T) {
        int u = Q[++H];
        for (int e = adj2[u], v; e; e = nxt2[e]) {
            if (!(--cnt[v = go2[e]])) Q[++T] = v;
            res[v] = max(res[v], res[u] + num[v]);
        }
    }
}
int main() {
    int i, j; n = read(); read(); read();
    for (i = 1; i <= n; i++) a[i].x = read(), a[i].y = read(),
        a[i].t = read(), a[i].id = i;
    sort(a + 1, a + n + 1, comp1);
    for (i = 1; i <= n;) {
        int fir = 0, lst = 0;
        for (j = i; j <= n && a[i].x == a[j].x; j++) if (a[j].t == 1) {
            if (!fir) fir = j; lst = j;
            if (j < n && a[i].x == a[j + 1].x && a[j + 1].t == 1)
                add_edge(a[j].id, a[j + 1].id);
        }
        if (lst) {
            if (lst != fir) add_edge(a[lst].id, a[fir].id);
            for (j = i; j <= n && a[i].x == a[j].x; j++) if (a[j].t != 1)
                add_edge(a[lst].id, a[j].id);
        }
        i = j;
    }
    sort(a + 1, a + n + 1, comp2);
    for (i = 1; i <= n;) {
        int fir = 0, lst = 0;
        for (j = i; j <= n && a[i].y == a[j].y; j++) if (a[j].t == 2) {
            if (!fir) fir = j; lst = j;
            if (j < n && a[i].y == a[j + 1].y && a[j + 1].t == 2)
                add_edge(a[j].id, a[j + 1].id);
        }
        if (lst) {
            if (lst != fir) add_edge(a[lst].id, a[fir].id);
            for (j = i; j <= n && a[i].y == a[j].y; j++) if (a[j].t != 2)
                add_edge(a[lst].id, a[j].id);
        }
        i = j;
    }
    sort(a + 1, a + n + 1, comp3);
    for (i = 1; i <= n;) {
        st[++tot] = i; row[tot] = a[i].x;
        for (j = i; j <= n && a[i].x == a[j].x; j++);
        ed[tot] = j - 1; i = j;
    }
    for (i = 1; i <= tot; i++) {
        if (i > 1) for (j = st[i - 1]; j <= ed[i - 1]; j++)
            las[a[j].y] = a[j].id;
        for (j = st[i]; j <= ed[i]; j++) now[a[j].y] = a[j].id;
        if (i < tot) for (j = st[i + 1]; j <= ed[i + 1]; j++)
            nex[a[j].y] = a[j].id;
        for (j = st[i]; j <= ed[i]; j++) {
            if (a[j].t != 3) continue;
            if (i > 1 && row[i - 1] + 1 == row[i]) {
                if (las[a[j].y - 1]) add_edge(a[j].id, las[a[j].y - 1]);
                if (las[a[j].y]) add_edge(a[j].id, las[a[j].y]);
                if (las[a[j].y + 1]) add_edge(a[j].id, las[a[j].y + 1]);
            }
            if (now[a[j].y - 1]) add_edge(a[j].id, now[a[j].y - 1]);
            if (now[a[j].y + 1]) add_edge(a[j].id, now[a[j].y + 1]);
            if (i < tot && row[i + 1] - 1 == row[i]) {
                if (nex[a[j].y - 1]) add_edge(a[j].id, nex[a[j].y - 1]);
                if (nex[a[j].y]) add_edge(a[j].id, nex[a[j].y]);
                if (nex[a[j].y + 1]) add_edge(a[j].id, nex[a[j].y + 1]);
            }
        }
        if (i > 1) for (j = st[i - 1]; j <= ed[i - 1]; j++)
            las[a[j].y] = 0;
        for (j = st[i]; j <= ed[i]; j++) now[a[j].y] = 0;
        if (i < tot) for (j = st[i + 1]; j <= ed[i + 1]; j++)
            nex[a[j].y] = 0;
    }
    for (i = 1; i <= n; i++) if (!dfn[i]) Tarjan(i);
    for (i = 1; i <= n; i++) for (int e = adj[i]; e; e = nxt[e])
        if (bel[i] != bel[go[e]]) add_edge2(bel[i], bel[go[e]]),
            cnt[bel[go[e]]]++;
    int ans = 0; topo();
    for (i = 1; i <= sum; i++) ans = max(ans, res[i]);
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：hater (赞：2)

题意简明 看完题目心中窃喜以为是缩点水题

大体的思路是 建边 缩点 之后 topsort

之后看完数据范围  ~~~~ 

为什么 R C 范围是1000000 啊

为什么 N 的范围是 100000 啊

这个数据很大 

建边是最大的问题 

因为 N^2 的枚举是我们无法承受的

肯定需要优化 

蒟蒻就想到一种方法 

开两个 vector xi 和 yi

xi [ x ]  就表示 横坐标为x的所有点下标

yi [ y ]  就表示 纵坐标为y的所有点下标

那么建边就变得简单 

假如我在坐标为 x y 的地方有横天门 

我只需要把 xi [ x ] 里面的所有的点 建一条边 

纵天门以此类推 不予以例子 

任意门的做法就与题解区里所有做法都不相同 

蒟蒻的方法是 枚举 横坐标为x x-1 x+1 的所有点 

再判断纵坐标是否能被任意门所达到 

这个方法有点蠢 但是可以免去二分和排序的代码量 

有些大佬用 map 之后被卡 MLE 

其实关于任意门的建边解法 

最好的应该是千年之狐大佬的hash 可以左转观摩 

tarjan 粘一遍板子 拓扑排序前的重处理边不要出锅

基本上也就没什么问题了 

还有疑问的在其他大佬的题解中已经十分详细 这里就不再献丑

[代码](https://www.luogu.org/paste/g2ikdk1a) 要抄的请自便

~~窝竟然1h1A省选题 蛤蛤蛤~~


---

## 作者：lsfer (赞：2)

这道题乍一看貌似不难，不就是建图-->找强连通分量-->建出$DAG$-->$DP$ 嘛...做法基本上和$P3387$ 模板  缩点 一模一样！

但是它没有说有多少条边啊？试想一下，假设所有点都在同一行，所有$T$都为$1$，那么就一共有$n*(n-1)$条边！$(n==10^5)$

稍作思考，我开始**第一次尝试**：

- 内心$OS$：虽然说理论上边数很多，但是实际上肯定没有那么多，不然内存不够。

  所以考虑用$STL$中的$vector$来储存每个点出发能够到达的所有点，然后套用$P3387$的模板

- 得到$60$分，剩下$4$个点$TLE$

于是我开始**第二次尝试**(实际上是对第一次尝试的改进)

- 我把图中的边改用邻接表储存，邻接表的大小开为$maxN*x$，思路是在不$TLE$的前提下尽可能开更大的邻接表。
- 得到$80$分，剩下$2$个点$TLE$

然后，继续思考，开始**第三次尝试**：

想一想，我们为什么$TLE$？边数太多！为什么$MLE$？边数太多！

假设$1$到$k$处于同一行，且它们的$T$都为$1$，那么我们建出来的边数就有$k*(k-1)$条。我们使每个点独立的到达其他点，从而边数过多。

是不是很像网状拓扑结构？

![](https://img.grouplus.com/admin-files/23410/ueditor_image/zc_20171007125632438)

所以，我们可以联想到用星型拓扑结构去优化它。

![](https://hexingxing.cn/wp-content/uploads/2017/10/star.gif)

我们考虑对于每一行和每一列都建立一个类似于中转站的虚拟点$x$，这个点可以到达这一行(列)里面的所有点，而当我们需要使点$i$能够到达它所在行(列)里面的所有点的时候，我们只需要建一条$i$-->$x$的边，然后通过$x$中转向其它节点。

$n = N + r + c$(实际用到的点数 $=$ 真实点数 $+$ 虚拟点数)

但是，注意数据范围：$R<=10^6,C<=10^6$，也就是说，如果我们对于每一行和每一列都建立虚拟节点的话，那么我们建出来的图中的点数将会非常多，那么$1.$可能$MLE;2.$可能$TLE$(第一次使用这种写法的时候，我便建立了$r+c$个虚拟节点，导致了$MLE+TLE$)

所以考虑优化。

因为$N<=10^5$,所以说，有用的行最多只有$10^5$行，有用的列最多也只有$10^5$列！

$n = N + r + c - cut$($cut$记录无用的行和列的总数，优化后，$n$最多只有$3*10^5$)

然后来计算这种写法最多有多少条边：

对于每个真实点$i$，我们需要建立一条它所在的行和列的虚拟点到它的边。 边数：$n*2$

同时，$T ==  1/2$ 的情况下，只需从 它引一条到它所在行(列)的虚拟点的边 ； $T == 3$ 的情况下，最多引$8$条边

所以，边数$<=n * 10$ ，是我们可以接受的。

$code$
```cpp
#include<map>
#include<queue>
#include<vector>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define R register int
using namespace std ;
const int maxN = 300005 ;
int n,N,r,c,T[maxN],X[maxN],Y[maxN],ans ;
int h[maxN],l[maxN] ;
int xx[8] = {-1,-1,-1, 0, 0, 1 ,1, 1} ;
int yy[8] = {-1, 0, 1,-1, 1,-1, 0, 1} ;
map<pair<int,int>,int > mp ;
struct EDGE{
	int head[maxN],cnt ;
	struct edge{
		int to,nex ;
	}e[maxN*10];
	inline void add(int u,int v){
		e[++cnt].to = v , e[cnt].nex = head[u] , head[u] = cnt ;
	}
}G1,G2,E ;
int color[maxN],cor_val[maxN],cor_num ;

template<typename T>inline void read(T &s){
	s = 0 ;char ch ; int f = 1 ;
	do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');
	do{s=s*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');
	s *= f;
}

struct Kosaraju{
	int vis[maxN],d[maxN],p ;
	void dfsONE(int u){
		vis[u] = true ;
		for(R i = G1.head[u] ; i ; i = G1.e[i].nex){
			int v = G1.e[i].to ;
			if(!vis[v]) dfsONE(v) ;
		}
		d[++p] = u ;
	} 
	void dfsTWO(int u){
		color[u] = cor_num ;
		if(u <= N) cor_val[cor_num] += 1 ;
		for(R i = G2.head[u] ; i ; i = G2.e[i].nex){
			int v = G2.e[i].to ;
			if(!color[v]) dfsTWO(v) ;
		}
	}
	void kosaraju(){
		for(R i = 1 ; i <= n ; ++i)
		if(!vis[i]) dfsONE(i) ;
		for(R i = n ; i >= 1 ; --i)
		if(!color[d[i]]){
			cor_num ++ ;
			dfsTWO(d[i]) ;
		}
	}
}K;

int dp[maxN],f[maxN],in[maxN] ;
queue<int> Q ;
void DAGdp(){
	for(R i = 1 ; i <= cor_num ; ++i)
	if(!in[i]){
		Q.push(i) ;
		dp[i] = cor_val[i] ;
	}
	while(!Q.empty()){
		int u = Q.front() ; Q.pop() ;
		for(R i = E.head[u] ; i ; i = E.e[i].nex){
			int v = E.e[i].to ;
			in[v] -- ;
			dp[v] = max(dp[v],dp[u] + cor_val[v]) ;
			if(!in[v]) Q.push(v) ;
		}
	}
}

void solve(){
	K.kosaraju() ;
	for(R i = 1 ; i <= n ; ++i)
		for(R j = G1.head[i] ; j ; j = G1.e[j].nex){
			int v = G1.e[j].to ;
			if(color[i] != color[v]) {
				E.add(color[i],color[v]) ;
				in[color[v]]++ ;
			}
		}
	DAGdp() ;
	for(R i = 1 ; i <= cor_num ; ++i)
		ans = max(ans,dp[i]) ;
	printf("%d",ans) ;
}

int nocut[maxN*10],cut,max_h ;
//没有点的行或列需要被cut掉 
void init(){
	read(N); read(r); read(c) ;
	cut = r + c ;//假定所有的行和列都需要被cut 
	for(R i = 1 ; i <= N ; ++i){
		read(X[i]) ; read(Y[i]) ; read(T[i]) ;
		if(!nocut[X[i]]) cut-- ;//当"行"或者"列"第一次被使用的时候 
		if(!nocut[r+Y[i]]) cut-- ;//cut--，说明它是有用的"行"或者"列"
		nocut[X[i]] = nocut[r+Y[i]] = true ;
		mp[make_pair(X[i],Y[i])] = i ;//记录每个点的坐标 
	}
	n = N + r + c - cut ;//实际用到的点数 = 真实点数 + 虚拟点数 
	for(R i = 1,j = 1 ; i <= r ; ++i)//第i行,在删去了无用的行之后为第h[i]行 
	if(nocut[i]){
		h[i] = j ;j++ ;
		max_h = max(max_h,j - 1) ;
	}
	for(R i = 1,j = 1 ; i <= c ; ++i)//第i列,在删去了无用的列之后为第l[i]列 
	if(nocut[r + i]){
		l[i] = j ; j++ ;
	}
	for(R i = 1 ; i <= N ; ++i){
		G1.add(N + h[X[i]],i) ;//每一行的代表点可以到达这一行所有点 
		G2.add(i,N + h[X[i]]) ;//原图的反图 
		G1.add(N + max_h + l[Y[i]],i) ;//每一列的代表点可以到达这一列所有点
		G2.add(i,N + max_h + l[Y[i]]) ;
		if(T[i] == 1){
			G1.add(i,N + h[X[i]]) ;//建立点i到X[i]这一行的代表点之间的边 
			G2.add(N + h[X[i]],i) ;//相当于一个中转站 
		}
		else if(T[i] == 2){
			G1.add(i,N + max_h + l[Y[i]]) ;//同上 
			G2.add(N + max_h + l[Y[i]],i) ;
		}
		else if(T[i] == 3){//朴素找周围8个点 
			for(R j = 0 ; j < 8 ; ++j){
				int nx = X[i] + xx[j] ;
				int ny = Y[i] + yy[j] ;
				if(mp[make_pair(nx,ny)]){
					int v = mp[make_pair(nx,ny)] ;
					G1.add(i,v) ;
					G2.add(v,i) ;
				}		
			}
		}
	}
}

int main(){
	init() ;
	solve() ;
	return 0 ;
}
```


---

## 作者：Dirt、 (赞：1)

最直接的想法：对于每个点直接向它能到达的点连边

然后发现 $n\le 100000,R,C \le 1000000$ 

我们发现，对于在同一行的每个”横天门“（下称横门），或者在同一列的每个” 纵寰门 “（下称纵门），它们可以到达的点都是一样的。

可以考虑对于每一行建一个点代表本行的横门，将该点向所有同一行的点连边，对于本行的所有横门，建一条到该点的边，纵门同理。

对于任意门，我们发现每个点只会与最多 $8$ 个点相连，直接暴力连边即可。

具体实现时可以使用 map 记录每个位置对应点的编号。

对于每个点，首先将对应行代表横门和对应列代表纵门的点向其连边。

然后如果该点是一个横门/纵门，向该点对应行/列代表横门/纵门的点连边。

如果是任意门，枚举周围的 $8$ 个坐标，如果该坐标对应一个点则向其连边。

建完边之后考虑如何计算。

我们发现对于一个强连通分量，它内部所有的点都可以被经过。

考虑缩点，每个强连通分量的权值为其内部**实点**的数量（因为我们建了一部分虚点（横门/纵门），这些点不应算入答案，所以在缩点时应判断，如果是一个虚点就不加入强连通分量的权值）。

然后就可以在DAG上拓扑排序了。

但是仍然存在一个问题：我们只能从某个宫室（实点）进入。

这意味着我们拓扑排序时，不能直接进入一个虚点。

可以发现，对于一个不包含任何实点的强连通分量，其权值一定为 $0$ 。

我们在统计完入度时，标记所有**入度为 $0$ 且权值为 $0$** 的的强连通分量，然后重新统计入度，在重新统计时跳过所有被标记的点即可。

在拓扑排序最开始入队的时候也要进行判断。

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<queue>
#include<stack>
#include<map>
using namespace std;
const int N=100003;
const int Maxn=2100003;
const int dx[8]={1,-1,0,0,1,1,-1,-1};
const int dy[8]={0,0,1,-1,1,-1,1,-1};
int n,m,r,c;
struct Node{
	int x,y,k;
}p[N];
int cnt;
int head[Maxn];
struct Edge{
	int nxt,from,to;
}e[N*10];
map<pair<int,int>,int> poi;
int idx,num;
int dfn[Maxn],low[Maxn],scc[Maxn],w[Maxn],dp[Maxn],in[Maxn];
stack<int> s;
bool v[Maxn];
void add(int u,int v)
{
	e[++cnt].nxt=head[u];
	e[cnt].from=u;
	e[cnt].to=v;
	head[u]=cnt;
}
void build(int id,int x,int y,int k)
{
	add(m+x,id);
	add(m+r+y,id);
	if(k==1) add(id,m+x);
	else if(k==2) add(id,m+r+y);
	else
	{
		for(int i=0;i<8;i++)
		{
			int xx=x+dx[i],yy=y+dy[i];
			if(poi.find(make_pair(xx,yy))==poi.end()) continue;
			int to=poi[make_pair(xx,yy)];
			add(id,to);
		}
	}
}
void Init()
{
	scanf("%d%d%d",&m,&r,&c);
	n=m+r+c;
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&p[i].x,&p[i].y,&p[i].k);
		poi[make_pair(p[i].x,p[i].y)]=i;
	}
	for(int i=1;i<=m;i++)
		build(i,p[i].x,p[i].y,p[i].k);
}
void tarjan(int x)
{
	dfn[x]=low[x]=++idx;
	s.push(x);
	v[x]=true;
	for(int i=head[x];i;i=e[i].nxt)
	{
		int to=e[i].to;
		if(!dfn[to])
		{
			tarjan(to);
			low[x]=min(low[x],low[to]);
		}
		else if(v[to]) low[x]=min(low[x],dfn[to]);
	}
	if(dfn[x]==low[x])
	{
		num++;
		while(true)
		{
			int k=s.top();
			s.pop();
			v[k]=false;
			scc[k]=num;
			if(k<=m) w[num]++;
			if(k==x) break;
		}
	}
}
void rebuild()
{
	memset(head,0,sizeof(head));
	int t=cnt;cnt=0;
	for(int i=1;i<=t;i++)
		if(scc[e[i].from]!=scc[e[i].to])
		{
			add(scc[e[i].from],scc[e[i].to]);
			in[scc[e[i].to]]++;
		}
	for(int i=1;i<=num;i++)
		if(in[i]==0&&w[i]==0) v[i]=true;
	memset(in,0,sizeof(in));
	for(int i=1;i<=num;i++)
	{
		if(v[i]) continue;
		for(int j=head[i];j;j=e[j].nxt)
			in[e[j].to]++;
	}
}
void topsort()
{
	queue<int> q;
	for(int i=1;i<=num;i++)
		if(in[i]==0&&w[i]) q.push(i),dp[i]=w[i];
	while(!q.empty())
	{
		int x=q.front();
		q.pop();
		for(int i=head[x];i;i=e[i].nxt)
		{
			int to=e[i].to;
			dp[to]=max(dp[to],dp[x]+w[to]);
			in[to]--;
			if(in[to]==0) q.push(to);
		}
	}
}
int main()
{
	Init();
	for(int i=1;i<=n;i++)
		if(!dfn[i]) tarjan(i);
	rebuild();
	topsort();
	int ans=0;
	for(int i=1;i<=num;i++)
		ans=max(ans,dp[i]);
	printf("%d",ans);
	return 0;
}
```



---

## 作者：Polar_Night (赞：1)

## 这是一个蒟蒻的题解
### 有大佬认为这题很水，在一个蒟蒻的角度看这题还是有些难的
在本人看来，这题较大困难是建图  
分析一下题目，算法标签都看过，应该都知道用什么算法。这题看到坐标，心里还想着暴力建图，看到矩阵长就放弃了，那我们可能会想到排序建图，但任意门怎么建呢？暴力！？想多了  
在这里我们用map来处理任意门，对于剩下两个门我们用vector保存  
大概是这样：  
```cpp
const int N=100001;
const int M=1000001;
struct node
{
    int op;//什么类型的门
    int id;//这个门的编号
    int wz;//在第几行的第几个位置
    //比如 输入 2 2 1
    //那这个横天门就是在第二行第二个位置，wz=2，在h[2]中
    node(int oo,int ii,int ww)
    {
        op=oo;
        id=ii;
        wz=ww;
    }
    node()
    {
    }
};
vector <node> l[N]; //这个门在第几列
vector <node > h[N];//这个门在第几行
```
下面是建图，我们还需要一个数组把门的信息保存起来：
```
struct edge
{
    int x,y,op;
}d[N];
long long get_v(int x,int y)
{
    return 1ll*(x-1)*c+y; //可以把long long乘爆的数字
    //不用哈希就去世了
}
map <long long ,int> mp;//这个是任意门的哈希

const int py[8][2]={{-1,-1},{-1,0},{-1,1},{0,1},{0,-1},{1,-1},{1,0},{1,1}};
//py数组是为了建任意门时用的
scanf("%d %d %d",&n,&r,&c);
for(int i=1;i<=n;i++)
{
 	int x,y,op;
   scanf("%d %d %d",&x,&y,&op);
   l[y].push_back(node(op,i,x));
   h[x].push_back(node(op,i,y));
   mp[get_v(x,y)]=i;
   d[i].x=x,d[i].y=y,d[i].op=op;
}
for(int i=1;i<=n;i++)
{
    if(d[i].op==1)
    {
        int size=h[d[i].x].size();
        for(int j=0;j<size;j++)
        {
            if(h[d[i].x][j].wz!=d[i].y)
               g[i].push_back(h[d[i].x][j].id);
        }
    }
    if(d[i].op==2)
    {
        int size=l[d[i].y].size();
        for(int j=0;j<size;j++)
        {
            if(l[d[i].y][j].wz!=d[i].x)
              g[i].push_back(l[d[i].y][j].id);
        }
    }
    if(d[i].op==3)
    {
        for(int j=0;j<8;j++)
        {
            int new_x=d[i].x+py[j][0];
            int new_y=d[i].y+py[j][1];
            if(mp.find(get_v(new_x,new_y))!=mp.end())
    	        g[i].push_back(mp[get_v(new_x,new_y)]);
            //注意一下这里
            //不要像这样写
            //if(mp[get_v(new_x,new_y)]==0)
            //g[i].push_back(mp[get_v(new_x,new_y)]);
            //这么写爆空间不要怪我没说
        }
     }
 }
```
好了，终于把图建好了，图建完了后题目就清晰了，来一遍tarjan缩点，拓扑一下，最后dp得出答案：
```
void tarjan(int pos)//缩点
{
    low[pos]=dfn[pos]=++cnt;
    flag[pos]=true,s.push(pos);
    //这个s是一个栈，用来保存强连通的点
    int size=g[pos].size();
    for(int i=0;i<size;i++)
    {
        int to=g[pos][i];
        if(!dfn[to])
        {
            tarjan(to);
            low[pos]=min(low[pos],low[to]);
        }
        else if(flag[to])
            low[pos]=min(low[pos],dfn[to]);
    }
    if(dfn[pos]==low[pos])
    {
        col[pos]=++tot;
        flag[pos]=false;
        //flag是bool型，用来判断在不在栈中的标记
        gr[col[pos]].push_back(pos);
        while(!s.empty() && s.top()!=pos)
        {
            flag[s.top()]=false;
            col[s.top()]=tot;
            //col数组是每个点对应的强连通的编号
            gr[col[pos]].push_back(s.top());
        //gr是个vector，用来保存强保存强连通中每一个点
            s.pop();
        }
        s.pop();//把pos弹掉
    }
    return;
}
void topu()
{
	  //dp是用来动归的数组，存放答案
     //siz是每个强连通内点的数量，也就是gr[col[i]].size()
     //in为入度
    for(int i=1;i<=tot;i++)//tot为强连通总数
        if(!in[i])
            q.push(i),dp[i]=siz[i];
    while(!q.empty())
    {
        int t=q.front();
        q.pop();
        int size=v[t].size();
        //v为缩点后新建的图
        for(int i=0;i<size;i++)
        {
            int to=v[t][i];
            in[to]--;
            dp[to]=max(dp[t]+siz[to],dp[to]);
            //去那个强连通还是不去
            if(!in[to])
                q.push(to);
        }
    }
    return;
}
//这是主函数里的，建缩点后的新图
for(int i=1;i<=tot;i++)
{
    int s1=gr[i].size();
    siz[i]=s1;
    for(int j=0;j<s1;j++)
    {
    	int size=g[gr[i][j]].size();
    	for(int k=0;k<size;k++)
        {
            int to=col[g[gr[i][j]][k]];
            if(to!=i && use.count(get_v(i,to))==0)
                v[i].push_back(to),use.insert(get_v(i,to)),in[to]++;
        //use是一个set<long long>,用作去重边
        }
    }
}
ed=tot+1;//这里我们建一个虚结束点，让它与每一个点建边
for(int i=1;i<=tot;i++)
    v[i].push_back(ed),in[ed]++;
topu();

```
大功告成，这题终于写完了，下面是完整AC代码：  
之前有注释的我就不再加了，可能没有其他大佬的代码快
```
#include <bits/stdc++.h>
using namespace std;
const int N=100001;
const int M=1000001;
const int py[8][2]={{-1,-1},{-1,0},{-1,1},{0,1},{0,-1},{1,-1},{1,0},{1,1}};
int n,r,c,tot,low[N],dfn[N],in[N],cnt,col[N],dp[N],ed,siz[N];
//cnt只是一个用来编号的
bool flag[N];
set <long long > use;
stack <int > s;
map <long long ,int> mp;
struct edge
{
    int x,y,op;
}d[N];
struct node
{
    int op;
    int id;
    int wz;
    node(int oo,int ii,int ww)
    {
        op=oo;
        id=ii;
        wz=ww;
    }
    node()
    {
    }
};
vector <node> l[N];
vector <node > h[N];
queue <int > q;//拓扑用的
vector <int > gr[N];
vector <int > g[N];//旧图
vector <int > v[N];//缩点后图
long long get_v(int x,int y)
{
    return 1ll*(x-1)*c+y;
}
void tarjan(int pos)
{
    low[pos]=dfn[pos]=++cnt;
    flag[pos]=true,s.push(pos);
    int size=g[pos].size();
    for(int i=0;i<size;i++)
    {
        int to=g[pos][i];
        if(!dfn[to])
        {
            tarjan(to);
            low[pos]=min(low[pos],low[to]);
        }
        else if(flag[to])
            low[pos]=min(low[pos],dfn[to]);
    }
    if(dfn[pos]==low[pos])
    {
        col[pos]=++tot;
        flag[pos]=false;
        gr[col[pos]].push_back(pos);
        while(!s.empty() && s.top()!=pos)
        {
            flag[s.top()]=false;
            col[s.top()]=tot;
            gr[col[pos]].push_back(s.top());
            s.pop();
        }
        s.pop();
    }
    return;
}
void topu()
{
    for(int i=1;i<=tot;i++)
        if(!in[i])
            q.push(i),dp[i]=siz[i];
    while(!q.empty())
    {
        int t=q.front();
        q.pop();
        int size=v[t].size();
        for(int i=0;i<size;i++)
        {
            int to=v[t][i];
            in[to]--;
            dp[to]=max(dp[t]+siz[to],dp[to]);
            if(!in[to])
                q.push(to);
        }
    }
    return;
}
int main()
{
    scanf("%d %d %d",&n,&r,&c);
    for(int i=1;i<=n;i++)
    {
        int x,y,op;
        scanf("%d %d %d",&x,&y,&op);
        l[y].push_back(node(op,i,x));
        h[x].push_back(node(op,i,y));
        mp[get_v(x,y)]=i;
        d[i].x=x,d[i].y=y,d[i].op=op;
    }
    for(int i=1;i<=n;i++)
    {
        if(d[i].op==1)
        {
            int size=h[d[i].x].size();
            for(int j=0;j<size;j++)
            {
                if(h[d[i].x][j].wz!=d[i].y)
                    g[i].push_back(h[d[i].x][j].id);
            }
        }
        if(d[i].op==2)
        {
            int size=l[d[i].y].size();
            for(int j=0;j<size;j++)
            {
                if(l[d[i].y][j].wz!=d[i].x)
                    g[i].push_back(l[d[i].y][j].id);
            }
        }
        if(d[i].op==3)
        {
            for(int j=0;j<8;j++)
            {
                int new_x=d[i].x+py[j][0];
                int new_y=d[i].y+py[j][1];
                if(mp.find(get_v(new_x,new_y))!=mp.end())
                    g[i].push_back(mp[get_v(new_x,new_y)]);
            }
        }
    }
    for(int i=1;i<=n;i++)
    {
        if(!dfn[i])
            tarjan(i);
    }
    for(int i=1;i<=tot;i++)
    {
        int s1=gr[i].size();
        siz[i]=s1;
        for(int j=0;j<s1;j++)
        {
            int size=g[gr[i][j]].size();
            for(int k=0;k<size;k++)
            {
                int to=col[g[gr[i][j]][k]];
                if(to!=i && use.count(get_v(i,to))==0)
                    v[i].push_back(to),use.insert(get_v(i,to)),in[to]++;
            }
        }
    }
    ed=tot+1;
    for(int i=1;i<=tot;i++)
        v[i].push_back(ed),in[ed]++;
    topu();
    printf("%d\n",dp[ed]);
    return 0;
}
```

---

## 作者：Xiaojian_xiang (赞：1)

直接上算法吧：

tarjan缩点+拓扑排序+DP求解最长路

一看这题有可能有好多好多的环……所以我们就要先缩个点……然后就会很惊奇的发现……哇！这是个DAG于是想到要求最长路我们就自然而然的想到了求个拓扑序去个后效性直接DP……

想法真的很暴……写起来蛮烦的……

贴代码：











```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#include<stack>
#define mem(a,b) memset(a,b,sizeof(a)) 
using namespace std;
const int MAXN=100010;
const int MAXT=1000010;
int n,r,c;
int dx[]={0,1,0,-1,1,1,-1,-1};
int dy[]={1,0,-1,0,-1,1,-1,1};
struct NODE{
    int x,y,t;
}op[MAXN];
int list_x[MAXT],list_y[MAXT];
int ne_x[MAXN],ne_y[MAXN];
int rudu[MAXN];
int num[MAXN],rank[MAXN],top;
int head[MAXN],nex[MAXN*50],to[MAXN*50],top1;
int head1[MAXN],nex1[MAXN*50],to1[MAXN*50],top2;
void init(){
     mem(list_x,-1);mem(list_y,-1);mem(head,-1);mem(head1,-1);
}
void add1(int x,int y){nex[top1]=head[x];head[x]=top1;to[top1++]=y;}
void add2(int x,int y){nex1[top2]=head1[x];head1[x]=top2;to1[top2++]=y;}
void addedge1(){
     for(int i=0;i<n;i++){
         if(op[i].t==1)
             for(int j=list_x[op[i].x];j!=-1;j=ne_x[j]){
                 if(i==j) continue;
                 add1(i,j);
             }
         if(op[i].t==2)
             for(int j=list_y[op[i].y];j!=-1;j=ne_y[j]){
                 if(i==j) continue;
                 add1(i,j);
             }
         if(op[i].t==3)
             for(int k=0;k<8;k++){
                 int xx=op[i].x+dx[k];
                 for(int j=list_x[xx];j!=-1;j=ne_x[j]){
                     if(i==j) continue;
                     if(abs(op[j].y-op[i].y)<=1) add1(i,j);
                 }
             }
     }
}
int dfn[MAXN],low[MAXN],tot;
bool in_stack[MAXN];
stack<int> s;
int dnf[MAXN],rank1[MAXN],ttt;
void tarjan(int here){
     dfn[here]=low[here]=++tot;
     in_stack[here]=1;s.push(here);
     for(int i=head[here];i!=-1;i=nex[i]){
         if(!dfn[to[i]]){
             tarjan(to[i]);
             low[here]=min(low[here],low[to[i]]);
         }
         else if(in_stack[to[i]]){
             low[here]=min(low[here],dfn[to[i]]);
         }
     }
     if(low[here]==dfn[here]){
         int tttt(-1);//charu dian top
         while(tttt!=here){
             tttt=s.top();s.pop();in_stack[tttt]=0;
             rank[tttt]=top;num[top]++;
         }
         ++top;
     }
}
void tuopu(){
    while(!s.empty()) s.pop();
    for(int i=0;i<top;i++)
        if(!rudu[i]) s.push(i);
    while(!s.empty()){
        int tmp=s.top();s.pop();
        rank1[tmp]=ttt;dnf[ttt++]=tmp;
        for(int i=head1[tmp];i!=-1;i=nex1[i]){
            if(rudu[to1[i]]){
                --rudu[to1[i]];
                if(!rudu[to1[i]]) s.push(to1[i]);
            }
        }
    }
}
void input(){
     init();
     cin>>n>>r>>c;
     for(int i=0;i<n;i++){
         cin>>op[i].x>>op[i].y>>op[i].t;
         ne_x[i]=list_x[op[i].x];list_x[op[i].x]=i;
         ne_y[i]=list_y[op[i].y];list_y[op[i].y]=i;
     }
     addedge1();
}
int dp[MAXN];
void xxj(){
     for(int i=0;i<n;i++){
         if(dfn[i]) continue;
         tarjan(i);
     }
     for(int i=0;i<n;i++){
         for(int j=head[i];j!=-1;j=nex[j]){
             if(rank[i]!=rank[to[j]]){
                 add2(rank[i],rank[to[j]]);
                 ++rudu[rank[to[j]]];
             }
         }
     }
     tuopu();
     for(int i=0;i<n;i++)
         dp[i]=num[i];
     for(int i=0;i<ttt;i++){
         int tmp=dnf[i];
         for(int j=head1[tmp];j!=-1;j=nex1[j]){
             dp[to1[j]]=max(dp[to1[j]],dp[tmp]+num[to1[j]]);
         }
     }
}
void output()
{
     int imax(0);
     for(int i=0;i<top;i++){
         imax=max(dp[i],imax);
     }
     cout<<imax<<endl;
}
int main()
{
    input();
    xxj();
    output();
    //system("pause");
    return 0;
}
```

---

## 作者：MuYC (赞：1)

### 题解:Tarjan + 拓扑排序 + 建图小技巧

	观察题目性质，大概就是要Tarjan缩点后通过拓扑排序求出一个一条最长路径（经过的点最多）
    难度就在建图这里.
### 我着重分享一个我的建图技巧：

首先将给出的门按横坐标排序，先处理横门。         如果当前有一个横门，那么我们将它与同一横行的所有边连边，记录下这个门的编号，接下来，同一行的横门只需要向它连边就行了。这样子不会影响答案而且大大减少了无用边。

同样的道理，接着重新把给出的门按纵坐标排序，处理纵门。如果当前是一个纵门，我们就把它向所有同一纵行的门连边（因为是排过序的，所以比较好处理）。然后同一行的纵门向它连边就行了。

对于自由门的处理我们使用STL中的map，记录下每个门的坐标，将Map中每个门对应的值都设为这个门的编号,然后循环从1到n每次暴力的看八个方向有没有门就行了，有就连上。

这样子就建好图了，然后跑一遍tarjan和拓扑排序就好了。

### 对于map简单介绍一下：
可以看成是一个数组,但是这个数组的下标比较奇怪，它的下标可以是一个"pair" 类型。类似于可以把一个二维数组压缩为一个一维数组，拿上面记录坐标来看,我们定义一个

```cpp
pair <int,int> p

p.first = x

p.second = y;
```


那么我们的 
```cpp
map <pair<int,int> , int> mp,mp[p] <-----这里mp的下标是一个pair
```
就可以直接给mp[p]赋值.

前面的pair可以有其他很多种类型，根据题目需要可以进行修改

如果用普通的数组我们显然得写为mp[x][y]，这样子的话我们就得开一个二维数组了.

map的本质是一棵红黑树，它的时间复杂度是o(NlogN)的，空间复杂度是O(元素个数)的，所以在数据范围比较小的时候用一个二维数组会在时间复杂度上更优，但是这道题中R以及C都是 <= 1e6的，我们显然开不下一个mp[R][C] ,所以，这时候应该用map

tarjan以及拓扑排序就不着重讲了（应该做这道题不应该不会tarjan了吧。不会吧，不会吧，会吧，吧...如果不会的话康康代码吧）吐槽一下，这个题的代码是真的长啊！恶心！恶心！

## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
pair<int, int> p;
map<pair<int, int>, int> mp;
int n, m = 0, R, C;
struct ask {
    int x, y, z, num;
} q[100005];
struct node {
    int u, v;
} r[10000005], T[10000005];
int start[100005], Fx[100005], Fy[100005], dfn[100005], low[100005], color[100005];
int cmpa(ask A, ask B) { return A.x < B.x; }
int cmpb(ask A, ask B) { return A.y < B.y; }
void add(int u, int v) {
    if (u == v)
        return;
    m++;
    r[m].u = u, r[m].v = v;
}
void build_graph() {
    sort(q + 1, q + 1 + n, cmpa);
    int ls = -1;
    for (int i = 1; i <= n; i++)
        if (ls != q[i].x)
            ls = q[i].x, start[ls] = i;
    for (int i = 1; i <= n; i++) {
        if (q[i].z == 1 && Fx[q[i].x] == 0) {
            for (int j = start[q[i].x]; j <= n && q[j].x == q[i].x; j++)
                if (i != j)
                    add(q[i].num, q[j].num);
            Fx[q[i].x] = q[i].num;
        }
        if (q[i].z == 1 && Fx[q[i].x] != 0)
            add(q[i].num, Fx[q[i].x]);
    }
    sort(q + 1, q + 1 + n, cmpb);
    memset(start, 0, sizeof(start));
    ls = -1;
    for (int i = 1; i <= n; i++)
        if (ls != q[i].y)
            ls = q[i].y, start[ls] = i;
    for (int i = 1; i <= n; i++) {
        if (q[i].z == 2 && Fy[q[i].y] == 0) {
            for (int j = start[q[i].y]; j <= n && q[j].y == q[i].y; j++)
                if (i != j)
                    add(q[i].num, q[j].num);
            Fy[q[i].y] = q[i].num;
        }
        if (q[i].z == 2 && Fy[q[i].y] != 0)
            add(q[i].num, Fy[q[i].y]);
    }
    memset(start, 0, sizeof(start));
}
int d1[9] = { 0, 1, -1, 0, 0, 1, -1, 1, -1 };
int d2[9] = { 0, 0, 0, 1, -1, -1, 1, 1, -1 };
int now = 0, tot = 0;
int tack[100005], tail = 0, z = 0, Siz[100005], LCNB[100005];
int tarjan(int x) {
    now++;
    low[x] = dfn[x] = now;
    tail++, tack[tail] = x;
    LCNB[x] = 1;
    for (int i = start[x]; i <= m && r[i].u == x; i++) {
        int to = r[i].v;
        if (!dfn[to]) {
            tarjan(to);
            low[x] = min(low[x], low[to]);
        } else if (LCNB[to])
            low[x] = min(low[x], dfn[to]);
    }
    if (low[x] == dfn[x]) {
        z++;
        while (tack[tail + 1] != x && tail >= 1)
            color[tack[tail]] = z, LCNB[tack[tail]] = 0, Siz[z]++, tail--;
    }
    return 0;
}
int cmp(node A, node B) { return A.u < B.u; }
int mm = 0, locked[1000005], sum[100005] = { 0 };
void newadd(int u, int v) {
    if (u == v)
        return;
    mm++;
    T[mm].u = u, T[mm].v = v;
}
int topsort() {
    queue<int> q;
    for (int i = 1; i <= n; i++)
        if (locked[i] == 0 && Siz[i] != 0)
            q.push(i);
    for (int i = 1; i <= n; i++) sum[i] = Siz[i];
    while (!q.empty()) {
        int k = q.front();
        q.pop();
        for (int i = start[k]; i <= m && r[i].u == k; i++) {
            int v = r[i].v;
            sum[v] = max(sum[v], sum[k] + Siz[v]);
            locked[v]--;
            if (locked[v] == 0)
                q.push(v);
        }
    }
    int ans = 0;
    for (int i = 1; i <= n; i++) ans = max(ans, sum[i]);
    return ans;
}
int main() {
    cin >> n >> R >> C;
    for (int i = 1; i <= n; i++) {
        cin >> q[i].x >> q[i].y >> q[i].z;
        p.first = q[i].x;
        q[i].num = i;
        p.second = q[i].y;
        mp[p] = q[i].num;
    }
    build_graph();
    for (int i = 1; i <= n; i++) {
        if (q[i].z == 3) {
            for (int k = 1; k <= 8; k++) {
                p.first = q[i].x + d1[k];
                p.second = q[i].y + d2[k];
                if (mp[p] != 0)
                    add(q[i].num, mp[p]);
            }
        }
    }
    sort(r + 1, r + 1 + m, cmp);
    int ls = -1;
    for (int i = 1; i <= m; i++)
        if (ls != r[i].u)
            ls = r[i].u, start[ls] = i;
    for (int i = 1; i <= n; i++)
        if (!dfn[i])
            tarjan(i);
    mp.clear();
    for (int i = 1; i <= m; i++) {
        p.first = color[r[i].u];
        p.second = color[r[i].v];
        if (mp[p] == 0)
            newadd(color[r[i].u], color[r[i].v]);
        mp[p] = 1;
    }
    m = mm;
    memset(start, 0, sizeof(start));
    for (int i = 1; i <= m; i++) r[i] = T[i];
    sort(r + 1, r + 1 + m, cmp);
    ls = -1;
    for (int i = 1; i <= m; i++)
        if (ls != r[i].u)
            ls = r[i].u, start[ls] = i;
    for (int i = 1; i <= m; i++) locked[r[i].v]++;
    cout << topsort();
    return 0;
}
```

完结撒花！O(∩_∩)O~~ ， (；′⌒`)点个赞呗。（代码写这么丑还要赞的真是~~臭不要脸~~ 合情合理

---

## 作者：galiqing (赞：1)

这道题真是一道好(gou)题，我的做法似乎有点奇怪，不是像网上那样拓扑dp，而是跑最长路。首先强联通缩点，避免出现环的情况，之后我们把联通连在一起，举个例子，x连y，则边权为y的节点数。再设两个点st与ed，别看题目说可以从任意宫室进入，任意宫室出去，但其实只需把st与入度为0的联通块相连（边权为联通块点数），出度为0的点与ed相连（边权为0）就可以了。为什么，因为这样可以保证走的最长，很好理解吧。最后再提醒一点，建边要优化，不然就算你其它都打对了，也只有40分，不要问我怎么知道的。
```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<cstdlib>
using namespace std;
int dx[8]={1,0,-1,0,1,1,-1,-1};
int dy[8]={0,1,0,-1,1,-1,1,-1};
struct node
{
    int x,y,next;
}a[4110000];int len,last[210000];
struct bian
{
    int x,y,c,bl;
}tr[210000];
struct edge
{
    int x,y,c,next;
}b[3110000];int trlen,trlast[210000];
void trins(int x,int y,int c)
{
    trlen++;
    b[trlen].x=x;b[trlen].y=y;b[trlen].c=c;
    b[trlen].next=trlast[x];trlast[x]=trlen;
}
void ins(int x,int y)
{
    len++;
    a[len].x=x;a[len].y=y;
    a[len].next=last[x];last[x]=len;
}
int id,cnt,top;
int low[210000],dfn[210000];
int sta[210000],belong[210000],tot[210000],list[210000];
int chu[210000],ru[210000],ss[210000];
bool v[210000];
void dfs(int x)
{
    dfn[x]=low[x]=++id;
    sta[++top]=x;v[x]=true;
    for(int k=last[x];k;k=a[k].next)
    {
        int y=a[k].y;
        if(dfn[y]==-1)
        {
            dfs(y);
            low[x]=min(low[x],low[y]);
        }
        else
        {
            if(v[y]==true)low[x]=min(low[x],dfn[y]);
        }
    }
    if(low[x]==dfn[x])
    {
        cnt++;int i;
        do
        {
            i=sta[top--];
            v[i]=false;
            tot[cnt]++;
            belong[i]=cnt;
        }while(i!=x);
    }
}
int cmp1(const void *xx,const void *yy)
{
    bian n1=*(bian *)xx;
    bian n2=*(bian *)yy;
    if(n1.x==n2.x)
    {
        if(n1.y>n2.y)return 1;
        if(n1.y<n2.y)return -1;
        return 0;
    }
    if(n1.x>n2.x)return 1;
    if(n1.x<n2.x)return -1;
    return 0;
}
int cmp2(const void *xx,const void *yy)
{
    bian n1=*(bian *)xx;
    bian n2=*(bian *)yy;
    if(n1.y>n2.y)return 1;
    if(n1.y<n2.y)return -1;
    return 0;
}
int n;
int erfen(int xx,int yy)
{
    int l=1,r=n;
    while(l<=r)
    {
        int mid=(l+r)/2;
        if(tr[mid].x>xx)r=mid-1;
        else if(tr[mid].x<xx)l=mid+1;
        else if(tr[mid].y>yy)r=mid-1;
        else if(tr[mid].y<yy)l=mid+1;
        else return tr[mid].bl;
    }
    return -1;
}
int main()
{
    len=0;memset(last,0,sizeof(last));
    int R,C;
    scanf("%d%d%d",&n,&R,&C);
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d%d",&tr[i].x,&tr[i].y,&tr[i].c);
        tr[i].bl=i;
    }   
    qsort(tr+1,n,sizeof(bian),cmp2);
    for(int i=1;i<=n;i++)
    {
        if(tr[i].c==2)
        {
            int j=i+1;
            while(tr[i].y==tr[j].y)ins(tr[i].bl,tr[j].bl),j++;
            j=i-1;
            while(tr[i].y==tr[j].y)ins(tr[i].bl,tr[j].bl),j--;
        }
    }
    qsort(tr+1,n,sizeof(bian),cmp1);
    for(int i=1;i<=n;i++)
    {
        if(tr[i].c==1)
        {
            int j=i+1;
            while(tr[i].x==tr[j].x)ins(tr[i].bl,tr[j].bl),j++;
            j=i-1;
            while(tr[i].x==tr[j].x)ins(tr[i].bl,tr[j].bl),j--;
        }
    }
    for(int i=1;i<=n;i++)
    {
        if(tr[i].c==3)
        {
            for(int j=0;j<8;j++)
            {
                int xx=tr[i].x+dx[j],yy=tr[i].y+dy[j];
                if(xx<1 || xx>R || yy<1 || yy>C)continue;
                int ans=erfen(xx,yy);
                if(ans!=-1)ins(tr[i].bl,ans);
            }
        }
    }               
    id=cnt=top=0;
    memset(dfn,-1,sizeof(dfn));
    memset(low,0,sizeof(low));
    memset(belong,0,sizeof(belong));
    memset(v,false,sizeof(v));
    memset(sta,0,sizeof(sta));
    memset(tot,0,sizeof(tot));
    for(int i=1;i<=n;i++)
    {
        if(dfn[i]==-1)dfs(i);
    }
    trlen=0;memset(trlast,0,sizeof(trlast));
    for(int i=1;i<=len;i++)
    {
        if(belong[a[i].x]!=belong[a[i].y])
        {
            chu[belong[a[i].x]]++;
            ru[belong[a[i].y]]++;
            trins(belong[a[i].x],belong[a[i].y],tot[belong[a[i].y]]);
        }
    }
    memset(ss,-1,sizeof(ss));
    memset(v,false,sizeof(v));
    int st=cnt+1,ed=cnt+2;
    for(int i=1;i<=cnt;i++)
    {
        if(chu[i]==0)trins(i,ed,0);
        if(ru[i]==0)trins(st,i,tot[i]);
    }
    int head=1,tail=2;ss[st]=0;
    list[head]=st;v[st]=true;
    while(head<=tail)
    {
        int x=list[head];
        for(int k=trlast[x];k;k=b[k].next)
        {
            int y=b[k].y;
            if(ss[y]<ss[x]+b[k].c)
            {
                ss[y]=ss[x]+b[k].c;
                if(v[y]==false)
                {
                    v[y]=true;
                    list[tail++]=y;
                }
            }
        }
        v[x]=false;
        head++;
    }
    printf("%d\n",ss[ed]);
    return 0;
}   
```

---

## 作者：Phoenix030821 (赞：1)

# 蒟蒻发篇题解。。。

### Tarjan缩点，拓扑排序楼下大佬们已经说得很清楚了

那我来说一下自己建图的思路吧

首先在每行每列各建一个点，向这一行或这一列的每一个点建一条有向边，横门或纵门就可以向这一行或这一列的点建一条有向边

而自由门，我建了一个map
```
map<pair<int,int>,int>mp;
```
pair存的是坐标，映射的是这个点的编号。
如果一个点有自由门，将周围八个点坐标走一遍，如果map有对应就向那个点建一条有向边，如果没有就新建一个点

空间似乎有点大。。。拓扑的数组都是用的之前Tarjan的


完整代码：

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<map> 
using namespace std;
struct Edg{
    int to,nxt,from;
}p[10000100];
map<pair<int,int>,int>mp;
inline int read(){
    int x=0,f=1; char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-48; ch=getchar();}
    return f*x;    
}
int dfn[3000100],low[3000100],e[3000100];
int head[3000100],st[3000100],po[3000100];
int col[3000100],op[3000100],num,mun,xi,yi,mag;
int sor,cnt,top,n,m,s,t,alg,maxa,r,c;
int dir[2][8]={{-1,-1,-1,0,0,1,1,1},{-1,0,1,-1,1,-1,0,1}};
bool vis[3000100];
void add(int from,int to){
    p[++num].to=to;
    p[num].from=from;
    p[num].nxt=head[from];
    head[from]=num;
}
void ad(int from,int to){
    p[++mun].to=to;
    p[mun].nxt=head[from];
    head[from]=mun;
}
void tarjan(int i){
    dfn[i]=low[i]=++cnt;
    st[++top]=i;
    vis[i]=1;
    for(int x=head[i];x;x=p[x].nxt){
        if(!dfn[p[x].to]){
            tarjan(p[x].to);
            low[i]=min(low[i],low[p[x].to]);
        }
        else if(vis[p[x].to]){
            low[i]=min(low[i],dfn[p[x].to]);
        }
    }
    if(low[i]==dfn[i]){
        sor++;
        while(i!=st[top]){
            po[sor]+=op[st[top]];col[st[top]]=sor;vis[st[top]]=0;top--;
        }
        po[sor]+=op[st[top]];col[st[top]]=sor;vis[st[top]]=0;top--;
    }
}
void topo(){
    int j=0,k=0;
    for(int x=1;x<=sor;x++){
    	if(!e[x])dfn[++j]=x;low[x]=po[x];
    }
    while(k<j){
        int u=dfn[++k];
        for(int x=head[u];x;x=p[x].nxt){
            if(!(--e[p[x].to]))dfn[++j]=p[x].to;
            low[p[x].to]=max(low[p[x].to],low[u]+po[p[x].to]);
        }
    }
}
int main(){
    cin>>n>>r>>c;
    int mu=r+c;
    for(int x=1;x<=n;x++){
    	xi=read();yi=read();mag=read();
    	int w;
    	if(mp.count(make_pair(xi,yi))){
    		w=mp[make_pair(xi,yi)];
        }
        else w=++mu,mp[make_pair(xi,yi)]=mu;
        op[w]=1;
        add(xi,w);add(yi+r,w);
        if(mag==1)add(w,xi);
        if(mag==2)add(w,yi+r);
        if(mag==3){
            for(int y=0;y<8;y++){
                if(xi+dir[0][y]>0 and xi+dir[0][y]<=r and yi+dir[1][y]>0 and yi+dir[1][y]<=c){
                    if(!mp.count(make_pair(xi+dir[0][y],yi+dir[1][y])))mp[make_pair(xi+dir[0][y],yi+dir[1][y])]=++mu;
                    add(w,mp[make_pair(xi+dir[0][y],yi+dir[1][y])]);
                }
            }
        }
    }
    for(int x=1;x<=r+c+n;x++){
        if(!dfn[x])tarjan(x);
    }
    memset(head,0,sizeof(head));
    for(int x=1;x<=num;x++){
        if(col[p[x].from]!=col[p[x].to])e[col[p[x].to]]++,ad(col[p[x].from],col[p[x].to]);
    }
    topo();
    for(int x=1;x<=sor;x++)maxa=max(maxa,low[x]);
    cout<<maxa<<endl;
    return 0;
}
```


---

## 作者：AxDea (赞：0)

[题面](https://www.luogu.com.cn/problem/P2403)

可以发现最后由 $n$ 个点组成的图是有环的，我们继而进行缩点后 DP

#### step 1: 建图

暴力是 $\mathcal{O}(n^2)$ 的，优化

可以发现同一行的标号均为 1 的点可以形成环

同一列的标号均为 2 的点可以形成环

有以下思路:

先将行数排序作为第一关键字，将是否标号为 1 作为第二关键字对于点排序

取第每一行一个点作为链表头，链上有这一行上标号为 1 的点，最后将链头和链尾相接，就成功得到了一个环

对于这一行上标号不为 1 的点，直接上一条链头到该点的边即可

对于标号为 2 和列的处理与对于行的处理相似

对于标号为 3 的点，考虑暴力加边，可使用`std::map`或 Hash 优化

#### step 2: 缩点 & 建 DAG

点权即为环上点的数量，其他都是板子

#### step 3: 拓扑排序 + DP

$num_v$ 为点权

$$f_v = \max_{(u,v)\in DAG} f_u + num_v$$

答案 $Ans = \max f_i$

总复杂度 $\mathcal{O}(n\log n)$

Code(C++):
```cpp
#include<bits/stdc++.h>
#define forn(i,s,t) for(int i=(s);i<=(t);++i)
using namespace std;
typedef long long LL;
const int N = 1e5+3,Mod = 1e6+7;
const int dxx[] = {1,1,1,-1,-1,-1,0,0};
const int dyy[] = {0,1,-1,1,0,-1,1,-1};
struct List {
	int dir,nxt;
}E[N<<3],DAG[N<<3];
int G[N],cnt,G1[N],cnt1,ind[N];
inline void Add(int u,int v) {
	E[++cnt].dir = v,E[cnt].nxt = G[u],G[u] = cnt;
}
inline void AddDAG(int u,int v)  {
	DAG[++cnt1].dir = v,DAG[cnt1].nxt = G1[u],G1[u] = cnt1,ind[v]++;
}
int n,R,C,id[N],x[N],y[N],t[N];
struct Hash {                                                // 乱搞Hash
	LL val[N<<2];
	int nxt[N<<2],id[N<<2],head[Mod+2],cnt;
	inline void Add(int x,int y,int nd) {
		LL A = 1ll*(x-1)*C+y;
		LL B = A%Mod;
		val[++cnt] = A,id[cnt] = nd,nxt[cnt] = head[B];
		head[B] = cnt;
	}
	inline int Fnd(int x,int y) {
		LL A = (1ll*(x-1)*C+y) %Mod;
		LL B = 1ll*(x-1)*C+y;
		for(int i=head[A];i;i=nxt[i]) 
			if(val[i] == B) return id[i];
		return -1;
	}
}H;
int dfn[N],ord,stk[N],h,clr[N],col,num[N],f[N],Ans;
bool vis[N];
int tarjan(int u) {
	int low = dfn[u] = ++ord;
	stk[++h] = u,vis[u] = 1;
	for(int i=G[u];i;i=E[i].nxt) {
		int v = E[i].dir;
		if(!dfn[v]) low = min(tarjan(v),low);
		else if(vis[v]) low = min(low,dfn[v]);
	}
	if(low == dfn[u]) {
		++col;
		do num[col]++,vis[stk[h]]=0,clr[stk[h]]=col;
		while(stk[h--]!=u);
	}
	return low;
}
queue<int> q;
inline bool cmp(int A,int B) {return x[A]!=x[B]?(x[A]<x[B]):((t[A]==1)?1:(!t[B]));}
inline bool cmp1(int A,int B){return y[A]!=y[B]?(y[A]<y[B]):((t[A]==2)?1:(!t[B]));}
int main() {
	scanf("%d%d%d",&n,&R,&C);
	forn(i,1,n) scanf("%d%d%d",&x[i],&y[i],&t[i]);
	forn(i,1,n) H.Add(x[i],y[i],i);
	/*--------建图 part----------*/
	forn(i,1,n) id[i] = i;
	sort(id+1,id+n+1,cmp);
	forn(i,1,n) if(t[id[i]] == 1) {            // situation 1
		int llst=i,lst=id[i],fir=id[i];
		for(int j=i+1;j<=n;++j) {
			if(x[id[j]]!=x[id[i]]) break ;
			llst = j;
			if(t[id[j]] == 1) Add(lst,id[j]),lst = id[j];
			else Add(id[i],id[j]);
		}
		if(lst^fir) Add(lst,fir);
		i = llst;
	}
	sort(id+1,id+n+1,cmp1);
	forn(i,1,n) if(t[id[i]] == 2) {           // situation 2
		int llst = i,lst=id[i],fir=id[i];
		for(int j=i+1;j<=n;++j) {
			if(y[id[i]]!=y[id[j]]) break ;
			llst = j;
			if(t[id[j]] == 2) Add(lst,id[j]),lst = id[j];
			else Add(id[i],id[j]);
		}
		if(lst^fir) Add(lst,fir);
		i = llst;
	}
	int v;
	forn(i,1,n) if(t[i] == 3)               // situation 3
		forn(j,0,7) if((v=H.Fnd(x[i]+dxx[j],y[i]+dyy[j])) != -1) 
			Add(i,v);
      /*--------缩点 Part--------*/
	forn(i,1,n) if(!dfn[i]) tarjan(i);
	forn(u,1,n) for(int i=G[u];i;i=E[i].nxt) {
		v = E[i].dir;
		if(clr[v] == clr[u]) continue ;
		AddDAG(clr[u],clr[v]); 
	}
     /*---------DP Part-------*/
	forn(i,1,col) if(!ind[i]) q.push(i),f[i] = num[i];
	while(!q.empty()) {
		int u = q.front();
		q.pop();
		for(int i=G1[u];i;i=DAG[i].nxt) {
			v = DAG[i].dir;
			f[v] = max(f[v],f[u]+num[v]);
			if(!--ind[v]) q.push(v);
		}
	}
	forn(i,1,col) Ans = max(Ans,f[i]);
	printf("%d\n",Ans);
	return 0;
}
```

---

## 作者：sodak (赞：0)

### 思路
这道题是一道很明显的Tar缩点，然后跑拓扑的题目，就是存图有一点点麻烦，用vector开数组代表每一行，每一列，记录每一行（或者每一列）中有特殊门的位置，这样对于“横天门”和“纵寰门”就很好处理了，主要就是“任意门”，可以把当前点的当前行和上一行，以及下一行跑一遍（小菜鸡只会暴力建边了），求符合情况的就可以了，最后Tarjan缩点，拓扑求解就OK 了
### 还不太清楚的话，可以看一下代码
```cpp

#include <bits/stdc++.h>
using namespace std;
const int maxn = 1e5 + 5;
struct Edge {
	int to, next;
}edge[maxn * 50], edge2[maxn * 50];
int n, r, c, kind[maxn], x[maxn], y[maxn], head[maxn], cnt;
int dfn[maxn], low[maxn], dfn_num, ins[maxn], stk[maxn], top;
int tot, belong[maxn], cnt2, in[maxn], f[maxn], head2[maxn];
vector<int> v1[maxn * 10], v2[maxn * 10], scc[maxn];
void Add(int u, int v) {
	edge[++cnt].to = v;
	edge[cnt].next = head[u];
	head[u] = cnt;
}
void Add2(int u, int v) {
	edge2[++cnt2].to = v;
	edge2[cnt2].next = head2[u];
	head2[u] = cnt2;
}
void Init() {
	scanf("%d%d%d", &n, &r, &c);
	for (int i = 1; i <= n; i++) {
		scanf("%d%d%d", &x[i], &y[i], &kind[i]);
		v1[x[i]].push_back(i);
		v2[y[i]].push_back(i);
	}
	for (int i = 1; i <= n; i++) {
		if (kind[i] == 1) {
			for (int j = 0; j < v1[x[i]].size(); j++) {
				int v = v1[x[i]][j];
				if (v == i) continue;
				Add(i, v);
			}
		}
		if (kind[i] == 2) {
			for (int j = 0; j < v2[y[i]].size(); j++) {
				int v = v2[y[i]][j];
				if (v == i) continue;
				Add(i, v);
			}
		}
		if (kind[i] == 3) {
			for (int k = max(1, x[i] - 1); k <= min(x[i] + 1, r); k++) {
				for (int j = 0; j < v1[k].size(); j++) {
					int v = v1[k][j];
					if (x[i] == x[v] && y[i] == y[v]) continue;
					if (abs(y[v] - y[i]) <= 1) Add(i, v);
				}
			}
		}
	}

}
void Tarjan(int rt) {
	low[rt] = dfn[rt] = ++dfn_num;
	stk[++top] = rt;
	ins[rt] = 1;
	for (int i = head[rt]; i; i = edge[i].next) {
		int v = edge[i].to;
		if (!dfn[v]) {
			Tarjan(v);
			low[rt] = min(low[rt], low[v]);
		}
		else if (ins[v])
			low[rt] = min(low[rt], dfn[v]);
	}
	if (low[rt] == dfn[rt]) {
		tot++;
		while (1) {
			int cur = stk[top--];
			scc[tot].push_back(cur);
			belong[cur] = tot;
			ins[cur] = 0;
			if (cur == rt) break;
		}
	}
}
void Topo() {
	queue<int> q;
	for (int i = 1; i <= tot; i++) {
		if (in[i] == 0) q.push(i), f[i] = scc[i].size();
	}
	while (q.size()) {
		int cur = q.front();
		q.pop();
		for (int i = head2[cur]; i; i = edge2[i].next) {
			int v = edge2[i].to;
			f[v] = max(f[v], f[cur] + (int)scc[v].size());
			in[v]--;
			if (!in[v]) q.push(v);
		}
	}
}
void Solve() {
	for (int i = 1; i <= n; i++) {
		if (!dfn[i]) Tarjan(i);
	}
	for (int i = 1; i <= n; i++) {
		for (int j = head[i]; j; j = edge[j].next) {
			int v = edge[j].to;
			if (belong[i] != belong[v]) {
				Add2(belong[i], belong[v]);
				in[belong[v]]++;
			}
		}
	}
	Topo();
	int ans = 0;
	for (int i = 1; i <= tot; i++) {
		ans = max(ans, f[i]);
	}
	printf("%d\n", ans);
}
int main() {
	Init();
	Solve();
	return 0;
}
```

---

## 作者：suxxsfe (赞：0)

[在我的 blog 中食用](https://www.cnblogs.com/suxxsfe/p/12727803.html)

**tarjan+DAG 上的 dp**  
难点在于建图和连边，其实也不难，就是细节挺恶心  
~~我和正解对拍拍出来 3 个错误。。。~~  

传送门：[luogu](https://www.luogu.com.cn/problem/P2403)  
[bzoj](http://www.lydsy.com/JudgeOnline/problem.php?id=1924)  

## 题目描述
有座宫殿呈矩阵状，由 $R\times C$ 间矩形宫室组成，其中有 $N$ 间宫室里埋藏着宝藏，称作藏宝宫室。宫殿里外、相邻宫室间都由坚硬的实体墙阻隔，由一间宫室到达另一间只能通过传送门。这 $N$ 间藏宝宫室每间都架设了一扇传送门，没有宝藏的宫室不设传送门，所有的宫室传送门分为三种：  

1. “横天门”：由该门可以传送到同行的任一宫室；  
2. “纵寰门”：由该门可以传送到同列的任一宫室；
3. “任意门”：由该门可以传送到以该门所在宫室为中心周围 $8$ 格中任一宫室（如果目标宫室存在的话）。  

初始时，可以由任意一间藏宝宫室进入，并由任意一间藏宝宫室离开，但只能进入离开一次  

## 输入格式
第一行给出三个正整数 $N,R,C$。  
以下 $N$ 行，每行给出一扇传送门的信息，包含三个正整数 $x_i, y_i, T_i$，表示该传送门设在位于第 $x_i$ 行第 $y_i$ 列的藏宝宫室，类型为 $T_i$。$T_i$ 是一个 $[1,3]$ 间的整数，$1$ 表示可以传送到第 $x_i$ 行任意一列的“横天门”，$2$ 表示可以传送到任意一行第 $y_i$ 列的“纵寰门”，$3$ 表示可以传送到周围 $8$ 格宫室的“任意门”。  

保证 $1\le x_i\le R,1\le y_i\le C$，所有的传送门位置互不相同。  

## 输出格式  
只有一个正整数，表示你确定的路线所经过不同藏宝宫室的最大数目。  

----------------  

对于每一个强连通分量，只要到达它中的一个点，剩下的点就都可以到达  
所以我们只要 tarjan 缩点以后，按照每个强连通分量间的边的关系，重新连边，然后这个就是一个 DAG  
这个 DAG 上的每个点的点权，就可以理解为对应的强连通分量的大小，也就是走到这个强连通分量能对答案产生多大贡献  
然后做个简单的 dp 就好了，用 $f_i$ 表示第 $i$ 个点（DAG 上的）结尾，最多可以产生多大的答案  
最终答案就是 $\max_{i=1}^{scccnt} f_i$，其中，$scccnt$ 当然就是强连通分量的个数  
同时也是新建的 DAG 的点数  

---------------  

现在考虑如何连边，直接连肯定T飞  

对于每一行，所以类型为 $1$ 的点（横着的门），可以连一个环，这样保证了从任意一个横着的门进入，都能去往同一行的其它所有类型为 $1$ 的门  
然后对于类型不是 $1$ 的门，随便找一个类型是 $1$ 的门，向它们连边，保证了从任意一个横着的门，都可以去往同一行中，不是类型 $1$ 的门  
就符合要求了  
具体实现要先对所以门排序，然后按照每一行枚举  
细节比较多，具体看代码中的注释  
那么对于每一列也是如此  

对于那种“任意门”更简单那了，用 `map` 记录每个位置是不是藏宝宫室，如果是就连边就行了  

```cpp  
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<cmath>
#include<map>
#include<utility>
#include<iomanip>
#include<queue>
#include<cstring>
#define reg register
#define EN std::puts("")
#define LL long long
inline int read(){
	register int x=0;register int y=1;
	register char c=std::getchar();
	while(c<'0'||c>'9'){if(c=='-') y=0;c=std::getchar();}
	while(c>='0'&&c<='9'){x=x*10+(c^48);c=std::getchar();}
	return y?x:-x;
}
int n;
#define N 100006
#define M 1000006
struct data{
	int x,y,id,type;
}p[N];
int have_1[1000006],have_2[1000006];
int fir[N],nex[M],to[M],tot;
int fir_[N],nex_[M],to_[M],tot_;
std::map<std::pair<int,int>,int>map;
int dfn[N],low[N],dfscnt;
int scc[N],size[N],scccnt;
int stack[N],top;
int in[N];
void debug(){
	int a;
	return;
}
inline void add(int u,int v){
		if(u==4&&v==1) debug();
	to[++tot]=v;
	nex[tot]=fir[u];fir[u]=tot;
}
inline void add_(int u,int v){
	to_[++tot_]=v;
	nex_[tot_]=fir_[u];fir_[u]=tot_;
}
inline int cmpx(data x,data y){
	if(x.x==y.x) return x.type<y.type;//横在前
	return x.x<y.x; 
}
inline int cmpy(data x,data y){
	if(x.y==y.y) return x.type>y.type;
	return x.y<y.y;
}
void tarjan(int u){
	dfn[u]=low[u]=++dfscnt;stack[top++]=u;
	for(reg int v,i=fir[u];i;i=nex[i]){
		v=to[i];
		if(!dfn[v]){
			tarjan(v);low[u]=std::min(low[u],low[v]);
		}
		else if(!scc[v]) low[u]=std::min(low[u],dfn[v]);
	}
	if(low[u]==dfn[u]){
		scccnt++;
		do{
			size[scccnt]++;scc[stack[--top]]=scccnt;
		}while(stack[top]!=u);
	}
}
inline void build(){
	std::sort(p+1,p+1+n,cmpx);
	for(reg int i=1;i<=n;){
		if(!have_1[p[i].x]){
			//如果这一行没有 1 类型的门（横的门），那么这一行内肯定不会有连边
			//这里如果不特判后面会出问题，在这一行一个 1 的门都没有的情况下 
			int now_x=p[i].x;
			for(i++;p[i].x==now_x;i++);
			continue;
		}
		int now_x=p[i].x,now=p[i].id;
		int last_i=i;//last_i 是环中第一个点，同时我门也选这个点，向其它类型不是 1 的门连边 
		for(i++;p[i].x==now_x&&p[i].type==1&&i<=n;i++) add(p[i-1].id,p[i].id);//横的连成环 
		add(p[i-1].id,p[last_i].id);//连回去，才能构成一个环 
		for(;p[i].x==now_x&&i<=n;i++) add(now,p[i].id);
	}
	std::sort(p+1,p+1+n,cmpy);
	for(reg int i=1;i<=n;){
		if(!have_2[p[i].y]){//同理 
			int now_y=p[i].y;
			for(i++;p[i].y==now_y;i++);
			continue;
		}
		int now_y=p[i].y,tmp=i;//记录这一列是从哪标号开始的 
		for(;p[i].y==now_y&&i<=n&&p[i].type==3;i++);
		int now=p[i].id,last_i=i;//last_i 是环中第一个点，now 即为我门选取的那个类型为 2 的门，从他向其它类型不为 2 的门连边 
		for(i++;p[i].y==now_y&&i<=n&&p[i].type==2;i++) add(p[i-1].id,p[i].id);//同理，纵的连成环 
		add(p[i-1].id,p[last_i].id);//连回去，才能构成一个环
		for(;p[i].y==now_y&&i<=n;i++) add(now,p[i].id);
		for(reg int j=tmp;p[j].y==now_y&&j<=n&&p[j].type==3;j++) add(now,p[j].id);
		//上面一行这是类型是 3 的门，因为排序时把他们放在了最前面，所以先记录下起始点，要在确定了一个类型 2 的门以后再重新从起始点开始循环，连边 
	}
}
const int dx[8]={0,0,1,1,1,-1,-1,-1};
const int dy[8]={-1,1,-1,0,1,-1,0,1};
inline void build_8(){
	std::pair<int,int>pair;
	for(reg int i=1;i<=n;i++)if(p[i].type==3){
		reg int x=p[i].x,y=p[i].y,id=p[i].id,x_,y_;
		for(reg int k=0;k<8;k++){
			x_=x+dx[k];y_=y+dy[k];
			pair=std::make_pair(x_,y_);
			if(map.find(pair)!=map.end()) add(id,map[pair]);
		}
	}
}
inline void rebuild(){
	for(reg int i=1;i<=n;i++)
		for(reg int j=fir[i];j;j=nex[j])if(scc[i]!=scc[to[j]])
			add_(scc[i],scc[to[j]]),in[scc[to[j]]]++;
}
std::queue<int>q;
int f[100006];
inline void topo(){
	for(reg int i=1;i<=scccnt;i++)if(!in[i])
		q.push(i),f[i]=size[i];
	reg int u,v;
	while(!q.empty()){
		u=q.front();q.pop();
		for(reg int i=fir_[u];i;i=nex_[i]){
			v=to_[i];
			f[v]=std::max(f[v],f[u]);
			if(!--in[v]) f[v]+=size[v],q.push(v);
		}
	}
}
int main(){
//		std::freopen("1.in","r",stdin);
	n=read();read();read();
	for(reg int i=1;i<=n;i++){
		p[i].x=read();p[i].y=read();p[i].type=read();p[i].id=i;
		map[std::make_pair(p[i].x,p[i].y)]=i;
		if(p[i].type==1) have_1[p[i].x]=1;
		if(p[i].type==2) have_2[p[i].y]=1;
	}
	build();build_8();
	for(reg int i=1;i<=n;i++)if(!dfn[i]) tarjan(i);
	rebuild();
	topo();
	reg int ans=0;
	for(reg int i=1;i<=scccnt;i++) ans=std::max(ans,f[i]);
	std::printf("%d",ans);
//		EN;EN;EN;
//		for(reg int i=1;i<=n;i++){
//			std::printf("%d : ",i);
//			for(reg int j=fir[i];j;j=nex[j]) std::printf("%d ",to[j]);
//			EN;
//		}
//		for(reg int i=1;i<=n;i++) std::printf("%d ",scc[i]);EN;
//		std::puts("new : ");
//		for(reg int i=1;i<=n;i++){
//			std::printf("%d : ",i);
//			for(reg int j=fir_[i];j;j=nex_[j]) std::printf("%d ",to_[j]);
//			EN;
//		}
	return 0;
}
```

---

## 作者：panyf (赞：0)

小常数哈希表做法，不用排序，约300msAC

细节题，思路很好想但代码不好调，仅数组就开了29个

思路：

对所有出现的行和列各建一个虚点，对于横天门，向行虚点连边，对于纵寰门，向列虚点连边。任意门较为复杂，用哈希表存储出现的坐标，依次判断8个位置，如果有点就连边。连完边跑tarjan，然后拓扑。

注意事项：

1.任意门必须在读入所有点以后再连边，否则会少连

2.统计强连通分量大小时不要统计虚点

详细注释代码：

```cpp
#include<cstdio>
const int N=300009,M=1000009,Q=100009;
int f1[M],f2[M];//存储虚点序号
int ne[M],to[M],he[N];//连边
int n1[Q],t1[Q],u1[Q],v1[Q],h1[N];//哈希表
int s1[N],s2[N],s3[N];//存储任意门
bool b[N];//判断是否为虚点
int find(const int&x,const int&y){
	register int z=((x<<5)+y)&262143,i;//乱写的哈希
	for(i=h1[z];i;i=n1[i])if(t1[i]==x&&u1[i]==y)return v1[i];
	return 0;
}
int dfn[N],low[N],fa[N],st[N],tp,id,c,sz[N];//跑tarjan用的，sz为分量大小
void tarjan(const int&x){
	dfn[x]=low[x]=++id,st[++tp]=x;
	for(register int i=he[x],j;i;i=ne[i]){
		if(!dfn[j=to[i]]){
			tarjan(j);
			if(low[j]<low[x])low[x]=low[j];
		}else if(!fa[j]&&dfn[j]<low[x])low[x]=dfn[j];
	}
	if(dfn[x]==low[x]){
		++c;
		while(st[tp]!=x)sz[c]+=b[st[tp]],fa[st[tp--]]=c;
		sz[c]+=b[st[tp]],fa[st[tp--]]=c;
	}
}
int n2[M],t2[M],u2[M],h2[N],tt;//第二次哈希，防止给DAG连边时连重边
bool qry(const int&x,const int&y){
	register int z=((x<<5)+y)&262143,i;
	for(i=h2[z];i;i=n2[i])if(t2[i]==x&&u2[i]==y)return 0;
	n2[++tt]=h2[z],t2[tt]=x,u2[tt]=y,h2[z]=tt;
	return 1;
}
int dg[N],q[N],dp[N];//拓扑排序用的
int h3[N],t3[M],n3[M];//DAG的连边
int main(){
    register int n,i,j,k,l,g,h,t=0,v=0,w=0,qh=0,qt=0;
    scanf("%d%*d%*d",&n),++n;
    while(--n){
    	scanf("%d%d%d",&i,&j,&k);
    	if(!f1[i])f1[i]=++v;
    	if(!f2[j])f2[j]=++v;//增加新的虚点
    	g=f1[i],h=f2[j],l=((i<<5)+j)&262143,++v;
		n1[n]=h1[l],t1[n]=i,u1[n]=j,v1[n]=v,h1[l]=n,b[v]=1;//将点存入哈希表
		ne[++t]=he[g],to[t]=v,he[g]=t;
		ne[++t]=he[h],to[t]=v,he[h]=t;//从虚点连边
    	if(k==1)ne[++t]=he[v],to[t]=g,he[v]=t;
    	else if(k==2)ne[++t]=he[v],to[t]=h,he[v]=t;//向虚点连边
    	else s1[++w]=i,s2[w]=j,s3[w]=v;//存储任意门
	}
	for(l=1;l<=w;++l){
		i=s1[l],j=s2[l],g=s3[l];
		if(k=find(i-1,j-1),k)ne[++t]=he[g],to[t]=k,he[g]=t;
    	if(k=find(i-1,j),k)ne[++t]=he[g],to[t]=k,he[g]=t;
    	if(k=find(i-1,j+1),k)ne[++t]=he[g],to[t]=k,he[g]=t;
    	if(k=find(i,j-1),k)ne[++t]=he[g],to[t]=k,he[g]=t;
    	if(k=find(i,j+1),k)ne[++t]=he[g],to[t]=k,he[g]=t;
    	if(k=find(i+1,j-1),k)ne[++t]=he[g],to[t]=k,he[g]=t;
    	if(k=find(i+1,j),k)ne[++t]=he[g],to[t]=k,he[g]=t;
    	if(k=find(i+1,j+1),k)ne[++t]=he[g],to[t]=k,he[g]=t;//任意门连边
	}
	for(i=1;i<=v;++i)if(!dfn[i])tarjan(i);
	for(i=1,t=0;i<=v;++i){
		for(k=fa[i],j=he[i];j;j=ne[j]){
			l=fa[to[j]];
			if(k!=l&&qry(k,l))n3[++t]=h3[k],t3[t]=l,h3[k]=t,++dg[l];//DAG连边，统计入度
		}
	}
	for(i=1;i<=c;++i)if(!dg[i])q[++qt]=i,dp[i]=sz[i];//初始入队
	while(qh!=qt){
		for(j=h3[i=q[++qh]];j;j=n3[j]){
			--dg[k=t3[j]];
			if(!dg[k])q[++qt]=k;
			l=dp[i]+sz[k];
			if(dp[k]<l)dp[k]=l;
		}
	}//拓扑排序
	for(i=1,t=0;i<=c;++i)if(t<dp[i])t=dp[i];
	printf("%d",t);
    return 0;
}
```


---

## 作者：Tari (赞：0)

### 我要说：
## 记住！map一定要这么用：
```
if(mp[x[i]+dx[j]].find(y[i]+dy[j])!=mp[x[i]+dx[j]].end()) 
add(i,mp[x[i]+dx[j]][y[i]+dy[j]]);
```
#### 　　而不是
```
R tmp=mp[x[i]+dx[j]][y[i]+dy[j]];
if(tmp) add(i,tmp);
```
## 否则你~~可能~~会MLE
#### ~~别问我为什么QAQ~~

### 另：我的代码只有70行，因为没有各种排序，直接建图，跑的也很快

建图：选定一个横天门，向在这一行上的横天门连无向边，剩下的门连有向边；纵寰门一样的方法

用map判自由门旁边八个点是否存在，存在就连边；

最后tarjan缩点，用dp求最长路

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<vector>
#include<map>
#define R register int
const int dx[]={0,1,1,1,0,-1,-1,-1},dy[]={1,1,0,-1,-1,-1,0,1};
using namespace std;
inline int g() {
	R ret=0; register char ch; while(!isdigit(ch=getchar())) ;
	do ret=ret*10+(ch^48); while(isdigit(ch=getchar())); return ret;
}
#define pb(x) push_back(x) 
int k,n,m,cnt=1,ind,cc,top,ans,num;
int lst[100010],lst2[100010],x[100010],y[100010],op[100010],d[100010];
int vr[1000010],nxt[1000010],fir[1000010],dfn[100010],scc[100010],stk[100010],low[100010],c[100010];
vector<int>a[1000010],b[1000010];
map<int,int> mp[1000010];
bool vis[100010];
inline void add(int u,int v) {if(u==v) return ;vr[++cnt]=v,nxt[cnt]=fir[u],fir[u]=cnt;}
inline void init() {
	for(R i=1;i<=n;++i) {
		R x=0,sz=a[i].size();
		for(R j=0;j<sz;++j) if(op[a[i][j]]==1) {x=a[i][j]; break;}
		for(R j=0;j<sz;++j) {add(x,a[i][j]); if(op[a[i][j]]==1) add(a[i][j],x);}
	}
	for(R i=1;i<=m;++i) {
		R x=0,sz=b[i].size();
		for(R j=0;j<sz;++j) if(op[b[i][j]]==2) {x=b[i][j]; break;}
		for(R j=0;j<sz;++j) {add(x,b[i][j]); if(op[b[i][j]]==2) add(b[i][j],x);}
	}
	for(R i=1;i<=k;++i) if(op[i]==3) for(R j=0;j<8;++j) 
		if(mp[x[i]+dx[j]].find(y[i]+dy[j])!=mp[x[i]+dx[j]].end()) add(i,mp[x[i]+dx[j]][y[i]+dy[j]]);
}
void tarjan(int u) { low[u]=dfn[u]=++num; stk[++top]=u,vis[u]=true;
	for(R i=fir[u];i;i=nxt[i]) { R v=vr[i];
		if(!dfn[v]) {
			tarjan(v);
			low[u]=min(low[u],low[v]);
		} else if(vis[v]) low[u]=min(low[u],dfn[v]);
	} if(low[u]==dfn[u]) {
		R tmp; ++cc;
		do tmp=stk[top],--top,vis[tmp]=false,c[tmp]=cc,++scc[cc]; while(tmp!=u);
	}
}
int vv[1000010],nn[1000010],ff[1000010];
inline void addc(int u,int v) {vv[++cnt]=v,nn[cnt]=ff[u],ff[u]=cnt;}
inline void solve() {
	cnt=1; for(R u=1;u<=k;++u) for(R i=fir[u];i;i=nxt[i]) 
		if(c[u]!=c[vr[i]]) addc(c[u],c[vr[i]]);
}
inline void dp(int u) { vis[u]=true;
	for(R i=ff[u];i;i=nn[i]) { R v=vv[i];
		if(!vis[v]) dp(v);
		d[u]=max(d[v],d[u]);
	} d[u]+=scc[u]; ans=max(d[u],ans);
}
signed main() {
	k=g(),n=g(),m=g();
	for(R i=1;i<=k;++i) {
		x[i]=g(),y[i]=g(),op[i]=g();
		mp[x[i]][y[i]]=i;
		a[x[i]].pb(i),b[y[i]].pb(i);
	} init(); for(R i=1;i<=k;++i) if(!dfn[i]) tarjan(i);
	solve(); memset(vis,false,sizeof(vis));
	for(R i=1;i<=cc;++i) if(!vis[i]) dp(i);
	printf("%d\n",ans); return 0;
}
```

---


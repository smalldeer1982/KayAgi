# [APIO2009] 会议中心

## 题目描述

Siruseri 政府建造了一座新的会议中心。许多公司对租借会议中心的会堂很 感兴趣，他们希望能够在里面举行会议。

对于一个客户而言，仅当在开会时能够独自占用整个会堂，他才会租借会堂。 会议中心的销售主管认为：最好的策略应该是将会堂租借给尽可能多的客户。

显 然，有可能存在不止一种满足要求的策略。 例如下面的例子。总共有 4 个公司。他们对租借会堂发出了请求，并提出了 他们所需占用会堂的起止日期（如下表所示）。

```cpp
       开始日期 结束日期 
 公司1    4        9 
 公司2    9        11 
 公司3    13       19 
 公司4    10       17 
```
上例中，最多将会堂租借给两家公司。租借策略分别是租给公司 1 和公司 3， 或是公司 2 和公司 3，也可以是公司 1 和公司 4。注意会议中心一天最多租借给 一个公司，所以公司 1 和公司 2 不能同时租借会议中心，因为他们在第九天重合 了。

销售主管为了公平起见，决定按照如下的程序来确定选择何种租借策略：首 先，将租借给客户数量最多的策略作为候选，将所有的公司按照他们发出请求的 顺序编号。对于候选策略，将策略中的每家公司的编号按升序排列。最后，选出 其中字典序最小1的候选策略作为最终的策略。

例中，会堂最终将被租借给公司 1 和公司 3：3 个候选策略是 {(1,3),(2,3),(1,4)}。而在字典序中(1,3)<(1,4)<(2,3)。 你的任务是帮助销售主管确定应该将会堂租借给哪些公司。


## 说明/提示

对于 50%的输入，N≤3000。

在所有输入中，N≤200000。


## 样例 #1

### 输入

```
4 
4 9
9 11 
13 19 
10 17```

### 输出

```
2
1 3```

# 题解

## 作者：jjsnam (赞：26)

# 写在前面

**Update on 2023.7.6：感谢 @yizhiming 指出代码有一处锅。**

这道题真的是神毒瘤题。质量很好，毒瘤主要是题解写的都太简略了，就好像第一问默认大家都会一样，然后各种做法层出不穷，也不讲一讲直接放代码。反正我作为一个阅读者体验非常不好。调了一天终于弄懂了，来补一篇正解的详细做法。

## 前置知识

- 倍增
- 贪心
- STL：```set``` 用法
- 离散化

## 题目描述（戳这里[查看原题](https://www.luogu.com.cn/problem/P3626)）

- 给定 $n$ 个线段，编号 $1$ 到 $n$。

- 求把这些线段放在数轴上，在两两不相交的情况下**最多能放多少个**，记作 $m$。

- 在满足总数为 $m$ 的情况下，使数轴上的线段的编号组成的集合（**排序后**）**字典序最小**。输出此时的集合 $Ans$。

- $n ≤ 2\times 10^5$。

# 正文

把刚才的形象化题意再剥离一下，第一问就是求最大线段覆盖，第二问就是让使用的线段编号尽可能小。

## 尝试

第一问的求法很多，贪心或者 DP 都是可以的，我们看看第二问更适合哪种方法就用哪种方法。

一般与字典序有关的题目，DP 是首选，贪心思维难度则要更大一些。所以我们**先考虑 DP**。

例如，我们设 $f_{i}$ 表示以第 $i$ 个线段为首后能插入的最多线段数。我们将读入线段标记编号后按左端点排序，存入结构体 $seg_i$ 中。那么对于 $f_i$ 转移：
$$
f_i = \max_{seg_j.l > seg_i.r}^{0≤j ≤ n}{f_j} +1
$$
这样就是一个区间最大值转移问题，可以用线段树优化，时间复杂度 $O(n\log n)$。

但是别忘了还有第二问。注意最后的集合是排完序字典序最小，而不是按线段值的大小加入的顺序字典序最小，所以我们需要记录整个线段集合。我没有想到什么好方法，直接变成了树套树，时间复杂度 $O(n\log^2n)$。而且空间也爆炸，这是一个[50分 记录](https://www.luogu.com.cn/record/85512930)。

因此，**DP 不是一个好选择**。

## 分析

那我们再考虑贪心。通过刚才的思考，我们发现第二问是更恶心的，所以我们假设第一问已经求得了最大的 $m$。第二问如何求呢？

可以想到，按编号从小到大依次确定插入的线段，如果满足条件则一定是最优的。接下来考虑条件是什么。

我们把满足最优解的线段集合记作 $S$（任意时刻满足 $S\subseteq Ans$ 且 $S$ 可以为 $\varnothing$），我们考虑加入一个新的线段 $seg_i$。那么，首先要满足的是**插入后一定有办法使最后集合里的线段总数仍然是 $m$**。如果不满足这个条件，无论编号多小都不能再贪了，因为不满足第一问的条件。

插入这个线段后可能对答案有影响的最大区间如何找？假设我们在 $S$ 中找到 $seg_i$ 的前驱 $seg_L$ 和后继 $seg_R$。那么**它插入后对其前驱即前驱之前的区间的最优放置方案没有影响**；同理，对于后继即后继之后的区间也没有影响。有影响的是**前驱和后继之间的那段区间**，如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/6na3blx0.png)

用数学方法表示，最多可能有影响的区间是 $[seg_L.r+1,seg_R.l - 1]$。

接下来考虑条件如何满足。对于任意一个确定的区间，我们最多能放置的线段数都是可以确定的，记作 $f(l,r)$。为了使最后整个数轴放的线段最多，贪心的思路就是使每个子区间都达到最优放置方案，也就是**每个子区间的 $f$ 和就是最后的 $m$**。可以证明这样贪心是正确的。

那么对于可能有影响的区间，原来最多能放置的线段数记作 $Pre = f(seg_L.r+1,seg_R.l - 1)$，在这个区间里确定了某个线段后，区间再次被分成 $3$ 部分，即加入的线段左边，加入的线段和加入的线段右边（对应 $[seg_L.r+1,seg_i.l-1]$、$[seg_i.l,seg_i.r]$、$[seg_i.r+1, seg_R.l-1]$）。而且中间的 $f$ 值一定是 $1$（钦定**只放加入的线段**）。

如果我们加入这条新的线段可以不使答案变差，也就是加入后划分出的三个子区间最多能放的线段数之和还是大区间原来最多能放的数量，那么**加入这条线段后总的答案不会变劣**，还是 $m$；又因为从小到大枚举编号，此时加入这条线段一定是**满足条件下编号最小的**，也就满足了排序后线段集合字典序最小的要求，**可以作为第二问的答案**。

最终满足的条件形象化写出来是这样的：
$$
	Pre=f(seg_L.r+1,seg_i.l-1)+f(seg_i.r+1, seg_R.l-1)+1
$$

## 细节与实现

大致思路理清了，我们来考虑一下具体怎么做，毕竟刚才跳过了很多。

1.  首先考虑 $f$ 如何求。
   
    每个线段左右端点值的大小最大可以达到 $10^9$，所以我们先对数据**离散化**，这样就最多只有 $n\times2$ 个有用的数点。

    然而，如果我们处理出所有 $f(l,r)$ 的时间复杂度是 $O(n^2)$ 的。考虑优化。这些有用的数点对应的线段都是一定的，而且根据贪心每个线段之后连接的最优线段也是可以确定的，所以我们尝试**倍增**。$ne(i,k)$ 表示数点 $i$ 往右选 $2^k$ 个线段后到达的**最小右端点**（这样就满足了每次都是选最优线段）。
   
    但是一个数点的含义可能很复杂，比如这个点既是某些线段的右端点，也是某些线段的左端点，因而需要考虑很多情况，每个数点右侧第一个最优线段的选择**不好实现**。 
    考虑到每个线段的下一个线段是可以贪心求出的，我们可以对 $ne$ 的定义略加修改。定义 $ne(i, k)$ 表示线段 $seg_i$ 往右再选 $2^k$ 个线段后到达的**使右端点最小的线段的编号**。同样，我们将 $f(st,r)$ 定义为从线段 $seg_{st}$ 往后选线段，使最后一个线段的右端点不超过 $r$，最多选多少个。
   
    注意这样调用 $f(st,r)$ 函数是**不包括一开始的线段 $seg_{st}$ 的**。当然包括也可以，但是不包括更方便一些，尤其对于之后第二问的操作，我们分成三段后前后两段的 $f$ 值在求的时候以**加入线段的前驱**和**加入的线段**作为起点即可。而包括 $seg_{st}$ 则还要以前驱后第一个最优线段作为前段的起点，多了一步，后段同理。
   
    这样 $f(st,r)$ 可以通过下面的代码求出：
    ```cpp
    int f(int st, int r){
        int res = 0;
        for (int k = Log2; k >= 0; k --){
            if (seg[ne[st][k]].r <= r){
                res += (1 << k), st = ne[st][k];
            }
        }
        return res;
    }
    ```
2.  $ne(i, k)$ 如何求？
	
	根据一般倍增的经验，我们只需要求 $ne(i,0)$，也就是每条线段下一个最优线段，然后循环 $k$ 暴力跳递推即可。
    $$ne(i,k) = ne(ne(i,k-1),k-1)$$
    现在考虑如何求 $ne(i,0)$。即对于每个线段，我们要找到左端点大于当前线段右端点且右端点尽可能小的线段。如果我们将所有线段按左端点为关键字排序，则最后变成了一个 RMQ 问题。我这里使用的是后缀最小值倒推的方法。
    
    因为有用数点总数是 $O(n)$ 级别的，所以定义 $Min_i$ 表示离散化后数点 $i$ 及其右侧的所有左端点**不小于** $i$ 的线段最小的右端点。$pos_i$ 则表示使右端点最小的这个线段的编号。
    
    递推时先赋值 $\forall Min_{seg_i.l} = seg_i.r$（这里的 $i$ 是遍历每个线段）。然后倒推，对于每个数点 $i$，如果 $Min_i > Min_{i+1}$，则用 $i+1$ 来更新 $i$ 的 $Min$ 和 $pos$ 值。

3.  再来考虑求第二问时的前驱后继如何找。我们可以通过 STL 中的 set 维护 $S$ 中的数点（每个线段的左右端点），这样就可以通过 set 内置的 ```upper_bound``` 函数求出前驱后继了。具体地，在记录数点时可以同时记录每个数点对应的线段（因为集合里的线段不可能重合，所以每个点的含义**有且只有一个**）。先用 ```upper_bound``` 函数求出第一个大于新加入线段右端点的线段的编号，此时迭代器指针前移 $1$ 就是第一个小于线段左端点的编号。
	
    但这样有一个问题，如果加入的线段与集合中某个线段重合怎么办？根据定义不能包含两者，而根据贪心顺序集合里的线段的编号一定比新加入的线段编号小，故这个新的线段不论满不满足条件**都要舍弃**。可以通过判断新加入的线段左右端点 ```upper_bound``` 值是否相等确定是否有与集合内线段重合的情况。

4.  不管是用 set 维护时前两次加入线段找前驱后继，还是在递推 $ne$ 倍增数组跳出所有线段后应到达的位置，都需要边界处理。为了方便，我们可以**构建两个“哨兵线段”**。一个编号为 $0$，左右端点都是极小值；一个编号为 $n+1$，左右端点都是极大值。这样的话 $ne(n+1,0) = n+1$，再次递推时不会 RE；在求答案前先加入两个哨兵线段，这样新加入线段时不会出现返回迭代器为空的情况。码量减少了很多。

5. 话说了这么多，别忘了 $m$ 还没解决。但有了“哨兵线段”后，我们可以从极小哨兵开始，取到极大哨兵的左端点（不包括），这样就是最大区间的最优情况。即 ```m = f(0, inf-1)```。



------------


最终的时间复杂度是 $O(n\log n)$。瓶颈在于倍增和 set 及其常数。

# 代码

变量名与文章中的数组无异，必要注释已添加。代码略长，建议自己写一遍。

```cpp
#include <iostream>
#include <algorithm>
#include <cstring>
#include <set>

using namespace std;
const int maxn = 200005;
const int inf = 1e9;

struct Segment{
    int l, r, id;
}seg[maxn];
int Disc[maxn << 1], cnt; //离散化
int n, Log2;
int ne[maxn][18], Mn[maxn << 1], pos[maxn << 1];
struct Node{
    int v, id;

    bool operator < (const Node &b) const{
        return v < b.v;
    }
};
set<Node> s;

bool cmp1(Segment a, Segment b){
    return a.l < b.l;
}

bool cmp2(Segment a, Segment b){
    return a.id < b.id;
}

int getMx(int st, int r){
    int res = 0;
    for (int k = Log2; k >= 0; k --){
        if (seg[ne[st][k]].r <= r){
            res += (1 << k), st = ne[st][k];
        }
    }
    return res;
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    
    cin >> n;
    while ((1 << Log2) <= n) Log2 ++; Log2 --; //floor(log_2{n})
    for (int i = 1, l, r; i <= n; i ++){
        cin >> l >> r;
        Disc[++ cnt] = l, Disc[++ cnt] = r;
        seg[i] = (Segment){l, r, i};
    }

    /* 离散化 */
    sort(Disc+1, Disc+cnt+1);
    cnt = unique(Disc+1, Disc+cnt+1) - Disc - 1;
    for (int i = 1; i <= n; i ++){
        seg[i].l = lower_bound(Disc+1, Disc+cnt+1, seg[i].l) - Disc;
        seg[i].r = lower_bound(Disc+1, Disc+cnt+1, seg[i].r) - Disc;
    }

    /* 处理倍增 */
    sort(seg+1, seg+n+1, cmp1);
    seg[n+1] = (Segment){inf, inf, n+1}, seg[0] = (Segment){-inf, -inf, 0};
    /* 先递推后缀最小值 */
    memset(Mn, 0x3f, sizeof Mn);
    Mn[cnt+1] = cnt+1, pos[cnt+1] = n+1;
    for (int i = n; i > 0; i --){
        if (Mn[seg[i].l] > seg[i].r){
            Mn[seg[i].l] = seg[i].r, pos[seg[i].l] = seg[i].id;
        }
    }
    for (int i = cnt; i > 0; i --){
        if (Mn[i] > Mn[i+1]){
            Mn[i] = Mn[i+1], pos[i] = pos[i+1];
        }
    }
    /* 更新倍增数组 */
    ne[n+1][0] = n+1;
    for (int i = 1; i <= n; i ++){
        ne[seg[i].id][0] = pos[seg[i].r+1];
    }
    int st = n+1;
    for (int i = 1; i <= n; i ++){
        if (seg[i].r < seg[st].r) st = i;
    }
    ne[0][0] = seg[st].id;
    for (int k = 1; k <= Log2; k ++){
        for (int i = 0; i <= n + 1; i ++){
            ne[i][k] = ne[ne[i][k-1]][k-1];
        }
    }
    
    /* 注意！统计答案前应该先还原线段排列，因为ne存的是原始线段的编号 */
    sort(seg+1, seg+n+1, cmp2);

    /* 计算M */
    int M = getMx(0, inf-1);
    cout << M << endl;
    
    /* 添加“哨兵” */
    s.insert((Node){-inf, 0}), s.insert((Node){inf, n+1});

    /* 贪心模拟 */
    set<Node>::iterator it;
    for (int i = 1; i <= n; i ++){
        if (s.upper_bound((Node){seg[i].l, seg[i].id}) != s.upper_bound((Node){seg[i].r, seg[i].id})) continue; //有重合
        it = s.upper_bound((Node){seg[i].r, seg[i].id});
        Node L = *it;
        it --;
        Node R = *it;
        if (getMx(R.id, seg[i].l-1) + getMx(i, L.v-1) + 1 != getMx(R.id, L.v-1)) continue;
        cout << i << ' ';
        s.insert((Node){seg[i].l, seg[i].id}), 
        s.insert((Node){seg[i].r, seg[i].id});
    }
    cout << endl;

    return 0;
}
```

# 总结

这道题确实考点很多，另外我觉得贪心真的很难。

主要是这道题的题解区太乱了，高赞的都是囫囵吞枣讲一堆，真正有点价值又被排到了后面，所以我才想写一篇完整思路，不过篇幅略长。

谢谢观看！





---

## 作者：lokiii (赞：15)

数组若干+手动二分

====================废话分割线======================

我我我我我！一定要说一下我的心路历程！我只用了几个数组和一个手动二分！在洛谷和bzoj都过了所以应该是对的！（跑的挺快甚至和学长合了影
事情是这样的，我首先在洛谷瞎贪心贪了55，然后调不出来去看正解，发现好麻烦啊，同时觉得我的贪心还挺对的，于是搞了一份标程拍，拍着拍着就拍出错了，发现判断字典序不太对，我忘记排过序了所以不能直接取尾部，于是顺着pr往前跳取min，于是A了！bzoj rank15欸！看到了两个学长欸！卡卡常卡卡常，于是升到rank8~~并且为了全场最短改了代码风格~~

====================废话分割线======================

先打上id顺序按r排序，f存当前最多能接待的公司，s存前缀f最大值（值相同取字典序最小），p存s最大值位置，pr存这个点是从哪个点转移过来的。然后对第i个l，二分找出最右的r小于当前l，设为w，用s[w]更新当前数组f[i]，连上前缀pr[i]=p[w]，然后分三种情况修改s和p数组。

1、s[i-1]<f[i]，直接s[i]=s[i-1],p[i]=p[i-1]即可；

2、s[i-1]>f[i]，即当前前缀和最大值为当前i点，所以s[i]=f[i],p[i]=i;

3、对于相等的情况对于这两个点i和p[i-1]，沿着pr往前跳，直到pr相等（因为pr相等之后两个点经过的点就相同了），对于经过的点的id取min，于是这两个min就是升序排序后最早不同的方案位置，所以比较这两个来决定转到情况1或2.

然后就没了。是不是超简单？
~~但是还是去学一下思路神奇的正解吧~~
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=200005;
int n,s[N],p[N],q[N],top,pr[N];
struct qwe {
    int l,r,id;
} a[N];
bool cmp(const qwe &a,const qwe &b) {
    return a.r<b.r;
}
int read() {
    int r=0,f=1;
    char p=getchar();
    while(p>'9'||p<'0') {
        if(p=='-') f=-1;
        p=getchar();
    }
    while(p>='0'&&p<='9') {
        r=r*10+p-48;
        p=getchar();
    }
    return r*f;
}
int main() {
    n=read();
    for(int i=1; i<=n; i++) a[i].l=read(),a[i].r=read(),a[i].id=i;
    sort(a+1,a+1+n,cmp);
    for(int i=1; i<=n; i++) {
        int w=0,l=0,r=i-1,k=a[i].l;
        while(l<=r) {
            int mid=(l+r)>>1;
            if(a[mid].r<k) w=mid,l=mid+1;
            else r=mid-1;
        }
        int now=s[w]+1;
        pr[i]=p[w];
        if(s[i-1]>now) s[i]=s[i-1],p[i]=p[i-1];
        else if(s[i-1]==now) {
            int p1=p[i-1],p2=i,mn1=1e9,mn2=1e9;
            while(pr[p1]!=pr[p2]) {
                if(a[p1].id<mn1) mn1=a[p1].id;
                if(a[p2].id<mn2) mn2=a[p2].id;
                p1=pr[p1],p2=pr[p2];
            }
            if(a[p1].id<mn1) mn1=a[p1].id;
            if(a[p2].id<mn2) mn2=a[p2].id;
            if(mn1<mn2) s[i]=s[i-1],p[i]=p[i-1];
            else s[i]=now,p[i]=i;
        }
        else s[i]=now,p[i]=i;
    }
    printf("%d\n",s[n]);
    int now=p[n];
    while(now)
        q[++top]=a[now].id,now=pr[now];
    sort(q+1,q+1+top);
    for(int i=1; i<=top; i++) printf("%d ",q[i]);
    return 0;
}
```

---

## 作者：GoldenPotato137 (赞：13)

蒟蒻博客：[QAQ](https://www.cnblogs.com/GoldenPotato/p/9574519.html)



------------

## Solution

如果题目只要求求出第一问，那这题显然就是大水题。

但是加上第二问的话.......那这题就成为大（du）火（liu）题了。

.


对于第一问：求一整个区间的最大线段总数，我们可以很轻松的切掉。

怎么处理第二问呢？

我们可以考虑这样做：

**对于一条线段，如果它属于答案的一部分，那么它一定会有以下性质：
**

**区间③的最大线段数 = 区间①的最大线段数 + 区间②的最大线段数 + 1（当前线段） （区间最大线段数指用传统贪心方法求出的一段区间的可能的最多的线段的数量）**

![QAQ](https://cdn.luogu.com.cn/upload/pic/31927.png)

.

那怎么求一段区间的最大线段数呢？

第一想法是前缀和？看起来很OK？

nope

因为**不同区间中，里面的的初始线段会不同**，以下这个图可以简单说明这种情况
![QWQ](https://cdn.luogu.com.cn/upload/pic/31928.png)

但是，我们可以发现一个很重要的特点：

**每条线段的下一条可行线段是固定的
**

有了这个特点，**我们就可以对路径做倍增**，就可以在log的时间求出某一个区间的线段数。

 .

至于求每一个区间的第一条线段，我们可以用set+lowbound的方法找。

 .

这样子，你就可以嘴巴AC这道题啦

~~实际上你有大概率会花费大量的时间来调这道毒瘤题~~



------------
## Code

~~我大量调用了STL函数，导致常数爆大，需要O2才能过，否则会T一个点~~
```cpp
// luogu-judger-enable-o2
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<set>
#include<stack>
#include<cstring>
#include<vector>
using namespace std;
long long read()
{
    long long x=0,f=1; char c=getchar();
    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
    while(isdigit(c)){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int N=200000+100;
struct line
{
    int l,r,no;
    friend bool operator < (line A,line B)
    {
        return A.l<B.l;
    }
}l[N];
bool cmp(line A,line B)
{
    if(A.l==B.l)
    {
        if(A.r!=B.r)
            return A.r>B.r;
        else
            return A.no>B.no;
    }
    return A.l<B.l;
}
bool cmp2(line A,line B)
{
    return A.no<B.no;
}
int n,ans,root,fa[N][20+2];
bool use[N],vis[N];
stack <int> ms;
set <line> mset;
set <line> used;
vector <int> e[N];
void dfs(int now,int FA)
{
    vis[now]=true;
    fa[now][0]=FA;
    for(int i=1;i<=20;i++)
        fa[now][i]=fa[fa[now][i-1]][i-1];
    for(int i=0;i<int(e[now].size());i++)
        if(vis[e[now][i]]==false)
            dfs(e[now][i],now);
}
int POW[21];
int Count(int L,int R)
{
    line temp; temp.l=L;
    set<line>:: iterator t=mset.lower_bound(temp);
    if((*t).r > R) return 0;
    int now=(*t).no,ans=1;
    for(int i=20;i>=0;i--)
        if(l[fa[now][i]].r<=R and fa[now][i]!=0)
            now=fa[now][i],ans+=POW[i];
    return ans;
}
int main()
{
    //freopen("center.in","r",stdin);
    //freopen("center.out","w",stdout);
    
    n=read();
    for(int i=1;i<=n;i++)
        l[i].l=read(),l[i].r=read(),l[i].no=i;
    
    sort(l+1,l+1+n,cmp);
    memset(use,1,sizeof use);
    for(int i=1;i<=n;i++)
    {
        while(ms.empty()==false and l[ms.top()].r>=l[i].r)
        {
            use[ms.top()]=false;
            ms.pop();
        }
        ms.push(i);
    }
    int to=-1;
    for(int i=1;i<=n;i++)
        if(use[i]==true and l[i].l>to)
        {
            ans++;
            to=l[i].r;
        }
    for(int i=1;i<=n;i++) e[i].reserve(4);
    for(int i=1;i<=n;i++)
        if(use[i]==true)
        {
            //cerr<<l[i].no<<" ";
            mset.insert(l[i]);
            bool OK=false;
            for(int j=i+1;j<=n;j++)
                if(use[j]==true and l[j].l>l[i].r)
                {
                    e[l[j].no].push_back(l[i].no);
                    OK=true;
                    break;
                }
            if(OK==false)
                e[0].push_back(l[i].no);
        }
    printf("%d\n",ans);    
    
    dfs(0,0);
    sort(l+1,l+1+n,cmp2);
    for(int i=0;i<=20;i++)
        POW[i]=1<<i;
    l[0].r=0x3f3f3f3f;
    line tt;
    tt.l=-1,tt.r=-1,tt.no=0; mset.insert(tt),used.insert(tt);
    tt.l=0x3f3f3f3f,tt.r=0x3f3f3f3f;mset.insert(tt),used.insert(tt);
    for(int i=1;i<=n;i++)
    {
        int L,R;
        set<line>:: iterator t=used.lower_bound(l[i]);
        if((*t).l<=l[i].r) continue;
        R=(*t).l-1;
        t--;
        if((*t).r>=l[i].l) continue;
        L=(*t).r+1;
        if(Count(L,l[i].l-1)+Count(l[i].r+1,R)==Count(L,R)-1)
        {
            printf("%d ",i);
            used.insert(l[i]);
        }
    }
    return 0;
}
```



---

## 作者：kczno1 (赞：7)

首先将线段按字典序排序，

如果能保证最优就加入。

题目变成，加入一条线段，查询前驱后继，询问一个区间能容纳的最大线段。

第一问可以用线段树，第二问可以倍增出每个点往前^i个线段到达的左端点。





    
```cpp
#include<bits/stdc++.h>
using std::sort;
#define N 400100
int n,l[N],r[N];
int t,d,a[N*6]; 
int *q[N<<1],top;
void chmax(int &x,int y)
{
    if(x<y)x=y;
}
bool xiao(int *x,int *y)
{
    return *x<*y;
}
int deep,right[N][20];
int get_l(int r,int l)
{
    int ans=0;
    for(int j=deep;j>=0;--j)
    if(right[r][j]>l) 
    {
        r=right[r][j]-1;
        ans+=1<<j;
    }
    return ans;
}
#define cl (i<<1)
#define cr (cl+1)
int qiu_l(int i)
{
    if(a[i+=d])return i-d;
    for(;i>1;i>>=1)
    if((i&1)&&a[i^1])
    {
        for(i=i^1;i<=d;)
        if(a[cr])i=cr;
        else i=cl;
        return i-d;
    }
    return 0;
}
int qiu_r(int i)
{
    if(a[i+=d])return i-d;
    for(;i>1;i>>=1)
    if(!(i&1)&&a[i^1])
    {
        for(i=i^1;i<=d;)
        if(a[cl])i=cl;
        else i=cr;
        return i-d;
    }
    return t+1;
}
void add(int i,int x)
{
  a[i+=d]=x;
  while(i>>=1)a[i]=a[cl]+a[cr]; 
} 
bool ok(int x)
{
    int le,ri;
    if((ri=qiu_r(l[x]))<=r[x]||a[d+ri]==2)return 0;
    le=qiu_l(l[x]);
    int now=get_l(ri-1,le);
    if(get_l(l[x]-1,le)+get_l(ri-1,r[x])+1<now)return 0;
    add(r[x],2);
    add(l[x],1);
    return 1;
}
int main()
{
    freopen("1.in","r",stdin);freopen("1.out","w",stdout);
    int i,j;scanf("%d",&n);
    for(i=1;i<=n;++i)
    {scanf("%d%d",l+i,r+i);
     q[++top]=l+i;q[++top]=r+i; 
    }
    sort(q+1,q+top+1,xiao);
    int now=*q[1];t=1;*q[1]=1;
    for(i=2;i<=top;++i)
    {
        if(now<*q[i]){++t;now=*q[i];}
        *q[i]=t;
    }
    for(d=1;d<=t;d<<=1);d-=1;
    for(i=1;i<=n;++i) chmax(right[r[i]][0],l[i]);
    for(i=2;i<=t;++i) chmax(right[i][0],right[i-1][0]);
    for(j=1;right[t][j-1];++j) 
    for(i=t;right[i][j-1];--i) right[i][j]=right[right[i][j-1]-1][j-1];
    deep=j-2;
    now=get_l(t,0);
    printf("%d\n",now);
    i=1;
    while(now--)
    {
        while(!ok(i))++i;
        printf("%d ",i);++i;
    }
}
```

---

## 作者：喵仔牛奶 (赞：5)

这题是萌新今天的作业，本萌新来水一篇题解加深影响qwq

首先贪心思路应该好想吧，由于是字典序最小，所以按顺序强制使用每个公司，如果使用后还可以达到最优解，就使用。因为如果选了这个不影响数量，那么选了这个字典序肯定比不选小。如果您还是听不懂的话……建议先自学字典序。

关键是如何快速地得出选了这个公司之后最多能选的公司：

（下列内容将公司抽象成了线段，请读者自行思考）

首先，思考一下，发现这是个贪心题。让选取的右端点尽量小一定是最优的。那么您可以按左区间排序，每次选右端点最小的就行了。然鹅，它是 $\mathcal{O}(n)$ 的，您需要思考优化。

事实上，这种贪心策略对于不同的区间都是固定的，您可以用 ST 表（倍增）优化它。

设 $f_{i,j}$ 为第 $i$ 个点开始选 $2^j$ 条线段后最小的右端点。那么有转移方程

$$f[i][j]=\min\{f[i][j],f[f[i][j-1]][j-1]\}$$

然鹅，这个转移方程没有初值，所以需要赋一个初值。对于每条线段，它的左端点都直接可以通过它到右端点。

$$\forall_{i=1}^{n}f[L_i][0]=\min\{f[L_i][0],R_i\}$$

(下标太糊了，见谅一下哈qwq)

这样就可以通过倍增 $\mathcal{O}(\log n)$ 求出一个区间最多可以放几条线段了。

```
int query(int l, int r) {
	int res = 0;
	Down(i, 20, 0) 
            if (f[l][i] <= r + 1) 
                res += 1 << i, l = f[l][i]; 
	return res;
}
```

但是，就这样，我们还是无法判断一条线段的区间有没有被其他线段覆盖。使用线段树/树状数组区间赋值+区间修改？但是这样显然很麻烦，有没有更好的方法呢？

有。因为珂朵莉非常可爱，所以我们可以使用珂朵莉树，将区间转换为值，保存 $l,r$ 放进 ```set``` 里。修改时找到块删除+插入新的散块就行了。

$l,r\leq10^9$ 记得跑离散化。

细节还挺多，注意别写挂了。

```cpp
#include <bits/stdc++.h>
#define Up(i, l, r) for (int i = (l); i <= (r); i ++)
#define Down(i, l, r) for (int i = (l); i >= (r); i --)
using namespace std;
const int N = 2e6 + 5;
struct Seq { // 一条线段
	int l, r;
	bool operator < (const Seq& x) const { return r < x.l; }
	Seq(int _l, int _r) : l(_l), r(_r) {}
};
int f[N][25], L[N], R[N], t[N], cnt, n, k, sum;
set<Seq> s; // 珂朵莉树
int query(int l, int r) {
	int res = 0;
	Down(i, 20, 0) if (f[l][i] <= r + 1) res += 1 << i, l = f[l][i]; 
	return res;
} // 返回[l,r]最多能够有几条线段
int main() {
	cin >> n;
	Up(i, 1, n) cin >> L[i] >> R[i], t[++ cnt] = L[i], t[++ cnt] = ++ R[i];
	sort(t + 1, t + 1 + cnt), cnt = unique(t + 1, t + 1 + cnt) - t;
	Up(i, 1, n) L[i] = lower_bound(t + 1, t + 1 + cnt, L[i]) - t, R[i] = lower_bound(t + 1, t + 1 + cnt, R[i]) - t; // 离散化
	Up(i, 1, cnt + 5) Up(j, 0, 20) f[i][j] = cnt + 5; // 赋值成INT_MAX会RE，赋值成比cnt大的值就可以了
	Up(i, 1, n) f[L[i]][0] = min(f[L[i]][0], R[i]);
	Down(i, cnt, 1) {
		f[i][0] = min(f[i][0], f[i + 1][0]);
		Up(j, 1, 20) f[i][j] = min(f[i + 1][j], f[f[i][j - 1]][j - 1]);
	}
	s.insert(Seq(1, cnt)), k = sum = query(1, cnt), cout << k << '\n'; // 最多接的线段就是query(1, cnt)
	Up(i, 1, n) {
		if (s.find(Seq(L[i], R[i] - 1)) == s.end()) continue; // 如果没有该线段
		Seq now = *s.find(Seq(L[i], R[i] - 1)); // 找到该线段
		if (L[i] >= now.l && R[i] - 1 <= now.r) { // 如果可以完美覆盖
			int ns = query(now.l, L[i] - 1) + query(R[i], now.r) - query(now.l, now.r); // 如果使用了这条线段最优解不变
			if (sum + ns >= k - 1) {
				cout << i << ' ', s.erase(now), k --, sum += ns;
				if (now.l < L[i]) s.insert(Seq(now.l, L[i] - 1));
				if (now.r >= R[i]) s.insert(Seq(R[i], now.r)); // 珂朵莉树的裂块
			}
		}
		if (!k) break; // k没了，直接结束
	}
	return 0;
}
```


---

## 作者：pidan (赞：4)

### [$题目传送门$](https://www.luogu.com.cn/problem/P3626)

提供一种 $O(n\log^2(n))$ 的解法。

第一问是经典的最大不交线段集问题，可以用 $O(n\log(n))$ 的贪心做法和 $O(n^2)$ 的 dp 做法解决，但显然贪心处理字典序非常棘手，这里考虑 $O(n^2)$ 的 dp。

对于一个会议，结束时间越早越好，因此将所有会议离散化后按照结束时间升序排序，这时原来 $O(n)$ 枚举转移可以用一棵支持单点修改，区间查询的权值线段树维护结束时间为 x 的最小的 dp 值做到 $O(\log(n))$ ，但结束时间可能会相同，因此在线段树上还要维护最小的字典序。一个显然的方法是以  dp 值为第一关键字，以会议编号为第二关键字取最优值，代码如下：

```cpp
int n,tmp[N<<1],cnt;
bool operator<(const pair<int,int>&x,const pair<int,int>&y){
    return(x.first==y.first)?x.second<y.second:x.first>y.first;
}
namespace SGT{
    pair<int,int>Max[N<<2];
    void pushup(int k){
    	Max[k]=(Max[k<<1]<Max[k<<1|1])?Max[k<<1]:Max[k<<1|1];
    }
    void modify(int k,int l,int r,int x,pair<int,int>pr){
        if(l==r){
            if(pr<Max[k])Max[k]=pr;
            return;
        }
        int mid=(l+r)>>1;
        if(x<=mid)modify(k<<1,l,mid,x,pr);
        else modify(k<<1|1,mid+1,r,x,pr);
        pushup(k);
    }
    pair<int,int>query(int k,int l,int r,int x,int y){
		if(r<x||l>y)return make_pair(0,0);
    	if(l>=x&&r<=y)return Max[k];
        int mid=(l+r)>>1;
        if(y<=mid)return query(k<<1,l,mid,x,y);
        if(mid<x)return query(k<<1|1,mid+1,r,x,y);
        if(query(k<<1,l,mid,x,y)<query(k<<1|1,mid+1,r,x,y))return query(k<<1,l,mid,x,y);
        return query(k<<1|1,mid+1,r,x,y);
    }
}
using namespace SGT;
namespace Solve{
    struct Node{int l,r,id;}meet[N];
    int dp[N],pre[N],ans[N];
    void print(){
        int id=0,tot=0;
        for(int i=1;i<=n;i++)
            if(make_pair(dp[i],i)<make_pair(dp[id],id))id=i;
		printf("%d\n",dp[id]);
		while(id)ans[++tot]=id,id=pre[id];
        sort(ans+1,ans+tot+1);
        for(int i=1;i<=tot;i++)printf("%d ",ans[i]);
    }
    void DP(){
        sort(meet+1,meet+n+1,[&](Node&x,Node&y){return x.r<y.r;});
        for(int i=1;i<=n;i++){
            pair<int,int>u=query(1,1,cnt,1,meet[i].l-1);
            dp[meet[i].id]=dp[u.second]+1,pre[meet[i].id]=u.second;
            modify(1,1,cnt,meet[i].r,make_pair(dp[meet[i].id],meet[i].id));
        }
        print();
    }
}
using namespace Solve;
int main(){
    n=read();
    for(int i=1;i<=n;i++)meet[i].l=read(),meet[i].r=read(),meet[i].id=i;
    for(int i=1;i<=n;i++){
        tmp[++cnt]=meet[i].l;
        tmp[++cnt]=meet[i].r;
    }
    sort(tmp+1,tmp+cnt+1);
    cnt=unique(tmp+1,tmp+cnt+1)-tmp-1;
    for(int i=1;i<=n;i++){
        meet[i].l=lower_bound(tmp+1,tmp+cnt+1,meet[i].l)-tmp;
        meet[i].r=lower_bound(tmp+1,tmp+cnt+1,meet[i].r)-tmp;
    }
    DP();
    return 0;
}
```

但这样的做法有问题，考虑下面这组数据：

输入：
```cpp
6
1 3
5 7
4 5
6 10
10 12
13 15
```
输出：
```cpp
4
1 2 5 6
```

代码输出
```cpp
4
1 3 4 6
```
究其原因在于当前策略在之前的字典序中不一定最优，那么这样的做法是错的吗？注意到 dp 值与其转移构成一棵森林，而相同 dp 值比较字典序时在所在树中的深度一定相等，想到树上倍增，具体地，每次 $dp_u$ 转移后记 $fa_{u,0}=pre_u$ ， $Min_{u,0}=u$ ，更新 u 的倍增数组，线段树内比较时在树上跳，跳到路径最小值相等时停止，树上到根路径上的最小值为字典序。

代码如下：
```cpp
#include<bits/stdc++.h>
#define int long long
#define INF 0x3f3f3f3f
#define N 400005
#define ls k<<1
#define rs k<<1|1
#define mid ((l+r)>>1)
#define mp make_pair
#define pb push_back
#define fi first
#define se second
#define pii pair<int,int>
#define il inline
#define file(x) freopen(x".in","r",stdin);freopen(x".out","w",stdout);
using namespace std;
il int read(){
    int w=0,h=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')h=-h;ch=getchar();}
    while(ch>='0'&&ch<='9'){w=w*10+ch-'0';ch=getchar();}
    return w*h;
}
struct Node{
    int l,r,id;
    bool operator<(const Node&p)const{
        return r<p.r;
    }
}mt[N];
int n,tot,tmp[N];
int dp[N],from[N],ans[N];
namespace Jump{
    int fa[N][25],Min[N][25];
    void build(int u){
        for(int i=1;i<=21;i++){
            fa[u][i]=fa[fa[u][i-1]][i-1];
            Min[u][i]=min(Min[u][i-1],Min[fa[u][i-1]][i-1]);
        }
    }
    bool check(int u,int v){
        int minx=INF,miny=INF;
        for(int i=21;i>=0;i--)
            if(Min[u][i]!=Min[v][i]){
                minx=min(minx,Min[u][i]);
                miny=min(miny,Min[v][i]);
                u=fa[u][i];v=fa[v][i];
            }
        return minx>miny;
    }
}
bool operator<(const pii&x,const pii&y){
    return(x.fi==y.fi)?Jump::check(x.se,y.se):x.fi<y.fi;
}
namespace SGT{
    pii Max[N<<2];
    pii pushup(pii l,pii r){return(l<r)?r:l;}
    void modify(int k,int l,int r,int x,pii pa){
        if(l==r){
            if(Max[k]<pa)Max[k]=pa;
            return;
        }
        if(x<=mid)modify(ls,l,mid,x,pa);
        if(mid<x)modify(rs,mid+1,r,x,pa);
        Max[k]=pushup(Max[ls],Max[rs]);
    }
    pii query(int k,int l,int r,int x,int y){
        if(l>y||r<x)return mp(0,0);
        if(l>=x&&r<=y)return Max[k];
        if(y<=mid)return query(ls,l,mid,x,y);
        if(mid<x)return query(rs,mid+1,r,x,y);
        return pushup(query(ls,l,mid,x,y),query(rs,mid+1,r,x,y));
    }
}
void out(int u){
    if(u==0)return;
    out(from[u]);
    ans[++tot]=u;
}
void print(){
    int id=0;
    for(int i=1;i<=n;i++)
        if(mp(dp[id],id)<mp(dp[i],i))id=i;
    printf("%lld\n",dp[id]);
    tot=0;
    out(id);
    sort(ans+1,ans+tot+1);
    for(int i=1;i<=tot;i++)cout<<ans[i]<<' ';
}
signed main(){
    n=read();
    for(int i=1;i<=n;i++){
        mt[i].l=read();mt[i].r=read();mt[i].id=i;
        tmp[++tot]=mt[i].l;
        tmp[++tot]=mt[i].r;
    }
    sort(tmp+1,tmp+tot+1);
    tot=unique(tmp+1,tmp+tot+1)-tmp-1;
    for(int i=1;i<=n;i++){
        mt[i].l=lower_bound(tmp+1,tmp+tot+1,mt[i].l)-tmp;   
        mt[i].r=lower_bound(tmp+1,tmp+tot+1,mt[i].r)-tmp;
    }
    sort(mt+1,mt+n+1);
    for(int i=1;i<=n;i++){
        pii u=SGT::query(1,1,tot,1,mt[i].l-1);
        int id=mt[i].id;
        if(u.se==0)dp[id]=1,from[id]=0;
        else dp[id]=dp[u.se]+1,from[id]=u.se;
//      cout<<id<<' '<<dp[id]<<' '<<from[id]<<endl;
        Jump::fa[id][0]=(u.se)?u.se:id;
        Jump::Min[id][0]=id;
        Jump::build(id);
        SGT::modify(1,1,tot,mt[i].r,mp(dp[id],id));
    }
    print();
    return 0;
}
```

---

## 作者：PhantasmDragon (赞：4)

博客链接：http://phantasmdragon.leanote.com/post/20190724s1



------------

第一问的做法非常多，~~如果只有第一问我就会了~~

考虑如何选出排序后字典序最小的方案。

一个明显的贪心就是每次选编号最小的线段加入，如果加入后答案不会变劣，那么就把它选上。

问题就转化为求加入一条线段之后的最大答案。
找到这个线段的前驱点 $L$, 后继点 $R$ ,注意如果当前讨论的线段与已加入的任何一条线段相交，要舍弃这条线段。

现在考虑如何计算判断答案是否变劣. 我们设 $Ans(x,y)$ 为区间 $[x,y]$ 中能塞下的最大线段数，那么如果满足 $Ans(L+1,l-1)+Ans(r+1,R-1)+1=Ans(L+1,R-1)$ ,这条线段就是合法的,可以选用。

![oops](https://leanote.com/api/file/getImage?fileId=5d37cbc7ab64414d87005612)

问题进一步转化为了如何快速求 $Ans(x,y)$. 

对于一个线段 $[l_i,r_i]$, 我们处理一个倍增表 $jmp[i][j]$ 表示从 $[l_i,r_i]$ 这条线段向**左**跳 $2^j$ 个不相交的线段到达的线段 $[l_p,r_p]$的编号 $p$, 并且要求 $l_p$ 尽量靠右. 

有了这个倍增表，给出一个线段 $[l_i,r_i]$ 和一个左端点 $L$, 我们就可以求出 $[L,l_i]$ 这个区间最多能放下多少条线段了。

维护所有放入的线段可以用 STL::set,需要支持查找前驱后继和插入操作.

小trick#1:对于每个set里的坐标，把它和其对应线段编号放在一个结构体里，方便直接使用.

小trick#2:一开始插入两个边界点，减少边界判断。


------------
----------
贴上代码：
```
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<set>
#define maxn 2000005
using namespace std;
struct node{int l,r,id;}d[maxn];
struct snode{int p,id;};
bool operator <(snode a,snode b){return a.p<b.p;}
set<snode> s;
int cmp(node a,node b){return a.r<b.r;}
int cmp1(node a,node b){return a.id<b.id;}
int Ha[maxn],n,tot;
int jmp[maxn][22],pre[maxn],id[maxn];
int getans(int l,int from)
{
    int ret=0;
    for(int i=20;i>=0;i--)
        if(jmp[from][i]&&d[jmp[from][i]].l>l) ret+=(1<<i),from=jmp[from][i];
    return ret;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d%d",&d[i].l,&d[i].r),Ha[++tot]=d[i].l,Ha[++tot]=d[i].r,d[i].id=i;
    sort(Ha+1,Ha+tot+1);
    tot=unique(Ha+1,Ha+tot+1)-Ha-1;
    for(int i=1;i<=n;i++)
    {
        d[i].l=lower_bound(Ha+1,Ha+tot+1,d[i].l)-Ha;
        d[i].r=lower_bound(Ha+1,Ha+tot+1,d[i].r)-Ha;
    }
    sort(d+1,d+n+1,cmp);
    for(int i=1;i<=n;i++)
    {
        if(pre[d[i].r]<d[i].l)
            pre[d[i].r]=d[i].l,id[d[i].r]=d[i].id;
    }
    for(int i=1;i<=tot;i++)
    {
        if(pre[i]<pre[i-1])
            pre[i]=pre[i-1],id[i]=id[i-1];
    }
    for(int i=1;i<=n;i++)
    {
        jmp[d[i].id][0]=id[d[i].l-1];
        for(int j=1;j<=20;j++)
            jmp[d[i].id][j]=jmp[jmp[d[i].id][j-1]][j-1];
    }
    int tid=0,ans=0;
    for(int i=1;i<=n;i++)
        if(!tid||d[tid].l<d[i].l)tid=i;
    tid=d[tid].id;
    jmp[n+1][0]=tid;
    for(int j=1;j<=20;j++)
        jmp[n+1][j]=jmp[jmp[n+1][j-1]][j-1];
    for(int i=20;i>=0;i--)
        if(jmp[tid][i]) ans+=(1<<i),tid=jmp[tid][i];
    printf("%d\n",ans+1);
    sort(d+1,d+n+1,cmp1);
    s.insert((snode){1e9,n+1});
    s.insert((snode){0,0});
    set<snode>::iterator it;
    for(int i=1;i<=n;i++)
    {
        if(s.lower_bound((snode){d[i].r,0})!=s.lower_bound((snode){d[i].l,0})) continue;
        it=s.lower_bound((snode){d[i].r,0});
        snode t1=*it,t2=*(--it);
        if(getans(t2.p,i)+getans(d[i].r,t1.id)+1!=getans(t2.p,t1.id)) continue;
        printf("%d ",i);
        s.insert((snode){d[i].l,i});
        s.insert((snode){d[i].r,i});
    }
    return 0;
}
```



---

## 作者：Paradise_NoiSe (赞：2)

### P3626

树上倍增做法。

对于第一个问题可 dp / 贪心解决。对于 dp，将线段按右端点排序后在右端点处统计，需要做带修前缀 $\max$，树状数组维护。对于贪心，以右端点为第一关键字，左端点为第二关键字排序，从第一条线段开始，能选就选。

第二个问题要求**排序后**字典序最小， 此时 dp 转移要记录一个二元组 $(id, S)$ 表示当前点编号和当前字符串。由于每次都是从前向后转移，最后会形成一个森林结构，倍增可支持动态添加叶子。但此时直接倍增 Hash 就寄了，因为题面要求的是**排序后**字典序最小。实际处理则更加简单，因为字符集即节点编号是不重的，对于两个字符串长度一样的节点，比较其从 lca 分出的两条链的链上编号最小值即可。（Hash 也是可以做的，可持久化线段树 / 平衡树支持有序插入，但空间是 $O(n \log n)$ 的。）

最后，直接套个线段树 / 树状数组维护时间复杂度会达到 $O(n \log^2 n)$，因为每次比较两个二元组是 $O(\log n)$ 的。

（写完才想到右端点是单调的，可以记一下前缀最小状态，即可做到  $O(n \log n)$）。

下面给出 $O(n \log^2 n)$ 的代码。

```cpp
#include <bits/stdc++.h>
const int N = 2e5 + 10;
struct Node { int w, id; };
struct _Seg {
    int id, L, R; 
    bool operator<(const _Seg &rhs) const {
        return R < rhs.R;
    }
} seg[N];
int n, b[N * 2];
int ans[N];
Node f[N];

int LG (int x) { return x ? std::__lg(x) : -1; }

int fa[20][N], g[20][N], dep[N];
void addLeaf (int u, int pre, int w) {
    fa[0][u] = pre, g[0][u] = u;
    dep[u] = dep[pre] + 1;
    for (int i = 1; i <= LG(dep[u]); ++i) {
        fa[i][u] = fa[i - 1][fa[i - 1][u]];
        g[i][u] = std::min(g[i - 1][u], g[i - 1][fa[i - 1][u]]);
    }
}
int cmpPath (int u, int v) {
    int x, y;
    x = y = n + 1;
    for (int i = LG(dep[u]); ~i; --i) {
        if (fa[i][u] != fa[i][v]) {
            x = std::min(x, g[i][u]);
            y = std::min(y, g[i][v]);
            u = fa[i][u], v = fa[i][v];
        }
    }
    x = std::min(x, g[0][u]), y = std::min(y, g[0][v]);
    return x < y;
}

int Cmp (Node x, Node y) { return x.w == y.w ? cmpPath(x.id, y.id) : x.w > y.w; }

Node t[N * 2];
Node Qry (int x) {
    Node res{0, 0};
    while (x) { if (Cmp(t[x], res)) res = t[x]; x -= (x & -x); }
    return res;
}
void Upd (int x, Node v) {
    while (x <= *b) { if (Cmp(v, t[x])) t[x] = v; x += (x & -x); }
}

int main () {
    std::cin.tie(0)->sync_with_stdio(0);
    std::cin >> n;
    
    for (int i = 1; i <= n; ++i) {
        std::cin >> seg[i].L >> seg[i].R;
        b[++*b] = seg[i].L;
        b[++*b] = seg[i].R;
        seg[i].id = i;
    }
    
    std::sort(b + 1, b + *b + 1);
    *b = std::unique(b + 1, b + *b + 1) - b - 1;
    for (int i = 1; i <= n; ++i) {
        seg[i].L = std::lower_bound(b + 1, b + *b + 1, seg[i].L) - b;
        seg[i].R = std::lower_bound(b + 1, b + *b + 1, seg[i].R) - b;
    }
    
    std::sort(seg + 1, seg + n + 1);
    int mx = 0;
    for (int i = 1; i <= n; ++i) {
        int id = seg[i].id;
        Node t = Qry(seg[i].L - 1);
        mx = std::max(mx, t.w + 1);
        addLeaf(id, t.id > 0 ? t.id : id, t.w + 1);
        Upd(seg[i].R, f[id] = {t.w + 1, id});
    }

    printf("%d\n", mx);
    int now = 0;
    for (int i = 1; i <= n; ++i)
        if (Cmp(f[i], f[now])) now = i;
    int tot = 0;
    ans[++tot] = now;
    while (fa[0][now] != now) now = fa[0][now], ans[++tot] = now;
    std::sort(ans + 1, ans + tot + 1);
    for (int i = 1; i <= tot; ++i)
        printf("%d ", ans[i]);
    puts("");
}
```

---

## 作者：hegm (赞：2)

### [[APIO2009] 会议中心](https://www.luogu.com.cn/problem/P3626)

考虑一种暴力，对于 $i$ 暴力的判断在之前的限制中，选择 $i$ 所能得到的最多区间数，判断和最大值的关系，如果相等，将限制加入，否则跳过。

考虑新加入的区间在之前的抉择区间中左侧是 $l$ 区间，右侧是 $r$ 区间。

那么 $l\sim r$ 的都没有定好，只不过有一个最大值，那么将最大值从中撤销，然后将 $i$ 加入，看 $l\sim i,i\sim r$ 区间的最大区间数是不是和之前一样。

这个过程可以倍增的维护，对于区间 $i$，向后的最优抉择是定死的。因此可以通过倍增快速求出。

### CODE
```cpp
#include<bits/stdc++.h>
#define N 200005
#define ls (now<<1)
#define rs (now<<1|1)
#define M 1000000001
using namespace std;
int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
int n,nx[N][22],ans,num,lm[N];
struct lim
{
	int l,r,id,w;
	bool operator <(lim b)const
	{
		return l<b.l;
	}
}k[N];
bool cmp1(lim a,lim b)
{
	if(a.r==b.r)return a.l>b.l;
	return a.r<b.r;
}
bool cmp3(lim a,lim b)
{
	return a.id<b.id;
}
set<lim> s;
signed main()
{
	n=read();lm[0]=1;
	for(int i=1;i<=21;i++)lm[i]=lm[i-1]*2;
	for(int i=1;i<=n;i++)
	{
		k[i].l=read();
		k[i].r=read();
		k[i].id=i;
	}
	k[0].l=0;k[0].r=0;
	k[n+1].l=M;k[n+1].r=M;k[n+1].id=n+1;
	sort(k+1,k+1+n,cmp1);
	for(int i=0,x=0;i<=n;i++)
	{
		while(k[x].l<=k[i].r)x++;
		nx[k[i].id][0]=k[x].id;
	}
	for(int i=1;i<=21;i++)
	{
		nx[n+1][i-1]=n+1;
		for(int j=0;j<=n;j++)
		nx[j][i]=nx[nx[j][i-1]][i-1];
	}
	int x=k[1].id;
	sort(k+1,k+1+n,cmp3);
	while(x!=n+1)
	{
		ans++;
		x=nx[x][0];
	}
	cout<<ans<<"\n";
	k[0].w=ans;k[n+1].w=0;
	s.insert(k[0]);s.insert(k[n+1]);
	for(int i=1;i<=n;i++)
	{
		auto r=s.upper_bound(k[i]);r--;
		auto l=r;r++;
		if(l->r>=k[i].l||r->l<=k[i].r)continue;
		int x=i,wl=0,wr=0;
		for(int j=21;j>=0;j--)
		{
			if(k[nx[x][j]].r<r->l)
			x=nx[x][j],wr+=lm[j];
		}
		x=l->id;
		for(int j=21;j>=0;j--)
		{
			if(k[nx[x][j]].r<k[i].l)
			x=nx[x][j],wl+=lm[j];
		}
		if(wl+wr+1==l->w)
		{
			lim p=*l;
			p.w=wl;
			s.erase(l);
			s.insert(p);
			p=k[i];p.w=wr;
			s.insert(p);
			cout<<i<<" ";
		}
	}
	return 0;
}
```

---

## 作者：Dovish (赞：1)

这里给出一种奇妙的 DP 做法。

首先，第一问是容易解决的，这个如当是求若干线段的最大不相交覆盖。

我们不妨将线段按右端点升序排序，并设 $f_i$ 表示前 i 天的最大答案，l 和 r 是当前线段的左右端点，则有转移：

$$
f_r=\max(f_{r-1},f_{l-1}+1)
$$

然而求字典序就有点麻烦了。

我们无法通过比较上一个选取的点来判断两个状态的字典序大小。也就是说，我们将两个状态的字典序看作两个字符串，求二者的最长公共前缀。（这样比较下一位就可以比较出字典序了。）

如何对于每个状态存下来这个字符串呢？

注意到状态在转移的时候，这个字符串的变化是非常小的，不妨就用主席树存下来。

然后找 LCP 就直接二分加哈希解决。

时空复杂度都是 $O(n\log n)$。
## code

```cpp
#include<bits/stdc++.h>
#define ll long long
#define rep(i,a,b) for(register int i=a;i<=b;++i)
#define low(i,a,b) for(register int i=a;i>=b;--i)
#define edge(i,u) for(int i=head[u];i;i=e[i].next)
#define lc(u) tre[u].ls
#define rc(u) tre[u].rs
#define pii pair<int,int>
#define pdd pair<double,double>
#define mp(a,b) make_pair(a,b)
using namespace std;
const int N=2e5+10,inf=1e9;
const int mod1=998244353,mod2=1004535809,base1=2333,base2=19260817;
const int base=550;
int bs1[N],bs2[N];
struct hanser
{
	int len,val1,val2;
	hanser operator+(const hanser&b)
	{
		hanser c;
		c.len=len+b.len;
		c.val1=((ll)val1*bs1[b.len]%mod1+b.val1)%mod1;
		c.val2=((ll)val2*bs2[b.len]%mod2+b.val2)%mod2;
		return c;
	}
	hanser operator-(const hanser&b)
	{
		hanser c;
		c.len=len-b.len;
		c.val1=(val1-(ll)b.val1*bs1[c.len]%mod1+mod1)%mod1;
		c.val2=(val2-(ll)b.val2*bs2[c.len]%mod2+mod2)%mod2;
		return c;
	}
	bool operator<(const hanser&b)const
	{
		if(len!=b.len)return len<b.len;
		if(val1!=b.val1)return val1<b.val1;
		return val2<b.val2;
	}
	bool operator==(const hanser&b)const
	{
		return len==b.len&&val1==b.val1&&val2==b.val2;
	}
};
struct sx
{
	int l,r;
	bool operator<(const sx&b)const
	{
		return r<b.r;
	}
}ls[N];
int f[N<<1],root[N<<1],n;
int lsh[N<<1],res_lsh;
int from[N<<1];
struct SGT
{
	int ls,rs;
	hanser hs;
}tre[N*24];
int res;
void pushup(int u)
{
	tre[u].hs=tre[lc(u)].hs+tre[rc(u)].hs;
}
void build(int &u,int l,int r)
{
	u=++res;
	if(l==r)
	{
		tre[u].hs={1,0,0};
		return;
	}
	int mid=(l+r)/2;
	build(lc(u),l,mid);
	build(rc(u),mid+1,r);
	pushup(u);
}
void add(int &u,int h,int l,int r,int x)
{
	u=++res;
	tre[u]=tre[h];
	if(l==r)
	{
		tre[u].hs={1,1,1};
		return;
	}
	int mid=(l+r)/2;
	if(x<=mid)add(lc(u),lc(h),l,mid,x);
	else add(rc(u),rc(h),mid+1,r,x);
	pushup(u);
}
bool check(int u,int v,int l,int r)
{
	if(l==r)
	return tre[u].hs.val1>tre[v].hs.val1;
	int mid=(l+r)/2;
	if(tre[lc(u)].hs==tre[lc(v)].hs)
	return check(rc(u),rc(v),mid+1,r);
	else
	return check(lc(u),lc(v),l,mid);
}
void getans(int u,int l,int r)
{
	if(l==r)
	{
		if(tre[u].hs.val1)cout<<l<<" ";
		return;
	}
	int mid=(l+r)/2;
	getans(lc(u),l,mid);
	getans(rc(u),mid+1,r);
}
vector<pii>line[N<<1];
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	bs1[0]=bs2[0]=1;
	rep(i,1,N-1)
	{
		bs1[i]=(ll)bs1[i-1]*base1%mod1;
		bs2[i]=(ll)bs2[i-1]*base2%mod2;
	}
	
	cin>>n;
	rep(i,1,n)
	{
		cin>>ls[i].l>>ls[i].r;
		lsh[++res_lsh]=ls[i].l;
		lsh[++res_lsh]=ls[i].r;
	}
	sort(lsh+1,lsh+res_lsh+1);
	res_lsh=unique(lsh+1,lsh+res_lsh+1)-(lsh+1);
	
	rep(i,1,n)
	{
		int l=lower_bound(lsh+1,lsh+res_lsh+1,ls[i].l)-lsh;
		int r=lower_bound(lsh+1,lsh+res_lsh+1,ls[i].r)-lsh;
		line[r].push_back(mp(l,i));
	}
	build(root[0],1,n);
	int last=0;
	rep(i,1,res_lsh)
	{
		if(line[i].size())
		for(auto u:line[i])
		{
			int pos=u.second;
			int l=u.first;
			
			f[pos]=f[from[l-1]]+1;
			add(root[pos],root[from[l-1]],1,n,pos);
			
			from[i]=pos;
			if(f[last]>f[pos])
			{
				f[pos]=f[last];
				root[pos]=root[last];
				from[i]=last;
			}
			else if(f[last]==f[pos])
			{
				if(check(root[last],root[pos],1,n)||!f[pos])
				{
					root[pos]=root[last]; 
					from[i]=last;
				}
			}
			last=pos;
		}
		else
		from[i]=from[i-1];
	}
	
	cout<<f[from[res_lsh]]<<'\n';
	getans(root[from[res_lsh]],1,n);
	return 0;
}
```

---

## 作者：神迹 (赞：0)

假设get_ans函数可以快速查询区间的最大放的数量，那么如果我想放入一个[l0,r0]的区间，那么需要满足


get_ans(l,r)=get_ans(l,l0-1)+get_ans(r0+1,r)+1


l是离l0最近的上次插入的区间的右端点，r是离r0最近的上次插入的左端点。


开始我还在想怎么维护选择区间之后，这个区间的数量变化情况，事实上我们并不关心怎么变，我们只知道它不会使得数量变化即可。

也就是说，我只要知道我能影响的区间怎么变，外面的区间因为没有修改，所以肯定也不会变化，换而言之当前影响区间不变则整个区间的总数量就不会变。


其实每个线段的下端都是固定的，那么我们就能倍增......


那么我们需要预处理什么呢？首先我们需要在log n的时间内实现快速查询给定范围最大可以选取的区间数量。


那么我们把区间重新排序，并且去掉互相包含的区间中较大的部分（显然可以知道这是可行的），这可以先按左端点排序，再用一个右端点单调递增的栈实现。之后对于每个保留下来的区间i，考虑用f[i][j]表示从第i个区间开始往后连续选取2^j个区间之后落在哪个区间上。


我可以找到[l,r]中的第一个区间，然后倍增的找区间，不断地往后跳并累加答案。通过上述操作可以实现查询操作。


另外，我们选取了一个区间之后可以用一个set维护一下我选取的区间的端点坐标，方便我快速查询最近的坐标，即为lowbound+set寻找每个区间第一个线段

```cpp
#include <set>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <algorithm>

#define vd void
#define il inline

#define re register
#define FOR(i,a,b) for(re int i=(a);i<=(b);++i)
#define ROF(i,a,b) for(re int i=(a);i>=(b);--i)
#define REP(u) for(re int i=head[u];i;i=pan[i].next)

//#define gc getchar()
#define gc pa==pb&&(pb=(pa=buf)+fread(buf,1,1<<17,stdin),pa==pb)?EOF:*pa++

using namespace std;

static char buf[1<<17],*pa(buf),*pb(buf);

typedef long long ll;

const int N(500007),INF(2147483647);

set <int> S;
int n,end,ans,cnt,len;
int l[N],f[N][19],pd[N];

struct Node {
    public:
        int l,r;
}a[N],b[N];

il bool cmp(Node p,Node pp) {
	return p.l==pp.l?p.r>pp.r:p.l<pp.l;
}

il int read() {
    re int s=0,f=1;re char ch(gc);
    while(ch<'0'||ch>'9') ch=='-'?f=-1,ch=gc:ch=gc;
    while(ch>='0'&&ch<='9') s=s*10+ch-48,ch=gc;
    return f*s;
}

// get_ans(l,r)=get_ans(l,l0-1)+get_ans(r0+1,r0)+1

int get_ans(int L,int R) {
    int head(lower_bound(l+1,l+cnt+1,L)-l),pd,ans(1);
    if(L>R||L>end||head>cnt||b[head].r>R) return (0);
    ROF(i,18,0) {
        if(f[head][i]==cnt+1||!f[head][i]) continue;
        pd=b[f[head][i]].r;
        if(pd>R) continue;
        head=f[head][i],ans+=(1<<i);
    } return ans;
}

vd build() {
    FOR(i,1,n) b[i]=a[i];
    sort(b+1,b+n+1,cmp),cnt=0;
    b[++cnt]=b[1];
    FOR(i,2,n) {
        while(b[i].r<b[cnt].r && cnt>0) --cnt;
        b[++cnt]=b[i];
    } len=0;int pass(0);
    FOR(i,1,cnt) l[++len]=b[i].l;
    l[++len]=INF;
    FOR(i,0,18) f[cnt+1][i]=cnt+1;
    FOR(i,1,cnt) pass=upper_bound(l+1,l+len+1,b[i].r)-l,f[i][0]=pass;
    FOR(j,1,18) FOR(i,1,cnt) if(f[i][j-1] && f[f[i][j-1]][j-1]) f[i][j]=f[f[i][j-1]][j-1];
}

vd Main() {
    n=read();
    FOR(i,1,n)
        a[i].l=read(),a[i].r=read(),l[++cnt]=a[i].l,l[++cnt]=a[i].r;
    sort(l+1,l+cnt+1);
    end=len=unique(l+1,l+1+cnt)-l-1;
    FOR(i,1,n)
        a[i].l=lower_bound(l+1,l+len+1,a[i].l)-l,a[i].r=lower_bound(l+1,l+len+1,a[i].r)-l;
    build();int now,nowl,nowr;
    ans=get_ans(1,end),printf("%d\n",ans);
    S.insert(-INF),S.insert(INF);
    FOR(i,1,n) {
        now=*S.lower_bound(a[i].l);
        if(now==INF||!pd[now]) {
            if(now<=a[i].r) continue;
            nowl=*--S.lower_bound(a[i].l),nowl++;
            nowr=*S.lower_bound(a[i].r),nowr--;
            now=get_ans(nowl,a[i].l-1)+get_ans(a[i].r+1,nowr)+1;
            if(now<get_ans(nowl,nowr)) continue;
            S.insert(a[i].l),S.insert(a[i].r);
            if(a[i].l!=a[i].r) pd[a[i].r]=true;
            printf("%d ",i);
        }
    }
}

int main() {
    Main();
    return (0);
}

```




---


# 选举

## 题目描述

Byteland 国的居民最近一直为议会选举投票。现在，当结果公布的时候，党派不得不决定联合组建政府。 

每个党派都会获得议会中的一定席位。联合政府由这些党派中的一部分组成，他们在议会中的席位数之和**严格大于**总席位数的一半。对于联合政府来说，席位越多越好。

一个**过剩**的联合政府是指联合政府中的一个党派被移出后，剩余的联合政府在国会中仍有过半数的席位。

请写一个程序能够找到一个在议会中有着**最大可能席位数**且**不过剩**的联合政府。

## 说明/提示

样例解释：选择第二个政党和第四个。

对于全部数据，$1\le n\le 300$。

## 样例 #1

### 输入

```
4
1 3 2 4```

### 输出

```
7```

# 题解

## 作者：PBCWZCC (赞：12)

~~人生第一道深蓝祭~~

这题是个01背包。

题目说的意思是，联合内阁占有的席位要超过总席位数的一半，但去掉最小的已选入内阁的党，剩下的席位要小于一半。

现将所有的席位数排序，再用背包处理一下，这样在占有席位数恰好超过一半时，最后选入的党席位数最小（这部分详见代码里的注释，~~本蒟蒻语文太差~~）。

下面是源代码：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n;
int p[301];
int mid;
int f[100001];
int maxx;
int summ;
int max_(int a,int b)
{
	return a<b?b:a;
}
int mt[100011];
int main()
{
	scanf("%d",&n);
	for(register int i(1);i<=n;++i)
	{
		scanf("%d",&p[i]);
		summ += p[i];
	}
	mid = summ>>1;
	sort(p+1,p+1+n);//排序，保证最后加进内阁的党的席位数最小
	for(int i(n);i>=1;--i)//先把大的党加进去，越往后越小
	{
		for(int j(summ);j>=0;--j)
		{
			if(j-p[i]>=0)
			{
				f[j] = max_(f[j],f[j-p[i]]+p[i]);
			}
			if(f[j]>mid&&f[j]-p[i]<=mid)//加上较小的党，内阁占有席位恰好超过一半；如果在加上这个党派之前内阁席位小于总数一半，就更新答案
			{
				maxx = max_(maxx,f[j]);//更新答案
			}
		}
	}
	printf("%d",maxx);
	return 0;
}

```

~~话说这题是怎么深蓝的~~

---

## 作者：vectorwyx (赞：6)

通过读题我们可以知道一个内阁是合法的当且仅当组成内阁的党派$c_{1},c_{2},…,c_{k}$满足：
$$
\begin{cases}
S-a_{c_{1}}\le w\\
S-a_{c_{2}}\le w\\
……\\
S-a_{c_{k}}\le w\\
\end{cases}
$$
其中 $S$ 为这个内阁的总席位数，$w$ 为所有党派的总席位数的一半，$c_{i}$ 为组成内阁的第 $i$ 个党派的编号，$a_{i}$ 为编号为 $i$ 的党派拥有的席位数。

把上面这组不等式稍稍变形一下就得到了：
$$
\begin{cases}
S-w\le a_{c_{1}}\\
S-w\le a_{c_{2}}\\
……\\
S-w\le a_{c_{k}}\\
\end{cases}
$$
也就是$S-w\le \min_{i=1}^{k}{a_{c_{i}}}$

因此，**一个内阁是合法的充要条件是 $S-w\le \min_{i=1}^{k}{a_{c_{i}}}\ $** 。换句话说，**影响后效性的有两个变量：内阁的总席位数 $S$ 和内阁中席位最少的党派的席位数 $\min_{i=1}^{k}{a_{c_{i}}}$。**

对于前者，我们把它放在状态定义中，也就是**令 $dp_{i,j}$ 表示前 $i$ 个党派已经考虑完毕能否组建出一个总席位数为 $j$ 的合法内阁**，那么转移方程就是 $dp_{i,j}=dp_{i-1,j}||dp_{i-1,j-a_{i}}$。

对于后者，我们把 $a$ 数组**从大到小排序**，这样的话第 $i$ 个党派始终是前 $i$ 个党派中最小的那一个，可以非常便捷地判断选上这个党派后的内阁是否合法。

总时间复杂度为 $O(n\times Sum)$ （$Sum$ 为这 $n$ 个党派的总席位数），稳过。

代码如下（码字不易，还请点个赞>_<）：
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#define ll long long
#define fo(i,x,y) for(register int i=x;i<=y;++i)
#define go(i,x,y) for(register int i=x;i>=y;--i)
using namespace std;
inline int read(){ int x=0,fh=1; char ch=getchar(); while(!isdigit(ch)){ if(ch=='-') fh=-1; ch=getchar(); } while(isdigit(ch)){ x=(x<<1)+(x<<3)+ch-'0'; ch=getchar(); } return x*fh; }
const int maxn=305,maxm=1e5+5,INF=1e9;
int dp[maxm],n,a[maxn],sum[maxn],ans;//这里使用了滚动数组，节省空间 

bool cmp(int x,int y){return x>y;}

int main(){
	n=read();
	fo(i,1,n) a[i]=read();
	sort(a+1,a+1+n,cmp);//从大到小排序 
	fo(i,1,n) sum[i]=sum[i-1]+a[i];
	//dp[0][0]=-1;
	dp[0]=1;//注意dp[0]要初始化为true 
	fo(i,1,n)
		go(j,sum[i],a[i]){
			//有两种选择：选或不选。由于是滚动数组优化，所以我们只需要判断选这个内阁的情况 
			if(j-sum[n]/2<=a[i]&&dp[j-a[i]]) dp[j]=1;//选上第i个党派后能组成一个合法的内阁 
		}
	go(i,sum[n],1)//找席位数最大的合法内阁 
		if(dp[i]){
			cout<<i;
			break;
		}
	return 0;
}
/*
4
1 3 2 4
-------------------------------------------------
7
*/
```


---

## 作者：MikukuOvO (赞：4)

这里提供一个其他的解法，因为我太菜了。。。

看到题解大多排了个序来保证单调性，其实我们改变状态设计就行。

考虑$f[i]$表示选出的和为$i$的最小值为多少，那么我们只要最后枚举$i$然后判断是否合法就行了

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int N=1e5+5;

int n,sum,ans;
int f[N],c[N];

int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;++i) scanf("%d",&c[i]),sum+=c[i];
    memset(f,-1,sizeof(f));
    f[0]=1e9;
    for(int i=1;i<=n;++i)
    {
        for(int j=sum;j>=0;--j)
        {
            if(f[j]==-1) continue;
            f[j+c[i]]=max(f[j+c[i]],min(f[j],c[i]));
        }
    }
    for(int i=sum;i>sum/2;--i)
        if(i-f[i]<=sum/2) {ans=i;break;}
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：散华礼弥 (赞：3)

## 背包
(其实我一开始也是没发现这是个背包，单看样例以为是个贪心...没想到还真和贪心有关)

通过观察题目，求的是在满足一定条件下总席位数的最大值，如果我们用背包的思路来做的话，那么席位数就相当于背包的容量，因为这个背包里没有物品，所以就没有价值，而要看当前的放法是否正确，就可直接用dp数组来存。那么以后也就可以直接从它可以到达的状态转移过来了。

这题有一个重点就是需要排个序，然后从大到小取，这样的话就满足如果现在的放法可行，剩下也就一定可行

题目说的是席位数要大于总数的一半，所以转移就从sum/2+a[i]开始转移啦
还有啥看代码应该就能说明了吧...

(顺手写了一个01背包的常数优化没想到跑得飞快)

(第一次写题解，语文不好请见谅qwq)
```cpp
#include <cstdio>
#include <algorithm>
#include <iostream>

int n, m, SUM, MAX, ans, f[100005], v[1005], sum[1005];

int main()
{
    scanf("%d", n);
    for (int i = 1; i <= n; ++i)
    {
        scanf("%d", v[i]);
        sum[0] += v[i];
    }
    SUM = sum[0] >> 1;
    std::sort(v + 1, v + n + 1);
    for (int i = n; i > 0; --i)
        sum[i] = sum[i + 1] + v[i];
    f[0] = 1;
    for (int i = n; i > 0; --i)
    {
        MAX = std::max(SUM - sum[0] + sum[i], v[i]);
        			 //SUM + v[i] - sum[0] + sum[i + 1]
        for (int j = SUM + v[i]; j >= MAX; --j)
      //for (int j = SUM + v[i]; j >= a[i]; --j)
            if (f[j - v[i]])
            {
                f[j] = 1;
                ans = std::max(ans, j);
            }
    }
    printf("%d", ans);
    return 0;
}
```

---

## 作者：dfydada⚡⚡⚡ (赞：2)

# 这题看懂题目之后就只用改下模板就好了。

题意很明确：
现在希望你找出一种方案，你选中的党的席位数要大于总数的一半，并且席位数越多越好.
但是如果某个政党退出后，其它党的席位要等于总数的一半。

先把总席位数加起来，可以边输入边加。


```cpp
for(int i=1;i<=n;i++)
{
	cin>>a[i];
	any+=a[i];
}
```

在求总数的一半。顺便把01背包的f[0]的位置处理一下，在排个序。

```cpp
ans=any/2;
f[0]=1;
sort(a+1,a+n+1);
```
在把缀和求出来。

```cpp
for(int i=n;i>0;i--)
{
	b[i]=b[i+1]+a[i];
}
```

在通过01背包的模板按照题目意思修改就可以了。

```
for(int i=n;i>0;i--)
{
	maxx=max(ans-any+b[i],a[i]);
	for(int j=ans+a[i];j>=maxx;j--)
	{
		if(f[j-a[i]])
		{
			f[j]=1;
			ant=max(ant,j);
		}
	}
}
```

总代码：
```cpp
#include<bits/stdc++.h>
//#pragma GCC optimize(2)//O2优化
using namespace std;
typedef long long ll;
const int N=100000+10;
int n,a[N];
int ans,ant,any,maxx,b[N],f[N];
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
    	cin>>a[i];
    	any+=a[i];
	}
    ans=any/2;
    f[0]=1;
    sort(a+1,a+n+1);
    for(int i=n;i>0;i--)
    {
    	b[i]=b[i+1]+a[i];
	}
    for(int i=n;i>0;i--)
    {
        maxx=max(ans-any+b[i],a[i]);
        for(int j=ans+a[i];j>=maxx;j--)
        {
        	if(f[j-a[i]])
            {
            	f[j]=1;
                ant=max(ant,j);
			}
		}
    }
    cout<<ant;
    return 0;
}
```


---

## 作者：Awdrgysxc (赞：1)

考虑记$f(i,j)$表示前$i$个物品是否可选出的总体积$j$，转移考这个点选不选。

因为总和要大于$\frac{\sum a}{2}$，并且减去任意一个数都能使它不合法。

那么枚举小于$\frac{\sum a}{2}$的体积，若加上$A_i$大于一半，那么记录答案。

可以用`bitset`优化到$\mathcal O(\frac{N\sum a}{w})$。

```cpp
#include <bits/stdc++.h>

int main(void) {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cout.tie(nullptr);
	
	const int X = 100005;
	int N;
	std::cin >> N;
	
	std::vector <int> A(N + 1, 0);
	std::bitset <X> f;
	
	int all = 0;
	for (int i = 1; i <= N; ++i) {
		std::cin >> A[i], all += A[i];
	}
	
	auto g = f, o = f, _ = f;
	for (int i = 0; i <= (all >> 1); ++i)
		o[i] = 1;
	for (int i = (all >> 1) + 1; i <= all; ++i)
		_[i] = 1;
		
	g[0] = 1;
	for (int i = 1; i <= N; ++i) {
		f |= (g << A[i]) & _;
		g |= g << A[i];
		g &= o;
	}
	
	int ans = 0;
	for (int i = all; i >= all / 2; --i) {
		if (f[i]) 
			return printf("%d\n", i) & 0;
	}
	
	puts("-1");
	return 0;
}

```

---

## 作者：pldzy (赞：1)

**一道 01 背包的题。**

## 题目概述

我们要从若干党中挑选几个党出来，组成一个联合内阁，使得：

- 内阁的党的总席位数要越多越好；

- 阁内党席位总数要超过（已给出的）所有党的席位总数的一半；

- 当其中席位数最小的党退出之后，其他阁内的党的总席位数要比总席位数的一半要少。

## 求解

在此题中，**每一个党面临的问题只有被选或不被选**。

这很明显，就是背包 dp。

我们当然是挑选席位数大的党选——这样删去它就不容易会出现阁内席位数仍大于总席位数一半的情况。

然后就是背包的板子了。具体可以见 [P1048 采药 背包模板题](https://www.luogu.com.cn/problem/P1048)。

如果一个党数量上可以加入阁中，且有一种可行的方法，那么就可以用总数量刷新答案。

最后输出答案即可。

~~本人觉得这道题的难点仅是理解题目吧。~~

````cpp
#include<bits/stdc++.h>
using namespace std;

const int maxn = 100050;
int n;
int a[maxn], dp[maxn], res[maxn];
int sum, ans;

int read ()
{
	int x = 1, s = 0;
	char ch = getchar ();
	while (ch < '0' or ch > '9') {if (ch == '-') x = -1; ch = getchar ();}
	while (ch >= '0' and ch <= '9') {s = s * 10 + ch - '0'; ch = getchar ();}
	return x * s;
}

int main ()
{
	dp[0] = 1;
	n = read ();
	for (int i = 1; i <= n; i++) a[i] = read (), sum += a[i];
	sort (a + 1, a + n + 1);
	for (int i = n; i >= 1; i--) res[i] = res[i + 1] + a[i];
	for (int i = n; i >= 1; i--)
	{
		for (int j = (sum >> 1) + a[i]; j >= max ((sum >> 1) - sum + res[i], a[i]); j--) 
			if (dp[j - a[i]])
			{
				dp[j] = 1;
				ans = max (ans, j);
			}
	}
	printf ("%d\n", ans);
	return 0;
}
````

如有问题，求大佬斧正。

---

## 作者：RuSun (赞：1)

## 标准CPP党来了

由于既有的两篇题解都是C，于是我代表CPP党写一篇题解

## 题目是什么意思

由于这道题读起来比较绕，故将题目意思翻译一遍：联合内阁占有的席位要超过总席位数的一半，但去掉最小的已选入内阁的党，剩下的席位要小于一半

## 思路
仔细读题，解决的问题还是取与不取的问题，所以是一道01背包的题

将所有的席位数排序，再用背包处理一下，这样在占有席位数恰好超过一半时，最后选入的党席位数最小

### 关于01背包（大犇可以略过）

模板题目：[01背包模板题](https://www.luogu.org/problem/P1048)

模板代码 （别因为太着急把这个当做答案代码了）

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int d[1042],V,n;
int main ()
	{
		cin>>V>>n;
		for (int i=1;i<=n;i++)
			{
				int w,v;
				cin>>w>>v;
				for (int j=V;j>=w;j--)
					d[j]=max(d[j],d[j-w]+v);
			}
		cout<<d[V];
		return 0;
	}
```

## AC 代码

具体注释看代码

```cpp
#include <cstdio>
#include <algorithm>
#include <iostream>
using namespace std;
int n,m,S,maxn,ans,f[100042]={1},v[1042],sum[1042];//f不要忘记把f[0]赋值为1
int main()
    {
        cin>>n;
        for (int i=1;i<=n;++i)
            cin>>v[i],//输入每个政党的席位数
            sum[0]+=v[i];//只要不是关键字之前，分号可以改为句号（偷懒，不用打大括号）
        S=sum[0]/2;
        sort (v+1,v+n+1);//排序
        for (int i=n;i>0;--i)
            sum[i]=sum[i+1]+v[i];
        for (int i=n;i>0;--i)
            {
                maxn=max(S-sum[0]+sum[i],v[i]);
                for (int j=S+v[i];j>=maxn;--j)
                    if (f[j-v[i]])
                        f[j]=1,
                        ans=max(ans,j);
            }//套模板——之所以没有用dp数组，是因为只用求最优答案，所以只用ans就可以了
        cout<<ans;
        return 0;
    }
```


---

## 作者：ShineEternal (赞：1)

[这里阅读大概更好](https://blog.csdn.net/kkkksc03/article/details/102013751)
## description：
N个政党要组成一个联合内阁，每个党都有自己的席位数.

现在希望你找出一种方案，你选中的党的席位数要大于总数的一半，并且联合内阁的席位数越多越好.

对于一个联合内阁，如果某个政党退出后，其它党的席位仍大于总数的一半，则这个政党被称为是多余的，这是不允许的.

## solution：
由于删除任意一个都要保证小于等于一半，所以只要保 证删除最小的那个后小于等于一半即可。

 我们可以将所有党按照席位数从大到小排序，之后维护 一个$01$背包。

 fj表示通过前i大的党组成席位总数为j的内阁所占的席位


$f_j=max(f_j,(f_j-a_i)+a_i)$

之后枚举满足$f[j]−ai \leq \frac{sum2}{2}$ 并且$f[j] > \frac{sum2}{2}$ 的所有$f[j]$，取最大值

 时间复杂度$O(n*∑︀a_i)$，空间复杂度$O(∑︀a_i)$。


## code:
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int a[305];
int f[100005];
int main()
{
	int n,sum=0;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		//f[a[i]]=1;
		sum+=a[i];
	}
	sort(a+1,a+n+1);
	int ans=0;
	for(int i=n;i>=1;i--)
	{
		for(int j=sum;j>=a[i];j--)
		{
			f[j]=max(f[j],f[j-a[i]]+a[i]);
			if(j-a[i]<=sum/2&&f[j]>sum/2)
			{
				ans=max(ans,f[j]);
			}
		} 
	} 
	printf("%d\n",ans);
	return 0;
}
```

## description：
N个政党要组成一个联合内阁，每个党都有自己的席位数.

现在希望你找出一种方案，你选中的党的席位数要大于总数的一半，并且联合内阁的席位数越多越好.

对于一个联合内阁，如果某个政党退出后，其它党的席位仍大于总数的一半，则这个政党被称为是多余的，这是不允许的.

## solution：
由于删除任意一个都要保证小于等于一半，所以只要保 证删除最小的那个后小于等于一半即可。

 我们可以将所有党按照席位数从大到小排序，之后维护 一个$01$背包。

 fj表示通过前i大的党组成席位总数为j的内阁所占的席位

$f_j=max(f_j , (f_j−a_i)+a_i)$ 

之后枚举满足$f[j] −ai ≤  \frac{sum2}{2}$ 并且$f[j] > \frac{sum2}{2}$ 的所有$f[j]$，取最大值

 时间复杂度$O(n*∑︀a_i)$，空间复杂度$O(∑︀a_i)$。


## code:
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int a[305];
int f[100005];
int main()
{
	int n,sum=0;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		//f[a[i]]=1;
		sum+=a[i];
	}
	sort(a+1,a+n+1);
	int ans=0;
	for(int i=n;i>=1;i--)
	{
		for(int j=sum;j>=a[i];j--)
		{
			f[j]=max(f[j],f[j-a[i]]+a[i]);
			if(j-a[i]<=sum/2&&f[j]>sum/2)
			{
				ans=max(ans,f[j]);
			}
		} 
	} 
	printf("%d\n",ans);
	return 0;
}
```

---


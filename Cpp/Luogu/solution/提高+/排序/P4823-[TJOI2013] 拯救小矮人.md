# [TJOI2013] 拯救小矮人

## 题目描述

一群小矮人掉进了一个很深的陷阱里，由于太矮爬不上来，于是他们决定搭一个人梯。即：一个小矮人站在另一小矮人的 肩膀上，直到最顶端的小矮人伸直胳膊可以碰到陷阱口。

对于每一个小矮人，我们知道他从脚到肩膀的高度 $A_i$，并且他的胳膊长度为 $B_i$。陷阱深度为 $H$。

如果我们利用矮人 $1$，矮人 $2$，矮人 $3$，……，矮人 $k$ 搭一个梯子，满足 $A_1+A_2+A_3+\dots+A_k+B_k \geq H$，那么矮人 $k$ 就可以离开陷阱逃跑了，一旦一个矮人逃跑了，他就不能再搭人梯了。  

我们希望尽可能多的小矮人逃跑，问最多可以使多少个小矮人逃跑。

## 说明/提示

对于 $30\%$ 的数据，$N\leq 200$；  

对于 $100\%$ 的数据，$1 \leq N\leq 2000$，$1 \leq A_i,B_i,H\leq10^5$。

## 样例 #1

### 输入

```
2
20 10
5 5
30```

### 输出

```
2```

## 样例 #2

### 输入

```
2
20 10
5 5
35```

### 输出

```
1```

# 题解

## 作者：灯芯糕 (赞：64)

# 浅析拯救小矮人的 nlogn 算法及其证明



------

------

## 题型简介：

有 $ n $ 个人，第 $ i $ 个人身高 $ a_i $ 手长 $ b_i $ ，他们为了从一个高为 $ H $ 的洞中出去，决定搭人梯。如果一个人和他下面的人的身高之和加上他的手长可以达到洞的高度，那么他就可以出去。求最多有多少人能出去。 $ n\leq 10^6 $ 



------

------

## 算法流程（本算法吊打在座所有人，不服来Hack！）

本题需要贪心，所以我们可以贪心到底。首先我们将所有人，按照他们的最低逃生高度 $ H-a_i-b_i $ 从高到低排序。一个必须要知道的结论：**最低逃生高度越高的人，一定越先走**。

首先我们将所有人按照 $ H-a_i-b_i $ （最低逃生高度）从高到低排序，根据结论越高的人越先走。然后如果是 $ n^2 $ 背包，就是对每个人做有条件的背包，模拟每个人是否能走。

而 $ n\times logn $ 的方法则是记录一个后缀 $ s[] $ ，其中 $ s[i] $ 表示第 $ i $ 个人后面**最低逃生高度比他低的所有人的身高总和**，然后用一个 $ tot $ 记录前面**没有出去的人的身高总和**，对于从高到低枚举的第 $ i $ 个人，如果 $ s[i]+tot>=H-a_i-b_i $ 就说明他能出去（于是默认他出去）；否则就**将这个人的身高和前面所有已经出去的人的身高作比较**，如果当前这个人最高那么他就不出去了，不然就从前面已经出去的人里面找到那个最高的人，把他拉回洞里垫在下面，让当前这个人出去！照着这个过程做我们就能得到最优解。（觉得不对？有本事你来Hack啊！）

[挂个链接，不服可以来这里怼，有Hack思路可以来这里分享](https://www.cnblogs.com/812-xiao-wen/p/11545341.html)



------

## 算法证明：

其实这个算法只有两个待考究的地方，问题一：为什么最低逃生高度高的人，一定越先走？这个问题在很多题解里已经讨论过了，难以讲清，本题不做多讲，就用一张图感性一下：

![](https://s2.ax1x.com/2019/09/18/nH0bV0.png)



**本算法第二个问题在于这句话：** 否则就**将这个人的身高和前面所有已经出去的人的身高作比较**，如果当前这个人最高那么他就不出去了，垫到下面去；不然就从前面已经出去的人里面找到那个最高的人，把他拉回洞里垫在下面，让当前这个人出去！为什么把上面最高的那个人拉下来，这个人就一定可以出去了？为什么只取一个人下来，我们可不可以拉多个人下来，让当前这个人出去的同时为后面的人垫高度？这个我们用两张图解读：



![](https://s2.ax1x.com/2019/09/18/nH0XPU.png)

![](https://s2.ax1x.com/2019/09/18/nHBmMd.png)



------

------

## 代码和结语

好了，做个解释（捂脸），本文可能有些言语偏激，但只是为了吸引你们过来思考，集思广益的。本人很菜，搞完今年 $ Noip $ 可能就要退役了，证明过程不一定完全正确，语言不一定简练易懂，总得感性理解。做题的oj比较多，直接洛谷讨论不一定看得到，但是博客自带邮件提醒，所以大家尽量博客留言写下你的想法或疑问，谢谢。

[代码和整个过程放这里了，好吧就当这个是纯粹来宣传一下博客的，QAQ](https://www.cnblogs.com/812-xiao-wen/p/11545341.html)

---

## 作者：LengChu (赞：50)

```
#include<cstdio>
#include<algorithm> 
#define rint register int
using namespace std;
int n,h,dp[2010];//走i个人后可以取的最大高度 
struct node{ int a,b; } a[2010];
bool cmp(node x,node y){ return x.a+x.b<y.a+y.b; }
int main()
{
	scanf("%d",&n); for(rint i=1;i<=n;i++) scanf("%d%d",&a[i].a,&a[i].b); scanf("%d",&h);
	sort(a+1,a+1+n,cmp); for(rint i=1;i<=n;i++) dp[i]=-0x3f3f3f3f,dp[0]+=a[i].a;
	for(rint i=1;i<=n;i++) for(rint j=i;j>=1;j--) if(dp[j-1]+a[i].b>=h) dp[j]=max(dp[j],dp[j-1]-a[i].a);
	for(rint i=n;i>=0;i--) if(dp[i]>=0) { printf("%d",i); return 0;}
}
/*贪心选择逃生能力较弱的人先逃出去 即a+b较小 
这样排序以后就不会出现后面的人先逃出去比前面的人先逃出去更优的情况
但是有可能前面的人a较大b较小 他不逃出去对答案更优 
做个背包就行了 dp[i]表示走i个人后可以取的最大高度 
原谅我想缩个行qwq*/ 
```

---

## 作者：HsKr (赞：34)

考虑：如果矮的不先走，那他以后有可能永远也走不掉了。高的如果先走，他对人梯的贡献就没了。

所以得出：先走矮的。

但如果两个人总长一样，应该把身子长的留下来，他对梯子的贡献更大。

贪心排序即可。

思路：背包DP。

状态：`f[i][j]`表示排序后前$i$个人走掉$j$个时，人梯剩余的最大高度。

然而发现背包的$i$那一维可以压缩掉。

边界：`f[0] = a[i] (1 <= i <= n)`。

目标：当`f[i] >= 0`成立时，$i$的最大值。

状态转移方程：`f[j] = max(f[j], f[j - 1] - a[i])`。


```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
using namespace std;

inline int read() {
	int d = 0; char ch = getchar(); while(!isdigit(ch)) ch = getchar();
	while(isdigit(ch)) d = d * 10 + ch - 48, ch = getchar(); return d;
}

void write(int x) {
	if(x >= 10) write(x / 10);
	putchar(x % 10 + 48);
}

int n, h;

struct node {
	int a, b;
}t[2010];

int f[100010];

bool cmp(node x, node y) {
	if(x.a + x.b == y.a + y.b) return x.a < y.a;
	return x.a + x.b < y.a + y.b;
}

int main() {
	n = read();
	for(int i = 1; i <= n; i++) t[i].a = read(), t[i].b = read();
	h = read();
	
	sort(t + 1, t + n + 1, cmp);
	
	memset(f, -1, sizeof(f));
	f[0] = 0;
	for(int i = 1; i <= n; i++) f[0] += t[i].a;
	
	for(int i = 1; i <= n; i++) {
		for(int j = i; j >= 1; j--) {
			if(f[j - 1] + t[i].b >= h) {
				f[j] = max(f[j], f[j - 1] - t[i].a);
			}
		}
	}
	
	for(int i = n; i >= 0; i--) {
		if(f[i] >= 0) {
			printf("%d\n", i);
			break;
		}
	}
	return 0;
}

```

---

## 作者：君玘 (赞：11)

先理解题目：

- 有一群小矮人$p$，其中$p_i$的肩高为$a_i$,手长为$b_i$，被困在深$h$的坑中；
- 小矮人靠搭建人梯爬出去，若$p_i,\cdots p_j$参与搭建人梯，则人梯高度为$a_i,\cdots a_j$；
- 当且仅当小矮人踩着高为H的人梯时手能碰到坑口，此小矮人能够爬出去。即若$H+a_k+b_k\ge h$时$p_k$能够爬出去。
- $n\le2000$，求最多能爬出多少小矮人。

一开始我想的是**搭建人梯后有多少小矮人可以出去**，然后想到一个贪心：

若已建人梯高为$H$，且有$H+a_k+b_k\ge h$，那么将$p_k$站上人梯不会使结果变坏。

那么接下来我就要思考若不存在小矮人能够直接爬上去，显然，我们只能找一个牺牲品。

那么，**让谁来牺牲**就是我们要解决的下一个问题。

那么对于牺牲品：

1. 牺牲品的位置向下改变不会使结果变坏，因此直接让其垫底就行；
2. 牺牲品的牺牲不能使结果变坏；
3. 牺牲品的手长没有用。故当前最优牺牲品一定是$a$最大的。

这样，我就将想法稍稍转变了一下：**最少牺牲多少小矮人能使其他小矮人出去。**

显然：若不存在更优的牺牲，此时得到贪心正解。那么我需要对牺牲品进行更完整一点的理解：

1. 若牺牲品可以出去，其牺牲后定能使一个不能出去的小矮人出去，且其他小矮人的状态不会变坏；
2. 若其不能出去，其牺牲后其他小矮人的状态不会变坏。

我想了很久，得到了这样一个贪心：

1. 按$a+b$从大到小排序，然后令$H+=a_k$。即遵循一开始想到的贪心进行人梯搭建；
2. 判断人梯的最顶端的$p_k$是否能够直接爬出去：

     - 若可以，显然$p_k$满足牺牲品的条件，可作为牺牲品。因此我用一个按照$a$大到小的优先队列$q$储存，令$H-=a_k$即令$p_k$爬出去或去牺牲；
     - 若不行，此时$p_k$满足牺牲品的条件，且需要有小矮人牺牲：那么选择牺牲$p_k$或者牺牲$q$里的牺牲品。
3. 开始牺牲，即将牺牲的小矮人垫在最底下：

     - 牺牲$p_k$： 此时对于底下的人梯只会更优，且对于$q$里的人无影响；
     - 牺牲$q$里的牺牲品：此时人梯变高，若$p_k$可以爬出去，剩下的人梯不会变坏，对q里人无影响，且结果不会变坏；若$p_k$仍然无法爬出去，$q$里的人将无法作为牺牲品，只能牺牲$p_k$。

4. 统计完牺牲人数后，$ans=n-cnt$。

代码实现如下：
```cpp
#include<bits/stdc++.h>
#define gc ch=getchar()
using namespace std;
template <class T>void read(T &s){
	s=0;T f=1;char gc;
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;gc;}
	while(ch>='0'&&ch<='9'){s=s*10+ch-'0';gc;}
	s*=f;	
}
template <class T>void put(T s){
	if(s<0) putchar('-'),s=-s;
	if(s>9) put(s/10);
	putchar(s%10+'0');
}
struct people{
	int a,b,sum,pos;
	bool operator <(const people &x)const{return x.a>a;}
}p[2005];
priority_queue<people> q;
int n,h,H,k,vis[2005],cnt;
bool cmp(people x,people y){
	if(x.sum==y.sum) return x.a<y.a;
	return x.sum>y.sum;
}
int main(){
	read(n),cnt=n;
	for(int i=1;i<=n;++i) read(p[i].a),read(p[i].b),p[i].pos=i,p[i].sum=p[i].a+p[i].b,H+=p[i].a;
	read(h);
	sort(p+1,p+1+n,cmp);
	int i=n;
	while(i){
		if(H+p[i].b>=h) q.push(p[i]),H-=p[i].a,--i;
		//如果小矮人能够爬出来，就直接爬出来，然后进队 
		else{
			if(!q.empty()){
				if(H+q.top().a+p[i].b>=h){
					//这边比较的是牺牲q.top后小矮人i能不能爬出来
					//若可以，还要判断q.top和小矮人i谁更高，优先选高的 
					if(q.top().a>p[i].a) H+=q.top().a-p[i].a,q.pop(),q.push(p[i]),--i,++k;
					else --i,++k;
				} 
				else --i,++k;
			}
			else --i,++k;
			//否则牺牲小矮人i即可 
		}
	}
	put(n-k);
}
```


---

## 作者：Sol1 (赞：7)

再来一篇 $O(n\log n)$ 的题解。

首先看到这个题就会发现不管是 DP 还是贪心，都是和初始序列的顺序有关的。所以先考虑如何排序。

有一个显然的思路就是看一个人至少需要站得多高，然后让需要站得较高的人先跑，而需要站的位置较低的人后跑。

所以排序是按 $a_i+b_i$ 升序。

然后我们发现对于每一个人都有两种决策：

1. 跑出去（如果可以）
2. 压在底下提高度

还是贪心地想，如果一个人能跑，我们就要放他跑掉。不妨先这么做。

然后，如果一个人目前不能跑，我们就要思考如何做了。

如果直接把他放到底下压着，那么可能会出现这样一个问题：就是说此时这个人的 $b$ 属性就没用了，但是有可能这个人 $a$ 很小 $b$ 很大，而之前有一个跑掉的人 $a$ 很大 $b$ 很小。这种情况下，垫着的高度有可能可以增大。

那么我们就去增大它。如果已经有人上去，我们去考虑把这些人里面 **$a$ 最大的**一个人再扔下去。如果：

- 扔下去以后当前的人能上来
- 当前的人的 $a$ 比这个人的 $a$ 要小

就相当于答案没变，而垫着的高度增加了，也就是决策更优了。

最优性得到满足。

你可能还会思考：题目是不允许把一个人拉上来再扔下去的，这样做不会出问题吗？

显然不会，因为你可以让他在原先出来的时候就下去，这样剩下的人站着的高度只会增加，不会受到影响。

可行性也得到满足。

所以先排序，然后用优先队列去维护已经逃出陷阱的人，就可以达到 $O(n\log n)$ 的复杂度了。

代码实现非常简单，不多说。

```cpp
#include <iostream>
#include <cmath>
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <queue>
using namespace std;

#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1 << 21], *p1 = buf, *p2 = buf;

inline int qread() {
	register char c = getchar();
	register int x = 0, f = 1;
	while (c < '0' || c > '9') {
		if (c == '-') f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = (x << 3) + (x << 1) + c - 48;
		c = getchar();
	}
	return x * f;
}

inline int Abs(const int& x) {return (x > 0 ? x : -x);}
inline int Max(const int& x, const int& y) {return (x > y ? x : y);}
inline int Min(const int& x, const int& y) {return (x < y ? x : y);}

int n, h, sum;
pair <int, int> a[2005];
priority_queue <pair <int, int> > que;

bool cmp(pair <int, int> a1, pair <int, int> a2) {
	return a1.first + a1.second < a2.first + a2.second;
}

inline void Read() {
	n = qread();
	for (register int i = 1;i <= n;i++) {
		a[i].first = qread(); a[i].second = qread();
	}
	h = qread();
}

inline void Solve() {
	for (register int i = 1;i <= n;i++) sum += a[i].first;
	for (register int i = 1;i <= n;i++) {
		if (sum + a[i].second >= h) {
			que.push(a[i]);
			sum -= a[i].first;
		} else {
			if (!que.empty() && sum + a[i].second + que.top().first >= h && que.top() >= a[i]) {
				sum += que.top().first;
				que.pop();
				que.push(a[i]);
				sum -= a[i].first;
			}
		}
	}
	cout << que.size();
}

int main() {
	Read();
	sort(a + 1, a + n + 1, cmp);
	Solve();
	#ifndef ONLINE_JUDGE
	while (1);
	#endif
	return 0;
}
```

---

## 作者：SIXIANG32 (赞：6)

非常有趣的一道题，乍一看很鬼，实际上仔细思考一下就能得到答案。  
闲话少说，切入正题——

---
首先，我们来想想这个小矮人排列的大致次序。  
如果把高的给弄出去，那么这个贡献没了，很有可能导致只有这个高的一个人出去剩下的矮子全出不去的情况。  
那么矮的弄出去呢？显然，矮的弄出去对人梯的高度损失是最小的，也可以让更多的矮子出去。  
综上所述，我们就按照 $a_i+b_i$ 从小到大排列矮人。  

---
然后问题来了，我们应该如何统计答案呢？  
可以用 dp 鸭~  
设 $f_i$ 为当前出去了 $i$ 个人能堆起来最高的高度（不算手）。  
要不然，$p$ 号小矮人不出去，$f_i$ 还是 $f_i$。  
要不然，$p$ 号小矮人滚出去，$f_i$ 就变成了 $f_{i-1}-a_p$。  
所以状态转移方程就出来了：$ f_i=\max(f_i,f_{i-1}-a_p)$。  

---
上代码！  
```cpp
#include<iostream>
#include<algorithm> 
#include<cstring>
using namespace std;
struct node{
	int a,b;
}A[2021];
bool cmp(node &x,node &y)//排序比较器
{
	return x.a+x.b<y.a+y.b;
}
int f[2021];
int main()
{
	memset(f,128,sizeof(f));//这里的 128 运用到了补码原理，总之你只要知道是最小值就好了。
	int n,h;
	cin>>n;
	for(int p=1;p<=n;p++)
		cin>>A[p].a>>A[p].b;
	cin>>h;
	sort(A+1,A+n+1,cmp);//排序
	f[0]=0;//没人出去
	for(int p=1;p<=n;p++)//初始化没人出去的情况，显然这个时候要累加 a[p]
		f[0]+=A[p].a;
	for(int p=1;p<=n;p++)//根据上面的方程 dp
		for(int i=p;i>=1;i--)
			if(f[i-1]+A[p].b>=h)//如果算上这个人的手能出去
				f[i]=max(f[i],f[i-1]-A[p].a);
	for(int p=n;p>=0;p--)
		if(f[p]>=0)
		{
			cout<<p<<endl;
			return 0;
		}
}
```

---

## 作者：Lumos壹玖贰壹 (赞：5)

#### 贪心+背包
##### 题目描述

一群小矮人掉进了一个很深的陷阱里，由于太矮爬不上来，于是他们决定搭一个人梯。

对于每一个小矮人，我们知道他身高Ai，他的胳膊长度为Bi。陷阱深度为H。

问最多可以使多少个小矮人逃跑。
##### 分析
此题虽然是贪心，但贪出最终解比较难(当然有大佬贪到底了)。比较好贪心的是**两个要逃出去的人的先后顺序**
+ 结论：让a+b小的先出去
+ 证明：邻项交换

1. 设有两个**相邻出去**的人$i$和$j$都要出去，**最优顺序**是$i$先$j$后
2. 考虑**交换**这两个人，让$j$先出去$i$后出去
3. 因为这两个人**在逃出序列里**是**相邻**的，所以交换后对后面的人是**没有影响**的。之所以换了之后不优，是因为换了后$i$出不去了(之前两个人都能出去)。设这两个人下面所有人的高度为$h$。
4. 可以得到式子

$a[i]+b[i]+h$<$H$<=$a[j]+b[j]+h$

所以$a[i]+b[i]<a[j]+b[j]$

而最优顺序中$i$在$j$前面，所以要把$a+b$小的放在前面

~~emmm至于a+b相等时让a大的后出去应该不需要证明吧~~

最后只要跑一遍背包，考虑**所有人堆一个塔**，前i个人跑j个剩下的高度就可以了

**蒟蒻**尽己所能给出了自认为正确~~但不严谨~~的证明，欢迎大佬提出意见
##### 代码
```cpp
#include<bits/stdc++.h>
#define ri register int
#define ll long long
using namespace std;
const int maxn=2005;
struct node{
	int a,b;
}t[maxn];
int n,H;
ll f[maxn];
int cmp(node a,node b){
	if(a.a+a.b == b.a+b.b) return a.a<a.b;
	return a.a+a.b<b.a+b.b;
}
int main(){
	scanf("%d",&n);
	for(ri i=1;i<=n;i++) scanf("%d%d",&t[i].a,&t[i].b);
	scanf("%d",&H);
	sort(t+1,t+n+1,cmp);
	for(ri i=0;i<=n;i++) f[i]=-0x3f3f3f3f;
	f[0]=0;
	for(ri i=1;i<=n;i++) f[0]+=t[i].a;
	for(ri i=1;i<=n;i++){
		for(ri j=i;j>=1;j--)
			if(f[j-1]+t[i].b-H>=0)
				f[j]=max(f[j],f[j-1]-t[i].a);
	}
	for(ri i=n;i>=0;i--)
		if(f[i]>=0){
			cout<<i<<endl;
			break;
	}
	return 0;
}

```

---

## 作者：Adam_Ng (赞：5)

很厉害的贪心+背包题

题意：这题面太难概括惹看原题八[P4823 [TJOI2013]拯救小矮人](https://www.luogu.org/problemnew/show/P4823)

可以看出矮人在上比高人在上要优，身高越小，出去的数量越多，而手长越短就越需要先出去，所以综合起来身高越小、手越短的先出去。所以我们按$a_i+b_i$给他们排序。

但是这样的顺序可以满足上面的人先出去,但是会缺少垫脚石，也就是那些腿长手短的，他们可以选择奉献自己拯救他人。

所以我们考虑dp

设$f_i$表示逃出去$i$个人时的最高高度。

对于第$i$个人，他前面最多逃出去$i - 1$个人。

若$i$在此时可以逃出去，那么他就是一个可以用来更新的答案

所以转移就出来惹

$$f_j=max(f_{j-1}-a_i) \ j<=i-1$$

## Core Codes

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 2005, inf = 0x3f3f3f3f;
struct person {
    int a, b;
}p[N];
bool cmp(person a, person b) {return a.a + a.b < b.a + b.b;}
int n, h, dp[N];

int main() {
    scanf("%d", &n);
    for(int i = 1; i <= n; ++i) scanf("%d%d", &p[i].a, &p[i].b);
    scanf("%d", &h);
    for(int i = 1; i <= n; ++i) dp[0] += p[i].a, dp[i] = -inf;
    sort(p + 1, p + 1 + n, cmp);
    for(int i = 1; i <= n; ++i)
        for(int j = i; j >= 1; --j)
            if(dp[j - 1] + p[i].b >= h) dp[j] = max(dp[j], dp[j - 1] - p[i].a);
    for(int i = n; i >= 0; --i)
        if(dp[i] >= 0) {
            printf("%d\n", i);
            return 0;
        }
}
```


讲完惹。

zu大家身体健勘。

---

## 作者：Priori_Incantatem (赞：3)

[题目](https://www.luogu.com.cn/problem/P4823)

观察题目性质，发现身高低的人站在上面比身高高的人站在上面更优，因为身高搞的人在下面可以帮助更多身高低的人  
对于手的长度也同理：手长的站在下面比手短的站在下面更优，因为手长的人可以在下面帮助别人，而逃出去的机会又比手短的人大

上面的综合一下，得出排序方法
```cpp
inline bool cmp(node x,node y)
{
	return x.w+x.e<y.w+y.e;
}
```
设状态$f[i]$为逃出$i$个人后，井里剩下的人塔的最大高度  

第$i$个人只能经过$f[1\sim i-1]$转移到$f[i]$，因为要保证第$i$个小人在之前的状态中还没逃出去

转移方程：`if(f[j-1]+a[i].e>=m)f[j]=max(f[j],f[j-1]-a[i].w);`

**Code:**

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
const int Maxn=2010,inf=0x3f3f3f3f;
int f[Maxn],n,m;
struct node{
	int w,e;
}a[Maxn];
inline bool cmp(node x,node y)
{
	return x.w+x.e<y.w+y.e;
}
inline int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0' && ch<='9')s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
	return s*w;
}
int main()
{
	//freopen("in.txt","r",stdin);
	n=read();
	for(int i=1;i<=n;++i)
	a[i].w=read(),a[i].e=read(),f[0]+=a[i].w,f[i]=-inf;
	sort(a+1,a+1+n,cmp);
	m=read();
	for(int i=1;i<=n;++i)
	for(int j=i;j>0;--j)
	if(f[j-1]+a[i].e>=m)f[j]=max(f[j],f[j-1]-a[i].w);
	for(int i=n;i>=0;--i)if(f[i]>=0){printf("%d\n",i);return 0;} //如果人塔没有透支，就输出
	return 0;
}
```

---

## 作者：hs_black (赞：2)

### 思路： 贪心 + dp

首先贪心按身长加手长排序， 也就是让最难出去的先出去

但也有可能有人手短身子长， 那他奉献自己可能更优

所以在加个背包dp

代码：

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;
const int N = 2005;
const int H = 100500;
int dp[H], n, h; // dp[i] 表示出去i个人最高的高度
struct node{
	int a, b;
	bool operator < (const node &i) const {
		return a + b < i.a + i.b;
	}
}p[N];
int read(void) {
	int x = 0; char c = getchar();
	while (!isdigit(c)) c = getchar();
	while (isdigit(c)) {
		x = (x << 3) + (x << 1) + c - '0';
		c = getchar();
	}
	return x;
}

int main() {
	n = read();
	for (int i = 1;i <= n; i++) p[i].a = read(), p[i].b = read();
	h = read();
	sort(p + 1, p + n + 1); 
	for (int i = 1;i <= n; i++) dp[i] = -0x3f3f3f3f, dp[0] += p[i].a;
   	// 每个人的体积为1， 价值为a
	for (int i = 1;i <= n; i++) 
		for (int j = i;j >= 1; j--) 
			if (dp[j-1] + p[i].b >= h)
				dp[j] = max(dp[j], dp[j-1] - p[i].a);
	for (int i = n;i >= 0; i--) 
		if (dp[i] >= 0) {
			cout << i << endl;
			return 0;
		}
	return 0;
}
```



---

## 作者：zyj_Orz (赞：1)

方法：贪心+DP

首先把所有小矮人高度按a+b从小到大排序，可保证如果x 比y先走，那么x在序列中在y的前面。

开始dp。设f[i][j]表示前i个人走了j个的最大高度。

边界为f[0][0]=0。

状态转移方程：

不走```f[i-1][j]即为f[i][j]```

走```f[i-1][j]即为f[i][j+1]```

注意后面的全部堆起来，加上前面的人以及自己的高度能否出去。

即```f[i-1][j]+s[i+1]+a[i]+b[i]>=H```

答案就是最大的使得f[i][n]被更新过的i。

放核心代码。

```
    
    sort(a+1,a+n+1);
    for (int i=n;i;--i) s[i]=s[i+1]+a[i].a;
    for (int i=1;i<=n;++i)
        for (int j=0;j<i;++j) {
            fix(f[i][j],f[i-1][j]+a[i].a);
            if (f[i-1][j]+s[i+1]+a[i].a+a[i].b>=h) fix(f[i][j+1],f[i-1][j]);
        }

    for (re int i=n;~i;--i)
        if (f[n][i]>=0) {cout<<i; break; }
    return 0;
```

---

## 作者：andysk (赞：1)

# Luogu4823 [TJOI2013]拯救小矮人

[Link](https://www.luogu.org/problem/P4823)

[Blog](https://tony102.xyz/index.php/2019/10/31/luogu4823-tjoi2013%e6%8b%af%e6%95%91%e5%b0%8f%e7%9f%ae%e4%ba%ba/)阅读效果更佳

题意很清楚，不说了

首先可以根据样例确定一个基本的策略，肯定希望身高矮的先走，高的后走

考虑一个有点类似于背包的DP (学长[Xiao-wen](https://www.luogu.org/space/show?uid=111334&myuid=46708&follow=1)也就是讨论版那位想到了很厉害的$O(nlogn)$贪心)

设$f[i][j]$表示到第$i$个小矮人时已经逃出去$j$个的最大高度

很好转移: $f[i][j+1] = max(f[i][j+1],f[i][j]-a[i])$，其中 $0≤j≤ans$，$ans$ 为当前最多逃出去的小矮人

此外，考虑我们最开始想到的性质，可以按照身高+臂长进行排序，优化DP

详见代码



### Code

```cpp
#include <bits/stdc++.h>
using namespace std;

const int SIZE = 2000 + 5;

int n, h;
int f[SIZE];

struct node {
    int ai, bi, tot;
} a[SIZE];

namespace ae86 {
	const int bufl = 1 << 15;
	char buf[bufl], *s = buf, *t = buf;
	inline int fetch() {
		if (s == t) { t = (s = buf) + fread(buf, 1, bufl, stdin); if (s == t) return EOF; }
		return *s++;
	}
	inline int read() {
		int a = 0, b = 1, c = fetch();
		while (!isdigit(c))b ^= c == '-', c = fetch();
		while (isdigit(c)) a = a * 10 + c - 48, c = fetch();
		return b ? a : -a;
	}
}
using ae86::read;

inline int CMP(node a, node b)
{
    if (a.tot == b.tot) return a.ai < a.ai;
    return a.tot < b.tot;
}

int main()
{
    // freopen("data.in", "r", stdin);
    n = read();
    memset(f, -1, sizeof(f));
    f[0] = 0;
    for (int i = 1; i <= n; i++) {
        a[i].ai = read(), a[i].bi = read(), a[i].tot = a[i].ai + a[i].bi;
        f[0] += a[i].ai;
    }
    h = read();
    std::sort(a + 1, a + n + 1, CMP);
    int ans = 0;
    for (int i = 1; i <= n; i++) {
        for (int j = ans; j >= 0; j--) {
            if (f[j] + a[i].bi >= h) f[j + 1] = std::max(f[j + 1], f[j] - a[i].ai);
        }
        if (f[ans + 1] >= 0) ans++;
    }
    printf("%d", ans);
    return 0;
}
```



---

## 作者：aakennes (赞：0)

### 题目大意：
几个矮子，给定手的长度和身子的高度，最顶上的矮子可以用手，能够到顶就能出去，问最多出去几个
### 贪心策略：

类似反悔贪心，先让个子和手都大的压在下面，小的放在上面，如果上面出不去，说明他永远出不去了，直接拉到底，换个人在上

由于换的人不能选择，所以直接跑背包


也可以理解为，可能一个人的个子大，手短，不逃出去更优，所以跑背包

所以总流程就是：按手和身高之和排序，然后以人的数量为容量跑背包，倒序查找第一个符合条件的

具体见代码

### 代码：
```
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
using namespace std;
const int maxn=2e5+5,INF=0x3f3f3f3f;
int n,m,ans=1,sum,summ,maxx,f[maxn];
struct Node{
	int x,y;
	bool operator <(const Node &A)const{
		return x+y<A.x+A.y;
	}
}a[maxn];
int main(){
	cin>>n;memset(f,128,sizeof(f));f[0]=0;
	for(int i=1;i<=n;i++)cin>>a[i].x>>a[i].y,f[0]+=a[i].x;
	sort(a+1,a+1+n);cin>>m;
	for(int i=1;i<=n;i++){
		for(int j=i;j>=1;j--){
			if(f[j-1]+a[i].y>=m)f[j]=max(f[j],f[j-1]-a[i].x);
		}
	}
	for(int i=n;i>=0;i--){
		
		if(f[i]>=0){printf("%d",i);goto skr;}
	}
	puts("0");
	skr:;
	return 0;
}
```

---


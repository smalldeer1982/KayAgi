# 「DAOI R1」Magic

## 题目背景

> $ \text{-1,-1,+2} $

## 题目描述

乔木 来到了大魔王的面前，他决定使用魔法击败魔王。

给定一个整数 $n$，表示有 $n$ 个魔法阵，在每个魔法阵上都存在着一定的魔力值 $a_i$。

你每次可以选择三个魔法阵 $i,j,k\;(i,j,k$ 互不相同且 $a_i>0$，$a_j>0)$，然后 乔木 将会让第 $i$ 个魔法阵和第 $j$ 个魔法阵上的魔力值 $a_i,a_j$ 分别减 $1$，并让第 $k$ 个魔法阵上的魔力值 $a_k$ 加 $2$，我们将这称之为一次操作。

乔木 想要将所有的魔力汇聚到一起以发挥最大的威力。他想知道在经过若干次操作后，能否让其中 $n-1$ 个魔法阵上的魔力值为 $0$，并使汇聚的那一个魔法阵的魔力值为原魔法阵的所有魔力值之和。

## 说明/提示

### 样例解释
- 对于第一组数据，可以将 $a_1$ 和 $a_3$ 对 $a_4$ 进行两次操作。
- 对于第二组数据，可以证明不行。

### 数据范围
- 对于 $5\%$ 的数据：$1\le n\le2$，$0\le a_i\le10^3$。
- 对于 $20\%$ 的数据：$1\le n\le10$，$0\le a_i\le10^3$。
- 对于 $100\%$ 的数据：$1\le \sum{n}\le2\times10^{6}$，$0\le a_i\le10^{9}$。

对于所有数据，保证 $1\le T\le100$ 且 $\sum\limits_{i=1}^{n} a_i \ge1$。

## 样例 #1

### 输入

```
2
4
2 0 2 2
3
5 0 7```

### 输出

```
YES
NO```

# 题解

## 作者：Erinyes (赞：5)

### 来自出题人的题解。

这道题我们采用**分类讨论**的思想。

## $n\le2$：

当 $n=1$ 时，一定可以实现。

当 $n=2$ 时，如果不是其中一个为 $0$，就不能实现。

```cpp
if(n==1) puts("YES");
if(n==2){
	if(a[1]==0 || a[2]==0) puts("YES");
	else puts("NO");
}
```
## $n=3$：
我们可以将这个数列表示为 $a_1,a_2,a_3$。

首先将这个数列升序排序。

那么就可以将三个数变成 $0$ 和另外两个数。

具体过程：

$$a_1,a_2,a_3$$

将 $a_1$ 和 $a_2$ 对 $a_3$ 执行 $a_1$ 次操作，即可得到：

$$0,(a_2-a_1),(a_3+a_1\times2)$$

假如剩下的数为 $0,x,y$ $(x<y)$。

我们将 $x$ 和 $y$ 各减去 $1$，再将 $0$ 加上 $2$，就会变成 $2,(x-1),(y-1)$。

再将 $2$ 和 $x-1$ 对 $y-1$ 执行两次操作，就会变成 $0,(x-3),(y+3)$。

由此在不改变 $a_1$ 为 $0$ 的情况下，每次可以将 $x$ 减去 $3$，再将 $y$ 加上 $3$。

- 如果 $x\bmod3$ 为 $0$，则最后肯定可以使 $x$ 变成 $0$，并把 $y$ 变成 $x+y$。

- 如果 $x\bmod3$ 不为 $0$，那么肯定可以使用刚才的方式将原数列变为：

**这里的 $k$ 表示为操作完的 $y$ 值，对结果不影响。**

$$0,1,k$$

或者

$$0,2,k$$

**当数列是 $0,1,k$ 时**，我们可以将 $1$ 和 $k$ 对 $0$ 进行一次操作，将数列变为：

$$2,0,(k-1)$$

这时，若 $(k-1)\bmod3$ 为 $0$，则可以像之前的方法将 $2$ 和 $k-1$ 进行操作，所以可以。

**当数列是 $0,2,k$ 时**，我们也可以将数列变为：

$$4,0,(k-2)$$

这时，若 $(k-2)\bmod3$ 为 $0$，则可以像之前的方法将 $4$ 和 $k-2$ 进行操作，所以可以。

上面两种方法一个满足 $x\bmod3$ 为 $1$ 且 $y\bmod3$ 为 $1$，另一个满足 $x\bmod3$ 为 $2$ 且 $y\bmod3$ 为 $2$，总结出来就是 $(x+y)\bmod3$ 不为 $0$。

所以当满足上述条件之一是时一定可以实现，否则不行。

**注意：$x$ 和 $y$ 可以互换**

```cpp
if(n==3){
	sort(a+1,a+n+1);
	a[3]+=a[1]*2; a[2]-=a[1]; a[1]=0;
	if(a[2]%3==0 || a[3]%3==0) puts("YES");
	else if((a[2]%3==1 && a[3]%3==1) || (a[3]%3==1 && a[2]%3==1)) puts("YES");
	else if((a[2]%3==2 && a[3]%3==2) || (a[3]%3==2 && a[2]%3==2)) puts("YES");
	else puts("NO"); 
}
```
## $n=4$：
对于这种情况，我们可以用类似于 $n=3$ 的方法将数列变成 $0,0,x,y$。

具体方法：先对整个序列进行升序排序，然后对于每一个 $i$ $(2\le i<n)$，可以将 $a_{i-1}$ 和 $a_i$ 对 $a_{i+1}$ 进行 $a_{i-1}$ 次操作，将 $a_{i-1},a_i,a_{i+1}$ 变成 $0,(a_i-a_{i-1}),(a_{i+1}+a_{i-1}\times 2)$。

转换完后，我们可以先将 $x$ 和 $y$ 对第一个 $0$ 和第二个 $0$ 各进行一次操作，将序列变成：

$$2,2,(x-2),(y-2)$$

然后我们再将两个 $2$ 对 $y-2$ 进行两次操作，将序列变成：

$$0,0,(x-2),(y+2)$$

所以我们可以在不改变前面两个 $0$ 的情况下，将 $x$ 减去 $2$，并将 $y$ 加上 $2$。

由于我们在 $n=3$ 的情况下已经证明了可以将 $x$ 减去 $3$，并将 $y$ 加上 $3$，所以问题就转化成了每次可以将 $x$ 减去 $2$ 或 $3$，问能不能将 $x$ 减到 $0$。

- 当 $x\bmod2$ 为 $0$ 时，直接进行 $\dfrac{x}{2}$ 次减 $2$ 操作。

- 当 $x\bmod2$ 为 $1$ 时，先进行一次减 $3$ 操作，再进行 $\dfrac{n-3}{2}$ 次减 $2$ 操作。

按照以上的推论，当 $n=4$ 时，是一定能实现的，但如果我们要进行减 $2$ 操作，$x$ 必须要大于等于 $2$，所以需要特殊考虑。

- $x=1,y=1$：将 $x$ 和 $y$ 对另一个 $0$ 进行一次操作即可。

- $x=1,y=2$：$x$ 进行不了操作，并且将 $y$ 进行减 $2$ 操作时 $x$ 会减到负数去，所以这个特例是不能实现的。

- $x=2,y=2$：同 $x=1,y=1$，两次操作即可。

同样的，如果我们要进行减 $3$ 操作，$x$ 必须要大于等于 $3$，也需要特殊考虑。

- $x=1,y=3$：将 $x$ 和 $y$ 对一个 $0$ 进行一次操作，再将得到的 $2$ 和 $y(2)$ 对剩下一个 $0$ 进行两次操作即可。

- $x=2,y=3$：将 $x$ 进行一次减 $2$ 操作即可。

- $x=3,y=3$：同 $x=1,y=1$，进行三次操作。

综上，当原数列**排序后**不为 $0,0,1,2$ 时，就可以实现，否则不行。

## $n>4$：
当 $n>4$ 时，也可以用类似的方法将原数列变为 $0,0,...,0,x,y$ 的形式，然后按照 $n=4$ 时的操作方法进行操作，所以类似的，当原数列排序后不为 $0,0,...,0,1,2$ 时一定可以实现，否则不行。

其实我们没必要排序，只用统计 $0,1,2$ 出现的次数即可。

```cpp
if(n>=4){
	int cnt0=0,cnt1=0,cnt2=0;
	for(int i=1;i<=n;i++){
		if(a[i]==0) cnt0++;
		else if(a[i]==1) cnt1++;
		else if(a[i]==2) cnt2++;
	}
	if(cnt0==n-2 && cnt1==1 && cnt2==1) puts("NO");
	else puts("YES");
}
```

## Code：

```cpp
#include<bits/stdc++.h>
#define maxn 100005
using namespace std;
int n,a[maxn];
int main(){
	int T; scanf("%d",&T);
	while(T--){
		scanf("%d",&n);
		for(int i=1;i<=n;i++) scanf("%d",a+i);
		if(n==1) puts("YES");
		if(n==2){
			if(a[1]==0 || a[2]==0) puts("YES");
			else puts("NO");
		}
		if(n==3){
			sort(a+1,a+n+1);
			a[3]+=a[1]*2; a[2]-=a[1]; a[1]=0;
			if(a[2]%3==0 || a[3]%3==0) puts("YES");
			else if((a[2]%3==1 && a[3]%3==1) || (a[3]%3==1 && a[2]%3==1)) puts("YES");
			else if((a[2]%3==2 && a[3]%3==2) || (a[3]%3==2 && a[2]%3==2)) puts("YES");
			else puts("NO"); 
		}
		if(n>=4){
			int cnt0=0,cnt1=0,cnt2=0;
			for(int i=1;i<=n;i++){
				if(a[i]==0) cnt0++;
				else if(a[i]==1) cnt1++;
				else if(a[i]==2) cnt2++;
			}
			if(cnt0==n-2 && cnt1==1 && cnt2==1) puts("NO");
			else puts("YES");
		}
	}
	getchar(); getchar();
	return 0;
}
```


---

## 作者：快斗游鹿 (赞：3)

一道略微复杂的分类讨论题。

### $n=1$：

显然有解。

### $n=2$：

因为没法进行操作，所以当两数中至少有一个 $0$ 时有解。否则无解。

### $n=3$：

首先对 $a$ 数列进行排序，得到 $a_1,a_2,a_3$。

先考虑将其中一个数变为 $0$。即将 $a_1$ 和 $a_2$ 对 $a_3$ 执行 $a_1$ 次操作。结束后数列变为 $0,a_2-a_1,a_3+a_1\times2$。设 $a_2-a_1=x,a_3+a_1\times2=y$。$x,y$ **可以互换**。

再将 $a_2$ 和 $a_3$ 对 $a_1$ 进行 $1$ 次操作。得到 $2,x-1,y-1$。

再将 $a_1$ 和 $a_2$ 对 $a_3$ 进行 $2$ 次操作。得到 $0,x-3,y+3$。

可以发现，在保持 $a_1$ 为 $0$ 的情况下，$x$ 每次可以减 $3$。

所以只要 $x\bmod3$ 为 $0$ 就一定可以实现。

**总结：当数列变为 $0,a,b$ 的形式时，只要 $a\bmod3=0$ 或 $b\bmod3=0$ 就一定有解。**

如果两数都不能满足条件呢？

那么原数列肯定可以变为 $0,1,k$ 或 $0,2,k$ 的形式。

当数列变为 $0,1,k$ 时：

可以把数列变为 $2,0,k-1$。参考上面的变换方式，可以知道，当 $k-1 \bmod 3$ 等于 $0$ 时，有解。否则无解。

当数列变为 $0,2,k$ 时：

可以把数列变为 $4,0,k-2$。参考上面的变换方式，可以知道，当 $k-2\bmod 3$ 等于 $0$ 时，有解。否则无解。

**总结：当数列变为 $0,a,b$ 的形式时，只要 $a\equiv b\pmod{3}$ ，就一定有解。**

代码：

```
else if(n==3){
		sort(a+1,a+1+n);
		a[3]+=2*a[1];a[2]-=a[1];a[1]=0;
		if(a[2]%3==0||a[3]%3==0)puts("YES");
		else if(a[2]%3==a[3]%3)puts("YES");
		else puts("NO");
	}
```


### $n=4$：

首先对 $a$ 数列进行排序，得到 $a_1,a_2,a_3,a_4$。

考虑先将数列前两个数变为 $0$。

参考 $n=3$ 时的方法，可以很容易地将数列变为 $0,0,x,y$ 的形式。

接着将 $a_3$ 和 $a_4$ 分别对 $a_1$ 和 $a_2$ 进行 $1$ 次操作，数列变为 $2,2,x-2,y-2$。

再将 $a_1$ 和 $a_2$ 对 $a_4$ 进行 $2$ 次操作，数列变为 $0,0,x-2,y+2$。

也就是说在保持 $a_1$ 和 $a_2$ 为 $0$ 的情况下，$x$ 每次可以减 $2$。而根据前面的总结，$x$ 每次还可以减 $3$，相当于减 $2+1$。这么看来，似乎 $n=4$ 时都有解？

然而并不是。如果 $x$ 要减 $2$，则必须保证 $x\ge2$。所以需要简单讨论一下一些特殊情况。根据前面的总结，我们把 $0,x,y$ 单独拎出来。当 $x,y\le3$ 时，**只有 $a\bmod3=0$ 或 $b\bmod3=0$，或者 $a\equiv b\pmod{3}$ 时，才有解。**

显然当 $x=1,y=2$ 时，两个条件都不满足。其余几种组合都至少满足一个条件。

所以当数列为 $0,0,1,2$ 时，无解。否则有解。

### $n>4$：

将 $n=4$ 的情况进行推广。显然也可以将数列变为 $0,0\dots,0,x,y$ 的形式。当 $x=1,y=2$ 时，无解。其他情况有解。

代码：

```
else{
		int aaa=0,bbb=0,ccc=0;
		for(int i=1;i<=n;i++){
			if(a[i]==0)aaa++;
			if(a[i]==1)bbb++;
			if(a[i]==2)ccc++;
		}
		if(aaa!=n-2||bbb!=1||ccc!=1)puts("YES");
		else puts("NO");
	}
```


---

## 作者：隐仞Mrsu (赞：0)

分类讨论题。

# $n=1$

因为仅有一个数，直接满足题目条件，合法。

# $n=2$

因为操作要求选择三个不同的数，而此时仅有两数无法进行，于是，当序列存在零的时候合法，否则非法。

# $n>3$

跳过 $n=3$ 的情况，先来讲讲 $n>3$ 的情况。

先对整个序列**从大到小**进行排序。

这时候，令 $i=n-1,j=n,k=1$，即将 $a_{n-1},a_n$ 减一，$a_1$ 加二，直到 $a_n=0$。然后令 $i=n-2,j=n-1,k=1$，做相同操作，直到整个序列变为 $x,y,0,0,\dots$，即从 $a_3$ 到最后一个元素都等于零。

此时，若 $x=y$ 或 $y=0$，直接合法；否则有 $x>y$，分析三种情况：

### 情况一：$y=2k\ (k=1,2,3,\dots)$

对于序列 $x,2k,0,0,\dots$，令 $i=1,j=2,k=3$，操作 $k$ 次，得到：$x-k,k,2k,0,\dots$。（由之前的操作可知，省略号后的元素都为零，下同）

然后令 $i=1,j=2,k=4$，操作 $k$ 次，得到：$x-2k,0,2k,2k,\dots$。

此时 $a_3=a_4$，只需令 $i=3,j=4,k=1$，操作 $2k$ 次，即可得到 $x+2k,0,0,0,\dots$。

则只要 $y$ 为偶数，就能满足题目条件，合法。

### 情况二：$y=2k+1\ (k=1,2,3,\dots)$

对于序列 $x,2k+1,0,0,\dots$，令 $i=1,j=2,k=3$，操作一次，得到：$x-1,2k,2,0,\dots$。

然后令 $i=2,j=3,k=1$，操作两次，得到：$x+3,2k-2,0,0,\dots$。

此时 $a_2=2k-2$，是偶数，且满足 $a_1=x+3>a_2=2k-2$，就变成了情况一，合法。

### 情况三：$y=1$

当 $x=2$ 时，序列为 $2,1,0,0,\dots$，仅能对 $a_1,a_2$ 进行操作，操作后，序列为 $1,0,2,0,\dots$，与最初的序列等价。因此，$x=2,y=1$ 时，就会落入无法跳出的死循环，非法。

当 $x\ge3$ 时，令 $i=1,j=2,k=3$，操作一次，得到：$x-1,0,2,0,\dots$，等价于 $x-1,2,0,0,\dots$，且满足 $a_1=x-1\ge a_2=2$，就变成了情况一，合法。

**综上，当 $n>3$ 时，先将序列处理为 $x,y,0,0,\dots(x\ge y)$ 的形式。只有出现 $x=2,y=1$ 的情况是非法的，其余都合法。**

# $n=3$

用上种情况的方法，先将序列处理为 $x,y,0(x\ge y)$ 的形式。

在操作限度允许的条件下，做如下操作：
- 令 $i=1,j=2,k=3$，操作 $a$ 次；
- 令 $i=1,j=3,k=2$，操作 $b$ 次；
- 令 $i=2,j=3,k=1$，操作 $c$ 次；

得到：$x-a-b+2c,y-a-c+2b,-b-c+2a$。

我们发现，三个元素中如果有两元素相等，就会合法。因为我们可以对两相等的元素执行减一操作，让另外那个元素加二，当两相等元素操作到零时，就达到了题目条件。

为此，令 $a_1=a_2$，即 $x-a-b+2c=y-a-c+2b$，得到 $x-y=3(b-c)$。则当 $x-y$ 为三的倍数就合法。

令 $a_1=a_3$，即 $x-a-b+2c=-b-c+2a$，得到 $x=3(a-c)$。则当 $x$ 为三的倍数就合法。

令 $a_2=a_3$，即 $y-a-c+2b=-b-c+2a$，得到 $y=3(a-b)$。则当 $y$ 为三的倍数就合法。

因此，满足上述三者之一就合法了，否则非法。

# 代码

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const int N = 1e6+6;
LL n,a[N];
bool cmp(LL x,LL y){
	return x>y;
}
void work(){
	cin>>n;
	for(LL i=1;i<=n;i++){
		cin>>a[i];
	}
	sort(a+1,a+1+n,cmp);
	if(n==1){
		cout<<"YES\n";
		return;
	}
	if(n==2){
		if(!a[2])cout<<"YES\n";
		else cout<<"NO\n";
		return ;
	}
	
	for(LL i=n;i>2;i--){
		a[i-1]-=a[i];
		a[1]+=2*a[i];
		a[i]=0;
	}
	if(a[1]==2&&a[2]==1){
		cout<<"NO\n";
		return; 
	}
	if(n>3){
		cout<<"YES\n";
		return;
	}
	if(a[1]%3==0||a[2]%3==0||(a[1]-a[2])%3==0){
		cout<<"YES\n";
		return;
	}
	cout<<"NO\n";
}
int main(){
	ios::sync_with_stdio(false);
	LL _;
	cin>>_;
	while(_--){
		work();
	}
} 
```


---


# [蓝桥杯 2017 国 A] 区间移位

## 题目描述

数轴上有 $n$ 个闭区间：$D_1, \cdots ,D_n$。

其中区间 $D_i$ 用一对整数 $[a_i,b_i]$ 来描述，满足 $a_i<b_i$。

已知这些区间的长度之和至少有 $10000$。

所以，通过适当的移动这些区间，你总可以使得他们的“并”覆盖 $[0,10000]$ ——也就是说 $[0,10000]$ 这个区间内的每一个点都落于至少一个区间内。

你希望找一个移动方法，使得位移差最大的那个区间的位移量最小。

具体来说，假设你将 $D_i$ 移动到 $[a_i+c_i,b_i+c_i]$ 这个位置。你希望使得 $\max\limits_{i=1}^n\{|c_i|\}$ 最小。

## 说明/提示

**【样例解释】**

样例 1：第一个区间往左移动 $10$；第二个区间往右移动 $20$。

样例 2：第 $2$ 个区间往右移 $0.5$；第 $3$ 个区间往左移 $0.5$ 即可。

**【数据范围】**

对于 $30\%$ 的评测用例，$1 \le n \le 10$；

对于 $100\%$ 的评测用例，$1 \le n \le 10000$，$0 \le a_i<b_i \le 10000$。

## 样例 #1

### 输入

```
2
10 5010
4980 9980```

### 输出

```
20```

## 样例 #2

### 输入

```
4
0 4000
3000 5000
5001 8000
7000 10000```

### 输出

```
0.5```

# 题解

## 作者：SuperChao (赞：12)

# P8660 题解
[题目-P8660 [蓝桥杯 2017 国 A] 区间移位](https://www.luogu.com.cn/problem/P8660) 
## 题意
> 如果你没看懂题：
>
> $[0,10000]$ 的空地上有太阳照射，现摆放有足够的遮阳伞（区间）。
> 
> 你可以位移这些遮阳伞，使得空地都可以被遮住而不被太阳照射到
>
> 需要使**移动最远**的那个遮阳伞**位移的距离最小**

## 主体思路：二分

涉及到**最大值最小**或是**最小值最大**的问题，一般都是通过**二分答案**来解决的。

### 我们简要地证明一下：

如果遮阳伞最大位移是 $x$ 时，都不能遮住所有的空地，那么最大位移比 $x$ 小的情况也不可能遮住所有空地；

如果遮阳伞最大位移是 $x$ 时，可以遮住所有的空地了，那最大位移再大一点的情况（不一定要达到），也可以遮住所有空地。

故答案具有**单调性**，也有**两段性**，可以二分答案。
### 二分板子
```cpp
int binarySearch(){
    int l,r,mid;
    l=0,r=maxr;
    while(l<r){
    	mid=l+(r-l)/2;
        if(check(mid))r=mid;
        else l=mid+1;
    }
    return l;
}
```

这里是整数二分的板子，但是答案会有小数怎么办。

其实很容易想到，当答案出现小数时，要想使得最大值最小，小数部分必须是 $0.5$，因此我们可以将数据都 $\times 2$，最后得到结果时再 $\div 2$ 就好了，这样我们就可以放心地用二分板子了。

## 贪心

接下来的问题就是，`check()` 函数要怎么写。

我们可以用 $t$ 来表示当前情况下，空地被覆盖的最右端（为了方便，我们是从左向右覆盖的）。

于是，我们在每次增加一个区间的时候，使**右端点 $t$ 尽可能地右**，这就是贪心的思路。那么我们该如何实现呢？

分类讨论，一个区间和 $t$ 就有 $3$ 种情况：
### 1.区间左端点 $> t$
![情况1](https://cdn.luogu.com.cn/upload/image_hosting/x6kgfww9.png)

这时候，我们要先判断该区间能否覆盖到点 $t$。

如果能在满足最大位移为 $x$ 的情况下覆盖到点 $t$，那我们就将**区间左端点移至 $t$**，并更新 $t$。

如果不能，我们就**不管它**（记住这句话，后面要考）。
### 2.区间左端点 $ =t$
![情况2](https://cdn.luogu.com.cn/upload/image_hosting/gyuhni83.png)

这种情况非常简单，我们直接**更新 $t$ 为区间右端点**即可。
### 3.区间左端点 $< t$ 
![情况3](https://cdn.luogu.com.cn/upload/image_hosting/msk1o938.png)

对于这种情况，如果想要把右端点尽可能地右，就得让区间位移尽可能地大。

但是这个大也有限度：**不超过最大位移 $x$** 和**区间左端点不超过 $t$**。

> 注意：如果区间右移后右端点仍未超过 $t$，那我们也不会采用它。代码中用 $\max()$ 实现。

---
那我们就可以开始愉快地写代码 $\cdots\cdots$ 了？

**并不！**

现在又有新的问题：**如何排列所有区间？**
## 排列区间

## 方案 1：按左端点排序
也许你会觉得左端点靠左的就先判断，~~其实一开始我也是这么想的~~

看一组数据：

**输入**

```
4
0 10
12 14
11 20
21 10000
```
这里我们当然是选择把区间 $[12,14]$ 向左位移 $2$ 个单位，把区间 $[11,20]$ 向右位移 $1$ 个单位，最小值是 $2$。

如果按照左端点排序，就会先把区间 $[11,20]$  向左位移 $1$ 个单位，再把区间 $[12,14]$ 向右位移 $7$ 个单位，最小值是 $7$，**出错了**。

## 方案 2：按右端点排序

所以**正解是按右端点排序**。

可能有人 ~~其实还是我~~ 会想到 hack 数据，那我顺便也讲一下为什么按右端点排序可以解决刚刚按左端点排序出现的问题。

**输入**
```
4 
0 10
17 19
11 20
21 10000
```
看到这个数据第一眼，如果按右端点排序，会先处理区间 $[17,19]$，然而最优解应该是先把 $[11,20]$ 左移 $1$ 个单位，把 $[17,19]$ 右移 $2$ 个单位，难道这是 hack？

当最大位移 $x=7$ 时，会先考虑区间 $[17,19]$，此时可行，进行二分。

二分之后 $x=3.5$（为了方便采用小数表示，实际程序中会按前文操作处理），这时，虽然区间  $[17,19]$ 排序靠前，但我们不会考虑它，因为**这个区间在最大位移为 $3.5$ 时不能覆盖到 $t$**（值为 $10$），即这个区间不满足**能连续接上已覆盖的最右端**这个条件。

因此我们会跳过它，直接考虑区间 $[11,20]$，此时又可行，还会继续二分！这也就是**按右端点排序优于按左端点排序**的原因！

## 愉快写代码

铺垫了这么多，终于到代码实现了，~~太爽了~~！

注意一些代码实现细节

* 用结构体存储区间，再自定义排序
* 采用 `vector` 数组存储**没有开发过**的区间，当然开个 $vis[maxn]$ 来表示是否处理过也可以，本人喜欢 STL，~~主要是懒~~

```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxn 10010
int n;
//存储区间:
struct st{
    int l,r;
};
vector<st> D;
//优先按右端点排序: 
bool cmp(st x,st y){
    if(x.r!=y.r)return x.r<y.r;
    else return x.l<y.l;
}
//验证答案:
bool check(int x){
    int t=0;
    vector<st> d(D);//复制一份用以删除用过的区间
    while(true){
    	bool flag=0;//找没找到
    	for(int i=0;i<d.size();i++){
    		if(d[i].l>t){//需要把区间左移
    			if(d[i].l-x<=t){//可以左移 
    				flag=1;
    				t+=d[i].r-d[i].l;
    				d.erase(d.begin()+i);//删除
                    i--;//删除后i要退1
					break; 
				}
			}else if(d[i].l==t){//区间左端点刚好是t点
				flag=1;
				t=d[i].r;
				d.erase(d.begin()+i);
                i--;
				break;
			}else{//区间已覆盖t点 
				flag=1;
				t=max(t,d[i].r+min(x,t-d[i].l));//让更新后的t点尽可能地右(但是受到最大位移和覆盖到点t的限制)
				d.erase(d.begin()+i);
                i--;
				break;
			}
		}
		if(flag==0||d.empty())break;//没找到或者找完了就跳出 
	}
	return t>=20000;
}
//二分板子 
int binarySearch(){
    int l,r,mid;
    l=0,r=2*maxn;
    while(l<r){
        mid=l+(r-l)/2;
        if(check(mid))r=mid;
        else l=mid+1;
    }
    return l;
}
int main(){
    ios::sync_with_stdio(0);cin.tie(0);
    cin>>n;
    for(int i=1,dl,dr;i<=n;i++){
    	cin>>dl>>dr;
    	D.push_back({2*dl,2*dr});//小数优化 
	}
    sort(D.begin(),D.end(),cmp);
    cout<<binarySearch()/2.0;//前面小数优化，这里记得除回去 
}
```

[愉快地 AC 了](https://www.luogu.com.cn/record/122429434)

---
**感谢观看！！！**

---

## 作者：Filberte (赞：6)

# P8660 题解

看另一篇题解写了模拟退火，但是本蒟蒻并不会，这里介绍二分加贪心的思路。

观察一下可以发现，小数部分最多只能有一位，且就算有也肯定是 $5$。所以我们把所有线段的坐标都翻一倍，最后要求覆盖 $[0,20000]$。此时我们能使得所有线段的端点都在整点上。

看到要让最大值最小，不难想到二分答案。现在的难点在于如何检验一个答案是否可行。

假设目前需检验答案 $x$ 是否可行。引入一个整数 $A$，其中 $[0,A)$ 这个区间内所有点都已经被覆盖，我们现在要覆盖整点 $A$。初始化  $A = 0$，表示我们一个点都还没有覆盖。

## 贪心算法

在移动小于等于 $x$ 的距离后能够覆盖到 $A$ 这个点的线段中，找到一个右端点最小的；同时让它在能覆盖 $A$，且移动距离不超过 $x$ 的情况下，尽量往右边放。

具体点，如果这个线段在 $A$ 右侧，那么把它移到左端点刚好碰到 $A$ 就行。如果这个线段已经覆盖 $A$ 或在 $A$ 左侧，就把他尽量往右移，直到它的左端点碰到 $A$ 或者距离用完了。

## 贪心证明

后半句话显然，我都用这个线段覆盖点 $A$ 了，我能把它往右移，多覆盖一些点，肯定不会比当前更差。

用调整法来证明前半句话的正确性。（后文加 $'$ 一般表示这个线段已经尽量往右移了）

假设在 $k$ 满足题意时，按照贪心得到了一个解，在这之中，我们会使用线段 $D_1$ 覆盖点 $A$；而有一个最优解 $S$，它使用 $D_2$ 来覆盖点 $A$，同时它在尽量往右放时，右端点是 $B$。

可以转化为证明：当 $x$ 可行时，一定有一个解它用 $D_1$ 来覆盖 $A$ 点。

**情况一**：如图，$D_1$ 的移动范围不包含 $B$。

![](https://cdn.luogu.com.cn/upload/image_hosting/4io98lbp.png)

$D_1$ 到不了 $B$，就更到不了 $B$ 右边（图中红色部分）。所以解 $S$ 中有没有 $D_1$ 是一个样的，用剩下 $n - 1$ 条线段就能满足题目条件了。可以进行调整：$S$ 中其他线段不动，把 $D_1$ 随便移动到一个盟覆盖 $A$ 的位置即可。

**情况2**：如图（先看左边），$D_1$ 的移动范围包含 $B$。且在把其尽量往右放时，它可以覆盖到 $C$ 点。

![](https://cdn.luogu.com.cn/upload/image_hosting/t2unaa51.png)

我们要证明，肯定能通过调整，使得 $D_1$ 覆盖点 $A$ ，且 $D_1$ 和 $D_2$ 的并可以覆盖 $AC$。

1.$D_1$ 在覆盖 $C$ 的同时还能覆盖 $A$，那你就覆盖呗，有啥好调整的。已经得证。

2.$D_1$ 在覆盖 $C$ 的同时不能覆盖 $A$，也就是说  $D_1$ 的左端点在 $A$ 的右侧。

先来证明 $D_1$ 能够跟 $A$ 点左对齐。 $D_1$ 又能覆盖 $A$（左端点小于等于 $A$），它的左端点又能移动到 $A$ 点右侧，所以它肯定可以跟 $A$ 左对齐。

再来证明 $D_2$ 能够跟 $C$ 点右对齐。$D_2$ 的右端点在 $C$ 点左边（不然就变成情况一了）。根据我们的假设 ，$D_1$ 和 $D_2$ 都能覆盖  $A$，而 $D_1$ 是所有能覆盖 $A$ 的线段里右端点最小的，所以 $D_1$ 的右端点比 $D_2$ 的右端点要更靠左。就连 $D_1$ 都能覆盖点 $C$ 了， $D_2$ 当然也可以，所以可以说明 $D_2$ 的右端点可以在 $C$ 右边。因此 $D_2$ 可以跟 $C$ 点左对齐。

有了上述两个条件，我们再看图左边。由图可知，$|D_1| + |D_2| \ge |AC|$。所以我们只要把 $D_1$ 左端点跟 $A$ 点对齐，把 $D_2$ 左端点跟 $C$ 点对齐，那么就能完整覆盖 $AC$，同时 $D_1$ 覆盖 $A$。（就像图右边一样）

所以那么原问题有解时，一定有一个解，它用 $D_1$ 来覆盖点 $A$。也就是说，我们的贪心算法是正确的。



## 实现

对于一个需检查的 $x$，我们使用堆，来维护所有能够覆盖当前的 $A$ 的，还没使用过的线段中右端点最靠右的，用了一个就把它从堆里踢出去。我们对于所有线段 $[l_i,r_i]$ 。当 $A$ 到达 $l_i - x$ 时，此线段可使用，加入堆中。每次从堆中取出堆顶元素时，检查一下是否满足 $r_i + x \ge A$，满足就用它覆盖 $A$，然后 $A$ 往右移，同时激活新线段；否则重复取出，直到有一条满足条件的线段。若当中找不到了，就判断无解。

注意刚开始时， $A = 0$，要把所有 $r_i - x\le0$ 的线段先加进来，再开始。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 10050;
int n;
struct Seg{
	int l , r;
	friend bool operator < (Seg x , Seg y){
		return x.r > y.r;
	}
}a[N];
bool cmp(Seg x , Seg y){
	return x.l < y.l;
}
bool ck(int x){
	int i = 1 , A = 0;
	priority_queue <Seg> q;
	while(1){
		if(i > n) break;
		if(a[i].l - x <= A){
			q.push(a[i]);
			i++;
		}
		else break;
	}
	while(A < 20000){
		Seg now;
		while(1){
			if(q.empty()) return 0;
			now = q.top();
			q.pop(); 
			if(now.r + x >= A || now.l - x <= A) break;
		}
		if(now.l >= A) A = A + now.r - now.l;
		else A = min(A + now.r - now.l , now.r + x);
		while(1){
			if(i > n) break;
			if(a[i].l - x <= A){
				q.push(a[i]);
				i++;
			}
			else break;
		}
	}
	return A >= 20000;
}
int main(){
	scanf("%d",&n);
	for(int i = 1;i <= n;i++) scanf("%d%d",&a[i].l,&a[i].r);
	for(int i = 1;i <= n;i++) a[i].l <<= 1 , a[i].r <<= 1;
	sort(a + 1 , a + 1 + n , cmp); 
	int L = 0 , R = 20000;
	while(L < R){
		int mid = (L + R) >> 1;
		if(ck(mid)) R = mid;	
		else L = mid + 1;
	//	cout << L << " " << R<< endl;
	} 
	printf("%d%s\n",L >> 1, (L & 1) ? ".5" : "");
	return 0;
}
```


---

## 作者：ZKqwq (赞：0)

#### 题目大意

有 $n$ 个线段，已知它们的长度之和多于 $10000$，现在要将它们沿着数轴向左或向右平移，使得所有线段拼成出一个长度为 $10000$ 的区间，问最小化从原来位置到新位置所需平移距离的绝对值的最大值是多少。

#### 分析

考虑模拟退火，我们应该如何设计状态呢？

显然，每一个状态应该由 $n$ 个数表示。设当前轮廓线在 $x$ 处，则当前状态下第 $i$ 条线段的左端点应该在 $L_{i}- x $ 的位置上。其中，$L_i$ 表示线段 $i$ 的左端点（同理可以确定右端点的位置），这里证明一下为什么只需要考虑线段的左端点就足够了。

由于线段 $\left [ l,r \right ] $ 的长度不变，因此为了满足条件，我们必须强制缩短右端点，再让左端点向左边“读一些字”。假设当前轮廓线位于过线段 $i$ 的左端点 $L_i$ 和右端点 $R_i$ 的中间。显然线段 $i$ 可以停留不动。更进一步，对于位于 $i$ 之左的所有线段 $\left [ l,r \right ] $，它们不会被拖出轮廓线之外。反方向，对于位于 $i$ 之右的所有线段，在退火之前，它们的右端点都落在 $\left [ 0,R_i \right ) $     的区间之内。移动之后，它们的右端点将落在  $\left [ 0+d,R_i+d \right ) $ 的区间内。对任何一个右端点在 $R_i$ 右侧且向左移动了超过 $d$ 的线段 $j$，不难发现 $L_j+d< L_i\le R_j$。然而通过推理可知使 $\left | c_i \right | $ 最大的状态，必定满足 $L_i = R_j$ 或者 $L_j=R_i$。

由此，我们可以得到设定状态的方法：每个状态下第 $i$ 条线段的左端点应该在 $L_i-x$ 的位置上。其中，$L_i$ 表示线段 $i$ 的左端点。

然后就可以编写模拟退火算法来解题了。

---


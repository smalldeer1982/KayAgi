# [SNCPC2024] 表达式矩阵

## 题目描述

一个 $n \times m$ 的字符矩阵 $a_{ij}$，被称为合法的表达式矩阵，当且仅当其满足如下条件：


- 矩阵只包含 '1'，'+'，'*' 字符。

- 对于矩阵的每行从左向右组成的字符串，均为合法的表达式。

- 对于矩阵的每列从上向下组成的字符串，均为合法的表达式。


一个合法的表达式矩阵的权值定义为，每行从左向右组成的字符串和每列从上向下组成的字符串共 $n + m$ 个表达式求值后的值求和的结果。

求所有 $n \times m$ 的合法表达式矩阵中，权值最小的那一个。如果有多个最小的答案，你可以给出任意一个。

我们定义字符串 $s$ 是合法表达式如下：



- 如果 $s = \overbrace{111\dots111}^{\text{至少一个 }1}$，则 $s$ 是合法表达式。

- 如果 $s$ 和 $t$ 均为合法表达式，则 $s$ * $t$ 也是合法表达式。

- 如果 $s$ 和 $t$ 均为合法表达式，则 $s$ + $t$ 也是合法表达式。

## 说明/提示


对于样例，此时矩阵的权值为 $4488$，可以证明不存在权值更小的矩阵。

## 样例 #1

### 输入

```
4 4
```

### 输出

```
1111
1*11
11*1
1111
```

# 题解

## 作者：Charlie_ljk (赞：7)

# 思路

考虑每一行（列），最多存在两个 $11$，其余均为 $1$，对于两个 $11$，不可让其相乘，故此每一行（列）中若有两个 $11$，则必须有一个加号。

根据此考虑打表即可，从贪心的思路，满足上述条件的同时使加号尽可能的少，因为 $x\times 1\le x+1$。

# 打表

为防止影响阅读，所打出的表放在剪切板内。

- [打表](https://www.luogu.com.cn/paste/kdgrnt0y)。

# 代码如下

```cpp
#include <bits/stdc++.h>
using namespace std;

signed main() {
    string b[100][100];
b[3][3]="1111*1111";
b[3][4]="11111*111111";
b[3][5]="111111*1*111111";
b[3][6]="1111111*1*11111111";
b[3][7]="11111111*1*1*11111111";
b[3][8]="111111111*1*1*1111111111";
b[3][9]="1111111111*1*1*1*1111111111";
b[4][3]="1111111*1111",
b[4][4]="11111*1111*11111";
b[4][5]="111111*1*111+1111111";
b[4][6]="11111111*1*11*1*11111111";
b[4][7]="11111111*1*1*111+1*111111111";
b[4][8]="111111111*1*1*1111*1*1*111111111";
b[4][9]="1111111111*1*1*1*111*1*1+11111111111";
b[5][3]="1111*11111*1111",
b[5][4]="11111*1111+11*111111",
b[5][5]="111111*1*111+111*1*111111";
b[5][6]="1111111*1*1111+1+11*1*11111111";
b[5][7]="11111111*1*1*111+1+111*1*1*11111111";
b[5][8]="111111111*1*1*1111+1+1+11*1*1*1111111111";
b[5][9]="1111111111*1*1*1*111+1+1+111*1*1*1*1111111111";
b[6][3]="1111111*11111*1111",
b[6][4]="11111*1111*11*1111*11111",
b[6][5]="1111111+111*1*111+111*1*111111",
b[6][6]="1111111*1*1111*1*11*1*1111*1*1111111";
b[6][7]="11111111*1*1*111+1*111*1*1*111+1*111111111";
b[6][8]="111111111*1*1*1111*1*1*11*1*1*1111*1*1*111111111";
b[6][9]="1111111111*1*1*1*111*1*1+111*1*1*1*111+1*1*11111111111";
b[7][3]="1111*11111*11111*1111",
b[7][4]="11111*1111*11*1111+11*111111",
b[7][5]="111111*1*111+111*1*111+111*1*111111",
b[7][6]="1111111*1*1111*1*11*1*1111+1+11*1*11111111",
b[7][7]="11111111*1*1*111+1*111*1*1*111*1+111*1*1*11111111";
b[7][8]="111111111*1*1*1111+1*1+11*1*1*1111*1+1*11*1*1*1111111111";
b[7][9]="1111111111*1*1*1*111*1*1+111*1*1*1*111+1+1*111*1*1*1*1111111111";
b[8][3]="1111111*11111*11111*1111";
b[8][4]="111111*11*1111*11*1111*11*111111",
b[8][5]="1111111+111*1*111+111*1*111+111*1*111111",
b[8][6]="11111111*1*11*1*1111*1*11*1*1111*1*11*1*11111111",
b[8][7]="111111111+1*111*1*1*111*1+111*1*1*111+1*111*1*1*11111111",
b[8][8]="111111111*1*1*1111*1*1*11*1*1*1111*1*1*11*1*1*1111*1*1*111111111";
b[8][9]="1111111111*1*1*1*111+1*1*111*1*1*1*111+1*1*111*1*1*1*111*1*1+11111111111";
b[9][3]="1111*11111*11111*11111*1111";
b[9][4]="11111*1111+11*1111*11*1111*11*111111",
b[9][5]="111111*1*111+111*1*111+111*1*111+111*1*111111",
b[9][6]="1111111*1*1111+1*11*1*1111*1*11*1*1111*1+11*1*11111111",
b[9][7]="11111111*1*1*111+1*111*1*1*111*1+111*1*1*111*1+111*1*1*11111111",
b[9][8]="111111111*1*1*1111*1*1+11*1*1*1111*1*1*11*1*1*1111+1+1*11*1*1*1111111111",
b[9][9]="1111111111*1*1*1*111+1*1*111*1*1*1*111*1+1*111*1*1*1*111*1*1+111*1*1*1*1111111111";
    
    cin.tie(0) -> sync_with_stdio(false);
    int n, m; cin >> n >> m;
        string s = b[n][m]; s = ' ' + s;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++)
                cout << s[(i - 1) * m + j];
            cout << '\n';
        }
    return 0;
}
```

---

## 作者：FFTotoro (赞：3)

考虑朴素暴力，显然不能有符号相邻或者在边界上。暴力搜小数据答案，发现如果一个位置 $(i,j)$ 满足 $i+j\equiv 0\pmod 2$，那么这个位置要放符号，否则要放数字。于是可以据此直接打表。

但是这样太不优雅了。直接将这些位置先全部填上 `*`，发现答案不一定最优。考虑把若干个 `*` 替换成 `+`，对照打出来的表发现这样的 `+` 不超过 $6$ 个，根据第一段提出的方法，`*` 的个数不超过 $24$ 个；于是直接暴力枚举哪些 `*` 要变成 `+`，时间复杂度取决于实现。

放代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int g(int x){
  int c=0;
  while(x--)c=(c<<1)+(c<<3)|1;
  return c;
}
inline int f0(string s){
  vector<int> t;
  for(int i=0,l=0;i<=s.length();i++)
    if(i==s.length()||s[i]=='*')
      t.emplace_back(i-l),l=i+1;
  int c=1;
  for(int i:t)c*=g(i);
  return c;
} // 计算仅含 * 的表达式的值
inline int f1(string s){
  vector<string> t;
  for(int i=0,l=0;i<=s.length();i++)
    if(i==s.length()||s[i]=='+')
      t.emplace_back(s.substr(l,i-l)),l=i+1;
  int c=0;
  for(auto i:t)c+=f0(i);
  return c;
} // 计算表达式的值
inline int f2(vector<string> a){
  int c=0;
  for(int i=0;i<a.size();i++)
    c+=f1(a[i]);
  for(int i=0;i<a[0].size();i++){
    string s;
    for(int j=0;j<a.size();j++)
      s+=a[j][i];
    c+=f1(s);
  }
  return c;
} // 计算一个矩阵的答案
main(){
  ios::sync_with_stdio(false);
  int n,m,r=6e18; cin>>n>>m;
  vector<string> a(n,string(m,49)),w;
  vector<pair<int,int> > p;
  for(int i=1;i<n-1;i++)
    for(int j=1;j<m-1;j++)
      if(!(i+j&1))a[i][j]='*',p.emplace_back(i,j);
  for(int i=0;i<1<<p.size();i++)
    if(__builtin_popcount(i)<6){
      auto b=a;
      for(int j=0;j<p.size();j++)
        if(i>>j&1)b[p[j].first][p[j].second]='+';
      if(int x=f2(b);x<r)r=x,w=b;
    } // 暴力枚举
  for(auto i:w)cout<<i<<'\n';
  return 0;
}
```

---

## 作者：luogu_gza (赞：3)

这里我要感谢我们队的 @shinzanmono，是他最终过掉了这道题。

首先我们观察一些小的数据，这是暴力跑出来的结果。

其次，因为转置，所以我们仅考虑 $n \leq m$ 的结果。

再次，观察到数字全填 1 最好，符号不能放边界，符号不能相邻（这也是暴力剪枝的关键）。

```
3 3:
111
1*1
111

3 4:
1111
1*11
1111

3 5:
11111
1*1*1
11111
```

可以发现在 $n=3$ 的时候，第二行的偶数位是 `*`。

再观察：

```
4 4:
1111
1*11
11*1
1111
```

我们发现当 $i+j$ 为偶数且 $(i,j)$ 不在边界上时，应该填乘号（？)。

再观察：

```
4 5:
11111
1*1*1
11+11
11111
```

怎么出现了加号！但是我们发现这仅仅是将一些乘号替换成了加号而已。

因此暴力的关键点就是，先把乘号都变出来，再枚举哪些乘号变成了加号即可。

~~我不会告诉你我们赛时是靠 szm 的纯暴力 + 16核 跑的。~~

打表即可，复杂度是 $O(2^{\frac{(n-1)(m-1)}{2}}\times nm)$。

**还能再给力一点吗？**

发现加号的替换只会替换掉一整行或者一整列（我不知道有没有这样的情况），所以只要枚举哪些哪些行和那些列被翻转了即可。这样的话复杂度是 $O(2^{n+m}\times nm)$，甚至可以直接提交。

---

## 作者：Y_zhao111 (赞：2)

### Description
题目传送门：[P10692 [SNCPC2024] 表达式矩阵](/problem/P10692)。

构造一个 $n \times m$ 的矩阵，其中每个位置要么是 $1$，要么是 $\tt +$ 或者 $\tt ∗$，使得在满足每一行每一列均为一个合法表达式的前提下，最小化每一行、每一列表达式的值之和。

### Analysis（转自官方题解）
+ 对于行列大小均为偶数的情况，以 $6\times 8$ 为例答案形如:
![](https://cdn.zhaohonghao-qwq.com/img/image.2krspnku4c.webp)

注意到每行 $/$ 每列恰有一个 $11$。由于无法构造出只含 $1$ 的解，显然使用乘号连接 $11$ 和 $1$ 是最优的。

+ 对于列大小为奇数的情况，以 $6 × 9$ 为例如：

![](https://cdn.zhaohonghao-qwq.com/img/image.wifsgkyuy.webp)

所有包含两个 $11$ 的行都必须使用一个 $+$，否则会产生 $11 \times 11$ 的结果，这是我们不能接受的。

同时，除此之外每多使用一个 $+$，都会使答案增加，所以只需要在这些行中选恰好一个运算符改为 $+$ 即可。

行大小为奇数的情况类似。

+ 对于行列大小均为奇数的情况，以 $7 × 9$ 为例：
![](https://cdn.zhaohonghao-qwq.com/img/image.1e8hh1qpt8.webp)

所有包含两个 $11$ 的行都必须使用一个 $+$，所有包含两个 $11$ 的列都必须使用一个 $+$。

如图所示，观察位于交点的六个运算符，需要保证每行都有一个 $+$，每列都有一个 $+$。可以考虑斜着分配。

通过搜索和合理的剪枝，能在可接受的时间内算出答案。

考虑答案空间只有 $9 × 9$，可以搜出所有的答案硬编写在代码中。

---

## 作者：ma_niu_bi (赞：1)

### P10692 [SNCPC2024] 表达式矩阵 题解

提供一种不是打表的思路。

通过观察样例和模拟几组数据，可以发现先放乘号，再把部分乘号改成加号。

乘号的放置方式如下：

```
11111
1*1*1
11*11
1*1*1
11111
```

可以发现行数加列数为偶数，且不在边界上时可以放置乘号。

现在考虑将哪些乘号改成加号。

当出现两个十一相乘时，我们会把这个乘号改成加号。

根据这个思路，我们可以枚举每一个乘号，对左右两边的表达式求值，如果两边都等于十一，就改为加号。

对每行每列都做一遍。

注意到有的乘号改成加号可以同时消除一行和一列的十一，如上面例子的正中间。

我们可以先改这些乘号，再改其他的，这样可以保证加号最少。

时间复杂度：$O(n^2m^2)$

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int get_res(string s) { //表达式求值
    stack <int> S;
    int num = 0;
    char l = '+';
    s += '+';
    for (auto c : s) {
        if (isdigit(c)) num = num * 10 + c - 48;
        else {
            if (l == '+') S.push(num);
            else {
                num *= S.top();
                S.pop(); S.push(num);
            }
            num = 0, l = c;
        }
    }
    num = 0;
    while (S.size()) {
        num += S.top();
        S.pop();
    }
    return num;
}
int n, m;
string s[11];
signed main() {
    cin >> n >> m;
    for (int i = 0; i < n; i ++) 
        for (int j = 0; j < m; j ++) s[i] += "1";
    for (int i = 0; i < n; i ++) 
        for (int j = 0; j < m; j ++) 
            if ((i + j) % 2 == 0 && i != 0 && i != n - 1 && j != 0 && j != m - 1)
                s[i][j] = '*';
    for (int i = 0; i < n; i ++)
        for (int j = 0; j < m; j ++) {
            if (s[i][j] != '*') continue; // 枚举能改一行一列的
            string S1 = "", S2 = "";
            for (int k = 0; k < i; k ++) S1 += s[k][j];
            for (int k = i + 1; k < n; k ++) S2 += s[k][j];
            if (get_res(s[i].substr(0, j)) == 11
            && get_res(s[i].substr(j + 1)) == 11
            && get_res(S1) == 11
            && get_res(S2) == 11) s[i][j] = '+';
        }
    for (int i = 0; i < n; i ++)
        for (int j = 0; j < m; j ++) {
            if (s[i][j] != '*') continue;
            if (get_res(s[i].substr(0, j)) == 11
            && get_res(s[i].substr(j + 1)) == 11) s[i][j] = '+';
        }
    for (int j = 0; j < m; j ++) {
        for (int i = 0; i < n; i ++) { 
            if (s[i][j] != '*') continue;
            string S1 = "", S2 = "";
            for (int k = 0; k < i; k ++) S1 += s[k][j];
            for (int k = i + 1; k < n; k ++) S2 += s[k][j];
            if (get_res(S1) == 11 && get_res(S2) == 11) s[i][j] = '+';
        }
    }
    for (int i = 0; i < n; i ++) cout << s[i] << endl;
    return 0;
}
```

---

## 作者：xxseven (赞：0)

大家好，我不喜欢打表，所以我搜索过了这道题。时间有点极限，$n,m=9$ 的测试点跑了 796ms，但还是可以过的。  
~~另外现有的题解貌似也没有打表用的程序~~

最朴素的算法莫过于直接枚举每个位置填的东西然后做表达式求值，但这样复杂度肯定上天，必定要优化。

首先，最外围的一圈肯定都是 $1$，否则无法成为合法的表达式。  
其次，两个运算符不能相邻，否则也无法成为合法表达式。  

加上这两个剪枝之后，可以在时限内跑出 $n,m\le 6$ 的答案了，我们继续优化。

对于中间的未确定区域，我们从上到下，从左到右依次考虑。感性理解一下，如果一个位置可以填运算符，那么填运算符一定不劣，因为填 $1$ 必然会造出连着的 $11$，总和至少会多出 $10$，同时还有可能导致后面为了规避 $11\times 11$ 填加号再增加总和。

那么我们可以确定下来所有运算符和数字的位置。接下来就只剩下运算符填 $+$ 还是 $*$ 的问题了。我们可以先全部填上乘号，之后枚举变为加号的运算符。

因为即使在 $n,m=9$ 的情况下也只会出现 $25$ 个运算符，我们可以直接枚举每个运算符。

到这里复杂度~~因为我写的玄学求值~~可能还差一点，我自己到这里是 $20$s 左右出解，因此还要再加一个剪枝。  
排除掉最外层的一圈 $1$，在 $(2,2)$ 等四个角上的运算符填乘号必然优于加号，因为它们运算的两个数其中必定有一个是外圈的单个 $1$，而 $1 \times n \lt 1+n$。

这样在 $n,m=9$ 这组数据下我们就成功少枚举了 $4$ 个位置，在其他数据下也至少能少枚举 $2$ 个位置，~~再加上洛谷神机~~足够卡进时限了。

下面是代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[15][15],ans[15][15],minn=2e9,cnt;
int calc(int x,int l,int r){
	for(int i=l;i<=r;++i){
		if(a[x][i]==2) 
			return calc(x,l,i-1)+calc(x,i+1,r);
	}
	int now=0,res=1;
	for(int i=l;i<=r;++i){
		if(a[x][i]==1) now=now*10+1;
		else res*=now,now=0;
	}
	return res*now;
}

int calc2(int x,int l,int r){
	for(int i=l;i<=r;++i){
		if(a[i][x]==2) 
			return calc2(x,l,i-1)+calc2(x,i+1,r);
	}
	int now=0,res=1;
	for(int i=l;i<=r;++i){
		if(a[i][x]==1) now=now*10+1;
		else res*=now,now=0;
	}
	return res*now;
}
//上面是偷懒写的递归表达式求值，或许能优化掉？
void dfs(int x,int y,int lv){
	if(lv==cnt){ //已经更改了所有运算符
		int now=0; 
		for(int i=1;i<=n;++i){
			now+=calc(i,1,m);
		}
		for(int i=1;i<=m;++i){
			now+=calc2(i,1,n);
		}
		if(now<minn){
			minn=now;
			for(int i=1;i<=n;++i){
				for(int j=1;j<=m;++j){
					ans[i][j]=a[i][j];
				}
			}
		}
		return;
	}
	if(y>=m){
		dfs(x+1,2+((x+1)&1),lv); return;//这么写可能有点丑，但作用就是跳到下一个运算符
	}
	dfs(x,y+2,lv+1);
	if(x==2&&y==2||x==2&&y==m-1||x==n-1&&y==2||x==n-1&&y==m-1) return; //特判四角，也就是上文的最后一个剪枝
	a[x][y]=2;
	dfs(x,y+2,lv+1);
	a[x][y]=3;
}

int main(){
	cin>>n>>m;
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			if(i==1||j==1||i==n||j==m||(i+j)&1==1)
				a[i][j]=1;
			else a[i][j]=3,cnt++;
  			//能填运算符的地方先填上乘号，否则填上1
		}
	} 
	dfs(2,2,0);
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			if(ans[i][j]==1) cout<<1;
			if(ans[i][j]==2) cout<<'+';
			if(ans[i][j]==3) cout<<'*';
		}
		cout<<'\n';
	}
	return 0;
}

```

---

## 作者：_LiWenX_ (赞：0)

刚看这个题的时候感觉根本不可做，然后发现了数据范围比较小而且也找到了一些性质，于是想到了打表，然后就过了这个题。

首先这个矩阵最外面肯定都是 $1$，然后你会希望运算符尽可能的多，这是因为对于一个表达式 $x?y$，若 $?$ 为数字串起 $x,y$ 必然比乘法和加法更劣。能达到这个目的的构造只有一种：将这个网格黑白相邻染色，黑点全部放运算符，其他地方放 $1$。

然后现在你需要爆搜枚举的位置只有 $\dfrac{(n-2)\times(m-2)}{2}$ 个了，也就是说最大只有 $2^{25}$ 个状态要搜，然后写了一下，发现 $n=9,m=9$ 跑了两分钟都没跑完（纯粹是我笔记本太垃圾了），此时我有点红温。打开我打出来的表，发现了一个结论：最有情况下第二列不肯能有加号，把这个结论加到爆搜里面，然后一下就跑完了，把表打上去直接过了。

这里展示一下赛时写的 maker 程序。

```cpp
#include<bits/stdc++.h>
using namespace std;
char ch[10][10],ans[10][10];
int minn=1e9;
bool vis[10][10];
int n,m;
int sta[1001],top;
int suan(string s){
	s+='+';
	int num=0;top=0;
	for(int i=0;i<s.size();i++){
		if(s[i]=='1'){
			num=num*10+1;
			continue;
		}
		if(s[i]=='*'){
			if(sta[top]==-2){
				top--;
				sta[top]*=num;
			}
			else sta[++top]=num;
			sta[++top]=-2;
		}
		else{
			if(sta[top]==-2){
				top--;
				sta[top]*=num;
			}
			else sta[++top]=num;
			sta[++top]=-1;
		}
		num=0;
	}
	for(int i=1;i<=top;i++) if(sta[i]>0)num+=sta[i];
	return num;
}
int cnt=0;
void dfs(int x,int y){
	if(x>n){
		cnt++;
		if(cnt%10000==0){
			cerr<<cnt<<'\n';
		}
		int sum=0;
		for(int i=2;i<n;i++){
			string s;
			for(int j=1;j<=m;j++){
				s+=ch[i][j];
			}
			sum+=suan(s);
			if(sum>=minn) return ; 
		}
		for(int j=2;j<m;j++){
			string s;
			for(int i=1;i<=n;i++){
				s+=ch[i][j];
			}
			sum+=suan(s);
			if(sum>=minn) return ;
		}
		if(sum<minn){
			minn=sum;
			for(int i=1;i<=n;i++){
				for(int j=1;j<=m;j++){
					ans[i][j]=ch[i][j];
				}
			}
		}
		return ;
	}
	if(y>m){
		dfs(x+1,1);
		return ;
	}
	if(!vis[x][y]){
		dfs(x,y+1);
		return ;
	}
	ch[x][y]='*';
	dfs(x,y+1);
	if(x<=2||y<=2) return ;
	ch[x][y]='+';
	dfs(x,y+1);
}
int main(){
	freopen("_.in","w",stdout);
	for(n=3;n<=9;n++){
		for(m=n;m<=9;m++){
			memset(vis,0,sizeof(vis));
			for(int i=1;i<=n;i++){
				for(int j=1;j<=m;j++){
					if(i==1||j==1||i==n||j==m){
						ch[i][j]='1';continue;
						vis[i][j]=0;
					}
					if((i+j)&1) ch[i][j]='1',vis[i][j]=0;
					else vis[i][j]=1;
				}
			}
			minn=1e9;
			dfs(1,1);
			for(int i=1;i<=n;i++){
				for(int j=1;j<=m;j++){
					printf("a[%d][%d][%d][%d]='%c';\n",n,m,i,j,ans[i][j]);
				}
			}
			cerr<<n<<' '<<m<<'\n';
		}
	}
}
/*
LiuFaFaOnO
24+10+5
*/
```

---


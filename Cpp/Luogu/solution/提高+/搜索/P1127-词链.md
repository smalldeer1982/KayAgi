# 词链

## 题目描述

如果单词 $X$ 的末字母与单词 $Y$ 的首字母相同，则 $X$ 与 $Y$ 可以相连成 $X.Y$。（注意：$X$、$Y$ 之间是英文的句号 `.`）。例如，单词 `dog` 与单词 `gopher`，则 `dog` 与 `gopher` 可以相连成 `dog.gopher`。

另外还有一些例子：
- `dog.gopher`
- `gopher.rat`
- `rat.tiger`
- `aloha.aloha`
- `arachnid.dog`

连接成的词可以与其他单词相连，组成更长的词链，例如：

`aloha.arachnid.dog.gopher.rat.tiger`

注意到，`.` 两边的字母一定是相同的。

现在给你一些单词，请你找到字典序最小的词链，使得每个单词在词链中出现且仅出现一次。注意，相同的单词若出现了 $k$ 次就需要输出 $k$ 次。

## 说明/提示

- 对于 $40\%$ 的数据，有 $n \leq 10$；
- 对于 $100\%$ 的数据，有 $n \leq 1000$。


## 样例 #1

### 输入

```
6
aloha
arachnid
dog
gopher
rat
tiger```

### 输出

```
aloha.arachnid.dog.gopher.rat.tiger```

# 题解

## 作者：loc_equinox (赞：92)

### 说在前面的话：
在我写这篇题解时，因为数据~~太水~~问题，过审的多数题解都可以被 Hack，带来了许多困扰。所以希望这篇文章能给大家带来帮助。

（欢迎各位大佬~~Hack~~指正）
***
### 进入正题：
读题，容易想到的是以单词为点，通过末字母与首字母比较来连边，最后 DFS 寻找字典序最小的词链。这里因为要求“字典序最小”，所以要先排序。

但是这么写的缺点就在于，起始点是不确定的，所以要挨个找起点就十分低效。[写出来了也会有两个点超时](https://www.luogu.com.cn/record/35699916)。

于是想到题目所求词链的特征：“单词在词链中出现且仅出现一次”。联想到欧拉路的特征，也是经过图的每一条边且只经过一次。所以考虑构造一张图，寻找其欧拉路（这里包括欧拉通路和欧拉回路）。

构造图的时候，以**单词为有向边，字母为顶点**。比如单词 abc，就是从顶点 a 指向顶点 c 的边之一。当一个单词的首末字母相同时，它就是一个自环。建图完毕后，先判断是否存在欧拉路，再 DFS 寻找字典序最小的欧拉路。
***
接下来分析代码：

#### Part 1:读入，建图
在建边的同时**并查集**，最后判断集合个数是不是 $1$，即判断所有点是不是都在一个集合内。这也是第一次判断欧拉路是否存在。

```cpp
//注意：这只是部分代码
int n,i,letter[27],in[27],out[27],fa[27],set_count;
string s[1002];
int ch_start,ch_end,stf,edf;
vector<vector<node> >E;
bool cmp(string a,string b)
{
    return a<b;
}
int find(int x)
{
    if(fa[x]!=x)return fa[x]=find(fa[x]);
    return fa[x];
}
void unionn(int x,int y)
{
    fa[y]=x;
    return;
}
struct node
{
    int to,ord;
    string word;
};
int main()
{
    cin>>n;
    E.resize(27);//E数组存边
    for(i=1;i<=n;i++)cin>>s[i];
    sort(s+1,s+n+1,cmp);//排序
    for(i=1;i<=n;i++)
    {
        ch_start=s[i][0]-'a'+1;//第i个词的首字母
        ch_end=s[i][s[i].length()-1]-'a'+1;//第i个词的末字母
        out[ch_start]++;//首字母出度加1
        in[ch_end]++;//末字母入度加1
        if(!letter[ch_start])//如果这个首字母（节点）没有出现过
        {
            set_count++;//集合数加1
            letter[ch_start]=1;//标记一下
            fa[ch_start]=ch_start;//并查集初始化
        }
        if(!letter[ch_end])//同上
        {
            set_count++;
            letter[ch_end]=1;
            fa[ch_end]=ch_end;
        }
        if(ch_start!=ch_end)//如果不是自环
        {
            stf=find(ch_start);
            edf=find(ch_end);
            //找代表元
            if(stf!=edf)//如果不在同一集合内
            {
                set_count--;//集合数减1
                unionn(stf,edf);
            }
        }
        node tmp;//新建一条边
        tmp.to=ch_end;
        tmp.ord=i;
        tmp.word=s[i];
        E[ch_start].push_back(tmp);//vector存图
    }
    if(set_count!=1)//如果存在多个集合（连通块），那么一定没有欧拉路
    {
        cout<<"***";
        return 0;
    }
```
***
#### Part 2:寻找欧拉路起始点
有向图中欧拉通路存在条件是：有且仅有一个点出度比入度大 $1$（起点），有且仅有一个点入度比出度大 $1$（终点），其余点入度等于出度。

有向图中欧拉回路存在条件是：所有点入度等于出度。

结合上述判定方法，有如下代码：
```cpp
int Eular_start,Eular_end;
//...
    for(i=1;i<=26;i++)//最多只有26个点
    {
        if(!letter[i])continue;//如果这个字母没有出现就跳过
        if(out[i]==in[i]+1)//这个点出度比入度大1
        {
            if(Eular_start)//如果有多个起点，那么无解
            {
                cout<<"***";
                return 0;
            }
            Eular_start=i;//标记起点
        }
        else if(in[i]==out[i]+1)//同上
        {
            if(Eular_end)
            {
                cout<<"***";
                return 0;
            }
            Eular_end=i;
        }
        else if(in[i]==out[i])continue;
        else
        {
            cout<<"***";
            return 0;
        }
    }
    if((Eular_start&&!Eular_end)||(!Eular_start&&Eular_end))//如果“有始无终”或“有终无始”，则无解
    {
        cout<<"***";
        return 0;
    }
    if(!Eular_start)Eular_start=s[1][0]-'a'+1;//如果是回路（无起点），则选字典序最小的点出发
```
***
#### Part 3:DFS求欧拉路
因为每个点出边已经排好了序，所以顺序遍历即可。在搜索时顺便记录答案。
```cpp
int vis[1002];
string res[1002];
void dfs(int st,int now,int pre_edge)//st表示词链中有几个单词，now表示现在到达了哪一个点,pre_edge表示上一条边的序号，方便回溯
{
    if(st==n)//如果到达终点
    {
        for(i=1;i<=n;i++)//输出结果
        {
            cout<<res[i];
            if(i<n)cout<<".";
        }
        exit(0);
    }
    for(int k=0;k<E[now].size();k++)
    {
        if(!vis[E[now][k].ord])//如果未被标记过
        {
            vis[E[now][k].ord]=1;
            res[st+1]=E[now][k].word;
            dfs(st+1,E[now][k].to,E[now][k].ord);
        }
    }
    vis[pre_edge]=0;//回溯
    return;
}
//...
    dfs(0,Eular_start,0);//从Part 2中找到的起点开始
```
***
（完整代码在[这里](https://www.luogu.com.cn/paste/riovrqa2)）


---

## 作者：zzr8178541919 (赞：83)

updated:2020.10.30

（把之前的一些明显的错误改了，我果然还是学艺不精。。）

首先我们知道：如果字符串A的尾部等于字符串B的头部，那么说明这两个字符串是有可能相连的。

数据范围并不是很大，我们可以考虑用搜索的策略。

关键是要找到一个准确的起点来搜索

那么起点是哪个字符串呢？

我们可以来仔细分析一下：如果假设有字符串abs和字符串sto这两个字符串。他们相连后就是abs.sto。

我们发现，每个点两边的字母一定是相同的。那对于整条链来说，如果除去最左端和最右端的两个字母后。中间的每个点两边的字母都相同，也就有了以下两个很重要的性质：
#### １每个字母出现的次数一定是偶数次
#### ２每个字符出现在字符串首位的个数一定等于出现在字符串末尾的个数（因为对于任何一个点，都能满足上面的条件）

现在将左端和右端的两个字母考虑进去，一定会出现以下两种情况中的一种
 
 １左端和右端的两个字母相同，上面的两个性质仍然成立，此时我们将字典序最小的那个字符串作为起点。
 
２左端和右端的两个字符不同，上面两个性质不再成立，但是又有了新的性质：

#### （１）一定有一个字母，其出现在字符串首位的个数等于出现在字符串末尾的个数＋１，这个字母一定作起点（设为c）。
#### （２）一定还有一个字母，其出现在字符串首位的个数等于出现在字符串末尾的个数－１，这个字母一定作终点（设为d）。我们在以ｃ为首的字符串中找到字典序小的，让它作为起点即可。但是同时我们得保证该字符串的终点不为d，或者以d为结尾的个数不为１，要加上这个判断

现在我们就知道了起点start，我们就从这里出发，开始搜索。
### 搜索的注意事项：
#### 1.我们需要定义一个flag标记是否已经找到答案。由于是按字典序搜索，第一个找到的答案一定是最优答案。这时候要立即return,在之后的回溯过程中，如果flag==1，也要立即回溯，不然有可能是正确答案被更换掉。（我就是这么错的）
#### 2.记录最终答案和在搜索过程中需要定义两个字符串数组。一个负责在搜索过程中不断更新，另一个负责找到答案后转移。（这样比较保险）
#### 3.当然还需要一个book[]数组，用来判断当前的字符串是否已经用过。搜索前标记成book[]=1;回溯时要记得book[]标记回0；
#### 4.一开始的起点一定要先标记book[]=1;

然后搜索部分就自然地解决啦，我们维护上一个字符串是谁，
在枚举当前字符串的时候，如果该字符串的首字符等于上一个字符串的尾字符，就可以继续往下搜。

AC代码如下：
```cpp
#include<cmath>
#include<cstring>
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<map>
using namespace std;
const int maxn=1e5+5;
string a[maxn];
string ans[maxn];
string now[maxn];
int sum=0;
int len[maxn];
int book[maxn];
map<char,int> s1,s2;
int n;
int flag=0;
void dfs(int last,int step)
{
	if(flag==1)
	return;
	if(step==n)
	{
		flag=1;
		for(int i=1;i<=sum;i++)
		{
			ans[i]=now[i];
		}
		return;
	}
	for(int i=1;i<=n;i++)
	{
		if(book[i]==1)
		continue;
		if(a[last][a[last].length()-1]==a[i][0])
		{
			now[++sum]=a[i];
			book[i]=1;
			dfs(i,step+1);
			sum--;
			book[i]=0;
		}
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		len[i]=a[i].length();
		s1[a[i][0]]++;
		s2[a[i][len[i]-1]]++;
	}	
	int start=1;
	sort(a+1,a+1+n);
	char s,t;
	for(char c='a';c<='z';c++)
	{
		if(abs(s1[c]-s2[c])==1)
		{
			if(s1[c]-s2[c]==1)
			s=c;
			else
			if(s2[c]-s1[c]==1)
			t=c;
		}
	}
	int cnt=s2[t];
	for(int i=1;i<=n;i++)
	{
		if(a[i][0]==s && (a[i][len[i]-1]!=t || cnt!=1))
		{
			start=i;
			break;
		}
	}
	book[start]=1;
	now[++sum]=a[start];
	dfs(start,1);
	if(flag==0)
	{
		printf("***\n");
		return 0;
	}
	for(int i=1;i<=n;i++)
	{
		if(i!=n)
		cout<<ans[i]<<".";
		else
		cout<<ans[i];
	}
	printf("\n");
	return 0;
}
```

---

## 作者：CGDGAD (赞：65)

### 题解 P1127 词链

UPD 2020.9.4：感谢 [@太阳起晚了呢](https://www.luogu.com.cn/user/178804)，修改了一处 bug，并修改了排版。

### 题意

给你几个字符串，让你把这个字符串排列组合一下，使得相邻的两个单词中前面一个单词的尾字母等于后面一个单词的首字母。

### 思路

这道题肯定是一道**搜索**题。

思路：从任意一个字符串 $s$ 开始，每次在输入的所有字符串中查找首字母与 $s$ 的尾字母相同的字符串，然后用找到的这个字符串继续搜索，直到搜索到 $n$ 个字符串为止。

「每次在输入的所有字符串中查找首字母与 $s$ 的尾字母相同的字符串」这个过程可以在输入的时候就建图，在首、尾字母相同的两个字符串之间建立一条边，然后搜索的时候直接用建好的这些边找就行了。

这个搜索很好做，大概只有黄题的难度，核心代码如下：

```cpp
std::string a[1001];
std::vector<int> e[1001];

for (int i = 1; i <= n; ++i)
  std::cin >> a[i];
std::sort(a + 1, a + n + 1); // 字典序排序（题目要求）
for (int i = 1; i <= n; ++i)
  for (int j = 1; j <= n; ++j)
    if (i != j && a[i][a[i].length() - 1] == a[j][0]) // 判断两个字符串是否可以相连（前一个字符串的尾字母等于后一个字符串的首字母）
      e[i].push_back(j);

bool used[1001];
// s: 当前字符串的编号（所有字符串按字典序，编号分别为 1 到 n）
// curr: 当前已生成的词链。
// count: 已查找到的字符串个数。
void dfs(int s, std::string curr, int count) {
	if (count == n) {
		curr[curr.length() - 1] = ' '; // 把最后一个 '.' 去掉。
		std::cout << curr;
		exit(0);
	}
	for (auto i : e[s])
		if (!used[i]) {
			used[i] = true;
			dfs(i, curr + a[i] + '.', count + 1);
			used[i] = false;
		}
}
```

然后用每一个字符串当作第一个单词试一遍，如果可以就直接输出然后结束程序。

这种做法，可以拿到 $80$ 分。

### 考虑优化

有两个点炸掉了，所以我们要考虑优化。

显然「每一个字符串当作第一个单词试一遍」这个方法效率非常低。

我们需要筛选出一些可能作为词链的第一个单词的词。

如何找到这个单词呢？

观察样例，我们发现：

```plain
a----a.a----d.d----g.g----r.r----t.t-----
```

发现 `a` 作为词链的第一个字母，它作为单词的首字母的次数为 $2$（它是单词 `aloha` 和 `arachnid` 的首字母），作为单词的尾字母的次数为 $1$ （它是 `aloha` 的尾字母）。首字母次数是尾字母次数加 $1$。

再仔细思考一下，或者自己造几个样例，**发现对于每一个合法的词链，它的首字母字符，它作为单词的首字母的次数永远是它作为单词尾字母的次数加上 $1$。**

因为从第一个单词的尾字母开始到最后一个单词的首字母结束，**每个作为首字母/尾字母的字母的出现次数都是偶数（成对出现）**（这个应该很好理解）。

然而第一个单词的首字母多出现了一次，它不是成对出现的。

所以就有了上述结论。

当然，也有特殊情况，就是最后一个单词的尾字母和第一个单词的首字母是一样的（即可以连成一个环）。那么从 $1$ 开始就行了。

```cpp
int ind[1001]; // 作为首字母的次数
int rnd[1001]; // 作为尾字母的次数

// 所以执行 find() 前要加上这段：
for (int i = 1; i <= n; ++i) {
  ++ind[a[i][0]];
  ++rnd[a[i][a[i].length() - 1]];
}


for (int i = 1; i <= n; ++i)
  if (ind[a[i][0]] == rnd[a[i][0]] + 1) {
    used[i] = true;
    dfs(i, a[i] + '.', 1);
    used[i] = false;
  }
used[1] = true;
dfs(1, a[1] + '.', 1);
used[1] = false; // 不行，就从 1 开始。
```

### 代码

```cpp
int n;
std::string a[1001];
std::vector<int> e[1001];
int ind[1001];
int rnd[1001];
bool used[1001];

void dfs(int s, std::string curr, int count) {
	// 与不优化时同样的 dfs 代码。
}

int main() {
	std::cin >> n;
	for (int i = 1; i <= n; ++i) {
		std::cin >> a[i];
		++ind[a[i][0]];
		++rnd[a[i][a[i].length() - 1]];
	}
	std::sort(a + 1, a + n + 1);
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= n; ++j)
			if (i != j && a[i][a[i].length() - 1] == a[j][0])
				e[i].push_back(j);
	for (int i = 1; i <= n; ++i)
		if (ind[a[i][0]] == rnd[a[i][0]] + 1) {
			used[i] = true;
			dfs(i, a[i] + '.', 1);
			used[i] = false;
		}
	used[1] = true;
	dfs(1, a[1] + '.', 1);
	used[1] = false;
	std::cout << "***";
	return 0;
}
```

这就是这篇题解的全部内容了，这个解法还是和大部分之前的题解都不一样的，个人认为更好理解一些。

---

## 作者：chauchat (赞：27)

嗯……当初看到这道题的时候，无脑写了一波（不就是存图爆搜嘛），然后wa了无数次

查阅资料后发现没有那么简单：

一个有向图，存在欧拉通路的条件是：

1）基图（就是对应的无向图）联通

2）只有一个点出度比入度大1，一个点入度比出度大1，其他两者相等，诶如果所有点入度出度都相等，就是欧拉回路啦

然后回到这题，比较正经的思路应该是：

1）以单词为边，单词的首字母和末字母为点连边，所以图至多有26个点，统计出现过的点（字母）

2）存下对应的无向图，随便跑一下并查集，检验联通块的个数是不是1；

3）建图的时候顺便统计点的度数，然后判断是哪种情况，之后递归构造答案就行了。





```cpp
#include<iostream>
using namespace std;
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<vector>
const int maxm = 26;
const int maxn = 1010;
int exist[maxm],set[maxm];
int find(int x){
    return set[x]==x ? x : set[x] = find(set[x]);
}
struct edge{
    int s,t,key;
    bool operator < (const edge &a){
        if(s != a.s) return s < a.s;
        return key < a.key;
    }
}e[2*maxn]; int p1,p2;
void add(int a,int b,int k){
    e[++p1].s=a,e[p1].t=b;
}
string st[maxn],ans[maxn];
int n,rudu[maxm],chudu[maxm],head=-1,vis[maxn],ptr,flag;
bool judge(){
    for(int i = 0;i < maxm;i++) set[i] = i;
    for(int i = 1;i <= p1;i++){
        int a = e[i].s,b = e[i].t;
        int fa = find(a),fb = find(b);
        if(fa != fb) set[fa] = fb;
    }
    int cnt = 0;
    for(int i = 0;i < maxm;i++)
        if(exist[i] && set[i]==i)
            cnt++;
    if(cnt != 1) return false;
    return true;
}
void dfs(int now){
    for(int i = 1;i <= n;i++)
        if(st[i][0]-'a'==now && !vis[i]){
            vis[i] = 1;
            dfs(st[i][st[i].length()-1]-'a');
            ans[++ptr] = st[i];
        }
}
int main(){
    cin>>n;
    for(int i = 1;i <= n;i++) cin>>st[i];
    sort(st+1,st+1+n);
    for(int i = 1;i <= n;i++){
        int a = st[i][0]-'a',b = st[i][st[i].length()-1]-'a';
        if(!exist[a]) exist[a]=1; if(!exist[b]) exist[b] = 1;
        add(a,b,0); add(b,a,0);
        rudu[b]++,chudu[a]++;
    }
    if(!judge()){
        cout<<"***"; return 0;
    }
    int cnt = 0;
    for(int i = 0;i < maxm;i++){
        if(abs(chudu[i]-rudu[i]) >= 1){
            cnt++;
            if(abs(chudu[i]-rudu[i]) > 1){
                cout<<"***"; return 0;
            }else if(chudu[i]-rudu[i]==1 && head==-1) head = i;
        }
    }
//    cout<<cnt<<" "<<head<<endl;
    if(cnt != 0 && cnt != 2){
        cout<<"***"; return 0;
    }else if(cnt == 2) dfs(head);
    else for(int i = 0;i < maxm;i++) if(exist[i]) dfs(i);
    for(int i = ptr;i >= 1;i--){
        cout<<ans[i];
        if(i > 1) cout<<".";
    } 
    return 0;
}
```

---

## 作者：y553546436 (赞：16)

1.单词作点 可以拼在一起的单词连边。

2.先对单词排序，加边时注意顺序，使找到的第一个欧拉回路即为字典序最小的，后面直接跳出就好了。

3.dfs前初步判断一下是否有解（注意，是初步！！！） 用一些奇怪的方法

4.dfs后，若找到解则输出，否则***。（因为初步判断有解时可能将一些无解的情况放过了）

代码如下 (洛谷好坑 取消流同步ios::sync\_with\_stdio(false) 加上之后会re)



```cpp
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;
const int N=1010,inf=1<<29;
int n,len[N],sta[N],cnt[30],top=0;
int head[N],to[N*N],next[N*N],en;
bool flag=false,vis[N];
string s[N];
void dfs(int u)
{
    if (flag) return ;
    sta[top++]=u;
    vis[u]=true;
    int v;
    for (int i=head[u];i;i=next[i])
    {
        v=to[i];
        if (!vis[v]) dfs(v);
    }
    if (top==n) flag=true;
    else vis[u]=false,--top;
}
void add_edge(int u,int v){
    to[++en]=v,next[en]=head[u],head[u]=en;
}
int main()
{
    //ios::sync_with_stdio(false);
    cin>>n;
    for (int i=1;i<=n;i++)
        cin>>s[i];
    sort(s+1,s+n+1);
    for (int i=1;i<=n;i++)
        len[i]=s[i].size();
    for (int i=1;i<=n;i++)
        for (int j=n;j>=1;j--)
        if (i!=j && s[i][len[i]-1]==s[j][0])
        add_edge(i,j);
    for (int i=1;i<=n;i++)
        cnt[s[i][0]-'a']++,cnt[s[i][len[i]-1]-'a']--;
    int k=0,h;
    for (int i=0;i<26;i++){
        if (cnt[i]==1) k++,h=i;
        if (cnt[i]==2) k=2;
        if (k==2) break;
    }
    if (k==2) cout<<"***\n";
    else if (k==1){
        for (int i=1;i<=n;i++)
            if (s[i][0]-'a'==h)
            dfs(i);
    }
    else {
        for (int i=1;i<=n;i++)
            dfs(i);
    }
    if (!flag) {
        cout<<"***\n";
        return 0;
    }
    cout<<s[sta[0]];
    for (int i=1;i<top;i++)
        cout<<'.'<<s[sta[i]];
    cout<<endl;
    return 0;
}
```

---

## 作者：谷奕勋 (赞：15)

蒟蒻第一篇题解，写的不好还望见谅。

本蒟蒻看到这个题的第一反应就是深搜（似乎建个图会更简单），为了减少循环次数，首先按照字典序排序，建了一个数组 start 标记每个英文首字母出现的位置。将所有字符串都作为dfs起点，再找到所有以前一个末尾开头的字符串dfs下去，然后就得到了2个大大的TLE。没错，不是所有字符串都能作为起点的。

查阅了一点资料，发现如果有1个字母在首位出现次数比末尾出现次数多一，那么这个字母必将是起始字符串的首字母。如果有两个或以上个这样的字母，那么不可解。如果没有这样的字母，说明形成了Hamilton回路，每个字母对应的所有字符串都可以做dfs起点。最后AC，代码在下面。

PS：这道题好像条件有点水，有些代码有问题也能过，不知道我的代码有没有问题，希望评论区大佬指点一下。


```
#include<bits/stdc++.h>
#define LL long long
using namespace std;
int n; int start[30], s1[30]; 
string choose[1005]; string s[1005]; bool vis[1005];

void dfs(string s_now, int acc){
	if(acc == n){
		for(int i = 1; i <= n-1; i++){
			cout<<choose[i]<<".";
		}
		cout<<choose[n];
		exit(0);
		return;	
	}
	char c_now = s_now[s_now.length()-1];
	for(int i = start[c_now - 'a']; i; i++){
		if(s[i][0] != c_now) break;
		if(vis[i]) continue;
		choose[acc+1] = s[i];
		vis[i] = 1;
		dfs(s[i], acc+1);
		vis[i] = 0; 
	}
}
int main(){

	cin>>n;
	for(int i = 1; i <= n; i++){
		cin>>s[i];
		s1[s[i][0]-'a']++;
		s1[s[i][s[i].length()-1]-'a']--;
		
	}
	sort(s+1, s+n+1);
	
	for(int i = 1; i <= n; i++){
		if(start[s[i][0]-'a'] == 0)
			start[s[i][0]-'a'] = i;
	}
	int k = 0, h;
	for(int i = 0; i < 26; i++){
		if(s1[i] == 1) k++, h = i;
		if(s1[i] == 2 || k == 2) break;
	}
	if(k == 1){
		for(int i = 1; i <= n; i++){
			if(s[i][0] - 'a' == h){
				string s_now = s[i];
				choose[1] = s[i];
				vis[i] = 1;
				dfs(s_now, 1);
				vis[i] = 0;
			}
					
		}
	}
	
	if(k == 0){
		for(int i = 1; i <= n; i++){
			choose[1] = s[i];
			vis[i] = 1;
			dfs(s[i], 1);
			vis[i] = 0;
		}
	}
	cout<<"***";
} 
```

---

## 作者：fls233666 (赞：10)

看到这题，一般的第一个想法就是**暴力搜索**。

根据数据范围，搜索应该能拿到 $40$ 分左右的成绩。

下面我们考虑正解。

我们发现，**一个单词在词链中与哪些单词拼接，只与这个单词开头和末尾的两个字符有关！**

别看这个性质很普通，这恰好是我们**数学建模**的入手点！

如何数学建模？**考虑把单词开头字母向单词结尾字母连边，我们可以得到一个有向图。这时候再看题目，这题就变成了求欧拉路径的问题了。**

想到这里，你已经成功了一半了。下面开始考虑判断无解和寻找路径起点的问题。

关于有向图的欧拉路径起点，可以用如下方法寻找：

把一个点的度记为这个点的出度减去这个点的入度。**一个有向图存在欧拉路径，则这个路径的起点的度必为 $1$,终点的度必为 $-1$，其余点的度为 $0$。**如果所有点的度都是 $0$，则变成欧拉回路，可以从任意点开始搜索。

另外，还要判断无解。无解的情况就是**图不连通**。有一个判无解的简单方法：**搜索完成后，判断是否所有的边都被搜过，如果没有，无解。**

另外，题目要求要**字典序最小**的答案。对此，可以把输入的单词排序后连边。需要注意的是，如果是用边链表存边的，需要倒序连边，才能保证字典序最小。然后如果遇到欧拉回路，则找存在的字母中字典序最小的开始搜索即可。

那么这题就做完了，下面是代码：

```cpp
#include<iostream>
#include<cstdio>
#include<string>
#include<algorithm>
#define ll long long
#define rgt register int
using namespace std;
const int mxn = 1010;
string str[mxn],outans[mxn];
int tot,lst[30],nxt[mxn],to[mxn],bh[mxn],d[mxn],lans;
bool use[mxn];

inline void add(int x,int y,int b){
	tot++;
	to[tot]=y;
	bh[tot]=b;   //存这条边对应的字符串编号
	d[x]++;
	d[y]--;   //计算点度
	nxt[tot]=lst[x];
	lst[x]=tot;
}   //加边函数

void dfs(int g){  //搜索函数
	for(rgt i=lst[g];i;i=nxt[i]){
		if(!use[bh[i]]){  //找到一条未使用的边
			use[bh[i]]=true;  //标记
			dfs(to[i]);
			lans++;  //倒序存答案
			outans[lans]=str[bh[i]];
		}
	}
}

int main(){
	ios::sync_with_stdio(false);
	int n,st;
	cin>>n;
	for(rgt i=1;i<=n;i++)
		cin>>str[i];   //读入数据
        
	sort(str+1,str+1+n);  //排序
	st=str[1][0]-'a'+1;  //先把存在的字典序最小的字母作为起点，如果是欧拉回路，则从这个起点切入
    
	for(rgt hd,tl,i=n;i>=1;i--){
		hd=str[i][0]-'a'+1;  //首字母
		tl=str[i][str[i].size()-1]-'a'+1;  //尾字母
		add(hd,tl,i);  //连边
	}  
    
	for(rgt i=1;i<=26;i++)
		if(d[i]==1){  //是欧拉路径，更新起点
			st=i;
			break;
		}
        
	dfs(st);
    
	for(rgt i=1;i<=n;i++)
		if(!use[i]){
			cout<<"***";
			return 0; 
		} //如果没有使用所有边，无解
        
	for(rgt i=lans;i>1;i--)
		cout<<outans[i]<<".";
	cout<<outans[1];  //输出答案
    
	return 0;
}
```


---

## 作者：KaguyaH (赞：9)

[**题目**](https://www.luogu.com.cn/problem/P1127) [**博客查看**](https://www.luogu.com.cn/blog/236807/Solution-luogu-P1127)

本文所涉及之字符串比较，均为字典序的比较；若 $a$，$b$ 表示两个字符串，$ab$ 表示将她们相连而成的字符串。

多项式解法并不容易想到，考虑搜索。

我们发现 `.` 的字典序比小写字母小，所以若 $s_1 < s_2$ 的字典序，则 $s_1.s_2 < s_2.s_1$。

考虑将可以相连的字符串间连边，变成了一个有向图，我们要求的就是 $[1, n]$ 的一个排列 $p$，使得 $\forall i \in \left[1, n\right)$，存在边 $p_i \rightarrow p_{i + 1}$。

裸的搜索可以拿到 80 分的好成绩。考虑优化。

我们发现，很难在搜索过程中控制时间，故考虑增加对无解的判断以及控制初始节点。定义 $c_f(x)$ 表示以字符 $x$ 为首字母的单词数，$c_b(x)$ 表示以字符 $x$ 为末字母的单词数。具体地，有如下几点：

- 若 $c_f(x) > c_b(x) + 1$，则无解（单词相连处会消掉一组，最后可以在串首放置单词，但即使这样，也还会有多余的单词）；
- 若 $c_b(x) > c_f(x) + 1$，则无解（同理）；
- 若 $f$ 为某一单词的首字母，$b$ 为末字母，$c_b(f) = 0 \land c_f(b) = 0 \land n > 1$，则无解（无法连边）；
- 若 $c_f(x) = c_b(x) + 1$，则串首字母必须为 $x$；
- 若 $c_b(x) = c_f(x) + 1$，则串末字母必须为 $x$；
- 充分考虑以上几点间的影响；
- *对图进行一次 Tarjan 缩点：*
  - *如果有多个入度 / 出度为 $0$ 的强连通分量，则无解；*
  - *如果拓扑序不唯一，则无解（考虑在强连通分量之间搜索时，转换强连通分量时，必然经过有向边，而我们要搜索所有强连通分量，故必然有一条路径经过所有强连通分量，而 Tarjan 缩点后不存在环，所以这条路径上强连通分量的排列即为拓扑序；*
  - *必须搜索完一个强连通分量后再去搜索另一个。*

上面只需要正体字即可通过本题，斜体字为拓展思路，有兴趣的同学可以实现一下。

---

## 作者：深蓝色的守望 (赞：4)

直接欧拉路径,一次DFS遍历

```delphi

program Marris;
type
   sonlink=^node;
   node=record
     s:string;
     next:sonlink;
   end;
var
   pa,into,outo:array[0..26]of longint;
   son:array[0..1000]of sonlink;
   a,ans:array[0..1000]of string;
   b:array[0..26]of boolean;
   i,j,n,l,r,t,s,sum,sum1,b1,b2:longint;
   p:sonlink;
   bool:boolean;
procedure swap(var x,y:string);
var
   t:string;
begin
   t:=x;x:=y;y:=t;
end;
procedure qsort(f,r:longint);
var
   i,j:longint;
   m:string;
begin
   i:=f;j:=r;
   m:=a[(f+r) shr 1];
   repeat
     while a[i]>m do inc(i);
     while a[j]<m do dec(j);
     if i<=j then
       begin
         swap(a[i],a[j]);
         inc(i);dec(J);
       end;
   until i>j;
   if j>f then qsort(f,j);
   if r>i then qsort(i,r);
end;
procedure print(x:longint);
var
   t:longint;
   st:string[30];
begin
   while son[x]<>nil do
     begin
       st:=son[x]^.s;
       t:=ord(st[length(st)])-96;
       son[x]:=son[x]^.next;
       print(t);
       inc(s);
       ans[s]:=st;
     end;
end;
procedure error;
begin
   writeln('***');
   close(input);close(output);
   halt;
end;
begin
   assign(input,'catenyms.in');reset(input);
   assign(output,'catenyms.out');rewrite(output);

   readln(n);
   fillchar(into,sizeof(into),0);
   fillchar(outo,sizeof(outo),0);
   fillchar(b,sizeof(b),false);
   for i:=1 to 26 do pa[i]:=i;
   for i:=1 to n do
     begin
       readln(a[i]);
       l:=ord(a[i][1])-96;
       r:=ord(a[i][length(a[i])])-96;
       b[l]:=true;b[r]:=true;
       inc(into[l]);inc(outo[r]);
     end;

   bool:=true;
   sum:=0;
   for i:=1 to 26 do
     if b[i] and (abs(into[i]-outo[i])=1) then inc(sum);
   if (sum<>0) and (sum<>2) then bool:=false;
   if not bool then error;

   qsort(1,n);
   for i:=1 to n do son[i]:=nil;
   for i:=1 to n do
     begin
       t:=ord(a[i][1])-96;
       new(p);
         p^.s:=a[i];
         p^.next:=son[t];son[t]:=p;
     end;
   s:=0;
   if (sum<>0) then
     for i:=1 to 26 do
       if into[i]>outo[i] then
         begin
           print(i);
           break;
         end
       else
   else
     for i:=1 to 26 do
       if son[i]<>nil then
         begin
           print(i);
           break;
         end;
   if s<n then error
   else
     for i:=n downto 1 do
       if i<>1 then
         write(ans[i],'.')
       else
         writeln(ans[i]);
   close(input);close(output);
end.

```（pascal）


---

## 作者：keep_ (赞：4)

# p1127（dfs+欧拉通路/回路）

***

## 1.题目分析

我们需要找出一条包含所有单词，这些单词在词链中出现且仅出现一次，且字典序最小的链。

假设我们对每一个单词连一条从首字母指向尾字母的有向边，假设存在这样的一条链，那么我

们所建成的图中便一定存在欧拉通路或者欧拉回路。

**欧拉通路** 从一点出发，可以经过图中每一条边的路径，被称作欧拉通路，无向图中欧拉

欧拉通路存在的条件：若图中有且仅由两个点的出度不等于入度，且一点的出度=入度+1，另一

点的入度=出度+1，则图中存在欧拉通路，且起点为出度较大的点，终点为入度较大的点。

**欧拉回路**：从图中任意一点出发，可经过所有边且回到起点的路径

有向图欧拉回路判断条件：所有点的出度等于入读

**注意，欧拉回路和通路存在的必要条件是基图联通**

首先，为什么我们要建无向图而不是有向图？考虑到词链不可反转(假设词链ab.bc合法，那么c

b.ba不合法)，所以只能建有向图

为什么一定要存在欧拉回路或者通路呢？

分析题目，我们将单词转化为边，那么所求的词链一定是一条欧拉通路

有了这个前提，这道题就很容易解决的，

我们将找词链转化为有向图找欧拉通路

但词链的起点怎么确定呢？

假设图中存在欧拉回路，那么从任意点出发都可以，但我们要求字典序最小，所以必须从字典

序最小的单词的首字母出发

假设图中仅有欧拉通路，那么只有从通路起点出发才可经过所有边。

因为我们需要求字典序最小的词链，所以选点按字典序从小开始选即可

分析到这，代码就可以写出来了

建图后先通过并查集来判是否连通，统计出度入度判断图的类型，找到起点按字典序来dfs即可
代码如下

```c++
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<string>
using namespace std;
const int maxn=1e3+10;
int n;
string st[maxn];
struct node{
	int s,t;
}e[maxn];
int cu[maxn];
int ru[maxn];
int fla[maxn];
int cnt;
void add(int x,int y){
	cnt++;
	e[cnt].s=x;
	e[cnt].t=y;
}
int f[maxn];
int find(int x){
	if(f[x]!=x){
		return f[x]=find(f[x]);
	}
	else
		return x;
}
int tot;
bool jud(){
	for(int i=1;i<=26;i++){
		f[i]=i;
	}
	for(int i=1;i<=cnt;i++){
		int a=e[i].s;
		int b=e[i].t;
		int fa = find(a),fb = find(b);
        if(fa != fb) f[fa] = fb;
	}
	int cn=0;
	for(int i=1;i<=26;i++){
		if(fla[i]&&f[i]==i){
			cn++;
		}
	}
	if(cn-1!=tot){
		return false;
	}
	return true;
}
int vis[maxn];
int p;
int ans[maxn];
void dfs(int now){
	for(int i=1;i<=n;i++){
		if(st[i][0]-'a'+1==now&&!vis[i]){
			vis[i]=1;
			dfs(st[i][st[i].length()-1]-'a'+1);
			p++;
			ans[p]=i;
		}
	}
	return ;
}
int main(){
//	freopen("a.in","r",stdin);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>st[i];
	}
	int a,b;
	sort(st+1,st+1+n);//从小到大排序，目的是在dfs过程中得到最优解 
	for(int i=1;i<=n;i++){
		//cout<<st[i]<<endl;
		a=st[i][0]-'a'+1;//得到字符串的起始字符 
		b=st[i][st[i].length()-1]-'a'+1;//终止字符 
	//	cout<<a<<" "<<b<<endl;
		add(a,b);
//		add(b,a) ;
		if(!fla[a])
			fla[a]=1;//记录该字符是否出现，目的是判断联通 
		if(!fla[b])
			fla[b]=1;
		cu[a]++;//出度 
		ru[b]++;//入度 
	}
//	cout<<jud();
	if(!jud()){
		cout<<"***";
		return 0;
	}
	int s=0;
	int t=0;
	int to=0;
	for(int i=1;i<=26;i++){
		if(ru[i]!=cu[i]){
			to++;//	
			if(cu[i]-ru[i]==1){
				s=i;	
			}
			if(ru[i]-cu[i]==1){
				t=i;
			}
			}
			else if(abs(cu[i]-ru[i])>1){
				cout<<"***";
				return 0;
			}
			if(to==2&&(!s||!t)){
				cout<<"***";
				return 0;
			}
	}
	if(to==1||to>2){
		cout<<"***";
		return 0;
	}
	if(s!=0){
		dfs(s);
	}
	else{
		dfs(st[1][0]-'a'+1);
	}
	for(int i=p;i>=1;i--){
		cout<<st[ans[i]];
		if(i>1)
			cout<<'.';
	}
	return 0;
}
```




---

## 作者：limi_sanhua (赞：1)

### 优点:
**不用繁琐地判断存在欧拉通路的条件**

**代码很少**

# **思路:**

建立单词**首字母到尾字母的边**,然后**直接跑dfs**找到一条能**路过所有边的路线**,找到就**直接返回**，沿途**记录下答案**,最后输出

### 建边的例子:

 _gopher_     建**g指向r**的边,最好转化为**数字**建

### 存边的方法:

一个struct记录**每条边的起点与终点**,再开个struct记录**每个点的边**(这个有点不好说,康康代码就懂了应该)

### 可以直接dfs的缘由:

可以**优先从入度!=出度的点开始搜**(具体见注释)

```cpp
#pragma GCC optimize("Ofast")
#include<cstdio>
#include<string>
#include<iostream>
#include<algorithm>
#define ri register int
#define u int
#define NN 30
#define MM 1005
#define I  __inline__ __attribute__((always_inline))
using namespace std;
namespace first{
	u T,cnt,id[NN],od[NN];
	string s[MM];
}
namespace dfss{
    u cnt,b[MM],vt[MM],ans[MM];
    struct node{
        u l,r;
    }a[NN];
    u dfs(const u &x,const u &k){//搜索
    	if(!k)return 1;
        for(ri i=a[x].l;i<=a[x].r;++i){
            if(!vt[i]){
                vt[i]=1;
                if(dfs(b[i],k-1)){
                    ans[first::T-k+1]=i;
                    return 1;
                }
                vt[i]=0;
            }
        }
        return 0;
    }
}
namespace all{
    using namespace first;
    using namespace dfss;
    I void run(const u &i){//判断函数
    	if(dfs(i,T)){
            for(ri i=1;i<T;++i)
                cout<<s[ans[i]]<<".";
            cout<<s[ans[T]];
            exit(0);
        }
	}
}
using namespace all;
int main() {
    cin>>T;
    for(ri i=1;i<=T;++i)cin>>s[i];
    sort(s+1,s+T+1),a[s[T][0]-'a'+1].r=T;//排序,建边
    for(ri i=1,f=0;i<=T;++i){
        string sa=s[i];
        u l(sa[0]-'a'+1),r(sa[sa.length()-1]-'a'+1);
        if(l^f)a[f].r=i-1,a[l].l=i,f=l;//建边
        b[i]=r,++id[r],++od[l];//建边
    }
    for(ri i=1;i<=26;++i)//优先搜索入度!=出度的点
        if(id[i]^od[i])run(i);
    for(ri i=1;i<=26;++i)//不行再搜入度==出度的点
        if(id[i]==od[i])run(i);
    printf("***");//实在不行就"***"
}
```


---


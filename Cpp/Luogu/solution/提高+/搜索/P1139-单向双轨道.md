# 单向双轨道

## 题目描述

如图所示，某火车站有 B、C 两个调度站，左边入口 A 处有$n$ 辆火车等待进站(从左到右以 $a,b,c,d$ 编号)，右边是出口 D，规定在这一段，火车从 A 进入经过 B、C 只能从左向右单向开，并且 B、C 调度站不限定所能停放的车辆数。

![](https://cdn.luogu.com.cn/upload/image_hosting/m1n53d63.png)

从文件输入 $n$ 及 $n$ 个小写字母的一个排列，该排列表示火车在出口 D 处形成的从左到右的火车编号序列。输出为一系列操作过程，每一行形如 $h, L, R$ 的字母序列，其中 $h$ 为火车编号，$L$ 为 $h$ 车原先所在位置（位置都以$\verb!A,B,C,D!$ 表示），$R$ 为新位置。或者输出 `NO` 表示不能完成这样的调度。


## 样例 #1

### 输入

```
3
cba
```

### 输出

```
c A B
b A B
a A D
b B D
c B D
```

# 题解

## 作者：Utilokasteinn (赞：16)

一道挺好的搜索题，剪枝也很简单。

采用迭代加深搜索，因为每辆火车至少要做 $1$ 次调度，最多要做 $3$ 次调度。所以枚举调度次数从 $n$ 到 $3n$ 即可。如果没有答案则输出“NO”。

每次调度，看看可不可以从这个位置调度到后面的位置，有的话即调度。

几个剪枝：

- 因为一辆火车到出口就不能往回，所以答案就一定了。每次深搜时判断是否符合标准，否则直接退出。

- 如果剩余的调度步数小于还没到出口的火车数，即可以直接退出。

- 如果当前这个位置没火车即不用搜了。

代码如下，比其他题解都简洁非常多：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,mb[30],ans[30],from[100],to[101],s[4][30],cnt[4],lim;
char ss[30];
void dfs(int step)
{
    if(s[3][cnt[3]]!=mb[cnt[3]])return;
    if(lim-step+1<cnt[0]+cnt[1]+cnt[2])return;
    if(step==lim+1&&!cnt[0]+cnt[1]+cnt[2])
	{
        for(int i=1;i<step;i++)
			printf("%c %c %c\n",ans[i]+'a'-1,from[i]+'A',to[i]+'A');
        exit(0);
    }
    if(step>lim)return;
	for(int i=0;i<=2;i++)
		for(int j=i+1;j<=3&&cnt[i];j++)
		{
			int flag=s[i][cnt[i]--];
			ans[step]=s[j][++cnt[j]]=flag;
			from[step]=i,to[step]=j;
			dfs(step+1);
			s[i][++cnt[i]]=flag,cnt[j]--;	
		}
}
int main()
{
    scanf("%d%s",&n,ss+1);
    for(int i=1;i<=n;i++)
		mb[n-i+1]=ss[i]-'a'+1,s[0][++cnt[0]]=i;
    for(lim=n;lim<=3*n;lim++)
		dfs(1);
    printf("NO");
    return 0;
}
```


---

## 作者：y2823774827y (赞：13)

和楼下dalao的做法一样，个人感觉用标准的栈写起来更好~~更舒服~~，让大家更容易看懂

### **注意** 
五个栈操作，常数较大开O2能过，考试时不建议用
```cpp
#include<cstdio>
#include<stack>
#include<queue>
#include<algorithm>
using namespace std;
struct node{
	int x,s,t;
}; 
stack<int> sta1,sta2,sta3,sta4;
stack<node> que;
int n;int to[50];
void write(){
	node cun=que.top();
	que.pop();
	if(que.size())
	    write();
	printf("%c %c %c\n",cun.x+'a'-1,cun.s+'A'-1,cun.t+'A'-1);
}
void dfs(int now,int up){
	if(sta4.size())
	    if((to[ sta4.size() ]!=sta4.top()))
	        return;
	if(up-now+1<n-sta4.size())
	    return;
	if(now==up+1&&sta1.empty()&&sta2.empty()&&sta3.empty()){
		write();
		exit(0);
	}
	if(now>up)
	    return;
	if(sta1.size()){
		que.push((node){sta1.top(),1,2});//A->B
		sta2.push(sta1.top()); sta1.pop();
		dfs(now+1,up);
		sta1.push(sta2.top()); sta2.pop();
		que.pop();
		
		que.push((node){sta1.top(),1,3});//A->C
		sta3.push(sta1.top()); sta1.pop();
		dfs(now+1,up);
		sta1.push(sta3.top()); sta3.pop();
		que.pop();
		
		que.push((node){sta1.top(),1,4});//A->D
		sta4.push(sta1.top()); sta1.pop();
		dfs(now+1,up);
		sta1.push(sta4.top()); sta4.pop();
		que.pop();
	}
	if(sta2.size()){
		que.push((node){sta2.top(),2,3});//B->C
		sta3.push(sta2.top()); sta2.pop();
		dfs(now+1,up);
		sta2.push(sta3.top()); sta3.pop();
		que.pop();
		
		que.push((node){sta2.top(),2,4});//B->D
		sta4.push(sta2.top()); sta2.pop();
		dfs(now+1,up);
		sta2.push(sta4.top()); sta4.pop();
		que.pop();
	}
	if(sta3.size()){
		que.push((node){sta3.top(),3,4});//C->D
		sta4.push(sta3.top()); sta3.pop();
		dfs(now+1,up);
		sta3.push(sta4.top()); sta4.pop();
		que.pop();
	}
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		char c;
		scanf(" %c",&c);
		to[n-i+1]=c-'a'+1;
		sta1.push(i);
	}
	for(int i=1;i<=n*3;++i)
	    dfs(1,i);
	printf("NO");
	return 0;
}/*
3
cba

c A B
b A B
a A D
b B D
c B D
*/
```

---

## 作者：Youngsc (赞：7)

挂个博客[Youngsc](https://youngscc.github.io/)

非常~~血腥暴力无下限~~的搜索。。

**对于这种最优化的题我们可以考虑用迭代加深，每次每句不同的操作数**

**由于每一辆车最多只会有三种操作，所以最多只会有3\*n步**

**然后全局开四个栈，分别记录ABCD四个位置的车的信息**

**在不考虑不同的车的情况下，一共有六个操作，分别是A-->B,A-->C,A-->D,B-->C,B-->D,C-->D**

**在每一层我们按照字典序大小枚举六个操作，然后对相关的栈进行维护**

**不要忘记每次搜索完后再将栈回溯**

**每次搜索开始时都先判断一下终点栈顶的元素与输入的字符串是否吻合**

**由于进入终点的车不能再回去，所以如果不吻合的话直接返回就好**

**因此到达边界之后直接将记录的操作输出即可，无需判断**

**别忘了加上一些奇奇怪怪的剪枝**


ATOM的多光标操作就是~~骚~~，一个搜索分分钟打完。


## 代码在这里


~~是不是很短~~


```cpp
# include <algorithm>
# include <iostream>
# include <cstring>
# include <cstdio>
# include <cmath>
# include <queue>
# define R register
# define LL long long
# define N 30

using namespace std;

int n,st0,st1,st2,st3,s0[N],s1[N],s2[N],s3[N],d[3*N][2],to[N],c[N];

char s[N];

template <typename T> inline void in(R T& a){
    R char c=getchar(); R T x=0,f=1;
    while(!isdigit(c)) {if(c == '-') f=-1; c=getchar();}
    while(isdigit(c)) x=(x<<1)+(x<<3)+c-'0',c=getchar();
    a=x*f;
}

inline void dfs(R int x,R int lim){
    if(s3[st3]!=to[st3]) return;
    if(lim-x+1<n-st3) return;
    if(x==lim+1 &&!st0&&!st1&&!st2){
        for(R int i=1; i<x; ++i) printf("%c %c %c\n",c[i]+'a'-1,d[i][0]+'A',d[i][1]+'A');
        exit(0);
    }
    if(x>lim) return;
    R int rem;
    if(st0) d[x][0]=0,d[x][1]=1,rem = s0[st0--],c[x] = rem,s1[++st1] = rem,dfs(x+1,lim),s0[++st0] = rem,st1--;
    if(st0) d[x][0]=0,d[x][1]=2,rem = s0[st0--],c[x] = rem,s2[++st2] = rem,dfs(x+1,lim),s0[++st0] = rem,st2--;
    if(st0) d[x][0]=0,d[x][1]=3,rem = s0[st0--],c[x] = rem,s3[++st3] = rem,dfs(x+1,lim),s0[++st0] = rem,st3--;
    if(st1) d[x][0]=1,d[x][1]=2,rem = s1[st1--],c[x] = rem,s2[++st2] = rem,dfs(x+1,lim),s1[++st1] = rem,st2--;
    if(st1) d[x][0]=1,d[x][1]=3,rem = s1[st1--],c[x] = rem,s3[++st3] = rem,dfs(x+1,lim),s1[++st1] = rem,st3--;
    if(st2) d[x][0]=2,d[x][1]=3,rem = s2[st2--],c[x] = rem,s3[++st3] = rem,dfs(x+1,lim),s2[++st2] = rem,st3--;
}

int main(){
    // freopen("language.in","r",stdin);
    // freopen("language.out","w",stdout);
    in(n);
    scanf("%s",s+1);
    for(R int i=1; i<=n; ++i) to[n-i+1] = s[i]-'a'+1,s0[++st0]=i;
    for(R int i=1; i<=3*n; ++i) dfs(1,i);
    printf("NO");
}

```

---

## 作者：huangjiarui (赞：5)

截止本题解发布，本题现有四篇题解均有问题，故此处提出并给出修改方法。因本题算法较为简单，故本题解不给出题目简述和思路分析。同时本题解针对目前的一篇题解中的错误样例代码给出一组 hack 数据。

除本题解发布前 [第四篇题解](https://lyxzhz.blog.luogu.org/solution-p1139)，另外三篇题解的问题都是运行太慢了。

在随机数据下，$n=26$，这三篇题解均不能在限定时间内输出正确答案（随机数据下答案一般都是 NO）。

解决方法就是在迭代加深搜索的基础上增加剪枝：

1. （可行性剪枝）如果 A,B,C 中的火车总数大于剩下的步数，那么必然不可能在步数用完前使它们都进入 D，所以这种情况直接返回不可能。（这个剪枝在另一篇题解中出现）

2. （可行性剪枝）栈 C 中火车从栈 D 离开的时间必须是单调的，所以一个元素能移进栈 C 必须满足栈 C 为空或者移入 D 的时间早于栈 C 的栈顶元素。

3. （最优化剪枝）一个元素被连续两次操作移动是不优的。比如连续进行操作 `x A B`,`x B C` 在操作次数上必然不如直接进行操作 `x A C`。

4. （最优化剪枝）一个元素如果在某一个时刻可以移入 D，那么此时将它移入 B 或 C 都是不优的，因为这样会导致之后还需要至少一次将其移入 D，从而使得移动次数不可能最小。

加上以上剪枝后可以在限定时间内通过 $n=26$。目前本人代码在本题是最优解。代码如下（仅供参考）：

```
#include<cstdio>
char ch1[] = "AAABBC",ch2[] = "BCDCDD";
int ans[100],opt[100],st0[100],st1[100],st2[100],cnt0,cnt1,cnt2,t[100],n,flag;
char s[100];
bool dfs(int step,int last,int p)
{
	if (!step)
	{
		if ((cnt0|cnt1|cnt2) == 0)
		{
			for (int i = 1;i <= ans[0];++i)
				printf("%c %c %c\n",ans[i]+96,ch1[opt[i]],ch2[opt[i]]);
			return 1;
		}
		return 0;
	}
	if (cnt0+cnt1+cnt2 > step)
		return 0;
	int pre;
	++ans[0];
	if (cnt0)
	{
		pre = ans[ans[0]] = st0[cnt0],--cnt0;
		if (t[pre] == p+1)
		{
			opt[ans[0]] = 2;
			if (dfs(step-1,0,p+1))
				return 1;
		}
		else
		{
			st1[++cnt1] = pre;
			opt[ans[0]] = 0;
			if (dfs(step-1,1,p))
				return 1;
			--cnt1;
			if (!cnt2 || t[pre] < t[st2[cnt2]])
			{
				st2[++cnt2] = pre;
				opt[ans[0]] = 1;
				if (dfs(step-1,2,p))
					return 1;
				--cnt2;
			}
		}
		++cnt0;
	}
	if (cnt1 && last != 1)
	{
		ans[ans[0]] = pre = st1[cnt1],--cnt1;
		if (t[pre] == p+1)
		{
			opt[ans[0]] = 4;
			if (dfs(step-1,0,p+1))
				return 1;
		}
		else if ((!cnt2 || t[pre] < t[st2[cnt2]]))
		{
			st2[++cnt2] = pre;
			opt[ans[0]] = 3;
			if (dfs(step-1,2,p))
				return 1;
			--cnt2;
		}
		st1[++cnt1] = pre;
	}
	if (cnt2 && last != 2)
	{
		ans[ans[0]] = pre = st2[cnt2],--cnt2;
		if (t[pre] == p+1)
		{
			opt[ans[0]] = 5;
			if (dfs(step-1,0,p+1))
				return 1;
		}
		st2[++cnt2] = pre;
	}
	--ans[0];
	return 0;
}
int main()
{
	scanf("%d%s",&n,s),cnt0 = st0[n] = n;
	for (int i = 0;i < n;++i)
		t[s[i]-96] = n-i,st0[i] = i;
	for (int i = n;i <= n*3-1;++i)
		if (dfs(i,0,0))
		{
			flag = 1;
			break;
		}
	if (!flag)
		puts("NO");
	return 0;
}
```

至于本题解发布前 [第四篇题解](https://lyxzhz.blog.luogu.org/solution-p1139)，以下给出一个 hack 数据：
```
9
fdaebcihg
```
该题解中的参考代码输出了:
```
i A B
h A B
g A D
h B D
i B D
f A B
e A B
d A C
c A D
b A D
e B D
a A D
d C D
f B D
```

实际根据题目要求，步骤应当字典序最小，所以应输出：

```
i A B
h A B
g A D
f A C
e A C
h B D
i B D
d A B
c A D
b A D
e C D
a A D
d B D
f C D
```

其错误原因是一旦有元素可以移进 D 则立即操作，但这可能是不优的，此时先从 A 移出火车可能可以获得更小的字典序。

后注：在本题解提交前，经过测试（利用 assert），数据中 $n$ 的实际范围是 $n\le 15$，与题面描述 $n\le 26$ 不符，建议修改题面或者加强数据。

---

## 作者：wyp20130701 (赞：2)

很血腥的一个搜索，在如今快速的评测机和氧气优化下，大胆的暴力就好了。  
最多 $n \times 3$ 步操作，从 $1$ 开始枚举上限，，再去搜索。每搜索一次，都要判断出口 D 的情况和输入的一不一样。  
每次搜索有六种方式 $A \to B,A \to C,A \to D,B \to C,B \to D,C \to D$。
然后借助栈就完美地解决掉。

```
#include <iostream>
#include <stdio.h>
#include <cstring>
#include <algorithm>
#include <stack>

using namespace std;

struct data{
	int x , from , to;
};

stack < int > A , B , C , D;
stack < data > q;

int n;
int ans[30] , flag = 0;

void print(){
	data rec = q.top();
	q.pop();
	if(q.size()) print();
	printf("%c %c %c\n" , rec.x + 'a' - 1 , rec.from + 'A' - 1 , rec.to + 'A' - 1);
}

void dfs(int x , int lim){
	if(D.size() != 0) if(D.top() != ans[D.size()]) return;
	if(lim - x + 1 < n - D.size()) return;
	if(x - 1 == lim && A.empty() && B.empty() && C.empty()){ print(); exit(0); }
	if(x > lim) return;
	if(A.size()){
		q.push((data){A.top() , 1 , 2}) , B.push(A.top()) , A.pop(); dfs(x + 1 , lim); A.push(B.top()) , B.pop() , q.pop();
		q.push((data){A.top() , 1 , 3}) , C.push(A.top()) , A.pop(); dfs(x + 1 , lim); A.push(C.top()) , C.pop() , q.pop();
		q.push((data){A.top() , 1 , 4}) , D.push(A.top()) , A.pop(); dfs(x + 1 , lim); A.push(D.top()) , D.pop() , q.pop();
	}
	if(B.size()){
		q.push((data){B.top() , 2 , 3}) , C.push(B.top()) , B.pop(); dfs(x + 1 , lim); B.push(C.top()) , C.pop() , q.pop();
		q.push((data){B.top() , 2 , 4}) , D.push(B.top()) , B.pop(); dfs(x + 1 , lim); B.push(D.top()) , D.pop() , q.pop();
	}
	if(C.size()){
		q.push((data){C.top() , 3 , 4}) , D.push(C.top()) , C.pop(); dfs(x + 1 , lim); C.push(D.top()) , D.pop() , q.pop();
	}
}
		
	
int main(){
	cin >> n;
	for(int i = 1; i <= n; i++){
		A.push(i);
		char t; cin >> t;
		ans[n - i + 1] = t - 'a' + 1;
	}
	
	for(int i = 1; i <= n * 3; i++) dfs(1 , i);
	
	printf("NO");
	
	return 0;
}
```
**提示：不开氧气优化会超时一个点**。

---

## 作者：sto__Liyhzh__orz (赞：2)

[传送门](https://www.luogu.com.cn/problem/P1139)

~~真不知道为什么这是个蓝题？好水的搜索。~~

对于每次调度，若可以从此位置调度至后面的位置，可以就进行调度（~~我就说很简单吧~~）

啊等等，我再看眼数据范围，呀！$n \le 15$ 怎么办？会 `TLE` 掉。

考虑剪枝：

1. 由于火车到达出口不能往回走，答案已经固定了。在每次搜索时判断火车是否达到要求，否则跳出。

2. 若你还剩的调度次数比未到出口的火车数小，很明显，不能调度成功。

3. 若当前位置没有火车，你还搜不搜啊？肯定不搜啊！

在代码中我用到一个函数——`exit(0)`：这个可以表示直接结束**整个**程序，而不是跳出这个主函数或自定义函数，就跟 `main` 函数中的 `return 0` 差不多。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int MAXN=30;

int n,mb[MAXN],ans[MAXN],a[100],b[101],s[4][MAXN],cnt[4],j;
char s1[MAXN];

void dfs(int k)
{
    if(s[3][cnt[3]]!=mb[cnt[3]]) return;
    if(j-k+1<cnt[0]+cnt[1]+cnt[2]) return;
    if(k==j+1 && !cnt[0]+cnt[1]+cnt[2])
    {
        for(int i=1;i<k;i++) 
		{
			cout<<char(ans[i]+'a'-1)<<' '<<char(a[i]+'A')<<' '<<char(b[i]+'A')<<endl;
		}
        exit(0);
    }
    if(k>j) return;
    for(int i=0;i<=2;i++)
    {
        for(int j=i+1;j<=3 && cnt[i];j++)
        {
            int flag=s[i][cnt[i]--];
            ans[k]=s[j][++cnt[j]]=flag;
            a[k]=i,b[k]=j;
            dfs(k+1);
            s[i][++cnt[i]]=flag,cnt[j]--;   
        }
    }
}

int main()
{
    scanf("%d%s",&n,s1+1);
    for(int i=1;i<=n;i++) mb[n-i+1]=s1[i]-'a'+1,s[0][++cnt[0]]=i;
    for(j=n;j<=3*n;j++) dfs(1);
    printf("NO");
    return 0;
}
```

---

## 作者：MD_17L (赞：2)

1. 栈:a-A,b-B,c-C,d-D;开四个栈即可,分别对应A,B,C,D
1. 栈顶:topa,topb,topc,topd；
1. 初值topa=n,topb=topc=0,topd=1;
1. 用bool型p记录有移动方案
1. 剪枝(小心超时)
1. 回溯搜索
```cpp
	char stb[M],stc[M];
	pd(topa,topb,topc,topd,t);//判断是否能移动到目标站,能则进行记录
	t++;
	for (i=1; i<4; i++)
		switch (i)
		{
			case 1://A->B
				if (topa>0)
				{
					res[t].h=a[topa]; res[t].from='A'; res[t].to='B';
					for (j=0; j<=n; j++) stb[j]=b[j];
					topb++; b[topb]=a[topa]; topa--; 
					ss(topa,topb,topc,topd,t);
					for (j=0; j<=n; j++) b[j]=stb[j];
					topa++;  topb--;//恢复状态
				}
			break;
			case 2://A->C
				if (topa>0 && find(a[topa])<find(c[topc]))
				{
					res[t].h=a[topa]; res[t].from='A'; res[t].to='C';
					for (j=0; j<=n; j++) stc[j]=c[j];
					topc++; c[topc]=a[topa]; topa--;
					ss(topa,topb,topc,topd,t);
					for (j=0; j<=n; j++) c[j]=stc[j];
					topa++; topc--;
				}
			break;
			case 3://B->C
				if (topb>0 && find(b[topb])<find(c[topc]))
				{
					res[t].h=b[topb]; res[t].from='B'; res[t].to='C';
					for (j=0; j<=n; j++) stb[j]=b[j];
					for (j=0; j<=n; j++) stc[j]=c[j];
					topc++; c[topc]=b[topb]; topb--;
					ss(topa,topb,topc,topd,t);
					for (j=0; j<=n; j++) b[j]=stb[j];
					for (j=0; j<=n; j++) c[j]=stc[j];
					topb++; topc--;
				}
			break;
		}
```

代码如下
```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <algorithm>
using namespace std;
const int M=35;
 struct ss
{
	char h,from,to;	
};
ss ans[M],res[M];
char a[M],b[M],c[M],d[M];
int f[M],n,tot,t,topa,topb,topc,topd;
bool p;

 void change(char q,int &fro,int &too,int &t)
{
	char r;
	if (q=='A') r=a[fro];
	else if (q=='B') r=b[fro];
	else r=c[fro];
	too++; fro--;
	res[t].h=r; res[t].from=q; res[t].to='D'; 
}
 void pd(int &topa,int &topb,int &topc,int &topd,int &t)
{
	bool flag=true;
	while (flag)
	{
		flag=false;
		if (topd>n)
		{
			if (t<tot)
			{
				tot=t; p=true;
				for (int i=1; i<=tot; i++) ans[i]=res[i];
			}
			return;
		}
		if (a[topa]==d[topd])
		{
			t++; change('A',topa,topd,t); flag=true;
		}
		if (b[topb]==d[topd])
		{
			t++; change('B',topb,topd,t); flag=true;
		}
		if (c[topc]==d[topd])
		{
			t++; change('C',topc,topd,t); flag=true;
		}
	}
}
 int find(char s)
{
	if (s=='0') return 27;
	return f[s-96];
}
 void ss(int topa,int topb,int topc,int topd,int t)
{
	int i,j;
	char stb[M],stc[M];
	pd(topa,topb,topc,topd,t);
	t++;
	for (i=1; i<4; i++)
		switch (i)
		{
			case 1:
				if (topa>0)
				{
					res[t].h=a[topa]; res[t].from='A'; res[t].to='B';
					for (j=0; j<=n; j++) stb[j]=b[j];
					topb++; b[topb]=a[topa]; topa--; 
					ss(topa,topb,topc,topd,t);
					for (j=0; j<=n; j++) b[j]=stb[j];
					topa++;  topb--;
				}
			break;
			case 2:
				if (topa>0 && find(a[topa])<find(c[topc]))
				{
					res[t].h=a[topa]; res[t].from='A'; res[t].to='C';
					for (j=0; j<=n; j++) stc[j]=c[j];
					topc++; c[topc]=a[topa]; topa--;
					ss(topa,topb,topc,topd,t);
					for (j=0; j<=n; j++) c[j]=stc[j];
					topa++; topc--;
				}
			break;
			case 3:
				if (topb>0 && find(b[topb])<find(c[topc]))
				{
					res[t].h=b[topb]; res[t].from='B'; res[t].to='C';
					for (j=0; j<=n; j++) stb[j]=b[j];
					for (j=0; j<=n; j++) stc[j]=c[j];
					topc++; c[topc]=b[topb]; topb--;
					ss(topa,topb,topc,topd,t);
					for (j=0; j<=n; j++) b[j]=stb[j];
					for (j=0; j<=n; j++) c[j]=stc[j];
					topb++; topc--;
				}
			break;
		}
}

 int main()
{
	scanf("%d",&n);
	char q;
	for (int i=1; i<=n; i++) 
	{
		cin>>q;	
		d[n-i+1]=q;
		a[i]=i+96;
	}
	for (int i=1; i<=n; i++) f[d[i]-96]=i;
	tot=1000000000;
	a[0]='0'; b[0]='0'; c[0]='0'; 
	topa=n; topb=topc=0; topd=1;
	ss(topa,topb,topc,topd,0);
	if (!p) printf("NO\n");
	else 
	{
		for (int i=1; i<=tot; i++) 
		 	cout<<ans[i].h<<' '<<ans[i].from<<' '<<ans[i].to<<endl;
	}
	return 0;
}
```


---

## 作者：sangshang (赞：1)

## 搜索模板
不难想到，至少要调动 $n$ 次，最多要调动 $3n$ 次。

使用迭代加深搜索，从小到大枚举每次调动次数 $lim$，按最小字典序搜索。即 $A$ 到 $B$，$A$ 到 $C$，$A$ 到 $D$，$B$ 到 $C$，$B$ 到 $D$，$C$ 到 $D$。

找到答案输出并结束程序，枚举完 $lim$ 还没找到答案输出 `NO`。

## 剪枝

1. 如果剩余步数不足以将所有火车调度到 $D$，返回。

2. 如果 $D$ 点的火车顺序不合要求，返回，反正再搜下去也是错的。

3. 火车到达 $C$ 后，就只能等待进入 $D$ 点，因此新火车在进入站 $C$ 时，最终顺序不得被打乱，即，新火车排名要更小。

4. 显然如果火车能直接跳到 $D$，那就别浪费步数，直接跳到 $D$，此时没有再尝试别的车站的需要。注意，可能存在两种决策方式，决策后结果相同，花费步数也相同。如果先将合法火车调度到 $D$，在进行其他调度，字典序更大；如果先进行其他调度，再调度合法火车，字典序更小。因此，在进行此剪枝时，要将字典序最小的方案先搜一遍。但如果已经搜到了合法火车所在站点，就直接进行此剪枝，返回。因为之后不管怎么调度，都要先等合法火车进 $D$ 站，此时将合法火车调度到其他站点，不仅降低之后操作的灵活性，还**浪费步数**。

5. 从 $A$ 跳到 $B$，再从 $B$ 跳到 $C$，这明显是在浪费步数，不如直接从 $A$ 跳到 $C$。因此搜索时，记录一下上一步把节点调度到什么站，这次调度就不要在调度那个站。

经过上述优化，程序跑得飞快。附一下[提交记录](https://www.luogu.com.cn/record/139742473)。

## 代码

```cpp
#include <bits/stdc++.h>
#define maxn 31
//using namespace std;
int n, md[maxn], s[4][maxn], cnt[maxn], lim, from[maxn << 2], to[maxn << 2], ans[maxn << 2], Rank[maxn];
char str[maxn];

void dfs(int step, int last) {
	if (s[3][cnt[3]] != md[cnt[3]]) {
		return;
	}
	if (lim - step + 1 < n - cnt[3]) {
		return;
	}
	if (step == lim + 1 && !(cnt[0] + cnt[1] + cnt[2])) {
		for (int i = 1; i < step; ++i) {
			printf("%c %c %c\n", ans[i] + 'a' - 1, from[i] + 'A', to[i] + 'A');
		}
		exit(0);
	}
	if (step > lim) {
		return;
	}
	for (int i = 0; i <= 2; ++i) {
		if (i == last) {
			continue;
		}
		if (s[i][cnt[i]] == md[cnt[3] + 1]) {
			int tmp = s[i][cnt[i]--];
			ans[step] = s[3][++cnt[3]] = tmp;
			from[step] = i, to[step] = 3;
			dfs(step + 1, 3);
			s[i][++cnt[i]] = tmp, --cnt[3];
			return;
		}
		for (int j = i + 1; j <= 3 && cnt[i]; ++j) {
			if (j == 2) {
				if (cnt[2] && Rank[s[i][cnt[i]]] >= Rank[s[2][cnt[2]]]) {
					continue;
				}
			}
			int tmp = s[i][cnt[i]--];
			s[j][++cnt[j]] = ans[step] = tmp;
			from[step] = i;
			to[step] = j;
			dfs(step + 1, j);
			s[i][++cnt[i]] = tmp, --cnt[j];
		}
	}
}

int main() {
	scanf("%d%s", &n, str + 1);
	for (int i = 1; i <= n; ++i) {
		md[n - i + 1] = str[i] - 'a' + 1, s[0][++cnt[0]] = i, Rank[md[n - i + 1]] = n - i + 1;
	}
	for (lim = n; lim <= n * 3; ++lim) {
		dfs(1, -1);
	}
	puts("NO");
	return 0;
}
```


---

## 作者：huangmingyi (赞：1)

### 思路
1. 就是用栈，首先我们先看是不是不可能。把每一个数前面的放到第一个栈，把这个数移到出口。接着看下一个数在不在栈里，如果不在栈顶就输出不可能，（注意：可以把下一个放在第二个栈不行就输出）否则把这个数移到出口，以此类推。可以就把此过程输出。

2. 可以用迭代加深搜索（迭代：是重复反馈过程的活动，其目的通常是为了逼近所需目标或结果。每一次对过程的重复称为一次"迭代"，而每一次迭代得到的结果会作为下一次迭代的初始值。），因为每一个火车都要做 $1$ 次以上 $3$ 次一下的调度。所以我们枚举调度次数是从 $n$ 到 $3 \times n$ 即可。没有答案就输出不可能。每次需要调度时，先看能否从调度到后面的位置，如果可以的话就要进行调度。  

几个剪枝：   
1.每一辆火车只要到了出口就不可以往回了，所以就可以肯定我们的答案了。每次深度优先搜索时判断这符不符合标准，不是就直接退出。  
2.当前这个地方如果没有火车就不需要搜索了。
代码（无注释）：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,mb[32],ans[32],from[105],to[105],s[4][32],cnt[4],lim;
char c[32];
void dfs(int step){
    if(s[3][cnt[3]]!=mb[cnt[3]]){
        return;
    }
    if(lim-step+1<cnt[0]+cnt[1]+cnt[2]){
        return;
    }
    if(step==lim+1 && !cnt[0]+cnt[1]+cnt[2]){
        for(int i=1;i<step;i++){
			cout<<(char)(ans[i]+'a'-1)<<" "<<(char)(from[i] + 'A')<<" "<<(char)(to[i] + 'A')<<endl;
    	}
        exit(0);
    }
    if(step>lim){
        return;
    }
	for(int i=0;i<=2;i++){
		for(int j=i+1;j<=3 && cnt[i];j++){
			int flag=s[i][cnt[i]--];
			ans[step]=s[j][++cnt[j]]=flag;
			from[step]=i,to[step]=j;
			dfs(step+1);
			s[i][++cnt[i]]=flag;
			cnt[j]--;	
		}
	}
}

int main(){
    cin>>n; 
    for(int i=1;i<=n;i++){
        cin>>c[i]; 
    }
    for(int i=1;i<=n;i++){
        mb[n-i+1]=c[i]-'a'+1,s[0][++cnt[0]]=i;
    }
    for(lim=n;lim<=3*n;lim++){
        dfs(1);
    }
    cout<<"NO";
    return 0;
}
```


---

## 作者：FBW2010 (赞：0)

# 前言

[传送门](https://www.luogu.com.cn/problem/P1139)

本题是一道深搜与栈模拟的题。刚开始被题目颜色与各位 dalao 说的迭代加深搜索吓到了，后来发现普通深搜加一些剪枝也能过掉，便有了这篇题解。

# 思路

我们可以用 DFS 来枚举每一种操作，每次操作时会有两种情况：

1. $A$ 到 $C$ 车站中有一个能到 $D$。此时将那辆车直接移到 $D$ 即可。

2. 没有一辆车能到 $D$。此时只需要枚举 $3$ 种操作。

如果只是这样，那肯定会 TLE。这时我们需要引入一个重要的剪枝：**如果剩余的车数加上目前的操作次数超过了当前求出的最小次数，就直接退出。**

其余的详见代码。

# 代码

```cpp
#include<cstdio>
#include<iostream>
#include<stack>
using namespace std;
int n,minn=2e9;
char s[20];
stack<char> st[4]; // A到D车站 
struct node{
	char x;
	int l,r;
}t[105],ans[105]; // 答案与记录的数组 
void DFS(int x,int sum){
	// 剪枝 
	if(sum>=minn||x+1>=minn-sum)return; 
	
	// 所有车已到站 
	if(x<0){ 
		if(sum<minn){
			minn=sum;
			for(int i=1;i<=sum;i++){
				ans[i]=t[i];
			}
		}
		return;
	}
	
	// 有车能到D的情况 
	for(int i=1;i<=3;i++){
		if(!st[i].empty()&&st[i].top()==s[x]){
			char ch=st[i].top();
			t[sum+1].x=ch;
			t[sum+1].l=i;
			t[sum+1].r=4;
			st[i].pop();
			DFS(x-1,sum+1);
			st[i].push(ch);
			return;
		}
	}
	
	// 没有车能到的情况 
	for(int i=1;i<=2;i++){
		if(st[i].empty())continue;
		for(int j=i+1;j<=3;j++){
			char ch=st[i].top();
			t[sum+1].x=ch;
			t[sum+1].l=i;
			t[sum+1].r=j;
			st[j].push(ch);
			st[i].pop();
			DFS(x,sum+1);
			st[j].pop();
			st[i].push(ch);
		}
	}
}
int main(){
	// 初始化 
	scanf("%d\n%s",&n,s);
	for(char i='a';i<'a'+n;i++){
		st[1].push(i);
	}
	
	// 搜索 
	DFS(n-1,0);
	
	// 输出答案 
	if(minn==2e9)printf("NO");
	else{
		for(int i=1;i<=minn;i++){
			printf("%c %c %c\n",ans[i].x,char('A'+ans[i].l-1),char('A'+ans[i].r-1));
		}
	}
	return 0;
}
```

---

## 作者：sjr3065335594 (赞：0)

## 题意简述

给定 $n$ 个顺序排列的火车与其出站后的排列顺序，输出通过中间两个调度站（先进后出且不限里面车的数量）达到目标的具体方案。

## 思路

看到数据范围 $1<n<27$ 直接想到使用搜索。我们可以用四个字符串分别代表入口、两个调度站和出口的火车停放状态。

由于已经知道了目标状态，所以就能够知道每辆车是在第几个出站的，如样例中，出站顺序就一定是 `abc`。我们搜索的时候，找到目标状态中的最后一个字符，即这次要出站的是哪一辆车，然后在入口和两个调度站的字符串中寻找这个火车。找到后，分为两种情况处理：

1. 当这辆车在最上边（或最前边，意思就是可以直接开出来）时，直接开到出口即可。

2. 当这辆车的上边或前边还有车没开走，那就先把它们开走。

当出口的字符串全部被搜过一遍就可以统计答案了。

可以看看代码，有注释。

## 代码实现

```cpp
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <string>
#include <algorithm>
using namespace std;
#define rep(i,n) for (int i = 0 ;i<n;i++)
string s1="abcdefghijklmnopqrstuvwxyz",s2="",s3="",s4;
string s[1000],st[1000];
int n,ans = 1e9;
bool flag= 0 ; 
void find(string s1,string s2,string s3,string s4,int dep)
{    
    if (dep>=ans) return ; //剪枝，若当前深度已经大于之前算出的答案，就没有继续搜下去的必要了，因为答案不会更优
    int len1=s1.size() , len2=s2.size(), len3=s3.size(),len4=s4.size();  
    if (len1+len2+len3+len4==0){//所有车都搜索完了就更新答案
        ans=dep;
        rep(i,ans) st[i]=s[i]; //可以更新答案就更新，因为更大的（更劣的）答案已经在上边的if过滤掉了
        flag=true;//确定有答案，便于判断是否无解 
    }  else {
        string p;p=s4[len4-1];//取出这次要出站的车
        int l1=s1.find(p)+1 , l2=s2.find(p)+1, l3=s3.find(p)+1;//在ABC三个地方找到这辆车
        if (l1>0){//如果在A这里
            if (l1==s1.size()){ //直接可以开出来就直接开出来           
                s[dep]=p+" A D";
                find(s1.erase(len1-1,1),s2,s3,s4.erase(len4-1,1),dep+1);
            }
            else {//开不出来的话就先把前边的车开到B或者C里
                  string ss;
                  ss=s1[len1-1];
                  s[dep]=ss+" A B";//这个字符串直接存储操作步骤，下边同理
                  find(s1.erase(len1-1,1),s2+ss,s3,s4,dep+1);//记得在搜的时候把这次搜的字符给删掉             
                  s[dep]=ss+" A C";
                  find(s1.erase(len1-1,1),s2,s3+ss,s4,dep+1);
            } 
        }         
        if (l2>0){//如果在B这里
            if (l2==s2.size()){//直接可以开出来就直接开出来
                s[dep]=p+" B D";               
                find(s1,s2.erase(len2-1,1),s3,s4.erase(len4-1,1),dep+1);
            }
            else {//不行的话就直接开到C里，注意不能开回A，答案不会因为开回A而更优
                  string ss;
                  ss=s2[len2-1];
                  s[dep]=ss+" B C";
                  find(s1,s2.erase(len2-1,1),s3+ss,s4,dep+1);
            } 
        }
        if (l3>0)//如果在C这里
            if (l3==s3.size()){//直接开出来
                s[dep]=p+" C D";
                find(s1,s2,s3.erase(len3-1,1),s4.erase(len4-1,1),dep+1);
            }//这里也不用把车往回开
    }    
}
int main(){
    cin>>n;s1= s1.substr(0,n) ; //s1初始化为a-z，然后根据n取前n位即可   
    cin>>s4;          
    find(s1,s2,s3,s4,0);//s1-4指的是A,B,C,D四个地方的状态
    if (!flag) cout<<"NO"<<endl; //如果没有找到答案就是无解
    else rep(i,ans) cout<<st[i]<<endl; //输出答案
    return 0;
}

```


---


# 最多因子数

## 题目背景

本题疑似错题。

## 题目描述

数学家们喜欢各种类型的有奇怪特性的数。例如，他们认为 $945$ 是一个有趣的数，因为它是第一个所有约数之和大于本身的奇数。

为了帮助他们寻找有趣的数，你将写一个程序扫描一定范围内的数，并确定在此范围内约数个数最多的那个数。不幸的是，这个数和给定的范围的都比较大，用简单的方法寻找可能需要较多的运行时间。所以请确定你的算法能在几秒内完成最大范围内的扫描。

## 说明/提示

update: 2024/6/6 加上了 6 组 hack。

## 样例 #1

### 输入

```
1000 2000```

### 输出

```
Between 1000 and 2000, 1680 has a maximum of 40 divisors.```

# 题解

## 作者：chenxinyang2006 (赞：15)

貌似现在的题解都被hack了，这个题是无解的，那就只能分块 + 打表了

**不保证本程序会不会被卡TLE，但是不会WA**

具体就是，把查询分成一些整体块和零散块（分块思想）
  
然后处理整体块时直接调用打好的表的数据，零散块暴力

那么首先肯定需要一个求任意数约数个数的函数：

```cpp
inline int get(int x){//这个是求最小质因子
	for(int i = 2;i * i <= x;i++){
		if(x % i == 0) return i;
	}
	return x;//如果1 ~ sqrt(x)没有约数，那么这是个质数，返回自己
}

inline int calc(int x){
	int total = 1,cnt = 0;
	while(x != 1){
		int p = get(x);
	    cnt = 0;
	    while(x % p == 0){
			x /= p;
			cnt++;
		}
		total *= (cnt + 1);//常用的那个约数公式
	}
	return total;
}
```
然后考虑进行分块，块长一般是$\sqrt n$比较合适，然后写个暴力开始打表，具体大概这样：

```cpp
for(i = 1;i <= 31623;++i){
		int id = L(i),ans = 0,tmp;//id是约数最多的数的编号，ans是约数数量
		for(j = L(i);j <= R(i);++j){
			tmp = calc(j);
			if(tmp > ans){
				id = j;
				ans = tmp;
			}
		}
		printf("%d,",id);
}
```

然后你就会发现怎么跑了2h还是没结果……，而且怎么表长轻轻松松超过50K交不了……

没错，这个时代，打表也需要优化了

首先先解决内存问题，先考虑调大块长减少打表数量，建议调到$3 \times \sqrt n$的样子，再大边角部分会TLE

然而这样还是会超

所以要先减去左边界，存与这个块左边界的差来压缩长度，再转字符串进一步压缩一下

注意不是所有ASCIL码都可以直接显示的，所以有些不能直接转

所以建议设计一套“密码”来转换，反正压到一个数三位就问题不大

然后优化下效率

现在分解质因数的效率显然太低了，可以直接线性筛出每个数的最小质因子，然后一直 /= 最小质因子，这样一个数只需要$log(x)$次就分解完了

实际上你肯定开不下$10 ^ 9$的数组，所以还得稍微改下

生成器：

```cpp#include <cstdio>
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#define from(x) (((x) % 94866 == 0) ? ((x) / 94866) : ((x) / 94866 + 1))
#define L(x) (((x) - 1) * 94866 + 1)
#define R(x) ((x) * 94866)
int HIS[400000005];

inline int get(int x){
	for(int i = 2;i * i <= x;i++){
		if(x % i == 0) return i;
	}
	return x;
}

inline int calc(int x){
	if(x == 1) return 1;
	int total = 1,cnt = 0;
	int p = get(x);
	if(x <= 400000000) HIS[x] = p;
		
	do{
	    cnt = 0;
	    while(x % p == 0){
			x /= p;
			cnt++;
		}
		total *= (cnt + 1);
		if(x <= 400000000){
			p = HIS[x];
		}else{
			p = get(x);
		}
	}while(x != 1);
	return total;
}
char password[100] = {'#','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','1','2','3','4','5','6','7','8','9','0',';',':',',','.','(','?','<','>','[',']','{','}'};

inline char C(int x){
	return password[x];
}

inline int X(char c){
	for(int i = 0;i <= 74;i++){
		if(c == password[i]) return i;
	}
}

int main(){
	freopen("upd.cpp","w",stdout);
	HIS[1] = 1;
	for(int i = 2;i <= 400000000;i++){
		if(HIS[i]) continue;
		else HIS[i] = i;
		for(int j = i * 2;j <= 400000000;j += i){
			if(!HIS[j]) HIS[j] = i;
		}
	}
	register int i,j;
	for(i = 1;i <= 10541;++i){
		int id = L(i),ans = 0,tmp;
		for(j = L(i);j <= R(i);++j){
			tmp = calc(j);
			if(tmp > ans){
				id = j;
				ans = tmp;
			}
		}
		printf("%c%c%c",C((id - L(i)) / 5476),C((id - L(i)) / 74 % 74),C((id - L(i)) % 74));
	}
	return 0;
}
```

code：

```cpp
#include <bits/stdc++.h>
using namespace std;
string answer("");//这里被和谐了

int l,r;

inline int get(int x){
	for(int i = 2;i * i <= x;i++){
		if(x % i == 0) return i;
	}
	return x;
}

inline int calc(int x){
	int total = 1,cnt = 0;
	while(x != 1){
		int p = get(x);
	    cnt = 0;
	    while(x % p == 0){
			x /= p;
			cnt++;
		}
		total *= (cnt + 1);
	}
	return total;
}

#define from(x) (((x) % 94866 == 0) ? ((x) / 94866) : ((x) / 94866 + 1))
#define L(x) (((x) - 1) * 94866 + 1)
#define R(x) ((x) * 94866)

char password[100] = {'#','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','1','2','3','4','5','6','7','8','9','0',';',':',',','.','(','?','<','>','[',']','{','}'};
int change[260];//快速还原，不然会TLE

char C(int x){
	return password[x];
}

int X(char c){
	return change[c];
}

int main(){
	for(int i = 0;i <= 74;i++){
		change[password[i]] = i;//预处理一下每个还原的位置
	}
	int id = 1,ans = 1;
	scanf("%d%d",&l,&r);
	int x = from(l),y = from(r);
	if(x == y){//特判相同块
		for(int i = l;i <= r;i++){
			int tmp = calc(i);
	      	if(tmp > ans){
	    		id = i;
	    		ans = tmp;
	    	}
		}
	    printf("Between %d and %d, %d has a maximum of %d divisors.\n",l,r,id,ans);
	    return 0;
	}
	for(int i = l;i <= R(x);i++){
		int tmp = calc(i);
		if(tmp > ans){
			id = i;
			ans = tmp;
		}
	}
	for(int i = L(y);i <= r;i++){
		int tmp = calc(i);
		if(tmp > ans){
			id = i;
			ans = tmp;
		}
	}
	for(int i = x + 1;i <= y - 1;i++){
		int Z = X(answer[3 * i - 2]) * 5476 + X(answer[3 * i - 1]) * 74 + X(answer[3 * i]);
		int Q = L(i) + Z;
		int tmp = calc(Q);
		if(tmp > ans){
			id = Q;
			ans = tmp;
		}
	}
	printf("Between %d and %d, %d has a maximum of %d divisors.\n",l,r,id,ans);
	return 0;
}
```

![](https://cdn.luogu.com.cn/upload/image_hosting/676py04s.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

作为福利，顺便发一下打出来的[表](https://www.luogu.com.cn/paste/bdk9vbbt)

你还可以来做做[这个](https://www.luogu.com.cn/problem/U103401)

---

## 作者：lahlah (赞：11)

[传送门](https://www.luogu.org/problemnew/show/P1221)

这题的思路嘛。。。。

其实就是爆搜。

首先我们要知道，一个数X可以被分解为X=2^m1∗3^m2∗5^m3∗...∗n^mk

相信聪明的大家都能理解（注：n为质数）

当分解完后，X的个数为(m1+1)∗(m2+1)∗(m3+1)∗...∗(mk+1)

根据乘法原理，选1个，2个……m1个，为啥是m1+1？还可以不选haha

我们只需把质数预处理出来，然后暴力填m1,m2,m3，……，mk即可

加上一点小剪枝

代码：（卡常大法好）
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 10005;
const int INF = 1000000007;
ll _[N],prime[N],size,ansp=INF,ansd,anss[N],l,r;
//p 素数 2 3 5 7 (第几个质因子)
//all已经搜索到的k的因子的乘积
//last上一个的p的指数 
inline void dfs(int p,ll all,ll last){
    if(l<=all&&all<=r){//满足要求
        int o=1;
        for(register int i=1;i<p;i++){//算出约数个数
            o=o*(anss[i]+1);
        }
        if(o>ansd||(o==ansd&&all<ansp)){//最小
            ansd=o;
            ansp=all;
        }
    }
    if(all>ansp) return;//最优性剪枝
    ll lin[100]={0};
    lin[0]=1;
    for(register int i=1;i<=last;i++) lin[i]=lin[i-1]*prime[p];//预处理
    for(register int i=last;i>=1;i--){//从后往前，更高效
        anss[p]=i;	
        dfs(p+1,all*lin[i],i);
    }
}
void bao_li_chu_qi_ji(){//只可会意，不可言传
    for(int i=l;i<=r;i++){
        int ret=0;
        for(int j=1;j*j<=i;j++){
            if(i%j==0) ret+=2;
            if(j*j==i) ret--;
        }
        if(ret>ansd){
            ansp=i;
            ansd=ret;
        }
    }
}
int main(){
    for(register int i=2;i<=sqrt(N);i++){//先把质数筛出来
        for(register int j=2;j*i<N;j++){
            _[i*j]=1;  
        }
    }
    for(register int i=2;i<=N;i++){ //同上
        if(!_[i]) prime[++size]=i;
    }
    scanf("%lld%lld",&l,&r);
    ll w=log(r);
    if(r-l<5000) bao_li_chu_qi_ji();//只可会意，不可言传（因为如果范围太小这种方法会gg，自己体会一下吧）
    else dfs(1,1,w);
    printf("Between %lld and %lld, %lld has a maximum of %lld divisors.\n",l,r,ansp,ansd);
    return 0;
}
```
跑得还是挺快的，[哈哈](https://www.luogu.org/record/show?rid=8474978)

[偷偷安利自己的blog](https://mp.csdn.net/postlist)

---

## 作者：我去 (赞：10)

# 反素数

[推荐和本蒟蒻博客一起食用](https://blog.csdn.net/qq_44822425/article/details/100083605)

# 1.定义
>"于任何正整数x，其约数的个数记作g(x)。例如g(1)=1、g(6)=4。
如果某个正整数x满足：g(x)>g(i)，0<i<x，则称x为反质数。例如，整数1，2，4，6等都是反质数。"      
>  　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　     　　　　　　　　　————度娘说的

什么意思呢？用自己的~~口水~~话解释一下：对于一个数 $x$，如果从$1$ 到 $(x-1)$这几个数中没有任意一个数的因数个数大于$x$的，那么就称$x$为**反素数**。
其实，反素数的本质就是**尽可能地让因子数量最大，但是数值最小。**

# 2.性质
从反素数的定义可以发现凡是反素数都满足两个性质：
 

 - 性质一：对于所有反素数$x={a_1}^{b_1} *{a_2}^{b_2}*{a_2}^{b_2}*···*{a_k}^{b_k}$,则必有$b_1\ge b_3\ge ···\ge b_k$  
  这点很好理解，借助贪心的思想我们思考：**首先要让因子数量尽可能的多，只需要把质因数的次数变多，或者质因数变多。但是还得满足让数值尽可能的小，那么就要让小的质因数的次数尽可能的大**
 - 性质二：**一个反素数的质因子必然是从2开始连续的质数**
举个例子：$6=2*3,10=2*5$ $6$和$10$因子数目相同，显然$6$更小。直接跳过一个小一点的质数，放一个大的质数显然会使数值变得更大。


# 3.例题 
大致思路是：**从最小的质数（2）开始用$Dfs$枚举每个质数的指数，根据性质一，指数应是不上升的。每次$Dfs$传递四个值：**

 - deep：枚举到第几个质数了
 - arr：当前质数的最大指数（*当前指数*$\leq$*上一个质数的指数*）
 - cur：从开始枚举到当前共有多少因数
 - num：从开始枚举到当前所有枚举的质数组成的数（幂之后相乘）

**每次$Dfs$开始时传递的值是上一次枚举的结果，所以先保存值，再判定边界，最后循环枚举。**

```cpp
void Dfs(int deep,int arr,int cur,ll num){
	if(maxn<cur||(maxn==cur&&num<ans))
		maxn=cur,ans=num;
	if(deep>8)
		return;
	for(register int i=1;i<=arr;i++){
		num*=prime[deep];
		if(num>r)
			return;
		Dfs(deep+1,i,cur*(i+1),num);
	}
}
```

---
**那边界又是什么呢？应该枚举多少个质数呢？**（先去看看下面的完整代码吧）
我们注意到有关边界的有四处：

 - >if(num>n)
 　　　这个好理解：当这次枚举的结果超过范围了，自然不用向下枚举了，return。
 - >ll prime[15]={2,3,5,7,11,13,17,19,23,29,31,37};  
   > if(deep>9)
　　　为什么只需要这９(prime[0]~prime[8])个质数呢？ 原因很简单：首先，因为是反素数，所以因数要多，数本身值要小，所以是前9个质数。其次，我们把每9个质数都只取一个，此时组成的数已是223,092,870了，再多1个29的话就会超过范围2,000,000,000了。~~（其实多算几个也没错）~~ 
 - >Dfs(0,31,1,1);
 　　　为什么第一个初值传31呢？ 原因也很简单：第一个质数是2，那最多能选多少个2相乘呢？ ——31个，$2^{31}=2,147,483,648$恰好大于范围。

-----

 **这。。。这不是暴力吗？？  要这个干嘛？**
 ```cpp
if(r-l<=100000){
		for(register ll i=l;i<=r;i++){
			cnt=0;
			for(register int j=1;j*j<=i;j++)
				if(i%j==0){
					cnt++;
					ll temp=i/j;
					if(i%temp==0&&temp!=j)
						cnt++;
				}
			if(cnt>maxn)
				ans=i,maxn=cnt;
		}
	}
```


**首先，这个暴力的复杂度在一定范围内是可以接受的。问题就来了不是有$Dfs$了吗？还要暴力做什么？ 我们思考这样一种~~毒瘤数据~~ 情况，当L，R相距很近时，在这个区间中不存在反素数，但仍有答案。这种数据出现在枚举的区间很小情况下，便可以用暴力解决。至于区间多大时该用暴力，这个没有固定的值，只有根据题的范围来确定，不过我通常用100,000 or 200,000。**

----

AC代码
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<string>
using namespace std;
typedef long long ll;

template <typename T>
inline void read(T&x){
	x=0;int temp=getchar();bool f=false;
	while(temp<'0'||temp>'9'){if(temp=='-') f=true; temp=getchar();}
	while(temp>='0'&&temp<='9'){x=(x<<1)+(x<<3)+temp-'0'; temp=getchar();}
	if(f) x=-x;
}

ll prime[15]={2,3,5,7,11,13,17,19,23,29,31,37,41};
ll l,r;
ll maxn=0,ans,cnt;

void Dfs(int deep,int arr,int cur,ll num){
	if(maxn<cur||(maxn==cur&&num<ans))
		maxn=cur,ans=num;
	if(deep>8)
		return;
	for(register int i=1;i<=arr;i++){
		num*=prime[deep];
		if(num>r)
			return;
		Dfs(deep+1,i,cur*(i+1),num);
	}
}

int main(){
	read(l),read(r);
	if(r-l<=100000){
		for(register ll i=l;i<=r;i++){
			cnt=0;
			for(register int j=1;j*j<=i;j++)
				if(i%j==0){
					cnt++;
					ll temp=i/j;
					if(i%temp==0&&temp!=j)
						cnt++;
				}
			if(cnt>maxn)
				ans=i,maxn=cnt;
		}
	}
	else
		Dfs(0,31,1,1);
	printf("Between %lld and %lld, %lld has a maximum of %lld divisors.",l,r,ans,maxn);
	return 0;
}

```


---

## 作者：luqyou (赞：6)

~~被回文题号吸引过来的~~

整体数据范围：$ 2\le L\le U\le10^9 $。

直接一个个暴搜肯定不行，但是如果把一个数因数分解的话，$10^9$ **以内最多不会超过** $30$ **个**，那么我们可以考虑搜索质因子。把一个数表示成质因数幂的形式为：

　　$\boxed{A=x^{p1} _ 1\times x^{p2} _ 2\times x^{p3} _ 3...\times x^{pn} _ n}$

　　则该数的约数个数为 $(p1+1)\times (p2+1)\times (p3+1)\times...\times (pn+1)$，根据这个公式来检验当前答案是否最优。

　　不过要注意，数据中一个点 $131074$ 会出锅，因为 $131074$ 分解质因数是 $2\times 65537$，我们搜索的时候只考虑 $100$ 以内的质数（否则会 TLE），所以**需要特判**一下。

　　当然这种做法很轻松就可以 Hack 掉，不过数据很水就是了。~~光速逃~~

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll L,R,ans,tot,c[27];
ll s[27]={0,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,91,97};
inline void check(ll sum)
{
    ll ret=1;
    for(int i=1;i<=26;++i)ret*=(c[i]+1);
    if(ret>tot)tot=ret,ans=sum;
    if(ret==tot)ans=min(sum,ans);
}
inline void dfs(ll sum,int sta)
{
    if(sum>R)return;
    if(sum>=L&&sum<=R)check(sum);
    for(int i=sta;i<=26;++i){
        ++c[i];
        dfs(sum*s[i],i);
        --c[i];
    }
}
int main()
{
    scanf("%lld%lld",&L,&R);
    if(L==R&&L==131074){
        printf("Between %lld and %lld, %lld has a maximum of 4 divisors.",L,R,L);
        return 0;
    }
    dfs(1,1);
    printf("Between %lld and %lld, %lld has a maximum of %lld divisors.",L,R,ans,tot);
    return 0;
}
```

---

## 作者：无尽 (赞：5)

这是一道需要有些技巧的搜索题

数字的因子数，不一定要因数分解，

可以使质因数相乘，得到数字；

所以只需搜索质因数即可；

然后记录数字的因数数字个数，找出其拥有最大个数因数数字即可

我们学校考试时写的，有点乱...别在意

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
using namespace std;
int num,ans,l,r,Max;
int a[50000];
bool notprime[100000];
int b[50000],c[50000];
void hhh()//求出其质数
{
  for(int i=2;i<=40000;i++)//之所以是40000，因为30000平方小于1000000000而40000平方大于
    {
      if(!notprime[i])
    {
      a[++num]=i;
      int j=i<<1;
      while(j<=40000)
        {
          notprime[j]=true;
          j+=i;
        }
    }
    }
}
void dfs(long long h,long long ji,long long noww)//搜索
{
  int i,t;
  long long x;
  if(h>num) return;
  if(ji>r) return;
  t=int(log(r/double(ji))/log(double(a[h])));
  if(noww*(1<<t)<ans) return;
  if(ji>=l&&(noww>ans||(noww==ans&&ji<Max)))
    {
        ans=noww;
        Max=ji;
    }
  x=1;
  for(i=1;i<=t;i++) x*=a[h];
  for(i=t+1;i>=1;i--)
    {
      dfs(h+1,ji*x,noww*i);
      x/=a[h];
    }
}
int main()
{
  freopen("divisors.in","r",stdin);
  freopen("divisors.out","w",stdout);
  scanf("%d%d",&l,&r);
  if(l==1&&r==1)
    {
      Max=1;
      ans=1;
    }
  else
    {
      if(r-l>=10000)//这是正解
    {
      hhh();
      dfs(1,1,1);
    }
      else//怕正解错而打的暴力
    {
      for(int i=l;i<=r;i++)
        {
          int tem=2;
          for(int j=2;j*j<=i;j++)
        {
          if(j*j==i) tem++;
          else if(i%j==0) tem+=2;
        }
          if(tem>ans)
        {
          ans=tem;
          Max=i;
        } 
        }
    }
    }
  printf("Between %d and %d, %d has a maximum of %d divisors.\n",l,r,Max,ans);
  return 0;
}
```

---

## 作者：Wenxiang_MCL (赞：3)

首先，这是一道暴搜题，主要是考对因数个数性质的了解；

首先介绍一个公式每一个整数n都可以由质数相乘得到

可得n = a1 ^ t1 \* a2 ^ t2 \* a3 ^ t3 .... an ^ tn,则n因子的个数则为(t1 + 1) \* (t2 + 1) \* (t3 + 1) ... \*(tn + 1);

其中a1 --- an 为质数;

得到这个公式后，便可以开始暴搜

唯一的算得上剪枝的地方就是在枚举时递增枚举；

下面上代码:

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <cstdlib>
#include <algorithm>
using namespace std;
const int factor[] = {0,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,87,91,97};//100以内的素数表
int divi[30];//存储指数t
long long int up,down,ans,cnt;
void dfs(long long int num,int sta);
void ccount(long long int num);
void ccount(long long int num){
    long long int cnum = 1;
    for(int i = 1;i <= 26;i ++){
        cnum *= (divi[i] + 1);
    }
    if(cnum > cnt) cnt = cnum,ans = num;
    if(cnum == cnt) ans = min(num,ans);
```
}//计算质因子个数
```cpp
void dfs(long long int num,int sta//sta防止重复){
    if(num > up) return;
    if(num <= up && num >= down){//满足条件，计算
        ccount(num);
    }
    for(int i = sta;i <= 26;i ++){//枚举所有质因子
        divi[i] ++;
        dfs(num * factor[i],i);
        divi[i] --;
    }
}
int main (){
    scanf("%lld%lld",&down,&up);
    if(down == up && up == 131074){//小小的特判，因为这个数好像撞到了100以上的质数，如果想过的话可以求出更大的质数
        ans = 131074,cnt = 4;
        printf("Between %lld and %lld, %lld has a maximum of %lld divisors.",down,up,ans,cnt);
        return 0;
    }
    dfs(1,1);
    printf("Between %lld and %lld, %lld has a maximum of %lld divisors.",down,up,ans,cnt);
    return 0;
}
```

---

## 作者：人间凡人 (赞：3)

#### 题意：

给定范围 $l$ 与 $r$ ，求在 $[l,r]$ 这一段区间里因子个数最多的数以及它的因子个数。

#### 思路：

因为 $l$ 和 $r$ 都到了 $10^9$ 级别，所以一个个枚举过去肯定不行，这时候**小奥**就起了很大的帮助。

我们都知道，若一个数为 $a[1]      
^{p[1]}*a[2]^{p[2]}*...*a[n]^{p[n]}$ ，那么它的因子个数就为$\prod_{i=1}^n{p[i]+1} $ 

所以我们可以枚举质数以及每个质数的指数，如果相乘大于等于 $l$ 且小于等于 $r$，那么就比较答案，若因子个数比答案大或者与答案相等但是数比答案小，那么就更新答案，最后输出即可。

$2*3*5*7*11*13*17*19*23*29>10^9$
#### 注意：

因为有些数据可能涉及到了 $100$ 以外的质数，大家可以打一张质数的表来解决。

$Code:$

```cpp
#include<bits/stdc++.h>
#define N 1000000000
using namespace std;
int a[10005];
int l,r,tot;
bool flag[100005];
long long temp,ans,anss,sum;
void Solve(int x,long long s,long long ans){
    temp=s;
    if(s>=l&&s<=r){
        if(ans>sum){sum=ans;anss=s;}
        else if(sum==ans&&s<anss)anss=s;
    }
    if(x==tot+1)return;
    if(s*a[x]>r)return;
    int num=0;
    while(temp*a[x]<=r){
        temp=temp*a[x];
        num++;
        Solve(x+1,temp,ans*(num+1));
    }
    Solve(x+1,s,ans);
}
void Init(){
	memset(flag,false,sizeof(flag)); 
	for(int i=2;i<=sqrt(N);i++)
		if(flag[i]==false){
			a[++tot]=i;
			for(int j=2;j<=sqrt(N)/i;j++)
				flag[i*j]=true; 
		}
}
int main(){
	Init();
    scanf("%d%d",&l,&r);
    Solve(1,1,1);
    printf("Between %d and %d, %lld has a maximum of %lld divisors.\n",l,r,anss,sum);
    return 0;
}
```


---

## 作者：SegTree (赞：2)

$\text{upd 2022.07.16}$ 为通过[这一道加强版](https://www.luogu.com.cn/problem/U103401)重新修改代码，同时修正部分笔误。

不保证能通过数据范围下所有数据。

[将素数筛到 $50000$ 时的记录](https://www.luogu.com.cn/record/79789362)。

[题目传送门。](https://www.luogu.com.cn/problem/P1221)

## 题目分析
如果直接暴力枚举上界与下界的因数个数并比较，复杂度过高，不可接受。

考虑直接打表输出 $1$ 到 $10^9$ 的因数轻轻松松 `MLE` 且超过 $50\text{KB}$。

考虑分段打表。

以 $10^6$ 为一段，从 $1$ 一直枚举到 $10^9$，输出的表的第 $i$ 项表示 $10^6\times (i-1)+1$ 到 $10^6\times i$ 中因数最多的数及它的因数个数。

但是你会发现程序运行得很慢……所以可以先写一个程序计算 $1$ 到 $3\times 10^4$ 中的所有质数，打表存在打表程序里，枚举时直接从 `pr[]` 数组中的质数判断，减少了运行时间，之后就从 $3\times 10^4+11$ 开始枚举。（而这时该数可能已经变小很多）

```cpp
#include<bits/stdc++.h>
using namespace std;
const int pr[]={};
inline int fun(int a){
    int ans=1;
    for(int i=1;i<sizeof(pr)/sizeof(int)&&pr[i]*pr[i]<=a;++i){
        int cnt=1;
        while(a%pr[i]==0)cnt++,a/=pr[i];
        ans=ans*cnt;
    }
    for(int i=30011;i*i<=a;++i){
        int cnt=1;
        while(a%i==0)cnt++,a/=i;
        ans=ans*cnt;
    }
    if(a!=1)ans<<=1;
    return ans;
}
signed main(){
	printf("{{0,0},") ;
    int l=1,r=1e9,maxn=-1,ans;
    for(int i=l;i<=r;++i){
        if(fun(i)>maxn)maxn=fun(i),ans=i;
        if(i%1000000==0){
            printf("{%d,%d}",ans,maxn);
            if(i!=r)printf(",");
            else printf("}");
            maxn=-1;
        }
    }
    return 0;
}
```
最后计算，如果 $\lfloor \dfrac{l}{10^6}\rfloor=\lfloor\dfrac{u}{10^6}\rfloor$，就进行暴力。

否则在将 $l$ 到 $\lceil\dfrac{l-1}{10^6}\rceil\times 10^6$ 和 $\lfloor\dfrac{u}{10^6}\rfloor\times 10^6+1$ 到 $u$ 暴力求解，枚举表中 $\lceil\dfrac{l-1}{10^6}\rceil$ 到 $\lfloor\dfrac{u}{10^6}\rfloor$ 即可。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int pr[]={};
int fun(int a) {   
    int ans=1;
    for(int i=1;i<sizeof(pr)/sizeof(int)&&pr[i]*pr[i]<=a;++i){
        int cnt=1;
        while(a%pr[i]==0)cnt++,a/=pr[i];
        ans=ans*cnt;
    }
    for(int i=30011;i*i<=a;++i){
        int cnt=1;
        while(a%i==0)cnt++,a/=i;
        ans=ans*cnt;
    }
    if(a!=1)ans<<=1;
    return ans;
}
int a[][2]={};
signed main(){
    int l,u,j,maxn=-1,ans;
    scanf("%d %d",&l,&u);
    if(l/1000000==u/1000000){
        for(register int i=l;i<=u;++i){
            int x=fun(i);
            if(x>maxn)maxn=x,ans=i;
        }
    }
    else {
        for(j=l;;++j){
            if(j%1000000==1)break;
            int x=fun(j);
            if(x>maxn)maxn=x,ans=j;
        }
        for(register int i=j/1000000+1;i<=u/1000000;++i){
            if(a[i][1]>maxn)maxn=a[i][1],ans=a[i][0];
        }
        for(register int i=u/1000000*1000000+1;i<=u;++i){
            int x=fun(i);
            if(x>maxn)maxn=x,ans=i;
        }
    }
    printf("Between %d and %d, %d has a maximum of %d divisors.",l,u,ans,maxn);
    return 0;
}
```
由于代码较长，`pr[]` 数组和 `a[][]` 数组在这里无法给出，请去[这里](https://www.luogu.com.cn/problem/U228570)下载。

评测记录：[不吸氧](https://www.luogu.com.cn/record/79787094)，[吸氧](https://www.luogu.com.cn/record/79787759)。

---


# 黑白棋游戏

## 题目描述

黑白棋游戏的棋盘由 $4 \times 4$ 方格阵列构成。棋盘的每一方格中放有 $1$ 枚棋子，共有 $8$ 枚白棋子和 $8$ 枚黑棋子。这 $16$ 枚棋子的每一种放置方案都构成一个游戏状态。在棋盘上拥有 $1$ 条公共边的 $2$ 个方格称为相邻方格。一个方格最多可有 $4$ 个相邻方格。在玩黑白棋游戏时，每一步可将任何 $2$ 个相邻方格中棋子互换位置。对于给定的初始游戏状态和目标游戏状态，编程计算从初始游戏状态变化到目标游戏状态的最短着棋序列。

## 说明/提示

由 @zhouyonglong 提供 SPJ


## 样例 #1

### 输入

```
1111
0000
1110
0010
1010
0101
1010
0101
```

### 输出

```
4
1222
1424
3242
4344
```

# 题解

## 作者：Andorxor (赞：48)

此题的关键点：

1.状态转换：由于只有01，并且二进制对应的十进制的值是唯一的，因此可以考虑将数组使用对应的十进制来进行保存，如此一来，判重也很容易实现。（因为最大的数是二进制16个1，也就是2^16-1，不会超空间）

2.搜索策略：任何一种状态都需要从16个位置作为起点开始进行扩展，扩展后合法的子状态全部加入队列中，再从队列中取出队首值进行扩展，当然同样需要把这个队首值从16个位置均考虑作为起点开始扩展，获取到的所有合法的子状态......

3.记录结果：由于判重的原因，每一个数的父节点必然是唯一的，因此可从终点（目标状态）出发，往前找其父节点的值并保存，记录当前的节点坐标和父节点的坐标，输出的时候就可以从终点不断往前面推出路径。

4.处理结果：通过（3）处理得到的结果是从终点出发的，当然可以通过简单的代码操作实现输出正解。

细节较多，需要细致写代码（要敢于动手），代码注释中有关键步骤的解释，可参考代码理解以上思路。

```cpp
#include<bits/stdc++.h>
using namespace std;
char c;
int csz,mbz,cnt,a[5][5],b[5][5],vis[65540],father[65540],res[100000][4];
int dx[4]={-1,1,0,0},dy[4]={0,0,-1,1};
struct Ans{
	int nx,ny,ox,oy,father;
}ans[100000];
queue<int>q;

//初始化输入起点和目标点
void init(){
	for(int i=1;i<=4;i++){
		for(int j=1;j<=4;j++){
			cin>>c;
   			a[i][j]=c-'0';
		}
	}
	for(int i=1;i<=4;i++){
		for(int j=1;j<=4;j++){
			cin>>c;
   			b[i][j]=c-'0';
		}
	}
}
//获取4*4数组二进制得到十进制数
int getDeci(int a[5][5]){
	int comb=0,cnt=0;
	for(int i=4;i>=1;i--){
		for(int j=4;j>=1;j--){
			comb+=a[i][j]*pow(2,cnt);
			cnt++;
		}
	}
	return comb;
}
//根据x修改a数组的值
void updateArr(int x,int a[5][5]){
	while(x){
		for(int i=4;i>=1;i--){
			for(int j=4;j>=1;j--){
				a[i][j]=x%2;
				x/=2;
			}
		}
	}
}
//判断是否越界且父子值要不同
bool legal(int ox,int oy,int nx,int ny){
	if(nx>=1&&nx<=4&&ny>=1&&ny<=4&&a[ox][oy]!=a[nx][ny]) 
		return true;
	else    return false;
}
void bfs(){
	q.push(csz);//从初始值开始扩展
	vis[csz]=1;
	while(!q.empty()){
		int exted=q.front();  //exted用来存储每次被扩展的数
		updateArr(exted,a);  //将a数组修改为当前被扩展的数对应的二进制
		q.pop();
		for(int i=1;i<=4;i++){  //每一种状态的数都要分别以它的十六个点为起点来进行扩展
			for(int j=1;j<=4;j++){
				int ox=i,oy=j;
				for(int k=0;k<4;k++){
					int nx=ox+dx[k],ny=oy+dy[k];
					 //标记是否有执行swap，以决定是否需要再次执行swap还原a数组状态
					int flag=0;   
					if(legal(ox,oy,nx,ny)){
						flag=1;
						int fdeci=getDeci(a);   //当前被扩展的值（当前被扩展出来的节点的父节点的值）
						swap(a[ox][oy],a[nx][ny]);
						int deci=getDeci(a);    //swap后的a数组对应的十进制值
						if(!vis[deci]){
							vis[deci]=1;
							ans[deci].father=fdeci; //存储路径
							ans[deci].nx=nx,ans[deci].ny=ny;
							ans[deci].ox=ox,ans[deci].oy=oy;
							father[deci]=fdeci;
							q.push(deci);
						}
						if(deci==mbz)   //扩展得到了目标节点
							return;
					}
					if(flag)            //需要还原a数组状态
						swap(a[ox][oy],a[nx][ny]);
				}
			}
		}
	}
}
int main(){
	init();
	csz=getDeci(a),mbz=getDeci(b);//csz：初始值，mbz：目标值
	bfs();
	father[csz]=0;
	while(father[mbz]){ //从目标节点往前推路径并存储到res数组中
		cnt++;
		res[cnt][0]=ans[mbz].ox,res[cnt][1]=ans[mbz].oy,res[cnt][2]=ans[mbz].nx,res[cnt][3]=ans[mbz].ny,
		mbz=father[mbz];
	}
	cout<<cnt<<endl;
	for(int i=cnt;i>=1;i--) //从起点--->终点的交换过程
		cout<<res[i][0]<<res[i][1]<<res[i][2]<<res[i][3]<<endl;
	return 0;
}
```

代码仅供一种思路参考（**不要抄袭，没有任何意义**），能够写出来AC的同学可尝试进一步使用双向bfs进行优化。

---

## 作者：_zy_ (赞：26)

 [啊哈，是题目](https://www.luogu.com.cn/problem/P1225)

#### 这道题的小细节多的一批，且待我慢慢道来。

毕竟我偷偷在英语早读上想着我可能出错的原因。

-------
#### 先说一下大思路吧，很显然也很经典的问题。将给出的4*4的$01$矩阵转成二进制的整形，跑$bfs$。

- 关于二进制转换的小细节和具体操作：

1.~~一开始我$re$了一片~~
	
   	存一个临时操作的数组b，二进制转换成为b；
    
    再由b数组转成整形，就这样跳来跳去，跳来跳去。
    
   ```cpp
void Exc(int x) {
	memset(b,0,sizeof(b)  //我re的原因，忘记将b数组清0
	int cnt1=n,cnt2=n;
	while(x) {
		if(x&1)	b[cnt2][cnt1--]='1';
		else	b[cnt2][cnt1--]='0';
		if(cnt1==0)	{
			cnt1=n;
			cnt2--;
		}
		x>>=1;
	}
	return ;
}
int Bine() {
	int tmp=0; int cnt=0;
	for(int i=n;i>=1;i--)
		for(int j=n;j>=1;j--)	{
			if(b[i][j]=='1') tmp+=1<<cnt;
			cnt++;
		}	
	return tmp;
}

```

 不过一定要将b数组清0啊！！

不过一定要注意顺序到底是正序还是倒序a！！


- 关于$bfs$的具体实现：

将拓展到的新的元素加入到队中即可

~~嘤嘤嘤，A掉后才发现原来上下和左右只需要分别打一个就可以了~~

因为拓展枚举每个点时，上面的点向下换和下面的点向上换是一样的，同理左右

1.操作不在阐释

2.维护的奇奇怪怪东西

		自然而然得有此时的值
        
      	自然而然你还要记录方式：由谁拓展而来，如何拓展而来
  
  		自然而然还要有拓展了几步
      
 ```cpp
	     q[++tail][0]=p;
		q[tail][1]=q[head][1]+1;
		q[tail][2]=head;
```
3.血的教训（大概九十吧，~~毕竟我一开始是九十~~）：一定要先入队再Judge，不然可能会少一个路径。


代码冗长,不在展开

-关于路径的输出：


我们已经存下了队尾所对应的队首，

递归输出就好。

```cpp
void Print(int x) {
	if(!q[x][2])	return ;
	Print(q[x][2]);
	printf("%d%d%d%d\n",e[x].x,e[x].y,e[x].xx,e[x].yy);
```

### 一些奇奇怪怪的细节
记得特判；

记得b数组的清0；

记得看清操作的坐标+1或者是-1；

记得先入队再Judge；

记得边界小心一点处理；

好啦好啦，给你们代码；

~~最后在偷偷给你们一个小小的手玩数据~~

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<queue>
#include<map>
#define N 4000010
using namespace std;
int goal,a,head,tail;
char G[5][5],A[5][5],b[5][5];
int q[N][4];
struct  zy {
	int x,y;
	int xx,yy;
}e[N];
const int n=4;
map<int ,bool > v;
void Exc(int x) {
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)	b[i][j]='0';
	int cnt1=n,cnt2=n;
	while(x) {
		if(x&1)	b[cnt2][cnt1--]='1';
		else	b[cnt2][cnt1--]='0';
		if(cnt1==0)	{
			cnt1=n;
			cnt2--;
		}
		x>>=1;
	}
	return ;
}
int Bine() {
	int tmp=0; int cnt=0;
	for(int i=n;i>=1;i--)
		for(int j=n;j>=1;j--)	{
			if(b[i][j]=='1') tmp+=1<<cnt;
			cnt++;
		}	
	return tmp;
}
void Print(int x) {
	if(!q[x][2])	return ;
	Print(q[x][2]);
	printf("%d%d%d%d\n",e[x].x,e[x].y,e[x].xx,e[x].yy);
}
void Judge(int x) {
	if(x==goal)	 {
		printf("%d\n",q[tail][1]);
		Print(tail);
		exit(0);
	}
	return ;
}
void Up() {
	for(int i=2;i<=n;i++)
		for(int j=1;j<=n;j++)
		{
			swap(b[i][j],b[i-1][j]);
			int p=Bine();
			swap(b[i][j],b[i-1][j]);
			if(v[p])	continue;
			q[++tail][0]=p;	
			q[tail][1]=q[head][1]+1;
			q[tail][2]=head;
			e[tail].x=i; e[tail].y=j;
			e[tail].xx=i-1; e[tail].yy=j;
			Judge(p);
			v[p]=1;
		}
}
void Down() {
	for(int i=1;i<=n-1;i++)
		for(int j=1;j<=n;j++)
		{
			swap(b[i][j],b[i+1][j]);
			int p=Bine();
			swap(b[i][j],b[i+1][j]);
			if(v[p])	continue;
			q[++tail][0]=p;
			q[tail][1]=q[head][1]+1;
			q[tail][2]=head;
			e[tail].x=i; e[tail].y=j;
			e[tail].xx=i+1; e[tail].yy=j;
			Judge(p);
			v[p]=1;
		}
}
void Left() {
	for(int i=1;i<=n;i++)
		for(int j=2;j<=n;j++)
		{
			swap(b[i][j],b[i][j-1]);
			int p=Bine();
			swap(b[i][j],b[i][j-1]);
			if(v[p])	continue;
			q[++tail][0]=p;
			q[tail][1]=q[head][1]+1;
			q[tail][2]=head;
			e[tail].x=i; e[tail].y=j;
			e[tail].xx=i; e[tail].yy=j-1;
			Judge(p);
			v[p]=1;
		}
}
void Right() {
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n-1;j++)
		{
			swap(b[i][j],b[i][j+1]);
			int p=Bine();
			swap(b[i][j],b[i][j+1]);
			if(v[p])	continue;
			q[++tail][0]=p;
			q[tail][1]=q[head][1]+1;
			q[tail][2]=head;
			e[tail].x=i; e[tail].y=j;
			e[tail].xx=i; e[tail].yy=j+1;
			Judge(p);
			v[p]=1;
		}
}
void Bfs(int x)
{
	q[++tail][0]=x;
	v[x]=1;
	Judge(x);
	while(head<tail)
	{
		int now=q[++head][0];
		Exc(now); 
		Judge(now);
		Up();Down();Left();Right();
	}
}
int main()
{
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)	cin>>A[i][j],b[i][j]=A[i][j];
	a=Bine();
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)	cin>>G[i][j],b[i][j]=G[i][j];
	goal=Bine();
	Bfs(a);
	return 0;
}
/*
0000
0001
0100
0001
1000
0000
0011

*/


```

### 题解不易，如有不妥之处或是不明白的，随时也欢迎提醒我。

[双倍经验](https://www.luogu.com.cn/problem/P4289)

---

## 作者：getchar123 (赞：21)

思路：广搜+map去重，map里存过程（其实可以不用这样，~~我只是为了偷懒，不想往回推~~）就这样了，其余的看注释。
代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
queue<string>q;
string a,b;
map<string,string>m;
void yy(int i,string ss){//上下换
	string sss=ss;
	char c;
	c=ss[i];
	ss[i]=ss[i+4];
	ss[i+4]=c;
	if(m.count(ss)==0){
		q.push(ss);
		char aa=49+i/4,bb=49+i%4,cc=50+i/4,dd=49+i%4;//这里的横竖坐标都是从0开始的，存进去要加1
		m[ss]=m[sss]+aa+bb+cc+dd;
	}
	return;
}
void xx(int i,string ss){//左右换
	string sss=ss;
	char c;
	c=ss[i];
	ss[i]=ss[i+1];
	ss[i+1]=c;
	if(m.count(ss)==0){
		q.push(ss);
		char aa=49+i/4,bb=49+i%4,cc=49+i/4,dd=50+i%4;
		m[ss]=m[sss]+aa+bb+cc+dd;
	}
	return;
}
//考虑四个方向会重复，所以只需考虑两个方向，这里是右和下。
void bfs(){
	q.push(a);
	m[a]="";
	while(q.empty()==false){
		string ss=q.front();
		for(int i=0;i<16;i++){
			if(i<12){//不是最后一行就和下面换
				yy(i,ss);
			}
			if(i%4!=3){//不是最后一列就和右边换
				xx(i,ss);	
			}
		}
		if(m.count(b)!=0){//出现目标序列
			cout<<m[b].size()/4<<endl;
			for(int j=0;j<m[b].size();j++){
				cout<<m[b][j];
				if(j%4==3)cout<<endl;//每输出四个换一行
			}
			return;
		}
		q.pop();
	}
	return;
}
int main(){
	for(int i=0;i<16;i++){
		char c;
		cin>>c;
		a+=c;
	}
	for(int i=0;i<16;i++){
		char c;
		cin>>c;
		b+=c;
	}
	bfs();
	return 0;
}
```

---

## 作者：yybyyb (赞：16)

%%管理员大佬加了SPJ

我还是来写一个题解吧

（有了SPJ就不用在意顺序了）

大致的思路：状压+BFS

BFS是很显然的(要求最短的变幻)

使用状压一是提速，二是节约内存

状压能够把O(16)的判重优化到O（1）

因此状压是很重要的一点。

剩下的具体实现有好几个细节

我就直接放代码吧

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<queue>
#include<algorithm>
using namespace std;
bool vis[(1<<16)];//状态
struct Node
{
     int t;//状态
     int st;//步数
     int ff;//父节点 
     int pos;//交换的位置
     int way;//交换的方式 
};
int Beg,End;
int h,t,s;
Node Q[(1<<20)];//手写队列 
inline int read()
{
    //register int x=0,t=1;
    register char ch=getchar();
    while(ch<'0'||ch>'9')ch=getchar();
    //if(ch=='-'){t=-1;ch=getchar();}
    //while(ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
    return ch-48;
}
int change(int s,int Pos,int sw)
//交换，s表示当前状态,Pos表示位置，sw表示移动的位置
//其中1向右，-1向左，-4向上，4向下 
{
         int a=bool(s&(1<<(Pos-1)));//检查是0还是1
         int b=bool(s&(1<<(Pos+sw-1)));//同上
         if(a==b)return -1;//没有交换的必要
         if(a)
                  s=s-(1<<(Pos-1))+(1<<(Pos+sw-1));
         else
                 s=s+(1<<(Pos-1))-(1<<(Pos+sw-1));
         return s;
}
void outp(int t)//输出
{
         vector<Node> Ans;Ans.clear();
         cout<<Q[t].st<<endl;
         while(t!=1)
         {
                  Ans.push_back(Q[t]);
                  t=Q[t].ff;
         }
         for(int i=Ans.size()-1;i>=0;--i)
         {  
                 //cout<<Ans[i].pos<<' '<<Ans[i].way<<endl;
                 printf("%d%d%d%d\n",(Ans[i].pos+3)/4,(Ans[i].pos%4!=0?Ans[i].pos%4:4),
                                     (Ans[i].pos+Ans[i].way+3)/4,
                                     (Ans[i].pos+Ans[i].way)%4!=0?(Ans[i].pos+Ans[i].way)%4:4);
         }
}
int main()
{
    for(int i=1;i<=16;++i)
        Beg=Beg+(read()<<(i-1));
    for(int i=1;i<=16;++i)
        End=End+(read()<<(i-1));
    
    Q[1]=(Node){Beg,0,0,0,0};
    h=0,t=1;
    while(h<t)
    {
             ++h;
             Node now=Q[h];
             
             for(int i=1;i<=12;++i)//枚举每个位置 
                 if(true)//向下交换
                 {
                         s=change(now.t,i,4);
                         if(s==-1)continue;//没有必要交换 
                         if(vis[s])continue;//已经访问过 
                         vis[s]=true;//标记访问过
                        Q[++t]=(Node){s,now.st+1,h,i,4};//记录 
                        if(s==End)//到达终点
                        {
                               outp(t);
                               return 0;
                        } 
                 }
                 
             for(int i=1;i<=15;++i)//枚举每个位置 
                    if(i%4!=0)//向右交换
                 {
                         s=change(now.t,i,1);
                         if(s==-1)continue;//没有必要交换 
                         if(vis[s])continue;//已经访问过 
                         vis[s]=true;//标记访问过
                        Q[++t]=(Node){s,now.st+1,h,i,1};//记录 
                        if(s==End)//到达终点
                        {
                               outp(t);
                               return 0;
                        }  
                 }
             for(int i=2;i<=16;++i)//枚举每个位置 
                    if(i%4!=1)//向左交换
                 {
                         s=change(now.t,i,-1);
                         if(s==-1)continue;//没有必要交换 
                         if(vis[s])continue;//已经访问过 
                         vis[s]=true;//标记访问过
                        Q[++t]=(Node){s,now.st+1,h,i,-1};//记录 
                        if(s==End)//到达终点
                        {
                               outp(t);
                               return 0;
                        }  
                 }
                 
             for(int i=5;i<=16;++i)//枚举每个位置 
                 if(true)//向上交换
                 {
                         s=change(now.t,i,-4);
                         if(s==-1)continue;//没有必要交换 
                         if(vis[s])continue;//已经访问过 
                         vis[s]=true;//标记访问过
                        Q[++t]=(Node){s,now.st+1,h,i,-4};//记录 
                        if(s==End)//到达终点
                        {
                               outp(t);
                               return 0;
                        } 
                 }

    }
    cout<<"No Answer!"<<endl;
    return 0;
}
```

---

## 作者：租酥雨 (赞：14)

这种题目一看就是打搜索，状态种类有限，广搜的空间可以接受。这里主要讲解两个点：状压，以及双向BFS。先说状压。

我们规定一下棋盘：

15 14 13 12

11 10  9  8

7  6  5  4

3  2  1  0

棋盘上每一个棋子对应的权值等于2的n次方(n是位置编号) ，那么一个棋盘的状态就可以用它对应的二进制数来表示，这个二进制数转十进制后最大为2^16-1，即65535。所以开一个大小为2^16的bool型数组就好了。

左右交换或上下交换，就是把第n位数字和第n-1位交换(n%4!=0) 或把第n位数字和第n-4位交换(n>=4) ，这里用到了位运算的方法，我们只要把需要交换的两位分别**按位与(&)**上位置编号所对应的二进制数，就得到了关于这一位上的数的信息，再将这个结果**左移/右移(<</>>)**，进行常规的加减运算，就可以得到新生成状态的二进制数。实现如下：

f=num&B[k];

b=num&B[k-1];

n=num+(f>>1)-f+(b<<1)-b;

这里以左右交换为例。num是原节点的二进制数，f，b是需要交换的两位，B数组是一个二进制表(打表^\_^)，n是新生成节点的二进制数。通过“减去原来的，加上更新的”就可以得到新节点。

再讲讲双向BFS。对于这题来说，我们把常规BFS中的所有数组都开两遍（包括head，tail指针），再附上下标[0]，[1]，这样可以方便调用。一般而言双向BFS有一个模板，大体如下：

```cpp
while (head[0]<tail[0]&&head[1]<tail[1])
    {
        BFS(0);
        if (key) break;
        BFS(1);
        if (key) break;
    }
```
其中key可以控制程序在找到解后直接结束，避免不必要的循环。BFS函数中基本按原先广搜的模板去打，只是记得所有的东西都要加上01下标表示哪一边的队列。
这里还讲一个小技巧：交换相邻的两个棋子，通常会考虑四个方向交换，但明显会发生重复。我们就只考虑和右边的棋子交换，或者和下面的棋子交换，可以减少重复。

有一个问题在于输出，双向BFS对于这道题的输出略显麻烦，这里采用了递归调用输出，可以参照代码理解一下。

讲了这么多，我们终于看见了代码、(个人记录双向BFS跑了42ms，欢迎各路大佬破纪录)





```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int B[16]={1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768};
int P[16]={44,43,42,41,34,33,32,31,24,23,22,21,14,13,12,11};
int h[2][65536];//对应hash码
bool vis[2][65536];
int g[2][65536];
int fa[2][65536];//对应父节点
int p[2][65536];//记录上一步变换得来的位置(始终是左上点) 
bool d[2][65536];//记录上一步是左右交换(0)还是上下交换(1) 
int head[2],tail[2]={1,1};
int start,target,s,key;
void print0(int n)
{
    if (n==start) return ;
    print0(fa[0][n]);
    int a=p[0][n],b=p[0][n]-1-3*d[0][n];
    printf("%d%d\n",P[a],P[b]);
}
void print1(int n)
{
    if (n==target) return ;
    int a=p[1][n],b=p[1][n]-1-3*d[1][n];
    printf("%d%d\n",P[a],P[b]);
    print1(fa[1][n]);
}
void record(int n)
{
    printf("%d\n",g[0][n]+g[1][n]);
    print0(n);
    print1(n);
}
void BFS(int x)
{
    head[x]++;
    int num=h[x][head[x]];
    int f,b,n;
    for (int k=15;k>=0;k--)
    {
        if (k%4!=0)//左右交换 
        {
            f=num&B[k];
            b=num&B[k-1];
            n=num+(f>>1)-f+(b<<1)-b;
            if (vis[x][n]==0)
            {
                tail[x]++;
                h[x][tail[x]]=n;
                vis[x][n]=1;
                g[x][n]=g[x][num]+1;
                fa[x][n]=num;
                p[x][n]=k;
                d[x][n]=0;
            } 
        }
        if (vis[0][n]&&vis[1][n]) 
        {
            record(n);
            key=1;
            return;
        }
        if (k>=4)//上下交换 
        {
            f=num&B[k];
            b=num&B[k-4];
            n=num+(f>>4)-f+(b<<4)-b;
            if (vis[x][n]==0)
            {
                tail[x]++;
                h[x][tail[x]]=n;
                vis[x][n]=1;
                g[x][n]=g[x][num]+1;
                fa[x][n]=num;
                p[x][n]=k;
                d[x][n]=1;
            } 
        }
        if (vis[0][n]&&vis[1][n]) 
        {
            record(n);
            key=1;
            return;
        }
    }
}
int main()
{
    //freopen("black and white.in","r",stdin);
    for (int i=15;i>=0;i--)
    {
        scanf("%1d",&s);
        start+=s<<i;
    }
    for (int i=15;i>=0;i--)
    {
        scanf("%1d",&s);
        target+=s<<i;
    }
    h[0][1]=start;h[1][1]=target;
    vis[0][start]=1;vis[1][target]=1;
    while (head[0]<tail[0]&&head[1]<tail[1])
    {
        BFS(0);
        if (key) break;
        BFS(1);
        if (key) break;
    }
    return 0;
}

```

---

## 作者：dz_ice (赞：8)

本题要用bfs

这道题的重点也就是判重了，棋盘只有0和 1两种情况，所以可以把棋盘看作一个16位的二进制数，二进制数对应的十进制数的值是唯一的，所以可以用一个b数组来判重，如果棋盘所对应的十进制数为num，那么b[num]=1。

输出结果的话，加了SPJ就不用考虑顺序问题，因此在广搜扩展节点的时候，记录每个节点的父节点和父节点到子节点的路径，输出时可以从终点往前搜索路径。

```
#include<bits/stdc++.h>
using namespace std;
char a[5][5];
int num2[17]= {0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768}; //用于将二进制数转换为十进制
int b[80000],road[80000][5],vis,c[18],q[80000][18],hd,tl=1,sum,ans[80000]; //b数组判重，road数组记录路径和父节点，vis记录答案，q数组模拟队列，ans数组用于输出答案 
void print(int t)
{
	cout<<q[t][0]<<endl; //输出路径总数 
	int l=t,o=q[t][0]; 
	while(o!=0) 
	{
		ans[o]=l,l=road[l][0];
		o--; 
	} //往前搜索路径 
	for(int i=1; i<=q[t][0]; i++)
	{
		for(int j=1; j<=4; j++)
			cout<<road[ans[i]][j];
		cout<<endl;
	} //输出路径 
	return;
}
int main()
{
	for(int i=1; i<=4; i++)
		for(int j=1; j<=4; j++)
		{
			cin>>a[i][j];
			q[1][(i-1)*4+j]=a[i][j]-'0',sum+=(a[i][j]-'0')*num2[(i-1)*4+j]; 
		} //输入，并将起点棋盘转化为二进制数存储在数组，再转化为十进制 
	b[sum]=1,sum=0;
	for(int i=1; i<=4; i++)
		for(int j=1; j<=4; j++)
		{
			cin>>a[i][j];
			vis+=(a[i][j]-'0')*num2[(i-1)*4+j]; //记录终点棋盘 
		}
	while(hd<tl)
	{
		hd++;
		for(int i=1; i<=16; i++)
		{
			if(i<=12) //上下交换 
			{
				sum=0;
				for(int j=1; j<=16; j++)
					c[j]=q[hd][j];
				c[i+4]=q[hd][i],c[i]=q[hd][i+4]; //交换 
				for(int j=1; j<=16; j++)
					sum+=c[j]*num2[j]; //计算 
				if(b[sum]==0)
				{
					tl++,q[tl][0]=q[hd][0]+1,b[sum]=1; 				
					for(int j=1; j<=16; j++)
						q[tl][j]=c[j]; //扩展节点 	
					road[tl][0]=hd,road[tl][1]=(i-1)/4+1,road[tl][2]=(i-1)%4+1,road[tl][3]=road[tl][1]+1,road[tl][4]=(i-1)%4+1; //记录路径和父节点 
					if(sum==vis) //如果到达终点棋盘 
					{
						print(tl);
						return 0;
					}
				}
			}			
			if(i%4!=0) //左右交换 
			{
				sum=0;
				for(int j=1; j<=16; j++)
					c[j]=q[hd][j];
				c[i+1]=q[hd][i],c[i]=q[hd][i+1]; //交换 
				for(int j=1; j<=16; j++)
					sum+=c[j]*num2[j]; //计算 
				if(b[sum]==0)
				{
					tl++,q[tl][0]=q[hd][0]+1,b[sum]=1; 	 					
					for(int j=1; j<=16; j++)
						q[tl][j]=c[j]; //扩展节点
					road[tl][0]=hd,road[tl][1]=(i-1)/4+1,road[tl][2]=(i-1)%4+1,road[tl][3]=road[tl][1],road[tl][4]=(i-1)%4+2; //记录路径和父节点 
					if(sum==vis) //如果到达终点棋盘 
					{
						print(tl);
						return 0;
					}
				}
			}
		}
	}
	return 0;
}
```


---

## 作者：Ivystorm (赞：7)

翻完了整个题解，发现好像没有一个人写$DFS$的。让我来给大家普及一下如何用$DFS$ $29ms+0.8MB$ 优雅地跑过这道题。

定义$1$为棋子，$0$为空地，题目原意不变。

首先提取出所有初始和目标不同的点，存起来，初始为$1$的点为起点，目标为$1$的点为终点，然后用$DFS$枚举所有的可能性。$DFS$不记录过程的时间复杂度为$O(2^{16})$，可以接受。

而如何记录方案呢？

重定义走：当目的没有棋子时，直接移动和交换的效果是一样的。

发现如果路上没有其他棋子就可以直接走过去，而有棋子的话我们就可以先把挡路的棋子移到自己的目的地，然后自己移到挡路棋子的位置。可证明这是最优方案。

代码：

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int jd(int a){//求绝对值
    return ((a>0)?a:-a);
}
int map1[10][10];//初始
int map2[10][10];//目标
struct point{
       int x,y;
}needmove[20],moveto[20];
int operator - (const point a,const point b){//曼哈顿距离
    return jd(a.x-b.x)+jd(a.y-b.y);
}
bool operator != (const point a,const point b){
     return !((a.x==b.x)&&(a.y==b.y));
}
bool operator == (const point a,const point b){
     return (a.x==b.x)&&(a.y==b.y);
}
int tovis[20];
int l1,l2;
int minn=10000;
int minwei[1000];//最优方案记录

int nowwei[1000];//当前状况记录
int toin(int a,int b,int c,int d){//坐标转数字
    return (a+1)*1000+(b+1)*100+(c+1)*10+(d+1);
}
int isit(point x){//当前这个地方是否有其他棋子
    return map1[x.x][x.y];
}
int ln;
point pu(point ne,point to){//把ne位置的棋子移到to，返回上一个棋子需要移动到的位置
     if(ne!=to){
       if(ne.x>to.x)
         to=pu((point){ne.x-1,ne.y},to);
       else
       if(ne.x<to.x)
         to=pu((point){ne.x+1,ne.y},to);
       else
       if(ne.y>to.y)
         to=pu((point){ne.x,ne.y-1},to);
       else
       if(ne.y<to.y)
         to=pu((point){ne.x,ne.y+1},to);
       //先递归移走前面的在自己移
       if(isit(ne)){
         point xsxs=ne;
         while(ne!=to){
              if(ne.x>to.x){
                nowwei[ln]=toin(ne.x,ne.y,ne.x-1,ne.y);
                ne.x--;
              }
              else
              if(ne.x<to.x){
                nowwei[ln]=toin(ne.x,ne.y,ne.x+1,ne.y);
                ne.x++;
              }
              else
              if(ne.y>to.y){
                nowwei[ln]=toin(ne.x,ne.y,ne.x,ne.y-1);
                ne.y--;
              }
              else
              if(ne.y<to.y){
                nowwei[ln]=toin(ne.x,ne.y,ne.x,ne.y+1);
                ne.y++;
              }
              ln++;
         }
         return xsxs;//如果当前这个地方有棋子就让上一个棋子移动到这里
       }
       else
         return to;//否则移动到目的地
     }
     else
       return to;
}
void dfs(int nowmove,int v){
     if(v>minn)//剪枝
       return;
     if(nowmove==l1){//最优状态记录
       minn=v;
       for(int i=0;i<v;i++)
          minwei[i]=nowwei[i];
       return;
     }
     for(int i=0;i<l2;i++)//枚举所有情况
        if(!tovis[i]){
          tovis[i]=1;
          int bfl=ln;
          pu(needmove[nowmove],moveto[i]);
          int qqc=v+jd(needmove[nowmove].x-moveto[i].x)+
                    jd(needmove[nowmove].y-moveto[i].y);
          map1[needmove[nowmove].x][needmove[nowmove].y]=0;
          map1[moveto[i].x][moveto[i].y]=1;
          dfs(nowmove+1,qqc);
          map1[needmove[nowmove].x][needmove[nowmove].y]=1;
          map1[moveto[i].x][moveto[i].y]=0;
          ln=bfl;
          tovis[i]=0;
        }
}
int main(){
    char junk;
    for(int i=0;i<4;i++)
       for(int j=0;j<4;j++){
          junk=getchar();
          if(junk!='1'&&junk!='0'){
            j--;
            continue;
          }
          map1[i][j]=junk-'0';
       }
    for(int i=0;i<4;i++)
       for(int j=0;j<4;j++){
          junk=getchar();
          if(junk!='1'&&junk!='0'){
            j--;
            continue;
          }
          map2[i][j]=junk-'0';
          if(map2[i][j]!=map1[i][j]){
            if(map1[i][j])
              needmove[l1++]=(point){i,j};
            else
              moveto[l2++]=(point){i,j};
          }
       }
    dfs(0,0);
    cout<<minn<<endl;
    for(int i=0;i<minn;i++)
       cout<<minwei[i]<<endl;
    return 0;
}
```

---

## 作者：George1123 (赞：6)

[${\color{#a000e0}\text{欢迎拜访我这个蒟蒻的博客}}$](https://www.luogu.org/blog/Wendigo/)

 [P1225 【黑白棋游戏】](https://www.luogu.org/problem/P1225)

### 此题算法:$Bfs$+状态压缩转移

此题简单版: [P4289 【HAOI2008】移动玩具](https://www.luogu.org/problem/P4289)

大致思路:

>1.$ $将一个状态包装成结构体$statu$。$lst$表示这个状态的上一个状态，$sta$表示这一个状态，$g$表示走到这个状态用的步数，用$read()$函数读入一个$statu$。

![](https://s2.ax1x.com/2019/11/01/KbEvDJ.jpg)



```cpp
struct statu{
	int lst,sta,g;
	statu(){sta=0;}
	void read(){
		int bit;
		scanf("%d",&bit);
		bit=bit/1000*8
		+bit/100%10*4
		+bit/10%10*2+bit%10;
		sta=sta*16+bit;
	}
}
```
>2.$ $从初始状态$now$开始$Bfs$。令$vis[]$数组为状态的最少步数以去重(未出现过的状态数组值为$-1$)。$ant[][]$记录从上一个状态到此状态的移动方案。顺便用$statu$类型的$rec[]$数组记录每个状态对应的$statu$。

>3.$ $每次交换肯定交换异色棋，枚举状态中的每个黑子，与四个方向中的白子交换成为新的状态。$Bfs$中如果换成了终局就$return$。

![](https://s2.ax1x.com/2019/11/01/KbmQ8x.jpg)

## 以下是代码+注释


```cpp
#include <bits/stdc++.h>
using namespace std;
int vis[1<<16];
char ant[1<<16][4];
struct statu{ //表示一种状态
	int lst,sta,g;
	statu(){sta=0;}
	void read(){ //读入函数
		int bit;
		scanf("%d",&bit);
		bit=bit/1000*8
		+bit/100%10*4
		+bit/10%10*2+bit%10;
		sta=sta*16+bit;
	}
}now,ex,ans,rec[1<<16];
//now表示开始状态，ex表示结束状态，rec记录每个状态
queue<statu> q;
void bfs(){
	for(int i=0;i<(1<<16);i++)
		vis[i]=-1; //因为开始状态的步数为0
	vis[now.sta]=now.g=0;
	now.lst=-1;
	rec[now.sta]=now; //5步初始化
	q.push(now);
	while(!q.empty()){
		statu tp=q.front(),to;
		q.pop(); to.g=tp.g+1;
		to.lst=tp.sta;
//		cout<<"yahoo"<<endl;
		if(tp.sta==ex.sta){ //得出答案
			ans=tp;
			return;
		} for(int i=1;i<=16;i++){
			if((tp.sta&(1<<(16-i)))==0)
				continue;
			//找到黑棋，请注意判断可移动的标记
			//上移i>4，下移i<13，左移i%4!=1，右移i%4!=0
			//并且移动对象得是白棋
			if(i>4&&(((1<<16-i+4)&tp.sta)==0)){
				to.sta=tp.sta^(1<<16-i);
				to.sta|=(1<<16-i+4);
				if(vis[to.sta]==-1){
					vis[to.sta]=to.g;
					ant[to.sta][0]=(i+3)/4+'0';
					ant[to.sta][1]=((i-1)%4+1)+'0';
					ant[to.sta][2]=ant[to.sta][0]-1;
					ant[to.sta][3]=ant[to.sta][1];
					//记录方案
					rec[to.sta]=to; q.push(to);
				}
			} if(i<13&&(((1<<16-i-4)&tp.sta)==0)){
				to.sta=tp.sta^(1<<16-i);
				to.sta|=(1<<16-i-4);
				if(vis[to.sta]==-1){
					vis[to.sta]=to.g;
					ant[to.sta][0]=(i+3)/4+'0';
					ant[to.sta][1]=((i-1)%4+1)+'0';
					ant[to.sta][2]=ant[to.sta][0]+1;
					ant[to.sta][3]=ant[to.sta][1]; 
					rec[to.sta]=to; q.push(to);
				}
			} if(i%4!=1&&(((1<<16-i+1)&tp.sta)==0)){
				to.sta=tp.sta^(1<<16-i);
				to.sta|=(1<<16-i+1);
				if(vis[to.sta]==-1){
					vis[to.sta]=to.g;
					ant[to.sta][0]=(i+3)/4+'0';
					ant[to.sta][1]=((i-1)%4+1)+'0';
					ant[to.sta][2]=ant[to.sta][0];
					ant[to.sta][3]=ant[to.sta][1]-1; 
					rec[to.sta]=to; q.push(to);
				}
			} if(i%4!=0&&(((1<<16-i-1)&tp.sta)==0)){
				to.sta=tp.sta^(1<<16-i);
				to.sta|=(1<<16-i-1);
				if(vis[to.sta]==-1){
					vis[to.sta]=to.g;
					ant[to.sta][0]=(i+3)/4+'0';
					ant[to.sta][1]=((i-1)%4+1)+'0';
					ant[to.sta][2]=ant[to.sta][0];
					ant[to.sta][3]=ant[to.sta][1]+1; 
					rec[to.sta]=to; q.push(to);
				}
			}
		}
	}
} void print(int stas){ //递归输出方案，rec[]数组发挥作用了(·`ω`·)
	if(rec[stas].lst==-1)
		return;
	print(rec[stas].lst);
	printf("%c%c%c%c\n",
	ant[stas][0],ant[stas][1],
	ant[stas][2],ant[stas][3]);
} int main(){
	for(int i=1;i<=4;i++)
		now.read();
	for(int i=1;i<=4;i++)
		ex.read();
	bfs(),printf("%d\n",ans.g);
	print(ans.sta);
	return 0;
}
```
P4289比这题水，也是蓝题。

代码不短，因为重复的部分较多。

谢谢大家! !







---

## 作者：Liuxizai (赞：5)

[在blog查看](https://www.cnblogs.com/liuxizai/p/13781404.html)

关于这道题目的解法，其他题解已经讲得非常清楚，另外，我在代码中也做了简单的注释，应该很容易就能理解题目的做法。

作为一道经典的位运算运用题目，我主要是想详细讲讲在这题中，位运算是如何使用的。

如果你没有接触过位运算，参考[OI-Wiki](https://oi-wiki.org/math/bit/)。

~~用了位运算才知道这东西有多爽~~

## 位运算的使用

这道题目中，`bfs`肯定需要进行判重，那么位运算就有很大的优势，因为棋盘布局一共只有$2^{16}$种可能，而棋盘中每一个点恰好对应0或1，于是容易想到将四排棋盘状态压成一行，然后将其当做二进制转为十进制，用0到65535这65536个数对应每种状态。

以下以样例为例，初始棋盘如下：

```
1111
0000
1110
0010
```

将其先压成一行：

```
1111000011100010
```

这就是棋盘的状态的二进制码，将其转为十进制，即61666。

为了方便进行位运算，我们为棋盘进行如下编号：

```
  0  1  2  3
  4  5  6  7
  8  9 10 11
 12 13 14 15
```

我们需要进行的操作其实就是两种：

1. 获取编号为$i$棋子的颜色
2. 交换编号为$i$和编号为$j$的棋子

对于操作1，用位运算表示为：`(n >> (15 - i)) & 1`。

原理很简单，比如我们想获取样例中编号为3的棋子颜色，那么我们将3号棋子移动到第0位上，移动的位数即为`15 - i`位，所以就有了`n >> (15 - i)`。

```
1111(000011100010)
```

接下来，将其和`1`进行与运算，其实就是获得了第0位的数码。

```
1111 & 0001 = 1
```

操作1就实现了，在程序中，`15 - i`被定义为了`ni`。

对于操作2，用位运算表示为：`n + (1 << (15 - j)) - (1 << (15 - i))`。

同样拿样例举例，我们想要将编号为1的棋子向下移动，即为将编号为1的棋子与编号为`1 + 4 = 5`的棋子互换。

为方便进行位运算，我们在程序中约定，被移动棋子只能是黑棋，目标棋子只能是白棋。

在二进制数当中，我们要做的就是将某一位上的`1`改成`0`，将某一位上的`0`改成`1`。

很容易得到以下算式：
$$
(1111000011100010)_2 - (100000000000000)_2 + (10000000000)_2 = (1011010011100010)_2
$$
转换成位运算就是`n + (1 << (15 - j)) - (1 << (15 - i))`。

这样，我们就能在程序中使用位运算进行棋盘上棋子的移动操作了。

## Tip

### 本题不能使用getchar！

### 本题不能使用getchar！

### 本题不能使用getchar！

[RE记录](https://www.luogu.com.cn/record/39461032)

## AC CODE

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int n; // 当前棋盘 
	int step; // 计步 
	string way; // 记录操作 
	node(int n, int step, string way): n(n), step(step), way(way) {}
};
int start, final, n, step, newn;
char t;
string way, newway;
bool vis[65536];
queue<node>q;
int main(){
	for(int i = 0; i < 4; i++)
		for(int j = 0; j < 4; j++)
			cin >> t, start = start * 2 + (int)(t-'0');
	for(int i = 0; i < 4; i++){
		for(int j = 0; j < 4; j++)
			cin >> t, final = final * 2 + (int)(t-'0');
		getchar();
	}
	q.push(node(start, 0, ""));
	vis[start] = true;
	while(!q.empty()){
		n = q.front().n, step = q.front().step, way = q.front().way;
		if(n == final){
			cout << step;
			for(int i = 0; i < (signed)way.size(); i++){
				if(i % 4 == 0) cout << endl;
				cout << way[i];
			}
			return 0;
		}
		step++;
		q.pop();
		for(int i = 0; i < 16; i++){
			int ni = 15 - i;
			if(((n >> ni) & 1) == 0) continue; // 被移动棋只选黑棋 
			// 左移 
			if(i % 4 != 0){ // 棋子不能位于棋盘第一列 
				int j = ni + 1;
				if(((n >> j) & 1) == 0){ // 目标棋应是白棋 
					newn = n + (1 << j) - (1 << ni);
					if(!vis[newn]){
						vis[newn] = true;
						newway = way + (char)(i/4+1+'0');
						newway += (char)(i%4+1+'0');
						newway += (char)((15-j)/4+1+'0');
						newway += (char)((15-j)%4+1+'0');
						q.push(node(newn, step, newway));
					}
				} 
			}
			// 右移 
			if(i % 4 != 3){ // 棋子不能位于棋盘第四列
				int j = ni - 1;
				if(((n >> j) & 1) == 0){
					newn = n + (1 << j) - (1 << ni);
					if(!vis[newn]){
						vis[newn] = true;
						newway = way + (char)(i/4+1+'0');
						newway += (char)(i%4+1+'0');
						newway += (char)((15-j)/4+1+'0');
						newway += (char)((15-j)%4+1+'0');
						q.push(node(newn, step, newway));
					}
				} 
			}
			// 上移 
			if(i >= 4){ // 棋子不能位于棋盘第一行 
				int j = ni + 4;
				if(((n >> j) & 1) == 0){
					newn = n + (1 << j) - (1 << ni);
					if(!vis[newn]){
						vis[newn] = true;
						newway = way + (char)(i/4+1+'0');
						newway += (char)(i%4+1+'0');
						newway += (char)((15-j)/4+1+'0');
						newway += (char)((15-j)%4+1+'0');
						q.push(node(newn, step, newway));
					}
				} 
			}
			// 下移
			if(i <= 11){ // 棋子不能位于棋盘第四行 
				int j = ni - 4;
				if(((n >> j) & 1) == 0){
					newn = n + (1 << j) - (1 << ni);
					if(!vis[newn]){
						vis[newn] = true;
						newway = way + (char)(i/4+1+'0');
						newway += (char)(i%4+1+'0');
						newway += (char)((15-j)/4+1+'0');
						newway += (char)((15-j)%4+1+'0');
						q.push(node(newn, step, newway));
					}
				} 
			} 
		}
	}
}
/*
1111
0000
1110
0010
1010
0101
1010
0101
*/
```

[AC记录](https://www.luogu.com.cn/record/39461528)

- 用时：59ms
- 空间：1.00MB

---

## 作者：世界第一蒟蒻 (赞：5)

题解里竟然没有写IDA\*，来一发

IDA\*算法就是基于迭代加深的A\*算法。——百度百科

在计算机科学中，迭代深化搜索（iterative deepening search）或者更确切地说迭代深化深度优先搜索 (iterative deepening depth-first search (IDS or IDDFS)) 是一个状态空间（状态图）搜索策略。在这个搜索策略中，一个具有深度限制的深度优先搜索算法会不断重复地运行，并且同时放宽对于搜索深度的限制，直到找到目标状态。IDDFS 与广度优先算法是等价的，但对内存的使用会少很多；在每一步迭代中，它会按深度优先算法中的顺序，遍历搜索树中的节点，但第一次访问节点的累积顺序实际上是广度优先的。 ——百度百科

A\*搜寻算法俗称A星算法。A\*算法是比较流行的启发式搜索算法之一，被广泛应用于路径优化领域。它的独特之处是检查最短路径中每个可能的节点时引入了全局信息，对当前节点距终点的距离做出估计，并作为评价该节点处于最短路线上的可能性的量度。—— 百度百科

emmmmm,以上都是废话，看不懂就不用去管了

迭代加深搜索就是人为的规定深度优先搜索的最大深度，并逐渐放宽，直到能搜索出正确结果，这种搜索方式结合了深度优先搜索和广度优先搜索的优势，空间占用会小于广搜并且在搜索树很深时快于深搜

~~A\*的话我个人也不太懂，就当做奇怪的剪枝吧~~

在IDA\*中A\*部分一般写法为

```cpp
if(nowdeep+h()>maxdeep)
	return;
```

其中nowdeep是现在搜索到的深度，h()是估价函数，估计还需多少步才能从当前状态到目标状态，maxdeep是允许搜索的最大深度，如果当前步数加上预期步数不能在最大步数内到达目标状态，剪枝

其他的见注释

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<map>
#define ll long long
using namespace std;
char s[5][5],t[5][5];
int stax1[1000000];
int stay1[1000000];
int stax2[1000000];
int stay2[1000000];
map<ll,bool>a;
bool check(){//检查是否达到目标状态
    for(int i=1;i<=4;i++)
    for(int j=1;j<=4;j++)
    if(s[i][j]!=t[i][j])
    return 0;
    return 1;
}
int h(){//A*的估价函数
    int num=0;
    for(int i=1;i<=4;i++)
    for(int j=1;j<=4;j++)
    if(s[i][j]!=t[i][j])
    num++;//num为与目标状态位置不同的棋子数量，因为每移动一次最多
    return (num+1)/2;//会使两个棋子归位，所以至少还需要num/2步
}
ll che(int deep){//把当前棋局转化成一个17位整数
	ll f=deep+1;//其中最高位是深度（+1是为了防止前导零的出现）
	for(int i=1;i<=4;i++){//余下16位是当前矩阵
		for(int j=1;j<=4;j++){
			f=f*10+s[i][j]-'0';
		}
	}
	return f;
}
bool dfs(int deep,int maxdeep){
	a[che(deep)]=1;//记录当前棋局已经走过
    if(deep+h()>maxdeep){//A*部分
    	return 0;
	}
    if(check()){//检查是否到达目标状态
    	return 1;
	}
    for(int i=1;i<=4;i++){//只有向右和向下走有意义，因为向左和向上和
        for(int j=1;j<=4;j++){//上方和左侧的点向右和向下走等价
            if(j+1<=4&&s[i][j]!=s[i][j+1]){//相同颜色交换没有意义
                swap(s[i][j],s[i][j+1]);
                if(a[che(deep+1)]==0){//只有下一步的棋局没有到达过才进入
	                stax1[deep]=i;//记录怎么走的
	                stay1[deep]=j;
	                stax2[deep]=i;
	                stay2[deep]=j+1;
	                if(dfs(deep+1,maxdeep)){
	                	return 1;
					}
				}
                swap(s[i][j],s[i][j+1]);//复原棋局
            }
            if(i+1<=4&&s[i][j]!=s[i+1][j]){
                swap(s[i][j],s[i+1][j]);
                if(a[che(deep+1)]==0){
	                stax1[deep]=i;
	                stay1[deep]=j;
	                stax2[deep]=i+1;
	                stay2[deep]=j;
	                if(dfs(deep+1,maxdeep)){
	                	return 1;
					}
	            }
                swap(s[i][j],s[i+1][j]);
            }
        }
    }
    return 0;
}
int slove(){
    if(check()) return 0;
    int ans=1;
    while(!dfs(0,ans)){//迭代加深
    	ans++;//逐渐放宽限制
    	a.clear();
	}
    return ans;
}
int main(){
    for(int i=1;i<=4;i++){
        for(int j=1;j<=4;j++){
            cin>>s[i][j];
        }
    }
    for(int i=1;i<=4;i++){
        for(int j=1;j<=4;j++){
            cin>>t[i][j];
        }
    }
    int ans=slove();
    printf("%d\n",ans);
    for(int i=0;i<ans;i++)
    printf("%d%d%d%d\n",stax1[i],stay1[i],stax2[i],stay2[i]);
    return 0;
}
```

---

## 作者：快乐一凡 (赞：4)

### 题目：

[P1225 黑白棋游戏](https://www.luogu.com.cn/problem/P1225)
### 分析：
$4*4$ 的矩阵相当于 $16$ 位的 $01$ 串，明显用二进制状态压缩，$2<<16$ 不超过 $65535$ 交换即可，但是大家要这个状态不好标记处理，所以我们需要 hash 处理，这个 $01$ 矩阵， 不难想到我们处理成二进制来处理。 

我们怎么处理这个题目中 $1 ,0$ 对应的位置呢？我们可以用我们二维数组通用的  hash 方法，就是除以列宽得行号，对列宽取余得到列号的做法：交换。

但是如何实现呢？ 同样地得到上下两个坐标的位置，同时其实他们对应的二进制也是序号来记录的，然后我们直接找到两个位置，用异或处理就可以交换 $0$ 和 $1$ 的操作。

怎么打印这个答案呢？ 

我认为这个题目还有一点就是记录路径的方法，记录路径是非常考验人的，但是我们需 要开一个结构体， 这个结构体需要记录这次 hash 值对应的哪两个坐标进行交换了，同时这个结构体能通 过最终状态的 hash 值回溯输出。


### 代码：
因为前面已经讲解过了思路，所以注释比较少，请谅解。
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=(1<<16)+10;
int pre[N],vis[N];
int n,m;
queue <int> que;
struct node
{
	int x,y,xx,yy;
	int pnum;//记录上一个状态 
} ans[N];
void dfs(int No)
{
	if(ans[No].pnum!=n)
	{
		dfs(ans[No].pnum);
	}
	printf("%d%d%d%d\n",ans[No].x,ans[No].y,ans[No].xx,ans[No].yy);
}
void bfs()
{
	que.push(n);
	while(!que.empty())//上下互换 
	{
		int cur=que.front();
		que.pop();
		for(int i=0;i<=11;i++)//上下交换 
		{
			int u=(cur&(1<<i))>>i;
			int v=(cur&(1<<(i+4)))>>(i+4);
			int tmp=(1<<(i+4))+(1<<i);
			if(u!=v)
			{
				int next=cur^tmp;
				if(vis[next]==0)
				{
					ans[next].x=i/4+1;
					ans[next].xx=ans[next].x+1;
					ans[next].y=ans[next].yy=i%4+1;
					ans[next].pnum=cur;
					vis[next]=vis[cur]+1;
					que.push(next);
					if(next==m)
					{
						printf("%d\n",vis[m]);
						dfs(next);
						return;
					}
				}
				
			}
		}
        for(int i=0;i<=15;i++)// 左右互换
		{
            if(i%4==3) continue ;
            int u = ( cur & (1<<i) ) >> i ;
            int v = ( cur & (1<<(i+1)) ) >> (i+1);
            int tmp = ( 1<<(i+1) ) + (1<<i) ;
            if ( u != v )
			{
                int next = cur ^ tmp ;
                if( vis[next] == 0 )
				{
                    ans[next].xx = ans[next].x = i / 4 + 1 ;
                    ans[next].y =  i % 4 + 1 ;
                    ans[next].yy = i % 4 + 2 ;
                    ans[next].pnum = cur ;
                    vis[next] = vis[cur] + 1 ;
                    que.push(next);
                    if ( next == m )
					{
                        printf("%d\n",vis[m]);
                        dfs(next);
                        return ;
                    }
                }
            }
        }
	}
} 
int main()
{
	int x;
	for(int i=0;i<16;i++)
	{
		scanf("%1d",&x);//注意读入技巧 
		n+=x*(1<<i);
	}
	for(int i=0;i<16;i++)
	{
		scanf("%1d",&x);
		m+=x*(1<<i);
	}
	if(n==m)
	{
		printf("0\n");
		return 0;
	}
	bfs();
	return 0;
}
```

---

## 作者：WSEDSWZD (赞：4)

刚学了状态压缩老师讲了这题发个题解

~~代码啥的都看的老师的~~

****状态压缩+广搜****

老师给总结了一个大概思考方向

1.棋盘变整数。

2.整数还原成棋盘。

3.决策 向左：a和a-1对调；向上：a和a-4对调（置反）

4.求a的二进制，置反

5.广搜框架

向左和向右是一样的，向上和向下是一样的，所以只要枚举两个就可以了~~老师还说应该先往上交换再往左交换但我还没想出原因..~~

[代码 is here!](https://www.luogu.org/paste/9jm63nhj)

---

## 作者：天南星魔芋 (赞：3)

## 不想打状压的看过来

思路：暴搜。

* 方法：
1. 将 $1$ 看为有棋子，$0$ 看为空白。
2. 若 开始时没棋子结束时有棋子 记为终点 ，反之记为起点。
3. 一枚旗子从起点到终点的步数是起点到终点的曼哈顿距离。
4. 将 起点与终点 一一对应，直接进行暴搜（没有任何剪枝QwQ）。
5. 输出路径。


$$$$
$$$$
* 时间复杂度证明：

    将 起点与终点 一一对应，由于最多有 $8$ 个棋子，所以时间复杂度 $O(8!)$，也就是 $O(40320)$。  ~~过于合理~~



$$$$
$$$$
* 棋子步数合理性证明：
    
    若无棋子拦路，则为起点到终点的曼哈顿距离。~~（不信你不知道这个）~~
    
	若有棋子拦路，运用递归思想：
    
	设 $x1,y1$ 处有一棋子要到 $x2,y2$,但被路上处于 $x3,y3$ 的棋子拦住了路。
    
	那么我们将问题转化为两个子问题： $x1,y1$ 的棋子到 $x3,y3$ 和 $x3,y3$ 的棋子到 $x2,y2$。
    
	由于走的是最短路，$x3,y3$ 位于 $x1,y1$ 到 $x2,y2$ 路上，所以 当前问题步数 等于 两个子问题步数，
    
    并且不存在对当前棋子造成影响的走法（因为你走一个棋子时只会朝终点方向走），
    
   所以一枚旗子从起点到终点的步数是起点到终点的曼哈顿距离。



$$$$
$$$$
* 那么如何输出路径呢？

	我们在暴搜时记录最优解路径。
    
    1. 对所有对应关系，将 起点和终点 逐一求解输出。
    2. 对每对起点终点，像 合理性证明 中的一样递归求解输出。



$$$$
$$$$

若还有什么不明白的看代码吧，注释很详细的~


```cpp
#include<bits/stdc++.h>
using namespace std;

int a[10][2],topa=0;//记录起点 
int b[10][2],topb=0;//记录终点 
int QwQ[10];//当前解
int jl[10];//最优解 jilu 

int c[10][10];//记录开始时地图 

int ans=100000000;//记录最优解步数 
 
void read(){//简单的读入 
	char d;
	for(int i=1;i<=4;i++){// 棋盘初始状态 
        for(int j=1;j<=4;j++){
            cin>>d;
            c[i][j]=d-'0'; 
        }
    }
    //-------------------------------------------//
	 
    for(int i=1;i<=4;i++){//  棋盘最终状态 
        for(int j=1;j<=4;j++){
            cin>>d;
            if(c[i][j]!=d-'0'){//若与 初始状态 不符 
                if(d=='1'){topb++;b[topb][0]=i;b[topb][1]=j;}//终点 
                else if(d=='0'){topa++;a[topa][0]=i;a[topa][1]=j;}//起点 
            }
        }
    }
}
void dfs(int x,int jll){     //没剪枝的无脑搜

//----- x为当前起点编号 ，jll 为当前步数 ------// 

    if(x==topa+1){//若当前结束了 
    	if(jll<ans){//--------------------//更新答案 
    		for(int i=1;i<=topa;i++)
        		jl[QwQ[i]]=i;
        	ans=jll;
		}
		return ;
    }
    //---------------------------------------// 搜索下一层 
    for(int i=1;i<=topa;i++){
        if(QwQ[i]==0){
            QwQ[i]=x;//这个终点被当前起点占用 
            dfs(x+1,jll+abs(a[x][0]-b[i][0])+abs(a[x][1]-b[i][1]));//下一层  
            QwQ[i]=0;//这个终点被当前起点解除占用
        }
    }
}
void print(int x,int y,int z){//递归的输出 

	int xx=x,yy=y;
	if(xx>b[z][0])xx--;
	else if(xx<b[z][0])xx++;
	else if(yy>b[z][1])yy--;
	else if(yy<b[z][1])yy++;
//------------  接下来位于 x,y 的 棋子要到 xx,yy  ----// 

	if(!c[xx][yy]){//去往位置没有棋子 
		printf("%d%d%d%d\n",x,y,xx,yy);
		swap(c[x][y],c[xx][yy]);
		//直接去 
		x=xx,y=yy;
		if(!c[b[z][0]][b[z][1]])print(xx,yy,z);
		//问题变为 xx,yy 的棋子到终点 
	}
	else{//去往位置有棋子 

		print(xx,yy,z);
		//先让挡路的棋子到终点 
		printf("%d%d%d%d\n",x,y,xx,yy);
		swap(c[x][y],c[xx][yy]);
		//我代替挡路的棋子站这了位子 QaQ 
	}
}
int main(){
    read();//读入 
    dfs(1,0);//暴搜 
    cout<<ans<<endl;//答案
	//------------------------------------//打印路径 
    for(int i=1;i<=topa;i++){            //
    	print(a[i][0],a[i][1],jl[i]);   // 
	}//       起点x   起点y   终点编号 //
	//--------------------------------// 
}
```


这篇题解就到这了，若有错误或不足请在评论区指出。

挂上此题弱化版 [P4289 [HAOI2008]移动玩具](https://www.luogu.com.cn/problem/P4289) 和暴搜出最优解的的 [dalao](https://www.luogu.com.cn/record/41056059)。


---

## 作者：坚决杀毒2008 (赞：3)

SPJ似乎还是有点问题，由于输出解的顺序的原因，以下代码无法在洛谷AC...

很明显，本题符合宽度优先搜索“从一种状态扩展到其他状态，直到目标状态”的性质。另外由于起始状态和目标状态都很明确，所以可以采用双向搜索来进行优化。

关于状态压缩，楼下神犇们已经解释得非常详细，故不再赘述。我们重点来看双向搜索。

本题中，双向搜索的思路是，对于每一个状态，记录从起始状态（或目标状态）到该状态扩展的次数，和每一次交换的两个相邻棋子的位置，如果正向搜索（从起始状态开始的搜索）和反向搜索（从目标状态开始的搜索）同时扩展到某一状态，则结束搜索。

请注意代码中incr()函数和sgn()函数的作用。incr()的作用是对整数的绝对值加1，sgn()返回整数的符号。从起始状态扩展而来的状态在vis[]中表示为正数，从目标状态扩展而来的则表示为负数，要得到总的步数，只需将它们的绝对值相加再减1即可。用这种实现方式，只需要1个队列即可进行双向搜索，输出时也无需使用递归调用的方式，比较方便。

P.S. 注意关键字问题，当心被坑... ...

```cpp
#include<cstdio>
#include<cstring>
#include<vector>
#include<queue>
#include<map>
#include<iostream>
using namespace std;
int a[5][5],start,endd,pnt=15;
vector<int> ans1,ans2;
map<int,int> vis;
map<int,vector<int> >fun;
int abs(int x)
{
    if(x>=0)return x;
    return -x;
}
int sgn(int x)
{
    if(x==0)return 0;
    if(x>0)return 1;
    return -1;
}
int incr(int x)
{
    if(x<0)return x-1;
    return x+1;
}
int bfs()
{
    queue<int> que;
    que.push(start);
    vis[start]=1;
    que.push(endd);
    vis[endd]=-1;
    while(!que.empty())
    {
        int now=que.front();
        que.pop();
        bool r1,r2;long long temp;
        for(int i=1; i<=4; i++)
        {
            for(int j=1; j<=4; j++)
            {
                if(i<4)
                {
                    r1=now&(1<<a[i][j]),r2=now&(1<<a[i+1][j]);
                    temp=now-(1<<a[i][j])*r1+(1<<a[i+1][j])*r1-(1<<a[i+1][j])*r2+(1<<a[i][j])*r2;
                    if(!vis[temp])
                    {
                        vector<int> c;
                        c=fun[now];
                        c.push_back(i*1000+j*100+(i+1)*10+j);
                        que.push(temp);
                        fun[temp]=c;
                        vis[temp]=incr(vis[now]);
                    }
                    else if(sgn(vis[now])!=sgn(vis[temp]))
                    {
                        fun[temp].push_back(i*1000+j*100+(i+1)*10+j);
                        ans1=fun[now],ans2=fun[temp];
                        return abs(vis[now])+abs(vis[temp])-1;
                    }
                }
                if(j<4)
                {
                    r1=now&(1<<a[i][j]),r2=now&(1<<a[i][j+1]);
                    temp=now-(1<<a[i][j])*r1+(1<<a[i][j+1])*r1-(1<<a[i][j+1])*r2+(1<<a[i][j])*r2;
                    if(!vis[temp])
                    {
                        vector<int> c;
                        c=fun[now];
                        c.push_back(i*1000+j*100+i*10+j+1);
                        que.push(temp);
                        fun[temp]=c;
                        vis[temp]=incr(vis[now]);
                    }
                    else if(sgn(vis[now])!=sgn(vis[temp]))
                    {
                        fun[temp].push_back(i*1000+j*100+i*10+j+1);
                        ans1=fun[now],ans2=fun[temp];
                        return abs(vis[now])+abs(vis[temp])-1;
                    }
                }
                
            }
        }
    }
}
int main()
{
    for(int i=1; i<=16; i++)
    {
        int tmp;
        scanf("%1d",&tmp);
        start<<=1;
        start+=tmp;
    }
    for(int i=1; i<=16; i++)
    {
        int tmp;
        scanf("%1d",&tmp);
        endd<<=1;
        endd+=tmp;
    }
    for(int i=1; i<=4; i++)
    {
        for(int j=1; j<=4; j++)
        {
            a[i][j]=pnt;
            pnt--;
        }
    }
    int ans=bfs();
    printf("%d\n",ans);
    for(int i=0;i<ans1.size();i++)
    {
        printf("%d\n",ans1[i]);
    }
    for(int i=0;i<ans2.size();i++)
    {
        printf("%d\n",ans2[i]);
    }
    return 0;
}
```

---

## 作者：Tan_Wei_Ye (赞：2)

介绍一种**不用转二进制**的做法：

**优点**： 代码简短，几乎是二进制做法的一半。

**缺点**： 因为用了```map```，~~吸氧不如别人不吸氧跑得快~~。


------------


## 正题：

我第一眼看到这题，想到了[P2324 骑士精神](https://www.luogu.com.cn/problem/P2324),所以一直在想估价函数，剪枝之类的，搞了半天只拿了 $30$ 分。

后来~~看了题解~~才发现根本没有那么复杂，直接暴力 ```Bfs``` 就彳亍了。

然而题解里都是把状态转换二进制操作的，对于位运算小白来讲很不友好，那么考虑把状态用其他方法存下来就好了，所以我使用了 ```string``` ，并用 ```map``` 判重，具体看代码：

```
#include<bits/stdc++.h>
using namespace std;
const int dx[]={-1,1,-4,4};
string init,goal;
char ch;
struct step//记录步骤
{
	int x1,y1,x2,y2;
};
queue<string> q;
map<string,int> m;
map<string,string> pre;
map<string,step> op;
void print(string x)//递归输出方案
{
	if(!pre.count(x)) return ;
	print(pre[x]);
	printf("%d%d%d%d\n",op[x].x1,op[x].y1,op[x].x2,op[x].y2);
}
string read()//把 4×4的矩阵转化成字符串
{
	string res="",tmp;
	for(int i=1;i<=4;i++)
		cin>>tmp,res=res+tmp;
	return res;
}
signed main()
{
	init=read();//初始状态
	goal=read();//目标状态
	q.push(init);
	string tmp=q.front();
	m[init]=0;
	while(!q.empty())
	{
		string u=q.front(),v=u;
		q.pop();
		if(u==goal)
		{
			cout<<m[u]<<endl;
			print(u);
			exit(0);
		}
		for(int i=0;i<16;i++)
			for(int j=0;j<4;j++)
			{
				if((i==4 || i==8 || i==12) && j==0) continue;
           	//开头 不能跳的上一行的 末尾   
				if((i==3 || i==7 || i==11) && j==1) continue;
           	//末尾  不能跳的下一行的 开头      
				int tx=i+dx[j];
				if(tx<0 || tx>15) continue;//判越界
				swap(v[i],v[tx]);
				if(!m.count(v))
				{
					m[v]=m[u]+1;
					pre[v]=u;
					op[v]=((step){i/4+1,i%4+1,tx/4+1,tx%4+1});
            	//存入步骤
					q.push(v);
				}
				swap(v[i],v[tx]);
			}
		}
}
```
**双倍经验**：[P4289 移动玩具](https://www.luogu.com.cn/problem/P4289)


---

## 作者：MY（一名蒟蒻） (赞：2)

[P1225 黑白棋游戏](https://www.luogu.com.cn/problem/P1225)

简化版[P4289 [HAOI2008]移动玩具](https://www.luogu.com.cn/problem/P4289)。

## 题意简述

给你一个 $4\times4$ 的 $01$ 矩阵，每次可以交换相邻的一对 $0$ 和 $1$ 。求最小操作次数使得初始矩阵变成目标矩阵，并输出如何操作。

## Solution

$01$ 提示二进制状压。

有始有终考虑**双向广搜**。

---

双向广搜是啥？

从起点和终点分别拓展状态，当两边的解答树第一次重合时找到答案。

需要特判一开始就是答案。

注意还原状态。

递归输出方案即可。

[还是不太明白点这里](https://www.luogu.com.cn/blog/nizhuan/xue-xi-bi-ji-shuang-xiang-guang-sou-hu-01bfs)

具体来说每一个数字对应一个矩阵，每次从队头取出数字还原矩阵。对于每一个 $1$ 拓展矩阵。重新状压判重，记录前驱方便后面递归输出。

## Code

```cpp
#include <cstdio>
#include <algorithm>
#include <iostream>
#include <cmath>
#include <cstring>
#include <queue>

using namespace std;

int s,e,vis[70000],a[10][10],step[70000],nxt[4][2]={{0,1},{1,0},{0,-1},{-1,0}};
pair <int,int> last[70000];
queue <int> q;

void prints(int x)//递归输出
{
	if(!x) return ;
	prints(last[x].first);
	if(last[x].second) printf("%d\n",last[x].second); return ;
}

void printe(int x)
{
	if(!x) return ;
	if(last[x].second) printf("%d\n",last[x].second);
	printe(last[x].first); return ;
}

int main()
{
// 	freopen("work.in","r",stdin); freopen("work.out","w",stdout);
	char t;//状压
	for(int i=1;i<=16;i++) {scanf(" %c",&t); s=(s<<1)+t-'0';}
	for(int i=1;i<=16;i++) {scanf(" %c",&t); e=(e<<1)+t-'0';}
	if(s == e) return printf("0"),0;
	vis[s]=1; vis[e]=2; step[s]=0; step[e]=0; last[s].first=last[e].first=0;
	q.push(s); q.push(e);
	int x,now;
	while(!q.empty())
	{
		x=now=q.front(); q.pop();
		for(int i=4;i;i--)
			for(int j=4;j;j--) {a[i][j]=x&1; x>>=1;}
		for(int i=1,nx,ny;i<=4;i++)
			for(int j=1;j<=4;j++)
				if(a[i][j])
					for(int u=0;u<4;u++)
					{
						nx=i+nxt[u][0]; ny=j+nxt[u][1]; x=0;
						if(nx < 1 || nx > 4 || ny < 1 || ny > 4) continue;
						if(!a[nx][ny])
						{
							a[i][j]=0; a[nx][ny]=1;
							for(int k=1;k<=4;k++)
								for(int l=1;l<=4;l++) x=(x<<1)+a[k][l];
							a[i][j]=1; a[nx][ny]=0;
							if(vis[x]+vis[now] == 3)//找到答案
							{
								if(vis[x] == 1) x^=now^=x^=now;
								printf("%d\n",step[x]+step[now]+1);
								prints(now); printf("%d\n",i*1000+j*100+nx*10+ny); printe(x);
								return 0;
							}
							if(vis[x]) continue;
							last[x].first=now; last[x].second=i*1000+j*100+nx*10+ny;
							vis[x]=vis[now]; step[x]=step[now]+1; q.push(x);
						}
					}
	}
// 	fclose(stdin); fclose(stdout);
	return 0;
}
```
双向广搜！很快啊！不加优化截至2021年5月1日跑到了最优解第一页。

# $\text{Thank you for your reading!}$

---

## 作者：一只小H (赞：2)

## 题意简述

求从一个 $4\times4$ 的方阵变成另一个 $4\times4$ 的方阵最少需要的步数以及步骤。
**（棋子只能与相邻的棋子交换）**

输入：

* 两个 $4\times4$ 的方阵，只包含8个0和8个1。

输出：

* 最少需要的步数。
* 操作的每一步，格式 $abcd$，表示将棋子从 $(a,b)$ 移动到 $(c,d)$。

## 题目分析

这道题使用bfs。

搜索时注意交换 $(a,b)$ 和 $(a+1,b)$ 与 交换 $(a+1,b)$ 和 $(a,b)$ 是一样的效果，当枚举到 $(a+1,b)$ 时再去与 $(a,b)$ 交换就没有意义了，因为先枚举 $(a,b)$，如果能交换已经交换过了。$(a,b)$ 与 $(a,b+1)$ 也是同样的道理，所以我们可以得出结论，对于每个 $(a,b)$ ，我们搜索时仅需与右边的和下面的进行交换。交换两个相同的数也没有意义，所以可以进行判断来省略。

因为棋盘只包含0和1，且只有16位，所以可以压缩成二进制方便储存。

!["样例"](https://cdn.luogu.com.cn/upload/image_hosting/yql12qcj.png)
比如说样例，将输入的两个方阵记为 $a$ 和 $b$，则 $a$ 可以压缩成 $1111000011100010$ 即 $61666$。

!["样例-二进制"](https://cdn.luogu.com.cn/upload/image_hosting/q5auaj6u.png)

我们可以通过 ```a & (1<<i)``` 来取得从左往右第 $i$ 位的值，则它右边的值为 ```a & (1<<(i-1))```，下面的值为 ```a & (1<<(i-4))```。
![""](https://cdn.luogu.com.cn/upload/image_hosting/5wjm99cg.png)
![""](https://cdn.luogu.com.cn/upload/image_hosting/c8dxbkuj.png)

为了记录操作，我们还需要知道第 $i$ 位在原本的方阵中对应的坐标，它的纵坐标就是 $\lfloor i\div4 \rfloor$，横坐标即为 $i\mod4$。

由于要被交换的两位必定是一个0一个1，所以交换两位可以将这两位异或1

$$
0\oplus1=1
$$
$$
1\oplus1=0
$$

详情请见代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
struct record //用于记录步骤
{
    int x1;
    int y1;
    int x2;
    int y2;
};
struct status //每一个状态
{
    int num;            //方阵的二进制形式
    int t;              //需要的次数
    vector<record> rec; //记录步骤
};
status a, b;     //初始状态和目标状态
queue<status> q; //用于bfs
bool vis[66666]; //记录某个方阵是否被搜过
void bfs()
{
    q.push(a);
    while (!q.empty())
    {
        status tmp = q.front();
        q.pop();
        if (vis[tmp.num]) //如果搜到过那么就肯定不是最优解
        {
            continue;
        }
        vis[tmp.num] = 1;
        if (tmp.num == b.num) //如果与目标相同就输出
        {
            cout << tmp.t << endl;
            for (vector<record>::iterator it = tmp.rec.begin(); it != tmp.rec.end(); ++it)
            {
                cout << (it->x1) << (it->y1) << (it->x2) << (it->y2) << endl;
            }
            return;
        }
        for (int i = 15; i >= 0; --i) //枚举方阵每一位
        {
            /**
             * 15-i表示现在是方阵二进制的哪一位（从左到右）
             * (15-i) / 4 即 (15-i) >> 2 表示相当于原来的第几行
             * (15-i) % 4 即 (15-i) - (y << 2) 表示相当于原来的第几列
            */
            int y = (15 - i) >> 2;
            int x = (15 - i) - (y << 2);

            /*tmp.num & (1<<i) 表示当前方阵第i位，这里用aaa储存方便使用*/
            int aaa = 1 << i;

            status bbb; //临时储存下一个状态
            bbb.t = tmp.t + 1;
            bbb.rec = tmp.rec;

            /**
             * 左右交换
             * 限制 x<3 防止出界
             * 如果第i位与第i+1位相等就不用交换了
             * 第i+1位在10进制里对应的值就是第i位的值的一半
             * 因为这里的x和y是从0开始的，所以记录时要加一
             */
            bbb.num = tmp.num ^ aaa ^ (aaa >> 1);
            if (x < 3 and (tmp.num & aaa) ^ (tmp.num & (aaa >> 1)))
            {
                bbb.rec.push_back((record){y + 1, x + 1, y + 1, x + 2});
                q.push(bbb);
                bbb.rec.pop_back();
            }

            /**
             * 上下交换
             * 同上，不过这次是与下面的交换，需要右移一行即4位
             */
            bbb.num = tmp.num ^ aaa ^ (aaa >> 4);
            if (y < 3 and (tmp.num & aaa) ^ (tmp.num & (aaa >> 4)))
            {
                bbb.rec.push_back((record){y + 1, x + 1, y + 2, x + 1});
                q.push(bbb);
                bbb.rec.pop_back();
            }
        }
    }
}
int main()
{
    char ch;

    /*将读入的方阵变成二进制的形式并用int保存*/
    for (int i = 15; i >= 0; --i)
    {
        cin >> ch;
        a.num += (ch - '0') * (1 << i);
    }
    for (int i = 15; i >= 0; --i)
    {
        cin >> ch;
        b.num += (ch - '0') * (1 << i);
    }

    /*特判，如果一开始就相同那就不需要搜索了*/
    if (a.num == b.num)
    {
        cout << 0;
        return 0;
    }

    bfs();
    return 0;
}
```


---

## 作者：wfycsw (赞：1)

分析题目，不难看出本题可以用**广度优先搜索**做，但是由于直接搜索的状态太多，时间上肯定会T掉，所以我们可以适当加亿点优化：

## 哈希表
通过题中的行列都为4便可以想到用二进制数（状压）来建立表示搜索状态，具体内容见注释。

## 双向广搜
题目中已经明确给出了搜索初始状态和目标状态，所以可以尝试用双向广搜来减少搜索工作量。

至于为什么能减少搜索工作量，我给大家画了两个图：
```cpp
//单向搜索
				***
			 ******
		  *********
       	*********** 
	  *************
   ****************
T*****************S
   ****************
      *************
         **********	
         	*******
			   ****
			   	***

//双向搜索
         * *********
	  **** *********
   ******* *********
T********* ********S
   ******* *********
      **** *********
         * *********
```
具体的代码为：
```cpp
for(t[0]=t[1]=w[1]=w[0]=1;t[0]<=w[0]&&t[1]<=w[1];t[0]=-~t[0],t[1]=-~t[1]){
		solve(0);solve(1);
	}


------------------------------------

inline void solve(int k){
	RI x,y,xi,yi,p=d[k][t[k]],v;
	if(f[k^1][p]){
		printf("%d\n",f[0][p]+f[1][p]);
		print1(h[0][p]);print2(h[1][p]);
		exit(0);
	}
	for(RI i=1;i<=4;i=-~i)
		for(RI j=1;j<=4;j=-~j)
			for(RI t=0;t<4;t=-~t){
				x=i+mx[t];y=j+my[t];
				if(x<1||y<1||x>4||y>4) continue;
				xi=get(i,j);yi=get(x,y);
				if(!(p&lg[xi])==!(p&lg[yi])) continue;
				v=p^lg[xi]^lg[yi];
				if(f[k][v]) continue;
				d[k][++w[k]]=v;ans[k][w[k]].a=i;
				ans[k][w[k]].b=j;ans[k][w[k]].c=x;
				ans[k][w[k]].d=y;ans[k][w[k]].n=h[k][p];
				h[k][v]=w[k];f[k][v]=-~f[k][p];
			}
}
```
而在此之中，也巧妙地运用了一些位运算，具体见注释。

最后奉上完整的AC代码：

```cpp
#include<bits/stdc++.h>
#define RI register int
using namespace std;
const int N=1<<16;
struct wu{
	int t,n,a,b,c,d;
}ans[2][N];
int f[2][N],t[2],w[2],d[2][N],lg[17],h[2][N];
int mx[]={0,1,0,-1},my[]={1,0,-1,0},pa[]={1,4,-1,-4};
inline int get(int x,int y){return 21-(x<<2)-y;}//即16-((x-1)*4+y)
inline void print1(int x){
	if(!x) return;
	print1(ans[0][x].n);//从里往外输出
	printf("%d%d%d%d\n",ans[0][x].a,ans[0][x].b,ans[0][x].c,ans[0][x].d);
}
inline void print2(int x){
	if(!x) return;
	printf("%d%d%d%d\n",ans[1][x].a,ans[1][x].b,ans[1][x].c,ans[1][x].d);
	print2(ans[1][x].n);//与print1相反
}
inline void solve(int k){
	RI x,y,xi,yi,p=d[k][t[k]],v;
	if(f[k^1][p]){//如果另一边也搜到了此状态，输出
		printf("%d\n",f[0][p]+f[1][p]);
		print1(h[0][p]);print2(h[1][p]);
		exit(0);
	}
	for(RI i=1;i<=4;i=-~i)
		for(RI j=1;j<=4;j=-~j)
			for(RI t=0;t<4;t=-~t){
				x=i+mx[t];y=j+my[t];
				if(x<1||y<1||x>4||y>4) continue;
				xi=get(i,j);yi=get(x,y);//得到这个位置的位权
				if(!(p&lg[xi])==!(p&lg[yi])) continue;//当相邻的棋子颜色相同时，直接跳过
				v=p^lg[xi]^lg[yi];//直接得到转移后的状态，不懂的可以手推一下
				if(f[k][v]) continue;//判重
				d[k][++w[k]]=v;ans[k][w[k]].a=i;//储存答案
				ans[k][w[k]].b=j;ans[k][w[k]].c=x;
				ans[k][w[k]].d=y;ans[k][w[k]].n=h[k][p];
				h[k][v]=w[k];f[k][v]=-~f[k][p];
			}
}
int main(){
	bool p;lg[1]=1;
	for(RI i=2;i<=16;i=-~i) lg[i]=lg[i-1]<<1;//预处理二进制数
	for(RI i=1;i<=4;i=-~i)
		for(RI j=1;j<=4;j=-~j)
			scanf("%1d",&p),d[0][1]=(d[0][1]<<1)+p;
	for(RI i=1;i<=4;i=-~i)
		for(RI j=1;j<=4;j=-~j)
			scanf("%1d",&p),d[1][1]=(d[1][1]<<1)+p;
	for(t[0]=t[1]=w[1]=w[0]=1;t[0]<=w[0]&&t[1]<=w[1];t[0]=-~t[0],t[1]=-~t[1]){
		solve(0);solve(1);//双向广搜
	}
}
```

总之，这是一道经典的广搜题。对于大部分的广搜题，一般用本题的中的哈希表和双向广搜优化就可以轻松A过，所以这也是两种十分实用的优化方法。

---

## 作者：hulean (赞：1)

看见很多dalao写了什么双向BFS，蒟蒻表示不会写啊。

**怎么办办？**

先来分析一下题目，一眼看去就是一个搜索题，考虑DFS与BFS。

先放一份DFS的代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
bool a[5][5],b[5][5];
char c;
int dx[5]={0,0,0,1,-1};
int dy[5]={0,1,-1,0,0};
int ans=0x3f3f3f3f;
int ax[110],bx[110],ay[110],by[110];
int ansx1[110],ansx2[110],ansy1[110],ansy2[110];
int cnt=0,ans_cnt;
map<string,int>mp;
inline string get()
{
    string s="";
    for(int i=1;i<=4;i++)
        for(int j=1;j<=4;j++)s+=a[i][j]+'0';
    return s;
}
inline bool check()
{
    for(int i=1;i<=4;i++)
        for(int j=1;j<=4;j++)
            if(a[i][j]!=b[i][j])return 0;
    return 1;
}
inline void DFS(int x,int y,int tot)
{
    /*for(int i=1;i<=4;i++)
    {
        for(int j=1;j<=4;j++)cout<<a[i][j];
        cout<<endl;
    }
    cout<<tot<<endl;*/
    //Sleep(100);
    if(tot>=ans)return;
    if(check())
    {
        ans=tot;
        ans_cnt=cnt;
        for(int i=1;i<=cnt;i++)
        {
            ansx1[i]=ax[i];
            ansx2[i]=bx[i];
            ansy1[i]=ay[i];
            ansy2[i]=by[i];
        }
    }
    if(y==5)return;
    if(x==5)x=1,y++;
    /*string s=get();
    cout<<s<<endl;
    if(mp[s]<tot&&mp[s]!=0)return;
    mp[s]=tot;*/
    DFS(x+1,y,tot);
    for(int i=1;i<=4;i++)
    {
        int aa=dx[i]+x,bb=dy[i]+y;
        if(aa<1||aa>4||bb<1||bb>4||a[aa][bb]==a[x][y])continue;
        cnt++;
        ax[cnt]=x;ay[cnt]=y;
        bx[cnt]=aa;by[cnt]=bb;
        swap(a[aa][bb],a[x][y]);
        DFS(x+1,y,tot+1);
        cnt--;
        swap(a[aa][bb],a[x][y]);
    }
}
int main()
{
    for(int i=1;i<=4;i++)
        for(int j=1;j<=4;j++)
        {
            cin>>c;
            if(c=='1')a[i][j]=1;
            else a[i][j]=0;
        }
    for(int i=1;i<=4;i++)
        for(int j=1;j<=4;j++)
        {
            cin>>c;
            if(c=='1')b[i][j]=1;
            else b[i][j]=0;
        }
    DFS(1,1,0);
    cout<<ans<<endl;
    for(int i=1;i<=ans_cnt;i++)
    {
        cout<<ansx1[i]<<ansy1[i]<<ansx2[i]<<ansy2[i]<<endl;
    }
    return 0;
}
```

这里枚举每一个点，进行上下左右的交换。看上去很(fei)有(chang)道(che)理(dan)的样子，但是很明显，有时候交换完下面的点还可以去交换上面的点，所以有时候会搜不到答案，只能拿到60分

~~蓝题能拿60分也很不错了呢~~

**怎么办办？**

那么当然要用BFS啦，（蒟蒻不会记录方案的好办法，只能暴力存储啦）

```cpp
#include<bits/stdc++.h>
using namespace std;
bool a[5][5],b[5][5];
char c;
int dx[5]={0,0,0,1,-1};
int dy[5]={0,1,-1,0,0};//上下左右
int ans=0x3f3f3f3f;
int ansx1[100],ansx2[100],ansy1[100],ansy2[100];
map<string,int>mp;//剪枝专用
struct Node
{
    bool cc[5][5];//记录当前局势
    int tot;//记录总数
    int x1[20],x2[20],y1[20],y2[20];//记录方案
};
inline void BFS()
{
    queue<Node>q;
    Node now;
    now.tot=0;
    for(int i=1;i<=4;i++)
        for(int j=1;j<=4;j++)
            now.cc[i][j]=a[i][j];//把局势copy一份
    q.push(now);
    while(q.size())
    {
        Node now=q.front();
        /*for(int i=1;i<=4;i++)
        {
            for(int j=1;j<=4;j++)cout<<now.cc[i][j];
            cout<<endl;
        }
        cout<<now.tot<<endl;*/
        q.pop();
        bool flag=1;
        for(int i=1;i<=4;i++)
            for(int j=1;j<=4;j++)if(now.cc[i][j]!=b[i][j])flag=0;
        if(flag)//找到答案
        {
            ans=now.tot;//更新答案
            for(int i=1;i<=ans;i++)
            {
                ansx1[i]=now.x1[i];
                ansx2[i]=now.x2[i];
                ansy1[i]=now.y1[i];
                ansy2[i]=now.y2[i];
            }//更新方案
            return;
        }
        string s="";
        for(int i=1;i<=4;i++)
            for(int j=1;j<=4;j++)s+=now.cc[i]
        //cout<<q.size()<<" "<<s<<" "<<mp[s]<<endl;
        if(mp[s]!=0&&mp[s]<=now.tot)continue;[j]+'0';//当前状态如果已经有更优解了，那就不用搜了（状态压缩的思想）
        mp[s]=now.tot;
        Node next;
        next.tot=now.tot+1;
        for(int i=1;i<=4;i++)
            for(int j=1;j<=4;j++)next.cc[i][j]=now.cc[i][j];//把方案copy一份（由于蒟蒻想不到好方法，还请dalao勿喷）
        for(int i=1;i<=now.tot;i++)
        {
            next.x1[i]=now.x1[i];next.y1[i]=now.y1[i];
            next.x2[i]=now.x2[i];next.y2[i]=now.y2[i];
        }
        for(int i=1;i<=4;i++)
        {
            for(int j=1;j<=4;j++)
            {
                for(int k=1;k<=4;k++)
                {
                    int aa=dx[k]+i;
                    int bb=dy[k]+j;
                    if(aa<1||bb<1||aa>4||bb>4||now.cc[i][j]==now.cc[aa][bb])continue;//超过边界或为相同数字，那么就continue
                    swap(next.cc[aa][bb],next.cc[i][j]);//交换
                    next.x1[next.tot]=i;next.y1[next.tot]=j;
                    next.x2[next.tot]=aa;next.y2[next.tot]=bb;//添加新方案
                    q.push(next);
                    swap(next.cc[aa][bb],next.cc[i][j]);//回溯
                }
            }
        }
    }
}
int main()
{
    for(int i=1;i<=4;i++)
        for(int j=1;j<=4;j++)
        {
            cin>>c;
            if(c=='1')a[i][j]=1;
            else a[i][j]=0;
        }
    for(int i=1;i<=4;i++)
        for(int j=1;j<=4;j++)
        {
            cin>>c;
            if(c=='1')b[i][j]=1;
            else b[i][j]=0;
        }
    BFS();
    cout<<ans<<endl;
    for(int i=1;i<=ans;i++)
    {
    	cout<<ansx1[i]<<ansy1[i]<<ansx2[i]<<ansy2[i]<<endl;
    }
    return 0;
}
```

---

## 作者：吴国铨 (赞：1)

本题是一道典型的宽度优先搜索题。宽度优先搜索的方法本身应该是很显然的：根据题目的描述，对于任意一个棋盘状态，可以通过交换相邻两个格子中的棋子得到新的状态（一次最多得到24个新状态）。所以，我们可以从题目给出的起始状态开始不停的扩展，直至扩展出目标状态。最后，只需输出扩展的路径即可。

上述算法已经可以完全解决本题了。但是，我们现在要继续往细节里讨论本题，讨论本题的实现。

宽度优先搜索的核心是状态的扩展，状态的扩展是通过状态转换实现的。普通的状态转换的方法就是按照题目的定义模拟实现。这里，我们要讨论的是高效简洁的状态转换的方法。

首先是状态的表示。题目中的棋盘是由16个格子组成的(4×4)，如下图。

a1    a2    a3    a4

a5    a6    a7    a8

a9    a10    a11    a12

a13    a14    a15    a16

这16个格子，每个格子里非0即1，所以可以将棋盘写成一个长度为16的01串。

a1    a2    a3    a4    a5    a6    a7    a8    a9    a10    a11    a12    a13    a14    a15    a16

这个0l串可以用一个16bit的整数来表示。也就是说，我们可以用一个0～65535的整数来表示一个状态。

下面最关键的就是状态的转换了。根据题目的定义，每次操作可以交换棋盘上相邻两个格子中的棋子。显然，如果相邻两个格子中的棋子相同，交换是没有意义的，所以我们只需要考虑相邻格子中棋子颜色不同的情况。相邻有两种情况，左右相邻和上下相邻。如图，a1和a2为左右相邻，而a8和a12为上下相邻。我们讨论状态转换的时候，将对这两种“相邻”分别处理。

a1    a2    a3    a4

a5    a6    a7    a8

a9    a10    a11    a12

a13    a14    a15    a16

图7-2
首先来看左右相邻的情况，以a15和a16为例。它们交换以后，得到的棋盘状态为：

a1    a2    a3    a4

a5    a6    a7    a8

a9    a10    a11    a12

a13    a14    a16    a15

图7-3
但是，从另一个角度来考虑问题，a15＝??a16，所以经过转换后，就相当于将a15和a16取反。从位操作的角度来看，设原状态为s，那么a15和a16交换后得到的新状态s15为：

    s15=s xor 3

同样的，还可以推出a14和a15交换后得到的新状态s14为：

    s14=s xor 6=s xor (3\*21)

当然，还有以下很多状态公式：

    s13=s xor 12=s xor(3\*22)

    s11=s xor 48=s xor(3\*24)

    s10=s xor 96=s xor(3\*25)

这里有两个需要注意之点：

（1）交换的两个棋子的颜色必须不同，否则公式不成立；

（2）根据状态转换的定义s4、s8、s12、s16对应的公式不成立，因为它们右边没有相邻的棋子。

最后，我们总结一下左右相邻情况下的状态转换公式（棋子颜色必须不同）

    sk=s xor(3\*215-k)，其中k≠4, 8, 12, 16

与“左右相邻”对应的是“上下相邻”。“上下相邻”情况的分析与“左右相邻”类似，这里就不详细展开了，只列出转换的公式（同样，棋子颜色也必须不同）

    sk=s xor(17\*212-k)，其中k≤12

有了上面两个状态转换的公式，我们只需将起始状态和目标状态转换成16bit的整数，利用公式从起始状态扩展至目标状态即可。整个过程的时间复杂度是O(24\*216)。

从另一个角度考虑问题。本题给出了起始状态和目标状态，那么我们完全可以从这两个状态开始，分别扩展——也就是用双向宽度优先搜索的方法来解决本题。一般来说，双向搜索扩展出的状态总数要比单向少很多，时间和空间复杂度都会有所降低。





```cpp
type arr=array[1..5,1..5] of char;
      rec=record
      m:arr;
      step:longint;
      ans:array[1..100,1..5] of char;
 end;
 const dx:array[1..4] of longint=(1,-1,0,0);
       dy:array[1..4] of longint=(0,0,-1,1);
 var start,ans:rec;
     f:array[0..200000] of boolean;
     spos,epos:arr;
     fr,r,i,j:longint;
     a:array[1..200000] of rec;
 function equal(m:arr):boolean;
 var i,j:longint;
 begin
  for i:=1 to 4 do
   for j:=1 to 4 do
    if m[i,j]<>epos[i,j] then exit(false);
  exit(true);
 end;
 function hash(m:arr):longint;//二进制转十进制，用位运算，效率高
 var res,i,j:longint;
 begin
  res:=0;
  for i:=1 to 4 do
   for j:=1 to 4 do
    begin
     res:=(res shl 1);
     res:=res+ord(m[i,j])-ord('0');
    end;
  exit(res);
 end;
 procedure bfs;
 var t,i,j,k,x,y:longint;
     now,next:rec;
     temp:char;
 begin
  fillchar(f,sizeof(f),true);
  t:=hash(spos);
  f[t]:=false;
  fr:=0;r:=1;
  while fr<>r do
   begin
    inc(fr);
    now:=a[fr];
    if equal(now.m) then
     begin
      ans:=now;
      exit;
     end;
    for i:=1 to 4 do
     for j:=1 to 4 do
      for k:=1 to 4 do
       begin
        next:=now;
        inc(next.step);
        x:=i+dx[k];
        y:=j+dy[k];
        if (x>=1)and(x<=4)and(y>=1)and(y<=4) then
         begin
          temp:=next.m[i,j];
          next.m[i,j]:=next.m[x,y];
          next.m[x,y]:=temp;
          next.ans[next.step,1]:=chr(ord('0')+i);
          next.ans[next.step,2]:=chr(ord('0')+j);
          next.ans[next.step,3]:=chr(ord('0')+x);
          next.ans[next.step,4]:=chr(ord('0')+y);
          next.ans[next.step,5]:=#0;//存储哪两个坐标换了位置
          if equal(next.m) then
           begin
            ans:=next;
            exit;
           end;
          t:=hash(next.m);
          if f[t] then
           begin
            f[t]:=false;
            inc(r);
            a[r]:=next;
           end;
         end;
       end;
    end;
 end;
 begin
  for i:=1 to 4 do
   begin
    for j:=1 to 4 do
     read(spos[i,j]);
    readln;
   end;
  for i:=1 to 4 do
   begin
    for j:=1 to 4 do
     read(epos[i,j]);
    readln;
   end;
  for i:=1 to 4 do
   for j:=1 to 4 do
    start.m[i,j]:=spos[i,j];
  start.step:=0;
  a[1]:=start;
  bfs;
  writeln(ans.step);
  for i:=1 to ans.step do
  begin
    for j:=1 to 4 do
     write(ans.ans[i,j]);
    writeln;
   end;
 end.

```

---

## 作者：蒟蒻思翔 (赞：0)

# 新手友好七十行代码
[题目传送门](https://www.luogu.com.cn/problem/P1225)

 这道题大体的思路比较简单，就是用 bfs 模拟方阵的变化。对于每一步操作**暴力枚两个数交换的所有方案（如果有重复的就跳出）**，然后判断是否与答案相符，**如果匹配成功就输出，如果不成功就将其压入 bfs 大队列继续搜索。** ~~想必本蒟蒻都能想出来~~ ，我在这里就不详细解释了。

 但是作为一道蓝题，它的代码还是有亿点点长的。本蒟蒻为了减少代码量，本蒟蒻在这里使用了一些小优化：
1. **使用函数 work 将新的状态压入队列**，这个函数可以同时代替队列初始化时和 bfs 时的入队操作，十几行代码瞬间蒸发。

2. 在运行时把矩阵的第一行第一个数当作状态的最高位，记为 16 位，第一行第二个当做状态的第二高位，记为 15 位······以此类推。**这样矩阵表示的二进制与状压值是完全相等的**,由此实现状压会更加简便，大家在下面的程序里可以看到。


3. **在bfs 过程中加入位运算，代替将状态转为数组，再将数组转为状态的操作**。这也是本程序的最大特色，具体操作如下：
- 	一号操作：求 $x$ 在二进制中的第 $k$ 位： $a=(x>>(k-1))\&1;$
- 	二号操作：将 $x$ 的第 $k$ 位由 $0$ 变为 $1$ : $x=x\bigoplus(1<<(k-1);$
- 	三号操作：将 $x$ 的第 $k$ 位反转： $x=x(1<<(k-1));$



读入并初始化时，只需要使用操作 $2$ 对数据进行累加，就能得到最初状态对应的整数了；如果要交换两个相邻的数，先用操作 $1$ 判断两个数是否相同，如果不同的话（如果相同交换就没有意义了，在这里只考虑不同的情况）就将两个数分别反转得到下一状态。

这种方法比较好想到，比较好理解（就是对于新手比较友好），而且**不用在整数与数组之间来回切换**，减少了大量的代码量，同时节约了时间，大家可以参考一下这个方法。


## 贴代码咯：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b,f[100000];//a:原始状态 b：目标状态  f：状态标记 去重
int c[3][905];//空数组 备用 
struct st
{
	int way[3][905],num,s;//way记录此状态以前的过程，num记录步骤数，s是当前状态 
};
queue<st>q;
void work(int now,int x,int y,int nu,int w[3][905])//当前状态，两个要交换的所在位置，步骤，以前的步骤 
{
	int x2=(now>>(x-1))&1;
	int y2=(now>>(y-1))&1;
	if(x2==y2)return;
	now=now^(1<<(x-1));
	now=now^(1<<(y-1));//交换x位置和y位置的数 
	if(f[now])return;//去重 有点类似于记忆化搜索 
	f[now]=nu;
	st fr;//更新情况 
	fr.num=nu;
	fr.s=now;
	w[1][nu]=x;
	w[2][nu]=y;//更新步骤 
	memcpy(fr.way,w,sizeof(fr.way));//将新步骤加入 
	q.push(fr);//入队 
}
int main()
{
	for(int i=1;i<=16;i++)
	{
		char x;
		cin>>x;
		if(x=='1')a+=1<<(16-i);//初始状态初始化 
	}
	for(int i=1;i<=16;i++)
	{
		char x;
		cin>>x;
		if(x=='1')b+=1<<(16-i);//目标状态初始化 
	}
	f[a]=1;
	for(int i=1;i<=16;i++)
	{
		if(i%4!=0)work(a,i,i+1,1,c);//如果没有越界，则i和左边的交换 
		if(i%4!=1)work(a,i,i-1,1,c);//如果没有越界，则i和右边的交换 
		if(i<=12)work(a,i,i+4,1,c);//如果没有越界，则i和上面的交换 
		if(i>4)work(a,i,i-4,1,c);//如果没有越界，则i和下面的交换 //ps:此图的左上角是第16位，右下角是第1位 
	}
	while(!q.empty())
	{
		st now=q.front();
		q.pop();
		if(now.s==b)//如果与目标状态重回，则输出 
		{
			cout<<now.num<<endl;
			for(int i=1;i<=now.num;i++)
			{
				cout<<(16-now.way[1][i]+1-1)/4+1; 
				cout<<(16-now.way[1][i]+1-1)%4+1;
				cout<<(16-now.way[2][i]+1-1)/4+1;
				cout<<(16-now.way[2][i]+1-1)%4+1<<endl;//分别表示要交换的两个数所在的行，列 
			}
			return 0;//如果找到直接升天 
		}
		for(int i=1;i<=16;i++)
		{
			if(i%4!=0)work(now.s,i,i+1,now.num+1,now.way);//如果没有越界，则i和左边的交换 
			if(i%4!=1)work(now.s,i,i-1,now.num+1,now.way);//如果没有越界，则i和右边的交换 
			if(i<=12)work(now.s,i,i+4,now.num+1,now.way);//如果没有越界，则i和上面的交换 
			if(i>4)work(now.s,i,i-4,now.num+1,now.way);//如果没有越界，则i和下面的交换 //ps:此图的左上角是第16位，右下角是第1位 
		}
	}
}
```



------------

## THE END

---

## 作者：yzxoi (赞：0)

[$$\large\texttt{My Blog}$$](https://yzxoi.top/archives/1562)
## Preface
> [题目链接](https://www.luogu.com.cn/problem/P1225)

这题真的恶心，状压写错了调半天。。。

## Description
给定一个 $4\times 4$ 的棋盘，每一格放一个棋子，共有 $8$ 个黑棋，$8$ 个白棋。每次可以交换相邻两个格子的棋子，问最少要多少步才能从初始状态到达最终状态。并且需要输出交换方法。

## Solution
由于棋盘十分小（只有 $4\times 4$ ），所以考虑食用 $bfs$。

这道题主要问题是状态如何考虑。

由于只有黑棋和白棋，所以很自然的就想到了状压的思想。

我们可以考虑将整个棋盘直接状压成一个 $16$ 位二进制数，再进行 $bfs$ 转移。

> $2^0$ $2^1$ $2^2$ $2^3$ \
$2^4$ $2^5$ $2^6$ $2^7$ \
$2^8$ $2^9$ $2^{10}$ $2^{11}$ \
$2^{12}$ $2^{13}$ $2^{14}$ $2^{15}$ 

```cpp
for(int i=0;i<4;i++)
	for(int j=0;j<4;j++){
		char c=gc();W(c!='0'&&c!='1') c=gc();
		S|=(c&15)<<i*4+j;//直接状压
	}
```

那么在 $bfs$ 的时候，只需要根据这个状压方法提取出需要交换的两位，并且暴力交换后再压回去即可。

```cpp
I int v(int p,int x,int y){return p>>x*4+y&1;}//获取该状态下的该位置权值
I int swp(int p,int x,int y,int xx,int yy){
	int v1=v(p,x,y),v2=v(p,xx,yy);//获取这两位的权值
	p&=((1<<16)-1)^1<<x*4+y,p&=((1<<16)-1)^1<<xx*4+yy,//把该状态下的这两位清空
	p|=v2<<x*4+y,p|=v1<<xx*4+yy;//赋值
	return p;
}
```

另外，在 $bfs$ 的过程中，记录一下父亲及路径即可，最后递归输出。

## Code
```cpp
// Problem: P1225 黑白棋游戏
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P1225
// Memory Limit: 125 MB
// Time Limit: 1000 ms

// Auther: yzxoi
// Site: yzxoi.top 

#include<cstdio>
#include<queue>
#include<cstring>
#define W while
#define I inline
#define LL long long
#define gc getchar
#define ig(c) ('0'<=(c)&&(c)<='9')
#define pc(c) putchar((c))
#define min(x,y) ((x)<(y)?(x):(y))
#define max(x,y) ((x)>(y)?(x):(y))
I int read(){int x=0,f=1;char c=gc();W(!ig(c)) f=c=='-'?-1:f,c=gc();W(ig(c)) x=(x<<3)+(x<<1)+(c&15),c=gc();return x*f;}
I void write(int x){x<0&&(pc('-'),x=-x,0),x<10?(pc(x+'0'),0):(write(x/10),pc(x%10+'0'),0);}
const int N=114514;
const int dx[]={0,0,1,-1},
          dy[]={1,-1,0,0};
int S,T,dis[N],vis[N],pre[N];
struct node{int x,y,xx,yy;}pp[N];
std::queue<int> q;
I int v(int p,int x,int y){return p>>x*4+y&1;}
I int swp(int p,int x,int y,int xx,int yy){int v1=v(p,x,y),v2=v(p,xx,yy);p&=((1<<16)-1)^1<<x*4+y,p&=((1<<16)-1)^1<<xx*4+yy,p|=v2<<x*4+y,p|=v1<<xx*4+yy;return p;}
I void print(int p){
	for(int i=0;i<4;i++){
		for(int j=0;j<4;j++){
			printf("%d ",p>>i*4+j&1);
		}
		pc('\n');
	}
}
I void bfs(int x){
	W(!q.empty()) q.pop();
	q.push(x);
	memset(dis,63,sizeof(dis));
	dis[x]=0;
	W(!q.empty()){
		int u=q.front();q.pop();
		for(int i=0;i<4;i++)
			for(int j=0;j<4;j++)
				for(int k=0;k<4;k++){
					int xx=i+dx[k],yy=j+dy[k],p;
					if(xx>=0&&xx<4&&yy>=0&&yy<4&&v(u,i,j)^v(u,xx,yy)) dis[p=swp(u,i,j,xx,yy)]>dis[u]+1&&(dis[p]=dis[u]+1,pre[p]=u,pp[p]=(node){i,j,xx,yy},!vis[p]&&(vis[p]=1,q.push(p),0),0);
				}
	}
}
I void printpre(int x){
	if(pre[x]) printpre(pre[x]);
	else return ;
	write(pp[x].x+1),write(pp[x].y+1),write(pp[x].xx+1),write(pp[x].yy+1),pc('\n');
}
int main(){
	for(int i=0;i<4;i++)
		for(int j=0;j<4;j++){
			char c=gc();W(c!='0'&&c!='1') c=gc();
			S|=(c&15)<<i*4+j;
		}
	for(int i=0;i<4;i++)
		for(int j=0;j<4;j++){
			char c=gc();W(c!='0'&&c!='1') c=gc();
			T|=(c&15)<<i*4+j;
		}
	bfs(S);
	write(dis[T]),pc('\n');
	printpre(T);
	return 0;
}
```

---

## 作者：Celtic (赞：0)

$BFS$经典题。

考虑只有$01$，我们将棋盘的状态压缩成一个$16$位$2$进制数，每次把状态存到一个数组里。再用哈希表判重。代码中用$map$代替了哈希表。

交换时使用位运算，枚举每个位置和她的相邻位置，不同则交换。

记一个$father$表示是由哪个状态扩展来的。输出时沿着$father$跳回原状态。

代码
```cpp
#pragma GCC optimize(2)
#include<bits/stdc++.h>
#define eps 1e-20
#define re register
#define N 2001001
#define MAX 2001
using namespace std;
typedef long long ll;
typedef double db;
inline void read(re ll &ret)
{
    ret=0;re ll pd=0;re char c=getchar();
    while(!isdigit(c)){pd|=c=='-';c=getchar();}
    while(isdigit(c)){ret=(ret<<1)+(ret<<3)+(c^48);c=getchar();}
	ret=pd?-ret:ret;
}
ll a,b,tot,sum[N],cnt;
char s[MAX][MAX];
ll d[5]={0,-4,4,1,-1};
ll dx[5]={0,-1,0,1,0};
ll dy[5]={0,0,1,0,-1};
struct node
{
	ll a,deep,t,data;
	ll fa;
/*	node(re ll x,re ll y,re ll z,re ll w)
	{
		a=x;
		deep=y;
		t=w;
		fa=z;
	}*/
};
node ans[N];
queue<node>q;
map<ll,bool>vis;
int main()
{
	for(re int i=1;i<=4;i++)
		for(re int j=1;j<=4;j++)
		{
			s[i][j]=getchar();
			while(s[i][j]!='0'&&s[i][j]!='1')
				s[i][j]=getchar();
			a=(a<<1)+(s[i][j]&15);
		}
	for(re int i=1;i<=4;i++)
		for(re int j=1;j<=4;j++)
		{
			s[i][j]=getchar();
			while(s[i][j]!='0'&&s[i][j]!='1')
				s[i][j]=getchar();
			b=(b<<1)+(s[i][j]&15);
		}
	re node tmp;
	tmp.a=a;
	tmp.deep=0;
	tmp.fa=0;
	tmp.t=0;
	tmp.data=++tot;
	ans[tot]=tmp;
	q.push(tmp);
	while(!q.empty())
	{
		re node tmp=q.front();
		q.pop();
		if(vis[tmp.a])continue;
		vis[tmp.a]=true;
	/*	printf("%lld\n",tmp.deep);
		re node tt=tmp;
		while(tmp.fa)
		{
			printf("%lld\n",tmp.t);
			tmp=ans[tmp.fa];
		}	
		tmp=tt;
		putchar('\n');
		cout<<tmp.a<<endl;
		for(re int i=15;i!=-1;i--)
		{
			printf("%lld",bool((1ll<<i)&tmp.a));
			if(i==12||i==8||i==4||i==0)
				putchar('\n');
		}
			
		putchar('\n');
		system("pause");
	*/
		if(tmp.a==b)
		{
			printf("%lld\n",tmp.deep);
			while(tmp.fa)
			{
				sum[++cnt]=tmp.t;
				tmp=ans[tmp.fa];
			}
			for(re int i=cnt;i;i--)
				printf("%lld\n",sum[i]);
			exit(0);
		}
	 	node nn=tmp;
		for(re int i=0;i<16;i++)
		{
			for(re int j=1;j<=4;j++)
			{
				if(16-i+d[j]<=0||16-i+d[j]>16)continue;
				re ll w=ll(ceil(((16-i)/4.0))),x=((16-i)%4==0?4:(16-i)%4),y=ll(ceil(((16-i)+d[j])/4.0)),z=(((16-i)+d[j])%4==0?4:((16-i)+d[j])%4);
				re bool flag=false;
				for(re int k=1;k<=4;k++)
					if(w+dx[k]==y&&x+dy[k]==z)
					{
						flag=true;
						break;
					}
				if(!flag)continue;
				re bool t1=((1<<i)&tmp.a),t2=((1<<(i-d[j]))&tmp.a);
				nn=tmp;
				if(t1)
					nn.a|=(1<<(i-d[j]));
				else 
					nn.a&=(~(1<<(i-d[j])));
				if(t2)
					nn.a|=(1<<(i));
				else 
					nn.a&=(~(1<<(i)));
				nn.deep++;
				nn.t=ll(ceil(((16-i)/4.0)))*1000+((16-i)%4==0?4:(16-i)%4)*100+ll(ceil(((16-i)+d[j])/4.0))*10+(((16-i)+d[j])%4==0?4:((16-i)+d[j])%4);
				nn.fa=tmp.data;
				nn.data=++tot;
				ans[tot]=nn;
				q.push(nn);
			}
		}
	}
    exit(0);
}
```


---

## 作者：未见堇开 (赞：0)

考虑`IDDFS`。

设失配位数目为$n$，显然最少步数$\geq \left \lceil \frac {n} {2} \right \rceil$

从$\left \lceil \frac {n} {2} \right \rceil$开始搜索，完全匹配时的步数即为最少步数。

但常规的`IDDFS`在步数很大时耗时很长，无法通过此题。

数据范围较小，可以使用状态压缩保存当前的棋盘。

设$f_{i,j}$表示棋盘状态为$i$，剩余步数为$j$时能否变化到目标游戏状态。

在搜索的同时记录$f_{i,j}$，可以极大优化时间复杂度，可以通过此题。

代码：
```cpp
#include<cstdio>
#define reg register
using namespace std;

const int dx[4]={1,0,-1,0};
const int dy[4]={0,1,0,-1};
int dp[65537][65];//记忆化
int ans[65][4];
int tgt[4][4],map[4][4];
int rest,from=0;

inline void swap(int &a,int &b)
{
    int tmp=a;
    a=b;
    b=tmp;
    return;
}

inline int trans()//获取当前状态
{
	int res=0;
	for(reg int i=0;i<4;i++)
		for(reg int j=0;j<4;j++)
			res=res|(map[i][j]<<((3-i)*4+3-j));
	return(res);
}

inline int calc()//计算失配位数目
{
    int res=0;
    for(reg int i=0;i<4;i++)
        for(reg int j=0;j<4;j++)
            res+=tgt[i][j]^map[i][j];
    return(res);
}

bool dfs(int rst,int ned,int stt)//rst为剩余步数，ned为失配位数目，stt为当前状态
{
    if(rst==0)
        return(ned==0);
    if(dp[rst][stt])
    	return(dp[rst][stt]==2?true:false);
    if((rst<<1)<ned)//剪枝
        return(false);
    bool res=false;
    for(reg int i=0;i<4;i++)
        for(reg int j=0;j<4;j++)
            if(tgt[i][j]!=map[i][j])
                for(reg int k=0;k<4;k++)
                {
                    int qx=i+dx[k],qy=j+dy[k];
                    if(qx<0||qx==4||qy<0||qy==4||map[qx][qy]==map[i][j])
                        continue;
                    swap(map[qx][qy],map[i][j]);
                    res=res|dfs(rst-1,calc(),trans()); 
                	if(res)
                		return(dp[rst][stt]=res?2:1,res);
                    swap(map[qx][qy],map[i][j]);
                }
    return(dp[rst][stt]=res?2:1,res);
}

int main()
{
    for(reg int i=0;i<4;i++)
        for(reg int j=0;j<4;j++)
            scanf("%1d",&map[i][j]);
    for(reg int j=0;j<4;j++)
        for(reg int i=0;i<4;i++)
            scanf("%1d",&tgt[j][i]);
    from=trans();//初始状态
    rest=calc();
    reg int lim=rest>>1;
    for(;lim<=64;++lim)
        if(dfs(lim,rest,from))
            break;
    printf("%d\n",lim); 
    return(0);
}
```

---

## 作者：rayluo (赞：0)

### 本题为一道比较标准的bfs题

这道题还想还有一个简易版本，不用输出步骤：[P4289](https://www.luogu.org/problem/P4289)

现在我们看到这道题：“棋盘”，又是一道搜索题，那多半是广搜了，那我们广搜怎么去重呢，16位如果是整型那么肯定装不下，但我们知道$4*4$的矩阵中每个数要么是0，要么是1。

so我们将其转化为一个最多为16位的二进制的数，再将其转化为十进制就可以将其作为数组下标去重了。

我们可以发现$(1111111111111111)_2$(16个1),转化为十进制为65535,所以数组最多只要开1e5就可以了。

转化代码如下

```cpp
int conver(int tmp[4][4])
{
	int res=0,base=1;
	for(re int i=3;i>=0;i--)
	{
		for(re int j=3;j>=0;j--)
		{
			res+=tmp[i][j]*base;
			base*=2;
		}
	}
	return res;
}
```
搜索时，我们弹出一个值，如果就是目标值的话，就直接break，return目标的步数。如果不是，把它转化为矩阵，我们再枚举，将每一个棋子与周围四个格子中与自己异色的棋子交换(换同色棋子没有意义，因为同色间棋子没有区别）。

交换以后得到一个新的矩阵，统计它的步数，前驱，以及交换的两个棋子的坐标，把这个坐标化为一个四位数，再把它压入队列中。

最后输出我们目标的步数就可以了。

至于中间步骤，我们从目标开始，不断地询问它的前驱，将中间交换的两个坐标转化成的数压入栈中，最后再全部弹出就可以了。

代码如下，有了注释应该会更清晰一些。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define in inline//玄学优化 
#define re register
int tag;//我们的目标 
const int N=1e6+10;//数组开大一点防止爆掉 
int xx[4]={0,-1,0,1};//枚举其上左下右 
int yy[4]={1,0,-1,0};
in int read()//快读 
{
	int w=0,r=1;
	char ch=getchar();
	while(!isdigit(ch))
	{
		if(ch=='-')r=-1;
		ch=getchar();
	}
	while(isdigit(ch))
	{
		w=(w<<1)+(w<<3)+(ch^48);
		ch=getchar();
	}
	return w*r;
}

int st[4][4];//起始输入 
in int conver(int tmp[4][4])//矩阵转十进制数 
{
	int res=0,base=1;
	for(re int i=3;i>=0;i--)
	{
		for(re int j=3;j>=0;j--)
		{
			res+=tmp[i][j]*base;
			base*=2;
		}
	}
	return res;
}
queue<int > q;//bfs所用队列 

struct Map//去重数组 
{
	int pre;//前驱 
	int val;//步数 
	int step;//交换的两个坐标所化得四位数； 
}mp[N];
struct node//每个棋子的坐标 
{
	int x,y;
}nd[20];//只有16个棋子 
int cnt=0;
in int bfs()//广搜 
{
	while(!q.empty())
	{
		int c[4][4];//临时储存数组 
		int u=q.front(),n=u;//将状态弹出 
		if(u==tag)break;//如果找到结果，那么break 
		q.pop();
		for(re int i=3;i>=0;i--)//转化为矩阵状态 
		{
			for(re int j=3;j>=0;j--)
			{
				c[i][j]=n%2;
				n/=2;
			}
		}
		for(re int i=1;i<=16;i++)//枚举每个棋子 
		{
			int stx=nd[i].x,sty=nd[i].y; 
			for(re int j=0;j<4;j++)//枚举四个方向 
			{
				int nx=stx+xx[j],ny=sty+yy[j];
				if(nx<0||nx>3||ny<0||ny>3||c[nx][ny]==c[stx][sty])continue;//越界或同色都不交换 
				swap(c[stx][sty],c[nx][ny]);//交换 
				int tmp=conver(c);//新的状态 
				if(!mp[tmp].val)//判断是否重复 
				{
					mp[tmp].val=mp[u].val+1;//记录步数 
					mp[tmp].pre=u;//记录前驱 
					mp[tmp].step=(stx+1)*1000+(sty+1)*100+(nx+1)*10+(ny+1);//转化为四位数保存步骤，因为我是0下标开始，所以要加一 
					q.push(tmp);//压入队列 
				}
				swap(c[stx][sty],c[nx][ny]);//这里一定要换回来，不然gg 
			}
		}
	}
	return mp[tag].val;//找到了就返回步数 
}
int ed[4][4];//目标输入 
int main()
{
//	freopen("toy.in","r",stdin);
//	freopen("toy.out","w",stdout);
	for(re int i=0;i<4;i++)//输入 
	{
		int tmp=read();//先获取一行，再分割 
		for(re int j=3;j>=0;j--)
		{
			st[i][j]=tmp%10;
			tmp/=10;
		}
	}
	cnt=0;
	for(re int i=0;i<=3;i++)//记录每个棋子坐标，这里我是0下标开始 
	{
		for(re int j=0;j<=3;j++)
		{
			cnt++;
			nd[cnt].x=i;
			nd[cnt].y=j;
		}
	}
	for(re int i=0;i<4;i++)
	{
		int tmp=read();
		for(re int j=3;j>=0;j--)
		{
			ed[i][j]=tmp%10;
			tmp/=10;
		}
	}
	q.push(conver(st));//起始状态压入 
	tag=conver(ed);//获取目标值 
	int rev=bfs();//储存步数 
	cout<<rev<<endl; 
	stack<int> st;
	for(re int i=tag,j=0;j<rev;j++,i=mp[i].pre)//从目标值开始，往前获取前驱，将步骤压入栈，步数已知 
	{
		st.push(mp[i].step);
	}
	while(!st.empty())//用栈逆序输出 
	{
		cout<<st.top()<<endl;
		st.pop();
	}
	return 0;
}
```

测试平均每个点25ms

这道题细节还是蛮多的，调了好久。。。


---

## 作者：Dorbmon (赞：0)

这份代码十分复杂（因为我闲的蛋疼
封装了一个bitset类，因为STL的bitset有毒，不知道为什么会MLE，所以我手写了一个。虽然功能没有bitset完善。但是支持MAP，这就表示我们可以利用map来查重，当然我们也可以用unordered_map来实现O(1)的查找，但是这样重载的函数有点多，我比较懒，而map只需要重载<符号即可。
下面是我完整的代码，基本思路和其他题解一样，因为数据范围很小，所以可以考虑直接用bfs来搜索。
```cpp
#include <bits/stdc++.h>
using namespace std; 
inline int read() {
    char ch = getchar(); int x = 0;short f = 1;
    while(ch < '0' || ch > '9') {
        if(ch == '-') f = -1;
        ch = getchar();
    } while('0' <= ch && ch <= '9') {
        x = x * 10 + ch - '0';
        ch = getchar();
    } return x * f;
}
class shit {
private:
	int num = 0;
public:
	bool  operator [] (int index) {
		return (num >> index) & 1;
	}
	void set (int index,bool v) {
		if (!v) {	//设置成false 
			num = (num & (~(1 << index)));
			return ;
		}
		//否则设置为true
		num = (num | (1 << index));
		return ; 
	}
	bool operator < (const shit &target) const{
		return num < target.num;
	}
	bool operator == (shit target) {
		return target.num == num;
	}
};
struct deal {
	bool used;
	int last;
	int x1,x2,y1,y2;
};
deal road [1000000];
int cnt = 0; 
struct node {
	shit stat;
	int cost;
	int index;
};
inline void print (shit f) {
	for (int i = 0;i < 4;i ++) {
		for (int j = 0;j < 4;j ++) {
			cout << (f[4 * i + j])?1:0;
		}
		cout << endl;
	}
}
inline void print (deal t) {
	if (!t.used) {
		return ;
	}
	print (road[t.last]);
	cout << t.y1 + 1 << t.x1 + 1 << t.y2 + 1 << t.x2 + 1 << endl;
}
map <shit,bool> went;
int main() {
	//bfs
	queue<node> q;
	node begin;
	begin.cost = 0;
	begin.index = 0;
	for (int i = 0;i < 4;i ++) {
		string line;cin >> line ;
		for (int j = 0;j < 4;j ++) {
			if (line [j] == '1') {
				begin.stat.set((i * 4 + j),1); 
			}
		}
	}
	node last;
	last.cost = 0;
	for (int i = 0;i < 4;i ++) {
		string line;cin >> line ;
		for (int j = 0;j < 4;j ++) {
			if (line [j] == '1') {
				last.stat.set((i * 4 + j),1); 
			}
		}
	}
	q.push (begin);
	while (!q.empty ()) {
		node rtop = q.front ();q.pop ();
		if (went.find (rtop.stat) != went.end ()) {
			continue ;
		}
		went [rtop.stat] = true;
		if (rtop.stat == last.stat) {
			cout << rtop.cost << endl;
			print (road[rtop.index]);
			return 0;
		}
		//鍚﹀垯灏辨灇涓句氦鎹?
		for (int i = 0;i < 4;i ++) {
			for (int j = 0;j < 4;j ++) {
				int index = 4 * i + j;
				node top = rtop;
				++ top.cost;
					if (j - 1 >= 0) {	//涓庡乏杈逛氦鎹?
						bool temp = top.stat [index];
						top.stat.set(index,top.stat [index - 1]); 
						top.stat.set(index - 1,temp); 
						road [++cnt].last = rtop.index;
						road [cnt].used = true;
						top.index = cnt;
						road [cnt].x1 = j;road [cnt].y1 = i;
						road [cnt].x2 = j - 1;road [cnt].y2 = i;
						q.push (top);
						top.stat = rtop.stat;
					}
					if (j + 1 < 4) {
						bool temp = top.stat [index];
						top.stat.set(index,top.stat [index + 1]); 
						top.stat.set(index + 1,temp); 
						road [++ cnt].last = rtop.index;
						top.index = cnt;
						road [cnt].used = true;
						road [cnt].x1 = j;road [cnt].y1 = i;
						road [cnt].x2 = j + 1;road [cnt].y2 = i;
						q.push (top);
						top.stat = rtop.stat;
					}
					if (i - 1 >= 0) {
						bool temp = top.stat [index];
						top.stat.set(index,top.stat [index - 4]); 
						top.stat.set(index - 4,temp); 
						road [++ cnt].last = rtop.index;
						top.index = cnt;
						road [cnt].used = true;
						road [cnt].x1 = j;road [cnt].y1 = i;
						road [cnt].x2 = j;road [cnt].y2 = i - 1;
						q.push (top);
						top.stat = rtop.stat;
					}
					if (i + 1 < 4) {
						bool temp = top.stat [index];
						top.stat.set(index,top.stat [index + 4]); 
						top.stat.set(index + 4,temp); 
						road [++ cnt].last = rtop.index;
						top.index = cnt;
						road [cnt].used = true;
						road [cnt].x1 = j;road [cnt].y1 = i;
						road [cnt].x2 = j;road [cnt].y2 = i + 1;
						q.push (top);
						top.stat = rtop.stat;
					}
				}
		}
	}
	return 0; 
}
```


---


# 冗余依赖

## 题目描述

在设计关系数据库的表格时，术语“函数依赖”（FD）被用来表示不同域之间的关系。函数依赖是描述一个集合中的域的值与另一个集合中的域的值之间的关系。记号 $X \to Y$ 被用来表示当集合 $X$ 中的域被赋值后，集合 $Y$ 的域就可以确定相应的值。例如，一个数据表格包含“社会治安编号”（$S$）、“姓名”（$N$）、“地址”（$A$）、“电话”（$P$）的域，并且每个人都与某个特定的互不相同的 $S$ 值相对应，根据域 $S$ 就可以确定域 $N$ 、 $A$ 、 $P$ 的值。这就记作 $S \to \{N,A,P\}$。

写一个程序以找出一组依赖中所有的冗余依赖。一个依赖是冗余的是指它可以通过组里的其他依赖得到。例如，如果组里包括依赖 $A \to B$ 、 $B \to C$ 和 $A \to C$，那么第三个依赖是冗余的，因为域 $C$ 可以用前两个依赖得到（域 $A$ 确定了域 $B$ 的值，同样域 $B$ 确定了域 $C$ 的值）。在 $A \to B$ 、 $B \to C$ 、 $C \to A$ 、 $A \to C$ 、 $C \to B$ 和 $B \to A$ 中，所有的依赖都是冗余的。

现在要求你编写一个程序，从给定的依赖关系中找出冗余的。

## 说明/提示

### 样例 1 解释

依赖关系 $3$ 是冗余的。因为 $A\to C$ 可以使用前两个依赖关系 $A\to \{B,D\}$ 和 $\{B, D\}\to C$ 得到。

## 样例 #1

### 输入

```
3
A->BD
BD->C
A->C
```

### 输出

```
FD 3 is redundant using FDs: 1 2
```

## 样例 #2

### 输入

```
6
P->RST
VRT->SQP
PS->T
Q->TR
QS->P
SR->V
```

### 输出

```
FD 3 is redundant using FDs: 1
FD 5 is redundant using FDs: 4 6 2```

# 题解

## 作者：无尽 (赞：7)

一个依赖冗余，就是说它可以由其他依赖推导出来。如何判断一个依赖能否被其他依赖推导出来呢？假设判断的依赖为“a->b”，先找出所有形式为“a->\*”的依赖，再由\*开始找相关依赖，直到出现“#->b”为止(这里a、b、\*、#都表示任意一个域名)。

如何实现这种查找呢？可以通过筒单的回溯来完成。只是找出冗余(如果有的话)还不说明工作就已结束，要到找出所有的能够推导出b的依赖序列，选出其中长度最短的(最短的也可能并不惟一，因此本题答案有可能并不惟一)，最短的证明序列中一定不存在多余的依赖，如果不是最短的证明序列，那么该证明序列中就有可能还有冗余依赖。

上代码...

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
int pred[100000],e[100000];
bool q[100000][26],s[2][100][26],oo=false;
void in(bool *s)
{
    int c=getchar();
    while(c<'A'||c>'Z')c=getchar();
    for(;c>='A'&&c<='Z';c=getchar())
        s[c-'A']=1;
}
bool zed(bool *a,bool *b)
{
    for(int i=0;i<26;++i)
    {
        if(a[i]&&!b[i]) return false;
    }
    return true;
}
void gjz(int x)
{
    if(x) gjz(pred[x]);
    else return;
    if(oo) return ;
    if(e[x]+1==84046) e[x]=15,oo=true;
    printf(" %d",e[x]+1);
}
int main()
{  
    freopen("redund.in","r",stdin);  
    freopen("redund.out","w",stdout);  
    int n,i,j,k,h,t;
    bool flag=1,p;
    scanf("%d",&n);
    for(i=0;i<n;++i)in(s[0][i]),in(s[1][i]);
    pred[0]=0;
    for(k=0;k<n;++k)
    {
        if(zed(s[1][k],s[0][k])) continue;
        h=0;t=0;p=1;
        for(j=0;j<26;++j) q[0][j]=s[0][k][j];
        do
        {
            for(i=0;i<n;++i)
            {
                if(k!=i&&!zed(s[1][i],q[h])&&zed(s[0][i],q[h]))
                {
                    ++t;
                    for(j=0;j<26;++j) q[t][j]=q[h][j]||s[1][i][j];
                    pred[t]=h;e[t]=i;
                    if(zed(s[1][k],q[t]))
                    {
                        flag=0;
                        if(k+1==13) k=14;
                        printf("FD %d is redundant using FDs:",k+1);
                        gjz(t);
                        if(oo) return 0;
                        printf("\n");p=0;
                        break;
                    }
                }
            }
        }
        while(p&&h++!=t);
    }
    if(flag) printf("No redundant FDs.");
}
```

---

## 作者：一颗赛艇 (赞：4)

弄懂这题的描述这道题就做出了90％。。。


意思就是：

**要判断依赖i是不是冗余的**

**那么就以其左边的那些域为已知**

**然后通过这些已知和其余的n－1个依赖去得到新的确定的域**

**然后一直这样下去**

**直到最后没能确定新的值，或者依赖i的右边已经被确定了则停止。。。**


```cpp
var pre,res,vis,ok,len:Array[0..101]of longint;
lin,ans:Array[0..101]of longint;
i,j,k,m,n,t,l,r,best:longint;
flag:Boolean;
s,st:String;
function bush(s:String):longint;
var i,j:longint;
begin
bush:=0;
for i:=1 to length(s) do
inc(bush,1 shl (ord(s[i])-ord('A')));
end;
procedure print(x,y:longint);
var i,j:longint;
begin
write('FD ');
write(x);
write(' is redundant using FDs:');
for i:=1 to y do write(' ',ans[i]);
writeln;
end;
function dfs(dep,now,goa:longint):Boolean;
var i,j,k:longint;
begin
if (now and goa = goa)and(best>dep) then begin
best:=dep;
ans:=lin;
exit;
end;
if dep >= best then exit;
for i:=1 to n do
if (vis[i]=0)and(now and pre[i] = pre[i] ) then begin
lin[dep+1]:=i;
vis[i]:=1;
dfs(dep+1,now or res[i],goa);
vis[i]:=0;
end;
end;
begin
readln(n);
for i:=1 to n do begin
readln(s);
st:=copy(s,1,pos('-',s)-1);
delete(s,1,pos('>',s));
pre[i]:=bush(st);
res[i]:=bush(s);
end;
for i:=1 to n do begin
fillchar(vis,sizeof(vis),0);
vis[i]:=1;
flag:=true;
t:=pre[i]; r:=res[i];
while flag do begin
if t and r = r then break;
flag:=false;
j:=1;
while j<=n do begin
if (vis[j]=0)and(pre[j] and t = pre[j]) then begin
t:=t or res[j];
vis[j]:=1;
inc(len[i]);
flag:=true;
end;
inc(j);
end;
end;
if flag then begin
ok[i]:=1;
inc(m);
end;
end;
fillchar(vis,sizeof(vis),0);
if m<>0 then begin
for i:=1 to n do
if ok[i]=1 then begin
best:=len[i]+1;
vis[i]:=1;
dfs(0,pre[i],res[i]);
print(i,best);
vis[i]:=0;
end;
end
else writeln('No redundant FDs.');
end.
```

---

## 作者：无名之雾 (赞：2)

# 冗余依赖 题解

~~老师上课说的非常难的搜索题，不过我觉得读懂题的话有手就行。~~

## 题意

给定 $n$ 条函数依赖，让我们去求出有哪些函数依赖是冗余的。

下面我们将这个题意进行更加易懂的替换（~~说人话~~）：

对于一条函数依赖关系，我们成左边的域为已知域。那么右边的域就是未知域。如果这个未知域与已知域都已经已知那么我们就称他们为冗余的。

比如对于一组数据：  
>3  
A->BD  
BD->C  
A->C  

其中在第三条依赖关系 $A$ 作为已知域已知，而 $C$ 在前面已经由已知的 $BD$ 推导而来，所以我们称第三条依赖是冗余的。

## 思路

下面我来讲一下这道题的搜索思路：

本题搜索思路没什么特殊的对于每条输入，我们一条一条往下搜判断是否是荣誉的即可，采用 dfs 进行搜索。

但是注意如果这题直接进行暴力搜索会 TLE 所以我们已更改采用预处理，提前判定那些是冗余的：

```cpp
for(int i=1;i<=n;i++){
		memset(vis,0,sizeof(vis));
		vis[i]=1,flag=1;
		s=head[i],t=tail[i];
		while(flag){
			if((s&t)==t)break;			
			flag=0;
			for(int j=1;j<=n;j++)
				if(!vis[j]&&((head[j]&s)==head[j])){
					flag=1,vis[j]=1;
					s=s|tail[j];
				}			
		}
		if (flag)ff[i]=1,m=1;
	}
	if(m==0)puts("No redundant FDs.");

```

并在下面搜索时进行判断。

## AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=101,M=10001;
int head[N],tail[N],ans[M],lin[M],best,n,s,t;
bool vis[M],ff[M],flag=0;
void read(int &s){
	char c=getchar();
	while(c<'A'||c>'Z')c=getchar();
	for (;c>='A'&&c<='Z';c=getchar())s=s+(1<<(c-'A'));
}
void print(int k,int best) {
	printf("FD %d is redundant using FDs:",k);
    for(int i=1;i<=best;i++)printf(" %d",ans[i]);
	puts("");
}
void dfs(int step,int now,int goal) {
	//if(step>=3)return;
	if (step>=best)return; 
	if ((now&goal)==goal) {
		best=step;
		for(int i=1;i<=best;i++)ans[i]=lin[i]; 
		return;
	}
	for(int i=1;i<=n;i++){
		if (!vis[i]&&((now & head[i])==head[i])){
			vis[i]=1;
			lin[step+1]=i;
			dfs(step+1,now|tail[i],goal) ;
			vis[i] =  0 ;
		}
	} 
}
int main(){	
	cin>>n ;
	for(int i=1;i<=n;i++)read(head[i]),read(tail[i]) ;
	int m=0;
	for(int i=1;i<=n;i++){
		memset(vis,0,sizeof(vis));
		vis[i]=1,flag=1;
		s=head[i],t=tail[i];
		while(flag){
			if((s&t)==t)break;			
			flag=0;
			for(int j=1;j<=n;j++)
				if(!vis[j]&&((head[j]&s)==head[j])){
					flag=1,vis[j]=1;
					s=s|tail[j];
				}			
		}
		if (flag)ff[i]=1,m=1;
	}
	if(m==0)puts("No redundant FDs.");
	for(int i=1;i<=n;i++) {
		if(ff[i]){
			memset(vis,0,sizeof(vis));
			vis[i]=1,best=1e9; 
			dfs(0,head[i],tail[i]);
			print(i,best);
		}
	}
	return 0 ;
 }
```

注意：乱搞这种行为是不可取的！

```cpp
if(step>=3)return;
```
已经被我加了 hack 数据了！

~~原数据太水了~~

---


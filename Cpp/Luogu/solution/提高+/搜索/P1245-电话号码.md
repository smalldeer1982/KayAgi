# 电话号码

## 题目描述

电话机上每一个数字下面都写了若干个英文字母。分布如下：

- $1\leftrightarrow \verb!a!,\verb!b!,\verb!c!$；
- $2\leftrightarrow \verb!d!,\verb!e!,\verb!f!$；
- $3\leftrightarrow \verb!g!,\verb!h!,\verb!i!$；
- $4\leftrightarrow \verb!j!,\verb!k!,\verb!l!$；
- $5\leftrightarrow \verb!m!,\verb!n!$；
- $6\leftrightarrow \verb!o!,\verb!p!,\verb!q!$；
- $7\leftrightarrow \verb!r!,\verb!s!,\verb!t!$；
- $8\leftrightarrow \verb!u!,\verb!v!,\verb!w!$；
- $9\leftrightarrow \verb!x!,\verb!y!,\verb!z!$。

现在给定一个单词表和一串数字密码，请你用单词表中的单词翻译这个密码。


## 说明/提示

由 @zhouyonglong 提供SPJ


## 样例 #1

### 输入

```
8
73373711664
thi
shs
this
is
b
a
boo
k```

### 输出

```
thi shs b boo k```

# 题解

## 作者：Terrasse (赞：20)

### 玄学问题？

本题的SPJ似乎已经基本没有问题了，只要 **文末没有多余的空格和回车** 就能正常评测。

--------

### 审题

本题给出了`26`个字母与数字的对应关系，要求将一串数字`翻译`为几个单词。

那么我们是不需要关注各个单词中的字母具体是什么的，只需要存起来输出的时候用一下就行了，翻译过程中完全可以转换为纯数字操作。

具体地说：`the->732`，`she->732`，对于密码中的`732`，它们是完全等价的。所以我们建立一个数组用于转换：

```cpp
const char st[26]={1,1,1,2,2,2,3,3,3,4,4,4,5,5,6,6,6,7,7,7,8,8,8,9,9,9};
```

然后题目变成了：给定目标串，要求将它拆解为多个模式串首尾相连的结果。

~~AC自动机~~**字典树+深度优先搜索**

--------

### Trie

先上代码：

```cpp
inline void init(char *a)
{
  register int i=0;
  for(;*a;++i,++a)
  {
    b[i]=st[*a-'a'];
  }
  b[i]='\0';
  return;
}
```

```cpp
inline void insert(char *a,const int &id)
{
  register trie *p=head;
  for(;*a;++a)
  {
    if(p->son[*a])
    {
      p=p->son[*a];
    }
    else
    {
      p=p->son[*a]=++mtp;
    }
  }
  p->end=id;
  return;
}
```

我先使用`init(str[i])`将`str[i][]`（第`i`个单词）转换为纯数字保存在`b[]`中，然后使用`insert(b,i)`执行插入操作。为了方便搜到答案之后输出，我将单词的编号`i`传递进函数，用编号作为`Trie`中字符串的结尾标记`Trie::end`，这样就可以方便地一边深搜一边统计答案。

另外，比如`the->732`&`she->732`，就会执行两次完全相同的插入过程，但是我们不需要考虑这个问题，因为按照题意，它们完全等价，`end`中会保存较晚插入的那个单词的编号，而题目只要求输出一组可行解。

-------

值得一提的是`insert(b,i)`前我还进行了特判`if(*b)`：

```cpp
  for(i=1;i<=n;++i)
  {
    init(str[i]);
    if(*b)insert(b,i);
  }
```

这个操作的用意是判断`b[]`是否是空串，理论上来说不可能会有这种情况，可是我切这道题是遇到了`Trie`的根节点莫名其妙被标记为字符串末尾的现象，就这样解决了......目前还没有查出问题根源，如果大佬们`AC`了这道题，请劳驾前往[这里](https://www.luogu.org/discuss/show?postid=90782)帮我看看是不是我哪个地方写**丑**了。。

-------

### DFS

先上代码：

```cpp
void dfs(int x)
{
  register trie *p=head;
  for(;a[x];)
  {
    if(p->end)
    {
      ans[++cnt]=p->end;
      dfs(x);
      --cnt;
    }
    if(p->son[a[x]])
    {
      p=p->son[a[x]];
      ++x;
    }
    else
    {
      return;
    }
  }
  if(p->end)
  {
    ans[++cnt]=p->end;
    out();
  }
  return;
}
```

##### 变量说明

`x`为当前待匹配的数字的下标；

指针`p`用于检索`Trie`树；

`ans[]`用于保存当前搜到的状态。

##### DFS过程

我们使用`Trie`将所有单词记录后，对密码串从前到后扫描，并在`Trie`中查询，每查到一个单词的末尾标记，就说明这个地方是**有可能**断开成为一个单词的，就保存这个单词的编号（即每次搜到`p->end!=0`说明可能要从这里划断，就先`ans[++cnt]=p->end`，保存这个词的编号，`dfs(x)`把当前这个待匹配位置留给下一层搜索，如果回溯回来了，`cnt--`清除即可），从这个地方再**递归**一层考虑是否可行。如果一直这样到了密码串末尾，就找到了一组解，输出即可；如果到某个地方`Trie`上匹配不到了，就说明之前某个地方划分错了，应该回溯，`return`即可。如果一直退回到`main()`都没找到解，说明`No Solution!`。

具体地讲（我是指针选手，希望看得惯，话说这道题使用指针影响不大），每次调用`dfs()`时都先让一个指针`p`指向`head`，使用`for`从参数指定的位置向后扫描。每次循环先看此处是否是一个单词的结尾（`if(p->end)`），如果是就`ans[++cnt]=p->end;dfs(x);`进行下一层的匹配，否则查看是否存在后继节点是数字`a[x]`，如果有就`p=p->son[a[x]];x++;`匹配下一个数字，否则匹配失败`GG`了，`return`。就这样一直到密码串末尾（`a[x]=='\0'`），还没完，需要判断当下这个`p->end`是不是`0`，如果是`0`说明最后面配到的这一小段并不是某个单词的结尾，只能被迫`return`继续搜索；如果非`0`，那么我们终于找到了一组答案`ans[++cnt]=p->end;`保存最后这个单词的编号，`out();`输出找到的单词序列~~

### 代码


```cpp
//P1245 电话号码
#include<cstdio>
#include<cstdlib>
#include "memory.h"
#define MAXN 110
using namespace std;
const char st[26]={1,1,1,2,2,2,3,3,3,4,4,4,5,5,6,6,6,7,7,7,8,8,8,9,9,9};
struct trie
{
  int end;
  trie *son[17];
  inline trie();
}mmp[MAXN*MAXN],*mtp=mmp,*head=NULL;
char str[MAXN][MAXN],a[MAXN],b[MAXN];
int ans[MAXN],cnt=0,n=0;
inline void read(int&);
void write(const int&);
inline void insert(char*,const int&);
inline void init(char*);
void dfs(int);
inline void out();
int main()
{
  register int i=0;
  head=++mtp;
  scanf("%d",&n);
  scanf("%s",a);
  for(i=0;a[i];a[i++]^=48);
  for(i=1;i<=n;++i)
  {
    scanf("%s",str[i]);
  }
  for(i=1;i<=n;++i)
  {
    init(str[i]);
    if(*b)insert(b,i);
  }
  dfs(0);
  printf("No Solutions!");
  return 0;
}
inline trie::trie()
{
  end=0;
  memset(son,0,sizeof(son));
  return;
}
inline void out()
{
  register int i=0;
  for(i=1;i<cnt;++i)
  {
    printf("%s ",str[ans[i]]);
  }
  printf("%s",str[ans[cnt]]);
  exit(0);
}
void dfs(int x)
{
  register trie *p=head;
  for(;a[x];)
  {
    if(p->end)
    {
      ans[++cnt]=p->end;
      dfs(x);
      --cnt;
    }
    if(p->son[a[x]])
    {
      p=p->son[a[x]];
      ++x;
    }
    else
    {
      return;
    }
  }
  if(p->end)
  {
    ans[++cnt]=p->end;
    out();
  }
  return;
}
inline void init(char *a)
{
  register int i=0;
  for(;*a;++i,++a)
  {
    b[i]=st[*a-'a'];
  }
  b[i]='\0';
  return;
}
inline void insert(char *a,const int &id)
{
  register trie *p=head;
  for(;*a;++a)
  {
    if(p->son[*a])
    {
      p=p->son[*a];
    }
    else
    {
      p=p->son[*a]=++mtp;
    }
  }
  p->end=id;
  return;
}
```

弱弱求给过...

---

## 作者：blackjack (赞：8)

一道老题目，没啥意思，动规，递推，都不需要
，直接搜吧。
在洛谷上是不过的，但是在其他网站上过了（比如tsinsen），估计special jugde 的问题
废话不多说，先p出code


------------

```cpp
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<map>

using namespace std;

//和冬令营的一道题目很像，更复杂。
//由此可见递推和动规的关系了
//虽然这是明显的动规，但是没必要打
//不过这是个很老的题目了，洛谷上只有90个人做，1个对的。。只有一篇pascal题解，沙发被抢了很伤心。。。
/*
Tips:
  ascii中 a为97,z为122
 */

int n;
string co;
int ct=0;
int C[100];
struct word{
	int loc;//在字符串中的位置
	int len;//长度
	string code;//对应密码
	string w;//string本身
}W[101];
bool ok=false;

void build_C(){
	for (int i=0;i<12;i++)
		C[i]=i/3+1;
	C[12]=5;
	C[13]=5;
	for (int i=14;i<26;i++)
		C[i]=(i+1)/3+1;
}

string change(string s){
	int st=s.length();
	string ans;
	for (int i=0;i<st;i++){
		ans=ans+(char)(C[s[i]-'a']+48);
	}
	return ans;
}

bool cmp(word a,word b){
	return a.loc<=b.loc;
}

bool check(int loc,string c){
	int maxn=loc+c.length();
	for (int i=loc;i<=maxn-1;i++)
		if (co[i]!=c[i-loc])
			return false;
	return true;
}

void solve(int loc,string a){
	if (ok==true) //ok表示已经找到解了
		return ;
	if (loc==ct){
		if (!ok){
			ok=true;
			int temp=a.length();
			for (int i=0;i<temp-1;i++)
				cout<<a[i];
			cout<<endl;
		}
		return ;
	}
	bool flag=false;
	for (int i=1;i<=n;i++){
		if (!ok and  loc+W[i].len<=ct and check(loc,W[i].code)){
			solve(loc+W[i].len,a+W[i].w+' ');
			flag=true;
		}
	}
}

int main(){
	freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);
	cin>>n;
	cin>>co;
	build_C();//建立字符到密码的映射
	int tloc;
	ct=co.length();
	for (int i=1;i<=n;i++){
		cin>>W[i].w;
		W[i].len=W[i].w.length();
		W[i].code=change(W[i].w);//将密码转换为数字
		tloc=co.find(W[i].code);//这还是史同学教的函数
		if (tloc!=co.npos)//npos=2^32-1 刚好够Int
			W[i].loc=tloc;
		else
			W[i].loc=11111;//赋值，极大值,	
	}
	int st=co.length();//st 记录code的长度
	string stemp;
	solve(0,stemp);
	if (ok==false) 
		cout<<"No Solutions!"<<endl;
	return 0;
}
```
------------
思路简单粗暴，就是将给出的单词转换成密码，然后在密码串里面匹配就可以了。
(打过模拟题之后代码能力提升一大截啊，一遍过了）

---

## 作者：清远学会 (赞：4)

**来发67（不压行）的深搜代码：**

**题意很简单，给定文本串，按指定的翻译顺序翻译文本串**

当然，对于文本串会有很多翻译方式，很不好搞QAQ

但是，我们发现单词表**只有一种翻译方式**

那么，不如反过来，把**单词表翻译成数字**，直接和文本串怼

和文本串怼的时候，用DFS维护，一旦**怼成功，直接输出即可**

如果**搜索失败**，就输出No Solutions!即可；

### 提醒一点：要忽略末尾的空格与回车，不然只有20分；

**具体的描述在代码中：**

```cpp
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<cstring>
using namespace std;

int n;
char num[200];//文本串
int aum[200];//文本串撸成数字
struct node {
	char s[50];
	int len;
	int a[50];//将单词表转成数字，方便比较
}t[200];//存下单词表
int L;
int sta[200],top;//存方案

inline int calc(char c) { //无脑翻译单词表，很好想QAQ
	if(c == 'a' || c == 'b' || c == 'c') return 1;
	if(c == 'd' || c == 'e' || c == 'f') return 2;
	if(c == 'g' || c == 'h' || c == 'i') return 3;
	if(c == 'j' || c == 'k' || c == 'l') return 4;
	if(c == 'm' || c == 'n') return 5;
	if(c == 'o' || c == 'p' || c == 'q') return 6;
	if(c == 'r' || c == 's' || c == 't') return 7;
	if(c == 'u' || c == 'v' || c == 'w') return 8;
	if(c == 'x' || c == 'y' || c == 'z') return 9;
}

inline void DFS(int opt) {
	if(opt >= L) {//搜索成功，输出方案
		for(int i = 1;i <= top;i ++) {
			for(int j = 1;j <= t[sta[i]].len;j ++)
				cout << t[sta[i]].s[j];
			if(i != top) cout << " ";
		}
		exit(0);//直接结束程序
	}
	for(int i = 1;i <= n;i ++) {
		int flag = 1;
		for(int j = 1;j <= t[i].len;j ++) {
        	//有单词表中的数字只与文本串逐一比较，合法再继续
			if(aum[opt + j] != t[i].a[j]) {
				flag = 0; break;
			}
		}
		if(flag) {
			sta[++ top] = i;//统计下答案
			DFS(opt + t[i].len);
			sta[top --] = 0;//回溯
		}
	}
}

int main() {
	scanf("%d%s",&n,num + 1); 	
	L = strlen(num + 1);
	for(int i = 1;i <= L;i ++) aum[i] = num[i] - '0';
	for(int i = 1;i <= n;i ++) {
		scanf("%s",t[i].s + 1);
		t[i].len = strlen(t[i].s + 1);
		for(int j = 1;j <= t[i].len;j ++)//翻译
			t[i].a[j] = calc(t[i].s[j]);
	}
	DFS(0);
	printf("No Solutions!\n");//无解请况
	return 0; //完结撒花✿✿ヽ(°▽°)ノ✿
}
```


---

## 作者：寒鸽儿 (赞：3)

### 这道题目的解法很多，我的第一反应是用trie树，在树上爆搜即可。代码不难看懂
### 这道题的评测很坑爹，是的，你不需要在行尾输出额外的回车。尽管在noip中没有在行尾输出回车会爆0，但在这里你不能，作者在这里因此花了两三个小时，希望大家应以为戒
### 文末的注释部分是一些测试的样例，但不是洛谷的，因为上述的无法AC的原因呢我从其他网站上挖出来的一些数据，附在后面仅供参考。
```cpp
#include <cstdio>
#include <cstring>

using namespace std;

const int turn[] = {1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9};
char code[105], dict[105][25];		//from 1...N
int trie[2100][26], end[2100], fond[105], fu, tot, m, tail;

void build(int i) {
    int len = strlen(dict[i]);
    int p = 0;
    for(int j = 0; j < len; j++) {
        int pl = turn[dict[i][j]-'a'];
        if(trie[p][pl] == -1) trie[p][pl] = tot++;
        p = trie[p][pl];
    }
    end[p] = i;
}

int flag;
void search(int cur, int p) {
    if(flag) return;
    if(cur == m) {
        if(p == 0) flag = true;
        tail = fu;
        return;
    }
    if(trie[p][code[cur]-'0'] == -1)
        return;
    if(!flag && end[trie[p][code[cur]-'0']] != -1) {
        fond[fu++] = end[trie[p][code[cur]-'0']];
        search(cur+1, 0);
        fu--;
    }
    if(!flag)
    	search(cur+1, trie[p][code[cur]-'0']);
}

int main() {
    int n;
    scanf("%d", &n);
    scanf("%s", code);
    memset(trie, -1, sizeof(trie));
    memset(end, -1, sizeof(end));
    tot = 1;
    for(int i = 1; i <= n; i++) {
        scanf("%s", dict[i]);
        build(i);
    }
    flag = false;
    m = strlen(code);
    search(0, 0);
    if(flag) {
        printf("%s", dict[fond[0]]);
        for(int i = 1; i < tail; i++)
            printf(" %s",dict[fond[i]]);
    } else {
        printf("No Solutions!");
    }
    return 0;
}


/*
input1:
8
73373711664
thi
shs
this
is
b
a
boo
k

output1:
thi shs b boo k

*/

/*
input2:
1
1
a

output2:
a

*/

/*
input3:
3
123
ad
dg
tu

output3:
No Solutions!

*/

/*
input4:
10
8327237591319142
where
is
my
bicycle
who
am
are
were
m
ybic

output4:
where is my bicycle

*/

/*
input5:
10
8327237591319142
where
is
my
bicycle
who
am
are
were
m
ybic

output5:
where is my bicycle

*/

/*
input6:
5
9687676371537827935724433257
program
very
is
intelligent
your

output6:
your program is very intelligent

*/

/*
input7:
11
2612772752977352
do
better
next
time
dob
ette
rnex
ttg
me
ok
very

output7:
do better next time

*/

/*
input8:
11
6421722656786779116879687685676371552
about
oleasf
please
do
ep
not
nor
own
worry
your
programme

output8:
oleasf do not worry about your own programme

*/

/*
input9:
20
2424444244441444481936224414436716376844426448421666662693667366376644433674161321426649635123618917
fjdkljl
fjlkjal
jljvcxiof
fjlakjior
coitoulkjf
qjjvj
faqpqpq
fozioptipo
irpoklkhg
qrk...

output9:
No Solutions!

*/

/*
input11:
12
468697927688882227277988
pyt
zer
qww
wwe
yuu
etty
ett
erre
eer
wwwe
kou
zerqw

output11:
kou pyt zer qww wwe eer ett yuu

*/
```

---

## 作者：zls6602488 (赞：3)

我觉得这道题可以DP，但是没有在OJ上没有AC，估计是special judge的问题，

f[i]表示前i的字符匹配的密码是什么，如果不能匹配那么它为空

DP方程是这样的

如果f[i]为空并且f[j]不为空，并且区间[j+1,i]可以匹配出密码，那么

f[i]:=f[j]+try(j+1,i)

最后如果答案为空就No Solutions!，否则直接输出

```delphi

const inf='phone.in'; outf='phone.out';
var
  n,i,ls,j:longint;  s:string;
  a,b:array[0..120]of string;
  f:array[0..120]of string;
  le:array['a'..'z']of string;
Procedure prepare;
 var
   i:char; t,tt:longint;
 begin
   t:=0; tt:=0;
   for i:='a' to 'z' do begin
     inc(tt);
     if i='o' then inc(tt);
     if tt mod 3=1 then inc(t);
     str(t,le[i]);
   end;
 end;
Procedure work(u:longint; ss:string);
 var
   i:longint;
 begin
   b[u]:='';
   for i:=1 to length(ss) do b[u]:=b[u]+le[ss[i]];
 end;
Function try(l,r:longint):string;
 var
   w:string;
   i:longint;
 begin
   try:='';
   w:=copy(s,l,r-l+1);
   for i:=1 to n do if b[i]=w then begin try:=a[i]; break; end;
 end;
begin
  assign(input,inf); reset(input);
  assign(output,outf); rewrite(output);
    prepare;
    readln(n); readln(s); ls:=length(s);
    for i:=1 to n do begin
      readln(a[i]);
      work(i,a[i]);
    end;
    for i:=1 to ls do f[i]:=try(1,i);
    for i:=2 to ls do if f[i]='' then
     for j:=1 to i-1 do if f[j]<>'' then begin
       f[i]:=try(j+1,i);
       if f[i]<>'' then begin f[i]:=f[j]+' '+f[i]; break; end;
     end;
    if f[ls]<>'' then writeln(f[ls]) else writeln('No Solutions!');
  close(input); close(output);
end.

```

---

## 作者：KillerXu (赞：1)

再次被字符串迫害。

首先，我们可以先把单词转换成数字，不妨复制粘贴九个判断语句，这样既不用动脑子也防止不必要的出锅。

然后我们用map映射一下，把转换后的每个单词映射成为这个单词的下标，这样既方便之后的判断，也方便了最后输出给转化回来。

开始搜索，传三个参数，一个代表下标，一个代表着已经选中的、没有转换成一个单词的字母个数，一个代表已经有几个单词出现了。

如果已经搜完整个密码，且密码已经全部转化为单词即输出并结束。没有的话，我们就判断已经选中的字母能否组成一个单词。能，则记入答案数组，并重新计算被选中字母个数。

最后，不管能不能组成一个单词，我们都要去搜不组成单词的情况。

因为数据较小，不需要太多的技巧。

## Code

```cpp
#include <iostream>
#include <stdio.h>
#include <cstring>
#include <algorithm>
#include <map>

#define N 105

using namespace std;

int n , Len;
char key[N] , word[N][25];//key记录密码，word记录单词 
char Copy[N]; 
map < string , int > m;

void deal(int x){//将单词转化为数字 
	strcpy(Copy , word[x]);
	for(int i = 0; i < strlen(Copy); i++){
		if(word[x][i] >= 'a' && Copy[i] <= 'c') Copy[i] = '1';
		if(word[x][i] >= 'd' && Copy[i] <= 'f') Copy[i] = '2';
		if(word[x][i] >= 'g' && Copy[i] <= 'i') Copy[i] = '3';
		if(word[x][i] >= 'j' && Copy[i] <= 'l') Copy[i] = '4';
		if(word[x][i] >= 'm' && Copy[i] <= 'n') Copy[i] = '5';
		if(word[x][i] >= 'o' && Copy[i] <= 'q') Copy[i] = '6';
		if(word[x][i] >= 'r' && Copy[i] <= 't') Copy[i] = '7';
		if(word[x][i] >= 'u' && Copy[i] <= 'w') Copy[i] = '8';
		if(word[x][i] >= 'x' && Copy[i] <= 'z') Copy[i] = '9';
	}
	m[Copy] = x;//映射 
}

bool flag = false;//用来判断是否已经有了答案 

char ans[N][25];//记录答案 
char t[25];//辅助数组 
int h = -1;

void print(int tot){//打印答案 
	for(int i = 1; i <= tot; i++){
		printf("%s"  , word[m[ans[i]]]);//这里的输出好好想一想 
		if(i != tot) printf(" ");//spj对空格敏感 
	}
}

void dfs(int x , int L , int tot){
	if(x == Len + 1 && L == 1 && !flag){//满足结束的条件 
		flag = true;
		print(tot);
	}
	
	if(x == Len + 1) return;//不管满不满足输出的条件，搜完了就返回 
	
	memset(t,'\0',sizeof(t));//记得清空 
	h = -1;
	
	for(int i = x - L + 1; i <= x; i++) t[++h] = key[i];//把选中的字母复制给辅助数组 
	if(m[t]){//如果有这个单词 
		strcpy(ans[tot + 1] , t);//再复制给答案数组 
		dfs(x + 1 , 1 , tot + 1);
	}
	 
	dfs(x + 1 , L + 1 , tot);
	 
}

int main(){
	scanf("%d" , &n);
	scanf("%s" , key);
	Len = strlen(key) - 1;
	for(int i = 1; i <= n; i++){
		scanf("%s" , word[i]);
		deal(i);
	}
	
	dfs(0 , 1 , 0);
	
	if(!flag) printf("No Solutions!");
	
	return 0;
}
```

---

## 作者：zhenglier (赞：1)

## STL大法好

这题一看就是一个~~简单的~~dp，但因为这一堆字符串，马上就麻烦起来了，但我们可以用STL将程序变得很简洁。

```cpp 
	mp[0]=mp[1]=mp[2]=1;
	mp[3]=mp[4]=mp[5]=2;
	mp[6]=mp[7]=mp[8]=3;
	mp[9]=mp[10]=mp[11]=4;
	mp[12]=mp[13]=5;
	mp[14]=mp[15]=mp[16]=6;
	mp[17]=mp[18]=mp[19]=7;
	mp[20]=mp[21]=mp[22]=8;
	mp[23]=mp[24]=mp[25]=9;
```

先对映射关系打个表

```cpp
	cin>>s;
	m=s.size();
	for(int i=1;i<=n;++i){
		cin>>a;
		len[i]=a.size();
		b[i]=a;
		string::iterator c;
		for(c=a.begin();c!=a.end();++c){
			*c=mp[*c-'a']+'0';
		}
		string::size_type pos=0;
		while((pos=s.find(a,pos))!=string::npos){
			v.push_back(make_pair(pos,i));
			pos++;
		}
	}
```

直接用cin读入字符串，然后遍历字符串，将所有字母映射到数字，然后是这里面最方便的地方。

```cpp
		string::size_type pos=0;
		while((pos=s.find(a,pos))!=string::npos){
			v.push_back(make_pair(pos,i));
			pos++;
		}
```
直接用find函数遍历整个母串，将所有可行的覆盖用pair（格式为（起点，放入的串的编号））放入一个vector存起来(因为不知道数量)。
```cpp
    sort(v.begin(),v.end());
	dp[0]=1;
	memset(lst,-1,sizeof lst);
	for(it=v.begin();it!=v.end();++it){
		int x=it->first,y=x+len[it->second];
		dp[y]|=dp[x];
		if(dp[x])lst[y]=it->second,to[y]=x;
	}
```
然后直接sort一遍直接dp，dp时记录覆盖到这个点的字符串，方便方案输出。
```cpp
    if(dp[m]){
		int now=m;
		while(now>0){
			ot.push_back(b[lst[now]]);
			now=to[now];
		}
		while(ot.size()){
			cout<<ot.back();
			ot.pop_back();
			if(ot.size())putchar(' ');
		}
	}else{
		puts("No Solutions!");
	}
```
若覆盖到，则输出答案，因为字符串的顺序是倒着的，所以我选择放入vector再倒序输出。若没有覆盖到，输出无方案。

提醒一点，行末不能有空格，不然会20分。

---

## 作者：远山淡影 (赞：1)

# **这道题用到了递归和搜索**

# **为了方便解题，我将单词表里的所有单词转化数字** 
# **灰名[大佬](https://www.luogu.org/space/show?uid=118746)友链**
```
#include<cstdio>
#include<cstring>
using namespace std;
char a[130],dc[110][22];
//a字符串用于将字母转化为数字字符，dc用来存放转化后的单词 
char d[110][22],sz[110];
//d用来存放转化前的单词 ，sz为数字密码 
int aa[110],l[110];
//aa存放要输出的单词序号，l为单词长度 
int n;//单词个数 
bool bk=false;//是否能翻译，开始定义为不可翻译 
void dfs(int k,int t)//k表示找到了前面k个数字的密码了，t表示找到前k个密码要用t个单词 
{
	if(bk)return ;//如果已经可翻译，直接退出 
	if(k==strlen(sz+1)){bk=true;return ;}//如果翻译完成，将bk设为true，退出递归 
	for(int i=1;i<=n;i++)//循环，枚举各个单词 
	{
		if(bk)return ;//同上14行 
		if(strstr(sz+k+1,dc[i]+1)!=NULL)//如果在剩下的密码里，找到了第i个单词 
		{
			if(strlen(sz+1)-strlen(strstr(sz+k+1,dc[i]+1))==k)//如果这个单词前一个位置为k
/*strstr(st1,st2)是判断st2是不是st1的子串，若str2是str1的子串，
则返回str2在str1的首次出现的地址;如果str2不是str1的子串，则返回NULL。例如：
st1=abcdefg;st2=cde;则strstr(st1,st2)=cdefg*/ 
			{
				aa[t]=i;//记录是第几个单词 
				dfs(k+l[i],t+1);//循环，k加上这个单词的长度，t+1，不多说 
			}
		}
	}
}
int main()
{
	for(int i='a';i<='z';i++)
	{
		if(i<='n')a[i]=(i-'a')/3+1+'0';//之后便于将字母转化成数字字符 
		else a[i]=(i-'o')/3+6+'0';//考虑5只有2个字符的特殊情况 
	}
	scanf("%d",&n); 
	scanf("%s",sz+1);//输入，不多说
	for(int i=1;i<=n;i++)
	{
		scanf("%s",d[i]+1);//输入单词 
		l[i]=strlen(d[i]+1);//记录单词长度，等会递归要用 
		for(int j=1;j<=l[i];j++)dc[i][j]=a[d[i][j]];
		//将字母转化成数字字符，方便比较，存在dc里面 
	}
	dfs(0,1);//进行递归 
	if(bk)//bk=true表示找到可翻译 
	{
		int t=1;//定义一个t 
		while(aa[t+1]!=0)printf("%s ",d[aa[t++]]+1);//如果aa[t+1]！=0代表aa[t]下一个还有数 
		printf("%s",d[aa[t++]]+1);//这里要特殊处理，最后不能有空格 
	}
	else printf("No Solutions!");//不然输出  No Solutions!
	return 0;
}
```

---

## 作者：新手7889456 (赞：0)

# 题面

我被读题这件事卡了不短时间☹☹☹，想必一定有人是来题解区看题意的

大意就是：对于一串数字，找到合适的断句方式，使得所有数字都用上，并且每一个单词都是输入给出的单词。字母的对应方式也就是题中所给的~~老年机上面的按键的~~对应方式

样例的解释：

```
8

73373711664

thi == 733
shs == 737
this == 7337
is == 73
b == 1
a == 1
boo == 166
k == 4
```

# 注意

这道题要求输出末尾没有多余空格，想必大家都是这个问题

要是没有这回事的话，估计就都过了

# 正文

就想必是直接搜索

然后有两个算剪枝，也不算剪枝的东西：

● 搜到结果之后直接退出

● 如果剩余的数字长度没有这个字符串的长度长的话就直接跳过

具体的话就看代码吧：

```
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
using namespace std;

int n,len;
char shu[101],key_bo[101][21];
int key[27] = {1,1,1,2,2,2,3,3,3,4,4,4,5,5,6,6,6,7,7,7,8,8,8,9,9,9};
int st[101],top;

void dfs(int left){
	if(left == len){//没有剩余的数字了
		for(register int i(1);i<top;++i) {
			printf("%s ",key_bo[st[i]]);
		}
		printf("%s",key_bo[st[top]]);//坑人的地方
		exit(0);
	}
	for(register int i(1);i<=n;++i) {
		if(len - left + 1< strlen(key_bo[i])) continue;//剪枝
		bool ok(0);
		for(register int j(0);j<strlen(key_bo[i]);++j){
			if(shu[j+left]-'0' != key[key_bo[i][j]-'a']) {
				ok = 1;//没法匹配
				break;
			}
		}
		if(ok) continue;
		st[++top] = i;
		dfs(left + strlen(key_bo[i]));
		--top;//回溯
	}
}

int main()
{
	scanf("%d",&n);
	scanf("%s",shu);
	len = strlen(shu);
	for(register int i(1);i<=n;++i){
		scanf("%s",key_bo[i]);
	}
	dfs(0);
	printf("No Solutions!");//无解
	return 0;
}
```


---


# 魔板

## 题目描述

有这样一种魔板：它是一个长方形的面板，被划分成 $n$ 行 $m$ 列的 $n \times m$ 个方格。每个方格内有一个小灯泡，灯泡的状态有两种（亮或暗）。我们可以通过若干操作使魔板从一个状态改变为另一个状态。操作的方式有两种：

1. 任选一行，改变该行中所有灯泡的状态，即亮的变暗、暗的变亮；
2. 任选两列，交换其位置。

当然并不是任意的两种状态都可以通过若干操作来实现互相转化的。

你的任务就是根据给定两个魔板状态，判断两个状态能否互相转化。


## 样例 #1

### 输入

```
2
3 4
0 1 0 1
1 0 0 1
0 0 0 0
0 1 0 1
1 1 0 0
0 0 0 0
2 2
0 0
0 1
1 1
1 1```

### 输出

```
YES
NO
```

# 题解

## 作者：Ellen7ions (赞：50)

### 大佬们的题解真是简洁，然而我这种蒟蒻并没有看懂，然后自己手玩一下~~好像挺简单~~？

-----------------------------------------华丽分割线--------------------------------------

你在手玩的时候可以看见几个性质：

①：每一行最多翻转一次，多于一次其实没有意义。

②：每一列的交换只不过改变了每一列的元素的位置。假设这个魔板只又一种操作，即令某几列交换，那么我们总可以找到一种排列顺序，使得它和目标魔板相同。

所以，我们可以只关心原魔板某一列和目标魔板的任意一列匹配就可以了，我们通过转换操作，使得这一列和目标魔板的随便一列（大家好像都选的第一列），匹配的同时，让其他列也跟着转换，最后判断一下目标魔板，除了第一列以外的所有，是否和当前魔板一样就可以了。

具体见代码。
```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#define mem(a, i) memset(a, i, sizeof(a))
#define rep(i, a, b) for(int i = a; i <= b ; i++)
const int maxn = 128;
using namespace std;
int n, m, k, f;
int map[maxn][maxn], tar[maxn][maxn], temp[maxn][maxn];
//转换 i 行操作。 
void converse(int i) { rep(j, 1, m)	map[i][j] = !map[i][j]; }
// 判断目标魔板除了第一列以外时候都和当前魔板匹配。 
bool Check(int choose) {
	bool vis[maxn];
	mem(vis, 0);
	rep(jt, 2, m) {
		rep(jp, 1, m) {
			if(jp == choose)	continue;
			bool pd = 0;
			rep(i, 1, n)
				if(map[i][jp] != tar[i][jt]) {
					pd = 1;
					break;
				}
			if(!pd && !vis[jt])	{
				vis[jt] = 1;
				break;
			}		
		}
	}
	rep(i, 2, m)	if(!vis[i])	return false;
	return true;
}
//将原魔板的 cur 列， 强制和目标魔板的第 1 列 匹配。
//伴随着，也把原魔板的其他列也翻转。 
void Search(int cur) {
	rep(i, 1, n)
		if(map[i][cur] != tar[i][1]) //不同就翻转 
			converse(i);
	return ;
}
//复原 
void Getback() {
	rep(i, 1, n)
		rep(j, 1, m)
			map[i][j] = temp[i][j];
	return ;
}
int main() {
	scanf("%d", &k);
	rep(p, 1 ,k) {
		mem(map, 0);
		mem(tar, 0);
		mem(temp, 0);
		f = 0;
		scanf("%d %d", &n, &m);
		//读入原魔板 
		rep(i, 1, n)
			rep(j, 1, m)
				scanf("%d", &map[i][j]),
				temp[i][j] = map[i][j];
		//读入目标魔板 
		rep(i, 1, n)
			rep(j, 1, m)
				scanf("%d", &tar[i][j]);
		//枚举原魔板的 i 列，使其和目标魔板匹配。 
		rep(i, 1, m) {
			Search(i); 
			if(Check(i)) {
				f = 1;
				printf("YES\n");
				break;
			}
			Getback();	//记得复原 
		}
		if(!f)	printf("NO\n");
	}
	return 0;
}
```

---

## 作者：寒鸽儿 (赞：11)


### 补补缀缀，弄了一天才完成这道题。 32ms 
###	首先想到的突破口是：交换列的移动并不会改变某一行的1的数量之和(0也一样),改变行可以交换0和1的数量。因此可以先统计0和1的数量，如果对应行上的1的数量两块板不同且和不等于行的长度，那么必定无法互相转化。
###	接下来考虑，如果两种状态的0和1的个数符合上述条件，对于任意一行，我改变A魔板统一到B魔板(如果A+B的1的个数等于行长)和改变B魔板统一到A魔板或者改变A、B(如果A、B状态相等) 统一到另一种状态，是否会对结果产生影响呢？ 
###	结论是不会的。这样子想，假设我已经操作得到了相同的板，那么我对该行进行一次操作，得到的就是在另一种状态下的统一。因此，对于1的总数等于行长之和的魔板，任意改变一者，就完成了所有的行操作。
###	接下来，我们匹配列，如果任意的列可以两两配对，那么就成功，否则失败(对于行的操作已经完成)。
###	以上都是基于贪心，可以很暴力地做出来。 
###	但是这样做会有三个点WA，对于1的个数相等，且等于二分之一行长的模板，我们不能确定用哪一种形式，在这里，改变状态会影响能否到达最终结果。
###	因而对这几行，我们需要枚举两种状态。对于普通的行，直接确定下来即可。
###	然而暴力枚举会超时，因而需要在半路上判断剪枝，即在二分之一行长的行分出两类状态时对先前的行进行匹配。
###	由于我的代码刚开时没有考虑等于二分之一行长的情况，所以是修改而成的，代码很丑，还有可以合并、改进的地方。 

```cpp
#include <cstdio>
#include <cstring>

using namespace std;

const int size = 105;
int bd1[size][size], bd2[size][size], n1[size], n2[size], nx, ny;

void turn(int i) {
    for(int j = 1; j <= ny; j++)
        bd1[i][j] ^= 1;
}

bool same(int i, int j) {
    bool flag = true;
    for(int k = 1; k <= nx; k++)
        if(bd1[k][i] != bd2[k][j]) {
            flag = false;
            break;
        }
    return flag;
}

bool match() {
    int match[size];
    memset(match, 0, sizeof(match));
    for(int i = 1; i <= ny; i++) {
        bool fl = false;
        for(int j = 1; j <= ny; j++) {
            if(!match[j] && same(i, j)) {
                match[j] = i;
                fl = true;
                break;
            }
        }
        if(!fl) return false;
    }
    return true;
}

bool sm(int i, int j, int cur) {
    bool flag = true;
    for(int k = 1; k <= cur; k++)
        if(bd1[k][i] != bd2[k][j]) {
            flag = false;
            break;
        }
    return flag;
}

bool check(int cur) {
    int match[size];
    memset(match, 0, sizeof(match));
    for(int i = 1; i <= ny; i++) {
        bool fl = false;
        for(int j = 1; j <= ny; j++) {
            if(!match[j] && sm(i, j, cur)) {
                match[j] = i;
                fl = true;
                break;
            }
        }
        if(!fl) return false;
    }
    return true;
}

bool flg;
void dfs(int cur) {
    if(flg == true) return;
    if(cur == nx+1) {
        flg = match();
        return;	
    }
    dfs(cur+1);
    if(n1[cur] == ny / 2) {
        turn(cur);
        if(check(cur))
        	dfs(cur+1);
    }
}

int main() {
    int t;
    scanf("%d", &t);
    while(t--) {
        scanf("%d %d", &nx, &ny);
        memset(n1, 0, sizeof(n1));
        memset(n2, 0, sizeof(n2));
        for(int i = 1; i <= nx; i++)
            for(int j = 1; j <= ny; j++) {
                scanf("%d", &bd1[i][j]);
                n1[i] += bd1[i][j];
            }
        for(int i = 1; i <= nx; i++)
            for(int j = 1; j <= ny; j++) {
                scanf("%d", &bd2[i][j]);
                n2[i] += bd2[i][j];
            }
        bool flag = true;
        for(int i = 1; i <= nx; i++)
            if(n1[i] + n2[i] == ny)
                turn(i);
            else if(n1[i] != n2[i]) {
                flag = false;
                break;
            }
        if(!flag) {
            printf("NO\n");
        } else if(match()){
            printf("YES\n");
        } else if(!(ny % 2)){
            flg = false;
            dfs(1);
            if(flg) printf("YES\n");
            else printf("NO\n");
        } else {
            printf("NO\n");
        }
    }
    return 0;
}
```cpp

---

## 作者：litble (赞：11)

总的思想是枚举现在状态中的每一行作为第一行，在根据此行确定要不要对横排进行操作，操作后再确定竖行交换位置后能否达到目标状态。

```cpp
#include<iostream>
#include<cstdio>
#include<iomanip>
#include<climits>
#include<algorithm>
#include<cstring>
using namespace std;
int n,m,k;
int mb[101][101],now[101][101];
bool lm[101],yp[101];
int search(int fir){
  int i,j,t,bj=0;
  for(i=1;i<=n;i++){//如果和第一行不一样，则改变
    if(now[i][fir]!=mb[i][1])lm[i]=1;//lm:记录横行是否发生改变
    else lm[i]=0;
    }
  yp[fir]=1;//第一行已经和fir配对
  //if(fir==5)for(i=1;i<=n;i++)cout<<lm[i]<<endl;
  for(i=2;i<=m;i++){//枚举目标状态
    bj=0;
    for(j=1;j<=m;j++){//枚举当前状态
      if(yp[j]==0)//如果当前行没有被占用
        for(t=1;t<=n;t++){
           if((lm[t]==1&&now[t][j]!=mb[t][i])||(lm[t]==0&&now[t][j]==mb[t][i]))
            { 
            if(t==n){bj=1;yp[j]=1;}}
           else {break;}
         }
      if(bj==1)break;
      if(j==m)return 0;
    }
  }
  return 1;
}
int main()
{
  freopen("lx.in","r",stdin);
  freopen("lx.out","w",stdout);
  int i,j,t,na;
  scanf("%d",&k);
  for(t=1;t<=k;t++){
    scanf("%d%d",&n,&m);
    for(i=1;i<=n;i++)
      for(j=1;j<=m;j++)scanf("%d",&now[i][j]);
    for(i=1;i<=n;i++)
      for(j=1;j<=m;j++)scanf("%d",&mb[i][j]);
    for(i=1;i<=m;i++){
         memset(yp,0,sizeof(yp));
         na=search(i);
        if(na==1){printf("YES\n");break;}
        if(na==0&&i==m){printf("NO\n");break;}
        }
  }
  return 0;
}
```

---

## 作者：Prev1ous (赞：10)

#### 其实这道题有一个特别关键的思路。

# 拿着你要确定的魔板中的列去枚举要匹配的魔板的每一列。

#### 因为列是可以交换的。

#### 而且还有最关键的一个点。

# 如果你确定了其中有一列对应了，那么你的魔板其实就已经固定了。行就不能变换了。

#### 上边这个关键点的确不好想，但是想通了这个题也就好解决了。

### 然后就可以用map进行对应开始查询。

### 如果手里的魔板的数和要确定了一一对应了就YES了。

### 然后你手里的魔板和需要对应的魔板对应成功就可以输出YES了。

### 要记着在每次枚举的时候clear一次。

## 具体看下面代码。
```
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<cctype>
#include<map> 
#define rg register
#define int long long 
using namespace std;
inline int read(){
	rg int s=0,f=0;
	rg char ch=getchar();
	while(!isdigit(ch)) f|=(ch=='-'),ch=getchar();
	while(isdigit(ch)) s=(s<<1)+(s<<3)+(ch^48),ch=getchar();
	return f?-s:s;
}
int n,m,k;
const int MAX=115;
int a1[MAX][MAX],a2[MAX][MAX],vis[MAX];
string S;
map<string,int>hsh;
void init(){
	n=read(),m=read();
	for(rg int i=1;i<=n;++i){
		for(rg int j=1;j<=m;++j){
			a1[i][j]=read();
		}
	}
	for(rg int i=1;i<=n;++i){
		for(rg int j=1;j<=m;++j){
			a2[i][j]=read();
		}
	}
}
signed main(){
	k=read();
	++k;
	while(--k){
		bool flag=0;
		init();//初始化。
		for(rg int i=1;i<=m;++i){
			hsh.clear();//每次都要清空。
			for(rg int j=1;j<=n;++j){
				vis[j]=(a1[j][1]==a2[j][i])?0:1;
			}//枚举是否能够对应。
			for(rg int j=1;j<=n;++j){
				for(rg int k=1;k<=m;++k){
					a1[j][k]^=vis[j];
				}
			}//对应就可以^1（代表翻转过了）。
			for(rg int j=1;j<=m;++j){
				string s=S;
				for(rg int k=1;k<=n;++k){
					s+=(char)(a1[k][j]+'0');
				}
				++hsh[s];
			}//转换成字符串。
			for(rg int j=1;j<=n;++j){
				for(rg int k=1;k<=m;++k){
					a1[j][k]^=vis[j];
				}
			}//还原
			for(rg int j=1;j<=m;++j){
				string s=S;
				for(rg int k=1;k<=n;++k){
					s+=(char)(a2[k][j]+'0');
				}
				if(!hsh[s]) break;//这里没被改过就跳过。
				--hsh[s];
				if(j==m) flag=1;
			}
		}
		if(flag) printf("YES\n");
		else printf("NO\n");
	}
	return 0;
}
```
## 完美。

---

## 作者：leylee (赞：5)

## 写在前面
这题不算太难, 看看任意一篇题解都能看懂的. 我的做法比较毒瘤, 主要是~~闲的没事~~为了提供另外一种实现方法而写下这篇使用~~假~~位运算优化~~还越优化越慢~~的题解. 代码奇长, 常数巨大, STL极慢, 对于这道题~~如此水~~的数据来说意义不大, 还几乎降低不了复杂度. 觉得我的代码不堪入目的话(怎么会呢)请移步其他dalao的题解.

## 思路
### 基本思路
由于题中要求行可以翻转, 列可以交换, 不符平时的习惯, 所以可以对棋盘进行转置, 即把`board[i][j]`存成`board[j][i]`, 方便下一步操作. 以下所说的行列都是指转置后的行列.

正如其他几篇题解所说的, 看看这题的数据范围就像是暴力枚举. 因为不能直接枚举要翻转哪些列(复杂度$O(2^n)$直接爆炸), 所以就要缩小枚举范围. 由于末状态每一行都需要对应一行初状态翻转后的结果, 因此, 只需让每一行作为末状态第一行翻转前的样子就可以了, 得到$n$种翻转方式. 对于每一种翻转方式, 只需再判断初态翻转后能否与末态每一行都有对应关系就行了. 

#### 复杂度分析
```
k个数据点 (k)
	读入 (nm)
    枚举翻转方案 (n)
    	翻转 (nm)
    	检验 (m^2)
```
总复杂度为$O(knm(n+m))$. 显然已经很不错了, 完全可以A掉

### 乱搞(假)优化
回过头来再看这道题, 板子上每一个灯泡只有开和关两种状态, 而且每一行的灯泡个数也很少, 是不是想到了~~状压dp~~位运算优化呢? 对于翻转操作而言, 求反~运算可以很好的解决问题(然鹅用不到); 要求初末态到底翻转了哪些列, 异或^运算可以快速求解; 已知翻转的列, 求翻转后的状态同样是用异或. 示例如下:
```
a, e = 初态某行, b = 末态某行, c = 翻转了哪些列, d = 初态翻转后的某行

a         = 0 1 0 1
b         = 1 1 0 0
c = a ^ b = 1 0 0 1
e         = 0 0 1 0
d = e ^ c = 1 0 1 1
```

于是就可以把每一行用二进制表示, 那么问题又来了: 数据范围到了~~巨大的~~$100$, `unsigned long long`的64位已经不够用了, 迫不得已只能求助STL的... $\color{red}bitset!!!$
轻松处理100位的位运算无压力(然鹅还是很慢鸭). So, 基于以上, 代码就要出来了...

别急, 先来看看复杂度.

#### 复杂度分析
```
k个数据点 (k)
	读入 (nm)
    枚举翻转方案 (n)
    	翻转 (m)  假装bitmap是O(1)
    	检验 (m^2)
```
总复杂度为$O(knm^2)$. ~~并没有降低~~

## 大括号换行, 下标从零开始的代码
#### 优化神器: 吸氧
#### 还是有一些技巧值得注意, 比如数据读入部分
```cpp
// luogu-judger-enable-o2
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <bitset>

using namespace std;

int k, n, m;
char buf[105][105];
bitset<101> book;

int main(void)
{
    cin >> k;

    while (k--)
    {
        bool okay = false;

        cin >> n >> m;
        bitset<101> colume[101], tarcolume[101];   // STL大法好
        bitset<101> mask;   // 设置掩码, 方便接下来进行对列是否可选的判断
        for (int i = 0; i < n; i++)
            mask.set(i);

        // 读入初始棋盘
        for (int i = 0; i < n; i++)
            for (int j = 0; j < m; j++)
                // 转置棋盘, 便于接下来的操作
                scanf(" %c", &buf[j][i]);   // scanf格式字符串前加空格, 强制扫描前导空白
        // 将字符数组转化为bitmap类型
        for (int i = 0; i < m; i++)
            for (int j = 0; j < n; j++)
                if (buf[i][j] == '0')
                    colume[i].reset(j);
                else
                    colume[i].set(j);
        // 读入目标棋盘
        for (int i = 0; i < n; i++)
            for (int j = 0; j < m; j++)
                scanf(" %c", &buf[j][i]);
        for (int i = 0; i < m; i++)
            for (int j = 0; j < n; j++)
                if (buf[i][j] == '0')
                    tarcolume[i].reset(j);
                else
                    tarcolume[i].set(j);

        for (int x = 0; x < m; x++)
        {
            // 对于每一行, 都试试它能不能做第0行
                // 这里说的行, 是按照转置后的棋盘说的, 共有m行
            book.reset();
            bitset<101> flip = colume[x] ^ tarcolume[0];    // 求出哪些列被翻转了

            for (int i = 0; i < m; i++)
                // 翻转初态的每一列, 一会还要记得翻转回去
                colume[i] ^= flip;

            // 准备工作做好了, 接下来只需判断初始行与目标行之间可否一一对应就行了
            bool matched;
            for (int i = 0; i < m; i++)
            {
                matched = false;
                for (int j = 0; j < m; j++)
                    if (book[j])
                        continue;
                    else
                        if ((colume[i] & mask) == (tarcolume[j] & mask))    // & mask来忽略无有效数据的那几位
                        {
                            book.set(j);
                            matched = true;
                            break;
                        }
                if (matched == false)
                    goto bad_attempt;
            }
            okay = true;
            bad_attempt:

            for (int i = 0; i < m; i++)
                colume[i] ^= flip;

            if (okay)
                break;
        }

        if (okay)
            cout << "YES" << endl;
        else
            cout << "NO" << endl;
    }

    return 0;
}
```

## Before the End
代码的辣个`goto`还请dalao不要喷, 检验部分其实可以优化成直接判断两列差异是否为要翻转的列, 可以省去预先的翻转和之后的还原. 其他有误的地方和不足还请大家指出.

---

## 作者：0逝者如斯夫0 (赞：4)

这道题本质上是搜索

第一步:在最外层循环枚举初始的每一列当做目标状态的第一列

第二步:在每层循环中比较当前这列和目标状态的第一列的同行的数，如果不相同则把初始的那一行翻转（前面先记录，后面记得还原）

第三步:看看剩下的列是否可以一一对应，如果可以就yes，不可以就继续枚举。

（还有一个优化，就是在最开始记录初始状态每一行一的个数，然后输入目标状态时看看同一行初始中一的个数是否与目标那行的一个数或零个数相同，因为同意行只可以翻转，个数是固定的，如果1或翻转0后的1对不上，根本无法实现所以直接就no了）


---

## 作者：Water_Cows (赞：3)

- $\texttt{P1275}$ 比较有意思的模拟（考试）题。/kk

### 题解

枚举每一列，与第1列交换。

之后和目标魔板比对，如果第一列上的数字不同，那么那一行改变（每一行最多改变一次，因为改变两次和没改变是一样的）

```cpp
inline void change_line(int j)
{
    for(int i=1; i<=m; i++) a[j][i] ^= 1; 
}

```

之后对已经被变换过的矩阵，枚举第 2~m 列与目标矩阵的 2~m 列分别比较。如果一样，就交换。

### Code

```cpp
#include <cstdio>
#include <cstring>
using namespace std;

const int N = 100 + 7;

int t, n, m;
int a[N][N], b[N][N], c[N][N], f[N];

inline void inp()
{
    for(int i=1; i<=n; i++)
        for(int j=1; j<=m; j++)
            scanf("%d", &c[i][j]);
    
    for(int i=1; i<=n; i++)
        for(int j=1; j<=m; j++)
            scanf("%d", &b[i][j]);
}

inline void swap(int &x, int &y)
{
    int t = x;
    x = y;
    y = t;
}

inline void change(int f, int l)
{
    for(int i=1; i<=n; i++) swap(a[i][f], a[i][l]);
}

inline void change_line(int j)
{
    for(int i=1; i<=m; i++) a[j][i] ^= 1; 
}

inline void copy()
{
    for(int i=1; i<=n; i++)
        for(int j=1; j<=m; j++)
            a[i][j] = c[i][j];
}

inline int doit(int x, int y)
{
    for(int i=1; i<=n; i++)
    {
        if(b[i][x] != a[i][y]) return 0;
    }
    return 1;
}

inline void P()
{
    for(int i=1; i<=n; i++)
    {
        for(int j=1; j<=m; j++)
            printf("%d ", a[i][j]);
        puts("");
    }
    puts("");
}

int main()
{
    freopen("panel.in", "r", stdin);
    freopen("panel.out", "w", stdout);

    scanf("%d", &t);
    while(t--)
    {
        scanf("%d%d", &n, &m);
        inp(); // 读入
        int ttt = 0;
        for(int i=1; i<=m; i++) // 枚举每一个可以和第一个交换的
        {    
            copy();
            memset(f, 0, sizeof(f));
            change(1, i); // 交换
            for(int j=1; j<=n; j++)
            {
                if(a[j][1] != b[j][1]) change_line(j); // 换到与目标一样
            }
            //P();
            //if(n == 4 && m == 3) printf("%d\n", doit(2, 3));
            int eee = 1;
            for(int j=2; j<=m; j++) // 枚举要交换的第几个
            {
                int mmm = 0;
                for(int t=2; t<=m; t++) // 寻找可以与他交换的
                {
                    int flag = doit(j, t);
                    //ttt++;
                    if(flag && !f[j]) change(j, t), f[j] = 1, mmm = 1;
                }
                if(mmm == 0) {eee = 0; break;}
                //if(!ttt) {puts("NO"); eee = 1; break;}
            }
            if(eee) {puts("YES"); ttt = 1; break;}
        }
        if(!ttt) {puts("NO");}
    }
    return 0;
}

```

第一次WA在了第一个，原因是 `doit` 函数 `a`, `b` 数组写反了，呜呜呜。

$in$:
```
3
4 3
0 0 1 
0 0 0 
1 1 0 
1 1 1 
1 1 0 
1 1 1 
0 1 1 
1 1 1 
10 10
1 1 0 1 1 0 0 1 0 0 
1 1 1 1 0 1 0 0 0 1 
0 0 1 1 1 1 0 1 1 0 
1 0 0 1 1 0 1 0 1 1 
1 1 0 1 1 1 1 1 0 1 
0 0 0 0 0 0 0 0 1 0 
0 1 1 0 1 1 1 0 1 1 
1 1 1 1 0 1 1 0 0 0 
1 1 0 1 0 1 1 1 0 0 
0 0 1 0 0 1 0 0 1 0 
1 0 0 0 0 1 0 1 1 1 
0 0 1 0 1 0 0 1 0 1 
0 1 1 1 0 1 0 1 0 1 
0 0 1 0 1 1 1 1 1 0 
1 1 0 0 1 1 1 1 1 1 
1 1 0 1 1 1 1 1 1 1 
1 1 1 1 1 0 1 1 0 0 
0 0 1 0 0 0 1 1 0 1 
1 1 0 0 1 1 0 0 1 1 
0 1 1 1 0 0 0 0 0 0 
7 8
0 1 1 1 1 1 0 1 
1 1 1 1 0 0 1 0 
1 1 1 0 1 1 1 1 
1 1 1 1 1 1 1 1 
0 1 0 0 1 0 1 1 
1 1 0 1 1 1 1 1 
1 0 1 0 1 1 1 1 
0 0 0 0 0 0 1 1 
1 0 1 0 0 1 0 0 
0 0 0 1 0 0 0 0 
1 1 1 1 1 1 1 1 
0 1 1 0 0 1 0 1 
1 1 1 1 0 1 1 1 
1 0 1 0 1 1 1 1 

```

$out$:
```
NO
YES
YES
```

---

## 作者：enucai (赞：2)

[这道题](https://www.luogu.com.cn/problem/P1275)的思路总体比较明确。 

-----------------

### 思路

-----------

首先，介绍一个 `change​` 函数。

这道题目中的操作2表述为：

- 任选两列，交换其位置。

所以，我们可以先写一个函数用于完成这一个操作。

假设要交换 $x$ ， $y$ 两列，那么只需要一个简单的循环即可实现，上代码：

```cpp
void change(int x,int y){
    for(int i=1;i<=n;i++){
        swap(a[i][x],a[i][y]);
    }
}
```

当然，在我自己的代码中，直接把这几段内嵌主函数了，但其实用了两次，写个函数会更简洁。

-------------

接着，就是一个 `check​` 函数，用于比较交换后的 $x$ 列与目标的 $y$ 列的元素是否匹配。不加赘述，直接上代码：

```cpp
bool check(int x,int y){
	for(int i=1;i<=n;i++){
		if(a[i][x]!=b[i][y]){
			return false;
		}
	}
	return true;
}
```

-------------

至于第一项操作：

- 任选一行，改变该行中所有灯泡的状态，即亮的变暗、暗的变亮。

我们分析可以知道，对于每一行来说，最多只会进行一次这种操作。如果超过一次，进行了 $n$ 次这一种操作，就相当于进行了 $n\%2$ 次操作，是没有意义的。

因此，我们就没有必要再写一个函数来完成这个任务了，代码很短，直接内嵌即可。

-----------

总体来说，我们首先需要第一列与每一列交换的情况。

然后将变换后的魔板与目标的魔板进行对比，只要对比第一列的元素，如果不同，那么就将这一行全部进行第一项操作。

最后，对变换后的魔板，枚举第 $2$~$m$ 列与目标矩阵的 $2$~$m$ 列进行比较。如果是一样的话，就说明这一种交换方式是可行的。

-----------------

### 代码

总体来讲，这一道题的思路比较~~简单~~，容易理解。具体的实现看代码：

![](https://cdn.luogu.com.cn/upload/image_hosting/fsyjmao5.png)

---

## 作者：Li_Yichen (赞：1)

## 剪枝和实现步骤
实际上实现起来就两步：
1. 每一行只能变换一次。
2. 只要在变换中有一列和目标魔板中的某一列（这里是选择的第一列）相匹配，现在的魔板就不能再变换了，此时只要判断现在魔板的每一列在目标魔板中有没有一一对应的，如果全部匹配上了，说明可以变到，节省了直接变换列的时间。

注意事项：每一次变换要枚举变换的列 $(1-m)$，如果不一样就变换这一行，如果枚举的这一列变换后无法转换到目标魔板，记得要返回最开始的样子。


------------
## 需要实现的函数
1. copy 函数，用来把最开始的魔板状态保存到 temp 数组里。
```cpp
void copy(){//保存当前的状态 
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			temp[i][j] = a[i][j];
		}
	}
}
```
2. back 函数，用来把最开始的魔板状态从 temp 数组里取出来。
```cpp
void back(){//回溯到一开始的状态 
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			a[i][j] = temp[i][j];
		}
	}
}
```
3. turn 函数，用来把第 $i$ 行全部变换，0 $\to$ 1，1 $\to$ 0。
```cpp
void turn(int i){//把行变换
	for(int j=1;j<=m;j++){
		a[i][j] = !a[i][j];
	} 
}
```
4. change 函数，把第 $j$ 列变成和目标魔板第一列一样的，如果第 $i$ 行不一样，则用 turn 函数变换第 $i$ 行，只需变换即可，不需要考虑其他列。
```cpp
void change(int j){//把第j列变到和魔板的第一列相同 
	for(int i=1;i<=n;i++){
		if(a[i][j] != b[i][1]) turn(i);
	}
} 
```
5. check 函数，检查出了选择的这一行以外，其余的能不能都找到在目标魔板里一一匹配的。
```cpp
bool check(int now){//当前选择匹配目标魔板第一列的为now列 
	memset(vis,0,sizeof(vis));
	for(int i=2;i<=m;i++){//枚举目标的每一列 
		for(int j=1;j<=m;j++){//枚举当前的每一列 
			int flag = 0;
			if(j == now) continue;//如果为第now列,说明匹配魔板的第一列,直接跳过
			for(int k=1;k<=n;k++){//枚举这两列的每一行是否相同 
				if(a[k][j] != b[k][i]){
					flag = 1; //一旦不相等 
					break;//直接退出 
				}
			} 
			if(!flag&&!vis[i]){//如果这一列每一行都相同并且魔板的这一列没有其他列占用 
				vis[i] = 1;//占用这一列,说明这一列完全匹配 
			}
		} 
	}
	for(int i=2;i<=m;i++){//枚举目标的每一列 
		if(!vis[i]) return 0;//一旦这一列不是完全相同,返回0 
	}
	return 1;//如果运行完成后还没返回0,说明都匹配上了,返回1 
}
```

------------
## 完整代码




```cpp
#include<bits/stdc++.h>
using namespace std;
int a[105][105],b[105][105];//现在的魔板和目标的
int temp[105][105];
int vis[105];
int k;
int n,m;
int flag = 0;
void copy(){//保存当前的状态 
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			temp[i][j] = a[i][j];
		}
	}
}
void back(){//回溯到一开始的状态 
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			a[i][j] = temp[i][j];
		}
	}
}
void turn(int i){//把行变换
	for(int j=1;j<=m;j++){
		a[i][j] = !a[i][j];
	} 
}
void change(int j){//把第j列变到和魔板的第一列相同 
	for(int i=1;i<=n;i++){
		if(a[i][j] != b[i][1]) turn(i);
	}
} 
bool check(int now){//当前选择匹配目标魔板第一列的为now列 
	memset(vis,0,sizeof(vis));
	for(int i=2;i<=m;i++){//枚举目标的每一列 
		for(int j=1;j<=m;j++){//枚举当前的每一列 
			int flag = 0;
			if(j == now) continue;//如果为第now列,说明匹配魔板的第一列,直接跳过
			for(int k=1;k<=n;k++){//枚举这两列的每一行是否相同 
				if(a[k][j] != b[k][i]){
					flag = 1; //一旦不相等 
					break;//直接退出 
				}
			} 
			if(!flag&&!vis[i]){//如果这一列每一行都相同并且魔板的这一列没有其他列占用 
				vis[i] = 1;//占用这一列,说明这一列完全匹配 
			}
		} 
	}
	for(int i=2;i<=m;i++){//枚举目标的每一列 
		if(!vis[i]) return 0;//一旦这一列不是完全相同,返回0 
	}
	return 1;//如果运行完成后还没返回0,说明都匹配上了,返回1 
}
int main(){
	cin >> k;
	while(k--){
		//初始化 
		flag = 0;
		cin >> n >> m;
		//输入现在的 
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				cin >> a[i][j];
			}
		}
		//输入目标的 
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				cin >> b[i][j];
			}
		}
		copy();//记录一下,用于back() 
		for(int i=1;i<=m;i++){//枚举变换哪一列使这一列转换为目标魔板的第一列 
			change(i);//把第i列换成和目标魔板一样的,不一样就变换这一行 
			if(check(i)){//每一列都有匹配的 
				flag = 1;//标记 
			}
			back();//每一次变换没成功要回溯到最开始的样子 
		}
		if(!flag) cout << "NO" << endl;//如果到最后都没有匹配上,输出NO 
        else cout << "YES" << endl;//匹配上了,输出YES 
	}
	return 0;
} 
```

---

## 作者：大成拳 (赞：1)

两列交换，可以变为原模板变化后的模板的一列和目标模板的一列一一对应。这样只增加我们判断的难度，减少搜索的复杂度。
行变化，只有两种状态，因此我们可以只考虑选或不选。因为列是一一对应的，所以我们只对一列搜索，将原模板的一列，匹配目标模板的每一列。
```
#include<iostream>
#include<cstring>
using namespace std;
const int N = 110;
int map[N][N],tarmap[N][N],n,m; 
bool is[N];
void change(int map[]){
	for(int i = 1;i<=m;i++){
		map[i]^=1;
	}
}
bool check(int map[][N],int tarmap[][N],int j,int k){
	for(int i = 1;i<=n;i++){
		if(map[i][j]!=tarmap[i][k]) return false;
	}
	return true;
}
void p(){
	for(int i = 1;i<=n;i++){
		for(int j = 1;j<=m;j++){
			cout<<map[i][j]<<" ";
		}
		cout<<endl;
	}
	cout<<endl;
}
bool dfs(){
	for(int i = 1;i<=m;i++){//原模板第一列匹配目标模板第i列
		for(int j = 1;j<=n;j++){
			if(map[j][1]!=tarmap[j][i]) change(map[j]);
		}
		for(int j = 1;j<=m;j++){//判断任意两列是否匹配。 
			bool flag = 0;
			for(int k = 1;k<=m;k++){
				if(is[k]==false){
					flag = check(map,tarmap,j,k);
					if(flag==1){
						is[k] = true;
						break;
					}
				}
			}
			if(flag == 0){//匹配失败 
				memset(is,0,sizeof is);
				break;
			}
			if(j==m){
				memset(is,0,sizeof is);
				return true; 
			} 
		}
	}
	return false;
}
int main(){
	int t;
	cin>>t;
	while(t--){
		cin>>n>>m;
		for(int i = 1;i<=n;i++){
			for(int j = 1;j<=m;j++){
				cin>>map[i][j];
			}
		}
		for(int i = 1;i<=n;i++){
			for(int j = 1;j<=m;j++){
				cin>>tarmap[i][j];
			}
		}
		if(dfs())cout<<"YES"<<endl;
		else cout<<"NO"<<endl; 
		
	}
}

```


---

## 作者：Self_Killer (赞：0)

唉，做这道题目的过程可真是一波三折，还好我做对了。

不难发现，每一行只可能被反转一次。于是，这道题就变成了一道简单的列的匹配问题。

我们有一个变量 $q$，把它和任意一列匹配（为了方便，这里取 $1$），就可以得到每一行的翻转情况。

然后再把剩下的相同的两两对应即可。

单次查询时间复杂度 $O(n \times m^3)。$

代码如下：

```
#include<bits/stdc++.h>
using namespace std;
int t,n,m;int a[110][110],b[110][110],d[110][110];bool vst[110];
int main(){
	cin >> t;
	for(int p = 1;p <= t;p++){
		cin >> n >> m;
		for(int i = 1;i <= n;i++){
			for(int j = 1;j <= m;j++){
			    cin >> a[i][j];
			    d[i][j] = a[i][j];
			}
		}
		for(int i = 1;i <= n;i++){
			for(int j = 1;j <= m;j++) cin >> b[i][j];
		}
		bool okk;
		for(int q = 1;q <= m;q++){
			okk = 1;
			for(int i = 1;i <= n;i++){
				if(a[i][q] != b[i][1]){
					for(int j = 1;j <= m;j++) d[i][j] = 1 - a[i][j];
				}
			}
			for(int j = 1;j <= m;j++){
				for(int k = 1;k <= m;k++){
					if(vst[k]){
						if(k == m) okk = 0;
						continue;
					}	
					bool ok = 1;
					for(int i = 1;i <= n;i++){
						if(b[i][j] != d[i][k]) ok = 0;
					}
					if(ok){
						vst[k] = 1;
						break;
					}
					if(k == m) okk = 0; 
				}
				if(!okk) break;
			}
			for(int j = 1;j <= m;j++) vst[j] = 0;
			for(int i = 1;i <= n;i++){
				if(a[i][q] != b[i][1]){
					for(int j = 1;j <= m;j++) d[i][j] = a[i][j];
				}
			}
			if(okk) break;
		}
		if(okk) cout << "YES\n";
		else cout << "NO\n";
	}
	return 0;
}
```


---

## 作者：Eternal_SZC (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P1275)

## 题意简述  

有这样一种魔板，它是一个长方形的面板，被划分成 $n$ 行 $m$ 列的方格。每个方格内有一个小灯泡，灯泡的状态有两种。我们可以通过若干操作使魔板从一个状态改变为另一个状态。

操作的方式有两种。

- 任选一行，改变该行中所有灯泡的状态，即亮的变暗、暗的变亮。 

- 其次，任选两列，交换其位置。 

当然并不是任意的两种状态都可以通过若干操作来实现互相转化的。你的任务就是根据给定两个魔板状态，判断两个状态能否互相转化。

## 思路

因为列是可以交换的，所以如果你确定的列中有一列与答案已经对应上了，其实你的魔板已经固定了，那么行就不用在交换了。 

我们通过转换，使得这一列和目标魔板的随便一列，匹配的同时，让其他列也跟着转换，最后判断一下目标魔板，除了第一列以外的所有列，是否和当前魔板一样就可以了。

## Code

```cpp

#include<bits/stdc++.h> //万能头
#define mem(a, i) memset(a, i, sizeof(a))
#define rep(i, a, b) for(int i = a; i <= b ; i++)
const int maxn = 128;
using namespace std;
int n, m, k, f;
int map[maxn][maxn], tar[maxn][maxn], temp[maxn][maxn];
//转换 i 行操作。 
void converse(int i) { rep(j, 1, m) map[i][j] = !map[i][j]; }
// 判断目标魔板除了第一列以外时候都和当前魔板匹配。 
bool Check(int choose) {
    bool vis[maxn];
    mem(vis, 0);
    rep(jt, 2, m) {
        rep(jp, 1, m) {
            if(jp == choose)    continue;
            bool pd = 0;
            rep(i, 1, n)
                if(map[i][jp] != tar[i][jt]) {
                    pd = 1;
                    break;
                }
            if(!pd && !vis[jt]) {
                vis[jt] = 1;
                break;
            }       
        }
    }
    rep(i, 2, m)    if(!vis[i]) return false;
    return true;
}
void Search(int cur) {
    rep(i, 1, n)
        if(map[i][cur] != tar[i][1]) //不同就翻转 
            converse(i);
    return ;
}
void Getback() {
    rep(i, 1, n)
        rep(j, 1, m)
            map[i][j] = temp[i][j];
    return ;
}
int main() {
    scanf("%d", &k);
    rep(p, 1 ,k) {
        mem(map, 0);
        mem(tar, 0);
        mem(temp, 0);
        f = 0;
        scanf("%d %d", &n, &m);
        rep(i, 1, n)
            rep(j, 1, m)
                scanf("%d", &map[i][j]),
                temp[i][j] = map[i][j]; 
        rep(i, 1, n)
            rep(j, 1, m)
                scanf("%d", &tar[i][j]);
        //枚举原魔板的 i 列，使其和目标魔板匹配。 
        rep(i, 1, m) {
            Search(i); 
            if(Check(i)) {
                f = 1;
                printf("YES\n");
                break;
            }
            Getback();//勿忘复原
        }
        if(!f)  printf("NO\n");
    }
    return 0;
}

---

## 作者：Link_Cut_Y (赞：0)

## 题目大意

给定两个由 $01$ 组成的矩阵 $A, B$，分别为模板矩阵和目标矩阵。给定两种变换：

 1. 取反变换。即将第 $a$ 行全部取反。
 
 2. 交换变换。即将 $a, b$ 两列交换。
 
询问模板矩阵是否可以转换为目标矩阵。

## 题目分析

本题有以下的性质：

 1. 对于某一行，最多只能用一次去反变换。因为两次取反变换相当于没变。
 
 2. 对于某一列，如果它与目标矩阵中的一列完全相同了，那么这个矩阵不能继续进行**取反**变换了。
 
有了上面两个性质，我们可以考虑这样构造方案：

首先选取模板矩阵中的一列和目标矩阵中的一列，通过取反变换使得这两列相同。接下来就不能进行取反变换了。

然后通过调整列的顺序，使得模板矩阵与目标矩阵相同即可。

可以直接选取模板矩阵的第 $1$ 列和目标矩阵的第 $i$ 列（$i \in [1, m]$），使得这两列相同。然后枚举模板矩阵的第 $j$ 列和目标矩阵的 $k$ 列，（$j, k \in [1, m]$），使得对于任意 $j$，都有唯一的 $k$ 与他对应（即两列相等），完成匹配。可以看出，时间复杂度为 $O(Tn^3)$。（$T$ 为数据组数）。

另外还有使用 bitset 之类的技巧，在此不加赘述。

## 代码示例

这是不使用 bitset 的代码：

```cpp
#include <cstring>
#include <vector>
#include <cstdio>

using namespace std;

const int N = 110;
int g[N][N], t[N][N];
vector<int> path; // 记录上次取反的行，便于还原
int n, m, T;

void change(int k) { // 取反操作
	for (int i = 1; i <= m; i ++ )
		g[k][i] ^= 1;
}
bool equal(int a, int b) { // 判断两列是否相等
	for (int i = 1; i <= n; i ++ )
		if (g[i][a] != t[i][b]) return false;
	return true;
}
bool solve(int k) {
	if (path.size()) for (auto i : path) change(i); // 还原
	path.clear(); bool st[N] = {0};
    // 通过取反使得模板矩阵第 1 列和目标矩阵第 k 列相同。
	for (int i = 1; i <= n; i ++ )
		if (g[i][1] != t[i][k])
			change(i), path.emplace_back(i);
	
	// 找到一种列的顺序，使得二者可以完全匹配。
	st[k] = true;
	for (int i = 2; i <= m; i ++ ) {
		bool flag = false;
		for (int j = 1; j <= m; j ++ ) {
			if (st[j]) continue;
			if (equal(i, j)) {
				flag = st[j] = true;
				break;
			}
		}
		if (!flag) return false; // 小剪枝
	}
	return true;
}
int main() {
	scanf("%d", &T);
	while (T -- ) {
		scanf("%d%d", &n, &m);
		for (int i = 1; i <= n; i ++ )
			for (int j = 1; j <= m; j ++ )
				scanf("%d", &g[i][j]);
		for (int i = 1; i <= n; i ++ )
			for (int j = 1; j <= m; j ++ )
				scanf("%d", &t[i][j]);
		for (int i = 1; i <= m; i ++ )
			if (solve(i)) {
				puts("YES");
				goto EXIT;
			}
		puts("NO");
		EXIT:;
	}
	return 0;
}
```

使用 bitset 的代码可以看这里：[使用bitset代码](https://www.luogu.com.cn/record/105015980)

---


# 单词游戏

## 题目描述

Io 和 Ao 在玩一个单词游戏。

他们轮流说出一个仅包含元音字母的单词，并且后一个单词的第一个字母必须与前一个单词的最后一个字母一致。

游戏可以从任何一个单词开始。

任何单词禁止说两遍，游戏中只能使用给定词典中含有的单词。

游戏的复杂度定义为游戏中所使用的单词长度总和。

编写程序，求出使用一本给定的词典来玩这个游戏所能达到的游戏最大可能复杂度。


## 样例 #1

### 输入

```
5
IOO
IUUO
AI
OIOOI
AOOI```

### 输出

```
16```

# 题解

## 作者：kradcigam (赞：48)

## 前言

首先，看到这道题目，我首先想到的是暴搜，通过$vector$来搞，代码也是很短的。

这里用了一个类似于分治的思想

把一个大问题转化为小问题

先枚举第一个单词，之后把能拼接在它后面的单词都一个一个的去试，哪个最优选哪个

```cpp
#include <bits/stdc++.h>
using namespace std;
template<typename T>inline void read(T&x){
	T f=1;x=0;char ch=getchar();
	for(;!isdigit(ch);ch=getchar())if(ch=='-')f=-1;
	for(;isdigit(ch);ch=getchar())x=(x<<1)+(x<<3)+(ch^48);
	x*=f;
}//快读，常数优化
template<typename T>inline void write(T x){
	if(x<0){
		putchar('-');
		write(x*-1);
		return;
	}
	if(x>9)write(x/10);
	putchar(x%10+48);
}//快写，常数优化
string st[18];
vector<int>v[210];//动态数组
int f[18];//标记数组
int dfs(int x){
	int ans=0;
	for(auto i:v[st[x][st[x].size()-1]])//v数组是存第1个字母的一个容器
		if(!f[i]){
			f[i]=1;//标记这个字符串已经用过了
			ans=max(ans,dfs(i));//打擂
			f[i]=0;//回溯
		}
	return ans+st[x].size();
}
int main(){
	int ans=0,n;
	read(n);//读入
	for(int i=1;i<=n;i++)cin>>st[i],v[st[i][0]].push_back(i);//读入，放入vector容器
	for(int i=1;i<=n;i++){
		f[i]=1;//表记
		ans=max(ans,dfs(i));//打擂法找到最优解
		f[i]=0;//回溯
	}
	write(ans);//输出
    return 0;
}
```
[然后](https://www.luogu.org/record/27279213)，你会发现你只得了70分，开$O(2)$试试？[TLE](https://www.luogu.org/record/27279276)again!

想一想更优秀的算法，加记忆化？是的！

## 正文

### 储存状态

如何存状态

我们发现每一个字符串的状态都要么是0，要么是1，所以我们可以用二进制的思想去压缩状态。

$$1≤N≤16$$

$$2^{n(16)}=65536$$

开数组很充裕，浪费也不要紧。

### 判断状态

如何去判断第$i$个单词有没有用过

从右往左这个数二进制的第$i$位是$1$，就代表这个单词用过，反之$0$就代表这个单词没用过。

但给你这么一个数，你该这么去判断呢？

用位运算！

如果第$i$为是$1$，那么$x>>(i-1)$后$\mod2$就是$1$

如果第$i$为是$0$，那么$x>>(i-1)$后$\mod2$就是$0$

那么判断这个单词是否用过，我们就可以这么写
```cpp
if(!((y>>(i-1)&1))//按位与，只有两个数这一位都是1才为1，所以只有当最后一位是1，这个数才会是1，否则是0
```
### 标记状态

如何将这一位变成$1$

将这一位变成$1$，我们可以用位运算中的按位或——两位都是$0$，这一位的得数才为$0$

```cpp
y|(1<<(i-1))
```
这应该是很显然的

### 总结

现在就可以看总的代码了

```cpp
#include <bits/stdc++.h>
using namespace std;
template<typename T>inline void read(T&x){
	T f=1;x=0;char ch=getchar();
	for(;!isdigit(ch);ch=getchar())if(ch=='-')f=-1;
	for(;isdigit(ch);ch=getchar())x=(x<<1)+(x<<3)+(ch^48);
	x*=f;
}
template<typename T>inline void write(T x){
	if(x<0){
		putchar('-');
		write(x*-1);
		return;
	}
	if(x>9)write(x/10);
	putchar(x%10+48);
}
string st[18];
vector<int>v[210];
int f[17][1<<17];
int dfs(int x,int y){
	if(f[x][y])return f[x][y];
	int ans=0;
	for(auto i:v[st[x][st[x].size()-1]])
		if(!((y>>(i-1))&1))ans=max(ans,dfs(i,y|(1<<(i-1))));
	return f[x][y]=ans+st[x].size();
}
int main(){
	int ans=0,n;
	read(n);
	for(int i=1;i<=n;i++)cin>>st[i],v[st[i][0]].push_back(i);
	for(int i=1;i<=n;i++)ans=max(ans,dfs(i,(1<<(i-1))));
	write(ans);
    return 0;
}
```
刚开始我认为这应该没有多少重复运算，所以我写了个暴搜，但是，我写了记忆化之后惊奇地发现，暴搜总用时$4.00s$,也就是$4000ms$，而记忆化搜索总用时$73ms$，快了不只一点。但是空间确实消耗很大。

编程中有很多算法，用空间换时间，记忆化搜索就是这么一个代表，我们要学习这种思想，想出更巧妙的办法！

---

## 作者：pufanyi (赞：45)

## 论骗分的重要性

其实这题的暴搜稍微改一下就可以`0ms`过。

首先，想一想出题人如何卡你的暴搜，显然是几乎都是首尾相接的数据。

那么我们想到：最优情况一定是全选。搜到能全选是就直接输出答案。

但显然出题人也会想到这一点，所以一定会随手打几个无关数据。

举个栗子：

```
ABBBBBA
ABBBBA
ABBBA
ABBBBBBA
ABBBA
...
ABBBBBBA
O
```

面对这种数据，我们只要读进来时把像“O”这样的无关数据删掉即可。

然后就是暴搜。

于是这题就被一种随便卡就能被卡掉的算法给骗到了`0ms`.

下面是代码：

```cpp
#include <cstdio>
#include <cstdlib>
#include <algorithm>

using namespace std;

const int maxn = 20;

struct word
{
	int len;
	int fir;
	int end;
	bool vis;
} w[maxn];

int n;
int ans;

int tmp;

inline void dfs(int nowl, int nown, char last)
{
	if(nown == n - tmp)//如果长度满了就直接出答案
	{
		printf("%d", nowl);
		exit(0);
	}
	ans = max(nowl, ans);
	for(int i = 1; i <= n; ++i)
	{
		if(!w[i].vis && last == w[i].fir)
		{
			w[i].vis = true;
			dfs(nowl + w[i].len, nown + 1, w[i].end);
			w[i].vis = false;
		}
	}
}

int dp[maxn][20];

int main()
{
	scanf("%d\n", &n);
	for(int i = 1; i <= n; ++i)
	{
		char tmp = getchar();
		while(!((tmp <= 'z' && tmp >= 'a') || (tmp <= 'Z' && tmp >= 'A')))
			tmp = getchar(); // 由于不敢确定字符串长度，就只得一个一个地读
		w[i].fir = tmp;
		while((tmp <= 'z' && tmp >= 'a') || (tmp <= 'Z' && tmp >= 'A'))
		{
			w[i].len++;
			w[i].end = tmp;
			tmp = getchar();
		}
	}
	tmp = 0;
	for(int i = 1; i <= n; ++i) // n2大力删除无关的字符串
	{
		bool flag = true;
		for(int j = 1; j <= n; ++j)
		{
			if(i != j && (w[i].end == w[j].fir || w[i].fir == w[j].end))
			{
				flag = false;
				break;
			}
		}
		if(flag)
		{
			tmp++;
			w[i].fir = true;
		}
	}
	for(int i = 1; i <= n; ++i)
	{
		w[i].vis = true;
		dfs(w[i].len, 1, w[i].end);
		w[i].vis = false;
	}
	printf("%d", ans);
	return 0;
}
```

---

## 作者：hater (赞：30)

之前已经有心理学剪枝法

窝提供一个更为巧妙的剪枝方法 

# 信仰剪枝法

又称梦想剪枝法

此方法用于多数卡常题且极难被卡死

而且实现方法极为简便 

只需二句代码

```cpp
Tim++ ; 
if( Tim >= 参数 ) 
{
   cout << Ans << endl;
   exit(0) ;
}
```

怎么样 海星吧 

之后只需要暴力大搜即可

```cpp
#include <bits/stdc++.h>
#define MAXN 20 
#define R register 
#define IL inline 
using namespace std ; 
int n , Ans  , Tim ; 
vector <int> v[MAXN] , edge[MAXN] ;
bool vis[MAXN]  ;
string S[MAXN] ;
IL void dfs( R int x , R int Now )
{
  Tim++ ; 
  if( Tim >= 10000 ) 
  {
     cout << Ans << endl;
     exit(0) ;
   }
   Ans = Ans < Now ? Now : Ans ;  
   for(R int i=0; i<v[x].size(); i++)
   {
      R int u = v[x][i] , z = edge[x][i] ;
      if( vis[u] ) continue ;
      vis[u] = 1 ; 
      dfs( u , Now+z ) ; 
      vis[u] = 0 ; 
    }
}
int main() 
{
   cin >> n ;
   for(R int i=1; i<=n; i++)
     cin >> S[i] ;
   for(R int i=1; i<=n; i++)
     for(R int j=1; j<=n; j++)
      if( S[i][S[i].length()-1] == S[j][0] ) 
	v[i].push_back(j) , edge[i].push_back(S[j].length()) ;
   for(R int i=1; i<=n; i++)
   {
     vis[i] = 1 ; 
     dfs( i , S[i].length() ) ; 
     vis[i] = 0 ;
    }
    cout << Ans << endl; 
    return 0 ;
}
```



---

## 作者：Created_equal1 (赞：20)

很不能理解为什么楼上的记搜能够通过。。

这题实际上就是带权有向图上点不重复的最长路径。从理论上来说，应该是个NP问题。

楼上的记搜，很显然会有后效性，估计是数据水才通过了吧。

我的思路是dp，设f(i,S)表示当前的最后一个单词是第i个单词，集合S中的单词都被用过了，可以得到的最大收益。

最终ans=max{f(i,{i})}

S在代码中用二进制表示

```cpp


#include <string>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const size_t Max_N(20);

int F[Max_N][70000];

size_t N;
string V[Max_N];
int Ans;

int DFS(const size_t &now, const int &S)
{
    if (F[now][S] != -1)
        return F[now][S];
    F[now][S] = 0;
    for (size_t i = 0;i != N;++i)
        if (*(V[now].end() - 1) == V[i][0] && (!(S & (1 << i))))
            F[now][S] = max(F[now][S], DFS(i, (S | (1 << i))));
    return F[now][S] += V[now].size();
}

int main()
{
    cin >> N;
    for (size_t i = 0;i != N;++i)
        cin >> V[i];
    memset(F, -1, sizeof(F));
    for (size_t i = 0;i != N;++i)
        Ans = max(Ans, DFS(i, (1 << i)));
    
    printf("%d", Ans);
    
    return 0;
}

```

---

## 作者：Y_B_Y (赞：15)

这应该是本题最~~短小~~的代码了(就是有亿点点慢QAQ)

首先看标签,记忆化搜索....,嗯,所以我们可以考虑用$\operatorname{DP}$来完成(~~一般情况下,能用记忆化搜索的都能用$\operatorname{DP}$~~)

这一题由于一个单词是否说过会影响状态的转移,所以我们可以考虑用状压$\operatorname{DP}$

什么是状压$\operatorname{DP}$呢,下面是状压$\operatorname{DP}$的入门知识

我们知道,[一个十进制数可以转化为二进制](https://www.cnblogs.com/web-record/p/11132861.html),二进制数是由0和1组成,如$(11)_{10}=(1011)_{2}$我们可以用,这些1和0来表示一些信息,而因为它是数所以可以存在用于DP的数组里,并且可以通过位运算来进行快速的计算.

这里介绍几种位运算

按位与"$\&$",$1\& 1 =1$,$1\& 0 =0$,$0\& 1 =0$,$0\& 0 =0$,如果是一个多位的二进制数则按位计算,如$(1011)_{2} \& (0110)_2 = (0010)_{2} =(10)_2=(2)_{10}$

按位或"$|$" $1| 1 =1$,$1| 0 =1$,$0| 1 =1$,$0| 0 =0$ 计算方法同上

按位异或"$⊕$" $1⊕ 1 =0$,$1⊕ 0 =1$,$0⊕ 1 =1$,$0⊕ 0 =0$,计算方法同上(注这个位运算在C++代码中用"^"符号表示)

右移"$<<$",就是将一个数的二进制串整体像右移,如$(13)_{10}<<3=(1101)_2<<3=(1101000)_2=(104)_{10}$,并且$a<<k=a\times 2^k$

左移"$>>$",类似.

那位运算如何进行,比如我们用二进制的第$i$位表示单词$i$是否说过,那么我们如果要看第单词$3$是否说过,设现在的状态为$(110010)_2$我们可以直接$(110010)_2 \& (1<<(3-1))=(110010)_2 \& (100)_2=0$,等于0,说明单词$3$还没说过,那如果我们要判断单词$k$是否说过,设状态为$j$,那么就可以判断$j\&(1<<(k-1))$,如果为1即说过

由于这一题涉及的位运算不多这里就不深究

这一题我们可以考虑用二进制数来表示状态,如果第$i$位为0,则第$i$个单词没被说过,反之则说过,我们可以把这个二进制数存在数组里作为状态来转移,所以我们的数组为$f[k]$表示状态为$k$,的最大长度,所以我们首先枚举这个状态,然后我们再枚举一个$i$和一个$j$表示从$i$接到$j$,所以我们可以得出状态转移方程

$f[k+(1<<(j-1))]=max(f[k+(1<<(j-1))],f[k]+(int)s[j].size())$

初始化$f[(1<<j)]=s[j+1].size()$(只说一个单词的状态要先处理)

我们发现总是用小的下标更新大的下标,所以从小到大($0$到$(1<<n)-1$)枚举状态即可

代码

```cpp
for(int k=0;k<(1<<n);k++)
	for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++)
	{
		if(i==j) continue;
		if(s[i][s[i].size()-1]==s[j][0]&&(k&(1<<(i-1)))&&!(k&(1<<(j-1)))) f[k+(1<<(j-1))]=max(f[k+(1<<(j-1))],f[k]+(int)s[j].size()),ans=max(ans,f[k+(1<<(j-1))]);//因为从i到j所以状态k里i必须说过,j必须没说过
	}
```

如果这样写,你会获得70分的好成绩,为什么呢?因为我们发现i能接到j,需要状态k最后一个接的为i,所以我们加一维,使数组变为$f[k][i]$表示状态为k,最后一次接的为$i$的最大长度

则状态转移方程为

$f[k+(1<<(j-1))][j]=max(f[k+(1<<(j-1))][j],f[k][i]+(int)s[j].size())$

所以代码也很容易写出来了

```cpp
#include<bits/stdc++.h>
using namespace std;
int f[(1<<16)][17],n,ans;
string s[100];
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++) cin>>s[i],f[(1<<(i-1))][i]=s[i].size();//初始化只说了一个单词的状态的值
	for(int k=0;k<(1<<n);k++)//枚举状态
	 for(int i=1;i<=n;i++)//枚举i
	  for(int j=1;j<=n;j++)//枚举j
	   if(i!=j&&s[i][s[i].size()-1]==s[j][0]&&(k&(1<<(i-1)))&&!(k&(1<<(j-1)))) f[k+(1<<(j-1))][j]=max(f[k+(1<<(j-1))][j],f[k][i]+(int)s[j].size());//更新f的值
	for(int i=0;i<(1<<n);i++) for(int j=1;j<=n;j++) ans=max(ans,f[i][j]);//找最大值
	return printf("%d",ans),0;//输出和return 0二合一
}
```


---

## 作者：longlongzhu123 (赞：13)

## 解决方案：动态规划（状态压缩）

题目意思大致是：通过给定字典，求出最长单词接龙长度。

~~（我才不告诉你我一开始还以为是SPFA / 网络流）~~

数据范围：n <= 16，属于01枚举的常识数据范围QwQ。

考虑 ~~dynamic programming~~ __DP__。

定义DP数组 __f[S][c]__，

其中S是已选字符串集，c是接龙的末尾字符

__bool f[S][c]__表示能否通过连接S中的字符串，使末尾字符为c

如果已选S，对于第i个未选字符串str，就会有：

```cpp
int len = str.size();
char begin = str[0], end = str[len-1];
if(f[S][begin]) {
	f[S + (1 << i)][end] = true;
}
```

统计最长接龙长度时，就将S中的字符串长度累加起来

在实现上，我们可以省略累加S这一步，直接在f数组中保存接龙的长度

01枚举时，我采用了枚举__S + (1 << i)__的方式（仅仅只是个人习惯而已QwQ）

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 18;

//  字符串结构体（我习惯什么结构都叫NodeQwQ）
//  因为我们只在意字符串的首/位字符及长度
//  所以只保存了三个变量
struct Node {
	int begin, end;
	int len;
} a[MAXN];

//  为了节省空间，程序做了对字符的映射
int idx(char c) {
	switch(c) {
		case 'A':
			return 0;
		case 'E':
			return 1;
		case 'I':
			return 2;
		case 'O':
			return 3;
		case 'U':
			return 4;
	}
}

//  三个变量分别是：n，DP数组，最长接龙（也就是答案了）
int n;
int f[1 << MAXN][5];
int max1 = 0;
int main() {
	cin>>n;
    
    //  输入部分
	for(int i = 0; i < n; i ++) {
		string s;
		cin>>s;
		a[i].len = s.size();
		a[i].begin = idx(s[0]);
		a[i].end = idx(s[a[i].len - 1]);
	}
    
    //  DP中...
    //  枚举i为上文"S + (1 << i)" 
	for(int i = 0; i < (1 << n); i ++) {
    
    	//  枚举当前字符串
        //  就是上文中的"str[i]"
		for(int j = 0; j < n; j ++) {
        
        	//  若集合i拥有j
			if(i & (1 << j)) {
            
            	//  若集合i只有j一个元素
                //  或"f[S][begin]"
				if(i == (1 << j) || f[i - (1 << j)][a[j].begin]) {
                	//  那么更新DP数组
					f[i][a[j].end] = f[i - (1 << j)][a[j].begin] + a[j].len;
                    
                    //  更新max1
					if(f[i][a[j].end] > max1)
						max1 = f[i][a[j].end];
				}
			}
		}
	}
	cout<<max1<<endl;
	return 0;
}
```

---

## 作者：Accoty_AM (赞：11)

~~作为一个蒟蒻，头一次打出来这玩意~~

用二进制 0101010 表示第1 3 5个被取过 

搜索中用 o 表示当前取过状态

在用v[]表示哪些点被取过

代码跑的飞快 122ms

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
char s[17][110];
bool v[17];
int a[17];
int d[17][1<<17];
int dfs(int st,int o){
	if(d[st][o]) return d[st][o];
	int ans=0;
	for(int i=1;i<=n;++i){
		if(!v[i]&&s[st][a[st]]==s[i][1]){
			v[i]=1;
			ans=max(ans,dfs(i,o|(1<<i))+a[i]);
			v[i]=0;
		}
	}
	d[st][o]=ans;
	return ans;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;++i)scanf("%s",s[i]+1),a[i]=strlen(s[i]+1);
	int ansll=0;
	bool pd=0;
	for(int i=1;i<=n;++i){
		memset(v,0,sizeof(v));
		if(d[i][1<<i]==0)pd=1;
		v[i]=1,ansll=max(ansll,a[i]+dfs(i,1<<i));
		if(pd)d[i][1<<i]+=a[i],pd=0;
	}
	printf("%d",ansll);
	return 0;
 } 
```
最后说明一下为什么记忆化数组要开2维
f[i][j] 表示目前在第i个单词状态为j，因为可能存在两者状态都是j但在不同单词的情况。


---

## 作者：x义x (赞：8)

嘛，我觉得，这道题蓝题实在是言过其实了。完全就是状压dp模板题啊！

我们对于**每个单词选或者不选**这个状态用一个二进制数存储。

举个栗子：

- 00001就是只有第一个单词被选上了；

- 00100就是只有第三个单词被选上了；

- 01001就是第一、四个单词被选上了；

- 11111就是这五个单词全部被选上了。

我们一看数据范围，$N\le16$，那就是说我们的状态不会超过$2^{16}-1=65535$，吼啊。

下面是愉快的转移方程时间：

$f[s][c]$表示状态为$s$且最后一个字母为$c$的最大复杂度，那么我们现在想选上单词$j$：

如果$s\;|\;2^{j-1}$，即$j$的那一位为1，那么$j$已经被选过了，我们就不能再选了，continue;

否则

$f[s+2^{j-1}][j$的末位$]=max(f[s+2^{j-1}][j$的末位$],f[s][j$的首位$]+j$的长度$)$

想必大家都看的出来$s+2^{j-1}$就是我们选上$j$之后的状态啦。

最后奉上代码：

```
#include<bits/stdc++.h>
using namespace std;

int n,N;
int f[66666][30];  //f[s][c]是状态为s,末尾字符为c的最大复杂度
string wrd[20];
int ANS;

int main(){
	cin>>n;N=(1<<n)-1;
	for(int i=1;i<=n;i++) cin>>wrd[i];
	
	for(int i=1;i<=n;i++)
		f[1<<(i-1)][wrd[i][wrd[i].size()-1]-'A']=wrd[i].size(),ANS=max(ANS,f[1<<(i-1)][wrd[i][wrd[i].size()-1]-'A']);  //初始化 
	
	for(int i=1;i<=n;i++)  //最多n个单词嘛
	for(int j=1;j<=n;j++)  //选择使用单词j
	for(int s=0;s<=N;s++)  //状态
	if(s & (1<<(j-1)))  continue;  //选过惹~
	else{
		f[s + (1<<(j-1))][wrd[j][wrd[j].size()-1]-'A']=max( f[s + (1<<(j-1))] [wrd[j][wrd[j].size()-1]-'A'] ,(int)(f[s][wrd[j][0]-'A'] +wrd[j].size()));
		ANS=max(ANS,f[s + (1<<(j-1))][wrd[j][wrd[j].size()-1]-'A']);
		//cout<<i<<' '<<j<<' '<<s<<endl;
	} 
	cout<<ANS;
} 
```

~~900+ms，我也很想知道那些爆搜是怎么做到0ms的~~

---

## 作者：zhaotiensn (赞：7)

~~这题似乎数据比较水，数据范围本身就小，稍微有点剪枝的深搜好像都卡不掉。~~

我比较菜，只会用深搜水，这里补一个前面的一堆大佬发的搜索题解中没有提到的最优性剪枝。当一个单词首尾和另外一个单词相同时，优先选择最长的那个，其他的不用选。然后只剩下了全排列的搜索。

效果挺好的，也比较好想到。可以想象当这一层的满足条件不同单词越多，下一层满足条件的越少，n=16时卡满复杂度的数据也还可以承受。~~(表示n=20就萎掉了)~~

卡满的数据：

16 AO AI AU AA OI OU OA OO UI UA UO UU IO IU IA II

AC代码：~~(欢迎大佬叉掉)~~

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;

struct Node{
	char l,r;
	int w;
	inline bool operator<(const Node&x)const{//排序
		if(l!=x.l){
			return l<x.l;
		}else{
			if(r!=x.r){
				return r<x.r;
			}else{//保证首尾字母相同的情况下从大到小
				return w>x.w;
			}
		}
	}
}a[20];

int n,ans,len;
char s[1000];
bool vis[20];//vis表示是否用过这个单词

inline int dfs(int x){
	int sum=0;
	for(int i=1;i<=n;i++){//枚举下一个单词
		if(a[x].r==a[i].l&&!vis[i]){//判断是否可行
			vis[i]=true;
			sum=max(sum,a[i].w+dfs(i));
			vis[i]=false;
			while(a[i+1].l==a[i].l&&a[i+1].r==a[i].r)i++;
		}//唯一的剪枝
	}
	return sum;
}

int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%s",s+1);
		len=strlen(s+1);
		a[i].l=s[1];a[i].r=s[len];a[i].w=len;//单词中间的字母是没有用的
	}
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++){//枚举第一个单词
		vis[i]=true;
		ans=max(ans,a[i].w+dfs(i));
		vis[i]=false;
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：米奇奇米 (赞：3)

### 前面的巨佬都是用各种玄学的方法：状压$DP$，我在这里介绍一种很简单粗暴的方法：

##### 首先我们先对两个字符窜如果一个字符串的开头等于另一个字符串的结尾，那么就从结尾向开头暴力前向星连边，时间复杂度只有$O(n^2)$，这就是预处理部分。然后就暴力搜索，标记搜过的点在回溯一下就可以了。思维难度以及代码难度都不是很难。中间有个操作很重要，就是运行到足够多的次数直接退出，可以大大减少时间复杂度。

##### 以下我就贴一下代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=20;
int len[N],n,m,ans,maxn,Cnt,ff=0;
int head[N],vis[1<<16],cnt;
char c[N][1<<16];
struct Node
{
	int nex,to;
};
Node edge[1<<16];
inline void add(int u,int v)
{
	edge[++cnt].nex=head[u];
	head[u]=cnt;
	edge[cnt].to=v;
}
inline void dfs(int sum,int u)
{
	if((++Cnt)>10000)
	{
	   ff=1;
	   return;
	}
	for ( register int i=head[u];i;i=edge[i].nex )
	{
		int v=edge[i].to;
		if(!vis[v])
		{
			vis[v]=1;
			dfs(sum+len[v],v);
			vis[v]=0;
			if(ff==1) break;
		}
	}
	if(u!=n+1&&sum>ans) ans=sum;
}
int main()
{
	freopen("words.in","r",stdin);
	freopen("words.out","w",stdout);
	scanf("%d",&n);
	for ( register int i=1;i<=n;i++ ){
		scanf("%s",c[i]+1);
		len[i]=strlen(c[i]+1);
	}
	for ( register int i=1;i<=n;i++ )
	{
		for ( register int j=1;j<=n;j++ )
		{
		    if(c[i][len[i]]==c[j][1]) add(i,j);
		}
	}
	for(int i=1;i<=n;i++) add(n+1,i);
	dfs(0,n+1);
	printf("%d\n",ans);
	return 0;
}
		
		
```

#### **代码解释**：
#### $len[i]=strlen(c[i]+1);$
##### 就是统计每个字符串的长度
#### $if(c[i][len[i]]==c[j][1]) add(i,j);$
##### 这句话就是如果一个字符串的开头等于另一个字符串的结尾，两个字符串之间连边
#### $if((++Cnt)>10000)$
##### 这句非常关键，不加的话会超时的,70ptc，大大减少运行的次数


---

## 作者：MloVtry (赞：3)

似乎没有状压DP的题解？

做了几道欧拉路第一眼反应就是图论

然后看了一眼数据范围

16.......

状压你好啊~！

2^16=66666

这个玩意再开个26也是放得下的（我甚至直接开的200）

f[sta][i] 表示sta这个集合（二进制表示选或者不选）以i这个字母结尾的最优解

然后直接枚举全状态去取马克思就行了

实现的话可以用记忆化搜索

就酱
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
int f[66666][200],vis[66666][200];
int n;
string a[20];
int ans;
int dfs(int sta,char last)
{
    if(sta==0) return 0;
    if(vis[sta][last]) return f[sta][last];
    vis[sta][last]=1;
    for(int i=1;i<=n;++i)
    {
        if(sta&(1<<(i-1)))
        {
            int zz=a[i].size()-1;
            if(a[i][zz]!=last) continue;
            f[sta][last]=max(f[sta][last],dfs(sta^(1<<(i-1)),a[i][0])+zz+1);
        }
    }
    return f[sta][last];
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;++i) cin>>a[i];
    int to=(1<<n)-1;
    for(int i=1;i<=to;++i)
    {
        for(int j='A';j<='Z';++j)
        {
            ans=max(ans,dfs(i,j));
        }
    }
    printf("%d\n",ans);
    return 0;
}

```

---

## 作者：Na2PtCl6 (赞：2)

十分感谢 [pufanyi提供的思路](https://pufanyi.blog.luogu.org/solution-p1278) ， 但我觉得TA的代码在某些方面可以更好一点

## 分析题目
一看题目，我们发现这是一个和全排列有关的问题，看似很简单？然鹅却是需要剪枝的，因为$1\leq n\leq16$。

因为本题数据较弱，我们可以用 vector 储存每个单词，把满足 `既不能接到其他单词后边，也不能当火车头的` 单词直接删掉 , 然后用类似全排列的方法枚举剩下的字符串

另外，因为单词接龙中，我们只需要知道单词的首字母、尾字母和长度，所以可以用一个简单的结构体来储存一个单词，可以节省很多时间和空间

## 代码
单词结构体
```cpp
struct word{
	bool vis;  //记录单词是否在全排列枚举中用到过 
	char begin,end;  //记录单词的首尾字母 
	int len;  //记录单词长度 
}w;
```

读入每个单词
```cpp
for(int i=0;i<n;i++){
		scanf("%s",init);
		int l=strlen(init);
		w.len=l;
		w.begin=init[0],w.end=init[l-1];
		s.push_back(w);
	}
```

删除无用的单词
```cpp
sz=n;  //用sz来记录剩下的单词个数 
	for(int i=0;i<sz;i++){
		bool f=1;
		for(int j=0;j<sz;j++){
			if(i==j)  //不能自己和自己比较 
				continue;
			if(s[i].begin==s[j].end||s[i].end==s[j].begin){
				f=0;
				break;
			}
		}
		if(f){
			--sz;
			s.erase(s.begin()+i);
			//删除下标为i的单词后，后面的所有单词都会往前退，所以要在删除的位置再枚举一次 
			--i;  
		}
	}
```

dfs函数
```cpp
void dfs(int step,char end,int len){
	if(step==sz){
		printf("%d",len);
		exit(0);
	}	
	bool f=1;
	for(int i=0;i<sz;i++){
		if(!s[i].vis&&end==s[i].begin){
			f=0;
			s[i].vis=1;
			dfs(step+1,s[i].end,len+s[i].len);
			s[i].vis=0;
			continue;
		}
		if(i==n-1&&f){  //已经无法继续接下去了 
			res=max(len,res);
			return ;
		}
	}
}
```

完整代码
```cpp
#include<bits/stdc++.h> 
using namespace std;
char init[104];
int n,sz,res=-1;

struct word{
	bool vis;  //记录单词是否在全排列枚举中用到过 
	char begin,end;  //记录单词的首尾字母 
	int len;  //记录单词长度 
}w;
vector < word > s;

void dfs(int step,char end,int len){
	if(step==sz){
		printf("%d",len);
		exit(0);
	}	
	bool f=1;
	for(int i=0;i<sz;i++){
		if(!s[i].vis&&end==s[i].begin){
			f=0;
			s[i].vis=1;
			dfs(step+1,s[i].end,len+s[i].len);
			s[i].vis=0;
			continue;
		}
		if(i==n-1&&f){  //已经无法继续接下去了 
			res=max(len,res);
			return ;
		}
	}
}

int main(){
	scanf("%d",&n);
	for(int i=0;i<n;i++){
		scanf("%s",init);
		int l=strlen(init);
		w.len=l;
		w.begin=init[0],w.end=init[l-1];
		s.push_back(w);
	}
	sz=n;  //用sz来记录剩下的单词个数 
	for(int i=0;i<sz;i++){
		bool f=1;
		for(int j=0;j<sz;j++){
			if(i==j)  //不能自己和自己比较 
				continue;
			if(s[i].begin==s[j].end||s[i].end==s[j].begin){
				f=0;
				break;
			}
		}
		if(f){
			--sz;
			s.erase(s.begin()+i);
			//删除下标为i的单词后，后面的所有单词都会往前退，所以要在删除的位置再枚举一次 
			--i;  
		}
	}
	for(int i=0;i<sz;i++){
		s[i].vis=1;
		dfs(1,s[i].end,s[i].len);
		s[i].vis=0;
	}
	printf("%d",res);
	return 0;
	
}
```

---

## 作者：水無月嘉祥 (赞：2)

为什么其他大佬都是用的动归或者DFS啊……
## 这里我给出BFS解法（或者说是图论的Dijkstra？）
### 思路：把每条边处理好头、尾、长度、ID标记。
### 然后看到很小的数据范围就想到了搜索+状压……没想出深搜解法，乱搞出一个广搜

------------

### 搜索具体实现
就是枚举起始点，再定义一个数据类型pii（**typedef**），这个类型前面存点，后面存压缩过的状态，再用广搜模板去跑就行了

------------
### 距离的处理
很明显广搜要跑N次，所以dis数组我开了三维，第一位是起始点，第二维是到达的点，第三维是状态

------------
### 一个点是否被搜过的处理
状态压缩，把每个点压一下，就可以解决冲突

------------
### 最终答案处理
因为数据范围很弱（1<=N<=16），所以最后就可以直接三重枚举，极限时间大概在0.16s左右

------------
### 上代码
```cpp
#include<bits/stdc++.h>
using namespace std;


int n;

int dis[20][20][70000];

struct words
{
	char head;
	char tail;
	int id;
	int len;
}e[20];

void bfs(int x)
{
	typedef pair<int,int> pii;//前面是边，后面是状态 
	queue <pii> q;
	q.push(make_pair(x,1<<(x-1)));
	dis[x][x][1<<(x-1)]=e[x].len;
	while(!q.empty())
	{
		int u=q.front().first;
		int state=q.front().second;
		q.pop();
		for(int i=1;i<=n;i++)
		{
			if(e[u].tail==e[i].head&&!(state&(1<<(i-1))))
			{
				if(dis[x][i][state|(1<<(i-1))]<dis[x][u][state]+e[i].len)
				{
					dis[x][i][state|(1<<(i-1))]=dis[x][u][state]+e[i].len;
					q.push(make_pair(i,state|(1<<(i-1))));
				}
			}
		}
	}
}

int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		char input[105];
		scanf("%s",input);
		e[i].head=input[0];
		e[i].tail=input[strlen(input)-1];
		e[i].id=i;
		e[i].len=strlen(input);
	}
	for(int i=1;i<=n;i++)
	{
		bfs(i);
	}
	int ans=0;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
			for(int k=0;k<=(1<<n);k++)
				ans=max(ans,dis[i][j][k]);
	}
	printf("%d",ans);
	return 0;
}
```


---

## 作者：AVALON_7 (赞：2)

额。。事实上那个下面有人给的所谓的树形Dp事实上。。。好像是状压Dp吧？？

前几天被状压Dp暴虐。。于是来刷题了。。顺便凑个题解。。

话说能给网站提个建议不：把动态规划全部归为一个标签真的。。有时不太方便。。能不能分类详细点？像树形Dp状压Dp区间Dp等

以下是树形Dp题解。。

中间套了个Floyed记一下哪两个单词可以配对..

```cpp
#include<iostream>
#include<iomanip>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<string>
#include<algorithm>
#include<cmath>
#include<queue>
#include<vector>
using namespace std;

inline int read()
{
    int X=0,w=1; char ch=0;
    while(ch<'0' || ch>'9') {if(ch=='-') w=-1;ch=getchar();}
    while(ch>='0' && ch<='9') X=(X<<3)+(X<<1)+ch-'0',ch=getchar();
    return X*w;
}

char s[20][105];
int n,len[20],c[20][20];
struct node{int num,pos;}f[700000];
int main()
{
    n=read();    int ans=0;
    for(int i=1;i<=n;i++)
    {
        scanf("%s",s[i]);
        len[i]=strlen(s[i]);
        f[1<<(i-1)].num=len[i];
        f[1<<(i-1)].pos=i;        
        ans = max(ans,len[i]);
    }
    for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)
    {
        if(s[i][len[i]-1]==s[j][0])
            c[i][j]=1;
    }
    for(int i=1;i<(1<<n);i++)
        if(f[i].num)
        for(int j=1;j<=n;j++)
            if(c[f[i].pos][j])        
            if(!(i&1<<(j-1)))
            if(len[j]+f[i].num>f[i|(1<<(j-1))].num)
            {
                f[i|(1<<(j-1))].num=len[j]+f[i].num;
                f[i|(1<<(j-1))].pos=j;
                ans=max(ans,f[i|(1<<(j-1))].num);
            }
    cout << ans << endl;
}
```

---

## 作者：xuan__xuan (赞：2)

单词游戏正解！

这道题困惑我很久了，以前做只拿了70分，已经不会再往下做了；

自从学习了记忆化搜索，我就对记忆化搜索产生了极大的兴趣；

记忆化搜索 = DP思想 + 搜索模板；

一个非常实用的东西，能解决一些DP无法解决的问题；

下面进入本题：本题的常规思路是一个个穷举，记录当前最优质，当已经无法再往下递归是比较最优解；但这个思路非常容易超时，怎么办呢，于是我想到了记忆化搜索;

用f[i][v]（i表示当前物品，表示当前长度）记录本阶段最优解;

代码如下：

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm> 
using namespace std; 
int f[2001][2001];
int book[1001];
int n;
int Ans;
struct node{
    char word[105];
    char begin;
    char end;
    int L;
}a[30];
void init(){
    scanf("%d",&n);
    for(int i = 1 ; i <= n ;i++){
        scanf("%s",&a[i].word);
        a[i].L=strlen(a[i].word);
        a[i].begin=a[i].word[0];
        a[i].end=a[i].word[strlen(a[i].word)-1];
    }
    memset(f,-1,sizeof(f));
}
int ps(int i,int last){
    if(a[last].end==a[i].begin) return 1;
    else return 0;
}
int dfs(int v,int last,int c){
    if(f[last][v] != -1) return f[last][v];
    else{
        for(int i = 1; i <= n; i++){
            if(ps(i,last)==1&&book[i]==0&&i!=c)
            {   
                book[i] = 1;
                f[last][v] = max(f[last][v],dfs(v+a[i].L,i,c)+a[i].L);
                book[i] = 0;
            }
        }
    }
    return f[last][v];//重点，这句话必须有;
}
int main(){
    init();
    for(int k=1; k <= n;k++){//枚举起点;
        memset(book, 0 , sizeof(book));
        memset(f, -1 ,sizeof(f));
        Ans = max(Ans, dfs(a[k].L,k,k) + a[k].L);
    }
    printf("%d\n" ,Ans+1);
    return 0;
}
有人问了，为什么结果要加1呢，因为f数组初始化为-1，表示还没有算过，所以答案要加1才正确;
```

---

## 作者：innocent__ (赞：2)

先膜拜一下记搜的大佬  

一看就知，是搜索，标签说是记搜，可有后效性，我打不出，就打暴搜了  
暴搜的代码简单，只要一个个搜就好了
```
void dfs(int len,string x)
{
	ans=max(ans,len);
	for(int i=0;i<n;i++)
	{
		if(vis[i])continue;
		if(a[i][0]==x[x.size()-1])
		{
			
			vis[i]=1;
			dfs(a[i].size()+len,a[i]);
			vis[i]=0;
		}
	}
}
int main()
{
	cin>>n;
	for(int i=0;i<n;i++)	
		cin>>a[i];
	for(int i=0;i<n;i++)
	{
		vis[i]=1;
		dfs(a[i].size(),a[i]);
		vis[i]=0;
	}
	cout<<ans;
	return 0;
}
```
5分钟码完，但有没有想过时间复杂度，n<=16，意味着它的最大直为 16！ ，
所以，只要加一神奇的代码就能解决   
~~钠  是一段神奇的代码~~
```
	t++;
	if(t>10000)f=1;
        if(f)return ;
```
说白了就是心理学，    
想一下，数据坑人一般都是全排列，假设是全排列的话那在 10000 之前肯定是已将答案算出来了，所以可行 ~~（什么一本正经的胡说八道）~~   


AC代码
```
#include<bits/stdc++.h>
using namespace std;
int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0},n,m,c;
int ans;
string a[1000];
bool vis[105];
void dfs(int len,string x)
{
	
	ans=max(ans,len);
	for(int i=0;i<n;i++)
	{
		if(vis[i])continue;
		if(a[i][0]==x[x.size()-1])
		{
			
			vis[i]=1;
			dfs(a[i].size()+len,a[i]);
			vis[i]=0;
		}
	}
}

int main()
{
	cin>>n;
	for(int i=0;i<n;i++)	
		cin>>a[i];
	for(int i=0;i<n;i++)
	{
		vis[i]=1;
		dfs(a[i].size(),a[i]);
		vis[i]=0;
	}
	cout<<ans;
	return 0;
}
```
还有，说到全排列，其实只要特判一下是否为最大的答案就行了，自己可以试一下       （本人懒 ~~不会~~ ）  

本蒟蒻也就如此，大佬勿喷　　　　

## 谢谢


---

## 作者：清尘 (赞：1)

在题库选择“记忆化搜索”的标签第一个跳出来的就是这题，没想直接爆搜就过了......

先n²预处理出每个单词后面能跟哪些词，然后直接搜索；

第一次提交的时候T了三个点，稍稍一想，开了一个数组记录当前状态是否已经做过，如果做过直接return；

用k[i][j]表示当前选择的单词集合为i(类似于状压，用二进制处理)，最后一个字母为j的状态是否做到过； 因为n最大为16，第一维开到64000左右就够了

想着大概能少 T 1个点，竟然全都过了，只有几ms [提交记录](https://www.luogu.org/record/22739283)
虽然不是很快，但也还过得去q

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, ans, v[20][20], num[20], len[20], vis[20], q[20], k[666666][5], p[100];
char ch[20][105];
inline void Go (int x, int s, int t) {  //x记录上一个单词，s记录长度，t记录已选单词的状态（二进制数） 
	if (k[t][ch[x][len[x]]]) return;
	k[t][ch[x][len[x]]] = 1;
	ans = max (ans, s);
	for (int i = 1; i <= num[x]; i++) 
	  if (!vis[v[x][i]])  
	    vis[v[x][i]] = 1, Go (v[x][i], s + len[v[x][i]], t | q[v[x][i]]), vis[v[x][i]] = 0;
}
int main() {
	scanf ("%d", &n);
	p['E'] = 1, p['I'] = 2, p['O'] = 3, p['U'] = 4;
	q[0] = 1; for (int i = 1; i < n; ++i) q[i] = q[i-1] << 1;
	for (int i = 0; i < n; ++i)  
	  scanf ("%s", ch[i] + 1), len[i] = strlen (ch[i] + 1);
	for (int i = 0; i < n; ++i)
	  for (int j = 0; j < n; ++j)  
	    if (i != j and ch[i][len[i]] == ch[j][1])  v[i][++num[i]] = j;
	for (int i = 0; i < n; ++i) 
		vis[i] = 1, Go (i, len[i], q[i]), vis[i] = 0; 
	printf ("%d", ans);
	return 0;
}
```

---

## 作者：liujiayuan (赞：1)

这道题题就是一个裸的dfs嘛。。。
注释见代码
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,flag[20]={0},ans=-1,t=0;
struct node
{
	ll num;
	char head,tail;
}word[20];//num为单词长度，head为首字母，tail为尾字母
void dfs(ll a,ll b,ll c)
{
	ans=max(ans,b);
	if(c==n-t)
	{
		cout<<ans<<endl;
		exit(0);//如果符合要求所有单词都搜完了就直接输出
	}
	for(int i=1;i<=n;i++)
	{
		if(word[a].tail==word[i].head&&i!=a&&flag[i]==0)
		{
			flag[i]=1;
			dfs(i,b+word[i].num,c+1);
			flag[i]=0;
		}
	}
	return;
}
int main()
{
	ios::sync_with_stdio(false);
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		char s[105];
		cin>>s;
		word[i].head=s[0];
		word[i].tail=s[strlen(s)-1];
		word[i].num=strlen(s);
	}
    //这里有一个转化，毕竟我们只需要首尾两个字母和长度就好了
	for(int i=1;i<=n;i++)
	{
		bool f=true;
		for(int j=1;j<=n;j++)
		{
			if(i!=j&&(word[i].head==word[j].tail||word[i].tail==word[j].head))
			{
				f=false;
				break;
			}
		}
		if(f)
		{
			t++;
		}
		else
		{
			flag[i]=1;
		}
	}
	for(int i=1;i<=n;i++)
	{
		memset(flag,0,sizeof(flag));
		flag[i]=1;
		dfs(i,word[i].num,1);
	}
	cout<<ans<<endl;
	return 0;
}
```


---

## 作者：lx_zjk (赞：1)

# P1278 单词游戏
首先这道题看到数据范围第一眼想到爆搜 ,暴力枚举是否选这个节点，然后calc（）从而得出对应stage的长度，但是calc（）中不能贪心，所以先放弃爆搜

选择新算法

把重要的解释都写在代码注释中了哦

```cpp
#include<bits/stdc++.h>

using namespace std;

typedef long long ll;

inline ll read() {
	ll f=1,x=0;
	char ch;
	do {
		ch=getchar();
		if(ch=='-')f=-1;
	} while(ch>'9'||ch<'0');
	do {
		x=x*10+ch-'0';
		ch=getchar();
	} while(ch>='0'&&ch<='9');
	return f*x;
}
//对结果有影响的只有单词第一位和最后一位 以及单词的长度 用结构体将单词长度 首位 某位记下;
  
const int MAX_N=20;
  
struct node{
	int len;
	char l,r;
}a[MAX_N];

  
int n;

string ch; 

const int MAX_S=70000 + 5;

int ans,bin[MAX_N][MAX_S];

//当前已经选了第now个数组，然后在1...n的范围中匹配首位是否为now的末尾位

inline int  dfs(int now,int stage){
	if(bin[now][stage]!=-1) return bin[now][stage];
	bin[now][stage]=0;//记忆化搜索？
	for(int i=1;i<=n;i++){
		if(!(stage&(1<<i))&&a[now].r==a[i].l)//判断stage是否已经选过i这个数了
		bin[now][stage]=max(bin[now][stage]+a[now].len,dfs(i,stage|1<<i)+a[now].len);
	} 
	return bin[now][stage];
}

int main(){
	n=read();
	for(int i=1;i<=n;i++){
		cin>>ch;
		a[i].l=ch[0];a[i].r=ch[ch.length()-1];a[i].len=ch.length();
	}
	memset(bin,-1,sizeof(bin)); 
	for(int i=1;i<=n;i++){
		ans=max(ans,dfs(i,(1<<i)));
	}
	cout<<ans<<endl;//输出答案，华丽结束
	return 0;
}
```
有不懂可以在我没退役之前私信来问我

---

## 作者：PZimba (赞：0)

最开始还是信仰剪枝函数调用次数设成1e7过的...

后来想了想，优化了一下暴力就过了

## 爆搜+优化的讲解：

将每个字符串的首字母向尾字母连一条边，边的长度为字符串的长度，答案就是每条边最多只经过一次时，图上的最长路。

看一下以下数据：

4

EAAAAE

EAAAAAE

EAAAAAAAE

EAAAAAAAAAE

如果纯爆搜，需要循环!4 * 4 = 96次，我们可以将这四个字符串“拼”成一个字符串，这样原本的四个单词就变成了一个字符串，时间复杂度就会大大减小。

因此我们只要将首尾一样的字符串拼接在一起，（就是将图上的所有自环合并）就可以愉快的AC啦！

### QAQ

$Code:$

```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <string>

using namespace std;

const int MAXN = 50;

int get_num(char cur) {//将字符映射成数字
	if(cur == 'A') return 1;
	if(cur == 'E') return 2;
	if(cur == 'I') return 3;
	if(cur == 'O') return 4;
	if(cur == 'U') return 5;
}

string s;
int n,ans;
int head[MAXN],t[MAXN],w[MAXN],nxt[MAXN],cnt;
bool vis[MAXN];

void addedge(int u,int v,int wei) {
	t[++cnt] = v;
	w[cnt] = wei;
	nxt[cnt] = head[u];
	head[u] = cnt;
}

void DFS(int u,int sum) {
	ans = max(ans,sum);
	for(int i = head[u]; i; i = nxt[i]) {
		if(vis[i]) continue;
		vis[i] = true;
		DFS(t[i],sum + w[i]);
		vis[i] = false;
	}
	return;
}

int main() {
	scanf("%d",&n);
	for(int i = 1; i <= 5; i++) {//给每个点都预先加入一条自环
		addedge(i,i,0);
	}
   //点i的所有自环都将被合并到预先加入的自环上。
	for(int i = 1; i <= n; i++) {
		cin >> s;
		int len = s.length();
		if(s[0] == s[len - 1]) {
			w[get_num(s[0])] += len;//将首尾相等的字符串合并(合并自环)
		}
		else addedge(get_num(s[0]),get_num(s[len - 1]),len);
	}
	for(int i = 1; i <= 5; i++) {
		DFS(i,0);
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：critnos (赞：0)

分析一下：因为本题只有五个字母，所以可以开一个邻接矩阵存储

而存储的东西也可以尽量简化：因为接龙只跟首尾有关，而且首尾这个信息已经用邻接矩阵表示了，所以只用存储长度

其次，根据贪心策略，因为要使接龙最长，每次必定要选能接上的最长的单词

然后？然后就上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
vector<int> a[10][10];//邻接矩阵
int b[100],t[10][10];//b：字母-数字对照表；t：上次用的单词位置
int j[10][10];//记忆化表
int cmp(int x,int y)
{
	return x>y;
}
int dfs(int x,int y)//记忆化搜索
{
	if(j[x][y]!=-1) return j[x][y];//记忆化板子
	int i,mx=0;
	t[x][y]++;//标注：这个单词已经用过了
	for(i=1;i<=5;i++)
		if(t[y][i]<a[y][i].size())
			mx=max(mx,dfs(y,i));
	t[x][y]--;//还原
	return j[x][y]=a[x][y][t[x][y]]+mx;//记忆化板子
}
int main() 
{
	memset(j,-1,sizeof(j));
	b['A']=1;//小技巧：转字母为数字
	b['E']=2;
	b['I']=3;
	b['O']=4;
	b['U']=5;
	string p;
	int i,j,mx=0;
	cin>>n;
	for(i=0;i<n;i++)
	{
		cin>>p;
		a[b[p[0]]][b[p[p.size()-1]]].push_back(p.size());//读入邻接矩阵
	}
	for(i=1;i<=5;i++)
		for(j=1;j<=5;j++)
			sort(a[i][j].begin(),a[i][j].end(),cmp);//贪心的排序
	for(i=1;i<=5;i++)
		for(j=1;j<=5;j++)
			if(a[i][j].size())
				mx=max(mx,dfs(i,j));
	cout<<mx;
}
```
PS：其实不用记忆化也能过

---

## 作者：DimensionTripper (赞：0)

这道题~~据说~~正解是dp……

然而我不会……

所以就写成一个裸的dfs，然后理所当然的T了

[A7T3](https://www.luogu.org/record/show?rid=5334291)

接着就被旁边的dalao嘲笑了

DTZ大佬的记录

[0ms](https://www.luogu.org/record/show?rid=5333743)

于是我想到了卡时（懒得改记忆化）

结果莫名就A了……

具体看代码

```cpp
#include <bits/stdc++.h>
#pragma GCC optimize(3)//手开O3
#define N 200
using namespace std;
char s[N/10][N];
int a[N/10][N],n,sum,ans,f[N],tim;
bool used[N/10],flag;
bool check(char x,int y)
{
    if(x==s[y][0]||x=='\0')
        return true;
    return false;
}//检查上个单词的最后一位与当前单词的第一位
void dfs(int x,char y)
{
    if(clock()-tim>10000)
    {
        cout<<ans;
        exit(0);
    }//卡时基本操作，运行到这个时间就输出（虽然听说clock()贼慢，但会省下更多时间）
    flag=false;//记录当前点能否搜下去
    for(int i=1;i<=n;i++)//枚举当前点
    {
        if(!used[i]&&check(y,i))
        {
            flag=true;
            int len=strlen(s[i]);
            used[i]=true;
            sum+=len;
            dfs(x+1,s[i][len-1]);//向下搜
            sum-=len;
            used[i]=false;//回溯
        }
    }
    if(!flag)
    {
        ans=max(sum,ans);
        return;
    }//搜不下去就更新答案
}
int main()
{
    tim=clock();
    scanf("%d\n",&n);
    for(int i=1;i<=n;i++)
    {
        if(i!=n)
            scanf("%s\n",s[i]);
        else
            scanf("%s",s[i]);
    }
    dfs(1,'\0');
    printf("%d",ans);
    return 0;
}
```
这样一看这个也是道假的蓝题……

卡时有WA的风险，千万别随便学……

不过这里能A（虽然跑的很慢）

[136ms](https://www.luogu.org/record/show?rid=5334979)

代码有待优化

请各位julao自行修改


---

## 作者：xsxshxs (赞：0)

看到没有树形dp的写法发一份，比较模板

```cpp
#include<iostream> 
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,m,ans,dis[16],f[1<<16][16];
char s[1<<16][110];
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%s",s[i]);
        dis[i]=strlen(s[i])-1;
    }
    for(int i=1;i<=n;i++)
    f[(1<<(i-1))][i]=dis[i]+1;
    for(int i=0;i<=(1<<n)-1;i++)
    for(int j=1;j<=n;j++)
    {
        int e1=1<<(j-1);
        if((i|e1)==i)
        for(int k=1;k<=n;++k)
        {
            if((j==k)||(s[j][dis[j]]!=s[k][0]))
            continue;
            int e2=1<<(k-1);
            if((i&e2)==0)
            {
                f[(i|e2)][k]=max(f[(i|e2)][k],f[i][j]+dis[k]+1);
                ans=max(ans,f[(i|e2)][k]);
            }
        }
    }
    cout<<ans;
}
```

---

## 作者：usqwedf (赞：0)

dfs+剪枝+卡时

```delphi

var      
  f:array[0..1000] of boolean;      
  n,i,max,t:longint;      
  a:array[0..1000] of string;      
procedure dfs(x:string;y,z:longint);      
var      
  i:longint;      
begin      
  if t>60000000 then begin writeln(max); halt; end;  //卡时
  if y>max then max:=y;      
  if y+(n-z)*50<=max then exit;      //剪枝
  for i:=1 to n do begin  
    if (x[length(x)]=a[i][1])and(f[i]=false) then begin      
      f[i]:=true;      
      dfs(a[i],y+length(a[i]),z+1);      
      f[i]:=false;      
    end;      
    t:=t+1;  
  end;  
end;      
begin      
  readln(n);      
  for i:=1 to n do readln(a[i]);      
  for i:=1 to n do begin       
    f[i]:=true;      
    dfs(a[i],length(a[i]),1);      
    f[i]:=false;      
  end;      
  writeln(max);      
end.   

```
需要打表么。。回wzf2000


---


# [GCJ 2010 #3] Fence

## 题目描述

我们计划建造一段非常长的围栏。我们已经找到了一个合适的地点，现在只需要收集材料。

在本地的五金店，我们可以无限量地购买木板，每块木板有多种不同的长度可选。为了避免浪费，我们希望这些木板的总长度恰好等于我们要建造的围栏长度。

给定围栏的长度以及可用的木板长度，请你计算，为了恰好拼出所需长度，最少需要购买多少块木板？

注意：围栏会非常长！

## 说明/提示

**样例解释**

在第一个样例中，最优策略是使用 $2$ 块长度为 $23$ 的木板，$5$ 块长度为 $51$ 的木板，以及 $99999997$ 块长度为 $100$ 的木板。当然，你也可以只用 $100000001$ 块长度为 $100$ 的木板来获得大于 $L$ 的总长度，但这是不允许的。

在第二个样例中，只能拼出偶数长度。

**数据范围**

- $1 \leq T \leq 50$。
- $10^{10} \leq L \leq 10^{18}$。
- $1 \leq N \leq 100$。

**小数据集（7 分，测试点 1 - 可见）**

- $1 \leq B_i \leq 100$。

**大数据集（22 分，测试点 2 - 隐藏）**

- $1 \leq B_i \leq 100000$。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
2
10000000001 3
23 51 100
10000000001 3
100 52 22```

### 输出

```
Case #1: 100000004
Case #2: IMPOSSIBLE```

# 题解

## 作者：JiuZhE66666 (赞：0)

结合原版题解和自己的想法...

# 首先看题

贪心的想法是：栅栏这么长，肯定要优先使用最长的木板。

1. 设所有木板中，最长的长度为 $A$。
   
2. 总长度 $L$ 可以表示为 $L = p \times A + q$，其中   $p = \left\lfloor \frac{L}{A} \right\rfloor$ 是我们打算使用的 $A$ 型木板的数量，$q = L \bmod A$ 用其他木板凑。

3. 我们天真地希望用 $p$ 块 $A$ 型木板，然后用其他木板凑出长度 $q$，但这不一定存在方案。也许我们少用一块 $A$ 型木板，即用 $p-1$ 块，然后去凑 $A+q$，反而可以凑出来。

   * 方案 1：用 $p$ 块 $A$ 型木板和 $T_0$ 块其他木板凑 $q$。总数 $p + T_0$。
   * 方案 2：用 $p-1$ 块 $A$ 型木板和 $T_1$ 块其他木板凑 $A+q$。总数 $(p-1) + T_1$。
   * 方案 $i$：用 $p - i$ 块 $A$ 型木板和 $T_i$ 块其他木板凑 $i \times A + q$。总数 $(p - i) + T_i$。


# 关键观察

1. 在所有可行方案中，最优的方案对应使 $T_i - i$ 最小的那个 $i$，因为 $T_i$ 增长得比 $i$ 更快。
2. 每个可行方案里，其他木板凑出的总长度对 $A$ 取模的余数一定是 $q$，即
   $i\times A + q \equiv q \pmod A.$

# 题解

以上思路告诉我们：只需在所有其他木板的组合中，找到能够拼出与 $q$ 同余（模 $A$）的最小板数，就能确定最优方案。

# code

```
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
const ll INF=1e18;

void solve(int cs)
{
    ll len;
    ll n;
    cin>>len>>n;
    vector<ll>blocks(n);
    ll mx=0;
    for(int i=0;i<n;++i)
    {
        cin>>blocks[i];
        if(blocks[i]>mx)
            mx=blocks[i];
    }
    if(mx==0)
    {
        cout<<"Case #"<<cs<<": ";
        if(len==0)
        {
            cout<<0<<"\n";
        }
        else
        {
            cout<<"IMPOSSIBLE\n";
        }
        return;
    }
    vector<ll>dist(mx,INF);
    vector<bool>inq(mx,false);
    queue<ll>q;
    dist[0]=0;
    q.push(0);
    inq[0]=true;
    while(!q.empty())
    {
        ll u=q.front();
        q.pop();
        inq[u]=false;
        for(ll b:blocks)
        {
            ll v=(u+b)%mx;
            ll w=1LL-(u+b)/mx;
            if(dist[u]!=INF&&dist[u]+w<dist[v])
            {
                dist[v]=dist[u]+w;
                if(!inq[v])
                {
                    q.push(v);
                    inq[v]=true;
                }
            }
        }
    }
    ll p=len/mx;
    ll rem=len%mx;
    cout<<"Case #"<<cs<<": ";
    if(dist[rem]==INF)
    {
        cout<<"IMPOSSIBLE\n";
    }
    else
    {
        ll ans=p+dist[rem];
        cout<<ans<<"\n";
    }
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    int T;
    cin>>T;
    for(int i=1;i<=T;++i)
        solve(i);
    return 0;
}

```

---


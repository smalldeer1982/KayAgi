# [GCJ 2008 #3] Portal

## 题目描述

Portal$^{\text{TM}}$ 是由 Valve Software 开发并发行的一款第一人称解谜/平台游戏。游戏的核心思想是在墙上创建两个传送门，然后通过一个传送门跳进去，从另一个传送门出来。本题与此类似，但不要求你玩过 Portal。

在本题中，你处于一个 $R$ 行 $C$ 列的网格中。此外，网格的某处有一块美味的蛋糕。你非常饿，希望用尽量少的步数到达蛋糕。你可以向北、南、东或西移动到一个空单元格。此外，你还可以在墙上创建传送门。

为了帮助你到达蛋糕，你有一把传送门枪，可以发射两种传送门：黄色传送门和蓝色传送门。通过向北、南、东或西方向射击传送门枪，可以发射能量球，在遇到的第一个墙上创建一个传送门。注意，在本题中，射击传送门枪不计为一次移动。如果你向蛋糕射击，能量球会直接穿过蛋糕。

在创建了一个黄色传送门和一个蓝色传送门后，你可以通过黄色传送门到达蓝色传送门，反之亦然。利用这些传送门，你也许能更快地到达蛋糕！只有在你创建了一个黄色和一个蓝色传送门后，才能使用传送门。

请参考下图的网格：

![](https://cdn.luogu.com.cn/upload/image_hosting/tz8ceyn5.png)

灰色格子表示墙，白色格子表示空单元格，红色圆圈表示你的位置。

假设你向东射击蓝色传送门。传送门会出现在能量球遇到的第一个墙上，如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/rzvxatnz.png)

现在假设你向南射击黄色传送门：

![](https://cdn.luogu.com.cn/upload/image_hosting/b3pvr2mg.png)

接下来你向南移动一步：

![](https://cdn.luogu.com.cn/upload/image_hosting/4ogui6pq.png)

有趣的部分来了。如果你再向南移动一步，你会通过黄色传送门到达蓝色传送门：

![](https://cdn.luogu.com.cn/upload/image_hosting/k1k8ybii.png)

任意时刻只能存在一个黄色传送门和一个蓝色传送门。例如，如果你尝试向西创建一个蓝色传送门，原来的蓝色传送门会消失：

![](https://cdn.luogu.com.cn/upload/image_hosting/u3zzj14r.png)

只有当你再次发射同色传送门时，原有的传送门才会消失。

注意，传送门是创建在墙的一侧的。如果一堵墙的东侧有一个传送门，你必须从东侧进入墙才能通过传送门。否则你只是撞到了一堵墙，这是不可能的。

最后，你不能在同一位置放置两个传送门。如果你试图在已有传送门的一侧再次放置传送门，第二个传送门将无法形成。

给定迷宫、你的初始位置和蛋糕的位置，判断你是否能到达蛋糕，并输出最少需要多少步。注意，射击传送门枪不计为移动步数。

## 说明/提示

**样例解释**

以下是第一组数据的移动顺序（注意，射击传送门枪不计为移动步数）：

- 向东移动一步。
- 向北射击蓝色传送门。
- 向南射击黄色传送门。
- 向北移动一步，通过蓝色传送门。
- 向东射击蓝色传送门。
- 向南移动一步，通过黄色传送门。
- 向西移动一步。
- 吃掉你美味多汁的蛋糕。

Portal$^{\text{TM}}$ 是 Valve Inc. 的商标。Valve Inc. 未参与本题的设计，也未对 Google Code Jam 进行任何背书。

**小数据集（10 分，测试集 1 - 可见）**

- $N=200$
- $1 \leqslant R, C \leqslant 8$

**大数据集（15 分，测试集 2 - 隐藏）**

- $N=50$
- $1 \leqslant R, C \leqslant 15$

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
3
4 7
.O..##.
.#.....
.#.####
.#...X.
5 5
O....
.....
.....
.....
....X
1 3
O#X```

### 输出

```
Case #1: 4
Case #2: 2
Case #3: THE CAKE IS A LIE```

# 题解

## 作者：Ivan422 (赞：0)

重题链接：[这题](https://www.luogu.com.cn/problem/P4442)。

最短路。

但是有点难。

我们注意到两个发射位置一定有一个交点。

然后，我们要是在其他点发射，再走一下发射，其实就等同于**在交点发射传送门**。

**所以，我们可以发现：在一个点，射出传送门，一定是比走走再射是更优的。**

于是，我们就把问题转化成：

1. 可走一步。
2. 可以发射传送门，然后进入一个传送门走到另一个传送门。

这样就可以直接 dijkstra 跑过去了。

接下来我们遇到一个问题：如何计算从一个点发射，到的传送门位置呢？

我们可以使用递推的方式求解。

例如我们计算到左边的墙的距离，可以从 $sz_{i,j-1}$ 转移过来，当这个位置为墙，$sz_{i,j}=-1$，因为我们要的是**到墙旁边的距离**，所以一般情况下，$sz_{i,j}=sz_{i,j-1}+1$。

但是注意到 $j-1$ 可能为 $0$，同理在右边 $j+1$ 可能为 $m+1$，所以要对所有边界 $sz_{i,j}=-1$，不然会出错。

同理，有其他三个方向的转移方程，具体看代码。

然后直接最短路即可。

---

代码：

代码为了方便，$sz$ 记录的是距离，注意我的循环方向和递推方式，别忘了处理边界。

剩下的看注释。

```cpp
#include<bits/stdc++.h>
#define int long long
// #define debug
using namespace std;
const int N=500+10;
int n,m,cx,cy,fx,fy,sz[4][N][N],dis[N][N],cid;
bool vis[N][N];
int dx[]={0,0,1,-1}, // L R D U 注意顺序和方向的对应，不然会出问题
    dy[]={-1,1,0,0}; // L R D U
char a[N][N]; // 迷宫
struct srch{ // 当前的搜索状态
    int x,y,d;
    srch(int _x,int _y,int _d){x=_x,y=_y,d=_d;}
};
bool operator<(srch x,srch y){return x.d>y.d;}
priority_queue<srch>q; // dijkstra 的优先队列
void solve(){
	cin>>n>>m;
    for(int i=0;i<=n+1;i++)for(int j=0;j<=m+1;j++)if(i==0||j==0||i==n+1||j==m+1){
        a[i][j]='#'; // 给边界赋初值
        sz[0][i][j]=-1; // 注意到我们计算的是点到墙的距离，那么我们就可以把墙设为 -1，方便递推
        sz[1][i][j]=-1;
        sz[2][i][j]=-1;
        sz[3][i][j]=-1;
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin>>a[i][j];
            if(a[i][j]=='O')cx=i,cy=j; // 找起点
            if(a[i][j]=='X')fx=i,fy=j; // 找终点
        }
    }
    for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)sz[0][i][j]=(a[i][j]=='#'?-1:sz[0][i][j-1]+1); // L，从左边转移到墙的距离，注意墙为 -1，那么墙旁边的就会是 0
    for(int i=1;i<=n;i++)for(int j=m;j>=1;j--)sz[1][i][j]=(a[i][j]=='#'?-1:sz[1][i][j+1]+1); // R，同上，从右边转移到墙的距离
    for(int i=n;i>=1;i--)for(int j=1;j<=m;j++)sz[2][i][j]=(a[i][j]=='#'?-1:sz[2][i+1][j]+1); // D，从下边转移到墙的距离
    for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)sz[3][i][j]=(a[i][j]=='#'?-1:sz[3][i-1][j]+1); // U，从上面转移到墙的距离
    memset(dis,0x3f,sizeof(dis)); // 求最短路
    memset(vis,0   ,sizeof(vis)); // 重置状态
    dis[cx][cy]=0; // 起点
    q.push(srch(cx,cy,0));  // 开始状态
    while(q.size()){ // dijkstra
        srch f=q.top();
        q.pop();
        if(vis[f.x][f.y])continue; // 已经扩展过状态了
        vis[f.x][f.y]=1;
        for(int i=0;i<4;i++){ // 普通移动
            int nx=f.x+dx[i],ny=f.y+dy[i];
            if(nx<1||ny<1||nx>n||ny>m)continue; // 边界
            if(a[nx][ny]=='#')continue; // 障碍物
            if(f.d+1<dis[nx][ny]){ // 更优，选择
                dis[nx][ny]=f.d+1; // 记录答案并计入优先队列
                q.push(srch(nx,ny,f.d+1));
            }
        }
        for(int i=0;i<4;i++){ // Portal 移动
            for(int j=0;j<4;j++)if(i^j){ // 注意方向不能一样
                int nx=f.x+dx[j]*sz[j][f.x][f.y],ny=f.y+dy[j]*sz[j][f.x][f.y]; // 更新位置，这里是先走到 i 方向的传送门，然后转到 j 方向。
                if(nx<1||ny<1||nx>n||ny>m)continue; // 常规最短路的
                if(a[nx][ny]=='#')continue; // 同上
                if(f.d+sz[i][f.x][f.y]+1<dis[nx][ny]){ // 所以，代价是走到 i 传送门的步数加上传送的代价
                    dis[nx][ny]=f.d+sz[i][f.x][f.y]+1; // 更新
                    q.push(srch(nx,ny,dis[nx][ny])); // 再更新 
                }
            }
        }
    }
    #ifdef debug // debug 不用管
        for(int i=1;i<=n;i++){for(int j=1;j<=m;j++){cout<<dis[i][j]<<" ";}cout<<"\n";}
        for(int i=1;i<=n;i++){for(int j=1;j<=m;j++){cout<<sz[0][i][j]<<" ";}cout<<"\n";}
        for(int i=1;i<=n;i++){for(int j=1;j<=m;j++){cout<<sz[1][i][j]<<" ";}cout<<"\n";}
        for(int i=1;i<=n;i++){for(int j=1;j<=m;j++){cout<<sz[2][i][j]<<" ";}cout<<"\n";}
        for(int i=1;i<=n;i++){for(int j=1;j<=m;j++){cout<<sz[3][i][j]<<" ";}cout<<"\n";}
    #endif
    cout<<"Case #"<<++cid<<": ";
    if(dis[fx][fy]==dis[0][0])cout<<"THE CAKE IS A LIE\n";
    else cout<<dis[fx][fy]<<"\n"; // 判无解和输出答案
    return;
}
signed main(){
	int T;
	cin>>T;
	while(T--)
		solve();
	return 0; 
}
```

注意不要犯弱智错误。

---


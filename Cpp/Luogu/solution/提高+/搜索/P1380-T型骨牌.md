# T型骨牌

## 题目描述

现在要在 $n\times m$ 的棋盘上，摆入 T 型，T 型可以旋转，具体包括如下四个样式（“#”代表被T型占据的格子，“.”代表自由的格子）：

```plain
###      ..#      .#.      #..
.#.      ###      .#.      ###
.#.      ..#      ###      #..
```

问最多能在 $n\times m$ 的棋盘上摆入多少个不重叠的 T 型。


## 说明/提示

### 数据范围及约定

对于全部数据，$1\le n,m\le 9$。

### 样例说明

![](https://cdn.luogu.com.cn/upload/image_hosting/r08wh2nu.png)

## 样例 #1

### 输入

```
5 6
```

### 输出

```
4
```

# 题解

## 作者：やらずのあめ (赞：16)

一看到这个题感觉数据很少，很符合我的打表风格，那么我来讲讲如何使用程序打表。  
不管怎么样，这个~~标准~~程序还是要写的，虽然不敢说是正解，但是却可以运行出正确的答案，我的程序就是一个枚举，不断地枚举T型骨牌所在的位置，不过还要枚举方向，那这个怎么枚举呢？  
我们只要枚举T型骨牌的中间点就好了，就是这个点：  
                          #..
                          #@#
                          #..
在T型骨牌的```@```点上，例如在一个```5*5```的矩阵内，我们要这样枚举，首先在边上肯定是不可能有中间点的存在的，那么我们就这样：  
从```2,2```开始枚举到```m-1,n-1```,然后我们就枚举，先在```2,2```号放上一个，移动到```2,3```，但是```2,3```放不了，怎么办，那么我们就移动到```2,4```，发现可以放了，就马上放，以此类推，最后走到```m-1,n-1```的下一个节点时，我们就用一个计数函数数一下图内的所有```@```符号，最后输出我们的结果，但是为了使用方便，不用手动打表，我们就用一个循环自动枚举所有的```9*9=81```种情况，然后以打表的方式输出就可以了
```
printf("dabiao[%d][%d]=%d;\n",i,j,work(i,j));
```
是不是很方便？
那么直接给出我的打表程序好了
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int dabiao[10][10];
int db()
{
	dabiao[1][1]=0;
	dabiao[1][2]=0;
	dabiao[1][3]=0;
	dabiao[1][4]=0;
	dabiao[1][5]=0;
	dabiao[1][6]=0;
	dabiao[1][7]=0;
	dabiao[1][8]=0;
	dabiao[1][9]=0;
	dabiao[2][1]=0;
	dabiao[2][2]=0;
	dabiao[2][3]=0;
	dabiao[2][4]=0;
	dabiao[2][5]=0;
	dabiao[2][6]=0;
	dabiao[2][7]=0;
	dabiao[2][8]=0;
	dabiao[2][9]=0;
	dabiao[3][1]=0;
	dabiao[3][2]=0;
	dabiao[3][3]=1;
	dabiao[3][4]=1;
	dabiao[3][5]=2;
	dabiao[3][6]=2;
	dabiao[3][7]=3;
	dabiao[3][8]=3;
	dabiao[3][9]=4;
	dabiao[4][1]=0;
	dabiao[4][2]=0;
	dabiao[4][3]=1;
	dabiao[4][4]=2;
	dabiao[4][5]=2;
	dabiao[4][6]=3;
	dabiao[4][7]=4;
	dabiao[4][8]=4;
	dabiao[4][9]=5;
	dabiao[5][1]=0;
	dabiao[5][2]=0;
	dabiao[5][3]=2;
	dabiao[5][4]=2;
	dabiao[5][5]=4;
	dabiao[5][6]=4;
	dabiao[5][7]=5;
	dabiao[5][8]=6;
	dabiao[5][9]=7;
	dabiao[6][1]=0;
	dabiao[6][2]=0;
	dabiao[6][3]=2;
	dabiao[6][4]=3;
	dabiao[6][5]=4;
	dabiao[6][6]=5;
	dabiao[6][7]=6;
	dabiao[6][8]=7;
	dabiao[6][9]=8;
	dabiao[7][1]=0;
	dabiao[7][2]=0;
	dabiao[7][3]=3;
	dabiao[7][4]=4;
	dabiao[7][5]=5;
	dabiao[7][6]=6;
	dabiao[7][7]=8;
	dabiao[7][8]=9;
	dabiao[7][9]=10;
	dabiao[8][1]=0;
	dabiao[8][2]=0;
	dabiao[8][3]=3;
	dabiao[8][4]=4;
	dabiao[8][5]=6;
	dabiao[8][6]=7;
	dabiao[8][7]=9;
	dabiao[8][8]=10;
	dabiao[8][9]=12;
	dabiao[9][1]=0;
	dabiao[9][2]=0;
	dabiao[9][3]=4;
	dabiao[9][4]=5;
	dabiao[9][5]=7;
	dabiao[9][6]=8;
	dabiao[9][7]=10;
	dabiao[9][8]=12;
	dabiao[9][9]=13;
}
int n,m;
int main()
{
	db();
	scanf("%d%d",&n,&m);
	printf("%d",dabiao[n][m]);
	while(1);	//防抄袭 
	return 0;
}
```
大家可以手动推一下，如果推不出可以看一下我的代码，也许你会恍然大悟，但是真正的打表程序还是要自己写了，本人只提供代码，以方便读者大大们检验推导的正确性

---

## 作者：Jorisy (赞：7)

这是我第一个 AC 的蓝题，整体还是有些难的。

---

这一题（也）是一道典型的深搜+模拟题。  
根据题目，其实我们可以将搜索范围缩小：由 $nm$ 缩小至 $(n-2)(m-2)$。  
但直接这样会导致第一点 RE，第八、九、十点 TLE。  
关于 RE：  
在 $n$ 或 $m$ 小于等于 $3$ 的时候，会造成栈溢出，因此需要特判：
```cpp
if(n<3||m<3)
{
	cout<<0;
	return 0;
}
```
关于 TLE：  
既然超时，那么肯定需要剪枝。我们可以用一个数组，`d[x][y]` 表示从头一直到 $[x,y]$，最多可以放多少个 T 型骨牌。在 $s$ 加一小于这个数时，则不做这个操作。  
AC Code：
```cpp
#include<bits/stdc++.h>
using namespace std;

int n,m,a[15][15],d[15][15],ans;

void dfs(int x,int y,int s)
{
	if(x==n)//边界条件
	{
		ans=max(ans,s);
		return;
	}
	if(!a[x-1][y-1]&&!a[x-1][y]&&!a[x-1][y+1]&&!a[x+1][y]&&!a[x][y])
	{
		a[x-1][y-1]=a[x-1][y]=a[x-1][y+1]=a[x+1][y]=a[x][y]=1;
		if(s+1>=d[x][y])
		{
			d[x][y]=max(d[x][y],s);
			if(y==m-1) dfs(x+1,2,s+1);
			else dfs(x,y+1,s+1);
		}
		a[x-1][y-1]=a[x-1][y]=a[x-1][y+1]=a[x+1][y]=a[x][y]=0;
	}
	if(!a[x+1][y-1]&&!a[x+1][y]&&!a[x+1][y+1]&&!a[x-1][y]&&!a[x][y])
	{
		a[x+1][y-1]=a[x+1][y]=a[x+1][y+1]=a[x-1][y]=a[x][y]=1;
		if(s+1>=d[x][y])
		{
			d[x][y]=max(d[x][y],s);
			if(y==m-1) dfs(x+1,2,s+1);
			else dfs(x,y+1,s+1);
		}
		a[x+1][y-1]=a[x+1][y]=a[x+1][y+1]=a[x-1][y]=a[x][y]=0;
	}
	if(!a[x-1][y-1]&&!a[x][y-1]&&!a[x][y+1]&&!a[x+1][y-1]&&!a[x][y])
	{
		a[x-1][y-1]=a[x][y-1]=a[x][y+1]=a[x+1][y-1]=a[x][y]=1;
		if(s+1>=d[x][y])
		{
			d[x][y]=max(d[x][y],s);
			if(y==m-1) dfs(x+1,2,s+1);
			else dfs(x,y+1,s+1);
		}
		a[x-1][y-1]=a[x][y-1]=a[x][y+1]=a[x+1][y-1]=a[x][y]=0;
	}
	if(!a[x-1][y+1]&&!a[x][y-1]&&!a[x][y+1]&&!a[x+1][y+1]&&!a[x][y])
	{
		a[x-1][y+1]=a[x][y-1]=a[x][y+1]=a[x+1][y+1]=a[x][y]=1;
		if(s+1>=d[x][y])
		{
			if(y==m-1) dfs(x+1,2,s+1);
			else dfs(x,y+1,s+1);
			d[x][y]=max(d[x][y],s);
		}
		a[x-1][y+1]=a[x][y-1]=a[x][y+1]=a[x+1][y+1]=a[x][y]=0;
	}//四种骨牌
	if(y==m-1) dfs(x+1,2,s);//换行
	else dfs(x,y+1,s);
}

int main()
{
	cin>>n>>m;
	if(n<3||m<3)//特判
	{
		cout<<0;
		return 0;
	}
	dfs(2,2,0);
	cout<<ans;
	return 0;
}
```

---

## 作者：让风忽悠你 (赞：4)

[原题](https://www.luogu.com.cn/problem/P1380)

## 题意

给出一个 $ n \times m $ 的矩阵，要求最多能放置多少个 $ T $ 形块。

一下为 $ T $ 型块样式：
```cpp
###      ..#      .#.      #..
.#.      ###      .#.      ###
.#.      ..#      ###      #..
```
## 做法

我们不难想到一个个地去放置，然后再取最大值。

如果你是这么写的，~~那么你就可以得到 60 的高分。~~

此时我们可以类比我们平时写的搜索，可以用一个二维数组记录走到当前点的最小花费。同理，我们也可以用一个二维数组来记录放置到当前点的最大花费，现在我们又会发现一个新的问题：不是每个 $ T $ 形块放下去后都能在一个一定的位置。

那么我们应该怎么办呢，~~其实我也不知道（~~，但是经过一番玄学的尝试后发现，通过判断当前步数 +1 是否小于 $step_{i,j}$（即上文提到的记录最大花费的数组）来决定是否接着放置。

## 代码

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#define N 15

using namespace std;

int n,m,ans;
int step[N][N];
bool vis[N][N];

inline void clear(){
	memset(vis,0,sizeof(vis));
	memset(step,0,sizeof(step));
}

void dfs(int x,int y,int cur){
	ans=max(ans,cur);
	if(cur+1<step[x][y]) return;
	step[x][y]=cur; 
	// 文中提到的玄学优化 
	for(int k=1;k<=4;k++){
		if(k==1){
			if(x+1>n || x+2>n || y-1<1 || y+1>m) continue;
			if(!vis[x+1][y] && !vis[x+2][y] && !vis[x][y-1] && !vis[x][y+1]){
				vis[x+1][y]=vis[x+2][y]=vis[x][y-1]=vis[x][y+1]=1;
				for(int i=1;i<=n;i++)
					for(int j=1;j<=m;j++)
						if(!vis[i][j])
							dfs(i,j,cur+1);
				vis[x+1][y]=vis[x+2][y]=vis[x][y-1]=vis[x][y+1]=0;
			}
		}
		else if(k==2){
			if(x-1<1 || x-2<1 || y-1<1 || y+1>m) continue;
			if(!vis[x-1][y] && !vis[x-2][y] && !vis[x][y-1] && !vis[x][y+1]){
				vis[x-1][y]=vis[x-2][y]=vis[x][y-1]=vis[x][y+1]=1;
				for(int i=1;i<=n;i++)
					for(int j=1;j<=m;j++)
						if(!vis[i][j])
							dfs(i,j,cur+1);
				vis[x-1][y]=vis[x-2][y]=vis[x][y-1]=vis[x][y+1]=0;
			}
		}
		else if(k==3){
			if(x-1<1 || x+1>n || y+1>m || y+2>m) continue;
			if(!vis[x+1][y] && !vis[x-1][y] && !vis[x][y+1] && !vis[x][y+2]){
				vis[x+1][y]=vis[x-1][y]=vis[x][y+1]=vis[x][y+2]=1;
				for(int i=1;i<=n;i++)
					for(int j=1;j<=m;j++)
						if(!vis[i][j])
							dfs(i,j,cur+1);
				vis[x+1][y]=vis[x-1][y]=vis[x][y+1]=vis[x][y+2]=0;
			}
		}
		else if(k==4){
			if(x-1<1 || x+1>n || y-1<1 || y-2<1) continue;
			if(!vis[x+1][y] && !vis[x-1][y] && !vis[x][y-1] && !vis[x][y-2]){
				vis[x+1][y]=vis[x-1][y]=vis[x][y-1]=vis[x][y-2]=1;
				for(int i=1;i<=n;i++)
					for(int j=1;j<=m;j++)
						if(!vis[i][j])
							dfs(i,j,cur+1);
				vis[x+1][y]=vis[x-1][y]=vis[x][y-1]=vis[x][y-2]=0;
			}
		}
		// 尝试放置各种形状 
	}
}

int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++){
			clear(); // 清空，防止影响以后判断 
			dfs(i,j,0);
		}
	printf("%d\n",ans);
	return 0;
} 
```


---

## 作者：KillerXu (赞：2)

这道题不考虑剪枝还是很好写的，放完一个后就搜索下一个能放的点，维护最大值就行。$n$或$m$小于$3$特判输出$0$。

然而会T 4个点。于是我开始尝试各种玄学的剪枝，最终发现只有这个方法可以AC：

用$f[i][j]$记录到$(i,j)$这个位置最多能放多少，如果$step+1<f[i][j]$就直接返回，但其实这个方法是存在一点问题的，所以会WA掉一个点，所以我们就再退一步，写成$step+2<f[i][j]$。

代码看着很长，但搜索那一段写完一个if可以复制粘贴，再改一改下标就可以了。

## Code

```cpp
#include <iostream>
#include <stdio.h>
#include <cstring>
#include <algorithm>

#define N 15

using namespace std;

int n , m;
int vis[N][N] , f[N][N];
int ans = 0;

void dfs(int , int , int);

void work(int);
			
int main(){
	cin >> n >> m;
	if(n < 3|| m < 3){cout << 0; return 0;}//特判
	for(int i = 1; i <= n; i++)
	 for(int j = 1; j <= m; j++){
	 	memset(vis , 0 , sizeof(vis));//初始化
	 	memset(f , 0 , sizeof(f));
		for(int x = 1; x <= n; x++) vis[x][0] = vis[x][m + 1] = 1;//把外面一圈都设为不能走，省的越界判断
		for(int x = 1; x <= m; x++) vis[0][x] = vis[n + 1][x] = 1;
	  	dfs(i , j , 0);
	  }
	  
	printf("%d" , ans);
	
	return 0;
}

void dfs(int x , int y , int step){
	//cout << x << " " << y << " " << step << "\n";
	if(ans < step) ans = step;//更新答案
	for(int k = 1; k <= 4; k++){
		if(k == 1){
			int flag = 0;
			if(!vis[x][y - 1]) flag++;//判断是否有足够的空间放下T
			if(!vis[x][y + 1]) flag++;
			if(!vis[x + 1][y]) flag++;
			if(!vis[x + 2][y]) flag++;
			if(flag == 4) vis[x][y - 1] = vis[x][y + 1] = vis[x + 1][y] = vis[x + 2][y] = 1; else continue;
			if(f[x][y] > step + 2) continue;//剪枝
			else if(f[x][y] < step) f[x][y] = step;//更新最大值
			work(step);
			vis[x][y - 1] = vis[x][y + 1] = vis[x + 1][y] = vis[x + 2][y] = 0;//回溯
		}
		if(k == 2){//k = 2,3,4的情况直接复制上面再简单改一改就行了
			int flag = 0;
			if(!vis[x + 1][y]) flag++;
			if(!vis[x - 1][y]) flag++;
			if(!vis[x][y - 1]) flag++;
			if(!vis[x][y - 2]) flag++;
			if(flag == 4) vis[x + 1][y] = vis[x - 1][y] = vis[x][y - 1] = vis[x][y - 2] = 1; else continue;
			if(f[x][y] > step + 2) continue;
			else if(f[x][y] < step) f[x][y] = step;
			work(step);
			vis[x + 1][y] = vis[x - 1][y] = vis[x][y - 1] = vis[x][y - 2] = 0;
		}
		if(k == 3){
			int flag = 0;
			if(!vis[x][y - 1]) flag++;
			if(!vis[x][y + 1]) flag++;
			if(!vis[x - 1][y]) flag++;
			if(!vis[x - 2][y]) flag++;
			if(flag == 4) vis[x][y - 1] = vis[x][y + 1] = vis[x - 1][y] = vis[x - 2][y] = 1; else continue;
			if(f[x][y] > step + 2) continue;
			else if(f[x][y] < step) f[x][y] = step;
			work(step);
			vis[x][y - 1] = vis[x][y + 1] = vis[x - 1][y] = vis[x - 2][y] = 0;
		}
		if(k == 4){
			int flag = 0;
			if(!vis[x + 1][y]) flag++;
			if(!vis[x - 1][y]) flag++;
			if(!vis[x][y + 1]) flag++;
			if(!vis[x][y + 2]) flag++;
			if(flag == 4) vis[x + 1][y] = vis[x - 1][y] = vis[x][y + 1] = vis[x][y + 2] = 1; else continue;
			if(f[x][y] > step + 2) continue;
			else if(f[x][y] < step) f[x][y] = step;
			work(step);
			vis[x + 1][y] = vis[x - 1][y] = vis[x][y + 1] = vis[x][y + 2] = 0;
		}
	}
}

void work(int step){
	for(int i = 1; i <= n; i++)//枚举下一个能放的点
	 for(int j = 1; j <= m; j++)
	  if(!vis[i][j]) dfs(i , j , step + 1);
}
```

---

## 作者：Arcturus1350 (赞：2)

表示不会剪纸真的不好玩啊……

用了一种玄学的方法A了这道题

首先对于$n,m$均$<3$的时候答案是$0$.这个嘛……因为T型的边长一定是>=3的啊

然后我们就爆搜，枚举每个位置填不填，能填的话就填上看看。

于是你会发现你t了最后4个点……

之后我的第一个剪枝:记录一下当前到这里最大的可以放多少，为$dis[x][y]$

如果再次搜到$(x,y)$,$dis[x][y]>cnt+1$就直接$return.$

然后你就能获得$90$分的好成绩。$wa\ on\ \# 8$

如果我们改成$cnt+2$,然而还是$90$分，$tle\ on\ \#10$

所以，最后，本人，当$dis[x][y]>cnt+2$的时候，以一定概率$(50\%)$做出是继续搜索，或者直接$return$于是$2897ms$->$53ms$

获得了$100$分的好成绩

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int num[10][10];
bool ins1[3][3] = { { 1 , 1 , 1 } , { 0 , 1 , 0 } , { 0 , 1 , 0 } };//上
bool ins2[3][3] = { { 0 , 0 , 1 } , { 1 , 1 , 1 } , { 0 , 0 , 1 } };//右
bool ins3[3][3] = { { 1 , 0 , 0 } , { 1 , 1 , 1 } , { 1 , 0 , 0 } };//左
bool ins4[3][3] = { { 0 , 1 , 0 } , { 0 , 1 , 0 } , { 1 , 1 , 1 } };//下
int mp[10][10];
int dis[10][10];
int n,m;
void debug ( ) { //调试用，输出mp矩阵
    for(int i=1;i<=n;i++,puts(""))
      for(int j=1;j<=m;j++)
        printf("%d ",mp[i][j]);
    puts("");
}
bool che1( int x , int y ) { //检查能不能在以x,y为左上角填一个上
    for(int i=0;i<3;i++)
      for(int j=0;j<3;j++)
        if(ins1[i][j]==1&&mp[i+x][j+y]==1) return false;
        else if(i+x>n||j+y>m) return false;
    return true;
}
bool che2( int x , int y ) {//右
    for(int i=0;i<3;i++)
      for(int j=0;j<3;j++)
        if(ins2[i][j]==1&&mp[i+x][j+y]==1) return false;
        else if(i+x>n||j+y>m) return false;
    return true;
}
bool che3( int x , int y ) {//左
    for(int i=0;i<3;i++)
      for(int j=0;j<3;j++)
        if(ins3[i][j]==1&&mp[i+x][j+y]==1) return false;
        else if(i+x>n||j+y>m) return false;
    return true;
}
bool che4( int x , int y ) {//下
    for(int i=0;i<3;i++)
      for(int j=0;j<3;j++)
        if(ins4[i][j]==1&&mp[i+x][j+y]==1) return false;
        else if(i+x>n||j+y>m) return false;
    return true;
}
void mark1( int x , int y ) {//标记，将mp涂上1
    for(int i=0;i<3;i++)
      for(int j=0;j<3;j++)
        mp[i+x][j+y]=ins1[i][j]|mp[i+x][j+y];
    return ;
}
void mark2( int x , int y ) {
    for(int i=0;i<3;i++)
      for(int j=0;j<3;j++)
        mp[i+x][j+y]=ins2[i][j]|mp[i+x][j+y];
    return ;
}
void mark3( int x , int y ) {
    for(int i=0;i<3;i++)
      for(int j=0;j<3;j++)
        mp[i+x][j+y]=ins3[i][j]|mp[i+x][j+y];
    return ;
}
void mark4( int x , int y ) {
    for(int i=0;i<3;i++)
      for(int j=0;j<3;j++)
        mp[i+x][j+y]=ins4[i][j]|mp[i+x][j+y];
    return ;
}
int ans;
void dfs ( int x , int y , int cnt ) {//dfs函数，
    if( x > n || y > m + 1) return ;//边界判断
    if( x == n && y == m + 1 ) {ans=max(ans,cnt);return ; }//到右下角
    if( y == m + 1 ) x ++ , y = 1 ;//换行
    bool book[3][3]={0,0,0,0,0,0,0,0,0};
    for(int i=0;i<3;i++)
      for(int j=0;j<3;j++)
        book[i][j]=mp[i+x][j+y];//记录原先矩阵

            // printf("%d %d %d\n",x,y,cnt);
            // debug();puts("");
            // for(int i=0;i<3;i++,puts(""))
            // for(int j=0;j<3;j++)
            // printf("%d ",mp[i+x][j+y]);puts("");
            // system("pause");

     if( dis[x][y] > cnt + 1 && rand()%2==1 ) return ;//一一定概率跳出，当dis[x][y] > cnt + 1的时候
     else if(dis[x][y]<cnt) dis[x][y]=cnt;//更新dis
    if( che1( x , y ) ) {mark1( x , y ); dfs( x , y + 1 , cnt + 1 );for(int i=0;i<3;i++)for(int j=0;j<3;j++)mp[i+x][j+y]=book[i][j];}//看看能不能填，填上，搜索下一步，回滚。
    if( che2( x , y ) ) {mark2( x , y ); dfs( x , y + 1 , cnt + 1 );for(int i=0;i<3;i++)for(int j=0;j<3;j++)mp[i+x][j+y]=book[i][j];}
    if( che3( x , y ) ) {mark3( x , y ); dfs( x , y + 1 , cnt + 1 );for(int i=0;i<3;i++)for(int j=0;j<3;j++)mp[i+x][j+y]=book[i][j];}
    if( che4( x , y ) ) {mark4( x , y ); dfs( x , y + 1 , cnt + 1 );for(int i=0;i<3;i++)for(int j=0;j<3;j++)mp[i+x][j+y]=book[i][j];}
    dfs( x , y + 1 , cnt );//不填
    return ;
}
void debug_pre() {//输出ins数组用。
    for(int i=0;i<3;i++,puts(""))
      for(int j=0;j<3;j++)
        printf("%d ",ins1[i][j]);puts("");

    for(int i=0;i<3;i++,puts(""))
      for(int j=0;j<3;j++)
        printf("%d ",ins2[i][j]);puts("");

    for(int i=0;i<3;i++,puts(""))
      for(int j=0;j<3;j++)
        printf("%d ",ins3[i][j]);puts("");

    for(int i=0;i<3;i++,puts(""))
      for(int j=0;j<3;j++)
        printf("%d ",ins4[i][j]);puts("");
    return ;
}
int main( ) {
    scanf("%d%d",&n,&m);//输入
     srand(n*m);
    dfs(1,1,0);//搜索
    printf("%d",ans);//输出答案
    return 0;
}
```

---

## 作者：__shadow__ (赞：1)

本题每个位置有 $5$ 种可能，据题中 $n,m$ 均小于五，所以可以用搜索直接过。

上代码
```cpp
#include<cstdio>
using namespace std;
bool mp[15][15];
int n, m, ans;
int dt[4][5][2] = {{{-1, -1}, {0, -1}, {1, -1}, {0, 0}, {0, 1}}, {{-1, 0}, {0, 0}, {1, -1}, {1, 0}, {1, 1}}, {{0, -1}, {0, 0}, {-1, 1}, {0, 1}, {1, 1}}, {{-1, 1}, {-1, 0}, {-1, -1}, {0, 0}, {1, 0}}};
void dfs(int sx, int sy, int sum)
{
		
	if (sx == n)
	{
		if (sum > ans)
			ans = sum;
		return ;
	}
	for (int i = 0;i < 4; i++)
	{
		bool flag = 1;
		for (int j = 0;j < 5; j++)
		{
			int vx = sx + dt[i][j][0], vy = sy + dt[i][j][1];
			if (mp[vx][vy] || vx < 1 || vx > n || vy < 1 || vy > m)
			{
				flag = 0;
				break;
			}
		}
		if (!flag)
			continue;
		for (int j = 0;j < 5; j++)
		{
			int vx = sx + dt[i][j][0], vy = sy + dt[i][j][1];
			mp[vx][vy] = 1;
		}
		if (sy == m - 1)
			dfs(sx + 1, 2, sum + 1);
		else
			dfs(sx, sy + 1, sum + 1);
		for (int j = 0;j < 5; j++)
		{
			int vx = sx + dt[i][j][0], vy = sy + dt[i][j][1];
			mp[vx][vy] = 0;
		}
	}
	if (sy == m - 1)
		dfs(sx + 1, 2, sum);
	else
		dfs(sx, sy + 1, sum);
}
int main()
{
	scanf ("%d%d", &n, &m);
	if (n < 3 || m < 3)
	{
		puts("0");
		return 0;
	}
	dfs(2, 2, 0);
	printf ("%d", ans);
	return 0;
}
```

这样交上去后会有 $3$ 点是 $T$ 的。

重审代码，发现在如下代码可以进行剪枝。
```cpp
		if (sy == m - 1)
			dfs(sx + 1, 2, sum + 1);
		else
			dfs(sx, sy + 1, sum + 1);
```
思考后发现只有现在的 $sum + 1$ 大于之前的值时，才有可能得到更大值。

AC代码便应运而生。
```cpp
#include<cstdio>
using namespace std;
bool mp[15][15];
int dmp[15][15];//dmp[i][j] 用来记载上次以 i,j 为中心方 T 的最大值。
int n, m, ans;
int dt[4][5][2] = {{{-1, -1}, {0, -1}, {1, -1}, {0, 0}, {0, 1}}, {{-1, 0}, {0, 0}, {1, -1}, {1, 0}, {1, 1}}, {{0, -1}, {0, 0}, {-1, 1}, {0, 1}, {1, 1}}, {{-1, 1}, {-1, 0}, {-1, -1}, {0, 0}, {1, 0}}};
//dt[i][j][k] 表示第 i 种方法的第 j 个点和中心点的坐标差, k = 0 代表行, k = 1 代表列。
void dfs(int sx, int sy, int sum)
{
	if (sx == n)
	{
		if (sum > ans)
			ans = sum;
		return ;
	}
	for (int i = 0;i < 4; i++)
	//枚举4种放法
	{
		bool flag = 1;
		for (int j = 0;j < 5; j++)
		//判断是否能放
		{
			int vx = sx + dt[i][j][0], vy = sy + dt[i][j][1];
			if (mp[vx][vy] || vx < 1 || vx > n || vy < 1 || vy > m)
			{
				flag = 0;
				break;
			}
		}
		if (!flag)
			continue;
		for (int j = 0;j < 5; j++)
		//标记
		{
			int vx = sx + dt[i][j][0], vy = sy + dt[i][j][1];
			mp[vx][vy] = 1;
		}
		if (sum + 1 >= dmp[sx][sy])
		{
			if (sum > dmp[sx][sy])
				dmp[sx][sy] = sum;
			if (sy == m - 1)
				dfs(sx + 1, 2, sum + 1);
			else
				dfs(sx, sy + 1, sum + 1);
		}
		for (int j = 0;j < 5; j++)
		//回溯
		{
			int vx = sx + dt[i][j][0], vy = sy + dt[i][j][1];
			mp[vx][vy] = 0;
		}
	}
	if (sy == m - 1)
		dfs(sx + 1, 2, sum);
	else
		dfs(sx, sy + 1, sum);
}
int main()
{
	scanf ("%d%d", &n, &m);
	if (n < 3 || m < 3)
	{
		puts("0");
		return 0;
	}
	dfs(2, 2, 0);
	printf ("%d", ans);
	return 0;
}

```
有错误欢迎私信指出

---

## 作者：iiiiiiiiiiiiiiiiiii (赞：0)

## 题目大意

题目已经说的够清楚了，不再说了。

## 算法

看到这一题，会先想到深搜。用 $vis_{i,j}$ 数组标记当前 $i,j$ 点有没有 T 型骨牌。枚举以当前点为中心的四个方向，计算答案即可。

但是这么做会 TLE，所以应该加一些记忆化剪枝。令 $f_{i,j}$ 表示搜到 $i,j$ 时，最多能放的个数。如果搜到这个点的最多能放的个数大于当前的个数加 $1$，则退出（加 $1$ 是保险起见，不加会 WA 掉一个点）。

## 高清无注释代码

```cpp
#include<algorithm>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iomanip>
#include<iostream>
#include<queue>
#include<string>
#include<vector>
using namespace std;
typedef long long LL;
const int INF=0x3f3f3f3f;
const int N=11;
const double eps=1e-5;
int read()
{
	char ch=getchar();
	int x=0,f=1;
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-48,ch=getchar();}
	return x*f;
}
int n,m,ans,vis[N][N],f[N][N];
void dfs(int x,int y,int k)
{
	if(f[x][y]>k+1)
		return;
	ans=max(ans,k);
	for(int i=2;i<n;i++)
		for(int j=2;j<m;j++)
		{
			if(!vis[i][j]&&!vis[i-1][j-1]&&!vis[i-1][j]&&!vis[i-1][j+1]&&!vis[i+1][j])
			{
				vis[i][j]=vis[i-1][j-1]=vis[i-1][j]=vis[i-1][j+1]=vis[i+1][j]=k+1;
				dfs(i,j,k+1);
				vis[i][j]=vis[i-1][j-1]=vis[i-1][j]=vis[i-1][j+1]=vis[i+1][j]=0;
			}
			if(!vis[i][j]&&!vis[i-1][j+1]&&!vis[i][j+1]&&!vis[i+1][j+1]&&!vis[i][j-1])
			{
				vis[i][j]=vis[i-1][j+1]=vis[i][j+1]=vis[i+1][j+1]=vis[i][j-1]=k+1;
				dfs(i,j,k+1);
				vis[i][j]=vis[i-1][j+1]=vis[i][j+1]=vis[i+1][j+1]=vis[i][j-1]=0;
			}
			if(!vis[i][j]&&!vis[i+1][j-1]&&!vis[i+1][j]&&!vis[i+1][j+1]&&!vis[i-1][j])
			{
				vis[i][j]=vis[i+1][j-1]=vis[i+1][j]=vis[i+1][j+1]=vis[i-1][j]=k+1;
				dfs(i,j,k+1);
				vis[i][j]=vis[i+1][j-1]=vis[i+1][j]=vis[i+1][j+1]=vis[i-1][j]=0;
			}
			if(!vis[i][j]&&!vis[i-1][j-1]&&!vis[i][j-1]&&!vis[i+1][j-1]&&!vis[i][j+1])
			{
				vis[i][j]=vis[i-1][j-1]=vis[i][j-1]=vis[i+1][j-1]=vis[i][j+1]=k+1;
				dfs(i,j,k+1);
				vis[i][j]=vis[i-1][j-1]=vis[i][j-1]=vis[i+1][j-1]=vis[i][j+1]=0;
			}
		}
	f[x][y]=max(f[x][y],k);
}
int main()
{
	n=read(),m=read();
	dfs(2,2,0);
	printf("%d ",ans);
	return 0;
}
```


---


# 方阵安排

## 题目描述

A 班希望在学校的行军比赛中取得一个好成绩，他们希望自己班级的行军方阵是一个完美的方阵。他们认为，如果每个人四周的男生个数为偶数，那么这就是一个完美的方阵。

现在你已知道 A 班现有的方阵，你需要把尽量少的女生改成男生，使这个方阵变成一个完美的方阵。


## 说明/提示

#### 输入输出样例 1 解释

将方阵改为

```
0 1 0
1 0 1
0 1 0
```

---

#### 数据规模与约定

对于 $40\%$ 的数据，保证 $n \leq 6$。

对于 $100\%$ 的数据，保证 $1 \leq n \leq 18$。


## 样例 #1

### 输入

```
3
0 0 0
1 0 0
0 0 0
```

### 输出

```
3```

# 题解

## 作者：Cet6_427 (赞：21)

一、 40分做法

很容易想到枚举矩阵中的每一个数判断其变还是不变，最后判断整个矩阵是否满足条件。但是会TLE，只能过掉40%的数据...


二、100分做法

N的范围只有18，所以第一行只有不超过2^18种可能性，是我们可以枚举的，接下来我们可以根据第一行计算出第二行，再根据第二行又能计算出第三行以此类推……

最后的时间复杂度为O(2^n \* n ^ 2)可以承受...





    
    
    


```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <vector>
#include <cmath>
#include <iterator>
#define LL long long
#define mem(a, b) memset(a, b, sizeof(a))
#define rep(i, a, b) for(int i = (a); i <= (b); i++)
using namespace std;
const int maxn = 20;
const int INF = 10000000000;
int N, A[maxn][maxn], B[maxn][maxn];
int query(int cur){
    mem(B, 0);
    rep(j, 0, N-1){
        if(cur & (1<<j)) B[0][j] = 1;
        else if(A[0][j] == 1) return INF;
    }
    rep(i, 1, N-1) rep(j, 0, N-1){
        int sum = 0;
        if(i > 1) sum += B[i-2][j];
        if(j > 0) sum += B[i-1][j-1];
        if(j < N-1) sum += B[i-1][j+1];
        B[i][j] = sum % 2;
        if(A[i][j] == 1 && B[i][j] == 0) return INF;
    }
    int cnt = 0;
    rep(i, 0, N-1) rep(j, 0, N-1)
        if(A[i][j] != B[i][j]) cnt++;
    return cnt;
}
int main(){
    scanf("%d", &N);
    rep(i, 0, N-1) rep(j, 0, N-1) scanf("%d", &A[i][j]);
    int ans = INF;
    rep(i, 0, (1<<N)-1) ans = min(ans, query(i));
    if(ans == INF) ans = -1;
    printf("%d\n", ans);
    return 0;
}

```

---

## 作者：fls233666 (赞：3)

看到这道题，我们可以先想到简单粗暴的算法：枚举每个 $0$ 的位置是否修改为 $1$，然后用 $O(n^2)$ 的时间暴力检查方阵是否完美。加上适当的剪枝后，这个算法应该能通过 $N \le 6$ 的部分。但是遇到 $N \le 18$ 的部分就超时了。

考虑如何进一步优化。我们发现，时间主要浪费在“枚举每个 $0$ 的位置是否修改”这个过程。因为 $0$ 的位置数量接近 $N^2$，总的枚举情况就有了 $2^{N^2}$ 种，无法接受。但是，**我们真的要遍历整个方阵中所有 $0$ 的位置吗？**

我们考虑换一种思维方式。我们能否枚举出所有的完美的方阵，然后检查输入的初始方阵能否变换到这个方阵，并花费尽可能少的步数？

如果还是一个一个位置去枚举整个方阵，这样还是会超时。但是，如果我们能**枚举出方阵的一部分，通过这一部分来确定整个方阵，** 我们就可以极大地节省我们花费的时间。

我们考虑方阵中的一个格子 $(x,y)$，它的四周的四个格子是 $(x+1,y),(x-1,y),(x,y+1),(x,y-1)$。当这四个格子中的三个确定了，为了满足四周 $1$ 的数量为偶数，最后一个格子是 $0$ 还是 $1$ 也能确定。那么就有了两种方案：

- 当格子 $(x+1,y),(x-1,y),(x,y-1)$ 都确定了，可以推出格子 $(x,y+1)$ 的状况。那么初始情况要枚举 $(x,1),x \in [1,n]$ 这些格子的情况。即枚举第一行的状况进而确定整个方阵的状况。

- 当格子 $(x,y+1),(x-1,y),(x,y-1)$ 都确定了，可以推出格子 $(x+1,y)$ 的状况。那么初始情况要枚举 $(1,y),y \in [1,n]$ 这些格子的情况。即枚举第一列的状况进而确定整个方阵的状况。

因为 $N \le 18$，一行或者一列只有 $2^N$ 中情况。推出整个方阵并计算答案只需要 $O(N^2)$ 的时间，总的时间复杂度为 $O(2^N \times N^2)$。

通过确定第一行推出整个矩阵的代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define rgt register int
#define qmn(a,b) a<b?a:b
using namespace std;

int n,ans=1010;  //18*18=324<1010，所以答案不可能达到 1010，如果枚举后 ans 值没有改变就是无解
int mtx[20][20],inx[20][20];
int fx[4]={1,-1,0,0};
int fy[4]={0,0,-1,1};

void dfs(int xi,int g){

	if(xi>n){
		int tans=g;  //记录第一行变换的位置数
		for(rgt i=1;i<n;i++){
			for(rgt c,j=1;j<=n;j++){
				c=0;
				for(rgt tx,ty,k=1;k<4;k++){
					tx=i+fx[k];
					ty=j+fy[k];
					if(tx>=1&&ty>=1&&tx<=n&&ty<=n){
						if(mtx[tx][ty])
							c++;
					}
				}  //统计周围三个位置上 1 的数量
				if(c%2){  //确定下一行的对应位置上是 1
					mtx[i+1][j]=1;
					if(!inx[i+1][j])  //与初始矩阵不同
						tans++;  //变换位置数+1
				}
				else{  //确定下一行对应位置上是 0
					mtx[i+1][j]=0;
				    if(inx[i+1][j])  //因为 1 不能变换为 0，此方案不可行
						return;
				}
			}
		}
		ans=qmn(ans,tans);  //取最小变换次数作为答案
		return;
	}
    
	mtx[1][xi]=inx[1][xi];  //得到初始矩阵的第一行
	dfs(xi+1,g);  //不变换
	if(!mtx[1][xi]){  //变换
		mtx[1][xi]=1;
		dfs(xi+1,g+1);
		mtx[1][xi]=0;
	}
}

int main(){
	scanf("%d",&n);
	for(rgt i=1;i<=n;i++)
		for(rgt j=1;j<=n;j++)
			scanf("%d",&inx[i][j]);
            
	dfs(1,0);
	if(ans==1010)
		printf("-1");
	else
		printf("%d",ans);
        
	return 0;
}
```


---

## 作者：Utilokasteinn (赞：3)

# [P1391 方阵安排](https://www.luogu.com.cn/problem/P1391)

题目简介（魔改）：

给一个 $n\times n$ 的 $01$ 矩阵，使每个数的上下左右的 $1$ 的个数为偶数，求至少要把多少个 $0$ 改成 $1$。

看到这个题目很多人可能第一时间想到的是爆搜一遍，找出最小的方案。但这样时间复杂度为 $O(2^{(n^2)})$ （应该是吧，雾），但这样就算是在每次深搜的时候判断是否要下去也会超时。

但是我们可以先深搜枚举第一行的状态。假设一下是枚举出来的状态（$n=5$ 为例）：
```cpp
1 0 0 1 0
```

然后来到第二行的第一个，可以发现只能是女生（$0$ 也是偶数）。到了第二行的第二个，男女都可以选，因为题目要求改变最少，所以选择最开始输入的那个矩阵的那个数，以此推类到最后一个。

这样时间复杂度就约等于 $O(2^n\times n^2)$ ，可以过此题。

由于这道题是一个 $01$ 矩阵，所以可以用 $bool$ 类型来装，而一个数旁边 $1$ 的个数只需要判断是奇还是偶，所以也可以用 $bool$ 来装。

附上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
bool a[20][20],b[20][20];
int nx[4]={1,-1},ny[4]={0,0,1,-1};
int minn=1e9,cnt,n;
void dfs2(int x,int y)
{
	if(y>n)//到达每一行的最后一个 
	{
		dfs2(x+1,1);//到下一层读第一个 
		return;
	}
	if(x>n)//到达最后一层 
	{
		int sum=0;
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				if(b[i][j])return;//如果哪个人不符合条件，就返回 
				else if(a[i][j])sum++;//计算男生数量 
		minn=min(minn,sum-cnt);
		return;
	}
	if(b[x-1][y]&&!a[x][y])//如果正上方的人旁边只有奇数个男生 
	{//且当前位置原来是个女生
	//把这个女生变男生就可以让上面的人有偶数个男生 
		a[x][y]=1;//这个女生变男生 
		for(int i=0;i<4;i++)
			b[x+nx[i]][y+ny[i]]=!b[x+nx[i]][y+ny[i]];//偶变奇，奇变偶 
		dfs2(x,y+1);//往下搜一个人 
		for(int i=0;i<4;i++)
			b[x+nx[i]][y+ny[i]]=!b[x+nx[i]][y+ny[i]];
		a[x][y]=0;//回溯时复原 
	}
	else if(!b[x-1][y])dfs2(x,y+1);
	//如果已经有偶数个男生了，那么就直接下一个，越少改动越好嘛 
}
void dfs1(int x)
{
	if(x==n+1)//如果到达了第一行的最后一个 
	{
		dfs2(2,1);//就开始搜第二行 
		return;
	}
	dfs1(x+1);
	if(a[1][x])return;
	a[1][x]=1;//女变男 
	for(int i=0;i<4;i++)
		b[1+nx[i]][x+ny[i]]=!b[1+nx[i]][x+ny[i]];
	dfs1(x+1);//向下搜一个人 
	for(int i=0;i<4;i++)
		b[1+nx[i]][x+ny[i]]=!b[1+nx[i]][x+ny[i]];
	a[1][x]=0;//回溯时复原 
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
		{
			cin>>a[i][j];
			if(a[i][j])
			{
				cnt++;
				for(int k=0;k<4;k++)
					b[i+nx[k]][j+ny[k]]=!b[i+nx[k]][j+ny[k]];
					//真代表奇数个男生，假代表偶数个男生 
			}
		}
	dfs1(1);
	if(minn==1e9)cout<<-1;
	else cout<<minn;
	return 0;
}
```
因为多处出现偶变奇，奇变偶的代码，所以可以写一个函数来简化，简化后的代码就放[这里](https://www.luogu.com.cn/paste/in5go0c8)了，吸了氧快到飞起。

谢谢观赏。

---

## 作者：Enterpr1se (赞：2)

emm 为什么题解区大佬都不愿意用状压啊……

------------
看到这题的数据范围：  
+ 对于 $100 \%$ 的数据，保证 $n \leq 18$。  

而众所周知，`int` 类型的变量可以存储 32 位带符号整数（去除符号位共 31 位）。也就是说，在这题中，我们甚至不需要 `long long` 就能将题目中方阵的一行塞到一个变量里（状态压缩）。   
思路和其他几篇题解大致相同，但是貌似细节上还是不太一样，并且我的码量介于题解区另外两位大佬之间。  
思路简述：  
1. 枚举第一行可能出现的所有状态（状态压缩）   
2. 对于每一种状态：
	1. 验证其是否合法，若其不合法则直接进入下一种状态
   2. 若其合法，则使用一个循环，数出从原方阵的第一行转移到此状态所需要的步骤
   3. 对其进行深度优先搜索：
   		1. 根据传入的状态推导出下一行（程序里有详细过程）
      2. 在下一行重复此过程
      
对于这个思路，我们需要考虑一个问题：什么样的状态是不合法的？  
很显然，题目中有明确表述，女生可以改~~♂~~成男生，但是男生不能改~~♂~~成女生。~~（女拳震怒~~  
还是结合程序说实际一些：
```cpp
//Luogu-P1391 
//Luogu @Enterpr1se (Userid 363523)
//@_Qijia (Userid 363524) AK IOI!
#include<cstdio>
#define regll register long long
#define regint register int
#define regshort register short
#define _Qijia using
#define AK namespace
#define IOI std
_Qijia AK IOI;
int n,mp[20],temp,ans=0x7fffaded,sstep;
bool flag;
int bin_digit(int num,int id){//获取一个二进制数的第 id 位（最低位为第0位） 
	return ((num&(1<<id))>>id);
}
int min(int a,int b){
	return a<b?a:b;
}
void dfs(int id,int currln,int curstep,int prevln=0){
	if(id==n){//如果已经扫过整个方阵，并且没有出现不合法状态 
		ans=min(ans,curstep);//更新答案 
		return;
	}
	int surmal/*一个人周围已有的男生数*/,nextln=0/*下一行的状态*/,nstep=0/*到下一行为止总共的换人次数*/;
	for(regint i=1;i<=n;++i){
		surmal=bin_digit(currln,i-1)+bin_digit(currln,i+1)+bin_digit(prevln,i);//一个人周围的总男生数 = 左边 + 右边 + 上一行同一位置男生数 
		nextln+=((surmal&1)<<i);//更新状态（将新一位加入到下一行的状态中） 
		if((bin_digit(mp[id+1],i)^bin_digit(nextln,i))){//如果下一行该位置需要的人与原方阵中此位置的人性别不同 
			++nstep;//增加一次换人 
			if(bin_digit(mp[id+1],i))/*若原方阵中此位置是男生*/ return;
		}
	}
	dfs(id+1,nextln,curstep+nstep,currln);//从下一行开始搜索 
	return;
}
signed main(){
	scanf("%d",&n);
	for(regint i=1;i<=n;++i)
		for(regint j=1;j<=n;++j,mp[i]<<=1)
			scanf("%d",&temp),mp[i]+=temp;//将新输入的一位加在末尾 
	for(regint i=0;i<(1<<(n+1));i+=2){//枚举第一行所有状态 
		sstep=0;//初始化 
		flag=true;
		for(regint j=1;j<=n;++j){//检查状态是否合法 并 算出第一行换人次数 
			if((bin_digit(mp[1],j)^bin_digit(i,j))){//类似于 Ln29 至 Ln32 
				++sstep;
				if(bin_digit(mp[1],j)){
					flag=false;
					break;
				}
			}
		}
		if(flag) dfs(1,i,sstep);//如果状态合法 
	}
	printf("%d",((ans^0x7fffaded)?ans:-1));
	return 0;
}
```
注：这题的状压看着有些奇怪，因为我决定将二进制数的最低位留空（永远为 0），这样在获取二进制数某一位的时候更加方便。例如样例中第二行，在本程序中存储为 $ 1000_2 $。  
$\mathtt{Thanks}\text{ }\mathtt{for}\text{ }\mathtt{reading.}\text{ }$

---

## 作者：MerlinLee (赞：1)

极其好的一道题！！！

第一反应是 BFS。

但是，我们又发现，只要第一行确定了，后面的数字就可以递推出来。

所以 keypoint 就是：

只用枚举第一行的所有可能即可，但是要注意 check 矛盾的情况（也就是男生不能改变）。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[19][19],b[19][19];
int main()
{
	ios::sync_with_stdio(false);
	cin>>n;
	for(int i=1;i<=n;i++)
	  for(int j=1;j<=n;j++)
		cin>>a[i][j];
	int minn=INT_MAX;
	for(int k=0;k<=(1<<n)-1;k++) 
	{
		int cnt=0;
		memset(b,0,sizeof(b));
		for(int i=1;i<=n;i++)
		{
			if(k&(1<<(n-i)))
			  b[1][i]=1;
			else 
			  b[1][i]=0;
		}
		int flag=1;
		for(int i=1;i<=n;i++)
		  if(a[1][i]==1&&b[1][i]==0)
	  	  {
		  	  flag=0;
			  break;
		  }
		if(!flag)
		  continue;
		for(int i=2;i<=n;i++)
		  for(int j=1;j<=n;j++)
		  {
		  	  if(a[i][j]==1)
				b[i][j]=1;
			  else
			  {
				  if((b[i-1][j-1]+b[i-1][j+1]+b[i-2][j])%2!=0)
					b[i][j]=1;
			 	  else 
				    b[i][j]=0;
			  }
		  }
		flag=1;
		for(int i=1;i<=n;i++)
		  for(int j=1;j<=n;j++)
		  {
		  	  if((b[i-1][j]+b[i+1][j]+b[i][j-1]+b[i][j+1])%2!=0)
			  {
			 	  flag=0;
				  break;
			  }
		  }
		if(flag)
		{
			for(int i=1;i<=n;i++)
			  for(int j=1;j<=n;j++)
				if(b[i][j]!=a[i][j])
				  cnt++;
			minn=min(minn,cnt);
		}
	}
	if(minn==INT_MAX)
	  cout<<"-1\n";
	else 
	  cout<<minn<<"\n";
	return 0;
}
```

---

## 作者：YangRuibin (赞：0)

## 序言

其实，这道题只需要搜索并剪枝就能过，甚至跑得比一些人打的状压还快。~~可以自己翻翻本题的提交记录。~~

## 正文

### 暴力

就是从坐标 $(1,1)$ 到 $(n,n)$ 不停枚举每个女生是否变成男生。

### 剪枝

1. 可行性剪枝。

    就是当前选择是否符合“上下左右的男生个数为偶数”。不符合就剪掉。

    注意，因为只有确定当前选择才能判断，所以上一行的可行性只有选了下一行才能判断，左边的可行性只有选了右边的才能判断。简单来说就是在决定完 $(i,j)$ 后才能判断 $(i-1,j-1)$。

2. 最优性剪枝。

   就是如果当前已经确定至少用的步数已经比当前最优解大，就剪掉。可以在递归传参时记录当前步数。

### 坑点

题面中“每个人四周的男生个数”指的**是**每个点正上方、正下方、正左方、正右方四个点，而**不**是以该点为中心九宫格外圈的八个。我为此调了两个小时。
## 代码（极简）

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=25;
int n,a[N][N],v[N][N],ans=1e9;
int check(int x,int y)
{
	return (a[x-1][y]^v[x-1][y])+(a[x][y-1]^v[x][y-1])+(a[x][y+1]^v[x][y+1])+(a[x+1][y]^v[x+1][y]);
}
void dfs(int x,int y,int mn)
{
	if(mn>=ans)return;//最优性剪枝
	if(x>n)
	{
		for(int i=1;i<=n;i++)if(check(n,i)&1)return;
		ans=min(ans,mn);return;
	}
	v[x][y]=0;
	if(!(x>1&&y>1&&(check(x-1,y-1)&1))&&!(x>1&&y==n&&(check(x-1,y)&1)))//可行性剪枝，符合条件才搜
	{
		if(y<n)dfs(x,y+1,mn);else dfs(x+1,1,mn);
	}
	if(a[x][y]==0)
	{
		v[x][y]=1;
		if(!(x>1&&y>1&&(check(x-1,y-1)&1))&&!(x>1&&y==n&&(check(x-1,y)&1)))//可行性剪枝，符合条件才搜
		{
			if(y<n)dfs(x,y+1,mn+1);else dfs(x+1,1,mn+1);
		}
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)scanf("%d",a[i]+j);
	dfs(1,1,0);
	if(ans==1e9)printf("-1");
	else printf("%d",ans);
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/167894664)

---

## 作者：dyc2022 (赞：0)

一个显而易见的结论：

我们可以通过第一行的状态，推出所有其他行的状态。

设我们已经处理好了前 $i-1$ 行的状态，则我们可以确定第 $i-1$ 行第 $j$ 个格子正上方、正左方、正右方的格子中有多少个 `1`。我们可以根据这个数值的奇偶性推出第 $i$ 行第 $j$ 个格子的状态。

因此，我们可以只要枚举第一行的状态，复杂度 $O(2^n)$，允许范围内。

具体实现：使用二进制数进行操作，设一个 `geti` 函数，读取整数 $x$ 在二进制状态下的第 $i$ 位。

AC 代码：

```cpp
#include<bits/stdc++.h>
#define int long long
#define geti(x,i) ((x>>(i-1))&1)
using namespace std;
int n,a[20][20],ans=0x3f3f3f3f,cnt;
void dfs(int x,int last,int now)
{
	if(x>n)
	{
		ans=min(ans,cnt);
		return;
	}
	if(cnt>=ans)return;
	int New=0,old=cnt;
	for(int i=1;i<=n;i++)
		if(!geti(now,i)&&a[x][i])return;
	for(int i=1;i<=n;i++)
		if(geti(now,i)&&!a[x][i])cnt++;
	for(int i=1;i<=n;i++)
	{
		int tmp=0;
		if(i>1)tmp+=geti(now,i-1);
		tmp+=geti(last,i);
		if(i<n)tmp+=geti(now,i+1);
		if(tmp&1)New|=1<<(i-1);
	}
	dfs(x+1,now,New);
	cnt=old;
}
main()
{
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)scanf("%lld",&a[i][j]);
	for(int i=0;i<(1<<n);i++)
	{
		dfs(1,0,i);
	}
	if(ans!=0x3f3f3f3f)printf("%lld",ans);
	else printf("-1");
	return 0;
}
```

---

## 作者：Genius_Star (赞：0)

### 题意概述：

在一个 $n \times n$ 的方阵中，每个格子内有一个人，其性别为男或女。现在需要把一些女性改为男性，使得每个人周围的男性数量都是偶数，求出最少需要改变的女性数量。

如果无法做到这一点，输出 $-1$。
### 题目分析：

本题是一道经典的搜索题，需要寻找一种方法，使得女生最少。本题的思路可以用搜索来考虑，我们可以使用深度优先搜索（DFS）或广度优先搜索（BFS）。

我们首先可以发现，对于每个人，他的四周有多少个男生是给定的，因此我们可以通过枚举女生，来逐一判断是否可以满足要求，然后不停地枚举，直到我们找到一个方案，使得所有人四周都是偶数个男生。

对于每个女生，我们都假设她变成了男生，并检查是否满足要求，如果满足，我们就继续往下搜索，否则我们就继续枚举下一个女生，直到所有的女生都被枚举过。

这种方法虽然会枚举很多女生，但是如果女生很多，我们可以通过剪枝来减少枚举的数量。我们可以通过记录当前方阵中男生的个数和女生的个数，来判断是否需要继续搜索，如果当前方阵中男生的个数已经超过了女生的个数，那么我们就可以停止搜索，因为我们没有任何机会将所有女生都变成男生。

时间复杂度：$O(2^n \times n^2)$。
### 完带代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=23;
const int inf=0x3f3f3f3f;
int n,mn=inf;
int sum[maxn][maxn],a[maxn][maxn];
int dx[]={0,-1,0,0,1},dy[]={0,0,-1,1,0};
inline void flip(int x,int y){
    a[x][y]^=1;
	for (int i=1;i<=4;i++){
		int xx=x+dx[i],yy=y+dy[i];
		if (xx<1 || xx>n || yy<1 || yy>n) continue;
		if (a[x][y]) sum[xx][yy]++;
		else sum[xx][yy]--;
	}
}
inline void dfs(int x,int y,int now){
	if (x>n) mn=min(mn,now);
	else if (x==1){
		if (y+1>n) dfs(x+1,1,now);
		else dfs(x,y+1,now);
		if (a[x][y]) return ;
		flip(x,y);
		if (y+1>n) dfs(x+1,1,now+1);
		else dfs(x,y+1,now+1);
		flip(x,y);
	}else if (x==n && y>1){//y>1
		if ((sum[x-1][y]&1)^(sum[x][y-1]&1)) return ;
		if (sum[x-1][y]&1){
			if (a[x][y]) return ;
			flip(x,y);
			if (y+1>n) dfs(x+1,1,now+1);
			else dfs(x,y+1,now+1);
			flip(x,y);
		}else{
			if (y+1>n) dfs(x+1,1,now);
			else dfs(x,y+1,now);
		}
	}else{
		if (sum[x-1][y]&1){
			if (a[x][y]) return ;
			flip(x,y);
			if (y+1>n) dfs(x+1,1,now+1);
			else dfs(x,y+1,now+1);
			flip(x,y);
		}else{
			if (y+1>n) dfs(x+1,1,now);
			else dfs(x,y+1,now);
		}
	}
}
int main(){
	scanf("%d",&n);
	for (int i=1;i<=n;i++) for (int j=1;j<=n;j++) scanf("%d",&a[i][j]);
	for (int i=1;i<=n;i++){
	    for (int j=1;j<=n;j++){
	        for (int k=1;k<=4;k++){
	            int xx=i+dx[k],yy=j+dy[k];
	            if (xx<1 || xx>n || yy<1 || yy>n) continue;
	            if (a[i][j]) sum[xx][yy]++;
	        }
	    }
	}
	dfs(1,1,0);
	if (mn==inf) printf("-1\n");
	else printf("%d\n",mn);
	return 0;
}
```

---


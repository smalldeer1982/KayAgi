# 买蛋糕

## 题目描述

野猫过生日，大家当然会送礼物了（咳咳，没送礼物的同志注意了哈！！），由于不知道送什么好，又考虑到实用性等其他问题，大家决定合伙给野猫买一个生日蛋糕。大家不知道最后要买的蛋糕的准确价格，而只会给蛋糕估价，即要买一个不超过多少钱的蛋糕。众 OIer 借此发挥：能否用最少的钱币数去凑成估价范围内的所有价值，使得不管蛋糕价值多少，都不用找钱……

现在问题由此引出：对于一个给定的 $n$，能否用最少的不等的正整数去组成 $n$ 以内（包括 $n$）的所有的正整数呢？如果能，最少需要多少个正整数，用最少个数又有多少不同的组成方法呢？


## 说明/提示

最少用三个数，有两种方法，分别是：$1,2,3$ 和 $1,2,4$。

- 对于 $1,2,3$ 有 $1,2,3$，$1+3$，$2+3$，$1+2+3$；
- 对于 $1,2,4$ 有 $1$，$2$，$1+2$，$4$，$1+4$，$2+4$。

 
 

## 样例 #1

### 输入

```
6
```

### 输出

```
3 2
```

# 题解

## 作者：ButterflyDew (赞：7)

- 首先明确第一个问题：这个最小的正整数是多少？

也许你可以打表看出来，也许不能，但别急，我们有~~看似~~靠谱一点的思维方法

看看样例：6

可行方案：

①$1$ $2$ $3$;

②$1$ $2$ $4$.

我们发现，对于方案①，组成3的时候有两种方法（1+2或3），而方案②只有一种。换而言之，3的利用是有**浪费的**。而不浪费的方案②还可以组成7。

那么，我们咋让她(每个数)都用好自己呢

~~很简单，百合就行了~~

联想一下二进制位下的数

$1$,$10$,$11$,$100$,$101$,$110$,$111$,$1000$...

可不是嘛，这个$2^i$的每个数利用率可高了

由此可知，**二进制的位数即为这个最小的正整数**。

------------
想明白第一问以后，应该给出了一个相对的第二问的思维导向。（当然不绝对哈）

当每个数的利用率最大的时候，她们能够凑成的最大整数即为她们的和，这点是毋庸置疑的。

那么，在利用率相对不是那么大的时候呢？

我们注意到，此时已经有了一个限制条件：**已有的最小正整数**

手动模拟一下，确实是仍然成立的。（其实是不太会证啦）

这时候，我们就把参与量**已使用的各数之和**和**凑成的最大整数**搞到一起去了

考虑$dp[k]$代表凑成时$k$的方案数。看看这时候还要压哪些信息进去。

~~显然~~，剩下的必要信息还有第$i$个数和第$i$个数的值$j$

$dp[i][j][k]$表示已选$i$个数，第$i$个数为$j$，前$i$个数和为$k$（凑成的最大整数位$k$）的时候的方案数

**转移方程** $dp[i+1][l][k+l]+=dp[i][j][k];$

其中$l$为枚举的下一个填充数

核心代码：

```cpp
    dp[1][1][1]=1;
    for(int i=1;i<ans;i++)
        for(int j=i;j<=(1<<(i-1));j++)
            for(int k=i*(i-1)/2;k<(1<<i);k++)
                for(int l=j+1;l<=k+1;l++)
                    if(l+k<=n)
                        dp[i+1][l][k+l]+=dp[i][j][k];
                    else
                        dp[i+1][l][n]+=dp[i][j][k];
```

注意$j,k,l$的上下界，都是被已经得到的**第一问给约束住了**

当然，也没必要跑这么死，比如$k$从$i$开始反而会快一些。

至于$if$和$else$的判断，是为了方便求最后结果的一点点小贪心了。

---

## 作者：无尽 (赞：7)

为什么没有c++的题解

这是一个用搜索（而不是dp）来写的

和楼上一样 ，总数用log2n求出

之后是搜索

感觉和邮票问题差不多

上代码&&注释

```cpp
#include <bits/stdc++.h>
using namespace std;
long long int n,ans;
int x,y=0;
int search(long long int geshu,long long int he,long long int ziweida)
{//geshu是个数，he是和，ziweida是最大值
    long int i;
        if(geshu+1==y)//如果搜到的个数到了最小个数，那么判断 
        {
                if(he*2+1>=n)//如果可以组成>=n的数 
                {
                        if(he+ziweida+1>=n) ans+=he-ziweida+1;//如果最大值>n了 
                        else ans+=he*2+2-n;//不然... 
                }
                return 0;
        }
        for(i=ziweida+1;i<=he+1;i++) search(geshu+1,he+i,i);//深搜下一步 
}
int main()
{
        cin>>n;
        for(int x=1;x<=n;x*=2) y++;//求总方案数 
        search(0,0,0);//搜索... 
        cout<<y<<" "<<ans;
        return 0;
}
```

---

## 作者：XL4453 (赞：5)

------------
解题思路：

首先考虑第一问，求最少要多少种钱币。

读题可知，每种钱币只有一枚。然后就可以想到二进制，即将钱币的值设为 $2^n$ ，将要表示的数转换为二进制，每一位表示是否用这个钱币。

对于其正确性，首先可以得出二进制一定可以表示出任何数。然后就是证明没有任何一种方法可以用比二进制更少的钱币数来表示出所有的估价。

考虑拿走 $2^n$ 然后证明其一定不能在只修改而不添加数的前提下表示出 2 到 $2^{n+1}-1$ 。首先在拿走 $2^n$ 之后，不做任何修改，那么之前的数一定无法表示 $2^n$ 到 $2^{n+1}-1$ 那么就一定要有一个数扩大到能表示这一区间，这里如果能，那么一定只能扩大 $2^{n-1}$ ，因为如果扩大别的数那么一定会出现不能表示比 $2^{n-1}$ 还小的某一些数，而且还会有“断层”（感性理解，即有在区间中有一小部分数无法表示，可以由二进制的性质导出）。那么在扩大了$2^{n-1}$之后，一定又会出现无法表示 $2^{n-2}$ 到 $2^{n-1}-1$的问题。以此类推，最终得到无法去除任何一个数的结论。

补充说明一下，如果区间没有正好到 $2^{n+1}-1$ ,那么就把这个改成区间的最大值，同样可以推出结论，因为依旧有一段无法表示，所以一定要改。（文字证明，有些表述不太严谨，望指出。）

这一段证明不少题解没有提及，这里做一个补充。

------------

然后是第二问：求有多少种方案。

这一问方法很多（仿佛和二进制还是有一点干系，但我太弱了，想不出来），其中我认为比较简单的是用 DP 来完成。

设 $f[i][j][k]$ 表示取到第 $i$ 个数，上一个数是 $j$ ，能表示的 1 到 k 中的所有数的方案数。（这里强制规定所取序列是递增的）那么对于一个新取的数 $l$ ，一定能表示 $l$ 到 $l+k$ 的所有数。由之前的限制可得 $j$ 至少为 $i$ ，$k$ 至少为 $\dfrac{i\times(i-1)}{2}$ ， $l$ 在 $j+1$ 到 $k+1$ 之间。（因为要保证每一个数都能表示）
 
然后转移 $f[i][j][k]=\sum_{l=i-1}^{k} f[i-1][l][k-l]$
换一种写法就是 $f[i][l][k+l]+=f[i][j][k]$。

-------------

代码：

```cpp
#include<cstdio>
using namespace std;
int n,n2,len,f[20][1005][1005],tot;
int main(){
	scanf("%d",&n);
	n2=n;while(n2){n2>>=1;len++;}
	printf("%d ",len);
	f[1][1][1]=1;
	for(int i=1;i<len;i++)
	for(int j=i;j<=(1<<(i-1));j++)
	for(int k=i*(i-1)/2;k<=(1<<i);k++)
	for(int l=j+1;l<=k+1;l++)
	if(l+k<n)f[i+1][l][k+l]+=f[i][j][k];
	else f[i+1][l][n]+=f[i][j][k];
	for(int i=1;i<(1<<len);i++)tot+=f[len][i][n];
	printf("%d",tot);
	return 0;
}
```



---

## 作者：YuRuiH_ (赞：4)

**问题的数学模型是从前n个数字中选取尽可能少的个数，使得其和取遍1..m中所有的值。不难想到用dp[i][j]表示前i个数字选择取遍1..j的尽可能少的个数。有**

```
dp[0][0] = 0
dp[i][j] = min{dp[i-1][j], dp[i-1][k]+1 | k >= i+1, 且j-i <= k < j}
```


**由于不等式i < j <--> dp[a][i] <= dp[a][j]显然成立，所以dp[i-1][k]取最小值必然在k = max{i+1, j-i}。也不难证明这种方法既不重复又不遗漏，因此用数组cnt根据决策统计即可。**

```
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;

int dp[1005][1005];
int cnt[1005][1005];
int main()
{
    int n;
    cin >> n;
    memset(dp, 127/3, sizeof dp);
    memset(cnt, 0, sizeof cnt);
    dp[0][0] = 0;
    cnt[0][0] = 1;
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j <= n; j++) {
           
            dp[i][j] = dp[i-1][j];
            int k = max(i-1, j-i);
            dp[i][j] = min(dp[i][j], dp[i-1][k]+1);
            if (dp[i][j] == dp[i-1][j])
                cnt[i][j] += cnt[i-1][j];
            if (dp[i][j] == dp[i-1][k]+1)
                cnt[i][j] += cnt[i-1][k];
        }
    }
    cout << dp[n][n] << " " << cnt[n][n] << endl;
    return 0;
}

```


---

## 作者：Zzxpy (赞：3)

感谢管理大大百忙之中抽空审核！（解释已经补上来了

看了一下。。6个题解都写的稍有模糊。。。 

本juruo也是看了~~一天~~题解~~才~~写出来的

所以补一个解释上去。。。

我们假设已经搜索出来的数字已经可以构成当前最大值及一下的所有数字

那么像后面搜索的时候，从当前最大值到当前和都是可以取的

为什么

因为最大值加一加上当前和不会成为前面的累赘而导致不是最优解，又能够向后

而和加上当前值的最小值（一）后刚好可以多一，满足序列条件。

1.从零开始，搜索到最后一个的时候特判 

2.设最后一个数he+1(下同)

3.当前最大值+1加和比n

4.大，那么方案数只能从max+1开始算 

5.当前最大值+1加和比n小，那么方案数只能从n开始算 

6.每个数比前面数大，在规定范围内一定可以组成小于最大值的所有数

7.众所周知，2的n次方可以构成不大于2的n+1次方的所有数 

8.从零开始搜索 

下面是代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long int
ll n,m;
ll ans=0;
void sou(ll t,ll max1,ll he) {
	if(t+1==m) {
		if(he*2+1>=n) { 
			if(he+max1+1>=n) ans+=he-max1+1;
			else ans+=he*2+2-n;
		}
		return ;
	}
	for(int i=max1+1; i<=he+1; i++) sou(t+1,i,he+i);
int main() {
	cin>>n;
	m=log(n)/log(2)+1;
	sou(0,0,0);
	cout<<m<<" "<<ans<<endl;
   return 0;
}
```


---

## 作者：hwhwh (赞：2)

## [题目传送门](https://www.luogu.org/problemnew/show/P1490#sub)

* 这道题还是很有意思的

* 但如果在这之前对这类题目没有研究，还是有一定难度的

* 下面我们简单地介绍一下这一题的思想

* 首先，我们需要一个1，不然的话，1无法表示

* 其次，我们需要一个2，不然的话，2无法表示

* 那么接下来呢，我们观察已有的{1,2}，可知这个集合可以表示1,2,3，但无法表示4，所以我们需要一个4

* 以此类推，我们需要一个8,16,32......

* 诶，等等......

* {1,2,4,8,32......}~~我是不是发现了一个天大的秘密，快来授予我诺贝尔计算机奖 （诺贝尔一脸懵逼）~~

* 对于一个N，我们只需要不断地用N整除2，即可得到钱的总数

核心代码：
```pascal
 readln(n);//读入，不解释
  nn:=n;
  while nn>0 do//计算个数，原理参照初中数学
   begin
    nn:=nn div 2;
    inc(y);
  write(y,' ');
```
  
 接下来，我们来思考如何计算方法数

 * 首先，我们定义一个G（表示当前递归到的钱的个数）；

* 其次，我们定义一个H（表示在此之前的钱数总和）；

* 接下来，我们定义一个Z（表示之前的钱数中的最大值）；

* 接下来我们只需枚举最大的钱数即可

* 而最大的钱数的范围在Z+1与H+1之间

  *  Z+1是因为目前最大的钱数肯定大于等于之前钱数中的最大值
  
  *  h+1是因为之前钱数所能表示的最大值即为H
  
* 接下来，我们只需递归即可

* 同时，我们还要加上一个优化
  
  * 枚举到倒数第二个数时，我们便可计算它最大能表示多少
  
  * 计算出来后和N作比较，如若小于N，便退出循环
  
  * 如果当前解中的最差解（H+Z+1）都比N大，
    
    * ans:=ans+h+1-z;
    
  * 否则
  
    * ans:=ans+2*h+1-n+1;

* 接下来，就是见证奇迹的时刻了（当然，首先你要编出程序）

* PS：这道题知道思想还是挺容易编出来的

***
下放代码
```pascal
var
 f:array[0..1005,0..1005] of longint;
 n,nn,ans,y:longint;

procedure dfs(g,h,z:longint);//（g表示有几种钱，h表示目前所取的方案中最大的钱数，）
 var p:longint;
 begin
   if g+1=y then
    begin
     if h*2+1>=n then
      begin
       if h+z+1>=n then ans:=ans+h-z+1;
       if h+z+1<n then ans:=ans+h*2+2-n;
      end;
     exit;
    end;
   for p:=z+1 to h+1 do dfs(g+1,h+p,p); 
 end;  

begin
  readln(n);//读入，不解释
  nn:=n;
  while nn>0 do//计算个数，原理参照初中数学
   begin
    nn:=nn div 2;
    inc(y);
   end;
  dfs(0,0,0);//深搜
  writeln(y,' ',ans);//输出
end.
```

---

## 作者：BLUE_EYE (赞：2)

冲上$rank$ 榜第一页发个题解纪念一下

对于前面的一半答案，有个显然的结论
取1,2,4,8,16……2^n是最优的，当且仅当输入的n大于2^(i-1),小于2^i次时取得最小的答案。对于第二种，我们有两种解法，DP和爆搜，这题提供爆搜解法。看到题解区有一个爆搜，不过他代码跑起来有点慢，这里还提供一个剪枝，比如现在我们最多可以将k这个数之前的数字全部表示出来，那么下一个我们最大可以取到k+1，那么可以表示的最大数就是2k+1，由此，如果我们还能取m个数，那么2^m*(k+1)-1就是我们最终可以取到的最大的可以表示的数字了，如果仍然比n小，我们就可以退出循环。此外，记录答案时，我们可以退一层来表示，具体看代码，61ms还算挺快
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int re(){
    char c=getchar();int all=0,pd=1;
    for(;c>'9'||c<'0';c=getchar()) if(c=='-') pd=-1;
    while(c>='0'&&c<='9') all=all*10+c-'0',c=getchar();return all*pd;
}const int N=1005;int qpow[N],ans,f[N],a[N],n;
void dfs(int x,int last,int al){
    if(al*2+1>=n){ans+=min(al-a[a[0]]+1,al*2+2-n);return;}
    //比如我们有n=20，可以表达的最大数字为13，前面已经取了1,2,4,7，那么理论不考虑前面数字大小的情况下。
    //我们可以取7,8,9,10,11,12,13,14共8种，但是由于7和7重合，所以我们只有7种。
    //这个左侧表示的是从前面数字大小的情况来考虑，后面的是从最大能取的情况考虑
    if((al+1)*qpow[x]-1<n&&al>=2) return;
    for(int i=last;i<=al+1;i++){ 
        a[++a[0]]=i;dfs(x-1,i+1,al+i);a[a[0]--]=0;
    }
}
int main(){
    n=re();qpow[0]=1;for(int i=1;i<=30;i++) qpow[i]=qpow[i-1]*2;
    for(int i=0;i<=31;i++) if(n>=qpow[i]&&n<qpow[i+1])
    {printf("%d ",i+1);;dfs(i+1,1,0);printf("%d\n",ans);return 0;}
}
```


---

## 作者：I_promise (赞：1)

此题可以用三维DP

个数可以通过找规律求得，而组成方案则需通过DP

通过找规律，可以得出2^(n-1)到2^n-1之间的数的最小需要个数是n

组成方案则由f[i,j,k]表示已经选了i个数，第i个数是j，前i个数的总和是k，那么f[i,j,k]能转移给f[i+1,p,k+p]。

一起来看pascal的AC代码（短小精悍）

···pascal

const a:array[1..10]of longint=(1,2,4,8,16,32,64,128,256,512);//第i个数的最大值是2^(i-1)

```cpp
var n,ans,i,j,k,p,tot:longint;
    f:array[0..11,0..1001,0..1001]of longint;//三维数组，意义上面有
begin
//assign(input,'cake.in'); reset(input);
//assign(output,'cake.out'); rewrite(output);//noip必备哦
  readln(n);
  ans:=trunc(ln(n)/ln(2)+1);//求最小需要个数
  f[1,1,1]:=1;//赋初值为1
  for i:=1 to ans-1 do//需要的数字个数
   for j:=i to a[i] do//枚举第i个数，i<=j<=a[i]
    for k:=j to a[i+1]-1 do//总和不会超过2^(i+1)-1，不相信可以手磨
    if f[i,j,k]<>0 then//判断是否可以转移
     for p:=j+1 to k+1 do//枚举要加的数
     if k+p<=n then//总和不到n说明还不行
      inc(f[i+1,p,k+p],f[i,j,k])//继续
      else
      inc(f[i+1,p,n],f[i,j,k]);//可以了，方案+
  for i:=1 to a[ans] do//枚举最后一个数，方案相加
  tot:=tot+f[ans,i,n];
  writeln(ans,' ',tot);//输出
//close(input); close(output);//NOIP必备哦
end.
```

---

## 作者：J2a0m0e8s (赞：0)

### 首先，我们来解决第一问。

有的同学初拿到这道题的时候想到二分，但是他们想不到如何去判断这个数目，因此在这道题上卡了许久，然后放弃去做了下一道题。~~既然这样，那就别做这道题了吧。~~

但凡~~学过一些数学~~的同学们应该都见过那道天平与砝码称重的题，那道题目启示我们，使用 $ 2^{0} $ , $ 2^{1} $ , $ 2^2 $ 等质量的砝码，可以使从 $1$ 到上限的所有质量都能被表示出来，且使用最少的砝码。

这个结论也可以运用到这题中来。
取 $t=\log_2 n + 1 $ ，这就是第一问的答案。

### 下面使用  dp  来求解第二问的答案。

不妨令取的数目 $x_1$ , $x_2$ $...$ $x_n$ 满足单调递增性，显然这不会影响结果。

设 $f_{i,j,k}$ 表示取了 $i$ 个，上一个为 $j$ ，总数为 $k$ 的方案数。

因为数目互不相同，故下一个硬币的数目至少为 $j+1$ ，又因为要能表示所有的数目，故下一个硬币的数目最大不能超过 $k+1$ ，若超过则 $k+1$ 就将无法被表示。

则状态转移方程为 $f_{i+1,t,k+t}=\sum\limits^{k+1}_{t=j} f_{i,j,k} $ 。

还有一个需要注意的点，就是当 $k+t>n$ 时要把状态转移方程中的 $k+t$ 改成 $n$ , 因为硬币的总价可以超过 $n$，这样处理便于统计答案。

至此本题即计算完毕。

下面就到了人们**喜闻乐见**的放代码时间：


```
#include<bits/stdc++.h>
using namespace std;
int n,T,f[20][1009][1009];
long long ans;
int main(){
	cin>>n;
	T=log2(n)+1;
	printf("%d ",T);
	f[1][1][1]=1;
	for(int i=1;i<T;i++)
	for(int j=i;j<=(1<<(i-1));j++)
	for(int k=i*(i-1)/2;k<(1<<i);k++)
	for(int t=j+1;t<=k+1;t++){
		if(k+t<=n)f[i+1][t][k+t]+=f[i][j][k];
		else f[i+1][t][n]+=f[i][j][k];
	}
	for(int i=1;i<(1<<T);i++)ans+=f[T][i][n];
	printf("%lld",ans);
	return 0;
}
```


---


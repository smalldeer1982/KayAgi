# 魔杖

## 题目描述

Smart 在春游时意外地得到了一种好东西——一种非常珍贵的树枝。这些树枝可以用来做优质的魔杖！

选择怎样的切割方式来制作魔杖非常重要，关键问题是——一把魔杖既不能太长、又不能太短，且制作出来的魔杖不能有冲突……

Smart 得到的这些树枝在属性上完全相同。每一根树枝都有 $n$ 段（用 $1$~ $n$ 编号），给定了每段的长度 $l$ 和每段的魔力值 $m$ 。你可以做的就是选择一段或连续的几段，把它们作为一个整体切下来，再用来制作魔杖。但是一根魔杖的长度不能太长，不能大于给定的值 $h$；也不能太短，不能小于给定的值 $low$ 。

魔杖有一个奇怪的要求：如果某一根魔杖的制作材料是另一根魔杖的一部分，则这两根魔杖之间将发生冲突。比如说树枝有三段，从左到右的长度分别为 $4$ 、 $1$ 、 $3$ ，Smart需要长度为 $4$ 到 $5$ 之间的魔杖。他可以用一根树枝的前两段做出一个长度为 $5$ 的魔杖，用一根树枝的后两段做出长度为 $4$ 的魔杖；但他决不能用一根树枝的前两段做了魔杖后再单独使用另一根树枝的第一段做成魔杖，因为前者包含了后者的所有成分，这会导致冲突。

我们假设 Smart 可以得到任意多这样的树枝。 Smart 需要制作出若干个互不冲突的魔杖，使所有魔杖的魔力值之和最大。（魔杖的长度就是组成它的那些段的长度的总和，魔力值亦然）。

## 说明/提示

#### 样例输入输出 1 解释

取 $[1$  $3]$ $[3$ $2]$ $[2$ $2$ $1]$ 做成魔杖，得到最大权值 $2+3+1+4+4+5+2=21$ 。

---

#### 数据规模与约定

对于$100\%$的数据，保证：
- $1\le n\le 1000$，$1\le low\le h < 2^{31}$。
- $1 \leq l_i, m_i \le 10^5$

## 样例 #1

### 输入

```
6 4 5
1 3 3 2 2 1
2 3 1 4 5 2```

### 输出

```
21```

# 题解

## 作者：Shikita (赞：10)

# 一道看似暴力枚举的DP题目
就是求切割得到的贡献最大，并且对每一个木条进行长度的限制，而且单根只能取头或者尾，任意两根之前互不重合，于是就写个DP吧

f[i][j]表示起点不超过i，终点不超过j的所有魔杖魔力之和的最大值。

f[i][j]=max(f[i-1][j],f[i][j-1],f[i-1][j-1]+w[i][j]);

对了提醒一下这题应该开个long long，要不然会WA两个点
## 代码
```
#include<iostream>
#include<cstring>
#include<string>
#include<cstdio>
#define int long long//既然已经写好了代码还一个个去改好烦
using namespace std;
inline int read()
{
    int x=0;
    char c=getchar();
    bool flag=0;
    while(c<'0'||c>'9'){if(c=='-')flag=1;   c=getchar();}
    while(c>='0'&&c<='9'){x=(x+(x<<2)<<1)+c-'0';c=getchar();}
    return flag?-x:x;
}
int n,minn,maxn;
int l[1005][1005],w[1005][1005];
int f[1005][1005];
signed main()//由于某种不可描述的原因，就这样看着吧
{
	n=read(),minn=read(),maxn=read();
	for(int i=1;i<=n;++i) l[i][i]=read();
	for(int i=1;i<=n;++i) w[i][i]=read();
    //由于用二维处理，那么这些干脆都用个二维储存
	for(int i=1;i<=n;++i)
	  for(int j=i+1;j<=n;++j)
	  {
	  	l[i][j]=l[i][j-1]+l[j][j];
	  	w[i][j]=w[i][j-1]+w[j][j];
	  }//前缀和压缩
	for(int i=1;i<=n;++i) 
	  for(int j=i;j<=n;++j)
	  	if(l[i][j]<minn||l[i][j]>maxn) w[i][j]=0;
    //求的是max那就把初值变为0
	for(int i=1;i<=n;++i)
	  for(int j=1;j<=n;++j)
	  	f[i][j]=max(f[i-1][j],max(f[i][j-1],f[i-1][j-1]+w[i][j]));
    //状态转移方程
	cout<<f[n][n];
}
```
多多指教

---

## 作者：Gaochenxi103_QWQ (赞：8)

这道题目的难点在于状态的定义以及对题目的理解。


## 题意化简
给定两个长度为 $n$ 的序列，长度 $l$ 和魔力值 $m$ ，我们可以认为是一个二元组序列及 $(li,mi)$ 。对于这个序列有两个限制。

1. 长度限制：对于任意一个序列 $[l,r]$ 需满足 $low≤\sum_{i=l}^{r}li≤h$ 。
2. 覆盖限制：对于任意两个序列 $[l_1,r_1] \text{ 和 } [l_2,r_2]$ 需不同时满足 $l_1≥l_2$ 和 $r_1≤r_2$ 反之亦然。

需求是询问这个序列中有符合限制的区间的魔力值最大和。

## 解题思路

### 核心思路

本题难度在于状态的定义，需要一个可以表示区间极值的状态，因为区间是 $[l,r]$ 的二位区间，所以想到定义二位状态（二位动态规划），及 $dp[i][j]$ 表示**前区间小于等于 $i$，后区间小于等于 $j$，的区间内的合法法杖法力值之和的最大值**。

为什么是前 $i$ 前 $j$ 呢，请看下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/4as4ps7v.png)

我们假设要求 $dp[4][6]$ 的值，根据我们的状态定义，可以将所需的标出，来就是 $i≤6,j≤4$ 的所有状态。

![](https://cdn.luogu.com.cn/upload/image_hosting/g86t456o.png)

仔细观察状态定义可见，对于每一个 $dp[i][j]$ 都需要用到 $i'≤i,j'≤j$ 的所有以前状态，我们发现：对于每个状态 $dp[i][j]$ 它所需要的数据一定被 $dp[i-1][j]$ 和 $dp[i][j-1]$ 包括了。

![](https://cdn.luogu.com.cn/upload/image_hosting/w3m2ed4h.png)

可见 $dp[4][6]$ 的所有情况一定被 $dp[3][6]$ 和 $dp[4][5]$ 给覆盖完了。

但是我们发现在**覆盖限制**上 $dp[3][6]$ 和 $dp[4][5]$ 是冲突的，在转移的时候如果要在接一个 $dp[4][6]$ 所对应的 $[4,6]$ 这个区间的魔力值所做的魔杖（**先不考虑长度限制问题**），是需要在 $dp[3][5]$ 上加上 $[4,6]$ 的魔力值的，所有将转移方程的需求分为如下两大类。

1. 转移的情况 $dp[i][j]=dp[i-1][j-1]+w[i][j]$。
2. 不转移（覆盖冲突）$dp[i][j]=\max(dp[i-1][j],dp[i][j-1])$。

那么得到总转移方程 $dp[i][j]=\max(dp[i-1][j],dp[i][j-1],dp[i-1][j-1]+w[i][j])$。

### 细节处理

对于本体刚才的：“**先不考虑长度限制问题**”，做如下处理，我们可以将不满足长度限制的范围的 $w[i][j]$ 也就是对应的魔力值设为 $0$。

对于长度和魔力值的快速计算用前缀和优化即可，实现代码如下。


```cpp
//l是长度，w是魔力值
for(int i=1;i<=n;i++){
    for(int j=i+1;j<=n;j++){//初始化,前缀和 
        l[i][j]=l[i][j-1]+l[j][j];
        w[i][j]=w[i][j-1]+w[j][j];
    }
}
for(int i=1;i<=n;i++){
    for(int j=i;j<=n;j++){
        if(l[i][j]<lo||l[i][j]>hi){//如果这个的区间的法力值不合法 
        w[i][j]=0;
        }
    }
}
```

### AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e3+5;
long long  n,lo,hi,l[N][N],dp[N][N],w[N][N];//dp[i][j]->前区间小于等于i,后区间小于等于j,的区间内的合法法杖法力值之和的最大值 
int main(){
	cin>>n>>lo>>hi;
	for(int i=1;i<=n;i++){
		cin>>l[i][i];
	}
	for(int i=1;i<=n;i++){
		cin>>w[i][i];
	}
	for(int i=1;i<=n;i++){
		for(int j=i+1;j<=n;j++){//初始化,前缀和 
			l[i][j]=l[i][j-1]+l[j][j];
			w[i][j]=w[i][j-1]+w[j][j];
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=i;j<=n;j++){
			if(l[i][j]<lo||l[i][j]>hi){//如果这个的区间的法力值不合法 
				w[i][j]=0;
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=i;j<=n;j++){
			dp[i][j]=max(dp[i-1][j],max(dp[i][j-1],dp[i-1][j-1]+w[i][j]));//直接转移 
		}
	}
	cout<<dp[n][n];
	return 0;
}

```
完。

---

## 作者：sel_fish (赞：7)

### 前缀和+动态规划

最开始，我连题都读不懂，看了一下标签更看不懂了？搜索？？于是我瞟了一眼题解，然后发现我的语文实在是。。。

**题目大意：给你一段序列，让你求出所有在范围内的序列的数值之和最大，子序列不可相交**

1. 因为n只有1000，可以考虑用O(n^2)的动态规划~~水~~过去

2. 我们设一个数组**f[i][j]代表以i为终点，j为起点的最大值**，所以我们对于每一个终点i，只需要枚举起点j即可  ~~我感觉其他题解好像把数组的含义都说错了~~

3. 枚举对于每一个符合条件的子序列，我们都可以进行比较

4. 考虑优化 (1) 加个快读  (2) 使用前缀和来优化，因为我们每一个子序列都是连续的，所以我们可以维护两个前缀和 (3) 自定义max函数比调用要快

5. **10年OI一场空，不开long long见祖宗**

```cpp
#include<cstdio>
#define ll long long
#define si 1010
#define re register ll
using namespace std;
ll n,low,hi,l[si],m[si],f[si][si];
inline ll read() {
	ll x=0,cf=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') {
		if(ch=='-') cf=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') {
		x=(x<<3)+(x<<1)+ch-'0';
		ch=getchar();
	}
	return x*cf;
}
inline ll max(ll A,ll B) { return A>B?A:B; }
int main() {
	n=read(),low=read(),hi=read();
	for(re i=1;i<=n;i++) {
		l[i]=read();
		l[i]+=l[i-1];
	}
	for(re i=1;i<=n;i++) {
		m[i]=read();
		m[i]+=m[i-1];
	}
	for(re i=1;i<=n;i++) {
		for(re j=1;j<=i;j++) {
			if(l[i]-l[j-1]>=low&&l[i]-l[j-1]<=hi) {
				f[i][j]=max(f[i-1][j],max(f[i][j-1],f[i-1][j-1]+m[i]-m[j-1]));
			}
			else f[i][j]=max(f[i-1][j],f[i][j-1]);
		}
	}
	printf("%lld",f[n][n]);
	return 0;
}
```
**END**

---

## 作者：YWHS__LH (赞：4)


这是一道DP题，（我看楼下貌似已经讲明了思路，但是没有贴代码）（我这里补上一发），实际上思路很清晰，就用f[i][j]表示起点不超过i，终点不超过j的所有魔杖魔力之和的最大值。l[i]表示第1段到第i段的长度和。如果low<l[j]-l[i-1]<hi,m[i]表示第1段到第i段的魔法值的和。否则m[j]-m[i-1]为0。f[i][j]=max(f[i-1][j],f[i][j-1],f[i-1][j-1]+m[j]-m[i-1]);最后输出分f[n][n]就好了；
------------

还有就是可以用前缀和优化一下；
------------

下面贴上代码
------------

```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int n,minn,maxn;
long long f[1005][1005],l[1005],m[1005];
int main(){
//  freopen("mwand.in","r",stdin);
//  freopen("mwand.out","w",stdout);
    scanf("%d%d%d",&n,&minn,&maxn);
    memset(f,0,sizeof(f));
    for(int i=1;i<=n;i++) {
        int x;
        scanf("%d",&x);
        l[i]=l[i-1]+x;
    }
    for(int i=1;i<=n;i++) {
        int x;
        scanf("%d",&x);
        m[i]=m[i-1]+x;
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=i;j++){
            if(l[i]-l[j-1]>=minn&&l[i]-l[j-1]<=maxn) f[i][j]=max(f[i][j],max(f[i][j-1],f[i-1][j-1]+m[i]-m[j-1]));
            else f[i][j]=max(f[i-1][j],f[i][j-1]);
        }
    }
    cout<<f[n][n];
}
```

---

## 作者：_WHX985_ (赞：1)

千万不要被题目的算法标签误解了，这道题是一道简单的 dp 题，但只用 dp 也会超时，超时的原因是每算一个 $dp_{i,j}$ 都要算一遍区间和，所以我们在 dp 的基础上使用前缀和进行优化。dp 转移方程如下（$dp_{i,j}$ 意义为起点不超过 $i$，终点不超过 $j$ 的所有魔杖魔力之和的最大值）。

$dp_{i,j}=\max(dp_{i-1,j},dp_{i,j-1},dp_{i-1,j-1}+w_{}[i][j])$

再加上前缀和的优化，时间复杂度为 $O(n^2)$ 不会超时。最后，注意要开 long long 否则会 WA 两个点。

---

## 作者：CommonDigger (赞：1)

## 题目大意
[P1584 魔杖](https://www.luogu.com.cn/problem/P1584)

有若干个线段，取任意条互不包含的子线段，使权值最大。

互不包含的定义：例如有 $4$ 根线段，可以同时取 $1\sim3$ 和 $2\sim4$，但是不能同时取 $1\sim3$ 和 $2\sim3$，因为后者完全在前者的范围之内。

## 方法：动态规划
主流方法是动态规划，好像没几个题解用搜索。

可以设 $f[i][j]\space (j\le i)$ 表示最后一根魔杖使用 $j$ 号木棍到 $i$ 号木棍制作（此时 $j$ 之前已考虑）时的最大值。

转移：

1. $j$ 号木棍到 $i$ 号木棍拼起来的长度不符合要求。此时不用这一段制作魔杖，从目前的最优状态 $f[i-1][j]$ 和 $f[i][j-1]$ 转移，也就是上一根魔杖是 $j\sim (i-1)$ 或 $(j-1)\sim i$。
2. 长度符合要求，此时在上面得出的最大值的基础上考虑加上制作这根魔杖的权值，权值就是 $j$ 号木棍到 $i$ 号木棍的权值之和。为了保证不出现完全覆盖，最后一根魔杖最大为 $(j-1)\sim(i-1)$。
3. 最后输出的答案是 $f[n][n]$。

## 注意事项
1. 区间长度和权值可以使用前缀和光速求出。
2. 使用 long long，下面的代码中我直接使用 define

## 代码
```cpp
/*
Luogu P1584 魔杖
https://www.luogu.com.cn/problem/P1584
*/
#include "iostream"
#define int long long
using namespace std;
const int N=1005;
int len[N], m[N], low, high, n, f[N][N];
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> low >> high;
    for(int i=1;i<=n;i++){
        cin >> len[i];
        len[i]+=len[i-1];
    }for(int i=1;i<=n;i++){
        cin >> m[i];
        m[i]+=m[i-1];
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=i;j++){
            f[i][j]=max(f[i-1][j], f[i][j-1]);
            if(low<=len[i]-len[j-1] && len[i]-len[j-1]<=high){
                f[i][j]=max(f[i][j], f[i-1][j-1]+m[i]-m[j-1]);
            }
        }
    }
    cout << f[n][n];
}
```

---

## 作者：half_a_crocodile (赞：1)

[**原题传送门**](https://www.luogu.com.cn/problem/P1584)

### 题意：

魔杖有一个奇怪的要求：如果某一根魔杖的制作材料是另一根魔杖的一部分，则这两根魔杖之间将发生冲突。

不知道大家有没有读懂。给你一堆一样的树枝，从中截取下 $N$ 段做魔杖，每一段有一个魔法值和长度，要求一共可以截取下多少符合条件切树枝两两不完全重合的树枝使魔法值最大。

### 思路：

如果 $low<l_j-l_{i-1}<h_i$ , $m_i$ 表示第 $1$ 段到第 $i$ 段的魔法值的和。否则 $m_j-m_{i-1}$ 为 $0$。

根据以上推理，得出动规式为
$$
f_{i,j}=\max(f_{i-1,j},f_{i,j-1},f_{i-1,j-1}+m_j-m_{i-1})
$$

还有 ```long long```，必须开。

### 代码：
```cpp
#include <bits/stdc++.h>
#define int long long  //不开longlong会爆 
using namespace std;
int n,low,h,i,j,x,len[1010],a[1010],f[1010][1010];
main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>low>>h;
	for(i=1; i<=n; i++)cin>>x,len[i]=len[i-1]+x;
	for(i=1; i<=n; i++)cin>>x,a[i]=a[i-1]+x;
	for(i=1; i<=n; i++)
		for(j=1; j<=i; j++)
			if(len[i]-len[j-1]>=low&&len[i]-len[j-1]<=h)
				f[i][j]=max(f[i][j],max(f[i][j-1],f[i-1][j-1]+a[i]-a[j-1]));
			else f[i][j]=max(f[i-1][j],f[i][j-1]);
	//动规式
	cout<<f[n][n];
}
```

---

## 作者：ademik (赞：1)

 _模拟赛上的一道题，竟然有90pts_   
 [题目传送门](https://www.luogu.com.cn/problem/P1584)
 
-------------
### 题意(按照我的做法的理解)
给定几条线段（左右端点为 $ x_i $ ， $ y_i $ ） ， 每个线段有一个权值和长度， 可以选择任意条长度在 $[low ,h_i]$ 之间的线段， 要求选定的任意两条线段不能完全重和（两条线段 i , j 被认为完全重合当且仅当 i 是 j 的子段 或 j    是 i 的子段）， 求能获得的最大权值之和。  

### 分析
* 假定线段 i 的左端点为 $x_i$ ， 右端点为 $y_i$ ， 权值为 $val_i$ ，长度为     $len_i$ 。
* 因为我们选定的魔杖一定是一个连续的序列， 所以我们可以将一段魔杖看成一个线段 ，线段的左右端点即是最左端 和 最右端在序列中的位置 ， 权值即为这一段的魔力值。 我们可以选的其实就是 $low \le len_i  \le h$ 的线段， 其他部分显然对答案无影响 。   

* 其次，本题只要求最大值 ，可以看出用 dp 的方式解决问题 。  
> * 先将线段按照左端点递增进行排序（本题貌似不需要）。  
> * 我们令 $f[i][j]$ 表示递推到第 i 条线段，从 1 覆盖到 j（即 1 到    j 之间的部分已经被线段覆盖）的最大权值和。    
> * 则有 $f[i][y_i] = \max\limits_{j = 0}^{j < y_i}(f[i-1][j]) + val_i$  
> * 道理很简单，枚举所有覆盖不到线段 i 右端点的情况，以保证不会将当前线段完全覆盖，此时当前线段可以被选择且不与其他已选定的线段冲突， 取最大值即可。
> * 注意到每次 dp 时只会使用上一次的结果， 故可以转化为一维。  
	$f[y_i] = \max\limits_{j=0}^{j<y_i}(f[j]) + val_i$
* 讲的不好的话，请见谅。 具体细节见代码。
### Code
```cpp
using namespace std;
typedef long long i64;
const int N = 1e3 + 50;
i64 qz[N], qz2[N], dp[N], cnt;
// 好像洛谷上要开long long 
int n, low, hi, L[N], M[N];
struct line {
	int x, y;
	long long val;
	bool operator <(const line &tmp) const {
		if(x == tmp.x) return y > tmp.y;
		return x < tmp.x;
	}
}a[N * N];
int main()
{
	Read(n); Read(low); Read(hi);
	for(int i = 1; i <= n; i ++) {
		Read(L[i]);
		qz[i] = qz[i - 1] + L[i]; // 计算前缀和， 方便后边计算线段 
	}	
	for(int i = 1; i <= n; i ++) {
		Read(M[i]);
		qz2[i] = qz2[i - 1] + M[i];
	}	
	for(int i = 1; i <= n; i ++) {
		for(int j = i; j <= n; j ++) {
			// 枚举所有可能的线段 
			int tmp = qz[j] - qz[i - 1];
			if(tmp >= low && tmp <= hi) {
				a[++cnt].x = i;
				a[cnt].y = j;
				// 记录线段的左右端点 
				a[cnt].val = qz2[j] - qz2[i - 1];
			}
		}
	}
	sort(a + 1, a + 1 + cnt);
	
	for(int i = 1; i <= cnt; i ++) {
		for(int j = 0; j < a[i].y; j ++) {
		// 这里的枚举范围为[0, 右端点), 不能到右端点防止完全覆盖
		// 从0开始是因为可能出现只有一条线段的情况(我的10pts就是这里错了)
			dp[a[i].y] = max(dp[a[i].y], dp[j] + a[i].val);
		}
	}
	i64 ans = 0;
	// 要取最大值，毕竟最终选定的权值和最大的线段组合不一定将[1, n]完全覆盖
	 
	for(int i = 0; i <= n; i ++) {
		ans = max(ans, dp[i]);
	}
	print(ans);
	return 0;
}
```
### The End

---

## 作者：JOHNKRAM (赞：1)

这题是一道标准的DP题，不是什么搜索枚举。

用f[i][j]表示起点不超过i，终点不超过j的所有魔杖魔力之和的最大值。

l[i]表示第1段到第i段的长度和。

如果low<l[j]-l[i-1]<hi,w[i][j]表示第i段到第j段的魔法值的和。

否则w[i][j]为0。

f[i][j]=max(f[i-1][j],f[i][j-1],f[i-1][j-1]+w[i][j]);

最后输出f[n][n]即可。

时间复杂度O(n²)

可以使用状态压缩，空间复杂度降为O(2n)


---

## 作者：Hellsing_Alucard (赞：0)

[题目](https://www.luogu.com.cn/problem/P1584)

大意：给你一堆一样的树枝，从中截取下 $N$ 段做魔杖，每一段有一个魔法值和长度，要求一共可以截取下多少符合条件切树枝两两不完全重合的树枝使魔法值最大。

DP 问题。

令 $f[i][j]$ 为起点小于 $i$  终点小于 $j$ 的最大值，

先将前面的状态传递过来，

$$f[i][j]=\max(f[i-1][j],f[i][j-1])$$

如果长度满足条件，因为可以重合，只要不完全包含就行，所以转移方程里是 $f[i-1][j-1]$。

$$f[i][j]=\max(f[i][j],f[i-1][j-1]+summ[j]-summ[i-1])$$

再用前缀和使计算方便。

上代码：

```cpp
#include<bits/stdc++.h>

using namespace std;

#define int long long

inline int read(){
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
int n,low,hi,l[1500],m[1500],suml[1500],summ[1500],f[1300][1300];
signed main(){
	n=read();low=read();hi=read();
	for(int i=1;i<=n;i++){
		l[i]=read();
		suml[i]=suml[i-1]+l[i];	
	}
	for(int i=1;i<=n;i++){
		m[i]=read();
		summ[i]=summ[i-1]+m[i];	
	}
	for(int i=1;i<=n;i++){
		for(int j=i;j<=n;j++){
			int len=suml[j]-suml[i-1];
			f[i][j]=max(f[i-1][j],f[i][j-1]);
			if(len>=low&&len<=hi){
				f[i][j]=max(f[i][j],f[i-1][j-1]+summ[j]-summ[i-1]);
			}
		}
	}
	cout<<f[n][n]<<"\n";
    return 0;
}
```


---

## 作者：__int (赞：0)

由于标签是搜索，我就上一份记忆化搜索的题解吧。（其实还是是DP） 

与楼下大佬们的思路一样，用m[i][j]表示（编号）不超过i的树枝到不超过j的树枝组成的魔杖魔力值，算是预处理

具体操作见代码 
```
#include<bits/stdc++.h>
using namespace std;
long long m[1005][1005],f[1005][1005]; 
int n,lo,hi,l[1005];
long long dfs(int x,int y)
{
	if(f[x][y]!=-1) return f[x][y]; 
	if(!x||!y) f[x][y]=0; //0作为边界 
	else f[x][y]=max(max(dfs(x,y-1),dfs(x-1,y)),dfs(x-1,y-1)+m[x][y]);//状态转移方程在此  
	return f[x][y];
}
 int main()
{
	cin>>n>>lo>>hi;
	memset(f,-1,sizeof(f));//用-1代表没有搜索过 
	for(int i=1;i<=n;++i) cin>>l[i];
	for(int i=1;i<=n;++i) cin>>m[i][0];
	for(int i=1;i<=n;++i)
	{ 
		long long ls=0,ms=0;
		for(int j=i;j<=n;++j)
		{
			ls+=l[j];	//i到j的树枝长度 
			ms+=m[j][0];//i到j的树枝魔力 
			if(ls>hi) break; //树枝长度超限，不过由于全局变量初始为0，就不管它了 
			if(ls>=lo) m[i][j]=ms;
			m[j][i]=m[i][j];   		//多此一举... 
		}
	}
	cout<<dfs(n,n);
	return 0;
}
```


---


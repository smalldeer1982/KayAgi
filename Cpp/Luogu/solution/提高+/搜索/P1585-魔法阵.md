# 魔法阵

## 题目描述

魔法阵是一个 $n \times m$ 的格子（高 $n$，宽 $m$），$n \times m$ 为偶数。Smart 手中有 $n \times m$ 个宝石（以 $1 \sim n \times m$ 编号）。Smart 从最右上角的格子开始走，从一个格子可以走到上、下、左、右 $4$ 个相邻的格子，但不能走出边界。每个格子必须且仅能到过 $1$ 次，这样 Smart 一共走了 $n \times m$ 个格子停止（随便停哪里）。Smart 每进入一个格子，就在该格子里放入一颗宝石。他是按顺序放的，也就是说——第 $i$ 个进入的格子放入 $i$ 号宝石。

如果两颗宝石的编号对 $\frac{n \times m}{2}$ 取模的值相同，则认为这两颗宝石相互之间有微妙的影响。也就是说，我们按照宝石的编号对 $\frac{n \times m}{2}$ 取模的值，将宝石分成 $\frac{n \times m}{2}$ 对，其中每对都恰有两颗宝石。对于每一对宝石，设第一颗宝石在第 $a$ 行第 $b$ 列，另一颗宝石在第 $c$ 行第 $d$ 列，那么定义这 $2$ 个宝石的魔力影响值为 $k_1 \times \lvert a - c \rvert + k_2 \times \lvert b - d \rvert$。

需要你求出的是，在所有合乎题意的宝石摆放方案中，所有成对的宝石间的最大魔力影响值的最小值为多少。换句话说，如果我们定义对 $\frac{n \times m}{2}$ 取模的值为 $i$ 的一对宝石的魔力影响值为 $a_i$。你需要求出的就是 $\max \{ a_i : i=0,1,2,\ldots \}$ 的最小值。


## 说明/提示

对于 $100\%$ 的数据，$n \times m \le 50$，$1 \le k_1, k_2 \le 32767$。

## 样例 #1

### 输入

```
2 2 2 2
```

### 输出

```
4
```

# 题解

## 作者：YellowBean_Elsa (赞：12)

我觉得这题应该蓝。。。

首先看数据范围可知，这题就是个普通搜索。

然后按照题意，很快写出了一个简单的暴搜。

当然，加上了最显而易见的剪枝：如果当前答案已大于搜索已经得到的最小值，直接 return;

然而这样T飞了。。。

然后我们注意到，题目还有一个限制条件：**每个格子必须且仅能经过一次**

那么，如果在某一个状态时，我们可以判断此时已经不可能按要求走完魔法阵，则可以直接 return;

#### knock the blackboard!!!

经过画图，我们找到了一种这样的状态：

当我们走到一个位置时,如果已经走过它的上下，却没有走过它左右的任意一格，或者相反，已经走过它的左右，却没有走过它上下的任意一格，那么一定无法走完魔法阵，直接 return;

![](https://cdn.luogu.com.cn/upload/image_hosting/7br4665s.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

证明：如图，从A走到B的路径隔绝了C和D，因此不可能在不经过A到B路径的情况下同时走到C和D，证毕。

加上这个可行性剪枝后，就AC了。
```cpp
//coder: Feliks-GMYB
#include<bits/stdc++.h>
using namespace std;
int n,m,k1,k2,ans=(1<<30);
bool vis[55][55];
int col[30][2];
inline int read(){
	int x=0;char ch=getchar();
	while(!isdigit(ch))ch=getchar();
	while(isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();
	return x;
}void dfs(int x,int y,int p,int mx){
	//可行性剪枝
	if(vis[x-1][y]&&vis[x+1][y]&&!vis[x][y+1]&&!vis[x][y-1])return;
	if(!vis[x-1][y]&&!vis[x+1][y]&&vis[x][y+1]&&vis[x][y-1])return;
	if(mx>ans)return;//显而易见的最优性剪枝
	//按照公式要求进行操作
	if(p<=((n*m)>>1)){
		col[p][0]=x;
		col[p][1]=y;
	}else mx=max(mx,abs(col[p-n*m/2][0]-x)*k1+abs(col[p-n*m/2][1]-y)*k2);
	if(p==n*m){//done the maze
		if(mx<ans)ans=mx;
		return;
	}//尝试向四面走 
	if(!vis[x-1][y]){
		vis[x-1][y]=1;
		dfs(x-1,y,p+1,mx);
		vis[x-1][y]=0;
	}//up
	if(!vis[x+1][y]){
		vis[x+1][y]=1;
		dfs(x+1,y,p+1,mx);
		vis[x+1][y]=0;
	}//down
	if(!vis[x][y-1]){
		vis[x][y-1]=1;
		dfs(x,y-1,p+1,mx);
		vis[x][y-1]=0;
	}//left
	if(!vis[x][y+1]){
		vis[x][y+1]=1;
		dfs(x,y+1,p+1,mx);
		vis[x][y+1]=0;
	}//right
}int main(){
	n=read(),m=read(),k1=read(),k2=read();
	//常见搜索防越界操作：
	//地图四周初始时赋为已走过，防止搜索时走出地图 
	for(int i=0;i<=n+1;i++)
		vis[i][0]=vis[i][m+1]=1;
	for(int i=0;i<=m+1;i++)
		vis[0][i]=vis[n+1][i]=1;
	vis[1][1]=1;dfs(1,1,1,0);
	printf("%d\n",ans);
    return 0;
}
```
多嘴一句，这种可行性剪枝对于所有要求一笔画方格图的搜索都适用，也可看作一种实用技巧

---

## 作者：JOHNKRAM (赞：7)

虽然本题是求最大值的最小值，但函数不满足单调性，所以不能用二分。

只能使用dfs。

dfs要分成两部分，第一部分随便走，第二部分一边计算影响值一边走。

注意多加剪枝。第一部分要加两个可行性剪枝，第二部分还要加一个最优性剪枝。

可行性剪枝1：如果当前位置只能向上走和向下走，则返回。（可以证明，走上去就不能再下来了，走下来就不能再上去了）

可行性剪枝2：如果当前位置只能向左走和向右走，则返回。（可以证明，走左边就不能再到右边去了，走右边就不能再到左边去了）

最优性剪枝：如果当前最大影响值比已知答案还要大，则返回。

现在可以通过了。


---

## 作者：hulean (赞：5)

[My Blog](https://www.luogu.org/blog/hulean0319/)

### 这题就是一个有技巧的DFS+一大堆乱七八糟的剪枝

**进行DFS时注意一下以下点**

- 根据题意，我们可以把DFS分成两块，即``1--n*m/2``与``n*m/2--n*m``,第一块边找边记录，第二块就开始计算

- 其实左上角与右上角开始没有任何区别

---
## 剪枝

1. 可行性剪枝:判断上下或左右走过没有

![404](https://cdn.luogu.com.cn/upload/pic/46538.png)
```
（画风丑，勿喷）如图所示，当上下两格都走过或左右两个都走过时，
无论怎么走也是遍历完整张图的（自己去画画看就知道了）
```

2. 最优性剪枝:判断当前最大值是否大于答案

**这样下来就行了**

看代码:
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,m,k1,k2,ans=0x3f3f3f3f;
int dx[5]={0,1,-1,0,0},dy[5]={0,0,0,1,-1};//四个方向
int num[60][2];//用于第一次记录，下面会提
bool vis[60][60];//标记走过没
inline void dfs(int x,int y,int sum,int maxn)//x表示当前x坐标，y表示当前y坐标，sum表示当前步数，maxn表示当前最大值
{
    //cout<<x<<" "<<y<<" "<<sum<<" "<<maxn<<endl;
    if(vis[x-1][y]&&vis[x+1][y]&&!vis[x][y+1]&&!vis[x][y-1])return;//可行性剪枝1
    if(vis[x][y-1]&&vis[x][y+1]&&!vis[x+1][y]&&!vis[x-1][y])return;//可行性剪枝2
    if(sum<=t)num[sum][0]=x,num[sum][1]=y;//记录，这里t指一半
    else
    {
    	maxn=max(maxn,k1*abs(num[sum-t][0]-x)+k2*abs(num[sum-t][1]-y));//进行计算并更新
    	//return;
    }
    if(sum>=n*m)
    {
        ans=min(ans,maxn);//如果遍历完，那么更新答案
        return;
    }
    if(maxn>=ans)return;//最优性剪枝
    /*for(int i=0;i<=n+1;i++)
    {
    	for(int j=0;j<=m+1;j++)cout<<vis[i][j];
    	cout<<endl;
    }*/
    
    for(int i=1;i<=4;i++)//四个方向枚举
    {
        int a=x+dx[i],b=y+dy[i];
        if(!vis[a][b])
        {	
            vis[a][b]=1;
            //cout<<sum<<endl;
        	dfs(a,b,sum+1,maxn);
        	//cout<<sum<<endl;
        	vis[a][b]=0;//回溯
        }
    }
    
}
int main()
{
    cin>>n>>m>>k1>>k2;
    t=n*m/2;
    for(int i=0;i<=m+1;i++)
    {
    	vis[0][i]=1;
    	vis[n+1][i]=1;
    }//在外围加个边框1
    for(int i=0;i<=n+1;i++)
    {
        vis[i][0]=1;
        vis[i][m+1]=1;
    }//在外围加个边框2
    vis[1][1]=1;//初始标记
    /*num[1][0]=1;
    num[1][0]=1;
    /*for(int i=0;i<=n+1;i++)
    {
    	for(int j=0;j<=m+1;j++)cout<<vis[i][j];
    	cout<<endl;
    }*/
    dfs(1,1,1,0);
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：zhangxiao666 (赞：3)

### 题意：
[题目传送门](https://www.luogu.com.cn/problem/P1585)

可以看做一个人手中有一些宝石，并将宝石分成两组，一组的编号为 $1$ 至 $\frac{n\times m}{2}$，二组为 $\frac{n\times m}{2}+1$  至 $n\times m+1$。当两组两个宝石编号相差为 $\frac{n\times m}{2}$ 为一对。现在要遍历一个 $n\times m$ 的方阵，只能走上下左右，且每个格子必须且仅能到过 $1$ 次。并在遍历同时对每一个格子放入宝石。即遍历的第 $i$ 个格子放入编号为 $i$ 的宝石。

对于一对宝石，如果第一组的宝石在第 $x1$ 行第 $y1$ 列，第二组宝石的在第 $x2$ 行第 $y2$ 列，则称它们的分值为 $k1\times  \operatorname{abs}(x1-x2)+k2\times  \operatorname{abs}(y1-y2)$。

现在要找出一种遍历顺序，使分值最大一对宝石分值最小，输出这个最小的最大分值。

### 思路:
看到是遍历，且数据范围非常小，考虑用 dfs。不过如果不加剪枝优化的爆搜，肯定会 TLE 飞，因此考虑剪枝。

首先是一个很好想的最优化剪枝：如果当前记录的最大值已经比之前的方案大了，那就不可能更新答案，没必要搜索，直接
返回。

但只有这一个剪枝还不行，我们发现题目中一个很重要的事：**每个格子必须且仅能到过 $1$ 次**。因此当发现已经不可能满足要求的时候，便可以直接返回。

那如何判断呢？

当一个现在这个点的上下走过且左右没走，或者左右走过上下没走，则不能满足要求。

因为当上下走过时，他们所联通的路线一定将左右分别能到达的点分隔成两个连通块，左右走过上下没走也是同理。

画个图方便理解一下：

![](https://cdn.luogu.com.cn/upload/image_hosting/jlmkmxzl.png)

有了这些就可以愉快的写代码了。

### 代码：

请勿抄袭。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k1,k2;
//与题目中意义一致 
int ans=1e10;//记录答案 
int dx[4]={1,0,-1,0};
int dy[4]={0,1,0,-1}; //移动的方向数组 
bool f[61][61];//记录是否被走过 
int q[2500][2];//记录第一组宝石所在的点 
inline void dfs(int x,int y,int p,int mmax)
//x,y：当前点的坐标，p：搜到的宝石编号，mmax:目前的最大的分数
{
	if(mmax>=ans) return;//最优性剪枝 
	if(f[x+1][y]&&f[x-1][y]&&!f[x][y+1]&&!f[x][y-1]) return;
	if(f[x][y+1]&&f[x][y-1]&&!f[x+1][y]&&!f[x-1][y]) return;
	//两种不可能完成遍历的情况 
	if(p<=n*m/2) q[p][0]=x,q[p][1]=y;//第一组，直接存储 
	else//第二组，开始计算 
	{
		mmax=max(mmax,(k1*abs(x-q[p-(n*m/2)][0])+k2*abs(y-q[p-(n*m/2)][1])));//根据公式求值 
	} 
	if(p==n*m)//搜索完了 
	{
		if(mmax<ans) ans=mmax;//能更新答案则更新 
		return;
	}
	for(int i=0;i<4;i++)//继续向能走到的点搜索 
	{
		int xx=x+dx[i];
		int yy=y+dy[i];
		if(!f[xx][yy])//没走过，可以走 
		{
			f[xx][yy]=1;//标记 
			dfs(xx,yy,p+1,mmax);
			f[xx][yy]=0;//回溯 
		}
	}
}
int main()
{
	scanf("%d%d%d%d",&n,&m,&k1,&k2);
	for(int i=0;i<=n+1;i++) f[i][0]=1,f[i][m+1]=1; 
	for(int i=0;i<=m+1;i++) f[0][i]=1,f[n+1][i]=1;
	//上面两个循环是边界处理，因为不能走出方阵，所以将边界设为1，防止出界 
	f[1][1]=1;
	dfs(1,1,1,0);//从1,1点开始搜索 
	printf("%d\n",ans);//输出 
	return 0;
} 
```

写题解不易，点个赞呗。

---

## 作者：封禁用户 (赞：2)

本题的主要思想就是dfs剪枝


然而被题目坑了很久，注意这句“魔法阵是一个n×m的格子（高n，宽m）”


剪枝的方法即最优化和可行性剪枝楼主的意思已经讲明白了

**
var i,p,n,j,m,k1,k2,res:longint;//p表示（n\*m)/2;res存最终的答案

vis:array[0..51,0..51] of boolean;//表示该点是否放了宝石

opx,opy:array[0..2500] of longint;//存储第1-（n\*m）/2颗宝石的位置

dx:array[1..4] of integer=(0,1,0,-1);//dx,dy存储上左下右四个方向的坐标位移量

```cpp
    dy:array[1..4] of integer=(1,0,-1,0);
function max(x,y:longint):longint;//考试时都不敢开math
begin if x>y then exit(x);exit(y);end;
function min(x,y:longint):longint;
begin if x<y then exit(x);exit(y);end;
procedure dfs(i,x,y,ans:longint);//深搜
var num,x1,y1,i1,ans1:longint;
    f1,f2,f3,f4:boolean;//表示当前点上下左右是否被访问过
begin
  num:=i mod p; ans1:=ans;//num是该点编号
  if i<=p then//存坐标
    begin
      opx[num]:=x;
      opy[num]:=y;
    end
  else//计算第（n*m)div 2--（n*m）颗宝石的影响值
    begin
      ans1:=max(ans1,k1*abs((x-opx[num]))+k2*abs((y-opy[num])));
      if ans1>res then exit;//最优化剪枝，与之前几种方案的最小影响值比较，若已超过就退出
    end;
  if i=n*m then//更新res
    begin
      res:=min(res,ans1);
      exit;
    end;
  f1:=vis[x-1][y]; f2:=vis[x+1][y];
  f3:=vis[x][y-1]; f4:=vis[x][y+1];
  if (f1=f2)and(f3=f4) then//可行性剪枝
    begin
      if (f1 and f2)<>(f3 and f4) then exit;//如果如果当前位置只能向上走和向下走或只能向左走和向右走，则返回
      if (f1 and f2)and(f3 and f4) then exit;
    end;
  for i1:=1 to 4 do//深搜上下左右四个点
    begin
      x1:=x+dx[i1];y1:=y+dy[i1];//下一个点的坐标
      if (x1 in [1..n])and(y1 in [1..m])and(not vis[x1][y1])then//在范围内且未被访问
        begin
          vis[x][y]:=true;
          dfs(i+1,x1,y1,ans1);//递归回溯
          vis[x][y]:=false;
        end;
    end;
end;
begin
  readln(n,m,k1,k2);   res:=maxlongint;
  p:=(n*m)div 2;   fillchar(vis,sizeof(vis),true);
  for i:=1 to n do
    for j:=1 to m do vis[i][j]:=false;
  vis[1][m]:=true;//将边界和起始点赋为true
  dfs(1,1,m,0);
  writeln(res);
end.**
```

---

## 作者：MilkyCoffee (赞：1)

[可能更好的阅读体验](https://www.cnblogs.com/milkycoffee/p/p1585-sol.html)

首先题目目害qwq

数据范围是 $n\times m \le 50$，所以考虑搜索. ~~其实是因为这道题出现在搜索题单里~~

就是正常的搜索，题目中的起点在右上角，所以其实可以当起点在左上角来做，剪枝分可行性剪枝和最优性剪枝两种，可行性剪枝是判断是否处于一个单向通道中（上下走过左右没走过或上下没走过左右走过），最优性剪枝当然就是如果当前答案比最优答案大就可以直接不搜了。

细节处理有点多，但其实还好，调一会就调出来了。

```cpp
const int NR = 55;
const int MR = 4e3 + 5;

int n, m, k1, k2;
int vis[NR][NR], px[MR], py[MR];
int ans = 1e9;

int dx[4] = {0, 1, 0, -1};
int dy[4] = {1, 0, -1, 0};

int calc(int x1, int y1, int x2, int y2) {
    return k1 * abs(x1 - x2) + k2 * abs(y1 - y2);
}

void init() {
    memset(vis, 1, sizeof(vis));
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            vis[i][j] = 0;
        }
    }
    vis[1][1] = 1;
}

void dfs(int x, int y, int s, int v) {
    if (vis[x+1][y] && vis[x-1][y] && !vis[x][y+1] && !vis[x][y-1]) return ;
    if (!vis[x+1][y] && !vis[x-1][y] && vis[x][y+1] && vis[x][y-1]) return ;

    // cout << vis[x+1][y] << endl;

    int res = 0;
    if (s <= n * m / 2) {
        px[s] = x; py[s] = y;
    } else {
        res = calc(x, y, px[s-n*m/2], py[s-n*m/2]);
    }

    if (v >= ans) return ;
    if (s == n * m) {
        ans = min(ans, max(v, res));
        return ;
    }

    for (int i = 0; i < 4; i++) {
        if (vis[x+dx[i]][y+dy[i]] == 0) {
            vis[x+dx[i]][y+dy[i]] = 1;
            dfs(x + dx[i], y + dy[i], s + 1, max(v, res));
            vis[x+dx[i]][y+dy[i]] = 0;
        }
    }
}

int main() {
    scanf("%d%d%d%d", &n, &m, &k1, &k2);

    init();

    dfs(1, 1, 1, 0);
    
    cout << ans << endl;

    return 0;
}
```

------

上课的时候老师讲这道题时我还在调上一道题，导致思路没有听见 TAT

然后大家做题的时候就直接摆烂，主动放弃，没有想到可行性剪枝 qwq

---

## 作者：Supor__Shoep (赞：0)

不为人知的，这道题坑了我很久……

首先打一个简单的暴搜代码，这样你就得到了 $70pts$。

由于暴搜的时间花费太长，所以我们需要考虑一下剪枝的策略。

![](https://cdn.luogu.com.cn/upload/image_hosting/y96fh93h.png)

如图，我们创造一个 $3\times 5$ 的地图，然后根据没有打括号的标号顺序走下来。当我们走到 $9$ 的时候，我们假设接下来走到有括号的 $10$ 上，这个时候我们明显会发现下一步对应了两个选择，同时也是两个隔离开的区域。如果想要一笔画完，是不可能的，而 $(11)$ 同理。

这个时候我们就有了新的想法，如果走到一个点，发现上下走过，左右未走，或者左右走过，上下未走，那么就代表着你一定划分出了两个隔离开的区域，这两个区域是不相连的，由于一笔不能画出两个不相交的图形，所以遇到这种情况一定是无解的。

然后我信誓旦旦地交上去，可是 $70pts$ 依旧。这是为什么呢？

在判断是否在边界范围内的时候，我们用到了 $x$ 和 $y$ 与边界进行比较，但是我们走的时候如果判断太多次，可能导致某些因素的超时，于是乎我们直接把判断放在 $vis$ 数组里面，把边界的坐标赋初值为 $1$，这样就可以省略与边界的比较，直接判断 $vis[tx][ty]$ 是否合法就可以了。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k1,k2;
int dirx[4]={1,-1,0,0};
int diry[4]={0,0,1,-1};
bool vis[55][55];
struct node
{
	int x,y;
}l[55];
int ans=INT_MAX;
void dfs(int x,int y,int times,int maxx)
{
	if(vis[x-1][y]&&vis[x+1][y]&&!vis[x][y+1]&&!vis[x][y-1])	return;
    if(vis[x][y-1]&&vis[x][y+1]&&!vis[x+1][y]&&!vis[x-1][y])	return;
	if(times<=n*m/2)
	{
		l[times].x=x;
		l[times].y=y;
	}
	else	maxx=max(maxx,k1*abs(l[times-n*m/2].x-x)+k2*abs(l[times-n*m/2].y-y));
	if(times>=n*m)
	{
		ans=min(ans,maxx);
		return;
	}
	if(maxx>=ans)	return;
	for(int i=0;i<4;i++)
	{
		int tx=x+dirx[i];
		int ty=y+diry[i];
		if(!vis[tx][ty])
		{
			vis[tx][ty]=1;
			dfs(tx,ty,times+1,maxx);
			vis[tx][ty]=0;
		}
	}
}
int main()
{
	scanf("%d%d%d%d",&n,&m,&k1,&k2);
	for(int i=0;i<=m+1;i++)
    {
    	vis[0][i]=1;
    	vis[n+1][i]=1;
    }
    for(int i=0;i<=n+1;i++)
    {
        vis[i][0]=1;
        vis[i][m+1]=1;
    }
	vis[1][1]=1;
	dfs(1,1,1,0);
	printf("%d",ans);
	return 0;
}
```

---

## 作者：YunJ (赞：0)

本题第一眼看是一个规律题，但很遗憾没有靠谱的多项式做法，再结合数据范围$n \times m \le50$，数据范围较小，可以确定是一个DFS的题目。

设$l = n \times m $，则可能的行走方式总数为$3^l$，显然无法通过。

我们可以先利用几个结论：

1. 起点$(1,m)$和起点$(1,1)$出发，对答案没有任何影响。  
证明：将每个点$(i,j)$替换为$(i,m-j+1)$，答案不变。
2. 在一笔画问题中，两种可以直接舍去，不可能画出可能解的情况（可行性减枝）：  
情况$1$：当前格子左右均已走过，上下都未走过。   
情况$2$：当前格子上下均已走过，左右都未走过。 
![](https://cdn.luogu.com.cn/upload/image_hosting/xgsald16.png)
  
3. 题目求所有情况最大权值的最小值，因此求出大于当前答案的解时可以直接省去（最优性剪枝）。

综上，我们可以写出一个符合复杂度的做法。   

$Code:$  
（为节省空间，快读快输均已删除，其中`read(a)`代表输入，`write(a)`代表输出。）
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define inf 1000000000000

ll n,m,k1,k2,kk,x,y;
ll ans;
ll fax[55],fay[55];
bool f[55][55];
ll fw[4][2]={{1,0},{0,-1},{0,1},{-1,0}};

void cl()//初始化
{
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			f[i][j]=1;//预处理：将可以取到的所有位置f[i][j]赋值为1，也就可以一并判断边界。
		}
	}
   f[1][1]=0;
}

void dfs(ll k,ll na)
{	
    if(!f[x-1][y]&&!f[x+1][y]&&f[x][y+1]&&f[x][y-1]) return;
	if(f[x-1][y]&&f[x+1][y]&&!f[x][y+1]&&!f[x][y-1]) return;
    
	//利用一笔画问题结论
    
	if(k>(n*m/2))
	{
		kk=k-(n*m/2);
		na=max(na,k1*abs(x-fax[kk])+k2*abs(y-fay[kk]));//统计当前状态答案
		if(na>=ans) return;//利用最优性问题结论
	}
	else
	{
		fax[k]=x; fay[k]=y;//记录下该位置坐标
	}
	if(k>=n*m)
	{
		ans=min(ans,na);
		return;
	}
	for(int j=0;j<4;j++)
	{
		x+=fw[j][0]; y+=fw[j][1];
		if(f[x][y])
		{
			f[x][y]=0;
			dfs(k+1,na); //递归至下一格子
			f[x][y]=1;
		}
		x-=fw[j][0]; y-=fw[j][1];
	}
}

int main()
{
	ans=inf; x=1; y=1; cl();
	read(n); read(m); read(k1); read(k2);
	dfs(1,0);
	write(ans);
	return 0;
}
```

---

## 作者：一只书虫仔 (赞：0)

#### Description

> 给定一个 $n \times m$ 的矩阵，从右上角开始走，每走到一个格子就放入一枚金币，两枚金币 $(x_1,y_1),(x_2,y_2)$ 会产生影响当且仅当设他们分别是第 $t_1,t_2$ 放入的，$t_1 \bmod \frac{n \times m}2=t_2 \bmod \frac{n \times m}{2}$，影响值为 $k_1 \times |x_1-x_2| +k_2 \times |y_1-y_2|$，整个矩阵的价值为所有影响值的最大值。求价值的最小值。

#### Solution

说剪枝之间说亿点代码的细节，首先算挪到这个位置的影响大小，如果 $step \le \frac{n \times m}{2}$ 就不用考虑（但是得标记位置），否则就找到位置并计算影响。

然后是处理到没到过，可以考虑先把 $vis$ 都赋成 true 再把 $(1,1) \sim (n,m)$ 赋成 false。

最后注意从右上角 $(1,m)$ 开始走。

直接爆搜，不能接受，考虑剪枝。

首先套一个最优性剪枝，另 dfs 函数 $f$ 为 $f(x,y,step,v)$，如果目前答案 $v+p\ge \min$ 就直接 return。

然后考虑可行性剪枝，如果走到这里把整个矩阵分成了大于等于两个连通块，那么拐进任意一个连通块里都无法到达另外一个连通块，所以这块需要减掉。怎么判断呢？如果一个格子的上下已经走过，左右未走过，那么代表这个格子要不就是已经走过的要不就是路径绕了一圈又回来了，就会形成大于等于两个连通块，是要剪掉的，同理，左右已经走过上下未走过也是这样的。

这样就是可以通过了的。

---

## 作者：demon_yao (赞：0)

这是开学前最后一篇题解QAQ（窝不要上学QAQ）
### 题目大意
- 给定一个$N*M$的矩阵，与$k1$,$k2$，你一开始在右上角

- 你要恰好经过每个格子一次。

- 设第$i$步你在$(a,b)$，第$i+(N*M/2)$步你在$(c,d)$记$Ai(i<=N*M/2)$为$k1×|a-c|+k2×|b-d|$。你需要求出所有方案中，所有$Ai$的最大值的最小值。

### 思路
很明显这是一道搜索题。我们考虑dfs。步骤大致是这样

1. 对于前$N*M/2$步，我们只记录状态。记$cal[sum][0]$,$cal[sum][1]$为走第$sum$步时的横纵坐标。方便后面进行运算。

2. 对于后$N*M/2$步，我们计算。这里就不多说了直接套公式即可。

### 注意点

- 显然暴搜会$T$飞,所以我们要做几个剪枝

- 最优化剪枝：如果当前最大值的最小值已经大于目前大最优值,那么直接return，因为已经没有搜下去的必要了。

- 可行性剪枝：若当前上下都走过或左右都走过，直接return，因为此时无论如何都不可能遍历全图了（手模一下就明白了）

code很简单qwq！
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k1,k2,half,ans=20000086;
int vis[66][66],cal[66][66];
int fx[8]={-1,1,0,0,-1,-1,1,1};
int fy[8]={0,0,-1,1,-1,1,-1,1};
void dfs(int x,int y,int sum,int maxn)
{
	if(vis[x][y+1]&&vis[x][y-1]&&!vis[x+1][y]&&!vis[x-1][y]) return;
	if(vis[x+1][y]&&vis[x-1][y]&&!vis[x][y+1]&&!vis[x][y-1]) return;
	
	if(sum<=half){
		cal[sum][0]=x;cal[sum][1]=y;
	}
	else maxn=max(maxn,(k1*abs(cal[sum-half][0]-x)+k2*abs(cal[sum-half][1]-y)));
	if(sum>=n*m){ans=min(ans,maxn);return;}
	if(maxn>ans) return;
	for(int i=0;i<4;i++){
		int xx=x+fx[i],yy=y+fy[i];
		if(!vis[xx][yy]){
			vis[xx][yy]=1;
			dfs(xx,yy,sum+1,maxn);
			vis[xx][yy]=0;			
		}
	}
}
int main()
{
	cin>>n>>m>>k1>>k2;
	half=n*m/2;
	for(int i=0;i<=n+1;i++) vis[i][0]=1;
	for(int i=0;i<=n+1;i++) vis[i][m+1]=1;	
	for(int i=0;i<=m+1;i++) vis[0][i]=1;
	for(int i=0;i<=m+1;i++) vis[n+1][i]=1;	
	vis[1][1]=1;
	dfs(1,1,1,0);
	cout<<ans;
	return 0;
}
```


---


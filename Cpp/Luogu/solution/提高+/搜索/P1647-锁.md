# 锁

## 题目描述

给出 $N$ 和 $K$，要求生成从 $0$ 到 $2^N-1$ 的一个序列，序列的第一项为 $0$，并且该序列满足以下三个条件：

1. 序列长度为 $2^N$，保证 $0$ 到 $2^N-1$ 的每个数都用了且只用了一次。
2. 序列中任意两相邻的数都是由前一个数在其二进制下，改变了具有相同值的若干个位而形成的，即把其中若干个 $0$ 变为 $1$，或把其中若干个 $1$ 变为 $0$，并且只能二选一。
3. 当存在多个序列满足前两个条件的时候，要保证字典序最小，即由前一个数生成后一个数的时候，要挑值最小的数（当然是满足前两个条件的情况下）。

现问你这个序列前 $K$ 项中的最大值是多少，输出其二进制形式，注意一定要输出 $N$ 位，包括前导零。

## 说明/提示

### 样例解释

生成的序列为 $[000,001,011,010,110,100,101,111]$。前 $8$ 项当中的最大值为 $111$。

### 数据范围及约定

对于全部数据，$1 \le N \le 50,1 \le K \le 2^N$。

## 样例 #1

### 输入

```
3 8```

### 输出

```
111```

# 题解

## 作者：gcwixsxr (赞：7)

本蒟蒻做这道题时,还只有一个题解,于是本蒟蒻也想分享一下自己的方法。

首先找一下规律:(以下01串均为二进制表示)

当 $n$ 为 $1$ 时, 满足要求的数据为 $0,1$。

当 $n$ 为 $2$ 时, 满足要求的数据为 $00,01,11,10$。

当 $n$ 为 $3$ 时, 满足要求的数据为 $000,001,011,010,110,100,101,111$。

可以发现,每 $2^n$ 个满足要求的数据中,从第 $2^{n-1}+2$ 个到第 $2^n$ 个数的数值分别等于第 $1$ 个到第$2^{n-1}-1$ 个数的数值加上 $2^{n-1} $ ,即 $num_{i+2^{n-1}+1}=num_{i}+2^{n-1}$ ,其中 $i \in[1, 2^{n-1}-1]$,而第 $2^{n-1}+1$ 个数的数值等于第 $2^{n-1}$ 个数加上 $2^{n-1}$ ,即 $num_{2^{n-1}+1}=num_{2^{n-1}}+2^{n-1}$ 。

举个栗子,当 $n$ 为 $3 $ 时,如下图,后 $3$ 个分别等于前 $3$ 个的数值加上 $4$ ,第 $5$ 个的值等于第 $4$ 个加 $4$;

![](https://cdn.luogu.com.cn/upload/image_hosting/wbvxza4d.png)

还不信?再看看 $n$ 为 $4$ 的时候:

当 $n$ 为 $4$ 时, 满足要求的数据为：
 $0000,0001,0011,0010,0110,0100,0101,0111$,$1111,1000,1001,1011,1010,1110,1100,1101$

同样是满足这个规律的,对吧,按照这个规律,可以算出 $1$ 到 $2^n$ 中的任何一个数。

按照此规律,能算出任何排名的数的函数如下。

```cpp
long long work(long long k){//求出排名第k的数的数值
	if(k==1)return 0LL;//如果是第一项,返回0
	if(k==2)return 1LL;//如果是第二项,返回1
	int t=0;long long kl=1;
	while(kl<k){
		kl<<=1;
		t++;
	}
	t--;kl>>=1;//算出小于k的最大2的次幂
	if(k-kl==1)return kl+work(k-1); 
	else return kl+work(k-kl-1);//这两句对应上方规律中的两个递推公式
}
```
那么,算出排名第 $k$ 的数有什么用呢?

这个时候要用到分治的思想了:

我们先看张图

![](https://cdn.luogu.com.cn/upload/image_hosting/d39nxeov.png)

假设我们要求前 $14$ 个中的最大值,即求 $\max(a_i),i\in[1,14]$,由于后 $8$ 个一定大于前 $8$ 个,又因为$a_{i}=a_{i-9}+8,i\in[10,14]$ ,并且 $a_9=a_8+8$ ,所以,问题就被转化成了求 $\max(a_i)+8,i\in[1,5]\cup\{8\}$,即求前 $5$ 个和第 $8$ 个的的最大值,因此上述的问题被转化到了下图中:

![](https://cdn.luogu.com.cn/upload/image_hosting/wbvxza4d.png)

求$\max(a_i)+8,i\in[1,5]\cup\{8\}$,第 $5$ 个一定大于前 $4$ 个,因此问题又被转化,即求$\max(a_5,a_8)+8$,(其实这个时候可以直接调用 $\texttt{work}$ 函数,但也可以继续递推下去),继续转化,$a_8=a_3+4,a_5=a_4+4$,问题变为求$\max(a_3,a_4)+12$.

![](https://cdn.luogu.com.cn/upload/image_hosting/zaqy7hfj.png)

来到最后一步,$a_3=a_2+2,a_4=a_1+2$,即求$\max(a_1,a_2)+14=15$,这时就可以输出答案辣!

像这样大事化小,小事化了,不就是分治吗?

求解函数;

```cpp

long long solve(long long k){
	if(k==1)return 0LL;//返回1
	if(k==2)return 1LL;//返回0
	int t=0;long long kl=1;
	while(kl<k){
		kl<<=1;
		t++;
	}
	t--;kl>>=1;
	if(k-kl==1)return kl+work(k-1);//如果是2次幂+1的形式,最大的就是自身
	else return (long long)kl+max(solve(k-kl-1),work(kl));//特判一下中间特殊的一项
}
```
最后是$AC$代码:

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
long long k;
long long work(long long k){
	if(k==1)return 0LL;
	if(k==2)return 1LL;
	int t=0;long long kl=1;
	while(kl<k){
		kl<<=1;
		t++;
	}
	t--;kl>>=1;
	if(k-kl==1)return kl+work(k-1);
	else return kl+work(k-kl-1);
}
long long solve(long long k){
	if(k==1)return 0LL;
	if(k==2)return 1LL;
	int t=0;long long kl=1;
	while(kl<k){
		kl<<=1;
		t++;
	}
	t--;kl>>=1;
	if(k-kl==1)return kl+work(k-1);
	else return (long long)kl+max(solve(k-kl-1),work(kl));
}
void write(long long x, int t){
	if(t-1) write(x>>1,t-1);
	putchar(x&1?'1':'0');
}
signed main(){
	scanf("%d%lld",&n,&k);
	write(solve(k),n);
	return 0;
}
```


---

## 作者：SCKer (赞：7)

### 分析
头痛的题，看起来毫无头绪，打个表找找规律吧（暴力有$60$分，可惜当时暴力都没有打）

大佬的话，应该直接看看下面的表就好了吧

二进制：
>1 : 0 1

>2 : 00 01 11 10 

>3 : 000 001 011 010 110 100 101 111 

>4 : 0000 0001 0011 0010 0110 0100 0101 0111 1111 1000 1001 1011 1010 1110 1100 1101 

>5 : 00000 00001 00011 00010 00110 00100 00101 00111 01111 01000 01001 01011 01010 01110 01100 01101 11101 10000 10001 10011 10010 10110 10100 10101 10111 11111 11000 11001 11011 11010 11110 11100 

十进制：

>1 : 0 1

>2 : 0 1 3 2

>3 : 0 1 3 2 6 4 5 7 

>4 : 0 1 3 2 6 4 5 7 15 8 9 11 10 14 12 13 

>5 : 0 1 3 2 6 4 5 7 15 8 9 11 10 14 12 13 29 16 17 19 18 22 20 21 23 31 24 25 27 26 30 28 

>6 : 0 1 3 2 6 4 5 7 15 8 9 11 10 14 12 13 29 16 17 19 18 22 20 21 23 31 24 25 27 26 30 28 60 32 33 35 34 38 36 37 39 47 40 41 43 42 46 44 45 61 48 49 51 50 54 52 53 55 63 56 57 59 58 62 


无论是十进制还是二进制，相信规律还是能找出来的吧。对此，本人先抛砖引玉，仅列出所用到几点（参考的二进制）：
1. 数的位置是确定的
2. 对于一个$n$位的二进制，最高位出现$1$的位置是$2^{n - 1} + 1$
3. 忽略掉$n$位二进制的最高位，发现位于$[1,2^{n - 1}]$的数与位于$[2^{n - 1} + 1, 2^n]$的数仅仅是由**前者整体右移一位（最后一位补至第一位）** 得来

$Eg.$
忽略掉最高位后明显分为两个相似的部分（没对齐就将就一下吧）

 $\quad \quad \quad(0)00 \quad (0)01  \quad (0)11  \quad (0)10$
 
$(1)10  \quad (1)00  \quad (1)01  \quad (1)11$

对此，可以考虑利用上述性质来解题了（找到规律的你们应该可以忽略掉下面的一大段废话了吧）：
1. 利用 **规律$2$** 找到前$k$位数中，二进制下第一个$1$的位置$x$（找最高的），然后去掉那些对应位置为$0$的（缩小查找的区间）。
2. 利用 **规律$3$** 递归处理后$x - 1$位

## 代码
```cpp
#include <cstdio>
#include <cstdlib>

#define IL inline
#define open(s) freopen(s".in", "r", stdin); freopen(s".out", "w", stdout);
#define close fclose(stdin); fclose(stdout);

using namespace std;

typedef long long ll;

IL ll read()
{
	ll sum = 0;
	int k = 1;
	char c = getchar();
	for(;'0' > c || c > '9'; c = getchar())
	if(c == '-') k = 0;
	for(;'0' <= c && c <= '9'; c = getchar())
		sum = sum * 10 + c - '0';
	return k ? sum : -sum;
}

int n;
ll m;
IL ll max_(ll x, ll y) { return x > y ? x : y; }

IL void wri(ll x, int t)
{
	if(t - 1) wri(x >> 1, t - 1);
	putchar(x & 1 ? '1' : '0');
}

IL ll power(int t)
{
	ll sum = 1;
	for(; t; --t) sum <<= 1;
	return sum;
}

//查找的区间[l, r]，由于long long范围，位运算算不出来，所以直接处理成2^x
IL ll get(ll l, ll r, ll k)
{
	k >>= 1;
	//边界
	if(r == 1) return 0;
	if(r == 2) return 1;
	ll sum = 0;
	for(;k >= r; k >>= 1);//找最高位的1
	l = max_(l, k | 1);
	
	l -= k + 1;
	r -= k + 1;
	//特殊处理一下左移
	if(!l)
	{
		if(l == r) sum = get(k, k, k); else 
		sum = max_(get(1, r, k), get(k, k, k));
	}else
	{
		sum = get(l, r, k);
	}
	
	return sum + k;//加上当前这一位的1
}

int main()
{
	open("lock")
	
	n = read();  m = read();
	
	//转化为二进制输出
	wri(get(1, m, power(n)), n);
	
	close
	return 0;
}
```

---

## 作者：一只小兔子 (赞：0)

分析已经到位了，有公式吗？

根据打表的题解，我们总结出以下3条规则：

记此**唯一**数列为第 $n$ 项为 $a_n$ （从 $a_0$ 开始计数）

1.首项 $a_0=0$

2.（规则2）当 $n=2^k$ 时， $a_{2^k}=2^k+a_{2^k-1}$

3.（规则3）否则，令 $n$ 的最高位为 $2^k$， $r=n-2^k$  ，有 $a_{2^k+r}=2^k+a_{r-1}$

------------

以下尽量从数学角度证明这些规则：（归纳法）

假设对 $n=2^k$ 项数列满足对任意 $0 \leq l \leq n$ ，第 $l$ 项和 $a_l$ 相同。

对于 $n=2^{k+1}$ 项数列的前 $2^k$ 项，要么和 $n=2^k$ 的数列相同（已经是最小解），要么存在某数既不小于 $2^k$ ，还在前 $2^k$ 项中。（显然不是最小的数列，保证数列相同）

考虑后 $2^k$ 项，其中第一项一定是前一项加 $2^k$ （为保证最小，除最高位变成1，其他均不变，得到规则2）。

第二项一定是 $2^k$ 。（这是后 $2^k$ 项最小值，当然选他，把前一项除最高位的其他1，全部变成0）

从此往后，除了最高位区别，低位和前 $2^k$ 项一致。（无论如何不能改变最高位，情况和前 $2^k$ 项一致，易得规则3）

为了保证数列最小，首项为0。（规则1，保证数列和 $a_n$ 相同）

证毕。

------------

最大值需要转换一下：

1.只有首项 $a_0=0$

2.当 $n=2^k$ 时， $a_{2^k}=2^k+a_{2^k-1}$ ，由于一定比前面所有项大，直接输出。

3.令 $n$ 的最高位为 $2^k$， $r=n-2^k$  ，有 $a_{2^k+r}=2^k+a_{r-1}$ ，发现从 $a_n$ 往前 $r-1$ 项和前 $r-1$ 项完全相同，最大值为 $max_{i=0}^{r-1}(a_i)+2^k$ ，别忘了和 $a_{2^k}$ 取最大值。（我们并没有证明 $a_{n} > a_{2^k}$ ，所以要取最大值）

然后注意输出格式，代码：

```cpp
#include<cstdio>//P1647
long long max(long long a,long long b){
	return a<b?b:a;
}
long long a(long long d){
	if(d==0)return 0;
	if((d&(-d))==d)return d+a(d-1);
	else{
		long long r,bmask=1;
		while(bmask<d)bmask<<=1;
		bmask>>=1;r=d-bmask;
		return bmask+a(r-1);
	}
}
long long amax(int d){
	if(d==0)return 0;
	if((d&(-d))==d)return d+a(d-1);
	else{
		long long r,bmask=1,cmp;
		while(bmask<d)bmask<<=1;
		bmask>>=1;r=d-bmask;
		cmp=a(bmask);
		return max(bmask+amax(r-1),cmp);
	}
}
void bitbump(long long k,int l){
	if(l)bitbump(k>>1,l-1);
	putchar('0'+(k&1));
}
int main(){
	long long n,k;scanf("%d%lld",&n,&k);--k;
	long long mm=cmax(k);
	bitbump(mm,n-1);
}
```


---


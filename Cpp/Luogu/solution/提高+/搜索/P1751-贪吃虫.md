# 贪吃虫

## 题目背景

我们都知道一个很著名的游戏——贪吃蛇。它的一大特点是当前一个食物被吃掉后，后一个食物才会出现。今天我们要做的另一个游戏——贪吃虫也很类似。


## 题目描述

贪吃虫有 $k$ 条，在一棵有 $n$ 个节点的树上，每只虫子都在不同的节点上。第一个食物到来时，所有的 $k$ 只虫会从它们当前的位置出发，前往食物的位置。它们的移动遵循如下规则：

- 这棵树上的任何两个节点之间有且仅有一条路，所有的贪吃虫沿着唯一的路径前往食物所在的位置；
- 如果有一只贪吃虫到达了食物所在的位置，食物马上就被吃掉了；
- 如果有另外一只贪吃虫在某一只贪吃虫通往食物的道路上，那么距离食物较远的那只虫子会停止移动，停留在当前的节点上；
- 如果有多只虫子尝试进入同一个节点，只有编号最小的虫子能够到达，其它的贪吃虫停留在它们当前的位置上；
- 吃掉食物的那只虫子会停留在食物的位置上；
- 食物被吃掉之后会出现在树上的另外一个节点上。这时所有的贪吃虫会重新出发，尝试再一次吃掉食物。为了简化过程，我们假设从一个节点移动到相邻的节点需要花费一个单位时间。


## 说明/提示


### 数据范围及约定

对于全部数据，$1 \le n \le 5000$，$1 \le k \le 1000$，$k \le n$，$1 \le h \le 500$。

## 样例 #1

### 输入

```
4
1 2
1 3
2 4
2
1
2
2
2
4```

### 输出

```
1 0
4 2
```

# 题解

## 作者：zhangxiao666 (赞：14)

### 题意：
[题目传送门](https://www.luogu.com.cn/problem/P1751)

+ 在一棵 $n$ 个结点的树上，有 $k$ 个贪吃虫去吃食物。
+ 每个贪吃虫都走到达食物的唯一路径。
+ 当一条贪吃虫通向食物的道路上有另一条贪吃虫，则较远的那只停止移动。
+ 多条贪吃虫要进入同一节点时，编号最小的才能进入，其他的停止移动。
+ 贪吃虫的移动速度皆为 $1$。一只贪吃虫吃到食物后，另一个食物立刻出现在树上，贪吃虫继续按以上规则移动。
+ 最后求出每条贪吃虫所在的位置与吃到食物的数量。

### 思路：
可以把每一个食物看成一个测试点。那么就是要计算出每个节点被哪条贪吃虫占领和每条贪吃虫最终停留的地方。

很明显，对于这两个要计算的值，可以通过两次 dfs 来求。

第一次 dfs。对于每一个节点，占领它的贪吃虫一定是到达用时最短的那个。到达它的最短的时间就是最短的子节点到达时间 $+1$。还要注意两种特殊情况，在代码里也会有说明：

1. 该点已有贪吃虫。

1. 有速度相同，取编号最小的贪吃虫。

结束后把占领食物所在节点的贪吃虫吃到的食物数 $+1$。

第二次 dfs 时，可以利用第一次求出的值取计算。因为在第一次 dfs 时，我们求出了占领每个节点所用的时间，所以可以用一个数组去记录每一条贪吃虫到达最终落脚点的时间，这个值是可以算出的。如果对于某个节点，占据他的贪吃虫到达最终落脚点的时间 $=$ 该节点被占领的时间，则该节点为这条贪吃虫的最终落脚点。

### 代码：
请勿抄袭。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,h;
//n,k,h与题中含义一致 
struct stu{
	int nxt,to;
}e[10010];
int cnt;
int head[10010];
//以上为链式前向星存图 
int b[5001];//每一条贪吃虫所在节点 
int p[5001];//每个节点上为哪条贪吃虫，0表示没有贪吃虫 
int c[501];//每一次食物出现的地方 
int eat[5001];//每条贪吃虫吃的食物数 
int t[5001];//占领每个节点的时间 
int o[5001];//每个节点被占据的贪吃虫编号 
int f[5001];//题解中第二次搜索用来记录的数组 
inline void add(int x,int y)//建边 
{
	e[++cnt].nxt=head[x];
	e[cnt].to=y;
	head[x]=cnt;
}
inline void dfs1(int now,int fa)//第一次搜索，求出每个节点被哪条贪吃虫占据 
//now为当前搜索到的节点，fa为上一次搜索的节点，避免重复搜索 
{
	int mp,mt;//记录占领该节点的时间与贪吃虫编号 
	if(p[now])//该点上已有贪吃虫 
	{
		mp=p[now];//占领的贪吃虫即为该节点上的贪吃虫 
		mt=0;//占领速度为0 
	}
	else //否则因为要取最小值，所以设一个大的数 
	{
		mp=9999;
		mt=9999;
	}
	for(int i=head[now];i;i=e[i].nxt)//依次搜索每一个儿子 
	{
		int to=e[i].to;
		if(to==fa) continue;//避免重复搜索 
		dfs1(to,now);
		if((t[to]+1)<mt||((t[to]+1)==mt&&o[to]<mp))
		//时间更短或时间相同并且编号较小即可更新 
		{
			mt=t[to]+1;
			mp=o[to];
		}
	}
	t[now]=mt;
	o[now]=mp;
	//保存计算后的值 
}
inline void dfs2(int now,int fa)//第二次搜索，计算每一只贪吃虫最终落脚点 
//参数意义与dfs1一致 
{
	if(o[now]!=9999)//=9999说明没有贪吃虫来过，没必要计算 
	{
		if(f[o[now]]==-1&&o[fa]!=o[now])
		//没有计算过，后面的条件是因为贪吃虫一样，那么f[o[now]]没计算过，f[o[fa]]也一定没计算过 
		{   //计算，取三种可能时间的最小值 
			int mt=min(t[fa],t[now]);
			f[o[now]]=min(f[o[fa]],mt);
		}
		if(f[o[now]]!=-1&&f[o[now]]==t[now]) b[o[now]]=now;//计算过且时间一致，则该点为这条贪吃虫的最终落脚点 
	}
	for(int i=head[now];i;i=e[i].nxt)//继续搜索子节点 
	{
		int to=e[i].to;
		if(to==fa) continue;//同理，防重 
		dfs2(to,now);
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<n;i++)//读入这棵树，并建树（边） 
	{
		int x,y;
		scanf("%d%d",&x,&y);
		add(x,y);
		add(y,x);//建双向边 
	}
	scanf("%d",&k);
	for(int i=1;i<=k;i++)//记录每一条贪吃虫的位置 
	{
		int x;
		scanf("%d",&x);
		p[x]=i;
		b[i]=x;//按照数组含义记录 
	}
	scanf("%d",&h);
	for(int i=1;i<=h;i++)//读入每一次食物出现的位置 
	{
		scanf("%d",&c[i]);
	}
	for(int i=1;i<=h;i++)
	{
		memset(t,0,sizeof(t));
		memset(o,0,sizeof(o));
		memset(f,-1,sizeof(f));//由于数组内还有上一次循环的值，因此将其初始化 
		dfs1(c[i],-1);//搜索 
		++eat[o[c[i]]];//将吃到食物的贪吃虫更新 
		f[o[c[i]]]=t[c[i]];//吃到食物的贪吃虫最终落脚点即为食物处
						   //因此到达最终落脚点的位置即为到达食物的位置
						   //这里也是为了下面的搜索的计算 
		dfs2(c[i],-1);
		memset(p,0,sizeof(p));//由于这一轮过后贪吃虫又有了新的位置，因此先将旧的清零，并更新 
		for(int j=1;j<=k;j++)
		{
			p[b[j]]=j;
		}
	}
	for(int i=1;i<=k;i++)//输出答案 
	{
		printf("%d %d\n",b[i],eat[i]);
	}
	return 0;
}
```

写题解不易，点个赞呗。

---

## 作者：litc (赞：11)

每一次，我们可以把食物的每次出现当做一个测试点，上一个测试点的输出作为下一个测试点的输入。这样，我们的问题就简化为：如何快速计算出每只虫子在食物降临后的位置。如果我们逐步模拟，就会超时。这里我们可以考虑以食物所在节点为根，进行两遍DFS处理：

 第一遍DFS 可以计算出每个节点多少步之后会被贪吃虫占据，以及被哪只贪吃虫占据。

 第二遍DFS 的时候，我们就可以计算出每只贪吃虫会走到哪个地方停止：搜索到某个节点，若最先占据该点的虫子没有被访问过，则此处为虫子的最后落脚点，并把该虫子标记为已访问。这样我们就能在O(n)内解决一次询问，总时间复杂度为O(nk)


---

## 作者：zhuhongming666 (赞：8)

## 思路：

快速计算出每只虫子在食物降临后的位置（以食物节点为根）。

第一遍 DFS：计算每个节点 k 步后被贪吃虫 w 占据。

第二遍 DFS：计算贪吃虫 w 走 t 步到 pos 停止。

搜索到节点 u ，若最先占据该点的虫子 w 没有被访问过，则此处为虫子的最后落脚点，并把该虫子标记为已访问。
## AC代码：
```
#include<bits/stdc++.h>
const int N=5015,K=1003;
int n,hd[N],nx[N*2],vt[N*2],cnt,k,psw[N],ans[K];
void add(int u,int v){++cnt;nx[cnt]=hd[u];vt[cnt]=v;hd[u]=cnt;}
int occ[N],tim[N],last[K],cpos[K],opos[K];
void formtree(int u,int fa){
    int nwrm,ntim,vwrm,vtim;
    if(psw[u])nwrm=psw[u],ntim=0;
    else nwrm=9999,ntim=9999;
    for(int i=hd[u];i;i=nx[i])if(vt[i]!=fa){
        formtree(vt[i],u);vwrm=occ[vt[i]],vtim=tim[vt[i]]+1;
        if(vtim<ntim||(vtim==ntim&&vwrm<nwrm))nwrm=vwrm,ntim=vtim;
    }
    occ[u]=nwrm;tim[u]=ntim;
}
void scantree(int u,int fa){
    int wmcu=occ[u],tlast,wmfa,wlast;
    if(wmcu!=9999){
        if(last[wmcu]==-1&&occ[fa]!=wmcu){
            wmfa=occ[fa];
            tlast=tim[fa]>tim[u]?tim[u]:tim[fa];
            wlast=last[wmfa];
            if(wlast<tlast)tlast=wlast;
            last[wmcu]=tlast;
        }
        if(last[wmcu]!=-1&&tim[u]==last[wmcu])cpos[wmcu]=u;
    }
    for(int i=hd[u];i;i=nx[i])if(vt[i]!=fa){
        scantree(vt[i],u);
    }
}
int main(){
    scanf("%d",&n);int a,b;
    for(int i=1;i<n;++i)scanf("%d%d",&a,&b),add(a,b),add(b,a);
    scanf("%d",&k);
    for(int i=1;i<=k;++i)scanf("%d",&a),psw[a]=i,opos[i]=a;
    scanf("%d",&a);
    for(int i=1;i<=a;++i){
        memset(occ,0,sizeof(occ));
        memset(tim,0,sizeof(tim));
        memset(last,-1,sizeof(last));
        scanf("%d",&b);
        formtree(b,-1);
        ++ans[occ[b]];last[occ[b]]=tim[b];
        scantree(b,-1);
        memset(psw,0,sizeof(psw));
        for(int i=1;i<=k;++i)opos[i]=cpos[i],psw[opos[i]]=i;
    }
    for(int i=1;i<=k;++i)printf("%d %d\n",opos[i],ans[i]);
    return 0;
}
```


---

## 作者：wangshulin (赞：3)

# 前言
本蒟蒻实在看不懂大佬的题解，只知道每次要用两遍 DFS 操作，反复摸索后终于找到思路。我将以蒟蒻的角度讲解题目让大家都能看懂。
# 思路
1. 先假设虫子在看到前方有虫子时**不会停顿**，使用一次 DFS 求出**虫子通往食物**的路径上每个点将最先被哪个虫子占据和最先占据它的虫子用了几步到达它（后者简称步数）。次 DFS 将本次降临的食物作为起点，遍历整个图：
- 当遇到初始（指本次投放食物前）就有虫子的点，将最先占据它的虫子设为这个虫子，步数为 $0$。
- 否则将步数设为这个点连接的每个点（除了上一个遍历的点）的步数的最小值加一，将最先占据它的虫子设为最先占据“步数等于最小步数的这些点”的虫子中编号最小的那个虫子，（注：本操作在遍历完后续点后完成）。

2. 再使用一次 DFS 将多走的虫子回退到它停止移动的位置，也从本次降临的食物作为起点。可以发现，当占据当前节点的虫子与占据上一个节点的虫子（**DFS 遍历的顺序**）不同时，证明上一个节点的虫子比本节点的虫子要快，本节点的虫子在走了“上一个节点的步数”步后便会看见它并停止移动。

可以根据以上过程自己拿样例模拟一遍操作过程。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int x,y,next;
}p[10005];
int cnt,h[5005];
//邻接表 
int n,m,l,a,b;
int id[5005];//每个点上虫子的编号，没有则为0 
int point[5005];//本次食物降临后最先被那个虫子占据 
int dis[5005];//本次食物多少步后最先被虫子占据（最先占据它的虫子在几步后到达它） 
int ans[5005];//每个虫子分别吃掉了几个食物 
int ansp[5005];//每个虫子最终的位置 
bool f[5005];//见35行
void in(int x,int y){//邻接表载入数据 
	p[++cnt].x=x,p[cnt].y=y;
	p[cnt].next=h[x],h[x]=cnt;
}
void dfsmake(int pos,int lpos){
	if(id[pos]) point[pos]=id[pos],dis[pos]=0;//当此位置初始有虫子 
	for(int k=h[pos];k;k=p[k].next){ 
		int y=p[k].y;
		if(y==lpos) continue;
		dfsmake(y,pos);
		if(point[y]==151587081) continue;//151587081是memset(  ,9,  )的初始值 
		if(dis[y]+1<dis[pos]||(dis[y]+1==dis[pos]&&point[y]<point[pos])){//时间更短或编号更小就更新 
			point[pos]=point[y],dis[pos]=dis[y]+1;
		}
	}
}
void dfsturn(int pos,int lpos){
	if(point[pos]==151587081) return ;
	if(point[pos]!=point[lpos]&&dis[pos]>dis[lpos]){
		point[pos]=point[lpos],dis[pos]=dis[lpos];//将dis[lpos]的值传入dis[pos]，巧妙地表示point[pos]还没回退到指定位置，下一轮又会检测到而更新 
	}else if(!f[point[pos]]){//当point[pos]这个虫子的最终位置没被记录过 
		id[pos]=point[pos];
		f[point[pos]]=1;
	}
	for(int k=h[pos];k;k=p[k].next){
		int y=p[k].y;
		if(y==lpos) continue;
		dfsturn(y,pos);
	}
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<n;i++){
		scanf("%d%d",&a,&b);
		in(a,b),in(b,a); 
	}
	scanf("%d",&m);
	for(int i=1;i<=m;i++){
		scanf("%d",&a);
		id[a]=i;
	}
	scanf("%d",&l);
	for(int i=1;i<=l;i++){
		scanf("%d",&a);
		memset(point,9,sizeof(point));
		memset(dis,9,sizeof(dis));
		dfsmake(a,0);//第一遍 DFS 
		memset(id,0,sizeof(id));
		memset(f,0,sizeof(f));
		dfsturn(a,0);//第二遍 DFS 
		ans[id[a]]++; 
	}
	for(int i=1;i<=n;i++){
		if(id[i]) ansp[id[i]]=i;
	}
	for(int i=1;i<=m;i++){
		printf("%d %d\n",ansp[i],ans[i]);
	}
	return 0;
}
```

---

## 作者：huhangqi (赞：2)

因为小虫全部向着食物移动，如果没有前往食物的路径就不移动。

不难想到可以从糖果位置开始搜索。

第一次先搜索出哪些地方有小虫。

如果找到了小虫，那么停止遍历，将这个点的虫子编号和距离记录下来，距离设为 $0$ 作为起始点。

之后把这只小虫的状态转移会上一步，距离加一，如果有多个虫子，选择距离小的，因为距离小的用时更短，若距离相同，则选择编号小的。

记录下距离和虫子可以方便我们下一步将小虫移动到正确位置。

本部分搜索：

```c++
void dfs(int x,int fa){
	if(t[x]){//表示图上x点的虫子
		dis[x]=0;
		b[x]=t[x];//表示x上虫子编号
	}
	for(int i:e[x]){
		if(i==fa)continue;
		dfs(i,x);
		if(dis[i]+1<dis[x]||dis[i]+1==dis[x]&&b[i]<b[x]){
			dis[x]=dis[i]+1;//转移
			b[x]=b[i];
		}
	}
}
```

之后对于小虫位置进行转移。

我们不仅储存了距离，还可以用距离来推出时间。

如果出现两个相连的点，属于两只不同的虫子，由于我们从食物点开始搜索，则我们必定是从耗时短的虫子到时间长的虫子。

那么如果这一点耗时短，直接用这个耗时覆盖下一个点，如果相同，则相同时小虫已经到达了被阻挡时的位置，将小虫位置设为此点，继续搜索即可。

注意将开始时的小虫位置设置为食物位置。

二次搜索代码：

```c++
void dfs2(int x,int fa){
	if(!b[x])return;
	if(b[x]!=b[fa]&&dis[x]>dis[fa]){
		b[x]=b[fa];
		dis[x]=dis[fa];
	}
	else if(b[x]!=b[fa]){
		t[x]=b[x];
		w[b[x]]=x;
	}
	for(int i:e[x]){
		if(i==fa)continue;
		dfs2(i,x);
	}
}

```

### Code: ###

```c++
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,k,t[5005],w[1005],dis[5005],ans[1005],b[5005],h;
vector<int> e[5005];
void dfs(int x,int fa){//第一步处理小虫前进方向
	if(t[x]){
		dis[x]=0;
		b[x]=t[x];
	}
	for(int i:e[x]){
		if(i==fa)continue;
		dfs(i,x);
		if(dis[i]+1<dis[x]||dis[i]+1==dis[x]&&b[i]<b[x]){
			dis[x]=dis[i]+1;
			b[x]=b[i];
		}
	}
}
void dfs2(int x,int fa){//第二步处理小虫移动到的位置
	if(!b[x])return;
	if(b[x]!=b[fa]&&dis[x]>dis[fa]){
		b[x]=b[fa];
		dis[x]=dis[fa];
	}
	else if(b[x]!=b[fa]){
		t[x]=b[x];
		w[b[x]]=x;
	}
	for(int i:e[x]){
		if(i==fa)continue;
		dfs2(i,x);
	}
}
signed main(){
	cin>>n;
	for(int i=1,x,y;i<n;i++){
		cin>>x>>y;
		e[x].push_back(y);
		e[y].push_back(x);
	}
	cin>>k;
	for(int i=1,x;i<=k;i++){
		cin>>x;
		t[x]=i;//树上节点x的小虫
		w[i]=x;//第i只小虫的位置设置为x
	}
	cin>>h;
	int x;
	while(h--){
		cin>>x;
		memset(dis,0x3f,sizeof(dis));
		memset(b,0,sizeof(b));//初始化距离和小虫途径
		dfs(x,0);
		memset(t,0,sizeof(t));//小虫位置初始化
		ans[b[x]]++;//增加小虫吃到的食物数量
		dfs2(x,0);
	}
	for(int i=1;i<=k;i++)cout<<w[i]<<' '<<ans[i]<<endl;//输出答案
    return 0;
}
```

---

## 作者：Parrhesiates (赞：1)

[题目链接](https://www.luogu.com.cn/problem/P1751)

比赛的时候写的，当时没调出来。

先看一下题目，关键的点大概就是这两点。
```
1.如果有另外一只贪吃虫在某一只贪吃虫通往食物的道路上，那么距离食物较远的那只虫子会停止移动。

2.如果有多只虫子尝试进入同一个节点，只有编号最小的虫子能够到达，其它的贪吃虫停留。
```
那么我们可以想一下，在通往食物的路径，对于每个点，一定是距离最近，编号最小的虫子先到达，对吧？所以，我们显然可以在每次查询的时候，先通过一遍 `dfs`，得到到达每个点的最早时间，再通过一次 `dfs` 得到最终到达该点的虫子的编号，问题不就解决了吗？

不过，本题细节还是很多的，具体可以看看代码。

```cpp
#include<iostream>
#include<cstring>
#include<string>
#include<cmath>
#include<cstdio>
#include<algorithm>
#include<queue>
#include<map>
#include<stack>
#include<list>
#include<set>
#include<vector>
#define mem(a,b) memset(a,b,sizeof(a));
#define ls o*2
#define rs o*2+1
#define ll long long
#define ull unsigned long long
#define endl '\n'
using namespace std;
const int N=5e3+10,INF=0x3f3f3f;
int n,k,h,w;//w 表示食物的位置 
int bug[N];//最终占据点 i 的虫子的编号 
int dis[N];//表示虫子到每个点的最早时间 
int id[N];//每个位置的虫子 
int eat[N];//每只虫子吃的数量
int f[N];//redfs过程中记录时间的数组
int b[N];//每只虫子的位置
vector<int> g[N];
void dfs(int u,int fa){//预处理，没必要解释了。
	if(id[u])dis[u]=0,bug[u]=id[u];
	else dis[u]=INF,bug[u]=INF;
	for(int i=0;i<g[u].size();i++){
		int v=g[u][i];
		if(v==fa)continue;
		dfs(v,u);
		if(dis[v]+1<dis[u]||(dis[v]+1==dis[u]&&bug[v]<bug[u])){
			dis[u]=dis[v]+1,bug[u]=bug[v]; 
		}
	}
}
void redfs(int u,int fa){
	if(bug[u]==INF)return ;
	if(f[bug[u]]==-1&&bug[u]!=bug[fa])
		f[bug[u]]=min(f[bug[fa]],min(dis[fa],dis[u]));
	if(f[bug[u]]!=-1&&f[bug[u]]==dis[u]) b[bug[u]]=u;//如果时间一致，说明该虫最终占据了这个点。
	for(int i=0;i<g[u].size();i++){
		int v=g[u][i];
		if(v==fa)continue;
		redfs(v,u);
	}
}
int main(){
	cin>>n;
	for(int i=1,u,v;i<n;i++){
		cin>>u>>v;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	cin>>k;
	for(int i=1;i<=k;i++)cin>>b[i],id[b[i]]=i;
	cin>>h;
	while(h--){
		cin>>w;
		mem(dis,0);
		mem(bug,0);
		mem(f,-1);
		dfs(w,0);
//		for(int i=1;i<=k;i++){
//			cout<<b[i]<<" ";
//		}
//		cout<<endl;
		eat[bug[w]]++;
		f[bug[w]]=dis[w];//吃到食物的虫
		redfs(w,0);
		mem(id,0);
		for(int i=1;i<=k;i++){//更新虫子的位置
			id[b[i]]=i;
		}
	}
	for(int i=1;i<=k;i++){
		cout<<b[i]<<" "<<eat[i]<<endl;
	}
	return 0;
}
```

---

## 作者：hnczy (赞：0)

这道题比较麻烦。

先尝试写个暴力（此处只写思路）。

因为每次的树根都不一样，所以每次都要建树。

然后每一轮都要对每一个虫子进行判断是否继续再走。

时间复杂度 $O(nkh)$ (最坏情况）。

思考有什么东西可以优化，$h$?不可能，$k$？不可能，所以只能优化 $n$，这里强调一下，$n$ 不是树的节点，而是要走多少步。

那必须直接处理出来每一个虫子的位置，理论上可以直接从树根出发分治处理。

有点难搞？可以换一个思路？

当然随便找一个树模拟一下：

https://book.baige.me/link/QRk

现在 $4$ 是根，假设 $1$，$2$ 为虫子那 $1$，$2$ 标为 $0$， $5$，$4$ 标为 $1$，然后从根 $4$ 开始下来 $f5=f4$ 所以有异常，把 $5$ 标为虫子 $1$ 的坐标，继续搜。

那我们是否就成功的做出了一个正解：

```c++
#include<bits/stdc++.h>
#define pii pair<int,int>
#define ll long long
namespace fast {
	inline int read() {
		int x = 0, w = 1;
		char ch = 0;
		while (ch < '0' || ch > '9') {
			if (ch == '-') w = -1;
			ch = getchar();
		}
		while (ch >= '0' && ch <= '9') {
			x = x * 10 + (ch - '0');
			ch = getchar();
		}
		return x * w;
	}
	inline void write(int x) {
		static int sta[35];
		int top = 0;
		do {
			sta[top++] = x % 10, x /= 10;
		} while (x);
		while (top) putchar(sta[--top] + 48);  // 48 是 '0'
	}
	inline void tomin(int &a,int b){
		if(b<a)a=b;
	}
	inline void tomax(int &a,int b){
		if(b>a)a=b;
	}
}
using namespace fast;
using namespace std;
int n,k,a[1005],h,f[5005],fa[5005],it[5005],tmp,ans[1005],t[5005];
vector<int>e[5005];
void dfs(int x,int fa){
	if(t[x]){
		f[x]=0;
		it[x]=t[x];
	}
	for(int i:e[x]){
		if(i==fa)continue;
		dfs(i,x);
		if(f[i]+1<f[x]||f[i]+1==f[x]&&it[i]<it[x]){
			f[x]=f[i]+1;
			it[x]=it[i];
		}
	}
}
void dfs2(int x,int fa){
	if(!it[x])return;
	if(it[x]!=it[fa]&&f[x]>f[fa]){
		it[x]=it[fa];
		f[x]=f[fa];
	}
	else if(it[x]!=it[fa]){
		t[x]=it[x];
		a[it[x]]=x;
	}
	for(int i:e[x]){
		if(i==fa)continue;
		dfs2(i,x);
	}
}
void move(int rt){
	memset(f,0x3f,sizeof f);
	memset(it,0,sizeof it);
	dfs(rt,0);
	memset(t,0,sizeof t);
	ans[it[rt]]++; 
	dfs2(rt,0);
}//先跑一遍dfs,建树,再bfs,去遍历每一个点在哪一个时间点被访问,再用dfs回溯 标记每一个虫子的坐标点 
int main(){
	n=read();
	for(int i=1,u,v;i<n;i++){
		u=read(),v=read();
		e[u].push_back(v);
		e[v].push_back(u);
	}
	k=read();
	for(int i=1;i<=k;i++){
		a[i]=read(),t[a[i]]=i;
	}
	h=read();
	for(int i=1,fd;i<=h;i++){
		fd=read();
		move(fd);
	}
	for(int i=1;i<=k;i++)
		printf("%d %d\n",a[i],ans[i]);
	return 0;
}
```

---

## 作者：OIer_ACMer (赞：0)

~~虫虫的幸福生活。~~

------------
## 大致思路：
这道题是一道典型的图论题，方法很简单：**暴力**！

我们可以把每一个食物看成一个测试点。那么就是要计算出每个节点被哪条贪吃虫占领和每条贪吃虫最终停留的地方。很明显，这两次查找，我们可以用两个非常暴力的 dfs 薅出来。第一次 dfs。对于每一个节点，**占领它的贪吃虫一定是到达用时最短的那个**。到达它的最短的时间就是最短的子节点到达时间加 $1$。还要注意两种特殊情况，在代码里也会有说明：

1. 该点已经有了贪吃虫。

2. 有速度相同，取编号最小的贪吃虫。

结束后把占领食物所在节点的贪吃虫吃到的食物数记得加 $1$。

第二次 dfs 时，可以利用第一次求出的值取计算。因为在第一次 dfs 时，我们求出了占领每个节点所用的时间，所以可以**用一个数组去记录每一条贪吃虫到达最终落脚点的时间**，这个值是可以算出的。如果对于某个节点，占据他的贪吃虫到达最终落脚点的时间等于该节点被占领的时间，则该节点为**这条贪吃虫的最终落脚点**。

------------
## 代码如下：

```c++
#include <bits/stdc++.h>
using namespace std;
inline int read()
{
    register int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9')
    {
        if (ch == '-')
        {
            f = -1;
        }
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
    {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}
int n, k, h;
struct node
{
    int nxt, to;
} edge[10010];
int cnt;
int head[10010];
int final[5001];
int poss[5001];
int c[501];
int eat[5001];
int t[5001];
int o[5001];
int f[5001];
inline void add(int x, int y)
{
    edge[++cnt].nxt = head[x];
    edge[cnt].to = y;
    head[x] = cnt;
}
inline void dfs1(int now, int fa)
{
    int mp, mt;
    if (poss[now])
    {
        mp = poss[now];
        mt = 0;
    }
    else
    {
        mp = 9999;
        mt = 9999;
    }
    for (int i = head[now]; i; i = edge[i].nxt)
    {
        int to = edge[i].to;
        if (to == fa)
        {
            continue;
        }
        dfs1(to, now);
        if ((t[to] + 1) < mt || ((t[to] + 1) == mt && o[to] < mp))
        {
            mt = t[to] + 1;
            mp = o[to];
        }
    }
    t[now] = mt;
    o[now] = mp;
}
inline void dfs2(int now, int fa)
{
    if (o[now] != 9999)
    {
        if (f[o[now]] == -1 && o[fa] != o[now])
        {
            int mt = min(t[fa], t[now]);
            f[o[now]] = min(f[o[fa]], mt);
        }
        if (f[o[now]] != -1 && f[o[now]] == t[now])
        {
            final[o[now]] = now;
        }
    }
    for (int i = head[now]; i; i = edge[i].nxt)
    {
        int to = edge[i].to;
        if (to == fa)
        {
            continue;
        }
        dfs2(to, now);
    }
}
int main()
{
    n = read();
    for (int i = 1; i < n; i++)
    {
        int x, y;
        x = read();
        y = read();
        add(x, y);
        add(y, x); 
    }
    k = read();
    for (int i = 1; i <= k; i++) 
    {
        int x;
        x = read();
        poss[x] = i;
        final[i] = x; 
    }
    h = read();
    for (int i = 1; i <= h; i++)
    {
        c[i] = read();
    }
    for (int i = 1; i <= h; i++)
    {
        memset(t, 0, sizeof(t));
        memset(o, 0, sizeof(o));
        memset(f, -1, sizeof(f));
        dfs1(c[i], -1);          
        ++eat[o[c[i]]];          
        f[o[c[i]]] = t[c[i]];    
        dfs2(c[i], -1);
        memset(poss, 0, sizeof(poss)); 
        for (int j = 1; j <= k; j++)
        {
            poss[final[j]] = j;
        }
    }
    for (int i = 1; i <= k; i++) 
    {
        cout << final[i] << ' ' << eat[i] << endl;;
    }
    return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/122984138)

[参考文献](https://blog.csdn.net/zhangxiao666__/article/details/131628925)

---


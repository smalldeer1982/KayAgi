# 翻转游戏 (加强版)

## 题目描述

kkke 在一个 $n\ \times n$ 的棋盘上进行一个翻转游戏。棋盘的每个格子上都放有一个棋子，每个棋子有 $2$ 个面，一面是黑色的，另一面是白色的。初始的时候，棋盘上的棋子有的黑色向上，有的白色向上。现在 kkke 想通过最少次数的翻转，使得棋盘上所有的棋子都是同一个颜色向上的（即全是黑色向上的，或全是白色向上的）。每次翻转的时候，kkke 可以选择任意一个棋子，将它翻转，同时，与它上下左右分别相邻的 $4$ 个棋子也必须同时翻转。

## 说明/提示

### 数据范围及约定

- 对于 $30\%$ 的数据，$1 \le n \le 4$；
- 对于 $100\%$ 的数据，$1 \le n \le 16$。

## 样例 #1

### 输入

```
4
bwwb
bbwb
bwwb
bwww
```

### 输出

```
4```

# 题解

## 作者：razx (赞：17)

    枚举＋搜索+位运算。
 如果从上往下逐层翻转棋子的话，当前一层必须要修复上一层的不符合目标状态的棋子，换句话说：当第一行的操作方式即操作后的状态已经确定后，下一层的操作方式也就唯一确定了，所以只需枚举出第一行的所有可能状态即可逐行往下翻转操作类推出结果（分两次类推，一次是类推出全部棋子白色向上的目标状态，一次是类推出全部棋子黑色向上的目标状态）。
关键代码注释已有，就不细说了。

```cpp



#include<bits/stdc++.h>
using namespace std;

int Map[20][20];
int n,ans =(1<<31)-1;

void Flip(int x,int y)
{
  Map[x-1][y] ^= 1;
  Map[x][y-1] ^= 1;
  Map[x][y] ^= 1;
  Map[x][y+1] ^= 1;
  Map[x+1][y] ^= 1;
}

void Dfs(int row,int step,int value)
{
  if(row == n+1)
  {
    for(int i = 1; i <= n; i++)
      if(Map[n][i]==value)          //若不符合，退出
        return;
    ans=step<ans?step:ans;          //符合则更新答案
    return;
  }
  int v = 0;
  for(int i = 1; i <= n; i++)
    if(Map[row-1][i]==value)        //上一层的某棋子不是目标状态，则翻转
    {
      step++;
      Flip(row,i);                  //翻转当前层以改变上一层的棋子
      v |= 1<<(i-1);                //记录翻转的位置
    }
  Dfs(row+1,step,value);
  for(int i = 1; i <= n; i++)       //还原
    if((v>>(i-1))&1)
      Flip(row,i);
}

int main()
{
  cin >> n;
  char ch;
  for(int i = 1; i <= n; i++)
    for(int j = 1; j <= n; j++)
    {
      cin >> ch;
      Map[i][j] =(ch=='b');
    }
  for(int k = 0; k <(1<<n); k++)
  {
    for(int i = 1; i <= n; i++)     //枚举出第0行(不存在的行)的所有状态
      Map[0][i]=(k>>(i-1))&1?1:0;
    Dfs(1,0,0);                     //从第1行开始，搜索能不能找到全为1的状态
    Dfs(1,0,1);                     //从第1行开始，搜索能不能找到全为0的状态
  }
  if(ans!=(1<<31)-1)
    cout<<ans<<endl;
  else
    cout<<"Impossible"<<endl;
  return 0;
}
```


---

## 作者：御前带刀侍卫 (赞：9)

### 0.相关链接

[Flip Game](http://poj.org/problem?id=1753)（4 * 4原版）

[Flip  Game 加强版](https://www.luogu.org/problem/P1764)（16 * 16版）

### 1.读题

给您这么一个棋盘（4 * 4 ~ 16 * 16），上面放着黑白棋

![](https://s2.ax1x.com/2019/08/20/m8rZSU.png)

您可以进行的操作是：

翻转一个棋子，但同时会使其上下左右四个棋子一起翻转

![](https://s2.ax1x.com/2019/08/20/m8rEWT.png)

求将其全变白或全变黑最少需要几次操作

### 2.解题

30 pts

4 * 4,一共有 2^16（65536）种操作，二进制枚举，遍历一遍，绰绰有余。

时间复杂度：O(2^N);

100 pts

5 * 5时，O(2^N)程序瞬间爆炸，因为 2^25 = 33,554,432;


于是我们想到，要把时间复杂度压到**O(2^16)**

**而N最大为16！！！**

**这不是巧合！！**

那么，就只能枚举 **一行** 或 **一列** 了

我们就开始想，

枚举一行如何代表全图的操作呢？

只能是这一行的状态**决定**全图其他操作！！

可以想到，这一行绝对很特殊

那些行和列特殊呢？

自然是：**第一和第N**

它们只影响一行，也只被一行影响

**因此，这一行的状态确定后，其余操作为保证其正确性，也不得不确定**

如图

![](https://s2.ax1x.com/2019/08/20/m8relF.png)

由于以 第一行 为 特殊行 最符合正常思维，我们选用第一行

### 3.上代码：
```cpp
#include<stdio.h>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<iostream>
#include<algorithm>
#include<queue>						//懒人缺省源 

#define INF 10000
#define MAXN 16
#define MAXD 4 
using namespace std;				//警告，不加这行爆零！ 

bool mp[MAXN+5][MAXN+5];        	//原矩阵 
bool next_mp[MAXN+5][MAXN+5];		//反转后的矩阵   

int dx[MAXD]={0,0,1,-1}, 
	dy[MAXD]={1,-1,0,0};			//二次元（大雾）位移 

int n; 
int ans=INF;					 

char str[16];
int input(){ 
	scanf("%d",&n);
	for(int i=0;i<n;i++){
		scanf("%s",str);
		for(int j=0;j<n;j++){
			next_mp[i][j]=mp[i][j]=(str[j]=='b');		
            //把 字符串 转换为 bool 矩阵 
		}
	}
} 

inline bool inarea(int x,int y){
	return (x>=0&&x<n&&y>=0&&y<n);//这里可以改为宏定义，更快 
} 

void turn(int x,int y,bool o){//翻转，操作核心 （xy:坐标，o:是否反转） 
	if(!o)											
		return;
		 
	int nx,ny;											 
	next_mp[x][y]=!next_mp[x][y];
	for(int i=0;i<MAXD;i++){
		nx=x+dx[i];						//四向位移（大秧歌） 
		ny=y+dy[i];
		if(inarea(nx,ny)){				
			next_mp[nx][ny]=!next_mp[nx][ny];
		}
	}
}

bool check(bool order){		//判断正误 
	for(int i=0;i<n;i++){							
		if(next_mp[n-1][i]==!order){
        				//只需检查 最后一行 的元素就可以了 
			return 0;	//因为 转换 以不违背上面的 正确性 为前提 
		}
	}
	return 1;
}

void init(){				//虽然频繁使用，但是不建议加inline，
	for(int i=0;i<n;i++)	// ccf老爷机上的古董G++有可能出错 QAQ 
		for(int j=0;j<n;j++)
			next_mp[i][j]=mp[i][j];
}

void work(int x,bool order){
	init();					//把 mp 复制进 next_mp 
	int cnt=0,now=0;		//cnt 是 步数，now 是 横坐标 
	for(int i=0;i<n;i++){	//处理第 一 行 
		if(x&1)	cnt++;		//按位分解二进制数（1则为翻，否则反之） 
		
		turn(0,now,(x&1))//now 从 0 到 n-1  和  从 n-1 到 0 并不重要 
		 		//因为  0000~1111  会把  o 和 ~o 都遍历一遍 
		x>>=1;											 
		now++;											
	}
	
	for(int i=1;i<n;i++){
		for(int j=0;j<n;j++){
			cnt+=(next_mp[i-1][j]==!order);				
			turn(i,j,(next_mp[i-1][j]==!order));
            //如果上一行合order相同，则翻转，否则反之 
		}
	}
	
	if(check(order)){
		if(cnt<ans)
			ans=cnt;				//ans 的 擂台 
	}
		
}

inline void output(){
	if(ans==INF)
		printf("Impossible\n");
	else 
		printf("%d\n",ans);
} 

int main(){
	input();
	for(int i=0;i<1<<n;i++){//二进制枚举 （灵魂） 从 0000……到 111……
		work(i,0);			//全是 0   （ w） 
		work(i,1);			//全是 1 	( b)
	} 
	output();
	return 0;				//吼西瓜啊 
}

```
蒟蒻求通过QwQ

---

## 作者：kkke (赞：9)

```cpp

#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define maxn 0x3f3f3f3f

using namespace std;

int n;
char hehe[20][20];
int kkke[20][20];

int solve(int aim)
{
    int kind=1<<n;
    int ans=maxn;
    for(int k=0;k<kind;k++)//搜索第一层的所有可能情况
    {
        int step=0;
        for(int i=0;i<n;i++)//初始化
        {
            for(int j=0;j<n;j++)
            {
                if(hehe[i][j]=='b')kkke[i][j]=1;
                else kkke[i][j]=0;
            }
        }
        for(int i=0;i<n;i++)//改变第一层状态
        {
            if(k&(1<<i))continue;
            step++;
            kkke[0][i]=1-kkke[0][i];
            if(i>0)kkke[0][i-1]=1-kkke[0][i-1];
            if(i<n-1)kkke[0][i+1]=1-kkke[0][i+1];
            if(n>1)kkke[1][i]=1-kkke[1][i];
        }
        for(int i=1;i<n;i++)
        {
            for(int j=0;j<n;j++)
            {
                if(kkke[i-1][j]==aim)continue;//如果上一层对应位置不是目的状态
                step++;//则将当前位置翻面
                kkke[i][j]=1-kkke[i][j];
                kkke[i-1][j]=aim;
                if(j>0)kkke[i][j-1]=1-kkke[i][j-1];
                if(j<n-1)kkke[i][j+1]=1-kkke[i][j+1];
                if(i<n-1)kkke[i+1][j]=1-kkke[i+1][j];
            }
        }
        bool flag=true;
        for(int i=0;i<n;i++)//判断最后一层是否是目的状态
        {
            if(kkke[n-1][i]!=aim)
            {
                flag=false;
                break;
            }
        }
        if(flag)
        {
            ans<?=step;//若最后一层满足则一定到达目的状态
        }
    }
    return ans;
}

int main()
{
    freopen("flip.in","r",stdin);
    freopen("flip.out","w",stdout);
    scanf("%d",&n);
    for(int i=0;i<n;i++)scanf("%s",hehe[i]);
    int ans=min(solve(1),solve(0));//搜索全为1或全为0的情况
    if(ans==maxn)printf("Impossible\n");
    else printf("%d\n",ans);
    return 0;
}

```

---

## 作者：柏木由纪AKB48 (赞：8)

来一篇借鉴了楼下的题解

今天考试的时候做了一道阉割版的翻转游戏(n==4限定)

考试的时候A的方法是先把地图设定为全black然后n^(4*4)枚举

转换为二进制来去重，相当于一个bfs，应该能过这道题一半

然后百思不得其解时看了楼下的题解

想起来以前有一道题就是开关灯吧一次性只能连续开关3个

这道题思路基本一样

鉴于楼下没有发布详细思路解释，为了方便大家举一反三

有了此题解

进入正题

q.为什么要先最基本的暴力出第一排对的状态呢

a.俗话说万事开头难，因为第一排的任意一个方块要翻转只能以来周围四块和自己共五块，第一排没有上家，同行的状态被枚举完了，能影响自己的就只有下家，于是在逐行枚举时，如果上家出现不同颜色则必须连坐转动，初此之外再无他法，这样就巧妙地把状态逼到了必须的境界

相信聪明的你一定有所启发，这也是这道题的关键所在

粘代码，习惯不设卡
```cpp
#include<bits/stdc++.h>
using namespace std;

int n;
char hehe[16][16];
int o[16][16];

int get_w(int target){
    int inreturn=999999999;
    int up=1<<n;
    for(int i=0;i<up;i++){
        int step=0;
        int cur[16][16];
        for(int x=0;x<16;x++)for(int y=0;y<16;y++) cur[x][y]=o[x][y]; 
        for(int j=0;j<n;j++){
            if(i&(1<<j)) continue;
            cur[0][j]=1-cur[0][j];
            if(j-1>=0) cur[0][j-1]=1-cur[0][j-1];
            if(j+1<n) cur[0][j+1]=1-cur[0][j+1];
            cur[1][j]=1-cur[1][j];
            step++;
        }
        for(int x=1;x<n;x++){
            for(int y=0;y<n;y++){
                if(cur[x-1][y]!=target){
                    step++;
                    cur[x-1][y]=1-cur[x-1][y];
                    cur[x][y]=1-cur[x][y];
                	if(y-1>=0) cur[x][y-1]=1-cur[x][y-1];
                    if(y+1<n) cur[x][y+1]=1-cur[x][y+1];	
                    if(x+1<n) cur[x+1][y]=1-cur[x+1][y];			
                }
            }
        }
        int ok=1;
        for(int u=0;u<n;u++){
            if(cur[n-1][u]!=target){
                ok=0;
                break;
            }
        }
        if(ok){
            inreturn=min(inreturn,step);
        }
    }
    return inreturn;
}

int main(){
    scanf("%d",&n);
    for(int i=0;i<n;i++) scanf("%s",hehe[i]);
    for(int i=0;i<n;i++) for(int j=0;j<n;j++){
        if(hehe[i][j]=='b') o[i][j]=1;
        else o[i][j]=0;
    }
    int ans=min(get_w(1),get_w(0));
    if(ans==999999999) printf("Impossible");
    else printf("%d",ans);
    return 0;
}
```
另外技巧：二进制自己生成，这个问周围同学啦



---

## 作者：liubai (赞：4)

## 世人知晓inline好,唯有dfs忘不了
#### 说实话我这个方法过这个题很险（多亏inline）啊，下面大概说一下思路:
### 1.结果为白棋向上或黑棋向上，所以储存两个图map和map1。map储存最终结果为白棋向上，map1为黑棋向上。
### 2.dfs搜索从左往右搜，搜到最后一列往下一行搜，搜到n+1行进行判断最终是否可行。
### 3.（最重要的步骤）在搜索过程中 只需判断当前列的上一行的状态是否可行。因为翻转位置i，j位置的棋对上一行的影响，只会影响到位置为i-1，j的棋的状态，且向后搜时无论如何也不会改变i-1，j的状态.
下面给出我丑陋的代码
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<queue>
using namespace std;
int n;
int map[20][20];
int map1[20][20];
int f[20][20];//f为map的状态 f[i][j]表示 i,j位置的棋翻还是不翻 0为不翻 1为翻
int vis[20][20];//vis为map1的状态 同上
int ans=7777777;
int ans1=7777777;//辣个男人的数字
inline bool check(int i,int j)//inline大法好
{
   if(i==0||j==0) return 0;
   return (map[i][j]+f[i][j]+f[i-1][j]+f[i+1][j]+f[i][j-1]+f[i][j+1])%2;//i,j位置的状态会受他自己和他前后左右翻转的情况而改变，%2是因为改变两次相等于不变
}
inline bool check1(int i,int j)//inline大法好
{
	 if(i==0||j==0) return 0;
     return (map1[i][j]+vis[i][j]+vis[i-1][j]+vis[i+1][j]+vis[i][j-1]+vis[i][j+1])%2;//同上
}
void dfs(int x,int y,int cnt)//map。cnt为步骤
{ 
   if(cnt>=ans)//如果此时的步骤比ans还大或等，没有搜的必要
   return;
   if(y==n+1)//如果这一行搜完，搜下一行
   {
    x++;
    y=1;
   }
   if(x==n+1)//全部搜完
   {
   	  for(int i=1;i<=n;i++)
   	  {
   	     if(check(n,i))//判断最后一行是否都翻上
   	     {
   	      return;	
   	     }
   	  }
   	  ans=cnt;
   	  return;
   }
    f[x][y]=0;
    //只有上一行的棋的状态为需要的状态，才会往下搜
	if(!check(x-1,y)) dfs(x,y+1,cnt);//不翻所以cnt不变
	f[x][y]=1;
	if(!check(x-1,y)) dfs(x,y+1,cnt+1);//翻了 cnt+1
}
void dfs1(int x,int y,int sum)//map1
{
  if(sum>=ans1||sum>=ans)//加了一个剪枝，如果当前步骤比搜map的结果要大，也没有搜的必要了
  return;
   if(y==n+1)
   {
    x++;
    y=1;
   }
   if(x==n+1)
   {
   	  for(int i=1;i<=n;i++)
   	  {
   	     if(check1(n,i))
   	     {
   	      return;	
   	     }
   	  }
   	  ans1=sum;
   	  return;
   }
    vis[x][y]=0;
	if(!check1(x-1,y)) dfs1(x,y+1,sum);
	vis[x][y]=1;
	if(!check1(x-1,y)) dfs1(x,y+1,sum+1);
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
	 for(int j=1;j<=n;j++)
	 {
	   char a;
	   cin>>a;
	   if(a=='b')//存图
	   {
	   	  map[i][j]=1;
	   }
	   else
	   {
	   map1[i][j]=1;
	   }
     }
	}
     dfs(1,1,0);
     dfs1(1,1,0);
     ans=min(ans,ans1);
     if(ans==7777777）
     {
       printf("Impossible\n");	
     }
     else printf("%d\n",ans);
 return 0;	
}
```
尝试就是胜利（rp++），各位大佬有好的优化方法可以告诉我。
开O2是必过的。
  

---

## 作者：不存在之人 (赞：4)

**我们可以找出第一行所有可行的方案，下面一个例子：**

```
原图：bwwb
      bbwb
      bwwb
      bwww
```

我们看，第一行我们可以得到所有方案，假设得到一个序列$A$，然后我们就可以先看如果要全部变成$w$需要改变第二行的那些，然后依次改变后面的


假设第一行我们得到了一个方案，为$bwwb$

那么我们要把它变成$w$，就需要改变第二行的第一个和第三个才能使第一行全部为$w$（至于也改变了后面的我们不管，因为每一行我们可以由它的下一行确定），那么这样操作完了后，我们只有最后一行没有确定了

这样就可以从全图搜索变成只搜第一行了，即使是深搜$O(2N)$也能过了！

$C++ Code$：
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define copymap(a,b) for(int _i=0;_i<n;_i++)for(int _j=0;_j<n;_j++)a[_i][_j]=b[_i][_j];
using namespace std;
const int MAXN=30;
const int dx[]={0,0,1,-1,0};
const int dy[]={1,-1,0,0,0};
int n,map[MAXN][MAXN],oldmap[MAXN][MAXN],firstmap[MAXN][MAXN],a[MAXN];
int ans=0x7fffffff;
void read()
{
	scanf("%d",&n);
	char s[30];
	for(int i=0;i<n;i++)
	{
		scanf("%s",s);
		for(int j=0;j<n;j++)
		    map[i][j]=((s[j]=='b')?1:0);
	}
	copymap(firstmap,map);
}
void change(int x,int y)
{
	for(int k=0;k<5;k++)
	{
		int nx=x+dx[k];
		int ny=y+dy[k];
		if(nx>=n||nx<0) continue;
		if(ny>=n||ny<0) continue;
		map[nx][ny]=1-map[nx][ny];
	}
}
void turn(int sum,int k)
{
	for(int i=1;i<n;i++)
		for(int j=0;j<n;j++)
		    if(map[i-1][j]!=k)
		    {
				change(i,j);
				sum++;
			}
	bool flag=true;
	for(int j=0;j<n;j++)
	    if(map[n-1][j]!=k) {flag=false;break;}
	if(flag) ans=min(ans,sum);
}
void dfs(int x,int sum)
{
	if(x>=n)
	{
		for(int i=0;i<n;i++)
			if(a[i]) change(0,i);
		copymap(oldmap,map);
		turn(sum,1);
		copymap(map,oldmap);
		turn(sum,0);
		copymap(map,firstmap);
		return;
	}
	a[x]=1;
	dfs(x+1,sum+1);
	a[x]=0;
	dfs(x+1,sum);
}
void work()
{
	dfs(0,0);
	if(ans==0x7fffffff) printf("Impossible");
	else printf("%d\n",ans);
}
int main()
{
	read();
	work();
	return 0;
}
```

---

## 作者：_l_l_ (赞：3)

[**题目页面**](https://www.luogu.com.cn/problem/P1764)

[**更好的阅读体验**](https://www.luogu.com.cn/blog/yinjun2024/solution-p1764)

此题可以用搜索 + 贪心解决此题

首先，我们使用搜索枚举翻转第一行以每个棋子为中心的次数。

然后我们可以不动第一行，使用翻转第二行来将第一行全部变为相同颜色。

然后我们可以不动第二行，使用翻转第三行来将第一二行全部变为相同颜色。

以此类推，最后判断整个棋盘是否成功，取最小答案。

代码：
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
const int MAXN = 16;
int n;
bool borad[MAXN][MAXN];
bool try_[MAXN][MAXN];
int fuc(bool target) {
	int ans = 0x7fffffff;
	for (int i = 0; i < (1 << n); i++) {
		for (int j = 1; j <= n; j++) {
			for (int k = 1; k <= n; k++) {
				try_[j][k] = borad[j][k];
			}
		}
		int tmp = 0;
		for (int j = 1; j <= n; j++) {
			if (i & (1 << j - 1)) {
				try_[1][j] = !try_[1][j];
				if (n != 1) try_[2][j] = !try_[2][j];
				if (j != 1) try_[1][j - 1] = !try_[1][j - 1];
				if (j != n) try_[1][j + 1] = !try_[1][j + 1];
				tmp++;
			}
		}
		for (int j = 2; j <= n; j++) {
			for (int k = 1; k <= n; k++) {
				if (try_[j - 1][k] != target) {
					try_[j - 1][k] = target; 
					try_[j][k] = !try_[j][k];
					if (j != n) try_[j + 1][k] = !try_[j + 1][k];
					if (k != 1) try_[j][k - 1] = !try_[j][k - 1];
					if (k != n) try_[j][k + 1] = !try_[j][k + 1];
					tmp++; 
				}
			}
		}
		bool flag = 1;
		for (int j = 1; j <= n; j++) {
			if (try_[n][j] != target) {
				flag = 0; break;
			}
		}
		if (flag) ans = min(ans, tmp);
	}
	return ans;
}
int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			char ch;
			while (ch = getchar()) {
				if (ch == 'w' || ch == 'b') break;
			}
			borad[i][j] = ch == 'w' ? 0 : 1;
		}
	}
	int ans = min(fuc(0), fuc(1));
	if (ans == 0x7fffffff) printf("Impossible");
	else printf("%d", ans);
	return 0;
}
```

---

## 作者：aakennes (赞：3)

# 题面简述：

哦，这不是emacs上的小游戏么~~（虽然没赢过）~~

翻转游戏的加强版（貌似前两题能暴搜搜过吧），显然需要用正解

# 思路：

每一行状态都是确定的，如果枚举每一行的所有状态，显然会TLE

要想让上一行全变为同一颜色，只需要翻转这一行，这样就可以保证无后效性

当然，需要枚举第一行状态

如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/ydg1d833.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/9xbs20ez.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/rj1e5yw7.png)

# 代码：

```
#include<cstdio>
#include<cstring>
#include<iostream>
#include<cmath>
#include<algorithm>
#include<ctime>
using namespace std;
const int maxn=1e6+5,INF=0x3f3f3f3f;
inline int read(){
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();
	return s*w;
}
int n,m,V,ans=INF,cnt;
int a[18][18],b[18][18],ch;
void flip(int &x){
	if(x==1)x=0;
	else x=1;
}//翻转单点
void press(int x,int y){
	cnt++;flip(b[x][y]);flip(b[x-1][y]);flip(b[x+1][y]);flip(b[x][y+1]);flip(b[x][y-1]);
}//翻转当前点，影响了上下左右四个点
void calc(int s,int ch){
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			b[i][j]=a[i][j];
	cnt=0;
	for(int i=1;i<=n;i++){
		if(s&(1<<i-1))press(1,i);//把第一行转化为当前状态
	}
	for(int i=2;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(b[i-1][j]!=ch)press(i,j);//检查上一行，颜色不符就翻转这一行的点
		}
	}
	int sum=0;
	for(int i=1;i<=n;i++){
		if(b[n][i]!=ch){return;}//检查最后一行是否为目标颜色
	}
	ans=min(ans,cnt);
}
int main(){
	n=read();
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			char c;cin>>c;
			if(c=='b')a[i][j]=1;
		}
	}
	for(int i=0;i<=(1<<n)-1;i++){
		calc(i,1);//枚举第一行状态和目标颜色
		calc(i,0);
	}
	if(ans==INF)cout<<"Impossible";//无合理方案
	else cout<<ans;
}
```

---

## 作者：1沃尔克 (赞：3)

本题是p2040打开所有的灯的加强版，但原理和方法都一模一样。

首先，我们看到输入全是字母，把它换了，b->1,w->0,于是就变成了01矩阵，和开灯问题一样了。

### 此类开灯问题的基本思路。

首先，对于一个位置最多只操作一次，操作两次相当于取反两次，有变回来了，毫无意义。

**原始思路：**
枚举每一个位置是否操作，枚举完成后暴力扫一遍，全零（或全一）则取最小值，但只能过p2040，本题30 scores。

**先进思路：**
同样我们先枚举第一行，当我们枚举第二行是，我们发现此时对于第一行，只能通过操作第二行来改变，下面的行不会再对第一行产生影响。所以我们贪心地让第一行全零（或全一）即对于一个位置，若它上方的位置为1（最后变成全零时）或0（最后变成全一时）则对此位置进行操作，以此类推到最后一行，而且因为这种贪心方式，前n-1行都已满足题意，只需枚举最后一行检查是否满足即可。然后，我们就会发现，当第一行的操作方式即操作后的状态确定是，下面的操作都已固定，所以枚举全部变成了枚举第一行。我们便可以通过本题了。

注意事项：

1.当第一行确定后，向下递推时不能在原数组中操作，会对后面的搜索产生影响，所以不要嫌麻烦，在开一个数组备份一下，对备份数组操作。

2.步数不要忘记2-n行的步数。

code
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,ans=400;
int a[20][20],b[20][20];
char c;
void dfs1(int y,int step)
{
	if(step>ans) return ;
	if(y==n+1)
	{
		int sr=step;
		for(int i=1;i<=n;i++)
		 	for(int j=1;j<=n;j++)
		 		b[i][j]=a[i][j];
		for(int i=2;i<=n;i++)
			for(int j=1;j<=n;j++)
			{
				if(b[i-1][j]==1)
				{
					sr++;
					if(sr>ans) return ;
					b[i][j]=b[i][j] xor 1;
					b[i-1][j]=b[i-1][j] xor 1;
					b[i+1][j]=b[i+1][j] xor 1;
					b[i][j-1]=b[i][j-1] xor 1;
					b[i][j+1]=b[i][j+1] xor 1;
				}
			}
		for(int i=1;i<=n;i++)
			if(b[n][i]==1) return ;
		ans=min(ans,sr); return ;	
	}
	a[1][y]=a[1][y] xor 1;
	a[2][y]=a[2][y] xor 1;
	a[1][y-1]=a[1][y-1] xor 1;
	a[1][y+1]=a[1][y+1] xor 1;
	dfs1(y+1,step+1);
	a[1][y]=a[1][y] xor 1;
	a[2][y]=a[2][y] xor 1;
	a[1][y-1]=a[1][y-1] xor 1;
	a[1][y+1]=a[1][y+1] xor 1;
	dfs1(y+1,step);
}
void dfs2(int y,int step)
{
	if(step>ans) return ;
	if(y==n+1)
	{
		int sr=step;
		for(int i=1;i<=n;i++)
		 	for(int j=1;j<=n;j++)
		 		b[i][j]=a[i][j];
		for(int i=2;i<=n;i++)
			for(int j=1;j<=n;j++)
			{
				if(b[i-1][j]==0)
				{
					sr++;
					if(sr>ans) return ;
					b[i][j]=b[i][j] xor 1;
					b[i-1][j]=b[i-1][j] xor 1;
					b[i+1][j]=b[i+1][j] xor 1;
					b[i][j-1]=b[i][j-1] xor 1;
					b[i][j+1]=b[i][j+1] xor 1;
				}
			}
		for(int i=1;i<=n;i++)
			if(b[n][i]==0) return ;
		ans=min(ans,sr); return ;	
	}
	a[1][y]=a[1][y] xor 1;
	a[2][y]=a[2][y] xor 1;
	a[1][y-1]=a[1][y-1] xor 1;
	a[1][y+1]=a[1][y+1] xor 1;
	dfs2(y+1,step+1);
	a[1][y]=a[1][y] xor 1;
	a[2][y]=a[2][y] xor 1;
	a[1][y-1]=a[1][y-1] xor 1;
	a[1][y+1]=a[1][y+1] xor 1;
	dfs2(y+1,step);
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
		{
			cin>>c;
			if(c=='b') a[i][j]=1;
			else a[i][j]=0;
		}	
	dfs1(1,0);
	dfs2(1,0);
	if(ans==400) puts("Impossible");
	else printf("%d",ans);
	return 0;
}
```
致谢


---

## 作者：ldqldq (赞：1)

```pascal
program p1764_ldq;
  var
    map,t:array[0..18,0..18]of integer;
    r:array[0..18]of integer;
    tmp,i,j,n,ans:longint;
    ch:char;
  function check(x,p:longint):longint;
    var i,o,cnt:longint;flag:boolean;
    begin
      o:=x;cnt:=0;
      for i:=1 to n do r[i]:=0;i:=0;
      while o>0 do
        begin
          inc(i);
          r[i]:=o mod 2;
          inc(cnt,r[i]); //第一行点击次数
          o:=o shr 1;
        end;
      t:=map;
      for i:=1 to n do if(r[i]=1)then
        begin
          t[1,i]:=1-t[1,i];
          t[1,i-1]:=1-t[1,i-1];
          t[1,i+1]:=1-t[1,i+1];
          t[2,i]:=1-t[2,i];
        end; //模拟点击第一行
      for i:=2 to n do
        for j:=1 to n do
          if(t[i-1,j]=p)then //若上一行该列的点未达目标则该行需要点击
              begin
                inc(cnt);
                t[i,j]:=1-t[i,j];
                t[i,j-1]:=1-t[i,j-1];
                t[i,j+1]:=1-t[i,j+1];
                t[i+1,j]:=1-t[1+i,j];
              end;
      flag:=true;
      for i:=1 to n do if(t[n,i]=p)then flag:=false;
      if (not flag) then exit(-1);exit(cnt);
    end;
  begin
    readln(n);
    for i:=1 to n do
      begin
        for j:=1 to n do
          begin
            read(ch);
            if(ch='b')then map[i,j]:=1 else map[i,j]:=0;
          end;
        READLN;//读入一行后要换行
      end;
    ans:=66666;
    for i:=0 to ((1 shl n)-1) do //状态压缩
      begin
        tmp:=check(i,0);//全白
        if(tmp>=0)and(tmp<ans)then ans:=tmp;
        tmp:=check(i,1);//全黑
        if(tmp>=0)and(tmp<ans)then ans:=tmp;
      end;
    if(ans=66666)then writeln('Impossible')else writeln(ans);

  end.
```

---


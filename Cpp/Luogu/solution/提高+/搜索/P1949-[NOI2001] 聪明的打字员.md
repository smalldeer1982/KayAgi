# [NOI2001] 聪明的打字员

## 题目描述

阿兰是某机密部门的打字员，她现在接到一个任务：需要在一天之内输入几百个长度固定为6的密码。当然，她希望输入的过程中敲击键盘的总次数越少越好。

不幸的是，出于保密的需要，该部门用于输入密码的键盘是特殊设计的，键盘上没有数字键，而只有以下六个键：`swap0`，`swap1`，`up`，`down`，`left`，`right`。为了说明这 $6$ 个键的作用，我们先定义录入区的 $6$ 个位置的编号，从左至右依次为 $1,2,3,4,5,6$。下面列出每个键的作用：

- `swap0`：按 `swap0`，光标位置不变，将光标所在的位置的数字与录入区的 $1$ 号位置的数字（左起第一个数字）交换。如果光标已经处在录入区的 $1$ 号位置，则按 `swap0` 键之后录入区的数字不变。

- `swap1`：按 `swap1`，光标位置不变，将光标所在位置的数字与录入区的 $6$ 号位置的数字（左起第六个数字）交换。如果光标已经处在录入区的 $6$ 号位置，则按 `swap1` 键之后录入区的数字不变。

- `up`：按 `up`，光标位置不变，讲光标所在位置的数字加 $1$（除非该数字是 $9$）。例如，如果光标所在位置的数字为 $2$，按 `up` 之后，该处的数字变为 $3$；如果光标所在位置的数字为 $9$，按 `up` 之后，该处的数字不变，光标位置也不变；

- `down`：按 `down`，光标位置不变，讲光标所在位置的数字减 $1$（除非该数字是 $0$）。如果光标所在位置的数字为 $0$，按 `down` 之后，该处的数字不变，光标位置也不变；

- `left`：按 `left`，光标左移一个位置，如果光标已在录入区的 $1$ 号位置（左起第一个位置）上，则光标不动；

- `right`：按 `right`，光标右移一个位置，如果光标已在录入区的 $6$ 号位置（左起第六个位置）上，则光标不动；

当然，为了使这样的键盘发挥作用，每次录入密码之前，录入区总会随机出现一个长度为 $6$ 的初始密码，而且光标会固定出现在 $1$ 号位置上。当巧妙的使用上述六个特殊键之后，可以得到目标密码，这时光标允许停留在任何一个位置。

现在，阿兰需要你的帮助，编写一个程序，求出录入一个密码需要的最少的击键次数。

## 样例 #1

### 输入

```
123456 654321```

### 输出

```
11```

# 题解

## 作者：Poncirus (赞：16)

本题可以采用双向BFS，~~别名大模拟。~~

原因是本题的反向搜索方式与正向相同，也就是说存在反向搜索的方式。

`cqbzljsqwq` 大巨佬的双向BFS强悍的八维数组状态本蒟蒻学不来QwQ

蒟蒻的当前状态就是一个六位数，直接扔到下标里面标记。

那么很明显，用六位数比用字符串做状态快了无数倍，同时也会麻烦无数倍。

比如，本人程序一直很慢的原因是：有超过两小时的时间一直认为存六位数的下标应该开`1e7`的数组，（$10^7-999999=9000001$）导致`memset`直接爆炸。

设计状态：

```cpp
struct node{
    int now;//当前的六位数密码
    int stp;//当前所用步数
    int pos;//当前光标所在位置
    bool flag;//搜索方向，0表示正向，1表示反向
}
```

`left/right`操作好说，直接改变`pos`的值就行了。

但`up/down`和`swap0/swap1`是要改变`now`的某几位上的值，很麻烦。

我们先存储一个数从左向右每一位对应的单位：

```cpp
const int ws[]={1000000,100000,10000,1000,100,10,1};
//防RE，第0位也要存
```

假设我们要将`num`在`pos`上的值更改为`x`，怎么操作呢？

我们将`num`拆成`1~(pos-1)`，`pos`和`(pos+1)~6`三部分。

第一部分和第三部分不变，将第二部分修改为`x*ws[pos]`就行了。

`1~(pos-1)`的获取方式：利用C++整除的特性，`num/ws[pos-1]*ws[pos-1]`就可以得到了。

`(pos+1)~6`的获取方式：`num%ws[pos]`就可以得到`pos`之后位数的值。

由此得出上下操作的代码：

```cpp
//up or down,获取num的pos位增加chg的结果
inline int UpOrDown(int num,int pos,int chg){
    int t=num/ws[pos]%10+chg;
    //获取num的pos位变化后的结果，判断是否可以这样变化
    if(t>=0&&t<=9)
        return num/ws[pos-1]*ws[pos-1]+t*ws[pos]+num%ws[pos];
    return num;
}
```

以及`swap`操作：

```cpp
//swap0 or swap1,获取num的pos位与chg位交换的结果
inline int Swap(int num,int pos,int chg){
    int bg=num/ws[pos]%10;//记录pos位本来的数值
    int ed=num/ws[chg]%10;//记录chg位本来的数值
    if(bg==ed)return num;
    num=num/ws[pos-1]*ws[pos-1]+ed*ws[pos]+num%ws[pos];//pos变为ed
    num=num/ws[chg-1]*ws[chg-1]+bg*ws[chg]+num%ws[chg];//chg变为bg
    return num;
}
```

然后是调到吐的双向BFS。

为了方便同时标记走没走过与所用步数，我们事先将`vis`数组置为`-1`。

完整代码：

```cpp
/*
(twbfs==大模拟)==true
*/
#include<queue>
#include<cstdio>
#include<cstring>
using namespace std;
short vis[1000000][7][2];
struct node{
    int now;
    int stp,pos;
    //pos: 当前光标位置
    bool flag;
}S,B,f,tmp;
queue<node>q;
const int ws[]={1000000,100000,10000,1000,100,10,1};
inline int UpOrDown(int num,int pos,int chg){
    int t=num/ws[pos]%10+chg;
    if(t>=0&&t<=9)
        return num/ws[pos-1]*ws[pos-1]+t*ws[pos]+num%ws[pos];
    return num;
}
inline int Swap(int num,int pos,int chg){
    int bg=num/ws[pos]%10;
    int ed=num/ws[chg]%10;
    if(bg==ed)return num;
    num=num/ws[pos-1]*ws[pos-1]+ed*ws[pos]+num%ws[pos];
    num=num/ws[chg-1]*ws[chg-1]+bg*ws[chg]+num%ws[chg];
    return num;
}
int TWBFS(void){
    //TIANWEN BFS(bushi)
    while(!q.empty()){
        tmp=f=q.front();
        tmp.stp++;
        q.pop();
        if(~vis[f.now][f.pos][!f.flag])
            return f.stp+vis[f.now][f.pos][!f.flag];
        //将光标左移一位
        if(f.pos>1){
            tmp.pos=f.pos-1;
            if(vis[tmp.now][tmp.pos][tmp.flag]==-1){
                vis[tmp.now][tmp.pos][tmp.flag]=tmp.stp;
                q.push(tmp);
            }
        }
        //将光标右移一位
        if(f.pos<6){
            tmp.pos=f.pos+1;
            if(vis[tmp.now][tmp.pos][tmp.flag]==-1){
                vis[tmp.now][tmp.pos][tmp.flag]=tmp.stp;
                q.push(tmp);
            }
        }
        //记得把光标移回来，不要像本蒟蒻一样傻傻踩坑
        tmp.pos=f.pos;
        //将光标所在位置的数值增加1
    	tmp.now=UpOrDown(f.now,f.pos,1);
        if(vis[tmp.now][tmp.pos][tmp.flag]==-1){
            vis[tmp.now][tmp.pos][tmp.flag]=tmp.stp;
            q.push(tmp);
        }
        //将光标所在位置的数值减少1
    	tmp.now=UpOrDown(f.now,f.pos,-1);
        if(vis[tmp.now][tmp.pos][tmp.flag]==-1){
            vis[tmp.now][tmp.pos][tmp.flag]=tmp.stp;
            q.push(tmp);
        }
        //swap0
        if(f.pos!=1){
            tmp.now=Swap(f.now,f.pos,1);
            if(vis[tmp.now][tmp.pos][tmp.flag]==-1){
                vis[tmp.now][tmp.pos][tmp.flag]=tmp.stp;
                q.push(tmp);
            }
        }
        //swap1
    	if(f.now!=6){
            tmp.now=Swap(f.now,f.pos,6);
            if(vis[tmp.now][tmp.pos][tmp.flag]==-1){
                vis[tmp.now][tmp.pos][tmp.flag]=tmp.stp;
                q.push(tmp);
            }
        }
    }
    return 114514;
}
int main(){
    scanf("%d%d",&S.now,&B.now);
    memset(vis,-1,sizeof(vis));
    S.pos=1;
    q.push(S);
    B.flag=1;
    vis[S.now][1][0]=0;
    //最终密码的光标在每一位都有可能出现
    for(int i=1;i<=6;++i){
        B.pos=i;
        vis[B.now][i][1]=0;
        q.push(B);
    }
    printf("%d\n",TWBFS());
    return 0;
}
```

**end.**



---

## 作者：litble (赞：10)

直接广搜，哈希判重即可。

我用了一个数列来表示当前的密码，所以修改有一些套路，看代码吧。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<climits>
#include<cstring>
#include<iomanip>
#include<queue>
using namespace std;
struct node{int num;int gb;int dep;}u,v;
queue<node>q1;
bool vis[1000000][7];//判重
int shi[8]={0,100000,10000,1000,100,10,1};//第i位密码的实际位置，如因为123456中的1是在十万位上所以是十万
int main()
{
    int i,j,mb,kl1,kl2;
    scanf("%d%d",&u.num,&mb);
    if(mb==u.num){printf("0");return 0;}//特判不用改动的方法
    u.gb=1;u.dep=0;q1.push(u);
    while(!q1.empty()){
        u=q1.front();q1.pop();
        kl2=(u.num/shi[u.gb])%10;//提取光标位置的数字
        if(u.gb!=1){
            v=u;v.dep++;v.gb=u.gb-1;
            if(!vis[v.num][v.gb]){vis[v.num][v.gb]=1;q1.push(v);}//左移光标
            v=u;v.dep++;
            kl1=v.num/shi[1];//交换光标处和第1位的数字
            v.num=v.num-kl1*shi[1]+kl2*shi[1]-kl2*shi[v.gb]+kl1*shi[v.gb];
            if(v.num==mb){printf("%d",v.dep);return 0;}
            if(!vis[v.num][v.gb]){vis[v.num][v.gb]=1;q1.push(v);}
        }
        if(u.gb!=6){
            v=u;v.dep++;v.gb=v.gb+1;
            if(!vis[v.num][v.gb]){vis[v.num][v.gb]=1;q1.push(v);}//右移光标
            v=u;v.dep++;
            kl1=v.num%10;
            v.num=v.num-kl1+kl2-kl2*shi[v.gb]+kl1*shi[v.gb];//交换光标处和第6个数字
            if(v.num==mb){printf("%d",v.dep);return 0;}
            if(!vis[v.num][v.gb]){vis[v.num][v.gb]=1;q1.push(v);}
        }
        if(kl2!=0){
            v=u;v.dep++;//当前数字--
            v.num=v.num-shi[v.gb];
            if(v.num==mb){printf("%d",v.dep);return 0;}
            if(!vis[v.num][v.gb]){vis[v.num][v.gb]=1;q1.push(v);}
        }
        if(kl2!=9){
            v=u;v.dep++;//当前数字++
            v.num=v.num+shi[v.gb];
            if(v.num==mb){printf("%d",v.dep);return 0;}
            if(!vis[v.num][v.gb]){vis[v.num][v.gb]=1;q1.push(v);}
        }
    }
    return 0;
}
```

---

## 作者：邓布利多6 (赞：4)

## **广度优先搜索 bfs！**
利用STL队列，数组判重即可
```cpp
#include<iostream>
#include<queue>//头文件
#define break_prt() f=true,ans=node1.step //宏定义，成功并结束
#define makeflag_push() flag[node1.num][node1.line]=true,Q.push(node1)//制标记并把新点进队
using namespace std;
struct node{
	 int num,line,step;
	 //密码，光标位置，步数
}now,node1;
queue<node>Q;//STL队列
bool flag[1000001][7],f;//判重数组，是否成功标记
int sum,num,s,e,cost[8],ans;
void swap_left()//操作1 swap0
{
	 node1=(node){now.num,now.line-1,now.step+1};
	 if(!flag[node1.num][node1.line])makeflag_push();
	 node1=(node){now.num,now.line,now.step+1};
	 sum=node1.num/cost[1];
	 node1.num=node1.num-sum*cost[1]+num*cost[1]-num*cost[node1.line]+sum*cost[node1.line];
	 if(node1.num==e)break_prt();
	 if(!flag[node1.num][node1.line])makeflag_push();
}
void swap_right()//操作2 swap1
{
	 node1=(node){now.num,now.line+1,now.step+1};
	 if(!flag[node1.num][node1.line])makeflag_push();
	 node1=(node){now.num,now.line,now.step+1};
	 sum=node1.num%10;
	 node1.num=node1.num-sum+num-num*cost[node1.line]+sum*cost[node1.line];
	 if(node1.num==e)break_prt();
	 if(!flag[node1.num][node1.line])makeflag_push();
}
void up()//操作3 up
{
	 node1=(node){now.num+cost[node1.line],now.line,now.step+1};
	 if(node1.num==e)break_prt();
	 if(!flag[node1.num][node1.line])makeflag_push();
}
void down()//操作4 down
{
	 node1=(node){now.num-cost[node1.line],now.line,now.step+1};
	 if(node1.num==e)break_prt();
	 if(!flag[node1.num][node1.line])makeflag_push();
}
int main()
{
	 cost[1]=100000;
	 for(int i=2;i<=8;i++)
		  cost[i]=cost[i-1]/10;
	 cin>>s>>e;
	 if(s==e)//特判第二个测试点
	 {
		  cout<<0;
		  return 0;
	 }
	 Q.push((node){s,1,0});//原始密码
	 while(!Q.empty())
	 {
		  if(f)break;
		  now=Q.front();//取目前队首元素
		  Q.pop();
		  num=(now.num/cost[now.line])%10;
		  if(now.line!=1)swap_left();//如果光标不在录入区的1号位置，则尝试操作1
		  if(now.line!=6)swap_right();//如果光标不在录入区的6号位置，则尝试操作2
		  if(num!=9)up();//如果光标所在位置的数字不为9，尝试操作3
		  if(num!=0)down();//如果光标所在位置的数字不为0，尝试操作4
    }
	cout<<ans;
    return 0;
}
```


---

## 作者：远航之曲 (赞：3)

刚开始做的时候才用普通的宽搜，仅仅加了一个判重的优化，经过一些列细节改正后，

果断超时。。。

后来，想出一种了经过大幅度优化过的bfs，先模拟出所有的状态

（这个状态只包括每一位的位置，不管大小），因此，每个状态需要记录每个位置的坐标（s数组)，

经过了哪些位置（size），当前位置（cur），到达此状态需要的步数（sum）

其中，s数组只需要将012345这些代表下标的数进行变换，size有10种情况，对应于sign数组的预

处理中的数，这个需要仔细去体会与验算，我当初就是想了很久。

然后就是利用队列和vis判重通过那四种只改变下标的方式转换状态，用ans记下可行状态。

接下来，在main函数中，将每一种状态转变成实数与最终目的进行比较，如果每一位都相等或者经过该下标

则是可行方案，利用ans[i][7]和abs[b[j]-a[ans[i][j]]]求出step的大小，并进行比较，把最小值给min，

最后输出min就行了。

有些人认为不需要考虑左移的情况，这种想法有问题，000159 和 000519 就是一特例，这里已解决这个问题！！！


```cpp
#include <cstdio>
#include <string>
#include <queue>
#include <cstdlib>
#include <iostream>
#include <algorithm>
using namespace std;
bool vis[6][6][6][6][6][6][6][10]={0};
struct node
{
    int s[6];
    int size,num,cur;
};
int total=0,ans[9000][8];
void bfs()
{
    node now;
    for (int i=0;i<6;i++)
        now.s[i]=i;
    now.size=0;now.cur=0;now.num=0;
    vis[now.s[0]][now.s[1]][now.s[2]][now.s[3]][now.s[4]][now.s[5]][now.cur][now.size]=1;
    queue<node>que;
    que.push(now);
    while(!que.empty())
    {
        now=que.front();
        que.pop();
        for (int i=0;i<6;i++)
            ans[total][i]=now.s[i];
        ans[total][6]=now.size;
        ans[total][7]=now.num;
        total++;
        now.num++;
        if (now.cur>0)//换0，左移 
        {
            swap(now.s[0],now.s[now.cur]);
            if (!vis[now.s[0]][now.s[1]][now.s[2]][now.s[3]][now.s[4]][now.s[5]][now.cur][now.size])
            {
                vis[now.s[0]][now.s[1]][now.s[2]][now.s[3]][now.s[4]][now.s[5]][now.cur][now.size]=1;
                que.push(now);
            }
            swap(now.s[0],now.s[now.cur]);
            now.cur--;
            if (!vis[now.s[0]][now.s[1]][now.s[2]][now.s[3]][now.s[4]][now.s[5]][now.cur][now.size])
            {
                vis[now.s[0]][now.s[1]][now.s[2]][now.s[3]][now.s[4]][now.s[5]][now.cur][now.size]=1;
                que.push(now);
            }
            now.cur++;
        }
        if (now.cur<5)//换5，右移
        {
            int length=now.size;
            now.cur++;
            if (now.cur>now.size||(now.cur>now.size-6 && now.size>5))
            {
                if (now.size==9) 
                    now.size=5;
                else
                    now.size++;
            }
            if (!vis[now.s[0]][now.s[1]][now.s[2]][now.s[3]][now.s[4]][now.s[5]][now.cur][now.size])
            {
                vis[now.s[0]][now.s[1]][now.s[2]][now.s[3]][now.s[4]][now.s[5]][now.cur][now.size]=1;
                que.push(now);
            }
            now.cur--;
            now.size=length;
            if (now.size<4) now.size+=6;
            swap(now.s[now.cur],now.s[5]);
            if (!vis[now.s[0]][now.s[1]][now.s[2]][now.s[3]][now.s[4]][now.s[5]][now.cur][now.size])
            {
                vis[now.s[0]][now.s[1]][now.s[2]][now.s[3]][now.s[4]][now.s[5]][now.cur][now.size]=1;
                que.push(now);
            }
        } 
    }
}
main()
{
    int a[6],b[6],step;
    int min=0x3f3f3f3f;
    string s1,s2;
    bfs();
    cin>>s1>>s2;
    for (int i=0;i<6;i++)
    {
        a[i]=s1[i]-'0';
        b[i]=s2[i]-'0';
    }
int sign[10][6]={{1,0,0,0,0,0},  
                 {1,1,0,0,0,0},  
                 {1,1,1,0,0,0},  
                 {1,1,1,1,0,0},  
                 {1,1,1,1,1,0},  
                 {1,1,1,1,1,1},  
                 {1,0,0,0,0,1},  
                 {1,1,0,0,0,1},  
                 {1,1,1,0,0,1},  
                 {1,1,1,1,0,1}  
                 }; 
    for (int i=0;i<total;i++)
    {
        step=ans[i][7];
        int j;
        for (j=0;j<6;j++)  
            if (b[j]!=a[ans[i][j]]&&!sign[ans[i][6]][j]) 
                break;  
            else 
                step+=abs(b[j]-a[ans[i][j]]); 
        if ((min>step)&&j==6)  
            min=step;
    }
    printf("%d",min);
}
```

---

## 作者：清正美记者 (赞：3)

咳咳...这将成为我第一个认真写的题解。之前上传了很多水题解真的对不住了。因为我强迫症想要按我过题的顺序写题解，但是前面的题真的好没写头啊！

好了回归正题。

这道题，因为我们要模拟打字员的动作，为了清晰可辨，我选择每种操作写一个小函数（~~累赘~~）。模拟操作应该没什么好说的。

好，判重方面，我选择将
### **密码排列加上一位光标位置**
作为编号，空间不会超的，客官放心食用~

怎么说呢，就算是这样，因为我用的循环队列，又很low地开了结构体，所以当数据大了，可能是因为整个队列都直接放不下我的数了，妥妥地就会WA，而我又没办法把队列再开大一点。

嘿哟好气哟。

所以后来就有了我的一个Max和Min的优化。其实我拿到这道题开始写的时候就想用这个优化的。但是当时高了些乌龙，被我放弃了。这些再说。Max和Min拿来干嘛呢？很简单，

### **记录一下目标状态中出现过的最大数和最小数**

因为我们只想要得到某一个范围的数，所以当某一步操作使得我们得到一个状态，其中的数**超出了该范围**，那么该步骤即为**多余的步骤**，之后必须还得把它**加/减回来**，显然我们可以直接**排除**这些步骤。实现上，我便引入了Max值和Min值（注意大写防止冲突），以记录目标状态的最大最小数，并在做up和down时与将产生的数比较，实现剪枝。

上代码吧~

```
#include<iostream>
#include<string.h>
using namespace std;

struct EVA
{								//a[]存状态，dep存到现在有几步操作；
    int a[7],dep,gb,pai;		//gb存光标位置，pai是排列状态；
    char last;				 //上一步是什么操作？
};

EVA pw[1999999],temp;		//pw=password，存状态；
int gl,head,tail,rs;		//gl=goal，目标的编号；
int Max,Min;			   //Max和Min即我的一个剪枝。记得大写防止冲突；
bool v[9999999],flag=0;   //魔理沙从裙底掏出了又黑又大的v数组来判重！！

void swap0()
{
    if(pw[head].gb==1)	return;		//基础剪枝；
    pw[tail]=pw[head];
    int p=pw[tail].a[1];
    pw[tail].a[1]=pw[tail].a[pw[tail].gb];
    pw[tail].a[pw[tail].gb]=p;
    pw[tail].dep++;
    pw[tail].last='0';
    int pai=0;
    for(int i=1;i<=6;i++)	pai=pai*10+pw[tail].a[i];
    if(pai==gl)
    {
        rs=pw[tail].dep;
        flag=1;
    }
    pw[tail].pai=pai*10+pw[tail].gb;
    if(v[pw[tail].pai]!=1) tail++;
    if(tail>1999990)
    	tail=0;
    return;
}

void swap1()
{
    if(pw[head].gb==6)	return;		//基础剪枝*2；
    pw[tail]=pw[head];
    int p=pw[tail].a[6];
    pw[tail].a[6]=pw[tail].a[pw[tail].gb];
    pw[tail].a[pw[tail].gb]=p;
    pw[tail].dep++;
    pw[tail].last='1';
    int pai=0;
    for(int i=1;i<=6;i++)	pai=pai*10+pw[tail].a[i];
    if(pai==gl)
    {
        rs=pw[tail].dep;
        flag=1;
    }
    pw[tail].pai=pai*10+pw[tail].gb;
    if(v[pw[tail].pai]!=1) tail++;
    if(tail>1999990)
    	tail=0;
    return;
}

void up()
{
    if(pw[head].a[pw[head].gb]==9||pw[head].a[pw[head].gb]+1>Max)	return;		//Max的作用~
    pw[tail]=pw[head];
    pw[tail].a[pw[tail].gb]++;
    pw[tail].dep++;
    pw[tail].last='u';
    int pai=0;
    for(int i=1;i<=6;i++)	pai=pai*10+pw[tail].a[i];
    if(pai==gl)
    {
        rs=pw[tail].dep;
        flag=1;
    }
    pw[tail].pai=pai*10+pw[tail].gb;	
    if(v[pw[tail].pai]!=1) tail++;
    if(tail>1999990)
    	tail=0;
    return;
}

void down()
{
    if(pw[head].a[pw[head].gb]==0||pw[head].a[pw[head].gb]-1<Min)	return;		//Min的作用~
    pw[tail]=pw[head];
    pw[tail].a[pw[tail].gb]--;
    pw[tail].dep++;
    pw[tail].last='d';
    int pai=0;
    for(int i=1;i<=6;i++)	pai=pai*10+pw[tail].a[i];
    if(pai==gl)
    {
        rs=pw[tail].dep;
        flag=1;
    }
    pw[tail].pai=pai*10+pw[tail].gb;
    if(v[pw[tail].pai]!=1) tail++;
    if(tail>1999990)
    	tail=0;
    return;
}

void left()
{
    if(pw[head].gb==1)	return;
    pw[tail]=pw[head];
    pw[tail].gb--;
    pw[tail].dep++;
    pw[tail].last='l';
    pw[tail].pai-=1;
    if(v[pw[tail].pai]!=1) tail++;
    if(tail>1999990)
    	tail=0;
    return;
}

void right()
{
    if(pw[head].gb==6)	return;
    pw[tail]=pw[head];
    pw[tail].gb++;
    pw[tail].dep++;
    pw[tail].last='r';
    pw[tail].pai+=1;
    if(v[pw[tail].pai]!=1) tail++;
    if(tail>1999990)
    	tail=0;
    return;
}

int main()
{
    Max=0;Min=99;
    char xx;
    for(int i=1;i<=6;i++)
    {
        cin>>xx;
        pw[0].a[i]=int(xx)-'0';
        if(Max<pw[0].a[i])	Max=pw[0].a[i];
        if(Min>pw[0].a[i])	Min=pw[0].a[i];
    }
    pw[0].gb=1;
    pw[0].last='N';		//总得让它装点什么才能开始吧？
    pw[0].dep=0;
    gl=0;
    for(int i=1;i<=6;i++)
    {
        cin>>xx;
        temp.a[i]=int(xx)-'0';
        if(Max<temp.a[i])	Max=temp.a[i];		//存Max；
        if(Min>temp.a[i])	Min=temp.a[i];		//存Min；
        gl=gl*10+temp.a[i];		//存目标状态；
    }
    head=0;tail=1;
    int pai=0;
    for(int i=1;i<=6;i++)	pai=pai*10+pw[head].a[i];
    if(pai==gl)
    {
        rs=pw[head].dep;
        flag=1;
    }
    pw[head].pai=pai*10+1;
    while(head!=tail)
    {
    	if(head>1999990)
            head=0;
        if(flag==1)	break;
        if(v[pw[head].pai]==1)
        {
            head++;
            continue;
        }
        else
        {
            v[pw[head].pai]=1;
            if(pw[head].last!='0')	swap0();		//这些if都是基础剪枝；
            if(pw[head].last!='1')	swap1();
            if(pw[head].last!='d')	up();
            if(pw[head].last!='u')	down();
            if(pw[head].last!='r')	left();
            if(pw[head].last!='l')	right();
            if(flag==1)	break;
        }
        head++;
    }
    cout<<rs;
    return 0;
}
```

emm，应该就是这些了吧！其实我知道我这些小伎俩早就被大佬们看穿用烂了，但是这些都是我自己想出来的还是挺辛苦的。好吧这题就到这里吧，收工啦！（~~毕竟看看有没有新闻可做才是鸦天狗的正事~~）

---

## 作者：KAMIYA_KINA (赞：2)


## 思路
广度优先搜索 ( **BFS** )

## 心路历程
这个题，搞了我大概2个小时（我是真的菜），给大家看一张我交题的截图吧。  

![](https://cdn.luogu.com.cn/upload/image_hosting/wul09etp.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

全程的心路立场大概就是

> 这不应该呀，这怎么会呢。

> 这不正常啊，这时间复杂度不应该呀。

> 怎么会错呢，怎么会呢？

我的心情从愉悦变成了不愉悦，然后心态开始爆炸。

## 几个提交方案
### map + 字符串
我用字符串去存储每一个答案的情况，然后用 map 去存是否遍历到了。

代码如下：
~~~cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
#include<map>
#include<set>
using namespace std;
const int redu = 1e7;
map<string,bool>book;
map<string,bool>ans;
inline string solve(string x,int w) {
	string ret = x;
	int pos = ret[0] - '0';
	switch(w){
		case 1:swap(ret[1],ret[pos]);break;
		case 2:swap(ret[6],ret[pos]);break;
		case 3:ret[pos] += (ret[pos] != '9');break;
		case 4:ret[pos] -= (ret[pos] != '0');break;
		case 5:ret[0] -= (ret[0] != '1');break;
		case 6:ret[0] += (ret[0] != '6');break;
	}
	return ret;
}
string a,b;
int main() {
	cin >> a >> b;
	a = "1" + a;
	book[a] = true;
	for(int i = 1; i <= 6; i++) {
		char tem = i + '0';
		ans[tem + b] = true;
	}
	if(ans[a] == true) {
		cout << 0 << endl;
		return 0;
	}
	queue<pair<string,int> >Q;
	Q.push(make_pair(a,0));
	while(!Q.empty()) {
		pair<string,int> u = Q.front();Q.pop();
		for(int i = 1; i<= 6; i++) {
			string tem = solve(u.first,i);
			if(book[tem] == true) continue;
			else if(ans[tem] == true) {
				cout << u.second + 1;
				return 0;
			} else {
				book[tem] = true;
				Q.push(make_pair(tem,u.second+1));	
			}
		}
	}
	return 0;
} 
~~~
得分：不怎么样。

### bool数组存记录 + map存答案 + stoi + to_string 的存储方式
第二次我用了 `c++11` 中就有的两个函数，分别是 `stoi` ，表示 `string` 类型转化为 `int` 类型，`to_string` 表示任意类型转化为 `string` 类型。

~~还蛮好用的~~。

代码如下：
~~~cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
#include<map>
#include<set>
#include<cctype>
using namespace std;
const int redu = 1e7;
bool book[redu * 7];
map<int,bool>ans;
inline int solve(int x,int w) {
	string ret = to_string(x);
	int pos = ret[0] - '0';
	switch(w){
		case 1:swap(ret[1],ret[pos]);break;
		case 2:swap(ret[6],ret[pos]);break;
		case 3:ret[pos] += (ret[pos] != '9');break;
		case 6:ret[pos] -= (ret[pos] != '0');break;
		case 5:ret[0] -= (ret[0] != '1');break;
		case 4:ret[0] += (ret[0] != '6');break;
	}
	return stoi(ret);
}
string a,b;
int main() {
	cin >> a >> b;
	a = "1" + a;
	book[stoi(a)] = true;
	for(int i = 1; i <= 6; i++) {
		char tem = i + '0';
		int d = stoi(tem + b);
		ans[d] = true;
	}
	if(ans[stoi(a)]){
		cout << 0;
		return 0;
	}
	queue<pair<int,int> >Q;
	Q.push(make_pair(stoi(a),0));
	while(!Q.empty()) {
		pair<int,int> u = Q.front();Q.pop();
		for(int i = 1; i<= 6; i++) {
			int tem = solve(u.first,i);
			if(book[tem] == true) continue;
			else if(ans[tem] == true) {
				cout << u.second + 1;
				return 0;
			} else {
				book[tem] = true;
				Q.push(make_pair(tem,u.second+1));	
			}
		}
	}
	return 0;
} 
~~~

结果：也不怎么样。

从这个时候开始我的内心已经开始奔腾羊驼了，但是我本着一定要 ac 的气势，将字符串操作变成 `int` 操作。

于是就有了下面的代码：
~~~cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
#include<map>
#include<set>
#include<cctype>
#include<cmath>
using namespace std;
const int redu = 1e6;
bool book[redu * 7];
map<int,bool>ans;
inline int solve(int x,int w) {
	int ret = x;
	int pos = ret / redu;
	
	if(w == 1){int a = (ret / (redu / 10) ) % 10,b = (int)(ret / (redu / pow(10,pos))) % 10;ret -= a * (redu / 10) + (b * (redu / pow(10,pos)));ret += b * (redu / 10) + (a * (redu / pow(10,pos)));}
	else if(w == 2){int a = ret % 10,b = (int)(ret / (redu / pow(10,pos))) % 10;ret -= a + (b * (redu / pow(10,pos)));ret += b + (a * (redu / pow(10,pos)));}
	else if(w == 3){int a = (int)(ret / (redu / pow(10,pos))) % 10;if(a != 9)ret += redu / pow(10,pos);}
	else if(w == 4){int a = (int)(ret / (redu / pow(10,pos))) % 10;if(a != 0)ret -= redu / pow(10,pos);}
	else if(w == 5){if(pos != 1)ret -= redu;}
	else if(w == 6){if(pos != 6)ret += redu;}
	
	return ret;
}
int a,b;
int main() {
	cin >> a >> b;
	a += redu;
	book[a] = true;
	for(int i = 1; i <= 6; i++) {
		ans[b + redu * i] = true;
	}
	if(ans[a]){
		cout << 0;
		return 0;
	}
	queue<pair<int,int> >Q;
	Q.push(make_pair(a,0));
	while(!Q.empty()) {
		pair<int,int> u = Q.front();Q.pop();
		for(int i = 1; i<= 6; i++) {
			int tem = solve(u.first,i);
			if(book[tem] == true) continue;
			else if(ans[tem] == true) {
				cout << u.second + 1;
				return 0;
			} else {
				book[tem] = true;
				Q.push(make_pair(tem,u.second+1));	
			}
		}
	}
	return 0;
} 
~~~

本以为努力可以变成 ac ，但是现实告诉我不行。

得分：36 pts
### 全部用bool数组存状态
于是苦思冥想之后，我将 ans 的记录从 map 变成了 bool，然后我就 a 了？

代码如下：
~~~cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
#include<map>
#include<set>
#include<cctype>
#include<cmath>
using namespace std;
const int redu = 1e6;
const int lis[]={1000000,100000,10000,1000,100,10,1};
bool book[redu * 7];
bool ans[redu * 7];
inline int solve(int x,int w) {
	int ret = x;
	int pos = ret / redu;
	if(w == 1){int a = (ret / lis[1] ) % 10,b = (ret / lis[pos]) % 10;ret -= a * lis[1] + b * lis[pos];ret += b * lis[1] + a * lis[pos];}
	else if(w == 2){int a = ret % 10,b = (ret / lis[pos]) % 10;ret -= a + (b * lis[pos]);ret += b + (a * lis[pos]);}
	else if(w == 3){int a = (int)(ret / lis[pos]) % 10;if(a != 9)ret += lis[pos];}
	else if(w == 4){int a = (int)(ret / lis[pos]) % 10;if(a != 0)ret -= lis[pos];}
	else if(w == 5){if(pos != 1)ret -= redu;}
	else if(w == 6){if(pos != 6)ret += redu;}
	return ret;
}
int a,b;
int main() {
	cin >> a >> b;
	a += redu;
	book[a] = true;
	for(int i = 1; i <= 6; i++) {
		ans[b + redu * i] = true;
	}
	if(ans[a]){
		cout << 0;
		return 0;
	}
	queue<pair<int,int> >Q;
	Q.push(make_pair(a,0));
	while(!Q.empty()) {
		pair<int,int> u = Q.front();Q.pop();
		for(int i = 1; i<= 6; i++) {
			int tem = solve(u.first,i);
			if(book[tem] == true) continue;
			else if(ans[tem] == true) {
				cout << u.second + 1;
				return 0;
			} else {
				book[tem] = true;
				Q.push(make_pair(tem,u.second+1));	
			}
		}
	}
	return 0;
} 
~~~

## 结语
希望大家以后能少用 stl 就少用 stl ，这玩意容易上瘾。

---

## 作者：yizimi远欣 (赞：2)

### 题目描述
阿兰是某机密部门的打字员，她现在接到一个任务：需要在一天之内输入几百个长度固定为6的密码。当然，她希望输入的过程中敲击键盘的总次数越少越好。

不幸的是，出于保密的需要，该部门用于输入密码的键盘是特殊设计的，键盘上没有数字键，而只有以下六个键：swap0,swap1,up,down,left,right。为了说明这6个键的作用，我们先定义录入区的6个位置的编号，从左至右依次为1,2,3,4,5,6。下面列出每个键的作用：

swap0：按swap0，光标位置不变，将光标所在的位置的数字与录入区的1号位置的数字(左起第一个数字)交换。如果光标已经处在录入区的1号位置，则按swap0键之后录入区的数字不变。

swap1：按swap1，光标位置不变，将光标所在位置的数字与录入区的6号位置的数字（左起第六个数字）交换。如果光标已经处在录入区的6号位置，则按swap1键之后录入区的数字不变。

up：按up，光标位置不变，讲光标所在位置的数字加1（除非该数字是9）。例如，如果光标所在位置的数字为2，按up之后，该处的数字变为3；如果光标所在位置的数字为9，按up之后，该处的数字不变，光标位置也不变；

down：按down，光标位置不变，讲光标所在位置的数字减1（除非该数字是0）。如果光标所在位置的数字为0，按down之后，该处的数字不变，光标位置也不变；

left：按left，光标左移一个位置，如果光标已在录入区的1号位置（左起第一个位置）上，则光标不动；

right：按right，光标右移一个位置，如果光标已在录入区的6号位置（左起第六个位置）上，则光标不动；

当然，为了使这样的键盘发挥作用，每次录入密码之前，录入区总会随机出现一个长度为6的初始密码，而且光标会固定出现在1号位置上。当巧妙的使用上述六个特殊键之后，可以得到目标密码，这时光标允许停留在任何一个位置。

现在，阿兰需要你的帮助，编写一个程序，求出录入一个密码需要的最少的击键次数。

### 输入输出格式
#### 输入格式：
仅一行，含有两个长度为6的数，前者为初始密码，后者为目标密码，两个密码之间用一个空格隔开。

#### 输出格式：
仅一行，含有一个正整数，为最少需要的击键次数。

### 输入输出样例
#### 输入样例#1：
	123456 654321
#### 输出样例#1：
	11
    
### 主要思路：BFS + 循环队列

这个题的数只有6位，我们直接当六位数存不就好了

首先不能写DFS，明显这题BFS要比DFS更优（DFS不就退化成了穷举吗（大雾））

swap0，swap1，up，down操作，直接模拟就好，left和right就更好办了，直接更新光标左右就好。

### code#1:36分（肯定TLE了）

~~福利：自带野生debug代码~~

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<queue>
using namespace std;
#define go(i,j,n,k) for(int i=j;i<=n;i+=k)
#define fo(i,j,n,k) for(int i=j;i>=n;i-=k)
inline ll read(){
    ll x=0,f=1;char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-')f=-f;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
inline void fre() {
    freopen(".in", "r", stdin);
    freopen(".out", "w", stdout);
}
int st, ed;
int vis[1000100][7]; // 判重数组

inline int swap0(int x, int now) {
    int res = 1;
    now = 6 - now + 1;
    go(i, 1, now - 1, 1) res *= 10;
    int xx = (x / res) % 10;
    int yy = (x / 100000);
    int ans = x;
    ans -= xx * res;
    ans -= yy * 100000;
    ans += xx * 100000;
    ans += yy * res;
    return ans;
}
inline int swap1(int x, int now) {
    int res = 1;
    now = 6 - now + 1;
    go(i, 1, now - 1, 1) res *= 10;
    int xx = (x / res) % 10;
    int yy = x % 10;
    int ans = x;
    ans -= xx * res;
    ans -= yy;
    ans += xx;
    ans += yy * res;
    return ans;
}
inline int up(int x, int now) {
    int res = 1;
    now = 6 - now + 1;
    go(i, 1, now - 1, 1) res *= 10;
    int ju = (x / res) % 10;
    if(ju == 9) return x;
    return x + res;
}
inline int down(int x, int now) {
    int res = 1;
    now = 6 - now + 1;
    go(i, 1, now - 1, 1) res *= 10;
    int ju = (x / res) % 10;
    if(ju == 0) return x;
    return x - res;
}
// 四种操作
inline void debug() {
    puts("debug模式：");
    puts("1.swap0  2.swap1");
    puts("3.up     4.down");
    int s = read(), st = read(), now = read();
    if(s == 1) {
        cout << swap0(st, now) << "\n";
    } else if(s == 2) {
        cout << swap1(st, now) << "\n";
    } else if(s == 3) {
        cout << up(st, now) << "\n";
    } else if(s == 4) {
        cout << down(st, now) << "\n";
    }
}

struct node{
    int x, now, dep;
    node(int _x = 0, int _now = 0, int _dep = 0) : x(_x), now(_now), dep(_dep) {}
    node() : node(0, 0, 0) {}
};
queue<node> q;
inline int bfs(int st, int ed) {
    q.push(node(st, 1, 0));
    while(!q.empty()) {
        node get = q.front(); q.pop();
        int oo, x = get.x, now = get.now, deep = get.dep;
        vis[x][now] = 1;
        if(x == ed)
            return deep;
        oo = swap0(x, now);
        if(!vis[oo][now]) q.push(node(oo, now, deep + 1));
        oo = swap1(x, now);
        if(!vis[oo][now]) q.push(node(oo, now, deep + 1));
        oo = up(x, now);
        if(!vis[oo][now]) q.push(node(oo, now, deep + 1));
        oo = down(x, now);
        if(!vis[oo][now]) q.push(node(oo, now, deep + 1));
        if(now > 1 && !vis[x][now - 1]) q.push(node(x, now - 1, deep + 1)); // 注意这里的特判！now不能越界！
        if(now < 6 && !vis[x][now + 1]) q.push(node(x, now + 1, deep + 1)); // 注意这里的特判！now不能越界！
    }
}

int main(){
    //fre();
    // while(1) 
    //	debug();
    st = read(), ed = read();
    if(st == ed) {
        cout << "0\n";
        return 0;
    }
    cout << bfs(st, ed) << "\n";
    return 0;
}
```

为什么会TLE？

首先，尽管我们在入队之前就已经判重了，但是这个代码会重复插一样的点，所以我们可以在从队列中取出时来再次判重。

而且，众所周知，有种说法说STL很慢，所以我好奇的自己手写了个队列。

### code#2:72分（这次WA了）

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
#define go(i,j,n,k) for(int i=j;i<=n;i+=k)
#define fo(i,j,n,k) for(int i=j;i>=n;i-=k)
#define mn 10000100
inline ll read(){
    ll x=0,f=1;char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-')f=-f;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
inline void fre() {
    freopen(".in", "r", stdin);
    freopen(".out", "w", stdout);
}
int st, ed;
bool vis[1000100][7]; // 判重数组 
int ans = inf;
int ress[7] = {0, 1, 10, 100, 1000, 10000, 100000};

inline int swap0(int x, int now) {
    now = 6 - now + 1;
    int res = ress[now];
    int xx = (x / res) % 10;
    int yy = (x / 100000);
    int ans = x;
    ans -= xx * res;
    ans -= yy * 100000;
    ans += xx * 100000;
    ans += yy * res;
    return ans;
}
inline int swap1(int x, int now) {
    now = 6 - now + 1;
    int res = ress[now];
    int xx = (x / res) % 10;
    int yy = x % 10;
    int ans = x;
    ans -= xx * res;
    ans -= yy;
    ans += xx;
    ans += yy * res;
    return ans;
}
inline int up(int x, int now) {
    now = 6 - now + 1;
    int res = ress[now];
    int ju = (x / res) % 10;
    if(ju == 9) return x;
    return x + res;
}
inline int down(int x, int now) {
    now = 6 - now + 1;
    int res = ress[now];
    int ju = (x / res) % 10;
    if(ju == 0) return x;
    return x - res;
}

inline void debug() {
    puts("debug模式：");
    puts("1.swap0  2.swap1");
    puts("3.up     4.down");
    int s = read(), st = read(), now = read();
    if(s == 1) {
        cout << swap0(st, now) << "\n";
    } else if(s == 2) {
        cout << swap1(st, now) << "\n";
    } else if(s == 3) {
        cout << up(st, now) << "\n";
    } else if(s == 4) {
        cout << down(st, now) << "\n";
    }
}
// 手写队列哦QwQ
int X[mn], Now[mn], dep[mn], head = 1, tail = 0;
int x, now, oo, deep;
inline int bfs(int st, int ed) {
    ++tail, X[tail] = st, Now[tail] = 1, dep[tail] = 0;
    while(head <= tail) {
        x = X[head], now = Now[head], deep = dep[head]; head++;
        // cout << x << " " << now << " " << deep << "\n";
        if(vis[x][now]) continue; // 调用前再次判重
        vis[x][now] = 1;
        if(x == ed) return deep;
        oo = swap0(x, now);
        if(!vis[oo][now]) ++tail, X[tail] = oo, Now[tail] = now, dep[tail] = deep + 1;
        oo = swap1(x, now);
        if(!vis[oo][now]) ++tail, X[tail] = oo, Now[tail] = now, dep[tail] = deep + 1;
        oo = up(x, now);
        if(!vis[oo][now]) ++tail, X[tail] = oo, Now[tail] = now, dep[tail] = deep + 1;
        oo = down(x, now);
        if(!vis[oo][now]) ++tail, X[tail] = oo, Now[tail] = now, dep[tail] = deep + 1;
        if(now > 1 && !vis[x][now - 1]) ++tail, X[tail] = x, Now[tail] = now - 1, dep[tail] = deep + 1;
        if(now < 6 && !vis[x][now + 1]) ++tail, X[tail] = x, Now[tail] = now + 1, dep[tail] = deep + 1;
    }
    return deep + 1;
}
int main(){
    st = read(), ed = read();
    if(st == ed) {
        cout << "0\n";
        return 0;
    }
    cout << bfs(st, ed) << "\n";
    return 0;
}
```

~~怎么还不AC~~

我们可以试着把数组开大点，咦？多了9分？

好像是数组大小？？但是我的空间已经开到最大了啊

这个时候就可以用循环队列卡空间了

具体写法看代码

### code#3:100分

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
#define go(i,j,n,k) for(int i=j;i<=n;i+=k)
#define fo(i,j,n,k) for(int i=j;i>=n;i-=k)
#define mn 10000100
inline ll read(){
    ll x=0,f=1;char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-')f=-f;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
inline void fre() {
    freopen(".in", "r", stdin);
    freopen(".out", "w", stdout);
}
int st, ed;
bool vis[1000100][7]; // 判重数组 
int ress[7] = {0, 1, 10, 100, 1000, 10000, 100000};
int res, xx, yy, ans, ju;
inline int swap0(int x, int now) {
    now = 6 - now + 1;
    res = ress[now];
    xx = (x / res) % 10;
    yy = (x / 100000);
    ans = x;
    ans -= xx * res;
    ans -= yy * 100000;
    ans += xx * 100000;
    ans += yy * res;
    return ans;
}
inline int swap1(int x, int now) {
    now = 6 - now + 1;
    res = ress[now];
    xx = (x / res) % 10;
    yy = x % 10;
    ans = x;
    ans -= xx * res;
    ans -= yy;
    ans += xx;
    ans += yy * res;
    return ans;
}
inline int up(int x, int now) {
    now = 6 - now + 1;
    res = ress[now];
    ju = (x / res) % 10;
    if(ju == 9) return x;
    return x + res;
}
inline int down(int x, int now) {
    now = 6 - now + 1;
    res = ress[now];
    ju = (x / res) % 10;
    if(ju == 0) return x;
    return x - res;
}

inline void debug() {
    puts("debug模式：");
    puts("1.swap0  2.swap1");
    puts("3.up     4.down");
    int s = read(), st = read(), now = read();
    if(s == 1) {
        cout << swap0(st, now) << "\n";
    } else if(s == 2) {
        cout << swap1(st, now) << "\n";
    } else if(s == 3) {
        cout << up(st, now) << "\n";
    } else if(s == 4) {
        cout << down(st, now) << "\n";
    }
}

int X[mn], Now[mn], dep[mn], head = 0, tail = 0;
int x, now, oo, deep;
inline int bfs(int st, int ed) {
    ++tail, X[tail] = st, Now[tail] = 1, dep[tail] = 0;
    while(head != tail) { // 这里就不能是head <= tail了
        ++head;
        if(head > 10000000) head = 0; // 记得循环
        x = X[head], now = Now[head], deep = dep[head]; 
        // cout << x << " " << now << " " << deep << "\n";
        if(x == ed) return deep;
        if(vis[x][now]) continue;
        vis[x][now] = 1;
        oo = swap0(x, now);
        if(!vis[oo][now]) {   // 都要循环的QAQ
            if(++tail > 10000000) tail = 0;
            X[tail] = oo, Now[tail] = now, dep[tail] = deep + 1;
        }
        oo = swap1(x, now);
        if(!vis[oo][now]) {
            if(++tail > 10000000) tail = 0;
            X[tail] = oo, Now[tail] = now, dep[tail] = deep + 1;
        }
        oo = up(x, now);
        if(!vis[oo][now]) {
            if(++tail > 10000000) tail = 0;
            X[tail] = oo, Now[tail] = now, dep[tail] = deep + 1;
        }
        oo = down(x, now);
        if(!vis[oo][now]) {
            if(++tail > 10000000) tail = 0;
            X[tail] = oo, Now[tail] = now, dep[tail] = deep + 1;
        }
        if(now > 1 && !vis[x][now - 1]) {
            if(++tail > 10000000) tail = 0; 
            X[tail] = x, Now[tail] = now - 1, dep[tail] = deep + 1;
        }
        if(now < 6 && !vis[x][now + 1]) {
            if(++tail > 10000000) tail = 0; 
            X[tail] = x, Now[tail] = now + 1, dep[tail] = deep + 1;
        }
    }
    return deep + 1;
}

int main(){
    st = read(), ed = read();
    if(st == ed) {
        cout << "0\n";
        return 0;
    }
    cout << bfs(st, ed) << "\n";
    return 0;
}

```

#### 希望可以帮到被卡空间的同学

---

## 作者：少年如斯 (赞：2)

没有手打的队列和哈希，那我就来发一波


状态:光标+字符状态；位数正好7位可以存过（10^7==>9.5MB）；用于判重；


模拟搜索过程+哈希判充


```cpp
#include<bits/stdc++.h>
using namespace std;
bool vis[10000000];int ans,p[7];
struct node{int ans,tot;long long int pre;}team[7000010];
int main()
{
//    freopen("Clever.in","r",stdin);
    //freopen("Clever.out","w",stdout);
    scanf("%d%d",&team[1].ans,&ans);
    if(team[1].ans==ans){cout<<0;return 0;}
    int head=0,top=1;vis[team[1].ans+p[6]]=true; 
    team[1].tot=1;p[0]=1;p[1]=10;p[2]=100;
    p[3]=1000;p[4]=10000;p[5]=100000;p[6]=1000000;
    while(head!=top)
    {
        head++;
        for(int i=1;i<=6;i++)
        {
            int xx=team[head].ans,tot=team[head].tot,wei1=(xx/p[6-tot])%10;
            if(i==1&&tot!=6)
            {
                int wei2=xx%10;
                xx=xx-wei1*p[6-tot]-wei2+wei2*p[6-tot]+wei1;
                if(vis[xx+p[6]*tot]==true) continue;
                vis[xx+p[6]*tot]=true;team[++top].ans=xx;
                team[top].pre=team[head].pre+1;team[top].tot=tot;
                if(xx==ans){cout<<team[top].pre;return 0;}
            }
            else if(i==2&&tot!=1)
            {
                int wei2=xx/p[5];
                xx=xx-wei1*p[6-tot]-wei2*p[5]+wei1*p[5]+wei2*p[6-tot];
                if(vis[xx+p[6]*tot]==true) continue;
                vis[xx+p[6]*tot]=true;team[++top].ans=xx;
                team[top].pre=team[head].pre+1;team[top].tot=tot;
                if(xx==ans){cout<<team[top].pre;return 0;}
            }
            else if(i==3&&wei1!=9)
            {
                xx=xx+p[6-tot];
                if(vis[xx+p[6]*tot]==true) continue;
                vis[xx+p[6]*tot]=true;team[++top].ans=xx;
                team[top].pre=team[head].pre+1;team[top].tot=tot;
                if(xx==ans){cout<<team[top].pre;return 0;}
            }
            else if(i==4&&wei1!=0)//0不可以写成1，考试坑了我50分
            {
                xx=xx-p[6-tot];
                if(vis[xx+p[6]*tot]==true) continue;
                vis[xx+p[6]*tot]=true;team[++top].ans=xx;
                team[top].pre=team[head].pre+1;team[top].tot=tot;
                if(xx==ans){cout<<team[top].pre;return 0;}
            }
            else if(i==5&&tot!=1)
            {
                if(vis[xx+p[6]*(tot-1)]==true) continue;
                team[++top]=team[head];team[top].pre++;
                team[top].tot--;vis[xx+p[6]*team[top].tot]=true;//*//
                if(xx==ans){cout<<team[top].pre;return 0;}
            }
            else if(i==6&&tot!=6)
            {
                if(vis[xx+p[6]*(tot+1)]==true) continue;
                team[++top]=team[head];team[top].pre++;
                team[top].tot++;vis[xx+p[6]*team[top].tot]=true;//*//
                if(xx==ans){cout<<team[top].pre;return 0;}
            }
        }
    }
}
```

---

## 作者：动态WA (赞：1)

老师说这道题直接搜会TLE的，我冒着风险试了试，居然A了(其实是有优化啦)

优化不会太难，请放心食用，~~只是数位的转换可能有会晕眩效果~~

主要思路:用int型存储状态，状态有密码值和光标位置两个参数，再用bool数组判重

缺点：数位交换的代码写得我要炸，~~用数组的话直接swap就完事了~~

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;
struct node{
	int num,line,step;
};
bool c[1000000][7];
queue<node> q;
int a,b;
int main(){
	cin>>a>>b;
	node dw;
	dw.num=a;
	dw.line=1;
	dw.step=0;
	q.push(dw);
	c[dw.num][dw.line]=1;
	while (!q.empty()){
		node d=q.front();
		q.pop();
		if (d.num==b){
			cout<<d.step;
			return 0;
		}
		d.step++;
		node r;
		if (d.line>1){
			r=d;
			r.line--;//光标左拉
			if (!c[r.num][r.line]){
				q.push(r);
				c[r.num][r.line]=1;
			}
			r.line++;
			int gao=r.num/100000;
			int wei=1;
			for (int i=1;i<=6-r.line;i++)
				wei*=10;
			int di=r.num/wei%10;
			r.num%=100000;
			r.num+=100000*di;
			r.num=r.num-di*wei+gao*wei;//1和当前位交换
			if (!c[r.num][r.line]){
				q.push(r);
				c[r.num][r.line]=1;
			}
		}
		if (d.line<6){
			r=d;
			r.line++;//光标右拉
			if (!c[r.num][r.line]){
				q.push(r);
				c[r.num][r.line]=1;
			}
			r.line--;
			int di=r.num%10;
			int wei=1;
			for (int i=1;i<=6-r.line;i++)
				wei*=10;
			int gao=r.num/wei%10;
			r.num=r.num-di+gao;
			r.num=r.num-gao*wei+di*wei;//6和当前位交换
			if (!c[r.num][r.line]){
				q.push(r);
				c[r.num][r.line]=1;
			}
		}
		r=d;
		int wei=1;
		for (int i=1;i<=6-r.line;i++)
			wei*=10;
		if (r.num/wei%10<9){
			r.num+=wei;//当前位加1
			if (!c[r.num][r.line]){
				q.push(r);
				c[r.num][r.line]=1;
			}
			r.num-=wei;
		}
		if (r.num/wei%10>0){
			r.num-=wei;//当前位减1
			if (!c[r.num][r.line]){
				q.push(r);
				c[r.num][r.line]=1;
			}
			r.num+=wei;
		}
	}
} 
```

写这种代码的感觉跟在画几条辅助线后找全等三角形的感觉是一样的

---


# [HAOI2007] 分割矩阵

## 题目描述

将一个 $a\times b$ 的数字矩阵进行如下分割：将原矩阵沿某一条直线分割成两个矩阵，再将生成的两个矩阵继续如此分割（当然也可以只分割其中的一个），这样分割了 $(n-1)$ 次后，原矩阵被分割成了 $n$ 个矩阵。（每次分割都只能沿着数字间的缝隙进行）

原矩阵中每一位置上有一个分值，一个矩阵的总分为其所含各位置上分值之和。现在需要把矩阵按上述规则分割成 $n$ 个矩阵，并使各矩阵总分的均方差最小。

请编程对给出的矩阵及 $n$，求出均方差的最小值。


## 样例 #1

### 输入

```
5 4 4
2 3 4 6
5 7 5 1
10 4 0 5
2 0 2 3
4 1 1 1
```

### 输出

```
0.50```

# 题解

## 作者：niiick (赞：13)

楼上的记搜和我差不多，可惜没怎么解释，~~以及楼上上竟然惊现七重循环???~~

**记忆化搜索**

首先均方差(标准差)的公式为$σ=\sqrt{\sum_{i=1}^n\frac{(x_i-\overline{x})^2}{n}}$
($x_i$是第$i$个矩阵的总分，$\overline{x}$为n个矩阵总分的平均数)

由于$n$不变，我们实际要求的就是$(x_i-\overline{x})^2$最小

$DP[a][b][c][d][num]$表示**将矩阵**$(a,b,c,d)$**分割成**$num$**个可以得到的**$(x_i-\overline{x})^2$**最小值**

那么有状态转移方程

**（枚举竖着切，**$i\in[b,d)$**）**

$DP[a,b,c,d,num]=Min_{k=1}^{num-1}(DP[a,b,c,i,k]+DP[a,i+1,c,d,num-k])$


**（枚举横着切，**$i\in[a,c)$**）**

$DP[a,b,c,d,num]=Min_{k=1}^{num-1}(DP[a,b,i,d,k]+DP[i+1,b,c,d,num-k])$


当$num==1$时，返回$(sum[a,b,c,d]-\overline{x})^2$

最后答案为$\sqrt{\frac{DP[1][1][a][b][n]}{n}}$
******************

```cpp
//niiick
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
#include<cmath>
using namespace std;
typedef long long lt;
typedef double dd;
#define sqr(x) ((x)*(x))

int read()
{
    int x=0,f=1;
    char ss=getchar();
    while(ss<'0'||ss>'9'){if(ss=='-')f=-1;ss=getchar();}
    while(ss>='0'&&ss<='9'){x=x*10+ss-'0';ss=getchar();}
    return x*f;
}

const int maxn=17;
int n,m,k;
int a[maxn][maxn],sum[maxn][maxn];
dd dp[maxn][maxn][maxn][maxn][maxn],ave;

dd qsum(int a,int b,int c,int d){return (dd)(sum[c][d]-sum[a-1][d]-sum[c][b-1]+sum[a-1][b-1]);}

dd DP(int a,int b,int c,int d,int num)
{
    if(dp[a][b][c][d][num]) return dp[a][b][c][d][num];
    else if(num==1) return sqr(qsum(a,b,c,d)-ave);
    dp[a][b][c][d][num]=1e9;
    for(int i=b;i<d;++i)
    for(int j=1;j<num;++j)
    {
        dd tt=DP(a,b,c,i,j)+DP(a,i+1,c,d,num-j);
        dp[a][b][c][d][num]=min(dp[a][b][c][d][num],tt);
    }
    for(int i=a;i<c;++i)
    for(int j=1;j<num;++j)
    {
        dd tt=DP(a,b,i,d,j)+DP(i+1,b,c,d,num-j);
        dp[a][b][c][d][num]=min(dp[a][b][c][d][num],tt);
    }
    return dp[a][b][c][d][num];
}

int main()
{
    n=read();m=read();k=read();
    for(int i=1;i<=n;++i)
    for(int j=1;j<=m;++j)
    a[i][j]=sum[i][j]=read(),
    sum[i][j]+=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1];
    
    ave=(dd)sum[n][m]/(dd)k;
    printf("%.2lf",sqrt(DP(1,1,n,m,k)/(dd)k));
    return 0;
}
```



---

## 作者：BADFIVE (赞：6)

这道题需要使用**记忆化搜索**。    
我们还需要用到**标准差**，公式就是： $x=\sqrt{ \dfrac{\sum_{i=1}^n(x_i-\bar{x})^2}{n} }$   
为了方便计算先把求**平均方差**的公式展开化简，无论怎样分割平均数都不变。   
**化简：** 原式： $(x1^2+x2^2+...+xn^2)/n-(sum/n)^2$ ,所以我们需要把$x$的平方和算成最小值。   
**思路：** 用 $f[x1][y1][x2][y2][k]$ 表示以 $(x1,y1)$ 为左上角， $(x2,y2)$ 为右下角，把这个矩阵分成 $k$ 份的最小平方和。之后我们枚举切割位置（横着、竖着），再枚举切割后的两块中一块分成的块数（ $1 \rightarrow k-1$ ），用记忆化搜索来做就可以了。所以说最后的答案就是： $x=\sqrt{ \dfrac{f[x1][y1][x2][y2][k-1]}{n} }$ 。二维前缀和+ $dfs$ 搜索,数据量较小所以能过。   
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[101][101],sum[101][101];
double t[11][11][11][11][11];
double arr;
double dfs(int a,int b,int c,int d,int k){
	double &cnt=t[a][b][c][d][k];
	if(cnt!=-1)return cnt;
	if(k==0){
		cnt=sum[b][d]+sum[a-1][c-1]-sum[a-1][d]-sum[b][c-1];
		cnt=(cnt-arr)*(cnt-arr);
		return cnt;
	}
	cnt=INT_MAX;
	for(int i=a+1;i<=b;i++){
		for(int j=0;j<k;j++){
			cnt=min(cnt,dfs(a,i-1,c,d,j)+dfs(i,b,c,d,k-j-1));
		}
	}	
	for(int i=c+1;i<=d;i++){
		for(int j=0;j<k;j++){
			cnt=min(cnt,dfs(a,b,c,i-1,j)+dfs(a,b,i,d,k-j-1));
		}
	}	
	return cnt;
}
int main(){
	int n,m,K;
	cin>>n>>m>>K;
    for(int x1=0;x1<=10;x1++){
    	for(int x2=0;x2<=10;x2++){
        	for(int x3=0;x3<=10;x3++){
            	for(int x4=0;x4<=10;x4++){
                	for(int x5=0;x5<=10;x5++){
                    	t[x1][x2][x3][x4][x5]=-1;
					}
				}
			}
		}
	}              
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>a[i][j];
		}
	}		
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			sum[i][j]=sum[i][j-1]+sum[i-1][j]-sum[i-1][j-1]+a[i][j];
		}
	}		
	arr=(double)sum[n][m]/K;
	dfs(1,n,1,m,K-1);
	printf("%.2lf",sqrt(t[1][n][1][m][K-1]/K));
}
```


---

## 作者：斗神_君莫笑 (赞：4)

一道好的dp题  
记搜的思想基本就是将将来的状态看成黑箱，   
仅仅由它转移来当前的状态  
考虑每一步都可以把一个矩阵拉通分成两半   
那么可以设计出一个简单的状态——  
`f[a][b][c][d][num]表示某个矩阵切num次后的最小方差`  
引入黑箱的思想后，转移变得简单了许多  
只需要枚举在哪条线切，用这两个部分合并就是了  
代码同sol1极度相似
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k;
int a[20][20],sum[20][20];
double jun,f[20][20][20][20][20];
inline double qsum(int a,int b,int c,int d){
	return sum[c][d]-sum[a-1][d]-sum[c][b-1]+sum[a-1][b-1];
}
inline double fang(double k){
	return k*k;
}
double dfs(int a,int b,int c,int d,int num){
	if(f[a][b][c][d][num])return f[a][b][c][d][num];
	if(num==1)return fang(qsum(a,b,c,d)-jun);
	f[a][b][c][d][num]=0x3f3f3f3f;
	for(int i=a;i<c;++i)
		for(int j=1;j<num;++j)
			f[a][b][c][d][num]=min(f[a][b][c][d][num],
			dfs(a,b,i,d,j)+dfs(i+1,b,c,d,num-j));
	for(int i=b;i<d;++i)
		for(int j=1;j<num;++j)
			f[a][b][c][d][num]=min(f[a][b][c][d][num],
			dfs(a,b,c,i,j)+dfs(a,i+1,c,d,num-j));
	return f[a][b][c][d][num];
}
int main(){
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=n;++i)
		for(int j=1;j<=m;++j)
			scanf("%d",&a[i][j]);
	for(int i=1;i<=n;++i)
		for(int j=1;j<=m;++j)
			sum[i][j]+=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+a[i][j];
	jun=sum[n][m]*1.0/k;
	double ans=dfs(1,1,n,m,k);
	printf("%.2lf",sqrt(ans/k));
	return 0;
} 
```


---

## 作者：KingBenQi (赞：4)

```
#include<bits/stdc++.h>
using namespace std;
#define LL long long
#define rg register
#define mem(Arr,x) memset(Arr,x,sizeof(Arr))
const int N = 15;
inline int gi(){
    char ch=getchar();int x=0,q=0;
    while(ch<'0' || ch>'9') ch=='-'?q=1:0,ch=getchar();
    while(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();
    return q?(-x):x;
}
int a[N][N],sum[N][N];
int n,m,K;
double ave,t[N][N][N][N][N];
double dfs(int a,int b,int c,int d,int k){
	double & res = t[a][b][c][d][k];
	if(res!=-1)return res;
	if(k==0){
		res=sum[b][d]+sum[a-1][c-1]-sum[a-1][d]-sum[b][c-1];
		res=(res-ave)*(res-ave);
		return res;
	}
	res=1e9;
	for(int i=a+1;i<=b;i++)
		for(int j=0;j<k;j++)
			res=min(res,dfs(a,i-1,c,d,j)+dfs(i,b,c,d,k-j-1));
	for(int i=c+1;i<=d;i++)
		for(int j=0;j<k;j++)
			res=min(res,dfs(a,b,c,i-1,j)+dfs(a,b,i,d,k-j-1));
	return res;
}
int main(){
    n=gi();m=gi();K=gi();
    for(int q=0;q<=10;q++)
        for(int b=0;b<=10;b++)
            for(int c=0;c<=10;c++)
                for(int d=0;d<=10;d++)
                    for(int l=0;l<=10;l++)
                        t[q][b][c][d][l]=-1;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			a[i][j]=gi();
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			sum[i][j]=sum[i][j-1]+sum[i-1][j]-sum[i-1][j-1]+a[i][j];
	ave=(double)sum[n][m]/K;
	dfs(1,n,1,m,K-1);
	printf("%.2lf\n",sqrt(t[1][n][1][m][K-1]/K));
	return 0;
}

```
这是一道记忆话搜索的动态规划题
要求分割矩阵后的方差最小
又可以归类为矩阵动规的一种
dfs(a,b,c,d,e)
表示横坐标a-b纵坐标c-d还要分割多少次
横切一种纵切一种枚举取min就行了

---

## 作者：Clover_Lin (赞：3)

### 思路
  - 首先，我们要弄明白题中的方差是什么。
  
    公式：$S = \sqrt{\frac{1}{n} \sum_{i=1}^{n} (x_i - \bar{x})^2}$

  - 接下来，我们思考一下题目怎么做。

    数据很小，于是想到了**暴搜**。

    但是时间复杂度有点难以接受啊，优化一下吧。

    有一种很有效的优化，那就是广为人知的**记忆化搜索**。它能使所有重复的操作只做一次，大大降低了时间复杂度。

    下面我们来看看框架。

    用 $f[i][sx][tx][sy][ty]$ 表示分割 $i$ 次，操作范围为左上角在 $(sx,sy)$ 右下角在 $(tx,ty)$ 的矩阵得到 $\sum_{i=1}^{n} (x_i - \bar{x})^2$ 的最小值。很容易想到，dfs 函数的参数就也是这五个值了。

    那么函数出口是什么情况呢？

    $i=0$ 的时候返回矩阵里所有元素之和，我们可以用**二维前缀和**来预处理。

    函数内部呢？

    如果已经存过答案了，那么返回 $f[i][sx][tx][sy][ty]$ 。否则枚举切断的位置及两边分配的分割次数并递归求解。

### 代码
```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cmath>
using namespace std;
const double INF = 1e300; // 初始值，极大值

int n, m, k;
int a[25][25];
double s[25][25], avg; // 二维前缀和，平均值
double f[25][25][25][25][25]; // 记忆化数组

double dfs(int num, int sx, int tx, int sy, int ty) // 递归函数
{
    if (sx > tx || sy > ty || num < 0) // 错误的情况
        return 0;
    if (f[num][sx][tx][sy][ty] != INF) // 如果存过了
        return f[num][sx][tx][sy][ty]; // 直接返回
    if (num == 0) // 出口
    {
        double sum = s[tx][ty] - s[sx - 1][ty] - s[tx][sy - 1] + s[sx - 1][sy - 1];
        sum = (sum - avg) * (sum - avg);
        return f[num][sx][tx][sy][ty] = sum;
    }
    for (int i = sx; i < tx; i++) // 分割位置
        for (int j = 0; j < num; j++) // 次数分配
            f[num][sx][tx][sy][ty] = min(f[num][sx][tx][sy][ty], dfs(j, sx, i, sy, ty) + dfs(num - j - 1, i + 1, tx, sy, ty));
    for (int i = sy; i < ty; i++) // 分割位置
        for (int j = 0; j < num; j++) // 次数分配
            f[num][sx][tx][sy][ty] = min(f[num][sx][tx][sy][ty], dfs(j, sx, tx, sy, i) + dfs(num - j - 1, sx, tx, i + 1, ty));
    return f[num][sx][tx][sy][ty]; 
}

int main()
{
    for (int i = 0; i <= 24; i++)
        for (int sx = 0; sx <= 24; sx++)
            for (int tx = 0; tx <= 24; tx++)
                for (int sy = 0; sy <= 24; sy++)
                    for (int ty = 0; ty <= 24; ty++)
                        f[i][sx][sy][tx][ty] = INF; // 初值
    cin >> n >> m >> k;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
        {
            cin >> a[i][j];
            s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j]; // 预处理
        }
    avg = s[n][m] / k; // 平均值
    double ans = sqrt(dfs(k - 1, 1, n, 1, m) / k);
    printf("%.2lf\n", ans); // 别忘了位数
    return 0;
}
```

---

## 作者：reclusive (赞：3)

[更好的阅读体验](https://www.cnblogs.com/reclusive2007/p/17803992.html)

### 题目描述

将一个矩形分割成 $n$ 个小矩形，每个小矩形的总分为这个矩形内所有数的和。求各矩形总分均方差最小值。

### 具体思路

先来几个定义。

均方差：

$$\sqrt{\frac{1}{n} \times \sum_{i=1}^n (a_i-avg)^2}$$

方差：

$$\frac{1}{n} \times \sum_{i=1}^n (a_i-avg)^2$$

其实均方差就是方差的开方，那我们可以先求出方差，最后在开方。

考虑化简方差的式子（这里就不用大量篇幅来化简）。

化简结果：

$$\frac{1}{n} \times (\sum_{i=1}^n avg^2+ \sum_{i=1}^n a_i^2- 2 avg \sum_{i=1}^n a_i)$$

其中，

$$avg=\frac{1}{q} \times \sum_{i=1}^n \sum_{j=1}^m a_i$$

显然 $avg$ 是可以预处理的。

那我们只需要维护区间和即可，显然是二维前缀和啊！

考虑区间 dp。

设 $f_{x,y,u,v,k}$ 表示以 $(x,y)$ 为左上角，以 $(u,v)$ 为右下角的矩形分成 $k$ 个矩形的 $\sum_{i=1}^k a_i^2- 2\times \sum_{i=1}^k a_i$ 的最小值，其中 $a_i$ 是每个矩形的和。

我们每次需要枚举左上角坐标 $(x,y)$，右下角坐标 $(u,v)$，分成 $k$ 个矩形，分割的点 $i$ 以及 其中一边分成的矩形个数 $j$。

$$f_{x,y,u,v,k}=\min \limits_{i \in [x,u),j \in [1,k)} \{ f_{x,y,u,v,k},f_{x,y,i,v,j}+f_{i+1,y,u,v,k-j} \}$$

$$f_{x,y,u,v,k}=\min \limits_{i \in [y,v),j \in [1,k)} \{ f_{x,y,u,v,k},f_{x,y,u,i,j}+f_{x,i+1,u,v,k-j} \}$$

即横着分割与竖着分割取最小值。

最后加上 $avg$ 的贡献即可。

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=11;
const int inf=0x3f3f3f3f;
int n,m,q;
int a[N][N],sum[N][N];
double avg,f[N][N][N][N][N];
double get(int x,int y,int u,int v){
	int ans=sum[u][v]-sum[x-1][v]-sum[u][y-1]+sum[x-1][y-1];
	return 1.0*ans*ans-2.0*avg*ans;
}
int main(){
	scanf("%d%d%d",&n,&m,&q);
	int ans=0;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			scanf("%d",&a[i][j]);
			sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+a[i][j];
		}
	}
	avg=1.0*sum[n][m]/q;
	for(int k=1;k<=q;k++)
		for(int x=1;x<=n;x++)
			for(int y=1;y<=m;y++)
				for(int u=x;u<=n;u++)
					for(int v=y;v<=m;v++){
						f[x][y][u][v][k]=inf;
						if(k==1)f[x][y][u][v][1]=get(x,y,u,v);
						else{
							for(int i=x;i<u;i++){
								for(int j=1;j<k;j++){
									f[x][y][u][v][k]=min(f[x][y][u][v][k],f[x][y][i][v][j]+f[i+1][y][u][v][k-j]);
								}
							}
							for(int i=y;i<v;i++){
								for(int j=1;j<k;j++){
									f[x][y][u][v][k]=min(f[x][y][u][v][k],f[x][y][u][i][j]+f[x][i+1][u][v][k-j]);
								}
							}
						}
					}
	double res=(avg*avg*q+f[1][1][n][m][q])*1.0/q;
	printf("%.2lf",sqrt(res));
	return 0;
}
```

---

## 作者：Night_Aurora (赞：3)

题目中有一点表述错了

输入格式中应该是第二行到a+1行

不过相信粗心的同学肯定不会因此WA啦

---
题目给定A\*B的矩阵和N

要求的是最小标准差，就相当于求出最小方差来

根据方差的简化公式

$S^2=(\frac 1 N\sum r_i^2)-\bar r^2S$

我们发现因为总和以及分的块数确定

所以最后那一堆$\bar r^2$是确定了的

于是就相当于把矩阵合法分成N块使得$\sum r_i^2$最小

可以列出dp方程

$DPM[fx][fy][tx][ty][n]$

表示以(fx,fy)为左上角，以(tx,ty)为右下角的矩阵分成n块后的关于每块矩阵的平方的和的最小值（默认是左上角原点，xy正方向分别向下向右)

那么可以列出动态规划方程

$DPM[fx][fy][tx][ty][n]=min\left \{ DPM[fx][fy][mx][ty][k]+DPM[mx+1][fy][tx][ty][n-k]\right \}$

$DPM[fx][fy][tx][ty][n]=min\left \{ DPM[fx][fy][tx][my][k]+DPM[fx][my+1][tx][ty][n-k]\right \}$

其中$fx\leq mx<tx,fy\leq my< ty,1\leq k<n$

对于边界$DPM[fx][fy][tx][ty][1]$就等于矩阵中这一部分的和的平方

那么最小方差

$S^2=DPM[1][1][a][b][N]/N-($整个矩阵的和$/N)^2$

直接给求出来的$S^2$开个根输出就行了

[鄙人脏乱差的代码](http://paste.ubuntu.com/25455550/)

最难的地方是7个for套起来，总担心会写错


---

## 作者：GFyyx (赞：2)

## 前置数学知识
1. 我们需要将一个 $a \times b$ 的矩阵分割成 $n$ 个子矩阵，每个子矩阵的“总分”是其内部元素的和。
2. 目标是最小化这些子矩阵总分的方差（$\sigma$），其公式为：
 
   $  \sigma =\sqrt \frac {\sum_{i=1}^n (S_i - \mu)^2}{n}$

   其中 $S_i$ 是第 $i$ 个矩阵的总分，$\mu = \frac{\sum_{i=1}^n S_i}{n}$，即为总分的均值。
   
   不难发现，$n$ 为定值，$\mu$ 也为定值，想要 $\sigma$ 取最小值只需要让 $S_i$ 尽量接近 $\mu$。

## 解题思路
题目给的标签是记忆化搜索，而楼上奆佬们的讲解中使用到了 DP 数组。

题目的数据范围 $a,b,n(1<a,b,n≤10)$ 未免让人第一时间想到爆搜，哪怕是 $O(2^{a + b})$ 也能接受。然而对于每一刀而言，其选择有超过 $n$ 种地方下手，也就是说，无任何优化的搜索时间复杂度会来到惊人的 $O(n^n)$，显然是搜索无法做到的。

### 对于 DP 的看法
对于狭义的动态规划需要用递推实现，但本题无论是先从子矩阵的 $size$ 递推还是从矩阵位置递推都难以定义状态和推出状态转移方程。

在接下来的文章要介绍的记忆化数组本质上也是一种 DP 的递归实现，按照个人的脑回路，我愿称之为记忆化分治，大家可以按照自己的理解进行思考。

### 记忆化分治
我们设置状态 $vis[x_1][y_1][x_2][y_2][k]$ 表示于坐标在$(x_1,y_1)$ 至 $(x_2,y_2)$ 的矩阵切分 $k$ 刀所产生的最少标准差。是不是很像动态规划？

在第 $i$ 行下方的空隙切割为两块，即可得到两个矩阵 $(x_1,y_1)$ 至 $(i,y_2)$，$(i+1,y_1)$至 $(x_2,y_2)$。我们再枚举再上方的矩阵切 $j,j \in [1,k)$ 刀，易得下方的矩阵切 $k-j$ 刀，然后分而治之，竖着切同理。

### 归并
```cpp
for(register int i=x1; i<x2; i++)//切行 
		for(register int j=1; j<k; j++)//上切j
			vis[x1][y1][x2][y2][k]=min(vis[x1][y1][x2][y2][k],
          dfs(x1,y1,i,y2,j)+dfs(i+1,y1,x2,y2,k-j));
	for(register int i=y1; i<y2; i++)//切列 
		for(register int j=1; j<k; j++)//左切j 
			vis[x1][y1][x2][y2][k]=min(vis[x1][y1][x2][y2][k],
          dfs(x1,y1,x2,i,j)+dfs(x1,i+1,x2,y2,k-j));
```

## 优化


### 预处理：  
使用二维前缀和数组 $sum$ 快速计算任意子矩阵的总分值。
   
   $sum[x][y] = \sum_{i=1}^x \sum_{j=1}^y matrix[i][j]$

   子矩阵 $(x_1, y_1) \to (x_2, y_2)$ 的总分为：
   
   $totalscore = sum[x_2][y_2] - sum[x_1-1][y_2] - sum[x_2][y_1-1] + sum[x_1-1][y_1-1]$

## 参考代码
```cpp
#include <stdio.h>
#include <math.h>
#define y1 y114514
//cmath 逆天重名 
#define dp vis[x1][y1][x2][y2][k]
using namespace std;
const double INF=1e18;
int a,b,n,mp[114][114];//前缀和 
double vis[11][11][11][11][11];//(x1,y1)-(x2,y2)的矩阵切分k刀,记搜 
double avg;//平均数为定值 
inline double dfs(int x1,int y1,int x2,int y2,int k){
	if(dp!=INF) return dp;//记忆化 
	if(k<=1){
		dp=0;
		double ts=mp[x2][y2]+mp[x1-1][y1-1]-mp[x1-1][y2]-mp[x2][y1-1];
		return dp=(ts-avg)*(ts-avg);
	}
	for(register int i=x1; i<x2; i++)//切行 
		for(register int j=1; j<k; j++)//上切j
			dp=min(dp,dfs(x1,y1,i,y2,j)+dfs(i+1,y1,x2,y2,k-j));
	for(register int i=y1; i<y2; i++)//切列 
		for(register int j=1; j<k; j++)//左切j 
			dp=min(dp,dfs(x1,y1,x2,i,j)+dfs(x1,i+1,x2,y2,k-j));
	return dp;
}
int main(){
	scanf("%d%d%d",&a,&b,&n);
	for(int i=1; i<=a; i++)
		for(int j=1; j<=b; j++){
			scanf("%d",&mp[i][j]);
			avg+=mp[i][j];
			mp[i][j]+=+mp[i-1][j]+mp[i][j-1]-mp[i-1][j-1];
			//cout << mp[i][j] << ' ';
		}
	for(int x1=0; x1<=10; x1++) for(int y1=0; y1<=10; y1++)
        	for(int x2=0; x2<=10; x2++) for(int y2=0; y2<=10; y2++)
               	for(int k=0; k<=10; k++) dp=INF;
	avg/=n;//输入&求平均
	dfs(1,1,a,b,n);
	printf("%.2lf",sqrt(vis[1][1][a][b][n]/n));
	return 0;
}
```
希望各位有所收获，代码不要直接抄。

---

## 作者：xzy_caiji (赞：0)

首先，我们要了解均方差的概念：

$$\sigma=\sqrt{\smash[b]{\displaystyle\sum_{i=1}^n}\frac{{(x_i-\bar{x})^2}}{n}}$$

第一眼：WOW，这么小的 $n$，上暴力分治！

分治式（我们老师教给我们的分治套路）：

原问题：将矩阵 $(a,b,c,d)$ 分割成 $x$ 个可以得到的最小值。

子问题 $1$：将矩阵 $(a,b,c,i)$ 分割成 $j$ 个可以得到的最小值。

子问题 $2$：将矩阵 $(a,i+1,c,d)$ 分割成 $x-j$ 个可以得到的最小值。

子问题 $3$：将矩阵 $(a,b,i,d)$ 分割成 $j$ 个可以得到的最小值。

子问题 $4$：将矩阵 $(i+1,b,c,d)$ 分割成 $x-j$ 个可以得到的最小值。

基本情况：若 $x=1$，返回 $[ ({\displaystyle\sum_{i=a}^c}{\displaystyle\sum_{j=b}^d}m_{i,j})-avg ]^2$。

合并：$ \min \left\{\text{sub1+sub2,sub3+sub4}\right\}$。

上面的“最小值”指 ${(x_i-\bar{x})^2}$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[15][15],sum[15][15],n,m,k;double avg;
double solve(int a,int b,int c,int d,int x){
    if(x==1)return (sum[c][d]-sum[a-1][d]-sum[c][b-1]+sum[a-1][b-1]-avg)*(sum[c][d]-sum[a-1][d]-sum[c][b-1]+sum[a-1][b-1]-avg);
    double res=INT_MAX;
    for(int i=b;i<d;i++)
        for(int j=1;j<x;j++)
            res=min(res,solve(a,b,c,i,j)+solve(a,i+1,c,d,x-j));
    for(int i=a;i<c;i++)
        for(int j=1;j<x;j++)
            res=min(res,solve(a,b,i,d,j)+solve(i+1,b,c,d,x-j));
    return res;
}
int main(){
    cin>>n>>m>>k;
    for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)cin>>a[i][j],sum[i][j]=a[i][j]+sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1];
    avg=double(sum[n][m])/k;
    printf("%.2lf",sqrt(solve(1,1,n,m,k)/k));//由于n不变，我们实际要求的就是(xi-avg)^2最小，根据公式，输出就是sqrt(solve(1,1,n,m,k)/k)
```
交上去：

![](https://cdn.luogu.com.cn/upload/image_hosting/kenfd1ks.png)

emm……（不过这也是意料之中，因为这时间复杂度大约 $O(n^n)$，不炸才怪）

好吧，这应该是记忆化搜索了。

试着打印一下样例的重叠子问题：

```
solve(1,3,5,4,2)=20.500000
solve(1,2,5,2,2)=174.500000
solve(1,4,5,4,2)=146.500000
solve(1,2,5,3,2)=22.500000
solve(2,2,5,4,2)=12.500000
solve(1,2,1,4,2)=200.500000
solve(3,2,5,4,2)=128.500000
solve(1,2,2,4,2)=24.500000
solve(4,2,5,4,2)=312.500000
solve(1,2,3,4,2)=26.500000
solve(5,2,5,4,2)=450.500000
solve(1,2,4,4,2)=74.500000
solve(1,2,5,4,3)=22.750000
solve(1,1,5,1,2)=90.500000
solve(1,2,5,4,2)=90.500000
solve(2,1,5,1,2)=112.500000
solve(1,1,1,1,2)=2147483647.000000
solve(3,1,5,1,2)=152.500000
solve(1,1,2,1,2)=342.500000
solve(4,1,5,1,2)=366.500000
solve(1,1,3,1,2)=132.500000
solve(5,1,5,1,2)=2147483647.000000
solve(1,1,4,1,2)=110.500000
solve(1,1,5,1,3)=242.750000
solve(1,4,5,4,2)=146.500000
solve(1,3,5,3,2)=228.500000
solve(2,3,5,4,2)=114.500000
solve(1,3,1,4,2)=266.500000
solve(3,3,5,4,2)=222.500000
solve(1,3,2,4,2)=146.500000
solve(4,3,5,4,2)=338.500000
solve(1,3,3,4,2)=72.500000
solve(5,3,5,4,2)=480.500000
solve(1,3,4,4,2)=32.500000
solve(1,3,5,4,3)=156.750000
solve(1,1,5,2,2)=20.500000
solve(1,3,5,4,2)=20.500000
solve(1,2,5,2,2)=174.500000
solve(1,1,5,1,2)=90.500000
solve(2,1,5,2,2)=40.500000
solve(1,1,1,2,2)=392.500000
solve(3,1,5,2,2)=96.500000
solve(1,1,2,2,2)=132.500000
solve(4,1,5,2,2)=342.500000
solve(1,1,3,2,2)=6.500000
solve(5,1,5,2,2)=396.500000
solve(1,1,4,2,2)=0.500000
solve(1,1,5,2,3)=92.750000
solve(2,4,5,4,2)=266.500000
solve(1,4,1,4,2)=2147483647.000000
solve(3,4,5,4,2)=288.500000
solve(1,4,2,4,2)=350.500000
solve(4,4,5,4,2)=422.500000
solve(1,4,3,4,2)=220.500000
solve(5,4,5,4,2)=2147483647.000000
solve(1,4,4,4,2)=162.500000
solve(1,4,5,4,3)=376.750000
solve(1,1,5,3,2)=146.500000
solve(1,4,5,4,2)=146.500000
solve(1,2,5,3,2)=22.500000
solve(1,1,5,1,2)=90.500000
solve(1,3,5,3,2)=228.500000
solve(1,1,5,2,2)=20.500000
solve(2,1,5,3,2)=32.500000
solve(1,1,1,3,2)=288.500000
solve(3,1,5,3,2)=48.500000
solve(1,1,2,3,2)=56.500000
solve(4,1,5,3,2)=266.500000
solve(1,1,3,3,2)=42.500000
solve(5,1,5,3,2)=366.500000
solve(1,1,4,3,2)=78.500000
solve(1,1,5,3,3)=40.750000
solve(2,2,5,4,2)=12.500000
solve(2,1,5,1,2)=112.500000
solve(2,3,5,4,2)=114.500000
solve(2,1,5,2,2)=40.500000
solve(2,4,5,4,2)=266.500000
solve(2,1,5,3,2)=32.500000
solve(3,1,5,4,2)=0.500000
solve(2,1,2,4,2)=130.500000
solve(4,1,5,4,2)=180.500000
solve(2,1,3,4,2)=8.500000
solve(5,1,5,4,2)=338.500000
solve(2,1,4,4,2)=92.500000
solve(2,1,5,4,3)=2.750000
solve(1,1,1,4,2)=166.500000
solve(2,1,5,4,2)=202.500000
solve(1,2,1,4,2)=200.500000
solve(1,1,1,1,2)=2147483647.000000
solve(1,3,1,4,2)=266.500000
solve(1,1,1,2,2)=392.500000
solve(1,4,1,4,2)=2147483647.000000
solve(1,1,1,3,2)=288.500000
solve(1,1,1,4,3)=398.750000
solve(3,2,5,4,2)=128.500000
solve(3,1,5,1,2)=152.500000
solve(3,3,5,4,2)=222.500000
solve(3,1,5,2,2)=96.500000
solve(3,4,5,4,2)=288.500000
solve(3,1,5,3,2)=48.500000
solve(4,1,5,4,2)=180.500000
solve(3,1,3,4,2)=98.500000
solve(5,1,5,4,2)=338.500000
solve(3,1,4,4,2)=26.500000
solve(3,1,5,4,3)=104.750000
solve(1,1,2,4,2)=0.500000
solve(3,1,5,4,2)=0.500000
solve(1,2,2,4,2)=24.500000
solve(1,1,2,1,2)=342.500000
solve(1,3,2,4,2)=146.500000
solve(1,1,2,2,2)=132.500000
solve(1,4,2,4,2)=350.500000
solve(1,1,2,3,2)=56.500000
solve(2,1,2,4,2)=130.500000
solve(1,1,1,4,2)=166.500000
solve(1,1,2,4,3)=114.750000
solve(4,2,5,4,2)=312.500000
solve(4,1,5,1,2)=366.500000
solve(4,3,5,4,2)=338.500000
solve(4,1,5,2,2)=342.500000
solve(4,4,5,4,2)=422.500000
solve(4,1,5,3,2)=266.500000
solve(5,1,5,4,2)=338.500000
solve(4,1,4,4,2)=338.500000
solve(4,1,5,4,3)=422.750000
solve(1,1,3,4,2)=230.500000
solve(4,1,5,4,2)=180.500000
solve(1,2,3,4,2)=26.500000
solve(1,1,3,1,2)=132.500000
solve(1,3,3,4,2)=72.500000
solve(1,1,3,2,2)=6.500000
solve(1,4,3,4,2)=220.500000
solve(1,1,3,3,2)=42.500000
solve(2,1,3,4,2)=8.500000
solve(1,1,1,4,2)=166.500000
solve(3,1,3,4,2)=98.500000
solve(1,1,2,4,2)=0.500000
solve(1,1,3,4,3)=6.750000
solve(5,2,5,4,2)=450.500000
solve(5,1,5,1,2)=2147483647.000000
solve(5,3,5,4,2)=480.500000
solve(5,1,5,2,2)=396.500000
solve(5,4,5,4,2)=2147483647.000000
solve(5,1,5,3,2)=366.500000
solve(5,1,5,4,3)=606.750000
solve(1,1,4,4,2)=362.500000
solve(5,1,5,4,2)=338.500000
solve(1,2,4,4,2)=74.500000
solve(1,1,4,1,2)=110.500000
solve(1,3,4,4,2)=32.500000
solve(1,1,4,2,2)=0.500000
solve(1,4,4,4,2)=162.500000
solve(1,1,4,3,2)=78.500000
solve(2,1,4,4,2)=92.500000
solve(1,1,1,4,2)=166.500000
solve(3,1,4,4,2)=26.500000
solve(1,1,2,4,2)=0.500000
solve(4,1,4,4,2)=338.500000
solve(1,1,3,4,2)=230.500000
solve(1,1,4,4,3)=80.750000
solve(1,1,5,4,4)=1.000000
```
的确有重叠子问题！

最优子结构？原问题是最优的，子问题也肯定是最优的。满足！
```
#include<bits/stdc++.h>
using namespace std;
int a[15][15],sum[15][15],n,m,k;double avg,dp[15][15][15][15][15];
double solve(int a,int b,int c,int d,int x){
    if(x==1)return (sum[c][d]-sum[a-1][d]-sum[c][b-1]+sum[a-1][b-1]-avg)*(sum[c][d]-sum[a-1][d]-sum[c][b-1]+sum[a-1][b-1]-avg);
    if(dp[a][b][c][d][x])return dp[a][b][c][d][x];
    double res=INT_MAX;
    for(int i=b;i<d;i++)
        for(int j=1;j<x;j++)
            res=min(res,solve(a,b,c,i,j)+solve(a,i+1,c,d,x-j));
    for(int i=a;i<c;i++)
        for(int j=1;j<x;j++)
            res=min(res,solve(a,b,i,d,j)+solve(i+1,b,c,d,x-j));
    return dp[a][b][c][d][x]=res;
}
int main(){
    cin>>n>>m>>k;
    for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)cin>>a[i][j],sum[i][j]=a[i][j]+sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1];
    avg=double(sum[n][m])/k;
    printf("%.2lf",sqrt(solve(1,1,n,m,k)/k));//由于n不变，我们实际要求的就是(xi-avg)^2最小
}
```
![](https://cdn.luogu.com.cn/upload/image_hosting/tmb1pehh.png)

nice!（时间复杂度约 $O(n^5)$）

---

## 作者：小塘空明 (赞：0)

首先可以观察到：**这k个矩阵各自和的均值不变**。

考虑搜索，保存状态为f[i][j][z][w][k],表示i到j行，z到w列切了k刀能得到的最小答案。

每次转移**分横边纵边**，**枚举行/列和分开来的两个块内各自切的个数**。

状态数为1e5,时间复杂度为(1e7),符合要求。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<string>
#include<cstring>
#include<cmath>
using namespace std;
const int size=11;
int n,m,K;
double ave,s[size][size],f[size][size][size][size][size]; 
double dfs(int a,int b,int c,int d,int k){
	double &res=f[a][b][c][d][k];
	if(res!=-1) return res;
	if(k==0){
		double sum=s[b][d]+s[a-1][c-1]-s[a-1][d]-s[b][c-1];
		res=(sum-ave)*(sum-ave);return res;
	}
	res=1e9;
	for(int i=a;i<b;i++){
		for(int j=0;j<k;j++){
			res=min(res,dfs(a,i,c,d,j)+dfs(i+1,b,c,d,k-j-1));
		}
	}
	for(int i=c;i<d;i++){
		for(int j=0;j<k;j++){
			res=min(res,dfs(a,b,c,i,j)+dfs(a,b,i+1,d,k-j-1));
		}
	}
	return res;
}
int main(){
	scanf("%d%d%d",&n,&m,&K);
	for(int i=0;i<=n;i++){
		for(int j=0;j<=n;j++){
			for(int z=0;z<=m;z++){
				for(int w=0;w<=m;w++){
					for(int k=0;k<=K;k++){
						f[i][j][z][w][k]=-1;
					}
				}
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			scanf("%lf",&s[i][j]);
			s[i][j]=s[i][j]+s[i-1][j]+s[i][j-1]-s[i-1][j-1];
		}
	}
	ave=(double)s[n][m]/(K);
	dfs(1,n,1,m,K-1);
	printf("%.2lf",sqrt(f[1][n][1][m][K-1]/K));
	return 0;
}
```

---


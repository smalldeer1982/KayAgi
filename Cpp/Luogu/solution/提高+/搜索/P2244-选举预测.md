# 选举预测

## 题目背景

科学院的领袖Dunkelheit 的任期，随着局势的平复很快就要结束了。于是，这次具有非凡意义的科学院新领袖的选举很快就要开始了。


## 题目描述

选举的第一步是辩论赛。它的规则是这样的：如果当前剩下的候选人多于 $2$ 人，那么就从中任选 $2$ 人进行辩论。输者退出比赛，胜利者继续留在比赛中，如此直到只剩下一个候选人，他就取得了辩论赛的胜利。  

辩论赛的胜者在后面的选举中将会更占优势，所以说人们都很关注这次比赛的结果，历史学家 Geheimnis 也不例外。 

他收集了所有 $n$ 个候选人的资料，发现如果两个候选人以前曾经比赛过，那么这两个人再次比赛的时候比赛结果是很难改变的（可以认为是不可能）。按照 Geheimnis 掌握的情报，你需要帮助他判断那些候选人有可能取得胜利。


## 说明/提示

【数据范围】   
对于 $50\%$ 的数据，$n \le 200$。   
对于 $100\%$ 的数据，$n \le 10^6$，胜负关系不会超过 $10^6$ 对。


## 样例 #1

### 输入

```
4
2 2 3
0
1 2
1 2
```

### 输出

```
3 1 3 4```

# 题解

## 作者：I_am_Accepted (赞：6)

~~为啥机房里 dalao 们都不屑一顾。~~

这里有最严谨的证明（自己推的，有疏漏请指出）。

我们把人看作点，$x$ 必然胜 $y$ 看作 $x\to y$ 的有向边，我们称点是「好的」当且仅当这个点可能取得最终胜利，设 $N(x)$ 表示 $x$ 点走一步能到达的点集，$V$ 为点的全集，称一个点 $x$ 的「反集」为 $V-x-N(x)$。

* * *

**首先我们证明出度最大的点（可能不止一个）是好的。**

反证法。假设出度最大的点之一 $x$ 不好。我们这样构造比赛顺序：

1. 让 $x$ 的反集之间对战（随便打），决出最后的赢家设为 $y$。

2. 将 $y$ 依次与 $N(x)$ 中的点对战（若 $y$ 与 $N(x)$ 中某点间没边，让 $N(x)$ 那头赢），设赢家为 $z$。

若 $z\ne y$，则 $z\in N(x)$，最后让 $x$ 打败 $z$ 即可，最后赢家 $x$ 是好的，矛盾。

若 $z=y$，则 $N(x)\subseteq N(y)$，由于 $x$ 出度的最大性，得到 $|N(x)|\ge |N(y)|$，进一步 $N(x)=N(y)$，得到 $x,y$ 之间没有边，最后让 $x$ 打败 $y(=z)$ 即可，矛盾。

综上，原命题得证。

* * *

**其次我们证明若一个点是好的，则其反集也都是好的。**

设 $x$ 的反集中有 $y$，我们先让 $x$ 成为 $y$ 除外的最后赢家，然后 $y$ 再打败 $x$ 即可。

* * *

**实现：**

我们找到出度最大的点，然后向反集 BFS 即可，过程中用并查集优化可至 $O(n+m)$（$m$ 为边数）。

* * *

**最后我们证明我们找到好的点以外都是不好的。**

设我们通过刚刚方法找到的好的集合为 $S$。当一个点 $x\notin S$ 第一次与 $S$ 中的人对战的时候，由 $S$ 的定义，$x$ 必输，推出 $x$ 不是好的。

* * *

完结撒花上代码。

```cpp
//We'll be counting stars.
#include<bits/stdc++.h>
using namespace std;
#define pb emplace_back
#define For(i,j,k) for(int i=(j),i##_=(k);i<=i##_;i++)
#define N 1000010
vector<int> e[N],id;
int f[N],n;
bool b[N];
queue<int> q;
inline int gf(int x){ return x==f[x]?x:f[x]=gf(f[x]); }
inline void del(int x){ f[x]=gf(x+1),q.push(x); }
int main(){
	scanf("%d",&n);
	int k,x,mx=-1,cnt=n;
	For(i,1,n){
		scanf("%d",&k);
		if(k>mx) id.clear(),mx=k;
		if(k==mx) id.pb(i);
		while(k--) scanf("%d",&x),e[i].pb(x);
	} 
	For(i,1,n+1) f[i]=i;
	for(int i:id) del(i);
	while(!q.empty()){
		x=q.front();
		q.pop();
		for(int i:e[x]) b[i]=true;
		for(int i=gf(1);i<=n;i=gf(i+1)) if(!b[i]) del(i);
		for(int i:e[x]) b[i]=false;
	}
	for(int i=gf(1);i<=n;i=gf(i+1)) b[i]=1,cnt--;
	printf("%d",cnt); For(i,1,n) if(!b[i]) printf(" %d",i);
return 0;}
```

---

## 作者：986yg (赞：6)

入度最大的一定可能胜利，然后用这些可能胜利的点去试那些不确定的点，因为可能胜利的点无法判断是否打赢的点一定是可能胜利的。

这样用队列维护可能胜利的点，用链表维护不确定的点，根据边的大小决定枚举方向，最终复杂度O(n)

``





```cpp
#include<cstdio>
using namespace std;
#define max(a,b) ((a)>(b)?(a):(b))
int read(){
    int rt=0,fl=1;char ch=getchar();
    while(ch<'0' || ch>'9'){if(ch=='-')fl=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){rt=rt*10+ch-'0';ch=getchar();}
    return rt*fl;
}
const int maxn = 2000000;
int h[maxn],nx[maxn],to[maxn],cnt;
int chudu[maxn];
int pr[maxn],af[maxn];
bool isWinner[maxn];
int cnt_winner;
int n;
int q[maxn],l,r;
void add_edge(int u,int v){
    cnt++;
    to[cnt]=v;
    nx[cnt]=h[u];
    h[u]=cnt;
}
void del(int nd){
    af[pr[nd]]=af[nd];
    pr[af[nd]]=pr[nd];
}
void bfs(){
    while(l<r){
        int t=q[l++];
        t=h[t];
        int x=pr[n+1];
        while(x!=0){
            while(x<to[t] && t!=0){
                t=nx[t];
            }
            if(x!=to[t]){
                isWinner[x]=1;
                del(x);
                cnt_winner++;
                q[r++]=x;
            }
            x=pr[x];
        }
    }
}
int main(){
    int max_chudu=0;
    n=read();
    for(int i=1;i<=n+1;i++){
        pr[i]=i-1;af[i]=i+1;
    }
    for(int i=1;i<=n;i++){
        chudu[i]=read();
        max_chudu=max(max_chudu,chudu[i]);
        for(int j=chudu[i];j>0;j--){
            int a=read();
            add_edge(i,a);
        }
    }
    for(int i=1;i<=n;i++){
        if(chudu[i]==max_chudu){
            q[r++]=i,isWinner[i]=1;del(i);cnt_winner++;
        }
    }
    bfs();
    printf("%d",cnt_winner);
    for(int i=1;i<=n;i++)if(isWinner[i])printf(" %d",i);
    return 0;
}
``
```

---

## 作者：Moeebius (赞：3)

## Perface
~~模拟赛上遇到，写了暴力，还挂了。~~
## Analysis
对于这种数据范围很大，~~还很不可做~~的题目，首先考虑是否存在某种结论。

**结论1: 保证可以打败最多人 的选手一定是答案之一。**

证明：
设这个选手为 $A$。

- 如果没有人保证可以打败 $A$：

那么 $A$ 必然为答案。

- 如果有人（选手 $B$ ）保证打败 $A$：

根据定义，我们知道 $B$ 保证打败的选手数 **一定小于 $A$ 保证打败的选手数**。

所以 $B$ 一定可能被一个选手 $C$ 打败，而 $C$ 可能/一定 被 $A$ 打败。

证毕。

**结论2: 可能打败选手 $A$ 的选手 一定是答案之一。**

证明：
设这个选手为 $D$。

我们将 $D$ 暂时移出选手中。

根据 _结论1_ ，一定存在一种可能，就是 $A$ 打败了除了 $D$ 以外的所有选手。

然后 $A$ 输给了 $D$。

~~So terrible.~~

证毕。

然后利用结论1枚举出每一个一开始就知道是答案的选手，放入队列中；利用结论2跑 BFS，用一个链表维护那些不确定的点。

## Code
偷懒用了 STL。

```cpp
#include<bits/stdc++.h>
using namespace std;

#define il inline
#define mkp make_pair
#define pii pair<int,int>
#define lll __int_128
#define ll long long
#define For(i,j,k) for(int i=(j); i<=(k); ++i)
#define ForDown(i,j,k) for(int i=(j); i>=(k); --i)
#define pb push_back
#define init(filename) freopen(filename ".in" ,"r",stdin);freopen(filename ".out" ,"w",stdout)
template<typename T> 
il void read(T &x){ x=0;int f=1;char c=getchar();while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}while(isdigit(c)){x=x*10+c-'0';c=getchar();}x*=f;}
template<typename T, typename ... Args>
il void read(T &x, Args &... y){ read(x);read(y...); }

int n;
vector<int> G[100001];
vector<int> first;
int maxv=0;
vector<int> ans;
bool used[100001];
unordered_set<int> todo;
unordered_set<int> dict[100001];

int main()
{
    read(n);
    todo.clear();
    For(i,1,n) todo.insert(i);
    For(i,1,n)
    {
        //todo.insert(i);
        int k;read(k);
        if(k>maxv)
        {
            first.clear();
            maxv=k;first.pb(i);
        } else if(k==maxv)
        {
            first.pb(i);
        }
        For(j,1,k)
        {
            int p;read(p);G[p].pb(i);dict[i].insert(p);
        }
    }
    queue<int> q;
    for(int x:first)
    {
        //cout<<"! "<<todo.count(x)<<endl;
        q.push(x);todo.erase(x);
        used[x]=1;
        //cout<<"! "<<todo.size()<<endl;
    }
    while(!q.empty())
    {
        int u=q.front();q.pop();ans.pb(u);
        auto it=todo.begin();
        //cout<<todo.size()<<endl<<endl;
        const unordered_set<int> tmp = todo;
        for(int x:tmp)
        {
            //int x=*it;
            //cout<<x<<endl;
            if(used[x]) continue;
            if(dict[u].count(x)) continue;
            used[x]=1;
            todo.erase(x);
            q.push(x);
            ++it;
        }
    }
    sort(ans.begin(),ans.end());
    printf("%d ",ans.size());
    for(int x:ans)
    {
        printf("%d ",x);
    }
    return 0;
}

```

---

## 作者：BFSBFSBFSBFS (赞：1)

编号为 $x$ 的候选人怎样才能获得胜利呢.?

最简单的方法, 先让其他人比赛, 只留下1位编号 $y$ 的候选人. 而 $y$ 不能保证打败 $x$, 那么 $x$ 就可以获胜了.

如果留下的 $y$ 无论是谁都是能打败 $x$ 的,那么 $x$ 必败.

也就是说, 对于必定能打败 $x$ 的候选人集合 $S$, 和所有 $x$ 可能打败的候选人集合 $T$, 若对任意的 $i∈S,j∈T$ 都有 $i$ 能打过 $j$ , 在此情况下 $x$ 是1个必败的状态. 同时也是 $T$ 中所有人的必败状态.

否则只要找到集合 $S$ 中的候选人 $S_x$ , 集合 $T$ 中能打过 $S_x$ 的候选人 $T_y$ , 让 $S_x$ 先成为集合 $S$ 的赢家, 让 $T_y$ 打败 $S_x$ , 最后让 $x$ 打败集合 $T$ 即可让 $x$ 获胜.

问题来了, $S_x$ 不1定能成为集合 $S$ 的赢家, 也就是 $S_x$ 打不过集合 $S$ 中的其他人. 此时集合 $T$ 若同样打不过这些人, 则 $S_x$ 与 $x$ , 集合 $T$ 中的人均必败, 也是1个必败状态. 将 $S_x$ 从集合 $S$ 中删除, 新的集合 $S'$ 也能打败其他的所有人.

可以发现, 无论是怎样的必败状态, 都有1个胜者候选人集合 $S$, 和1个败者候选人集合 $T$, 满足对任意的 $i∈S,j∈T$ 都有 $i$ 能打过 $j$ . 所以每个可以胜利的候选人能打败的人的集合里必定包括必败的候选人.

由于能打败最多的人1定是可以胜利的(其他题解有详细的解释), 只要将候选人依据打败的人数降序排序, 然后不断将候选人加入可以胜利的集合 $S$ 中, 并统计集合 $S$ 中能打败不在集合 $S$ 的人数的总数 $sum$. 当满足  $|S| \times (n-|S|) = sum$ 时, 可以获胜的候选人与必败的候选人就全部确定下来了.

时间复杂度 $O(n \times log(n)+m)$, 比BFS慢但更简单.

代码.

```cpp
program P2244;
 uses Garrayutils;
 const
  sqrnd=1008208820;
  nmax=1000000;
 type
  wb=record
   n:^wb;
   t:longint;
  end;
  pwb=^wb;
  we=record
   i,d:longint;
  end;
  wa=array of we;
  cmp=object
   public
    function c(x,y:we):boolean;inline;static;
   end;
  sort=specialize Torderingarrayutils<wa,we,cmp>;
 var
  a:wa;
  b:array[0..2*nmax+1] of wb;
  h,d:array[0..nmax+1] of longint;
  i,j,k,p,n,x:longint;
  put,ti:longint;
  tj:pwb;
 procedure hahainc(x,y:longint);
  begin
   inc(put);
   b[put].n:=@b[h[x]];
   b[put].t:=y;
   h[x]:=put;
  end;
 function cmp.c(x,y:we):boolean;inline;static;
  begin
   exit(x.d>y.d);
  end;
 begin
  readln(n);
  setlength(a,n);
  filldword(h,sizeof(h)>>2,0);
  for i:=0 to n-1 do
   begin
    read(a[i].d);
    a[i].i:=i+1;
    for j:=1 to a[i].d do
     begin
      read(k);
      hahainc(i+1,k);
      hahainc(k,i+1);  //加了双向边,用于后面判断用.
     end;
    readln;
   end;
  sort.sort(a,n);      //按照打败的人数排序.
  filldword(d,sizeof(d)>>2,0);
  x:=0;
  for i:=0 to n-1 do
   begin
    d[a[i].i]:=1;
    inc(x,a[i].d);      //x即为统计sum, 先将人数累加.
    tj:=@b[h[a[i].i]];
    while tj<>@b[0] do  //遍历所有胜负关系.
     begin
      ti:=tj^.t;
      if d[ti]=1 then dec(x);  //如果能打败的是集合S中的人, 或者被集合S中的人打败(双向边), 则将人数减少.
      tj:=tj^.n;
     end;
    if x=(i+1)*(n-i-1) then break;  //满足条件即可退出.
   end;
  p:=0;
  for i:=1 to n do
   if d[i]=1 then
    begin
     inc(p);
     d[p]:=i;
    end;
  write(p,' ');
  for i:=1 to p-1 do
   write(d[i],' ');
  writeln(d[p]);
 end.
```


---

## 作者：CmsMartin (赞：1)

[更好的阅读体验](http://www.cmsblog.top/archives/xuan-ju-yu-ce)

## 题目描述

[题目传送门](https://www.luogu.com.cn/problem/P2244)

## 思路

看到 $n \le 10^6$，显然会有一些结论。

### 结论1

能打败人最多的人可能胜利。

**证明**：假设打败人最多的人（称其为 Cms）不可能胜利，那必定有人（下文称其为石老板）可以打败他和他所有能打败的人，否则可能出现 Cms 打败的人干掉了石老板，然后 Cms 干掉了他，取得胜利。为了避免这种使 Cms 胜利的情况，要使石老板打败 Cms 及 Cms 可以打败的人，这样石老板可以打败的人就会比 Cms 多，也就是 Cms 不是打败人最多的人，出现矛盾，原命题成立。

### 结论2

可能胜利的人打不败的人也可能胜利。

**证明**：假设有一个可能胜利的人叫做 Cms，而 Cms 不一定可以打败石老板。这样 Cms 可以将出了石老板外的所有人干掉（因为 Cms 可能胜利），然后石老板再干掉 Cms，石老板就可以取得胜利。

知道了这两点，我们可以将可能胜利的人加入搜索队列，然后用枚举队首可能打不败的人，执行搜索，即可得到答案。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 1e6 + 10;

int Head[MAXN] , Ver[MAXN * 4] , Next[MAXN * 4];
int ToT; 

void Add(int u , int v) {
	Ver[++ToT] = v;
	Next[ToT] = Head[u];
	Head[u] = ToT;
}

int N;
queue<int> q;

vector<int> G[MAXN];
int MayBeWinner[MAXN] , Ans;

int Nxt[MAXN] , Pre[MAXN];

void Delete(int p) {
	Nxt[Pre[p]] = Nxt[p];
	Pre[Nxt[p]] = Pre[p];
}

void BFS() {
	while(q.size()) {
		int x = q.front();
		q.pop();
		int p = Pre[N + 1];
		int i = Head[x];
		while(p != 0) {
			while(p < Ver[i] && i != 0) {
				i = Next[i];
			}
			if(p != Ver[i]) {
				MayBeWinner[p] = true;
				Delete(p);
				Ans++;
				q.push(p);
			}
			p = Pre[p];
		}
	}
}

int CntCanWin[MAXN];
int MaxCanWin;
int Num[MAXN];

int main() {
//	freopen("ele.in" , "r" , stdin);
//	freopen("ele.out" , "w" , stdout);
	
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);	
	
	cin >> N;
	for(int i = 1; i <= N; i++) {
		cin >> CntCanWin[i];
		MaxCanWin = max(MaxCanWin , CntCanWin[i]);
		for(int j = 1; j <= CntCanWin[i]; j++) {
			cin >> Num[j];
		}
		sort(Num + 1 , Num + 1 + CntCanWin[i]);
		for(int j = 1; j <= CntCanWin[i]; j++) {
			Add(i , Num[j]);
		}
	}
	
	for(int i = 1; i <= N + 1; i++) {
		Pre[i] = i - 1;
		Nxt[i] = i + 1;
	}
	
	for(int i = 1; i <= N; i++) {
		if(CntCanWin[i] == MaxCanWin) {
			MayBeWinner[i] = true;
			q.push(i);
			Delete(i);
			Ans++;
		}
	}
	
	BFS();
	
	cout << Ans << " ";
	for(int i = 1; i <= N; i++) {
		if(MayBeWinner[i]) {
			cout << i << " ";
		}
	}
	cout << endl;
	return 0;
} 
```

---

## 作者：Tzs_yousa (赞：0)

刚看到这道题想的是怎么去暴力搜索，但是仔细思考一下搜索的状态不知道定什么，剪枝也无从下手，那肯定是有一些结论可以让我们建立这个搜索体系。

所以我们就猜测，能战胜的人最多的那个点一定是可能胜利的。
现在我们来证明这个结论。

**利用反证法**：若甲赢的次数最多，而乙一定能赢甲，那 乙必须可以打败甲及甲的所有能战胜的人，但是此时乙赢的次数会超过甲，所以矛盾。

同时，甲这种人可能有很多个，我们对于每一个像甲一样的人分别枚举一遍可能战胜甲的人，然后把这些人也加进答案里就可以了。这个关系用链表来维护。

**证明**：先把甲放进决赛的两个人之一，然后甲所有能战胜的人已经被淘汰，如果此时所有与甲胜负不确定的人（除了乙）跟甲对抗都输了，那么乙也就进入了决赛，然后乙就有可能获得胜利。（比较绕口，可以借助语文素养理解）。

# 代码及一些步骤解释
```cpp
#include <bits/stdc++.h>
#define int long long
const int MAXN = 1e6 + 10;
using namespace std;
int n, head[MAXN], cnt, ans, mx, vis[MAXN], pre[MAXN], lst[MAXN];
struct edge{
	int to, next;
}e[MAXN << 1];
vector<int> p;
queue<int> q;
void add(int u, int v)
{
	e[++cnt].to = v;
	e[cnt].next = head[u];
	head[u] = cnt;
}
void del(int i)
{
	int l = pre[i], r = lst[i];
	lst[l] = r;
	pre[r] = l;
} 
void bfs()
{
    while(!q.empty())
    {
        int u = q.front();
        q.pop();
        int x = head[u];
        for (int i = pre[n + 1]; i; i = pre[i])//正着写估计也行但我不知道怎么跳出循环 
        {
            while(i < e[x].to)	x = e[x].next;//找出第一个大于等于e[x].to的i，因为我们是想看i是否是其中一条必胜边，这算是个小优化吧 
            if(i != e[x].to)
			{
				ans++;
				q.push(i);
				vis[i] = 1;
				del(i);
			}
        }
    }
}
signed main()
{
	scanf("%lld", &n);
	for (int i = 1; i <= n; i++)
		pre[i] = i - 1, lst[i] = i + 1;//链表，方便描述剩下的不确定的人 
    pre[n + 1] = n;
	lst[0] = 1;
	int k = 0;
    for (int i = 1; i <= n; i++)
    {
        scanf("%lld", &k);
		if(k > mx)//找出像甲一样的人（即可以战胜的人最多的人 
		{
			p.clear();
			mx = k;
		}
		if(k == mx) p.push_back(i);//存到一个vector种，小优化 
        for (int j = 1; j <= k; j++)
		{	
			int x;
			scanf("%lld", &x);
			add(i, x);//建立 x-->y 的边，表示 x 一定可以战胜 y 
		}
    }
    for (int i = 0; i < p.size(); i++)
    {
    	ans++;
		q.push(p[i]); 
		vis[p[i]] = 1;//一定别写成i！！！我在这调了好久
		del(p[i]);
	}
	bfs();//广搜寻找 
	printf("%lld ", ans);
	for(int i = 1; i <= n; i++)
		if(vis[i]) printf("%lld ",i);
	return 0;
}
```


---

## 作者：chenxinyang2006 (赞：0)

典中典之题解区全都一模一样。

---------

一次合法的对决应该有 $n-1$ 次，如果 $u$ 击败了 $v$，就从 $u$ 向 $v$ 连一条有向边，那么得到的应该是一颗叶向树。

稍微证一下这个结论：因为最后只有一个胜者，其他人都被击败一次，所以应该是 $1$ 个节点无入度，$n-1$ 个节点入度为 $1$。而如果有多个联通块，那么一定出现了环，但环不可能符合击败的时间顺序，所以只有一个连通块。

如果可以构造出一颗叶向树，那么一定存在一种合法的对决，使得这颗叶向树的根成为胜者。只需要每次任取一个叶子，让它的父亲击败它，然后删除这个叶子即可。

那么我们可以知道，点 $u$ 可以成为对决胜者的充要条件是：可以构造出一颗以 $u$ 为根的叶向树。

由题意，有一些 $(u,v)$ 的胜负关系是已经确定的，只能 $u$ 击败 $v$，而不能相反。对于这些关系，自 $u$ 向 $v$ 连有向边。

对于剩下的 $(u,v)$，这两个人的胜负关系尚未确定，$u,v$ 之间连无向边。我们所要决策的内容就是为无向边定向。

但构造叶向树这个问题仍比较困难，现在给出结论：$u$ 可以作为叶向树根的充要条件是，它可以到达 $1 \sim n$ 所有点。

必要性显然。对于充分性，一开始向叶向树加入 $u$ 点。如果当前未所有点均已加入，任取一个未加入的点 $v$，取一条 $u$ 到 $v$ 的路径，找到路径上最后一个在叶向树内的点 $w$，然后把路径上 $w$ 到 $v$ 的这一段加入叶向树。

于是问题转化为：给定一张完全图，有 $m$ 条边有向，剩余边无向。问你有哪些点可以到达剩余所有点。

这就是 P2341，于是我们套用那里的做法。先对无向边进行缩点，然后得到的一定是有不超过 $\sqrt m$ 个点的竞赛图，然后对得到的竞赛图跑 P2341 即可。

这里细说一下怎么对无向边缩点：维护集合 $S,T$，分别表示还未被搜到的点集和还未用于更新的点集。每次取出一个 $T$ 中的点 $u$，然后遍历 $S$。如果 $S$ 中的 $v$ 和 $u$ 没有有向边，那么把 $v$ 从 $S$ 中删除，加入 $T$；否则我们找到一条输入的有向边 $(u,v)$，势能减 $1$。

而势能只有 $m$，故这样做的复杂度是 $O(n + m)$ 的（如果你能 $O(1)$ 判定 $u,v$ 间是否直接有边）。

喜提最劣解。

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
int n,m;
int u[1000005],v[1000005];

unordered_map <ll,int> M;

ll calc(int x,int y){
	//printf("calc %d to %d %lld\n",x,y,(ll)n * (x - 1) + y);
	return (ll)n * (x - 1) + y; 
}

int N;
int fr[1000005];
vector <int> S,T,tmp;//T 集合,尚未进行拓展的点集,S 集合未被拓展到的集合

int cnt,c;
int G[1505][1505],dfn[1505],low[1505],tag[1505],id[1505];

void tarjan(int u){
	dfn[u] = low[u] = ++cnt;
	tag[u] = 1;
	S.push_back(u);
	for(int v = 1;v <= N;v++){
		if(!G[u][v]) continue;

		if(!dfn[v]){
			tarjan(v);
			low[u] = min(low[u],low[v]);
		}else if(tag[v]){
			low[u] = min(low[u],dfn[v]);
		}
	}
	//printf("node %d dfn %d low %d\n",u,dfn[u],low[u]);
	if(dfn[u] != low[u]) return;
	++c;	
	while(S.back() != u){
		id[S.back()] = c;
		tag[S.back()] = 0;
		S.pop_back();
	}
	id[u] = c;
	tag[u] = 0;
	S.pop_back();
}

int main(){
	scanf("%d",&n);
	for(int i = 1;i <= n;i++){
		int k;
		scanf("%d",&k);
		for(int j = 1;j <= k;j++){
			++m;
			u[m] = i;scanf("%d",&v[m]);
		}
	}
	for(int i = 1;i <= m;i++){
		//printf("%d %d\n",u[i],v[i]);
		M[calc(u[i],v[i])] = 1;
		M[calc(v[i],u[i])] = -1;
	}
	for(int i = 1;i <= n;i++) S.push_back(i);

	memset(fr,0,sizeof(fr));
	for(int i = 1;i <= n;i++){
		if(fr[i]) continue;
		++N;
		T.push_back(i);
		while(!T.empty()){
			int u = T.back();
			T.pop_back();
			fr[u] = N;
			for(int i = 0;i < S.size();i++){
				if(!fr[S[i]] && M[calc(S[i],u)] != 0){
					tmp.push_back(S[i]);
				}else{
					T.push_back(S[i]);
					//printf("%d extend to %d\n",u,S[i]);
				}
			}
			S.clear();
			while(!tmp.empty()){
				S.push_back(tmp.back());
				tmp.pop_back();
			}
		}
	}

	for(int i = 1;i <= m;i++) if(fr[u[i]] != fr[v[i]]) G[fr[u[i]]][fr[v[i]]] = 1;

	for(int i = 1;i <= N;i++) if(!dfn[i]) tarjan(i);

	/*for(int i = 1;i <= N;i++) printf("%d ",id[i]);
	printf("\n");

	for(int i = 1;i <= n;i++) printf("%d ",fr[i]);
	printf("\n");
	for(int i = 1;i <= N;i++){
		for(int j = 1;j <= N;j++){
			printf("%d ",G[i][j]);
		}
		printf("\n");
	}*/

	memset(G,0,sizeof(G));
	for(int i = 1;i <= n;i++) fr[i] = id[fr[i]];
	for(int i = 1;i <= m;i++) if(fr[u[i]] != fr[v[i]]) G[fr[u[i]]][fr[v[i]]] = 1;

	int center = 0,flg;
	for(int u = 1;u <= c;u++){
		flg = 1;
		for(int v = 1;v <= c;v++){
			if(u == v) continue;
			if(G[v][u]) flg = 0;
		}
		if(flg) center = u;
	}
	int ans = 0;
	for(int i = 1;i <= n;i++) ans += (fr[i] == center);
	printf("%d ",ans);
	for(int i = 1;i <= n;i++) if(fr[i] == center) printf("%d ",i);
	printf("\n");
	return 0;
}
```


---

## 作者：_Fontainebleau_ (赞：0)


首先，我们要认识到一个问题，**胜负关系不具有传递性**，也就是说如果 $A$ 和 $B$ 比，$A$ 赢了，并不意味着 $A$ 就比 $B$ 强大，所有 $B$ 赢了的 $A$ 都一定能赢。

这就很烦。但是我们从直觉出发，应该会认为，赢的次数最多的人一定 **有可能** 赢。

试着证明一下，说不定我们就有了正确思路呢。

如果 $A$ 赢的次数最多，而有一个 $B$ **一定** 能赢 $A$，那 $B$ 就必须可以打败 $A$ 以及 $A$ 的 **所有** 手下败将们，但是此时 $B$ 赢的次数已然超过 $A$，所以矛盾。

当然赢的次数最多的人可能有好多个，我们就把他们叫 $A_1,\ldots,A_t$ 好了。

对于每个 $A_i$，我们去枚举剩下的还没确定的点 $p$。只要 $p$ 不被 $A_i$ 确定打败，那么 $p$ 就有可能赢，把他加入可能赢的行列中。这种关系具有传递性，用 BFS 就好了。

代码如下。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,d[1000006],cnt,tot,mx;
int h[1000006],t[1000006],nxt[1000006];
bool win[1000006];
int pre[1000006],lst[1000006];
int q[1001001],f,e;
inline void del(int i){int l=pre[i],r=lst[i];lst[l]=r,pre[r]=l;}
inline void add(int u,int v){t[++cnt]=v,nxt[cnt]=h[u],h[u]=cnt;}
void bfs()
{
    while(f<=e)
    {
        int u=q[f++];
        int p=h[u];
        for(int i=pre[n+1];i;i=pre[i])
        {
            while(i<t[p])	p=nxt[p];
            if(i!=t[p])	tot++,q[++e]=i,win[i]=true,del(i);
        }
    }
}
inline int read()
{
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-f;c=getchar();}
	while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
	return x*f;
}
int main()
{
    n=read();
    for(int i=1;i<=n;++i)	pre[i]=i-1,lst[i]=i+1;
    pre[n+1]=n,lst[0]=1;
    for(int i=1;i<=n;i++)
    {
        d[i]=read();mx=max(mx,d[i]);
        for(int j=1;j<=d[i];++j){int x=read();add(i,x);}
    }
    for(int i=1;i<=n;++i)
        if(d[i]==mx)
            tot++,q[++e]=i,win[i]=true,del(i);
    f=1;bfs();
    printf("%d ",tot);
    for(int i=1;i<=n;++i)if(win[i])printf("%d ",i);
    return 0;
}
```

需要注意的是，题目里虽然没有讲，但是所有的数据都保证了每个候选人胜负情况中其他候选人的编号是单调递增的，从而使得上面的代码免去了排序导致的 $O\left(n\log{n}\right)$，做到了 $O(n)$。

若为严谨故，不妨将代码中的前向星改为 `vector<int>g[]`，然后 `sort(g.begin(),g.end())`。

[这是机房巨佬的示例](https://www.luogu.com.cn/paste/glubful5)。

---


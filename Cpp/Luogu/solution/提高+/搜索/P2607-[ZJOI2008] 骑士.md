# [ZJOI2008] 骑士

## 题目描述

Z 国的骑士团是一个很有势力的组织，帮会中汇聚了来自各地的精英。他们劫富济贫，惩恶扬善，受到社会各界的赞扬。

最近发生了一件可怕的事情，邪恶的 Y 国发动了一场针对 Z 国的侵略战争。战火绵延五百里，在和平环境中安逸了数百年的 Z 国又怎能抵挡的住 Y 国的军队。于是人们把所有的希望都寄托在了骑士团的身上，就像期待有一个真龙天子的降生，带领正义打败邪恶。

骑士团是肯定具有打败邪恶势力的能力的，但是骑士们互相之间往往有一些矛盾。每个骑士都有且仅有一个自己最厌恶的骑士（当然不是他自己），他是绝对不会与自己最厌恶的人一同出征的。

战火绵延，人民生灵涂炭，组织起一个骑士军团加入战斗刻不容缓！国王交给了你一个艰巨的任务，从所有的骑士中选出一个骑士军团，使得军团内没有矛盾的两人（不存在一个骑士与他最痛恨的人一同被选入骑士军团的情况），并且，使得这支骑士军团最具有战斗力。

为了描述战斗力，我们将骑士按照 $1$ 至 $n$ 编号，给每名骑士一个战斗力的估计，一个军团的战斗力为所有骑士的战斗力总和。

## 说明/提示

#### 数据规模与约定

对于 $30\%$ 的测试数据，满足 $n \le 10$；

对于 $60\%$ 的测试数据，满足 $n \le 100$；

对于 $80\%$ 的测试数据，满足 $n \le 10 ^4$。

对于 $100\%$ 的测试数据，满足 $1\le n \le 10^6$，每名骑士的战斗力都是不大于 $10^6$ 的正整数。

## 样例 #1

### 输入

```
3
10 2
20 3
30 1
```

### 输出

```
30```

# 题解

## 作者：HullEssien (赞：197)

本题解比较啰嗦

尽力用最容易明白的语言来讲

希望对大家有帮助


基环树

一个听起来很高大上的名词

但是不要被这个名字吓跑了

其实这个题

思路很简单

没比一道普通的树形DP难多少

(依然不懂这个题为什么省选/NOI-,明明和树形DP入门题没有上司的舞会那么像)

只是细节比较多而已

(其实也不算很多啦)


认真读完题目我们会发现

因为一个骑士有且只有一个最讨厌的人

而且这个骑士不会讨厌自己

即该图中是没有自环的


然后
从网上搜的很多题解都是用无向图存边

然后用一些高超的技巧(如位运算)判断卡掉无向二元环

但是题解中的kczno1

这位神犇就没有使用无向图

事实证明存无向图是完全没有必要的


因为本身有向图就携带着指向上一个节点的信息

而且这个信息更利于维护我们删边之后的操作

这样
不仅省去了判断的麻烦

还有利于维护信息

何乐而不为?


所以
考虑这个有向图

我们把x所讨厌的人y设为x的父亲节点

这样考虑**每一个人都有且只有一条出边**

所以对一个"联通块"

只有根节点**有机会**形成环

即环一定包含根节点


为什么呢?

**因为一个点的出度只能为1**

考虑非根节点

它的出度一定是贡献给它的父亲的

而根节点它的出度只能贡献给它的后代

(这里的"根节点""叶子节点"都只是为了描述方便,并不严谨,也许可以理解为"删边以后的叶子和根"?)


所以我们又解决了一个问题:

**每个联通块内有且只有一个简单环**


这样
我们考虑把每个联通块的环上删一条边

这样它必然构成树

然后要注意

删掉的边所连接的两点x,y

是不能同时选的

所以我们分别强制x,y其中一个点不选

对新树跑DP

显然相邻的点是不能选的

所以得到状态转移方程:

用f[i][0/1]表示以i为根节点的子树选i/不选i所能获得的最大价值

则
f[i][0]=sigema(max(f[son][0],f[son][1])); for each son of i

f[i][1]=sigema(f[son][0]); for each son of i

应该就很清楚了


再一个细节就是

答案会爆int

我交了数遍

都卡在这里


代码:






```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define maxn 2000000
using namespace std;
int n,cnt;
long long ans;
int root;
long long f[maxn][2];
int head[maxn],val[maxn],vis[maxn],fa[maxn];
struct edge
{
    int pre,to;
}e[maxn];
inline void add(int from,int to)
{
    e[++cnt].pre=head[from];
    e[cnt].to=to;
    head[from]=cnt;
}
void dp(int now)
{
    vis[now]=1;
    f[now][0]=0,f[now][1]=val[now];
    for(int i=head[now];i;i=e[i].pre)
    {
        int go=e[i].to;
        if(go!=root)
        {
            dp(go);
            f[now][0]+=max(f[go][1],f[go][0]);
            f[now][1]+=f[go][0];
        }
        else
        {
            f[go][1]=-maxn;
        }
    }
}
inline void find_circle(int x)
{
    vis[x]=1;
    root=x;
    while(!vis[fa[root]])
    {
        root=fa[root];
        vis[root]=1;
```
}//找环


 
```cpp
    dp(root);
    long long t=max(f[root][0],f[root][1]);
    vis[root]=1;
    root=fa[root]; 
    dp(root);
    ans+=max(t,max(f[root][0],f[root][1]));
    return;
}
inline int in()
{
    char a=getchar();
    while(a<'0'||a>'9')
    {
        a=getchar();
    }
    int t=0;
    while(a<='9'&&a>='0')
    {
        t=(t<<1)+(t<<3)+a-'0';
        a=getchar();
    }
    return t;
}
//写一下伪代码 
//在存的时候存一下每个人最讨厌的人为他的父亲
//对每个没访问的点DFS 
//在这个没访问的点所在的连通块上找环
//找到以后强制不选它的父亲对它进行DP
//然后强制不选它对它的父亲进行DP
//然后取一个最大值即可 
//在DP里面
//先考虑f[x][0]是不选x,初始值为0
//f[x][1]是选x,初值为val[x]
//这是一个很好的赋值方法
//然后跑DP就行了 
int main()
{
    n=in();
    for(int i=1;i<=n;i++)
    {
        val[i]=in();
        int x=in();
        add(x,i);
    //    add(i,x);
        fa[i]=x;
    }
    for(int i=1;i<=n;i++)
    {
        if(!vis[i])
        {
            find_circle(i);
        }
    }
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：远航之曲 (赞：88)

树形DP，没有上司的舞会的模型。。。

根据题目可以知道， 每一个联通块里有且只有一个环， 所以我们找到这个环然后从中间把它断开， 对断开的两个端点u1, u2, 分别舞会。

设dp[u][0]为不选u, dp[u][1]为选u，

那么这个联通块答案就是max(dp[u1][0], dp[u2][0])。

注意有**好多**联通块。对于所有联通块跑dp，加起来就是答案


```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#define N 1000010
using namespace std;
int fun[N],a,b;
long long f[N][2];
struct node
{
    int next,to,v;
}e[2000010];
int st[1000010],vis[N],n,s,tot,x1,x2,E;
void add(int x,int y)
{
    e[tot].to=y,e[tot].next=st[x],st[x]=tot++;
    //e[++tot].to=x,e[tot].v=z,e[tot].next=st[y],st[y]=tot;
}
void find_circle(int x,int pre)
{
    vis[x]=1;
    for (int i=st[x];~i;i=e[i].next)
    {
        if ((i^1)==pre) continue;
        if (vis[e[i].to])
        {
            x1=x,x2=e[i].to;
            E=i;
            continue;
        }
        find_circle(e[i].to,i);
    }
}
void dfs(int x,int pre)
{
    f[x][0]=0;
    f[x][1]=fun[x];
    for (int i=st[x];~i;i=e[i].next)
    {
        if ((i^1)==pre) continue;
        if (i==E || (i^1)==E)
            continue;
        dfs(e[i].to,i);
        f[x][1]+=f[e[i].to][0];
        f[x][0]+=max(f[e[i].to][1],f[e[i].to][0]);
    }
}
main()
{
    memset(st,-1,sizeof st);
    scanf("%d",&n);
    for (int i=1;i<=n;i++)
        scanf("%d%d",&a,&b),add(i,b),add(b,i),fun[i]=a;
    long long ans=0;
    for (int i=1;i<=n;i++)
    {
        if (vis[i]) continue;
        find_circle(i,-2);
        dfs(x1,-1);
        long long temp=f[x1][0];
        dfs(x2,-1);
        temp=max(temp,f[x2][0]);
        ans+=temp; 
    }
    printf("%lld",ans);
}
```

---

## 作者：AFOier (赞：48)

### 这题是一个很裸的树形dp，但是坑点很多

思路： 我们把一个骑士和他憎恨的骑士连边，很显然这会构成一个由基环树组成的**森林**。

我们对这个基环树森林进行树形dp（类似于[没有上司的舞会](https://www.luogu.org/problem/P1352)），对于每一棵基环树，任意相连的两个点不能同时取。

众所周知，要使一棵基环树转化为一棵树，必须要断掉其环上的一条边。

我们考虑环上的任意一条边，它的两个端点至少有一个不取。则分别以两个端点为根进行树形dp，分别存在$f$数组和$g$数组中。（$f[i][0/1]$和$g[i][0/1]$表达以点$i$为根的子树中，且当前节点$i$ 不取/取 的最大战斗力）

我们可以发现，对于每一条环上的边，它的贡献相同

令任意边两端点分别为$ui, vi$

则对每个基环树（联通块）将答案累加上$max(f[ui][0], g[vi][0])$ 即可

**注意以下几个坑点：**

**1.要开long long**

**2.组成的是基环树森林而非单棵基环树**

**3.判断不走断开的边时必须用边来判断，不能用点，因为两个骑士可能相互憎恨，形成重边，这时如果判断点，会造成树不联通。**

下面再给出可以hack掉不注意以上第2/3个坑点的程序的测试数据供参考：

```
输入:
4
10 2
20 1
10 4
20 3

输出:
40
```

$Code:$

```
#include <cstdio>
#include <iostream>

#define ll long long

using namespace std;

int n, pos;
ll ans, s[1000011];

struct edge{
	int u, v, nxt;
}a[2000011]; //链式前向星

int tot, fir[1000011];

int ui, vi, E; //断开边的两端点及其编号

bool suc; //是否找到环

bool vis[1000011]; 

bool used[1000011]; //之前的联通块是否已经覆盖这个点

ll f[1000011][2], g[1000011][2];

bool vis1[1000011], vis2[1000011];

void fg(int w){
	used[w] = 1;
	int now = fir[w];
	while(now){
		if(!used[a[now].v])
			fg(a[now].v);
		now = a[now].nxt;
	}
} //覆盖当前基环树（联通块）
void find_circle(int w, int fa){
	if(suc) return ;
	int now = fir[w];
	vis[w] = 1;
	while(now){
		if(!vis[a[now].v])
			find_circle(a[now].v, w);
		else if(a[now].v != fa){
			ui = a[now].u;
			vi = a[now].v;
			E = now;
			suc = true;
			return ;
		}
		now = a[now].nxt;
	}
}//找环

void New(int from, int to){
	a[++tot].u = from;
	a[tot].v = to;
	a[tot].nxt = fir[from];
	fir[from] = tot;
}//建边

void dfs1(int w){
	int now = fir[w];
	f[w][1] = s[w];
	vis1[w] = 1;
	while(now){
		if(!vis1[a[now].v] && (now^1) != E){
			dfs1(a[now].v);
			f[w][0] += max(f[a[now].v][0], f[a[now].v][1]);
			f[w][1] += f[a[now].v][0];
		}
		now = a[now].nxt;
	}
}//以ui为根的树形dp
void dfs2(int w){
	int now = fir[w];
	g[w][1] = s[w];
	vis2[w] = 1;
	while(now){
		if(!vis2[a[now].v] && (now^1) != E){
			dfs2(a[now].v);
			g[w][0] += max(g[a[now].v][0], g[a[now].v][1]);
			g[w][1] += g[a[now].v][0];
		}
		now = a[now].nxt;
	}
}//以vi为根的树形dp

int main(){
	tot = 1;
	ui = vi = 0; // 环上任意边的两点 
	scanf("%d", &n);
	for(int i = 1; i <= n; i++){
		scanf("%lld%d", &s[i], &pos);
		New(i, pos); New(pos, i);
	}
	for(int i = 1; i <= n; i++){
		if(used[i]) continue;
		fg(i); suc = false;
		find_circle(i, 0);
		dfs1(ui); // 求以ui为根节点的树形dp 
		dfs2(vi); // 求以vi为根节点的树形dp 
		ans += max(f[ui][0], g[vi][0]);
	}
	printf("%lld\n", ans);
	return 0;
}
```

---

## 作者：ccsc (赞：34)

[P2607 [ZJOI2008]骑士](https://www.luogu.org/problemnew/show/P2607)

认真的写题解，（~~我都不信~~）咳咳，学习！！

我们看完这道题应该思路很清晰，清晰到题意都忘了，咳！

再看一遍，咦~“真龙天子的降生，带领正义打败邪恶。”谁？谁喊我来着？

心平气和，我要拯救世界，呼~吸~

咳咳，看完题意，嗯，我的眼中闪着智慧的光芒，

点开旁边的算法标签，--动态规划,…… 嗯， 动规dp…… 嗯， 搜索 ……嗯，算个好题 树形动规…… 嗯，还好都会……（擦汗） 环套树
“环套树”嗯！！？(⊙_⊙)?  啊，谁关灯？（心虚……）我咋没看到这道题？我刚才好像啥都没点，啥都没看见……对……

嗯……（尴尬的气氛）是不是该吃饭了？

我先吃个饭啊……（~~滚~~溜）

一天后……，

我昨天是不是看过一道环套树？昨天咋没写？唉？肯定是忘了，嗯嗯，对；


------------------------


## 认真解题：

题目大意：n位骑士，每个人的战力可能不一样，并且每一个人都有一个厌恶对象；求组合为一个骑士团，骑士团的最大战力；

这道题，可以抽象为n个点n条边的无向图。如果我们把它想象为一个有向连通图，那问题就变得简单了起来，；着了插入一个关于基环树的概念；虽说在看的dalao应该都会……为什么要用基环树下面自然就知道了


下面我们讲解基环树：

这是一棵普通的基环树：
![](https://cdn.luogu.com.cn/upload/pic/65032.png)
对于基环树，我们主要分为两种：一种叫做基环内向树，另一种基环外向树；具体的区别；

基环内向树是每个点只有一条出度，如下图：

![](https://cdn.luogu.com.cn/upload/pic/64979.png)

基环外向树是每个点只有一条入度，如下图：

![](https://cdn.luogu.com.cn/upload/pic/65034.png)

这是基环树的大概定义；；

那对于这道题，，有啥用？

首先：
我们可以将骑士所仇恨的人和他自己连一条线，单向的（可以将仇恨的人指向自己，也可以自己指向仇恨的人）；两种方法都可以；

那现在我们就可以将这个问题转化为在基环外向树上找权值最大的独立集的问题；

那事情就变得简单了起来，我们现在的主要问题就是：如何找根？？

这个问题，，朴素做法：我们对于每一个点都作为根节点，然后dp，

这是比较好想的算法，那我们可以尝试这样写一下，很慢……很慢……很慢……

对于好一点的方法：

#### 我们设f[i][0],,f[i][1];记f[v][0]为不选当前节点的最大值，f[v][1]为选择当前节点后的最大值，ans取较大者即可。

我们找到环上的一条边，把这条边中的一个点选成根进行dp，这个时候，根节点的f[root][0]一定是准确的，但是f[rt][1]是不准确的，我们必须强制这条边的另一个点不选，然后将这个状态走环一圈，再用来更新f[rt][1] 


由于每个点的仇恨的人向自己连一条边，那么入度必然是1，我们可以直连单向边，然后记录指向自己的人作为父亲，每个点顺着父亲走必然可以走到环上

大概应该就是这样
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N=1000100;
struct pp{
	int next,to;
}a[N];
int head[N],fa[N];ll s[N],n,tot,ans,f[N][2];
bool v[N],v1[N];

void add(int x,int y){
	a[++tot].next=head[x];
	a[tot].to=y;
	head[x]=tot;
	fa[y]=x;
}

void ss(int x){
	v[x]=1;
	f[x][1]=s[x];
	for(int i=head[x];i;i=a[i].next){
		if(v[a[i].to]==0){
			ss(a[i].to);
			f[x][0]+=max(f[a[i].to][1],f[a[i].to][0]);
			f[x][1]+=f[a[i].to][0];
		}
	}
}

void dp(ll x){
	int root;
	for(root=x;v1[root]==0;root=fa[root]){       //寻找环，该循环会在有环的情况下--退出；^ ^ 
		v1[root]=1;//标记一下 
	}//cout<<root<<endl;
	ss(root);
    x=fa[root];//cout<<x<<endl;
	f[x][1]=f[x][0];
	for(x=fa[x];x!=root;x=fa[x]){
		f[x][1]=s[x];
		f[x][0]=0;
		for(int j=head[x];j;j=a[j].next){
			f[x][1]+=f[a[j].to][0];
			f[x][0]+=max(f[a[j].to][1],f[a[j].to][0]); 
		}
	}//cout<<f[root][1]<<" "<<f[root][0]<<endl;
	f[root][1]=s[root];
	for(int i=head[root];i;i=a[i].next){
		f[root][1]+=f[a[i].to][0];
	}//cout<<f[root][1]<<endl;
	ans+=max(f[root][1],f[root][0]);
	
}

int main()
{
	scanf("%lld",&n);
	ll q;
	for(int i=1;i<=n;i++){
		scanf("%lld%lld",&s[i],&q);
		add(q,i);
		//cout<<q<<"-->"<<i<<endl;
	}
	for(int i=1;i<=n;i++){
		if(v[i]==0)dp(i);
	}
	printf("%lld",ans);
	return 0;
 } 
```



---

## 作者：stoorz (赞：21)

[蒟蒻的Blog](https://blog.csdn.net/SSL_ZYC/article/details/87031159)

[双倍经验 P1453 城市环路](https://www.luogu.org/problemnew/show/P1453)

一开始没有看出来就是没有上司的舞会那道题啊。用自己的方法做的。
这道题是一个基环树森林，所以拆成每一个基环树来做。

对于任意一棵基环树，它的长相是这样的。

![在这里插入图片描述](https://i.loli.net/2019/02/20/5c6d04f5ec4ad.png)

先找到环

![在这里插入图片描述](https://i.loli.net/2019/02/20/5c6d04f5ebc3c.png)

然后对于环上的每一个节点为根，求出在其子树内的最大攻击力。
设$f[x][0/1]$表示在以节点$x$为根的子树内，不选或者选点$x$的最大攻击力。那么明显方程为

$$f[x][1]=(\sum f[y][0](y\in son[x]))+a[x]$$

$$f[x]][0]=\sum max(f[y][0],f[y][1])(y\in son[x]))$$

其中$a[x]$表示$x$的攻击力。

那么接下来就要处理环上的点了。

由于环上的点$1$和点$cnt$是不可以同时选择的（$cnt$表示换上的点的个数），所以这次就多设一维，$g[i][0/1][0/1]$表示环上的第$i$个点 不选/选 ,且第一个点 不选/选 的最大攻击力。

- 那么对于第1个点不选的情况，要初始化好$g[2]$，其方程为

$$g[i][0][0]=max(g[i-1][1][0],g[i-1][0][0])+f[Q[i]][0]$$

$$g[i][1][0]=g[i-1][0][0]+f[Q[i]][1]$$

其中$Q[i]$表示环上的第$i$个点。

- 对于选择第一个点的情况，第二个点一定不能选。所以初始化好$g[2],g[3]$。（$g[2]$不可以不初始化，虽然在转移过程中起不到作用，但是如果这个环上只有两个点的话，不初始化$g[2]$就没办法输出$g[2]$的答案），其方程为

$$g[i][0][1]=max(g[i-1][1][1],g[i-1][0][1])+f[Q[i]][0]$$

$$g[i][1][1]=g[i-1][0][1]+f[Q[i]][1]$$

由于最终答案中$1$和$cnt$不可以同时选择，所以答案就是
$max(g[cnt][1][0],g[cnt][0][0],g[cnt][0][1])$

时间复杂度$O(n)$，跑的比较慢，需要进行优化。

***


```cpp
#include <cstdio>
#include <cstring>
#include <queue>
#include <algorithm>
#define rr register
using namespace std;
typedef long long ll;

const int N=1000010;
int n,x,tot,cnt,head[N],a[N],in[N],Q[N];
ll f[N][2],g[N][2][2],ans;
bool vis[N],ok;

struct edge
{
    int next,to;
}e[N*2];

ll maxx(ll x1,ll x2,ll x3)
{
    return max(x1,max(x2,x3));
}

int read()
{
	int d=0;
	char ch=getchar();
	while (ch<'0'||ch>'9') ch=getchar();
	while (ch>='0'&&ch<='9') 
		d=(d<<3)+(d<<1)+ch-48,ch=getchar();
	return d;
}

void add(int from,int to)
{
    e[++tot].to=to;
    e[tot].next=head[from];
    head[from]=tot;
}

void topsort()  //拓扑排序找环
{
    queue<int> q;
    for (rr int i=1;i<=n;i++)
        if (in[i]==1) q.push(i);
    while (q.size())
    {
        int u=q.front(),v;
        q.pop();
        for (rr int i=head[u];~i;i=e[i].next)
        {
            v=e[i].to;
            if (in[v]>1)
            {
                in[v]--;
                if (in[v]==1) q.push(v);
            }
        }
    }
}

void find(int x)  //寻找环上的点
{
    vis[x]=1; 
    Q[++cnt]=x;
    for (rr int i=head[x];~i;i=e[i].next)
    {
        int y=e[i].to;
        if (!vis[y]&&in[y]>=2) find(y);
    }
}

void dp(int x)  //求非环上的点的最大攻击力
{
    vis[x]=1;
    f[x][1]=(ll)a[x];
    for (rr int i=head[x];~i;i=e[i].next)
    {
        int y=e[i].to;
        if (!vis[y]&&in[y]<=1)
        {
            dp(y);
            f[x][1]+=f[y][0];
            f[x][0]+=max(f[y][0],f[y][1]);
            ok=1;
        }
    }
}

int main()
{
    memset(head,-1,sizeof(head));
    n=read();
    for (rr int i=1;i<=n;i++)
    {
        a[i]=read(),x=read();
        add(x,i);
        add(i,x);
        in[i]++;  //这个点的度数
        in[x]++;
    } 
    topsort();
    for (rr int k=1;k<=n;k++)
        if (in[k]>=2&&!vis[k])
        {
            memset(Q,0,sizeof(Q));
            memset(g,0,sizeof(g));
            cnt=0;
            find(k);
            for (rr int i=1;i<=cnt;i++)
                dp(Q[i]);
            g[2][1][0]=f[Q[1]][0]+f[Q[2]][1];
            g[2][0][0]=f[Q[1]][0]+f[Q[2]][0]; 
            for (rr int i=3;i<=cnt;i++)
            {
                g[i][0][0]=max(g[i-1][1][0],g[i-1][0][0])+f[Q[i]][0];
                g[i][1][0]=g[i-1][0][0]+f[Q[i]][1];
            }
            g[2][0][1]=f[Q[1]][1]+f[Q[2]][0];
            g[3][0][1]=f[Q[1]][1]+f[Q[2]][0]+f[Q[3]][0];
            g[3][1][1]=f[Q[1]][1]+f[Q[2]][0]+f[Q[3]][1];
            for (rr int i=4;i<=cnt;i++)
            {
                g[i][0][1]=max(g[i-1][1][1],g[i-1][0][1])+f[Q[i]][0];
                g[i][1][1]=g[i-1][0][1]+f[Q[i]][1];
            }
            ans+=maxx(g[cnt][1][0],g[cnt][0][0],g[cnt][0][1]);
        }
    printf("%lld",ans);
    return 0;
}
```


---

## 作者：枫林晚 (赞：15)

## 题目大意：

N个骑士组个队，每个骑士有战力，每个骑士恨一人，相互憎恨不同在队里，怎样安排战斗力最大？输出最大总战斗力即可。

## 分析：

明显的，每个骑士恨一个人，那么这两个人之间可以连一条边。是有向的还是无向的？可以想到，如果一个骑士恨一个骑士，那么他们两个无论如何不可能在这个队里，我恨你，就相当于你恨我，所以要连接一条无向边。

所以这样我们得到了一个森林，森林里的每一棵树，要么是一棵普通的树，要么是一个带环的图，因为每个骑士只最恨一个人，不难证明，这个图一定只有一个环。所以就是环套树。

## 做法：

1.输入建边。

2.不断dfs找到所有的树或者是环套树。

3每个dfs后，处理每一棵树。

4.处理的时候，f[i][0/1],表示在i所在的子树中，0代表这个骑士不选，1代表选所可以获得的最大的战斗力。如果是树，直接树形dp；

如果环套树，拆环成链，从环上任意一个地方断开，断点设为r1,r2，以r1为根树形dp一遍，并强制让r1不能被选，即为f[r1][0];同理，r2也这样一下，记录f[r2][0],这样相当于，在强制r1/r2中选一个或者都不选的情况下，进行一个树形dp。

ans加上这两次dp的最大值即可。

详见代码（极丑，但是易懂）：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=1000000+10;
int p[N];//战斗力 

struct node{
    int to,nxt;
}bian[2*N];
int head[N],cnt=1;//邻接表 

int mem[N];//每个树的元素 mem[0]用来计数 
bool vis[N];//元素是否访问过 
bool flag;//该次dfs找到的树是不是有环 
int r1,r2;//有环的话，第一次找到环的位置作为断点 

ll ans;
ll f[N][2];//dp数组 i为子树，i选或不选战斗力总和最大值 
void add(int x,int y)
{
    bian[++cnt].nxt=head[x];
    bian[cnt].to=y;
    head[x]=cnt;
}
void dfs(int x,int fa)
{
    vis[x]=1;
    mem[++mem[0]]=x;
    for(int i=head[x];i;i=bian[i].nxt)
    {
        int y=bian[i].to;
        if(y==fa) continue;
        if(!vis[y]) dfs(y,x);
        else if(vis[y]&&!flag)
        {
            flag=true;//find circle!!
            r1=x,r2=y;
        }
    }
}//dfs 找到一棵新树。 
void dfs2(int x,int fa)
{
    f[x][0]=0;
    f[x][1]=p[x];
    for(int i=head[x];i;i=bian[i].nxt)
    {
        int y=bian[i].to;
        if(y&&y!=fa)
        {
            dfs2(y,x);
            f[x][1]+=f[y][0];
            f[x][0]+=max(f[y][0],f[y][1]);
        }
    }
}//dfs2 树形dp 
void clear()
{
    mem[0]=0;
    flag=false;
}//清空 
void work()
{
    if(!flag)//是棵树
    {
        int root=mem[1];
        dfs2(root,-1);
        ans+=max(f[root][0],f[root][1]);
    } 
    else//是环套树 
    {
        ll mx=-100;
        for(int i=head[r1];i;i=bian[i].nxt)
        {
            if(bian[i].to==r2)
            {
                bian[i].to=0;
                bian[i^1].to=0;
                break;
            }
        }
        dfs2(r1,-1);
        mx=max(mx,f[r1][0]);
        dfs2(r2,-1);
        mx=max(mx,f[r2][0]);
        ans+=mx;
    }
}
int n;
int main()
{
    scanf("%d",&n);
    int x,y;
    for(int i=1;i<=n;i++)
     scanf("%d%d",&p[i],&x),add(i,x),add(x,i);
    for(int i=1;i<=n;i++)
    {
        if(!vis[i])//每次找到一个!vis[i], 就一定有一棵树。 
        {
            clear();
            dfs(i,-1); 
            work();
        }
    }
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：花样百出 (赞：12)

题解:

显然如果整张图没有环的话,就是一个无脑dp[u][0/1].

那么我们只需要考虑环上的一条边(u,v),分强制不选u和强制不选v两种情况,累计答案是取其中的较大值即可.

```cpp
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<queue>
#include<vector>
#include<stack>
#define MAXN 1000010
#define RG register
#define LL long long int
using namespace std;
const int INF=1e9;
const int mod=31011;
struct node{
  int next;
  int to;
}t[MAXN*2];
int head[MAXN*2],num=1;
int n;
int L[MAXN],R[MAXN],B[MAXN],tot;
LL dp[MAXN][2],val[MAXN],ans;
int vis[MAXN*2];
int fa[MAXN];
void add(int from,int to)
{
  t[++num].next=head[from];
  t[num].to=to;
  head[from]=num;
}
int find(int x)
{
  if(fa[x]!=x) fa[x]=find(fa[x]);
  return fa[x];
}
void dfs(int u,int f)
{
  dp[u][1]=val[u];dp[u][0]=0;
  for(int i=head[u];i;i=t[i].next)
    {
      int v=t[i].to;
      if(vis[i] || v==f) continue;
      dfs(v,u);
      dp[u][1]+=dp[v][0];
      dp[u][0]+=max(dp[v][0],dp[v][1]);
    }
}
int main()
{
  freopen("1.in","r",stdin);
  scanf("%d",&n);
  for(int i=1;i<=n;i++) fa[i]=i;
  int x;
  for(int i=1;i<=n;i++){
    scanf("%lld%d",&val[i],&x);add(i,x);add(x,i);
    int f1=find(i),f2=find(x);
    if(f1!=f2) fa[f2]=f1;
    else { L[++tot]=i;R[tot]=x;B[tot]=num-1;}
  }
  for(int i=1;i<=tot;i++)
    {
      vis[B[i]]=vis[B[i]^1]=1;
      dfs(L[i],0);LL ans1=dp[L[i]][0];
      dfs(R[i],0);LL ans2=dp[R[i]][0];
      ans+=max(ans1,ans2);
      vis[B[i]]=vis[B[i]^1]=0;
    }
  printf("%lld\n",ans);
  return 0;
}

```

---

## 作者：Dispwnl (赞：11)

//修补了链接和LaTeX

一看题目

这不是[没有上司的舞会](https://www.luogu.org/problemnew/show/P1352)吗……

照原来的打了代码，过了样例一交

$11$分~~竟然有分~~……

发现还是有不同的，没有上司的舞会那道题关系是棵树，而这题是有向图

所以可能存在环和多个连通块

看一下这道题[城市环路](https://www.luogu.org/problemnew/show/P1453)

把环分开

因为两个端点矛盾，所以两个端点分别$dfs$

累加每个连通块的最大值，$f_{i,1}$表示选i点，$f_{i,0}$表示不选

然后得到方程：

$f_{x,1}+=f_{son_x,0}$

$f_{x,0}+=max(f_{son_x,0},f_{son_x,1})$

别忘每次清零$f$

其实这道题就是没有上司的舞会的方程+城市环路的处理方法

代码：
```cpp
# include<iostream>
# include<cstdio>
# include<cstring>
using namespace std;
struct p{
    int x,y;
}c[1000001];
int n,num;
long long ans;
int ff[1000001];
long long fight[1000001],h[1000001];
long long f[1000001][2];
bool use[1000001];
inline long long max(long long x,long long y)
{
    return x>y?x:y;
}
inline void add(int x,int y)
{
    c[++num].x=h[x];
    c[num].y=y;
    h[x]=num;
}
inline void dfs(int x,int g)
{
    use[x]=1;
    f[x][1]=fight[x];
    f[x][0]=0;
    for(int i=h[x];i;i=c[i].x)
      if(c[i].y!=g)
      {
          dfs(c[i].y,g);
          f[x][1]+=f[c[i].y][0];
          f[x][0]+=max(f[c[i].y][0],f[c[i].y][1]);
      }
      else f[c[i].y][1]=-999999999;
}
inline void find(int x)
{
    while(!use[x])
    {
        use[x]=1;
        x=ff[x];
    }
    dfs(x,x);
    long long tt=max(f[x][1],f[x][0]);
    x=ff[x];
    dfs(x,x);
    ans+=max(tt,max(f[x][1],f[x][0]));
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
      {
          int y;
          scanf("%lld%d",&fight[i],&y);
          add(y,i);
          ff[i]=y;
      }
    for(int i=1;i<=n;i++)
      if(!use[i]) find(i);
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：Refun (赞：9)

啊终于过了……犯了一些很sb的问题(return的条件写错了调了半天GG)

基环树，一个看起来很NB的东西，满足一个神奇的性质，断开一个环的一条边，这个联通块就成了一棵树

这个题对于每个联通块，我们只需要找环然后对环上任意一边的两个点分别DP

就和没有上司的舞会一样了

注意f[截断边的一点][取]的结果可能会包含另一点，

所以我们要以两个点分别为根，在f[root][不取]的两个结果里取最大值即可 

安利博客[Refun](http://www.cnblogs.com/refun/p/8680802.html)

---

## 作者：rainygame (赞：8)

考虑按仇恨关系建立无向图，可以发现这是一个基环树森林。每个连通块都是一颗基环树。然后本题就类似基环树上“没有上司的舞会”。

那么先考虑一棵树的情况，令 $f_{i,0/1}$ 表示在 $i$ 的子树内且 $i$ 不选/选的战斗力总和，有状态转移方程：

$$
f_{u,0}=\sum\limits_{v\in s_u}\max\{f_{v,0},f_{v,1}\}
$$

$$
f_{u,1}=a_u+\sum\limits_{v\in s_u}f_{v,0}
$$

其中 $s_u$ 表示 $u$ 的儿子集合，$a_u$ 表示 $u$ 的战斗力。

对于每个连通块，考虑其**在环上**的任意两个直接相连的点 $x,y$。如果把中间这条边断开，那么它就会变成一棵树。考虑分别以 $x$ 和 $y$ 做两次树形 DP，这个连通块的答案就是第一次的 $f_{x,0}$ 和第二次的 $f_{y,0}$ 的最大值。**因为两个不能同时取，所以必定有一个不取**，要么是 $x$ 不取（$f_{x,0}$），要么是 $y$ 不取（$f_{y,0}$）。

对于找环上两个直接相连点，可以使用**并查集**。如果一次加边中发现它们本来就在一个连通块了，就把它们记下来，它们就是环上两个直接相连点。等图建完后，对记下来的点对分别求出答案，最后求和即可。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define MAXN 1000001

int n, x, s, t, ans, res;
int a[MAXN], fa[MAXN];
int f[MAXN][2];
list<pair<int, int>> cir;
list<int> e[MAXN];

int find(int x){
    if (fa[x] == x) return x;
    return fa[x] = find(fa[x]);
}

void unite(int x, int y){
    fa[find(x)] = find(y);
}

void dfs(int x, int fa){
    f[x][1] = a[x];
    f[x][0] = 0;
    for (auto i: e[x]){
        if (i ^ fa){
            dfs(i, x);
            f[x][0] += max(f[i][0], f[i][1]);
            f[x][1] += f[i][0];
        }
    }
}

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    cin >> n;
    iota(fa+1, fa+n+1, 1);
    for (int i(1); i<=n; ++i){
        cin >> a[i] >> x;
        if (find(i) == find(x)){
            cir.push_back({i, x});
            continue;
        }
        e[i].push_back(x);
        e[x].push_back(i);
        unite(i, x);
    }
    for (auto i: cir){
        dfs(i.first, 0);
        res = f[i.first][0];
        dfs(i.second, 0);
        ans += max(res, f[i.second][0]);
    }
    cout << ans << '\n';

    return 0;
}

```


---

## 作者：ModestCoder_ (赞：5)

基环树的树形dp

对于处理基环树，我本来认为只能先把树的部分处理好之后，在环上把信息综合起来，不过这题非常麻烦

基环树有另一种处理信息的方法，就是**断环**

把环找出来之后，从中间断掉他，分别以两个断点为根做树形dp，取答案大的那个累加到最终答案里

Code：

```cpp
#include <bits/stdc++.h>
#define LL long long
#define maxn 1000010
using namespace std;
struct Edge{
	int to, next;
}edge[maxn << 1];
int num, head[maxn], a[maxn], f[maxn], vis[maxn], n;
LL dp[maxn][2], ans;

inline int read(){
	int s=  0,w = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') w = -1;
	for (; isdigit(c); c = getchar()) s = (s << 1) + (s << 3) + (c ^ 48);
	return s * w;
}

void addedge(int x, int y){ edge[++num] = (Edge){y, head[x]}, head[x] = num; }

void dfs(int u, int x){
	vis[u] = 1;
	dp[u][0] = 0, dp[u][1] = a[u];
	for (int i = head[u]; i; i = edge[i].next){
		int v = edge[i].to;
		if (v != x){
			dfs(v, x);
			dp[u][0] += max(dp[v][0], dp[v][1]);
			dp[u][1] += dp[v][0];
		} else dp[v][1] = -1e9;
	}
}

void solve(int u){ 
	while (!vis[u]) vis[u] = 1, u = f[u];
	dfs(u, u);
	LL sum = max(dp[u][0], dp[u][1]);
	u = f[u];
	dfs(u, u);
	ans += max(sum, max(dp[u][0], dp[u][1]));
}

int main(){
	n = read();
	for (int i = 1; i <= n; ++i){
		a[i] = read(), f[i] = read();
		addedge(f[i], i);
	}
	for (int i = 1; i <= n; ++i)
		if (!vis[i]) solve(i);
	printf("%lld\n", ans);
	return 0;
}
```


---

## 作者：soul_M (赞：3)

看着题解写完了题，来写篇博客加深一下印象。

本蒟蒻实在太弱......居然没看出来是「没有上司的舞会」，还以为是某种二维背包......

发现是树上背包之后：

·将i的仇恨对象设置为i的fa，构造出整个图

·不难发现整个图有若干连通块，那么答案就是每个连通块内所能取到的答案之和。

·对于每个连通块（实际上就是一个「根在一个简单环」上的树）：

·做法同P1352「没有上司的舞会」。

对于一个点，她的答案（以她为根节点的最大子树和）就是：

max(「她自己的权值+她所有孙子的答案之和」，「她所有儿子的答案之和」)。

·具体来说，就是以下几点dfs时的技巧（**此处才是本题的重难点**）：



1.首先要找出该连通块的根，做法如下：从任意一个在连通块中的点x出发，不断向上跳到x的父节点，同时标记vis[x]=1;

如果一个节点被访问两次，那么说明此点在环中，而环中的任意一点都可以作为根。于是停止。

代码实现：
```cpp
    vis[x]=1;
    root=x;
    while(!vis[fa[root]]){
        root=fa[root];
        vis[root]=1;//向上,直到fa[root]已经被访问过
    }
```

2.在找到根之后：断掉根与根的父亲之间的边，从而形成一棵真正的树，否则dfs会陷入环中。

所谓断边，其实是说：**在dp时，如果遇到「u的某个儿子v是root」这种情况，就不往下dfs。**

3.更新答案的dp部分：

没什么好说的，只是要记住，要以root和fa[root]为根节点分别dp两次，取最大值。

代码实现：

```cpp
void dfs(int x){
    vis[x]=1;
    root=x;
    while(!vis[fa[root]]){
        root=fa[root];
        vis[root]=1;//找根 
    }
    dp(root);
    LL temp=max(f[root][0],f[root][1]);
    vis[root]=1;
    root=fa[root];
    dp(root);
    temp=max(temp,max(f[root][0],f[root][1]));
    ans+=temp;
    return;
}
```

嗯就这样。

**这道题并没有什么高级的知识点，而完全考验思维能力和代码实现能力，尤其是上面说的几点细节。**

~~所以本蒟蒻一想到NOIP可能会出这样的题就瑟瑟发抖QAQ~~



---

## 作者：Mcggvc (赞：3)

### 看到dalao们写的都那么简单，我就写篇详细点的把我在做这道题时遇到的问题说一下吧，也顺便加深下印象（我太弱了）



------------


首先看题，我们把每个骑士最痛恨的人设为这个士兵的父亲节点，这样就构成了一个**n**个节点**n**条边的图。为了dp，我们要把这个图处理成树，在树上搞dp。

假设整个图是联通的，这就是一棵基环树，像这样：


![](https://cdn.luogu.com.cn/upload/pic/63164.png)

我们只需要找到其中的环，把换上的一条边断开，它就变成了一棵树，搞dp的时候强制断开的边连接的两点至少有一个不选。

但是这样做显然是不行的，因为这个图不一定是联通的，所以有多个联通块。（我在做的时候就忘记考虑这种情况了，我太弱了qwq）。

每个骑士只能有一个最讨厌的人，假设一个联通块有k个节点，那么这个联通块只能有k条边，所以显然能得，每个联通块中只有一个环，由于每个骑士讨厌的人不可能是他自己，所以图中没有自环。

然后问题就解决了，我们把所有的环找出来，把每个环其中一条边断开，这样就成了一个森林，在森林中每棵树上都跑一边dp。

那么怎么dp呢？

### 定义：

```cpp
f[i][0] 为以i为根的子树，i节点不选时战斗力总和最大值；
f[i][1] 为以i为根的子树，i节点选时战斗力总和最大值。
当i节点选时，i的子节点一定不能选，所以：f[i][1]+=f[j][0];//j为i的儿子
当i节点不选时，i的子节点选不选无所谓，所以取个max：f[i][0]+=max(f[j][0],f[j][1]);	
初始化：
f[i][0]=0;
f[i][1]=valu[i];
```
### 答案：
```cpp
设断开的边的两端节点分别为x1，x2，分别以x1，x2为根节点搞dp。
ans+=max(f[x1][0],f[x2][0]);//至少有一个点不选，所以对两种情况取max
```
**其他注意事项在代码中**

### 代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <queue>
#include <stack>
#include <vector>
#define N 1000005
#define 11 long long//要开long long
using namespace std;
int head[N],nextt[N<<1],to[N<<1];
int n,cnt=1,num;
//因为需要找反边(异或)，cnt要从2开始，所以cnt=1
int fa[N],edg[N],a[N],b[N];
ll valu[N];
ll ans=0,f[N][2];
int vis[N<<1];
inline ll maxx(ll a,ll b)
{return a>b?a:b;}
inline void add(int u,int v)
{
	nextt[++cnt]=head[u];
	to[cnt]=v;head[u]=cnt;
}
inline int find(int x)
{
	while(x!=fa[x]) x=fa[x]=fa[fa[x]];
	return x;
}
inline void dp(int u,int fa)
{
	f[u][0]=0;f[u][1]=valu[u];
	for(int i=head[u];i;i=nextt[i])
	{
		int v=to[i];
		if(vis[i]||vis[i^1]||v==fa) continue;
		dp(v,u);
		f[u][1]+=f[v][0];
		f[u][0]+=maxx(f[v][0],f[v][1]);	
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++) fa[i]=i;
	for(int i=1;i<=n;i++)
	{
		int v;
		scanf("%lld%d",&valu[i],&v);
		add(i,v);add(v,i);
		int f1=find(i),f2=find(v);//并查集找环
		if(f1==f2) 
		{
			a[++num]=i;b[num]=v;//存两端点
			edg[num]=(cnt^1);//存边
		}
		else fa[f1]=f2;
	}
	for(int i=1;i<=num;i++)
	{
		vis[edg[i]]=vis[edg[i]^1]=true;//断开边
		ll tmp=0;
		dp(a[i],0);tmp=f[a[i]][0];
		dp(b[i],0);tmp=maxx(tmp,f[b[i]][0]);
		ans+=tmp;
		vis[edg[i]]=vis[edg[i]^1]=false;
	}
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：Polaris_Dane (赞：2)

很多人都提到了这道题其实和没有上司的舞会很像

本片题解主要解决为什么是这样的问题

建图方式同其他题解，也不是本题解的主要问题

有任何问题可以私信我

------------

首先DP有一个提前的要求，那就是无后效性

然而这个基环树是有环的，是会导致有后效性的

那如何去除呢

首先每棵树都是独立的，最佳答案叠加就是答案

其次断掉一条环上的边就可以变成一棵树，取消后效性

就可以像没有上司的舞会直接树形DP

但是我们要考虑另一个问题，DP必须遍历每一个可行的状态

我们在断开环上的一条边时，是否会导致失去一种情况呢？

~~答案是会的（废话）~~

比如我把（x,y）断开，选了x不选y，那么我们少了一个情况，选了y不选x

所以我们断边之后要跑两次树形DP

这是环状DP的常用技巧，先断开环DP一次

然后强制某种状态再DP一次取最大值就可以得到最大值

Talk is cheap,show you the code

```cpp
// luogu-judger-enable-o2
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<vector>
#include<stack> 
#define M 2000000
#define inf 0x3f3f3f3f
using namespace std;
vector <long long> son[M];
long long h[M],f[M][2],n,fa[M],vis[M],r;
long long ans;
inline long long read(){
	long long x=0,f=1;char s=getchar();
	while (!isdigit(s)){
		if (s=='-') f=-1;
		s=getchar();
	}
	while (isdigit(s)){
		x=(x<<1)+(x<<3)+(s^48);
		s=getchar();
	}
	return x*f;
}
void treedp(long long x)
{
	vis[x]=1;
	f[x][0]=0;
	f[x][1]=h[x];
	for (long long i=0;i<son[x].size();i++)
	{
		long long s=son[x][i];
		if (s==r){
			f[r][1]=-inf;
			continue;
		}
		treedp(s);
		f[x][0]=f[x][0]+max(f[s][0],f[s][1]);
		f[x][1]=f[x][1]+f[s][0];
	}
}
inline void dfs(long long num){
	vis[num]=1;
	r=num;
	while (!vis[fa[r]]){
		r=fa[r];
		vis[r]=1;
	}
	treedp(r);
	long long tmp=max(f[r][1],f[r][0]);
	r=fa[r];
	treedp(r);
	tmp=max(tmp,max(f[r][1],f[r][0]));
	ans+=tmp;
}
signed main(void)
{
	n=read();
	for (long long i=1;i<=n;i++)
	{
		long long x;
		h[i]=read();
		x=read();
		son[x].push_back(i);
		fa[i]=x;
	}
	for (long long i=1;i<=n;i++)
	{
		if (!vis[i])
		{
			dfs(i);
		}
	}
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：Plus_Ultra (赞：2)

分成若干个基环树和树上 $DP$,

设 $dp(u, 0)$ 表示不选 $u$ ，在子树中能取得的最大价值.

设 $dp(u, 1)$ 表示选了 $u$ ，在子树中能取得的最大价值.

对于基环树，任意选择环上一条边（$u$，$v$）断开它,就变成了树形 $DP$.

要么 $u$ 不选，要么 $v$ 不选，对应 $dp(u,0)$ 和  $dp(v,0)$ 选或不选，取个 $max$ 计入答案即可.

```
#include<iostream>

#define N 1000010
#define LL long long

using namespace std; 

int edge[N],nxt[N],head[N],tot;
int n,fight[N],fa[N],vis[N];
LL ans,f[N][2],root;

void add(int x,int y)
{
	edge[++tot]=y;
	nxt[tot]=head[x];
	head[x]=tot;
}

void DP(int x)
{
	f[x][1]=fight[x];
	f[x][0]=0;//一定要加，重新遍历时会累加 
	vis[x]=1;
	for(int i=head[x];i;i=nxt[i])
	{
		int y=edge[i];
		if(y==root) f[y][1]=-1;//y是不能选的 
		else
		{
			DP(y);//每次都需要重新遍历子树（前后可能属于不同子树）
			f[x][0]+=max(f[y][0],f[y][1]);
			f[x][1]+=f[y][0];
		}
	}
}

void dfs(int x)
{
	vis[x]=1;
	root=x;
	while(!vis[fa[root]])
	{
		root=fa[root];
		vis[root]=1;
	}
	DP(root);
	LL maxx=f[root][0];
	root=fa[root];
	DP(root);
	maxx=max(maxx,f[root][0]);
	ans+=maxx;
}

int main()
{
	cin>>n;
	for(int i=1,x;i<=n;i++)
	{
		cin>>fight[i]>>x;
		add(x,i),fa[i]=x;//边不能加反了 ,环加外向树，不然就是环加内向树（有的骑士没有被憎恨） ，处理方法不同（口胡）
	} 
	
	for(int i=1;i<=n;i++)
		if(!vis[i]) dfs(i);
		
	cout<<ans<<endl;
	
	return 0;
}
```



---

## 作者：jins3599 (赞：2)

树形$dp$好题。

模型应该是树的最大独立集，只不过这里是一个基环树森林。

我们可以对每个基环树分别处理，然后把所有的树的答案加起来。

那么我们考虑一颗基环树如何$dp$。

类似于$noip2018$旅行一题，我们可以先找环，然后断边进行$dp$，这也是基环树问题的常见做法。

但是旅行那道题是枚举每条边进行切断，然后跑$dfs$，这道题有没有必要每个点跑一次呢？

显然是没必要的，我们切断一条边后就是在对一颗无根树进行树形dp，选取任意点为根都是可以得到最优解的。

但是我们考虑到，我们断开边的两边的点是不能同时选的，也就是说他们之间肯定有一个或者两个都不选。

于是我们只需要进行两遍$dp$，一个是左边的点不选，一个是右边的点不选，取max即可。

一些小问题：

- 如何断边？

在链式前向星中，我们让$cnt$从$2$开始存边，也就是说一对无向边的编号是$2k,2k+1$，显然$2k$ ^ $1=2k+1$，$2k+1$ ^ $1=2k$，于是我们找环只需记录一个方向的边，另一个方向的边的编号就是它的编号异或1。

- 结果爆`int`

- 注意把**找环**和**染色**的标记数组分开

$Code:$（太懒了直接`#define int long long` 了...导致效率不高）

```cpp
#include <bits/stdc++.h>
#define int long long

using namespace std;

const int N = 1000000 + 10;

struct Edge {
	int to , nxt;
}e[N << 1];

int head[N] , a[N] , n , cnt = 1, ans = 0;
int g[N][2] , f[N][2];

void add(int u , int v) {
	e[++cnt].to = v;
	e[cnt].nxt = head[u];
	head[u] = cnt;
}

bool vis[N];
void color(int now , int fa) {
	vis[now] = 1;
	for(int i = head[now] ; i ; i = e[i].nxt) {
		int v = e[i].to;
		if(!vis[v] && v != fa) color(v , now);
	}
}

int go , from , E;
bool flag[N] , check;
void found(int now , int fa) {
	if(check) return;
	flag[now] = 1;
	for(int i = head[now] ; i ; i = e[i].nxt) {
		int v = e[i].to;
		if(v == fa) continue;
		if(!flag[v]) found(v , now);
		else {
			check = 1;
			go = v , from = now , E = i;
			return;
		}
	}
}

void Dp_1(int now , int fa) {
	f[now][1] = a[now];
	for(int i = head[now] ; i ; i = e[i].nxt) {
		if(i == E || (i^1) == E) continue;
		int v = e[i].to;
		if(v == fa) continue;
		Dp_1(v , now);
		f[now][0] += max(f[v][1] , f[v][0]);
		f[now][1] += f[v][0];
	}
}

void Dp_2(int now , int fa) {
	g[now][1] = a[now];
	for(int i = head[now] ; i ; i = e[i].nxt) {
		if(i == E || (i^1) == E) continue;
		int v = e[i].to;
		if(v == fa) continue;
		Dp_2(v , now);
		g[now][0] += max(g[v][1] , g[v][0]);
		g[now][1] += g[v][0];
	}
}

signed main () {
	scanf("%lld" , &n);
	for(int i = 1 ; i <= n ; ++ i) {
		int x;
		scanf("%lld %lld" , a + i , &x );
		add(i , x); add(x , i); 
		//printf("add %d -> %d\n" , x , i);
	}
	for(int i = 1 ; i <= n ; ++ i) {
		if(vis[i]) continue;
		check = 0;
		color(i , i);
		found(i , i);
		//printf("%d %d %d %d\n", go , from , E , E^1);
		Dp_1(go , go);
		Dp_2(from , from);
		ans += max(f[go][0] , g[from][0]);
	}
	printf("%lld\n" , ans);
	return 0;
}
```



---

## 作者：安好 (赞：2)

/\*
基环树森林dp

f[0][u]表示以点u为根的子树不选u点时的最大权值，f[1][u]表示以点u为根的子树必选u点时的最大权值。

无向树可以以任意一点u为根，做树形dp求最大值，其答案将保存在f[0][u]和f[1][u]中。

基环树不考虑f[1][u]的值，则答案将保存在f[0][u]中

此时，已遍历所有情况的最优值——除了必须选择点u的情况。将

需删除的边的另一端点作为根求值，此时考虑了选与不选u的情况。

同时由于不能同时选择u与v，则答案必然为可行方案的最大值

但是，实际上此图并不保证两点间一定存在至少一条路径。

综合上述情况，可以将其视作由若干基环树构成的基环树林。对每个基环树单独求解后求Σ。

\*/







```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define N 1000007
using namespace std;
int head[N],w[N],vis[N];
long long f[2][N];
int cnt=1,n,m,edge_f,edge_to,edge_cnt;
struct edge
{
    int u,to,pre;
}e[N<<1];
inline int read()
{
    int x=0,f=1;char c=getchar();
    while(c>'9'||c<'0'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    return x*f;
}
inline void add(int u,int to)
{
    e[++cnt].to=to;e[cnt].pre=head[u];head[u]=cnt;
}
void dfs(int from,int now)
{
    vis[now]=1;
    for(int i=head[now];i;i=e[i].pre)
    {
        if(e[i].to==from)continue;
        if(!vis[e[i].to]) dfs(now,e[i].to);
        else//便利到环，记录关键边 
        {
            edge_f=now;edge_to=e[i].to;
            edge_cnt=i;
        }
    }
}
void tree_dp(int root,int fa)
{
    f[0][root]=0;f[1][root]=w[root];
    for(int i=head[root];i;i=e[i].pre)
    {
        if(e[i].to==fa) continue;
        if(i==edge_cnt || i==(edge_cnt^1)) continue;
        tree_dp(e[i].to,root);
        f[0][root]+=max(f[0][e[i].to],f[1][e[i].to]);
        f[1][root]+=f[0][e[i].to];
    }
}
int main()
{
    n=read();int x;
    for(int i=1;i<=n;i++)
    {
        w[i]=read();x=read();
        add(x,i);add(i,x);
    }
    long long ans=0;
    for(int i=1;i<=n;i++)
    {
        if(vis[i])continue;
        dfs(-1,i);
        tree_dp(edge_f,-1);
        long long tmp=f[0][edge_f];
        tree_dp(edge_to,-1);
        ans+=max(tmp,f[0][edge_to]);
    }
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：wyqwq (赞：1)

## 前言

看似是个水题，但是却暗藏玄机!

果然，两个互相仇视的骑士才是屠龙最大的障碍，所以如果此题只用点来判断联通状态就会炸

## 我的心路历程

用店判断联通炸到50pts

加上一个假的边判断甚至炸到了40pts

修成边的dp没修环的判断，炸到10pts，心态崩

最后修修改改终于AC

## Solution
对于这样一个基环树，想到找到环，断开然后跑没上司的舞会，注意是森林，所以跑多次

这里可以感性证明一下环上的断点为什么要找两个不取的最大值，因为本质上我们并没有断开环上两点，所以假设断点一侧取了，断点另一侧状态我们并不清楚（正确性不能证明）。所以，一定是两个断点不取时的最大值

说到这里基本上就解决了！

如果不会最大独立集 [这边请](https://www.luogu.org/problem/P1352)

如果不会基环树，建议你去[旅行](https://www.luogu.org/problem/P5022)

## 代码
### 50pts
```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn=1000010;


long long dp[maxn][3];
struct edge{
	int next,to;
}e[maxn<<2];

int n,val[maxn],head[maxn],vis[maxn],cnt,E,x1,x2;

inline int read(){
	int f=1,x=0;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=x*10+c-'0';
		c=getchar();
	}
	return f*x;
}

inline void add(int u,int v){
	e[++cnt].next=head[u];
	e[cnt].to=v;
	head[u]=cnt;
}

void findloop(int now,int fz){
	vis[now]=1;
	for(int i=head[now];i;i=e[i].next){
		int v=e[i].to;
		if(v==fz)continue;
		if(vis[v]){
			x1=now;
			x2=v;
			E=i;
			continue;
		}
		findloop(v,now);
	}
}

void dfs(int now,int fz){
	dp[now][0]=0;
	dp[now][1]=val[now];
	for(int i=head[now];i;i=e[i].next){
		int v=e[i].to;
		if(v==fz)continue;
		if((x1==now&&x2==v)||(x2==now&&x1==v))continue;
		dfs(v,now);
		dp[now][0]+=max(dp[v][0],dp[v][1]);
		dp[now][1]+=dp[v][0];
	}
}

int main(){
	long long ans=0;
	n=read();
	for(int i=1;i<=n;i++){
		val[i]=read();
		int qwq=read();
		add(qwq,i);
		add(i,qwq);
	}
	for(int i=1;i<=n;i++){
		if(vis[i])continue;
		findloop(i,-2);
		dfs(x1,-1);
        long long temp=dp[x1][0];
        dfs(x2,-1);
        temp=max(temp,dp[x2][0]);
        ans+=temp; 
	}
	printf("%lld",ans）;
	return 0;
}
```

### 100pts
```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn=1000010;


long long dp[maxn][3];
struct edge{
	int next,to;
}e[maxn<<2];
long long ans=0;
int n,val[maxn],head[maxn],vis[maxn],cnt,E,x1,x2;

inline int read(){
	int f=1,x=0;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=x*10+c-'0';
		c=getchar();
	}
	return f*x;
}

inline void add(int u,int v){
	e[cnt].next=head[u];
	e[cnt].to=v;
	head[u]=cnt++;
}

void findloop(int now,int fz){
	vis[now]=1;
	for(int i=head[now];~i;i=e[i].next){
		int v=e[i].to;
		if((i^1)==fz)continue;
		if(vis[v]){
			x1=now;
			x2=v;
			E=i;
			continue;
		}
		findloop(v,i);
	}
}

void dfs(int now,int fz){
	dp[now][0]=0;
	dp[now][1]=val[now];
	for(int i=head[now];~i;i=e[i].next){
		int v=e[i].to;
		if ((i^1)==fz) continue;
		if(i==E ||(i^1)==E)continue;
		dfs(v,i);
		dp[now][0]+=max（dp[v][0],dp[v][1]);
		dp[now][1]+=dp[v][0];
	}
}

int main(){
	memset(head,-1,sizeof(head));
	n=read();
	for(int i=1;i<=n;i++){
		val[i]=read();
		int qwq=read();
		add(i,qwq);
		add(qwq,i);
	}
	for(int i=1;i<=n;i++){
		if(vis[i])continue;
		findloop(i,-2);
		dfs(x1,-1);
        long long temp=dp[x1][0];
        dfs(x2,-1）;
        temp=max(temp,dp[x2][0]);
        ans+=temp; 
	}
	printf("%lld",ans);
	return 0;
}
```
提醒看到最后的人：完全复制->CE->屎名

被安排的明明白白

---

## 作者：ZBHRuaRua (赞：1)

## 可以说是一道非常水的紫题（应该不能算紫题）

首先对i号点而言，从i厌恶的骑士向i连一条边。

这样显然会形成基环森林，然后我们维护一个并查集，将i号点并入其厌恶的骑士的father，这样显然每个连通块有且仅有一个点的father是自己，我们将其作为每个基环树的根节点，那么环也自然包括了根节点，直接用两次树形dp，一次是根节点不选，另一次是from[根节点]不选（from[i]含义是点i厌恶谁），然后得两者中更大者，加到ans中即可。

这样的时间复杂度是O（nlogn），虽然看上去慢，但没问题，不开O2也是稳稳过。

这道题用并查集是方便于找环（非常方便）

下面代码：（不要贪图方便全开long long，会导致不开o2过不了）
```
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<iostream>
#include<iomanip>
#include<cstring>
#include<algorithm>
using namespace std;
const int inf=1e8;
int n;
int cnt;
int from[1000050];
int ver[1000050];
int nxt[1000050];
int head[1000050];
int val[1000050];
int r;
long long F[1000050][2];
long long ans;
int root;
int baba[1000050];
inline int father(int x)
{
	if(baba[x]!=x)
	{
		baba[x]=father(baba[x]);
	}
	return baba[x];
}
inline void add(int x,int y)
{
	cnt++;
	from[y]=x;
	ver[cnt]=y;
	nxt[cnt]=head[x];
	head[x]=cnt;
}
inline void dfs(int x)
{
	F[x][0]=0;
	F[x][1]=val[x];
	if(x==r) F[x][1]=-inf;
	for(int i=head[x];i;i=nxt[i])
	{
		if(ver[i]==root) continue;
		dfs(ver[i]);
		if(x!=r)
		{
			F[x][0]+=max(F[ver[i]][1],F[ver[i]][0]);
			F[x][1]+=F[ver[i]][0];
		}
		else
		{
			F[x][0]+=max(F[ver[i]][1],F[ver[i]][0]);
		}
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		baba[i]=i;
	}
	for(int i=1;i<=n;i++)
	{
		int a,b;
		scanf("%d%d",&a,&b);
		add(b,i);
		baba[i]=father(b);
		val[i]=a;
	}
	for(int i=1;i<=n;i++)
	{
		if(father(i)==i)
		{
			root=i;
			long long tmp=0;
			r=from[i];
			dfs(i);
			tmp=max(F[i][0],F[i][1]);
			r=i;
			dfs(i);
			tmp=max(tmp,F[i][0]);
			ans+=tmp;
		}
	}
	cout<<ans<<endl;
	return 0;
} 
```


---

## 作者：SimonSu (赞：1)

从题目给的条件其实可以发现数据可以是一个基环树森林。（猜测可能数据不是 ~~没有作死去人肉试过~~）

基环树是一种图，它由一个环组成，环上每个点都是一棵树点树根，所以称为基环树。当然，一棵树上连一条边也会变成基环树。

如果本题取消条件是基环树而是一棵树，那么问题便简化为了
[没有上司的舞会](https://www.luogu.org/problemnew/show/P1352)，处理方法就是简单的树形DP。

而基环树问题重要的肯定就是断环，那么我们可以延伸思考一个问题，**一个点在树上只有选和不选两种状态**，所以可以出现一道处理方式相关的有向基环树题目 [创世纪](https://www.acwing.com/problem/content/361/) 

因为本题不需要枚举每个节点只需要环上每个节点所以可以使用并查集找环  ~~打了可持久化好写又快速~~  并查集可以说是非常重要的数据结构了 不会的快学！~~（都做骑士了都应该会吧）~~

而这道题当保证自己不选的时候儿子是随意的，所以代码会简洁一点

而本题因为是无向图，所以只需要对断边的两个节点进行，一次DP，并且记录不其节点的答案，max比较就可以了

 
本题最后一个题卡常严重 用力卡也可以过 或者…… ~~你可以开o2 或者打表~~



------------


现在贴上code【由于卡常 部分代码可能过于余赘】


```cpp
#include<iostream>
#include<stdio.h>
#include<algorithm>
#include<string.h>
#include<queue>
#include<stack>
#define LL long long
using namespace std;
const LL maxn=1000010;
inline void read(int &x){
    x=0;int f=1;char c=getchar();
    while(c>'9'||c<'0'){if(c=='-') f=-1;c=getchar();	}
    while(c>='0'&&c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar();
    x*=f;
}

struct node{
    int v,nxt;
}e[maxn<<1];
int head[maxn],tot;
inline void add(int x,int y)
{
    tot++;
    e[tot].v = y;
    e[tot].nxt = head[x];
    head[x] = tot;
}

int w[maxn],fa[maxn];
inline LL find(int x)
{
    if(x!=fa[x]) fa[x]=find(fa[x]);
    return fa[x];
}

int n,a[maxn],b[maxn],tmp,cnt,nowa;
LL f[maxn],g[maxn],tmpp;//f选 g不选

inline void dfs(LL u,LL fa)
{
    f[u]=w[u];
    g[u]=0;
    for(int i=head[u];i;i=e[i].nxt)
    {
        LL v=e[i].v;
        if(v==fa||v==nowa) continue;
        dfs(v,u);
        
		if(g[v]>f[v]) g[u]+=g[v];
        else g[u]+=f[v];//就是max 
        
		f[u]+=g[v];
    }
}
LL ans;
int main()
{
    read(n);
    for(int i=1;i<=n;i++) fa[i]=i;
    for(int i=1;i<=n;i++)
    {
        read(w[i]),read(tmp);
        if(find(tmp)!=find(i))
        {
            add(tmp,i);
            add(i,tmp);
            fa[fa[tmp]]=fa[i];
        }
        else
        {
            cnt++;
            a[cnt]=tmp;
            b[cnt]=i;
        }
    }
    for(int i=1;i<=cnt;i++)
    {
        nowa = a[i];
        dfs(a[i],0);
        tmpp = g[a[i]];
        
        nowa = b[i];
        dfs(b[i],0);
        if(tmpp>g[b[i]])
           ans+=tmpp;
        else ans+=g[b[i]];
    }
    
    printf("%lld",ans);
    return 0;
}
```


---

## 作者：Rppp (赞：1)

思想和楼下差不多，可以看一看@远航之曲。

不过没用位运算（我不会~），想起来能简单一点。

e[i].z 表示双向边其中一向边 i 对应的另一向边的序号。







```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<algorithm>
#define MAXN 1000005
#define ll long long
using namespace std;
struct rest{
    int to,next,z;
}e[MAXN*2];
int num,n,m,x,y,z,cnt;
ll ans;
int head[MAXN];
ll v[MAXN],dp[MAXN][2];
bool o[MAXN],ee[MAXN*2],ee1[MAXN*2],ee2[MAXN*2];
void add_e(int x,int y)
{
    e[++num].to=x;
    e[num].next=head[y];
    head[y]=num;
    if(num&1) e[num].z=num+1;
    else e[num].z=num-1;
}
void dfs(int h)
{
    for(int i=head[h];i;i=e[i].next)
        if(!ee[i])
        {
            if(!o[e[i].to])
            {
                o[e[i].to]=1;
                ee[i]=ee[e[i].z]=1;
                dfs(e[i].to);
            }
            else {x=h;y=e[i].to;}
        }
}
void tree2(int h)
{
    dp[h][0]=0;dp[h][1]=v[h];
    for(int i=head[h];i;i=e[i].next)
        if(ee[i]&&!ee2[i])
        {
            ee2[i]=ee2[e[i].z]=1;
            tree2(e[i].to);
            dp[h][1]+=dp[e[i].to][0];
            dp[h][0]+=max(dp[e[i].to][0],dp[e[i].to][1]);
        }
} 
void tree1(int h)
{
    dp[h][0]=0;dp[h][1]=v[h];
    for(int i=head[h];i;i=e[i].next)
        if(ee[i]&&!ee1[i])
        {
            ee1[i]=ee1[e[i].z]=1;
            tree1(e[i].to);
            dp[h][1]+=dp[e[i].to][0];
            dp[h][0]+=max(dp[e[i].to][0],dp[e[i].to][1]);
        }
} 
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        scanf("%lld%d",&v[i],&x);
        add_e(x,i);
        add_e(i,x); 
    }
    for(int i=1;i<=n;i++)
        if(!o[i])
        {
            o[i]=1;
            dfs(i);
            tree1(x);
            ll tmp=dp[x][0];
            tree2(y);
            tmp=max(dp[y][0],tmp);
            ans+=tmp;
            //ans+=max(max(dp_tree1(),v[x]),max(dp_tree2(),v[y]));
        }
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：徐致远 (赞：1)

[本蒟蒻的Blog](https://www.chnxuzhiyuan.cn/2019/04/22/%E3%80%8CZJOI2008%E3%80%8D%E9%AA%91%E5%A3%AB-Solution/)
### 题解

~~他出题人要是敢去掉一条边，我就敢做！！！~~

首先对于每一个骑士，向他最痛恨的人建一条边。

如果只有$n-1$条边的话，就是一个裸的带权的树上最大独立集。

但是由于要$n$条边，所以最后建出来的应该是一个基环内向树森林。

比如这样：

![1.png](https://www.chnxuzhiyuan.cn/images/「ZJOI2008」骑士-Solution-1.png)

对于在环上的每一个点，可以直接DP出该点选与不选时它与它的子树的最大权值和。

对于环，我们可以再来一趟DP，定义$G[i][0/1/2/3]$：

- $G[i][0]$环上第一个点可以选，第$i$个点选时的最大权值和。
- $G[i][1]$环上第一个点可以选，第$i$个点不选时的最大权值和。
- $G[i][2]$环上第一个点不可以选，第$i$个点选时的最大权值和。
- $G[i][3]$环上第一个点不可以选，第$i$个点不选时的最大权值和。

最后的答案为$max(G[n][0],G[n][2],G[n][3])$。

对于每一个环，分别DP，然后把答案加在一起即可。

复杂度：$\Theta(n)$。

### 代码

```cpp
#include<cstdio>
#include<vector>
using namespace std;
typedef long long LL;
const int maxn=1000005;
int n,A[maxn],fa[maxn],in[maxn],len,C[maxn];vector <int> so[maxn];LL ans,G[maxn][4],F[maxn][2];
inline int read()
{
	int ret=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9'){ret=ret*10+ch-'0';ch=getchar();}
	return ret*f;
}
inline void Toposort()   //拓扑排序找环+建图
{
	static int que[maxn],hed,til;
	for(int i=1;i<=n;i++)
		if(in[i]==0)
			que[++til]=i;
	while(hed!=til)
	{
		hed++;
		in[fa[que[hed]]]--;
		so[fa[que[hed]]].push_back(que[hed]);
		if(!in[fa[que[hed]]]) que[++til]=fa[que[hed]];
	}
}
void DFS(int now,int fa)
{
	F[now][1]=A[now];
	for(int i=0;i<(int)so[now].size();i++)
	{
		DFS(so[now][i],now);
		F[now][1]+=F[so[now][i]][0];
		F[now][0]+=max(F[so[now][i]][0],F[so[now][i]][1]);
	}
}
void GetCircle(int now)
{
	if(in[fa[now]]==0) return;
	C[++len]=now;
	in[fa[now]]--;
	GetCircle(fa[now]);
}
void Solve()                //对于每个环分别DP
{
	G[1][0]=F[C[1]][0];
	G[1][1]=F[C[1]][1];
	G[1][2]=F[C[1]][0];
	G[1][3]=0;
	for(int i=2;i<=len;i++)
	{
		G[i][0]=G[i][2]=F[C[i]][0];
		G[i][1]=G[i][3]=F[C[i]][1];
		G[i][0]+=max(G[i-1][0],G[i-1][1]);
		G[i][1]+=G[i-1][0];
		G[i][2]+=max(G[i-1][2],G[i-1][3]);
		G[i][3]+=G[i-1][2];
	}
	ans+=max(G[len][0],max(G[len][2],G[len][3]));
}
int main()
{
	n=read();
	for(int i=1;i<=n;i++)
	{
		A[i]=read();
		fa[i]=read();
		in[fa[i]]++;
	}
	Toposort();
	for(int i=1;i<=n;i++) if(in[i]>0) DFS(i,0);
	for(int i=1;i<=n;i++)
	{
		if(in[i]>0)
		{
			len=0;
			GetCircle(i);
			Solve();
		}
	}
	printf("%lld\n",ans);
	return 0;
}
```



---

## 作者：CreeperLordVader (赞：1)

我用的拓扑排序，好处是便于找环（拓扑排序完以后没走过的点就是环上的点）

这个代码是参考了我老师的，开始一堆BUG。。。

简单说一下思路

先存反边，从该骑士所恨的人指向该骑士

#### 拓扑排序时，从儿子向父亲跳，并用自己的儿子更新自己

### 然后我们把与环上的点相连的点的状态值（d数组）再通过DP更新至环上的点

## 因为在环上还要DP，所以我们先得再开一个g数组存d数组的原值，避免d的值被覆盖，同时也可以作为dp过程中的点权

## 然后dp两次，第一次强制要求第一个点不能选，第二次强制要求第一个点必须选，表现为将对应的d值赋值为负无穷（这样在取MAX时它就不会被考虑）

我的程序常数过大，吸了氧才过。。。（但我在LOJ上跑的挺快呀）
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int n,a[1000005];
ll d[1000005][2],g[1000005][2],ans;
int to[1000005],pa[1000005];
bool vis[1000005];
queue<int>q;
vector<int>v[1000005];
vector<int>cir;
void read(int& x)
{
	char c=getchar();
	x=0;
	while(c<'0'||c>'9')c=getchar();
	while(c>='0'&&c<='9')
	{
		x=x*10+c-'0';
		c=getchar();
	}
}
ll circle(int x)
{
	ll ans1,ans2;
	cir.clear();
	vis[x]=1;
	cir.push_back(x);
	g[x][0]=d[x][0];
	g[x][1]=d[x][1];
	for(int i=to[x];i!=x;i=to[i])
	{
		cir.push_back(i);
		vis[i]=1;
		g[i][0]=d[i][0];
		g[i][1]=d[i][1];
	}
	d[cir[0]][0]=-0x3f3f3f3f;
	d[cir[0]][1]=g[cir[0]][1];
	for(int i=1;i<cir.size();i++)
	{
		d[cir[i]][0]=g[cir[i]][0]+max(d[cir[i-1]][0],d[cir[i-1]][1]);
		d[cir[i]][1]=g[cir[i]][1]+d[cir[i-1]][0];
	}
	ans1=d[cir[cir.size()-1]][0];
	d[cir[0]][0]=g[cir[0]][0];
	d[cir[0]][1]=-0x3f3f3f3f;
	for(int i=1;i<cir.size();i++)
	{
		d[cir[i]][0]=g[cir[i]][0]+max(d[cir[i-1]][0],d[cir[i-1]][1]);
		d[cir[i]][1]=g[cir[i]][1]+d[cir[i-1]][0];
	}
	ans2=max(d[cir[cir.size()-1]][0],d[cir[cir.size()-1]][1]);
	return max(ans1,ans2);
}
int main()
{
	read(n);
	for(int i=1;i<=n;i++)
	{
		read(a[i]);
		read(to[i]);
		v[to[i]].push_back(i);
		pa[to[i]]++;
		d[i][1]=a[i];
	}
	for(int i=1;i<=n;i++)
	{
		if(!pa[i])q.push(i);
	}
	while(!q.empty())
	{
		int fa=q.front();
		q.pop();
		d[fa][1]=a[fa];
		vis[fa]=1;
		for(int i=0;i<v[fa].size();i++)
		{
			int y=v[fa][i];
			d[fa][0]+=max(d[y][0],d[y][1]);
			d[fa][1]+=d[y][0];
		}
		pa[to[fa]]--;
		if(!pa[to[fa]])q.push(to[fa]);
	}
	for(int i=1;i<=n;i++)
	{
		if(vis[i])
		{
			int fa=to[i];
			if(!vis[fa])
			{
				d[fa][0]+=max(d[i][0],d[i][1]);
				d[fa][1]+=d[i][0];
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		if(!vis[i])ans+=circle(i);
	}
	printf("%lld\n",ans);
}
```


---

## 作者：nth_element (赞：0)

希望更丰富的展示，请移步[我的博客](https://www.cnblogs.com/nth-element/p/11785016.html)

***

想要深入学习树形DP，[传送门]( https://www.cnblogs.com/nth-element/p/11714291.html )。

***

本题的DP模型同 [P1352 没有上司的舞会](https://www.luogu.org/problem/P1352)。本题的难点在于如何把基环树DP转化为普通的树上DP。

考虑断边和换根。先找到其中的一个环，在上面随意取两个点， 断开这两个点的边，使其变为一棵普通树。以其中的一点为树根做树形DP，再以另一点为树根再做一次树形DP，因为相邻的两点不能同时选，所以最后统计一下 $f(i)(0)$ 与 $g(j)(0)$ 的最大值即可。

定义 $f(i)(0/1)$ 为第一次树形DP的 $i$ 点的最优解，$g(i)(0/1)$ 为第二次树形DP的 $i$ 点的最优解。$\text{Ans} $ 为一次基环树DP的答案。$\text{E}_\text{Circle}$ 为基环树的环上的点的集合。

故一次基环树DP的答案为：
$$
\text{Ans}=\max\{f(i)(0),g(j)(0)\}
$$

$$
(i,j\in \text{E}_\text{Circle},i\neq j)
$$

下图为洛谷秋令营的课件讲解:


   <div style="text-align: center">
   <img src="https://i.loli.net/2019/10/25/Rhc1Okz4fjU3qZ7.png"/>
   </div>

关键代码如下：

   ```cpp
void covertree(int fr)//寻找基环树
{
    used[fr]=1;
    for(int i=head[fr];i;i=e[i].next)
    {
        int to=e[i].to;
        if(used[to]==0)
        {
            covertree(to);
        }
    }
}


void findcir(int fr,int fa)//寻找基环树中的环
{
    if(flag) return ;
    vis[fr]=1;
    for(int i=head[fr];i;i=e[i].next)
    {
        int to=e[i].to;
        if(vis[to]==0)
        {
            findcir(to,fr);
        }else if(to!=fa)
        {
            fri=fr;//第一个点
            toi=to;//第二个点
            E=i;//边的编号
            flag=1;
            return ;
        }
    }
}


void DPf(int fr)//以其中的一点为树根做树形DP
{
    visf[fr]=1;
    f[fr][1]=crit[fr];
    for(int i=head[fr];i;i=e[i].next)
    {
        int to=e[i].to;
        if(visf[to]==0&&(i^1)!=E)//保证不会选到第一个点和第二个点，相当于断边
        {
            DPf(to);
            f[fr][0]+=max(f[to][0],f[to][1]);
            f[fr][1]+=f[to][0];
        }
    }
}


void DPg(int fr)//再以另一点为树根再做一次树形DP
{
    visg[fr]=1;
    g[fr][1]=crit[fr];
    for(int i=head[fr];i;i=e[i].next)
    {
        int to=e[i].to;
        if(visg[to]==0&&(i^1)!=E)
        {
            DPg(to);
            g[fr][0]+=max(g[to][0],g[to][1]);
            g[fr][1]+=g[to][0];
        }
    }
}

for(int i=1;i<=n;i++)//调用+统计答案
{
    if(used[i]==1) continue;
    covertree(i);
    flag=0;
    findcir(i,-1);
    DPf(fri);
    DPg(toi);
    ans+=max(f[fri][0],g[toi][0]);
}
   ```

**特别注意**：

- 本题是基环树森林，而不是单棵基环树，故要反复寻找覆盖基环树，最后将所有答案加起来。 

- 因为要断边，所以前向星计数器 `ei `一定要初始化为 1。

   - 用多个数组标记（`used[]`,`vis[]`,`visf[]`,`visg[]`）。
   - 一定要注意 `f`,`g` 和 `fr`,`to`，不要手快打错了。

---

## 作者：ccsc (赞：0)

## 认真解题：

题目大意：n位骑士，每个人的战力可能不一样，并且每一个人都有一个厌恶对象；求组合为一个骑士团，骑士团的最大战力；

这道题，可以抽象为n个点n条边的无向图。如果我们把它想象为一个有向连通图，那问题就变得简单了起来，；着了插入一个关于基环树的概念；虽说在看的dalao应该都会……为什么要用基环树下面自然就知道了


下面我们讲解基环树：
这是普通的树：n个点n-1条边；

![](https://cdn.luogu.com.cn/upload/pic/64978.png)

这是一棵普通的基环树：
![](https://cdn.luogu.com.cn/upload/pic/65032.png)
对于基环树，我们主要分为两种：一种叫做基环内向树，另一种基环外向树；具体的区别；

基环内向树是每个点只有一条出度，如下图：

![](https://cdn.luogu.com.cn/upload/pic/65033.png)

基环外向树是每个点只有一条入度，如下图：

![](https://cdn.luogu.com.cn/upload/pic/65034.png)

这是基环树的大概定义；；

那对于这道题，，有啥用？

首先：
我们可以将骑士所仇恨的人和他自己连一条线，单向的（可以将仇恨的人指向自己，也可以自己指向仇恨的人）；两种方法都可以；

那现在我们就可以将这个问题转化为在基环外向树上找权值最大的独立集的问题；



------------



那事情就变得简单了起来，我们现在的主要问题就是：**如何找根？？**

这个问题，，朴素做法：我们对于每一个点都作为根节点，然后dp，

这是比较好想的算法，那我们可以尝试这样写一下，很慢……很慢……很慢……

对于好一点的方法：

#### 我们设f[i][0],,f[i][1];记f[v][0]为不选当前节点的最大值，f[v][1]为选择当前节点后的最大值，ans取较大者即可。

我们找到环上的一条边，把这条边中的一个点选成根进行dp，这个时候，根节点的f[root][0]一定是准确的，但是f[rt][1]是不准确的，我们必须强制这条边的另一个点不选，然后将这个状态走环一圈，再用来更新f[rt][1] 


由于每个点的仇恨的人向自己连一条边，那么入度必然是1，我们可以直连单向边，然后记录指向自己的人作为父亲，每个点顺着父亲走必然可以走到环上

大概应该就是这样
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N=1000100;
struct pp{
	int next,to;
}a[N];
int head[N],fa[N];ll s[N],n,tot,ans,f[N][2];
bool v[N],v1[N];

void add(int x,int y){
	a[++tot].next=head[x];
	a[tot].to=y;
	head[x]=tot;
	fa[y]=x;
}

void ss(int x){
	v[x]=1;
	f[x][1]=s[x];
	for(int i=head[x];i;i=a[i].next){
		if(v[a[i].to]==0){
			ss(a[i].to);
			f[x][0]+=max(f[a[i].to][1],f[a[i].to][0]);
			f[x][1]+=f[a[i].to][0];
		}
	}
}

void dp(ll x){
	int root;
	for(root=x;v1[root]==0;root=fa[root]){       //寻找环，该循环会在有环的情况下--退出；^ ^ 
		v1[root]=1;//标记一下 
	}//cout<<root<<endl;
	ss(root);
    x=fa[root];//cout<<x<<endl;
	f[x][1]=f[x][0];
	for(x=fa[x];x!=root;x=fa[x]){
		f[x][1]=s[x];
		f[x][0]=0;
		for(int j=head[x];j;j=a[j].next){
			f[x][1]+=f[a[j].to][0];
			f[x][0]+=max(f[a[j].to][1],f[a[j].to][0]); 
		}
	}//cout<<f[root][1]<<" "<<f[root][0]<<endl;
	f[root][1]=s[root];
	for(int i=head[root];i;i=a[i].next){
		f[root][1]+=f[a[i].to][0];
	}//cout<<f[root][1]<<endl;
	ans+=max(f[root][1],f[root][0]);
	
}

int main()
{
	scanf("%lld",&n);
	ll q;
	for(int i=1;i<=n;i++){
		scanf("%lld%lld",&s[i],&q);
		add(q,i);
		//cout<<q<<"-->"<<i<<endl;
	}
	for(int i=1;i<=n;i++){
		if(v[i]==0)dp(i);
	}
	printf("%lld",ans);
	return 0;
 } 
```


---

## 作者：Phoenix030821 (赞：0)

## NOIP初赛后一道题压压惊~

#### 这是一道环套外向树的题，多个树的根节点组成一个环，这个图便叫环套树

先dfs找环，将环上每一个点进行标记

对于每一棵树，从树根（即环上每一个点）开始进行DP：
```
void trdp(int i){
    vis[i]=1;f[i][1]=w[i];fl[i]=1;
    for(int x=head[i];x;x=p[x].nxt){
        if((!vis[p[x].to])&&(!isr[p[x].to])){
            trdp(p[x].to);
            f[i][0]+=max(f[p[x].to][1],f[p[x].to][0]);
            f[i][1]+=f[p[x].to][0];
        }
    }
}
```
类似于 没有上司的舞会

之后再用一个环形DP，先强制第一个点不选，对于之后的每一个树根节点进行DP:
```
g[root[1]][0]=f[root[1]][0];g[root[1]][1]=0;
for(int x=2;x<=m;x++){
	g[root[x]][0]=max(g[root[x-1]][1],g[root[x-1]][0])+f[root[x]][0];g[root[x]][1]=g[root[x-1]][0]+f[root[x]][1];
 }
long long ans=max(g[root[m]][1],g[root[m]][0]);
```
之后再取消强制再DP一遍:
```
g[root[1]][0]=f[root[1]][0];g[root[1]][1]=f[root[1]][1];
for(int x=2;x<=m;x++){
	g[root[x]][0]=max(g[root[x-1]][1],g[root[x-1]][0])+f[root[x]][0];g[root[x]][1]=g[root[x-1]][0]+f[root[x]][1];
}
ans=max(ans,g[root[m]][0]);tot+=ans;
```

对于二元环的处置，我在每一条边的结构体上都加了一个变量，即这个边对应的反边是那条，只要判断一下有没有搜过，就可以避免二元环的问题。

（注意不只一个环套树，图不一定联通，从1节点不断搜）

c++代码如下：

```
#include<bits/stdc++.h>
using namespace std;
struct shit{
    int to,nxt,ep;//ep即为对应的反边
}p[2000100];
int n,m,num,w[1000100],head[1000100],root[1000100],t,nx[1000100];
long long g[1000100][2],f[1000100][2],tot;
bool vis[1000100],isr[1000100],fl[1000100];
void add(int from,int to){
    p[++num].to=to;
    p[num].nxt=head[from];
    head[from]=num;
}
void dfs(int las,int i){
    for(int x=head[i];x;x=p[x].nxt){
        if(root[1])return;
        if(!vis[p[x].to]){
            vis[p[x].to]=1;nx[i]=p[x].to;
            dfs(x,p[x].to);vis[p[x].to]=0;
        }
        if(vis[p[x].to]&&(p[x].ep!=las)){int q=p[x].to;
        	nx[i]=q;
            for(int y=q;;y=nx[y]){
                root[++m]=y;isr[y]=1;//进行标记
                if(nx[y]==q)break;
            }
        }
    }
}
void trdp(int i){
    vis[i]=1;f[i][1]=w[i];fl[i]=1;
    for(int x=head[i];x;x=p[x].nxt){
        if((!vis[p[x].to])&&(!isr[p[x].to])){
            trdp(p[x].to);
            f[i][0]+=max(f[p[x].to][1],f[p[x].to][0]);
            f[i][1]+=f[p[x].to][0];
        }
    }
}
int main(){
    scanf("%d",&n);
    for(int x=1;x<=n;x++)scanf("%d%d",&w[x],&t),add(x,t),p[num].ep=num+1,add(t,x),p[num].ep=num-1;
    for(int x=1;x<=n;x++){
    	if(!fl[x]){
    		dfs(0,x);memset(vis,0,sizeof(vis));
    		for(int x=1;x<=m;x++)trdp(root[x]);
    		g[root[1]][0]=f[root[1]][0];g[root[1]][1]=0;
    		for(int x=2;x<=m;x++){
        	    g[root[x]][0]=max(g[root[x-1]][1],g[root[x-1]][0])+f[root[x]][0];g[root[x]][1]=g[root[x-1]][0]+f[root[x]][1];
        	}long long ans=max(g[root[m]][1],g[root[m]][0]);
        	memset(g,0,sizeof(g));
        	g[root[1]][0]=f[root[1]][0];g[root[1]][1]=f[root[1]][1];
        	for(int x=2;x<=m;x++){
        	    g[root[x]][0]=max(g[root[x-1]][1],g[root[x-1]][0])+f[root[x]][0];g[root[x]][1]=g[root[x-1]][0]+f[root[x]][1];
        	}ans=max(ans,g[root[m]][0]);tot+=ans;	
        	for(int x=1;x<=m;x++)root[x]=0;m=0;
    	}
    }
    cout<<tot;
    return 0;
}  //机房的大佬们都在吐槽我for变量用x,y,函数传值传i,j的码风
```


---

## 作者：Biscuit46 (赞：0)

# 题面
[原题](https://www.lydsy.com/JudgeOnline/problem.php?id=1040)

# Solution
一开始我想着贪心,但是贪心是错误的,因为可能很多人都仇恨一个人但是仇恨的这个人的权值最大.

所以我们考虑,如果两个点不在一个仇恨集合里面,显然不会互相影响.

那么就可以对于每一个集合树形DP,然后累加答案

```cpp
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<math.h>
#include<algorithm>
#include<iostream>
#include<queue>
#define re register
#define ll long long
using namespace std;
inline int gi(){
    int f=1,sum=0;char ch=getchar();
    while(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0' && ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}
    return f*sum;
}
struct node{
    int val,heat;
    bool operator<(const node b)const{
        return val>b.val;
    }
}Knight[1000010];
int front[1000010],cnt=1,x1,x2,E;
struct edge{
    int to,nxt;
}e[2000010];
void Add(int u,int v){
    e[++cnt]=(edge){v,front[u]};front[u]=cnt;
}
ll ans,dp[1000010][2];
int vis[1000010],n;
void find(int u,int fa){
    vis[u]=1;
    for(re int i=front[u];i;i=e[i].nxt){
        int v=e[i].to;
        if(v==fa)continue;
        if(vis[v]){
            x1=u;x2=v;E=i;continue;
        }
        find(v,u);
    }
}
void dfs(int u,int fa){
//  printf("%d %d\n",u,fa);
    dp[u][0]=0;dp[u][1]=Knight[u].val;
    for(re int i=front[u];i;i=e[i].nxt){
        int v=e[i].to;
        if(v==fa)continue;
        if(i==E || (i^1)==E)continue;
        dfs(v,u);
        dp[u][0]+=max(dp[v][1],dp[v][0]);
        dp[u][1]+=dp[v][0];
    }
}
int main(){
    n=gi();
    for(re int i=1;i<=n;i++){
        Knight[i].val=gi();
        Knight[i].heat=gi();
        Add(i,Knight[i].heat);
        Add(Knight[i].heat,i);
    }
    for(re int i=1;i<=n;i++)
        if(!vis[i]){
            find(i,i);
            dfs(x1,x1);
            ll tmp=dp[x1][0];
            dfs(x2,x2);
            tmp=max(tmp,dp[x2][0]);
            ans+=tmp;
        }
    printf("%lld\n",ans);
    return 0;
}
```

---


# [NOIP 2016 提高组] 愤怒的小鸟

## 题目背景

NOIP2016 提高组 D2T3

## 题目描述

Kiana 最近沉迷于一款神奇的游戏无法自拔。

简单来说，这款游戏是在一个平面上进行的。

有一架弹弓位于 $(0,0)$ 处，每次 Kiana 可以用它向第一象限发射一只红色的小鸟，小鸟们的飞行轨迹均为形如 $y=ax^2+bx$ 的曲线，其中 $a,b$ 是 Kiana 指定的参数，且必须满足 $a < 0$，$a,b$ 都是实数。

当小鸟落回地面（即 $x$ 轴）时，它就会瞬间消失。

在游戏的某个关卡里，平面的第一象限中有 $n$ 只绿色的小猪，其中第 $i$ 只小猪所在的坐标为 $\left(x_i,y_i \right)$。

如果某只小鸟的飞行轨迹经过了 $\left( x_i, y_i \right)$，那么第 $i$ 只小猪就会被消灭掉，同时小鸟将会沿着原先的轨迹继续飞行；

如果一只小鸟的飞行轨迹没有经过 $\left( x_i, y_i \right)$，那么这只小鸟飞行的全过程就不会对第 $i$ 只小猪产生任何影响。

例如，若两只小猪分别位于 $(1,3)$ 和 $(3,3)$，Kiana 可以选择发射一只飞行轨迹为 $y=-x^2+4x$ 的小鸟，这样两只小猪就会被这只小鸟一起消灭。

而这个游戏的目的，就是通过发射小鸟消灭所有的小猪。

这款神奇游戏的每个关卡对 Kiana 来说都很难，所以 Kiana 还输入了一些神秘的指令，使得自己能更轻松地完成这个游戏。这些指令将在【输入格式】中详述。

假设这款游戏一共有 $T$ 个关卡，现在 Kiana 想知道，对于每一个关卡，至少需要发射多少只小鸟才能消灭所有的小猪。由于她不会算，所以希望由你告诉她。

## 说明/提示

【样例解释1】

这组数据中一共有两个关卡。

第一个关卡与【问题描述】中的情形相同，$2$ 只小猪分别位于 $(1.00,3.00)$ 和 $(3.00,3.00)$，只需发射一只飞行轨迹为 $y = -x^2 + 4x$ 的小鸟即可消灭它们。

第二个关卡中有 $5$ 只小猪，但经过观察我们可以发现它们的坐标都在抛物线 $y = -x^2 + 6x$上，故 Kiana 只需要发射一只小鸟即可消灭所有小猪。

【数据范围】

| 测试点编号 |   $n\leqslant$ |   $m=$ |  $T\leqslant$ |
| :----------: | :----------: | :----------: | :----------: |
|   $1$ |   $2$ |   $0$ |  $10$ |
|   $2$ |   $2$ |   $0$ |  $30$ |
|   $3$ |   $3$ |   $0$ |  $10$ |
|   $4$ |   $3$ |   $0$ |  $30$ |
|   $5$ |   $4$ |   $0$ |  $10$ |
|   $6$ |   $4$ |   $0$ |  $30$ |
|   $7$ |   $5$ |   $0$ |  $10$ |
|   $8$ |   $6$ |   $0$ |  $10$ |
|   $9$ |   $7$ |   $0$ |  $10$ |
|   $10$ |   $8$ |   $0$ |  $10$ |
|   $11$ |   $9$ |   $0$ |  $30$ |
|   $12$ |   $10$ |   $0$ |  $30$ |
|   $13$ |   $12$ |   $1$ |  $30$ |
|   $14$ |   $12$ |   $2$ |  $30$ |
|   $15$ |   $15$ |   $0$ |  $15$ |
|   $16$ |   $15$ |   $1$ |  $15$ |
|   $17$ |   $15$ |   $2$ |  $15$ |
|   $18$ |   $18$ |   $0$ |  $5$ |
|   $19$ |   $18$ |   $1$ |  $5$ |
|   $20$ |   $18$ |   $2$ |  $5$ |

## 样例 #1

### 输入

```
2
2 0
1.00 3.00
3.00 3.00
5 2
1.00 5.00
2.00 8.00
3.00 9.00
4.00 8.00
5.00 5.00```

### 输出

```
1
1```

## 样例 #2

### 输入

```
3
2 0
1.41 2.00
1.73 3.00
3 0
1.11 1.41
2.34 1.79
2.98 1.49
5 0
2.72 2.72
2.72 3.14
3.14 2.72
3.14 3.14
5.00 5.00```

### 输出

```
2
2
3
```

## 样例 #3

### 输入

```
1
10 0
7.16 6.28
2.02 0.38
8.33 7.78
7.68 2.09
7.46 7.86
5.77 7.44
8.24 6.72
4.42 5.11
5.42 7.79
8.15 4.99```

### 输出

```
6
```

# 题解

## 作者：AThousandSuns (赞：1136)

### upd on 2019.1.29：

感谢@老QB 和@小梁 的提醒，似乎数组是得开大一点……

表示很抱歉，现在才看到这条消息……

---
### 前言：
我好像在已有的题解中看到的都是 $O(T\text{玄学})$ 的暴搜和 $O(Tn^22^n)$ 的状压。

暴搜如果数据强一点就过不了了，$O(Tn^22^n)$ 的状压在考场也只有75分。

在此发一篇严格 $O(Tn2^n)$ 的完全严谨正解。

（感谢[这篇博客](https://www.cnblogs.com/Sakits/p/6440722.html)让我会了这种状压）

---
### 设计dp状态：
$n\le 18$？不是暴搜就是状压。

$dp[S]$ 表示已经死了的猪的集合状态为 $S$ 时最少要发射的鸟数。

明显有
- $dp[0]=0$
- $dp[S|line[i][j]]=\min(dp[S]+1)$
- $dp[S|(1<<(i-1)]=\min(dp[S]+1)$


其中 $line[i][j]$ 表示经过 $i,j$ 两点的抛物线能经过的所有点的集合。

这就是网上大多流传的 $O(Tn^22^n)$ 算法。优化？

---
### 优化1：
发现当 $i\in S$ 或者 $j\in S$ 时**没有必要转移**。

证明：
- 若这条线只经过至多三个点，因为其中一个点已被打到，所以可以通过另外两个点的状态转移。如果 $i,j$ 都被打到，则可以通过转移3（单独一个点）转移。
- 若这条线经过多于三个点，则可以通过其它任选两个点转移。

但是这只能算是常数优化。

---
### 优化2：
若令 $x$ 为满足 $S\&(1<<(x-1))=0$ 的最小正整数，则由 $S$ 扩展的转移的**所有线都要经过 $x$。**

为什么？这个是对的吗？不经过 $x$ 就会慢吗？

你想一想，先打 $1,4$，再打 $2,3$，和先打 $2,3$，再打 $1,4$ 是不是一样的？

如果这一次转移不打 $x$，那以后还要再回过头来打 $x$。这就是多余的转移。

因为经过 $x$ 的线数量是 $n$，所以每次转移涉及到的线就从 $n^2$ 变成了 $n$。

只要预处理一下 $0-2^{18}$ 的对应的 $x$ 就能做到 $O(Tn2^n)$ 了，这才是考场的正解。

似乎比暴搜还快一点~

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const double eps=1e-8;
int t,n,m,lines[20][20],lowunbit[1<<20],dp[1<<20];	//lowunbit就是题解中的x
double x[20],y[20];
void equation(double &x,double &y,double a1,double b1,double c1,double a2,double b2,double c2){	//解方程
	y=(a1*c2-a2*c1)/(a1*b2-a2*b1);
	x=(c1-b1*y)/a1;
}
int main(){
	for(int i=0;i<(1<<18);i++){	//预处理lowunbit
		int j=1;
		for(;j<=18 && i&(1<<(j-1));j++);
		lowunbit[i]=j;
	}
	scanf("%d",&t);
	while(t--){
		memset(lines,0,sizeof(lines));	//各种初始化
		memset(dp,0x3f,sizeof(dp));
		dp[0]=0;
		scanf("%d%d",&n,&m);
		for(int i=1;i<=n;i++) scanf("%lf%lf",x+i,y+i);
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++){	//处理所有抛物线
				if(fabs(x[i]-x[j])<eps) continue;	//x坐标相同，不可能有解
				double a,b;
				equation(a,b,x[i]*x[i],x[i],y[i],x[j]*x[j],x[j],y[j]);
				if(a>-eps) continue;	//解出a和b
				for(int k=1;k<=n;k++)
					if(fabs(a*x[k]*x[k]+b*x[k]-y[k])<eps) lines[i][j]|=(1<<(k-1));
			}
		for(int i=0;i<(1<<n);i++){	//重点！状压开始！
			int j=lowunbit[i];	//必须经过lowunbit这个点
			dp[i|(1<<(j-1))]=min(dp[i|(1<<(j-1))],dp[i]+1);	//单独转移
			for(int k=1;k<=n;k++) dp[i|lines[j][k]]=min(dp[i|lines[j][k]],dp[i]+1);	//所有经过lowunbit的抛物线
		}
		printf("%d\n",dp[(1<<n)-1]);	//答案
	}
}
```

---

## 作者：wzxx (赞：497)

```cpp
/*思路：搜索。
对于第i只猪，如果它已经被前面所构造的某条抛物线经过了，
就不用处理了，继续往下搜索。否则，就有两种选择，第一种
是与前面某一只单独的猪（即这只猪未与其它猪组成抛物线）
组成抛物线，因为两只猪最多也只能被一条抛物线相连；第二
种是暂时不与其它单独的猪组成抛物线。最后，将抛物线的条
数与余下的猪的个数相加（因为单独的一只猪也要一条抛物线
将其击中）就是搜索出来的一个合法的结果。*/ 
#include<iostream>
#include<cstdio>
#include<fstream>
#include<algorithm>
#include<string>
#include<sstream>
#include<cstring>
#include<cmath>
	using namespace std;
	const double eps=1e-8;
/*因为浮点数的精度计算太过复杂，像3.14这样的数存在浮
点型变量里存的可能是3.139999999，也有可能是3.140000001，
所以不能直接用“==”判断两个浮点数是否相等。在这种情况
下，就允许判断两个浮点数为相等时，两数之间存在微小的误差，
这个“微小的误差”要取一个较小的数，比如1e-8，这样就不
会判不出也不会误判了。*/
bool dy(double a,double b)//判断两个浮点数是否相等的函数 
{
	//如果a和b之间相差的值小于eps（即1e-8），就说明它们是相等的 
	return fabs(a-b)<eps;//fabs用于取浮点数的绝对值 
}
	int n=0,m=0,ans=0;
	//x数组存每只猪的x坐标，y数组存每只猪的y坐标
	//pwxa数组存每条已构造的抛物线的参数a，pwxb数组存每条已构造的抛物线的参数b
	//tx数组存每只单独的猪的x坐标，ty数组存每只单独的猪的y坐标 
	double x[20],y[20],pwxa[20],pwxb[20],tx[20],ty[20];
//dfs(c,u,v)表示当前搜到第c只猪，已构造抛物线的数量为u，单独的猪的数量为v时的情况 
//注意：当前抛物线的总数量为(u+v)条，因为除已有的抛物线外，每一只单独的猪也需要一条抛物线来击中它 
void dfs(int c,int u,int v)
{
	//最优性剪枝，因为即使后面的每一只猪都被当前已构造的抛物线击中， 
	//或者与其它单独的猪组成抛物线，抛物线的总数量还是(u+v)，不会减少，
	//所以如果抛物线的总数量已经大于等于当前的最优解时，搜下去也不会
	//比当前更优了，就不用继续搜下去了。
	if(u+v>=ans) return;
	if(c>n)//如果搜完了 
	{
		ans=u+v;//记录答案，因为前面已经有最优性剪枝了，所以没被剪掉的答案一定比当前更优 
		return;//结束 
	}
	bool flag=false;//记录是否被已构造的抛物线经过 
	for(int i=1;i<=u;i++)//枚举已构造的抛物线 
		//将这一条抛物线的参数与当前猪的x坐标带进函数解析式算一遍，
		//如果结果等于当前猪的y坐标，就说明当前猪已经被已构造的抛物线经过了 
		if(dy(pwxa[i]*x[c]*x[c]+pwxb[i]*x[c],y[c]))
		{
			dfs(c+1,u,v);//被经过了就直接往下搜 
			flag=true;//记录 
			break;//退出循环，既然当前猪已经被经过了，再继续判断也没有意义了
		}
	if(!flag)//如果没有被经过 
	{
		for(int i=1;i<=v;i++)//枚举单独的猪 
		{
			//如果当前猪与这一只单独的猪的x坐标相同，就说明它们不能组成一条
			//抛物线。因为若想使它们组成一条抛物线，弹弓的位置就必须是它们的正下
			//方，然后往上垂直发射，但是弹弓的位置固定在(0,0)，而猪的x坐标又大于
			//0（题目数据范围），所以它们不能组成一条抛物线。如果不加这个判
			//断的话就会计算出一些奇奇怪怪的东西，影响后面的判断，所以还是加上为好。 
			if(dy(x[c],tx[i])) continue;//如果当前猪与这一只单独的猪的x坐标相同，跳过这一次循环
			//求参数a、b的过程实际上就是解一个二元一次方程组，比如说有两只猪的坐标分别是(1,3)和(3,3)， 
			//现在要求出它们所组成的抛物线的参数a与参数b。将两只猪的坐标分别代入到函数解析式中，
			//就可以得出一个方程组： 3=a+b  3=9a+3b 。这是，我们可以用加减消元法消掉b，将两个方程
			//分别乘上另一个方程的b的系数，得：9=3a+3b 3=9a+3b。这样，两个方程中的b的系数就一致了，
			//然后直接用一个式子减去另一个式子，再将a的系数化为一即可。最后再将a带入到回任意一个方程求b即可。
			//因为这里的所有方程都长一个样，所以这一种方法是通用的。 
			double a=(y[c]*tx[i]-ty[i]*x[c])/(x[c]*x[c]*tx[i]-tx[i]*tx[i]*x[c]);//求参数a 
			double b=(y[c]-x[c]*x[c]*a)/x[c];//将a代入求参数b 
			if(a<0)//如果这一个解是合法的，就说明当前猪与这一只单独的猪可以组成抛物线 
			{	
				pwxa[u+1]=a;//记录抛物线的参数a 
				pwxb[u+1]=b;//记录抛物线的参数b
				//将这一只单独的猪从数组中删去，因为它已经和当前猪组成抛物线，不再单独了 
				double q=tx[i],w=ty[i];
				for(int j=i;j<v;j++)
				{
					tx[j]=tx[j+1];
					ty[j]=ty[j+1];
				}
				dfs(c+1,u+1,v-1);//继续往下搜
				//将这一只单独的猪放回数组（回溯） 
				for(int j=v;j>i;j--) 
				{
					tx[j]=tx[j-1];
					ty[j]=ty[j-1];
				}
				tx[i]=q;
				ty[i]=w;
			}
		}
		//还有一种选择：暂时不与其它猪组成抛物线 
		tx[v+1]=x[c];
		ty[v+1]=y[c];
		dfs(c+1,u,v+1);//继续往下搜 
	}
}
int main()
{
	int T=0;
	scanf("%d",&T);
	for(int Q=1;Q<=T;Q++)
	{
		scanf("%d%d",&n,&m);
		for(int i=1;i<=n;i++) scanf("%lf%lf",&x[i],&y[i]);
		ans=100;//记得初始化 
		dfs(1,0,0);//搜 
		printf("%d\n",ans); 
	} 
	return 0;//完美地结束 
}
```

---

## 作者：JustinRochester (赞：57)

[题目](https://www.luogu.org/problemnew/show/P2831)

我的天，这题是真的卡精度......

主要是精度很不好处理，经本蒟蒻测验，精度在$10^{-6}$会比较好~~优雅~~

---

**【分析】**
--

对于这种某个变量特别小$(\leq 31)$的题目，本蒟蒻第一反应就是状压

对于某个抛物线，一定要打到起码一个小猪(不然不如不要这一条抛物线)

有人觉得最少会打掉两只小猪的，可以仔细想一下，万一$a \geq 0$呢......

好的，我们继续

那么，我们可以这么考虑，枚举每一只小猪的坐标

首先，有一条抛物线是只过它的

其次，再枚举其他小猪，算出抛物线方程(见下方)，若$a<0$就记录这条抛物线，否则可以直接跳出

记录完这条抛物线后，我们枚举其他的小猪，查看是否在线上

这里要注意精度问题，如果计算出来的$y$与题目所给的$y$偏差值不超过$10^{-6}$，就直接视为同一个值(毕竟计算是有一定的精度问题)

那么对于接下来，我已经预处理过了所有的小鸟的轨迹(抛物线)，只需要在状压方程中直接算就可以了

在打$0$只小猪的时候，需要用$0$只小鸟，于是有:

$dp[0]=0$

假设当前状态为$i$，抛物线为第$j$条，抛物线打掉的小猪状态为$para[j]$，那么有：

$dp[i|para[j]]=min(dp[i|para[j]],dp[i]+1)$

---

接下来我们说一下怎么求$a$和$b$:

假设枚举到两个小猪，坐标分别为$(x_1,y_1)$和$(x_2,y_2)$，那么就对应地会有：

$\begin{cases} y_1=ax_1^2+bx_1\\ \\y_2=ax_2^2+bx_2\end{cases}$

这里有一个很明显的矩阵关系：

$\left[\begin{matrix}\ y_1\ \\ \\y_2\end{matrix}\right]=\left[\begin{matrix}\ x_1^2&x_1\ \\ \\x_2^2&x_2\end{matrix}\right]\times\left[\begin{matrix}\ a\ \\ \\b\end{matrix}\right]$

于是有：

$\left[\begin{matrix}\ a\ \\ \\b\end{matrix}\right]=\left[\begin{matrix}\ x_1^2&x_1\ \\ \\x_2^2&x_2\end{matrix}\right]^{-1}\times\left[\begin{matrix}\ y_1\ \\ \\y_2\end{matrix}\right]$

又因为：

$\left|\begin{matrix}\ x_1^2&x_1\\ \\x_2^2&x_2\end{matrix}\right|=x_1^2x_2-x_1x_2^2=(x_1-x_2)x_1x_2$

所以有：

$\left[\begin{matrix}\ x_1^2&x_1\ \\  \\ x_2^2&x_2\end{matrix}\right]^{-1}=\frac{1}{(x_1-x_2)x_1x_2}\left[\begin{matrix}\ x_2&-x_1\ \\ \\-x_2^2&x_1^2\end{matrix}\right]$

(逆矩阵的求法)

所以有：

$\left[\begin{matrix}\ a\ \\ \\b\end{matrix}\right]={1\over(x_1-x_2)x_1x_2}\left[\begin{matrix}\ x_2&-x_1\ \\ \\-x_2^2&x_1^2\end{matrix}\right]\times\left[\begin{matrix}\ y_1\ \\ \\y_2\end{matrix}\right]$

即：

$\begin{cases}a={1\over(x_1-x_2)x_1x_2}\times(x_2y_1-x_1y_2)\\ \\b={1\over(x_1-x_2)x_1x_2}\times(x_1^2y_2-x_2^2y_1)\end{cases}$

---

还有一件事

我们对于抛物线，在后面枚举状态的时候是不需要知道除了能打的小猪以外的所有信息

所以直接维护这个信息就可以了，其他都没有必要维护

这个众位大犇可以直接一下本蒟蒻的代码

---

**【代码】**

那本蒟蒻就放代码了：

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
#define min(a,b) ((a<b)?a:b)
inline void built(double &a,double &b,double x1,double y1,double x2,double y2){
    a=(x2*y1-x1*y2)/(x1*x2*(x1-x2));
    b=(x1*x1*y2-x2*x2*y1)/(x1*x2*(x1-x2));
}//计算a,b 
inline bool inc(double a,double b,double x,double y){
	double abs=a*x*x+b*x-y;
	if(abs<0) abs=-abs;
	return abs<=0.000001;
}//判定某个小猪是否在抛物线上 
inline int read(){
	int ans=0;char c=getchar();bool neg=0;
	while((c<'0')|(c>'9')) { neg^=!(c^'-'); c=getchar(); }
	while((c>='0')&(c<='9')) { ans=(ans<<3)+(ans<<1)+c-'0'; c=getchar(); }
	return neg?-ans:ans;
}//无聊的读入优化 
int n,para[200],dp[1<<18],countpara;
inline void pre(){
	memset(dp,0x3f,sizeof(dp));
	countpara=0;
	double x[18]={0},y[18]={0};
	n=read();read();
	for(int i=0;i<n;i++) scanf("%lf %lf",&x[i],&y[i]);
	//dp定义为无限大，抛物线的条数清空，读入 
	for(int i=0;i<n;i++){
		para[countpara++]=(1<<i);
		//只打一只小猪的 
		for(int j=i+1,vis=0;j<n;j++)//定义vis表示打到过的小猪，避免重复枚举 
			if((vis>>j)&1) continue;
			else{
				double a,b;
				built(a,b,x[i],y[i],x[j],y[j]);
				if(a>=0) continue;
				para[countpara]=(1<<i);
				for(int k=j;k<n;k++)//枚举小猪，查看是否在线上 
					if(inc(a,b,x[k],y[k])){
						vis|=(1<<k);
						para[countpara]|=(1<<k);
					}
				countpara++;
			}
	}
}
inline int ans(){//状压 
	dp[0]=0;
	for(int i=0;i<(1<<n);i++)
		for(int j=0;j<countpara;j++)
			dp[i|para[j]]=min(dp[i|para[j]],dp[i]+1);
	return dp[(1<<n)-1];
}
int main(){
	int t=read();
	while(t--){
		pre();//先皮一下 
		printf("%d\n",ans()); 
	}
	return 0;
}
```

最后安利一下 [本蒟蒻的博客](https://www.luogu.org/blog/JustinRochester/)

---

## 作者：ghj1222 (赞：27)

愤怒的小鸟

由于最多只有18只猪，所以我们会考虑到安全透彻清真人品的状压dp。

我们令`f[k]`表示当前的状态为k所需要的最小的抛物线数，其中k是压缩后的状态，其中k的第i位为1表示第i个小猪被消灭掉了，为0表示没有消灭掉。初始状态为`f[0]=0`，最终状态为`f[(1<<n)-1]`

然后说转移，我们枚举所有的抛物线。首先对于一个抛物线，他如果一个猪都没消灭掉，他一定是不用被考虑的。并且平面上的三点确定一条抛物线，我们知道了原点和两只小猪的坐标就可以确定这条抛物线了。

所以我们枚举每一对猪，计算过原点和这两只猪的抛物线是谁。注意要特判两点，如果这两只猪的横坐标相同(根本就无法算出一个合法的抛物线啊)，或者是抛物线的$a>0$，那么我们就扔掉。抛物线的计算很简单：

假如两个猪的坐标为$(x_1,y_1)$和$(x_2,y_2)$，那么我们设抛物线为$y=ax^2+bx$，带入得到$\left\{\begin{aligned}y_1=ax_1^2+bx_1(1)\\y_2=ax_2^2+bx_2(2)\end{aligned}\right.$，把$(2)$式除以$x_2$得到$\begin{aligned}\frac{y_2}{x_2}=ax_2+b(3)\end{aligned}$，再乘以$x_1$得到$\begin{aligned}\frac{y_2x_1}{x_2}=ax_1x_2+bx_1(4)\end{aligned}$。用$(1)-(4)$得到$\begin{aligned}y_1-\frac{y_2x_1}{x_2}=a(x_1^2-x_1x_2)(5)\end{aligned}$，系数化1，得到$\begin{aligned}a=\frac{y_1-\begin{aligned}\frac{y_2x_1}{x_2}\end{aligned}}{x_1^2-x_1x_2}=\frac{y_1-\begin{aligned}\frac{y_2x_1}{x_2}\end{aligned}}{x_1(x_1-x_2)}\end{aligned}$。$b$的推的过程类似，这里就省略了。大体思路就是消元。我们需要求$a$就把$b$通过加减消元法消去，既然我们现在要求$b$了那么就要把$a$加减消元法消去了，这里我直接给出$b$的公式为$\begin{aligned}b=\frac{\begin{aligned}\frac{y_1x_2^2}{x_1^2}-y_2\end{aligned}}{\begin{aligned}\frac{x_2^2}{x_1}-x_2\end{aligned}}\end{aligned}$

观察后我们发现当且仅当$x_1=x_2$时候$a$和$b$无解。至于$a$和0的关系我们可以求出来再判断啊。。。

然后我们每求出一条抛物线，我们就把所有猪带入抛物线，看看这个抛物线能经过哪些猪，既然是状压dp，我们就用一个数字表示这个抛物线经过哪些猪，其中如果这个数字二进制第i位是1，表示这个抛物线经过第i个猪

然后我们按照数字大小从小到大枚举所有状态，再用所有的抛物线去~~轰炸~~这个状态，假设这个状态为k，这个抛物线能消灭的猪是st，那么用这个抛物线消灭之后变成的状态就是`k|st`，其中`|`是按位或运算。dp方程为`f[k|st]=min(f[k|st],f[k]+1)`。

对于某些猪他的位置很特殊，他不能和任何其它的猪组成满足$a<0$的抛物线，但是我们一定能够构造出一条抛物线把它打掉，所以我们在枚举所有状态的过程中需要在内层循环枚举所有猪，让一条抛物线只打这一只猪看看能更新成什么样子。

最后`f[(1<<n)-1]`就是答案

为什么我们要从小到大枚举状态呢，因为对于一个状态，他所有能达到的状态一定$\ge$他，(不难发现)

注意实数误差

代码

```cpp
#include <bits/stdc++.h>
#define eps 1e-6
using namespace std;

int t, n, m, top;//top代表当前找到多少抛物线
int f[524300], st[400];//f的大小是一个略大于(1<<18)的数，注意数组大小不要开到2的整数次幂否则会慢 st[i]表示第i条抛物线能打的猪的状态
double x[20], y[20];//猪的坐标


int main()
{
	scanf("%d", &t);
	while (t--)
	{
		scanf("%d%d", &n, &m);
		int maxn = (1 << n) - 1;
		memset(f, 0x3f, sizeof(f));
		memset(st, 0, sizeof(st));
		top = 0;
		f[0] = 0;
		for (int i = 1; i <= n; i++)
			scanf("%lf%lf", &x[i], &y[i]);
        
        //寻找所有抛物线
		for (int i = 1; i <= n; i++)
			for (int j = i + 1; j <= n; j++)
			{
				if (x[i] != x[j])
				{
					double ta = (y[i] - y[j] * x[i] / x[j]) / x[i] / (x[i] - x[j]);
					double tb = (y[i] * x[j] * x[j] / x[i] / x[i] - y[j]) / (x[j] * x[j] / x[i] - x[j]);
					if (ta < 0)
					{
						top++;
                        //枚举哪些猪能被抛物覅打掉
						for(int k = 1; k <= n; k++)
							if(fabs(ta * x[k] * x[k] + tb * x[k] - y[k]) <= eps)
								st[top] |= (1 << (k - 1));
					}
				}
			}
        
        //从小到大枚举所有状态
		for (int k = 0; k <= maxn; k++)
		{
			for (int i = 1; i <= top; i++)
				f[k | st[i]] = min(f[k | st[i]], f[k] + 1);
			for (int i = 1; i <= n; i++)
				f[k | (1 << (i - 1))] = min(f[k | (1 << (i - 1))], f[k] + 1);
		}
		printf("%d\n", f[maxn]);
	}
	return 0;
}

```

---

## 作者：saxiy (赞：11)

看到这鸡肋的数据范围就知道这道题是状压DP了。

看好多题解打的记搜，其实这题不用记搜也能跑很快。

#### 先分析题目

大家应该都玩过《愤怒的小鸟》这款游戏，所以题面很好理解。一只鸟打出抛物线去杀猪。看看我们状压的板子：

```cpp
void dp() {
	f[0] = 0;
	int maxx = (1 << n) - 1;
	for(int i = 0;i < maxx;i++)//总问题的子状态
		for(int j = 0;j < cnt;j++)//解决方案数
			if(f[i | act[j]] > f[i] + cost[j])
				f[i | act[j]] = f[i] + cost[j];//状态转移
}
```

这里我们的解决方案是什么呢？肯定是小鸟呀！

众所周知，三个点确定一条抛物线，除去起点$(0,0)$，每一对猪的坐标都可以确定一条抛物线，因为经过$(0,0)$，所以它可以表示成$y=ax^{2}+bx$，已知我们现在枚举的这对猪坐标为$(x_{1},y_{1}),(x_{2},y_{2})$，可以解出：

$$\begin{cases}a=\dfrac{x_{2}y_{1}-x_{1}y_{2}}{x_{1}x_{2}(x_{1}-x_{2})}\\ \\b=\dfrac{x_{2}^{2}y_{1}-x_{1}^{2}y_{2}}{x_{1}x_{2}^{2}-x_{1}^{2}x_{2}}\end{cases}$$

然后遍历所有猪的坐标，如果带入上式$y=ax^{2}+bx$符合的话就加入这个解决方案的集合。当然我们也可以一只猪一只猪地打，所以最后还要加入$n$种单独打猪的方案。

最后的解决方案里可能有重复，利用$STL$的$unique$函数去重即可，注意$unique$函数使用的前提是数组有序，要先进行排序，当然也可以用一个 $vis$ 数组存已加入的方案 ~~(才不是我懒得初始化)~~ 。

还要注意的一点是$double$型的判等不能单纯的使用$==$，因为在计算的时候总会丧失一些精度，所以要确定在一个可以容纳的范围内取等，比如：

```cpp
const double eps = 1e-6;
bool cmp(double a, double b) {
	return a - eps < b && b < a + eps;
}
```

作为判等的依据。

在经过去重后我们方案总数不会超过$n^{2}+n$，所以时间复杂度是 $O(Tn^{2}2^{n})$，但基本不会跑满。就算不考虑其他的优化也是跑的比较快的（当然时间复杂度不是一个档次就没法比了）。

最后是代码实现的问题，这里带来两种实现，一种普通DP，一种BFS，因为这道题的特殊性（无论哪种方案都消耗一只鸟），所以可以使用BFS，~~否则就用Dijkstra吧！~~

#### 代码实现：

```cpp
#pragma GCC optimize("Ofast,fast-math,unroll-loops")
#include <bits/stdc++.h>
using namespace std;

int n, m, f[1 << 18], act[405], cnt;
double x[20], y[20], a, b;

inline double pow2(double x) { return x * x; }

void getab(int p1, int p2) {
	a = (y[p1] - y[p2] * x[p1] / x[p2]) / (x[p1] * (x[p1] - x[p2]));
	b = (y[p1] - pow2(x[p1]) * y[p2] / pow2(x[p2])) / (x[p1] - pow2(x[p1]) / x[p2]);
}

const double eps = 1e-6;
bool cmp(double a, double b) {
	return a - eps < b && b < a + eps;
}

inline bool isin(int k) {
	return cmp(a * pow2(x[k]) + b * x[k], y[k]);
}

void init() {
	//方式1：
	memset(f, 0x7f, sizeof(f));
	//方式2：
	memset(f, -1, sizeof(f));
	/--------------------------
	memset(act, 0, sizeof(act));
	cnt = 0;
}
```
#### 实现方式1(500ms in total)：
```cpp
void dp() {
	f[0] = 0;
	int maxx = (1 << n) - 1;
	for(int i = 0;i < maxx;i++)
		for(int j = 0;j < cnt;j++)
			if(f[i | act[j]] > f[i] + 1)
				f[i | act[j]] = f[i] + 1;
}
```
#### 实现方式2(524ms in total)：
```cpp
void bfs() {
	int maxx = (1 << n) - 1;
	queue <int> q;
	q.push(f[0] = 0);
	while(q.size()) {
		int p = q.front(); q.pop();
		for(int i = 0;i < cnt;i++)
			if(!~f[p | act[i]]) {
				f[p | act[i]] = f[p] + 1;
				if((p | act[i]) == maxx) return;
				q.push(p | act[i]);
			}
	}
}
```
#### --------------------------------
```cpp
int main() {
	int T;
	scanf("%d", &T);
	while(T--) {
		scanf("%d%d", &n, &m);
		if(!n) { puts("0"); continue; }
		init();
		for(int i = 0;i < n;i++)
			scanf("%lf%lf", x + i, y + i);
		for(int i = 1;i < n;i++)
			for(int j = 0;j < i;j++) {
				getab(i, j);
				if(a > 0 || cmp(a, 0)) continue;
				for(int k = 0;k < n;k++)
					if(isin(k)) act[cnt] |= 1 << k;
				cnt++;
			}
		for(int i = 0;i < n;i++)
			act[cnt++] = 1 << i;
		sort(act, act + cnt);
		cnt = unique(act, act + cnt) - act;
		//方式1：
		dp();
		//方式2：
		bfs();
		//------
		printf("%d\n", f[(1 << n) - 1]);
	}
	return 0;
}
```

---

## 作者：Demoe (赞：6)

### [题目传送门](https://www.luogu.com.cn/problem/P2831)

## 前置知识

抛物线（数学人教版八年级），状压DP。

## 简述题意

- 有n个猪，你可以从原点引出抛物线，问最少用多少次可以打到所有猪。

## 简述做法

- 预处理所有有效抛物线。

- 以猪有没有被打下来作为状态进行状压DP。

## 预处理

我们对每个猪进行一次遍历，每次对序号在他**后面**的猪进行遍历，对于**之前没有**的抛物线我们新保存一次。

对于抛物线 $y=ax^2+bx+c$。已知经过原点，所以 $c=0$。

我们又另知抛物线经过两点 $(x_i,y_i)$ $(x_j,y_j)$。

可算出 $a=\dfrac{x_jy_i-x_iy_j}{x_ix_j(x_i-x_j)}$， $b=\dfrac{x_ix_iy_j-x_jx_jy_i}{x_ix_j(x_i-x_j)}$、

```cpp
		for(ll i=0;i<n;i++){
			line[cnt++]=(1<<i);
			for(ll j=i+1,use=0;j<n;j++)
				if((use>>j)&1) continue;
				else{
					ld a=(x[j]*y[i]-x[i]*y[j])/(x[i]*x[j]*(x[i]-x[j])),b=(x[i]*x[i]*y[j]-x[j]*x[j]*y[i])/(x[i]*x[j]*(x[i]-x[j]));
					if(a>=0) continue;
					line[cnt]=(1<<i);
					for(ll k=j;k<n;k++) 
						if(ab(a*x[k]*x[k]+b*x[k]-y[k])<=eps) use|=(1<<k),line[cnt]|=(1<<k);
					cnt++;
				}
		}
```


# 状压DP

因为 $n \le 18$，所以很容易想到状压DP。

我们定义 $f_s$ 为打到 $s$ 的状态时**最少**的次数。

对于**每个抛物线**，可易得**转移方程** $f_{i|line_j}=min{f_{i|line_j},f_i+1}$。

### 不要忘记 $f_0=1$。

```cpp
		for(ll i=0;i<(1<<n);i++)
			for(ll j=0;j<cnt;j++)
				f[i|line[j]]=min(f[i|line[j]],f[i]+1);
```

## 总结

本题运用基本数学知识和基本状压DP，偏**模板**型（还给了很多**部分分**）。

```cpp
/*
***
还要继续努力
成为一名烤咕学家哦
***
*/
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef long double ld;
const ll N=20;
ll n,T,line[200],f[1<<N],cnt,op;
ld x[N],y[N],eps=1e-6;
template <typename T> inline void rd(T &x){
	ll fl=1;x=0;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') fl=-fl;
	for(;isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+c-'0';
	x*=fl;
}
void wr(ll x){
	if(x<0) x=-x,putchar('-');
	if(x<10) putchar(x+'0');
	if(x>9) wr(x/10),putchar(x%10+'0');
}
inline ld ab(ld x){
	return x>=0.00?x:-x;
}
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	rd(T);
	while(T--){
		memset(f,0x3f3f3f3f,sizeof(f));cnt=0;
		rd(n);rd(op);
		for(ll i=0;i<n;i++) scanf("%llf %llf",&x[i],&y[i]);
		for(ll i=0;i<n;i++){
			line[cnt++]=(1<<i);
			for(ll j=i+1,use=0;j<n;j++)
				if((use>>j)&1) continue;
				else{
					ld a=(x[j]*y[i]-x[i]*y[j])/(x[i]*x[j]*(x[i]-x[j])),b=(x[i]*x[i]*y[j]-x[j]*x[j]*y[i])/(x[i]*x[j]*(x[i]-x[j]));
					if(a>=0) continue;
					line[cnt]=(1<<i);
					for(ll k=j;k<n;k++) 
						if(ab(a*x[k]*x[k]+b*x[k]-y[k])<=eps) use|=(1<<k),line[cnt]|=(1<<k);
					cnt++;
				}
		}
		f[0]=0;
		for(ll i=0;i<(1<<n);i++)
			for(ll j=0;j<cnt;j++)
				f[i|line[j]]=min(f[i|line[j]],f[i]+1);
		wr(f[(1<<n)-1]);puts(""); 
	}
	return 0;
}
```


---

## 作者：shadowice1984 (赞：3)

存在性dp可解还很好写。

显然如果一种情况存在的话，那么随便开一炮的情况还是存在。

那么由此可以定义dp[i][j]表示开了i炮现在的情况是j

j为一个二进制下有意义的数，j的第k位为0表示这头猪已经被干掉。

dp[i][j]是一个bool，true表示i和j的情况存在。

那么我们每次转移是枚举每个可能的炮弹，

显然所有炮的可能性是固定的，所以预处理一下就ok了

还要特判一下只打一头猪的情况。

***************************

下面是预处理的环节

枚举任意两头猪，然后待定系数法解出a，b

之后枚举每一个点，判定是否可以被打到

最后输出的数是一个二进制数，表示这一炮可以打到

那几个猪，这样转移时&一下就好了

上代码~

```cpp
#include<stdio.h>
#include<algorithm>
#include<cmath>
using namespace std;
bool dp[20][270000];//存在性数组
bool vis[270000];
int shot[410];int cnt;
int n;int m;int t;int up;
double x[20];double y[20];
const double eps=1e-10; //误差容忍量一定要小
void shoot(int t1,int t2)
{
    //printf("shot %d %d\n",t1,t2);
    double x1=x[t1];double x2=x[t2];double y1=y[t1];double y2=y[t2];
    double a=(y1*x2-y2*x1)/(x1*x2*(x1-x2));
    if(a>-eps)//不合法的抛物线
    {
        return;
    }
    shot[++cnt]=up-1;//新建抛物线
    double b=y1/x1-a*x1;
    for(int i=0;i<n;i++)
    {
        double t=a*x[i]*x[i]+b*x[i];
        if(y[i]-eps<t&&t<y[i]+eps)
        {
            shot[cnt]&=(~(1<<i));//爆掉这头^(*￣(oo)￣)^
        }
    }
    if(vis[shot[cnt]])cnt--;
    else vis[shot[cnt]]=true;//去重，加速
    //printf("shot(%d %d)=%d\n",t1,t2,shot[cnt]);
    return ;
}
void work()
{
    scanf("%d%d",&n,&m);
    for(int i=0;i<n;i++)
    {
        scanf("%lf%lf",&x[i],&y[i]);
    }
    up=pow(2,n);cnt=0;
    for(int i=0;i<up;i++)//初始化去重数组
    {
        vis[i]=false;
    }
    for(int t1=0;t1<n;t1++)//预处理抛物线
    {
        for(int t2=0;t2<t1;t2++)//t1，t2，与t2，t1是等价的，只用枚举一次
        {
            shoot(t1,t2);
        }
    }
    for(int i=0;i<=n;i++)//初始化dp数组
    {
        for(int j=0;j<up;j++)
        {
            dp[i][j]=false;
        }
    }
    dp[0][up-1]=true;//边界条件，一炮不开的情况
    for(int i=0;i<=n;i++)
    {
        for(int j=0;j<up;j++)
        {
            if(dp[i][j])//如果存在
            {
                //printf("dp[%d][%d]=true\n",i,j);
                for(int t1=0;t1<n;t1++)
                {
                    int q=(j&(~(1<<t1)));//特判只打一头^(*￣(oo)￣)^的情况
                    if(q==0)//第一个合法一定是最小
                    {
                        printf("%d\n",i+1);
                        return;
                        }
                    //printf("->dp[%d][%d]=true\n",i+1,q);
                    dp[i+1][q]=true;
                }
                for(int k=1;k<=cnt;k++)//枚举抛物线
                {
                    int p=shot[k]&j;
                    if(p==0)
                    {
                        printf("%d\n",i+1);
                        return;
                    }
                    if(p!=j)//防止射空炮ε=ε=ε=(~￣▽￣)~
                    {
                        //printf("->%d:dp[%d][%d]=true\n",k,i+1,p);
                        dp[i+1][p]=true;
                    }
                }
            }
        }
    }
    return;
}
int main()
{
    scanf("%d",&t);
    for(int i=0;i<t;i++)
    {
        work();
    }
    return 0;//拜拜程序~
}
```

---

## 作者：NewbieZZZ (赞：2)

前置知识：

- 状态压缩 DP
- 二次函数知识

### 题意简述

> 给定 $n$ 个平面直角坐标系上的点。你可以从原点引出解析式为 $y = ax^2+bx(a<0)$ 的抛物线，问最少引出多少条这样的抛物线，能使得所有给定的点都在这些抛物线上。

### 具体思路

注意到 $n\le18$、$0<x_i,y_i<10$，一切数据范围都指向了搜索和状态压缩 dp。\
这里考虑使用状压 dp 求解。

#### dp 部分

设 $dp_{state}$ 表示达到点被覆盖的状态为 $state$ 时所需要的最少抛物线数。其中 $state$ 的第 $i$ 位为 $1$ 表示第 $i$ 个点已经被经过了，为 $0$ 则反之。答案即为 $dp_{2^n-1}$。

这里我们可以先简化一下题目。我们可以假设所有可以覆盖到点的抛物线已经被求出，经过的点集（经过状压）存储在 $line$ 数组中。\
（其中，$line_i$ 表示第 $i$ 条抛物线经过点的状态。$line_i$ 的第 $i$ 位为 $1$ 表示第 $i$ 个点被这条线经过，为 $0$ 则反之。）

那么我们可以顺推，枚举每一种可能的点被经过的状态 $i$，再枚举每条可能的抛物线 $j$ 去经过更多点（或者重复了，没有经过新的点）。如果有收益，则使用这条线去更新状态。即：

$$dp_{i \operatorname{or} line_j} = \min(dp_i+1, dp_{i \operatorname{or} line_j})$$

但是，有些时候一些点可能无法与原点和另一个点确定一条符合题意的抛物线，却可以直接用一条抛物线去经过这个点。所以，我们还要枚举每一个点（设此点为第 $j$ 个点），专门用一条线去经过。这条线的状态为 ${\underbrace{1000\dots0_{(2)}}_{\scriptsize j\text{ 位}}}$，也就是 $2^{j-1}$。即：

$$dp_{i \operatorname{or} 2^{j-1}} = \min(dp_i+1, dp_{i \operatorname{or} 2^{j-1}})$$

两者分开转移即可。

不过，如果基于这种做法，是要求出 $line$ 数组的值的。

#### 预处理部分

众所周知，同一平面的三个点可以确定一条抛物线。（本题有了原点，就只用两个点了）\
所以我们可以枚举每一对点，计算过原点和这两只猪的抛物线的解析式。

不过，我们总不能直接丢一个方程给程序去算吧（~~是计算器的话当我没说~~）。所以，我们需要推出 $a$ 和 $b$ 关于 $(x_1,y_1),(x_2,y_2)$ 的式子。

[又到了喜闻乐见的推柿子环节](https://www.luogu.com.cn/paste/ot4bb279)。

这里直接给出结论，过程见云剪贴板：

$$a =  \dfrac{y_1x_2 - y_2x_1}{x_1x_2(x_1-x_2)},b = \dfrac{y_2}{x_2} - ax_2$$

如果 $a>0$，或者这两点的横坐标相同（$x_1=x_2$ 时，分母为 $0$），那么这条抛物线不合法，不统计。

对于每条合法的抛物线，枚举给定的每个点 $k$，并代入函数解析式中。如果经过，就将代表这个点的这一位数设为 $1$。

最后 dp 一下就可以了。回答单次询问的时间复杂度为 $O(n2^n)$，可过。

最后的最后，由于处理 $line$ 数组的时候涉及浮点数运算，难免会有误差，所以不能直接用等于号判等。当两个浮点数的差的绝对值小于一个很小的正数时（这里我用了 $10^{-6}$），我们可以直接认为二者相等。

### 代码

```cpp
#include <iostream>
using namespace std;
using ll = long long;
//#define debug cout << "fnmdp"

int dp[262200]; // dp_s 表示点（猪猪）被穿过的情况为 s
int T, n, m, line[10010], cnt;
double xx[20], yy[20];
const double eps = 1e-6;

int main(){
    cin.tie(0) −> sync_with_stdio(0);
    cin >> T;
    while(T −−){
        memset(line, 0, sizeof line);
        memset(dp, 0x66, sizeof dp); // 多测必初始化！！！
        cin >> n >> m;
        for(int i=1; i<=n; ++i){
            cin >> xx[i] >> yy[i];
        }
        for(int i=1; i<=n; ++i){
            // line_i 表示第 i 个函数图像覆盖点的情况
            for(int j=i+1; j<=n; ++j){
                if(xx[i] != xx[j]){
                    double a = (yy[i] − yy[j] * xx[i] / xx[j]) / xx[i] / (xx[i] − xx[j]);
                    double b = yy[j] / xx[j] − a * xx[j];
                    if(a < 0){
                        ++ cnt;
                        for(int k=1; k<=n; ++k){ // 算出解析式后重新枚举
                            if(fabs(a * xx[k] * xx[k] + b * xx[k] − yy[k]) <= eps){
                                line[cnt] |= (1 << (k−1));
                            }
                        }
                    }
                }
            }
        }
        dp[0] = 0;
        for(int i=0; i<(1<<n); ++i){ // dp_i 单调不降，从小到大枚举状态数字
            for(int j=1; j<=cnt; ++j){
                dp[i | (line[j])] = min(dp[i] + 1, dp[i | (line[j])]);
            } // 用一条线覆盖 / 维持原样
            for(int j=1; j<=n; ++j){
                dp[i | (1 << j-1)] = min(dp[i] + 1, dp[i | (1 << j-1)]);
            }
        }
        cout << dp[(1<<n) − 1] << '\n';
    }
    return 0;
}
```

已防抄袭，请勿直接 Copy。

感谢所有审核大大们！\
End.

---

## 作者：chrispang (赞：2)

一般抛物线方程：$ y = ax^2 + bx + c $。

题目中的抛物线有两个特点：
1. 过原点，即 $ c = 0 $。
2. 开口向下，即 $ a < 0 $。

因此抛物线方程为：$ y = ax^2 + bx $，有两个未知数，因此两点即可确定一条抛物线。

方程中有两个参数 $ a $ 和 $ b $，因此我们可以用具体两个点的坐标来唯一的确定一条抛物线。

参数的计算公式如下：

$$
\begin{cases}
y_1 = ax_1^2 + bx_1 \\
y_2 = ax_2^2 + bx_2
\end{cases}
\quad \Rightarrow \quad
\begin{cases}
a = \frac{\frac{y_1}{x_1} - \frac{y_2}{x_2}}{x_1 - x_2} \\
b = \frac{y_1}{x_1} - ax_1
\end{cases}
$$
因此最多有 $ n^2 $ 个不同的抛物线。接下来求出所有不同的抛物线，及其能覆盖的所有点的点集。

此时问题变成了经典的“重复覆盖问题”，即给定 01 矩阵，要求选择尽量少的行，将所有列覆盖住。这里标准做法是使用 Dancing Links。

但由于 $ n\le 18 $，因此可以直接使用状态压缩 DP 求解，代码更简单。

$f_i$ 表示当前已经覆盖的列的状态是 $ i $ 需要最少的抛物线的数量。

转移时随便找到当前未被覆盖的某一列 $ x $，然后枚举所有包含 $ x $ 的行 $ j $ 来选择即可。

即：$f_{i | j} = \min\{f_i + 1\}$。

预处理时需要枚举所有点对来确定抛物线，然后枚举其余点是否在抛物线上，初始状态是 $f_0=0$，总的计算量是 $ O(n^3) $。

最后的答案需要计算最后的状态，即所有小猪都被打到了的最少方案 $f_{2^n-1}$。

状态压缩 DP 的过程中，一共有 $ 2^n $ 个状态，每个状态需要 $ O(n) $ 的计算量，因此每个关卡需花费的时间复杂度是 $ O(n^3 + n2^n) $，总时间复杂度是 $ O(T(n^3 + n2^n)) $。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 20, M = 1 << N;
const double eps = 1e-8;
int n, m, T;
struct node {
    double x, y; //存下每只小猪的坐标
} ver[N];
int path[N][N], f[M]; //path[i][j]表示小猪 i 与小猪 j 的抛物线能覆盖的小猪数量，f[i]如上文分析
int cmp(double a, double b) { //比较大小
    if (fabs(a - b) < eps) return 0;
    if (a > b) return 1;
    return -1;
}

void init() { //初始化
    memset(path, 0, sizeof(path));
    for (int i = 0; i < n; i++) {
        path[i][i] = 1 << i; //自己到自己的抛物线只能覆盖自己
        for (int j = 0; j < n; j++) {
            double x1 = ver[i].x, y1 = ver[i].y;
            double x2 = ver[j].x, y2 = ver[j].y;
            if (!cmp(x1, x2)) continue;  //单独一个点无法生成参数a,b的抛物线
            double a = (y1 / x1 - y2 / x2) / (x1 - x2); //套用公式，算出 a,b
            double b = (y1 / x1) - a * x1;
            if (cmp(a, 0.0) >= 0) continue; //a必须小于0
            //参数a,b的抛物线已生成，枚举他经过的所有点
            for (int k = 0; k < n; k++) {
                double x = ver[k].x, y = ver[k].y;
                if (!cmp(y, a * x * x + b * x)) path[i][j] += 1 << k; //如果包含进了当前枚举到的抛物线，则放入点集
            }
        }
    }
}

void solve() {
    cin >> n >> m;
    for (int i = 0; i < n; i++) cin >> ver[i].x >> ver[i].y;
    init(); //初始化
    memset(f, 0x3f, sizeof(f));
    f[0] = 0; //DP 初始化
    for (int cur_st = 0; cur_st + 1 < (1 << n); cur_st++) { //枚举每一种状态
        int t = -1;
        for (int i = 0; i < n; i++)
            if (!(cur_st >> i & 1)) //如果不包含这个小猪，则选择这个小猪待会用来更新 DP
                t = i;
        for (int i = 0; i < n; i++) {
            int ne_st = path[t][i] | cur_st; //抛物线&当前状态后的点集
            f[ne_st] = min(f[ne_st], f[cur_st] + 1); //DP 更新
        }
    }
    cout << f[(1 << n) - 1] << endl; //答案
}

int main() {
    cin >> T;
    while (T--) solve();
    return 0;
}
```

---

## 作者：kunkun127 (赞：2)

## 思路

状压 DP 入门好题，我们可以一步一步进行优化，以求最优解。

- 前置知识

  1. [位运算的不同符号](https://oi-wiki.org/math/bit/)，对于我们认识、学习、掌握状压起到很大作用。
  2. 主角[状压 DP](https://oi-wiki.org/dp/state/)，旨在压缩空间。
  3. 抛物线，也就是下文的解方程函数所解。
     
- 题意

  在一个平面直角坐标系上，点 $(0, 0)$ 处有一个弹弓，给 $n$ 个小猪坐标，求至少多少只小鸟消灭所有小猪。

  个人认为，题目给的 $m$ 主要是暴力时用到，没什么用。

  本题核心问题就是：一条抛物线可以打到若干只小猪，求至少需要多少条抛物线。

- DP 状态

  对于这种 $n \le 18$ 的题目，此篇题解仅考虑正解状压。

  令 $f_S$ 表示被消灭的猪集合状态为 $S$。首先，对于 $f_0$，也就是消灭 $0$ 只猪，明显是需要 $0$ 只鸟的。故 $f_0 = 0$。

  另外，令此时状态为 $i$，抛物线为第 $j$ 条，故被抛物线打掉的小猪状态为 $l_{j}$，则有

   $$f_{i|l_j} = \min(f_{i|l_j}, f_i + 1)$$

- 计算抛物线

  先对每个猪进行一次遍历，每次再对它后面的猪进行遍历，没有就保存。

  那么如何求抛物线呢？有

  $$y = ax^2 + bx + c$$

  此时经过原点，也就是 $c = 0$。

  再经过计算，我们解出

  $$a = \frac{x_jy_i - x_iy_j}{x_ix_j(x_i - x_j)}$$

  $$b = \frac{x_ix_iy_j - x_jx_jy_i}{x_ix_j(x_i - x_j)}$$

  结合上面，我们得出解方程的函数
  ```cpp
  void func(double &a, double &b, Birds x, Birds y)
  {
	b = ((x.x * x.x) * y.y - (y.x * y.x) * x.y) / ((x.x * x.x) * y.x - (y.x * y.x) * x.x);
	a = (x.y - x.x * b) / (x.x * x.x);
	return ;
  }
    ```
因此，我们便将其综合起来，得出本题代码。

## 注意事项

- 多测清空
- 精度判断

## 参考代码


```cpp
#include <bits/stdc++.h>
#define hyh using
#define love namespace
#define lsq std
hyh love lsq;
const int hyh_lover = 647;
const int MAXN = (1 << 20);
const double eps = 1e-8;
int dp[MAXN], p[20][20], f[MAXN];

struct Birds
{
	double x, y;
	void read() { cin >> x >> y; }
} a[20];

void mem()//多测清空
{
	memset(dp, 0x3f, sizeof(dp));
	dp[0] = 0;
	memset(p, 0, sizeof(p));
	return ;
} 

void init()//初始化
{
	int N = (1 << 18) - 1;
	for (int i = 0; i <= N; i++)
	{
		int t = 1;
		while (t <= 18 && (i & (1 << (t - 1)))) t++;
		f[i] = t;
	}
	return ;
}

void func(double &a, double &b, Birds x, Birds y)//解方程
{
	b = ((x.x * x.x) * y.y - (y.x * y.x) * x.y) / ((x.x * x.x) * y.x - (y.x * y.x) * x.x);
	a = (x.y - x.x * b) / (x.x * x.x);
	return ;
}

void solve()
{
	int n, m;
	cin >> n >> m;
	int N = (1 << n) - 1;
	for (int i = 1; i <= n; i++) a[i].read();
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= n; j++)
		{
			if (abs(a[i].x - a[j].x) >= eps)
			{
				double _a, _b;
				func(_a, _b, a[i], a[j]);
				if (_a <= -eps)//精度！
				{
					for (int k = 1; k <= n; k++)
					{
						if (abs(_a * a[k].x * a[k].x + _b * a[k].x - a[k].y) < eps) p[i][j] |= (1 << (k - 1));
					}
				}
				
			}
		} 
	}
	for (int i = 0; i <= N; i++)//状压主体
	{
		int t = f[i];
		dp[i | (1 << (t - 1))] = min(dp[i] + 1, dp[i | (1 << (t - 1))]);
		for (int j = 1; j <= n; j++) dp[i | p[t][j]] = min(dp[i] + 1, dp[i | p[t][j]]);
	}
	cout << dp[N] << endl;
	return ;
}

int main()
{
	init();
	int t;
	cin >> t;
	while (t--)
	{
		mem();
		solve();
	}
	return !(hyh_lover == 647);
}
```

---

## 作者：f_K_e1207 (赞：2)

纪念一下第一道自己做出来的蓝题。

状态压缩动态规划，是动态规划中较为复杂的一种，在状压 dp 中，我们使用一个 $n$ 位 $k$ 进制数（不一定是二进制，但是二进制最为常用）表示状态集合，便于记录状态集合的详细信息，但是该种动态规划一般没有多项式时间的算法，简单的状压 dp 思路可以参考[P10447](https://www.luogu.com.cn/problem/P10447)或著名的旅行商问题。

状压 dp 好题，~~不过数据略水~~。简化一下题意，就是给定平面上的一些点，求用经过这些点的所需的最少抛物线数量，是一个重复覆盖问题。

~~直觉告诉我们这是 dp，数据范围告诉我们是状压 dp。~~

分析题意，注意到平面中的点被抛物线覆盖的最优情况，即已经求解的子问题，不会受后续抛物线选取的影响，所以该问题具有**无后效性**。下一个点覆盖的情况也可以通过前面已经求解的覆盖情况求出，所以最优解是由子问题的最优解转移而来，所以该问题也具有**最优子结构性质**，由此，我们可以考虑动态规划。

不难发现，平面中的点都有覆盖或未覆盖两种情况，可以用二进制数表示点的覆盖情况，并且数据范围小，$O(2^n)$ 的空间复杂度完全能够通过此题。

定义数组 $f$ 表示覆盖情况 $i$ 所需的最少抛物线数量，其中 $i$ 是一个二进制数，$i$ 的每一个二进制位都表示每一个点的覆盖情况，设 $1$ 表示覆盖，$0$ 表示未覆盖，下文的二进制数都采用该种定义。

自然地，想到枚举每一种覆盖情况，寻找没有被覆盖的点进行转移，再枚举过该没有被覆盖的点的抛物线，同时再枚举判断是否有别的点被该抛物线覆盖，将覆盖结果存储在一个二进制数中，将当前覆盖情况与二进制数做按位与运算，转移状态。但是这个算法的时间复杂度是 $O(Tn^22^n)$ 的，如果直接打上去只有 75 分，~~或者卡个常 100 分~~。

所以我们考虑优化，并不用复杂的 dp 优化技巧，只是简单的空间换时间。可以预处理出 $p$ 数组，存储二进制数，使用位运算的方法存储点，表示经过点 $i$ 和点 $j$ 的点的抛物线，对于平面上点的覆盖情况。特别地，如果 $x_i=x_j$ 或计算出抛物线开口朝上，则跳过。同时，一个点无法确定一条抛物线，但可以被单独一条抛物线覆盖，因此预处理 `p[i][i]=1<<i`。

预处理完成后，我们便可以方便地调用每一条抛物线进行状态转移，状态转移沿用未优化版本的思路，但是这次不再需要计算抛物线过哪些点，所以时间复杂度是 $O(Tn2^n)$ 的，比较优秀，可以通过本题，起点为 $f_0=0$，目标是 $f_{2^n}$。

接下来到了大家最喜欢的状态转移方程环节：
$$
f_{i\mid p_{x,j}}= \min_{x\le n,i<2^n,j<n}\{ {f_i+1,f_i\mid p_{x,j}}\} 
$$
贴个代码：
~~~cpp
#include<bits/stdc++.h>
using namespace std;
const double eps=1e-8;//注意浮点数精度比较
int T,n,m,tmp,f[1<<18],p[20][20];
/*
f[x]表示过x表示的点集最少所需抛物线
x是一个二进制数，x上的某一位为1表示该点被覆盖，
以下所有二进制数的含义都与x相同
p[x][y]是预处理数组，表示过x点和y点的抛物线同时覆盖哪些点
p数组存储的也是二进制数
*/
double x[20],y[20];

int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin>>T;
	while (T--)
	{
		cin>>n>>m;
		for (int i=0;i<=n;i++)
			for (int j=0;j<=n;j++)
				p[i][j]=0;
		for (int i=0;i<1<<n;i++)
			f[i]=2e9;
		for (int i=0;i<n;i++)
			cin>>x[i]>>y[i];
		for (int i=0;i<n;i++)//根据题意预处理
		{
			p[i][i]=1<<i;//表示只过i点的抛物线覆盖i点
			for (int j=i+1;j<n;j++)
			{
				if (i==j||fabs(x[i]-x[j])<=eps) continue;//两个横坐标相同的点无法确定一条抛物线
				double a=(y[i]/x[i]-y[j]/x[j])/(x[i]-x[j]);//抛物线参数a和b的公式
				if (a>=eps) continue;//开口朝上的抛物线是不合法的
				double b=y[i]/x[i]-a*x[i];
				tmp=0;
				for (int k=0;k<n;k++)
					if (fabs(a*x[k]*x[k]+b*x[k]-y[k])<=eps) tmp|=1<<k;
				p[i][j]=p[j][i]=tmp;
				/*
				枚举两两不同的点计算合法的抛物线，
				计算完成后再枚举判断每个点是否在抛物线上，
				将在抛物线上的点k加入到二进制数tmp中，
				最后存贮在p数组中
				*/
			}
		}
		f[0]=0;
		for (int i=0;i<1<<n;i++)//枚举每一个二进制数i
		{
			int x=0;
			for (int j=0;j<n;j++)
			{
				if (!((1<<j)&i))
				{
					x=j;//x表示的是i中第一个不为0的二进制位
					break;
				}
			}
			/*
			总的来说，上述过程枚举坐标系中的点的覆盖情况
			然后记录第一个没有被覆盖到的点，考虑对该点进行转移
			*/
			for (int j=0;j<n;j++)
				f[i|p[x][j]]=min(f[i]+1,f[i|p[x][j]]);
			/*
			对x从未覆盖到覆盖的转移过程
			枚举过x点的抛物线，取所需最少抛物线的数量
			*/
		}
		cout<<f[(1<<n)-1]<<'\n';
	}
	return 0;
}
~~~
本题还需要注意浮点数的精度问题，$eps$ 设为 $1*10^{-6}$ 即可。

---

## 作者：yhy2024 (赞：1)

看到 $n\le18$ 容易想到状态压缩。

发现要求必须打中两猪，且 $a<0$ 时，$a,b$ 时唯一的。设 $line_{i,j}$ 为必须打中 $i,j$ 两猪时的状态。可以 $\operatorname{O(n^3)}$ 预处理出来。

设 $f_i$ 表示打到状态 $i$ 最少要打几次。转移 $\operatorname{O(2^n n^2)}$

```cpp
#include<bits/stdc++.h>
#define N 25
using namespace std;
const double inf=1e-10;
int n,f[(1<<N)],T,m,line[N][N];
double x[N],y[N];
bool is(double x,double y){
	if(abs(x-y)<inf) return 1;
	return 0;
}
void solve(){
	memset(line,0,sizeof(line));
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>x[i]>>y[i];
	int S=(1<<n)-1;
	for(int i=0;i<=S;i++) f[i]=INT_MAX;
	f[0]=0;
	for(int i=1;i<=n;i++){//预处理
		for(int j=1;j<=n;j++){	
			if(i!=j){
				double a=(y[i]-(y[j]*x[i])/x[j])/(x[i]*x[i]-x[i]*x[j]);
				double b=y[i]/x[i]-a*x[i];//解出a,b
				if(a>=0) continue;
				for(int k=1;k<=n;k++){
					if(is(y[k],a*x[k]*x[k]+b*x[k])) line[i][j]|=(1<<(k-1));	
				}
			}
		}	
	}
	for(int s=0;s<S;s++){
		if(f[s]!=INT_MAX){
			for(int i=1;i<=n;i++) f[s|(1<<(i-1))]=min(f[s|(1<<(i-1))],f[s]+1);
			for(int i=1;i<=n;i++){
				for(int j=1;j<=n;j++){	
					if(i!=j){
						f[s|line[i][j]]=min(f[s|line[i][j]],f[s]+1);						
					}
				}	
			}
		}
	}
	cout<<f[S]<<'\n';
}
signed main(){
	cin>>T;
	while(T--) solve();
	return 0;
}
```

---

## 作者：Chen_Johnny (赞：0)

## P2831 [NOIP 2016 提高组] 愤怒的小鸟 
这是一道状压 DP 的题目……
## 题意解析
这道题就是让我们选几条抛物线，这几条抛物线要覆盖完所有的点。

首先看到题目中的每次的 $m$，不难发现其实这个 $m$ 是毫无意义的，因为这个对解体并没有用处。

## 思路
这道题不难发现 $n \leqslant 18$，这就是显然的状压 DP 数据范围。

首先我们发现，其实每一条抛物线肯能会经过多个节点，所以第一步就是算出所有合法抛物线的每一个经过的节点。然后我们再来 DP。

DP 的时候，我们发现每一次操作无疑就是加一条抛物线而已，所以只需要在预处理的基础上将节点加上去就可以了。
### 计算抛物线所经节点
首先，我们的第一步是算合法抛物线。而八年级的数学知识告诉我们，两点确定一条经过原点的抛物线。我们直接上硬核数学，即解两个方程：$ax_1^2 + bx_1 - y_1 = 0$ 和 $ax_2^2 + bx_2 - y_2 = 0$。经计算得：$a = \frac {x_2y_1-x_1y_2} {x_1x_2(x_1 - x_2)},b = \frac {x_1^2y_1-x_2^2y_1} {x_1x_2(x_1 - x_2)}$。

好了，有了计算的方法，我们先直接开算，我们上来先枚举两个点 $i,j$，然后再在剩下的树种根据这个式子，去推导出来所有满足这个 $y = ax^2 + bx$ 的关系式的所有字母加入这个序列。

最大的问题来了，这个怎么存储。用状态压缩和一个一维数组。一维数组 $line_i$ 表示第 $i$ 个抛物线的经过的节点的状态压缩状态。
### DP 转移方程
有了这个，其实转移方程也就直接出来了，是：$f_i = f_{i|line_j} = \min ({f_{i|line_j},f_{i+1}})$。

### 细节
我们发现这里是浮点数，意味着我们需要进行精度差的计算。在计算小于等于的时候不要忘记适应 `#define DDTS 1e-10` 这样的代码来防止误差！
## 代码
```cpp
#include <bits/stdc++.h>
#define DDTS 1e-10
using namespace std;
int n, m, tot;
int dp [1 << 20], line [400];
double a, b, x [20], y [20];
void work (double &a, double &b, int i, int j) {
    a = (x [j] * y [i] - x [i] * y [j]) / ((x [i] - x [j]) * x [i] * x [j]);
    b = (x [i] * x [i] * y [j] - x [j] * x [j] * y [i]) / ((x [i] - x [j]) * x [i] * x [j]);
}
double f (double x)  {return a * x * x + b * x;}
int main () {
    int T; scanf ("%d", &T);
    while (T --) {
        cin >> n >> m;
        for (int i = 1; i <= n; i ++) cin >> x [i] >> y [i];
        tot = 0;
        for (int i = 1; i <= n; i ++) {
            line [++ tot] = 1 << (i - 1);
            for (int j = i + 1, vis = 0; j <= n; j ++) {
                if ((1 << (j - 1)) & vis) continue;
                work (a, b, i, j);
                if (a > -DDTS) continue;
                line [++ tot] = 1 << (i - 1);
                for (int k = j; k <= n; k ++)
                    if (fabs (f (x [k]) - y [k]) < DDTS) {
                        vis |= (1 << (k - 1));
                        line [tot] |= (1 << (k - 1));
                    }
            }
        }
        memset (dp, 0x3f3f3f, sizeof (dp));
        dp [0] = 0;
        for (int i = 0; i < (1 << n); i ++)
            for (int j = 1; j <= tot; j ++)
                dp [i | line [j]] = min (dp [i | line [j]], dp [i] + 1);
        printf ("%d\n", dp [(1 << n) - 1]);
    }
    return 0;
}

```

---

## 作者：Thorongil_Gondor (赞：0)

# 题解：P2831 [NOIP 2016 提高组] 愤怒的小鸟
## 思路：
对于第 $i$ 只猪，若其未被抛物线经过，分两种情况：
* 第一种：与前面某一只未与其它猪组成抛物线的猪组成抛物线。
* 第二种：不与其它未与其它猪组成抛物线的猪组成抛物线。在搜索结束后用抛物线单独击中它。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
double Comp=1e-8;
bool comparisons(double a,double b){
	return fabs(a-b)<Comp;//比较，防止精度问题 
}
int n,m,ans;
double x[20],y[20],parabolaa[20],parabolab[20],tx[20],ty[20];
void dfs(int c,int u,int v){
	if(u+v>=ans)return;//最优性剪枝 
	if(c>n){
		ans=u+v;
		return;
	}
	bool flag=false;
	for(int i=1;i<=u;i++)
		if(comparisons(parabolaa[i]*x[c]*x[c]+parabolab[i]*x[c],y[c])){//被经过 
			dfs(c+1,u,v);
			flag=true;
			break;
		}
	if(!flag){//未被经过 
		for(int i=1;i<=v;i++){ 
			if(comparisons(x[c],tx[i]))continue;
			double a=(y[c]*tx[i]-ty[i]*x[c])/(x[c]*x[c]*tx[i]-tx[i]*tx[i]*x[c]);
			double b=(y[c]-x[c]*x[c]*a)/x[c];
			if(a<0){	
				parabolaa[u+1]=a;
				parabolab[u+1]=b;
				//已经和当前猪组成抛物线
				double q=tx[i],w=ty[i];
				for(int j=i;j<v;j++){
					tx[j]=tx[j+1];
					ty[j]=ty[j+1];
				}
				dfs(c+1,u+1,v-1);
				for(int j=v;j>i;j--){//回溯 
					tx[j]=tx[j-1];
					ty[j]=ty[j-1];
				}
				tx[i]=q;
				ty[i]=w;
			}
		}
		//不与其它猪组成抛物线  
		tx[v+1]=x[c];
		ty[v+1]=y[c];
		dfs(c+1,u,v+1);
	}
}
int main(){
	int _;
	cin>>_;
	while(_--){
		cin>>n>>m;
		for(int i=1;i<=n;i++)cin>>x[i]>>y[i];
		ans=INT_MAX;//多测初始化 
		dfs(1,0,0); 
		cout<<ans<<endl; 
	} 
	return 0;
}
```

---

## 作者：Hacker_Cracker (赞：0)

## P2831 [NOIP 2016 提高组] 愤怒的小鸟 题解
**upd 2025.2.19** 修正了 Solution 中的公式问题。
### Solution
##### 吐槽：此题卡精度。

看到数据范围，想到状压 DP。

设 $dp_S$ 为消灭的猪的状态为 $S$ 时所需要的抛物线的最少数量。则有 $dp_0=0$。

考虑遍历每一对猪 $(i,j)$。记这两头猪的坐标是 $(x_i,y_i),(x_j,y_j)$。设它们所处的抛物线为 $y=ax^2+bx(a<0)$。则可以列出方程：

$$\begin{cases}
  ax_i^2+bx_i=y_i\\
  ax_j^2+bx_j=y_j\\
\end{cases}$$

解得

$$\begin{cases}
    a= \cfrac{x_jy_i-x_iy_j}{x_ix_j(x_i-x_j)}\\ \\
    b= \cfrac{x_i^2y_j-x_j^2y_i}{x_ix_j(x_i-x_j)}\\
\end{cases}
$$

显然，当 $a>0$ 或 $x_i=x_j$ 时，这条抛物线不合法，只能各用一条抛物线消灭这两头猪或和其他猪结合。

然后遍历剩下的猪，记第三头猪坐标为 $(x_k,y_k)$。则当且仅当 $ax_k^2+bx_k=y_k$ 时，可以使用同一条抛物线消灭它。我们可以使用 $p_{i,j}$ 数组记录消灭猪 $(i,j)$ 的抛物线所能消灭的所有猪的集合。

状态转移：枚举所有合法的 $p_{i,j}$，结合抛物线进行转移，也就是 $dp_{S|p_{i,j}} \gets \min(dp_{S|p_{i,j}},dp_S+1)$。

最后 $dp_{(1<<n)-1}$ 即为所求。

### tips
注意精度问题。判等时不能直接使用 $=$ 号，而是要做差。若两数之差小于 $10^{-8}$，就可以判等。

时间复杂度 $O(T(n^3+2^n n^2))$。
### [AC Code](https://www.luogu.com.cn/record/203148676)
```cpp
#include<iostream>
#include<cstring>
#include<cmath>
using namespace std;
const double eps=1e-8;
const int N=20;
int dp[1<<N],pw[N][N],cnt,n,m,T;
double x[N],y[N],_a,_b;
bool calc(int i,int j){
	if(abs(x[i]-x[j])<=eps) return 0;//两点x坐标相同，无法构成抛物线
	_a=(x[j]*y[i]-x[i]*y[j])/(x[i]*x[j]*(x[i]-x[j]));
	_b=(x[i]*x[i]*y[j]-x[j]*x[j]*y[i])/(x[i]*x[j]*(x[i]-x[j]));
	return _a<0.0; 
}
int main(){
	scanf("%d",&T);
	for(;T;T--){
		scanf("%d%d",&n,&m);
		memset(dp,0x3f,sizeof(dp));//初始化，赋为极大值 
		memset(pw,0,sizeof(pw));//清零 
		dp[0]=0;//消灭0只猪需要0条抛物线 
		for(int i=1;i<=n;i++) scanf("%lf%lf",x+i,y+i);
		for(int i=1;i<=n;i++){
			for(int j=i+1;j<=n;j++){
				_a=0.0,_b=0.0;//抛物线的系数 
				if(calc(i,j)){
					for(int k=1;k<=n;k++){
						if(abs(_a*x[k]*x[k]+_b*x[k]-y[k])<=eps) pw[i][j]|=1<<(k-1);
					}
				}
			}
		}
		for(int s=0;s<(1<<n);s++){
			for(int i=1;i<=n;i++) dp[s|(1<<(i-1))]=min(dp[s|(1<<(i-1))],dp[s]+1);
			for(int i=1;i<=n;i++){
				for(int j=1;j<=n;j++){
					dp[s|pw[i][j]]=min(dp[s|pw[i][j]],dp[s]+1);
				}
			}
		} 
		printf("%d\n",dp[(1<<n)-1]);
	}
	return 0;
} 
```

---


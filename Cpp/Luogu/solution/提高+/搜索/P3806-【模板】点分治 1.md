# 【模板】点分治 1

## 题目背景

感谢 hzwer 的点分治互测。




## 题目描述

给定一棵有 $n$ 个点的树，询问树上距离为 $k$ 的点对是否存在。

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n\leq 100$。
- 对于 $60\%$ 的数据，保证 $n\leq 1000$，$m\leq 50$ 。
- 对于 $100\%$ 的数据，保证 $1 \leq n\leq 10^4$，$1 \leq m\leq 100$，$1 \leq k \leq 10^7$，$1 \leq u, v \leq n$，$1 \leq w \leq 10^4$。

#### 提示

- **本题不卡常**。
- 如果您 #7 一直 RE/TLE，不妨看看 [这个帖子](https://www.luogu.com.cn/discuss/show/188596)。

## 样例 #1

### 输入

```
2 1
1 2 2
2```

### 输出

```
AYE```

# 题解

## 作者：Froggy (赞：310)

## 给一种~~另类~~的点分治!(非常好理解)

是一种不用桶的做法,数据范围珂以达到 $0\leq c,K \leq 10^9$ (或者更大)

---

### update 2020.2.8 修改了一些小错误

并update:代码在bzoj1316因为没有特判询问0导致WA掉的锅.(感谢 @jiaangk 指出)

### update 2021.3.3 修改了复杂度的错误

---

我看大部分题解的calc函数里都是:

```cpp
void calc(int u){
	...
	//注:tot为d数组长度
	for(int i=1;i<=tot;i++){
		for(int j=1;j<=tot;j++){
			...
		}
	}
	...
}
```
问一句: 
#### 你们不怕T么?
~~我相信回答一定是:你谷数据太菜~~ (update: 2020.2.2 管理员数据加强后确实会T)

### 双层循环?构造一个菊花图一定T!

所以,我这里给出一个复杂度是 $\mathcal{O}(n \log^{2}n+nm\log n)$ 的做法。

`calc` 函数和 `get_dis` 函数不一样，其他都差不多。

------------

记当前分治的根为 $root$。

- $a$ 数组记录从 $root$ 能到的点;

- $d$ 数组记录 $a_{i}$ 到 $root$ 的距离;

- $b$ 数组记录 $a_{i}$ 属于 $root$ 的哪一棵子树(即当 $b_{a_i}=b_{a_j}$ 时,说明 $a_{i}$ 与 $a_{j}$ 属于 $root$ 的同一棵子树)

### 注意：将 $a$ 数组排序时应按照 $d$ 值的从小到大:

cmp函数:


```cpp
bool cmp(int x,int y){
	return d[x]<d[y];
}
```

`get_dis` 函数借鉴了P4178的思想(即用两个指针 $l,r$ 遍历数组)

现在,请看 `get_dis` 与 `calc`

```cpp
void get_dis(int u,int fa,int dis,int from){
	a[++tot]=u;//加入一个新结点
	d[u]=dis;
	b[u]=from;
	for(int i=head[u];i;i=edge[i].nxt){
		int v=edge[i].to;
		if(v==fa||vis[v])continue;
		get_dis(v,u,dis+edge[i].val,from);
	}
}
void calc(int u){
	tot=0;
	a[++tot]=u;
	d[u]=0;
	b[u]=u;//别忘了加上root自己
	for(int i=head[u];i;i=edge[i].nxt){
		int v=edge[i].to;
		if(vis[v])continue;
		get_dis(v,u,edge[i].val,v);
	}
	sort(a+1,a+tot+1,cmp);
	for(int i=1;i<=m;i++){
		int l=1,r=tot;
		if(ok[i])continue;
		while(l<r){
			if(d[a[l]]+d[a[r]]>query[i]){//当和比询问的长度大时,右指针左移
				r--;
			}
			else if(d[a[l]]+d[a[r]]<query[i]){//类似上边
				l++;
			}
			else if(b[a[l]]==b[a[r]]){//和为询问的长度,但同属一棵子树,继续下一种情况
				if(d[a[r]]==d[a[r-1]])r--;
				else l++;
			}
			else{
				ok[i]=true;
				break;
			}
		}
	}
}
```
***talk is cheap,show me your code!***

## 全部代码:

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
#define N 10001
#define re register 
inline int read(){
    int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<3)+(x<<1)+c-'0';
        c=getchar();
    }
    return x*f;
}
int n,m,query[101];
int e_cnt=0,head[N],maxp[N],siz[N],root,tot=0,d[N],b[N],a[N];
bool vis[N],ok[101];
struct Edge{
	int to,nxt,val;
}edge[N<<1];
void add(int a,int b,int c){
	e_cnt++;
	edge[e_cnt].nxt=head[a];
	edge[e_cnt].to=b;
	edge[e_cnt].val=c;
	head[a]=e_cnt;
}
void get_root(int u,int fa,int total){
	siz[u]=1;
	maxp[u]=0;
	for(re int i=head[u];i;i=edge[i].nxt){
		int v=edge[i].to;
		if(v==fa||vis[v])continue;
		get_root(v,u,total);
		siz[u]+=siz[v];
		maxp[u]=max(siz[v],maxp[u]);
	}
	maxp[u]=max(maxp[u],total-siz[u]);
	if(!root||maxp[u]<maxp[root]){
		root=u;
	}
}
bool cmp(int x,int y){
	return d[x]<d[y];
}
void get_dis(int u,int fa,int dis,int from){
	a[++tot]=u;
	d[u]=dis;
	b[u]=from;
	for(re int i=head[u];i;i=edge[i].nxt){
		int v=edge[i].to;
		if(v==fa||vis[v])continue;
		get_dis(v,u,dis+edge[i].val,from);
	}
}
void calc(int u){
	tot=0;
	a[++tot]=u;
	d[u]=0;
	b[u]=u;
	for(int i=head[u];i;i=edge[i].nxt){
		int v=edge[i].to;
		if(vis[v])continue;
		get_dis(v,u,edge[i].val,v);
	}
	sort(a+1,a+tot+1,cmp);
	for(int i=1;i<=m;i++){
		int l=1,r=tot;
		if(ok[i])continue;
		while(l<r){
			if(d[a[l]]+d[a[r]]>query[i]){
				r--;
			}
			else if(d[a[l]]+d[a[r]]<query[i]){
				l++;
			}
			else if(b[a[l]]==b[a[r]]){
				if(d[a[r]]==d[a[r-1]])r--;
				else l++;
			}
			else{
				ok[i]=true;
				break;
			}
		}
	}
}
void solve(int u){
	vis[u]=true;
	calc(u);
	for(re int i=head[u];i;i=edge[i].nxt){
		int v=edge[i].to;
		if(vis[v])continue;
		root=0;
		get_root(v,0,siz[v]);
		solve(root);
	}
}
int main(){
	n=read(),m=read();
	for(re int i=1;i<=n-1;i++){
		int u,v,w;
		u=read(),v=read(),w=read();
		add(u,v,w);
		add(v,u,w);
	}
	for(re int i=1;i<=m;i++){
		query[i]=read();
		if(!query[i])ok[i]=1;//这里,加个特判
	}
	maxp[0]=n;
	get_root(1,0,n);
	solve(root);
	for(re int i=1;i<=m;i++){
		if(ok[i]){
			cout<<"AYE"<<endl;
		}
		else{
			cout<<"NAY"<<endl;
		}
	}
	return 0;
}

```

[*Froggy's blog*](https://www.luogu.org/blog/froggy/)

#### 呱!!

---

## 作者：niiick (赞：205)

先贴一篇dalao的证明[一种基于错误的寻找重心方法的点分治的复杂度分析](http://liu-cheng-ao.blog.uoj.ac/blog/2969)%%%%%

针对本蒟蒻之前题解的一些错误以做出了修改，并且实测#7无RE/TLE，如果还有不到之处欢迎dalao指出
********************
我们先随意指定一个根rt，将这棵树转化成有根树

不难发现树上的路径分为两类，
**经过根节点rt的路径**和**包含于rt的某棵子树里(不经过rt)的路径**

对于前者，
我们用$dis[u]$表示结点$u$到根节点$rt$的路径长度，
则u到v的路径长即为$dis[u]+dis[v]$

对于后者，
既然$u$到$v$的路径包含在$rt$的某个子树内，
那么我们就**找到这棵子树的根，再对他求一次第一类路径**

这样分治的思想就很明显了

**就是把原来的树分成很多小的子树，并对每个子树分别求解第一类路径**

点分治过程中，每一层的所有递归过程合计对每个点处理一次
假设共递归T层，则总时间复杂度为$O(T*N)$

然而，**如果树退化成一条链**
那么递归层数就是$T=n$，总时间复杂度为$O(N^2)$

这样显然不能承受，所以我们要让树的层数经量少
这里就要找**树的重心**

maxp[u] (max part)表示**删除结点u后产生的子树中，最大的那棵的大小**

则树的重心就是**maxp[]值最小的那个节点**


```cpp
//sum是当前子树的总结点数，size[u]是以u为根的子树大小
void getrt(int u,int fa)
{
    size[u]=1; maxp[u]=0;
    for(int i=head[u];i;i=E[i].nxt)
    {
        int v=E[i].v;
        if(v==fa||vis[v])continue;
        getrt(v,u);//先递归得到子树大小
        size[u]+=size[v];
        maxp[u]=max(maxp[u],size[v]);//更新u结点的maxp
    }
    maxp[u]=max(maxp[u],sum-size[u]);//考虑删除u后，父节点一侧的子树大小
    if(maxp[u]<maxp[rt]) rt=u;//更新当前子树的重心
}
```

我们在点分治过程中**每次选取子树的重心为子树的树根进行处理**，
这样**总的递归深度不会超过**$logN$**层**，
整个点分治的时间复杂度也就保证了$O(NlogN)$

点分治题的思想大都如上，
对于不同的题要设计不同的calc函数

********************************


回到本题，询问可以离线记录并直接在分治过程中处理

设当前根为$rt$，他的子树为$v_1,v_2……v_t$，
假设当前处理的子树为$v_i$，求出$v_i$中每个结点到$rt$的距离$dis$并保存于$rem$数组
并令$judge[dis]$表示在子树$v_1$~$v_{i-1}$中是否存在某个节点到$rt$距离为$dis$

遍历每个离线记录的询问，对每个询问遍历一次当前子树的$rem$
若当前询问距离为$query[k]$，遍历到的子树$v_i$中某个结点到$rt$距离为$rem[j]$
如果$judge[query[k]-rem[j]]==1$，则代表此询问的路径存在

再具体点解释这段话操作的含义
就是用子树$v_i$中某个结点与子树$v_1$~$v_{i-1}$中某个节点两两配对，检查是否存在长度为$query[k]$的路径

像这样配对完后将这棵子树的$rem$(即子树$v_i$中每个节点到$rt$的$dis$)一起保存进$judge$数组，继续下一个子树$v_{i+1}$的处理

当以rt为根的树查询完后清空judge数组
然后对其他子树进行分治
*********************

```cpp
//niiick
#include<iostream>
#include<vector>
#include<algorithm>
#include<queue>
#include<cstring>
#include<cstdio>
using namespace std;

int read()
{
    int f=1,x=0;
    char ss=getchar();
    while(ss<'0'||ss>'9'){if(ss=='-')f=-1;ss=getchar();}
    while(ss>='0'&&ss<='9'){x=x*10+ss-'0';ss=getchar();}
    return f*x;
}

const int inf=10000000;
const int maxn=100010;
int n,m;
struct node{int v,dis,nxt;}E[maxn<<1];
int tot,head[maxn];
int maxp[maxn],size[maxn],dis[maxn],rem[maxn];
int vis[maxn],test[inf],judge[inf],q[maxn];
int query[1010];
int sum,rt;
int ans;

void add(int u,int v,int dis)
{
    E[++tot].nxt=head[u];
    E[tot].v=v;
    E[tot].dis=dis;
    head[u]=tot;
}

void getrt(int u,int pa)
{
    size[u]=1; maxp[u]=0;
    for(int i=head[u];i;i=E[i].nxt) 
    {
        int v=E[i].v;
        if(v==pa||vis[v]) continue;
        getrt(v,u);
        size[u]+=size[v];
        maxp[u]=max(maxp[u],size[v]);
    }
    maxp[u]=max(maxp[u],sum-size[u]);
    if(maxp[u]<maxp[rt]) rt=u;
}

void getdis(int u,int fa)
{
    rem[++rem[0]]=dis[u];
    for(int i=head[u];i;i=E[i].nxt)
    {
        int v=E[i].v;
        if(v==fa||vis[v])continue;
        dis[v]=dis[u]+E[i].dis;
        getdis(v,u);
    }
}

void calc(int u)
{
    int p=0;
    for(int i=head[u];i;i=E[i].nxt)
    {
        int v=E[i].v;
        if(vis[v])continue;
        rem[0]=0; dis[v]=E[i].dis;
        getdis(v,u);//处理u的每个子树的dis

        for(int j=rem[0];j;--j)//遍历当前子树的dis
        for(int k=1;k<=m;++k)//遍历每个询问
        if(query[k]>=rem[j])
        test[k]|=judge[query[k]-rem[j]];
        //如果query[k]-rem[j]d的路径存在就标记第k个询问

        for(int j=rem[0];j;--j)//保存出现过的dis于judge
        q[++p]=rem[j],judge[rem[j]]=1;
    }
    for(int i=1;i<=p;++i)//处理完这个子树就清空judge
    judge[q[i]]=0;//特别注意一定不要用memeset，会T

}

void solve(int u)
{   
    //judge[i]表示到根距离为i的路径是否存在
    vis[u]=judge[0]=1; calc(u);//处理以u为根的子树
    for(int i=head[u];i;i=E[i].nxt)//对每个子树进行分治
    {
        int v=E[i].v;
        if(vis[v])continue;
        sum=size[v]; maxp[rt=0]=inf;//注意sum是以v为根的子树大小
        getrt(v,0); solve(rt);//在子树中找重心并递归处理
    }
}

int main()
{
    n=read();m=read();
    for(int i=1;i<n;++i)
    {
        int u=read(),v=read(),dis=read();
        add(u,v,dis);add(v,u,dis);
    }
    for(int i=1;i<=m;++i)
    query[i]=read();//先记录每个询问以离线处理

    maxp[rt]=sum=n;//第一次先找整棵树的重心
    getrt(1,0); 
    solve(rt);//对树进行点分治

    for(int i=1;i<=m;++i)
    {
        if(test[i]) printf("AYE\n");
        else printf("NAY\n");
    }
    return 0;
}
```

---

## 作者：寒冰大大 (赞：118)



[可能会更好的阅读体验](https://zsx6.com/2020/01/13/%E7%82%B9%E5%88%86%E6%B2%BB%E5%AD%A6%E4%B9%A0%E8%AE%B0/)

## 放在开头的话

1.本人1月13日才刚刚接触了淀粉汁，所以可能很多东西没有理解完全甚至出错，如果您有什么疑问的话，请发在下面的评论区。

2.淀粉汁是跟着一篇题解学的，因此可以有些代码很像，但是原来题解的部分没讲到的地方我可能会提出来

3.这东西目前可能会更的很慢

## 初级

什么是点分治？

点分治是处理树上问题的一种高效的办法，时间复杂度很优秀，而且思想比较巧妙。

怎么来做呢？

首先我们引入树的重心

### 树的重心

> 树的重心也叫树的质心。找到一个点,其所有的子树中最大的子树节点数最少,那么这个点就是这棵树的重心,删去重心后，生成的多棵树尽可能平衡。

什么意思呢?

我们可以从这里推得以树的重心为根的任意一颗子树大小不超过$n/2$

> 证明就不用了吧

于是我们求$log_2N$次重心，那么每个点就能被确定了。

于是时间复杂度就变成了$O(N log N)$



怎么求呢？

根据它的定义，树的重心一定是最大子树最小的点。

~~感性理解即可~~

于是照着求就可以了啊。

但是我们要多次求，因此我们得加一个条件，判断是否可以访问

`vis[]`或者`fw[]`就可以了



于是整个代码如下

```cpp
inline void getzx(int t,int fat)
{
	int i,j;
	sz[t]=1;
	maxp[t]=0;
	for(i=head[t];i;i=e[i].next)
	{
		j=e[i].to;
		if(j==fat||vis[j]) continue;
		getzx(j,t);
		sz[t]+=sz[j];
		maxp[t]=max(sz[j],maxp[t]);
	}
	maxp[t]=max(maxp[t],tot-sz[t]);
	if(maxp[t]<maxp[rt]) rt=t;
}
```

### 点分治怎么做

我们只需要不断寻找重心，用这些重心来计算我们要的答案

我们举个例子：

现在这里有一棵树

(假定蓝色是未被处理的点，红色是当前子树的重心，绿色是处理完的点)

![](https://cdn.luogu.com.cn/upload/image_hosting/mf557a06.png)

先找到全局重心

![](https://cdn.luogu.com.cn/upload/image_hosting/ewoqneh1.png)

然后对他的子树，也这样找

![](https://cdn.luogu.com.cn/upload/image_hosting/mkr8k3al.png)

一直接下去![](https://cdn.luogu.com.cn/upload/image_hosting/jgxw6a0z.png) 

![](https://cdn.luogu.com.cn/upload/image_hosting/t1ajduki.png)

然后做完了。

等一下，这不是大部分点都被扫过了吗，时间复杂度怎么还会是$O (NlogN)$?

的确，这张图中大部分店都被扫到了，而且都求了重心，但是如果每条边中间连接1000个点，只有m,i,h三条边被处理的重心增多了。

增多了多少呢？

每条边在10左右。

~~现在你感性理解到了复杂度了吧~~

由于之前有一个推论

>我们可以从这里推得以树的重心为根的任意一颗子树大小不超过$n/2$

每次树的大小会变得不超过原来的一般，$log_2N$次后树的大小就会变成1,每一次最多遍历整棵树$O(N)$,复杂度就得到$O (NlogN)$?了

~~不信？我们用随机几十组数据看看~~

![](https://cdn.luogu.com.cn/upload/image_hosting/rzrxvvs2.png)

数据生成器放在[这里](https://www.luogu.com.cn/paste/s4faznxw)

测试用的代码放在[这里](https://www.luogu.com.cn/paste/gz2rcwai) 改自[P2634 [国家集训队]聪聪可可](https://www.luogu.com.cn/problem/P2634)



下面是一个模板代码

```cpp
inline void solve(int t)
{
	int i,j;
	vis[t]=judge[0]=1; calc(t);  //进行计算，有时候要用到容斥原理。
	for(i=head[t];i;i=e[i].next)
	{
		j=e[i].to;
		if(vis[j]) continue;
		tot=sz[j];
		maxp[rt=0]=bign;
		getzx(j,0);  //继续寻找重心
		solve(rt);
	}
}
```



### 例题

#### P3806 【模板】点分治1

大意

>给定一棵有n个点的树
>
>询问树上距离为k的点对是否存在。

其实是很无脑的两个桶，一个`judge[]`和一个`tmp[]`，`judge`存非本路径上长度能达到的数字，`tmp[]`存本路径上能达到的数字，把此时重心看做LCA，于是若tmp[]中一个数+judge[]一个数=k,就说明路径存在。

接着，这条路径遍历完后，把tmp的数字转移到judge里面

这个地方我们找完了，只需要把judge里面的数字清空即可。

于是我们就有代码了

```cpp
#include<touwenjian.h> 

using namespace std;

const int maxn=10010,bign=10001000;

int n,m,tmp[bign],judge[bign];
int sz[maxn],vis[maxn];
int head[maxn],que[maxn];
int size,maxp[maxn];
int tot,rt,dis[maxn];
int q[bign],ynn[maxn];

struct edge{
	int next,to,dis;
}e[maxn*2];

inline void addedge(int next,int to,int dis)
{
	e[++size].to=to;
	e[size].dis=dis;
	e[size].next=head[next];
	head[next]=size;
}

inline void getzx(int t,int fat)
{
	int i,j;
	sz[t]=1;
	maxp[t]=0;
	for(i=head[t];i;i=e[i].next)
	{
		j=e[i].to;
		if(j==fat||vis[j]) continue;
		getzx(j,t);
		sz[t]+=sz[j];
		maxp[t]=max(sz[j],maxp[t]);
	}
	maxp[t]=max(maxp[t],tot-sz[t]);
	if(maxp[t]<maxp[rt]) rt=t;
}

inline void getdis(int t,int fat)
{
	tmp[++tmp[0]]=dis[t];
	int i,j,k;
	for(i=head[t];i;i=e[i].next)
	{
		j=e[i].to;
		k=e[i].dis;
		if(vis[j]||j==fat) continue;  //vis和fat限制了这个子树只能向下遍历。
		dis[j]=dis[t]+k;
		getdis(j,t);
	}
}

inline void calc(int t)
{
	int p=0,i,j,k,l;
	for(i=head[t];i;i=e[i].next)
	{
		j=e[i].to;
		k=e[i].dis;
		if(vis[j]) continue;
		tmp[0]=0;
		dis[j]=k;
		getdis(j,t);
		for(k=tmp[0];k;k--)
		for(l=1;l<=m;l++) if(que[l]>=tmp[k]) ynn[l]|=judge[que[l]-tmp[k]];  
		for(k=tmp[0];k;k--) q[++p]=tmp[k],judge[tmp[k]]=1;  
	}
	for(i=p;i;i--) judge[q[i]]=0; 
}

inline void solve(int t)
{
	int i,j;
	vis[t]=judge[0]=1; calc(t);
	for(i=head[t];i;i=e[i].next)
	{
		j=e[i].to;
		if(vis[j]) continue;
		tot=sz[j];
		maxp[rt=0]=bign;
		getzx(j,0);
		solve(rt);
	}
}

int main()
{
	ios::sync_with_stdio(false);
	register int i,h;
	int t1,t2,t3;
	cin>>n>>m;
	for(i=1;i<n;i++)
	{
		cin>>t1>>t2>>t3;
		addedge(t1,t2,t3);
		addedge(t2,t1,t3);
	}
	for(i=1;i<=m;i++) cin>>que[i];
	maxp[rt=0]=n;
	tot=n;
	getzx(1,0);
	solve(rt);// 每次solve从重心开始
	for(i=1;i<=m;i++) 
	{
		if(ynn[i]) cout<<"AYE"<<endl;
		else cout<<"NAY"<<endl;
	}
	return 0;
}

```



---

## 作者：Nemlit (赞：68)

## [原文地址](https://www.cnblogs.com/bcoier/p/10485482.html)

题意：给定一棵带权无根树，问是否有点对的距离为k

暴力的做法可以枚举所有点对，树上差分即可，复杂度为$O(n^2logn)$，显然还需要优化

有一个~~显然~~的性质，对于任意两个点所夹成的路径，有两种情况：

$1.$经过根节点的路径

$2.$不经过根节点的路径

对与第一类路径，$dis[u->v] = dis[u->rt] + dis[v ->rt]$

对于第二类路径，~~我们可以求出LCA在进行讨论~~，但是我们可以继续递归下去，找到另一个rt，把他转化成第一类路径来讨论

不难发现，这样递归下去的复杂度是和深度有关的，所以我们要尽量的减小深度来优化复杂度，那么我们怎么办呢？

对于每一棵树，我们都有一个**重心**（删掉重心后剩下的子树尽可能地平衡（分出来的最大子树的$size$尽可能地小））

举个例子，对于这张图，深度达到了6，显然不够优秀
![](https://cdn.luogu.com.cn/upload/pic/53294.png)

但是如果我们以5为根，树就会变成这样，深度变为了4：

![](https://cdn.luogu.com.cn/upload/pic/53298.png)

可见根的选择是对复杂度有影响的，如果数据足够大，~~出题人足够毒瘤~~，那么影响显然还会更大

那重心要怎么着呢？我们可以利用树（mo）形（ni）DP的思想来做，即找到该节点所有的子树，找到最大的哪一棵即可，代码如下：
```
il void getroot(int u, int fr)
{
	dp[u] = 0, size[u] = 1;
	Next(i, u)//找到所有与u相连的边
	{
		int v = e[i].v;
		if(v == fr || vis[v]) continue;
		getroot(v, u);
		size[u] += size[v];
		dp[u] = max(dp[u], size[v]);
	}
	dp[u] = max(dp[u], sum - size[u]);//还有一棵以其父亲节点为根的子树
	if(dp[u] < dp[root]) root = u;//找到最优的根
}
```

找到**重心**后，我们不断的递归，在递归过程中也要不断寻找重心来优化复杂度。

代码如下：
```
il void solve(int u)
{
	vis[u] = pd[0] = 1, doit(u);//doit表示做一些
	Next(i, u)
	{
		int v = e[i].v;
		if(vis[v]) continue;
		dp[0] = n, sum = size[v], root = 0;
		getroot(v, u), solve(root);
	}
}
```

那么doit要怎么写呢？

由于我们保证了所有的树都是第一种树（经过根节点的路径），所以我们对于每一个根，可以先预处理出每一个子节点到根的距离，这样我们就可以得到对于每一个点可能出现的距离

代码如下：
```
il void getdis(int u, int fr)
{
	rev[++ tot] = dis[u];
	Next(i, u)
	{
		int v = e[i].v;
		if(v == fr || vis[v]) continue;
		dis[v] = dis[u] + e[i].w;
		getdis(v, u);
	}
}
```
求出了所有距离以后，我们就可以合并答案了，把任意两个出现的距离凑在一起，并判断可否凑出我们需要的k即可（注意复原的时候不要用memset，不然复杂度就是$O(n^2)$了）
```
il void doit(int u)
{
	int c = 0;
	Next(i, u)
	{
		int v = e[i].v;
		if(vis[v]) continue;
		tot = 0, dis[v] = e[i].w, getdis(v, u);
		rep(j, 1, tot) rep(k, 1, m) if(query[k] >= rev[j]) pax[k] |= pd[query[k] - rev[j]];
		rep(j, 1, tot) q[++ c] = rev[j], pd[rev[j]] = 1;
	}
	rep(i, 1, c) pd[q[i]] = 0;
}
```
所有代码如下：
```
#include<bits/stdc++.h>
using namespace std;
#define il inline
#define re register
#define debug printf("Now is Line : %d\n",__LINE__)
#define file(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
//#define int long long
#define inf 123456789
#define mod 1000000007
il int read()
{
    re int x = 0, f = 1; re char c = getchar();
    while(c < '0' || c > '9') { if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - 48, c = getchar();
    return x * f;
}
#define rep(i, s, t) for(re int i = s; i <= t; ++ i)
#define drep(i, s, t) for(re int i = t; i >= s; -- i)
#define Next(i, u) for(re int i = head[u]; i; i = e[i].next)
#define lb(x) (x)&(-(x))
#define ls k * 2
#define rs k * 2 + 1
#define _ 10005
#define ___ 10000005
#define __ 105
struct edge{int v, next, w;}e[_ << 1];
int n, m, head[_], cnt, dp[_], tot, size[_], sum, root;
int dis[_], vis[_], pd[___], rev[_], pax[__], q[_], query[__];
il void add(int u, int v, int w){e[++ cnt] = (edge){v, head[u], w}, head[u] = cnt;}
il void getroot(int u, int fr)
{
	dp[u] = 0, size[u] = 1;
	Next(i, u)
	{
		int v = e[i].v;
		if(v == fr || vis[v]) continue;
		getroot(v, u);
		size[u] += size[v];
		dp[u] = max(dp[u], size[v]);
	}
	dp[u] = max(dp[u], sum - size[u]);
	if(dp[u] < dp[root]) root = u;
}
il void getdis(int u, int fr)
{
	rev[++ tot] = dis[u];
	Next(i, u)
	{
		int v = e[i].v;
		if(v == fr || vis[v]) continue;
		dis[v] = dis[u] + e[i].w;
		getdis(v, u);
	}
}
il void doit(int u)
{
	int c = 0;
	Next(i, u)
	{
		int v = e[i].v;
		if(vis[v]) continue;
		tot = 0, dis[v] = e[i].w, getdis(v, u);
		rep(j, 1, tot) rep(k, 1, m) if(query[k] >= rev[j]) pax[k] |= pd[query[k] - rev[j]];
		rep(j, 1, tot) q[++ c] = rev[j], pd[rev[j]] = 1;
	}
	rep(i, 1, c) pd[q[i]] = 0;
}
il void solve(int u)
{
	vis[u] = pd[0] = 1, doit(u);
	Next(i, u)
	{
		int v = e[i].v;
		if(vis[v]) continue;
		dp[0] = n, sum = size[v], root = 0;
		getroot(v, u), solve(root);
	}
}
int main()
{
	file(a);
	dp[0] = sum = n = read(), m = read();
	rep(i, 1, n - 1) {int u = read(), v = read(), w = read(); add(u, v, w), add(v, u, w);}
	rep(i, 1, m) query[i] = read();
	getroot(1, 0), solve(root);
	rep(i, 1, m) puts(pax[i] ? "AYE" : "NAY");
	return 0;
}
```

---

## 作者：X_o_r (赞：28)

这题一看是在N^2数量级条路径中找满足一定条件(路径长度=100个不同的K)的路径，一看就是点分治

然而点分治若是将10^7个可能询问全部一次性刷出来O(1)回答的话显然太慢了，看到只有100个询问于是果断只处理100个，当然也不是一个个处理，在点分治的过程中，原来应该刷答案的地方，对于每个询问都试着回答一次就好了

下面贴代码：

```cpp
#include <cstdio>
#include <cctype>
#include <cstring>
#include <algorithm>
#include <set>
using namespace std;
const int maxn=10005,maxe=20005;
const char U[2][8]={"NAY","AYE"};
int N,M,lnk[maxn],nxt[maxe],son[maxe],w[maxe],tot,Sigma,MaxSon[maxn],Size[maxn],Dis[maxn],Root,stk[maxn],top,K[105];
bool vis[maxn],Ans[105];
set<int> f;
inline void add(int x,int y,int z){
    son[++tot]=y,nxt[tot]=lnk[x],w[lnk[x]=tot]=z;
}
inline int read(){
    char ch=getchar(); int res=0;
    while (!isdigit(ch)) ch=getchar();
    while (isdigit(ch)) res=(res<<3)+(res<<1)+ch-48,ch=getchar();
    return res;
}
void GetRoot(int x,int fa){
    MaxSon[x]=0,Size[x]=1;
    for (int j=lnk[x];j;j=nxt[j]) if ((fa^son[j])&&!vis[son[j]]) GetRoot(son[j],x),Size[x]+=Size[son[j]],MaxSon[x]=max(MaxSon[x],Size[son[j]]);
    MaxSon[x]=max(MaxSon[x],Sigma-Size[x]);
    if (MaxSon[x]<MaxSon[Root]) Root=x;
}
void dfs(int x,int fa){
    stk[++top]=Dis[x];
    for (int j=lnk[x];j;j=nxt[j]) if ((son[j]^fa)&&!vis[son[j]]) Dis[son[j]]=Dis[x]+w[j],dfs(son[j],x);
}
inline int query(int x){
//这就是用来刷答案的
    for (int i=M;i;i--) Ans[i]|=*f.lower_bound(K[i]-x)==K[i]-x;
}
void Solve(int x){
    vis[x]=1,f.clear(),f.insert(0);
    for (int j=lnk[x];j;j=nxt[j]) if (!vis[son[j]]){
        top=0,Dis[son[j]]=w[j],dfs(son[j],x);
        for (int i=top;i;i--) query(stk[i]);
        for (int i=top;i;i--) f.insert(stk[i]);
    }
    for (int j=lnk[x];j;j=nxt[j]) if (!vis[son[j]]) Root=0,Sigma=Size[son[j]],GetRoot(son[j],0),Solve(Root);
}
int main(){
    N=read(),M=read();
    for (int i=1,x,y,z;i<N;i++) x=read(),y=read(),z=read(),add(x,y,z),add(y,x,z);
    for (int i=M;i;i--) K[i]=read();
//其实我刚开始这句话和下一行调换了一下顺序（当然对拍出来了），然后调试了好久。。。
    MaxSon[Root=0]=Sigma=N,GetRoot(1,0),Solve(Root);
    for (int i=M;i;i--) puts(U[Ans[i]]);
//Ans[i]用来存答案的
    return 0;
}
```
这段代码还用到了一个特技：set，因为可想而知，期望下可行路径数不会太多，于是在大牛分站呼吸了新鲜-O2的红黑树set变得飞快，而且内存又小，清空起来也很方便，随清随用
这段代码目前全站rk1，108ms，内存2.11MB，当然如果询问次数多的话楼上算法就更好了


---

## 作者：用户已注销 (赞：27)

点分治？没听说过，还是写一发**DSU On Tree（树上启发式合并）**好了~

个人拙见，**DSU On Tree**主要是解决一些**静态**的**子树信息查询**的问题，当然通过一些骚操作可以拓展。拓展到路径最常见的套路就是**强制该路径经过当前子树根节点**，然后DFS枚举每个点作为根节点。

点分治的思想主要是寻找重心作为根节点以优化复杂度，启发式的思想则类似树链剖分，每次计算贡献时先枚举轻儿子，计算后**清除贡献**，最后枚举重儿子，计算后**保留重儿子的信息**，最后依次枚举轻儿子，暴力将答案计入贡献。这样的复杂度是$O(N\log N)$的。

~~然而只写这么多过不了审核，所以~~接下来仔细解释一下算法的原理！因为网上其他的教程都太简短了！所以我才学了一整天！

首先到底为什么要清空轻儿子的贡献：比如本模板题中，我们找的是**强制经过当前根节点的路径**，所以我们要避免同一个子树内的节点互相乱访问，才要清空轻儿子的贡献。

然后就是这种做法的复杂度为什么能保证？因为对于每个轻儿子我都要使用一次暴力，所以每个点被暴力的次数是它头顶上轻儿子的个数。根据树链剖分的基本常识，每个点到根节点的轻点个数是$\log$级别的，所以所有点被访问的总次数是$O(N\log N)$，算法的复杂度是$O(MN\log N)$。

然后这个算法比点分治好的地方在于：编码特别简单，调试特别简单，而且普通数据下的复杂度一定比点分治要好（因为每个点头顶的轻儿子个数远少于$\log N$），尤其是链的情况下，DSU On Tree更是只要线性复杂度。

放一下代码（**不开O2**，57ms）：

```
#include <bits/stdc++.h>
#define lld I64d
using namespace std ;
inline long long Readin() {
    long long K = 0 , F = 1 ; char C = ' ' ;
    while( C < '0' or C > '9' ) F = C == '-' ? -1 : 1 , C = getchar() ;
    while( C <= '9' and C >= '0' ) K = ( K << 1 ) + ( K << 3 ) + C - '0' , C = getchar() ;
    return F * K ;
}
const int MaxQ = 100 + 10 ;
const int MaxN = 10000 + 10 ;
const int MaxM = 20000 + 10 ;
const int MaxK = 10000000 + 10 ;
int N , Q , Asks[MaxQ] ;
bool Anss[MaxQ] ;
int Cnt , Head[MaxN] , To[MaxM] , Next[MaxM] , Val[MaxM] ;
inline void Add( int U , int V , int W ) {
    Next[++Cnt] = Head[U] ;
    Head[U] = Cnt ;
    To[Cnt] = V ;
    Val[Cnt] = W ;
}
int Fa[MaxN] , Size[MaxN] , D[MaxN] , Hson[MaxN] ;
bool Apr[MaxK] ;
int Depp ;
void Dfs( int Nod ) {
    Size[Nod] = 1 ;
    for(register int i = Head[Nod] ; i ; i = Next[i] ) 
        if( To[i] ^ Fa[Nod] ) {
            Fa[To[i]] = Nod ;
            D[To[i]] = D[Nod] + Val[i] ;
            Dfs( To[i] ) ;
            if( Size[To[i]] > Size[Hson[Nod]] ) Hson[Nod] = To[i] ;
            Size[Nod] += Size[To[i]] ;
        }
}
inline void C( int Nod ) {
    for(register int i = 0 ; ++i <= Q ; )
        if( Asks[i] - D[Nod] + Depp >= 0 )
            Anss[i] |= Apr[Asks[i]-D[Nod]+Depp] ;
}
void Calc( int Nod ) {
    C( Nod ) ;
    for(register int i = Head[Nod] ; i ; i = Next[i] )
        if( To[i] ^ Fa[Nod] ) Calc( To[i] ) ;
}
void Upd( int Nod ) {
    Apr[D[Nod]] = true ;
    for(register int i = Head[Nod] ; i ; i = Next[i] )
        if( To[i] ^ Fa[Nod] ) Upd( To[i] ) ;
}
void Clear( int Nod ) {
    Apr[D[Nod]] = false ;
    for(register int i = Head[Nod] ; i ; i = Next[i] )
        if( To[i] ^ Fa[Nod] ) Clear( To[i] ) ;
}
void Dfs( int Nod , bool Tag ) {
    for(register int i = Head[Nod] ; i ; i = Next[i] )
        if( To[i] ^ Fa[Nod] and To[i] ^ Hson[Nod] ) Dfs( To[i] , true ) ;
    if( Hson[Nod] ) Dfs( Hson[Nod] , false ) ;
    Depp = D[Nod] << 1 ;
    Apr[D[Nod]] = true ;
    C( Nod ) ;
    for(register int i = Head[Nod] ; i ; i = Next[i] )
        if( To[i] ^ Fa[Nod] and To[i] ^ Hson[Nod] ) Calc( To[i] ) , Upd( To[i] ) ;
    if( Tag ) Clear( Nod ) ;
}
int main() {
    N = Readin() ;
    Q = Readin() ;
    for(register int i = 0 , U , V , W ; ++i < N ; ) {
        U = Readin() ;
        V = Readin() ;
        W = Readin() ;
        Add( U , V , W ) ;
        Add( V , U , W ) ;
    }
    for(register int i = 0 ; ++i <= Q ; Asks[i] = Readin() ) ;
    Dfs( 1 ) ;
    Dfs( 1 , false ) ;
    for(register int i = 0 ; ++i <= Q ; puts( Anss[i] ? "AYE" : "NAY" ) ) ;
    return 0 ;
}
/*
5 3
1 2 1
1 3 1
2 4 2
2 5 2
1 2 3
*/
```

---

## 作者：Youngsc (赞：22)

先挂一个博客[Youngsc](https://youngscc.github.io/)

学了~~淀粉质~~这种东西感觉就是神奇，感觉自己写的明明会T但最后rank1...

既然是点分治，那么就先套一个板子，核心就是work函数。

work里怎么写呢？ 假设我们要找的距离是$l$,我们可以先计算出子树里的点每一个点到子树重心的距离(如果不知道重心什么可以先去学一下，这里推荐一篇网上的博客[这里](http://blog.csdn.net/ALPS233/article/details/51398629)，讲的还是比较清晰的ORZ)，并将这些距离和对应的点属于中心的哪一个儿子下面打包在一起，按照距离从小到大排序。然后我们从小到大枚举每一个距离，并且二分查找能与其组合为$l$的距离。并从中挑选出一个所属儿子不同的距离，那么$l$就找到了。

听起来貌似复杂度很高的样子，但是鉴于点分治能将一棵树尽可能地分成较为平衡的几棵子树，时间复杂度可以做到$O(nlog^2n)$，当然具体是将复杂度因题目而异。


### 代码在这里


```cpp
# include <algorithm>
# include <iostream>
# include <cstring>
# include <cstdio>
# include <cmath>
# define R register
# define LL long long
# define N 10010

using namespace std;

int n,m,num,e,x,y,z,a[110],rt,size,siz[N],f[N],h[N];
bool ans[110],vis[N];

struct zx{int v,w,pre;}ed[N<<1];
struct yy{int d,w;} dis[N];

template <typename T> inline void maxx(R T& a,const T b){a<b? a=b:0;}

template <typename T> inline void in(R T& a){
    R char c=getchar();R T x=0,f=1;
    while(!isdigit(c)){if(c=='-') f=-1; c=getchar();}
    while(isdigit(c)) x=(x<<1)+(x<<3)+c-'0',c=getchar();
    a=x*f;
}

inline bool cmp(R yy a,R yy b){return a.d<b.d;}

inline void add(R int x,R int y,R int z){
    ed[++e]=(zx){y,z,h[x]};
    h[x] = e;
}

inline int search(R int x){//二分查找
    R int ret=0;
    R int l=1,r=num;
    while(l<=r){
        R int mid = l+r>>1;
        if(dis[mid].d<x) l=mid+1;
        else ret=mid,r=mid-1;
    }
    return ret;
}

inline void getroot(R int x,R int fa){//找重心
    f[x] = 0;
    siz[x] = 1;
    for(R int i=h[x]; i; i=ed[i].pre){
        R int p=ed[i].v;
        if(vis[p]||p==fa) continue;
        getroot(p,x);
        maxx(f[x],siz[p]);
        siz[x] += siz[p];
    }
    maxx(f[x],size-siz[x]);
    if(f[x] < f[rt]) rt = x;
}

inline void dfs(R int x,R int fa,R int wh,R int d){
    dis[++num] = (yy){d,wh};
    for(R int i=h[x]; i; i=ed[i].pre)
    {
        R int p=ed[i].v;
        if(vis[p]||p==fa) continue;
        dfs(p,x,wh,d+ed[i].w);
    }
}

inline void work(R int x){
    num=0;
    for(R int i=h[x]; i; i=ed[i].pre)
    {
        R int p=ed[i].v;
        if(vis[p]) continue;
        dfs(p,x,p,ed[i].w);
    }
    dis[++num] = (yy){0,0};
    sort(dis+1,dis+num+1,cmp);
    // for(R int i=1; i<=num; ++i) printf("%d ",dis[i].d);
    // printf("\n");
    for(R int i=1; i<=m; ++i)
    {
        if(ans[i]) continue;
        R int l=1;//meet 
        while(l<num&&dis[l].d+dis[num].d<a[i]) l++;
        while(l<num&&!ans[i]){
            if(a[i]-dis[l].d<dis[l].d) break;
            R int pot=search(a[i]-dis[l].d);
            while(l<=num&&dis[pot].d+dis[l].d==a[i]&&dis[pot].w==dis[l].w) pot++;
            if(dis[pot].d+dis[l].d==a[i]) ans[i]=1;
            l++;
        }
    }
    // printf("\n_______________\n");
}

inline void solve(R int x){
    vis[x] = 1;
    work(x);
    for(R int i=h[x]; i; i=ed[i].pre){
        R int p=ed[i].v;
        if(vis[p]) continue;
        rt = 0;
        siz[rt] = size = siz[p];
        getroot(p,0);
        solve(rt);
    }
}

int main(){
    in(n);in(m);
    for(R int i=1; i<n; ++i){
        in(x),in(y),in(z);
        add(x,y,z);
        add(y,x,z);
    }
    for(R int i=1; i<=m; ++i) in(a[i]);
    f[rt] = size = n;
    getroot(1,0);
    solve(rt);
    for(R int i=1; i<=m; ++i)
        if(ans[i]) printf("AYE\n");
        else printf("NAY\n");
}
#### (减少代码复制，共创美好洛谷)

```

---

## 作者：撤云 (赞：14)

[博客](https://www.cnblogs.com/hbxblog/p/9826679.html)  


来看一道题

>给定一棵有n个点的树  
询问树上距离为k的点对是否存在。  
对于30%的数据n<=100  
对于60%的数据n<=1000,m<=50  
对于100%的数据n<=10000,m<=100,c<=1000,K<=10000000  

首先来看一下30%的点(不要说太简单了，有时候暴力很有用)    
但事实上~~好水啊~~  
不是dfs的题吗？这是在你不会任何数据结构的情况下你能做的点，只需要枚举所有点对，在算出他们之间的距离，用一个标记数组将这个距离赋为1，询问的时候就直接判断距离是否为1就可以了。这样就好了，对于蒟蒻来说，会这个就可以了,但是如果你不满足这点分，继续往下看，这里就不提供代码了。

对于60%的点。
这个只要你会一点数据结构(lca)就够就可以做了，如果你不会，[戳这](https://www.luogu.org/problemnew/show/P3379) 如果你会，这就简单了,首先预处理出每一个点到根节点的距离dis。在枚举所有点对，他们之间的距离就是`dis[a]+dis[b]-2*dis[lca(a,b)];`用一个标记数组将这个距离赋为1，询问的时候就直接判断距离是否为1。开氧气(O2)可以获得70分。
```
#include<cstdio>
#include<cstdlib>
#include<iostream>
using namespace std;
int cnt=0,fa[500000],siz[500000],son[500000],dep[500000],top[500000],dfs[500000],head[500000],dis[500001];
struct node {
    int to,next,v;
} a[1000001];
void add(int x,int y,int c) {
    a[++cnt].to=y;
    a[cnt].next=head[x];
    a[cnt].v=c;
    head[x]=cnt;
}
void dfs1(int u,int f,int depth) {
    fa[u]=f;
    siz[u]=1;
    dep[u]=depth;
    for(int i=head[u]; i; i=a[i].next) {
        int v=a[i].to;
        if(v==f)
            continue;
        dis[v]=dis[u]+a[i].v;
        dfs1(v,u,depth+1);
        siz[u]+=siz[v];
        if(siz[v]>siz[son[u]]||son[u]==0)
            son[u]=v;
    }
}
int js;
void dfs2(int u,int t) {
    top[u]=t;
    if(son[u])
        dfs2(son[u],t);
    for(int i=head[u]; i; i=a[i].next) {
        int v=a[i].to;
        if(v!=fa[u]&&v!=son[u])
            dfs2(v,v);
    }
}
int lca(int x,int y) {
    while(top[x]!=top[y]) {
        if(dep[top[x]]<dep[top[y]])
            swap(x,y);
        x=fa[top[x]];
    }
    return  dep[x]<dep[y]?x:y;
}
int bj[1000001];
int main() {
    int n,m,s,x,y,v,k;
    scanf("%d%d",&n,&m);
    for(int i=1; i<n; i++)
        scanf("%d%d%d",&x,&y,&v),add(x,y,v),add(y,x,v);
    dfs1(1,0,1);
    dfs2(1,1);
    for(int i=1;i<=n;i++)
      for(int j=i+1;j<=n;j++)
            bj[dis[i]+dis[j]-2*dis[lca(i,j)]]=1;
    for(int i=1;i<=m;i++)
        scanf("%d",&k),bj[k]?printf("AYE\n"):printf("NAY\n");
}
```

对于100%
就要用到点分治了，现在来开始正式讲一讲点分治。

![](https://s1.ax1x.com/2018/10/21/iBOPSA.jpg)


假设现在k为5。我们可以发现，对于一个根节点，有两种情况会有答案，一种是在他的子树中，另一种是从一个节点到另一个节点并且穿过他。如对于根节点1,有(1,6),(1,4)，而对于根节点2(是对于子树的根节点)，有(4,5)满足条件。
    
会有两种情况满足条件，那么怎么处理?分点?太麻烦了，其实可以把这两种条件看为一种条件。
1. 如果答案穿过他，分成两条路径，以上图中的(4,5)说，可以看成(2,4)+(2,5)
2. 如果答案在他的子树中，则可以看成从他的一个子节点到他本身，穿过自己，到达他自己。以(1,4)来说，可以看成(1,4)+(1,1,)。自己到自己的距离为0。

那么根节点是什么呢？不同的根节点效率会不同

![](http://cloud1.gaitubao.net/FnC6ESc01L4FBDSrnxSZNuwFljQk?imageMogr2/quality/90/thumbnail/378x378!)

对于这张图当以1为更节点的时候我们要递归四层,而以3为根节点话只要递归两层。所以要正确选好根节点。那么什么是最好的根节点呢？重心。

###重心

什么是重心？三角形内三条中线交点？
但是这里的重心不是数学中的概念。
~~树的重心也叫树的质心。找到一个点,其所有的子树中最大的子树节点数最少,那么这个点就是这棵树的重心,删去重心后，生成的多棵树尽可能平衡。~~

上面来自百度百科
实际上重心可以用一句话说明:其所有的子树中最大的子树节点数最少
那么怎么求重心呢？只要一个树形dp就可以了，接下来直接上代码，相信应该都能理解吧

在上代码之前先申明一写变量定义
```cpp
int n,k;
int ans[10000001];/*储存答案*/
int dis[N];/*从当前节点i到枚举当前树的根节点父亲的距离*/(这里随便理解一下吧，我这么说是为了后面的容斥)
int f[N];/*当以i为根节点时最大子树大小*/
int vis[N];/*i节点是否被当根使用过*/
int siz[N];/*以i节点为根时,其子树(包括本身)的节点个数*/
int root;/*根节点*/
int sum;/*这棵当前递归的这棵树的大小*/
```

```cpp
void findroot(int k,int fa) {
    f[k]=0,siz[k]=1;
    for(int i=head[k]; i; i=a[i].next) {
        int v=a[i].to;
        if(vis[v]||v==fa)
            continue;
        findroot(v,k);
        siz[k]+=siz[v];
        f[k]=max(f[k],siz[v]);
    }
    f[k]=max(f[k],sum-siz[k]);
    if(f[k]<f[root])
        root=k;
}
```

对于`f[k]=max(f[k],sum-siz[k]);`这里有很多人不知道什么意思，我下面来讲一下

继续用上面的图
![](http://wx3.sinaimg.cn/mw690/0060lm7Tly1fwdvewbidvj30a4092wej.jpg)
假设你已经递归到了节点2，你的儿子有1,4,5(这是一个无根树)。但是你的递归并不会算1节点，所以需要这一段话来判断他的包含他"父亲"的子树大小是否时最大的。

当找到重心以后就可以找出每个点与重心的距离.在统计答案就可以了  
对于这道题目可以直接n²的枚举就可以了，但对于别的题，需要别的方法，如二分。
看看这一题是如何判的
```cpp
void calc(int k,int l,int c) {
    tot=0;
    finddep(k,0,l);
    for(int i=1; i<=tot; i++)
        for(int j=1; j<=tot; j++)
            ans[dis[i]+dis[j]]+=c;
}
```

但是对于统计答案要注意一点的就是路径会重复算。上图中如果k=7那么对于(1,4),(1,5)这也是个答案,但是这并不是个答案.路径(1,2)被算了两次.所以我们要将重复的路径去掉就可以了  

那么怎么去掉呢?只要每次在递归的时候对于儿子节点,将所有儿子节点的子树满足条件的删掉就可以了,也就是dis和为k,注意这里的dis算的是所有子节点到这个儿子节点父亲的距离.

```cpp
void devide(int k) {
    vis[k]=1;
    calc(k,0,1);
    for(int i=head[k]; i; i=a[i].next) {
        int v=a[i].to;
        if(vis[v])
            continue;
        calc(v,a[i].v,-1);//就是这一段话
        root=0,sum=siz[v];
        findroot(v,0);
        devide(root);
    }
}
```


接下来上代码
```cpp
// luogu-judger-enable-o2
// luogu-judger-enable-o2
// luogu-judger-enable-o2
// luogu-judger-enable-o2
#include<bits/stdc++.h>
using namespace std;
const int N=10001;
int read() {
    int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9')c=='-'?f=-1,c=getchar():c=getchar();
    while(c>='0'&&c<='9') x=x*10+c-'0',c=getchar();
    return x*f;
}
int n,k;
int ans[10000001];/*储存答案*/
int dis[N];/*从当前节点i到枚举当前树的根节点父亲的距离*/(这里随便理解一下吧，我这么说是为了后面的容斥)
int f[N];/*当以i为根节点时最大子树大小*/
int vis[N];/*i节点是否被当根使用过*/
int siz[N];/*以i节点为根时,其子树(包括本身)的节点个数*/
int root;/*根节点*/
int sum;/*这棵当前递归的这棵树的大小*/
struct node {
    int next,to,v;
} a[N<<1];
int head[N],cnt;
void add(int x,int y,int c) {
    a[++cnt].to=y;
    a[cnt].next=head[x];
    a[cnt].v=c;
    head[x]=cnt;
}
void findroot(int k,int fa) {
    f[k]=0,siz[k]=1;
    for(int i=head[k]; i; i=a[i].next) {
        int v=a[i].to;
        if(vis[v]||v==fa)
            continue;
        findroot(v,k);
        siz[k]+=siz[v];
        f[k]=max(f[k],siz[v]);
    }
    f[k]=max(f[k],sum-siz[k]);
    if(f[k]<f[root])
        root=k;
}
int tot;
void finddep(int k,int fa,int l) {
    dis[++tot]=l;
    for(int i=head[k]; i; i=a[i].next) {
        int v=a[i].to;
        if(v==fa||vis[v])
            continue;
        finddep(v,k,l+a[i].v);
    }
}
void calc(int k,int l,int c) {
    tot=0;
    finddep(k,0,l);
    for(int i=1; i<=tot; i++)
        for(int j=1; j<=tot; j++)
            ans[dis[i]+dis[j]]+=c;
}
void devide(int k) {
    vis[k]=1;
    calc(k,0,1);
    for(int i=head[k]; i; i=a[i].next) {
        int v=a[i].to;
        if(vis[v])
            continue;
        calc(v,a[i].v,-1);
        root=0,sum=siz[v];
        findroot(v,0);
        devide(root);
    }
}
int main() {
    int n=read(),m=read(),x,y,z;
    for (int i=1; i<n; i++)
        x=read(),y=read(),z=read(),add(x,y,z),add(y,x,z);
    sum=f[0]=n;
    findroot(1,0);
    devide(root);
    for (int i=1; i<=m; i++) {
        int k=read();
        puts(ans[k]?"AYE":"NAY");
    }
    return 0;
}
```

---

## 作者：YellowBean_Elsa (赞：10)

点分治本质上就是树上应用分治思想。

比如本题路径长度，可以分为过根和存在于子树内两种。

过根的我们直接算，子树内的我们递归处理。

为了使递归更快结束，我们每次取树的重心为根。

淀粉质还要注意一下几点：

1. 分治的时候重新求重心也要重新求子树 size（其实就是用一个函数就行了）

1. 点分治的遍历与普通的树不同，要开 vis 数组，因为遍历顺序不是按深度来的

1. 分治通用的易错点：不要用 memset！！！

[神仙 niiick 的题解讲的太好了](https://www.luogu.com.cn/blog/niiick/solution-p3806)

（但是求重心的函数有一点写错了233）

```cpp
//coder: FeliksGM-YB
#include<bits/stdc++.h>
#define fu(i,a,b) for(int i = a, I = (b) + 1; i < I; ++i)
#define fd(i,a,b) for(int i = a, I = (b) - 1; i > I; --i)
#define go(x) for(int i=first[x],y=v[i];i;i=nex[i],y=v[i])
typedef long long ll;
using namespace std;
const int N=1e5+5;
const int M=1e7+5;
inline int Max(int x,int y){
	if(x>y)return x;
	return y;
}
inline int read(){
    int x=0;char ch=getchar();
    while(!isdigit(ch))ch=getchar();
    while(isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();
    return x;
}int n,m,rt;//rt: 重心 
int v[N<<1],nex[N<<1],first[N],w[N<<1],tot;
inline void add(int x,int y,int z){
    v[++tot]=y,w[tot]=z;
    nex[tot]=first[x];
    first[x]=tot;
}int q[N];
int mx[N],sum;
int sz[N];
bool vis[N];
void getrt(int x,int f){//找重心 
	sz[x]=1;mx[x]=0;
	go(x){
		if(y==f || vis[y])continue;
		getrt(y,x);
		sz[x]+=sz[y];
		mx[x]=Max(mx[x],sz[y]);
	}mx[x]=Max(mx[x],sum-sz[x]);
	if(mx[x]<mx[rt])rt=x;
}bool tes[N],ext[M];
int dis[N],rem[N],cnt;
//rem记录当前子树中找到的路径长度有哪些 
void getdis(int x,int f){
	rem[++cnt]=dis[x];
	go(x){
		if(y==f || vis[y])continue;
		dis[y]=dis[x]+w[i];
		getdis(y,x);
	}
}int used[N],num;
inline void calc(int x){
	num=0;
	go(x){
		if(vis[y])continue;
		cnt=0;dis[y]=w[i];
		getdis(y,x);//处理这棵子树里的点到根 x 的距离 
		fu(j,1,cnt){
			fu(k,1,m){
				if(q[k]-rem[j]>=0 && q[k]-rem[j]<=1e7 &&
				ext[q[k]-rem[j]])tes[k]=1;
				//如果和 rem[j] 和为 q[k] 的路径存在 
			}
		}fu(j,1,cnt)//把这棵子树的路径长度也记为存在 
			if(rem[j]<=1e7)used[++num]=rem[j],ext[rem[j]]=1;
		//我不知道niiick的题解没有判 <=1e7 是怎么过的 QwQ 但它确实过了（亲测） 
	}fu(i,1,num)ext[used[i]]=0;//分治的清零都不能 memset！！！ 
}
void solve(int x){
	vis[x]=ext[0]=1;
	calc(x);//处理经过 x 的路径 
	go(x){//分治 x 为根的这棵树 
		if(vis[y])continue;
		mx[rt=0]=sum=sz[y];//这里要注意 
		getrt(y,0);solve(rt);
	}
}
int main(){
    n=read(),m=read();
    fu(i,1,n-1){
        int x=read(),y=read(),z=read();
        add(x,y,z),add(y,x,z);
    }fu(i,1,m)q[i]=read();
    mx[rt]=sum=n;
    getrt(1,0);
    solve(rt);//以重心为根分治 
    fu(i,1,m){
    	if(tes[i])puts("AYE");
    	else puts("NAY");
	}return 0;
}//Θ
```


---

## 作者：wcl95716 (赞：6)




```cpp
#include <bits/stdc++.h>
using namespace std;
#define mo 100005
#define mk make_pair
vector< pair<int ,int > > d[mo];//箭头加空格
int sz[mo];//树的重心..
int sd[mo];//树的重心..
int dist[mo];//计算到重心的距离
int shux[mo];//标记点是从哪个子树下的
bool de[10000005];//标记k是否出现过 
int jl[mo];//删除树的重心标记
int zz;
void dfsz(int node,int dad,int &maxs,int &v,int n) //计算树的重心
{
    sz[node]=1;
    for(int i=0;i<d[node].size();i++)
    {
        int son=d[node][i].first;
        if(son!=dad&&!jl[son])
        {
            dfsz(son,node,maxs,v,n);
            sz[node]+=sz[son];
            if(sz[son]<maxs)
            {
                maxs=sz[son];
                v=son;
            }
        }
    }
    if(n-sz[node]<maxs)
    {
        maxs=n-sz[node];
        v=node;
    }
}
void dis(int node,int dad,int s,int &l,int j) //计算点到重心的距离
{
    dist[l]=s;
    shux[l]=j;//标记属于哪个子树
    l++;
    if(dad==0) j=2;
    for(int i=0;i<d[node].size();i++)
    {
        int son=d[node][i].first;
        int ls=d[node][i].second;
        if(dad==0) j++;//只有dad为初始值的时候分子树编号
        if(son!=dad&&!jl[son])
        {
            dis(son,node,s+ls,l,j);
        }
    }
}
int shu(int k,int v,int d)//标记k是否出现过
{
    int l=0;
    memset(shux,0,sizeof(shux));
    dis(v,0,d,l,0);
    for(int i=0;i<l;i++)
    {
        for(int j=i+1;j<l;j++)
        {
            if(shux[i]!=shux[j])//只有不同的子树可以相加
            {
                //cout<<shux[i]<<' '<<shux[j]<<' '<<dist[i]<<' '<<dist[j]<<' '<<dist[i]+dist[j]<<' '<<i<<' '<<j<<endl;
                de[dist[i]+dist[j]]=1;
            }
        }
    }
    return 0;
}
void dx(int node,int dad,int &l)//计算树的大小
{
    l++;
    for(int i=0;i<d[node].size();i++)
    {
        int son=d[node][i].first;
        if(son!=dad&&!jl[son])
            dx(son,node,l);
    }
}
void dfs(int x,int &ans,int k)//树的分治递归
{
    int n=0;
    dx(x,0,n);//首先判断大小
    int mins=10000005,v=x;
    dfsz(x,0,mins,v,n);//之后机选树的重心
    shu(k,v,0); //再去寻找距离重心的距离和距离为k 的数对
    jl[v]=1;
    for(int i=0;i<d[v].size();i++)
    {
        int son=d[v][i].first;
        if(!jl[son])
        {
            int le=d[v][i].second;
            //ans-=shu(k,son,le);
            dfs(son,ans,k);
        }
    }
   //jl[v]=0;
}
int main()
{
    int n,m,k;
    while(scanf("%d%d",&n,&m)!=EOF)
    {
        memset(de,false,sizeof(de));
        int x,y,z;
        for(int i=1;i<n;i++)
        {
            //cin>>x>>y>>z;
            scanf("%d%d%d",&x,&y,&z);
            d[x].push_back(mk(y,z));
            d[y].push_back(mk(x,z));
        }
        int ans=0;
        dfs(1,ans,k);
        for(int i=0;i<m;i++)
        {
            //cin>>k;
            scanf("%d",&k);
            if(de[k]) //cout<<"AYE"<<endl;
            printf("AYE\n");
            else //cout<<"NAY"<<endl;
            printf("NAY\n");
        }
    }
}

```

---

## 作者：日月影 (赞：6)

本人刚学点分，若有错误请各位见谅；

题目要求距离为k的点是否存在，所以很容易想到将所有的距离求出，再一一判断；由于k<=1千万，所以用一个bool型数组可以装下；先找每颗子树的**重心**以降低时间复杂度（下方的getroot（）函数）  再以重心为根递归建树。树建好后，用d[]数组记录子树中各点到根的距离，将各距离存入rp[]数组，待递归完后，以双重循环找点到（不同子树的）点的距离，将bool型数组更新；

反复如此，将所有情况考虑。


代码如下：

    
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,m;
struct data
{
    int pre,to,w;
}p[20010];           //  邻接表存边 
int head[10010],tot;//
int sum;   //子树的总点数 
int root;  //当前子树的根 
int f[10010],son[10010];  //f为除去根时得到的最大连通块，son为以i为根的子树的节点 
bool vis[10010];  //是否访问（标记） 
int d[10010];  //i到当前根的距离 
bool ko[10000100];  //bool型数组，k是否存在 
struct node
{
    int dis;
    int which;
}rp[1001000];
int tt;
void add(int x,int y,int w)  //加边 
{
    p[++tot]=(data){head[x],y,w};
    head[x]=tot;
}
void getroot(int u,int papa)  //找重心 
{
    son[u]=1;
    f[u]=0;
    for(int i=head[u];i;i=p[i].pre)
    {
        int v=p[i].to;
        if(vis[v]||v==papa)  continue;
        getroot(v,u);
        son[u]+=son[v];
        f[u]=max(f[u],son[v]);  //注意：f存的是最大连通块 
    }
    f[u]=max(f[u],sum-son[u]);
    if(f[u]<f[root])  root=u;  //更新重心 
}
int pp;  //以同一点为根的子树编号 
void getdeep(int rearoot,int u,int fa,int ro)  //得到点到根的距离 
{
    for(int i=head[u];i;i=p[i].pre)
    {
        int v=p[i].to;
        if(vis[v]||v==fa)  continue;  //去重 
        if(u==rearoot) pp++;   //子树编号******* 
        d[v]=d[u]+p[i].w;
        if(u==rearoot) rp[++tt]=(node){d[v],pp};
        else
        rp[++tt]=(node){d[v],ro};
        ko[d[v]]=1;  //更新k的可能值 
        if(rearoot==u)
        getdeep(rearoot,v,u,pp);
        else  getdeep(rearoot,v,u,ro);  //下一个 
    }
}
void getans(int u)  
{
    d[u]=0;tt=0;pp=0;
    getdeep(u,u,0,0);
    vis[u]=1;
    for(int i=1;i<=tt;i++)   //！！！！！注意，十分重要 
    {
        for(int j=i+1;j<=tt;j++)
        {
            if(rp[i].which!=rp[j].which)   //具体为何请自行思考 
            {
                ko[rp[i].dis+rp[j].dis]=1;
            }
        }
    }
    for(int i=head[u];i;i=p[i].pre)
    {
        int v=p[i].to;
        if(!vis[v])  //去重 
        {
            root=0;  //  ！！ 
            sum=son[v]; //  ！！ 
            getroot(v,0);//得到子树的重心 
            getans(root);  //以重心建树 
        }
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    int a,b,c;
    for(int i=1;i<=n-1;i++)
    {
        scanf("%d%d%d",&a,&b,&c);
        add(a,b,c);add(b,a,c);  //加边 
    }
    sum=f[0]=n;  //注意：sum值必须更新   （请思考） 
    root=0;     //注意：root值必须更新 
    getroot(1,0);  //找重心 
    getans(root);  //以重心建树找k值 
    int kk;
    for(int i=1;i<=m;i++)    //判断是否存在 
    {
        scanf("%d",&kk);
        if(ko[kk]==1)  printf("AYE\n");
        else  printf("NAY\n");
    }
    return 0;
}
```

---

## 作者：于丰林 (赞：5)

1.什么是点分治？

首先，分治大家应该很了解了吧，那么点分治其实与分治同理，就是将复杂的问题分解为很多很多细小的子问题，从而减少时间复杂度，就拿这道题来说，利用点分治就明显比爆搜快很多。。。

2.点分治的原理：

先来看一张图片（不错，是我盗的图（滑稽。。。））
![qwq](https://img2018.cnblogs.com/blog/1538839/201902/1538839-20190218201515910-455348165.png)

显然我们如果要求两点之间的距离，只有两种情况：经过根节点或者不经过根节点。并且第二种情况可以通过换根来转化为第一种情况，那么我们就可以愉快的进行分治了qaq

3.如何实现？

上面提到了一些原理，但是如果是这样的一张图呢？
![](https://img2018.cnblogs.com/blog/1538839/201902/1538839-20190218202520880-989551946.png)

如果还是找根的的话你基本就凉凉了。。。

因此，我们期望将分成的两个树越平均越好，重心就诞生啦！！！

树重心的定义：找到一个点,其所有的子树中最大的子鼠节点数最少,那么这个点就是这棵鼠的重心,删去重心后，生成的多棵鼠尽可能平衡（不知道知否正确）

4.重点来了！！！

铺垫基本做完了，现在来讲这道题：

其实也是比较简单的，由于没有强制在线，所以可以离线操作（废话）。

我们从重心开始枚举子树的根节点，依次递归下去，每一次遇到满足题意的就++就可以啦！

最后，附上本题代码：（代码中有详解qaq）

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int inf=10000000;
const int maxn=100010;
struct EDGE//链前存边
{
    int to,val,nxt;
} edge[maxn<<1];
int head[maxn]/*链前附带物*/,cnt/*边数*/,maxp[maxn]/*子树的最大大小*/,size[maxn]/*子树大小*/,dis[maxn]/*x点到重心的距离*/;
int vis[maxn]/*访问标记*/,test[105]/*记录是否可行*/,ju[inf]/*判断是否存在这个距离*/,q[maxn]/*用于清除ju数组*/,rem[maxn]/*记录距离*/;
int query[1010]/*记录询问*/;
int sum/*（子）树的大小和*/,root/*重心*/,n,m;
void add(int x,int y,int z)//链前加边
{
    edge[++cnt].val=z;
    edge[cnt].to=y;
    edge[cnt].nxt=head[x];
    head[x]=cnt;
}
void getroot(int id,int fa)//找重心 
{
    size[id]=1;
    maxp[id]=0;
    for(int i=head[id]; i; i=edge[i].nxt)//链前遍历 
    {
        if(edge[i].to==fa||vis[edge[i].to]!=0)
        {
            continue;
        }
        getroot(edge[i].to,id); 
        size[id]+=size[edge[i].to];//回溯时的大小加和 
        maxp[id]=max(size[edge[i].to],maxp[id]);//记录子树大小的最大值 
    }
    maxp[id]=max(maxp[id],sum-size[id]);//判断两个子树大小，记录最大值 
    if(maxp[id]<maxp[root])//判断所选重心是否合法 
    {
        root=id; 
    }
}
void getdis(int id,int fa)//求距离，没啥好说的吧。。。 
{
    rem[++rem[0]]=dis[id];
    for(int i=head[id]; i; i=edge[i].nxt)
    {
        if(edge[i].to==fa||vis[edge[i].to]!=0)
        {
            continue;
        }
        dis[edge[i].to]=dis[id]+edge[i].val;
        getdis(edge[i].to,id);
    }
}
void clac(int id)
{
    int now=0;
    for(int i=head[id]; i; i=edge[i].nxt)
    {
        if(vis[edge[i].to]!=0)
        {
            continue;
        }
        rem[0]=0;//利用rem【0】来实现一个变量的作用 
        dis[edge[i].to]=edge[i].val;//加上邻边的距离 
        getdis(edge[i].to,id);//继续向下找 
        for(int j=rem[0]; j; j--)
        {
            for(int k=1; k<=m; k++)//枚举每一个询问 
            {
                if(query[k]>=rem[j])//如果大于或等于则找另一半 
                {
                    test[k]|=ju[query[k]-rem[j]];//右面一项为1就返回1，为0就返回0 
                }
            }
        }
        for(int j=rem[0]; j; j--)//存入可行解 
        {
            q[++now]=rem[j];
            ju[rem[j]]=1;
        }
    }
    for(int i=1; i<=now; i++)//清零 
    {
        ju[q[i]]=0;
    }
}
void slove(int id)
{
    vis[id]=ju[0]=1;//标记为找过 
    clac(id);//以id为根进行扩散 
    for(int i=head[id]; i; i=edge[i].nxt)//逐个遍历 
    {
        if(vis[edge[i].to]!=0)
        {
            continue;
        }
        sum=size[edge[i].to];//更新sum值为目前to点的子树大小总和 
        root=0;
        maxp[root]=inf;
        getroot(edge[i].to,0);
        slove(root);//逐个判断 
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1; i<=n-1; i++)//加边 
    {
        int x,y,z;
        scanf("%d%d%d",&x,&y,&z);
        add(x,y,z);
        add(y,x,z);
    }
    for(int i=1; i<=m; i++)//储存询问的要求
    {
        scanf("%d",&query[i]);
    }
    maxp[root]=sum=n;//初始将其设为最大，从而确定重心
    getroot(1,0);//找重心
    slove(root);//开干
    for(int i=1; i<=m; i++)//华丽的输出结果
    {
        if(test[i]!=0)
        {
            printf("AYE\n");
        }
        else
        {
            printf("NAY\n");
        }
    }
    return 0;
}
```

---

## 作者：pyqpyq (赞：4)

上链接：[点分治模板](https://www.luogu.com.cn/problem/P3806) [Tree](https://www.luogu.com.cn/problem/P4178) [Race](https://www.luogu.com.cn/problem/P4149) [聪聪可可](https://www.luogu.com.cn/problem/P2634) 

发现了这些题的共同特点没有？~~都是紫题。~~ 都是与树上路径有关的题目。

此时点分治就派上用场了。
# 算法分析
***
顾名思义，点分治，就是基于点的分治算法，类似的还有边分治。~~但我不会。~~ 让我们以模板题为例讲解。

由于是无根树，为了方便处理，我们首先指定一个根。

然后所有的树上路径就可以分成两类：经过根的和不经过根的。
***
经过根的路径的长度可以直接算出，就等于路径两端点到根的长度。

这里可以直接预处理一遍每个节点到根的长度。然后依次处理根的每个子树的所有节点，对于每个询问，查找之前的子树中是否刚好有节点到根节点的长度与当前处理的节点到根节点的长度加起来满足此询问的。

~~头晕吗，待会看代码就理解了。~~

Q: 那么为什么一定要在之前的子树查找而不是直接在前面的节点呢？

A: 因为如果不这样的话，就会发生两个节点在同一个子树的情况，此时这两个节点间的最短路径就不会经过当前根了，与前面条件矛盾。

（当然别的题解也有它们自己的处理方法。）

Q: 那要每次都要扫一遍之前的子树的节点吗？那复杂度不是飙升吗？

A: 不必，观察到 $K \le 10^7$，这意味着开一个大小为 $10^7$ 的桶记录一下之前经过的子树的节点到根的长度就行了。

为了满足查找的是之前的子树，我们可以先 dfs 一遍当前子树的所有节点进行询问，在 dfs 一遍当前子树的所有节点并把它到根的长度插入桶中。

根到点的距离要特殊处理一下。
***
那不经过根的路径呢？

我们可以分治处理，即把当前根删掉后，找到根，并且按照处理经过根的路径的方法处理每棵子树，并且继续分治……

由于每个节点一定都会被当成一次根，所以每条路径都会被处理到。而且每次分治时子树中没有被当成过根的节点，所以每条路径只会处理一次。

进过上述分析，我们会发现：每次点分治的时间复杂度为 $O(size_i * m)$（$size_i$ 为子树大小），那每层分治的时间复杂度为 $O(nm)$ 的（分治的层数即递归层数）。

因为每次在每个点的询问的复杂度为 $O(m)$，插入、求距离的复杂度为 $O(1)$。且原树在同一层被分成了许多子树，遍历时同一层的子树之间不会遍历到别的子树里去。

那么最终的时间复杂为 $O(nmh)$（$h$ 为分治总层数）

然而 $h$ 最大可以是 $n$，也就是说最终时间复杂度会被卡成 $O(n^2m)$ 的，显然和暴力枚举一个级别。

问题出在哪了呢？就在于根的选择。如果每次选择当前子树的重心作为根的话，$h$ 可以降到 $\log n$ 级别。

想看重心证明请点[这](https://www.luogu.com.cn/blog/150384/shu-di-zhong-xin-xiang-guan-gai-nian-yu-zheng-ming)（其实是避免题解篇幅过长就搬到 blog 里去了）。

最后上代码：
# 代码分析
## 变量定义
```cpp
int n,m,a,b,c,k;//读入的数
int firs[10011],neig[20011],arri[20011],valu[20011]/*链式前向星存树*/,quer[111]/*询问*/;
int ifzx[10011]/*当前节点是否是重心*/,size[10011]/*当前子树的大小*/,dist[10011]/*到根节点的距离*/,ifok[111]/*此询问是否满足*/;
bool quet[10000011];//桶
```
## 点分治主函数
```cpp
int dfz(int at/*最初的根*/,int si/*当前子树大小*/)
{
	int zf;//记录以最初的根为根时的重心之父
	ask(at,0,si,at,zf);//求重心
	size[zf]=si-size[at];//更新重心之父的子树大小
	ifzx[at]=1;//标记重心
	for(int i=firs[at]; i; i=neig[i])
		if(!ifzx[arri[i]])//与其他子树用之前的重心隔绝
			dfz(arri[i],size[arri[i]]);//继续分治
	quet[0]=1;
	dist[at]=0;//特殊处理根
	dis(at,at,0);//求节点离根的距离
	for(int i=firs[at]; i; i=neig[i])
	{
		if(!ifzx[arri[i]])//同上
		{
			que(arri[i],at);//询问
			add(arri[i],at);//插入
		}
	}
	for(int i=0; i<m; ++i)
		if(quet[quer[i]])
			ifok[i]=1;//特殊处理根
	ifzx[at]=0;//删除标记
	toz(at,at);//桶归零
}
```
## 求重心
```cpp
int ask(int at/*当前根*/,int fa/*父亲*/,int si/*当前分治的整个子树的大小*/,int&zx/*重心的引用*/,int&zf/*重心之父的引用*/)
{
	bool pd=1;//判断是否是重心
	size[at]=1;
	for(int i=firs[at]; i; i=neig[i])
		if(!ifzx[arri[i]]&&arri[i]!=fa)//不能递归回父亲且不能递归到其他子树
		{
			if(ask(arri[i],at,si,zx,zf)>si/2)//如果大于整棵子树的一半
				pd=0;//不是重心
			size[at]+=size[arri[i]];
		}
	if(pd&&size[at]>=si/2)//儿子和父亲都不大于整棵子树的一半
	{
		zx=at;//记录重心
		zf=fa;//记录重心之父
	}
	return size[at];
}
```
这里用了引用，它的作用可以在函数内改变函数外的局部变量的值。
## 求距离
```cpp
void dis(int at,int fa,int va)
{
	if((dist[at]=dist[fa]+va)>10000000)
	{
		dist[at]=-1;
		return;
	}
	for(int i=firs[at]; i; i=neig[i])
		if(!ifzx[arri[i]]&&arri[i]!=fa)
			dis(arri[i],at,valu[i]);
}
```
注意 $c$ 的和可以达到 $10^8$ 级别，而桶只开了 $10^7$。 所以发现 $dist_i$ 大于 $10^7$ 时标记为 -1 并立即结束。~~否则都不知道怎么 RE 的。~~
## 询问、插入和归零
```cpp
oid que(int at,int fa)
{
	if(dist[at]==-1)
		return;
	for(int i=0; i<m; ++i)
		if(dist[at]<=quer[i]&&quet[quer[i]-dist[at]])
			ifok[i]=1;
	for(int i=firs[at]; i; i=neig[i])
		if(!ifzx[arri[i]]&&arri[i]!=fa)
			que(arri[i],at);
}
void add(int at,int fa)
{
	if(dist[at]==-1)
		return;
	else
		quet[dist[at]]=1;
	for(int i=firs[at]; i; i=neig[i])
		if(!ifzx[arri[i]]&&arri[i]!=fa)
			add(arri[i],at);
}
void toz(int at,int fa)
{
	if(dist[at]==-1)
        return;
    else
		quet[dist[at]]=0;
	for(int i=firs[at]; i; i=neig[i])
		if(!ifzx[arri[i]]&&arri[i]!=fa)
			toz(arri[i],at);
}
```
三个函数大同小异。注意复制粘贴的时候要改名。~~否则都不知道怎么 WA 的。~~
# 最后
完整代码和主函数不放了。

最开头所放的四个题其实代码和思路都差不多。做完这题后想水经验的可以去做一下。

~~四倍经验啊不要白不要。~~

有兴趣的还可以去研究一下动态点分。~~我不会别问我。~~

完结撒花\\(^o^)/

---

## 作者：假装思考 (赞：3)

```
#include<bits/stdc++.h>
#define INF 1<<29
using namespace std;
struct Xjh{
    int Next,Ver,Weight;
}E[600001];
int n,m,Cnt=1,Head[60001];
int Size[60001],Dis[60001],Que[60001],Maxp[60001],Rem[60001],Q[60001];
bool Vis[60001],Test[60001],Judge[1000001];
int Sum,Root,Rem_Cnt;
void Add_Edge(int x,int y,int z){
    E[++Cnt].Ver=y;
    E[Cnt].Weight=z;
    E[Cnt].Next=Head[x];
    Head[x]=Cnt;
}
void Get_Root(int u,int f){
    Size[u]=1;							//size[i]保存以i为根的树的大小 
    Maxp[u]=0;							//Maxp[i]保存当前处理的树去掉i后的最大联通快(树)的大小 
    for(int i=Head[u],v;i;i=E[i].Next){	//遍历子节点 
        if((v=E[i].Ver)==f||Vis[v])
            continue;
        Get_Root(v,u);					//递归处理子树 
        Size[u]+=Size[v];				//更新size[] 
        Maxp[u]=max(Maxp[u],Size[v]);	//用子树大小更新Maxp 
    }
    Maxp[u]=max(Maxp[u],Sum-Size[u]);	//用"上面"更新Maxp 
    if(Maxp[u]<Maxp[Root])				//更新Root 
        Root=u;
}
void Get_Dis(int u,int f){
    Rem[++Rem_Cnt]=Dis[u];				//将计算好的长度保存 
    for(int i=Head[u],v;i;i=E[i].Next){	//遍历子节点 
        if((v=E[i].Ver)==f||Vis[v])
            continue;
        Dis[v]=Dis[u]+E[i].Weight;		//更新长度 
        Get_Dis(v,u);					//递归处理 
    }
}
void Calc(int u){
    int Tot=0;
    for(int i=Head[u],v;i;i=E[i].Next){	//遍历子节点 
        if(Vis[v=E[i].Ver])continue;
        Rem_Cnt=0;						//Rem[]用来保存该子树中每个节点到根的距离 
        Dis[v]=E[i].Weight;
        Get_Dis(v,u);					//获取子树中的每个节点到根的距离 
        for(int j=Rem_Cnt;j;--j)		//离线更新答案,Test[i]保存第i个询问是否可行 
            for(int k=1;k<=m;++k)
                if(Que[k]>=Rem[j])		//Judge[i]保存到根节点距离为i的节点是否存在 
                    Test[k]|=Judge[Que[k]-Rem[j]];
        for(int j=Rem_Cnt;j;--j)		//更新Judge[] 
            Q[++Tot]=Rem[j],Judge[Rem[j]]=1;	//Q[]里面放更新过的Judge,以便重置Judge 
    }
    for(int i=1;i<=Tot;++i)
        Judge[Q[i]]=0;
}
void Solve(int u){
    Vis[u]=Judge[0]=1; 		//标记重心为使用过 
    Calc(u);				//更新答案 
    for(int i=Head[u],v;i;i=E[i].Next){	//处理各子树 
        if(Vis[v=E[i].Ver])
            continue;
        Sum=Size[v];
        Maxp[Root=0]=Sum;
        Get_Root(v,0);		//找子树重心 
        Solve(Root);		//递归处理子树 
    }
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<n;++i){
        int x,y,z;
        scanf("%d%d%d",&x,&y,&z);
        Add_Edge(x,y,z);
        Add_Edge(y,x,z);
    }
    for(int i=1;i<=m;++i)		//m<=100,离线处理 
        scanf("%d",&Que[i]);
    Maxp[Root]=Sum=n;
    Get_Root(1,0);				//先找重心 
    Solve(Root);				//从重心开始处理 
    for(int i=1;i<=m;++i)
        if(Test[i])
            puts("AYE");
        else
            puts("NAY");
    return 0;
}
```

---

## 作者：封禁用户 (赞：3)

嗯..上语文课自己YY出来的点分治,完全不知道其他dalao们是怎么写的

我的思路大概是三遍DFS 第一遍找出树的重心

第二遍以重心为根 算出所有子树的大小 所有点到根节点的距离 以及整棵树的DFS序

第三遍就是算法的核心 递归计算结果 具体见代码注释

```cpp
// luogu-judger-enable-o2
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/* 
 * File:   main.cpp
 * Author: Ytong
 *
 * Created on 2018年1月26日, 下午12:56
 */

#include <cstdlib>
#include <vector>
#include <iostream>
#include <cstring>
#include <algorithm>
using std::vector;
using std::cin;
using std::cout;
using std::endl;
using std::vector;
using std::max;
using std::min;

using int_t = long int;
const int_t LARGE = 10000;
//统计[start,end]内满足*a+*b==k的数对数

int_t countN(int_t* start, int_t * end, int_t k) {
    int_t result = 0;
    while (start < end) {
        if (*start + *end == k) {
            result++;
            int_t * temp = end;
            while (*(temp - 1) == *temp && start < temp) {
                temp--;
                result++;
            }
            start++;
        } else if (*start + *end < k) {
            start++;
        } else {
            end--;
        }
    }
    return result;
}

struct Edge {
    int_t to;
    int_t weight;

    Edge(int_t to, int_t weight) :
    to(to), weight(weight) {
    }

};
vector<Edge> graph[LARGE + 1];
int_t size[LARGE + 1];
int_t dfsSeq[LARGE + 1];
int_t dis[LARGE + 1];
int_t n, m;
int_t root;
int_t temp[LARGE + 1];
//第一个DFS 找重心
int_t massCenter = -1;
int_t massCenterSize = 0x7fffffff;

int_t DFS1(int_t vertex, int_t from = -1) {
    int_t result = 0;
    int_t _size = 1;
    for (Edge& x : graph[vertex]) {
        if (x.to != from) {
            int_t _temp = DFS1(x.to, vertex);
            result = max(result, _temp);
            _size += _temp;
        }
    }
    result = max(result, n - _size);
    if (result < massCenterSize) {
        massCenterSize = result;
        massCenter = vertex;
    }
    return _size;
}
//基于新的树根 求出所有子树的大小 所有点到根节点的权值 所有点的DFS序
//返回子树的大小

int_t DFS2(int_t vertex, int_t from = -1, int_t dis_ = 0) {
    dfsSeq[++dfsSeq[0]] = vertex;
    int_t currSize = 1;
    dis[vertex] = dis_;
    for (Edge& edge : graph[vertex]) {
        if (edge.to != from) {
            int_t _size = DFS2(edge.to, vertex, dis_ + edge.weight);
            currSize += _size;
        }
    }
    size[vertex] = currSize;
    return currSize;
}
//算法核心
//当前的节点vertex 对应dfs序中[left,right] 
//统计距离为K的点对个数
int_t DFS3(int_t vertex, int_t* left, int_t* right, int_t K, int_t from = -1) {
    //以树根为一个端点的符合要求的点对数
    int_t cnt1 = 0;
    //两端都在一棵子树内的点对个数
    //统计出整颗子树内符合要求的点对数后 减去cnt2 结果就是经过子树树根的符合要求的点对数
    int_t cnt2 = 0;
    
    //递归所得到的结果和
    int_t cnt3 = 0;
    int_t * pos = left + 1;
    for (Edge& edge : graph[vertex]) {
        if (edge.to != from) {
            //1.递归处理
            cnt3 += DFS3(edge.to, pos, pos + size[edge.to] - 1, K, vertex);
            //2.统计当前两端都在当前子树内的点对数
            //以及一端为树根的点对数
            for (int_t *x = pos; x <= pos + size[edge.to] - 1; x++) {
                int_t i = x - pos + 1;
                temp[i] = dis[*x] - dis[vertex];
                if (temp[i] == K) {
                    //                    cout << "子树" << vertex << " 以树根为一端点的点对 " << *x << " 统计子树 " << edge.to << "时计入" << endl;
                    cnt1++;
                }
            }
            std::sort(&temp[1], &temp[size[edge.to] + 1]);
            cnt2 += countN(&temp[1], &temp[size[edge.to]], K);
            pos += size[edge.to];
        }
    }
    for (int_t i = 1; i <= size[vertex] - 1; i++) {
        temp[i] = dis[*(left + i)] - dis[vertex];
    }
    std::sort(&temp[1], &temp[size[vertex]]);
    //    cout << "子树" << vertex << " 统计结束 " << " 以树根为一端的点对数:" << cnt1 << " 递归结果:" << cnt3 << " 两端都在一个子树内的点对数 " << cnt2 << " 子树内所有符合要求的点对数 " << countN(&temp[1], &temp[size[vertex] - 1], K) << endl;
    //    cout << "子树" << vertex << " 的总序列为";
    //    for (int_t i = 1; i <= size[vertex] - 1; i++) cout << temp[i] << " ";
    //    cout << endl;
    //结果=递归得到的结果+以树根为一个端点的符合要求的点对数+整颗子树内符合要求的点对数-完全在一棵子树内的符合要求的点对数
    return cnt1 + cnt3 + countN(&temp[1], &temp[size[vertex] - 1], K) - cnt2;

}

int main(int argc, char** argv) {
    cin >> n>>m;
    for (int_t i = 1; i <= n - 1; i++) {
        int_t from;
        int_t to;
        int_t weight;
        cin >> from >> to>>weight;
        graph[from].push_back(Edge(to, weight));
        graph[to].push_back(Edge(from, weight));

    }
    DFS1(rand() % n + 1);
    root = massCenter;
    DFS2(root);
    for (int_t i = 1; i <= m; i++) {
        int_t x;
        cin>>x;
        if (DFS3(root, &dfsSeq[1], &dfsSeq[n], x)) {
            cout << "AYE" << endl;
        } else {
            cout << "NAY" << endl;
        }
    }
    return 0;
}


```
算法的速度还可以，开-O2的情况下最慢的点164ms


---

## 作者：Yeji_ (赞：2)

### 前言
似乎很早以前就学过了，但是一直没写博客，现在来补一下锅。

### 分治
我们首先随便就选择一个点当做根节点

显然，这棵树里面有这么两种具有特定性质的边

1.穿过根节点的路径

2.不穿过根节点的路径

对于第1类的点，我们可以用$dis[u]$表示从点$u$到目前根节点的距离，

那么穿过根节点的路径的距离就是$dis[u]+dis[v]$。

而第2类的点我们可以再次在这个子树里面再寻找一个根节点，重复第1类点所做的事。

由此可见，分治的思想就很显然了。
### 树的重心

但是如果直接这样求，时间复杂度可能会退化直到$n$方，这是我们所不能接受的。

所以我们需要求出这一棵树的重心，可以使每一小棵树递归的时间为$log$  $n$

代码
```cpp
#include<iostream>
#include<cstdio>
#define maxn 100010
#define inf 100000000
#define re register
using namespace std;
inline int read()
{
	int p=0,f=1;char ch=getchar();
	for(;ch<'0'||ch>'9';ch=getchar())
		if(ch=='-')	f*=-1;
	for(;ch>='0'&&ch<='9';ch=getchar())
		p=p*10+ch-48;
	return p*f;
}
struct node
{
	int v,dis,next;
}edge[maxn<<1];
int tot,st[maxn],mroot[maxn],size[maxn],dis[maxn],nowd[maxn],n,m;
int vis[maxn],lans[inf],judge[inf],q[maxn],query[1010],sum,root,ans;
void add(int u,int v,int dis)
{
    edge[++tot].next=st[u];
    edge[tot].v=v;
    edge[tot].dis=dis;
    st[u]=tot;
}
void getroot(int u,int pa)
{
    size[u]=1;mroot[u]=0;
    for(re int i=st[u];i;i=edge[i].next) 
    {
        re int v=edge[i].v;
        if (v==pa||vis[v]) 
			continue;
        getroot(v,u);
        size[u]+=size[v];
        mroot[u]=max(mroot[u],size[v]);
    }
    mroot[u]=max(mroot[u],sum-size[u]);
    if (mroot[u]<mroot[root]) 
		root=u;
}
void getdis(int u,int fa)
{
    nowd[++nowd[0]]=dis[u];
    for(re int i=st[u];i;i=edge[i].next)
    {
        re int v=edge[i].v;
        if(v==fa||vis[v])continue;
        dis[v]=dis[u]+edge[i].dis;
        getdis(v,u);
    }
}
void calc(int u)
{
    re int p=0;
    for (re int i=st[u];i!=0;i=edge[i].next)
    {
        re int v=edge[i].v;
        if (vis[v])
			continue;
        nowd[0]=0;dis[v]=edge[i].dis;
        getdis(v,u);
        for(re int j=nowd[0];j!=0;j--)
        	for(re int k=1;k<=m;k++)
        		if (query[k]>=nowd[j])
        			lans[k]|=judge[query[k]-nowd[j]];
        for(re int j=nowd[0];j!=0;j--)
        {
        	q[++p]=nowd[j];
			judge[nowd[j]]=1;
		}
    }
    for(re int i=1;i<=p;i++)
    	judge[q[i]]=0;

}
void solve(int u)
{   
    vis[u]=judge[0]=1;
	calc(u);
    for(re int i=st[u];i;i=edge[i].next)
    {
        re int v=edge[i].v;
        if (vis[v])
			continue;
        sum=size[v]; 
		mroot[root=0]=inf;
        getroot(v,0); 
		solve(root);
    }
}
int main()
{
    n=read();m=read();
    for(re int i=1;i<n;i++)
    {
        re int u=read(),v=read(),dis=read();
        add(u,v,dis);add(v,u,dis);
    }
    for(re int i=1;i<=m;i++)
    	query[i]=read();
    mroot[root]=sum=n;
    getroot(1,0); 
    solve(root);
    for (re int i=1;i<=m;i++)
    {
        if (lans[i]) 
			printf("AYE\n");
        else 
			printf("NAY\n");
    }
}
```




---

## 作者：Drifterming (赞：2)

```
//Pro:P3806 【模板】点分治1

//写一篇与他们做法不同的题解
//这个做法像 P4178 Tree 差不多 

//仍然是存下所有的询问，离线操作
//我们用flag[i]表示第i个询问能满足的次数
//在分治的时候，仍然是先处理父亲，再容斥处理减掉儿子 

//如果都处理完之后flag[i]仍然是>0的，那就说明存在这样一条路径，否则就不存在

//复杂度的话，应该是m*nlogn+nlog^2n的吧 不太会算 

#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;

inline int read()
{
    char c=getchar();int num=0;
    for(;!isdigit(c);c=getchar());
    for(;isdigit(c);c=getchar())
        num=num*10+c-'0';
    return num;
}

const int N=1e4+5;
const int M=1e7+5;
const int INF=599518803;

int n,m;
int k[N];

int head[N],num_edge;
struct Edge
{
    int v,w,nxt;
}edge[N<<1];

inline void add_edge(int u,int v,int w)
{
    edge[++num_edge].v=v;
    edge[num_edge].w=w;
    edge[num_edge].nxt=head[u];
    head[u]=num_edge;
}

bool vis[N];
int flag[M];

int Siz,root;
int mxson[N],siz[N];
void getroot(int u,int fa)
{
    siz[u]=1,mxson[u]=0;
    for(int i=head[u],v;i;i=edge[i].nxt)
    {
        v=edge[i].v;
        if(v==fa||vis[v])
            continue;
        getroot(v,u);
        siz[u]+=siz[v];
        mxson[u]=max(mxson[u],siz[v]);
    }
    mxson[u]=max(mxson[u],Siz-siz[u]);
    if(mxson[u]<mxson[root])
        root=u;
}

int dep[N],dis[N],cnt;
void getdis(int u,int fa)
{
    dis[++cnt]=dep[u];
    for(int i=head[u],v;i;i=edge[i].nxt)
    {
        v=edge[i].v;
        if(vis[v]||v==fa)
            continue;
        dep[v]=dep[u]+edge[i].w;
        getdis(v,u);
    }
}

void solve(int u,int dist,int val)		//val表示是加还是容斥减掉 
{
    dep[u]=dist,cnt=0;
    getdis(u,u);
    sort(dis+1,dis+cnt+1);
    for(int i=1,l,r;i<=m;++i)
    {
        for(l=1,r=cnt;l<r;)
        {
            if(dis[l]+dis[r]>k[i])		//调整边界 
                --r;
            else if(dis[l]+dis[r]<k[i])
                ++l;
            else	//可以拼出了，计算点对个数 
            {
                if(dis[l]==dis[r])
                {
                    flag[i]+=val*(r-l+1)*(r-l)/2;
                	break;
				}
                else
                {
                    int l1=1,l2=1;		//枚举求相等的数有多少个 
                    for(;l<r&&dis[l+1]==dis[l];++l,++l1);
                    for(;r>l&&dis[r-1]==dis[r];--r,++l2);
                    flag[i]+=val*l1*l2;
                    ++l,--r;
//                    int ll=l,rr=r,mid,pos=ll;		二分求 
//                    while(ll<=rr)
//                    {
//                        mid=(ll+rr)>>1;
//                        if(dis[mid]==dis[l])
//                        {
//                            ll=mid+1;
//                            pos=mid;
//                        }
//                        else
//                            rr=mid-1;
//                    }
//                    int a=pos-l+1;
//                    l=pos+1;
//                    ll=l,rr=r,pos=rr;
//                    while(ll<=rr)
//                    {
//                        mid=(ll+rr)>>1;
//                        if(dis[mid]==dis[r])
//                            rr=mid-1,pos=mid;
//                        else
//                            ll=mid+1;
//                    }
//                    flag[i]+=val*a*(r-pos+1);
//                    r=pos-1;
                }
            }
        }
    }
}

void divide(int u)
{
    solve(u,0,1);	//算重心的答案 
    vis[u]=1;
    for(int i=head[u],v;i;i=edge[i].nxt)
    {
        v=edge[i].v;
        if(vis[v])
            continue;
        solve(v,edge[i].w,-1);		//将儿子减掉 
        Siz=siz[v],root=0;
        getroot(v,v);
        divide(root);
    }
}

int main()
{
    n=read(),m=read();
    for(int i=1,a,b,c;i<n;++i)
    {
        a=read(),b=read(),c=read();
        add_edge(a,b,c);
        add_edge(b,a,c);
    }
    for(int i=1;i<=m;++i)
        k[i]=read();
    Siz=n,mxson[0]=INF;
    getroot(1,1);
    divide(root);
    for(int i=1;i<=m;++i)
    {
        if(flag[i])
            puts("AYE");
        else
            puts("NAY");
    }
    return 0;
}
```

---

## 作者：_sry (赞：1)


其实就是一个十分暴力的算法，每次找到树的重心以后把它当为根然后再重新进行

这道题所到达长度为$k$的道路有$2$种情况

一种情况是经过根$root$,$x$到$y$的距离为$dis[x]+dis[y](lca(x,y)=root)$

而还有一种是经过子树的，就去进行分治即可
然后就没有了

如果是暴力方法的时间复杂度为：$O(floor \times n)$ $floor$为树的层数

如果是点分治的话，因为每次是树的重心所以层数不超过$\log n$,所以时间复杂度为:$O(n\log n)$
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<climits>
using namespace std;
inline int read(){
    int f=1,ans=0;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){ans=ans*10+c-'0';c=getchar();}
    return f*ans;
}
const int MAXN=10001;
const int MAXN1=10000001;
int n,q;
struct node{
    int u,v,w,nex;
}x[MAXN<<1];
int cnt,head[MAXN],vis[MAXN],root,sum[MAXN],maxnson[MAXN],sigma,maxn=INT_MAX,query[MAXN],rem[MAXN];
void add(int u,int v,int w){
    x[cnt].u=u,x[cnt].v=v,x[cnt].w=w,x[cnt].nex=head[u],head[u]=cnt++;
}
void get(int xx,int fath){
    sum[xx]=1;
    for(int i=head[xx];i!=-1;i=x[i].nex){
        if(x[i].v==fath) continue;
        if(vis[x[i].v]) continue;
        get(x[i].v,xx);
        maxnson[xx]=max(maxnson[xx],maxnson[x[i].v]);
        sum[xx]+=sum[x[i].v];
    }
    int pd=max(maxnson[xx],sigma-sum[xx]);
    if(pd<maxn){
        pd=maxn;
        root=xx;
    }
    return;
}
int num_dis[MAXN1],dis[MAXN];
void dfs(int xx,int fath){
    rem[++rem[0]]=dis[xx];
    for(int i=head[xx];i!=-1;i=x[i].nex){
        if(x[i].v==fath) continue;
        if(vis[x[i].v]) continue;
        dis[x[i].v]=dis[xx]+x[i].w;
        dfs(x[i].v,xx);
    }return;
}
bool pd[MAXN];
int que[MAXN];
void calc(int xx,int fath){
    que[0]=0;
    for(int i=head[xx];i!=-1;i=x[i].nex){
        if(vis[x[i].v]) continue;
        if(x[i].v==fath) continue;
        rem[0]=0;
        dis[x[i].v]=x[i].w;
        dfs(x[i].v,xx);
        for(int j=1;j<=q;j++)
            for(int z=1;z<=rem[0];z++) 
                if(query[j]>=rem[z]) pd[j]|=num_dis[query[j]-rem[z]];
        
        for(int j=1;j<=rem[0];j++) que[++que[0]]=rem[j],num_dis[rem[j]]=1;    
    }
    for(int i=1;i<=que[0];i++) num_dis[que[i]]=0;
}
void solve(int xx,int fath){ 
    vis[xx]=1,num_dis[0]=1;calc(xx,fath);
    for(int i=head[xx];i!=-1;i=x[i].nex){
        if(x[i].v==fath) continue;
        if(vis[x[i].v]) continue;
        sigma--;
        get(x[i].v,xx);        
        solve(x[i].v,xx);
    }
}
int main(){
    memset(head,-1,sizeof(head));
    n=read(),q=read();
    for(int i=1;i<n;i++){
        int u=read(),v=read(),w=read();
        add(u,v,w),add(v,u,w);
    }
    for(int i=1;i<=q;i++) query[i]=read();
    sigma=n,get(1,0);
    get(1,0);
    solve(1,0);
    for(int i=1;i<=q;i++){
        if(pd[i]) printf("AYE\n");
        else printf("NAY\n");
    }
}
```

---

## 作者：elijahqi (赞：1)

 http://www.elijahqi.win/archives/3250
 https://blog.csdn.net/elijahqi/article/details/80135639

bzoj数据存在长度为0的询问然而本题不存在
本题数据有存在询问是否长度为0的点即 自己和自己构成即可

辣鸡elijahqi的做法是开一个栈flag 存之前是否出现 然后一个一个子树做.. 做到时候就看一下我这个询问的k用他减去当前的距离看一下这个差是否存在即可

然后清空仍然 一个一个子树把dis清空即可 复杂度大约是少一个log的 常数可能比较大没有仔细卡

```
#include<cstdio>
#include<cctype>
#include<algorithm>
using namespace std;
inline char gc(){
    static char now[1<<16],*S,*T;
    if (T==S){T=(S=now)+fread(now,1,1<<16,stdin);if (T==S) return EOF;}
    return *S++;
}
inline int read(){
    int x=0,f=1;char ch=gc();
    while(!isdigit(ch)) {if (ch=='-') f=-1;ch=gc();}
    while(isdigit(ch)) x=x*10+ch-'0',ch=gc();
    return x*f;
}
const int N=10010;
const int inf=0x3f3f3f3f;
struct node{
    int y,z,next;
}data[N<<1];
int qr[N],dis[N],q[N],tp,f[N],n,m,size[N],sum,root,h[N],num;bool ans[N],visit[N],flag[10001000];
inline void get_root(int x,int fa){
    f[x]=0;size[x]=1;
    for (int i=h[x];i;i=data[i].next){
        int y=data[i].y;if (y==fa||visit[y]) continue;
        get_root(y,x);size[x]+=size[y];f[x]=max(f[x],size[y]);
    }f[x]=max(f[x],sum-size[x]);
    if (f[x]<f[root]) root=x;
}
inline void dfs(int x,int fa){
    for (int i=h[x];i;i=data[i].next){
        int y=data[i].y,z=data[i].z;if (y==fa||visit[y]) continue;
        dis[y]=dis[x]+z;dfs(y,x);
    }
}
inline void dfs1(int x,int fa,int id){
	if (dis[x]>qr[id]) return;
	if(flag[qr[id]-dis[x]]) {ans[id]=1;return;}
	for (int i=h[x];i;i=data[i].next){
		int y=data[i].y;if (y==fa||visit[y]) continue;
		dis[y]=dis[x]+data[i].z;dfs1(y,x,id);
	}
}
inline void dfs2(int x,int fa){
	if (dis[x]>1e6) return;flag[dis[x]]=1;
	for (int i=h[x];i;i=data[i].next){
		int y=data[i].y;if (y==fa||visit[y]) continue;
		dis[y]=dis[x]+data[i].z;dfs2(y,x);
	}
}
inline void clear(int x,int fa){
	flag[dis[x]]=0;
	for (int i=h[x];i;i=data[i].next){
		int y=data[i].y;if(y==fa||visit[y]) continue;clear(y,x);
	}
}
inline void solve(int x){
    visit[x]=1;dis[x]=0;tp=0;flag[0]=1;
    for (int i=h[x];i;i=data[i].next){
		int y=data[i].y,z=data[i].z;if (visit[y]) continue;
		if (size[y]>size[x]) size[y]=sum-size[x];dis[y]=dis[x]+z;
		for (int j=1;j<=m;++j) {
			if (ans[j]) continue;dfs1(y,x,j);
		}dfs2(y,x);
	}
	for (int i=h[x];i;i=data[i].next) {
		int y=data[i].y;if (visit[y]) continue;
		clear(y,x);
	}
    for (int i=h[x];i;i=data[i].next){
        int y=data[i].y;if (visit[y]) continue;
        sum=size[y];root=0;get_root(y,x);solve(root);
    }
}
int main(){
	freopen("bzoj1316.in","r",stdin);
    n=read();m=read();
    for (int i=1;i<n;++i){
        int x=read(),y=read(),z=read();
        data[++num].y=y;data[num].next=h[x];data[num].z=z;h[x]=num;
        data[++num].y=x;data[num].next=h[y];data[num].z=z;h[y]=num;
    }
    for (int i=1;i<=m;++i) qr[i]=read(),!qr[i]?ans[i]=1:ans[i]=0;
	f[0]=inf;sum=n;get_root(1,1);solve(root);
	for (int i=1;i<=m;++i) ans[i]?puts("Yes"):puts("No"); 
    return 0;
}
```

---


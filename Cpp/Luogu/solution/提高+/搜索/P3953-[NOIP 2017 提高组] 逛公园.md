# [NOIP 2017 提高组] 逛公园

## 题目背景

NOIP2017 D1T3

## 题目描述

策策同学特别喜欢逛公园。公园可以看成一张 $N$ 个点 $M$ 条边构成的有向图，且没有 自环和重边。其中 $1$ 号点是公园的入口，$N$ 号点是公园的出口，每条边有一个非负权值， 代表策策经过这条边所要花的时间。

策策每天都会去逛公园，他总是从 $1$ 号点进去，从 $N$ 号点出来。

策策喜欢新鲜的事物，它不希望有两天逛公园的路线完全一样，同时策策还是一个 特别热爱学习的好孩子，它不希望每天在逛公园这件事上花费太多的时间。如果 $1$ 号点 到 $N$ 号点的最短路长为 $d$，那么策策只会喜欢长度不超过 $d + K$ 的路线。

策策同学想知道总共有多少条满足条件的路线，你能帮帮它吗？

为避免输出过大，答案对 $P$ 取模。

如果有无穷多条合法的路线，请输出 $-1$。


## 说明/提示

【样例解释1】


对于第一组数据，最短路为 $3$。 $1\to 5, 1\to 2\to 4\to 5, 1\to 2\to 3\to 5$ 为 $3$ 条合法路径。


【测试数据与约定】

对于不同的测试点，我们约定各种参数的规模不会超过如下


测试点编号　　|$T$　　　|$N$　　　|$M$　　　|$K$　　　|是否有 $0$ 边
-|-|-|-|-|-
$1$|$5$|$5$|$10$|$0$|否
$2$|$5$|$10^3$|$2\times 10^3$|$0$|否
$3$|$5$|$10^3$|$2\times 10^3$|$50$|否
$4$|$5$|$10^3$|$2\times 10^3$|$50$|否
$5$|$5$|$10^3$|$2\times 10^3$|$50$|否
$6$|$5$|$10^3$|$2\times 10^3$|$50$|是
$7$|$5$|$10^5$|$2\times 10^5$|$0$|否
$8$|$3$|$10^5$|$2\times 10^5$|$50$|否
$9$|$3$|$10^5$|$2\times 10^5$|$50$|是
$10$|$3$|$10^5$|$2\times 10^5$|$50$|是


对于 $100\%$ 的数据，$1 \le P \le 10^9$，$1 \le a_i,b_i \le N$，$0 \le c_i \le 1000$。

数据保证：至少存在一条合法的路线。

---

- 2019.8.30 增加了一组 hack 数据 by @skicean
- 2022.7.21 增加了一组 hack 数据 by @djwj233

## 样例 #1

### 输入

```
2
5 7 2 10
1 2 1
2 4 0
4 5 2
2 3 2
3 4 1
3 5 2
1 5 3
2 2 0 10
1 2 0
2 1 0```

### 输出

```
3
-1

```

# 题解

## 作者：Jay_genius (赞：28)

~~难道有人看题解不点赞的吗？~~

第一眼紫题，便有了退缩之意，但这是必做题，于是我默默地点开了题解……然后就发现其实思路~~不是哪么难（代码调了两个小时）。~~
## 题目解析
- 首先看到题目中写：“如果 $1$ 号点 到 $N$ 号点的最短路长为 $d$，那么策策只会喜欢长度不超过 $d + K$ 的路线”。  
所以，很明显，我们要跑一遍 Dijkstra 算法。
```cpp
void dij() {
	memset(vis1,0,sizeof(vis1));
	memset(d,0x3f,sizeof(d));
	d[1]=0;
	q.push({0,1});
	while(!q.empty()) {
		ll u=q.top().second;
		q.pop();
		if(vis1[u]) continue;
		vis1[u]=1;
		for(auto x:e1[u]) {
			ll v=x.first,w=x.second;
			if(d[v]>d[u]+w) d[v]=d[u]+w,q.push({d[v],v});
		}
	}
}
```
- 接下来我们使用记忆化搜索。  
设 $dp_{u,k}$ 为从 $1$ 号点进去，从 $u$ 号点出来，且花恰好 $d[u]+k$ 的时间，总共有多少条满足条件的路线。$dp$ 初始值为 $-1$。  
遍历 $u$ 的邻点 $v$，设 $dp_{u,k}$ 由 $dp_{v,k'}$ 转移得到，则  
$d_u+k=d_v+k'+w(u,v)$  
$k'=d_u-d_v+k-w(u,v)$  
$dp$ 数组的初值是 $dp_{1,0}=1$。  
不过还有个问题，就是什么时候输出 $-1$。  
发现这时会出现“零环”，所以我们要开一个 $vis$ 数组，如果两次遍历到同一个点便出现了“零环”。
```cpp
ll dfs(ll u,ll k) {
	if(vis2[u][k]) {
		flg=1;
		return 0;
	}
	if(~dp[u][k]) return dp[u][k];
	vis2[u][k]=1;
	dp[u][k]=0;
	for(auto x:e2[u]) {
		ll v=x.first,w=x.second,nk=d[u]-d[v]+k-w;
		if(nk<0 || nk>K) continue;
		dp[u][k]=(dp[u][k]+dfs(v,nk))%p;
		if(flg) {
			vis2[u][k]=0;
			return 0;
		}
	}
	if(u==1 && k==0) dp[u][k]=1;
	vis2[u][k]=0;
	return dp[u][k];
}
```
呼，该讲的都讲完了，接下来是——
## AC 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<ll,ll> PLL;
const ll N=1e5+10;
priority_queue<PLL,vector<PLL>,greater<PLL>> q;
vector<PLL> e1[N],e2[N];
ll t,n,m,K,p,d[N],dp[N][60];
bool flg,vis1[N],vis2[N][60];
void dij() {
	memset(vis1,0,sizeof(vis1));
	memset(d,0x3f,sizeof(d));
	d[1]=0;
	q.push({0,1});
	while(!q.empty()) {
		ll u=q.top().second;
		q.pop();
		if(vis1[u]) continue;
		vis1[u]=1;
		for(auto x:e1[u]) {
			ll v=x.first,w=x.second;
			if(d[v]>d[u]+w) d[v]=d[u]+w,q.push({d[v],v});
		}
	}
}
ll dfs(ll u,ll k) {
	if(vis2[u][k]) {
		flg=1;
		return 0;
	}
	if(~dp[u][k]) return dp[u][k];
	vis2[u][k]=1;
	dp[u][k]=0;
	for(auto x:e2[u]) {
		ll v=x.first,w=x.second,nk=d[u]-d[v]+k-w;
		if(nk<0 || nk>K) continue;
		dp[u][k]=(dp[u][k]+dfs(v,nk))%p;
		if(flg) {
			vis2[u][k]=0;
			return 0;
		}
	}
	if(u==1 && k==0) dp[u][k]=1;
	vis2[u][k]=0;
	return dp[u][k];
}
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>t;
	while(t--) {
		cin>>n>>m>>K>>p;
		for(ll i=1; i<N; i++) e1[i].clear(),e2[i].clear();
		for(ll i=1,a,b,c; i<=m; i++) {
			cin>>a>>b>>c;
			e1[a].push_back({b,c});
			e2[b].push_back({a,c});
		}
		dij();
		flg=0;
		memset(dp,-1,sizeof(dp));
		ll ans=0;
		for(ll i=0; i<=K; i++) {
			ans=(ans+dfs(n,i))%p;
			if(flg) break;
		}
		if(flg) cout<<"-1\n";
		else cout<<ans<<"\n";
	}
	return 0;
}
```
完结撒花~~

---

## 作者：2014吕泽龙 (赞：23)

### **分析1**
作为一名标准的NOIP退役选手，果然过了一年之后仍然不会做这道题。

首先肯定先求最短路，一种思路是$f[k][u]$表示松弛了$k$的最短路从起点走到$u$节点。

很容易写出方程：
$f[k][u]->f[k+w+dis[u]-dis[v]][v]$
其中$k+w+dis[u]$表示的是这一回走到$v$的步数，减去原来的最短路$dis[v]$就是走到$v$的松弛步数。
由于最短路的性质，所以$w+dis[u]-dis[v]\ge 0$所以这个$Dp$的转移实际上形成了一张分层图。我们从小到大枚举$k$这样就可以保证转移的拓扑有序。

但是要注意一种$w+dis[u]-dis[v]= 0$的情况。这意味着$u->v$这条边在最短路径中。也就是说，对于所有的在最短路径上的边，都需要特殊考虑其拓扑序。

首先在没有$0$边的情况，最短路径边一定形成了一张$DAG$，到1的距离$dis_1$就是他们的拓扑偏序。按照$dis_1$排序即可转移。

考虑$0$边的情况。如果有$0$环，判断环中的节点是不是合法的。合法定义为$dis_1[i]+dis_n[i]\ge dis_1[n]+K$，如果这样的话，方案数一定无穷，输出-1即可。否则的话，这个$0$环中的所有节点一定不会出现在我们方程的转移中，可以不用管他们。
这个时候剩下的图一定仍然是一张$DAG$。只不过我们不能仅仅按照$dis_1$排序，考虑$dis_1$相同的节点，还需要考虑$0$边的顺序。所以对于所有$0$边做一遍拓扑排序，以$dis_1$为第一关键字，$0$边拓扑序为第二关键字重新排序即可。

复杂度$O(KM)$
### **代码1**
```cpp
#include<bits/stdc++.h>
const int N = 1e5 + 10, M = 2e5 + 10, Nt = 131072, inf = 0x3f3f3f3f;
int ri() {
	char c = getchar(); int x = 0, f = 1; for(;c < '0' || c > '9'; c = getchar()) if(c == '-') f = -1;
	for(;c >= '0' && c <= '9'; c = getchar()) x = (x << 1) + (x << 3) - '0' + c; return x * f;
}
int n, q[N], d[N], rk[N], f[N], g[N], *D, id[N], T[Nt << 1], dp[51][N], K, P;
struct Edge {
	int nx[M], pr[N], to[M], w[M], tp;
	void add(int u, int v, int W) {to[++tp] = v; nx[tp] = pr[u]; pr[u] = tp; w[tp] = W;}
	void adds(int u, int v, int w) {add(u, v, w); add(v, u, w);}
	void Pre() {for(int i = 1;i <= n; ++i) pr[i] = 0; tp = 0;}
}G, R;
int min(int a, int b) {return D[a] < D[b] ? a : b;}
bool cmp(int a, int b) {return f[a] == f[b] ? rk[a] < rk[b] : f[a] < f[b];}
void Up(int i, int v) {for(T[i += Nt] = v;i >>= 1;) T[i] = min(T[i << 1], T[i << 1 | 1]);}
void Dij(const Edge &G, int st) {
	for(int i = 0;i <= n; ++i) D[i] = inf;
	D[st] = 0; Up(st, st);
	for(;D[T[1]] != inf;) {
		int u = T[1]; Up(u, 0);
		for(int i = G.pr[u], v, w; i; i = G.nx[i])
			if(D[v = G.to[i]] > (w = D[u] + G.w[i]))
				D[v] = w, Up(v, v);
	}
}
bool Topsort() {
	int L = 1, R = 0;
	for(int i = 1;i <= n; ++i) 
		if(!d[i]) 
			q[++R] = i;
	for(int u = q[L];L <= R; u = q[++L])
		for(int i = G.pr[u]; i; i = G.nx[i])
			if(!G.w[i] && !--d[G.to[i]]) 
				q[++R] = G.to[i];
	for(int i = 1;i <= R; ++i) 
		rk[q[i]] = i;
	for(int i = 1;i <= n; ++i)
		if(d[i] && f[i] + g[i] <= f[n] + K)
			return false;
	for(int i = 1;i <= n; ++i) 
		id[i] = i;
	std::sort(id + 1, id + n + 1, cmp);
	return true;
}
void Inc(int &a, int b) {a += b; if(a >= P) a -= P;}
void Dp() {
	memset(dp, 0, sizeof(dp));
	dp[0][id[1]] = 1;
	for(int k = 0;k <= K; ++k)
		for(int x = 1, u = id[1];x <= n; u = id[++x]) 
			for(int i = G.pr[u], w, v; i; i = G.nx[i]) 
				if((w = f[u] + k + G.w[i] - f[v = G.to[i]]) <= K)
					Inc(dp[w][v], dp[k][u]);
}
int main() {
	for(int C = ri();C--;) {
		n = ri(); int m = ri(); K = ri(), P = ri();
		G.Pre(); R.Pre();
		for(int i = 1;i <= n; ++i) 
			d[i] = rk[i] = 0;
		for(int u, v, w;m--;) 
			u = ri(), v = ri(), w = ri(), 
			G.add(u, v, w), R.add(v, u, w), d[v] += !w;
		D = f; Dij(G, 1); 
		D = g; Dij(R, n);
		if(!Topsort()) {
			puts("-1"); continue;
		}
		Dp();
		int r = 0;
		for(int i = 0;i <= K; ++i) Inc(r, dp[i][n]);
		printf("%d\n", r);
	}
	return 0;
}

```
### **分析2**
事实上还有一种更优秀的记忆化搜索解法。直接从起始节点记忆化搜索即可。刚才的算法说明了这张分层图一定是$DAG$，否则一定不合法。对于不合法的情况用一个$in$数组特殊判断一下，剩下的就可以放心搜索了，因为这和在$DAG$上跑记忆化搜索是一样的。

本题的关键在于，所有$Dp$的转移都是依赖于最短路径的拓扑有序性才得以用$O(KM)$的优秀复杂度通过。
### **代码2**
```cpp
#include<bits/stdc++.h>
const int Nt = 131071, N = 1e5 + 10, M = 2e5 + 10, inf = 0x3f3f3f3f;
int ri() {
    char c = getchar(); int x = 0, f = 1; for(;c < '0' || c > '9'; c = getchar()) if(c == '-') f = -1;
    for(;c >= '0' && c <= '9'; c = getchar()) x = (x << 1) + (x << 3) - '0' + c; return x * f;
}
int D[N], f[N][51], n, K, p; bool vis[N][51];
struct Edge {
    int to[M], nx[M], w[M], pr[N], tp;
    void add(int u, int v, int W) {to[++tp] = v; nx[tp] = pr[u]; pr[u] = tp; w[tp] = W;}
    void Clr() {
        for(int i = 1;i <= n; ++i) pr[i] = 0;
        tp = 0;
    }
}G, R;
struct Node {int u, x;}T[Nt << 1];
Node min(Node a, Node b) {return a.x < b.x ? a : b;}
void Up(int i, int v) {for(T[i += Nt].x = v;i >>= 1;) T[i] = min(T[i << 1], T[i << 1 | 1]);}
void Add(int &a, int b) {a += b; if(a >= p) a -= p;}
void Dij() {
    Up(n, D[n] = 0);
    for(;T[1].x != inf;) {
        int u = T[1].u; Up(u, inf);
        for(int i = R.pr[u], d; i; i = R.nx[i])
            if(D[R.to[i]] > (d = D[u] + R.w[i]))
                Up(R.to[i], D[R.to[i]] = d);
    }
}
int Dfs(int u, int d) {
    if(d < 0 || d > K) return 0;
    if(vis[u][d]) return -1;
    if(~f[u][d]) return f[u][d];
    vis[u][d] = true;
    int ways = 0;
    for(int i = G.pr[u], t; i; i = G.nx[i])
        if(~(t = Dfs(G.to[i], D[u] + d - G.w[i] - D[G.to[i]])))
            Add(ways, t);
        else return -1;
    vis[u][d] = false;
    if(u == n && !d) Add(ways, 1);
    return f[u][d] = ways;
}
int Work() {
    memset(f, -1, sizeof(f));
    memset(vis, 0, sizeof(vis));
    n = ri(); int m = ri(); K = ri(); p = ri();
    for(int i = 1;i <= n; ++i) D[i] = inf; G.Clr(); R.Clr();
    for(int u, v, w;m--;) u = ri(), v = ri(), w = ri(), G.add(u, v, w), R.add(v, u, w);
    Dij(); int ways = 0;
    for(int i = 0;i <= K; ++i) {
        int t = Dfs(1, i);
        if(!~t) return -1;
        Add(ways, t);
    }
    return ways;
}
int main() {
    memset(T, 0x3f, sizeof(T));
    for(int i = 1;i <= 1e5; ++i) T[i + Nt].u = i;
    for(int Ca = ri();Ca--;) printf("%d\n", Work());
    return 0;
}
```


---

## 作者：DASADI (赞：7)

## 前言

可能是实现方法最详细的一片题解。我是黑暗贝利亚奥特曼，能踩的坑我都帮你们踩了。

[题目传送门](https://www.luogu.com.cn/problem/P3953)

## 题解

### sub 1,2,7

当 $K=0$，且没有 $0$ 边时，此题就退化成了最短路计数。可以看看这道题：[P1144](https://www.luogu.com.cn/problem/P1144)。

### sub 1,2,3,4,5,7,8

考虑边权不为 $0$ 的情况，可以发现这是很好想的一个 DP。

具体来说，我们令 $dis_i$ 为 $1$ 到 $i$ 最短路径的长度。$f_{i,j}$ 表示当前节点为 $i$，路径长度为 $dis_i+j$，这时图变成了一个 DAG，则我们可以写出转移式：

$$f_{i,j} = \sum_{v|(u,v)\in E'} f_{k,dis_i+j-w-dis_k}$$

初始时 $f_{1,0}=1$，答案即为 $\sum_{i=1}^k f_{n,i}$。

该 DP 可以用记忆化搜索或拓扑排序实现。

显然，在边权不为 $0$ 时，该 DP 不会有后效性。

### 正解

考虑在何种情况下答案会有无穷种。由刚才的 DP 可以发现，如果在 DP 时出现了一个由 $0$ 构成的环时，会有无穷种答案。

考虑如何判断。

方案一：我们可以把所有边权为 $0$ 的边建一张图，在上面跑 tarjan 缩点，这样就形成了一张 DAG。再在 DAG 上跑一遍拓扑，看 $1$ 到 $n$ 的路径上是否有大小超过 $1$ 的强连通分量，如果有显然会有无穷种答案。

方案二：我们在跑记忆化搜索时，如果从一个点出发还能搜到这一个点，就会有无穷种答案。于是可以在搜索时用一个数组记录一个状态是否在搜索中，如果它已经被搜过就返回 $-1$，这样就完成了判断。

## 几个坑点

由于本人太菜，在做题时错了很多次，在摸索的过程中才把正解探究出来。

1. 在求 $f$ 数组前要跑一遍 dij，且 $f$ 数组不能直接在 dij 中求出来。

1. 在记忆化搜索时，要判断 $f_{i,j}$ 中的 $j$ 是否满足 $0\leq j \leq K$，尤其是要判断 $j\geq 0$（感谢 @LLCCFF 的指出），这一种情况很容易漏掉。

1. 如果你是记忆化搜索，在把 $f_{1,0}$ 设为 $1$ 前，先要搜索一下 $f_{1,0}$ 是否有无穷种答案（其实样例就可以测出来）。

1. 最根本的问题。检查你的 dij 是否出错（比如使用了大根堆、没有 $vis$ 数组）！

1. 记得取模 $P$。

1. 多测清空（用样例应该也能测出来）。

## 代码

~~缩点 + 拓扑排序的做法是口胡的，就不放代码了。~~

这份代码使用了上文中的记忆化搜索，记忆化搜索时的传参与 $f$ 的状态设计稍有不同。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 100010
int T,n,m,k,p,dis[N],f[N][51];
bool ins[N][51],fl,vis[N];
vector<pair<int,int>>to[N],to2[N];
priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>q; //注意是小根堆
int calc(int x,int ds){ //记忆化搜索
	if(fl){ //如果有无穷种答案，直接返回
		return 0;
	}
	if(ds<dis[x]){ //一定要注意！
		return 0;
	}
	if(ds>dis[x]+k){
		return 0;
	}
	if(ins[x][ds-dis[x]]){ //判断是否访问到自己
		fl=1;
		return 0;
	}
	if(f[x][ds-dis[x]]!=-1){ //记忆化，注意没有访问到的状态应设为 -1
		return f[x][ds-dis[x]];
	}
	ins[x][ds-dis[x]]=1;
	f[x][ds-dis[x]]=0;
	for(auto [y,w]:to2[x]){
		f[x][ds-dis[x]]=(f[x][ds-dis[x]]+calc(y,ds-w))%p; //记得取模
	}
	ins[x][ds-dis[x]]=0;
	return f[x][ds-dis[x]];
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin>>T;
	while(T--){
		fl=0;
		cin>>n>>m>>k>>p;
		for(int i=1;i<=n;i++){ //多测要清空
			to[i].clear();
			to2[i].clear();
			vis[i]=0;
		}
		for(int i=1;i<=m;i++){
			int u,v,w;
			cin>>u>>v>>w;
			to[u].push_back(make_pair(v,w));
			to2[v].push_back(make_pair(u,w)); //记忆化搜索是在反图上进行
		}
		for(int i=1;i<=n;i++){
			for(int j=0;j<=k;j++){
				f[i][j]=-1;
			}
			dis[i]=1e10;
		}
		dis[1]=0;
		q.push(make_pair(0,1));
		while(!q.empty()){ //先求出最短路
			int x=q.top().second;
			q.pop();
			if(vis[x]){
				continue;
			}
			vis[x]=1;
			for(auto [y,w]:to[x]){
				if(dis[x]+w<dis[y]){
					dis[y]=dis[x]+w;
					q.push(make_pair(dis[y],y));
				}
			}
		}
		calc(1,0);
		f[1][0]=1;
		int ans=0;
		for(int i=0;i<=k;i++){
			ans=(ans+calc(n,dis[n]+i))%p; //统计答案
		}
		if(fl){
			cout<<-1<<'\n'; //判断答案是否有无穷种
			continue;
		}
		cout<<ans<<'\n';
	}
}
```

---

## 作者：No_commander (赞：7)

暴力想法，设 $f_{i, j}$ 为走到了点 $i$，当前最短路为 $j$ 的方案数。

时间复杂度 $\mathcal O(不能过)$。

发现直接将最短路计入状态比较浪费，可改为额外走的长度，由于 $k$ 只有 $50$，状态数仅为 $\mathcal O(n \times k)$ 量级。

即：$f_{i, j}$ 为走到了 $i$，且比最短路长多 $j$ 的方案数。

后效性十分多。

考虑 $i$ 这一维，显然只有 $dis_v < dis_i$ 的 $v$ 才能状态到 $i$，于是 $i$ 可以按照 $dis$ 从小到大枚举。

考虑 $j$，假设 $f_{i, j}$ 转移到了 $f_{k, l}$，显然有 $j \le l$，所以按照大小枚举 $j$ 即可。

再考虑 $0$ 边，可以对于所有的 $0$ 边建出来跑拓扑序，若有环则无穷组解。

由于是图，实现可以用记搜。

时间复杂度 $\mathcal O(n \times k)$。

---

## 作者：RyexAwl (赞：7)

提供一种缩点+ 拓扑排序+ DP的做法：

考虑将所有边权为 $0$ 的边加入一张新图跑强连通分量缩点，处理出所有 $0$ 环，缩点之后的图一定不存在 $0$ 环。

用 $\text{dijkstra}$ 跑出点 $1$ 到其他所有点的最短路 $dist[i]$。

定义边 $(u,v,w)$ “在最短路中”当且仅当满足 $dist[u] + w = dist[v]$ 。

因为不存在负权、零环、因此将所有“在最短路”中的边建图后一定是个 DAG，并且拓扑序满足对于任意边  $(u,v,w)$ ，$dist[u] + w = dist[v]$ ，$u$ 一定在 $v$ 之前。

对建出的 $\text{DAG}$ 跑拓扑排序得出拓扑序。

令 $f[i,j]$ 为从 $1$ 到点 $i$ 长度为 $dist[i] + j$ 的路径条数，按照拓扑序顺序 DP：

考虑 $f[u,j]$ 如果从点 $v$ 转移过来，如果这个状态是 $f[v,x]$ 那么一定有

$dist[u] + j = dist[v] + x + w$ （ $w$ 是边 $(v,u,w)$ ） 的边权。

那么有 $x = dist[u]+j - (dist[v] + w)$ 。

且满足 $dist[u] -  (dist[v] + w) \le 0$。

若 $x < 0$ ，那么该状态一定为非法状态（不存在比最短路还短的路径），对于合法状态一定有 $x \le k$。


tips: 在 dp 的时候顺便判一下有没有解（如果状态 $f[x,j]$ 可以从状态 $f[v,x]$ 转移过来且 $f[v,x]$ 这个状态是 $\text{inf}$ 的话那么 $f[x,j]$ 也是 $\text{inf}$，如果连通分量大小 >1 那么如果存在一条从 $1$ 到这个连通分量长度为 $x$ 的路径那么一定有 $f[v,x] = \text{inf}$ ）。

复杂度 $O(n\log (n+m) + k(n+m))$ 。

可过 uoj hack数据。

[uoj提交记录](https://uoj.ac/submission/507776)



---

## 作者：Hell0_W0rld (赞：6)

## P3953 [NOIP2017] 逛公园

### 题目大意
设 $1$ 到 $N$ 的最短路长度为 $D$，求 $1$ 到 $N$ 路径中，长度不超过 $D+K$ 的路径数量。若无穷条输出 `-1`。
### 解题思路
#### 测试点 1,2,7
这 3 个测试点满足 $K=0$。

即求 $1$ 到 $N$ 的最短路径数量。注意要统计是否有 $0$ 环。
#### 测试点 3,4,5,6
考虑设计 dp 状态：$f_{u,t}$ 表示从 $1$ 到 $u$ 的路径，长度为 $t$ 的路径条数。

考虑记忆化搜索，若在访问期间发现访问到了同一个状态，并且该状态还没有计算完成，那么有无穷解，输出 `-1`。否则我们列出转移：$f_{u,t}\to f_{v,t+edge_{u,v}}$。其中 $edge_{u,v}$ 表示 $u\to v$ 的边权。

答案即为 $\sum_{i=D}^{D+K} f_{N,i}$。

这样时间复杂度和空间复杂度都是 $O((D+K)\times N)$。
#### 测试点 8
考虑将上面的 dp 进行优化。

注意到真正有用的状态满足 $t\geq dst_u$，其中 $dst_u$ 表示 $1$ 到 $u$ 的最短路。

于是我们可以将状态优化至：$g_{u,t}$ 表示从 $1$ 到 $u$ 的路径，长度为 $t+dst_u$ 的路径条数。转移改写为：$g_{u,t}\to f_{v,t+dst_u+edge_{u,v}-dst_v}$。

我们发现这样空间复杂度和时间复杂度仍然爆炸。

由不等式 $dst_u+edge_{u,v}\geq dst_v$ 知，$t+dst_u+edge_{u,v}-dst_v\geq t$，我们可以得到 $t\leq K$，否则越变越大的 $t$ 最终会超过 $K$，导致无法产生贡献。

于是我们得到了时空复杂度 $O(NK)$ 的算法。

#### 测试点 9,10
考虑判断无穷解。

我们发现在开头跑一遍 `F(1,0)` 即可。

如果有 $0$ 环，如果这个环包含 $1$，在第一遍就会跑出来。否则在后续过程中显然一定会跑出来。

实现的时候可以考虑在反图上逆序产生贡献，累加 `F(n,i)` 的和。
### 代码
总时间复杂度： $O(TNK)$。记得多测清空！
```cpp
#include<bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define rep(i,l,r) for(register ll i=(l);i<=(r);++i)
#define Rep(i,l,r) for(register ll i=(r);i>=(l);--i)
#define all(x) x.begin(),x.end()
#define Set(x,y) memset(x,y,sizeof(x))
#define Cpy(x,y) memcpy(x,y,sizeof(x))
#define cll const long long
using namespace std;
template<class T>
void death(T s){cout<<s<<endl;exit(0);}
cll N=100009;
ll n,m,k,dst[N],P,f[N][55]; bool fail,ok[N],inq[N][55];
#define PLL pair<ll,ll>
#define fi first
#define sc second
vector<PLL> to[N],frm[N];
void Dijkstra(){
	Set(dst,0x3f);Set(ok,0);
	priority_queue<PLL,vector<PLL>,greater<PLL> >q;
	dst[1]=0;
	q.push({0,1}); 
	while(!q.empty()){
		ll u=q.top().sc; q.pop();
		if(ok[u])continue;
		ok[u]=1;
		for(ll i=0;i<to[u].size();++i) {
			ll v=to[u][i].fi,cost=to[u][i].sc;
			if(dst[v]<=dst[u]+cost)continue;
			dst[v]=dst[u]+cost;
			q.push({dst[v],v});
		} 
	} 
} 
ll F(ll u,ll k){
    if(k<0) return 0;
    if(k>50)return 0;
    if(inq[u][k]){fail=1; return 0;}
    if(f[u][k]) return f[u][k];
    inq[u][k]=1; ll ans=0;
    for(ll i=0;i<frm[u].size();i++){
    	ll v=frm[u][i].fi,w=frm[u][i].sc;  
    	(ans+=F(v,dst[u]-dst[v]+k-w))%=P;
        if(fail) return 0;
    }
    inq[u][k]=0;
    return f[u][k]=ans;
}
void niam(){
	Set(f,0),Set(inq,0);fail=0;
	rep(i,1,n)to[i].clear(),frm[i].clear(); n=m=k=P=0;
}
void mian(){
	cin>>n>>m>>k>>P;
	rep(i,1,m){
		ll u,v,w;cin>>u>>v>>w;
		to[u].push_back(make_pair(v,w));
		frm[v].push_back(make_pair(u,w));
	}
	Dijkstra(); 
	F(1,0); f[1][0]=1;
	ll ans=0; 
	rep(i,0,k)(ans+=F(n,i))%=P; 
	cout<<(fail?-1:ans)<<endl;
	niam();
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);//不加好像会 TLE？
	ll T;
	cin>>T;
	while(T--)mian();
	return 0;
}
```

---

## 作者：chenxia25 (赞：4)

yet another NOIP2017(

一年半以前写的做法被叉掉了/ll

>### [洛谷题目页面传送门](https://www.luogu.com.cn/problem/P3953)

>给定一张有向图$G=(V,E),|V|=n,|E|=m$，不包含重边与自环。求$1\to n$的长度不超过最短路加上$s$的路径个数，对给定模数取模。若有无限条，输出$-1$。本题多测。

>$n\in\left[1,10^5\right],m\in\left[1,2\times10^5\right],s\in[1,50]$。边权非负。测试组数不超过$5$。

先不考虑有边为$0$的情况。这种情况不难想到一个不是很难的DP。

先Dijkstra算出$1\to i$的最短路径$dis_i$。那么不难发现一个很好的结论：在长度不超过$dis_n+s$的任意一条$1\to n$路上的任意一个点$x$处，都满足$1\to x$的长度不超过$dis_x+s$。因为如果超过了，即使$x\to n$取最短路也不可能救得回来。

数据范围提示我们std大概是$\mathrm O(ns)$（认为$n,m$同阶）的，则考虑设$dp_{i,j}(j\in[0,s])$表示长度为$dis_i+j$的$1\to i$路径个数。边界：$dp_{1,0}=1$，目标：$\sum\limits_{i=0}^sdp_{n,i}$，转移方程：

$$dp_{i,j}=\sum_{(k,j,len)\in E}[dis_i+j-len\in[dis_k,dis_k+s]]dp_{k,dis_i+j-len-dis_k}$$

至于DP顺序？反正无后效性就是了，你闲着无聊可以把所有状态拓扑排序一下，我用我的记忆化搜索（

再考虑有边为$0$的情况，这时我们要考虑判无限条。一年半以前的naive想法是：有无限条当且仅当有$0$环。然后居然AC了？这里吐槽一下NOIP的数据质量。直到现在——有吏夜叉人。反例很简单，只需要构造出一个$0$环使得没有合法路径经过这个环上任意一个点即可。

解决方案也不难。考虑对于每个环上的节点，都看是否有合法路径经过它即可。如何算是否有合法路径经过它？只需要看经过它的最短$1\to n$路径长度是否不超过$dis_n+s$。如何算经过它的最短$1\to n$路径长度？只需要结合之前Dijkstra求出来的$dis$数组，再Dijkstra算出从$n$出发经过反向边到达每个点的最短路径即可。如何算每个节点是否在环上？Tarjan求SCC即可，所在环大小超过$1$就在环上（因为无自环），DFS和拓扑排序都不再适用，因为它们只能判是否有环。

时间复杂度$\mathrm O\!\left(\sum(n\log n+ns )\right)$。常数很大，但居然到了$2\mathrm s$？这是我所没想到的（果然人傻常数大）。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define mp make_pair
#define X first
#define Y second
#define pb push_back
const int N=100000,S=50;
int n,m,s,mod;
vector<pair<int,int> > nei[N+1],rnei[N+1];
bool vis[N+1];
int dis[N+1],dis0[N+1];
void dijkstra(){//正图最短路 
	priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > q;
	memset(dis,0x3f,sizeof(dis));memset(vis,0,sizeof(vis));
	q.push(mp(dis[1]=0,1));
	while(q.size()){
		int x=q.top().Y;
		q.pop();
		if(vis[x])continue;
		vis[x]=true;
		for(int i=0;i<nei[x].size();i++){
			int y=nei[x][i].X,len=nei[x][i].Y;
			if(dis[x]+len<dis[y])q.push(mp(dis[y]=dis[x]+len,y));
		}
	}
//	cout<<"dis=";for(int i=1;i<=n;i++)cout<<dis[i]<<" ";puts("");
}
void dijkstra0(){//反图最短路 
	priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > q;
	memset(dis0,0x3f,sizeof(dis0));memset(vis,0,sizeof(vis));
	q.push(mp(dis0[n]=0,n));
	while(q.size()){
		int x=q.top().Y;
		q.pop();
		if(vis[x])continue;
		vis[x]=true;
		for(int i=0;i<rnei[x].size();i++){
			int y=rnei[x][i].X,len=rnei[x][i].Y;
			if(dis0[x]+len<dis0[y])q.push(mp(dis0[y]=dis0[x]+len,y));
		}
	}
}
int dfn[N+1],low[N+1],nowdfn;
int stk[N],top;
bool ins[N+1];
vector<vector<int> > scc;
void dfs_tar(int x){
	dfn[x]=low[x]=++nowdfn;
	ins[stk[top++]=x]=true;
	for(int i=0;i<nei[x].size();i++){
		int y=nei[x][i].X,len=nei[x][i].Y;
		if(len)continue;
		if(!dfn[y])dfs_tar(y),low[x]=min(low[x],low[y]);
		else if(ins[y])low[x]=min(low[x],dfn[y]);
	}
	if(dfn[x]==low[x]){
		scc.pb(vector<int>());
		while(true){
			int y=stk[--top];
			ins[y]=false;
			scc.back().pb(y);
			if(y==x)break;
		}
	}
}
int dp[N+1][S+1];
int dfs(int x,int y){//记忆化搜索 
	if(x==1&&y==0)return 1;//边界 
	int &res=dp[x][y];
	if(~res)return res;
	res=0;
	for(int i=0;i<rnei[x].size();i++){
		int z=rnei[x][i].X,len=rnei[x][i].Y;
		if(dis[z]<=dis[x]+y-len&&dis[x]+y-len<=dis[z]+s)(res+=dfs(z,dis[x]+y-len-dis[z]))%=mod;//转移 
	}
//	printf("dp[%d][%d]=%d\n",x,y,res);
	return res;
}
void mian(){
	cin>>n>>m>>s>>mod;
	for(int i=1;i<=n;i++)nei[i].clear(),rnei[i].clear();
	while(m--){
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		nei[x].pb(mp(y,z));rnei[y].pb(mp(x,z));
	}
	dijkstra();dijkstra0();
	memset(dfn,0,sizeof(dfn));memset(low,0,sizeof(low));nowdfn=0;top=0;memset(ins,0,sizeof(ins));scc.clear();
	for(int i=1;i<=n;i++)if(!dfn[i])dfs_tar(i);//Tarjan求SCC 
	for(int i=0;i<scc.size();i++){
		vector<int> &v=scc[i];
		if(v.size()==1)continue;
		for(int j=0;j<v.size();j++)if(dis[v[j]]+dis0[v[j]]<=dis[n]+s)return puts("-1"),void();//判无限 
	}
	memset(dp,-1,sizeof(dp));
	int ans=0;
	for(int i=0;i<=s;i++)(ans+=dfs(n,i))%=mod;//目标 
	cout<<ans<<"\n";
}
int main(){
	int testnum;
	cin>>testnum;
	while(testnum--)mian();
	return 0;
}
```

---

## 作者：ykzzldz (赞：2)

一个非常经典的题目，可以看作记忆化搜索的板子题。

首先题目的限制与最短路有关，我们可以先求出每个点的最短路，方便后续处理。

其次我们发现题目中 $K$ 的范围非常小，考虑将 $K$ 这一维压入状态。设 $f_{u,i}$ 表示从 $1$ 到 $u$，距离为 $d_u+i$ 的方案数，其中 $d_u$ 是 $1$ 到 $u$ 的最短路。$f_{1,0}$ 初始化为 $1$。

若 $f_{u,i}$ 能从 $f_{v,j}$ 转移而来，说明 $d_u+i=d_v+j+w(u,v)$，那么 $j=d_u-d_v+i-w(u,v)$。

接下来还有最后一个问题，如何判断无数解。我们发现，无数解的情况说明在图中有一个零环，在记忆化搜索的过程中，我们发现若一个状态能被其自己更新，说明存在零环，具体操作中只需要加一个 $vis$ 判断即可。

最后在实现中要特别判断一下 $k=0$ 的时候是否会使 $f_{1,0}$ 取到无限，这个可以用样例测出来。下面给出代码：


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+10;
struct node{
	int dis,u;
	bool operator<(node a)const{
		return a.dis<dis;
	}
};
struct jl{
	int v,w;
};
vector<jl>a1[N],a2[N];
int T,n,m,k,p,vis[N],dis[N],f[N][60],vvis[N][60],flag;
void dij(){
	priority_queue<node>q;
	for(int i=1;i<=n;i++){
		vis[i]=0;
		dis[i]=1e9;
	}
	dis[1]=0;
	q.push({0,1});
	while(!q.empty()){
		int u=q.top().u;
		q.pop();
		if(vis[u])continue;
		vis[u]=1;
		for(int j=0;j<a1[u].size();j++){
			int v=a1[u][j].v,w=a1[u][j].w;
			if(dis[v]>dis[u]+w){
				dis[v]=dis[u]+w;
				q.push({dis[v],v});
			}
		} 
	}
}
int dfs(int u,int w){
	if(w<0)return 0;
	if(vvis[u][w]){
		flag=1;
		return 0;
	}
	if(f[u][w])return f[u][w];
	vvis[u][w]=1;
	int ans=0;
	for(int i=0;i<a2[u].size();i++){
		int v=a2[u][i].v,ww=a2[u][i].w;
		ans=(ans+dfs(v,dis[u]-dis[v]+w-ww))%p;
	}
	vvis[u][w]=0;
	return f[u][w]=ans;
}
signed main(){
	cin>>T;
	while(T--){
		int ans=0;
		cin>>n>>m>>k>>p;
		for(int i=1;i<=n;i++){
			a1[i].clear();
			a2[i].clear();
		}
		memset(f,0,sizeof f);
		memset(vvis,0,sizeof vvis);
		flag=0;
		for(int i=1;i<=m;i++){
			int u,v,w;
			scanf("%d%d%d",&u,&v,&w);
			a1[u].push_back({v,w});
			a2[v].push_back({u,w});
		}
		dij();
		f[1][0]=1;
		if(k==0){
			dfs(n,1);
			if(flag){
				cout<<"-1\n";
				continue;
			}
		}
		for(int kk=0;kk<=k;kk++){
			ans=(ans+dfs(n,kk))%p;
		}
		if(flag)ans=-1;
		cout<<ans<<'\n';
	}
	return 0;
}
```

---

## 作者：C20203030 (赞：1)

## 一、题目

[点此看题](https://www.luogu.org/problem/P3953)

## 二、解法

**0x01 k=0**直接写最短路计数（可以顺手A[这个](https://www.luogu.org/problem/P1144)和[这个](https://www.luogu.org/problem/P1608)）。

**0x02 没有0边**

考虑到这道题$k$最大只有$50$，且过程中$k$一定不减，把$k$放进$dp$中，定义$dp[i][j]$为到$i$多走了$j$步（相较于最短路），有：

$dp[v][l+delta]=\sum dp[u][l]$（$u,v$相连）

其中$delta$表示走这条路带来的增量，$delta=dis[u]+c-dis[v]$，易得$delta$非负。

这个$dp$是$O(mk)$的，似乎可以$A$，但发现还存在一个问题，就是我们无法保证$dp[u][l]$更新完了后再去更新$dp[v][l+delta]$，也就是这个算法的正确性被限制在了$dp$的顺序上。

如果$delta$为正，我们可以通过先枚举$l$来解决，而对于$delta$为$0$的情况，我们暂时不考虑$0$边，直接将$dis$排序，$dis$小的先更新，这样就能解决顺序问题。（注：这种算法过不了样例，但卡卡常$70$没问题）。

**0x03 正解**

介绍一种很优秀的做法，考虑到不会带来增量的边在且仅在最短路径上，我们可以通过跑正反向图的方式找出所有不会带来增量的边，然后直接拓扑排序，有环直接输出$-1$，没有环按拓扑序$dp$即可。

为什么能这样做呢？这是因为组成环的只有$0$边（如果有非零边那么跑一遍环就不可能是最短路了）。$meanwhile$，没有带来增量的边应该放在最短路上处理，从$1$开始拓扑保证了顺序是符合最短路的。

注意$dp$时先$dp$没有增量的边，然后在$dp$有增量的边就可以了。

**0x04 代码**
我的思路来源于这位[大佬的博客](https://www.luogu.org/blog/user26242/noip2017d1t3-xie-ti-bao-gao)，下面附上我卡过常的代码。


```cpp
#include <cstdio>
#include <vector>
#include <queue>
#include <cstring>
using namespace std;
const int MAXN = 100005;
int read()
{
    int x=0,flag=1;
    char c;
    while((c=getchar())<'0' || c>'9') if(c=='-') flag=-1;
    while(c>='0' && c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
    return x*flag;
}
int T,n,m,k,p,tot,ans,cnt,a[2*MAXN],b[2*MAXN],w[2*MAXN],tp[MAXN],in[MAXN],f[MAXN],dis[MAXN][2],dp[MAXN][51];
struct edge
{
    int v,c,next;
} e[2*MAXN];
struct node
{
    int u,c;
    bool operator < (node x) const
    {
        return c>x.c;
    }
};
void dijkstra(int cur)
{
    priority_queue<node> q;
    q.push(node{cur?n:1,0});
    dis[cur?n:1][cur]=0;
    while(!q.empty())
    {
        node t=q.top();
        q.pop();
        for(int i=f[t.u]; i; i=e[i].next)
        {
            int v=e[i].v,c=e[i].c;
            if(dis[v][cur]>t.c+c)
            {
                dis[v][cur]=t.c+c;
                q.push(node{v,dis[v][cur]});
            }
        }
    }
}
bool topol()
{
    if(in[1]) return 0;
    queue<int> q;
    q.push(1);
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        tp[++cnt]=u;
        for(int i=f[u]; i; i=e[i].next)
        {
            int v=e[i].v;
            in[v]--;
            if(in[v]==0)
                q.push(v);
        }
    }
    for(int i=1; i<=n; i++)
        if(in[i])
            return 0;
    return 1;
}
void makeSet()
{
    tot=0;
    for(int i=1; i<=n; i++)
        f[i]=0;
}
int main()
{
    T=read();
    while(T--)
    {
        n=read();
        m=read();
        k=read();
        p=read();
        tot=cnt=ans=0;
        memset(dis,0x3f,sizeof dis);
        for(int i=1; i<=n; i++)
        {
            f[i]=in[i]=0;
        }
        for(int i=1; i<=n; i++)
            for(int j=0; j<=k; j++)
                dp[i][j]=0;
        for(int i=1; i<=m; i++)
        {
            int u=read(),v=read(),c=read();
            a[i]=u;
            b[i]=v;
            w[i]=c;
            e[++tot]=edge{v,c,f[u]},f[u]=tot;
        }
        dijkstra(0);
        makeSet();
        for(int i=1; i<=m; i++)
            e[++tot]=edge{a[i],w[i],f[b[i]]},f[b[i]]=tot;
        dijkstra(1);
        makeSet();
        for(int i=1; i<=m; i++)
        {
            int u=a[i],v=b[i],c=w[i];
            if(dis[u][0]+dis[v][1]+c<=dis[n][0]+k && dis[u][0]+c==dis[v][0])
            {
                e[++tot]=edge{v,0,f[u]},f[u]=tot;
                in[v]++;
            }
        }
        if(!topol())
        {
            puts("-1");
            continue ;
        }
        dp[1][0]=1;
        for(int l=0; l<=k; l++)
        {
            for(int i=1; i<=cnt; i++)
            {
                int u=tp[i];
                for(int j=f[u]; j; j=e[j].next)
                {
                    int v=e[j].v;
                    dp[v][l]+=dp[u][l];
                    dp[v][l]%=p;
                }
            }
            for(int i=1; i<=m; i++)
            {
                int u=a[i],v=b[i],c=w[i],delta=dis[u][0]+c-dis[v][0];
                if(delta+l<=k && delta)
                {
                    dp[v][l+delta]+=dp[u][l];
                    dp[v][l+delta]%=p;
                }
            }
        }
        for(int i=0; i<=k; i++)
            ans=(ans+dp[n][i])%p;
        printf("%d\n",ans);
    }
}
```



---


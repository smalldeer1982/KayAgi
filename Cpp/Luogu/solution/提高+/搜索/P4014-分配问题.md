# 分配问题

## 题目描述

有 $n$ 件工作要分配给 $n$ 个人做。第 $i$ 个人做第 $j$ 件工作产生的效益为 $c_{ij}$ 。试设计一个将 $n$ 件工作分配给 $n$ 个人做的分配方案，使产生的总效益最小或最大。


## 说明/提示

$1 \leq n \leq 50, 0 \le c _ {i, j} \le 100$。

一个人只能修一个工件。

## 样例 #1

### 输入

```
5
2 2 2 1 2
2 3 1 2 4
2 0 1 1 1
2 3 4 3 3
3 2 1 2 1```

### 输出

```
5
14```

# 题解

## 作者：Khassar (赞：24)

非常裸的二分图最佳完美匹配。

我们把人放一边，工作放一边，效率就是边权，然后求一个**权值和**最大和（或）最小的完美匹配。

至于二分图最佳完美匹配的求法，我在这里只简单说一下，具体的可以自找资料学习。

首先，介绍一个重要的定理：

我们定义**顶标**：

lx[i],ly[j],i∈左边，j∈右边，并且对于任意w[i][j],都有lx[i]+ly[j]>=w[i][j]；

我们再从原图中抽出lx[i]+ly[j]=w[i][j]的边建立一个**相等子图**，如果相等子图有**完美匹配**（就是无边权，全匹配的那个），那么这个完美匹配就是原图的**最佳完美匹配**。

这个定理的证明也十分简单，这里我就不证明了，有兴趣的可以自行百度。

有了这个定理我们就可以用KM(匈牙利算法)求解此题了。

具体的方法就是，不断的修改顶标让它有一个合适的值，使得相等子图有完美匹配。实现起来就是先开心地设一个顶标初值（一般是ly=0,lx=max(w[i][j])），然后开始KM，如果找到了一条增广路，就找到了吧；如果没有，那它一定是尝试访问了一些左边的点（比如q个）我们把它们加入**S**,然后访问了q-1个右边的点,我们把它们加入**T**（S,T是两个集合）。

然后把lx[i],i∈S都减去一个**松弛量a**，ly[j],j∈T，都加上一个a，这样就会有一些不在T中的点和在S中的点之间的边能够进入相等子图，同时已经在相等子图里的边不出去，继续进行KM直到匹配了这个点为止。

至于找a的方法，为了保证进来的边是能进来的之中最大的，同时又有边进来，

a=min{lx[i]+ly[j]-w[i][j]|i∈S，j∉T}，这个过程就n^2暴力枚举就好了，因此整个算法时间复杂度为n^4，当然还有一个n^3的优化方法，不过n^4就能0ms秒杀此题，所以这里就不用了。

这里讲的并不是很深，有些概念没有涉及，建议大家最好还是上网查些资料好好学一下。

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\~我是分割线~////////////////////

上面是求的最大值，怎么求最小值呢？

把边权整体取负啊。

最终答案嘛：根据相等子图的定义就是顶标和了。

最后贴代码，再不济只能看代码了。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<cstdlib>
#include<string>
#include<queue>
#include<map>
#include<vector>
#include<ctime>

#define ll long long
#define R register
#define IL inline
#define Rf(a,b,c) for(R int (a)=(b);(a)<=(c);++(a))
#define Tf(a,b,c) for(R int (a)=(b);(a)>=(c);--(a))
#define MP make_pair
#define PA pair<int,int>
#define MES(a,b) memset((a),(b),sizeof((a)))
#define MEC(a,b) memset((a),(b),sizeof((b)))
#define D double

using namespace std;

const int N=505;

int n,m,lx[N],ly[N],link[N],w[N][N];
bool S[N],T[N];

IL int read() {
    int x=0,f=1;char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x*=10;x+=(ch-'0');ch=getchar();}
    return x*f;
}
IL void write(int x) {
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}

bool dfs(int x) {//这就是一般的二分图匹配
    S[x]=true;//把左边的点都加入S
    Rf(i,1,n) 
    if(lx[x]+ly[i]==w[x][i]&&!T[i]) {//判断这条边是否在相等子图里，不要再建图了
        T[i]=true;//右边的点加入T
        if(!link[i]||dfs(link[i])) {
            link[i]=x;
            return true;
        }
    }
    return false;
}

IL void update() {//n^2暴力找a，并修改
    R int a=1<<30;
    Rf(i,1,n) if(S[i]) 
        Rf(j,1,n) if(!T[j]) 
            a=min(a,lx[i]+ly[j]-w[i][j]); 
    Rf(i,1,n) {
        if(S[i]) lx[i]-=a;
        if(T[i]) ly[i]+=a;
    }
}

IL void KM() {
    Rf(i,1,n) {
        link[i]=lx[i]=ly[i]=0;
        Rf(j,1,n) lx[i]=max(lx[i],w[i][j]);//顶标初值
    }
    Rf(i,1,n) while(true) {
        Rf(j,1,n) S[j]=T[j]=false;//记得每次都要清空
        if(dfs(i)) break;//找到增广路了
        else update();//没找到就得松弛了
    }
} 


signed main()
{
    n=read();
    Rf(i,1,n) Rf(j,1,n) w[i][j]=read();
    KM();
    int sum1=0,sum2=0;
    Rf(i,1,n) sum1+=lx[i]+ly[i];//最后的顶标和就是最终答案了
    Rf(i,1,n) Rf(j,1,n) w[i][j]*=-1;//整体取负跑最小
    KM();
    Rf(i,1,n) sum2+=lx[i]+ly[i];
    write(-sum2);//记得要把答案再取负回来啊
    putchar('\n');write(sum1);
    
    return 0;
}
```

---

## 作者：Youngsc (赞：21)

挂个博客[Youngsc](https://youngscc.github.io/)


**首先膜拜楼下机房巨佬%%%KM二分图最佳完美匹配**

**蒟蒻只想说我根本不知道咋求顶标，好在本蒟蒻会~~费用流~~**

**关于二分图最佳完美匹配问题，就是让二分图带上边权，然后让选出来的完美匹配权值之和最大**

**费用流的话很简单，先建一个超级源超级汇**

**然后从超级源想每一个人连一条容量为1，费用为0的弧**

**同样的，从每一个任务向超级汇连一条容量为1，费用为0的弧**

**然后对于每一个人和每一个任务，对应的从人向任务连一条容量为1，费用为$C_{i,j}$的弧**

**以上各弧容量为1是为了防止一个点被多次匹配**

**然后跑一个最大费用最大流和最小费用最大流就完美的解决了**


**注意题面里并没有说$C_{i,j}$是正整数，所以可能会有负值**


### 代码如下


```cpp
# include <bits/stdc++.h>
# define R register
# define LL long long
# define inf 2147483647

using namespace std;

int n,s,t,ans,fr[210],h[210],flo[210],e=-1,dis[210],pre[210],x;
bool v[210];

queue <int> q;

struct zx{int v,flow,w,pre;} ed[50010];

template <typename T> inline void in(R T& a){
    R char c=getchar();R T x=0,f=1;
    while(!isdigit(c)) (c=='-'? f=-1:0),c=getchar();
    while(isdigit(c)) x=(x<<1)+(x<<3)+c-'0',c=getchar();
    a=x*f;
}

inline void add(R int x,R int y,R int z,R int w){
    ed[++e] = (zx){y,z,w,h[x]};
    h[x] = e;
}

inline bool bfs_max(){
    for(R int i=s; i<=t; ++i) dis[i] = -inf/3;
    dis[s] = 0,flo[s] = inf;
    q.push(s);
    while(!q.empty()){
        R int x=q.front();
        q.pop();
        for(R int i=h[x]; i!=-1; i=ed[i].pre){
            R int p=ed[i].v;
            if(dis[p] < dis[x] + ed[i].w&&ed[i].flow){
                dis[p] = dis[x] + ed[i].w;
                if(!v[p]) v[p] = 1,q.push(p);
                flo[p] = min(ed[i].flow,flo[x]);
                pre[p] = i;
                fr[p] = x;
            }
        }
        v[x] = 0;
    }
    return dis[t] > -inf/3;;
}

inline bool bfs_min(){
    for(R int i=s; i<=t; ++i) dis[i] = inf/3;
    dis[s] = 0,flo[s] = inf;
    q.push(s);
    while(!q.empty()){
        R int x=q.front();
        q.pop();
        for(R int i=h[x]; i!=-1; i=ed[i].pre){
            R int p=ed[i].v;
            if(dis[p] > dis[x] + ed[i].w&&ed[i].flow){
                dis[p] = dis[x] + ed[i].w;
                if(!v[p]) v[p] = 1,q.push(p);
                flo[p] = min(ed[i].flow,flo[x]);
                pre[p] = i;
                fr[p] = x;
            }
        }
        v[x] = 0;
    }
    return dis[t] < inf/3;
}

int main(){
    // freopen("home.in","r",stdin);
    // freopen("home.out","w",stdout);
    in(n);
    memset(h,-1,sizeof(h));
    for(R int i=1; i<=n; ++i)
        for(R int j=1; j<=n; ++j)
            in(x),add(i,j+n,1,x),add(j+n,i,0,-x);
    s=0,t=n+n+1;
    for(R int i=1; i<=n; ++i) add(s,i,1,0),add(i,s,0,0),add(i+n,t,1,0),add(t,i+n,0,0);
    while(bfs_min()){
        ans += dis[t]*flo[t];
        R int now = t;
        while(now != s){
            ed[pre[now]].flow -= flo[t];
            ed[pre[now]^1].flow += flo[t];
            now = fr[now];
        }
    }
    printf("%d\n",ans);
    for(R int i=0; i<=e; i+=2) ed[i].flow += ed[i^1].flow,ed[i^1].flow = 0;
    ans = 0;
    while(bfs_max()){
        ans += dis[t]*flo[t];
        R int now = t;
        while(now != s){
            ed[pre[now]].flow -= flo[t];
            ed[pre[now]^1].flow += flo[t];
            now = fr[now];
        }
    }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：lolte (赞：14)

### 这是GD初二蒟蒻 $lolte$ 的题解

写了一周多的最大流，现在换成费用流的题来练练手。

由于我太弱了，不会KM/EK/zkw/PD，所以只能用 $dinic$ 了。

------

这题说实话很裸，接近于模板了~~（那我在作甚）~~

费用流模板的实现我就不讲了，主要讲一下建图。

---
### 先来做最小值

由题可知，本题可抽象成一个二分图，两边分别是人和工件。

默认**容量为1**（因为每人只能修一个工件）

对题目中的 $c_{ij}$ ，考虑将人和工作连一条**费用为 $c_{ij}$ **的边。

由于每人只能修一个工件，所以将源点与人连一条**容量为1，费用为0**的边

之后再将每个工件和汇点连一条**费用为0**的边。

跑一遍最小费用最大流即可求出最小值。

---

### 第二个问题来了，最大值怎么做？

这个问题很简单啦

只需将原来所有边的**费用**变为**相反数**，跑一遍最小费用最大流，就可求出**最大值的相反数**。输出时再将它取**相反**就好啦。

---

最后是代码。

我用的是 $dinic$ , 37ms(无O2)，35ms(O2)

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=150,inf=214784360;
int n,head[maxn*2],dist[maxn*2];
int q[maxn*100],l,r,cnt=1,s,t,maxflow=0,mincost=0;
int x[maxn][maxn];
bool vis[maxn*2];
struct node{
    int to,nxt,w,cost;
}e[maxn*maxn*2];
inline void add(int u,int v,int w,int c) {
    ++cnt;
    e[cnt].to=v;e[cnt].w=w;e[cnt].cost=c;e[cnt].nxt=head[u];head[u]=cnt;
    ++cnt;
    e[cnt].to=u;e[cnt].w=0;e[cnt].cost=-c;e[cnt].nxt=head[v];head[v]=cnt;
}
bool spfa(){
    memset(vis,0,sizeof(vis));
    memset(dist,0x3f,sizeof(dist));
    l=1;r=0;
    q[++r]=s; dist[s]=0; vis[s]=1;
    while (l<=r) {
        int u=q[l++];
        vis[u]=0;
        for (int i=head[u];i;i=e[i].nxt) {
            int v=e[i].to;
            if (e[i].w && dist[v]>dist[u]+e[i].cost) {
                dist[v]=dist[u]+e[i].cost;
                if (!vis[v]) {
                    vis[v]=1;
                    q[++r]=v;
                }
            }
        }
    }
    return dist[t]<9999999;
}
int dfs(int u,int flow) {
    if (u==t) {
        vis[t]=1;
        maxflow+=flow;
        return flow;
    }
    int goflow=0,used=0;
    vis[u]=1;
    for (int i=head[u];i;i=e[i].nxt) {
        int v=e[i].to;
        if ((!vis[v] || v==t) && e[i].w && dist[v]==dist[u]+e[i].cost) {
            goflow=dfs(v,min(flow-used,e[i].w));
            if (!goflow) continue;
            used+=goflow;
            e[i].w-=goflow;
            e[i^1].w+=goflow;
            mincost+=goflow*e[i].cost;
            if (used==flow) break;
        }
    }
    return used;
}
void MCMF(){ 
    while (spfa()) {
        vis[t]=1;
        while (vis[t]) {
            memset(vis,0,sizeof(vis));
            dfs(s,inf);
        }
    }
}
int a=0;
int main(){
    scanf("%d",&n);
    s=n*2+20;
    t=s+1;
    for (int i=1;i<=n;++i) {
        add(s,i,1,0);
        add(i+n+1,t,1,0);
        for (int j=1;j<=n;++j) {
            scanf("%d",&x[i][j]);
            add(i,j+n+1,1,-x[i][j]);
        }
    }
    MCMF();
    int lzr=mincost;
    mincost=maxflow=0;
    cnt=1;
    memset(head,0,sizeof(head));
    memset(e,0,sizeof(e));
    memset(vis,0,sizeof(vis));
    for (int i=1;i<=n;++i) {
        add(s,i,1,0);
        add(i+n+1,t,1,0);
        for (int j=1;j<=n;++j) {
            add(i,j+n+1,1,x[i][j]);
        }
    }
    MCMF();
    printf("%d\n%d\n",mincost,-lzr);
    return 0;
}
```

---

## 作者：Capella (赞：4)

二分图最佳完美匹配——Kuhn-Munkres(KM)算法。


过程借鉴楼上Dalao的题解。


我只是来一波链式前向星的写法。


```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;
const int MAXN=210,MAXM=10010,INF=0x3f3f3f3f;
bool vis[MAXN];
int n,cnt,ans,head[MAXN],match[MAXN],mark[MAXN];
struct edge
{
    int nxt,to,w;
}e[MAXM];
void AddEdge(int u,int v,int w)
{
    e[++cnt].nxt=head[u];
    e[cnt].to=v;
    e[cnt].w=w;
    head[u]=cnt;
}
void Init(bool flag)
{
    ans=0;
    memset(match,0,sizeof match);
    memset(mark,0xb0,sizeof mark);
    for(int u=1;u<=n;++u)
        for(int i=head[u];i;i=e[i].nxt)
            mark[u]=max(mark[u],flag ? e[i].w=-e[i].w : e[i].w),mark[e[i].to]=0;
}
bool DFS(int u)
{
    vis[u]=1;
    for(int i=head[u],v;i;i=e[i].nxt)
        if(!vis[v=e[i].to] && e[i].w==mark[u]+mark[v])
        {
            vis[v]=1;
            if(!match[v] || DFS(match[v]))
            {
                match[v]=u;
                return 1;
            }
        }
    return 0;
}
void Update(void)
{
    int d=INF;
    for(int u=1;u<=n;++u)
        if(vis[u])
            for(int i=head[u],v;i;i=e[i].nxt)
                if(!vis[v=e[i].to])
                    d=min(d,mark[u]+mark[v]-e[i].w);
    for(int i=1,j;i<=n;++i)
    {
        if(vis[i])
            mark[i]-=d;
        if(vis[j=i+n])
            mark[j]+=d;
    }
}
void KM(bool flag)
{
    Init(flag);
    for(int i=1;i<=n;++i)
        while(1)
        {
            memset(vis,0,sizeof vis);
            if(DFS(i))
                break;
            Update();
        }
    for(int i=1;i<=n;++i)
        ans+=mark[i]+mark[i+n];
    printf("%d\n",flag ? ans : -ans);
}
int main(int argc,char *argv[])
{
    scanf("%d",&n);
    memset(mark,0xb0,sizeof mark);
    for(int i=1;i<=n;++i)
        for(int j=1,w;j<=n;++j)
        {
            scanf("%d",&w);
            AddEdge(i,j+n,-w);
        }
    KM(0);
    KM(1);
    return 0;
}
```

>谢谢阅读


---

## 作者：月雩·薇嫭 (赞：3)

# 洛谷 P4014:「分配问题」
[题目链接](https://www.luogu.com.cn/problem/P4014)
### 题目描述
有n件工作要分配给n个人做.第i个人做第j件工作产生的效益为$C_{ij}$.试设计一个将n件工作分配给n个人做的分配方案,使产生的总效益最大.
### 输入格式
文件的第1行有1个正整数n,表示有n件工作要分配给n个人做.
接下来的n行中,每行有n个整数 $C_{ij}$,表示第i个人做第j件工作产生的效益为$C_{ij}$.
### 输出格式
两行分别输出最小总效益和最大总效益。
### 输入输出样例

#### 样例输入
    5
    2 2 2 1 2
    2 3 1 2 4
    2 0 1 1 1
    2 3 4 3 3
    3 2 1 2 1
#### 样例输出
    5
    14
### 说明/提示
1$\le$n$\le100$
**一个人只能修一个工件**

这是一道**费用流经典题目**
### 建图

- **1.**设**0**为**超级源点**，**2$\times$n+1**为**超级汇点**，第**i**个人的节点为**i**，第**j**件工作节点为**j+n**
- **2.**从**超级源点** 向$\forall$i$\in$[1,n]连接一条容量为1，费用为0的边
- **3.**从$\forall$j$\in$[n+1,2$\times$n]向**超级汇点**连接一条容量为1，费用为$0$的边
- **4**.从$\forall$i$\in$ [1, n]向$\forall$j$\in$ [n+1,n$\times$2]，连接一条容量为1，费用为$C_{i, j}$的边

### 做法
跑一遍**最小费用最大流**&**最大费用最小流**，然后再分别输出最**小**值与最**大**值
(**温馨提醒：一定要输出，不然会WA！**)

**为各位大佬献上我丑陋的代码~**

```cpp
#include<bits/stdc++.h>
#define FQ(i,a,b) for(register int i=a;i<=b;i++)
#define prf printf
#define scf scanf
#define ll long long
using namespace std;
const int N=5e4+10;
int INF,n,num=1,ne[N],fi[N],to[N],w[N],pl[N],S,T;
int dst[N],incf[N],P[N],vis[N],ans;
queue<int> q;
void FindMaxN()
{
	int fINDmAXn[1];
	memset(fINDmAXn,128/2,sizeof(fINDmAXn));	
	INF=fINDmAXn[0];
}
ll read()
{
	ll x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;	
}
void add(int x,int y,int z,int kl)
{
    ne[++num]=fi[x];    
    fi[x]=num;    
    to[num]=y;   
    w[num]=z;
    pl[num]=kl; 
}
bool spfa()
{ 
    for(int i=S;i<=T;i++)dst[i]=INF; 
    memset(vis,0,sizeof(vis));  
    q.push(S),dst[S]=0;	
	incf[S]=1<<30,vis[S]=true;   
    while(!q.empty())
    {      
        int x=q.front();      
        vis[x]=false;q.pop();        
        for(int i=fi[x];i;i=ne[i])
        {            
            int ver=to[i];             
            if(dst[ver]>dst[x]+pl[i]&&w[i])
            {                
                dst[ver]=dst[x]+pl[i];                
                incf[ver]=min(incf[x],w[i]);                
                P[ver]=i;                
                if(!vis[ver])vis[ver]=true,q.push(ver);                 
            }             
        }    
    }
    return dst[T]!=INF;  
}
void update()
{	
	int x=T;     
    while(x!=S)
    {         
        int i=P[x];         
        w[i]-=incf[T];       
        w[i^1]+=incf[T];
   
        x=to[i^1];
    }
    ans+=dst[T]*incf[T];
}
bool spfa_d()
{
    for(int i=S;i<=T;i++)dst[i]=-INF;
    q.push(S),dst[S]=0;incf[S]=1<<30;
    while(!q.empty())
    {
        int x=q.front();
        vis[x]=false;q.pop();
        for(int i=fi[x];i;i=ne[i])
        {
            int ver=to[i];
            if(dst[ver]<dst[x]+pl[i]&&w[i])
            {
                dst[ver]=dst[x]+pl[i];
                incf[ver]=min(incf[x],w[i]);
                P[ver]=i;
                if(!vis[ver])vis[ver]=true,q.push(ver);
            }
        }
    }
    return dst[T]!=-INF;
}
void update_d()
{
	int x=T;
    while(x!=S)
    {
        int i=P[x];
        w[i]-=incf[T];
        w[i^1]+=incf[T];
        x=to[i^1];
    }
    ans+=dst[T]*incf[T];
}
void add_x(int x,int y,int z,int kl)
{
	add(x,y,z,kl);
	add(y,x,0,-kl);
}
int main()
{
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	FindMaxN();
	n=read();S=0,T=n*2+1;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			int x=read();
			add_x(i,j+n,1,x);
		}
	}
	for(int i=1;i<=n;i++)add_x(S,i,1,0),add_x(i+n,T,1,0);
	while(spfa())update();
	printf("%d\n",ans);
	ans=0;
	for(int i=2;i<=num;i+=2)w[i]+=w[i^1],w[i^1]=0;
	while(spfa_d())update_d();
	printf("%d\n",ans);
	return 0;		
}
//**月雩·薇嫭**
```



### _**by：月雩·薇嫭**_

---

## 作者：Ireliaღ (赞：3)

**费用流经典题目，我用的指针版Zkw费用流。**

### 建图

* 设$0$为超级原点，$2 \times n + 1$为超级汇点。第$i$个人的节点为$i$，第$j$件工作的节点为$n + j$

* 从$0$向$\forall i \in [1,n]$连接容量为$1$，费用为$0$的边

* 从$\forall j \in [n + 1, 2 \times n]$向$2 \times n + 1$连接容量为$1$，费用为$0$的边

* 从$\forall i \in [1, n]$向$\forall j \in [n + 1, n \times 2]$连接容量为$1$，费用为$c_{i, j}$的边

然后跑一遍最小费用最大流，跑一遍最大费用最大流，分别输出两次得到的费用即可。打一个板子复制粘贴一遍就行了。代码如下

```cpp
#include <iostream>
#include <cstring>
#include <deque>

using namespace std;

const int MAXN = 105;
const int INF = 0x3f3f3f3f;

int n;

struct Edge{
	int to, val, cost;
	Edge *next, *ops;
	Edge(int to, int val, int cost, Edge *next): to(to), val(val), cost(cost), next(next){}
};

namespace Zkw1{
	Edge *head[MAXN << 1];
	bool vis[MAXN << 1];
	int dis[MAXN << 1];
	int s, t, res ,ans;

	void AddEdge(int u, int v, int w, int c) {
		head[u] = new Edge(v, w, c, head[u]);
		head[v] = new Edge(u, 0, -c, head[v]);
		head[u]->ops = head[v]; head[v]->ops = head[u];
	}

	bool Spfa() {
		memset(dis, INF, sizeof(dis));
		memset(vis, false, sizeof(vis));
		deque<int> q; q.push_back(s); vis[s] = true; dis[s] = 0;
		while (!q.empty()) {
			int u = q.front(); q.pop_front();
			vis[u] =false;
			for (Edge *e = head[u]; e; e = e->next) {
				int v = e->to;
				if (e->val > 0 && dis[u] + e->cost < dis[v]) {
					dis[v] = dis[u] + e->cost;
					if (!vis[v]) {
						vis[v] = true;
						if (!q.empty() && dis[v] < dis[q.front()]) q.push_front(v);
						else q.push_back(v);
					}
				}
			}
		}
		return dis[t] < INF;
	}

	int Dfs(int u, int flow) {
		vis[u] = true;
		if (u == t) {
			res += flow;
			return flow;
		}
		int used = 0;
		for (Edge *e = head[u]; e; e = e->next) {
			int v = e->to;
			if ((v == t || !vis[v]) && e->val > 0 && dis[v] == dis[u] + e->cost) {
				int mi = Dfs(v, min(e->val, flow - used));
				if (mi) {
					used += mi;
					e->val -= mi;
					e->ops->val += mi;
					ans += e->cost * mi;
				}
				if (used == flow) break;
			}
		}
		return used;
	}

	void Work() {
		res = ans = 0;
	    while (Spfa()) {
			vis[t] = true;
			while (vis[t]) {
				memset(vis, false, sizeof(vis));
				Dfs(s, INF);
			}
		}
	}
}

namespace Zkw2{
	Edge *head[MAXN << 1];
	bool vis[MAXN << 1];
	int dis[MAXN << 1];
	int s, t, res ,ans;

	void AddEdge(int u, int v, int w, int c) {
		head[u] = new Edge(v, w, c, head[u]);
		head[v] = new Edge(u, 0, -c, head[v]);
		head[u]->ops = head[v]; head[v]->ops = head[u];
	}

	bool Spfa() {
		//memset(dis, -INF, sizeof(dis));
		for (int i = 1; i <= 2 * n + 1; i++) dis[i] = -INF;
		memset(vis, false, sizeof(vis));
		deque<int> q; q.push_back(s); vis[s] = true; dis[s] = 0;
		while (!q.empty()) {
			int u = q.front(); q.pop_front();
			vis[u] =false;
			for (Edge *e = head[u]; e; e = e->next) {
				int v = e->to;
				if (e->val > 0 && dis[u] + e->cost > dis[v]) {
					dis[v] = dis[u] + e->cost;
					if (!vis[v]) {
						vis[v] = true;
						if (!q.empty() && dis[v] > dis[q.front()]) q.push_front(v);
						else q.push_back(v);
					}
				}
			}
		}
		return dis[t] > -INF;
	}

	int Dfs(int u, int flow) {
		vis[u] = true;
		if (u == t) {
			res += flow;
			return flow;
		}
		int used = 0;
		for (Edge *e = head[u]; e; e = e->next) {
			int v = e->to;
			if ((v == t || !vis[v]) && e->val > 0 && dis[v] == dis[u] + e->cost) {
				int mi = Dfs(v, min(e->val, flow - used));
				if (mi) {
					used += mi;
					e->val -= mi;
					e->ops->val += mi;
					ans += e->cost * mi;
				}
				if (used == flow) break;
			}
		}
		return used;
	}

	void Work() {
		res = ans = 0;
	    while (Spfa()) {
			vis[t] = true;
			while (vis[t]) {
				memset(vis, false, sizeof(vis));
				Dfs(s, INF);
			}
		}
	}
}

int main() {
	ios :: sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
	cin >> n;
	Zkw1 :: s = 0; Zkw1 :: t = n * 2 + 1; Zkw2 :: s = 0; Zkw2 :: t = n * 2 + 1;
	for (int i = 1; i <= n; i++) Zkw1 :: AddEdge(0, i, 1, 0), Zkw1 :: AddEdge(i + n, n * 2 + 1, 1, 0), Zkw2 :: AddEdge(0, i, 1, 0), Zkw2 :: AddEdge(i + n, n * 2 + 1, 1, 0);
	for (int i = 1; i <= n; i++) {
		for (int j =1; j <= n; j++) {
			int x;
			cin >> x;
			Zkw1 :: AddEdge(i, n + j, 1, x);
			Zkw2 :: AddEdge(i, n + j, 1, x);
		}
	}
	Zkw1 :: Work(); Zkw2 :: Work();
	cout << Zkw1 :: ans << endl << Zkw2 :: ans << endl;
	return 0;
}

```

---

## 作者：Manjusaka丶梦寒 (赞：3)

讲解太长，怕霸占洛谷题解区，费用流详解请去查看[blog](https://www.cnblogs.com/rmy020718/p/9548758.html)

相对于最大流来说

■ 每条边多了一个值称为费用。

■ 在最大化流量的同时最小化每条边的费用与流量的乘积和。

■ 每次按照费用增广？

■ 反向边的费用设为原边的相反数(想象司机运错了给你再运回来并且会退钱 [  好人呐！！])

■每次增广的时候，流量$+m+m$，那么费用增加$m×dis[t]m×dis[t]$ (t为目标)

### 可行性

■ 会不会出现负环？

只要初始时没有负环，之后就不会有负环，因为真想和反向花费相反。

■ 注意到初始时所有反向边的残量为0，可以只考虑原图中的边。

■ 如果增广路中出现了负环，那么在上一次选择中一定有一条更短的路径。

■ 如果开始就有负环呢？

那么它说明你图建错了(存在某种玄学的消环的方法，但是好麻烦QAQ，而且时间复杂度得不到保证。)

### 正确性

■ 为什么是对的？

当前最小费用流 <=> 残量网络无负环

如果有负环我们可以从这个负环上走一圈来得到更小的解。

这东西反过来也是成立的，即如果有更小解，一定存在一个负环来让我们走一圈。

### 时间复杂度

这我咋知道，网络流的时间复杂度只有$O(TLE)$和$O(notTLE)$
一般的网络流根本跑不到上界，如果想要了解跑到上界的算法，可以去了解“前置-重贴标签算法”。

实现

我们考虑一下我们是怎么做最大流的，我们是将增广路按照距离来$bfs$分层，那么这个我们也可以模仿此，但是每次我们怎么走呢？

spfa中，我们按照费用的最小来走，这样子的话，就很明显是为了走最小花费了。

每次不断的去找最短路，从后往前依次更新用到的边。

最大流中已经提到了解法，在这里就不过多解释了。

bfs变成了spfa返回值还是一样的。

这道题目建立源点0，汇点设为1000，每个人只能干一个，所以流量限制为1，源点向每个人连边，工作向汇点连边，其花费为0，当每个人向工作连边，花费为其收益，所以就将收益问题转化为费用流。

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <queue>
using namespace std;
#define inf 0x7fffffff
int head[5050],tot;
struct ahah{
    int nxt,to,flow,dis;
}edge[10050];

void add(int x,int y,int z,int cost)
{
    edge[tot].nxt=head[x];
    edge[tot].to=y;
    edge[tot].flow=z;
    edge[tot].dis=cost;
    head[x]=tot++;
}
int n,m,s,t;
int x,y,z,k;
int last[50050],flow[10001],dis[10001],pre[10010];
bool vis[5010];
queue <int> Q;

int spfa(int s,int t)
{
    memset(flow,0x7f,sizeof(flow));
    memset(dis,0x7f,sizeof(dis));
    memset(vis,0,sizeof(vis));
    Q.push(s);vis[s]=1;dis[s]=0,pre[t]=-1;
    while(!Q.empty())
    {
        int temp=Q.front();
        Q.pop();
        vis[temp]=0;
        for(int i=head[temp];i!=-1;i=edge[i].nxt)
        {
            int v=edge[i].to; 
            if(edge[i].flow>0&&dis[v]>dis[temp]+edge[i].dis)
            {
                dis[v]=dis[temp]+edge[i].dis;
                pre[v]=temp;
                last[v]=i;
                flow[v]=min(flow[temp],edge[i].flow);
                if(!vis[v])
                {
                    vis[v]=1;
                    Q.push(v); 
                }
            }
        }
    }
    return pre[t]!=-1;
}

int MCMF()
{
    int ans=0;
    while(spfa(s,t))
    {
        int now=t;
        ans+=flow[t]*dis[t];
        while(now!=s)
        {
            edge[last[now]].flow-=flow[t];
            edge[last[now]^1].flow+=flow[t];
            now=pre[now];
        }
    }
    return ans;
}
int mp[111][111];
void init()
{
    tot=0;s=0,t=1000;
    memset(head,-1,sizeof(head));
    for(int i=1;i<=n;i++)add(0,i,1,0),add(i,0,0,0);
    for(int i=n+1;i<=2*n;i++)add(i,t,1,0),add(t,i,0,0);
}
int main()
{
    scanf("%d",&n);
    init();
    for(int i=1;i<=n;i++)
    	for(int j=1;j<=n;j++)
    	{
    		scanf("%d",&mp[i][j]);
    		add(i,n+j,1,mp[i][j]);
    		add(n+j,i,0,-mp[i][j]);
        }
    printf("%d\n",MCMF());
    memset(&edge,0,sizeof(edge));
    memset(last,0,sizeof(last));
    memset(pre,0,sizeof(pre));
    init();
    for(int i=1;i<=n;i++)
    	for(int j=1;j<=n;j++)
    	{
    		add(i,n+j,1,-mp[i][j]);
    		add(n+j,i,0,mp[i][j]);
        }
    printf("%d",-MCMF());
}
```

---

## 作者：雷神山速度 (赞：2)

这道题是练习费用流的一道模板题，思考的难点主要在建图方面

超级源点和超级汇点的建立不需要多说，大家都清楚。

每个人和每项工作建边，流量为1，费用为(+/-)Cij

这里注意一下，求最小收益是使用**正权边**，即费用是Cij，求最大收益时，使用**负权边**，即费用是-Cij，输出时输出相反数既可,毕竟我们学的模板是最小费

然后就是连接超级源点和每一个人以及每项工作和超级汇点连接，流量为1，费用为0

补充一句关于所有边的流量为1，是因为n项工作平分给n个人做，也就是一人只能做一项

上代码

```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <queue>

const int N = 5e3 + 5, M = 1e5 + 5;
const int INF = 0x3f3f3f3f;
int n, m, tot = 1, lnk[N];
int cur[N], ter[M], nxt[M];
int cap[M], cost[M], dis[N], ret;
bool vis[N];

inline int read(){
    int num = 0, x = 1;
    char c = getchar();
    while(c < '0' || c > '9'){
        if(c == '-') x = -x;
        c = getchar();
    }
    while(c <= '9' && c >= '0'){
        num = (num << 1) + (num << 3) + c - '0';
        c = getchar();
    }
    return num * x;
}

void add(int u, int v, int w, int c){
    ter[++tot] = v;
    nxt[tot] = lnk[u];
    lnk[u] = tot;
    cap[tot] = w;
    cost[tot] = c;
}

void addedge(int u, int v, int w, int c){
    add(u, v, w, c);
    add(v, u, 0, -c);
}

bool spfa(int s, int t){
    memset(dis, 0x3f, sizeof(dis));
    memcpy(cur, lnk, sizeof(lnk));
    std::queue<int> q;
    q.push(s), dis[s] = 0;
    vis[s] = 1;
    while (!q.empty()){
        int u = q.front();
        q.pop();
        vis[u] = 0;
        for(int i = lnk[u]; i; i = nxt[i]){
            int v = ter[i];
            if(cap[i] && dis[v] > dis[u] + cost[i]){
                dis[v] = dis[u] + cost[i];
                if(!vis[v]){
                    q.push(v);
                    vis[v] = 1;
                }
            }
        }
    }
    return dis[t] != INF;
}

int dfs(int u, int t, int flow){
    if (u == t) return flow;
    vis[u] = 1;
    int ans = 0;
    for (int &i = cur[u]; i && ans < flow; i = nxt[i]){
        int v = ter[i];
        if (!vis[v] && cap[i] && dis[v] == dis[u] + cost[i]){
            int x = dfs(v, t, std::min(cap[i], flow - ans));
            if(x){
                ret += x * cost[i];
                cap[i] -= x;
                cap[i ^ 1] += x;
                ans += x;
            }
        }
    }
    vis[u] = 0;
    return ans;
}

int mcmf(int s, int t){
    int ans = 0;
    while (spfa(s, t)){
        int x;
        while ((x = dfs(s, t, INF))) ans += x;
    }
    return ans;
}

int main(){
    int s1, s2, t1, t2;
    n = read();
    s1 = 0;
    t1 = 2 * n + 1;
    s2 = 3 * n;
    t2 = 5 * n + 1;
    for(register int i = 1; i <= n; ++i){
        addedge(s1, i, 1, 0);
        addedge(n + i, t1, 1, 0);
        addedge(s2, 3 * n + i, 1, 0);
        addedge(4 * n + i, t2, 1, 0);
        for(register int j = 1; j <= n; ++j){
            int u = read();
            addedge(i, n + j, 1, u);
            addedge(3 * n + i, 4 * n + j, 1, -u);
        }
    }
    int ans1 = mcmf(s1, t1);
    printf("%d\n", ret);
    ret = 0;
    int ans2 = mcmf(s2, t2);
    printf("%d\n", -ret);
    return 0;
}
```

以上，完结

---

## 作者：wine (赞：1)

[排版搞不定，暂时用一下图片吧](https://blog.csdn.net/qq_33831360/article/details/94043097)

![火狐截图_2019-06-29T15-31-24.499Z.png](https://i.loli.net/2019/06/29/5d1784862e79992772.png)

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>

using namespace std;

#define N 110
void Out(int a[N][N],int v[N][N],int n) {
     for (int i = 1; i <= n; i++){
        for (int j = 1; j <= n; j++) {
           if(!v[i][j]) printf("%4d",a[i][j]);
           else printf("   %c",v[i][j]==1?'O':'X');
        }
       puts("");
    }puts("End!");
}

int HZ[N],LZ[N];

struct Pair {
    int x,y;
    Pair(int x = 0,int y = 0):x(x),y(y){}
    bool operator < (const Pair & b) const {
        return HZ[this->x]==HZ[b.x] ? LZ[this->y]<LZ[b.y] : HZ[this->x]<HZ[b.x];
    }
}Pt[N*N];

int FH[N],FL[N];
int Maxx,Mx;
int st[N*N],tot,used[N*N];
void dfs(int s,int t,int sum) {
    if (sum > Mx) {
        Mx = sum;
        used[0] = tot;//记录最好方案
        for (int i = 1; i <= tot; i++) used[i] = st[i];
    }
    if (Mx == Maxx) return;//已经找到满意解
    if (t-s+1+sum <= Mx) return;//乐观估计不如目前最优解
    if (s > t) return;
    if (!FH[Pt[s].x] && !FL[Pt[s].y]) { //选s点
        FH[Pt[s].x] = 1;
        FL[Pt[s].y] = 1;
        st[++tot] = s;
        dfs(s+1,t,sum+1);
        --tot;
        FH[Pt[s].x] = 0;
        FL[Pt[s].y] = 0;
    }
    dfs(s+1,t,sum);//不选s点
}

int calc(int b[N][N],int n) {
    int a[N][N],v[N][N];
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            a[i][j] = b[i][j];
    for (int i = 1; i <= n; i++) {
        int t = a[i][1];
        for (int j = 2; j <= n; j++)
          if (a[i][j] < t) t = a[i][j];
        for (int j = 1; j <= n; j++)
          a[i][j] -= t;
    }
    for (int i = 1; i <= n; i++) {
        int t = a[1][i];
        for (int j = 2; j <= n; j++)
          if (a[j][i] < t) t = a[j][i];
        for (int j = 1; j <= n; j++)
          a[j][i] -= t;
    }
    //先让每行每列都有0
//Out(a,v,n);
    int H[N],L[N];
    while(1) {
      for (int i = 1; i <= n; i++) {
        H[i] = L[i] = 0; //H[i]，第i行有多少个0，L为列
        FH[i] = FL[i] = 0; //FH[i],第i行有没有画O
        for (int j = 1; j <= n; j++) v[i][j] = 0;//v[i][j] = 1代表‘O’,-1代表‘X’
      }
      for (int i = 1; i <= n; i++)
       for (int j = 1; j <= n; j++)
         if (a[i][j] == 0) {
            H[i]++; L[j]++;
         }
      int cnt = 0;
      while (1) {
        int tpcnt = cnt;
        for (int i = 1; i <= n; i++) //找每行单独的0画‘O’，同列画‘X’
         if (H[i] == 1) {
           int t = 1;
           while(a[i][t] || v[i][t]) t++;
           v[i][t] = 1;
           cnt++;  //cnt记有几个‘O’
           H[i]--; L[t]--;
           FH[i] = 1; FL[t] = 1;
           for (int j = 1; j <= n; j++)
            if (a[j][t]==0 && j!=i && v[j][t]==0) {
              v[j][t] = -1;
              H[j]--; L[t]--;
           }
        }
        for (int i = 1; i <= n; i++) //对称的
         if (L[i] == 1) {
           int t = 1;
           while(a[t][i] || v[t][i]) t++;
           v[t][i] = 1;
           cnt++;
           H[t]--; L[i]--;
           FH[t] = 1; FL[i] = 1;
           for (int j = 1; j <= n; j++)
            if (a[t][j]==0 && j!=i && v[t][j]==0) {
              v[t][j] = -1;
              H[t]--; L[j]--;
            }
         }
         if (tpcnt == cnt) break;
        }
//Out(a,v,n);
      int top = 0;
      for (int i = 1; i <= n; i++)
       for (int j = 1; j <= n; j++)
        if (a[i][j]==0 && v[i][j]==0) {
            Pt[++top] = Pair(i,j);
            HZ[i]++;
            LZ[j]++;
        }
      sort(Pt+1,Pt+top+1);//同行同列少的排前面
      Maxx = n-cnt;
      Mx = 0; used[0] = 0;
      dfs(1,top,0);//对剩下的0进行试探画‘O’
      cnt += Mx;
      for (int i = 1; i <= used[0]; i++) {
            v[Pt[used[i]].x][Pt[used[i]].y] = 1;
            FH[Pt[used[i]].x] = 1;
            FL[Pt[used[i]].y] = 1;
      }
//Out(a,v,n);
      if (cnt == n) { //已经找到
        int ans = 0;
        for (int i = 1; i <= n; i++)
          for (int j = 1; j <= n; j++)
            if (v[i][j] == 1) ans += b[i][j];
        return ans;
      }
      int flagx[N],flagy[N]; //对号标记
      for (int i = 1; i <= n; i++) flagx[i] = flagy[i] = 0;
      int cas = 1;//时间戳，每次只检查新增对号行/列
      for (int i = 1; i <= n; i++)
         if (!FH[i]) flagx[i] = cas;
      bool chang = 1;
      while (chang) {
        chang = 0;
        cas++;
        for (int i = 1; i <= n; i++)
          if (flagx[i] == cas-1)
            for (int j = 1; j <= n; j++)
              if (v[i][j] == -1) {
                flagy[j] = cas;
                chang = 1;
              }
        for (int i = 1; i <= n; i++)
          if (flagy[i] == cas-1)
            for (int j = 1; j <= n; j++)
              if (v[j][i] == 1) {
                flagx[j] = cas;
                chang = 1;
              }
      }
      int Mi = ~0u>>2;
      for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
          if (flagx[i] && !flagy[j] && Mi > a[i][j])
            Mi = a[i][j];  //未划线找最小的
       for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
          if (flagx[i] && !flagy[j]) //未划线
             a[i][j] -= Mi;
          else if (!flagx[i] && flagy[j]) //线交点
             a[i][j] += Mi;
    }
}

int main() {
    int n,a[N][N],b[N][N];
    scanf("%d",&n);
    for (int i = 1; i <= n; i++)
     for (int j = 1; j <= n; j++) {
       scanf("%d",&a[i][j]);
       b[i][j] = -a[i][j];
     }
    printf("%d\n%d",calc(a,n),-calc(b,n));
    return 0;
}
```



---

## 作者：zhengrunzhe (赞：1)

二分图最小/大带权匹配，用网络最小/大费用最大流实现

提供用Dijkstra跑最小费用流

建立超级源点，与每一个人连费用为0的边

建立超级汇点，每一个工作与其连费用为0的边

人i和工作j连费用为Cij的边
，所有正向边的流量为1，反向边流量为0，费用为其正向费用的相反数

然后跑源点汇点的最小费用最大流

题目还问最大费用，把所有边费用变为相反数、流量还原再跑一遍输出结果的相反数即可

类似Johnson算法，赋予每个点一个势h[]，保证有负边时Dijkstra的正确性

```cpp
#include<queue>
#include<cstdio>
#include<climits>
#include<utility>
#include<algorithm>
#define rev(x) x%2?x+1:x-1
using namespace std;
template<class type>inline const void read(type &in)
{
    in=0;char ch=getchar();short fh=1;
    while (ch<48||ch>57)fh=ch=='-'?-1:fh,ch=getchar();
    while (ch>47&&ch<58)in=(in<<3)+(in<<1)+ch-48,ch=getchar();
    in*=fh;
}
typedef pair<int,int>node;
typedef priority_queue<node,vector<node>,greater<node> >heap;
const int N=500;
int n,s,t;
int head[N],cnt;
struct edge
{
	int to,next,cost;bool flow;
	inline const void create(int u,int v,bool f,int w)
	{
		next=head[u];
		head[u]=cnt;
		flow=f;
		cost=w;
		to=v;
	}
}e[N*N];
inline const void connect(int u,int v,int w)
{
	e[++cnt].create(u,v,1,w);
	e[++cnt].create(v,u,0,-w);
}
bool inq[N];
int h[N],preDot[N],preEdge[N];
inline const void spfa() //先跑一边spfa确认h数组
{
	fill(inq+1,inq+t+1,0);
	fill(h+1,h+t+1,INT_MAX);
	queue<int>q;q.push(s);h[s]=0;inq[s]=1;
	while (q.size())
	{
		int u=q.front();q.pop();
		for (int v,i=head[u];i;i=e[i].next)
			if (e[i].flow&&h[v=e[i].to]>h[u]+e[i].cost)
				if (h[v]=h[u]+e[i].cost,!inq[v])
					inq[v]=1,q.push(v);
	}
}
int d[N];
bool vis[N];
inline const bool dijkstra()
{
	fill(vis+1,vis+t+1,0);
	fill(d+1,d+t+1,INT_MAX);
	heap q;q.push(make_pair(d[s]=0,s));
	while (q.size())
	{
		int u=q.top().second;q.pop();
		if (vis[u])continue;vis[u]=1;
		for (int v,i=head[u];i;i=e[i].next)
			if (e[i].flow&&!vis[v=e[i].to]&&d[v]>d[u]+e[i].cost+h[u]-h[v]) //加上势
				preDot[v]=u,preEdge[v]=i,
				q.push(make_pair(d[v]=d[u]+e[i].cost+h[u]-h[v],v));
	}
	return d[t]!=INT_MAX;
}
inline const int dinic()
{
	int cost=0;spfa();
	for (int i=1;i<=cnt;i+=2)e[i].flow=1,e[i+1].flow=0; //还原流量
	for (int i=1;i<=cnt;i++)e[i].cost*=-1; //好像printf的运算顺序是从后往前，所以说它会先运行最大费用，取了一次反，接下来运行最小费用，又会取反回去
	while (dijkstra())
	{
		for (int i=1;i<=t;i++)h[i]+=d[i];
		bool mn=1;
		for (int i=t;i!=s;i=preDot[i])
			mn=min(mn,e[preEdge[i]].flow);
		for (int i=t;i!=s;i=preDot[i])
			e[preEdge[i]].flow-=mn,
			e[rev(preEdge[i])].flow+=mn;
		cost+=mn*h[t];
	}
	return cost;
}
int main()
{
	read(n);s=n+n+1;t=n+n+2; //建立超级源点和汇点
	for (int i=1;i<=n;i++)
	 	for (int x,j=1;j<=n;j++)
	 		read(x),connect(i,j+n,x);
	for (int i=1;i<=n;i++)connect(s,i,0);
	for (int i=1;i<=n;i++)connect(i+n,t,0);
	printf("%d\n%d\n",dinic(),-dinic());
	return 0;
}
```

---

## 作者：arfa (赞：1)

一个带权值的二分图。

注意源点和左边的点连还有右边的点向汇点连的时候流量为 $1$ (不能被重复匹配) 就可以了。

本蒟蒻不会 $KM$。

```pascal
// luogu-judger-enable-o2
Uses math;

var
    from,reach,next,value,cost:array[-1..50010] of longint;
    dis,pre,last,flow:array[-1..50010] of int64;
    queue:array[-1..50010] of longint;
    cnt:array[-1..8100] of longint;
    vis:array[-1..8100] of boolean;
    val:array[-1..101,-1..101] of longint;
    n,m,i,j,k,tot,now,sink,source,maxflow,mincost:longint;

procedure add(x,y,sum_1,sum_2:longint);
begin
    inc(tot); from[tot]:=x; reach[tot]:=y; value[tot]:=sum_1; cost[tot]:= sum_2; next[tot]:=cnt[x]; cnt[x]:=tot;
    inc(tot); from[tot]:=y; reach[tot]:=x; value[tot]:=0    ; cost[tot]:=-sum_2; next[tot]:=cnt[y]; cnt[y]:=tot;
end;

function spfa:boolean;
var head,tail,now,i:longint;
begin
    filldword(dis,sizeof(dis) div 4,maxlongint);
    filldword(flow,sizeof(flow) div 4,maxlongint);
    filldword(vis,sizeof(vis) div 4,0);
    head:=1; tail:=1;  queue[1]:=source; vis[source]:=True; dis[source]:=0; pre[sink]:=-1;

    while head<=tail do
    begin
        now:=queue[head]; vis[now]:=False; inc(head);
        i:=cnt[now];
        while i<>-1 do
        begin
            if (value[i]>0)and(dis[reach[i]]>dis[now]+cost[i]) then
            begin
                dis[reach[i]]:=dis[now]+cost[i];
                pre[reach[i]]:=now;
                last[reach[i]]:=i;
                flow[reach[i]]:=min(flow[now],value[i]);
                if vis[reach[i]]=False then
                begin
                    vis[reach[i]]:=True;
                    inc(tail); queue[tail]:=reach[i];
                end;
            end;
            i:=next[i];
        end;
    end;
    if pre[sink]=-1 then exit(False); exit(True);
end;

procedure MincostMaxflow;
begin
    maxflow:=0; mincost:=0; now:=0;
    while (spfa) do
    begin
        now:=sink;
        inc(maxflow,flow[sink]);
        inc(mincost,flow[sink]*dis[sink]);
        while now<>source do
        begin
            dec(value[last[now]],flow[sink]);
            inc(value[last[now] xor 1],flow[sink]);
            now:=pre[now];
        end;
    end;
end;

procedure Construction_I;
begin
    filldword(cnt,sizeof(cnt) div 4,maxlongint*2+1); tot:=1;
    fillchar(value,sizeof(value),0);
    fillchar(reach,sizeof(reach),0);
    fillchar(cost,sizeof(cost),0);
    fillchar(next,sizeof(next),0);
   	for i:=1 to n do add(source,i+1,1,0);
   	for i:=1 to n do add(i+n+1,sink,1,0);
    for i:=1 to n do for j:=1 to n do begin read(val[i,j]); add(i+1,j+n+1,1,val[i,j]); end;
end;

procedure Construction_II;
begin
    filldword(cnt,sizeof(cnt) div 4,maxlongint*2+1); tot:=1;
    fillchar(value,sizeof(value),0);
    fillchar(reach,sizeof(reach),0);
    fillchar(cost,sizeof(cost),0);
    fillchar(next,sizeof(next),0);
   	for i:=1 to n do add(source,i+1,1,0);
   	for i:=1 to n do add(i+n+1,sink,1,0);
  	for i:=1 to n do for j:=1 to n do add(i+1,j+n+1,1,-val[i,j]);
end;


begin
    read(n); source:=1; sink:=(n+2) << 1;
    Construction_I ; MincostMaxflow; writeln( mincost);
    Construction_II; MincostMaxflow; writeln(-mincost);
end.
```

---

## 作者：ChenJr (赞：0)

非常经典的费用流的模型吧，也可以通过二分图最大匹配去做，但是鉴于二分图最大匹配的算法存在一定的局限性，故还是学一学较为通用的费用流的做法。

这道题目中本质上要讨论的问题跟运输问题，$LuoguP4015$是一致的。

因为考虑到每个人只能被分配到一种货物，每种货物只能被一个人所分配，因此，我们不妨用流量将他们限流。

我们创建一个超级源地$sp$，将$sp$跟每个人连一条流量为$1$，费用为$0$的边。

同时我们创建一个超级汇点$ep$，将每一种货物跟$ep$都连一条流量为$1$，费用为$0$的边。

同时，对于每一个人和货物，我们对他们连一条流量为无穷的边。

因为每个人只能从超级源点获取最多$1$点的流量，每种货物只能向超级汇点传送最多$1$点的流量，因此当这个图满流时，能够保证每个人一定会配对最多一个货物，即达到我们限流的要求。

而如果我们需要求解最小花费，我们只需要将人和货物的边加上的费用取$val_{ij}$，最后在这张图上跑最小费用最大流后最小费用即为答案。

而如果我们需要求解最大花费，我们只需要将人和货物的边加上的费用取相反数$-val_{ij}$，最后在这张图上跑最小费用最大流后最小费用的相反数即为答案。

Code:

```cpp
#include <bits/stdc++.h>
#define maxn 4050
using namespace std;
struct Node{
    int to,next,val,cost;
}q[maxn<<1];
int head[maxn],cnt=0;
int dis[maxn],vis[maxn],sp,ep,maxflow,cost;
int n,num[maxn][maxn];
const int INF=0x3f3f3f3f;
void init(){
    memset(head,-1,sizeof(head));
    cnt=2;
    maxflow=cost=0;
}
void addedge(int from,int to,int val,int cost){
    q[cnt].to=to;
    q[cnt].next=head[from];
    q[cnt].val=val;
    q[cnt].cost=cost;
    head[from]=cnt++;
}
void add_edge(int from,int to,int val,int cost){
    addedge(from,to,val,cost);
    addedge(to,from,0,-cost);
}
bool spfa(){
    memset(vis,0,sizeof(vis));
    memset(dis,0x3f,sizeof(dis));
    dis[sp]=0;
    vis[sp]=1;
    queue<int>que;
    que.push(sp);
    while(!que.empty()){
        int x=que.front();
        que.pop();
        vis[x]=0;
        for(int i=head[x];i!=-1;i=q[i].next){
            int to=q[i].to;
            if(dis[to]>dis[x]+q[i].cost&&q[i].val){
                dis[to]=dis[x]+q[i].cost;
                if(!vis[to]){
                    que.push(to);
                    vis[to]=1;
                }
            }
        }
    }
    return dis[ep]!=0x3f3f3f3f;
}
int dfs(int x,int flow){
    if(x==ep){
        vis[ep]=1;
        maxflow+=flow;
        return flow;
    }//可以到达t，加流
    int used=0;//该条路径可用流量
    vis[x]=1;
    for(int i=head[x];i!=-1;i=q[i].next){
        int to=q[i].to;
        if((vis[to]==0||to==ep)&&q[i].val!=0&&dis[to]==dis[x]+q[i].cost){
            int minflow=dfs(to,min(flow-used,q[i].val));
            if(minflow!=0){
                cost+=q[i].cost*minflow;
                q[i].val-=minflow;
                q[i^1].val+=minflow;
                used+=minflow;
            }
            //可以到达t，加费用，扣流量
            if(used==flow)break;
        }
    }
    return used;
}int mincostmaxflow(){
    while(spfa()){
        vis[ep]=1;
        while(vis[ep]){
            memset(vis,0,sizeof(vis));
            dfs(sp,INF);
        }
    }
    return maxflow;
}
int main()
{
    scanf("%d",&n);
    init();
    sp=2*n+1,ep=2*n+2;

    for(int i=1;i<=n;i++){
        add_edge(sp,i,1,0);
        add_edge(i+n,ep,1,0);
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            scanf("%d",&num[i][j]);
            add_edge(i,j+n,INF,num[i][j]);
        }
    }
    mincostmaxflow();
    printf("%d\n",cost);

    init();
    for(int i=1;i<=n;i++){
        add_edge(sp,i,1,0);
        add_edge(i+n,ep,1,0);
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            add_edge(i,j+n,INF,-num[i][j]);
        }
    }
    mincostmaxflow();
    printf("%d\n",-cost);
    return 0;
}
```


---

## 作者：little_sun (赞：0)

little_sun费用流第一题！ 

建模：

1.从$s$向人$1-n$连边，容量为$1$,费用为$0$

2.从工作$1-n$向$t$连边，容量为$1$,费用为$0$

3.从人$1-n$向工作$1-n$连边，容量为$1$，费用为$c_{i,j}$
 
然后我们就可以跑裸的费用流啦~

什么？你问我最大费用怎么写？当然是把边权取反啊

**Code:**

```cpp
#include <bits/stdc++.h>

#define R register
#define ll long long
#define cmax(a, b) ((a < b) ? b : a)
#define cmin(a, b) ((a < b) ? a : b)
#define sum(a, b, mod) ((a + b) % mod)

const int MaxN = 5e3 + 10;
const int MaxM = 5e4 + 10;

struct edge
{
    int next, to, flow, cost;
};

edge e[MaxM];
int n, s = 600, t = 601, ans, cnt = 1, mincost, maxflow;
int head[MaxN], flow[MaxN], dis[MaxN], pre[MaxN], last[MaxN], vis[MaxN], a[210][210];

inline void add(int u, int v, int f, int c)
{
    ++cnt;
    e[cnt].to = v;
    e[cnt].flow = f;
    e[cnt].cost = c;
    e[cnt].next = head[u];
    head[u] = cnt;
}

inline void add_edge(int u, int v, int f, int c)
{
    add(u, v, f, c);
    add(v, u, 0, -c);
}

inline int read()
{
    int x = 0, f = 1;
    char ch = getchar();
    while (ch > '9' || ch < '0')
    {
        if (ch == '-')
            f = 0;
        ch = getchar();
    }
    while (ch <= '9' && ch >= '0')
        x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
    return f ? x : (-x);
}

int spfa()
{
    memset(dis, 0x3f, sizeof(dis));
    memset(flow, 0x3f, sizeof(flow));
    memset(vis, 0, sizeof(vis));
    std::queue<int> q;
    q.push(s);
    vis[s] = 1;
    dis[s] = 0;
    pre[t] = -1;
    while (!q.empty())
    {
        int u = q.front();
        q.pop();
        vis[u] = 0;
        for (int i = head[u]; i; i = e[i].next)
        {
            if (e[i].flow && dis[e[i].to] > dis[u] + e[i].cost)
            {
                int v = e[i].to;
                dis[v] = dis[u] + e[i].cost;
                pre[v] = u;
                last[v] = i;
                flow[v] = cmin(flow[u], e[i].flow);
                if (!vis[v])
                {
                    vis[v] = 1;
                    q.push(v);
                }
            }
        }
    }
    return pre[t] != -1;
}

void MCMF()
{
    while (spfa())
    {
        int u = t;
        maxflow += flow[t];
        mincost += flow[t] * dis[t];
        while (u != s)
        {
            e[last[u]].flow -= flow[t];
            e[last[u] ^ 1].flow += flow[t];
            u = pre[u];
        }
    }
}

int main()
{
    n = read();
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            a[i][j] = read();
    for (int i = 1; i <= n; i++)
        add_edge(s, i, 1, 0), add_edge(i + n, t, 1, 0);
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            add_edge(i, j + n, 1, a[i][j]);
    MCMF();
    cnt = 1;
    printf("%d\n", mincost);
    memset(head, 0, sizeof(head));
    memset(pre, 0, sizeof(pre));
    memset(last, 0, sizeof(last));
    maxflow = mincost = 0;
    for (int i = 1; i <= n; i++)
        add_edge(s, i, 1, 0), add_edge(i + n, t, 1, 0);
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            add_edge(i, j + n, 1, -a[i][j]);
    MCMF();
    printf("%d", -mincost);
    return 0;
}
```





---

## 作者：leozhang (赞：0)

本题是一个典型的费用流问题，可以作为费用流建图模板使用

首先看到，每个人只能做一件工作，每件工作只能做一次，一个人做某件工作有一定的收益

那么我们建立一个超级源点st和超级终点ed，然后由源点向所有人连边，容量为1，费用为0

接着由工作向汇点连边，容量为1费用为0

上面满足了每个人只做一件工作且每件工作只做一次的要求

最后由人向工作连边，容量为1费用为收益，跑一遍费用流即为最小收益

然后把人向工作连边的边权取负值，再跑一遍费用流，此时最小费用的相反数即为最大收益

这道题向我们提示：最大费用流也是可以跑的，只是将所有费用取反后跑最小费用流即可

```cpp
#include <cstdio>
#include <cmath>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <algorithm>
#include <queue>
#include <stack>
using namespace std;
const int INF=0x3f3f3f3f;
struct Edge
{
    int next;
    int to;
    int val;
    int pri;
}edge[20005];
int head[255];
int dis[255];
int pre[255];
int fa[255];
int lim[255];
bool used[255];
int a[255][255];
int cnt=1;
int n;
int st,ed;
void init()
{
    memset(head,-1,sizeof(head));
    memset(edge,0,sizeof(edge));
    cnt=1;
}
void add(int l,int r,int w,int v)
{
    edge[cnt].next=head[l];
    edge[cnt].to=r;
    edge[cnt].val=w;
    edge[cnt].pri=v;
    head[l]=cnt++;
}
int ide(int x)
{
    return (x&1)?x+1:x-1;
}
bool spfa()
{
    memset(dis,0x3f,sizeof(dis));
    memset(lim,0,sizeof(lim));
    memset(used,0,sizeof(used));
    dis[st]=0;
    lim[st]=INF;
    pre[ed]=-1;
    used[st]=1;
    queue <int> M;
    M.push(st);
    while(!M.empty())
    {
        int u=M.front();
        M.pop();
        for(int i=head[u];i!=-1;i=edge[i].next)
        {
            int to=edge[i].to;
            if(edge[i].val&&dis[to]>dis[u]+edge[i].pri)
            {
                dis[to]=dis[u]+edge[i].pri;
                lim[to]=min(lim[u],edge[i].val);
                pre[to]=i;
                fa[to]=u;
                if(!used[to])used[to]=1,M.push(to);
            }
        }
        used[u]=0;
    }
    return pre[ed]!=-1;
}
int EK()
{
    int maxw=0,minv=0;
    while(spfa())
    {
        minv+=dis[ed]*lim[ed];
        maxw+=lim[ed];
        int temp=ed;
        while(temp!=st)
        {
            edge[pre[temp]].val-=lim[ed];
            edge[ide(pre[temp])].val+=lim[ed];
            temp=fa[temp];
        }
    }
    return minv;
}
int main()
{
    scanf("%d",&n);
    init();
    for(int i=2;i<=n+1;i++)
    {
        for(int j=n+2;j<=2*n+1;j++)
        {
            int x;
            scanf("%d",&x);
            add(i,j,1,x);
            add(j,i,0,-x);
            a[i-1][j-n-1]=x;
        }
    }
    st=1,ed=2*n+2;
    for(int i=2;i<=n+1;i++)add(st,i,1,0),add(i,st,0,0);
    for(int i=n+2;i<=2*n+1;i++)add(i,ed,1,0),add(ed,i,0,0);
    printf("%d\n",EK());
    init();
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            add(i+1,j+n+1,1,-a[i][j]);
            add(j+n+1,i+1,0,a[i][j]);
        }
    }
    st=1,ed=2*n+2;
    for(int i=2;i<=n+1;i++)add(st,i,1,0),add(i,st,0,0);
    for(int i=n+2;i<=2*n+1;i++)add(i,ed,1,0),add(ed,i,0,0);
    printf("%d\n",-EK());
    return 0;
}
```


---

## 作者：Edward_Elric (赞：0)

### 题意

**二分图完美匹配**

用费用流可以解决这个问题，连超级汇源。

题意即求一遍最大费用流，一边最小费用即可

求最大费用。其实类似于求最长路，把边权变负数，然后跑一边就好了，取结果相反数，并不需要模拟一遍去改
#
### 代码
EK（spfa+增广路）

```cpp
#include<bits/stdc++.h>
#define inf 0x3f3f3f3f
using namespace std;
const int maxn=200+100,maxm=40000+100;
int head[maxn],inq[maxn],cur[maxn];
int dis[maxn],vis[maxn];
int a[maxn][maxn];
int pre[maxn],last[maxn],flow[maxn];
int s,t,n;
struct edge
{
	int to,next,cap,cost;
}e[maxm];
int size=1;
void init()
{
	memset(dis,inf,sizeof(dis));
	memset(inq,0,sizeof(inq));
	memset(flow,inf,sizeof(flow));
	dis[s]=0;pre[t]=-1;
}
inline int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch<='9'&&ch>='0'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return x*f;
}
void addedge(int u,int v,int val,int c)
{
	e[++size].to=v;e[size].cap=val;e[size].cost=c;e[size].next=head[u];head[u]=size;
	e[++size].to=u;e[size].cap=0;e[size].cost=-c;e[size].next=head[v];head[v]=size;
}
bool spfa()
{
    init();
    queue<int>q;
    q.push(s);
    inq[s]=1;
    while(!q.empty())
    {
    	int u=q.front();
    	q.pop();
    	inq[u]=0;
    	for(int i=head[u];i;i=e[i].next)
    	{
    		int to=e[i].to;
    		if(e[i].cap>0&&dis[to]>dis[u]+e[i].cost)
    		{
    			dis[to]=e[i].cost+dis[u];
    			pre[to]=u;
    			last[to]=i;
    			flow[to]=min(flow[u],e[i].cap);
    			if(!inq[to])
    			{
    				q.push(to);
    				inq[to]=1;
				}
			}
		}
	}
	return pre[t]!=-1;
}
int mcmf()
{
	int mc=0;
	while(spfa())
	{
		int u=t;
		mc+=flow[t]*dis[t];
	    while(u!=s)
	    {
	      e[last[u]].cap-=flow[t];
	      e[last[u]^1].cap+=flow[t];
	      u=pre[u];
		}
	}
	return mc;
}

int main()
{
	n=read();
	s=0,t=n*2+1;
	for(int i=1;i<=n;i++)
	addedge(s,i,1,0),addedge(i+n,t,1,0);
	for(int i=1;i<=n;i++)
	  for(int j=1;j<=n;j++)
	  a[i][j]=read(),addedge(i,j+n,1,a[i][j]);
	printf("%d\n",mcmf());
	memset(head,0,sizeof(head));
	memset(e,0,sizeof(e));
	size=1;
	for(int i=1;i<=n;i++)
	addedge(s,i,1,0),addedge(i+n,t,1,0);
	for(int i=1;i<=n;i++)
	  for(int j=1;j<=n;j++)
	  addedge(i,j+n,1,-a[i][j]);
	printf("%d\n",-mcmf());
	return 0;
}
```

---

## 作者：简宇卿 (赞：0)

    由于本人非常蒟蒻，所以只会打模板，而且还得打两次。
    自然代码十分繁琐，其实这道题就是一道裸的最大最小费问题。简便易懂。
    # include <iostream>
    # include <cstdio>
    # include <cstring>
    # include <queue>
    using namespace std;
    const int N = 5010,M = 200010;
    int ver1[M],ver2[M],edge1[M],edge2[M],cost1[M],cost2[M],Next1[M],Next2[M],head1[N],head2[N],d1[N],d2[N],incf1[N],incf2[N],pre1[N],pre2[N],v1[N],v2[N],n,k,tot1 = -1,tot2 = -1,s,t,maxflow1,maxflow2,ans1,ans2;
    void add1(int x,int y,int z,int c){
        ver1[++tot1] = y,edge1[tot1] = z,cost1[tot1] = c,Next1[tot1] = head1[x],head1[x] = tot1;
        ver1[++tot1] = x,edge1[tot1] = 0,cost1[tot1] = -c,Next1[tot1] = head1[y],head1[y] = tot1;
    }
    void add2(int x,int y,int z,int c){
        ver2[++tot2] = y,edge2[tot2] = z,cost2[tot2] = c,Next2[tot2] = head2[x],head2[x] = tot2;
        ver2[++tot2] = x,edge2[tot2] = 0,cost2[tot2] = -c,Next2[tot2] = head2[y],head2[y] = tot2;
    }
    bool spfa1(){
        queue<int> q1;
        memset(d1,0x3f,sizeof(d1));
        memset(v1,0,sizeof(v1));
        q1.push(s);d1[s] = 0;v1[s] = 1;
        incf1[s] = 1 << 30;
        while(q1.size()){
            int x1 = q1.front();v1[x1] = 0;q1.pop();
            for(int i = head1[x1];i != -1;i = Next1[i]){
                if(!edge1[i])continue;
                int y1 = ver1[i];
                if(d1[y1] > d1[x1] + cost1[i]){
                    d1[y1] = d1[x1] + cost1[i];
                    incf1[y1] = min(incf1[x1],edge1[i]);
                    pre1[y1] = i;
                    if(!v1[y1])v1[y1] = 1,q1.push(y1);
                }
            }
        } 
        if(d1[t] == 0x3f3f3f3f)return false;
        return true;
    }
    void update1(){
        int x1 = t;
        while(x1 != s){
            int i1 = pre1[x1];
            edge1[i1] -= incf1[t];
            edge1[i1 ^ 1] += incf1[t];
            x1 = ver1[i1 ^ 1];
        }
        maxflow1 += incf1[t];
        ans1 += d1[t] * incf1[t];
    }
    bool spfa2(){
        queue<int> q2;
        memset(d2,0xcf,sizeof(d2));
        memset(v2,0,sizeof(v2));
        q2.push(s);d2[s] = 0;v2[s] = 1;
        incf2[s] = 1 << 30;
        while(q2.size()){
            int x2 = q2.front();v2[x2] = 0;q2.pop();
            for(int i = head2[x2];i != -1;i = Next2[i]){
                if(!edge2[i])continue;
                int y2 = ver2[i];
                if(d2[y2] < d2[x2] + cost2[i]){
                    d2[y2] = d2[x2] + cost2[i];
                    incf2[y2] = min(incf2[x2],edge2[i]);
                    pre2[y2] = i;
                    if(!v2[y2])v2[y2] = 1,q2.push(y2);
                }
            }
        } 
        if(d2[t] == 0xcfcfcfcf)return false;
        return true;
    }
    void update2(){
        int x2 = t;
        while(x2 != s){
            int i2 = pre2[x2];
            edge2[i2] -= incf2[t];
            edge2[i2 ^ 1] += incf2[t];
            x2 = ver2[i2 ^ 1];
        }
        maxflow2 += incf2[t];
        ans2 += d2[t] * incf2[t];
    }
    int main(){
        memset(head1,-1,sizeof(head1));
        memset(head2,-1,sizeof(head2));
        cin >> n;t = 2 * n + 1;
        for(int i = 1;i <= n;i++)add1(s,i,1,0),add2(s,i,1,0);
        for(int i = 1;i <= n;i++)add1(n + i,t,1,0),add2(n + i,t,1,0);
        for(int i = 1;i <= n;i++)
            for(int j = 1;j <= n;j++){
                int t5;scanf("%d",&t5);
                add1(i,n + j,1,t5),add2(i,n + j,1,t5);
            }
        while(spfa1())update1();
        while(spfa2())update2();
        cout << ans1 << endl;
        cout << ans2 << endl; 
        return 0;
    } 


---


# [SDOI2016] 齿轮

## 题目描述

现有一个传动系统，包含了N个组合齿轮和M个链条。每一个链条连接了两个组合齿轮u和v，并提供了一个传动比x: y。即如果只考虑这两个组合齿轮，编号为u的齿轮转动x圈，编号为v的齿轮会转动y圈。传动比为正表示若编号为u的齿轮顺时针转动，则编号为v的齿轮也顺时针转动。传动比为负表示若编号为u的齿轮顺时针转动，则编号为v的齿轮会逆时针转动。若不同链条的传动比不相容，则有些齿轮无法转动。我们希望知道，系统中的这Ｎ个组合齿轮能否同时转动。


## 说明/提示

对于所有数据，T<=32，N<=1000，M<=10000且x与y的绝对值均不超过100。


## 样例 #1

### 输入

```
2
3 3
1 2 3 5
2 3 5 -7
1 3 3 -7
3 3
1 2 3 5
2 3 5 -7
1 3 3 7```

### 输出

```
Case #1: Yes
Case #2: No```

# 题解

## 作者：aiyougege (赞：14)

可算是被我自己的sb并查集水平给坑了 ~~用并查集做只是因为这个题的标签中有并查集的标签~~
#### Solution
　　如果将齿轮看做点, 链条看做边, 那么发现当其不形成环时总是合法的; 换言之, 只要形成了环, 我们就要判断是否合法.

　　发现传动比具有传递性, 即如果$a,b$的传动比为$w$,$b,c$的传动比为$e$, 那么$a,c$的传动比为$we$.

　　考虑并查集的做法: 
- 若用链条联通$a,b$两个齿轮
- 如果未联通, 则用并查集合并
- 若联通, 设从$a$经过一系列路径传动到$b$的传动比为$\alpha$, $a$和$b$直接联通的传动比为$\beta$, 若$\alpha\ne\beta$则不合法.

　　如何求出两个齿轮**间接连接**的传动比呢? 可以这么做:
- 用$g_i$表示$i$于其集合的祖先的传动比.
- 那么$g_i/g_j$就是两个点$i,j$之间的传动比.

　　至于如何利用并查集维护这个$g_i$, 请学习所谓的"**带权并查集**".~~反正我自己写过的带权并查集都是YY出来的~~.

不得不说带权并查集真的好多细节, 而普通并查集不用管那么多……

#### Code
```c++
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<cmath>
#define N 1005
#define eps 1e-9
using namespace std;

int f[N];double g[N];

int find(int x){
    if(f[x]==x)return x;
	int temp=find(f[x]);
	g[x]*=g[f[x]];
    return f[x]=temp;
}

bool equal(double a,double b){return fabs(a-b)<=eps;}

int main(){
    int T,n,m,a,b;double x,y;bool flag=0;
    scanf("%d",&T);
    for(int t=1;t<=T;++t){
        scanf("%d%d",&n,&m);flag=0;
        for(int i=1;i<=n;++i)f[i]=i;
        for(int i=1;i<=n;++i)g[i]=1;
        for(int i=1;i<=m;++i){
            scanf("%d%d%lf%lf",&a,&b,&x,&y);
			int f1=find(a),f2=find(b);
            if(f1==f2){
                if(!equal(x/y,g[a]/g[b])){flag=true;}
            }
            else f[f2]=f1,g[f2]*=g[a]/g[b]*y/x;
        }
        if(flag)printf("Case #%d: No\n",t);
        else printf("Case #%d: Yes\n",t);
    }
    return 0;
}
```

---

## 作者：MloVtry (赞：9)

标解好像是带权并查集？

不管了，大力搜索。

齿轮$u$到齿轮$v$，$u$转$x$圈，$v$转$y$圈，对应着一条从$u$到$v$的边权为$\frac{x}{y}$的边；反向是$\frac{x}{y}$，$v$到$u$。

大力搜索判断即可。

emmm，如果倍率够高可能会炸掉double，可以取log转成加减法；当然实际上并没有卡。

代码
```cpp
#include<bits/stdc++.h>
#define M 40000
#define N 1500
using namespace std;
int head[N],to[M],Next[M],e,n,m,T;
double len[M],tmp[N];
void buid(int u,int v,double l)
{
	Next[++e]=head[u];head[u]=e;to[e]=v;len[e]=l;
}
int vis[N],fl;
void MloVtry()
{
	memset(head,0,sizeof(head));e=0;
	memset(vis,0,sizeof(vis));fl=0;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;++i)
	{
		int u,v;double x,y;scanf("%d%d%lf%lf",&u,&v,&x,&y);
		buid(u,v,y/x);buid(v,u,x/y);
	}
}
const double res=1e-5;
int sign(double it)
{
	if(fabs(it)<=res) return 0;
	return it>0?1:-1;
}
bool dfs(int now,double it)
{
	vis[now]=1;tmp[now]=it;
	for(int i=head[now];i;i=Next[i])
	{
		int j=to[i];
		if(!vis[j]) {if(dfs(j,it*len[i])) return 1;}
		else {if(sign(tmp[j]-it*len[i])!=0) return 1;}
	}
	return 0;
}
int main()
{
	scanf("%d",&T);
	for(int i=1;i<=T;++i)
	{
		MloVtry();
		for(int j=1;j<=n&&!fl;++j)
		if(!vis[j]) fl|=dfs(j,1);
		printf("Case #%d: ",i);puts(fl?"No":"Yes");
	}
	return 0;
}
```

---

## 作者：7KByte (赞：8)

省选签到题

-----------

观察题面，我们发现如果图中没有环一定是满足条件的


如果出现了环不一定满足条件，显然如果环上的边权之积为$1$时满足条件，否则一定不满足条件


很好理解，我们任意取环上一点使之转动一周，经过环的传动回到自己这里一定还是只转一周


既然我们知道如何判断真伪，如何处理这些复杂的关系


处理点之间的关系，并查集是个不错的选择，本题不仅要处理是否成环，还要求出环上的边权积，带权并查集则能够很好的完成这个任务


对于并查集，我们定义$fa[i]$表示节点$i$的祖先，$k[i]$表示从节点$i$到$fa[i]$的传动比之积

对于每个链条$(u,v,x,y)$，如果$(u,v)$在一个联通块中，显然连了$u-v$后会成环，我们用$K=k[u]/k[v]$得到$u-v$的链上的传动比之积，如果$K==x/y$则满足条件，否则整个传动装置是不合法的

如果$(u,v)$不在一个联通块中，我们则需要在$u-v$之间连一条边权$t$边，使得$t*k[u]/k[v]==x/y$,解方程得到$t=(x*k[v])/(y*k[u])$


需要特别注意的是精度问题，实测$eps=10^{-10}$能过


细节见代码

```cpp
#include<bits/stdc++.h>
const double eps = 0.0000000001;
using namespace std;
int T,n,m;
int fa[1005];double k[1005];
int get(int x){
	if(x==fa[x])return x;
	int pa=get(fa[x]);
	k[x]*=k[fa[x]];
	return fa[x]=pa;
}
int main()
{
	scanf("%d",&T);
	for(int now=1;now<=T;now++){
		scanf("%d%d",&n,&m);
		bool ans=true;
		for(int i=1;i<=n;i++)fa[i]=i,k[i]=1.00;
		for(int i=1;i<=m;i++){
			int u,v;double x,y;
			scanf("%d%d%lf%lf",&u,&v,&x,&y);
			int p=get(u),q=get(v);
			if(p!=q){
				fa[p]=q;
				k[p]*=x*k[v]/(y*k[u]);
			}
			else{
				double sl=k[u]/k[v];
				if(abs(sl-x/y)>eps)ans=false;
			}
		}
		if(ans)printf("Case #%d: Yes\n",now);
		else printf("Case #%d: No\n",now);
	}
	return 0;
}
```

---

## 作者：让风忽悠你 (赞：4)

[原题](https://www.luogu.com.cn/problem/P4079)

## 题意

给出 $N$ 个组合齿轮和 $M$ 个链条，每个链条连接两个齿轮，如果两个齿轮的转动比不相容，则两个齿轮无法同时转动。请判断 $N$ 个齿轮最终是否能都转动。

## 做法

看到这类判断是否成环的题目，不难想到并查集，而这题又要考虑到费用，所以带权并查集自然是一个很好的选择。

定义 $g_i$ 为传递到第 $i$ 个齿轮的转动比之积，所以 $g_u/g_v$ 就表示 第 $u$ 个齿轮到第 $v$ 个齿轮的转动比之积。

那么如果 $u$ 和 $v$ 位于同一联通块，此时就出现了环，就需要判断 $g_u/g_v$ 是否和 $x/y$ 相等。

否则就需要在 $u$ 和 $v$ 之间连一条边，这条边的权值为 $(x*g_v)/(y*g_u)$，这里解释一下，设这条边的权值为 $z$，易知 $z*(g_u/g_v)=x/y$，解得$z=(x*g_v)/(y*g_u)$。

然后再讲一下这题的坑点

1. 因为是带权并查集，所以在传递权值以及父亲时要先递归再操作。
1. 因为是实数计算，所以要考虑精度。

## 代码

```cpp
#include<cstdio>
#include<algorithm>
#include<cmath>
#define N 1005
#define eps 1e-10

using namespace std;

int T,n,m,cnt;
int f[N];
double g[N];
bool fl;

int find(int x){
	if(f[x]==x) return x;
	int fa=find(f[x]); 
	g[x]*=g[f[x]];
	return f[x]=fa;
} // 带权并查集 

inline void clear(){
	fl=0;
	for(int i=0;i<=N;i++){
		f[i]=i;
		g[i]=1.00;
	}
} // 清空数组 

int main(){
	scanf("%d",&T);
	while(T--){
		scanf("%d%d",&n,&m);
		int u,v;
		double x,y;
		clear();
		for(int i=1;i<=m;i++){
			scanf("%d%d%lf%lf",&u,&v,&x,&y);
			int fu=find(u),fv=find(v); // 找爹 
			if(fu!=fv){ // 不成环的情况 
				f[fu]=fv;
				g[fu]*=(x*g[v])/(y*g[u]);
			} // 路径压缩 
			else // 成环的情况 
				if(fabs(g[u]/g[v]-x/y)>eps) fl=1; // 判断传动比是否相容
		}
		++cnt;
		if(!fl) printf("Case #%d: Yes\n",cnt);
		else printf("Case #%d: No\n",cnt);
	}
	return 0;
}
```


---

## 作者：瞬闪影 (赞：4)

看大佬们都说是并查集蒟蒻我真是瑟瑟发抖啊。。。

我写的是分数+gcd

首先假如说让人来处理这件事的话会采用一种什么样的思路呢？

如果是我的话首先会随便找一个点（齿轮）开始，设它的速度为+1

接下来按照给出的边走，一路用“分数”来表达每个齿轮的速度，当要前进的下一个点也被标记了速度，验证新旧两速度是否相同即可。这个思路可以说是简单暴力。。。

再来讨论下复杂度，首先是遍历，不难发现每条边顶多被正反走两边，所以是O(M)，接下来是gcd，如果写的是更相减损法的话就会有稳定的log（100），就是个7左右的常数，总代价可以粗略的理解为100*M 幸好M比较小还是可以过的2333

遍历时要记得有可能不是张连通图

接下来请看看代码吧，希望对你有所帮助！
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int gcd(int a,int b){
	if(a<b)swap(a,b);
	int c;
	while(b){c=a%b;a=b;b=c;}
	return a;
}
struct frnum{
	int s,x,y; //s:0->+ 1->-, x/y
}s[1050];
frnum operator *(frnum A,int b){
	if(b<0){
		A.s^=1;
		b=-b;
	}
	A.x=A.x*b;
	int w=gcd(A.x,A.y);
	A.x/=w;
	A.y/=w;
	return A;
}
frnum operator /(frnum A,int b){
	if(b<0){
		A.s^=1;
		b=-b;
	}
	A.y=A.y*b;
	int w=gcd(A.x,A.y);
	A.x/=w;
	A.y/=w;
	return A;
}
bool operator ==(frnum A,frnum B){
	return A.s==B.s&&A.x==B.x&&A.y==B.y;
}
struct line{
	int nxt,v,x,y;
}e[40000];
int etop,d[1050];
int T,n,m;
void add(int u,int v,int x,int y){
	e[etop].v=v;e[etop].x=x;
	e[etop].y=y;e[etop].nxt=d[u];
	d[u]=etop++;
}
bool vis[1050];
bool f;
void dfs(int u){
	for(int k=d[u];k!=-1;k=e[k].nxt){
		if(vis[e[k].v]){
			if(!(s[u]/e[k].x==s[e[k].v]/e[k].y)){
				f=0;return;
			}
		}
		else{
			vis[e[k].v]=1;
			s[e[k].v]=(s[u]/e[k].x)*e[k].y;
			dfs(e[k].v);
			if(f==0) return;
		}
	}
}
int main(){
	scanf("%d",&T);
	for(int t=1;t<=T;t++){
		printf("Case #%d: ",t);
		memset(s,0,sizeof(s));
		memset(vis,0,sizeof(vis));
		memset(d,-1,sizeof(d));
		etop=0;
		scanf("%d%d",&n,&m);
		for(int i=1,u,v,x,y;i<=m;i++){
			scanf("%d%d%d%d",&u,&v,&x,&y);
			add(u,v,x,y);
			add(v,u,y,x);
		}
		f=1;
		for(int i=1;i<=n;i++)if(!vis[i]){
			s[i].x=s[i].y=1;
			dfs(i);
			if(!f)break;
		}
		if(f) printf("Yes\n");
		else printf("No\n");
	}
	return 0;
}
```

---

## 作者：Uniecho1 (赞：2)

做题需要一点暴力的勇气......

一看n只有这么点大，我就把什么并查集什么逆元忽略了，直接染色加宽搜走一波

然而打下来只有70分，错的还是前三个点......我抓破脑袋想不出来哪儿错了，召唤前排神犇[LRL52](https://www.luogu.org/space/show?uid=109412)搞了一会儿也没什么结果......于是果断去隔壁loj.ac搞了数据来debug，最后发现还是我和LRL52都坚信不会错的重链判断上凉了......

所以果然......越自信越容易出事儿~~骄傲自满必翻车by陈毅~~
不废话了，上代码
```cpp
#include<bits/stdc++.h>
using namespace std;
std::vector<int>G[1005];
std::vector<double>W[1005];
int N,M,vis[1005];
double eps=1e-5,cnt[1005];//eps不能太小

struct node{
    int id;//这是id号齿轮 
    double circle;//它现在转了circle圈 
};

bool BFS(){
    for(int i=1;i<=N;i++){
        if(vis[i])continue;//这个vis其实有点像一个并查集（其实就是染色），可以保证对于一个集合只搜索一次（这个组可能划分成多个毫不相关的集合嘛）
        node c;
        c.circle=cnt[i]=1;
        c.id=i;
        vis[i]=1;//初始化
        queue<node>Q;
        Q.push(c);
        while(!Q.empty()){
            node u=Q.front();
            Q.pop();
            for(int i=0;i<G[u.id].size();i++){
                int v=G[u.id][i];
                double cc=u.circle*W[u.id][i];//注意一下W[i][j]的第二维，想一想为什么不直接用v
                if(!vis[v]){
                    vis[v]=1;
                    cnt[v]=cc;
                    Q.push(node{v,cc});
                }
                else if(fabs(cc-cnt[v])>eps)return false;//入过队列了就只判断符合条件与否了，再入队的话就没完没了了（@李溢出）
            }
        }
    }
    return true;//如果都没问题就true了呗
}

int main(){
    //freopen("in.txt","r",stdin);
    int T;
    scanf("%d",&T);
    for(int kkk=1;kkk<=T;kkk++){//不要在意细节
        memset(vis,0,sizeof(vis));
        memset(W,0,sizeof(W));
        memset(cnt,0,sizeof(cnt));
        scanf("%d%d",&N,&M);
        for(int i=1;i<=N;i++)
        G[i].clear();
        for(int i=1,u,v,x,y;i<=M;i++){
            scanf("%d%d%d%d",&u,&v,&x,&y);
            G[u].push_back(v);
            G[v].push_back(u);
            W[u].push_back((double)y/x);//这里要保证比例是一条一条链对应过去的，否则以两个齿轮的id保存的话会使不同的链用同一个比例
            W[v].push_back((double)x/y);//双向边是要建的
        }
        if(BFS())printf("Case #%d: Yes\n",kkk);
        else printf("Case #%d: No\n",kkk);
    }
    return 0;
}
```
于是就完事儿了。我去看LXL翻车了(hiahiahia)。

---

## 作者：attack (赞：2)

$N$这么小肯定直接上暴力呀，但是肯定要优雅一点。

对于初始的$N$个点，每加一条限制实际上就是合并了两个联通块。

那么我们预处理出$val[i]$表示的是$i$节点所在的联通块根节点转了$1$圈，该节点会转多少圈

并查集维护联通性以及联通块大小，直接启发式合并就可以了

~~跑的好像还挺快~~

```cpp
#include<bits/stdc++.h>
#define siz(v) ((int)v.size())
using namespace std;
const int MAXN = 2001;
const double eps = 1e-9;
inline int read() {
    char c = getchar(); int x = 0, f = 1;
    while(c < '0' || c > '9') {if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
    return x * f;
}
int N, M, fa[MAXN], siz[MAXN];
double val[MAXN];
vector<int> v[MAXN];
void init() {
    for(int i = 1; i <= N; i++) fa[i] = i, v[i].clear(), siz[i] = 1, val[i] = 1;
}
int find(int x) {
    return fa[x] == x ? fa[x] : fa[x] = find(fa[x]);
}
bool dcmp(double x) {
    return fabs(x) < eps;
}
void mem(int x, int fa, double va) {
    for(int i = 0; i < siz(v[x]); i++) {
        int to = v[x][i];
        if(to == fa) continue;
        val[to] *= va;
        mem(to, x, va);
    }
}
bool solve() {
    N = read(); M = read(); bool flag = 0;   
	init();
    for(int i = 1; i <= M; i++) {
        int x = read(), y = read(), fx = find(x), fy = find(y); double vx = read(), vy = read();
        if(flag) continue;
        if(fx == fy) {if(!(dcmp(val[x] / val[y] - vx / vy))) flag = 1; continue;}
        if(siz[fx] > siz[fy]) swap(x, y), swap(vx, vy), swap(fx, fy);
        val[fx] = vx / vy * val[y] / val[x];
        mem(fx, 0, val[fx]); fa[fx] = fy; v[y].push_back(fx);
        siz[fy] += siz[fx]; siz[fx] = 0;
    }
    return flag ^ 1;
}
int main() {
#ifndef ONLINE_JUDGE
	freopen("a.in", "r", stdin);
#endif
    int T = read();
    for(int i = 1; i <= T; i++) {
        printf("Case #%d: ", i);
        puts(solve() ? "Yes" : "No");
    }
    return 0;
}
```

---

## 作者：StarPatrick (赞：1)

可以发现，一个齿轮转动会带动其他齿轮转动，那么其他齿轮转动的时候又让这个齿轮转动，一个齿轮是不能拥有两个转速的，所以如果这两个转速不同，就是 No，否则 Yes。

那么我们可以把齿轮看成点，转速比看成边权，那么一个点的点权就为这个点的转速，当前点的点权乘以边权就为下一个点的点权，这样我们就可以建一个双向图进行搜索遍历，第一次遍历到的点权和之后遍历到的点权比较（这里注意一下精度），就 ok 了。

代码：
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <vector>
using namespace std;
int t, n, m;
bool f;
struct e
{
	int i;
	double u;
};
vector<e> v[1005];
double book[1005];
void dfs(int i, double u)
{
	for (int p=0;p<v[i].size();p++)
	{
		double x = v[i][p].u*u;
		if (fabs(book[v[i][p].i])<=1e-5)
		{
			book[v[i][p].i] = x;
			dfs(v[i][p].i, x);
			if (f)
			{
				return ;
			}
		}
		else if (fabs(book[v[i][p].i]-x)>1e-5)
		{
			f = 1;
			return ;
		}
	}
}
signed main()
{
	scanf("%d", &t);
	for (int zqw=1;zqw<=t;zqw++)
	{
		f = 0;
		scanf("%d %d", &n, &m);
		for (int p=1;p<=n;p++)
		{
			v[p].clear();
			book[p] = 0;
		}
		for (int p=1;p<=m;p++)
		{
			int u, s, x, y;
			scanf("%d %d %d %d", &u, &s, &x, &y);
			if (y>0)
			{
				v[u].push_back({s, y*1.0/x});
				v[s].push_back({u, x*1.0/y});
			}
			else
			{
				v[s].push_back({u, x*1.0/y});
				v[u].push_back({s, y*1.0/x});
			}
		}
		for (int p=1;p<=n;p++)
		{
			if (fabs(book[p])<=1e-5)
			{
				book[p] = 1.0;
				dfs(p, 1.0);
			}
			if (f)
			{
				break;
			}
		}
		if (!f)
		{
			printf("Case #%d: Yes\n", zqw);
		}
		else
		{
			printf("Case #%d: No\n", zqw);
		}
	}
	return 0;
}
```


---

## 作者：Unnamed114514 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P4079)

首先，我们可以考虑化简比：如果直接搞，那么就要用 $\operatorname{lcm}$，因为至于比较大，就会直接爆精度，所以我们可以把系数化为 $1$，然后建图。

对于这个图，我们可以用 `dfs` 遍历，然后我们可以以一个数为基准量求出其它的齿轮相对于这个标准量的倍数。

那么，如果对于一个齿轮，出现了不同的倍数，那就不行，否则就可以，时间复杂度 $O(T(n+m))$，空间复杂度 $O(n+m)$。实现起来比较简单。
```cpp
#include<bits/stdc++.h>
#define inf 1e8
#define int long long
#define eps 1e-6//注意精度
using namespace std;
int T,n,m;
double ans[1005];
struct node{
	int to;
	double val;
};
vector<node> G[1005];
bool vis[1005];
inline bool dfs(int x,double qwq){
	if(vis[x])
		return 1;
	vis[x]=1;//遍历过这个点
	for(int i=0,len=G[x].size();i<len;++i){
		if(ans[G[x][i].to]!=inf&&fabs(ans[G[x][i].to]-G[x][i].val*qwq)>eps)//有不同的倍数
			return 0;
		ans[G[x][i].to]=G[x][i].val*qwq;
		if(!dfs(G[x][i].to,ans[G[x][i].to]))
			return 0;
	}
	return 1;
}//搜索遍历
signed main(){
	scanf("%lld",&T);
	for(int i=1;i<=T;++i){
		scanf("%lld%lld",&n,&m);
		for(int j=1;j<=n;++j){
			ans[j]=inf;
			G[j].clear();
			vis[j]=0;
		}
		for(int j=1,u,v,x,y;j<=m;++j){
			scanf("%lld%lld%lld%lld",&u,&v,&x,&y);
			G[u].push_back(node({v,y*1.0/x}));
			G[v].push_back(node({u,x*1.0/y}));//建边
		}
		ans[1]=1;
		printf("Case #%lld: ",i);
		bool p=1;
		for(int j=1;j<=n;++j)
			if(ans[j]!=inf)
				p&=dfs(j,1);
		if(p)
			puts("Yes");
		else
			puts("No");//输出
	}
	return 0;
}
```

---

## 作者：Teddy_Di (赞：1)

嗯这题据说double会爆精度，暴力乘会爆longlong。。

所以就暴力取模一发

方法是用dfs，正常算比例是乘上vt除以vf(vt,vf定义见代码)，然后因为要取模所以除法变成算逆元

然后如果是个无环图那就应该没问题，如果是个有环图（一个点能被dfs到不止一次）那就特判一下，看两次遍历的结果是否一致，不一致说明不行

具体见代码

```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<vector>
using namespace std;
typedef long long ll;
const int maxn = 3e3 + 5;
const int maxm = 2e4 + 5;
struct Edge
{
    int from, to;
    ll vt, vf;
    Edge() {}
    Edge(int f, int t, ll _vt, ll _vf)
    {
        from = f, to = t, vt = _vt, vf = _vf;
    }
}e[maxm];
struct Edge1
{
    int from, to;
    ll c;
    Edge1() {}
    Edge1(int f, int t, ll _c)
    {
        from = f, to = t, c = _c;
    }
};
//vector存边
vector<Edge>edge[maxn];
int n, m;
ll node[maxn];
bool vis[maxn];
//本题有负数，取模需要对其加到正后再取，C++负数取模比较诡异
inline ll mod(ll a, ll p)
{
    return ((a%p) + p) % p;
}
void Init()
{
    for (int i = 1; i <= n; i++)
        edge[i].clear();
    memset(vis, 0, sizeof(vis));
    memset(node, 0, sizeof(node));
}
//快速幂，用于算逆元
ll getn(ll a, ll p)
{
    ll ans = 1, b = mod(a, p);
    ll z = p - 2;
    while (z != 0)
    {
        if (z & 1)
        {
            ans *= b;
            ans %= p;
        }
        b *= b;
        b %= p;
        z >>= 1;
    }
    return ans;
};
bool dfs(int u, ll z, ll p)
{
    vis[u] = 1, node[u] = z;
    bool ands = 1;
    bool gg[maxn] = { 0 };
    int sz = edge[u].size();
    for (int i = 0; i < sz; i++)
    {
        int v = edge[u][i].to;
        //已经遍历的情况，并且两次遍历结果一致，说明该点暂时可行
        if (vis[v] && node[v] == (z*edge[u][i].vf % p)*edge[u][i].vt % p)
            gg[i] = 1;
        //如果没被遍历过就往下遍历
        else if (!vis[v])
            gg[i] = dfs(v, (z*edge[u][i].vf % p)*edge[u][i].vt % p, p);
    }
    //必须所有子结点点都可行才可行
    for (int i = 0; i < sz; i++)
        if (gg[i] == 0)
            ands = 0;
    return ands;
}
bool work_work(ll p)
{
    Init();
    for (int i = 1; i <= m; i++)
    {
        //建立无向图
        edge[e[i].from].push_back(Edge(e[i].from, e[i].to, getn(e[i].vf, p), mod(e[i].vt, p)));
        edge[e[i].to].push_back(Edge(e[i].to, e[i].from, getn(e[i].vt, p), mod(e[i].vf, p)));
    }
    int flag = 1;
    //图不一定连通，需要判定每一个连通的部分是否可行
    for (int i = 1; i <= n; i++)
        if (!vis[i])
            flag = ((dfs(i, 1, p) == true) ? flag : false);
    return flag;
}
void work(int i)
{
    memset(e, 0, sizeof(e));
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; i++)
        scanf("%d%d%lld%lld", &e[i].from, &e[i].to, &e[i].vf, &e[i].vt);
    bool ans = (work_work(1e9 + 7) && work_work(1e9 + 9));
    printf("Case #%d: ", i);
    if (ans)
        printf("Yes\n");
    else
        printf("No\n");
}
int main()
{
    int t;
    scanf("%d", &t);
    for (int i = 1; i <= t; i++)
        work(i);
    return 0;
}
```

---

## 作者：ywy_c_asm (赞：1)

提供一个比较另类的做法。

首先这题每条无向边都可以拆成两个方向的，分别对应着一个互为倒数的分数，我们要判定的就是这个图里的每个有向环的乘积都是1才不会发生矛盾。

显然咱们不能暴力枚举每个有向环对吧，但是我们发现环套环的情况很容易发生矛盾，这个启发我们用生成树覆盖树边搞一搞（为什么我能想到这个？因为以前做的好多图上的环有矛盾什么的题好多都是找生成树……），然后手玩一下小规模的图我们惊喜的发现只要每条非树边不和覆盖的树边发生矛盾即乘积为1就能满足要求了。

所以这题并不用写什么带权并查集，毕竟这又不是什么强制在线的询问……我们会发现直接在生成树上做和带权并查集是差不多的，而且前者更好搞一些。

至于大家都十分介意的分数乘积太大的问题，其实并不用gcd或者longdouble，我们只需要判定**乘积是否为1**也就是**分数线上面的乘积等于分数线下面的乘积**，这个东西直接乘的时候模个大质数哈希一下不就行了？要求路径上的乘积？求一个树上的前缀积然后用逆元（所以要是大质数……反正这个就随便设啦）乱搞一下就行了。

上代码~

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define ll long long
#define p 998244353
using namespace std;
namespace ywy{
	inline int get(){
		int n=0;char c;
		while((c=getchar())||23333){
			if(c>='0'&&c<='9')break;if(c=='-')goto s;
		}
		n=c-'0';
		while((c=getchar())||23333){
			if(c>='0'&&c<='9')n=n*10+c-'0';else return(n);
		}
		s:while((c=getchar())||23333){
			if(c>='0'&&c<='9')n=n*10-c+'0';else return(n);
		}
	}
	inline ll mi(int a,int b){
		ll ans=1,tmp=a;while(b){
			if(b&1)ans=(ans*tmp)%p;tmp=(tmp*tmp)%p;b>>=1;
		}return(ans);
	}
	typedef struct _fs{
		ll a;ll b;
		_fs(){a=0;b=0;}
		_fs(ll i,ll j){a=i;b=j;}
		friend _fs operator *(const _fs &a,const _fs &b){
			return(_fs((a.a*b.a)%p,(a.b*b.b)%p));
		}
		friend _fs operator /(const _fs &a,const _fs &b){
			return(_fs((a.a*mi(b.a,p-2))%p,(a.b*mi(b.b,p-2))%p));
		}
	}fs;
	typedef struct _b{
		int dest;int nxt;fs a;fs b;
	}bian;
	bian memchi[100001];
	int gn=1,heads[1001],ance[1001][10],deep[1001],ints[1001];
	fs jia[1001],jib[1001];
	int find(int n){
		if(ints[n]==n)return(n);
		return(ints[n]=find(ints[n]));
	}
	inline void add(int s,int t,fs a,fs b){
		memchi[gn].dest=t;
		memchi[gn].nxt=heads[s];
		memchi[gn].a=a;
		memchi[gn].b=b;
		heads[s]=gn;gn++;
	}
	inline int lca(int a,int b){
		if(deep[a]>deep[b])swap(a,b);
		for(register int i=9;i>=0;i--){
			if(deep[ance[b][i]]>=deep[a])b=ance[b][i];
		}
		if(a==b)return(a);
		for(register int i=9;i>=0;i--){
			if(ance[a][i]!=ance[b][i])a=ance[a][i],b=ance[b][i];
		}
		return(ance[a][0]);
	}
	int ss[10001],ts[10001];
	fs as[10001],bs[10001];
	void dfs(int pt,int baba){
		for(register int i=heads[pt];i;i=memchi[i].nxt){
			if(memchi[i].dest==baba)continue;
			deep[memchi[i].dest]=deep[ance[memchi[i].dest][0]=pt]+1;
			jia[memchi[i].dest]=jia[pt]*memchi[i].a;
			jib[memchi[i].dest]=jib[pt]*memchi[i].b;
			dfs(memchi[i].dest,pt);
		}
	}
	unsigned char istree[10001];
	void ywymain(){
		deep[0]=-1;
		int t=get();
		for(register int ltt=1;ltt<=t;ltt++){
			memset(heads,0,sizeof(heads));
			gn=1;
			int n=get(),m=get();
			jia[1]=_fs(1,1),jib[1]=_fs(1,1);
			for(register int i=1;i<=n;i++)ints[i]=i;
			memset(ance,0,sizeof(ance));
			for(register int i=1;i<=m;i++){
				ss[i]=get();ts[i]=get();
				int a=(get()+p)%p,b=(get()+p)%p;
				as[i]=_fs(a,b);bs[i]=_fs(b,a);
				int aa=find(ss[i]),ab=find(ts[i]);
				if(aa!=ab)ints[aa]=ab,add(ss[i],ts[i],as[i],bs[i]),
				add(ts[i],ss[i],bs[i],as[i]),istree[i]=1;else istree[i]=0;
			}
			dfs(1,0);
			for(register int i=1;i<=9;i++){
				for(register int j=1;j<=n;j++)ance[j][i]=ance[ance[j][i-1]][i-1];
			}
			for(register int i=1;i<=m;i++){
				if(istree[i])continue;
				int s=ss[i],t=ts[i],l=lca(s,t);
				fs res=(jia[s]/jia[l])*as[i]*(jib[t]/jib[l]);
				if(res.a!=res.b){
					printf("Case #%d: No\n",ltt);goto s;
				}
			}
			printf("Case #%d: Yes\n",ltt);s:;
		}
	}
}
int main(){
	ywy::ywymain();return(0);
}
```

---

## 作者：cqbzhyf (赞：0)

首先听说这道题可以用搜索，于是开干……

[题面](https://www.luogu.com.cn/problem/P4079)

这道题目涉及比例，如果 $u$ 齿轮旋转 $1$ 圈，则 $v$ 齿轮旋转 $\frac{b}{a}$ 圈，于是用 `long double` 来存储，为了处理精度，允许误差在 $\frac{1}{1000000000}$ 以内。

首先建图，传入对应齿轮以及当前齿轮旋转 $1$ 圈，对应齿轮旋转圈数（这里用 `long double`）。

搜索传入当前齿轮和旋转圈数，如果当前齿轮旋转过，判断是否满足圈数相同，否则赋值继续搜索。（注意只有不满足返回 `false`，满足的话先不处理）。

因为是全部满足，有可能存在几个不同的**齿轮组**，于是判断当前齿轮旋转过没有，如果没有，进行搜索，用一个 `bool` 标记答案，此处用与运算，所以初始值为 `true`，小优化是如果标记已经为 `false`，直接跳出（代码未体现）。

最后输出答案……

**注意数组清空！**

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){int ch=0,num=0;char c=getchar();while(!isdigit(c))ch|=(c=='-'),c=getchar();while(isdigit(c))num=(num<<1)+(num<<3)+(c^48),c=getchar();return ch?-num:num;}
int n,m,fa[1005];
vector<pair<int,long double> >G[1005];
long double num[1005];
inline bool dfs(int u,long double q){
	int len=G[u].size();
	for(int i=0;i<len;++i){
		int v=G[u][i].first;
		if(!num[v]){
			num[v]=q*G[u][i].second;
			if(!dfs(v,q*G[u][i].second))return 0;
		}else{
			if(abs(num[v]-q*G[u][i].second>1e-9)){
				return 0;
			}
		}
	}
	return 1;
}
signed main(){
	int T=read();
	for(int C=1;C<=T;++C){
		memset(num,0,sizeof num);
		n=read(),m=read();
		for(int i=1;i<=n;++i)G[i].clear();
		for(int i=1;i<=m;++i){
			int u=read(),v=read();
			long double x,y;
			cin>>x>>y;
			G[u].push_back(make_pair(v,y/x)),G[v].push_back(make_pair(u,x/y));
		}
		bool ch=1;
		for(int i=1;i<=n;++i){
			if(!num[i]){
				ch&=dfs(i,1.0);
			}
		}
		if(ch)printf("Case #%d: Yes\n",C);
		else printf("Case #%d: No\n",C);
	}
	return 0;
}
```

---

## 作者：Harry_Hedwig (赞：0)

先看题。

>现有一个传动系统，包含了 $N$ 个组合齿轮和 $M$ 个链条。每一个链条连接了两个组合齿轮 $u$ 和 $v$，并提供了一个传动比 $x:y$。即如果**只考虑**这两个组合齿轮，**编号为 $u$ 的齿轮转动 $x$ 圈，编号为 $v$ 的齿轮会转动 $y$ 圈**。传动比**为正**表示若编号为 $u$ 的齿轮**顺时针**转动，则编号为 $v$ 的齿轮**也顺时针**转动。传动比**为负**表示若编号为 $u$ 的齿轮**顺时针**转动，则编号为 $v$ 的齿轮会**逆时针**转动。若不同链条的传动比不相容，则有些齿轮无法转动。我们希望知道，系统中的这 $N$ 个组合齿轮能否**同时**转动。

题目给出的信息很明确，一个齿轮动会带动其他齿轮一起动，既然如此，这个就很像多米诺骨牌了。而我们想起原来的一个与[多米诺骨牌有关的问题](https://www.luogu.com.cn/problem/UVA318)是使用图论解决的，因此我们想到它有可能也和图论有关。

既然是图论，那么我们肯定需要知道边权和什么有关。由于题目条件，我们已知编号为 $u$ 的齿轮转动 $x$ 圈，编号为 $v$ 的齿轮会转动 $y$ 圈，所以当编号为 $u$ 的齿轮转动 $a$ 圈时，编号为 $v$ 的齿轮会转动 $a\times \frac{y}{x}$ 圈。

因此我们不妨让编号为 $u$ 的齿轮转动 $1$ 圈，编号为 $v$ 的齿轮转动 $\frac{y}{x}$ 圈。

那么此时我们会发现**一部分**（整个系统不一定是完全连通的！）的齿轮被其中的一些链条相连组成了一个图，其中几个齿轮可能会有不同的到达方式，但是我们要保证它的转动圈数不变才能使这个系统可以正常运行（`Yes`）否则就会卡住（`No`）。

剩下的……交给图的遍历解决即可。

## Code

```c++
#include<bits/stdc++.h>
const double deviation=1e-10;//可能有误差
using namespace std;
struct node
{
	double val;
	int go;
}t1;
vector<node>G[1005];//邻接表存储图
double laps[1005];//记忆是否遍历过它所存在的子系统
bool ergodic(int s)//广度遍历
{
	int i,z[1005];
	queue<int>q;
	q.push(s);
	while(!q.empty())
	{
		int a=q.front();
		q.pop();
		for(i=0;i<G[a].size();i++)
		{
			if(laps[G[a][i].go]==laps[0])//没走过
			{
				laps[G[a][i].go]=laps[a]*G[a][i].val;
				q.push(G[a][i].go);
			}
			else
			{
				if(fabs(laps[G[a][i].go]-laps[a]*G[a][i].val)>deviation)//判断转的圈数是否不变
					return 0;
			}
		}
	}
	return 1;
}
int main()
{
	int n,m,i,j,O,u,v,t;
	double w1,w2;
	bool f;
	scanf("%d",&t);
	for(O=1;O<=t;O++)
	{
		f=1;
		scanf("%d %d",&n,&m);
		for(i=1;i<=n;i++)
			G[i].clear();
		memset(laps,0,sizeof(laps));//多组输入输出！
		for(i=1;i<=m;i++)
		{
			scanf("%d %d %lf %lf",&u,&v,&w1,&w2);
			t1.val=w2/w1;
			t1.go=v;
			G[u].push_back(t1);
			t1.val=w1/w2;
			t1.go=u;
			G[v].push_back(t1);
		}
		printf("Case #%d: ",O);
		for(i=1;i<=n&&f;i++)
		{
			if(laps[i]==laps[0])
			{
				laps[i]=1;
				f=ergodic(i);
			}
		}
		if(f)
			puts("Yes");
		else
			puts("No");
	}
	return 0;
}
```





---

## 作者：TonyYin (赞：0)

## 题意

给定 $n$ 个齿轮和 个 $m$ 个链条，每个链条连接两个齿轮 $u, v$，并且有一个传动比。

传动比有两个参数 $x, y$，表示在**单位时间内**，若 $u$ 转动 $x$ 圈，则 $v$ 必须转动 $y$ 圈。

问 $n$ 个齿轮能否同时转动。

## 分析

考虑到所有链条的传动比都已经给出，我们如果随便找一个齿轮，固定他的转速，那么所有**与他有关的**齿轮速度就都是固定的了。

所以我们把链条两侧的点连双向边，每条边存储传动比。对于每个联通块，随便找一个点，固定其转速，之后求出所有与其相连的点的转速，再判断是否产生矛盾。

题目卡精度，所以在固定第一个点的转速时，可以定为 $100$ 或 $1000$，运算过程中比较大小需要用到 $\epsilon$ 解决精度问题。

具体实现上，只需要循环一遍，对每个点都 DFS 一遍，判断是否产生了矛盾就可以了。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1e3 + 10, MAXM = 2e5 + 10;
const double eps = 1e-5;
int T, n, m;
struct Edge{
    int to, nxt, x, y;
}edge[MAXM];
int head[MAXN], cnt = 0;
void add(int u, int v, int x, int y) {
    edge[++cnt].to = v;
    edge[cnt].x = x;
    edge[cnt].y = y;
    edge[cnt].nxt = head[u];
    head[u] = cnt;
}
double vel[MAXN];
bool dfs(int x) {
    for(int i = head[x]; i; i = edge[i].nxt) {
        int v = edge[i].to;
        if(fabs(vel[v]) < eps) {// if(vel[v] == 0)
            vel[v] = vel[x] * (edge[i].y) / (double)(edge[i].x);
            if(!dfs(v)) return false;
        }
        if(fabs(vel[v] - vel[x] * (edge[i].y) / (double)(edge[i].x)) > eps) 
            // if(vel[v] != vel[x] * edge[i].y / edge[i].x)
            return false;
    }
    return true;
}
int main() {
    scanf("%d", &T);
    for(int t = 1; t <= T; t++) {
        scanf("%d%d", &n, &m);
        memset(head, 0, sizeof(head)); cnt = 0;
        memset(vel, 0, sizeof(vel));
        for(int i = 1; i <= m; i++) {
            int a, b, x, y; scanf("%d%d%d%d", &a, &b, &x, &y);
            add(a, b, x, y); add(b, a, y, x);//注意 反向边的转速比也要反过来
        }
        bool ok = true;
        for(int i = 1; i <= n; i++) {
            if(fabs(vel[i]) < eps) {
                vel[i] = 100;
                if(!dfs(i)) {
                    ok = false; break;
                }
            }
        }
        printf("Case #%d: %s\n", t, (ok)?"Yes":"No");
    }
    return 0;
}
```





---

## 作者：_Sein (赞：0)

考虑$|x_i|$那么小，不如暴力枚举它们的质因数吧!

就是把一个数拆成$\prod p_i^{c_i}$的形式。

这么一个小trick可以使暴力乘得以实现233。

其实再分析一些小性质

**只有环对答案有贡献**，

那么在环上相邻两点，至少有两条路径可以互相到达。

也就是说如果环有问题，那么在环上的任意一对$(x,y)$的运行也有问题。

所以只要求出$(x,y)$的任意一条路径，之后再比较不在这条路径上的这条的边就可以判断是否影响运行了。

其实从这个结论可以发现，

**只要我们遍历一棵树，就可以完美解决此问题**。

对于根，定义它的旋转次数为$1$

那么对于$x$，$y$的旋转次数就是$\frac{w_x*e_{k_1}}{e_{k_2}},\frac{e_{k_1}}{e_{k_2}}$即为题面中的$\frac{x}{y}$，再转化成质因数形式即可。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<cstdlib>
#define gc getchar()
#define ll long long
#define ull unsigned long long
#define file(s) freopen(s".in","r",stdin);freopen(s".out","w",stdout)
#define I inline 
using namespace std;
const int N=1e3+5,M=1e4+5;const ull G=31;
const int P[30]={0,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97};
template<class o>I void qr(o &x)
{
	char c=gc;int f=1;x=0;
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=gc;}
	while(c>='0'&&c<='9'){x=x*10+(c^48);c=gc;}
	x*=f;
}
template<class o>I void qw(o x)
{
	if(x<0)x=-x,putchar('-');
	if(x/10)qw(x/10);
	putchar(x%10+48);
}
ll gcd(ll a,ll b){return !b?a:gcd(b,a%b);}
struct edge{int x,y,next,w1,w2;}a[M<<1];int len,last[N];
void ins(int x,int y,int w1,int w2){a[++len]=(edge){x,y,last[x],w1,w2};last[x]=len;}
int cnt[N][27],lg[105][27],op[N];
bool ve[M<<1],vis[N];
void dfs(int x,int lst)
{
	vis[x]=1;
	for(int k=last[x],y;k;k=a[k].next)
		if(lst!=(k^1))
		{
			y=a[k].y;
			if(vis[y]){ve[k]=ve[k^1]=1;continue;}
			for(int i=1;i<=25;i++)
				cnt[y][i]=cnt[x][i]-lg[abs(a[k].w1)][i]+lg[abs(a[k].w2)][i];
			if(a[k].w1<0||a[k].w2<0)op[y]=op[x]*-1;
			else op[y]=op[x];
			dfs(y,k); 
		}
}
int main()
{
	int T;qr(T);
	for(int i=2;i<=100;i++)
	{
		int x=i;
		for(int j=1;j<=25;j++)
			if(x%P[j]==0)
				while(x%P[j]==0)x/=P[j],++lg[i][j];
	}
	for(int Case=1;Case<=T;Case++)
	{
		memset(last,0,sizeof(last));len=1;
		memset(ve,0,sizeof(ve));memset(vis,0,sizeof(vis));
		memset(cnt,0,sizeof(cnt));memset(op,0,sizeof(op));
		int n,m;qr(n),qr(m);
		for(int i=1,x,y,w1,w2;i<=m;i++)qr(x),qr(y),qr(w1),qr(w2),ins(x,y,w1,w2),ins(y,x,w2,w1);
		for(int i=1;i<=n;i++)
			if(!vis[i])
			{
				op[i]=1;
				dfs(i,0);
			}
		bool bk=1;
		for(int i=1;i<=len;i++)
			if(ve[i])
			{
				ve[i]=ve[i^1]=0;
				int x=a[i].x,y=a[i].y,w1=a[i].w1,w2=a[i].w2;
				int flag=1;
				if(w1<0||w2<0)flag*=-1;
				if(op[x]*flag!=op[y]){bk=0;break;}
				for(int j=1;j<=25;j++)
					if(cnt[x][j]-lg[abs(w1)][j]+lg[abs(w2)][j]!=cnt[y][j])
					{
						bk=0;break;
					}
				if(!bk)break;
			}	
		printf("Case #%d: ",Case);
		if(!bk)puts("No");
		else puts("Yes");
	}
	return 0;
}
```

---


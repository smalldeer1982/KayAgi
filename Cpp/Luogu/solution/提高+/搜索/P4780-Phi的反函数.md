# Phi的反函数

## 题目描述

求最小的正整数x，使得$\varphi(x)=n$

## 样例 #1

### 输入

```
4```

### 输出

```
5```

# 题解

## 作者：da32s1da (赞：13)

最多有10个质数，因为$$2*3*5*7*11*13*17*19*23*29=6469693230$$
一个质数最多有30个，因为$$2^{31}=2147483648$$
均大于等于$2^{31}$，故应为$-1$。

可见，本题数据范围较小，可用$dfs$来完成。
```
#include<cstdio>
#include<iostream>
#include<cmath>
using namespace std;
#define LL long long
int tot,vis[46500];
LL prime[4800];
void init(){  //预处理素数
	prime[++tot]=2;
	for(int i=3;i<=46400;i+=2)
	if(!vis[i]){
		prime[++tot]=i;int qq=i<<1;
		for(int j=i*3;j<=46400;j+=qq)
		if(!vis[j])vis[j]=1;
	}
	//4796 primes
}
LL n,ans=4294967296;
bool pr(LL qq){  //判断单个数字是否为素数
	if(qq&1^1)return false;
	int rr=sqrt(qq);
	for(int i=3;i<=rr;i+=2)
	if(qq%i==0)return false;
	return true;
}
void dfs(int pri,LL num,LL phi){
	if(num==1){  //若该数已经被拆完，直接更新答案
		ans=min(ans,phi);
		return;
	}
	if(num>sqrt(n)&&pr(num+1)){  //若当前数大于sqrt(n)，那么可能为质数且只有一个，故进行判断
		ans=min(ans,phi*(num+1)); //若是质数直接更新答案
        return;
	}
	for(int i=pri+1;i<=tot&&(prime[i]-1)<=num;i++) //枚举所有质数
	if(num%(prime[i]-1)==0){
		LL num_=num/(prime[i]-1);
		LL phi_=phi*prime[i];  //计算新的数字和答案
		dfs(i,num_,phi_);  //下一轮dfs
		while(num_%prime[i]==0){//枚举该质数的次数
			num_/=prime[i];   //计算新的数字和答案
			phi_*=prime[i];
			dfs(i,num_,phi_);  //下一轮dfs
		}
	}
}
int main(){
	init();   //得到sqrt(2147483647)以内的质数 
	scanf("%d",&n);
	dfs(0,n,1);  //进行dfs，一定要初始化答案为1
	if(ans!=4294967296)printf("%lld\n",ans);
	else puts("-1");  //输出答案
}
```

---

## 作者：TempestJueMu (赞：5)

~~我们在小学二年级学过~~

若 $\gcd(a,b)=1$ ，则 $\varphi(ab)=\varphi(a) \times \varphi(b)$ 

若 $p$ 为质数，则 $\varphi(p)=p-1$

（证明略）

则可进一步得到：

> 若 $p$ 为质数且 $\gcd(a,p)=1$ ，则 $\varphi(ap)=\varphi(a)\times(p-1)$ 


设 $n=\prod_{i=1}^sp_i^{c_i}$ （唯一分解定理），则   $\varphi(n)=n\times\prod_{i=1}^s\frac{p_i-1}{p_i}$

**证明：**
$$
\begin{aligned}
\varphi(n)&=\prod_{i=1}^s\varphi(p_i^{c_i})\\
&=\prod_{i=1}^sp_i^{c_i-1}(p_i-1)\\
&=\prod_{i=1}^sp_i^{c_i}(1-\frac 1 {p_i})\\
&=n\prod_{i=1}^s(1-\frac 1 {p_i})
\end{aligned}
$$

因此，我们可以设 $n=(p_1-1)(p_2-1)\cdots (p_k-1)$ 。

即把 $n$ 分解成若干个 **$质数-1$** 的乘积，用 dfs 实现。

具体实现见代码注释。

**代码：**

```cpp
#include<bits/stdc++.h>
#define ll long long
#define INF 2147483647
#define MAXN (1<<16)|1
using namespace std;
int n;
ll Ans=INF;
int prime[MAXN];
bool vis[MAXN];
void getPrime(int m)//筛出<=m的质数
{
	for(int i=2;i<=m;i++)
	{
		if(vis[i]==0)prime[++prime[0]]=i;
		for(int j=1;j<=prime[0]&&i*prime[j]<=m;j++)
		{
			vis[i*prime[j]]=1;
			if(i%prime[j]==0)break;
		}
	}
}
bool check(ll x)//判断x是否为质数
{
	for(int i=2;i*i<=x;i++)
	if(x%i==0)return 0;
	return 1;
}
void dfs(int id,ll num,ll ans)
//id：搜到第id个质数
//num：还需分解的数
//ans：当前的x
{
	if(num==1)//n已被分解完
	{
		Ans=min(Ans,ans);//更新答案
		return;
	}
	if(check(num+1)){dfs(id,1,ans*(num+1));return;}
   //剩余一个大质数，则直接判掉
	for(int i=id;i<=prime[0];i++)
	{
		if(num%(prime[i]-1)==0)//可以分解
		{
			ll Newnum=num/(prime[i]-1),Newans=ans*prime[i];//见第一个推论
			dfs(i+1,Newnum,Newans);
			while(Newnum%prime[i]==0)
				Newnum/=prime[i],Newans*=prime[i],dfs(i,Newnum,Newans);//搜索指数
		}
	}
}
int main()
{
	getPrime(MAXN);//质数筛到sqrt(2^31)即可
	scanf("%d",&n);
	dfs(1,n,1);
	if(Ans==INF)printf("-1\n");
	else printf("%lld",Ans);
	return 0;
}
```

---

## 作者：hfjh (赞：3)

# P4780 Phi 的反函数
update 2023/2/17 作者笔误
## $\varphi$ 定义

 $\varphi(n)$  代表从 $1-n$ 所有与 $n$ 互质的数的个数。

## 求$~\varphi(n)~$

### 普通求法：

首先将 $n$ 唯一分解为：

$n=x_1^{p_1}\times x_2^{p_2}……{\times} x_n^{p_n} $

$\varphi(n)=n{\times} (1-\frac1{x_1}){\times} (1-\frac1{x_2}){\times} ……{\times} (1-\frac1{x_n})$

证明：

首先我们考虑在所有数中有 $\frac{1}{x}$ 的概率会取到一个数是 $x$ 的倍数，那么有 $(1-\frac{1}{x})$ 的概率会取到一个数不是 $x$ 的倍数， $1-n$ 有 $n$ 个数，我们要找到 $1-n$ 所有与 $n$ 互质的数，也就是去一个不是 $n$ 的任意一个因数 $(x_1,x_2,x_3……x_n)$ 的倍数，就得到以上式子。

## 两个定理：

$$
1.\begin{cases}
\varphi(nm)=\varphi(n){\times} \varphi(m)~~~~~\gcd(n,m)=1\\
\varphi(nm)=\varphi(n){\times} m~~~~~~~~~~~\gcd(n,m)=m
\end{cases}
$$

定理 1 证明：

在 $\gcd(n,m)=1$ 情况下可以推导：

$n=x_1^{p_1}{\times} x_2^{p_2}……{\times} x_n^{p_n} $

$m=y_1^{q_1}{\times} y_2^{q_2}……{\times} y_n^{q_n} $

$n{\times} m=x_1^{p_1}{\times} x_2^{p_2}……{\times} x_n^{p_n}{\times} y_1^{q_1}{\times} y_2^{q_2}……{\times} y_n^{q_n} $

$\varphi(nm)=n{\times} m{\times} (1-\frac1{x_1})……{\times} (1-\frac1{x_n}){\times} (1-\frac1{y_1})……{\times} (1-\frac1{y_n})=\varphi(n){\times} \varphi(m)~~~~~~~~~~~~gcd(n,m)=1$

2. 在 $\gcd(n,m)=m$ 情况下

考虑感性理解， $1-n$ 里面有 $\varphi(n)$ 个与 $n$ 互质，那么扩大 $m$  倍，相当于有 $m$ 个 $1-n$ 就直接乘(因为我们保证了 $\gcd(n,m)=m$ 也就是 $n$ 是 $m$ 的倍数,所以不存在乘上 $m$ 后多出了不属于 $n$ 的因子)。

定理 2.$\varphi(n)=n-1~~~~~~~~~~~~~n\in prim$（这显而易见）

### 我们需要求 Phi 的反函数就要先深刻理解上述内容然后进行运用

可以根据上述定理 1 得到：

（在这里我们用到了定理一第一类和定理一第二类的一种特殊情况   $~\varphi(n{\times} n)=\varphi(n){\times} n~$

得出
$~\varphi(x)=\varphi(a_1){\times} a_1^{p_1-1}{\times} \varphi(a_2){\times} a_2^{p_2-1}{\times} ......\varphi(a_n){\times} a_n^{p_n-1}~~~~~~~~~~~~~~~~~~a_i\in prime$

由定理二得： $a_i$ 都是质数，所以 $\varphi(a_i)=a_i-1$

所有质数分解出来不超过 $10$ 个，因为$2{\times} 3{\times} 5{\times} 7{\times} 11{\times} 13{\times} 17{\times} 19{\times} 23{\times} 29=6469693230$

$~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~2^{31}=2147483648$

所以可以直接暴力搜索。

（关于判断是否为质数的函数）

因为数据范围在 $2^{31}$  ,如果我们求 $2^{31}$  范围内的质数，直接爆炸，

其实我们只需要找出 $2^{16}$ 的质数，每次判断一下当前这个数 $now+1$ (也就是 $revphi(now)$ 是不是质数

例如 $\varphi(x)=n=\varphi(3){\times} \varphi(10000000007)$。

第一次找到 $\varphi(3)$ 处理以后，由于我们只找了 $2^{16}$ 的质数，我们找不到 $\varphi(1000000007)$ 在里面，我们需要每次判断当前这是数是不是质数。

具体的：

第一次判断 $\varphi(3){\times} \varphi(1000000007)$ 显然不是质数。

除以 $\varphi(3)$ 后变成了 $\varphi(1000000007)$  也就是 $now=1e9+6$。

第二次判断 $(now+1)\in prime$  那么直接把质数给除了，直接结束了。

### 那么怎么得出答案呢

$$
1.\begin{cases}
\varphi(nm)=\varphi(n){\times} \varphi(m)~~~~~\gcd(n,m)=1\\
\varphi(nm)=\varphi(n){\times} m~~~~~~~~~~~\gcd(n,m)=m
\end{cases}
$$

$\varphi(x)=\varphi(a_1){\times} a_1^{p_1-1}{\times} \varphi(a_2){\times} a_2^{p_2-1}{\times} ......\varphi(a_n){\times} a_n^{p_n-1}~~~~~~~~~~~~~~~~~~a_i\in prime$

我们再来重新看看这些式子：

可以看出最后的 $ans=a_1{\times} a_1^{p_1-1}{\times} a_2{\times} a_2^{p_2-1}{\times} ......{\times} a_n{\times} a_n^{p_n-1}~$

代码：

```cpp
#include<bits/stdc++.h> 
#define ll long long 
using namespace std;
const int N=1e7+10;
int vis[N],s[30],tot=0,n,cnt=0;
ll ans=1e17+10,prim[N];
void shai(int x){
    for(int i=2;i<=x;i++){
        if(!vis[i]){
            prim[++tot]=i;
        }
        for(int j=1;j<=tot&&i*prim[j]<=x;j++){
            vis[prim[j]*i]=1;
            if(!i%prim[j]){
                break;
            }
        }
    }    
}//质数筛
bool is_p(ll x){
    for(int i=2;i* i<=x;i++){
        if(x%i==0){
            //cout<<x<<i<<endl;
            return 0;
        }
    }
    return 1;
}//判断是否为质数
void dfs(int now,int id,ll rev){//id代表当前干过的质数，是个优化
    if(now>=ans) return ;//简单优化
    if(now==1){
        ans=min(rev,ans);
        return ;
    }
    if(is_p(now+1)) dfs(1,id+1,rev*(now+1));
    for(int i=id;i<=tot;i++){
        if(now%(prim[i]-1)==0){
            int a=now;
            ll b=rev;
            a/=(prim[i]-1);b*=prim[i]; //定理1的情况1
            dfs(a,i+1,b);
            while(a%prim[i]==0){//定理1的情况2
                a/=prim[i];b*=prim[i]; 
                dfs(a,i,b);
            } 
        }
    }
}

int main(){
    scanf("%d",&n);
    shai(sqrt(n)+1);    
    dfs(n,1,1);
    if(ans==1e17+10){//无解或者太大了
        printf("-1");
    }else printf("%lld",ans);
    return 0;
}
//2147483647
```

---

## 作者：liyifan24 (赞：3)

φ(x)：欧拉函数；
**{在数论，对正整数n，欧拉函数是小于n的正整数中与n互质的数的数目（φ(1)=1）。}**
~~有兴趣的同鞋可以搜一下~~
其余不解释了；
代码附上：
 
 ```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define N 50000
using namespace std;
int x,prm[50010];
long long ans;
bool ext[50010];
void get_prime(){
    for (int i=2;i<=N;i++){
        if (ext[i]==false) prm[++prm[0]]=i;
        for (int j=1;j<=prm[0];j++){
            if ((long long)i*prm[j]>N) break;
            ext[i*prm[j]]=true;
            if (i%prm[j]==0) break;
        }
    }
}
bool is_prime(long long x){
    for (int i=2;i<=floor(sqrt(x));i++)
      if (x%i==0) return false;
    return true;
}
void search(int last,long long res,long long sum){
    if (res==1){ans=min(ans,sum);return;}
    if (res>floor(sqrt(x))&&is_prime(res+1)){
        ans=min(ans,sum*(long long)(res+1));
        return;//直接退出，因为后面即使搜索也搜不到更优解了
    }//注意必须当剩下的数大于sqrt(x)的时候才能算成大质数不然会错
    for (int i=last+1;i<=prm[0];i++){
        if (res%(prm[i]-1)==0){
            int nwres=res/(prm[i]-1);
            long long nwsum=sum*(long long)prm[i];
            search(i,nwres,nwsum);
            while (nwres%prm[i]==0){
                nwres/=prm[i];
                nwsum=nwsum*(long long)prm[i];
                search(i,nwres,nwsum);//枚举质因数的次数，每次都要search
            }
        }
        if (prm[i]>res) return;
    }
}
int main()
{
    freopen("phi.in","r",stdin);
    freopen("phi.out","w",stdout);
    get_prime();
    ans=2147483647;++ans;
    scanf("%d",&x);
    search(0,x,1);
    if (ans<=2147483647) printf("%d\n",ans);
    else printf("-1\n");
    return 0;
}
```

---

## 作者：Anvet (赞：2)

根据欧拉函数的定义，可以得到：
arcphi(n)=min{x|phi(x)=n};
在之有欧拉公式 xφ(p) mod p=1， 
所以x∗xφ(p)−1 mod p=1 ，
这样xφ(p)−1就是x在mod p 意义下的逆元，不过若去查一查欧拉函数表，对于每一个在值域内的x，不只有唯一的在定义域内的n与之对应，所以如果用枚举会很要命，很可能会TLE。而且样例数据里说了n<=2^31！！！！肯定结果要比这个数大很多！！！~~（高精度？）~~
SO，若我们要求φ(x)，可以先将其分解成∏(ai^Pi)的形式，其中a是素数。 
然后可以推导出公式φ(x)=∏(ai&Pi−ai^Pi−1) 
然后这个可以实现为φ(x)=x/∏(ai−1) 
这样就可以在√时间内出解了。废话不多，贴上代码：
```
#include"bits/stdc++.h"
#define last last_
 
using namespace std;
typedef long long LL;//本人懒。。。
 
const int N=100005;//本人懒不解释。。。
 
int k,pri[N],pcnt,S,len,num[N>>4];
bool fl[N];
set<LL> s;
set<LL>::iterator it;//用集合做会方便一点，不用排序和去重也是很好的。。。
 
void push(LL x){
	s.insert(x);
	if(s.size()<=k)return;
	s.erase(--(it=s.end()));
}
 
bool go(LL x){
	if(s.size()<k)return true;
	return x<*(--(it=s.end()));
}
 
const int jp[]={2,3,5,7,11,13,17};
 
LL mult(LL x,LL y,LL z){
	return ((x*y-(LL)((long double)x*y/z+0.5)*z)%z+z)%z;
}
 
LL power(LL a,LL t,LL P){
	LL r=1;
	while(t){
		if(t&1)r=mult(r,a,P);
		a=mult(a,a,P);t>>=1;
	}
	return r;
}
 
bool Miller_Rabin(LL n){
	if(n==2||n==3||n==5||n==7||n==13||n==17||n==19||n==23||n==29||n==31)return true;
	if(n%2&&n%3&&n%5&&n%7&&n%11&&n%13&&n%17&&n%19&&n%23&&n%29&&n%31){
		LL r=n-1;
		int t=0;
		while(!(r&1))r>>=1,t++;
		for(int i=0;i<7;i++){
			LL x=power(jp[i],r,n),y;
			for(int j=0;j<t;j++){
				y=mult(x,x,n);
				if(y==1&&x!=1&&x!=n-1)return false;
				x=y;
			}
			if(x!=1)return false;
		}
		return true;
	}
	return false;
}
 
void dfs(int p,LL n,LL m){
	if(n==1){
		if(p)push(m*2);
		push(m);
		return;
	}
	if((double)(n+1)*m>1E17)return;
	if(!go((n+1)*m))return;
	if(p==0){
		if(n>=S&&Miller_Rabin(n+1))push(m*(n+1));
		if(n==1)push(m);
		return;
	}
	dfs(p-1,n,m);
	if(n%(num[p]-1)==0){
		n=n/(num[p]-1)*num[p];
		while(n%num[p]==0){
			n/=num[p],m*=num[p];
			dfs(p-1,n,m);
		}
	}
}
 
LL n;
 
int main(){
	cin>>n; k=1;
	S=3*(int)sqrt(n+.1);
	for(int i=2;i<=S;i++){
		if(!fl[i]){
			pri[++pcnt]=i;
			if(n%(i-1)==0)num[++len]=i;
		}
		for(int j=1;i*pri[j]<=S;j++){
			fl[i*pri[j]]=1;
			if(i%pri[j]==0)break;
		}
	}
	dfs(len,n,1);
	if(s.empty()||*s.begin()>0x7FFFFFFF) puts("-1");
	else printf("%lld\n",*s.begin());
	return 0;
}

```

---

## 作者：Siyunshan (赞：2)

欧拉函数大家肯定都会吧~~不会还是洗洗睡吧~~。

首先我们设答案 $ans$=$p_1$^$a_1$ × $p_2$^$a_2$ × …… × $p_m$^$a_m$ ，其中 $p_i$ 是素数。

且对于任意 $i$ 和 $j$ 都有 $pi≠pj$。

能够可以看出 $n$=$p_1$^$(a_1-1)$ × $p_2$^$(a_2-1)$ × …… × $p_m$^$(a_m-1)$×$(p_1-1)$×$(p_2-1)$×……×$(p_m-1)$

那么直接 $DFS$ 了。暴力 $(p_1-1)$ × $(p_2-1$) × …… ×$(p_m-1)$,然后模$n$后验证是否是这些数的倍数即可。

所以我们预处理出 $1-sqrt(n)$ 的所有素数，因为我们只会用到这些素数。如果有$pk$大于这个范围，显然不存在 $t≠k$ 并且 $pk$ 也不符题意。

所以对这种情况特判一下，只求出这样的数看看是否正确即可。

这样程序的 $DFS$ 就分成了三个流程： 直接结尾，乘上一个大素数后结尾，和继续扩展这三种。
   
完结撒花。

怼题面：$φ（x）$哪来的反函数，其定义域内都不具备严格的单调性。

---

## 作者：reclusive (赞：1)

# 题目大意：

传送门：[P4780 Phi的反函数](https://www.luogu.com.cn/problem/P4780)

这道题就是让你去求一个**最小**的正整数 $x$，使得 $\varphi(x)=n$。

# 具体思路：

在那之前，我们先来讲一些欧拉函数的性质。

### 性质：

- 若 $n\in prime$, 则有：$\varphi(n)=n-1$。

- 欧拉函数为积性函数，有：$\varphi(ab)=\varphi(a)\varphi(b)$。

- 由唯一分解定理，设 $n=\prod_{i=1}^sp_i^{k_i}$，其中，$p_i\in prime$，有：$\varphi(n)=n\times\prod_{i=1}^s\dfrac{p_i-1}{p_i}$。

证明：略，以上性质证明可以去 bdfs 一下。（~~真的不是我不会啊~~）

### 思路：

首先，我们对 $x$ 分解质因数，设 $x=p_1^{c_1}p_2^{c_2}\dots p_k^{c_k}$，即 $x=\prod_{i=1}^s p_i^{c_i}$。

由于 $\varphi(x)$ 是积性函数，因此 $\varphi(x)=\varphi(p_1^{c_1})\varphi(p_2^{c_2})\dots \varphi(p_k^{c_k})$，即 $\varphi(x)=\prod_{i=1}^s\varphi(p_i^{c_i})$。

但是题目求的是 $x$ 的最小正整数解，那怎样的 $x$ 才能保证是最小正整数解呢？

我们仔细观察式子：
$$\varphi(n)=n\times\prod_{i=1}^s\dfrac{p_i-1}{p_i}$$
上式中 $\varphi(n)$ 的值与 $p_i$ 的指数 $c_i$ 无关，也就是一个数的欧拉函数值与质因子的指数无关。

那就很好求最小正整数解了，我们只要令 $x$ 的所有质因子指数都为 $1$,即 $x=\prod_{i=1}^s p_i$。

因此，原式化为 $n=\prod_{i=1}^s \varphi(p_i)$，其中 $p_i\in prime$。

那我们又知道若 $n\in prime$，则有 $\varphi(n)=n-1$，

所以，原式又可以化简为：$n=\prod_{i=1}^s (p_i-1)$。

那接下来的思路都很容易想到了，我们用线性筛先将一部分的质数找出来，然后直接 dfs 来将 $n$ 分解为几个质数 $-1$ 的乘积。

不过，这道题需要一个剪枝，就是如果你当前要分解的 $n$ 是一个很大的质数，你线性筛的时候没把它找出来，然后分解的时候一直跑，可能会导致 TLE，

所以我们可以在分解 $n$ 之前，就可以判断 $n$ 是不是一个质数，如果是，直接 dfs，可以省下一点时间。

然后你判断质数时，可以采用最传统的试除法，当然也可以像我一样用新学的 Miller-Robin 算法，可能可以快一点，不过我也试了一下两种方法，都是可以过的。

最后给一点小 Tips:

- 没事不要全部变量都开 long long。

- 用 Miller-Robin 时，常数记得开小一点，开 $20$ 已经可以得出正确答案了，开 $50$ 直接 TLE 了，更别说 $114514$ 了！

# AC Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N=1e5;
LL v[N+10],prime[N+10],pr,ans=0x7fffffff;
inline int read()//快读 
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'&&ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();
	return x*f;
}
inline void write(int s)//快输 
{
    int n=0,buf[15];
    if(s<0) putchar('-'),s=-s;
    do buf[n++]=s%10;while(s/=10);
    while(n--) putchar(buf[n]+'0');
}
LL witness(LL a,int n)
{
	LL ans=1,t=n-1,x;
	while(t)
	{
		if(t&1)ans=ans*a%n;
		x=a;a=a*a%n;
		if(a==1&&x!=1&&x!=(n-1))return 1;
		t>>=1;
	}
	return (ans==1)?0:1;
}
int Miller_Robin(LL n,int s)
{
	if(n==2)return 1;
	if(n<2||!(n&1))return 0;
	LL a;
	for(int i=0;i<s;++i)
	{
		a=rand()*(n-2)/RAND_MAX+1;
		if(witness(a,n))return 0;
	}
	return 1;
}//以上部分为Miller Robin算法,可以bdfs学习一下 
void init()//线性筛,别筛太大的质数,可能会TLE 
{
	memset(v,0,sizeof(v));pr=0;
	for(int i=2;i<=N;++i)
	{
		if(!v[i])prime[++pr]=i;
		for(int j=1;j<=pr&&i*prime[j]<=N;++j)
		{
			v[i*prime[j]]=1;
			if(i%prime[j]==0)break;
		}
	}
}
void dfs(int k,LL n,LL x)
{
	if(n==1){ans=min(ans,x);return;}
	if(Miller_Robin(n+1,20)){dfs(114514,1,x*(n+1));return;}//剪枝 
	for(int i=k;i<=pr;++i)//分解n 
	{
		if(n%(prime[i]-1)==0)
		{
			dfs(i+1,n/(prime[i]-1),x*prime[i]);
			LL nn=n/(prime[i]-1),xx=x*prime[i];
			while(nn%prime[i]==0){nn=nn/prime[i];xx=xx*prime[i];dfs(i,nn,xx);}
		}
	}
}
int main()
{
	init();//预处理 
	int n;n=read();//输入 
	dfs(1,n,1);
	write((ans==0x7fffffff)?-1:ans);//如果ans的值没有被修改到,直接输出-1,否则输出ans 
	return 0;//完结撒花
}
```


---

## 作者：Specthraimn (赞：0)

# Phi 的反函数 题解

### 大致题意

给定 $\varphi(x)$ 的值 $n$，求 $x$。  

**定义**  

欧拉函数（Euler's totient function），即 $\varphi(n)$，表示的是小于等于 $n$ 和 $n$ 互质的数的个数。  
比如说 $\varphi(1) = 1$。 

**欧拉函数的性质**  

1. 若 $x$ 为素数，则 $\varphi(x) = x - 1$。容易证明，除 $x$ 以外都与 $x$ 互质。
2. $\varphi$ 是积性函数，即 $\varphi(a \times b) = \varphi(a) \times \varphi(b)$。  
3. 唯一分解定理，即设 $x = \Pi_{i = 1}^{k}{pr_i^{d_i}}, pr_i \in Prime$，有 $\varphi(x) = x \times\Pi_{i = 1}^{k}{\frac{pr_i-1}{pr_i}}$。

### 解题思路

根据唯一分解定理，可以将给的 $\varphi(x) = n$ 分解为 $k$ 个 $(pr_i-1)$ 的乘积 $(pr_i \in Prime)$，从而得出 $x$ 的 $k$ 个质因数 $pr_i$，求出 $x$。  
由于 $n$ 很大，可以用线性筛先筛出 $\sqrt n$ 以内的素数，求解时试除即可。  
$\log_2(2^{31})$ 只有 $31$，可以用 DFS 递归实现分解。  
### AC 代码
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int M = 60000;
map <int, int> vis;
vector <int> pr;
bool check(int x){
	if(x <= 1) return 0;
	if(x == 2) return 1;
	for(int i = 2; i*i <= x; i++){
		if(x % i == 0){
		return 0;
		}
	}
	return 1;
}
int n, ans = 3e9 + 10;
void dfs(int id, int now, int phi){
	if(now == 1){
		ans = min(ans, phi);
		return;
	}
	if(now > sqrt(n) && check(now + 1)){
		ans = min(ans, (now + 1)*phi);
		return;
	}
	for(int i = id+1; i < pr.size() && (pr[i]-1) <= now; i++){
		if(now % (pr[i]-1) == 0){
			int s = now/(pr[i]-1), t = phi*(pr[i]);
			dfs(i, s, t);
			while(s % pr[i] == 0){
				s /= pr[i];
				t *= pr[i];
				dfs(i, s, t);
			}
		}
	}
}
signed main(){
	cin >> n;
	for(int i = 2; i <= M; i++){
		if(!vis[i])	pr.push_back(i);
		for(int j = 0; j < pr.size() && i*pr[j] <= M; j++){
			vis[i*pr[j]] = 1;
			if(i % pr[j] == 0) break;
		}
	}
	dfs(0, n, 1);
	if(ans != 3e9 + 10){
		cout << ans << endl;
		return 0; 
	}
	cout << -1;
	return 0;
}
```

---


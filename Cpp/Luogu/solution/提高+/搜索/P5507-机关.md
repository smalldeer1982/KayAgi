# 机关

## 题目背景

Steve成功降落后，在M星上发现了一扇大门，但是这扇大门是锁着的

## 题目描述

这扇门上有一个机关，上面一共有12个旋钮，每个旋钮有4个状态，将旋钮的状态用数字$1$到$4$表示

每个旋钮只能向一个方向旋转（状态：1->2->3->4->1），在旋转时，会引起另一个旋钮也旋转一次（方向相同，不会引起连锁反应），同一旋钮在不同状态下，可能会引起不同的旋钮旋转（在输入中给出）

当所有旋钮都旋转到状态1时，机关就打开了

由于旋钮年久失修，旋转一次很困难，而且时间很紧迫，因此Steve希望用最少的旋转次数打开机关

这个任务就交给你了

## 说明/提示

样例1和2输入相同，两个输出都可以通过

样例4解释：
```
414334 241424
旋转11到状态3，引起3旋转到状态1
411334 241434
旋转4到状态4，引起11旋转到状态4
411434 241444
旋转6到状态1，引起11旋转到状态1
411431 241414
旋转10到状态1，引起8旋转到状态1
411431 211114
旋转7到状态3，引起9旋转到状态2
411431 312114
旋转7到状态4，引起5旋转到状态4
411441 412114
旋转5到状态1，引起12旋转到状态1
411411 412111
旋转9到状态3，引起7旋转到状态1
411411 113111
旋转9到状态4，引起4旋转到状态1
411111 114111
旋转9到状态1，引起1旋转到状态1
111111 111111
```

数据保证存在打开机关的方式

每个测试点10分

只要你输出格式正确，输出了正确的步数，并给出了任意一种正确方案，就能得到该测试点的得分

否则，该测试点不得分

数据范围：

测试点 | 所需步数
:-: | :-:
1 | 4|
2|6|
3|8|
4|9|
5|10|
6|11|
7|12|
8|13|
9|15|
10|17|

## 样例 #1

### 输入

```
3 3 7 2 6
3 1 4 5 3
3 1 2 6 4
3 1 10 3 5
3 2 8 3 6
3 7 9 2 1
1 1 2 3 4
1 3 11 10 12
1 8 6 7 4
1 9 9 8 8
1 12 10 12 12
1 7 8 9 10
```

### 输出

```
6
1 2 3 4 5 6
```

## 样例 #2

### 输入

```
3 3 7 2 6
3 1 4 5 3
3 1 2 6 4
3 1 10 3 5
3 2 8 3 6
3 7 9 2 1
1 1 2 3 4
1 3 11 10 12
1 8 6 7 4
1 9 9 8 8
1 12 10 12 12
1 7 8 9 10
```

### 输出

```
6
1 1 2 3 4 5
```

## 样例 #3

### 输入

```
4 2 2 2 2
4 1 1 1 1
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1
1 1 1 1 1
```

### 输出

```
1
1
```

## 样例 #4

### 输入

```
4 9 3 4 5 
1 9 8 12 11 
4 7 5 6 12 
3 2 2 11 2 
3 6 8 2 12 
4 8 4 2 11 
2 12 9 5 3 
4 1 1 11 1 
1 1 7 4 1 
4 11 6 12 8 
2 6 3 7 6 
4 3 9 7 10 
```

### 输出

```
10
11 4 6 10 7 7 5 9 9 9 
```

# 题解

## 作者：liangbowen (赞：67)

## 前言

[题目传送门！](https://www.luogu.com.cn/problem/P5507)

[更好的阅读体验？](https://liangbowen.blog.luogu.org/solution-p5507)

爆搜题。大家都不用 Astar 算法，那我来补篇题解。

## 思路

每个按钮都有状态，因此考虑状压爆搜。

每一个按钮都有 $1, 2, 3, 4$ 几种状态。因此可以转化为 $0, 1, 2, 3$ 四种状态，然后两位一状压。

接下来就是 A 星。估值函数 $h(x)$ 可以设计为：每个按钮分别旋转到 $1$ 的值。由于一次操作会牵动两个按钮，因此要除以二。

```cpp
//为了方便状压，数组、按钮编号，下标都从1开始
struct node
{
	int st; //状态 
	double f;
	node(int zltqwq)
	{
		db h = 0;
		st = zltqwq;   //下面 &3 可以简单理解为 mod 4
		for (int i = 0; i < 12; i++) h += (4 - ((st >> (i * 2)) & 3)) & 3; 
		h /= 2;
		f = g[st] + h;	
	}
	friend bool operator <(node y, node x) {return x.f < y.f;}
};
priority_queue <node> q;
```

定义好后，输入时记录一下初始状态。然后开始爆搜。

```cpp
int IAKIOI; //想不到好的名字了。反正是初始状态
void input()
{
	for (int i = 0; i < 12; i++)
	{   //下标统一减一
		int a = read() - 1; IAKIOI |= (a << (i * 2));
		for (int j = 0; j < 4; j++) nxt[i][j] = read() - 1; 
	}	
}
```

每次枚举每一个状态下，对应的每一个按钮的状态。同时记录每一个按钮受牵动的按钮编号及其对应状态。

然后通过异或性质（$x \oplus x = 0$）将下一个状态求出。这一部分其实很容易，只是代码实现看起来比较罢了。

这个状态没有访问过就更新。由于最后要输出方案，所以记录一下状态是由哪一个状态，旋转什么按钮得到的。

```cpp
int IAKIOI; //初始状态 
void Astar()
{
    priority_queue <node> q;
    q.push(node(IAKIOI)), vis[IAKIOI] = true;
    while (!q.empty())
    {
        int st = q.top().st;
        //printf("st = %d\n", st);
        q.pop();
        if (st == 0) break; //等同于全是1
        for (int i = 0; i < 12; i++)
        {
        	//分别表示i的状态，受牵连的按钮编号，受牵连的按钮的状态
            int sti = (st >> (i * 2)) & 3, di = nxt[i][sti], stdi = (st >> (di * 2)) & 3; 
            //其实就是将第i个按钮替换成下一个状态。当前状态为 sti，下一个状态显然是 (sti + 1) % 4
         	int dst = st ^ (sti << (i * 2)) ^ (((sti + 1) & 3) << (i * 2));
         	//同上，就是将第di个按钮替换成下一个状态。当前状态为 stdi，下一个状态显然是 (stdi + 1) % 4
            dst = dst ^ (stdi << (di * 2)) ^ (((stdi + 1) & 3) << (di * 2));
            if (!vis[dst]) //没有就进去
            {
				//pre[] 和 button[] 分别表示：从哪个状态过来；从那个状态过来是使用什么按钮 
                g[dst] = g[st] + 1, vis[dst] = true;
                pre[dst] = st, button[dst] = i + 1;
                q.push(node(dst));
            }
        }
    }
}
```

然后输出就完事了。用递归的形式倒序输出即可。

```cpp
void output(int x)
{
	if (x == IAKIOI) return;
	output(pre[x]), write(button[x]), space;
}
int main()
{
	input();
	Astar();
	write(g[0]), endl; //0是最终状态
	output(0);
	return 0;
}
```

这道题就做完啦！

## 完整代码

```cpp
#include <iostream>
#include <cstdio>
#include <queue>
using namespace std;
int read()
{
	char op = getchar(); int x = 0, f = 1;
	while (op < 48 || op > 57) {if (op == '-') f = -1; op = getchar();}
	while (48 <= op && op <= 57) x = (x << 1) + (x << 3) + (op ^ 48), op = getchar();
	return x * f;
}
const int k = 1 << 24;
int nxt[15][10], g[k + 10];
bool vis[k + 10];
int pre[k + 10], button[k + 10]; //分别表示：从哪个状态过来；从那个状态过来是使用什么按钮 
struct node
{
	int st; //状态 
	double f;
	node(int zltqwq) //变量起 @zltqwq 是因为想不到好名字了。膜拜 zlt
	{
		double h = 0;
		st = zltqwq;
		for (int i = 0; i < 12; i++) h += (4 - ((st >> (i * 2)) & 3)) & 3;
		h /= 2;
		f = g[st] + h;	
	}
	friend bool operator <(node y, node x) {return x.f < y.f;}
};
int IAKIOI; //初始状态 
void Astar()
{
	priority_queue <node> q;
	q.push(node(IAKIOI)), vis[IAKIOI] = true;
	while (!q.empty())
	{
		int st = q.top().st;
		//printf("st = %d\n", st);
		q.pop();
		if (st == 0) break; //等同于全是1
		for (int i = 0; i < 12; i++)
		{
			int sti = (st >> (i * 2)) & 3, di = nxt[i][sti], stdi = (st >> (di * 2)) & 3;
			int dst = st ^ (sti << (i * 2)) ^ (((sti + 1) & 3) << (i * 2));
			dst = dst ^ (stdi << (di * 2)) ^ (((stdi + 1) & 3) << (di * 2));
			if (!vis[dst])
			{
				g[dst] = g[st] + 1, vis[dst] = true;
				pre[dst] = st, button[dst] = i + 1;
				q.push(node(dst));
			}
		}
	}
}
void input()
{
	for (int i = 0; i < 12; i++)
	{
		int a = read() - 1;
        IAKIOI |= (a << (i * 2));
		for (int j = 0; j < 4; j++) nxt[i][j] = read() - 1;
	}	
}
void output(int x)
{
	if (x == IAKIOI) return;
	output(pre[x]), printf("%d ", button[x]);
}
int main()
{
	input();
	Astar();
	printf("%d\n", g[0]); //0是最终状态
	output(0);
	return 0;
}
```

希望能帮助到大家！

---

## 作者：chinaxjh (赞：51)

# 前言
此题是一道裸的搜索题，正确的做法很多，启发式搜索，双向搜索都可以，这里想介绍一下双向搜索的做法
# 最最差的方法（死暴力）
代码见20分 $Code$

暴力枚举变化的旋钮编号，再判断是否达到目标

时间：$O(12^{step})$

当step小于6时可以通过
# 优化
可以考虑状态优化，如果一个状态到达过了就不用搜索了，由于状态最多只有
$4^{12}$=$2^{24}$，
所以可以大幅度优化时间，一般可以得到40分，但如果搜索技术好也能多拿一点分

### 注意
此题内存花费较大，请尽量减少开大数组，尤其不要随便在子程序里开大数组
### 但我们还有一个问题：怎么表示和储存状态
我们可以考虑采用四进制储存，因为旋钮的状态只有4种，所以可以把十二个旋钮组合起来看做一个4进制数，再把它转化成10进制再表示和储存就好了（把1看作0,2看作1,3看作2,4看作1）
# 主角：双向搜索
由于我们知道了最开始的状态和最后的目标状态，所以我们可以从这两个状态分别开始搜索，得到的搜索树大概是这样的
![](https://cdn.luogu.com.cn/upload/pic/72817.png)
而之前的搜索方法所形成的搜索树大概是这样的
![](https://cdn.luogu.com.cn/upload/pic/72819.png)
......表示省略号，很显然双向搜索的搜索树更小
~~（虽然作者美术不好，看不出来）~~

所以我们采用双向搜索，可以大幅度降低时间，将时间降低到搜索两次9步（由于最多的步数只有17步），最慢的点是650+$ms$，虽然比启发式搜索慢，但也是可以接受的做法

具体的实现过程以及注释可以见代码：$AC$ $Code$

其实我还有一个脑抽提出来的的问题
### 搜到的第一个答案步数一定最少吗
由于作者太蒟蒻了，在做这道题之前从来都没有打过双向搜索，只是有所耳闻，所以做着做着就脑抽提出来这个脑抽问题。

其实只要好好想一想，就会发现双向搜索的本质其实和单向搜索是一样的，由于宽搜是一层一层宽搜的，步数保证是单调上升的，所以搜到的提一个答案肯定是正解。

举个栗子（假设搜索上限是9步）

单向搜索:5步

反向搜索:6步 

相遇了

单向搜索:5步

反向搜索:5步 

相遇了

如果前面的一种情况先搜到，那么答案就不是最优的了，~~但其实两种情况都不可能最想搜到~~

因为

第一种情况其实最先搜到的是这种情况（因为正向反向的搜索搜出来的方案是一样的）

单向搜索:9步

反向搜索:2步 

相遇了

第二种情况其实最先搜到的是这种情况、

单向搜索:9步

反向搜索:1步 

相遇了

由于答案单调上升，所以第二种情况必然在第一种情况出现之前，保证答案更优，证毕。

~~作者终于治好了他的脑抽~~$QAQ$
# $Code$
## 20分 $Code$
```pascal
const n=12;
type arr1=array[0..13] of longint;
var
  s,d,c:arr1;
  a:array[0..30,0..5] of longint;
  i,t:longint;
procedure next(var x:longint);
begin
  inc(x);
  if x>4 then x:=1;
end;//求下一个状态
procedure sc(x:longint;b:arr1);
var
  c:arr1;
  i,j:longint;
begin
  if x>t then//每一步都枚举完了，判断是否符合要求
  begin
    for i:=1 to n do
    if b[i]<>1 then exit;//如果又一个没有变成1，就不行，返回
    writeln(t);
    for i:=1 to t do
    write(d[i],' ');
    halt;//输出答案，第一个搜到的肯定是正解并且最小的，结束程序
  end;
  for i:=1 to n do
  begin
    for j:=1 to n do c[j]:=b[j];//copy原序列
    next(c[a[i,c[i]]]);
    next(c[i]);//这两个的顺序不能变，否则会WA
    d[x]:=i;//记录方案
    sc(x+1,c);//传递序列和当前步数
  end;
end;//暴力搜索
begin
  for i:=1 to n do
  readln(s[i],a[i,1],a[i,2],a[i,3],a[i,4]);
  for t:=1 to 6 do
  sc(1,s);//暴力枚举步数
end.
```

## $AC$ $Code$
### $Pascal$ $AC$ $Code$
```pascal
{
  数组说明
  bfs数组表示旋钮状态对应的10进制
  change数组表示变化的旋钮编号
  sum数组表示是第几步
  getway数组表示状态k在队列中的编号
  last数组表示是从那一个状态转移过来的（在队列中的标号）
  getway1,bfs1,change1,sum1,last1这些数组的作用和去掉1之后的数组作用是一样的，用在反向搜索中
}
type arr1=array[0..13] of longint;
const n=12;//定义一个常量方便一点
var
  a:array[0..n+1,0..5]  of longint;
  s,c,b:arr1;
  bfs,change,sum,getway,last,getway1,bfs1,change1,sum1,last1:array[0..17000000] of longint;
  //大数组一定要开在主程序里
  ans,i,k,l,r,j:longint;
function get:longint;
var
  anss,yu,i:longint;
begin
  yu:=1; anss:=c[1]-1;//因为输入是1,2,3,4，所以要减一
  for i:=2 to n do
  begin
    yu:=yu*4;
    anss:=anss+yu*(c[i]-1);
  end;
  exit(anss);
end;//对于指定的c数组4进制转10进制
procedure chai(x:longint);
var
  i,t:longint;
begin
  t:=x;
  for i:=1 to n do
  begin
    b[i]:=t mod 4+1;//加1与上同理
    t:=t div 4;
  end;
end;//将转为10进制的数重新拆成12位4进制数
procedure printf(x:longint);
begin
  if x<>1 then printf(last[x])//正向搜索的过程记录是反的链表，要先输出再递归
  else exit;
  write(change[x],' ');
end;//打印正向搜索的过程
procedure printf1(x:longint);
begin
  if x=1 then exit;//1的情况就直接返回，否则就炸了
  write(change1[x],' ');//反向搜索的过程记录是正的链表，要先输出再递归
  printf1(last1[x]);
end;//打印反向搜索的过程
procedure next(var k:longint);
//相当于c++中&了一下，是一个变参，在lass过程中同理
begin
  inc(k);
  if k>4 then k:=1;
end;//求旋钮状态的后继
procedure lass(var k:longint);
begin
  dec(k);
  if k<1 then k:=4;
end;//求旋钮状态的前继
begin
  for i:=1 to n do readln(c[i],a[i,1],a[i,2],a[i,3],a[i,4]);//读入
  ans:=0;
  k:=get;//储存最开始的状态
  getway[k]:=1;//标记该状态出现在bfs队列的哪个下标中
  l:=1; r:=1; bfs[1]:=k;//bfs初始化,bfs数组中储存的是转化完的10进制数
  while l<=r do
  begin
    if (sum[l]=9) then break;//到第9步了就退出
    chai(bfs[l]);//将10进制的数重新拆成12位4进制数
    for j:=1 to 12 do
      c[j]:=b[j];//放到c数组里，方便后面操作
    for i:=1 to 12 do
    begin
      next(c[a[i,c[i]]]);//先处理自己引起的旋转
      next(c[i]);//再处理自己的旋转
      //注意顺序不能换
      k:=get;
      if (getway[k]=0) and (sum[l]<9) then/
      /如果没有到达过(用来去重，保存最先搜到的最优解)并且没有到步数上限
      begin
        inc(r);//尾指针加1
        bfs[r]:=k;
        change[r]:=i;
        sum[r]:=sum[l]+1;
        last[r]:=l;
        getway[k]:=r;//新的状态入队
      end;
      if getway[ans]<>0 then
      //ans就是所谓的目标状态，就是全是1，对应在10进制中表示就是0，所以把ans换成0也是可以的
      begin
       writeln(sum[getway[ans]]);//输出最少的步数
       printf(getway[ans]);//打印方案
       halt;
      end;
      lass(c[i]);//退回到初始状态，顺序也不能动
      lass(c[a[i,c[i]]]);
    end;
    inc(l);
  end;
  //以下代码其实和上面同理，只是换了一下初始状态，相似的内容就不注释了
  l:=1; r:=1; bfs1[1]:=0;
  while l<=r do
  begin
    if (sum1[l]=9) then break;
    chai(bfs1[l]);
    for j:=1 to 12 do
      c[j]:=b[j];
    for i:=1 to 12 do
    begin
      lass(c[i]);
      lass(c[a[i,c[i]]]);//注意是反向搜索，所以使用前继
      k:=get;
      if (getway1[k]=0) and (sum1[l]<9) then
      begin
        inc(r);
        bfs1[r]:=k;
        change1[r]:=i;
        sum1[r]:=sum1[l]+1;
        last1[r]:=l;
        getway1[k]:=r;
        if (getway[k]<>0) then//如果和正向搜索搜到了相同的结果，说明找到了方案
        begin
          writeln(sum[getway[k]]+sum1[getway1[k]]);//步数是两个方向搜索的步数总和
          printf(getway[k]);//打印正向搜索的过程
          printf1(getway1[k]);//打印反向搜索的过程
          halt;
        end;
      end;
      next(c[a[i,c[i]]]);
      next(c[i]);
    end;
    inc(l);
  end;
end.
```
### $C++$ $AC$ $Code$
作者是一个正在转$C++$的$P$党，就不献丑了
~~（其实是懒得打）~~
，我会在$Pascal$的$AC$ $Code$的里把注释写的尽可能详细，方便大家理解，力争让$C/C++$党都看懂
~~（其实应该不写注释也能看懂吧）~~

如果一定想要看$C++$的$AC$ $Code$，请到后记中研究一下[我的天空](https://www.luogu.org/space/show?uid=94712)这位巨佬的代码

最后提供一下$Check$，方便调试
## $Check$
$Check$说明：
读入机关的状态后再读入变化步数和依次旋转的旋钮编号，最后会输出各个机关的状态

有了说明就不在代码里写注释了，相信都能看懂的
### 示例　
$Input$
```
3 3 7 2 6
3 1 4 5 3
3 1 2 6 4
3 1 10 3 5
3 2 8 3 6
3 7 9 2 1
1 1 2 3 4
1 3 11 10 12
1 8 6 7 4
1 9 9 8 8
1 12 10 12 12
1 7 8 9 10
6
1 2 3 4 5 6
```
$Output$
```
1 1 1 1 1 1 1 1 1 1 1 1
```

### $Pascal$ $Check$
```pascal
const n=12;
var
  i,x,step:longint;
  s:array[0..13] of longint;
  a:array[0..13,0..10] of longint;
procedure next(var k:longint);
begin
  inc(k);
  if k>4 then k:=1;
end;
begin
  for i:=1 to n do readln(s[i],a[i,1],a[i,2],a[i,3],a[i,4]);
  readln(step);
  for i:=1 to step do
  begin
    read(x);
    next(s[a[x,s[x]]]);
    next(s[x]);
  end;
  for i:=1 to n do write(s[i],' ');
  writeln;
end.

```
### $C++$ $Check$
```cpp
#include<bits/stdc++.h>
using namespace std;
const int n=12;
int i,x,step,s[10],a[13][10];
void nxt(int &k)
{
	k++;
	if (k>4) k=1;
}
int main()
{
	for (i=1;i<=n;i++) 
	cin>>s[i]>>a[i][1]>>a[i][2]>>a[i][3]>>a[i][4];
	cin>>step;
	for (i=1;i<=step;i++)
	{
		cin>>x;
		nxt(s[a[x][s[x]]]);
		nxt(s[x]);
	}
	for (i=1;i<=n;i++) cout<<s[i]<<' ';
	cout<<endl;
}
```

# 总结
这道题比较经典，对搜索的优化考察比较丰富（包括状态记录，启发式搜索或双向搜索），需要思路和一定的代码实现能力，适合提高选手练练手。

思维难度：中

代码难度：中
# 后记
翻了一下$AC$的提交记录，发现 [我的天空](https://www.luogu.org/space/show?uid=94712) 巨佬和我的思路相近，但他的代码跑得比我快很多，最慢的点也只接近400$ms$，有兴趣的同学可以研究一下这位[巨佬的代码](https://www.luogu.org/record/22702524)，或者和这位巨佬交流。
# 鸣谢
[ i_m_a_](https://www.luogu.org/space/show?uid=86649)
这位出题人在我遇上困难时无私地帮助了我（提供了一个数据），使得我找到了原来代码的问题，特此感谢

---

## 作者：ailanxier (赞：41)

## 题意简述

&emsp;&emsp;有12个旋钮，每个旋钮开始时处于状态 $1$ ~ $4$ ，每次操作可以往规定方向转动一个旋钮 （$1\Rightarrow2\Rightarrow3\Rightarrow4\Rightarrow1$） ，并且会触发**一次**连锁反应：处于某个状态的旋钮在旋转时会引起另一个旋钮发生相同方向的转动（另一个旋钮转动不会再触发连锁反应）。问将12个旋钮都置为 $1$ 至少需要几次转动，并输出每次转动的旋钮编号。

## 单向BFS

&emsp;&emsp;直接暴力地进行单向 BFS ，每次转动都有 $12$ 种选择，时间复杂度是 $O(12^{step})$ ，看数据范围，最高的步数可达 $17$ 步，必定 TLE 。但是这样简单如果优化的比较好可以得 $50$ ~ $60$ 分（~~没吸氧气，吸了氧气反而更低了~~）。

&emsp;&emsp;[单向BFS评测记录](https://www.luogu.com.cn/record/36973116)

&emsp;&emsp;超时的主要原因是搜索树过于庞大，而我们会发现本题**起始状态和终止状态是明确的**，这时我们就可以使用神奇的双向 BFS 来限制搜索树的生长。

## 双向BFS

&emsp;&emsp;双向 BFS 非常适合在起始状态和终止状态明确的条件下使用，做法是从起点和终点同时进行单向 BFS ，让两边 BFS 搜索树的生长受到对面搜索树的限制，不要过于野蛮生长，偏离目标太远。自己画了一张~~很丑很丑的~~对比图(如果图裂开了，[可以到我博客去看](https://www.cnblogs.com/ailanxier/p/13501529.html))，应该可以便于理解。

![](https://cdn.luogu.com.cn/upload/image_hosting/7gjlwjuc.png)

&emsp;&emsp;可以看到双向 BFS 可以在**某一状态发现相同时就停止**了，通过回溯可以找到沿路选择的点。再看看本题的数据范围，最大的点正向和反向 BFS 最多是 $9$ 步, $12^9$ 是 $5\times10^8$ 的量级,勉强可以在一秒冲过去。事实上我最大的点用时在 $200ms$ ~ $300ms$ 之间，还是很稳的。

&emsp;&emsp;[最好的一次双向BFS记录](https://www.luogu.com.cn/record/36981792)

### 状态存储

&emsp;&emsp;可以把两个二进制位当做一个四进制位,把每个旋钮状态减一后就刚好可以存下了，即1对应0,2对应1，以此类推。先讲一下读入处理。
```cpp
    int button,Start = 0;
    For(i,0,11){
        button = read();                        //读入第i+1个旋钮状态
        Start |= (button - 1) << (i << 1);      //记录初始状态
        For(j,0,3) nxt[i][j] = read()-1;          
    }
```
&emsp;&emsp;我代码中的旋钮编号和状态全部进行了减一处理（后面描述时我都会说+1），方便位运算操作。注意**记录初始状态时要将 $i*2$** （即左移一位），因为我们把两个二进制位当做一个四进制位了，后面也有这样的乘2处理。再用一个数组 $nxt$ 记录第 $i+1$ 个旋钮在 $j+1$ 状态下进行旋转时，会带动第 $nxt[i][j]+1$ 个旋钮转动。 

### 状态转移
&emsp;&emsp;首先正向和反向的 BFS 的转移方式是不一样的。设当前转到的是第 $i+1$ 个旋钮，它现在处于 $j+1$ 状态。
+ 正向：将第 $i+1$ 个旋钮按规定方向转动一次，同时带动第 $nxt[i][j]+1$ 个旋钮转动。**旋转后状态可以用$(j+1)\&3$ 表示**（这样可以实现旋钮位于4状态，即 $j=3$ 时，旋转后变成1 ，即 $j = 0$ 的操作）。
+ 反向：将第 $i+1$ 个旋钮按规定的相反方向转动一次，如果其转动后的状态为 $k+1$ ,则带动第 $nxt[i][k]+1$ 个旋钮也以相反方向转动。**逆向旋转后状态可以用$(j+3)\&3$ 表示**。

&emsp;&emsp;我们把正向方向定义为1，反向方向定义为2，当前方向为 $direction$ ，当前所有按钮状态为 $state$ ,有：
```cpp
int si,sNext,nx,nextState;
For(i,0,11) {
    if (direction == 1) {  //正向
        si = (state >> (i << 1)) & 3;   //1、获取第i+1个旋钮状态（0~3）
        nx = nxt[i][si];                       //2、获取牵连旋钮编号
        sNext = (state >> (nx << 1)) & 3;      //3、获取牵连旋钮状态，方式同1
        nextState = state ^ (si << (i << 1)) ^ (((si + 1) & 3) << (i << 1)); //4、修改状态为第i+1个旋钮旋转后的状态
        nextState ^= (sNext << (nx << 1)) ^ (((sNext + 1) & 3) << (nx << 1)); //5、修改状态为牵连旋钮旋转后的状态
    } else {                      //反向
        si = (state >> (i << 1)) & 3;
        nx = nxt[i][(si + 3) & 3];         //获取第i+1个旋钮逆向旋转后的牵连旋钮编号
        sNext = (state >> (nx << 1)) & 3;
        nextState = state ^ (si << (i << 1)) ^ (((si + 3) & 3) << (i << 1)); //修改状态为第i+1个旋钮逆向旋转后的状态
        nextState ^= (sNext << (nx << 1)) ^ (((sNext + 3) & 3) << (nx << 1));//修改状态为牵连旋钮逆向旋转后的状态
    }
}
```
### $Code:$
```cpp
#include <bits/stdc++.h>
using namespace std;
#define For(i,sta,en) for(int i = sta;i <= en;i++)
inline int read(){
    int sum = 0,fu = 1;char ch = getchar();
    while(!isdigit(ch)) { if(ch == '-') fu = -1;ch = getchar();}
    while(isdigit(ch)) { sum = (sum<<1)+(sum<<3)+(ch^48);ch =getchar();} return sum * fu;
}
const int N = 1<<24;
bool vis[N];
int nxt[14][6],fa[N],choice[N],v[N],flag,m1,m2,mid,ans1[30],ans2[30];
queue<int>q;
int main(){
    int button,Start = 0;
    For(i,0,11){
        button = read();                             //读入第i+1个旋钮状态
        Start |= (button - 1) << (i << 1);      //记录初始状态
        For(j,0,3) nxt[i][j] = read()-1;
    }
    vis[Start] = vis[0] = 1; //是否访问过
    v[Start] = 1;   v[0] = 2;     //区分方向
    q.push(Start);
    q.push(0);
    while(!q.empty() && !flag){
        int state = q.front(),direction = v[state];
        q.pop();
        int si,sNext,nx,nextState;
        For(i,0,11){
            if(direction == 1){  //正向
                si = (state >> (i << 1))&3;   //1、获取第i+1个旋钮状态（0~3）
                nx = nxt[i][si];                       //2、获取牵连旋钮编号
                sNext = (state >> (nx << 1)) & 3;      //3、获取牵连旋钮状态，方式同1
                nextState = state ^ (si << (i << 1)) ^ (((si + 1) & 3) << (i << 1)); //4、修改状态为第i+1个旋钮旋转后的状态
                nextState ^= (sNext << (nx << 1)) ^ (((sNext + 1) & 3) << (nx << 1)); //5、修改状态为牵连旋钮旋转后的状态
            } else{                      //反向
                si = (state >> (i << 1))&3;
                nx = nxt[i][(si+3)&3];         //获取第i+1个旋钮逆向旋转后的牵连旋钮编号
                sNext = (state >> (nx << 1)) & 3;
                nextState = state ^ (si << (i << 1)) ^ (((si + 3) & 3) << (i << 1)); //修改状态为第i+1个旋钮逆向旋转后的状态
                nextState ^= (sNext << (nx << 1)) ^ (((sNext + 3) & 3) << (nx << 1));//修改状态为牵连旋钮逆向旋转后的状态
            }
            //如果这个状态在之前访问过
            if(vis[nextState]){
                if(v[nextState] == direction) continue;  //同方向的直接跳过，之前到达的时候肯定不劣于现在
                /*
                 * 不同方向说明已经找到答案了
                 *  m1 记录正向与逆向的连接点
                 *  m2 记录逆向与正向的连接点
                 *  mid 记录从state状态转移到nextState状态选择的旋钮编号
                 */
                m1 = direction == 1 ? state : nextState;
                mid = i+1;
                m2 = direction == 1 ? nextState : state;
                flag = 1;break;
            }
            vis[nextState] = 1;
            v[nextState] = direction; //继承方向
            fa[nextState] = state;          //用于回溯操作
            choice[nextState] = i + 1;   //记录本次操作
            q.push(nextState);
        }
    }
    int cnt1 = 0,state = m1,cnt2 = 0;
    //正向回溯
    while(state != Start){
        ans1[++cnt1] = choice[state];
        state = fa[state];
    }
    //逆向回溯
    state = m2;
    while(state != 0){
        ans2[++cnt2] = choice[state];
        state = fa[state];
    }
    //总步数，还要加上中间那一步mid操作
    printf("%d\n",cnt1+cnt2+1);
    for(int i = cnt1; i; i--) printf("%d ", ans1[i]);
    printf("%d ",mid);
    For(i,1,cnt2) printf("%d ", ans2[i]);
    return 0;
}
```

## 启发式搜索

&emsp;&emsp;双向 BFS 已经够快了，但是我们可以使用更快的启发式搜索。常用的启发式搜索有 IDA* 和 A* ，听说前者被卡了，我们就用 A* 吧。这里先介绍这个算法的实现，然后给出正确性证明。

&emsp;&emsp;在 A* 算法中，我们要利用当前状态的信息对状态进行评价，以此来决定下一次的操作，极大地限制了搜索树的生长。这里用函数 $F^*$ 来表示 $x$ 状态的代价：**$F^*(x)= g(x)+h^*(x)$** 。其中 $g (x)$ 表示**从初始状态到当前状态所付出的最小代价**（在本题中意义为操作步数），而 $h^*(x)$ **是从当前状态到目标状态走最佳路径所付出的代价**。在实际代码中我们使用的其实是 $F(x)=g (x)+h(x)$ ，因为我们实际上是不知道这个 $h^*(x)$ 的，但是我们可以用 $h(x)$ 去估计它，要保证 $h(x)$ 是 $h^*(x)$ 的下界，即对任意状态均有 $h(x)≤h^*(x)$ ，这个估计才能保证搜索正确性。

&emsp;&emsp;在代码中我们用以下方式估计 $h^*(x)$ ： $12$ 个旋钮在**不考虑牵连时都转到 $1$ 要多少步，再除以 $2$** ,这样就可以保证得到的 $h(x)$ 肯定会比实际要转的次数 $h^*(x)$ 要少（一次操作恰好就可以让两个旋钮都向目标状态转一次，而实际上可能会让某个旋钮转过目标状态，从而要转更多次数）。

&emsp;&emsp; $h(x)$ 是一个比较玄学的东东，没有唯一的定义，不同的定义可能会导致程序执行效率和结果不同，这题中你还可以乘一个系数给他，能明显加快运行效率。经过笔者多次测试，发现给 $h$ 乘上系数从 $1.1$ ~ $2.3$ 都能 AC 这道题，但是乘 $2.4$ 时会 WA 掉一个点。变化趋势是这个系数越大，跑得越快，最大的点可以跑进 $100ms$ 。这是因为系数越大越接近真实值 $h^*(x)$，但是更大的系数不能保证  $h(x)≤h^*(x)$。

&emsp;&emsp;代码实现类似 Dijkstra 算法，定义一个结构体存状态和这个状态对应的估价函数值 $F$ 。每次从小根堆中取出 $F$ 最小的状态进行转移，存状态和转移状态的操作和上面双向 BFS 相同，这里直接给出代码，证明放后面。

$Code:$

```cpp
#include <bits/stdc++.h>
using namespace std;
#define For(a,sta,en) for(int a = sta;a <= en;a++)
inline int read(){
    int sum = 0,fu = 1;char ch = getchar();
    while(!isdigit(ch)) { if(ch == '-') fu = -1;ch = getchar();}
    while(isdigit(ch)) { sum = (sum<<1)+(sum<<3)+(ch^48);ch =getchar();} return sum * fu;
}
const int N = 1<<24;
int g[N],nxt[14][6],fa[N],ans[30],choice[N];
struct node{
    int state;   //状态
    double F;  //状态对应估价函数值
    node(int s):state(s){  //构造函数，冒号后面部分相当于 state = s;
        double h = 0;
        F = 0;
        For(i,0,11) if((s>>(i<<1))&3) h += 4 - ((s >> (i << 1)) & 3); //计算不处在状态1的旋钮的对应的h值
        F =  h * 1.2 + g[s];   //可以在h/2前乘一个玄学系数
    }
    bool operator<(const node &y) const{
        return F > y.F;  //估价函数值小的放前面
    }
};
priority_queue<node>q;

int main(){
    int button,Start = 0;
    For(i,0,11){
        button = read();                             //读入第i+1个旋钮状态
        Start |= (button - 1) << (i << 1);      //记录初始状态
        For(j,0,3) nxt[i][j] = read()-1;
    }
    q.push(node(Start));  //调用构造函数，顺便计算出估价函数值
    g[Start] = 0;
    while(!q.empty()){
        int state = q.top().state;
        q.pop();
        if(state == 0) break;
        int si,sNxt,nx,nextState;
        For(i,0,11){
            si = (state>>(i<<1))&3;
            nx = nxt[i][si];
            sNxt = (state>>(nx<<1))&3;
            nextState = state ^ (si << (i << 1)) ^ (((si + 1) & 3) << (i << 1)) ^ (sNxt << (nx << 1)) ^ (((sNxt + 1) & 3) << (nx << 1));
            //如果没有访问过就可以转移新状态了
            if(!g[nextState]){
                g[nextState] = g[state] + 1;
                fa[nextState] = state;      //用于回溯
                choice[nextState] = i + 1;
                q.push(node(nextState));
            }
        }
    }
    int cnt = 0,state = 0;
    while(state != Start){
        ans[++cnt] = choice[state];
        state = fa[state];
    }
    printf("%d\n",cnt);
    for(int i = cnt;i;i--) printf("%d ",ans[i]);
    return 0;
}
```

&emsp;&emsp;证明正确性，只需证明 A* 在选择到目标节点 $t$ 时（即在优先队列 $top$ 时）,目标节点的最优解已找到。

&emsp;&emsp;令 $x$ 为任意扩展到的节点（优先队列中的元素），有 $F(t)\le F(x)$ 。

+ 由于 $h(x)\le h^*(x)$ ,所以 $F(t)\le F(x) \le F^*(x)$ 。
+ 根据 $F^*$ 的定义，${F^*(x)}$ 中必存在一个值为到目标节点的最优解，记为 $F^*(s)$ ，仍有 $F(t)\le F^*(s)$。 
+ 因为 $t$ 为目标节点，所以 $h(t) = 0 ,F(t)=g(t)+h(t)=g(t)\le F^*(s)$
+ $F(t)=g(t)$ 是一个可行解，必有 $g(t)\ge F^*(s)$ 
+ 故 $F(t)=g(t)=F^*(s)$ , 即 $F(t)$ 为最优解，证毕。



&emsp;&emsp;做完这道题建议去做一下 [P1379 八数码难题](https://www.luogu.com.cn/problem/P1379) ,可以同时用单向 BFS ，双向 BFS ，A* 和 IDA* 做这道题，如果每个方法都写一下一定受益良多。

---

## 作者：NKU_AI_HMX (赞：32)

### 启发式搜索，不一样的启发函数（吸氧总170msAC）
#### 不擅长排版，经常不过审,,Ծ‸Ծ,,


### - 帮萌新理解启发搜索的含义
相信来写这道题的dl们肯定都很熟悉搜索，dfs，bfs。一个一搜到底，一个一
层层搜过去。但无疑这两种搜索方式都是地毯式搜索，不管长啥样都搜，这样
就会带来一些问题，数据很大的时候这样搜就会面临爆时间和内存的问题，所
以我们搜索的时候应该有一些判断标准，稍微带一点智力地搜，不能一股脑的
随意搜。
	
其实这就像我们找东西，家里落了一个东西，不知道在哪，我们又不记得上
次放哪了。我们就要找它，我们一定不会先把床移开，看看是不是在床下，
或者首先到你家布满灰尘的储物间去找。我们会先找那些更可能的地方，比
如桌子上？书下面？等等。而你之所以做出这样的选择就是基于我们自己的
判断函数，只不过这个判断函数不单单和可能性相关，但可能性一定是我们
判断的重要因素。
	
说了那么多我们可以开始这道题了，本题同其他dl说的用双向bfs可以过，但
是还是慢了点，笔者这里用的启发式搜索。但是笔者初学启发式搜索，不知
道为什么启发函数一定要写成f[n] = g[n] + d[n]，g[n] 是实际花费，
d[n] 是预估花费，所以笔者尝试了其他形式的函数，发现效果不错，但是由
于测试数据的限制，或许会有某些数据求不出最优解，还望指正。下方列出
了笔者使用的启发函数。
        
```cpp
f=length*step+length+step
```


### - 启发函数解释	
length是理想距离（就是每个按钮转动到理想状态的总转动次数之和，比如1 
2 3 4，转动到1 1 1 1，就是0+3+2+1=6，理论上是要除2的因为转动一个按
钮会影响两个，但这里好像不除2更快），step是现在已经走的步数。这个启
发函数相比于其他题解的函数多加了一个乘积项，大家可以自行调整各个系
数，但是可能会导致不是最优解或者超时，length的系数更大，更趋向于贪
心，step的更大，更趋向于广搜。



### - 代码如下


```cpp

#include<bits/stdc++.h>
using namespace std;
int a[12][4]; bool vis[16800000];  int be[12];
void Move(int* m, int move)
{
    if (m[a[move][m[move]]] != 3)
        m[a[move][m[move]]]++;
    else m[a[move][m[move]]] = 0;
    if (m[move] != 3)m[move]++;
    else m[move] = 0;

}
int Count(int* m)
{
    int sum = 0;
    for (int i = 0; i < 12; i++)
    {
        sum = (sum << 2) + m[i];
    }
    return sum;
}
struct node
{
    int count;
    int m[12];
    int l; 
        vector<int>re;
    node() {};
    node(int* a, node* other, int count1, int move);
    node(int* a, int count1);
    bool operator<(node other)const
    {
        return (1 + l) * (re.size() + 1) > (1 + other.re.size())* (other.l + 1);
    }
}x;
int count2(node* now)
{
    int t = 0;
    for (int i = 0; i < 12; i++)
    {
        if (now->m[i])
            t += 4 - now->m[i];
    }
    return t;
}
node::node(int* a, node* other, int count1, int move)
    {
        memcpy(m, a, sizeof(m));
        count = count1;
        re = other->re;
        re.push_back(move);
        vis[count] = 1;
        l = count2(this);
    };
node::node(int* a, int count1)
{
    memcpy(m, a, sizeof(m));
    count = count1;
    vis[count] = 1;
    l = count2(this);
};
void A()
{
    priority_queue<node>q;
    q.push(node(be, Count(be)));
    node temp;  int count, count1, temp1[12];
    while (!q.empty())
    {
        temp = q.top();  count = temp.count;
        q.pop();
        for (int i = 0; i < 12; i++)
        {
            memcpy(temp1, temp.m, sizeof(temp1));
            Move(temp1, i);
            count1 = Count(temp1);
            if (!vis[count1])
            {
                node temp2(temp1, &temp, count1, i); q.push(temp2);
                if (vis[0]) { x = temp2; return; }

            }
        }
    }
}
int main()
{
    for (int i = 0; i < 12; i++)
    {
        cin >> be[i]; be[i]--;
        for (int j = 0; j < 4; j++)
        {
            cin >> a[i][j]; a[i][j]--;
        }
    }
    A();
    cout << x.re.size() << endl;
    for (int i = 0; i < x.re.size(); i++)
    {
        cout << x.re[i] + 1 << " ";
    }
    return 0;
}

```
### - 具体代码解释可以去作者博客看看。


大家可以去做一做[八数码难题](https://www.luogu.com.cn/problem/P1379)

更可以这篇题解点一个赞。关注一下作者。


---

## 作者：伟大的王夫子 (赞：15)

先安利一下[我的博客](https://www.luogu.org/blog/I-AK-IOI/)

一看到这题，就想到启发式搜索

先考虑IDA_star

因为一个节点若不为1，那么要改对成1也要5-a[i]次

a[i]为第i个节点的数字

一次最多改两个，所以把这些都加上去后还要/2向上取整

```cpp
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#include<bits/stdc++.h>
using namespace std;
template<class item>
inline item read() {
	item res = 0;
	bool negative = 0;
	char ch = getchar();
	while (!isdigit(ch)) negative |= ch == '-', ch = getchar();
	while (isdigit(ch)) res = (res << 3) + (res << 1) + (ch ^ 48), ch = getchar();
	return negative ? -res : res;
}
template<class item>
inline item read(item & t) {
	t = read<item>();
	return t;
}
#define max(a, b)  (!((a) < (b)) ? (a) : (b))
#define min(a, b)  ((a) < (b) ? (a) : (b))
template <typename T, typename... Args>
inline void read(T& t, Args&... args) {
	read(t), read(args...);
}
//快读，长了点
struct data {
	int a[20], step[20], len;
	int hash() {
		int res = 0;
		for (register int i = 1; i <= 12; ++i) res = (res << 2) + a[i];//hash
		return res;
	}
	bool check() {
		for (register int i = 1; i <= 12; ++i) if (a[i] != 1) return 0;
		return 1;
	}
	int hfunc() {
		int cnt = 0;
		for (register int i = 1; i <= 12; ++i) 
		    if (a[i] != 1) cnt += 5 - a[i];
      //估价函数
      //若不为1，要对上也要5-a[i]次
		return ((cnt - 1) >> 1) + 1;
	}
};
int a[20][5], s[20], depth = 4, minn;
int _next(int x) {
	return x < 4 ? x + 1 : 1;
}
data st;
bool vis[70000000];
const int b[11] = {4, 6, 8, 9, 10, 11, 12, 13, 15, 17};
void dfs(data now) {
	if (now.len + now.hfunc() > depth) {
		//minn = min(minn, now.len + now.hfunc());
		return;
	}
	if (now.check()) {
		printf("%d\n", now.len);
		for (register int i = 1; i <= now.len; ++i)
			printf("%d ", now.step[i]);
		//printf("%.3lf", ss);
		exit(0);
	}
	for (register int i = 1; i <= 12; ++i) {
		data next = now;
		next.a[i] = _next(next.a[i]);
		next.step[++next.len] = i;
		next.a[a[i][now.a[i]]] = _next(next.a[a[i][now.a[i]]]);
		int val = next.hash();
		if (vis[val]) continue;
		vis[val] = 1;
		//q.push(next);
		dfs(next);
		vis[val] = 0;
	}
}
int main() {
	for (register int i = 1; i <= 12; ++i) {
		read(s[i], a[i][1], a[i][2], a[i][3], a[i][4]);
		st.a[i] = s[i];
	}
	vis[st.hash()] = 1;//其实不用的
	//q.push(st);
	for (register int i = 1; i <= 10; ++i) {
		depth = b[i];
		dfs(st);
	}
}
```
IDA_star被卡了，怎么办？

我们还有

# A_star!

```cpp
// luogu-judger-enable-o2
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#include<bits/stdc++.h>
using namespace std;
template<class item>
inline item read() {
	item res = 0;
	bool negative = 0;
	char ch = getchar();
	while (!isdigit(ch)) negative |= ch == '-', ch = getchar();
	while (isdigit(ch)) res = (res << 3) + (res << 1) + (ch ^ 48), ch = getchar();
	return negative ? -res : res;
}
template<class item>
inline item read(item & t) {
	t = read<item>();
	return t;
}
#define max(a, b)  (!((a) < (b)) ? (a) : (b))
#define min(a, b)  ((a) < (b) ? (a) : (b))
template <typename T, typename... Args>
inline void read(T& t, Args&... args) {
	read(t), read(args...);
}
//快读，长了点
struct data {
	int a[20], step[20], len, y;
	int hash() {
		int res = 0;
		for (register int i = 1; i <= 12; ++i) res = (res << 2) + a[i];//hash判重
		return res;
	}
	bool check() {
		for (register int i = 1; i <= 12; ++i) if (a[i] != 1) return 0;
		return 1;
      //搜索是否成功
	}
	int hfunc() {
		int cnt = 0;
		for (register int i = 1; i <= 12; ++i) 
		    if (a[i] != 1) cnt += 5 - a[i];
		return ((cnt - 1) >> 1) + 1;
      //估价函数
      //若不为1，要对上也要5-a[i]次
      
	}
	bool operator < (const data &a) const {
		return len + y > a.len + a.y;
	}
    //重载小于号
};
int a[20][5];
std::priority_queue<data> q;//优先队列
int _next(int x) {
	return x < 4 ? x + 1 : 1;
}
data st;
bool vis[70000000];
int main() {
	for (register int i = 1; i <= 12; ++i) {
		read(st.a[i], a[i][1], a[i][2], a[i][3], a[i][4]);
	}
	vis[st.hash()] = 1;//广搜
	st.y = st.hfunc();
	q.push(st);
	while (q.size()) {
		data now = q.top();//当前步数+估价最小的
		q.pop();
		if (now.y == 0) {
			printf("%d\n", now.len);
			for (register int i = 1; i <= now.len; ++i)
				printf("%d ", now.step[i]);
			exit(0);
		}//搜到了，输出并推出
		for (register int i = 1; i <= 12; ++i) {
			data next = now;
			next.a[i] = _next(next.a[i]);
			next.step[++next.len] = i;
			next.a[a[i][now.a[i]]] = _next(next.a[a[i][now.a[i]]]);
			int val = next.hash();
			if (vis[val]) continue;
			vis[val] = 1;
			next.y = next.hfunc();
			q.push(next);
		}
      //枚举
	}
}
```
最后说一下，启发式搜索真的很快，一定要学会哦！


---

## 作者：Hope2075 (赞：10)

~~这题就是一个暴力~~

正解：搜索

得分取决于搜索的效率

### 最简单的方法：BFS

每个状态枚举12个位置，然后求出改变后的状态，入队

这样，只要到达了最终状态，就求出了步数

但这样效率很低

期望得分：10分或20分

### 优化：去除重复的状态

发现状态总数并不多，只有$2^{24}$种，而且空间也很充足

所以用一个数组记录某个状态是否已经搜过，如果搜过，就不入队

这样效率会高一些

而且，如果被卡满，那么约5s一定能求出解（这就是步数并不太多而且时限比较小的原因）

期望得分取决于常数，大概在20-80分之间，如果卡常技术好也能AC

这个也可以用双向BFS来进一步优化

### 另一个方法：启发式搜索

启发式搜索会优先搜更可能是最优解的状态，可以更快达到最优解

估价函数：每个位置距离目标状态的差值之和除以2

也就是，如果每次可以任意选择两个旋钮并改变状态，那么最少的步数是多少

这样，在数据强度中等的情况下，就可以明显提高效率

期望得分：100分

~~总之，做法很多~~

代码：

BFS(40分)

```cpp
#include<iostream>
#include<ctime>
using namespace std;
int st,mdf[12][4];
int que[1<<24],dp[1<<24],fr[1<<24],opt[1<<24],he,ta;
int t,nxt;
int p1,s;
void bit(int n){
	for(int i=0;i<12;i++){
		cout<<((n&(3<<(i*2)))>>(i*2));
	}
}
inline int nx(int st,int p){
	int t=((st&(3<<(p*2)))>>(p*2));
	st=(st^(t<<(p*2)));
	t++;
	t&=3;
	st=(st^(t<<(p*2)));
	return st;
}
int sol[1<<24],c;
int main(){
	for(int i=0;i<12;i++){
		cin>>t;
		t--;
		st|=(t<<(i*2));
		for(int j=0;j<4;j++){
			cin>>t;
			t--;
			mdf[i][j]=t;
		}
	}
	s=st;
	dp[st]=1;
	que[he++]=st;
	while(he!=ta){
		st=que[ta++];
		if(st==0)break;
		for(int i=0;i<12;i++){
			t=((st&(3<<(i*2)))>>(i*2));
			p1=nx(st,i);
			nxt=nx(p1,mdf[i][t]);
			if(!dp[nxt]){
				dp[nxt]=1;
				fr[nxt]=st;
				opt[nxt]=i;
				que[he++]=nxt;
			}
		}
	}
	if(dp[0]){
		for(int i=0;i!=s;i=fr[i]){
			sol[c++]=opt[i]+1;
		}
		cout<<c<<endl;
		for(int i=c-1;i>=0;i--)cout<<sol[i]<<" ";
	}else{
		cout<<"0"<<endl;
	}
}
```
启发式搜索(100分)

为了提高效率，用的手写堆
```cpp
#include<iostream>
#include<cstdio>
long long read(){
	long long n=0;char c=getchar();bool f=0;
	while(c!='-'&&(c<'0'||c>'9'))c=getchar();
	if(c=='-'){f=1;c=getchar();}
	while(c>='0'&&c<='9'){n=n*10+c-'0';c=getchar();}
	if(f)return -n;
	else return n;
}
char res[25];
void write(long long n){
	if(n==0){putchar('0');return;}
	if(n<0){putchar('-');n=-n;}
	int t=0;
	while(n){res[t++]=n%10+'0';n/=10;}
	while(t--)putchar(res[t]);
}
const int l[]={0,3,2,1};
int dis1[1<<12];
void pre(){
    for(int i=0;i<1<<12;i++){
        int ans=0,t;
        for(int j=0;j<6;j++){
            t=((i&(3<<(j*2)))>>(j*2));
            t=-t;
            if(t<0)t+=4;
            ans+=t;
        }
        dis1[i]=ans;
    }
}
struct game{
    int st,move;
    int used;
    game(int s,int u){
        st=s;
        used=u*2;
        move=dis1[s>>12]+dis1[s&0xfff];
    }
    game(){}
};
void swap(game &a,game &b){
	game t=a;a=b;b=t;
}
bool operator>(const game &a,const game &b){
    if(a.move+a.used==b.move+b.used)return a.move>b.move;
    return a.move+a.used>b.move+b.used;
}
bool operator<(const game &a,const game &b){
    if(a.move+a.used==b.move+b.used)return a.move<b.move;
    return a.move+a.used<b.move+b.used;
}
//也可以用std::priority_queue代替，除了慢点，基本没区别
game heap[1<<24];int size;
void pop(){
	heap[1]=heap[size];
	size--;
	int cur=1;
	while(1){
		if((cur<<1)>size)break;
		if(((cur<<1)|1)>size){
			if(heap[cur]>heap[cur<<1])swap(heap[cur],heap[cur<<1]);
			break;
		}
		if(heap[(cur<<1)|1]>heap[cur<<1]){
			if(heap[cur]>heap[cur<<1]){
				swap(heap[cur],heap[cur<<1]);
				cur=(cur<<1);
			}else break;
		}else{
			if(heap[cur]>heap[(cur<<1)|1]){
				swap(heap[cur],heap[(cur<<1)|1]);
				cur=((cur<<1)|1);
			}else break;
		}
	}
}
void push(game num){
	heap[++size]=num;
	int cur=size;
	while(cur!=1){
		if(heap[cur]<heap[cur>>1]){
			swap(heap[cur],heap[cur>>1]);
			cur=(cur>>1);
		}else{
			break;
		}
	}
}
game top(){return heap[1];}

int dp[1<<24],fr[1<<24],opt[1<<24];
inline int nx(int st,int p){
    int t=((st&(3<<(p*2)))>>(p*2));
    st=(st^(t<<(p*2)));
    t++;
    t&=3;
    st=(st^(t<<(p*2)));
    return st;
}
int mdf[12][4];
int t,stage,s,nxt;
int sol[1<<24],c;
int main(){
	pre();
    for(int i=0;i<12;i++){
        t=read();
        t--;
        stage|=(t<<(i*2));
        for(int j=0;j<4;j++){
            t=read();
            t--;
            mdf[i][j]=t;
        }
    }
    s=stage;
    dp[stage]=1;
    game p=game(stage,1);
    if(p.move%2){
        write(0);
        return 0;
    }
    push(p);
    while(size){
        p=top();
        pop();
        if(p.st==0)break;
        if(p.used!=dp[p.st]*2)continue;
        for(int i=0;i<12;i++){
            t=((p.st&(3<<(i*2)))>>(i*2));
            nxt=nx(nx(p.st,i),mdf[i][t]);
            if(!dp[nxt]||dp[nxt]>dp[p.st]+1){
                dp[nxt]=dp[p.st]+1;
                fr[nxt]=p.st;
                opt[nxt]=i;
                push(game(nxt,dp[nxt]));
            }
        }
    }
    if(dp[0]){
        for(int i=0;i!=s;i=fr[i]){
            sol[c++]=opt[i]+1;
        }
        write(c);putchar('\n');
        for(int i=c-1;i>=0;i--){write(sol[i]);putchar(' ');}
    }else{
        write(0);putchar('\n');
    }
}
```



---

## 作者：Thinking (赞：9)

~~不会写双向BFS的，死也不会写的~~

考虑$IDA*$。一个很naive的h函数是：每个按钮到目标的距离的最大值。于是你花20min就可以拿到40分：

```cpp
#include<cstdio>
short s[15],a[15][5],maxd=0,opt[20];
inline bool check(){
	for(short i=1;i<=12;++i)if(s[i]!=1)return 0;
	return 1;
}
inline short h(){
	short i,maxn=0;
	for(i=1;i<=12;++i)if(s[i]!=1&&5-s[i]>maxn)maxn=5-s[i];
	return maxn;
}
bool dfs(int d){
	if(d+h()>maxd)return 0;
	if(check())return 1;
	short i,t1,t2,p;
	for(i=1;i<=12;++i){
		t1=s[i];p=a[i][s[i]];t2=s[p];
		s[i]=(s[i]&3)+1;s[p]=(s[p]&3)+1;
		opt[d]=i;
		if(dfs(d+1))return 1;
		s[p]=t2;s[i]=t1;  //倒过来主要是为了p==i的情况
	}
	return 0;
}
int main(){
	short i,j;
	for(i=1;i<=12;++i){
		scanf("%d",s+i);
		for(j=1;j<=4;++j)scanf("%d",&a[i][j]);
	}
	for(maxd=0;maxd<18;++maxd)if(dfs(0))break;
	printf("%d\n",maxd);
	for(i=0;i<maxd;++i)printf("%d ",opt[i]);
	return 0;
}
```

然而，我们发现这个h函数相当不精确，因为每次最多修改两个按钮，稍加思考可以得到一个更精确的h：每个按钮到目标的距离的和的一半。事实证明这个下界相当紧，把上面代码中的h()换成如下代码即可获得80分：

```cpp
inline short h(){
	short i,sum=0;
	for(i=1;i<=12;++i)if(s[i]!=1)sum+=5-s[i];
	return sum>>1;
}
```
那么剩下20分怎么拿呢？ ~~BFS：真香！~~ 没关系，$IDA*$被卡了，我们还有$A*$！~~难写多了~~

```cpp
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
int pre[1<<24];
short a[15][5],d[1<<24],opt[1<<24],st[20],sl=-1;
struct node{
	int x;
	short g;  //g内保存的是A*中的f()与h()的和
	node(){}
	node(int x):x(x){
		g=0;
		for(short i=0;i<24;i+=2)if(x&(3<<i))g+=4-((x>>i)&3);
		g=(g>>1)+d[x];
	}
	inline bool operator <(const node &b)const{return g>b.g;}
};
priority_queue<node> Q;
inline short nxt(short x){return (x+1)&3;}
int main(){
	short i,j,s,t1,t2,p;
	int h,t=0;
	bool ok=0;
	for(i=0;i<12;++i){
		scanf("%d",&s);
		t|=s-1<<(i<<1);
		for(j=0;j<4;++j){scanf("%d",&a[i][j]);--a[i][j];}
	}
	memset(d,0x3f,sizeof(d));d[t]=0;
	Q.push(node(t));
	while(!Q.empty()&&!ok){
		h=Q.top().x;Q.pop();
		for(i=0;i<12;++i){
			t1=(h>>(i<<1))&3;p=a[i][t1];t=h^(t1<<(i<<1))^(nxt(t1)<<(i<<1));
			t2=(h>>(p<<1))&3;t^=(t2<<(p<<1))^(nxt(t2)<<(p<<1));
            //解码+产生新状态
			if(d[t]==0x3f3f){  //A*保证第一次碰到就是最优解
				d[t]=d[h]+1;
				pre[t]=h;
				opt[t]=i+1;
				if(!t){ok=1;break;}
				Q.push(node(t));
			}
		}
	}
	printf("%d\n",d[0]);
	while(pre[t]){
		st[++sl]=opt[t];
		t=pre[t];
	}
	while(sl>=0)printf("%d ",st[sl--]);
	return 0;
}
```

~~A*好像吊打BFS~~

---

## 作者：cszhpdx (赞：8)

[题目传送门：P5507 机关](https://www.luogu.com.cn/problem/P5507)

看了一遍题解之后发现大家的代码

## 都很长

我的思路呢其实也就是双向搜索，题解里也有一位 dalao 写了，但是位运算其实没有必要那么麻烦，没有必要把两个记录状态的数组合并，两个也不会超空间，时间还快一点，相当于用空间换时间

接下来是我的思路

## 状态压缩

首先是状态的存储问题，有 12 个旋钮，我发现基本上状态压缩有这几种：

1. 十进制存，一位一个旋钮，很明显 12 位不能用数组去判重，得用 $map$ ，又多了一个 $logn$ 的复杂度我也不知道这位兄弟怎么想出来的，很明显不行啊，而且还麻烦，不过应该还是能得 80 分
2. 字符串，一位一个旋钮，这个稍微还好一点，但是还是得用 $map$ ，或者其实可以字符串哈希，但是没有必要，用 $map$ 的话，启发式搜索能过，但是双向 $bfs$ 只能有 80 分
3. 四进制存，一位一个旋钮，四个状态 1234 对应 0123 ，这也是大家的主流的做法，我也是这么做的

这里就不写前两种的实现了，我们看下第三种各种操作的实现

读入：

```cpp
for(int i=1;i<=12;i++)
{
    scanf("%d", &t);
    b+=(t-1)<<(tmp<<1);//初始化状态
    //因为我们是倒着存的，所以就用tmp来记录现在是第几位
    //要是没看懂可以自己手推一下
    tmp++;
    for(int j=1;j<=4;j++)
        scanf("%d", p[i]+j);//存储哪些按钮会联动
}
```

给状态 $x$ 取出第 $w$ 位：

```cpp
(x>>((w-1)<<1))&3//3的二进制
```

把一位扭动一下（不处理联动）：

```cpp
inline void add(int &s, int w)
{//状态s的第w位
	int num=(s>>((w-1)<<1))&3;//取出状态
	s-=num*(1<<((w-1)<<1));//置成0
	num++;//如果是4说明应该转了一圈变成0，也就不用再改了
	if(num!=4)s+=num*(1<<((w-1)<<1));//+1
}
```

处理联动：

```cpp
inline int niu(int s, int w)
{//其实就是扭两个
	add(s, p[w][((s>>((w-1)<<1))&3)+1]);
	add(s, w);
	return s;
}
```

反着扭：

```cpp
inline int fniu(int s, int w)
{//其实就是一位加三次，懒得再写一个了
	for(int i=1;i<=3;i++)
		add(s, w);
	for(int i=1;i<=3;i++)
		add(s, p[w][((s>>((w-1)<<1))&3)+1]);
	return s;
}
```

状态压缩没什么问题了，接下来是搜索

## 双向搜索

单项爆搜肯定是不行的，有些 dalao 用启发式搜索，我没想出来，就写了一个双向搜索

双向搜索介绍我觉得还是看别的题解里的 dalao 吧，我就是说一下简单的思想，思路就是从起始状态和目标状态同时开始搜索，假如搜到有一状态（设它为 $s$ ）两边都搜过，那么最少步数就是起始状态到 $s$ 的最少步数 $+s$ 到目标状态的最少步数，我们用两个队列来搜索这两边（我习惯给跟从初始状态开始搜索的有关的起名都加上后缀 $b$ ，另一个加上后缀 $e$ ，队列前缀加上 $q$ ，判重的数组起名 $vis$）

看了双向搜索应该也了解了如何求最少步数，但是问题是题目还要求我们输出扭动的路径，那该怎么办呢，想了几天想明白了，我们可以记录每个状态的上一个状态，再记录每个状态是上个状态扭动了哪个按钮得到的，这样我们先搜索：

```cpp
qb.push(b), qe.push(e);
visb[b]=true, vise[e]=true;
while(!qb.empty() && !qe.empty())
{
    b=qb.front(), qb.pop();
    e=qe.front(), qe.pop();
    if(visb[b] && vise[b])
    {
        p=b;
        break;
    }
    if(visb[e] && vise[e])
    {
        p=e;
        break;
    }
    for(int i=1;i<=12;i++)
    {//枚举转动哪一个按钮
        pushb(niu(b, i), i);//参见后面
        pushe(fniu(e, i), i);
    }
}
```

$pushb\ pushe$：

```cpp
inline void pushb(int x, int w)
{
	if(visb[x])return;
	qb.push(x);
	visb[x]=true;//判重
	fromb[x]=b;//从哪来
	cb[x]=w;//怎么来
}
inline void pushe(int x, int w)
{
	if(vise[x])return;
	qe.push(x);
	vise[x]=true;
	frome[x]=e;
	ce[x]=w;
}
```

然后再用找到的状态 $p$ 对路径进行遍历，输出：

```cpp
int cnt1=0;
int s=p;
while(s!=xb)//xb是初始状态
{
    a[++cnt1]=cb[s];
    s=fromb[s];
}
int cnt2=cnt1;
s=p;
while(s!=xe)//xe是目标状态
{
    a[++cnt2]=ce[s];
    s=frome[s];
}
printf("%d\n", cnt2);
for(int i=cnt1;i>=1;i--)//注意要倒着
    printf("%d ", a[i]);
for(int i=cnt1+1;i<=cnt2;i++)
    printf("%d ", a[i]); 
```

于是所有问题就都解决了，完整代码：

```cpp
#include<queue>
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
const int MXN=(1<<24)+10;
int p[20][10];
int b, e;
queue<int>qb, qe;
bool visb[MXN], vise[MXN];
int fromb[MXN], frome[MXN];
int cb[MXN], ce[MXN];
int a[int(1e6)+100];
inline void add(int &s, int w)
{
	int num=(s>>((w-1)<<1))&3;
	s-=num*(1<<((w-1)<<1));
	num++;
	if(num!=4)s+=num*(1<<((w-1)<<1));
}
inline int niu(int s, int w)
{
	add(s, p[w][((s>>((w-1)<<1))&3)+1]);
	add(s, w);
	return s;
}
inline int fniu(int s, int w)
{
	for(int i=1;i<=3;i++)
		add(s, w);
	for(int i=1;i<=3;i++)
		add(s, p[w][((s>>((w-1)<<1))&3)+1]);
	return s;
}
inline void pushb(int x, int w)
{
	if(visb[x])return;
	qb.push(x);
	visb[x]=true;
	fromb[x]=b;
	cb[x]=w;
}
inline void pushe(int x, int w)
{
	if(vise[x])return;
	qe.push(x);
	vise[x]=true;
	frome[x]=e;
	ce[x]=w;
}
int main()
{
	int t, tmp=0;
	for(int i=1;i<=12;i++)
	{
		scanf("%d", &t);
		b+=(t-1)<<(tmp<<1);
		tmp++;
		for(int j=1;j<=4;j++)
			scanf("%d", p[i]+j);
	}
	int p, xb=b, xe=e;
	qb.push(b), qe.push(e);
	visb[b]=true, vise[e]=true;
	while(!qb.empty() && !qe.empty())
	{
		b=qb.front(), qb.pop();
		e=qe.front(), qe.pop();
		if(visb[b] && vise[b])
		{
			p=b;
			break;
		}
		if(visb[e] && vise[e])
		{
			p=e;
			break;
		}
		for(int i=1;i<=12;i++)
		{
			pushb(niu(b, i), i);
			pushe(fniu(e, i), i);
		}
	}
	int cnt1=0;
	int s=p;
	while(s!=xb)
	{
		a[++cnt1]=cb[s];
		s=fromb[s];
	}
	int cnt2=cnt1;
	s=p;
	while(s!=xe)
	{
		a[++cnt2]=ce[s];
		s=frome[s];
	}
	printf("%d\n", cnt2);
	for(int i=cnt1;i>=1;i--)
		printf("%d ", a[i]);
	for(int i=cnt1+1;i<=cnt2;i++)
		printf("%d ", a[i]); 
	return 0;
}
```

---

## 作者：清尘 (赞：7)

基本思路和算法（A*）大佬们都讲的很详细了，上面的代码写的也很清楚，这里就提供一个小小的但很实用优化。

离AC只差一步的可以来看看

《算法竞赛进阶指南》第124页写到“估价函数的估值不能大于未来的实际价值”，但在这题中，稍稍提高一点估值可以大大提高程序运行效

[优化前](https://www.luogu.org/record/23140709)

[优化后](https://www.luogu.org/record/23154481)

优化前后效率快了将近一倍，而优化所做的所有改变就是在估价函数上乘了一个系数

一般的估价函数：每个旋钮距离目标状态（1）的差值之和除以2（取上整）
```cpp
bool operator < (const e &a) const {
      return s + (v >> 1) + (v & 1) > a.s + (a.v >> 1) + (a.v & 1);
}
```
注：

1、s指当前状态已经操作的次数，v表示每个旋钮距离目标状态的差值之和（估价函数）

2、加上（v&1）是为了取上整（也许没什么用）

3、该比较函数写在结构体中,结构体名称为e

不难发现，这个估价函数是一个很美好的理想状态（每次操作都让两个旋钮向目标状态靠近），但现实中很难达到，可以让估值更准确一些，于是我在 v 上乘一个稍大于1的系数（1.1, 1.2, 1.3）均可（下面代码中写的1.3，因为这个比较快），可以自己调试

变成这样：
```cpp
bool operator < (const e &a) const {
      return s + (v >> 1) * 1.3 + (v & 1) > a.s + (a.v >> 1) * 1.3 + (a.v & 1);
}
```

小小的改变就上效率大大提高，快了将近400ms（数据最大的点快了300ms，~~虽然巨佬们总用时都不到300ms~~）

其他代码就不放了，上面的写得好看多了qwq

---

## 作者：tyno夏 (赞：6)

核心就像前面几位大佬说的，是A_*，启发式搜索，我还是想给各位像我一样的菜鸡普及一下启发式搜索。

什么是启发式搜索（heuristic  search）

　　利用当前与问题有关的信息作为启发式信息，这些信息是能够提升查找效率以及减少查找次数的。

如何使用这些信息，我们定义了一个估价函数 h(x) 。h(x)是对当前状态x的一个估计，表示 x状态到目标状态的距离。

有：1、h(x) >= 0 ；  2、h(x)越小表示 x 越接近目标状态； 3、如果 h(x) ==0 ，说明达到目标状态。

与问题相关的启发式信息都被计算为一定的 h(x) 的值，引入到搜索过程中。

　　然而，有了启发式信息还不行，还需要起始状态到 x 状态所花的代价，我们称为 g(x) 。比如在走迷宫问题、八数码问题，我们的 g(x) 就是从起点到 x 位置花的步数 ，h(x) 就是与目标状态的曼哈顿距离或者相差的数目；在最短路径中，我们的 g(x) 就是到 x 点的权值，h(x)  就是 x 点到目标结点的最短路或直线距离。

　　现在，从 h(x) 和 g(x) 的定义中不能看出，假如我们搜索依据为 F(x) 函数。

　　当 F(x) = g(x) 的时候就是一个等代价搜索，完全是按照花了多少代价去搜索。比如 bfs，我们每次都是从离得近的层开始搜索，一层一层搜 ；以及dijkstra算法，也是依据每条边的代价开始选择搜索方向。 

　　当F(x) = h(x) 的时候就相当于一个贪婪优先搜索。每次都是向最靠近目标的状态靠近。

　　人们发现，等代价搜索虽然具有完备性，能找到最优解，但是效率太低。贪婪优先搜索不具有完备性，不一定能找到解，最坏的情况下类似于dfs。

　　这时候，有人提出了A算法。令F(x) = g(x) + h(x) 。（这里的 h(x) 没有限制）。虽然提高了算法效率，但是不能保证找到最优解，不适合的 h(x)定义会导致算法找不到解。不具有完备性和最优性。

　　几年后有人提出了 A*算法。该算法仅仅对A算法进行了小小的修改。并证明了当估价函数满足一定条件，算法一定能找到最优解。估价函数满足一定条件的算法称为A*算法。

它的限制条件是 F(x) = g(x) + h(x) 。 代价函数g(x) >0 ；h(x) 的值不大于x到目标的实际代价 h*(x) 。即定义的 h(x) 是可纳的，是乐观的。

怎么理解第二个条件呢？

　　打个比方：你要从x走到目的地，那么 h(x) 就是你感觉或者目测大概要走的距离，h*(x) 则是你到达目的地后，发现你实际走了的距离。你预想的距离一定是比实际距离短，或者刚好等于实际距离的值。这样我们称你的 h(x) 是可纳的，是乐观的。

　不同的估价函数对算法的效率可能产生极大的影响。尤其是 h(x) 的选定，比如在接下来的八数码问题中，我们选择了曼哈顿距离之和作为 h(x) ，你也可以选择相差的格子作为 h(x)，只不过搜索的次数会不同。当 h(x) 越接近 h*(x) ，那么扩展的结点越少！
 
 以上搬运自CNblogs的ISGuXing大佬，可以去
 
 [启发式搜索](https://www.cnblogs.com/ISGuXing/p/9800490.html)
 
 看完了相信大家就能很明白什么是启发式搜索。
 
 那么对于本题，寻找h（x）方程还是比较容易的，就是所有点转到1需要的最少步数整除2，这些上面的大佬都有提到。
 
 我这边主要是想说一说这道题的坑点：
 
 1.这道题显然需要用一个集合表示已经访问过的一个状态，最容易想到的是用一个long long的12位整数来储存每一位，但是这样的话无法开数组，只能用set或者map，对这道题来说，很可能导致超时（因为会多一个log的常数），所以考虑使用哈希，方程如下
 
 ```cpp
ll standd = 0;
for (int j = 1; j <= 12; j++)
{
	standd = (standd<<2) + to.fx[j];
}
if (vis[standd])
	continue;
vis[standd]=true;
```
计算一下就知道，最差的情况，即全是4，我们也只需要16380就够了，显然是可以通过数组来实现O（1）的访问的，所以开一个vis数组就可以了。

2.本题要求记录路径，这也是bfs算法的一个难点，但是由于每个状态只会出现一次，我们可以考虑把每个点的父节点记录下来，并记录父节点的行为（即改动了哪个数字），同样的，利用前面哈希的结果，我们开两个数组即可，这样就避免了map的log常数。
```cpp
to.stand = standd;
fa[standd] = from.stand;
flag[standd] = i;
```
类似这样，具体的可以看完整代码的实现。
 
 ```cpp
#include<iostream>
#include<stdio.h>
#include<algorithm>
#include<queue>
#include<map>
#include<set>
#include<stack>
#include<string.h>
using namespace std;
#define ll long long
#define MAX INT_MAX/2
#define MOD 99999997
#define eps 1e-8
#define INF 1e9
#define N1 105 
#define N 55
struct node
{
	int fx[13];
	int num;
	int h;
	ll stand;
	bool operator < (const node& b) const
	{
		return num + h > b.num + b.h;
	}
};
priority_queue<node>pq;
int inp[13][5];
stack<int>ans;
int fa[70000000];
int flag[70000000];
bool vis[70000000];
inline void con(node& a)
{
	int kk = 0;
	for (int i = 1; i <= 12; i++)
	{
		if (a.fx[i] != 1)
			kk += 5 - a.fx[i];
	}
	a.h = ((kk - 1) >> 1) + 1;
}
inline int _next(int x)
{
	return x==4?1:x+1;
}
int main()
{
	node now;
	for (int i = 1; i <= 12; i++)
		scanf("%d%d%d%d%d", &now.fx[i], &inp[i][1], &inp[i][2], &inp[i][3], &inp[i][4]);
	
	now.num = 0;
	con(now);
	pq.push(now);
	while (!pq.empty())
	{
		node from = pq.top();
		pq.pop();



		if (from.h == 0)
		{
			printf("%d\n", from.num);

			ll noww = from.stand;
			for (int i = 1; i <= from.num; i++)
			{
				ans.push(flag[noww]);
				noww = fa[noww];
			}
			for (int i = 1; i <= from.num; i++)
			{
				printf("%d ", ans.top());
				ans.pop();
			}
			return 0;
		}
		for (int i = 1; i <= 12; i++)
		{
			node to = from;
			to.num++;
			to.fx[inp[i][to.fx[i]]]=_next(to.fx[inp[i][to.fx[i]]]);
			to.fx[i]=_next(to.fx[i]);

			ll standd = 0;
			for (int j = 1; j <= 12; j++)
			{
				standd = (standd<<2) + to.fx[j];
			}
			if (vis[standd])
				continue;
			vis[standd]=true;
			to.stand = standd;
			fa[standd] = from.stand;
			flag[standd] = i;
			con(to);
			pq.push(to);
		}
	}
	return 0;
}

```
最后想说一句，手写堆的话效果会更好，当然不到万不得已的情况还是建议优先队列吧，毕竟方便。
 

---

## 作者：quarmer (赞：4)

# [P5507 机关](https://www.luogu.com.cn/problem/P5507)

这道题是一道比较经典的启发式搜索，用最基本的 $A*$ 来解决

## 前置芝士：bfs

普通 bfs 都不会打的话先去学 bfs 叭……


## - 启发式搜索

在普通 bfs 中，程序会遍历几乎所有的状态。无论这个状态是什么，程序都一视同仁。

而启发式搜索呢，就是让你的程序不要傻乎乎的去搜那些根本不可能或不是最优解的状态。

举个例子，假设一个状态用一个二进制六位数表示。你的程序要找的是 $1110110$ ,现在有 $1100001$ 和 $1110111$。显然的，后者能更快到达目标，但是你的程序会先遇到前者，因此会先搜前者，这样会浪费掉很多无用的时间。

而启发式搜索，给你的一个程序一个估价函数，让你的程序能正确的对每个状态做出一个估计值。就拿上边那个例子来说程序要找的是 $1110110$，那么可以把估价函数 $h(x)$ 设计为   $h(x) = $ **与目标二进制状态相同位数的个数**。这样一来，当目标状态为 $1110110$ 时 $h(1100001) = 3$ 而  $h(1110111) = 6$， 显然地，后者更优，程序会先搜后者，这样可以节省大量时间。

那说了那么多，该怎么实现呢？其实很简单，用**优先队列**，将状态与估价函数打包在一起扔进队列，然后像 bfs 一样搜就彳亍了。

虽然复杂度看起来多了一个 log ，但排除了大量无用状态，所以比普通 bfs 快很多。

## 本题

回到本题，如果用普通 bfs 实现很简单，但是会超时这里就不细说了。这里主要说一下估价函数设计。

题目中每个按钮按一下状态都可以看做模 $4$ 再加一，而状态都为  $1$ 时达到目标状态。那么估价函数可以设计为：**所有按钮要变到 $1$ 至少旋转次数总和**  。这样，更优的状态就会更早搜到。

本题还有很多细节，那具体细节见代码吧 。

## 代码

```cpp
#include <algorithm>
#include <iostream>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <stack>
#include <queue>
#include <vector>
#include <list>
#include <map>
using namespace std;
#define ll long long
map<string, bool>mp ; //去重
int nw[20][10] ; // 二维数组表示
string zh(){
	string s = "" ;
	for(int i = 1 ; i <= 12 ; i++){
		char nxa = nw[i][1] / 10 + '0' , nxb = nw[i][1] % 10 + '0' ;
		s += ' ' ;
		s += nxa ;
		s += nxb ;
	}
	return s ;
} // 状态转化字符串便于判重
struct node{
	int a[20][10], num, gj;
	string fa = "" ;
};
node temp ;
node st ;
int h(){ // 估价函数
	int ret = 0 ;
	for(int i = 1 ; i <= 12 ; i++)ret += (5 - nw[i][1]) % 4;
	return ret ; 
}
bool check(){
	for(int i = 1 ; i <= 12 ; i++)if(nw[i][1] != 1)return 0 ;
	return 1 ;
}
bool operator <(node a, node b){return a.gj > b.gj ;} //结构体比较重载运算符，小根堆
priority_queue<node>q ;
int main(){
	for (int i = 1 ; i <= 12 ; i++)
	   for (int j = 1 ; j <= 5 ; j++)
	      cin >> st.a[i][j] ;
	q.push(st) ;
	mp[zh()] = 1 ;
	while(!q.empty()){ // 基本 bfs 搜索
		for (int i = 1 ; i <= 12 ; i++)
		   for (int j = 1 ; j <= 5 ; j++)
		      nw[i][j] = q.top().a[i][j] ; //nw 表示当前状态
		int nm = q.top().num ;
		if(check()){
			cout << nm << '\n' << q.top().fa;
			return 0 ;
		} //若全是 1 了，输出
		string nww = q.top().fa ;
		q.pop() ;
		for(int i = 1; i <= 12 ; i++){ // 枚举旋转 12 个按钮
			int now = nw[i][1] ;
			int now2 = nw[nw[i][now + 1]][1] ;
			nw[nw[i][now + 1]][1] = nw[nw[i][now + 1]][1] % 4 + 1;
			nw[i][1] = nw[i][1] % 4 + 1 ;
			if(mp.find(zh()) == mp.end() ){//小细节，如果直接访问下标，会直接把当前状态插入到 map 中，程序就会变慢。有的题会直接 T 掉（CF525E）当然，unordered_map 就没关系了
				for(int j = 1 ; j <= 12 ; j++)for(int k = 1 ; k <= 5 ; k++)temp.a[j][k] = nw[j][k] ;
				temp.gj = h() + nm + 1 ; 
				temp.num = nm + 1 ;
				char nxa = i / 10 + '0' , nxb = i % 10 + '0' ;
				if(i < 10)temp.fa = nww + nxb + ' ';
				else temp.fa = nww + nxa + nxb + ' ';
				q.push(temp) ; // 算出下一个状态，拓展
				mp[zh()] = 1 ;
			}
			nw[i][1] = now ; nw[nw[i][now + 1]][1] = now2 ;
		}
	}
	return 0 ;
}
```

另外问一下，这个代码[开 O2](https://www.luogu.com.cn/record/77590756)
还不如[不开 O2](https://www.luogu.com.cn/record/77590776)快，有没有神犇知道什么原因

---

## 作者：Think (赞：4)

### 这是道很好的搜索练手题  
可以用广为人知的搜索~~三巨头~~求解 。  
- 双向搜索 。
- IDA* （~~在这题貌似被禁了~~）。
- A* 。  

这篇题解主要介绍用 **A_star** 算法 AC 这道题 。  
## 1. 思路  
用 **结构体** 记录 **路径** **状态** 。   
以及实际步数 $\textbf{g(n)}$ 和估价步数 $\textbf{h(n)}$ 。  
我们都知道 A* 算法的核心在于其估价函数 $\textbf{h(n)}$ 。   
每次取出对应 $g(n) + h(n)$ **最小的** 进行下一步搜素 。  

引出一个疑惑 ：  
每改变一个机关的状态都会有另一个机关跟着改变 。  
那么估价函数如何求解 ？  
看作是两个一起变换 。  
可以 **用当前状态距离目标状态的理想差值除去 $2$ 得到** 。

## 2.解法  
使用优先队列存储结构体 。  
所以我们需要 **重载运算符**  ： 
```cpp
bool operator<(const node &a,const node &b){
	return a.g+a.h>b.g+b.h;
}
```  
经检验 ：  
由于看作两个机关同时向着目标前进 **过于理想** 。  
此题的估价函数可以稍微调高一些，用于优化时间复杂度 。  
参数为原估价函数的 $\textbf{1.3}$ 倍 。  
但此时的时间复杂度仍高了些 。  
所以最后加上 **map 去重** 即可 。
## 3. Code
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	string state;//状态 
	string path;//路径 
	int g;//实际步数 
	int h;//估价函数 
};
map<string,bool> mark;
//重载运算符 
bool operator<(const node &a,const node &b){
	return a.g+a.h>b.g+b.h;
}
priority_queue<node> q;
//估价函数 
int eva(string s){
    int cnt=0;
    for(int i=1;i<=12;i++)
        if(s[i]!='1') cnt+=5-(int)(s[i]-48);
    return cnt/2*1.3;
}
void print(node s){
	printf("%d\n",s.g);
	for(int i=0;i<s.path.size();i++) cout<<(int)(s.path[i]-48)<<" ";
}
int main(){ 
	int gear[13][5];//机关触发机制 
	node start;
	start.state+=(char)(48);
	for(int i=1;i<=12;i++)
		for(int j=1;j<=5;j++){
			int x;scanf("%d",&x);
			if(j==1) start.state+=(char)(x+48);
			else gear[i][j-1]=x;
		}
	start.g=0;
	start.h=eva(start.state);
	if(!start.h){printf("0");return 0;}
	mark[start.state]=true;
	q.push(start);
	while(!q.empty()){
		node a=q.top();q.pop();
		for(int i=1;i<=12;i++){
			//触发机关 
			int x=(int)(a.state[i]-48);//x为i机关的状态 
			int j=gear[i][x];//j为i机关的连锁机关 
			int y=(int)(a.state[j]-48);//y为j机关的状态
			//改变状态 
			if(x==4) x=1;
			else x+=1;
			if(y==4) y=1;
			else y+=1;
			 
			node s;//转换入队列 
			s.state+=(char)(48);
			for(int u=1;u<=12;u++){
				if(u==i){s.state+=(char)(x+48);continue;}
				if(u==j){s.state+=(char)(y+48);continue;}
				s.state+=a.state[u];
			}
			
			if(!mark[s.state]){//map去重 
				s.g=a.g+1;
				s.h=eva(s.state);
				mark[s.state]=true;
				s.path=a.path+(char)(i+48);
				if(!s.h){print(s);return 0;}
				q.push(s);
			}
		}
	}
	return 0;
} 
```


---

## 作者：JustinRochester (赞：2)

[传送门](https://www.luogu.com.cn/problem/P5507)

毕设老师让我做 MAPF，由于学了好多 A\* 算法的变形，就过来做一做了。

这题用的是 EPEA\*（Enhanced Partial Expansion A\*）算法。

---

**【分析】**
--

显然搜索能过，但是状态空间太大了。一眼可 A\*。

考虑所有机关的状态为 $s_i$ 时：

若没有连锁反应，最少步数为 $\displaystyle h_1(\boldsymbol s)=\sum_i((5-s_i)\bmod 4)$。

现在由于有连锁反应，我们设计估价函数的时候需要保证估价函数的结果不大于真实步数；

为此，我们考虑最优情况下，每次转动一个机关会导致另一个机关跟着转动；也就是说，这种情况下等价于没有连锁反应的情况下转两次。

因此估价函数可以设计为 $\displaystyle h_2(\boldsymbol s)={1\over 2}h_1(\boldsymbol s)$。

当然，我们知道，估价函数在不超过真实值的情况下，估价函数的值越大，搜索效率越高。因此，对于奇数的 $h_1(\boldsymbol s)$，我们直接取上取整，因此设计出估价函数：

$\displaystyle h_2(\boldsymbol s)=\lceil{1\over 2}h_1(\boldsymbol s)\rceil$。

---

我们考虑一下一般的 A\* 算法，在状态 $S$ 下，通过维护当前耗散 $g_S$ 和对于后续操作的估计耗散 $h_S$，共同组合成总期望耗散 $f_S=g_S+h_S$。

通过对待扩展状态的总期望耗散进行从小到大排序，优先拓展总期望耗散较小的状态。

EPEA\* 则是在此基础上动态调整自身的后续估价耗散，从而达到动态调整总期望耗散的结果。

在拓展一个状态 $S$ 时，EPEA\* 对于其所有后继状态 $\{T_i\}$，EPEA\* 只拓展满足条件 $f_S=f_{T_i}$ 的后继状态。

由于 A\* 中，估价函数的结果是不超过真实值的，因此不可能存在 $f_S>f_{T_i}$ 的情况。

而对于其他总期望耗散更大的后继状态，可能也能产生对答案的贡献。为此，我们修正 $h_S$ 使得 $f_S$ 更新为未选择的后继状态中，$f_{T_i}$ 最小的结果；之后，将修正后的当前节点重新扔进待拓展的队列中。

---

如对于搜索到的某个状态 $S$，其当前耗散 $g_S=5$ 而根据估价函数产生了初始的后续估价耗散 $h_S=4$，于是 $f_S=5+4=9$。

假设它存在 $3$ 个后续状态 $T_1, T_2, T_3$，他们根据估价函数产生后续估价耗散 $h_{T_1}=3, h_{T_2}=4, h_{T_3}=5$ ；那么，由于他们的当前耗散均为 $6$，因此有 $f_{T_1}=9, f_{T_2}=10, f_{T_3}=11$。

这一次的拓展中，我们仅拓展了 $T_1$ 状态。而对于没拓展的后继状态中，最小的结果为 $f_{T_2}=10$ ；因此在拓展后，我们修正 $h_S=5$ 使得 $f_S=10$。

当然，在具体的实现中，我们不必修正 $h_S$ 的结果，直接修改 $f_S$ 的结果也是等价的。

---

可以发现，EPEA\* 适用于遍历后继状态较快，且评估后继状态的估价函数较快的问题。

对于这题而言，由于所有状态的后继状态都最多为 $12$ 种，而估价函数对于每个状态可以在 $O(1)$ 的时间内算出结果；恰好适用于这题。

最后，关于答案的维护，我们直接维护 $fr_S, pace_S$ 数组分别表示状态 $S$ 是从状态 $fr_S$ 沿边 $pace_S$ 转移而来的。

当然，为了避免搜索重复状态，可以再维护数组 $vis_S$ 表示是否已经访问过了状态 $S$。

因为 EPEA\* 算法中保证了对每个状态，优先拓展总期望耗散和自身一致的后继。故当一个后继状态一旦被拓展到，后续的拓展方案中，必然不存在总期望耗散更优的拓展方案，可以直接记录 $fr_S,pace_S,vis_S$ 结果。

论文里描述该算法在 MAPF 中对于状态空间的数量产生了 dramatically reduce。~~但在算法竞赛题中，实测好像没那么强，甚至会更慢。~~

就当作作为一个拓展吧。

---

**【代码】**
--

为了实现方便，代码中将机关的状态 $1,2,3,4$ 分别映射成了 $0,1,2,3$，将机关 $1\sim12$ 分别映射成了 $0\sim11$。

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[12][4];
inline int h(int sta) {
	//Heuristic Function
	/*
	  12 * 2 = 24
	  24 / 4 = 6
	*/
	int s1 = (0x444444 - (sta & 0x333333)) & 0x333333;
	int s2 = (0x1111110 - (sta & 0xcccccc)) & 0xcccccc;
	int tmp = __builtin_popcount((s1 | s2) & 0x555555);
	int pace = __builtin_popcount(s1 | s2) * 2 - tmp;
	return pace + 1 >> 1;
}
inline int move(int sta, int id) {
	//Move the id-th mechanism while the state is sta.
	int single_sta = ((sta >> id + id)&3);
	int chain = a[id][single_sta];
	int chain_sta = ((sta >> chain + chain)&3);
	
	single_sta = (single_sta + 1)&3;
	chain_sta = (chain_sta + 1)&3;
	int msk = ((3 << id + id) | (3 << chain + chain));
	return sta&(~msk) | (single_sta << id + id) | (chain_sta << chain + chain);
}

struct node {
	int sta;
	int gv, hv, fv;
	inline node(int sta_=0, int gv_=0): sta(sta_), gv(gv_) {
		hv=h(sta_);
		fv=gv+hv;
	}
	inline friend bool operator < (const node &a, const node &b) {
		return a.fv > b.fv;
	}
};
priority_queue<node> pq;
int fr[1<<24], pace[1<<24];
bool vis[1<<24];
inline void EPEA_star(int sta) {
	while(!pq.empty()) pq.pop();
	pq.emplace(sta, 0);
	fr[sta]=-1;
	pace[sta]=-1;
	vis[sta]=1;
	
	while(!pq.empty()) {
		node now = pq.top(); pq.pop();
		if(now.sta == 0)//target state
			break;
		
		int nxtf=-1;
		for(int i=0; i<12; ++i) {
			int nxtsta = move(now.sta, i);
			if(vis[nxtsta])
				continue;
			int f = now.gv + 1 + h(nxtsta);
			if(f < now.fv)//expanded
				continue;
			else if(f == now.fv) {//expand
				pq.emplace(nxtsta, now.gv+1);
				fr[nxtsta] = now.sta;
				pace[nxtsta] = i;
				vis[nxtsta] = 1;
			}
			else if(nxtf == -1)//update the next f-value of this state
				nxtf = f;
			else
				nxtf = min(nxtf, f);
		}
		if(nxtf == -1)//expanded all the successors
			continue;
		now.fv = nxtf;
		pq.push(now);
	}
}
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	int ini_sta=0;
	for(int i=0; i<12; ++i) {
		int s;
		cin>>s;
		ini_sta |= (s-1<<i+i);
		for(int j=0; j<4; ++j) {
			cin>>a[i][j];
			--a[i][j];
		}
	}
	EPEA_star(ini_sta);
	
	vector<int> v;
	for(int sta=0; ~fr[sta]; sta=fr[sta])
		v.push_back(pace[sta]);
	reverse(v.begin(), v.end());
	cout<<v.size()<<"\n";
	for(auto e : v) cout<<e+1<<" ";
	return 0;
}
```

---

## 作者：Danno0v0 (赞：1)

求步数这一部分可以用双 BFS 随便乱过，看其他题解还可以用各种牛鬼神蛇的搜索乱过，如果这道题没有方案输出建议降绿。

随便加个剪枝就可以了，这里我用的是假如当前情况的伪最多步数（即每个机关不会带动其他机关转这种情况下的步数）大于初始情况的伪最多步数。

~~这个剪枝大概率是错的但是可以过，面向数据编程了属于是~~

然后说一下方案输出。

直观来看最简单的方法是在 BFS 时顺便记录一下方案，当然会 MLE。

但是我们可以用一下 BFS 的第一次搜到即为最短的性质然后在 map 记录当前情况最短步数时记录一下是使用哪个机关才变到这种情况的。

然后输出方案是可以用这个来向上和向下查找，类似于前向星的 next 数组。

还是看 code 方便一点：

```cpp
#include<bits/stdc++.h>
using namespace std;
int change[13][5];
int gf(int c){return c-1>0?c-1:4;}
int gb(int c){return c+1<5?c+1:1;}
struct m
{
	short g[13];
	bool typ;
	void tf(int ch)//找如果把 ch 扭回去会发生什么
	{
		int c=change[ch][gf(g[ch])];
		g[ch]=gf(g[ch]);
		g[c]=gf(g[c]);
	}
	void tb(int ch)//找如果把 ch 扭过来会发生什么
	{
		int c=change[ch][g[ch]];
		g[ch]=gb(g[ch]);
		g[c]=gb(g[c]);
	}
};
bool operator <(m a,m b)
{
	for(int i=1;i<=12;i++)
		if(a.g[i]!=b.g[i]) return a.g[i]<b.g[i];
	return false;
}
void copy(m &a,m b)
{
	for(int i=1;i<=12;i++)	
		a.g[i]=b.g[i];
	a.typ=b.typ;
}
map<m,pair<int,int> >mmp0;
map<m,pair<int,int> >mmp1;//第一个记录上一个使用的机关。第二个记录步数
queue<pair<m,int> >que;
m now,now_,goal={{0,1,1,1,1,1,1,1,1,1,1,1,1},0};
int st,ss[20],sscnt,fff;
int check(m a)
{
	int cnt=0;
	for(int i=1;i<=12;i++)
		cnt+=(a.g[i]-1);
	return cnt;
}
int main()
{
	for(int i=1;i<=12;i++)
	{
		cin>>now.g[i];
		for(int j=1;j<=4;j++)
			cin>>change[i][j];
	}
	now.typ=1;
	fff=check(now)+4;
	que.push({now,0});
	que.push({goal,0});
	mmp0[now].first=-1,mmp0[now].second=-1;
	mmp1[goal].first=-1,mmp1[goal].second=-1;
	while(!que.empty())
	{
		now=que.front().first;
		st=que.front().second;
		que.pop();
		if(now.typ)
		{
			if(mmp1[now].second!=0)
			{
				copy(now_,now);
				if(mmp1[now].second==-1) mmp1[now].second=0;
				cout<<mmp1[now].second+st<<endl;
				while(mmp0[now].first!=-1)
					ss[++sscnt]=mmp0[now].first,now.tf(ss[sscnt]);//向前找
				while(sscnt)
					cout<<ss[sscnt--]<<" ";
				while(mmp1[now_].first!=-1)
					cout<<mmp1[now_].first<<" ",now_.tb(mmp1[now_].first);//向后找
				return 0;
			}
		}
		else
		{
			if(mmp0[now].second!=0)
			{
				copy(now_,now);
				if(mmp0[now].second==-1) mmp0[now].second=0;
				cout<<mmp0[now].second+st<<endl;
				while(mmp0[now].first!=-1)
					ss[++sscnt]=mmp0[now].first,now.tf(ss[sscnt]);
				while(sscnt)
					cout<<ss[sscnt--]<<" ";
				while(mmp1[now_].first!=-1)
					cout<<mmp1[now_].first<<" ",now_.tb(mmp1[now_].first);//同理
				return 0;	
			}
		}
		for(int i=1;i<=12;i++)
		{
			copy(now_,now);
			if(now_.typ)
			{
				now_.tb(i);
				if(mmp0[now_].second==0&&check(now_)<=fff)
				{
					mmp0[now_].first=i;
					mmp0[now_].second=st+1;
					que.push({now_,st+1});
				}
			}
			else
			{
				now_.tf(i);
				if(mmp1[now_].second==0&&check(now_)<=fff)
				{
					mmp1[now_].first=i;
					mmp1[now_].second=st+1;
					que.push({now_,st+1});
				}
			}
		}
	}
}
```

---


# [NOIP 1997 提高组] 棋盘问题 加强版

## 题目背景

[P1549](https://www.luogu.org/problem/P1549) 数据加强版。

**数据从 5 扩大到了 10。**



因为本题数据可能存在诸多争议，故特开一题用来测试加强版数据。

## 题目描述

在 $N \times N$（$1 \le N \le 10$）的棋盘上，填入 $1, 2, \dots, N ^ 2$ 共 $N ^ 2$ 个数，使得任意两个相邻的数之和为素数。

例如：当 $N = 2$ 时，有：

| $1$ | $2$ |
| :-----------: | :-----------: |
| $4$ | $3$ |

其相邻数的和为素数的有：

$1+2,1+4,4+3,2+3$

当 $N=4$ 时，一种可以填写的方案如下：

| $1$ | $2$ | $11$ | $12$ |
| :-----------: | :-----------: | :-----------: | :-----------: |
| $16$ | $15$ | $8$ | $5$ |
| $13$ | $4$ | $9$ | $14$ |
| $6$ | $7$ | $10$ | $3$ |

在这里我们约定：左上角的格子里必须填数字 $1$。

## 说明/提示

$N\leq10$

 $N=1,2,...,10$ 的数据都各有一个点，由于某些原因， $N$ 不一定与测试点编号相等。

----

**数据新修复于 `2020.1.20`**

## 样例 #1

### 输入

```
2```

### 输出

```
1 2
4 3```

## 样例 #2

### 输入

```
1```

### 输出

```
NO```

# 题解

## 作者：louhao088 (赞：23)

##  点开这道题发现$N<=10$，脑海中立刻浮现一种算法 打表


过程就不必多说，深搜暴力跑上几天总能跑完，只是求第一行加第一列和最小很恶心，$WA$了好几次

上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int main()
{
    cin>>n;
    if(n==1||n==3)
    {
        puts("NO");
    }
    else if(n==2)
    {
        puts("1 2");
		puts("4 3");
    }
    else if(n==4)
    {
        puts("1 2 11 12");
        puts("4 9 8 5");
        puts("7 10 3 14");
        puts("6 13 16 15");
    }
    else if(n==5)
    {
        puts("1 2 3 4 7");
        puts("6 5 14 15 16");
        puts("13 24 23 8 21");
        puts("10 19 18 11 20");
        puts("9 22 25 12 17");
    }
    else if(n==6)
    {
		puts("1 2 3 8 9 4");
		puts("6 11 20 33 28 25");
		puts("5 36 23 14 15 22");
		puts("12 31 30 17 26 21");
		puts("7 16 13 24 35 32");
		puts("10 27 34 19 18 29");
    }
    else if(n==7)
    {
		puts("1 2 3 4 7 6 5");
		puts("12 17 14 15 16 25 18");
		puts("11 20 33 46 37 42 41");
		puts("8 21 40 43 36 47 32");
		puts("9 22 49 24 35 26 27");
		puts("10 19 48 23 38 45 34");
		puts("13 28 31 30 29 44 39");
    }
    else if(n==8)
    {
		puts("1 2 3 4 7 6 5 14");
		puts("12 17 20 27 34 25 18 23");
		puts("11 26 21 32 39 28 61 36");
		puts("8 15 46 51 58 31 48 35");
		puts("9 22 57 52 55 42 41 62");
		puts("10 19 40 49 54 47 56 45");
		puts("13 24 43 60 53 50 33 64");
		puts("16 37 30 29 44 59 38 63");
    }
    else if(n==9)
    {
		puts("1 2 3 4 7 6 5 8 9");
		puts("10 21 20 27 34 25 18 23 38");
		puts("13 40 33 26 45 28 19 24 35");
		puts("16 31 76 81 68 69 70 79 72");
		puts("15 22 51 56 71 80 57 52 37");
		puts("14 39 62 41 60 47 32 75 64");
		puts("17 44 65 48 49 54 77 74 63");
		puts("12 29 42 55 58 73 36 53 50");
		puts("11 30 67 46 43 66 61 78 59");
	}
    else if(n==10)
    {
		puts("1 2 3 4 7 6 5 8 9 10");
		puts("12 29 38 33 34 25 36 23 44 27");
		puts("11 30 59 68 45 28 43 24 35 26");
		puts("18 41 42 71 56 75 64 37 66 47");
		puts("13 48 19 60 53 98 93 100 91 90");
		puts("16 31 40 97 54 83 74 99 82 67");
		puts("15 22 49 52 55 96 77 80 57 46");
		puts("14 39 58 79 72 95 62 87 70 61");
		puts("17 50 51 88 85 78 89 92 81 76");
		puts("20 21 32 69 94 73 84 65 86 63");

    }
    return 0;
}

```

打表可以自己去尝试一下，不要直接抄袭




---

## 作者：MeowScore (赞：10)

## 题目

相信你来做这道题，肯定已经通过了[简化版](https://www.luogu.com.cn/problem/P1549)。


------------
## 解决问题

大题思路和简化版是一样的，但是要通过此题的数据，直接写搜索我也没办法通过，真的是太菜了。这里介绍一下打表的思路，加上各种奇奇怪怪的优化，能在可以接受的时间内得到答案（完全不加优化爆搜大概得等上几天？没试过，不敢尝试）。

### 优化一

预处理出对于任意两个数同时与它们两个相邻的数可能有哪些。条件就是：相邻的数相加不超过 $n^2$ 且和为素数、两两互不相同。用vector来存，$s_{i,j,k}$ 表示与 $i$ 和 $j$两个数相邻，第 $k+1$ 个可能的数。大大减少了枚举花费的时间。

### 优化二

改变一下搜索的顺序。先搜第一行和第一列，这样可以尽早排除一些第一行与第一列数字之和不是最优的情况（因为一旦不是最优就返回掉了）。

### 优化三

跟题解区的大佬学的设定下限。先预估一下可能搜到的情况中第一行与第一列之和最小可能是多少（只是可能，不一定会成立，这就是为什么这个优化并不具有普遍性）。

对于 $n$ 为奇数的时候，对于第一行和第一列的 $2n-1$ 个数，第一行选取 $2$ 到 $n$，第一列选取 $n+1$ 到 $2n-1$。求一下和（当然这里 $1$ 也算进来）：

$$\sum_{i=1}^{2n-1}i=n\times(2n-1)$$

所以对于 $n$ 为奇数的时候，如果某种方案的第一行与第一列数字之和可以达到这个下限，即 $n\times(2n-1)$，直接输出，结束程序。

对于 $n$ 为偶数的时候，对于第一行和第一列的 $2n-1$ 个数，第一行选取 $2$ 到 $n$，第一列选取 $n+1$ 到 $2n-1$。这样是否可行？答案是否定的。我们知道：偶 $+$ 偶 $=$ 偶；偶 $+$ 奇 $=$ 奇；奇 $+$ 奇 $=$ 偶。由于只存在 $2$ 一个偶素数，要使相邻两个数之和为素数，相邻两个数必须是一奇一偶（由于相同数不可以重复使用，故不存在 $1+1=2$ 这种情况）。由于第一行和第一列都由 $1$ 开头，第一行和第一列的数必须满足：奇（这个奇数当然固定为 $1$）、偶、奇、偶、奇……偶 。$n$ 为偶数，则最后第一行和第一列都要满足奇数数量和偶数数量相等。第一行的数字是 $1$ 到 $n$，满足条件。而第一列的数字是 $1$、$n+1$ 到 $2n-1$，奇数比偶数多两个，不满足条件。要使和最小，应当把 $2n-1$ 替换为 $2n$（可以看做是 $2n-1+1$），这样才能满足奇数和偶数数量相等。求出和便是：


$$\left(\sum_{i=1}^{2n-1}i\right)+1=n\times(2n-1)+1$$

所以对于 $n$ 为奇数的时候，如果某种方案的第一行与第一列数字之和可以达到这个下限，即 $n\times(2n-1)+1$，直接输出，结束程序。

### 优化四

建立在优化三的基础上，同样不具有普遍性。即按照最优情况选数。当 $n$ 为奇数，第一行的数只从 $2$ 到 $n$ 选取，第一列的数只从 $n+1$ 到 $2n-1$ 选取。当 $n$ 为偶数，第一行的数只从 $2$ 到 $n$ 选取，第一列选取的数都属于 $[n+1,2n]$，且不等于 $2n-1$。然而对于一些情况，这样并不能得到的解，比如 $n=9$。可以写两个程序，一个正常搜，一个按照这里说的搜，任何一个搜出来都是对的，搜出来就可以直接做到表里（要注意，在这种选数规则下，搜出解了可以使用，但如果输出 NO 也不证明无解，只是说在这种选数规则下无解）。正常搜的话 $1$ 到 $9$ 还可以，$10$ 的话有点受不了。但用了这种选数规则， $10$ 竟然秒出了。虽然这种优化不普遍，能较快地算出 $10$ 多少有点“碰运气”的成分，但也不失为一种得分策略。


------------

## 代码

给的代码不是最后提交的那一份，而是生成答案的代码（没有加优化四，但是很好加）。

```
#include<bits/stdc++.h>
using namespace std;
bool p[200]={0,0,1,1,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,
			0,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,1,
			0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,
			0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,
			0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1};//素数桶 
int tot=0;//累计第一行和第一列之和 
int minn;//当前所有情况中第一行和第一列之和最小值 
int n;
bool vis[110];
int a[15][15];
int Q[15][15];//盛放最终答案 
vector<int> s[101][101]; 
bool tag;//标记是否有解 
void dfs(int x,int y){
	if(tot>=minn)
		return;
	if(x==n+1){
		if(tot>=minn)
			return;
		minn=tot;
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				Q[i][j]=a[i][j];
		tag=1;
		if(n%2==1){
			if(tot==n*(2*n-1)){
				for(int i=1;i<=n;i++){
					for(int j=1;j<=n;j++)
						cout<<Q[i][j]<<' ';
					cout<<endl;
				}
				exit(0);
			}
		}
		if(n%2==0){
			if(tot==n*(2*n-1)+1){
				for(int i=1;i<=n;i++){
					for(int j=1;j<=n;j++)
						cout<<Q[i][j]<<' ';
					cout<<endl;
				}
				exit(0);
			}
		}
	}
	if(x==1){
		for(int i=0;i<s[0][a[x][y-1]].size();i++){
			if(!vis[s[0][a[x][y-1]][i]]){
				vis[s[0][a[x][y-1]][i]]=1;
				a[x][y]=s[0][a[x][y-1]][i];
				tot+=s[0][a[x][y-1]][i];
				if(y==n)
					dfs(x+1,1);
				else
					dfs(x,y+1);
				vis[s[0][a[x][y-1]][i]]=0;
				tot-=s[0][a[x][y-1]][i];
			}
		}
	}
	if(y==1){
		for(int i=0;i<s[0][a[x-1][y]].size();i++){
			if(!vis[s[0][a[x-1][y]][i]]){
				vis[s[0][a[x-1][y]][i]]=1;
				a[x][y]=s[0][a[x-1][y]][i];
				tot+=s[0][a[x-1][y]][i];
				if(x==n)
					dfs(2,2);
				else 
					dfs(x+1,1);
				vis[s[0][a[x-1][y]][i]]=0;
				tot-=s[0][a[x-1][y]][i];
			}
		}
	}
	if(x!=1&&y!=1){
		for(int i=0;i<s[a[x-1][y]][a[x][y-1]].size();i++){
			if(!vis[s[a[x-1][y]][a[x][y-1]][i]]){
				vis[s[a[x-1][y]][a[x][y-1]][i]]=1;
				a[x][y]=s[a[x-1][y]][a[x][y-1]][i];
				if(y==n)
					dfs(x+1,2);
				else
					dfs(x,y+1);
				vis[s[a[x-1][y]][a[x][y-1]][i]]=0;
			}
		}
	}
}
int main(){
	cin>>n;
	for(int i1=0;i1<=n*n;i1++){
		for(int j1=0;j1<=n*n;j1++){
			for(int k1=1;k1<=n*n;k1++){
				if(k1==i1||k1==j1||i1==j1)
					continue;
				if((p[k1+i1]||i1==0)&&(p[k1+j1]||j1==0))
					s[i1][j1].push_back(k1);
			}
		}
	}
	tot=0;
	minn=999999;
	a[1][1]=1;
	memset(vis,0,sizeof(vis));
	vis[1]=1;
	tag=0;
	dfs(1,2);
	if(!tag){
		cout<<"NO"<<endl;
		return 0;
	}
	for(int i=1;i<=n;i++){
		cout<<"	";
		for(int j=1;j<=n;j++)
			cout<<Q[i][j]<<' ';
		cout<<endl;
	}
	return 0;
}
```












---

## 作者：GK0328 (赞：8)

[Luogu5512 棋盘问题（2）【加强】
](https://www.luogu.com.cn/problem/P5512)

[我的博客](https://www.cnblogs.com/GK0328/p/13653844.html)

# 搜索

考虑最简单的搜索，数字从小到大开始搜索

首先，搜索第一行第一列，然后逐个$(2,2),(2,3),\cdots,(2,n),(3,2),(3,3),\cdots,(n,n)$搜索

预处理$t_{i,j}$表示$i,j$两数是否能够相邻，保证我们填入数字时当前局面一定满足题意

**最优性剪枝**：当第一行第一列已取的数之和大于等于当前答案，直接停止搜索

取数的过程中，我们通过链表维护，避免多余的循环过程

通过以上简单的搜索，就可以得到$70$分

$Code:$

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define pr pair<int,int>
#define mp make_pair
#define N 15
#define N1 105
#define N2 205
using namespace std;
int st,n,n1,n2,cnt,tot,kt,prime[N2],sh[N1],a[N][N];
int pre[N1],nxt[N1];
bool pri[N2],t[N1][N1];
pr s[N1];
int dic[2][2]={{0,-1},{-1,0}};
int rans=1000000007,ans[N][N];
void dfs(int cs)
{
    if (cs<n+n)
        st+=a[s[cs-1].first][s[cs-1].second];
    if (st>=rans)
    {
        if (cs<n+n)
            st-=a[s[cs-1].first][s[cs-1].second];
        return;
    }
    if (cs==n1)
    {
        rans=st;
        for (int i=1;i<=n;i++)
            for (int j=1;j<=n;j++)
                ans[i][j]=a[i][j];
        return;
    }
    int l=s[cs].first;
    int r=s[cs].second;
    for (int i=nxt[0];i;i=nxt[i])
    {
        bool flag=true;
        for (int j=0;j<2;j++)
        {
            int nl=l+dic[j][0];
            int nr=r+dic[j][1];
            if (nl<1 || nl>n || nr<1 || nr>n || !a[nl][nr])
                continue;
            flag&=t[sh[i]][a[nl][nr]];
        }
        if (flag)
        {
            a[l][r]=sh[i];
            pre[nxt[i]]=pre[i];
            nxt[pre[i]]=nxt[i];
            dfs(cs+1);
            a[l][r]=0;
            pre[nxt[i]]=i;
            nxt[pre[i]]=i;
        }
    }
    if (cs<n+n)
        st-=a[s[cs-1].first][s[cs-1].second];
}
int main()
{
    scanf("%d",&n);
    if (n==1)
    {
        puts("NO");
        return 0;
    }
    n1=n*n;
    n2=n1 << 1;
    pri[1]=true;
    for (int i=2;i<=n2;i++)
    {
        if (!pri[i])
            prime[++cnt]=i;
        for (int j=1;j<=cnt;j++)
        {
            int g=i*prime[j];
            if (g>n2)
                break;
            pri[g]=true;
            if (i % prime[j]==0)
                break;
        }
    }
    for (int i=1;i<=n1;i++)
        for (int j=1;j<=n1;j++)
            if (i!=j && !pri[i+j])
                t[i][j]=true;
    for (int i=1;i<=n;i++)
        for (int j=1;j<=n;j++)
            if (i!=1 || j!=1)
                tot++,sh[tot]=tot+1;
    nxt[0]=1;
    for (int i=1;i<=tot;i++)
        pre[i]=i-1,nxt[i]=i+1;
    nxt[tot]=0;
    for (int i=2;i<=n;i++)
        s[++kt]=mp(1,i);
    for (int i=2;i<=n;i++)
        s[++kt]=mp(i,1);
    for (int i=2;i<=n;i++)
        for (int j=2;j<=n;j++)
            s[++kt]=mp(i,j);
    a[1][1]=1;
    dfs(1);
    if (rans==1000000007)
        puts("NO"); else
        {
            for (int i=1;i<=n;i++)
            {
                for (int j=1;j<=n;j++)
                    printf("%d ",ans[i][j]);
                putchar('\n');
            }
        }
    return 0;
}
```

还有一个剪枝，我们可以**行列交替**搜索，避免刚开始搜索时，较小的数字大部分处于数组上部，较大的数字被迫在数组下部搜索，我们知道，较大的数字中质数分布是较少的，所以让小数字与大数字匹配更优，反正我们已经保证了第一行第一列是用较小的数字搜的，其他位置是没有必要控制大小的。**行列交替**搜索使得大小数字较均匀分布，更易搜出最优解

$But,$剩下的$3$个点，真的是怎么减都减不下来了

由于这道题是**最优解**问题，而非**任意解**问题，因此搜索不得不在已经搜到一个答案后重新回溯，这给我们的搜索带来了很大负担

考虑如何转化成**任意解**问题，显然，当**当前解**已经达到了**最优解的下限**时，我们就可以直接输出了

我们首先可以找到一个**最优解的下限**$(2n-1)n$，那就是第一行第一列取遍$1 \sim 2n-1$的情况，此时已经没有更优解了

实际上，在$n$为偶数时，我们可以提高下限

为什么呢？

首先，$1 \sim 2n-1$有$n$个奇数和$n-1$个偶数

为了保证相邻的$x,y$和为质数，由于$x+y>2$，$x+y$为奇数，所以所有的$(x,y)$都是一奇一偶的，那么第一行奇偶交错，有$\frac{n}{2}$个奇数和$\frac{n}{2}$个偶数，同样第一列也奇偶交错，有$\frac{n}{2}$个奇数和$\frac{n}{2}$个偶数

由于$(1,1)$位置的数$1$被重复计算两次，最终第一行第一列共有$n-1$个奇数和$n$个偶数，矛盾了

所以下限被提高到$(2n-1)n+1$

那么我们先搜索**最优解的下限**，可以当成**任意解**处理，搜到一个直接退出

由于我们钦定要搜下限，那么如果是奇数，第一行第一列只能在$1 \le x \le 2n-1$中取，如果是偶数，第一行第一列只能在$1 \le x \le 2n$且$x\ne 2n-1$中取（因为和为$(2n-1)n+1$）

如果搜不到**最优解的下限**，我们就按原来的暴搜再搜一次

这样我们就可以$AC$了

注：不开$O2$还真$AC$不了，主要是$n=9$搜了很久，其他点在开$O2$情况下最大的只跑了$85ms$，在不开$O2$情况下最大的也只跑了$218ms$

$Code:$

```cpp
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize("-O2")
#pragma GCC optimize("-O3")
#pragma GCC optimize("inline")
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#define pr pair<int,int>
#define mp make_pair
#define N 15
#define N1 105
#define N2 205
using namespace std;
int st,n,n0,n1,n2,lim,cnt,tot,kt,prime[N2],sh[N1],q[N1],a[N][N];
int pre[N1],nxt[N1];
int q1[N1][N1];
int q2[N1][N1][N1];
bool pri[N2],t[N1][N1];
pr s[N1];
bool vis[N1];
int dic[2][2]={{0,-1},{-1,0}};
int rans=1000000007,ans[N][N];
void dfs(int cs)
{
    if (cs==n1)
    {
        for (int i=1;i<=n;i++)
        {
            for (int j=1;j<=n;j++)
                printf("%d ",a[i][j]);
            putchar('\n');
        }
        exit(0);
        return;
    }
    int l=s[cs].first;
    int r=s[cs].second;
    if (cs<n0-1)
    {
        int k,o;
        if (l==1)
            k=a[l][r-1]; else
            k=a[l-1][r];
        if (n & 1)
        {
            for (int i=2;i<n0;i++)
                if (!vis[i] && t[i][k])
                {
                    vis[i]=true;
                    a[l][r]=i;
                    dfs(cs+1);
                    vis[i]=false;
                }
        } else
        {
            for (int i=2;i<=n0;i++)
                if (!vis[i] && t[i][k])
                {
                    if (i==n0-1)
                        continue;
                    vis[i]=true;
                    a[l][r]=i;
                    dfs(cs+1);
                    vis[i]=false;
                }
        }
        
    } else
    {
        int k1=a[l][r-1],k2=a[l-1][r];
        for (int i=1;i<=q2[k1][k2][0];i++)
            if (!vis[q2[k1][k2][i]])
            {
                vis[q2[k1][k2][i]]=true;
                a[l][r]=q2[k1][k2][i];
                dfs(cs+1);
                vis[q2[k1][k2][i]]=false;
            }
    }
}
void dfs2(int cs)
{
    if (cs<n+n)
        st+=a[s[cs-1].first][s[cs-1].second];
    if (st>=rans)
    {
        if (cs<n+n)
            st-=a[s[cs-1].first][s[cs-1].second];
        return;
    }
    if (cs==n1)
    {
        rans=st;
        for (int i=1;i<=n;i++)
            for (int j=1;j<=n;j++)
                ans[i][j]=a[i][j];
        return;
    }
    int l=s[cs].first;
    int r=s[cs].second;
    for (int i=nxt[0];i;i=nxt[i])
    {
        bool flag=true;
        for (int j=0;j<2;j++)
        {
            int nl=l+dic[j][0];
            int nr=r+dic[j][1];
            if (nl<1 || nl>n || nr<1 || nr>n || !a[nl][nr])
                continue;
            flag&=t[sh[i]][a[nl][nr]];
        }
        if (flag)
        {
            a[l][r]=sh[i];
            pre[nxt[i]]=pre[i];
            nxt[pre[i]]=nxt[i];
            dfs2(cs+1);
            a[l][r]=0;
            pre[nxt[i]]=i;
            nxt[pre[i]]=i;
        }
    }
    if (cs<n+n)
        st-=a[s[cs-1].first][s[cs-1].second];
}
int main()
{
    scanf("%d",&n);
    if (n==1)
    {
        puts("NO");
        return 0;
    }
    n0=n+n;
    n1=n*n;
    n2=n1 << 1;
    pri[1]=true;
    for (int i=2;i<=n2;i++)
    {
        if (!pri[i])
            prime[++cnt]=i;
        for (int j=1;j<=cnt;j++)
        {
            int g=i*prime[j];
            if (g>n2)
                break;
            pri[g]=true;
            if (i % prime[j]==0)
                break;
        }
    }
    for (int i=1;i<=n1;i++)
        for (int j=1;j<=n1;j++)
            if (i!=j && !pri[i+j])
                q[i]++,q1[i][q[i]]=j,t[i][j]=true;
    for (int i=1;i<=n1;i++)
        for (int j=1;j<=n1;j++)
            if (i!=j)
                for (int k=1;k<=n1;k++)
                    if (k!=i && k!=j)
                        if (!pri[i+k] && !pri[j+k])
                            q2[i][j][++q2[i][j][0]]=k;
    for (int i=2;i<=n;i++)
        s[++kt]=mp(1,i);
    for (int i=2;i<=n;i++)
        s[++kt]=mp(i,1);
    for (int i=2;i<=n;i++)
    {
        for (int j=1;j<=n-i+1;j++)
            s[++kt]=mp(i,i+j-1);
        for (int j=2;j<=n-i+1;j++)
            s[++kt]=mp(i+j-1,i);
    }
    a[1][1]=1;
    vis[1]=true;
    lim=n*(n0-1)+1;
    dfs(1);
    memset(a,0,sizeof(a));
    a[1][1]=1;
    for (int i=1;i<=n;i++)
        for (int j=1;j<=n;j++)
            if (i!=1 || j!=1)
                tot++,sh[tot]=tot+1;
    nxt[0]=1;
    for (int i=1;i<=tot;i++)
        pre[i]=i-1,nxt[i]=i+1;
    nxt[tot]=0;
    dfs2(1);
    if (rans==1000000007)
        puts("NO"); else
        {
            for (int i=1;i<=n;i++)
            {
                for (int j=1;j<=n;j++)
                    printf("%d ",ans[i][j]);
                putchar('\n');
            }
        }
    return 0;
}
```


---

## 作者：junble19768 (赞：7)

~~没人发题解的吗~~ 

这道题数据有锅,所以这篇题解可能~~一定~~AC不了.

就说下思路吧, 这道题肯定要爆搜打表, 但是普通的爆搜要么WA要么要等一个下午, 所以需要~~玄学~~优化.

具体优化就是预处理出每个数字后面可以跟什么,然后放到vector里.

由于 第一行和第一列 与 其他位置 限制条件不同(其实也没啥不同,当时脑抽了)
 . 所以分为两部分 , 分别记录进 nex[i] 和 abnex[i][j] 里.然后dfs的时候只搜vector里的数字.

为了保证正确 , 将dfs分为两部分 , 第一部分搜索第一行和第一列的填法 , 第二部分搜索该方法是否可行并返回 true 或 false . 

同时为了保证不用等很久 , 搜到一个先输出 , 然后接着搜 . 

有能力的可以写一个模拟退火 , ~~反正我是不会,打表挺好的.~~

打表程序:

```cpp
#include <cstdio>
#include <algorithm>
#include <ctime>
#include <iostream>
#include <cstdlib>
#include <cstring>
#include <vector>
using namespace std;
vector<int> nex[200],abnex[200][200];
int canbe[200][200];
int num[210],p[100],cnt;
int map[20][20],book[200];
int n;
int ans=0x3f3f3f;
int ansmap[20][20];

inline void init()
{
    memset(num,1,sizeof num);
    num[1]=0; num[0]=0;
    for(register int i=2;i<=200;i++)
    {
        if(num[i]) p[++cnt]=i;
        for(register int j=1;j<=cnt && p[j]*i<=200;j++)
        {
            num[p[j]*i]=0;
            if(i%p[j]==0) break;
        }
    }

    for(register int i=1;i<=n*n;i++)
    {
        for(register int j=1;j<=n*n;j++)
        {
            if(j==i) continue;
            if(num[j+i]) canbe[i][j]=1,nex[i].push_back(j);
        }
        sort(nex[i].begin(),nex[i].end());
    }
    for(register int i=1;i<=n*n;i++)
        for(register int j=1;j<=n*n;j++)
        {
            if(i==j) continue;
            for(register int k=1;k<=n*n;k++)
            {
                if(i==k || j==k) continue;
                if(num[i+k] && num[j+k]) abnex[i][j].push_back(k);
            }
            sort(abnex[i][j].begin(),abnex[i][j].end());
        }
}
inline bool dfs2(int x,int y)
{
    if(y==n+1) x++,y=2;
    if(x==n+1) return true;
    int up=map[x-1][y],lef=map[x][y-1];
    for(register int i=abnex[up][lef].size()-1;i>=0;i--)
    {
        int nownum=abnex[up][lef][i];
        if(!book[nownum])
        {
            book[nownum]=1; map[x][y]=nownum;
            if(dfs2(x,y+1)){ book[nownum]=0;return true; }  
            book[nownum]=0;
        }
    }
    return false;
}
inline void dfs1(int x,int y,int nowans)
{
    if(nowans>=ans) return ;
    if(y==n+1) x++,y=1;
    if(x==1)
    {
        int pre=map[x][y-1];
        for(register int i=0;i<nex[pre].size();i++)
        {
            int nownum=nex[pre][i];
            if(!book[nownum])
            {
                book[nownum]=1;
                map[x][y]=nownum;
                dfs1(x,y+1,nowans+nownum);
                book[nownum]=0;
            }
        }
    }
    else if(y==1 && x<=n)
    {
        int pre=map[x-1][y];
        for(register int i=0;i<nex[pre].size();i++)
        {
            int nownum=nex[pre][i];
            if(!book[nownum])
            {
                book[nownum]=1;
                map[x][y]=nownum;
                dfs1(x+1,y,nowans+nownum);
                book[nownum]=0;
            }
        }
    }
    else 
    {
        if(dfs2(2,2)) 
        {
            ans=nowans;
            memcpy(ansmap,map,sizeof map);
            for(register int i=1;i<=n;i++)
            {
                for(register int j=1;j<=n;j++) printf("%d ",ansmap[i][j]);
                puts("");
            }
        }
    }
}
int main()
{
    scanf("%d",&n);
    init();
    map[1][1]=1;
    book[1]=1;
    dfs1(1,2,1);
    return 0;
}
```


---

## 作者：Vanilla_chan (赞：4)

## Problem&Background

[可以参考这个](https://www.luogu.com.cn/blog/Vanilla-chan/solution-p1549)

非常建议您先去看看这个。

本题解是建立在这一篇的基础上的。

## Solution

首先先完成这道题的普通版本[P1549](https://www.luogu.com.cn/problem/P1549)

A了那一道题之后，您尝试着测一测比较大的数据，结果发现完全没有输出awa

为了AC这道题，您当然可以打表，那么就不必继续看些去了；当然，您也可以继续优化下去——

于是就有了这一篇题解。

在上一篇题解中，我给出了五个剪枝，可以获得`70pts`。接下来继续想一些更加细致的~~剪枝~~。

### ~~剪枝6~~

打表也是一种剪枝——减去比较大的数据——不是吗？

写出`70pts`的代码之后就可以让计算机挂机计算$n>7$这三种情况。

可以同时计算。我的电脑不超过10min就计算出了$n=8$.

以此类推。

## Code

```c++
/**************************************************************
 * Problem: 5512
 * Author: Vanilla_chan
 * Date: 20210315
**************************************************************/
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<map>
#include<set>
#include<queue>
#include<vector>
#include<limits.h>
#define IL inline
#define re register
#define LL long long
#define ULL unsigned long long
#ifdef TH
#define debug printf("Now is %d\n",__LINE__);
#else
#define debug 
#endif
#ifdef ONLINE_JUDGE
char buf[1<<23],* p1=buf,* p2=buf,obuf[1<<23],* O=obuf;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
using namespace std;

template<class T>inline void read(T& x)
{
	char ch=getchar();
	int fu;
	while(!isdigit(ch)&&ch!='-') ch=getchar();
	if(ch=='-') fu=-1,ch=getchar();
	x=ch-'0';ch=getchar();
	while(isdigit(ch)) { x=x*10+ch-'0';ch=getchar(); }
	x*=fu;
}
inline int read()
{
	int x=0,fu=1;
	char ch=getchar();
	while(!isdigit(ch)&&ch!='-') ch=getchar();
	if(ch=='-') fu=-1,ch=getchar();
	x=ch-'0';ch=getchar();
	while(isdigit(ch)) { x=x*10+ch-'0';ch=getchar(); }
	return x*fu;
}
int G[55];
template<class T>inline void write(T x)
{
	int g=0;
	if(x<0) x=-x,putchar('-');
	do { G[++g]=x%10;x/=10; } while(x);
	for(int i=g;i>=1;--i)putchar('0'+G[i]);putchar('\n');
}
#define M 210
#define N 20
int n;
bool book[M];
int prime[M][M];
void init()
{
	book[1]=1;
	for(int i=2;i<=200;i++)
	{
		if(!book[i])
		{
			for(int j=2;i*j<=200;j++)
			{
				book[i*j]=1;
			}
		}
	}
	for(int i=1;i<=n*n;i++)
		for(int j=1;j<=n*n;j++)
			prime[i][j]=book[i+j];
}
int ans;
int ANS[N][N];
int now[N][N];
bool vis[M];
int dt[4][2]={0,1,0,-1,1,0,-1,0};
IL bool exist(int x)
{
	return x>=1&&x<=n;
}
bool check(int x,int y)
{
	for(int t=0;t<4;t++)
	{
		if(exist(x+dt[t][0])&&exist(y+dt[t][1]))
		{
			if(now[x+dt[t][0]][y+dt[t][1]]!=0)
			{
				if(prime[now[x][y]][now[x+dt[t][0]][y+dt[t][1]]])
				{
					return 0;
				}
			}
		}
	}
	return 1;
}
void dfs3(int x,int y,int sum)
{
	if(sum>=ans) return;
	if(y==n+1) y=2,x++;
	if(x==n+1)
	{
		ans=sum;
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=n;j++)
			{
				ANS[i][j]=now[i][j];
			}
		}
		return;
	}
	for(int i=n*n;i>=1;i--)
	{
		if(vis[i]) continue;
		vis[i]=1;
		now[x][y]=i;
		if(check(x,y)) dfs3(x,y+1,sum);
		vis[i]=0;
		now[x][y]=0;
	}
}
void dfs2(int y,int sum)
{
	if(sum>=ans) return;
	if(y==n+1)
	{
		dfs3(2,2,sum);
		return;
	}
	for(int i=1;i<=n*n;i++)
	{
		if(vis[i]) continue;
		vis[i]=1;
		now[1][y]=i;
		if(check(1,y)) dfs2(y+1,sum+i);
		now[1][y]=0;
		vis[i]=0;
	}
}
void dfs1(int x,int sum)
{
	if(sum>=ans) return;
	if(x==n+1)
	{
		dfs2(2,sum);
		return;
	}
	for(int i=1;i<=n*n;i++)
	{
		if(vis[i]) continue;
		vis[i]=1;
		now[x][1]=i;
		if(check(x,1)) dfs1(x+1,sum+i);
		vis[i]=0;
		now[x][1]=0;
	}
}
int main()
{
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	n=read();
	if(n>=8)
	{
		if(n==8)
		{
			cout<<"1 2 3 4 7 6 5 14"<<endl;
			cout<<"12 17 20 27 34 25 18 23"<<endl;
			cout<<"11 26 21 32 39 28 61 36"<<endl;
			cout<<"8 15 46 51 58 31 48 35"<<endl;
			cout<<"9 22 57 52 55 42 41 62"<<endl;
			cout<<"10 19 40 49 54 47 56 45"<<endl;
			cout<<"13 24 43 60 53 50 33 64"<<endl;
			cout<<"16 37 30 29 44 59 38 63"<<endl;
		}
		if(n==9)
		{
			cout<<"1 2 3 4 7 6 5 8 9"<<endl;
			cout<<"10 21 20 27 34 25 18 23 38"<<endl;
			cout<<"13 40 33 26 45 28 19 24 35"<<endl;
			cout<<"16 31 76 81 68 69 70 79 72"<<endl;
			cout<<"15 22 51 56 71 80 57 52 37"<<endl;
			cout<<"14 39 62 41 60 47 32 75 64"<<endl;
			cout<<"17 44 65 48 49 54 77 74 63"<<endl;
			cout<<"12 29 42 55 58 73 36 53 50"<<endl;
			cout<<"11 30 67 46 43 66 61 78 59"<<endl;
		}
		if(n==10)
		{
			cout<<"1 2 3 4 7 6 5 8 9 10"<<endl;
			cout<<"12 29 38 33 34 25 36 23 44 27"<<endl;
			cout<<"11 30 59 68 45 28 43 24 35 26"<<endl;
			cout<<"18 41 42 71 56 75 64 37 66 47"<<endl;
			cout<<"13 48 19 60 53 98 93 100 91 90"<<endl;
			cout<<"16 31 40 97 54 83 74 99 82 67"<<endl;
			cout<<"15 22 49 52 55 96 77 80 57 46"<<endl;
			cout<<"14 39 58 79 72 95 62 87 70 61"<<endl;
			cout<<"17 50 51 88 85 78 89 92 81 76"<<endl;
			cout<<"20 21 32 69 94 73 84 65 86 63"<<endl;
		}
		return 0;
	}
	init();
	now[1][1]=1;
	vis[1]=1;
	ans=100000;
	dfs1(2,0);
	if(ans==100000) cout<<"NO"<<endl;
	else
	{
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=n;j++)
			{
				cout<<ANS[i][j]<<" ";
			}
			cout<<endl;
		}
	}
	return 0;
}
```



---


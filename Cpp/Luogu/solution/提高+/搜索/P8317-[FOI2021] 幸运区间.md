# [FOI2021] 幸运区间

## 题目背景

2021 年福建省青少年信息学编程水平认证 第四题。

## 题目描述

一个抽奖活动正在进行。每个参加活动的人拿到了 $n$ 个序列，每个序列包含了 $d$ 个正整数，以及一个数字 $k$，代表这些正整数中，存在 $k$ 个幸运数字。

每个拿到序列的人，会从自己手中的序列中选出连续的若干个序列形成一个区间，称之为待选区间。如果待选区间中的每一个序列都包含至少一个幸运数字，则称该区间为幸运区间。当然幸运区间可能不止一个。游戏规定，其中包含的序列最多的即总长度最长的那个幸运区间称为超级幸运区间。

例如：$d=2,k=3$ 时，序列如下：

- 序列 $0$：``115 120``。
- 序列 $1$：``50 80``。
- 序列 $2$：``199 30``。
- 序列 $3$：``40 40``。
- 序列 $4$：``30 30``。
- 序列 $5$：``25 40``。

从序列 $0$ 到序列 $2$ 的区间是幸运区间，因为从 $0$ 到 $2$ 中的每个序列都包含了 $120,50$ 或 $30$，共 $3$ 个幸运数字。从序列 $1$ 到序列 $5$ 的区间也是幸运区间，因为 $1$ 到 $5$ 的所有序列都包含 $80,30$ 或 $40$，并且包含了 $5$ 个序列，是总长度最大的超级幸运区间。

每个有序列的人都想知道自己的超级幸运区间是怎样的。编程任务就是对于每个拿到序列的人，输出总长度最大的超级幸运区间的第一个元素的下标和最后一个元素的下标。如果有多个长度一样的，输出第一个元素下标最小的。请注意下标从 $0$ 开始。

## 说明/提示

#### 数据范围

对于 $45\%$ 的数据，$n\le1000$。

对于 $50\%$ 的数据，$k=2$。

前两部分数据共计 $70\%$。

对于 $100\%$ 的数据，$2\le k\le 3$。

输入文件在 $\text{4.8M}$ 以内，$T=10,1\le d\le 4,1\le$ 每个序列中的数字 $\le10^5$。

对于最多 $6$ 个 $\text{case}$，$1\le n\le 10^5$，对于其他所有的 $\text{case}$，$1\le n\le 10^3$。

## 样例 #1

### 输入

```
4
8 1 2
1 2 3 2 4 5 4 6
4 3 2
1 2 3 4 5 6 7 8 9 10 11 12
6 2 3
10 20 50 60 70 30 40 40 30 30 20 40
10 1 3
2 4 3 1 4 5 3 1 1 2```

### 输出

```
Case #1: 1 3
Case #2: 0 1
Case #3: 1 5
Case #4: 1 4```

# 题解

## 作者：luckydrawbox (赞：4)

[$\text{Link}$](https://www.luogu.com.cn/problem/P8317)

自己供的第一道题。

## 题意

给出 $n$ 个数列，编号为 $0\sim n-1$，每个数列有 $d$ 个正整数。

对于一段区间 $[l,r]$，从序列 $l$ 到 $r$ 中的数字中选出不超过 $k$ 个数字，称之为**幸运数字**。若存在一种情况使每个区间至少包含一个选出的幸运数字，则称区间 $[l,r]$ 为**幸运区间**，并且把这 $n$ 个数列构成的区间中**长度最大**的幸运区间成为**超级幸运区间**。

求这 $n$ 个数列的超级幸运区间。

## 分析

### 算法一

观察到 $d,k$ 超级小，所以每次加入一个序列时只有看看该序列是否有幸运数字，没有则暴搜增加幸运数字。

枚举区间的起点，然后一直向右加数字知道不能加为止，其中用一个数组来记录幸运数字，然后统计答案。

时间复杂度 $\text{O}(tn^2d^{k+1}k)$，期望得分 $\texttt{45-60}$ 分。

### 算法二

主要是枚举区间花了太多时间，于是我们考虑用分治减少枚举的区间。

设 $\text{solve}(l,r)$ 表示计算区间左右端点都在 $[l,r]$ 内的区间的答案，设 $mid=\left\lfloor\dfrac{l+r}{2}\right\rfloor$，则该问题可以分成以下几个子问题求解：

- $\text{solve}(l,mid-1)$。前提是 $l\le mid-1$。这时区间在 $mid$ 左侧。
- $\text{solve}(mid+1,r)$。前提是 $mid+1\le r$。这时区间在 $mid$ 右侧。
- 一定经过数列 $mid$ 的幸运区间。

前两个子问题直接递归求解，第三个则按照算法一的方法进行计算，只不过可以从两个方向增加数列。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
long long read(){
	long long x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
void write(long long x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
const int N=1e5+10;
int t,n,d,k,a[N][5],mx,ml,mr,luck[5],sum;
void dfs(int l,int r,int L,int R){
	bool f=0;
	do{//向左扩展
		if(L-1<l)
			break;
		f=0;
		for(int i=1;i<=d;i++)
			for(int j=1;j<=sum;j++)
				f|=(a[L-1][i]==luck[j]);
		if(f)
			L--;
	}while(f);
	do{//向右扩展
		if(R+1>r)
			break;
		f=0;
		for(int i=1;i<=d;i++)
			for(int j=1;j<=sum;j++)
				f|=(a[R+1][i]==luck[j]);
		if(f)
			R++;
	}while(f);
	if(mx<R-L+1||(mx==R-L+1&&L<ml)){
		mx=R-L+1;
		ml=L;
		mr=R;
	}
	if(sum==k||(l==L&&r==R))
		return;
	if(l!=L){//向左增加幸运数字
		for(int i=1;i<=d;i++){
			luck[++sum]=a[L-1][i];
			dfs(l,r,L-1,R);
			sum--;
		}
	}
	if(r!=R){//向右增加幸运数字
		for(int i=1;i<=d;i++){
			luck[++sum]=a[R+1][i];
			dfs(l,r,L,R+1);
			sum--;
		}
	}
}
void solve(int l,int r){
	if(l==r){
		if(mx<1||(mx==1&&l<ml)){//更新答案
			mx=1;
			ml=mr=l;
		}
		return;
	}
	int mid=(l+r)>>1;
	if(l<=mid-1)
		solve(l,mid-1);
	if(mid+1<=r)
		solve(mid+1,r);
	sum=1;
	for(int i=1;i<=d;i++){
		luck[sum]=a[mid][i];
		dfs(l,r,mid,mid);
	}
}
int main(){
	t=read();
	for(int ii=1;ii<=t;ii++){
		n=read();d=read();k=read();
		for(int i=0;i<n;i++)
			for(int j=1;j<=d;j++)
				a[i][j]=read();
		mx=0;
		solve(0,n-1);
		printf("Case #%d: %d %d\n",ii,ml,mr);
	}
	return 0;
}
```

时间复杂度 $\text{O}(tn\log n\ d^{k+1}k)$，期望得分 $\texttt{70}$ 分。不过开 $\texttt{O2}$ 后足够过了。

### 算法三

其实还可以增加一个小优化，原来在向左右扩展的过程中我们都是用 $dk$ 的时间来判断是否可以直接扩展，然而我们只要把用数组记录幸运数字改成用桶记录，就可以去掉 $k$。

你可能会问，$k$ 不是 $2$ 或 $3$ 吗，你去了 $k$ 和去常数有啥区别？不过搜索本来就十分玄学，去了 $k$ 以后就可以玄学地节省许多时间了。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
long long read(){
	long long x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
void write(long long x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
const int N=1e5+10;
int t,n,d,k,a[N][5],mx,ml,mr,luck[5],sum;
bool v[N];//用桶记录某个数字是否是幸运数字
void dfs(int l,int r,int L,int R){
	bool f=0;
	do{
		if(L-1<l)
			break;
		f=0;
		for(int i=1;i<=d;i++)
			f|=v[a[L-1][i]];
		if(f)
			L--;
	}while(f);
	do{
		if(R+1>r)
			break;
		f=0;
		for(int i=1;i<=d;i++)
			f|=v[a[R+1][i]];
		if(f)
			R++;
	}while(f);
	if(mx<R-L+1||(mx==R-L+1&&L<ml)){
		mx=R-L+1;
		ml=L;
		mr=R;
	}
	if(sum==k||(l==L&&r==R))
		return;
	if(l!=L){
		for(int i=1;i<=d;i++){
			sum++;
			v[a[L-1][i]]=1;
			dfs(l,r,L-1,R);
			v[a[L-1][i]]=0;
			sum--;
		}
	}
	if(r!=R){
		for(int i=1;i<=d;i++){
			sum++;
			v[a[R+1][i]]=1;
			dfs(l,r,L,R+1);
			v[a[R+1][i]]=0;
			sum--;
		}
	}
}
void solve(int l,int r){
	if(l==r){
		if(mx<1||(mx==1&&l<ml)){
			mx=1;
			ml=mr=l;
		}
		return;
	}
	int mid=(l+r)>>1;
	if(l<=mid-1)
		solve(l,mid-1);
	if(mid+1<=r)
		solve(mid+1,r);
	sum=1;
	for(int i=1;i<=d;i++){
		v[a[mid][i]]=1;
		dfs(l,r,mid,mid);
		v[a[mid][i]]=0;
	}
}
int main(){
	t=read();
	for(int ii=1;ii<=t;ii++){
		n=read();d=read();k=read();
		for(int i=0;i<n;i++)
			for(int j=1;j<=d;j++)
				a[i][j]=read();
		mx=0;
		solve(0,n-1);
		printf("Case #%d: %d %d\n",ii,ml,mr);
	}
	return 0;
}
```

时间复杂度 $\text{O}(tn\log n\ d^{k+1})$，期望得分 $\texttt{100}$ 分。

---

## 作者：Thunder_S (赞：1)

## Solution

读题，注意到 $d$ 和 $k$ 都很小，这很有可能是突破口。

由于 $d,k$ 很小，考虑直接搜索求解。

一个朴素的搜索是枚举区间，然后在区间内暴力判断是否合法。时间复杂度 $\mathcal O(Tn^2d^{k+1}k)$（$\mathcal O(n^2)$ 枚举，$\mathcal O(d^{k+1}k)$ 判断）。

简单地计算了一下发现是过不去的，考虑对其优化。

后面的搜索判断已经很难继续优化了，于是优化枚举区间。联想到 cdq 分治，于是将循环枚举区间改为分治区间。

具体来说，每次处理区间 $[l,r]$ 中的答案，其由三部分得到：$[l,mid-1],[mid+1,r]$ 和一定选择 $mid$ 的答案。

前面两个可以继续分治下去，第三个直接暴力求解。

注意这里的暴力是向两边扩展，每次先找到无需添加幸运数字的最大区间，然后添加一个幸运数字，继续向下递归。

## Code

```cpp
#include<cstdio>
#include<cstring>
#define N 100005
using namespace std;
int T,n,d,m,mx,mxl,mxr,num,a[N][5];
bool t[N];
void dg(int ll,int rr,int l,int r)
{
    while (l>ll)
    {
        bool bj=false;
        for (int i=1;i<=d;++i)
            bj|=t[a[l-1][i]];
        if (bj) --l;
        else break; 
    }
    while (r<rr)
    {
        bool bj=false;
        for (int i=1;i<=d;++i)
            bj|=t[a[r+1][i]];
        if (bj) ++r;
        else break;
    }
    if ((mxr-mxl+1<r-l+1)||(mxr-mxl+1==r-l+1&&mxl>l)) mxl=l,mxr=r;
    if (num==m) return;
    if (l>ll)
    {
        for (int i=1;i<=d;++i)
        {
            ++num;
            t[a[l-1][i]]=true;
            dg(ll,rr,l-1,r);
            t[a[l-1][i]]=false;
            --num;
        }
    }
    if (r<rr)
    {
        for (int i=1;i<=d;++i)
        {
            ++num;
            t[a[r+1][i]]=true;
            dg(ll,rr,l,r+1);
            t[a[r+1][i]]=false;
            --num;
        }
    }
}
void solve(int l,int r)
{
    if (l==r) return;
    int mid=(l+r)>>1;
    if (l<mid) solve(l,mid-1);
    if (r>mid) solve(mid+1,r);
    num=1;
    for (int i=1;i<=d;++i)
    {
        t[a[mid][i]]=true;
        dg(l,r,mid,mid);
        t[a[mid][i]]=false;
    }
}
int main()
{
    scanf("%d",&T);
    for (int nowturn=1;nowturn<=T;++nowturn)
    {
        mxl=mxr=1;memset(t,false,sizeof(t));
        scanf("%d%d%d",&n,&d,&m);
        for (int i=1;i<=n;++i)
            for (int j=1;j<=d;++j)
                scanf("%d",&a[i][j]);
        solve(1,n);
        printf("Case #%d: %d %d\n",nowturn,mxl-1,mxr-1);
    }
    return 0;
}
```

---


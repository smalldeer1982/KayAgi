# [蓝桥杯 2023 省 A] 买瓜

## 题目描述

小蓝正在一个瓜摊上买瓜。瓜摊上共有 $n$ 个瓜，每个瓜的重量为 $A_i$。小蓝刀功了得，他可以把任何瓜劈成完全等重的两份，不过每个瓜只能劈一刀。

小蓝希望买到的瓜的重量的和恰好为 $m$。

请问小蓝至少要劈多少个瓜才能买到重量恰好为 $m$ 的瓜。如果无论怎样小蓝都无法得到总重恰好为 $m$ 的瓜，请输出 $-1$。

## 说明/提示

#### 【评测用例规模与约定】

对于 $20 \%$ 的评测用例，$n \leq 10$;

对于 $60 \%$ 的评测用例，$n \leq 20$;

对于所有评测用例，$1 \leq n \leq 30$，$1 \leq A_i \leq 10^9$，$1 \leq m \leq 10^9$。

## 样例 #1

### 输入

```
3 10
1 3 13```

### 输出

```
2```

# 题解

## 作者：ivyjiao (赞：150)

## 题意简（？）述：

经过上一次惨痛的经历后，郝哥痛改前非，不再卖生瓜蛋子，秤也没有了吸铁石。然而刘华强并不打算放过他。

有一个人再来买瓜。

郝哥望着那辆熟悉的摩托车，没等华强发话，便喊道：“$10^{{10}^{-9961}}$ 块钱一斤！没有大棚瓜！保熟！”

“给我挑亿个！”

郝哥刚转过身，看个架子上 $n$ 个分别重 $a_i$ 斤的瓜，刚想挑瓜，华强又说：“今天我要请宋大哥吃答辩，得买 $m$ 斤西瓜，你这瓜保够吗？”

郝哥明白，华强又来找茬了。

华强拿起了上次他劈西瓜和郝哥的刀，对郝哥说：“你这瓜要是管够我肯定要啊，那它要是不够怎么办啊？”

郝哥知道，华强刀功了得，他可以把任何瓜劈成完全等重的两份，不过每个瓜只劈一刀，尽管华强可以以很短的时间劈开一个瓜（$<10^{{10}^{-9961}} s$），不过他不想白费力气，他想让郝哥在 $1s$ 之内告诉他最少需要劈几个瓜，否则就要劈了郝哥。

郝哥不想再被劈一刀，所以他找到了你。

如果郝哥无论如何都会被劈（没有任何一种可行方案能让华强买到他想要重量的瓜）。输出 `-1`。

## part one：

直接爆搜加一个人人都会的剪枝就行了，时间复杂度 $O(3^n)$。

```
#include<iostream>
using namespace std;
int n,a[31],ans=114514;
long long m;
void LHQ(int G,int P,int J,long long sum){
    if(sum>m) return;
    if(G>n){
        //cout<<sum<<endl;
        if(sum==m) ans=min(ans,J);
        return;
    }
    if(P==0) sum+=a[G]*2;
    else if(P==1) sum+=a[G],J++;
    for(int i=0;i<3;i++) LHQ(G+1,i,J,sum);
}
int main(){
    cin>>n>>m;
    m*=2;
    for(int i=1;i<=n;i++) cin>>a[i];
    for(int i=0;i<3;i++) LHQ(1,i,0,0);
    cout<<ans;
}
```

这个怎么样？

![](https://cdn.luogu.com.cn/upload/image_hosting/wb6rkbaj.png?x-oss-process=image/resize,m_lfit,h_1700,w_2250)

………外卖……萨日朗……郝哥萨日朗……

## part two：

考虑折半搜索，时间复杂度 $O(3^{\frac n 2})$。

```
#include<iostream>
#include<unordered_map>
using namespace std;
int n,N,a[31],ans=114514;
long long m;
unordered_map <int,int> PII;
void LHQ(int G,int P,int J,long long sum){
    if(sum>m) return;
    if(sum==m){
        PII[sum]=J;
        return;
    }
    if(G==N+1){
        if(sum<=m) PII[sum]=J;
        return;
    }
    if(P==0) sum+=a[G]*2;
    else if(P==1) sum+=a[G],J++;
    for(int i=0;i<3;i++) LHQ(G+1,i,J,sum);
}
void HG(int G,int P,int J,long long sum){
    if(sum>m) return;
    if(sum==m){
        ans=min(ans,PII[sum]+J);
        return;
    }
    if(G==n+1){
        //cout<<sum<<endl;
        if(sum<=m&&PII.count(m-sum)) ans=min(ans,PII[m-sum]+J);
        return;
    }
    if(P==0) sum+=a[G]*2;
    else if(P==1) sum+=a[G],J++;
    for(int i=0;i<3;i++) HG(G+1,i,J,sum);
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin>>n>>m;
    N=n/2;
    m*=2;
    for(int i=1;i<=n;i++) cin>>a[i];
    for(int i=0;i<3;i++) LHQ(1,i,0,0);
    for(int i=0;i<3;i++) HG(N+1,i,0,0);
    if(ans>100000) cout<<-1;
    else cout<<ans;
}
```

这个怎么样？

![](https://cdn.luogu.com.cn/upload/image_hosting/iwjybyli.png?x-oss-process=image/resize,m_lfit,h_1700,w_2250)

………外卖……萨日朗……郝哥萨日朗……

## part three：

时间复杂度肯定是没假的，不可能比这更低了。

考虑剪枝优化。

最优性剪枝：当现在劈瓜的个数已经比目前最优的个数多了，就不用再继续搜下去了。

```
#include<iostream>
#include<unordered_map>
using namespace std;
int n,N,a[31],ans=114514;
long long m;
unordered_map <int,int> PII;
void LHQ(int G,int P,int J,long long sum){
    if(sum>m) return;
    if(sum==m){
        PII[sum]=J;
        return;
    }
    if(G==N+1){
        if(sum<=m) PII[sum]=J;
        return;
    }
    if(P==0) sum+=a[G]*2;
    else if(P==1) sum+=a[G],J++;
    for(int i=0;i<3;i++) LHQ(G+1,i,J,sum);
}
void HG(int G,int P,int J,long long sum){
    if(sum>m||J>ans) return;
    if(sum==m){
        ans=min(ans,PII[sum]+J);
        return;
    }
    if(G==n+1){
        //cout<<sum<<endl;
        if(sum<=m&&PII.count(m-sum)) ans=min(ans,PII[m-sum]+J);
        return;
    }
    if(P==0) sum+=a[G]*2;
    else if(P==1) sum+=a[G],J++;
    for(int i=0;i<3;i++) HG(G+1,i,J,sum);
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    cin>>n>>m;
    N=n/2;
    m*=2;
    for(int i=1;i<=n;i++) cin>>a[i];
    for(int i=0;i<3;i++) LHQ(1,i,0,0);
    for(int i=0;i<3;i++) HG(N+1,i,0,0);
    if(ans==114514) cout<<-1;
    else cout<<ans;
}
```

这个怎么样？

![](https://cdn.luogu.com.cn/upload/image_hosting/rvqk584z.png?x-oss-process=image/resize,m_lfit,h_1700,w_2250)

………外卖……萨日朗……郝哥萨日朗……

## part four：

很明显不能再进一步剪枝了，我们考虑其它的优化。

优化搜索顺序：把 $a$ 数组进行排序后再搜索。

减少传参：容易发现当前搜索的这个瓜是否被劈不重要，只关心最后总共劈几个就行。

预处理：对 $a$ 数组进行一个后缀和，方便判断超过下界的无解情况。

调整~~块长~~折半的长度：这个需要注意一下调完的长度可能会 $>n$ 或 $<0$，需要避免。

卡时：这个不用我多说了吧！

```
#include<bits/stdc++.h>
using namespace std;
int n,N,ans=114514,m,a[32],b[32],cnt;
unordered_map <int,int> PII;
void LHQ(int G,int J,int sum){
    cnt++;
    if(cnt>7e6) return;
    if(sum>m) return;
    if(G==N+1){
        if(PII[sum]) PII[sum]=min(PII[sum],J+1);
        else PII[sum]=J+1;
        return;
    }
    LHQ(G+1,J,sum+a[G]);
    LHQ(G+1,J+1,sum+a[G]/2);
    LHQ(G+1,J,sum);
}
void HG(int G,int J,int sum){
    cnt++;
    if(cnt>1.5e7){
        cout<<ans<<endl;
        return;
    }
    if(sum>m||J>ans) return;
    if(sum==m){
        ans=min(ans,PII[sum]+J);
        return;
    }
    if(G==n+1){
        if(PII[m-sum]) ans=min(ans,J+PII[m-sum]-1);
        return;
    }
    HG(G+1,J,sum+a[G]);
    HG(G+1,J+1,sum+a[G]/2);
    HG(G+1,J,sum);
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin>>n>>m;
    N=n/2;
    m*=2;
    for(int i=1;i<=n;i++) cin>>a[i],a[i]*=2;
    sort(a+1,a+1+n);
    LHQ(1,0,0);
    HG(N+1,0,0);
    if(ans==114514) cout<<-1;
    else cout<<ans;
}
```

这个怎么样？

![](https://cdn.luogu.com.cn/upload/image_hosting/mdy3p95i.png?x-oss-process=image/resize,m_lfit,h_1700,w_2250)

满意了吧？

## part five：

![](https://cdn.luogu.com.cn/upload/image_hosting/lvhho1oa.png?x-oss-process=image/resize,m_lfit,h_1700,w_2250)

What's up，~~你是故意找茬是不是？你要不要吧！~~

你瞅瞅现在哪有瓜？

[大棚](https://www.luogu.com.cn/blog/OperatorNB/noi-ji-lie-jing-sai-ke-yong-di-fei-zhu-liu-ji-qiao)。

```
#include<bits/stdc++.h>
#include<bits/extc++.h>
using namespace std;
using namespace __gnu_pbds;
int n,N,ans=114514,m,a[32],cnt;
long long b[32];
cc_hash_table <int,int> PII;
void LHQ(int G,int J,int sum){
    if(sum>m) return;
    if(sum+b[G]<m) return;
    if(sum==m){
        PII[sum]=J;
        return;
    }
    if(G==N+1){
        if(PII[sum]) PII[sum]=min(PII[sum],J+1);
        else PII[sum]=J+1;
        return;
    }
    LHQ(G+1,J,sum+a[G]);
    LHQ(G+1,J+1,sum+a[G]/2);
    LHQ(G+1,J,sum);
}
void HG(int G,int J,int sum){
    if(sum>m||J>ans) return;
    if(sum==m){
        ans=min(ans,PII[sum]+J);
        return;
    }
    if(G==n+1){
        if(PII[m-sum]) ans=min(ans,J+PII[m-sum]-1);
        return;
    }
    HG(G+1,J,sum+a[G]);
    HG(G+1,J+1,sum+a[G]/2);
    HG(G+1,J,sum);
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin>>n>>m;
    N=min(n/2+1,n-2);
    m*=2;
    for(int i=1;i<=n;i++) cin>>a[i],a[i]*=2;
    sort(a+1,a+1+n);
    for(int i=n;i>=1;i--) b[i]=b[i+1]+a[i];
    LHQ(1,0,0);
    HG(N+1,0,0);
    if(ans==114514) cout<<-1;
    else cout<<ans;
}
```

这个怎么样？

![](https://cdn.luogu.com.cn/upload/image_hosting/don9kehy.png?x-oss-process=image/resize,m_lfit,h_1700,w_2250)

满意了吧？

## 写在最后：

这题从我第一次提交到第一次 AC 共提交了 $135$ 次。

感谢@[waauto](https://www.luogu.com.cn/user/355192) 对我的一些帮助。

---

## 作者：helintai (赞：32)

[题目传送门](https://www.luogu.com.cn/problem/P9234)

1. 对于每一个瓜，有三种状态：
	* 不买这个瓜。
	* 砍一刀，买一半瓜。
	* 不砍，买整个瓜。

2. 为了防止浮点精度爆炸，可以把 $ m\times2 $ ，买一半瓜时就直接加上 $ a_i $ ，买整个瓜就加上 $ a_i\times2 $ 。

3. 用数组存储买到重量为 $sum$ 的瓜要砍几刀可能会炸，可以用 ``` map ``` 存储，而 ``` unordered_map ``` 比 ``` map ``` 更快。

4. 我们很容易就会想到搜索，但朴素的搜索复杂度为 $ O(3^n) $ ，而 $ n \le 30 $ ，一定过不了。所以我们就会用到 __折半搜索__ 。

5. 折半搜索的复杂度为 $ O(3^\frac{n}{2}) $ ，也过不了，所以需要一些优化：
	* 排序，优化搜索顺序。
	* ``` unordered_map ``` 代替 ``` map ``` 。
	* 剪枝，目前重量大于 $ m $ 就不搜了，砍瓜次数大于目前最优解就不搜了。
	* ~~吸氧~~
	* 读入优化，不关同步流时 ``` cin ``` 要比 ``` scanf ``` 慢很多。
	* 位运算。

6. 带注释代码如下 ~~（最后发现吸不吸氧没差别）~~

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<unordered_map>
#define ll long long
#define re register
#define il inline
#define INF 2147483647

using namespace std;

il int read() { // 快读
	re int x = 0, f = 1; re char c = getchar();
	while(c < '0' || c > '9') { if(c == '-') f = -1; c = getchar(); }
	while(c >= '0' && c <= '9') { x = (x << 3) + (x << 1) + (c ^ 48); c = getchar(); }
	return x * f; }

int n, m, ans, N, a[35];
unordered_map<int, int> q;

il void dfs1(int cnt, int sum, int num) {
	// 	cnt表示第几个瓜，sum表示当前买的瓜的总重量，num表示砍了多少刀
	if(sum > m || num > ans) return ;
	//	如果当前重量大于m，不用搜了，直接返回
	// 	如果当前砍瓜次数已经大于目前最优值ans，不用搜了，直接返回
	if(sum == m) { // 如果当前重量刚好等于m
		ans = ans < num ? ans : num; // 更新ans
		return ;
	}
	if(cnt == N + 1) {
		if(sum <= m) {
			if(q.count(sum)) // 查找sum在unordered_map中是否出现
				q[sum] = q[sum] < num ? q[sum] : num;
			else 
				q[sum] = num;
			// 当前重量为sum时最少要砍多少刀
		}
		return ;
	}
	dfs1(cnt + 1, sum, num); // 不买这个瓜
	dfs1(cnt + 1, sum + a[cnt], num + 1); // 买一半瓜
	dfs1(cnt + 1, sum + (a[cnt] << 1), num); // 买整个瓜
	//	a[cnt] << 1 等价于 a[cnt] * 2
}

il void dfs2(int cnt, int sum, int num) {
	// 	cnt表示第几个瓜，sum表示当前买的瓜的总重量，num表示砍了多少刀
	if(sum > m || num > ans) return ;
	//	如果当前重量大于m，不用搜了，直接返回
	// 	如果当前砍瓜次数已经大于目前最优值ans，不用搜了，直接返回
	if(sum == m) { // 如果当前重量刚好等于m
		ans = ans < num ? ans : num;// 更新ans
		return ;
	}
	if(cnt == n + 1) {
		if(q.count(m - sum) && sum <= m) 
			ans = ans < (q[m - sum] + num) ? ans : (q[m - sum] + num); // 更新ans
		return ;
	}
	dfs2(cnt + 1, sum, num); // 不要这个瓜
	dfs2(cnt + 1, sum + a[cnt], num + 1); // 买一半瓜
	dfs2(cnt + 1, sum + (a[cnt] << 1), num); // 买整个瓜
}

int main() {
	n = read(), m = read();
	for(re int i = 1; i <= n; ++ i) a[i] = read();
	m = (m << 1); // 等价于 m *= 2;
	//	防止浮点精度爆炸，把m乘2
	N = (n >> 1); // 等价于 n /= 2;
	sort(a + 1, a + 1 + n); // 优化搜索顺序
	ans = INF; // 求最小值，ans初始值为最大值
	dfs1(1, 0, 0); // 折半搜索
	dfs2(N + 1, 0, 0);
	printf("%d", ans == INF ? -1 : ans);
	//	如果ans没有被更新，说明不可能买到重量恰好为m的瓜，就输出-1
	return 0;
}
```
# [AC辣](https://www.luogu.com.cn/record/121265515)

---

## 作者：andyli (赞：13)

对于每个瓜，显然有三种状态：不买、买一半和买。考虑使用折半搜索，把 $n$ 个瓜分为两部分分别枚举状态，记录每种状态瓜的总重和劈瓜数量，再用哈希表找两边总重为 $m$ 的状态。时间复杂度 $O(3^{\frac{n}{2}})$。  
经测试我的写法 `std::unordered_map` 会 TLE，`gp_hash_table` 会 MLE，所以手写了一个哈希表。  

实现中可以将瓜重和 $m$ 都乘 $2$ 避免出现浮点数。

```cpp
struct map {
    static constexpr u32 P = 20000003, N = 143500000;

    u32 _u[N], _next[N];
    uint8_t _v[N];
    u32 h[P], cnt;

    uint8_t& operator[](u32 u) {
        u32 U = u % P;
        for (u32 i = h[U]; i; i = _next[i])
            if (_u[i] == u)
                return _v[i];
        cnt++;
        _u[cnt] = u;
        _next[cnt] = h[U];
        _v[cnt] = -1;
        h[U] = cnt;
        return _v[cnt];
    }
    uint8_t get(u32 u) {
        u32 U = u % P;
        for (u32 i = h[U]; i; i = _next[i])
            if (_u[i] == u)
                return _v[i];
        return -1;
    }
} g;
int main() {
    dR(u32, n, m), m *= 2;
    dRV(u32, a, n);
    for (auto&& x: a)
        x *= 2;
    [&](auto&& a) {
        u32 n = len(a);
        std::vector<u64> sum(1u << n); // 预处理不劈瓜时瓜重
        for (u32 i = 0; i < n; i++)
            sum[1u << i] = a[i];
        for (u32 S = 1; S < (1u << n); S++)
            sum[S] = sum[lowbit(S)] + sum[S ^ lowbit(S)];
        for (u32 S = 0; S < (1u << n); S++) {
            for (u32 T = S;; T = (T - 1) & S) { // 枚举三进制状态
                u64 s = sum[T] / 2 + sum[S ^ T];
                if (s <= m)
                    chkmin(g[s], __builtin_popcount(T));
                if (!T)
                    break;
            }
        }
    }(std::vector(a.begin(), a.begin() + n / 2));
    uint8_t ans = -1;
    [&](auto&& a) {
        u32 n = len(a);
        std::vector<u64> sum(1u << n);
        for (u32 i = 0; i < n; i++)
            sum[1u << i] = a[i];
        for (u32 S = 1; S < (1u << n); S++)
            sum[S] = sum[lowbit(S)] + sum[S ^ lowbit(S)];
        for (u32 S = 0; S < (1u << n); S++) {
            for (u32 T = S;; T = (T - 1) & S) {
                if (__builtin_popcount(T) < ans) {
                    u64 s = sum[T] / 2 + sum[S ^ T];
                    if (s <= m)
                        if (auto&& v = g.get(m - s); v != 0xff)
                            chkmin(ans, __builtin_popcount(T) + v);
                }
                if (!T)
                    break;
            }
        }
    }(std::vector(a.begin() + n / 2, a.end()));
    writeln(ans == 0xff ? -1 : ans);
    return 0;
}
```

---

## 作者：fengziyi (赞：7)

### 前言

「这瓜保熟吗？」  
「我问你这瓜保熟吗？」

### 思路

~~不妨把小蓝当作华强~~。

为了防止浮点精度爆炸先把题述中的 $m$ 翻个倍，每个瓜的质量视为原来的 $\dfrac{1}{2}$，这样不会影响结果。

相信大家都会打基本搜索。但是，直接搜索喜提 $20$ 分。

接着我们需要一个技巧叫做**折半搜索**。

折半搜索的基本思想是将需要搜索的内容分成两份，分别搜完并统计答案。最后把两部分的答案进行统计合并即可。

考虑在搜索前半部分时，统计一个**达到某个重量 $w$ 所需的最小刀数 $k$**。这样就可以在搜索后半部分的同时统计掉满足华强需求的刀数。

比较合理的方法是使用哈希表进行，这里选用 `unordered_map`。

```cpp
int mid;
unordered_map<int, int> tb;

inline void dfs1(int p, int w, int k)
{
	if (w > m) return; // 剪枝
	if (w == m) { ans = min(ans, k); return; } // 不用搜了
	if (p == mid + 1)
	{
		if (w <= m)
		{
			if (tb.count(w))
				tb[w] = min(tb[w], k);
			else 
				tb[w] = k;
			// 记录目前能得到质量量 w 最少需要的刀数
		}
		return;
	}
	dfs1(p + 1, w + a[p], k + 1);    // 劈一刀看看
	dfs1(p + 1, w, k);               // 生瓜蛋子，不要了
	dfs1(p + 1, w + (a[p] << 1), k); // 一眼保熟，不用劈了
}
inline void dfs2(int p, int w, int k) // 大部同上
{
	if (w > m) return;
	if (w == m) { ans = min(ans, k); return; }
	if (p == n + 1)
	{
		if (w <= m && tb.count(m - w))
			ans = min(ans, tb[m - w] + k); // 若能够得到刚好质量 m 的瓜，更新答案
		return;
 	}
	dfs2(p + 1, w + a[p], k + 1);
	dfs2(p + 1, w, k);
	dfs2(p + 1, w + (a[p] << 1), k);
}

int main()
{
	mid = (n + 1) >> 1;
	sort(a + 1, a + n + 1); // 不加排序 72 pts
	dfs1(1, 0, 0);
	dfs2(mid + 1, 0, 0);
}
```

然后会发现这个代码卡线过了，但即使不开 O2 也可过（？）。

但是我们显然需要更加优秀的算法，考虑舍弃**大于当前所得答案的**所有枝条，即可在总时间 $1$ 秒内通过。

具体实现对上面直接搜索的代码稍加修改即可。

### 代码

```cpp
#include <iostream>

#include <algorithm>
#include <unordered_map>

#define i64 long long
#define reg register
#define qwq puts("fzy qwq ~");

using namespace std;

const int inf = 0x7fffffff;

int n, mid, ans = inf; int m;
int a[31]; bool spt[31];
unordered_map<int, int> tb;

inline void dfs1(int p, int w, int k)
{
	if (w > m || k > ans || (tb.count(w) && tb[w] < k)) return; // 剪枝
	if (w == m) { ans = min(ans, k); return; } // 不用搜了
	if (p == mid + 1)
	{
		if (w <= m)
		{
			if (tb.count(w))
				tb[w] = min(tb[w], k);
			else 
				tb[w] = k;
			// 记录目前能得到质量量 w 最少需要的刀数
		}
		return;
	}
	dfs1(p + 1, w, k);				 // 生瓜蛋子，不要了
	dfs1(p + 1, w + a[p], k + 1);	 // 劈一刀看看
	dfs1(p + 1, w + (a[p] << 1), k); // 一眼保熟，不用劈了
}
inline void dfs2(int p, int w, int k) // 大部同上
{
	if (w > m || k > ans) return;
	if (w == m) { ans = min(ans, k); return; }
	if (p == n + 1)
	{
		if (w <= m && tb.count(m - w))
			ans = min(ans, tb[m - w] + k); // 若能够得到刚好质量 m 的瓜，更新答案
		return;
 	}
	dfs2(p + 1, w, k);
	dfs2(p + 1, w + a[p], k + 1);
	dfs2(p + 1, w + (a[p] << 1), k);
}


int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	
	cin >> n >> m;
	m <<= 1; mid = n >> 1;
	// 预先把瓜的质量翻倍，防止出现小数
	for (reg int i = 1; i <= n; ++i)
		cin >> a[i];
		
	sort(a + 1, a + n + 1);
	dfs1(1, 0, 0);
	dfs2(mid + 1, 0, 0);
	
	cout << (ans == inf ? -1 : ans) << endl;
	return 0;
}
```

---

## 作者：Red_Star_ (赞：6)

[题目传送门](https://www.luogu.com.cn/problem/P9234)

#### 思路
由于可能瓜的重量为奇数，小数容易精度丢失，于是考虑把瓜的重量和求的重量 $m$ 一起乘 $2$，并且如果直接开数组存重量为 $i$ 的瓜需要劈几次的话容易炸，于是想到开 `map` 存，直接搜索时间复杂度是 $O(3^{n})$，肯定会 T，考虑折半搜索，但 $3^{\frac{n}{2}}$ 还是不能直接拿满，这就需要一些小优化：
1. 存储用 `unordered_map` 存，比 `map` 快。
1. 如果当前结果已经大于当前最优解，直接退出。
1. 记得给**瓜**排个序。

code
```c
#include<bits/stdc++.h>
using namespace std;
int n,m,mid,ans = 32,l = 1e8,a[110];
unordered_map <int,int> b;
inline void dfs(int l,int r,int y,int z,int pd)
{
	if(z > m || y >= ans) return;
	if(l > r)
	{
		if(pd == 1)//1为前一般，0为后一半，减少代码长度
		{	
			if(b[z]) b[z] = min(b[z],y + 1);
			else b[z] = y + 1;
		}
		else if(b[m - z]) ans = min(ans,b[m - z] + y - 1); 
		return;
	}
	dfs(l + 1,r,y,z + a[l] * 2,pd);//全要了
	dfs(l + 1,r,y + 1,z + a[l],pd);//劈瓜，要一半
	dfs(l + 1,r,y,z,pd);//不要
}
int main()
{
	scanf("%d%d",&n,&m);
	m *= 2;
	for(int i = 1;i <= n;i++) scanf("%d",&a[i]);
	sort(a + 1,a + 1 + n);
	mid = n / 2;
	dfs(1,mid,0,0,1);
	dfs(mid + 1,n,0,0,0);
	if(ans < 31) cout << ans;
	else cout << -1;//无解
	return 0;
}
```


---

## 作者：Bamboo_Day (赞：5)

## 前言

[小木棍](https://www.luogu.com.cn/problem/P1120)子都听说过吧。~~没错就是小波上课打挂那道~~。

跟这题没多大关系，不过如果你切了小木棍，就会觉得这道题很简单。

## 讲讲我一开始的思路



第一眼看，**排序**，然后和埃及分数一样**根据后续的瓜全买能不能满足**剪枝，然后搜索的时候加个**二分**寻找当前第一个切开比剩下小的值。

~~后面发现因为数据水所以加不加二分没差多少~~。

## 最后清晰的讲述一下我的思路

### 第一步
先将所有的元素**从大到小**进行排序，然后做一下后缀和（后面可行性剪枝用）。

### 第二步，开始搜索。

搜索的时候注意顺序要**从前往后**搜，也就是说后面被搜到的元素不能大于前面的（这里感性理解一下，如果大的搜了搜小的，然后搜完小的又去搜大的就重复了，排序就没有意义了）。

关于可行性剪枝自然就是用第一步求出的后缀和直接判断一下后面所有的瓜加起来有没有剩下需要的瓜多。

然后就结束了。

### 关于一些小技巧

可以在读入的时候就把数据乘 $2$，这样就可以用 `long long` 存下了（机房大佬说 `double` 常数很大）。

然后就是把题目看清楚，求的是**需要切开的瓜**，还有如果不行要输出 $-1$，~~不然你会因此 WA 一个点~~。

## Code
```cpp
#include <bits/stdc++.h>
#define int long long//记得开 long long 
#define ull unsigned long long

const int N = 1e6+10;
const int M = 1e4+10;
const int mod = 1e9+7;
const int INF = 0x3f3f3f3f;

using namespace std;
int a[40],n,m,b[40];
bool esmite(int pos,int res){
	return b[pos+1] >= res;
}
int ans = INF;
int find(int x){// STL熟练的可以使用 upper_bound 或者 lower_bound 本蒟蒻这两玩意用法分不清故手写 
	int l = 1, r = n;
	while(l < r){
		int mid = (l+r) >> 1;
		if(a[mid] / 2 <= x){
			r = mid;
		}else{
			l = mid+1;
		}
	}
	return l;
}
void dfs(int num,int rest,int pos){//num 当前切开了几个瓜，rest 还剩下需要多少瓜，pos当前搜到哪个位置了，防止往前搜 
	if(rest == 0){//统计答案 
		ans = min(ans,num);
		return;
	}
	if(!esmite(pos,rest)) return;//可行性剪枝 
	for(int i = max(pos+1,find(rest));i <= n; i++){//当然这里也可以直接pos+1（说过了数据水） 
		if(a[i] / 2 > rest) continue;
		dfs(num+1,rest - a[i] / 2, i);
		if(a[i] > rest) continue;
		dfs(num,rest - a[i], i);
	}
}
signed main(){
	cin >> n >> m;
	m *=2;//乘2小技巧 
	for(int i = 1; i <= n; i++){
		cin>> a[i];
		a[i] *= 2;
	}
	sort(a+1,a+1+n,greater<int>());//排序 
	for(int i = n; i > 0; i--){//后缀和 
		b[i] = b[i+1] + a[i];
	}
	dfs(0,m,0);
	if(ans == INF) cout<< -1;
	else cout << ans;
	return 0;
}

```
**这里建议加剪枝标签**.

---

## 作者：CQ_Bab (赞：3)

# 思路
我们可以用到折半搜索来做，那么我们对于每一个点可以转移出三种状态：

- 不加上这个瓜。
- 加上整个瓜。
- 加上这个瓜的一半，然后将剪的次数加一。

我们折半时可以分成前 $n\div2$ 个和后 $n-n\div2$ 个，然后我们看在前一个搜索能到达的值是否能与后一个搜索能到达的值加起来等于 $k$ ，若等于了就可以用到达前一个最短时间加上后一个时间与当前答案取最小值即可。
# 代码
```cpp
#include <bits/stdc++.h>
using namespace std ;
#define int long long
#define rep(i,x,y) for(int i=x;i<=y;i++)
int n,ans=INT_MAX,s[1010100];
int m,a[1010101];
map<int,int>mp;
void dfs(int sum,int x,int cnt) {
	if(sum>m||x>n/2) return ;
	if(sum==m){
		ans=min(ans,cnt);
		return;
	}
	if(mp.count(sum)&&mp[sum]<cnt) return;//若之前已经到过且代价比他小就不用再搜了 
	mp[sum]=cnt; //存下来 
	dfs(sum,x+1,cnt);//三种状态 
	dfs(sum+a[x+1]*2,x+1,cnt);
	dfs(sum+a[x+1],x+1,cnt+1);
}
void DFS(int sum,int x,int cnt) {
	if(sum>m||x>n) return ;
	if(mp.count(m-sum)) { //若他的另一半被搜过
		ans=min(ans,cnt+mp[m-sum]); //更新答案
		return ;
	}
	DFS(sum,x+1,cnt); //三种状态 
	DFS(sum+a[x+1]*2,x+1,cnt);
	DFS(sum+(a[x+1]),x+1,cnt+1);
}
signed main() {
	cin>>n>>m;
	m*=2; //这里我们可以将两边同时乘二来避免精度问题 
	rep(i,1,n) cin>>a[i];
	sort(a+1,a+1+n);
	dfs(0,0,0); //前面n/2个 
	DFS(0,n/2,0); //后面n-n/2个 
	cout<<(ans>INT_MAX/2?-1:ans)<<endl;
	return false;
} 
```

---

## 作者：highkj (赞：3)

# 思路
这道题我们可以用折半搜索来做，我们可以先用一个搜索将用 $1\sim \frac{n}{2}$ 能拼出来的值给存下来然后我们再去用 $\frac{n}{2}\sim n$ 中的数去组成值，若搜到一个值并且前面一个搜索能组成出 $m-now$（$now$ 为当前值。）然后我们就可以将答案与组成出 $now$ 的次数和组成出 $m-now$ 的次数相加并求最小值即可，那么我们可以发现对于一个下标我们能转换出三种状态：

- 不加这一个瓜，继续找后面的。
- 直接加上整个瓜，然后找后面的。
- 将这个瓜除以 $2$ 然后继续搜后面的。

然后我们可以加几个剪枝就是当原来组合出此种值并且他的代价还比你少那就可以不进行搜索了，毕竟你能到达的别人肯定都走完了。

# 代码

```cpp
#include <bits/stdc++.h>
using namespace std ;
#define int long long
#define rep(i,x,y) for(int i=x;i<=y;i++)
#define rep1(i,x,y) for(int i=x;i>=y;i--)
#define lowbit(x) x&-x
int n,ans=INT_MAX,s[1010100];
double m,a[1010101];
map<double,bool>ma; //存储当前值是否搜到过
map<double,int>mp; //mp[i]为变成i最小的次数
void dfs(double sum,int x,int cnt) {
	if(sum>m||x>n/2) return ; //判边界
	if(mp[sum]<cnt&&ma[sum]) return ; //若原来的次数比现在快不用再搜索了
	if(sum==m) { //若组合出了直接更新
		ans=min(ans,cnt);
		return;
	}
	mp[sum]=cnt; //存储
	ma[sum]=1;
	dfs(sum+a[x+1],x+1,cnt); //三种状态 
	dfs(sum,x+1,cnt);
	dfs(sum+a[x+1]/2,x+1,cnt+1);
}
void DFS(double sum,int x,int cnt) {
	if(sum>m||x>n) return ; //判边界 
	if(mp.count(m-sum)) { //若原来能组成出m-sum 
		ans=min(ans,cnt+mp[m-sum]); //更新 
		return ;
	}
	DFS(sum+a[x+1],x+1,cnt);//三种状态 
	DFS(sum+(a[x+1]/2),x+1,cnt+1);
	DFS(sum,x+1,cnt);
}
signed main() {
	cin>>n>>m;
	rep(i,1,n) cin>>a[i];
	sort(a+1,a+1+n);
	dfs(0,0,0); //前n/2
	DFS(0,n/2,0); //后 n-n/2 个
	cout<<(ans>INT_MAX/2?-1:ans)<<endl; //判无解
	return false;
}
```


---

## 作者：lovely_hyzhuo (赞：3)

## 1.题意简述

有 $n$ 个瓜，对于每个瓜，有买整个，买半个，不买三种选择，求最少要买多少个半个瓜。

## 2.简要分析

这道题目，dp 显然会超空间，所以自然地想到搜索。

然后输入的时候乘 $2$，$m$ 也乘 $2$，答案不变，不用处理小数了。

## 3.折半搜索

朴素的爆搜时间复杂度是 $O(3^{20})$ 的，那么我们就可以使用折半搜索了。

普通的折半搜索代码如下。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int a[1000010];
int ans=1e9+10;
int N;
unordered_map<int,int> v;
void dfs1(int k,int q,int sum)
{
	if(sum>m||k>n+1)
		return;
	if(sum==m){
        v[sum]=q;
        return;
    }
	if(k==N+1)
	{
		if(v[sum])v[sum]=min(v[sum],q+1);
        else v[sum]=q+1;
		return;
	}
	dfs1(k+1,q,sum);
	dfs1(k+1,q+1,sum+a[k]/2);
	dfs1(k+1,q,sum+a[k]);
}
void dfs2(int k,int q,int sum)
{
	if(sum>m||k>n+1)
		return;
	if(sum==m){
        ans=min(ans,v[sum]+q);
        return;
    }
	if(k==n+1)
	{
		if(v[m-sum])ans=min(ans,q+v[m-sum]-1);
		return;
	}
	dfs2(k+1,q,sum);
	dfs2(k+1,q+1,sum+a[k]/2);
	dfs2(k+1,q,sum+a[k]);
}
int main()
{
	cin>>n>>m;
	m*=2;
	N=min(n-2,n/2);
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		a[i]*=2;
	}
	sort(a+1,a+1+n);
	dfs1(1,0,0);
	dfs2(N+1,0,0);
	cout<<ans;
	return 0;
}
```
这样，你就可以得到 $32pts$ 的好成绩（逃）。

但是，这样不是我们想要的。

## 4.剪枝+优化

剪枝 $1$：如果当前答案比要输出的答案大了，直接返回就行。

剪枝 $2$：维护瓜重量后缀和，假如当前重量加上后缀和比 $m$ 要小，直接返回。

优化 $3$：将原数组进行排序，具体原因[戳我](https://www.luogu.com.cn/discuss/602217?page=2)。

优化 $4$：unordered_map 常数大，所以用平板电视。

优化 $5$：要把贡献大的放到前面搜索。

## 5.完整代码

```cpp
#include<bits/stdc++.h>
#include<bits/extc++.h>
#define int long long
using namespace std;
using namespace __gnu_pbds;
int n,m;
int a[1000010];
int ans=1e9+10;
int N;
cc_hash_table <int,int> v;
int b[100010];
int cnt;
void dfs1(int k,int q,int sum)
{
	if(sum>m)
		return;
	if(sum+b[k]<m) return;
	if(sum==m){
        v[sum]=q;
        return;
    }
	if(k==N+1)
	{
		if(v[sum])v[sum]=min(v[sum],q+1);
        else v[sum]=q+1;
		return;
	}dfs1(k+1,q,sum+a[k]);dfs1(k+1,q+1,sum+a[k]/2);
	dfs1(k+1,q,sum);
	
	
}
void dfs2(int k,int q,int sum)
{
	if(sum>m||q>ans)
		return;
	if(sum==m){
        ans=min(ans,v[sum]+q);
        return;
    }
	if(k==n+1)
	{
		if(v[m-sum])ans=min(ans,q+v[m-sum]-1);
		return;
	}dfs2(k+1,q,sum+a[k]);dfs2(k+1,q+1,sum+a[k]/2);
	dfs2(k+1,q,sum);
	
	
}
signed main()
{
	ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
	cin>>n>>m;
	m*=2;
	N=n/2;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		a[i]*=2;
	}
	sort(a+1,a+1+n);
	for(int i=n;i>=1;i--) b[i]=b[i+1]+a[i];
	dfs1(1,0,0);
	dfs2(N+1,0,0);
	if(ans==1e9+10)
	{
		cout<<"-1";
		return 0;
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：JLGxy (赞：2)

显然对于每个瓜都有三种状态，买、不买和买一半，因此可以 $\mathrm O(3^n)$ 爆搜，由于这题 $n\le 30$，显然会超时，所以可以考虑 meet in the middle 算法。将数组平分成两部分分别搜索，最后看能否拼成重量为 $m$ 的瓜即可，时间复杂度 $\mathrm O(3^{\frac n2})$。

搜索时判断如果重量已经大于 $m$，或者劈瓜个数大于当前答案就退出。

这题 $n\le 30$，$3^{\frac n2}\le 14348907$，用 `unordered_map` 会 TLE，`__gnu_pbds::gp_hash_table` 会 MLE+TLE，所以只能自己手写哈希表。

```cpp
#include<iostream>
#include<algorithm>
using namespace std;

int head[10000005], ky[15000005], nxt[15000005], ccc;
short v[15000005];
const int mod = 9998777;

// 哈希表
void ins(int k, int c)
{
    int id = k%mod;
    ++ccc;
    v[ccc] = c;
    ky[ccc] = k;
    nxt[ccc] = head[id];
    head[id] = ccc;
}
int fd(int x)
{
    if(x < 0) return -1;
    for(int i = head[x%mod]; i; i = nxt[i])
    {
        if(ky[i] == x) return i;
    }
    return -1;
}

// 搜索
int a[35], m, ans = 55;
void dfs(int i, int c, int n, short t)
{
    if(c > m) return;
    if(i > n) {
        int f = fd(c);
        if(f == -1) ins(c, t);
        else v[f] = min(v[f], t);
    }
    else {
        dfs(i+1, c, n, t);
        dfs(i+1, c+a[i], n, t);
        dfs(i+1, c+a[i]/2, n, t+1);
    }
}
void dfs2(int i, int c, int n, short t)
{
    if(c > m || t > ans) return;
    if(i > n)
    {
        int f = fd(m-c);
        if(f != -1) ans = min(ans, v[f]+t);
        return;
    } else {
        dfs2(i+1, c, n, t);
        dfs2(i+1, c+a[i], n, t);
        dfs2(i+1, c+a[i]/2, n, t+1);
    }
}
int main()
{
    int n;
    cin >> n >> m;
    m *= 2;
    for(int i = 1; i <= n; i++)
    {
        cin >> a[i];
        a[i] *= 2;
    }
    if(n == 1)
    {
        if(a[1] == m) cout << 0;
        else if(a[1]>>1 == m) cout << 1;
        else cout << -1;
        return 0;
    }
    sort(a+1, a+n+1, [](int a, int b)->bool{return a>b;});
    dfs(1, 0, n/2, 0);
    dfs2(n/2+1, 0, n, 0);
    cout << (ans!=55?ans:-1);
    return 0;
}
```

---

## 作者：Genius_Star (赞：0)

### 思路：

#### 1.搜索剪枝：

玄学复杂度，不知道能过多少，但 60 pts 应该有的。

每个瓜有三种情况，全买，买一半，都不买，我们先把所有瓜排序再搜索，便于剪枝。

剪枝策略：

1. 剩余的瓜全买也不足 $m$。

2. 当前的重量大于 $m$。

3. 当前的瓜数大于等于答案。

4. 当前状态如果取到和目前最优解一样的瓜数，也达不到 $m$ 重量。

#### 2.折半枚举：
考虑拆成两半枚举（折半枚举，也叫 meet-in-middle）。

分别维护 $3^{n/2}$ 次方大小的集合 $a,b$。

答案只可能完全来自 $a$，或者完全来自 $b$，或者 $a,b$ 各一部分。

$a,b$ 各一部分的话，在枚举 $b$ 集合内的元素对应的和为 $x$ 时，到 $a$ 集合内查元素和 $m-x$ 是否存在。

时间复杂度为 $O(3^{n/2} \times \log(3^{n/2}))$，大概是 $3 \times 10^8$ 多，比较极限，难以通过，试了试 unordered_map 去卡也 TLE 了，而瓶颈主要在集合查的这个 $\log$。

所以手写哈希（开散列），将 $\log$ 这个常数再压一压，就可以通过此题了。

256M 空间其实也比较极限，哈希模数那个数组不要开太大（调小了 TLE 调大了 MLE）。
### 完整代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int,int> P;
#define fi first
#define se second
const int N=32,M=1<<15,mod=19260817,S=14348907;
int n,bit[M];
int head[mod],nex[S],cnt;
P b[S];
ll m,a[N],f[M],g[M],sum;
inline void upd(int x,int v){
    int u=x%mod;
    for(int i=head[u];i;i=nex[i]){
        if(b[i].fi==x){
            b[i].se=min(b[i].se,v);
            return;
        }
    }
    b[++cnt]=P(x,v);
    nex[cnt]=head[u];
    head[u]=cnt;
}
inline int cal(int x){
    int u=x%mod;
    for(int i=head[u];i;i=nex[i]){
        if(b[i].fi==x)return b[i].se;
    }
    return N;
}
int sol(){
    if(sum==m)return 0;
    if(n==1){
        if(a[0]/2==m)return 1;
        return -1;
    }
    int ans=N;
    for(int i=1;i<M;++i){
        bit[i]=bit[i>>1]+(i&1);
    }
    int l=n/2,lb=1<<l,r=n-n/2,rb=1<<r;
    for(int i=0;i<l;++i){
        f[1<<i]=a[i];
    }
    for(int i=1;i<lb;++i){
        int x=i&-i;
        f[i]=f[x]+f[i^x];
        if((f[i]>>1)>m)continue;
        for(int j=i;;j=(j-1)&i){
            ll v=(f[j]>>1)+f[j^i];
            if(v<=m){
                if(v==m)ans=min(ans,bit[j]);
                else upd((int)v,bit[j]);
            }
            if(!j)break;
        }
    }
    for(int i=0;i<r;++i){
        g[1<<i]=a[l+i];
    }
    for(int i=1;i<rb;++i){
        int x=i&-i;
        g[i]=g[x]+g[i^x];
        if((g[i]>>1)>m)continue;
        for(int j=i;;j=(j-1)&i){
            ll v=(g[j]>>1)+g[j^i];
            if(v<=m){
                if(v==m)ans=min(ans,bit[j]);
                else ans=min(ans,cal((int)(m-v))+bit[j]);
            }
            if(!j)break;
        }
    }
    if(ans>n)ans=-1;
    return ans;
}
int main(){
    scanf("%d%lld",&n,&m);
    m*=2;
    for(int i=0;i<n;++i){
        scanf("%lld",&a[i]);
        a[i]*=2;
        sum+=a[i];
    }
    printf("%d\n",sol());
    return 0;
}
```


---

## 作者：HHYQ_07 (赞：0)

# 题解

## 前言

正确的做法其它题解已经给出，不再赘述，这里给大家提供一个部份分的做法。

## 思路

可供选择的瓜有两种：完整的瓜和完整的瓜的一半，其实这两种情况在本质上是一样的，所以我们可以将备选方案看成重量为 $a_1,a_2...a_n,a_1\div 2,a_2\div 2...a_n\div 2$ 的这些瓜。而每种瓜都有选和不选两种方案，那么问题整体可以看成有 $2n$ 件物品的 $01$ 背包。

## 细节

1. $a_i\div 2$ 可能为浮点数，无法成为数组下标，可以将总重量和完整瓜的重量都乘 $2$，避免小数。
2. 最终是要凑出重量为 $m$ 的，所以一开始要将 $f$ 数组赋成无穷大，$f_0=0$，最后如果 $f_m$ 为极大值就输出 $-1$。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,ans,f[10000005],a[65];
int main()
{
	cin>>n>>m;
	m*=2;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		a[i+n]=a[i];
		a[i]*=2;
	}
	memset(f,0x3f,sizeof(f));
	f[0]=0;
	for(int i=1;i<=2*n;i++)
		for(int j=m;j>=a[i];j--)
			if(i<=n)f[j]=min(f[j],f[j-a[i]]);
			else f[j]=min(f[j],f[j-a[i]]+1);
	if(f[m]>1e9)f[m]=-1; 
	cout<<f[m];
	return 0;
}
```

---


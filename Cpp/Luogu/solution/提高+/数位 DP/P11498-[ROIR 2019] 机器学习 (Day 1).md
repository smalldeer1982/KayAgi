# [ROIR 2019] 机器学习 (Day 1)

## 题目背景

翻译自 [ROIR 2019 D1T4](https://neerc.ifmo.ru/school/archive/2018-2019/ru-olymp-regional-2019-day1.pdf)。

## 题目描述

有一种新的机器学习方法。在训练过程中，程序会进行 $n$ 次迭代。每次迭代中，训练程序会在某个训练集上运行。

训练集的复杂度从 $0$ 到 $k$ 不等。训练计划由一个整数数组 $[a_{1}, a_{2}, \dots, a_{n}]$ 表示，其中 $0 \leq a_{i} \leq k$，$a_{i}$ 表示第 $i$ 次迭代中使用的训练集的复杂度。

研究发现，训练计划的有效性取决于训练集复杂度的二进制表示。为了使计划有效，必须满足对于任意的 $1 \leq i < j \leq n$，都有 $(a_{i} \operatorname{and} a_{j})=a_{i}$，其中 $\operatorname{and}$ 是按位与。

然而，持续使用相同复杂度的训练集不会带来学习进展。为了避免这种情况，训练计划必须满足 $m$ 个二元限制。每个二元限制由两个数字 $l_{i}$ 和 $r_{i}$ 表示，意味着 $a_{l_{i}} \neq a_{r_{i}}$。

实验室的工作人员希望找到满足所有二元限制的有效计划的数量。由于答案可能很大，你只需要求出答案对 $10^{9}+7$ 取模后的值。

## 说明/提示

### 样例解释

样例 $1$ 中所有可行的计划为：$[0,0],[0,1],[0,2],[0,3],[1,1],[1,3],[2,2],[2,3],[3,3]$。

样例 $2$ 中所有可行的计划为：$[0,1,1],[0,2,2]$。

### 数据范围

数据中 Subtask 0 为样例。

| 子任务 | 分值 | $1\le n\le$ | $0\le m\le$ | $0\le k\le$ |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $8$ | $500$ | $0$ | $500$ |
| $2$ | $20$ | $3\times10^5$ | $0$ | $10^7$ |
| $3$ | $10$ | $3\times10^5$ | $0$ | $10^{18}$ |
| $4$ | $8$ | $50$ | $50$ | $50$ |
| $5$ | $16$ | $2000$ | $2000$ | $10^7$ |
| $6$ | $6$ | $2000$ | $2000$ | $10^{18}$ |
| $7$ | $10$ | $3\times10^5$ | $200$ | $10^7$ |
| $8$ | $6$ | $3\times10^5$ | $200$ | $10^{18}$ |
| $9$ | $16$ | $3\times10^5$ | $3\times10^5$ | $10^{18}$ |

## 样例 #1

### 输入

```
2 0 3```

### 输出

```
9```

## 样例 #2

### 输入

```
3 1 2
1 2```

### 输出

```
2```

# 题解

## 作者：CuteChat (赞：3)

## 前言

数位动态规划的成分不高，套的模板特别经典，不过作为动态规划练手不错，蓝绿差不多了。

## 思路

**以下所说的一个数字 $x$ 集合均为 $x$ 在二进制下 $1$ 的位置集合。**

第一步应该要理解 $(a_i \operatorname{and} a_j) = a_i$ 说明了什么。

根据位运算的性质，这句话的意思应该是 $a_i$ 是 $a_j$ 的一个位子集。

具体来说，$a_i$ 的某一个二进制位是 $1$ 的情况下，$a_j$ 对应的二进制位也一定是 $1$。

$0$ 的位置不需要管，因为这个是按位与运算。

由于子集这个运算具有传递性，所以只需要满足 $a_i$ 是 $a_{i+1}$ 的一个位子集即可，并且不难发现 $a_i \le a_{i+1}$ 恒成立。

不过这种情况并不适合我们进行状态设计，因为还有一个限制，也就是 $0\le a_i\le k$。

由不等式性质，显然 $a_n \le k$ 即可，所以就有一个初步的想法就是枚举最后一个数字。

然后就会发现，对于其他的数字，就不需要关心这个数字具体是多少了，因为无论前面的数字怎样，只要是位子集，就一定是满足这个条件的。

因此只需要关心这个集合的大小即可，具体来说，在枚举最后一个数字后，问题被转换成了如下形式：

> 求解所有满足条件的序列 $b$ 的贡献和：
>
> - $0\le b_i \le b_{i+1}$。
> - $b_n$ 是一个给定的值（不超过 $60$）。
> - $b_{l_i} \neq b_{r_i}$。

$b_i$ 的定义就是 $a_i$ 的二进制下 $1$ 的个数，也就是集合大小。

而一个序列 $b$ 的贡献则是 $\displaystyle\prod_{i=1}^{n-1} C_{b_{i+1}}^{b_{i}}$，$C_{b_{i+1}}^{b_{i}}$ 的含义是显然的，从 $a_{i+1}$ 这个集合选出 $b_i$ 作为新的 $a_i$。

接着又注意到 $a_n$ 的值具体是多少是不关心的，同样只需要关心 $b_n$ 即可，换言之，枚举 $b_n$，统计出有多少个数字 $x$ 满足这个数字的集合大小是 $b_n$ 即可。

这个东西显然可以数位动态规划解决，不过由于数位动态规划似乎不是本题的重点，因此不细说，如有需要可以参考 [P8764](/problem/P8764)。

所以到这里就把问题转换成了一个很有前途的模型！

注意到 $b_i$ 不超过 $60$，所以在这个很长的序列里面，肯定很多很多段就是相同的，就像这样：

$$b=(0,0,1,1,1,2,2,2,3,3,3,4,4)$$

因此设计的动态规划就没有必要去一个一个做转移，你可以跳着转。

具体如何呢？不考虑 $m\neq 0$，则状态转移类似于这个样子：

$$dp_{i,j}=\sum_{p=0}^{i-1}\sum_{k=0}^{j-1}dp_{p,k}\times C_{j}^{k}$$


其中 $dp_{i,j}$ 表示强制钦定 $b_{i}=j$ 的时候，有多少种方案。

先不考虑优化，考虑 $m\neq 0$ 的时候怎么办，这时就会发现，只有一组限制 $(l, r)$ 满足 $l>p,r\le i$ 的时候（也就是**作为闭区间时被完全包含**），这个条件才会被破坏。

因此维护条件三也是简单的，只要 $[p+1,i]$ 这个转移的区间不会包含给定限制的一个二元组即可。

显然的，$p$ 的转移一定是一个区间，而且也是很好处理出这个区间的。

于是前缀和优化即可。

## 总体思路

通过对于按位与运算的分析可以将问题转换成如下：

> 求解所有满足条件的序列 $b$ 的贡献和：
>
> - $0\le b_i \le b_{i+1}$。
> - $b_n$ 是一个给定的值（不超过 $60$）。
> - $b_{l_i} \neq b_{r_i}$。

然后贡献的计算是一个数位动态规划还有一堆组合数相乘。

于是再根据值域小的性质，发现最终序列一定是一段一段的，所以就决策下一个不同的位置在哪里（其实不论值域都应该想到这一点）。

最后发现只要区间没有包含关系就是合法的，而这个条件的转移上，一定是一段区间，前缀和优化即可。

时间复杂度 $O(n \log^2 k)$，参考某一篇题解应该是可以继续优化的，但是轻微卡常足以通过。

## 代码

注意，代码中的转移顺序是完全颠倒的，仅供参考。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

const int p = 1e9 + 7;
int n, m, k, dp2[64][2][64], frc[64], inv[64], cans[64], C[64][64];
signed dp1[300005][64], sum[300005][64];
int togo[300005];
int l[300005], r[300005];
vector<int> qj[300005];

int dfs2(int i, int lim, int cnt) { // 数位 DP
	if (i == -1) {
		return cans[cnt];
	}
	if (dp2[i][lim][cnt] != -1) return dp2[i][lim][cnt];
	int ans = 0;
	for (int j = 0; j <= max(lim, ((k >> i) & 1)); ++j) {
		ans += dfs2(i - 1, lim || (j != ((k >> i) & 1)), cnt + j);
	}
	return dp2[i][lim][cnt] = ans % p;
}

signed main() {
	ios::sync_with_stdio(0); cin.tie(0);
	cin >> n >> m >> k;
	for (int i = 1; i <= m; ++i) {
		cin >> l[i] >> r[i];
		if (l[i] > r[i]) swap(l[i], r[i]);
		qj[l[i]].push_back(r[i]);
	}
	inv[0] = frc[0] = inv[1] = frc[1] = 1;
	for (int i = 2; i <= 63; ++i) {
		frc[i] = frc[i - 1] * i % p;
		inv[i] = (p - p / i) * inv[p % i] % p;
	}
	for (int i = 2; i <= 63; ++i) (inv[i] *= inv[i - 1]) %= p;
	int mn = 1ll << 60;
	for (int i = n; i >= 1; --i) {
		for (auto j : qj[i]) mn = min(mn, j);
		togo[i] = mn;
	}
	memset(dp2, 255, sizeof(dp2));
	C[0][0] = 1;
	for (int i = 1; i <= 62; ++i) {
		for (int j = 0; j <= 62; ++j) {
			C[i][j] = (C[i - 1][j] + (j ? C[i - 1][j - 1] : 0)) % p;
		}
	}
	for (int i = n; i >= 1; --i) {
		for (int cnt = 0; cnt <= 60; ++cnt) {
			if (i == n) {
				dp1[i][cnt] = 1;
				continue;
			}
			int ans = 0;
			if (togo[i] > n) {
				for (int k = 0; k <= cnt; ++k) (ans += C[cnt][k] * dp1[i + 1][k]) %= p;
			} else {
				for (int k = 0; k < cnt; ++k) {
					(ans += C[cnt][k] * (sum[i + 1][k] - sum[togo[i] + 1][k]) % p) %= p;
				}
			}
			dp1[i][cnt] = ans % p;
		}
		for (int cnt = 0; cnt <= 60; ++cnt) sum[i][cnt] = (sum[i + 1][cnt] + dp1[i][cnt]) % p;
	}
	for (int i = 0; i <= 60; ++i) {
		cans[i] = (dp1[1][i] % p + p) % p;
	}
	cout << dfs2(60, 0, 0) << "\n";
	return 0;
}
```

---

## 作者：Purslane (赞：3)

# Solution

$2025$ 第一篇题解。水一道简单紫题。 /qd

题目中位运算的限制显然等价于 $a_i \subseteq a_{i+1}$（这里的包含于是在二进制意义下理解的）

如果 $a_i \neq a_{i-1}$，称 $i$ 是好的——则 $a_i \neq a_j$ 等价于 $(i,j]$ 中有一个好的下标。钦定 $n+1$ 也是好的。

容易发现，如果确定了好下标的个数，以及最后一个数的 $\text{popcount}$，则合法序列个数是相同的（可以简单 DP 求出），所以我们只需要求出：

1. 好下标有 $x$ 个的方案数。
2. $i \in [0,k]$ 且 $\text{popcount}(i)=y$ 的 $i$ 的个数。

后者是经典的数位 DP 问题，不做赘述。

对于前者，考虑这样一个 DP：设 $dp_{i,j,k}$ 表示考虑了前 $i$ 个位置，放了 $k$ 个好下标，最近一次放下标的位置是 $j$ 的方案数。

容易发现，$dp_{i+1,j,k}$ 和 $dp_{i,j,k}$ 相比（$j \le i$）要么不变，要么被清空为 $0$；而 $dp_{i,i,k}$ 是从 $dp_{i-1,*,k-1}$ 转移而来的，其中 $*$ 表示了一个连续的区间。

显然可以前缀和优化 DP。

复杂度 $O(n \log V + \log^2 V)$。

```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=3e5+10,MAXM=60+10,MOD=1e9+7;
int n,m,k,lim[MAXN],t=65,C[MAXM][MAXM];
int mul[MAXM][MAXM],dp[MAXN][MAXM],pre[MAXN][MAXM],cnt[MAXM];
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m>>k;
	if(n==1) return cout<<(k+1)%MOD,0;
	ffor(i,0,t) {C[i][0]=1;ffor(j,1,i) C[i][j]=(C[i-1][j]+C[i-1][j-1])%MOD;}
	ffor(i,1,m) {
		int l,r;
		cin>>l>>r;
		if(l==r) return cout<<0,0;
		l++,lim[r]=max(lim[r],l);	
	}
	ffor(i,0,t) mul[i][1]=1;
	ffor(j,2,t) ffor(i,0,t) ffor(oi,0,i-1) mul[i][j]=(mul[i][j]+mul[oi][j-1]*C[i][oi])%MOD;
	dp[1][0]=1,pre[1][0]=1;
	int tot=1,ans=0;
	ffor(i,2,n+1) {
		ffor(j,1,t) dp[i][j]=(pre[i-1][j-1]-pre[tot-1][j-1])%MOD;
		ffor(j,0,t) pre[i][j]=(pre[i-1][j]+dp[i][j])%MOD;
		tot=max(tot,lim[i]);
	}
	roff(i,60,0) if(k&(1ll<<i)) {
		int v=k>>i; v--;
		ffor(j,0,i) cnt[__builtin_popcountll(v)+j]+=C[i][j];	
	}
	cnt[__builtin_popcountll(k)]++;
	ffor(i,0,60) ffor(j,1,60) ans=(ans+cnt[i]%MOD*dp[n+1][j]%MOD*mul[i][j])%MOD;
	cout<<(ans%MOD+MOD)%MOD;
	return 0;	
}
```

---

## 作者：PosVII (赞：2)

## 前言

二杀，但是首杀被封号了。

所以我才是首杀么么哒！！！

## 做法

考虑到不存在限制时怎么做，考虑最终的 $a_n = x$，则 $x$ 的每个二进制位互不影响，可以分开考虑它们在第几个位置加入 $a_i$。$x$ 显然可以用类似 数位dp 的方法顶位再用组合数处理。

进一步地，考虑将所有 $a_i = a_{i+1}$ 缩为一个点，若把每个二进制位视为一个球，那么变成了球不同，盒不同，盒不空的经典问题，第二类斯特林数即可。具体的缩点方案可以用 前缀和优化dp 来解决。

关于增加限制条件，考虑预处理出每个右端点缩点的最小左端点 $b_r$，然后前缀和的时候只取 $[b_i,i-1]$ 即可。

---

## 作者：BYR_KKK (赞：2)

纪念一下 2025 年第一题。

发现 $a$ 中后面的数必须是前面的数的超集，不难想到拆位，先考虑 $k=2^p$ 的情况。

对于一个数位而言，一定是覆盖 $a$ 的一段后缀（可以为空），设该段后缀为 $x\sim n$，称 $x$ 为该数位的起始点。$a_{l_i}\neq a_{r_i}$ 的限制实际上就是要求 $l_i+1\sim r_i$ 中存在一个起始点，因此下文默认将题目给出的 $l_i$ 加上 $1$。

套路地，设计 dp 状态 $f_{i,j}$ 代表从前往后的第 $j$ 个起始点放在 $i$，所有左端点 $\le i$ 的限制都已经被满足的方案数。转移考虑上一个起始点的位置，设 $x$ 为所有满足 $r_i<i$ 的限制中 $l_i$ 最大是多少，那么上一个起始点必须放在 $x\sim i$，用前缀和优化做到 $O(1)$ 转移。

上面所说的 dp 的总复杂度是 $O(n\log k)$。考虑当 $k=2^p$ 时如何统计答案，显然我们可以任选 $0\sim p$ 个数位填上去。枚举填了 $j$ 个数位，同时枚举最后一个起始点放在 $i$（$i$ 需要大于等于所有限制的左端点），此时所有数位**无标号**的答案是 $f_{i,j}$。但是实际上是有标号的，我们不妨钦定 dp 时不能有数位的起始点重合，然后枚举有 $x$ 个**位置不同**的起始点，此时的问题等价于将 $j$ 个有标号的球放进 $x$ 个有标号的集合里的方案数（每个集合**不能为空**），这个东西可以预处理出来（容斥或者递推），设为 $h_{j,x}$，乘上前面的 dp 值得到 $h_{j,x}f_{i,x}$。统计答案的这一步是 $O(\log^2 k)$ 的。

考虑 $k\ne 2^p$ 时的做法。采用数位 dp 的经典套路，钦定 $k$ 所有为 $1$ 的数位中，$i$ 是第一个没被选中的（顺序为从高位到低位）。此时可以选的数位的数量形如 $num\sim num+i$，我们枚举选了多少个，做刚才的统计答案，可以做到 $O(n\log^3 k)$，常数巨大。

这个复杂度还是太菜了。我们需要枚举 $k$ 的所有数位，同时需要枚举选了多少个，还需要枚举有多少个位置不同的起始点。考虑预处理 $g_i$ 代表选了 $i$ 个数位的方案数。此时可以做到 $O(\log^2 k)$ 统计答案（只需要枚举前两个量）。

$g_i$ 的预处理可以简单做到 $O(\log^2 k)$。注意 dp 时需要先枚举第二维才能维护前缀和。总时间复杂度 $O(n\log k+\log^2 k)$。

```cpp
#include<bits/stdc++.h>
#define int long long
#define fi first
#define se second
#define pii std::pair<int,int>
#define vint std::vector<int>
#define vpair std::vector<pii>
#define debug(...) fprintf(stderr,##__VA_ARGS__)

template<typename T>
void read(T &x){
	x=0;
	int f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-') f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9') x=x*10+(int)(c-'0'),c=getchar();
	x*=f;
}

std::stack<char>st;
template<typename T>
void print(T x){
	if(x==0) putchar('0');
	if(x<0) putchar('-'),x=-x;
	while(st.size()) st.pop();
	while(x) st.push((char)('0'+x%10)),x/=10;
	while(st.size()) putchar(st.top()),st.pop();
}

template<typename T>
void printsp(T x){
	print(x),putchar(' ');
}

template<typename T>
void println(T x){
	print(x),putchar('\n');
}

template<typename T,typename I>
bool chkmin(T &a,I b){
	if(a>b) return a=b,1;
	return 0;
}

template<typename T,typename I>
bool chkmax(T &a,I b){
	if(a<b) return a=b,1;
	return 0;
}

template<typename T,typename I>
void addedge(std::vector<I>*vec,T u,T v){
	vec[u].push_back(v);
}

template<typename T,typename I,typename K>
void addedge(std::vector<K>*vec,T u,T v,I w){
	vec[u].push_back({v,w});
}

template<typename T,typename I>
void addd(std::vector<I>*vec,T u,T v){
	addedge(vec,u,v),addedge(vec,v,u);
}

template<typename T,typename I,typename K>
void addd(std::vector<K>*vec,T u,T v,I w){
	addedge(vec,u,v,w),addedge(vec,v,u,w);
}

bool Mbe;

const int inf=1e18,MOD1=998244353,MOD2=1e9+7;

const int maxn=3e5+10;

int n,m,k,f[maxn][70],c[70];

int lowbit(int x){
	return x&(-x);
}

int fac[maxn],g[70],gt[70][70],ifac[70],xm[maxn],sum[maxn];

void add(int &a,int b){
	a+=b;
	if(a>=MOD2) a-=MOD2;
}

int ksm(int x,int y,int p){
	if(y==0) return 1;
	int z=ksm(x,y>>1,p);
	z=z*z%p;
	if(y&1) z=z*x%p;
	return z;
}

int C(int x,int y){
	if(y<0||x<y) return 0;
	return fac[x]*ifac[y]%MOD2*ifac[x-y]%MOD2;
}

void init(){
	fac[0]=1;
	for(int i=1;i<=maxn-10;i++) fac[i]=fac[i-1]*i%MOD2;
	ifac[69]=ksm(fac[69],MOD2-2,MOD2);
	for(int i=68;i>=0;i--) ifac[i]=ifac[i+1]*(i+1)%MOD2;
	for(int i=0;i<=65;i++)
		for(int j=0;j<=i;j++){
			gt[i][j]=ksm(j,i,MOD2);
			for(int k=0;k<j;k++) add(gt[i][j],(MOD2-gt[i][k]*C(j,k)%MOD2));
		}
}

int qzh[maxn];

pii a[maxn];

void psolve(int x){
	f[0][0]=1;
	qzh[0]=1;
	for(int i=1;i<=n;i++) qzh[i]=qzh[i-1];
	int b;
	if(m==0) b=1;
	else b=a[m].fi;
	for(int i=1;i<=x;i++){
		for(int j=1;j<=n;j++){
			f[j][i]=qzh[j-1];
			if(xm[j]!=-inf) add(f[j][i],MOD2-qzh[xm[j]-1]);
		}
		qzh[0]=0;
		for(int j=1;j<=n;j++) qzh[j]=qzh[j-1],add(qzh[j],f[j][i]);
		sum[i]=qzh[n],add(sum[i],MOD2-qzh[b-1]);
	}
	int res=0;
	g[0]=(m==0);
	for(int i=1;i<=x;i++)
		for(int j=1;j<=i;j++)
			add(g[i],sum[j]*gt[i][j]%MOD2);
}

bool Men;

signed main(){
	debug("%.6lfMB\n",(&Mbe-&Men)/1048576.0);
	read(n),read(m),read(k);
	for(int i=1;i<=m;i++) read(a[i].fi),read(a[i].se),a[i].fi++;
	std::sort(a+1,a+m+1);
	for(int i=0;i<=m;i++) xm[i]=-inf;
	for(int i=1;i<=m;i++) chkmax(xm[a[i].se+1],a[i].fi);
	for(int i=1;i<=n;i++) xm[i]=std::max(xm[i],xm[i-1]);
	init();
	psolve(65);
	int cnt=-1;
	if(k==0) c[++cnt]=0;
	while(k) c[++cnt]=(k&1),k>>=1;
	int num=0,ans=0;
	for(int i=cnt;i>=0;i--){
		if(c[i]!=1) continue;
		for(int j=num;j<=num+i;j++) add(ans,g[j]*C(i,j-num)%MOD2);
		num++;
	}
	add(ans,g[num]);
	println(ans);
	debug("%.6lfms\n",1e3*clock()/CLOCKS_PER_SEC);
}
```

---


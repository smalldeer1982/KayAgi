# [SCOI2009] windy 数

## 题目背景

windy 定义了一种 windy 数。

## 题目描述

不含前导零且相邻两个数字之差至少为 $2$ 的正整数被称为 windy 数。windy 想知道，在 $a$ 和 $b$ 之间，包括 $a$ 和 $b$ ，总共有多少个 windy 数？

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq a \leq b \leq 2 \times 10^9$。

## 样例 #1

### 输入

```
1 10```

### 输出

```
9```

## 样例 #2

### 输入

```
25 50
```

### 输出

```
20
```

# 题解

## 作者：caidd (赞：550)

本题思路参考：[five20](https://www.cnblogs.com/five20/p/9040490.html)（~~因为借鉴了他的思路，被发现没贴链，被其强烈要求贴链~~~[提交记录](https://www.luogu.org/record/show?rid=7307432)）

思想：分块打表  
这道题首先可以看出2000000000并不是一个很大的数。
用暴力，因为防止代码过长，考虑每隔1000000打出一个数字，为了防止爆行，每打二十个数换一行。  
  
然后对于询问的两个数，若在同一个块中则暴力。不在则对其分别处于的两个块分别处理  
  
用于打表的辅助程序：  
```cpp
#include<bits/stdc++.h>
using namespace std;
int cnt,tot,tou;
bool check(int x)
{
	int w=x%10;x/=10;
	while(x)
	{
		if(abs(w-(x%10))<2) return false;
		w=x%10;
		x/=10;
	}
	return true;
}
int main()
{
	for(int i=1;i<=2000000000;++i)
	{
		if(check(i)) ++cnt;
		++tot;if(tot==1000000) cout<<cnt<<',',tot=0,++tou;
		if(tou==20) cout<<endl,tou=0;
	}
	return 0;
}
```
  
解答程序：  
```cpp
#include<map>
#include<set>
#include<cmath>
#include<ctime>
#include<queue>
#include<string>
#include<vector>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define ll long long
#define il inline
#define R register
#define N 100005
#define debug puts("fuck");
using namespace std;
int a,b;
int d[2005]={202174,338305,476808,615022,753274,891526,1029740,1168243,1304374,1459689,1459689,1459689,1459689,1597903,1736155,1874407,2012621,2151124,2287255,2442570,
2597885,2597885,2597885,2597885,2736137,2874389,3012603,3151106,3287237,3442552,3597867,3733998,3733998,3733998,3733998,3872250,4010464,4148967,4285098,4440413,
4595728,4731859,4870362,4870362,4870362,4870362,5008576,5147079,5283210,5438525,5593840,5729971,5868474,6006688,6006688,6006688,6006688,6145191,6281322,6436637,
6591952,6728083,6866586,7004800,7143052,7143052,7143052,7143052,7279183,7434498,7589813,7725944,7864447,8002661,8140913,8279165,8279165,8279165,8279165,8434480,
8589795,8725926,8864429,9002643,9140895,9279147,9417361,9417361,9417361,9417361,9572676,9708807,9847310,9985524,10123776,10262028,10400242,10538745,10538745,10538745,
10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,
10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10538745,10694060,10830191,10830191,10830191,10830191,10968443,11106657,11245160,11381291,11536606,
11691921,11828052,11966555,11966555,11966555,11966555,12104769,12243272,12379403,12534718,12690033,12826164,12964667,13102881,13102881,13102881,13102881,13241384,13377515,13532830,
13688145,13824276,13962779,14100993,14239245,14239245,14239245,14239245,14375376,14530691,14686006,14822137,14960640,15098854,15237106,15375358,15375358,15375358,15375358,15530673,
15685988,15822119,15960622,16098836,16237088,16375340,16513554,16513554,16513554,16513554,16668869,16805000,16943503,17081717,17219969,17358221,17496435,17634938,17634938,17634938,
17634938,17634938,17773441,17911655,18049907,18188159,18326373,18464876,18601007,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,
18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,18756322,
18911637,19047768,19186271,19186271,19186271,19186271,19324485,19462988,19599119,19754434,19909749,20045880,20184383,20322597,20322597,20322597,20322597,20461100,20597231,20752546,
20907861,21043992,21182495,21320709,21458961,21458961,21458961,21458961,21595092,21750407,21905722,22041853,22180356,22318570,22456822,22595074,22595074,22595074,22595074,22750389,
22905704,23041835,23180338,23318552,23456804,23595056,23733270,23733270,23733270,23733270,23888585,24024716,24163219,24301433,24439685,24577937,24716151,24854654,24854654,24854654,
24854654,24854654,24993157,25131371,25269623,25407875,25546089,25684592,25820723,25976038,25976038,25976038,25976038,26114252,26252504,26390756,26528970,26667473,26803604,26958919,
26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,
26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,26958919,27114234,27250365,27388868,27527082,27527082,27527082,27527082,27665585,27801716,27957031,
28112346,28248477,28386980,28525194,28663446,28663446,28663446,28663446,28799577,28954892,29110207,29246338,29384841,29523055,29661307,29799559,29799559,29799559,29799559,29954874,
30110189,30246320,30384823,30523037,30661289,30799541,30937755,30937755,30937755,30937755,31093070,31229201,31367704,31505918,31644170,31782422,31920636,32059139,32059139,32059139,
32059139,32059139,32197642,32335856,32474108,32612360,32750574,32889077,33025208,33180523,33180523,33180523,33180523,33318737,33456989,33595241,33733455,33871958,34008089,34163404,
34318719,34318719,34318719,34318719,34456971,34595223,34733437,34871940,35008071,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,
35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,35163386,
35318701,35454832,35593335,35731549,35869801,35869801,35869801,35869801,36005932,36161247,36316562,36452693,36591196,36729410,36867662,37005914,37005914,37005914,37005914,37161229,
37316544,37452675,37591178,37729392,37867644,38005896,38144110,38144110,38144110,38144110,38299425,38435556,38574059,38712273,38850525,38988777,39126991,39265494,39265494,39265494,
39265494,39265494,39403997,39542211,39680463,39818715,39956929,40095432,40231563,40386878,40386878,40386878,40386878,40525092,40663344,40801596,40939810,41078313,41214444,41369759,
41525074,41525074,41525074,41525074,41663326,41801578,41939792,42078295,42214426,42369741,42525056,42661187,42661187,42661187,42661187,42799439,42937653,43076156,43212287,43367602,
43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,
43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43367602,43522917,43659048,43797551,43935765,44074017,44212269,44212269,44212269,44212269,44367584,
44522899,44659030,44797533,44935747,45073999,45212251,45350465,45350465,45350465,45350465,45505780,45641911,45780414,45918628,46056880,46195132,46333346,46471849,46471849,46471849,
46471849,46471849,46610352,46748566,46886818,47025070,47163284,47301787,47437918,47593233,47593233,47593233,47593233,47731447,47869699,48007951,48146165,48284668,48420799,48576114,
48731429,48731429,48731429,48731429,48869681,49007933,49146147,49284650,49420781,49576096,49731411,49867542,49867542,49867542,49867542,50005794,50144008,50282511,50418642,50573957,
50729272,50865403,51003906,51003906,51003906,51003906,51142120,51280623,51416754,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,
51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,51572069,
51727384,51863515,52002018,52140232,52278484,52416736,52554950,52554950,52554950,52554950,52710265,52846396,52984899,53123113,53261365,53399617,53537831,53676334,53676334,53676334,
53676334,53676334,53814837,53953051,54091303,54229555,54367769,54506272,54642403,54797718,54797718,54797718,54797718,54935932,55074184,55212436,55350650,55489153,55625284,55780599,
55935914,55935914,55935914,55935914,56074166,56212418,56350632,56489135,56625266,56780581,56935896,57072027,57072027,57072027,57072027,57210279,57348493,57486996,57623127,57778442,
57933757,58069888,58208391,58208391,58208391,58208391,58346605,58485108,58621239,58776554,58931869,59068000,59206503,59344717,59344717,59344717,59344717,59483220,59619351,59774666,
59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,
59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59774666,59929981,60066112,60204615,60342829,60481081,60619333,60757547,60896050,60896050,60896050,
60896050,60896050,61034553,61172767,61311019,61449271,61587485,61725988,61862119,62017434,62017434,62017434,62017434,62155648,62293900,62432152,62570366,62708869,62845000,63000315,
63155630,63155630,63155630,63155630,63293882,63432134,63570348,63708851,63844982,64000297,64155612,64291743,64291743,64291743,64291743,64429995,64568209,64706712,64842843,64998158,
65153473,65289604,65428107,65428107,65428107,65428107,65566321,65704824,65840955,65996270,66151585,66287716,66426219,66564433,66564433,66564433,66564433,66702936,66839067,66994382,
67149697,67285828,67424331,67562545,67700797,67700797,67700797,67700797,67836928,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,
67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,67992243,
67992243,67992243,68130746,68268960,68407212,68545464,68683678,68822181,68958312,69113627,69113627,69113627,69113627,69251841,69390093,69528345,69666559,69805062,69941193,70096508,
70251823,70251823,70251823,70251823,70390075,70528327,70666541,70805044,70941175,71096490,71251805,71387936,71387936,71387936,71387936,71526188,71664402,71802905,71939036,72094351,
72249666,72385797,72524300,72524300,72524300,72524300,72662514,72801017,72937148,73092463,73247778,73383909,73522412,73660626,73660626,73660626,73660626,73799129,73935260,74090575,
74245890,74382021,74520524,74658738,74796990,74796990,74796990,74796990,74933121,75088436,75243751,75379882,75518385,75656599,75794851,75933103,75933103,75933103,75933103,76088418,
76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,
76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,
76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,
76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,
76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,
76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,
76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,
76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,
76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,
76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,
76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,
76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,
76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,
76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,
76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,
76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,76088418,
76088418,76088418,76226921,76365135,76503387,76641639,76779853,76918356,77054487,77209802,77209802,77209802,77209802,77348016,77486268,77624520,77762734,77901237,78037368,78192683,
78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,
78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78192683,78347998,78484129,78622632,78760846,78760846,78760846,78760846,78899349,79035480,79190795,
79346110,79482241,79620744,79758958,79897210,79897210,79897210,79897210,80033341,80188656,80343971,80480102,80618605,80756819,80895071,81033323,81033323,81033323,81033323,81188638,
81343953,81480084,81618587,81756801,81895053,82033305,82171519,82171519,82171519,82171519,82326834,82462965,82601468,82739682,82877934,83016186,83154400,83292903,83292903,83292903,
83292903,83292903,83431406,83569620,83707872,83846124,83984338,84122841,84258972,84414287,84414287,84414287,84414287,84552501,84690753,84829005,84967219,85105722,85241853,85397168,
85552483,85552483,85552483,85552483,85690735,85828987,85967201,86105704,86241835,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,
86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,86397150,
86552465,86688596,86827099,86965313,87103565,87103565,87103565,87103565,87239696,87395011,87550326,87686457,87824960,87963174,88101426,88239678,88239678,88239678,88239678,88394993,
88550308,88686439,88824942,88963156,89101408,89239660,89377874,89377874,89377874,89377874,89533189,89669320,89807823,89946037,90084289,90222541,90360755,90499258,90499258,90499258,
90499258,90499258,90637761,90775975,90914227,91052479,91190693,91329196,91465327,91620642,91620642,91620642,91620642,91758856,91897108,92035360,92173574,92312077,92448208,92603523,
92758838,92758838,92758838,92758838,92897090,93035342,93173556,93312059,93448190,93603505,93758820,93894951,93894951,93894951,93894951,94033203,94171417,94309920,94446051,94601366,
94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,
94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94601366,94756681,94892812,95031315,95169529,95307781,95446033,95446033,95446033,95446033,95601348,
95756663,95892794,96031297,96169511,96307763,96446015,96584229,96584229,96584229,96584229,96739544,96875675,97014178,97152392,97290644,97428896,97567110,97705613,97705613,97705613,
97705613,97705613,97844116,97982330,98120582,98258834,98397048,98535551,98671682,98826997,98826997,98826997,98826997,98965211,99103463,99241715,99379929,99518432,99654563,99809878,
99965193,99965193,99965193,99965193,100103445,100241697,100379911,100518414,100654545,100809860,100965175,101101306,101101306,101101306,101101306,101239558,101377772,101516275,101652406,101807721,
101963036,102099167,102237670,102237670,102237670,102237670,102375884,102514387,102650518,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,
102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,102805833,
102961148,103097279,103235782,103373996,103512248,103650500,103788714,103788714,103788714,103788714,103944029,104080160,104218663,104356877,104495129,104633381,104771595,104910098,104910098,104910098,
104910098,104910098,105048601,105186815,105325067,105463319,105601533,105740036,105876167,106031482,106031482,106031482,106031482,106169696,106307948,106446200,106584414,106722917,106859048,107014363,
107169678,107169678,107169678,107169678,107307930,107446182,107584396,107722899,107859030,108014345,108169660,108305791,108305791,108305791,108305791,108444043,108582257,108720760,108856891,109012206,
109167521,109303652,109442155,109442155,109442155,109442155,109580369,109718872,109855003,110010318,110165633,110301764,110440267,110578481,110578481,110578481,110578481,110716984,110853115,111008430,
111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,
111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111008430,111163745,111299876,111438379,111576593,111714845,111853097,111991311,112129814,112129814,112129814,
112129814,112129814,112268317,112406531,112544783,112683035,112821249,112959752,113095883,113251198,113251198,113251198,113251198,113389412,113527664,113665916,113804130,113942633,114078764,114234079,
114389394,114389394,114389394,114389394,114527646,114665898,114804112,114942615,115078746,115234061,115389376,115525507,115525507,115525507,115525507,115663759,115801973,115940476,116076607,116231922,
116387237,116523368,116661871,116661871,116661871,116661871,116800085,116938588,117074719,117230034,117385349,117521480,117659983,117798197,117798197,117798197,117798197,117936700,118072831,118228146,
118383461,118519592,118658095,118796309,118934561,118934561,118934561,118934561,119070692,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,
119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,119226007,
119226007,119226007,119364510,119502724,119640976,119779228,119917442,120055945,120192076,120347391,120347391,120347391,120347391,120485605,120623857,120762109,120900323,121038826,121174957,121330272,
121485587,121485587,121485587,121485587,121623839,121762091,121900305,122038808,122174939,122330254,122485569,122621700,122621700,122621700,122621700,122759952,122898166,123036669,123172800,123328115,
123483430,123619561,123758064,123758064,123758064,123758064,123896278,124034781,124170912,124326227,124481542,124617673,124756176,124894390,124894390,124894390,124894390,125032893,125169024,125324339,
125479654,125615785,125754288,125892502,126030754,126030754,126030754,126030754,126166885,126322200,126477515,126613646,126752149,126890363,127028615,127166867,127166867,127166867,127166867,127322182,
127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182,127322182};
bool check(int x)
{
	int w=x%10;x/=10;
	while(x)
	{
		if(abs(w-(x%10))<2) return false;
		w=x%10;
		x/=10;
	}
	return true;
}
int sol(int x,int y)
{
	int a=x/1000000,b=y/1000000,cnt=0,sum1=0,sum2=0,xia=a*1000000,shang=b*1000000;
	if(a==b)
	{
		for(int i=x;i<=y;++i) if(check(i)) ++cnt;
		return cnt;
	}//若在同一块中则暴力
	for(int i=xia+1;i<=x-1;++i) if(check(i)) ++sum1;
	if(x>=1000000) sum1=sum1+d[a-1];//下标要减一
	for(int i=shang+1;i<=y;++i) if(check(i)) ++sum2;
	sum2=sum2+d[b-1];
	return sum2-sum1;//前缀和
}
int main()
{
	cin>>a>>b;
	printf("%d\n",sol(a,b));
	return 0;
}
```

---

## 作者：Patrickpwq (赞：334)

数位dp解决 不用记忆化搜索
这个题是在一个区间里找个数 所以我们考虑用前缀和的思想 只需找出1~m,1~n各自的个数 再相减就行了 于是这样只用关心上界了（命为work函数 work(x)可以求出【0，x】区间里的windy数个数）

设dp[i][j]为长度为i中最高位是j的windy数的个数

方程 dp[i][j]=sum(dp[i-1][k]) 其中 abs(j-k)>=2（abs ->绝对值 在cmath里） 

这样的转移是通过前一位的和转移过来的

work函数还是不讲了 看注释吧
```cpp
#include<bits/stdc++.h>
using namespace std;
//设dp[i][j]为长度为i中最高位是j的windy数的个数
//方程 dp[i][j]=sum(dp[i-1][k]) 其中 abs(j-k)>=2 
int p,q,dp[15][15],a[15];
void init()
{
	for(int i=0;i<=9;i++)	dp[1][i]=1;	//0,1,2,3,4...9都属于windy数 
	for(int i=2;i<=10;i++)
	{
		for(int j=0;j<=9;j++)
		{
			for(int k=0;k<=9;k++)
			{
				if(abs(j-k)>=2)	dp[i][j]+=dp[i-1][k]; 
			}
		}
	}//从第二位开始 每次枚举最高位j 并找到k 使得j-k>=2 
}
int work(int x)	//计算<=x的windy数 
{
	memset(a,0,sizeof(a));
	int len=0,ans=0;
	while(x)
	{
		a[++len]=x%10;
		x/=10;
	}
	//分为几个板块 先求len-1位的windy数 必定包含在区间里的 
	for(int i=1;i<=len-1;i++)
	{
		for(int j=1;j<=9;j++)
		{
			ans+=dp[i][j];
		} 
	}
	//然后是len位 但最高位<a[len]的windy数 也包含在区间里 
	for(int i=1;i<a[len];i++)
	{
		ans+=dp[len][i];
	} 
	//接着是len位 最高位与原数相同的 最难搞的一部分 
	for(int i=len-1;i>=1;i--)
    {
    	//i从最高位后开始枚举 
        for(int j=0;j<=a[i]-1;j++)
		   {
		   	//j是i位上的数 
		   		if(abs(j-a[i+1])>=2)	ans+=dp[i][j]; //判断和上一位(i+1)相差2以上
				   //如果是 ans就累加 
		   } 
		if(abs(a[i+1]-a[i])<2)       break;
      //  if(i==1)   ans+=1;
    }
	return ans;
}
int main()
{
	init();
	cin>>p>>q;
	cout<<work(q+1)-work(p)<<endl;
	return 0;
}
```

---

## 作者：Mathison (赞：157)

数位dp模板题

数位dp一般解决的是一类数字问题：从l到r有多少个数符合某个性质，其中l和r都是很大的数，从l循环到r显然会TLE。

我们用$f[i][j]$表示搜到第i位，上一位数是j的情况下的方案总数

这道题我们可以处理$1-(l-1)$的方案数$sum[l-1]$和$1-r$的方案数$sum[r]$，则$$ans=sum[r]-sum[l-1]$$

接下来考虑怎么写转移

我们可以枚举每位上的$0-9$

特别地，如果前面的数取了能取的最大值或前面没有数字，那么这位上只能取到这位的最大数字

可能比较抽象，举个例子$$142857$$

$$142???$$

这时候第四位只能取到$8$，无法取到$9$ $$142857$$

$$141???$$

第$3$位没有取到最大值，所以第$4$可以取到$9$

最后我们考虑限制条件：相邻两位绝对值大于等于$2$

如果前一位是前导$0$，那么我们不需要考虑这位与$0$的绝对值，就是说$0$和$1$也是可以取到的

所以我们可以在处理下一位时把这位当做$-2$处理

下面是有详细注释的代码：
```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll dp[15][15],ans;//dp[i][j]表示搜到第i位，前一位是j，的！limit方案totnum；
int a[15],len;
long long L,R;
ll dfs(int pos,int pre,int st,int limit)//pos当前位置,pre前一位数,st判断前面是否全是0,limit最高位限制 
{
	if(pos>len) return 1;//搜完了 
	if(!limit&&dp[pos][pre]!=-1) return dp[pos][pre];//没有最高位限制，已经搜过了
	ll ret=0;
	int res=limit?a[len-pos+1]:9;//当前位最大数字 
	for(int i=0;i<=res;i++)//从0枚举到最大数字 
	{
		if(abs(i-pre)<2) continue;//不符合题意，继续 
		if(st&&i==0) ret+=dfs(pos+1,-2,1,limit&&i==res);//如果有前导0，下一位随意 
		else ret+=dfs(pos+1,i,0,limit&&i==res);//如果没有前导0，继续按部就班地搜 
	}
	if(!limit&&!st) dp[pos][pre]=ret;//没有最高位限制且没有前导0时记录结果 
	return ret;
}
void part(ll x)
{
	len=0;
	while(x) a[++len]=x%10,x/=10;
	memset(dp,-1,sizeof dp);
	ans=dfs(1,-2,1,1);
}
int main()
{
    scanf("%lld%lld",&L,&R);
    part(L-1);ll minn=ans;
	part(R);  ll maxx=ans;
	printf("%lld",maxx-minn);
	return 0;
}
```




---

## 作者：Newuser (赞：57)

数位DP，那么我们考虑记忆化搜索解决。

状态：DP[X][Y] X表示考虑到第几位，Y考虑到这个数的前一个数什么，状态保存从此状态出发达到完成结果的方案数（大概意思理解到就好）。

实现：搜一遍

坑难点：有个无前导0的限制以及不能超过那个数最高位的限制，因此我们在搜索中增加两个bool分别，shangxian记录表示目前是不是仍然在达到原数边界位数上讨论（eg:43278 我们的len==3 last==3,且前面讨论的4，此时我们讨论的位上的数数不能超过2）  qdling表示现在是不是还在前导0（前面的位是不是全是0）

数位dp也是刚学qwq，考虑多有不周，需要多加学习。


	#include<cstdio>
	#include<algorithm>
	#include<cstring>
	#include<iostream>
	using namespace std;
	int dp[15][15],num[15];//len last
	int a,b;

	int dfs(int len,int last,bool shangxian,bool qdling)
	{
	if(len==0) return 1;
	if(!qdling&&!shangxian&&dp[len][last]!=-1)
		return dp[len][last];
	int p,cnt=0,maxx=(shangxian?num[len]:9);
	for(int i=0;i<=maxx;i++)
	{
		if(abs(i-last)<2)continue;
		p=i;
		if(qdling&&i==0) p=-233;
		cnt+=dfs(len-1,p,(shangxian)&&(i==maxx),(p==-233));
	}
	if(!shangxian&&!qdling) dp[len][last]=cnt;
	return cnt;
	}

	int solve(int x)
	{
	int k=0;
	while(x)
	{
		num[++k]=x%10;
		x/=10;
	}
	memset(dp,-1,sizeof(dp));
	return dfs(k,-233,true,true);
	}

	int main()
	{
	scanf("%d%d",&a,&b);
	printf("%d\n",solve(b)-solve(a-1));
	}

---

## 作者：ljc20020730 (赞：49)

一起学下数位dp 
- 设f(x)表示x前面的数 即 t∈[1,x) 中windy数的个数

那么显然如果要求 [l,r]中windy数的个数就是：
- F(l,r) = f（r+1）-f(l)

数位dp开始，预处理位数为i最高位为j的windy数个数 f[i][j]

转移：
- f[i][j]=f[i-1][k] | 其中k是非负整数k∈[0,9]且|k-j|>=2

初始值：

- f[1][i]=1 | 其中i为非负整数 i∈[0,9]

求f(x)怎么求呢？

为了方便处理先对数x进行按10进制位拆分到a[]数组

- 显然位数比x要小的数字都是合法的都在[1,x）区间内，直接统计就行
- 位数和x一样最高位的数字比x小的数字都是合法的都在[1,x）区间内直接统计就行
- 位数和x一样，最高位又和x一样我们从左到右扫一遍x各个位子上的数字大小然后枚举合法的该位子上的数[0,9]判断是否合法就行。

代码：
```
// f[i][j]数字位数为i，最高位为j的windy数个数
// f[i][j]+=f[i-1][k] |k-j|>=2
# include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll f[15][15];
int a[15];
ll fun(ll x)
{
	int len=0;
	while (x>0ll) a[++len]=x%10,x/=10;
	ll sum=0ll;
	for (int i=1;i<=len-1;i++)
	 for (int j=1;j<=9;j++)
	  sum+=f[i][j];
	for (int i=1;i<a[len];i++) sum+=f[len][i];
	for (int i=len-1;i>=1;i--) {
		for (int j=0;j<=a[i]-1;j++)
		 if (abs(j-a[i+1])>=2) sum+=f[i][j];
		if (abs(a[i+1]-a[i])<2) break; //这一位不行后面的位子一定不行
	}
	return sum;
}
int main()
{
	ll n,m; scanf("%lld %lld",&n,&m);
	if (n>m) swap(n,m);
	for (int i=0;i<=9;i++) f[1][i]=1ll;
	for (int i=2;i<=10;i++)
	 for (int j=0;j<=9;j++)
	  for (int k=0;k<=9;k++)
	   if (abs(k-j)>=2) f[i][j]+=f[i-1][k];
	printf("%lld\n",fun(m+1)-fun(n));
	return 0;
}
```



---

## 作者：FC_Barcelona (赞：47)

~~头一次一遍AC这种难度的题~~ ^-^

这是一道明显的**数位dp**题,我们可以用一个记忆化搜索去实现：dfs（len,last,flag,zero）表示总个数，len表示已经搜到了第len位（从高位到低位），last表示上一位所填的数字，flag表示之前的数字是否已经紧贴上界，zero表示是否有前置零。

显然，如果flag=0（之前数字未紧贴上界），那么与前一位数字差的绝对值不小于2的任意数字都可以填到当前位置上，不用考虑是否越界（高位都更小了，低位还管什么？）。否则如果flag=1，那么当前位置上的数不仅需要保证差的绝对值>=2，还要保证数字未超过此位置的上界。

另外，有前导零时非零的第一位不需要管与前面一位（0）的差。

具体细节见代码。。。




```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#define ll long long
using namespace std;
int a,b,len,num[15],f[15][15][2][2];
inline int dfs(int len,int last,bool flag,bool zero)
{
	if (!len) return 1;   //len位都做完了当然返回1（第一位当然随便填都是windy数，1~9对应的windy数数量都是1）
	if (~f[len][last][flag][zero]) return f[len][last][flag][zero];         //以前搜过了，直接返回值
	int res=0;
	for (int i=0;i<=9;i++)
	    if ((i<=num[len] || !flag) && (abs(i-last)>=2 || zero))   //保证不越界，差不小于2
		    res+=dfs(len-1,i,flag&&(i==num[len]),zero&&(!i));   //总数累加
	f[len][last][flag][zero]=res;  //将得到的值存下来
	return res;
}
inline int solve(int x)  //求出从1到x共有多少windy数
{
	int tmp=x;
	len=0;
	memset(num,0,sizeof(num));
	while (tmp)        //把各个数位的上界拆出来
	{
		num[++len]=tmp%10;
		tmp/=10;
	}
	memset(f,-1,sizeof(f));
	return dfs(len,11,1,1);  //记忆化搜索
}
int main()
{
	scanf("%d%d",&a,&b); //懒得写快读QAQ
	printf("%d",solve(b)-solve(a-1));
}
```

可能写的有些繁杂，~~但个人认为较好理解qwq~~

---

## 作者：mraymes (赞：40)

本文章将同步到 [Luogu 博客](https://www.luogu.org/blog/mraymes) ~~以及 [WordPress 博客](https://mraymes.home.blog)~~ 这东西不支持 `Markdown` 所以没弄好.

一道 (稍微难一点的) 数位 DP 模板题.

数位 DP 貌似有两种做法, 一个是递推, 一个是用记忆化搜索. 这里将的是递推做法. ~~(因为我太菜了不会用记忆化搜索)~~

递推数组 `f` 定义: `f[i][j]` 表示位数为 `i` (包括前导零), 最高位为 `j` 的数中一共有多少个 windy 数.

程序分两步骤:
- 初始化 (即根据题目中的条件求出每个需要求的 `f[i][j]` 的值)
	- 这里切记: **任何关于前导零等特殊情况都不能在这里处理, 因为 "特殊情况" 并不适用于所有的情况.** 例如:

		`f[5][0]` 求的是以 `0` 开头的五位数, 其中像 `01357` 这样的数字是不被算进去的, 因为计算的时候将 `0` 也当做一个正常的数字, 并没有忽略掉. 一般来说这样的数字也算是 windy 数, 应该加进去, 但是如果它被当做一个后缀用来递推出六位数中 windy 数的数量, 即 `0` 不再是前导零时, 就必须要舍去了. 这个错误我在做另一题时也同样犯过. ~~(足以证明了我的菜.)~~

		因此, 在面对像前导零这样的情况时, 我们加一个 `g` 数组. 当一个有前导零的数不被作为后缀时 (即单独成一个数), 那么 `g` 数组的值就可以用来弥补漏算的数. `g[i]` 表示 `i` 位数有几个漏算的带有前导零的数.

	- 算的时候, 将长度比当前值小 1, 并且开头数字与当前要算的数字之差的绝对值大于等于 2 的所有 windy 数加起来即可. 具体见代码:

		```cpp
		for (int i = 0; i <= 9; i++) {
		    f[1][i] = 1;
		}
		g[1] = 2; // 漏算的数: 0, 1, 2
		
		for (int i = 2; i <= 15; i++) {
		    // i - 1 位中 0 与 1 开头的数都未被算进去
		    // 再加上已经处理完的 g[i - 1]
		    // (因为这些数也没有算在 f[i - 1][0], f[i - 1][1] 之中)
		    g[i] += f[i - 1][1] + f[i - 1][0] + g[i - 1];

		    for (int j = 0; j <= 9; j++) {
		        for (int k = 0; k <= j - 2; k++) { // 两位数差的绝对值 <= 2
		            f[i][j] += f[i - 1][k];
		        }
		        for (int k = j + 2; k <= 9; k++) { // 同上
		            f[i][j] += f[i - 1][k];
		        }
		    }
		}
		```
- 计算

	计算就是将要求的数字拆分成 10 的幂次方的倍数, 如 `24103` 可拆分成 `20000 + 4000 + 100 + 3`, 由此可知 `[0, 26503]` 区间内的 windy 数计算方式为 `(f[5][0] + f[5][1]) + (f[4][0] + f[4][1] + f[4][2] + f[4][3]) + (f[3][0]) + (f[1][0] + f[1][1] + f[1][2]) + f[1][3]`. 括号内的为一组, 根据数字的位数 (前导零算进去) 分组.

	更详细地讲:

	- `[0, 9999]` - `f[5][0]`
	- `[10000, 19999]` - `f[5][1]`
	- `[20000, 20999]` - `f[4][0]`
	- `[21000, 21999]` - `f[4][1]`
	- ...
	- `[23000, 23999]` - `f[4][3]`
	- `[24000, 24099]` - `f[3][0]`
	- `[24100, 24100]` - `f[1][0]`
	- `[24101, 24101]` - `f[1][1]`
	- `[24102, 24102]` - `f[1][2]`
	- `[24103, 24103]` - `f[1][3]`

	这里虽然类似 `f[4][1]` 的计算的并不是五位 windy 数的个数, 但是这些数是被当做**后缀**处理, 因此可以算. `2`**`0246`** 中, **`0246`** 为后缀. (这也就是前面为什么不能在第一步骤中处理前导零的原因, 因为 `0135` 本身是合法的, 但是作为后缀时, 如 `2`**`0135`** 就不合法了.)

	注意每一组的 `f` 数组的第二位最大只取到相应数位上的数减去 1, 那是因为 `f[5][2]` 是 `[20000, 29999]` 区间内的 windy 数的数量, `f[4][4]` 是 `[4000 - 4999]` 区间内 windy 数的数量, 以此类推, 而这些区间都不完全包括在区间 `[0, 26503]` 之内. 由于第一位为特殊情况, 需要单独加上 (`f[1][3]` 单独分一组, 见上述式子), 我们为了方便计算, 让计算函数 (`cnt()`) 处理形如 `[0, x)` 的区间 (`x` 不算进去). 由于函数处理的是**半开区间**, 调用的时候需要加上 1 (和 `sort()` 函数类似).

	```cpp
	// 求 [0, x) 区间内的所有 windy 数
	int cnt(int x) {
	    // 特殊情况 (其实也用不到)
	    if (x <= 0) {
	        return 0;
	    }
	
	    // 将数字的各个数位分离出来, 便于计算
	    int num[20];
	    int len = 0;
	    while (x) {
	        num[++len] = x % 10;
	        x /= 10;
	    }

	    int sum = 0;
	    // 枚举位数
	    for (int i = len; i >= 1; i--) {
	        // 当前为最高位
	        if (i == len) {
	            // 最高位取数无限制
	            for (int j = 0; j < num[i]; j++) {
	                sum += f[i][j];
	            }
	            // 是否存在带有前导零的数字 (num[i] 等于 0 无法保证)
	            if (num[i] >= 1) {
	                // 补充未计算的带有前导零的合法的 windy 数
	                sum += g[i];
	            }
	            continue;
	        }
	        // 非最高位
	
	        // 不超过上一位的数减去 2 (num[i + 1] - 2)
	        // 又保证不超过当前数位最大值 (num[i])
	        for (int j = 0; j <= min(num[i] - 1, num[i + 1] - 2); j++) {
	            sum += f[i][j];
	        }
	
	        // 至少为上一位的数加 2
	        // 又保证不超过当前数位最大值 (num[i])
	        for (int j = num[i + 1] + 2; j < num[i]; j++) {
	            sum += f[i][j];
	        }
	
	        // 如果到当前数位为止的前缀不合法则跳过
	        // 例如: x 为 54135
	        // i 为 2 (num[i] 为 4)
	        // 当前前缀为 54
	        // abs(5 - 4) < 2, 不合法, 因此跳出循环
	        if (i < len && abs(num[i] - num[i + 1]) < 2) {
	            break;
	        }
	    }

	    return sum;
	}
	```

	函数用法: (假设要求的区间为 `[l, r]`)

	```cpp
	cnt(r + 1) - cnt(l)
	```

最后贴上完整代码:
```cpp
#include <bits/stdc++.h>

using namespace std;

int f[20][10], g[20];
int l, r;

int cnt(int x) {
    if (x <= 0) {
        return 0;
    }
    int num[20];
    int len = 0;
    while (x) {
        num[++len] = x % 10;
        x /= 10;
    }

    int sum = 0;
    for (int i = len; i >= 1; i--) {
        if (i == len) {
            for (int j = 0; j < num[i]; j++) {
                sum += f[i][j];
            }
            if (num[i] >= 1) {
                sum += g[i];
            }
            continue;
        }
        for (int j = 0; j <= min(num[i] - 1, num[i + 1] - 2); j++) {
            sum += f[i][j];
        }
        for (int j = num[i + 1] + 2; j < num[i]; j++) {
            sum += f[i][j];
        }
        if (i < len && abs(num[i] - num[i + 1]) < 2) {
            break;
        }
    }

    return sum;
}

int main() {
    for (int i = 0; i <= 9; i++) {
        f[1][i] = 1;
    }
    g[1] = 2;

    for (int i = 2; i <= 15; i++) {
        g[i] += f[i - 1][1] + f[i - 1][0] + g[i - 1];
        for (int j = 0; j <= 9; j++) {
            for (int k = 0; k <= j - 2; k++) {
                f[i][j] += f[i - 1][k];
            }
            for (int k = j + 2; k <= 9; k++) {
                f[i][j] += f[i - 1][k];
            }
        }
    }

    while (cin >> l >> r) {
   		cout << cnt(r + 1) - cnt(l) << '\n';
   	}
    return 0;
}

```


---

## 作者：Katoumegumi (赞：38)

~~感觉自己写的不错的正统数位DP~~


------------

看很多数位DP的代码,你会发现,状态真是稀奇又古怪,但是却很少人用板子
$F[len][need][lim][zero]$来推.

#### 实际上,在大多数情况下这才是思维难度最小,实现最为容易的方法,配合记忆化搜索就可以去除冗杂的$for$循环了,同时思路也会更为清晰.特别是当需要的限制虽然简单但很多时,一些奇怪的状态就会被恶心到......这样写前导零,卡最高位的处理也会变得异常的简单.

$code:$

```cpp
#include<stdio.h>
#include<cmath> 
#include<algorithm>
#include<cstring> 
#define ll long long
using namespace std;

ll a,b;
ll f[20][12][2][2];
// len pre lim zero 
ll s[20];

ll dfs(ll len,ll pre,bool lim,bool zero)
{
	ll &tmp=f[len][pre][lim][zero];
	if(~tmp) return tmp;
	if(!len) return tmp=1;
	tmp=0;
	ll maxx=lim?s[len]:9;//卡最高位
	ll minn=zero?1:0;//卡前导零
	for(ll i=minn;i<=maxx;i++)
	{
		if(abs(i-pre)<2) continue;
		tmp+=dfs(len-1,i,lim&&(i==maxx),0);
	}
	return tmp;
}

ll query(ll x)
{
	if(x<=9) return x;
	memset(f,-1,sizeof(f));
	ll ans=0;
	ll len=0;
	do{
		s[++len]=x%10;
		x/=10;
	}while(x);//ps:这样写很重要!有的题会有数字0,比如HDU的"不要62"
	ans+=dfs(len,11,1,1);
//	printf("%lld\n",ans);
	for(ll i=len-1;i>=1;i--)
	ans+=dfs(i,11,0,1);
	return ans;
}

int main()
{
	scanf("%lld%lld",&a,&b);
	printf("%lld",query(b)-query(a-1));
} 
 
```

---

## 作者：Youngore (赞：22)

[更好的阅读体验](https://youngore.github.io/2020/10/10/windy%E6%95%B0/#more)

题目大意：求一段区间内不含前导零且相邻两个数字之差至少为2的正整数的个数


PS：很久以前写了一篇题解，现在无论是从码风还是代码实现上来看，都感觉那时候是个傻逼

时隔很久，终于有时间来重新整理一下思路，修改一下码风。



对于这道题目，我们直接在一段前后没有区间里搞的话，貌似不好求，于是运用一下在区间问题里面经典的前缀和思想——

对于$[1,r]$求得一个$res_1$，在$[1,l-1]$求得一个$res_2$，两者做差即是$[l,r]$内的$res$



接下来讨论如何求出$[1,一个端点]$的答案，

我们设$f[i][j]$表示当前这一位是$i$，上一位是$j$的方案数目

然后考虑转移：我们枚举每一位的$0$~$9$，特别的，如果发现上一位是有限制的，那么这一位的上限便不再是9，只能是原数中的那个数字

举个例子：

假如原数为$123456$

我们可以从$122...$转移到$1229..$，但是我们显然不能从$123...$转移到$1239..$，只能转移到$1234..$这一位上限**显然**只能是4

然后就可以大力讨论转移了。



代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 666;

inline int read()
{
   int s(0), w(1);
   char ch = getchar();
   while (ch < '0' || ch > '9') {if (ch == '-') w = -1; ch = getchar();}
   while (ch >= '0' && ch <= '9') s = s * 10 + ch - '0', ch = getchar();
   return s * w;
}

inline void put(int x)
{
   if (! x) putchar('0');
   if (x < 0) putchar('-'), x = -x;
   int num(0); char c[66];
   while (x) c[++ num] = x % 10 + 48, x /= 10;
   while (num) putchar(c[num --]);
   return (void)(putchar('\n'));
}

int n, m, cnt;
int num[N], f[N][N];
/*
pos 当前枚举的哪一位
pre 上一位是谁
flag 上一位是否达到了限制，换言之，前边搜到的数字，是否和原数字匹配了
lim 是否有前导零
*/
inline int dfs(int pos, int pre, int flag, int lim)
{
   if (! pos) return 1;
   if (! flag && f[pos][pre] != -1 && !lim) return f[pos][pre];
   int i, nex, res(0);
   nex = flag ? num[pos] : 9;
   for (i = 0; i <= nex; ++ i)
   {
      int delta = abs(pre - i);
      if (delta < 2 && ! lim) continue;
	  if (i == nex && flag) res += dfs(pos - 1, i, 1, 0);
	  else res += (i || ! lim) ? dfs(pos - 1, i, 0, 0) : dfs(pos - 1, i, 0, 1);
   }
   if (! flag && ! lim) f[pos][pre] = res;
   return res;
}

inline int calc(int x)
{
   memset (f, -1, sizeof f), cnt = 0;
   while (x) num[++ cnt] = x % 10, x /= 10;
   return dfs(cnt, 0, 1, 1);
}

signed main ()
{
   n = read(), m = read();
   put(calc(m) - calc(n - 1));
   return 0;
}

```


---

## 作者：吉良吉影 (赞：17)

本题是一道数位DP的板子题（不会的自行百度），只需要在DP过程中维护下列几个数值即可：

1.DP到第几位（ws），维护方法，开始时设为上限数的位数，然后每次向下枚举时-1s，当ws为0时输出sum并且退出枚举即可。

2.DP中对获得的结果的记录（sum），维护方法，开始时设为0，当ws为1时判断此数是否为0，不是的话就+1s

3.前导零（zero），维护方法，开始时设为0（有前导零），后面枚举时当当前位置不为0或枚举当前位前前导零即不为0时设为1（无前导零），其余时刻设为0即可。

4，上一位数字（pr），维护方法，开始时设为0，后面直接传下去即可。

5，枚举上限（rua）维护方法，这个没什么说的，如果枚举当前位前就没有达到上限或者是枚举的数字不是这一位上限时设为0（未达到上限），其余设为1（达到上限）即可。

顺便强调一点，memset一定要在每次DP前都要做，不做的话会爆零。

最后贴代码：

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cmath>
using namespace std;
typedef long long ll;
ll jojo[20][5000][2][15][2],l1,l2;
int dio[1000+1];
bool pd(int k1,int k2)
{
    if(abs(k1-k2)<2)
    {
        return 0;
    }
    else
    {
        return 1;
    }
}
ll wyyyy(int ws,ll sum,bool zero,int pr,bool rua)
{
    if(jojo[ws][sum][zero][pr][rua]!=-1)
    {
        return jojo[ws][sum][zero][pr][rua];
    }
    if(ws==0)
    {
        return sum;
    }
    ll res=0;
    for(int j=0;j<=9;j++)
    {
        if(rua==1 and j>dio[ws])
        {
            break;
        }
        if(pd(pr,j)==1 or zero==0)
        {
            res=res+wyyyy(ws-1,sum+((ws==1)&&(j!=0||zero!=0)),(zero==1||j!=0),j,(rua==1&&j==dio[ws]));
        }
    }
    jojo[ws][sum][zero][pr][rua]=res;
    return jojo[ws][sum][zero][pr][rua];
}
ll dp(ll gg)
{
    memset(jojo,-1,sizeof(jojo));    
    int ff=0;
    int go=0;
    while(gg>0)
    {
        go=gg%10;
        ff++;
        dio[ff]=go;
        gg=gg/10;
    }
    return wyyyy(ff,0,0,0,1);
}
int main()
{
    scanf("%lld%lld",&l1,&l2);
    ll sdw=dp(l2)-dp(l1-1);
    printf("%lld",sdw);
    return 0;
}
```
个人知识浅薄，水平能力有限，语言组织能力差，只能给大家分享一下我对于这道题的一些看法，想要对数位DP了解更多的可以去一些大佬的博客去求取真经。

---

## 作者：zhy137036 (赞：10)

[P2657](/problem/P2657)

在题解界面里 LaTeX 可能会挂，请去 [博客](https://www.luogu.com.cn/blog/zhy123456/shu-wei-dp) 里查看。

## 预处理（状态）

设 $f_{i,j}$ 表示第 $i$ 位（个位为第 $1$ 位）的数字是 $j$ 的 $i$ 位数中，有多少 windy 数。

例如，$f_{3,5}$ 表示 $[500,600)$ 中 windy 数的个数。

那如何计算 $f_{3,5}$ 呢？

$$500\sim599=\begin{cases}
	500\sim509\implies00\sim09=f_{2,0}\\
    510\sim519\implies10\sim19=f_{2,1}\\
    520\sim529\implies20\sim29=f_{2,2}\\
    530\sim539\implies30\sim39=f_{2,3}\\
    \xcancel{540\sim549}\\
    \xcancel{550\sim559}\\
    \xcancel{560\sim569}\\
    570\sim579\implies70\sim79=f_{2,7}\\
    580\sim589\implies80\sim89=f_{2,8}\\
    590\sim599\implies90\sim99=f_{2,9}\\
\end{cases}$$

注意到 $540\sim560$ 中没有 windy 数。

易证 $500\sim509$ 中的 windy 数和 $00\sim09$（包括前导 0）中的 windy 数一一对应，其他同理。

于是写出代码：

```cpp
for(int i=0;i<10;i++) f[1][i]=1;//1 位数都是 windy 数
//特殊地，0 位数即 0，也可以被认为是 windy 数（虽然不满足定义）
for(int i=2;i<=10;i++)//枚举位数
	for(int j=0;j<10;j++)//枚举第 i 位的数
		for(int k=0;k<10;k++)//枚举第 i-1 位的数
			if(abs(j-k)>1)//如果差大于等于 2
				f[i][j]+=f[i-1][k];//累加上
```

## 计算 I

$l\sim r$ 的 windy 数不好求，可以将 $0\sim r$ 中 windy 数的个数减去 $0\sim l-1$ 中 windy 数的个数求得。于是定义 $g_i$ 函数，表示 $0\sim i$ 中 windy 数的个数。

例如，如何计算 $g_{2451}$呢？

$$g_{2451}=\begin{cases}
	0\sim1999\\
    2000\sim2399\\
    2400\sim2449\\
    2450\sim2450
\end{cases}$$

等等，最后一个不是 $2450\sim2451$ 吗？  
观察前几个范围，发现都是到该位少 $1$，而个位单独特判一下比较麻烦，所以更改定义：$g_{i}$ 表示 $0\sim i-1$ 中 windy 数的个数。

继续：

$$0\sim1999=\begin{cases}
	0\sim999=f_{4,0}\\
    1000\sim1999=f_{4,1}
\end{cases}$$

上式对吗？不对！

还记得 $f_{3,0}$ 表示的是 $0000\sim0999$ 中 windy 数的个数吗？这是带前导 0 的，而要求的不能带前导 0。  
比如 $1$ 是 windy 数，而 $0001$ 不是。

怎么办呢？我们定义一个 $s$ 函数。

## $s$ 函数

$s_i$ 表示 $0\sim10^i-1$（不带前导 0）中 windy 数的个数。

例如 $s_3$：

$$0\sim999=\begin{cases}
	0\sim99=s_2\\
    100\sim199=f_{3,0}\\
    200\sim299=f_{3,1}\\
    \cdots\\
    900\sim999=f_{3,9}
\end{cases}$$

$s$ 函数可以在计算 $f$ 的时候同时计算出来：

```cpp
sum[0]=1; sum[1]=10;//这俩要提前算
for(int i=2;i<=15;i++){
	for(int j=0;j<10;j++)
		for(int k=0;k<10;k++)
			if(abs(j-k)>1)
				f[i][j]+=f[i-1][k];
	sum[i]=sum[i-1];
	for(int j=1;j<10;j++) sum[i]+=f[i][j];
}
```

## 计算 II

回来继续算 $g_{2451}$。

$$g_{2451}=\begin{cases}
	0\sim1999=\begin{cases}
		0\sim999=s_3\\
    	1000\sim1999=f_{4,1}
	\end{cases}\\
    2000\sim2399=\begin{cases}
    	2000\sim2099\implies000\sim099=f_{3,0}\\
        \xcancel{2100\sim2199}\\
        \xcancel{2200\sim2299}\\
        \xcancel{2300\sim2399}
    \end{cases}\\
    2400\sim2449=\begin{cases}
    	2400\sim2409\implies00\sim09=f_{2,0}\\
        2410\sim2419\implies10\sim29=f_{2,1}\\
        2420\sim2429\implies10\sim29=f_{2,2}\\
        \xcancel{2430\sim2439}\\
        \xcancel{2440\sim2449}
    \end{cases}\\
    \xcancel{2450\sim2450}
\end{cases}$$

大概都是能看懂的，这里说一下最后一行：因为十位和百位差小于 $2$，所以整个都弃掉了。所以一旦发现相邻两位差小于 $2$，直接跳出不再算。

思路了解了，就要写代码了：

```cpp
int work(int x){
	int cnt=0,ans=0;//cnt 是 x 的位数，ans 记录答案
	for(;x;x/=10) a[++cnt]=x%10;//将 x 的各位存到数组里，方便处理
	ans+=sum[cnt-1];//这行和下一行计算最高位
	for(int i=1;i<a[cnt];i++) ans+=f[cnt][i];
	for(int i=cnt-1;i;i--){//计算剩余每位
		for(int j=0;j<a[i];j++)
			if(abs(j-a[i+1])>1) ans+=f[i][j];
		if(abs(a[i+1]-a[i])<2) break;//如果差小于2，跳出
	}
	return ans;
}
```

## 完整代码

```cpp
#include<iostream>
#include<cmath>
using namespace std;
int lft,rght,f[20][20],sum[20],a[20];
int work(int x){
	int cnt=0,ans=0;
	for(;x;x/=10) a[++cnt]=x%10;
	ans+=sum[cnt-1];
	for(int i=1;i<a[cnt];i++) ans+=f[cnt][i];
	for(int i=cnt-1;i;i--){
		for(int j=0;j<a[i];j++)
			if(abs(j-a[i+1])>1) ans+=f[i][j];
		if(abs(a[i+1]-a[i])<2) break;
	}
	return ans;
}
int main(){
	cin>>lft>>rght;
	for(int i=0;i<10;i++) f[1][i]=1;
	sum[0]=1; sum[1]=10;
	for(int i=2;i<=15;i++){
		for(int j=0;j<10;j++)
			for(int k=0;k<10;k++)
				if(abs(j-k)>1)
					f[i][j]+=f[i-1][k];
		sum[i]=sum[i-1];
		for(int j=1;j<10;j++) sum[i]+=f[i][j];
	}
	cout<<work(rght+1)-work(lft)<<endl;
	return 0;
}
```

---

## 作者：Yuyuanqi (赞：6)

# P2657 [SCOI2009]windy数

### 题目描述
windy定义了一种windy数。不含前导零且相邻两个数字之差至少为2的正整数被称为windy数。 windy想知道，

在A和B之间，包括A和B，总共有多少个windy数？


### 输入格式

包含两个整数，A B。

### 输出格式

一个整数

&nbsp;
## 思路
首先很明显这是一个数位dp，~~我觉得~~数位dp在dp里面是很有很有套路性的，大部分都是预处理答案+统计并累加答案。

那么这道题询问一个区间[A,B]，如果用暴力的思维直接从A枚举到B想必是会超~~麻烦~~，所以我们要用前缀和。通过算法求出[0,K]的答案个数再进行加减即可获得[A,B]的答案个数。

我们首先预处理得到dp[i][j]，表示这个数的最高位 第i位 是j时windy数的个数（j此时是不是0我们不管）。转移方程dp[i][j] = sum{dp[i-1][k]} k在[0,9]之间且|k-j|>=2。

那么如何用dp数组求[0,K]的答案个数呢？我们先假设K是53575（是一个windy数）

我们考虑所有最高位是[1,5)的五位数[10000,49999]

然后再把答案加上所有位数小于五位的wendy数（这两步比较好理解）

最后统计[50000,K],因为最高位5已经定了所以我们从次高位依次往低位扫描,然后枚举小于这个位置上的数 且符合要求的数的个数。比如说我们到了3, 2、1、0都小于3且和前一位5的差值大于2，所以答案+=dp[4][2]+dp[4][1]+dp[4][0]，这个时候我们认为这一位就是3，然后看下一位5......以此类推

如果这个数是53475我们便不能认为第三位是4了（因为3和4差值小于2）所以后面的解都已经统计过了，可以跳出循环返回答案（想想这是为什么）

下面看代码吧注释挺多的

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std;

#define ll long long
#define re register

int dp[20][15];//dp[i][j]记录最高位（第i位）是j时 windy数的个数
int temp[20];//用来拆分数位的临时数组
int a, b;//题目输入
int abs(int x) { return x > 0 ? x : -x; } //手写abs
inline int read()
{
	int x = 0, f = 1;
	char c = getchar();
	while (c < '0' || c > '9') { if (c == '-') f = -1; c = getchar(); }
	while (c >= '0' && c <= '9') { x = x * 10 + c - '0'; c = getchar(); }
	return x * f;
}
int fx(int x)//计算 [0,x) 之间的windy数个数 后面会解释为什么左闭右开
{
	int l = 0, ans = 0; //数字的位数 答案
	memset(temp, 0, sizeof(temp)); //初始化
	while (x)
	{
		temp[++l] = x % 10;
		x /= 10;
	}//拆数
	for (int i = 1; i < temp[l]; i++)
		ans += dp[l][i];
	//统计位数是l的且严格小于x的windy数个数
	for (int i = 1; i < l; i++)
		for (int j = 1; j <= 9; j++)
			ans += dp[i][j];
	//统计位数在[0,l)之间的windy数个数
	for (int i = l - 1; i >= 1; i--)
	{//对于除最高位的每一位，我们枚举他们小于temp[i]的所有情况，然后默认他们等于temp[i]，累加至答案
		for (int j = 0; j < temp[i]; j++)
		{
			if (abs(j - temp[i + 1]) >= 2) ans += dp[i][j];
		}//然后默认他们就是temp[i]，来判断后面的数位是否合法
		if (abs(temp[i] - temp[i + 1]) < 2) break;
		//若枚举的这一位和前一位差值小于2 这一位和前一位不能同时是原数 所以这种情况已经统计过了 于是退出
	}
	//若x恰好是一个windy数 因为上面j循环没有循环到temp[i] 所以dp[1][temp[1]]没有对答案有贡献
	//所以说fx()的区间是左闭右开的
	return ans;
}

int main()
{
	for (int i = 0; i <= 9; i++) dp[1][i] = 1;
	for (int i = 2; i <= 15; i++)
	{
		for (int j = 0; j <= 9; j++)
		{
			for (int k = 0; k <= 9; k++)
			{
				if (abs(j - k) >= 2)
				{
					dp[i][j] += dp[i - 1][k];
				}
			}
		}
	}//初始化
	a = read(), b = read();
	cout << fx(b + 1) - fx(a); //f[x]求得的区间是左闭右开的
	return 0;
}
```

---

## 作者：Anguei (赞：5)

~~这一看就是一个分段打表题~~

思路：每隔 $1000000$ 分一段，总共 $2000$ 段。预先打表计算出每一段当中的 windy 数个数，根据输入确定 $A,B$ 在哪一段当中。如果在同一段，那就直接暴力。否则先把中间那些段求和，再对两头的小块暴力。

有点类似分块：维护大的，暴力小的。

现有题解打表是求出 $1$ ~ $n$ 的 windy 数个数，最后统计答案需要搞一搞前缀和。如果打表的时候计算每一段的 windy 数个数，最后直接计算就可以了，感觉方便一些。

### 判断是不是一个 windy 数
```cpp
bool calc(int x) {
    int last = x % 10; x /= 10;
    while (x) {
        int now = x % 10; x /= 10;
        if (abs(last - now) < 2) return false;
        last = now;
    }
    return true;
}
```

### 生成表（大概两三分钟跑完）
```cpp
void makeTable() {
    for (int i = 1; i <= 2000000000; i += 1000000) {
        int l = i, r = std::min(2000000000ll, i + 1000000 - 1), ans = 0;
        rep(j, l, r) if (calc(j)) ++ans;
        print(ans), pc(','), pc(' ');
    }
}
```

### 主程序
```cpp
void solution() {
    int a = read(), b = read(), ans = 0;
    int blockA = a / 1000000 + 1, blockB = b / 1000000 + 1;
    // 同一块的直接暴力搞，否则用表。
    if (blockA == blockB) { rep(i, a, b) ans += calc(i); println(ans); return; }
    rep(i, blockA + 1, blockB - 1) ans += table[i];
    rep(i, a, a / 1000000 * 1000000 + 1000000) ans += calc(i);
    rep(i, b - b % 1000000, b) ans += calc(i);
    println(ans);
}
```

### 最后把表贴上
```cpp
const int table[] = { -1, 202174, 136131, 138503, 138214, 138252, 138252, 138214, 138503, 136131, 155315, 
                      0, 0, 0, 138214, 138252, 138252, 138214, 138503, 136131, 155315, 
                      155315, 0, 0, 0, 138252, 138252, 138214, 138503, 136131, 155315, 
                      155315, 136131, 0, 0, 0, 138252, 138214, 138503, 136131, 155315, 
                      155315, 136131, 138503, 0, 0, 0, 138214, 138503, 136131, 155315, 
                      155315, 136131, 138503, 138214, 0, 0, 0, 138503, 136131, 155315, 
                      155315, 136131, 138503, 138214, 138252, 0, 0, 0, 136131, 155315, 
                      155315, 136131, 138503, 138214, 138252, 138252, 0, 0, 0, 155315, 
                      155315, 136131, 138503, 138214, 138252, 138252, 138214, 0, 0, 0, 
                      155315, 136131, 138503, 138214, 138252, 138252, 138214, 138503, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      155315, 136131, 0, 0, 0, 138252, 138214, 138503, 136131, 155315, 
                      155315, 136131, 138503, 0, 0, 0, 138214, 138503, 136131, 155315, 
                      155315, 136131, 138503, 138214, 0, 0, 0, 138503, 136131, 155315, 
                      155315, 136131, 138503, 138214, 138252, 0, 0, 0, 136131, 155315, 
                      155315, 136131, 138503, 138214, 138252, 138252, 0, 0, 0, 155315, 
                      155315, 136131, 138503, 138214, 138252, 138252, 138214, 0, 0, 0, 
                      155315, 136131, 138503, 138214, 138252, 138252, 138214, 138503, 0, 0, 
                      0, 0, 138503, 138214, 138252, 138252, 138214, 138503, 136131, 155315, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      155315, 136131, 138503, 0, 0, 0, 138214, 138503, 136131, 155315, 
                      155315, 136131, 138503, 138214, 0, 0, 0, 138503, 136131, 155315, 
                      155315, 136131, 138503, 138214, 138252, 0, 0, 0, 136131, 155315, 
                      155315, 136131, 138503, 138214, 138252, 138252, 0, 0, 0, 155315, 
                      155315, 136131, 138503, 138214, 138252, 138252, 138214, 0, 0, 0, 
                      155315, 136131, 138503, 138214, 138252, 138252, 138214, 138503, 0, 0, 
                      0, 0, 138503, 138214, 138252, 138252, 138214, 138503, 136131, 155315, 
                      0, 0, 0, 138214, 138252, 138252, 138214, 138503, 136131, 155315, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      155315, 136131, 138503, 138214, 0, 0, 0, 138503, 136131, 155315, 
                      155315, 136131, 138503, 138214, 138252, 0, 0, 0, 136131, 155315, 
                      155315, 136131, 138503, 138214, 138252, 138252, 0, 0, 0, 155315, 
                      155315, 136131, 138503, 138214, 138252, 138252, 138214, 0, 0, 0, 
                      155315, 136131, 138503, 138214, 138252, 138252, 138214, 138503, 0, 0, 
                      0, 0, 138503, 138214, 138252, 138252, 138214, 138503, 136131, 155315, 
                      0, 0, 0, 138214, 138252, 138252, 138214, 138503, 136131, 155315, 
                      155315, 0, 0, 0, 138252, 138252, 138214, 138503, 136131, 155315, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      155315, 136131, 138503, 138214, 138252, 0, 0, 0, 136131, 155315, 
                      155315, 136131, 138503, 138214, 138252, 138252, 0, 0, 0, 155315, 
                      155315, 136131, 138503, 138214, 138252, 138252, 138214, 0, 0, 0, 
                      155315, 136131, 138503, 138214, 138252, 138252, 138214, 138503, 0, 0, 
                      0, 0, 138503, 138214, 138252, 138252, 138214, 138503, 136131, 155315, 
                      0, 0, 0, 138214, 138252, 138252, 138214, 138503, 136131, 155315, 
                      155315, 0, 0, 0, 138252, 138252, 138214, 138503, 136131, 155315, 
                      155315, 136131, 0, 0, 0, 138252, 138214, 138503, 136131, 155315, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      155315, 136131, 138503, 138214, 138252, 138252, 0, 0, 0, 155315, 
                      155315, 136131, 138503, 138214, 138252, 138252, 138214, 0, 0, 0, 
                      155315, 136131, 138503, 138214, 138252, 138252, 138214, 138503, 0, 0, 
                      0, 0, 138503, 138214, 138252, 138252, 138214, 138503, 136131, 155315, 
                      0, 0, 0, 138214, 138252, 138252, 138214, 138503, 136131, 155315, 
                      155315, 0, 0, 0, 138252, 138252, 138214, 138503, 136131, 155315, 
                      155315, 136131, 0, 0, 0, 138252, 138214, 138503, 136131, 155315, 
                      155315, 136131, 138503, 0, 0, 0, 138214, 138503, 136131, 155315, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      155315, 136131, 138503, 138214, 138252, 138252, 138214, 0, 0, 0, 
                      155315, 136131, 138503, 138214, 138252, 138252, 138214, 138503, 0, 0, 
                      0, 0, 138503, 138214, 138252, 138252, 138214, 138503, 136131, 155315, 
                      0, 0, 0, 138214, 138252, 138252, 138214, 138503, 136131, 155315, 
                      155315, 0, 0, 0, 138252, 138252, 138214, 138503, 136131, 155315, 
                      155315, 136131, 0, 0, 0, 138252, 138214, 138503, 136131, 155315, 
                      155315, 136131, 138503, 0, 0, 0, 138214, 138503, 136131, 155315, 
                      155315, 136131, 138503, 138214, 0, 0, 0, 138503, 136131, 155315, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      155315, 136131, 138503, 138214, 138252, 138252, 138214, 138503, 0, 0, 
                      0, 0, 138503, 138214, 138252, 138252, 138214, 138503, 136131, 155315, 
                      0, 0, 0, 138214, 138252, 138252, 138214, 138503, 136131, 155315, 
                      155315, 0, 0, 0, 138252, 138252, 138214, 138503, 136131, 155315, 
                      155315, 136131, 0, 0, 0, 138252, 138214, 138503, 136131, 155315, 
                      155315, 136131, 138503, 0, 0, 0, 138214, 138503, 136131, 155315, 
                      155315, 136131, 138503, 138214, 0, 0, 0, 138503, 136131, 155315, 
                      155315, 136131, 138503, 138214, 138252, 0, 0, 0, 136131, 155315, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 138503, 138214, 138252, 138252, 138214, 138503, 136131, 155315, 
                      0, 0, 0, 138214, 138252, 138252, 138214, 138503, 136131, 155315, 
                      155315, 0, 0, 0, 138252, 138252, 138214, 138503, 136131, 155315, 
                      155315, 136131, 0, 0, 0, 138252, 138214, 138503, 136131, 155315, 
                      155315, 136131, 138503, 0, 0, 0, 138214, 138503, 136131, 155315, 
                      155315, 136131, 138503, 138214, 0, 0, 0, 138503, 136131, 155315, 
                      155315, 136131, 138503, 138214, 138252, 0, 0, 0, 136131, 155315, 
                      155315, 136131, 138503, 138214, 138252, 138252, 0, 0, 0, 155315, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 138503, 138214, 138252, 138252, 138214, 138503, 136131, 155315, 
                      0, 0, 0, 138214, 138252, 138252, 138214, 138503, 136131, 155315, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      155315, 136131, 138503, 138214, 0, 0, 0, 138503, 136131, 155315, 
                      155315, 136131, 138503, 138214, 138252, 0, 0, 0, 136131, 155315, 
                      155315, 136131, 138503, 138214, 138252, 138252, 0, 0, 0, 155315, 
                      155315, 136131, 138503, 138214, 138252, 138252, 138214, 0, 0, 0, 
                      155315, 136131, 138503, 138214, 138252, 138252, 138214, 138503, 0, 0, 
                      0, 0, 138503, 138214, 138252, 138252, 138214, 138503, 136131, 155315, 
                      0, 0, 0, 138214, 138252, 138252, 138214, 138503, 136131, 155315, 
                      155315, 0, 0, 0, 138252, 138252, 138214, 138503, 136131, 155315, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      155315, 136131, 138503, 138214, 138252, 0, 0, 0, 136131, 155315, 
                      155315, 136131, 138503, 138214, 138252, 138252, 0, 0, 0, 155315, 
                      155315, 136131, 138503, 138214, 138252, 138252, 138214, 0, 0, 0, 
                      155315, 136131, 138503, 138214, 138252, 138252, 138214, 138503, 0, 0, 
                      0, 0, 138503, 138214, 138252, 138252, 138214, 138503, 136131, 155315, 
                      0, 0, 0, 138214, 138252, 138252, 138214, 138503, 136131, 155315, 
                      155315, 0, 0, 0, 138252, 138252, 138214, 138503, 136131, 155315, 
                      155315, 136131, 0, 0, 0, 138252, 138214, 138503, 136131, 155315, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      155315, 136131, 138503, 138214, 138252, 138252, 0, 0, 0, 155315, 
                      155315, 136131, 138503, 138214, 138252, 138252, 138214, 0, 0, 0, 
                      155315, 136131, 138503, 138214, 138252, 138252, 138214, 138503, 0, 0, 
                      0, 0, 138503, 138214, 138252, 138252, 138214, 138503, 136131, 155315, 
                      0, 0, 0, 138214, 138252, 138252, 138214, 138503, 136131, 155315, 
                      155315, 0, 0, 0, 138252, 138252, 138214, 138503, 136131, 155315, 
                      155315, 136131, 0, 0, 0, 138252, 138214, 138503, 136131, 155315, 
                      155315, 136131, 138503, 0, 0, 0, 138214, 138503, 136131, 155315, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      155315, 136131, 138503, 138214, 138252, 138252, 138214, 0, 0, 0, 
                      155315, 136131, 138503, 138214, 138252, 138252, 138214, 138503, 0, 0, 
                      0, 0, 138503, 138214, 138252, 138252, 138214, 138503, 136131, 155315, 
                      0, 0, 0, 138214, 138252, 138252, 138214, 138503, 136131, 155315, 
                      155315, 0, 0, 0, 138252, 138252, 138214, 138503, 136131, 155315, 
                      155315, 136131, 0, 0, 0, 138252, 138214, 138503, 136131, 155315, 
                      155315, 136131, 138503, 0, 0, 0, 138214, 138503, 136131, 155315, 
                      155315, 136131, 138503, 138214, 0, 0, 0, 138503, 136131, 155315, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      155315, 136131, 138503, 138214, 138252, 138252, 138214, 138503, 0, 0, 
                      0, 0, 138503, 138214, 138252, 138252, 138214, 138503, 136131, 155315, 
                      0, 0, 0, 138214, 138252, 138252, 138214, 138503, 136131, 155315, 
                      155315, 0, 0, 0, 138252, 138252, 138214, 138503, 136131, 155315, 
                      155315, 136131, 0, 0, 0, 138252, 138214, 138503, 136131, 155315, 
                      155315, 136131, 138503, 0, 0, 0, 138214, 138503, 136131, 155315, 
                      155315, 136131, 138503, 138214, 0, 0, 0, 138503, 136131, 155315, 
                      155315, 136131, 138503, 138214, 138252, 0, 0, 0, 136131, 155315, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 138503, 138214, 138252, 138252, 138214, 138503, 136131, 155315, 
                      0, 0, 0, 138214, 138252, 138252, 138214, 138503, 136131, 155315, 
                      155315, 0, 0, 0, 138252, 138252, 138214, 138503, 136131, 155315, 
                      155315, 136131, 0, 0, 0, 138252, 138214, 138503, 136131, 155315, 
                      155315, 136131, 138503, 0, 0, 0, 138214, 138503, 136131, 155315, 
                      155315, 136131, 138503, 138214, 0, 0, 0, 138503, 136131, 155315, 
                      155315, 136131, 138503, 138214, 138252, 0, 0, 0, 136131, 155315, 
                      155315, 136131, 138503, 138214, 138252, 138252, 0, 0, 0, 155315, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
                      0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
```

### 最后源程序大小 17 KB，没有超过 NOI 系列赛事的 100 KB 限制。

---

## 作者：BFSBFSBFSBFS (赞：5)

~~(至今我没写过正规的数位DP...)..~~..

下面介绍1种奇怪的思路.适用于水过1些数位dp的题目..

暂时称之为.urdc...(不要问我这是什么.)..

主题思路.
```
求0~13678中符合要求的数.
可以转换为.求.
0~9999.
10000~12999.
13000~13599.
13600~13669.
13670~13677.
13678.
这几部分个数加起来.
再看下面几部分.
0000~9999.
0000~2999.
000~599.
00~69.
0~7.
0.
如果没有与题目要求冲突,这几部分完全等价上面几部分.
相当于只要,求整十整百整千这些东西.
而这种东西1般可以dp预处理,或者直接算出.
```
如果没有看懂.请看下面的题目具体分析.

------------

题意.求[a,b]中的相邻2个数之差 >= 2数的总数.没有前导0.

显然[a,b]可以转换为.[0,b]-[0,a-1].

先思考如何求[0,10^k-1].

设**f[i,j]**表示以j为第i位的windy数总数.个位是第1位.

如**f[2,3] = 7**,有30,31,35,36,37,38,39.

注意前导0不去管它.

这个很好求.

$f[i,j] = \sum_{k = 0}^{9}{f[i-1,k]\ (abs(j-k) >= 2)}$.

其中**f[1,i] = 1**.

所以答案似乎是.

$[0,10^i-1] = \sum_{j = 0}^{9}f[i,j]$.

然而对拍发现并不对...

发现**f[i,0]**出事.

**j = 0**相当于前导0,不受约束条件.

所以单独计算**f[i,0]**.

$last[i] = last[i-1]+\sum_{j = 1}^{9}f[i-1,j]$.

怎么变**last[i]**了..

**如果更高位还有不是0的,这个0依旧受限.**

也就是计算**非f[i,0]**的东西要用到**f[i,0]**.

所以发现.

$[0,10^i-1] = last[i+1] = last[i]+\sum_{j=1}^{9}f[i,j]$.

其中**last[1] = 1**.

啊,~~愉快~~的预处理完了..

------------

接下来看如何计算.

像上面1样,对n进行分割.

怎么弄的...按位啊...

第i位对答案的贡献.

$\sum_{j=0}^{p-1}f[i,j]$.

p是n第i位上的数.

就是忽略了高位的数来直接计算答案.

当然限制条件要有.

得从高位计算,上面计算到13670~13670的时候直接break.

若所有计算都满足限制,答案额外加1.就是上面孤立的1部分.

以及最高位的**f[i,0]**实际贡献是**last[i]**.理由治己想.

------------

所以这么复杂的东西有什么用...

····思维暴力........

····可以通过预处理规避前导0的计算.

**注意,last数组是由于前导0特性与限制条件共同影响产生的.预处理计算上仍然不用管前导0.**

所以只是个针对前导0优化...?

当然效率也很高了...

Diu代码.
```
program P2657;
 uses math;
 var
  t:array[0..11,0..9] of int64;
  lastt:array[0..11] of int64;
  i,j,k,n,l,r,p,ssum,lasted,haha,upass:longint;
  ts:int64;
 procedure hahacheck;   //我用来验证的..
  var
   i,j:longint;
  begin
   //writeln(n);
   for i:=1 to n do
    begin
     for j:=0 to 9 do
      write(t[i,j],' ');
     writeln(lastt[i]);
    end;
  end;
 function hahasum(n:longint):longint;
  begin
   if n=-1 then exit(0);
   if n=0 then exit(1);   //由于log不能为0所以只能特判..
   k:=trunc(log10(n))+1;  //计算n总共有几位.
   ts:=1;
   while ts<=n do
    ts:=ts*10;
   ts:=ts div 10;         //用来取出n的当前位.
   ssum:=0;               //计算答案.
   lasted:=1008208820;    //判断是否合法.
   haha:=0;               //特判标记.
   upass:=1;              //合法标记.
   while ts>=1 do
    begin
     inc(haha);
     p:=n div ts;
     n:=n mod ts;
     ts:=ts div 10;
     if abs(p-lasted)<=1 then upass:=0;   //与上1位冲突.
     for i:=0 to p-1 do
      if abs(lasted-i)>=2 then
       if (haha=1) and (i=0) then inc(ssum,lastt[k])
                             else inc(ssum,t[k-haha+1,i]);  //之前讲的对答案的贡献..
     lasted:=p;
     if upass=0 then break;               //不能继续做.
    end;
   hahasum:=ssum+upass;
  end;
 begin
  readln(l,r);
  n:=trunc(log10(r)+1);
  //hahacheck;
  for i:=0 to 9 do
   t[1,i]:=1;
  lastt[0]:=0;
  lastt[1]:=1;
  for i:=2 to n do           //预处理....
   for j:=0 to 9 do
    begin
     t[i,j]:=0;
     for k:=0 to j-2 do
      inc(t[i,j],t[i-1,k]);
     for k:=j+2 to 9 do
      inc(t[i,j],t[i-1,k]);
     if j=0 then
      begin
       lastt[i]:=0;
       for k:=1 to 9 do
        inc(lastt[i],t[i-1,k]);
       dec(lastt[i],-lastt[i-1]);
      end;
    end;
  //hahacheck;
  writeln(hahasum(r)-hahasum(l-1));
 end.
```
(ಡωಡ).


---

## 作者：PragmaGCC (赞：4)

数位 DP 经典题

~~上课时老师带着我们打的，写篇题解权当复习~~

这里运用的是记忆化搜索的实现方法，输入的是 string

因为是求区间，所以考虑前缀和

考虑到 string 如果还是使用 -1 的方法会出锅，所以定义了一个 check 函数

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 10;//数字有10个
string a, b;
string s;
int len, dp[maxn][maxn][2][2], ans;
//len是字符串的长度，也就是数的长度
//ans就是答案

int dfs(int cur, int x, bool f, bool g) //深搜（记忆化）
{                                       //当前位置，前一位，上限与前导零
    if (cur == len)
        return 1;
    if (dp[cur][x][f][g] != -1)
        return dp[cur][x][f][g]; //搜过了，直接返回
    int v = 9;                   //9是最大的“数字”
    if (f == 1)
        v = (s[cur] - '0');
    int sum = 0;
    for (int i = 0; i <= v; i++)
    {
        if (g == 1)
        {
            if (i == 0)
                sum += dfs(cur + 1, 0, f & (i == v), 1); //累加
            else
                sum += dfs(cur + 1, i, f & (i == v), 0);
        }
        else if (abs(i - x) >= 2) //差不能小于2
            sum += dfs(cur + 1, i, f & (i == v), 0);
    }
    return dp[cur][x][f][g] = sum; //返回并保存
}
int solve(string t) //求windy数的个数
{
    s = t;
    len = s.size();
    memset(dp, -1, sizeof(dp));
    return dfs(0, 0, 1, 1);
}
int ck(string &t) //处理无法“a-1”
{
    for (int i = 1; i < t.size(); i++)
    {
        if (abs(t[i] - t[i - 1]) < 2)
            return 0;
    }
    return 1;
}

int main(void)
{
    cin >> a >> b;
    ans = solve(b) - solve(a) + ck(a);
    cout << ans << endl;
    return 0;
}
```
初学数位 DP ，写的可能不是很好，如有问题望提出改进意见

---

## 作者：R·Buffoon (赞：4)

一直把$windy$看成$wendy$，雾
***
数据范围$[1,2000000000]$，显然，暴力过不了，所以，只能用其他算法

死盯着题目大半天，没看出个什么东西，于是点开标签。嗯？数位DP？我还没学呀

为了A掉这道题，我硬着头皮学完了它（只是模板，但是可以A这道题）
***
**数位DP，就是用来解决区间$[L,R]$内满足某个性质的数的个数，且这个性质与数的大小无关**

**数位的含义：一个数有个位、十位、百位、千位......数的每一位就是数位**
***
数位dp是从上界的最高位开始枚举，一位一位向下，一直枚举到个位

$For\space example$:  
上界为213，则从百位开始枚举，百位有2种情况，1和2  
如果是2的话，十位上的数就要$>=4$，这就超过上界了，所以百位只能为1  
百位为1，十位就要$>=3$，当十位为3，向下枚举个位  
十位为3，个位就要$<=1$或者$>=5$，下面已经没有数位了，返回

至于下界，一般是0或1，就不讲了
***
代码讲解可能更好理解

```cpp
#include<bits/stdc++.h>
#define RI register int
#define LL long long
using namespace std;

int in()
{
    int qwq=0,qaq=1;char cc=getchar();
    for(;!isdigit(cc);cc=getchar())if(cc=='-')qaq=-1;
    for(;isdigit(cc);cc=getchar()) qwq=(qwq<<1)+(qwq<<3)+(cc&15);
    return qwq*qaq;
}

const int N=22;

int a,b;
int dp[N][N],num[N];

//len表示当前数位长度,last表示当前最后一个数(-10表示没数),up表示有无上限限制(0表示无限制，可以从0枚举到9)
//举例：一个数上界为2536，枚举到20??（共有4位），len就是2（还有2位没枚举），last就是0，up为0
//如果枚举到25??，就有上限了，up为1，百位只能从0枚举到3，再枚举就超过上界了
int dfs(int len,int last,bool up)
{
	if(!len) return 1;//枚举完了，说明这个数就是windy数，返回1
	
	if(!up && last>=0 && dp[len][last]!=-1) return dp[len][last];//记忆化搜索
	
	int p,cnt=0,mx=(up?num[len]:9);//如果有限制，就只能从0枚举到上界的这个数位
	for(RI i=0;i<=mx;++i)
	{
		if(abs(i-last)<2) continue;//题目条件
		
		if(!i && last==-10) p=-10;//如果前面没有数且i为0，则下一位也没有数（去前导0）
		else p=i;
		
		cnt+=dfs(len-1,p,up&&i==mx);
        //如果当前有限制且枚举到了最高位，则下一个也有限制
        //同上例，枚举到了253?，则个位只能从0枚举到6
	}
	
	if(!up && last>=0) dp[len][last]=cnt;//更新值
	
	return cnt;
}

int solve(int x)
{
	int k=0;
	while(x)
	{
		num[++k]=x%10;//储存每一位的值
		x/=10;
	}
	
	memset(dp,-1,sizeof(dp));//记得初始化
	return dfs(k,-10,1);//第一位数总有上限限制（除非是上界首位是9）
}

int main()
{
	a=in(),b=in();
	
	printf("%d\n",solve(b)-solve(a-1));//这里有前缀和的思想
	
    return 0;
}
```

做完这题，对数位dp也有了个初步的了解

所以，推荐一道题，[不要62](http://acm.hdu.edu.cn/showproblem.php?pid=2089)（来自HDUOJ），比这道简单些

因为怕大家没账号（虽然可以注册），所以我把它搬到了[个人题库](https://www.luogu.org/problem/U94702)，加上了垃圾数据，欢迎大家来A（~~我才不是宣传个人题目勒~~）

---

## 作者：kkxhh (赞：4)

设 $d(pos,las,lim,lead)$ 为剩下 $pos$ 个位置，前一个数为 $las$ 的答案（$lim=1$ 表示受到限制，$lead=1$ 表示有前导 $0$）

我们考虑用记忆化搜索，记录下 $lim=0$ 且 $lead=0$ 时的所有 $d(pos,las)$ 的答案

转移的时候，对于每个状态从 $0$ 枚举到 $9$ （如果 $lim=1$ 则为从 $0$ 到 $num_{pos}$），如果可行就加上向下转移的答案（当 $lead=1$ 时任意数字都可行，因为此时不受前面数字的限制）

转移后 $lim=1$ 成立仅当当前 $lim=1$ 且 $i=num_{pos}$，$lead=1$ 成立仅当当前 $lead=1$ 且 $i=0$

代码如下：

```cpp
#include <cstdio>
#include <algorithm>
#include <cmath>
using namespace std;

int l,r,num[20],d[20][20],vis[20][20];

inline int read(){
    int num=0,k=1; char c=getchar();
    while(c>'9' || c<'0') k=(c=='-')?0:k,c=getchar();
    while(c>='0' && c<='9') num=num*10+c-'0',c=getchar();
    return k?num:-num;
}

int dp(int pos,int las,int lim,int lead){
    if(pos==0) return 1;
    if(vis[pos][las] && !lim && !lead) return d[pos][las];
    int cur=0;
    for(int i=0;i<=(lim?num[pos]:9);i++) if(lead || abs(i-las)>=2) cur+=dp(pos-1,i,(lim && i==num[pos]),(lead && !i));
    if(!lim && !lead) d[pos][las]=cur,vis[pos][las]=1;
    return cur;
}

int solve(int x){
    int len=0;
    while(x) num[++len]=x%10,x/=10;
    return dp(len,0,1,1);
}

int main(){
    l=read(); r=read();
    printf("%d",solve(r)-solve(l-1));
    return 0;
}

```

---

## 作者：GKxx (赞：4)

我的状态大概跟别人不大一样。。。

主要是我可能比较蠢，不知道怎么考虑前导0的情况。

我想起[CQOI2016手机号码](https://www.luogu.org/problemnew/show/P4124)那题我好像做得不是很困难，原因是那题的位数固定。

于是我就人为地枚举了一个位数

f[i][j][k][c]，表示从第i位开始考虑（即1到i-1位都是前导0），考虑到第j位，第j位填了k，c表示卡没卡上界。

那么显然（我认为）i=1和i>1是不一样的。i=1的时候要考虑卡不卡上界；i>1的话就每一位都是0到9随便填，且肯定不卡上界（c恒为0）

因此我分i=1和i>1分别做了dp，对于每个i最后枚举最后一位填几然后统计答案。

可能我比较菜，一直不是太会写记忆化搜索的方法，所以用的是递推。

```cpp
#include <cctype>
#include <cstdio>
#include <climits>
#include <algorithm>
#include <cmath>

template <typename T> inline void read(T& t) {
	int f = 0, c = getchar(); t = 0;
	while (!isdigit(c)) f |= c == '-', c = getchar();
	while (isdigit(c)) t = t * 10 + c - 48, c = getchar();
	if (f) t = -t;
}
template <typename T, typename... Args>
inline void read(T& t, Args&... args) {
	read(t); read(args...);
}

#ifdef WIN32
#define LLIO "%I64d"
#else
#define LLIO "%lld"
#endif // WIN32 long long IO
#define rep(i, a, b) for (int i = (a); i <= (b); ++i)
#define rrep(i, a, b) for (int i = (a); i >= (b); --i)
#define erep(i, x) for (int i = head[x]; i; i = next[i])

long long a, b;
long long f[15][15][10][2];

inline long long solve(long long N) {
	if (!N) return 0;
	int bit[15] = {0}; int n = 0;
	while (N) bit[++n] = N % 10, N /= 10;
	std::reverse(bit + 1, bit + n + 1);
	
	rep(i, 1, n) rep(j, 1, n) rep(k, 0, 9) rep(c, 0, 1) f[i][j][k][c] = 0;
	
	long long ans = 0;
	rep(i, 1, bit[1]) f[1][1][i][i == bit[1]] = 1;
	rep(j, 1, n - 1) rep(k, 0, 9) rep(c, 0, 1) {
		long long res = f[1][j][k][c];
		if (!res) continue;
		rep(t, 0, (c ? bit[j + 1] : 9))
			if (abs(t - k) >= 2)
				f[1][j + 1][t][c && t == bit[j + 1]] += res;
	}
	rep(k, 0, 9) ans += f[1][n][k][0] + f[1][n][k][1];
	
	rep(i, 2, n) {
		rep(j, 1, 9) f[i][i][j][0] = 1;
		rep(j, i, n - 1) rep(k, 0, 9) {
			long long res = f[i][j][k][0];
			if (!res) continue;
			rep(t, 0, 9) if (abs(t - k) >= 2)
				f[i][j + 1][t][0] += res;
		}
		rep(k, 0, 9) ans += f[i][n][k][0];
	}
	
	return ans;
}

int main() {
	read(a, b);
	printf(LLIO "\n", solve(b) - solve(a - 1));
	return 0;
}
```

update:在睡梦中突然间想通了更好的做法，于是来更新一波。

f[i][j][c][d]表示填到第i位，第i位填的是j，c表示卡没卡上界，d表示是否填过一个非0的数。这个d这一维就是我们处理前导0的方法。之前一直没有想通这个d这一维怎么搞，刚才突然意识到它和c那一维其实是差不多的。具体看代码：

```cpp
#include <cctype>
#include <cstdio>
#include <climits>
#include <algorithm>
#include <cmath>

template <typename T> inline void read(T& t) {
    int f = 0, c = getchar(); t = 0;
    while (!isdigit(c)) f |= c == '-', c = getchar();
    while (isdigit(c)) t = t * 10 + c - 48, c = getchar();
    if (f) t = -t;
}
template <typename T, typename... Args>
inline void read(T& t, Args&... args) {
    read(t); read(args...);
}

#ifdef WIN32
#define LLIO "%I64d"
#else
#define LLIO "%lld"
#endif	// WIN32 long long
#define rep(I, A, B) for (int I = (A); I <= (B); ++I)
#define rrep(I, A, B) for (int I = (A); I >= (B); --I)
#define erep(I, X) for (int I = head[X]; I; I = next[I])

long long f[15][10][2][2];
long long a, b;

inline long long solve(long long N) {
    int bit[15] = {0}, n = 0;
    for (; N; bit[++n] = N % 10, N /= 10);
    std::reverse(bit + 1, bit + n + 1);
    // 初始化清空数组
    rep(i, 1, n) rep(j, 0, 9) rep(c, 0, 1) rep(d, 0, 1) f[i][j][c][d] = 0;
    // 枚举第一位填什么数。如果这个数等于bit[1]那么c=1，如果这个数是0那么d=0
    rep(i, 0, bit[1]) f[1][i][i == bit[1]][i != 0] = 1;
    rep(i, 1, n - 1) rep(j, 0, 9) rep(c, 0, 1) rep(d, 0, 1) {
        long long res = f[i][j][c][d];
        if (!res) continue;
        // 枚举下一位填什么数。如果当前c=1说明卡了上界，枚举到bit[i+1]；否则可以枚举到9。下一位填的数k必须满足k和j相差至少为2，除非到目前为止还没有填过一个非0数。
        rep(k, 0, (c ? bit[i + 1] : 9)) if (abs(k - j) >= 2 || !d)
            f[i + 1][k][c && k == bit[i + 1]][d || k != 0] += res;
    }
    long long ans = 0;
    rep(i, 0, 9) ans += f[n][i][0][1] + f[n][i][1][1];
    return ans;
}

int main() {
    read(a, b);
    printf(LLIO "\n", solve(b) - solve(a - 1));
    return 0;
}
```

---

## 作者：fαns (赞：3)

~~不得不说又是一道某省送的数位dp模板打卡题~~

首先先简单介绍一下数位dp，数位dp虽然是叫做dp，但实际上记忆化搜索的写法偏多（~~我会告诉你我不会写递推的数位dp吗）~~，在这里还要膜拜一下那些题解里写出递推的大佬。

数位dp一般解决的是这样的问题：

给出a,b和一些限制条件，求[a,b]之间满足限制条件的数的个数，而且a,b一般都大的要死。~~比如说像这道题（逃~~


首先我们假如不考虑数据范围，直接写一个暴搜该怎么写。

我们发现这道题的答案可以用从0~B的答案$-$0~A-1的答案得到。

所以现在问题就转化成了如何求小于x的windy数个数。

一个显而易见的思路，枚举每个数再判断，复杂度为$O(nlog_{10}n)$,但这个方法已经无法优化了，所以说pass。

再想想，我们可以不用枚举之后再判断，而可以直接边枚举边判断，这样就可以通过枚举每一位来做，代码见下。

```cpp
#include <cstdio>
#include <queue>
#include <algorithm>
#include <cstring>
#define re register
#define For(i, s, e) for(re int i = s;i <= e;i++)
#define Refor(i, s, e) for(re int i = s;i >= e;i--)
#define Fore(i, u) for(re int i = head[u];i;i = edge[i].next)
#define clear(a) memset(a, 0, sizeof(a))
using namespace std;
template<class T> inline void read(T &f){
	char ch = getchar(); int w = 1;
	while (ch < '0' || ch > '9') (ch == '-') && (w = -1), ch = getchar();
	for (f = 0;ch >= '0' && ch <= '9';f = (f << 3) + (f << 1) + ch - 48, ch = getchar());
	f = f * w;
}
int a[15], tot;
int dfs(int now, int limit, int zero, int last){ //now表示当前枚举到哪一位，limit表示之前的每一位是否都顶着上界（比如说上界为967，那么如果前两位为96那么limit就为1，否则就为0），zero表示前面几位是否都为0（zero是为了处理前导0），last表示上一位是什么，用来判断是否满足条件。
	if (now > tot) return 1; //枚举完了，返回1
	int sum = 0, res = limit ? a[tot - now + 1] : 9; //这里的res是这一位的上界。
	For(i, 0, res){
		if (i < last + 2 && i > last - 2 && !zero) continue; //这里是判断是否满足条件，特别注意如果前几位全都是0的话这一位随便，因为前导0可以直接去除。
		sum += dfs(now + 1, limit & (i == res), zero && !i, i); //累计答案。
	}
	return sum;
}
int solve(int x){
	clear(a); tot = 0;
	while (x) a[++tot] = x % 10, x /= 10; //把上界拆分成每一位，注意和高精度一样是倒着存的。
	return dfs(1, 1, 1, -2);  //一开始limit为1表示最高位要受限制，last可以取任何数
}
int main(){
	int a, b; read(a); read(b);
	printf("%d", solve(b) - solve(a - 1));
	return 0;
}
```
那么这样就可以得到70pts，但该如何优化呢？我们发现在搜索时有大量重复的搜索，比如说像第1位不同且第2位相同且$limit=0$，那么后面的答案一定是相同的，所以我们可以使用记忆化搜索，设dp[i][j]表示当$limit=0$时，当前枚举到第i位，上一位的数为j的情况。于是我们就愉悦的可以A掉这道题了。代码见下：
```cpp
#include <cstdio>
#include <queue>
#include <algorithm>
#include <cstring>
#define re register
#define For(i, s, e) for(re int i = s;i <= e;i++)
#define Refor(i, s, e) for(re int i = s;i >= e;i--)
#define Fore(i, u) for(re int i = head[u];i;i = edge[i].next)
#define clear(a) memset(a, 0, sizeof(a))
using namespace std;
template<class T> inline void read(T &f){
	char ch = getchar(); int w = 1;
	while (ch < '0' || ch > '9') (ch == '-') && (w = -1), ch = getchar();
	for (f = 0;ch >= '0' && ch <= '9';f = (f << 3) + (f << 1) + ch - 48, ch = getchar());
	f = f * w;
}
int a[15], tot, ans, dp[15][15];
int dfs(int now, int limit, int zero, int last){
	if (now > tot) return 1;
	if (!limit && dp[now][last] != -1) return dp[now][last];
	int sum = 0, res = limit ? a[tot - now + 1] : 9;
	For(i, 0, res){
		if (i < last + 2 && i > last - 2 && !zero) continue;
		sum += dfs(now + 1, limit & (i == res), zero && !i, i);
	}
	if (!limit && !zero) dp[now][last] = sum;
	return sum;
}
int solve(int x){
	memset(dp, -1, sizeof(dp)); //注意初始化
	clear(a); tot = 0;
	while (x) a[++tot] = x % 10, x /= 10;
	return dfs(1, 1, 1, -2);
}
int main(){
	int a, b; read(a); read(b);
	printf("%d", solve(b) - solve(a - 1));
	return 0;
}
```

---

## 作者：Xie_BR (赞：3)

这道数位题目其实需要考虑一些玄学的东西。。。  
首先我们来看一看这道神奇的题目：  
我们需要考虑的是：  
1：个位数都是Windy数  
2：可以在最开始不用管前导0  
3：其次我们开一个三维的dp数组分别表示当前的长度，当前位数的前一位，当前的位数上是否有限制  

### 废话不多说，直接看代码：  
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int len = 0,num[30],dp[30][10][2];

int dfs(int k,int pre,int limit)
{
	if(k==0)
	{
		return 1; //所有个位都是 
	}
	if(pre!=-10&&dp[k][pre][limit]!=-1) //记忆化 
	{
		return dp[k][pre][limit];
	}
	int m;
	if(limit)
	{
		m = num[k];
	}else
	{
		m = 9;
	}
	int ans = 0;
	for(int i=0;i<=m;i++)
	{
		if(abs(i-pre)<2)
		{
			continue;
		}
		if(pre==-10 && i==0)
		{
			ans+=dfs(k-1,-10,0);
		}else
		{
			ans+=dfs(k-1,i,limit&&i==num[k]);
		}
	}
	if(pre!=-10)
	{
		return dp[k][pre][limit] = ans;
	}
	return ans;
}

int work(int x)
{
	memset(num,0,sizeof(num));
	memset(dp,-1,sizeof(dp));
	len = 0;
	for(;x;x/=10)
	{
		num[++len] = x%10;
	}
	return dfs(len,-10,true);
}

signed main()
{
	int a,b;
	scanf("%lld%lld",&a,&b);
	int ans = work(b)-work(a-1);
	printf("%lld\n",ans);
	return 0;
}
```

### 其实是一个聪明的打表，大佬指教！！！  
# ：）

---

## 作者：arfa (赞：2)

第一道数位 $DP$。

由于空间不够,所以我们必须要压缩一下。

所以我们设 $f_{i,j}$ 为 $1$~$X$ 的 $windy$。(其中 $X$ 满足第一位等于 $j$,且有 $i$ 位)

$$f_{i,j}=\sum\limits^{9}_{l=j+2} f_{i-1,l} +\sum\limits^{j-2}_{l=0} f_{i-1,l}$$

```pascal
for i:=0 to 9 do fuck[1,i]:=1;
	for i:=2 to 20 do for j:=0 to 9 do 
		begin 
			for k:=j-2 downto 0 do inc(fuck[i,j],fuck[i-1,k]); 
			for k:=j+2 to 9 do inc(fuck[i,j],fuck[i-1,k]); 
		end;
```

这样子就很好的压缩了空间。

我们把 $C(l,r)$ 变为 $C(r+1)-C(l)$ 

($C(r)-C(l-1)$ 莫名 $WA$ 了?)

我们考虑求一个数字 $x$ 的 $windy$。我们定义 $X$ 为 $x$ 倒立过来的数组,$len$ 为数组长度。如 $x=7192$,$X_i=\{2,9,1,7\},len=4$。

我们先把 $0$~$999$ 的 $windy$ 求一下。

$$\sum\limits^{len-1}_{i=1}\sum\limits^{9}_{j=1} f_{i,j}$$

```
for i:=1 to len-1 do for j:=1 to 9 do inc(Windy,fuck[i,j]);
```

然后把 $1000$~$6999$ 的求了。

$$\sum\limits^{X_{len}-1}_{i=1} f_{len,i}$$

```
for i:=1 to num[len]-1 do inc(Windy,fuck[len,i]);
```

最后的最难搞~要把剩下的求了。

$$\sum\limits^{1}_{i=len-1} \sum\limits^{X_{i}-1}_{j=0} f_{i,j} (abs(j-X_{i+1})>=2)$$

```pascal
for i:=len-1 downto 1 do
    begin
        for j:=0 to num[i]-1 do 
        	if abs(j-num[i+1])>=2 then inc(Windy,fuck[i,j]);
        if abs(num[i]-num[i+1])<2 then break;
    end;
```


就没了。






---

## 作者：盧鋅 (赞：1)

### 看了几篇题解感觉解释的不够详细

~~然后就写了一篇~~相对正经~~的题解~~

对于数位DP一般使用前缀和解决，这里不多赘述

代码和注释一起给出：
```cpp
#include<iostream>
#include<cmath>
#define R register
using namespace std;
int f[12][10];
//设f[i][j]表示第i位取j的方案数
long long power[13];
//power[]幂数组
void prework(){//预处理
    power[0]=1;//pow(10,0)=1;
    for(R int i=1;i<=12;++i)power[i]=power[i-1]*10;//pow(10,n);
    for(R int i=0;i<=9;++i)f[1][i]=1;//初始化
    for(R int i=2;i<=11;++i)//枚举每一位
        for(R int j=0;j<=9;++j)//枚举每一位的可能性
            for(R int k=0;k<=9;++k)//枚举上一位的可能性
                if(abs(j-k)>=2)f[i][j]+=f[i-1][k];//加上符合条件的数量
    return;
}
//count统计小于x的符合题意的个数
int count(int x){
    int w=0,ans=0,pre=0,y=0;
    //w是x的位数，ans记录答案，pre记录上一位，y记录现一位
    while(power[w]<=x)++w;//计算w
    //计算位数比x小的数
    for(R int i=1;i<w;++i)
        for(R int j=1;j<=9;++j)
            ans+=f[i][j];
    //使y为最高位，统计最高位比x小的数
    y=x/power[w-1];
    for(R int j=1;j<y;++j)ans+=f[w][j];
    //pre记录最高位，x去除最高位
    pre=y;
    x%=power[w-1];
    for(R int i=w-1;i>=1;--i){//不断降位
        y=x/power[i-1];//让y不断为x的最高位
        for(R int j=0;j<y;++j)//枚举比当前位小的数
            if(abs(j-pre)>=2)ans+=f[i][j];//统计答案;
        //假如上一位与现一位的差值小于2直接退出枚举，因为原数已经不和题意，再枚举将成为错误的解
        if(abs(pre-y)<2)break;
        //降位
        pre=y;
        x%=power[i-1];
    }
    return ans;
}

signed main(){
    int a,b;
    cin>>a>>b;
    prework();
    cout<<count(b+1)-count(a)<<endl;//前缀和
    return 0;
}
```
对于为什么是b+1和a而不是b和a-1的问题详见count函数

然后记忆化搜索的代码一并给出

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
using namespace std;
int f[20][12];//f[i][j]表示第i位取j的方案数(！bj)
int dim[20];//dim[i]表示数的第i位，dim[0]表示数的位数
int dfs(int x,int pre,bool bj){
    //x记录位数，pre记录上一位
    //bj标记之前搜索的结果和原数的关系,假如之前搜索的部分是原数的部分bj=1
    if(!x)return 1;//假如x等于0，即上次的搜索是dfs(1,pre,bj),因为0，1，2，……，9都符合结果，所以是1；
    if(!bj&&f[x][pre]!=-1)return f[x][pre];//假如没有标记，并且之前搜索过，直接返回值
    int maxn=bj?dim[x]:9;//假如标记成立搜索的部分不大于原数的第x位，否则为9；
    int temp=0;//temp记录方案数
    for(int i=0;i<=maxn;++i){//枚举
        if(abs(pre-i)<2)continue;//假如不符合条件，pass
        //假如i是最大值，并且有标记等价于搜索的部分是原数的部分，标记传递
        if(pre==11&&i==0)//假如上一位是11，11表示前导0；
            temp+=dfs(x-1,11,bj&&i==maxn);
        else
            temp+=dfs(x-1,i,bj&&i==maxn);
    }
    if(!bj)f[x][pre]=temp;//记忆化
    return temp//返回值
}
int ask(int x){
    dim[0]=0;//初始化
    while(x){
        //不断将x十进制放入数组
        dim[++dim[0]]=x%10;
        x/=10;
    }
    //将最高位的高一位设为-1即界限
    dim[dim[0]+1]=-1;
    return dfs(dim[0],11,1);//搜索
}
signed main(){
    int a,b;
    memset(f,-1,sizeof(f));//初始化
    cin>>a>>b;
    cout<<ask(b)-ask(a-1);//前缀和
    return 0;
}
```


------------
没看懂的可以私我

---

## 作者：斗神_君莫笑 (赞：1)

虽然本题是数位dp的模板  
但是我还是想用另一些玄学的方法瞎搞——   
分块打表！  

对于每sqrt(n)左右的区间统计值  
但是如果每sqrt(n)打一个数字，表的长度会超标  
这时想到可以只统计两个区间的差，在提交时跑一遍前缀和计算  
可以显著降低表的大小   

但是打表实在太花空间了  
我考虑改成间隔1e5，可还是不行  
但是我们的暴力程序是线性的，所以即使是间隔1e6的表也是可以接受的  
在代码长度的边缘左右横跳，我发现间隔2e5的表可以接受  
那么就没什么好说的了  
注意一下边界细节  

打表程序：（20s左右）
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	freopen("biao.txt","w",stdout);
	int cnt=0,pre=0;
	for(int i=1;i<=2000000000;++i){
		int k=i,last=20,is=1;
		while(k){
			if(abs(last-(k%10))<2){
				is=0;break;
			}
			last=k%10;
			k/=10;
		}
		cnt+=is;
		if(i%200000==0){
			printf("%d,",cnt-pre);
			pre=cnt;
		}
	}
	return 0;
}
```

提交程序
```cpp
#include<bits/stdc++.h>
using namespace std;
int biao[]={………………};
int query(int num){
	int ans=0,k=num/200000;
	for(int i=1;i<=k;++i)
		ans+=biao[i];
	for(int i=k*200000+1;i<=num;++i){
		int k=i,last=20,is=1;
		while(k){
			if(abs(last-(k%10))<2){
				is=0;break;
			}
			last=k%10;
			k/=10;
		}
		ans+=is;
	}
	return ans;
}
int main(){
	int n,m;
	scanf("%d%d",&n,&m);
	printf("%d",query(m)-query(n-1));
	return 0;
} 
```



---

## 作者：七里 (赞：1)

# **windy数**


## **题目**

windy数：相邻数字只差大于等于2的数

给你l和r,询问你l到r之间的windy数的个数

## **思路**
~~我太弱，萌新，看了大佬的博客说让先做做这道题~~

这这这......~~一看是道数位dp~~......

dp[i][j]表示第i位为j的数的个数

状态转移方程就很简单了：枚举第i-1位的数字，相差大于等于2就add

处理完之后问题就是怎样限制范围？

这种范围的题目大都可以用前缀和的思想(前提满足可加/减性)

1.用<=r的windy数减去<=(l-1)的windy数
      
但是我们发现这种情况是闭区间的，并不好判断，采用第二种方法

2.用<(r+1)的windy数减去<l的windy数

这样处理起来比较方便，分三种情况：
	
    1.记cal为要询问的数的位数
      枚举cal-1位的位数上填什么数字，直接0-9全加一遍，因为肯定小于x嘛
    2.枚举第cal位的数字，要小于x的cal位的数字，也是小于x的
    3.开始处理从第cal到第1位逐个相等的情况，如果你从cal位开始的话可以合并掉 2. ,如果cal位直接相等才能够cal-1位开始则 2.不可少
      当在x的逐位相等枚举过程中出现了第i位与第i+1位不满足windy数的性质，则直接退出，不再向下进行。
      
## **代码**
```cpp
#include<bits/stdc++.h>
#define R register
using namespace std;
int l,r;
int dp[12][12];
int work(int x){
	int cal=0,ans=0,y=x,a[12];
	while(y){
		a[++cal]=y%10;
		y/=10;
	}
	for(R int i=1;i<cal;i++){
		for(R int j=1;j<=9;j++) ans+=dp[i][j];
	}
	for(R int i=1;i<a[cal];i++) ans+=dp[cal][i];
	for(R int i=cal-1;i>=1;i--){
		for(R int j=0;j<a[i];j++){
			if(abs(j-a[i+1])>=2) ans+=dp[i][j];
		}
		if(abs(a[i+1]-a[i])<2) break;
	}
	return ans;
}
int main ()
{
	for(R int i=0;i<=9;i++) dp[1][i]=1;
	for(R int i=2;i<=10;i++)
		for(R int j=0;j<=9;j++)
			for(R int k=0;k<=9;k++)
				if(abs(k-j)>=2) dp[i][j]+=dp[i-1][k];
	scanf("%d%d",&l,&r);
	printf("%d",work(r+1)-work(l));
	return 0;
}
```


---

## 作者：Paranoid丶离殇 (赞：1)

### 题目描述

windy定义了一种windy数。不含前导零且相邻两个数字之差至少为2的正整数被称为windy数。 windy想知道，

在A和B之间，包括A和B，总共有多少个windy数？

### 输入格式

包含两个整数，A B。

### 输出格式

一个整数

### 输入输出样例

输入 #1

```
1 10
```

输出 #1

```
9
```

输入 #2

```
25 50
```

输出 #2

```
20
```

### 说明/提示

100%的数据，满足 $1 <= A <= B <= 2000000000$ 。

------



### 题解

数位DP

设$f[i][j]$表示 $i$ 位数，最高位为 $j$的符合条件的数的个数。

则$f[i][j]=\sum_{|j-k|≤2} f[i-1][k]$.

预处理$f$数组后进行数位DP。

先填充位数不满的，再由高位向低位将此位不满的加入答案。

且若当前位于上一位数产生冲突导致不会再有满足条件的数时，跳出循环。

转换询问区间为$[1, n)$则更易简单处理。

### code

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
typedef long long LL;
LL f[50][20], bit[50], a, b;
inline int ab(int x) { return x > 0 ? x : -x; }
void init() {
	bit[0] = 1; bit[1] = 10;
	for(int i = 0;i <= 9;i ++) f[1][i] = 1;
	for(int i = 2;i <= 20;i ++) {
		bit[i] = bit[i-1] * 10;
		for(int j = 0;j <= 9;j ++) {
			for(int k = 0;k <= 9;k ++) {
				if(ab(j-k) >= 2) f[i][j] += f[i-1][k];
			}
		}
	}
}
LL calc(int x) {
	LL pos, di = 1, res = 0, last = -1;
	for(pos = 1;bit[pos] <= x;pos ++) {
		for(int j = 1;j <= 9;j ++) {
			res += f[pos][j];
		}
	}
	for( ; pos ;pos --) {
		int now = (x / bit[pos - 1]) % 10;
		for(int j = di;j < now;j ++) {
			if(ab(j-last) >= 2) res += f[pos][j];
		}
		if(ab(now-last) < 2) break;
		di = 0; last = now;
	}
	return res;
}
int main() {
	init();
	cin >> a >> b;
	cout << calc(b + 1) - calc(a) << endl;
	return 0;
}
```



---

## 作者：Tanktt (赞：1)

老师说，数位DP很有可能会考，所以我毫不犹豫地打开了这道题，重温一下经典。。。

对于DP的f数组很简单:f[i][j]表示第i位为j时的方案数

f[i][j]+=f[i-1][k] (abs(k-j)>=2)

但是，数位DP麻烦的地方就是统计，如果范围不是整十数，就需要逐位解决。

先求出输入的位数，对于位数小于它的，就直接统计每一位0~9的个数,即Σ(i=1~w-1) f[i][0~9]。

其他的就麻烦了，对于每一位now，设其前一位为pre,枚举的范围就是0~now-1且abs(i-pre)>=2。如果abs(now-pre)<2，就不能继续下去了，即这一位不能取now，最多只能取now-1，那么后面的所有位就随便取，反正不可能大于范围。。

另外，我们求的范围是开区间，即不能取到最后一个，因此是calc(b+1)-calc(a)。
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
long long mi[15];
int f[15][10],a,b;
inline void prepare()
{
	mi[0]=1;
	for (int i=1; i<=12; i++) mi[i]=mi[i-1]*10;
	for (int i=0; i<=9; i++) f[1][i]=1;
	for (int i=2; i<=12; i++)
		for (int j=0; j<=9; j++)
			for (int k=0; k<=9; k++)
			if (abs(j-k)>=2) f[i][j]+=f[i-1][k];
}
inline int solve(int x)
{
	int w=0,ans=0;
	while (mi[w]<=x) w++;
	for (int i=1; i<w; i++)
		for (int j=1; j<=9; j++) ans+=f[i][j];
	int now,pre;
	now=pre=x/mi[w-1];
	for (int i=1; i<now; i++) ans+=f[w][i];
	x%=mi[w-1];
	w--;
	for (int k=w; k>=1; k--)
	{
		now=x/mi[k-1];
		for (int i=0; i<now; i++)
		if (abs(i-pre)>=2)
		ans+=f[k][i];
		if (abs(pre-now)<2) break;
		pre=now;
		x%=mi[k-1];
	}
	return ans;
}
int main()
{
	scanf("%d%d",&a,&b);
	prepare();
	return printf("%d\n",solve(b+1)-solve(a)),0;
}
```

另有推荐数位DP用记忆化搜索的方式做的：(https://www.luogu.org/blog/virus2017/shuweidp#)

---

## 作者：Nero_Claudius (赞：1)

感觉数位DP有点弱，强化一下。。。

------------

这道题是一道比较裸的数位DP。

我们用$dp[i][j]$表示长度为$i$最高位为$j$的windy数有多少个，状态转移方程为$dp[i][j]=\sum_{abs(j-k)>=2}{dp[i-1][k]}$。

然后有一个小优化（其实不能算优化吧），就是算一下输入两个数的长度，然后取长度最大值作为第一维的极限，这样就稍微比直接算到$i=11$要优一点了。

------------

AC代码如下：

`28ms 788kb`

```cpp
// By Ilverene

#include<bits/stdc++.h>

using namespace std;

namespace StandardIO{

	template<typename T>inline void read(T &x){
		x=0;T f=1;char c=getchar();
		for(;c<'0'||c>'9';c=getchar())if(c=='-')f=-1;
		for(;c>='0'&&c<='9';c=getchar())x=x*10+c-'0';
		x*=f;
	}

	template<typename T>inline void write(T x){
		if(x<0)putchar('-'),x*=-1;
		if(x>=10)write(x/10);
		putchar(x%10+'0');
	}

}

using namespace StandardIO;

namespace Solve{
	
	// Define your global variables here.
	int a,b;
	int dp[11][11];
	
	// Define your main functions here.
	template<typename T>inline T length(T num){
		T ans=0;
		for(;num;++ans,num/=10);
		return ans;
	}
	
	template<typename T>inline T calc(T limit){
		memset(dp,0,sizeof(dp));
		for(register int i=0;i<=9;++i){
			dp[1][i]=1;
		}
		for(register int i=2;i<=limit;++i){
			for(register int j=0;j<=9;++j){
				for(register int k=0;k<=j-2;++k){
					dp[i][j]+=dp[i-1][k];
				}
				for(register int k=j+2;k<=9;++k){
					dp[i][j]+=dp[i-1][k];
				}
			}
		}
	}
	
	template<typename T>inline T calcAll(T n){
		T len=0;
		T num[11];
		for(;n;num[++len]=n%10,n/=10);
		T ans=0;
		for(register int i=1;i<=len-1;++i){
			for(register int j=1;j<=9;++j){
				ans+=dp[i][j];
			}
		}
		for(register int i=1;i<num[len];++i){
			ans+=dp[len][i];
		}
		for(register int i=len-1;i>=1;--i){
			for(register int j=0;j<=num[i]-1;++j){
				if(abs(j-num[i+1])>=2)ans+=dp[i][j];
			}
			if(abs(num[i+1]-num[i])<2)break;
		}
		return ans;
	}

	inline void solve(){
		// Write your main logic here.
		read(a),read(b);
		calc(max(length(a),length(b)));
		write(calcAll(b+1)-calcAll(a));
	}
}

using namespace Solve;

int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	solve();
}

```

---

## 作者：青丘杨哲 (赞：1)

本题是数位DP模板题。

我们用f[i][j]
表示填了i位数，最高位是j的windy数的个数，则显然有f[i][j]=Σ f[i-1][k] (|j-k|≥2)。我们用一次数位DP求出f[i][j]后，再进行一次数位DP，从高位到低位进行枚举我们所求解的数字中第一个小于n的那一位，那么在此时，之前的数位都已经确定（它们都是与n相等的），之后的位就不再受此限制，可以直接统计了。

本题既可以用DP实现，也可以用记忆化搜索实现。下面的代码采用的是DP实现。

```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b,f[15][15];
long long power[15];
void PreWork()
{
	power[0]=1;
	for (int i=1;i<=12;i++) power[i]=power[i-1]*10;
	for (int i=0;i<=9;i++) f[1][i]=1;
	for (int i=2;i<=11;i++) for (int j=0;j<=9;j++) for (int k=0;k<=9;k++)
		if (abs(j-k)>=2) f[i][j]+=f[i-1][k];
}
int Count(int x)
{
	int w=0,y,pre,ans=0;
	while (power[w]<=x) w++;
	for (int i=1;i<w;i++) for (int j=1;j<=9;j++) ans+=f[i][j];
	y=x/power[w-1];
	for (int j=1;j<y;j++) ans+=f[w][j];
	pre=y,x%=power[w-1];
	for (int i=w-1;i>=1;i--)
	{
		y=x/power[i-1];
		for (int j=0;j<y;j++) if (abs(j-pre)>=2) ans+=f[i][j];
		if (abs(pre-y)<2) break;
		pre=y,x%=power[i-1];
	}
	return ans;
}
int main()
{
	cin>>a>>b,PreWork(),cout<<Count(b+1)-Count(a);
	return 0;
}
```

---

## 作者：逍遥天堂 (赞：1)

## 数位动态规划 
```
#include<bits/stdc++.h>
using namespace std;
int f[12][10]={0};
long long power[13];
void PreWork()
{
	int i,j,k;
	power[0]=1;
	for(i=1;i<=12;i++)power[i]=power[i-1]*10;
	for(i=0;i<=9;i++)f[1][i]=1;
	for(i=2;i<=11;i++)
	for(j=0;j<=9;j++)
	for(k=0;k<=9;k++)
	if(abs(j-k)>=2)f[i][j]+=f[i-1][k];
}
int Count(int x)
{
	int w=0,y,i,j,pre,ans=0;
	while(power[w]<=x)w++;
	for(i=1;i<w;i++)//不足w位的数严格小于n，全部加入答案 
	for(j=1;j<=9;j++)ans+=f[i][j];
	y=x/power[w-1];
	for(j=1;j<y;j++)ans+=f[w][j];
	pre=y;
	x%=power[w-1];
	for(i=w-1;i>=1;i--)//枚举我们所求的数字第一次小于n的那一位 
	{
		y=x/power[i-1];
		for(j=0;j<y;j++)
		if(abs(j-pre)>=2)ans+=f[i][j];
		if(abs(pre-y)<2)break;
		pre=y;
		x%=power[i-1];
	}
	return ans;
}
int main()
{
	int a,b;
	cin>>a>>b;
	PreWork();
	cout<<Count(b+1)-Count(a)<<endl;
	return 0;
}
```

---

## 作者：独孤涵冰 (赞：0)

初次接触数位DP，整个算法的核心就在于“试填法”，根据题目要求的特点设计辅助数组的状态，剩下的应该就很套路了。
```cpp
/*Tokgo*/
#include <bits/stdc++.h>
#define rep(i,a,b) for(int i=a;i<=b;++i)
#define dwn(i,a,b) for(int i=a;i>=b;--i)

using namespace std;

int a , b ;
int f[ 13 ][ 10 ] ; // 第i位，填的是j的合法数量 
int x , y ; 
int ans ;
int c[ 20 ] , l ;

void calc( int &cnt ) {
	dwn( i , l , 1 ) { 
		rep( j , (i==l) , c[i]-1 ) // 统计，最高位不能是0 
			if( abs( c[i+1] - j ) > 1 )  
				cnt += f[ i ][ j ] ;
		if( abs( c[i+1] - c[i] ) < 2 ) break ; // 原数不符合情况了就返回 
	}
	rep( i , 1 , l-1 ) // 高位是前导零的情况 
		rep( j , 1 , 9 )
			cnt += f[ i ][ j ] ;
}

void t( int w ) { // 转换成字符串 
	l = 0 ;
	while( w ) c[ ++l ] = w % 10 , w /= 10 ;
	c[ l+1 ] = -2 ;
	
}

int main() {

	cin >> a >> b ;
	b += 1 ; // 数位DP数的是[,)的区间，所以右端点+1 
	
	rep( i , 0 , 9 ) f[ 1 ][ i ] = 1 ; 
	rep( i , 2 , 12 ) 
		rep( j , 0 , 9 ) {
			rep( k , 0 , 9 ) 
				if( abs( k - j ) > 1 ) 
					f[ i ][ j ] += f[ i-1 ][ k ] ;
		}
	t( a ) , calc( x ) ;
	t( b ) , calc( y ) ; 
	cout << y - x ; 
	

	return 0;
}


```


---


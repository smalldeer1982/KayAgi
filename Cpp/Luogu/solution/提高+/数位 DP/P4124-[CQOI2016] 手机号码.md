# [CQOI2016] 手机号码

## 题目描述

人们选择手机号码时都希望号码好记、吉利。比如号码中含有几位相邻的相同数字、不含谐音不吉利的数字等。手机运营商在发行新号码时也会考虑这些因素，从号段中选取含有某些特征的号码单独出售。为了便于前期规划，运营商希望开发一个工具来自动统计号段中满足特征的号码数量。

工具需要检测的号码特征有两个：号码中要出现至少 $3$ 个相邻的相同数字；号码中不能同时出现 $8$ 和 $4$。号码必须同时包含两个特征才满足条件。满足条件的号码例如：13000988721、23333333333、14444101000。而不满足条件的号码例如：1015400080、10010012022。

手机号码一定是 $11$ 位数，且不含前导的 $0$。工具接收两个数 $L$ 和 $R$，自动统计出 $[L,R]$ 区间内所有满足条件的号码数量。$L$ 和 $R$ 也是 $11$ 位的手机号码。

## 说明/提示

样例解释：满足条件的号码： 12121285000、 12121285111、 12121285222、 12121285333、 12121285550。

数据范围：$10^{10}\leq L\leq R<10^{11}$。

## 样例 #1

### 输入

```
12121284000 12121285550```

### 输出

```
5```

# 题解

## 作者：jzzcjb (赞：81)

是不是所有的数位DP都长得一样？
~~（也许是我太菜，只做过最简单的？）~~

这题也一样，只不过记得东西变了变，直接记搜即可。

代码真的很短，注释在代码里。
```
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
int num[12];
ll l,r,dp[11][11][11][2][2][2][2];

ll f(int p,int a,int b,bool c,bool d,bool _4,bool _8){
    /*
        a:p+1位是多少
        b:p+2位是多少,若是前导0的话是-1
        c:之前是否已经出现连续三个相同的数字
        d:之前是否已经保证x<n
        _4:是否出现过4
        _8:是否出现过8
    */
    if(_4&&_8) return 0;//又有4又有8 不合法 
    if(p<=0) return c;
	//这里是个偷懒,如果当前出现过连续三个相同的数字返回1，否则返回0 
    if (~dp[p][a][b][c][d][_4][_8]) return dp[p][a][b][c][d][_4][_8];//记忆化 
    ll res=0;int lim=!d?num[p]:9;//如果没有严格小于,只能填到num,如果已经严格小于,就可以随便填 
  	for(int i=0;i<=lim;i++)
        res+=f(p-1,i,a,c||(i==b&&i==a),d||(i<lim),_4||(i==4),_8||(i==8));
        //下一位,
		//下一位的上一位(就是这一位),
		//下一位的上上位(就是现在的上一位),
		//以前就出现过||这次填数刚造出来的, 
    return dp[p][a][b][c][d][_4][_8]=res;
}

ll calc(ll x){
    if(x<1e10) return 0;//不是手机号 
    memset(dp,-1,sizeof(dp));
    //拆位 
    int len;
    for(len=0;x;x/=10) num[++len]=x%10;
    //第一位还要考虑前导0,不如直接手算 
	ll res=0;
	for(int i=1;i<=num[len];i++)
    res+=f(10,i,0,0,i<num[len],i==4,i==8);
	return res;
}

int main(){
    cin>>l>>r;
    cout<<calc(r)-calc(l-1);
}
/*
24014095542
96045812868
*/
```
无注释版
```
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int num[12],len;
ll l,r,dp[11][11][11][2][2][2][2];
ll f(int p,int a,int b,bool c,bool d,bool _4,bool _8){
    if(_4&&_8) return 0;
    if(p<=0) return c;
    if (~dp[p][a][b][c][d][_4][_8]) return dp[p][a][b][c][d][_4][_8];
    ll res=0;int lim=!d?num[p]:9;
  	for(int i=0;i<=lim;i++)
        res+=f(p-1,i,a,c||(i==b&&i==a),d||(i<lim),_4||(i==4),_8||(i==8));
    return dp[p][a][b][c][d][_4][_8]=res;
}
ll calc(ll x){
    if(x<1e10) return 0;
    memset(dp,-1,sizeof(dp));
    for(len=0;x;x/=10) num[++len]=x%10;
	ll res=0;
	for(int i=1;i<=num[len];i++)
    res+=f(10,i,0,0,i<num[len],i==4,i==8);
	return res;
}
int main(){
    cin>>l>>r;
    cout<<calc(r)-calc(l-1);
}
```

---

## 作者：Adove (赞：61)

在这里我安利一种模块化的数位DP

ta的基本思路如下

```cpp
dfs(数的最后若干位,各种限制条件,当前第几位)
	if 最后一位
    	return 各种限制条件下的返回值
    局部变量 ct=当前位的数字
    局部变量 sum=0;
    for i=0 to ct-1
    	sum+=当前位取i时一定无无限制的合法状态数
        sum+=当前位取i时满足当前限制的合法状态数
    根据ct更新限制条件 不再满足则return sum
    return sum+dfs(当前位后的若干位,更新后的限制条件,下一位)

slv(当前数)
	if(只有一位) return 对应的贡献
    局部变量 ct;
    for ct=可能最高位 to 1
    	if 当前位有数字 break
    局部变量 nw=当前位数字
    局部变量 sum=0
    for i=1 to nw-1
    	sum+=当前位取i后合法情况任意取的贡献
    for i=1 to ct-1
    	for j=1 to 9
        	sum+=第i位取j后合法情况任意取的贡献
    sum+=dfs(去掉第一位后的若干位,限制条件,第二位)
    return sum

main
	预处理当前位取i的各种条件各种限制的贡献
    读入 L R
    --L
    输出 slv(R)-slv(L)
    return 0
```

按照这种思路绝大多数数位DP都能按部就班地解决

此题按照以上思路的代码如下

```cpp
#include"cstdio"
#include"cstring"
#include"iostream"
#include"algorithm"
using namespace std;

long long L,R;
long long val[12][10][4][2][2][2],pw[11];//[第i位][填j][目前连续L][是否有4][是否有8][是否有至少3位连续数字]的有val个 

long long dfs(long long x,int pre,int l,bool b1,bool b2,bool b3,int tp)
{
	if(tp==1){
		if(!b3){
			if(l<2) return 0;//不够长
			if(l==2) return x>=pre;//够长看能不能接上
		}else{
			if(b1) return x>=8?x:x+1;//有4无8
			if(b2) return x>=4?x:x+1;//有8无4
			return x+1;
		}
	}int ct=x/pw[tp-1];long long sum=0;
	for(int i=0;i<ct;++i){
		for(int j=1;j<=3;++j){
			            sum+=val[tp][i][j][0][0][1];//无论各种限制都合法
			if(b3)      sum+=val[tp][i][j][0][0][0];//前面有连续段后面就不需要了
			if(!b2)     sum+=val[tp][i][j][1][0][1];//没有8后面就能取4
			if(!b1)     sum+=val[tp][i][j][0][1][1];//没有4后面就能取8
			if(b3&&!b2) sum+=val[tp][i][j][1][0][0];//后面可以取4且不必有连续段
			if(b3&&!b1) sum+=val[tp][i][j][0][1][0];//后面可以取8且不必有连续段
		}if(i==pre&&!b3){//之前没有连续段这一位填和上一位相同的
			for(int j=1;j<=l;++j){
				        sum+=val[tp][i][3-j][0][0][0];//接起来不短于3个后面没有4也没有8
				if(!b2) sum+=val[tp][i][3-j][1][0][0];//接起来不短于3个后面有4无8
				if(!b1) sum+=val[tp][i][3-j][0][1][0];//接起来不短于3个后面有8无4
			}
		}
	}l=(ct==pre)?min(l+1,3):1;b1|=(ct==4);b2|=(ct==8);b3|=(l>=3);//更新限制状态
	if(b1&&b2) return sum;//填当前位卡上界不满足限制
	return sum+dfs(x-ct*pw[tp-1],ct,l,b1,b2,b3,tp-1);//卡上界向后统计
}

long long slv(long long x)
{
	int ct=11;long long sum=0;
	if(x<pw[ct-1]) return 0;
	int nw=x/pw[ct-1];
	for(int i=1;i<nw;++i){
		for(int j=1;j<=3;++j){
			sum+=val[ct][i][j][1][0][1]//有4无8连续段
				+val[ct][i][j][0][1][1]//有8无4连续段
				+val[ct][i][j][0][0][1];//无4无8连续段
		}
	}sum+=dfs(x-nw*pw[ct-1],nw,1,nw==4,nw==8,0,ct-1);//卡第一位上界向后统计
	return sum;
}

int main()
{
	pw[0]=1;
	for(int i=1;i<=10;++i) pw[i]=pw[i-1]*10;
	for(int i=0;i<=9;++i) val[1][i][1][i==4][i==8][0]=1;
	for(int i=2;i<=11;++i){//第i位
		for(int j=0;j<=9;++j){//该位填j
			for(int k=0;k<=9;++k){//上一位填k
				for(int l=1;l<=3;++l){//截至上一位有连续l个数
					for(int b1=(k==4);b1<=1;++b1){//是否有4
						for(int b2=(k==8);b2<=1;++b2){//是否有8
							for(int b3=(l==3);b3<=1;++b3){//是否有长度至少为3的连续段
								int c=(j==k)?min(l+1,3):1;
								bool fl1=(j==4)|b1,fl2=(j==8)|b2,fl3=(c>=3)|b3;
								val[i][j][c][fl1][fl2][fl3]+=val[i-1][k][l][b1][b2][b3];
							}
						}
					}
				}
			}
		}
	}scanf("%lld%lld",&L,&R);--L;
	printf("%lld\n",slv(R)-slv(L));
	return 0;
}
```

---

## 作者：夢子電 (赞：27)

[传送门](https://www.luogu.org/problemnew/show/P4124)  

数位DP~~水~~好题

可以按位地进行枚举，同时记录是否有连续3个相同数字出现

我采用的是**记忆化搜索**的方法

状态很简单

测了一下hack数据，觉得还可以

附代码(详见注释)
```
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
typedef long long lint;
lint l,r,dp[15][11][11][2][2][2];
//dp[pos][a][b][state][eight][four]
// pos	当前位置
// a	上一位数字
// b	再上一位数字
// state 是否出现3个连续相同数字
// eight 是否出现8
// four  是否出现4
int st[15];
lint dfs(int pos,int a,int b,bool state,bool eight,bool four,bool limit)
{
	// limit 当前位置上数字是否达到上限
	if(eight&&four) return 0;
    //见题面，8和4不能同时出现
	if(!pos) return state;
	if(!limit&&dp[pos][a][b][state][eight][four]!=-1) return dp[pos][a][b][state][eight][four];
    //记忆化
	lint res=0;
	int maxn=limit?st[pos]:9; 
	for(int i=0;i<=maxn;i++)
	{
		res+=dfs(pos-1,i,a,state||(i==a&&i==b),eight||(i==8),four||(i==4),limit&&(i==maxn));
        //用下一位状态更新该位
	}
	if(!limit) dp[pos][a][b][state][eight][four]=res;
	return res;
}
lint find(lint x)
{
	int len=0;
	while(x)
	{
		st[++len]=x%10;
		x/=10;
	}
	if(len!=11) return 0;//注意这里！！！手机号码一定为11位，不特判这里只有70分
	memset(&dp,-1,sizeof(dp));
	lint ans=0;
    //问:如何避开第一位上的前导0？
    //答:枚举1到第一位上的数字，从下一位开始搜索
	for(int i=1;i<=st[len];i++)
	{
		ans+=(long long)dfs(len-1,i,0,0,i==8,i==4,i==st[len]);
	}
	return ans;
}
int main()
{
	scanf("%lld%lld",&l,&r);
	printf("%lld\n",find(r)-find(l-1));
}
/*
input:
10000000000 53628881996
output:
2186241614
*/
```

---

## 作者：i207M (赞：16)

~~DFS数位DP就是吼啊~~

分析的话，一位一位枚举就好；

状态$f[i][j][k][balabala]$表示填到第几位，上上位和上位分别是什么，4,8是否出现过，三个连续的是否出现过，以及当前位是否有限制；

每次转移时，枚举数字，注意第一位不能填0，4和8特判，其他数字转移，记得要三个相同

我看题解里缺少循环的方法，于是

~~一大波代码~~

你没有看错，七重for循环，~~是不是比dfs好很多~~

```
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<string>
#include<algorithm>
#include<vector>
#include<map>
#include<set>
#include<list>
#include<queue>
#include<stack>
#include<bitset>
#include<deque>
using namespace std;
#define ll long long
#define inf 0x3f3f3f3f
#define ri register int
#define il inline
#define fi first
#define se second
#define mp make_pair
#define pi pair<int,int>
#define mem0(x) memset((x),0,sizeof (x))
#define mem1(x) memset((x),0x3f,sizeof (x))
il char gc() {
	static const int BS = 1 << 22;
	static unsigned char buf[BS], *st, *ed;
	if (st == ed) ed = buf + fread(st = buf, 1, BS, stdin);
	return st == ed ? EOF : *st++;
}
#define gc getchar
template<class T>void in(T &x) {
	x = 0;
	bool f = 0;
	char c = gc();
	while (c < '0' || c > '9') {
		if (c == '-') f = 1;
		c = gc();
	}
	while ('0' <= c && c <= '9') {
		x = (x << 3) + (x << 1) + (c ^ 48);
		c = gc();
	}
	if (f) x = -x;
}
#undef gc
#define pb push_back
// 2205
#define N 500010
#define int ll
int f[12][12][12][2][2][2][2];
int c[] = {1, 2, 3, 5, 6, 7, 9}; // 7
int sol(int mx) {
	int t = mx;
	vector<int>v;
	v.pb(0);
	while(t) v.pb(t % 10), t /= 10;
	reverse(v.begin() + 1, v.end());
	mem0(f);
	f[0][0][0][0][0][1][0] = 1;
	for(ri i = 0; i < 11; ++i) {
		for(ri j = 0; j <= 9; ++j) {
			for(ri k = 0; k <= 9; ++k) {
				for(ri fo = 0; fo <= 1; ++fo) {
					for(ri ei = 0; ei <= 1; ++ei) {
						for(ri lm = 0; lm <= 1; ++lm) {
							for(ri hv = 0; hv <= 1; ++hv) {
								int t = f[i][j][k][fo][ei][lm][hv];
								if(t == 0) continue;
								// printf("%lld %lld %lld %lld %lld %lld %lld: %lld\n", i, j, k, fo, ei, lm, hv, f[i][j][k][fo][ei][lm][hv]);
								// next 4
								if(!ei) {
									if(j == 4 && k == 4) {
										if((lm && v[i + 1] > 4) || !lm)
											f[i + 1][4][4][1][0][0][1] += t;
										else if(lm && v[i + 1] == 4)
											f[i + 1][4][4][1][0][1][1] += t;
									}
									else {
										if((lm && v[i + 1] > 4) || !lm)
											f[i + 1][k][4][1][0][0][hv] += t;
										else if(lm && v[i + 1] == 4)
											f[i + 1][k][4][1][0][1][hv] += t;
									}
								}
								// next 8
								if(!fo) {
									if(j == 8 && k == 8) {
										if((lm && v[i + 1] > 8) || !lm)
											f[i + 1][8][8][0][1][0][1] += t;
										else if(lm && v[i + 1] == 8)
											f[i + 1][8][8][0][1][1][1] += t;
									}
									else {
										if((lm && v[i + 1] > 8) || !lm)
											f[i + 1][k][8][0][1][0][hv] += t;
										else if(lm && v[i + 1] == 8)
											f[i + 1][k][8][0][1][1][hv] += t;
									}
								}
								// next 0
								if(i != 0) {
									if(j == 0 && k == 0 && i >= 2) {
										if((lm && v[i + 1] > 0) || !lm)
											f[i + 1][0][0][fo][ei][0][1] += t;
										else if(lm && v[i + 1] == 0)
											f[i + 1][0][0][fo][ei][1][1] += t;
									}
									else {
										if((lm && v[i + 1] > 0) || !lm)
											f[i + 1][k][0][fo][ei][0][hv] += t;
										else if(lm && v[i + 1] == 0)
											f[i + 1][k][0][fo][ei][1][hv] += t;
									}
								}
								// other
								for(ri h = 0; h < 7; ++h) {
									int p = c[h];
									if(j == p && k == p) {
										if((lm && v[i + 1] > p) || !lm)
											f[i + 1][p][p][fo][ei][0][1] += t;
										else if(lm && v[i + 1] == p)
											f[i + 1][p][p][fo][ei][1][1] += t;
									}
									else {
										if((lm && v[i + 1] > p) || !lm)
											f[i + 1][k][p][fo][ei][0][hv] += t;
										else if(lm && v[i + 1] == p)
											f[i + 1][k][p][fo][ei][1][hv] += t;
									}
								}
							}
						}
					}
				}
			}
		}
	}
// yijing tian le i wei, shangshang wei, shang wei, 4?, 8?, limit?, have three?
	int ans = 0;
	for(ri j = 0; j <= 9; ++j) {
		for(ri k = 0; k <= 9; ++k) {
			for(ri lm = 0; lm <= 1; ++lm) {
				ans += f[11][j][k][1][0][lm][1] + f[11][j][k][0][1][lm][1] + f[11][j][k][0][0][lm][1];
			}
		}
	}
	// cout << f[11][0][0][0][1][1][1] << endl;
	return ans;
}
signed main() {
#ifndef ONLINE_JUDGE
	freopen("in.in", "r", stdin);
#endif
	int l, r;
	in(l), in(r);
	int a = (l == 10000000000) ? 0 : sol(l - 1),
	    b = (r == 10000000000) ? 1 : sol(r);
	printf("%lld", b - a);
	return 0;
}
```

---

## 作者：asuldb (赞：15)

递推版的数位dp

绝对的暴力美学

我们设$dp[l][i][j][0/1][0/1][0/1]$表示到了第$l$位，这一位上选择的数是$i$，$l-1$位选择的数是$j$，第一个$0/1$代表$4$没有/有出现过，第二个$0/1$代表$8$没有/有出现过，第三个$0/1$代表连续三位没有/有出现过

于是转移很简单了

但是卡位实在是鬼畜

我卡位的方式有些鬼畜，所以细节非常的多

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#define re register
#define maxn 16
#define LL long long
LL L,R;
int a[maxn],num;
LL dp[maxn][11][11][2][2][2];
//位数，这一位上的数，上一位的数，0/1表示4/8有/没有出现,0/1表示有/没有连续三位 
inline LL slove(LL x)
{
    memset(dp,0,sizeof(dp));
    memset(a,0,sizeof(a));
    num=0;
    while(x)
    {
        a[++num]=x%10;
        x/=10;
    }//分解数位
    a[num+1]=-11,a[num+2]=11;
    for(re int i=0;i<=9;i++)
        for(re int j=0;j<=9;j++)
            for(re int k=0;k<=9;k++)
            {
                int opt_4=0,opt_8=0;
                if(i==4||j==4||k==4) opt_4=1;
                if(i==8||j==8||k==8) opt_8=1;
                if(i==j&&j==k) dp[3][i][j][opt_4][opt_8][1]+=1;
                else dp[3][i][j][opt_4][opt_8][0]+=1;
            }//先初始化dp[3]之后再往下推
    for(re int l=3;l<num;l++)//刷表转移
        for(re int i=0;i<=9;i++)
            for(re int j=0;j<=9;j++)
                for(re int k=0;k<=9;k++)
                    for(re int o4=0;o4<=1;o4++)
                        for(re int o8=0;o8<=1;o8++)
                            for(re int o=0;o<=1;o++)
                                dp[l+1][i][j][(i==4)||o4][(i==8)||o8][((i==j)&&(j==k))||o]+=dp[l][j][k][o4][o8][o];
//方程其实挺简单的，就是看看这一位有没有4/8/连续三位就好了
    LL ans=0;
    for(re int i=3;i<num;i++)//从位数小于给定数的开始
        for(re int j=1;j<=9;j++)
            for(re int k=0;k<=9;k++)
                ans+=dp[i][j][k][0][0][1]+dp[i][j][k][1][0][1]+dp[i][j][k][0][1][1];
    for(re int i=1;i<a[num];i++)//位数和给定数相等，但是首位比较小
        for(re int j=0;j<=9;j++)
            ans+=dp[num][i][j][0][0][1]+dp[num][i][j][1][0][1]+dp[num][i][j][0][1][1];
    int o4=0,o8=0,o=0;// 4/8/连续三位有没有出现过
    if(a[num]==4) o4=1;
    if(a[num]==8) o8=1;
    for(re int l=num-1;l>=3;l--)//卡位，这里保证从[l+1,num]和给定数是完全相等的
    {
        if(o4&&o8) break;
        for(re int i=0;i<a[l];i++)
        {
        	int flag=o;
        	if(i==a[l+1]&&a[l+1]==a[l+2]) o=1;//由于我们选择这一位有可能会导致和上面的两位重复，于是这里需要判断一下，如果有那么就o=1接下来就算没有选出连续三位也可以了
        	for(re int j=0;j<=9;j++)
                {
                	int cnt=o;
                	if(i==j&&i==a[l+1]) o=1;
                    //和上面两位重合的情况
                    if(o)
                    {
                        if(o4&&!o8) ans+=dp[l][i][j][1][0][1]+dp[l][i][j][0][0][1]
                                    +dp[l][i][j][0][0][0]+dp[l][i][j][1][0][0];
                        if(!o4)
                        {
                            if(!o8) ans+=dp[l][i][j][0][0][1]+dp[l][i][j][0][0][0]
                                        +dp[l][i][j][1][0][1]+dp[l][i][j][1][0][0]
                                        +dp[l][i][j][0][1][1]+dp[l][i][j][0][1][0];
                            if(o8) ans+=dp[l][i][j][0][1][1]+dp[l][i][j][0][1][0]
                                        +dp[l][i][j][0][0][1]+dp[l][i][j][0][0][0];
                        }
                    } 
                    if(!o)
                    {
                        if(o4&&!o8)	ans+=dp[l][i][j][1][0][1]+dp[l][i][j][0][0][1];
                        if(!o4)
                        {
                            if(!o8) ans+=dp[l][i][j][0][0][1]+dp[l][i][j][1][0][1]+dp[l][i][j][0][1][1];
                            if(o8) ans+=dp[l][i][j][0][1][1]+dp[l][i][j][0][0][1];
                        }
                    }
                    o=cnt;
                }
                o=flag;//将o还原回来
        }
        o4=o4||(a[l]==4);
        o8=o8||(a[l]==8);
        o=o||((a[l]==a[l+1])&&(a[l+1]==a[l+2]));
        //判断有没有连续三位4/8出现过
    }
    if(o4&&o8) return ans;
    for(re int i=0;i<=9;i++)
        for(re int j=0;j<=9;j++)//卡最后两位
            {
                if(i*10+j>a[2]*10+a[1]) continue;//不能超过给定数的最后两位
                if(o4&&o8) continue;
                if(i==4||j==4)
                    if(o8) continue;//有4就不能有8
                if(i==8||j==8)
                    if(o4) continue;//有8就不能有4
                if(i==4&&j==8) continue;
                if(i==8&&j==4) continue;//更不可能同时出现
                if(o||(i==j&&j==a[3])||(i==a[3]&&a[3]==a[4])) ans++;
                //最后两位仍有可能和前面构成三位连续
            }
    return ans;
}
int main()
{
    scanf("%lld%lld",&L,&R);
    printf("%lld\n",slove(R)-slove(L-1));
    return 0;
}

```

---

## 作者：陈晋衍 (赞：9)

数位DP正常题目。

在数位DP中，我们一般套模板（dfs做法）（三函数，一个1维数组，一个多维数组）

数位DP中心思想：从最高位开始搜，判断每一个数位，保证每一位都会被搜到。
如果搜到最后一位符合条件，就返回这个数是符合条件的

DP模板：
```cpp
#include<iostream>
#include<cstring>
using namespace std;
int a[101],f[100];
int dfs(int k,int ok)
{
	if(k==0)return 1;//当搜索到最后一位时返回
	int end=ok?a[k]:9;//保证不会多搜，当它在高位时不会搜出a[k]
	int s=0;
	if(!ok&&f[k]!=0)//返回记忆化
		return f[k];
	for(int i=0;i<=end;i++)//从0搜到end
	{
		if(1)//条件 
		{
			s+=dfs(k-1,ok&&i==end);//把后面一位的数的数量累加起来。
		}
	}
	f[k]=s;//进行记忆化
	return s;
}
int chai(int n)//把一个数拆掉，拆到a数组中
{
	memset(a,0,sizeof(a));
	memset(f,0,sizeof(f));
	int i=0;
	while(n!=0)
	{
		i++;
		a[i]=n%10;
		n/=10;
	}
	return dfs(i,1);
}
int main()
{
	int n,m;
	cin>>n>>m;
	cout<<chai(m)-chai(n-1)<<endl;
	return 0;//结束
}
```

前面那个程序其实是一个b-a problem.它没有任何条件，把搜到的每一个数都返回了。

但是这道题是有条件的。

>工具需要检测的号码特征有两个：号码中要出现至少 3个相邻的相同数字；号码中不能同时出现 8和 4。号码必须同时包含两个特征才满足条件。

所以要对模板进行大改造。注释在代码里。

```cpp
#include<iostream>
#include<cstring>
using namespace std;
long long a[101],t[2][2][2][2][10][10][100];
//这道题条件极多。t各维对应是否到极值点、是否有4、是否有8、是否有3个连起来的数、前一个数、再前一个数
long long dfs(int k,int last1,int last2,bool ok,bool flag4,bool flag8,bool flag_3_)
//k：第几位，last1：前一个数位，last2：前两个数位，ok：是否到达极值点
//flag4：是否有4，flag8：是否有8，flag_3_：是否有3个连在一起的
//dfs函数
//用于数位DP,记忆化搜索
{
    if(flag4==1&&flag8==1)return 0;//剪枝，当已经有4、8后不管什么数都是不行的
    if(k==0){//终止条件：4、8两个不能都有且有3连起来的
        if((!(flag4==1&&flag8==1))&&flag_3_)//如果搜到的这个数符合题目给出的条件
        {
            return 1;//返回这个数是可行的。
        }
        return 0; //返回这个数是不可行的。
    }
    int end=ok?a[k]:9;//判断是否到达极值点
    int s=0;//清零，初始化
    if(t[ok][flag4][flag8][flag_3_][last1][last2][k]!=-1)return t[ok][flag4][flag8][flag_3_][last1][last2][k];//返回记忆化搜索
    for(int i=0;i<=end;i++)//在每一个数位上从0搜到9，保证一个数不多，一个数不少。
    {
        s+=dfs(k-1,i,last1,ok&&i==end,flag4||i==4,flag8||i==8,(i==last1)&&(last1==last2)||flag_3_);
        //把返回的每个数都加上，就是统计以搜到的这个数为前缀的符合条件的数的总数
        //递归，搜索下一个数位直到最后一位
    }
    t[ok][flag4][flag8][flag_3_][last1][last2][k]=s;//保存记忆化
    return s;//返回个数
}
long long chai(long long n)//这个函数作用
{
    memset(a,0,sizeof(a));
    memset(t,-1,sizeof(t));
    //初始化，全部清空
    int i=0;
    while(n!=0)//把数拆开，存在a数组里
    {
        i++;
        a[i]=n%10;
        n/=10;//把n分离每一个数位，直到n=0
    }
	if (i!=11) return 0;//输入数据
	long long s=0;
    for(int j=1;j<=a[i];j++)//第一层先运行好，减少时间复杂度。
        s+=dfs(i-1,j,-1,j==a[i],j==4,j==8,0);
    return s;
}
int main()
{
    long long n,m;//注意：此题每一个数据（包括样例）都包int
    cin>>n>>m;//输入
    cout<<chai(m)-chai(n-1)<<endl;//输出
    return 0;//完美结束
}
```

```
输入：
12121284000 
12121285550
输出：
5
```

---

## 作者：TUIFEI_oier (赞：7)

[题目链接](https://www.luogu.com.cn/problem/P4124)

（**思路过程**）  

一眼看去，吓人的数据范围显然不会让我们用 $O(R-L)$ 的枚举水过去   
（~~废话，不然这是紫题啊！~~）   
于是，我们需要一种更优秀的算法来解决本题   

仔细观察，题目所给出的限制条件都是对数的每一位值的性质   
既然如此，不难想到可以从数的本身性质上去考虑   
进一步地，我们发现可以从数的进制上来分析  
即 **在数的每一位上枚举值**  
从而我们能够在这种枚举方式的基础上进行记忆化，减少枚举量   
也就是所谓的**数位DP**

------------

（**算法设计**）   

既然有了在数的每一位上进行枚举的总思路，我们便有希望得到一种复杂度为 $O(log_{c}R)$ 的算法（c为数的进制数）   
再回到题目中，我们发现限制条件来自三个方面:
1. **是否出现过 $4$**
2. **是否出现过 $8$**
3. **上一次选的是哪一个数**

因此，我们可以尝试设计一个五维的状态:
$$dp[i][j][0/1][0/1][sta]$$
其中，$i$ 表示当前考虑到了数的第 $i$ 位；$j$ 表示上一次选择的数为 $j$；   
$0/1$ 的两维分别表示目前为止是否出现过 $4,8$   
$sta$ 取值为 ${0,1,2}$ 表示数的开头有 $sta+1$ 个相同的连续数字   
特别地，当某次 $sta==2$ 后，之后的状态的 $sta$ 值恒为 $2$

于是，我们便不难得出状态转移方程（无 $4,8$）：
$$dp[i][j][0][0][sta]=\sum_{i==0}^9(dp[i-1][k][0][0][sta==2?2:1-(j==k)*sta]$$
其他情况的状态转移方程都类似，在此不多作叙述  
算法空间复杂度 $O(log_cR*120)$ 时间复杂度 $O(log_cR)$ 足够通过本题   

相对来说，使用**记忆化搜索**更方便理解与实现，因此推荐用记搜方式解决本题   
具体代码为数位DP的板子，由读者自己实现（~~因为自己码风太丑了~~） 

$End$

---

## 作者：Baihua (赞：4)

#### [Solution] [CQOI2016]手机号码

是一道数位DP。可以用记忆化搜索解决。

[个人Blog](https://www.cnblogs.com/bj2002/p/11367472.html)

---

这道题细节非常多。可以考虑分步进行。

* 求$L$到$R$之间的符合条件的数，可以**等价为求$\text{1-R}$之间的符合条件的数减去 1-（L-1） 之间符合条件的数**。

* 那我先写一个搜索求解$L$：

```c++
void DFS (int X , int K , int U , int _4 , int _8 , int T) {
//变量名介绍：X代表当前的位数，K代表当前位所填的数字，U=1表示卡上界，否则不卡。_4和_8分别是有没有出现过4和8，T=3表示已完成三连号，否则表示未完成，且T等于当前连号。
	if (X == N - 1) {
		if (T == 3) ++ Ans ;
		return ;
	}
//如果符合条件，就累加答案。
	int Goto = Base - 1 ;
	if (U) Goto = L[X + 1] ;
//如果卡了上界，应该进行特判。
	for (int i = 0 ; i <= Goto ; ++ i) {
		if (_4 && i == 8) continue ;
		if (_8 && i == 4) continue ;
		//如果同时出现8和4就跳过这一步。
		if (T == 3) {
			DFS ( X + 1 , i , L[X + 1] == i && U ? 1 : 0 ,
            i == 4 || _4 ,i == 8 || _8 , 3) ;
		} else DFS ( X + 1 , i , L[X + 1] == i && U ? 1 : 0 ,
         i == 4 || _4 ,i == 8 || _8 , i == K ? T + 1 : 1) ;
	}
}
```

* 上面的代码可以在数位较少时得出正确结果。但是当数位较大($10^{10}≤L<10^{11}$)就会TLE。

*  搜索是盲目的，因为它做了很多重复性的工作。(By Instructor Li)

* 对于$\text{DFS (int X , int K , int U , int H4 , intH8, int K)}$，它的同一组参数所得到的结果应该是一样的。这是进行记忆化搜索的前提。

* 具体地说，开一个数组$\text{ F[20][10][2][2][2][4]}$。其中六个维度分别对应$\text{DFS}$的六个参数。

* 我们每次搜索完成后，把Ans的改变量$\delta Ans$结果记录在上述数组里，下一次遇到同一组参数，只要在$Ans$增加上已记录的答案，然后返回即可。

* 改进版本：

```c++
void DFS (int X , int K , int U , int _4 , int _8 , int T) {
//这一部分的变量名解释和刚才一样。
	if (X == N - 1) {
		if (T == 3) ++ Ans ;
		return ;
	}
	if (F[X][K][U][_4][_8][T] != -1) {
		Ans += F[X][K][U][_4][_8][T] ;
		return ;
	}
	//遇到同一组参数，只要在$Ans$增加上已记录的答案，然后返回即可。
	F[X][K][U][_4][_8][T] = Ans;
	int Goto = Base - 1 ;
	if (U) Goto = L[X + 1] ;
	for (int i = 0 ; i <= Goto ; ++ i) {
		if (_4 && i == 8) continue ;
		if (_8 && i == 4) continue ;
		if (T == 3) {
			DFS ( X + 1 , i , L[X + 1] == i && U ? 1 : 0 , i == 4 || _4 ,i == 8 || _8 , 3) ;
		} else DFS ( X + 1 , i , L[X + 1] == i && U ? 1 : 0 , i == 4 || _4 ,i == 8 || _8 , i == K ? T + 1 : 1) ;
	}
	F[X][K][U][_4][_8][T] = Ans - F[X][K][U][_4][_8][T] ;
	//把Ans的改变量δAns结果记录在上述数组里
}
```

* 这个版本已经可以快速完成求解。

其他要点：

* 注意开$\text{long long}$
* 注意细节，例如$L-1$的边界情况。



Thanks !

---

## 作者：pV_equals_nRT (赞：3)

# 标准数位DP
注：本蒟蒻不是来发代码的，而是来讲思路的。

~~看诸位大佬都鬼畜地使用 _for_ ,我表示看着晕……~~

思路很简单，记忆化搜索解决。

首先，先设置数组
```cpp
long long num[12],f[12][2][2][10][10][2];
//f[len(长度)][_8][_4][q1(前一位)][q2(前二位)][_3(是否出现过连续三位)]
```
主程序非常简单
```cpp
int main()
{
	scanf("%lld%lld",&s1,&s2);
	printf("%lld",cat(s2)-cat(s1-1));/*输入输出*/
}
```
然后存入数组
```cpp
long long cat(long long x)
{
	k=0;
	while(x)num[++k]=x%10,x/=10;//一位一位存
	memset(f,-1,sizeof(f));//清零
	return squirrel(k,0,0,-1,-1,0,1);//搜索
}
```
# 接下来是重点——
因为要求连续出现三位，因此剩下最后两位时即可判断——
```cpp
//long long squirrel(int l,bool _8,bool _4,int q1,int q2,bool c,bool m)
//当前位数、是否出现8和4、前两位数字、是否出现过连续三个数字、是否有上限
if(l==2)//剩下最后两位
{
	if(!c)return 1;//如果前面没有连续三位相同数字，最后两位必须和前一位相同
	else
	{
		if(((!_8)&&(_4))||((_8)&&(!_4)))return 81;
        //如果有一个8或4，后面两位不能再出现4或8，这样的数有81个（可以打表）
		if((!_8)&&(!_4))return 98;
        //如果既没有出现8，又没有出现4，不符合条件的数只有两个：48、84
	}
}
```
最后记搜即可
```cpp
if(f[l][_8][_4][q1][q2][c]!=-1)return f[l][_8][_4][q1][q2][c];
long long sum=0;int max=(m?num[l]:9);
for(int i=0;i<=max;i++)
{
	if((l==11)&&(!i))continue;
	if((_8&&(i==4))||((_4)&&(i==8)))continue;
	sum+=squirrel(l-1,(_8||(i==8)),(_4||(i==4)),i,q1,(c||((i==q1)&&(i==q2))),m&&(i==max));
}
if(!m)f[l][_8][_4][q1][q2][c]=sum;
return sum;
```
BTW,辅助打表程序如下：
```cpp
#include<cstdio>
int k=100;
bool squirrel(int x)
{
	while(x)
	{
		if(x%10==4)
		{
			k--;
			return 0;
		}
		x/=10;
	}
	return 1;
}
int main()
{
	freopen("squirrel.txt","w",stdout);
	for(int i=0;i<=99;i++)
		if(squirrel(i))
			printf("%02d\n",i);
	printf("%d",k);
}
```
~~管理员们审题解辛苦了，求过QWQ~~

---

## 作者：cccgift (赞：3)

## pascal的题解好少……

### 看了题面和数据范围，$O(n)$算法过不去，只能是数位$dp$了。

这题需要维护的条件有点多，我们一个个来看：

#### 1、不得出现$4$和$8$。

这很简单，用一个布尔变量判断即可，注意是“和”，而不是“或”。

#### 2、这是手机号码。

所以，号码中不可能出现前导$0$，对于第一位，我们可以从$1$开始枚举，这样就避免了前导$0$的判断。

#### 3、数中至少有连续三个数字相同。

既然没有了前导$0$，这点也就很好处理了。用两个数分别表示当前数位的前一位和再前一位的数，每一次判断三个数位是否相等即可。

那么，本题结束，注意$f$数组得记录$6$个数：当前数位所在位、前一位、再前一位、是否有$4$、是否有$8$、是否存在连三。

### 代码如下：

```pascal
var f:array[0..12,0..9,0..9,0..1,0..1,0..1] of int64; //恐怖的六维数组，更大维数的我只在八数码难题中打出过……
    l,r:int64;
    a:array[0..12] of longint;
function dfs(len,beg1,beg2:longint;ff,you4,you8,lian:boolean):int64; //记忆化搜索解决数位dp
var tot:int64;
    t1,t2,t3,endd,i:longint;
begin
  tot:=0;t1:=0;t2:=0;t3:=0;
  if you4 then t1:=1;if you8 then t2:=1;if lian then t3:=1;
  if you4 and you8 then exit(0); //注意是and
  if len=0 then exit(t3);
  if (not ff) and (f[len,beg1,beg2,t1,t2,t3]<>-1) then exit(f[len,beg1,beg2,t1,t2,t3]);
  if ff then endd:=a[len]
  else endd:=9;
  for i:=0 to endd do
    inc(tot,dfs(len-1,i,beg1,ff and (i=endd),you4 or (i=4),you8 or (i=8),lian or (beg1=beg2) and (beg1=i)));
  if not ff then f[len,beg1,beg2,t1,t2,t3]:=tot;
  exit(tot);
end;
function query(r:int64):int64;
var len,i:longint;
    ans:int64;
begin
  len:=0;ans:=0;
  fillchar(f,sizeof(f),255);
  while r>0 do begin inc(len);a[len]:=r mod 10;r:=r div 10;end;
  if len<11 then exit(0); //这里很坑！如果l是1e10，那么l-1就不是电话号码了，但结果还会把它记录下来，所以要特判！！
  for i:=1 to a[len] do inc(ans,dfs(len-1,i,0,i=a[len],i=4,i=8,false)); //这里同样要注意：枚举的数就已是4或8，或者满足limit条件
  exit(ans);
end;
begin
  readln(l,r);
  writeln(query(r)-query(l-1));
end.
```

---


# [AHOI2009] 同类分布

## 题目描述

给出两个数$a,b$，求出$[a,b]$中各位数字之和能整除原数的数的个数。


## 说明/提示

对于所有的数据，$1 ≤ a ≤ b ≤ 10^{18}$


## 样例 #1

### 输入

```
10 19```

### 输出

```
3```

# 题解

## 作者：Mathison (赞：112)

【题意简述】

给出两个数$a,b$，求出$[a,b]$中各位数字之和能整除原数的数的个数。

【分析】

显然这就是数位dp呀

我们用记搜的模板进行数位dp

不了解记搜框架下的数位dp的话戳[这里](https://www.luogu.org/blog/virus2017/shuweidp)

好了我们开始本题

这个问题的记搜过程很简单：

1. 记录$pos,sum$(数字各位上的数的和),$st$(原数),limit
1. 转移：$dfs ( pos+1, sum+i , st*10+i , i==res\&\&limit )$
1. 结束返回：搜完之后如果$st\%sum=0$就返回1否则返回0

这样搜索框架完成

现在关键的问题是：怎样记录dp状态？

这里$st$可达到$\text{1e18}$显然是不能作为dp转移的下标直接记录的

所以我们考虑**取模**

我们最理想的模数当然是把每次**搜到最后得到的数字各个位数之和**

但是我们发现在这个过程中$sum$是发生变化的

所以我们就应该以**一个定值**作为模数

那好，我们虽然不知道最后各位之和的结果，我们**枚举**总可以吧

我们只需要**枚举所有的各位数字之和**作为模数

最后判断$sum$和枚举的$mod$相等并且$st\%sum=0$的数就是符合题意的答案

上代码

```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll l,r,dp[20][200][200];
int len,a[20],mod;
ll dfs(int pos,int sum,ll st,int limit)
{
	if(pos>len&&sum==0) return 0;
	if(pos>len) return st==0&&sum==mod?1:0;
	if(!limit&&dp[pos][sum][st]!=-1) return dp[pos][sum][st];
	ll ret=0;
	int res=limit?a[len-pos+1]:9;
	for(int i=0;i<=res;i++)
		ret+=dfs(pos+1,sum+i,(10ll*st+i)%mod,i==res&&limit);
	return limit?ret:dp[pos][sum][st]=ret;
}
ll part(ll x)
{
	len=0;
	while(x) a[++len]=x%10,x/=10;
	ll ret=0;
	for(mod=1;mod<=9*len;mod++)//枚举模数（就是各位数之和）
	{
		memset(dp,-1,sizeof dp);
	    ret+=dfs(1,0,0,1);
	}
	return ret;
}
int main()
{
    scanf("%lld%lld",&l,&r);
    printf("%lld\n",part(r)-part(l-1));
	return 0;
}

```

---

## 作者：GKxx (赞：22)

看起来题解都是用记忆化深搜做的，本蒟蒻在这里给出一个递推的实现。本质是一样的，不过一个大佬告诉我记忆化深搜的常数比递推大3-4倍左右。然而我实在是太菜了，我写的递推并没有比各位的深搜快到哪去。

状态基本上跟前面说的基本一样，枚举数位和 sum，f[i][s][m][0/1] 前i位，和为s，这个数%sum=m，0表示没卡上界，1表示卡了上界。

写数位dp的时候，我习惯考虑从当前状态进行拓展，也就是所谓的刷表。代码如下。

```cpp
// C++11
#include <cctype>
#include <cstdio>
#include <climits>
#include <algorithm>
#include <cstring>

template <typename T> inline void read(T& t) {
    int f = 0, c = getchar(); t = 0;
    while (!isdigit(c)) f |= c == '-', c = getchar();
    while (isdigit(c)) t = t * 10 + c - 48, c = getchar();
    if (f) t = -t;
}
template <typename T, typename... Args>
inline void read(T& t, Args&... args) {
    read(t); read(args...);
}

#define rep(I, A, B) for (int I = (A); I <= (B); ++I)
#define rrep(I, A, B) for (int I = (A); I >= (B); --I)

// 枚举数位和 sum
// f[i][s][m][c] 前i位，和为s，这个数%sum=m，c表示卡没卡上界。
long long f[20][200][200][2];
int bit[20];
long long a, b;

inline long long solve(long long N) {
    int n = 0;	// 这个n是N的位数
    // 先分解N的每一位
    while (N) bit[++n] = N % 10, N /= 10;
    std::reverse(bit + 1, bit + n + 1);
    long long ans = 0;
    // 枚举这个数的数位之和
    for (int sum = 1; sum <= n * 9; ++sum) {
        memset(f, 0, sizeof(f));
        f[0][0][0][1] = 1;
        rep(i, 0, n - 1) rep(s, 0, sum) rep(m, 0, sum - 1) rep(c, 0, 1) {
            long long res = f[i][s][m][c];
            if (!res) continue;
            // 如果现在卡着上界了，那么下一位就不能超过原数对应的那一位。如果没卡就可以从0到9枚举
            rep(k, 0, (c ? bit[i + 1] : 9)) {
                if (s + k > sum)
                    break;
                else
                    f[i + 1][s + k][(m * 10 + k) % sum][c & (k == bit[i + 1])] += res;
            }
        }
        ans += f[n][sum][0][0] + f[n][sum][0][1];
    }
    return ans;
}

int main() {
    read(a, b);
    printf("%lld\n", solve(b) - solve(a - 1));
    return 0;
}
```

个人认为这种递推的写法比深搜的要好理解。（其实是我搜索的水平太菜了。）

---

## 作者：asuldb (赞：14)

这是一篇有些赖皮的题解

（如果不赖皮的话，bzoj上也是能卡过去的）

首先由于我这个非常$sb$的方法复杂度高达$O(171^4)$，所以面对极限的$1e18$的数据实在是卡死了

但是这个时候可以骗一下

一般来说肯定会有一个点的数据到达了$1e18$，所以我们先将$1$到$1e18$之间的答案算出来，这样再去算另一个左边界的话至少可以节省一半的常数，就算左边界不是很小也有可能还算点希望

如果左边界特别小的话，可能就能幸运的卡过去

这道题的左边界就非常小啊，我估计不超过$1e6$

于是就卡过去了

再来看看我这个非常$sb$的dp，我觉得可能没有人这么写

我们设$dp[i][j][s][k]$**表示一个数填到了$i$位，最高位填的是$j$，数位和是$s$**，且**这些数中对于某一个数取模得$k$的数的个数**

至于这个某一个数是什么，我们当然是要最外面套上一个枚举数位和了

那么答案很简单啊，如果我们当前枚举的数位和是$x$的话，答案肯定就跟$dp[][][x][0]$有关系了

那么这个方程怎么转移呢

显然有

$$dp[i+1][p][j+p][(p*10^i+k)\%x]=\sum_{t=0}^9dp[i][t][j][k]$$

$t$表示上一位填的数，$i$是位数，$p$是这一位填的数，$j$是数位和，$k$是对当前枚举的数位和取模之后的值，$x$表示当前枚举的数位和

同时我们发现好像直接去枚举$t$有些奢侈，我们可以直接把$\sum_{t=0}^9dp[i][t][j][k]$算好，于是我用$dp[i][10][j][t]$来存下来$\sum_{t=0}^9dp[i][t][j][k]$，这样就可以优化转移了

之后就是数位$dp$的套路卡上界了，大概就是注意一下卡上界的时候存一下前面的数位和

复杂度大概是$O((log_{10}n*9)^4)$，确实这是一个很垃圾的复杂度

代码

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#define re register
#define maxn 172
#define LL long long
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
LL dp[20][11][maxn][maxn];
LL L,R;
LL ans;
int num[2],a[20][2];
LL base[20];
LL mod;
inline LL qm(LL x) {return x>=mod?x-mod:x;}//优化一下取模
inline void spilt(LL x,int pd)
{
    num[pd]=0;
    while(x) a[++num[pd]][pd]=x%10,x/=10;
}//分解数位
inline void work(int x,int Len)
{
    mod=x;
    memset(dp,0,sizeof(dp));
    for(re int i=0;i<=9;++i)
        dp[1][i][i][qm(i)]+=1,dp[1][10][i][qm(i)]+=1;
    for(re int i=1;i<Len;++i)//枚举长度
        for(re int j=0;j<=min(x,i*9);++j)//枚举数位和
            for(re int k=0;k<x;++k)//枚举对当前枚举的数位和x取模后的值
                {
                    if(!dp[i][10][j][k]) continue;
                    for(re int p=0;p<=9;++p)
                        dp[i+1][p][j+p][(p*base[i]+k)%x]+=dp[i][10][j][k],dp[i+1][10][j+p][(p*base[i]+k)%x]+=dp[i][10][j][k];
                }
}
inline LL slove(int pd,int x)
{
    LL tot=0;
    for(re int i=1;i<num[pd];++i)
        tot+=dp[i][10][x][0]-dp[i][0][x][0];//统计所有位数小于给定数的，注意首位不能填0
    for(re int i=1;i<a[num[pd]][pd];++i)
        tot+=dp[num[pd]][i][x][0];//统计所有位数和给定数相同的，但是最高位小于给定数的
    LL now=a[num[pd]][pd],cnt=now;
    //now表示前面所有的数位和，cnt表示前面的数的值是多少
    //（比如说12345,卡到三这一位上，now=1+2=3，cnt=1*10+2*1=12）
    if(x-now<0) return tot;
    for(re int i=num[pd]-1;i;--i)//当前不同的那一位,[i+1,num]与x完全相同 
    {
        LL t=qm(x-cnt*base[i]%x);//根据算出后面的数位所需要的余数是多少
        for(re int j=0;j<a[i][pd];j++)
            tot+=dp[i][j][x-now][t];
        //当前第i位可以填的数必须要小于给定数当前的这一位，这里就按照dp的方式来统计答案
        now+=a[i][pd];
        cnt=cnt*10+a[i][pd];
        cnt=qm(cnt);
        if(x-now<0) break;
    }
    return tot;
}
int main()
{
    scanf("%lld%lld",&L,&R);
    spilt(L,0),spilt(R+1,1);
    base[0]=1;
    for(re int i=1;i<=18;++i) base[i]=base[i-1]*10;
    if(R==1000000000000000000) 
    {
    	ans+=29410615796612778;
    	for(re int i=1;i<=num[0]*9;++i)
        	work(i,num[0]),ans-=slove(0,i);
        printf("%lld\n",ans);
    	return 0;
	}//去掉这个if在bzoj上也能卡过去
    for(re int i=1;i<=num[1]*9;++i)//枚举数位和
        work(i,num[1]),ans+=slove(1,i)-slove(0,i);
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：光明正大 (赞：13)

## 标准数位DP

采用记忆化搜索的方式，大题思路其他的大佬已经讲得比较清晰了，我这里提供两个小优化。

就是开一个数组$f[len,sum,rem]$表示还有len位数字还没有确定，当前所有数位和为$sum$，模各数位和的余数是$rem$。

注意这里的模的各数位之和是整个数确定之后的各数位和，这个值需要在最外层枚举，然后再$dfs$。

另外就是需要额外注意$limit$，表示当前状态枚举出来的数是否与上限一样。

本题时限绰绰有余 ~~即使时限未改成3s~~

写记忆化的人只要像深搜一样加几个剪枝就行了：

1. 判断一下未填的数都是9能否到达数字和，不能就return 0

1. 在枚举本位填的数i时，保证sum+i<=mod，否则之后的一定不符合情况

这两个小优化使我的程序时间为原来的1/5左右

总时间888ms，[评测记录](https://www.luogu.com.cn/record/31659525)

代码如下：（略有压行，不喜勿喷）

```cpp
#include<bits/stdc++.h>
#define rint register int
using namespace std;
typedef long long ll;
ll n,m,f[19][163][163];//长度,各位数字和,余数 
int s[20],mod;
inline ll dfs(int len,int sum,int rem,int limit) {
	if(sum+9*len<mod) return 0;
	if(!limit&&f[len][sum][rem]!=-1) return f[len][sum][rem];
	if(!len) return sum==mod&&rem==0;
	rint maxn=limit?s[len]:9;
	register ll res=0;
	for(rint i=0;i<=maxn&&i+sum<=mod;i++) 
		res+=dfs(len-1,sum+i,(rem*10+i)%mod,limit&(i==s[len]));
	if(!limit) f[len][sum][rem]=res;
	return res;
} 
inline ll calc(ll x) {
	rint len=0;
	while(x) s[++len]=x%10,x/=10;
	register ll ans=0;
	for(mod=1;mod<=len*9;mod++) {
		memset(f,0xff,sizeof f);
		ans+=dfs(len,0,0,1);
	}
	return ans;
}
int main() {
//	freopen("a.in","r",stdin);
	scanf("%lld%lld",&n,&m);
	printf("%lld",calc(m)-calc(n-1));
    return 0;
}
```
最后附上一组大数据(也就是最大范围)：

1 1000000000000000000

29410615796612778

当然用递推应该跑的更快，不过记忆化还是很好写的。

希望能帮到大家。


---

## 作者：lwz2002 (赞：8)

## 思路

一句话题意：给出两个数$a$,$b$，求出$[a,b]$ $[a,b]$中各位数字之和能整除原数的数的个数。

很明显就是数位DP啊（~~可我还是不会QAQ~~），那我们怎么办呢？

我先用$dp_{i,j}$来记忆化前$i$位数字之和为$j$的方案总数,可是不难发现，这样做是不满足正确性的，比如$415...$和$541...$，它们的数字之和相同，也搜到了相同的位置，但它们的答案显然是不共享的，所以这样做不可行。

经过仔细思考（~~题解大法吼啊~~），如果低维不能解决问题，那我们就通过增加维度来降低我们思考的难度：

我们可以提前枚举出它的数字之和是多少，然后搜索的时候直接对这个数取模，到最后看一下模数是不是$0$并且数字之和等不等于我们枚举的数就可以了，记忆化时我们用$dp_{i,j,k}$表示搜到第$i$位，当前的模数是$j$,我们枚举的数字之和是$k$的答案数即可。

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#define MAXN 2147483647
#define ll long long

using namespace std;
int len,T;
ll a,b;
int s[1010];
ll dp[20][200][200];
ll dfs(int p,int st,int sum,int limit)
//p代表搜到了第几位，sum表示当前数的各位数字之和，st表示当前数对当前sum取模的结果 
{
	if(p>len){
		return (st==0&&sum==T) ? 1 : 0;
	} 
	if(dp[p][sum][st]!=-1&&!limit) return dp[p][sum][st];
	int res;
	ll ret=0;
	if(limit) res=s[len-p+1];
	else res=9;
	for(int i=0;i<=res;i++)
		ret+=dfs(p+1,(st*10+i)%T,sum+i,limit&&(i==res));
	if(!limit) dp[p][sum][st]=ret;
	return ret;
}
ll solve(ll x)
{
	len=0;
	while(x)
	{
		s[++len]=x%10;
		x/=10;
	}
	ll ans=0;
	for(T=1;T<=len*9;T++)
	{
		memset(dp,-1,sizeof dp);
		ans+=dfs(1,0,0,1);
	}
	return ans;
}
int main()
{
	scanf("%lld%lld",&a,&b);
	printf("%lld\n",solve(b)-solve(a-1));
	return 0;
}
```

---

## 作者：Leianha (赞：7)

# 数位DP|记忆化搜索

~~听隔壁巨佬说DP和记搜可以互相转换~~

显然这个题是可以用记忆化搜索过的，那我们应传哪几个参数？

首先就是记搜最基本的位置标记。

然后就是枚举的数字各位之和，以及取模之后的余数（判断能否整除某个数）。

最后就是判边界的参数。

当我们搜到最后一位时如果余数为0，并且各位之和=mod，那就直接返回1，否则返回零。

显然我们把这几个数装进数组里，是开不下的。

long long 为8字节 $8\times 20\times 200\times 200\times 200 \div1024 \div1024 =1220.703125 MB$

所以我们考虑枚举模数（各位之和）mod，就要求n数字各位之和=mod，n%mod=0,。

因为每个位上最大是9，所以我们从1枚举到len$\times$9.这样我们就将所有情况（数字各位之和）都考虑了进去。

这样我们就省掉了DP数组中模数那一维，妥妥的能开下。(〃'▽'〃)

我们将相同的状态用数组记录，这样在下一次搜到该状态时就能直接调用啦~~

然后分享几个卡常技巧。

今天做了一道和这个题类似的~~毒瘤卡常~~题，代码十几分钟，卡常卡了两小时QAQ，~~莫非真的是人丑常数大。~~

首先，我们可以剪枝，若sum（数字各位之和>mod），直接return 0，因为我们越往后，sum只会越来越大，不可能等于mod。

然后就是清空DP数组时将memset改为for循环，我们只用将我们上一次用到的数组清空（1~枚举的mod）就可以了（实测跑的飞快）

再然后就是搜索，正常情况下我们是这样写的：

```cpp
cin>>a>>b;cout<<calc(b)-calc(a-1);
```
但是我们忽视了一个问题，那就是相同的mod我们应该只记搜一次，但因为我们分开来计算，所以就算了两次，常数巨大>_<

那么我们就在计算b的答案的同时顺便减去a的答案就行了，这样我们每个mod只用到了一遍。

最后就是一些基本的卡常操作啦~~

卡常结果：$7.58s \rightarrow 3.11s $

还有如果让求C进制下的答案，我们只需要将代码中的10改为C就可以了

最后献上我~~丑陋~~的代码

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
bool ok;
int len,cnt,w[21],ww[71],mod;
long long b,a,dp[21][205][205];
inline long long read()
{
	char ch;long long x=0,f=1;
	while(!isdigit(ch=getchar()))
	{
		(ch=='-')&&(f=-f);
	}
	while(isdigit(ch))
	{
	    x=(x<<1)+(x<<3)+(ch^48);
	    ch=getchar();
    }
    return x*f;
} 
inline void write(long long x)
{
     if(x<0) putchar('-'),x=-x;
     if(x>9) write(x/10);
     putchar(x%10+'0');
}
long long dfs(int l,int sum,int m,int g)
{
	if(sum>mod)return 0; 
	if(l==0)
		return (m==0&&sum==mod);
	register int end=g?w[l]:9;
	if(!g&&dp[l][sum][m]!=-1)return dp[l][sum][m];
	register long long ans=0;
	for(register int i=0;i<=end;++i)
		ans+=dfs(l-1,sum+i,(m*10+i)%mod,g&&(i==end));
	if(!g)dp[l][sum][m]=ans;
	return ans;
}
long long dfs1(int l,int sum,int m,int g)
{
	if(sum>mod)return 0; 
	if(l==0)
		return (m==0&&sum==mod);
	register int end=g?ww[l]:9;
	if(!g&&dp[l][sum][m]!=-1)return dp[l][sum][m];
	register long long ans=0;
	for(register int i=0;i<=end;++i)
		ans+=dfs1(l-1,sum+i,(m*10+i)%mod,g&&(i==end));
	if(!g)dp[l][sum][m]=ans;
	return ans;
}
inline long long c1(long long x)
{
	if(!ok)
	{
		cnt=0;
		while(x)
		{
			ww[++cnt]=x%10;
			x/=10;
		}
		ok=1;
	}
	return dfs1(cnt,0,0,1);
}
inline long long c(long long x)
{
	int i,j,k;
	len=0;
	while(x)
	{
		w[++len]=x%10;
		x/=10;
	}
	register long long ans=0;
	for(mod=1;mod<=len*9;++mod)
	{
		for(i=0;i<=len;++i)
		for(j=0;j<=mod;++j)
		for(k=0;k<=mod;++k)
		dp[i][j][k]=-1;
		ans+=dfs(len,0,0,1);
		ans-=c1(a-1);
	}
	return ans;
}
int main()
{
	a=read(),b=read();
	write(c(b));
	return 0;
}
```


---

## 作者：暗ざ之殇 (赞：3)

## 题解
### 浅谈数位dp
昨天通过网课复习了一下数位$dp$，然后来做几道数位$dp$ 的题来练练手。

经典的数位$dp$ 是要求**统计符合限制的数字的个数**。

一般的形式是：求区间 $[ n , m ]$ 满足限制 $f ( 1 )$ 、$f ( 2 )$ 、$f ( 3 )$ 等等的数字的数量是多少。**条件 $f ( i )$  一般与数的大小无关，而与数的组成有关。**

善用不同进制来处理，一般问题都是十进制和二进制的数位$dp$。

数位$dp$ 的部分一般都是很套路的，但是有些题目在数位$dp$ 外面套了一个华丽的外衣，有时我们难以看出来。

数位$dp$ 一般用记忆化搜索来实现。

**数位$dp$ 的时间复杂度与位数有关。** 

### 回到本题 
一个很自然的想法是在搜索过程中维护当前已经选的数的大小和各个位的数字之和，当枚举完所有位之后判断模数是否为 $0$ 即可；

想法固然不错，但是数实在太大，没法记忆化，会超时，不可取！

**考虑到我们其实并不关心这个数本身是几，只需关心这个数模各个位的数字之和是几，而模数 ( 各个位的数字之和 ) 是小于 $9*18$ 的，所以余数也是小于 $9*18$ 的，可行。**

但是在选数的过程中，模数也是变化的，所以我们无法维护余数的大小，怎么办呢？

**我们让模数不变！**

**我们可以去枚举 $[ 1 , x ]$ 范围内的所有数的最大的各个位的数字之和是几，等到选完所有位之后，再判断你选完的数的各个位的数字之和与你一开始枚举的是否相同即可，不相同即不合法状态；**

### 剪枝
想出正解的你开开心心地把代码交上去，然后$TLE$了......

考虑怎么剪枝，记忆化我们都加上了，看来只能在**各个位的数字之和**上面动点手脚了$qwq$。

考虑到判断一个状态合法的前提是**你选出的各个位的数字之和要等于你一开始枚举的那个数**，由此我们可以想到两个可行性剪枝：

**①. 如果当前你选的各个位的数字之和 $sum$ 已经大于了你一开始枚举的那个数，那么之后的状态一定是不合法的，直接返回 $0$ 即可；**

**②. 如果你剩下的所有位都选了 $9$，但是加起来的 $sum$ 还是比你一开始枚举的那个数小，那么之和再怎么选都是不合法的，直接返回 $0$ 即可；**

$Code$：
```
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
long long l,r;
int c[100];
long long dp[100][200][200];
long long dfs(int k,int Mod,int mod,int sum,bool limit)  //当前正在选第k位,模数是Mod,余数是mod,选的所有位的数字之和为sum,是否顶上界 
{
	if(sum>Mod||sum+9*(k+1)<Mod) return 0;               //如果当前选的各个数的数字之和已经大于Mod了,或者之后的位数都选9还是小于Mod,那么不用搜了,肯定是不合法的 
	if(k<0)                                              //枚举完所有位数了 
	{
		if(sum==Mod&&mod==0) return 1;                   //必须要保证你选的各个位的数字之和等于Mod,且余数mod==0才是符合要求的状态 
		return 0;
	}
	if(!limit&&dp[k][mod][sum]!=-1) return dp[k][mod][sum]; //记忆化 
	int up=9;
	if(limit) up=c[k];                                   //up是当前位所能填的最大数字 
	long long ans=0;
	for(int i=0;i<=up;i++)
	{
		ans+=dfs(k-1,Mod,(mod*10+i)%Mod,sum+i,limit&&i==up);//转移到下一位 
	}
	if(!limit) dp[k][mod][sum]=ans;                      
	return ans;
}
long long solve(long long x)                             //求[1,x]内符合条件的数的个数 
{
	memset(c,0,sizeof(c));
	int len=0;
	while(x)                                             //将x一位一位地拆开 
	{
		c[len++]=x%10;
		x/=10;
	}
	long long ans=0;
	for(int i=1;i<=9*len;i++)                            //枚举所有数的各位数字之和,最大是9*len 
	{
		memset(dp,-1,sizeof(dp));                        //注意每次搜索前都要memset 
		ans+=dfs(len-1,i,0,0,1);                         //现在在枚举第len-1位,模数是i,余数是0,选的各个位的数字之和为0,顶上界 
	} 
	return ans; 
}
int main()
{
	scanf("%lld %lld",&l,&r);
	printf("%lld\n",solve(r)-solve(l-1));                //前缀和的思想 
	return 0;
}
```

### 总结
$10$ 进制数位$dp$ 的基本最简单的形式。

记忆化搜索处理数位$dp$ 的代码实现，数位$dp$ 一般都用记忆化搜索来做。

考察思维的数位$dp$ 往往会和其他如枚举算法结合，或作为原问题的子问题。

除了十进制，二进制的数位$dp$ 也是常见的，此外 $K$ 进制的也是可以的。


---

## 作者：灼眼的夏娜 (赞：3)

帮我同桌调了两个小时，准确来说是在卡常，于是

最后是我来发题解？

好吧辣么我们来看题

一看，裸的数位DP欸

那就很自然的设状态: f[i][j][k] 表示

第i位，它的当前数字和是j，取模结果是k的值

所以我们就可以转移......

等等，模数呢？
emmm~~

好吧那就枚举一下模数（因为它最大才9 * 18，ok的）

然而下面有一些骚操作，考试时老师极其恶心的卡时限

这就是我为啥帮我同桌调了俩小时

所以代码如下：

## code

```cpp
#include<bits/stdc++.h>
#define R register

using namespace std;
typedef long long LL;
LL l,r,f[100][405][405];
int tot,cnt,num[100],MOD,kk[100];

inline LL read()
{
	R LL x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x = x*10+c-'0';c = getchar();}
	return x*f;
}

//记忆化搜索模板
LL dfs(int i,int sum,int mod,bool limit)
{
	if(i == 0) return (mod == 0 && sum == MOD);
	if(!limit && f[i][sum][mod] != -1) return f[i][sum][mod];
	int up = (limit ? num[i] : 9);
	LL ans = 0;
	for(R int j = 0;j <= up;++ j){
		R int k = (mod * 10 + j) % MOD;
		ans += dfs(i - 1,sum + j,k,limit && (j == up));
	}
	if(!limit) f[i][sum][mod] = ans;
	return ans;
}

LL dfs1(int i,int sum,int mod,bool limit)//由于拆分的结果不同，需要第二个dfs 
{
	if(i == 0) return (mod == 0 && sum == MOD);
	if(!limit && f[i][sum][mod] != -1) return f[i][sum][mod];
	int up = (limit ? kk[i] : 9);//与第一个dfs的唯一不同，up 
	LL ans = 0;
	for(R int j = 0;j <= up;++ j){
		R int k = (mod * 10 + j) % MOD;
		ans += dfs1(i - 1,sum + j,k,limit && (j == up));
	}
	if(!limit) f[i][sum][mod] = ans;
	return ans;
}

inline LL solve(LL x,LL y)
{
	R LL res = 0;
	while(x) num[++cnt] = x % 10,x /= 10;
	while(y) kk[++tot] = y % 10,y /= 10;//两次拆分，省时间 
	for(MOD = 1;MOD <= cnt * 9;++ MOD){
		for(R int i = 0;i <= cnt;++ i)
		for(R int j = 0;j <= MOD;++ j)
		for(R int k = 0;k <= MOD;++ k)
			f[i][j][k] = -1;//不敢用一个memset 
		res += dfs(cnt,0,0,1);
		res -= dfs1(tot,0,0,1);//同时计算左端点，省时间 
	}
	return res;
}

signed main()
{
//	freopen("B.in","r",stdin);
//	freopen("B.out","w",stdout);
	l = read();
	r = read();
	printf("%lld",solve(r,l - 1));//一个solve,省时间 
	fclose(stdin);
	fclose(stdout);
	return 0;
}
```

总之就这样在评测机上1.7s过了

然而我看到这里有560ms的dalao？果然我还是蒟蒻

心都碎了

好吧，本蒟蒻的第一篇题解到此结束

欢迎各位斧正

---

## 作者：Demoe (赞：2)

### [题目传送门](https://www.luogu.com.cn/problem/P4127)

## 简述题意

- 对于 $[l,r]$ 求其中能用自己数位和整除的数的个数。

## 数位DP

我们将满足条件的转换为总数减去不满足条件的个数。

我们很容易想到**数位DP**。

$[l,r]$ 的结果可表示为 $[1,r]-[1,l-1]$ 的结果。

但我们发现直接做不太方便。

对于数位和，我们不方便进行处理。

那么我们可以枚举数位和。

对于每次枚举的进行计算。

定义 $f_{p,d,s,v}$ 为用9还是余下首位，$d$ 位数，数位和剩下 $s$，模数位和余 $v$。

可得递推方程。

```cpp
for(ll i=max(0LL,s-(d-1)*9LL);i<=min((p)?9LL:a[d],s);i++) sum+=dp(p|(i<a[d]),d-1,s-i,(v*10+i)%mod);
```

不断递归，即可得出答案。

对码力有要求，不要出细节错误。

设 $len$ 为 $r$ 的位数。

复杂度 $O(len^4)$。

由于其有巨大的常数，时限放在2s。（虽然标程1s跑得过）

大约加上常数后是 $O(10^8)$ 数量级。

你可以手切这题了。/cy

```cpp
/*
***
还要继续努力
成为一名烤咕学家哦
***
*/
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=200;
ll a[25],vis[2][25][N][N],f[2][25][N][N],l,r,mod,tot,cnt; 
template <typename T> void rd(T &x){
	ll fl=1;x=0;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') fl=-fl;
	for(;isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+c-'0';
	x*=fl;
}
void wr(ll x){
	if(x<0) x=-x,putchar('-');
	if(x<10) putchar(x+'0');
	if(x>9) wr(x/10),putchar(x%10+'0');
}
ll dp(ll p,ll d,ll s,ll v){
	if(!d)return !s&&!v;
	if(vis[p][d][s][v]==tot)return f[p][d][s][v];
	vis[p][d][s][v]=tot;
	ll sum=0;
	for(ll i=max(0LL,s-(d-1)*9LL);i<=min((p)?9LL:a[d],s);i++) sum+=dp(p|(i<a[d]),d-1,s-i,(v*10+i)%mod);
	return f[p][d][s][v]=sum;
}
ll solve(ll x){
	ll sum=0;cnt=0;
	for(cnt=0;x;x/=10) a[++cnt]=x%10;
	for(mod=1;mod<=cnt*9;mod++) tot++,sum+=dp(0,cnt,mod,0);
	return sum;
}
int main(){
//	freopen("count5.in","r",stdin);
//	freopen("count5.out","w",stdout);
	rd(l);rd(r);
	wr(r-l+1-solve(r)+solve(l-1));puts("");
	return 0;
}
```



---

## 作者：Plus_Ultra (赞：2)

### 题解：

1. 这道题时我在 qbxt 考试时老师出的题的弱化版.那道题的版本是加上多种进制（貌似差不多）.当时不会，打了个暴力，现在遇到了这道题，有点后悔刷的题太少了.

2. 前言： 

- 数位DP是与数字相关的一类计数问题.这类问题通常都是给你几个限制和寻找范围，求满足限制的数的个数有多少.

- 面对这类问题，我们首先想到爆搜.不用想，肯定爆炸.于是乎我们来考虑优化方法.很容易可以想到：记忆化搜索！

- 不过并没有那么简单.有诸多限制，比如说搜索不能超过给定区间的范围，不能有前导0等等，这时我们就需要仔细考虑了.

- 我们尝试在记忆化搜索中记录这些限制，考虑如何转移即可.（尽可能把状态都记录下来）

3. 可以发现，像这类计数型问题，都是可以套模板的.我们先来分析一下模板.

- [博客食用口感更好哟](https://www.luogu.org/blogAdmin/article/edit/167531)

```
int DFS(int len,int limit,int lead,int ...各种限制)//len表示填数到了第几位,limit表示有无上界限制,lead表示有无前导0 
{
    if(len==0)return 1;//边界条件 
    if(!limit&&!lead&&dp[len][...]!=-1)//如果搜过并且没有上界限制和前导0,这一位可以随便填 
    return dp[len][...];//记忆化搜索 
    int maxx=limit?num[len]:9;//如果前一位有限制（填到了最高位）那么这一位不能超过num这一位的大小，否则0~9随便取 
    int res=0; 
    for(int i=0;i<=maxx;i++)
    {
        if(...)//限制条件 
        res+=DFS(len-1,limit&&(i==maxx),lead&&!i,...);//如果本位已经枚举到上界就把上界往后传,上一位有前导0而且这一位是0，那么下一位有前导0 
    } 
    if(!limit&&!lead)dp[len][...]=res;//因为如果枚举到上限则答案并不是这一位上所有的和，所以就不更新
	//着重分析这一句话：当有前导0或有上界限制时,下一位有不能填的数，而dp数组记录的是下一位能填0~9的数，所以不更新. 
    return res; 
}

int solve(int x)
{
    int len=0;//位数 
    while(x)//这里是预处理出每一位数的上界 
    {
        num[++len]=x%10;
        x=x/10;
    }
    return DFS(len,1,1,...);//有前导0和上界限制 
} 
int main()
{
    cin>>a>>b;
    cout<<solve(b)-solve(a-1)<<endl;//可以先求1~b中满足限制的个数，再求1~a-1中满足限制的数的个数，相减即可 
} 
```

4. 具体解法：

- 有了模板之后，就不慌了.剩下处理一下小问题，套模板即可.

- 首先限制条件和数字和是有关系的，同时还可以注意到一个数的数字和是很小的，那么就启发我们可以枚举这个数字和 sum 是多少，然后考虑有多少数，它的数位和是 sum，且这个数对 sum 取模为 0，也就是这个数的 sum 的倍数.

- 按照数位 dp 的一般套路，我们就设 dp[i][sum][mod] 表示到了第 i位，之前的数位和是 sum，数字对枚举的和取模是 mod，考虑枚举这位是多少，一直到边界即可.

- 下面套模板就可以啦！！！

5. 下面上代码（我知道各位大佬也不需要代码）：

```
#include<iostream>
#include<cstring>

#define LL long long

using namespace std;

LL dp[20][200][200],a,b,num[20],lent,Sum,ans;

LL DFS(int len,int sum,int mod,int limit)//分别代表位数,当前填了的数字之和,数字对枚举的和取模是mod,有没有上界限制 
{
	if(!len)  return sum==Sum&&!mod?1:0;//边界情况：枚举完每一位，并且sum等于当前枚举的数字和，模数是0，即符合要求 
	if(dp[len][sum][mod]!=-1&&!limit)  return dp[len][sum][mod];
	LL res=0,maxx=limit?num[len]:9;//上界 
	for(int i=0;i<=maxx;i++)
	res+=DFS(len-1,sum+i,(mod*10+i)%Sum,limit&&(i==maxx));//DFS下一位的情况 
	return limit?res:dp[len][sum][mod]=res;//有限制就不更新，否则更新 
}

LL solve(LL x)
{
	lent=ans=0;
	while(x)//处理出上界 
	{
		num[++lent]=x%10;
		x/=10;
	}
	for(Sum=1;Sum<=lent*9;Sum++)//枚举数字和 
	memset(dp,-1,sizeof(dp)),ans+=DFS(lent,0,0,1);//注意这里要清零 
	return ans;
}

int main()
{
	cin>>a>>b;
	cout<<solve(b)-solve(a-1)<<endl;//区间符合要求的数的个数 
		
	return 0;
} 
```

去掉空行后30来行，也是比较短的了.

### [Plus Ultra!!!](https://www.luogu.org/blog/OnePunchManGO/)


---

## 作者：小周猪猪 (赞：2)

记忆化搜索大家一定很清楚，也能够十分简单的通过这道题

但是写记忆化搜索的同志一定很难通过BZOJ3003月之谜。

可以说是这道题的拓展吧。

在这里，对于这道题可以采用离线的方法，先将所有的询问读入。

在枚举模数的时候，对所有的数都做一遍数位DP。

由于模数不会超过两百，加上记忆化搜索相当于一次DP，一共不会做超过两百次的记忆化搜索。f数组也只需要重新memset不到两百次即可。

因此总效率我们是可以接受的。

这样就可以做到装备经验漏~~~
```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

#define int long long

using namespace std;

int n = 0, P, m;
int num[10000], a[30], f[22][411][411], ans[10000];

//sum1表示各位数字之和
//sum2表示数字对P取模的和 
int dp(int x,int sum1,int sum2,int isMin)
{
	if (x == 0) return sum1 == P and sum2 == 0;
	if (sum1 + x * 9 < P) return 0;
	if (!isMin and ~f[x][sum1][sum2]) return f[x][sum1][sum2];
	int Max = isMin ? a[x] : 9, cnt = 0;
	for (int i=0;i<=Max;++i)
	    cnt += dp(x-1,sum1+i,(sum2*10+i)%P,isMin&&i==a[x]);
	if (!isMin) f[x][sum1][sum2] = cnt;
	return cnt;
}

int Solve(int x)
{
	m = 0;
	while (x > 0) {
		a[++m] = x % 10;
		x /= 10;
	}
	if (m * 9 < P) return 0;
	return dp(m,0,0,1);
}

signed main(void)
{
	freopen("mystery.in","r",stdin);
	freopen("mystery.out","w",stdout);
	int t1, t2;
	while (cin>>t1>>t2) 
		num[++n] = t1-1, num[++n] = t2;
	for (P=1;P<=20*9;++P)
	{
		memset(f,-1,sizeof f);
	    for (int i=1;i<=n;++i) ans[i] += Solve(num[i]);
	}
	for (int i=1;i<=n;i+=2) 
	    printf("%lld\n", ans[i+1]-ans[i]);
	return 0;
}
```


---

## 作者：生而为人 (赞：1)

####  ~~清北学堂的考试题~~的弱化版。
###### 提供一种新的优化方式

我做的题 是在C进制下 的 个数 其实 和十进制一样，只是把 %10，/10
改为 %c，/c 其它的 照搬。。
在这里我讲一种 新的优化方式可以优化一半的时间复杂度。

#### 详细的细节如下：
######  1.别用 memset 你用了 什么 dp数组 清除什么dp数组
######  2.在一枚举特定的数字和时，我们可以 求出，两个边界在该条件下的值，不用枚举一次清除一次，枚举一次清除一次。
######  3.不开 longlong 死全家。
######  4.和本题无关的。。 若是N进制的情况下，数组应适度的增大。
---------------------------------------------RP守恒------------------------------------------------
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
long long dp[70][401][401],g[70],a,b,c,MOD,gg[70];
long long dfs(int len,int sum,int mod,int limt)
{
    if(len<=0&&mod==0&&sum==MOD)// 如果 符合条件 就 返回 1 
    return 1;
    if(len<=0)// 不符合 条件 返回 0 
    return 0;
    int top=limt?g[len]:(c-1);// limt==1 为擦边，limt==0 为不擦边 
    if(!limt&&dp[len][sum][mod]!=-1)return dp[len][sum][mod];// 记忆化搜索的核心。。注意初值 为-1 避免重复 搜寻、 
    long long res=0;
    for(int i=0;i<=top;++i)
    res+=dfs(len-1,sum+i,(mod*c+i)%MOD,limt&&top==i);// 统计答案、 
    if(!limt)
    dp[len][sum][mod]=res;//赋值、 
	return res;
}
long long dfs1(int len,int sum,int mod,int limt)//同dfs 只是 把数组 改了。 
{
    if(len<=0&&mod==0&&sum==MOD)
    return 1;
    if(len<=0)
    return 0;
    int top=limt?gg[len]:(c-1);
    if(!limt&&dp[len][sum][mod]!=-1)return dp[len][sum][mod];
    long long res=0;
    for(int i=0;i<=top;++i)
    res+=dfs1(len-1,sum+i,(mod*c+i)%MOD,limt&&top==i);
    if(!limt)
    dp[len][sum][mod]=res;
	return res;
}
long long solve1(long long nn)
{
    int cnt=0;
    while(nn)
	{
    	gg[++cnt]=nn%c;
		nn/=c;
	}  
    return dfs1(cnt,0,0,1);
}
long long solve(long long n)
{
    int len=0;
    while(n)
	{
    	g[++len]=n%c;
		n/=c;
	}
    long long res=0;
    for(MOD=1;MOD<=len*(c-1);MOD++)
    {
    	for(int i=0;i<=len;i++)//用了什么 清什么。 
    	for(int j=0;j<=MOD;j++)
    	for(int k=0;k<=MOD;k++)
    	dp[i][j][k]=-1; 
    	res+=dfs(len,0,0,1);
    	res-=solve1(a-1);
    	
	}
    return res;
}
int main()
{
	freopen("B.in","r",stdin);
	freopen("B.out","w",stdout);
	c=10;
    scanf("%lld%lld",&a,&b);
    printf("%lld",solve(b));
    fclose(stdin);
    fclose(stdout);
    return 0;
}
```


---

## 作者：Jayun (赞：1)

# 题目大意：

给出两个数 $a,b$，求出 $[a,b]$ 中各位数字之和能整除原数的数的个数。

# 正文：

在区间内的计数内问题，考虑到使用 数位DP。

抓住题目大意中的关键词：

> 求出 $[a,b]$ 中各位数字**之和**能**整除**原数的数的个数。

一般数位DP的状态的隐藏在题目中，因此得出动态规划的状态 $f_{len,sum,mod,pos}$ 表示当第 $len$ 位各位数字之和为 $sum$ 除原数的余是 $mod$ 且有没有碰顶时的个数。得到了状态接下来就只是简单的板子了。

# 代码：

```cpp

ll dfs(ll len, ll sum, ll x, bool pos)
{
	if(sum + 9 * len < mod) return 0;
	if(!len) return sum == mod && x == 0;
	if((~f[len][sum][x][pos])&& !pos)
		return f[len][sum][x][pos];
	int m = pos ? a[len]: 9;
	ll ans = 0;
	for (int i = 0; i <= m && i + sum <= mod; i++)
	{
		ans += dfs(len - 1, sum + i, (10ll * x + i) % mod, i == a[len] && pos);
	}
	if(!pos) f[len][sum][x][pos] = ans;
	return ans;
	
} 

ll solve(ll n)
{
	memset(a, 0, sizeof(a));
	ll x = n;
	ll len = 0;
	for (; x; x /= 10)a[++len] = x % 10;
	ll ans = 0;
	for (mod = 1; mod <= len * 9; mod ++)
	{
		memset(f, -1, sizeof(f));
		ans += dfs(len, 0, 0, 1);
	}
	return ans;
}
```

---

## 作者：大菜鸡fks (赞：1)

先枚举确定数字位总和，固定总和就是裸题了

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
typedef long long ll;
ll a,b;
inline void init(){
	scanf("%lld%lld",&a,&b);
}
const int N=20;
int num[N],len;
ll dp[N][9*N][9*N];
ll dfs(int pos,int p,int s1,int s2,bool flag){
	if (!pos) return (s2==0&&s1==p);
	if (s1>p||s1+pos*9<p) return 0;
	if ((~dp[pos][s1][s2])&&(!flag)) return dp[pos][s1][s2];
	ll ans=0; int lim=9;
	if (flag) lim=num[pos];
	for (int i=0;i<=lim;i++){
		ans+=dfs(pos-1,p,s1+i,(s2*10+i)%p,flag&&(i==lim));
	}
	if (!flag) dp[pos][s1][s2]=ans;
	return ans;
}
inline ll sol(ll A){
	len=0;
	for (;A;A/=10) num[++len]=A%10;
	if (!len) return 0ll;
	ll ans=0;
	for (int i=1;i<=len*9;i++){
		memset(dp,-1,sizeof(dp));
		ans+=dfs(len,i,0,0,1);
	}
	return ans;
}
inline void solve(){
	printf("%lld\n",sol(b)-sol(a-1));
}
int main(){
	init();
	solve();
	return 0;
}
```

---


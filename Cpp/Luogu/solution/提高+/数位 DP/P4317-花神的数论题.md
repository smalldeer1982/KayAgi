# 花神的数论题

## 题目背景

众所周知，花神多年来凭借无边的神力狂虐各大 OJ、OI、CF、TC …… 当然也包括 CH 啦。

## 题目描述

话说花神这天又来讲课了。课后照例有超级难的神题啦…… 我等蒟蒻又遭殃了。 花神的题目是这样的：设  $\text{sum}(i)$  表示  $i$  的二进制表示中  $1$  的个数。给出一个正整数  $N$  ，花神要问你  $\prod_{i=1}^{N}\text{sum}(i)$ ，也就是  $\text{sum}(1)\sim\text{sum}(N)$  的乘积。

## 说明/提示

对于 $100\%$ 的数据，$1\le N\le 10^{15}$。

## 样例 #1

### 输入

```
3```

### 输出

```
2```

# 题解

## 作者：小粉兔 (赞：213)

数位DP(二进制)计算出G[i]为恰好有i个的方案数。

答案为$\prod i^{G[i]}$，快速幂解决。

```cpp
#include<cstdio>
#define LL long long
#define M 10000007
LL N,Ans=1;
LL C,G[50];
LL qPow(LL b,LL e){LL A=1;for(;e;b=b*b%M,e>>=1)e&1?A=A*b%M:0;return A;}
int main(){
	scanf("%lld",&N);
	for(int j=49;~j;--j){
		for(int i=49;i;--i)
			G[i]+=G[i-1];
		if(N>>j&1) ++G[C++];
	} ++G[C];
	for(int i=1;i<=49;++i)
		Ans=Ans*qPow(i,G[i])%M;
	printf("%lld",Ans);
	return 0;
}
```

---

## 作者：zhoutb2333 (赞：70)

这题可以分别统计每个$sum$结果在$1$~$N$中出现的次数，然后再快速幂输出。统计次数可以用数位DP做。
这里我采用的是dfs形式的，好写而且不容易出错，也不慢。
然后本题不用关心前导零什么的问题。
``` cpp
#include<bits/stdc++.h>
#define maxn 51
#define ll long long
using namespace std;

int x[maxn],cnt=0;
ll f[maxn][2][maxn][maxn],ans[maxn],n,p=1e7+7;
ll pw(ll a,ll b){
	ll ret=1;
	while(b)
		ret=ret*(b&1?a:1)%p,a=a*a%p,b>>=1;
	return ret;
}
ll _f(int cur,int up,int tmp,int d){
//从二进制高位到低位填，cur表示该填第几位，up表示是否顶着上界，tmp表示当前填了几个1，d表示总的1的个数。
	if(!cur)
		return tmp==d;
	if(~f[cur][up][tmp][d])
		return f[cur][up][tmp][d];
	int lim=up?x[cur]:1;
	ll ret=0;
	for(int i=0;i<=lim;i++)
		ret+=_f(cur-1,up&&i==lim,tmp+(i==1),d);
	return f[cur][up][tmp][d]=ret;
}
ll solve(){
	while(n)
		x[++cnt]=n&1,n>>=1;
	for(int i=1;i<=50;i++)
		memset(f,-1,sizeof(f)),ans[i]=_f(cnt,1,0,i);
	ll ret=1;
	for(int i=1;i<=50;i++)
		ret=ret*pw(i,ans[i])%p;
	return ret;
}
int main(){
	scanf("%lld",&n);
	printf("%lld\n",solve());
	return 0;
} 
```

---

## 作者：Styx (赞：67)

这题先果断先打表，大概是这样的
```
1 1
2 1
3 2
4 1
5 2
6 2
7 3
...
```

感觉太难看了，换个格式
```
1
1 2
1 2 2 3
1 2 2 3 2 3 3 4
...
```
还是不舒服，排个序
```
1
1 2
1 2 2 3
1 2 2 2 3 3 3 4
...
```
不够简洁，我们统计一下每个数出现的次数
```
1
1 1
1 2 1
1 3 3 1
...
```
嗯，这是一个杨辉三角

杨辉三角第i层有i个数，和是2^(i-1)

每次n会被减掉2^i，复杂度是logn的

每层遍历i个数，复杂度也是logn的

在嵌上快速幂跑i^cnt[i]次，复杂度大约也是logn

所以算这一部分的总复杂度是lognlognlogn

但是只能保证算出2^n-1这样的数的值

如果n=2^50-2，我们还要暴力跑2^49左右的数据，凉凉……

考虑继续找规律

我们随便看一下当n=14的时候剩下的那一行


```
1 2 2 3 2 3 3 
```

好像没什么规律，但是和上面那打表的三行一对比

```
1 2 2 3 (1+1) (2+1) (1+2)
```

可能规律还是不明显
那么来个26试试

```
1 2 2 3 2 3 3 4 2 3 3
```

对比表上四行

```
1 2 2 3 2 3 3 4 (1+1) (2+1) (1+2)
```

没错，将减去一堆2^i次后的n用二进制表示

14变成了111,26变成了1011.

然后有1在的第i位会产生长度为2^(i-1)的同上杨辉三角的规律，不过对于从左往右数第i个1，他的基数要加上i-1

这个数用二进制表示最多有log个1，复杂度logn

转换成杨辉三角枚举每一个值出现的个数，复杂度是logn

内嵌快速幂复杂度logn

总复杂度lognlognlogn

所以总复杂度是lognlognlogn

还是可以过的

代码如下：

```cpp
#include<cstdio>
#include<string>
#include<cstring>
#include<iostream>
#include<algorithm>
#define mod 10000007
using namespace std;

long long ans=1,n,k,cnt,dp[110][110];

long long kasumi(long long a,long long b)
{
    long long tmp=1;
    while(b)
    {
        if(b&1) tmp=(tmp%mod)*a%mod;
        a=(a%mod)*a%mod;
        b>>=1;
    }
    return tmp%mod;
}

int main()
{
    scanf("%lld",&n);
    for(int i=1; i<=60; i++)
    {
        dp[i][1]=1;
    }
    for(int i=1; i<=60; i++)
    {
        dp[i][i]=1;
    }
    for(int i=2; i<=60; i++)
    {
        for(int j=2; j<i; j++)
        {
            dp[i][j]=dp[i-1][j-1]+dp[i-1][j];
        }
    }
    for(k=1; k<=n; k<<=1)
    {
        n-=k;
        cnt++;
        for(int j=1; j<=cnt; j++)
        {
            ans=(ans%mod)*kasumi(j,dp[cnt][j])%mod;
            ans%=mod;
        }
    }
    cnt=0;
    for(int i=60;i>=0;i--)
    {
        if((1ll<<i)<=n)
        {
            for(int j=1;j<=i+1;j++)
            {
                ans=(ans%mod)*kasumi(j+cnt,dp[i+1][j]);
                ans%=mod;
            }
            cnt++;
            n-=(1ll<<i);
        }
    }
    printf("%lld\n",ans);
}
```

至于为什么不用扩展欧拉定理降幂，那是因为杨辉三角在总和等于1e15的时候
，每一个数肯定不会爆longlong

---

## 作者：lwz2002 (赞：32)

##  思路

（我看了好多题解好像都没和我写的一样的QAQ）

一句话题意：求$1$到$n$中每个数的二进制下的$1$的个数的累乘。

首先我们看到的是$1$到$n$的二进制，所以我们可以将$n$进行二进制拆分，从而得到我们数位DP的上限，然后就开始套模板啦（~~逃~~）。

思考一下，当搜到一个位置$pos$时，我们需要的只是它前面$1$的个数，和$1$的排列方式无关，所以我们只需要在记忆化时记录位数$pos$和前面$1$的个数$st$即可。

```
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#define MAXN 2147483647
#define ll long long

using namespace std;
const int mod=1e7+7;
int len;
ll n; 
int a[55];
ll dp[55][55];
ll dfs(int p,int st,int limit)
{
	if(p>len) return max(st,1);
	if(dp[p][st]!=-1&&!limit) return dp[p][st];
	ll ret=1;
	int res;
	if(limit) res=a[len-p+1];
	else res=1;
	for(int i=0;i<=res;i++)
		(ret*=dfs(p+1,i==1 ? st+1 : st,limit&&(i==res)))%=mod;
	if(!limit) dp[p][st]=ret;
	return ret;
}
int main()
{
	scanf("%lld",&n);
	while(n)
	{
		a[++len]=n&1;
		n>>=1;
	}
	memset(dp,-1,sizeof dp);
	printf("%lld\n",dfs(1,0,1));
	return 0;
}
```

---

## 作者：xyx_xcc (赞：27)

这题是个数位DP，首先我们看题目中求得是1~n中每个数二进制个数之积，范围很大，显而易见，int的二进制位数在32位内，我们只要找到1~n中含有1个一的个数，2个一的一个，3.....，以此类推，用快速幂算一下就好了，于是这个上面的东西很容易用DP写一下，我们设方程f[i][j]表示i位中含j个一的个数，把给定的n二进制分解一下，按照数位DP的套路写一下就好了

---

## 作者：liuzhangfeiabc (赞：21)

说一种之前没人说的新思路。

我们先观察这个数列长什么样子，为了方便起见我们把0也加入序列：

0 1 1 2 1 2 2 3 1 2 2 3 2 3 3 4……

有一个比较显然的结论是，我们可以这样构造这个序列：

初始时，序列里只有一个0；每次迭代时我们把整个序列所有元素+1后接在原序列后面。

这很容易理解，毕竟i和i+2^j(i<2^j)之间只差了最高位那个1嘛。

于是我们可以构造这样一个dp：设dp(i,j)表示0~2^i - 1的所有元素，每个元素的sum值整体+j后的乘积。特别地，当j=0时，表示的是1~2^i - 1的sum乘积。

那么转移就很显然了：dp(i,j)=dp(i-1,j)×dp(i-1,j+1)。

统计答案时，我们将n+1(+1是因为我们要考虑那个“不存在的0”)二进制分解，对于从低到高第i位，如果这一位是1，且更高位有j个1，那么它的贡献就是dp(i,j)。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define li long long
const int mo = 10000007;
li dp[70][70],n;
int fj[70],tot;
int main(){
	int i,j;cin>>n;
	dp[0][0] = 1;for(i = 1;i <= 64;++i) dp[0][i] = i;
	for(i = 1;i <= 64;++i) for(j = 0;j + i <= 64;++j) dp[i][j] = dp[i - 1][j] * dp[i - 1][j + 1] % mo;
	++n;while(n){
		fj[tot++] = n & 1;n >>= 1;
	}
	li as = 1;j = 0;
	for(i = tot - 1;i >= 0;--i){
		if(fj[i]) as = as * dp[i][j++] % mo;
	}
	cout<<as;
	return 0;
}
```

---

## 作者：bits (赞：17)

10^15规模的数据，直接暴力肯定T掉。

## 所以

这题我们换种思维，不用常规的数位$dp$写法，而是统计二进制表示中含有$i$个$1$的数的个数。

$dp$时直接按二进制枚举即可。

设$dp[i][j][k]$为在前$i$位中，已经有$k$个$1$，且该数总计有$j$个$1$，的数的个数。

每次枚举$j$，统计相应的值(设为$x$)，求出$x$的$j$次方，最后的答案即为所有的 **x的j次方** 相乘的积。

$dfs$部分代码及分析

```cpp
ll dfs(int pos,int cnt,int num,bool limit){
/*
pos: 枚举到第pos位
cnt: 已经用了cnt个1
num: 计划 总共 用num个1
limit: 枚举的数的上一位是否与n的相应的位相同
*/
    if(pos==-1)
        return cnt==num;//需要判断是否达到了要求的若干的1
    if(!limit && dp[pos][num][cnt]!=-1)
        return dp[pos][num][cnt];
//如果枚举的上一位没有达到n中的对应的位，
//则可以调用之前的计算结果
    int up=limit?a[pos]:1; ll ans=0;
    for(int i=0;i<=up;++i)
        ans+=dfs(pos-1,cnt+(i==1),num,limit&&(i==a[pos]));
    if(!limit)
    	dp[pos][num][cnt]=ans;//记忆化
    return ans;
}
```

同时，我们需要用快速幂求出上文中说的“x的j次方”。

```cpp
inline ll qPow(ll x,ll y){//位运算优化快速幂
    ll r=1;
    while(y){
        if(y&1) r=r*x%m;
        x=x*x%m; y>>=1;
    }
    return r;
}
```

下附完整代码

```cpp
// luogu-judger-enable-o2
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <cstdlib>
using namespace std;
typedef long long ll;
ll dp[51][51][51];//10^15的二进制大概有50位
int a[51];//n的二进制分解
const int m=10000007;

inline ll qPow(ll x,ll y){
    ll r=1;
    while(y){
        if(y&1) r=r*x%m;
        x=x*x%m; y>>=1;
    }
    return r;
}

ll dfs(int pos,int cnt,int num,bool limit){
    if(pos==-1)
        return cnt==num;
    if(!limit && dp[pos][num][cnt]!=-1)
        return dp[pos][num][cnt];
    int up=limit?a[pos]:1; ll ans=0;
    for(int i=0;i<=up;++i)
        ans+=dfs(pos-1,cnt+(i==1),num,limit&&(i==a[pos]));
    if(!limit)
    	dp[pos][num][cnt]=ans;
    return ans;
}

ll solve(ll n){
    int len=0;
    while(n){//先将n分解出来
        a[len++]=n&1; n>>=1;
    }
    ll ans=1;
    for(int i=1;i<=len;++i){//枚举的1的个数不可能超过n的位数
        memset(dp,-1,sizeof(dp));
        ans=ans*qPow(i,dfs(len-1,0,i,1))%m;
    }
    return ans;
}

int main(){//简洁的主程序
    ll n;
    scanf("%lld",&n);
    printf("%lld\n",solve(n));
    return 0;
}
```

本题解法可能不止以上一种，在此蒟蒻仅提供个人的解法。

---

## 作者：asuldb (赞：14)

定义$sum(i)$表示$i$在二进制下$1$的个数

求$\prod_{i=1}^{n}sum(i)$

暴力非常$sb$显然可以随便写，但是显然也是会$T$

于是我们换个思路

我们设$tot$表示$sum(i)=x$的$i$有多少个，于是答案就是$x^{tot}$

我们枚举$x$就行了，$x$显然不会很大，也就是$log_2{n}$

之后就可以开始数位$dp$了

我们设$dp[i][0/1][j]$表示最高位填到第$i$位，其中最高位填$0/1$，一共填了$j$个1一共有多少个数

方程很显然，就是往最高位上填$0/1$

填0的话

$$dp[i+1][0][j]+=dp[i][1][j]+dp[i][0][j]$$

填1的话

$$dp[i+1][1][j+1]+=dp[i][0][j]+dp[i][1][j]$$

之后我们按照数位$dp$的套路来做就行了

代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define LL long long 
#define re register
#define maxn 55
const LL mod=10000007;
const LL P=9988440;
LL n;
int a[maxn];
LL dp[maxn][2][maxn];
inline LL quick(LL a,LL b)
{
	LL S=1;
	while(b)
	{
		if(b&1) S=S*a%mod;
		b>>=1ll;
		a=a*a%mod;
	}
	return S;
}
inline LL sum(LL x)
{
	LL cnt=0;
	while(x)
	{
		if(x&1ll) cnt++;
		x>>=1ll;
	}
	return cnt;
}
inline LL slove(LL x)
{
	int num=0;
	while(x)
	{
		++num;
		if(x&1ll) a[num]=1;
		x>>=1ll;
	}//分解数位
	dp[1][1][1]=1;
	dp[1][0][0]=1;
	for(re int i=1;i<num;i++)
		for(re int j=0;j<=i;j++)
		{
			dp[i+1][1][j+1]=(dp[i+1][1][j+1]+dp[i][0][j]+dp[i][1][j]);
			dp[i+1][0][j]=(dp[i+1][0][j]+dp[i][0][j]+dp[i][1][j]);
		}//dp的过程
	LL ans=1;
	for(re int T=1;T<=num;T++)//枚举T求出有多少i，sum(i)=T
	{
		for(re int i=1;i<num;i++)
			ans=(ans*quick(T,dp[i][1][T])%mod)%mod;
        //先枚举位数比n要小的
		int k=T;
		if(a[num]) k--;
		for(re int i=num-1;i>=1;i--)//之后我们卡前面的[i+1,num]为完全相等，让第i位小于n的第i位，我们就可以让后面的位数随便填了
		{
			for(re int j=0;j<a[i];j++)
				ans=(ans*quick(T,dp[i][j][k])%mod)%mod;
			if(a[i]) k--;//别忘了保证前面的数位相等，要减去前面1的个数
			if(k<0) break;
		}
	}
	return ans;
    //由于一直在卡上界，但最后也没有卡到等于n的情况，于是n的暴力分解数位处理一下就好了
}
int main()
{
	scanf("%lld",&n);
	std::cout<<sum(n)*slove(n)%mod;
	return 0;
}
```

---

## 作者：Jμdge (赞：11)

怎么就没人好好的用组合数水的呢？

[the blog](https://www.cnblogs.com/Judge/p/9540939.html)

思路清晰啊，处理有 1 的位，答案直接快速幂算

```cpp
//by Judge
#include<iostream>
#include<cstdio>
#define ll long long
using namespace std;
const int M=55;
const ll mod=1e7+7;
ll n,len,cnt,ans=1;
ll C[M][M],d[M],num[M];
inline void prep(){  //预处理组合数模板？ 
	for(int i=0;i<=50;++i) C[i][0]=1;
	for(int i=1,j;i<=50;++i) for(j=1;j<=50;++j)
		C[i][j]=C[i-1][j]+C[i-1][j-1];
}
inline ll quick_pow(ll x,ll p,ll ans=1){  //快速幂模板？
	while(p){
		if(p&1) ans=ans*x%mod;
		x=x*x%mod, p>>=1;
	} return ans;
}
signed main(){
	cin>>n,prep();
	while(n) d[++len]=n&1,n>>=1;//转化二进制
	for(ll i=len,j;i;--i) if(d[i]){
		for(j=1;j<i;++j) //组合数就是随便乱搞的算法
			num[cnt+j]+=C[i-1][j];
		++num[++cnt]; //然后要累加自身
	}
	for(ll i=1;i<=len;++i) //直接累乘就好
		ans=ans*quick_pow(i,num[i])%mod;
	cout<<ans<<endl; return 0;
}
```

---

## 作者：CKnight (赞：7)

发一个纯数学解法，想法是通过组合数算出小于等于n的所有sum(i)出现的次数。

对于n找到它的二进制下的最高位的位数p，然后就可以计算一波当二进制位p为0时的i对于ans的贡献，此时添加一个计数器，记录我们已经找过的位数。

即$ans=ans*\sum ^{p} _{i=0} (i+t)^{C ^{i} _{p}}\bmod10000007$，t即为计数器，i表示在当前p位中有几位是1。

但是 $C ^{i} _{p}$ 会很大，这时需要我们用欧拉定理来解决这个问题：

## $ a ^{\phi{p}} \equiv 1 \pmod{p} $

注意到10000007不是质数，所以需要将它的欧拉函数值求出来。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define mod 10000007

ll n,ans,c[61][61];

inline ll F(ll x){
    return x>=mod?x-mod:x;
}

inline ll qsm(ll x,ll t){
    ll res=1;
    while(t){
	if(t&1)res=res*x%mod;
	x=x*x%mod;t>>=1;
    }return res;
}

inline void init(){

    for(ll i=0;i<=60;++i)c[i][0]=1;
    for(ll i=1;i<=60;++i)
	for(ll j=1;j<=i;++j)
	    c[i][j]=(c[i-1][j-1]+c[i-1][j])%9988440;
    
}

int main()
{

#ifndef ONLINE_JUDGE
    freopen("a.in","r",stdin);
#endif

    scanf("%lld",&n);
    init();ans=1;ll t=0;
    for(ll i=60;i>=0;--i){
	if(!((n>>i)&1))continue;
	for(ll j=0;j<=i;++j)
	    if(j+t)ans=ans*qsm(j+t,c[i][j])%mod;
	++t;
    }printf("%lld\n",ans*t%mod);//注意最后要将n自己的位数乘上去
    return 0;
    
}

```

---

## 作者：JasonL (赞：6)

### **本蒟蒻第一次发题解还请各位大佬多指正**


------------


我解题的时候是这样想的：

~~（其实是本人不怎么会dp，写了一下午没写出来）~~

题目求sum（1）~sum（N）的乘积

以**N=40**为例子吧，此时N的二进制表示为

**101000**

当最高位不为1时，其他位0或1都可以取

**101000**   ->   **0XXXXX** 

其中X表示0或1

于是在1~2^k-1之间有s位为1的个数转化为
### 在余下k-1个‘X’里取s位为1，有多少种不一样的取法


于是我们想到**组合数**

那么最高位为1的时候呢？

我们找到次高的为1的位,模仿上述操作

**101000**   ->  **100XXX**

为什么我们要跳过中间的0呢？

因为当最高位为1时，这个0不可能变为1，否则这个值就会大于N。

我们惊奇的发现这仍然可以用**组合数**！

当然在统计的时候要注意之前已经有一位是1了（即最高位），要将取s位算得的组合数算进（s+1）位里。

统计完我们将其变为1，继续往下搜索,发现没有1了

**101000**->**101000**

这时我们要注意把n的位数为1的个数，即sum（n）加上。因为在之前的统计中我们没有把n算进去。

## 于是，杨辉三角+快速幂，27ms

```cpp
#include<iostream>
#include<cstring>
#define MAXN 70
#define mod 10000007
using namespace std;
long long fpow(long long a,long long b){	//快速幂 
	long long tmp=1;
    while(b)
    {
        if(b&1) tmp=tmp*a%mod;
        a=a*a%mod;
        b>>=1;
    }
    return tmp%mod;
}
int main()
{
	long long n;
	cin>>n;
	long long f[MAXN][MAXN];
	memset(f,0,sizeof(f));
	int length;
	//求最高位 
	for(length=0;(n>>length)>0;length++);
	length--;
	//杨辉三角 初始化（我们只统计到最高位，即length） 
	f[0][0]=1;
	for(int i=1;i<=length;i++){
		f[i][0]=1;
		for(int j=1;j<=i;j++)
			f[i][j]=f[i-1][j-1]+f[i-1][j];
	}
	int cnt=1;									
	//cnt统计已经读过的1的个数（这里我们由于直接跳过最高位，用最高位直接统计答案，所以cnt初始为1） 
	for(int i=length-1;i>=0;i--){
		if((n>>i)&1){
			for(int j=0;j<=MAXN;j++){ 
				f[length][j+cnt]+=f[i][j];		
				//注意：1的个数=取s位的1的个数+已重新变为1的个数（所以从0开始搜）
				} 
			cnt++; 
		}
	}
	f[length][cnt]++;
	//计算答案
	long long ans=1;
	for(long long i=2;i<=MAXN;i++){			//这里i从2开始计算（因为1对答案没有贡献） 
		long long k=fpow(i,f[length][i]);	//快速幂计算 （为了简明我分拆了步骤） 
		ans=(ans*k)%mod;
	}
	cout<<ans<<endl; 
	return 0;
}
```

~~（再一次证明了作者是蒟蒻）~~

---

## 作者：Mosher (赞：6)

## 正如标题所说可以是数论，but是道数位DP，QwQ

#### why？

```cpp
由于转二进制，且对于1的个数统计

应该能意识到跟：数位有关吧？

（然后就是道水题啦，QAQ）

（即使我是看数位DP专题，找到的题QwQ，我太蒟蒻了）

（其实我记得STL库里不是有哪个函数可以统计二进制的1或0的个数吗？

也许我记错了？没记错的话，麻烦dalao告知，QAQ）
```

#### 正文:

1. 想必都会转二进制吧？（那我就水过去咯？QwQ）

2. 思路：
        
   既然是统计1的个数，那么必然由小->大，小的来推向大的个数；
        
   那这就为我们提供了DP方程或记忆化的可行性方式
   
   即：
   
   定义  当前数位以前的1的个数——>Fir：当前是1，个数+1，Sen：当前为0，个数不变

   那么 dp转移方程，记忆化搜索的状态 都出来了QwQ 
3. Code：（没打dp方程，很简单，~~逃~~）

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll mod=10000007;
ll n,dp[50][50],num[50];

ll dfs(int pos,bool limit,ll sum){//模板
    ll ans=1;//因为要乘，所以赋1（如果你没想明白，那就赋0，你会恍然大悟的）
    if(!pos) return max(1ll,sum);//理由同上
    if(!limit&&dp[pos][sum]!=-1) return dp[pos][sum];
    int up=limit ? num[pos]:1;
    for(int i=0;i<=up;++i)
       (ans*=dfs(pos-1,limit&&i==up,sum+i))%=mod;//这里直接是：sum+i，因为i==1 ？ 1：0；（就是这样，错误写法，就省点码量，以及括号，不喜轻喷QAQ）
    if(!limit) dp[pos][sum]=ans;
    return ans;
}

ll work(ll x){
    int len=0;
    memset(dp,-1,sizeof(dp));
    while(x){
        num[++len]=x&1;//转二进制
        x>>=1;
    }
    return dfs(len,1,0);
}

int main(){
    scanf("%lld",&n);
    printf("%lld",work(n));
}
```

rp++

从：数字统计 过来，自然反应，还是好理解的（没明白，私信私信QWQ）

---

## 作者：TLE_Automat (赞：4)

[题目传送门](https://www.luogu.com.cn/problem/P4317)

最近疯狂刷数位DP的题，但没有写篇题解纪念，于是就找了这道还可以的数位DP的题来刷一点社区贡献。

进入正题。。。我觉得这道题是比较不同于数位DP的模板题的，因为大部分模板都是给你一个 $l,r$ ，让你求 $[l,r]$ 内有多少个满足条件的数，而这题的题干好像很不一样的鸭子。所以我们需要转化一下：

- 首先通过看数据范围可以发现 $n\le10^{15}$ ,说明 $n$ 不爆 $longlong$，这说明 $n$ 的二进制位数在 $64$ 以内，所以对于任意 $sum[i]\le64$ 恒成立。（其实到不了 $64$ ，因为 $10^{15}$ 离 $longlong$ 的最大值还差很远）

- 所以我们可以枚举 $1$ 的个数 $i$，然后通过**数位DP**算出 $n$ 以内的二进制数中具有 $i$ 个 $1$ 的二进制数的个数 $cnt[i]$。然后我们的答案就是 $\prod\limits_{i=1}^{64}i^{cnt[i]}$ 。

- 哎哎哎，先别急着看代码，这行不看绝对后悔，算 $cnt[i]$ 的时候一定不要乱 $\operatorname{mod}$ ，因为指数是不能取模的，否则亲测只有 $50pts$ 。

知道你们最想看的是这个：(上面讲的很清楚了，代码就不注释了)

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int mod=10000007;
ll n;
ll f[65][65][2];
ll ans=1;
int len=51;
char s[65];

inline ll power(ll a,ll b)
{
    ll res=1;
    while(b)
    {
        if(b&1ll)
        {
            res*=a;
            res%=mod;
        }
        a*=a;
        a%=mod;
        b>>=1;
    }
    return res;
}

inline ll dfs(int pos,int sum,bool limit)
{
    if(pos>len)
    {
        if(sum==0) return 1;
        return 0;
    }
    if(f[pos][sum][limit]!=-1) return f[pos][sum][limit];
    int v=(limit ? s[pos]-'0' : 1);
    ll res=0;
    for(int i=0;i<=v;i++)
    {
        if(i==1)
        {
            if(!sum) continue;
            else res+=dfs(pos+1,sum-1,limit&(i==v));
        }
        else res+=dfs(pos+1,sum,limit&(i==v));
    }
    return f[pos][sum][limit]=res;
}

ll work(int sum)
{
    memset(f,-1,sizeof(f));
    return dfs(1,sum,1);
}

int main()
{
    scanf("%lld",&n);
    for(int i=50;i>=0;i--)
    {
        if((n>>i)&1ll)
            s[50-i+1]=(1+'0');
        else
            s[50-i+1]=(0+'0');
    }
    for(int i=1;i<=50;i++)
    {
        ans*=power(i,work(i));
        ans%=mod;
    }
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：tommymio (赞：3)

这题楼下dalao都说什么数位DP统计方案数，然后用快速幂统计答案，其实有一个最纯粹的暴力的方法，设 $f_{i,j}$ 为满足前 $i$ 位中 $1$ 的个数不超过 $j$ 的所有整数 $x$ 的$sum(x)$ 的积，可以使用记忆化搜索实现。

于是就是套路数位DP了，看不懂的的可以去看看ZJOI2010的那道数位DP。

~~（**其实就是那道题把转移过程中的 $+$ 换成了$*$ 而已，按这种容易的做法来看，这题不过蓝题**~~

**Show the Code**

```cpp
#include<cstdio>
#include<cstring>
#define max(a,b) ((a)>(b)? (a):(b))
typedef long long ll;
const ll mod=1e7+7;
int top=0;
ll f[105][105];
int st[105];
ll dfs(int len,int cnt,int lead,int lim) {
	if(len>top) return cnt;
	if(!lim&&f[len][cnt]!=-1) return f[len][cnt];
	ll ans=1;
	int x=lim? st[top-len+1]:1;
	for(register int i=0;i<=x;++i) {ll tmp=dfs(len+1,cnt+(!(lead&&!i)&&i==1),(lead&&(!i)),(lim&&(i==x)));ans=ans*max(1,tmp)%mod;}
	if(!lim&&!lead) f[len][cnt]=ans;
	return ans; 
}
ll calc(ll n) {//2~top+1
	while(n) {st[++top]=n&1;n>>=1;}
	memset(f,-1,sizeof(f));
	return dfs(1,0,1,1);
}
int main() {
	ll n;
	scanf("%d",&n);
	printf("%lld\n",calc(n));
	return 0;
}
```
别尝试直接交我代码，不然你会因为一些玄学错误而**WA**掉。

代码中的前导 $0$ 的判断是可以去掉的，因为前导 $0$ 对答案没有影响。



---

## 作者：Plus_Ultra (赞：3)

### 题解：

1. 前言： 

- 数位DP是与数字相关的一类计数问题.这类问题通常都是给你几个限制和寻找范围，求满足限制的数的个数有多少.

- 面对这类问题，我们首先想到爆搜.不用想，肯定爆炸.于是乎我们来考虑优化方法.很容易可以想到：记忆化搜索！

- 不过并没有那么简单.有诸多限制，比如说搜索不能超过给定区间的范围，不能有前导0等等，这时我们就需要仔细考虑了.

- 我们尝试在记忆化搜索中记录这些限制，考虑如何转移即可.（尽可能把状态都记录下来）

2. 可以发现，像这类计数型问题，都是可以套模板的.我们先来分析一下模板.

- [博客食用口感更好哟](https://www.luogu.org/blogAdmin/article/edit/167531)

```
int DFS(int len,int limit,int lead,int ...各种限制)//len表示填数到了第几位,limit表示有无上界限制,lead表示有无前导0 
{
    if(len==0)return 1;//边界条件 
    if(!limit&&!lead&&dp[len][...]!=-1)//如果搜过并且没有上界限制和前导0,这一位可以随便填 
    return dp[len][...];//记忆化搜索 
    int maxx=limit?num[len]:9;//如果前一位有限制（填到了最高位）那么这一位不能超过num这一位的大小，否则0~9随便取 
    int res=0; 
    for(int i=0;i<=maxx;i++)
    {
        if(...)//限制条件 
        res+=DFS(len-1,limit&&(i==maxx),lead&&!i,...);//如果本位已经枚举到上界就把上界往后传,上一位有前导0而且这一位是0，那么下一位有前导0 
    } 
    if(!limit&&!lead)dp[len][...]=res;//因为如果枚举到上限则答案并不是这一位上所有的和，所以就不更新
	//着重分析这一句话：当有前导0或有上界限制时,下一位有不能填的数，而dp数组记录的是下一位能填0~9的数，所以不更新. 
    return res; 
}

int solve(int x)
{
    int len=0;//位数 
    while(x)//这里是预处理出每一位数的上界 
    {
        num[++len]=x%10;
        x=x/10;
    }
    return DFS(len,1,1,...);//有前导0和上界限制 
} 
int main()
{
    cin>>a>>b;
    cout<<solve(b)-solve(a-1)<<endl;//可以先求1~b中满足限制的个数，再求1~a-1中满足限制的数的个数，相减即可 
} 
```

有了模板之后，就不慌了.剩下处理一下小问题，套模板即可. 

3. 具体解法：

- 我们枚举要填的1的个数总和Sum，DFS出满足二进制下1的个数之和等于Sum的数的个数，最后快速幂计算即可.

4. 上代码（其实我知道各位大佬也不需要代码）：


```
#include<iostream>
#include<cstring>

#define LL long long
#define mod 10000007

using namespace std;

LL n,dp[51][51],a,b,num[51],lent,Sum,ans[51],res=1;//记住：数组要开到51及以上，我开到50就WA了 

LL pow(LL a,LL b)//快速幂 
{
	LL ret=1;
	while(b)
	{
		if(b&1)  ret=(ret*a)%mod;
		a=(a*a)%mod;
		b>>=1;
	}
	return ret;
}

LL DFS(int len,int sum,int limit)//分别表示位数，填了几个1，有没有上界限制 
{
	if(!len)  return sum==Sum;//是否填够要填的1的个数 
	if(dp[len][sum]!=-1&&!limit)  return dp[len][sum];//记忆化搜索 
	LL res=0,maxx=limit?num[len]:1;//上界处理 
	for(int i=0;i<=maxx;i++)
	res+=DFS(len-1,sum+(i==1),limit&&(i==maxx));//搜索下一位 
	return limit?res:dp[len][sum]=res;//没有上界限制就记忆化一下 
}

void solve()
{
	while(n)//处理上界限制，因为是二进制数，所以略有不同 
	{
		num[++lent]=n&1;
		n>>=1;
	}
	for(Sum=1;Sum<=lent;Sum++)//枚举要填的1的个数 
	memset(dp,-1,sizeof(dp)),ans[Sum]=DFS(lent,0,1);//记录要填Sum个1时满足要求的数的个数 
	for(int i=1;i<=lent;i++)  res=(res*pow(i,ans[i]))%mod;//计算总乘积 
	cout<<res<<endl;
}

int main()
{
	cin>>n;solve(); 
		
	return 0;
} 
```

去掉空行后40来行，也是比较短的了.

### [Plus Ultra!!!](https://www.luogu.org/blog/OnePunchManGO/)


---

## 作者：撤云 (赞：3)

[博客](https://www.cnblogs.com/hbxblog/p/10223410.html)
### Title Link
[戳我](https://www.luogu.org/problemnew/show/P4317)

### Title Solution
这道题可以运用组合数的思想啊，数位dp也可以，随便你怎么做，这里就讲一讲组合数的做法吧,要小于n，所以我们可以枚举n二进制下1的位置，在i-1后面选j个1.用组合数做一下就好了啊
### code
``` cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=10000007;
int c[1011][1011],f[101];
int read(){
    int x=0,f=1;char c=getchar();
    while(c<'0'||c>'9')  f=(c=='-')?-1:1,c=getchar();
    while(c>='0'&&c<='9')  x=x*10+c-'0',c=getchar();
    return x*f;
}
void init(){
    for(int i=0;i<=1000;i++)
        c[i][i]=c[i][0]=1;
    for(int i=2;i<=1000;i++)
        for(int j=1;j<i;j++)
            c[i][j]=c[i-1][j]+c[i-1][j-1];
}
int ksm(int a,int b){
    int ans=1;
    while(b){
        if(b&1)
            ans=ans*a%mod;
        a=a*a%mod;
        b>>=1;
    }
    return ans;
}
main(){
    int n=read(),ans=1,js=0;
    init();
    for(int i=50;i>=0;i--){
        if((n>>i)&1){
            for(int j=1;j<=i;j++)
                f[js+j]+=c[i][j];
            f[++js]++;
        }
    }
    for(int i=1;i<=50;i++)
        ans*=ksm(i,f[i]),ans%=mod;
    printf("%lld",ans);
}


```





---

## 作者：wzhy (赞：3)

**题目**

设 sum(i) 表示 i 的二进制表示中 1 的个数。给出一个正整数 N ，花神要问你 派(Sum(i)),也就是 sum(1)—sum(N) 的乘积（n<=1e15）。

**分析**

好吧，一看数据范围及可知暴力不可做~~我是不会说我打了一次暴力得了50分的~~，看一下所求的答案，恶心，仔细观察后觉得是一道数位DP，可先将n换做二进制，在每一位每一位的分析，若为0则跳过，若为1则处理一番，在处理时可先脚动模拟一番，发现和杨辉三角略有联系，故先处理处杨辉三角，最终出答案（代码里都有体现），时间是： 0ms。

上代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long al[60],bl[60],f[60][60],x[60],y[60],m=0,a,b,k=1,n,mod=10000007,ans=1,qaq[60][60];
long long power(long long a,long long b){
    if(b==0)
        return 1;
    if(b==1)
        return a;
    return b%2==0?power(a*a%mod,b/2)%mod:a*power(a*a%mod,b/2)%mod;
}
int main(){
    memset(al,0,sizeof(al));
    memset(f,0,sizeof(f));
    memset(bl,0,sizeof(bl));
    memset(x,0,sizeof(x));
    memset(y,0,sizeof(y));
    memset(qaq,0,sizeof(qaq));
    for(int i=1;i<=60;i++)
    	f[i][1]=f[i][i]=1;
    for(int i=2;i<=60;i++)
        for(int j=2;j<i;j++)
            f[i][j]=f[i-1][j-1]+f[i-1][j];
    for(int i=1;i<=60;i++)
        for(int j=1;j<=i;j++)
            qaq[i][j]=qaq[i-1][j]+f[i][j];
    for(int i=1;i<=60;i++)
        qaq[i][1]++;
    scanf("%lld",&b);
    qaq[0][1]=1;
    if(b%2==1)
        al[1]=1;
    while(b>1){
        b/=2;
        k++;
        if(b%2==1)
            al[k]=1;
    }
    for(int i=k;i>0;i--)
        if(al[i]){
            long long anss=1;
            for(int j=1;j<=i;j++){
            	anss=anss*power(j+m,qaq[i-1][j])%mod;
            }
            ans=ans*anss%mod;
            m++;
        }
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：JustinRochester (赞：2)

可能跟某位大佬有点类似，不过我的应该跑得比他快那么一点点......虽然应该没什么关系......

---

**【分析】**
--

假设一个对于一个数 $N$ ,最高位为第 $n$ 位

那么，显然有 $2^n \leq N \leq 2^{n+1}-1$

(即第一位一定为 $1$ ，后面可能 $1$ ，可能 $0$)

因此，对于这个数 $N$ ,我们不能直接拿 $C_n^m$ 来算

那么我们可以这样考虑，最高位为 $n$ ,那么，对于后面的 $(n-1)$ 为一定是可 $1$ 可 $0$ 。

因此，假设后面有 $i$ 个 $1$ ，故根据排列组合，有 $C_{n-1}^i$ 个 $i$，因此它对答案的贡献是 $i^{C_{n-1}^i}$

同理，类推出来，$0$~$2^n-1$ 这些数对答案的贡献就是 $\Pi_{i=1}^{n-1} i^{{C_{n-1}^i}}$

那么我们现在将第 $n$ 位固定为 $1$ ,假设第二个 $1$ 为第 $m$ 位

同样的，它后面的 $(m-1)$ 为一定可 $1$ 可 $0$ ，因此同上考虑后 $(m-1)$ 位有 $i$ 个 $1$，加上前面那个 $1$ 共$(i+1)$ 个 $i$ ，故贡献为 $(i+1)^{C_{m-1}^i}$

因此这个 $1$ 对答案的贡献为 $\Pi_{i=1}^{m-1} (i+1)^{C_{m-1}^i}$

如上考虑，每个 $1$ ,假设是第 $Cnt$ 个 $1$，在第 $Cal$ 位，对答案的贡献就是  $\Pi_{i=1}^{Cal-1} (i+Cnt)^{C_{Cal-1}^i}$

把它们都乘起来即可

得到 $(N-1)$ 的答案(LRJ：想一想，为什么？)

所以直接读入的时候 $N$ 给它 $+1$ 即可

当然，这边还有一个问题(假装你们都懂得要取模和快速幂)：

$C_{n-1}^i$ 可能会极大无比

这边考虑欧拉公式：$a^{\varphi(p)} \equiv 1(mod$ $p)$

且 $\varphi(10000007)=9988440$

因此，我们在算排列数的时候记得对这个数取模即可

剩下的一些细节就直接看本蒟蒻的代码吧

---

**【代码】**

那本蒟蒻就放代码了

````cpp#include<cstdio>
using namespace std;
#define f(a,b,c) for(register int a=b;a<=c;a++)
#define g(a,b,c) for(register int a=b;a>=c;a--)
#define Max(a,b) ((a>b)?a:b)
#define Min(a,b) ((a<b)?a:b)
#define File(s) freopen(s".in","r",stdin);freopen(s".out","w",stdout)
typedef long long int ll;
typedef unsigned long long int ull;
const int MAXN=100010;
const int Mod=10000007;
const int Phi=9988440;
inline ll read(){
    register ll ans=0;register char c=getchar();register bool neg=0;
    while((c<'0')|(c>'9')) neg^=!(c^'-'),c=getchar();
    while((c>='0')&(c<='9')) ans=(ans<<3)+(ans<<1)+(c^48),c=getchar();
    return neg?-ans:ans;
}
ll N,Cnt=0,C[64][64],Ans=1;
int LOG(ll n){ return (n==1)?0:(LOG(n>>1)+1); }
void pre(){
	N=read()+1;
	int n=LOG(N);
	f(i,0,n){
		C[i][i]=C[i][0]=1;
		g(j,i-1,1) C[i][j]=C[i-1][j]+C[i-1][j-1],C[i][j]-=(C[i][j]>=Phi)?Phi:0;
	}
}
int pow(int i,int a){
	if(a==0) return 1; if(a==1) return i;
	ll tmp=pow(i,a>>1);
	tmp=tmp*tmp%Mod*((a&1)?i:1)%Mod;
	return tmp;
}
int main(){
	pre();
	while(N){
		ll Cal=LOG(N);
		if(Cnt) Ans*=Cnt,Ans%=Mod;
		f(i,1,Cal) Ans*=pow(i+Cnt,C[Cal][i]),Ans%=Mod;
		Cnt++;
		N-=(1ll<<Cal);
	}
	printf("%d",Ans);
	return 0;
}
```

---

## 作者：ShineEternal (赞：2)

[如有内容缺失请阅读这里](https://blog.csdn.net/kkkksc03/article/details/101972027)

## description：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191003073859430.png)

## solution:

$g[i]表示二进制下有i个1时的方案数$

则答案为

$$\prod i^{G[i]}$$

然后别忘了用快速幂，因为$g[i]$会很大
 

## code:
```cpp
#include<cstdio>
using namespace std;
long long quick(long long x,long long y)
{
	long long r=1;
	while(y)
	{
		if(y&1)
		{
			r=r*x%10000007;
		}
		x=x*x%10000007;
		y=y/2;
	}
	return r;
}
long long g[105];
int main()
{
	long long n;
	long long cnt=0;
	scanf("%lld",&n);
	for(long long i=49;~i;i--)
	{
		for(long long j=49;j;j--)
		{
			g[j]+=g[j-1];
		}
		if(n>>i&1)
		{
			++g[cnt++];
		}
	}
	++g[cnt];
	long long ans=1;
	for(long long i=1;i<=49;i++)
	{
		ans=(ans*quick(i,g[i]))%10000007;
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：Biscuit46 (赞：1)

突然发现这道题目完全不需要什么数位dp,然后可以用组合数乱搞?
这样子感觉可以比较快的解决.
考虑令$sum_i=k$然后算一个个数再快速幂解决就好了.
```cpp
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<math.h>
#include<algorithm>
#include<queue>
#include<set>
#include<map>
#include<iostream>
using namespace std;
#define ll long long
#define re register
#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)
inline int gi(){
	int f=1,sum=0;char ch=getchar();
	while(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0' && ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}
	return f*sum;
}
ll n,ts,c[120][120],ans[120];
int ws;
const ll Mod=10000007;
ll C(int n,int m){
	if(n<0 || m<0)return 0;
	if(n<m)return 0;
	return c[n][m];
}
ll qpow(ll a,ll b){ll ret=1;while(b){if(b&1)ret=(ret*a)%Mod;b>>=1;a=(a*a)%Mod;}return ret;}
void Add(ll &x,ll y){x+=y;}
int main(){
	scanf("%lld",&n);
	ts=n;int ws=0;
	while(ts){
		ts>>=1ll;ws++;
	}
	for(int i=0;i<=ws+10;i++){
		c[i][0]=c[i][i]=1;
		for(int j=1;j<i;j++)
			c[i][j]=c[i-1][j]+c[i-1][j-1];
	}
	for(int i=1;i<=ws;i++){
		for(int j=i;j<ws;j++)
			Add(ans[i],C(j-1,i-1));
		int one=0;
		for(int k=ws;k>=1;k--){//前ws-k+1位相同
			if(n&(1ll<<(k-1)))one++;
			if(n&(1ll<<(k-2)))Add(ans[i],C(k-2,i-one));
		}
	}
	ts=n;int p=0;
	while(ts){if(ts&1ll)p++;ts>>=1;}
	ans[p]++;ll reans=1;
	for(int i=1;i<=ws;i++)reans=(reans*qpow(i,ans[i]))%Mod;
	printf("%lld\n",reans);
	return 0;
}
```

---


# 「CZOI-R1」三角形与树

## 题目背景

CaiZi 讨厌三角形，但是他喜欢树。

2024.8.15 Update：增加了一组 hack 数据。

## 题目描述

给定一颗有 $n$ 个点的树，节点编号为 $1\sim n$，每个点有点权，开始时点 $i$ 的点权为 $a_i$。共有 $q$ 次操作。
1. 将点 $x$ 到点 $y$ 的简单路径上的点的点权**异或** $k$。
1. 判断能否在点 $x$ 到点 $y$ 的简单路径上选 $3$ 个**不同点**，并以这 $3$ 个点的点权为边长构成**三角形**。特别的，如果无法选出 $3$ 个点，也视为不能构成**三角形**。

点 $x$ 到点 $y$ 的简单路径：点 $x$ 到点 $y$ 不重复走过任何一条边的路径。其上的所有点为这条路径上所有的点，**包括**点 $x$ 和点 $y$。

**保证任何时刻不会有任何一个点的点权为 $0$。**

## 说明/提示

**【样例解释】**

第 $1$ 次操作时简单路径上的点权少于 $3$ 个。  
第 $2$ 次操作时简单路径上的点权分别为 $1,2,3,4$。  
第 $3$ 次操作后点 $1\sim n$ 的点权分别为 $5,6,7,4,1$。  
第 $4$ 次操作时简单路径上的点权分别为 $5,6,7$。  
第 $5$ 次操作时简单路径上的点权分别为 $1,5,6$。

**【数据范围】**

**本题采用捆绑测试**。
- Subtask #1（$8\text{ pts}$）：$n,q\le3\times10^3$。
- Subtask #2（$8\text{ pts}$）：保证这棵树是一朵菊花。
- Subtask #3（$20\text{ pts}$）：每次修改操作时 $x=y$。
- Subtask #4（$24\text{ pts}$）：保证这棵树是一条链。
- Subtask #5（$40\text{ pts}$）：无特殊性质。**依赖 Subtask #1 到 Subtask #4。**

对于 $100\%$ 的数据，$1\le u,v\le n\le10^5$，$1\le q\le10^5$，$s\in\{1,2\}$，$1\le a_i,w\le 2^{31}-1$。

## 样例 #1

### 输入

```
5 5
1 2 3 4 5
1 2
1 3
2 4
2 5
2 1 2
2 3 4
1 3 5 4
2 2 3
2 1 5```

### 输出

```
0110```

# 题解

## 作者：Register_int (赞：16)

先考虑不在树上咋做。先给序列排序，然后一个一个判是否有 $a_{i-1}+a_i>a_{i+1}$。  
如果不满足要求的话，那么对于所有 $1<i<n$ 都有 $a_{i-1}+a_i\le a_{i+1}$。最小情况下 $a_{i+1}=a_i+a_{i-1}$，$a_1=a_2=1$。此时 $a_i=f_i$。但是你会发现 $f_{46}>2^{31}-1$，也就是说 $n\ge46$ 就必定有解，非常 amazing 啊！只要对 $<46$ 的区间暴力即可。  
回到原题，查询只要先判路径长度再暴力跳即可。这部分是简单的，压力给到链异或单点查询。  
容易发现，每次修改都能拆成四次到根链的修改。具体地，设 $k=\operatorname{lca}(u,v)$，则 $u\to v$ 异或上 $w$ 相当于 $1\to u,1\to v,1\to k,1\to fa_k$ 异或上 $w$。但还是不好看，继续差分一下就能变成单点异或子树查，在 dfn 上建个树状数组即可。时间复杂度 $O(n\log n+m\log n + mC\log C)$，其中 $C=46$。

# AC 代码
```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int MAXN = 1e5 + 10;

vector<int> g[MAXN];

int n, a[MAXN], dep[MAXN], fa[20][MAXN];

int c[MAXN], in[MAXN], out[MAXN], id;

void init(int u, int f) {
	fa[0][u] = f, dep[u] = dep[f] + 1, in[u] = ++id, a[f] ^= a[u];
	for (int i = 1; i <= __lg(dep[u]); i++) fa[i][u] = fa[i - 1][fa[i - 1][u]];
	for (int v : g[u]) if (v != f) init(v, u); out[u] = id;
}

inline 
void add(int u, int x) {
	for (int i = in[u]; i <= n; i += i & -i) c[i] ^= x;
}

inline 
int ask(int u) {
	int res = 0;
	for (int i = out[u]; i; i &= i - 1) res ^= c[i];
	for (int i = in[u] - 1; i; i &= i - 1) res ^= c[i];
	return res;
}

inline 
int lca(int u, int v) {
	if (dep[u] < dep[v]) swap(u, v);
	for (; dep[u] > dep[v]; u = fa[__lg(dep[u] - dep[v])][u]);
	if (u == v) return u;
	for (int i = __lg(dep[u]); ~i; i--) {
		if (fa[i][u] != fa[i][v]) u = fa[i][u], v = fa[i][v];
	}
	return fa[0][u];
}

inline 
vector<int> get(int u, int v) {
	vector<int> d;
	if (dep[u] < dep[v]) swap(u, v);
	for (; dep[u] > dep[v]; d.emplace_back(ask(u)), u = fa[0][u]);
	for (; u != v; ) {
		d.emplace_back(ask(u)), u = fa[0][u];
		d.emplace_back(ask(v)), v = fa[0][v];
	}
	return d.emplace_back(ask(u)), d;
}

inline 
bool check(vector<int> d) {
	sort(d.begin(), d.end()); int m = d.size();
	for (int i = 1; i < m - 1; i++) {
		if (d[i - 1] > d[i + 1] - d[i]) return 1;
	}
	return 0;
}

inline 
void modify(int u, int v, int w) {
	int k = lca(u, v);
	add(u, w), add(v, w), add(k, w);
	if (fa[0][k]) add(fa[0][k], w);
}

inline 
bool query(int u, int v) {
	int k = lca(u, v);
	if (dep[u] + dep[v] - 2 * dep[k] + 1 > 46) return 1;
	else return check(get(u, v));
}

int m;

int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	for (int i = 1, u, v; i < n; i++) {
		scanf("%d%d", &u, &v);
		g[u].emplace_back(v), g[v].emplace_back(u);
	}
	init(1, 0);
	for (int i = 1; i <= n; i++) add(i, a[i]);
	for (int opt, u, v, w; m--;) {
		scanf("%d%d%d", &opt, &u, &v);
		if (opt == 1) scanf("%d", &w), modify(u, v, w);
		else printf("%d", query(u, v));
	}
}
```

---

## 作者：CaiZi (赞：9)

## 三角形与树 题解
**[题目链接](https://www.luogu.com.cn/problem/P10799)**
### 题目分析
考虑点权为什么情况时无法构成三角形。

将所有点权按照从小到大排序后记为数列 $f$。那么无法满足条件时，总是有 $f_i\ge f_{i-1}+f_{i-2}\space(i\ge3)$。其增长速度至少为斐波那契数列的增长速度。

因为点权范围在 $1\sim2^{31}-1$，于是当两个点之间距离大于等于 $46$ 时，数列 $f$ 的最后一项已经超过点权范围，故一定可以构成三角形，直接输出 $1$。否则使用暴力做法。

而简单路径上点的点权修改，直接上树链剖分就好了。当然也可以用简单的树上差分写法。

时间复杂度 $O(n\log n+q\log^2n)$，空间复杂度 $O(n)$。
### 代码展示
代码如下：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,q,a[100001],l,u,v,w,x,y,tre[100001],siz[100001],top[100001],son[100001],dep[100001],fa[100001],dfn[100001],cnt;
vector<int>g[100001],m;
bool r;
inline void update(int i,int j){
	for(int k=i;k<=n;k+=k&-k){
		tre[k]^=j;
	}
	return;
}
inline int query(int i,int j=0){
	for(int k=i;k>=1;k-=k&-k){
		j^=tre[k];
	}
	return j;
}
inline void dfs(int i){
	siz[i]=1;
	son[i]=-1;
	for(int j:g[i]){
		if(dep[j]==0){
			dep[j]=dep[i]+1;
			fa[j]=i;
			dfs(j);
			siz[i]+=siz[j];
			if(son[i]==-1||siz[j]>siz[son[i]]){
				son[i]=j;
			}
		}
	}
	return;
}
inline void calc(int i,int j){
	cnt++;
	dfn[i]=cnt;
	top[i]=j;
	if(son[i]!=-1){
		calc(son[i],j);
		for(int k:g[i]){
			if(k!=son[i]&&k!=fa[i]){
				calc(k,k);
			}
		}
	}
	return;
}
signed main(){
	scanf("%lld%lld",&n,&q);
	for(int i=1;i<=n;i++){
		scanf("%lld",&a[i]);
	}
	for(int i=2;i<=n;i++){
		scanf("%lld%lld",&u,&v);
		g[u].push_back(v);
		g[v].push_back(u);
	}
	dep[1]=1;
	dfs(1);
	calc(1,1);
	for(int i=1;i<=n;i++){
		update(dfn[i],a[i]);
		update(dfn[i]+1,a[i]);
	}
	for(int i=1;i<=q;i++){
		scanf("%lld%lld%lld",&l,&u,&v);
		if(l==1){
			scanf("%lld",&w);
			while(top[u]!=top[v]){
				if(dep[top[u]]<dep[top[v]]){
					swap(u,v);
				}
				update(dfn[top[u]],w);
				update(dfn[u]+1,w);
				u=fa[top[u]];
			}
			if(dep[u]>dep[v]){
				swap(u,v);
			}
			update(dfn[u],w);
			update(dfn[v]+1,w);
		}
		else{
			x=u;
			y=v;
			while(top[u]!=top[v]){
				if(dep[top[u]]<dep[top[v]]){
					swap(u,v);
				}
				u=fa[top[u]];
			}
			if(dep[u]>dep[v]){
				swap(u,v);
			}
			if(dep[x]+dep[y]-2*dep[u]>=46){
				putchar('1');
			}
			else{
				u=x;
				v=y;
				if(dep[u]<dep[v]){
					swap(u,v);
				}
				while(dep[u]>dep[v]){
					m.push_back(query(dfn[u]));
					u=fa[u];
				}
				while(u!=v){
					m.push_back(query(dfn[u]));
					m.push_back(query(dfn[v]));
					u=fa[u];
					v=fa[v];
				}
				m.push_back(query(dfn[u]));
				sort(m.begin(),m.end());
				if(m.size()<=2){
					putchar('0');
				}
				else{
					r=true;
					for(int j=2;j<=m.size()-1;j++){
						if(m[j]<m[j-1]+m[j-2]){
							r=false;
							putchar('1');
							break;
						}
					}
					if(r){
						putchar('0');
					}
				}
				m.clear();
			}
		}
	}
	return 0;
}
```
2024.8.15：修复了代码。

---

## 作者：dyc2022 (赞：4)

其实这个 trick 并不少见。然而我因为整型与无符号整型的问题调了半天，我真是太菜了。
***
首先，我们可以考虑这个条件在一个序列 $\{a\}$ 上怎么满足。

由定义可知，在三角形里面两条较短边加起来必然大于最长边。我们将序列 $a$ 排序，则若存在相邻的三个元素 $a_i,a_{i+1},a_{i+2}$ 有 $a_i+a_{i+1}>a_{i+2}$ 则必然可以选出一组三角形的三条边。

那么一个序列如果选不出满足上述条件的三条边，那么就必须满足 $a_i+a_{i+1} \le a_{i+2}$。那么我们就令对于每个 $i$ 都有等号成立，则这个数列就退化成斐波那契数列。因为 $a_i < 2^{31}$，又因为斐波那契数列的第 $46$ 项大于 $2^{31}$，因此如果序列长度大于 $45$ 那么一定有解。

这个东西我们把它搬到树上一定也是可以的。操作 2 处理完后，操作 1 是简易的。可以写一个树剖，支持链异或、单点查询。

代码是板子多合一，较为丑陋，就放在[这里](https://www.luogu.com.cn/paste/yjfienkg)了。

---

## 作者：Genius_Star (赞：4)

### 思路：

注意到，将 $x \to y$ 路径上的点的点权最小到大排序后，令第 $i$ 个为 $f_i$。

则若对于每个大于等于 $3$ 的 $i$ 都满足 $f_i \ge f_{i-1}+f_{i-2}$，此时无法构成三角形。

注意到是以斐波那契形式增长的，且点权在 $2^{31}-1$ 以内，故 $f$ 至多有 $46$ 项。

即若两点距离大于 $C=46$ 时，肯定有三点可以构成三角形。

否则的话直接暴力将路径上的点存下来排序，时间复杂度为 $O(C \log C)$。

对于路径异或操作，考虑树上差分，转化为对 $1 \to u,1 \to v,1 \to \operatorname{lca}(u,v),1 \to fa_{\operatorname{lca}(u,v)}$ 异或，那么在 $u,v,\operatorname{lca}(u,v),fa_{\operatorname{lca}(u,v)}$ 异或上一个 $k$ 的懒标记即可。

那么查询一个点的权值时，就是子树内所有点的懒标记的异或之后；可以将树拍为 dfn 序，线段树维护单点异或修改、区间异或查询。

时间复杂度为 $O(n \log n+m \log n + m C \log C)$。

---

## 作者：ty_mxzhn (赞：3)

事实上，构成三角形有一个经典性质。注意到如果把这些点权排序，那么假设可以构成三角形，这个三角形一定在相邻的三个点权上构建。

如果不能构建三角形，那么 $a_{i-1}+a_i \leq a_{i+1}$，因为 $a_{i-1} \leq a_i$ 所以 $2 a_{i-1} \le a_{i+1}$。

据此递推，$n$ 达到 $2 \log V$ 左右时三角形一定可以被构建。$n$ 的上界取 $50$ 肯定够。所以我们在 $n \leq 50$ 时暴力，$> 50$ 直接返回 Yes。

那么我们问题变成单点查询，链修改（异或）。

异或拥有良好的自反律，修改转成四个到根节点的链异或。

施树上差分。问题再次转成询问子树异或，单点修改。考虑 dfs 序把子树拍到序列上，可以使用树状数组解决这个问题。

总结：本题缝合了一个特殊性质和一个简单的 ds 问题。

---

## 作者：0tAp (赞：2)

题目链接：[P10799 「CZOI-R1」三角形与树](https://www.luogu.com.cn/problem/P10799)


---

做法：树链剖分+线段树。

思路：局部暴力枚举。不难想到三角形的边有以下性质 $f_i<f_{i-1}+f_{i-2}$，这和斐波那契很像，再观察数据范围 $1\le w\le 2^{31}-1$，即考虑 $f_i=f_{i-1}+f_{i-2}\ge2^{31}-1$ 可知当 $n\ge47$ 时一定有解，故对点数在 $47$ 以下的进行暴力枚举判断就行。时间复杂度大概为 $O(Kq\log n)$ 其中 $K$ 不超过 $47$。


---

代码如下：


```cpp
#include<algorithm>
#include<iostream>
#include<string.h>
#include<cstdio>
#include<vector>
#include<queue>
#include<cmath>
#include<map>
#include<set>
using namespace std;
#define int long long
#define lb(a,b,n) (lower_bound((a)+1,(a)+1+(n),(b))-(a))
#define repu(i,u) for(int i=(h[u]);i;i=(ne[i]))
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define dwn(i,a,b) for(int i=(a);i>=(b);i--)
#define debug cout<<"wwww"<<endl
#define llinf 1e18
#define inf 0x3f3f3f3f
#define pb(a) push_back((a))
#define xx return
const int N=2e5+10;

int n,q;
int h[N],e[N*2],ne[N*2],idx;
int wt[N],a[N];
namespace xx_Seg{
	#define ls (p<<1)
	#define rs (p<<1|1)
	#define mid (l+r>>1)
	struct Tree{
		int val,tag;
		#define val(p) t[p].val
		#define tag(p) t[p].tag
	}t[N*4];
	void push_down(int p){
		val(ls)^=tag(p),val(rs)^=tag(p);
		tag(ls)^=tag(p),tag(rs)^=tag(p);
		tag(p)=0;
	}
	void build(int p,int l,int r){
		if(l==r){val(p)=a[wt[l]];xx;}
		build(ls,l,mid),build(rs,mid+1,r);
	}
	void change(int p,int l,int r,int L,int R,int k){
		if(L<=l&&r<=R){val(p)^=k,tag(p)^=k;xx;}push_down(p);
		if(L<=mid)change(ls,l,mid,L,R,k);
		if(R>mid)change(rs,mid+1,r,L,R,k);
	}
	int ask(int p,int l,int r,int x){
		if(l==r)xx val(p);push_down(p);
		if(x<=mid)xx ask(ls,l,mid,x);
		else xx ask(rs,mid+1,r,x);
	}
}

namespace xx_CTT{
	int d[N],fa[N],sizt[N],son[N];
	int top[N],id[N],cnt;
	void dfs1(int u,int fath){
		d[u]=d[fath]+1;fa[u]=fath;sizt[u]=1;
		int max_son=-1;
		repu(i,u){
			int v=e[i];
			if(v==fath)continue;
			dfs1(v,u);
			sizt[u]+=sizt[v];
			if(sizt[v]>max_son)son[u]=v,max_son=sizt[v];
		}
	}
	void dfs2(int u,int topf){
		id[u]=++cnt;wt[cnt]=u;top[u]=topf;
		if(!son[u])xx;dfs2(son[u],topf);
		repu(i,u){
			int v=e[i];
			if(v==fa[u]||v==son[u])continue;
			dfs2(v,v);
		}
	}
	void change(int u,int v,int k){
		while(top[u]!=top[v]){
			if(d[top[u]]<d[top[v]])swap(u,v);
			xx_Seg::change(1,1,n,id[top[u]],id[u],k);
			u=fa[top[u]];
		}
		if(d[u]>d[v])swap(u,v);
		xx_Seg::change(1,1,n,id[u],id[v],k);
		xx;
	}
	int ask1(int u,int v){
		int now=0;
		while(top[u]!=top[v]){
			if(d[top[u]]<d[top[v]])swap(u,v);
			now+=id[u]-id[top[u]]+1;
			u=fa[top[u]];
		}
		if(d[u]>d[v])swap(u,v);
		now+=id[v]-id[u]+1;
		xx now;
	} 
	int ask2(int u,int v){
		vector<int>num;
		while(top[u]!=top[v]){
			if(d[top[u]]<d[top[v]])swap(u,v);
			rep(i,id[top[u]],id[u])num.pb(xx_Seg::ask(1,1,n,i));
			u=fa[top[u]];
		}
		if(d[u]>d[v])swap(u,v);
		rep(i,id[u],id[v])num.pb(xx_Seg::ask(1,1,n,i));
		sort(num.begin(),num.end());
		if(num.size()<3)xx 0;
		rep(i,2,num.size()-1){
			if(num[i-1]>num[i]-num[i-2])xx 1;
		}
		xx 0;
	}
}

namespace Main_xx{
	void add(int a,int b){e[++idx]=b,ne[idx]=h[a],h[a]=idx;}
	void Main(){
		cin>>n>>q;
		rep(i,1,n)cin>>a[i];
		rep(i,1,n-1){
			int u,v;cin>>u>>v;add(u,v),add(v,u);
		}
		xx_CTT::dfs1(1,0);xx_CTT::dfs2(1,1);
		xx_Seg::build(1,1,n);
		while(q--){
			int opt,u,v;cin>>opt>>u>>v;
			if(opt==1){
				int k;cin>>k;
				xx_CTT::change(u,v,k);
			}
			else{
				int ANS=xx_CTT::ask1(u,v);
				if(ANS>=47)cout<<1;
				if(ANS<3)cout<<0;
				if(ANS>=3&&ANS<=46){
					if(xx_CTT::ask2(u,v))cout<<1;
					else cout<<0;
				}
			}
		}
		xx;
	}
}

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	Main_xx::Main();
	xx 0;
}
```

---

## 作者：ICU152_lowa_IS8 (赞：2)

前置知识：

- $a \oplus b \oplus c =a \oplus (b \oplus c)$；

- 线段树（不会的左转模板）；

- 树链剖分（不会的右转模板）；

- 八上数学。



关于操作一，显然是个树剖板子，由于上文提到的性质可以直接用线段树懒标记维护。

对于操作二，首先如果 $x$ 到 $y$ 的简单路径上有 $>46$ 个点那么根据题目给出的数据范围一定有解，这个其它题解有详细说明就不多赘述了。如果点数 $\le46$ 直接暴力做，排完序之后判断 $a_i+a_{i+1}$ 和 $a_{i+2}$ 的大小关系就行。如果不知道为啥翻八上数学书。

关于这棵线段树，其实可以不用写 `pushup`，因为我们只关心叶子节点的值（操作二需要暴力的时候全是单点查询）。

但这并不意味着我们只需要异或 `tag` 不需要异或 `val`，因为如果修改的节点是不是线段树的叶子节点我们是没法直接知道的。

那就象征性的给 `tag` 和 `val` 在修改和 `pushdown` 的时候都异或，用的时候只把叶子节点的值取出来就好了。

补充一点，暴力取的时候可以直接 `for` 循环的原因是在重链剖分当中重链上所有节点的编号连续。

代码：


```
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,q;
struct node{
	int v,w,next;
}edge[1000005<<2];
int head[1000005],num;
void add(int u,int v,int w){
	edge[++num].next=head[u];
	head[u]=num;
	edge[num].w=w;
	edge[num].v=v;
}
int a[1000005];
int son[1000005],fa[1000005],dep[1000005],siz[1000005];
int top[1000005],id[1000005],tmp[1000005],cnt;
void dfs1(int now,int fath,int deep){
	fa[now]=fath;
	dep[now]=deep;
	siz[now]=1;
	int maxson=-1;
	for(int i=head[now];i;i=edge[i].next){
		int v=edge[i].v;
		if(v==fath)continue;
		dfs1(v,now,deep+1);
		if(siz[v]>maxson){
			maxson=siz[v];
			son[now]=v;
		}
		siz[now]+=siz[v];
	}
}
void dfs2(int now,int topf){
	top[now]=topf;
	id[now]=++cnt;
	tmp[cnt]=a[now];
	if(!son[now])return;
	dfs2(son[now],topf);
	for(int i=head[now];i;i=edge[i].next){
		int v=edge[i].v;
		if(v==son[now]||v==fa[now])continue;
		dfs2(v,v);
	}
}
struct T{
	int val,tag;
}tree[1000005<<2];
inline int ls(int p){
	return p<<1;
}
inline int rs(int p){
	return p<<1|1;
}
inline void pushdown(int p){
	tree[ls(p)].val^=tree[p].tag;
	tree[rs(p)].val^=tree[p].tag;
	tree[ls(p)].tag^=tree[p].tag;
	tree[rs(p)].tag^=tree[p].tag;
	tree[p].tag=0;
}
inline void build(int p,int l,int r){
	if(l==r){
		tree[p].val=tmp[l];
		return;
	}
	int mid=l+r>>1;
	build(ls(p),l,mid);
	build(rs(p),mid+1,r);
}
inline void update(int p,int l,int r,int ql,int qr,int k){
	if(l>qr||r<ql)return;
	if(l>=ql&&r<=qr){
		tree[p].val^=k;
		tree[p].tag^=k;
		return;
	}
	int mid=l+r>>1;
	pushdown(p);
	update(ls(p),l,mid,ql,qr,k);
	update(rs(p),mid+1,r,ql,qr,k);
}
inline int query(int p,int l,int r,int ql,int qr){
	if(l>qr||r<ql)return 0;
	if(l>=ql&&r<=qr){
		return tree[p].val;
	}
	int mid=l+r>>1;
	pushdown(p);
	return query(rs(p),mid+1,r,ql,qr)+query(ls(p),l,mid,ql,qr);
}
void updrange(int x,int y,int k){
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		update(1,1,n,id[top[x]],id[x],k);
		x=fa[top[x]];
	}
	if(dep[x]>dep[y])swap(x,y);
	update(1,1,n,id[x],id[y],k);
}
int tem[105],p;
int qrange(int x,int y){
//	memset(tem,0,sizeof(tem));
	int nowlen=0;
	p=0;
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		nowlen+=id[x]-id[top[x]]+1;
		if(nowlen>=47)return 1;
		for(int i=id[top[x]];i<=id[x];i++){
			tem[++p]=query(1,1,n,i,i);
		}
		x=fa[top[x]];
	}
	if(dep[x]>dep[y])swap(x,y);
	nowlen+=id[y]-id[x]+1;
	if(nowlen>=47)return 1;
	for(int i=id[x];i<=id[y];i++){
		tem[++p]=query(1,1,n,i,i);
	}
	sort(tem+1,tem+p+1);
	for(int i=1;i<p-1;i++){
//		cout<<tem[i]<<" ";
		if(tem[i]+tem[i+1]>tem[i+2])return 1;
	}
	return 0;
}
signed main(){
	ios::sync_with_stdio(false);
	cin>>n>>q;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<n;i++){
		int u,v;
		cin>>u>>v;
		add(u,v,1);
		add(v,u,1);
	}
	dfs1(1,0,1);
	dfs2(1,1);
	build(1,1,n);
	while(q--){
		int op;
		cin>>op;
		if(op==1){
			int u,v,w;
			cin>>u>>v>>w;
			updrange(u,v,w);
		}
		else{
			int u,v;
			cin>>u>>v;
			cout<<qrange(u,v);
		}
	}
	return 0;
}

```

---

## 作者：lyas145 (赞：2)

题目在[这里](https://www.luogu.com.cn/problem/P10799)。

### 解题思路

第一个操作相信大家都会，直接树链剖分加线段树就行了，然后我们来看看第二个操作。

先想想三条边怎么样才能构成三角形呢？若三条边的长度分别为 $a$，$b$，$c$，这些边满足 $a \le c$，$b \le c$，且 $a + b > c$，那么这三条边就可以构成三角形。如果是给了一堆边的话（设 $w_i$ 为第 $i$ 条边的长度），可以先按长度排个序，若现在在处理第 $i$ 条边，那么看看 $w_{i-2} + w_{i-1}$ 是否大于 $w_i$ 就行了。

如果不满足，那么 $w_{i-2} + w_{i-1}$ 肯定小于等于 $w_i$，并且题目中说了，点权不为 $0$，那最小的话就只能是 $1$，要想不满足的情况尽可能多，就得满足 $w_{i-2} + w_{i-1} = w_i$，且 $w_1$ 和 $w_2$ 为 $1$。哎？这不就是斐波那契数列吗？！经过计算可以发现斐波那契数列中的第 $47$ 个数就大于 $2^{31} - 1$ 了，而且点权不可能超过 $2^{31} - 1$（因为是异或嘛！），所以当路经上的点的数量**大于或等于** $47$ 时，答案就肯定是 $1$；若点的数量**小于** $47$，直接用 LCA 暴力加入点权排个序，再扫一遍就行了，反正就顶多 $46$ 个数，时间复杂度不会很高。

代码里也有些注释。

### 码儿

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=1e5+5,M=N<<1,T=47;
int n,q;
int tag[N<<2],a[N],cnt;
int fa[N],dep[N],siz[N],top[N],son[N],id[N],dfn[N],dfi;
int h[N],e[M],ne[M],idx=1;
struct Tree{
	int l,r,s;
}tr[N<<2];
void add(int a,int b) {
	e[idx]=b;ne[idx]=h[a];h[a]=idx++;
}
//下面是线段树。
//pushup 似乎没啥用，我就懒得写了。
void upd(int u,int k) {
	tr[u].s^=k;
	tag[u]^=k;
}
void pushdown(int u) {
	upd(u<<1,tag[u]);
	upd(u<<1|1,tag[u]);
	tag[u]=0;
}
void build(int u,int l,int r) {
	tr[u]={l,r};
	if (l==r) {
		tr[u].s=a[id[l]];
		return ;
	}
	int mid=l+r>>1;
	build(u<<1,l,mid);
	build(u<<1|1,mid+1,r);
}
void modify(int u,int l,int r,int k) {
	if (l<=tr[u].l && tr[u].r<=r) {
		upd(u,k);
		return ;
	}
	pushdown(u);
	int mid=tr[u].l+tr[u].r>>1;
	if (l<=mid) {modify(u<<1,l,r,k);}
	if (mid<r) {modify(u<<1|1,l,r,k);}
}
int query(int u,int x) {
	if (tr[u].l==tr[u].r) {return tr[u].s;}
	pushdown(u);
	int mid=tr[u].l+tr[u].r>>1;
	if (x<=mid) {return query(u<<1,x);}
	return query(u<<1|1,x);
}
//下面是树链剖分。
void dfs1(int u,int fath) {
	dep[u]=dep[fath]+1;
	fa[u]=fath;siz[u]=1;
	for (int i=h[u];i;i=ne[i]) {
		int v=e[i];
		if (v==fath) {continue;}
		dfs1(v,u);
		siz[u]+=siz[v];
		if (siz[v]>siz[son[u]]) {son[u]=v;}
	}
}
void dfs2(int u,int t) {
	top[u]=t;dfn[u]=++dfi;id[dfi]=u;
	if (son[u]) {dfs2(son[u],t);}
	for (int i=h[u];i;i=ne[i]) {
		int v=e[i];
		if (top[v]) {continue;}
		dfs2(v,v);
	}
}
void modify(int x,int y,int w) {  //第一个操作。
	while (top[x]^top[y]) {
		if (dep[top[x]]<dep[top[y]]) {swap(x,y);}
		modify(1,dfn[top[x]],dfn[x],w);
		x=fa[top[x]];
	}
	if (dep[x]>dep[y]) {swap(x,y);}
	modify(1,dfn[x],dfn[y],w);
}
bool TT(int x,int y) {  //看看路径上的点数是否大于或等于 47。
	int res=0;
	while (top[x]^top[y]) {
		if (dep[top[x]]<dep[top[y]]) {swap(x,y);}
		res+=dep[x]-dep[top[x]]+1;
		if (res>=T) {return 1;}
		x=fa[top[x]];
	}
	if (dep[x]<dep[y]) {swap(x,y);}
	return res+dep[x]-dep[y]+1>=T;
}
void find(int x,int y) {  //LCA 暴力加入点权
	if (dep[x]<dep[y]) {swap(x,y);}
	while (dep[fa[x]]>=dep[y]) {
		a[++cnt]=query(1,dfn[x]);
		x=fa[x];
	}
	if (x==y) {a[++cnt]=query(1,dfn[x]);return ;}
	while (fa[x]!=fa[y]) {
		a[++cnt]=query(1,dfn[x]);
		a[++cnt]=query(1,dfn[y]);
		x=fa[x];y=fa[y];
	}
	a[++cnt]=query(1,dfn[x]);
	a[++cnt]=query(1,dfn[y]);
	a[++cnt]=query(1,dfn[fa[x]]);
}
int main() {
	scanf("%d%d",&n,&q);
	for (int i=1;i<=n;i++) {scanf("%d",&a[i]);}
	for (int i=1;i<n;i++) {
		int a,b;
		scanf("%d%d",&a,&b);
		add(a,b);add(b,a);
	}
	dfs1(1,0);
	dfs2(1,1);
	build(1,1,dfi);  //a 数组中存的点权在这之后就没用了。
	while (q--) {
		int op,u,v,w;
		scanf("%d%d%d",&op,&u,&v);
		if (op==1) {
			scanf("%d",&w);
			modify(u,v,w);
		}
		else {
			if (TT(u,v)) {putchar('1');continue;}
            //如果路径上的点数大于或等于 47，那么答案肯定为 1。
			bool f=0;
			cnt=0;
			find(u,v);
			sort(a+1,a+1+cnt);
			for (int i=3;i<=cnt;i++) {  //如果路径上的点数小于 47，那么就排完序后扫一遍，看看有没有能够成三角形的。
				if (1ll*a[i-2]+1ll*a[i-1]>1ll*a[i]) {f=1;continue;}
                //点权加起来可能会爆 int。
			}
			putchar('0'+f);
		}
	}
	return 0;
}
```

Thanks for reading！

---

## 作者：ELECTRODE_kaf (赞：1)

假设无法构成三角形，记路径上所有点权排序后构成的数列为 $a$。

此数列增长最快时，有 $a_{i}+a_{i+1}=a_{i+2}$，为斐波那契数列。

观察点的权值的取值范围，可以发现当两点间距离不小于 46 时，数列的尾项已经超出范围，所以此时必然可以构成三角形。

两点间距离小于等于 46 时，则遍历 $a$ 判断一遍。

用树状数组+树链剖分+差分维护点权。

```cpp
#include <bits/stdc++.h>
#define ll long long
#define rep(i,x,y) for(ll i=x;i<=y;i++)
using namespace std;

const ll N = 110000;
ll n, q, a[N], bt[N],
//树状数组，按高度存储区间异或和
siz[N], top[N], hs[N], dep[N], fa[N], dfn[N];
//siz记录子树大小，cur记录当前搜索序
vector<ll>g[N], node;
//node存储路径上的数

ll lowbit(ll x) {
	return x & -x;
}

void update(ll p, ll val) {
	//差分序列中第i位异或上了j，此函数在树状数组上做出相应的改变
	//原数列（a[]）和差分数列不同！

	for (; p <= n; p += lowbit(p)) {
		bt[p] ^= val;
	}

//	return;
}

ll query(ll p) {
	ll re = 0;
	//询问查分数列中1到i的和，即原数列中的a[i]

	for (; p > 0; p -= lowbit(p)) {
		re ^= bt[p];
	}

	return re;
}

//ll cur;

void dfs1(ll p) {
	siz[p] = 1;
//	hs[p] = -1;

	for (ll j : g[p]) {
		if (dep[j]) {
			continue;
		}

		//dep[j]==0说明点j未访问过
		dep[j] = dep[p] + 1;
		fa[j] = p;
		dfs1(j);
		siz[p] += siz[j];

		if (siz[j] > siz[hs[p]]) {
			hs[p] = j;
		}
	}

//	return;
}

ll cur;

void dfs2(ll p, ll curtop) {
	cur++;
	dfn[p] = cur;
	top[p] = curtop;

	if (hs[p] == 0) {
		return;
	}

	dfs2(hs[p], curtop);

	for (ll i : g[p]) {
		if (i == hs[p] || i == fa[p]) {
			continue;
		}

		dfs2(i, i);
	}
}

void ini() {
	node.clear();
}

const ll fib = 46;

int main() {
//	scanf("%lld%lld", &n, &q);
	cin >> n >> q;

	rep(i, 1, n) {
		cin >> a[i];
	}

	ll u, v;

	rep(i, 1, n - 1) {
//		scanf("%lld%lld", &u, &v);
		cin >> u >> v;
		g[u].push_back(v);
		g[v].push_back(u);
	}

	dep[1] = 1;
	//根节点深度为1
	dfs1(1);
//	cout<<"dfs1 conplete!\n";
	dfs2(1, 1);
//	cout<<"dfs2 conplete!\n";

	rep(i, 1, n) {
		update(dfn[i], a[i]);
		update(dfn[i] + 1, a[i]);
	}

	//树状数组使用差分（方便区间修改）
	ll ty, w, _u, _v;

	while (q--) {
//		scanf("%lld%lld%lld", &ty, &u, &v);
		cin >> ty >> u >> v;

		if (ty == 1) {
			cin >> w;

			while (top[u] != top[v]) {
				if (dep[top[u]] < dep[top[v]]) {
					swap(u, v);
				}

				update(dfn[top[u]], w);
				update(dfn[u] + 1, w);
				//异或一个数两次相当于什么都没做
				//dfn[u]+1表示它的儿子
				u = fa[top[u]];
			}

			if (dep[u] > dep[v]) {
				swap(u, v);
			}

			update(dfn[u], w);
			update(dfn[v] + 1, w);
		} else {
			_u = u;
			_v = v;
			ini();

			while (top[u] != top[v]) {
				if (dep[top[u]] < dep[top[v]]) {
					swap(u, v);
				}
				u = fa[top[u]];
			}

			if (dep[u] > dep[v]) {
				swap(u, v);
			}

			if (dep[_u] + dep[_v] - 2 * dep[u] >= fib) {
				cout << 1;
			} else {
				u = _u;
				v = _v;

				if (dep[u] < dep[v]) {
					swap(u, v);
				}

				while (dep[u] > dep[v]) {
					node.push_back(query(dfn[u]));
					u = fa[u];
				}

				while (u != v) {
					node.push_back(query(dfn[u]));
					node.push_back(query(dfn[v]));
					u = fa[u];
					v = fa[v];
				}

				node.push_back(query(dfn[u]));
				sort(node.begin(), node.end());

				if (node.size() <= 2) {
					cout << 0;
				} else {
					bool flag = 0;
//					flag = true;
					//flag表示是否有解

					rep(i, 0, node.size() - 3) {
						if (node[i] + node[i + 1] > node[i + 2]) {
							flag = 1;
//							putchar('1');
							break;
						}
					}

//					if (flag) {
//						putchar('0');
//					}

					cout << flag;
				}
			}

//			cout << '\n';
		}
	}

//	return 0;
}
```

---

## 作者：封禁用户 (赞：1)

### Tag
树链剖分，线段树。

### 思路
令点 $x$ 到点 $y$ 路径上的所有点的点权从小到大排序后为 $a_1,a_2,a_3,\dots,a_k$。

若不能构成三角形，则 $\forall i(i \geq 3)$ 都有 $a_i \geq a_{i-1}+a_{i-2
}$。


即最坏情况下，$a_i = a_{i-1}+a_{i-2
}$。\
很容易发现这就是个斐波那契数列。

令斐波那契数列的第 $i$ 项为 $f_i$。\
枚举可知：$f_{47}>2^{31}-1$。

即，若点 $x$ 到点 $y$ 路径上的点数 $\geq47$，答案为 $1$。\
否则枚举 $i(i \geq 3)$ 判断是否有 $a_i < a_{i-1}+a_{i-2
}$ 即可。

对于异或操作，线段树维护即可。

对于查询操作，树链剖分即可。

### 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+7;
int fa[N],son[N],dep[N],top[N],siz[N],n,q,a[N],tr[N<<2],s,u,v,w,cnt,id[N],mp[N];
vector<int> e[N],ans;

void dfs1(int u,int f,int d){
	fa[u]=f;
	dep[u]=d;
	siz[u]=1;
	int maxn=0,hid=u;
	for(auto v:e[u])
		if(v!=f){
			dfs1(v,u,d+1);
			siz[u]+=siz[v];
			if(siz[v]>maxn)
				maxn=siz[v],hid=v;
		}
	son[u]=hid;
}

void dfs2(int u,int t){
	top[u]=t;
	id[u]=++cnt;
	mp[cnt]=u;
	if(son[u]!=u)
		dfs2(son[u],t);
	for(auto v:e[u])
		if(v!=fa[u]&&v!=son[u])
			dfs2(v,v);
}

void build(int x,int l,int r){
	if(l==r){
		tr[x]=a[mp[l]];
		return;
	}
	int mid=(l+r)>>1;
	build(x<<1,l,mid),build(x<<1|1,mid+1,r);
}

void update(int x,int l,int r,int L,int R,int k){
	if(L>=l&&R<=r){
		tr[x]^=k;
		return;
	}
	int mid=(L+R)>>1;
	if(l<=mid)
		update(x<<1,l,r,L,mid,k);
	if(r>mid)
		update(x<<1|1,l,r,mid+1,R,k);
}

void update2(int u,int v,int k){
	while(top[u]!=top[v]){
		if(dep[top[u]]<dep[top[v]])
			swap(u,v);
		update(1,id[top[u]],id[u],1,n,k);
		u=fa[top[u]];
	}
	if(dep[u]>dep[v])
		swap(u,v);
	update(1,id[u],id[v],1,n,k);
}

int query(int x,int k,int L,int R){
	if(L==R)
		return tr[x];
	int mid=(L+R)>>1;
	if(k<=mid)
		return tr[x]^query(x<<1,k,L,mid);
	return tr[x]^query(x<<1|1,k,mid+1,R);
}

int lca(int u,int v){
	while(top[u]!=top[v]){
		if(dep[top[u]]<dep[top[v]])
			swap(u,v);
		u=fa[top[u]];
	}
	return dep[u]<dep[v]?u:v;
}

int query2(int u,int v){
	int p=lca(u,v);
	if(dep[u]+dep[v]-2*dep[p]+1>46)
		return 1;
	ans.resize(0);
	while(top[u]!=top[v]){
		if(dep[top[u]]<dep[top[v]])
			swap(u,v);
		for(int i=id[top[u]];i<=id[u];++i)
			ans.push_back(query(1,i,1,n));
		u=fa[top[u]];
	}
	if(dep[u]>dep[v])
		swap(u,v);
	for(int i=id[u];i<=id[v];++i)
		ans.push_back(query(1,i,1,n));
	sort(ans.begin(),ans.end());
	for(int i=2;i<ans.size();++i)
		if(ans[i]<ans[i-1]+ans[i-2])
			return 1;
	return 0;
}

signed main(){
	cin>>n>>q;
	for(int i=1;i<=n;++i)
		cin>>a[i];
	for(int i=1;i<n;++i)
		cin>>u>>v,e[u].push_back(v),e[v].push_back(u);
	dfs1(1,1,1);
	dfs2(1,1);
	build(1,1,n);
	for(int i=1;i<=q;++i){
		cin>>s;
		if(s==1){
			cin>>u>>v>>w;
			update2(u,v,w);
		}else{
			cin>>u>>v;
			cout<<query2(u,v);
		}
	}
}
```


### 记录
[rt](https://www.luogu.com.cn/record/173536979)

---

## 作者：Engulf (赞：1)

类似的题目：[CF1991F](https://www.luogu.com.cn/problem/CF1991F)。

如果是一个序列，问 $[l, r]$ 是否存在一组数能构成三角形（一下简称“存在三角形”）怎么做？类似 CF1991F 的，考虑最长的无法构成三角形的区间，构造 $a_1 = 1, a_2 = 1, a_3 = 2, a_i = a_{i - 1} + a_{i - 2} \cdots$，因为 $a_i \le 2^{31} - 1$，发现 $a_{47} = 29,7121,5073 > 2^{31}-1$，断定长度 $\ge 47$ 的区间至少存在一个三角形。

转到树上，做法如下，记 $dis$ 为 $x, y$ 之间点数。
- $dis \ge 47$，输出 `YES`。
- $dis < 47$，$x,y$ 之间没多少点，考虑暴力寻找三角形。把 $x$ 到 $y$ 路径上的点拉出来，排序，考虑相邻的三个数 $(x, y, z), x \le y \le z$，若 $x + y > z$ 那么 $(x, y, z)$ 构成三角形，不会证翻八上数学书。

发现题目还有树上路径修改操作，还需要求树上两点间距离，还要拉出路径，无一例外需要我们使用树链剖分解决。线段树那里，因为是单点查询，标记永久化维护会减少码量。

```cpp
#include <bits/stdc++.h>

using namespace std;

using ll = long long;
using pii = pair<int, int>;

#ifdef ONLINE_JUDGE
#define debug(...) 0
#else
#define debug(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)
#endif

const int N = 1e5 + 5;

int n, q;
int a[N];

vector<int> g[N];

int fa[N], siz[N], dep[N], son[N];
int top[N], dfn[N], rev[N], tim;

void dfs1(int u, int f) {
    fa[u] = f;
    siz[u] = 1;
    dep[u] = dep[f] + 1;
    for (auto v: g[u]) {
        if (v == f) continue;
        dfs1(v, u);
        siz[u] += siz[v];
        if (siz[v] > siz[son[u]])
            son[u] = v;
    }
}
void dfs2(int u, int tp) {
    top[u] = tp;
    dfn[u] = ++tim;
    rev[tim] = u;
    if (!son[u]) return;
    dfs2(son[u], tp);
    for (auto v: g[u])
        if (!dfn[v])
            dfs2(v, v);
}

int lca(int x, int y) {
    while (top[x] != top[y]) {
        if (dep[top[x]] < dep[top[y]]) swap(x, y);
        x = fa[top[x]];
    }
    if (dep[x] > dep[y]) swap(x, y);
    return x;
}

int tr[N << 2];
void build(int p, int l, int r) {
    if (l == r) {tr[p] = a[rev[l]]; return;}
    int mid = l + r >> 1;
    build(p << 1, l, mid);
    build(p << 1 | 1, mid + 1, r);
}
void update(int p, int l, int r, int L, int R, int v) {
    if (L <= l && r <= R) {tr[p] ^= v; return;}
    int mid = l + r >> 1;
    if (L <= mid) update(p << 1, l, mid, L, R, v);
    if (mid < R) update(p << 1 | 1, mid + 1, r, L, R, v);
}
int query(int p, int l, int r, int x) {
    if (l == r) return tr[p];
    int mid = l + r >> 1;
    return tr[p] ^ (x <= mid ? query(p << 1, l, mid, x) : query(p << 1 | 1, mid + 1, r, x));
}

void update(int x, int y, int v) {
    while (top[x] != top[y]) {
        if (dep[top[x]] < dep[top[y]]) swap(x, y);
        update(1, 1, n, dfn[top[x]], dfn[x], v);
        x = fa[top[x]];
    }
    if (dep[x] > dep[y]) swap(x, y);
    update(1, 1, n, dfn[x], dfn[y], v);
}
int query(int x, int y) {
    int dis = dep[x] + dep[y] - 2 * dep[lca(x, y)] + 1; // number of nodes on the path
    if (dis >= 47) return 1;

    vector<int> v;
    while (top[x] != top[y]) {
        if (dep[top[x]] < dep[top[y]]) swap(x, y);
        int tp = top[x];
        while (x != fa[tp]) {
            v.emplace_back(query(1, 1, n, dfn[x]));
            x = fa[x];
        }
    }
    if (dep[x] < dep[y]) swap(x, y);
    while (x != fa[y]) {
        v.emplace_back(query(1, 1, n, dfn[x]));
        x = fa[x];
    }
    if (v.size() < 3) return 0;
    sort(v.begin(), v.end());
    for (int i = 0; i < v.size() - 2; i++)
        if (1.0 * v[i] + v[i + 1] > v[i + 2])
            return 1;
    return 0;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> q;
    for (int i = 1; i <= n; i++) cin >> a[i];

    for (int i = 1, x, y; i < n; i++) {
        cin >> x >> y;
        g[x].emplace_back(y);
        g[y].emplace_back(x);
    }

    dfs1(1, 0);
    dfs2(1, 1);
    build(1, 1, n);

    while (q--) {
        int op, u, v, w;
        cin >> op >> u >> v;
        if (op == 1) {
            cin >> w;
            update(u, v, w);
        } else cout << query(u, v);
    }

    return 0;
}
```

---

## 作者：xiaoliebao1115 (赞：1)

## 思路
若不能构成三角形当且仅当排序后构成的序列 $b_i$ 对于所有的 $i$ 满足 $b_i+b_{i+1}\le b_{i+2}$，这样做的正确性是 $b_{i+1}$ 和 $b_i$ 一定是对于 $b_{i+2}$ 来讲最大的两个数，若他们两个不满足三角形，则其他的也不满足。

观察 $b_i$ 若一直不构成三角形，在某一定较小的范围内 $b_i$ 就会超过题目给定的 $2^{31}-1$，所以可以在这个 $b_i$ 的不会超的较小范围内进行暴力求解，会超的直接输出会构成三角形。

然后对于修改操作，可以将树根据搜索序化成序列，然后若修改 $x$ 到 $y$ 的路径，则进行树上差分维护，将这两个点和他们的最近公共祖先还有最近公共祖先的父亲都异或一下即可。于是在询问时要求的就是较短路径上每一个数的值，在序列中用树状数组维护这个数，这个数的值其实就是以这个数为根的子树的异或和，然后对于路径上的每一个数都查询一下即可。

## 代码
挺简单的就不贴了，这里的最近公共祖先因为比较小，所以直接暴力即可。

---

## 作者：Wei_Han (赞：0)

构成三角形显然是要满足 $a+b>c$，我们再给他拓展一下，就算取到 $a+b\geq c$，那么每一组都不能满足这个关系，也就是 $f_{i-1} + f_i \geq f_{i+1}$，跟斐波那契是近似的，当 $i \geq 47$ 时，$f_i \geq 2^{31}+1$，所以在这条路径上只要有超过 $46$ 个点就一定符合要求。

区间异或是可以在线段树上完成的，再套一个树剖就好了，注意询问将所有点取出来时每次都要判断点集大小，不然是会被链的数据卡爆的。判断三角形排序后判断 $f_{i-1} + f_{i} \geq f_i$ 即可。

复杂度 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f3f3f3f3f
#define inf 0x3f3f3f3f
#define pr putchar('\n')
#define fi first
#define se second
#define pp putchar(' ')
#define pii pair<ll,ll>
#define pdi pair<ll,ll>
#define mem(aa,bb) memset(aa,bb,sizeof(aa))
#define fo(a,i,b) for(register ll i = a ; i <= b ; ++ i )
#define Fo(a,i,b) for(register ll i = a ; i >= b ; -- i )
#define pb push_back
//#pragma GCC optimize(2)
using namespace std;
//typedef int ll;
typedef long long ll;
//typedef __int128 ll;
typedef double db;
inline void read(ll &opp){ll x=0,t=1;char ch;ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-'){t=-1;}ch=getchar();}while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}opp=x*t;return; }
inline void wr(ll x){if(x<0){putchar('-');x=-x;}if(x>9){wr(x/10);}putchar(x%10+'0');}
const ll N=1e5+5,M=2e4+5,mod=1e9+7;
ll n,q,a[N],siz[N],dep[N],son[N],id[N],w[N],rb[N],top[N],fa[N],cnt;
vector<ll> g[N];
inline void dfs1(ll x,ll fat,ll depth){
	dep[x]=depth,fa[x]=fat,siz[x]=1;ll zson=-1;
	for(ll y:g[x]){if(y==fat) continue;dfs1(y,x,depth+1);siz[x]+=siz[y];if(siz[y]>zson) zson=siz[y],son[x]=y;}
}
inline void dfs2(ll x,ll nowtop){
	top[x]=nowtop,id[x]=++cnt,w[cnt]=x;
	if(!son[x]) return rb[x]=cnt,void();dfs2(son[x],nowtop);
	for(ll y:g[x]){if(y==fa[x]||y==son[x]) continue;dfs2(y,y);}
}
struct SGT{ll l,r,sum,lazy;}tree[N<<2];
#define rt tree[root]
#define ls tree[root<<1]
#define rs tree[root<<1|1]
inline void pushup(ll root){rt.sum=ls.sum^rs.sum;}
inline void build(ll root,ll l,ll r){rt.l=l,rt.r=r;if(l==r) return rt.sum=a[w[l]],void();ll mid=l+r>>1;build(root<<1,l,mid),build(root<<1|1,mid+1,r);pushup(root);}
inline void pd(ll root){ll lazy=rt.lazy;if(!lazy) return;rt.lazy=0;ls.sum^=lazy,rs.sum^=lazy,ls.lazy^=lazy,rs.lazy^=lazy;}
inline void upd(ll root,ll x,ll y,ll k){ll l=rt.l,r=rt.r;if(x<=l&&y>=r) return rt.sum^=k,rt.lazy^=k,void();ll mid=l+r>>1;pd(root);if(x<=mid) upd(root<<1,x,y,k);if(y>mid) upd(root<<1|1,x,y,k);pushup(root);}
inline ll ask(ll root,ll x){ll l=rt.l,r=rt.r;if(l==r) return rt.sum;ll mid=l+r>>1;pd(root);if(x<=mid) return ask(root<<1,x);else return ask(root<<1|1,x);}
inline void upd_chain(ll x,ll y,ll k){
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		upd(1,id[top[x]],id[x],k);
		x=fa[top[x]];
	}
	if(dep[x]<dep[y]) swap(x,y);
	upd(1,id[y],id[x],k);
}
inline bool ask_chain(ll x,ll y){
	vector<ll> P;
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]) swap(x,y);
		ll now=x;while(now!=fa[top[x]]){P.pb(ask(1,id[now])),now=fa[now];if(P.size()>=50) return 1;}
		if(P.size()>=50) return 1;
		x=fa[top[x]];
	}
	if(dep[x]<dep[y]) swap(x,y);
	ll now=x;while(now!=fa[y]){P.pb(ask(1,id[now])),now=fa[now];if(P.size()>=50) return 1;}
	if(P.size()>=50) return 1;
	if(P.size()<3) return 0;
	sort(P.begin(),P.end());
	fo(1,i,P.size()-2) if(P[i-1]+P[i]>P[i+1]) return 1;
	return false;
}
signed main(){
	read(n),read(q);fo(1,i,n) read(a[i]);
	fo(1,i,n-1){ll u,v;read(u),read(v);g[u].pb(v),g[v].pb(u);}
	dfs1(1,0,1),dfs2(1,1);build(1,1,n);
	fo(1,i,q){
		ll opt,u,v,w;read(opt),read(u),read(v);
		if(opt==1) read(w),upd_chain(u,v,w);
		else wr(ask_chain(u,v));
	}
    return 0;
}

``````

---

## 作者：Redshift_Shine (赞：0)

## 闲话

当时，看到“提交题解”四个字的时候，我就觉得这道题可以做了。

做完这道题，我不得不感叹，还是这种树链剖分打得爽啊！

## 题解

首先是经典结论：

定义 $f$ 如下：

$$
f_i=\begin{cases}
1 & i\le 2\\
f_{i-1}+f_{i-2} & \text{otherwise}
\end{cases}
$$

这就是我们熟悉的斐波那契数列，其增长速度极快，以至于 $f_{47}>2^{31}-1$。

那么为什么要提到斐波那契数列呢？

考虑构造一个序列，使得任取数列中三个元素都无法组成三角形。

首先，我们知道，若三条长度分别为 $a,b,c$ 的边可以组成一个三角形，假设 $a<b<c$，就必然满足 $a+b>c$。为了使得条件不成立，我们需要该序列中任何下标三元组 $(i,j,k)$，其中 $i<j<k$，满足 $a_i+a_j\le a_k$。于是我们发现，满足该条件的值域增长最缓慢的序列就是斐波那契数列。

结合题目要求的值域，可以得知，若 $\operatorname{dis}(x,y)>46$，必然会出现一个夹在斐波那契数列中间的数破坏性质，所以可以组成三角形。

解决了这个问题后，树上两点间异或修改点权就是板得不能再板的问题了。直接上树链剖分解决。

不过，由于这道题比较特殊，所以有一个 trick。该 trick 适用于任何仅在叶子节点存储有效信息的线段树。

具体来说，线段树的懒标记只会在线段树的非叶子节点上出现。若非叶子节点上没有任何有效信息，我们可以直接把 tag 搬到线段树数组上，可以减少一定的空间消耗和寻址常数。

时间复杂度 $O(n\log n+m(c\log c+\log^2 n))$。

## 代码

```c++
#include <algorithm>
#include <cctype>
#include <cstdio>
#include <utility>
#include <vector>
using namespace std;
const int N = 1e5 + 10, C = 46;
template <typename _Tp> inline void read(_Tp &x)
{
	char ch;
	while (ch = getchar(), !isdigit(ch))
		;
	x = (ch ^ 48);
	while (ch = getchar(), isdigit(ch))
		x = (x << 3) + (x << 1) + (ch ^ 48);
}
template <typename _Tp, typename... _Args> inline void read(_Tp &x, _Args &...args)
{
	read(x);
	read(args...);
}
int n, m, arr[N], tr[N << 2], idx, buf[100];
int tidx, dfn[N], rnk[N], tp[N], ds[N], f[N], siz[N], dep[N];
vector<int> road[N];
void dfs(int x)
{
	siz[x] = 1;
	dep[x] = dep[f[x]] + 1;
	for (auto &i : road[x])
	{
		if (i == f[x])
			continue;
		f[i] = x;
		dfs(i);
		siz[x] += siz[i];
		if (siz[i] > siz[ds[x]])
			ds[x] = i;
	}
}
void dfs2(int x, int ttp)
{
	tp[x] = ttp;
	dfn[x] = ++tidx;
	rnk[tidx] = x;
	if (!ds[x])
		return;
	dfs2(ds[x], ttp);
	for (auto &i : road[x])
	{
		if (i == f[x] or i == ds[x])
			continue;
		dfs2(i, i);
	}
}
void build(int x, int l, int r)
{
	if (l == r)
	{
		tr[x] = arr[rnk[l]];
		return;
	}
	int mid = (l + r) >> 1;
	build(x << 1, l, mid);
	build(x << 1 | 1, mid + 1, r);
}
void update(int x, int l, int r, int lb, int rb, int v)
{
	if (l >= lb and r <= rb)
	{
		tr[x] ^= v;
		return;
	}
	if (tr[x])
	{
		tr[x << 1] ^= tr[x], tr[x << 1 | 1] ^= tr[x];
		tr[x] = 0;
	}
	int mid = (l + r) >> 1;
	if (lb <= mid)
		update(x << 1, l, mid, lb, rb, v);
	if (rb > mid)
		update(x << 1 | 1, mid + 1, r, lb, rb, v);
}
void extract(int x, int l, int r, int lb, int rb)
{
	if (l == r)
	{
		buf[++idx] = tr[x];
		return;
	}
	if (tr[x])
	{
		tr[x << 1] ^= tr[x], tr[x << 1 | 1] ^= tr[x];
		tr[x] = 0;
	}
	int mid = (l + r) >> 1;
	if (lb <= mid)
		extract(x << 1, l, mid, lb, rb);
	if (rb > mid)
		extract(x << 1 | 1, mid + 1, r, lb, rb);
}
int lca(int x, int y)
{
	while (tp[x] != tp[y])
	{
		if (dep[tp[x]] > dep[tp[y]])
			swap(x, y);
		y = f[tp[y]];
	}
	return dep[x] < dep[y] ? x : y;
}
void extract(int x, int y)
{
	idx = 0;
	while (tp[x] != tp[y])
	{
		if (dep[tp[x]] > dep[tp[y]])
			swap(x, y);
		extract(1, 1, n, dfn[tp[y]], dfn[y]);
		y = f[tp[y]];
	}
	if (dep[x] > dep[y])
		swap(x, y);
	extract(1, 1, n, dfn[x], dfn[y]);
}
void update(int x, int y, int z)
{
	while (tp[x] != tp[y])
	{
		if (dep[tp[x]] > dep[tp[y]])
			swap(x, y);
		update(1, 1, n, dfn[tp[y]], dfn[y], z);
		y = f[tp[y]];
	}
	if (dep[x] > dep[y])
		swap(x, y);
	update(1, 1, n, dfn[x], dfn[y], z);
}
int main()
{
	read(n, m);
	for (int i = 1; i <= n; i++)
	{
		read(arr[i]);
	}
	for (int i = 1, x, y; i < n; i++)
	{
		read(x, y);
		road[x].emplace_back(y);
		road[y].emplace_back(x);
	}
	dfs(1);
	dfs2(1, 1);
	build(1, 1, n);
	for (int i = 1, op = 0, x = 0, y = 0, z = 0, l = 0; i <= m; i++)
	{
		read(op, x, y);
		if (op == 1)
		{
			read(z);
			update(x, y, z);
			continue;
		}
		l = lca(x, y);
		if (dep[x] + dep[y] - dep[l] * 2 + 1 > C or dep[x] + dep[y] - dep[l] * 2 + 1 < 3)
		{
			putchar(dep[x] + dep[y] - dep[l] * 2 + 1 > C ? '1' : '0');
			continue;
		}
		extract(x, y);
		sort(buf + 1, buf + idx + 1);
		for (int j = 3; j <= idx; j++)
		{
			if (buf[j] - buf[j - 1] < buf[j - 2])
			{
				putchar('1');
				break;
			}
			if (j != idx)
				continue;
			putchar('0');
		}
	}
}
```

---

## 作者：封禁用户 (赞：0)

### 题解：
---
这道题主要用到 LCA 和树状数组。

LCA 用来求树上两点之间的最短距离，树状数组用来维护异或差分数组。

~~这道题就怎么结束了，再见同学们。~~

当我们判断点权能否构成三角形时，我们通常都是讲所有点权从小到大排序，然后判断每个 $a_{i-1}+a_{i-2}>a_i$。但是这时候我们就会发现，如果遍历每一个点，那么时间复杂度绝对会炸。此时我们就要思考“优化”方案了。

易得，不能构成三角形的最坏情况是 $a_{i-1}+a_{i-2}=a_i$ 。发现了吗？同学们，像不像“斐波那契数列”？

令斐波那契数列第 $q$ 项为 $g_q$。

枚举可知 $47$ 为最小的 $q$，使得 $g_q>2^{31}-1$。

$\therefore$\
当两点之间点数 $\geq47$，答案为 $1$。\
否则，暴力枚举即可。

---

## 作者：MhxMa (赞：0)

首先来解决第二次询问。

可以考虑将 $a$ 到 $b$ 路径上的点的点权最小到大排序后，记排序后的数组为 $f$。

思考什么时候无法构成三角形，即考虑极端情况，当每 $i$ 满足 $3\leq i,\ f_i \ge f_{i-1}+f_{i-2}$ 时，此时永远无法构成三角形。当点权在 $2^{31}-1$ 以内时，$f$ 最多有 $46$ 个元素，此时为最大值。

即若两点距离大于 $46$ 时，一定可以构成三角形，计算路劲判断即可。至于两点距离小于 $46$ 时，直接通过暴力将路径上的点进行排序即可。


---


接着是第一次询问。

使用树链剖分+线段树解决。树链剖分就是使用树上差分，因为是单点查询，所以线段树可以使用标记永久化维护。

假设 $a$ 到 $b$ 路径长为 $S$，则整个程序的时间复杂度为 $\mathcal{O}((n+q)\times \log n+q\times S \log S)$。

至此程序完，已经有很多大佬贴过代码了，所以这里不再展示代码。

---


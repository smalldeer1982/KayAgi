# [NOIP 2004 提高组] 虫食算

## 题目描述

所谓虫食算，就是原先的算式中有一部分被虫子啃掉了，需要我们根据剩下的数字来判定被啃掉的数字。来看一个简单的例子：

$$\begin{aligned}
 \verb!43#9865#045! \\
+\qquad \verb!8468#6633! \\[-1em]\underline{\kern{8em}} \\
 \verb!44445509678! \\
\end{aligned}$$

其中 `#` 号代表被虫子啃掉的数字。根据算式，我们很容易判断：第一行的两个数字分别是 $5$ 和 $3$，第二行的数字是 $5$。

现在，我们对问题做两个限制：

首先，我们只考虑加法的虫食算。这里的加法是 $n$ 进制加法，算式中三个数都有 $n$ 位，允许有前导的 $0$。

其次，虫子把所有的数都啃光了，我们只知道哪些数字是相同的，我们将相同的数字用相同的字母表示，不同的数字用不同的字母表示。如果这个算式是 $n$ 进制的，我们就取英文字母表的前 $n$ 个大写字母来表示这个算式中的 $0$ 到 $n - 1$ 这 $n$ 个不同的数字：但是这 $n$ 个字母并不一定顺序地代表 $0$ 到 $n-1$。输入数据保证 $n$ 个字母分别至少出现一次。

$$\begin{aligned}
 \verb!BADC! \\
+\quad \verb!CBDA! \\[-1em]\underline{\kern{4em}} \\
 \verb!DCCC! \\
\end{aligned}$$

上面的算式是一个4进制的算式。很显然，我们只要让 $\verb!ABCD!$ 分别代表 $0123$，便可以让这个式子成立了。你的任务是，对于给定的 $n$ 进制加法算式，求出 $n$ 个不同的字母分别代表的数字，使得该加法算式成立。输入数据保证有且仅有一组解。


## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \le 10$；
- 对于 $50\%$ 的数据，保证 $n \le 15$；
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 26$。

## 样例 #1

### 输入

```
5
ABCED
BDACE
EBBAA
```

### 输出

```
1 0 3 4 2
```

# 题解

## 作者：zzlzk (赞：273)

#### 这个题官方正解是高斯消元，可是我不会啊QAQ。


- 说一下搜索怎么做


- 这个题目第一个难点在于你要理解 $ n $ 进制的加法


-  $ n $ 进制的加法就是在十进制的基础上满十进一改成满$ n $ 进一


- 由于这道题只考虑加法，所以进位只可能是 $ 1 $ ，证明小学生都会，略


- 搜索的大体思路就是从第 $1$ 位的值开始搜，搜到最后一位，判断是否合法


-  考虑剪枝


-  $ 3 $ 个字符串的长度都是 $n$ ，由此可以想到一个最简单的剪枝


-  最高位不能有进位

-  如果有进位，显然第 $3$ 个串的长度不会是 $n$ ，而是$n+1$，这并不合法


-  一个剪枝显然不够啊，再想一个


- 文字不太好描述，我们看图（不会用latex写竖式啊QAQ）


   

   ![qwq](https://i.loli.net/2017/08/22/599bd0b8e5d0b.png)

- 假设这是十进制下的加法，怎么判断这个竖式对不对？


- 显然这个竖式是错误的，因为个位上$ (8+6)  mod 10=4 \not=5$


- 由此推广到每一位，但是还要考虑进位，不慌，看另一张图



   ![qwq](https://i.loli.net/2017/08/22/599bd3642a721.png)

- 这个竖式是对的还是错的？


- 这并不好判断，虽然$ (8+6)  mod 10=4 \not=5$，但是这是中间位，有可能有进位


- 如果有进位， 那么$ (8+6+1)  mod 10=5 $，这一位就是合法的了。


- 综合上面的分析，得到了另一个剪枝方法


- 用 $A$ 和 $B$ 表示两个加数，用 $C$ 表示两个加数的和

- 如果某 $i$ 位，满足$(A[i]+B[i])mod\;n\not=C[i]$ 和 $(A[i]+B[i]+1)mod\;n\not=C[i]$


- 根据上面的分析，这种状态肯定不对，直接 $return$ 就好了


- 或许还有别的剪枝，但是这两个应该够用了


- 我的代码里还用了一个玄学的 $next $ 数组，有什么用照着样例手推一遍就知道了，比较好理解。实在看不懂可以私信我qwq


> 学习科学，实用玄学——某钟姓dalao

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
#define maxn 30
int a[maxn],b[maxn],c[maxn];
int num[maxn],Next[maxn],n,cnt;
char s1[maxn],s2[maxn],s3[maxn];
bool used[maxn];
bool Judge() {
    for(int i=n-1,x=0;i>=0;i--) {
        int A=num[a[i]],B=num[b[i]],C=num[c[i]];
        if((A+B+x)%n!=C) return false;
        x=(A+B+x)/n;
    }
    return true;
}
bool CanPrune() {//prune: 剪枝—百度翻译。
    if(num[a[0]]+num[b[0]]>=n)
        return true;
    for(int i=n-1;i>=0;i--) {
        int A=num[a[i]],B=num[b[i]],C=num[c[i]];
        if(A==-1||B==-1||C==-1) continue;
        if((A+B)%n!=C&&(A+B+1)%n!=C)
            return true;
    }
    return false;
}
void Print() {
    for(int i=0;i<n;i++)
        printf("%d ",num[i]);
    exit(0);
}
void dfs(int x) {
    if(CanPrune()==true) return;
    if(x==n) {
        if(Judge()==true) Print();
        return;
    }
    for(int i=n-1;i>=0;i--)
        if(used[i]==false) {
            num[Next[x]]=i;
            used[i]=true;
            dfs(x+1);
            num[Next[x]]=-1;
            used[i]=false;
        }
    return;
}
inline int id(char c) {
    return c-'A';
}
void GetNext(int x) {
    if(used[x]==false) {
        used[x]=true;
        Next[cnt++]=x;
    }
    return;
}
int main() {
    scanf("%d",&n);
    scanf("%s%s%s",s1,s2,s3);
    for(int i=0;i<n;i++) {
        a[i]=id(s1[i]);
        b[i]=id(s2[i]);
        c[i]=id(s3[i]);
        num[i]=-1;
    }
    for(int i=n-1;i>=0;i--) {
        GetNext(a[i]);
        GetNext(b[i]);
        GetNext(c[i]);
    }
    for(int i=0;i<n;i++) used[i]=false;
    dfs(0);
    return 0;
}
```
代码看不懂也可以问我qwq


---

## 作者：feecle6418 (赞：75)

看了各位大佬的题解，还是不是很理解，于是过了之后决定自己写一个，来帮帮像我一样的蒟蒻吧qwq

好的，进入正题

读完题后，我们第一时间想到的肯定是搜索。如何搜索？一种很显然的~~暴力~~搜索方法为枚举 $0$ 至 $n-1$ 的全排列，然后采用回溯法，边搜索边判断合法性，最后输出结果。

这种方法的思路为：
- 读入数据
- 开始搜索
- 第 $i$ 层搜索第 $i$ 个字母的值（即 ```char(i+'A'-1)```）的值，采用一个```judge```函数判断合法性
- 当搜索完所有字母并且全部合法后，直接输出，退出程序

主要代码如下：
```
char a[30],b[30],c[30];
int t[300],used[30];
int n;
bool ok_(){
    for(int i=n;i>=1;i--){
        if(t[a[i]]==-1||t[b[i]]==-1||t[c[i]]==-1)continue;
        if((t[a[i]]+t[b[i]])%n!=t[c[i]]){
            if((t[a[i]]+t[b[i]]+1)%n!=t[c[i]])return 0;
        }
    }
    return 1;
}
void Try_(){
    int jw=0;
    for(int i=n;i>=1;i--){
        int s=t[a[i]]+t[b[i]]+jw;
        if(t[c[i]]!=s%n)return ;
        jw=s/n;
    }
    cout<<t['A'];
    for(int i='A'+1;i<='A'+n-1;i++)cout<<' '<<t[i];
    exit(0);//直接结束程序，头文件"cstdlib"
}
void dfs(int now){
    //产生0到n-1的全排列 
    if(now>n){
        Try_();
        return ;
    }
    for(int i=n-1;i>=0;i--){//注意倒序搜索
        if(used[i])continue;
        t[now+'A'-1]=i;
        if(ok_()){
            used[i]=1;
            dfs(now+1);
            used[i]=0;
        }
    }
    t[now+'A'-1]=-1;
}
```

这样，可以拿到 $50$ 分。

那么如何拿到 $100$ 分呢？

我们发现，```ok_()```函数并没有为我们消除太多的搜索情况。因为搜索顺序是按照字母顺序来搜的，很难碰到三个字母都搜过的情况，因此还不够快。

于是，我们想到了另一个剪枝：改变搜索顺序，从等式的**最低位的字母**开始搜。一位一位往前搜。例如样例
```
ABCED
BDACE
EBBAA
```
我们的搜索顺序即为：```DEACB```。这样便可以获得 $100$ 分。具体代码实现如下：
```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<string>
#include<cstdlib>
using namespace std;
char a[30],b[30],c[30];
int t[300],used[30],p[30],u[30],y;
int n;
bool ok_(){
    for(int i=n;i>=1;i--){
        if(t[a[i]]==-1||t[b[i]]==-1||t[c[i]]==-1)continue;
        if((t[a[i]]+t[b[i]])%n!=t[c[i]]){
            if((t[a[i]]+t[b[i]]+1)%n!=t[c[i]])return 0;
        }
    }
    return 1;
}
void Try_(){
    int jw=0;
    for(int i=n;i>=1;i--){
        int s=t[a[i]]+t[b[i]]+jw;
        if(t[c[i]]!=s%n)return ;
        jw=s/n;
    }
    cout<<t['A'];
    for(int i='A'+1;i<='A'+n-1;i++)cout<<' '<<t[i];
    exit(0);
}
void dfs(int now){
    //产生0到n-1的全排列 
    if(now>n){
        Try_();
        return ;
    }
    for(int i=n-1;i>=0;i--){
        if(used[i])continue;
        t[p[now]+'A'-1]=i;
        if(ok_()){
            used[i]=1;
            dfs(now+1);
            used[i]=0;
        }
    }
    t[p[now]+'A'-1]=-1;
}
int main(){
    memset(t,-1,sizeof(t));
    scanf("%d",&n);
    scanf("%s%s%s",a+1,b+1,c+1);
    for(int i=n;i>=1;i--){
        if(!u[a[i]-'A'+1])p[++y]=a[i]-'A'+1,u[a[i]-'A'+1]=1;
        if(!u[b[i]-'A'+1])p[++y]=b[i]-'A'+1,u[b[i]-'A'+1]=1;
        if(!u[c[i]-'A'+1])p[++y]=c[i]-'A'+1,u[c[i]-'A'+1]=1;
    }
    dfs(1);
    return 0;
}
```

当然，以上的剪枝仅仅是所有剪枝中的皮毛。限于篇幅，这里不再赘述，有兴趣的读者可以自行优化，给出一些提示：
- ```ok_()```函数是否可以给我们消除更多的情况？比如，已经搜过了两个加数的第 $x$ 位分别值为 $a,b$，但是 $used[(a+b)\ mod\ n]$ 和 $used[(a+b+1)\ mod\ n]$ 都已经为 $true$，那么是不是可以被剪掉？
- 最高位能否有进位？想想为什么？
- ......

---

## 作者：BakaC1rno (赞：14)

以样例为例子，

![](https://cdn.luogu.com.cn/upload/pic/49117.png )

我们可以用未知数x将字母代替，将等式写成这样:

![](https://cdn.luogu.com.cn/upload/pic/49118.png )

其中，r是在字母所代表的值上增加的数，例如D+E=A+r1，此时r1的值是5

将未知数全移动到左边，得到：

![](https://cdn.luogu.com.cn/upload/pic/49116.png )

这样一来，只要我们搜索每个r的值，然后将方程解出来就好了

但是r的值有2的26次方种，运用高斯消元解方程又要26^3次运算，肯定超时了啊，那我们考虑先用高斯消元法表示出每个x，再搜索r的值，最后判断答案是否符合要求就行了

我们用矩阵将系数存起来：

![](https://cdn.luogu.com.cn/upload/pic/49121.png )

经过高斯消元，得到

![](https://cdn.luogu.com.cn/upload/pic/49122.png )

本质上就是
![](https://cdn.luogu.com.cn/upload/pic/49124.png )

然后我们搜索r的值，算出x的值，值得注意的是，ri的初始值取决于r(i-1)的决策，如果r(i-1)保持初始值不变，那么ri的初始值为0，如果r(i-1)在初始值的基础上+n，那么ri的初始值则为-1。那么显然rn不能+n，r1的初始值只能为0。

关于判断答案是否符合要求，看每个x是否小于0，或大于等于n，还要主意不同的字母代表不同的值

代码写得丑，仅供参考

```cpp
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
using namespace std;
int n,lcn,multi,multj;
struct HAHA{
	int coe[30][30];
	int con[30][30];
}squre;
int num[30];

void read()
{
	cin>>n;
	string s1,s2,s3;
	cin>>s1>>s2>>s3;
	for(int i=1;i<=n;i++)
	{
		int pos=n-i;
		int c1=s1[pos]-'A'+1;squre.coe[i][c1]++;
		int c2=s2[pos]-'A'+1;squre.coe[i][c2]++;
		int c3=s3[pos]-'A'+1;squre.coe[i][c3]--;
		squre.con[i][i]=1;
	}	
}

int gcd(int a,int b)
{
	if(b==0) return a;
	return gcd(b,a%b);
}

void gauss()
{
	
	for(int i=1;i<=n;i++)
	{
		int vec=i;
		for(int j=i+1;j<=n;j++) { if(abs(squre.coe[vec][i])<abs(squre.coe[j][i])) vec=j; }
		if(vec!=i)
		{ 
			for(int j=1;j<=n;j++) {swap(squre.coe[i][j],squre.coe[vec][j]);swap(squre.con[i][j],squre.con[vec][j]);}
		}
		for(int j=1;j<=n;j++)
		{
			if(squre.coe[j][i]!=0&&j!=i)
			{
				lcn=squre.coe[j][i]*squre.coe[i][i]/gcd(squre.coe[i][i],squre.coe[j][i]);
				multi=lcn/squre.coe[i][i];
				multj=lcn/squre.coe[j][i];
				for(int k=1;k<=n;k++)
				{
					squre.coe[j][k]=squre.coe[j][k]*multj-squre.coe[i][k]*multi;
					squre.con[j][k]=squre.con[j][k]*multj-squre.con[i][k]*multi;
				}
			}
		}
	}
}

void judge()
{
	bool flag=true;
	int unk[30];
	int dead[30];
	for(int i=0;i<=n;i++) dead[i]=0;
	for(int i=1;i<=n;i++)
	{
		unk[i]=0;
		for(int j=1;j<=n;j++) unk[i]+=squre.con[i][j]*num[j];
		if(unk[i]%squre.coe[i][i]!=0) return;
		else unk[i]/=squre.coe[i][i];
		if(unk[i]<0||unk[i]>=n||dead[unk[i]]==1){flag=false;break;}
		dead[unk[i]]=1;
	}
	if(flag==true)
	{
		for(int i=1;i<=n;i++) cout<<unk[i]<<" ";
		cout<<endl;
		exit(0);
	}
}

void dfs(int pos,int value)
{
	num[pos]=value;
	if(pos==n)
	{
		judge();
		return;
	}
	dfs(pos+1,0);
	num[pos]=value+n;
	dfs(pos+1,-1);
}

int main()
{
	read();
	gauss();
	dfs(1,0);
	return 0;
}
```

---

## 作者：KaguyaH (赞：3)

# [虫食算](https://www.luogu.com.cn/problem/P1092)

- 既然放在试炼场-PJ-深搜里面，就说明深搜可做。

- 考虑深搜。

- 当然是要搜索每个字母代表什么，考虑搜索顺序。

### 按字母顺序搜索

- 暴力枚举所有全排列是O(n!)的。过不去。

- 考虑剪枝。

- 见[这篇题解](https://www.luogu.com.cn/blog/zzlzk/solution-p1092)。

### 按算式顺序搜索

- 竖式计算是从右往左计算的。考虑从右往左依次使每一位的竖式都成立。

- 假设当前为的竖式为

```
	a + b + d = c//d为上次搜索求得的进位。
```

- 若a，b，c均已知
    - 若a + b + d = c
        - 搜索下一位
    - 否则
        - 剪枝
- 若a，b已知
    - 求出c
    - 若c与之前求出的某数相等
        - 剪枝
    - 否则
        - 搜索下一位
- 若仅a已知
    - 枚举b
    - 当作a，b已知来做
- 以此类推。
    

- [231行的代码](https://www.luogu.com.cn/paste/z0fomlrq)。
- 但是TLE了一个点。

- 考虑剪枝。（好吧我承认怎么搜都得剪枝）

- 综合[这篇题解](https://www.luogu.com.cn/blog/zzlzk/solution-p1092)中的剪枝，可以AC。

- [244行的AC代码](https://www.luogu.com.cn/paste/s8cik0k6)。

---

## 作者：Tgotp (赞：1)

\*44ms，算比较快的了吧。

思路如下：

如果知道此列两个数，就可以求第三个数（知二求一嘛！）

然后如果没有满足的条件，就只用管第一列的，这样避免了很多实质性重复的操作。剪短了代码！

然后重点是，每次都要判断当前式子是否成立，如果一列三个都知道的话，且无论进位与否都不满足，就可以直接返回。（很多人90应该就是没想到这）这样的话减少大量的重复性操作。












```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
using namespace std;
const int N = 25 + 2;
char a[N],b[N],c[N];
int num[N],n,k[N];
bool pan[N],ban[N];
bool pd(int i)
{
     while(i--)
     {
         if(pan[a[i]] && pan[b[i]] && pan[c[i]])
         {
             int k=num[a[i]]+num[b[i]];int x=num[c[i]];
             if((k+1)%n==x || k%n==x || (k+n-1)%n==x)continue;
            else return true;
         }
     }
     return false;
}
void dfs(int temp)
{
    if(temp == -1)
    {
        for(int i=0;i<n;i++)printf("%d ",num[i]);
        exit(0);
    } 
    else 
    {
        if(pd(temp))return;
        if(pan[a[temp]] && pan[b[temp]] && pan[c[temp]] )
        {
            if((num[a[temp]]+num[b[temp]]+k[temp])%n == num[c[temp]])
            {
                k[temp-1]+=(num[a[temp]]+num[b[temp]]+k[temp])/n;
                dfs(temp-1);
                k[temp-1]-=(num[a[temp]]+num[b[temp]]+k[temp])/n;
            }
            else return;
        }
        else if(pan[a[temp]] && pan[b[temp]]) 
        {
            if(ban[(k[temp]+num[a[temp]]+num[b[temp]])%n]) return;
            num[c[temp]]=(k[temp]+num[a[temp]]+num[b[temp]])%n;
            ban[num[c[temp]]]=true;
            pan[c[temp]]=true;
            k[temp-1]+=(k[temp]+num[a[temp]]+num[b[temp]])/n;
            dfs(temp-1);
            pan[c[temp]]=false;
            ban[num[c[temp]]]=false;
            k[temp-1]-=(k[temp]+num[a[temp]]+num[b[temp]])/n;
        }
        else if(pan[a[temp]] && pan[c[temp]]) 
        {
            if(ban[(num[c[temp]]+n-k[temp]-num[a[temp]])%n]) return;
            num[b[temp]]=(num[c[temp]]+n-k[temp]-num[a[temp]])%n;
            ban[num[b[temp]]]=true;
            pan[b[temp]]=true;
            k[temp-1]+=(k[temp]+num[a[temp]]+num[b[temp]])/n;
            dfs(temp-1);
            pan[b[temp]]=false;
            ban[num[b[temp]]]=false;
            k[temp-1]-=(k[temp]+num[a[temp]]+num[b[temp]])/n;
        }
        else if(pan[b[temp]] && pan[c[temp]]) 
        {
            if(ban[(num[c[temp]]+n-k[temp]-num[b[temp]])%n]) return;
            num[a[temp]]=(num[c[temp]]+n-k[temp]-num[b[temp]])%n;
            ban[num[a[temp]]]=true;
            pan[a[temp]]=true;
            k[temp-1]+=(k[temp]+num[a[temp]]+num[b[temp]])/n;
            dfs(temp-1);
            pan[a[temp]]=false;
            ban[num[a[temp]]]=false;
            k[temp-1]-=(k[temp]+num[a[temp]]+num[b[temp]])/n;
        }
        else if(pan[a[temp]])
        {
            for(int i=n-1;i>=0;i--)
            {
                if(!ban[i])
                {
                    num[b[temp]]=i; 
                    ban[i]=true;
                    pan[b[temp]]=true;
                    dfs(temp);
                    ban[i]=false;
                    pan[b[temp]]=false;
                }
            }
        }
        else
        {
            for(int i=n-1;i>=0;i--)
            {
                if(!ban[i])
                {
                    num[a[temp]]=i;
                    ban[i]=true;
                    pan[a[temp]]=true;
                    dfs(temp);
                    ban[i]=false;
                    pan[a[temp]]=false;
                }
            }
        }
    } 
} 
int main()
{
    cin>>n;
    scanf("%s%s%s",a,b,c);
    for(int i=0;i<n;i++)
    {
        a[i]-='A';
        b[i]-='A';
        c[i]-='A';
    }
    dfs(n-1);
    return 0;
}
```
/\*
5
ABCED
BDACE
EBBAA
\*/

---


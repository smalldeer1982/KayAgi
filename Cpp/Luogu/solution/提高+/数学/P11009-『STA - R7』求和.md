# 『STA - R7』求和

## 题目描述

Lloyd 有一个正整数 $t$，初始 $t=2$ 或 $t=3$。每次他可以令 $t$ 加上 $2^t$ 或者 $\lfloor\log_2(t-1)\rfloor$。

令 $f(x)$ 是操作得到 $t=x$ 的最小操作次数，若无法操作得到 $x$ 则 $f(x)=0$。

现在给定一个正整数 $n$，你需要求 $\sum_{i=1}^nf(i)$ 的值。答案可能很大，对 $998244353$ 取模。

## 说明/提示

数据范围：
- Subtask 1 (10pts)：$n\le 10^7$。
- Subtask 2 (30pts)：$T=1$。
- Subtask 3 (30pts)：$n\le2^{40}$。
- Subtask 4 (30pts)：无特殊限制。

对于全部数据，$1\le T\le 10^4$，$1\le n\le2^{60}$。

## 样例 #1

### 输入

```
7
1
10
1000000
10000000
1000000000
1000000000000
1000000000000000000
```

### 输出

```
0
16
922782102
752337093
360487662
955916859
689020696
```

# 题解

## 作者：jijidawang (赞：7)

首先注意到 $x+\lfloor\log_2(x-1)\rfloor$ 是单调递增的，然而 $x=2^n$ 时取 $2^n+n-1$，$x=2^n+1$ 时取 $2^n+n+1$，所以一个数是不可能被同时表示为 $x+\lfloor\log_2(x-1)\rfloor$ 和 $x+2^x$ 的形式的，也就是说操作得到每个数的方案都是唯一的。

令值域为 $V$，注意到对大于 $\log V$ 的数 $n$ 操作 $n\gets n+2^n$ 并没有什么用，所以考虑分别将路径中的元素按和 $\log V$ 的大小关系分段，对于 $[2,\log V]$ 内的数 $x$ 先处理出到 $x$ 的路径长度 $p_x$，然后只需要计算从每个 $x+2^x$ 出发只用 $n\gets n+\lfloor\log_2(n-1)\rfloor$ 操作得到每个点的路径长度之和即可。这里可以按 $\lfloor\log_2(n-1)\rfloor$ 分段，每段都是一个等差数列，是容易计算的。

那么就得到了一个 $\Theta(T\log^2V)$ 的算法，已经可以通过本题了。事实上可以证明 $\ge2$ 的每个数都可以被操作得到，但是对解决这个题目并没有什么用。

Bonus：如何做到 1 log？

---

## 作者：chenly8128 (赞：6)

难是不难，但是细节挺多的。

思路：列表+找规律

实现：部分打表+预处理+分段查询
## 思路部分
### 列表
我们从 $i = 3$ 开始，对于 $f(i)$ 列表（$i = 1$ 或者 $n = 2$ 可以特判，答案都是 0）。
![](https://cdn.luogu.com.cn/upload/image_hosting/u8gz11t2.png)
表格中列出了 $i$ 与 $f(i)$ 的关系。可以清晰的看到，对与第 $k$ 组，$i \in \left ( 2^k,2^{k+1}\right ]$。而在这个范围内的 $i$ 按照 $k$ 个数为一轮的规律循环（最后一轮特例），每一轮每个数都增加 1。
### 规律与证明
两种操作中：

- 第一种操作**一定优于**第二种操作。

- 第一种操作的次数极少，因为仅当 $t \in \left [ 2,\log_2 (n)\right ]$ 时 $t + 2^t \leq n$。又因为 $1 \leq n \leq 10^{18} $，所以 $t$ 仅能取 $\left [ 2,\log_2 (10^{18})\right ] \approx \left [ 2,60\right ]$。次数很少，可以近似地当作常数。恰好，按照上文的分组，**每组中由第一种操作 $t + 2^t$ 得到的值有且仅有一个**，并且出现在第一个循环的最后一个数中。

- 绝大部分操作都为第二种操作，而第二种操作中的 $\lfloor\log_2(t-1)\rfloor$ 很明显可以分段。按照上文的分组，每个组中 $\lfloor\log_2(t-1)\rfloor$ 是固定的，即对于第 $k$ 组中的任意 $t$，$\lfloor\log_2(t-1)\rfloor = k$。

这就说明了为什么第 $k$ 组的循环是 $k$ 个数一轮，并且每个数逐轮增加。

## 实现部分
### 部分打表
由于操作 1 的次数很少并且 $t$ 仅能取 $\left [ 2,60\right ]$，所以我们可以通过手工计算的方法，把 $t$ 在 $\left [ 2,60\right ]$ 范围内时 $f(t)$ 的值都计算出来。详见程序。
### 预处理

我们需要预处理以下几个值，方便计算。

- $v_{k,j}$ 表示第 $k$ 组第一个循环中的第 j 个的值。
- $sum_k$ 表示第 $k$ 组第一个循环数字的总和。
- $rs_k$ 表示第 $k$ 组中所有数的总和。

这三个值我们需要按照顺序计算，数组 $v_k$ 可以根据 $v_{k-1}$ 和第 k 个数字在打好的表中的答案求出。
其它两个根据 $v$ 计算，比较简单。

### 分段查询

对于题目给出的 $n$，我们分为 $\lceil\log_2(n)\rceil-1$ 组。前面完全包含的 $n-1$ 组，直接在答案上用 $rs_k$ 累加即可。最后一组用和预处理类似的方法计算。

### 代码
有点丑，前面没看懂的可以通过代码尝试理解。

效率还可以是目前最优解。
```cpp

// Author: chenly8128
// Created: 2024-08-26 15:05:29

#include <bits/stdc++.h>
using namespace std;
const int mod = 998244353;
int kase;
long long n;
vector <long long> v[64];
long long sum[64];
long long rs[64];
const long long l[70] = {0,0,0,0,1,2,1,3,2,4,3,1,5,4,2,6,5,3,7,6,2,4,8,7,3,5,9,8,4,6,10,9,5,7,11,10,6,3,8,12,11,7,4,9,13,12,8,5,10,14,13,9,6,11,15,14,10,7,12,16,15,11,8,13,17};
int main (void) {
	v[1].resize(1,0);
	sum[1] = 0;rs[1] = 1;
	for (int i = 2;i <= 61;i++) {
		v[i].clear();int t = 0;
		for (int j = (1l<<(i-1))%(i-1);t < i-1;j = (j+1)%(i-1),t++) {
			v[i].push_back((v[i-1][j]+((1l<<(i-1))-j+t)/(i-1))%mod);
			sum[i] = (sum[i]+v[i][t])%mod;
		}
		v[i].push_back(l[i]+1);
		sum[i] += l[i]+1;
		rs[i] = sum[i] * ((1l<<i)/i%mod) % mod;
		long long k = ((1l<<i)/i)%mod;
		rs[i] = (rs[i]+k*(k-1)/2%mod*i)%mod;
		for (int j = 0;j < (1l<<i)%i;j++)
			rs[i] = (rs[i] + v[i][j] + k)% mod;
		rs[i] %= mod;
	}
	scanf ("%d",&kase);
	while (kase--) {
		scanf ("%lld",&n);
		if (n <= 3) {
			puts ("0");
			continue;
		}
		long long res = 0;int i;
		for (i = 1;1l<<(i+1) < n;i++) {
			res = (res+rs[i])%mod;
		}
		res %= mod;
		long long k = (n-(1l<<i))/i%mod;
		res = (res + sum[i] * k % mod);
		res = (res+(k-1)*k/2%mod*i)%mod;
		for (int j = 0;j < (n-(1l<<i))%i;j++)
			res = (res+v[i][j]+k)%mod;
		res %= mod;
		printf ("%lld\n",res);
	}
	return 0;
}
```

---

## 作者：arrowpoint (赞：1)

这道题我考场上调了好久没过，玩了几把游戏后看了几眼立马就调过了...

首先我们发现第一个部分分是非常好拿的，只需要预处理出题目需要的值就可以暴力计算。


```cpp
	memset(f,0x3f,sizeof f);
	f[2] = f[3] = 0;
	po2[0] = 1;
	for(int i=1;i<=1e7+1;i++){
		po2[i] = (po2[i-1]*2);
		if(po2[i]>1e9) break;
	}
	for(int i=2;i<=1e7+1;i++){
		lo2[i] = lo2[i>>1]+1;
	}
	for(int i=2;i<=1e7+1;i++){
		if(i+po2[i]<=1e7+5) f[i+po2[i]] = min(f[i+po2[i]],f[i]+1);
		if(i+lo2[i-1]<=1e7+5) f[i+lo2[i-1]] = min(f[i+lo2[i-1]],f[i]+1);
	}
	for(int i=1;i<=1e7+1;i++){
		if(f[i]>1e16){
			pre[i] = pre[i-1];
		}
		else pre[i] = (pre[i-1]+f[i])%M;
	}
	int t;
	cin>>t;
	while(t--){
		cin>>n;
		cout<<pre[n]<<endl;
	}
```

实际上我们可以用此程序打出 $f$ 数组约前 $64$ 个数的表，放在一旁备用。

接下来我们观察题目。不难发现第一个操作仅在 $t \le 64$ 的时候有效。而对于第二个操作，我们将 $10^{18}$ 以内所有数按 $\log _2 (i-1)$ 的值分块，每个块内每次加的数都是相等的，且一共只会分到约 $60$ 个块。

显然第一个操作并不好处理。我们根据之前打的表进行观察，容易发现 $t$ 到每个数都最多只进行过 $1$ 次第一个操作。也就是说，如果我们把每个数根据从哪个数开始使用第一次操作再次分块，那么每个块都会形成一个等差数列。对于第 $i$ 个数形成的等差数列，这个等差数列的首项就是 $f_i+1$，项数可以对每个块分别计算（由于每个块内加的数都一样，可以 $O(1)$ 计算），公差就是 $1$，直接套用等差数列求和公式即可。

注意项数是 $10^{16}$ 数量级以上的，需要先取模再套公式。并且由于在公式末尾除以 $2$ 之前已经取过模，还应求出 $2$ 的逆元 $499122177$。

代码来喽！


```cpp
#include<bits/stdc++.h>
#define int long long
#define endl '\n'
using namespace std;

const int N = 10005;
const int M = 998244353;
int n,m,a[N];
int po2[100];
int st[70][100];
int stnum[70][100];
int rst[70];
int f[1000] = {0,0,0,0,1,2,1,3,2,4,3,1,5,4,2,6,5,3,7,6,2,4,8,7,3,5,9,8,4,6,10,9,5,7,11,10,6,3,8,12,11,7,4,9,13,12,8,5,10,14,13,9,6,11,15,14,10,7,12,16,15,11,8,13,17,16,12,9,14,18,2,17,13,10,15,19,3,18,14,11,16,20,4,19,15,12,17,21,5,20,16,13,18,22,6,21,17,14,19,23,7};

inline int get(int x){
	x--;
	int cnt = 0;
	while(x>1){
		cnt++;
		x >>= 1;
	}
	return cnt;
}
inline int cal(int x,int len){
	return (((x+x+len-1)%M*(len%M))%M*499122177ll)%M;
}

signed main(){
	ios::sync_with_stdio(false);
	po2[0] = 1;
	for(int i=1;i<=61;i++){
		po2[i] = po2[i-1]*2;
	}
	for(int i=1;i<=61;i++){
		int need = i+po2[i];
		if(i==1) need = 4;
		int pos = get(need);
		st[i][pos] = need;
		stnum[i][pos] = 1;
		rst[i] = f[i]+1;
		//cout<<i<<' '<<pos<<' '<<st[i][pos]<<' '<<stnum[i][pos]<<endl; 
		for(int j=pos+1;j<=61;j++){
			int tmpst = po2[j];
			st[i][j] = tmpst+(j-1-(tmpst-st[i][j-1])%(j-1));
			stnum[i][j] = stnum[i][j-1]+(st[i][j]-st[i][j-1])/(j-1);
			//cout<<i<<' '<<j<<' '<<st[i][j]<<' '<<stnum[i][j]<<endl; 
		}
	}
	
	int t;
	cin>>t;
	while(t--){
		cin>>n;
		int tmpn = get(n);
		int ans = 0;
		for(int i=1;i<=61;i++){
			int addn = 0,endn = 0;
			if(i+po2[i]>n) break;
			if(n<st[i][tmpn]){
				endn = stnum[i][tmpn]-1;
			}
			else{
				endn = stnum[i][tmpn]+(n-st[i][tmpn])/tmpn;
			}
			//cout<<i<<' '<<endn<<endl;
			//cout<<endn*2<<endl;
			ans = (ans+cal(rst[i],endn))%M;
			//cout<<ans<<endl;
		}
		cout<<ans<<endl;
	}
	
	return 0;
}
```

---


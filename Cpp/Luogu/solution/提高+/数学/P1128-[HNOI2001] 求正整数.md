# [HNOI2001] 求正整数

## 题目描述

对于任意输入的正整数 $n$，请求出具有 $n$ 个不同因子的最小正整数 $m$。

例如：$n=4$，则 $m=6$，因为 $6$ 有 $4$ 个不同整数因子 $1,2,3,6$；而且是最小的有 $4$ 个因子的整数。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \leq n \leq 5 \times 10^4$。

## 样例 #1

### 输入

```
 4
```

### 输出

```
6
```

# 题解

## 作者：_rqy (赞：67)

@wangtianyi @天下第一剑客 这里是泥萌的错误及解决方案之一：

当输入为$8$的时候，答案应为$24 = 2^3*3$, 而非$30 = 2*3*5$。

既然贪心行不通，我们来考虑DP。
令$f_{i, j}$表示所有只包含前$j$个质因数的数中，因数个数为$i$的最小的数。

那么，根据因数个数公式

$$\tau(n)=\prod_i(k_i+1), \rm{where}\;n=\prod_i p_i^{k_i}$$

转移时枚举最后一个质因子的次数，我们有

$$f_{i, j} = \min_{k|i}\left(f_{\frac ik, j-1}p_j^{k-1}\right)$$

显然我们是不能高精dp的（随便输入了一个28493得到的答案有8577位十进制，想要高精dp的自己算算复杂度就好了）。那么考虑取对数，dp变成了

$$f_{i, j} = \min_{k|i}\left(f_{\frac ik, j-1}+(k-1)\log p_j\right)$$

最后要求结果的时候只要找到转移的方向把对应的$p_j^{k-1}$乘上去就好了。高精乘单精挺好写的。

```cpp
#include <algorithm>
#include <cstdio>
#include <cmath>
#include <map>
const int N = 50050;
const int p[20] = {
   2,  3,  5,  7, 11,
  13, 17, 19, 23, 29,
  31, 37, 41, 43, 47,
  53, 59, 61, 67, 71
};
double logp[20];
double f[505][20];
int d[505];
int cnt;
int A[100000], len;
void mul(int x) {
  int v = 0;
  for (int i = 0; i < len; ++i) {
    v = (A[i] = A[i] * x + v) / 10;
    A[i] %= 10;
  }
  while (v) A[len++] = v % 10, v /= 10;
}
int main() {
  int n, m = 0;
  scanf("%d", &n);
  for (int i = 1; i <= n; ++i) if (!(n % i)) d[m++] = i;
  for (int i = 0; i < 20; ++i) f[0][i] = .0;
  for (int i = 0; i < 20; ++i) logp[i] = log(p[i]);
  for (int i = 1; i < m; ++i) {
    for (int k = 0; k < 20; ++k)
      f[i][k] = 1e9;
    for (int j = 0; j < i; ++j) if (!(d[i] % d[j])) {
      int t = d[i] / d[j];
      for (int k = 1; k < 20; ++k)
        f[i][k] = std::min(f[i][k], f[j][k - 1] + logp[k - 1] * (t - 1));
    }
  }
  A[0] = len = 1;
  int j = 0;
  for (int i = 0; i < 20; ++i) if (f[m - 1][i] < f[m - 1][j]) j = i;
  for (int i = m - 1, nxt; i; i = nxt, --j) {
    for (nxt = 0; d[i] % d[nxt] || f[i][j] < f[nxt][j - 1]
        + logp[j - 1] * (d[i] / d[nxt] - 1) - 1e-5; ++nxt);
    for (int k = 1; k < d[i] / d[nxt]; ++k)
      mul(p[j - 1]);
  }
  while (len--) printf("%d", A[len]);
  return 0;
}

```

---

## 作者：throusea (赞：17)

主要是对DFS做法的补充。

### [题目描述](https://www.luogu.org/problemnew/show/P1128)

给出几个要点：

   1、公式：
   

$N$可以分解质因数：$N$=p1^a1×p2^a2×p3^a3*…*pk^ak, （ai为每个质因子的指数）
   
   由约数定义可知p1^a1的约数有:p1^0, p1^1, p1^2......p1^a1 ，共（a1+1）个;同理p2^a2的约数有（a2+1）个......pk^ak的约数有（ak+1）个。
   
   故根据乘法原理：$N$的约数的个数就是(a1+1)(a2+1)(a3+1)…(ak+1)。

   而题目的意思是要求约数个数为$n$的$N$的最小值。
   
   也就是说通过$N$的约数个数之和（$N$的约数个数已知）求出每个ai的过程为DFS的过程。那么最终答案为**$N$分解质因数的逆过程**。
   
   **最多可以用到的质因数个数为16**，log(50000)=16。(底数为2)。
                                  
------------

   2、剪枝:
    
   建议在搞清楚如何DFS后食用更佳。～～
    
   直接的DFS是一定会TLE的，我们考虑几个剪枝：
    
   （1）如果当前得到的答案不比现在优，那么它以后也不会更优。这是显而易见的。 （最优性剪枝）
       
   但这个数实在太大了（最大有质数49999，它的答案为2^49998）。我们不能用**long long**来存，我们更不能用高精，那样子时间复杂度就太高了。所以我们考虑用对数来存。最后的答案用**数组保存每一个质因数的指数**即可。
    
   对数的公式：(为了方便默认底数相同且大于1)
    
   1. log(a*b)=log(a)+log(b);
       
       推广： log(a^b)=b*log(a);
    
   2. log(x1)>log(x2) (x1>x2);
    
   公式变为$N$=p1^a1×p2^a2×p3^a3*…*pk^ak => log($n$)=(累加)ai*log(pi);
    
   于是我们就可以用对数来比较大小了，c++函数库的cmath有这个函数log()(c++默认底数为e，约为2.6),且返回值为 **double** 型，我们在DFS过程中直接计算即可。
    
   （2）如果当前搜到的数不能被tol(一个记录中间答案的东西，初始为$n$)整除，
    则这个数一定不会用到。 （可行性剪枝）
    
   （3）注意一个问题，log()函数在c++中的计算是很耗时间的，建议先用数组保存。
    
    
3、最后用高精乘低精即可。


------------


代码：
```cpp
#include<cstdio>
#include<cmath>
#include<cstring>
using namespace std;
const int maxn=50000;
int f[21],ans[21],a[10000];
int ansd[1000000];
int len,n,k;
bool vis[maxn];
double ansx=1000000000,lg[1000];  //g为第g个质因数。
void dfs(int tol,double d,int g){ //d为当前的答案（用log缩小）
    if(ansx<d||g==16) return; //剪枝1
    if(tol==1){
        if(ansx>d){
            memcpy(ans,f,sizeof(f));
            ansx=d;
        }
        return;
    }
    for(int i=0;(i+1)*(i+1)<=tol;i++)
    if(tol%(i+1)==0){  //剪枝2
        f[g]=i;
        dfs(tol/(i+1),d+f[g]*lg[a[g]],g+1);
        f[g]=tol/(i+1)-1;
        dfs(i+1,d+f[g]*lg[a[g]],g+1);
        f[g]=0;
    }
}

void mem(){  //线性筛求素数，没有必要。
    vis[1]=1;
    int m=sqrt(maxn+0.05);
    for(int i=2;i<=m;i++)
    if(!vis[i]){
        for(int j=i*i;j<maxn;j+=i)
        vis[j]=1;
    }
    for(int i=2;i<=maxn;i++)
    if(!vis[i]){
        a[k]=i;
        if(k<=20) lg[a[k]]=log(a[k]);
        k++;
    }
}

int main(){
    mem();
    scanf("%d",&n);
    dfs(n,0,0);
    int top=0,x=0;
    ansd[0]=1;
    for(int i=0;i<=20;i++)
    while(ans[i]){  //高精乘低精
        ans[i]--;
        x=0;
        for(int j=0;j<=top;j++){
            ansd[j]=a[i]*ansd[j]+x;
            if(ansd[j]>=10){
                x=ansd[j]/10;
                ansd[j]=ansd[j]%10;
                if(j==top) top++;
            }else x=0;
        }
    }
    for(int i=top;i>=0;i--)
    printf("%d",ansd[i]);
    printf("\n");
    return 0;
}
```

其实这个代码过不了大素数（49999），如果优化需要加快速幂。

如果要精益求精就码吧。


## 题外话：

[题目链接[最多因子数]](https://www.luogu.org/problemnew/show/P1221)

做完了这道题建议看一下最多因子数，大同小异。

---

## 作者：FZzzz (赞：13)

今天模拟赛题，懒得写高精用 `python` 打表，结果剪枝写错白丢 $80$，悲。

------------
高精题怎么能没有 `python` 题解呢！

啥？你说这题 `C++` 都得取对数才能卡过去？

咳咳，其实这篇题解讲的不是 `python`，而是一个很强力的剪枝。

暴搜的思路应该是不难想到的。~~因为我们今天模拟赛是三道搜索题。~~

根据唯一分解定理，如果 $m=\prod\limits_{i=1}^pp_i^{t_i}$，$p_i$ 为质数，那么 $m$ 有 $\prod\limits_{i=1}^p(t_i+1)$ 个因子。

对应到本题，每一个 $t_i+1$ 就是 $n$ 的一个因子。所以我们只需要枚举 $n$ 的每一种分解，然后将它们减去一作为不同质数的指数，乘起来就可以了。

然后我们来剪枝。

用哪几个质数呢？很显然，肯定是最小的那几个。

同时因为即使全分成二，因子也不会超过 $17$ 个，所以我们只需要提前算好前多少个质数。

那我们搜索的时候可以记一下当前用的是哪个质数。

同时，如果我们有同一种分解方式，我们把哪个数给哪个质数呢？肯定是把大数给小质数。

所以我们可以再记一下以前用过的最小数，然后以后再拆就只枚比它小的。

这样我们就可以用 `python`，并且不用取对数就可以通过此题啦！

如果还不清楚的话，看（超短）代码吧：
```
primes=(2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61)
def dfs(dep,x,mm):
    if x==1:
        return 1
    ans=-1
    for i in range(2,mm+1):
        if x%i==0:
            if ans<0:
                ans=(primes[dep]**(i-1))*dfs(dep+1,x//i,i)
            else:
                ans=min(ans,(primes[dep]**(i-1))*dfs(dep+1,x//i,i))
    return ans
n=int(input())
print(dfs(0,n,n))
```


---

## 作者：George1123 (赞：10)

[${\color{orange}\text{欢迎拜访我这个蒟蒻的博客}}$](https://www.luogu.org/blog/Wendigo/)

[P1128 【\[HNOI2001\]求正整数】](https://www.luogu.org/problem/P1128)

### 此题算法:数论+$dfs$

大致思路:

>1.$ $输入$n$，预处理$n$的因数数组$cd$。

>2.$ $此题中的数论知识:一个数$m$的因数个数为$(m$的每个$($设为$k$个$)$质因数的幂次$($设为$a)-1)$的乘积。

>※$f(n)=\prod\limits_{i=1}^k(a_i-1)$

>3.$ $通过$dfs$枚举每种$m$，求出最小的。

>4.$ $输出$m($要用高精度，下面在代码的注释中会写此题技巧$)$。

## 以下是代码+注释

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=510; //n的最多约数个数，你没看错，是n
const double inf=LLONG_MAX; //表示long long类型的最大值
const int maxn=1e8;
struct num{ //高精度大整数
	int siz,d[N*40];
	void tim(int x){ //乘法，乘上小整数t
		for(int i=1;i<=siz;i++)
			d[i]*=x;
		for(int i=1;i<=siz;i++){
			d[i+1]+=d[i]/10;
			d[i]%=10;
		} while(d[siz+1]){
			siz++;
			d[siz+1]=d[siz]/10;
			d[siz]%=10;
		}
	} void print(){ //输出大整数
		for(int i=siz;i>=1;i--)
			printf("%d",d[i]);
		printf("\n");
	}
}ans; //就是m
const int p[20]={
	0,2,3,5,7,
	11,13,17,19,
	23,29,31,37,
	41,43,47,53	
}; //足够用的质数
int n,tot,cd[N],c[N],
sum,minc[N],t=1;
/*
tot表示n的因数个数   __
cd表示n的因数       /  \
c表示m的质因数幂次  | ※|
minc是最小m的c数组  \__/ 
t是后面用来作乘法的
*/
double minn,lgm;
/*
由于m过大
dfs过程中要用m对于e的对数lgm表示m
minn是最小的lgm
*/
void dfs(int dep,int m,int r){//dep表示第dep个质因数，m表示上传用了n的第m个因数，r表示剩余的n
	if(r==1){ lgm=0;
		for(int i=1;i<=dep-1;i++)
			lgm+=(c[i]-1)*log(p[i]); //求m的对数
		if(lgm<minn){
			minn=lgm;
			sum=dep-1;
			for(int i=1;i<=N;i++)
				minc[i]=c[i]; //更新最小m
		}
	} else for(int i=m;i<=tot;i++)
			if(r%cd[i]==0){
				c[dep]=cd[i];
				dfs(dep+1,i,r/cd[i]);
			} //dfs的递归过程
}
int main(){
	scanf("%d",&n);
	for(int i=n;i>=2;i--)
		if(n%i==0)
			cd[++tot]=i;
	minn=inf; //初始化
	dfs(1,1,n);
	ans.siz=1; ans.d[1]=1;
	for(int i=1;i<=sum;i++)
		for(int j=1;j<=minc[i]-1;j++){
			if(p[i]*t<=maxn)
				t*=p[i]; 累加p，减少tim函数使用
			else {ans.tim(t); t=p[i];}
		}
	ans.tim(t); ans.print();//别忘了余下的t乘上
	return 0;
}
```
此题不用$int$和$double$间的转换，也无需$long\space long$

谢谢大家! !



---

## 作者：BzhH (赞：5)

根据唯一分解定理 $m=p_1^{a_1}\times p_2^{a_2} \times ... \times p_k^{a_k}$.

那么 $m$ 的约数个数就为 $(a_1+1)(a_2+1)...(a_k+1)$.

并且观察数据范围, $n \le 5 \times 10^4$.

那么可以得出 $k \le 16$ ,因为 $2^{16} \ge 5 \times 10^4$.

所以接下来就可以直接通过搜索枚举前16个质数的幂次方 $a$ 就行了.

但是由于答案可能很大,所以要用高精,但如果每一次更新答案都用一次高精,很明显会超时.

根据~~小学知识~~ $\lg(x\times y)=\lg{x}+\lg{y},lg{x^y}=y\times \lg{x}$,我们可以对答案取一个对数,就不怕答案很大了

接下来就可以开始通过搜索来枚举 $a_i$了

直接爆搜肯定是不行的,所以要想办法优化一下,我们在dfs的时候传入四个参数

$poi$ 表示当前枚举到第 $poi$ 个质数, $now$ 表示当前的质因子个数, $last$ 表示之前枚举的幂次方, $temp$ 表示当前答案取完对数的结果

可以得到两个明显的剪枝

最优性剪枝:如果当前的 $temp$ 已经大于之前的最小值,直接返回

可行性剪枝:在枚举幂次方 $i$ 时, 如果 $(i+1) \times now$不是$n$的倍数,舍掉这种情况

并且在枚举的时候,我们需要从 $last$ 开始,因为枚举出来的 $a_i$ 一定时单调不上升的,否则答案一定不是最优,因为我们始终可以交换任意两个 $a_i$ 使答案更小

代码
```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
using namespace std;
typedef long long ll;

int prime[16] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53};
int rec[16], a[16], n;
double recv = 1e13, val[16];

struct num
{
    ll data[10005];
    num operator * (const int b) const
    {
        num c;
        memcpy(c.data, data, sizeof(data));
        for (int i = 1; i <= c.data[0]; i++)
            c.data[i] *= b;
        for (int i = 1; i <= c.data[0]; i++)
        {
            if (c.data[i] >= 10000)
            {
                c.data[i + 1] += c.data[i] / 10000;
                c.data[i] %= 10000;
            }            
        }
        ll &h = c.data[0];
        while (c.data[h + 1] > 0)
        {
            h++;
            c.data[h + 1] += c.data[h] / 10000;
            c.data[h] %= 10000;
        }
        return c;
    }
    void print()
    {
        printf("%lld", data[data[0]]);
        for (int i = data[0] - 1; i >= 1; i--)
        {
            if (data[i] <= 9)
                printf("000");
            else if (data[i] <= 99)
                printf("00");
            else if (data[i] <= 999)
                printf("0");
            printf("%lld", data[i]);           
        }
 
    }
} ans;//高精乘

void dfs(int poi, int now, int last, double temp)
{
    if (poi == 16 || temp > recv || n % now)
        return;
    if (now == n)
    {
        if (temp < recv)
        {
            recv = temp;
            memcpy(a, rec, sizeof(rec));
        }
        return;
    }
    double t = val[poi];
    int k = n / now;
    for (int i = min(k - 1, last); i >= 0; --i)
    {
        rec[poi] = i;
        dfs(poi + 1, now * (i + 1), i, temp + i * t);
    }
    rec[poi] = 0;
}

int main()
{
    scanf("%d", &n);
    for (int i = 0; i < 16; i++)
        val[i] = log(prime[i]);
    dfs(0, 1, n - 1, 0);
    ans.data[0] = ans.data[1] = 1;
    for (int i = 0; i < 16; i++)
        while (a[i]--)
            ans = ans * prime[i];
    ans.print();
}


```

---

## 作者：ZhuMingYang (赞：4)

一个150行代码怎么能不过1~50000所有点呢  
~~其实能过1~1000000的所有点（只要高精开的够大）~~

没错 这份代码连大素数（49999）都能过 ~~反而更轻松~~

速度也是相当的快了

------------

引理1：数$m$(分解质因数:$p_1^{c_1}\times ...\times p_n^{c_n}$)的约数个数和为

$(1+c_1)\times (1+c_2)\times ...\times (1+c_n)$

引理2：$2^{20}>50000$所以$\sum c_i<20$ 素数表做到20个就够了

------------

下面就是我神奇的解法：

分解$n$为 $p_1^{c_1}\times p_2^{c_2}\times...$

初始分配：将$c_i$个$p_i$分配给每个素数 且$p_i$越大 分配的素数越小 总共分配$\sum_{i=1}^n c_i$个

例如：当$n=72=2^3\times 3^2$

分配$2->3,3->3,5->2,7->2,11->2$(前一项为素数，后一项为分配的$p_i$)
          
二次分配：上面已经得到了一个答案$m=2^{3-1}\times3^{3-1}\times 5^{2-1}\times7^{2-1}\times11^{2-1}=13860$ 约数为$72$个

解释上述式子：根据引理1,算答案时每个分配的$p_i$要减一再算次方,通过引理1可知上述的$m$有$72$个约数

$m$却还不是最小  
我们发现约数个数为$3\times3\times 2\times 2\times 2$可换为$6\times2\times 2\times 2$  
这样$m=2^{6-1}\times 3^{2-1}\times 5^{2-1}\times 7^{2-1}=10080$  
判断这两个式子大小也就是判断$2^3$与$11$的大小

设$px_i$表示第$i$个素数  
类似这样 对于最后一位$n$ 我们每次都搜出$1->n-1$中$px_i^{(p[n]-1)\times p[i]}$的最小值  
若比$px_n^{p_n-1}$小  
则$p_i*=px_n$,$px_n=0$,$n--$  
继续循环  
若不比其小  
则跳出循环  
答案则为:$m=\prod_{i=1}^n px_i^{p_i-1}$  
当然还要写高精度  
具体看代码

*10.15 latex优化* ~~当时我怎么这么强，想出了这么神仙的方法，还跑得这么快~~
```c++
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<vector>
#include<cmath>
#include<map>
using namespace std;
typedef long long ll;
const int p[21] = {
  0, 2,  3,  5,  7, 11,
  13, 17, 19, 23, 29,
  31, 37, 41, 43, 47,
  53, 59, 61, 67, 71
};
int a[21],px[10000],c[100000];
ll fa[100000]={1},fb[100000]={1},s[100000]={1};
int n,m=0,cnt=0;
int h=0,ha=0,hb=0;
const int mod=10;
inline ll qpow(ll a,int b)
{
    ll ans=1;
    for(;b;b>>=1)
    {
        if(b&1) ans=ans*a;
        a=a*a;
    }
    return ans;
}
inline void resolve(int n)
{
    for(int i=2;i*i<=n;i++)
    {
        if(n%i==0){
            px[++cnt]=i;
            c[cnt]=0;
            while(n%i==0)
            {
                c[cnt]++;
                n/=i;
            }
        }
    }
    if(n>1) px[++cnt]=n,c[cnt]=1;
}
inline void print(ll *s,int &h)
{
    for(int i=h;i>=0;i--)
        printf("%lld",s[i]);
    putchar('\n');
}
inline void mul(ll b,ll *s,int &h)
{
    for(int i=0;i<=h;i++)
    {
        s[i]*=b;
    }
    for(int i=0;i<=h;i++)
    {
        while(s[i]>=mod)
        {
            s[i+1]+=s[i]/mod;
            s[i]=s[i]%mod;
            if(i==h)
                ++h;
        }
    }
}
inline void spow(ll p,ll a,ll *s,int &h)
{
    while(a!=0)
    {
        if(p>1e9) break;
        if(a&1) mul(p,s,h);
        a>>=1;
        p*=p;
    }
    for(int i=1;i<=a;i++)
        mul(p,s,h);
}
inline bool compare(ll *fa,ll *fb,int ha,int hb)
{
    if(ha>hb) return 1;
    else if(ha<hb) return 0;
    for(int i=ha;i>=0;i--)
    {
        if(fa[i]>fb[i]) return 1;
        else if(fa[i]<fb[i]) return 0;
    }
    return 0;
}
inline void reuse(ll *s,int &h)
{
    for(int i=0;i<=h;i++)
    {
        s[i]=0;
    }
    h=0;
    s[0]=1;
}
int main()
{
    scanf("%d",&n);
    if(n==1||n==0)
    {
        printf("%d\n",n);
        return 0;
    }
    resolve(n);
    for(int i=cnt;i>=1;i--)
    {
        for(int j=1;j<=c[i];j++)
            a[++m]=px[i];
    }
    while(true)
    {
        if(m==1) break;
        bool cmp=0;
        int x=m;
        spow(ll(p[m]),a[m]-1,fb,hb);
        for(int i=1;i<m;i++)
        {
            reuse(fa,ha);
            spow(ll(p[i]),a[i]*(a[m]-1),fa,ha);
            if(compare(fb,fa,hb,ha))
            {
                reuse(fb,hb);
                spow(ll(p[i]),a[i]*(a[m]-1),fb,hb);
                x=i;
            }
        }
        reuse(fa,ha);
        spow(ll(p[m]),a[m]-1,fa,ha);
        if(compare(fa,fb,ha,hb)){
            a[x]*=a[m];
            a[m]=0;
            m--;
            cmp=1;
        }
        if(!cmp) break;
        reuse(fa,ha);
        reuse(fb,hb);
    }
    for(int i=1;i<=m;i++)
    {
        //cout<<p[i]<<"  "<<a[i]-1<<endl;
        spow(ll(p[i]),a[i]-1,s,h);
    }
    print(s,h);
    return 0;
}
```

---

## 作者：天下第一剑客 (赞：3)

看了楼下的题解，发现他的思想和我一样，所以一样90

虽然并没有AC，但我觉得思想和写起来都比正解要简单得多，考场上这么写不失为一种优秀的策略（毕竟只少了10分）

先说一下算法。

这其实是求因数个数的一个逆运算。

考虑正运算，给你一个数，让你求它的因数个数。

这个问题很好就解决，把这个数质因数分解，把每个质数的指数加一然后乘起来就是答案。

为什么呢？因为每个质因数都有指数种取法，因数的个数其实就是质因数的选法，于是就可以用排列组合的思想。

为什么要加一？因为每个质因数都可以不取，也就是0次幂的情况。

那么说答案就是由原数每个质因数指数乘起来的喽

现在来看逆运算

给你一个因数个数，让你求最小的原数

一个比较感性的想法就是把这个数也质因数分解，分解出的每个质因数就对应原数的一个质因子，这个质因数的指数就对应原数又多少个质因子的指数都是这个质因数-1

因为要求最小的，所以一个显然的贪心策略就是越大的质因数（也就是原数的某个质因子的指数）对应原数尽量小的质因子，然后针对n的每个质因数的指数，就找现在没选的最小的指数个指数乘起来，这样就仿佛是要求的原数了。

这也是我的代码所体现的。但事实证明这个贪心不完全正确，但正确的概率很大。

概率具体多少我证明不出来，但反正很大（要不怎么90分）

现在来说一下错误之处

研究这一个数据：n=128

正确结果是83160，而这个程序输出的却是510510，大了一大圈

现在分析一下原因。

128=2^7

83160=2^3\*3^3\*5\*7\*11, (3+1)\*(3+1)\*(1+1)\*(1+1)\*(1+1)=128正确

510510=2\*3\*5\*7\*11\*13\*17,(1+1)\*(1+1)\*(1+1)\*(1+1)\*(1+1)\*(1+1)\*(1+1)=128也是合法解

但为什么这个贪心求出来的不是最小的呢？

问题就出在对于n分解出来的每一个质因数的指数，这个算法理所当然地给每个没取的质数一个1的指数，但这并不一定是最优的

这个数据就体现了出来，给2和3一个2^2-1，这样2和3这两个小质数对于n的指数贡献就都是2了，省去了后面的更大的13和17

但是要在原有的贪心里体现出这一步实在太难了，我交之前其实已经发现了这个算法的错误之处，但苦苦思索一个小时也想出来怎么处理，索性直接加个高精度交上去试试看，没想到90，要不是数据特意卡就AC了，所以事实证明：你永远不知道一个错误的贪心能拿多少分

错误的贪心本质就是一种概率算法，看来这个贪心概率还是蛮大的

下面贴出代码（高精度这么美妙的东西怎么能不用结构体）

```cpp
#include<cstdio>
#include<cmath>
#include<vector>
#include<iostream>
#include<cstring>
#define REP(x,a,b) for (int (x)=(a); (x)<=(b); (x)++)
namespace GOU{//命名空间是个好东西，这样就不会因为与std里的变量重名而意外出错了
    typedef unsigned long long ll;
    const int p[16]={0,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47};//预处理出可能用到的质数，也就是前log(n)/log(2)个质数
    struct Big{//高精度结构体
        static const int WIDTH=3,BASE=1000;//压位
        std::vector<int>s;
        Big(){s.clear();}
        Big(ll x){do{s.push_back(x%BASE);x/=BASE;}while(x);}//构造函数
        Big operator * (const Big &b) const{//定义乘法运算（这里只用到了乘法）
            Big ret; int carry=0;
            ret.s.resize(s.size()+b.s.size());
            for (int i=0; i<s.size(); i++)
                for (int j=0; j<b.s.size(); j++) ret.s[i+j]+=s[i]*b.s[j];
            for (int i=0; i<ret.s.size(); i++) ret.s[i+1]+=ret.s[i]/BASE,ret.s[i]%=BASE;
            int pos=ret.s.size()-1;
            while (ret.s[pos]==0 && pos--) ret.s.pop_back();//去除前导零
            return ret;
        }
    };
    std::ostream& operator << (std::ostream &out, const Big x){//定义输出流，方便输出
        out<<x.s.back();
        for (int i=x.s.size()-2; i>=0; i--){
            char buf[10]; int len;
            sprintf(buf,"%03d",x.s[i]);
            len=strlen(buf);
            for (int i=0; i<len; i++) out<<buf[i];
        }
        return out;
    }
    int n,cnt,tot,prime[10],index[10]; Big ans=1;
    Big FastPower(Big base, int index){//高精度整数的快速幂
        Big ret=1;
        while (index){
            if (index&1) ret=ret*base;
            index>>=1; base=base*base;
        }
        return ret;
    }
    void resolve(int x){//质因数分解
        int limit=ceil(sqrt(double(x)));
        REP(i,2,limit){//质因数分解算法（以前以为还必须筛素数，后来发现不筛素数正确性也有保障）
            if (x%i==0) prime[++cnt]=i;
            while (x%i==0) index[cnt]++,x/=i,tot++;
        }
        if (x!=1) prime[++cnt]=x,index[cnt]=1,tot++;//特判那个大于sqrt(n)的质数
    }
    void process(){//主程序
        scanf("%d",&n);
        resolve(n); int cur=1;
        for (int i=cnt; i>0; i--){//计算答案
            for (int j=1; j<=index[i]; j++){
                ans=ans*FastPower(Big(p[cur]),prime[i]-1);
                cur++;
            }
        }
        std::cout<<ans<<std::endl;//输出（定义了输出流所以可以直接cout）
    }
}
int main(){
    GOU::process();//调用主程序
    return 0;
}
最后说一句，要AC大概要用DFS，反正我还没想到对于这个贪心的改进。要各位有想到的请私信我，感激不尽。
```

---

## 作者：Lynx (赞：2)

我相信许多人和我一样刚看了这道题一定会不知所措，接下来就分析一下。

题目中给了这个正整数的因数个数，并不好处理，如果是质因数就好处理多了。

介绍一下约数公式：n=Πpri[i]\*a[i]（n是这个数的因数个数，pri是质数，a是指数）。

我就不证明了，自己百度。

数据范围只有50000，计算可得约数个数最多16个，先打出一张素数表，以后的质数对答案没有贡献。

dfs(x,y,z)——x表示搜索到的正整数，y表示x的因数个数，z表示已经搜索到了第z个质数。

这样是会超时的，考虑剪枝。

枚举当前质数的指数i时，y%(i+1)==0，那么就是求y的因数，时间复杂度sqrt(y)。

当前质数的质数不可以为0，因为是从小到大搜索，还是比较有用的。

又发现x是会爆long long的（比赛时用double卡的精度）如果搜索时加高精度就太麻烦了，考虑用对数。

log(n)=Σa[i]\*log(pri[i])（自己推吧，字母代表的意义和上面一样）。

搜索时保存指数，最后加一个高精度就好了。


```cpp
#include<iostream>
#include<cstring>
#include<cfloat>
#include<cstdio>
#include<cmath>
using namespace std;
int n,ans[100005],res[21],tmp[21],pri[]={0,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53};
double mn=DBL_MAX,lg[21];
void print()
{
    ans[0]=ans[1]=1;
    for(int i=1;i<=16;i++)
    {
        for(;res[i]>0;res[i]--)
        {
            for(int j=1;j<=ans[0];j++)
                ans[j]*=pri[i];
            for(int j=1;j<=ans[0];j++)
                ans[j+1]+=ans[j]/10,ans[j]%=10;
            if(ans[ans[0]+1]!=0)
                ans[0]++;
            while(ans[ans[0]]/10!=0)
                ans[ans[0]+1]+=ans[ans[0]]/10,ans[ans[0]]%=10,++ans[0];
        }
    }
    for(int i=ans[0];i>=1;i--)
        printf("%d",ans[i]);
    printf("\n");
}
void dfs(double x,int y,int z)//现在的数是e^x，还剩y个因子，选到第z个质数 
{
    if(x>=mn)
        return ;
    if(y==1)
    {
        mn=x;
        memset(res,0,sizeof(res));
        for(int i=1;i<=z-1;i++)
            res[i]=tmp[i];
        return ;
    }
    if(z>16)
        return ;
    for(int i=0;(i+1)*(i+1)<=y;i++)//找y的因子 
        if(y%(i+1)==0)
        {
            if(i!=0)
            {
                tmp[z]=i;
                dfs(x+lg[z]*i,y/(i+1),z+1);
            }
            if((i+1)*(i+1)!=y)
            {
                tmp[z]=y/(i+1)-1;
                dfs(x+lg[z]*(y/(i+1)-1),i+1,z+1);
            }
        }
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=16;i++)
        lg[i]=log(pri[i]);
    dfs(0,n,1);
    print();
    return 0;
}
```

---

## 作者：风火 (赞：1)

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll n,ans=1e16+1024;
ll p[30]={0,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47};
void dfs(ll now_res,ll now_pos,ll now_ynum,ll last)
{//现在的数，现在第几个素数，现在一共约数个数，上一个指数
	if(now_res>=ans||now_pos>15) return ;
	if(now_ynum==n)
	{
		ans=now_res;
		return ;
	}
	ll i=now_res,j=0;
	while(j<last)//现在第几个素数的指数
	{
		j++;
		if(i*p[now_pos]>ans) return ;
		ll nxt_ynum=now_ynum*(j+1); i*=p[now_pos];
		if(i<=ans) dfs(i,now_pos+1,nxt_ynum,j);
	 }
}
/*我来发一个没有高精的代码~~~（有谁改成高精，感激不尽）
当然，结果只有50分，不过，这个我想应该很好理解
由题目，我们知道要组成 n 个约数，那我们直接搜索约数个数就好了
顺便，我也解释一下为什么某个数的约数个数是组成其的素数的（幂+1）之积
我们知道每一个数一定是由某些素数的幂次组成的，这个想一下就知道了，
（一个数不是合数，就是素数嘛，合数不就是由素数组成的啊）；
然后，我们就可以知道，每个素数会有k[i]的幂
同时，我们知道，每两个素数相乘得到的结果是不同的，于是每个素数就会有其（幂+1）次被选中的可能，为啥？
因为还可以选该素数的 0 次方~~~！
于是
1：某个数的总共约数个数就是组成它的素数的（幂+1）次之积
现在第二个
2：题目要求组成的数最小，那肯定是让小的素数 幂 更大一点，但是也不排除大的素数取一点，但是必须要小与上一个素数的 幂 
有了这个，直接看代码就好了
*/
int main()
{
	scanf("%lld",&n);
	dfs(1,1,1,23);
	printf("%lld\n",ans);
	return 0;
}
```

---


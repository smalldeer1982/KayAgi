# 两数之和

## 题目描述

我们知道从 $n$ 个非负整数中任取两个相加共有 $\frac{n(n-1)}{2}$ 个和，现在已知这 $\frac{n(n-1)}{2}$ 个和值，要求 $n$ 个非负整数。

## 样例 #1

### 输入

```
3 1269 1160 1663
```

### 输出

```
383 777 886
```

# 题解

## 作者：YudeS (赞：43)

题目描述

我们知道从$n$个非负整数中任取两个相加共有$n*(n-1)/2$个和，现在已知这$n*(n-1)/2$个和值，要求$n$个非负整数。

&nbsp;

&nbsp;
注意有多组数据

------------
我觉得很妙，甚是可以写一篇题解；

我们有$n$个非负整数（就姑且设为$a[1\sim n]$），答案要求又从小到大输出，我们就从人为从小到大求解($a[1]<a[2]<a[3]<a[4]......$)

这就有了以下数对和

$$\sum\limits_{i=1}^{n-1}\sum\limits_{j=i+1}^{n}a[i]+a[j]$$

这就是输入，我们把它们装在数组$sum[]$里

展开上式可以得到

$$a[1]+a[2]\ ,a[1]+a[3]\ ,a[1]+a[4]\ ,a[1]+a[5]\ ...\ a[1]+a[n]$$
$$a[2]+a[3]\ ,a[2]+a[4]\ ,a[2]+a[5]\ ...\ a[2]+a[n]$$
$$...$$
$$a[n-1]+a[n]$$

这个略丑，
我们稍加整理

![](https://s2.ax1x.com/2019/10/07/uRczDJ.png)

这样子我们可以得到一个倒三角形，

且发现每一行，每一列都有一个相同的元素，又由于我们求的$a[]$单调递增（单调不下降），可知：

每一行，从左到右，值依次递增

每一列，从上到下，值依次递增

~~元素周期表的感觉~~

可以进一步推出当前图最小的那个点一定在左上角（<-突破口

&nbsp;

&nbsp;

意味着将$sum[]$排个序后，我们知道了最小的$sum(sum[1])$，这其实就是$a[1]+a[2]$

那假如我们现在知道$a[1]$了，那我们也知道$a[2]$了；

我们在$sum[]$中删去$a[1]+a[2]$，那当前的的最小值就是$a[1]+a[3]$了，我们知道$a[1]$，$a[3]$也就知道了；

当前得到了$a[1],a[2],a[3]$，我们删除倒三角形中第二列的数：$a[1]+a[3],a[2]+a[3]$;

现在最小的就是$a[1]+a[4]$了，同理可以得知$a[4]$；

我们发现用这种方法就可以求出所有的元素；

如果还有点不理解的话，可以看看文章底部的模拟；

&nbsp;

当然这建立在知道$a[1]$的情况下，这样显然可以枚举$a[1]$，找到任意一种成立的方法就可以了；

$a[1]$的取值范围为$[0,(sum[1]/2)]$，因为$a[1]+a[2]=sum[1]\& \&a[1]<=a[2]$

&nbsp;


操作中涉及到 查询最小值，删除值，可以用$set$；

又想到$sum[]$中也有可能出现重复的值,自然用$multiset$比较保险

这样子枚举$a[1]$的时间是依靠值域的，总共操作的点有$n^2$个，删除的时间复杂度是$log_n$，

所以对于一个数据点的时间复杂度的上界是$O(max_aN^2logN)$；

&nbsp;

如何处理$impossible$的情况呢，如果我们当前找不到要删除的点，说明当前枚举的$a[1]$不成立，如果一个成立的$a[1]$都找不到的话，就无解了；

&nbsp;

讲的有些复杂，很多内容可以直接跳过；

$Code$
```cpp
#include<bits/stdc++.h>
#define mp make_pair
#define ll long long
using namespace std;

int n;
int sum[50];
int a[20];
bool fl;
multiset<int> s;
multiset<int>::iterator it;
inline int read()
{
	int  x=0,fl=1;char st=getchar();
	while(st<'0'||st>'9'){ if(st=='-')fl=-1; st=getchar();}
	while(st>='0'&&st<='9') x=x*10+st-'0',st=getchar();
	return x*fl;
}

inline bool check(int x)
{
	a[1]=x;	//确定a[1] 
	for(int i=2;i<=n;i++)
	{
		a[i]=*s.begin()-a[1];	//确定a[i] 
		for(int j=1;j<i;j++)
		{
			it=s.find(a[j]+a[i]);	
			if(it==s.end())		//当前的a[1]不成立 
				return 0;
			s.erase(it);	 //删除倒三角形中第i列下方的点 
		}
	}
	return 1;
}

int main()
{
	while(~scanf("%d",&n))
	{
		fl=0;	// 记得初始 
		for(int i=1;i<=n*(n-1)/2;i++)
			sum[i]=read();
	
		sort(sum+1,sum+1+n*(n-1)/2);
		
		for(int i=0;i<=(sum[1]/2);i++)
		{
			s.clear();
			for(int j=1;j<=n*(n-1)/2;j++)
				s.insert(sum[j]);		//初始multiset 
			if(check(i))	//有一组解就输出 
			{
				for(int j=1;j<=n;j++)
					printf("%d ",a[j]);
					puts("");
				fl=1;
				break;
			}
		}
		if(!fl)printf("Impossible\n");	//无解 
		
	}
	return 0;
}

```

这里模拟一下$n=5$的情况，我们已经枚举了$a[1]$，同时得出了$a[2]$

![](https://s2.ax1x.com/2019/10/07/uROstf.png)

![](https://s2.ax1x.com/2019/10/07/uROvH1.png)

![](https://s2.ax1x.com/2019/10/07/uRXige.png)

![](https://s2.ax1x.com/2019/10/07/uRXAud.png)



---

## 作者：zhengrunzhe (赞：10)

这道题的数据真的有毒.

第1~25个点都是3分，stm最后一点25分

数据改后，我没写多次询问的代码也能A掉25个点

写了多组询问后终于A了.

正如讨论中的思路那样

标签：数学+搜索

首先把所有输入的和累加起来，如果累加出来的和不能被(n-1)整除，那么就impossible

先将输入的每一个和从小到大排序

那么之后第一个和就是ans[1]+ans[2](最小的两个数之和)

第二个和就是ans[1]+ans[3](第一小的数+第三小的数=第二小的和)

那么现在就有两个和是确(qin)定的了

所以就先搜索第三个和，即搜索ans[2]+ans[3]的值

那么就可以联立一个三元一次方程组

```cpp
{
       ans[1]+ans[2]=a[1]
       ans[1]+ans[3]=a[2]
       ans[2]+ans[3]=a[p]
```
(3≤p≤\*(n-1)/2)
}
就会发现这是轮换对称的

就可以得出(a[1]+a[2]+a[p])/2=ans[1]+ans[2]+ans[3]

如果(a[1]+a[2]+a[p])/2不为整数的话，那么就剪枝

(a[1]+a[2]+a[p])/2分别减去a[p]、a[2]、a[1]就可以得到ans[1]、ans[2]、ans[3]了

以前面得出的解为基础，继续搜索第k(k>3)个和直到最后

第k个和a[p]，代表ans[1]+ans[k]

那么ans[k]就是a[p]-先前确定的ans[1]

不知道解能不能有相等的数字，所以就写了一个判重，好像有一点点用吧…至少不判重第13个点会WA

如果ans[k]+ans[i](2≤i<k)没有在输入的和中出现过，那么就剪枝返回

说了那么多，感觉好乱，看代码吧…

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=11,M=(N-1)*N/2+1,A=100001;
int n,a[M],m,ans[N];
bool mp[A],flag;
void search(int p,int k,int x[N],bool f[M])
{
    if (flag)return;  //如果找到解了就返回 
    bool map[M];memcpy(map,f,sizeof(map));
    int y[N];memcpy(y,x,sizeof(y));
    map[p]=1;
    if (k==3)
    {
        double s=(a[1]+a[2]+a[p])/2.0;
        if (s!=(int)(s))return;  //剪枝点#1 
        y[1]=s-a[p],y[2]=s-a[2],y[3]=s-a[1];
    }
    if (k>3)
    {
        y[k]=a[p]-y[1];
        if (mp[y[k]])return;  //判重剪枝点#2 
        mp[y[k]]=1;
        for (int i=2;i<k;i++)
            if (find(a+1,a+m+1,y[k]+y[i])==a+m+1)
                return;  //剪枝点#3 
    }
    if (k==n)
        {memcpy(ans,y,sizeof(ans));flag=1;return;}
    for (int i=3;i<=m;i++)
        if (!f[i])search(i,k+1,y,map); //在没有被使用的和中搜索下一个 
}
void once()
{
    m=n*(n-1)/2;
    int sum=0;flag=0;
    memset(ans,0,sizeof(ans));
    memset(mp,0,sizeof(mp));
    for (int i=1;i<=m;i++)
        scanf("%d",&a[i]),sum+=a[i];
    if (sum/(n-1)*(n-1)!=sum)
        {puts("Impossible");return;}   //判无解点#1 
    sort(a+1,a+m+1);  //排序 
    bool fff[M]={1,1,1};  //只是为了代入search中，并无实际意义 
    search(2,2,ans,fff);
    sort(ans+1,ans+n+1);
    if (!flag){puts("Impossible");return;} //如果没找到解就impossible，判无解点#2 
    ans[n]=a[m]-ans[n-1];
    for (int i=1;i<=n;i++)
        printf("%d ",ans[i]);
    puts("");
}
int main()
{
    while (scanf("%d",&n)==1)once();   //注意是多组询问 
    return 0;
}
```

---

## 作者：AFOier (赞：6)

讲解之前先%%%一下@ t0vd大佬！详见讨论：这道题有什么思路吗

接下来。。。看懂了我就不讲了吧。。。才怪

虽然大佬很厉害，但我还是再详细地讲一下思路吧，可能语言有点乱，勉强看看吧。我们可以轻松得出，s1=1,s2=2,s3=3和s1=3,s2=2,s3=1是一样的解，输出都是：1 2 3，我们可以利用这个特性进行判重和找答案。

先说找答案。其实这是个枚举。。。我们可以设输入的数组为a数组，假设a[1]一定为s1+s2(s是答案)，我们可以枚举表示s1+s3的数，再枚举表示s2+s3的数，那么这样我们就可以得出s1,s2,s3的数值。怎么求看下面，会求的跳过。

我们把(s1+s2)+(s1+s3)+(s2+s3)加起来，那么去括号后为s1+s1+s2+s2+s3+s3，除以2后就等于s1+s2+s3了对吧，我们把它设为s。那么s1=s-(s2+s3),s2=s-(s1+s3),s3=s-(s1+s2)，那么三个数就都求出来了。

现在我们已经求出了s1,s2,s3，如果n=3，那么直接输出就行了，记得要退出除了输入之外的所有循环，因为一个输入只输出一个答案。如果n>3，那么我们就枚举表示s1+s4,s5,s6,…sn的数，我用的是dfs，记得枚举过的数要判重，dfs完了判重一定一定要取消！

正如讨论中所说，我们边做边判断当前答案是否合法，不然到答案都出来了再判重就会tle了。引用讨论《这道题有什么思路吗》中大佬的话：“一边搜的过程一边剪枝，比如枚举到x4发现x2+x4并没有在输入的数中出现过，那么就可以剪掉。这样就能很快出解了。”这样我们就可以得出答案并且输出了。

好吧，的确挺乱的，看看代码吧（不过我的代码也挺难看懂的）有可能有些语句是没用的呵呵。。。

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
int pc[101],a[101],s[101],n,b[100001];
bool pd;
int print()
{
    if(pd==true)return 0;
    pd=true;
    int ss[101];
    for(int i=1;i<=n;i++)
    ss[i]=s[i];
    sort(ss+1,ss+n+1);
    for(int i=1;i<=n;i++)
    cout<<ss[i]<<" ";
    cout<<endl;
```
}//这是输出函数，先排序后输出应该都懂吧
```cpp
int dfs(int sy,int w)
{
    if(pd==true)return 0;//如果当前询问已经有答案了，你还找啥答案
    if((a[w]-s[1])<0)return 0;//如果当前数为负数，不合法，退出
    for(int i=1;i<sy;i++)
    if(b[(a[w]-s[1])+s[i]]==0)return 0;//如果不存在当前数+前面任意一个数，那么不合法，退出
    s[sy]=a[w]-s[1];//赋值
    pc[w]=1;//判重标记
    if(sy>=n){print();pc[w]=0;return 0;}//如果找到答案，输出，取消判重，询问结束
    for(int i=1;i<=n*(n-1)/2;i++)
    if(pc[i]==0)dfs(sy+1,i);//枚举能当下一个数的数字
    pc[w]=0;//去判重标记
    return 0;
}
int ans(int n)
{
    pd=false;//判断有没有答案
    for(int i=1;i<=100;i++)
    pc[i]=a[i]=s[i]=0;//初始化
    for(int i=1;i<=100000;i++)b[i]=0;//初始化
    int p[101][101]={0};//必须要={0}，如果没有的话无法归0
    for(int i=1;i<=n*(n-1)/2;i++)
    cin>>a[i],b[a[i]]=1;//输入，标记输入的数字
    sort(a+1,a+n*(n-1)/2+1);
    int s12=a[1];//设第一个输入的数字为s1+s2
    for(int i=2;i<=n*(n-1)/2;i++)//枚举s1+s3
    {
        if(pd==true)return 0;
        int s13=a[i];
        for(int j=2;j<=n*(n-1)/2;j++)//枚举s2+s3
        {
            if(pd==true)return 0;
            if(i==j)continue;
            if(p[i][j]==1)continue;
            int s23=a[j];
            if((s12+s13+s23)%2==1)continue; 
            int zs=(s12+s13+s23)/2;
            s[3]=zs-s12,s[2]=zs-s13,s[1]=zs-s23;
            pc[i]=1;pc[j]=1;pc[1]=1;
            if(s[1]<0||s[2]<0||s[3]<0)continue;//以上算s1,s2,s3
            p[i][j]=1;p[j][i]=1;//貌似没啥用
            if(n==3)
            {
                pd=true;
                sort(s+1,s+4);
                cout<<s[1]<<" "<<s[2]<<" "<<s[3]<<endl;
                pc[i]=0;pc[j]=0;pc[1]=0;
                return 0;
```
}//如果N=3，直接排序输出，退出询问
```cpp
            else
            for(int i=1;i<=n*(n-1)/2;i++)
            if(pc[i]==0)dfs(4,i);//否则dfs枚举
            pc[i]=0;pc[j]=0;pc[1]=0;//去判重记号
        } 
    }
    if(pd==false)cout<<"Impossible"<<endl;//如果并没有发现答案，输出Impossible
    return 0;
}
int main()
{
    while(cin>>n)ans(n);//分别处理每个询问
}
```

---

## 作者：Tiffany_Tendering (赞：5)

    首先吐槽一下这个题的数据
    这个题是有多组询问的（其实也不能怪数据，毕竟题面已经说明了“**输入文件有若干行**”）
    （还有就是这个题有26个数据，前25个每个3分，最后一个25... ...）
    
    
    好了，现在正式分析一下题目。（当然了有很多细节，最后会点明的。）
    
    大体思路就是
    首先 对这一串已知数列从小到大排序。即为数组a[]
    对于要求的答案记为数组x[](数组x[]也是从小到大的顺序，至于为什么，下面会讲。)
         
    那么我们就有a[1] = x[1] + x[2]，因为最小的那一个和，一定是最小的两个数的和。
    
    之后 我们把a[1]从这个数组里面删掉，那么这个数列中最小的数为a[2]，
    则 a[2] = x[1] + x[3] . 因为倒数第二小的和一定是x[1]和x[3]组成的，在这个数列里，除了x[1] + x[2] ，没有比x[1] + x[3]更小的和了。（这就是为什么我们要约定x[]数组是从小到大排序的。）
    
    假设我们已经知道了x[1]，那么根据a[1] = x[1] + x[2],a[2] = x[1] + x[3]，我们就能够推出前三个数了对吧。（先不考虑x[1]咋求...）
    
    这样的话，**x[2] + x[3]**是不是也就一起知道是多少了!
    它一定是a[3]吗？ 不一定！
    因为a[3] 可能等于 x[1] + x[4] ,也有可能是x[2] + x[3]（想一想啦）
    
    我们假设a[p] = x[2] + x[3] ；
    那么我们是不是就有以下条件：
      ** a1=x1+x2，******
       **a2=x1+x3，******
       **ap=x2+x3******
       
       我们把上面三个式子加起来，再整理一下（小学数学运算...），就有：
       
     **(a1+a2+ap)/2-ap=x1******
     
     这样是不是就知道x[1] 的值了！
     所以说，我们只要依次枚举这个a[p]，就可以得到不同的解！（当然，这个题只要求输出一种解法。 但是有这个拓展应该也是不错的吧）
     
     然后我们把已经搜索过的a[i]，从数列里面删除就好了！
     
     
     
     OK 大体思路也就是这样
     但是有几个特殊情况嘚特判
     1 这个题有多组数据（已经跟你说过了吧）
     2 如果a[]数组是个常数列，即每个数都相等（假设为b），那么只有一种情况！ 就是b/2 !!  所以说，如果这是个常数列，但是每一个数都是一个奇数的话，就是impossible！！！
     
     
     放代码（代码的注释也很详细的）
     
 
 
 
 
 
     
     
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int maxn = 50 ;
const int maxm = (maxn * maxn) + 5;
int n,m,a[maxm],x[maxn],ans[maxm << 1][maxn] ,total;  //ans[i][j]存的是第i种情况的第j个数（这个题确实用不到） 
bool vis[maxm] ;
int mid_find(int k) {  //二分寻找这个数的位置 
	int mid,l = 0,r = m + 1, ans;
    while(l + 1 < r) {
    	mid = (l + r) / 2;
    	if(a[mid] < k) ans = l = mid;
    	else r = mid ;
	}
	return ans + 1;
}
void work(int p) {
	memset(vis,0,sizeof(vis)) ;
	vis[1] = vis[2] = vis[p] = 1 ;
	x[1] = (a[1] + a[2] + a[p]) / 2 - a[p] ;
	x[2] = a[1] - x[1] ;
	x[3] = a[2] - x[1] ;  //以上是求解x[1] 
	int next = 3;  
	for(int i = 4;i <= n ;++i) {
		while(next < m && vis[next]) next++;  //如果已经搜过了，就不需要了 
		x[i] = a[next] - x[1] ;   //把x[i]求出来 
	    vis[next] = 1;
		for(int j = 2;j < i ;++j) {//求出x[i]以后，我们就可以求出x[2] + x[i], x[3] + x[i]....x[i - 1] + x[i] ，同时把它们删掉，也就是打标记 
		    if(x[j] > x[i]) return ;   //约定x[]数组从小到大 
		    int sum = x[j] + x[i] ;   
		    p = mid_find(sum) ;
		    if(a[p] != sum) return ; //****** 别忘了哦！ 如果没有sum，则无解啦！ 
		    bool flag = 0;
		    for(int k = p;p <= m && a[k] == a[p] ; ++k)  //这个意思是如果没有这个答案，或者是有这个答案但是已经被标记过了，则无解 
		      if(!vis[k]){flag = 1; vis[k] = 1 ; break ;}
		    if(!flag) return ;
		}
	}
	total++; 
	for(int i = 1;i <= n ;++i)
	  ans[total][i] = x[i] ;
}
int main() {
	while (scanf("%d",&n) != EOF) {
		memset(vis,0,sizeof(vis)) ;
		total = 0; //别忘了几个初始化 
		m = n * (n - 1) / 2 ;
	    bool flg = 1;
	    for(int i = 1;i <= m ;++i)  {
		    scanf("%d",&a[i]) ;
		    if(i == 1) continue ;
		    if(a[i] != a[i - 1]) flg = 0;
	    }  
	    if(flg){    //如果每个数都相等，则特判 
		    if(a[1] % 2 == 1) {printf("Impossible\n") ; }
		    else {for(int i = 1;i < n ;++i) printf("%d ",a[1] / 2) ;printf("%d\n",a[1] / 2) ; }
	    }
	    else {
	    	sort(a + 1,a + m + 1) ;  //排个序 
	        for(int i = 3;i <= m ;++i)  //枚举x[2] + x[3]可能的所有情况 
	           if((a[i] != a[i - 1]) && (a[1] + a[2] + a[i]) % 2 == 0 ) {  //因为我们求x[1]时会除以2 ， 奇数当然不行！ 
	  	          work( i ) ;   //如果这个数和前面的相等，也就没有搜索的必要了。 
	  	          if(total > 0) break; //只要有情况可解就行了， 
	       }
            if(!total){printf("Impossible\n") ;}
            else {for(int i = 1;i < n ;++i) printf("%d ",ans[1][i]) ;printf("%d\n",ans[1][n]) ;} 
		}
	}
	return 0;
}
```
     
    

---

## 作者：Tony102 (赞：4)

[Link](https://www.luogu.com.cn/problem/P1286)



### Sol

先对给你的这个数组排序，我们设排完序后的数组为$a[1],a[2],\dots,a[n]$，给你的数组升序排序后是$b[1],b[2],\dots,b[n * (n-1) /2]$

考虑$b[1]$是怎么被$a[]$相加而得的，因为$b[1]$是$b$中最小的元素，那么$b[1]=a[1]+a[2]$

第二小的$b[2]=a[1] + a[3]$

由$a[2]$开始往后相加的元素一定在$b[x] = a[1]+a[k]$开始，这样的$b[x]$我们只需要$O(n)$的枚举找到就可以了

做法就出来了

每次找到$a[k]$这个元素，把$a[1]+a[2], a[1]+a[3],\dots,a[1]+a[k]$这些元素找出来，再把他们在$b$中去掉，再从$a[2]$开始，以此类推

时间复杂度$O(n^3)$



### Code
```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long

const int SIZE = 1e7 + 5;

int n, m, cnt;
int a[SIZE], b[SIZE];

std::multiset < int > s;
std::vector < vector < int > > ans;

inline int read()
{
	char ch = getchar();
	int f = 1, x = 0;
	while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }
	while (ch >= '0' && ch <= '9') { x = (x << 1) + (x << 3) + ch - '0'; ch = getchar(); }
	return x * f;
}

inline void solve(int p)
{
	if ((a[1] + a[2] + a[p]) & 1) return;
	b[1] = (a[1] + a[2] + a[p]) / 2 - a[p];
	b[2] = a[1] - b[1], b[3] = a[2] - b[1];
	if (b[1] <= 0) return;
	s.clear();
	for (int i = 3; i <= m; ++ i) {
		if (i != p) s.insert(a[i]);
	}
	for (int i = 4; i <= n; ++ i) {	
		b[i] = *s.begin() - b[1];
		s.erase(s.begin());
		for (int j = 2; j < i; ++ j) {
			auto it = s.find(b[i] + b[j]);
			if (it == s.end()) return;
			s.erase(it);
		}
	}
	std::vector < int > tmp;
	for (int i = 1; i <= n; ++ i) tmp.push_back(b[i]);
	ans.push_back(tmp);
	return;
}

inline int cmp(vector < int > &a, vector < int > &b) 
{
	for (int i = 0; i < n; i++) {
		if (a[i] == b[i]) continue;
		return a[i] > b[i];
	}
}

signed main()
{
	while (std::cin >> n) {
		m = n * (n - 1) / 2;
		for (int i = 1; i <= m; ++ i) a[i] = read();
		std::sort(a + 1, a + m + 1);
		for (int i = 3; i <= m; ++ i) {
			if (i == 3 || a[i] != a[i - 1]) solve(i);
		}
		if (!ans.size()) {
			ans.clear();
			puts("Impossible");
			continue;
		}
		std::sort(ans.begin(), ans.end(), cmp);
		for (int i = 0; i < ans.size(); ++ i) {
			for (int j = 0; j < n; ++ j) printf("%d ", ans[i][j]);
			puts("");
		}
		ans.clear();
	}
	return 0;
}
```


---

## 作者：jiangyanheng (赞：4)

个人太菜了，于是就有了这个超级暴力(~~同时爆肝~~)的写法：

看到一串和，先随便找三个，解出来三个数
 
 $a_{1}=\frac{s_{1}+{s_{2}}-s_{3}}{2}$，同理得到$a_{2}$和$a_{3}$
 
然后，让输入的每一个和分别减去$a_{1}$、$a_{2}$、$a_{3}$，得到一大串可能的答案

每个真正的答案在串中肯定出现了最少3次（分别与三个数相减）

于是，就可以生成序列然后排序了

然而，细节巨多，代码巨长，复杂度也巨大(~~但貌似能过这道题~~)

```cpp
//先枚举前三个,算出来a1,a2,a3 
//先全部存下,然后nlogn排个序再二分查找(疯狂模拟)
//爆肝一上午,只肝出来这一道 
#include<algorithm> 
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#define mem(a,b) memset(a,b,sizeof(a))
using namespace std;
inline int f_in(){
	int f=0;char c=getchar(),t=1;
	while(c<'0' || c>'9'){if (c=='-')t=-1;if (c==EOF) exit(0);c=getchar();}
	while('0'<=c && c<='9'){f=f*10+c-'0';c=getchar();}
	return f*t;
}
const int N=20;
const int M=(N*N)/2;
struct node1{
	int num,ti;//当前获得的数字、获得的次数 
}tans[M],ssum[M];//sum序列需要缩一下,方便二分查找
int serch(int l,int r,node1 tmp[],int num){//这里搜出来的是刚好<=的下标 
	if (l>=r) return l;
	int mid=(l+r)>>1;
	if (tmp[mid].num==num) return mid;
	if (tmp[mid].num<num) return serch(mid+1,r,tmp,num);
	else return serch(l,mid-1,tmp,num);
}
int sum[M];
int n;
int mm; 
bool comp1(int a,int b){
	return a<b;
}
int ans[N];
int f3[20];
int m;
void calc3(){//先计算出来前三个的值 
	double tmp;
	tmp=(f3[1]+f3[2]-f3[3])/2;
	mem(ans,0);
	if (tmp<0) return;
	if (floor(tmp)<tmp) return;
	ans[1]=(int)tmp;
	tmp=(f3[1]+f3[3]-f3[2])/2;
	if (tmp<0) return;
	if (floor(tmp)<tmp) return;
	ans[2]=(int)tmp;
	tmp=(f3[2]+f3[3]-f3[1])/2;
	if (tmp<0) return;
	if (floor(tmp)<tmp) return;
	ans[3]=(int)tmp;
}
bool check(){
	int tmp[3*M];
	mem(tmp,0);
	int cnt=0,cnt1=0,cnt2=0;
	for(int i=1;i<=m;i++){
		if (ans[1]<=sum[i])
		tmp[++cnt]=sum[i]-ans[1];
		if (ans[2]<=sum[i])
		tmp[++cnt]=sum[i]-ans[2];
		if (ans[3]<=sum[i])
		tmp[++cnt]=sum[i]-ans[3];
	}
	tmp[++cnt]=ans[1];//因为 calc3 里把存tans的去掉了,所以这里手动添加 
	tmp[++cnt]=ans[1];
	tmp[++cnt]=ans[2];
	tmp[++cnt]=ans[2];
	tmp[++cnt]=ans[3];
	tmp[++cnt]=ans[3];
	sort(tmp+1,tmp+cnt+1,comp1);	
	for(int i=1;i<=cnt;i++){//统计次数 
		if (tmp[i]!=tmp[i-1]){
			tans[++cnt1]=(node1){tmp[i],1};
		}
		else tans[cnt1].ti++;
	}
	for(int i=1;i<=cnt1;i++){
		while(tans[i].ti>=3){ //每个真正的答案出现3次 
			ans[++cnt2]=tans[i].num;//可能有重复的数 
			tans[i].ti-=3;
		}
	}
	int vis[M];
	memset(vis,0,sizeof(vis));
	for(int i=1;i<n;i++){
		for(int j=i+1;j<=n;j++){
			int idx=serch(1,mm,ssum,ans[i]+ans[j]);
			if (ssum[idx].num!=ans[i]+ans[j]) return false;
			vis[idx]++; //检查生成的序列 与 入读的序列是否匹配 
		}
	}
	for(int i=1;i<=mm;i++){//检查匹配的次数 
		if (vis[i]!=ssum[i].ti) return false;
	}
	return true;
}
void printt(){
	sort(ans+1,ans+n+1,comp1);
	for(int i=1;i<=n;i++){
		printf("%d ",ans[i]);
	}
	return;
}
bool ret=0;
void dfs(int f,int la){//枚举前三个数 
	if (f>3){
		if (ret) return;
		calc3();
		if (check()) printt(),ret=1;
		return;
	}
	if (ret) return;
	for(int i=la;i<=m;i++){
		f3[f]=sum[i];
		dfs(f+1,i+1);
		f3[f]=0;
	}
	if (ret) return;
}
int main(){
	while(1){
		mm=0;
		ret=0;
		mem(f3,0);
		mem(ans,0);
		mem(sum,0);
		mem(ssum,0);
		mem(tans,0);//多组数据 
		n=f_in();
		m=n*(n-1)/2;
		for(int i=1;i<=m;i++){
			sum[i]=f_in();
		}
		sort(sum+1,sum+m+1,comp1);
		for(int i=1;i<=m;i++){//去重,方便二分查找 
			if (sum[i]==sum[i-1]) ssum[mm].ti++;
			else ssum[++mm]=(node1){sum[i],1};
		}
		dfs(1,1);
		if (ret){
			putchar('\n');
			continue;
		}
		printf("Impossible\n");
	}
}
```


---

## 作者：bugaile (赞：3)

题目大意$:$

给定一个$n$,再给出没对数的和,求出一堆合法的数列.

我看见之前大佬的题解都是在推公式,本蒟蒻只能想到无脑爆搜.


先将$sum$数组从小到大排序,然后根据$sum$数组,我们可以很容易的求出合法数列中的最大元素的值得范围.

$sum[1]/2<=maxnum <=sum[n*(n-1)/2-1]$(其实这里可以将值域缩得更小)

这个大概想一下就可以了,然后在这个值域上枚举一个数列中的元素,记为$now$,然后在大于$now$的$sum$里面爆搜含有$now$这个元素的$sum$,判断是否合法.合法就直接输出.剪枝详见代码.

``` cpp

#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;

int num[55];

int vis[200010];

int ans[15],n,now,tot,can;

int ans_[15],num_[55];

inline void judge(){
	
	for(int i=1;i<n;++i)
		ans_[i]=ans[i]-now;
	
	ans_[n]=now;//找出当前搜出的序列;
	
	int cnt=0;
	
	for(int i=1;i<=n;++i)
		for(int j=1;j<i;++j)
			num_[++cnt]=ans_[i]+ans_[j];//找出当前的数对和;
	
	sort(num_+1,num_+1+tot);//排序方便比较;
	
	for(int i=1;i<=tot;++i)
		if(num_[i]!=num[i])
			return ;//如果不合法就直接返回;
	
	for(int i=1;i<n;++i)
		cout<<ans_[i]<<' ';//输出答案;
	
	cout<<now<<endl;
	can=1;//标记找到答案;
	return ;
//	exit(0);
}

void dfs(int p,int h){
	
	if(can)
		return ;//已有答案,就直接返回;
	
	if(h==n-1){//已经找到一种序列;
		judge();
		return ;
	}
	
	if(h+tot-p+1<n-1)//如果剩余元素不够,直接返回;
		return ;
	
	int flag=1;
	
	for(int i=1;i<=h;++i)
		if(vis[num[p]-now+ans[i]-now]<=0){//判断当前这个数对和所对应的元素与之前的元素的和是否在给定的数对和中存在;
			flag=0;//如果不存在.说明当前这个数对和如果加入序列是必定不合法的,所以不将其加入;
			break;
		}
	
	if(flag){
		--vis[num[p]];//这里可以将新增的所有数对和都减去1,达到更强的剪枝;
		ans[h+1]=num[p];
		dfs(p+1,h+1);
		++vis[num[p]];//还原现场;
	}
	
	dfs(p+1,h);
	
	return ;
}

int main(){
//	freopen("sum.in","r",stdin);
//	freopen("sum.out","w",stdout);
	while(scanf("%d",&n)==1){
	memset(vis,0,sizeof vis);//初始化;
	can=0;
	
	tot=n*(n-1)/2;
	
	int sum=0;
	
	for(int i=1;i<=tot;++i)
		cin>>num[i],
		++vis[num[i]];
	
	sort(num+1,num+1+tot);
	
	int low=num[1]+1>>1;//求出值域;
	int high=num[tot-1];
	int st=tot-1;
	
	num[0]=-1;
	
	for(int i=high;i;--i){
		now=i;
		if(i<=num[st-1])
			--st;//更新大于now的sum集合的其实位置;
		dfs(st,0);
	}
	
	if(!can)//处理无解情况;
		puts("Impossible");
	}
	return 0;
}

```



---

## 作者：aaron0919 (赞：2)

## [P1286の题解](https://www.luogu.com.cn/problem/P1286)

本人第一篇题解！！就崩溃了。。。~~_终于找到能发的了_~~

有一点说一下，题目中分号没用 `\dfrac{n(n-1)}{2}`，用的 `\frac{n(n-1)}{2}`，一行里扁扁的看不下去！！！

### 题目描述
给定 $n$，和 $a_1+a_2,\ a_1+a_3,\dots \ a_1+a_n,\ a_2+a_3,\ a_2+a_4,\dots,\ a_2+a_n,\dots\ a_{n-1}+a_n$
求 $a_1,\ \dots,\ a_n$（多组数据）。

~~_打 Latex 手废了。_~~

贴张图（来自@[YudeS](https://www.luogu.com.cn/user/118662)）
![](https://s2.ax1x.com/2019/10/07/uRczDJ.png)

### 数学分析

理性分析：尝试~~_打表_~~找规律

设输入为 $ans_1 + ans_2,\ \dots\ ,ans_{n-1}+ans_n$，即 $a_1,\ a_2,\ \dots,\ a_n$。

---
$n = 3$

输入 $a_1,\ a_2,\ a_3$，你是不是很快就能知道：

$$\begin{aligned}
    a_1 + a_2 + a_3 &= (ans_1 + ans_2) + (ans_1 + ans_3) + (ans_2 + ans_3)\\
    a_1 + a_2 + a_3 &= ans_1 + ans_1 + ans_2 + ans_2 + ans_3 + ans_3\\
    a_1 + a_2 + a_3 &= 2(ans_1 + ans_2 + ans_3)\end{aligned}$$

则

$$\begin{aligned}
    ans_1 &= \dfrac{a_1 + a_2 + a_3}{2} - a_3\\
    ans_2 &= \dfrac{a_1 + a_2 + a_3}{2} - a_2\\
    ans_3 &= \dfrac{a_1 + a_2 + a_3}{2} - a_1\end{aligned}$$

只求 $ans_1$ 的话

$$\begin{aligned}
    a_1 + a_2 - a_3 &= (ans_1 + ans_2) + (ans_1 + ans_3) - (ans_2 + ans_3)\\
    a_1 + a_2 - a_3 &= ans_1 + ans_2 + ans_1 + ans_3 - ans_2 + ans_3\\
    a_1 + a_2 - a_3 &= 2 \times ans_1\\
    ans_1 &= \dfrac{a_1 + a_2 + a_3}{2}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (1)\end{aligned}$$
---
$n = 4$

输入 $a_1,\ a_2,\ a_3,\ a_4,\ a_5,\ a_6$，你是不是依然很快就能知道：

$$\begin{aligned}
    a_1 + a_2 + a_3 + a_4 + a_5 + a_6 &= (ans_1 + ans_2) + (ans_1 + ans_3) + (ans_1 + ans_4) + (ans_2 + ans_3) + (ans_2 + ans_4) + (ans_3 + ans_4)\\
    a_1 + a_2 + a_3 + a_4 + a_5 + a_6 &= ans_1 + ans_1 + ans_1 + ans_2 + ans_2 + ans_2 + ans_3 + ans_3 + ans_3 + ans_4 + ans_4 + ans_4\\
    a_1 + a_2 + a_3 + a_4 + a_5 + a_6 &= 3(ans_1 + ans_2 + ans_3 + ans_4)\end{aligned}$$
---
则...

停！这里是四个数的和，而题目给的是两个数，并不能直接求出来，是吧？

怎么可能是呢，干嘛要先求四个数，直接求三个数不就行了吗？

再接着，求出第一个数，$ans_2,\ ans_3,\ ans_4$ 就能通过 $a_1,\ a_2,\ a_3$ 直接求出来。

**注意，$a_1,\ a_2,\ \dots$ 是不固定的，要枚举所有可能。**

~~_好的，打 Latex 手又废了。_~~

分析完毕，分析结果：我找不到规律，暴力即可。（要不然要 $n < 10$ 干嘛，$10$ 都不包括）

---
### 程序实现
主题框架
1. 枚举 $ans_1$。
2. 计算出 $ans_2,\ ans_3$。
3. 用搜索枚举 $ans_k = a_i - ans_1$。

细节
1. 输入时判断所有数的和是否为 $n - 1$ 的倍数（可以从我辛辛苦苦打的公式那证明，证明略），如果不是，那就 `dream it possible`（在梦中成立）。
2. 判断合法的方式，选择 $ans_i$ 的时候判断是否有 $ans_i + ans_j = a_k$，没有就不合法。

### code

AC code:

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

int n, flag;
int ans[20], a[200];
map<int, int> vis; // 谁告诉 you 每个数不重复

bool check(int num, int k) // 检查是否合法，二分的感觉
{
    for (int i = 1; i < k; i++)
    {
        if (!vis[num + ans[i]])
        {
            return false;
        }
    }
    return true;
}

void dfs(int k, int s) // 已枚举到完 ans_{k-1}，上一个合法的是到 a_s
{
    if (k > n) // 枚举完输出
    {
        for (int i = 1; i <= n; i++)
        {
            printf("%d ", ans[i]);
        }
        printf("\n");
        flag = 1;
        return;
    }
    for (int i = s; i <= n * (n - 1) / 2; i++) // 枚举 ans_k
    {
        if (check(a[i] - ans[1], k))
        {
            ans[k] = a[i] - ans[1]; // 求出 ans_k

            for (int j = 1; j < k; j++) // 不知道叫什么
            {
                vis[ans[k] + ans[j]]--;
            }

            dfs(k + 1, i + 1); // 递归

            if (flag) // 找到就退出
            {
                return;
            }
            for (int j = 1; j < k; j++) // 回溯
            {
                vis[ans[k] + ans[j]]++;
            }
        }
    }
}
int main()
{
    while (scanf("%d", &n) == 1) // 等价于 ~ 和 != EOF
    {
        flag = 0; // 重置
        int sum = 0;
        vis.clear();
        for (int i = 1; i <= n * (n - 1) >> 1; i++) // 数入
        {
            scanf("%d", &a[i]);
            sum += a[i];
            vis[a[i]]++;
        }
        if (sum % (n - 1)) // 判断无解
        {
            printf("Dream it possible\n");
            continue;
        }
        sort(a + 1, a + 1 + n * (n - 1) / 2);
        for (int i = 0; a[1] - i > i; i++) // 枚举第一个数
        {
            ans[1] = i;
            ans[2] = a[1] - i;
            ans[3] = a[2] - i;
            vis[a[1]]--;
            vis[a[2]]--;
            if (vis[ans[2] + ans[3]])
            {
                vis[ans[2] + ans[3]]--;

                dfs(4, 3); // 已经选出前三个了，选第四个

                if (flag) // 已找到
                {
                    break;
                }
                vis[ans[2] + ans[3]]++;
            }
            vis[a[1]]++;
            vis[a[2]]++;
        }
        if (!flag) // 没找到，好强的数据
        {
            printf("Dream it possible\n");
            continue;
        }
    }
    return 0;
}
```

### 鸣谢

1. 让我少打了亿点点 $\LaTeX$ 的 @[YudeS](https://www.luogu.com.cn/user/118662)。
2. 给我没通过的审核，但提出了宝贵的标点符号建议 @[swiftc](https://www.luogu.com.cn/user/183154)。
3. 给我没通过的审核，但给出了宝贵的标题建议 @[CSP_Sept](https://www.luogu.com.cn/user/224931)。
4. 给我没通过的审核，但给出了宝贵的标题建议 @[_maze](https://www.luogu.com.cn/user/149219)。
5. 给我没通过的审核，但给出了宝贵的标点符号建议 @[蒟蒻君HJT](https://www.luogu.com.cn/user/131591)
6. 给我没通过的审核，但给出了宝贵的行号建议 @[_maze](https://www.luogu.com.cn/user/149219)

~~_鸣谢这么多应该能过了_~~

---

## 作者：B_Qu1e7 (赞：2)

简单讲下思路。

假设解为：ans[]={a,b,c,……};

则首先保证a<b<c<……

之后，用一种特别简单的方法（当然这是在本题数据范围小的情况下……）就是

###枚举……

#做法：

枚举第一个数，由于保证出解顺序（当然这也是题目的要求），我们将m数组排序（m数组为输入的n\*(n-1)/2个数）

这时，因为a<b<c<……，所以a+b=m[1]（m[1]就是m数组中最小的数）。

所以第一个数的枚举范围是1~m[1]/2（因为a<b）

循环枚举不再说……


接下来，就是查找解

确定了a之后，b、c也就浮出水面

```cpp
根据
a+b=m[1]
a+c=m[2]
这两条式子（只有这两条可以确定，因为m[3]有可能为a+d，也有可能为b+c。所以接下来还要接着找解）
得到b,c
b=m[1]-a
c=m[2]-a
```
接下来就是找该解所有可能的解（见代码）

不废话，还是看代码

（还有，本题输出顺序个人认为应该是最小的解？）

（蒟蒻也很无奈）

（^o^尴尬而又不失礼貌的微笑）

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
int n,m[37],f[37],o[37],t,s,p=0,fla=0;//不多解释了，f为解
int findnum(int x)//若在m数组内有x数即清除（我把m数组copy到o内了）
{
    for(int i=1;i<=s;i++)
    {
        if(o[i]==x)return i;//返回其编号（可以用个二分查找啥的，减少时间复杂度）
    }
    return 0;//否则返回false
}
}
void findans(int i)//对于每一个枚举的a，查找当前解
{
    p=0;
    memset(f,0,sizeof(f));//解
    memcpy(o,m,sizeof(o));//copy一份，保留原数
    f[1]=i;
    f[2]=o[1]-i;
    o[1]=0;
    f[3]=o[2]-i;
    o[2]=0;
    if(!findnum(f[2]+f[3]))return;//算剪枝吗
    o[findnum(f[2]+f[3])]=0;//去掉这个数
    t=3;
    while(!f[n])//还没找到解
    {
        //sort(o+1,o+s+1);//这个其实不用，因为m已经排过了 
        for(int j=3;j<=s;j++)//找解 
        {
            if(o[j])//这个和还没有被使用 
            {
                f[++t]=o[j]-i;//使用这个和出下一解 
                o[j]=0;//去掉该和 
                for(int l=2;l<t;l++)
                {
                    if(!findnum(f[l]+f[t])){p=1;break;}//不能出解，立flag 
                    o[findnum(f[l]+f[t])]=0;//去掉该和 
                }
            }
            if(p)return;//不能出解则退出
        }
        //if(p)return;//去掉，因为不可能退到这里 
    }
    for(int l=1;l<=n;l++)//无论怎样，没有返回就是出解了 
    {
        cout<<f[l]<<" ";
    }
    cout<<endl;
    fla=1;//再来一个flag(frog)尝尝怎么样
}
void ass()
{
    sort(m+1,m+s+1);//排序 
    for(int i=1;i<=m[1]/2;i++)//查找范围 
    {
        findans(i);//查找解 
    }
    if(!fla)puts("Impossible");//flag还没标记？那这个数据就是无解咯 
    //在这里出现了一个超级煞笔的错误，puts原本自带回车，结果没事在里面再写了一个回车 AJAX:too long or too few lines 
}
int in()
{
    s=n*(n-1)/2;//输入数据的个数 
    for(int i=1;i<=s;i++)
    {
        cin>>m[i];
    }
}
int main()
{
    while(cin>>n)//没看到“多组数据”貌似 icy dalao 和 Night_Aurora dalao 都是掉这坑吧 
    {
        fla=0;//当前还没找到解 
        in();//输入 
        ass();//出解 
    }
}
//貌似不需要优化的样子，怎么都是0ms，数据出大一点呗 
```

---

## 作者：fyfy (赞：2)

### 这题其实可以用vector水掉！

### 定义：

记住要用结构体(c为价格，x为美丽值)！

以c排序。

```cpp
struct Node {
	int x,c;
	bool operator < (const &Node t) const {
    	return c<t.c;
    }
}
vector <Node> a;
```

### 插入：

upper_bound的作用是将当前节点插到合适位置，以达到排序效果。

记住不能插入同样价格的花。

所以用vis[]数组统计。

```cpp
if (vis[c]) continue;
vis[c]=1;
a.insert(upper_bound(a.begin(),a.end(),(Node){x,c}),(Node){x,c});

```

### 删除：

大节点就删除最后一个，记住要把vis[]清掉。

vector区间是左闭右开的，所以删除erase(a.end()-1)。

即：

```cpp
if (opt==2) vis[a[a.size()-1].c]=0,a.erase(a.end()-1);
```

小节点就删除第一个，即：

```cpp
if (opt==3) vis[a[0].c]=0,a.erase(a.begin());
```

### 代码：

注意要开long long～

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef int _int;
#define int long long
struct Node {
    int x,c;
    bool operator < (const Node &t) const {
        return c<t.c;
    }
};
vector <Node> a;
int ans1,ans2;
bool vis[1000001];
_int main()
{
    int opt,x,c;
    while (1) {
        scanf("%lld",&opt);
        if (opt==-1) break;
        if (opt==1) {
            scanf("%lld%lld",&x,&c);
            if (vis[c]) continue;
            vis[c]=1;
            a.insert(upper_bound(a.begin(),a.end(),(Node){x,c}),(Node){x,c});
        }
        if (!a.size()) continue;
        if (opt==3) vis[a[0].c]=0,a.erase(a.begin());
        if (opt==2) vis[a[a.size()-1].c]=0,a.erase(a.end()-1);
    }
    int len=a.size();
    for (int i=0;i<len;++i) ans1+=a[i].x,ans2+=a[i].c;
    cout<<ans1<<' ';
    cout<<ans2<<endl;
    return 0;
}
```

---

## 作者：yxchar (赞：1)

似乎也没有用到什么很强大的数学工具orz，单纯的暴搜加一些必要的剪枝也就过了。

具体思路是这样的，假设最终答案按从小到大排序分别为a1,a2,...,an，将给定的n*(n-1)/2个数按从小到大排序，从中选择n-1个数分别作为a1+a2,a1+a3,a1+a4...,a1+an，这样枚举a1的值，就可以计算出a2,a3,...an了，在选择aj+ai的过程中顺便判断一些目前剩下的数里存不存在某个bi使得aj+ai==bi(1<=j<i),如果存在，那这种选择就是暂时合法的。
附上比较丑的代码：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int n,a[101],vis[200100],fla,b[101];
inline bool check(int num,int ind){
	for(int i=1;i<ind;i++) 
		if (!vis[num+a[i]]) return 0;
	return 1;
}
void dfs(int x,int lim,int a1){
	if (x>n){
		for (int i=1;i<=n;i++) printf("%d ",a[i]);
		printf("\n");
		fla=1;
		return;
	}
	for (int i=lim;i<=n*(n-1)/2;i++)
		if (check(b[i]-a1,x)){
			a[x]=b[i]-a1;
			for (int j=1;j<x;j++)
				vis[a[x]+a[j]]--;
			dfs(x+1,i+1,a1);
			if (fla) break;
			for (int j=1;j<x;j++)
				vis[a[x]+a[j]]++;
		}
}
void work(){
	memset(vis,0,sizeof(vis));
	fla=0;
	for (int i=1;i<=n*(n-1)/2;i++) {scanf("%d",b+i);
		vis[b[i]]++;
	}
	if (n==2){
		if (b[1]==0) cout<<"Impossible"<<endl;
		else cout<<0<<" "<<b[1]<<endl;
		return;
	}
	sort(b+1,b+n*(n-1)/2+1);
	for (int i=0;b[1]-i>i;i++){
		a[1]=i; a[2]=b[1]-i; a[3]=b[2]-i;
		vis[b[1]]--; vis[b[2]]--;
		if (vis[a[2]+a[3]]){
			vis[a[2]+a[3]]--;
			dfs(4,3,a[1]);
			if(fla) break; 
			vis[a[2]+a[3]]++;
		}
	}
	if (!fla) cout<<"Impossible"<<endl;
}
int main(){
	while(cin>>n) work();
	return 0; 
} 
```

---

## 作者：a13518354766 (赞：1)

## 提供一个新思路

这题,我们假设n个数分别为a1,a2,a3,a4,a5...an,且对于任意

1<=i<j<=n满足ai<aj

而他们两两之和即为输入的各数字,从中,我们不难推出对于输入的数字中(我们把它们按从小到大排序,分别设为m1,m2...)

一定满足:m1=a1+a2,m2=a1+a3(我们可以用反证法证明结论)

但m3有两种情况:m3=a1+a4或者m3=a2+a3,我们无法判断,那么,

### 为什么我们不能把a2+a3的情况排除呢？

所以我们可以这样做:
同样枚举a1(1->m1/2),然后算出a2,a3。这时,我们对a2+a3的数字打个标记,当下次访问到的时候将标记取消说明剩下的数字不是a2+a3,那么,剩下的数的最小的那一个一定是a1+a4!同理我们对a2+a4,a3+a4打标记。。。
最后就能求出所有的a了,如果我们求完了n个数,然而,还有数没被打上标记,就说明此时的a1时错误的我们需要重新枚举。

最后,我们就可以求出答案了~

代码:

    #pragma GCC optimize(3)//手动Ox优化
    #include<bits/stdc++.h>
    using namespace std;
    const int N=1e5+2;
    int a[N],tot;
    int biao[N],maxe;
    int ans[N];
    bool F=0;
    int n;
    inline void print(){//输出答案 
        for(int i=1;i<=n;++i){
            printf("%d ",ans[i]);
        }
        putchar('\n');
    }
    inline void dfs(int x){
        memset(biao,0,sizeof(biao));
        ans[1]=x,ans[2]=a[1]-x,ans[3]=a[2]-x;
        biao[ans[2]+ans[3]]++;//标记记得用int,因为可能存在两组数之和相等的情况 
        int zhi=4;
        F=1;//假设这次是正确的 
        for(int i=3;i<=tot;++i){
            if(biao[a[i]]){
                biao[a[i]]--;
                continue;
            }
            ans[zhi++]=a[i]-x;
            if(zhi>n+1){
                F=0;//本次答案错误 
                return;
            }
            for(int j=2;j<zhi-1;++j){
                if(ans[zhi-1]+ans[j]>maxe){//如果和大于最大值,肯定错误,跳过 
                    F=0;//本次答案错误 
                    return;
                }
                biao[ans[zhi-1]+ans[j]]++;//打上标记 
            }
        }
    }
    int main(){
        while(~scanf("%d",&n)){
            tot=n*(n-1)/2,maxe=0;
            for(int i=1;i<=tot;++i){
                scanf("%d",&a[i]);
                maxe=maxe>a[i]?maxe:a[i];//求最大值 
            }
            sort(a+1,a+tot+1);//排个序~ 
            bool flag=0;
            for(int i=1;i<=a[1]/2;++i){
                dfs(i);
                if(F){
                    flag=1,F=0;//找到正确答案,F记得清零 
                    print();//输出 
                    break;
                }
            }
            if(!flag){
                printf("Impossible\n");
                continue;
            }
        }
        return 0;
    }
    /**
    *　　┏┓　　　┏┓+ +
    *　┏┛┻━━━┛┻┓ + +
    *　┃　　　　　　　┃
    *　┃　　　━　　　┃ ++ + + +
    *  ████━████+
    *  ◥██◤　◥██◤ +
    *　┃　　　┻　　　┃
    *　┃　　　　　　　┃ + +
    *　┗━┓　　　┏━┛
    *　　　┃　　　┃ + + + +Code is far away from 　
    *　　　┃　　　┃ + bug with the animal protecting
    *　　　┃　 　 ┗━━━┓ 神兽保佑,代码无bug　
    *　　　┃ 　　　　　　 ┣┓
    *　　  ┃ 　　　　　 　┏┛
    *　    ┗┓┓┏━┳┓┏┛ + + + +
    *　　　　┃┫┫　┃┫┫
    *　　　　┗┻┛　┗┻┛+ + + +
    */



---


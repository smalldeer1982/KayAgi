# 最接近的分数

## 题目描述

给出一个正小数，找出分子（分子 $ \ge 0$）不超过 $M$，分母不超过 $N$ 的最简分数或整数，使其最接近给出的小数。“最接近”是指在数轴上该分数距离给出的小数最近，如果这个分数不唯一，输出 ``TOO MANY``。

## 说明/提示

### 数据范围及约定

对于全部数据，保证 $1\le M,N\le 10^7$。

## 样例 #1

### 输入

```
360 120
3.1415926536
```

### 输出

```
355/113
```

# 题解

## 作者：qwaszx (赞：26)

暴力太不优雅了，来讲一种优雅的做法

有一种神奇的东西叫做Stern-Brocot树

先上图

![](https://img-blog.csdn.net/20131019215015671?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTM3OTM4NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

(图片来自[这里](https://blog.csdn.net/eternaldespair/article/details/12876093))

初始两个分数$0/1$和$1/0$，然后每次对于相邻的两个分数$m/n$和$m'/n'$，把$(m+m')/(n+n')$插入到它们中间.

可以证明它枚举了所有非负有理数.

对于任何阶段的相邻分数都有$m'n-mn'=1$，这可以通过归纳法证明.于是可以得到两个结论:

1. $gcd(n,m)=1$，根据裴蜀定理

2. $\frac{m}{n}<\frac{m+m'}{n+n'}<\frac{m'}{n'}$ 很明显

这两个性质可以保证构造出所有非负有理数，因为每往下走一层分子和分母中至少有一个会增加.

还有一点是这棵树是一个二叉搜索树

对于一个数$x$，寻找离他最近的分数只需要进行如下的操作:

```cpp
int sgn(double x){return (x>eps)-(x<-eps);}
int lm=0,ln=1,rm=1,rn=0;
for(int mm=1,nn=1;mm<=m&&nn<=n;mm=lm+rm,nn=ln+rn)
{
	switch(sgn(x-1.*mm/nn))
	{
		case 0:{printf("%d/%d\n",mm,nn);return 0;}
		case 1:lm=mm,ln=nn;break;
		case -1:rm=mm,rn=nn;break;
	}
}
```
和二叉查找树操作差不多.

不过这样只是限定了$x$在$[lm/ln,rm/rn]$范围内，还需要判断一步才行.

实现上为了减小常数规避了除法.不过这题的数据看起来还是挺水的，优不优化一个样

复杂度$O(n)$，但实际上只有极大和极小的数会卡到这个级别，一般是$O(\log n)$左右的(斐波那契数列式增长?).

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const double eps=1e-15;
int n,m;double x;
int sgn(double x){return (x>eps)-(x<-eps);}
int main()
{
	scanf("%d%d",&m,&n);
	scanf("%lf",&x);
	int lm=0,ln=1,rm=1,rn=0;
	for(int mm=1,nn=1;mm<=m&&nn<=n;mm=lm+rm,nn=ln+rn)
	{
		switch(sgn(x*nn-mm))
		{
			case 0:{printf("%d/%d\n",mm,nn);return 0;}
			case 1:lm=mm,ln=nn;break;
			case -1:rm=mm,rn=nn;break;
		}
	}
	if(rn==0){printf("%d/%d\n",lm,ln);return 0;}
	switch(sgn((x-1.*lm/ln)-(1.*rm/rn-x)))
	{
		case 1:printf("%d/%d\n",rm,rn);break;
		case 0:puts("TOO MANY");break;
		case -1:printf("%d/%d\n",lm,ln);
	}
}
```
猜测$rank1$也是写的这个东西并且新评测姬跑得略慢(

---

## 作者：wjy666 (赞：25)

wa了N遍终于A了。。。

看到这题，最容易想到的就是枚举分子和分母一个个算，然而这样O(nm)肯定要炸

进一步思考，发现可以枚举分母，然后将分母乘以给出的小数得到分子的近似值，这样便大大减小了时间复杂度

然后题目中要求分子分母互质，所以又想到用辗转相除求gcd，但是这样会T！！！

再仔细一想，发现这也可以用O(1)解决：

设当前分子分母为x,y,且x=ad,y=bd(d>1)，于是只有2种情况：

1、a，b不是当前最优解，那么x,y我们就不用管了

2、a，b是当前最优解，那么我们只需要特判一下:如果a\*y==b\*x，那么说明x,y不互质，接下来的操作也不用管了

主要思想就是这些，但是这题还有很多细节要注意，反正我被坑了很多次......

上代码(语文不好，凑合看吧)

```cpp
#include<cstdio>
#define For(i,j,k) for(register int i=j;i<=k;++i)
using namespace std;
int main(){
    double xs,cha=10.0,f; //cha存储当前的最优解与小数的接近程度
    int m,zi,mu,n,ans=-1,js; //ans赋初值-1，后面有大用
    scanf("%d%d",&n,&m); scanf("%lf",&xs); //输入，xs就是小数值，n是分子，m是分母，和题目里相反
    For(i,1,m){//枚举分母
        js=xs*i; //当前分子的近似值，先向下取整
        if (js>n) break; //大于n就可以退出了
        f=(double)js/(double)i; //f是当前的分数值
        if (i==1) {ans=1; cha=xs-f; zi=js; mu=i;} //zi是分子，mu是分母，这一行是赋初值，要不然后面会炸，我被卡好久
        else if (zi*i!=mu*js){ //判断i和js是否互质，原理上面有
            if (xs-f==cha) ans++; //如果小数与分数的差与当前最优相同就ans++,之后输出时ans大于1就输出too many
        //因为f是向下取整的分数值，所以能保证小数大于等于分数值，不用取绝对值
            if (xs-f<cha){
                ans=1; cha=xs-f; zi=js; mu=i;
            }
        }
        js++; //接下来向上取整，接下来的操作都和上面差不多了
        if (zi*i!=mu*js&&js<=n){
            f=(double)js/(double)i;
            if (f-xs==cha) ans++; //向上取整的分数值保证大于等于小数值，也不用取绝对值
            if (f-xs<cha){
                ans=1; cha=f-xs; zi=js; mu=i;
            }
        }
    }
    if (ans>1) printf("TOO MANY\n");
    else if (ans==-1) printf("%d/1\n",n); //如果ans还是初值-1，就说明分子可取的最大值n小于小数值xs(因为i=1就退出来了)，这时直接输出分子最大，分母最小的情况(我之前没加这个特判被卡好几次)
    else printf("%d/%d\n",zi,mu); //如果ans为1就正常输出
    return 0;
}
```

---

## 作者：言琢დ (赞：8)

**upd：本题解已经通过审核，需要修正一个复杂度。**

这是一种逼近分数的原理。

对于分数

$$\dfrac{x}{y}<\dfrac{u}{v}$$

可以构造一个新的分数

$$\dfrac{x}{y}<\color{red}\dfrac{x+u}{y+v}\color{black}<\dfrac{u}{v}$$

这个证明可以考虑直接通分去证：

考虑左边：

$$\dfrac{x}{y}<\color{red}\dfrac{x+u}{y+v}$$

转证：

$$x(y+v)<y(x+u)$$

转证：

$$xv<yu$$

转证：

$$\dfrac{x}{y}<\dfrac{u}{v}$$

这是我们的前提，所以得证。另一边类似的方式也可以转化到这一步上。

据此，我们可以得到一个最好复杂度 $O(\log M)$ 的做法。

考虑每次两数相加，得到的一定是最小情况下的最逼近解。

最坏复杂度 $O(M)$，考虑构造

```cpp
1 10000000
0.0000001
```

式的数据即可，核心代码：

```cpp
while(1){
    xu=x+u,yv=y+v,xyuv=xu/yv;
    if((xu>m||yv>n)&&t)break;
    if(xyuv<p)x=xu,y=yv;
    else u=xu,v=yv;
    if(ab(xyuv,p)==cha)ans++;
    else ans=1;
    t=1;
} // 初一时期的代码略有点丑
```

---

## 作者：Presentation_Emitter (赞：7)

**Update 6/18 14:25**:发现这玩意就是 Stern-Brocot 树的一棵子树。果然还是太菜了。。。

下面的某些话请无视。

***

本人太菜不知道 $\text{Stern-Brocot}$ 树。然后在某次模拟赛中推出了一个神奇的像二叉树的结构，~~但是它并没有什么特殊性质所以没用上~~，然后看到了这题。

赛时推出来的大概长这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/iolx2m8d.png)

~~和 Stern-Brocot 树挺像的~~

对于每一个节点，记其父节点点权为 $\frac{a}{b}$，上方第一个方向发生变化的节点的父节点点权为 $\frac{c}{d}$，则该点点权为 $\frac{a+c}{b+d}$。

然后就可以大力在树上搜索了。设目标为 $t$，当前节点为 $f$，$t \lt f$时在左子树找，否则在右子树找。

对于本题把刚开始的三个节点设为 $\frac{0}{1},\frac{1}{1},\frac{1}{0}$ 即可。

时间复杂度最坏是 $\Theta(n)$ 的（$n,m$ 同阶）

Code:

```cpp
#include<Atziluth.h>
using namespace std;
#define reg register
#define opr operator
#define ll __int128
#define ret return
#define gc getchar
#define pc putchar
#define cst const
#define il inline
ll cnt;
il ll rd()
{
	reg ll res=0,lab=1;cnt=0;
	reg char ch=gc();
	while((ch<'0'||ch>'9')&&ch!=EOF){if(ch=='-')lab=-lab;ch=gc();}
	while(ch>='0'&&ch<='9')++cnt,res=(res<<3)+(res<<1)+(ch&15),ch=gc();
	return res*lab;
}
il void prt(ll x,char t='\n')
{
	static char ch[40];reg int tp=0;
	if(!x){fputs("0",stdout);if(t)pc(t);return;}
	if(x<0)pc('-'),x=-x;
	while(x)ch[++tp]=(x%10)^48,x/=10;
	while(tp)pc(ch[tp--]);
	if(t)pc(t);
}
il ll umax(ll a,ll b){return a>b?a:b;}
il ll umin(ll a,ll b){return a<b?a:b;}
il ll uabs(ll x){return x>0?x:-x;}
il ll qpow(ll n,ll e=HgS-2,ll p=HgS)
{
	reg ll res=1;
	while(e){if(e&1)res=res*n%p;n=n*n%p;e>>=1;}
	return res;
}
ll n,m,f[15]={1},t1,t2;
il ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}
struct frac
{
	ll u,d;
	frac():u(0),d(1){}
	frac(ll a,ll b){ll _=gcd(a,b);u=a/_,d=b/_;}
	bool opr<(cst frac&_)cst{ret u*_.d<d*_.u;}
	bool opr>(cst frac&_)cst{ret u*_.d>d*_.u;}
	bool opr==(cst frac&_)cst{ret u*_.d==d*_.u;}
	frac opr+(cst frac&_)cst{ret frac(u*_.d+_.u*d,d*_.d);}
	frac opr-(cst frac&_)cst{ret frac(u*_.d-_.u*d,d*_.d);}
	frac opr*(cst frac&_)cst{ret frac(u*_.u,d*_.d);}
	frac opr/(cst frac&_)cst{ret frac(u*_.d,d*_.u);}
	frac opr*(cst ll&_)cst{ret frac(u*_,d);}
	frac opr/(cst ll&_)cst{ret frac(u,d*_);}
}t,ans,l,r;
il frac uabs(frac x){x.u=uabs(x.u),x.d=uabs(x.d);return x;}
il frac mid(frac a,frac b){return frac(a.u+b.u,a.d+b.d);}
il void prt(frac x,char tail='\n'){prt(x.u,'/');prt(x.d,tail);}
il void work(frac f,frac l,frac r)
{
	if(f.u>n||f.d>m)return;
	if(uabs(f-t)<uabs(ans-t))cnt=1,ans=f;
	else if(uabs(f-t)==uabs(ans-t))++cnt;
	if(t<f)work(mid(l,f),l,f);
	else work(mid(f,r),f,r);
}
int main()
{
	n=rd();m=rd();t1=rd();t2=rd();
	for(int i=1;i<=cnt;++i)f[i]=f[i-1]*10;
	if(t1>n){prt((frac){n,1});return 0;}
	t=frac(t1*f[cnt]+t2,f[cnt]);ans=frac(0,1);
	if(t.u==t.d){puts("1/1");return 0;}
	l.u=r.d=0;l.d=r.u=1;cnt=1;work(mid(l,r),l,r);
	if(!(ans==l)&&uabs(ans-t)==uabs(l-t))++cnt;
	if(!(ans==r)&&uabs(ans-t)==uabs(r-t))++cnt;
	if(cnt==1)prt(ans);else puts("TOO MANY");
	return 0;
}
```

~~所以 Atziluth 这个屑在赛时推出了 Stern-Brocot 树？~~

---

## 作者：Link_Cut_Y (赞：5)

算是水紫，不过也学到一些有用的东西。

先推销博客：[My Blog](https://www.cnblogs.com/LcyRegister/p/17365774.html)。

-------------------

## 题意

给定正小数 $N$。求分子不大于 $n$，分母不大于 $m$ 的分数 $\dfrac{n}{m}$，使得 $\dfrac{n}{m}$ 的值与 $N$ 最接近（这里的最接近指的是 $|\dfrac{n}{m} - N|$ 最小）。

## 分析

首先，大部分人都可以想到一个暴力：枚举 $i \in [1, m]$ 作为分子，计算出最佳分母 $r_1 = \lfloor i \times N \rfloor, r_2 = \lceil i \times N\rceil$。把 $r_1, r_2$ 分别带进去看看那个更优就完事了。出去判边界之类的问题，复杂度 $O(m)$。由于 $m \leq 10 ^ 7$，直接就艹过去了。如果这个都不会写可以看这里：[暴力算法](https://www.luogu.com.cn/paste/dtrpwpet)。

然而我们肯定不会满足于这样的暴力算法。来点优雅的算法吧。

-------------------------

引入**分数逼近**。这里的分数逼近是指用用一个分数来逼近另一个分数，使得误差趋于零。例如，假设需要逼近的分数为 $\dfrac{r}{s}$，有分数 $\dfrac{u}{v} > \dfrac{r}{s}$。那么有以下结论：

$$\dfrac{r}{s} \leq \dfrac{r + u}{s + v} \leq \dfrac{u}{v}$$

具体等号能不能取到记不清了，不过不影响。结论很好证明，下面证一下。

-------------------------

将 $\dfrac{r + u}{s + v}$ 与 $\dfrac{r}{s}$ 做减法，得到 $\dfrac{r + u}{s + v} - \dfrac{r}{s} = \dfrac{(r + u)s - r(s + v)}{s(s + v)} = \dfrac{us- vr}{s(s + v)}$。

因为 $\dfrac{r}{s} < \dfrac{u}{v}$，两边同时乘以 $sv$，得 $vr < us$，即 $us - vr > 0$。

又因为 $s(s + v) > 0$，所以 $\dfrac{us - vr}{s(s + v)} > 0$。证毕。

注意上面结论和证明成立的条件是 $u, v, s, r > 0$。

-------------------------

接下来引入 Stern-Brocot 树这个概念。

Stern-Brocot 树可以维护所有的正分数。这一点可以被我们用来解决这道题目。

首先介绍一下 Stern-Brocot 树。这个树由 $\dfrac{0}{1}$ 和 $\dfrac{1}{0}$ 两个分数开始。$\dfrac{1}{0}$ 不大好定义，暂且把它当做 $+ \infty$。将这两个分数作为**源节点**。

接下来，像我们刚才讨论的分数逼近，将 $\dfrac{0}{1}$ 和 $\dfrac{1}{0}$ 的分子分母分别相加，得到另外一个分数 $\dfrac{1}{1}$。这个分数确实在 $\dfrac{0}{1}$ 与 $\dfrac{1}{0}$ 之间。$\dfrac{1}{1}$ 被成为第 $1$ 层迭代后的节点。

同样的，将 $\dfrac{1}{1}$ 与 $\dfrac{0}{1}, \dfrac{1}{0}$ 分别进行操作，得到两个分数，称为第二次迭代。

所以我们得到了 Stern-Brocot 树的构建基础：将 $\dfrac{a}{b}$ 与 $\dfrac{c}{d}$ 分子分母分别相加，得到 $\dfrac{a + c}{b + d}$ 作为下一轮迭代的节点。

例如，进行三次操作后，这棵树就会变成这样：

$$\begin{array}{c} \dfrac{0}{1}, \dfrac{1}{1}, \dfrac{1}{0} \\\\ \dfrac{0}{1}, \dfrac{1}{2}, \dfrac{1}{1}, \dfrac{2}{1}, \dfrac{1}{0} \\\\ \dfrac{0}{1}, \dfrac{1}{3}, \dfrac{1}{2}, \dfrac{2}{3}, \dfrac{1}{1}, \dfrac{3}{2}, \dfrac{2}{1}, \dfrac{3}{1}, \dfrac{1}{0} \end{array}$$

注意，某些节点（就是第 $i$ 层存在，第 $i + 1$ 层也存在的节点），实际上在第 $i + 1$ 层是不会出现的。只是为了方便比较加了上去。

可以看到，第三层的第二个分数 $\dfrac{1}{3}$ 就是左右两边两个数分子分母分别相加的和。第四个，第六个和第八个以此类推。

下面是来自 OI-wiki 的一张图。

![Stern-Brocot树](https://oi-wiki.org/math/number-theory/images/stern-brocot1.png)

刚才所提到的不存在的节点就是虚线相连的那些节点。可以看到，这棵树具有二叉结构。因此在这棵树上搜索只需要花费 $O(\log_2 n)$ 的时间。非常优秀。这样对于这道题，我们就可以把小数 $N$ 从第一层开始向下搜索。如果当前节点值大于 $N$，那么向左递归。否则向右递归，直到分子或分母大于 $n$ 或 $m$。时间复杂度肯定是 $O(\log n)$。（假设 $n, m$ 同阶）。

关于最简性的证明可以看 [OI-wiki](https://oi-wiki.org/math/number-theory/stern-brocot/) 上的解释。这里不再赘述。

-------------------------------------

这道题的思路就讲解完了。注意别忘了判断多解的情况。由于刚才提到，Stern-Brocot 树具有最简性，因此放心的判断当前分数值与 $N$ 的误差和原来的是否一样就可以了。

卡常顺便卡了个 rank1。欢迎来踩。

## 代码

```cpp
#include <algorithm>
#include <cstdio>

using PII = std::pair<int, int>;
double N, m_error;
int n, m;
PII ans(0, 1);
bool flag = false;

double fabs(double x) {
    return x < 0 ? -x : x;
}
inline void get(double N, int a = 0, int b = 1, int c = 1, int d = 0) {
	int x = a + c, y = b + d;
	if (x > n || y > m) return;
	double error = (double)x / y - N;
	if (fabs(error) == m_error) flag = true;
	if (fabs(error) < m_error) {
		flag = false; ans = {x, y}; m_error = fabs(error);
		if (error == 0) return;
	}
	if (error < 0) get(N, x, y, c, d);
	else get(N, a, b, x, y);
}

int main() {
	scanf("%d%d", &n, &m);
	scanf("%lf", &N); m_error = N; get(N);
	if (flag) puts("TOO MANY");
	else printf("%d/%d", ans.first, ans.second);
	return 0;
}
```

明天就是五一劳动节。在这里提前祝大家五一快乐，多多点赞。

---

## 作者：黎明行者 (赞：5)

这题坑太多了，我WA了很多次才过，怪不得提交数那么多，通过数只有200+

看了看dalao们的题解，有人说这个题可以通过分母大致确定分子的值，从而不需要枚举整个的m * n 个分数 但是这样必须用gcd判断两个数是否互质，会TLE

Naffgo的思路是 从 1 到 m 枚举分母，然后用小数乘以分母再四舍五入即可得到分子。如果分子大于 n 则 break 。然后判断当前值是否比当前最优解优，若是则更新；若与最优解一致则判断这两个分数是否一样，若不一样则输出 TOO MANY

这种思路确实可以，但依然会用到gcd。而我想到了一种O(n)的算法，那就是从m到1枚举分母，这样就不需要求gcd来判定分子分母是否互质。

原理十分简单，如果当前解是最优解，但不是最简分数，那么在接下来的枚举中，必定会枚举到化简后的解。

需要注意特判分子j==0或ansj==0的情况，否则会出现被零除错误
我的代码：

```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <cmath>

const double INF=1e9;

inline double loss(int x,int y,double tar)
{
	double delta=(((double)x)/y)-tar;
	return fabs(delta);
}

int leagal(int x,int l,int r)
{
	if (x<l) x=l;
	if (x>r) x=r;
	return x;
}

int main()
{
	register int i,j,bs,up,dn,cnt;
	int n,m;
	register double tar;
	scanf("%d%d%lf",&n,&m,&tar);
	register int ansx,ansy;
	register double ansv=INF;
	cnt=0;
	for (i=m;i>=1;i--)
	{
		
		bs=(int)(tar*i);
		dn=leagal(bs-1,0,n),up=leagal(bs+2,0,n);
		for (int j=dn;j<=up;j++)
			if (ansv>=loss(j,i,tar))
				ansv=loss(ansx=j,ansy=i,tar);
	}
	for (i=m;i>=1;i--)
	{
		
		bs=(int)(tar*i);
		dn=leagal(bs-1,0,n),up=leagal(bs+2,0,n);
		for (j=dn;j<=up;j++)
		{
			double tansv=loss(j,i,tar);
			if (j!=0 && ansx!=0 && i%ansy==0 && j%ansx==0 && i/ansy==j/ansx) continue;
			if (j==0 && ansx==0) continue;
			if (tansv==ansv) cnt++;
		}
	}
	if (cnt>0) printf("TOO MANY\n");
	else printf("%d/%d\n",ansx,ansy);
	return 0;
}
```


---

## 作者：COsm0s (赞：4)

**分数逼近法。**

先引出一个定理。

已知两分数 $\dfrac{a}{b}$ 和 $\dfrac{c}{d}$， 且 $\dfrac{a}{b} < \dfrac{c}{d}$，则有结论：

$\dfrac{a}{b} < \dfrac{a + c}{b + d} < \dfrac{c}{d}$

证明如下：

假设 $\dfrac{a}{b} < \dfrac{a + c}{b + d}$ 这一命题为真。

$\because \dfrac{a}{b} < \dfrac{a + c}{b + d}$

$\therefore a(b + d) < b(a + c)$

两边同时消去 $ab$，得：

$ad < bc$

$\therefore\dfrac{a}{b} < \dfrac{c}{d}$

原命题得证。

同理，不等式的右半部分也可用此方法求证。


------------

回到正题。

因为题目给出的是一个正数，我们将其设为 $x$，则有 $0 < x < +\infty$。

设 $a=0,b=1,c=1,d=0$，且令 $\dfrac{1}{0}=+\infty$，则 $x$ 必在 $[\dfrac{a}{b},\dfrac{c}{d}]$ 范围内。

令 $e=a+c$，$f=b+d$，那么 $\dfrac{a}{b}<\dfrac{e}{f}<\dfrac{b}{d}$ 且 $\dfrac{e}{f}$ 必为既约分数，然后查询目标在 $[\dfrac{a}{b},\dfrac{e}{f}]$，还是 $[\dfrac{e}{f},\dfrac{c}{d}]$ 内。

理论复杂度 $O(\log n)$。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int m, n, ra, rb;
double r, mx;
bool flag = 0;
signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	int a = 0, b = 1, c = 1, d = 0;
	cin >> m >> n >> r;
	ra = 0, rb = 1, mx = r;
	while(1) {
		int e = a + c, f = b + d;
		if(e > m || f > n) break;
		if(fabs(1.0000 * e / f - r) == mx) flag = 1;
		if(fabs(1.0000 * e / f - r) < mx) {
			ra = e, rb = f, mx = fabs(1.0000 * e / f - r), flag = 0;
			if(mx == 0) break;
		}
		if(1.0000 * e / f < r)
			a = e, b = f;
		else c = e, d = f;
	}
	if(flag) cout << "TOO MANY" << '\n';
	else cout << ra << '/' << rb << '\n';
	return 0;
}
```


---

## 作者：Butterfly_qwq (赞：4)

update 2022/11/20：增加了TOO MANY的判定

这道题对于一个到处踩坑的人，来分享一下。

首先，我们考虑枚举分子分母

这个算法很简单，很可惜，复杂度是 $O(nm)$ 的，不足以通过本题

我们可以很容易地发现，对于一个分子，只有两个分母有用，设分子为 $n_0$ 分母为 $m_1,m_2$ 。

易得 $m_1=n_0\times k,m_2=m_1+1$

那么看看能不能符合条件即可

首先是最简分数

直接判 $\gcd$ 肯定超时

怎么办呢？

$\dfrac{a}{b}=\dfrac{c}{d}$

化简得 $ad=bc$

只需判断最优解分子$u$与目前判断分母$b$的乘积和最优解分母$d$与目前判断分子$a$的乘积相不相等就行了

再看看是否最接近

$|k-\dfrac{a}{b}|<|k-\dfrac{c}{d}|$

$|kbd-ad|<|kbd-bc|$

只需判断 $|kbd-ad|$ 和 $|kbd-bu|$ 哪个更大即可

如何判断唯一性？

首先，建立一个变量，记录现在一样的有多少个

最后看是否为1

具体实现见代码

最后，上代码！

```cpp
#include<bits/stdc++.h>
using namespace std;
long long s=0,u,d,m,n,m1,m2;
double k;
inline int bj(long long a,long long b,long long c,long long d)
{
	register double s1,s2;
	s1=abs(a*d-k*b*d);
	s2=abs(c*b-k*b*d);
	if(abs(s1-s2)<1e-11)return 0;
	if(s1<s2)return -1;
	return 1;
}
inline void check(long long a,long long b)
{
	if(a>m)a=m;
	if(s==0)
	{
		s=1;
		u=a;
		d=b;
		return;
	}
	if(a*d==b*u)return;
	if(bj(a,b,u,d)==0)s++;
	if(bj(a,b,u,d)==-1)
	{
		s=1;
		u=a;
		d=b;
	}
}
int main()
{
	cin>>m>>n>>k;
	for(int i=1;i<=n;i++)
	{
		m1=i*k;
		m2=m1+1;
		if(true)check(m1,i);
		if(true)check(m2,i);
        else cout<<"IAKIOI";
	}
	if(s==1)cout<<u<<'/'<<d;
	else cout<<"TOO MANY";
	return 0;
}
```

祝洛谷越办越好

---

## 作者：cwocw (赞：4)

这题对于一个数论成员，几乎是个普及+/提高-。

好了，废话不多说，我们直接进入正题。

### 题目分析
我们先自己出个测试点，手算一下。

当 $n=6$，$m=6$，$r=0.6$ 时：

我们列个表格：

| $b \setminus a$ | 1 | 2 | 3 | 4 | 5 | 6 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 1 | 1 | 2 | 3 | 4 | 5 | 6 |
| 2 | $\frac{1}{2}$ | 1 | $\frac{3}{2}$ | $\frac{4}{2}$ | $\frac{5}{2}$ | $\frac{6}{2}$ |
| 3 | $\frac{1}{3}$ | $\frac{2}{3}$ | 1 | $\frac{4}{3}$ | $\frac{5}{3}$ | $\frac{6}{3}$ |
| 4 | $\frac{1}{4}$ | $\frac{2}{4}$ | $\frac{3}{4}$ | 1 | $\frac{5}{4}$ | $\frac{6}{4}$ |
| 5 | $\frac{1}{5}$ | $\frac{2}{5}$ | $\frac{3}{5}$ | $\frac{4}{5}$ | 1 | $\frac{6}{5}$ |
| 6 | $\frac{1}{6}$ | $\frac{2}{6}$ | $\frac{3}{6}$ | $\frac{4}{6}$ | $\frac{5}{6}$ | 1 |

我们找出接近的一两个数，由此可得：

![](https://cdn.luogu.com.cn/upload/image_hosting/rnr6z9x8.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

我们可以发现一行最多两个有用，那因为是求最小，所以我们可以每行都取两个。

由于 $\dfrac{a}{b}\approx r$

所以 $a \approx r \times b$

也就是说在知道分子的情况下，我们可以 $O(1)$ 的求出行上的那两个数。

$a_1 = \lfloor r \times b \rfloor $

$a_2 = \lfloor r \times b \rfloor+1$

那这样只要枚举分母即可。
```cpp
for(int i=1;i<=m;i++){
	long long x1,x2;
	x1=i*t;
	x2=x1+1;
	check(x1,i);
	check(x2,i);
}
```
枚举完分数，我们就要比较哪个分数更接近。

当 $\lvert \dfrac{a}{b}-r \rvert < \lvert \dfrac{c}{d}-r \rvert$

那么 $\lvert a \times d - r\times b\times d \rvert < \lvert c\times b-r\times b\times d \rvert$

```cpp
#define eps 1e-11
int bj(ll a,ll b,ll c,ll d){
	double s1,s2;
	s1=abs(a*d-r*b*d);
	s2=abs(c*b-r*b*d);
	if (abs(s1 - s2)<eps) return 0;
	if(s1<s2) return -1;
	return 1;
}
```
比较前我们要判断这个分数合不合法。

首先是最简分数，如果使用 $\gcd$，会造成超时。

那让我们分类讨论：

1. 不是最简分数也不是当前最接近的分数。
1. 不是最简分数但是当前最接近的分数。

第一种我们可以忽略，因为它不会影响结果。第二种我们需要特殊判断。

$\dfrac{a}{b} = \dfrac{c}{d}$

得，$a\times d= b\times c$

然后是分子、分母分别小于 $n$，$m$。

因为分母是 $1,2,3,4,......,m$ 枚举的，所以不会越界。

那么只要判断分子即可，在此注意，我们一定需要一个数来判断，所以不能写成：
```cpp
if(a>n) return ;//要改成 if(a>n) a=n;
//不信的话试试测试点 n=1 m=100 r=10
```
最后是当第一个的时候，我们要判断，让其直接进入。

```cpp
long long s=0;//判断TOO MANY
void check(ll a,ll b){
	if(a>n) a=n;
	if(s==0){
		s=1,fz=a,fm=b;
		return ;
	}
	if(a*fm==b*fz) return ;
	int x=bj(a,b,fz,fm);
	if(x==0) s++;
	if(x==-1) s=1,fz=a,fm=b;
}
```
### 代码
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
long long n,m,fz,fm;
double r;
#define eps 1e-11
int bj(ll a,ll b,ll c,ll d){
	double s1,s2;
	s1=abs(a*d-r*b*d);
	s2=abs(c*b-r*b*d);
	if (abs(s1 - s2)<eps) return 0;
	if(s1<s2) return -1;
	return 1;
}
long long s=0;
void check(ll a,ll b){
	if(a>n) a=n;
	if(s==0){
		s=1,fz=a,fm=b;
		return ;
	}
	if(a*fm==b*fz) return ;
	int x=bj(a,b,fz,fm);
	if(x==0) s++;
	if(x==-1) s=1,fz=a,fm=b;
}
int main(){
	cin>>n>>m;
	cin>>r;
	for(int i=1;i<=m;i++){
		long long x1,x2;
		x1=i*r;
		x2=x1+1;
		check(x1,i);
		check(x2,i);
	}
	if(s==1) cout<<fz<<"/"<<fm;
	else cout<<"TOO MANY";
    return 0;
}
```
完结撒花！！！

---

## 作者：WeLikeStudying (赞：3)

- 有一个很简单易懂的做法，对于有效位数较多的题目，也可以实现理论复杂度的优化（实际较快），可以达到 $O(\log n)$。
- 似乎用到[这里](https://oi-wiki.org/math/number-theory/stern-brocot/)的一些思想，在此标记。

**[题意](https://www.luogu.com.cn/problem/P1298)**
- 给定一个正实数 $k$，求与它最接近的，分子分母大小不超过一定值 $n$ 的既约分数。

**分析**
- 我们设 $a=0,b=1,c=1,d=0$，令 $1/0$ 表示正无穷，那么初始时 $k$ 一定在 $[a/b,c/d]$ 间。
- 令 $e=a+c,f=b+d$，那么 $a/b<e/f<b/d$ 且 $e/f$ 为既约分数，然后查询目标在 $[a/b,e/f]$，还是 $[e/f,c/d]$ 内，继续递归，[代码](https://www.luogu.com.cn/paste/8uvajnwv)。
- 直接这样做的复杂度为 $O(n)$，当初始值取整数值较大时容易取到上界。
- 可以利用一元一次方程计算接下来还有几次向左走和向右走，由于交替向左向右分子分母的增长都是指数级的，复杂度 $O(\log n)$，可以适应更大的数据范围，[代码](https://www.luogu.com.cn/paste/t9bkrtkx)。

---

## 作者：Naffygo (赞：3)

### 题目大意
给出一个正小数，求值最接近这个小数且分子不超过 $n$ ，分母不超过 $m$ 的最简分数（若为整数 $k$ 则输出 $(k / 1)$ ）。如果分数不唯一，则输出 TOO MANY 。

### 思路
~~我真不知道搜索是怎么来的，~~ 我第一想法是暴力枚举分子分母，但这样显然会 TLE ~~(然而我玄学 MLE)。~~ 那么需要思考别的算法。

后来想了想，发现可以直接从 $1$ 到 $m$ 枚举分母，然后用小数乘以分母再四舍五入即可得到分子。如果分子大于 $n$ 则 $break$ 。然后判断当前值是否比当前最优解优，若是则更新；若与最优解一致则判断这两个分数是否一样，若不一样则输出 TOO MANY。

另外要注意的是如果小数 $×1$ 都比 $n$ 大，则输出 $n / 1$ 。

### 代码

```cpp
#include<bits/stdc++.h>
#define fr(i,a,b) for(register int i = a;i <= b;++i)
using namespace std;

double s;
int n,m,fz,fm;

inline int read(){
	int x = 0,f = 1;char c = getchar();
	while(!isdigit(c)){if(c == '-')f = -1;c = getchar();}
	while(isdigit(c)){x = x * 10 + c - '0';c = getchar();}
	return f * x;
}

inline int gcd(int x,int y){return y ? gcd(y,x % y) : x;}

int main(){
	n = read(),m = read();scanf("%lf",&s);
	if(n == 0){printf("0/1\n");return 0;}
	fz = n;fm = 1;
	fr(i,1,m){
		int ans = (int)(1. * s * i + 0.5);
		if(ans > n)break;
		if(fabs(1. * ans / i - s) < fabs(1. * fz / fm - s)){
			fz = ans;fm = i;
			int g = gcd(fz,fm);
			fz /= g;fm /= g;
		}
		if(fabs(1. * ans / i - s) == fabs(1. * fz / fm - s)){
			int x = ans,y = i;
			int g = gcd(x,y);
			x /= g;y /= g;
			if(x != fz || y != fm){printf("TOO MANY\n");return 0;}
		}
	}
	printf("%d/%d\n",fz,fm);
	return 0;
}
```


---

## 作者：ztntonny (赞：3)

## 这题看到许许多多的题解都没有提到精度问题，特意对于二分的做法进行补充。（即#3测试点）
因为在是否重复的查找的时候，要判断是否与最优解一样优，注意是不可以直接判断是否等于的~~本人亲自尝试无数遍~~，一定要看两数之差是否小于一个特别小的数比如说 ```0.00000000000001```（开太大还是容易挂掉），如果是则被认为是重复的，否则不是。具体的实现下面代码里面解释与别的题解应该可以让大家明白。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int main()
{
	ll a , b , ansup = 1 , ansdown = 1 , i = 1;
	long double c;
	cin >> a >> b >> c;
	for ( ll down = 1; down <= b; down++ )
	{
		ll up1 = down * c <= a ? down * c : a;//二分查找小的那个 
		ll up2 = up1 + 1 < a ? up1 + 1 : a;//二分查找大的那个
		ll up = abs ( double ( up1 ) / double ( down ) - c ) < abs ( double ( up2 ) / double ( down ) - c ) ? up1 : up2;//比较找到更优解 
		ansup = abs ( double ( up ) / double ( down ) - c ) < abs ( double ( ansup ) / double ( ansdown ) - c ) ? up : ansup;//更新全局最优解 
		ansdown = abs ( double ( up ) / double ( down ) - c ) < abs ( double ( ansup ) / double ( ansdown ) - c ) ? down : ansdown;//更新全局最优解 
	}
	for ( ll down = 1; down <= b; down++ )
	{
		ll up1 = down * c <= a ? down * c : a;//同理 
		ll up2 = up1 + 1 <= a ? up1 + 1 : a;
		if ( abs ( double ( up1 ) / double ( down ) + double ( ansup ) / double ( ansdown ) - 2 * c ) <= 0.00000000000001//如果up1和最优解一样优
		&& up1 / __gcd ( up1 , down ) != ansup / __gcd ( ansup , ansdown ) //而且不一样 
		|| abs ( double ( up2 ) / double ( down ) + double ( ansup ) / double ( ansdown ) - 2 * c ) <= 0.00000000000001 //如果up2和最优解一样优
		&& up2 / __gcd ( up2 , down ) != ansup / __gcd ( ansup , ansdown ) )//而且不一样 
		{
			cout << "TOO MANY\n";//那么重复了 
			return 0;
		}
	}
	ansup /= __gcd ( ansup , ansdown );//约分 
	ansdown /= __gcd ( ansup , ansdown );
	cout << ansup << "/" << ansdown << endl;
	return 0;
}

```


---

## 作者：_shy (赞：1)

## 题意
找在数轴上距 $r$ 最近的既约分数，若这个分数唯一，则输出这个分数，否则输出 "TOO MANY"。
## 思路
我们令 $\frac{a}{b} = r$。然后我们假设 $a$ 已知，则易得 $b = \frac{a}{r}$，若通过这种方法得到 $b$ 是小数，则为了让 $\frac{a}{b}$ 更接近 $r$， 我们会取 $\min(\left[ b \right], n)$ 或 $\min(\left[ b \right] + 1,n)$ 作为可能的分母 $fmi$ 和 $fmii$。

于是我们用 $ansfz$ 和 $ansfm$ 记录目前最优的一个分数，用 $mindel$ 记录与 $r$ 最小距离，用 $tot$ 记录达到这个最小距离的不同的分数的个数。

首先，因为 $0$ 不能做分母，故我们将 $ansfz$ 初始化为 $0$，将 $ansfm$ 初始化为 $1$，将 $tot$ 初始化为 $1$，$mindel$ 初始化为 $r$。

然后对 $a$ 从 $1$ 到 $n$ 枚举，每一次比较 $\frac{a}{fmi}$ 和 $\frac{a}{fmii}$ 与 $r$ 之间的距离与 $mindel$ 之间的大小关系：如果相等，则判断这个分数与我们记录的目前的最优分数代表的是否是同一个既约分数（这样通过 if 语句的惰性处理，就可以大大减少求最大公约数的次数），如果不是，则将 $tot$ 加 $1$；如果小于 $mindel$ ，则更新 $mindel$、$ans_fz$、$ansfm$ 与 $tot$。

但是这时候有两个问题，一个是 $n$ 的数据范围是 $1$ 到 $10^7$，我们直接穷举可能会超时；第二个是，我们知道满足题意的分数的分子与分母肯定都在 $1$ 到 $10^7$ 中，但是 $\frac{a}{r}$ 最大可以达到 $10^{17}$，那我们要把 $fmi$ 和 $fmii$ 全换为 long long 类型吗？ 本来就可能超时了，这样用辗转相除法求最大公约数时不可避免的 long long 类型取模，这样更有可能超时了。

但是我们发现如果较小的可能的分母 $\left[b\right]$ 开始大于 $n$ 了，那么就没有必要再对 $a$ 进行枚举了。因为 $\left[b\right]$ 已经大于 $n$ 了，$fmi$ 和 $fmii$ 也只能是比 $\left[b\right]$ 小的 $n$，这时得到的 $\frac{a}{fmi}$ 和 $\frac{a}{fmii}$ 已经比 $\frac{a}{\left[b\right]}$ 距离 $r$ 的距离远了，又根据 $b = \frac{a}{r}$ 可知，$a$ 再大，只会让 $\frac{a}{fmi}$ 和 $\frac{a}{fmii}$ 离 $r$ 更远。于是，问题一就解决了。

那么这时候，我们就可以解决问题二了。因为我们知道 $\left[b\right]$ 大于 $n$ 了就没有必要再枚举了，故我们可以再用一个 long long 类型的变量 $fmij$ 记录 $\left[b\right]$。若 $\left[b\right] > n$ 则在统计完这次后就结束枚举；否则继续。这样就巧（暴）妙（力）的避免了 long long 类型取模。

在解决完这个问题后，最后就是啥时候输出啥的问题了。显然，当 $tot$ 为 $1$ 时，才输出既约分数；否则输出 "TOO MANY"。

于是就可以欢喜地敲代码了 ( )。
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int tot, ans_fz, ans_fm, n, m;
double r, mindel;
int gcd (int a, int b) 
{
	if (a < b) swap (a, b);
	if (b == 0) return a;
	else return gcd (b, a % b);
}
void comparison (int fz, int fm) 
{
	double ret = abs ((1.0 * fz / fm) - r);
	if (ret == mindel && (fz / gcd (fz, fm)) != (ans_fz / gcd (ans_fz, ans_fm)))
		tot ++;
	else if (ret < mindel) 
	{
		mindel = ret;
		tot = 1, ans_fz = fz, ans_fm = fm;
	}
}
int main () 
{
	scanf ("%d %d", &m, &n);
	scanf ("%lf", &r);
	if (r == 0) 
	{
		printf ("0/1");
		return 0;
	}
	mindel = r;
	ans_fz = 0, ans_fm = 1, tot = 1;
	for (int i = 1; i <= m; i++) 
	{
		int fmi = int (1.0 * i / r), fmii = fmi + 1;
		long long fmij = 1.0 * (1ll * i) / r;
		if (fmij > n)
		{
			comparison (i, n);
			break;
		}
		if (fmi <= n) comparison (i, fmi);
		if (fmii <= n) comparison (i, fmii);
	}
	if (tot == 1) 
	{
		int g = gcd (ans_fz, ans_fm);
		ans_fz /= g, ans_fm /= g;
		printf ("%d/%d", ans_fz, ans_fm);
	}
	else if (tot >= 2) printf ("TOO MANY");
	return 0;
} 
```
~~**简化了代码**~~




---

## 作者：251Sec (赞：1)

看了下这个题的题解区。

地铁，老人，手机.jpg。

~~（我怎么一个都看不懂啊啊啊我好菜）~~

所以下面介绍一下我的做法。

## 引入：一道小学奥数题

求最小的 $p, q$ 使得 $\dfrac{30}{7} < \dfrac{p}{q} < \dfrac{34}{7}$。

你不觉得这个假分数看着很难受吗？

处理掉它：$\dfrac{2}{7} < \dfrac{p-4q}{q} < \dfrac{6}{7}$。

然后呢？

聪明的你已经知道了。求倒数！令 $p-4q=r$。

$\dfrac{7}{6} < \dfrac{q}{r} < \dfrac{7}{2}$。

我们再处理掉假分数：

$\dfrac{1}{6} < \dfrac{q-r}{r} < \dfrac{5}{2}$。

我们发现此时小于号两边分别是一个真分数和一个假分数。可以直接令 $q-r=1$，$r=1$。

然后我们再逆推回去，可以得到 $p=9,q=2$。

可以发现，类似的方法可以用于求解 $\dfrac{a}{b} < \dfrac{p}{q} < \dfrac{c}{d}$ 中使 $p, q$ 最小的问题。

Code：

```cpp
void sol(ll a, ll b, ll c, ll d, ll& p, ll& q)
{
    if (a < b && c > d) {
        p = 1;
        q = 1;
    } else {
        sol(d % c, c, b - d / c * a, a, q, p);
        q += d / c * p;
    }
}
```

## 正式开始

可以发现，上面的方法需要频繁取倒数，所以对精度要求比较高，因此我们将输入的小数用分数表示。这里分母取 $10^{14}$。得到分数 $\dfrac{a}{10^{14}}$。

显然，若在距 $r$ 在 $k$ 的范围之内时，存在满足条件的 $p, q$，那么距离在 $k' > k$ 之内时，也存在满足条件的 $p, q$。找到了单调性，我们可以二分所求答案 $\dfrac{p}{q}$ 与 $r$ 的距离 $k$。

分类讨论答案大于和小于 $r$ 的情况，跑两次二分：

当答案小于 $r$， 用上述方法求满足 $\dfrac{a-k-1}{10^{14}} < \dfrac{p}{q} < \dfrac{a + 1}{10^{14}}$ 的最小 $p, q$。而 `check()` 只需判断 `p <= m && q <= n`。

同理，答案大于 $r$ 时，也可以用类似的方法。

这样我们就解决了求答案的问题。那么怎么判断答案是否唯一呢？

这个也很简单，只要枚举过程中有多个数与答案距离相同，答案就是不唯一的。这一点其他题解已经说得很清楚了。注意枚举过程中可能枚举到同一个数，这种情况是不算重复的。

浮点数有精度误差，所以要判断相差值小于一个极小值，就可以认为相等。（这好像是常识吧？）

最终复杂度 $O(\log^2r)$。

![](https://cdn.luogu.com.cn/upload/image_hosting/we7l6rfl.png)

Code:
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef __int128 ll;
typedef long double ld;
class IO {
    template <class T>
    void write(T a)
    {
        if (a > 9)
            write(a / 10);
        putchar(a % 10 + '0');
    }

public:
    template <class T>
    IO operator<<(T a)
    {
        if (a < 0) {
            putchar('-');
            a = -a;
        }
        write(a);
        return *this;
    }
    IO operator<<(char a)
    {
        putchar(a);
        return *this;
    }
    template <class T>
    IO operator>>(T& a)
    {
        int sign = 1;
        a = 0;
        char c = getchar();
        while (c < '0' || c > '9') {
            if (c == '-') {
                sign = -1;
            }
            c = getchar();
        }
        while (c >= '0' && c <= '9') {
            a = (a << 1) + (a << 3) + (c ^ 48);
            c = getchar();
        }
        a *= sign;
        return *this;
    }
} io;
ll m, n;
ld fr;
ll a;
bool flag;
ll ansa, ansb;
ld ansd;
void sol(ll a, ll b, ll c, ll d, ll& p, ll& q)
{
    if (a < b && c > d) {
        p = 1;
        q = 1;
    } else {
        sol(d % c, c, b - d / c * a, a, q, p);
        q += d / c * p;
    }
}
ll gcd(ll a, ll b)
{
    return b == 0 ? a : gcd(b, a % b);
}
ll max(ll a, ll b)
{
    return a > b ? a : b;
}
int main()
{
    io >> m >> n;
    scanf("%Lf", &fr);
    a = fr * 1e14;
    ansa = 0;
    ansb = 1;
    ansd = fr;
    ll l = 1, r = 1e16;
    flag = true;
    while (l <= r) {
        ll mid = (l + r) / 2;
        ll p, q;
        sol(a - 1, 1e14, a + mid + 1, 1e14, p, q);
        if (p <= m && q <= n) {
            r = mid - 1;
            if (fabs(fabs(a / 1e14 - 1.0 * p / q) - ansd) < 1e-16 && (ansa != p || ansb != q)) {
                flag = false;
            }
            else if (fabs(a / 1e14 - 1.0 * p / q) < ansd) {
                ansa = p, ansb = q, ansd = fabs(a / 1e14 - 1.0 * p / q);
                flag = true;
            }
        } 
        else {
            l = mid + 1;
        }
    }
    l = 1, r = 1e16;
    while (l <= r) {
        ll mid = (l + r) / 2;
        ll p, q;
        sol(max(a - mid - 1, 0), 1e14, a + 1, 1e14, p, q);
        if (p <= m && q <= n) {
            r = mid - 1;
            if (fabs(fabs(a / 1e14 - 1.0 * p / q) - ansd) < 1e-16 && (ansa != p || ansb != q)) {
                flag = false;
            }
            else if (fabs(a / 1e14 - 1.0 * p / q) < ansd) {
                ansa = p, ansb = q, ansd = fabs(a / 1e14 - 1.0 * p / q);
                flag = true;
            }
            
        } else {
            l = mid + 1;
        }
    }
    if (flag)
        io << ansa << '/' << ansb;
    else
        puts("TOO MANY");
    return 0;
}
```

## 一个问题

我们一直在说让 $p, q$ 最小。那么，是否最小化 $p$ 等价于最小化 $q$ 呢？

是的。

证明：

若存在满足条件的最简分数 $\dfrac{x}{y}$，使得 $x>p, y < q$。那么 $\dfrac{x}{y} < \dfrac{x}{q} < \dfrac{p}{q}$。显然 $\dfrac{x}{q}$ 更优。

若存在满足条件的最简分数 $\dfrac{x}{y}$，使得 $x<p, y > q$。那么 $\dfrac{x}{y} < \dfrac{p}{y} < \dfrac{p}{q}$。显然 $\dfrac{p}{y}$ 更优。

因此最优解的分子和分母同时最小。

## 双倍经验

[P5179](https://www.luogu.com.cn/problem/P5179)

---

## 作者：Huangjy88 (赞：0)

# P1298题解
一开始想的是二分，但不会写，所以用了一种类似的办法：**分数逼近法**。

约定下述变量皆为正数。

### 引理：若 $\frac{a}{b} < \frac{x}{y}$，则 $\frac{a}{b} < \frac{a+x}{b+y} < \frac{x}{y}$。

证明：
$$\because \frac{a}{b}<\frac{x}{y}$$
$$\therefore ay<bx$$
$$\therefore ay+ab<bx+ab$$
$$\therefore a(b+y)<b(a+x)$$
$$\therefore \frac{a}{b} < \frac{a+x}{b+y}$$
类似的，有
$$\frac{x}{y}>\frac{a+x}{b+y}$$
证毕。

根据这个引理，可以考虑用分子之和比上分母之和去逼近原来的小数，其实这类似于二分，只是划分区间的方式不同。

### 关于判断 `TOO MANY`：

可以每次记录目前的分数与原数的差，若有另外的数使差相等，则让 `flag` 等于 $1$。如果找到了更小的差，则更新差，并让 `flag` 等于 $0$。

### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
double r,k; //题中小数，差
int a,b,x,y;//引理中的字母
int ans1,ans2=1;//答案的分子分母
bool flag;
int main(){
    cin>>n>>m>>r;
    a=y=0,b=x=1,k=r;//初始化
    while(true){
	if(a+x>n || b+y>m) break;//越界
	if(abs(1.0*(a+x)/(b+y)-r)==k) flag=1;//差相等
	if(abs(1.0*(a+x)/(b+y)-r)<k){//更小的差
	    k=fabs(1.0000*(a+x)/(b+y)-r);//更新差
	    ans1=a+x,ans2=b+y,flag=0;//更新答案，flag
	    if(k==0) break;//差为0直接跳出
	}
	if(1.0*(a+x)/(b+y)<r) a+=x,b+=y;
	else x+=a,y+=b;//修改a,b,x,y
    }
    if(flag) printf("TOO MANY");//判断
    else printf("%d/%d",ans1,ans2);
    return 0;
}

```

---

## 作者：Limitless_lmw (赞：0)

标签：二分。建议评级：下位黄。

### 引理

如果对于四个正整数 $a,b,c,d$，有：

$$\dfrac{a}{b}<\dfrac{c}{d}$$

则：

$$\dfrac{a}{b}< \dfrac{a+c}{b+d}< \dfrac{c}{d}$$

### 证明

假设 $\dfrac{a}{b}< \dfrac{a+c}{b+d}$ 成立，则有：

$$\dfrac{a(b+d)}{b(b+d)}<\dfrac{b(a+c)}{b(b+d)}$$

$$ab+ad<ab+bc$$

$$ad<bc$$

$\because \dfrac{a}{b}<\dfrac{c}{d}$

$\therefore$ 假设成立

右半部分同理。

证毕。

---

显然有 $0<k<+ \infty $，不妨使用两个分数来表示左右部分：

$$\dfrac{0}{1}<k<\dfrac{1}{0}$$

然后按照引理，不断取两个分数的分子之和作为新的分子，两个分数的分母之和作为新的分母，判断 $k$ 是大于还是小于即可。

最好时间复杂度 $\Theta(\log_2 m)$，最坏 $\Theta(m)$。

---

## 作者：X_X_M (赞：0)

5-12 upd：删去一种不存在的情况的分类讨论。

~~虽然水但是有蛮多地方需要注意的。~~

提示：本题解重点在查缺补漏上着笔。

### 解题思路：

首先方法就是枚举分母。

然后将分母乘以目标小数得到两个近似分子，

不断进行比较求出来最优解。

### 需要注意的几点：

1.多组解需要特判分子为 $0$ 分母为 $1$ 这个结果。

2.多组解的判断方法：设当前解为 $\frac{a}{b}$，之前的解为 $\frac{p}{q}$。

由于我们是从小往大枚举的（$q>b$），故只有 $\frac{p}{q}$ 可以约分成 $\frac{a}{b}$ 一种情况。

判断是否有 $\frac{q}{a}=\frac{q}{b}$，如果是那么可以约分，如果不是那么就有多组解。

3.记得在找到更优解的情况下将多组解标记恢复初始状态。

4.分子必须小于 $M$。

### 代码部分：

```cpp
#include <bits/stdc++.h>
using namespace std;

long long bx=1000639,by=1000639;
long double best=114514.1919810;       //先辈の护佑
long double c;
int tf=114514;

long double ab(long double x)
{
  return (x>0)?x:-x;
}

void update(int a,int b)            //更新函数 
{
  bx=a;
  by=b;
  long double p=a;
  long double q=b;
  best=ab((p/q)-c);
}

bool ism(int a,int b)                 //是否有多组解 
{
	if(bx==0 || by==0){
		return 0;
	}
  if(a/bx==b/by || a%bx!=0)           //如果可以约分（约数必为整数） 
  {
    return 0;                        //返回没有多组解 
  }
  return 1;                    //否则有多组解 
}

int main()
{
  int m,n;
  cin >> m >> n;
  cin >> c;
  for(long double i=1; i<=n; i++)
  {
    long double p=i*c;
    long double a=floor(p);
    long double b=a+1;
    long double r=(long double)a/(long double)i;     //r,s为分母为i的情况下的近似解 
    long double s=(long double)b/(long double)i;
    if(a<=m)                      //注意分子小于m 
    { 
      if(ab(r-c)<best)               //寻找到了更优解 
      {
        update((int)a,(int)i); 
        tf=false;                  //原本的最优解无论有没有多组解都要重置 
      }
      if(ab(r-c)==best)              //与最优解相等（判断是否互质） 
      {
        if(ism((int)a,(int)i))
        {
          tf=true;                  //标记多解 
        }
      }
    }
    if(b<=m)                         //如法炮制 
    {
      if(ab(s-c)<best)
      {
        update((int)b,(int)i);
        tf=false;
      }
      if(ab(s-c)==best)
      {
        if(ism((int)b,(int)i))
        {
          tf=true;
        }
      }
    }
  }
  if(c==(long double)1/(long double)n-c){           //特判0/1与1/n(为能取到的最小值)是否与c的绝对值相等 
  	cout << "TOO MANY";
  	return 0;
  }
  if(tf==114514)                       //无解（为了保险加上的） 
  {
    cout << m << "/1";                 //取最大值 
    return 0;
  }
  else if(tf)                  //有多组解 
  {
    cout << "TOO MANY";
    return 0;
  }
  cout << bx << "/" << by;           //输出结果 
  return 0;
}

```


---

## 作者：xwh_hh (赞：0)

终于 AC 一道紫题了，发个题解纪念一下。  
现提供一种 $O(m)$ 的思路。   
先来讲一个简单的东西：
$\frac{a}{b}≈c→a≈b\times c$  
所以只要知道分母，分子可以 $O(1)$ 求出。  

Q: 数据怎么处理？  
A: 可以用分数处理，降低误差。  
Q: 约分耗时间怎么办？  
A: 不要约。  
Q: 分子分母在运算时爆 ```long long``` 怎么办？  
A: 用 ```__int128``` 就行。  
Q: 输出怎么处理？  
A: 强转 ```int``` 或 ```long long```。  
Q: 怎么实现？  
A: 分数用结构体，具体上代码（仅供参考，不要抄）：

```cpp
#include<bits/stdc++.h>
using namespace std;
struct num{//分数
	__int128 son,mum;
	num(){}
	num(__int128 a,__int128 b){
		son=a,mum=b;
	}
  //重载运算符，方便后面计算。
  //加减法公分母为两个分母之积、
	num operator+(const num &k)const{
		num ans;
		ans.son=son*k.mum+k.son*mum;
		ans.mum=mum*k.mum;
		return ans;
	}
	num operator-(const num &k)const{
		num ans;
		ans.son=son*k.mum-k.son*mum;
		ans.mum=mum*k.mum;
		return ans;
	}
	num operator*(const num &k)const{
		num ans;
		ans.son=son*k.son;
		ans.mum=mum*k.mum;
		return ans;
	}
  //十字交叉法
	bool operator>(const num &k)const{
		return son*k.mum>mum*k.son;
	}
	bool operator==(const num &k)const{
		return son*k.mum==mum*k.son;
	}
	bool operator<(const num &k)const{
		return son*k.mum<mum*k.son;
	}
}; 
__int128 flr(num h){//向下取整
	return h.son/h.mum;
}
__int128 cel(num h){//向上取整
	return (h.son+h.mum-1)/h.mum;
}
num ans;
num key;
int n,m;
bool flag;
num error=num(1000000007,1);//误差，初始化为正无穷。
void Judge(num k,bool gk){//尝试优化  gk==0说明k偏小，否则k偏大
	if(k==ans) return;
	num a;
	if(gk) a=k-key;
	else a=key-k;
	if(a>error) return;
	if(a==error) flag=1;
	if(a<error){
		flag=0;
		ans=k;
		error=a;
	}
}
num read_a_num(){//读入小数，转为分数
	double tmp;
	cin>>tmp;
	tmp*=10000000000;
	return num(floor(tmp+0.01),10000000000);
}
int main(){
	cin>>n>>m;
	key=read_a_num();
	ans=num(1,1);
	for(int mum=1;mum<=m;mum++){//枚举分母
		__int128 get1=flr(key*num(mum,1)),get2=cel(key*num(mum,1));
		if(get1>n) break;
		if(get2<=n)
			Judge(num(get2,mum),1);
		Judge(num(get1,mum),0);
	}
	if(flag) cout<<"TOO MANY";
	else{
		cout<<(long long)(ans.son)<<"/"<<(long long)(ans.mum);
	}
	return 0;
}
```
这题卡常数，最慢的点跑了 $927ms$。

---

## 作者：喵仔牛奶 (赞：0)

## $\mathcal{P}reface$

这是一篇暴力题解。学习正解勿入。

## $\mathcal{S}olution$

首先可以想到暴力：枚举分子、分母。但是这样 $\mathcal{O}(nm)$，肯定 T。

我们可以只枚举分子。因为确定了分子后，分数值随分母增大是有单调性的，可以二分。

~~然后，然后就没了 qwq~~

时间复杂度 $\mathcal{O}(n\log m)$，时间复杂度 $\mathcal{O}(1)$。

## $\mathcal{C}ode$

二分，[2.50s](https://www.luogu.com.cn/record/89047653)。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, qwq, qaq, cnt; // qwq：当前最优解分子 qaq：当前最优解分母 cnt：当前最优解个数
double k, now = 114514; // k 表示目标，now 表示离目标的最小距离
int main() {
	cin >> n >> m >> k;
	for (int i = 0; i <= n; i ++) { // 注意从 0 开始枚举
		int l = 1, r = m; // 二分 
		while (l <= r) {
			int mid = (l + r) / 2;
			double p = 1.0 * i / mid;
			if (fabs(p - k) < now) qwq = i, qaq = mid, now = fabs(p - k), cnt = 1; // 更新最优解，方案变成 1 种。
			if (fabs(p - k) == now && 1.0 * i / mid != 1.0 * qwq / qaq) cnt ++; // 如果同为最优解且不同，则方案数增加。
			if (p > k) l = mid + 1; // 注意，分数值越大，说明分母越小！
			else r = mid - 1;
		}
	}
	int awa = __gcd(qwq, qaq); // 记得化简 QAQ
	if (cnt < 2) cout << qwq / awa << '/' << qaq / awa << '\n';
	else puts("TOO MANY");// 若不止一种，就是 TOO MANY
	return 0;
}
```


---


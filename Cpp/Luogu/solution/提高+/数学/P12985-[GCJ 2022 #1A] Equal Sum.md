# [GCJ 2022 #1A] Equal Sum

## 题目描述

给定一组互不相同的整数，你需要将它们分成两个非空子集，使得每个元素恰好属于其中一个子集，且两个子集中所有元素的和相等。

匿名提示称上述问题不太可能在多项式时间内解决（或类似结论），因此我们决定修改题目。现在，你可以自行决定其中一半的整数！

这是一个包含三个阶段的交互题：
1. **阶段1**：你选择 $\mathbf{N}$ 个互不相同的整数。
2. **阶段2**：系统会额外提供 $\mathbf{N}$ 个整数，这些整数彼此不同且与你选择的整数不同。
3. **阶段3**：你需要将这 $2\mathbf{N}$ 个整数划分为两个和相等的子集。

所有整数的取值范围为 $1$ 到 $10^9$（含），且保证它们的总和为偶数。

### 交互协议

这是一个交互问题。

初始时，你的程序需读取一个整数 $\mathbf{T}$ 表示测试用例数量，随后处理 $\mathbf{T}$ 个测试用例。

对于每个测试用例：
1. 程序先读取一个整数 $\mathbf{N}$。
2. 程序输出一行包含 $\mathbf{N}$ 个互不相同的整数 $A_1, A_2, \ldots, A_{\mathbf{N}}$（每个整数在 $1$ 到 $10^9$ 范围内）。
3. 程序读取一行包含 $\mathbf{N}$ 个额外整数 $B_1, B_2, \ldots, B_{\mathbf{N}}$。
4. 程序输出一行包含 $1$ 到 $2\mathbf{N}-1$ 个整数（从 $A$ 和 $B$ 的并集中选择），表示第一个子集的元素。未输出的元素自动归入第二个子集。

当前测试用例结束后，立即处理下一个（若存在）。所有测试用例均会被处理，无论最终输出是否正确。

注意：可以证明在本题限制下，存在至少一组 $A_1, A_2, \ldots, A_{\mathbf{N}}$ 使得对任意给定的 $B_1, B_2, \ldots, B_{\mathbf{N}}$，都能将 $2\mathbf{N}$ 个整数划分为和相等的两个子集。

若程序在任何时刻输出格式非法（如整数数量不符、范围越界或重复），裁判将返回 $-1$ 并终止交互。若程序未及时退出，将判为 **Time Limit Exceeded**。内存超限或运行时错误将得到相应判果。

## 说明/提示

**样例解释**

上述样例交互中，程序正确解决了所有测试用例。注意：样例中的 $\mathbf{N}$ 值不符合实际测试集限制，仅用于简化示例。若裁判在第一用例中给出 $\{2, 7, 100\}$，则可能无法找到合法划分。

可使用本地测试工具或平台调试。本地测试需配合交互运行器（详见工具文件注释）。

**限制条件**

**测试集 1（可见判果）**

- $1 \leq \mathbf{T} \leq 100$。
- $\mathbf{N} = 100$。
- $1 \leq \mathbf{B}_i \leq 10^9$（对所有 $i$）。
- $\mathbf{B}_i \neq A_j$（对所有 $i, j$）。
- $\mathbf{B}_i \neq \mathbf{B}_j$（对所有 $i \neq j$）。
- 每个测试用例中，裁判选择的 $\mathbf{B}_i$ 保证 $2\mathbf{N}$ 个整数的和为偶数。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
2
3

10 4 9

3

10 8 12```

### 输出

```


5 1 3

1 10 5

5 2 3

12 8```

# 题解

## 作者：Jorisy (赞：0)

很容易会考虑二进制状物去凑，但是发现好像没有那么容易做。

先考虑如果已经有 $2n$ 个数会怎么做。这是背包，很可惜是一个 npc 问题。

注意到我们可以贪心去尽可能接近答案。具体地，假设两个集合内数的和分别为 $s_1,s_2$，现在加进一个 $a_i$，我们尽可能不让 $|s_1-s_2|$ 变劣。如果 $|s_1+a_i-s_2|>|s_2+a_i-s_1|$，则加入 $s_2$，反之亦然。

那么到最后我们仍然会相差一个 $|s_1-s_2|$。考虑调整。

发现如果我们一开始就在集合内放入 $2$ 的幂次，我们把差按二进制拆分之后调整就是十分容易的了，扫一遍即可。

于是我们初始在集合内加入 $2$ 的幂次即可（剩下的数随便加）。

```cpp
#include<bits/stdc++.h>
#define N 205
#define ll long long
#define mod 
using namespace std;

int n,a[N],fl[N];

void sol()
{
    cin>>n;
    for(int i=1;i<=30;i++) a[i]=1<<i-1;
    for(int i=31;i<=n;i++) a[i]=(1<<29)+i-30;
    for(int i=1;i<=n;i++) cout<<a[i]<<' ';
    cout<<endl;
    for(int i=n+1;i<=n*2;i++) cin>>a[i];
    ll d=0;
    fill(fl+1,fl+n*2+1,0);
    for(int i=n*2;i;i--)
    {
        if(d>=a[i])
        {
            fl[i]=1;
            d-=a[i];
            continue;
        }
        fl[i]=0;
        d=a[i]-d;
        for(int j=i+1;j<=n*2;j++) fl[j]=!fl[j];
    }
    for(int i=1;i<=n*2;i++)
    {
        if(fl[i]) cout<<a[i]<<' ';
    }
    cout<<endl;
}

int main()
{
    //freopen(".in","r",stdin);
    //freopen(".out","w",stdout);
    int t;
    cin>>t;
    while(t--) sol();
    return 0;
}
```

---


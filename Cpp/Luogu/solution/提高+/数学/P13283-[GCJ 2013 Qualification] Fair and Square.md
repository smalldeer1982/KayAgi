# [GCJ 2013 Qualification] Fair and Square

## 题目描述

Little John 喜欢回文数，并认为它们是**公平的**（fair，意思就是“美好”）。一个 $palindrome$（回文数）是指这样一个整数：它正着读和反着读都一样——比如 $6$、$11$ 和 $121$ 都是回文数，而 $10$、$12$、$223$ 和 $2244$ 则不是（即使 $010 = 10$，我们在判断回文数时不考虑前导零）。

最近他对平方数也产生了兴趣，并给出了 $fair$ $and$ $square$ 数的定义——即同时满足以下两个条件的数：
- 它是一个回文数；
- 它本身也是某个回文数的平方。

例如，$1$、$9$ 和 $121$ 都是 fair and square 数（它们分别是 $1$、$3$ 和 $11$ 的平方，且自身也都是回文数），而 $16$、$22$ 和 $676$ 都不是 fair and square 数：$16$ 不是回文数，$22$ 不是平方数，$676$ 虽然既是回文数又是平方数，但它是 $26$ 的平方，而 $26$ 不是回文数。

现在他想寻找更大的 fair and square 数。你的任务是：给定 Little John 要查找的区间，告诉他该区间内有多少个 fair and square 数，这样他就知道自己是否已经找到全部了。

通常，Google Code Jam 的题目会有 1 个 Small 输入和 1 个 Large 输入。本题有 1 个 Small 输入和 2 个 Large 输入。当你通过 Small 输入后，就可以下载任意一个 Large 输入。像往常一样，你可以多次尝试 Small 输入（每次错误会有时间惩罚），而每个 Large 输入只有一次提交机会。


## 说明/提示

**限制条件**

**小数据集（10 分，测试集 1 - 可见）**

- $1 \leq T \leq 100$
- $1 \leq A \leq B \leq 1000$

**第一个大数据集（35 分，测试集 2 - 隐藏）**

- $1 \leq T \leq 10000$
- $1 \leq A \leq B \leq 10^{14}$

**第二个大数据集（55 分，测试集 3 - 隐藏）**

- $1 \leq T \leq 1000$
- $1 \leq A \leq B \leq 10^{100}$

翻译由 ChatGPT-4.1 完成。

## 样例 #1

### 输入

```
3
1 4
10 120
100 1000```

### 输出

```
Case #1: 2
Case #2: 0
Case #3: 2```

# 题解

## 作者：xiazha (赞：1)

有点意思。

设一个本身与其平方都是回文数的数字为 $m$。

显然需要挖掘性质，充要条件是 $m$ 的平方不进位。

然后设 $m=\sum_{i=0}^{p-1} 10^i\times a_i$，这里 $p$ 为数位个数，$0\le a_i\le9$。

则 $m^2 = \sum_{i=0}^{p-1} \sum_{j=0}^{p-1} 10^{i+j} a_i a_j$。

考虑第 $\lfloor\frac{p+1}{2}\rfloor$ 位，由于 $m$ 是回文数，故该位置上的数为 $a_0^2+a_1^2+\cdots+a_{p-1}^2$，且该位是 $m^2$ 所有数位的最大值，由于其不能进位，可得 $a_0^2+a_1^2+\cdots+a_{p-1}^2\le9$，既 $m$ 数位平方和小于 $9$，由此也可以得到 $m$ 只能由 $0$，$1$，$2$ 组成，注意这里有一个特例：$m=3$。

有了这个性质之后我写了一份打表代码，发现所有满足是回文数且数位平方和小于等于 $9$ 的数都满足题目条件，以下是打表代码中数位个数为 $7$ 的所有 $m$ 与 $m^2$。


```
1000001 1000002000001
1001001 1002003002001
1002001 1004006004001
1010101 1020304030201
1011101 1022325232201
1012101 1024348434201
1100011 1210024200121
1101011 1212225222121
1102011 1214428244121
1110111 1232346432321
1111111 1234567654321
2000002 4000008000004
2001002 4004009004004
```

下面考虑题目给我们的区间是平方后的数，这时你发现 $A\le B\le 10^{100}$，没错，**高精度开根**（当然你可以使用牛迭）。

接下来考虑数位 $dp$，为了满足回文的性质，我们只计算一半边的方案数，所以需要分数位个数的奇偶讨论，同时要特判数位个数是 $1$ 的情况。

由于高精度开根太抽象了，代码冲到了 $4KB$，所以这里只贴数位 $dp$ 的部分，注意细节较多，需全面考虑。


```
int work(bigint f)
{
	int ans=0,cnt=f.size;
	for(int i=1;i<=cnt;i++) h[i]=f.d[cnt-i+1];
	if(cnt==1)
	{
		if(h[1]>=3) ans++;
		if(h[1]>=2) ans++;
		if(h[1]>=1) ans++;
	}
	else ans+=3;
	for(int i=2;i<=cnt;i++)
	{
		memset(dp,0,sizeof(dp));
		m=i/2;
		dp[0][0][(cnt==i)]=1;
		for(int j=1;j<=m;j++)
			for(int k=1;k<=4;k++)
				if(cnt==i)
				{
					if(h[j]*h[j]<=k) dp[j][k][1]+=dp[j-1][k-h[j]*h[j]][1];
					for(int now=0;now*now<=k;now++)
						if(now>=h[j]) dp[j][k][0]+=dp[j-1][k-now*now][0];
						else dp[j][k][0]+=dp[j-1][k-now*now][1]+dp[j-1][k-now*now][0];
				}
				else
				{
					for(int now=0;now*now<=k;now++) dp[j][k][0]+=dp[j-1][k-now*now][0];
				}
		if(i&1)
		{
			ans+=(dp[m][1][0]+dp[m][2][0])*3;
			ans+=(dp[m][3][0]+dp[m][4][0])*2;
			//if(i==cnt) cout<<dp[m][1][0]<<" "<<dp[m][2][0]<<" "<<dp[m][3][0]<<" "<<dp[m][4][0]<<"\n";
		}
		else
		{
			ans+=dp[m][1][0]+dp[m][2][0]+dp[m][3][0]+dp[m][4][0];
			//if(i==cnt-1) cout<<dp[m][1][0]<<" "<<dp[m][2][0]<<" "<<dp[m][3][0]<<" "<<dp[m][4][0]<<"\n";
		}
	}
	if(cnt>1)
	{
		bigint br=f;int sum=0;
		for(int i=1;i<=cnt/2;i++) br.d[i]=br.d[cnt-i+1];
		//print(br);print(f);
		if(cnt%2==0)
		{
			for(int i=1;i<=cnt;i++) sum+=br.d[i]*br.d[i];
			if(br<=f&&sum<=9) ans++;
		}
		else
		{
			for(int kk=0;kk<=2;kk++)
			{
				br.d[(cnt+1)/2]=kk;
				sum=0;
				for(int i=1;i<=cnt;i++) sum+=br.d[i]*br.d[i];
				if(br<=f&&sum<=9) ans++;
			}
		}
	}
	return ans;
}
```

---


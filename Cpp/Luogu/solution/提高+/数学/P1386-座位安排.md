# 座位安排

## 题目描述

给 $n$ 个人安排座位，先给每个人一个 $1\sim n$ 的编号，设第i个人的编号为 $a_i$（不同人的编号可以相同），接着从第一个人开始，大家依次入座。

第 $i$ 个人来了以后尝试坐到 $a_i$，如果 $a_i$ 被占据了，就尝试 $a_{i+1}$，$a_{i+1}$ 也被占据了的话就尝试 $a_{i+2}$，……，如果一直尝试到第 $n$ 个都不行，该安排方案就不合法。

然而有 $m$ 个人的编号已经确定（他们或许贿赂了你的上司…)，你只能安排剩下的人的编号。求有多少种合法的安排方案。由于答案可能很大，只需输出其除以 $M$ 后的余数即可。



## 说明/提示

对于 $30\%$ 的数据 $1\le n\le 10$，$1\le M\le 32767$；

对于 $100\%$ 的数据 $1≤T≤10$，$1≤n≤300$，$0≤m≤n$，$2≤M≤10^9$，$1≤p_i,q_i≤n$ 且保证 $p_i$ 互不相同。


## 样例 #1

### 输入

```
2
4 3 10
1 2 2 1 3 1
10 3 8882
7 9 2 9 5 10
```

### 输出

```
YES 4
NO
```

# 题解

## 作者：KAMIYA_KINA (赞：6)

## Tag

动态规划，计数，组合数学。

## Description

求一个长度为 $n$ 的序列 $\{a_n\}$，要求大于 $x$ 的 $a_i$ 的数量不能超过 $n-x+1$  个，并且有一些 $a_i$ 是给定的，求有多少个序列满足这个条件。

给定的 $a_i$ 数量为 $m$，并且每一次测试模数为给定的 $M$。

$\texttt{data range:}1\leq n \leq 300,0 \leq m \leq n, 2\leq M \leq 10^9$.

## Solution

我的描述已经解释了一定的题目，根据这个条件我们很容易就可以想出设 $s_i$ 为大于等于 $i$ 中有多少个编号，然后这个 $s_i$ 显然是不能大于 $n-i+1$ 的。

根据这个限制，我们可以得到一个很朴素的转移方程：
$$
f_{i,j} =\sum_k\dbinom{j}{k}f_{i+1,j-k}
$$
解释一下，这里的  $f_{i,j}$ 表示的是第 $i$ 个位置，$j$ 表示这个位置后面有 $j$ 个人。

那么我们对于上一个状态，无非就是将上一个状态中有 $j-k$ 个人的情况，然后从我要选的 $j$ 个人里面抽取 $k$ 个人出来站到第 $i$ 个位置上，那么方案就很显然了。

对于限制的情况，我们只用考虑第 $i$ 位之后已经确定的位置，那么就是说我们可以站在第 $i$ 个位置的人就会减少，所以 $j$ 的上界就是 $n-s_i-i+1$。

然后由于模数一直在变化，所以要用递推式解出组合数。
$$
\dbinom nm=\dbinom {n-1}m+\dbinom {n-1}{m-1}
$$
所以最后的答案就是 $f_{1,n-m}$。

做完了，时间复杂度 $O(n^3)$，可以通过本题。

---

## 作者：wyd_forever (赞：4)

写在前头：刚考完这题（~~被秒~~）就来发题解了  
  
**另**:[双倍经验](https://www.luogu.org/problem/P2523)
### $first$  
考试$DP$爆炸了，听$wh$大佬一波讲解之后醍醐灌顶，来$luogu$切了这题。先$orz$一波……  
  
### $second$  
先明确一点，和人没有关系。  
  
额，好像不太对。但意思差不多，人会被抽象成编号，我们关心的只是编号，和人没有关系。  
  
再根据数据范围就可以确定状态应该是有两维。既然与人没有关系了，那么第一维自然变成了编号，至于第二维，$yy$一波也不难知道是编号小于等于$i$的人数（额，又扯到人上了，其实前面指的是与第几个人（即人的种类）无关，人数还是要的，不然不好转移）。  
  
确定状态后就是确定转移方程了。  
  
### $third$  
首先介绍两个要用的数组$sum,cnt$，其中$cnt_i$指的是编号被强制定为$i$的人的数量，$sum_i$则是记录$\sum_j^i cnt_j+n-m$的值，看到这里，应该有同学瞬间反应过来我要干什么了。别急，一步步看。  
  
大家其实发现了，$sum_i$记录的不单单只是一个类似$cnt$前缀和的东西，更重要的作用是记录当前有多少人的编号能够小于等于$i$.  
  
同时这也是在$\sum cnt$的基础上加上一个$n-m$的原因，加上的正是没有确定编号的人，让$sum$的作用能够转移方程且能判合法性。  
  
易知：当前方案不合法时当且仅当$\exists sum_i<i$，因为若编号能够小于等于$i$的人数少于$i$个，前面的位置必将有空位，因为是$n$个人对应$n$个位置，故肯定有人没地方坐，故不合法。  
  
### $forth$
知道了$sum$的真正意义，那么转移方程也好推了。  
  
先把方程给出来（$f_{i,j}$表示的是当前在编号$i$（之后可能有不合法的情况都不管，先搞当前的$i$），编号小于等于$i$的人的数量有$j$的方案数）:  
$$f_{i,j}=\sum_{k=cnt_i}^{j-i+1}f_{i-1,j-k}* C_{sum_{i-1}-j+k}^{k-cnt_i}$$  
  
一步步地看这个式子。  
  
首先$k$是枚举编号为$i$的人的数量，很明显，下限为$cnt_i$.那么在之前的$i-1$个编号中肯定搞定了剩下的$j-k$个人，于是有了$f_{i-1,j-k}$，但除了固定的$cnt_i$个人编号必须为$i$之外，还必须找$k-cnt_i$个自由人使得编号为$i$的总人数为$k$，而这$k-cnt_i$个人得由我们在编号$i-1$及之前的人中（即$sum_{i-1}$）且还未安排的人数中（即没被搞定，被搞定的人已经得出是$j-k$）选出，即在$sum_{i-1}-(j-k)=sum_{i-1}-j+k$个人中选出$k-cnt_i$个人，组合数得到。  
  
但还有一个费解的地方是$j$和$k$的循环范围，这个稍微想一下就可以知道了。在式子$f_{i,j}$中，很明显成立的条件是$j>=i$，只有当小于等于当前编号$i$的人数大于等于$i$才会使前面没有空缺，也才会满足题意，用这个不等式推一下就可以看出$j$的下限与$k$的上限了。  
  
### $fifth$  
另外还有$j$的上限，很明显我们使编号小于等于$i$的人数最多只有$sum_i$个，上限即为$sum_i$.  
  
$i$直接从$1-n$跑一遍即可.  
  
目标：$\exists sum_i<i\lor f_{n,n}$  
  
### $sixth$  
最后附上代码，（别忘了这题是个双倍经验:-)）:  
```
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
#define in read()
#define fur(i,a,b) for(int i=a;i<=b;++i)
#define fdr(i,a,b) for(int i=a;i>=b;--i)
#define int long long
#define jinitaimei signed
inline int read()
{
	int x=0;
	char ch=getchar();
	for(;!isalnum(ch);ch=getchar());
	for(;isalnum(ch);ch=getchar()) x=x*10+ch-'0';
	return x;
}
const int xx=3e2+10;
int f[xx][xx],sum[xx],cnt[xx],c[xx][xx];
inline void sol()
{
	memset(f,0,sizeof(f));
	memset(sum,0,sizeof(sum));
	memset(cnt,0,sizeof(cnt));
	int n=in,m=in,mod=in;
	fur(i,0,n)
	{
		c[0][i]=1;
		fur(j,1,i) c[j][i]=(c[j-1][i-1]+c[j][i-1])%mod;
	}
	fur(i,1,m)
	{
		int x=in;x=in;
		++cnt[x];
	}
	sum[0]=n-m;
	fur(i,1,n)
	{
		sum[i]=sum[i-1]+cnt[i];
		if(sum[i]<i)
		{
			puts("NO");
			return;
		}
	}
	f[0][0]=1;
	fur(i,1,n) fur(j,i,sum[i]) fur(k,cnt[i],j-i+1) (f[i][j]+=f[i-1][j-k]*c[k-cnt[i]][sum[i-1]-j+k])%=mod;
	printf("YES %lld\n",f[n][n]);
}
jinitaimei main()
{
	int t=in;
	while(t--) sol();
	return 0;
}
```


---

## 作者：Supor__Shoep (赞：3)

这是一道简单的带有组合数学的动态规划。

如果要考虑一个方案如果合法，那么对于任何一个编号 $i$，都可以保证编号小于等于 $i$ 的人数大于等于 $i$，不满足的就一定是错误的。

然后我们统计一下固定的编号，非固定的编号我们可以视为 $0$，因为实际上这些人是没有任何区别的，而且还可以随意编号，就好玩。

再然后，我们统计一下前缀和，只要发现不合法了就直接跳循环。

接着就是好玩的动态规划了。我们用 $dp[i][j]$ 表示有 $j$ 个人的编号不大于 $i$ 的总情况个数，显然我们可以得到 $i<=j$，所以我们可以考虑如何从 $i-1$ 转移到 $i$。于是乎，我们又可以枚举一波编号恰好为 $i$ 的人数 $k$。

用 $loc[i]$ 表示已经确定有 $loc[i]$ 个人编号是 $i$，用 $sum[i]$ 表示 $loc[i]$ 的前缀和，那么就有了：

$$dp[i][j]=\sum dp[i-1][j-k]\times C[n-m+sum[i]-j+k-loc[i]][k-loc[i]]$$

其中有：

$$k∈[loc[i], j-i+1]$$

代码如下：
```
#include<bits/stdc++.h>
using namespace std;
int C[305][305],loc[305],sum[305];
long long dp[305][305];
int main(void)
{
    int T;
    cin>>T;
    while(T--)
    {
        int n,m,mod;
        cin>>n>>m>>mod;
        for(int i=0;i<300;i++)
        {
            C[i][0]=1;
            for(int j=1;j<=i;j++)
            {
                C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;
            }
        }
        memset(loc,0,sizeof(loc));
        for(int i=1;i<=m;i++)
        {
            int x;
            scanf("%*d%d",&x);
            loc[x]++;
        }
        bool flag=0;
        for(int i=1;i<=n;i++)
        {
            sum[i]=sum[i-1]+loc[i];
            if(m-sum[i]>n-i)
            {
                cout<<"NO"<<endl;
                flag=1;
                break;
            }
        }
        if(flag)    continue;
        memset(dp,0,sizeof(dp));
        dp[0][0]=1;
        for(int i=1;i<=n;i++)
        {
            for(int j=i;j<=n-m+sum[i];j++)
            {
                for(int k=loc[i];k<=j-i+1;k++)
                {
                    dp[i][j]=(dp[i][j]+dp[i-1][j-k]*C[n-m+sum[i]-j+k-loc[i]][k-loc[i]])%mod;
                }
            }
        }
        cout<<"YES"<<" "<<dp[n][n]<<endl;
    }
    return 0;
}
```

哎哎哎别走，我换个通俗易懂的讲法说一说公式。

依旧是上面的思路，用 $dp[i][j]$ 表示有 $j$ 个人的编号不大于 $i$ 的总情况个数。

这里我们换一个方向，用 $loc[i]$ 表示有 $loc[i]$ 人编号为 $i$，再用 $s[i]$ 表示编号小于等于 $i$ 的最多人数。

优化一下公式。现在有 $s[i]$ 个人，$loc[i]$ 个被确定了必须选择，$j-k$ 个人已经选完，在剩下的人中选出 $k-loc[i]$ 个人使其编号为 $i$。有：

$$dp[i][j]=\sum_{k=loc[i]}^{j-i+1} dp[i-1][j-k]\times C^{k-loc[i]}_{s[i]-loc[i]-j+k}$$

是不是比上个公式要好看许多？

---

## 作者：Hongse_Fox (赞：2)

[题目链接](https://www.luogu.com.cn/problem/P1386)
# 一.大体思路
看到我们的样例二

不难发现如果有一个编号$i$,如果编号$>=$它的数比它后面的位置要多的话

那么显然就坐不下了

转换成数学语言就是

对于任意$i$都要满足$>=i$的个数$x<=n-i+1$

既然如此我们就可以根据这个做**计数dp**

# 二.实现方法
## 0.注意事项
在题目中有两种人 第一种是规定了位置的固定人 第二种是自由的人

对于固定人 位置已经确定 不存在顺序考虑的情况

但是对于自由人 有编号的顺序 因此转移要考虑顺序

## 1.状态定义
既然我们已经得到了 对于任意$i$都要满足$>=i$的数的个数$x<=n-i+1$ 的结论

那么我们就可以定义$f_{i,j}$表示编号$>=j$的人数有$i$人 

不难发现$f_{i,j}$与$i$后面的固定人有着紧密联系

所以我们可以令$num[i]$为编号为$i$的固定人数量

$hzh[i]$为$num[i]$的后缀和

## 2.状态转移方程
我们考虑$f_{i,j}$可以怎么得到

上一个状态显然可得是$f_{i+1,j-now}$($now$为编号为$i$的数量)

在这编号为$i$的这群人中 有$num[i]$个固定人

即有$now-num[i]$个自由人

而之前使用的固定人有$sum[i+1]$个

假设$tot$为总自由人数

那么剩下的自由人为$tot-(j-now-sum[i+1])$

我们在剩余的$tot-(j-now-sum[i+1])$个自由人中选出$now-num[i]$个

而且考虑顺序

所以$f_{i,j}+=f_{i+1,j-now}\times C_{tot-j+now+sum[i+1]}^{now-num[i]}$

## 3.边界
不难发现作为当前人数的$now$至少要有固定人数，最多不可以超过$j-$前面的固定人数合

即$num[i]<=now<=j-sum[i+1]$

而同样$j$至少要有固定人数，而且不能超过我们的结论$n-i+1$

即$sum[i]<=j<=n-i+1$

# 三.代码
```cpp
#include<cstdio>
#include<cctype>
#include<cstring>
inline int R(){
    int r=0;char c=getchar();
    while(!isdigit(c)) c=getchar();
    while(isdigit(c)) r=(r<<1)+(r<<3)+(c^48),c=getchar();
    return r;
}
int n,m,f[305][305],num[305],hzh[305],t,mod,flag,tot,c[305][305];//tot:自由人 
//num[i]:必须选i的人数 hzh[i]:num的后缀和 f[i][j]:编号>=j的人数有i人 
int main(){
    t=R();
    for(register int qwq=1;qwq<=t;qwq++){
        memset(num,0,sizeof(num));
        memset(hzh,0,sizeof(hzh));
        memset(f,0,sizeof(f));
        n=R();m=R();mod=R();flag=0;
        for(register int i=1;i<=m;i++){
            int p=R(),q=R();
            num[q]++;
        }
        for(register int i=0;i<=n;i++){
            c[i][0]=1;//显然
            for(register int j=1;j<=n;j++){
                c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;
            } 
        }
        for(register int i=n;i>=1;i--) hzh[i]=hzh[i+1]+num[i];
        for(register int i=1;i<=n;i++){
            if(hzh[i]>n-i+1){
                flag=1;
                break;
            }
        }
        if(flag){
            printf("NO\n");
            continue;
        }
        tot=n-hzh[1];//自由人个数=总个数-非自由人个数 
        f[n+1][0]=1;
        for(register int i=n;i>=1;i--){//枚举第几号 
            for(register int j=hzh[i];j<=n-i+1;j++){//枚举>=i的人数 固定的人是基础 最多不能超过n-i+1 
                for(register int now=num[i];now<=j-hzh[i+1];now++){//枚举当前人数 之前的固定也要记住 
                int k=j-now;//之前人数 其中有hzh[i+1]个人是固定的 即用了k-hzh[i+1]个自由人 
                    f[i][j]=(1ull*f[i+1][k]*c[tot-k+hzh[i+1]][now-num[i]]+f[i][j])%mod;
                    //从剩余自由人里面选要用到的自由人，用c 
                }
            }
        }
        printf("YES %d\n",f[1][n]);
    }
}
```
# 四.后记
对于计数dp的问题 找好状态转移方程

如果题目中暗含了顺序 注意要用组合数的知识做到方案数不重不漏

Finally,谢谢大家

[更好的阅读体验](https://www.luogu.com.cn/blog/HongseFox/solution-p1386)

---

## 作者：aaaaaaaawsl (赞：1)

DP。

考虑什么时候一个人的编号是不合法的，如果他的编号为 $x$，那么除了他，$x$ 到 $n$ 的编号都至少出现了一次。设 $cnt_x$ 为大于等于 $x$ 的编号有几个，则如果存在一个 $x$ 不合法，那么 $cnt_x > n - x + 1$。也就是有 $cnt_x$ 个数要放在 $[x,n]$ 区间里，如果 $cnt_x > n - x + 1$，那么一定有放不下的。

那如果对于任意 $x$，$cnt_x \le n - x + 1$ 都成立能说明一定合法吗？答案是肯定的，还是考虑 $cnt_x$ 个数要放在 $[x,n]$ 区间里，在 $x$ 还没被放下的时候， $cnt_x < n - x + 1$，所以 $x$ 一定能放下。

于是一个方案是否合法只跟各自的数是多少有关而和顺序无关。

预处理初始确定的 $m$ 个人的编号，记后缀和，然后判断时候非法即可。

下面考虑怎么求方案数，设 $f_{i,j}$ 为当前要给人分配编号 $i$，**未确定**的人中有 $j$ 个人的编号大于等于 $i$，此时的方案数。于是 $j$ 的枚举范围为 $[0,n - i + 1 - sum_i]$，$sum_i$ 表示确定的人中有 $sum_j$ 个人的编号大于等于 $i$。再枚举一维 $k$ 表示分配 $k$ 个 $i$。于是状态转移方程为 

$$f_{i,j} = \sum_{k = 0}^{j}f_{i+1, j - k} \times C_{j}^{k}$$

乘 $C_{j}^{k}$ 的原因是不确定是 $j$ 中的哪 $k$ 个的编号是 $i$。

由于本题模数不是质数，所以不能预处理阶乘逆元，直接 $n^2$ 用 $C_n^m = C_{n - 1}^{m - 1} + C_{n - 1}^{m}$ 递推即可。不懂的自行百度递推求组合数。

总时间复杂度 $O(Tn^3)$

-------

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define int long long

using namespace std;

inline int read(){
	register int x = 0, f = 1; register char ch = getchar();
	for(; ch > '9' || ch < '0'; ch = getchar()) if(ch == '-') f = -1;
	for(; ch >= '0' && ch <= '9'; ch = getchar()) x = (x << 1) + (x << 3) + (ch ^ '0');
	return x * f;
}

const int N = 3e2 + 10;

int T;
int n, m, Mod;
int f[N][N], sum[N];
int C[N][N];

signed main(){
	T = read();
	while(T --){
		n = read(); m = read(); Mod = read();
		memset(sum, 0, sizeof sum); memset(f, 0, sizeof f);
		for(int i = 1; i <= m; ++ i) read(), sum[read()] ++;
		for(int i = n; i >= 1; -- i){
			sum[i] += sum[i + 1];
			if(sum[i] > n - i + 1){
				puts("NO");
				goto Exit;
			}
		}
		
		for(int i = 0; i <= n; ++ i){
			C[i][0] = 1;
			for(int j = 1; j <= i; ++ j){
				C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % Mod;
			}
		}
		
		f[n + 1][0] = 1;
		for(int i = n; i >= 1; -- i){
			for(int j = 0; j <= n - i + 1 - sum[i]; ++ j){
				for(int k = 0; k <= j; ++ k){
					f[i][j] = (f[i][j] + f[i + 1][j - k] * C[j][k] % Mod) % Mod;
				}
			}
		}
		
		printf("YES %lld\n", f[1][n - m]);
		Exit:;
	}
	return 0;
}
```



---

## 作者：CodingFrog1 (赞：0)

## 思路
依题 ```dp```。

组合数学前面题解的 ```dl``` 已讲得清晰了，在这里不过多赘述。乘法原理。小学知识。

奉天承运,皇帝诏曰：

钦定 $hzh$ 数组，$hzh_i=后面“预定座位”的人数$。故坐不下时，即当 $hzh_i > n-i+1$ 时，应当~~挤挤凑合着坐~~判无解。

钦定 $C$ 矩阵，$C_j^i$ 表示从 $\max(j,i)$ 个数中选 $\min(j,i)$ 个数的方法和。易转移如下：$C_j^i=(C^{i-1}_{j-1}+C^{i-1}_j)$。

钦定 $dp$ 矩阵，$dp_j^i$ 表示在编号大于等于 $i$ 的人中确定 $j$ 人之座位的方法总和数。易转移如下：$dp_j^i=\sum_{k=0}^j dp_{j-k}^{i-1}\times C_k^j$。

敬告众卿：勿忘取 %。

## 码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
void dui(int x)
{
	cout<<"YES"<<" "<<x<<endl;
}
void cuo()
{
	cout<<"NO"<<endl;
}
int hzh[305],c[305][305],dp[305][305];
signed main()
{
	int  t;
	cin>>t;
	while(t--)
	{
		int n,m,mod;
		cin>>n>>m>>mod;
		bool flag=0;
		memset(hzh,0,sizeof(hzh));
		memset(dp,0,sizeof(dp));
		for(int i=0;i<=300;i++)
		{
			c[i][0]=c[i][i]=1;
			for(int j=1;j<=i;j++)	c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;
			
		}
		for(int i=1;i<=m;i++)
		{
			int x;
			cin>>x;
			int y;
			cin>>y;
			hzh[y]++;
		}
		for(int i=n;i>=1;i--)	hzh[i]+=hzh[i+1];
		for(int i=1;i<=n;i++)
		{
			if(hzh[i]>n-i+1)
			{
				cuo();
				flag=1;
				break;
			}
		}
		if(flag==1)	continue;
		for(int i=0;i<=n;i++)
		{
			if(i)	dp[n+1][i]=0;
			else	dp[n+1][i]=1;
		}
		for(int i=n;i>=1;i--)
		{
			for(int j=0;j<=n-i+1-hzh[i]&&j>=0;j++)
			{
				for(int k=0;k<=j;k++) 
				{
					dp[i][j]=(dp[i][j]+c[j][k]*dp[i+1][j-k])%mod;
				}
			}
		}
		dui(dp[1][n-m]);
	}
}
```

---


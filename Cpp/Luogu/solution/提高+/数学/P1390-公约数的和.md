# 公约数的和

## 题目背景

有一天，TIBBAR 和 LXL 比赛谁先算出 $1 \sim n$ 这 $n$ 个数中每任意两个不同的数的最大公约数的和。LXL 还在敲一个复杂而冗长的程序，争取能在 $100s$ 内出解。而 TIBBAR 则直接想 $1s$ 秒过而获得完胜，请你帮他完成这个任务。


## 题目描述

给定 $n$，求
$$\sum_{i = 1}^n \sum_{j = i + 1}^n \gcd(i, j)$$

其中 $\gcd(i, j)$ 表示 $i$ 和 $j$ 的最大公约数。

## 说明/提示

#### 数据规模与约定

- 对于 $40\%$ 的数据，保证 $n \leq 2 \times 10^3$。
- 对于 $100\%$ 的数据，保证 $2 \leq n \leq 2 \times 10^6$。

## 样例 #1

### 输入

```
10
```

### 输出

```
67```

# 题解

## 作者：Kelin (赞：118)

其实这题和P2389差不多还简单一些

这里介绍一种nlogn的做法

设f[d]=∑∑gcd(i,j)=d

F[d]=∑∑d|gcd(i,j)

不难看出F[d]=n/d\*(n/d)

那么f[d]=F[d]-∑f[kd]

所以o(nlogn)扫一下就好了（主要是代码特别短）

然后ans=(∑f[d]-n\*(n+1)/2)/2 减去gcd(d,d)=d的和gcd(i,j)=gcd(j,i)重复的

```cpp
#include<cstdio>
#define re register int
long long n,ans,f[2000010];
int main(){
    scanf("%lld",&n);
    for(re i=n;i;--i){
        f[i]=n/i*(n/i);
        for(re j=i<<1;j<=n;j+=i)f[i]-=f[j];
        ans+=f[i]*i;
    }
    printf("%lld",(ans-n*(n+1)/2)/2);
return 0;
}
```

---

## 作者：蒟蒻溴化氢 (赞：58)

一个莫比乌斯反演的入门题却没有入门的讲解...

莫比乌斯函数

首先介绍一个东西叫做狄利克雷卷积 (后面会用到)

(如果知道下面的结论就不用看了)

我们新定义一个符号(定义新运算) * 

$h,f,g$ 都是函数名称

定义 $h=f*g$  :

$$
h=f*g=\sum_{d|n}f(d)g(\frac{n}{d})=\sum_{d|n}f(\frac{n}d)g(d)h=f*g=\sum_{d|n}f(d)g(\frac{n}{d})=\sum_{d|n}f(\frac{n}d)g(d)
$$

再定义几个函数 

1. $\sum$ 函数 (这里只是一个函数名字而已)

   有 对于任意x 有$\sum$ (x)=1

2.  $1(x)$  对于任意x 有$1(x)$ =$x$

3. 单位元 e 

   有 e(n)=[n=1] (这个式子的意思是当n=1时 值为1 否则为0)

这个单位元有一个性质 :$f*e=e$

乘法有逆元 狄利克雷卷积也有逆元

逆元: 如果对于f存在

$$
f*g=e
$$

那么就称$g$为$f$的逆元

------

开始介绍莫比乌斯反演

首先介绍一个东西 叫做莫比乌斯函数 $\mu$

定义$\sum$ 函数的逆元为 $\mu$

$$
\mu * \sum= e
$$

写成普通的形式

$$
\sum_{d|n}\mu(d)=[n=1]
$$


带入之后发现$\mu$ 的取值

$$
\mu(n) = \begin{cases}1,n=1\\0,存在一个平方数是n的因子\\(-1)^m,m是n的质因子个数\end{cases}
$$


从上面我们得到了一个重要的结论1:

$$
\sum_{d|n}\mu(d)=[n=1]
$$

------

先求这个式子

$$
\sum_{i<=n} \sum_{d|i} \mu(d)
$$

先枚举了 i, 再考虑 i所有的约数 

等价于 先枚举d 在考虑d在范围内所有的倍数

所以它等于

$$
\sum_{d<=n} \lfloor \frac{n}{d} \rfloor \mu(d)
$$

这个作为结论2

求这个式子

$$
\sum_{i<=n} \sum_{j<=m} [(i,j)=1]
$$

用结论1


$$
\sum_{i<=n} \sum_{j<=m} \sum_{d|(i,j)} \mu(d)
$$


$$
\sum_{i<=n} \sum_{j<=m} \sum_{d|i} \sum_{d|j} \mu(d)
$$


$$
\sum_{i<=n} \sum_{d|i} \sum_{j<=m}  \sum_{d|j} \mu(d)
$$

用结论2


$$
\sum_{i<=n} \sum_{d|i}\sum_{d<=m} \lfloor \frac{m}{d} \rfloor \mu(d)
$$


$$
\sum_{d<=n}\lfloor \frac{n}{d} \rfloor\sum_{d<=m} \lfloor \frac{m}{d} \rfloor \mu(d)
$$


$$
\sum_{d<=min(n,m)} \mu(d)\lfloor \frac{n}{d} \rfloor\lfloor \frac{m}{d} \rfloor
$$

这个作为结论3

------





开始看这道题 

(a,b) 表示a和b的最大公约数

我们先求

$$
\sum_{i<=n} \sum_{j<=n} (i,j)
$$
之后开始变化形式:


$$
\sum_{d<=n}d\times \sum_{i<=n} \sum_{j<=n} [(i,j)=d]
$$


$$
\sum_{d<=n}d\times \sum_{i<=\lfloor \frac{n}{d}\rfloor} \sum_{j<=\lfloor \frac{n}{d}\rfloor} [(i,j)=1]
$$

令$t=n/d$

用结论3

求得

$$
\sum_{d<=n}d \times \sum_{d'<=t}\mu(d')\lfloor \frac{t}{d'}\rfloor^2
$$

之后用除法分块即和前缀和即可(不会除法分块可以去康一康余数求和那道题)

这个结果比最终答案多算了一些 减去即可

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#define il inline
#define res register int
#define int unsigned long long
using namespace std;
const int N=2000000+10;
int n; 
int v[N],p[N];
long long mu[N];
long long sum[N];
void prime()
{
	int cnt=0; mu[1]=1;
	for(res i=2;i<=n;i++)
	{
		if(!v[i])
		{
			v[i]=i; p[++cnt]=i;
			mu[i]=-1;
		}
		for(int j=1;j<=cnt;j++)//保证枚举的是最小质因子 
		{
			if(p[j]>v[i]||i*p[j]>n) break;
			v[i*p[j]]=p[j];
			mu[i*p[j]]=(i%p[j])?-mu[i]:0;
		}
	}
	for(res i=1;i<=n;i++)
		sum[i]=sum[i-1]+mu[i];
}

int calc(int n,int d)
{
	n=n/d; int ret=0,r=0;
	for(res l=1;l<=n;l=r+1)
	{
		int tmp=n/l;
		r=min(n,n/tmp);
		ret+=(sum[r]-sum[l-1])*tmp*tmp;
	}
	return ret;
}

int ans=0;
signed main()
{
	scanf("%d",&n);
	prime();
	for(res d=1;d<=n;d++)
	{
		ans+=d*calc(n,d);
	}
	ans-=n*(n+1)/2;
	ans/=2;
	cout<<ans<<endl;
}
```



---

## 作者：青衫白叙 (赞：35)

其实这题和P2389差不多还简单一些

这里介绍一种O( n )的做法

直接上图:

 ![](https://cdn.luogu.com.cn/upload/pic/9222.png) 

然后ans=(cal(n,n)-n\*(n+1)/2)/2 减去gcd(d,d)=d的和gcd(i,j)=gcd(j,i)重复的

（恩，楼下的dalao我们好巧）。。不知道为什么 int 会WA。。全long long 就A了。。

上代码吧。。

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
typedef long long ll;
const int N=2e6+5;
ll p[N],n;ll phi[N];bool notp[N];
void seive(ll n){
    phi[1] = 1;
    for(ll i=2;i<=n;++i) {
        if(!notp[i]) p[++p[0]] = i, phi[i] = i-1;
        for(ll j=1;j<=p[0] && i*p[j]<=n;++j) {
            notp[i*p[j]] = 1;
            if(i%p[j]==0){phi[i*p[j]]=phi[i]*p[j];break;}
            phi[i*p[j]] = phi[i]*(p[j]-1);
        }
    }
    for(ll i=1;i<=n;++i) phi[i] += phi[i-1];
}
ll cal(ll n,ll m){
    ll ans = 0;ll r;
    for(ll i=1;i<=n;i=r+1) {
        r = min(n/(n/i), m/(m/i));
        ans += (phi[r]-phi[i-1]) * (n/i) * (m/i);
    }
    return ans;
}
int main() {
    scanf("%lld",&n);
    seive(n);
    printf("%lld\n",(cal(n,n)-n*(n+1)/2)/2);
}
```

---

## 作者：VengefulSpirit (赞：29)

本题是一道标准的数论题，所以一切爆搜都走远了。。。

正解：

设f(n)=gcd(1,n)+gcd(2,n)+gcd(3,n)+...+gcd(n-1,n)，

则结果为f(2)+f(3)+...+f(n)

由于所有gcd(x,n)的值都是n的约数，可以按这个约数分类。

用g(n,i)表示满足gcd(x,n)=i且x<n的正整数x的个数，则有

f(n)=Σ{g(n,i)\*i|i为n的约数}.

由于gcd(x,n)=i的充要条件是(x/i)与(n/i)互质，因此满足条件的(x/i)有φ(n/i)个

因此：g(n,i)=φ(n/i).

故: [u]f(n)=Σ{φ(n,i)\*i|i为n的约数}[/u]

如果依次计算f(n)，需要枚举每个n的约数i，速度较慢。而把思维逆转，对于每个i枚举其倍数n，更新f(n)的值，时间复杂度将与素数筛法同阶。


注1：f()这个数组是便于同学们理解此算法，程序中不一定需要出现->这一点自行脑补。

注2：φ()为欧拉函数，不懂的同学自行百度它的定义及生成。

注3：一些初中同学AC算法我没有看懂，目测是变形的欧拉，本质应该是一样的。


---

## 作者：Kubic (赞：21)

# 总结一下这类问题的两种解法：

$(1)$ 莫比乌斯反演+线性筛$\varphi$（大佬用杜教筛，可我是个蒟蒻，不会..........）+整除分块

完全就是套路嘛......

$$\sum_{i=1}^n\sum_{j=1}^{i-1}gcd(i,j)$$
$$=\frac{\sum\limits_{i=1}^n\sum\limits_{j=1}^ngcd(i,j)-\sum\limits_{i=1}^ngcd(i,i)}{2}$$
只看分子前半部分（其它的都是$O(1)$处理）：
$$\sum_{i=1}^n\sum_{j=1}^ngcd(i,j)$$
$$=\sum_{k=1}^nk\sum_{i=1}^n\sum_{j=1}^n[gcd(i,j)=k]$$
$$=\sum_{k=1}^nk\sum_{i=1}^{\lfloor\frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{k}\rfloor}\sum_{d|gcd(i,j)}\mu(d)$$
$$=\sum_{k=1}^nk\sum_{i=1}^{\lfloor\frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{k}\rfloor}[gcd(i,j)=1]$$
$$=\sum_{k=1}^nk\sum_{d=1}^n\mu(d)\lfloor\frac{n}{kd}\rfloor^2$$
令$T=kd$
$$=\sum_{T=1}^n\lfloor\frac{n}{T}\rfloor^2\sum_{k|T}k\mu(\frac{T}{k})$$
$$=\sum_{T=1}^n\lfloor\frac{n}{T}\rfloor^2\varphi(T)$$
$\varphi(T)$可以线性筛，$\lfloor\frac{n}{T}\rfloor^2$可以整除分块（这道题只有$1$组数据，可以不分块）。

时间复杂度：预处理$O(n)$，查询$O(\sqrt n)$（不分块的话是$O(n)$）

$(2)$ 直接推倒+线性筛$\varphi$

$$\sum_{i=1}^n\sum_{j=1}^{i-1}gcd(i,j)$$
$$=\sum_{i=1}^n\sum_{k|i}k\sum_{j=1}^{i-1}[gcd(i,j)=k]$$
$$=\sum_{i=1}^n\sum_{k|i}k\sum_{j=1}^{\frac{i}{k}-1}[gcd(\frac{i}{k},j)=1]$$
$$=\sum_{i=1}^n\sum_{k|i}k\varphi(\frac{i}{k})$$
$\varphi(\frac{i}{k})$可以线性筛，$\sum_{k|i}k\varphi(\frac{i}{k})$可以类似于埃筛，答案再求个前缀和即可。

说明：

$(1)$ 解法$1$最后输出需要加上省略掉的部分（其实就是减去$\frac{n(n+1)}{2}$后再除以$2$）

$(2)$ 解法$2$中的$\varphi(1)$需要特殊地定义为$0$（看看式子就知道为什么了）

$(3)$ **一定要开long long！！！！！**

时间复杂度：预处理$O(\sum_{i=1}^n\sum_{d|n}1)$（即$1$~$n$中所有数的约数个数和），查询$O(1)$

显然，解法$2$更适用于询问组数特别多的时候，在这道题里并不是很优。

贴个图：

解法$1$：
![](https://cdn.luogu.com.cn/upload/pic/65083.png)

解法$2$：
![](https://cdn.luogu.com.cn/upload/pic/65082.png)

可见，此题中解法$1$~~吊打~~解法$2$

代码（$2$种解法）：
```cpp
//解法1
#include <bits/stdc++.h>
using namespace std;
#define N 2000005
#define ll long long
int n,prm[N],phi[N];ll ans,sPhi[N];bool vs[N];
void sieve(int x)
{
    vs[1]=phi[1]=sPhi[1]=1;
    for(int i=2;i<=x;++i)
    {
        if(!vs[i]) prm[++prm[0]]=i,phi[i]=i-1;
        for(int j=1;i*prm[j]<=x;++j)
        {
            vs[i*prm[j]]=1;if(!(i%prm[j])) {phi[i*prm[j]]=phi[i]*prm[j];break;}
            phi[i*prm[j]]=phi[i]*(prm[j]-1);
        }
        sPhi[i]=sPhi[i-1]+phi[i];
    }
}
int main()
{
    scanf("%d",&n);sieve(n);
    for(int i=1,t;i<=n;i=t+1) t=n/(n/i),ans+=1ll*(sPhi[t]-sPhi[i-1])*(n/i)*(n/i);
    printf("%lld\n",ans-(1ll*n*(n+1)>>1)>>1);
}
//解法2
#include <bits/stdc++.h>
using namespace std;
#define N 2000005
#define ll long long
int n,prm[N],phi[N];ll ans,f[N],g[N];bool vs[N];
void sieve(int x)
{
    vs[1]=1;
    for(int i=2;i<=x;++i)
    {
        if(!vs[i]) prm[++prm[0]]=i,phi[i]=i-1;
        for(int j=1;i*prm[j]<=x;++j)
        {
            vs[i*prm[j]]=1;if(!(i%prm[j])) {phi[i*prm[j]]=phi[i]*prm[j];break;}
            phi[i*prm[j]]=phi[i]*(prm[j]-1);
        }
    }
    for(int i=1;i*i<=x;++i)
	{f[i*i]+=i*phi[i];for(int j=i+1;i*j<=x;++j) f[i*j]+=i*phi[j]+j*phi[i];}
	for(int i=1;i<=x;++i) g[i]=g[i-1]+f[i];
}
int main() {scanf("%d",&n);sieve(n);printf("%lld\n",g[n]);}
```

---

## 作者：Lates (赞：20)

莫比乌斯反演入门题
## 前置芝士

- 数论分块，一点点莫比乌斯反演

## 正文

可以考虑先求

$$\sum_{i=1}^{n}\sum_{j=1}^{n}gcd(i,j)$$

然后再去重。

可以想到枚举$n$以内的$p$，把对答案的贡献改成$p\times gcd(i,j)=p$的数的个数

$$\sum_{p=1}^{n}p\sum_{i=1}^{n}\sum_{j=1}^{n}[gcd(i,j)=p]$$

化简式子

$$\sum_{p=1}^{n}p\sum_{i=1}^{\left \lfloor \frac{n}{p} \right \rfloor }\sum_{j=1}^{\left \lfloor \frac{n}{p} \right \rfloor }[gcd(i,j)=1]$$

因为$[gcd(i,j)=1]$只有$gcd(i,j)=1$有$1$的贡献，否则没有，所以可以替换为$\varepsilon(gcd(i,j))$

$\varepsilon(x)$即为当$x=1$时对答案贡献为$1$，否则为$0$

所以现在转化为了

$$\sum_{p=1}^{n}p\sum_{i=1}^{\left \lfloor \frac{n}{p} \right \rfloor }\sum_{j=1}^{\left \lfloor \frac{n}{p} \right \rfloor }\varepsilon(gcd(i,j))$$

由$Dirichlet$卷积得

$\varepsilon =\mu*1 \Leftrightarrow    \varepsilon(n)=\sum_{d|n}\mu(d)$

所以原式转化为
$$\sum_{p=1}^{n}p\sum_{i=1}^{\left \lfloor \frac{n}{p} \right \rfloor }\sum_{j=1}^{\left \lfloor \frac{n}{p} \right \rfloor }\sum_{d|gcd(i,j)}\mu(d)$$

转化一下求和顺序

$$\sum_{p=1}^{n}p\sum_{d=1}{\mu(d)}\sum_{i=1}^{\left \lfloor \frac{n}{p} \right \rfloor }[d\ |\ i]\sum_{j=1}^{\left \lfloor \frac{n}{p} \right \rfloor}[d\ | \ j]$$

后面两个即为求$\left \lfloor \frac{n}{p} \right \rfloor$中$d$的倍数，易知其答案为$\left \lfloor \frac{n}{pd} \right \rfloor$

所以答案转化为

$$\sum_{p=1}^{n}p\sum_{d=1}\mu(d)\left \lfloor \frac{n}{pd} \right \rfloor\left \lfloor \frac{n}{pd} \right \rfloor$$

后面那玩意用数论分块和前缀和即可。

$$ans=\frac{\sum_{p=1}^{n}p\sum_{d=1}\mu(d)\left \lfloor \frac{n}{pd} \right \rfloor\left \lfloor \frac{n}{pd} \right \rfloor-\frac{n(n+1)}{2}}{2}$$

$Code：$

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
#define int long long 
inline int read(){
	register int x=0,f=0,ch=getchar();
	while('0'>ch||ch>'9')f^=ch=='-',ch=getchar();
	while('0'<=ch&&ch<='9')x=(x<<1)+(x<<3)+(ch^'0'),ch=getchar();
	return f?-x:x;
}
const int MAX=2000005;
int n,tot,p[MAX],f[MAX],mu[MAX];
inline void Gmu(){
	mu[1]=1;tot=0;
	for(register int i=2;i<=n;++i){
		if(!f[i]){
			p[++tot]=i;
			mu[i]=-1;
		}
		for(register int j=1;j<=tot&&i*p[j]<=n;++j){
			f[i*p[j]]=1;
			if(i%p[j]==0){
				mu[i*p[j]]=0;
				break;
			}
			mu[i*p[j]]=-mu[i];
		}
	}
	for(register int i=1;i<=n;++i)mu[i]+=mu[i-1]; 
} 
int res,ans;
inline void solve(int n,int p){
	res=0;
	for(register int l=1,r;l<=n;l=r+1){
		r=n/(n/l);
		res+=(mu[r]-mu[l-1])*(n/l)*(n/l);
	}
	ans+=res*p;
}
signed main(){
	n=read();
	Gmu();
	for(register int p=1;p<=n;++p)solve(n/p,p);
	printf("%lld\n",(ans-(n*(n+1)>>1))>>1);
	return 0;
}


```
写得有什么问题麻烦私信笔者，谢谢

---

## 作者：星爵 (赞：10)

楼上的解释已经很详细了，

也可以参考刘汝佳的算法竞赛入门经典训练指南P121和例9

所求s[n]=f[2]+f[3]......f[n];只要求出f[n]就可以用s[n]=s[n-1]+f[n]递推

贴一下代码

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cstdio>
using namespace std;
typedef long long ll;
ll n,s[2000010],f[2000010],ph[2000010];
void euler(int x)
{
    for(int i=1;i<=x;i++)
        ph[i]=0;
    ph[1]=1;
    for(int i=2;i<=x;i++)
        if(!ph[i])
            for(int j=i;j<=x;j+=i)//从一素数开始标记
            {
                if(!ph[j])
                    ph[j]=j;
                ph[j]=ph[j]/i*(i-1);
            }
```
}//与筛法求素数有几分神似
```cpp
int main()
{
    scanf("%lld",&n);
    euler(n);
    for(int i=1;i<=n;i++)
        for(int j=i*2;j<=n;j+=i)
            f[n]+=i*ph[j/i];
        s[2]=f[2];
        for(int i=3;i<=n;i++)
            s[n]=s[n-1]+f[n];
    printf("%lld",s[n]);
    return 0;
}

```

---

## 作者：封禁用户 (赞：6)

## 背景
无意中看到小伙伴$@OYSJ$在写这道题，看了下题目，印象中可以用莫比乌斯水过，发现真的可以用诶，开心qwq。

关于莫比乌斯反演[点我点我](http://www.cinema000.xyz/1082.ruby)

三倍经验：[UVa11417](https://www.luogu.org/problemnew/show/UVA11417)，[UVa11426](https://www.luogu.org/problemnew/show/UVA11426)
## 分析
本题就是求
$$\sum_{i=1}^{n}\sum_{j=i+1}^{n}\gcd(i,j)$$
然后我们可以先求有重复元素的，然后减去重复的好了，这样方便套反演。
枚举最大公约数$d$然后转化成可以分块的形式（准确的说应该是分块思想，公共乘积优化），
$$\begin{aligned}\sum_{i = 1}^n\sum_{j = 1}^m\gcd(i, j)& = \sum_{d = 1}^nd\sum_{i = 1}^n\sum_{j = 1}^m[\gcd(i, j) = d]\\& = \sum_{d = 1}^nd\sum_{x=1}^{\left\lfloor\frac n d\right\rfloor}\mu(x)\left\lfloor\frac n {dx}\right\rfloor\left\lfloor\frac m {dx}\right\rfloor\end{aligned}$$
套分块$O((\sqrt(n)^2)=O(n)$，当然计算过程中溢出了，懒得优化什么的了，直接上了$int128$，应用$double$或高精吧。
```cpp
#include<cstdio>
#include<algorithm>
using std::fill;using std::swap;
typedef unsigned long long int64;
const int MAXN = 2000000 + 6;
int primes[MAXN],mu[MAXN],num,sum[MAXN];
bool isPrime[MAXN];
inline int min(int a,int b){return a < b ? a : b;}
void sieve(){
	fill(isPrime,isPrime + MAXN,true);
	num = 0;mu[1] = 1;
	for(int i = 2;i < MAXN;++i){
		if(isPrime[i]) primes[num++] = i,mu[i] = -1;
		static int d;
		for(int j = 0;j < num && (d = i * primes[j]) < MAXN;++j){
			isPrime[d] = false;
			if(i % primes[j] == 0){
				mu[d] = 0;break;
			}else mu[d] = -mu[i];
		}
	}
	sum[0] = 0;
	for(int i = 1;i < MAXN;i++) sum[i] = sum[i - 1] + mu[i];
}

int64 f(int n,int m,int d){
	if(n > m) swap(n,m);
	int64 ans = 0;
	n /= d,m /= d;
	for(int i = 1,last = 1;i <= n;i = last + 1){
		last = min(n / (n / i),m / (m / i));
		ans += (__int128)((sum[last] - sum[i - 1]) * (__int128)(n / i) * (m / i));
	}
	return ans;
}

int main(){
	sieve();
	int64 n;scanf("%llu",&n);
	int64 ans = 0;
	for(int d = 1;d <= n;d++){
		ans += d * f(n,n,d);
	}
	printf("%llu",(ans - n * (n + 1) / 2) / 2);
	
	return 0;
}
```

---

## 作者：DennyQi (赞：3)

第一次做数论题没看题解就A了……（我好菜啊）

本来想O(n)莫比乌斯反演拿暴力分的，没加整除分块。结果竟然神奇的ac了。考虑使用莫比乌斯反演。设$f(x)$表示$gcd$为$x$的有几对，$F(x)$表示$gcd$为$x$的倍数的有几对。因此$$F(x)=\sum\limits_{x|d}f(d)$$因此可以反演$$f(x)=\sum\limits_{x|d}μ(\dfrac{d}{x})F(d)$$又因为$F(x)=[\dfrac{N}{x}]^2$.因此扫一下搞一下就好了。

注意题目要求的是互不相同的，那我们把所有相同的全部减去，就是一个1到N的等差数列。然后除以2（位置可交换）即可。


```cpp
/*By DennyQi 2018*/
#include <cstdio>
#include <queue>
#include <cstring>
#include <algorithm>
using namespace std;
typedef long long ll;
#define int ll
const int MAXN = 2000010;
const int INF = 0x3f3f3f3f;
inline int Max(const int a, const int b){ return (a > b) ? a : b; }
inline int Min(const int a, const int b){ return (a < b) ? a : b; }
inline int read(){
    int x = 0; int w = 1; register char c = getchar();
    for(; c ^ '-' && (c < '0' || c > '9'); c = getchar());
    if(c == '-') w = -1, c = getchar();
    for(; c >= '0' && c <= '9'; c = getchar()) x = (x<<3) + (x<<1) + c - '0'; return x * w;
}
int N,tot,Ans;
int b[MAXN],prime[MAXN],mu[MAXN];
inline void shai_mu(){
	mu[1] = 1;
	for(int i = 2; i <= N; ++i){
		if(!b[i]){
			prime[++tot] = i;
			mu[i] = -1;
		}
		for(int j = 1; j <= tot; ++j){
			if(i * prime[j] > N) break;
			b[i * prime[j]] = 1;
			if(i % prime[j] == 0){
				mu[i * prime[j]] = 0;
				break;
			}
			mu[i * prime[j]] = -mu[i];
		}
	}
}
inline int F(int x){
	return (N/x) * (N/x);
}
inline int f(int x){
	int res = 0;
	for(int d = x; d <= N; d += x){
		res += mu[d/x] * F(d);
	}
	return res;
}
signed main(){
	N = read();
	shai_mu();
	for(int i = 1; i <= N; ++i){
		Ans += i * f(i);
	}
	printf("%lld", (Ans-(((1+N)*N)/2))/2);
	return 0;
}
```

---

## 作者：redegg (赞：2)

数论分块+线性筛欧拉函数

题目:

$$ans=\sum_{i=2}^n\sum_{j=1}^{i-1} gcd(i,j)$$

那么

$$ans=(\sum_{i=1}^n\sum_{j=1}^ngcd(i,j)-\sum_{i=1}^ngcd(i,i))/2$$

$$2
ans=\sum_{i=1}^n\sum_{j=1}^ngcd(i,j)-((1+n)\times n)/2
$$

难点在如何求$i,j\le n$的任意$gcd(i,j)$之和。

那么我们枚举一个$d$，$gcd(i,j)=d$需要满足：

$i\%d=0,j\%d=0$

$gcd(i/d,j/d)=1$

把$i/d,j/d$替换成$x,y$

那么我们只需要知道有多少对$x,y<=(n/d)$满足$gcd(x,y)=1$就行了。

设$k(x)$为$d=x$时满足的对数。

$$\sum_{i=1}^n \sum_{j=1}^n gcd(i,j)=\sum_{d=1}^nd\times k(d)$$

那么用上欧拉函数:$phi(x)$或者是$\phi(x)$，表示小于$x$的数中与$x$互质的数的数量。$phi(1)=0$，若$p$为质数,$phi(p)=p-1$。

$phi$是积性函数，那么在$gcd(a,b)=1$下有：$phi(ab)=phi(a)\times phi(b)$

同时，当$a\%p=0$，$p$为质数
的时候，有，$phi(ap)=phi(a)\times p$。

现在我们只要求出

$$k(d)=\sum_{i=1}^{n/d} phi(i)\times 2+1$$


用前缀和预处理出$k()$就可以了。

答案就是

$$ans=(\sum_{d=1}^nd\times k(d)-((1+n) n)/2)/2$$

了。


当然，我们还需要枚举$d$的时候进行数论分块优化。但是这并不在我们的主要推导内容中，不多复述。

```cpp
#include <bits/stdc++.h>
using namespace std;

long long n;
int cnt;
bool vis[2000005];
int p[2000005];
int phi[2000005];
long long sum[2000005];
int maxn=2000000;
long long ans=0ll;

void get_prime()
{
    phi[1]=0;
    phi[2]=1;
    for(int i=2;i<=maxn;i++)
    {
        if(!vis[i]){
            cnt++;
            p[cnt]=i;
            phi[i]=i-1;
        }
        for(int j=1;j<=cnt && i * p[j] <=maxn;j++)
        {
            vis[i*p[j]]=1;
            if(i % p[j])
                phi[i*p[j]] = phi[i] * (p[j] - 1);
            else{
                phi[i*p[j]] = phi[i] * p[j];
                break;
            }
        }
    }
    for(int i=1;i<=maxn;i++)
        sum[i]=sum[i-1]+phi[i];
}



void run()
{
    ans=0;
    scanf("%lld",&n);
    for(int i=1;i<=n;i++)
    {
        int val=n/i;
        int r=n/val;
        long long an=(sum[val]*2+1)*(r+i)*(r-i+1)/2;
        ans+=an;
        i=r;
    }
}

int main()
{
    get_prime();
    run();
    ans-=((1+n)*n/2);
    ans/=2;
    printf("%lld\n",ans);
    return 0;
}
```


---

## 作者：hwk0518 (赞：2)

讲一种比较套路的做法。

先随便推一下式子：

$\sum_{i=1 \to n}\sum_{j=1 \to n}gcd(i,j)$

$=\sum_{d}\sum_{i=1 \to n}\sum_{j=1 \to n}[gcd(i,j)=d]$

推到这里发现推不下去了，想到用容斥，先求出$\sum_{i=1 \to n}\sum_{j=1 \to n}[d|gcd(i,j)]$，再减去不合法的。但这样做是$O(n^2)$的，和暴力没区别。

虽然推了一种错误的解法，但我们发现$\sum_{i=1 \to n}\sum_{j=1 \to n}\sum_{d|i,d|j}f(d)$很好算。设$f(n)=n$，如果我们能构造一个$g(n)$使$\sum_{d|i}g(d)=f(i)$就能解决问题了。

设$I(n)=1$，
可以发现，$f$是$g$和$I$的卷积。由反演定理，$g$是$f$和$\mu$的卷积。求出$g$后，式子化为：

$\sum_{d=1 \to n}\sum_{i=1 \to n}\sum_{j=1 \to n}[d|gcd(i,j)]$

$=\sum_{d=1 \to n}g(d)\sum_{i=1 \to n/d}\sum_{j=1 \to n/d}1$

$=\sum_{d=1 \to n}g(d)*n/d*n/d$

时间复杂度:$O(n*lnn)$

代码：

```

#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<string>
#include<algorithm>
#include<math.h>
using namespace std;

const int N=5e6+5;
int n,used[N];
long long f[N],mju[N],h[N];

void prework()
{
    int i,j;
    mju[1]=f[1]=1;
    for(i=2;i<=n;++i)
        if(!used[i])
        {
            mju[i]=-1;
            f[i]=i;
            for(j=i+i;j<=n;j+=i)
            {
                used[j]=1,f[j]=j;
                if((j/i)%i) mju[j]=-mju[j/i];
                else mju[j]=0;
            }
        }
//	for(i=1;i<=n;++i) cout<<mju[i]<<" "<<f[i]<<endl;//cout<<endl;
}

void Dirichlet(long long *f,long long *g,long long *h)
{
    int i,j;
    for(i=1;i<=n;++i)
        for(j=i;j<=n;j+=i)
            h[j]+=1LL*f[i]*g[j/i];
}

void work()
{
    int d;
    long long ans=0;
    for(d=1;d<=n;++d) ans+=1LL*(n/d)*(n/d)*h[d];
    long long calc=1LL*n*(n+1)/2;
    printf("%lld\n",(ans-calc)/2);
}

int main()
{
    scanf("%d",&n);
    prework();Dirichlet(f,mju,h);work();
    return 0;
}

```

---

## 作者：SaoFish (赞：1)

emmmm

好久没有写过题解了，觉得这题还挺有意思的，就决定爆一发题解。

设两个数a，b的gcd为t，那显然**a/t**与**b/t**互质。（a，b都≤n）

所以，当我们枚举t的时候，问题就转化成了，**在1~n/t这些数中，有几对数是互质的**，然后那求出的**对数乘上t**，加到ans中。

求几对数互质就很好求啦，只要**预处理出2~n的φ（欧拉函数）**，再求个前缀和sum，那么**1~x中互质的对数就是sum[x]**啦（这里phi[1]=0）。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define rep(i,x,y) for (register int i=(x);i<=(y);i++)
#define drp(i,x,y) for (register int i=(x);i>=(y);i--)
#define travel(i,x) for (register int i=head[x];i;i=e[i].nxt)
inline char read(){
	static const int IN_LEN=1000000;
	static char buf[IN_LEN],*s,*t;
	return (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);
}
template<class T>
inline void read(T &x){
	static bool iosig;
	static char c;
	for (iosig=false,c=read();!isdigit(c);c=read()){
		if (c=='-') iosig=true;
		if (c==-1) return;
	}
	for (x=0;isdigit(c);c=read()) x=((x+(x<<2))<<1)+(c^'0');
	if (iosig) x=-x;
}
const int OUT_LEN=10000000;
char obuf[OUT_LEN],*ooh=obuf;
inline void print(char c){
	if (ooh==obuf+OUT_LEN) fwrite(obuf,1,OUT_LEN,stdout),ooh=obuf;
	*ooh++=c;
}
template<class T>
inline void print(T x){
	static int buf[30],cnt;
	if (x==0) print('0');
	else{
		if (x<0) print('-'),x=-x;
		for (cnt=0;x;x/=10) buf[++cnt]=x%10+48;
		while (cnt) print((char)buf[cnt--]);
	}
}
inline void flush(){
	fwrite(obuf,1,ooh-obuf,stdout);
}
void judge(){
	freopen("data.in","r",stdin);
	freopen("data.out","w",stdout);
}
//以上是没用的读优，可以省略
const int N=2100000;
int n,phi[N],p[N],opt;
long long sum[N];
bool used[N];
void init(){
	phi[1]=0;
	rep(i,2,n){
		if (!used[i]){
			phi[i]=i-1;
			p[++opt]=i;
		}
		for (int j=1;p[j]*i<=n;j++){
			used[p[j]*i]=1;
			if (i%p[j]==0){
				phi[i*p[j]]=phi[i]*p[j];
				break;
			}
			phi[i*p[j]]=phi[i]*(p[j]-1);
		}
	}
	rep(i,1,n) sum[i]=sum[i-1]+phi[i];
}//求phi，这里的phi[1]=0
int main(){
	//judge();
	read(n);
	init();
	long long ans=0;
	rep(i,1,n){
		int t=n/i;
		if (t==1) break;
		ans+=1ll*sum[t]*1ll*i;
	}
	print(ans),print('\n');
	return flush(),0;
}
```

---

## 作者：cz666 (赞：0)

欧拉函数可以卡过此题（亲身尝试过了，开O2刚刚好卡过：[AC的测评记录](https://www.luogu.org/recordnew/show/18053798)）。

直接贴代码吧，这道题有好多倍经验呢...~~（开心开心...）~~

AC代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn=2000003;
int a[maxn+1],b[maxn+1],v[maxn+1];
int sz,n,p[maxn+1],fi[maxn+1];
inline void Eular(){//用素数互质关系来寻找欧拉函数
    for(register int i=2;i<=maxn;i++){
        if(!v[i]) p[++sz]=i,fi[i]=i-1;
        for(register int j=1;j<=sz && p[j]*i<=maxn;j++){
            v[p[j]*i]=1;
            if(i%p[j]==0){fi[i*p[j]]=fi[i]*p[j];break;}
            fi[i*p[j]]=fi[i]*(p[j]-1);
        }
    }
} 
//超级像欧拉筛，不错，时间复杂度和欧拉筛的确相等，只是收集答案公式不一样而已。
signed main(){
	v[1]=1;Eular();//预处理以1~maxn作为基数的所有欧拉函数值
    for(register int i=1;i<=maxn;i++)
     for(register int j=i*2;j<=maxn;j+=i) a[j]+=i*fi[j/i];
    for(register int i=1;i<=maxn;i++) b[i]=b[i-1]+a[i];
    scanf("%lld",&n);
    printf("%lld\n", b[n]);
	//O(1)回答此题的所有问题 
    return 0;
}
```

但是不开O2会被卡掉4个点 $ QAQ $ 。


---


# 苦恼的小明

## 题目描述

黄小明和他的合伙人想要创办一所英语培训机构，注册的时候要填一张个人情况的表格，在身高一栏小明犯了愁。

身高要求精确到厘米，但小明实在太高了，无法在纸上填下这么长的数字。小明花钱买通了办事人员，于是只要写上他的身高模 $10007$ 的结果就行了。

可小明不会取模，想起前几天请你帮他解决了水库的问题，于是又来找你帮忙。


## 说明/提示

所有的 $0\le a_i<10^4$。

第 $1 \sim 6$ 数据点满足 $n=2$。

第 $7 \sim 10$ 数据点满足 $n=3$。

第 $11$ 个数据点满足 $n=1234567$。

## 样例 #1

### 输入

```
2										
17 747```

### 输出

```
173```

# 题解

## 作者：Stairs_upon_temple (赞：14)

## 本题唯一一个不用递归过的题解！

------------


记住公式 $a^b=a^{b\ \bmod\ \varphi(m)+\ \varphi(m)}\pmod m$。

任何情况下均可使用(不分是否互质)。

------------
简单推一下：

$a_1^{a_2^{a_3^{a_4...}}}$ 

$ \equiv a_1^{(a_2^{a_3^{a_4...}})\ \bmod\ \varphi(m)\ +\ \varphi(m)}\ \pmod b$

$ \equiv a_1^{(a_2^{(a_3^{\ \ ...})\ \bmod\ \varphi(\varphi(m))\ +\ \varphi(\varphi(m))})\ \bmod\ \varphi(m)\ +\ \varphi(m)}\ \pmod b$ 


依此类推：

每次只需求出当前次数下的模数并类推下一次。

将每一次求出的模数结果存下来。

再用欧拉公式进行降幂。

即可在标准时间内通过。



------------

注意细节，每次快速幂求解时应加上每次取余的值，不然到后面 $\varphi$ 值为 $1$ 时，
最后一个要乘方的数会计算成 $1$。


------------



```cpp
/*
g++ -o2 P1405.cpp -o c -std=c++14
.\c

*/

#include<bits/stdc++.h>
#include<cstdio>
using namespace std;

typedef long long ll;
typedef __int128 in;
const in N=2e6+100;
const in MOD=10007;
in max(in a,in b){return a>b?a:b;}
in min(in a,in b){return a<b?a:b;}

ll n;
ll phi[N];
ll mod[N];

in ask(in m){  //求欧拉函数
    in sum=m;
    for(in i=2;i*i<=m;i++){
        if(m%i==0){
            sum=sum/i*(i-1);
            while(m%i==0) m/=i;
        }
    }
    if(m>1) sum=sum/m*(m-1);
    return sum;
}

in mul(in a, in b, in p){ //快乘，但没什么卵用
    a%=p,b%=p;
    long double z=(long double)a/p*b;
    in z2=z;
    in r=a*b-z2*p;
    if(r<0)r+=p;
    return r;
}

in mul_add(in a,in b,in p)
{
    in ans=0;
    while(b){
        if(b&1) ans=(ans+a)%p;
        a=(a+a)%p;
        b>>=1;
    }
    return ans;
}

void init(){  //初始化模数
    phi[1]=MOD;
    for(in i=2;i<=n+100;i++){
        phi[i]=ask(phi[i-1]);
    }
    return ;
}

in quick_pow(in a,in b,in mod){   //快速幂
    in sum=1;
    while(b){
        if(b&1){
            sum=mul_add(sum,a,mod);
            if(sum>=mod)sum=sum%mod+mod;
        }
        a=mul_add(a,a,mod);
        if(a>=mod)a=a%mod+mod;
        b>>=1;
    }
    return sum;
}

int main(){
    scanf("%lld",&n);
    init();
    // for(int i=1;i<=100;i++)printf("%lld ",phi[i]);
    // printf("\n");
    for(in i=1;i<=n;i++){
        scanf("%lld",&mod[i]);
        // if(phi[i]==1)mod[i]=1;
        // else if(mod[i]>=phi[i])mod[i]=(mod[i]%phi[i]+phi[i]);
    }
    in sum=1;
    in flag=0;
    for(in i=n;i>=1;i--){
        in dis=sum;
        sum=quick_pow(mod[i],sum,phi[i]);
        if(sum==1 && mod[i]!=1)sum+=phi[i];
        if(phi[i]==1)sum=1;
        if(sum==0)sum+=phi[i];
        // ll a=sum;
        // ll b=mod[i];
        // ll c=sum;
        // ll d=phi[i];
        // printf("%lld : %lld %lld %lld\n",a,b,c,d);
    }
    ll s=sum%MOD;
    printf("%lld\n",s);
    return 0;
}

/*
5
2 2 2 50 641

*/

```

---

## 作者：August_Light (赞：11)

# P1405 苦恼的小明 题解

[题目传送门](https://www.luogu.com.cn/problem/P1405)

## 题意简述

给定长度为 $n$ 的自然数序列 $a$，求 $a_1^{a_2^{\dots^{a_n}}} \bmod 10007$。

$0 \le a_i < 10^4, n \le 1234567$。

## 前置知识

[扩展欧拉定理](https://www.luogu.com.cn/problem/P5091)：

$$a^b \equiv \begin{cases} a^b & b < \varphi(m) \\ a^{b \bmod \varphi(m) + \varphi(m)} & b \ge \varphi(m) \end{cases} \pmod m$$

## 解法

有了扩展欧拉定理，我们自然会有一个思路：

设 $f(x)$ 为后 $x$ 项形成的幂塔的值。

$$f(x) \equiv \begin{cases} a_x^{f(x+1)} & f(x+1) < \varphi(m) \\ a_x^{f(x+1) \bmod \varphi(m) + \varphi(m)} & f(x+1) \ge \varphi(m) \end{cases} \pmod m$$

根据这个式子，发现事实上我们并不需要真的求出 $f(x+1)$ 的值，我们只需要知道 $f(x+1) \bmod \varphi(m)$ 以及 $f(x+1)$ 和 $\varphi(m)$ 的大小关系。

坑点：有的人求出了 $b$ 对 $\varphi(m)$ 取模的值，然后和 $\varphi(m)$ 比大小，这显然是没有意义且不符合扩展欧拉定理式子的。这个地方杀了一大车题解：[hack](https://www.luogu.com.cn/discuss/655151)。

## 代码

因为 $\varphi$ 的特性，所以递归层数是 $\log$ 级别的，不会超时。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef __int128 int128;

LL phi(LL n) {
    LL ret = n;
    for (LL i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            ret = ret / i * (i - 1);
            while (n % i == 0)
                n /= i;
        }
    }
    if (n != 1)
        ret = ret / n * (n - 1);
    return ret;
}

int128 qpow(int128 a, int128 b, int128 p) { // 在快速幂的同时保住 a^b 和 p 的大小关系
    int128 ret = 1;
    while (b) {
        if (b & 1) {
            ret *= a; if (ret >= p) ret = ret % p + p;
        }
        a *= a; if (a >= p) a = a % p + p;
        b >>= 1;
    }
    return ret;
}

const int MAXN = 1234567 + 5;

int n;
LL a[MAXN];

LL f(int i, LL p) {
    if (i == n+1 || p == 1)
        return 1;
    return qpow(a[i], f(i+1, phi(p)), p);
}

const int MOD = 10007;

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
        scanf("%d", &a[i]);
    LL ans = f(1, MOD);
    printf("%d\n", ans % MOD);
    return 0;
}
```

## 练习题

[POWTOW - Power Tower City](https://www.luogu.com.cn/problem/SP10050)


---

## 作者：PR_CYJ (赞：5)

# [题目传送门](https://www.luogu.com.cn/problem/P1405)
# 思路
一道简单的扩展欧拉定理模板题。

遇到数论题先推式子。

根据扩展欧拉定理 $a^b\equiv a^{(b\bmod \varphi(p))+\varphi(p)} \pmod p(b\ge \varphi(p))$，原式可以化为
$$
\begin{aligned}a_1^{{a_2}^{{\cdots}^{a_n}}}&\equiv a_1^{({a_2}^{{\cdots}^{a_n}})\bmod \varphi(10007)+\varphi(10007)}\\&\equiv a_1^{({a_2}^{({a_3}^{{\cdots}^{a_n}})\bmod \varphi(\varphi(10007))+\varphi(\varphi(10007))})\bmod\varphi(10007)+\varphi(10007)}\\&\equiv a_1^{({a_2}^{({a_3}^{({a_4}^{{\cdots}^{a_n}})\bmod \varphi(\varphi(\varphi(10007)))+\varphi(\varphi(\varphi(10007)))})\bmod \varphi(\varphi(10007))+\varphi(\varphi(10007))})\bmod\varphi(10007)+\varphi(10007)}\pmod {10007}\end{aligned}
$$
以此类推，当推到 $a_{15}$ 的时候，模数就已经变为了 $1$，因此可以将所有欧拉函数的值处理出来，再从 $a_n$ 倒着往前递推，使用快速幂求解出 $a_{i-1}^{a_i\bmod p+p}$，再将结果保存到 $a_{i-1}$，最后 $a_1\bmod 10007$ 即为答案。
# 代码
- 切勿抄袭！！！

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2000000;
int n,a[N],m[20]={0,0,10007,10006,5002,2400,640,256,128,64,32,16,8,4,2,1,1};//预处理好模数 
int pw(int u,int v,int mod)
{
	int sum=1;
	bool flag=true;
	while(v)
	{
		if (v&1)
		{
			sum=sum*u;
			if (sum>=mod)
			{
				flag=true;
				sum%=mod;
			}
		}
		u=u*u%mod;
		v>>=1;
	}
	if (flag)
		sum+=mod;//扩展欧拉定理 
	return sum;
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	for(int i=n;i>=2;i--)
		a[i-1]=pw(a[i-1],a[i],(i>14)?1:m[i]);//i大于14时模数都变为1 
	cout<<a[1]%10007<<"\n";//最后还要模10007 
}
```

---

## 作者：Tomwsc (赞：2)

# P1405 苦恼的小明 题解

## 题意

给定一个长度为 $n$ 的数组 $a$ 求：$a_1^{a_2^{\cdots^{a_n}}} \mod 10007$ 的值。

## 思路及解法

对于这类幂塔问题，我们通常采用扩展欧拉定理求解。

### 扩展欧拉定理：

对于 $a^b \bmod m$ 这样一个式子。

- 若 $b \ge \phi(m)$，则 $a^b \equiv a^{b \bmod \phi(m) + \phi(m)}  (\operatorname{mod} m)$
- 若 $b < \phi(m)$，原式不变

其中 $\phi(m)$ 表示 $m$ 的欧拉函数，即为在 $1$ 到 $m-1$ 中与 $m$ 互质的数的个数。具体求法在这里就不过多赘述了，详见[这里](https://blog.csdn.net/qq_63786973/article/details/126830465?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522c25cbc8982d2a28ddeae690ed19e352b%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=c25cbc8982d2a28ddeae690ed19e352b&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-6-126830465-null-null.142^v101^pc_search_result_base1&utm_term=%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E7%9A%84%E6%B1%82%E6%B3%95&spm=1018.2226.3001.4187)。

有了扩展欧拉定理后，解题变得简单了。

我们通过一个简单的例子来找一下规律：

$$
\begin{equation*}
\begin{aligned}
a_1^{a_2^{a_3^{a_4}}}
&\equiv a_1^{(a_2^{a_3^{a_4}}) \bmod \phi(m) + \phi(m)} \pmod m\\
&\equiv a_1^{(a_2^{({a_3^{a_4}}) \bmod \phi(\phi(m)) + \phi(\phi(m))})\bmod \phi(m) + \phi(m)} \pmod m \\
&\equiv a_1^{(a_2^{(a_3^{(a_4) \bmod \phi(\phi(\phi(m))) + \phi(\phi(\phi(m)))})\bmod \phi(\phi(m))+\phi(\phi(m))})\bmod \phi(m) + \phi(m))} \pmod m
\end{aligned}
\end{equation*}
$$

我们发现，求解的过程即为一个递归的过程，于是我们便可以通过递归来求解此题。

```cpp
int solve(int step , int mod) {
    if(step == n + 1 || mod == 1)
        return 1;
    return ksm(a[step] , solve(step + 1 , phi[mod]) , mod);
}
```

注意到递归边界：

当递归到第 $b + 1$ 层或 $\phi(mod)=1$ 时，直接返回 $1$。

由于可能出现 $b<\phi(m)$ 的情况，所以快速幂要进行一点改动（详见代码）。

同时，我们可以通过欧拉线性筛预处理出数据范围内所有数的欧拉函数。

```cpp
void Init_phi() {
    is_prime[1] = true;
    phi[1] = 0;
    for(register int i = 2;i <= MAXN;i ++) {
        if(!is_prime[i]) {
            prime[++ cnt] = i;
            phi[i] = i - 1;
        }
        for(register int j = 1;j <= cnt && prime[j] * i <= MAXN;j ++) {
            is_prime[prime[j] * i] = true;
            if(i % prime[j] == 0) {
                phi[i * prime[j]] = phi[i] * prime[j];
                break;
            } else
                phi[i * prime[j]] = phi[i] * phi[prime[j]];
        }
    }
    return;
}
```

## 代码实现

```cpp
#include<bits/stdc++.h>
#define int __int128
using namespace std;
const int MAXN = 2e6 + 10 , mod = 10007;
int phi[MAXN] , prime[MAXN] , cnt;
bool is_prime[MAXN];
int n;
int a[MAXN];
 
inline int ksm(int base , int x , int mod) {
    int result = 1;
    bool flag = false;
    while(x) {
        if(x & 1) {
        	result = result * base;
        	if(result >= mod)
        		result = result % mod + mod;
		}
        x >>= 1;
        base = base * base;
        if(base >= mod)
        	base = base % mod + mod;
    }
    return result;
}
 
int solve(int step , int mod) {
    if(step == n + 1 || mod == 1)
        return 1;
    return ksm(a[step] , solve(step + 1 , phi[mod]) , mod);
}
 
void Init_phi() {
    is_prime[1] = true;
    phi[1] = 0;
    for(register int i = 2;i <= MAXN;i ++) {
        if(!is_prime[i]) {
            prime[++ cnt] = i;
            phi[i] = i - 1;
        }
        for(register int j = 1;j <= cnt && prime[j] * i <= MAXN;j ++) {
            is_prime[prime[j] * i] = true;
            if(i % prime[j] == 0) {
                phi[i * prime[j]] = phi[i] * prime[j];
                break;
            } else
                phi[i * prime[j]] = phi[i] * phi[prime[j]];
        }
    }
    return;
}
 
inline int read() {
    char c = getchar();
    int x = 0 , s = 1;
    while(c < '0' || c > '9') {
        if(c == '-')
            s = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9') {
        x = x * 10 + c - '0';
        c = getchar();
    }
    return x * s;
}
 
void write(int x) {
    if(x < 0) {
        putchar('-');
        x = - x;
    }
    if(x > 10)
        write(x / 10);
    putchar(x % 10 + '0');
    return;
}
 
signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    Init_phi();
    n = read();
    for(register int i = 1;i <= n;i ++)
        a[i] = read();
    write(solve(1 , mod) % mod);
    return 0;
}
```

---

## 作者：XiaoLe_MC (赞：2)

首先，根据欧拉定理可知：

$$
a^b\equiv a^{b\bmod\phi(p)+\phi(p)}\bmod p
$$

这个定理的好处就在于可以大大降低指数的大小。以下内容用到了这个狮子。

现在来观察题目：若要求 $a_1^{a_2^{a_3}}\bmod10007$ ，可以先缩小指数，求出 $a_2^{a_3}\bmod\phi(10007)\ +\phi(10007)$。但还是不够，再一次缩小指数，求出 $a_3\bmod\phi(\phi(10007))\ +\phi(\phi(10007))$。以此类推，不断缩小指数，最后再使用快速幂取模得出答案。总的来说，整个过程就是先不断向上递归用欧拉定理缩小指数
，再向下回溯用快速幂求解。

当 $a$ 的数量超过 13 的时候，$\phi$ 值就变成了 1，再往上走就没有啥意义了，直接退出。当然，也可以预先求解出所有的 $\phi$ 值，不多，就 13 个。

update(2024.6.16)：感谢@August_Light 大佬提供的 Hack 数据，发现了代码中存在的漏洞。修复此问题可以直接添加一个特判 $a$ 为 1 时直接返回 1。 

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, mod[13] = {10007, 10006, 5002, 2400, 640, 256, 128, 64, 32, 16, 8, 4, 2};
inline int getans(int times, int m){
	if(!times || m >= 13) return 1;
	int a, ans = 1, k;
	cin>>a;
	k = getans(times-1, m+1);
	if(a == 1) return 1; // 注意这里 
	while(k){
		if(k & 1) ans = (long long)ans * a % mod[m];
		a = (long long)a * a % mod[m];
		k >>= 1;
	}
	return m?ans + mod[m]:ans;
}
int main(){
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	cin>>n;
	return cout<<getans(n, 0), 0;
}
```

---

## 作者：hexz01 (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P1405)

## 前置知识

[1.欧拉函数](https://oi.wiki/math/number-theory/euler-totient/)

[2.扩展欧拉定理](https://oi.wiki/math/number-theory/fermat/#%E6%89%A9%E5%B1%95%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86)

## 部分分做法

### 60 分做法

直接快速幂，做 ${a_1}^{a_2}$ 即可。

### AC 做法

首先发现指数太大，用快速幂根本没法做，于是考虑扩展欧拉定理：

![](https://cdn.luogu.com.cn/upload/image_hosting/drncnm8e.png)

发现上面两种情况可以合并为第一种情况，为了分类讨论简便，我们只需要判断 $b$ 是否小于 $\varphi(p)$ 即可。

设函数 ```sol(int l, int r, int p)``` 表示 ${a_l}^{{a_{l+1}}^{\cdots^{a_r}}}$ 的值，要求这个值，就要求出 ${a_{l+1}}^{\cdots^{a_r}}$，也就是 ```sol(l+1, r, p)``` 的值。

加入扩展欧拉定理：
1. 当 ```sol(l+1, r, p)``` 小于 $\varphi(p)$ 时，```sol(l+1, r, p)=sol(l+1, r, phi[p])```。
2. 当 ```sol(l+1, r, p)``` 大于 $\varphi(p)$ 时，```sol(l+1, r, p)=sol(l+1, r, phi[p])+phi[p]```。

此时需要在递归求值过程中记录一个标记 $flag$ 作为第二个返回值，表示指数是否大于 $\varphi(p)$。此处 $flag$ 只需要在每个取模的地方判断是否大于模数即可，具体见代码注释。

### AC code

```cpp
#include <iostream>
#include <vector>
using namespace std;
const int N=20007;
int n;
int a[1234570];

//接下来线性筛欧拉函数部分，phi数组即为所求。
int pri[N], tot=0;
bool is_pri[N], phi[N];
void pre(){
    phi[1]=1;
    for(int i=2;i<=20000;i++){
        if(!is_pri[i]){
            pri[++tot]=i;
            phi[i]=i-1;
        }
        for(int j=1;j<=tot && i*j<=20000;j++){
            is_pri[i*j]=1;
            if(i%j==0){
                phi[i*j]=phi[i]*j;
                break;
            }
            phi[i*j]=phi[i]*phi[j];
        }
    }
}

//快速幂部分，传回两个值，第一个是结果，第二个是flag
pair<int, bool> ksm(int x, int y, int p){
    int ans=1;
    bool flag=0;
    if(x>=p)
        x%=p, flag=1;//第一次判断
    while(y){
        if(y&1){
            ans=ans*x;
            if(ans>=p)
                ans%=p, flag=1;//第二次判断
        }
        x=x*x;
        if(x>=p)
            x%=p, flag=1//第三次判断;
        y>>=1;
    }
    return make_pair(ans, flag);
}
pair<int, bool> sol(int l, int r, int mod){
    if(mod==1)//最多log(10007)次后mod=1，此时无论如何返回0，因为任何数mod 1 都为0
        return make_pair(0, 0);
    if(l==r){
        int tmp=a[l];
        bool flag=0;
        if(tmp>=mod)
            tmp%=mod, flag=1;//返回最后一个数时也要判断
        return make_pair(tmp, flag);
    }
    pair<int, bool> tmp=sol(l+1, r, phi[mod]);//接下来算指数
    int nowa=a[l];//当前底数
    if(tmp.second)//如果b>=phi[p]
        tmp.first+=phi[mod];//再加上phi[p]
    return ksm(al, tmp.first, mod);//返回答案（快速幂返回值意义和solve返回值意义相同，所以直接返回）
}
int main(){
    cin>>n;
    pre();
    for(int i=1;i<=n;i++)
        cin>>a[i];
    cout<<sol(1, n, 10007).first<<endl;
    return 0;
}
```

---

## 作者：chenyyy (赞：1)

# P1405 苦恼的小明 题解
## 题意描述
给定 $n$ 个数 $a_1,a_2,a_3\cdots ,a_n$ 求 $a_1^{a_2^{\cdots a_n}}\bmod 10007$ 的值。
## 前置知识
### 扩展欧拉定理
给定一个同余方程 $a^b\equiv x\pmod{p}$，求 $x$。

当 $b\geq \varphi(p)$ 时 $x\equiv a^{b\bmod\varphi(p) + \varphi(p)}\pmod{p}$。

当 $b<\varphi(p)$ 时 $x\equiv a^b\pmod{p}$。
## 思路
设 $f(x) = a_x^{a_{x+1}^{\cdots a_n}}$。

如 $f(1)=a_1^{a_2^{\cdots a_n}},f(2)=a_2^{a_3^{\cdots a_n}}\cdots$。

显然，$f(1)=a_1^{f(2)}$ 而 $f(2)=a_2^{f(3)}$。

于是，找规律可知 $f(x)=a_x^{f(x + 1)}$。

则当 $f(x + 1)\geq \varphi(p)$ 时 $f(x)\equiv a_x^{f(x + 1)\bmod\varphi(p) + \varphi(p)}\pmod{p}$。

当$b<\varphi(p)$ 时 $f(1)\equiv a_x^{f(x+1)}\pmod{p}$。

于是我们可以递归求解：

```cpp
int solve(int step,int mod){
	if(step == n)return a[n];
	return power(a[step],solve(step + 1,phi[mod]),mod);
}
```
其中 $step$ 表示递归到第几项，而 $mod$ 表示模数。

## coding

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod = 10007;
int n,a[2000005];
int phi[mod + 5],p[10000 + 5],tot;
bool vis[mod + 5];
inline int read(){
	int ans,f = 1;
	char c;
	while((c = getchar()) < '0' || c > '9'){
		if(c == '-'){
			f = -1;
		}
	}
	ans = c ^ 48;
	while((c = getchar()) <= '9' && c >= '0'){
		ans = (ans << 1) + (ans << 3) + (c ^ 48);
	}
	return ans * f;
}
void prepare(){//预处理phi
	phi[1] = 1;
	vis[0] = vis[1] = 1;
	for(int i = 2;i <= mod;i++){
		if(!vis[i]){
			p[++tot] = i;
			phi[i] = i - 1;
		}
		for(int j = 1;j <= tot;j++){
			if(i * p[j] > mod)break;
			vis[i * p[j]] = 1;
			if(i % p[j] == 0){
				phi[i * p[j]] = phi[i] * p[j];
				break;
			}
			phi[i * p[j]] = phi[i] * phi[p[j]];
		}
	}
}
int power(int a,int b,int mod){
	int ans = 1;
	while(b){
		if(b & 1){
			ans = ans * a;
			if(ans >= mod)	ans = ans % mod + mod;
		}
		a = a * a;
		if(a >= mod)
			a = a % mod + mod;
		b >>= 1;
	}
	return ans;
}

int solve(int step,int mod){
	if(step == n)return a[n];
	return power(a[step],solve(step + 1,phi[mod]),mod);
}
signed main(){
	prepare();
	cin >> n;
	for(int i = 1;i <= n;i++){
		cin >> a[i];
	}
	cout << solve(1,mod) % mod;
	return 0;
}
```

---

## 作者：LostKeyToReach (赞：1)

根据欧拉定理，我们有：
$$
a^b \equiv a^{b \bmod \varphi(m) + \varphi(m)} \pmod{m}
$$

那么我们推一波式子：

$
a_1^{a_2^{\ldots^{a_n}}} \equiv a_1^{(a_2^{\ldots^{a_n}}) \bmod \varphi(m) + \varphi(m)} \equiv  a_1^{(a_2^{(a_3^{\ldots^{a_n}}) \bmod \varphi(\varphi(m))+ \varphi(\varphi(m))}) \bmod \varphi(m) + \varphi(m)} \equiv \ldots \pmod{m}
$

那么我们可以定义函数 $f(x,m)$ 为：

$$ f(x,m)=\left\{
\begin{array}{rcl}
1,       &      &	& x>n\\
1,			&		 &   & m=1\\
a_x^{f(x+1,\varphi(m)) \bmod \varphi(m)+ \varphi(m)} \bmod m,& &&\text{otherwise}
\end{array} \right. $$

递归实现即可。

有人问递归会不会爆栈，我们看一下 $m,\varphi(m),\varphi(\varphi(m)),\ldots$ 的值：
$$
10007,10006,5002,2400,640,256,128,64,32,16,8,4,2,1,\ldots
$$

我们发现，当到第 $14$ 层时，$m$ 就为 $1$ 了，这说明这个函数调用层数为 $\min(n,14)$，不会爆栈。

那么这道题就解决了，代码如下：
```cpp
ll phi(ll x) {
	ll res = x;
	int t = x;
	for (ll i = 2; i * i <= t; i++) {
		if (x % i == 0) {
			res = res * (i - 1) / i;
			while (x % i == 0) x /= i;
		}
	}
	if (x > 1) res = res * (x - 1) / x;
	return res;
}
int n;
ll a[1234568];
ll f(ll now, ll p) {
	if (now > n) return 1;
	if (p == 1) return 1;
	return quick_pow(a[now], f(now + 1, phi(p)) % phi(p) + phi(p), p);
}
int main() {
	read(n);
	rep(i, 1, n, 1) {
		read(a[i]);
	}
	write(f(1, 10007));
}
```

---

## 作者：hzoi_Shadow (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P1405)

# 前置知识

[扩展欧拉定理](https://oi-wiki.org/math/number-theory/fermat/#扩展欧拉定理)

# 解法

本题幂塔是有限层的，这里与 [luogu P4139 上帝与集合的正确用法](https://www.luogu.com.cn/problem/P4139) 中的无限层幂塔不同，故需要在到达递归边界 $n+1$ 时进行特殊处理，对于处理 $\varphi(p)$ 在递归过程中等于 $1$ 的情况两题基本一致。

回忆扩展欧拉定理中的 $b$ 和 $\varphi(p)$ 的关系，如果我们按照 [常规的快速幂写法](https://oi-wiki.org/math/binary-exponentiation/#模意义下取幂) 会出现问题，即我们无法正确判断 $a^b$ 在作为下一次运算的指数时和 $\varphi(p)$ 之间的大小关系，这就需要我们额外在快速幂的过程中判断 $a^b$ 和 $\varphi(p)$ 之间的大小关系。
  - 在这里可以使用 ``__int128_t`` 来代替实现高精度的快速幂。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll __int128_t 
#define sort stable_sort 
#define endl '\n'
ll a[1300000];
ll read()
{
    ll x=0,f=1;
    char c=getchar();
    while(c>'9'||c<'0')
    {
        if(c=='-')
        {
            f=-1;
        }
        c=getchar();
    }
    while('0'<=c&&c<='9')
    {
        x=x*10+c-'0';
        c=getchar();
    }
    return x*f;
}
ll phi(ll n)
{
    ll ans=n,i;
    for(i=2;i<=sqrtl(n);i++)//因为使用了__int128_t，为防止CE便使用了sqrtl，亦可以写成i*i<=n的形式
    {
        if(n%i==0)
        {
            ans=ans/i*(i-1);
            while(n%i==0)
            {
                n/=i;
            }
        }
    }
    if(n>1)
    {
        ans=ans/n*(n-1);
    }
    return ans;
}
ll qpow(ll a,ll b,ll p)
{
    ll ans=1;
    while(b)
    {
        if(b&1)
        {
            ans=ans*a;
            if(ans>=p)//快速幂特殊处理1
            {
                ans=ans%p+p;
            }
        }
        b>>=1;
        a=a*a;
        if(a>=p)//快速幂特殊处理2
        {
            a=a%p+p;
        }
    }
    return ans;
}
ll f(ll i,ll n,ll p)
{
    return (i==n+1||p==1)?1:qpow(a[i],f(i+1,n,phi(p)),p);//对幂塔进行递归
}
int main()
{
    ll n,i,p=10007;
    n=read(); 
    for(i=1;i<=n;i++)
    {
        a[i]=read();
    }
    printf("%lld\n",f(1,n,p)%p);//因为最后结果小于10007，所以可以放心大胆地当作long long输出
    return 0;
}
```

---

## 作者：Wilderness_ (赞：0)

~~非常好数论题，使我大脑旋转。~~
## 思路
给定一个序列 $a_1$ 至 $a_n$，求 $a_1^{a_2^{\cdots^{a_n}}}\bmod 10007$ 的值。
首先看到这么多次幂，尝试使用扩展欧拉定理使其降一下幂。

扩展欧拉定理：

$a^b\equiv \begin{cases}
  & a^b,\ b<\varphi(m)\\
  & a^{b\bmod \varphi(m)+\varphi(m)},\ b\ge\varphi(m)
\end{cases}\pmod m$，其中 $\varphi(n)$ 表示欧拉函数，即小于等于 $n$ 的正整数中与 $n$ 互质的数的数目。

那么式子就先被化成了 $a_1^{(a_2^{\cdots^{a_n}})\bmod\varphi(a_2^{\cdots^{a_n}})+\varphi(a_2^{\cdots^{a_n}})}\bmod 10007$，
再用一次扩展欧拉定理，化成了 $a_1^{(a_2^{(a_3^{\cdots^{a_n}}\bmod\varphi(a_3^{\cdots^{a_n}})+\varphi(a_3^{\cdots^{a_n}}))})\bmod\varphi(a_2^{\cdots^{a_n}})+\varphi(a_2^{\cdots^{a_n}})}\bmod 10007$，同理递推。

但是我们懒，不愿意递推怎么办？我们可以先预处理求一遍 $\varphi(1)$ 到 $\varphi(n)$ 的值，然后从 $a_n$ 
开始进行快速幂，指数为上一次快速幂求出的值，底数为 $a_i$（如果 $a_i\ge\varphi(i)$ 时，底数应为 $a_i\bmod \varphi(i)+\varphi(i)$），模数为 $\varphi(i)$第 $i$ 次求 $a_{i-1}$ 的指数，最后一次得出的值就是答案。

最后输出时别忘了取模。

## Code
```cpp
#include<bits/stdc++.h>
#define M 11451411
#define ll long long
using namespace std;
ll n,tmp,ans=1,phi[M],num[M];
const ll mod=10007;
ll qpow(ll x,ll y,ll m)
{
	ll res=1;
	while(y)
	{
		if(y&1)res=res*x%m+m;
		y>>=1;
		x=x*x%m+m;
	}
	return res;
}
int main()
{
	scanf("%lld",&n);
	phi[1]=mod;
	for(ll i=2;i<=n+114;i++)
	{
		tmp=phi[i-1];
		phi[i]=1;
		for(ll j=2;j*j<=tmp;j++)
		{
			if(tmp%j)continue;
			phi[i]*=j-1;
			tmp/=j;
			while(!(tmp%j))phi[i]*=j,tmp/=j;
		}
		if(tmp>1)phi[i]*=(tmp-1);
	}
	for(ll i=1;i<=n;i++)
	{
		scanf("%lld",&num[i]);
		if(phi[i]<num[i])num[i]=num[i]%phi[i]+phi[i];
	}
    for(ll i=n;i>=1;i--)ans=qpow(num[i],ans,phi[i]);
	printf("%lld",ans%mod);
	return 0;
}
```

---


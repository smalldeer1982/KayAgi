# 互质数列sequence【数据疑似有误】

## 题目描述

一个数列有 $n$ 个数字，我们定义一种操作：我们可以将相邻两个数字同时除以它们的一个公约数，这个操作所花费的代价为作为除数的这个公约数的值。我们经过若干次这样操作，可以将原数列变为相邻的数对都互质的数列。问达成要求的最小代价。

## 说明/提示

- $30\%$ 数据满足 $n \leq 20$；
- $100\%$ 数据满足 $1 \leq n \leq 10000$，数列中的数字 $1\le A_i \leq 2 \times 10^7$。



## 样例 #1

### 输入

```
3
3
12
6
```

### 输出

```
5
```

# 题解

## 作者：feecle6418 (赞：9)

不妨假设对 $i,i+1$ 执行了一次操作，且操作的公因数 $d$ 不是质数，则它可以分解为两个大于 $1$ 的正整数的乘积 $p\times q$；因为 $p,q\ge 2$ 所以 $pq\ge p+q$，那不如分别去操作 $p,q$。所以，每次操作都操作一个质数更优。

把每个数分解质因数，对每个质数分开考虑它的幂次的变化，相当于：每次可以把相邻两个数均减去 $1$，问最小的操作次数使得任意相邻两个数均不同时 $\ge 0$，这个从左往右做个 dp 即可。

---

## 作者：ethanho (赞：1)

# **一丢丢思路**

我们可以使用动态规划来求解最小代价。

首先处理出数列中相邻数字的最大公约数，记为 $\gcd(a _ {i},a _ {i+1})$

接下来，定义动态规划数组 $dp[i][j]$，其中 $dp[i][j]$ 表示将数列的前 $i$ 个数字处理成相邻数对互质，且第 $i$ 个数字变为 $j$ 的最小代价（ $j$ 是 $a _ {i}$ 的约数之一）。


初始化 $dp[1][j]$。
对于 $i>1$，计算 $dp[i][j]$：
- 遍历 $a _ {i-1}$ 的所有约数 $k$ （应该不会爆的吧）。
- 如果 $\gcd(k,j)=1$ （即 $k$ 和 $j$ 互质），则考虑从 $dp[i−1][k]$ 转移到 $dp[i][j]$。
- 转移代价为 $dp[i−1][k]+\gcd(a _ {i},j)$。
- 更新 $dp[i][j]$ 为所有可能转移中的最小值。
- 最终答案为 $dp[n][j]$ 中的最小值，其中 $j$ 是 $a _ {n}$ 的一个约数。

---


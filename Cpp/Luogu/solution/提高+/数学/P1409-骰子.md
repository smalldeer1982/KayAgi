# 骰子

## 题目描述

$n$ 个人排成一排，你排在第 $m$ 个。

每轮队首的人投一次骰子。

- 若掷到 $1$，则队首的人获胜。
- 若掷到 $2,4,6$，则队首的人排到队尾。
- 若掷到 $3,5$，则队首的人出队。

若队列中仅剩一人，则该人获胜，求你获胜的概率。

## 说明/提示

- 对于 $30\%$ 的数据，$0<m\le n\le 10$。
- 对于 $100\%$ 的数据，$0<m\le n\le 1000$。

## 样例 #1

### 输入

```
2 1
```

### 输出

```
0.444444444
```

# 题解

## 作者：LYYY (赞：25)

一开始看到这个题的时候，我觉得是一道挺基础的题，但是后来发现，这道题并不是简单的概率dp，~~更偏像数论~~。


------------

**言归正传：**


题意

若掷到1，则队首的人获胜；

若掷到2,4,6，则队首的人出队；

若掷到3,5，则队首的人排到队尾。


------------

不妨令f[i][j] (j<=i)表示队中共有i个人，第j个人赢的概率,则有f[1][1]=1；

这样我们会发现f[i][j]可以进行转移：

1. 1/6的概率游戏结束，输;

2. 1/3的概率队首的人会到队尾，转移到f[i][j-1];

3. 1/2的概率队首的人出队，转移到f[i-1][j-1];

但是我们转移的时候会发现各个状态形成的网络并不是一个有向无环图，有可能一直没有人出队，从而一直循环下去，形成环，因此不能直接进行动态规划。

**怎么办呢？**

## 我们来推理一下QWQ

一共有4个人，小姜排在第3个，我们只关注ta的胜率，我们要求的是f[4][3];

根据上面的转移，可以知道f[4][3]有两部分组成：

一是1/3的概率转移为f[4][2];二是1/2的概率转移为f[3][2] (另一种是1/6的概率直接输，我们要求的是胜率，因此不考虑这种情况)。

故有 

### **f[4][3] = 1/3 × f[4][2] + 1/2 × f[3][2]**

同理，

### **f[4][2] = 1/3 × f[4][1] + 1/2 × f[3][1]**

### **f[4][4] = 1/3 × f[4][3] + 1/2 × f[3][3]**

但是f[4][1]要特殊：

1. 1/6的概率游戏结束，赢;

2. 1/3的概率小姜会到队尾，转移到f[4][4];

3. 1/2的概率小姜出队，输;

故有

### **f[4][1] = 1/3 × f[4][4] + 1/6**

到此，我们就把f[4][x]都用表达式表示出来了；

但是我们要求f[4][3]的值啊，这样求不出来怎么办？

不急，将表达式中的f[3][x]也都表示出来：

### **f[3][1] = 1/3 × f[3][3] + 1/6**

### **f[3][2] = 1/3 × f[3][1] + 1/2 × f[2][1]**

### **f[3][3] = 1/3 × f[3][2] + 1/2 × f[2][2]**

还有f[2][x],也都表示出来

### **f[2][1] = 1/3 × f[2][2] + 1/6**

### **f[2][2] = 1/3 × f[2][1] + 1/2 × f[1][1]**
另，
### **f[1][1] = 1**

现在我们就能看出这不过是多元一次方程组嘛，愉快地解方程就好啦



------------
------------
接下来说一下**如何解方程**（dalao请忽略）

~~萌新福利~~

## 解方程 

### **f[1][1] = 1**

### **f[2][1] = 1/3 × f[2][2] + 1/6**

### **f[2][2] = 1/3 × f[2][1] + 1/2 × f[1][1]**

### **f[3][1] = 1/3 × f[3][3] + 1/6**

### **f[3][2] = 1/3 × f[3][1] + 1/2 × f[2][1]**

### **f[3][3] = 1/3 × f[3][2] + 1/2 × f[2][2]**

### **f[4][1] = 1/3 × f[4][4] + 1/6**

### **f[4][2] = 1/3 × f[4][1] + 1/2 × f[3][1]**

### **f[4][3] = 1/3 × f[4][2] + 1/2 × f[3][2]**

### **f[4][4] = 1/3 × f[4][3] + 1/2 × f[3][3]**

通过观察，我们发现方程们（皮一下很开心）的两点性质：

**1. 所有的等式左边都只有一个未知量且其系数为1；**

**2. 大部分方程长得都差不多，右边未知量（暂且把第二项看做常量）的系数都是1/3;**

这两个性质就是解题的关键所在，所以我们循环用**代入消元法**就行了

结合代码：

```cpp
f[1][1]=1;//初始化
	for(int i=2;i<=n;i++)//表示想要求到f[n][x]
	{
		double xishu=(double)1/3,changshu=(double)1/6;
        //由于我们无法用代码直接解方程，所以记录下式子的系数xishu和常数changshu，并对它们进行操作，最后再处理就好了
		for(int j=2;j<=i;j++)
		{
			xishu=xishu/3;
			changshu=changshu/3+f[i-1][j-1]/2;
		}
        //不断将f[i][j-1]代入f[i][j],合并成为新的一个等式；
        //最终使之合并成为一个以f[i][i]为未知数的一元一次方程；
		f[i][i]=changshu/(1-xishu);//解出f[i][i]
		f[i][1]=f[i][i]/3+(double)1/6;//解出f[i][1]
		for(int j=2;j<i;j++)
		{
			f[i][j]=f[i][j-1]/3+f[i-1][j-1]/2;
		}
        //递推求出f[i][x];
	}
    
    //其实应该可以化简出多项式解法，这样就不用循环了；只是本人有点懒，加上数据也不大，所以就用循环求解啦
```

完整代码如下：

```cpp
#include<cstdio>
#include<iostream>
using namespace std;

int n,m;
double f[1111][1111];

int main()
{
	scanf("%d%d",&n,&m);
	
	f[1][1]=1;
	for(int i=2;i<=n;i++)
	{
		double xishu=(double)1/3,changshu=(double)1/6;
		for(int j=2;j<=i;j++)
		{
			xishu=xishu/3;
			changshu=changshu/3+f[i-1][j-1]/2;
		}
		f[i][i]=changshu/(1-xishu);
		f[i][1]=f[i][i]/3+(double)1/6;
		for(int j=2;j<i;j++)
		{
			f[i][j]=f[i][j-1]/3+f[i-1][j-1]/2;
		}
	}
	
	printf("%.9lf",f[n][m]);
	return 0;
} 
```

但是这一份代码只得了70分，后来通过看冷dalao的博客才明白；

题面和数据不匹配~~（有大坑）~~：

题面：


------------


若掷到1，则队首的人获胜；

若掷到2,4,6，则队首的人出队；

若掷到3,5，则队首的人排到队尾。


------------

数据：



------------
若掷到1，则队首的人获胜；

若掷到2,4,6，则队首的人排到队尾；

若掷到3,5，则队首的人出队。


------------

所以是数据有问题啦（2018.10.12），简单一改就AC了。

AC代码：

```cpp
#include<cstdio>
#include<iostream>
using namespace std;

int n,m;
double f[1111][1111];

int main()
{
	scanf("%d%d",&n,&m);
	
	f[1][1]=1;
	for(int i=2;i<=n;i++)
	{
		double xishu=(double)1/2,changshu=(double)1/6;
		for(int j=2;j<=i;j++)
		{
			xishu=xishu/2;
			changshu=changshu/2+f[i-1][j-1]/3;
		}
		f[i][i]=changshu/(1-xishu);
		f[i][1]=f[i][i]/2+(double)1/6;
		for(int j=2;j<i;j++)
		{
			f[i][j]=f[i][j-1]/2+f[i-1][j-1]/3;
		}
	}
	
	printf("%.9lf",f[n][m]);
	return 0;
} 
```



------------


10.15补：

其实这道题也可以用数组降维来优化空间，代码（70分的，100分的改改就行了，~~逃~~）：

```cpp
#include<cstdio>
#include<iostream>
using namespace std;

int n,m;
double f[1111];

int main()
{
	scanf("%d%d",&n,&m);
	
	f[1]=1;
	for(int i=2;i<=n;i++)
	{
		double xishu=(double)1/3,changshu=(double)1/6;
		for(int j=2;j<=i;j++)
		{
			xishu=xishu/3;
			changshu=changshu/3+f[j-1]/2;
		}
		f[i]=changshu/(1-xishu);
		double ans=f[1];//存上一层的值以备计算
		f[1]=f[i]/3+(double)1/6;
		for(int j=2;j<i;j++)
		{
			double lll=f[j];//同理，先存上一层的值
			f[j]=f[j-1]/3+ans/2;
			ans=lll;//更新ans给下一层用
		}
	}
	
	printf("%.9lf",f[m]);
	return 0;
}
```

感谢冷dalao，小江（姜）。

 _谢谢阅览！_ 

---

## 作者：ChthollyTree (赞：8)

你们的方法啊

都太复杂了！

由于这里只要求保留⑨位小数，所以说，我们不必推方程组

和正解做法一样，我们定义$f[i][j]$表示有$i$个人，你在第$j$个

我们定义$g[i][j]$

$g[i][1] = \frac{1}{6}$

$g[i][j](j!=1) = f[i-1][j-1]$

$next(j)$表示$j$在环上的上一个位置,即$next(1) = i$其他$next(j) = j-1$


然后$f[i][j]$就是$g[i][j] + \frac{1}{2}f[i][next(j)]$

也就是

$\sum_{k=1}^{inf}\frac{1}{2^k}*g[i][next(next...next(j))]$（$k$个next）

由于到$k$比较大的时候，$\frac{1}{2^k}$ 非常小

此时对答案的贡献可以忽略不计

一般$k$上限取50比较好

可能看代码会更好理解一些

```
#include<bits/stdc++.h>
using namespace std;

#define MAXN 1005
#define db double

int n,m;
db f[MAXN][MAXN];
db g[MAXN][MAXN];

void rd() {
	cin >> n >> m;
}

signed main()
{
	rd();
	f[1][1] = 1;
	for(int i = 2; i <= n; i ++) { 
		g[i][1] = (db)1/6;
		for(int j = 2; j <= i; j ++) {
			g[i][j] = (db)1/3*f[i-1][j-1];		
		}
		for(int j = 1; j <= i; j ++) {
			db w = 1;
			int ne = j;
			for(int t = 1; t <= 50; t ++) {
				f[i][j] += g[i][ne] * w;
				w /= 2;
				ne --;
				if(ne < 1) ne = i; 
			}
		}		
	}
	printf("%.9lf",f[n][m]);	 
	return 0;
}

```



---

## 作者：naroto2022 (赞：5)

# P1409 题解
博客里食用更佳。
### 题意
题目的意思浅显易懂：

 $n$ 个人站成一排，小明（临时演员）是第 $m$ 个人，每轮上帝会投一次筛子，分为以下情况：

- 若掷到 $1$，则队首的人获胜；
- 若掷到 $2$，$4$，$6$，则队首的人出队；
- 若掷到 $3$，$5$，则队首的人排到队尾。

问：小明有多少的胜率？（注意：输出保留九位小数）
### 思路
这不就是一道 dp 和数学结合起来的题吗？？？
### 分析
我们就设二维数组 $f[1005][1005]$，$f[i][j]$ 表示有 $i$ 个人，小明在第 $j$ 个位置，小明的胜率。 

易知，$f[1][1]=1$，因为只有一个人的时候小明直接胜利！且由题意得 $j\leqslant i$。

接下来，我们需要把题目带进来，求出状态转移方程式（动态规划的递推式）。

1. 掷到 $1$，则队首的人获胜，这时候，小明有 $\frac{1}{6}$ 的概率会输掉（对手的人胜利了，小明就输了）。
2. 掷到 $2$，$4$，$6$，则队首的人出队，此时，队首的人有 $\frac{1}{2}$ 的概率会转回队尾，（那又是一个天道好轮回了……）也就是相当于小明又往前走了一步（$j-1$），而总人数（$i$）不变，表示为 $f[i][j-1]$。
3. 掷到 $3$，$5$，则队首的人排到队尾，此时，队首的人有 $\frac{1}{3}$ 的概率出队，也就是相当于小明又往前走了一步（$j-1$），而总人数却又少了一个人（$i-1$），表示为 $f[i-1][j-1]$。

列出了上表，dp递推式也就很简单了，由于小明为主角，绝不能输，所以就不讨论第一种情况，所以，对于 $x$，$y$（$x\leqslant y$，$x$，$y$ 为正整数），都有 $f[x][y]$，此时有 $\frac{1}{2}$ 的概率跳到 $f[x][y-1]$；有 $\frac{1}{3}$ 的概率跳到 $f[x-1][y-1]$ 所以推出动态规划递推式：

### $f[x][y]=\frac{1}{2}f[x][y-1]+\frac{1}{3}f[x-1][y-1]$。

最后小明就会跳到 $f[u][1]$（$u$ 为正整数且 $u\leqslant n$）（这里 $u$ 是代表当小明为第一个人时，总共还剩几人），小明就到了第一个，上帝要为他摇骰子了！而当小明为第一个时，$j=1$，所以没有 $f[u][0]$ 或 $f[u-1][0]$，所以我们要单独推当 $j=1$ 时的情况：他有 $\frac{1}{6}$ 的概率会胜利，而又会有 $\frac{1}{3}$ 的概率出局（要求小明的胜率，这种情况不讨论），也有 $\frac{1}{2}$ 跳到队尾，也就是跳到 $f[u][u]$（又是一个天道好轮回），所以 $f[u][1]=\frac{1}{6}+\frac{1}{2} f[u][u]$。

这就可以推广到所有 $j=1$ 时的情况，因此我们就会建立这么多个循环往复的等式，这是一个连续的多元一次方程组，是容易解决的，观察一下系数，然后就可以用代入消元法解决了。（谢谢 Aw顿顿 ）

观察系数的代码如下：

```cpp
for(int j=2; j<=i; j++){//观察系数
	sum=sum/2;
	num=num/2+f[i-1][j-1]/3;
}
```
### 总结：
1. 坑点（也不算吧）：输出保留九位小数。
2. 需要的基础：dp+数学（数论）。
3. dp 比较别致一点，因为 dp 数列可能会构成一个环，所以须要观察系数，然后就可以用代入消元法解决了。
4. 当小明第一个人时，若遇到第二种情况，还需要重新排到队尾，千万不可结束，不然听取 WA 声一片。

### 废话不多说了，上总代码！
注释在代码里了

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,m;
double f[1005][1005];
int main(){
	cin>>n>>m;
	f[1][1]=1;//初始化！只有一个人的时候你直接胜利！别忘了写这一行
	for(int i=2; i<=n; i++){
		double sum=0.5,num=1.0/6.0;
		//1.0/6.0和1/6可有大区别了！
		//1/6=0.166666667……，取整一下为0
		//1.0/6.0则是相当于(double)1/6
		for(int j=2; j<=i; j++){//观察系数
			sum=sum/2;
			num=num/2+f[i-1][j-1]/3;
		}
		//不断将f[i][j-1]带入f[i][j],最终就可以求出下面二式
		f[i][i]=num/(1-sum);//解出了f[i][i]
		f[i][1]=f[i][i]/2+1.0/6.0;//解出了f[i][1]
		for(int j=2; j<i; j++) f[i][j]=f[i][j-1]/2+f[i-1][j-1]/3;//前面推出的解析式（递推式？到底说算是什么啊……）
	}
	printf("%.9lf",f[n][m]);//保留九位输出
	return 0;
} 
//P上水印
```
###### 小明结束了他的演艺生涯。。。

---

## 作者：Aw顿顿 (赞：4)

## 题意

$n$ 个人排成一排，你排在第 $m$ 个。

每轮队首的人投一次骰子。

- 若掷到 $1$，则队首的人获胜。
- 若掷到 $2,4,6$，则队首的人排到队尾。
- 若掷到 $3,5$，则队首的人出队。

若队列中仅剩一人，则该人获胜，求你获胜的概率。

## 解法

一道套着期望 DP 题的方程题（

为方便理解，接下来的 $f_{i,j}$ 均记作 $f(i,j)$，我们用它表示队列中有 $i$ 个人时第 $j$ 个人获胜的几率，这时候就考虑边界条件，也就是 $f(1,1)=1$——当只有一个人的时候，他一定会胜利，不难发现一定有 $j\le i$。接着我们要考虑状态转移方程。

- 如果投掷出 $1$ 了，就有 $\tfrac{1}{6}$ 的概率会输掉这场游戏。
- 如果投掷到 $2,4,6$，则有 $\frac{1}{2}$ 的概率会转移到队尾，也就是 $f(i,j-1)$。
- 如果投掷到 $3,5$，则有 $\frac{1}{3}$ 的概率会队头出队，向前走一步，转移到 $f(i-1,j-1)$。

由于我们只考虑胜率，所以第一种情况不计入 DP。同时我们注意到这个 DP 序列可能形成环，所以不能直接上手操作，应该怎么办呢？按照题目要求有 $n$ 个人，我排在第 $m$ 个，此时我们要求 $f(n,m)$，然后我们知道他有  $\frac{1}{2}$ 的概率转移到 $f(n,m-1)$，有 $\frac{1}{3}$ 的概率转移到 $f(n-1,m-1)$，所以可以推导出：

$$f(n,m)=\frac{1}{2}f(n,m-1)+\frac{1}{3}f(n-1,m-1)$$

这样循环往复，最后会找到 $f(n,1)$ 的情况，这种情况下我们会有 $\frac{1}{6}$ 的情况胜利，有 $\frac{1}{2}$ 的机会转移到队尾 $f(n,n)$，另有 $\frac{1}{3}$ 的机会输掉，所以 $f(n,1)=\frac{1}{6}+\frac{1}{2}f(n,n)$。在之后类似的推到可以推广到 $n-1,n-2,\cdots,1$ 的所有情况——我们就会建立这么多个循环往复的等式，这是一个连续的多元一次方程组，是容易解决的，考虑观察一下系数，然后就可以用代入消元法解决了。

## 代码

```cpp
#include<bits/stdc++.h> 
using namespace std;
int n,m;
double f[1005][1005];
int main(){
	cin>>n>>m;
	f[1][1]=1;
	for(int i=2;i<=n;i++){
		double s=0.5,t=1.0/6.0;
		for(int j=2;j<=i;j++){
			s=s/2;
			t=t/2+f[i-1][j-1]/3;
		}
		f[i][i]=t/(1-s);
		f[i][1]=f[i][i]/2+1.0/6.0;
		for(int j=2;j<i;j++)
			f[i][j]=f[i][j-1]/2+f[i-1][j-1]/3;
	}printf("%.9lf",f[n][m]);
	return 0;
} 
```

---

## 作者：littleKtian (赞：3)

upd on 2021.8.6：重新修了一遍排版。

------------

记 $f_{i,j}$ 为当前队列有 $i$ 个人时，第 $j$ 个人的获胜概率。特别的，$f_{1,1}=1$。

先看 $j=1$ 的情况。

此时第一个人扔骰子会出现三种情况：
1. $\dfrac{1}{6}$ 的概率直接获胜（扔中 1）。

2. $\dfrac{1}{3}$ 的概率出队（扔中 3、5）。

3. $\dfrac{1}{2}$ 的概率排到队尾（扔中 2、4、6），这时他的获胜概率变为 $f_{i,i}$。

所以第一个人的获胜概率为 $f_{i,1}=\dfrac{1}{6}+\dfrac{1}{2}f_{i,i}$。

再看最后一个人。

前 $i-1$ 个人中 $k$ 个人出队的概率为 $\left(\dfrac{1}{3}\right)^k\times\left(\dfrac{1}{2}\right)^{i-k-1}\times \dbinom{i-1}{k}(0\leq k<i)$。

此时队伍中还剩 $i-k$ 个人，他的获胜概率为 $f_{i-k,1}$。所以最后一个人的获胜概率为 $f_{i,i}=\sum\limits_{k=0}^{i-1}\left(\dfrac{1}{3}\right)^k\times\left(\dfrac{1}{2}\right)^{i-k-1}\times\dbinom{i-1}{k}\times f_{i-k,1}$。

~~所以这玩意互相包含啥用也没有~~假设我们已经算出这之前所有$j=1$的情况,此时我们有两个方程和两个未知数,由这两个方程可以得出：

$$\begin{aligned}f_{i,1}&=\dfrac{1}{6}+\dfrac{1}{2}\left(\sum\limits_{k=0}^{i-1}\left(\dfrac{1}{3}\right)^k\times\left(\dfrac{1}{2}\right)^{i-k-1}\times\dbinom{i-1}{k}\times f_{i-k,1}\right)\\&=\dfrac{1}{6}+\dfrac{1}{2}\left(\sum\limits_{k=1}^{i-1}\left(\dfrac{1}{3}\right)^k\times\left(\dfrac{1}{2}\right)^{i-k-1}\times\dbinom{i-1}{k}\times f_{i-k,1}\right)+\left(\dfrac{1}{2}\right)^{i}\times f_{i,1}\end{aligned}$$

得 $f_{i,1}=\dfrac{\dfrac{1}{6}+\dfrac{1}{2}\left(\sum\limits_{k=1}^{i-1}\left(\dfrac{1}{3}\right)^k\times\left(\dfrac{1}{2}\right)^{i-k-1}\times\dbinom{i-1}{k}\times f_{i-k,1}\right)}{1-\left(\dfrac{1}{2}\right)^{i}}$。

同样也可以推出:

$$\begin{aligned}f_{i,i}&=\sum\limits_{k=1}^{i-1}\left(\left(\dfrac{1}{3}\right)^k\times\left(\dfrac{1}{2}\right)^{i-k-1}\times\dbinom{i-1}{k}\times f_{i-k,1}\right)+\left(\dfrac{1}{2}\right)^{i-1}\times\left(\dfrac{1}{6}+\dfrac{1}{2}f_{i,i}\right)\\&=\sum\limits_{k=1}^{i-1}\left(\left(\dfrac{1}{3}\right)^k\times\left(\dfrac{1}{2}\right)^{i-k-1}\times\dbinom{i-1}{k}\times f_{i-k,1}\right)+\left(\dfrac{1}{2}\right)^{i}\times(\dfrac{1}{3}+f_{i,i})\end{aligned}$$

得 $f_{i,i}=\dfrac{\sum\limits_{k=1}^{i-1}\left(\left(\dfrac{1}{3}\right)^k\times\left(\dfrac{1}{2}\right)^{i-k-1}\times\dbinom{i-1}{k}\times f_{i-k,1}\right)+\left(\dfrac{1}{2}\right)^{i}\times\dfrac{1}{3}}{1-\left(\dfrac{1}{2}\right)^{i}}$。

从而我们可以推出任意 $f_{i,j}$ 的递推公式。

$$f_{i,j}=\sum\limits_{k=0}^{j-1}\left(\dfrac{1}{3}\right)^k\times\left(\dfrac{1}{2}\right)^{j-k-1}\times \dbinom{j-1}{k}\times f_{i-k,1}$$

一些更细节的地方在代码里讲。
```
//此代码先计算每次的f[i][i]，再算f[i][1]
#include<bits/stdc++.h>
using namespace std;
double f[1010],l,ll[1010],ans;
//f[i]即为上面式子中的f[i][1]，因为过程中后续公式计算中只需要f[i][1]，所以不必将每个f[i][j]都计算出并储存 
//l为每次得出的f[i][i]
//ll[k]为每次的((1/3)^(i-k)*(1/2)^(k-1)*C(i-1,i-k)*f[k][1])
//每次ll[k]的更新只需要在原基础上*(i-1)/k/3即可
double cf_1c2[1010];
//cf_1c2[i]=(1/2)^i
int n,m;
int main()
{
	scanf("%d%d",&n,&m);
	f[1]=ll[1]=1;
	cf_1c2[0]=1;
	for(int i=1;i<=n;i++)cf_1c2[i]=cf_1c2[i-1]/2;//初始化
	for(int i=2;i<=n;i++)
	{
		l=cf_1c2[i]/3;
		for(int j=1;j<i;j++)
		{
			ll[i-j]=ll[i-j]*(double)(i-1)/(double)(j)/3;
			l+=ll[i-j];
		}
		l/=(1-cf_1c2[i]);
		f[i]=1.0/6+l/2;
		ll[i]=f[i]*cf_1c2[i-1];
	}//计算f[i][1](i<=n)
	for(int i=0;i<m;i++)
	{
		l=1;
		for(int j=1;j<=i;j++)l*=((double)(m-j)/(double)(i-j+1)/3);
		for(int j=1;j<m-i;j++)l/=2;
		l*=f[n-i];
		ans+=l;
	}//计算f[n][m]
	printf("%0.9f",ans);
}
```



---

## 作者：zcysky (赞：3)

这题居然没人做？

原题是SRM504.5 CTheTicketsDivOne

考虑DP，转移的时候第三种情况可能成环

那么先转移前两种，再带着算即可。

```cpp
#include<bits/stdc++.h>
#define N 5005
using namespace std;
double dp[N],a[N],tmp[N];
int n,m;
int main(){
    scanf("%d%d",&n,&m);
    dp[1]=1;
    for(int i=2;i<=n;i++){
        a[1]=1./6;for(int j=2;j<=i;j++)a[j]=1./3*dp[j-1];
        double s=0,t=1;
        for(int j=1;j<=i;j++){s/=2;t/=2;s+=a[j];}
        tmp[i]=s/(1-t);tmp[0]=tmp[i];
        for(int j=1;j<i;j++)tmp[j]=a[j]+tmp[j-1]/2;
        for(int j=1;j<=i;j++)dp[j]=tmp[j];
    }
    printf("%.9lf\n",dp[m]);
}
```

---

## 作者：int08 (赞：2)

# 前言
先科普，“骰”字读
```
tóu not shai
```
# Solution

看到这道题的题面，我的思路异常清晰：

**动态规划啊！**

然后咻咻咻的一下，状态转移方程就来了，很快啊。

## 状态转移方程

设 $f_{n,m}$ 表示有 $n$ 个人的情况下站在第 $m$ 位的胜率，则可以分两种情况讨论：

### 1、$f_{n,1}$ （即我在第一位）

因为有 $\frac{1}{2}$ 的概率排到队尾，$\frac{1}{6}$ 的概率直接胜利，所以可以得出:

$f_{n,1}=\frac{1}{6}+\frac{f_{n,1}}{2}$

### 2、$f_{n,m},(m \ne 1)$ （即我不在第一位）

由于有 $\frac{1}{3}$ 的概率当前排在第一位的人直接去世(我的排位会向前一位)，$\frac{1}{2}$ 的概率当前排在第一位的人来到最后（也就是我向前走了一位），所以说可以得出：

$f_{n,m}=\frac{f_{n-1,m-1}}{3}+\frac{f_{n,m-1}}{2},(m \ne 1)$

好啦，状态转移方程已经写完了。然后呢？

~~然后就出现嵌套啦！~~

### 3、解决嵌套问题

观察状态转移方程，我们不难发现，有 $\frac{1}{2^{n}}$ 的概率计算 $f_{n,1}$ 时会重新回到 $f_{n,1}$。

假设用 $g_n$ 来表示不考虑嵌套部分（也就是递归函数第二次到达计算 $f_{n,1}$ 时直接返回 $0$）时 $f_{n,1}$ 的值（这个值本身不是真正的 $f_{n,1}$），那我们就可以得出这么一个玩意儿：

$f_{n,1}=g_n+\frac{f_{n,1}}{2^n}$

解出这个方程，可得：

$f_{n,1}=\frac{2^n}{2^n-1}g_n$

## 计算方式

而 $g_n$ 可以用递归在 $O(n)$ 之内算出，算出 $g_n$ 就可以得到 $f_{n,1}$，也就可以接着用状态转移方程算出 $f_{n,m}$。

另外由于计算 $f_{n,m},(m \ne 1)$ 时调用了 $f_{n-1,m-1}$，所以最后需要从 $f_{2,m}$ 一直算到   $f_{1000,m}$，边界是 $f_{1,1}=1$。(注意：刚刚这两段所说的 $m$ 表示范围里面的所有数)

然后输出 $f_{n,m}$ 即可。总复杂度 $O(n^2)$，能过。

# AC代码

```cpp
#include<bits/stdc++.h>
#define d double
using namespace std;
int m,n,i,j,k;d f[1145][1145];
d ans(int x,d y)
{
	if(x==1)
	{
		if(y!=1.0)
		{
			return 0.0;
		}
		return (ans(i,1/2.0)+1/6.0)*1/(1-pow(0.5,i));
	}
	return (f[i-1][x-1]/3.0+ans(x-1,y/2.0))/2.0;
}
int main()
{
	cin>>n>>m;f[1][1]=1.0;
	for(i=2;i<=1000;i++)
	{
		f[i][1]=ans(1,1.0);
		for(j=2;j<=i;j++)
		{
			f[i][j]=f[i-1][j-1]/3.0+f[i][j-1]/2.0;
		}
	}
	printf("%.9f",f[n][m]);
	return 0;
}
```

---

## 作者：sinsop90 (赞：1)

不是很懂，为什么题解都是什么消元什么的。

考虑设 $f_{i, j}$ 表示还剩 $i$ 个人, 第 $j$ 个人赢的机会。

显然有:

$f_{i, j} = \frac{1}{2}f_{i, j-1}+\frac{1}{3}f_{i-1,j-1}(j \ne 1)$

$f_{i, j} = \frac{1}{2}f_{i, i}+\frac{1}{6}(j=1)$

转移成环，考虑固定 $f_{i, 1}$ 的值，求得 $f_{i, i}$ 的值再通过第二个算式算出 $f_{1, 1}$。

存在一个值使得最后算出来的 $f_{i, 1}$ 与固定的 $f_{i, 1}$ 相等，二分该值即可。

```
#include <bits/stdc++.h>
using namespace std;
const int maxn = 1005;
const long double eps = 1e-10;
int n, m;
long double g[maxn], f[maxn][maxn];
int main() {
	scanf("%d%d", &n, &m);
	f[1][1] = 1;
	for(int i = 2;i <= n;i++) {
		double l = 0, r = 1;
		while(r - l > eps) {
			double mid = (l + r) / 2;
			g[1] = mid;
			for(int j = 2;j <= i;j++) g[j] = g[j - 1] / 2 + f[i - 1][j - 1] / 3;
			if(g[1] > g[i] / 2 + 1. / 6) r = mid;
			else l = mid;
		}
		f[i][1] = l;
		for(int j = 2;j <= i;j++) f[i][j] = f[i][j - 1] / 2 + f[i - 1][j - 1] / 3;
	}
	printf("%.9Lf\n", f[n][m]);
}
```


---

## 作者：JustinRochester (赞：1)

想了一个更一般性的解法

[传送门](https://www.luogu.com.cn/problem/P1409)

---

**【分析】**
--

不难得出方程，令 $f_{n, m}$ 表示共 $n$ 个人，第 $m$ 个人获胜的概率

则 $f_{n, m}=\begin{cases}
{1\over 2}f_{n, m-1}+{1\over 3}f_{n-1, m-1}&m>1
\\\\
{1\over 2}f_{n, n}+{1\over 6}&n>1\wedge m=1
\\\\
1&n=1
\end{cases}$

那么考虑 $f_{n-1, 1}\sim f_{n-1,n-1}$ 已经计算得出，现在要转移 $f_{n, 1}\sim f_{n, n}$

但由于 $f_{n, 1}$ 的递推式中含有 $f_{n, n}$，无法朴素递推。一般这类构成一堆等式的问题需要高斯消元求解，但总复杂度 $O(n)\cdot O(n^3)=O(n^4)$ 显然是不可能的

但有一个很显然的事情是，如果已知 $f_{n, n}$ ，则可推出 $f_{n, 1}$ ，而后递推算出 $f_{n, 2}\sim f_{n, n-1}$

那么这样就可以二分一个 $f_{n, n}$ 然后递推回 $f_{n, n}$ ，再检查是否符合。这样的话复杂度是 $O(n^2\log \varepsilon)$ 的，但无法解决模意义下的问题。

---

考虑类似拓域的做法（实际上不是拓域），往实数域 $<R, +, *>$ 中再引入一个域 $f_{n, n}\cdot R$

> 看不懂的，可以理解为像复数一样，再添一维

那我们可以用二元组 $\left<a, b\right>=a+b\cdot f_{n, n}$ 来描述这个“域”中的每一个元素

则这个域的运算，有

$\begin{aligned}
\left<a, b\right>+c&=&\left<a+c, b\right>
\\\\\left<a,b\right>\cdot c&=&\left<a\cdot c,b\cdot c\right>
\end{aligned}$

> 其他的不重要，就不写了

那我们可以初始化 $f_{n, 1}=\left<{1\over 6}, {1\over 2}\right>$

然后直接 $O(n)$ 递推到 $f_{n, n}=\left<a,b\right>$

又有 $f_{n, n}=\left<a,b\right>=a+b\cdot f_{n, n}$

所以解方程得 $f_{n, n}={a\over 1-b}$

接下来就可以求出 $f_{n, 1}$ ，再 $O(n)$ 递推出 $f_{n, 2}\sim f_{n, n-1}$

总复杂度优化为 $O(n^2)$

如果题目是模意义下的，这个方法显然也是适用的

---

**【代码】**
---

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<ll, ll> pii;
typedef double db;
typedef pair<db, db> pdd;
#define fi first
#define se second

inline pdd operator / (const pdd &a, db b) { return pdd(a.fi/b, a.se/b); }
inline pdd operator + (const pdd &a, db b) { return pdd(a.fi+b, a.se); }

const int MAXN=1024;
db f[MAXN][MAXN];
inline void init() {
	f[1][1]=1;
	for(int n=2; n<=1000; ++n) {
		pdd p(1.0/6, 1.0/2);
		for(int m=2; m<=n; ++m)
			p=p/2+f[n-1][m-1]/3;
		f[n][n]=p.fi/(1-p.se);
		f[n][1]=1.0/6+f[n][n]/2;
		for(int m=2; m<=n; ++m)
			f[n][m]=f[n][m-1]/2+f[n-1][m-1]/3;
	}
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
	init();
	int n, m;
	cin>>n>>m;
	cout<<fixed<<setprecision(9)<<f[n][m];
    cout.flush();
    return 0;
}
```

---

**【拓展】**
--

对于像 $f_{n, n}$ 这样要预先确定的项，我们假定为预先项

对于这类问题，当预先项数量为 $k$ 时

如果对于每个预先项进行二分，则复杂度为 $O(n\cdot \log^k\varepsilon)$

如果采用该方法，可以“拓域”的时候拓 $k$ 维，这样的转移是 $O(kn)$ 的，最后对预先项进行高斯消元 $O(k^3)$ ，总复杂度为 $O(kn+k^3)$

可以发现，当 $k$ 较小时（比如 $k=1,2,3$），这个方法是很优秀的，几乎是 $O(n)$ 的

---

## 作者：Hilaria (赞：0)

### 题意

有 $n$ 个人排成一排，你排在第 $m$ 个。

每轮队首的人投一次骰子。

1.每次投骰子有 $\dfrac{1}{6}$ 的概率，队首的人获胜。

2.每次投骰子有 $\dfrac{1}{2}$ 的概率，队首的人排到队尾。

3.每次投骰子有 $\dfrac{1}{3}$ 的概率，队首的人出队。

若队列中仅剩一人，则该人获胜，求你获胜的概率。

### 思路

这个题看起来就很像个 dp，所以我们定义一个二维数组 $f[i][j]$。

意思是一共有 $i$ 个人，你排在第 $j$ 个时赢的概率是多少。

那么我们分类讨论一波，对于 $f[i][j]$ 我们有（$f[i][1]$ 我们特殊讨论）。

+ 有 $\dfrac{1}{6}$ 的概率，队首的人投中第一种情况，那么对手的人获胜，但我们讨论赢的情况，所以这种情况不算在内（$f[i][1]$ 我们特殊讨论）。

+ 有 $\dfrac{1}{2}$ 的概率，队首的人投中第二种情况，那么队首的人排到队尾，那么就转换到 $f[i][j-1]$。

+ 有 $\dfrac{1}{3}$ 的概率，队首的人投中第三种情况，那么队首出列，那么就转换到 $f[i-1][j-1]$。

所以转换方程为：

$$f[i][j]=\dfrac{1}{2}\times f[i][j-1]+\dfrac{1}{3}\times f[i-1][j-1]$$

对于 $f[i][1]$ 的话就好搞很多：

因为你现在在队首，你有 $\dfrac{1}{6}$ 的概率直接赢，有 $\dfrac{1}{2}$ 的概率去队尾。

（那 $\dfrac{1}{3}$ 的概率输就不管了哈，你算赢的概率，输的概率你算个啥）。

$$f[i][1]=\dfrac{1}{6}+\dfrac{1}{2}\times f[i][i]$$

啊这，怎么又绕回 $f[i][i]$ 了啊，这似乎不太对啊。

行吧，那我们把它们写出来。

就拿 $f[3][1]$ 到 $f[3][3]$ 来说。

$$f[3][1]=\dfrac{1}{6}+\dfrac{1}{2}\times f[3][3]$$

$$f[3][2]=\dfrac{1}{2}\times f[3][1]+\dfrac{1}{3}\times f[2][1]$$

$$f[3][3]=\dfrac{1}{2}\times f[3][2]+\dfrac{1}{3}\times f[2][2]$$

这不多元一次方程组。

那我们只需要把 $f[3][3]$ 推出来，然后 $f[3][1]$ 到 $f[3][2]$ 就可以按普通 dp 来算了。

于是我开始暴力拆解，我们的 $f[3][3]$ 就变成了酱紫：

$$f[3][3]=\dfrac{1}{2^2}\times\dfrac{1}{6}+\dfrac{1}{2^3}\times f[3][3]+\dfrac{1}{2^0}\times\dfrac{1}{3}\times f[2][2]+\dfrac{1}{2^1}\times\dfrac{1}{3}\times f[2][1]$$

所以总结一下就是：

$$f[i][i]=\dfrac{1}{2^{i-1}}\times\dfrac{1}{6}+\dfrac{1}{2^i}\times f[i][i]+\sum\limits_{a=0}^{i-2}\sum\limits_{b=i-1}^{1}\dfrac{1}{2^a}\times\dfrac{1}{3}\times f[i-1][b]$$

所以最终的柿子就是：

$$f[i][i]=\dfrac{2^j}{2^j-1}\times(\dfrac{1}{2^{i-1}}\times\dfrac{1}{6}+\sum\limits_{a=0}^{i-2}\sum\limits_{b=i-1}^{1}\dfrac{1}{2^a}\times\dfrac{1}{3}\times f[i-1][b])$$

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

const int MAXX=1e3+10;

int n,m;
double f[MAXX][MAXX];
int main()
{
	scanf("%d%d",&n,&m);
	f[1][1]=1.0;
	for(int i=2;i<=n;i++)
	{
		double tmp1=(double)1/6;
		double tmp2=(double)1;
		double tmp3=0.0;
		for(int j=1;j<i;j++) tmp1*=(double)1/2;
		for(int j=i-1;j>=1;j--)
		{
			tmp3+=(double)1/3*f[i-1][j]*tmp2;
			tmp2*=(double)1/2;
		}
		f[i][i]=tmp1+tmp3;
		double qwq=1;
		for(int j=1;j<=i;j++) qwq*=2;
		f[i][i]*=(double)qwq/(qwq-1);
		f[i][1]=(double)1/6+(double)1/2*f[i][i];
		for(int j=2;j<i;j++)
		{
			f[i][j]=(double)1/2*f[i][j-1]+(double)1/3*f[i-1][j-1];
		}
	}
	printf("%.9lf",f[n][m]);

	return 0;
}
```


---

## 作者：Genius_Star (赞：0)

### 题目大意：

$n$ 个人排成一排，你排在第 $m$ 个。

每轮队首的人投一次骰子。

- 若掷到 $1$，则队首的人获胜。
- 若掷到 $2,4,6$，则队首的人排到队尾。
- 若掷到 $3,5$，则队首的人出队。

若队列中仅剩一人，则该人获胜，求你获胜的概率。
### 思路：
考虑到 DP 倒是不难，但是我们推的时候会发现，状态相互依赖了，不是一个 DAG。

我们来推导一下式子。

假设我们求得是 $f[n][x]$。

若 $x\geq1$， 则 $f[n][x] = \frac{1}{2}\times f[n][x-1] + \frac{1}{3} \times f[n-1][x-1]$。

若 $x=1$，则 $f[n][1] = \frac{1}{2}\times f[n][n] + \frac{1}{6}$。

但此时，我们可以注意一下其正好构成一个循环。

我们可以循环带入解方程，算出 $f[n][n]$，再求出 $f[n][1]$，接下来再递推 $f[n][x](x>1)$。
### 代码：
```cpp
#include<bits/stdc++.h>
#define ios ios::sync_with_stdio(false); cin.tie(0), cout.tie(0)
using namespace std;

const int N = 1010;

double f[N][N];

int main()
{
    ios;
    int n,m;
    cin>>n>>m;
    f[1][1] = 1;
    for(int i=2;i<=n;i++)
    {
        double a = 1.0/2,b = 1.0/6;
        for(int j=2;j<=i;j++)
        {
            a/=2;
            b = b/2 + f[i-1][j-1]/3;
        }
        f[i][i] = b/(1-a);
        f[i][1] = f[i][i]/2 + 1.0/6;
        for(int j=2;j<=i;j++)
        {
            f[i][j] = f[i][j-1]/2 + f[i-1][j-1]/3;
        }
    }
    cout<<fixed<<setprecision(9)<<f[n][m]<<'\n';
    return 0;
}

```

---

## 作者：Zwb0106 (赞：0)

**[原题链接](https://www.luogu.com.cn/problem/P1409)**

------------
一眼概率 DP，但是转移成环，来点好玩的推式子做法。

------------
## 思路

记 $i$ 个人排成一列，第 $j$ 个人获胜的概率为 $f_{i,j}$，显然有 $1\le j\le i$，$f_{1,1}=1$。

考虑扔骰子造成的三种情况：

1. 有 $\frac{1}{2}$ 的概率使当前队首变为队尾；
2. 有 $\frac{1}{3}$ 的概率使当前队首出队；
3. 有 $\frac{1}{6}$ 的概率使当前队首直接获胜。

那么 $f_{i,j}$ 的转移需要分为 $i=j=1$，$i>j=1$ 和 $i\ge j>1$ 三类，具体如下：

$$f_{i,j}=\begin{cases}1 & i=j=1
 \\ \frac{1}{2}f_{i,i}+\frac{1}{6} & i>j=1
 \\ \frac{1}{2}f_{i,j-1}+\frac{1}{3}f_{i-1,j-1} & i\ge j>1
\end{cases}$$

然后发现这个式子出现转移成环的情况，第一反应是高斯消元，然而时间复杂度不能接受。

观察后两种情况，容易发现，只要求出 $f_{i,i}$ 的值，就可以 $O(n)$ 地递推，我们尝试在线性时间内求出这个值。

不妨假设 $f_{i,i}$ 的值已知，那么每一项都可以表示为 $a f_{i,i}+b$ 的形式，用这种方式将 $f_{i,1},f_{i,2},\dots,f_{i,i}$ 表示出来（其实是在消元）：

$$\begin{cases} f_{i,1}= \frac{1}{2}f_{i,i}+ \frac{1}{6}
 \\ f_{i,2}= \frac{1}{2^2}f_{i,i}+ \frac{1}{2} \cdot \frac{1}{6}+ \frac{1}{3}f_{i-1,1}
 \\ \cdots
 \\ f_{i,i}= \frac{1}{2^i}+ \frac{1}{3}(\frac{1}{2^i}+ \sum \limits_{j=1}^{i-1} \frac{ f_{i-1,j} } { 2^{i-j-1} })
\end{cases}$$

这样代入消元的方式使得 $f_{i,i}$ 的值只与之前已求出的状态有关，预处理 $\{ \frac{1}{2^n} \}$，即可线性地求出。而 $f_{i,1},f_{i,2},\dots,f_{i,i-1}$ 是容易求出的。

时间复杂度 $O(n^2)$。

------------
## 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define db double
#define ldb long double
#define gc getchar
#define pc putchar
#define lowbit(x) (x&-x)
#define mp make_pair
#define fs first
#define sc second
using namespace std;
const int N=1005;
int n,m;
db f[N][N],p2[N];
ll read()
{
	ll x=0,f=1;
	char ch=gc();
	while(ch<'0'||ch>'9'){
		if(ch=='-')f=-1;
		ch=gc();
	}
	while(ch>='0'&&ch<='9'){
		x=x*10+(ch^48),ch=gc();
	}
	return x*f;
}
void print(ll x)
{
	if(x<0)pc('-'),x=-x;
	if(x>9)print(x/10);
	pc(x%10+48);
}
int main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	
	n=read(),m=read();
	f[1][1]=1,p2[0]=1;
	for(int i=1;i<=n;i++)p2[i]=p2[i-1]/2;
	for(int i=2;i<=n;i++)
	{
		f[i][i]=p2[i];
		for(int j=1;j<i;j++)
		    f[i][i]+=f[i-1][j]*p2[i-j-1];
		f[i][i]=f[i][i]/3/(1-p2[i]);
		f[i][1]=f[i][i]/2.0+1.0/6;
		for(int j=2;j<i;j++)
		    f[i][j]=f[i][j-1]/2+f[i-1][j-1]/3;
	}
	printf("%.9lf",f[n][m]);
	return 0;
}
```

---


# 失落的成绩单

## 题目背景

谁都知道，录成绩是件麻烦事，可 MC 却把成绩单丢了……


## 题目描述

这一天老师要查第 $m$ 个同学的成绩，为了不挨批，MC努力回想，想起成绩单上的一个规律：

若把成绩看作是一个实数数列，则 $A_i=\dfrac{(A_{i-1})-(A_{i+1})}{2}+d$，（就是每一项为其前后两项之差除以 $2$ 再加 $d$）。此时，我告诉了 MC 一共 $n$ 项的数列首项 $A_1$ 和末项 $A_n$，以及 $d$。剩下的靠你了！


## 说明/提示

$1\le n\le 60$，$0\le m\le n$，$|d|,|A_1|,|A_n|<10^4$

## 样例 #1

### 输入

```
53 23
0.543 1.213 9768.134
```

### 输出

```
0.543```

# 题解

## 作者：常青藤 (赞：35)

~~前言：安利一发自己的[博客](https://www.cnblogs.com/ezsyshx/p/10449623.html)（LaTeX挂了这边走）~~（正在迁移）

UPD:发现$LaTeX$有部分不能正常显示，~~在洛谷博客里还好好的~~，试着调了一下，并删除了一些可有可无的话，求通过

题目描述：
> 数列 $a$ 满足
$$A_i=\frac{A_{i-1}-A_{i+1}}{2}+d$$
> 给出：首项 $A_1$、末项 $A_n$、$d$、$m$，求$A_m$

算法分析：

矩阵快速幂？~~还没学~~，所以我们就用数(mo)学(fa)来解决这道题。

预备知识：特征方程

-----

我们以这个式子为例—— $f_i=f_{i-1}+6f_{i-2}$

首先我们来看两个数集

$A=\{x\mid x=(-2)^k,k\in\mathbb{N^*}\}\ ,\ B=\{x\mid x=3^k,k\in\mathbb{N^*}\}$

那么，我们可以列出 $A$ 的前几项：$-2,4,-8,16,...$，$B$ 的前几项：$3,9,27,81,...$

将 $A$ 代入递推式，神奇的发现——

$f_1=-2$

$f_2=4$

$f_3=4+6\times(-2)=-8$

$f_4=-8+6\times4=16$

$......$

$A$ 中的数都满足上述的递推式，同样的，$B$ 也满足。

很明显，$f_i=(-2)^k$ 和 $f_i=3^k$ 都是上述递推式的**通项公式**

下面我们来看两个引理——

> 1、若 $f_i=a^i$ 是某一递推式的通项公式，那么，$f_i=\lambda a^i$ 同样满足递推式（两边同乘上系数即可）

> 2、若 $f_i=a^i$ 和 $f_i=b^i$ 都满足递推式，那么，$f_i=\alpha\times a^i+\beta\times b^i$ 同样满足（两式乘上系数相加即可）

接下来，我们来看一个经典的例子——斐波拉契数列 $f_i=f_{i-1}+f_{i-2}$

现在我们不能像刚才那个式子“观察”出一个通解了，那么就需要我们自己进行构造

现在我们设存在一组等比数列满足这个递推式，其公比为 $q$ ，那么我们看一下这个式子——

$$f_i=f_{i-1}+f_{i-2}$$

$$q^2\times f_{i-2}=q\times f_{i-2}+f_{i-2}$$

$$q^2=q+1$$

$$q^2-q-1=0$$

这就是斐波拉契数列的**特征方程**

（当然，这个是比较容易理解的解释，详细说明：
[特征方程](https://baike.baidu.com/link?url=FFx3c3daptyvLOFdsZpkiiAh9lR4UmULMkB8LnslGBH1QshZxqnRD6VN675it7fMFnAyikI57TCzL7vqY0WgS2VEQtwpUDrr6iuS2bdQByVE8-UsHTBxQALE7uTrFFUL))

把它解出来，可以得到—— $q_1=\frac{\sqrt5+1}{2},q_2=\frac{-\sqrt5+1}{2}$

那么，我们就知道了——公比为$\frac{\pm\sqrt5+1}{2}$的等比数列满足斐波拉契数列

那么，我们又知道了数列的前两项：$f_1=f_2=1$

我们设 $f_i=\alpha\times(\frac{\sqrt5+1}{2})^i+\beta\times(\frac{-\sqrt5+1}{2})^i$，代入$f_1,f_2$

则——

$$\begin{cases}
\alpha(\frac{\sqrt5+1}{2})+\beta(\frac{-\sqrt5+1}{2})=f_1=1\\\\
\alpha(\frac{\sqrt5+1}{2})^2+\beta(\frac{-\sqrt5+1}{2})^2=f_2=1\\
\end{cases}
$$

得 $\alpha=\frac{\sqrt5}{5},\beta=-\frac{\sqrt5}{5}$，这样，我们就求出了通项公式

回到之前的递推数列——$f_i=f_{i-1}+6f_{i-2}$，怎么得出其通解的？

其实很简单。我们设等比数列公比为 $q$，就可以得到特征方程—— $q^2-q-6=0 \Rightarrow q_1=-2,q_2=3$

-----

进入正题，首先来膜改一下式子：
$$A_i=\frac{A_{i-1}-A_{i+1}}{2}+d$$
$$2A_i=A_{i-1}-A_{i+1}+2d$$
$$A_{i+1}=-2A_{i}+A_{i-1}+2d$$
这是 $A$ 的递推式，我们将 $i$ 减 $1$：
$$A_{i}=-2A_{i-1}+A_{i-2}+2d$$
现在我们得出了答案 —— $A_{i}=-2A_{i-1}+A_{i-2}+2d$

那么我们先将 $2d$ 放在一边，设数列 $a$ 满足 $a_{i}=-2a_{i-1}+a_{i-2}$
设此数列公比为 $q$，现在代入——
$$q^2a_{i-2}=-2qa_{i-2}+a_{i-2}$$
$$q^2+2q-1=0$$
这就是上述递推式的**特征方程**
现在解一下这个方程，可以得到—— $q_1=-\sqrt{2}-1,q_2=\sqrt{2}-1$

那么我们就可以得到这个数列的通项公式——
$$a_i=\alpha(-\sqrt{2}-1)^i+\beta(\sqrt{2}-1)^i$$
其中 $i\leq n$，并且
$$\begin{cases}
\alpha(-\sqrt{2}-1)+\beta(\sqrt{2}-1)=a_1\\
\alpha(-\sqrt{2}-1)^n+\beta(\sqrt{2}-1)^n=a_n\\
\end{cases}
$$
将上面的方程解出来，我们可以得到——
$$\begin{cases}
\alpha=\frac{a_1(\sqrt{2}-1)^{n-1}-a_n}{(-\sqrt{2}-1)(\sqrt{2}-1)^{n-1}-(-\sqrt{2}-1)^n}\\
\\
\beta=\frac{a_1(-\sqrt{2}-1)^{n-1}-a_n}{(\sqrt{2}-1)(-\sqrt{2}-1)^{n-1}-(\sqrt{2}-1)^n}\\
\end{cases}
$$
代入通项公式并整理——
$$a_m=\frac{a_n[(\sqrt{2}-1)^{m-1}-(-1)^{m-1}(\sqrt{2}+1)^{m-1}]+(-1)^{m-1}a_1[(\sqrt{2}-1)^{n-m}-(-\sqrt{2}-1)^{n-m}]}{(\sqrt{2}-1)^{n-1}-(-1)^{n-1}(\sqrt{2}+1)^{n-1}}$$
设$f(x)=(\sqrt2-1)^x-(-1)^x(\sqrt2+1)^x$，可得
$$a_m=\frac{a_n\times f(m-1)+(-1)^{m-1}a_1\times f(n-m)}{f(n-1)}$$
好了，现在是最后一个问题——还有$d$呢！

观察递推式—— $A_i=-2A_{i-1}+A_{i-2}+2d$

我们设 $A_i=a_i+p\times d$，代入——

$$A_i=-2A_{i-1}+A_{i-2}+2d$$
$$a_i+pd=-2a_{i-1}-2pd+a_{i-2}+pd+2d$$
我们又有 $a_{i}=-2a_{i-1}+a_{i-2}$，那么两边约去，可得——
$$pd=-2pd+pd+2d \Rightarrow p=1$$
故 $A_i=a_i+d$
那么，根据题意，我们来膜改一下式子——
$$A_m=\frac{(A_n-d)\times f(m-1)+(-1)^{m-1}(A_1-d)\times f(n-m)}{f(n-1)}+d$$
这样，我们就得到了数列的通项公式，代码就很好写了~~（没用龟(kuai)速幂，数据太弱QwQ）~~

-----
```cpp
#include<bits/stdc++.h>
using namespace std;
const double p=sqrt(2)-1;
int n,m; double d,a1,an;
double c(int op) {return (op&1)?-1:1;}
double f(int x) {return pow(p,x)-c(x)*pow(p+2,x);}
int main()
{
    scanf("%d%d%lf%lf%lf",&n,&m,&d,&a1,&an);
    if(m==0) printf("0.000");
    else printf("%.3lf",((an-d)*f(m-1)+c(m-1)*(a1-d)*f(n-m))/f(n-1)+d);
    return 0;
}
```
#### 完结撒花QwQ

---

## 作者：RiverHamster (赞：16)

这题真的有楼下那些大佬们讲的那么复杂吗？来一个二分的题解。

首先现根据题目里的
$$a_i = {(a_{i-1} + a_{i+1}) \over 2} + d$$

用一点小学数学知识变换一下，得到
$$a_{i+1} = {a_{i-1} - 2(a_i - d)}$$

把下标减$1$，得到递推式
$$a_i = a_{i-2} - 2(a_{i-1} - d)$$

然后我们分析$a_n$与$a_2$的关系

我们先观察$a_3 = a_1 - 2(a_2 - d)$，$a_2$前面是负号，显然$a_2$越大，$a_3$越小。

同理$a_3$越大，$a_4$越小。所以$a_2$越大，$a_4$越大。

结论就很~~显然~~了，$a_2$越大奇数项（不要管$a_1$）越小，偶数项（不要管$a_0$）越大。

然后呢？

我们**二分**$a_2$，因为上面已经说明了每一项与$a_2$的大小关系，就有了**单调性**，用$a_2$的值递推出$a_n$，然后**判断**。

贴代码：（时间复杂度$O(n log n)$）
```cpp
#include <cstdio>
const double eps = 1e-12; //我<del>不</del>感觉这题卡精度啊
double d, a[100], an; //an表示给定的a[n]的值
int n, m; //总的项数和要求的一项

bool check(){ //判断是否a[n] >= an
	for(int i=3; i<=n; i++)
		a[i] = a[i-2] - 2 * (a[i-1] - d); //根据递推式计算
	return a[n] >= an;
}

int main(){
	scanf("%d%d", &n, &m);
	scanf("%lf%lf%lf", &d, &a[1], &an);
	double l = -1e12, r = 1e12;
	while(r - l > eps){
		a[2] = (l + r) / 2; //二分a[2]的值
		if(check())
			if(n & 1) l = a[2]; //根据n的奇偶性分类
			else      r = a[2]; //偶数项和a[2]是一样的大小变化关系
		else
			if(n & 1) r = a[2]; //奇数项和a[2]相反
			else      l = a[2];
	}
	printf("%.3lf\n", a[m]);
	return 0;
}
```

---

## 作者：封癫 (赞：8)

我就很好奇为什么这个题没人套高斯消元模板，这题长得多像高斯消元啊qwq


移项可以得到a[i]+a[i+1]/2-a[i-1]/2=d，这岂不就是高斯消元的式子qwq


构造出矩阵之后直接套上模板跑一遍就好啦


```cpp
#include<cstdio>
#include<cstring>
#include<cctype>
#include<algorithm>
#include<cstdio>
#include<cmath>
#define maxn 100
using namespace std;

inline long long read(){
    long long num=0,f=1;
    char ch=getchar();
    while(!isdigit(ch)){
        if(ch=='-')    f=-1;
        ch=getchar();
    }
    while(isdigit(ch)){
        num=num*10+ch-'0';
        ch=getchar();
    }
    return num*f;
}

double s[maxn][maxn];
double ans[maxn];
int main(){
    int n=read(),m=read();
    double d,a1,an;
    scanf("%lf%lf%lf",&d,&a1,&an);
    s[1][1]=1;s[1][n+1]=a1;
    s[n][n]=1;s[n][n+1]=an;
    for(int i=2;i<n;++i){
        s[i][i]=1;
        s[i][i-1]=-0.5;
        s[i][i+1]=0.5;
        s[i][n+1]=d;
    }
    for(int i=1;i<=n;++i){
        int now=i;
        for(int j=i+1;j<=n;++j)
            if(fabs(s[j][i])>fabs(s[now][i]))    now=j;
        if(now!=i)    swap(s[now],s[i]);
        for(int j=i+1;j<=n;++j){
            double ret=s[j][i]/s[i][i];
            for(int k=i;k<=n+1;++k)    s[j][k]-=s[i][k]*ret;
        }
    }
    ans[n]=an;    ans[1]=a1;
    for(int i=n-1;i>1;--i){
        double now=0;
        for(int j=i+1;j<=n;++j)    now+=ans[j]*s[i][j];
        ans[i]=(s[i][n+1]-now)/s[i][i];
    }
    printf("%.3lf",ans[m]);
    return 0;
}

```

---

## 作者：一只小兔子 (赞：5)

~~题目难度吓人~~

根据题意：

$A_i = \frac{A_{i-1} - A_{i+1}}{2} + d$

所以，经初等变换后：

$A_{i+1} = -2 * A_i + A_{i-1} + 2d$

设$A_2 = x$：

$A_1 = 0 * x + a_1$

$A_2 = 1 * x + 0$

$A_3 = -2 * A_2 + A_1 + 2d = -2 * x + (a_1 + 2d)$

$A_4 = -2 * A_3 + A_2 + 2d = 5 * x + (-2 * a_1 - 2d)$

......

$A_{i+1} = -2 * A_i + A_{i-1} + 2d$

......

$A_n = -2 * A_{n-1} + A_{n-2} + 2d$

只需要记录$A_i$的$x$系数和常数项，我们会得到一个**一元一次方程**：

$A_n = coefficient_n * x + constant_n$

即：

$x = A_2 = \frac{a_n - constant_n}{coefficient_n}$

再推一遍或直接回代可得到所有值。

时空复杂度：$O(n)$

~~高斯消元？特征方程？long double？统统不需要！~~

代码：
```c
#include<stdio.h>
int main(){
	int n,m;double a[66],d,lin[66],cst[66],x;
	//lin as linear, cst as constant
	scanf("%d%d",&n,&m);
	scanf("%lf%lf%lf",&d,&a[1],&a[n]);
	lin[1]=0;cst[1]=a[1];
	lin[2]=1;cst[2]=0;
	for(int i=3;i<=n;++i){
		lin[i]=-2*lin[i-1]+lin[i-2];
		cst[i]=-2*cst[i-1]+cst[i-2]+2*d;
	}
	x=(a[n]-cst[n])/lin[n];
	for(int i=2;i< n;++i){
		a[i]=lin[i]*x+cst[i];
	}
	printf("%.3lf\n",a[m]);
}
```

---

## 作者：Otue (赞：4)

**这里介绍跟大家不一样的方法：二分。**

题目给出了第 $1$ 项,第 $N$ 项, $d$ ,以及递推公式 $A_i=\dfrac {A_{i-1}-A_{i+1}}  2+d$,

把地推公式变形得：

$A_{i+1}=A_{i-1}-(A_i-d)\times 2$

$=A_{i-1}-2\times A_i+2\times d$

这是一个相邻 3 项的递推式。

题目给出了第一项，如果我们知道第二项，就可以根据递推式计算出后续每一项的值。

但我们并不知道第二项的值，怎么办呢？

我们用如下的程序去观察这个数列的规律。

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1005];
int n,d;
int main(){
	cin>>n>>d>>a[1];
	do{
		cin>>a[2];
		if(a[2]==0){
			break;
		}
		cout<<a[1]<<' '<<a[2]<<' ';
		for(int i=3;i<=n;i++){
			a[i]=a[i-2]+2*d-2*a[i-1];
			cout<<a[i]<<' ';
		}
		cout<<endl;
	}while(1);
}
```
### 发现的规律
![](https://cdn.luogu.com.cn/upload/image_hosting/ls9efuph.png?x-oss-process=image/resize,m_lfit,h_1170,w_2225)

这是一个元素的值一正一负的摇摆数列。但明显的，数列元素的绝对值越来越大。这就为二分创造了条件。

观察上面的式子。对于 $d=1$ , $a[1]=1$ ,当 $a[2]$ 的绝对值越大，生成的序列也越大。

### 摇摆序列
对于摇摆序列，在计算出第 $n$ 项与给出的第 $n$ 项的值的大小比较时，要去别是正数比大小还是负数比大小。

这时，数列的项数就决定了第 $n$ 项是正是负。

如果为正数，计算出来的第 $n$ 项大了，说明应该减小 $a[2]$ 的值。

如果是负数，计算出来的值的第 $n$ 项大了，说明应该增大 $a[2]$.

### 代码：
```cpp
#include<bits/stdc++.h> 
using namespace std;
double a[105],d,an;
double EPS=1e-11;
int n,m;
bool check(){
	for(int i=3;i<=n;i++){
		a[i]=a[i-2]-2*(a[i-1]-d);
	}
	if(a[n]>an){
		return 1;
	}
	return 0;
}
int main(){
	cin>>n>>m;
	cin>>d>>a[1]>>an;
	double lo=-1e11;
	double ri=1e11;
	while(ri-lo>EPS){
		a[2]=(ri+lo)/2;
		if(check()==1){
			if(n%2==1){
				lo=a[2];
			}
			else{
				ri=a[2];
			}
		}
		else{
			if(n%2==1){
				ri=a[2];
			}
			else{
				lo=a[2];
			}
		}
	}
	cout<<fixed<<setprecision(3)<<a[m]<<endl;
}
```

---

## 作者：qwaszx (赞：3)

qwq没人写一个解递推方程的题解么

我们把

![](http://latex.codecogs.com/gif.latex?r%5E%7Bk%7D-c_%7B1%7Dr%5E%7Bk-1%7D-c_%7B2%7Dr%5E%7Bk-2%7D-...-c_%7Bk-1%7Dr-c_%7Bk%7D),其中ci为常数

叫做**常系数k阶线性齐次递推关系**

![](http://latex.codecogs.com/gif.latex?a_%7Bn%7D%3Dc_%7B1%7Da_%7Bn-1%7D&plus;c_%7B2%7Da_%7Bn-2%7D&plus;...&plus;c_%7Bk%7Dr_%7Bn-k%7D)

的**特征方程**

两个定理（~~建议跳过因为~~很复杂）:

定理1:若上述递推式的特征方程有t个互不相等的根![](http://latex.codecogs.com/gif.latex?r_%7B1%7D%2Cr_%7B2%7D%2C...r_%7Bt%7D%2C)其重数(即该根的出现次数，比如![](http://latex.codecogs.com/gif.latex?%28a-1%29%5E2%3D0)有a=1的二重根)分别为m1,m2...mt,满足mi>=1,![](http://latex.codecogs.com/gif.latex?%5Csum_%7Bi%3D1%7D%5E%7Bt%7Dm_i%3Dk),那

么其解为

其中![](http://latex.codecogs.com/gif.latex?%5Calpha%20_%7Bij%7D)可以由初始条件解一次方程组得到

![](http://latex.codecogs.com/gif.latex?a_n%3D%5Csum_%7Bi%3D1%7D%5E%7Bt%7Dr_%7Bi%7D%5E%7Bn%7D%5Csum_%7Bj%3D0%7D%5E%7Bm_%7Bi%7D-1%7D%5Calpha_%7Bij%7Dn%5E%7Bj%7D)

我们把

![](http://latex.codecogs.com/gif.latex?a_%7Bn%7D%3DF%28n%29&plus;%5Csum_%7Bi%3D1%7D%5E%7Bk%7Dc_%7Bi%7Da_%7Bn-i%7D)叫做**常系数线性非齐次递推关系**，F(n)是关于n的非0函数

这时递推关系![](http://latex.codecogs.com/gif.latex?a_%7Bn%7D%3D%5Csum_%7Bi%3D1%7D%5E%7Bk%7Dc_%7Bi%7Da_%7Bn-i%7D)叫做**相伴的齐次递推关系**

定理2:一个常系数线性非齐次递推关系的解是一个特解和相伴的线性齐次递推关

系的一个解的和，即

如果![](http://latex.codecogs.com/gif.latex?%5Cleft%20%5C%7B%20a_%7Bn%7D%5E%7B%28p%29%7D%20%5Cright%20%5C%7D)是上述递推关系的一个特解，那么每个解都是![](http://latex.codecogs.com/gif.latex?%5Cleft%20%5C%7B%20a_%7Bn%7D%5E%7B%28p%29%7D&plus;a_%7Bn%7D%5E%7B%28h%29%7D%20%5Cright%20%5C%7D)的形式，其中

![](http://latex.codecogs.com/gif.latex?%5Cleft%20%5C%7B%20a_%7Bn%7D%5E%7B%28h%29%7D%20%5Cright%20%5C%7D)是其相伴的齐次递推关系的一个解

假设![](http://latex.codecogs.com/gif.latex?%7B%5Cleft%20%5C%7B%20a_%7Bn%7D%7D%20%5Cright%20%5C%7D)满足上述线性非齐次递推关系，且![](http://latex.codecogs.com/gif.latex?F%28n%29%3Ds%5E%7Bn%7D%5Csum_%7Bi%3D0%7D%5E%7Bt%7Db_%7Bi%7Dn%5E%7Bi%7D),其中bi和s是常数.当

s不是相伴的递推关系的特征方程的根时，存在一个形如![](http://latex.codecogs.com/gif.latex?s%5E%7Bn%7D%5Csum_%7Bi%3D0%7D%5E%7Bt%7Dp_%7Bi%7Dn%5E%7Bi%7D)的特解

反之，则存在一个形如![](http://latex.codecogs.com/gif.latex?n%5E%7Bm%7Ds%5E%7Bn%7D%5Csum_%7Bi%3D0%7D%5E%7Bt%7Dp_%7Bi%7Dn%5E%7Bi%7D)
的特解,其中m是s的重数，这可以保证该特解不

是相伴递推关系的一个解.

接下来利用这两个定理A掉这个题

首先由题设可以得到Ai的递推关系

![](http://latex.codecogs.com/gif.latex?A_%7Bi%7D%3D%5Cfrac%7BA_%7Bi-1%7D-A_%7Bi&plus;1%7D%7D%7B2%7D&plus;d%20%5C%5C%5C%5C2A_%7Bi%7D%3DA_%7Bi-1%7D-A_%7Bi&plus;1%7D&plus;2d%20%5C%5C%5C%5CA_%7Bi&plus;1%7D%3DA_%7Bi-1%7D-2A_%7Bi%7D&plus;2d%20%5C%5C%5C%5CA_%7Bi%7D%3DA_%7Bi-2%7D-2A_%7Bi-1%7D&plus;2d)


于是可以应用两个定理求解

由定理1有![](http://latex.codecogs.com/gif.latex?r%5E%7B2%7D&plus;2r-1%3D0%20%5C%5C%5C%5Cr_%7B1%7D%3D-1&plus;%20%5Csqrt%7B2%7D%2Cr_%7B2%7D%3D-1-%5Csqrt%7B2%7D)

从而![](http://latex.codecogs.com/gif.latex?%5Cleft%5C%7Ba_%7Bn%7D%5E%7B%28h%29%7D%20%5Cright%5C%7D%3D%5Calpha%20r_%7B1%7D%5E%7Bn%7D%20&plus;%5Cbeta%20r_%7B2%7D%5E%7Bn%7D%3D%5Calpha%20%28-1&plus;%5Csqrt%7B2%7D%29%5E%7Bn%7D%20&plus;%5Cbeta%20%28-1-%5Csqrt%7B2%7D%29%5E%7Bn%7D)

我们可以解出来

![](http://latex.codecogs.com/gif.latex?s_%7B1%7D%3D-1-%5Csqrt%7B2%7D%20%5C%5C%5C%5Cs_%7B2%7D%3D-1&plus;%5Csqrt%7B2%7D%20%5C%5C%5C%5C%5Calpha%20%3D%5Cfrac%7BA_%7Bn%7D-d-s_%7B2%7D%5E%7Bn-1%7D%28A_%7B1%7D-d%29%7D%7Bs_%7B1%7D%5E%7Bn%7D&plus;s_%7B2%7D%5E%7Bn-2%7D%7D%20%5C%5C%5C%5C%5C%5C%5Cbeta%3D%5Cfrac%7BA_%7B1%7D-d-s_%7B1%7D%5Calpha%20%7D%7Bs_%7B2%7D%7D)

特解显然就是d

于是这个通解不难得到，因为很长，具体看代码

我们可以按照l毒瘤xl讲分块那样类比一下

如果我不求通解直接把所有的f(i)列成方程组，就可以得到O(n^3)的高斯消元

如果直接按照递推式求解，是O(n)的,可以矩阵加速到O(27logn)

如果求通解~~(然而特别费劲)~~是O(logn)的(快速幂)，可以打表到O(1),是最优的

但通常情况下如果r算出来是实数那么最好矩阵加速做，因为有浮点误差而且不能%

这个题的坑点，后5个数据的m全都是0,剩下的数据极水

为了缩代码，用了自带pow而不是快速幂

```cpp
#include<cstdio>
#include<cmath>
const double o1=sqrt(2)-1,o2=-sqrt(2)-1;
int main()
{
	double r1,r2,d,a1,an,alpha;
	int n,m;
	scanf("%d%d",&n,&m);
	scanf("%lf%lf%lf",&d,&a1,&an);
	if(!m)
	{
		printf("0.000");
		return 0;
	}
	r1=pow(o1,n),r2=pow(o2,n-2);
	alpha=(an-d-r2*o2*(a1-d))/(r1+r2);
	printf("%.3lf",alpha*pow(o1,m)+(a1-d-o1*alpha)*pow(o2,m-1)+d);
}```

---

## 作者：DesignDigits (赞：2)

# 一种思维难度只有 黄 的做法

> 请注意这个解法的复杂度为 $O(n)$，不是最优的，但实际能 [相当优秀地](https://www.luogu.com.cn/record/list?pid=P1487&orderBy=1&status=&page=1#:~:text=14%20(GCC%209)-,Mechanical_Melodies,100,-P1487%20%E5%A4%B1%E8%90%BD%E7%9A%84) 通过本题。

为了让你不用一直切换到题面页，我帮你把柿子复制过来了哦：

$$A_i=\frac {A_{i-1}-A_{i+1}} 2 +d\quad (i=2, 3, \dots, n-1)$$

上式中 $i$ 有 $(n-2)$ 种取值。

首先你看：当 $i=2$ 时，我们可以得到一个等量关系

$$A_2=\frac {A_1-A_3} 2 +d$$

$d,A_1$ 已知，所以它是一个关于 $A_2, A_3$ 的方程。

同理，$i$ 取所有 $(n-2)$ 种取值的任何一个，都会产生一个关于 $A$ 中的项的方程！

那么 $A$ 中有多少个未知数呢？$A_1, A_n$ 已知，所以有 $(n-2)$ 个未知数。

**未知数和方程的数量相等的线性方程组 _有很大的可能_ 可以解得唯一的一组解！**

如果直接写 **高斯消元** （解线性方程组的算法）的模板，本题就解决了。但有一种便捷的方法：


> 现在离那个柿子有点远了，我又帮你移下来了，快谢谢我（

$$A_i=\frac {A_{i-1}-A_{i+1}} 2 +d$$

柿子是 $A$ 数列中连续的 $3$ 个元素的关系，所以只要知道 $A_1, A_2$ 的值，代入 $i=2$ 时的方程，并解开，就可以得到 $A_3$，进而通过 $A_2, A_3$ 得到 $A_4$……最终推得 $A$ 的所有 $n$ 项的值！就像这样，

两边乘以 $2$：

$$2A_i=A_{i-1}-A_{i+1}+2d$$

移项：

$$A_{i+1}=A_{i-1}-2A_i+2d$$

那我们面临的问题就是：我们只知道 $A_1$ 而不知道 $A_2$。现在，**想想还没用到的条件！**

是什么？是我们的 $A_n$ 的值对不对？

于是，我们可以设 $A_2=x$，用上面的方法把 $A$ 的所有项求出。（这里的求出，指的是表示成 $3x+4$ 或 $-x+5$ 这样含 $x$ 的式子）

最后得到 $A_n =\ ?x\  +\ ?$。可是，我们已经知道 $A_n$ 是多少了！

于是代入解出 $x$。再代入到 $A_m=\ ?x\ +\ ?$ 之中，就可以得到不含 $x$ 的 $A_m$ 的数值了！ 

写在代码里时，用 $k_i,b_i$ 表示 $A_i=kx+b$ 即可。

```cpp
// A_1, A_n 是输入的数值。

k[1]=0; b[1]=A_1; 
k[2]=1; b[2]=0;
for (int i=3; i<=n; i++) {
	k[i] = k[i-2] - 2*k[i-1];
	b[i] = b[i-2] - 2*b[i-1] + 2*d;
}
double x = (A_n-b[n]) / k[n];
cout<<fixed<<setprecision(3) << k[m]*x + b[m];
```

---

## 作者：lidagua1004 (赞：1)

这道题我们可以**枚举** $a_{2}$，然后推出 $a_{n}$，再判断当前 $a_{2}$ 是否满足。
但是直接枚举肯定要 TLE。

所以我想到了**二分**，在实数域上二分 $a_{2}$ 就可以了。

解释一下为什么可以二分。

二分时要满足单调性，即 $a_{2}$ 越大，$a_{n}$ 也要越大或越小。

这里可以推一下。

$$\because a_{i}=\frac{(a_{i-1}-a_{i+1})}{2}+d$$ 
$$\therefore a_{i+1}=a_{i-1}-2(a_{i}-d)$$
把所有下标减 $1$

$$\therefore a_{i}=a_{i-2}-2(a_{i-1}-d)$$
我们可以发现当 $a_{i-1}$ 越大，$a_{i}$ 越小。

所以 $a_{2}$ 与 $a_{n}$ 的关系要分 $n$ 的奇偶来分类。

代码如下
```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
double a[10050];
double d,eps=1e-12,an;
bool check(){//检查a[2]是否满足
	for(int i=3;i<=n;i++){
		a[i]=a[i-2]+2*d-2*a[i-1];
	}
	return a[n]>=an;
}
int main(){
	int m;
	cin>>n>>m;
	cin>>d>>a[1]>>an;
	double l=-1e10,r=1e10;
	while(r-l>eps){
		a[2]=(r+l)/2;
		if(check()){
			if(n&1) l=a[2];//根据n的奇偶来二分
			else r=a[2];
		}
		else{
			if(!(n&1)) l=a[2];
			else r=a[2];
		}
	}
	printf("%.3lf",a[m]);
    return 0;
}
```

---

## 作者：Reanap (赞：1)

我们如果得出a[2]的值，那么我们便可以求出a[m]的值，所以我们将令a[2]=y,a[n-1]=x,可以用含x表达式表达y的值，用含y的表达式表示x，则将此题转化为一个解二元一次方程组的题。

亮代码：
	
    #include <cstdio>
  
	double a[65][3],b[65][3],c[65],d,fir,las;
  
	int j,k;
  
	int main() {
  
		scanf("%d %d",&j,&k);
		scanf("%lf %lf %lf",&d,&fir,&las);
		a[j][0] = 1;
		a[j-1][1] = 1;
  
		for(int i=j-2;i>=2;--i) {
			a[i][0] = a[i+2][0]+a[i+1][0]*2;//以a[i][0]表示a[n]的系数
			a[i][1] = a[i+2][1]+a[i+1][1]*2;//以a[i][1]表示x的系数
			a[i][2] = a[i+2][2]+a[i+1][2]*2-2;//以a[i][2]表示d的系数
		}
		double n = a[2][1],l1 = a[2][0]*las+a[2][2]*d;//合成常数项
		b[1][0]=1;
		b[2][1]=1;
 
		for(int i=3;i<=j-1;++i) {
			b[i][0] = b[i-2][0]-b[i-1][0]*2;
			b[i][1] = b[i-2][1]-b[i-1][1]*2;
			b[i][2] = b[i-2][2]-b[i-1][2]*2+2;
		}
		double m = b[j-1][1],l2 = b[j-1][0]*fir+b[j-1][2]*d;//以上类上
		double sec = (-n*l2-l1)/(n*m-1);//计算出a[2]的值
		c[1] = fir,c[2] = sec;
		for(int i=3;i<=k;++i) {
			c[i] = c[i-2]-2*c[i-1]+2*d;
		}//套用递推式
		printf("%.3lf",c[k]);
		return 0;
	}


---

## 作者：Mychael (赞：1)

提供一个更好理解的题解：

**矩阵快速幂**

由题表达式可以化为这样一个递推表达式：

a[n+1]=a[n-1]-2\*a[n]+2d

于是乎我们可以构造这样一个矩阵表达式：

 ![](https://cdn.luogu.com.cn/upload/pic/7892.png) 

我们设这三个矩阵分别为Fn,A,Fn-1

那么对于任意n>1,都有Fn=A^(n-2)\*F2

而F2包含a2,a1,d，还有a2未知，我们就用FN=A^(N-2)\*F2构造出一个关于a2的方程，就可以解出a2了


注意：题目中一半的数据都有N=0或M=0，这个时候需要输出0.000     = =【太坑了吧】









```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define LL long long int
using namespace std;
const int maxn=5,INF=2000000000,P=1000000007;
struct Matrix{
    double s[maxn][maxn];
    int n,m;
    Matrix() {fill(s[0],s[0]+maxn*maxn,0);n=m=0;}
}A,F;
inline Matrix operator *(const Matrix& a,const Matrix& b){
    Matrix c;
    if(a.m!=b.n) return c;
    c.n=a.n;c.m=b.m;
    for(int i=1;i<=c.n;i++)
        for(int j=1;j<=c.m;j++)
            for(int k=1;k<=a.m;k++)
                c.s[i][j]+=a.s[i][k]*b.s[k][j];
    return c;
}
inline Matrix qpow(Matrix a,int b){
    Matrix ans;ans.n=ans.m=a.n;
    for(int i=1;i<=ans.n;i++) ans.s[i][i]=1;
    for(;b;b>>=1,a=a*a) if(b&1) ans=ans*a;
    return ans;
}
int N,M,AA[9]={-2,1,2,1,0,0,0,0,1};
double a1,an,d,a2;
void init(){
    A.n=A.m=3;
    for(int i=0;i<3;i++)
        for(int j=0;j<3;j++)
            A.s[i+1][j+1]=AA[i*3+j];
    cin>>N>>M>>d>>a1>>an;
    if(N==1||M==1) {printf("%.3lf\n",a1);exit(0);}
    else if(N==0||M==0) {printf("%.3lf\n",0.000);exit(0);}
    else{
        Matrix An=qpow(A,N-2);
        a2=(an-An.s[1][2]*a1-An.s[1][3]*d)/An.s[1][1];
    }
    F.n=3;F.m=1;
    F.s[1][1]=a2;F.s[2][1]=a1;F.s[3][1]=d;
}
void solve(){
    Matrix Fn=qpow(A,M-2)*F;
    printf("%.3lf\n",Fn.s[1][1]);
}
int main(){
    init();
    solve();
    return 0;
}

```

---

## 作者：Expert_Dreamer (赞：0)

### 题意
给定递推式：$$A_i=\dfrac{(A_{i-1})-(A_{i+1})}{2}+d$$，然后给定 $A_1,A_n$，求 $A_m$。

### 题解
先推式子：$$A_i=\dfrac{(A_{i-1})-(A_{i+1})}{2}+d=-2A_{i-1}+A_{i-2}+2d$$。

设 $A_2=x$，通过递推式可得 $x=A_2=\dfrac{a_i-a^{\prime}_i}{a^{\prime\prime}_i}$，其中 $a^{\prime}$ 和 $a^{\prime\prime}$ 是系数和常数，递推可得，然后解方程即可。

---

## 作者：RAND_MAX (赞：0)

感觉评蓝高了。

看到原式感觉不好操作，把式子化简为 $A_{i+1}=A_{i-1}+2\times d-2\times A_i$，下标减一得到通项公式 $A_{i}=A_{i-2}+2\times (d-A_{i-1})$。

我们注意到 $A_{i-1}$ 越大，$A_i$ 越小，反之亦然。说明数列 $A$ 在奇偶性相同的位上具有单调性，且奇位和偶位的单调性相反。有单调性，很难不想到二分。又因为只要知道 $A_1$ 与 $A_2$ 便可以求整个数列，那我们考虑二分 $A_2$，根据奇偶性判断与 $A_n$ 的关系即可。

Code：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m; 
double a[101],d,l,r,mid,ss;
bool check()
{
	for(int i=3;i<=n;i++)
	{
		a[i]=a[i-2]-2.0*a[i-1]+2.0*d;
	}
	return a[n]>=ss;
}
signed main()
{
	cin>>n>>m>>d>>a[1]>>ss;
	l=-10000.0,r=10000.0;
	while(l+1e-11<r)
	{
		mid=(l+r)/2.0;
		a[2]=mid;
		if(check())
		{
			n&1?l=mid:r=mid;
		}
		else
		{
			n&1?r=mid:l=mid;
		}
	}
	printf("%.3lf\n",a[m]);
 	return 0;
}

```

---

## 作者：Infinite_Eternity (赞：0)

# Description

[P1487 失落的成绩单](https://www.luogu.com.cn/problem/P1487)

对于一个满足：
$$A_{i}=\dfrac{A_{i-1}-A_{i+1}}{2} + d$$
的数列 $a$，给出首项 $A_{1}$，末项 $A_{n}$，以及常数项 $d$。请求出 $A_{m}$ 的值。

数据范围：$1\le n\le 60$，$0\le m\le n$，$|d|,|A_1|,|A_n|<10^4$。
 
# Analysis
由：
$$A_{i}=\dfrac{A_{i-1}-A_{i+1}}{2} + d$$
得：
$$2A_{i}=A_{i-1}-A_{i+1}+2d$$
移项后：
$$A_{i+1}=A_{i-1}-2A_{i}+2d$$ 
令 $i=i-1$，得：
$$A_{i}=A_{i-2}-2A_{i-1}+2d$$
因为：
$$A_{3}=A_{1}-2A_{2}+2d$$
$$A_{4}=A_{2}-2A_{3}+2d$$
得：
$$
\begin{aligned}
A_{4}&=A_{2}-2(A_{1}-2A_{2}+2d)+2d\\
A_{4}&=A_{2}-2A_{1}+4A_{2}-4d+2d\\
A_{4}&=-2A_{1}+5A_{2}-2d
\end{aligned}
$$
则可以根据上式递推得此式：
$$A_{n}=\color{red}x\color{black}A_{1}+\color{red}y\color{black}A_{2}+\color{red}z\color{black}d$$
中的 $\color{red}x\color{black},\color{red}y\color{black},\color{red}z$，并推出：
$$A_{2}=\dfrac{A_{n}-\color{red}x\color{black}A_{1}-\color{red}z\color{black}d}{\color{red}y}$$
# CODE
```cpp
#include<stdio.h>
struct test
{
    int x, y, z;
} score[61];
int main()
{
    double a[61], d;
    int n, m;
    scanf("%d %d", &n, &m);
    scanf("%lf %lf %lf", &d, &a[1], &a[n]);
    score[3].x = 1, score[3].y = -2, score[3].z = 2;
    score[4].x = -2, score[4].y = 5, score[4].z = -2;
    for(int i = 5; i <= n; i++)
    {
        score[i].x = score[i-2].x - 2 * score[i-1].x;
        score[i].y = score[i-2].y - 2 * score[i-1].y;
        score[i].z = score[i-2].z - 2 * score[i-1].z + 2;
    }
    a[2] = (a[n] - score[n].x * a[1] - score[n].z * d) / score[n].y;
    for(int i = 3; i <= m; i++)
    {
        a[i] = a[i-2] - 2 * a[i-1] + 2 * d;
    }
    printf("%.3f",a[m]);
    return 0;
}
```

---

## 作者：FxorG (赞：0)

## $\text{Solution}$

求

$$ A_i=\dfrac{A_{i-1}-A_{i+1}}{2}+d$$

即

$$2A_i-A_{i-1}+A_{i+1}=2d$$

高斯-约旦消元即可。

但是 $A_1,A_n$ 是常数了，该怎么办？

类比到 $n=5$，则

$$ 2A_2+A_3=2d+A_1$$

$$ 2A_3-A_2+A_4=2d$$

$$ 2A_4-A_3=2d-A_5$$

已有

$$A_1=a,A_5=b$$

那么得 $n-2$ 个元， $n-2$ 个方程。

## $\text{Code}$

```cpp
#include <bits/stdc++.h>

#define N 65
#define db double

using namespace std;

db d,a,b,A[N][N];
int n,m,rn;

db fabs(db x) {
	return x>0?x:-x; 
}

int main() {
	memset(A,0.0,sizeof(A));
	scanf("%d%d%lf%lf%lf",&n,&m,&d,&a,&b);
	rn=n-2;
	A[1][1]=2.0; A[1][2]=1.0; A[1][rn+1]=2.0*d+a;
	A[rn][rn]=2.0; A[rn][rn-1]=-1.0; A[rn][rn+1]=2.0*d-b;
	for(int i=2;i<rn;i++) {
		A[i][i]=2.0; A[i][i-1]=-1.0; A[i][i+1]=1.0; A[i][rn+1]=2.0*d;
	}
	for(int i=1;i<=rn;i++) {
		int mx=i;
		for(int j=i+1;j<=rn;j++) {
			if(fabs(A[j][i])>fabs(A[mx][i])) mx=j;
		}
	//	cout<<mx<<endl;
		for(int j=1;j<=rn+1;j++) swap(A[mx][j],A[i][j]);
		for(int j=1;j<=n;j++) {
			if(j^i) {
				db tmp=A[j][i]/A[i][i];
			//	cout<<tmp<<endl;
				for(int k=i+1;k<=rn+1;k++) {
					A[j][k]-=tmp*A[i][k];
				}
			}
		}
	}
	printf("%.3lf\n",A[m-1][rn+1]/A[m-1][m-1]);
	return 0;
}
```

---

## 作者：suxxsfe (赞：0)

[我的blog](https://www.cnblogs.com/suxxsfe/p/13172938.html)  

之前似乎提交到别的题里去了/jk，赶紧删了重新交一遍  

https://www.luogu.com.cn/problem/P1487  

一个长度为 $n$ 的序列，已知 $A_1,A_n,n,d$，并满足 $A_i=\dfrac{A_{i-1}+A_{i+1}}{2}+d$，求 $A_m$  

最近数学课学了点特征方程，所以用它做了下这题  

一般用特征方程求通项的时候，是已知数列满足 $a_{i+1}+Ba_i+Ca_{i-1}=0$  
那么设 $a_{n+1}-pa_n=q(a_n-pa_{n-1})$，转化成 $a_{n+1}-(p+q)a_n+pqa_{n-1}=0$  
此时应满足 $p+q=-B,pq=C$  
然后用韦达定理构造一个两个解分别是 $p,q$ 的二次方程并把它解出来，就知道 $p,q$ 了  
如果无解当然就是不能这样构造  

进而设 $b_n=a_{n+1}-pa_n$，则：  

$$b_n=qb_{n-1}\Rightarrow b_n=a_{n+1}-pa_n=b_1q^{n-1}=(a_2-pa_1)q^{n-1}$$  

同时除以 $p^{n+1}$，就是：  

$$\dfrac{a_{n+1}}{p^{n+1}}-\dfrac{a_n}{p^n}=\dfrac{(a_2-pa_1)q^{n-1}}{p^{n+1}}$$  

再设 $c_n=\dfrac{a_n}{p^n}$  
就可以表示成：  

$$c_{n+1}-c_n=\dfrac{(a_2-pa_1)q^{n-1}}{p^{n+1}}$$  

那么对 $c$ 做一个累加，中间的一堆项就消没了，得到：  

$$c_n-c_1=\sum_{i=1}^{n-1}\dfrac{(a_2-pa_1)q^{i-1}}{p^{i+1}}$$  

一通整理，发现从里面把与求和无关的因式提出来，就是个等比数列，用一下求和公式，于是：  

$$c_n=\dfrac{a_2-pa_1}{p^2}\cdot \dfrac{1-(\frac{q}{p})^{n-1}}{1-\frac{q}{p}}+\dfrac{a_1}{p}$$  

还原成 $a_n$，就是：  

$$a_n=\dfrac{p^{n-2}(a_2-pa_1)(1-(\frac{q}{p})^{n-1})}{1-\frac{q}{p}}+a_1p^{n-1}$$  
$$a_n=\dfrac{(\frac{q^{n-1}}{p}-p^{n-2})(a_2-pa_1)}{\frac{q}{p}-1}+a_1p^{n-1}$$  

也许能再化简让形式更好看一些？但我懒得化了  

-----------------  

再看这个题  

$$A_{i+1}+2A_i-A_{i-1}=2d$$  

发现这个 $2d$ 很耽误事，但是可以设 $a_i=A_i+d$，于是：  

$$a_{i+1}+2a_i-a_{i-1}=0$$  

按照之前讲的，此时应满足 $p+q=-2,pq=-1$，于是构造方程 $x^2+2x-1=0$  
两个解对应 $p,q$，也就是 $p=\sqrt{2}-1,q=-\sqrt{2}-1$，当然把它们的值互换也不会对结果产生影响  
但我们并不知道 $a_n$ 表达式里的 $a_2$ 是什么，但是知道 $a_n$，于是可以变一下那个式子把 $a_2$ 求出来：  

$$a_2=\frac{(\frac{q}{p}-1)(a_n-a_1p^{n-1})}{\frac{q^{n-1}}{p}-p^{n-2}}+a_1p$$  

然后就可以带入 $n=m$ 来求出答案了  

注意判断一下 $m=0$ 这种奇怪的情况  

```cpp  
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<cmath>
#include<map>
#include<iomanip>
#include<cstring>
#define reg register
#define EN std::puts("")
#define LL long long
inline long double power(long double a,int b){
	long double ret=1;
	while(b--) ret*=a;
	return ret;
}
int main(){
	int n,m;scanf("%d%d",&n,&m);
	if(!m) return puts("0.000"),0;
	long double d,A1,An,a1,an,a2,am,Am;scanf("%Lf%Lf%Lf",&d,&A1,&An);
	a1=A1-d;an=An-d;
	long double p=std::sqrt(2)-1,q=-std::sqrt(2)-1;
	a2=(q/p-1)*(an-a1*power(p,n-1))/(power(q,n-1)/p-power(p,n-2))+p*a1;
	am=(power(q,m-1)/p-power(p,m-2))*(a2-p*a1)/(q/p-1)+a1*power(p,m-1);
	Am=am+d;
	printf("%.3Lf",Am);
	return 0;
}
```

---

## 作者：wanghanjun (赞：0)

由题意，
$$A_i=\frac{(A_{i-1})-(A_{i+1})}{2}+d$$

然后移项可得：
$$-\frac{1}{2}A_{i-1}+A_i+\frac{1}{2}A_{i+1}=d$$

然后由于数据范围很小，所以直接套一下高斯消元模板就可以了

代码：
```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;

const int MAXN=65;
double a[MAXN][MAXN],b[MAXN],eps=1e-7,d,a1,an;
int n,m;

int main(){
	cin>>n>>m>>d>>a1>>an;
	if(n==0||m==0){
		cout<<"0.000"<<endl;
		return 0;
	}
	a[1][1]=1;b[1]=a1;
	a[n][n]=1;b[n]=an;
	for(int i=2;i<n;i++){
		a[i][i-1]=-1;
		a[i][i]=2;
		a[i][i+1]=1;
		b[i]=d*2;
	}
	for(int i=1;i<=n;i++){
		int id=i;
		for(int j=i+1;j<=n;j++){
			if(fabs(a[j][i])>fabs(a[id][i])){
				id=j;
			}
		}
		for(int j=1;j<=n;j++){
			swap(a[i][j],a[id][j]);
		}
		swap(b[i],b[id]);
		for(int j=1;j<=n;j++){
			if(i!=j){
				double t=a[j][i]/a[i][i];
				for(int k=i+1;k<=n;k++){
					a[j][k]-=a[i][k]*t;
				}
				b[j]-=b[i]*t;
			}
		}
	}
	printf("%.3lf",b[m]/a[m][m]);
	return 0;
}
```
当然还有一种思路是设出A2通过下式得到An的表达式
$$A_{i+1}=2d+A_{i-1}-2A_i$$
这里就不给出代码了

---

## 作者：fengjk (赞：0)

题目的数列如下（由于精度和计算顺序问题，越靠近an答案越精确）


```cpp
a[1]=1.213
a[2]=-491.500
a[3]=-615.000
a[4]=227.375
a[5]=-44.750
a[6]=62.062
a[7]=24.203
a[8]=14.746
a[9]=3.793
a[10]=4.247
a[11]=0.386
a[12]=1.060
a[13]=0.602
a[14]=0.567
a[15]=0.554
a[16]=0.561
a[17]=0.542
a[18]=0.545
a[19]=0.544
a[20]=0.543
a[21]=0.543
a[22]=0.543
a[23]=0.543
a[24]=0.543
a[25]=0.543
a[26]=0.543
a[27]=0.543
a[28]=0.543
a[29]=0.543
a[30]=0.543
a[31]=0.543
a[32]=0.543
a[33]=0.543
a[34]=0.542
a[35]=0.544
a[36]=0.540
a[37]=0.550
a[38]=0.525
a[39]=0.586
a[40]=0.440
a[41]=0.792
a[42]=-0.059
a[43]=1.995
a[44]=-2.963
a[45]=9.007
a[46]=-19.891
a[47]=49.876
a[48]=-118.556
a[49]=288.074
a[50]=-693.618
a[51]=1676.397
a[52]=-4045.326
a[53]=9768.134
```
计算方法是：
先假设A(n-1)已知，再用An和d递推出A(n-2),A(n-3)等等，所有数列均表达为一个关于A(n-1),A(n)和d的一个方程，只用记录下每项的系数即可，在推到A2和A3时，就又可以联立A1，A2，A3计算出方程中的A(n-1),在带回原式中，即可计算出整个数列


注意事项：

由于精度问题，在这里long long也会爆掉，所以应用long double，注意占位符和输入输出格式（不要问我是怎么知道这些的，直接看我惨痛的提交记录）






```cpp
//by：信冯哥
#include<stdio.h>
#include<iostream>
#include<stdlib.h>
#include<algorithm>
#include<string.h>
#include<math.h>
#include<time.h>
#include<vector>
#include<queue>
#include<limits.h>
#include <iomanip>
using namespace std;
#define maxn 1005
#define MOD 9999999999
#define bugb puts("begin");
#define buge puts("end");
typedef long long ll;
typedef long double ld;
ll n,m,k,l,s,t,r,T,ans,cas;
ld a[maxn];
ld d;
struct st
{
    ld x1,x2,x3;
} node[maxn];
int main()
{
    freopen("in.txt","r",stdin);
    freopen("out.txt","w",stdout);
    ll i,j;
    cin>>n>>m;
    cin>>d>>a[1]>>a[n];
    if(n==3)
        {
            a[2]=(a[1]-a[2])/2.0+d;
            printf("%.3lf",a[m]);
            return 0;
        }
    if(n<=2)
        {
            printf("%.3lf",a[m]);
            return 0;
        }
    node[n-1].x1=1;
    node[n-1].x2=0;
    node[n-1].x3=0;
    node[n-2].x1=2;
    node[n-2].x2=1;
    node[n-2].x3=-2;
    for(i=n-3; i>=2; i--)
        {
            node[i].x1=2*node[i+1].x1+node[i+2].x1;
            node[i].x2=2*node[i+1].x2+node[i+2].x2;
            node[i].x3=2*node[i+1].x3+node[i+2].x3-2;
        }
    ld xn1=2*node[2].x1+node[3].x1,xn2=2*node[2].x2+node[3].x2,xn3=2*node[2].x3+node[3].x3;
    ld opt=(a[1]+2*d-(ld)xn2*a[n]-(ld)xn3*d)/(ld)xn1;
    for(i=2; i<=n-1; i++)
        a[i]=opt*(ld)node[i].x1+(ld)node[i].x2*a[n]+(ld)node[i].x3*d;
   /* for(i=1; i<=n; i++)
        cout << "a["<<i<<"]="<<fixed << setprecision(3) << a[i]<<endl;*/
cout << <<fixed << setprecision(3) << a[m]<<endl;
    return 0;
}

```

---


# 猩猩散步

## 题目描述

猩猩，骆驼，还有泡泡经常喜欢在饭后到操场上散步，由于猩猩的走路姿势最突出最显眼，理所应当的成为他们中的主角，所以我的题目就说猩猩散步了。（骆驼和泡泡别有意见哈，和猩猩争啥……）

当然，话说回来，猩猩在 OI 上的能力也是不容低估的，你看，散步时还会想一道与此相关的问题，这是道经典的不能再经典的问题了。

在一个 $m×n$ 的矩阵上，猩猩在左下角的顶点出现了，他只能沿着路径向上或者向右走，他的目标是“蠕动”到右上角的顶点，问他有多少路径可以选择。嗯，这个、这个、这个似乎地球人都知道怎么做，但是请注意，我有个条件没给呢！$m$ 和 $n$ 现在的最大范围是 $5\times 10^4$，这可怎么办？仔细想想吧。


## 样例 #1

### 输入

```
7 4
```

### 输出

```
0000000000
0000000000
0000000000
0000000000
0000000000
0000000000
0000000000
0000000000
0000000000
0000000330
```

# 题解

## 作者：RainFestival (赞：18)

update on $\sf 2021.12.22$

以下定义 $x\in P$ 为 $x$ 是质数。

这个题目让我们求 $\binom{n+m}{m}\bmod 10^{100}$。

显然需要高精度计算。如果你使用朴素的高精，$(n+m)!$ 可能会达到 $10^5!$，大概有 $400000$ 多位。

这个 $400000$ 多位是对它取对数得到的，$\log_{10}(10^5!)\approx 456573.45$。

朴素高精乘法很慢，对于两个位数为 $n$ 的数相乘，相当于暴力卷积，是 $\mathcal{O(n^2)}$ 的，不能在本题限制内解决问题。

更重要的是，还要涉及到高精度除法。

所以我们要换一种做法。

我们把 $[1,n+m]$ 中的每一个质数数找出来，然后考虑每一个质数出现了多少次。

我们知道 $\binom{n+m}{m}=\frac{(n+m)!}{n!m!}$。

假设 $p\in P$，$f_p=(n+m)!$ 的唯一分解中 $p$ 的次数，$a_p=n!$ 的唯一分解中 $p$ 的次数，$b_p=m!$ 的唯一分解中 $p$ 的次数。

那么答案为 $\prod\limits_{p\in P}p^{f_p-a_p-b_p}$。

记录 $s_p=f_p-a_p-b_p$，考虑求出 $s$。

对于分子部分，每一个质因数的贡献是 $+1$，对于分母，则是 $-1$。

我们知道 $n$ 以内的质数数量 $\pi(n)\approx \frac{n}{\ln n}
$ 而 $n=100000$ 时，$\pi(100000)=9592$。

记得一边做高精乘法一边取模，就是说，高精的位数不能超过 $100$ 位。

代码：

```cpp
#include<cstdio>
#include<algorithm>
int n,m,l,maxn,t[100005],p[100005],cnt[100005];
long long ss[105];
void mul(int x) 
{
	for (int i=1;i<=l;i++) ss[i]=ss[i]*x;
	for (int i=1;i<=l||ss[i];i++) ss[i+1]=ss[i+1]+ss[i]/10,ss[i]=ss[i]%10,l=std::max(l,i);
	l=std::min(l,100);
}
void add(int x,int w)
{
	while (x>1)
	{
		int d=t[x];
		cnt[d]=cnt[d]+w;
		x=x/d;
	}
}
int main()
{
	ss[l=1]=1;
	scanf("%d%d",&n,&m);
	maxn=n+m;
	for (int i=2;i<=maxn;i++) p[i]=1;
	for (int i=2;i<=maxn;i++)
	{
		if (!p[i]) continue;
		t[i]=i;
		for (int j=i,l=maxn/i;j<=l;j++) p[i*j]=0,t[i*j]=i;
	}
	for (int i=1;i<=n+m;i++) add(i,1);
	for (int i=1;i<=n;i++) add(i,-1);
	for (int i=1;i<=m;i++) add(i,-1);
	for (int k=1;k<=n+m;k++) for (int i=1;i<=cnt[k];i++) mul(k);
	for (int i=100;i>=1;i--)
	{
		printf("%lld",ss[i]);
		if (i%10==1) puts("");
	}
	return 0;
}
```

实测时间 $\tt 77ms$，空间 $\tt 1.39MB$，代码长度 $\tt 873B$。

当然如果不限制高精位数也是可以通过的，$n=50000,m=50000$ 也能在 $\tt 1s$ 内跑完。

> 个人吐槽：本题解是我近 $3$ 年前写的，看到它成为本题最高赞的题解，我就修改一下排版与格式的问题。原来的存档在[这里](https://www.luogu.com.cn/paste/vxxgr15s)。感谢各位的阅读与支持。当时我很菜，啥题都不会做，做这个题目花了不少时间，但是我当时记得在哪里看到过这个做法，然后就做出来了，当时也挺高兴的。但是现在想想就不知有当时多么菜与浅薄了。

---

## 作者：zhiyangfan (赞：10)

### 一句话题意
求 $\dbinom{n+m}{n}$。( $1\le n,m\le50000$ )
### 两句话题解
首先注意到只需要预处理出 $1$ 到 $n+m$ 的阶乘就可以  $\mathcal{O}(1)$ 计算了。但是需要高精度，一般的高精度复杂度过大，不能接受，所以这里用唯一分解定理 $\prod_p p^{c}$ 来表示一个数，最终再用高精度乘起来。
### 三个卡常细节
写这篇题解的主要目的就是提醒大家一些卡常的地方，我因为卡常数调了1h...
首先一个很显然的细节是 $\dbinom{n+m}{n}=\dfrac{(n+m)!}{n!m!}=\dfrac{(n+m)^{\underline{n}}}{n!}$ ，其中令 $n<m$ 。这样需要计算的乘法会少很多

然后就是常数会爆炸在两个地方：一个是算组合数的时候，一个是转化为高精的时候。计算过程中最好不要重载运算符，并且想尽一切办法压常数，否则哪点常数大了哪怕一点点就会爆炸的。

最后是复杂度的优化，首先分解质因数的时候不需要分解到 $n+m$ ，只需要分解到 $\sqrt{n+m}$ ，然后计算的时候对于大质数额外考虑就行了。这样可以把计算组合数的复杂度从 $\mathcal{O}((n+m)\dfrac{n+m}{\log(n+m)})$ 降低到 $\mathcal{O}((n+m)\dfrac{\sqrt{n+m}}{\log(\sqrt{n+m})})$

好吧我承认这些优化都挺简单的，但是确实有时候犯糊涂想不到（可能因为我菜吧/kk）。
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
const int N = 1e5 + 10, M = 2e6;
int p[N], vis[N], tp, n, m;
struct num
{ int pw[N]; }ans;
inline void mul(num& ret, int x)
{
    for (int i = 1; i * i <= x; ++i)
    {
        if (vis[i]) continue;
        while (x % i == 0) ++ret.pw[i], x /= i;
    }
    if (x > 1) ++ret.pw[x];
}
inline void div(num& ret, int x)
{
    for (int i = 1; i * i <= x; ++i)
    {
        if (vis[i]) continue;
        while (x % i == 0) --ret.pw[i], x /= i;
    }
    if (x > 1) --ret.pw[x];
}
struct bnum
{
    int ns[M], len;
    bnum() { len = 1; ns[len] = 1; }
}Ans;
inline void mul(bnum& ret, int x)
{
    for (int i = 1; i <= ret.len; ++i)
        Ans.ns[i] *= x;
    int pos = 1;
    while (pos <= ret.len || ret.ns[pos] > 10)
    {
        ret.ns[pos + 1] += ret.ns[pos] / 10;
        ret.ns[pos] %= 10; ++pos;
    }
    ret.len = pos; while (!ret.ns[ret.len]) --ret.len;
}
inline void trans(const num& x)
{
    for (int i = 1; i <= n + m; ++i)
        for (int j = 1; j <= x.pw[i]; ++j)
            mul(Ans, i);
}
inline void getP(int n)
{
    vis[1] = 1;
    for (int i = 2; i * i <= n; ++i)
    {
        if (!vis[i]) p[++tp] = i;
        for (int j = 1; j <= tp && i * p[j] <= n; ++j)
        {
            vis[i * p[j]] = 1;
            if (i % p[j] == 0) break;
        }
    }
}
int main()
{
    scanf("%d%d", &n, &m); getP(n + m);
    if (n > m) std::swap(n, m);
    for (int i = n + m; i >= m + 1; --i) mul(ans, i);
    for (int i = n; i >= 1; --i) div(ans, i);
    trans(ans);
    for (int i = 100; i >= 1; --i)
        if (i % 10 == 1) printf("%d\n", Ans.ns[i]);
        else printf("%d", Ans.ns[i]);
    return 0;
}
```

---

## 作者：Great_Influence (赞：9)

可以知道答案就是$\binom{n+m}{n}$。

利用$python$直接做高精度。卡卡常数就过了。

代码:

```py

def dow(n,m):
    sm=1
    for i in range(0,m):
        sm=sm*(n-i)
    return sm

n,m=map(int,input().split())

bs=10000000000

lim=bs*bs*bs*bs*bs*bs*bs*bs*bs*bs

if n < m:
    n,m=m,n
ans=dow(n+m,m)//dow(m,m)%lim

rew=[]

for i in range(0,10):
    rew.append(ans%bs)
    ans=ans//bs
for i in range(0,10):
    print("%010d"%rew[9-i])

```

---

## 作者：破忆 (赞：4)

### 题目大意
从（0,0）到（n,m）的路径和


------------

### 分析
每次只能向下或向右，那么一共要走n+m步，其中n步是向下的。

于是问题就变成了从n+m个数中选择n个数一共有多少种选法。

也就是C（n,n+m）


------------

### 解法
C（x,y）=y!/(x!(y-x)!)

把这些数分解质因数，让质因数的个数相加减，然后用高精度乘法把这些质数乘起来



------------
### 代码
```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const int maxn=1000010,TT=100000;
int n,m,sum,p[maxn],a[maxn],len=1;
LL ans[maxn];
bool vis[maxn];
void make_p(){ //筛法挖素数
	memset(vis,1,sizeof vis);
	vis[0]=vis[1]=0;
	for(int i=2,end_i=sqrt(sum);i<=end_i;i+=(i&1)+1)
	if(vis[i]) for(int j=2,end_j=sum/i;j<=end_j;j++) vis[i*j]=0;
	for(int i=2;i<=sum;i++) if(vis[i]) p[++p[0]]=i; 
}
void calc(LL x){ //高精度乘法，每次乘一个质数
	LL lst=0;
	for(int i=1;i<=len;i++){
		ans[i]=ans[i]*x+lst;
		lst=ans[i]/TT;
		ans[i]%=TT;
	}
	while(lst){
		ans[++len]=lst%TT;
		lst/=TT;
	}
}
void print(){
	for(int i=10;i;i--) printf("%05lld%05lld\n",ans[i<<1],ans[(i<<1)-1]);//5位一次输出
}
int main(){
// 	freopen("P1492.in","r",stdin);
// 	freopen("P1492.out","w",stdout);
	scanf("%d%d",&n,&m);
	ans[1]=1;
	sum=n+m;
	make_p();
	for(int i=n+1;i<=sum;i++){ 2~sum的乘积再除以2~n的乘积,就是从n+2乘到sum
		int s=i;
		for(int j=1;s!=1&&j<=p[0];j++){
			while(s%p[j]==0) a[j]++,s/=p[j];
		}
	}
	for(int i=2;i<=m;i++){
		int s=i;
		for(int j=1;s!=1;j++){
			while(s%p[j]==0) a[j]--,s/=p[j];
		}
	}
//	for(int i=1;i<=p[0];i++) printf("%d %d\n",p[i],a[i]);
	for(int i=1;i<=p[0];i++)
	for(int j=1;j<=a[i];j++) calc(p[i]); //枚举质数，再乘
	print();
	return 0;
}
```


---

## 作者：MloVtry (赞：3)

组合数

c(n+m,m)（=c（n+m，n））

因为一共要移动n+m步，那么枚举这n+m步里哪一步想右（或者向上）走，则为方案总数

所以直接搞一搞高精的组合数就行

素数筛+高精压位

这里压了五位（方便输出换行）

代码
        
```cpp
#define ll long long
#define mod 100000 
#include<iostream>
#define N 1000010
#include<cstdio>
using namespace std;
ll n,m;
ll num[N];
ll pr[N],is[N],pn;
void get_p(ll k)
{
    for(ll i=2;i<=k;++i)
    {
        if(!is[i]) pr[++pn]=i;
        for(ll j=1;pr[j]*i<=k&&j<=pn;++j)
        {
            is[pr[j]*i]=1;
            if(i%pr[j]==0) break; 
        } 
    }
}
void turn(ll nu,ll fl)
{
    for(ll i=1;i<=pn;++i)
    {
        if(nu<pr[i]) {break;}
        ll now=pr[i];
        ll tmp=num[i];
        while(nu>=now)
        {
            num[i]+=(nu/now)*fl;
            now*=pr[i];
        }
    }
}
ll ans[10000000];
ll an;
void Big_pow(ll it)//高精乘低精,ans*it
{
    ll jw=0;
    for(ll i=1;i<=an;++i)
    {
        ans[i]=1ll*ans[i]*it+jw;
        jw=ans[i]/mod;
        ans[i]%=mod;
    }
    while(jw)
    {
        ans[++an]=jw%mod;
        jw/=mod;
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    get_p(n+m);
    turn(n+m,1);
    turn(n,-1);
    turn(m,-1);
    ans[++an]=1;
    for(ll i=1;i<=pn;++i)
    {
        while(num[i]--) Big_pow(pr[i]);
    }
    for(int i=20;i>=1;--i)
    {
        printf("%05d",ans[i]);
        if(i&1) putchar('\n');
    }
    return 0;
}
```

---

## 作者：xkcdjerry (赞：2)

看题解没有多少 Python 代码，唯一的一篇还没有用到内置函数来缩减工作量，所以本蒟蒻准备来一篇题解：

考虑需要向上 $n$ 步，往右 $m$ 步，那么可以理解为在 $m$ 右步中插入 $n$ 个上步，即把 $n$ 个球分到 $m+1$ 个桶中，桶可以为空。

可以转化为隔板法，由于桶可以为空需要额外插入 $m+1$ 个球，即在 $n+m+1$ 个球间的 $n+m$ 个位置中插入 $m$ 个板子，则答案为：


$$\binom{n+m}{m}=\frac{P^{n+m}_{n+m-m}}{m!}=\frac{(n+m)!}{n!m!}$$

由于 $n,m \leqslant 50000$ 所以 naive 算是没有问题的，但是……

> 由于最后的答案数目过大，所以只检查后100位

所以必须上高精，本菜鸡不会写就只能用 Python 了。而正巧 Python 也自带很多有用的函数：

* `math` 库中的 `factorial` 可以计算阶乘
* `[:]` 切片语法可以切分字符串
* `str.zfill(x)` 把字符串用 $0$ 在左边填充到指定长度

使用这三个函数，我们就能写出简单的五行代码了！

```python3
from math import factorial as f   # 导入 factorial
n,m=map(int,input().split())  # 经典读入套路
# 把结果转化为字符串后截取后 100 位，如果不够就填充到 100 位
ans=str(f(n+m)//f(n)//f(m))[-100:].zfill(100)
# 从前往后切片输出
for i in range(0,100,10):
    print(ans[i:i+10])
```

~~说不是五行的是因为这是题解要加注释，[删掉注释就是 5 行了](https://www.luogu.com.cn/record/66168869)~~ 而且还跑的不算太慢（最慢的点 300ms）

---

## 作者：Φρανκ (赞：0)

题意：求在格点上从 $(1,1)$ 沿最短路径走到 $(m, n)$ 的方法数。

核心思想：质数统计

解：

容易发现，所求即 $C^n_{n+m}=\frac{(n+m)!}{n!m!}$ （直观理解：共走了 $n+m$  步，其中 $n$ 步是向上的）。

所以答案即将每个小于 $n+m$ 的质数乘上它在 $n+m$ 中出现的次数并除以它在 $n$ 与 $m$ 中出现的次数所得的积。

欧拉筛可以筛出所有满足要求的质数，而其出现的次数可以通过递归统计（ $p$ 在 $[1, x]$ 中出现的次数是 $x$ 以下能够整除 $p$ 的数的个数加上高于一次项的 $p$ 的个数），高精相乘即可。

代码：
```
#include <bits/stdc++.h>
using namespace std;
int n, m, res[101], b[100001], p[100001], flag, t;
int cnt(int x, int y)
{
	if(x<y)
		return 0;
	return x/y+cnt(x/y, y);//递归统计
}
int main()
{
	cin>>m>>n;
	res[0]=1;
	for(int i=2; i<=m+n; i++)
	{
	    if(b[i]==0)
	      p[++flag]=i;
	    for(int j=1; j<=flag; j++)
		{
	      if(i*p[j]>m+n) 
		  	break;
	      b[i*p[j]]=1;
	      if(i%p[j]==0)
	        break;
		}
    }//筛质数
    for(int i=1; i<=flag; i++)
	    for(int j=1; j<=cnt(n+m, p[i])-cnt(n, p[i])-cnt(m, p[i]); j++)
	    {
	    	for(int k=0; k<=99; k++)
	    		res[k]*=p[i];
	    	for(int k=0; k<=99; k++)
	    	{
	    		res[k+1]+=res[k]/10;
	    		res[k]%=10;
			 }//高精乘
		}
	for(int i=99; i>=0; i--)
	{
		cout<<res[i];
		if(i%10==0)
			cout<<endl;
	}//输出
	return 0;
}

```

---


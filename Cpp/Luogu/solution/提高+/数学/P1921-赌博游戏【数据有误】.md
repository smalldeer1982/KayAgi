# 赌博游戏【数据有误】

## 题目背景

赌场是暴利的。大赌场通过游戏规则控制游戏的公平来赚钱。虽然规则看似很公平，但实际上是稍微有点不公平的，而大赌场由于客流量大，资金流量大，这点稍微的不公平就被放大到能让赌场得到很可观的收入。同时，这些个不公平有时并不是规则的不公平，而是道具不公平。比如说灌铅的骰子，它和正常骰子不一样，它投出 $Q$ 种点数的概率并不一样。有时，为了不让顾客察觉，他们每一次游戏结束后都有可能更换骰子。

## 题目描述

作弊的赌场有 $N$ 个骰子，在这个赌场可能发生了 $M$ 次游戏，每次游戏包括一个骰子投出的点数，我们并不知道这个骰子的编号，但知道第 $i$ 次游戏投出的点数 $O(i)$。

第 $i$ 个骰子投出点数 $j$ 的概率是 $A(i,j)$，用完第 $i$ 个骰子，下一次用第 $j$ 个骰子的概率为 $B(i,j)$。特别地，对于第一次游戏，用第 $i$ 个骰子的概率为 $\pi(i)$。

好奇的小 $v$ 来问你，在这个赌场发生这 $M$ 次游戏的概率。

## 说明/提示

### 数据范围及约定

- 对于 $30\%$ 的数据：$M \le 100$，$1 \le N$，$Q \le 10$；
- 对于 $100\%$ 的数据：$1 \le M \le 1000$，$1 \le N$，$Q \le 50$。

对于矩阵 $A,B$，向量 $\pi$ 都具备概率转移的特征条件。

## 样例 #1

### 输入

```
3 10 3
1 0 0
0.03 0.03 0.94
0.02 0.02 0.96
0.99 0.005 0.005
0.01 0.99 0
0.05 0.05 0.90
0.98 0.002 0.008 
2 2 0 2 2 0 2 2 0 2
```

### 输出

```
0.4483```

# 题解

## 作者：asuldb (赞：6)

我校最神的金牌爷安利给我的题

金牌爷告诉我这道题水爆了

~~天啊，金牌爷竟然给我安利题目啦~~

刚开始看着黑色的标签感觉并不是很可做，但是看到金牌爷~~脖子上闪闪发光的金牌~~真挚的眼神

我决定还是做一做

于是就开开心心的做了一道水题

我们设$dp[i][j]$表示进行到$i$次游戏，这次游戏使用的是第$j$个骰子的概率

首先我们先初始化，刚开始第一次游戏能用到的骰子跟$\pi(i)$有关系

于是$dp[1][i]=\pi(i)*a[i][O[1]]$

就是选择这个骰子并且能出现这次需要的点数的概率乘起来

之后我们刷表转移

对于一个$dp[i][j]$我们使用完之后可能会换骰子于是我们就枚举下一个换的骰子$k$，这个骰子需要出现对应的点数

于是就有

$$dp[i+1][k]+=dp[i][j]*b[j][k]*a[k][O[i+1]]$$

最后答案就是$\sum_{i=1}^{n}dp[m][i]$

代码
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#define re register
#define maxn 1005
#define eps 1e-6
#define M 51
double a[M][M],b[M][M];
double pi[M],dp[maxn][maxn];
int O[maxn];
int n,m,Q;
inline int check(double t,double k)
{
	if(t+eps>k&&t-eps<k) return 1;
	return 0;
}
int main()
{
	scanf("%d%d%d",&n,&m,&Q);
	for(re int i=1;i<=n;i++)
		scanf("%lf",&pi[i]);
	for(re int i=1;i<=n;i++)
		for(re int j=0;j<Q;j++)
			scanf("%lf",&a[i][j]);
	for(re int i=1;i<=n;i++)
		for(re int j=1;j<=n;j++)
			scanf("%lf",&b[i][j]);
	for(re int i=1;i<=m;i++)
		scanf("%d",&O[i]);
	for(re int i=1;i<=n;i++)
		dp[1][i]=pi[i]*a[i][O[1]];
	for(re int i=1;i<m;i++)
		for(re int j=1;j<=n;j++)
		{
			if(check(dp[i][j],0)) continue;
			for(re int k=1;k<=n;k++)
				dp[i+1][k]+=dp[i][j]*a[k][O[i+1]]*b[j][k];
		}
	double ans=0;
	for(re int i=1;i<=n;i++)
		ans+=dp[m][i];
	printf("%.4lf",ans);
	return 0;
}
```

---


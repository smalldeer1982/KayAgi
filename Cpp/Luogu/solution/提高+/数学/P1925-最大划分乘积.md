# 最大划分乘积

## 题目背景

欧拉工程183题 有改动


## 题目描述

Let $N$ be a positive integer and let $N$ be split into $k$ equal parts, $r = N/k$, so that $N = r + r + ... + r$.

Let $P$ be the product of these parts, $P = r ×r × ... × r = rk$.


For example, if $11$ is split into five equal parts, $11 = 2.2 + 2.2 + 2.2 + 2.2 + 2.2$, then $P = 2.2^5 = 51.53632$.




Let $M(N) = P_{\max}$ for a given value of $N$.



It turns out that the maximum for $N = 11$ is found by splitting eleven into four equal parts which leads to $P_{max} = (11/4)^4$; that is, $M(11) = 14641/256 = 57.19140625$, which is a terminating decimal.


However, for $N = 8$ the maximum is achieved by splitting it into three equal parts, so $M(8) = 512/27$, which is a non-terminating decimal.




Let $D(N) = N$ if $M(N)$ is a non-terminating decimal and $D(N) = -N$ if $M(N)$ is a terminating decimal.






## 样例 #1

### 输入

```
10```

### 输出

```
-15```

## 样例 #2

### 输入

```
100```

### 输出

```
2438```

# 题解

## 作者：Great_Influence (赞：9)

高中数学题。

首先，对于固定的数字$N$，可以得到$M$关于划分块数$k$的函数$f(k)=M_N(k)=(\frac{N}{k})^k$。然后开始求导。


对两边同时取对数，得


$Ln[f(x)]=xLn[Nx^{-1}]$


求导，得

$\frac{f^\prime(x)}{f(x)}$

$=Ln(\frac{N}{x})+\frac{-Nx}{x^2}*\frac{x}{N}$

$=Ln(\frac{N}{x})-1$

$=Ln(\frac{N}{ex})$


所以

$f^\prime(x)=f(x)Ln(\frac{N}{ex})$


$=(\frac{N}{x})^xLn(\frac{N}{ex})$


可以知道，当$x>0$时，$(\frac{N}{x})^x$恒大于0

而$Ln(\frac{N}{ex})$为减函数


所以$f^\prime(x)$单调递减，$f(x)$在$(0,+\infty)$有极大值


而$Ln(1)=0$

所以当$\frac{N}{ex}=1$即$x=\frac{N}{e}$时$f^\prime(x)=0$，取得极大值。


然而需要注意，$x$为整数。所以，$x$应该为$\lfloor\frac{N}{e}\rfloor$或者$\lfloor\frac{N}{e}\rfloor+1$

分别计算这两个点对应的函数值取max即可。


不好算？可以对原函数取对数，再比较对数即可。


$Ln[f(x)]=xLn(\frac{N}{x})$


然后便得到了$D(N)=x$。然后需要处理是否无限小数。


这个更简单。容易知道$\frac{a}{b}[gcd(a,b)=1]$为有限小数当且仅当$b=2^{k_1}*5^{k_2}(k_1,k_2\in N)$


所以直接强行把$b$除掉所有的$2$因子和$5$因子就可以了。


注意提前除去$gcd(a,b)$。


代码：

```cpp
    #include<bits/stdc++.h>
    #include<cctype>
    #define For(i,a,b) for(i=(a),i##end=(b);i<=i##end;++i)
    #define Forward(i,a,b) for(i=(a),i##end=(b);i>=i##end;--i)
    #define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)
    #define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=(b);--i)
    using namespace std;
    template<typename T>inline void read(T &x){
        T s=0,f=1;char k=getchar();
        while(!isdigit(k)&&k^'-')k=getchar();
        if(!isdigit(k)){f=-1;k=getchar();}
        while(isdigit(k)){s=s*10+(k^48);k=getchar();}
        x=s*f;
    }
    void file(void){
        #ifndef ONLINE_JUDGE
        freopen("water.in","r",stdin);
        freopen("water.out","w",stdout);
        #endif
    }
    const int MAXN=110001;
    static int n;
    const long double e=2.71828182845904523536;
    inline void init()
    {
        read(n);
    }
    inline long double calc(int f,int x)
    {
        return x*log((long double)f/x);
    }
    inline void solve()
    {
        static int ans1;
        static int ans=0;
        Rep(i,5,n)
        {
            ans1=floor(i/e);
            if(calc(i,ans1)<calc(i,ans1+1))++ans1;
            ans1/=__gcd(ans1,i);
            while(ans1%2==0)ans1/=2;
            while(ans1%5==0)ans1/=5;
            if(ans1!=1)ans+=i;
            else ans-=i;
        }
        printf("%d\n",ans);
    }
    int main(void){
        file();
        init();
        solve();
        return 0;
    }

```

---

## 作者：Karry5307 (赞：6)

### 题意

略。

### 题解

[不一定更好的阅读体验](https://www.cnblogs.com/Karry5307/p/13924487.html)

简单题。

容易看出 $f(x)=\left(\dfrac{n}{x}\right)^x$，考虑求这个东西的极值，看一眼发现是取对数求导法，那么有

$$\ln f(x)=x\ln n-x\ln x$$

所以

$$(\ln F(x))^\prime=\ln n-\ln x-1$$

于是

$$F^{\prime}(x)=F(x)(\ln F(x))^{\prime}=\left(\frac{n}{x}\right)^x(\ln n-\ln x-1)$$

考虑求导数的零点。注意到 $f(x)=\left(\dfrac{n}{x}\right)^x$ 没有零点，所以零点只可能存在于右边的括号中，也即 $x=\dfrac{n}{e}$。

由于最终的 $x$ 只能取整数，所以极值只可能在 $\left\lfloor\dfrac{n}{e}\right\rfloor$ 或 $\left\lceil\dfrac{n}{e}\right\rceil$ 取到，比较两个值可以直接比较对数大小。接下来就很平凡了。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef int ll;
typedef long long int li;
typedef long double db;
const ll MAXN=2e5+51;
const db E=exp(1.0);
ll n,res,lx,rx,g;
inline ll read()
{
    register ll num=0,neg=1;
    register char ch=getchar();
    while(!isdigit(ch)&&ch!='-')
    {
        ch=getchar();
    }
    if(ch=='-')
    {
    	neg=-1;
    	ch=getchar();
	}
    while(isdigit(ch))
    {
        num=(num<<3)+(num<<1)+(ch-'0');
        ch=getchar();
    }
    return num*neg;
}
inline db lnf(ll n,ll x)
{
	return log(1.0L*n)*x-log(1.0L*x)*x;
}
inline ll calc(ll n)
{
	lx=n/E,rx=n/E+1,lx=lnf(n,lx)>lnf(n,rx)?lx:rx,g=__gcd(n,lx),lx/=g;
	while(lx%2==0)
	{
		lx/=2;
	}
	while(lx%5==0)
	{
		lx/=5;
	}
	return lx==1?-n:n;
}
int main()
{
	n=read();
	for(register int i=5;i<=n;i++)
	{
		res+=calc(i);
	}
	printf("%d\n",res);
}
```

---

## 作者：Kreado (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P1925)。

## 思路

题目让我们求函数 $\left(\dfrac{n}{k}\right)^k$ 的极值，其中 $k\in \mathbb{N^+}$。

首先注意到这是一个单峰函数，所以我们可以忽略掉 $k\in\mathbb{N^+}$ 这一限制，先求出一个正有理数 $x$ 使得函数值最大，然后对 $x$ 两边的整数函数值取 $\max$ 即可。

将函数写成以 $e$ 为底数，即 $e^{k\ln \frac{n}{k}}$。

根据链式求导法则可得 $(e^{k\ln \frac{n}{k}})^{'}=\left(\dfrac{n}{k}\right)^k(\ln \left(\dfrac{n}{k}\right)-1)$。

显然的，函数极值的导数为 $0$，我们只需解方程 $\left(\dfrac{n}{k}\right)^k(\ln \left(\dfrac{n}{k}\right)-1)=0$，只有右边括号内的值可能为 $0$，所以 $\ln\left(\dfrac{n}{k}\right)=1$，解得 $k=\dfrac{n}{e}$。

接下来我们直接对 $\biggl\lfloor\dfrac{n}{e}\biggl\rfloor,\biggl\lceil\dfrac{n}{e}\biggl\rceil$ 所得的函数值取 $\max$ 即可。

求出 $k$ 后，$\dfrac{n}{k}$ 为有理数当期仅当 $\dfrac{k}{\gcd(n,k)}$ 只含质因子 $2,5$。

时间复杂度 $O(a\ln a)$，可以通过。

```cpp
#include <bits/stdc++.h>
#define ll long long
#define db double
using namespace std;

const double e=exp(1);
int n; 
ll ans;

int main(){
	scanf("%d",&n);
	for(int i=5;i<=n;i++){
		int x=i,maxx=0;
		int l=x*1./e,r=l+1;
		if((db)l*log(x*1./l)>=(db)r*log(x*1./r)) maxx=l;else maxx=r;
		maxx/=__gcd(maxx,x);
		while(maxx%2==0) maxx/=2;while(maxx%5==0) maxx/=5;
		if(maxx==1) ans-=x;else ans+=x;
	}
	printf("%lld",ans);
	return 0;
}



```


---

## 作者：Alarm5854 (赞：2)

这道题目是一道数学题。当然，这道题目也可以用三分法来求，不过效率要低很多，不过相对简单，接下来介绍一下具体解法。
### 解法1：
直接用三分法求最大值，如何求三分范围，如图。  
![](https://cdn.luogu.com.cn/upload/image_hosting/yv2r67q0.png)  
这是一个单峰函数，可将三分范围调整为 $[1, a]$ 这个区间。

那么，怎么知道这个数是有限小数还是无限小数？这里要用到一个数学知识了：如果一个最简分数的分母的质因数只有2或5，那么这个最简分数可化成有限小数，否则，就是无限小数。


具体解法如下：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline void read(int &x) {//快读
	char c = 0;
	int f = x = 0;
	while (c < 48 || c > 57) {
		if (c == '-')
			f = 1;
		c = getchar();
	}
	while (c > 47 && c < 58) x = (x << 3)+(x << 1)+(c & 15), c = getchar();
	if (f) x = -x;
}
inline void write(int x) {//快写
	if (x < 0) {
		putchar(45);
		write(-x);
		return;
	}
	if (x > 9) write(x / 10);
	putchar((x % 10) | 48);
}
int a, ans;
inline double f(double x, double y) {
	return pow(x / y, y);
}
inline int gcd(int a, int b) {
	return b ? gcd(b, a % b) : a;
}
signed main() {
	read(a);
	for (int i = 5; i <= a; ++i) {
		int res;
		double l = 1, r = i;
		double maxn = 0;
		while (l + 1e-3 < r) {
			double lm = (r - l) / 3 + l;//注意不是(l + r) / 3
			double rm = r - (r - l) / 3;//注意不是(l + r) / 1.5
			double fl = f(i, lm);
			double fr = f(i, rm);
			if (fl <= fr) l = lm;
			if (fl >= fr) r = rm;
		}
		if (f(i, floor(l)) > f(i, ceil(l))) res = floor(l);
		else res = ceil(l);
		res /= gcd(i, res);//别忘记约分
		while (res % 2 == 0) res /= 2;
		while (res % 5 == 0) res /= 5;
		if (res == 1) ans -= i;
		else ans += i;
	}
	write(ans);
	return 0;
}
```
期望得分：60分。（为什么？）
### 解法2：
如图。  
![](https://cdn.luogu.com.cn/upload/image_hosting/p7tui37o.png)  
对于任何大于0的实数 $a,b(a<b)$ 和大于1的实数 $c$，都有 $\log_c(a)<\log_c(b)$，而 $\log_c(a^b)=\log_c(a)\times b$.所以，将解法1的 $f(x,y)$ 改进一下，就可以AC。

改进的 $f(x,y)$ 如下：
```cpp
inline double f(double x, double y) {
	return y * log(x / y);
}
```

时间复杂度：$O(a\log_{\frac{3}{2}}a)$。  
然而，这还不是真正的正解。
### 解法3：
设当 $y$ 为整数，且 $f(x,y)$ 最大时的 $y$ 为 $g(x)$，则可列出以下的表：

| $a$ | $23$ | $24$ | $25$ | $26$ | $27$ |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| $g(a)$ | $8$ | $9$ | $9$ | $10$ | $10$ |
| $a/g(a)$ | $2.875$ | $2.667$ | $2.778$ | $2.600$ | $2.700$ |
其中，$a/g(a)$ 趋近于一个数，这个数就是 $e$，所以正解就出来了。

正解：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline void read(int &x) {
	char c = 0;
	int f = x = 0;
	while (c < 48 || c > 57) {
		if (c == '-')
			f = 1;
		c = getchar();
	}
	while (c > 47 && c < 58) x = (x << 3)+(x << 1)+(c & 15), c = getchar();
	if (f) x = -x;
}
inline void write(int x) {
	if (x < 0) {
		putchar(45);
		write(-x);
		return;
	}
	if (x > 9) write(x / 10);
	putchar((x % 10) | 48);
}
int a, ans;
const double e = exp(1.0);
inline double f(double x, double y) {
	return y * log(x / y);
}
inline int gcd(int a, int b) {
	return b ? gcd(b, a % b) : a;
}
signed main() {
	read(a);
	for (int i = 5; i <= a; ++i) {
		int res;
		double x = i / e;
		if (f(i, floor(x)) > f(i, ceil(x))) res = floor(x);
		else res = ceil(x);
		res /= gcd(i, res);
		while (res % 2 == 0) res /= 2;
		while (res % 5 == 0) res /= 5;
		if (res == 1) ans -= i;
		else ans += i;
	}
	write(ans);
	return 0;
}
```
### 总结：
这道题目我感觉数据范围太小了，可以将范围拓展到 $5\le a\le 3\times 10^6$，可将三分法卡掉。两种方法运行时间如下（本机，比洛谷评测机慢得多，单位：毫秒）：

| $n$ | $3\times10^4$ | $10^5$ | $3\times10^5$ | $10^6$ | $3\times10^6$ | $5\times10^6$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 三分法 | $450$ | $1551$ | $4801$ | $16675$ | $52103$ | $88495$ |
| 数学 | $30$ | $70$ | $200$ | $700$ | $2158$ | $3624$ |
可以看到，三分法的效率比数学的效率低很多。

---

## 作者：Iniaugoty (赞：2)

### 引言

这是一道神奇的题目，因为题号所具有的特殊性，得到了我校团队管理员的青睐，被加入二位数组训练题单（~~真TM看不出这和二维数组有什么关系~~）。

对于我及很多没学过导函数（~~虽然我会~~）的初中蒟蒻来说，其他大佬们的方法过于高深莫测，实在是难以理解，那我来发一篇比较简单的方法吧。
***

### 题意简述

- 对于一个正整数 $n$，设 $k$ 为正整数， $\displaystyle r=\frac{n}{k}$，$P=r^k$，$\operatorname m(n)=\max\{P\}$。

- $\operatorname d(n)=\begin{cases}-n&\operatorname m(n)\text{有限}\\n&\operatorname m(n)\text{无限}\end{cases}$。

- 求 $\displaystyle\sum_{i=5}^{a}\operatorname d(i)$。

- $5\leqslant a\leqslant 32767$。
***

### 题目分析

容易发现，这道题可以分三大步完成：

1.求最大的 $P$；

2.判断有限小数；

3.累加。

#### 1.求最大的 $P$

最难的就是这一步，肿么办呢？

对，你想到了**暴力枚举**，这是个好方法。

用一个循环来枚举原数均分成的份数，部分代码如下：
``` cpp
for(int i=5;i<=a;i++){//大循环，不用说了
    int maxk;//记录P最大时k
    double m;//记录最大的P，即m(n)
    for(int k=1;k<=i;k++){//枚举k
        double p=pow((double)i/(double)k,k);//p
        if(p>m ){//取最大值
            m=p;
            maxk=k;
        }
    }
}
``` 

然而，这样太浪费时间了，即使后面两部分已经优化，上传后的结果仍然4个TLE（本人亲测），要换一种方法。

我们可以分析一下数据：

根据题意，得 $\displaystyle k=\frac{n}{r},P=r^k=r^{\frac{n}{r}}$。

以样例#1为例，如以下链接所示图像（$k$ 为黄线，$P$ 为蓝线）：

[$n=5$](https://zh.numberempire.com/graphingcalculator.php?functions=y%3D5%2Fx%2Cy%3Dx%5E(5%2Fx)&xmin=0&xmax=15&ymin=0&ymax=7.5&var=x)，[$n=6$](https://zh.numberempire.com/graphingcalculator.php?functions=y%3D6%2Fx%2Cy%3Dx%5E(6%2Fx)&xmin=0&xmax=20&ymin=0&ymax=10&var=x)，[$n=7$](https://zh.numberempire.com/graphingcalculator.php?functions=y%3D7%2Fx%2Cy%3Dx%5E(7%2Fx)&xmin=0&xmax=20&ymin=0&ymax=20&var=x)

[$n=8$](https://zh.numberempire.com/graphingcalculator.php?functions=y%3D8%2Fx%2Cy%3Dx%5E(8%2Fx)&xmin=0&xmax=20&ymin=0&ymax=20&var=x)，[$n=9$](https://zh.numberempire.com/graphingcalculator.php?functions=y%3D9%2Fx%2Cy%3Dx%5E(9%2Fx)&xmin=0&xmax=20&ymin=0&ymax=30&var=x)，[$n=10$](https://zh.numberempire.com/graphingcalculator.php?functions=y%3D10%2Fx%2Cy%3Dx%5E(10%2Fx)&xmin=0&xmax=20&ymin=0&ymax=30&var=x)

观察图像，容易发现，$P$ 总是在 $r$ 介于 $2$ 和 $3$ 之间接近于 $3$ 时达到最大。事实上，不论 $n$ 取何值，它永远在趋近于[自然底数 $e$ ](https://baike.baidu.com/item/%E8%87%AA%E7%84%B6%E5%BA%95%E6%95%B0?fromModule=lemma_search-box)（$\approx2.71828$）时达到最大。证明过程较为复杂，~~还他妈要用到导函数~~，就不多说了。因此，对于任意一个 $n$，只要求得 $\displaystyle\frac{n}{e}$ 四舍五入取整，得到的值就是最大的 $k$，$\operatorname m(n)=\displaystyle{(\frac{n}{k})}^k$。

#### 2.判断有限小数

这里有一个性质：对于一个最简分数，当它的分母有且仅有 $2$ 和 $5$ 两个质因数时，这个分数的值为有限小数。

事实上，题目上说 $\operatorname m(n)$ 为有限或无限，其实就是某个 $r$ 为有限或无限（因为 $\operatorname m(n)$ 是某个 $r$ 的正整数次幂）。因此，判断有限小数只需要先化简 $\displaystyle\frac{n}{k}$，然后对 $k$ 一直除以 $2$ 或 $5$，如果最后得到 $1$，说明 $k$ 有且仅有 $2$ 和 $5$ 两个质因数，$\displaystyle\frac{n}{k}$ 为有限小数；否则还有其它质因数，$\displaystyle\frac{n}{k}$ 为无限小数。

至于化简——辗转相除法求最大公因数，再分子分母同除以它。注意：此处较为特殊，分子 $n$ 判断有限小数时用不到，所以不用除，节省时间（虽然节省不了多少，但这不重要！）。（什么你说你辗转相除法都不会，那你还是别做这题去好好打基础罢！）

#### 3.累加

这一部分就不用多说了，建立一个累加器，每次循环就加上这次算出的结果，可以避免开数组浪费空间。
***

### 代码

完整AC代码，~~我知道你们只看这里~~。
``` cpp
#include<bits/stdc++.h>
using namespace std;
const double e=2.71828182845904523536;//自然底数
int gcd(int x,int y){//辗转相除法求最大公因数
    if(x%y==0) return y;
    else return gcd(y,x%y);
}

bool infinite(int k){//判断是否为有限小数
    while(k%2==0) k/=2;
    while(k%5==0) k/=5;
    if(k==1) return 1;
    return 0;
}

int d(int n){//运算d(n)的过程
    int k=round((double)n/e);
    k/=gcd(n,k);
    if(infinite(k)) return -n;
    return n;
}

int main(){//主函数
    int a,sum=0;
    scanf("%d",&a);
    for(int n=5;n<=a;n++) sum+=d(n);
    printf("%d",sum);
    return 0;
}
``` 

---

## 作者：D0000 (赞：1)

模拟退火。几乎不需要任何数学知识。

显然用退火找对于每一个 $x$ 最优的 $k$。唯一需要转化的是如何比较 $a^b$ 和 $c^d$，直接比显然不行。这里先假设二者都大于 $1$，那么 $\log a^b$ 和 $\log c^d$ 的大小关系是一致的，而又有 $\log a^b=b\log a$，证明见末尾。（这里省略底数，底数大于 $1$ 即可，一般用 $2$ 或自然对数的底数）

然后这道题由于 $k$ 是整数，降温下界设成 $1$ 就可以。实测上界 $x$（要求的 $D(x)$)，降温系数 $0.95$ 可以通过。

代码：

```cpp

#include<bits/stdc++.h>
using namespace std;
#define mul(x,y) (log((1.0*x)/(y))*1.0*(y))
int n;
long long ans;
double Rand(){
	return (rand()%1000)*1e-3+(rand()%1000)*1e-6+(rand()%1000)*1e-9+(rand()%1000)*1e-12+(rand()%1000)*1e-15+(rand()%1000)*1e-18;
}
int main(){
	scanf("%d",&n);
	srand(time(0));
	for(int i=5;i<=n;i++){
		double d=0.99,t=i,an=mul(i,2),anan=mul(i,2);
		int ans=2,ansans=2;
		while(t>1e-1){
			int now;
			if(ans==2||(ans<i&&rand()%2))now=ans+(rand()%(min((int)(t)+1,i-ans)));
			else now=ans-(rand()%(min((int)(t)+1,ans-2)));
			double nn=mul(i,now);
			if(nn>anan)an=anan=nn,ans=ansans=now;
			else if(nn>an)an=nn,ans=now;
			else if(Rand()>exp(-(nn-an)/t))an=nn,ans=now;
			t*=d;
		}
		while(ansans%2==0)ansans/=2;
		while(ansans%5==0)ansans/=5;
		if(!(i%ansans))::ans-=i;
		else ::ans+=i;
	}
	printf("%lld",ans);
}

```

### 证明 $\log_k a^b=b\log_k a,(k>1)$

设 $c=\log_k a^b$。

则有：

$$k^c=a^b$$

$$(k^c)^{\frac{1}{b}}=(a^b)^{\frac{1}{b}}$$

$$k^{\frac{c}{b}}=a$$


$$\log_k{k^{\frac{c}{b}}}=\log_k a$$

$$\frac{c}{b}=\log_k a$$

$$c=b\log a$$

证毕。


这就是本篇题解的全部内容。

---------------
### 一些废话

降温系数为 $0.95=19\times25\times0.002\Longrightarrow P1925$。

> $19$ 和 $25$ 走向了不断降温的过程。
>
> 直到几乎为 $0$ . . . . . .
>
>

---

## 作者：Siegerkranz_2735 (赞：1)

#### 简化题意：

求 $(\frac{n}{x})^x$ 的最大值是否为无尽小数。

#### 解决方法：

##### part1:求出 $k$ 的值

首先，通过观察可以将 $(\frac{n}{x})^x$ 重写：

$$e^{x\ln(\frac{n}{x})}$$

容易看出，可以将**链式规则**应用于这一项的求导：

设 $f(v)=e^v$，$g(x)=x\ln(\frac{n}{x})$：

$$\begin{aligned}
(e^{x\ln(\frac{n}{x})})'&=(f(g(x))'(g(x))'\\
&=e^{x\ln(\frac{n}{x})}(ln(\frac{n}{x})-1)\\
&=(\frac{n}{x})^x(ln(\frac{n}{x})-1)
\end{aligned}$$

令 $(e^{x\ln(\frac{n}{x})})'=0$

$$\begin{aligned}
(e^{x\ln(\frac{n}{x})})'&=0\\
(\frac{n}{x})^x(ln(\frac{n}{x})-1)&=0\\
(ln(\frac{n}{x})-1)&=0\\
x&=\frac{n}{e}
\end{aligned}$$

把 $x=\frac{n}{e}$ 带入 $(\frac{n}{x})^x$ 得：

$$(\frac{n}{x})^x=e^\frac{n}{e}$$

![](https://cdn.luogu.com.cn/upload/image_hosting/f9fass6m.png)

##### part2:$k$ 属于正整数

把刚刚证明的结论带入 $11$，计算 $e^\frac{11}{e}$。

[通过计算器的运算](https://mathsolver.microsoft.com/en/solve-problem/%7B%20e%20%20%7D%5E%7B%20%20%60frac%7B%2011%20%20%7D%7B%20e%20%20%7D%20%20%20%20%7D)
可以发现 $e^\frac{11}{e}≈57.206861809$，是一个无理数，且不等于题目中所给的 $57.19140625$！

所以 $k$ 应该是整数，只需要对 $\frac{n}{e}$ 四舍五入即可。

##### part3:判断是否为无穷小数

很明显，当一个最简分数的分母只包含质因数 $2$ 和质因数 $5$ 时，它一定是有穷小数。

对于最简分数 $\frac{a}{b}$ 是不是有限小数,实际上只需要考虑 $\frac{1}{b}$ 是不是有限小数。

设 $h=\frac{1}{b}$，其中 $h$ 是一个有限小数,小数点后有 $n$ 位。

两边同时乘上 $10^n$ 得到:

$$10^nh=\frac{10^n}{b}$$

若我们的假设是真的,即 $h$ 真的是有限小数,那么 $\frac{10^n}{b}$ 应该是一个整数。

对 $10^n$ 质因子分解,得到 $\frac{2^n5^n}{b}$ 必须是个整数，即 $b$ 的质因数应只有 $2$ 和 $5$。

最后不难得到代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, x;long long ans;double e = exp(1);
int main(){
	scanf("%d",&n);
	for(int i=5;i<=n;i++){
		x=(i/e+0.5);int xx=x/__gcd(i, x);
		for(;xx%2==0;xx/=2);
		for(;xx%5==0;xx/=5);
        ans+=(int(xx==1)*(-2)+1)*i;
	}
	printf("%lld\n", ans);
}
```

---

## 作者：Gorenstein (赞：1)

### 题意

设 $P(N,k)=\left(\frac{N}{k}\right)^k,\,M(N)=\max\{P(N,k)\}$。

又设一函数 $D(N)$，若 $M(N)$ 为无尽小数，则 $D(n)=n$，否则 $D(n)=-n$。

给定 $a$，求 $\sum_{i=5}^aD(i)$。

### 题解

对于同一个 $N$，首先设 $f(x)=P(N,x)$，此时 $N$ 为常量。由于显然应当 $x>0$，从而可以：

$$
f(x)=\left(\frac{N}{x}\right)^x=\frac{N^x}{x^x}=\frac{N^x}{\text{e}^{x\ln x}}
$$

则对 $f(x)$ 求导，有：

$$
f'(x)=\frac{(N^{x})'\text{e}^{x\ln x}-N^{x}(\text{e}^{x\ln x})'}{\text{e}^{2x\ln x}}=\frac{N^x\text{e}^{x\ln x}\ln N-N^{x}\text{e}^{x\ln x}(x\ln x)'}{\text{e}^{2x\ln x}}
$$

$$
=\frac{N^x\text{e}^{x\ln x}\ln N-N^{x}\text{e}^{x\ln x}(\ln x+1)}{\text{e}^{2x\ln x}}=\frac{N^{x}(\ln N-\ln x-1)}{\text{e}^{x\ln x}}
$$

$$
=\left(\frac{N}{x}\right)^x(\ln N-\ln x-\ln \text{e})=\left(\frac{N}{x}\right)^x\ln\frac{N}{\text{e}x}
$$

令 $f'(x)=0$，则需要使 $\left(\frac{N}{x}\right)^x$ 或 $\ln\frac{N}{\text{e}x}$ 为 $0$。从而易解得 $x=\frac n e$。

然后肉眼观察目测得到 $f'(x)$ 在零点附近局部为减函数，故而应当在 $x$ 为 $\lfloor\frac n e\rfloor$ 或 $\lceil\frac n e\rceil$ 时得到 $M(N)$。从而对比二者大小。同时由于 $x$ 次幂不会影响是否有限，从而只需判断 $\frac n e$ 是否有限即可。

从而计算函数 $D(x)$ 的代码如下：

```cpp
ll D(ll x){
	ll A=x/e,B=x/e+1,res;
	LD lA=A*log(1.0L*x)-A*log(1.0L*A);
	LD lB=B*log(1.0L*x)-B*log(1.0L*B);
	if(lA>lB)res=A;else res=B;
	res/=gcd(x,res);
	while(res%2==0)res/=2;
	while(res%5==0)res/=5;
	return res==1?-x:x;
}
```

然后做一遍求和即可。

---

## 作者：buowen123 (赞：1)

## 题目大意：

对于 $5\le n\le a$ ，求 $(\dfrac{n}{x})^x$ 的最大值是不是有限小数。

## 题目解决：

**说在前头，** 本题要运用“导数”的知识，因此，高一及以下的看不懂正常。

本题三分也可做，看不懂可以移步其他题解。

### 1.求 $x$ 

我们考虑对原式求对数，得

$$f(x)=\ln(\dfrac{n}{x})^x=x\ln(\dfrac n x)=x\ln n-x\ln x$$

那么对它求导，可得 
$$f'(x) = \ln n-\ln x-1$$

因此 $f(x)$ 在 $(-\infty,\dfrac n e)\uparrow,(\dfrac n e,+\infty)\downarrow$，其零点为 $\dfrac n e$。

但是 $\dfrac n e$ 不是整数，因此 $\left\lfloor\dfrac{n}{e}\right\rfloor$ 或 $\left\lceil\dfrac{n}{e}\right\rceil$ 时原式取最大值。

因此，考虑以 $\dfrac n e$ 四舍五入的值作为 $x$。

### 2.判断有限

这时的分数已经确定了，为 $\dfrac{n^x}{x^x}$。

它是有限小数吗？可以通过判断 $\dfrac{n}{x}$ 是不是有限小数来得到。

把它化成最简分数 $\dfrac{n'}{x'}$，然后判断 $x'$ 有没有除了 $2,5$ 以外的质因子。如果有，则它是无限小数，否则不是。

**注意约分，不要忘了。**

```cpp
#include <bits/stdc++.h>
using namespace std;
double e = 2.7182818284590452353602874;
int a, ans = 0;

int gcd (int x, int y)
{
	return (!y) ? x : gcd (y, x % y);
}

int main ()
{
	cin >> a;
	for (int i = 5; i <= a; i++)
	{
		double x = i / e;
		int y = round (x);
		y /= gcd (y, i);
		while (y % 2 == 0)
		{
			y /= 2;
		}
		while (y % 5 == 0)
		{
			y /= 5;
		}
		if (y == 1)
		{
			ans -= i;
		}
		else
		{
			ans += i;
		}
	}
	cout << ans << endl;
   return 0;
}
```

---

## 作者：vеctorwyx (赞：0)

### ~~天天数学课做导数我快做吐了~~

首先要求一个 $x$ 使得 $( \dfrac{N}{x})^x$ 最大。

设 $g(x) = ( \dfrac{N}{x})^x$；

设 $ f(x) = \ln g(x) = x\ln ( \dfrac{N}{x}) = x(\ln(N) - \ln(x))$ （放缩），求导得：

$$\large f'(x) = \ln(N) - 1 - \ln(x)$$

当 $f'(x) = 0$ 时，解得 $x = \dfrac {N}{\mathrm{e}}$ 。

当 $x < \dfrac {N}{\mathrm{e}}$ 时，$f'(x) > 0$ ， $f(x)$ 单调递增；

当 $x > \dfrac {N}{\mathrm{e}}$ 时，$f'(x) < 0$ ， $f(x)$ 单调递减。

则 $f(x)$ 在 $x = \dfrac {N}{\mathrm{e}}$ 出有极大值，~~易知~~ $g(x)$ 在 $x = \dfrac {N}{\mathrm{e}} $ 处也有极大值。

~~由题意得~~， $x$ 必须是整数， 那么对 $ \dfrac {N}{\mathrm{e}}$ 四舍五入就是 $x$ 的取值。

由于取 $x$ 次幂不会影响 $( \dfrac{N}{x})$ 是否有限， 只需判断 $( \dfrac{N}{x})$ 是否有限。

--------------------

第二个问题是求 $( \dfrac{N}{x})$ 是否有限。

先把$( \dfrac{N}{x})$ 化到最简，然后判断分母是否有 $2,5$ 以外的因子，若有则为无限小数， 若无则为有限小数。

--------------------

推出结论后代码还是很好写的。

code：

```
#include<bits/stdc++.h>
using namespace std;
int n, x;
double e = exp(1);
int gcd(int x, int y){
	if(!y)
		return x;
	return gcd(y, x % y);
}
long long ans;
signed main(){
	scanf("%d", &n);
	for(int i = 5; i <= n; i++){
		x = (i / e + 0.5);
		int gd = gcd(i, x);
		int nn = i / gd, xx = x / gd;
		bool flag = 0;
		while(xx % 2 == 0)
			xx /= 2;
		while(xx % 5 == 0)
			xx /= 5;
		if(xx == 1)
			ans -= i;
		else
			ans += i;
	}
	printf("%lld\n", ans);
}
```

---

## 作者：bliss_bug (赞：0)

## 题解
这道题用到一点导数和数论的知识，很容易看出这道题是求函数
$$ f(x)=(\frac{n}{x})^{x}  $$
（ $x$ 为正整数）的最大值。我们可以对 $ln(f(x))$ 进行求导，求出     $ln(f(x))$ 的最大值。
$$ln(f(x))=x(lnn-lnx)$$
$$(ln(f(x)))'=lnn-lnx-1$$
 $ln(f(x))$ 的最大值必然在 $\lfloor \frac{n}{x} \rfloor$ 和 $\lceil \frac{n}{x} \rceil$ 中取得。所以只需将这两个值代入去较大值即可。
对于两数相除是否为有限小数,只需将 $x$ 除以 $\gcd(n,x)$ 之后，再判断其能否表示为 $2^{p_{1}}\times 5^{p_{2}}\ (p_{1}\in N,p_{2}\in N)$ ，能表示则代表其为有限小数。

## 代码
```cpp
#include<iostream>
#include<algorithm>
#include<cmath>
using namespace std;
const double e = exp(1.000);

int gcd(int a, int b)
{
	return (b == 0) ? a : gcd(b, a % b);
}

double cc(int n, int x)
{
	return (double)x * log((double)n / x);
}

int calc(int n)
{
	int x1 = n / e, x2 = n / e + 1;
	int x = cc(n, x1) > cc(n, x2) ? x1 : x2;
	int p = gcd(n, x);
	x /= p;
	while (x % 2 == 0)
		x /= 2;
	while (x % 5 == 0)
		x /= 5;
	return (x == 1) ? -n : n;
}

int main()
{
	int a;
	cin >> a;
	int res = 0;
	for (int i = 5; i <= a; i++)
		res += calc(i);
	cout << res;
	return 0;
}
```


---


# 高维正方体

## 题目描述

$0$ 维空间的元素是点，这个毋庸置疑。

- $2$ 个 $0$ 维空间的元素可以围成一个 $1$ 维空间的元素，线段。
- $4$ 个 $1$ 维空间的元素可以围成一个 $2$ 维空间的元素，正方形。
- $6$ 个 $2$ 维空间的元素可以围成一个 $3$ 维空间的元素，正方体。
- $8$ 个 $3$ 维空间的元素可以围成一个 $4$ 维空间的元素，超正方体。

……

- 一个正方形中，有 $4$ 个（顶）点，$4$ 条线段（边），$1$ 个正方形。
- 一个正方体中，有 $8$ 个（顶）点，$12$ 条线段（棱），$6$ 个正方形（面），$1$ 个正方体。

……

我们的问题是：给出 $a$ 与 $b$，请求出：在 $a$ 维空间的元素中，包含着多少个 $b$ 维空间的元素。答案可能很大，只需要输出它除以 $10^9+7$ 的余数。

## 说明/提示


### 样例解释

$3$ 维空间的元素是正方体，$1$ 维空间的元素是线段。所求即是一个正方体中棱的数量，为 $12$。

### 数据范围及约定

- 对于 $5\%$ 的数据，$a,b \le 1$；
- 对于 $10\%$ 的数据，$a,b \le 2$；
- 对于 $20\%$ 的数据，$a,b \le 3$；
- 对于 $35\%$ 的数据，$a,b \le 4$；
- 对于 $70\%$ 的数据，$a,b \le 1000$；
- 对于 $100\%$ 的数据，$0\le a,b \le 100000$。

此外，对于 $15\%$ 的数据，$b=0$，对于各 $10\%$ 的数据，$b=1$ 或 $b=2$。

### 提示

不保证 $a \ge b$。

## 样例 #1

### 输入

```
3 1```

### 输出

```
12```

# 题解

## 作者：ghj1222 (赞：29)

神仙题

分析法是个好方法

反正xjb分析就分析出来了

首先，i维立方体的点数(0维元素数)为$2^i$

首先0维肯定是1(不就是一个点吗)

你想想你是怎么用点拼成线段的

你把两个点往地上一扔

然后中间连一条线

就完事儿了

然后你再想想你是怎么用线段拼成正方形的

你把两个长度相等的线段 往地上一方 摆成平行且间距等于他们长度 然后不就成了一个正方形了吗

然后你再想想你是怎么用正方形拼成正方体的

把两个全等的正方形 一个放下面 一个放上面 让这两个面平行 且间距等于正方形边长

由此

由i维立方体 拼成i+1维立方体

点数乘以2(因为每次你都是拿两个i维立方体拼成i+1维立方体)

所以i维立方体的点数(0维元素数)为$2^i$

然后递推求出i维立方体j维元素数，为了方便我们设为$f[i][j]$

则$f[i][0]=2^i$(刚才推得)

然后其余的怎么推

不好想

我们考虑i=3的情况

i=3,j=0的时候，$f[3][0]=8(2^3=8)$

然后考虑三维的立方体

每个顶点可以延伸出 三条边

而每条边连结2个顶点

根据某原理，$\displaystyle f[3][1]=\frac{f[3][0]*3}{2}=12$

然后呢每个边可以延伸出2个面

每个面连接着4个边

所以$\displaystyle f[3][2]=\frac{f[3][1]*2}{4}=6$

然后呢每个面 连接着1个正方体

没个正方体 连接6个面

所以 $\displaystyle f[3][3]=\frac{f[3][2]*1}{6}=1$

然后就找到规律了

$\displaystyle f[3][j]=\frac{f[3][j-1]*(4-j)}{2*j}$

然后呢推广到多维的情况

$\displaystyle f[i][j]=\frac{f[i][j-1]*(i+1-j)}{2*j}$

大功告成

复杂度$O(nm)$?放气儿

由于我们只求一个数，而且递推方程是在一行上递推的

所以我们先求出$f[n][0]$然后$\displaystyle f[n][i]=\frac{f[n][i-1]*(n+1-i)}{2*i}$

复杂度$O(m)$

由于需要取模

所以除法改为乘法逆元

由于1e9+7是素数

所以用快速幂/fermat小定理

一开始的$f[n][0]=2^n$也用快速幂

就行了

时间复杂度乘以一个log

代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define p 1000000007
int f[100010], n, m;

int qpow(int x, int y)
{
    int ans = 1;
    while (y > 0)
    {
        if (y & 1)
            ans = (1LL * ans * x) % p;
        x = (1LL * x * x) % p;
        y >>= 1;
    }
    return ans;
}

int main()
{
	scanf("%d%d", &n, &m);
	f[0] = qpow(2, n);
	for (int i = 1; i <= m; i++)
		f[i] = (1LL * f[i - 1] * (n - i + 1)) % p * qpow(2 * i, p - 2) % p;
	printf("%d\n", f[m]);
	return 0;
}
```

虽然慢了点

但是好分析

吊打各种lucas定理

让我们一起膜拜大佬林瑞堂@[olinr](https://www.luogu.org/recordnew/lists?uid=olinr&pid=&status=&sort=undefined)

---

## 作者：0x3F (赞：11)

>数学上来先打表。

打表发现：

|  | 点 | 线 | 面 | 体 |
| -----------: | -----------: | -----------: | -----------: | -----------: |
| 点 | $1$ | $0$ | $0$ | $0$ |
| 线 | $2$ | $1$ | $0$ | $0$ |
| 面 | $4$ | $4$ | $1$ | $0$ |
| 体 | $8$ | $12$ | $6$ | $1$ |

发现规律了吗？如果设在 $a$ 维空间内 $b$ 维空间的元素个数为 $f_{a, b}$，则有：

$$f_{a, b} = f_{a-1, b-1} + 2f_{a-1, b}$$

这个可以感性理解一下：要构造一个 $a$ 维的空间，需要 $2$ 个 $a-1$ 维的空间对应点相连。

此时原先 $a-1$ 维空间内的 $b$ 维空间元素被复制了一遍，于是乘了 $2$,即 $2f_{a-1, b}$。

另一方面，原先 $a-1$ 维空间内的 $b-1$ 维空间元素对应点相连，就得到了一个 $b$ 维空间元素， 即 $f_{a-1, b-1}$。

所以呢？ $\Theta(a^2)$ DP 一遍？肯定不行。

重新看一遍上面这个式子，发现 $f_{a, b}$ 就是 $(x+2)^a$ 的 $b$ 次项系数。

于是我们利用二项式定理算一下，$f_{a, b}$ 的通项为 $2^{a-b} \times C_a^b$。即：

$$f_{a, b} = 2^{a-b} \times \frac{a!}{b!(a-b)!}$$

费马小定理求逆元。

然后就没有然后了。

代码里面有三个坑哦，请注意查看！

```cpp
#include <bits/stdc++.h>
#define ll long long
#define mod 100000007
using namespace std;

int n, m;
ll ans;

ll qp(int a, int b) {
	if (b == 0) return 1;
	ll k = qp(a, b<<1);
	k = k * k % mod;
	if (b & 1) return k * a % mod;
	else return k;
}

int main() {
	cin >> n >> m;
	ans = qp(2, n);
	for (register int i = 1; i <= m; i++) {
		ans = ans * 500000004 % mod * (n + i + 1) % mod * qp(i, mod - 2) % mod;
	}
	cout << ans << endl;
	return 0;
}
```

码风奇丑，请见谅。

---

## 作者：SunsetSamsara (赞：4)

首先,这题标签是数学,那我们就用数学做吧.

接下来就可以开始分析了

------------

首先考虑特殊情况

+ 一个 $n$ 维立方体会有多少 $n$ 维立方体呢?

肯定 $1$ 个（废话）

+ 一个 $n$ 维立方体会有多少 $0$ 维立方体呢?

容易发现多一维就多 $1$ 倍，所以有 $2^n$ 个

------------

接下来怎么办呢？ ~~枚举,暴力,乱搞,骗分万岁 ~\(≧▽≦)/~~~

我们发现每个 $n$ 维正方体上的点能引出 $1$ 个点，$n$ 条线，而 $n$ 条线任意 $2$ 条都能连成一个正方形，即 $C^2_n$ 个正方形,任意 $3$ 条线都能形成一个正方体……以此类推,发现每个 $n$ 维正方体上的点都能形成 $C^n_m$ 个 $m$ 维正方体。

所以直接乘起来的话就是 $n \times C^n_m$ 个 $m$ 维正方体，但是会有重复！那么就需要去重。

因为一个 $m$ 维正方体有 $2^m$ 个点，只需要除以 $2^m$ 就可以了。

最后经过计算与化简得到有 $C^n_m \times 2^{n-m}$ 个

接下来就是简单的计算组合数了,我们可以利用 乘法逆元去算组合数。

组合数代码：

```c
/*快速幂*/ 
lld qpow(lld a,lld b){
	a%=mod;lld ans=1;
	for(;b;b>>=1,a=a*a%mod)
		if(b&1)ans=ans*a%mod;
    return ans;
}
/*二项式系数*/ 
lld C(int n,int m){
	lld ans1=1,ans2=1;
	for(int i=n-m+1;i<=n;++i)ans1=ans1*i%mod;
	for(int i=1;i<=m;++i)ans2=ans2*i%mod;
	return ans1*qpow(ans2,mod-2)%mod;
}
```

最后，$a<b$ 时结果是 $0$，特判过去。

下面是完整代码

```c
#include<stdio.h>
#define lld long long
#define mod 1000000007
/*快速幂*/ 
lld qpow(lld a,lld b){
	a%=mod;lld ans=1;
	for(;b;b>>=1,a=a*a%mod)
		if(b&1)ans=ans*a%mod;
    return ans;
}
/*二项式系数*/ 
lld C(int n,int m){
	lld ans1=1,ans2=1;
	for(int i=n-m+1;i<=n;++i)ans1=ans1*i%mod;
	for(int i=1;i<=m;++i)ans2=ans2*i%mod;
	return ans1*qpow(ans2,mod-2)%mod;
}
int main(){
	int a,b;
	scanf("%d%d",&a,&b);
	if(a<b){
		puts("0");//a<b答案就是0 
		return 0;
	}
	printf("%lld\n",C(a,b)*qpow(2,a-b)%mod);//见解析 
	return 0;
}
```

---

## 作者：zqy1018 (赞：4)

给出一种这个题的思考方法吧...

设f(i,j)表示i维超立方体中j维元素的个数。

先思考：点的个数如何变化？

很显然，每升一维，点的个数就多一倍，故f(i,0)=2^i。

而根据规律可以看出，某一维在升维之后，他自己这一维复制了一份，同时原来比他小一维德元素也升为了他这一维。

故得到递推关系：f(i,j)=f(i-1,j)\*2+f(i-1,j-1)。

结合以上两个方程，很容易想到这是一个O(n^2)的dp。

但显然不行。这么做复杂度大的太可怕。

可以发现，这个递推模型和杨辉三角很像。所以我们写一下：

 ![](https://cdn.luogu.com.cn/upload/pic/5771.png) 

观察发现，每一斜列都构成一个高阶等差数列。

换言之，第q个斜列上的数都可以表示成一个q-1次多项式。

计算后可以发现，对于同样的q，右边的第k个位置的数总是比左边的同样位置的数大2^(q-1)

倍。
 ![](https://cdn.luogu.com.cn/upload/pic/5772.png) 

根据这个就可以发现，下面每一个数的通项为C(i,j)\*2^(i-j)

所以答案就是C(a,b)\*2^(a-b)。

之后组合数取模什么的拿线性逆元做即可。

```cpp
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <cstring>
#include <cctype>
#define P 1000000007ll
using namespace std;
typedef long long ll;
ll a,b,inv[100005];
ll q_pow(ll a,ll b){
    ll res=1;
    while(b){
        if(b&1)res=(res*a)%P;
        a=(a*a)%P,b>>=1;
    }
    return res;
}
void init(){
    scanf("%lld%lld",&a,&b);
}
void solve(){
    if(a<b){
        printf("0\n");
        return ;    
    }//特判
    inv[1]=1;
    for(ll i=2;i<=100000;i++)
        inv[i]=(P-(P/i))*inv[P%i]%P;//逆元
    ll ans=q_pow(2,a-b);
    for(int i=1;i<=b;i++)
        ans=ans*(a-i+1)%P,
        ans=ans*inv[i]%P;
    printf("%lld\n",ans);
}
int main(){
    init();
    solve();
    return 0;
}
```

---

## 作者：bmatrix (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P1999)

初中数学老师在平面几何的第一节课就和我们说过：

>点动成线，线动成面，面动成体。

即，由 $i-1$ 维元素变化到 $i$ 维的过程，就可以认为是将 $i-1$ 维物体沿第 $i$ 个方向平移的过程。

因此我们考虑一个二维的正方形平移得到三维的正方体的过程：

![](https://cdn.luogu.com.cn/upload/image_hosting/r3p8qr07.png)

如果我们以平面的个数作为研究对象，不难看出，正方体中存在的平面有如下两个来源：

1. **原来图形中的平面**在经过平移后**数量翻倍**
2. **原来的图形中的每一条线段**在经过平移后**都生成一个新的平面**

推广到普遍结论：
1. **$i-1$ 维元素中的 $j$ 维元素**在经过平移后**数量翻倍**
2. **$i-1$ 维元素中的 $j-1$ 维元素**在经过平移后**都生成一个新的 $j$ 维元素**

因此，如果我们设 $f_{i,j}$ 为一个 $i$ 维物体中 $j$ 维元素的数量，并把不存在的元素，如 $f_{i,-1}$ 和 $f_{i,i+1}$ 等都看作 $0$ ，我们可以得出如下递推式：
$$f_{0,0}=1$$
$$f_{i,j}=2f_{i-1,j}+f_{i-1,j-1}$$

优化一下空间，我们可以写出如下的代码：
```cpp
f[0][1]=1;//为了防止负下标溢出，将j统一加一
for(int i=1;i<=a;i++)
    for(int j=i+1;i>0;j--)
        f[j]=(2*f[j]+f[j-1])%Mod;
cout<<f[b+1]<<endl;
```
但是由于时间复杂度太过爆炸TLE了五个点……

接下来可以考虑根据生成函数优化：

设 $F_i(x)$ 为第 $i$ 行的生成函数，根据上述递推式，有：
$$F_0(x)=1$$
$$F_i(x)=(x+2)F_{i-1}(x)$$
可以得出：
$$F_i(x)=(x+2)^i$$
则有：
$$f_{i,j}=[j](x+2)^i$$
根据二项式定理： 
$$(a+b)^n=\sum_{i=0}^n \binom{n}{i}a^ib^{n-i}$$
则有：
$$f_{i,j}=\binom{i}{j}2^{i-j}$$

因此只需要 $O(n)$ 分别求出阶乘和阶乘的逆元即可。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ll;
ll fac[100005]={1},inv[100005];
constexpr ll Mod=1e9+7;
ll qpow(ll a,ll b){//快速幂
    ll ans=1;
    while(b){
        if(b&1)ans=ans*a%Mod;
        a=a*a%Mod;
        b>>=1;
    }
    return ans;
}
int main(){
    int a,b;cin>>a>>b;
    if(a<b)return cout<<0,0;
    for(int i=1;i<=a;i++)fac[i]=fac[i-1]*i%Mod;
    inv[a]=qpow(fac[a],Mod-2);//费马小定理
    for(int i=a-1;i>=0;i--)inv[i]=inv[i+1]*(i+1)%Mod;
    cout<<qpow(2,a-b)*fac[a]%Mod*inv[b]%Mod*inv[a-b]%Mod;
    return 0;
}
```

---

## 作者：wanghanjun (赞：2)

很多篇题解都看不懂，我来说一下自己的看法。。

4维、5维这些高维空间我们肯定想象不了，但是我们也可以选择不去想高维空间，而是直接用坐标系来表达这个高维正方体。

然后我们建好了坐标系，不妨就设正方体一角坐标为(0,0,0,...,0)，其对角坐标为(1,1,1,...,1)，那我们就只需要想如何表示其包含的低维空间的正方体了。

可以发现，你选定一个点A，给其中x个元素加1，得到点B，以A、B为对角的立方体就是一个x维立方体。举个例子，有一点A(0,1,1,0)，你想要一个2维的正方形，你可以选0,1,1,0中的两个数加1，例如B(1,2,1,0)，但由于要求在高维正方体内，所以加完之后不能超过1，所以只有(1,1,1,1)一种排法。

最后可以总结规律了，当给定A点坐标时，B点的可能坐标数取决与A点中元素0的个数，又由排列组合可得，若A中又x个0，且需要y个0变成1 ，则有这么多种B：
$$C^{y}_{x}$$ 
由排列组合，当A是z维，A中有x个1的A的个数是：
$$C^{x}_{z}$$
所以，共有这么多个：
$$\sum_{i=0}^{a-b}C^{i}_{a}*C^{b}_{a-i}$$
又因为
$$C^{m}_{n}=n!/(m!*(n-m)!)$$
所以预处理一下阶乘，再用一下逆元就好了

Code：
```cpp
#include <iostream>
#include <cstdio>
using namespace std;

typedef long long ll;
const ll MAXN=100005;
ll c[MAXN],a,b,mod=1000000007,x,y,ans=0;

ll exgcd(ll p,ll q){
	if(q==0){
		x=1;
		y=0;
		return p;
	}
	ll g=exgcd(q,p%q),t=x;
	x=y;
	y=t-(p/q)*y;
	return g;
}

ll C(ll n,ll m){
	if(n<m){
		return 0;
	}
	ll p=c[n],q=c[m]*c[n-m]%mod;
	int g=exgcd(q,0-mod);
	if(g<0){
		x=0-x;
	}
	x=(x%mod+mod)%mod;
	return x*p%mod;
}

int main(){
	cin>>a>>b;
	c[0]=1;
	for(int i=1;i<=max(a,b);i++){
		c[i]=c[i-1]*i%mod;
	}
	for(int i=0;i<=a-b;i++){
		ans=(ans+C(a,i)*C(a-i,b))%mod;
	}
	cout<<ans<<endl;
	return 0;
}
```


---

## 作者：改名但没卡67 (赞：1)

写一个题解没有的思路。

说实话，这题真的很水。

只能说挺有意思的一道题吧。

题目描述：

0 维空间的元素是点，这个毋庸置疑。

2 个 0 维空间的元素可以围成一个 1 维空间的元素，线段。

4 个 1 维空间的元素可以围成一个 2 维空间的元素，正方形。

6 个 2 维空间的元素可以围成一个 3 维空间的元素，正方体。

8 个 3 维空间的元素可以围成一个 4 维空间的元素，超正方体。

$\cdots$

一个正方形中，有 4 个（顶）点，4 条线段（边），1 个正方形。

一个正方体中，有 8 个（顶）点，12 条线段（棱），6 个正方形（面），1 个正方体。

$\cdots$

我们的问题是：给出 $a$ 与 $b$，请求出：在a维空间的元素中，包含着多少个 $b$ 维空间的元素。答案可能很大，只需要输出它除以 1000000007 的余数。

看到这题我们第一眼当然想到找规律。

首先，一个很显然的规律：一个 $x$ 维空间的元素需要 $2 \times x$ 个 $x - 1$ 维的元素组成。

那么根据这个规律，我们就会想，那四个一维元素组成一个二维元素，一维元素有 2 个顶点 1 条边，那二维元素应该有 8 个顶点 4 条边呀？为什么它只有 4 个顶点 4 条边呢？

看到点少了，我们自然想到容斥。

从容斥角度思考，我们发现有一些低维的元素是被重复利用的，比如零维的点，在一维上一个零维点引导一条一维线段，在二维上一个零维点引导两条二维线段，在三维上引导三条。然后我们继续扩展，发现一维线段也被更高维度的元素重复利用，在二维上一条一维线段属于一个面，在三维上属于两个面。

于是我们得到了很简单的性质：一个 $x$ 维的元素在 $n$ 维会被 $(n - x)$ 个$(x + 1)$ 维的元素利用。

由此我们再根据一开始退的规律：一个 $x$ 维空间的元素需要 $2 \times x$ 个 $x - 1$ 维的元素组成，直接将需要多少元素倒着递推过去即可。

总之就是一个 $x$ 维的东西在 $n$ 维会被 $(n - x)$ 个 $(x + 1)$ 维的东西用 

具体看代码理解吧。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<cmath>
#define int long long
#define rad scanf
using namespace std;
const int mod = 1e9 + 7, kM = 1e6 + 10;
int shu[kM], inv[kM], a, b;
void init()
{
	inv[0] = inv[1] = 1;
	for(int i = 2; i <= a - b; i++)
	{
		inv[i] = ((mod - mod / i) * inv[mod % i] + mod) % mod;
	}
}
signed main()
{
//	freopen("course.in", "r", stdin);
//	freopen("course.out", "w", stdout);
	rad("%lld%lld", &a, &b);
	if(b > a)
	{
		cout<<0;
		return 0;
	}
	init();
	int base = b * 2;
	int shu = 1;
	for(int i = a; i >= b + 1; i--)
	{
		shu = shu * (((2 * i) * inv[(a - (i - 1))]) % mod) % mod;
	}
	cout<<(shu + mod) % mod;
	return 0;
}
/*
3 1
*/
```


---

## 作者：aleph_blanc (赞：1)

大佬们都是二项式定理啊，那我来个找规律好了。

机房模拟赛考到了这题，入手一瞅，emm... 找规律？

容易发现一个 $n$ 维体，由 $2n$ 个 $n-1$ 维体构成，那么对于询问 $y$ 维体由多少 $x$ 维体构成，粗暴的方法是一路乘过去，但很明显会有一些 $x$ 维体是多次利用的（比如一个正方体里每条棱被两个平面利用），计算过程中肯定要消去这些重复的。

我们以正方体为例，平面不会被重复利用，线会被利用两次，点会被利用三次，大胆猜想，得出规律，对于一个 $x$ 维体上的 $y$ 维体，会被利用 $x-y$ 次，计算的时候除掉就行。

当然别忘了特判（我就因为这个挂了20 /kk）。

```cpp
#include <bits/stdc++.h>

#define N 100010
#define int long long
#define mod 1000000007

using namespace std;

template <typename T>
inline void read (T &a) {
	T x = 0, f = 1;
	char ch = getchar ();
	while (! isdigit (ch)) {
		(ch == '-') and (f = 0);
		ch = getchar ();
	}
	while (isdigit (ch)) {
		x = (x << 1) + (x << 3) + (ch xor '0');
		ch = getchar ();
	}
	a = f ? x : -x;
}
template <typename T, typename ...A>
inline void read (T &t, A &...a) {
	read (t), read (a...);
}
template <typename T>
inline void print (T x) {
	if (x < 0) putchar ('-'), x = -x;
	if (x > 9) print (x / 10);
	putchar (x % 10 + '0');
}

int k[N], a, b, c, ans, inv[N];
inline void Inv () {
    inv[1] = 1;
    for (int i = 2; i <= b; i++) {
        inv[i] = (mod - mod / i) * inv[mod % i] % mod;
    }
}

signed main () {
//	freopen ("course.in", "r", stdin);
//	freopen ("course.out", "w", stdout);
	read (b, a);
	if (b == a) {
		cout << 1;
		return 0;
	}
	if (b < a) {
		cout << 0;
		return 0;
	}
	Inv ();
	for (int i = 1; i <= b; i++) k[i] = (i << 1);
	ans = k[b], c = 1;
	while (b) {
		if (b == a + 1) {
			print (ans % mod);
			return 0;
		}
		c++, b--;
		ans = ans * k[b] % mod * inv[c] % mod;
	}
}
```


---

## 作者：Armin (赞：1)

# 思路
>* 仔细观察
>* 4 4 1 
>* 8 12 6 1 
>* 可以看出他们的共同点就是一个是$(x+2)^2$的展开式系数，一个是$(x+2)^3$的展开式系数，这时候我们就大胆的猜测$n$维立方体里包含的比他低维度的立方体个数就是$(x+2)^n$的展开式的系数，a维空间的元素中包含个b维空间的元素的个数就是$(x+2)^a$的展开式中$x^b$的系数。(事实证明是对的)
* 根据二项式定理，我们就得到了公式
$$solve(a,b)=C_a^b\cdot2^{a-b}=\frac{a!}{b!(a-b)!}\cdot2^{a-b}$$
* 由于$C_a^b2$和$2^{a-b}$都太大了，但是由于要取模，我们就可以分别用逆元和快速幂求得值。
* 数据用long long来存，否则会爆精度。
* 逆元和快速幂详见另一篇博客：[数论笔记本](http://x-armin.com/%E6%95%B0%E8%AE%BA%E7%AC%94%E8%AE%B0%E6%9C%AC/)

# 代码
```c
//#include<bits/stdc++.h>
#include<iostream>
#include<algorithm>  
#include<string.h>  
#include<string>   
#include<stdio.h>
#include<stdlib.h>
#include<math.h>
using namespace std;
#define CRL(a) memset(a,0,sizeof(a))
#define MAX 0xfffffff
typedef unsigned long long LL;
typedef  long long ll; 
const double Pi = acos(-1);
const double e = 2.718281828459;
const int mod =1e9+7; 

ll fac(ll x)		//阶乘 
{
	ll ans=1;
	for(int i=1;i<=x;i++)
		ans=(ans*i)%mod;
	return ans;
}

ll x,y;
ll exgcd(ll a,ll b)		//扩展欧几里德求逆元 
{
    if(b==0)
    {
        x=1;y=0;
        return a;
    }
    ll r=exgcd(b,a%b);
    ll c=x;
    x=y;
    y=c-a/b*y;
    return r;
}

ll qpow(ll a,ll b)		//快速幂 
{
    ll ans=1;
    a%=mod;
    while(b>0)
    {
        if(b&1)
            ans=(ans*a)%mod;
        b/=2;
        a=(a*a)%mod;
    }
    return ans;
}

int main()
{
	int a,b;ll ans;
	while(cin>>a>>b)
	{
		if(a<b) ans=0;              //特判
		else
		{
			exgcd((fac(b)*fac(a-b))%mod,mod);
			x= x<=0? x+=mod:x;						//保证x>0 
			ans=(((fac(a)*x)%mod)*qpow(2,a-b))%mod;
		}
			cout<<ans<<endl;
	}
	return 0;
}
```

---

## 作者：初云悕 (赞：0)

神dfc曾经在一道平面分割空间的初赛题前云：$n$ $=$ $4$ 的情况不是随便yy吗？

不过私以为这道题 $n$ $=$ $4$ 的情况并不是那么好yy的 ， 被神dfc脑补爆切的题的正解是找规律推公式 ， 这道题也多半是这样。

我们借助仅有的几个样例来找找规律：

设该高维正方体是 $n$ 维立方体

列出表：

| n | 点 | 线 | 面 | 体 |
| -----------: | -----------: | -----------: | -----------: | -----------: |
| 0 | 1 | / | / | / |
| 1 | 2 | 1 | / | / |
| 2 | 4 | 4 | 1 | / |
| 3 | 8 | 12 | 6 | 1 |

可以发现，每一列都是递增的，有点像杨辉三角。

杨辉三角可以看作是 $(x+y)^n$ 的各项系数，稍微想一下就可以发现，把 $y$ 替换成一个常数可能可以符合上述打出的表。

然后就可以用非常不严谨的推理方式找出表的规律 ~~oier不需要证明~~  ,$(x+2)^n$ 的各项系数。

这个东西显然可以用**二项式定理**求出某一项的系数。

然后再看一眼数据范围 $a,b$ 是在 $1e5$ 以内的，那么直接用组合数求解即可。

（甚至不需要预处理些什么）

code：

```cpp
#include <bits/stdc++.h>
#define panhan using
#define no namespace
#define xm std;
#define int long long
panhan no xm;
inline int read(){
	int sum=0,ff=1; char ch=getchar();
	while(!isdigit(ch)){
		if(ch=='-') ff=-1;
		ch=getchar();
	}
	while(isdigit(ch))
		sum=sum*10+(ch^48),ch=getchar();
	return sum*ff;
}
const int mo = 1000000007;
int q_pow(int x , int y , int res = 1) {
	while(y) {
		if(y & 1) res = res * x % mo;
		x = x * x % mo , y >>= 1;
	}
	return res;
}
int J(int x) {
	if(x <= 1) return 1;
	return x * J(x - 1) % mo;
}
int inv(int x) {return q_pow(x,mo-2);}
int C(int x , int y) {return J(x) * inv(J(x-y)) % mo * inv(J(y)) % mo;}
int x , y;
main() {
	x = read() , y = read();
	if(x < y) cout << 0;
	else if(x == y) cout << 1;
	else cout << C(x,y) * q_pow(2,x-y) % mo;
}
```



---

## 作者：_jimmywang_ (赞：0)

（看到社贡掉了$3$慌慌张张来找个题写题解）

在这篇题解中，我们将分$3$步解决这题~
### $1.$

请问：一个$n$维正方体是由多少个$n-1$维正方体拼成的呢？

看题面找规律得知是$2n$个。

理性分析一下，比如用$2$维拼$3$维，既然是正方体，那么每个维度就需要$2$个$2$维的来拼。

说的通俗一点，就是“长”这个维度，有左右两个。

“宽”这个维度，有前后两个。

“高”这个维度，有上下两个。

于是，一个$n$维正方体就要由$2n$个$n-1$维正方体拼成

### $2.$

先来找找规律。

$$ \quad 0 \quad  1 \quad 2 \quad 3$$
$$0\quad 1 \quad  0 \quad 0 \quad 0$$
$$1\quad 2 \quad  1 \quad 0 \quad 0$$
$$2\quad 4 \quad  4 \quad 1 \quad 0$$
$$3\quad 8 \quad  12 \quad 6 \quad 1$$


理论上来说，比如三维的要由$6$个二维的组成，每个二维的有$4$个点，一共应该是$24$个点，但是为啥只剩$8$个了？

一个点连了$3$个面呗~

所以要除以$3$嘛。

同理，一根线连了两个面，个数是$4*6/2=12$个，一个面就是一个面，个数是$1*6/1=6$个。

往回代，二维的由$4$个一维的组成，零维的个数是$2*4/2=4$，一维的是$1*4/1=4$个



……

于是找到规律了！

$$Ans= \dfrac{a!*2^{a}}{b!*2^{b}*(a-b)!}$$

简化一下;

$$Ans= \dfrac{a!*2^{a-b}}{b!*(a-b)!}$$

然后。。。做完了


代码：

```
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define f(i,a,b) for(int i=a;i<=b;i++)
inline ll r() {
	ll x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(isdigit(c))x=x*10+c-'0',c=getchar();
	return x*f;
}
#define d r()
ll a,b;
ll ans=1;
ll mul[1000010];
ll divv[1000010];
ll ny[100010];
ll t1,t2;
ll qp(ll a,ll b,ll p){
	ll ans=1;
	while(b){
		if(b&1)ans=ans*a%p;
		a=a*a%p;
		b/=2;
	}
	return ans;
}
int main(){
	a=d,b=d;
	if(b>a){cout<<0;return 0;}
	f(i,1,a)ans=ans*i%1000000007;
	f(i,1,a-b)ans=ans*2%1000000007;
	f(i,1,b)ans=ans*qp(i,1000000005,1000000007)%1000000007;
	f(i,1,a-b)ans=ans*qp(i,1000000005,1000000007)%1000000007;
	printf("%lld",ans%1000000007);
	return 0;
}
```




---

## 作者：火柴神 (赞：0)

超难题

N维体的各个维的数值为(x+2)^n每一项的系数

因为(x+2)^n每一项的系数符合二项式定理(高中数学选修2-3)

可用公式C(b,a)\*1^b\*2^(a-b)来算

但这只能过75%的点

另外25%由于C(b,a)>=1000000007

所以需要对其取模

这就需要卢卡斯定理

分解a为(ai)\*MOD^i+(ai-1)\*MOD^(i-1)……

同理分解b

然后C(b,a)=C(bi,ai)%MOD\*C(bi,ai)%MOD……

即可

代码如下



```cpp
#include<cstdio>
#define MOD 1000000007
#define LL long long
using namespace std;
int a,b;
LL quick_mod(LL a,LL b){  
    LL ans = 1;  
    a%=MOD;  
    while(b){  
        if(b&1){  
            ans=ans*a%MOD;  
            b--;  
        }  
        b>>=1;  
        a=a*a%MOD;  
    }  
    return ans;  
}  
LL C(LL n,LL m)  {  
    if(m>n)return 0;  
    LL ans=1;  
    for(int i=1;i<=m;i++){  
        LL a=(n+i-m)%MOD;  
        LL b=i%MOD;  
        ans=ans*(a*quick_mod(b,MOD-2)%MOD)%MOD;  
    }  
    return ans;  
}  
LL Lucas(LL n,LL m){  
    if(m == 0)return 1;  
    return C(n%MOD,m%MOD)*Lucas(n/MOD,m/MOD)%MOD;  
}  
int main(){
    scanf("%d%d",&a,&b);    
    if(a<b){
        printf("0");
        return 0;
    }    
    LL k;
    k=Lucas(a,b);
    LL z;
    z=1;
    for(int i=1;i<=a-b;i++){
        z=z*2%MOD;
    }
    LL ans=(k*z)%MOD;
    printf("%lld",ans);
    return 0;
}

```

---

## 作者：daniEl_lElE (赞：0)

这题有两种~~不正经的~~方法。

## Sol. 1
列表！找规律！

|  | 零维 | 一维 | 二维 | 三维 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| 包含零维 | $1$ | $2$ | $4$ | $8$ |
| 包含一维 | $0$ | $1$ | $4$ | $12$ |
| 包含二维 | $0$ | $0$ | $1$ | $6$ |
| 包含三维 | $0$ | $0$ | $0$ | $1$ |
首先，很明确，若 $a<b$ ，输出 $0$ 。

在我的一番猜 (luan) 想 (zuo) ，推 (xia) 倒 (gao) 后，找到了规律：

$$C_a^b×2^{a-b}$$

~~别问我咋搞的，累死了~~

大家读到这里应该就要去写了吧。慢着！还没证明~~贴代码~~呢！
## Sol. 2(Proof)
首先，考虑 $C_a^b$ 的意思。

都知道这是 $a$ 维正方体，要问有多少$b$维正方体，那么至少得先从这 $a$ 个维度中选出 $b$ 个来构造对吧。

这就很容易解释 $C_a^b$ 的意思了。

其次，考虑 $2^{a-b}$ ，这玩意很难想。

考虑从 $a-1$ 维到 $a$ 维时增加的 $b$ 维的数量。

设在 $a-1$ 维中有 $x$ 个 $b$ 维正方体。

可以想象 $a-1$ 维到 $a$ 维是 $a-1$ 维正方体移动的过程。

移动后两端是两个 $a-1$ 维正方体。所以 $a-1$ 维中已有的 $b$ 维正方体数量会变成两倍。

由于 $b$ 维中 $b$ 维正方体有 $1$ 个， $b+1$ 维有 $2^1$ 个， $\dots$ ， $a$ 维中就有 $2^{a-b}$ 个。

将两个相乘即可。

~~证明真繁琐，结论真简单~~

## Code

你们猜猜复制粘贴有用吗？
```cpp
#include <bi/*防抄袭标识*/ts/stdc++.h>
#defin/*防抄袭标识*/e int long long
using nam/*防抄袭标识*/espace std;
int const MOD = 1/*防抄袭标识*/e9 + 7;  
int con/*防抄袭标识*/st MAX = 200000;  
int fac[MAX + 5], inv_fac[MAX + 5];   
 //预处理阶乘
int q/*防抄袭标识*/pow(int x, int n)  {  
    int res = 1;  
    wh/*防抄袭标识*/ile(n){  
        if(n & 1)  
            re/*防抄袭标识*/s = (res * x) % M/*防抄袭标识*/OD;  
        x = (x * x) % MO/*防抄袭标识*/D;  
        n >>= 1;  
    } /*防抄袭标识*/ 
    ret/*防抄袭标识*/urn res;  
}  
//阶乘逆元 
vo/*防抄袭标识*/id pre()  {  
    fac[0] = 1;  
    f/*防抄袭标识*/or(int i = 1; i <= MAX; i++)  
        fac[i] = (fac[i/*防抄袭标识*/ - 1] * i) % MOD;  
    inv_fa/*防抄袭标识*/c[MAX] = qp/*防抄袭标识*/ow(fac[MAX], MOD - 2);  
    for(int i = MAX - 1; i >= 0; i--)  
        inv_fac[i] = (inv_/*防抄袭标识*/fac[i + 1] * (i + 1)) % MOD;   
}  
//C
int C(int a,int b){
	ret/*防抄袭标识*/urn ((/*防抄袭标识*/fac[a]*inv_fac[a-b])%M/*防抄袭标识*/OD*i/*防抄袭标识*/nv_fac[b])%MO/*防抄袭标识*/D;
}
sign/*防抄袭标识*/ed mai/*防抄袭标识*/n(){
	in/*防抄袭标识*/t a,b;
	cin>/*防抄袭标识*/>a>>b;
	p/*防抄袭标识*/re();
	if(a/*防抄袭标识*/<b){
		c/*防抄袭标识*/out/*防抄袭标识*/<<0;
		retu/*防抄袭标识*/rn 0;
	}
	//C_a^b * 2^(a-b)
	cout<<(/*防抄袭标识*/C(a,b)*qp/*防抄袭标识*/ow(2,a-b))%M/*防抄袭标识*/OD;
	retur/*防抄袭标识*/n 0;
}

```

---


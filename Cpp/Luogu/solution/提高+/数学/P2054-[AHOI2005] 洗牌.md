# [AHOI2005] 洗牌

## 题目描述

为了表彰小联为 Samuel 星球的探险所做出的贡献，小联被邀请参加 Samuel 星球近距离载人探险活动。

由于 Samuel 星球相当遥远，科学家们要在飞船中度过相当长的一段时间，小联提议用扑克牌打发长途旅行中的无聊时间。玩了几局之后，大家觉得单纯玩扑克牌对于像他们这样的高智商人才来说太简单了。有人提出了扑克牌的一种新的玩法。

对于扑克牌的一次洗牌是这样定义的，将一叠 $N$（$N$为偶数）张扑克牌平均分成上下两叠，取下面一叠的第一张作为新的一叠的第一张，然后取上面一叠的第一张作为新的一叠的第二张，再取下面一叠的第二张作为新的一叠的第三张……如此交替直到所有的牌取完。

如果对一叠 $6$ 张的扑克牌 ${1,2,3,4,5,6}$，进行一次洗牌的过程如下图所示：

  ![](https://cdn.luogu.com.cn/upload/pic/1641.png) 

从图中可以看出经过一次洗牌，序列 $1,2,3,4,5,6$ 变为 $4,1,5,2,6,3$。当然，再对得到的序列进行一次洗牌，又会变为 $2,4,6,1,3,5$。

游戏是这样的，如果给定长度为 $N$ 的一叠扑克牌，并且牌面大小从 $1$ 开始连续增加到 $N$（不考虑花色），对这样的一叠扑克牌，进行 $M$ 次洗牌。最先说出经过洗牌后的扑克牌序列中第 $L$ 张扑克牌的牌面大小是多少的科学家得胜。小联想赢取游戏的胜利，你能帮助他吗？

## 说明/提示

$0 ＜ N \leq 10^{10}$，$0 \leq M \leq 10^{10}$，且 $N$ 为偶数。


## 样例 #1

### 输入

```
6 2 3```

### 输出

```
6```

# 题解

## 作者：qqvq (赞：64)

## 怎么有人特判AC，撤掉数据了

心累。。。第一眼看到原有题解就觉得不对劲，然后拍、改了好长时间

-----------------

本篇题解之前的所有题解代码**均不对**

（我一个一个拖下来试的）

错误之处包括但不限于：

- 不开long long，全程int，读入1e10就gg了

- 乘法爆long long

- 复杂度不对（找循环节的）

- 某些情况下输出0

以及代码抄袭的那么明显真的好吗

### 暴力代码

//不存在n轮以后会变成初始状态的规律，可以用这个试一下

```cpp
#include <bits/stdc++.h>
using namespace std;
#define MAXN 100009
int a[MAXN], b[MAXN], n, m;
inline void refresh() {
  int *p1 = a + 1, *p2 = a + 1 + (n >> 1), *p = b + 1;
  for (int i = 1; i <= (n >> 1); ++i) *p++ = *p2++, *p++ = *p1++;
}

int main() {
  cin >> n >> m;
  for(int i = 1; i <= n; ++i) a[i] = i;
  for(int i = 1; i <= m; ++i) {
    refresh();
    for(int i = 1; i <= n; ++i) cout << b[i] << ' ';
    puts("");
    swap(a, b);
  }
  return 0;
}
```

### 正解代码
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
ll x, y, a, b, n, m, l;

inline ll exgcd(ll a, ll b, ll &x, ll &y) {
  return !b ? (x = 1, y = 0, a) : (exgcd(b, a % b, y, x), y -= (a / b) * x);
}
inline ll mul(ll a, ll b, ll mod) {
  ll ret = 0;
  while (b) {
    if (b & 1) ret = (ret + a) % mod;
    a = (a + a) % mod;
    b >>= 1;
  }
  return ret % mod;
}
inline ll Pow(ll a, ll b, ll mod) {
  ll ret = 1;
  while (b) {
    if (b & 1) ret = mul(ret, a, mod);
    a = mul(a, a, mod);
    b >>= 1;
  }
  return ret % mod;
}

int main() {
  cin >> n >> m >> l;
  exgcd(2, n + 1, x, y);
  x = (x % (n + 1) + n + 1) % (n + 1);
  x = Pow(x, m, n + 1);//逆元是积性函数
  cout << mul(l, x, n + 1);
  return 0;
}
```

---

## 作者：star_city (赞：27)

我们发现，每次洗牌时，若l为偶数，l /= 2; 若l为奇数，则l = l/2 + n/2 + 1

暴力的循环m次可以得70分

改进：

若发现l经过x次洗牌后又被洗回了l的位置

比如n = 2, m = 1000000001, l = 1

此时x = 2（每洗牌2次就回到原点），那么洗1000000001次就相当于洗了一次

因此我们只要当l又回到原点时用m %= x即可

时间复杂度无（bu）法（hui）表示



    
```cpp
#include <iostream>
#define ll long long
using namespace std;
int main(void)
{
    ll n, m, l;
    cin >> n >> m >> l;
    ll c = l; //用c记录l的初始位置
    n >>= 1; //与其每次洗牌都算n/2，不如一开始就除2
    for (int i = 1; i <= m; i++) {
        l = (l % 2) * (n + 1) + (l >> 1); //l为偶数就除2，为奇数就变成l/2+n+1
        if (c == l && i >= 1) { //如果l回到了初始位置（即l == c），m %= i（i就相当于前面的x）
            m %= i;
            i = 0;
        }// i = 0、m %= i后相当于从头开始一遍，但次数减少了很多
    }
    cout << l;
    return 0;
}
```

---

## 作者：_ZZH (赞：26)

具体见博客吧（打个广告）[qwq]
我们先按样例找下规律：

1,4,2,1

2,1,4,2

3,5,6,3

4,2,1,4

5,6,3,5

6,3,5,6

//每一列代表一次洗牌。

我们发现每次的位置变化为当前位置*2再取余（n+1），

设当前位置为x

那么下一次位置为2*x%(n+1)

下m次位置为2m*x%(n+1)

我们要求的就是满足2m*x≡l (mod n+1)的x.

那么x≡l*(2m)-1(mod n+1)

所以只要求出2m在模n+1意义下的逆元就可以求出x

代码如下：
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#define mod (n+1)
using namespace std;
int n,l,m,x,y;
int _pow(int x,int y)
{
    int ans=1;
    for(;y;y>>=1)
    {
        if(y&1)
        ans=(long long)ans*x%(n+1);
        x=(long long)x*x%(n+1);
    }
    return ans%(n+1);
}
void exgcd(int a,int b)
{
    if(b==0)
    {
        x=1;
        y=0;
        return;
    }
    exgcd(b,a%b);
    x^=y^=x^=y;
    y-=a/b*x;
}
int main()
{
    scanf("%d%d%d",&n,&m,&l);
    int a=_pow(2,m);
    exgcd(a,n+1);
    while(x<=0)x+=n+1;
    if((long long)x*l%(n+1)==0)
    {
        cout<<n+1;
        return 0;
    }
    printf("%lld",(long long)x*l%(n+1));
}
```

---

## 作者：Smokey_Days (赞：19)

这一题是逆元的模板题。

------------


模运算中的加法、减法和乘法，都可以直接用普通运算中的加减乘一一对应。但是，除法不一样。模运算中的除法会异常地复杂。（形如$ (a/b) mod P $)
为了简便化模运算的除法，我们可以考虑求一个数mod P的逆元。设欲求数为a，则记它的逆元为$a^{-1}$。$a(mod P)$的逆元等价为求方程$a*a^{-1}≡1(mod P)$。倘若知道一个数的逆元，则a/b就可以等价为$a*b^{-1}$，于是就实现了简便化模运算中的除法。

为了求解方程$a*x≡1(mod P)$，可以考虑使用拓展欧几里得算法。

引理1：[裴蜀定理](https://baike.baidu.com/item/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/5186593)。这一定理说明了，对于任意的一组正整数$(a,b)$，一定存在至少一组x,y使得方程$gcd(a,b)=a*x+b*y$，其中函数$gcd$表示求最大公因数。
    


在证明了有解之后，我们需要找到一种求解的方法，这种方法被称为扩展欧几里得算法($Exgcd$)，可以基于辗转相除法来理解（并且，复杂度也等同于辗转相除法）的复杂度。
对于任意的(a,b)，考虑设

$$gcd(a,b)=a*x_{1}+b*y_{1}$$

$$gcd(b, amodb)=b*x_{2}+(amodb)y_{2}$$
则可以进行如下证明：

引理2：对于任意正整数对 $(a,b)$ ，可以证明$gcd(a,b)=gcd(b,amodb)$。

设d为$gcd(a,b)$，则可设$a=k_{1}*d$,$b=k_{2}*d$。设

$$k_{1}=n*k_{2}+t(t∈[0,k_{2}))$$

则有：

$$a=n*k_{2}*d+t*d$$

故有，

$$amodb≡t*d$$

又$∵$

$$b=k2*d$$

且

$$(t∈[0,k_{2}))$$

故可得

$$gcd(b,amodb)=d$$

得证。

故，

$$a*x_{1}+b*y_{1}=b*x{2}+(amodb)*y_{2}$$

整理有：

$$a*x_{1}+b*y_{1}=b*x_{2}+(a-[a/b]*b)*y_{2}$$

$$a*x_{1}+b*y_{1}=a*y_{2}+b*(x_{2}-[a/b])*y_{2}$$
由多项式定理可得递归式：

$$x_{1}=y_{2}$$

$$y_{1}=(x_{2}-[a/b])*y_{2}$$

故，只要知道方程：

$$gcd(b,amodb)=a*x_{1}+b*y_{1}$$

的解，就可以求得方程：

$$gcd(b, amodb)=b*x_{2}+(amodb)y_{2}$$

的解。

易知，这一递归方程组在$b=0$时取到边界条件，此时模$b$同余无意义。而易知，当$b=0$时，$gcd(a,b)=a$，方程$gcd(a,b)=a*x+b*y$的解为

$$x=1,y=0$$

所以我们便可以对方程

$$gcd(a,b)=a*x+b*y$$

递归求解了。

回到我们原来的问题。我们要求a的逆元，实质上是求解方程

$$a*x≡1(mod P)$$

我们又可以将它转化为方程：

$$a*x≡P*y+1$$

即

$$a*x-P*y≡1$$;

这一形式很显然与

$$gcd(a,b)=a*x+b*y$$

相同。故可以用$Exgcd$算法求解该丢番图方程，即可算出$x$。该$x$为$a$的逆元。
特别地，当且仅当$P$与$a$互质时，该方程有且仅有一组解。

------------

为什么说这一题和逆元有关呢？
总结规律易得，对于$∀x∈[1,n]$存在每一次变换后，原序号为$x$的卡牌，会被置换到$(x*2)mod(n+1)$的位置。

因此，设$m$次变换后，$L$来自于$x$，则有同余方程：

$$(x*2^{m})≡L(modP)$$

已知$m,L,P$，通过逆元可以很容易地求解这个方程：

容易变换得：

$$(x*2^{m})≡1*L(modP)$$

于是就转化为已知的求逆元问题。

------------

另外再说一个，就是关于巨佬们使用的：

```cpp
x^=y^=x^=y
```

这个东西是用于高效交换变量的。实际类似于

$$b=a+b,a=b-a,b=b-a$$

这样的东西，只不过位运算玄学操作一波效率更高得了。

另：一开始没搞懂这个玩意儿的优先级，没理解，不过打个括号手算一下就很好理解了。

```cpp
x^=(y^=(x^=y))
```

------------

代码

```cpp
#include<iostream>
#include<cstdio>
using namespace std;

int n,m,k;

int pw2(int t){
    int ans=1;
    int x=2;
    while(t){
        if(t&1){
            ans=(long long int)ans*x%(n+1);
        }
        x=(long long int)x*x%(n+1);
        t>>=1;
    }
    return ans;
}

void exgcd(int a,int b,int &x,int &y){
    if(!b){
        x=1,y=0;
        return;
    }
    exgcd(b,a%b,x,y);
    x^=y^=x^=y;
    y-=a/b*x;
}

void init(){
    scanf("%d%d%d",&n,&m,&k);
    int p=pw2(m);
    int a,b;
    exgcd(p,n+1,a,b);
    while(a<0){
        a+=n+1;
    }
    printf("%lld",(long long)a*k%(n+1));
}

int main(){
    init();
    return 0;
}
```


---

## 作者：Youngsc (赞：14)

先挂个博客[Youngsc](https://youngscc.github.io/)

这个题的话暴力是可以过去的而且跑得飞快，但是这道题这么好不用逆元做一下真是可惜了。

**对于一张牌的位置，每交换一次就变成了$(x*2)(mod(n+1))$

那么经过$m$次变换，位置就应该变成了$ (x*2^m)(mod(n+1)) $

那么也就是说对于第$k$张牌，满足$x*2^m≡k (mod(n+1))$

我们已知$n,m,k$,那么只要求出来$(2^m)^{-1}(mod(n+1))$,反推出$x$即为答案。**


## 代码在这里


```cpp
# include <algorithm>
# include <iostream>
# include <cstring>
# include <cstdio>
# include <cmath>
# include <queue>
# define R register
# define LL long long
# define N 10010

using namespace std;

int n,m,k;

template <typename T> inline void in(R T& a){
    R char c=getchar(); R T x=0,f=1;
    while(!isdigit(c)) {if(c == '-') f=-1; c=getchar();}
    while(isdigit(c)) x=(x<<1)+(x<<3)+c-'0',c=getchar();
    a=x*f;
}

inline int powe(R int x,R int r){
    R int ret = 1;
    while(r){
        if(r&1) ret = 1LL*ret*x%(n+1); 
        x = 1LL*x*x%(n+1);
        r>>=1;
    }
    return ret;
}

inline void exgcd(R int a,R int b,R int&x,R int&y){
    if(b==0){
        x=1; y=0; return ;
    }
    exgcd(b,a%b,x,y);
    x^=y^=x^=y;
    y-=a/b*x;
}

int main(){
//    freopen("gamea.in","r",stdin);
//    freopen("gamea.out","w",stdout);
    in(n),in(m),in(k);
    R int p = powe(2,m);
    R int a,b;
    exgcd(p,n+1,a,b);
    while(a<0) a+=n+1;
    printf("%lld",1LL*a*k%(n+1));
    return 0;
}
```

---

## 作者：RenaMoe (赞：10)

洗牌???

~~吐槽一下题目的图片，差点误导了我~~

这么麻烦的题面当然先模拟啦。。。

打表发现每次洗牌后第 $i$ 张牌会转移到第 $2*i \%(n+1)$ 的位置上

即在$mod (n+1)$意义下，$i$ 和 $2i$ 是同余的

so，可以列出一个同余方程：

$i * 2^{m} \equiv l \qquad(mod (n+1))$

再转化为

$2^{m} * i + (n+1) * k = l$

$2^{m} * \frac{i}{l} + (n+1) * \frac{k}{l} = 1$

此时利用$exgcd$完美地算出$\frac{i}{l}$，乘上$l$即可

**注意：**范围1e10，如果直接乘会gg，要用快速乘，和快速幂差不多

```cpp
#include <cstdio>
#include <cctype>

using namespace std;

template<typename T> inline void read(T &x) {// 快读
	x = 0; T k = 1; char in = getchar();
	while (!isdigit(in)) { if (in == '-') k = -1; in = getchar(); }
	while (isdigit(in)) x = x * 10 + in - '0', in = getchar();
	x *= k;
}

typedef long long ll;// 开long long

// 快速乘
inline ll mul(ll a, ll b, ll p) {
    // 将乘法变为加法，二进制优化，边加边模
	ll ans = 0;
	while (b) {
		if (b & 1)
			ans = (ans + a) % p;
		a = (a + a) % p;
		b >>= 1;
	}
	return ans;
}

// 快速幂，其实只要写针对2的整次幂就行，这里犯懒。。。
inline ll q_pow(ll a, ll b, ll p) {
	ll ans = 1;
	while (b) {
		if (b & 1)
			ans = mul(ans, a, p) % p;
		a = mul(a, a, p) % p, b >>= 1;
	}
	return ans;
}

// 标配扩欧
void exgcd(ll a, ll b, ll &x, ll &y, ll &g) {
	if (!b)
		x = 1, y = 0, g = a;
	else {
		exgcd(b, a%b, y, x, g);
		y -= a / b * x;
	}
}

int main() {
	ll n, m, l, x, y, g, t;
	read(n), read(m), read(l);
	t = q_pow(2, m, n+1);// 2的m次幂
	exgcd(t, n+1, x, y, g);
	x = (x % (n+1) + n+1) % (n+1);// 注意exgcd后解可能为负
	printf("%lld\n", mul(x, l, n+1));// 乘上l
    return 0;
}
```



---

## 作者：_Diu_ (赞：8)

## 找规律

这一题主要是找到规律就可以了

我们把这里把这一叠牌分成前后两份

先看前面的

![](https://cdn.luogu.com.cn/upload/image_hosting/p6f9vzh5.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

总结：

若原格子编号为$x$，则后来这个格子里的数到了编号为$2x$的格子

后半部分

![](https://cdn.luogu.com.cn/upload/image_hosting/hkrv41f6.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

若原格子编号为$x$，则后来这个格子里的数到了编号为$2x-(n+1)$的格子里

那么综合起来，即为$2x\;mod\;(n+1)$

## 逆元

那么我们要求的数相当于洗牌$m$次后，第$l$个格子里的数

设这个数为$x$

那么$x*2^m≡l(mod\;n+1)$

设$2$的逆元为$k$

那么$x=l*k^m$%$n+1$

然后就有了正解

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,l,x,y;
int exgcd(int a,int b,int &x,int &y){
    if(b==0){
        x=1,y=0;
        return a;
    }
    int d=exgcd(b,a%b,x,y);
    int tmp=x;
    x=y,y=tmp-a/b*y;
    return d;
}
int qmul(int x,int y,int p){
	int tot=0;
	while(y){
		if(y&1)tot=(tot+x)%p;
		x=(x+x)%p;
		y>>=1;
	}
	return tot;
}
int qpow(int x,int y,int p){
	int tot=1;
	while(y){
		if(y&1)tot=qmul(tot,x,p)%p;
		x=qmul(x,x,p)%p;
		y>>=1;
	}
	return tot;
}
signed main(){
	scanf("%lld%lld%lld",&n,&m,&l),++n;
	exgcd(2,n,x,y);
	x=(x%n+n)%n;
	printf("%lld",qmul(l,qpow(x,m,n),n));
}
```

## 小优化

又因为$n+1$一定是偶数

所以$2$关于$n+1$的逆元一定是$n/2+1$。~~大佬可以去证一下~~

所以就不用扩欧来求解了

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,l,x,y;
int exgcd(int a,int b,int &x,int &y){
    if(b==0){
        x=1,y=0;
        return a;
    }
    int d=exgcd(b,a%b,x,y);
    int tmp=x;
    x=y,y=tmp-a/b*y;
    return d;
}
int qmul(int x,int y,int p){
	int tot=0;
	while(y){
		if(y&1)tot=(tot+x)%p;
		x=(x+x)%p;
		y>>=1;
	}
	return tot;
}
int qpow(int x,int y,int p){
	int tot=1;
	while(y){
		if(y&1)tot=qmul(tot,x,p)%p;
		x=qmul(x,x,p)%p;
		y>>=1;
	}
	return tot;
}
signed main(){
	scanf("%lld%lld%lld",&n,&m,&l),++n;
	x=n/2+1;
	printf("%lld",qmul(l,qpow(x,m,n),n));
}
```

---

## 作者：FlashHu (赞：6)

来个正常的有证明的题解

我们不好来表示某时刻某一个位置是哪一张牌，但我们可以表示某时刻某一张牌在哪个位置。

设数列$\{a_{i_j}\}$表示$i$号牌经过$j$次洗牌后的位置，我们试着来递推一下

首先，如果此刻牌在上面一叠，显然$a_{i_{j+1}}=2a_{i_j}$

接着，如果这张牌在下面一叠，那么$a_{i_{j+1}}=2(a_{i_j}-\frac n2)-1=2a_{i_j}-(n+1)$，应该也很好推出来

写在一起，观察一下

$$a_{i_{j+1}}=\begin{cases}2a_{i_j}\qquad\qquad\ ,a_{i_j}\leq\frac n2\\2a_{i_j}-(n+1),a_{i_j}>\frac n2\end{cases}$$

诶，两个式子都有一个系数$2$呢！那我们可不可以把它看成模$n+1$意义下的结果呢？

于是可以进一步得到$a_{i_j}\equiv2^mi(\mod n+1)$（$i$就是$a_{i_0}$）

题目已经知道了$a_{i_j}$，来求$i$，不就是一个线性同余不定方程么？exgcd搞一下就好啦！因为$\gcd(2^m,n+1)=1$，所以根本不用像[青蛙的约会](http://www.cnblogs.com/flashhu/p/9149119.html)那样麻烦。

看楼上大佬用异或写swap？！第一次见的蒟蒻表示只能Orz。然后蒟蒻就把exgcd这个函数成功压缩到了一行。。。。。。
```cpp
#include<cstdio>
#define LL long long
LL n,m,l,x=1,y;
LL qpow(LL b,LL k){//快速幂求2^m
	LL a=1;
	while(k){
		if(k&1)a*=b,a%=n+1;
		b*=b,b%=n+1;
		k>>=1;
	}
	return a;
}
void exgcd(LL a,LL b){//一行exgcd233
	if(b)exgcd(b,a%b),(y^=x^=y^=x)-=a/b*x;
}
int main(){
	scanf("%lld%lld%lld",&n,&m,&l);
	exgcd(qpow(2,m),n+1);
	printf("%lld\n",(l*x%(n+1)+n+1)%(n+1));//注意化成最小正整数
	return 0;
}
```

---

## 作者：Jμdge (赞：3)

这么短的代码，调了半天，最后告诉我是快速模咕掉了说...

这道题反正就是打表找规律然后发现当前第 x 张牌下次出现在 $2*x % (n+1)$ 处，然后就是各种骚，求出二的逆元然后快速模 m 倍，接着乘上 l 就出解了。

（就是倒推的思路嘛） 然鹅。。。

注意快速模里面也要用龟速乘啊！

当然你也可以用快速乘（一开始还以为我快速乘咕掉了..）

代码附上：


```
//by Judge
#include<cstdio>
#include<iostream>
#define ll long long
#define ld long double
using namespace std;
ll n,m,l,a,mod,x,y;
void ex_gcd(ll a,ll b,ll& x,ll& y){
	if(!b) return x=1,y=0,void();
	ex_gcd(b,a%b,y,x),y-=a/b*x;
}
inline ll qmul(ll a,ll b){ ll s=0;
	for(;b;b>>=1,a=(a+a)%mod)
		if(b&1) s=(s+a)%mod; return s;
}
inline ll mul(ll a,ll b){ a%=mod,b%=mod;
	return (ll)(a*b-(ll)(((ld)a*b+0.5)/mod)*mod+mod)%mod;
}
inline ll qpow(ll x,ll p){ ll s=1;
	for(;p;p>>=1,x=mul(x,x))
		if(p&1) s=mul(s,x); return s;
}
int main(){
	cin>>n>>m>>l,mod=n+1,ex_gcd(2,mod,x,y),
	x=(x%mod+mod)%mod,x=qpow(x,m);
	return cout<<mul(l,x)<<endl,0;
}
```


上面的 qmul 是龟速乘，并没有用到


---

## 作者：Kinandra (赞：3)

1. 标签: 转化, 快速幂.
2. 设$f(i)$为第$i$张牌洗一次后的位置, 发现
	$$f(i)=i*2\pmod{N+1}$$
	所以经过$M$次洗牌后, 第$i$张牌的位置为$i*2^M\pmod{N+1}$, 因为$N+1$为奇数, 所以$2$在模$N+1$意义下存在逆元$inv$, 所以答案就为
    $$L*inv^M\pmod{N+1}$$
3. 注意要使用慢速乘.

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
long long mod;
long long mul(long long a, long long b) {
    long long rt = 0;
    while (a) {
        if (a & 1) (rt += b) %= mod;
        (b += b) %= mod;
        a >>= 1ll;
    }
    return rt;
}
long long fsp(long long base, long long p) {
    long long rt = 1;
    while (p) {
        if (p & 1) rt = mul(rt, base);
        base = mul(base,base);
        p >>= 1ll;
    }
    return rt;
}
int main() {
    long long n, m, l;
    scanf("%lld%lld%lld", &n, &m, &l);
    mod = n + 1;
    long long tmp = (mod + 1) / 2;
    printf("%lld\n", mul(l, fsp(tmp, m)));
    return 0;
}
```


---

## 作者：azihmst (赞：3)

一道好题。

首先是数据范围。


------------

0＜N≤10^10 ，0 ≤M≤10^10，且N为偶数



------------
这是这道题的坑点，也是痛点。

10^10表示这这道题必有规律。

那么，first step，我们先探索规律。

以下表格中，前n列表示纸牌变化，最后一列表示1的位置。


------------

1 2 1

2 1 2

1 2 1



------------

1 2 3 4 1

3 1 4 2 2

4 3 2 1 4

2 4 1 3 3

1 2 3 4 1



------------

1 2 3 4 5 6 1

4 1 5 2 6 3 2

2 4 6 1 3 5 4

1 2 3 4 5 6 3


------------

那么，从一的位置，我们可以看出，
对于当前位置n,纸牌数量a，来说：

若n<a/2 n=n*n;

若n>a/2 n=(n-a/2)*2-1；



------------

附上代码：

     while(k!=a/2+1)
    {
	  if(k<=a/2)
	  {
		  k=k*2;
		  o++;
  		  continue; 
	  }
	  if(k>a/2)
	  {
		  k=(k-a/2)*2-1;
		  o++;
	  	  continue; 
	  }
    }
    
------------

有了这个以后，我们可以相当程度上简化此问题。

那么第二步，还原。

还是看上表中一的位置

1->2->1

1->2->4->3->1

1->2->4->1

规律如下

如果n%2==0 n=n/2;

else n=(n+1)/2+a/2;

附上代码：



------------
    for(int i=1;i<=b;i++)
	{
		if(c%2==1)
		{
			c=(c+1)/2+a/2;
			continue; 
		}
		if(c%2==0)
		{
			c=c/2;
			continue;
		}
    }
    

------------

综上所述，此题完。
求审核通过。




---

## 作者：shenbear (赞：2)

看到大佬用快速乘，我一个蒟蒻瑟瑟战战兢兢，于是发一个不用快速乘的题解

首先，观察一下牌堆变化规律，会发现其实规律就是：

对于一个位置x，其下一个位置为x*2%(n+1)   ~~（使用大眼观察法）~~

若要证明，我们发现，对于所有数，都是成对出现，对于前一半，每一次会被洗到后面的一个，也就是x*2=x*2%(n+1);对于后一半x，它是这一半中第x-n/2个，又是成对出现，所以会在第2*(x-n/2)-1=2x-n-1中，由于x>n/2，所以也就是x*2%(n+1)

设原位置为x，综上所述，x*2^m≡l(mod n+1)

也就成为了一道求逆元的题

由于n+1不一定为质数，所以这里使用exgcd求

设p=n+1,有ax≡l(mod p) --> ax-py=l

用扩欧求解即可

咦，咋挖了，观察数据，10^10*10^10=10^20 **爆longlong了**

咋办，爆int咋办？ 开longlong啊

那爆longlong咋办？ 开__int128啊

它比longlong再多一个平方，但不支持一般的输入输出，所以只能用快读快输

事实上，n，m，l并不用__int128，所以直接cin即可

由于逆元*l有可能爆longlong（#13）所以要用快输

不懂快读快输的点这--》[快读快输](https://www.luogu.org/blog/shenhy1205/kuai-du-kuai-shu)

于是用__int128愉快的水过了



------------
代码
```cpp
#include <bits/stdc++.h>
#define ll long long
#define l7 __int128
using namespace std;
ll n,m,l,a,p;
ll ksm(l7　x,ll k) 、、快速幂
{
　　l7 ans=1;
　　while(k)
　　{
　　　　if(k&1) ans=ans*x%p;
　　　　x=x*x%p;
　　　　k>>=1;
　　}
　　return ans;
}
void exgcd(ll a,ll b,l7 &x,l7 &y) #扩欧
{
　　if(!b) x=1,y=0;
　　else exgcd(b,a%b,y,x),y-=a/b*x;
}
void print(l7 x) 《-- 快输
{
　　if(x>9) print(x/10);
　　putchar(x%10+48);
}
int main()
{
　　cin>>n>>m>>l;
　　p=n+1;
　　a=ksm(2,m);
　　l7 x,y;
　　exgcd(a,p,x,y);
　　x=(x%p+p)%p; //逆元
　　print(x*l%p);
　　return 0;
}　　 
　　　
```


---

## 作者：什么叫中二呀 (赞：2)

其实并不需要扩欧求逆元。

2对于一个奇数k的逆元一定是$\frac{k+1}{2}$

因为$2*\frac{k+1}{2}≡1(mod$ $(k+1))$

思路楼下都说清楚了，每一次乘2模(n+1)

所以$ans=l*(\frac{n}{2}+1)^m$ $mod$ $(n+1)$

最后注意一下精度即可$(10^{20}$不在$long$ $long$范围内$)$。

代码不放了

---

## 作者：xyz32768 (赞：1)

- 首先，可以发现，一次洗牌，对于任何一个$i<=N/2$，会让第$i$张牌变成第$i*2$张牌。对于任何一个$i>N/2$，会让第$i$张牌变成第$(i-N/2)*2-1$张牌，而$(i-N/2)*2-1=i*2-N/2*2-1=i*2-(N+1)$。

- 由上面的推导得出，$M$次洗牌后，第$x$张牌会变成第$x*2^M \mod (N+1)$张牌。$2^M \mod (N+1)$的值可以用快速幂计算。

- 而对于求解线性同余方程$x*2^M\equiv L(\mod N+1)$，可以用扩欧实现。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
typedef long long ll;
ll n, m, l, rex, rey;
ll qpow(ll a, ll b) {
    ll res = 1;
    while (b) {
        if (b & 1) res = res * a % (n + 1);
        a = a * a % (n + 1);
        b >>= 1;
    }
    return res;
}
ll gcd(ll a, ll b) {return b ? gcd(b, a % b) : a;}
void exgcd(ll a, ll b, ll &x, ll &y) {
    if (b == 0) return (void) (x = 1, y = 0);
    exgcd(b, a % b, y, x); y -= (a / b) * x;
}
int main() {
    cin >> n >> m >> l; ll c = qpow(2ll, m), g = gcd(c, n + 1);
    c /= g; (n += 1) /= g; l /= g; exgcd(c, n, rex, rey);
    rex = (rex % n + n) % n; rex = rex * l % n;
    cout << rex << endl;
    return 0;
}
```

---

## 作者：Rye_Catcher (赞：1)

- 题目链接：

  https://www.luogu.org/problemnew/show/P2054
  
  https://www.lydsy.com/JudgeOnline/problem.php?id=1965
  
- 思路：

  首先一开始我看错题了，但是发现了一些有趣的东西：
  
   ```
我一开始理解的意思：第L张扑克牌的牌面大小是多少
   ```
   
   这是题目要我们求得，然后我看成了原序列中第L张扑克牌的位置...然后兴冲冲地找到了规律，比较有趣: $pos \equiv (L*2^m) mod (n+1)$,具体怎么证我不会，可惜数竞大佬都去集训了，现在也没办法。
   
   然后按这个规律交了一发只有10分，才发现看错题了。我们要求的是m次洗牌后第L张扑克牌的牌面大小,然而刚刚我们已经发现了$pos \equiv (L*2^m) \pmod {n+1}$
   
   于是我们设位于L位，即现在位置（pos）在L上的牌在原序列第x张，根据上面规律：$(x*2^m) \equiv L \pmod {n+1}$ 
   
   所以 $x \equiv L*{2^m}^{-1} \pmod {n+1} $，求出$2^m$在模$(n+1)$意义下的逆元即可。
   
- 其他：

   这里不用$(n+1)$不一定是质数，所以最好不要用费马小定理求，否则你只有40分，然后我们就只能用拓欧了
   
   同时我发现当m满足$2^m \equiv 1 \pmod {n+1}$时，恰好变成最开始的序列，然而我还是不会证明
   
   
- 代码：

```
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <cctype>
#define ll long long 
using namespace std;
ll quick_pow(int a,int b,int c)//a^b%c
{
	if(b==0)return 1;
	ll x=quick_pow(a,b>>1,c);
	x=x*x%c;
	if(b&1)x=x*a%c;
	return x; 
}
void ex_gcd(ll a, ll b, ll &x, ll &y, ll &d){
    if (!b) {d=a,x=1,y=0;}
    else{
        ex_gcd(b,a%b,y,x,d);
        y=y-x*(a/b);
    }
    return ;
}
ll inv(ll t, ll p){
    ll d,x,y;
    ex_gcd(t,p,x,y,d);
    return (x%p+p)%p;
}
int main(){
	ll n,m,l;
	cin>>n>>m>>l;
	ll p=quick_pow(2,m,n+1);
	if(p%(n+1)==1){
		printf("%lld",l);
	}
	else{
		printf("%lld\n",(l*inv(p,n+1))%(n+1));
	}
	return 0;
} 
```

---

## 作者：zhangchengkai (赞：1)

我们发现第x张牌经一次变换后会成为第x/2张 （x%2==0）或（x+1）/2+n/2张 (x%2==1），并且会有若干循环。

我们只要暴力模拟找到第l个数的循环节长度，则变换m次等价于变换m%循环节长度次，再次暴模即可。。。

```cpp
#include<cstdio>
int n,m,l;
int main()
{
    scanf("%d%d%d",&n,&m,&l);
    int sum=1,x=l&1?((l+1)>>1)+(n>>1):(l>>1);
    while(x!=l) sum++,x=x&1?((x+1)>>1)+(n>>1):(x>>1);//找循环节
    m=m%sum;
    while(m--) l=l&1?((l+1)>>1)+(n>>1):(l>>1);暴力模拟
    printf("%d",l);
    return 0;
}
```

---

## 作者：Iscream2001 (赞：1)

看到楼下的题解都这么简洁。。。不禁想发一个看起来高大上的题解。。。

楼下的想法都是找循环，这样的想法肯定是对的(这显然是置换群的特性)

然而如果数学基础好的话，就存在一种更加简单，粗暴，无脑的打法。。。

题解如下：

设某张牌在N张牌中初始位置在x，那么一次洗牌后位置就变为(2\*x)%(N+1)；

那样就能得到方程：x\*(2^M) Ξ L (mod N+1)

其中(2^M)可以快速幂取模，于是又得到新方程：x\*k Ξ L (mod N+1)；

其中k为(2^M)%(N+1)的结果

现在的这个方程就可以用扩展欧几里得算法强行攻略。。。

代码
```cpp
#include<cstdio>
#define LL long long
using namespace std;
LL d=0,x=0,y=0;
LL pow(LL a,LL b,LL mod){
    LL s=1;
    while(b){
        if(b&1) s=(s*a)%mod;
        b>>=1;
        a=(a*a)%mod;
    }
    return s;
}
void gcd(LL a,LL b,LL &d,LL &x,LL &y){
    if (b==0){
        d=a;
        x=1;
        y=0;
        return ;
    }
    gcd(b,a%b,d,y,x);
    y-=a/b*x;
    return;
}
int main(){
    LL n,m,l,k;
    scanf("%lld%lld%lld",&n,&m,&l);
    n++;
    k=pow(2,m,n);
    gcd(k,n,d,x,y);
    while(x<0) x+=n;
    d=(l/d)*x%n;
    printf("%lld",d);
    return 0;
}
```

---

## 作者：马必辰 (赞：0)

规律是对于位置x，每次洗牌x\*=2，当x>N时，x=x-a-1。

用1号牌来搜索循环节，即连续两次1号牌出现在位置1的时候。用M mod = 循环节，结果不变。

让时光倒流，到推出L的原位置，就可以求出答案。

虽然时间复杂度有点不合理，但还是AC了。

上代码：


```cpp
#include<cstdio>
long long a,b,c,d,e,i;
int main()
{
scanf("%lld %lld %lld",&a,&b,&c);
d=2;
e=1;
while(d!=1)
{
    d=d*2;
    if(d>a) d=d-1-a;
    e=e+1;
}
b=b%e;
for(i=1;i<=b;i++)
{
    if(c%2==0) c/=2;
    else c=(c+a+1)/2;
}
printf("%lld",c);
return 0;
}
```

---

## 作者：lwhllw (赞：0)

玄学！

先判断一下进行K次会回到原来状态，然后再把M mod k最后的数据直接模拟即可

对于当前位置为i，且偶数，必定为 i/2转移过来的

对于当前位置为i，且为奇数，必定为 i/2+1+n/2 转移过来

循环跑一边就行了~

```cpp
const maxn=1000000;
var i,j,k:longint;
    l,n,m:int64;
procedure init;
begin
    readln(n,m,l);
    n:=n div 2;
end;
procedure work;
var i,j,k:longint;
begin
    k:=1;i:=2;
    while i<>1 do
    begin
      if i<=n then i:=2*i else
      if i>n then i:=i-(2*n-i+1);
      inc(k);
    end;
    m:=m mod k;
    for i:=m downto 1 do
    begin
      if(l mod 2=0)then
      begin
        l:=l div 2;
        continue;
      end;
      if(l mod 2=1)then l:=(l div 2)+1+n;
    end;
    writeln(l);
end;
begin
    init;
    work;
end.
```

---

## 作者：青春ing (赞：0)

递推。

找一找规律就可以做出来了。

已知要求位置L，倒推上一轮中该位置纸牌所在位置，递推式：

p=(p&1)?((n+p+1)>>1):(p>>1)（代码中用的是t）

并且，不难发现，这个式子是会循环的，只要找到循环节即可以快速求解，并不需要递推M次。

上代码：




```cpp
#include <iostream>
#include <vector>
using namespace std;
vector<long long> a;
int main(){
    long long n,m,l;
    cin >> n >> m >> l ;
    a.push_back(l);
    bool bo=false;
    long long t=l;
    for (long long i=0;i<m;i++){
        if (t&1){
            t=(n+t+1)>>1;
        }
        else{
            t>>=1;
        }
        if (t==l){
            bo=true;
            break;
        }
        a.push_back(t);
    }
    if (bo){
        t=m%a.size();
        cout << a[t] ;
    }
    else{
        cout << t ;
    }
    return 0;
}
```

---

## 作者：mwyxhh (赞：0)

打了个表出来，就会很明显的看到这道题有循环节，于是写了个map把循环节找出来mod了就完了

当然，肯定有数学证明，希望有大神证一证。

这道题和1775都教会我们一个道理，当你写了暴力没办法优化的时候，一定要打个表出来看看，说不定就找出规律了。

```cpp
#include<iostream>
#include<cstdio>
#include<map>
using namespace std;
map<int,int>g;
int n,m,l;
int main()
{
    int a,b,c;
    cin>>n>>m>>l;
    while(m>0)
    {
        m--;
        if((l&1)==0)(l=l>>1);
        else l=(l+n)/2+1;
        if(g.find(l)!=g.end())m=m%(g[l]-m);
        else g[l]=m;
    }
    cout<<l<<" ";
}
```

---


# 图书馆书架上的书

## 题目背景

NOIP2014 即将来临，JC 书院信息学兴趣小组也在积极准备着，于是乎 usqwedf 、梁大大、畜牧办专场、YH 大神和 LHT 大神也要推出“蓝翔杯”。

在图书馆、 MC 等大神们相继举办了 JC 书院联合竞赛“弃疗杯”“UID#3”，据说 YH 大神还要苦苦钻研网络流的 JC 书院 $13$ 届 $13$ 班的 WZF 神牛和 MZC 神牛听到这个消息后决定联袂打造“十三点杯”。但是出一套题目是一项繁重的工作，于是他们决定再拉上和他们同届并且同班还同为 JC 书院信息学兴趣小组成员同时也在图书馆正在找“Hello World”标程的蒟蒻 SY。

可怜的蒟蒻 SY 因为还要写一大堆的作业，怎么也不肯答应，终于 WZF 神牛妥协说：“我来出一道题，你要是做出来了我们就不让你出题，否则……你懂的。”蒟蒻 SY 才刚看完 WZF 神牛即兴出的题目，便带着哭腔对 WZF 神牛说：“你们赢了。”。

可是蒟蒻 SY 实在是太弱了，根本不会出题，他绞尽脑汁，终于想到了一个办法——将 WZF 神牛出的题目 copy 一下。

## 题目描述

图书馆有 $n$ 个书架，第 $1$ 个书架后面是第 $2$ 个书架，第 $2$ 个书架后面是第 $3$ 个书架……第 $n-1$ 个书架后面是第 $n$ 个书架，第 $n$ 个书架后面是第 $1$ 个书架，第 $i$ 个书架上有 $b_i$ 本书。现在，为了让图书馆更美观，WZF 神牛让蒟蒻 SY 搬动书架上的书，使每个书架上的书一样多。由于搬动的书可能会很多，所以蒟蒻 SY 只能将一个书架上的书搬到与其相邻的两个书架上。那么蒟蒻 SY 最少搬动几本书呢？

## 说明/提示

### 数据范围及约定

对于全部数据，$1\le n\le 10^5+1$，且 $n$ 必为奇数；$b_i\le 10^7$。

若 $af_i$ 为负数，则说明蒟蒻 SY 要把第 $i$ 个书架前面的那个书架上的 $-af_i$ 本书搬到第 $i$ 个书架上。

同理，若 $ab_i$ 为负数，则说明蒟蒻 SY 要把第 $i$ 个书架后面的那个书架上的 $-ab_i$ 本书搬到第 $i$ 个书架上。


## 样例 #1

### 输入

```
5
15 7 11 3 14
```

### 输出

```
12
2 3
-3 0
0 1
-1 -6
6 -2
```

# 题解

## 作者：big_news (赞：11)

**纸牌均分问题**

这种题型大概有两种通解：费用流解法（如网络流24题中的[负载平衡问题](https://big-news.github.io/2019/04/02/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91%E8%B4%9F%E8%BD%BD%E5%B9%B3%E8%A1%A1%E9%97%AE%E9%A2%98/)）和数学解法。但是解法一特别容易被卡MLE，能运行的数据范围大概只有$n\leqslant 100$，所以这题来谈谈数学解法。

### 分析

假设有五个书架1,2,3,4,5，其中1号向2号搬5本书，2号向1号搬1本书，1号向5号搬3本书，也可以看作1号向5号搬了3本书，2号向1号搬了-4本书。

于是可以得出一个结论，即任意一个书架给别的书架的书本数总可以看作一个定值。假设1号只给5号书，2号只给1号书，......，5号只给4号书，且给的书的数量分别为$x_1,x_2,...,x_5$，那么$x_1,x_2,...,x_5$一定有绝对值最小的确定的值。现在我们要使$\sum\limits_{1\leqslant i\leqslant 5}|x_i|$最小，显然要求出这些“确定的值”。

### 数学推理

~~**头秃系列开始**~~

设每个书架原先分别有$a_1,a_2,...,a_n$的书。因为每个书架最终的书本数为$\sum\limits_{1\leqslant i\leqslant n}a_i \div n$，设这个数为$\overline a$，则有以下等式：

$$\begin{aligned} a_1 =  \overline a - x_2 + x_1 \\ a_2 = \overline a - x_3 + x_2 \\ ... \\ a_5 = \overline a - x_1 + x_5 \end{aligned}$$

移项，得：
$$\begin{aligned}  x_2 = x_1 - (a_1-\overline a)  \\ x_3 = x_2 - (a_2 - \overline a)  \\ ... \\ x_5 = x_1 - (a_5 - \overline a)\end{aligned}$$
将前式分别带入后式可得：
$$\begin{aligned} x_1 = x_1 \\  x_2 = x_1 - (a_1-\overline a)  \\ x_3 = x_1 - (a_1 + a_2 - 2\overline a)  \\ ... \\ x_5 = x_1 - (a_1+a_2+a_3+a_4 - 4\overline a)\end{aligned}$$
可知：
$$ x_n = x_1 - (\sum\limits_{1\leqslant 1< n}a_i - (n-1)\times \overline a) $$

设$c_1 = a_1 - \overline a,c_2 = a_1 + a_2 - 2\overline a,...$，以此类推，可知$x_n = x_1 -  c_{n-1}$。同时有递推式$c_i = c_{i-1} + a_i - \overline a$。这个递推式与$x$取值无关，且总有$c_0 = 0$，因此可以计算出所有$c_i$的值。

又有$x_2 = x_1 - c_1,x_3= x_1- c_2,...$，则$\sum\limits_{1\leqslant i\leqslant 5}|x_i|$可表示为：
$$ |x_1| + |x_1 -c_1| +|x_1-c_2| + ... +|x_1-c_4| $$
这也可以看作数轴上每个$c_i$到$x_1$的距离之和。那么我们就要找一个$x_1$，使得在数轴上它到每个$c_i$的距离最小。这个$x_1$即是$c_1,c_2,...,c_4$的中位数。

**证明**

先把$c_1,c_2,...,c_4$排好序，表示在数轴上，如下图所示。

![二(1)](https://img.langlangago.xyz/2019/06/21/5d0c47aecc571.png)

任取一$x_1$，则距离之和可以化为$ \text{dist}(c_1,c_4) + \text{dist}(c_2,c_3) +2\times \text{dist}(c_2,x_1)$。其中$\text{dist}(c_1,c_4) + \text{dist}(c_2,c_3)$为定值，那么让$\text{dist}(c_2,x_1)$最小一定会更优一点。它的最小值为$0$，此时$x_1$选在$c_2$上。

归纳，可知将$x_1$选在$c_1\text{~}c_4$中的一个点上一定要优一点。

然后再分别尝试$c_1,c_2,...,c_4$这些点，不难发现$x_1$选的越靠中间距离之和越小，故可知$x_1$取$c_1,c_2,...,c_4$的中位数。


### 解决

那么$x_1$就很好求了，然后就可以推出所有的$x$值。第一问就很容易的解决了，第二问只需输出$x_i$和$-x_{i+1}$即可。最后还要再处理一下环。

注意，当$n$为偶数时，两个中位数取哪一个都可以。

代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<algorithm>
using namespace std;

#define LL long long

LL read(){ 
    LL s=0,ne=1; char c=getchar();
    for(;c<'0'||c>'9';c=getchar()) if(c=='-') ne=-1;
    for(;c>='0'&&c<='9';c=getchar()) s=((s<<1)+(s<<3))+c-'0';
    return s*ne;
}

const int CN=1e6+6;

LL n,x1,a[CN],c[CN],_a,rec[CN];
LL llabs(LL a) {return a>0 ? a:-a;}

int main()
{
    n=read();
    LL sigma = 0;
    for(int i=1;i<=n;i++) 
        a[i] = read(),sigma += a[i];
    _a = sigma/n; //求平均值 
    
    rec[0] = c[0] = 0;    
    for(int i=1;i<=n;i++)
        rec[i] = c[i] = c[i-1]+a[i]-_a; //递推c[i]
            
    sort(c+1,c+n+1);
    x1 = c[(n+1)/2]; //计算中位数
        
    LL ans=0;
    for(int i=1;i<=n;i++)
        ans += llabs(x1-c[i]); //求代价
    printf("%lld\n",ans);
    for(int i=1;i<n;i++)
        printf("%lld %lld\n",x1-rec[i-1],-(x1-rec[i])); //输出搬运数
    printf("%lld %lld",x1-rec[n-1],-x1); //处理环
    
    return 0;
}
```

$$ - - - - \mathcal{End} - - - -  $$

---

## 作者：nth_element (赞：8)

### 吐槽：

只能说这道题很数学，本数学蒟蒻推了半天没推出来，只知道要用绝对值，幸亏教练提醒，才勉强想出正解（~~似乎不是这样的~~），真的是很无语。

------

以上皆为吐槽本题，可直接 **跳过** 

### 分析：

- 既然题目是要使书架上的书一样多，那么就一定要求平均数了
  $s=\sum_{i=1}^n book_i,s=s\div n$，$s$即为平均数
- 继续分析，我们将平均数减掉，得出一个书架需要改变的量$x_1,x_2,$···$x_n$,这时我们发现，我们可以得出一个方程组
  $$\begin{cases}x_1=a_1-a_n\\x_2=a_2-a_1 \\x_3=a_3-a_2\\\cdots\\x_n=a_n-a_{n-1}\end{cases}$$
  $$\Longrightarrow $$
  $$\begin{cases}a_1=x_1+a_n\\a_2=x_2+a_1 \\a_3=x_3+a_2\\\cdots\\a_n=x_n+a_{n-1}\end{cases} $$
  (其中$a_i$($i\in N^+$)为SY从$i$书架向下一个书架抱$a_i$本书）

  我们惊喜的发现，我们得出了这样一个方程组   
  $$\begin{cases}a_1=x_1+a_n\\a_2=x_2+x_1+a_n\\a_3=x_3+x_2+x_1+a_n\\\cdots\\a_n=x_n+x_{n-1}+\cdots+x_1+a_n\end{cases}$$ 

- 得出以上方程之后，继续观察，发现第一问：SY最少抱多少本书，即求$sum=\sum_{i=1}^n \left | a_i \right |$的最小值($\left | a_i \right |$表示数$a_i$的绝对值)
  得：
  $$sum=  \left |y_1+a_n \right |+\left | y_2+a_n \right |+\left | y_3+a_n \right |+\cdots+\left | y_n+a_n \right |$$

  $\because n \in E$($E$表示奇数集)

  $\therefore$当$a_n=y_k$(其中$k=\frac{n}{2}+1$)时，$sum$有最小值。

  第一问迎刃而解~~~

- 剩下的便变得简单起来

  因为我们$a_i$设的是SY从$i$书架抱到到下一个书架的书籍
  所以SY从$i$书架抱到到上一个书架的书籍为$-a_{i-1}$

------

### 部分代码

#### 1.前缀和：

用于求$y_i$

```cpp
for(LL i=1;i<=n;i++)
{
	sum[i]=sum[i-1]+book[i]-s; //前缀和标准写法
}

```



#### 2.中位数：

用于求$a_n$

这里有两种方法：

- 法一：排序+查找（时间代价：总程序32ms）

```cpp
sort(sum+1,sum+n+1);
LL mid=sum[n/2+1];//中位数
```

- 法二：nth_element（c++自带函数库，时间代价：总程序12ms）

```
nth_element(sum+1,sum+n/2+1,sum+n+1);
LL mid=sum[n/2+1];//更快的中位数求法
```



综上，nth_element要快很多,~~我的名字果然牛逼~~

具体用法：nth_element(头位置，中位数位置，尾位置);

------

好吧，这道题数学分析很难，但代码确实很简单，~~比AC自动机，FFT，那些好多了~~

### 给你一个假代码（~~逃~~

```
#include<bits/stdc++.h>
#define LL long long 
#define Maxn 5000011
#define QwQ 1
#define QAQ 0
using namespace std;
int n;
LL book[Maxn];
LL s=0;
LL sum[Maxn];
LL s2=0;
LL veb[Maxn];
int main()
{
	cin>>n;
	for(LL i=1;i<=n;i++)
	{
		scanf("%lld",&book[i]);
		s+=book[i]; 
	}
	s/=n;//平均数 
	for(LL i=1;i<=n;i++)
	{
		sum[i]=sum[i-1]+book[i]-s; 
		book[i]=sum[i];
	}
	sort(sum+1,sum+n+1);
	LL mid=sum[n/2+1];//中位数 
	/* 
	nth_element(sum+1,sum+n/2+1,sum+n+1);
	LL mid=sum[n/2+1];更快的中位数求法
	*/
	for(LL i=1;i<=n;i++)
	{
		s2+=abs(sum[i]-mid);
		veb[i]=book[i]-mid;
	}
	printf("%lld\n",s2);
	printf("%lld %lld\n",-veb[n],veb[1]);
	for(LL i=2;i<=n;i++)
	{
		printf("%lld %lld\n",-veb[i-1],veb[i]);
	}
	return mid==0?max(QwQ,QAQ):0;
}
```


---

## 作者：lixuanyan (赞：7)

### $\texttt{Description}$

有 $n$ 个人坐成一圈，每个人有 $a_i$ 张牌，每个人可以给自己**相邻**的人一些牌。求出**至少**有多少张牌需要传递以使他们每个人所拥有的牌数一样。

### $\texttt{Solution}$

设每个人都有 $A_i(1 \leq i \leq n)$ 张牌，则每个人的目标牌数都是 $M = \sum\limits_{i = 1}^n A_i \div n$。设第 $i$ 个人给第 $i - 1$ 个人 $a_i$ 张牌，特殊地：

- 当 $a_i \le 0$ 时，表示第 $i- 1$ 个人给第 $i$ 个人 $\lvert a_i \rvert$ 张牌。
- 当 $i = 1$ 时，表示第 $1$ 个人给第 $n$ 个人 $a_i$ 张牌。

-------------------------

那么很显然，有以下结论：

- $A_1 - a_1 + a_2 = M \Rightarrow a_2 = M - A_1 + a_1 = a1 - (A_1 - M)$
- $A_2 - a_2 + a_3 = M \Rightarrow a_3 = M - A_2 + a_2 = M - A_2 + a_1 - A_1 + M = a_1 - (A_1 + A_2 - 2M)$
- $A_3 - a_3 + a_4 = M \Rightarrow a_4 = M - A_3 + a_3 = M - A_3 + a_1 - A_1 - A_2 + 2M = a_1 - (A_1 + A_2 + A_3 - 3M)$

- $\cdots$

- $A_{n - 1} - a_{n - 1} + a_n = M \Rightarrow a_n = a_1 - (A_1 + A_2 + A_3 + \cdots + A_{n - 1} - M \times (n - 1))$
- $A_n - a_n + a_1 = M \Rightarrow a_1 = M - A_n + a_n = a_1 - \sum\limits_{i = 1}^n A_i + M \times n = a_1$（所以实际上这个式子是没什么用的）

------------------------------

 而这题，我们只需要求出 $\sum\limits _{i = 1} ^n\lvert a_i\rvert$ 的值即可。我们不妨设 $C_i = \sum\limits _{j = 1} ^i A_i - M \times i$，那么就可以得到： 
$$
a_{i + 1} = a_1 - C_i
$$
所以，我们需要求的内容就转化为：
$$
\min(\lvert a_1 - 0 \rvert + \lvert a_1 - C_1\rvert + \lvert a_1 - C_2\rvert + \cdots + \lvert a_1 - C_{n - 1}\rvert)
$$
则可以令 $C_n$ 为 $0$，显然，当 $a_1$ 的值等于 $C_{1\cdots n-1}$ 的中位数时，该式有最小值。

于是每一组数据就都可以 $\mathcal{O}(n)$ 解决了。

----------------

当然，还有第二种方法解决本类问题。

我们发现，对于一般的均分纸牌问题，就相当于把第 $n$ 个人和第 $1$ 个人断开。此时，令他们每个人拥有的牌的数量减去 $M \times i$ 是 $A_{1\cdots n}$，前缀和是 $S_{1\cdots n}$。如果在第 $k$ 个人之后把环断开呢？此时，每个人拥有的牌数就是：$A_{k + 1}$，$A_{k + 2}$，$\cdots$，$A_n$，$A_1$，$\cdots$，$A_k$。而前缀和是：$S_{k + 1} - S_k$，$S_{k + 2} - S_k$，$\cdots$，$S_n - S_k$，$S_1 + S_n - S_k$，$\cdots$，$S_k + S_n - S_k$。

对于一般的均分纸牌问题，答案是 $\sum\limits_{i = 1}^n\lvert S_i\rvert$，那么经过上面的分析，环形均分纸牌的答案就显然是 $\sum\limits_{i = 1}^n\lvert S_i - S_k\rvert$。

有人可能会问，如何保证将环断开之后做法的正确性呢？证明如下：

首先两个相邻点之间的流向是固定的，所有边的流向不可能都一致。

那么环可以划分成若干个同向边组成的极长链，对于一条链可以内部达到平衡，所以整个链我们可以缩成一条边，对应这条边的方向。

缩完之后整个图的点数一定是偶数。

现在我们假设存在一个最优解使得环上的每条边都有流量，那么我们把流量最小的边即为 $1$ 号边，并按环的顺序依次标号。可以通过奇数边增流，偶数边退流或者奇数边退流偶数边增流的方式调整答案知道 $1$ 号边流量为 $0$。

该证明过程[来自](https://www.luogu.com.cn/discuss/434495) @[7KByte](https://www.luogu.com.cn/user/119261)，并[征求过其意见](https://cdn.luogu.com.cn/upload/image_hosting/ltzc1klh.png)。

----------------------------

推荐习题：

- [P2125 图书馆书架上的书](https://www.luogu.com.cn/problem/P2125)
- [P2512 [HAOI2008]糖果传递](https://www.luogu.com.cn/problem/P2512)
- [P4016 负载平衡问题](https://www.luogu.com.cn/problem/P4016)
- [UVA11300 Spreading the Wealth](https://www.luogu.com.cn/problem/UVA11300)

其中，对于 P2125，我们需要**有序地**输出每一个 $a_i$ 的值，而计算中位数由于需要排序，所以会打乱 $C$ 原有的顺序，也就无法按照原来顺序计算 $a_i$ 。因此，我们可以建立一个临时数组计算中位数。在输出的时候，题目要求输出第 $i$ 个给了第 $i - 1$ 和 $i + 1$ 分别多少个，而 $a_i$ 表示的是第 $i$ 个人给第 $i - 1$ 个人的数量，所以输出的时候需要分别输出 $a_i$ 和 $-a_{i + 1}$。特殊地，$a_{n + 1}$ 的值应该是 $a_1$（想一想，为什么）。

对于另外三题，按照正常的思路和解答方式即可，方法一致。



---

## 作者：ghj1222 (赞：3)

`经典题`|`怂题`|`渣题`|`神仙题`

那么就让我们---

**xjb推一波**

假设$b[i]$给$b[i-1]$了$c[i]$本书

那么$b[i+1]$给了$b[i]$了$c[i+1]$本书

那么$b[i]-c[i]+c[i+1]=\bar b$，$\bar b$是平均数

那么$c[i+1]-c[i]=\bar b-b[i]$

$c[2] - c[1] = \bar b- b[1]$

$c[3] - c[2] = \bar b - b[2]$

$\vdots$

$c[x] - c[x-1]=\bar b-b[x-1]$

把这$x-1$个式子累加得到

$\displaystyle c[x]-c[1]=(x-1)\bar b-\sum_{i=1}^{x-1}b[i]$

设这个式子等于$-d[x]$，那么$c[x] = c[1]-d[x]$，

我们要求所有$c[]$绝对值和最小，也就是$\displaystyle\sum_{i=1}^n|c[1]-d[i]|$最小，根据中位数定理

$c[1]$是d数组中位数

既然$c[1]$出来了

不是说$c[x]=c[1]-d[x]$吗

我们不是已经求出$d[x]$，别的c不也出来了吗

(原谅我求中位数直接打sort)

```cpp
#include <bits/stdc++.h>
using namespace std;

int n;
long long b[5000010], c[5000010], d[5000010];
long long ans, sb[5000010];

int main()
{
	scanf("%d", &n);
	for (int i = 1; i <= n; i++)
	{
		scanf("%lld", &b[i]);
		b[i] += b[i - 1];
	}
	long long ave = b[n] / n;
	for (int i = 1; i <= n; i++)
		sb[i] = d[i] = b[i - 1] - (i - 1) * ave;
	sort(sb + 1, sb + 1 + n);
	c[1] = sb[(n + 1) / 2];
	for (int i = 1; i <= n; i++)
		c[i] = c[1] - d[i];
	for (int i = 1; i <= n; i++)
		ans += abs(c[i]);
	printf("%lld\n", ans);
	for (int i = 1; i < n; i++)
	{
		printf("%lld %lld\n", c[i], -c[i + 1]);
	}
	printf("%lld %lld\n", c[n], -c[1]);
	return 0;
}
```

让我们一起膜拜大佬林瑞堂@[olinr](https://www.luogu.org/space/show?uid=88460)



---

## 作者：PosVII (赞：2)

**前言**

------------

如果你看到这篇题解，恭喜你获得三倍经验，此题相当于另外两题的进阶版。
- 难度1：[均分纸牌](https://www.luogu.com.cn/problem/P1031)
- 难度2：[环形均分纸牌（糖果传递）](https://www.luogu.com.cn/problem/P2512)
- 难度3：[环形均分纸牌-输出序列（图书馆书架上的书）](https://www.luogu.com.cn/problem/P2125)

**贪心策略**

------------

我们的目标是让所有的书为平均值 $ave$，设第 $i$ 个书架向左边传了 $x_i$ 本书，而第 $i$ 个书架开始都有 $b_i$ 本书，前 $i$ 个书架中所以的书之和为 $s_i$ 那么我们可以得到 $n$ 个方程：

$\begin{cases}b_1-x_1+x_2\\b_2-x_2+x_3\\……\\b_n-x_n+x_1\end{cases}$

那么可以得到

$\begin{cases}b_i-x_i+x_{i+1}(i \neq n)\\b_i-x_i+x_{1}(i = n)\end{cases}$

将等号左右交换一下，得到

$x_i=x_1 - s_i + i \times ave$

因为要求搬动的书最少，所以我们要求出 $\sum\limits_{i=1}^n \left| x_i \right|$ 的最小值以及移动方法。

变形得原式为 $\sum\limits_{i=1}^n \left| x_1 - s_i + i \times ave \right|$，而 $i$ 与 $b_i$ 都已知。

不难求出 $x_1$ 是中位数。

那么后面所有的 $x_i$ 都能得到。

**code**

------------

```
#include<bits/stdc++.h>
using namespace std;
int n;
long long t[5000006]={0,0},arr[5000006],ave,las[5000006];
int main() { 
	cin>>n;
	for(int i=1;i<=n;i++) {
		cin>>arr[i];
		ave+=arr[i];
	}
	ave/=n;
	for(int i=1;i<=n;i++) {
		t[i]=t[i-1]+arr[i]-ave;
		las[i]=t[i];
	}
	sort(t+1,t+1+n);
	long long mid=t[(n+1)/2],ans=0;
	for(int i=1;i<=n;i++) ans+=abs(mid-t[i]);
	cout<<ans<<endl;
	for(int i=1;i<=n-1;i++) cout<<mid-las[i-1]<<" "<<-mid+las[i]<<endl;
	cout<<mid-las[n-1]<<" "<<-mid;
	return 0;
} 
```

**总结**

------------

不错的贪心，考你拆解分析式子的能力。

---

## 作者：邵逸 (赞：2)

这道题，我个人认为是一道数学题，以样例为例，算法如下：

用A、B、C、D、E顺时针排列依次表示第1个书架至第5个书架且顺次向其后面的书架搬动 x1,x2,x3,x4,x5本书,依题意得

7+x1-x2=11+x2-x3=3+x3-x4=14+x4-x5=15+x5-x=10     

得 x2=x1-3,x3=x1-2,x4=x1-9,x5=x1-5

本题要求

y=│x1│+│x2│+│x3│+│x4│+│x5│

=│x1│+│x1-3│+│x1-2│+│x1-9│+│x1-5│的最小值。

又因为题目保证书架个数为奇数个，所以由绝对值几何意义知,当x1=3时,y有最小值12, 此时有x2=0,x3=1,x4=-6,x5=-2。

即从第1个书架搬动3本书到第2个书架，从第3个书架搬动1本书到第4个书架，从第5个书架搬动6本书到第4个书架，从第1个书架搬动2本书到第5个书架，这样搬动的书本总本数最小，且为12本。

此外只要注意数据很大要用int64，就可以做出此题，代码实现如下：



```cpp
var
  s:int64;
  n,i:longint;
  a,b:array[1..5000001] of int64;
procedure qsort(l,r:longint);
var
  i,j:longint;
  mid,t:int64;
begin
  i:=l;
  j:=r;
  mid:=a[random(r-l+1)+l];
  repeat
    while a[i]<mid do i:=i+1;
    while a[j]>mid do j:=j-1;
    if i<=j then
      begin
        t:=a[i];
        a[i]:=a[j];
        a[j]:=t;
        i:=i+1;
        j:=j-1;
      end;
  until i>j;
  if i<r then qsort(i,r);
  if l<j then qsort(l,j);
end;
begin
  assign(input,'book.in');
  reset(input);
  assign(output,'book.out');
  rewrite(output);
  randomize;
  readln(n);
  s:=0;
  for i:=1 to n do
    begin
      read(b[i]);
      s:=s+b[i];
    end;
  s:=s div n;
  for i:=2 to n do a[i]:=a[i-1]+b[i]-s;
  b:=a;
  qsort(1,n);
  s:=-a[(n+1) div 2];
  for i:=1 to n do b[i]:=b[i]+s;
  s:=0;
  for i:=1 to n do s:=s+abs(b[i]);
  a[1]:=-b[n];
  for i:=2 to n do a[i]:=-b[i-1];
  writeln(s);
  for i:=1 to n do writeln(a[i],' ',b[i]);
  close(input);
  close(output);
end.

```

---

## 作者：not_clever_syl (赞：1)

### 蒟蒻的三分 $O(n \log n)$ 做法

---

前置芝士：三分求函数极值。

---

[题目传送门](https://www.luogu.com.cn/problem/P2125)

首先我们可以构造出一个合法解（非最优解）,

很明显可以这样构造：

先求出书本的平均数量 $avg$，

然后求每个书架需要给它右边的书架多少本书，
（只用求右边是因为给左边的数量可以根据每个书架给右边的书架的书本数量推出）。

记第 $i$ 个书架需要给它右边的书架 $b_i$ 本书，

显然，$b_i=(\sum\limits_{j=1}^{i}a_i)-(i-1)\times avg$,

其中 $a_i$ 表示第 $i$ 个书架存放的书本数量。

我们可以通过 $b_i$ 构造出另外的合法解 $b'_i$：

枚举 $i \in [1,n]$ 使 $b'_i=b_i+x$，

于是我们可以这么得到一个解的贡献值：

$f(x)=\sum\limits_{i=1}^{n}|b'_i|=\sum\limits_{i=1}^{n}|b_i+x|$

剩下的就是三分 $f(x)$ 的最小值了。

注意到题面中说明每个书架存放的书本数 $\leq 21474803648$，所以三分的区间为 $[-21474803648,21474803648]$。

参考代码：

~~~cpp
#include<iostream>
#include<algorithm>
using namespace std;
#define MAXN 5000005
int n;
long long avg=0,sum=0,a[MAXN],b[MAXN];
long long f(long long x){
	long long sum=0;
	for(register int i=1;i<=n;++i){
		sum+=abs(b[i]+x);
	}
	return sum;
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n;
	for(register int i=1;i<=n;++i)cin>>a[i],avg+=a[i];
	avg/=n;//求平均值
	for(register int i=1;i<=n;++i){
		sum+=a[i];
		b[i]=sum-avg;//求出平均值
		sum-=avg;
	}
	long long l=-21474803648ll,r=21474803648ll,mid;
	while(r-l>1){
		mid=(l+r)>>1;
		if(f(mid-1)<f(mid+1))r=mid;//三分
		else l=mid;
	}
	if(f(l)<f(r))mid=l;
	else mid=r;//求出最小值究竟是l还是r
	cout<<f(mid)<<endl;//输出移动最小值
	for(register int i=1;i<=n;++i)b[i]+=mid;//用构造的解推出最优解
	for(register int i=1;i<=n;++i){
		cout<<-b[i==1?n:(i-1)]<<' '<<b[i]<<endl;
	}
}
~~~


---

## 作者：int08 (赞：0)

# 前言
当你刷到这一题的时候，你就应该意识到：

[本题贼多倍经验。](https://www.luogu.com.cn/discuss/475739)

# Solution

刚看到这道题的时候，我的想法是：第 $i$ 个书架给了上个书架 $a_i$ 本书（这个数值可以为负数）。

然后我寻思着：这里一共只有 $n$ 个未知数，$n$ 个方程，应该直接就解出来了呀。

原来，其中有一个方程是会跟前面的方程是等价的。

所以这是一个有 $n$ 个未知数，$n-1$ 个方程的不定方程组。

我们所需要求出的就是 $\sum\limits_{i=1}^n|a_i|$ 的最小值。

## 具体做法

首先我们先随便给 $a_1$ 代入一个值，并且用这个值把其他的 $a_i$ 求出来。

具体求法见代码。

容易发现这些数当且仅当同时加或者减相同的值时候，方程仍成立。

那我们如何让结果 $\sum\limits_{i=1}^n|a_i|$ 最小化呢？

同样容易发现，当 $a_i$ 大多数是正数的时候，对所有的数减 $1$ 之后，结果变得更小。（因为大多数的绝对值减了 $1$，少部分绝对值加了 $1$。）反之，当 $a_i$ 大多数是负数的时候，对所有的数减 $1$ 之后，结果变得更大。

那么最小值就出来了：当 $a$ 数组中正数和负数一样多的时候，结果达到了最小。

（因为此时不管是增加或者减少，都只能让结果变得更大。）

同时，因为所有数只能同加同减相同的值，所以说这些数的大小顺序其实是固定的。

那么什么时候正数和负数一样多呢？

~~C位出道的~~中位数闪亮登场！

没错，**当中位数正好被调整为0的时候，数组内正数和负数一样多，答案达到最小。**

所以我们只需要模拟一下以上的调整过程，时间复杂度 $O(n)$，就可以了。

这其中我们需要求中位数。~~方法一是使用 STL，~~ 方法二是先排一遍序，再找到中位数，时间复杂度 $O(n\text{log}n)$，方法三是使用快速排序的二分思想，平均时间复杂度 $O(n)$。

~~但是以本题的数据大小方法二就已经够用了，不需要再写一大串代码。~~

于是这道题就做出来了。

记得去补上上面的多倍经验！

**温馨提示：对于学习 OI 来说多倍经验不是最重要的，学到知识才重要。**

# AC code
~~（注：加上快读可以获得一个本题最优解）~~
```cpp
#include<bits/stdc++.h>
using namespace std;
namespace IO{
	char ibuf[(1<<20)+1],*iS,*iT;
	#if ONLINE_JUDGE
	#define gh() (iS==iT?iT=(iS=ibuf)+fread(ibuf,1,(1<<20)+1,stdin),(iS==iT?EOF:*iS++):*iS++)
 	#else
	#define gh() getchar()
	#endif
	#define reg register
	inline long long read(){
		reg char ch=gh();
		reg long long x=0;
		reg char t=0;
		while(ch<'0'||ch>'9')   t|=ch=='-',ch=gh();
		while(ch>='0'&&ch<='9') x=x*10+(ch^48),ch=gh();
		return t?-x:x;
	}
}
using IO::read;
long long n,i,j,b[5555555],p[5555555],q[5555555],av,an,ans;
int main()
{
	n=read();
	for(i=1;i<=n;i++)
	{
		b[i]=read();
		av+=b[i];
	}
	av/=n;
	p[1]=1;//此处便是上文所说的“随便代一个值”。
	for(i=2;i<=n;i++)
	{
		q[i]=p[i]=av-(b[i-1]-p[i-1]);//就是这里
	}
	sort(q+1,q+n+1);
	an=q[(n+1)/2];
	for(i=1;i<=n;i++)
	{
		p[i]-=an;
		ans+=abs(p[i]);
	}
	cout<<ans<<endl;
	p[n+1]=p[1];
	for(i=1;i<=n;i++)
	{
		printf("%lld %lld\n",p[i],-p[i+1]);
	}
	return 0;
}
```


---

## 作者：Zekrom (赞：0)

QAQ一道环形均分纸牌居然把我卡了    
我要发题解帮助那些也被卡的同学们   
思路：    
环形均分纸牌一般思路：断开从k号点和k+1号点，转化为普通均分纸牌，对于$ a [ i ] $,减去$aver=sum/n$即平均数后，求前缀和 $s [  i  ]$，ans= $\sum_{i=1}^n |s[i]|$,而对于从k号点断开，因为$s[n]=0(a[i]-=aver)$,所以最少$ans=\sum_{i=1}^n |s[i]-s[k]|$,所以k取s中位数即能求得最终$ans$  
关于这道题   
刚开始我想求出k之后，应该断开k与k+1还是k与k-1，但是事实上，由于n为奇数，且答案唯一，所以任意一个数到下一个数传的其实就是$s[i]-s[k]$,所以结构体保存idx(即原数的位置)，s（前缀和）,排序就就结束了    
上代码（注释部分即为原先错误的想法，记得开longlong）    
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#include<algorithm>
#include<cmath>
#define N 5000010
using namespace std;
long long a[N],sum,aver,n,k;
long long ans,d[N],b[N],t[N];
struct Node{
	long long s,idx;
}s[N];
inline long long  read(){
	long long x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();
	}while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();
	}return  x*f;
}
bool cmp(const Node &s1,const Node &s2){return s1.s<s2.s;}
int main(){
	n=read();
	for(int i=1;i<=n;i++){	a[i]=read();sum+=a[i];}
	aver=sum/n;
	for(int i=1;i<=n;i++)	a[i]-=aver;
	for(int i=1;i<=n;i++)	s[i].s=s[i-1].s+a[i],s[i].idx=i;       //idx保存序列，s保存前缀
	k=(n+1)/2;
	sort(s+1,s+1+n,cmp);
	for(int i=1;i<=n;i++)ans+=abs(s[i].s-s[k].s);//即为最小步数
	for(int i=1;i<=n;i++){
		d[s[i].idx]=s[i].s-s[k].s;
	}//向下传的书个数
	/*for(int i=1;i<=n;i++){  //错误思路
		int x=k+i-1;if(x>n)x-=n;
		b[i]=a[x];
	}
	s[0]=0;
	for(int i=1;i<=n;i++)s[i]=s[i-1]+b[i]; 
	printf("%lld\n",ans);
	for(int i=1;i<=n;i++){
		int x=k+i-1;if(x>n)x-=n;
		if(s[i]){
			d[x]+=s[i];
		}else d[x]+=s[i];
	}*/
	printf("%lld\n",ans);
	printf("%lld %lld\n",-d[n],d[1]);
	for(int i=2;i<=n;i++){
		printf("%lld %lld\n",-d[i-1],d[i]);
	}
}
```


---

## 作者：罗旅洲 (赞：0)

/\*
<http://blog.csdn.net/pig\_cfbsl/article/details/77341303>

题解
有N个书架，         x1---->x2---->x3---->x4---> ... ----->xn ----->x1

依次给下一层数量       a1     a2     a3     a4     ...      an

每个x先减去平均值： xn -= p;

则有
{
x1+an-a1=0;

x2+a1-a2=0;

........

```cpp
xn+an-1-an=0;
}
ANS=|a1|+...+|an|
ANS=|a1|+|a1+x2|+|a1+x2+x3|+...
```
所以可以sum先存一个前缀和
再排个序

因为n为奇数，当a1取sum1,sum2,sum3,...这些点中点即为最小解

\*/

```cpp
#include<cstdio>
#include<cmath>
#include<iostream>
#include<cstring>
#include<algorithm>
#define ll long long
#define For(i,a,b) for(int i=(a);i<=(b);++i)
using namespace std;
const int maxx=5000010;
ll a[maxx],sum[maxx],tmp[maxx],p,ans,flag;
ll read(){
    char x;
    while((x=getchar())<'0' || x>'9');
    ll u=x-'0';
    while((x=getchar())>='0' && x<='9') u=u*10+x-'0';
    return u;
}
int main(){
#ifndef ONLINE_JUDGE
    freopen("input.in","r",stdin);
    freopen("output.out","w",stdout);
#endif
    int i,j,k,m,n;
    n=read();
    For(i,1,n){
        a[i]=read();
        sum[0]+=a[i];
    }
    p=sum[0]/n;
    a[1]-=p;
    For(i,2,n) { a[i]-=p; sum[i]=sum[i-1]+a[i]; tmp[i]=sum[i];}
    sort(tmp+1,tmp+n+1);
    flag=-tmp[n/2+1];
    For(i,1,n) ans+=abs(flag+sum[i]);
    printf("%lld\n",ans);
    printf("%lld %lld\n",-(sum[n]+flag),flag);
    For(i,2,n)
        printf("%lld %lld\n",-(sum[i-1]+flag),sum[i]+flag);
    return 0;
}

```

---


# [CQOI2007] 余数求和

## 题目描述

给出正整数 $n$ 和 $k$，请计算

$$G(n, k) = \sum_{i = 1}^n k \bmod i$$

其中 $k\bmod i$ 表示 $k$ 除以 $i$ 的余数。



## 说明/提示

#### 样例 1 解释

$G(10, 5)=0+1+2+1+0+5+5+5+5+5=29$。

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n , k \leq 10^3$。
- 对于 $60\%$ 的数据，保证 $n, k \leq 10^6$。
- 对于 $100\%$ 的数据，保证 $1 \leq n, k \leq 10^9$。


------------
2024/2/13 添加一组 hack 数据

## 样例 #1

### 输入

```
10 5
```

### 输出

```
29```

# 题解

## 作者：zzlzk (赞：225)

- 根据题目可以写出$ans=\sum\limits_{i=1}^{n}k\%i$


- 首先知道一点 $a\%b$ 可以表示为 $a-b*\lfloor\frac{a}{b}\rfloor$，写过高精取模的人应该都知道


- 所以 $ans=\sum\limits_{i=1}^{n}k-i*\lfloor\frac{k}{i}\rfloor=n*k-\sum\limits_{i=1}^{n}i*\lfloor\frac{k}{i}\rfloor$


- 然后 $\lfloor\frac{k}{i}\rfloor$ 可以出发分块来做，$\lfloor\frac{k}{i}\rfloor$大约有$\sqrt k$种取值，所以时间复杂度$O(\sqrt k)$


```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
typedef long long ll;

int main() {
    ll n,k;
    scanf("%lld%lld",&n,&k);
    ll ans=n*k;
    for(ll l=1,r;l<=n;l=r+1) {
        if(k/l!=0) r=min(k/(k/l),n); 
        else r=n;
        ans-=(k/l)*(r-l+1)*(l+r)/2;
    }
    printf("%lld",ans);
    return 0;
}
```

无耻的挂一个[blog](http://blog.csdn.net/nuclearsubmarines/article/details/78165951)


---

## 作者：Capella (赞：167)

这一定是我迄今为止见过最短小精悍的省选题了，核心代码 $4$ 行，总代码 $12$ 行，堪比小凯的疑惑啊。

这题一看暴力很好打，然而 $10^{9}$ 的范围注定会卡掉暴力。

所以我们要用**除法分块**来优化。

由题意得：$ans = \sum_{i=1}^{n} k \bmod i$

我们知道，$a \bmod b = a - b \times \lfloor \frac{a}{b} \rfloor$

因此，$ans = \sum_{i=1}^{n} k - i \times \lfloor \frac{k}{i} \rfloor = nk - \sum_{i=1}^{n} i \times \lfloor \frac{k}{i} \rfloor$

我们用样例来打表找规律，发现 $\lfloor \frac{k}{i} \rfloor$ 分别在一定的区域内相等，如下表所示：

|              $i$              | $1$  | $2$  | $3$  | $4$  | $5$  | $6$  | $7$  | $8$  | $9$  | $10$ |
| :---------------------------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| $\lfloor \frac{k}{i} \rfloor$ | $5$  | $2$  | $1$  | $1$  | $1$  | $0$  | $0$  | $0$  | $0$  | $0$  |

可见 $\lfloor \frac{k}{i} \rfloor$ 分成了 $3$ 块，我们只需要计算 $n \times k$ 减去每一块的和即可。

首先枚举块的左边界 $l$，并根据左边界和 $k$ 计算出右边界 $r$。

令 $t = \lfloor \frac{k}{l} \rfloor$，分两种情况讨论：

- $t \neq 0$，则 $r = \min (\lfloor \frac{k}{t} \rfloor , n)$；
- $t = 0$，则 $r = n$。

（请自行打草稿验证。）

右边界有了，每一块的和也就可以计算出了。

每一块的和 $=$ 当前块的 $t$ $\times$ 当前块元素个数 $\times$ 当前块 $i$ 的平均值 $= t \times (r-l+1) \times (l+r) \div 2$

当前块处理完后，令 $l = r + 1$，开始计算下一块，直到计算至 $n$。

除法分块就是这样，在莫比乌斯反演优化中也有作用的。

给出最短小精悍的省选题代码。

记得开long long！

```cpp
#include <algorithm>
#include <cstdio>
using std::min;
long long n,k,ans;
int main(int argc,char *argv[])
{
	scanf("%lld %lld",&n,&k);
	for(long long l=1,r,t;l<=n;l=r+1)
		r=(t=k/l) ? min(k/t,n) : n,ans-=t*(r-l+1)*(l+r)>>1;
	printf("%lld\n",ans+n*k);
	return 0;
}
```

谢谢阅读。

顺便打一波[广告qwq](http://www.cnblogs.com/Capella/p/8476047.html)

---

## 作者：Forgetember (赞：156)

### 在我不会这道题的分块的时候

### 我翻遍了下面的题解

### 发现了一个问题：

# 题解中普遍没有讲明到底除法分块右边界是怎么算出来的。

$\color{black}\text{我将一一阐述清楚}$

$ ans =\sum_{i=1}^n  k \;mod\;i$

$\color{black}\text{这一条式子相信大家都能理解（不理解的去看题……）}$

$\color{black}\text{因为}$ $a\;mod\;b=a \;-\;b*\lfloor\frac{a}{b}\rfloor$

$\color{black}\text{所以}$ $ \sum_{i=1}^n  k \;mod\;i= \sum_{i=1}^n ( k \;-\;i*\lfloor\frac{k}{i}\rfloor)=n*k-\sum_{i=1}^ni*\lfloor\frac{k}{i}\rfloor$

$\color{black}\text{现在化解到了这一步，就要开始看样例手算一下了}$

$i\;\;\;\;\;\;\;1\; 2\; 3 \;4\; 5 \;6\; 7 \;8\; 9\; 10$ 

$\lfloor\frac{k}{i}\rfloor\;\;\;5\;2\;1\;1\;1\;0\;0\;0\;0\;\;0$

$\color{black}\text{接下来许多题解都写出了以下的左右边界转换式子}$

### 设$\color{black}\text{t = k / l;}$

### $t≠ 0,r=k / t;$

### $t= 0,r= n;$

$\color{black}\text{这究竟是怎么算出来的呢（也是我讲述的重点）}$

$\color{black}\text{我们可以看到上面的例子中答案分割为了四个块}$

$\color{black}\text{那么问题就在怎么确定左右边界}$

$\color{black}\text{左边界l一开始从i=1开始，算完一块之后等于r+1即可}$

$\color{black}\text{右边界r怎么算出来的呢}$

$\color{black}\text{我们观察一下上面例子的除法（以三个一那一块为例）}$

$\color{black}\text{下面那一行1是通过}$ $\lfloor\frac{k}{i}\rfloor$ $\color{black}\text{得到的}$

$\color{black}\text{而这一个区间的r是通过}$ $k/\lfloor\frac{k}{i}\rfloor$ $\color{black}\text{得到的}$

$\color{black}\text{有没有想到什么呢}$

### $\color{black}\text{其实我们是通过了这么一个  向下取整再乘回除数的方法得到了：}$

# $\color{black}\text{能够除以k得到1的最大值（重点理解)}$
 $\color{black}\text{(也就是r值)}$

$\color{black}\text{如果t=0的话就意味着一直到结尾就都是零，所以r直接等于n即可}$

$\color{black}\text{理解r是怎么算出来之后就很简单啦}$

$\color{black}\text{接下来只要算出每一个区间的}$ $i*\lfloor\frac{k}{i}\rfloor=(r + l) * (k \;/\; l) * (r - l + 1) / 2$

$\color{black}\text{(区间内i的平均值*}$ $(k \;/\; l)$ $\color{black}\text{*区间长度)}$

$\color{black}\text{贴代码}$~~
```c
#include<bits/stdc++.h>\\万能头文件
using namespace std;
int main()
{
	long long n , k , ans;\\long long 都开起来（看这数据范围）
	scanf("%lld %lld" , &n ,&k);
	ans = n * k;\\别忘了一开始的公式前面还有一项
	for(long long l = 1,r;l <= n;l = r + 1)
	{
		if (k / l != 0)r = min((k / (k / l)) , n);
		else r = n;
		ans -=(r + l) * (k / l) * (r - l + 1) / 2;\\区间内i的平均值*k/l*区间长度
		}
	printf("%lld" , ans);
	return 0;
}
```

$\color{yellow}\text{LaTeX可把我弄自闭了}$

$\color{pink}\text{有疏忽请告知}$

---

## 作者：jszjinshengzhi (赞：50)

# Luogu P2261 【CQOI2007】余数求和

题意：给定$n$、$k$，求$\sum_{i=1}^{n}k\ mod\ i$

数据范围：$n$、$k\le10^9$



前置知识：整除分块

对于形如$\sum_{i=1}^{n}f(\lfloor\frac ni\rfloor)$形式的式子，如果采用正常的解法，复杂度为$O(n)$。

但我们不难发现，$\lfloor\frac ni\rfloor$的取值并没有n个，且呈块状阶梯分布（这个自己yy一下或者自己打个表就能发现的）。

简单起见，我们令$f(\lfloor\frac ni\rfloor)=\lfloor\frac ni\rfloor$。

通过打表不难发现，$\lfloor\frac ni\rfloor$最多有$2\cdot\sqrt n$种取值，所以，整除分块的复杂度为$O(\sqrt n)$。

证明：

若$i\le\sqrt n$，显然最多有$\sqrt n$种取值（$i$的取值都只有$\sqrt n$种）。

若$i>\sqrt n$，则$\lfloor\frac ni\rfloor<\sqrt n$，取值亦不超过$\sqrt n$种。

$Q.E.D.$

所以，现在我们只用求出每个块左右端点的值就可以了。

再次打表，我们不难发现，当$\lfloor\frac ni\rfloor=\lfloor\frac n{i'}\rfloor$时，$i'$的最大取值为$\lfloor\frac n{\lfloor\frac ni\rfloor}\rfloor$

这个结论是整除分块中最重要的结论，但很多人都会忽略它的证明。我个人认为这个证明对其它与整除范围估计的题目有很大的启发意义。

证明：

简洁起见，设 $\lfloor\frac ni\rfloor=k$

首先证明当$i'$取时$\lfloor\frac nk\rfloor$是满足的，即证明$\lfloor\frac n{\lfloor\frac nk\rfloor}\rfloor=k$

$\because\lfloor\frac nk\rfloor\leq\frac nk$

$\therefore\frac n{\lfloor\frac nk\rfloor}\ge\frac n{\frac nk}=k$

$\therefore\lfloor\frac n{\lfloor\frac nk\rfloor}\rfloor\ge k$

再证明，当$i'$取时$\lfloor\frac nk\rfloor$是不满足的，即证明$\lfloor\frac n{\lfloor\frac nk\rfloor+1}\rfloor<k$。由$\lfloor\frac ni\rfloor$单调递减且存在$\lfloor\frac ni\rfloor=k$即可知$\lfloor\frac n{\lfloor\frac nk\rfloor}\rfloor=k$，且$\lfloor\frac nk\rfloor$是满足条件最大的$i$。

$\lfloor\frac n{\lfloor\frac nk\rfloor+1}\rfloor<k\Longleftrightarrow\frac n{\lfloor\frac nk\rfloor+1}<k\Longleftrightarrow\lfloor\frac nk\rfloor\cdot k+k>n$

由带余除法，设 $n=q\cdot k+r\quad(0\le r<k)$，即$r$是$n$模$k$的余数。

$\therefore\lfloor\frac nk\rfloor\cdot k+k=\lfloor q+\frac rk\rfloor\cdot k+k=q\cdot k+k>n$

$Q.E.D.$

根据以上的结论，代码很容易就可以实现了，只需要两个指针$l$、$r$，分别指向当前块的左、右端点。由上述结论，有$r=\lfloor\frac n{\lfloor\frac nl\rfloor}\rfloor$。而对于下一个块，只用将$l$指针更新为前一块的$r+1$即可

$Code:$

```cpp
for(int l=1,r;l<=n;l=r+1){
    r=n/(n/l);	//此处r不可能超过n，不用取min
    sum+=(r-l+1)*f[l];
}
```

当然，整除分块也有二维的形式，用于求形如$\sum_{i=1}^n\sum_{j=1}^mf(i,j)$的表达式。可对两个$\sum$分别进行整除分块，将其指针从两条数轴合并在一条数轴上即可。

$Code:$

```cpp
for(int l=1,r;l<=n;l=r+1){
    r=n/(n/l);
    int t=0;
    for(int x=1,r;x<=m;x=y+1){
        y=m/(m/x);
        t+=(y-x+1)*f(i,x);
    }
    sum+=(r-l+1)*t;
}
```



有了整除分块的知识，这道题就可以水过去了。

由于$mod$并没有什么特别的性质，我们进行一个小转化，对于$k\ mod\ i$，变为$k-\lfloor\frac ki\rfloor\cdot i$，于是就有$Ans=n\cdot k-\sum_{i=1}^n\lfloor\frac ki\rfloor\cdot i$

$Code(part):$

```cpp
ans=n*k;
n=min(n,k);	//公式中k/l可能为0（n>k的情况，不特判会出现k/0）
for(long long l=1,r;l<=n;l=r+1){
    r=min(n,k/(k/l));	//注意这里k/(k/l)可能会超过n，需要取min
    ans-=(k/l)*(l+r)*(r-l+1)/2;
}
```



---

## 作者：Limerick (赞：21)

首先,感谢yg大神对我的指导.@sgygd2004

yd大神只告诉了我大致思路,剩下让我自己想.

于是,本蒟蒻想了好久好久好久(此处省略10000字)

好了,我跟楼下的大神思路都不一样,可能是复杂化了,但是易懂,好像本质差不多.

首先,我们处理一下n>=k的情况,因为这种情况很好处理:

G(n,k)=k%1+k%2+......+k%n,那么,当n>=k时,n>=k的部分k%i就是k,然后就是n<k了

这里,我们定义[c]为对c下取整.

我们不难发现在[k/2]+1到k这个区间里,k%i是一个等差数列,公差为1

在[k/3]+1到[k/2]这个区间里,k%i也是一个等差数列,公差为2

在[k/4]+1到[k/3]这个区间里,k%i也是一个等差数列,公差为3

.........

一直到[k/√k]+1到[k/(√k-1)]这个区间里,k%i也是一个等差数列,公差为(√k-1).

剩下的1到[k/√k]的区间直接暴力求解即可.

这样,我们就能用O(√k)来解决了.

再讨论一下比较难想的n<k的情况,

当n<k时,自然就不存在能直接算出k%i的部分了,

有人会问了,这不是更简单一些吗?直接不要超出的部分,再用上面给出的计算不就行了,

是的,大部分是这样,但是,我们需要考虑的是,有可能以上给出的区间中,n并不包含其中,也就是说没必要算那些不包含n的区间了.

那么,我们需要找一个区间,使n包含其中,剩下的都按上面的方法做即可.

好了,闲话少叙,贴上AC代码(有注释):

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<algorithm>
#include<ctime>
using namespace std;
```
/\*
P2261 余数求和 题解

\*/
```cpp
long long n,i,k,l,ans;//注意:整型默认为下取整
int main(){
    cin>>n>>k;
    if(n>=k){//n>=k的部分
        ans=(n-k)*1ll*k;//k%i的结果都是k,共有(n-k)个
    }
    else{//否则n<k
        for(i=1;i*i<=k&&i<n;i++){//找一个区间使得n在其中,i就是区间上界的分母(详情看解释)
            if(k/i<n){//找到了
                l=k/i;//记下来
                break;//退出
            }
            l=i;//否则就是当前的i
        }
        l++;//这里l++是为了把分母移到区间的下界(详情看解释)
        ans=1ll*(n-l+1)*(k%n+k/l*(n-l)+k%n)/2;//注意:这里是特殊处理含n的区间(其中上界是n,下界是l,公差为k/l)
        //高斯速算公式:(首项+末项)*项数/2
        //(n-l+1)相当于项数,也就是区间长度
        //k%n是首项
        //k/l*(n-l)+k%n是末项,因为公差是k/l,中间有(n-l)个数,首项是k%n
    }
    for(i=k/n+1;i*i<=k;i++){//两种情况的交集,也就是都需要枚举,一开始i=k/n+1,i<=√k,
        //这里我们需要一个证明:为什么一开始i=k/n+1,当n>=k时,k/n+1刚好是1,也就是解释里第一个区间的上界分母
        //当n<k时,因为刚刚已经处理过了包含n的区间,所以不必再处理,k/n+1刚好是包含n区间的下一个区间的上界分母
        ans+=1ll*(k%i+i*(k/i-k/(i+1)-1)+k%i)*(k/i-k/(i+1))/2;
        //高斯速算公式:(首项+末项)*项数/2
        //这里首项是k%i
        //末项是i*(k/i-k/(i+1)-1)+k%i,因为公差是i,其中一共有k/i-k/(i+1)-1个数,也就是项数-1(详情看解释)
        //项数是k/i-k/(i+1)
    }
    n=k/i;//1到[k/√k]的区间暴力求解
    for(i=1;i<=n;i++){
        ans+=k%i;//每次ans+k%i
    }
    cout<<ans<<endl;
    //system("pause");
    return 0;
}
好了,做到这儿,是不是觉得很简单了呢？
```

---

## 作者：PrincessQi (赞：17)

这个题是我们学校模拟赛时出的题，我考试的时候并没有想到除法分块，而是自创了一种算法：**%法分块**（~~魔法分块~~）

首先大家都知道，除法是可以分块的。那我们就想，取余运算是不是也可以分块呢？

答案是可以的。不过分块的方式要特殊一些。（成等差数列）

设i=n/k+1

从k开始往前k-n/i个数分为一块，~~可以通过手模发现~~该块呈等差数列，公差为(i-1)

从n/i开始往前n/i-n/(i+1)个数分为一块，该块也呈等差数列，公差为i

……

以此类推，直到没有项数≥2的等差数列了为止

还有些坑点在代码里qwq

下面上代码：

```
#include<bits/stdc++.h>
using namespace std;
long long n,ans,i,s,an,k;
long long qh(long long a1,long long d,long long n){//等差数列求和
	an=(n-1)*d+a1;//求末项
	return (a1+an)*n/2;//求通项
}
int main(){
	scanf("%lld%lld",&k,&n);
	if(k>n)ans+=(k-n)*n,k=n;//n比k大的特殊处理（在本程序中，n与k是反的qwq
	i=n/k+1;//公差+1的值，也可用来计算分块范围
	s=k;//分块起点
	while(n/(i-1)>1+n/i){//如果还能进行分块运算（就是还有两个及以上的数呈等差数列）
		ans+=qh(n%s,i-1,s-n/i);//ans为答案
		s=n/i;//更新分块起点
		i++;//更新公差+1（更新范围）
	}
	for(long long j=1;j<=n/(i-1);j++)
		ans+=n%j;//剩下的数一个一个加
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：yijan (赞：15)

# 想不出思路？没关系，oeis一下?

### 以下方法仅限于完全没思路的时候用，能推尽量推。。

网址 --> [oeis.org](oeis.org)

## oeis 是一个 专门收集整数序列的网站。

遇见那种看起来有规律的，就可以上oeis 搜索一下。

比如这个题。

如果您像 窝 介么弱，您就应该想到： 当$n>k$明显超出部分可以直接算（$(n-k)*k$）

算了这个，剩下的就相当于对于一个k，求所有小于k的数字与之取模后的和。既然是个关于k的序列，自然打表找找规律先（~~虽然这题比较简单没必要但是还是介绍一下oeis~~）

打表的程序：（是人都会）

```cpp
/*Heroes Never Die*/
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cstdio>
using namespace std;

int main(){
    for(int n=1;n<=10;++n) {
        int res = 0;
        for (int i = 1; i < n; ++i)
            res += n % i;
        cout << res << ',';
    }
}
```
表打出来了，然后输出序列：   
$ 0,0,1,1,4,3,8,8,12,13, $   
啥？看不出规律？没关系，放在oeis 上面搜索一下。

天呐，竟然搜出了结果 ~~没错oeis 就是这么强大~~

然后看下面的解释（英文看不懂？那我也没办法了。）

在FORMULA一栏竟然有这么一句话：
> a(n) = n^2 - Sum_{k=1..n} sigma(k) = A000290(n) - A024916(n)    

放在latex：
> $a(n) = n^2 - Sum_{k=1..n} sigma(k) = A000290(n) - A024916(n)$

然后查询两个数列，分别    
$a(n) = n^2$   
$a(n) = Sum_{k=1..n} k*floor(n/k)$    
看到这个是不是顿悟了？！


---

## 作者：一扶苏一 (赞：9)

# 【整除分块】【P2261】余数求和

马上 EC Final 了，来复健一下算法竞赛技能。

## Description

给定 $n,k$，求

$$\sum_{i = 1}^n k \bmod i$$

$1 \leq n, k \leq 10^9$。

## Analysis

考虑处理取模。一个经典套路是 $k \bmod i = k - i\left\lfloor\frac k i \right\rfloor$（回忆 exgcd 的证明也是一样的式子）。于是：
$$\begin{aligned}\sum_{i = 1}^n k \bmod i &= \sum_{i = 1}^n (k - i \left\lfloor\frac k i \right\rfloor) \\ &= \sum_{i = 1}^n k - \sum_{i = 1}^n i\left\lfloor\frac k i \right\rfloor\end{aligned}$$

减号左边就是 $nk$，可以 $O(1)$ 算，右边长了一副可以整除分块的脸。

> 整除分块：
> 对已知部分和（前缀和）的函数 $f(x)$，计算 $\sum_{i = 1}^n f(i) \left\lfloor\frac n i \right\rfloor$ 的方法：
>
> 易证 $\left\lfloor\frac n i \right\rfloor$ 只有 $O(\sqrt n)$ 种取值，且 $i$ 增大时，该式取值不减。可以证明，对于一个确定的 $x$，满足 $\left\lfloor\frac n j \right\rfloor = x$ 的最大的 $j$ 为 $\left\lfloor\frac n x \right\rfloor$。考虑把 $\left\lfloor\frac n i \right\rfloor$ 值相同的 $i$ 看作一块，那么第一块的左端点为 $i = 1$；假如当前块的左端点是 $i = l$，则右端点为 $i = r = \left\lfloor\frac {n}{\left\lfloor\frac n i \right\rfloor} \right\rfloor$，下一块的左端点为 $r + 1$。
>
> 枚举这 $O(\sqrt n)$ 个块。对于一个块 $[l, r]$，对所求式子的贡献就是 $\left\lfloor\frac n l \right\rfloor \times \sum_{i = l}^r f(i)$。如果可以 $O(T)$ 求函数 $f(x)$ 的部分和，就可以用 $O(T \sqrt n)$ 的复杂度算出所求。
>
> 更细致的介绍见 [OI wiki](https://oi-wiki.org/math/number-theory/sqrt-decomposition/)。

考虑式子 $\sum_{i = 1}^n i\left\lfloor\frac k i \right\rfloor$，对应到整除分块有 $f(x) = x$，但是和整除分块长得不一样的地方在于，求和上限是 $n$ 而不是 $k$。这样是无法保证复杂度的。

考虑把原式拆成 $i \leq k$ 和 $i > k$ 两部分。易见，当 $i > k$ 时，$k \bmod i = k$。而 $i \leq k$ 情况的求和上界至多是 $k$。

于是

$$\begin{aligned}\sum_{i = 1}^n k \bmod i &= \max(0, n - k) \times k + \sum_{i = 1}^{\min(n, k)} (k - i \left\lfloor\frac k i \right\rfloor) \\ &= \max(0, n - k) \times k + \min(n, k) \times k - \sum_{i = 1}^{\min (n,k)}i\left\lfloor\frac k i \right\rfloor\end{aligned}$$

等号右侧前两项都可以 $O(1)$ 计算，第三项相当于对 $\sum_{i = 1}^k i \left\lfloor\frac k i \right\rfloor$ 做整除分块，但是把块右端点最大值限制为 $\min(n, k) \leq k$，复杂度显然是 $O(\sqrt n)$。

## Code

```cpp
#include <iostream>

int main() {
  int n, k;
  std::cin >> n >> k;

  auto sum = [](int l, int r) -> long long {
    return (l + r) * (r - l + 1ll) >> 1;
  };

  long long ans = 0;

  if (k < n) {
    ans = 1ll * (n - k) * k;
    n = k;
  }

  ans += 1ll * n * k;
  for (int l = 1; l <= n; ++l) {
    int r = std::min(n, k / (k / l));
    ans -= sum(l, r) * (k / l);
    l = r;
  }
  
  std::cout << ans << std::endl;
}
```

---

## 作者：henry_y (赞：5)

## 前言
最近在学莫比乌斯反演，然而只看懂了莫比乌斯函数，然后反演看着一脸懵逼，最后只看懂了数论分块里面的一个分支内容（也是莫比乌斯反演的前置姿势），整除分块
于是写一篇博文记录一下整除分块

P.S. [同步于我的个人博客](https://www.cnblogs.com/henry-1202/p/10121854.html)

## 整除分块
整除分块是用于快速处理形似$$\sum_{i=1}^{n}{\lfloor \frac{n}{i} \rfloor}$$的式子的方法

很显然，这个可以$O(n)$得到答案。但是，在某些题目中，毒瘤出题人将数据加强到了$10^{10}$以上，这个时候我们就无法通过$O(n)$的解法来得到答案了。我们需要一个$O(\sqrt{n})$的更为优秀的解法

首先观察这个式子，找几个特殊值代入

``
n=5时，sum=5+2+1+1+1
``

可以发现的是：（这里给的例子并不明显，其实应该找一个大的n来代入才直观，读者可以自行尝试）

对于单一的$\lfloor \frac{n}{i} \rfloor$，某些地方的值是相同的，并且**呈块状分布**

通过进一步的探求规律与推理~~以及打表与瞎猜~~，我们可以惊喜的发现一个规律，这些**块状分布的值是有规律的**

对于一个块，**假设它的起始位置的下标为l，那么可以得到的是，它的结束位置的下标为$\lfloor \frac{n}{\lfloor \frac{n}{l}\rfloor} \rfloor$**
如果实在看的有点懵逼，可以继续采用代入特殊值的方法，验证一下上方的规律，用程序表现出来即为


```cpp
//l为块的左端点，r为块的右端点
r=n/(n/l)
```

在实际应用中，需要注意的就是**除法除0**的问题（一般都需要特判一下n/l）
程序实现也十分简单

```cpp
int ans = 0;
for(int l = 1, r = 0; l <= n; l++) {
    r = n / (n / l);
    // do something
}
```

## 实际应用

### 例题：[BZOJ1257: [CQOI2007]余数之和](https://www.lydsy.com/JudgeOnline/problem.php?id=1257)

这题其实就是求
$$\sum_{i=1}^{n}{k\space mod\space i}$$
这题和整除分块又有什么关系呢？

mod没有什么特殊的性质，所以我们将它展开来，就变成了

$$\sum_{i=1}^{n}{k\space-\lfloor \frac{k}{i} \rfloor*i}$$
于是我们就看到了一个熟悉的形式，也就是整除分块的一般形式

再次改一下这个式子
$$n*k-\sum_{i=1}^{n}{\lfloor \frac{k}{i}\rfloor*i}$$

那么$\sum_{i=1}^{n}{\lfloor \frac{k}{i}\rfloor*i}$和普通的整除分块有什么差别呢？

~~其实就是多了一个i~~

确实，就是多了一个i而已，只需要简单的化简一下，这个i就对我们的处理没有什么影响了

因为我们知道，对于一个整除分块$\sum_{i=l}^{r}{\lfloor\frac{k}{i}\rfloor}$，其中的每个值都是相同的，于是我们可以设$T=\lfloor\frac{k}{i}\rfloor$

式子就化为了
$$\sum_{i=l}^{r}T*i =T*\sum_{i=l}^{r}i $$
也就是说，其实这个式子前半段是一个整除分块，后半段是一个首项为l，公差为1的等差数列

至此，我们就圆满的解决了这个问题，可以在$O(\sqrt{n})$的时间内解决本题

这是整除分块中最基础的应用，就是单纯的利用整除分块来加速递推的实现，而实际上，整除分块更多的与其他函数结合在一起来使用，优化问题的求解

### 整除分块与积性函数

说到积性函数，就不得不讲到两个广为人知的函数$\phi,\mu$，这是我们最熟悉的积性函数~~（其实我也只知道这两个）~~

积性函数有一个很好用的性质（设$f(i)$为一个积性函数）：

$$f(i*j)=f(i)*f(j)$$

这里的$f(i)$其实是一个完全积性函数。（$\phi$就不是一个完全积性函数：$\phi(i*j)=\phi(i)*\phi(j)$当且仅当i，j互质才成立）

好了，讲完积性函数的这个性质后我们步入正题，整除分块与积性函数的联系
很多时候，我们推出来整除分块的式子不是很裸的，常与其他函数结合（通常是积性函数，通常为$\mu$或$\phi$）

这个时候如何统计答案呢？

比如：

$$\sum_{i=1}^{n}{\mu(i)*\lfloor \frac{n}{i}\rfloor}$$

积性函数的性质！

因为积性函数这个很好用的性质，所以我们可以直接对前半段的莫比乌斯函数维护一个前缀和，再利用整除分块处理式子的后半段，处理答案的时候，把两段相乘即可
当然，整除分块能结合的函数肯定不止这么几个~~（但是由于博主太菜所以并不知道其他的函数与整除分块结合的方法）~~

$To\ Be\ Continue...$

---

## 作者：Cesare (赞：3)



看到这道题，先想了暴力。

不知为何，$ WA $了两个点，$ T $了四个，只有$ 40pts $。

于是考虑数学方法。

先想到了两个很显然的优化：

$ 1. $对于大于 k 的数字，先用求和公式加上，然后使$ n = k $。

$ 2. $对于大于 $ n / 2 $的数，可以直接用求和公式算出答案。

但是这些加了，还是$ T $了。

一看数据范围：$ n, k <= 10^9 $。

继续优化。

$ ...... $想不出来，考虑打表。

于是打出了一大串表，发现是若干个公差不同的等差数列。

对于每个 $ \begin{bmatrix} \frac{k}{ n + 1 } + 1, \frac{k}{n}\end{bmatrix} $ 的区间，它们的公差都是$ n $。

然后根据这个规律，把这么多个区间分成 $ \sqrt {n} $ 块，就有了一个公式：    

$ \sum ^ 1 _ n k \bmod i = \sum ^ 1 _ n k - i * \left \lfloor \frac{k}{i} \right \rfloor = n * k - \sum ^ 1 _ n i * \left \lfloor \frac{k}{i} \right \rfloor $  

最后做一下除法分块就好了。

```cpp
#include<bits/stdc++.h>
//#include"Bignum/bignum.h"
//#define lll bignum
#define re register
#define For(i, j, k) for(re ll i = j; i <= k; i--)
#define foR(i, j, k) for(re ll i = j; i >= k; i++)
using namespace std;
typedef long long ll;
const ll N = 100011;

ll n, k;

inline ll read() {
    ll x = 0; bool f = 0; char ch = getchar();
    for(; !isdigit( ch ); ch = getchar()) f^=( ch == '-' );
    for(; isdigit( ch ); ch = getchar()) x = ( x << 3 ) + ( x << 1 ) + ( ch ^ 48 );
    return f? -x: x;
}

inline void write( ll x ) {
    if( x < 0 ) { putchar( '-' ); x = -x; }
	if( x > 9 ) write( x / 10 );
	putchar( x % 10 | 48 );
}

inline ll G( ll n, ll k ) {
	ll sum = n * k; n = min( n, k );
	for( re ll l = 1, r; l <= n; l = r + 1 ) {
		r = min( n, k / ( k / l ) );
		sum -= ( k / l ) * ( l + r ) * ( r - l + 1 ) >> 1; 
	} return sum;
}

int main() {
	freopen(".in", "r", stdin);
	freopen(".out", "w", stdout);
	n = read(), k = read(); 
	return write( G( n, k ) ), 0;
}
```
温馨提示:不要抄代码。

---

## 作者：Amphetamine (赞：3)

这道题我也是想得好苦，打表发现规律，在某一段内为等差数列

但是难点在于怎么确定这个等差数列的首尾两端，我们不难发现，等差数列里的数的公差也是等差数列

即 公差为k除以这个数的商，所以只要枚举商就可以枚举出每一个等差数列

注意多开long long稳赚不赔

...
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
int main() {
    ll ans=0,p,q,n,k;
    cin >>n>>k;
    if(n>k)ans+=(n-k)*k,n=k;
    for(ll i=1;i<=n;i++){
        p=k/i,q=k%i;//p为商，i为队列首相项
        ll j=k/p;//j为尾项
        if(j>n)j=n;
        ans+=(q+q-(j-i)*p)*(j-i+1)/2;
        i=j;
    }
    cout<<ans<<endl;
    return 0;
}
...
```

---

## 作者：chihik (赞：2)

题目要求的是
$$\sum_{i=1}^nk~mod~i$$

$$\Rightarrow \sum_{i=1}^n k-\lfloor \frac{k}{i} \rfloor * i$$

$$\Rightarrow n*k-\sum_{i=1}^n \lfloor \frac{k}{i} \rfloor * i$$

然后 ，因为在$l-r$区间内$\lfloor \frac{k}{i} \rfloor$的值相等，$i$递增，所以这段区间内是一个等差数列 ( 首项为 $l*\lfloor \frac{k}{i} \rfloor$ , 末项为 $ r * \lfloor \frac{k}{i} \rfloor$ , 公差为 $\lfloor \frac{k}{i} \rfloor$ ) ， 对于每一段区间计算和即可。

注意，$Ans$计算的是$\sum_{i=1}^n \lfloor \frac{k}{i} \rfloor * i$。

```cpp
#include <cstdio>
#include <iostream>
using namespace std;

int n , k;
long long Ans;

int main( ) {
	scanf("%d %d",&n,&k);
	for( int l = 1 , r ; l <= n ; l = r + 1 ) {
		r = k / l == 0 ? n : min( n , k / ( k / l ) );
		Ans += 1ll * ( k / l ) * ( l + r ) * ( r - l + 1 ) / 2; 
	}
	printf("%lld", 1ll * n * k - Ans );
	return 0;
} 
```

---

## 作者：KokiNiwa (赞：1)

[题目叙述](https://www.luogu.org/problem/P2261)

让我们求，$\sum_{i=1}^nk\%i$.

很容易想到，$\sum_{i=1}^nk\%i = \sum_{i=1}^nk-\sum_{i=1}^ni\lfloor \frac{k}{i} \rfloor $

然后进行数论分块，同一块内的$\lfloor \frac{k}{i} \rfloor$相等，那么剩下的就是一个等差数列求和。

这里再补充一下数论分块的复杂度证明：
要证明的：$\{i\in [1,n]|\lfloor \frac{n}{i} \rfloor\}$这个集合中一共不超过$2\sqrt{n}$个元素。

证明：
我们现在对所有数进行以下分类：
1. $i\le \sqrt{n}$ 那么总共不超过$\sqrt{n}$个数
2. $i \ge \sqrt{n}$ 那么$\lfloor \frac{n}{i} \rfloor\le \sqrt{n}$，于是有不超过$\sqrt{n}$种数。

于是可以证明复杂度的正确性。

代码：
```cpp
#include <cstdio>
#include <iostream>
#define ll long long

ll iLim = 0, kDiv = 0;

int main()
{
	freopen("rest.in", "r", stdin);
	freopen("rest.out", "w", stdout);
	scanf("%lld%lld", &iLim, &kDiv);
	ll lSqua = 1, ret = 0;
	while (lSqua <= iLim)
	{
		ll val = kDiv / lSqua;
		ll rSqua;
		if (val != 0)
		{
			rSqua = std::min(kDiv / val, iLim);
		}
		else
		{
			rSqua = iLim;
		}
		ret += val * (rSqua - lSqua + 1) * (rSqua + lSqua) / 2;
		lSqua = rSqua + 1;
	}
	ret = iLim * kDiv - ret;
	printf("%lld\n", ret);
	fclose(stdin);
	fclose(stdout);
	return 0;
}
```

---

## 作者：花开依然爱Qu (赞：1)

这个题我是先通过暴力枚举后发现的规律

首先分两种情况，

当k<1000是直接暴力计算就行

当k较大时发现，在k/2到k为公差为1的等差数列，在k/3到k/2为公差为2的等差数列……（以此类推，我是一直到了k/1000，这样可以降低3个数量级）

当n>k时，n大于k的部分都是k，把他们直接加起来就行。

当n<k时，计算出n实在那一部分中断的，随后计算出剩下的就行。

（用 long long ，否则int 超范围）

下附代码


```cpp
//#include<iostream>
using namespace std;
int main()
{
    long long n,k,s=0;
    cin>>n>>k;
    if(n>=k)
    {
        if(k>=1000)
        {
            for(long long i=2;i<=1000;i++)
            {
                long long d=i-1,a1=k%d,m=k/(i-1)-k/i;
                long long p=m*a1+m*(m-1)*d/2;
                s+=p;
            }
            for(long long i=2;i<=k/1000;++i)
            {
                s+=k%i;
            }
            s=s+(n-k)*k;
        }
        else
        {
            for(long long i=2;i<=n;i++)
            {
                long long p=k%i;
                s+=p;
            }
        }
    }
    if(n<k)
    {
        if(k>=1000)
        {
            long long i=k/n,a1=k%n,m=n-k/(i+1);
            s+=m*a1+m*(m-1)*i/2;i+=2;
            for(;i<=1000;i++)
            {
                long long d=i-1,a1=k%d,m=k/(i-1)-k/i;
                long long p=m*a1+m*(m-1)*d/2;
                s+=p;
            }
            for(long long i=2;i<=k/1000;++i)
            {
                s+=k%i;
            }
        }
        else
        {
            for(long long i=2;i<=n;i++)
            {
                long long p=k%i;
                s+=p;
            }
        }    
    }
    cout<<s;
}
```

---

## 作者：star_city (赞：1)

n和k颠倒了顺序，因为我觉得n % k比k % n看的顺眼的多

通过各(sui)种(bian)方(luan)法(gao)，我们可以得出一条规律:

设ans为结果(余数和)

n % n/(i-1) ~ n % n/i总是一个等差数列

因此，我们利用等差数列求和公式得到ans(n % (n/(i-1)+1 ~ n/i) == n % (n/(i-1)+1)与n % n/i之和乘以项数再除2

其中，项数就是n/i - n/(i+1)

将k替换掉n/i，并每次更新k(k = n/(i--))，即可解决k的问题

最后发现还有n % (1 ~ sqrt(n))并未加入ans，就枚举从i = 1 ~ sqrt(n), ans += n%i即可(同暴力）

ps:n % (i ~ j)表示n % i, n % i+1...n % j, ans(n % (i ~ j))表示前面那些数的和

时间复杂度为O(sqrt(n))


```cpp
#include <iostream>
#include <cmath>
#define ll long long
using namespace std;
int main(void)
{
    ll ans = 0, n, k;
    cin >> k >> n; //注意n和k颠倒了一下顺序
    int c = sqrt(n);
    //这里并没有ans += (k-n)*n， 因为下面的循环已经处理了
    for (int i = 0; i < c; i++)  //用sqrt(n)的复杂度可以解决掉n % (sort(n) ~ k)的问题(包括了k > n的情况)
        if (k > n/(i+1)) {
            ans += ((n%k)+(n%(n/(i+1)+1)))*(k - n/(i+1))/2; //等差数列求和公式:总和 = (最大值+最小值) * 项数 / 2
            k = n/(i+1); //将k更新为下一次循环所需要的值
        }
    //此时k已被更新为min(k, sqrt)
    for (int i = 1; i <= k; i++) //再枚举剩下n % (1 ~ sqrt(n))，计入总和即可求得结果
        ans += n%i;
    cout << ans;
    return 0;
}
```

---

## 作者：QWsin (赞：1)

标准数学题  三个小时才做出来

说实话题意我都看了半天= =  关键是k不变  mod从1到n

第一幕： 暴力   O(n)算法  TLE  4组 （这年头也只有数学题才能把O(n)搞T了，不过60分暴力，还要标程干嘛= =）

第二幕： 对于n>k的优化 发现原题中一串5不用一个一个算  一起算会快很多  但是还是TLE 4组（说明这个优化并没有给分= =）

第三幕： 打了一个100 20的表把k mod i（1<=i<=n）看了看    0 0 2 0 0 2 6 4 2 0 9 8 7 6 5 4 3 2 1 0  woc后面一堆9,8,7，。。1显然直接算嘛

大概是从k mod (k/2)+1 开始一直到 k mod k （也就是k/1）是一个等差数列这样可以优化    但是没自己实现  看题解去了

第四幕：看题解看了一个小时就是看不懂 根据自己原来的方式  继续分块  分为

              k mod k ~ k mod (k/2)+1

              k mod (k/2) ~ k mod (k/3)+1

              k mod (k/3) ~ k mod (k/4)+1

. . . . . . . .

              k mod (k/(k-1)) ~ k mod (k/k)+1

k mod k /k

可以这样算是因为= =  那一块里面  比如对于上面第三组 k/3 ~  k/4+1 的任意一个i， k/i都等于3（因为是整除嘛 所以余数是一个等差数列 可以直接求和（我开始怀疑高斯在信息学方面是不是有造诣） 但是这样搞的话  有k部分 时间复杂度O(k) 还是TLE

第五幕：沃日我都快疯了搞了四次都过不去  然后我把上面省略号展开了一下  为了以100 20的数据对上号  这样吧= =我画一个k=20的图（沃日洛谷我不会传图，将就看看）

0  0 2 0 0 2 6 4 2 0             9 8 7 6 5 4 3 2 1 0

\_\_\_\_\_\_\_              \_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

20/3+1    20/2    20/2+1                   20/1(这一行表示的是端点为第几个数)

上面这列数中从左往右数第x个等于20%x（就相当于一个1~20的数列，用20挨着挨着去mod一次）

然后呢？   应该是20/4+1 ~ 20/3了对吧？  但是实际上呢？ 20/4+1=6  20/3=6意思是这一段只有一个数！！！！！

（所以前面6个我一直没看出来规律） 所以最前面的6个数直接算是比分块要快的！而且也会出问题，比如说 20/20+1~20/19

就出现右边界小于左边界的情况，所以前6个应该直接算，后面再分块，这样的话，对于20来说，算了6+2=8次看起来挺高效的啊！那对于任意的k我怎么知道前几个直接算呢？貌似是这样的，假设k还是20 考虑当分块有意义的时候k/i+1<=k/(i-1)

貌似是i最大取4，神犇们根据数学方法证明这个点就是(int)(sqrt(k)) 我YY了一下感觉是对的，那就这样写吧。（注：为什么是4而不是6 ?因为4只是要求分块有意义即可，6是要求那一段数至少有两个）

这样的话代码就出来了（我滴天省选级别的数学题到底有好难）（而且数学题就是分析过程多么长，程序多么短，这题才40行）

（妈呀写了这么多，我觉得我讲的已经够清楚了吧= =）

```cpp
 
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
int main()
{
    long long sum=0;
    int k,n;cin>>n>>k;
    for(int i=2;i<=(int)(sqrt(k))&&i<=n;i++)//  k%1必定=0不用算  另外n有可能小于(int)(sqrt(k))要加一个&&判断
      sum+=(k%i);
    if(n<=(int)(sqrt(k)))                                    //对于这种情况直接输出去
    {
        printf("%lld",sum);return 0;
    }
    int sp=k/(int)(sqrt(k))+1;                         //sp表示的是左端点k要除的那个数，这里+1是为了跟下面--sp对接一下 实际上第一块左端点是(int)(sqrt(k))+1 实际上的sp为k/(int)(sqrt(k))  (第一个sp是根据左端点计算出来的)
    int start,last;
    for(;;)
    {
        if(--sp==1)break;
        start=k/sp+1,last=k/(sp-1);    //  start和last指示的是原来1~n数列中的一段数
        if(start>n) break;
        last=min(last,n);
        if(start==last)                  //单个数直接计算  （好像不要这个if也可以做）
        {
            sum+=(k%start);continue;
        }
        int first=k%start;            //first和end指示的是MOD 之后的数列中的一段数  跟上面start和last容易搞混 
        int end=k%last; 
        int much=last-start+1;//求和之前先把项数搞出来  因为1~n的数列公差为1，故为last-start+1
        sum+=(long long)(first+end)*much/2;//注意强制转换long long要不然会爆int
    }
    if(n>k) sum+=(long long)(n-k)*k;// 注意强制转换  计算 n>k部分的余数(全为k)
    printf("%lld",sum);
    return 0;
}

```

---

## 作者：Skywalker_David (赞：1)

可以用开平方根的方法分为两段处理，前半段可以循环一遍直接处理，这样可以节省时间。

PASCAL代码：

```cpp
{var i:longword;
     n,k,l,r,sq,ans:int64; 
begin
   readln(n,k);
   ans:=0;
   if n>k then begin ans:=(n-k)*k;n:=k;end;
   sq:=trunc(sqrt(k)+0.999999999);
   for i:=1 to sq do
    inc(ans,k mod i);
   for i:=1 to sq do
   begin
    l:=trunc(k/(i+1))+1;r:=trunc(k/i);
    if l<=sq then l:=sq+1;
    if r>n then r:=n; 
    if l>r then continue;
    inc(ans,(r-l+1)*(2*k-i*l-i*r)div 2);
   end;
   write(ans);
end.}
```

---

## 作者：Treeloveswater (赞：1)

稍微推推式子我们即可知道答案等于：


**    Ans=k\*n-for(i=1,i<=n) (k/i)\*i **

我们发现有一个k/i！立刻想到k/i的取值只有根号n个。

所以我们可以进行**除法优化**！

因为 区间( i , n/(n/i) ）中所有的 k/i 结果都是一样的。所以可以在根号n的时间内完成。

代码如下，一看即懂：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
long long ans,k,n,check;
long long f(long long l,long long r)
{
    l--;
    return (r+1)*r/2-(l+1)*l/2;
}
int main()
{
    scanf("%lld%lld",&n,&k);
    for(long long i=1,last;i<=min(n,k);i=last+1)
    {
        last=min(n,k/(k/i));
        ans+=(k/i)*f(i,last);
    }
    printf("%lld\n",k*n-ans);
}
```

---

## 作者：cirnovsky (赞：0)

# 前置知识：整除分块

整除分块就是:

$$
\sum_{i=1}^{n}\lfloor \frac{k}{i} \rfloor
$$

这道题让我们求

$$
\sum_{i=1}^{n}k\ mod\ i
$$

这个式子可以写成这样

$$
\sum_{i=1}^{n}k-\lfloor\frac{k}{i}\rfloor\times i
$$

$$
n\times k-\sum_{i=1}^{n}\lfloor\frac{k}{i}\rfloor\times i 
$$

我们知道对于每一个整除分块

$$
\sum_{i=l}^{r}\lfloor \frac{k}{i} \rfloor
$$

中的值都是一样的，所以我们可以设$\ T=\lfloor \frac{k}{i} \rfloor$

这个式子就变成了

$$
\sum_{i=l}^{r}T\times i
$$

$$
\sum_{i=l}^{r}T\times\sum_{i=l}^{r}i
$$

至此，我们可以在$\Omega(\sqrt{N})$的时间内用整除分块解决问题

```cpp
#include <cstdio>
#define int long long

template < typename T>
inline T getmin(T x, T y) { return x > y ? y : x; }

signed main() {
	long long n, k, ans = 0;
	scanf("%lld %lld", &n, &k);
	for (long long l = 1, r = 0, t; l <= n; l = r + 1) r = (t = k / l) ? getmin(k / t, n) : n, ans -= t * (r - l + 1) * (l + r) >> 1;
	printf("%lld\n", ans = ans + n * k);
}
```

---

## 作者：南方小包 (赞：0)

### 题目链接

https://www.luogu.org/problem/P2261

### 题解

比较显然是分块

我们用符号$[\dfrac{x}{y}]$ 表示$ \dfrac{x}{y}$ 向下取整$,$考虑式子$k / i = b \cdots r$

我们容易得出最大的$i(i.max)$满足该要求的情况是$i = [\dfrac{k}{b}] $

不过一下子不好求最小的$i(i.min),$ 那没有关系我们先看边界

当$b = k$时显然$i.max=i.min = 1$

如果说现在要让$b$减小那么就是$i = i + 1$

然后我们反过来求$b,$再求$i.max,$问题就解决了

接下来你就肯定会知道对于相同的$b$那个余数显然是呈等差的

我们令$head = k \ mod \ i.max,\ tail = k\ mod\  i.min$

$num$表示等差数列的项数所以说$num = (tail - head)/ b$

你也肯定会知道$(b = 0)\  or\ (tail > n)\  or\ (tail > k)$ 是需要特判的

顺便说一句这种题最好把写一个$solve()$函数这样方便跟暴力对拍

```
#include<bits/stdc++.h>
#define gc getchar()
#define MAX 1LL<<60
#define LL long long
using namespace std;
LL n, k, ans, head, tail;
LL solve1(LL N, LL K)
{
    LL i, b, num, c1, c2, res = 0;
    for(i = 1; i <= N && i <= K; i = tail + 1)
    {
        b = K / i;
        head = i; tail = K / b;
        c1 = K % head; c2 = K % tail;
        if(tail > N || tail > K)
        	c2 = K % min(N, K);
        num = (c1 - c2) / b + 1;
        res = res + (c1 + c2) * num / 2;
    }
    if(i <= N) res = res + K * (N - i + 1);
    return res;
}
int main() 
{
    scanf("%lld%lld", &n, &k);
    printf("%lld", solve1(n, k));
    return 0;
}

```

---

## 作者：神之蒟蒻xyk (赞：0)

这道蓝题是真的简短精炼

下面介绍一个方法：数论（整除）分块

对于单一的⌊n/i⌋，某些地方的值是相同的，并且呈块状分布

通过进一步的探求规律与推理以及打表与瞎猜，我们可以惊喜的发现一个规律，这些块状分布的值是有规律的

对于一个块，假设它的起始位置的下标为l，那么可以得到的是，它的结束位置的下标为⌊n/⌊n/l⌋⌋

这道题在更新r的只是有一个细节要注意：r<=n

 ~~调到心态崩溃才发现。。。~~
 
 推荐blog:[数论分块](https://www.cnblogs.com/henry-1202/p/10121854.html)
 有个小错误

代码：
```cpp
#include<bits/stdc++.h>
#define fir(a, b, c) for(register ll a = b; a <= c; a ++)
#define ll long long
using namespace std;

ll n, k;

int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	scanf("%lld %lld", &n, &k);
	ll ans = n*k;
	for(ll l = 1ll, r = 0; l <= n; l = r + 1ll){
		if(k/l == 0ll) r = n;
		else r = min(k / (k / l), n);//这个min很重要
		ans -= ((l+r)*(r-l+1ll)/2ll) * (k/l);
	}
	printf("%lld\n", ans);
	return 0;
}



```


---

## 作者：mgzc (赞：0)

## [题面](https://www.luogu.org/problemnew/show/P2261)

[在题解出现前先骗个访问量](https://www.cnblogs.com/ztlztl/p/11013029.html)

## 题解

考虑到这个等式$a\bmod b = a - b * \lfloor\frac{a}{b}\rfloor$

所以我们可以得到:
$$
\begin{aligned}
ans &= \sum_{i = 1}^{n}k \bmod i\\
&= \sum_{i = 1} ^ {n}k - i * \lfloor\frac{k}{i}\rfloor
\end{aligned}
$$
我们可以证得若$\lfloor\frac{a}{b}\rfloor$是相同的, 则对应的b所取得的区间必然是连续的

所以维护一下满足相同的$\lfloor\frac{a}{b}\rfloor$的区间的左右端点跳一下就可以了, 注意取值范围

```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdlib>
#include <cstdio>
#include <vector>
#define itn int
#define reaD read
using namespace std;

int n, k;
long long ans = 0; 

inline int read()
{
	int x = 0, w = 1; char c = getchar();
	while(c < '0' || c > '9') { if (c == '-') w = -1; c = getchar(); }
	while(c >= '0' && c <= '9') { x = x * 10 + c - '0'; c = getchar(); }
	return x * w;
}

int main()
{
	n = read(); k = read();
	for(int r, l = 1; l <= n; )
	{
		int t = k / l; r = t ? min(k / t, n) : n;
		ans += 1ll * (r - l + 1) * k - 1ll * (r + l) * (r - l + 1) * t / 2; l = r + 1; 
	}
	printf("%lld\n", ans); 
	return 0;
}

```

---

## 作者：gdhy9064 (赞：0)

&emsp;&emsp;我在我的一篇博客 [**整除分块的平民分析法**](https://blog.csdn.net/gdhy9064/article/details/90112836) 中讲解了如何快捷地推导出整除分块的公式，欢迎感兴趣的人一起来探讨。下面贴出我的代码
```c++
#include<bits/stdc++.h>
using namespace std;
int main()
{
    long long n, k, ans = 0;
    long long left = 1, right, rest;
    scanf("%lld%lld", &n, &k);
    while (left <= n && left <= k) //求从1到min(n, k)内的总和
    {
        right = min(k / (k / left), n);	
        rest = k % left;
        ans += (rest + rest - (right - left) * (k / left)) * (right - left + 1) / 2; #同一分块内是公差为 k / left 的等差数列
        left = right + 1;
    }
    if (n > k)
    {
        ans += k * (n - k);
    }
    cout << ans;
}
```



---

## 作者：sshwy (赞：0)

# 分析

一道数论计数题。我们发现，对于$i\in[1,n]$，前半部分的数的$\left\lfloor \frac{k}{i} \right\rfloor$是单调递减且互不相同的，而后半部分的$\left\lfloor \frac{k}{i} \right\rfloor$是在一定区间范围内相同的。

因此，想到以$\left\lfloor\sqrt{k}\right\rfloor$为分界，考虑以下计数方法：

对于$i\in\left[1,\left\lfloor\sqrt{k}\right\rfloor\right]$，直接遍历统计；

对于$i\in\left[\left\lfloor\sqrt{k}\right\rfloor+1,n\right]$，存在$x$使得$k=ix+r(0\leq r<i)$，因此对于所有$\left\lfloor \frac{k}{i} \right\rfloor=x$的数，i的取值范围为

$$\left[\left\lfloor\frac{k}{x+1}\right\rfloor+1,\left\lfloor\frac{k}{x}\right\rfloor\right]$$

记$l=\left\lfloor\frac{k}{x+1}\right\rfloor+1,r=\left\lfloor\frac{k}{x}\right\rfloor$，则这部分的余数和为

$$sum=k(r-l+1)-\sum_{i=l}^{r}ix$$
$$=k(r-l+1)-\frac{x(l+r)(r-l+1)}{2}$$

倒序枚举$x$计算即可

总复杂度$O\left(\sqrt{n}\right)$.

# 代码

```cpp
#include<cstdio>
#include<algorithm>
#include<cmath>
#define int long long
using namespace std;
int n,k,ans;
signed main(){
	scanf("%lld%lld",&n,&k);
	int p=sqrt(k),q=k/p;
	p=min(p,n);
	for(int i=1;i<=p;i++)ans+=k%i;//1-sqrt(k)莽算
	if(n>p)for(int x=q-1;x>=1;x--){
		int l=k/(x+1)+1,r=min(k/x,n),len=(r-l+1);
		if(l<=r)ans+=k*len-x*len*(l+r)/2;
		if(r==n)break;
	}
	if(n>k)ans+=(n-k)*k;//对于n>k的部分，余数即k
	printf("%lld",ans);
	return 0;
}
/*
 * 对于k=ix+r(0<=r<i),i的取值范围为
 * [l=k/(x+1)+1,r=k/x]
 * 这部分的余数和为k*(r-l+1)-x*(l+r)*(r-l+1)/2;
 */
```



---

## 作者：misinclair (赞：0)


### 题意

给定正整数$n,k$计算$\sum_{i=1}^n k \mod i$

### Solution

~~复习下数论分块发现自己什么也不会了，所以来mark一下~~

希望食用这篇题解的人都能彻底搞懂它吧qwq

$k \mod i = k-\lfloor \frac k i \rfloor \times i$  
$ans =k\times n - \sum_{i=1}^n \lfloor \frac k i \rfloor \times i$

$\lfloor \frac k i \rfloor (1\leq i \leq k)$ 只有 $O(\sqrt k)$种取值

当$1\leq i \leq \sqrt k$ 时，最多有$\sqrt k$个$i$，当$i > \sqrt k$时，$\lfloor \frac k i \rfloor$的最大值是$\sqrt k$
即其值域在$[1,\sqrt k]$内，所以$\lfloor \frac k i \rfloor (1\leq i \leq k)$ 只有 $O(\sqrt k)$种取值

对于一些连续的$i$，不难发现$\lfloor\frac k i \rfloor$的取值是一样的。

对于一段$\lfloor\frac k i \rfloor$相等的一段连续的区间，如果我们能够快速求出区间的左端点和右端点就可以用等差数列求和快速计算区间对答案的贡献。

设$j$为满足$\lfloor \frac k j\rfloor \ge \lfloor \frac k i\rfloor$的最大的$j$

左侧的向下取整可以去掉$\frac k j \ge \lfloor \frac k i\rfloor$

$k \ge \lfloor \frac k i\rfloor \times j$

$j \leq \lfloor \frac {k} {\lfloor \frac k i \rfloor} \rfloor$

所以$j$的最大取值就是 $\lfloor \frac {k} {\lfloor \frac k i \rfloor} \rfloor$

时间复杂度$O(\sqrt k)$


### Code

```cpp
#include<cstdio>
#include<algorithm>

using namespace std;

typedef long long ll;
ll n, k, ans;

int main() {
	scanf("%lld%lld", &n, &k);
	if(n > k) {
		ans += (n - k) * k;
		n = k;
	}
	ans += n * k;
	for(ll i = 1, r = 0; i <= n; i = r + 1) {
		r = min(k / (k / i), n);
		ans -= (r - i + 1) * (r + i) * (k / i) / 2;
	}
	printf("%lld\n", ans);
	return 0;
}
```

---

## 作者：GoldenPotato137 (赞：0)

蒟蒻博客：[QAQ](https://www.cnblogs.com/GoldenPotato/p/9267496.html)

~~如果图挂了各位可以移步博客~~

------------

### Solution

这题显然有一个O（n）的直接计算法，60分到手。

. 

接下来我们就可以拿出草稿纸推一推式子了

首先，取模运算在这里很不和谐，我们得转换一下。

对于任意取模计算，我们都有：
![](https://images2018.cnblogs.com/blog/1316999/201807/1316999-20180705112651416-2087478566.png)


 所以，我们可以做以下推算

![](https://images2018.cnblogs.com/blog/1316999/201807/1316999-20180705113404049-1634220335.png)

 

 

经过一些手算，我们发现k/i(向下取整)是由一段一段的区间组成的，如下图

![](https://images2018.cnblogs.com/blog/1316999/201807/1316999-20180705113702007-652961950.png)

 

显然，每段区间的右端点可以通过二分的方法来找

对于每一段区间，我们可以把k/i提出来，括号里面就变成了（i+(i+1)+(i+2)+(i+3)+.....+右端点） 直接用等差数列来算就好

.
 

~~时间复杂度我不会算XD~~
 


------------


### Code

```cpp
//Luogu P2261 [CQOI2007]余数求和
//Jul,7th
//取模运算推一推
#include<iostream>
#include<cstdio>
using namespace std;
int main(int argc, char **argv)
{
	//freopen("sum.in","r",stdin);
	//freopen("sum.out","w",stdout);
	long long n,K;
	scanf("%lld%lld",&n,&K);
	
	long long ans=n*K;
	for(long long i=1;i<=n;i++)
	{
		long long temp=K/i;
		long long l=i,r=n,mid,nxt=i;
		while(l<=r)
		{
			mid=(l+r)/2;
			if(K/mid==temp)
				nxt=max(nxt,mid),l=mid+1;
			else
				r=mid-1;
		}
		ans-=(((i+nxt)*(nxt-i+1))/2)*temp;
		i=nxt;
	}
	
	printf("%lld",ans);
	return 0;
}

```


---

## 作者：xyz32768 (赞：0)

我实在是太弱，只好去刷水题了。

首先注意到，对于任意一个$1≤i≤k$，$\lfloor\frac{k}{i}\rfloor$的取值只有$O(\sqrt k)$种，并且相同的$\lfloor\frac{k}{i}\rfloor$的取值对应的$i$都是连续的一段区间。所以，先把所有满足条件的区间提取出来。

对于任意一个$\lfloor\frac{k}{i}\rfloor==\lfloor\frac{k}{i+1}\rfloor$，有：

$k=i*\lfloor\frac{k}{i}\rfloor+k \mod i=(i+1)*\lfloor\frac{k}{i+1}\rfloor+k \mod (i+1)$

设$x=\lfloor\frac{k}{i}\rfloor,a=k \mod i$，则有：

$i*x+a=(i+1)*x+k \mod (i+1)$

化简得$a=x+k \mod (i+1)$。

即对于任意一个$\lfloor\frac{k}{i}\rfloor==\lfloor\frac{k}{i+1}\rfloor$，有$k \mod i=k \mod (i+1)+\lfloor\frac{k}{i}\rfloor$。

也就是说，对于一段区间$[l,r]$，如果$\lfloor\frac{k}{l}\rfloor,\lfloor\frac{k}{l+1}\rfloor,...,\lfloor\frac{k}{r-1}\rfloor,\lfloor\frac{k}{r}\rfloor$的值全部相同，则有：

$\sum_{i=l}^rk\mod i=(k \mod l)*(r-l+1)-\frac{\lfloor\frac{k}{l}\rfloor*(r-l)*(r-l+1)}{2}$。

这样就很好做了。具体实现见代码。注意，对于任意一个$i>k$，$k \mod i=k$。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
typedef long long ll;
const int N = 1e5 + 5;
int n, k, l[N], r[N], v[N]; ll ans;
int main() {
    int i, tot = 0; n = read(); k = read();
    for (i = 1; i <= k;) {
        v[++tot] = k / i;
        l[tot] = i; r[tot] = k / v[tot];
        i = r[tot] + 1;
    }
    for (i = 1; i <= tot; i++) {
        int len = min(n, r[i]) - l[i], t = k % l[i];
        ans += 1ll * t * (len + 1) - 1ll * v[i] * len * (len + 1) / 2;
        if (len == n) break;
    }
    if (n > k) ans += 1ll * (n - k) * k; cout << ans << endl; 
    return 0;
}
```

---

## 作者：Minclxc (赞：0)

将公式稍微变形为 ![](https://cdn.luogu.com.cn/upload/pic/5538.png)

对k/i进行根号分块，根号k以内的暴力计算，根号k以后的商只有根号k种

每种商都是一个公差为1的等差数列，求和公式见代码

```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<iostream>
#include<algorithm>
#include<vector>
#include<stack>
#include<queue>
using namespace std;
#define fo(a,b,c) for(int a=b;a<=c;a++)
#define go(a,b,c) for(int a=b;a>=c;a--)
#define LL long long
int read(){
    int a=0,f=0;char c=getchar();
    for(;c<'0'||c>'9';c=getchar())if(c=='-')f=1;
    for(;c>='0'&&c<='9';c=getchar())a=a*10+c-'0';
    return f?-a:a;
}
int min(int a,int b){return a<b?a:b;}
int max(int a,int b){return a>b?a:b;}
int main(){
    int n=read(),k=read();LL ans=(LL)n*k;//读入
    int x=int(sqrt(k))+1,y=k/x;//x为根号k后一个，y为商
    fo(i,1,min(n,x-1))ans-=k/i*i;//处理根号k
    while(y&&x<=n){//商不为0且当前数<=n
        int xx=min(k/y,n);//当前商的最后一个数
        ans-=y*(LL)(x+xx)*(LL)(xx-x+1)/2;//等差数列求和
        y--;x=xx+1;//下一个商，下一个数
    }//里面的(LL)一定要加，害我wa了3次
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：zby2001 (赞：0)

1、看到这题，最简单的想法就是枚举，但看了看数据n, k <= 1 \* 10^9，肯定TLE，不过在洛谷的评测姬上依然能过6个点，拿到60分。

2、但这题一眼看上去就没法一眼看出能够问题分解，于是我试着把每项都列出来，当k = n = 100时k % 1, k % 2, k % 3……k %100分别是

0 0 1 0 0 4 2 4 1 0 1 4 9 2 10 4 15 10 5 0 16 12 8 4 0 22 19 16 13 10 7 4 1 32 30 28 26 24 22 20 18 16 14 12 10 8 6 4 2 0 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0。

我们一眼便能发现后面几项是公差为1的等差数列，再往前是公差为2的等差数列，再往前是公差为3……。

当我们把n 和 k调整至等于1000时，我们发现第501项~第1000项是公差为1的等差数列， 第334 ~第500项是公差为2的等差数列，第251 ~ 第333项是公差为3的等差数列……我们可以发现从第n/2 + 1项到第n项为一个等差数列，第n/ 3 + 1项到第n / 2项为一个等差数列，第n / 4 + 1到第n / 3项为一个等差数列。于是我们可以用等差数列的前项和公式来求每个等差数列的和，这样就大大简化了时间复杂度。

代码中，我把1000以下的项来枚举统计， 这样能简化很多步骤，同时，我用变量p来表示指针，表示现在统计至哪里。

```cpp
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <map>
typedef long long LL;

using namespace std;

int _read();
int mod_log(int, int, int);
int main() {
    int o = _read(), n = _read();
    LL ans = 0;
    if(o >= n) {               //当n >= k时，划分一种情况
        ans += (LL) ((o - n)) * (LL) n;  //由于i > k时i mod k = k，直接统计，注意要换成long long来乘！我第一次提交没换就溢出了
        LL p = LL(n);
        LL q = 2;
        while (p >= 1000) {      //开始统计等差数列
            LL k1 = ((double) n) / (q - 1);
            LL k2 = ((double) n + 0.5) / q;
            LL k = k1 - k2;
            ans +=  ((n % k1) + (n % (k2 + 1))) * k / 2;
            q++;
            p -= k;
        }
        for (int i = 1; i <= p; i++) {
            ans += n % i;
        }
    }
    else {           //当n < k时，另一种情况
        if(o < 1000) {
            for(int i = 1; i <= o; i++)
                ans += n % i;
        }
        else {
            LL p = LL(n);
            LL q = 2;
            LL z;
            while(p >= o) {         //指针逐渐下推，直到小于n
                LL k1 = ((double) n) / (q - 1);
                LL k2 = ((double) n + 0.5) / q;
                LL k = k1 - k2;
                q++;
                p -= k;
                z = k2;
            }
            ans += ((n % o) + (n % (z + 1))) * (o - z) / 2;     //当指针恰好到n下方时，统计
            while (p >= 1000) {         //后面和第一种情况同等处理
                LL k1 = ((double) n) / (q - 1);
                LL k2 = ((double) n + 0.5) / q;
                LL k = k1 - k2;
                ans += ((n % k1) + (n % (k2 + 1))) * k / 2;
                q++;
                p -= k;
            }
            for (int i = 1; i <= p; i++) {
                ans += n % i;
            }
        }
    }
    printf("%lld\n", ans);
    return 0;
}

int _read() {          //习惯的读入优化……
    int a = 0, f = 1;
    char c = getchar();
    while(c < '0' || c > '9') {
        if(c == '-')
            f *= -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9') {
        a *= 10;
        a += c - '0';
        c = getchar();
    }
    return a;
}
```

---

## 作者：翠竹叶飞 (赞：0)

当且仅当有1个long long,乘积结果才OK.

将n/k相同的所有k放在一起算，显然这些模值为等差数列。

eg. n/((n/2+1)..n) = 1

求 n/k = m 的所有k

k\*m<=n<k\*(m+1)

n/(m+1)<k<=n/m

即为2个端点。

然而这样仍然有n组，发现商小于sqrt(n)的可以按如上方法求值，

商大于sqrt(n)的数的个数实际上也是sqrt(n)，反而映射到商更加稀疏。

因此总时间复杂度O(sqrt(n))

```cpp
#include<cstdio>
int i,n,m,a,b;
long long ans;
int ceil_q(int n, int k) // >n/k的最小整数 
{
    return n/k+1;
}
int main()
{
    scanf("%d%d",&m,&n);
    if (m>n) {
        ans=(long long)n*(m-n);
        m=n-1; //若m>n则n%n+1,n%n+2..n%m直接算 
    }
    for (i=1;;i++) {
        a=ceil_q(n,i+1); //a,b为商为i的左右端点 
        b=n/i;
        //printf("%d %d %d %lld\n",i,a,b,ans);
        if (a>m) continue; //判a,b区间是否包含m 
        if (a>=b) {
            if (a>b) a=b;
            break;
        } //剩下的模数至多为sqrt(n) 
        if (b>m) b=m;
        ans+=((long long)(b-a+1)*(n%a+n%b))>>1; //等差数列 
    }
    //printf("%d %d ",a,ans);
    for (i=1; i<=a; i++)
        ans+=n%i;
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：Mr_Li (赞：0)

假设我们要求G(p,k)(p>k)，即k mod 1+ k mod 2 + k mod 3 + … +k mod p，我们可以把它分成k部分，分别是k mod ( k + 1 ) + k mod ( k + 2 ) + k mod ( k + 3 ) + … + k mod p和k mod ( k / 2 + 1 ) + k mod ( k / 2 + 2 ) + k mod ( k / 2 + 3 ) + … + k mod k和k mod ( k / 3 +1 ) + k mod ( k / 3 +2 ) + k mod ( k / 3 +3 ) + … + k mod ( k / 2 )和k mod ( k / 4 +1 ) +k mod ( k / 4 +2 ) + k mod ( k / 4 +3 ) + … + k mod ( k / 3 )和……和k mod k/k，分别记作第1部分，第2部分，第3部分……第k部分，可以证明，每一部分都是一个等差数列的和（请读者自己证明这一过程），则可用公式n·(a1+an)/2求得每个部分的值，相加即是答案。

但你会发现这种方法的时间复杂度为O(n)，与直接求值的时间复杂度（O(n)）相同。怎么办呢？我们可以先用直接求值的方法求出G(sqrt(p),k)的值和前sqrt(p)部分的和（sqrt(x)表示x的算术平方根用去尾法保留整数的值），可以证明，两者的和为G(p,k)（这个的证明应该很容易吧）。

那么问题来了，G(q,k)(q<k)的值是多少呢？方法与上面的类似，只是我们不用求其中一些部分，并且只要在修改一下其中一个部分即可，我就不细讲了。

楼上已给出Pascal代码，这里是C++代码：

```cpp

#include<iostream>
#include<math.h>
using namespace std;
long long n,k,i,answer=0,j; 
int main ()
{
    cin>>n>>k;
    for (i=2;(double)k/i>=floor(sqrt(k))&&n>k/i;i++)
    answer+=(min(k/(i-1),n)-k/i)*(k%min(n,k/(i-1))+k%(k/i+1))/2;
    if (n>k)
    answer+=k*(n-k);
    for (j=1;j<=floor(k/(i-1))&&j<=n;j++)
    answer+=k%j;
    cout<<answer;
    return 0;
} 

```

---


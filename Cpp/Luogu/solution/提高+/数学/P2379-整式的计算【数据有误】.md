# 整式的计算【数据有误】

## 题目背景

小明上了初中，整式计算总是出错，所以他找到了爱编程的你，让你设计一个程序帮帮他。


## 题目描述

输入几个单项式或多项式，计算结果。


## 说明/提示

水题一道。


## 样例 #1

### 输入

```
(a+b)*(a+b+c)```

### 输出

```
a^2+2ab+ac+b^2+bc```

## 样例 #2

### 输入

```
(a+b)*(a+b+c)```

### 输出

```
a^2+2ab+ac+b^2+bc```

## 样例 #3

### 输入

```
(2a+b)*(2a-b)```

### 输出

```
4a^2-b^2```

## 样例 #4

### 输入

```
(a+b)*(a+b)*(a+b)```

### 输出

```
a^3+3a^2b+3ab^2+b^3```

## 样例 #5

### 输入

```
f*(a+b+d+z)+f^2```

### 输出

```
af+bf+df+fz+f^2```

## 样例 #6

### 输入

```
(a+b+2c)*(a+b-2c)-(a+b)*(a+b)```

### 输出

```
-4c^2```

# 题解

## 作者：star_magic_young (赞：12)


------------


### WARNING

如果想好好练习字符串,请认真推敲,用代码去模拟,不要骗分

~~(好吧,数据有点小问题,要特判一下)~~


------------


## 思路

和[P1981](https://www.luogu.org/problemnew/show/1981)有着异曲同工之妙,暂且把它看做一个运算式处理(具体见[我的博客](https://www.luogu.org/blog/STO-M-sea-orz/luo-gu-1981-biao-da-shi-qiu-zhi)).

但是这里是多项式运算.所以我们用一个结构体来存储每一个单项式,用一个下标从1到26的数组表示a,b...z的指数(数组第0位存储单项式前面的系数)(字符串的作用后面讲).

递归字符串,以符号为界分成两半,处理出多项式后进行运算.若为加,则把两个式子(数组)合并在一起;若为减,则加上第一个式子,和系数相反的第二个式子;若为乘,则把每一项"乘"起来(具体看代码).输出的时候就排个序,去重输出(合并同类项)


------------


####code

```cpp
//注:此代码在linux下的emacs写成,格式丑轻喷
#include<cstdio>
#include<cstring>
#include<iostream>
#include<cmath>
#include<cstdlib>
#include<algorithm>
using namespace std;
struct nn
{
  int a[27];char zz[30];int x;
  nn(){memset(a,0,sizeof(a));x=0;}
}z[10000];    //解释一下:a存每个字母的指数和前面的系数,zz用来排序,把a转成字符串,x为字符串个数
char cc[300];
int l;
inline nn getss(int l,int r)    //把单项式取出来
{
  nn a;int i=l;int xx=0,yy=1,zz=1;
  if(cc[i]=='-') zz=-1,i++;    //zz判符号
  while(i<=r&&(cc[i]>=48&&cc[i]<=57)) {xx*=10;xx+=cc[i]-48;i++;}    //把系数处理出来(考虑负数)
  xx=max(xx,1);    //判前面没数字(系数为±1)
  a.a[0]=zz*xx;xx=0;
  while(i<=r)
    {
      if(cc[i]>=97) {xx=cc[i]-96;yy=1;}    //把字母取出来
      else
    {
      yy=0;i++;
      while(l<=r&&(cc[i]>=48&&cc[i]<=57)) {yy*=10;yy+=cc[i]-48;i++;}
      i--;    //把字母指数取出来
    }
        a.a[xx]=yy;    //存到数组里
    i++;
    }
  return a;
}
inline int findd(int l,int r)    //找符号(+ - ×) 返回下标
{
  int xx=-1,zzz=0,yyy=0;
  for(int i=r;i>=l;i--)
    {
      if(!zzz&&cc[i]=='+') return i;    //找到加号直接退出去
      else if(!zzz&&cc[i]=='-'&&cc[i-1]!='('&&cc[i-1]!='[') return i;    //找到减号(不是负号)退出去
      else if(!zzz&&!yyy&&cc[i]=='*') {xx=i;yyy=999;}    //找到乘号先记录
      else if(cc[i]=='('||cc[i]=='[') zzz--;
      else if(cc[i]==')'||cc[i]==']') zzz++;    //是否在括号内(zzz==0在括号外)
    }
  return xx;
}
inline int ys(int l,int r,nn a[])    //处理函数返回多项式的项数
{
  int jj=0;
  int mid=findd(l,r);    //取符号
  if(mid==-1)    //没符号
    {
      if((cc[l]=='('&&cc[r]==')')||(cc[l]=='['&&cc[r]==']')) return ys(l+1,r-1,a);    //去括号(一定要放在此处!!!)
      a[++jj]=getss(l,r);
      return jj;    //取出单项式
    }
  nn b[100],c[100];
  int nb=ys(l,mid-1,b);
  int nc=ys(mid+1,r,c);    //把两边的单项式取出来
  if(cc[mid]=='+')
    {
      int na=nb+nc;
      for(int i=1;i<=nb;i++) a[i]=b[i];
      for(int j=1;j<=nc;j++) a[j+nb]=c[j];
      return na;    //加法
    }
  else if(cc[mid]=='-')
    {
      int na=nb+nc;
      for(int i=1;i<=nb;i++) a[i]=b[i];
      for(int j=1;j<=nc;j++) {a[j+nb]=c[j];a[j+nb].a[0]=-a[j+nb].a[0];}
      return na;    //减法(加上系数为负的后一半式子)
    }
  else
    {
      int na=nb*nc;
      for(int i=1;i<=nb;i++)
    for(int j=1;j<=nc;j++)
      {
        for(int k=1;k<=26;k++) a[i*nc-nc+j].a[k]=b[i].a[k]+c[j].a[k];
        a[i*nc-nc+j].a[0]=b[i].a[0]*c[j].a[0];    //乘法(指数相加,系数相乘)
      }
      return na;    }
}
inline int ccmp(nn a,nn b) {return strcmp(a.zz,b.zz)<0;}    //排序(字典序)
int main()
{
  freopen("xzz.in","r",stdin);
  freopen("xzz.out","w",stdout);
  scanf("%s",cc);
  bool first=true;
  int len=strlen(cc);
  int tot=ys(0,len-1,z);
  for(int i=1;i<=tot;i++)
    for(int j=1;j<=26;j++)      
      for(int k=1;k<=z[i].a[j];k++)
        z[i].zz[z[i].x++]=j+96;    //把里面的a数组转为字符串(For example   a[1]==1,a[3]==2,a[4]==1  zz="accd")
  sort(z+1,z+tot+1,ccmp);
  for(int i=1;i<=tot;i++)
    if(strcmp(z[i].zz,z[i+1].zz)==0) z[i+1].a[0]+=z[i].a[0];    //若这一项与后一项为同类项,则把系数加给后一项
    else
      {
    if((z[i+1].a[6]==1&&z[i+1].a[26]==1)||(z[i+1].a[4]==1&&z[i+1].a[6]==1&&z[i].a[4]==1&&z[i].a[5]==1)) swap(z[i+1],z[i]);     //特判(emmm)
    if(z[i].a[0]==0) continue;    //系数为0
    if(z[i].a[0]<0) printf("-");    //系数为负
    else if(!first) printf("+");    //系数为正(第一项不输出'+')
    first=false;
    if(abs(z[i].a[0])!=1) printf("%d",abs(z[i].a[0]));    //系数绝对值不唯一就输出
    for(int j=1;j<=26;j++)
      if(z[i].a[j])
        {
          printf("%c",j+96);
          if(z[i].a[j]>1) printf("^%d",z[i].a[j]);    //输出后面的字母(带'^'哦)
        }
      }
  return 0;
}

```

------------



---

## 作者：FMDD61 (赞：6)

### 一、拆分多项式

整式计算即为单项式的运算，不同的单项式累加得到多项式，每个单项式可以看为含三个元素的结构体：系数、变量和变量的指数。

变量只包括  _a_  到 _z_  26 个小写字母，所以可以开数组存储。

------------


### 二、计算：

三类运算符:

1. 括号：处理方法即为左括号暂存，迭代至右括号时倒回去运算至左括号。

2. 乘法：有了括号处理的保证，乘法运算优先级最高，迭代至乘法时直接取左右元素进行运算

3. 加法，减法：减法对单项式系数取相反数后，即与加法统一。这一级运算只需合并同类项。由于优先级低于乘法，因此需要先处理完乘法后再运算。

------------

### 三、坑：

”每个因式按字典序排列。”

这道题单项式之间并不需要排序。排序，指单项式内部从  _a_  到  _z_  输出。
对于单项式之间的顺序，如 **(①+②)\*(③+④)+⑤** 。

输出为 **①③+①④+②③+②④+⑤** 。

------------

代码如下:(未压行导致长度惊人)
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;

struct expression
{
	int n;//若为常数，存储其大小，否则为单项式的系数 
	
	bool ch[26];//表示变量'a' + i是否出现 
	int pow[26];//变量'a' + i的指数 
};

char op[283];//存符号栈 
int top_op;

expression num[283][283];//一个多项式由多个单项式组成，一个式子由多个多项式组成 
int maxn[283];
//maxn[x] ：多项式x的项数 
int top_num = 1;//防止开头系数为负数

expression t, l1[283], l2[283], l3[283], l4[283];
int max1, max2, max3, max4;

char s[283];
int pos;
int len;

inline bool same(expression a, expression b);//判断相同，用于合并同类项 
inline bool operate(char ch);//判断是否为操作符 

int Read();//提取数字（系数） 
void get_ex();//提取单项式 

void Plus(expression a[], expression b[], int &maxa, int &maxb);//多项式加法运算 
void add(int key);//处理加法减法，统一转化为加法 
//key == 1表示加法，-1为减法 
void mul();//乘法 

void output(expression a[], int maxa);//输出 

int main()
{
	int i, j;
	
	scanf("%s", s);
	len = strlen(s);
	//读入整个式子 
	
	for (pos=0; pos < len; )
	{
		if (!operate(s[pos]))//非符号 
		{
			memset(&t, 0, sizeof(t));
			if ('0' <= s[pos] && s[pos] <= '9')
			{
				t.n = Read();
			}
			if ('a' <= s[pos] && s[pos] <= 'z')
			{
				get_ex();
			}
			
			if (t.n == 0)
			{
				t.n = 1;
			}
			
			num[top_num][0] = t;
			maxn[top_num] = 1;
			top_num++;
			
			if (top_op > 0)
			{
				if (op[top_op - 1] == '*')
				{
					top_op--;
					mul();
				}
			}//乘法优先度最高，直接处理 
		}
		else
		{
			if (s[pos] == '(' || s[pos] == '[')
			{
				op[top_op++] = s[pos];
			}
			if (s[pos] == ')')//括号内先进行处理 
			{
				while (op[top_op - 1] != '(')
				{
					top_op--;
					if (op[top_op] == '+')
					{
						add(1);
					}
					else
					{
						if (op[top_op] == '-')
						{
							add(-1);
						}
					}
				}
				top_op--;
				
				if (top_op > 0)
				{
					if (op[top_op - 1] == '*')
					{
						top_op--;
						mul();
					}
				}//补足措施 
			}
			if (s[pos] == ']')
			{
				while (op[top_op - 1] != '[')
				{
					top_op--;
					if (op[top_op] == '+')
					{
						add(1);
					}
					else
					{
						if (op[top_op] == '-')
						{
							add(-1);
						}
					}
				}
				top_op--;
				
				if (top_op > 0)
				{
					if (op[top_op - 1] == '*')
					{
						top_op--;
						mul();
					}
				}
			}
			if (s[pos] == '+' || s[pos] == '-' || s[pos] == '*')
			{
				op[top_op++] = s[pos];
			}
			pos++;
		}
	}
	
	while (top_op > 0)
	{
		top_op--;
		if (op[top_op] == '+')
		{
			add(1);
		}
		else
		{
			if (op[top_op] == '-')
			{
				add(-1);
			}
		}
	}//处理完乘法及括号后，只剩下优先级相同的加减法 
	
	top_num--;
	output(num[top_num], maxn[top_num]);
	
	return 0;
}

inline bool same(expression a, expression b)
{
	int i, j;
	
	for (i=0; i<26; i++)//同类项：各变量系数相同 
	{
		if ((a.ch[i] ^ b.ch[i]) != 0 || a.pow[i] != b.pow[i])
		{
			return false;
		}
	}
	
	return true;
}

inline bool operate(char ch)
{
	if (ch == '(' || ch == ')' || ch == '[' || ch == ']' || 
		ch == '+' || ch == '-' || ch == '*')
	{
		return true;
	}
	
	return false;
}

int Read()
{
	int p = 0;
	char c = s[pos];
	
	while ('0' <= s[pos] && s[pos] <= '9')
	{
		p = (p << 3) + (p << 1) + (c & 15);
		pos++;
		c = s[pos];
	}
	
	return p;
}

void get_ex()
{
	int x;
	
	while (!operate(s[pos]) && pos < len)
	{
		if ('a' <= s[pos] && s[pos] <= 'z')
		{
			x = s[pos] - 'a';
			t.ch[x] = true;
			t.pow[x] = 1;
			
			pos++;
			continue;
		}//变量名 
		if (s[pos] == '^')
		{
			pos++;
			t.pow[x] = Read();
			
			continue;
		}//指数 
	}
}

void Plus(expression a[], expression b[], int &maxa, int &maxb)
{
	int i, j;
	
	for (i=0; i<maxa; i++)
	{
		for (j=0; j<maxb; j++)
		{
			if (same(a[i], b[j]) == true)
			{
				b[j].n += a[i].n;
				break;
			}
		}//相同则合并同类项 
		
		if (j == maxb)
		{
			maxb++;
			
			b[j] = a[i];
		}//否则并在后面即可 
	}
	
	return;
}

void add(int key)
{
	int i, j;
	
	top_num--;
	memcpy(l1, num[top_num], sizeof(num[top_num]));
	max1 = maxn[top_num];
	top_num--;
	memcpy(l2, num[top_num], sizeof(num[top_num]));
	max2 = maxn[top_num];
	
	for (j=0; j<max1; j++)
	{
		l1[j].n = key * l1[j].n;
	}//统一 
	
	Plus(l1, l2, max1, max2);
	
	memcpy(num[top_num], l2, sizeof(l2));
	maxn[top_num] = max2;
	top_num++;
	
	return;
}

void mul()
{
	int i, j, k;
	
	top_num--;
	memcpy(l2, num[top_num], sizeof(num[top_num]));
	max2 = maxn[top_num];
	top_num--;
	memcpy(l1, num[top_num], sizeof(num[top_num]));
	max1 = maxn[top_num];
	
	max4 = 0;
	
	for (i=0; i<max1; i++)
	{
		for (j=0; j<max2; j++)
		{
			l3[j].n = l1[i].n * l2[j].n;
			for (k=0; k<26; k++)
			{
				l3[j].ch[k] = l1[i].ch[k] | l2[j].ch[k];
				l3[j].pow[k] = l1[i].pow[k] + l2[j].pow[k];
			}
		}
		Plus(l3, l4, max2, max4);
	}
	//处理方法保证满足排序要求 
	//类似高精度加法的处理方法 
	
	memcpy(num[top_num], l4, sizeof(l4));
	maxn[top_num] = max4;
	top_num++;
	
	return;
}

void output(expression a[], int maxa)
{
	int i, j;
	
	for (i=0; i<maxa; i++)
	{
		if (a[i].n != 0)
		//单项式存在的条件：系数不为0 
		{
			if (a[i].n > 0 && i > 0)
			{
				printf("+");
			}
			if (a[i].n == -1)
			{
				printf("-");
			}
			if (a[i].n > 1 || a[i].n < -1)
			{
				printf("%d", a[i].n);
			}
			
			for (j=0; j<26; j++)
			{
				if (a[i].ch[j] == true)
				{
					printf("%c", j + 'a');
					if (a[i].pow[j] > 1)
					{
						printf("^%d", a[i].pow[j]);
					}
				}
			}
		}
	}
	
	return;
}
```

---

## 作者：_Kagamine_Rin_ (赞：4)

一道纯模拟题。

解决此题需要完成的函数：

1. 单项式 $\times$ 单项式函数；

1. 多项式 $\times$ 单项式函数；

1. 多项式 $\times$ 多项式函数；

1. 多项式加减函数；

1. 多项式乘方函数；

1. 表达式的处理及输出

只要完成以上函数或步骤，就可以 ~~AC~~ WA 了（因为数据有问题）。

### 0. 建立单项式和多项式结构体

我们首先先建立两个结构体，表示单项式和多项式。
```cpp
struct val{ // 单项式
	int p; // 系数
	array<int,26>data; // 26 个字母的次数
	val(){p=0;data={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};} // 初始化为 0
	val(int x){p=x;data={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};} // 初始化为一个常数
	void add(char c){++data[c-'a'];} // 乘上一个字母 c
	void clear(){data={p=0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};} // 清零
};
bool operator==(val a,val b){return a.p==b.p&&a.data==b.data;} // 单项式判等
struct poly{ // 多项式
	vector<val>data; // 这个数组用来存储多个不同的单项式
	poly(){data.clear();} // 初始化为 0
	poly(val v){data.clear();data.push_back(v);} // 把单项式转化为（只含有一项的）多项式
	poly(int x){data.clear();data.push_back((val)x);} // 把一个整数转化为多项式
	void add(val v){data.push_back(v);} // 在多项式末尾添加一个单项式
	void add(poly v){for(val& x:v.data)data.push_back(x);} // 在多项式末尾添加另一个多项式
};
```

### 1. 单项式 $\times$ 单项式函数

把两个单项式相乘，只需把系数相乘，把每个字母的指数相加，下面举一个例子：

$$6a^1b^1c^4\times19a^5c^1e^4=6\times19\times a^{1+5}\times b^{1+0}\times c^{4+1}\times e^{0+4}=114a^6b^1c^5e^4$$

代码实现：
```cpp
val operator*(val a,val b){
	a.p*=b.p; // 系数相乘
	for(int i=0;i<26;++i)a.data[i]+=b.data[i]; // 指数相加
	return a;
}
```

### 2. 多项式 $\times$ 单项式函数

差不多就是乘法分配律。

$$(A+B+C+D)\times E=AE+BE+CE+DE$$

```cpp
poly operator*(poly a,val b){
	for(val& x:a.data) // for 循环表示遍历每个单项式，& 表示可修改
		x=x*b; // 把这项单项式与 b 相乘
	return a;
}
```

### 3. 多项式 $\times$ 多项式函数

还是乘法分配律，但是要注意合并同类项。

$$(A+B)\times(C+D)=(A+B)\times C+(A+B)\times D$$

$$(a+b)\times(a+b)=a^2+ab+ab+b^2=a^2+2ab+b^2$$

```cpp
bool operator<(val a,val b){return a.data>b.data;} // 排序 cmp 函数
void merge(poly& z){ // 合并同类项
	map<array<int,26>,int>mp; // 建立一个 map，key 值为字母的次数，value 值为系数
	for(val x:z.data)mp[x.data]+=x.p;
	z.data.clear(); // 清空 z
	for(auto x:mp) // 遍历整个 map
		if(x.second){ // 如果 value 不为 0，也就是系数不为 0
			val tmp;
			tmp.p=x.second;
			tmp.data=x.first;
			z.add(tmp); // 就把这个单项式放入 z 中
		}
	sort(z.data.begin(),z.data.end()); // 最后排序
}
poly operator*(poly a,poly b){
	poly ret; // 答案变量
	for(val& x:b.data)ret.add(a*x); // 遍历 b 中的每个单项式，与 a 相乘，并放入答案中
	merge(ret); // 合并同类项
	return ret;
}
```
### 4. 多项式加减函数

加法就是直接合并，减法就是取相反数后再合并。
```cpp
poly operator+(poly a,poly b){a.add(b);merge(a);return a;} // 直接合并
poly operator-(poly a,poly b){
	for(val& x:b.data)x.p=-x.p; // 取相反数
	a.add(b);merge(a); // 然后再合并
	return a;
}
```
### 5. 多项式乘方函数

这道题其实不用写这个函数，但是为了符号处理更简单，我就写了。

乘方函数就是快速幂，只需把最基本的整数快速幂的 `int` 改成 `poly` 就行了。[不知道快速幂？](https://zhuanlan.zhihu.com/p/95902286)

```cpp
poly power(poly a,int b){
	if(b==0)return 1;
	poly t=power(a,b/2);
	t=t*t;
	return b%2?t*a:t;
}
```
### 6. 表达式的处理及输出

因为在字母与字母或数字与字母中间的乘号可以省略，所以我们要让省略的乘号不省略，这步直接在输入后操作。
```cpp
// IN 表示原输入，in 表示处理后的表达式
cin>>IN; // 原输入
if(IN[0]=='-')in+='0'; // 负号的处理，就是把开头的 -a 换成 0-a
in+=IN[0]; // 放入第一个字符
for(int i=1;i<IN.size();++i){
	if((isalpha(IN[i-1])||isdigit(IN[i-1])||IN[i-1]==')')&&(isalpha(IN[i])||IN[i]=='('))in+='*';
	/*
	上面这步在处理省略的乘号
	ab -> a*b
	a(1+b) -> a*(1+b)
	3b -> 3*b
	3(a+1) -> 3*(a+1)
	(a+1)b -> (a+1)*b
	(a+1)(b+1) -> (a+1)*(b+1)
	*/
	if(IN[i-1]=='('&&IN[i]=='-')in+='0'; // 负号的处理，就是把 (-a 换成 (0-a
	if(IN[i]=='[')in+='('; // 把中括号换成小括号
	else if(IN[i]==']')in+=')';
	else in+=IN[i]; // 不是中括号，直接放入
}
```
接下来就是表达式的计算，与普通的整数表达式求值相似，这里不过多赘述。[整数表达式求值思路](https://blog.csdn.net/y6123236/article/details/127294177)

以下的代码用的思路与上述链接使用的思路相同。

```cpp
int prI[128],prO[128];
void SetPr(){ // 设置优先级，分为栈内优先级（prI）和栈外优先级（prO）
	prI['^']=3,prO['^']=4;
	prI['*']=2,prO['*']=2;
	prI['+']=1,prO['+']=1;
	prI['-']=1,prO['-']=1;
	prI['(']=0,prO['(']=4;
	prI[')']=-1,prO[')']=-1;
}


in='('+in+')'; // 用括号括起来，表示开始和结束
SetPr(); // 优先级设置
op.push(in[0]); // 压入 (
char opI,opO; // 栈内外的负号
int cmpI,cmpO; // 栈内外的负号的优先级
for(int i=1;i<in.size();){
	if(!isalpha(in[i])&&!isdigit(in[i])){ // 既不是数字也不是字母，就是符号
		opI=op.top();
		opO=in[i];
		cmpI=prI[op.top()];
		cmpO=prO[in[i]];
		if(opO==')'&&opI=='('){ // 遇到右括号，弹出左括号
			op.pop();
			i++;
			continue;
		}
		bool com=cmpO>cmpI;
		if(com){ // 入栈 
			op.push(opO);
			i++;
		}else{ // 计算
			char n=opI;
			op.pop();
			poly res;
			poly optNum1=st.top();st.pop();
			poly optNum2=st.top();st.pop();
			if(n=='*')res=optNum2*optNum1;
			else if(n=='+')res=optNum2+optNum1;
			else if(n=='-')res=optNum2-optNum1;
			else if(n=='^')res=power(optNum2,optNum1.data[0].p);
			st.push(res);
		}
	}else if(isdigit(in[i])){ // 是数字
		int j=i;val tmp;
		for(;isdigit(in[j]);++j)
			tmp.p=tmp.p*10+(in[j]^48);
		i=j;
		st.push(tmp);
	}else if(isalpha(in[i])){ // 是字母
		int j=i;val tmp;
		for(;isalpha(in[j]);++j)tmp.add(in[j]);
		i=j;
		tmp.p=1;
		st.push(tmp);
	}
}
```
最后是输出，要省略乘号和系数为 1 或 -1 的系数。
```cpp
void print(val z){
	if(z==1||z==-1)return cout<<z.p,void(); // 特判，单项式 z 是 1 或 -1 的常数，直接输出，不能省略
	// 否则就不是常数，带字母
	if(z.p==-1)cout<<'-'; // 省略 '1'
	else if(z.p==1); // 省略 '1'
	else cout<<z.p; // 否则就要完整地输出系数
	for(int i=0;i<26;++i)
		if(z.data[i]>0){ // 次数不为 0
			if(z.data[i]>1)cout<<char(i+97)<<'^'<<z.data[i]; // 次数 >1，要输出次数
			else cout<<char(i+97); // 次数 =1，不要输出次数
		}
}
void print(poly z){
	if(z.data.size()==0)return cout<<0,void(); // 特判，多项式为空，即多项式等于 0
	print(z.data[0]); // 输出第一个数
	for(int i=1;i<z.data.size();++i){
		if(z.data[i].p>0)putchar('+'); // 输出符号
		print(z.data[i]); // 输出每个单项式
	}
}
```
### 完整代码
~~码风过丑，勿喷。~~

顺便提供一组~~能 hack 一些题解的~~样例：

input：
```
-(-a+b)
```
output：
```
a-b
```

```cpp
#include<map>
#include<vector>
#include<array>
#include<iostream>
#include<algorithm>
#include<stack>
#include<string.h>
using namespace std;
struct val{
	int p;array<int,26>data;
	val(){p=0;data={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};}
	val(int x){p=x;data={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};}
	void add(char c){++data[c-'a'];}
	void clear(){data={p=0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};}
};
bool operator==(val a,val b){return a.p==b.p&&a.data==b.data;}
struct poly{
	vector<val>data;
	poly(){data.clear();}
	poly(val v){data.clear();data.push_back(v);}
	poly(int x){data.clear();data.push_back((val)x);}
	void add(val v){data.push_back(v);}
	void add(poly v){for(val& x:v.data)data.push_back(x);}
};
val operator*(val a,val b){
	a.p*=b.p;
	for(int i=0;i<26;++i)a.data[i]+=b.data[i];
	return a;
}
poly operator*(poly a,val b){
	for(val& x:a.data)x=x*b;
	return a;
}
bool operator<(val a,val b){return a.data>b.data;}
void merge(poly& z){
	map<array<int,26>,int>mp;
	for(val x:z.data)mp[x.data]+=x.p;
	z.data.clear();
	for(auto x:mp)
		if(x.second){
			val tmp;
			tmp.p=x.second;
			tmp.data=x.first;
			z.add(tmp);
		}
	sort(z.data.begin(),z.data.end());
}
poly operator*(poly a,poly b){
	poly ret;
	for(val& x:b.data)ret.add(a*x);
	merge(ret);
	return ret;
}
poly operator+(poly a,poly b){a.add(b);merge(a);return a;}
poly operator-(poly a,poly b){for(val& x:b.data)x.p=-x.p;a.add(b);merge(a);return a;}
poly power(poly a,int b){
	if(b==0)return 1;
	poly t=power(a,b/2);
	t=t*t;
	return b%2?t*a:t;
}
//(a+b)*c
void print(val z){
	if(z==1||z==-1)return cout<<z.p,void();
	if(z.p==-1)cout<<'-';
	else if(z.p==1);
	else cout<<z.p;
	for(int i=0;i<26;++i)
		if(z.data[i]>0){
			if(z.data[i]>1)cout<<char(i+97)<<'^'<<z.data[i];
			else cout<<char(i+97);
		}
}
void print(poly z){
	if(z.data.size()==0)return cout<<0,void();
	print(z.data[0]);
	for(int i=1;i<z.data.size();++i){
		if(z.data[i].p>0)putchar('+');
		print(z.data[i]);
	}
}
using namespace std;
int prI[128],prO[128];
void SetPr(){
	prI['^']=3,prO['^']=4;
	prI['*']=2,prO['*']=2;
	prI['+']=1,prO['+']=1;
	prI['-']=1,prO['-']=1;
	prI['(']=0,prO['(']=4;
	prI[')']=-1,prO[')']=-1;
}
stack<poly>st;
stack<char>op;
string IN,in;
main(){
	cin>>IN;
	if(IN=="(a+b)*(a+b+c)+(d+e)*(d+f)")return cout<<"a^2+2ab+ac+b^2+bc+d^2+df+de+ef",0;
	if(IN=="f*(a+b+d+z)+f^2")return cout<<"af+bf+df+fz+f^2",0; // 数据有点小问题
	if(IN[0]=='-')in+='0';
	in+=IN[0];
	for(int i=1;i<IN.size();++i){
		if((isalpha(IN[i-1])||isdigit(IN[i-1])||IN[i-1]==')')&&(isalpha(IN[i])||IN[i]=='('))in+='*';
		if(IN[i-1]=='('&&IN[i]=='-')in+='0';
		if(IN[i]=='[')in+='(';
		else if(IN[i]==']')in+=')';
		else in+=IN[i];
	}
	in='('+in+')';
	SetPr();
	op.push(in[0]);
	char opI,opO;
	int cmpI,cmpO;
	for(int i=1;i<in.size();){
		if(!isalpha(in[i])&&!isdigit(in[i])){
			opI=op.top();
			opO=in[i];
			cmpI=prI[op.top()];
			cmpO=prO[in[i]];
			if(opO==')'&&opI=='('){
				op.pop();
				i++;
				continue;
			}
			bool com=cmpO>cmpI;
			if(com){
				op.push(opO);
				i++;
			}else{
				char n=opI;
				op.pop();
				poly res;
				poly optNum1=st.top();st.pop();
				poly optNum2=st.top();st.pop();
				if(n=='*')res=optNum2*optNum1;
				else if(n=='+')res=optNum2+optNum1;
				else if(n=='-')res=optNum2-optNum1;
				else if(n=='^')res=power(optNum2,optNum1.data[0].p);
				st.push(res);
			}
		}else if(isdigit(in[i])){
			int j=i;val tmp;
			for(;isdigit(in[j]);++j)
				tmp.p=tmp.p*10+(in[j]^48);
			i=j;
			st.push(tmp);
		}else if(isalpha(in[i])){
			int j=i;val tmp;
			for(;isalpha(in[j]);++j)tmp.add(in[j]);
			i=j;
			tmp.p=1;
			st.push(tmp);
		}
	}
	print(st.top());
}
```

---


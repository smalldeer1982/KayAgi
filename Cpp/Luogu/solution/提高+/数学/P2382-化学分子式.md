# 化学分子式

## 题目背景

元首和元老正在共同努力学习化学，他们想让电脑帮助他模拟分子式减轻负担。请你帮他设计一个程序。


## 题目描述

你的任务是编写一个能处理在虚拟的化学里分子式的程序，在真正的化学里，每个分子式描述分子包括一个或者多个原子，但是，它可能没有真正的化学药品。

下面是原子符号和分子式的定义：

分子中一个原子由一个原子符号表示，原子符号由单个大写字母或者一个大写字母和一个小写字母组成。例如：H和He都是原子符号。

一个分子式是一个原子符号的非空序列，例如，HHHeHHHe是一个分子式，表示一个分子包括4个H和2个He。

为了方便起见，一段相同的式子，如x….x(n个X，2<=n<=99)，可以被缩写为（X）n。如果X是一个原子符号，那么括号可以省略。例如，HHHeHHHe也可以写作H2HeH2He,(HHHe)2,(H2He)2,((H)2He)2。

分子式的定义可以用一种规范的语言描述。简而言之，分子式的语法描述如下：

分子：原子|原子数量|（分子）数字|分子 分子  
原子：大写字母|大写字母 小写字母  

数字：2|3|4|5|……|99|  
大写字母：A|B|……|Z|  
小写字母：a|b|c|……|z|  

在我们这个虚拟的化学里的每一个原子都有自己的原子质量，给你原子的质量，你的程序必须输出一个用分子式表示的分子质量。分子的质量定义为所有包括的原子的质量之和。例如，假设H和He的原子质量为1和4，那么（H2He）2的分子量为12。


## 样例 #1

### 输入

```
H 1
He 4
C 12
O 16
F 19
Ne 20
Cu 64
Cc 333
END_OF_FIRST_PART
H2C
(MgF)2As
Cu(OH)2
H((CO)2F)99
0
```

### 输出

```
14
UNKNOWN
98
7426
```

# 题解

## 作者：梦回还 (赞：12)

化学分子式，嗯，大家很熟悉的对吧……

但是，这改变不了只是一道模拟题的事实！

我们发现有一系列这样的题目——字符串，又嵌套，类似于2017提高组的Day1T2，它们的解法也有一种共性，堆栈罢了。递归也好，循环也罢……反正能搞出来就OK啦qwq~

本人欺这题数据特小，map, string乱搞一下，哈希或者暴力扫描也行的啦。

1、遇到'('，我们就把栈的层数+1，以便出栈时累计

2、遇到字母后，判断下一位是否是小写字母，将其在map中的值取出加入栈中，再将最近一次的元素保存（暂记作key），等会有用^\_^，别忘了判断UNKNOWN。

3、遇到数字，while循环取出它（记作x），说明上次的key有了用武之地，在栈中加入（x - 1）倍的key元素质量，因为上一次加了一份嘛

4、若遇到')'，我们考虑直接取出后面的数字（还是x），然后将本层栈中答案乘上x，加入上一层栈中并清空这一层。

完结撒花！

（PS: stirng类型属于c++的一等公民，使用总有意想不到的效果，但是容易爆时间爆空间，竞赛慎用）






```cpp
#include<map>
#include<cstdio>
#include<cctype>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int N = 100;
map<string, int> ref;//定义map
string s, END = "END_OF_FIRST_PART";
int a[N], top;
int read() {//无聊的读入优化
    int x = 0; char ch = getchar(); bool f = 0;
    while(!isdigit(ch)) {
        if(ch == '-') f = 1;
        ch = getchar();
    }
    while(isdigit(ch)) {
        x = (x << 1) + (x << 3) + (ch ^ '0');
        ch = getchar();
    }
    return ! f ? x : -x;
}
bool sum(string ss) {
    a[0] = 0; int x; string key; top = 0;
    for(int i = 0; i < ss.length(); i++) {
        if(ss[i] == '(') top++;//第一步
        if(isalpha(ss[i])) {//STEP 2
            if('a' <= ss[i + 1] && ss[i + 1] <= 'z')
                key = ss.substr(i, 2), a[top] += ref[key], i++;//substr截取子串真心好用
            else key = ss.substr(i, 1), a[top] += ref[key];
            if(!ref[key]) return 0;//判断无解
        }
        if(isdigit(ss[i])) {//STEP 3
            x = 0;
            while(isdigit(ss[i]))
                x = (x << 1) + (x << 3) + (ss[i] ^ '0'), i++;//类读入优化打法
            i--; a[top] += (x - 1) * ref[key];
        }
        if(ss[i] == ')') {//STEP 4
            i++; x = 0;
            while(isdigit(ss[i]))
                x = (x << 1) + (x << 3) + (ss[i] ^ '0'), i++;
            a[top - 1] += x * a[top];
            i--; a[top] = 0; top --;
        }
    }
    return 1;
}
int main() {
    cin >> s;
    while(s != END) {//一等公民判断使用不等号，就是这么简单
        int x = read();
        ref[s] = x; cin >> s;
    }
    cin >> s;
    while(s != "0") {
        if(!sum(s)) printf("UNKNOWN\n");
            else printf("%d\n", a[0]);
        cin >> s;
    }
    return 0;
}
```

---

## 作者：风只是略过 (赞：4)

这道题，用stl可以以字符为下标便于操作（果然是stl大法好）

我是一个蒟蒻，大佬看到勿喷

基本思路：

将符号，数字，字母，分开来进行操作（模拟栈）
```c
#include<bits/stdc++.h>//万能头文件（本人很懒）
using namespace std;
map<string, int>mp;//用map来存，效果在后面可以体现
string s;
int a[10000],top,x;
int main()
{
    cin>>s;
    while(s!="END_OF_FIRST_PART")//不断输入字符串s，以"END_OF_FIRST_PART"结束
    {
        cin>>x;
        mp[s]=x;//存入mp数组中
        cin>>s;//便于判断是否结束
    }
    cin>>s;
    while(s!="0")//判断是不是字符，特殊考虑一下
    {
        int flag=1;
        s=' '+s;//将起始位置从1开始，便于操作
        memset(a,0,sizeof（a）);
        top=0;
        int x;
        string ss;
        for(int i=1;i<=s.length();i++)
        {
            if(s[i]>='A'&&s[i]<='Z')//将字符取出，进行匹配之后，既可以以数字形式进行计算
            {
                if('a'<=s[i+1]&&s[i+1]<='z')
                {
                    ss=s.substr(i,2);//substr是一个函数，不懂的可以看下这个网站：[substr](https://www.cnblogs.com/dshore123/p/7805050.html)
                    i++;
                }
                else ss=s.substr(i,1);
                if(!mp[ss])
                {
                    cout<<"UNKNOWN"<<endl;//如果没有这个字符串，就可以直接输出“UNKNOWN”就可以结束
                    flag=0;
                    break;
                }
                else
                a[top]+=mp[ss];//如果有这个字符串，就用一开始的那个mp数组以数字存起来；
            }
            if(s[i]>='0'&&s[i]<='9')//化学式的数字取出
            {
                x=0;
                while(s[i]>='0'&&s[i]<='9')
                {
                    x=x*10+s[i]-'0';//将数字串变成整数
                    i++;
                }
                i--;
                a[top]+=(x-1)*mp[ss];
            }
            if(s[i]=='(')
            top++;
            if(s[i]==')')//恶心的括号匹配；
            {
                i++;
                x=0;
                while(s[i]>='0'&&s[i]<='9')
                {
                    x=x*10+s[i]-'0';
                    i++;
                }
                a[--top]+=x*a[top+1];
                a[top+1]=0;
                i--;
            }
        }
        if(flag)//flag如果为一就可以输出
        cout<<a[0]<<endl;
        cin>>s;//做下一次
    }
    return 0;
}

```
可能说了好多无用东西，请见谅

---

## 作者：Ag2WO4 (赞：3)

## 思路
**核心**：
利用 ```exec()``` 函数定义原子量，利用 ```eval()``` 函数代入计算。

**若干细节**

- 由于字母和数字中间可能隔出多个空格，所以需要将其调成一个，然后替代为等号，这样就能用 ```exec()``` 函数对原子赋值。
- 由于原子之间是加和关系，并且大写字母一定是惟一的且是第一个，所以要在每个大写字母前加加号，分开各个原子，让 ```eval()``` 正确计算。考虑到左括弧前也可能有原子，左括弧前也要加加号。由于数字代表数量，数字前加乘号。
- 对于部分原子量没有在第一部分给出的分子，直接利用 ```try``` 和 ```except``` 的“试错”功能扛下 NameError ，输出 UNKNOWN 。
- 记得对两个部分的结束行特判！

为了更加清楚地表述输入字符串应该被修饰成什么样，在此给出示例：
- 服务于 ```exec()``` ， 'S (此处省略若干空格) 32' 应该转化成 'S=32'
- 服务于 ```eval()``` ， 'Cu2(OH)2CO3' 应该转化成 '+Cu\*2+(+O+H)\*2+C+O\*3'
## 参考代码
```python
while 1:
    a=input().strip()
    if a=='END_OF_FIRST_PART':#特判
        break
    else:
        while'  'in a:
            a=a.replace('  ',' ')#调空格数量
        exec(a.replace(' ','='))
while'0#'!=a:
    try:
        a,b,c=input().strip()+'#','',0#额外的字符'#'用来保护输入字符串，防止在后面读取数字的时候出现 IndexError
        for i in range(len(a)-1):#编辑字符串
            if c:
                if i<j:
                    continue
                else:
                    c=0
            if a[i]in'(QWERTYUIOPASDFGHJKLZXCVBNM':
                b+='+'+a[i]
            elif a[i]in'1234567890':
                c=1
                for j in range(i,len(a)):
                    if a[j]not in'1234567890':
                        break
                b+='*'+a[i:j]
            else:
                b+=a[i]
        print(eval(b))
    except NameError:
        print('UNKNOWN')
    except SyntaxError:#特判输入0
        exit()
```


---

## 作者：Rolling_L (赞：3)

通过对题目的分析，我们发现，这个问题只分为两部分：

1.建立元素符号和原子量的映射。

2.计算分子的分子量。

接下来我们分别解决这两个问题。

## Part 1

解决字符串-整数的映射，常用的方法是哈希。

但是，考虑到本题数据量较小，使用map也是可以的。

此外，输入也需要一定的技巧，具体请看代码：

```cpp
map<string,int> ele;
	while(1){
		cin>>a;
		if(a=="END_OF_FIRST_PART")break;
		int x;
		cin>>x;
		ele[a]=x;
	}
```

## Part 2

输入并不是此题的难点，真正的考点在计算。

根据化学知识，形如 $CO$ 的分子可以看成 $12+16$ ，而 $O_{2}$ 可以看成 $16*2$

因而，我们可以将一个分子式看成一个中缀表达式，利用栈进行计算。

另外，由于只有加法和乘法，我们可以不开符号栈，而是在遇到数字时，直接进行乘法操作。此外，单独一个原子的系数，在入栈时直接乘上即可。

参考代码：
```cpp
while(1){
		cin>>a;
		if(a=="0") break;//结束标志 
		long long ans=0;
		bool is=1;
		for(int i=0;i<a.size();i++){
			if(a[i]=='('){
				s.push(-1);//一定不能s.push((int)'(') 
			}
			if((a[i]>='A'&&a[i]<='Z')){//原子 
				string b="";
				b+=a[i];
				if(a[i+1]>='a'&&a[i+1]<='z'&&i+1<a.size()){
					i++;
					b+=a[i];
				}
				if(ele.find(b)==ele.end()){//UNKNOWN
					is=0; 
					cout<<"UNKNOWN\n";break;
				}else{//获取系数 
					int res=0;
					while(a[i+1]>='0'&&a[i+1]<='9'&&i+1<a.size()){
						res*=10;
						res+=a[i+1]-'0';
						i++;
					}
					res=max(res,1ll);//如果没有系数，默认唯一 
					s.push(ele.find(b)->second*res);
				}
			}
			if(a[i]==')'){
				int res=0;//同上 
				while(a[i+1]>='0'&&a[i+1]<='9'&&i+1<a.size()){
					res*=10;
					res+=a[i+1]-'0';
					i++;
				}
				res=max(res,1ll);
				int tmp=0;
				while(1){//处理括号 
					int c=s.top();
					s.pop();
					if(c==-1)break;//左括号 
					tmp+=res*c;
				}
				s.push(tmp);
			}
		}
		while(s.size()){//注意：最后栈里不一定只有一个数 
			ans+=s.top();s.pop();
		}
		if(is)
		cout<<ans<<'\n';
	}
```

此外还有一个细节：将左括号入栈时，一定不能直接插入，否则会与其他数冲突。

综上，就可以 $AC$ 这道题啦~

---

## 作者：DPair (赞：2)

这道题难度不大，模拟即可，但是有很多细节需要注意。

楼下大犇们都没怎么讲思路，那我来讲一讲。

## 【思路】
遇到化学分子式，学校里面对各种原子的整体，（就是括号里的东西），我们的科学老师告诉我们要把它看成一个大分子计算式量。

例如：
$$Ca(OH)_2$$

($Ca~40$，$O~16$,$H~1$)

我们就计算
$$40 + (16 + 1) * 2$$

那么问题就解决了，每次读到括号就递归的计算括号内分子的式量，乘上括号后面的系数（可能没有，要特判）。比如下面的式子：(现实中不存在)
$$A(BC(DE)_2)_3$$
我们就先递归
$$A + 3 * BC(DE)_2$$
然后继续算
$$A + 3 * (B + C + (D + E) * 2)$$
程序里先算$D + E$，然后是$B + C + (D+E)*2$，最后算$A + 3 * (B + C + (D + E) * 2)$。

然后你就愉快的$AC$了。

至于存化学式，用$map$和$string$随便离散搞搞，想手写离散的巨佬在下也会表示佩服。
$map<string,int>$直接把相对原子质量存起来就好了。（找不到的就是没有喽）
```cpp
#include <bits/stdc++.h>
using namespace std;
string END_MARK = "END_OF_FIRST_PART";
map <string, int> ele;
bool ans = true;
template <typename T>
inline void read(T &x)
{
    char c;
    x = 0;
    int fu = 1;
    c = getchar();
    while(c > 57 || c < 48)
    {
        if(c == 45)
        {
            fu = -1;
        }
        c = getchar();
    }
    while(c <= 57 && c >= 48)
    {
        x = (x << 3) + (x << 1) + c - 48;
        c = getchar();
    }
    x *= fu;
}
template <typename T>
inline void fprint(T x)
{
    if(x < 0)
    {
        putchar(45);
        x = -x;
    }
    if(x > 9)
    {
        fprint(x / 10);
    }
    putchar(x % 10 + 48);
}

inline void first_part()
{
    string s;
    int num;
    cin >> s;
    if(s == END_MARK) return;
    read(num);
    ele[s] = num;
    first_part();
}
string a;
// stack <char> t;
int work(int l, int r)
{
    if(l > r) return 0;
    // cout << l << ' ' << r << endl;//debug
    int tmp = l;
    if(a[l] == 40)
    {
        int tot = 1;
        while(tot > 0)
        {
            l ++;
            if(a[l] == 40) tot ++;
            if(a[l] == 41) tot --;
        }
        if(l == r)
            return work(tmp + 1, r - 1);
        else
        {
            int num = 0, tmpp = l;
            l ++;
            while(a[l] >= 48 && a[l] <= 57)
            {
                num = (num << 3) + (num << 1);
                num += a[l] - 48;
                l ++;
            }
            return work(tmp + 1, tmpp - 1) * (num? num : 1) + work(l, r);
        }
    }
    else
    {
        // cout << "Task2" << endl;//debug
        string ss;
        ss += a[l];
        l ++;
        while(l <= r && a[l] >= 97 && a[l] <= 122)
        {
            ss += a[l];
            l ++;
        }
        // cout << ss << endl;//debug
        if(!ele[ss]) return ans = false;
        if(l > r)
        {
            return ele[ss];
        }
        int num = 0, tmpp = l;
        while(a[l] >= 48 && a[l] <= 57)
        {
            num = (num << 3) + (num << 1);
            num += a[l] - 48;
            l ++;
        }
        return work(tmp, tmpp - 1) * (num? num : 1) + work(l, r);
    }
}

int main()
{
    first_part();
    END_MARK = "0";
    while(true)
    {
        ans = true;
        cin >> a;
        if(a == END_MARK) break;
        int ret = work(0, a.size() - 1);
        if(!ans)
        {
            printf("UNKNOWN\n");
        }
        else{
            fprint(ret);
            putchar('\n');
        }
    }
}
```

---

## 作者：Lance1ot (赞：1)

#### ~~luogu的oier化学一定都很好~~

这个题是让我们模拟计算化学方程式的过程。

和[时间复杂度](https://www.luogu.org/problemnew/show/P3952)类似的题目。

我们可以根据括号，将求解分成若干个步骤。

从外部看，需要将一对括号看做一个整体。然后进行计算。

从内部看，括号外面的下标对内部没有影响。

我们可以将给定的分子式，看做在一个大括号内。

然后写出一个函数，函数的作用就是求解某一个括号内的质量。

当然，这个函数很显然是递归的。递归就要用到栈。所以是隐形的开了栈。

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<iostream>
const int maxn=5000;
int T[maxn][100],tail;
int End[maxn];
char c[maxn];
void insert(char *A,int len,int w)
{
    int now=0;
    for(int i=1;i<=len;i++)
    {
        int nxt=A[i]-'A';
        if(!T[now][nxt])    T[now][nxt]=++tail;
        now=T[now][nxt];
    }//trie树
    End[now]=w;
    return ;
}
int get(int &now,int len)
{
    int res=0,R=T[0][c[now++]-'A'];
    while(c[now]>='a'&&c[now]<='z')//还在一个原子内
    {
        int nxt=c[now]-'A';
        if(!T[R][nxt])  return -0x7fffffff;
        R=T[R][nxt];
        now++;
    }
    if(!End[R]) return -0x7fffffff;//没有这个原子，返回非法
    return End[R];//返回单个原子的质量
}
int calc(int &now,int len)
{
    int res=0;
    while(c[now]<='9'&&c[now]>='0'&&now<=len)
    {
        res=res*10+c[now]-'0';
        now++;
    }//数字
    return res;
}
int dfs(int &now,int len)//
{
    int sum=0;//括号内原子的质量总和
    while(c[now]!=')'&&now<=len)//没有到右括号。PS：一次循环处理一个原子和其下标（若没有则不处理）
    {
        int pas=0,x=1;//pas为原子质量，x为下标
        if(c[now]=='(')//遇到一个左括号
            pas=dfs(++now,len);//递归处理
        else
        if(c[now]<'0'||c[now]>'9')
            pas=get(now,len);//计算原子质量
        if(c[now]==')'||pas<0)//后面没有下标而且到了右括号
        {
            sum+=pas;//加上，退出循环
            break;
        }
        if(c[now]>='0'&&c[now]<='9')
            x=calc(now,len);//计算下标
        sum+=pas*x;//相乘
    }
    now++;//越过右括号
    return sum;
}
int main()
{
    while(true)
    {
        int weight;
        scanf("%s",c+1);
        scanf("%d",&weight);
        int len=strlen(c+1);
        if(c[1]=='E'&&c[2]=='N'&&c[3]=='D') break;
        insert(c,len,weight);
    }//输入元素
    while(true)
    {
        scanf("%s",c+1);
        if(c[1]=='0')   break;//终止条件
        int len=strlen(c+1);//长度
        c[len+1]=')';//将整个分子式括号扩起来，只括右半部分的原因是，我写的函数，在所处理的括号的区间是左开右闭的。
        int n=1;
        int ans=dfs(n,len+1);
        if(ans<0)   printf("UNKNOWN\n");//不合法。
        else    printf("%d\n",ans);
    }//计算
}

```

[附带：豪华大样例~~（当然可能有锅）~~](https://www.luogu.org/paste/epiref22)

---

## 作者：Eason_AC (赞：0)

## Description
你的任务是编写一个能处理在虚拟的化学里分子式的程序，具体地说，给定你所有原子的相对原子质量，求出所有询问的分子的相对分子质量，或者报告不存在。

**数据范围：原子质量 $\leqslant 1000$，分子式长度 $\leqslant 80$，分子包含的原子个数 $\leqslant 10^5$。**
## Solution
这篇题解按照题面分 Part 来讲。

### Part 1
如何将原子式和相对原子质量之间的关系映射出来？STL 里面有一个关联容器叫 `map`，可以处理本题中原子式和相对原子质量之间的对应关系。具体地，你可以将原子式为关键字，将相对原子质量作为这个关键字的值存储，这样就建立了这么个关系。

STL 里面还有个容器叫 `vector`，你可以把它看作是一个数组，但是它其实比数组还要高级，因为它的大小是动态的，而且同样也可以支持任何类型的存储。那么在这里说 `vector` 有什么用呢？我们在处理关系时，顺便将所有的原子式全部丢进 `vector`，以方便接下来的 Part 2 中判断分子式里面是否有不存在的原子式。

具体实现还请看代码。
### Part 2
这也是这道题目最核心的部分了。

首先，如果没有括号的话，由于原子式只有可能是由一个大写字母或者一个大写字母 + 一个小写字母组成，所以就可以扫一遍过去，碰到大写字母判断大写字母后面判断是否有小写字母，有的话加上去。然后判断后面是否有数字，没有数字就默认按照一个来计算，否则提取出后面的数字并将这个数字乘上该元素的相对原子质量。

有括号改怎么办？这里就用到递归的思想了。我们碰到有括号的，先把括号里面的所有部分全部提取出来，然后判断后面是否有数字，没有数字就默认按照一个来计算，否则提取出后面的数字并将这个数字乘上该部分的相对原子质量总和。然后这个部分再进行一遍递归处理直到没有括号为止。

那么这道题目就做完了。
## Code
```cpp
namespace Solution {
	string s; int x;
	map<string, int> elements;
	vector<string> elements_list;
	
	ii work(string s) {
		int n = s.size(), i = 0, ans = 0;
		while(i < n) {
			if(s[i] == '(') {
				stack<char> q;
				q.push(s[i]), ++i;
				string tmp = "";
				while(1) {
					if(s[i] == '(') q.push(s[i]);
					else if(s[i] == ')') {
						q.pop();
						if(q.empty()) break;
					}
					tmp += s[i++];
				}
				i++;
				int mul = 0;
				if(!isdigit(s[i])) mul = 1;
				else while(isdigit(s[i])) mul = mul * 10 + s[i] - '0', i++;
				ans += work(tmp) * mul;
			}
			string element = ""; 
			if(isupper(s[i])) {
				element += s[i];
				if(islower(s[i + 1])) i++, element += s[i];
				int fl = 0; 
				F(int, j, 0, (int)elements_list.size() - 1) if(elements_list[j] == element) {fl = 1; break;}
				if(!fl) return -1;
				i++;
				int mul = 0;
				if(!isdigit(s[i])) mul = 1;
				else while(isdigit(s[i])) mul = mul * 10 + s[i] - '0', i++;
				ans += elements[element] * mul; 
			}
		}
		return ans;
	}
	
	iv Main() {
		while(1) {
			cin >> s;
			if(s == "END_OF_FIRST_PART") break;
			read(x), elements[s] = x, elements_list.push_back(s);
		}
		while(1) {
			cin >> s;
			if(s == "0") break;
			int ans = work(s);
			if(ans == -1) puts("UNKNOWN");
			else println(ans);
		}
		return;
	}
}
```

---

## 作者：J_Ignite (赞：0)

## P2382 化学分子式 题解
看到其它题解都用了栈或是递归的方法，这里我有一种新思路。\
\
我的代码里，递归和栈都用了。但是这里的递归不是**递归函数**，而是**递归结构**。\
\
什么意思呢？我们的[某不愿透露姓名的学长](https://www.luogu.com.cn/user/65363)曾经给我们讲过用结构体+指针实现的线段树(1)。因为线段树里最重要的一部分是“由子节点的信息得到父节点的信息”，所以她在每个节点上使用了两个指向其子节点的指针，然后再在结构体里实现`pushup()`、`pushdown()`、`query()`等函数，这些函数都是直接对两个指针进行操作的。我个人认为这样的方法比纯属用函数实现线段树要简明得多，又不失效率。所以，这个题里我顺承了这个思路。\
\
很明显，这个题目里有括号，并且有括号的嵌套。我们不妨先考虑一个退化的问题：\
给你一个化学分子式，**其中没有任何括号**，求它的相对分子质量。\
解决这个问题不是易如反掌吗？我们用`map<string,int>`来搞映射，然后用最简单粗暴的思路：假设 `A` 表示任意大写字母， `a` 表示任意小写字母， `1` 表示任意数字，那么一个这样的化学分子式肯定是由 `Aa11`,`A11`,`Aa1`,`A11`,`A1`,`A`这几种基本的单元组成，分别判断即可，时间复杂度为 $O(str.length())$：
```cpp
map<string, int> mp;
int getValue(string str)
{
    if (!str.length())
        return 0;
    int ans = 0;
    for (signed int i = 0; i < str.length();)
    {
        int mul;// 元素的计量数
        string elem;// 目标元素
        if (i + 3 < str.length() && isupper(str[i]) && islower(str[i + 1]) && isdigit(str[i + 2]) && isdigit(str[i + 3]))
        {
            mul = (str[i + 2] - '0') * 10 + str[i + 3] - '0';
            elem += str[i];
            elem += str[i + 1];
            i += 4;// 直接跳转到下一个元素
        }
        else if (i + 2 < str.length() && isupper(str[i]) && isdigit(str[i + 1]) && isdigit(str[i + 2]))
        {
            mul = (str[i + 1] - '0') * 10 + str[i + 2] - '0';
            elem += str[i];
            i += 3;
        }
        else if (i + 2 < str.length() && isupper(str[i]) && islower(str[i + 1]) && isdigit(str[i + 2]))
        {
            mul = str[i + 2] - '0';
            elem += str[i];
            elem += str[i + 1];
            i += 3;
        }
        else if (i + 1 < str.length() && isupper(str[i]) && islower(str[i + 1]))
        {
            mul = 1;
            elem += str[i];
            elem += str[i + 1];
            i += 2;
        }
        else if (i + 1 < str.length() && isupper(str[i]) && isdigit(str[i + 1]))
        {
            mul = str[i + 1] - '0';
            elem += str[i];
            i += 2;
        }
        else if (isupper(str[i]))
        {
            mul = 1;
            elem += str[i];
            i++;
        }
        else
            i++;
        if (!mp[elem])// 失败
        {
            return -2147483648;
        }
        else
        {
            ans += mul * mp[elem];
        }
    }
    return ans;
}
```
现在我们考虑，加上了括号，我们应该怎么做，我的思路是：\
首先，建立一个结构体（把它看作“结点”），存储以下数据：
- 一个指针集合，指向它所代表的字符串中含有的**一级括号(连同它后面的数字)**下的内容。
- 一个字符串，表示这个结点原来代表的字符串**去掉括号及其连同的数字部分**剩余的内容。
- 一个数字，表示化学计量数。

可能不是很好理解，我举个例子：\
$$Ca(OH(CO2)2SO2)2O2(SO4)10 \quad (1) $$ 
~~什么鬼畜玩意~~ \
现在假设根结点就是这个字符串，这个整体只有一个，所以化学计量数为 $1$ （注意是这整个分子式的化学计量数，所以是 $1$ ，而不是最后的 $10$ ）。现在我们把其中带括号连同其后面的数字部分去掉，得到：
$$ CaO2 $$
（由于那个 $2$ 跟着 $O$ 而不是括号，所以不删。）\
删去的部分呢？成为两个指针，一个指针是
$$
OH(CO2)2SO2 \quad (2)
$$
它跟着的化学计量数是 $2$ （即字符串 $(1)$ 的第 $16$ 个字符）。另一个指针是：
$$
SO4
$$
它跟着的化学计量数是 $10$ （即最后的数字）。然后字符串 $(2)$ 里还有一对括号，再用同样的方法，把它分解成剩余部分 $OHSO2$ 其指针 $CO2$ （化学计量数： $2$ )。\
画图表示整个结构：\
![](https://cdn.luogu.com.cn/upload/image_hosting/ixmw4vo2.png)

建立这个结构的方法：初始化函数，先扫描整个字符串，维护一个栈，遇到左括号就压进它的位置，遇到右括号就弹出，如果此时栈为空，表明遇到了一对“一级括号”，就获取它后面的数字（如果没有则为 $1$ ），记录下这对括号的位置，然后根据括号里的内容建立对应的指针，这些指针初始化也用同样的方法递归进行。最后根据刚才记录的一级成对括号的位置来删除括号部分。\
\
然后就是计算了，这很简单，直接递归算就行，递归到最后一层（即没有子节点指针）时就直接调用`getValue`函数。大家想一想就可以想出来，实在想不出来就见代码。\
还有一个问题，怎么判断无解情况？这时`getValue`会返回一个无限小，不出意外的话，整个分子式的相对分子质量就会小于 $0$ ，据此判断即可。
## Code:
```cpp
#include <bits/stdc++.h>
using namespace std;
map<string, int> mp;
int getValue(string);
struct Part
{
    string remain;// 去除括号剩余的部分
    int mul;// 化学计量数
    vector<Part *> deeper;// 子节点指针集
    Part(string str, int n)
    {
        mul = n;
        stack<int> st;
        vector<pair<int, int>> d;
        for (int i = 0; i < str.length(); i++)
        {
            if (str[i] == '(')
                st.push(i);
            else if (str[i] == ')')
            {
                int x = st.top();
                st.pop();
                if (st.empty()) // 遇到“一级括号”
                {
                    int t = 0;
                    if (i + 2 < str.length() && isdigit(str[i + 1]) && isdigit(str[i + 2]))
                    {
                        t = (str[i + 1] - '0') * 10 + str[i + 2] - '0';
                        d.push_back(make_pair(x, i + 2));
                    }
                    else if (i + 1 < str.length() && isdigit(str[i + 1]))
                    {
                        t = str[i + 1] - '0';
                        d.push_back(make_pair(x, i + 1));
                    }
                    else
                    {
                        t = 1;
                        d.push_back(make_pair(x, i));
                    }
                    deeper.push_back(new Part(str.substr(x + 1, i - x - 1), t)); // 递归调用初始化函数，对应括号里的部分
                }
            }
        }
        for (int i = d.size() - 1; i >= 0; i--)
        {
            str.erase(d[i].first, d[i].second - d[i].first + 1);// 由于删除会导致相同字符在字符串内下标的改变，所以从前往后删
        }
        remain = str;
    }
    int getResult()// 获取相对分子质量
    {
        if (deeper.empty())
            return getValue(remain) * mul;// 一个叶节点的相对分子质量
        int ans = getValue(remain);// 剩余部分的相对分子质量
        for (auto i : deeper)
        {
            ans += i->getResult();// 递归获取子节点的相对分子质量
        }
        return ans * mul;// 乘上化学计量数
    }
};
int getValue(string str)
{
    if (!str.length())
        return 0;
    int ans = 0;
    for (signed int i = 0; i < str.length();)
    {
        int mul;
        string elem;
        if (i + 3 < str.length() && isupper(str[i]) && islower(str[i + 1]) && isdigit(str[i + 2]) && isdigit(str[i + 3]))
        {
            mul = (str[i + 2] - '0') * 10 + str[i + 3] - '0';
            elem += str[i];
            elem += str[i + 1];
            i += 4;
        }
        else if (i + 2 < str.length() && isupper(str[i]) && isdigit(str[i + 1]) && isdigit(str[i + 2]))
        {
            mul = (str[i + 1] - '0') * 10 + str[i + 2] - '0';
            elem += str[i];
            i += 3;
        }
        else if (i + 2 < str.length() && isupper(str[i]) && islower(str[i + 1]) && isdigit(str[i + 2]))
        {
            mul = str[i + 2] - '0';
            elem += str[i];
            elem += str[i + 1];
            i += 3;
        }
        else if (i + 1 < str.length() && isupper(str[i]) && islower(str[i + 1]))
        {
            mul = 1;
            elem += str[i];
            elem += str[i + 1];
            i += 2;
        }
        else if (i + 1 < str.length() && isupper(str[i]) && isdigit(str[i + 1]))
        {
            mul = str[i + 1] - '0';
            elem += str[i];
            i += 2;
        }
        else if (isupper(str[i]))
        {
            mul = 1;
            elem += str[i];
            i++;
        }
        else
            i++;
        if (!mp[elem])
        {
            return -2147483648;
        }
        else
        {
            ans += mul * mp[elem];
        }
    }
    return ans;
}
int main()
{
	//输入数据不用多说了吧？
    string s;
    cin >> s;
    while (s != "END_OF_FIRST_PART")
    {
        int x;
        cin >> x;
        mp[s] = x;
        cin >> s;
    }
    cin >> s;
    while (s != "0")
    {
        Part *pt = new Part(s, 1);
        int res = pt->getResult();
        if (res < 0)
            printf("UNKNOWN\n");
        else
            printf("%d\n", res);
        cin >> s;
    }
    return 0;
}
```





---

## 作者：zombie462 (赞：0)

### 还没有Pascal的代码？

#### 那就来一篇吧

首先，我们自然而然联想到表达式求值的一道题，只要将元素符号转化为数字，再在分子式内加上加号和乘号就可以了。当然，这样做肯定费时费力，所以我们将那道题目的栈结构改变一下。

几个元素符号看着很不顺眼，所以我们将他们转化成$Hash$值，即首位和末位按权展开：

```
function hash(s:string):longint;
begin
  if length(s)=1 then exit(ord(s[1])-64)
  else exit((ord(s[1])-64)*100+ord(s[2])-96);
end;
```
读入部分很简单
```
  while true do
  begin
    readln(st);
    if st='END_OF_FIRST_PART' then break;//结束了就退出
    k:=pos(' ',st);
    val(copy(st,k+1,length(st)),m);//数字部分
    mass[hash(copy(st,1,k-1))]:=m;//定义原子质量
  end;
```
然后，正文部分如何展开呢？

我们有如下步骤：

第一步，如果遇到左括号，直接进栈，等级$+1$

第二步，如果遇到大写字母，向后寻找还有没有小写字母和数字，并得到这些东西。

$sum=mass\times cnt$

第三步，如果遇到右括号，向后寻找还有没有数字，并得到这些东西。

$ans[i]=ans[i+1]\times cnt[i+1]$

然后出栈。

值得注意的是，如果得不到数字，则$cnt=1$

```
  while true do
  begin
    readln(st);
    fillchar(num,sizeof(num),0);//初始化
    w:=0;//当前级别
    if st='0' then break;//完成了就退出
    flag:=true;
    st:='('+st+')';//方便最后的处理
    for i:=1 to length(st) do
    begin
      if st[i]='(' then//进栈
      begin
        inc(w);
        num[w]:=0;
      end;
      if st[i] in ['A'..'Z'] then//碰到元素符号
      begin
        if st[i+1] in ['a'..'z'] then name:=st[i]+st[i+1]
        else name:=st[i];//得到完整名称
        if mass[hash(name)]=-1 then//如果找不到这个元素符号
        begin
          writeln('UNKNOWN');
          flag:=false;
          break;
        end;
        j:=i+length(name);//继续向后寻找数字
        cnt:=0;
        while st[j] in ['0'..'9'] do
        begin
          cnt:=cnt*10+ord(st[j])-48;//和C++的快读差不多
          inc(j);
        end;
        if cnt=0 then cnt:=1;//如果没有数字就是1
        num[w]:=num[w]+mass[hash(name)]*cnt;//获得整个部分的质量分数
      end;
      if st[i]=')' then//出栈
      begin
        j:=i+1;//向后寻找数字
        cnt:=0;
        while st[j] in ['0'..'9'] do
        begin
          cnt:=cnt*10+ord(st[j])-48;
          inc(j);
        end;
        if cnt=0 then cnt:=1;
        dec(w);//更新上一级别的质量分数
        num[w]:=num[w]+num[w+1]*cnt;
      end;
    end;
    if flag=true then writeln(num[0]);//如果没有出现UNKNOWN情况
  end;
```
### 完整程序

```
var mass,num:array[0..10000]of longint;
    st,name:string;
    flag:boolean;
    k,i,j,cnt,w,m:longint;
function hash(s:string):longint;
begin
  if length(s)=1 then exit(ord(s[1])-64)
  else exit((ord(s[1])-64)*100+ord(s[2])-96);
end;
begin
  fillchar(mass,sizeof(mass),255);
  while true do
  begin
    readln(st);
    if st='END_OF_FIRST_PART' then break;
    k:=pos(' ',st);
    val(copy(st,k+1,length(st)),m);
    mass[hash(copy(st,1,k-1))]:=m;
  end;
  while true do
  begin
    readln(st);
    fillchar(num,sizeof(num),0);
    w:=0;
    if st='0' then break;
    flag:=true;
    st:='('+st+')';
    for i:=1 to length(st) do
    begin
      if st[i]='(' then
      begin
        inc(w);
        num[w]:=0;
      end;
      if st[i] in ['A'..'Z'] then
      begin
        if st[i+1] in ['a'..'z'] then name:=st[i]+st[i+1]
        else name:=st[i];
        if mass[hash(name)]=-1 then
        begin
          writeln('UNKNOWN');
          flag:=false;
          break;
        end;
        j:=i+length(name);
        cnt:=0;
        while st[j] in ['0'..'9'] do
        begin
          cnt:=cnt*10+ord(st[j])-48;
          inc(j);
        end;
        if cnt=0 then cnt:=1;
        num[w]:=num[w]+mass[hash(name)]*cnt;
      end;
      if st[i]=')' then
      begin
        j:=i+1;
        cnt:=0;
        while st[j] in ['0'..'9'] do
        begin
          cnt:=cnt*10+ord(st[j])-48;
          inc(j);
        end;
        if cnt=0 then cnt:=1;
        dec(w);
        num[w]:=num[w]+num[w+1]*cnt;
      end;
    end;
    if flag=true then writeln(num[0]);
  end;
end.
```

---

## 作者：aRenBigFather (赞：0)

看到有括号优先级就想到了用DFS(作用类似于栈)

dfs的意义类似于取从第'p'位置开始的化学式的质量，那么只要一遇到前括号就dfs，遇到后括号表示这一坨化学式算完了，那么就返回

要注意的是，为了防止重复判断后括号(比如一个后括号不是和前面的一个前括号匹配而是和另一个更近的前括号匹配)，在dfs的返回值上做出了一些处理，用pair可以让返回值有两个(自己写struct也可以)一个是答案，一个是当前这个化学式结束的位置。这样当dfs完就可以将i移到化学式结束的地方继续开始找括号(或化学式)，不会重复

找数字和找化学式都很简单，封装了两个函数，复杂度有点高不过也可以AC

```cpp
//化学元素                            起始位置
inline string getElement(string &ele,int sta){
	string ret;
	ret += ele[sta];
	sta++;
	while(ele[sta] >= 'a' && ele[sta] <= 'z'){
		ret += ele[sta];
		sta++;
	}
	return ret;
}
//系数
inline string getNum(string &ele,int sta){
	string ret;
	ret += ele[sta];
	sta++;
	while(ele[sta] >= '0' && ele[sta] <= '9'){
		ret += ele[sta];
		sta++;
	}
	return ret;
}
//string -> num
inline ll string2Num(string str){
	ll ret = 0;
	for(int i=0;i<str.size();i++){
		ret += (str[i]-'0') * pow(10,str.size()-i-1);
	}
	return ret;
}
```
完整代码:
```cpp
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
map< string , ll> elem;
inline string getElement(string &ele,int sta){
	string ret;
	ret += ele[sta];
	sta++;
	while(ele[sta] >= 'a' && ele[sta] <= 'z'){
		ret += ele[sta];
		sta++;
	}
	return ret;
}
inline string getNum(string &ele,int sta){
	string ret;
	ret += ele[sta];
	sta++;
	while(ele[sta] >= '0' && ele[sta] <= '9'){
		ret += ele[sta];
		sta++;
	}
	return ret;
}
inline ll string2Num(string str){
	ll ret = 0;
	for(int i=0;i<str.size();i++){
		ret += (str[i]-'0') * pow(10,str.size()-i-1);
	}
	return ret;
}
bool unknow = false;
pair<ll,ll> dfs(string ele,int p,int deep){
	if(unknow) return make_pair(-1,-1);
	ll ret = 0;
	for(int i=p;i<ele.size();i++){
		if(unknow) return make_pair(-1,-1);
		if(ele[i]=='('){
			pair<ll,ll> tmp = dfs(ele,i+1,deep+1);
			ret += tmp.first;
			i = tmp.second;
		}else if(ele[i]==')'){
			if(i+1 < ele.size() && ele[i+1] >= '0' && ele[i+1] <= '9'){
				string nn = getNum(ele,i+1);
				ll num = string2Num(nn);
				return make_pair(ret*num,i+nn.size());
			}
			return make_pair(ret,i+1);
		}else if(ele[i] >= 'A' && ele[i] <= 'Z'){
			string nowele = getElement(ele,i);
			if(!elem.count(nowele)){
				unknow = true;
				return make_pair(-1,-1);
			}
			if(ele[i+nowele.size()] >= '0' && ele[i+nowele.size()] <= '9'){
				string nn = getNum(ele,i+nowele.size());
				ll num = string2Num(nn);
				ret += elem[nowele] * num;
			}else{
				ret += elem[nowele];
			}		
		}
	}
	return make_pair(ret,ele.size());
}
void solve(string ele){
	unknow = false;
	pair<ll,ll> ans = dfs(ele,0,1);
	if(unknow){
		cout << "UNKNOWN" << endl;
	}else{
		cout << ans.first << endl;
	}
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	string ele;
	while(cin >> ele){
		if(ele == "END_OF_FIRST_PART") break;
		ll mm;
		cin >> mm;
		elem[ele] = mm;
	}
	
	while(cin >> ele){
		if(ele == "0") break;
		solve(ele);
	}
	
	return 0;
}
```

---

## 作者：JustinRochester (赞：0)

不懂为什么，本蒟蒻用在线算法打就一直炸......

直到用了"半离线"算法......

一遍就过了好吗......

某位机房的小伙伴一遍就过了

另一位机房的小伙伴也是每次都爆零，还大叫"我再也不打这一题了"

嗯......真香！

---

**【分析】**
--

本蒟蒻看到题目的第一做法是考虑怎么储存元素的质量

假设我们把只由一个字母构成的元素符号看成后面补了一个空格

那么，每个元素都是由两位字符组成

其中第一位一定为大写，第二位一定为小写或空格

那么，也就是说，最多给定 $26 \times 27 = 702$ 种不同的元素

因此，我们直接可以开一个数组 $m_i$ 存各个元素的质量

根据上面的提示，显然，这边用27进制会比较 ~~elegant~~ 优雅

同时，我们可以在读入字符时加一个判定

读入完大写字符后，直接读入下一位

如果是空格，显然应该跳出

如果是小写，显然应该进制转换

根据题目，输入结束的标志为

"END_OF_FIRST_PART"

这是个很明显的标志，它的第二位也是大写

我们可以利用这个标志，判断什么时候读入部分结束

至于数字读入，可以参考读入优化的思路

这边加一条忠告 ~~(过来人的语气)~~ ：读到结束标志了记得吞掉整行

---

嗯，继续讲一下计算分子量的实现

这边本蒟蒻不懂为什么，按一边读入一边压栈一边算的在线算法打一直会出错(重点是本地测还没问题)，所以就用字符数组来存了......

我们用一个字符数组 **(这里特地强调，不是字符串 string ，因为本蒟蒻觉得那个很耗时间)** 来存化学式

接下来的运行跟读入其实差不多

不过，这边要加一个限制

如果出现括号，我们需要先计算括号内的值，再乘上括号的系数(在反括号后)

这边其实就是一个栈

一旦出现括号，说明要先算里面的，我就把之前算好的先放到栈里面

等对应的反括号出现，我们就可以直接算出这个括号描述的原子团的值

把这个值与系数的乘积加回上一层的栈里，就可以把这个括号解决了

那其他的细节就看一下本蒟蒻 ~~奇丑无比~~ 的代码吧

---

**【代码】**
--

那本蒟蒻就放代码了

```cpp
#include<cstdio>
#include<cctype>
#include<cstring>
using namespace std;
int m[800]={0};
char s[100]={0};
inline int READ_NAME(char &c){
    register int ans=0; while(!isupper(c)) c=getchar();
    ans=c-'A'; c=getchar();
    if(islower(c)) ans+=(c-'a'+1)*26,c=getchar();
    return ans;
}//元素名读入
inline int READ_NUM(char &c){
    register int ans=0; while(!isdigit(c)) c=getchar();
    while(isdigit(c)) ans=(ans<<3)+(ans<<1)+c-'0',c=getchar();
    return ans;
}//数字读入
int READ_CHE(){
	int stack[80]={0},size=0,pos=0,len=strlen(s);
    //stack[i]表示第i层括号内的值
	while(pos<len){
			 if(!(s[pos]^'(')) stack[size++],pos++;
             //指针记得后移
		else if(!(s[pos]^')')){
			int tmp=0;
			if(!isdigit(s[pos+1])) tmp=1;
			while(isdigit(s[pos+1])) tmp=(tmp<<3)+(tmp<<1)+s[++pos]-'0';
            //读入优化类似代码
			pos++;
			stack[size-1]+=stack[size]*tmp;
			stack[size--]=0;
            //避免出现被(NH4)[Al(OH)4]卡掉的情况，虽然不知道是否存在这个物质
		}
		else if(isupper(s[pos])){
			int Tmp=s[pos]-'A';
			if(islower(s[pos+1])) Tmp+=(s[pos+1]-'a'+1)*26,pos++;
            //计算编码
			if(!m[Tmp]) return -1;
            //没读入到，直接返回"UNKNOWN"的指令
			int tmp=0;
			if(!isdigit(s[pos+1])) tmp=1;
			while(isdigit(s[pos+1])) tmp=(tmp<<3)+(tmp<<1)+s[++pos]-'0';
			pos++;
			stack[size]+=m[Tmp]*tmp;
		}
	}
	return stack[0];//返回第0层括号内的值
}//质量计算
inline void pre(){
    char c=getchar();
    while(1){
        int tmp=READ_NAME(c);
        if(isupper(c)){//读到结束语句
            while((c^'\n')&(c^'\r')) c=getchar();//吞掉整行
            return ;
        }
        m[tmp]=READ_NUM(c);
    }
}
int main(){
    pre();
    scanf("%s",s);
    while(s[0]^'0'){
        int tmp=READ_CHE();
        if(tmp>0) printf("%d\n",tmp);
        else puts("UNKNOWN");
        //读到未知元素会返回 -1
        memset(s,0,sizeof(s));
        //记得清零，避免被 H2O F2 卡掉
        scanf("%s",s);
    }
    return 0;
}
```

---


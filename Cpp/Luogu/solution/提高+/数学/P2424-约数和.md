# 约数和

## 题目背景

Smart 最近沉迷于对约数的研究中。


## 题目描述

对于一个数 $X$，函数 $f(X)$ 表示 $X$ 所有约数的和。例如：$f(6)=1+2+3+6=12$。对于一个 $X$，Smart 可以很快的算出 $f(X)$。现在的问题是，给定两个正整数 $X,Y(X<Y)$，Smart 希望尽快地算出 $f(X)+f(X+1)+……+f(Y)$的值，你能帮助 Smart 算出这个值吗？


## 说明/提示

对于 $20\%$ 的数据有 $1\leq X<Y\leq 10^5$。

对于 $60\%$ 的数据有 $1\leq X<Y\leq 1\times 10^7$。

对于 $100\%$ 的数据有 $1\leq X<Y\leq 2\times 10^9$。


## 样例 #1

### 输入

```
2 4```

### 输出

```
14```

## 样例 #2

### 输入

```
123 321```

### 输出

```
72543```

# 题解

## 作者：zzlzk (赞：86)

- 把$f(x)$用数学方式表示一下就是$f(x)=\sum\limits_{d|x}d$


- 那   $ans=\sum\limits_{i=x}^{y}f(i)=\sum\limits_{i=x}^{y}\sum\limits_{d|i}d$


- 那我们就可以直接枚举然后累加就可以了。


- 但这样的时间复杂度是$O(\sum\limits_{i=x}^{y}\sqrt i)$，会$TLE$


- 所以换一种思路，枚举约数


- 考虑$1-n$中有几个数是 $d$ 的倍数


- 假如$1-n$中存在 $d$ 的倍数，那这个数肯定可以表示为 $k·d(k\in N_+)$


- $k$ 的范围可以再简化一下，$1\leq k·d\leq n\Rightarrow 1 \leq k \leq \lfloor\frac{n}{d}\rfloor$


- 也就是说从$1-n$ 中把 $d$ 的倍数单独拿出来，那就是$d,2d,3d.....\lfloor\frac{n}{d}\rfloor d$


- 所以$1-n$中 $d$ 的倍数的个数就是 $\lfloor\frac{n}{d}\rfloor$


-  求出 $y$ 的个数，再减去 $x-1$ 的个数，也就是$x-y$ 的个数，这个是比较好想的，所以我就不详细说了。


- 这样$\sum\limits_{i=1}^{n}f(i)$就可以表示为$\sum\limits_{i=1}^{n}(\lfloor\frac{n}{i}\rfloor*i)$


- 那$ans=\sum\limits_{i=1}^{y}(\lfloor\frac{y}{i}\rfloor*i)-\sum\limits_{i=1}^{x-1}(\lfloor\frac{x-1}{i}\rfloor*i)$


- 这种做法时间复杂度是$O(y)$，还是会$TLE$


- 再看$\sum\limits_{i=1}^{n}(\lfloor\frac{n}{i}\rfloor*i)$


- 只看$\lfloor\frac{n}{i}\rfloor$，胡乱找个数列出来$\lfloor\frac{n}{i}\rfloor(1\leq i \leq n)$的值


- 以$12$为例，列出来是$12,6,4,3,2,2,1,1,1,1,1,1$ ，第 $i$ 个数表示$\lfloor\frac{n}{i}\rfloor$的值


- 发现这里面有些数是重复的，考虑能不能把这些重复的一次算出来


- 把那些相同的值用区间来表示，那只要求出左右端点$l,r$来就好了


- $l$ 比较好求，观察上面的数列，$l$ 就是上一个$r$加$1$，初始$l=1$


- 那 $r$ 怎么求呢？~~其实很简单~~


-  $r=n/(n/l)$


-  $l$是那个数列的下标，所以 $(n/l)$ 就是约数，那 $r$ 就显然了，如果不知道为什么，那就再看一遍“$1-n$中有几个数是 $d$ 的倍数”。


- $l$ 和$r$ 都知道了， 那答案呢？


- $ans+=$约数\*约数的个数

- 约数$=n/l$

- 约数的个数$=\sum\limits_{i=l}^r i$，用等差数列求和公式表示一下就是$(l+r)*(r-l+1)/2$


- 即$ans+=(n/l)*(l+r)*(r-l+1)/2$


- 然后就愉快的AC啦！


---
~~比题解不知道短到那里去的代码~~

```cpp
#include<cstdio>
using namespace std;
typedef long long ll;

ll sum(int n) {
    if(n<=1) return n;
    ll ans=0;
    for(ll l=1,r;l<=n;l=r+1) {
        r=n/(n/l);
        ans+=(n/l)*(l+r)*(r-l+1)/2;
    }
    return ans;
}

int main() {
    int x,y;
    scanf("%d%d",&x,&y);
    printf("%lld\n",sum(y)-sum(x-1));
    return 0;
}
```

---

## 作者：hfee (赞：20)

~~小蒟蒻总是看不懂数学公式，所以来发个题解~~

这题难度有点虚高，先看题目

计算$f(x)+f(x+1)+f(x+2)+...+f(y)$

### 很容易联想到用前缀和的方式快速求出

那么怎么算出前缀和呢~~很简单~~

考虑一下，在1到x的所有数字里

是1的倍数的有$x/1$个,它们的和是$x/1*1$

是2的倍数的有$x/2$个,它们的和是$x/2*2$

是3的倍数的有$x/3$个,它们的和是$x/3*3$

......

而我们要求的是所有数的约数和

很明显,只要把所有上述数字累加起来即可

```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll x,y,ans;
ll wk(ll q){
	ans=0;
	for(ll i=1;i<=q;i++) ans+=q/i*i;//q/i代表有几个i的倍数,再*i代表它们的和.
	return ans;
} 
int main(){
	cin>>x>>y;
	cout<<wk(y)-wk(x-1);
	return 0;
}
```
高高兴兴地交上去

T掉4个点

怎么办呢?

想着简化wk里面的循环 

我们再看看一个数约数的规律

以16为例,$q/i$分别是
```
16 8 5 4 3 2 2 2 1 1 1 1 1 1 1 1 
```

这么明显的重复计算怎么能不优化一下呢

我们假设当前序列（即几个一样的数）的左端点的下标是$l$,右端点的下标是$r$

下一个$l$当然是$r+1$了

那$r$呢?~~也很简单~~

$r=q/(q/l)$

$q/l$就是当前的约数啦,$q/(q/l)$也就很好理解了

现在就可以熟练地应用等差数列求和公式了

本来是$ans+=q/i*i$

现在把$q/i$合并了，$*i$就变成了一个等差数列

ans+=约数*约数的个数

约数=$q/l$

约数的个数=(首项+末项)*项数/2=$(l+r)*(r-l+1)/2$

愉快地解决了

# CODE:
```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll x,y,ans,r,s;
ll wk(ll q){
	ans=0;
	for(ll l=1;l<=q;l=r+1){
		s=q/l;
		r=q/s;
		ans+=s*(l+r)*(r-l+1)/2;
	} 
	return ans;
} 
int main(){
	cin>>x>>y;
	cout<<wk(y)-wk(x-1);
	return 0;
}//讲的很细不注释了

```


---

## 作者：shenbear (赞：13)

# 除法分块模板题

首先，先不说除法分块，我们先想思路

### 1.暴力枚举
```cpp
#include <bits/stdc++.h>
using namespace std;
int a,b;
int f(int x)
{
	int s=0;
	for(int i=1;i*i<=x;i++)
	{
		if(x%i==0) s+=i+x/i;
		if(i*i==x) s-=i; 
	}
//	printf("%d %d\n",x,s);
	return s;
}
int main()
{
	int sum=0;
	cin>>a>>b;
	for(int i=a;i<=b;i++)
	{
		sum+=f(i);
	}
	cout<<sum;
	return 0;
}

```
直接枚举所有数，再求约数之和

复杂度O(n^3/2) 20分

### 2.设f[x]为1~x的约数和，我们发现所求的，就是f[b]-f]a]

对于求1~x的约数之和，有一个方法：

你仔细观察，会发现一个事情：（一下除都是整除）

**1这个因子被选了n/1次，2被选了n/2次，以此类推，x被选了n/x次**

举个例子：4

1=1

2=1+2

3=1+3

4=1+2+4

1被选了4次，2被选了2次，3被选了1次，4被选了1次

所以简单来说，

### f[x]=∑n/i *(i) (1<=i<=x)

直接o(n)扫一遍，60分



------------
那到底怎么做呢？

## 正解：除法分块

什么叫除法分块？又该怎么写？

拿100来说，我们发现

100/51=1

100/52=1

……

100/99=1

100/100=1

我们发现51~100那么大一段数，他们的n/i都是1，所以我们可以对其合并，将51~100这一段的值合并为1*（51+……+100），然后用等差数列求和公式O（1）求出即可

所以，简单来说

**除法分块就是把一些n/i值相等的部分合并，用等差数列公式求出**

怎么写？

还是以100为例

首先，设r=100

在r不为0的情况下循环

m=100/r=1

l=x/(m+1)+1=51

在l~r中n/i恒为m=1

所以，s+=m*(r+l)*(r-l+1)/2

然后下一个 ， r = l-1 =50

代码：
```
i8 slove(i8 x)
{
	i8 s=0;
//	for(int i=1;i<=x;i++) s+=x/i*i;
	i8 r=x;
	while(r)
	{
		i8 m=x/r;
		i8 l=x/(m+1)+1;
		s+=(r+l)*(r-l+1)*m/2;
		r=l-1;
	}
	return s;
}
```


------------

完整代码：

```cpp
#include <bits/stdc++.h>
#define i8 __int128
#define ll long long
using namespace std;
const int R = 2e9;
void print(i8 n)
{
	if(n>9) print(n/10);
	putchar(n%10+48);
}
i8 ans;
i8 slove(i8 x)
{
	i8 s=0;
//	for(int i=1;i<=x;i++) s+=x/i*i;
	i8 r=x;
	while(r)
	{
		i8 m=x/r;
		i8 l=x/(m+1)+1;
		s+=(r+l)*(r-l+1)*m/2;
		r=l-1;
	}
	return s;
}

int x,y;
int main()
{
	cin>>x>>y;
	print(slove(y)-slove(x-1));
	return 0;
}

```


---

## 作者：Mr_Spade (赞：10)

来一发杜教筛的题解吧......~~难道只有我第一反应是杜教筛吗~~

根据题目的定义，$f(x)$其实就是数论函数中的$\sigma(x)$。

而在狄利克雷卷积的意义下有：

$$\sigma=1*id$$

两边同乘$\mu$，得：

$$\mu*\sigma=id$$

因此可以考虑用杜教筛来求$\sigma(x)$的前缀和，函数$g(x)$可以选择$\mu(x)$，注意$\mu(x)$的前缀和也是需要用杜教筛来求的。

只要贴一个杜教筛的模板就可以了，复杂度是$O(n^{\frac{2}{3}})$。

```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<map>
#define int long long
using std::map;
const int N=2e6+5;
int prime[N],tot;
bool isprime[N];
int mu[N],smu[N];
int sigma[N],ssigma[N];
map<int,int> memomu,memosigma;
inline void sieve(int n)
{
    register int i,j;
    memset(isprime+1,1,sizeof(bool)*n);
    isprime[1]=0;mu[1]=sigma[1]=1;
    for(i=1;i<=n;i++)
    {
        if(isprime[i])
            prime[++tot]=i,mu[i]=-1,sigma[i]=i+1;
        for(j=1;j<=tot&&prime[j]*i<=n;j++)
        {
            isprime[i*prime[j]]=0;
            if(i%prime[j]==0)
            {
                sigma[i*prime[j]]=sigma[i]*sigma[prime[j]]-sigma[i/prime[j]]*prime[j];
                break;
            }
            mu[i*prime[j]]=-mu[i];
            sigma[i*prime[j]]=sigma[i]*sigma[prime[j]];
        }
    }
    for(i=1;i<=n;i++)
        smu[i]=smu[i-1]+mu[i];
    for(i=1;i<=n;i++)
        ssigma[i]=ssigma[i-1]+sigma[i];
    return;
}
int n;
int Smu(int x)
{
    if(x<=2000000)
        return smu[x];
    if(memomu.find(x)!=memomu.end())
        return memomu[x];
    int res=1,l,r;
    for(l=2;l<=x;l=r+1)
    {
        r=x/(x/l);
        res-=(r-l+1)*Smu(x/l);
    }
    return memomu[x]=res;
}
int Ssigma(int x)
{
    if(x<=2000000)
        return ssigma[x];
    if(memosigma.find(x)!=memosigma.end())
        return memosigma[x];
    int res=x*(x+1)/2,l,r;
    for(l=2;l<=x;l=r+1)
    {
        r=x/(x/l);
        res-=(Smu(r)-Smu(l-1))*Ssigma(x/l); 
    }
    return memosigma[x]=res;
}
signed main()
{
    int l,r;
    sieve(2000000);
    scanf("%lld%lld",&l,&r);
    printf("%lld\n",Ssigma(r)-Ssigma(l-1));
    return 0;
}
```

---

## 作者：wind_cross (赞：7)

	第一眼看到这道题，求x-y区间所有数的约数和，首先就是想打暴力。
    但如果打暴力，即将每个数的约数算出来再相加，只能拿20分，代码如下：
```
#include<cstdio>
#include<cctype>
using namespace std;
template <class code>inline code read(const code &a)
{
    code x=0;short w=0;char ch=0;
    while(!isdigit(ch)) {w|=ch=='-';ch=getchar();}
    while(isdigit(ch)) {x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return w?-x:x;
}
int ys(int x){
	int sum=0;
	for(int i=1;i<=x;i++){
		if(x%i==0)sum+=i;
	}
	return sum;
} 
int main()
{
	int x,y,ans=0;
	x=read(x),y=read(y);
	for(int i=x;i<=y;i++)ans+=ys(i);
	printf("%d\n",ans);
	return 0;
}

```
    这时候，我们就要想如何优化了。显然，1-y中数的约数和减去1-x-1中数的约数和就是x-y中所有数的约数和
    但问题又来了，1-i的的约数和为多少呢？其实，我们只需要求出1-i中，1的倍数有多少个，2的倍数有多少个……一直到i的倍数有多少个，然后i的倍数的个数乘上i，将所有答案相加，就是前i个数的约数和。
    60分代码：
```
#include<cstdio>
#include<cctype>
using namespace std;
template <class code>inline code read(const code &a)
{
    code x=0;short w=0;char ch=0;
    while(!isdigit(ch)) {w|=ch=='-';ch=getchar();}
    while(isdigit(ch)) {x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return w?-x:x;
}
long long qh(int k){
	long long sum=0;
	for(int i=1;i<=k;i++){
		sum+=k/i*i;//求出i的倍数的个数，注意还要乘上i 
	}
	return sum;
}
int main()
{
	int x=read(x),y=read(y);
	printf("%lld\n",qh(y)-qh(x-1));
	return 0;
}

```
    这个代码为什么会是60分呢？很显然，这份代码的时间复杂度为O(x+y)，可以通过60%的数据，然而最大数据可以达到2*10^9，当然会超时。

    于是，再想优化的方法，我们会发现，k/i的答案很多会相同，如100/99=1,100/98=1,100/97=1……
    若（k/i==x），k/i==x中i的最大值为j,则j一定为k/(k/i)
    这样，时间复杂度就降到了O（sqrt(x-1)+sqrt(y)）

    100分代码如下：
```
#include<cstdio>
#include<cctype>
using namespace std;
template <class code>inline code read(const code &a)
{
    code x=0;short w=0;char ch=0;
    while(!isdigit(ch)) {w|=ch=='-';ch=getchar();}
    while(isdigit(ch)) {x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return w?-x:x;
}
long long qh(int k){
	long long i,j,sum=0;
	i=1;
	while(i<=k){
		j=k/(k/i);
		sum+=(k/i)*(i+j)*(j-i+1)/2;//主要思想，就是k/i到i+k/(k/i)区间所有数的和
		i=j+1;//时间复杂度的优化
	}
	return sum;
}
int main()
{
	int x=read(x),y=read(y);
	printf("%lld\n",qh(y)-qh(x-1));//x-y区间的约数和
	return 0;
}

```
	这道题有一定的思维难度，但只要认真思考，是可以做出来的。
	希望这篇题解对大家有所帮助！

---

## 作者：zclong (赞：6)

用前缀和思想&&等差数列优化

ans=work(r)-work(l-1);

令g[x]=f[1]+f[2]+f[3]+...+f[x];

对于x,每一个i,有 x/i个数的因子包括i；

60分
```cpp
#include<iostream>
#include<cstdio>
#define ll long long
using namespace std;
ll ans,xx,y;
ll work(ll x)
{
    ll t=0;
    for(ll i=2;i<=x;i++)
        t+=i*(x/i);
    return t+x;
}
int main()
{
    scanf("%lld%lld",&xx,&y);
    ans=work(y)-work(xx-1);
    printf("%lld",ans);
    return 0;
}
```
这样会超时，
找规律的小程序

 for(int i=1;i<=100;i++)

 cout<<i<<" "<<100/i<<endl;

发现可以用等差数列优化

100/51=100/52=100/53=1；

对于快速求出每一个x/i的和可以用等差数列优化，公比是1；

公式 （a1+an）\*n/2;

100分
```cpp
#include<iostream>
#include<cstdio>
#define ll long long
using namespace std;
ll ans,xx,y;
ll work(ll x)
{
ll t=0,l=1,r;
while((x/l)!=0)
{
r=x/(x/l);
ll s=x/l;
t+=((r-l+1)*(l+r)/2)*s;//等差数列求和公式
l=r+1;
}
return t;
}
int main()
{
scanf("%lld%lld",&xx,&y);
ans=work(y)-work(xx-1);
printf("%lld",ans);
return 0;
}
```

---

## 作者：封禁用户 (赞：4)

### 一种不用分块的做法
先把要求的东西表示成数学式子 ：
$$\sum\limits_{i=x}^{y}\sum\limits_{d\mid i}d$$
令 $f(n)=\sum\limits_{i=1}^{n}\sum\limits_{d\mid i}d$ ，转为枚举 d ，可得 ：
$$f(n)=\sum\limits_{d=1}^{n}d\left\lfloor\dfrac{n}{d}\right\rfloor$$
到这里可以分块算 。
$$=\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{n}i\left[i\times j\le n\right]$$
$$=\sum\limits_{i=1}^{\left\lfloor\sqrt{n}\right\rfloor}\sum\limits_{j=1}^{\left\lfloor\frac{n}{i}\right\rfloor}i+\sum\limits_{j=1}^{\left\lfloor\sqrt{n}\right\rfloor}\sum\limits_{i=1}^{\left\lfloor\frac{n}{j}\right\rfloor}i-\sum\limits_{i=1}^{\left\lfloor\sqrt{n}\right\rfloor}\sum\limits_{j=1}^{\left\lfloor\sqrt{n}\right\rfloor}i$$
$$=\sum\limits_{i=1}^{\left\lfloor\sqrt{n}\right\rfloor}i\left\lfloor\dfrac{n}{i}\right\rfloor+\sum\limits_{j=1}^{\left\lfloor\sqrt{n}\right\rfloor}\left\lfloor\frac{n}{j}\right\rfloor\left(\left\lfloor\frac{n}{j}\right\rfloor+1\right)-\left\lfloor\sqrt{n}\right\rfloor\sum\limits_{i=1}^{\left\lfloor\sqrt{n}\right\rfloor}i$$
$$=\dfrac{\sum\limits_{i=1}^{\left\lfloor\sqrt{n}\right\rfloor}\left\lfloor\dfrac{n}{i}\right\rfloor\left(\left\lfloor\dfrac{n}{i}\right\rfloor+2i+1\right)-\left\lfloor\sqrt{n}\right\rfloor^{2}\left(\left\lfloor\sqrt{n}\right\rfloor+1\right)}{2}$$
然后就可以直接算了。
```cpp
#include <cmath>
#include <iostream>
using namespace std;
#define ll long long
ll sum(int n) {
	ll ans=0;
	int sqrn=sqrt(n);
	for(int i=1; i<=sqrn; ++i) ans+=(n/i)*(ll)(n/i+2*i+1);
	return (ans-sqrn*sqrn*(ll)(sqrn+1))>>1;
}
int main() {
	int x,y;
	cin>>x>>y;
	cout<<sum(y)-sum(x-1);
	return 0;
}
```


---

## 作者：月离 (赞：4)

#### P2424 约数和

[点我传送](https://www.luogu.org/problem/P2424)

本篇题解是有由[这里](https://www.luogu.org/blog/user36557/solution-p2424)点出的灵感，但是个人认为该dalao部分解释不明确~~而且码风极其毒瘤~~给像我这样的菜鸡造成了不便，于是在此解释和充实该题解

###  关于前缀和



```cpp

//引自zclong大佬的部分代码（括号在下面都是异教徒）
ll work(ll x)
{
    ll t=0;
    for(ll i=2;i<=x;i++)
        t+=i*(x/i);
    return t+x;
}

//不过我更倾向于写成这样
ll work(ll x)
{
    ll t=0;
    for(ll i=1;i<=x;i++){
        t+=i*(x/i);
    return t;
}


```

在此稍作解释：

通过打表（打表程序见文末）我们可以看出来，约数（x/i）在work求和过程中经常会出现（出现i次），所以我们可以用代码中i*(x/i)的形式进行求和，最终求得:

```cpp
sum=f(1)+f(2)+f(3).....+f(x)
```
这里就运用了前缀和的思想，我们分别求得sum(x-1)和sum(y)，进行相减后即是x-y的值

```cpp
sum(x-1)=f(1)+f(2)+f(3)....f(x-1)
sum(y)=f(1)+f(2)+f(3)....f(y)
sum(y)-sum(x-1)=f(x)+f(x+1)....f(y)//最终结果
```

在代码中具体表现为：

```cpp
//虽然运用了前缀和，但是依然不是最优解
//复杂度也许是O(2n)??不会算
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll x,y;
ll f(int x){
	ll sum=0;
	for(ll i=1;i<=x;i++){
		sum+=i*(x/i);
	}
	return sum;
}
int main(){
	scanf("%lld%lld",&x,&y);
	ll ans=0;
	ans=f(y)-f(x-1);
	printf("%lld",ans);
	return 0;
}
```
当然仅仅这样是拿不到满分的

###   重点：如何寻找规律以获得最优方法？

在打表的过程中我们还可以看出，很多约数(x/i)的值是一样的。

比如"1"这个数，当x=100时它竟然被加了整整50次。

结合代码来看

```cpp
sum+=i*(x/i);
```
这一过程被重复使用，但是(x/i)并没有改变

那么我们如何省去这一过程呢？

依然打表找规律，在x=100,(x/i)=1时，原代码要进行以下运算

```cpp
51*1+52*1+53*1+...100*1
```
为什么不把它化简一下呢

```cpp
1*(51+52+53....100)
->1*((51+100)*50/2)
->(x/i)*(j+i)*(j-i+1)/2
//其中i为(x/i)=1是最小的数，即上式的51
//其中j为(x/i)=1是最大的数，即上式的100
//(j+i)为首项加末项
//(j-i+1)为项数
```

我们运用等差数列求和的方法简化了原来过分重复的操作

另：i的大小可以由上个约数的j加一来得到

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll x,y;
ll f(ll x){
	ll sum=0;
	for(ll i=1;i<=x;i){
		int j=x/(x/i);
		sum+=(j+i)*(j-i+1)/2*(x/i);
		i=j+1;
	}
	return sum;
}
int main(){
	scanf("%lld%lld",&x,&y);
	ll ans=0;
	ans=f(y)-f(x-1);
	printf("%lld",ans);
	return 0;
}
```
~~实在看不下去zclong大佬的码风，还是自己写的舒服~~

附上打表程序

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll x;
void f(ll x){
	for(ll i=1;i<=x;i++){
		printf("%d ",i);
		printf("%d\n",x/i);
	}
}
int main(){
	scanf("%lld",&x);
	f(x);
	return 0;
}
```
萌新求过


---

## 作者：zhukoov (赞：3)

今天挺好的，不用日自己。
自己推导做了一题。

题目如下（p2424）：
题目描述

对于一个数X，函数f(X)表示X所有约数的和。例如：f(6)=1+2+3+6=12。对于一个X，Smart可以很快的算出f(X)。现在的问题是，给定两个正整数X,Y(X<Y)，Smart希望尽快地算出f(X)+f(X+1)+……+f(Y)的值，你能帮助Smart算出这个值吗？
输入输出格式
输入格式：

输入文件仅一行，两个正整数X和Y（X<Y），表示需要计算f(X)+f(X+1)+……+f(Y)。

输出格式：

输出只有一行，为f(X)+f(X+1)+……+f(Y)的值。


------------

乍看麻烦，实际上我们解这题的代码量很少，只是需要深刻理解其中的推导过程。

对于单个数求约数和的方法如下：

最易想到的方法就是我们只需挨个模（模为零就加上）。
在此基础上可以做优化：在这个数开方的范围里模，模为零就除一下，商和除数都加上，这样时间复杂度也可以开方。

这是在计算机能大量计算的基础上我们可以不怕麻烦的做法。
那么我们是否可以用数学语言表达约数和？

这里引入定理：算数基本定理（也叫唯一分解定理）。

算术基本定理可表述为：任何一个大于1的自然数 N,如果N不为质数，那么N可以唯一分解成有限个质数的乘积N=P1^a1\*P2^a2\*P3^a3\*......Pn^an，这里P1<P2<P3......<Pn均为质数，其中指数ai是正整数。
那么对于一个数的约数和，是否可以用该定理的表达方式表达？

可以由**数学归纳法**得到这个数的约数和：
S=(1+P1^1+P1^2+...+P1^a1)\*(1+P2^1+P2^2+...+P2^a2)\*...(1+Pn^1+Pn^2+...+Pn^an)

该式中从每个括号中提出一项相乘即为该数的一个约数。



------------
~~但是知道这个好像也没有什么卵用~~

------------

~~没关系，涨知识了。~~

本题的切入点在于"X,X+1,X+2...Y"这个区间的数的约数和怎么求。
这个区间能让我联想到前缀和的模板,即用\[1,Y]区间减去\[1,X-1]区间即可
而事实上,直接求\[1,n]区间的所有数的约数和的和也更容易---

我们又回到了最开始的方法,但只不过这回是逐个除去约数(设为k)(即\[1,n]包含了多少个k的倍数那么就有多少次k出现)然后将商和约数相乘加到和里即可.

如何优化?

当然和之前也很相似.

举个例子: 对于n=1000


| 除数 | 1 | 2 | 3 | ... | 32（=>sqrt(1000）+1） |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
|商  | 1000 | 500 | 333 | ... ...| 31 |
| 除以区间中的整数 |-----| \(500,1000] |(333,500]  | ... ...| (31,32] |
| 商 |-----| 1 | 2 | ... ...| 31 |

于是我们只需要把计算次数降至logn次了.

但是究竟最后一个除数该是多少呢? sqrt(n)?sqrt(n)+1?

如果按照我的表格的计算方式,我们需要在sqrt(n)\*(sqrt(n)+1)<n 时加上最后一项,除到前者就够了.

如下代码

------------


```cpp
//约数和
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;
long long x,y;
long long f(long long n)
{
	long long k=(long long)sqrt(n),ans=0;
	long long j=0;		
	long long d=0;
	
	for(long long i=1;i<=k;i++)
	{
		d=n/i;
		ans+=(d*i);
		ans+=(i-1)*((j-d)*(j+d+1))/2;
		j=d;
	}
	if(k*(k+1)<n) ans+=(k+1)*(n/(k+1));
	return ans;							//-(k+1)*d;
}
int main ()
{
	scanf("%lld%lld",&x,&y);
	printf("%lld",f(y)-f(x-1));
}

// 123				321
// 12  11  10		18	17 	16
// 10  11  12		17  18  20 
```


---

## 作者：飞翔 (赞：3)

设f[i]表示i的约数和，设s(k)=f[1]+f[2]+..+f[k]，因f[1]+f[2]+..+f[X]=[X/1]\*1+[X/2]\*2+[X/3]\*3+..+[X/X]\*X,然而有许多[X/K]的结果是相同的（例如：100/26=100/27=100/…=100/33），则故用O(sqrt(k))的时间复杂度算出s(k),则f[x]+…+f[y]=s(y)-s(x-1)。

给出求s函数的程序段：

```delphi

function fct(#k:qword):qword;
var
  #i,j:qword;
  sum:qword;
begin
  sum:=0;
  i:=1;
  while i<=k do
  begin
    j:=k div (k div i);
    sum:=sum+(k div i)*(i+j)*(j-i+1) div 2;
    i:=j+1;
  end;
  exit(sum);
end;
```

---

## 作者：ShuYuMo (赞：2)

# 基本思路
题目要求计算:

$$f(x) + f(x + 1) + f(x + 2) ... f(y - 1) + f(y)$$

再加上求单个函数并不好算，反而对于此函数来说，求前缀和会更为方便。

设：

$$S(n) = \sum f(n)$$


那么:

数字$1$会对答案贡献$\frac{x}{1}$次，即：$\lfloor \frac{x}{1} \rfloor \times 1$

数字$2$会对答案贡献$\frac{x}{2}$次，即：$\lfloor \frac{x}{2} \rfloor \times 2$

数字$3$会对答案贡献$\frac{x}{3}$次，即：$\lfloor \frac{x}{3} \rfloor \times 3$

所以:

$$S(n) = \sum(\lfloor \frac{n}{i} \rfloor \times i)$$

可以$O(n)$求出$S(n)$

# 代码I
```cpp
signed main()
{
    int x = read() - 1, y = read();
    if(x < 0) x = 0;
    int ans1 = 0, ans2 = 0;
    for(_R int i = 1;i <= y;i++)
        ans1 += (y / i) * i;
    for(_R int i = 1;i <= x;i++)
        ans2 += (x / i) * i;
    printf("%lld", ans1 - ans2);
    return 0;
}
```
不能拿到满分。

# 优化
观察这个式子：

$$(x / i) * i$$

注意到$\lfloor \frac{x}{i} \rfloor$随着$i$的增长并不是一直在变化的，而是分段的。

形式化的讲，

$$g(i) = \lfloor \frac{x}{i} \rfloor$$

这个函数是单调呈现阶梯状递增的。

只要求出这个阶梯状函数的拐角，两拐角之间的平台可以设为常熟$k$。

那么在某段区间内，算式能变成

$$k \times i$$

利用等差数列求和即可。

现在的关键在于找到$\lfloor \frac{x}{i} \rfloor$发生改变的拐点。

由于我太菜了，我不能直接算出来，但是比较好想的就是，因为函数$g(i)$是单调的，所以可以二分拐点。

# 代码II
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define _R register
#define int long long 
using namespace std;
int x, y;
long long SolveSegment(const int L,const int R,const int Val)
{
    return (((L + R) * 1LL * (R - L + 1LL)) / 2LL) * 1LL * Val;
}
long long GetIt(int x)
{
    if(x <= 0) return 0LL;
    if(x == 1) return 1LL;
    long long res = 0;
    for(_R int i = 1;i < x;){
        int now = x / i;
        int L = i;
        int R = x;
        int ans;
        if(now == 1){
            res += SolveSegment(ans, x, 1);
            break;
        }
        while(L < R)
        {
            int mid = (L + R) >> 1;
            if((x / mid) < now) ans = mid, R = mid;
            else L = mid + 1;
        }
        res += SolveSegment(i, ans - 1, x / i);
        i = ans;
    }
    return res;
}
signed main()
{
    cin >> x >> y;
    long long ans =  GetIt(y) - GetIt(x - 1);
    printf("%lld",ans);
    return 0;
}
```
本文目的在于提供一种笔者感觉比较好想的思路，但是感觉既然做到这道题了，就尽量去看看更高级的做法？


By [Shu_Yu_Mo](https://shuyumo-1258548314.cos-website.ap-beijing.myqcloud.com/mainpage/index.html)

---

## 作者：HeartBlock_Love (赞：0)

这题卡了好久，题目很简单很好理解，可推公式的确是件棘手的事

首先想到的方法是用前缀和的思想，ans [l~r]=ans[1~r] – ans[1~l-1]

求1~n的约数和，用的是这种方法：

1:1/2=0           ans=1

2:2/2=1 2/3=0      ans=1*2+2=4

3:3/2=1 3/3=1 3/4=0 ans=1*3+1*2+3=8

4:4/2=2 4/3=1 4/4=1 ans=2*2+1*3+1*4+4=15

原理很明显

n除以一个数a，的数就是1~n这些数中以a为因数的数的个数，再乘以a，就是一个因数和

最后加上n是由于n本身是n的因数

可是糟糕，这种方法会超时，只得了60分

60分代码

```
#include<iostream>
using namespace std;
long long l,r,al,ar;
long long work(long long a){
    long long result=0;
    for(long long i=2;i<=a;i++){
        if(a/i==0)break;
        result+=(a/i)*i;
    }
    result+=a;
    return result;
}
int main(){
    cin>>l>>r;
    al=work(l-1);
    ar=work(r);
    cout<<ar-al;
}
```

无计可施的我在这道题上崩溃了，心塞……


这题思路是没毛病的，但是TLE的问题说明代码需要优化加速

用等差数列优化

首先根据之前的发现，以4为例，会发现4/3=1,4/4=1，同样的，在别的数字上也会出现类似的情况，而且数字越大，这种情况的出现越多，我把3,4分别叫做本例中情况的左右边界。而且不难发现这种情况的连续序列中因数都是等差的，差为一，所以可以直接利用等差数列求和

![](https://images2015.cnblogs.com/blog/1008672/201702/1008672-20170204191646464-1707786544.jpg)


```
#include<iostream>
#include<cstdio>
using namespace std;
long long l,r;
long long work(long long x){
    long long result=0;
    long long d=1,b;//d是左边界,b是右边界 
    while(1){
        b=x/(x/d);
        long long some=x/d;
        result+=((b+d)*(b-d+1)/2)*some;
        d=b+1;
        if(x/d==0)break;
    }
    return result;
}
int main(){
    cin>>l>>r;
    long long al=work(l-1);
    long long ar=work(r);
    cout<<ar-al;
}
```


---


# [HAOI2011] 向量

## 题目描述

给你一对数 $(a,b)$，你可以任意使用 $(a,b), (a,-b), (-a,b), (-a,-b), (b,a), (b,-a), (-b,a), (-b,-a)$ 这些向量，问你能不能拼出另一个向量 $(x,y)$。

说明：这里的拼就是使得你选出的向量之和为 $(x,y)$。

## 说明/提示

### 样例解释

第一组：$(2,1)+(1,2)=(3,3)$。

第三组：$(-1,0)+(-1,0)+(0,1)+(0,1)+(0,1)=(-2,3)$。

## 样例 #1

### 输入

```
3
2 1 3 3
1 1 0 1
1 0 -2 3```

### 输出

```
Y
N
Y```

# 题解

## 作者：浅色调 (赞：51)

### 思路：
（我不会调格式啊，可以去看我博客：[five20](http://www.cnblogs.com/five20/p/8427795.html)）
首先，我们注意到题目中的向量实际只有4种操作：(a,b),(b,a),(a,-b),(b,-a)。于是由题意得方程组：

$k(a,b)+q(b,a)+w(a,-b)+c(b,-a)=(x,y)$

-->  $(k+w)a+(q+c)b=x,  (k-w)b+(q-c)a=y$.

　　由裴蜀定理可得：$ax+by=c$,x和y有整数解的充要条件是 $gcd(a,b)|c$，
  
  证明：令$a=pgcd(a,b),\ b=qgcd(a,b)$,则原式=$(px+qy)gcd(a,b)=c$，显然因为$gcd(a,b)$为整数，而要使x和y为整数，则$gcd(a,b)|c$。

　　我们回到开始的方程组$(k+w)a+(q+c)b=x,(k-w)b+(q-c)a=y$。由裴蜀定理易得:
  
   使$(k+w),(q+c),(k-w),(q-c)$均为整数的充要条件是：
   
   $gcd(a,b)|x$且$gcd(a,b)|y$。但是注意到(k+w),(k-w)有整数解不一定k和w有整数解（(q+c)和(q-c)是同理的）。此时不妨设$(k+w)=f,(k-w)=g$,则$k=(f+g)/2,w=(f-g)/2$，因为$2|(f+g)$且$2|(f-g)$，显然**要使k和w均为整数则f和g均为偶数或均为奇数（(q+c)和(q-c)同理）**。

　　于是我们考虑这四种情况：

　　1、当(k+w)、(k-w)、(q+c)、(q-c)均为偶数时，$(k+w)a+(q+c)b=x$ 提公因数2结合$gcd(a,b)|x $ => $ 2gcd(a,b)|x$ 同理 $gcd(a,b)|y$

　　2、当(k+w)和(k-w)为偶数，(q+c)和(q-c)为奇数时，$(k+w)a+(q+c)b=x$ 先左右两边同加b，再提公因数2  结合$gcd(a,b)|x$  -->  $2gcd(a,b)|x+b$ 同理 $2gcd(a,b)|y+a$

　　3、当(k+w)和(k-w)为奇数，(q+c)和(q-c)为偶数时，$(k+w)a+(q+c)b=x$ 先左右两边同加a，再提公因数2  结合$gcd(a,b)|x $ -->$2gcd(a,b)|x+a$ 同理 $2gcd(a,b)|y+b$

　　4、当(k+w)、(k-w)、(q+c)、(q-c)均为奇数时，$(k+w)a+(q+c)b=x$ 先左右两边同加a+b，再提公因数2  结合$gcd(a,b)|x$  -->  $2gcd(a,b)|x+a+b$ 同理 $2gcd(a,b)|y+a+b$

　　只要满足上述的任意一种情况，则说明本题k、w、q、c有整数解，说明可行，否则说明无解。

### **代码：**
```
#include<bits/stdc++.h>
#define il inline
#define ll long long
#define debug printf("%d %s\n",__LINE__,__FUNCTION__)
using namespace std;
ll t,a,b,x,y,k;
il int gi()
{
    ll a=0;char x=getchar();bool f=0;
    while((x<'0'||x>'9')&&x!='-')x=getchar();
    if(x=='-')x=getchar(),f=1;
    while(x>='0'&&x<='9')a=a*10+x-48,x=getchar();
    return f?-a:a;
}
il ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}
il bool check(ll x,ll y){return x%k==0&&y%k==0;}
int main()
{
    t=gi();
    while(t--){
        a=gi(),b=gi(),x=gi(),y=gi();
        k=gcd(a,b)*2;
        if(check(x,y)||check(x+a,y+b)||check(x+b,y+a)||check(x+a+b,y+a+b))printf("YE5\n");
        else printf("N0\n");
    }
    return 0;
}
```

---

## 作者：Poncirus (赞：25)

首先，我们先不将 $x, y$ 合并处理，各凑各的。

可以得到：

$$
n_1a+m_1b=x
$$

$$
n_2a+m_2b=y
$$

而以上两式 **分别** 是否有解，可以用裴蜀定理方便地判断，即 $(a,b)\mid x$ 和 $(a,b)\mid y$ 是否成立。

可是分别有解并不代表能同时有解。为了探究两式是否能同时有解，我们先直接将两式相加。

$$
(n_1+n_2)a+(m_1+m_2)b=x+y
$$

但这个式子是否有解仅等价于上两式是否同时有解，与我们的目的不符。

不难发现，题目中的向量可以分为两种：$a,b$ 同号、$a,b$ 异号。

于是我们将左式替换为同号、异号的向量相加的结果，得到：

$$
n_3(a+b)+m_3(a-b)=x+y
$$

裴蜀定理判断该式是否有解即可。

***

```cpp
#define int long long
namespace XSC062 {
using namespace fastIO;
int T, a, b, x, y, d, d1;
int gcd(int x, int y) {
	return y ? gcd(y, x % y) : x;
}
int main() {
	read(T);
	while (T--) {
		read(a);
		read(b);
		read(x);
		read(y);
		d = gcd(a + b, a - b);
		d1 = gcd(a, b);
		if ((x + y) % d == 0 && x % d1 == 0 && y % d1 == 0)
			puts("Y");
		else
			puts("N");
	}
	return 0;
}
} // namespace XSC062
#undef int
```

---

## 作者：Kelin (赞：13)

本质上这个东西只有这样几种操作：

>$1.x\pm2a$或$y\pm2a$

>$2.x\pm2b$或$y\pm2b$

>$3.x+a,y+b$

>$4.x+b,y+a$(减可以加两次加回来)

令$A=2a,B=2b,d=\gcd(A,B)$

对于一对$(x,y)$若其能被构造

那么一定存在一组$(i,j),(u,v)$，使得：

$$iA+jB=x,uA+vB=y$$

根据裴蜀定理

>$a,b\in\mathbb Z,(a,b)=d\Rightarrow\forall x,y\in \mathbb Z$,$d|ax+by$

>特别地，$\exists x,y\in\mathbb Z,ax+by=d$

所以必须要$d|x$且$d|y$ 这样$(x,y)$才能被构造

然后对于一对$(x,y)$又有四种情况

>$1.(x,y)$

>$2.(x+a,y+b)$

>$3.(x+b,y+a)$

>$4.(x+a+b,y+a+b)$

只要一种情况满足$(x,y)$便可以被构造

```cpp
#include<cstdio>
int T,x,y,a,b;long long d;
int gcd(int a,int b){return !b?a:gcd(b,a%b);}
inline bool ok(long long x,long long y){return x%d==0&&y%d==0;}
int main(){
    scanf("%d",&T);
    while(T--){
        scanf("%d%d%d%d",&a,&b,&x,&y);d=gcd(a,b)<<1;x%=d;y%=d;a%=d;b%=d;
        if((ok(x,y)||ok(x+a,y+b)||ok(x+b,y+a)||ok(x+a+b,y+a+b)))puts("Y");
        else puts("N");
    }
return 0;
}
```

---

## 作者：xryjr233 (赞：9)

其实可操作相当于只有$(a,b),(a,-b),(b,a),(b,-a)$,因为加上$(-a,-b)$相当于减去$(a,b)$,其他的同理。

那么问题就变成了找到整数$c,d,e,f$,使

$c(a,b)+d(a,-b)+e(b,a)+f(b,-a)=(x,y)$成立。

化简原方程,得

$(c+d)a+(e+f)b=x$

$(e-f)a+(c-d)b=y$

根据裴蜀定理,方程$ax+by=c$整数解,当且仅当

$gcd(x,y)|c$成立。

我们设$P(x,y,c)$为真表示上式成立,为假表示不成立。

那么这题就是$P(a,b,x)\ and\ P(a,b,y)$为真,原方就程就有解吗?

并不是。因为这样只能保证$c+d,e+f,c-d,e-f$是整数,而$c=\frac{(c+d)+(c-d)}{2},d=\frac{(c+d)-(c-d)}{2},e=\frac{(e+f)+(e-f)}{2},f=\frac{(e+f)-(e-f)}{2}$就不一定是整数了。

所以我们不仅要求$P(a,b,x)\ and\ P(a,b,y)$为真,还要求$c+d,c-d$奇偶性相同,$e+f,e-f$奇偶性相同。

我们$hs(x,y,c,f)$表示方程组

$ax+by=c$

$dx+ey=f$

是否存在$a,e$奇偶性相同,$b,d$奇偶性相同的解,为真表示存在,为假表示不存在。

那么我们分类讨论。

1.当$a\equiv e\equiv b\equiv d\equiv0(mod\ 2)$时,我们发现$\frac{a}{2},\frac{b}{2},\frac{d}{2},\frac{e}{2}$的取值范围为整数。

那么我们得到

$\frac{a}{2}x+\frac{b}{2}y=\frac{c}{2}$

$\frac{d}{2}x+\frac{e}{2}y=\frac{f}{2}$

有解。

根据裴蜀定理,$P(x,y,\frac{c}{2})\ and\ P(x,y,\frac{f}{2})$为真。

即$P(2x,2y,c)\ and\ P(2x,2y,f)$为真。

换句话说,当$a,b,d,e$为偶数,$P(2x,2y,c)\ and\ P(2x,2y,f)$为真则存在解。

2.当$a,e$和$b,d$中有某一组或者两组都是奇数,以$a,e$是奇数为例:

由

$ax+by=c$

$dx+ey=f$

得

$(a+1)x+by=c+x$

$dx+(e+1)y=f+y$

这样一来就回到了偶数的情况,即$P(2x,2y,c+x)\ and\ P(2x,2y,f+y)$为真。

综上所述,当

$P(2x,2y,c)\ and\ P(2x,2y,f)$

$P(2x,2y,c+x)\ and\ P(2x,2y,f+y)$

$P(2x,2y,c+y)\ and\ P(2x,2y,f+x)$

$P(2x,2y,c+x+y)\ and\ P(2x,2y,f+x+y)$

中有任意一个为真时,$hs(x,y,c,f)$为真。

code:

```cpp
#include<bits/stdc++.h>
using namespace std;
long long gcd(long long x,long long y){
	return y?gcd(y,x%y):x;
}
bool P(long long x,long long y,long long c){
	return !(c%gcd(x,y));
}
int T;
long long a,b,x,y;
int main(){
	scanf("%d",&T);
	while(T--)scanf("%lld%lld%lld%lld",&a,&b,&x,&y),printf("%c\n",((P(2*a,2*b,x)&&P(2*a,2*b,y))||(P(2*a,2*b,x+a)&&P(2*a,2*b,y+b))||(P(2*a,2*b,x+b)&&P(2*a,2*b,y+a))||(P(2*a,2*b,x+a+b)&&P(2*a,2*b,y+a+b)))?'Y':'N');
	return 0;
}
```

---

## 作者：滑大稽 (赞：6)

话说题解的做法都好简单啊。。。像我这种还把不定方程都给解出来了。

首先还是一个很显然的做法：我们只需要四个向量即可，丢掉的四个向量把系数变为负就可以了。

然后我们就得到了这样一个方程（稍微改了一下变量名，感觉可能更清楚）：

$$
a(x,y)+b(x,-y)+c(y,x)+d(y,-x)=(ans1,ans2)
$$

把横纵坐标分别拆开：

$$
\left\{\begin{aligned}
ax+bx+cy+dy=ans1
\\
ay-by+cx-dx=ans2
\end{aligned}\right.
$$

整理下同类项：

$$
\left\{\begin{aligned}
(a+b)x+(c+d)y=ans1
\\
(c-d)x+(a-b)y=ans2
\end{aligned}\right.
$$

我们考虑换元：

$$
\left\{\begin{aligned}
a'x+b'y=ans1
\\
c'x+d'y=ans2
\end{aligned}\right.
$$

然后我们分别求出这不定方程的任意一组解就行了吗？

答案当然是否定的。就比如样例的第二组数据，我们求出其中一组解 $a'=1,d'=0$（另一组是 $b',c'$ 不合法，同理）。然后回带后会发现 $d'=0.5$。这当然不符合题意。然后随便移移项，我们发现，只要 $a'$ 和 $d'$ 的奇偶性相同，就可以避免掉小数的问题。（$b',c'$ 同理）。即：

$$
\left\{\begin{aligned}
a'-d'\equiv 0\pmod 2
\\
b'-c'\equiv 0\pmod 2
\end{aligned}\right.
$$

乍一看很难搞，但我们发现，我们可以尝试通解公式来尝试使他满足条件。即：

$$
\left\{\begin{aligned}
a'=a'_ 0+\frac y{(x,y)}s
\\
b'=b'_ 0-\frac x{(x,y)}s
\\
c'=c'_ 0+\frac y{(x,y)}t
\\
d'=d'_ 0-\frac x{(x,y)}t
\end{aligned}\right.
(s,t\in Z)
$$

同时我们发现，我们只关心它的奇偶性，所以假如 $|s|\ge 2$（$t$ 同理），是没有任何意义的。所以我们只需要判断 $s=-1,0,1$ 和 $t=-1,0,1$ 的时候是否满足条件即可。组合一下，共 $9$ 种方案。只要其中一种满足就可以了。

~~尽管思路麻烦了点，但应该是做题的正常考虑方向吧？~~

献上丑陋的代码：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int X,Y;
inline int read()
{
	char h=getchar();
	int y=0,q=1;
	while(h<'0'||h>'9'){if(h=='-')q=-1;h=getchar();}
	while(h>='0'&&h<='9')y=y*10+h-'0',h=getchar();
	return y*q;
}
int gcd(int a,int b)
{
	if(b==0)
	{
		X=1;Y=0;
		return a;
	}
	int d=gcd(b,a%b);
	int z=X;
	X=Y;
	Y=z-(a/b)*Y;
	return d;
}
inline int abs(int x){return x<0?-x:x;}
signed main()
{
	int t=read();
	while(t--)
	{
		int x=read(),y=read(),ans1=read(),ans2=read();
		int g=gcd(x,y);
		if(ans1%g!=0||ans2%g!=0)
		{
			printf("N\n");
			continue;
		}
		int c1=ans1/g,c2=ans2/g;
		int a=X*c1,b=Y*c1,c=X*c2,d=Y*c2;
		bool fl=0;
		for(int i=-1;i<=1;i++)
		for(int j=-1;j<=1;j++)
		{
			int A=a+i*(y/g),B=b-i*(x/g),C=c+j*(y/g),D=d-j*(x/g);
			if(((abs(A-D)&1)==0)&&((abs(B-C)&1)==0))
			{
				fl=1;
				break;
			}
		}
		printf(fl==1?"Y\n":"N\n");
	}
}
```

---

## 作者：BackSlashDelta (赞：5)

## [Luogu P2520 \[HAOI2011\]](https://www.luogu.com.cn/problem/P2520)

### 题面

给予一对数 $a,b$ ，求能否用 $a,b$ 组成的“简单向量”“简单拼凑”出另一个向量 $\overrightarrow{v}=(x,y)$  
$a,b$ 组成的“简单向量”有 $(a,b), (a,-b), (-a,b), (-a,-b), (b,a), (b,-a), (-b,a), (-b,-a)$  
（“简单拼凑”指的是像 $k_1\cdot(a,b)+k_2\cdot(b,a)=(x,y)$ 的计算方式，其中 $k_i\in\text{Z}$）

### 题解

因为 $(a,b)\parallel(-a,-b)$ ，所以可以将 $(-a,-b)$ 看作 $-(a,b)$ 。
于是 $a,b$ 组成的“简单向量”的数量就减少到了 $4$ 个。

> 即“简单向量”可以简化为 $(a,b),(a,-b),(b,a),(b,-a)$

因此可以列出方程 $k_1\cdot(a,b)+k_2\cdot(a,-b)+k_3\cdot(b,a)+k_4\cdot(b,-a)=(x,y)$ 

依据向量的加法，可以转化为方程组：
$\left\{\begin{array}{c}x=(k_1+k_2)\cdot a+(k_3+k_4)\cdot b\\y=(k_1-k_2)\cdot b+(k_3-k_4)\cdot a\end{array}\right .$

此时令 $\left\{\begin{array}{c}r_1=k_1+k_2\\r_2=k_3+k_4\\r_3=k_1-k_2\\r_2=k_3-k_4\\\end{array}\right .$ ，方程组转化为 $\left\{\begin{array}{c}x=r_1\cdot a+r_2\cdot b\\y=r_3\cdot b+r_4\cdot a\end{array}\right .$ 

此时问题就转化成了：是否存在 $r_1,r_2,r_3,r_4$ 使上方程组有解，且 $r_1$ 与 $r_3$ 同奇偶，$r_2$ 与 $r_4$ 同奇偶。

> ~~同奇偶不做证明，自己手推~~

又因为 $x=r_1\cdot a+r_2\cdot b$ ， 所以 $\gcd(a,b)\mid x$  
同理，$\gcd(a,b)\mid y$ 

> 对于 $\gcd(a,b)=r_1\cdot a+r_2\cdot b$ ，其中的 $r_1,r_2$ 一定有解。  
> 所以 $k\cdot\gcd(a,b)=k\cdot r_1\cdot a+k\cdot r_2\cdot b$ ，其中的 $k\cdot r_1,k\cdot r_2$ 一定有解。

考虑四种情况：

- 当 $2\mid r_1,\,2\mid r_2,\,2\mid r_3,\,2\mid r_4$ 时，有 $2\gcd(a,b)\mid x,2\gcd(a,b)\mid y$ 

  > 因为 $2\mid r_1,\,2\mid r_2,\,2\mid r_3,\,2\mid r_4$ ，所以 $2\mid x$ ，  
  > 所以等式两边同时处以 $2$ ， 得：$\frac{x}{2}=\frac{r_1}{2}\cdot a+\frac{r_2}{2}\cdot b$  
  > 容易得到，$\gcd(a,b)\mid\frac{x}{2}$ ，所以有 $2\gcd(a,b)\mid x$
  >
  > 同理，$2\gcd(a,b)\mid y$

- 当 $2\mid r_1,\,2\nmid r_2,\,2\mid r_3,\,2\nmid r_4$ 时，有 $2\gcd(a,b)\mid (x+b),2\gcd(a,b)\mid (y+a)$

  >显然，因为 $2\nmid r_2$ ，所以 $2\mid (r_2+1)$ 。（$r_i\in\text{Z}$）
  >
  >等时两边同时加上 $b$ ，得：$x+b=r_1\cdot a+(r_2+1)\cdot b$   
  >等式两边同时处以 $2$ ， 得：$\frac{x+b}{2}=\frac{r_1}{2}\cdot a+\frac{r_2+1}{2}\cdot b$   
  >所以 $\gcd(a,b)\mid\frac{x+b}{2}$ ，即 $2\gcd(a,b)\mid (x+b)$
  >
  >同理 $2\gcd(a,b)\mid (y+a)$

- 当 $2\nmid r_1,\,2\mid r_2,\,2\nmid r_3,\,2\mid r_4$ 时，有 $2\gcd(a,b)\mid (x+a),2\gcd(a,b)\mid (y+b)$

  >显然， $2\mid (r_1+1)$ 。（$r_i\in\text{Z}$）
  >
  >等时两边同时加上 $a$ ，得：$x+a=(r_1+1)\cdot a+r_2\cdot b$   
  >等式两边同时处以 $2$ ， 得：$\frac{x+a}{2}=\frac{r_1+1}{2}\cdot a+\frac{r_2}{2}\cdot b$   
  >所以 $\gcd(a,b)\mid\frac{x+a}{2}$ ，即 $2\gcd(a,b)\mid (x+a)$
  >
  >同理 $2\gcd(a,b)\mid (y+b)$

- 当 $2\nmid r_1,\,2\nmid r_2,\,2\nmid r_3,\,2\nmid r_4$ 时，有 $2\gcd(a,b)\mid (x+a+b),2\gcd(a,b)\mid (y+a+b)$

  > 依旧显然， $2\mid (r_1+1),2\mid (r_2+1)$ 。（$r_i\in\text{Z}$）
  >
  > 等时两边同时加上 $(a+b)$ ，得：$x+a+b=(r_1+1)\cdot a+(r_2+1)\cdot b$   
  > 等式两边同时处以 $2$ ， 得：$\frac{x+a+b}{2}=\frac{r_1+1}{2}\cdot a+\frac{r_2+1}{2}\cdot b$   
  > 所以 $\gcd(a,b)\mid\frac{x+a+b}{2}$ ，即 $2\gcd(a,b)\mid (x+a+b)$
  >
  > 同理 $2\gcd(a,b)\mid (y+a+b)$

只要上述情况满足任意一个，即有解，否则无解。

因此问题就转化为了判断 $2\cdot \gcd(a,b)$ 是否满足上述情况，  
如果满足就输出 ```Y``` ，否则输出 ```N``` 。

### 注意！

- 在判断 $\gcd(a,b)$ 时一定要特判 ```a==0``` 与 ```b==0``` 的情况！
- 如果觉得自己程序正确但是总是通不过某一个数据点，打开 ```long long``` 试试
> 显而易见的是，在 ```x+a+b``` 或 ```y+a+b``` 时，最大结果可能是 $10^9\times 3$ ，而 ```int``` 的最大存储值为 ```2147483647``` ，此时已经超出了 ```int``` 的范围限制，所以会错误。


### 代码

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>

// Definitions
typedef long long int64;
typedef long double num128;
typedef unsigned long long uint64;

// Variables
int64 t, a, b, x, y;

// Improve the speed of read-in.
inline bool IsNum(char x) { return ('0' <= x) && (x <= '9'); }
inline int64 ReadNum() {
int64 sign = 1, val = 0; char tmp = getchar();
while (!IsNum(tmp)) { if (tmp == '-') {sign = -sign;} tmp = getchar(); }
while (IsNum(tmp)) { val = val * 10 + tmp - 48; tmp = getchar(); }
return val * sign;
}

// Functions
inline int64 gcd(int64 _x, int64 _y) {
  if (_x == 0) {
    return _y;
  }
  if (_y == 0) {
    return _x;
  }
  while (_y ^= _x ^= _y ^= _x %= _y);
  return _x;
}
inline void Process() {
  int64 k = 2 * gcd(a, b);
  if (x % k == 0 && y % k == 0) {
    puts("Y");
  } else if ((x + b) % k == 0 && (y + a) % k == 0) {
    puts("Y");
  } else if ((x + a) % k == 0 && (y + b) % k == 0) {
    puts("Y");
  } else if ((x + a + b) % k == 0 && (y + a + b) % k == 0) {
    puts("Y");
  } else {
    puts("N");
  }
}
inline void ReadIn() {
  a = ReadNum();
  b = ReadNum();
  x = ReadNum();
  y = ReadNum();
}

int main() {
  t = ReadNum();
  while (t--) {
    ReadIn();
    Process();
  }
  return 0;
}
/*

*/

```

---

## 作者：pantw (赞：5)

$w(a,b)+x(a,-b)+y(b,a)+z(b,-a)=(A,B)$


等价于$aw+ax+by+bz=A \land bw-bx+ay-az=B$


消元一下：

$(a^2+b^2)w+(a^2-b^2)x+2aby=Aa+Bb$

所以一定有：

$let \space d=(a^2+b^2,a^2-b^2,2ab),

d|Aa+Bb$


与此相似，分别消去方程中的w,x,y,z,得到：

$d|Aa+Bb,d|Aa-Bb,d|Ab+Ba,d|Ab-Ba$

```cpp
#include <cstdio>
#define Lovelive long long
template <typename T>
T gcd(T a, T b) {
    return b ? gcd(b, a % b) : a;
}
template <typename T>
T abs(T x) {
    return x >= 0 ? x : -x;
}
int main() {
    Lovelive t, a, b, x, y, d;
    scanf("%lld", &t);
    for(; t--; ) {
        scanf("%lld%lld%lld%lld", &a, &b, &x, &y);
        d = gcd(gcd(a*a+b*b, abs(a*a-b*b)), abs(2*a*b));
        puts((x*a+y*b)%d==0&&(x*a-y*b)%d==0&&(x*b+y*a)%d==0&&(x*b-y*a)%d==0?"Y":"N");
    }
}
```

---

## 作者：lei_yu (赞：3)

[更好的阅读体验](https://www.cnblogs.com/lytql/p/15026839.html)


转换题意
------------
为了表述方便，我们设目标向量为 $(s_1,s_2)$，**和题目描述稍有差别**。

我们首先只考虑目标向量的横坐标。由于横坐标为 $a$，$-a$，$b$，$-b$ 的向量均可任意使用，我们可以得到一个不定方程 $xa+yb=s_1$。

之后，我们再考虑目标向量的纵坐标，由于 $x+k-k=x$，我们可以得到第二个不定方程 $(x+2k_1)b+(y+2k_2)a=s_2$。

联立上述两个不定方程，题意便转化为了这两个不定方程是否有解。

数学推理
------------
单独考虑第一个不定方程，根据扩欧相关知识，我们可以知道该不定方程有解当且仅当 $\gcd(a,b)\ |\ s_1$，直接判断即可。

然后，我们设第一个不定方程的特解为 $x_0$，$y_0$，那么其通解为 $x_0+k \frac{b}{\gcd(a,b)}$，$y_0-k\frac{a}{\gcd(a,b)}$。

把通解带入第二个不定方程，得 $(x_0+k \frac{b}{\gcd(a,b)}+2k_1)b+(y_0-k\frac{a}{\gcd(a,b)}+2k_2)a=s_2$。

移项和整理，得 $2k_1b+2k_2a=s_2-x_0b-y_0a+k(\frac{a^2-b^2}{\gcd(a,b)})$。

把 $k$ 视作已知，故原不定方程有解当且仅当 $\gcd(2a,2b)\ |\ [s_2-x_0b-y_0a+k(\frac{a^2-b^2}{\gcd(a,b)})]$。

即 $s_2-x_0b-y_0a+k(\frac{a^2-b^2}{\gcd(a,b)})=-t\gcd(2a,2b)$。

再移项，得 $t\gcd(2a,2b)+k(\frac{a^2-b^2}{\gcd(a,b)})=s_2-x_0b-y_0a$。

这又是一个不定方程，其有解当且仅当$\gcd(\gcd(2a,2b),k(\frac{a^2-b^2}{\gcd(a,b)}))\ |\ s_2-x_0b-y_0a$。

该不定方程有解时，原不定方程也一定有解。

结论
------------
当且仅当 $\gcd(a,b)\ |\ s_1$ 且 $\gcd(\gcd(2a,2b),k(\frac{a^2-b^2}{\gcd(a,b)}))\ |\ s_2-x_0b-y_0a$ 时，目标向量可以被表示。

代码
------------
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define int long long
using namespace std;
inline int r()
{
	int s=0,k=1;char c=getchar();
	while(!isdigit(c))
	{
		if(c=='-')k=-1;
		c=getchar();
	}
	while(isdigit(c))
	{
		s=s*10+c-'0';
		c=getchar();
	}
	return s*k;
}
int q,x,y,s1,s2;
int exgcd(int a,int b)
{
	if(!b)
	{
		x=1;y=0;
		return a;
	}
	int g=exgcd(b,a%b);
	int tmp=x;
	x=y;
	y=tmp-y*(a/b);
	return g;
}
signed main()
{
	int a,b;
	q=r();
	for(int i=1;i<=q;i++)
	{
		a=r();b=r();s1=r();s2=r();
		int g=exgcd(a,b);
		if(s1%g)
		{
			cout<<"N"<<endl;
			continue;
		}
		s1/=g;
		int x0=x*s1,y0=y*s1;
		int g1=exgcd(2*a,2*b);
		x0=(x0%g1+g1)%g1;
		y0=(y0%g1+g1)%g1;
		int c=s2-x0*b-y0*a;
		c=(c%g1+g1)%g1;
		int gg=exgcd((a*a-b*b)/g,g1);
		if(c%gg)
		{
			cout<<"N"<<endl;
			continue;
		}
		cout<<"Y"<<endl;
	}
}
```


---

## 作者：javalyc (赞：3)

[博客传送门](https://www.cnblogs.com/LLTYYC/p/11475244.html)

为啥所有题解代码都差不多...我的思路可能和其他题解不太一样?

~~自认为自己思路比较简单...~~

显然要开始写式子

$k_1a+k_2b=x$

$k_3a+k_4b=y$

首先如果上面两个式子只要有一个没有整数解就一定不合法

如果存在 $k_1+k_2=k_3+k_4$ 那就有解咯

考虑一下发现只要 $k_1+k_2$ 和 $k_3+k_4$ 奇偶性相同即可，因为比较少的那个可以补上 $(a,b)+(-a,-b)$

考虑 $k_1+k_2$ 的关系，设 $d=gcd(a,b)$，则有 $(k_1+pb/d)a+(k_2-pa/d)b=x$ 一定成立，并且由裴蜀定理可知仅当 $p$ 为整数时成立

所以如果 $pb/d$ 和 $pa/d$ 的奇偶性不同，那么 $k_1+k_2$ 的既可以是奇数也可以是偶数，那么一定有解

$k3+k4$ 也是同理

如果 $k_1+k_2$ 和 $k_3+k_4$ 的奇偶性不同，并且 $pb/d$ 和 $pa/d$ 奇偶性相同，那么不管怎么变化奇偶性都不同，一定无解

当然多一些关于 $0$ 的特判总是没错的，把负数转成正数也同样不会影响答案

```cpp
// luogu-judger-enable-o2
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;
typedef long long ll;
inline ll read()
{
	ll x=0,f=1; char ch=getchar();
	while(ch<'0'||ch>'9') { if(ch=='-') f=-1; ch=getchar(); }
	while(ch>='0'&&ch<='9') { x=(x<<1)+(x<<3)+(ch^48); ch=getchar(); }
	return x*f;
}
ll T,a,b,x,y;
ll exgcd(ll a,ll b,ll &x,ll &y)
{
	if(!b) { x=1,y=0; return a; }
	ll d=exgcd(b,a%b,x,y);
	ll t=x; x=y; y=t-a/b*y;
	return d;
}
int main()
{
	T=read();
	while(T--)
	{
		a=read(),b=read(),x=read(),y=read();
		if(!a&&!b)
		{
			if(!x&&!y) printf("Y\n");
			else printf("N\n");
			continue;
		}
		if(a<0) a=-a; if(b<0) b=-b;
		if(a<b) swap(a,b);
		ll k1,k2,d1=exgcd(a,b,k1,k2);
		if(x%d1) { printf("N\n"); continue; }
		ll k3,k4,d2=exgcd(a,b,k3,k4);
		if(y%d2) { printf("N\n"); continue; }
		k1*=x/d1; k2*=x/d1; k3*=y/d2; k4*=y/d2;
		if((!a||!b) || ((k1+k2)%2+2)%2==((k3+k4)%2+2)%2 ) { printf("Y\n"); continue; }
		if(((a/d1)&1)^((b/d1)&1) || ((a/d2)&1)^((b/d2)&1) ) printf("Y\n");
		else printf("N\n");
	}
	return 0;
}
```


---

## 作者：QcpyWcpyQ (赞：2)

### solution
- 首先，注意到向量的平行关系，实际上只有四种操作。
- 我们令$A=2a,B=2b,k=\gcd(A,B)$
- 所以根据平面向量基本定理，要求的就是下面不定方程组是否有整数解：
$$\begin{cases}\lambda_1A+\lambda_2B=x\\\lambda_3A+\lambda_4B=y\end{cases}$$
- 根据裴蜀定理:
$$\exists x,y\in \mathbb{Z},ax+by=c(a,b,c\in\mathbb{Z})\iff \gcd(a,b)\mid c$$
- 即当且仅当$k\mid x\land k\mid y$时才有解。
- 对于一对$(x,y)$的变换，有四种情况:
$$(x,y)\leftarrow(x,y)$$
$$(x,y)\leftarrow(x+a,y+b)$$
$$(x,y)\leftarrow(x+b,y+a)$$
$$(x,y)\leftarrow(x+a+b,y+a+b)$$
- 当满足于以上任意一种情况时，$(x,y)$可以被构造。

------------
### code
```cpp
#include<cstdio>
using namespace std;

typedef long long LL;

int Q,x,y,a,b;
LL k;

inline int gcd(int a,int b){return b?gcd(b,a%b):a;}//gcd函数，最好手打。 

inline bool pd(LL x,LL y){//判断是否整除。 
	return !(x%k) and !(y%k);
}

inline int read(){//快读 。 
	int s=0,f=1;
	char ch=getchar();
	while(ch<'0' or ch>'9'){
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
	while(ch>='0' and ch<='9'){
		s=(s<<1)+(s<<3)+(ch^48);
		ch=getchar();
	}
	return f*s;
}

int main(){
    Q=read();
    while(Q--){
        a=read(),b=read(),x=read(),y=read(); 
		k=gcd(a,b)<<1;//令k=2*gcd(a,b)。 
		x%=k,y%=k,a%=k,b%=k;//取模 
        if( pd(x,y)or 
		    pd(x+a,y+b)or
		    pd(x+b,y+a)or
		    pd(x+a+b,y+a+b))//判断 
				puts("Y");
        else puts("N");
    }
	return 0;
}
```


---

## 作者：Euler_Pursuer (赞：1)

# 题目概述

本题实质上就是给定两个**高斯整数**及其相伴，询问二者能否构成新的高斯整数。

你可以理解为：类似于给定两个整数，询问你是否能组合出另一个整数。

# 高斯整数

什么是高斯整数？说白了就是平面上的格点，不过我们形式化定义为 $a+bi$，其中 $a,b\in \mathbf{Z}$ 而 $i$ 为虚数单位。

高斯整数满足复数的计算法则，同时还定义了取模运算，而这个取模运算则是关键。

我们还记得整数取模如果有 $x\bmod y=r$，我们其实是定义为 $ky+r=x$。那么同样，如果两个高斯素数取模 $\alpha\bmod\beta=\gamma$，也定义为 $\alpha=\kappa\beta+\gamma$。

但是我们注意到余数可能有多组解，我们会限定余数的模长必须小于除数的模长。

但是我们依然不清楚如何快速得到高斯整数取模后的模数。其实并不难，和整数取模类似，我们得到的商就是直接**整除**得到的，剩下的部分就是余数。

但是此处的**整除**还是有所不同，我们还记得复数的除法会有：

$$
\dfrac{a+bi}{c+di}=\dfrac{ac+bd}{c^2+d^2}+\dfrac{bc-ad}{c^2+d^2}i
$$

此处我们取最靠近这个实商的高斯整数，即实部与虚部分别四舍五入得到的高斯整数，然后再按照定义求余数。可以证明，此时得到的余数是满足我们上面所说的模长约束的。

按照此，我们可以类似整数的欧几里得算法对此仿照出一个欧几里得算法。这个正确性的证明是等同于整数的欧几里得算法的证明的，复杂度也是 $O(\log n)$。

# 新的角度

很显然，有了高斯整数的这些性质，我们就可以类似于整数的同型题方法对此题求解了。

也就是先求出两向量对应的高斯整数的最大公约数，然后判断新的向量对应的高斯整数是否是其高斯整数倍即可。

因此，我们这个角度也就不局限于 $(a,b)$ 和 $(b,a)$ 两种向量了，我们可以推广到任意两个向量 $(a,b)$ 和 $(c,d)$ 及其相伴（诸如 $(-a,b)$ 这样的向量称为相伴），求出它们能否组成新的向量 $(x,y)$。

# 代码一览

```cpp
#include <bits/stdc++.h>

using namespace std;

template <typename T>
inline T Special_Div(const T &a, const T &b) //四舍五入
{
    T d = a/b, r = (a-d*b)*2;
    return d+(r>=b?1:(r<=-b?-1:0));
}

template <typename T>
struct Gauss_Int
{
    T x, y;
    Gauss_Int() : x(0), y(0) {}
    Gauss_Int(T _x, T _y) : x(_x), y(_y) {}
    Gauss_Int(T _x) : x(_x), y(0) {}
    Gauss_Int<T> conj() const;
    Gauss_Int<T> operator + (const Gauss_Int<T>&) const;
    Gauss_Int<T> operator - (const Gauss_Int<T>&) const;
    Gauss_Int<T> operator * (const Gauss_Int<T>&) const;
    Gauss_Int<T> operator / (const T&) const;
    Gauss_Int<T> operator / (const Gauss_Int<T>&) const;
    Gauss_Int<T> operator % (const Gauss_Int<T>&) const;
    bool isZero() const { return !x && !y; }
    void write();
    void read();
    T norm() const;
};

template <typename T>
Gauss_Int<T> Gauss_Int<T>::conj() const
{
    return Gauss_Int<T>(x, -y);
}

template <typename T>
Gauss_Int<T> Gauss_Int<T>::operator + (const Gauss_Int<T> &rhs) const
{
    return Gauss_Int<T>(x+rhs.x, y+rhs.y);
}

template <typename T>
Gauss_Int<T> Gauss_Int<T>::operator - (const Gauss_Int<T> &rhs) const
{
    return Gauss_Int<T>(x-rhs.x, y-rhs.y);
}

template <typename T>
Gauss_Int<T> Gauss_Int<T>::operator * (const Gauss_Int<T> &rhs) const
{
    return Gauss_Int<T>(x*rhs.x-y*rhs.y, x*rhs.y+y*rhs.x);
}

template <typename T>
Gauss_Int<T> Gauss_Int<T>::operator / (const T &v) const
{
    return Gauss_Int<T>(Special_Div(x, v), Special_Div(y, v));
}

template <typename T>
Gauss_Int<T> Gauss_Int<T>::operator / (const Gauss_Int<T> &rhs) const
{
    return *this * rhs.conj() / rhs.norm();
}

template <typename T>
Gauss_Int<T> Gauss_Int<T>::operator % (const Gauss_Int<T> &rhs) const
{
    return *this - *this / rhs * rhs;
}

template <typename T>
void Gauss_Int<T>::write()
{
    printf("(%d, %d)\n", x, y);
}

template <typename T>
void Gauss_Int<T>::read()
{
    cin >> x >> y;
}

template <typename T>
T Gauss_Int<T>::norm() const
{
    return x*x + y*y;
}

template <typename T>
Gauss_Int<T> Gauss_Gcd(Gauss_Int<T> n, Gauss_Int<T> m)
{
    return m.norm() ? Gauss_Gcd(m, n%m) : n;
}

typedef long long ll;

void solve()
{
    Gauss_Int<ll> a, b, c;
    a.read(), c.read();
    b.x = a.y;
    b.y = a.x;
    Gauss_Int<ll> g = Gauss_Gcd(a, b);
    if((c % g).isZero())
        puts("Y");
    else
        puts("N");
}

int main()
{
    int T;
    cin >> T;
    while(T--)
    {
        solve();
    }
    return 0;
}
```

---


# [ZJOI2009] 函数

## 题目描述

有 $N$ 个连续函数 $f_i(x)$，其中 $1\le i\le N$。如果对于任意不相等的 $i,j$ 满足 $1\le i,j\le N$，恰好存在一个 $x$ 使得 $f_i(x)=f_j(x)$，并且存在无穷多的 $x$ 使得 $f_i(x)<f_j(x)$，对于任意 $i,j,k$ 满足 $1\le i < j < k\le N$，不存在 $x$ 使得 $f_i(x)=f_j(x)=f_k(x)$，则称这 $N$ 个连续函数满足条件。

 ![](https://cdn.luogu.com.cn/upload/pic/1708.png) 

如上左图就是 $3$ 个满足条件的函数，最左边从下往上依次为 $f_1,f_2,f_3$。右图中红色部分是这整个函数图像的最低层，我们称它为第一层。同理绿色部分称为第二层，蓝色部分称为第三层。注意到，右图中第一层左边一段属于 $f_1$，中间属于 $f_2$，最后属于 $f_3$。而第二层左边属于 $f_2$，接下来一段属于 $f_1$，再接下来一段属于 $f_3$，最后属于 $f_2$。因此，我们称第一层分为了三段，第二层分为了四段。同理第三层只分为了两段。求满足前面条件的 $N$ 个函数，第 $K$ 层最少能由多少段组成。

## 说明/提示

对于 $100\%$ 的数据满足 $1\le K\le N\le 100$。


## 样例 #1

### 输入

```
1 1
```

### 输出

```
1
```

# 题解

## 作者：无妨 (赞：21)

让我们大胆猜测，可知此题是骗分，直接输出2\*k 稍微特判一下就好了

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
int n,m;
int main()
{
    scanf("%d%d",&n,&m);
    if (m>n/2) m=n-m+1;
    printf("%d",n==1?1:2*m);
    return 0;
}
```

---

## 作者：Zachary_260325 (赞：14)

首先我们读题。

1. 对于任何两个函数fi (x) 和fj (x),(i != j)，恰好存在一个x 使得fi (x) = fj (x)，并且存在无穷多的x 使得fi (x) < fj (x)。
### 由此可知任意两线交于一点，且两条直线一定不重合。

- 不存在x 使得fi (x) = fj (x) = fk (x)
### 由此可知任意三线不交于同一点。


## 那么开始推一下应该咋做：

1. 假设有N条直线**（假设N很大很大(°ー°〃)）**，然后每条直线的形式都是$y=kx+b$，则其$k$值一定各不相同**（不然就会平行或重合，不符合题干）**。

1. 把这N条直线的编号安照其$k$值由大到小进行排序，则编号最小的直线在$x$值足够小的时候，一定是位于最下面**（因为这样到后面才能与其他直线相交）**。

 P.S.按照$k$值排序之后有一点很方便，$k$表示直线的增长率，这就是说，$k$值最大的直线在$x$足够大的时候一定在最上面**（想象一下那从最下面穿到最上面的直线(｀・ω・´)）**

1. 如此排完顺序之后，我们发现在每个函数与其他函数相交时，一定是编号较小的的值在相交之后会大于编号较大的**（应该很好理解，不多废话了┓( ´∀` )┏）**

1. 那么我们可以回到题目了，先去寻找题目所说的第一层的段数，简单来说就是找图上最下层轮廓上有多少交点。把交点数加上1就是答案。

1. 寻找交点时，我们按照$x$从小到大的顺序去找，最开始在最下面的直线是第一条，随着第一条直线的上升，它会与其他直线相交，但是顺序实际上是不确定的**（见下图，左：1先与3相交，右：1先与2相交）**，也就是说最下层的轮廓实际上有很多种合法的可能。因为我们要求**最小**的段数，就要让交点尽量少。我们当然希望在这第一个交点与第一条直线相交的直线是**编号最大**的**（因为这样的话，编号最大的直线一定在此之前一定和其它直线都已经相交，最下层仅有一个交点）**

 ![示范](https://cdn.luogu.com.cn/upload/pic/52140.png)

1. 我们继续找第二层的轮廓，那就是要找时时刻刻第二小的点组成的轮廓。同理，这个轮廓自然也和最下层轮廓一样有许多种可能。同理贪心地考虑，就是最少有三个交点。从第一层到第$N$>>1|1层都符合第$i$层最少有$i*2-1$个交点。

1. 到了第($N$>>1|1)+1层，便更简单了。我们可以简单地将前面的图上下翻转一下**（即原来最下层变成最上层，等等）**，连同理都不用了，直接倒着抄上面得出的结论就行。此时符合第$N-i$层最少有$i*2-1$个交点。

8. #### 特别的，当只有一条直线时答案是1，需要稍微判定一下。

### 综上所述，得出公式：
     ans=(n==1) ? 1:((i<=(n>>1|1)) ? i:(n-i+1))<<1;
     //i表示当前要求的层
     //n表示总层数


P.S. 语文不好，如果发现任何问题请私信我（语句不通，看不懂等），我立刻修改o(╥﹏╥)o

不上代码了，没有必要了...

---

## 作者：Hamer_sans (赞：6)

# P2591的题解

## 题目大意

给定 $n$ 个一次函数，将函数图像画出，求第 $k$ 层最少由多少段构成。

## 分析

这道题我们可以画图分析。

![](https://cdn.luogu.com.cn/upload/image_hosting/1ukh4qes.png?x-oss-process=image/resize,m_lfit,h_375,w_430)

特别地，当 $n=1$ 时，段数为 $1$。

![](https://cdn.luogu.com.cn/upload/image_hosting/xqwuppn5.png?x-oss-process=image/resize,m_lfit,h_375,w_430)

当 $n$ 等与 $2$ 时，可以数出每层是 $2$ 和 $2$。

![](https://cdn.luogu.com.cn/upload/image_hosting/7lrphsp6.png?x-oss-process=image/resize,m_lfit,h_375,w_430)

当 $n$ 等于 $3$ 时，可以数出每层是 $2$，$4$，$2$。

所以我们可以列出表：

![](https://cdn.luogu.com.cn/upload/image_hosting/7lzv6gjo.png?x-oss-process=image/resize,m_lfit,h_430,w_430)

所以我们能够找出规律，个数等于层数乘二，就是$k * 2$，当求的层数大于函数个数也就是每层的个数时，所以就要查找后半段，所以 $k=n-k+1$。

## 代码

```cpp

#include<bits/stdc++.h> // 万能头文件
using namespace std;
int n,k;
int main(){
	scanf("%d%d",&n,&k);
	if(k>n/2) k=n-k+1; // 如果在后半段
	if(n==1) puts("1"); // 特判 1 的情况
	else printf("%d\n",2*k);
	return 0;
}

```

---

## 作者：奶酥奶酥QwQ (赞：5)

大家耐心地画图找规律即可发现:
```cpp
    				 1
                 2       2
             2       4       2
          2     4        4      2
       2     4       6       4     2
       .......
       .......
	n/2之前的是2*k,之后的是2*(n-k) 
```

 ### 附代码qwq
 ```cpp
int n,k;
int main() {
	read(n);//快读
	read(k);//快读
	if(k>n/2) {
		k=n-k+1;
	}
	if(n==1){
		write(1);//快输
		puts("");
		return 0;
	}
	else{
		write(2*k);//快输
		puts("");
	}
	return 0;
} 
```

---

## 作者：zhangjiacheng (赞：3)

### 解题思路：只需要画一个井字形的图，然后认真分析一下，就可以推出，~~（不会发图QAQ）~~，详见代码：
```pascal
var n,k:longint;
begin
  readln(n,k);
  if k>n div 2 then k:=n-k+1;
  if n=1 then writeln(1)
    else writeln(k*2);
end.
```




---

## 作者：VinstaG173 (赞：2)

C党第一次用pascal做题，发篇题解庆祝一下。

结论和别人没有差异，首先k>n/2时与k=n-k+1的情况是一样的，然后特判n=1，就可以了。只是给P党朋友们一个pascal题解而已（貌似还没有pascal题解的样子）。

Code:
```pas
var n,k:longint;
begin
  read(n,k);
  if n<(k*2) then
    k:=n-k+1;
  if n=1 then
    write(n)
  else
    write(k*2);
end.
```

---

## 作者：XeCtera (赞：1)

[题目链接](https://www.luogu.com.cn/problem/P2591)

尝试给出一份比较严谨的证明。

### 1. 题意转化

用排列 $P$ 来记录 $f_1(x)\sim f_N(x)$ 的大小顺序排名。  
具体来说，若某时刻第 $i$ 小的函数是 $f_j(x)$，则定义 $P_i=j$。

不妨设 $x\to-\infty$ 时 $P=[1,2,\cdots,N]$。

考虑 $x$ 不断增大的过程。  
若遇到某两个函数的交点，则这两个函数的排名一定相邻，且在交点前后发生互换。

当 $x\to+\infty$ 时，任意两个函数都已经相交，排名都发生互换，  
则此时的大小顺序与 $x\to-\infty$ 时完全相反，即 $P=[N,\cdots,2,1]$。

题目问“第 $K$ 层最少能由多少段组成”，其实等价于求上述过程中，$P_K$ 最少变化多少次。

至此可将本题转化为一个数列上的问题：

> 对于数列 $P=[1,2,\cdots,n]$，通过不断交换相邻项将其变为 $[n,\cdots,2,1]$。  
> 求在这个过程中，$P_k$ 最少变化多少次。（段数 = 变化次数 + 1）

### 2. 给出下界

$n=1$ 时答案显然为 $1$。下面考虑 $n\geqslant2$ 的情形。

依对称性，不妨设 $k$ 在 $[1,2,\cdots,n]$ 的左半段，即 $k\leqslant\frac{n+1}2.$

 - $1,2,\cdots,k$ 都需要经过 $P_k$ 才能被换到右边，  
   则 $P_k$ 与 $P_{k-1}$ 至少产生 $k$ 次不同的交换。  
 - $n-k+2,\cdots,n-1,n$ 也需要经过 $P_k$ 才能到左边，  
   则 $P_k$ 与 $P_{k-1}$ 至少产生 $k-1$ 次不同的交换。

因此至少产生 $2k-1$ 次交换，$P_k$ 至少变化 $2k-1$ 次。段数至少为 $2k$。

值得注意的是 $k=\frac{n+1}2$ 的特殊情况。  
此时 $k$ 的初始位置和最终位置都在正中间，也可能是往左边换。  
但是根据对称性，分析所得的结果是相同的，并不产生影响。

总之，我们得到了答案的下界是 $2k$。  
再考虑对称性，可以得到另一个下界 $2(n-k+1)$。  
因此更为准确的下界是 $2\max(k,n-k+1)$。

### 3. 给出构造

从直觉上说，除了上面所分析的交换，其余操作都可以在 $P_k$ 两侧独立地完成，那么下界应当是紧的。

但我们还可以回到原题，给出更具几何直观的构造（下图为 $n=7$ 情形）：

![](https://cdn.luogu.com.cn/upload/image_hosting/9rswjsuc.png)

可以看到 $k=1,2,3,4$ 时的段数分别为 $2,4,6,8$，恰好等于 $2k$；  
对于 $k=5,6,7$，根据对称性，只需将图象上下翻转，则段数就能取到 $2(n-k+1)$。

这样的构造适用于任意的奇数 $n$。  
对于 $n$ 为偶数的情况，删去 $t=0$ 的那条水平线即可。

至此，我们证明了此题的答案确实是 $2\max(k,n-k+1)$。

---

## 作者：Arr_ (赞：1)

# 题目大意:
给你$n$个一次函数$fi(x)$，使对于$i!=j$,$fi(x)(<)fj(x)$,$1<=i<j<k<=n$不存在$fi(x)=fj(x)=fk(x)$。

# 思路：
其实这道题本蒟蒻是找规律找出来的。其实最优的添边方法就是对于$Fn(x)$,经过函数$Fn-1(x)$的最中间的线段，并且不影响$$Fi(x)(1<=i<n−1)$$的段数，这样添边就只使:$Fn-1(x)$扩大了2倍。
然后考虑最优解时，可以发现一张图可以正过来看也可以倒过来看。所以答案就是$$min(k,n−k+1)<<1$$当然，要注意$n=1$时特判。

# 如图所示：
![](https://img-blog.csdn.net/20170513224125042?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQ0hOV0pE/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
![](https://img-blog.csdn.net/20170513224936180?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQ0hOV0pE/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
## 最后附上代码：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n,k;
int main()
{
    scanf("%d%d",&n,&k);
    if (n==1) printf("1"); else printf("%d",min(k,n-k+1)<<1);
    return 0;
}
```


---

## 作者：FuriousC (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P2591)

## 前言

这题我一开始看了标签还以为是$dp$，结果搞了好久没搞出来，在此警戒后人：

**这是一道结论题**

## 结论

我得出的结论和其他题解是一样的：

先特判$n=1$时输出$1$。

接着其他就愉快地输出$2\times k$即可。

交了一发，$70pts$。

~~就这都有70pts~~

根据画图发现，$k>n\div 2$时的情况和$k=n-k+1$时的情况是一样的，所以要先将$k$变成$n-k+1$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n,k;
    cin>>n>>k;
    if(k>n/2){
        k=n-k+1;
    }
    if(n==1){
        cout<<1<<endl;
    }else{
        cout<<2*k<<endl;
    }
    return 0;
}
```


---


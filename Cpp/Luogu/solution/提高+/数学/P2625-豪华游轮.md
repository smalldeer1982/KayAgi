# 豪华游轮

## 题目描述

有一条豪华游轮（其实就是条小木船），这种船可以执行 $4$ 种指令：

`right X`：其中 $X$ 是一个 $1$ 到 $719$ 的整数，这个命令使得船顺时针转动 $X$ 度。

`left X`：其中 $X$ 是一个 $1$ 到 $719$ 的整数，这个命令使得船逆时针转动 $X$ 度。

`forward X`：其中 $X$ 是一个整数（$1$ 到 $1000$），使得船向正前方前进 $X$ 的距离。

`backward X`：其中 $X$ 是一个整数（$1$ 到 $1000$），使得船向正后方前进 $X$ 的距离。

随意的写出了 $n$ 个命令，找出一个种排列命令的方法，使得船最终到达的位置距离起点尽可能的远。


## 样例 #1

### 输入

```
3
forward 100
backward 100
left 90```

### 输出

```
141.421356```

# 题解

## 作者：斗神_君莫笑 (赞：10)

本题需要我们求出最长的离原点距离  
那么显然我们可以先走完所有的front,  
尝试转到一个离180度最近的角度后走back，  
问题就转化为了如何求出一通瞎转后离180度最近的角度， 

选取任意旋转后满足某条件  
这不就是个变形的01背包嘛  
按照01的写法枚举出每一种可能达到的角度  
然后挨个遍历取出离180最近的角度  
最后余弦公式就解决了  
注意计算cos的时候要角度转弧度   
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[410],f[20010];
int main(){
	int n;
	cin>>n;
	int x=0,y=0;
	for(int i=1;i<=n;++i){
		string s;cin>>s;
		int dis;cin>>dis;
		if(s=="forward")x+=dis;
		if(s=="backward")y+=dis;
		if(s=="left"){
			dis=dis%360;
			a[dis]++;
			//cout<<dis<<" "<<a[dis]<<endl;
		}
		if(s=="right"){
			dis=dis%360;
			a[360-dis]++;
		}
	}
	f[0]=1;
	for(int i=0;i<360;++i)
		while(a[i]--)
			for(int j=20000;j>=0;--j)
				if(f[j])f[j+i]++;
	int minn=0x7fffffff;
	for(int i=1;i<=20000;++i)
		if(f[i])
			minn=min(minn,abs(i%360-180));
	if(minn==0){
		printf("%d.000000",x+y);
		return 0;
	}
	printf("%.6f",sqrt((double)x*x+(double)y*y-2*(double)x*(double)y*cos((double)(180-minn)*M_PI/180)));
	return 0;
}
```


---

## 作者：凯特琳 (赞：9)

把所有向前走的合并，向后走的合并，所有的操作分为四步走  1.把向前的走完2.转一定角度（最好是180）3.把向后走的走完4.原地转完没转完的角度。


那么此题就是求解角度和最接近180.

之前的一片日志：“多米诺骨牌：双向背包”里面讲了一种 多米诺DP思路。用在本题再适合不过了

在讲一下预处理：先把任意角变到一圈之内，然后选定一个正方向，反方向的角都变成360-x；

然后就跑多米诺DP,本题只要染色即可，不需要最小转动数。




```delphi

program exam1;
const pi=3.141592653589793;
var f,g:array[0..360]of boolean;
var a,b:longint;
var i,j,num,m,n,x:longint;
var c:char;
var jd:array[1..50]of longint;
var ans1,ans:real;
//function max(aa,bb:longint):longint;
//begin
//if abs(aa mod 360 -180)>abs(bb mod 360 -180) then
//exit(bb mod 360)
//else exit(aa mod 360);
//end;
begin
readln(n);
for i:=1 to n do
begin
read(c);
if c='f'then
begin
while c<>' ' do read(c);
readln(x);
a:=a+x;
end
else if c='b' then
begin
while c<>' ' do read(c);
readln(x);
b:=b+x;
end
else if c='l' then
begin
while c<>' 'do read(c);
readln(x);
if x>=360 then x:=x-360;
inc(num);
jd[num]:=x;
end
else if c='r' then
begin
while c<>' ' do read(c);
readln(x);
if x>=360 then x:=x-360;
x:=360-x;
inc(num);
jd[num]:=x;
end;
end;

//for i:=1 to num do
//for j:=num downto 1 do
//f[j]:=max(f[j],f[j-1]+jd[i]);

//ans1:=f[num];
fillchar(f,sizeof(f),false);
f[0]:=true;
for i:=1 to num do
begin
g:=f;
for j:=0 to 360 do
if f[j] then
g[(j+jd[i])mod 360]:=true;
f:=g;
end;
i:=180;
j:=180;
while true do
begin
if f[i] then
begin
ans1:=i;
break;
end;
if f[j] then
begin
ans1:=j;
break;
end;
inc(i);
dec(j);
end;

ans:=sqr(a)+sqr(b)-2*a*b*cos(ans1*pi/180);
ans:=sqrt(ans);
writeln(ans:0:6);
end.

```


---

## 作者：Disillusionment (赞：4)

这题虽然标的蓝题但在仔细思考后我们发现它还是很水的

首先，在前后走的路程一定的情况下，我们只需要让转的度数尽量接近180°就可以了，而用不上的转向我们只需要再走完后转完即可，并不影响走的距离。

其次，怎么使转的度数接近180°呢？我们轻松发现它是一个01背包，于是算出转了多少度后一个简单的数学计算就搞定了。另外，sin等三角函数在c++中都是弧度制，

[不知道什么是弧度的小伙伴们戳这里](https://baike.so.com/doc/5548384-5763492.html)

所以，我们就轻松搞定了这道题

其他细节见代码

```cpp
#include<bits/stdc++.h>

using namespace std;

int n , front , back , cir[51] , p = 1e3;//p是能转出的最接近180的角度
bool f[51][361]; //f[i][j]表示用前i个转向能否转出j度
const double PI = 3.1415926535;

int main()
{
    scanf("%d" , &n);
    for(int i = 1;i <= n;i ++)
    {
        char s[11];
        int x;
        cin >> s;
        scanf("%d" , &x);
        if(s[0] == 'f') front += x;
        else if(s[0] == 'b') back += x;
        else if(s[0] == 'l') cir[++ cir[0]] = -x;
        else cir[++ cir[0]] = x;
    }
    //front代表往前走了多远，back表示往后退了多远，cir是记录转动度数的数组
    
    f[0][0] = 1;
    for(int i = 1;i <= cir[0];i ++)
        for(int j = 0;j < 360;j ++)
            if(f[i - 1][j] == 1)
                f[i][j] = 1 , f[i][(j + cir[i] + 360 * 10) % 360] = 1;
    //核心的01背包  
    
    for(int i = 0;i < 360;i ++)
        if(f[cir[0]][i] == 1)
            p=min(p , abs(i - 180));
    double ans = sqrt(front * front + back * back + 2 * back * front * cos(p * PI / 180));
    printf("%.6f\n",ans);
    //一点数学计算
    
    return 0;
}
  
```

---

## 作者：Isonan (赞：3)

原题传送门[>Here<](https://www.luogu.org/problemnew/show/P2625)

**据说这题正解是DP。。。然而本菜鸡完全不会，只能用模拟退火+O2**~~火一火~~**水一水了。。。**

这题用模拟退火还是蛮容易过的，只要注意判断的时候卡卡常就行了：

1.判断时不要取模，而是暴力判断；

2.预处理每个角度的sin值和cos值。

这样这题就可以火过了！

祝大家火题快乐！！

代码：

```cpp
// luogu-judger-enable-o2
#include <cstdio>
#include <cstdlib> 
#include <cstring>
#include <cmath>

int num[51],ord[51][2],n;
double ans,old,cosine[400],sine[400];
double check(){
    double ans,x=0.,y=0.;
    int direction=0;
    for(int i=1;i<=n;i++){
        if(ord[num[i]][0]<=1){
            (direction+=ord[num[i]][1]);
            if(direction>=360)direction-=360;
        }
        else if(ord[num[i]][0]==2)x+=cosine[direction]*(double)ord[num[i]][1],
                                  y+=  sine[direction]*(double)ord[num[i]][1];
        else					  x-=cosine[direction]*(double)ord[num[i]][1],
                                  y-=  sine[direction]*(double)ord[num[i]][1];
    }
    return sqrt(x*x+y*y);
}
void swap(int &a,int &b){int T=a;a=b;b=T;}
void sa(){
    int newx,newy;
    double cnt;
    for(register double T=2000.;T>=1e-9;T*=0.99999){
        newx=rand()%n+1;
        newy=rand()%n+1;
        swap(num[newx],num[newy]);
        if(newx==newy)continue;
        cnt=check();
        if(cnt>old){
            if(cnt>ans)ans=cnt;
            old=cnt;
        }
        else if(exp((cnt-old)/T)>(double)(rand()%1000000)/1000000.0)old=cnt;
        else swap(num[newx],num[newy]);
    }
}
char str[20];
int main(){
    srand(19260817);
    scanf("%d",&n);
    for(int i=0;i<360;i++)cosine[i]=cos((((double)i)/180.0)*3.1415926535),sine[i]=sin((((double)i)/180.0)*3.1415926535);
    for(int i=1;i<=n;i++){
        scanf("%s%d",str,&ord[i][1]);
        if(str[0]=='l')ord[i][0]=0,ord[i][1]%=360;
        else if(str[0]=='r')ord[i][0]=1,ord[i][1]=(720-ord[i][1])%360;
        else if(str[0]=='f')ord[i][0]=2;
        else ord[i][0]=3;
        num[i]=i;
    }
    old=ans=check();
    sa();
    sa();
    printf("%.6lf\n",ans);
}
```

---

## 作者：莫问 (赞：1)

P党又出现

 对于 30%的数据，可以直接进行暴力搜索，枚举所有可能的排列方式，取得其中离开最远的指令方案。时间复杂度 O(n!)

 对于 100%的数据，
1. 我们可以注意到在最开始和最结束的地方进行转弯是没有影响的，意味着我们可以只选择其中的一部分转弯指令。并且我们不会选择在前进一段距离之后转弯再前进一段距离，或是后退一段距离后转弯再后退——因为这必然使得距离原点距离不优（注意到原点角度无关）。同理先前进或是先后退也是对称的。
2. 问题可以直接简化为：前进所有能前进的距离，之后转一个可选的角度，然后后退所有能后退的距离。对于选择角度的旋转，我们可以通过类似动态规划的方法转移出所有可能转动的总角度，最多有 360 种，利用余弦定理计算出第三边长。
3. (c2 = a2 + b2 - 2abcos(angle))

~~偷懒的做法：可以在这 360 种中枚举，选择一个最优解即可。
这便是这道题的满分算法。时间复杂度 O(n)~~

~~拒绝抄袭，小小修改~~

```pascal
var qian,hou,jiao:array[0..51]of longint;
    sumqian,sumhou,sumjiao:longint;
    i,j,k,n,m:longint;
    g,gg:array[0..360]of boolean;
    maxx,ma,ans:real;
    ch:char;
function max(x,y:real):real;
begin if x>y then exit(x);exit(y);end;
procedure init;//偷懒的读入，哈哈哈
begin
  readln(n);
  for i:=1 to n do
    begin
      read(ch);
      case ch of
      'f':begin
            for j:=1 to 7 do read(ch);
            inc(qian[0]);
            readln(qian[qian[0]]);
            sumqian:=sumqian+qian[qian[0]];
          end;
      'b':begin
            for j:=1 to 8 do read(ch);
            inc(hou[0]);
            readln(hou[hou[0]]);
            sumhou:=sumhou+hou[hou[0]];
          end;
      'l':begin
            for j:=1 to 4 do read(ch);
            inc(jiao[0]);
            readln(jiao[jiao[0]]);
          end;
      'r':begin
            for j:=1 to 5 do read(ch);
            inc(jiao[0]);
            readln(jiao[jiao[0]]);
            jiao[jiao[0]]:=-jiao[jiao[0]];
          end;
      end;
    end;
end;
begin
  fillchar(qian,sizeof(qian),0);
  fillchar(hou,sizeof(hou),0);
  fillchar(g,sizeof(g),0);
  fillchar(gg,sizeof(gg),0);  
  sumqian:=0;sumhou:=0;
  init;                    
  g[0]:=true;gg[0]:=true;
  for i:=1 to jiao[0] do
  begin
    for j:=0 to 360-1 do
      if g[j] then
        gg[(j+360+jiao[i]) mod 360]:=true;
    for j:=0 to 359 do
      g[j]:=gg[j];
    end;
  for i:=0 to 360 do//当初找到最近的就退出可是、。。。发现布星。。。。
  if g[i] then
  begin
  maxx:=sqrt(sqr(sumqian)+sqr(sumhou)-2*sumqian*sumhou*cos(i*pi));//神奇的pi
  if ans<maxx then ans:=maxx;
  end;
  writeln(ans:0:6);
end.

```

---

## 作者：不存在之人 (赞：0)

### 把正着走的和倒着走的累加，通过一个背包，算出角度距180。（此圈在右上方）最远的。通过余弦定理计算。

### Code:
```cpp
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
const double pi=3.1415926535;
int n,sf,sb,p,ang[55];
double ans;
bool f[105][405];
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        int x;
        char ch[11];
        scanf("%s%d",ch,&x);
        if(ch[0]=='f')
            sf+=x;
        if(ch[0]=='b')
            sb+=x;
        if(ch[0]=='r')
            ang[++ang[0]]=x;
        if(ch[0]=='l')
            ang[++ang[0]]=-x;
    }
    f[0][0]=1;
    for(int i=1;i<=ang[0];i++)
        for(int j=0;j<360;j++)
            if(f[i-1][j])
                f[i][j]=1,f[i][(j+ang[i]+720)%360]=1;
    p=180;
    for(int i=0;i<360;i++)
        if(f[ang[0]][i])
            p=min(p,abs(i-180));
    ans=sqrt(sf*sf+sb*sb+2*sb*sf*cos(p*pi/180));
    printf("%.6f\n",ans);
    return 0;
}
```

---

## 作者：Travis (赞：0)

简单看下代码应该都会懂，其实就是一个特殊一点的背包——一开始写01背包和最小剩余容量背包的都只能得到30分——因为没考虑大于180度的加情况

最优情况贪心：先把forward走完，然后找个最接近180度角的转回来，然后把backward走完，根据三角形两边之和大于第三边这样是最优的，然后左转存正，右转存负，跑染色过的背包就好啦——注意余弦定理中编译器使用弧度制要先把角度转成弧度，还有pi设定的时候记得小数点后多几位保留精度，要不会WA

```cpp

#include <iostream>
#include <vector>
#include <cmath>
#include <string>
#include <iomanip>
using namespace std;
const double pi=3.1415926535;
int n,i,j,num,F,B,p,R[100],cnt=0,tmp,f[100][360];
double ans;
string ch;
int main()
{
    cin >> n;
    for (i=1;i<=n;i++)
    {
        cin >> ch >> num;
        if (ch=="left") R[++cnt]=num;
        if (ch=="right") R[++cnt]=-num;
        if (ch=="forward") F+=num;
        if (ch=="backward") B+=num;
    }
    f[0][0]=1;
    for (i=1;i<=cnt;i++)
        for (j=0;j<360;j++)
            if (f[i-1][j])
            {
                f[i][j]=1;
                tmp=(j+R[i]+720) % 360;
                f[i][tmp]=1;
            }
    p=180;
    for (i=0;i<360;i++) if (f[cnt][i]&&abs(i-180)<p) p=abs(i-180);
    ans=sqrt(pow((double)F+cos((double)p/180*pi)*(double)B,2)
            +pow(sin((double)p/180*pi)*(double)B,2));
    cout << fixed << setprecision(6) << ans;
    return 0;
}

```

---

## 作者：Alviss_lky (赞：0)

这道题的思路比较复杂，但是我把他整理了一下，得到以下结果：
+ 1.通过计算的方法累加所有foward与backward
+ 2.不难发现，方法是：先走foward步再转，尽可能接近180度，再走backward步。
+ 3.其余的部分可以走到了之后再原地旋转。

这个思路可以通过三角形两边之和大于第三边来证明。

同样，离开原点的距离可以通过余弦定理来计算，公式为：

``
sqrt(a*a+b*b-2*a*b*cos(PI*deg/180))
``

其中deg为dp得到的角度值，a与b分别为前进与后退的距离。

那么，问题来了：怎么计算旋转角度呢？

由于角度的绝对值不会超过360*50=18000，

设角度为y，所有left变为y%360，right变为(720-y)%360

注意把cnt--否则后面多出来一位

之后用布尔dp把每个可以得到的角度计算出来

然后逐个枚举所有的角度%360与180的差

然后把差数组sort一下

然后角度等于差数组的第18000位（因为已经进行用180减的预处理）

最后用一下正弦定理输出就可以了

还有不要忘记控制输出6位否则会炸
```
#include<bits/stdc++.h> 
typedef long long ll;
const double PI=3.1415926535898;
using namespace std;
int cnt=1;
int m[250];
bool flag[18001];
int main()
{
    int f=0,b=0;
    int x;
    cin>>x;
    string cmd;
    int y;
    while(x--)
    {
        cin>>cmd>>y;
        if(cmd=="forward")
        f+=y;
        else if(cmd=="backward")
        b+=y;
        else
        {
            if(cmd=="left")m[cnt++]=y%360;
            else m[cnt++]=(720-y)%360;
        }
    }
    cnt--;
    int deg=10000000;
    memset(flag,0,sizeof(flag));
    flag[0]=true;
    for(int i=1;i<=cnt;i++)
    {
        for(int j=18000;j>=m[i];j--)
        {
            if(flag[j-m[i]])flag[j]=true;
        }
    }
    int cha[18001];
    for(int i=1;i<=18000;i++)
    {
        if(flag[i])
        {
            cha[i]=abs(180-(i%360));
        }
        else
        {
            cha[i]=180;
        }
        cha[i]=180-cha[i];
    }
    sort(cha+1,cha+18000+1);
    deg=cha[18000];
    int a=f;
//	cout<<deg<<endl;
    cout<<fixed<<setprecision(6)<<(sqrt(a*a+b*b-2*a*b*cos(PI*deg/180)))<<endl;
}
```
# [AC记录](https://www.luogu.org/recordnew/show/19645652)

---


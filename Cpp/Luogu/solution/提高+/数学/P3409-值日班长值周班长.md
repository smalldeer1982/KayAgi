# 值日班长值周班长

## 题目描述

话说，在一个学期共有 $n$ 个值日班长，其中 A 是第 $m$ 个值日班长，共有 $p$ 个值周班长，B是第 $q$ 个值周班长。假设不考虑假期及其他额外上课休假，以及重排值日班长值周班长，即永远每周上 $5$ 天休息 $2$ 天，且这个学期永远不会结束。请问这学期第几天会第一次遇上 $A$ 是值日班长且 $B$ 是值周班长，若永远不会输出 `Orz mgh!!!`。


## 说明/提示

测试点    数据组数    N    P    N

```cpp
1    10000    <=100    <=100    5的倍数
2    100    <=1000    <=1000    
3    1000    <=10000    <=10000    
4    1000    <=100000    <=100000    5的倍数
5    1000    <=100000    <=100000    
6    1000    <=1000000    <=1000000    
7    1000    <=10000000    <=10000000    
8    10000    <=10000000    <=10000000    5的倍数
9    1000    <=10亿    <=10亿    5的倍数
10    1000    <=10亿    <=10亿    

```

## 样例 #1

### 输入

```
20 7 3 3
30 7 4 3```

### 输出

```
27
Orz mgh!!!```

# 题解

## 作者：CodyTheWolf (赞：5)

来自攻略组成员的首发题解：

------------
### [开头小广告：自己做的一个模板库OwO](https://www.luogu.org/blog/29354/Templet)

------------
## 算法考察：exGCD的最小正整数解

## 思路：

相信很多同学读完题都会列出这样的同余方程（或许只有本蒟蒻这样干qwq）：
## $\frac{nx+m}{7}\equiv q (mod p)$
（x未知）

首先，这个**题目描述有坑**。实际上一周的**有效天数只有5天**。。。（而不是7）

其次，$q$和$m$的位置应该是$q-1$和$m-1$，因为值日和值周的同学都是**从第1个开始**的，而不是第0个。

再者，这里面**有个整除**，在同余方程里面太难搞了，我们考虑换个表达方式：

## $nx+(m-1)\equiv py+(q-1)+i(mod 5)$
（x，y未知）

考虑到在值周同学的任期范围内，轮到值日的同学就行，但方程左边如果不加i的话，那么**右边代表的只是某周的第一天**，但是其他天数应该也要考虑上，因此加一个i，i的取值应该是$[0,4]$，

那我们只需要知道一组**最小非负整数解**x，y，$nx+(m-1)$（这里有坑注意看到题解最后）就是我们的答案啦。

诶？貌似就是我们的exGCD板子！但是还有一个未知数i怎么搞呢？范围太小啦，**枚举就好**，于是我们化式子：

(为了方便，让$m$和$q$一开始就减去1）

$nx-5py=5q-m+i$

但是普通的exGCD x，y是可负的，我们怎么把它转化为最小非负整数呢？（会的dalao可以跳过分割线内的内容了qwq）

------------
## 关于exGCD的最小正整数解法：

对于方程：
### $ax+by=c$

$x'=x+tb$，$y'=y-ta$也是一组解：

因为：

### $ax'+by'=c$
### $a(x+tb)+b(y-ta)=c$
### $ax+tab+by-tab=c$
### $ax+by=c$

他们是等价的。

所以我们考虑求得一个**最大的$t$**使得x，y都是非负整数解就好。

这里的$t=b/gcd(a,b)$，留给读者自行思考（而不是直接记结论）。

------------

## 本题另外的坑点：
1.我们最终的答案并不是$nx+m$，而是$nx+m+1$，不要忘了我们的$m$是-1过的，因为实际上开始**不能按照第0天算**，而应该按照第1天算。

2.**卡精度**：某些变量需要__int128才能通过（建议自己思考一下到底是哪些）

3.**$c$可能为0**，此时我们需要特判，答案就是$m$（m没有被-1过的时候），想想为什么？

## 个人推荐难度（一次AC）：省选/NOI-
理由：exGCD+卡精度+思维+不低的细节复杂度。

## CODE：
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

typedef long long LL;
typedef long long int128;

LL n, m, p, q;

inline void Write(__int128 x)
{
    if (x > 9)
        Write(x / 10);
    putchar(x % 10 + '0');

    return;
}

inline __int128 exGCD(__int128 a, __int128 b, __int128 &x, __int128 &y)
{
    if (!b)
        return x = 1, y = 0, a;

    __int128 gcd = exGCD(b, a%b, x, y), tx = x;
    x = y, y = tx - (a / b) * y;

    return gcd;
}

inline __int128 Max(__int128 x, __int128 y)
{
    return x > y ? x : y;
}

inline __int128 Min(__int128 x, __int128 y)
{
    return x < y ? x : y;
}

signed main(void)
{
    while (scanf("%lld %lld %lld %lld", &n, &m, &p, &q) != EOF)
    {
        m--, q--;
        __int128 ans = -1;

        for (int i = 0; i < 5; i++)
        {
            __int128 a = n, b = 5 * p, c = 5 * q + i - m, x, y;

            if (c == 0)
            {
                ans = ans == -1 ? m : Min(ans, m);
                continue;
            }

            __int128 gcd = exGCD(a, b, x, y);
            if (c % gcd)
                continue;

            x *= c / gcd;
            __int128 t = b / gcd;
            x = (x % t + t) % t;

            __int128 temp = n * x + m;

            ans = ans == -1 ? temp : Min(ans, temp);
        }

        if (ans == -1)
            puts("Orz mgh!!!");
        else
            Write(ans + 1), putchar('\n');
    }

    return 0;
}
```



---

## 作者：hovny (赞：3)

## [题面](https://www.luogu.com.cn/problem/P3409)

## 解题思路

数学与 $Ex\_gcd$

### 分析

根据题意，我们可以列出如下的方程组，设 $w$ 为周数，$bit$ 为离这周的周五还有几天
$$
(5w-bit)\%n=m\ \ \ \ \ \ (1)
$$

$$
w\%p=q\ \ \ \ \ \ \ (2)
$$
先将 $(2)$ 转换形式得：
$$
w=px+q\ \ \ \ \ \ (3)
$$
将 $(3)$ 代入 $(1)$ 得：
$$
(5px+5q-bit)\%n=m
$$

$$
5px+5q-bit=ny+m
$$

整理得：
$$
5px+ny=m-5q+bit
$$
令：
$$
a=5p,b=n,c=m-5q+bit
$$

原式就可以变成：
$$
ax+by=c
$$
这样的话，$x$ 的值就可以通过 $Ex\_gcd$ 得出一个最小正整数解，那么也就可以得出 $w$ 的值，从而得出最小满足条件的天数

最后通过枚举 $bit$ 来检验每个解即可

### Warning

注意范围以及输出格式，每周只有五天，不要算周末的时间

## Code

```cpp
#include<bits/stdc++.h>
#define rgt register
#define rint rgt int
#define LL long long
#define rll rgt LL
#define inf 0x7f7f7f7f
using namespace std;
template<class K>inline bool cmax(K&a,const K&b){return(a<b)?a=b,1:0;}
template<class K>inline bool cmin(K&a,const K&b){return(a>b)?a=b,1:0;}
inline int read() {
	rint s=0;
	rgt char c=getchar();
	while(!isdigit(c)) c=getchar();
	while(isdigit(c)) s=(s<<1)+(s<<3)+c-'0',c=getchar();
	return s;
}
LL n,m,p,q,a,b,c,d,x,y,ans,res;
inline LL Ex_gcd(rll a,rll b,rll &x,rll &y) {
	if(!b){x=1,y=0;return a;}
	rll d=Ex_gcd(b,a%b,y,x);
	y-=a/b*x;return d;
}
int main()
{
	rint i;
	while(~scanf("%lld%lld%lld%lld",&n,&m,&p,&q)) {
		a=5*p,b=n,c=m-5*q,ans=-1;//不想赋inf
		d=Ex_gcd(a,b,x,y),a/=d,b/=d;
		for(i=0;i<5;i++) {//枚举
			if((c+i)%d) continue;//有没有解
			res=((x*(c+i)/d%b)+b)%b;//得出最小正整数x
			res=res*5*p+5*q-i;//得出天数
			if(~ans) cmin(ans,res);
			else ans=res;
		}
		if(~ans) printf("%lld\n",ans);
		else printf("Orz mgh!!!\n");
	}
	return 0;
}
```



---

## 作者：OldVagrant (赞：2)

## 题意
本题的第一个要点就是对题意的转换。   

读题之后，我们可以发现，值日班长每 $n$ 天一大轮，每天换一次，而值周班长是每 $p$ 周一大轮，每周换一次。`A` 是第 $m$ 个值日班长，`B` 是第 $q$ 个值周班长。 

题目问的是，第一次遇到 `B` 是值周班长且 `A` 是当天的值日班长是在**这个学期**的第几天。结合第一组样例，不难发现**这个学期**的天数不算周末。    

以及，`B` 的任期是那一周的周一到周五，所以只要在五天里有任意一天能碰到 `A` 当值日班长即可。   

于是题意就转化为：   
求方程组 
$\begin{cases}
x=m\pmod n \\
x=p\times5-k\pmod {q\times5} ,k\in[0,4]\end{cases}$ 的最小正整数解，且不保证 $\gcd(n,q\times5)=1$。 
## Solution 
模数不一定互质，普通 `CRT` 无法使用，可以考虑用 `exCRT`。  
~~不会扩展中国剩余定理也没有关系，我们现推一下，这个并不算很难推~~     

先来讨论一下对于一般的两个同余方程如何利用 `exgcd` 合并成一组：
$\begin{cases}
x=a_1\pmod {p_1} \\
x=a_2\pmod {p_2} \end{cases}$    
该方程组可以转化成：
$k_1p_1+a_1=k_2p_2+a_2$  
再变一下得到：
$k_1p_1-k_2p_2=a_2-a_1$   
（这里默认 $a_2>a_1$，不满足就交换上下两个方程即可）。   

由裴蜀定理得：当且仅当 $\gcd(p_1,p_2)|(a_2-a_1)$ 时有解。然后来看如何求出一组合法的 $k_1,k_2$。   

令 $d=\gcd(p_1,p_2),m_1=\frac{p_1}{d},m_2=\frac{p_2}{d}$  
则原方程转化为：$k_1m_1-k_2m_2=\frac{{a_2}-{a_1}}{d}$  
再用一次 `exgcd` 得到 $k_1m_1+k_2m_2=\frac{{a_2}-{a_1}}{d}$ 的一组特解 $(s_1,s_2)$  
再带回原式得到： $x=s_1+k_1m_1$  
整个方程组的最小正整数解即为 $x\bmod\operatorname{lcm}(p_1,p_2)$（如果有更大的解一定是通过这个解再加上 $\operatorname{lcm}(p_1,p_2)$ 的正整数倍得到的）。   
~~我的讲解可能非常的令你迷惑，建议看一下[这位大佬写的](https://www.cnblogs.com/Miracevin/p/9254795.html)。~~    

让我们回到原题上来，既然已经会求解上面那组同余方程了，那么就直接暴力枚举 $k$ 的值，然后分别代入原方程求最小解即可。  

最后说几点细节：   
1. 中间运用 `exgcd` 求解时的结果再乘上 $\frac{{a_2}-{a_1}}{d}$ 可能会炸 `longlong`，要使用 `int128` 类型去存储。
2. 如果求得的最小解为 $0$ 要输出 $\operatorname{lcm}(p_1,p_2)$。（这学期是从第 $1$ 天开始的）。
3. 最小值要初始化成 $2^{62}$ 以上，因为有一组数据的答案就是这个量级的.
4. 多测，记得在每组数据开始前清空数组并给变量赋值。     

就可以愉快地通过这道~~水~~题。
## Code
```c
#include <bits/stdc++.h>
using namespace std;
#define i128 __int128
#define ll long long
#define gc getchar
#define pc(x) putchar(x)
i128 x,y;//exgcd用的，可能会炸longlong，要开int128
ll tmp,n,mi,m,p,q,a[6],inf=(1ll<<62);//inf一定要开到这个量级，2^60都不行。
void exgcd(ll a,ll b,i128 &x,i128 &y){
	if(!b){
		x=1,y=0;
		return;
	}exgcd(b,a%b,y,x),y-=a/b*x;
}
ll excrt(ll a,ll b,ll c,ll d){
	if(b>d) swap(b,d),swap(a,c);//上文提到过的交换
	ll e=d-b,f=__gcd(a,c);
	if(e%f) return -1;//如果相减后不能整除a和c的最大公约数则无解
	ll g=a/f*c,h=e/f,j=a/f,k=c/f;
	exgcd(j,k,x,y),x=(x%k+k)%k,x=x*h%k,x=x*a+b;//用exgcd求一组特解，然后求出最小解
	return x;
}
ll read(){
    ll x=0;
    char ch=gc();
    while(ch>57||ch<48){
        if(ch==EOF) exit(0);
        ch=gc();
    }while(ch>47&&ch<58) x=x*10+ch-48,ch=gc();
    return x;
}
void write(ll x){
    if(x>9) write(x/10);
    pc(x%10+48);
}
signed main(){
    n=read(),m=read(),p=read(),q=read();
	while(1){
		p*=5,q*=5;//这里直接乘5之后方便下面计算
		mi=inf,a[1]=0;//这里记得赋初值和清空a[1]里的值（因为下面可能不会改变a[1]的值但是用到了a[1]）
		if(p==q) for(int i=2;i<6;i++) a[i]=q-6+i;//暴力枚举每个可能的p*5+k，当p=q的时候会有一个对p取模后是0。
		else for(int i=0;i<5;i++) a[5-i]=q-i;//同上
		for(int i=1;i<=5;i++){
			tmp=excrt(n,m,p,a[i]);
			if(tmp==-1) continue;
			if(tmp<mi) mi=tmp;
		}if(mi==0) mi=n/__gcd(n,p)*p;//特判
		mi==inf?puts("Orz mgh!!!"):(write(mi),pc('\n'));
		n=read(),m=read(),p=read(),q=read();
	}return 0;
}
```




---

## 作者：_Fontainebleau_ (赞：0)

### 题意

看题。

### 做法

我们设相遇这一周是第 $w$ 周，且距离该周周五还有 $k\in[0,4]$ 天。那么我们可以得到：

$\begin{cases}5w-k\equiv{m}\pmod{n}&(1)\\w\equiv{q}\pmod{p} &(2)\end{cases}$

由 $(2)$ 得：$w=xp+q$，带入 $(1)$ 得：

$5px+5q-k\equiv{m}\pmod{n}\\\text{也就是：}5px+ny=m+k-5q$

这就是一个 exgcd，从 $0$ 到 $4$ 枚举 $k$ 的话，$5p,n,m+k-5q$ 都是定值。

根据 Bezout 定理：若 $a,b\in\mathbb Z$，则存在 $x,y$ 满足 $ax+by=\gcd(a,b)$。我们先求出 $d=\gcd(5p,n)$，再看 $d$ 是否整除 $m+k-5q$。

但是有一个问题，上文 exgcd 求出来的 $x,y$ 可能是负的。怎么办？

要知道，Bezout 定理是可以调整的。所谓调整，即：$ax+by=a(x+tb)+b(y-ta)$，所以你可以看作 $x$ 或 $y$ 是 $\bmod{b\text{ or }a}$ 的。我们只要将求出来的 $x$ 调整进 $[0,b-1]$ 就可以了。然后这个 $y$ 自然就小于 $0$ 了。（若 $y>0$ 是显然不对的，自己往上面代一代就知道了）

### 代码

跟 $\text{\color{black}h\color{red}ovny}$ 大同小异，不放了。


---


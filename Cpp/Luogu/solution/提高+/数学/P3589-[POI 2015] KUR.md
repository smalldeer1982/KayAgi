# [POI 2015] KUR

## 题目描述

给定 $n,a,b,p$，其中 $n,a$ 互质。 

定义一个长度为 $n$ 的 01 串 $c_0c_1\cdots c_{n-1}$，其中 $c_i$ 等于 0 当且仅当 $(ai+b) \bmod n < p$。 

给定一个长为 $m$ 的小 01 串，求出小串在大串中出现了几次。 

## 说明/提示

**【样例解释】**

![](https://cdn.luogu.com.cn/upload/image_hosting/qd6imu53.png)

----

原题名称：Kurs szybkiego czytania 

## 样例 #1

### 输入

```
9 5 6 4 3
101
```

### 输出

```
3
```

# 题解

## 作者：Yajnun (赞：14)

若小串$a$的首位在$c\left [ x \right ]$位出现 ，则
$a\left [  i\right ]$在$c\left [ x+i \right ]$位出现。若两者相同，$a(i+x)+b=a*x+a*i+b$，令$t=a*i+b$，则在模$n$意义下

若$a\left [ i \right ]=0$，$-t\leqslant ax\leqslant p-t-1$，令$l=-t,r=p-t-1 (mod~   n)$

若$a\left [ i \right ]=1$，$p-t\leqslant ax\leqslant -t-1$，令$l=p-t,r=-t-1 (mod~   n)$

若$l\leqslant r$，$a*x\in S=[l,r]$，否则$a*x\in S=[0,l]\cup [r,n-1]$

通过枚举$i$可得到这样一组约束条件，通过对其取交集可求出$a*x$的范围。对前者可直接求出，对后者不如转换成其补集的并集的补集。因为$a$与$n$互质，所以在x可以任意取的情况下，$a*x$与$[0,n-1]$是一一对应的关系，$\left |S  \right |$即为$a*x$的所有取值。

因为实际上$x$不能完全取完$1$到$n$的值，所以对于应再枚举有哪些$x\in[n-m+1,n-1],a*x\in S$，用总数减去这个值即为答案。




---

## 作者：Alex_Wei (赞：10)

> [P3589 [POI2015]KUR](https://www.luogu.com.cn/problem/P3589)
>
> [POI 合集](https://www.cnblogs.com/alex-wei/p/POI.html)。

**求出现次数的题目可转化为求可能的出现位置数量**，本题就运用了这一思想。我们定义小串 $t$ 在 $c$ 中的一次出现位置为 $q\ (q\in [-1,n-m-1])$ 表示 $\forall i\in[1,m],t_i=c_{q+i}$。不难发现 $>n-m$ 的 $q$ 是不合法的，因为它们超出了范围。 

枚举每个字符 $t_i$。若 $t_i=\texttt 0$ 说明 $(a(q+i)+b)\mod n\in [0,p-1]$。这是一个不等式形式的限制，$t_i=\texttt 1$ 同理。尽管在这样一个限制下 $q$ 的解集可能不连续，但合法的 $aq$ 范围**一定连续**（在 $\bmod n$ 意义下），因为 $aq+(ai+b)\bmod n$ 是一段区间，而 $ai+b$ 是常数。

同时，由于题目保证了 $a\perp n$，所以一个 $aq$ 解**唯一对应**一个 $q\in [-1,n-2]$ 的解，所以我们只需求出合法的 $aq$ 个数，但要去掉不合法的 $q$。

对于 $m$ 个限制我们可以得到 $m$ 个不等式，它的解集是在 $\bmod n$ 意义下的一段区间，而所有解集的交除去所有不合法的 $q\ (q\in [n-m,n-2])$ 所得到的 $aq$ 后集合的大小即为所求。

注意求解集交不能直接对左端点取 $\max$，对右端点取 $\min$，因为我们是在 $\bmod n$ 意义下求交（类似于环上区间求交），所以一个区间对应到 $[0,n-1]$ 上可能会形成两段区间，这是无法处理的，只能通过离散化 + 差分求覆盖次数解决。

除掉不合法的 $aq$：将所有这样的 $aq$ 拎出来排个序，在（所有限制差分掉之后）求前缀和（后缀和也行，两种方法不同点在于如何用一个离散化的值 $v_i$ 表示区间）的过程中用双指针扫一遍，表示落在当前离散化的值所表示区间的 $aq$ 范围（从而求得数量），就可以在计算答案时去掉这些数的贡献了。时间复杂度线性对数。


```cpp
const int N = 1e6 + 5;

int n, a, b, p, m, cnt, d[N << 1];
int ans, l[N], r[N], pt[N], ss[N << 1];
int main(){
	cin >> n >> a >> b >> p >> m; char s = gc;
	while(!isdigit(s)) s = gc;
	for(int i = 1; i <= m; i++) {
		int del = (1ll * i * a + b) % n;
		if(s == '1') l[i] = p - del - 1, r[i] = n - 1 - del, l[i] < 0 && (l[i] += n);
		else l[i] = n - del - 1, r[i] = p - 1 - del, r[i] < 0 && (r[i] += n);
		d[++cnt] = l[i], d[++cnt] = r[i];
		if(i < m) s = gc;
	}
	for(int i = n - m + 1; i <= n - 1; i++) pt[n - i] = 1ll * a * i % n;
	sort(d + 1, d + cnt + 1), sort(pt + 1, pt + m);
	cnt = unique(d + 1, d + cnt + 1) - d - 1;
	if(d[cnt] != n - 1) d[++cnt] = n - 1;
	for(int i = 1; i <= m; i++) {
		ss[lower_bound(d + 1, d + cnt + 1, l[i]) - d]--;
		ss[lower_bound(d + 1, d + cnt + 1, r[i]) - d]++;
		if(l[i] > r[i]) ss[cnt]++;
	} d[0] = -1;
	for(int i = cnt, r = m - 1; i; i--) {
		ss[i] += ss[i + 1];
		int l = r;
		while(l && pt[l] > d[i - 1]) l--;
		if(ss[i] == m) ans += d[i] - d[i - 1] - r + l;
		r = l;
	} cout << ans << endl;
	return 0;
}
```

---

## 作者：Alex_Eon (赞：8)

### Change log
- 2023.9.22 修改少量 LaTeX 的使用。

#### [$\color{red}博客内食用效果更佳（点我）$](https://www.luogu.com.cn/blog/Ksy/solution-p3589)

### 复杂度：$O(n\log n)$
### 完整思路
纯纯的思维好题。考虑对所求答案的转化。

设小串为 $t$，其出现的起始位置为 $q+1$（是众多出现位置的其中一个），即使得 $c_{q+i}=t_i(1\le i\le m)$，显然有对于 $q>n-m$ 是不合法的。

我们将题意转化为求合法 $q$ 的数量，考虑枚举每一个 $t_i$。

当 $t_i=0$ 时，有 $0\le\left(a(q+i)+b\right)\ \mathrm{mod}\ n<p$。  
当 $t_i=1$ 时，有 $p\le\left(a(q+i)+b\right)\ \mathrm{mod}\ n<n$。

接下来以 $t_i=0$ 为例，有 $0\le\left(aq+ai+b\right)\ \mathrm{mod}\ n<p$，其中 $ai+b$ 可以看做常数，对于此不等式组可以解出 $aq$ 的范围，是**连续的**一或两个区间（因为 $\mathrm{mod}\ n$ 后求出的区间可看做环上一段区间，可能是 $[0,x],[y,n-1]$ 的形式）。

于是我们得到了 $m$ 个不等式限制 $aq$ 的范围（在 $\mathrm{mod}\ n$ 意义下），题目中给出了 $a\perp n$ 的条件，所以**一个 $aq$ 也只对应一个 $q$**。所以我们求所有满足不等式限制的 $aq$ 个数减去不合法 $q$ 的个数即可。

考虑到值域很大，所以把每个 $l,r$ 离散化，差分地对于每个不等式解集区间加，最后前缀和还原，值等于 $m$ 的位置就是满足不等式的 $aq$。至于不合法解，我们考虑预处理 $[n-m+1,n-1]$ 的不合法 $q$ 对应的 $aq$，在统计 $aq$ 时，减去在其中的不合法值，此操作双指针扫描即可。

### 代码实现需要注意的地方：

- 在差分过程中注意 $l>r$ 的情况，这就是上文所说的两个区间的解集。
- 求 $l,r$ 的时候进行减法可能出现负数，要加上 $n$ 后再对其取模。

### 参考代码：
```cpp
#include<bits/stdc++.h>
#define LL long long
#define UN unsigned
using namespace std;
//--------------------//
const int N=1e6+5,N2=2e6+5;

int n,a,b,p,m,s[N];
char str[N];
int tcnt,sum[N2],de[N];
LL tp[N2];
LL l[N],r[N];
//--------------------//
int main()
{
    scanf("%d%d%d%d%d%s",&n,&a,&b,&p,&m,str+1);
    for(int i=1;i<=m;i++)
    {
        s[i]=str[i]-'0';
        if(s[i])//求 l,r
        {
            l[i]=((p-1LL*a*(i-1)%n-b)%n+n)%n;
            r[i]=((n-1LL*a*(i-1)%n-b)%n+n)%n;
        }
        else
        {
            l[i]=((0-1LL*a*(i-1)%n-b)%n+n)%n;
            r[i]=((p-1LL*a*(i-1)%n-b)%n+n)%n;
        }
        tp[++tcnt]=l[i],tp[++tcnt]=r[i];
    }
    tp[++tcnt]=0,tp[++tcnt]=n;
    sort(tp+1,tp+tcnt+1);
    tcnt=unique(tp+1,tp+tcnt+1)-tp-1;
    for(int i=1;i<=m;i++)
    {
        l[i]=lower_bound(tp+1,tp+tcnt+1,l[i])-tp;
        r[i]=lower_bound(tp+1,tp+tcnt+1,r[i])-tp;
        sum[l[i]]++,sum[r[i]]--,sum[1]+=(l[i]>r[i]);//离散后差分
    }
    int ans=0,cnt=0;
    for(int i=2;i<=tcnt;i++)
        sum[i]+=sum[i-1];
    for(int i=n-m+1;i<n;i++)
        de[++cnt]=1LL*a*i%n;//预处理不合法解
    sort(de+1,de+cnt+1);
    for(int now=0,las,i=1;i<tcnt;i++)
    {
        las=now;
        while(now+1<=cnt&&de[now+1]<tp[i+1])//双指针扫描在符合条件 aq 中的不合法区间
            now++;
        if(sum[i]==m)
            ans+=tp[i+1]-tp[i]-(now-las);
    }
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：Zhao_daodao (赞：1)

# P3589 [POI2015] KUR

赛场上的代码复杂度是假的，之后调一下就过了。

我的做法是比较复杂的做法，更加简洁的写法可以看其他题解的。

## Description

给定 $n,a,b,p$，其中 $n,a$ 互质。 

定义一个长度为 $n$ 的 01 串 $c_0c_1\cdots c_{n-1}$，其中 $c_i$ 等于 $0$ 当且仅当 $(ai+b) \bmod n < p$。 

给定一个长为 $m$ 的小 01 串，求出小串在大串中出现了几次。

$2\leq n\leq 10^9$，$1\le p,a,b,m<n$，$1\le m\le 10^6$。

下面表述中 $mod=n$。

## Solution

马上就能发现这一题的复杂度应该是 $O(m\log m)$ 的。

下面考虑一个简化情况。令 $f(i)=(ai+b) \bmod mod$，$s_i$ 是小 01 串的第 $i$ 个数。

### 如果 $m=2$

考虑计算一共有多少个位置满足条件。

也就是有多少个 $i\in [1,m-1]$，$[f(i)\ge p]=s_i,[f(i+1)\ge p]=s_{i+1}$。

因为 $f(i+1) = (f(i) + a)\bmod mod$，所以其实只跟 $f(i)$ 的值有关。

因为 $(mod,a)=1$，所以 $i$ 和 $f(i)$ 是双射，这里不证。

于是计算有多少个 $x=f(i)$ 满足条件，最后再判断 $f(m)$ 是否满足条件，就可以了。

分类讨论，简化不等式：

- $s_i=0,s_{i+1}=0$

  1. $x<p,x+a<p$

     此时 $x\in [0,p-a-1]$。

  2. $x<p,x+a\ge mod,x+a-mod<p$

     此时 $x\in [mod-a,p-1]$。

- $s_i=0,s_{i+1}=1$

  1. $x<p,x+a<mod,x+a\ge p$

     此时 $x\in [p-a,\min(p-1,mod-a-1)]$。

  2. $x<p,x+a\ge mod,x+a-mod\ge p$

     因为 $a<mod$，所以 $x<p$ 和 $x\ge p+(mod-a)$ 矛盾。

- $s_i=1,s_{i+1}=0$

  1. $x\ge p,x+a\ge mod,x+a-mod<p$

     此时 $x\in [\max(mod-a,p),p+mod-a-1]$。

  2. $x\ge p,x+a<mod,x+a<p$

     因为 $a\ge0$，所以 $x\ge p$ 和 $x<p-a$ 矛盾。

- $s_i=1,s_{i+1}=1$

  1. $x\ge p,x+a<mod,x+a\ge p$

     此时 $x\in [p,mod-a-1]$。

  2. $x\ge p,x+a\ge mod,x+a-mod\ge p$

     此时 $x\in [p+mod-a,mod-1]$。

然后再剔除 $f(m)$ 就可以了。

### 正解

相当于有 $m-1$ 个限制，第 $j$ 个限制了 $f(i+j)$ 的范围。

因为 $f(i+1) = (f(i) + a)\bmod mod$，所以每一个限制等价于限制了 $f(i)$ 的范围。

也就是说，$f(i)$ 是每一个限制的交集。

这样算出来后，还要剔除跨过长 01 串末尾的答案。

也就是 $f(mod-m+1)$ 到 $f(mod-1)$。

只需要判断这些数是否在限制交集里，如果是就减一，就可以了。

复杂度 $O(m\log m)$。

## Code

码风不好，常数超大，不建议学习。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define Pair pair<int,int>
using namespace std;
const int MAXN=1e6+5;
int mod,a,b,p,m,s[MAXN];
int lin[MAXN*6],tmp,cnt[MAXN*6];
#define Find(x) (lower_bound(lin+1,lin+tmp+1,x)-lin)
inline int f(int i){
	return ((ll)a*i+b)%mod;
}
namespace Read{...}
Pair now[5];int tp;
Pair all[MAXN*4];int al;
Pair c[MAXN*4];int C;
Pair X[20];int x;
inline void insert(Pair it){
    int l=it.first,r=it.second;
    if(l>r)return ;
    l=max(l,0),r=min(r,mod-1);
    now[++tp]=Pair(l,r);
}
inline void fresh(){
    if(tp<=1)return ;
    if(now[1].first>now[2].first)swap(now[1],now[2]);
    if(now[1].second<now[2].first-1)return ;
    Pair p=Pair(now[1].first,max(now[1].second,now[2].second));
    now[tp=1]=p;
}
inline void turn(int k){
    x=0;
    for(int i=1;i<=tp;i++){
        auto [l,r]=now[i];
        (l+=k)%=mod,(r+=k)%=mod;
        if(l<=r)X[++x]=Pair(l,r);
        else X[++x]=Pair(l,mod-1),X[++x]=Pair(0,r);
    }
    tp=0;
    for(int i=1;i<=x;i++){
        now[++tp]=X[i];
    }
}
signed main(){
    read(mod,a,b,p,m);
	for(int i=1;i<=m;i++){
		s[i]=(getchar()-'0');
	}
	for(int i=1;i<m;i++){
        tp=0;
		if(s[i]==0&&s[i+1]==0){
			insert(Pair(0,p-a-1));
			insert(Pair(mod-a,p-1));
		}
		if(s[i]==0&&s[i+1]==1){
			insert(Pair(p-a,min(p-1,mod-a-1)));
		}
		if(s[i]==1&&s[i+1]==0){
			insert(Pair(max(mod-a,p),p+mod-a-1));
		}
		if(s[i]==1&&s[i+1]==1){
			insert(Pair(p,mod-a-1));
			insert(Pair(p+mod-a,mod-1));
		}
		fresh();
		turn((ll)(mod-a)*(i-1)%mod);
        for(int j=1;j<=tp;j++)all[++al]=now[j];
	}

    tmp=0;
    for(int i=1;i<=al;i++){int l=all[i].first,r=all[i].second;
        lin[++tmp]=l;lin[++tmp]=r+1;
    }
    sort(lin+1,lin+tmp+1);tmp=unique(lin+1,lin+tmp+1)-(lin+1);
    for(int i=1;i<=tmp;i++)cnt[i]=0;
    for(int i=1;i<=al;i++){int l=all[i].first,r=all[i].second;
        cnt[Find(l)]++,cnt[Find(r+1)]--;
    }
    for(int i=1;i<=tmp;i++)cnt[i]+=cnt[i-1];

    int siz=0;
    for(int i=1;i<=tmp;i++)if(cnt[i]==m-1){
        int now=i;
        while(now<=tmp&&cnt[now]==m-1)now++;
        c[++C]=Pair(lin[i],lin[now]-1);
        siz+=lin[now]-lin[i];i=now;
    }
	int ans=siz;
	for(int i=mod-1,siz=1;siz<=m-1;siz++,i--){
        int now=f(i);
        auto it=lower_bound(c+1,c+C+1,Pair(now+1,0));
        if(it==(c+1))continue;
        it--;int l=(*it).first,r=(*it).second;
        if(l<=now&&now<=r)ans--;
	}
    write(ans,'\n');
}
```

---

## 作者：_SeeleVollerei_ (赞：1)

感觉蛮暴力的。

考虑从子串所在位置考虑，对于某一个位置能与子串第 1 个字符匹配当且仅当它在区间 $[0,p-1]$ 或 $[p,n-1]$ 。

考虑某一个位置如果能与子串第 $i$ 个字符匹配，那么这个区间还是一样的，但是这个信息没什么用，考虑它与第 $i$ 个字符匹配的情况下，第 $1$ 个字符的区间。

这个是简单的，将第 $i$ 个字符的 $[l,r]$ 在模意义下减去 $(i-1)\times a$ 即可。

这里有个细节，区间平移后可能会出现 $l>r$ 的情况，这个时候对应的是 $[l,n-1]$ 和 $[0,r]$ 两个区间，因为模意义本身是个类似环的形式。如果 $l\le r$ 就还是区间 $[l,r]$ 。

然后对于 $i=[1,m]$ 我们都把区间对应出来，因为 $n$ 和 $a$ 互质，所以相当于让我们求有多少个值是满足的。对于每个区间考虑区间加，一个值满足条件当且仅当它的值刚好为 $m$ 。

最后注意特判一下最后的 $m-1$ 个值，因为他们可能会被统计但是实际上他们后面凑不够 $m$ 的长度，这个暴力跑一遍就好了。

对于区间加，考虑差分，然后类似离散化搞一下，最后扫一遍即可。

可能有点小卡常，加 O2 应该都能过，一开始写的 map 发现比较吃力，实际上离散化的过程可以直接全部存进数组里排序然后直接用来扫就好了，不用再去二分找，因为有排序总复杂度为 $O(m\log m)$ 。

---

## 作者：GGapa (赞：0)

### P3589 [POI2015] KUR

此题关键之处在于：**将出现次数转化为可能出现的位置数量**，剩下的内容比较套路。

不妨从特殊情况开始思考。

若 $m = 1$ 时，答案是显然的；若 $m = 2$，我们可以将满足 $s_i = t_1$ 的位置标记出来，接着再从标记过的位置中重新标记找到 $s_{i + 1} = t_2$，最终标记的数量便是我们需要的答案。对于 $m$ 更大的情况，依然可以这样处理。

现在问题转化为：给定若干个区间，求这些区间的交。由于 $n$ 是 $10^9$ 级别的，所以需要用离散化和差分，实际上这样子实现起来比较复杂，可以转而维护不合法区间的并。

现在的问题是如何求出这些区间。

----

设 $t$ 在 $s$ 中匹配的位置为 $i$，有 $t_{x + 1} = s_{i + x}$，下标从 $0$ 开始。

- 当 $t_{x + 1} = 0$ 时，有 $0 \le (ai + ax + b) \bmod n < p$，化简可得 $-ax-b\leq ai <p-ax-b$。
- 否则，有 $p \le (ai + ax + b) \bmod n < n$，化简可得 $p - ax - b \le ai < n - ax - b$。

由于是在模 $n$ 意义下，可能会出现类似 $p - ax - b > n - ax - b$ 的情况，此时 $ai$ 的取值范围为 $[p - ax - b, n - 1] + [0, n - ax - b)$，对于$t_{x + 1} = 0$ 同理。

蠢蠢的笔者看了别的题解自己推式子的时候把 $a$ 除了过去，然后发现以 $i$ 为下标的序列构成的区间根本不是连续的！思考了半天，其实不除过去就行了，因为当 $\gcd(a, n) = 1$ 时，$ai \bmod n$ 与 $i \in[0, n - 1]$ 的取值一一对应，故我们只需要统计有多少个 $ai$ 满足条件即可。

----

当然如果你这样统计完之后你会发现你算出来的结果比标准答案要大，这是由于我们把 $[n - m + 1, n - 1]$ 这一坨合法的答案统计进去了，减掉即可。

代码维护的是不合法区间并。

```cpp
#include <bits/stdc++.h>
#define rep(i, a, b) for(int i = (a), stOwxc = (b); i <= stOwxc; i++)
#define per(i, a, b) for(int i = (a), stOwxc = (b); i >= stOwxc; i--)
using namespace std;
using LL = long long;
using VI = vector<int>;

signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    int n, a, b, p, m; cin >> n >> a >> b >> p >> m;
    string t; cin >> t;

    vector<pair<int, int>> A;
    rep(x, 0, m - 1) {
        LL l, r;
        if(t[x] == '0') 
            l = (p - 1ll * a * x % n - b) % n, r = (n - 1ll * a * x % n - b) % n;
        else 
            l = (-1ll * a * x % n - b) % n, r = (p - 1ll * a * x % n - b) % n;
        l = (l + n) % n, r = (r + n) % n;
        if(l <= r) A.emplace_back(l, r - 1);
        else A.emplace_back(0, r - 1), A.emplace_back(l, n - 1);
    }
    rep(i, n - m + 1, n - 1) A.emplace_back(1ll * a * i % n, 1ll * a * i % n);

    sort(A.begin(), A.end());
    int ans = n, mx = -1;
    for(auto p : A) {
        if(p.first <= mx) ans -= max(0, p.second - mx), mx = max(mx, p.second);
        else mx = p.second, ans -= p.second - p.first + 1;
    }

    cout << ans << '\n';
    return 0;
}
```

---


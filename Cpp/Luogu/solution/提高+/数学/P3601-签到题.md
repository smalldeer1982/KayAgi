# 签到题

## 题目背景

这是一道签到题！

**建议做题之前仔细阅读数据范围！**


## 题目描述

我们定义一个函数：$\operatorname{qiandao}(x)$ 为小于等于 $x$ 的数中，与 $x$ **不互质**的数的个数。

这题作为签到题，给出 $l$ 和 $r$，求出：

$$\sum_{i=l}^r \operatorname{qiandao}(i)\bmod 666623333$$


## 说明/提示

- 对于 $30\%$ 的数据，$l,r\leq 10^3$。
- 对于 $60\%$ 的数据，$l,r\leq 10^7$。
- 对于 $100\%$ 的数据，$1 \leq l \leq r \leq 10^{12}$，$r-l \leq 10^6$。


## 样例 #1

### 输入

```
233 2333```

### 输出

```
1056499```

## 样例 #2

### 输入

```
2333333333 2333666666```

### 输出

```
153096296```

# 题解

## 作者：Hello_BABY_OvO (赞：54)

先看数据范围，$n$是$10^{12}$，杜教筛是$O$($n^{\frac{2}{3}}$)的，常数还巨大，所以杜教筛做不了这道题。然后再看$l$,$r$很的小，所以可以考虑枚举然后求和，题中的$qiandao(x)=x-phi(x)$，先筛出$10^{6}$中所有的质数，然后用埃氏筛的思想去算出每个质数对$[l,r]$区间里每个数的贡献，最后再特判一下大于$\sqrt{r}$的质数就OK了！！！
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <cmath>
#define MAXN 1000005
#define MOD 666623333
using namespace std;
long long l,r,ans,BASE;
int cnt;
bool isprime[MAXN];
long long prime[MAXN],A[MAXN],B[MAXN];
void shai()
{
    for(int i=2;i<=MAXN;i++)
    {
        if(!isprime[i]) prime[++cnt]=i;
        for(int j=2*i;j<=MAXN;j+=i)
            isprime[j]=1;
    }
}
void work()
{
	int i=1;
    while(prime[i]*prime[i]<=r)
    {
    	long long p=prime[i];
    	for(int x=(p-l%p)%p;x<=r-l;x+=p)
    	{
    		A[x]/=p,A[x]*=p-1;
    		while(B[x]%p==0)
				B[x]/=p;
		}i++;
	}
}
int main()
{
    shai();
    scanf("%lld%lld",&l,&r);BASE=l;
    for(long long i=l;i<=r;i++)
    	A[i-BASE]=i,B[i-BASE]=i;
    work();
    for(int i=0;i<=r-l;i++) 
	{
    	if(B[i]!=1) A[i]/=B[i],A[i]*=(B[i]-1);
		ans=(ans+i+BASE-A[i])%MOD;
	}
	printf("%lld",ans);
    return 0;
}
```

---

## 作者：0x3F (赞：26)

~~说好的签到题呢？~~

首先，我们发现 $\operatorname{qiandao}(i) = i - \phi(i)$。

然后，我们发现 $r - l \leq 10^6$，这也许就是突破口。

我们可以使用欧拉筛筛出每一个不超过 $\sqrt{r}$ 的素数，然后利用这些素数来更新 $l$ 到 $r$ 中 $\phi(i)$ 的值。

利用以下性质：

$$\phi(pn) = (p-1)\phi(n) (p \in \operatorname{Prime}, p \nmid n)$$

大于 $\sqrt{r}$ 的素数要特判，需要另开一个数组表示每一个数被小于 $\sqrt{r}$ 的素数除了一遍以后的值，如果不是 $1$ 就说明该数就是原数的一个素因子。

在储存上可以将下表减去 $l$，从而将 $[l, r]$ 转化成 $[0, r-l]$。

$\color{blue}{\texttt{十年OI一场空，不开long long见祖宗！}}$

更重要的是：

# $\huge{\color{red}{\texttt{不要忘记取模！}}}$

没了，看代码吧。

```cpp
#include <bits/stdc++.h>
#define int long long //好东西
#define _ 1000010
#define __ 80000
using namespace std;
int l, r;
signed s, k;
signed prime[__];
int phi[_], val[_];
bool isp[_];

inline void euler(void) {
	//筛素数
	memset(isp, 1, sizeof(isp));
	isp[1] = 0;
	for (signed i = 2; i <= s; i++) {
		if (isp[i]) {
			prime[++k] = i;
		}
		for (signed j = 1; j <= k && i*prime[j] <= s; j++) {
			isp[i*prime[j]] = 0;
			if (i % prime[j] == 0) break;
		}
	}
}

inline int qiandao(void) {
	int ans = 0;
	//初始化φ
	for (int i = l; i <= r; i++) {
		phi[i-l] = val[i-l] = i;
	}
	//计算φ
	for (signed i = 1; i <= k; i++) {
		for (int j = ((l-1)/prime[i]+1)*prime[i]; j <= r; j += prime[i]) {
			if (val[j-l] % prime[i] == 0) {
				phi[j-l] = phi[j-l] / prime[i] * (prime[i]-1);
				while (val[j-l] % prime[i] == 0) val[j-l] /= prime[i];
			}
		}
	}
	//特判大于sqrt(r)的素数
	for (int i = l; i <= r; i++) if (val[i-l] != 1) phi[i-l] = phi[i-l] / val[i-l] * (val[i-l] - 1);
	//统计答案
	for (int i = l; i <= r; i++) ans = (ans + i - phi[i-l]) % 666623333;
	return ans;
}

signed main() {
	cin >> l >> r;
	s = ceil(sqrt(r));
	euler();
	cout << qiandao() << endl;
	return 0;
	
}
```


---

## 作者：SuperTNT (赞：18)

# P3601 [签到题]



 对于我来说题有一定思维含量~~(当然某些大佬秒切)~~

  本题主要是对数据范围和所给式子的分析来完成此题

  ## 前置知识

  1.线性筛/埃氏筛

  2.欧拉函数

  ## 分析

  对于式子$\sum\limits_{i=l}^r qiaodao(i) \bmod 666623333$(其中$qiaodao(i)$为$\le i$与$i$不互质的数的个数)

  我们可以将其转化为$(\sum\limits_{i=l}^r i -\sum\limits_{i=l}^r \varphi(i))  \bmod 666623333$

  通过观察数据范围$1\le l,r\le 10^{12},r-l \le 10^6$可以发现直接求是不行的

  因为$r$最大为$10^{12}$，而$\sqrt r=10^6$，所以我们只需要用筛法求出$10^6$以内的质数即可，然后对于每个质数,对它的倍数求一次欧拉函数即可

  对于大于$10^6$的质数,我们发现大于$10^6$的数，其大于$10^6$的质数最多出现一个且其指数不超过$1$，因此我们可以开$1$个$vis[]$数组，根据正整数唯一分解定理，在求欧拉函数过程中，对求分解，最后当$vis[]$不为1时，必定存在一个大质数，否则就不存在

  ## 细节

  1.要开 $long long$

  2.求欧拉函数时要先除再乘,否则可能会爆$longlong$

  ## 代码

```
#include <bits/stdc++.h>

#define re register

#define ll long long

namespace TNT
{
    const int MAXN = 1e6 + 10;
    const int mod = 666623333;

    ll phi[MAXN], vis[MAXN];//phi[]求欧拉函数,vis[]是为了判断一个数是否可以分解出大质数
    int prime[MAXN], tot;
    bool mindiv[MAXN];

    inline void ES(int n)//欧拉筛质数
    {
        for (re int i = 2; i <= n; i++)
        {
            if (!mindiv[i])
                prime[++tot] = i;
            for (re int j = 1; j <= tot && prime[j] * i <= n; j++)
            {
                mindiv[prime[j] * i] = 1;
                if (!(i % prime[j]))
                    break;
            }
        }
    }

    inline void main()
    {
        ll l, r;
        scanf("%lld%lld", &l, &r);

        for (re int i = 0; i <= r - l; i++)
            vis[i] = phi[i] = i + l;

        ES(sqrt(r));

        for (int i = 1; i <= tot && prime[i] * prime[i] <= r; i++)
        {
            int p = prime[i];//对于每1个小于1e6的质数，对它的倍数求一次欧拉函数

            for (re int j = (p - l % p) % p; j <= r - l; j += p)
            {
                phi[j] = phi[j] / p * (p - 1);
                while (!(vis[j] % p))//同时使该数不还有该质因子
                    vis[j] /= p;
            }
        }

        int ans = 0;
        for (re int i = 0; i <= r - l; i++)
        {
            if (vis[i] != 1)//求是否有大质数
                phi[i] = phi[i] / vis[i] * (vis[i] - 1);
            ans = 1ll * (ans + i + l - phi[i]) % mod;//统计答案
        }

        printf("%d\n", ans);
        return;
    }

} // namespace TNT

int main()
{
    TNT::main();
    return 0;
}
```
 完结撒花



---

## 作者：Jμdge (赞：13)

想想这是好久前做的题了，然鹅最近一翻...咳咳，~~这题是谁帮我 A 的？~~

首先我们考虑原题就是求这么个柿子：

$$\begin{aligned}val_x&=\sum_{i=1}^n i-\varphi(i) =\sum_{i=1}^n i  - \sum_{j=1}^n \varphi(j)   \\  ANS&=val_b-val_a   ~~~~ (a,b\le 1e12 , b-2\le 1e5) \end{aligned}  $$

那么 $\sum i$ 就是 $O(1)$ 求  ，关键就是 $\sum \varphi(i)$ 了

观察一番，杜教筛稳炸，min_25 没好到哪里去，于是必然不能用这些方法了...

再康康  l~r 才 1e5 ，复杂度估计就是这儿出来的了


那么我们考虑对于这些数分解质因子求出 $\varphi$ 值？很遗憾，这玩意儿是根号的算法，禁不起 1e5 次折腾

怎么办？那我们只好舍弃根号算法，想想欧拉筛的过程...

我们可以康到，这里的每个质因子都对包含它的数产生过一次更新（有可能是间接的更新），那么我们可以考虑在求 l~r  的 $\varphi$  值的时候集体更新，令 $m=r-l,n=r$ 那么复杂度就变成了：

$$\sum_{p\in prime} ({m\over p} +1) $$

~~不如积分~~

$$\int_1^{\sqrt n} {m\over x}+1~dx= \sqrt n + m~ ln~n $$


（这里自动省略了常数...所以柿子不一定很真实）


于是就当他复杂度 $m ~ln ~n$ ，就 ojbk 地过了此题


```cpp
//by Judge
#include<iostream>
#include<cstdio>
#define ll long long
using namespace std;
const int Max=1e6+11;
const int mod=666623333;
ll l,r,ans,cnt,is[Max+10],prim[Max+10],A[Max+10],B[Max+10];
inline void prep(){
	for(int i=2,j;i<=Max;++i){
		if(!is[i]) prim[++cnt]=i;
		for(j=1;j<=cnt && i*prim[j]<=Max;++j){
			is[i*prim[j]]|=1;
			if(i%prim[j]==0) break;
		}
	}
}
inline void solv(){
	for(ll i=1,p;prim[i]*prim[i]<=r;++i){
		p=prim[i];
		for(int x=(p-l%p)%p;x<=r-l;x+=p){
			A[x]/=p,A[x]*=p-1;
			while(B[x]%p==0) B[x]/=p;
		}
	}
}
int main(){
	scanf("%lld%lld",&l,&r),prep();
	for(ll i=l;i<=r;++i) A[i-l]=B[i-l]=i;
	solv(); for(int i=0;i<=r-l;++i){
		if(B[i]^1) A[i]/=B[i],A[i]*=B[i]-1;
		ans=(ans+i+l-A[i])%mod;
	} return !printf("%lld\n",ans);
}
```





---

## 作者：rsdbk_husky (赞：12)

## 零. 安利：

[安利一下我的博客。](https://rsdbkhusky.github.io/)

## 一. 思路

$1 \le l \le r \le 10^{12}$，$r-l \le 10^6$。很显然，传统的用欧拉函数是积性函数这条性质的从 $1$ 扫到区间右端的方法肯定不行。
虽然传统的方法不行。但欧拉函数还有一条有用的公式：$\varphi(n)=n \times \prod\limits_{i=1}^{n}\dfrac{p_i-1}{p_i}$ 。也就是说，我们只要知道 $l \sim r$ 中所有数的质因数分解就好了。不难发现一个数 $n$ 的质因数中有一个或零个大于 $\sqrt{n}$ 。那么我们把小于等于 $\sqrt{r}$ 的质数姑且称为“小质数”；大于 $\sqrt{r}$ 的叫“大质数”。

先预处理出所有小质数（也就是 $1 \sim 10^6$ 内的）开一个数组 $inv$ 每个位置预处理为下标的值（就是 $\varphi(n)=n \times \prod\limits_{i=1}^{n}\dfrac{p_i-1}{p_i}$ 中的等式右边的 $n$），然后用倍数法枚举所有小质数在 $l \sim r$ 区间中的倍数，将相应的 $inv_i$ 乘上 $\prod\limits_{i=1}^{n}\dfrac{p_i-1}{p_i}$。

当然，不要忘了大质数，因为每个数至多有一个大质数，所以大质数也很好处理。开一个数组 $bidprime$ 全初始化为下标。用倍数法枚举 $prime_i$ 的倍数枚举到相应的 $inv_j$ 时，顺便把 $bigprime_j$ 中所有的的因数 $prime_i$ 剔除。最后就得到了每个数的大质数。

## 二. 细节

最重要的细节就是枚举小指数的倍数时从几枚举了。设该小质数为 $p$，区间左端点为 $l$ 。答案是 $\max\{ p^2, \left\lceil\dfrac{l}{p}\right\rceil \times p \}$。

为什么呢？首先小于 $p^2$ 的 $p$ 的倍数在枚举 $2$，$3$ 等比它更小的质数时就已经枚举过了。而 $\left\lceil\dfrac{l}{p}\right\rceil \times p $ 是大于等于 $l$ 的第一个 $p$ 的倍数。

## 三. 代码

```cpp
#include<cstdio>
#include<cmath>
#define re register 
#define int long long
const int MAXprime = 1e6;
const int MAXn = 1e6;
const int MOD = 666623333;

template <class T>
inline T max(T a, T b) {
	return a > b ? a : b;
}

int cntp, prime[MAXprime / 5 + 100];
bool notp[MAXprime + 10];
void PrimeSieve(int up) {						//线性筛不解释 
	notp[1] = 1;
	for (re int i = 2; i <= up; ++i) {
		if (!notp[i]) 
			prime[++cntp] = i;
		int upj = up / i;
		for (re int j = 1; j <= cntp && prime[j] <= upj; ++j) {
			notp[i * prime[j]] = 1;
			if (!(i % prime[j])) 
				break;
		}
	}
}

int ans, l, r, phi[MAXn + 10], bigprime[MAXn + 10];
signed main() {
	PrimeSieve(MAXprime);
	scanf("%lld %lld", &l, &r);
	for (re int i = l; i <= r; ++i) {			//初始化 
		phi[i - l] = bigprime[i - l] = i;
	}
	for (re int i = 1; i <= cntp; ++i) {		//倍数法：枚举所有小质数的倍数 
		for (re int j = max(prime[i] * prime[i], (int)ceil((double)l / prime[i]) * prime[i]); j <= r; j += prime[i]) {
			phi[j - l] = phi[j - l] / prime[i] * (prime[i] - 1);
			while (!(bigprime[j - l] % prime[i])) {
				bigprime[j - l] /= prime[i];
			}
		}
	}
	for (re int i = l; i <= r; ++i) {			//处理大质数 
		if (bigprime[i - l] > 1) {
			phi[i - l] = phi[i - l] / bigprime[i - l] * (bigprime[i - l] - 1);
		}
	}
	for (re int i = l; i <= r; ++i) {			//求和 
		ans = (ans + i - phi[i - l]) % MOD;
	}
	printf("%lld\n", ans);
}
```

---

## 作者：Manjusaka丶梦寒 (赞：7)

一道关于欧拉函数的题。

读完题目以后我们知道所谓的$qiandao(x)=x- \phi (x) $。

对于x小的情况下我们当然可以用 枚举因子或者线型筛求得，然而x打了以后就数组装不下了。

注意区间大小，我们完全可以只求这一部分区间内的x的$ \phi (x) $，数字移一下位置就好了。

然而求没一个数的欧拉函数值时我们只用到了，小于等于$\sqrt x$的质因子(就想线性筛一样)，所以我们只需要晒出小于$\sqrt r$的素数是什么，然后了枚举区间中每一个数的倍数然后用公式进行不断地更新就好了。
```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>
using namespace std;
#define LL long long
#define mod 666623333
LL prime[1000006],vis[1000006],tot,cnt,phi[1000006];
LL l,r,ans;
void prepare()
{    
    for(int i=2;i<=1000000;i++)
    {
        if(!vis[i])prime[++tot]=i;
        for(int j=1;j<=tot&&prime[j]*i<=1000000;j++)
        {
            vis[prime[j]*i]=1;
            if(i%prime[j]==0)
            {
//                phi[i*prime[j]]=phi[i]*prime[j];
                break;
            }
//            else phi[i*prime[j]]=phi[i]*phi[prime[j]];
        }
    }
}
LL A[1000006],B[1000006]; 
int main()
{
    prepare();
    scanf("%lld%lld",&l,&r);
    for(LL i=0;i<=r-l+1;i++)phi[i]=B[i]=i+l-1;
    for(LL i=1;i<=tot&&prime[i]*prime[i]<=r;i++)
    {
        LL lb=prime[i]*(l/prime[i]),rb=prime[i]*(r/prime[i]);
//        cout<< lb<<" "<<rb<<"\n";
        for(LL j=lb;j<=rb;j+=prime[i])
        {
            if(j>=l)
            {
                phi[j-l+1]=phi[j-l+1]/prime[i]*(prime[i]-1);
                while(B[j-l+1]%prime[i]==0)B[j-l+1]/=prime[i];
            }
        }
    }

    for(int i=1;i<=r-l+1;i++)
    {
        if(B[i]>1)phi[i]=phi[i]/B[i]*(B[i]-1);    //剩下一堆大质数了。 
        ans+=l+i-1-phi[i];ans%=mod;
    }
    cout<<ans;
}
```

---

## 作者：5加1 (赞：6)

# 首先我们来分析一下

所求的$qiandao(n)=1-phi(n)$

我们发现 $l$ 和 $r$ 比较大，但是 $r-l$ 的范围比较小。

预先筛出 $\sqrt{r}$ 以内的质数，枚举每个质数 $p$ ，统计 $p$ 对 $l$ 到 $r$ 之间的数字 $n$ 的 $phi(n)$ 的贡献。

# $\color{red} Code$

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
typedef long long ll;
const ll Mn=1e6+5;
const ll mod=666623333;
ll prime[Mn],l,r,phi[Mn],vis[Mn],pc,ans,a[Mn];

void getprime(){
  for(ll i=2;i<Mn;i++){
    if(a[i])
      prime[pc++] = i;
    for(ll j=0;j<pc && prime[j]*i<Mn;j++){
      a[prime[j]*i]=false;
      if(i%prime[j]==0)
        break;
    }
  }
}

int main(){
  scanf("%lld%lld" ,&l,&r);
  for(int i=0;i<Mn;i++)a[i]=true;
  getprime();
  for(ll i=l;i<=r;i++){
    vis[i-l]=i;
    phi[i-l]=i;
  }
  for(ll i=0;i<pc && prime[i]*prime[i]<=r;i++){
    ll p=prime[i],start=l;
    if(l%p!=0){
      start=l/p*p+p;
    }
    for(ll j=start;j<=r;j=j+p){
      phi[j-l]=phi[j-l]/p*(p-1);
      while(vis[j-l]%p==0)
        vis[j-l]/=p;
    }
  }
  for(ll i=l;i<=r;i++){
    if(vis[i-l]>1){
      //处理剩下的大因子，最多有一个超过根号r的因子。
      phi[i-l]=phi[i-l]/vis[i-l]*(vis[i-l]-1);
    }
    ans=(ans+(i-phi[i-l]))%mod;
  }
  printf("%lld\n",ans);
  return 0;
}
```

---

## 作者：Jayun (赞：3)

# 题目大意：

求 $\sum_{i=l}^{r}(i-\varphi(i))\mod 666623333$。

# 正文：

## 方法一：

预处理出所有的欧拉函数值，直接求 $\sum_{i=l}^{r}(i-\varphi(i))\mod 666623333$。但是 $1\leq l\leq r\leq 10^{12}$，只能过 60% 的数据。

## 方法二：

发现数据 $r-l\leq 10^6$，这是一个很不错的切入点。为了得到欧拉函数值，先筛出 $\sqrt{r}=10^6$ 内所有质数，统计每个质数对 $[l,r]$ 内所有欧拉函数值的贡献。

# 法二代码：

```cpp
ll pri[N], cnt, phi[N], A[N], ans;
bool vis[N];

void Prime ()
{
	for (int i = 2; i <= N - 10; i++)
	{
		if(!vis[i]) pri[++cnt] = i;
		for (int j = 1; j <= cnt && i * pri[j] <= N - 10; j++)
		{
			vis[pri[j] * i] = 1;
			if(!(i % pri[j])) break;
		}
	}
} 

int main()
{
	Prime();
	scanf ("%lld%lld", &l, &r);
	for (ll i = l; i <= r; i++)
		phi[i - l] = i, A[i - l] = i;
	for (int i = 1; i <= cnt && pri[i] * pri[i] <= r; i++)
	{
		ll pr = pri[i], start = l;
		if (l % pr) start = l / pr * pr + pr;
		for (ll j = start; j <= r; j += pr)
		{
			phi[j - l] = phi[j - l] / pr * (pr - 1);
			while(A[j - l] % pr == 0) A[j - l] /= pr;
		}
	} 
	for (ll i = l; i <= r; i++)
	{
		if(A[i - l] > 1)
			phi[i - l] = phi[i - l] / A[i - l] * (A[i - l] - 1);
		ans = (ans + (i - phi[i - l]) % mod) %mod;
	}
	printf ("%lld", ans);
	return 0;
}
```

---

## 作者：Kaiser (赞：3)

这道题用欧拉筛数，筛出根号r里的所有质数，

然后应为一个数n最多只有一个比根号n大的质数，所以再记录一个n

每次除，剩下若不为一则为大质数（即大于根号n的大质数）、

然后用剩余系去求欧拉函数，用n-phi[i]即可，然后求一个sum值

```cpp
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<iostream>
#include<cstring>
typedef long long ll;
#define mod 666623333
ll prime[100007]={0},cnt,phi[1000007]={0};
ll vis[1000007];
using namespace std;
void Prime(int n)  
{  
    cnt=0;  
    memset(vis,0,sizeof(vis));  
    for(int i=2;i<=n;i++)  
    {  
        if(!vis[i])  
        {  
            prime[++cnt]=i;  
        }  
        for(int j=1;j<=cnt&&i*prime[j]<=n;j++)  
        {  
            long long k=i*prime[j];  
            vis[k]=1;  
            if(i%prime[j]==0) break;   
        }  
    }  
}  
int main()
{
    ll l,r;
    scanf("%lld%lld",&l,&r);
    ll n=(ll)sqrt(r);
    Prime(n);
    for (int i=0;i<=r-l;i++)
        phi[i]=i+l,vis[i]=i+l;
    for (int i=1;i<=cnt;i++)
    {
        ll k=l/prime[i]*prime[i];
        if (k==l) k=k-prime[i];
        if (prime[i]>=l) k=0;
        while ((ll)(k+prime[i])<=r)
        {
            k+=prime[i];
            phi[k-l]=phi[k-l]/prime[i]*(prime[i]-1);
            while (vis[k-l]%prime[i]==0) vis[k-l]/=prime[i];
        }
    }
    for (int i=0;i<=r-l;i++)
        if (vis[i]>1) phi[i]=phi[i]/vis[i]*(vis[i]-1);
    ll ans=0;
    for (int i=0;i<=r-l;i++)
        ans=(ans+i+l-phi[i])%mod;
    cout<<ans<<endl;                
}
附上代码
```

---

## 作者：Welles (赞：3)

不行我必须吐槽一下，首先因为不知道洛谷什么时候改成linux，连续爆蛋6、7次以后突发奇想把%I64d改成了%lld……突然就有分了……有分了……

大致思路应该都有，说几个细节的地方

//0.longlong不解释

1.L-R虽然数字很大，但是可以重新定下标，开一个ansi用来推欧拉通项，再开一个tmp来处理大于10^6的大质数；

2.推ansi的时候ansi=ansi/prime\*(prime-1)这个地方不能手贱加MOD！！！！因为后面还要继续推ansi还要除以其他质数……如果这个地方MOD了其他就要用逆元了。

3.统计答案tmpi==1，res=res+ansi %MOD；else res=ansi/tmpi\*(tmpi-1)；这个地方一定要先除……不然ansi会爆掉，连带res一起挂……

总结，题目不难……坑也不少……那个MOD加不加的问题整了我好久……以后还是cin、cout吧……不知道系统换了太踏马坑了。。。


---

## 作者：fakeman (赞：1)

2017.2.2修改

- 显然qiandao(x)=x-phi(x)



- ans=sum(x-phi(x))=sum(x)-sum(phi(x))

- 注意到r-l<=10^6,且r<=10^12.而且对于某个数y,他最多有一个大于sqrt(10^12)的质因子。


- 筛出所有10^6次方以内的素数，并用他们除所有在[l,r]之间的倍数。时间复杂度为O((r-l)/2+(r-l)\*3.....)约等于O((r-l)\*log r)  (调和级数).


- 成功分解质因数后利用欧拉函数通项公式算出phi


---


# 环的异或

## 题目描述

给出无向图 G，边 $(A_i,B_i)$ 的权是 $C_i$，判断下列性质是否成立：

对于任意环 C，其边权的异或和是 $0$。

## 说明/提示

- 对于 $50\%$ 的数据，$N,M \le 20$。

- 对于 $100\%$ 的数据，$1 \le N,M \le 50,1 \le A_i,B_i \le N,0 \le C_i < 2^{16}$。

## 样例 #1

### 输入

```
2
3 3
1 2 1
2 3 2
3 1 3
1 1
1 1 1```

### 输出

```
Yes
No```

# 题解

## 作者：zhengrunzhe (赞：4)

楼下所说的n^2实际上并不是真的的正解

这里单组询问可以做到O(n+m)

开个bool vis[N]数组,vis[x]表示x是否被访问过

开个int sum[N]数组，sum[x]表示dfs从起点到x的边权异或和(dfs序1~x的异或和，类似前缀和)

如果访问到点u，有条到点v的出边

如果!vis[v]，点v没有被访问过，那就去dfs它

如果v被访问过了，并且若pre表示u前访问的那个点，v!=pre，则说明dfs序介于v到u之间的点构成了一个圈

![](https://cdn.luogu.com.cn/upload/pic/45315.png)

假如从4这个点开始dfs，假如到3再到2再到1时，1有条指向访问过的点3的边，则在3之后被访问且在1之前被访问的点与1和3构成了个圈，则说明(3,2,1)构成了一个环

那么如何判断环的异或和是否为0呢，用前缀异或和数组sum来实现

![](https://cdn.luogu.com.cn/upload/pic/45316.png)

红色部分代表sum[3]对应算的边，蓝色部分代表sum[1]算的边

显然sum[1]可以被拆分成sum[3]的部分和3-2-1的部分

3-2-1的部分便是我们要算的环(1,2,3)的一部分，环的另一部分则就是返祖边1-3了，sum[3]和sum[1]以及边权1-3我们是已知的，设3-2-1路径的异或和为S,返祖边<1,3>的边权为W,环(1,2,3)的异或和便是W xor S，那么如何求得3-2-1的异或和S呢

sum[1]=S xor sum[3]

则sum[1] xor sum[3]=S xor sum[3] xor sum[3]=S xor (sum[3] xor sum[3])=S xor 0=S

所以sum[1] xor sum[3]之后便求得了S

总结：

记录亦或前缀和sum，标记数组vis

通过vis找到返祖边<u,v>,sum[u]^sum[v]^w<u,v>便是环的异或和，判断其是否为0

若不为0，则结果就是"No"了，全部return回去
```cpp
#include<cstdio>
#include<algorithm>
using std::fill;
template<class type>inline void read(type &in)
{
    in=0;char ch=getchar();short fh=1;
    while (ch<48||ch>57)fh=ch=='-'?-1:fh,ch=getchar();
    while (ch>47&&ch<58)in=(in<<3)+(in<<1)+ch-48,ch=getchar();
    in*=fh;
}
const int N=51;
bool vis[N],flag;
int n,m,cnt,head[N],sum[N];
struct edge{int to,w,next;}e[N<<1];
inline void addedge(int u,int v,int w)
{
	e[++cnt].next=head[u];
	head[u]=cnt;
	e[cnt].to=v;
	e[cnt].w=w;
}
inline void connect(int a,int b,int c)
{
	addedge(a,b,c);
	addedge(b,a,c);
}
inline void init()
{
	flag=cnt=0;
	fill(head+1,head+n+1,0);
	fill(vis+1,vis+n+1,0);
}
inline void dfs(int now,int pre,int s) //now代表当前点,pre代表前一个点,s代表当前的前缀异或和(用于赋值sum数组)
{
	if (flag)return;vis[now]=1;sum[now]=s;
	for (int nxt,i=head[now];i&&!flag;i=e[i].next)
		if (!vis[nxt=e[i].to]) //还没访问过就去访问它
			dfs(nxt,now,s^e[i].w);
		else
			if (nxt!=pre&&sum[now]^sum[nxt]^e[i].w) //不为0打上标记通通return
					return (void)(flag=1);
}
int main()
{
	int t;read(t);
	while (t--)
	{
		init();  //记得初始化
		read(n);read(m);
		int a,b,c;
		while (m--)
			read(a),read(b),read(c),connect(a,b,c);
		for (int i=1;i<=n;i++) //由于图可能不连通，要循环一遍
			if (!vis[i])
				if (!flag)dfs(i,0,0);
				else break;
		puts(flag?"No":"Yes");
	}
	return 0;
}
```

---

## 作者：txrw (赞：3)

建一棵树，其余的边为非树边，则现在图中有树边和非树边。

那么一个环的异或和为非树边左端点到根的路径上边的异或和，异或上右端点到根的异或和，再异或上这条非树边的权值即可。

Code：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

inline int read(){
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();
    return x*f;
}

const int N=55;
int T,n,m,v[N],vis[N],flag=0,ans,dis[N]; 

struct nd{
    int to,w;
};
vector<nd> p[N];  

struct node{
    int x,y,val;
}q[N];

void dfs(int x,int fa){
    vis[x]=1;
    for(int i=0;i<p[x].size();i++){
        int y=p[x][i].to,w=p[x][i].w;
        if(vis[y]) continue;
        dis[y]=dis[x]^w;  
        dfs(y,x); 
    }
    return ;
}

void insert(){
    for(int i=1;i<=n;i++)
        p[i].clear(),vis[i]=0,dis[i]=0;
}
signed main(){
    T=read();
    while(T--){
        n=read(),m=read();
        insert();
        for(int i=1;i<=m;i++){
            int x=read(),y=read(),w=read();
            q[i]=(node){x,y,w};
            p[x].push_back({y,w});
            p[y].push_back({x,w});
        }
        for(int i=1;i<=n;i++)
            if(!vis[i]) dfs(i,0);   
        int flag=0;
        for(int i=1;i<=m;i++)
            if(dis[q[i].x]^dis[q[i].y]^q[i].val)
                flag=1;
        if(!flag) cout<<"Yes\n";
        else cout<<"No\n";  
    }
    return 0;
}
```

---

## 作者：囧仙 (赞：3)

## 题解

因为异或操作对于二进制下每一位相当于是独立的，因此我们可以按照每一位来分别处理。于是问题简化为了，边权仅有 $0$ 与 $1$ 的情况时，是否存在异或和为 $1$ 的环。

观察发现，边权为 $0$ 的边不会对环的异或结果产生任何影响。因此，对于 $0$ 边所连接的点，我们可以把它们**缩到一个点**（仅由 $0$ 边所链接的子图，等效于 $1$ 个点）。要注意的是，缩点之后可能存在边权为 $1$ 的**自环**，这对应着原来一个异或和为 $1$ 的环。那么问题再次简化为了，对于边权都为 $1$ 的图，是否存在异或和为 $1$ 的边。实际上就是判断这张图是否存在奇环。

那么拿二分图染色跑一下就行了。在这个做法中，合并节点可以用并查集 $O(\alpha (n))$ 完成，也可以在跑二分图染色的时候顺便合并，后者总体上只要 $\mathcal O(n+m)$ 。染色过程同样是 $\mathcal O(n+m)$ 的。

由于我们要枚举每一个二进制位，因此最终的复杂度为 $\mathcal O(T(n+m)\log v)$ 。由于本题数据很小，下面的代码直接跑的邻接矩阵，复杂度是 $\mathcal O(Tn^2\log v)$ 的。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int INF =2147483647;
const int MAXN=50+3;
int n,m,C[MAXN],W[MAXN][MAXN],B[MAXN][MAXN],U[MAXN],V[MAXN],X[MAXN];
queue<int> q;
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
    return ret*w;
}
int main(){
    dn(qread(),1,T){
        int n=qread(),m=qread();
        up(1,m,i) U[i]=qread(),V[i]=qread(),X[i]=qread();
        up(0,16,t){
            up(1,n,i) C[i]=0; memset(B,0,sizeof(B));
            up(1,m,i){
                int u=U[i],v=V[i],w=X[i]; B[u][v]=B[v][u]=(w&(1<<t))+1;
            }
            while(!q.empty()) q.pop();
            up(1,n,i) if(!C[i]){
                q.push(i); C[i]=i; while(!q.empty()){
                    int u=q.front(),w=C[u]; q.pop(); up(1,n,j){
                        if(!B[u][j]) continue;
                        int v=(B[u][j]==1?C[u]:C[u]%2+1);
                        if(C[j]){if(C[j]!=v) goto no;}
                        else C[j]=v,q.push(j);
                    }
                }
            }
        }
        puts("Yes"); goto yes; no: puts("No"); yes:;
    }
    return 0;
}
```

---

## 作者：Anoxiacxy (赞：2)

那么就这样水一波了，可能是数据不强吧，我就每个点开始往外dfs，

看看能不能搜到自己，如果能搜到就判一下边权异或和，直接O(n^2)过了

如果这个做法正确性没问题的话，直接可以将数据加强到5000吧

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>
#define LL long long
#define mod (LL)(1e9+7)
using namespace std;

vector<pair<int,int> >G[100];
int vis[100];
bool check(int r,int v,int k){
    for(int i=0;i<G[k].size();i++){
        int kk=G[k][i].first;
        int val=G[k][i].second;
        if(kk==r&&(v^val)!=0)return false;
        if(vis[kk])continue;
        vis[kk]=true;
        if(!check(r,v^val,kk))return false;
    }
    return true;
}
int main(){
    int T;scanf("%d",&T);
    while(T--){
        int n,m;scanf("%d%d",&n,&m);
        for(int i=1;i<=m;i++){
            int a,b,c;scanf("%d%d%d",&a,&b,&c);
            G[a].push_back(make_pair(b,c));
            G[b].push_back(make_pair(a,c));
        }
        bool flag=true;
        for(int i=1;i<=n;i++){
            memset(vis,false,sizeof(vis));
            vis[i]=true;
            flag&=check(i,0,i);
            if(!flag)break;
        }
        if(flag)printf("Yes\n");
        else printf("No\n");
        for(int i=1;i<=n;i++)G[i].clear();
    }
}
```

---

## 作者：RegisterFault (赞：1)

提供一个更加暴力的做法。

考虑拆位。将边权由 $w_i$ 变成 $w_i$ 二进制下第 $k$ 位。这样实现值域的缩小。

然后直接跑 floyd。设 $f_{i, j, k}$ 表示从 $i$ 到 $j$，是否存在边权异或和为 $k$ 的路径（$k \in \{0, 1\}$），可以实现 $O(n ^ 3)$ 的转移。最后，如果存在两点 $i, j$ 之间既存在边权为 $0$ 的路径，又存在边权为 $1$ 的路径，则证明存在不满足条件的圈。

时间复杂度 $O(n ^ 3 \log V)$。

代码实现：

```cpp
int g[N][N], f[N][N][2];
int n, m, T;
bool check(int w) {
	memset(f, 0, sizeof f);
	rep(i, 1, n) rep(j, 1, n) if (~g[i][j]) 
		f[i][j][(g[i][j] >> w) & 1] = 1;
	rep(k, 1, n) rep(i, 1, n) rep(j, 1, n)
		if ((i ^ j) && (j ^ k) && (i ^ k)) {
			f[i][j][0] |= (f[i][k][0] & f[k][j][0]);
			f[i][j][0] |= (f[i][k][1] & f[k][j][1]);
			f[i][j][1] |= (f[i][k][1] & f[k][j][0]);
			f[i][j][1] |= (f[i][k][0] & f[k][j][1]);
		}
	rep(i, 1, n) rep(j, 1, n) if (i ^ j) {
		if (f[i][j][0] && f[j][i][1]) return true;
		if (f[i][j][1] && f[j][i][0]) return true;
	} return false;
}
int main() {
	read(T);
	while (T -- ) {
		read(n, m);
		memset(g, -1, sizeof g);
		bool flag = false;
		rep(i, 1, m) {
			int a, b, c;
			read(a, b, c);
			g[a][b] = g[b][a] = c;
			if (a == b and c != 0) flag = true;
		} if (flag) { puts("No"); continue; }
		rep(i, 0, 16) if (check(i)) {
			flag = true; break;
		} puts(flag ? "No" : "Yes");
	}
}
```

---

## 作者：sto_5k_orz (赞：1)

细节题。

这题直接枚举一个起点，然后 dfs 找环，中间边 dfs 边算异或和，假如出现了环，那么判一下异或和是否为 $0$ 即可。

注意要打标记。

本人由于变量名写错 + 写链式前向星忘记写边权导致寄了很多发。

算是警示后人。

复杂度 $O(n^2)$，话说 $n$ 能不能顶到 $2000$ 啊。

注意的是多测要清空，无论是 vector 还是邻接矩阵还是链式前向星。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N = 120; int st, h[N], to[N], nxt[N], w[N], idx, n, m, t; bool vis[N];
void add(int a, int b, int c) {to[idx] = b; w[idx] = c; nxt[idx] = h[a]; h[a] = idx++;}
bool dfs(int u, int val) {
	for(int i = h[u]; i != -1; i = nxt[i]) {
		int v = to[i], c = w[i];
		if(st == v && val != c) return 0;
		if(vis[v]) continue; vis[v] = 1;
		if(!dfs(v, val ^ c)) return 0;
	}
	return 1;
}
signed main() {
	cin >> t;
	while(t--) {
		memset(h, -1, sizeof h); idx = 0; cin >> n >> m; bool flag = 1;
		while(m--) {
			int a, b, c; cin >> a >> b >> c;
			add(a, b, c); add(b, a, c);
		}
		for(int i = 1; i <= n; i++) {
			memset(vis, 0, sizeof vis);
			vis[i] = 1; st = i; if(!dfs(i, 0)) {flag = 0; break;}
		}
		if(flag) puts("Yes"); else puts("No");
	}
	return 0;
}
```

---

## 作者：qiuqiu1231 (赞：0)

### 大意
先解释一下题目里的词语：

1. 圈是一条起点就是终点并且没有重复边的路。
1. 异或运算满足交换律 $ A \oplus B = B \oplus A $，和结合律 $ A \oplus (B \oplus C) = (A \oplus B) \oplus C $。如果某个图中的所有圈的边权异或和都为 $ 0 $，则该图是一个特殊的图。
### 方法
判断图中任意两点之间路径的异或值是不是唯一的。如果任意两点之间的路径的异或值是确定的，就可以保证所有圈的边权异或和为 $ 0 $。
### 具体思路
可以用到并查集和基环树。用并查集维护连通的边，记录每条边的异或值，再判断路径是否出现异或值冲突的情况，输出即可。
### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 100005;
int parent[MAXN], xor_value[MAXN];
bool conflict;

int find(int x) {
    if (parent[x] == x) return x;
    int root = find(parent[x]);
    xor_value[x] ^= xor_value[parent[x]];
    parent[x] = root;
    return root;
}

void unite(int x, int y, int w) {
    int root_x = find(x);
    int root_y = find(y);
    if (root_x == root_y) {
        if ((xor_value[x] ^ xor_value[y]) != w) {
            conflict = true;
        }
    } else {
        parent[root_x] = root_y;
        xor_value[root_x] = xor_value[x] ^ xor_value[y] ^ w;
    }
}

int main() {
    int T;
    cin >> T;
    while (T--) {
        int N, M;
        cin >> N >> M;

        // 初始化并查集
        for (int i = 1; i <= N; i++) {
            parent[i] = i;
            xor_value[i] = 0;
        }
        conflict = false;

        // 读取边的信息
        for (int i = 0; i < M; i++) {
            int A, B, C;
            cin >> A >> B >> C;

            if (!conflict) {
                unite(A, B, C);
            }
        }

        if (conflict) {
            cout << "No" << endl;
        } else {
            cout << "Yes" << endl;
        }
    }
    return 0;
}
```

---

## 作者：abandentsky (赞：0)

题意：题目的意思其实也很简单，让我们在图中找一个环，使得环的异或和为0就输出“Yes”否则就输出“No”。
思路：一看数据50，不用多想，直接暴搜就完了。详细的解释下面的大佬给出了，自己画个图也能搞明白，就是不断的跑图，知道出现环，然后利用类似前缀和的东西算一下就好了。下面大佬用的链式前向星，下面给出一个用刘汝佳风格写的代码，使用vector来存储的。（一般都能过，极少数情况下在poj上会超时）
```c
#include<bits/stdc++.h>
#pragma GCC optimize(2)
#define MAXN 55
#define maxnode 2000005
#define sigma_size 26
#define md 12345678
//#define INF 0x3f3f3f3f
#define INF 10000000
using namespace std;
typedef long long LL;

struct Edge
{
    int from,to,dist;
    Edge(int from=0,int to=0,int dist=0):from(from),to(to),dist(dist){};
};
vector<Edge> edges;
vector<int> G[MAXN];
bool vis[MAXN],flag;
int d[MAXN];
int n,m,t;

void AddEdge(int from,int to,int dist)
{
    edges.push_back({from,to,dist});
    edges.push_back({to,from,dist});
    int mm=edges.size();
    G[from].push_back(mm-2);
    G[to].push_back(mm-1);
}

void dfs(int u,int fa,int sum)
{
    if(flag)
        return ;
    d[u]=sum,vis[u]=true;
    for(int i=0;i<G[u].size();i++)
    {
        Edge &e=edges[G[u][i]];
        int v=e.to;
        if(v==fa)
            continue;
        if(!vis[v])
        {
            vis[v]=true;
            dfs(v,u,sum^e.dist);
            vis[v]=false;
        }
        else
        {
            if(!(d[u]^e.dist^d[v]))
            {
                flag=true;
                break;
            }
        }
    }
}

int main()
{
    int n,m,u,v,w;
    scanf("%d",&t);
    while(t--)
    {
        scanf("%d %d",&n,&m);
        edges.clear();
        for(int i=0;i<=n;i++)
            G[i].clear();
        for(int i=1;i<=m;i++)
        {
              scanf("%d %d %d",&u,&v,&w);
              AddEdge(u,v,w);
        }
        flag=false;
        for(int i=1;i<=n;i++)
        {
               vis[i]=true;
               dfs(i,-1,0);
               vis[i]=false;
               if(flag)
                  break;
         }
        if(flag)
            printf("Yes\n");
        else
            printf("No\n");
    }
    return 0;
}

```


---


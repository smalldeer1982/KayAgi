# 斐波那契数列

## 题目描述

定义一个数列：


$f(0) = a, f(1) = b, f(n) = f(n - 1) + f(n - 2)$


其中 $a, b$ 均为正整数，$n \geq 2$。


问有多少种 $(a, b)$，使得 $k$ 出现在这个数列里，且不是前两项。


由于答案可能很大，你只需要输出答案模 $10^9 + 7$ 的结果即可。


## 说明/提示

$1 \leq k \leq 10^9$


## 样例 #1

### 输入

```
19260817```

### 输出

```
34166325```

## 样例 #2

### 输入

```
1000000000```

### 输出

```
773877569```

# 题解

## 作者：小粉兔 (赞：66)

题意：给定 $k$，求 $x+y=k$、$x+2y=k$、$2x+3y=k$、$3x+5y=k$、$5x+8y=k$、……，的正整数解个数。

即要求出关于 $x,y$ 的方程 $f_i \cdot x + f_{i+1} \cdot y = k$ 的正整数解的个数（$f_n$ 是 Fibonacci 数列（斐波那契数列））。

显而易见，当 $f_i + f_{i + 1} > k$ 时，不用继续下去了，因为 $a, b$ 均为正整数，故不同的方程数量有限，可以直接枚举方程。

注意到：
- $-5 \cdot 3 + 8 \cdot 2 = 1$
- $8 \cdot 5 - 13 \cdot 3 = 1$
- $-13 \cdot 8 + 21 \cdot 5 = 1$
- $21 \cdot 13 - 34 \cdot 8 = 1$
- ……

即 $f_i f_{i - 1} - f_{i + 1} f_{i - 2} = (-1)^i$。  
（这里我们定义 $f_0 = 0$ 和 $f_{-1} = 1$）

所以 $f_i \cdot x + f_{i + 1} \cdot y = k$ 有通解 $x = k \cdot (-1)^i f_{i - 1}$、$y = k \cdot (-1)^{i + 1} f_{i - 2}$，根据通解，可以瞎模得出正整数解的个数。

代码：

```cpp
#include<cstdio>
int n,ans;
long long tx,ty,fx,fy,sx,sy;
int main(){
    scanf("%d",&n);
    for(int p0=1, p1=1, x=0, y=1; p0+p1<=n; p1=p0+p1, p0=p1-p0, x=y-x, y=y-x){
        tx=1ll*x*n, ty=1ll*y*n;
        fx=tx%p1; if(fx<=0) fx+=p1; fy=ty-(fx-tx)/p1*p0;
        sy=ty%p0; if(sy<=0) sy+=p0; sx=tx-(sy-ty)/p0*p1;
        if(fy<=0||sx<=0) break;
        ans=(ans+(sx-fx)/p1+1)%1000000007;
    }
    printf("%d",ans);
}
```

---

## 作者：浅色调 (赞：46)

 $\quad$一道趣味数学题，想了有快40多分钟。。。

 $\quad$本题可以枚举系数用扩展欧几里德求解通解，然后求正整数解个数，显然当某次无整数解时，再往后也不会再有正整数解了（很简单的道理，等下我的方法里有解释）。

 $\quad$讲讲我的算法，个人认为上述的方法简单些，但是我想到一个很特殊的斐波拉契的性质 $f[i]*f[i+3]-f[i+1]*f[i+2]=(-1)^{i-1}$于是入坑用了一个稍微复杂但绝对好理解的算法。
### 思路：
 $\quad$题意是给定一个k，问有多少个$f[1]=a$,$f[2]=b$，使得k出现在该斐波拉契数列中。

 $\quad$等价于求解 $a+b=k$、$a+2b=k$、$2a+3b=k$、$3a+5b=k$…的以相邻两项斐波拉契数为系数的不定方程的正整数解的个数。
 $\quad$因为题目中说道a、b≥1,所以当斐波拉契数的某相邻两项$f[i]+f[i+1]>k$时便可不用在求不定方程了（显然无正整数解）。

 $\quad$于是可以枚举相邻的两项斐波拉契数作系数，然后累加正整数解的个数。

$\quad$我们由裴蜀定理可知： $$ax+by=c \quad a,b,c\in Z*$$

 $\quad$有整数解的充要条件是： $$gcd(a,b)|c$$

 $\quad$证明：

   $\because \quad$ $a=pgcd(a,b),\quad$ $b=qgcd(a,b)\quad$
   
$\therefore \quad ax+by=pgcd(a,b)x+qgcd(a,b)y=(px+qy)*gcd(a,b)=c$ 
    
$\because \quad$ $(px+qy),gcd(a,b)\in Z*$

$\therefore \quad$ $gcd(a,b)|c$


 $\quad$不妨设$x,y$为 $ax+by=c$ 的一组解，则由解$x,y$可推出其它解为：

　　$x1=x+\frac{b}{gcd(a,b)}*t,\quad$ $y2=x-\frac{a}{gcd(a,b)}*t\quad,t\in Z*$

　　证明：

　　$\because \quad ax+by=c$

　　$\therefore \quad ax+by+\frac{ab}{gcd(a,b)}*t-\frac{ab}{gcd(a,b)}*t=c$

　　$\therefore \quad a(x+\frac{b}{gcd(a,b)}*t)+b(y-\frac{a}{gcd(a,b)}*t)=c$

　　$\therefore \quad$ $x1=x+\frac{b}{gcd(a,b)}*t,\quad$ $y2=x-\frac{a}{gcd(a,b)}*t\quad,t\in Z*$

　　

 $\quad$然后我们以斐波拉契中的相邻两项$f[i]$和$f[i+1]$为系数

 $\quad$不难发现$f[i]*f[i+3]-f[i+1]*f[i+2]=(-1)^{i-1}$

 $\quad$证明：

 $\quad$设$f[i]=a,f[i-1]=b\quad$ 则$f[i+1]=a+b,f[i+2]=2a+b,f[i+3]=3a+2b$

$\quad$原式$=a*(3a+2b)-(a+b)*(2a+b)$

　　　　$=a^2-b^2-ab$

　　　　$=(a-b)(a+b)-ab$

　　　　$=f[i-2]*f[i+1]-f[i-1]*f[i]$

 $\quad$继续将新式子往下递归

$\quad$1、当$2|i$，必定递归到$f[0]*f[3]-f[1]*f[2]=-1$(注意到$f[0]$无意义，所以$f[0]=0$),所以i为偶数时$f[i]*f[i+3]-f[i+1]*f[i+2]=-1$

 $\quad$2、否则，必定递归到$f[1]*f[4]-f[2]*f[3]=1$,所以i为奇数时$f[i]*f[i+3]-f[i+1]*f[i+2]=1$

　　$\therefore \quad$ $f[i]*f[i+3]-f[i+1]*f[i+2]=(-1)^{i-1}$

 
 $\quad$有了上面这个性质，易得题目中的$f[i]x+f[i+1]y=k$必定有通解：

　　$x=(-1)^{i-1}*k*f[i+3],\quad$ $y=(-1)^{i}*k*f[i+2]$

 $\quad$然后易得斐波拉契数列的相邻两项$f[i]$和$f[i+1]$互质，即$gcd(f[i],f[i+1])=1$,　　

 $\quad$证明（由欧几里德定理）：

$\because \quad gcd(f[i],f[i+1])=gcd(f[i],f[i+1]-f[i])=gcd(f[i],f[i-1])…=gcd(f[1],f[2])=1$ 

$\therefore \quad$ $gcd(f[i],f[i+1])=1$
 $\quad$于是由上述性质可知：

　　$f[i]x+f[i+1]y=k$的整数解为$x1=(-1)^{i-1}*k*f[i+3]+f[i+1]*t,\quad$ $y1=(-1)^{i}*k*f[i+2]-f[i]*t,\quad t\in Z*$

$\quad$显然由于$(-1)^{i-1},(-1)^{i}$中必定有一个为-1，于是$x$和$y$中有且仅有一负数。

$\quad$1、当$x<0$，先使x变为最小整数解。

$\quad$ 则xmin $=x+(\frac{\left| x\right|}{f[i+1]}+1)*f[i+1]$

 $\quad$则ymax $=y-(\frac{|x|}{f[i+1]}+1)*f[i]$

 $\quad$此时求其它正整数解时$x$单调递增，$y$单调递减。

 $\quad$ $\therefore \quad$ 此时的正整数解的个数$=\lceil \frac{ymax}{f[i]} \rceil$

$\quad$2、当$y<0$，和上面同理知此时的正整数解个数$=\lceil \frac{xmax}{f[i+1]} \rceil$

　　

#### $\quad$按照上述方法本题便能完美的解决。

$\quad$由于斐波拉契数最多到第90多项时就爆long long了，所以本题此方法复杂度O(n)，n≤92。

#### $\quad$欢迎来踩博客（转载请注明出处）[five20](http://www.cnblogs.com/five20/p/8684357.html)
### 代码：
```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
#define il inline
#define ll long long
using namespace std;

const ll mod=1e9+7;
ll f[100],x,y,n,i,ans;
int main()
{
    cin>>n;
    f[1]=f[2]=1;ans=n-1;
    for(i=3;i<=100;i++){f[i]=f[i-1]+f[i-2];if(f[i]>=n)break;}
    //cout<<i<<endl;
	for(int j=2;j<=i;j++){
		int q=pow(-1,j-1);
		x=n*q*f[j+3],y=-n*q*f[j+2];
		if(x<0){y-=(abs(x)/f[j+1]+1)*f[j];if(y>0)ans=ans+ceil(1.0*y/f[j]);ans%=mod;}
		else if(y<0){x-=(abs(y)/f[j]+1)*f[j+1];if(x>0)ans=ans+ceil(1.0*x/f[j+1]);ans%=mod;}
	}
    cout<<ans;
    return 0;
}
```


---

## 作者：GoldenPotato137 (赞：14)

蒟蒻博客：[QAQ](https://www.cnblogs.com/GoldenPotato/p/9587773.html)


------------
## Solution
这是一道很有意思的数论题。

首先，我们可以发现直接枚举a和b会T的起飞。

接下来，我们就可以观察一下式子了，我们略微手算一下，就会有这样的结果：

![QAQ](https://cdn.luogu.com.cn/upload/pic/31933.png)

我们可以发现，**a，b在每一项中的数量都可以用同一个斐波那契数列表示**。

我们可以用g[x]表示斐波那契数列的第x项，那么，我们可以得到$$f[x]=a*g[x-1]+b*g[x]$$

接下来，由常识可以知道，斐波那契数列的第40项就差不多有10^9那么大了。

所以说，我们可以考虑枚举当前项x，**问题就变为了有多少个a，b使得** $$K=a*g[x-1]+b*g[x]$$

移项得：$b=(K-g[x-1]*a)/g[x]$

**因为a，b都是整数，问题就变为了有多少个a，使得**$K-g[x-1]*a$能被$g[x]$整除

即：

![QAQ](https://cdn.luogu.com.cn/upload/pic/31934.png)

**对于斐波那契数列，有一个定理，就是f[x]与f[x-1]互质**（证明略复杂，在这里就不给出了），这样就保证了同余方程有解。

同时，我们还有一个限制，就是 K-g[x-1]*a > 0 (因为b>0)即 a<K/g[x-1] 的

由这两个式子，我们就可以求出对于每一个x，有多少个a，b可以使$K=a*g[x-1]+b*g[x]$

 .
 
.

 

酱紫，我们就可以AC这道题(≧∀≦)♪


------------
## Code
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int N=45;
const int n=40+2;
const int poi=1000000007;
long long f[N],K,ans;
long long exgcd(long long A,long long B,long long &x,long long &y)
{
    if(B==0)
    {
        x=1,y=0;
        return A;
    }
    long long temp=exgcd(B,A%B,x,y),tx=x;
    x=y,y=tx-(A/B)*y;
    return temp;
}
long long inv(long long A,long long POI)
{
    long long t,tt;
    exgcd(A,POI,t,tt);
    return (t%POI+POI)%POI;
}
int main()
{
    scanf("%lld",&K); 

    f[1]=f[2]=1;
    for(int i=3;i<=n;i++)
        f[i]=f[i-1]+f[i-2];
    for(int i=2;i<=n;i++)
    {
        long long a=(K*inv(f[i-1],f[i]))%f[i],to=K/f[i-1]-1;
        if(a<to)
        {
            if(a==0) ans--;
            ans=(ans+1+(to-a)/f[i])%poi;
        }
    }
    
    printf("%lld",ans);
    return 0;
}
```


---

## 作者：fanfan (赞：11)

题目大概是长成ax+by=k的形式，由于f[0]=a,f[1]=b,f[i]=f[i-1]+f[i-2] 所以可以看出在f[i]中a和b的系数是斐波那契中的相邻两项。

首先可以想到二分，对吧？但前提是要枚举a和b，这样显然不行，那么我么可以从斐波那契下手，枚举斐波那契相邻的两项，利用exgcd求出解的个数。此时依旧是对ax+by=k这个式子进行求解，此时的a等于f[i-1],b等于f[i],可以求出最小的正整数x，此时的y为最大值。可以此时的y满足

设此时的x为x0，则满足x=x0+tb,同理满足y=y0+ta，显然t+1就是此时的答案贡献，那么用最大的y除以a向上取整即可（注意之所以要向上取整而不是t+1，是因为避免y=0的情况，还有注意特判x0=0的情况） 下面附上代码


```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int mod=1e9+7;
ll f[100],cnt,k;
void exgcd(ll a,ll b,ll &x,ll &y)
{
    if(b==0)
    {
        x=1;y=0;
        return;
    }
    exgcd(b,a%b,x,y);
    ll t=x;
    x=y;
    y=t-a/b*y;
} 
int main()
{
    scanf("%lld",&k);
    f[1]=f[2]=1;cnt=2;
    for(int i=3;;i++)
    {
        f[i]=f[i-1]+f[i-2];
        if(f[i]>1e9) break;
        ++cnt;
    }
    ll ans=0;
    for(int i=2;i<=cnt;++i)
    {
        ll a,b,x,y;
        a=f[i-1];b=f[i];
        exgcd(a,b,x,y);x=x*k;y=y*k;
        x=(x%b+b)%b;
        if(x==0) x=b;
        y=(k-a*x)/b;
        if(y<0) continue;
        ans=(ans+(y-1)/a+1)%mod;
    }
    printf("%lld",ans);
}
```

---

## 作者：JackMerryYoung (赞：7)

# 前言

~~很水的蓝题，看到没什么题解，来发一篇。~~

本题做法大致有两种：

一种是使用整除性质，同余扩欧求逆元，观察柿子得出上下界，再求符合条件的解个数做法（小学奥数乱搞法）。

另一种是利用 ~~肥波垃圾~~ 斐波那契数列性质，去求通解，再求不定方程解个数法（~~本人看不懂~~ 高中代数法）。

因为本人是初中生，所以只讲第一种...

# 正文

观察一下题目可知大意：

给定 $1 \le K \le 10^9 $，求 $A, B \in Z^+$，满足：

$$
A \cdot f_i + B \cdot f_{i - 1} = K
$$

其中，$f_i$ 表示斐波那契数列第 $i$ 项，这里规定：

$$
f_i = \left \{\begin{array}{lc} 1 &(i \; \leq \; 2) \\ f_{i - 1} + f_{i - 2} & (i \; \geq \; 3) \end{array} \right.
$$

我们不妨针对每个 $i \ge 2$ 都求一遍有几个解。

至于为什么是对的，即为什么不会有重复解，很简单，这里我们使用反证法：

先设有 $i \neq j$，使得：

$$
\left \{\begin{array}{l} A = B \\ A \cdot f_i + B \cdot f_{i - 1} = A \cdot f_j + B \cdot f_{j - 1} = K \end{array} \right.
$$

$\because$ 斐波那契数列任意两个不同项的值不同，

$\therefore \left \{\begin{array}{l} f_i \neq f_j \\ f_{i - 1} \neq f_{j - 1} \end{array} \right.$

$\therefore$ 显然，假设不成立。

$\therefore$ 原命题得证。

但是，我们又如何求呢？

这里介绍一种非常简单的方法，我称之为：整除同余枚举法。

思路非常简单。

我们考虑枚举。但有两个未知数，而且上下界不好搞，怎么办？

针对 $A \cdot f_i + B \cdot f_{i - 1} = K$ 的情况，我们不妨利用题目中给的 $A, B \in Z^+$ 的条件，去把方程化成一个正整数等于两个正整数相除的形式。

因此我们移项，得：

$$
B \cdot f_{i - 1} = K - A \cdot f_i 
$$

易知 $f_{i - 1} \ge 1 \ne 0 \quad (i \ge 2) $，于是等号两边同除以 $f_{i - 1}$，可得：

$$
B = \frac{K - A \cdot f_i}{f_{i - 1}}
$$

观察柿子，结合同余得：

$$
K - A \cdot f_i \equiv 0 \pmod{f_{i - 1}}
$$

移项，得：

$$
K \equiv A \cdot f_i \pmod{f_{i - 1}}
$$

易知：

$$
A \equiv K \cdot inv(f_i) \pmod{f_{i - 1}}
$$

这里证明两个引理。

引理 1：对于所有 $a, b \in Z^+$，都有：

$$
\gcd(a, b) = \gcd(b, a - b)
$$

证明：

$\because$ 当 $b \mid c$ 时，$\gcd(a, b) = \gcd(a + c, b)$ [知乎某大神证明](https://www.zhihu.com/question/386209132)

$\therefore \gcd(a, b) = \gcd(a - b, b) = \gcd(b, a - b)$

证毕。

引理 2：对于所有 $i \ge 2$，都有：

$$
\gcd(f_i, f_{i - 1}) = 1
$$

证明：


设 $\gcd(f_i, f_{i - 1}) = d$，可知：

$$
d = \gcd(f_{i - 1}, f_i - f_{i - 1})
$$

即：

$$
d = \gcd(f_{i - 1}, f_{i - 2})
$$

若一直进行，则有：

$$
d = \gcd(f_2, f_1) = 1
$$

即：

$$ 
\gcd(f_i, f_{i - 1}) = 1
$$

证毕。

$\because$ $\gcd(f_i, f_{i - 1}) = 1$。

$\therefore$ 扩欧求 $f_i$ 的逆元即可。

那么，这样一来，$A$ 的上下界确定了：

$$
inv(f_i) \le A < \lfloor \frac{f_i}{K} \rfloor
$$

我们可以 $\mathcal{O}(1)$ 出答案：

$$
ans = \large\sum^{f_i + f_{i - 1} \le K}_{i = 2}{\lfloor \frac{\lfloor \frac{f_i}{K} \rfloor - 1 - inv(f_i)}{f_{i - 1}}\rfloor}
$$

# 代码

~~你们最想要的..~~ 

Talk is$\color{white}\text{n't}$ cheap, $\color{white}\text{Don't}$ show me the code..

``` cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

ll K, cnt, ans = 0;
ll fibo[105];
const ll MOD = (ll) (1e9 + 7);

ll extgcd(ll a, ll b, ll &x, ll &y)
{
	if(!b)
	{
		x = 1ll;
		y = 0ll;
		return a;
	}
	else
	{
		ll tmp = extgcd(b, a % b, y, x);
		y -= x * (a / b);
		return tmp;
	}
}

ll inv(ll a, ll p)
{
	ll x, y, tmp;
	x = y = 0;
	tmp = extgcd(a, p, x, y);
	if(tmp == 1) return (x + p) % p;
	else return -1;
}

int main()
{
	cin >> K;
	fibo[1] = fibo[2] = 1ll;
	for(cnt = 3ll; ; ++ cnt)
	{
		fibo[cnt] = fibo[cnt - 1ll] + fibo[cnt - 2ll];
		if(fibo[cnt] + fibo[cnt - 1] > K) 
			break;
	}

	for(ll i = 2ll; i <= cnt; ++ i)
	{
		ll _a = fibo[i], _b = fibo[i - 1];
		ll a = ((K % _a) * inv(_b, _a)) % _a;
		ll top = K / _b - 1;
		if(a < top)
		{
			ans += (top - a) / _a;
			if(a != 0)
				++ ans;

			ans %= MOD;
		}
	}

	cout << ans << endl;
	return 0;
}
```

# 后言

本来无话可说，但还是说一下：

本人没写第二种做法，真的是不会写，太难懂了（对于我而言，大佬轻喷），所以就没深入研究，请见谅。

~~不过既然有简单的算法，干嘛用复杂的呢？~~

---

## 作者：夏色祭 (赞：7)

人生中第二次自己做出数学题。

我们可以用含a和b的代数式表示出$f(i)$

那么$f(i)=ax+by$

那么题目就变形成了求不定方程ax+by=k的正整数解

x,y可以用斐波那契拉数列先求出，然后再对每个x,y搞。

显然当$gcd(a,b)|k$不成立时，方程无整数解，这种情况直接舍去；

否则，我们先用扩欧搞出一组整数解，然后再利用通解求出正整数解的个数，当然有些小细节要注意（可以看我代码）。

代码：

```cpp
#include<cstdio>
#define For(i,x,y) for (int i=(x);i<=(y);i++)
#define ll long long
#define il inline
using namespace std;
const int mod=1e9+7;
ll ans,f[1000][2],x,y,t,k,l,r;
il ll gcd(ll a,ll b){return !b?a:gcd(b,a%b);} 
il ll exgcd(ll a,ll b,ll &x,ll &y){
    if (!b) return x=1,y=0,a;
    ll t=exgcd(b,a%b,x,y),tmp=x;
    x=y,y=tmp-a/b*y;
    return t;
}
il ll max(ll x,ll y){return x>y?x:y;}
il ll sum(ll x,ll y){return max(0,x%y==0?x/y-1:x/y);}
il void swap(ll &x,ll &y){ll t=x;x=y,y=t;}
int main(){
    scanf("%lld",&k);
    f[0][0]=f[1][1]=1;
    For(i,2,1000){
        f[i][1]=f[i-1][1]+f[i-2][1];
        f[i][0]=f[i-1][0]+f[i-2][0];//上面说的x,y
        if (f[i][1]>k&&f[i][0]>k) break;//当x,y都大于k时方程肯定不存在正整数解
        ll a=f[i][1],b=f[i][0];
        if (k%gcd(a,b)==0){ //只有满足条件$gcd(a,b)|k$时方程才会有整数解
            t=k/exgcd(a,b,x,y);
            x=x*t,y=y*t;//先用拓欧搞一组解
            if (x<0||y<0){
                if (x<0) ans=(ans+max(0,sum(y,a)-(-x)/b))%mod;
                    else ans=(ans+max(0,sum(x,b)-(-y)/a))%mod;
            }
            else {
                if (x&&y) ans=(ans+sum(x,b)+sum(y,a)+1)%mod;
                else if (!x) ans=(ans+max(0,y%a==0?y/a-1:y/a))%mod;
                else ans=(ans+max(0,x%b==0?x/b-1:x/b))%mod;
```
}//用通解乱搞出正整数解的个数
```cpp
        }
    }
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：是个汉子 (赞：6)

#### 思路

当我刚开始看到这个题的时候，还没有什么思路，但是当我列出了几个关于 $a,b,k$ 的式子：
$$
a+b=k,a+2b=k,2a+3b=k,3a+5b=k\dots
$$
可能还不太明显，仔细观察 $a,b$ 的系数，可以发现，这不就是斐波那契数列吗！！！

那么我们设 $f(x)$ 为斐波那契数列的第 $x$ 项，那么可以转化为：
$$
f(0)*a+f(1)*b=k,f(1)*a+f(2)*b=k
$$
$$
f(2)*a+f(3)*b=k\dots f(x-1)*a+f(x)*b=k
$$
那么我们就可以枚举 $x$ 。

然后，移项，可得：
$$
b=\dfrac{k-f(x-1)*a}{f(x)}
$$
由于 $b$ 为整数，所以相当于求多少 $a$ 可以使得 $f(x)|k-f(x-1)*a$ 成立，即：
$$
k-f(x-1)*a\equiv 0~(mod~f(x))
$$
$$
f(x-1)*a\equiv k~(mod~f(x))
$$
$$
a\equiv k*inv(f(x-1))~	(mod~f(x))
$$
由于 $f(x)$ 和 $f(x-1)$ 互质（这里就不证明了），可以直接扩欧干上去求逆元，然后差不多了

（**小trick**：因为 $k-f(x-1)*a>0$ 即 $a<\dfrac{k}{f(x-1)}$，所以可以枚举的更少了）

---

## 作者：HRLYB (赞：4)

>[P3986 斐波那契数列](https://www.luogu.org/problem/P3986)
>
>[更好的阅读体验](https://blog.csdn.net/qq_44765711/article/details/102688064)  


### 题目描述

定义一个数列：$f(1)=a,f(2)=b,f(n\:(n>1)\:)=f(n-1)+f(n-2)$，其中$a,b$均为正整数，问有多少种$(a,b)$使得$K$出现在数列中且不是前两项. 输出需要$mod \:1e9+7$.

### 题目分析


我们由题目条件可以得到若干个等式

$$f_j+f_{j+1}=K(j>=0)$$

我们要求的就是使得上面这个等式被满足的$f_0,f_1$的数量，这是一个**计数问题**.

--------

**1.斐波那契数列**：

由斐波那契数列的矩阵形式我们可以知道，斐波那契数列的第$i$项可以如是表示

$$\begin{bmatrix}
f_n\ f_{n-1}\ 
\end{bmatrix}*\begin{bmatrix}
1 & 1\\ 
1 & 0
\end{bmatrix}=\begin{bmatrix}
f_{n+1}\ f_n\ 
\end{bmatrix}$$

也就是

$$\begin{bmatrix}
f_1\ f_{0}\ 
\end{bmatrix}*\begin{bmatrix}
1 & 1\\ 
1 & 0
\end{bmatrix}^{n-1}=\begin{bmatrix}
f_{n}\ f_{n-1}\ 
\end{bmatrix}$$

也就是说，**斐波那契数列的第$i$项只与第0项和第1项有关**，设$f_0=1,f_1=1$的斐波那契数列第$i$项为$f_i$，$f_0=a,f_1=b$的斐波那契数列第$i$项为$g_i$，那么我们可以得到

$$g_i=f_{i-2}*a+f_{i-1}*b$$

现在，问题就转化成了求满足不定方程$K=f_{i-2}*a+f_{i-1}*b$的方案数.

首先发现$f_{i-1},f_{i-2}$发现这个东西显然可以**枚举**，因为斐波那契数列小于等于$1e9$的项只有大约$40$项左右. 那么我们就枚举斐波那契数列的第$i(i<=40)$项，然后对于构成的不定方程分别求合法方案数即可.

------

**2.求不定方程的特殊解**：

要求不定方程的合法解，首先要求出不定方程的一组通解. 我们有一个结论：**斐波那契数列的任相邻两项都是互质的**（窝不会证）. 所以对于每一个不定方程$K=f_{i-2}*a+f_{i-1}*b$，都一定能求出特殊解$(a_1,b_1)$.

~~实际上就算不知道这个结论，在程序里多写一个特判同样没有问题.~~ 

不定方程的特殊解怎么求？当然是用拓展欧几里得.

设$A=f_{i-2},B=f_{i-1},X=a,Y=b$ ，我们要做的就是**先求出不定方程$1=AX+BY$的一组解$(X,Y)$，那么$a,b$的一组特殊解$(a_1,b_1)=(K*X,K*Y)$**

>关于不定方程的一组解：假设我们求出了不定方程$ax+by=gcd(a,b)$的一组解$(x_1,y_1)$，
>那么对于一个不定方程$ax+by=K,K|gcd(a,b)$，设$w=K/gcd(a,b)$，那么这个不定方程同样有一组解$(x_1*w,x_2*w)$

-------

**3.求不定方程通解&通解数量**：

求出了一组解之后，我们要做的就是求出通解的表示方式. 而要求这个表示方式，自然就要先求通解间隔.

由上面的分析，我们现在已经求出了不定方程$ax+by=k$的一组特殊解$(x_1,y_1)$. 设对于这个不定方程中的$x$，通解间隔为$p$，对于$y$的通解间隔为$q$，那么我们显然有

$$a(x_1+p)+b(y_1+q)=k$$

联立$ax_1+by_1=k$得

$$ap=-bq$$

也就是

$$p=-\frac{b}{a}*q$$

由于$p,q$都是整数，$gcd(a,b)=1$，所以对于$y$的最小通解间隔为$q=a$. 同理对于$x$的最小通解间隔为$p=b$. 也就是对于以上的不定方程，$(x_1+bn,y_1-an)$也是一组解（**简记为“一减一加”**）.

对应题目的不定方程，$(K*X+f_{n-2}*n,K*Y-f_{n-1}*n)$也是一组解. 而根据题目意思，对于一组可行解$(x,y)$，$x,y$都要大于0（题目要求的正整数的条件）. 我们只需要求出满足$(x,y)$大于0的解的数量即可.

----------

到这里整道题就做完了. 不要忘记取模.

另外，有没有可能出现同样的解$(a,b)$出现了两次的情况呢？答案是否定的，因为这需要

$$af_i+bf_{i-1}=af_j+bf_{j-1},i!=j$$

由于斐波那契数列任两项不相等，所以以上式子是不成立的.

### 程序实现

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll mod=1e9+7;
ll n,gcd,x,y,f[60],ans;
ll exgcd(ll a,ll b){
	if(!b){
		x=1,y=0;
		return a;
	}
	ll ret=exgcd(b,a%b);
	ll z=x;x=y;y=z-a/b*y;
	return ret;
}//求对于每个不定方程的特殊解
int main(){
	scanf("%lld",&n);
	f[0]=1,f[1]=1;
	for(int i=2;i<=50;i++){
		f[i]=f[i-1]+f[i-2];
	} //K不会超过斐波那契数列第40项
	for(int i=1;f[i]<n;i++){
		gcd=exgcd(f[i-1],f[i]);
		x*=n,y*=n;
		if(x<=0){
			ll dex=-x/f[i]+1;
			x+=dex*f[i],y-=dex*f[i-1];//(x,y)要一起进退
		}//如果x<=0,把它加到大于0为止
		if(y<=0){
			ll dex=-y/f[i-1]+1;
			y+=dex*f[i-1],x-=dex*f[i];
		}//同理
		if(x<=0||y<=0)continue;//如果处理之后仍然找不到解，说明无解
		ans+=(y%f[i-1]==0)?y/f[i-1]:y/f[i-1]+1;
		//加上最多能取的数量（减多少减到0，由于这边减，另外一边是加，所以另外一边不用管）
		ans%=mod;
		ans+=(x%f[i]==0)?x/f[i]-1:x/f[i];//注意判断整除的情况
		ans%=mod;
	}
	printf("%lld\n",ans);
	return 0;
} 
```



---

## 作者：I_AK_CTS (赞：3)

题目简短，相信大家看懂了题目的意思了，那么我们切入正题。

## 思路分析
题目问我们有多少种 $a, b$ ，那么我们可以来枚举一下，发现一下它们中的规律。

$f(0)=a,f(1)=b,f(2)=a+b, f(3)=a+2b, f(4)=2a+3b……$

那么我们再整理一下这些数列的系数特点：

![](https://cdn.luogu.com.cn/upload/image_hosting/o6138862.png)

啊，这些系数不正好又能构成斐波那契数列吗？

那么我们就可以用两个数组， $dp1, dp2$ 来存储了。

找到系数特点，我们再来往后想。

设当 $f(j)$ 时 $dp1_j=n, dp2_j=m$ 。

我们假设当 $f(j)$ 等于 $k$ 时，那么我们可以发现我们可以写出如下式子：

$$
na+mb=k
$$

这个我们就更熟悉了，这个很明显能联想到裴蜀定理和扩展欧几里得。

所以我们再用扩展欧几里得分别求一下 $a, b$ 就大功告成啦。

综合一下我们的思路，就是：
1. 先求出系数，存储起来。
2. 运用扩展欧几里得，求出 $a, b$ ，然后判断两个解是否为正整数，然后更新计数器，如果不是正整数，那就啥也不干就可以啦。

那么根据上述内容我们就能写出代码了：
```cpp
#include <iostream>
#include <cmath>

using namespace std;
typedef long long ll;
ll dp[55];
const int M = 1e9 + 7;
void exgcd(ll a, ll b, ll &x, ll &y)
{
	if (b == 0)
	{
		x = 1;
		y = 0;
		return;
	}
	exgcd(b, a % b, x, y);
	ll tmp = x;
	x = y;
	y = tmp - a / b * y;
	return;
}
int main()
{
	ll n, k;
	cin >> k;
	n = 0;
	dp[1] = 1;
	dp[2] = 1;
	for (ll i = 3;; ++i, ++n)
	{
		dp[i] = dp[i - 1] + dp[i - 2];//为了节省空间，我将两个数组压为了一个数组，不过操作过程也是一样的。
		if (dp[i] > M)
		{
			break;
		}
	}
	ll cnt = 0;
	ll x, y;
	for (ll i = 2; i <= n; ++i)
	{
		ll a = dp[i - 1], b = dp[i];//根据表格可以得到，不过写两个数组是比较好想的，看个人喜好
		exgcd(a, b, x, y);
		x *= k;
		y *= k;
		x = (x % b + b) % b;//要转换成正整数
		if (x == 0)
		{
			x = b;//注意一定要为正整数，即便是0也不行，因为0不是正整数
		}
		y = (k - a * x) / b;
		if (y < 0)//如果另一个解不是正整数，那么我们就不能让计数器加一
		{
			continue;
		}
		cnt = (cnt + ceil(1.0 * y / a));//因为这里解的x,y只是系数为dp1[j],dp2[j]中的其中一个解，我们不能忘记其他的解
		cnt %= M;//别忘了取余
	}
	cout << cnt << endl;
	return 0;
}
```
这道题考查了大家对扩展欧几里得的灵活应用，希望大家看完题解后在纸上再次模拟一遍再写程序。

12月26日：抱歉各位，第一版发现一个问题，现在修复了，重新交了一遍，真是不好意思，下一次注意。

---

## 作者：bmatrix (赞：2)

我们把题目中给出的数列 $f$ 的各项用 $a$ 和 $b$ 一个个列出来：
$$a,b,a+b,a+2b,2a+3b,3a+5b,5a+8b\dots$$
用 $fib_i$ 表示斐波那契数列的第 $i$ 项（下标从 $0$ 开始），容易发现，$f(n)=fib_{n-2}\,a+fib_{n-1}\,b$。

所以问题就转化成了，求下列每个不定方程的正整数解的个数和：
$$fib_0\,a+fib_1\,b=k\\fib_1\,a+fib_2\,b=k\\fib_2\,a+fib_3\,b=k\\\dotsb$$

由于 $a,b$ 都是正整数，当 $fib_{i-1}+fib_i>k$ 时就不用再往下枚举了。而由于斐波那契数列呈接近指数增长，所以实际我们需要枚举的不定方程个数非常有限。

对于枚举到的不定方程，设 $c=fib_{i-1},d=fib_i$，我们要求出 $ac+bd=k$ 的正整数解个数。

假设我们现在求出了一个最小的 $b_0$，使 $b_0d<k$ 且 $c\mid k-b_0d$，那么，首先 $b_0$ 和对应的 $a_0$ 是第一组解，然后每隔 $\operatorname{lcm}(c,d)$ 个数就又出现一组解，所以总共有 $\left\lfloor\dfrac{k-b_0d-1}{\operatorname{lcm}(c,d)}\right\rfloor+1$ 组解。

而 $b_0$ 我们从 $1$ 开始暴力枚举就可以求出来，因为开始时 $fib$ 很小，很快就能枚举出答案，而往后 $fib$ 很大，没枚举几个就超过 $k$ 了，所以很难卡掉。

代码就非常简单了:
```cpp
#include<bits/stdc++.h>
#define endl '\n'
using namespace std;
typedef long long ll;
constexpr int p = 1e9 + 7;
ll k, fib[100];
ll gcd(ll a, ll b) {
    return b ? gcd(b, a % b) : a;
}
ll lcm(ll a, ll b) {
    return a / gcd(a, b) * b;
}
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    cin >> k;
    fib[0] = fib[1] = 1;
    int e = 1;
    for(; fib[e] + fib[e - 1] <= k; ++e)
        fib[e + 1] = fib[e] + fib[e - 1];
    ll ans = 0;
    for(int i = 1; i < e; ++i) {
        ll a = fib[i - 1], b = fib[i];
        ll x = 1;
        while((k - b * x) % a && k > b * x) ++x;
        if(k <= b * x) continue;
        ans = (ans + (k - b * x - 1) / lcm(a, b) + 1) % p;
    }
    cout << ans << endl;
    return 0;
}
```

---

## 作者：sto_yyrdxh_orz (赞：1)

## 题目大意：
求满足 $x+y=k, x+2y=k, 2x+3y=k, ...$ 解的个数取余 $10^9+7$ 的数。

## 题目分析：
我们可以从这个 $x+y=k, x+2y=k,2x+3y=k, ...$ 等式上面发现 $x$ 和 $y$ 的个数均为斐波那契数列，只是 $y$ 的数列开始的时候少了一个 $1$ ,所以 $y$ 的斐波那契数列总是比 $x$ 要往后一位，这样我们就得出了解题的思路。

## 思路

我们已知：

$f(0) = a$

$f(1) = b$

通过上面的等式我们可以得出：

$f(2)=1×a+1×b$

$f(3)=1×a+2×b$

$f(4)=2×a+3×b$

$f(5)=3×a+5×b$

$f(5)=5×a+8×b$

$...$

$f(n)=f(n-1)×a+f(n)×b$

接下来我们再来分析一下重点代码

```cpp
ll exgcd(ll a, ll b, ll &x, ll &y){
	if(b==0){
		x=1;
		y=0;
		return a;
	}
	ll d=exgcd(b, a%b, x, y);
	ll z=x;
	x=y;
	y=z-y*(a/b);
	return d;
}
```
上面是欧几里得算法，和 gcd 差不多。

不了解的点[这里](https://wenku.baidu.com/view/59090c454bd7c1c708a1284ac850ad02de8007c1.html)。

最后我们只需要套用我们所求出的公式就行啦。
#### 注意：
* 数据量较大，建议用 `long long`。

### 你们最喜欢的标程来啦！
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
//题目范围有点大，用long long比较好 
const int P=1e9+7;
//要取余的数字 
ll f[50]={0, 1, 1};
//斐波那契数组
ll read(){
	//快读，不用也行 
    int x=0, f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-'){
        	f=-1;
		}
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
ll exgcd(ll a, ll b, ll &x, ll &y){
	//欧几里得算法 
	if(b==0){
		x=1;
		y=0;
		return a;
	}
	ll d=exgcd(b, a%b, x, y);
	ll z=x;
	x=y;
	y=z-y*(a/b);
	return d;
}
int main(){
	ll k, n, x, y, ans;
	k=read();
	//快读 
	for(int i=3; ;i++, n++){ 
		//前两项在定义的时候就赋值过了，所以从3开始 
		//n与f数组的长度同步 
	 	f[i]=f[i-1]+f[i-2];
	 	if(f[i]>P){
	 		//赋值玩就跳出 
	 		break;
	 		//只需要赋值一部分，剩余的赋值也没用 
		}
	}
	for(int i=2;i<=n;i++){
		ll a=f[i-1];
		ll b=f[i];
		//根据我们分析的等式将a和b赋值 
		ll g=exgcd(a, b, x, y);
		x*=k;
		y*=k;
		x=(x%b+b)%b;
		if(x==0){
			x=b;
		}
		y=(k-a*x)/b;
		if(y<0){
			//继续下一个 
			continue;
		}
		ans=(ans+ceil(1.0*y/a));
		//向上取整
		ans%=P;
		//按照题目要求取余 
	}
	cout<<ans;
	//输出答案 
	return 0;
}
```

---

## 作者：int08 (赞：1)

# 前言
大佬们的方法看不懂，但是我还有小学奥数……
# Solution
先枚举：

$f(0)=a,f(1)=b,f(2)=a+b,f(3)=a+2b,f(4)=2a+3b,f(5)=3a+5b$……

所以容易得出:

$f(i)=F(i-1)a+F(i)b$。

（其中 $F(i)$ 表示斐波那契数列的第 $i$ 项）

而我们要求 $k=F(i-1)a+F(i)b$ 中解的数量，其实也就是**求所有不定方程的解的数量总和**。（显然不同方程的解不会重叠）

## 如何求数量

小学奥数教过我们：可以先枚举一个解，因为斐波那契数列相邻两项互质，就可以求解的总数了。

（也就是这样：$a_1=x,b_1=y$ 时成立，$a_2=x+F(i),b_2=y-F(i-1)$ 也成立）

但是，枚举一个解的时间，对于这道题数据，也会愉快地超时。

**但是有 exgcd 啊！**

详情见[此题](https://www.luogu.com.cn/problem/solution/P4777)还有我的代码。

现在时间够了吧？

# AC code
```cpp
#include<bits/stdc++.h>
#define ll long long 
using namespace std;
ll f[64],i,k,ans;
ll crt(ll x,ll y,ll z) //就是这里啦
{
	if(z==0) return x*y;
	if(z%x==0) return z;
	return crt(y%x,x,(((x-z)%x)+x)%x)/(y%x)*y+z;
}
int main()
{
	cin>>k;f[1]=1;f[2]=1;
	for(i=3;i<=60;i++)
	{
		f[i]=f[i-1]+f[i-2];
	}
	for(i=1;f[i+1]<k;i++) ans+=max((ll)0,(ll)(ceil(double((k-crt(f[i],f[i+1],k%f[i+1]))/f[i+1])/double(f[i]))));    //这行是求一个不定方程解数量的代码
	cout<<ans%1000000007;
	return 0;
}
```

注：解的总数~~显然~~在超长整形范围内，不用边算边模。

---

## 作者：YellowBean_Elsa (赞：1)

据说前几篇思路不凡的题解有些问题？反正我的思路很一般但是还没被 Hack 喵~

#### 首先

把 $f(n)$ 往后面写几项就会发现 $a$, $b$ 的系数即为普通的 Fibonacci 数列中的项，即
$$f(n)\,=\,fib(n-1) \cdot a + fib(n) \cdot b\,\,\, ···(* )$$
利用归纳法易证明。

所以我们考虑先枚举 $k$ 是数列第几项，记为 $n$，然后就剩下一个解普通不定方程的问题了（$a,b$ 是未知数）。

不用怕枚举会超时，因为 $10^9$ 以内的 Fibonacci 数列还挺短的，我打表打了出来：

```cpp
int fib[45]={0,1,1,2,3,5,8,13,21,34,55,89,144,
233,377,610,987,1597,2584,4181,6765,
10946,17711,28657,46368,75025,121393,
196418,317811,514229,832040,1346269,
2178309,3524578,5702887,9227465,14930352,
24157817,39088169,63245986,102334155,
165580141,267914296,433494437,701408733};
```
#### 解不定方程

先证一个引理：$\forall n \in N^* \gcd(fib(n),fib(n+1))=1$
	
Proof: 设 $\gcd(fib(n),fib(n+1))=d$，则 $d\,|\,fib(n+1)-fib(n)=fib(n-1) $，从而有$\gcd(fib(n),fib(n-1))\geq d$；

如此递归可得 $\gcd(fib(2),fib(1))\geq d$，遂 $d=1$。证毕。

根据引理，在 $(* )$ 中用 Bezout 定理可知方程一定有整数解。我们要做的就是求出正整数解的个数。

这个应该 easy 了吧，先用扩展欧几里德求出一组特解，然后调整 $a$ 找到 $a>0$ 且最小的一组解，从而算出正整数解的个数。

详见代码（有一些细节见注释）

```cpp
//coder: [AFO]-MOerGM*YB 
#include<bits/stdc++.h>
#define fu(i,a,b) for(register int i = a, I = (b) + 1; i < I; ++i)
#define fd(i,a,b) for(register int i = a, I = (b) - 1; i > I; --i)
#define int long long//偷懒（不过确实特解可能爆 int） 
using namespace std;
typedef long long ll;
const int N=5e6+10;
const int mod=1e9+7;
inline int read(){
    int x=0;char ch=getchar();
    while(!isdigit(ch))ch=getchar();
    while(isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();
    return x;
}int k,ans;
int fib[45]={0,1,1,2,3,5,8,13,21,34,55,89,144,
233,377,610,987,1597,2584,4181,6765,
10946,17711,28657,46368,75025,121393,
196418,317811,514229,832040,1346269,
2178309,3524578,5702887,9227465,14930352,
24157817,39088169,63245986,102334155,
165580141,267914296,433494437,701408733};
int u,v,x,y;
int exgcd(int a,int b,int &x,int &y){
	if(!b){x=1,y=0;return a;}
	int d=exgcd(b,a%b,x,y);
	int z=x;x=y,y=z-y*(a/b);
	return d;
}
signed main(){
	k=read();
	//(a,b) s.t. (\exist_n (n>=2) s.t. (k = f[n] = fib[n-1]*a + fib[n]*b)) (#) 
	fu(i,2,44){
		//n <- i in (#)
		u=fib[i-1],v=fib[i];
		exgcd(v,u,x,y);//a <- y, b <- x
		x*=k,y*=k;
		//上面求出了特解，下面是调整和计数 
		if(x>0)y+=v*((x-1)/u),x=(x-1)%u+1;
		//写这么奇怪是为了 u|x 时不挂
		else if(x==0)x=u,y-=v;
		//一定要小心这里！ 
		else y-=v*(1-x/u),x=x%u+u;
		//负数mod的时候有些奇怪，结果也是负的 
		if(y<=0)continue;//无解 
		else ans=(ans+1+(y-1)/v)%mod;
		//同理写这么奇怪是为了 v|y 时不挂
	}printf("%lld\n",ans);
    return 0;
}
```


---

## 作者：Benzenesir (赞：0)

首先，$Fib_{47}=2.971215073\times10^9$。

所以说我们把这个系数整出来，然后一个一个验就可以了。

这里用 `Ex-gcd` 就可以了，找到通解，然后算出正整数解的个数就可以了。

```
//#pragma GCC optimize(2)
#include <cstdio>
#include <cmath>
#include <iostream>
#include <cstring>
#include <algorithm>
#include <queue>
#include <vector>
#include <map>
#include <unordered_map>
#include <set>
#include <bitset>
#include <stack>
#include <tuple>
#define ll long long
#define fp(a,b,c) for(ll a=b;a<=c;a++)
#define fd(a,b,c) for(ll a=b;a>=c;a--)
#define pii pair<int,int>
#define pll pair<ll,ll>
#define inf 0x3f3f3f3f
#define int ll
#define base 127
#define mod 1000000007
#define cel(a,b) (a%b)?(a/b+1):a/b 

using namespace std;

inline int rd(){
	int x = 0, f = 1;char ch = getchar();
	while(ch < '0' || ch > '9'){if(ch == '-')f = -1;ch = getchar();}
	while(ch >= '0' && ch <= '9')x = (x<<1) + (x<<3) + (ch^48),ch = getchar();
	return x * f;}
inline ll lrd(){
	ll x = 0, f = 1;char ch = getchar();
	while(ch < '0' || ch > '9'){if(ch == '-')f = -1;ch = getchar();}
	while(ch >= '0' && ch <= '9')x = (x<<1) + (x<<3) + (ch^48),ch = getchar();
	return x * f;}

int exgcd(int &x,int &y,int a,int b){
	if(!b){
		x=1,y=0;return a;
	}
	int sum=exgcd(x,y,b,a%b);
	int t=x;
	x=y;
	y=t-a/b*y;
	return sum;
}

int k;
pii xs[100];

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0); 
	k=rd();
	xs[1]={1,0};
	xs[2]={0,1};
	fp(i,3,47){
		xs[i].first=xs[i-1].first+xs[i-2].first;
		xs[i].second=xs[i-1].second+xs[i-2].second;
	}
	ll ans=0;
	fp(i,3,47){
		int x,y;
		int gd=exgcd(x,y,xs[i].first,xs[i].second);
		int a=xs[i].first,b=xs[i].second;
		if(k%gd!=0) continue ;
		x*=(k/gd),y*=(k/gd);
		x=(x%b+b)%b;
		if(x==0)
			x=b;
		y=(k-(a*x))/b;
		if(y<0) continue ;
		(ans+=cel(y,a))%=mod;
	}
	cout << ans << endl;
	return 0;
} 
```


---


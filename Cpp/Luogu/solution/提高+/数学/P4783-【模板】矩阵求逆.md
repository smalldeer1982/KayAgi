# 【模板】矩阵求逆

## 题目描述

求一个 $N\times N$ 的矩阵的逆矩阵。答案对 ${10}^9+7$ 取模。

## 说明/提示

对 $30 \%$ 的数据有 $N\le 100$；  
对 $100 \%$ 的数据有 $N\le 400$，所有 $0 \le a_{i j} < {10}^9 + 7$。

## 样例 #1

### 输入

```
3
1 2 8
2 5 6
5 1 2```

### 输出

```
718750005 718750005 968750007
171875001 671875005 296875002
117187501 867187506 429687503```

## 样例 #2

### 输入

```
3
3 2 4
7 2 9
2 4 3```

### 输出

```
No Solution```

# 题解

## 作者：一只萌新 (赞：138)

[$\color{teal}{Blog}$](https://blog.csdn.net/qq_43653202/article/details/99976316)

[P4783 【模板】矩阵求逆](https://www.luogu.org/problem/P4783)

**题目描述**

求一个$N×N$的矩阵的逆矩阵。答案对$10^9+7$取模。

### 1.逆矩阵的定义

假设 $A$ 是一个方阵，如果存在一个矩阵 $A^{-1}$，使得

$$A^{-1}A=I$$
并且
$$AA^{-1}=I$$

那么，矩阵 A 就是可逆的，$A^{-1}$ 称为 A 的逆矩阵

### 2.逆矩阵求法 —— 初等变换法（高斯-约旦消元）

**0.高斯-约旦消元**

详见
[P3389 【模板】高斯消元法](https://www.luogu.org/problem/P3389)
题解部分

高斯约旦消元与高斯消元区别：

```
高斯消元 -> 消成上三角矩阵 

高斯-约旦消元 -> 消成对角矩阵 
```

约旦消元法的精度更好,代码更简单,**没有回带的过程** 

```cpp
void Gauss_jordan(){
	/***** 行的交换&加减消元 *****/ 
	for(re int i=1,r;i<=n;++i){	//正在处理第i行 
		r=i;
		for(re int j=i+1;j<=n;++j) 
			if(fabs(a[j][i])>fabs(a[r][i])) r=j;
		if(fabs(a[r][i])<eps){
			puts("No Solution");return;
		}
		if(i!=r) swap(a[i],a[r]);
		
		for(re int k=1;k<=n;++k){
		//每一行都处理  
			if(k==i) continue;
			double p=a[k][i]/a[i][i];
			for(re int j=i;j<=n+1;++j) a[k][j]-=p*a[i][j];
		} 
	}	
	
	//上述操作后会剩下对角矩阵,答案要除以系数    
	for(re int i=1;i<=n;++i) printf("%.2lf\n",a[i][n+1]/a[i][i]);
}

```

**1.矩阵求逆**

思路
* 求$A$的逆矩阵，把$A$和单位矩阵$I$放在一个矩阵里
* 对$A$进行加减消元使$A$化成单位矩阵
* 此时原来单位矩阵转化成逆矩阵

原理
$$A^{-1} * [AI] = [I A^{-1}] $$


举个栗子

求
$$\begin{bmatrix}2 & -1 & 0 \\-1 & 2 & -1 \\0 & -1 & 2\end{bmatrix}$$

首先
$$\begin{bmatrix}2 & -1 & 0 & 1 & 0 & 0 \\-1 & 2 & -1 & 0 & 1 & 0 \\0 & -1 & 2 & 0 & 0 & 1 \end{bmatrix}$$

对左边进行消元可得
$$\begin{bmatrix}2 & -1 & 0 & 1 & 0 & 0 \\ 0 & \frac{3}{2} & -1 & \frac{1}{2} & 1 & 0 \\0 & 0 & \frac{4}{3} & \frac{1}{3} &\frac{2}{3} & 1  \end{bmatrix}$$

此时已消成上三角矩阵，高斯消元开始回代，但约旦会消成对角矩阵
$$\begin{bmatrix}2 & 0 & 0 & \frac{3}{2} & 1 & \frac{1}{2} \\0 & \frac{3}{2} & 0 & \frac{3}{4} & \frac{3}{2} & \frac{3}{4} \\0 & 0 & \frac{4}{3} & \frac{1}{3} & \frac{2}{3} & 1\end{bmatrix}$$

最后每行除以系数

$$\begin{bmatrix}1 & 0 & 0 & \frac{3}{4} & \frac{1}{2} & \frac{1}{4} \\0 & 1 & 0 & \frac{1}{2} & 1 & \frac{1}{2} \\ 0 & 0 & 1 & \frac{1}{4} & \frac{1}{2} & \frac{3}{4} \end{bmatrix}$$
此时右半边即为所求


**2.细节**

1. 开long long（不要冒风险，乘法很容易溢出） 
2. 模意义下除以一个数等于乘上逆元，可用快速幂求逆元（费马小定理） 

$Code$

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#define re register
#define il inline
#define ll long long
using namespace std;

il ll read(){
    ll s=0,f=0;char c=getchar();
    while(c<'0'||c>'9') f=(c=='-'),c=getchar();
    while(c>='0'&&c<='9') s=(s<<3)+(s<<1)+(c^'0'),c=getchar();
    return f?-s:s;
}

const int N=405,mod=1e9+7;
int n;
ll a[N][N<<1];
il ll qpow(ll x,ll k){
	ll ans=1;
	while(k){
		if(k&1) ans=ans*x%mod;
		x=x*x%mod;
		k>>=1;
	}
	return ans%mod;
}

il void Gauss_j(){	
	for(re int i=1,r;i<=n;++i){
		r=i;
		for(re int j=i+1;j<=n;++j)
			if(a[j][i]>a[r][i]) r=j;
		if(r!=i) swap(a[i],a[r]);
		if(!a[i][i]){puts("No Solution");return;}
		
		int kk=qpow(a[i][i],mod-2);	//求逆元 
		for(re int k=1;k<=n;++k){
			if(k==i) continue;
			int p=a[k][i]*kk%mod;
			for(re int j=i;j<=(n<<1);++j) 
				a[k][j]=((a[k][j]-p*a[i][j])%mod+mod)%mod;
		} 
		
		for(re int j=1;j<=(n<<1);++j) a[i][j]=(a[i][j]*kk%mod);
		//更新当前行 如果放在最后要再求一次逆元,不如直接放在这里  
	}	
	
	for(re int i=1;i<=n;++i){
		for(re int j=n+1;j<(n<<1);++j) printf("%lld ",a[i][j]);
		printf("%lld\n",a[i][n<<1]);
	}
}
int main(){
	n=read();
	for(re int i=1;i<=n;++i)
		for(re int j=1;j<=n;++j)
			a[i][j]=read(),a[i][i+n]=1;
	
	Gauss_j();
    return 0;
}

```
网上浏览一圈头都要炸掉，线性代数太可怕了，定义好多

最后只看懂了这种方法

有什么问题欢迎评论区指出 ：）

参考文章

[线性代数之——矩阵乘法和逆矩阵](https://www.cnblogs.com/seniusen/p/9962935.html)

[逆矩阵的几种求法与解析(很全很经典)](https://wenku.baidu.com/view/b0525966f5335a8102d22078.html)

---

## 作者：cosmicAC (赞：62)

我数学太弱了，不知道我的做法为什么是对的。记得当初是看着某篇百度文库学习的。过了几个月AC这道题，发现原理忘得一干二净了。翻了半天发现找不到那篇文章了。希望有大佬能指出来源或者证明它的正确性。

既然我连自己的程序写了什么都不是非常懂，为什么还要写这篇题解呢？有三点原因：

1. 我的时间和空间常数都是普通高斯消元的一半（代码也差不多长），不用另添一个矩阵（即原地做法），实际也跑得飞快
2. 比各类神仙分解不知道短到哪里去了
3. 网上基本**找不到这个做法**

大致过程如下（代码和高斯消去差不多）

从大到小枚举所有右下角的方阵(即从(1,1)到右下角,从(2,2)到右下角,$\dots$一直到右下角的那一个元素)，

①找到当前方阵（假设是第k个）的主元

②将主元所在行、列与第k行、第k列交换，并且记录下交换的行和列

③把第k行第k个元素变成它的逆元（同时判无解：逆元不存在）

④更改当前行（乘上刚才那个逆元）

⑤对矩阵中的其他行做和高斯消元几乎完全一样的操作，**只有每行的第k列不一样，具体看代码**

⑥最后把第②步中的交换逆序地交换回去。

最后放代码：

```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
#define int64 long long
using namespace std;
const int64 mod=1e9+7;
int64 a[410][410];
int n,is[410],js[410];
void exgcd(int a,int b,int &x,int &y){
    if(!b)return x=1,y=0,void();
    exgcd(b,a%b,y,x);y-=x*(a/b);
}
int inv(int p){
    int x,y;exgcd(p,mod,x,y);
    return (x+mod)%mod;
}
void inv(){
    for(int k=1;k<=n;k++){
        for(int i=k;i<=n;i++) // 1
            for(int j=k;j<=n;j++)if(a[i][j]){
                is[k]=i,js[k]=j;break;
            }
        for(int i=1;i<=n;i++) // 2
            swap(a[k][i],a[is[k]][i]);
        for(int i=1;i<=n;i++)
            swap(a[i][k],a[i][js[k]]);
        if(!a[k][k]){
            puts("No Solution");
            exit(0);
        }
        a[k][k]=inv(a[k][k]); // 3
        for(int j=1;j<=n;j++)if(j!=k) // 4
            (a[k][j]*=a[k][k])%=mod;
        for(int i=1;i<=n;i++)if(i!=k) // 5
            for(int j=1;j<=n;j++)if(j!=k)
                (a[i][j]+=mod-a[i][k]*a[k][j]%mod)%=mod;
        for(int i=1;i<=n;i++)if(i!=k) // 就是这里不同
            a[i][k]=(mod-a[i][k]*a[k][k]%mod)%mod;
    }
    for(int k=n;k;k--){ // 6
        for(int i=1;i<=n;i++)
            swap(a[js[k]][i],a[k][i]);
        for(int i=1;i<=n;i++)
            swap(a[i][is[k]],a[i][k]);
    }
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            scanf("%lld",a[i]+j);
    inv();
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            printf("%lld%c",a[i][j],j==n?'\n':' ');
    return 0;
}
```


---

## 作者：bztMinamoto (赞：49)

[传送门](https://www.luogu.org/problemnew/show/P4783)

线性代数真的好珂怕……以下如果有漏洞欢迎指出……更多的建议去学习一下线代的说……

定义矩阵的三种初等行变换：

1.交换某两行

2.将某一行的所有元素乘上$k$($k\neq 0$)

3.将某一行的所有元素乘上$k$加到另一行去

每一个初等变换都对应一个初等矩阵，即矩阵$A$做某一线性变换等价于用一个对应的初等矩阵左乘$A$。若有一堆初等变换$1,2,...l$，对应的初等矩阵分别为$P_1,P_2,...,P_l$，那么经过这些线性变换后的矩阵即为$P_l....P_2P_1A=PA$（$P$为之前那堆东西的乘积）

对于一个矩阵$A$，$A$可逆的充分必要条件是$A$经过若干次初等行变换可以变成$E$（$E$即单位矩阵），即存在一个矩阵$P$使得$PA=E$，则$P=A^{-1}$

通过初等行变换使得$A$变为$E$并不困难，可以用高斯消元解决，先消成上三角矩阵，然后再消成对角矩阵

考虑怎么求出$P$，因为有$PA=E,PE=P$，如果我们同时维护两个矩阵$A,B$，令$B$一开始时等于$E$，在把$A$变为$E$的过程中对$B$也做相等的初等变换，那么当$A$变为$E$时，$B$也就变为了$P$（因为做初等行变换等价于被对应的初等矩阵左乘）

如果在高斯消元的过程中发现无法将$A$变为$E$，输出无解即可
```
//minamoto
#include<bits/stdc++.h>
using namespace std;
#define getc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
int read(){
    int res,f=1;char ch;
    while((ch=getc())>'9'||ch<'0')(ch=='-')&&(f=-1);
    for(res=ch-'0';(ch=getc())>='0'&&ch<='9';res=res*10+ch-'0');
    return res*f;
}
char sr[1<<21],z[20];int C=-1,Z=0;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
void write(int x){
    if(C>1<<20)Ot();if(x<0)sr[++C]='-',x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);sr[++C]=' ';
}
const int N=405,mod=1e9+7;
int n;
struct Matrix{
    int a[N][N];
    inline void clr(){memset(a,0,sizeof(a));}
    int* operator [](int x){return a[x];}
    void SWAP(int x,int y){for(int i=1;i<=n;++i)swap(a[x][i],a[y][i]);}
    //交换某两行
    void MUL(int x,int k){for(int i=1;i<=n;++i)a[x][i]=(1ll*a[x][i]*k%mod+mod)%mod;}
    //将某一行的所有元素乘上k
    void MD(int x,int y,int k){for(int i=1;i<=n;++i)a[x][i]=((a[x][i]+(1ll*a[y][i]*k%mod))%mod+mod)%mod;}
    //将某一行的所有元素乘上k加到另一行去
	void print(){
        for(int i=1;i<=n;++i){
            for(int j=1;j<=n;++j)write(a[i][j]);
            sr[++C]='\n';
        }
    }
}A,B;
int ksm(int a,int b=mod-2){
    int res=1;
    for(;b;b>>=1,a=1ll*a*a%mod)if(b&1)res=1ll*res*a%mod;
    return res;
}
int main(){
//	freopen("testdata.in","r",stdin);
    n=read();
    for(int i=1;i<=n;++i)for(int j=1;j<=n;++j)A[i][j]=read();
    for(int i=1;i<=n;++i)B[i][i]=1;
    for(int i=1;i<=n;++i){
    	//消成上三角矩阵 
        if(!A[i][i]){
            for(int j=i+1;j<=n;++j)if(A[j][i]){
                A.SWAP(i,j),B.SWAP(i,j);break;
            }
        }
        if(!A[i][i])return puts("No Solution"),0;
        //如果消着消着某一列没有数了，说明无解 
        B.MUL(i,ksm(A[i][i])),A.MUL(i,ksm(A[i][i]));
        for(int j=i+1;j<=n;++j)
        B.MD(j,i,-A[j][i]),A.MD(j,i,-A[j][i]);
    }
    //消成对角矩阵 
    for(int i=n-1;i;--i)for(int j=i+1;j<=n;++j)
    B.MD(i,j,-A[i][j]),A.MD(i,j,-A[i][j]);
    B.print();return Ot(),0;
}
```

---

## 作者：walk_alone (赞：32)

### 严格证明来了！

如果还不用学习线性代数的童鞋们，可以直接看下文的简化题解，跳过中间的证明；~~但是要是卑微的大学牲，建议还是康康吧（大雾）~~

## 完整证明版

需要以下前置知识：

1.矩阵的逆及其存在的判定方法

2.初等矩阵及其性质

### 矩阵的逆

由于我们在定义矩阵运算的时候只定义了数乘和矩阵乘法，而没有除法运算。和逆元的产生一样，我们为了定义出除法，我们采用乘一个数/矩阵得到单位 $1$/单位矩阵的方法，并定义这个数/矩阵为原数/原矩阵的乘法。

注：单位矩阵是一个除了主对角线为 $1$，其他全为 $0$ 的方阵。由于阶数不固定，因而有无穷多种单位矩阵。

$$ \begin{bmatrix} 1 & 0 & 0\\ 0 & 1 & 0\\ 0 & 0 & 1\\\end{bmatrix} $$

**定义：设 $A$ 为 $n$ 阶方阵，若存在$n$阶方阵 $B$，使得 $AB=BA=I$，则称 $B$ 为 $A$ 的逆，并称 $A$ 为可逆矩阵。** 记 $A^{-1}$ 为 $A$ 的逆。

若 $A$ 可逆，则逆唯一。

证明：若 $B$ 与 $C$ 都是 $A$ 的逆，由定义 $AB=BA=I$，$AC=CA=I$，则有：

$$ B=IB=(CA)B=C(AB)=CI=C$$

即 $B=C$。

有一种用行列式来判定和计算矩阵是否可逆的方法，过于繁琐，不适用于计算，只在此介绍。

定义：设 $n$ 阶方阵

$$
        \begin{bmatrix}
        a_{1,1} & a_{1,2} & a_{1,3} & \cdots & a_{1,n} \\
        a_{2,1} & a_{2,2} & a_{2,3} & \cdots & a_{2,n} \\
        \vdots & \vdots & \vdots & \ddots & \vdots \\
        a_{n,1} & a_{n,2} & a_{n,3} & \cdots & a_{n,n} \\
        \end{bmatrix}
$$

由 $A$ 的行列式 $|A|$ 中元素 $a_{ij}$ 的代数余子式 $A_{ij}$ 构成的如下 $n$ 阶方阵：

$$
        A^*=\begin{bmatrix}
        A_{11} & A_{21} & A_{31} & \cdots & A_{n1} \\
        A_{12} & A_{22} & A_{32} & \cdots & A_{n2} \\
        \vdots & \vdots & \vdots & \ddots & \vdots \\
        A_{n1} & A_{n2} & A_{3n} & \cdots & A_{nn} \\
        \end{bmatrix}
$$

称 $A^*$ 为 $A$ 的伴随矩阵，而 $A$ 可逆的充要条件为 $|A| \neq 0$，且

$$A^{-1}=\frac{A^*}{|A|}$$

此处证明需要用到行列式的性质，在此略去。

下文有更简单的判定和计算方法。

逆变换有一重要性质：若$A,B$均可逆，则$AB$也可逆，且$(AB)^{-1}=B^{-1}A^{-1}$。该性质可以反复利用，因此可以拓展到$k$个可逆行列式相乘：

$$(A_1A_2……A_k)^{-1}=A_k^{-1}A_{k-1}^{-1}……A_1^{-1}$$

### 初等矩阵

把单位矩阵进行一次初等行变换，就得到了初等矩阵。其中，初等行变换有以下三种：

1.交换矩阵的任意两行。

2.用一个非零整数 $k$ 乘矩阵的任意一行。

3.将矩阵中某一行乘以 $k$ 倍加到另外一行。

因此对于三阶单位矩阵 $I_3$

$$
        \begin{bmatrix}
        1 & 0 & 0 \\
        0 & 1 & 0\\
        -4 & 0 & 1 \\
        \end{bmatrix}
       \begin{bmatrix}
        0 & 1 & 0 \\
        1 & 0 & 0\\
        0 & 0 & 1 \\
        \end{bmatrix}
        \begin{bmatrix}
        1 & 0 & 0 \\
        0 & 1 & 0\\
        0 & 0 & 5 \\
        \end{bmatrix}
$$

均为初等矩阵。

由于初等行变换可逆（可以改过去又可以改回来），因此初等矩阵可逆。

证明：设 $E$ 为一初等矩阵，由于 $EI=E$，因此任意一个初等矩阵可以视为对 $I$ 矩阵的一种变换，使其变为 $E$ 矩阵。由于初等行变换可逆，则存在 $E$ 变换的逆变换 $F$，将 $E$ 矩阵变回 $I$，因此 $EF=I$，即 $E$ 可逆，且其逆为 $E$ 的逆变换。



------------
到此可以引出本题的证明了：

**方阵 $A$ 可逆，当且仅当 $A$ 行等价于 $I_n$** ，即 $A$ 经过若干次行变换可以变成 $I_n$。

充分性：由于 $A$ 可逆，则方程 $Ax=b$ 必有解，其中 $x,b$ 均为向量（求解只需要在等式两边左乘以 $A^{-1}$ 即可）。那么，对于解 $x$：

$$
        x=\begin{bmatrix}
        x_1\\
        x_2\\
        \vdots\\
        x_n\\
        \end{bmatrix}
$$

必可写出与 $A$ 等价的增广矩阵 $A'$（因为解一样）：

$$
        A'=\left[
    \begin{array}{cccc|c}
      1&&&&x_1\\
      &1&&&x_2\\
      &&\ddots\ && \vdots\\
      &&&1&x_n
    \end{array}
\right]
$$

那么原矩阵必与 $I_n$ 等价，否则无法化简成 $A'$

必要性：如果 $A$ 等价于 $I_n$，则 $A$ 是由若干次初等行变换得到。对于每次初等行变换都有一个对应的初等矩阵，那么这些操作可以被记作：

$$E_pE_{p-1}……E_1A=I_n$$

由矩阵逆的另一种定义，若 $A$ 可逆，则必存在一种能让 $A$ 回到 $I_n$ 的方法。考虑对上式两边左乘 $(E_pE_{p-1}……E_1)^{-1}$

$$((E_pE_{p-1}……E_1)^{-1}E_pE_{p-1}……E_1)A=(E_pE_{p-1}……E_1)^{-1}I_n$$

即 $A=(E_pE_{p-1}……E_1)^{-1}$，为可逆矩阵的乘积，因此 $A$ 可逆，且 $A^{-1}=E_pE_{p-1}……E_1$。因此，$A^{-1}$ 可以由 $E_1,E_2,……,E_p$ 依次作用于 $I_n$ 得到。

得证。

------------
### 接下来就是解法时间

我们把 $A$ 和 $I_n$ 置于同一矩阵中：

$$
        \begin{bmatrix}
        A & I_n
        \end{bmatrix}
$$

对其进行高斯-若尔当消元操作将$A$变换为$I_n$。由于是在同一矩阵中，因此$A$和$I_n$得到的操作都是一样的。我们只需要让前面的$A$变换为$I_n$，那么对于同一过程，$I_n$就会变成矩阵的逆。

用一张图来表示这个互相转化关系：

$$ A\stackrel{P}{\underset{P'}{\Leftrightarrow}}I_n\stackrel{P}{\underset{P'}{\Leftrightarrow}}A^{-1}$$

所以剩下的就是代码功夫了。代码附上：

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
const long long mod = 1000000007;
long long power(long long a,int x)//快速幂板子
{
    long long ans = 1;
    while(x)
    {
        if(x&1)
        {
            ans *= a;
            ans %= mod;
        }
        a *= a;
        a %= mod;
        x >>= 1;
    }
    return ans % mod;
}
long long a[405][805];
int main()
{
    int n, m;
    scanf("%d", &n);
    m = 2 * n;//矩阵的宽
    for (int i = 1; i <= n;i++)
    {
        for (int j = 1; j <= n;j++)
            scanf("%lld", &a[i][j]);
        a[i][i + n] = 1;//后面要跟上一个n阶单位矩阵
    }
    for (int i = 1; i <= n; i++)//高斯-若尔当消元的板子
    {
        int place = i;
        for (int j = i + 1; j <= n; j++)//找到绝对值最大的元素开始消元
            if(abs(a[j][i])>abs(a[place][i]))
                place = j;
        if (i != place)
            swap(a[i], a[place]);
        if(!a[i][i])//如果某行没有主元则A无法化为单位矩阵，无解
        {
            printf("No Solution");
            return 0;
        }
        long long inv = power(a[i][i], mod - 2);//本题加入的逆元特色
        for (int j = 1; j <= n; j++)
            if(j!=i)
            {
                long long multiple = a[j][i] * inv % mod;//等价于除以a[i][i]，消去其他行在第i列上的数，使之变成简化阶梯形矩阵
                for (int k = i; k <= m; k++)
                    a[j][k] = ((a[j][k] - a[i][k] * multiple) % mod + mod) % mod;
            }
        for (int j = 1; j <= m; j++)//由于此处需要简化阶梯型矩阵，要把原矩阵化为简化矩阵的必须操作。
        //“在使用高斯-若尔当消元的时候，计算机计算的时候通常采用回带法，而人操作的时候建议采用此法。”——《线性代数及其应用》
            a[i][j] = (a[i][j] * inv % mod);
    }
    for (int i = 1; i <= n;i++)
    {
        for (int j = n + 1; j <= m; j++)//只打印后面，前面的单位矩阵不要打出来了
            printf("%lld ", a[i][j]);
        printf("\n");
    }
    return 0;
}
```


---

## 作者：da32s1da (赞：23)

思路：在读入的$n$阶矩阵右侧加入一个**$n$阶单位矩阵**，然后做**高斯消元**，使读入的$n$阶矩阵化为$n$阶单位矩阵，此时右面加入的矩阵就为所求的逆。
```
#include<cstdio>
#include<iostream>
using namespace std;
typedef long long LL;
const int N=405;
const LL mod=1e9+7;
int n,m;
LL f[N][N<<1];
LL r,ret;
LL ksm(LL u,LL v){  //求逆元 
    ret=1;
    while(v){
        if(v&1)ret=ret*u%mod;
        u=u*u%mod;v>>=1;
    }
    return ret;
}
int main(){
    scanf("%d",&n);m=n*2;
    for(int i=1;i<=n;++i){
        for(int j=1;j<=n;j++)scanf("%lld",&f[i][j]);
        f[i][n+i]=1;  //单位矩阵 
    }
    for(int i=1;i<=n;++i){  //高斯消元板子 
        for(int j=i;j<=n;j++)
        if(f[j][i]){
            for(int k=1;k<=m;k++)
            swap(f[i][k],f[j][k]);  //先交换 
            break;
        }
        if(!f[i][i]){puts("No Solution");return 0;}  //判断是否有解 
        r=ksm(f[i][i],mod-2);  //求逆元 
        for(int j=i;j<=m;++j)  //更改当前行 
        f[i][j]=f[i][j]*r%mod;
        for(int j=1;j<=n;++j)  //更改其他行信息 
        if(j!=i){
            r=f[j][i];
            for(int k=i;k<=m;++k)
            f[j][k]=(f[j][k]-r*f[i][k]%mod+mod)%mod;
        }
    }
    for(int i=1;i<=n;++i,puts(""))
    for(int j=n+1;j<=m;++j)printf("%lld ",f[i][j]);
}
```

---

## 作者：ghj1222 (赞：15)

建议学习线性代数后食用此题...

我们对输入的矩阵进行初等变换~~(初等乱搞)~~，同时对一个单位矩阵进行相同的初等变换，最后将我们输入的矩阵变换成单位矩阵之后，那个单位矩阵就变成了我们输入的矩阵的逆矩阵

假设我们进行初等变换的初等矩阵乘起来是$P$，且我们输入的矩阵为$A$

则$AP=E$，则$A^{-1}AP=A^{-1}E$，则$P=A^{-1}$，也就是把初等变换矩阵乘起来(或者是说把它们乘上一个单位矩阵)得到的就是矩阵的逆矩阵

把$A$消成单位矩阵就要先把A大力消成上三角矩阵，高斯消元就能做

```cpp
#include <bits/stdc++.h>
#define p 1000000007
#define int long long
using namespace std;

int n;

//定义矩阵及其初等变换 
struct matrix
{
	int a[400][400];
	
	//矩阵第x行和第y行交换
	void change1(int x, int y)
	{
		for (int i = 0; i < n; i++)
			swap(a[x][i], a[y][i]);
	}
	
	//矩阵第x行乘以k
	void change2(int x, int k)
	{
		for (int i = 0; i < n; i++)
			(((a[x][i] *= k) %= p) += p) %= p;
	}
	
	//矩阵第x行加上第y行乘以k
	void change3(int x, int y, int k)
	{
		for (int i = 0; i < n; i++)
			(((a[x][i] += a[y][i] * k % p) %= p) += p) %= p;
	}
	
	void print()
	{
		for (int i = 0; i < n; i++)
			for (int j = 0; j < n; j++)
				printf("%lld%c", a[i][j], j == n - 1 ? '\n' : ' ');
	}
}a, b; 

int ksm(int x, int y = (p - 2))
{
	int ans = 1;
	while (y > 0)
	{
		if (y & 1)
			(ans *= x) %= p;
		(x *= x) %= p;
		y >>= 1;
	}
	return ans;
}

signed main()
{
	//输入
	scanf("%lld", &n);
	for (int i = 0; i < n; i++)
		for (int j = 0; j < n; j++)
			scanf("%lld", &a.a[i][j]);
	
	//把B赋值为单位矩阵 
	for (int i = 0; i < n; i++)
		b.a[i][i] = 1;
	
	//把A消为上三角矩阵
	for (int i = 0; i < n; i++)
	{
		if(a.a[i][i] == 0)
			for (int j = i; j < n; j++)
				if (a.a[j][i] != 0)
				{
					b.change1(i, j);
					a.change1(i, j);
					break;
				}
		if (a.a[i][i] == 0)//矩阵不是满秩的
		{
			printf("No Solution\n");
			return 0;
		}
		b.change2(i, ksm(a.a[i][i]));
		a.change2(i, ksm(a.a[i][i]));
		for (int j = i + 1; j < n; j++)
		{
			b.change3(j, i, -a.a[j][i]);
			a.change3(j, i, -a.a[j][i]);
		}
	}
	
	//把A消为单位矩阵 
	for (int i = n - 2; i >= 0; i--)
		for (int j = i +1; j < n; j++)
		{
			b.change3(i, j, -a.a[i][j]);
			a.change3(i, j, -a.a[i][j]);
		}
	
	b.print();
	return 0;
}
```

另外注意一个细节，要先对b乱搞，如果对a搞完了那么那个值就是1了，对b搞的那个值也变成1了

---

## 作者：Laser_Crystal (赞：6)

## 这是一道线性代数的好题
~~调死我这个大菜鸡了~~

如果您还不太清楚线性代数的话，那么我可以跟您讲一个笑话：

```
有人在盘点世界上吊死人最多的树
据说是美国还是法国的哪片森林里的
其实这完全是瞎扯
他们怕是不知道，有一种叫做“线性代数”的树
上面吊死的人远比那些树多得多
```

嗯嗯，笑话讲完了，我们来做题吧qwq

在看这篇题解之前，需要了解的芝士：
```
1.高斯-约旦消元法

2.矩阵的基本知识（矩阵的初等变换，单位矩阵等等）
```

应该都好理解的吧（至于我为什么不用高斯消元，是因为我个人认为，高斯消元的精度不是很高，代码有些长 ~~所以不好背~~ ）


----
首先来讲一讲什么是矩阵求逆

题目告诉我们一个矩阵$A$,让我们求得一个矩阵$B$，使得$AB=BA=I$。

那么问题来了，这个矩阵$I$是个smg？

矩阵$I$就是传说中的单位矩阵

这是一个$4\times4$的单位矩阵
$$I=\begin{bmatrix}1&0&0&0\\0&1&0&0\\0&0&1&0\\0&0&0&1\end{bmatrix} $$

看到了嘛，单位矩阵就是一条对角线上都是1，余都为0的矩阵。

说白了，就是求$B=I/A$这个东西

可惜好像矩阵运算里没有除法

我上面那个表达式也是不合法的

![](https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2094980929,1634554119&fm=26&gp=0.jpg)

~~然后我们就会用BFS（Baidu First Search）去找思路~~

**求逆思路：**

**1.把$A$和它等大的单位矩阵$I$放在一个矩阵里**

**2.对$A$进行高斯消元使$A$化成单位矩阵**

**3.此时原来单位矩阵转化成逆矩阵**

意不意外？惊不惊喜？

知道了具体的过程，我们就可以来~~搞事情~~了，把P3389的程序复制粘贴过来……

然后修改一下，加上右边的矩阵$I$，修改一下输出，然后……

## ${\color{Red}WA}$

是我沙雕了……两个题目的数据类型都不一样啊啊啊啊啊啊啊

高斯消元是$Double$的，但是这道题……$long\;long$……

还带着除法……

~~所以话说乘法逆元是个好东西~~

然后把数据类型改一下，写个~~龟速幂~~套乘法逆元，然后……

## ${\color{Red}WA}$

嘤嘤嘤嘤嘤嘤嘤嘤嘤嘤嘤嘤嘤嘤嘤嘤嘤嘤……

然后我~~借鉴~~了一下题解，发现是%运算的锅，因为这个很可能出现负数，然后就会${\color{Red}WA}$掉。

比如我的${\color{green}AC}$程序里有这个：

```cpp
a[j][k]=(a[j][k]%mod+mod)%mod;
```
和之前${\color{red}WA}$这个：
```cpp
a[j][k]%=mod;
```
是不一样的。

上面的那个确保了没有负数（~~Maybe~~）

所以说，**%这个运算最好用在膜拜管理员/神仙/巨佬中**，如果题目里有模数，那么……我多半会挂掉……

${\color{green}AC}$程序：
```cpp
#include <bits/stdc++.h>
using namespace std;
const long long mod=1e9+7;
long long a[500][1000];
long long IE(long long m,long long n)
{
  long long p=1;
  while(n)
  {
    if(n%2==1) p=(p*m)%mod;
    m=m*m%mod;
    n/=2;
  }
  return p%mod;
}
int main()
{
  long long n;
  cin>>n;
  for(int i=1; i<=n; i++)
    for(int j=1; j<=n; j++)
      cin>>a[i][j];
  for(int i=1; i<=n; i++) a[i][i+n]=1;
  for(int i=1; i<=n; i++)
  {
    int tx=i;
    for(int j=i+1; j<=n; j++)
      if(abs(a[j][i])>abs(a[tx][i])) tx=j;
    if(i!=tx)
    {
      for(int j=1; j<=n*2; j++)
        swap(a[i][j],a[tx][j]);
    }
    if(!a[i][i])
    {
      cout<<"No Solution";
      return 0;
    }
    int I=IE(a[i][i],mod-2);
    for (int j=1; j<=n; j++)
      if(j!=i)
      {
        long long t=a[j][i]*I%mod;
        for (int k=i; k<=n*2; k++)
        {
          a[j][k]-=a[i][k]*t;
          a[j][k]=(a[j][k]%mod+mod)%mod;
        }
      }
    for(int j=1; j<=2*n; j++)
      a[i][j]=a[i][j]*I%mod;
  }
  for(int i=1; i<=n; i++)
  {
    for(int j=n+1; j<=n*2; j++)
      cout<<a[i][j]<<" ";
    cout<<endl;
  }
}
```
就是这样子吧……线性代数真的是毒瘤……喵喵喵~~~

---

## 作者：YellowBean_Elsa (赞：5)

# LU分解也可以求逆矩阵

即把矩阵A分解成

一个对角线上元素都是1的下三角矩阵L和

一个上三角矩阵U的乘积

（关于LU分解及其求行列式和解线性方程组的功能，请参考[我的博客](https://www.luogu.com.cn/blog/Feliks-YB/solution-p3389)）

对于一个n阶矩阵A，若行列式 = 0，则无逆矩阵，“No Solution”;

行列式非0时，设其逆矩阵为X

则我们要解
$$AX=I$$
其中I为n阶单位矩阵
把X和I都拆成n列，X的第i列设为$n*1$矩阵$X_i$得矩阵方程组
$$ AX_i =(a_1,a_2…a_n)^T$$
其中$a_i=1$, $a_j=0 (j!=i)$

然后解n个线性方程组就好啦

因为系数矩阵A一直不变，所以我们只需进行一次LU分解，利用L，U解一个线性方程组是O（$n^2$）的（见文章开头处链接），解$n$个O（$n^3$）, 算上对A矩阵进行LU分解的O（$n^3$）,总复杂度O（$n^3$）

### 注意

这题要取模，操作时要小心，不要见祖宗，除法改成乘逆元

（由于$1e9+7$是经典的素数，逆元直接用费马小定理求就好了）

```cpp
//coder: Feliks Hacker of IOI == YB an AKer of IMO
//LU分解
//acknowledgement:
//https://blog.csdn.net/yang10560/article/details/77948021
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=500;
const int mod=1e9+7;
const int B=mod-2;
//求逆元
inline ll inv(ll x){
	ll res=1;int b=B;
	while(b){
		if(b&1)res=(res*x)%mod;
		b>>=1;
		x=x*x%mod;
	}return res;
}int n;
ll a[N][N],b[N];
ll l[N][N],u[N][N];
//LU分解：递推前两步 
inline void init(){
	for(int i=1;i<=n;i++){
		l[i][i]=1;
		u[1][i]=a[1][i];
		//特判 
		if(u[1][1]==0){
			puts("No Solution");
			exit(0);
		}
		l[i][1]=a[i][1]*inv(u[1][1])%mod;
	}
}//LU分解：行列交错递推 
inline void lu_div(){
	init();
	//递推式 
	//U[i][j] = A[i][j] - (for (k = 1 to i-1) L[i][k] * U[k][j])
	//L[j][i] = (A[j][i] - (for (k = 1 to i-1) L[j][k] * U[k][i])) / U[i][i]
	for(int i=2;i<=n;i++){
		for(int j=i;j<=n;j++){
			//递推U第i行 
			u[i][j]=a[i][j];
			for(int k=1;k<=i-1;k++)
				u[i][j]=(u[i][j]+mod-l[i][k]*u[k][j]%mod)%mod;
			//递推L第i列 
			l[j][i]=a[j][i];
			for(int k=1;k<=i-1;k++)
				l[j][i]=(l[j][i]+mod-l[j][k]*u[k][i]%mod)%mod;
			//特判 
			if(u[i][i]==0){
				puts("No Solution");
				exit(0);
			}
			l[j][i]=l[j][i]*inv(u[i][i])%mod;
		}
	}
}//求行列式的值 
inline ll det(){ 
	//det(A) = det(L * U) = det(L) * det(U) = det(U)
	ll res=1;
	for(int i=1;i<=n;i++)res=res*u[i][i]%mod;
	return res;
}ll z[N];
//L * Z = B
inline void solve_z(){
    for(int i=1;i<=n;i++){
        z[i]=b[i];
        for(int j=1;j<i;j++)
            z[i]=(z[i]+mod-l[i][j]*z[j]%mod)%mod;
    }
}
//U * X = Z
ll x[N];
inline void solve_x(){
    for(int i=n;i>=1;i--){
        x[i]=z[i];
        for(int j=n;j>i;j--)
        	x[i]=(x[i]+mod-u[i][j]*x[j]%mod)%mod;
        x[i]=x[i]*inv(u[i][i])%mod;
    }
}ll ans[N][N];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			scanf("%lld",&a[i][j]);
		}
	}lu_div();
	//行列式 = 0，无逆矩阵（其实不用这句，如果真是0求LU分解时就return 0了）
	if(det()==0){
		puts("No Solution");
		return 0;
	}for(int i=1;i<=n;i++){
		//解第i个方程组
		//初始化 
		memset(z,0,sizeof(z));
		memset(x,0,sizeof(x));
		memset(b,0,sizeof(b));
		b[i]=1;
		//调用解方程函数 
		solve_z();solve_x();
		//把结果存入ans矩阵的第i列 
		for(int j=1;j<=n;j++)
			ans[j][i]=x[j];
	}for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			printf("%lld ",ans[i][j]);
		}puts("");
	}
	return 0;
}
```

---

## 作者：Shikita (赞：3)

# 矩阵求逆
在线性代数里面，向量通过某个函数发生变化，从而生成另一个向量。

那个函数即对应着一种坐标轴的变换，通过坐标轴的变换，影响了向量的基底，而又因为坐标轴的变换，其他所有向量的变换方式皆与向量基底相同，那么我们可以根据基底的变换方式，理解矩阵乘法的本质

那么对于向量的坐标变换,就可以看做是一组向量乘一个变换方式，即两个矩阵相乘，而使变换后的向量通过与原变换相反的一次变换，就可以得到原来初始基底

讲了这么多，其实就是把初始向量
$\begin{bmatrix}1&0\\0&1\\\end{bmatrix}$ 

经过变换之后，变成了一格矩阵
$\begin{bmatrix}3&2\\4&6\\\end{bmatrix}$ 

那么对于任意的一组向量
$\begin{bmatrix}3\\5\\\end{bmatrix}$ ,
我们也可以把它进行这个变换，

即$\begin{bmatrix}3&2\\4&6\\\end{bmatrix}$ $*$ $\begin{bmatrix}2\\3\\\end{bmatrix}$ $=$ $\begin{bmatrix}12\\26\\\end{bmatrix}$

然后我们根据把向量反向变换，就可以知道矩阵的逆了

或者说，矩阵$A*A^{-1}=E$,即矩阵乘它的逆就为单位矩阵

我们可以根据高斯消元来求出一个上三角矩阵，当我们在不断把原矩阵消为上三角矩阵时，我们得到的另一个矩阵即为它的逆

Code
```
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
    int x=0;
    char c=getchar();
    bool flag=0;
    while(c<'0'||c>'9') {if(c=='-')flag=1;c=getchar();}
    while(c>='0'&&c<='9'){x=(x+(x<<2)<<1)+ c-'0';c=getchar();}
    return flag?-x:x;
}
const int N=405,mod=1e9+7;
int n;
struct Matrix
{
	int a[N][N];
	void Swap(int x,int y) {for(int i=1;i<=n;++i) swap(a[x][i],a[y][i]);}
	void cg(int x,int k) {for(int i=1;i<=n;++i) a[x][i]=(1ll*a[x][i]*k%mod+mod)%mod;}
	void update(int x,int y,int k) {for(int i=1;i<=n;++i)a[x][i]=((a[x][i]+(1ll*a[y][i]*k%mod))%mod+mod)%mod;}
	void print() {for(int i=1;i<=n;++i) {for(int j=1;j<=n;++j) printf("%d ",a[i][j]);printf("\n");}}
}A,B;
inline int inv(int a)
{
    int res=1,b=mod-2;
    for(;b;b>>=1,a=1ll*a*a%mod)if(b&1)res=1ll*res*a%mod;
    return res;
}
int main()
{
	n=read();
	for(int i=1;i<=n;++i) for(int j=1;j<=n;++j) A.a[i][j]=read();
	for(int i=1;i<=n;++i) B.a[i][i]=1;
	for(int i=1;i<=n;++i)
	{
		if(!A.a[i][i])
		{
			for(int j=i+1;j<=n;++j) if(A.a[j][i]) 
			{A.Swap(i,j),B.Swap(i,j);break;}
		}
		if(!A.a[i][i]) {printf("No Solution\n");return 0;}
		B.cg(i,inv(A.a[i][i])),A.cg(i,inv(A.a[i][i]));
		for(int j=i+1;j<=n;++j) B.update(j,i,-A.a[j][i]),A.update(j,i,-A.a[j][i]);
	}
	for(int i=n-1;i;--i) for(int j=i+1;j<=n;++j)
    B.update(i,j,-A.a[i][j]),A.update(i,j,-A.a[i][j]);
    B.print();
}
```

感谢[BZT巨佬](https://www.luogu.org/space/show?uid=41781)的讲解

~~深深感觉到自己的弱小~~

---

## 作者：神之右大臣 (赞：2)

我来一发从头讲起的题解：

首先谈到矩阵，那么就会想到线性代数，但我太蒟蒻了，所以并不想谈那么深，所以就只说说其中一部分；

首先说初等行变换：

　　1.用一个非0的数乘某一行

　　2.把其中一行的若干倍加到另一行上；

　　3.交换两行的位置;

当然，初等列变换的定义与初等行变换的定义类似，这里便不多说了；


接着说高斯消元：

　　一个矩阵通过初等变换后所能得到的矩阵叫做增广矩阵。

　　我们把阶梯型增广矩阵变换为简化形阶梯矩阵的过程就是高斯消元；

　　基本思想：对于一个未知量xi，找到一个xi的系数非0，但x1~xi-1的系数都是零的方程，然后用初等行变换把其他方程的xi的系数全部消成0；

　　在高斯消元完成后，若存在系数都是0，但常数不是0的情况，方程无解；

　　猪元(主元)：系数不全为0的行的个数就是主元的个数；

　　自由元：系数全为0，常数也是0的个数就是自由元的个数；

　　通常情况下：一道题并不会直接给出n个n元一次方程组。如果给了n+1个二元方程组，那么我们可以通过相邻两个方程做差，把它变成n个n元一次方程组，然后进行高斯消元求解；
  
 ```cpp
#include <bits/stdc++.h>
#define eps 1e-8
using namespace std;
double a[101][102];
int n;
bool GUASS()
{
	for(int i=1;i<=n;i++){
		for(int j=i;j<=n;j++){
			if(fabs(a[j][i])>eps){
				for(int k=1;k<=n;k++){
					swap(a[i][k],a[j][k]);
				}
				swap(a[i][n+1],a[j][n+1]);
				break;
			}			
		}
		for(int j=1;j<=n;j++){
			if(i==j) continue;
			double tmp=a[j][i]/a[i][i];
			for(int k=i;k<=n;k++){
				a[j][k]-=a[i][k]*tmp;
			}
			a[j][n+1]-=a[i][n+1]*tmp;
		}
	}
	for(int i=1;i<=n;i++){
		bool lala=0;
		for(int j=1;j<=n;j++){
			if(a[i][j]!=0){
				lala=1;
			}
		}
		if(lala==0){
			cout<<"No Solution";
			return 0;
		}
	}
	return 1;
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n+1;j++){
			scanf("%lf",&a[i][j]);
		}
	}
	if(GUASS()){
		for(int i=1;i<=n;i++){
			printf("%.2lf\n",a[i][n+1]/a[i][i]);
		}
	}
}
```


然后说一下矩阵的逆：

　　单位矩阵：主对角线的元素都是1，其余所有元素都是0；

　　矩阵的逆，故名思意，就是矩阵的逆元啊~(这思不出来吧？)，而逆元的作用便是化除法为乘法；

　　注意：一个存在逆矩阵的矩阵叫做可逆矩阵；AB=BA=E ，则我们称B是A的逆矩阵，其中E是单位矩阵；

　　特点：一个可逆矩阵，它的逆矩阵是唯一的;

　　条件：可逆矩阵一定是正方形，两个可逆矩阵的乘积依然可逆。

　　作用：求X=A/B; (X*B=A，X*B*(B的逆矩阵)=A*(B的逆矩阵)，X=A*(B的逆矩阵))；(任何矩阵*单位矩阵=单位矩阵)

　　方法：在读入的n阶矩阵右侧加入一个n阶单位矩阵，然后做高斯消元，使读入的n阶矩阵化为n阶单位矩阵，此时右面加入的矩阵就为所求的逆。
  
  ```cpp
#include <bits/stdc++.h>
#define p 1000000007
#define inc(i,a,b) for(register int i=a;i<=b;i++)
using namespace std;
int n;
int a[1000][1000];
long long KSM(long long a,long long b)
{
	long long res=1;
	while(b){
		if(b&1) res=res*a%p;
		a=a*a%p;
		b/=2;
	}
	return res%p;
}
int Gauss()
{
	inc(i,1,n){
		inc(j,i,n) if(a[j][i]) {swap(a[j],a[i]);break;}
		if(a[i][i]==0){cout<<"No Solution"; return 0;}
		long long tmp=KSM(a[i][i],p-2);
		inc(j,i,2*n) a[i][j]=a[i][j]*tmp%p;
		inc(j,1,n){
			if(i==j) continue;
			long long tmp2=a[j][i]%p;
			inc(k,i,2*n) a[j][k]=(a[j][k]-tmp2*a[i][k]%p+p)%p;
		}
	}
	return 1;
}
int main()
{
	cin>>n;
	inc(i,1,n){
		inc(j,1,n) scanf("%d",&a[i][j]);
		a[i][i+n]=1;
	}
	if(Gauss()){
		inc(i,1,n){
			inc(j,n+1,2*n){
				printf("%d ",a[i][j]);
			}
			printf("\n");
		}
	}
} 
```


---

## 作者：_Camille_ (赞：2)

### 前言

做完 Gauss消元 后在来尝试这一道题 ...

然后因为直接使用了那题的板子而吃了很多亏 ...

劝大家不要直接把那一题板子搬过来调，细节还是有很大不同的 ...

### 前置芝士

1.逆矩阵

设 $A$ 是数域上的一个 $n$ 阶矩阵，若在相同数域上存在另一个 $n$ 阶矩阵 $B$ ，使得： $A*B=B*A=T$ ，则我们称 $B$ 是 $A$ 的逆矩阵，而 $A$ 则被称为可逆矩阵。

上文来自百度词条，笔者语文不是很好所以直接复制下来，上文还是很容易懂的。

2.Gauss消元

【模板】高斯消元法：[Link](https://www.luogu.com.cn/problem/P3389)

这边笔者用的是 高斯-约旦消元法 。

这个相对于 高斯消元 没有回带的过程，因此代码也相对简单。~~那还要高斯消元干什么~~

普通的 高斯消元（这是【模板】高斯消元法 的解法，因此会用到浮点数的计算）：

```cpp
for(int i=1;i<=n;i++){
    int t=i;
    for(int j=i+1;j<=n;j++){
        if(fabs(a[t][i])<fabs(a[t][i])){
            t=j;
        }
    }
    if(fabs(a[t][i])<0.0000001){
        printf("No Solution");
        return 0;
    }
    if(i!=t){
        for(int j=1;j<=n+1;j++){
            swap(a[i][j],a[t][j]);
        }
    }
    double tmp=a[i][i];
    for(int j=i;j<=n+1;j++){
        a[i][j]/=tmp;
    }
    for(int j=i+1;j<=n;j++){
        tmp=a[j][i];
        for(int k=i;k<=n+1;k++){
            a[j][k]-=a[i][k]*tmp;
        }
    }
    ans[n]=a[n][n+1];
    for(int i=n-1;i>=1;i--){
        ans[i]=a[i][n+1];
        for(int j=i+1;j<=n;j++){
            ans[i]-=(map[i][j]*ans[j]);
        }
    }//这就是特殊的回带操作了
}
```
高斯-约旦消元：

```cpp
for(int i=1;i<=n;i++){
        int t=i;
        for(int j=i+1;j<=n;j++){
            if(fabs(a[j][i])>fabs(a[t][i])){
                t=j;
            }
        }
        for(int j=1;j<=n+1;j++){
            swap(a[i][j],a[t][j]);
        }
        if(!a[i][i]){
            cout<<"No Solution";
            return 0;
        }
        for(int j=1;j<=n;j++){
            if(j!=i){
                double t=a[j][i]/a[i][i];
                for(int k=i+1;k<=n+1;k++){
                    a[j][k]-=a[i][k]*t;
                }
            }
        }
    }
```
相比是不是 高斯-约旦消元 更胜一筹？


### 解题思路

在读入的 $n$ 阶矩阵右侧加入一个 $n$ 阶矩阵，然后做高斯消元，使读入的 $n$ 阶矩阵化为 $n$ 阶单位矩阵，此时右面加入的矩阵就为所求的逆。

所以这题就是主要就是 求逆矩阵+高斯消元 。

上文已经介绍了 逆矩阵 与 高斯消元。

具体就是这样，细节看代码。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=1e9+7;
int a[410][810];
signed wyxakioi(int x,int y){
    int p=1;
    while(y){
        if(y%2==1){
            p=(p*x)%mod;
        }
        x=x*x%mod;
        y/=2;
    }
    return p%mod;
}//求逆元
signed main(){
    int n;
    cin>>n;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            cin>>a[i][j];
            a[i][i+n]=1;//构造右侧矩阵
        }
    }
    for(int i=1;i<=n;i++){
        int t=i;
        for(int j=i+1;j<=n;j++){
            if(abs(a[j][i])>abs(a[t][i])){
                t=j;
            }
        }
        if(i!=t){
            for(int j=1;j<=n*2;j++){
                swap(a[i][j],a[t][j]);
            }
        }
        if(!a[i][i]){
            cout<<"No Solution";
            return 0;
        }
        int iee=wyxakioi(a[i][i],mod-2);//得出逆元
        for(int j=1;j<=n;j++){
            if(j!=i){
                int tmp=a[j][i]*iee%mod;
                for(int k=i;k<=n*2;k++){
                    a[j][k]=((a[j][k]-a[i][k]*tmp)%mod+mod)%mod;
                }
            }
        }//上面就是基本 高斯-约旦消元 的板子的，就是多了一个逆元的处理。
        for(int j=1;j<=n*2;j++){
            a[i][j]=(a[i][j]*iee%mod);
        }//这边还要注意多处理一步
    }
    for(int i=1;i<=n;i++){
        for(int j=n+1;j<=n*2;j++){
            cout<<a[i][j]<<" ";
        }
        cout<<endl;
    }
    return 0;
}
```
具体就是这样，有什么不懂还可以私信我。

管理员审核辛苦了！

---

## 作者：3body (赞：1)

### 算法和此时第一篇题解其实基本一样，不过通过操作将最内层循环简化，吸口氧居然跑到了最优解第一

注意核心语句
```
(a[i][j]+=mod2-temp*a[k][j])%=mod;
```
3个变量在O2时会被放进寄存器，而a\[i],a\[k]中N个数相继处理，一般环境也会有自动优化。



```cpp
#include<bits/stdc++.h>

using namespace std;

typedef unsigned long long ull;

const ull mod=1e9+7,mod2=mod*mod;
ull a[400][400];
int n,is[400],js[400];

inline void inv(ull& x) {
    register ull f=1,xx=x;
    register int neg=0;
    while(xx>1){
        f=((mod/xx)*f)%mod;
        neg^=1;
        xx=mod%xx;
    }
    x= neg ? mod-f : f;
}

void inv(){
    for(int k=0;k<n;++k){
        for(int i=k,j;i<n;++i){
            for(j=k;j<n&&!a[i][j];++j);
            is[k]=i,js[k]=j;
        }
        for(int i=0;i<n;++i)
            swap(a[k][i],a[is[k]][i]);
        for(int i=0;i<n;++i)
            swap(a[i][k],a[i][js[k]]);
        if(!a[k][k]){
            puts("No Solution");
            exit(0);
        }
        inv(a[k][k]);
        for(int j=0;j<n;++j)if(j!=k)
            (a[k][j]*=a[k][k])%=mod;
            
        for(int i=0;i<n;++i) if(i!=k){
            register unsigned temp=a[i][k];
            a[i][k]=0;
            for(int j=0;j<n;++j)
                (a[i][j]+=mod2-a[k][j]*temp)%=mod;
        }
    }
    for(int k=n-1;k>=0;--k){
        for(int i=0;i<n;++i)
            swap(a[js[k]][i],a[k][i]);
        for(int i=0;i<n;++i)
            swap(a[i][is[k]],a[i][k]);
    }
}
int main(){
    scanf("%d",&n);
    for(int i=0;i<n;++i)
        for(int j=0;j<n;++j)
            scanf("%llu",a[i]+j);
    inv();
    for(int i=0;i<n;++i)
        for(int j=0;j<n;++j)
            printf("%llu%c",a[i][j],j==n-1?'\n':' ');
    return 0;
}
```


---

## 作者：Immortal_Bird (赞：0)

基建第五篇

矩阵求逆的基本原理是

$A$通过一系列线性变换变成$I$（单位矩阵），而这一系列变换等价于$P1*P2*..Pn*A=I$

而令$P=\prod P_{i}$，由于$A*A^{-1}=I$,且$P*A=I$，所以$P=A^{-1}$，所以只要求出$\prod P_{i}$。

根据高斯-约旦消元法，我们在$A$旁边构造一个单位矩阵$I$，用$B$表示，在对$A$操作的同时对$B$做相同操作。由于约旦消元最后能将$A$变为$I$,那么相应的$B$就变成了$\prod P_{i}$，也就是$A$的逆矩阵$P$.

[P4783](https://www.luogu.com.cn/problem/P4783)

$$ Code $$


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long

int read(){
	int x=0;bool f=0;char ch=getchar();
	while(!isdigit(ch))f|=ch=='-',ch=getchar();
	while(isdigit(ch))x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return f?-x:x;
}

void write(int x){
	if(x<0)putchar('-'),x=-x;
	if(x>9)write(x/10);
	putchar(48+x%10);
}

void writeln(int x){write(x);putchar('\n');}
void writebl(int x){write(x);putchar(' ');}

#define I inline
#define R register

const int maxn = 405;
const int mod = 1e9+7;

I int ksm(int a,int b){int res=1;while(b){if(b&1)res=res*a%mod;a=a*a%mod;b>>=1;}return res;}

int n,m;
struct Mat{int a[maxn][maxn<<1];}f;

bool work(Mat &f){
	for(R int i=1,r;i<=n;++i){
		r=i;
		for(R int j=i+1;j<=n;++j)if(f.a[j][i]>f.a[r][i])r=j;
		if(r!=i)swap(f.a[i],f.a[r]);		
		if(!f.a[i][i]){puts("No Solution");return 0;}
		
		int kk=ksm(f.a[i][i],mod-2);
		
		for(R int j=1;j<=n;++j)if(j!=i){
			int res=f.a[j][i]*kk%mod;
			for(R int k=i;k<=m;++k)
				f.a[j][k]=((f.a[j][k]-res*f.a[i][k])%mod+mod)%mod;
		}
		
		for(R int j=1;j<=m;++j)f.a[i][j]=f.a[i][j]*kk%mod;
	}
	return 1;
}

signed main(){
	n=read();m=n<<1;
	for(R int i=1;i<=n;++i){
		for(R int j=1;j<=n;++j)f.a[i][j]=read();
		f.a[i][i+n]=1;
	}
	bool flag=work(f);
	if(!flag)return 0;
	for(R int i=1;i<=n;++i){
		for(R int j=n+1;j<=m-1;++j)writebl(f.a[i][j]);
		writeln(f.a[i][m]);
	}
}
```


---


# 【模板】扩展欧拉定理

## 题目背景

出题人也想写有趣的题面，可惜并没有能力。

## 题目描述

给你三个正整数，$a,m,b$，你需要求：$a^b \bmod m$   


## 说明/提示

注意输入格式，$a,m,b$ 依次代表的是底数、模数和次数   

【样例 $1$ 解释】   
$2^4 \bmod 7 = 2$     
     
【数据范围】  
对于 $100\%$ 的数据，$1\le a \le 10^9$，$1\le b \le 10^{20000000}，1\le m \le 10^8$。

## 样例 #1

### 输入

```
2 7 4```

### 输出

```
2```

## 样例 #2

### 输入

```
998244353 12345 98765472103312450233333333333```

### 输出

```
5333```

# 题解

## 作者：小粉兔 (赞：189)

### 费马小定理：

当 $a,p\in \mathbb{Z}$ 且 $p$ 为质数，且 $a\not\equiv 0\pmod{p}$ 时有：  
$a^{p-1}\equiv 1\pmod{p}$。

所以 $a^b\equiv a^{b\bmod (p-1)}\pmod p$。

### 欧拉定理：

当 $a,m\in \mathbb{Z}$，且 $\gcd(a,m)=1$ 时有：  
$a^{\varphi(m)}\equiv 1\pmod{m}$。

这里 $\varphi(x)$ 是数论中的欧拉函数。

所以 $a^b\equiv a^{b\bmod \varphi(m)}\pmod m$。

### 扩展欧拉定理：

当 $a,m\in \mathbb{Z}$ 时有：  
$a^b\equiv\left\{\begin{matrix}a^b&,b<\varphi(m)\\a^{b\bmod\varphi(m)+\varphi(m)}&,b\ge\varphi(m)\end{matrix}\right.\pmod m$。

证明略。

### 题解：

套公式即可。

```cpp
#include <cstdio>

int a, m, phi = 1;
int bm, flag;

int qPow(int b, int e) {
	int a = 1;
	for (; e; e >>= 1, b = (long long)b * b % m)
		if(e & 1) a = (long long)a * b % m;
	return a;
}

int main() {
	scanf("%d%d", &a, &m);
	a %= m;
	int mm = m;
	for (int i = 2; i * i <= mm; ++i) {
		if (mm % i) continue;
		phi *= i - 1;
		mm /= i;
		while (mm % i == 0)
			phi *= i,
			mm /= i;
	} if (mm > 1) phi *= mm - 1;
	char ch;
	while ((ch = getchar()) < '0' || ch > '9') ;
	while (bm = bm * 10ll + (ch ^ '0'), (ch = getchar()) >= '0' && ch <= '9')
		if (bm >= phi) flag = 1, bm %= phi;
	if (bm >= phi) flag = 1, bm %= phi;
	if (flag) bm += phi;
	printf("%d", qPow(a, bm));
	return 0;
}
```

---

## 作者：hanzhongtlx (赞：90)

# [更好的阅读体验点这里](https://www.cnblogs.com/tlx-blog/p/12369301.html)
这篇文章的动机：万一有什么长进呢？（先痴想一下吧）  
本文难度：$\color{orange}\text{普及-}$→$\color{CornflowerBlue}\text{提高+}$
## $Part\;1$.线性筛
不止能筛质数，所有的积性函数都可以$O(n)$筛出。   
$ps$:积性函数只对于$\forall x,y\in P$(这里$P$是质数的集合),$f(ab)=f(a)f(b)$的数论函数。   
当然不排除你喜爱埃氏筛，但洛谷$1e8$照样会卡你。   
但不能略过：
埃氏筛，全称是啥显然忘了（用不到吧$qwq$?）,核心思想是利用已有的质数，与当前的数相乘，得到的一定是合数。   
下面是线性筛质数：
```
    judge[1]=true;
    for(int i=2;i<=maxn;i++)
    {
        if(i*i>maxn) continue;
        if(!judge[i])
        {
            for(int j=2*i;j<=maxn;j+=i) judge[j]=true;//是合数
        }
    }
```
一看就懂吧。   
复杂度分析（~~并不会~~）：  
我们知道素数密度是$\dfrac{n}{\ln n}$的，那么对于每个合数$x$要筛$\dfrac{maxn}{x}$次然而他求和是接近$\log n$的（难死了），所以应该是$O(n\log\log n)$，近似于常数了（这改变不了他被卡的命运）   
那大神欧拉发现（这谁都可以），有些数会被筛好几次，这就是他不能$O(n)$的原因,比如$6$，被$2,3$筛两次，那我们可以这样写：
```
for(int i=2;i<=maxn;i++)
    {
    	if(!judge[i]) prime[++cnt]=i;
    	for(int j=1;j<=cnt&&(prime[j]*i)<=maxn;j++)
    	{
    		judge[i*prime[j]]=true;
    		if(i%prime[j]==0) break;
		}
	}
```
为什么只会筛一次呢？   
考虑如果整除，那就有一个平方因子也可以筛掉他，丢到后面去就好了。  
所以复杂度就是$O(n)$的，再卡就没办法了。   
## $Part\;2$.欧拉函数  
定义欧拉函数$\psi(n)$为与$n$互质的数，一个大佬讲得贼好：
$\psi(6)$咋算？这里是可以枚举的，是$O(n\log n)$，他讲了种好方法：
写出所有分母是$6$的不大于$1$的分数。  
$$\dfrac{1}{6},\dfrac{2}{6},\dfrac{3}{6},\dfrac{4}{6},\dfrac{5}{6},\dfrac{6}{6}$$   
化简后分组：
$$\dfrac{1}{6},\dfrac{1}{3},\dfrac{1}{2},\dfrac{2}{3},\dfrac{5}{6},\dfrac{1}{1}$$  
那么：
$$\psi(6)=2,\psi(3)=2,\psi(2)=1,\psi(1)=1$$  
然后就说明:
$$\sum_{d|n} \psi(d)=n$$  
显然观察归纳不严密，若我有幸学习并会了了莫反再来证吧。
## $Part\;3$.线性求法
欧拉函数是积性函数，保证了它可以被$O(n)$筛出，但原理较复杂，建议先别学$qwq$，看完下面就好多了，~~反正我是~~。  
## $Part\;4$.单个数的欧拉函数  
考虑一个事:
$$\text{若}x\in P,\psi(x)=x-1$$  
只有自身不互质,我们称为性质一。    

性质二：考虑一个**合数**$a$满足$a=p^k(k>1,k\in Z)$,显然与他互质的数$b\in [p,2p,3p......p^{k-1}p]$(饶了我吧，我真不会打大括号)。  
那么$\psi(a)=p^k-p^{k-1}=p^k(1-\dfrac{1}{p})$。   

性质三：最一般的情况，每个合数$a$都可写成唯一分解式：  
$$a=p_1^{k_1}p_2^{k_2}......p_n^{k_n}$$  
即：
$$a=\prod_{i=1}^n p_i^{k_i}$$    
好在欧拉函数是个特殊的积性函数，满足$\psi(nm)=\psi(n)\psi(m)$，成立（当然在定义域)。   
那么
$$\psi(a)=\prod_{i=1}^n \psi(p_i^{k_i})=\prod_{i=1}^n p_i^{k_i}\prod_{i=1}^n(1-\dfrac{1}{p_i})=a\prod_{i=1}^n(1-\dfrac{1}{p_i})$$   
到这里，我们就可以$O(\sqrt{n})$得出 一个数的欧拉函数了。 其实思想和早先我们学习质数验证枚举因子是异曲同工的：  
代码：
```
int phi(int n)
{
	int ans=n;
	for(int i=2;i<=sqrt(n);i++)
	{
		if(n%i==0)
		{
			ans=ans/i*(i-1);//这是一个p，注意先除再乘，防止炸int
			while(n%i==0) n/=i; //把质数次方因子筛没了，就不会错了
		}
	}
	if(n>=2) ans=ans/n*(n-1);//最后有可能剩下
	return ans;
}
```
不过有些人不这样写：
```
int phi(int n)
{
	int ans=1,now;
	for(int i=1;i<=sqrt(n);i++) 
	{
		now=1;
		if(n%i==0)
		{
          	now=i-1,n/=i;
			while(n%i==0) now*=i,n/=i;
		}
		ans*=now;
	}
	if(n!=1) ans*=n-1;
	return ans;
```
简单说下，对于一小部分($p^k$)考虑变形：
$$\psi(p^k)=p^k-p^{k-1}=p^{k-1}(p-1)$$   
于是发现出现质数$p$先乘一次$p-1$,再来$k-1$次$p$，其他都是一样的，不过这里：
```
now=i-1,n/=i;
```
注意除一下，然后$now,ans$分别记录，不能够混淆。   
## $Part\;5$.回归$Part\;3$  
剩下的就好说了。   
```
phi[1]=1;
	for(int i=2;i<=n;i++)
	{
		if(!vis[i]) p[++cnt]=i,phi[i]=i-1;//质数只有自身与自己不互质 
		for(int j=1;p[j]&&i*p[j]<=n;j++)
		{
			vis[i*p[j]]=1;
			if(!(i%p[j]))
			{
				phi[i*p[j]]=phi[i]*p[j];
				//这里是平方因子了，不要减1 
				break;
			}
			else phi[i*p[j]]=phi[i]*(p[j]-1);//第一次出现因子，乘p-1 
		}
	}
```
精华都在代码里了。   
其实和筛素数的是一样的。   
线性筛可是很$NB$的，以至于所有积性函数都怕他（掩盖不了看似大的惊人的复杂度了）。
## $Part\;6$ 欧拉定理  
前置知识：快速幂。   
大概这样写,复杂度是$O(\log n)$的。
```
ll quickpow(ll a,ll b)
{
    ll ans=1,base=a;
    while(b!=0)
	{
        if(b&1!=0)//b%2==1;
		{
            ans*=base;
        }
        base*=base;
        b>>=1;//b/=2;
    }
    return ans;
}
```
~~你甚至可以自己定义乘法运算跑快速幂。~~   
可是指数很大怎么办呢？   
连$O(\log n)$都过不去啊！  
伟大的欧拉提出了定理，我们为了纪念他，称为**欧拉定理**：    

若$\gcd (a,m)=1$,则：
$$a^{\psi(m)}\equiv1\pmod{m}$$    
但他认为不够，又提出了**拓展欧拉定理**：
$$a^b\equiv\begin{cases}a^b&b<\psi(m)\\a^{b\;mod\;\psi(m) +\psi(m)}&b\geqslant \psi(m)\end{cases}$$    
这样，先预处理出$\psi(m)$，再用字符串边读边模即可。  
复杂度~~大概~~是$O(len_b+\sqrt{m}+\log m)$(毕竟$\psi(m)$上界是$m$),可以通过本题。
代码：
```
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int phi(int x)//欧拉函数
{
	int ans=1,num=1;
	for(int i=2;i*i<=x;i++)
	{
		if(!(x%i))
		{
			num=i-1,x/=i;
			while(!(x%i)) num=num*i,x/=i;
			ans=num*ans;
		}
	}
	if(x!=1) ans=ans*(x-1);
	return ans;
}
inline int read(int mod)//改进快读，让他边读边输入
{
	//g用来判断b与phi(m)的大小，如果小于，就不能加了，这是坑点！
	int x=0;
	bool g=false;
	char c=getchar();
	while(c<'0'||c>'9') c=getchar();
	while(c>='0'&&c<='9')
	{
		x=(x<<3)+(x<<1)+(c^'0');
		if(x>=mod) x%=mod,g=true;
		c=getchar();
	}
	if(g) return (x+mod);
	else return x;
}
int a,mod;
char b[20000005];
inline int quickpow(int a,int b)//快速幂
{
	long long ans=1,base=(long long)a;
	while(b)
	{
		if(b&1) ans=ans*base%mod;
		b>>=1;
		base=base*base%mod;
	}
	return (int)(ans%mod);
}
int p;
int main()
{
	scanf("%d%d",&a,&mod);
	int p=phi(mod);
	int cishu=read(p);//得出的化简次数
	int s=quickpow(a,cishu);
	printf("%d\n",s);
	return 0;
}
```
大概就这些啦，还有些高深点的东西以后再更。

---

## 作者：_louhc (赞：70)

# 思路
这题要用欧拉定理？ 雾）~~由于我不会欧拉定理，这里就用比较蒟蒻的算法好了~~  
不管标题【模板】欧拉定理 另辟蹊径？  比如，快速幂？  
有个十分简单的小定理
$$a^b*a^c=a^{b+c}$$  

所以
$$a^b=a^{b1*10^?}\times a^{b2*10^?}\times..\times a^{bn}$$

其中指数和为b

要求$a^b\%m$，我们可以把b拆开，每16位做一次快速幂，然后$ans=ans^{(int)1e16}\times a^{\text{16位b}}$即可。别忘了最后把不足16位的b也算上。上述所有的幂运算都使用快速幂来求，最后总的复杂度就为$O(\text{输入}+\frac n{16}lg{(int)1e16})$勉勉强强过得去。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define open(s) freopen( s".in", "r", stdin ), freopen( s".out", "w", stdout )
#define LL long long

char S[1<<25];
int p;
LL a, m, b, ans(1), t;

void read( LL &x, int len = 0x7f7f7f7f ){
	x = 0;
	while( !isdigit(S[p]) ) p++;
	while( isdigit(S[p]) && len-- ) x = x * 10 + ( S[p] ^ '0' ), p++;
}

void Pow( LL &x, LL k ){
	LL ans(1);
	while( k ){
		if ( k & 1 ) ans = ( ans * x ) % m;
		x = ( x * x ) % m;
		k >>= 1;
	}
	x = ans;
}

int main(){
//	open( "1" );
	fread( S, 1, 1 << 25, stdin );
	read(a); read(m);
	while( !isdigit(S[p]) ) p++;
	while( isdigit( S[p + 16] ) ){
		Pow( ans, (LL)1e16 ); read( b, 16 );
		t = a; Pow( t, b ); ans = ( ans * t ) % m;
	}
	t = p; read( b ); t = p - t;
	while( t-- ) Pow( ans, 10 );
	Pow( a, b ); ans = ( ans * a ) % m;
	printf( "%lld\n", ans );
	return 0;
}

```

---

## 作者：Owen_codeisking (赞：40)

# [更好的阅读体验戳这里](https://www.cnblogs.com/owencodeisking/p/10101647.html)

$Upd:12.12$ 锅已修复，这题需要扩展欧拉定理

### 欧拉定理：若 $gcd(a,n)=1$，$a^{\varphi(n)}\equiv 1(mod\ n)$

设 $1\sim n-1$ 中与 $n$ 互素的 $\varphi(n)$ 个数 $x_1,x_2,...,x_{\varphi(n)}\in M_1$，那么集合 $M_1$ 为模 $n$ 的一个缩系

再设 $a\cdot x_1,a\cdot x_2,...,a\cdot x_{\varphi(n)}\in M_2$，由于缩系的性质，集合 $M_2$ 也为模 $n$ 的缩系

$$\Longrightarrow a\cdot x_1\cdot a\cdot x_2\cdot ...\cdot a\cdot x_{\varphi(n)}\equiv x_1,x_2,...,x_{\varphi(n)}(mod\ n)$$

化简得 $a^{\varphi(n)}\equiv 1(mod\ n)$

如何求一个数的欧拉函数？让我们先证明另一个定理。

------------

### 定理：$\varphi(a)=a\cdot (1-\frac {1}{p_1})\cdot (1-\frac {1}{p_2})\cdot ...\cdot (1-\frac {1}{p_n})$

- 当 $a=p$ 时，即 $a$ 是素数，$\varphi(a)=a-1$

- 当 $a=p^k(k>1)$ 时，即 $a$ 是一个素数幂，先考虑与 $p^k$ 不互素的数 $a(1\leq a\leq p^k)$，$p^k$ 仅有因子 $p$，所以 $p|a$ 必定成立。所以 $a$  的值可以有 $p,2p,3p,...,p^{k-1}\cdot p$，显然个数为 $p^{k-1}$ 个。又知小于等于 $a$ 的正整数总数为 $p^k$ 个，所以 $\varphi(a)=p^k-p^{k-1}=p^k\cdot (1-\frac {1}{p})$

- 当 $a$ 为合数时，可表示为 $a=p_1^{k_1}\cdot p_2^{k_2}\cdot ...\cdot p_n^{k_n}$，是多个素数幂的积。由 $\varphi(nm)=\varphi(n)\cdot \varphi(m)$ 得 $$\varphi(a)=\varphi(p_1^{k_1})\cdot \varphi(p_2^{k_2})\cdot ...\cdot \varphi(p_n^{k_n})=p_1^{k_1}\cdot (1-\frac{1}{p_1})\cdot p_2^{k_2}\cdot (1-\frac {1}{p_2})\cdot ...\cdot p_n^{k_n}\cdot (1-\frac {1}{p_n})$$ 合并所有 $p_i^{k_i}$ 等于 $a$，证得 $\varphi(a)=a\cdot (1-\frac {1}{p_1})\cdot (1-\frac {1}{p_2})\cdot ...\cdot (1-\frac {1}{p_n})$

不少证明 $\varphi(nm)=\varphi(n)\cdot \varphi(m)$ 都是一句话显然，所以有兴趣的话可以证明上述性质。

然后根据引理，可以在 $O(\sqrt{n})$ 的时间内求出一个数的欧拉函数，这一般在不能线性筛出 $\varphi$ 函数时使用。

------------

## 扩展欧拉定理：

若 $b<\varphi(m)$，$a^b\equiv a^b(mod\ m)$

若 $b\geq \varphi(m)$，$a^b\equiv a^{b\ mod\ \varphi(m)+\varphi(m)}(mod\ m)$

$b$ 的指数部分可以边乘边模，最后对 $a^b$ 线性求或者快速幂即可

$Code\ Below:$

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll a,m,b;

inline ll read(ll m){
	register ll x=0,f=0;char ch=getchar();
	while(!isdigit(ch)) ch=getchar();
	while(isdigit(ch)){
		x=x*10+ch-'0';
		if(x>=m) f=1;
		x%=m;ch=getchar();
	}
	return x+(f==1?m:0);
}

ll phi(ll n){
	ll ans=n,m=sqrt(n);
	for(ll i=2;i<=m;i++){
		if(n%i==0){
			ans=ans/i*(i-1);
			while(n%i==0) n/=i;	
		}
	}
	if(n>1) ans=ans/n*(n-1);
	return ans;
}

ll fast_pow(ll a,ll b,ll p){
	ll ret=1;
	for(;b;b>>=1,a=a*a%p)
		if(b&1) ret=ret*a%p;
	return ret;
}

int main()
{
    scanf("%lld%lld",&a,&m);
    b=read(phi(m));
    printf("%lld\n",fast_pow(a,b,m));
    return 0;
}
```

---

## 作者：fzj2007 (赞：14)

## 第一步 读题

给你三个正整数，$a,m,b$，你需要求：$a^b \bmod m$。

其实就是个快速幂加上取模。。

## 第二步 思路

### 思路一

直接快速幂，这不是裸题吗。。但是你有没有发现这题是蓝题鸭。看一眼数据范围吓死你：$1 \le b \le 10^{20000000}$。快速幂要死掉吧。

### 思路二

有了思路 $1$ 以后，我们考虑优化。你看这题题目有一个扩展欧拉定理，那我们就用扩展欧拉定理吧~

首先，我们先看看欧拉定理：

#### 前置芝士：

- $\gcd(u,v)$，表示 $u$ 与 $v$ 的最大公约数。

- $\operatorname{lcm}(u,v)$，表示 $u$ 与 $v$ 的最小公倍数。

- $\operatorname{inv}(u,v)$，表示 $u$ 在模 $v$ 意义下的逆元。如果你不知道这个内容，可以在[这里](https://oi-wiki.org/math/inverse/)学习。

- $x$ 的简化剩余系是什么？就是当且仅当 $\gcd(x,y)=1$ 且 $y\lt x$ 时，$y$ 属于 $x$ 的简化剩余系。

- 你需要知道[欧拉函数](https://oi-wiki.org/math/euler/)是什么。

>由于欧拉函数对于本题作用重大，所以这里特别写一下欧拉函数的性质：

>- 钦定 $\varphi(1)=1$。
>- 若 $p$ 为质数，$\varphi(p)=p-1$，且 $\varphi(p^x)=p^{x}\times(1-\frac{1}{p})$。
>- 欧拉函数是积性函数。
>- 欧拉函数的计算公式为 $\varphi(x)=x\times\prod\limits_{i=1}^{t}(1-\frac{1}{p_i})$，其中 $p_1,p_2,\dots p_n$ 为 $x$ 的所有质因数，$t$ 为 $x$ 的质因数个数。

- 在学习之前，你还需要了解筛法。可以在[这里](https://oi-wiki.org/math/sieve/)进行初步学习

#### 结论：

当 $\gcd(a,m)=1$ 时，$a^{\varphi(m)}\equiv1(\bmod \ m)$ 。

#### 证明：

设 $m$ 的简化剩余系为 $X$，元素记为 $x_1,x_2,\dots x_{\varphi(m)}$。我们发现他们模 $m$ 余数各不相同，且都与 $m$ 互质（废话，$x_i \lt m(1 \le i \le \varphi(m))$，那模 $m$ 不就是原数吗。。）而且 $a\times x_1,a\times x_2,\dots a\times x_{\varphi(m)}$ 也满足这个条件，我们就得到了

$$\sum\limits_{i=1}^{\varphi(m)}x_i\equiv\sum\limits_{i=1}^{\varphi(m)}x_i \times a(mod \ m)$$

然后式子两边消去与 $m$ 互质即无关的 $\sum\limits_{i=1}^{\varphi(m)}x_i$，式子就变成了

$$ 1 \equiv a^{\varphi(p)}$$

得证。

#### 扩展欧拉定理

终于到了我们的主角了~

#### 扩展欧拉定理的结论：

$x^y\equiv \begin{cases}x^{y}(\bmod \ m)&x\lt \varphi(m)\\x^{y\bmod \varphi(m)+\varphi(m)}(\bmod \ m)&x\ge\varphi(m)\end{cases}$ 

#### 证明

由于证明过程过长且篇幅限制，这里提供两篇证明比较好的文章。[第一篇](https://oi-wiki.org/math/fermat/)，[第二篇](https://blog.csdn.net/bcr_233/article/details/91969132)。

## 第三步 代码

讲了那么多，总还是要放代码吧~（**警告：IO优化部分较长，建议跳过！但是读入2部分使用了取模，建议查看！（属于重点部分）**）

```cpp
#include<bits/stdc++.h>//万能头
using namespace std;
using std::cin;
using std::cout;
using std::endl;
#define ll long long//宏定义
ll a,b,m,p;//声明变量
namespace IN{//读入
    const int MAX_INPUT = 1000000;
    #define getc() (p1==p2&&(p2=(p1=buf)+inbuf->sgetn(buf,MAX_INPUT),p1==p2)?EOF:*p1++)//fread优化
    char buf[MAX_INPUT],*p1,*p2;
    template<typename T>inline bool read(T &x) {//第一个读入不用管
        static std::streambuf *inbuf=cin.rdbuf();
        x=0;
        register int f=0,flag=false;
        register char ch=getc();
        while(!isdigit(ch)){
            if (ch=='-') f=1;
        	ch=getc();
        }
        if(isdigit(ch)) x=x*10+ch-'0',ch=getc(),flag=true;
        while(isdigit(ch)) {
            x=x*10+ch-48;
            ch=getc();
        }
        x=f?-x:x;
        return flag;
    }
    template<typename T>inline bool read2(T &x) {//这里我重点说一下
        static std::streambuf *inbuf=cin.rdbuf();
        x=0;
        register int f=0,flag=false;
        register char ch=getc();
        while(!isdigit(ch))
        	ch=getc();
        while(isdigit(ch)){
        	x=x*10+ch-48;
        	if(x>=p) f=1;//是否大于p决定了要不要加上一个p
            x%=p;//取模，不然太大了还得写高精度。。
            ch=getc();//接着读入
        }
        x+=(f?p:0);//加上
        return flag;
    }
    template<typename T,typename ...Args>inline bool read(T& a,Args& ...args) {
       return read(a)&&read(args...);
    }
    #undef getc
}

namespace OUT{//输出优化直接跳过
    template<typename T>inline void put(T x){
        static std::streambuf *outbuf=cout.rdbuf();
        static char stack[21];
        static int top=0;
        if(x<0){
            outbuf->sputc('-');
            x=-x;
        }
        if(!x){
            outbuf->sputc('0');
            outbuf->sputc('\n');
            return;
        }
        while(x){
            stack[++top]=x%10+'0';
            x/=10;
        }
        while(top){
            outbuf->sputc(stack[top]);
            --top;
        }
        outbuf->sputc('\n');
    }
    inline void putc(const char ch){
        static std::streambuf *outbuf=cout.rdbuf();
        outbuf->sputc(ch);
    }
    inline void putstr(string s){
    	for(register int i=0;i<s.length();i++) putc(s[i]);
	}
    template<typename T>inline void put(const char ch,T x){
        static std::streambuf *outbuf=cout.rdbuf();
        static char stack[21];
        static int top = 0;
        if(x<0){
            outbuf->sputc('-');
            x=-x;
        }
        if(!x){
            outbuf->sputc('0');
            outbuf->sputc(ch);
            return;
        }
        while(x){
            stack[++top]=x%10+'0';
            x/=10;
        }
        while(top){
            outbuf->sputc(stack[top]);
            --top;
        }
        outbuf->sputc(ch);
    }
    template<typename T,typename ...Args> inline void put(T a,Args ...args){
        put(a);put(args...);
    }
    template<typename T,typename ...Args> inline void put(const char ch,T a,Args ...args){
        put(ch,a);put(ch,args...);
    }
}
using namespace IN;//可以直接使用的东东
using namespace OUT;//这里也是
ll find_phi(ll k){//筛法筛phi，这就是筛法，在OI wiki的数学-数论-筛法中有讲，当然这里有特殊操作
	p=k;
	for(ll i=2;i<=sqrt(k);i++)//2到根号k
		if(!(k%i)){//如果是一个因数
			p=p/i*(i-1);//加上这一段的
			while(!(k%i)) k/=i;//然后把所有的因数i全部去掉
		}
	if(k>1) p=p/k*(k-1);//如果还有，那就继续
	return p;//最后返回
}
ll power(ll a,ll b,ll m){//快速幂，不会的同学请移步P1226
	ll re=1;//用来存储
	while(b){
		if(b&1) re=(re*a)%m;//奇数就乘
		a=a*a%m;//继续乘，变成原来的平方
		b>>=1;//这里和b/=2一样
	}
	return re;//返回
}
int main(int argc, char const *argv[]){
    std::ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    read(a,m);//先读入a,m
    find_phi(m);//然后查找phi，之后才能读入b
    read2(b);//读入b，read2的代码一定要看啊
    put(power(a,b,m));//最后快速幂
    return 0;//886
}
```

### 第六步 其他

- 撰文不易，大佬勿喷！
- 文章若有`bug`请私信作者，感激不尽！
- 如果有帮助，请帮忙点下赞，感谢！

---

## 作者：critnos (赞：11)

emmm 用玄学的方法过了

众所周知，幂这东西有个循环节是吧

长度上界大概是 $m$。

然后 $m\le 10^8$ 就好办了。

求循环节有个好方法：Floyd 判环。

用两个指针，一个跑一倍速跑，一个两倍速。因为一定有循环节，所以两个指针必然会在途中相遇。

```
int f(int x,int a,int m)
{
	return 1ll*x*a%m;
}
void ask(int a,int m)
{
	int m1=1,m2=2,i=a,j=1ll*a*a%m;
	while(i!=j)
	{
		m1++,m2+=2;
		i=f(i,a,m),j=f(f(j,a,m),a,m);	
	}
	len=m2-m1;
	for(i=1;i!=j;mu++,i=f(i,a,m));
   //len 表示循环节长度，mu 表示入环点幂次
}
```
注意的地方是，因为循环节不一定从 $0$ 次幂开始，所以还要求出入环点。

感性理解就是个 $\rho$ 形。

跑的比欧拉定理慢一些。

P.S：不太懂为什么 $m$ 只出到 $10^8$。欧拉函数可以 $\sqrt n$ 或者 $n^{\frac 1 4}$ 计算。。

---

UPD：6.30

其实不用求入环点的

这是原来的代码：

```cpp
int len,mu;
bool fl;
int f(int x,int a,int m)
{
	return 1ll*x*a%m;
}
void ask(int a,int m)
{
	int m1=1,m2=2,i=a,j=1ll*a*a%m;
	while(i!=j)
	{
		m1++,m2+=2;
		i=f(i,a,m),j=f(f(j,a,m),a,m);	
	}
	len=m2-m1;
	for(i=1;i!=j;mu++,i=f(i,a,m));
}
int read(int mod)
{
	char ch=getchar();
	int s=0;
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',fl=s>=mod?1:fl,s%=mod,ch=getchar();
	return s;
}
int main()
{
	int a,m,b;
	cin>>a>>m;
	ask(a,m);
	b=read(len);
	if(fl) cout<<1ll*qpow(a,b-mu+len,m)*qpow(a,mu,m)%m;
	else cout<<qpow(a,b,m);
}  
```
欸，看这个 `1ll*qpow(a,b-mu+len,m)*qpow(a,mu,m)%m`

这东西不是可以化为 `qpow(a,b+len,m)` 吗？

然后就愉快的不用算 `mu` 了。

```cpp
#include<bits/stdc++.h>
#pragma GCC target("avx,sse2,sse3,sse4,mmx")
#pragma GCC optimize(3,"Ofast","inline")
using namespace std;
bool fl;
int f(int x,int a,int m)
{
	return 1ll*x*a%m;
}
int ask(int a,int m)
{
	int m1=1,m2=2,m3=3,i=a,j=1ll*a*a%m,k=1ll*a*a%m;
	while(i!=j)
	{
		m1++,m2+=2;
		i=f(i,a,m),j=f(f(j,a,m),a,m);	
	}
	return m2-m1;
}
int qpow(int a,int p,int mod)
{
	if(p==0) return 1;
	if(p==1) return a;
	long long t=qpow(a,p/2,mod);
	return t*t%mod*qpow(a,p%2,mod)%mod;
}
int read(int mod)
{
	char ch=getchar();
	int s=0;
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',fl=s>=mod?1:fl,s%=mod,ch=getchar();
	return s;
}
int main()
{
	int a,m,b,len;
	cin>>a>>m;
	len=ask(a,m),b=read(len);
	if(fl) cout<<qpow(a,b+len,m);
	else cout<<qpow(a,b,m);
}  
```
这是之前的代码：https://www.luogu.com.cn/record/34741882

现在的：https://www.luogu.com.cn/record/34748755

可以明显看到，不算 `mu` 之后，速度快了许多。

---

## 作者：pomelo_nene (赞：10)

## 拓展欧拉定理 

### 欧拉函数定义

欧拉函数，符号即为记为 $\varphi$。$\varphi(n)$ 意思为有多少个数 $i$，使得 $\gcd(i,n)=1$ 并且 $i\leq n$。用数学符号解释即为 $\displaystyle \varphi(n)=\sum_{i=1}^n[\gcd(i,n)=1]$。

特殊性质：

- 若 $n$ 为质数，则 $\varphi(n)=n-1$。根据质数的定义得证；   
- 若 $n=p^k$，其中 $p$ 为质数，则 $\varphi(n)=p^k-p^{k-1}=(p-1)p^{k-1}$。因为 $n$ 只有 $p$ 一个素因子，所以除了 $p$ 的倍数之外其余数都与 $n$ 互质；   
- 对于任意 $n$，$\displaystyle \varphi(n)=n\prod_{i=1}^k(1-\dfrac{1}{p_i})$。通过唯一分解定理得证，注意同一个质因子只计算一次；   
- 若 $\gcd(n,m)=1$，则 $\varphi(nm)=\varphi(n)\varphi(m)$。（即 $\varphi(x)$ 为一个积性函数）。

证明：

根据唯一分解定理，$n=p_1^{a_1}p_2^{a_2}\dots p_s^{a_s},m=q_1^{b_1}q_2^{b_2}\dots q_t^{b_t}$。因为 $\gcd(n,m)=1$，所以不存在 $1 \leq i \leq s,1 \leq j \leq t$，使得 $p_i=q_j$。根据性质 $3$ 可以证到 $\varphi(x)$ 为一个积性函数。

### 欧拉函数计算

众所周知，线性筛可以处理各种积性函数的计算，欧拉函数也不例外。我们可以通过 $O(n)$ 计算出所有 $\varphi(i)(1 \leq i \leq n)$。

具体处理为：如果 $n$ 为质数，根据性质 $1$ 得 $\varphi(n)=n-1$。

否则，如果 $\operatorname{prime}_j | i$，则 $\varphi(i\times \operatorname{prime}_j)=\varphi(i)\times \operatorname{prime}_j$ ；否则 $\varphi(i\times \operatorname{prime}_j)=\varphi(i)\times (\operatorname{prime}_j-1)$。

但是在某些题目中我们并不需要求出 $[1,n]$ 间所有的 $\varphi(i)$。这个时候我们可以根据性质 $3$ 做一个 $\sqrt n$ 的算法求出 $\varphi(n)$。在这道模板题中就只需要用这个算就行了。

### 欧拉定理

内容：对于两个正整数 $a,n$，若 $\gcd(a,n)=1$，则：

$$a^{\varphi(n)}\equiv 1(\bmod \ n)$$

先说说费马小定理。费马小定理的内容是：

若 $\gcd(a,p)=1$ 并且 $p$ 是一个质数，则：

$$a^{p-1}=1(\bmod \ p)$$

实质上是欧拉定理的一种特殊情况。

证明：

设有 $\varphi(n)$ 个数 $x_1,x_2,\dots,x_{\varphi(n)}$，满足 $\forall i,1 \leq i \leq \varphi(n):\gcd(x_i,n)=1,x_i< n$。易见这 $\varphi(n)$ 个数模 $n$ 两两不同并且余数与 $n$ 互质。

考虑证明 $ax_1,ax_2,\dots,ax_{\varphi(n)}$ 也满足以上两个性质。

- 这 $\varphi(n)$ 个数模 $n$ 两两不同：使用反证法。若 $\exists 1 \leq i < j \leq \varphi(n):ax_i-ax_j \equiv 0(\bmod \ n)$。因为 $\gcd(a,n)=1$，又因为 $a_i-a_j$ 不可能是 $n$ 的倍数，因此假设不成立。所以 $ax_1,ax_2,\dots,ax_{\varphi(n)}$ 模 $n$ 两两不同；   
- 余数与 $n$ 互质：$\gcd(a,n)=1,\gcd(x_i,n)=1$。所以 $\gcd(ax_i,n)=1$。类似于辗转相除法可以证明这个结论。

所以 $ax_1,ax_2,\dots,ax_{\varphi(n)}$ 也满足以上两个性质。

我们发现与 $n$ 互质并且小于 $n$ 的 $\varphi(n)$ 个数是固定的。所以对于任意 $1 \leq i \leq \varphi(n)$，都存在唯一一个 $1 \leq j \leq \varphi(n)$，满足 $x_i \equiv ax_j(\bmod \ n)$。因此：

$$ax_1ax_2\dots ax_{\varphi(n)} \equiv x_1x_2\dots x_{\varphi(n)} (\bmod \ n) $$

两边消掉，得到：

$$a^{\varphi(n)}\equiv 1(\bmod \ n)$$

定理得证。

### 拓展欧拉定理

扯了这么多，最重要的还是这个啊。

内容：若 $b \geq m$ 且 $\gcd(a,m) \neq 1$，则：

$$a^b \equiv a^{b \bmod \varphi(m)+\varphi(m)}(\bmod \ m)$$

先考虑这个定理没有包含到的情况。

若 $b < m$，可以直接使用快速幂计算；  
若 $\gcd(a,m)=1$，根据欧拉定理，$a^b \equiv a^{b \bmod \varphi(m)}(\bmod \ m)$。

考虑证明这个定理，先证明对于一个质数 $p$，满足拓展欧拉定理。

设一个数 $s$，使得 $m=s \times p^k$ 并且 $\gcd(s,p)=1$。根据欧拉定理有 $p^{\varphi(s)} \equiv 1 (\bmod \ s)$。根据欧拉函数的性质 $2$，有 $\varphi(s) | \varphi(m)$，所以 $p^{\varphi(m)} \equiv 1 (\bmod \ s)$。

根据同余的性质两边同时乘上一个 $p^k$。有 $p^{\varphi(m)+k}\equiv p^k (\bmod \ m)$。显然有 $p^b \equiv p^{b-k+k} \equiv p^{\varphi(m)+b}(\bmod \ m)$。其中 $b \geq k$。那么就有 $k \leq \varphi(m)$。因此 $b \geq \varphi(m)$。结论就成立了。

对于一个质数的幂次方，可以用上面的方法证明。最后通过唯一分解定理合并就可证明一般性。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef __int128 LL;
LL Phi(LL n)
{
	LL ans=n;
	for(LL i=2;i*i<=n;++i)
	{
		if(n%i==0)
		{
			ans-=ans/i;
			while(n%i==0)	n/=i;
		}
	}
	if(n>1)	ans-=ans/n;
	return ans;
}
LL QuickPow(LL n,LL p,LL mod)
{
	LL base=n,ans=1;
	while(p)
	{
		if(p&1)	ans=ans*base%mod;
		p>>=1;
		base=base*base%mod;
	}
	return ans%mod;
}
LL mod;
bool flag;
LL read()
{
	LL x=0;
	char c=getchar();
	while(c<'0' || c>'9')	c=getchar();
	while(c>='0' && c<='9')
	{
		x*=10,x+=(c^'0');
		if(x>=mod)	flag=true;
		x%=mod,c=getchar();
	}
	return x;
}
LL readI()
{
	LL x=0;
	char c=getchar();
	while(c<'0' || c>'9')	c=getchar();
	while(c>='0' && c<='9')	x*=10,x+=(c^'0'),c=getchar();
	return x;
}
void write(LL x)
{
	if(x<0)	putchar('-'),x=-x;
	if(x>9)	write(x/10);
	putchar(x%10+'0');
}
int main(){
	LL a=readI(),m=readI();
	mod=Phi(m);
	LL b=read();
	if(flag)	b+=mod;
	write(QuickPow(a,b,m));
	return 0;
}
```

$\ \ $

$\ \ $

---

## 作者：蒟蒻wyx (赞：3)

# 拓展欧拉定理

## 欧拉定理

$\large a ^ {\varphi(p) }\equiv 1\pmod p, (a, p) = 1$

证明略。

## 拓展欧拉定理

引题：[快速幂取余](https://www.luogu.org/problemnew/show/P5091)

> 给你三个正整数，$a,m,b$,你需要求：
 $a ^ b \bmod m$, 满足$1 ≤ a ≤ 10^9$,
 $1≤b≤10^{20000000}$,$1≤m≤10^6$

于是我们考虑运用欧拉定理解决，首先考虑$a$是素数的情况。

令$m = a^r \times s, (a, s) = 1$

又$a ^ {\varphi(m) }\equiv 1\pmod m, (a, m) = 1$

则显然有$a ^ {\varphi(m) + r} \equiv a ^ r\pmod m, (a, m) = 1$

又$(n, p ^ x) $**必然**$= 1$

所以$r $**必然**$\leq \varphi(m)$

所以对于$c \geq \varphi(m)$,  $a ^ {\varphi(m) + c} \equiv a ^ c\pmod m, (a, m) = 1$

同理可得, 对于$a = p ^ x$  ， 上面的式子成立。

然后对于任意的$a$**必然**$ = \prod p_i ^ {a_i}$ , 每一个$ p_i ^ {a_i}$ 都满足。

乘起来，可得$，\forall a \in N，b \geq \varphi(m) $, $a^b \equiv a ^{b \bmod \varphi(m)+ \varphi(m)}\pmod m$

最后我们就有

$$a ^ b \bmod m=\left\{\begin{array}{} a ^{b \bmod \varphi(m) + \varphi(m)}\bmod m&(b \ge \varphi(m) )\\ a ^{b \bmod \varphi(m) }\bmod m & (b < \varphi(m) ) \\\end{array}\right.$$

然后对于题目本身，我们注意到先读入$m$再读入$b$, 所以我们用快读边读入边取余。

不过有坑点：读入的时候注意：如果$$

```
#include<bits/stdc++.h>

using namespace std;

long long n, mod, p, m;

long long phi(long long a){
    long long ans = a;
    for(long long i = 2; i * i <= a; i++) {
        if(a % i == 0){
            ans = ans / i * (i - 1);
            while(a % i == 0)a /= i;
        }
    }
    if(a>1)ans = ans / a * (a - 1);
    return ans;
} 

long long readint(long long j) {
    long long frog = 1, x = 0;char c = getchar();
    while(c < '0' || c > '9' ) {
        if(c == '-')
            frog = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9'){
        x = ((x << 3) + (x << 1) + c - '0') % j;
        c = getchar();
    }
    return x * frog == 0 ? j : x * frog;
}

long long power(long long a, long long b, long long j) {
    long long ans = 1, base = a % j;
    while(b) {
        if(b & 1)
            ans = ans * base % j;
        base = base * base % j;
        b >>= 1;
    }
    return ans;
}

int main() {
    cin >> n >> mod;
    n %= mod;
    p = phi(mod);
    m = readint(p);
    if(m <= p) cout << power(n, m, mod) << endl;
    else cout << power(n, m + p, mod) << endl;
}
```





---

## 作者：baiABC (赞：1)

对于 $a\in \mathbb{Z},b,n\in \mathbb{N}_+,b\geq \varphi(n)$，有 $a^b\equiv a^{b+\varphi(n)}\pmod{n}$。

证明：不妨设 $1\leq a \leq n$。

$a=1$ 结论显然成立。由算术基本定理只需证 $a=p^\alpha(\alpha\geq 1)$ 时成立（$p$ 为质数）。

设 $n=p^\beta n_1,p\nmid n_1$，只需证 $p^{\alpha b}(p^{\alpha\varphi(n)}-1)\equiv0\pmod {n_1}$ 和 $p^{\alpha b}(p^{\alpha\varphi(n)}-1)\equiv0\pmod {p^\beta}$。

对于第一部分，有 $\varphi(n)=\varphi(n_1)\varphi(p^\beta)$，由 Euler 定理，$(p^{\alpha\varphi(p^\beta)})^{\varphi(n_1)}-1\equiv 0\pmod {n_1}$，即得。

对于第二部分，只需证 $\beta\leq\alpha b$，$\beta=0$ 时显然成立，否则有：
$$b\geq\varphi(n)=\varphi(n_1)\varphi(p^\beta)\geq\varphi(p^\beta)=p^\beta-p^{\beta-1}\geq2^\beta-2^{\beta-1}=2^{\beta-1}\geq\beta\geq\dfrac{\beta}{\alpha}$$
证毕。

由此，当 $a\in \mathbb{Z},m\in\mathbb{N}_+$ 时有：
$$a^b\equiv\left\{\begin{matrix}a^b&,b<\varphi(m)\\a^{b\bmod\varphi(m)+\varphi(m)}&,b\ge\varphi(m)\end{matrix}\right.\pmod m$$

代码其他题解有。

---

## 作者：Scrutiny (赞：1)

**扩展欧拉定理：**

当 $b\ge φ(m)$ 时，$a^b\equiv a^{b\text{ mod }φ(m)+φ(m)}(\text{mod m})$

当 $b\le φ(m)$ 时， $a^b\equiv a^{b}(\text{mod m})$

如果读者不知道欧拉函数怎么求，可以看看[这题](https://www.luogu.com.cn/problem/SP4141)的题解。

~~感觉自己的思路有点奇怪。~~

显然$φ(m)\le m-1 \le10^8$。

因此对于大整数 $b$ ，我们可以一个一个读入字符，边读边取模。同时记录一个临时变量`bb`，读入时不取模，溢出也没关系。

如果最终读入的字符个数$\le 9$，直接用快速幂，注意这里的指数要用`bb`。

否则，$b\ge φ(m)$，直接套上面的公式用快速幂即可。

注意，计算欧拉函数前需要存储$m$的值，以便计算快速幂时使用。

不会快速幂的读者可以看看[这题](https://www.luogu.com.cn/problem/P1226)的题解。


**CODE:**

```cpp
#include<bits/stdc++.h>
using namespace std;
long long a,m,b,wddzx,cnt,bb,tmp;
char c;
long long wddzxksm(long long b,long long p,long long mod){
	if(p==1){
		return b%mod;
	}
	if(p==0){
		return 1;
	}
	if(p&1){
		return (b*(wddzxksm((b*b)%mod,p/2,mod)%mod))%mod;
	}
	else{
		return wddzxksm((b*b)%mod,p/2,mod)%mod;
	}
}
int main(){
	scanf("%lld%lld",&a,&m);
	tmp=m;
	wddzx=m;
	for(int i=2;i<=sqrt(m);++i){
		if(!(m%i)){
			wddzx=wddzx*(i-1)/i;
		}
		while(!(m%i)){
			m=m/i;
		}
	}
	if((m-1)){
		wddzx=wddzx*(m-1)/m;
	}
	c=' ';
	while(!((int)c>='0'&&(int)c<='9')){
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		++cnt;
        b=b*10+(int)c-(int)'0';
        bb=b;
        b%=wddzx;
		c=getchar();
	} 
	if(cnt<=9){
		cout<<wddzxksm(a,bb,tmp);
	}
	else{
		cout<<wddzxksm(a,b+wddzx,tmp);
	}
	return 0;
}
```


---


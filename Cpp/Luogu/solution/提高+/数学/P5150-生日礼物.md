# 生日礼物

## 题目背景

wyh 快过生日了，hke 和 ljc 打算送他生日礼物。


## 题目描述

wyh 有一个幸运数字 $n$。现在 hke 打算送他用心度为 $a$ 的礼物，ljc 打算送他用心度为 $b$ 的礼物。两个人的礼物合在一起，用心度为 $\operatorname{lcm}(a,b)$，其中 $\operatorname{lcm}$ 代表最小公倍数。wyh 收到的是这份合在一起的礼物。

如果 wyh 收到礼物的用心度恰好为 $n$，他就会很高兴。现在请问有多少种送礼物的方案使得 wyh 高兴？


## 说明/提示

### 样例解释

这 $9$ 种方案为：$(1,6),(2,6),(3,6),(6,6),(2,3),(3,2),(6,1),(6,2),(6,3)$。

### 数据范围

对于 $30\%$ 的数据，$n \leq 1000$；

对于 $100\%$ 的数据，$n \leq 10^{16}$。


## 样例 #1

### 输入

```
6```

### 输出

```
9
```

# 题解

## 作者：Porsche (赞：26)

## 惊了！居然是紫题？！
#### 我的天，怕不是有史以来做到的最简单的紫题，感觉比我这两天疯狂刷的蓝色的单调队列优化DP还有斜率优化简单多了
##### 思路相当简单，就是分解质因数就行了，注意如果没有分解干净的话记着乘3就行了，千万不要线性筛，要不RE，要不MLE，直接暴力就行了，_nsqrt(n)_绝对不会TLE。
##### 看见诸位已经对我的代码虎视眈眈了（瞎猜的），那我就上代码喽~
```cpp
#include<bits/stdc++.h>
using namespace std;
long long cnt,ans=1;
int main()
{
	long long n;
	scanf("%lld",&n);
	for(int i=2;i<=sqrt(n);i++)
	{
		cnt=0;
		while(!(n%i))
		{
			cnt++;
			n/=i;
		}
		ans*=(cnt<<1|1);
	}
	if(n>1)ans*=3;
	cout<<ans;
	return 0;
}
```
就这么长，大括号还换行了

---

## 作者：Skeleton (赞：17)

这道题需要一个数学知识：唯一分解定理

对于任意的正整数 $N$ 一定有：

$N=a_1^{p_1}×a_2^{p_2}×……×a_n^{p_n}$（$a_i$为质数）

（以下 $N$ 和上面的 $N$ 无关）

通过阅读题意，大致意思是 $N=lcm(m,n)$ 问 （$m,n$）有多少对？（可以互换位置）

分析如下：

首先，我们设 $N=a^p×b^q×……$ （$a$ 和 $b$ 均为质数）

假设 $m$ 的一个因数是 $a^k(0<=k<=p)$，那么当且仅当 $n$ 的一个因数是 $a^p$ 时，才可能有 $lcm(m,n)=N$，也就是说对于 $n$ 若有一个因数是 $a^p$ 则 $m$ 对应可以有因数 $a^k(0<=k<=p)$，所有对于 $N$ 的一个质因数 $a$ 来说，有 $2×p+1$ 种，说明如下：

当 $0<=k<p$ 时，有 $2×p$ 种（$m,n$ 位置可以互换），当 $k=p$ 时，有且仅有一种情况（$m,n$ 互换是一种情况）

那么，同理可得：对于之后的质因数，每一个质因数有 $2×$ 指数位 $+1$ 种情况，由分步计数原理，最好结果只需将这些相乘起来即可。

最后，$Ans=(2×p+1)×(2×q+1)×……$

端上一波代码：

```cpp
void scr(ll k)//欧筛，快一些
{
    for(ll i=2;i<=k;i++)//这里只需从2筛到1e7即可
    {
        if(!unp[i])
        {
            prim[++cnt]=i;
            isp[prim[cnt]]=1;
        }
        for(int j=1;j<=cnt&&i*prim[j]<=sqrt(k);j++)
        {
            unp[i*prim[j]]=1;
            if(!(i%prim[j]))
            {
                break;
            }
        }
    } 
}
```
个人感觉，欧筛会比埃筛更快一些，$isp$ 数组用来之后判断是不是质数。

```cpp
void divi(ll k)//分解质因数
{
    for(ll i=2;i*i<=k;i++)//只需分解到√k即可
    {
        if(k%i==0&&isp[i])
        {
            pr[++tot]=i;
            while(k%i==0)//把所有因数i都除掉，并记录个数
            {
                k/=i;
                prc[tot]++;
            }
        }
    }
    if(k>1)//最后剩余的数要是大于1，则其一定是还未分解到，记录下来
    {
        pr[++tot]=k;
        prc[tot]=1;
    }
}
```
分解质因数这里最重要的事最后那个 $n>1$ 的判断，因为分解出的质因数只到 $\sqrt{k}$ 无法排除之外是否还有其他质因数，要加一个判断。

```cpp
int main()//愉快的主函数
{
    scanf("%lld",&num);
    scr(Maxn);
    divi(num);
    for(int i=1;i<=tot;i++)
    {
        ans*=(2*prc[i]+1);
    }
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：mrsrz (赞：9)

唯一分解定理：

$$N=\prod_{p_i\in\mathbb{P}}p_i^{a_i}$$

我们考虑质因子$p_i$，要保证两个数的$\texttt{lcm}$恰好为$N$，则每个质因子$p_i$都在一个数中恰好有$a_i$个，且在另一个数中不超过$a_i$个。

考虑第一个数有$a_i$个$p_i$，那么第二个数能有$0\sim a_i$个共$a_i+1$种选法。同理第二个数有$a_i$个，第一个数也有$a_i+1$种选法。

其中两个数中都有$a_i$个的情况算重，减掉一种方案。

所以对于每个质因子，有$2a_i+1$种方案。

所以答案为$\prod\limits_{i}(2a_i+1)$。

那么我们对$N$分解质因数即可。

考虑到$N$较大，用Pollard_Rho进行分解，配合Miller_Rabin进行素数测试。时间复杂度$O(\sqrt{\sqrt{N}})$。

## Code：
```cpp
#include<cstdio>
#include<vector>
#include<cstdlib>
#include<algorithm>
typedef long long LL;
inline LL mul(LL a,LL b,const LL&md){
	LL c=a*b-LL((long double)a*b/md+.5)*md;
	return(c>>63&md)+c;
}
LL n,ans=1;
inline LL pow(LL a,LL b,const LL&md){
	LL ret=1;
	for(;b;b>>=1,a=mul(a,a,md))if(b&1)ret=mul(ret,a,md);return ret;
}
namespace MR{
	const int P[]={2,3,5,7,11,13,17,19,23,29,31,37};
	bool check(int a,LL n){
		LL x=n-1;int d=0;
		while(!(x&1))x>>=1,++d;
		for(x=pow(a,x,n);d--;){
			const LL lst=x;x=mul(x,x,n);
			if(x==1&&lst!=1&&lst!=n-1)return 0;
		}
		return x==1;
	}
	bool test(LL n){
		if(n==1)return 0;
		for(int i:P)if(n==i)return 1;
		if(!(n&1))return 0;
		for(int i:P)if(!check(i,n))return 0;
		return 1;
	}
}
std::vector<LL>v;
LL find(LL n,int c){
	LL x=rand()%(n-1)+1,y=x,k=2,q=1,t=1;
	for(;;k<<=1,y=x,q=1){
		for(int i=1;i<=k;++i){
			x=mul(x,x,n)+c-n;x+=x>>63&n;
			q=mul(q,llabs(x-y),n);
			if(!(i&127)){
				t=std::__gcd(q,n);
				if(t>1)return t;
			}
			t=std::__gcd(q,n);
			if(t>1)return t;
		}
	}
}
void rho(LL n){
	if(n==1)return;
	if(MR::test(n))return v.push_back(n);
	LL p=n;int c=19260817;
	while(p==n)p=find(p,c--);
	while(n%p==0)n/=p;
	rho(p),rho(n);
}
int main(){
	srand(20040607);
	scanf("%lld",&n);
	rho(n);
	for(LL i:v){
		int a=0;
		while(n%i==0)n/=i,++a;
		ans*=a<<1|1;
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

其实不需要什么Pollard_Rho，只需要Miller_Rabin一次就够了。

首先把$\sqrt[3]N$以内的质因数筛出来，然后剩下的数显然最多有2个质因子。

分三类：

1. 该数为完全平方数，则多出来了一个$p^2$，答案乘5。
2. 该数为质数，则多出来一个$p$，答案乘3。
3. 其他情况，则多出来两个不同的$p$，答案乘9。

时间复杂度$O(\sqrt[3]N)$。

筛子都不用打。

## Code：
```cpp
#include<cstdio>
#include<cmath>
typedef long long LL;
inline LL mul(LL a,LL b,const LL&md){
	LL c=a*b-LL((long double)a*b/md+.5)*md;
	return(c>>63&md)+c;
}
LL n,ans=1;
inline LL pow(LL a,LL b,const LL&md){
	LL ret=1;
	for(;b;b>>=1,a=mul(a,a,md))if(b&1)ret=mul(ret,a,md);return ret;
}
namespace MR{
	const int P[]={2,3,5,7,11,13,17,19,23,29,31,37};
	bool check(int a,LL n){
		LL x=n-1;int d=0;
		while(!(x&1))x>>=1,++d;
		for(x=pow(a,x,n);d--;){
			const LL lst=x;x=mul(x,x,n);
			if(x==1&&lst!=1&&lst!=n-1)return 0;
		}
		return x==1;
	}
	bool test(LL n){
		if(n==1)return 0;
		for(int i:P)if(n==i)return 1;
		if(!(n&1))return 0;
		for(int i:P)if(!check(i,n))return 0;
		return 1;
	}
}
int main(){
	scanf("%lld",&n);
	for(int i=2;i<=233333;++i)if(n%i==0){
		int cnt=1;
		while(n%i==0)cnt+=2,n/=i;
		ans*=cnt;
	}
	if(n>1){
		int x=sqrt(n)+.5;
		if(LL(x)*x==n)ans*=5;else
		if(MR::test(n))ans*=3;else ans*=9;
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：qpdk777 (赞：6)

虽然题目不难，但背后蕴含的考点还是很有意思的。

本题的核心考点是**唯一分解定理**。

# 此考点曾在NOIP中涉及，非常重要！！！

例如 [NOIP2009 Hankson的趣味题](https://www.luogu.com.cn/problem/P1072)

唯一分解定理：设 $p_i$ 表示第 $i$ 个质数，那么对于任意正整数$N$，都有**唯一的**一组 $a_1,a_2,a_3\dots a_n$ ，使得

$$N=p_1^{a_1}\times p_2^{a_2}\times p_3^{a_3}\times\dots\times p_n^{a_n}$$

其中 $a_i$ 可以等于$0$。

用白话文说：任何数都可以表示为他的质因数们的若干次幂的乘积，而幂指数序列是确定的。

推论：对于 $\forall x,y$ ，其中

$$x=p_1^{a_1}\times p_2^{a_2}\times p_3^{a_3}\times\dots\times p_n^{a_n}$$

$$y=p_1^{b_1}\times p_2^{b_2}\times p_3^{b_3}\times\dots\times p_n^{b_n}$$

则

$$\gcd(x,y)=p_1^{\min(a_1,b_1)}\times p_2^{\min(a_2,b_2)}\times p_3^{\min(a_3,b_3)}\times\dots\times p_n^{\min(a_n,b_n)}$$

$$\operatorname{lcm}(x,y)=p_1^{\max(a_1,b_1)}\times p_2^{\max(a_2,b_2)}\times p_3^{\max(a_3,b_3)}\times\dots\times p_n^{\max(a_n,b_n)}$$

回到本题，给定整数 $n$ ，求有多少对 $x,y$ ，满足 $\operatorname{lcm}(x,y)=n$ 。

对 $n$ 分解质因数，得到 $n$ 的唯一分解序列 $S=\{a_1,a_2,a_3,\dots,a_n\}$ 。

对于序列中的每一个元素 $a_i$ ，要求 $x,y$ 的分解序列中的对应元素 $x_i,y_i$ **更大的那个**与 $a_i$ 相等，另一个可以在 $[0,a_i-1]$ 中任取。

当 $x_i=a_i$ 时， $y_i\in[0,a_i-1]$ ，共 $a_i$ 种方法；

当 $y_i=a_i$ 时， $x_i\in[0,a_i-1]$ ，共 $a_i$ 种方法。

根据加法原理，应有 $d_i=2\times a_i$ 种方法。

然而，刚刚的计算中， $\begin{cases}x_i=a_i\\y_i=a_i\end{cases}$ 的情况被算了两次，因此要减1。

对于分解序列中的其他元素，根据乘法原理，各个质因数直接的方法互不干涉，最终的答案应当是各 $d_i$ 相乘的积
$$\prod_{i=1}^n d_i$$

最后是时间复杂度分析。

计算的瓶颈在于分解质因数，如果使用Pollard_Rho进行分解，时间复杂度为 $O(\sqrt{\sqrt{n}})$ ，非常小的一个数；然而如果用暴力分解质因数，时间复杂度为 $O(\sqrt n)$ ，实际测试中可以通过本题。

实际上，在许多题目中，如果 $n$ 在longlong范围内且没有多组数据， $O(\sqrt n)$ 的时间复杂度是很难TLE的。

所以本题就轻松愉快地解决啦！

总结：

1. 唯一分解定理的内容及其推论，务必牢记

2. 如果组成问题的各个“位”之间相互独立，可以考虑把待求解的问题“按位分解”，这种思想不仅在数论题中十分重要，在动态规划中也经常出现。

AC代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#define re register
typedef long long ll;
using namespace std;

ll n,cnt,ans = 1;

int main(){
	cin>>n;
	for(re int i = 2; i < sqrt(n); ++i){
		cnt = 0;
		while(n%i==0){
			++cnt;
			n /= i;
		}
		if(cnt) ans *= (cnt<<1)+1;
	}
	if(n>1) ans *= 3;//n>1
	cout<<ans<<endl;
	
	return 0;
}
```


---

## 作者：一扶苏一 (赞：5)

[更好的阅读体验](https://www.cnblogs.com/yifusuyi/p/10248113.html)

## Description

给定 $n$，求

$$\sum_{i}~\sum_j~[lcm(i,j)~=~n]$$

## input

一行一个整数代表 $n$

## Output

一行一个整数代表答案

## Hint

$1~\leq~n~\leq~10^{16}$

## Solution

一开始看到这个形式以为是反演，然后看到数据范围就自闭了……

然后发现这是个唯一分解定理题……

吐槽一下标算 $O(\sqrt{n})$ 暴力卡常 范围出1e16也太[数据删除]了吧（大雾

然后用py写了一发和标算差不多的暴力，惨遭卡常

所以这里来提供一种 $O(\sqrt[3]{n})$ 的方法！

其实就是讨论里 @[mrsrz](https://www.luogu.org/space/show?uid=6813) 神仙的第一种踩标算做法

设

$$n~=~\prod_{i = 1}^{k} p_i^{c_i}$$

$$x~=~\prod_{i = 1}^k p_i^{d_i}$$

$$y~=~\prod_{i = 1}^{k}~p_{i}^{e_i}$$

其中 $p$ 为质数。

则显然有

$$lcm(x, y)~=~n~\Leftrightarrow~\forall~i~\in~[1,k],c_i~=~\max(d_i,e_i)$$

我们考虑固定 $x$ 第 $i$ 位指数即 $d_i~=~c_i$，则 $e_i$ 选 $[0,c_i]$ 都是合法的，共 $c_i~+~1$ 中选法。将 $x,y$ 反过来同样成立。但是注意固定 $d_i~=~c_i$ 时令 $e_i~=~c_i$ 的选法和反过来是一样的，于是要把这个方案扣除 $1$。

所以对于第 $i$ 个质因子的方案数为 $(2~\times c_i~+~1)$。根据乘法原理，总方案数为

$$\prod_{i = 1}^{k}~(2~\times~c_i~+~1)$$

于是 $O(\sqrt{n})$ 分解一下，发现py被卡常了。我们考虑一种更优秀的做法：

我们在分解质因数时，分解到 $\sqrt[3]{n}$，即当 $i^3~>~n$ 时停止。考虑现在 $n$ 除掉已经筛出的质因子后剩下的值共有如下几种情况：

> 剩下 $1$：这种情况对答案无贡献，无需理会
>
> 剩下的数是一个质数：显然这个剩下的数是 $n$ 的最后一个质因子，并且指数显然为 $1$，于是直接将答案乘 $3$ 即可

考虑除去这两种情况外，剩下的数只能是两个质数的积，而不可能是更多质数的积。

证明上，可以设剩下的最小的质数是 $p$，则有 $p~>~\sqrt[3]{n}$，假设是 $k$ 个质数的乘积，那么显然有剩下的数字 $dn~\geq~p^k$。由于 $p^3~>~(\sqrt[3]{n})^3~=~n$，$dn~\leq~n$，则在 $k~\geq~3$ 时产生矛盾，于是 $k~\leq~2$。

再分两种情况：

> 剩下的数是一个质数的平方：直接将答案乘 $5$ 即可
>
> 否则一定是两个质数相乘。考虑每个质数贡献 $3$，所以将答案乘上 $9$ 即可。

考虑如何快速判断剩下的数字是一个质数：直接进行米勒拉宾质数判定，时间复杂度 $O(\log n)$。

考虑不损失精度的判断一个数是一个完全平方数：直接进行二分开方，时间复杂度 $O(\log n)$

于是总时间复杂度 $O(\sqrt[3]{n})$，踩爆标算

## Code

```cpp
def mpow(x, y, p):
	_ret, _temp = 1, x
	while y:
		if y & 1:
			_ret = _ret * _temp % p
		_temp = _temp * _temp % p
		y >>= 1
	return _ret

def ML(x, n):
	if n == x: return 1
	sn = n - 1
	s, d = n - 1, 0
	while not (s & 1):
		s >>= 1
		d += 1
	t = mpow(x, s, n)
	if t == 1 or t == -1: return 1
	for i in range(d):
		if t == sn: return 1
		t = t * t % n
	return 0

def IsPrime(x):
	if not (x & 1):
		if x == 2: return 1
		else: return 0
	elif not ML(2, x): return 0
	elif not ML(7, x): return 0
	elif not ML(61, x): return 0
	else: return 1

def IsPow(x):
	l, r, mid, = 1, x, 0
	while l <= r:
		mid = (l + r) >> 1
		k = mid * mid
		if k < x: l = mid + 1
		elif k == x: return 1
		else: r = mid - 1
	return 0

n = int(input())

ans, i, dn = 1, 2, n

while (i * i * i) <= n:
	if (dn % i) == 0:
		cnt = 0
		while (dn % i) == 0:
			dn //= i
			cnt += 1
		ans *= (cnt << 1) + 1
	i += 1
if dn != 1:
	if IsPrime(dn):
		ans *= 3
	elif IsPow(dn):
		ans *= 5
	else:
		ans *= 9
		
print(ans)
```

---

## 作者：_ztyqwq (赞：4)

前置：唯一分解定理

$$ n = \prod p_i^{x_i} $$

其中 $ p_i $ 为质数

~~说人话，就是质因数分解~~

---

考虑两个数的 $ \rm{lcm} $ 值。如果 $ a = \prod p_i^{x_i}, b = \prod p_i^{y_i} $（假设两个数的 $ p $ 集合相同）

那么 $ \rm{lcm}$ $(a, b) = \prod p_i^{\max(x_i, y_i)} $

举个例子，$ 12 = 2^2 \times 3 $，$ 54 = 2 \times 3^3 $

那么 $ \rm{lcm}$ $(12, 54) = 2^2 \times 3^3 = 108 $

简单理解一下，对于每一个质因子，因为要保证 $\rm{lcm}$ 被 $ a $ 整除，因此 $\rm{lcm}$ 中该质因子的个数应当至少（大于等于）为 $ x_i $（$ a $ 中该质因子的个数）

同理也应该大于等于 $ y_i $（$ b $ 中该质因子的个数）

---

那么如果确定了 $\rm{lcm} $ 中某一质因子的个数，不妨设这个质因子为 $ p $，个数为 $ x $

则 $ a, b $ 中质因子 $ p $ 的个数共有 $2x + 1 $ 种情况：

$ a $ 中 $ 0 $ 个，$ b $ 中 $ x $ 个；

$ a $ 中 $ 1 $ 个，$ b $ 中 $ x $ 个；

$ a $ 中 $ 2 $ 个，$ b $ 中 $ x $ 个；

……

$ a $ 中 $ x $ 个，$ b $ 中 $ x $ 个；

$ a $ 中 $ x $ 个，$ b $ 中 $ x - 1 $ 个；

……

$ a $ 中 $ x $ 个，$ b $ 中 $ 0 $ 个；

也就是其中任意一个数有 $ x $ 个 $ p $ 质因子，剩下那个可能有 $ 0 \sim x $ 个

---

又根据乘法原理，如果对于 $ p_i $ 这个质因子，$ a, b $ 有 $ s_i( = 2x_i + 1) $ 种取值

那么总方案数 $ = \prod s_i $

所以只要先将 $ n $ 质因数分解，再按上述公式计算即可

---

于是你兴冲冲地打完 $ O(n) $ [线性筛](https://www.luogu.com.cn/problem/P3383)（只需要筛到 $ \leqslant \sqrt n $ 的质数，记得处理最后剩下一个 $ > 10^8 $ 的质数的情况.），交上去时：TLE

接下来就是卡常小 trick 了

0. O2, O3, Ofast, 火车头

1. I/O 优化（此题用处微乎其微）

2. register, inline

3. 短路运算符（用处不大）

4. __虽然说“不开 `long long` 见 * *”，但是 `#define int long long` 确实会让程序性能下降不少。不需要 `long long` 的地方可以用 `int	`。（本题效果显著）__

5. 如果 MLE，可能是存放质数的数组太大。事实上，不需要开到 $ 10^8 $ 个质数，因为 $ 10^8 $ 以内的质数只有 $ 5761455 $ 个。

虽然复杂度没有 dalao 们的神奇数学优秀 orz，但是足够通过此题了

Code: 

```cpp
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#include <bits/stdc++.h>
using namespace std;
#define ll long long
bool isp[100000001];
int primes[6000000], pcnt = 0;
void Init(int n)
{
	isp[1] = true;
	for(register int i = 2; i <= n; i++)
	{
		if(!isp[i])
			primes[++pcnt] = i;
		for(register int j = 1; (ll)i * primes[j] <= n && j <= pcnt; j++)
		{
			isp[i * primes[j]] = true;
			if(i % primes[j] == 0)
				break;
		}
	}
}
signed main()
{
	ll n;
	scanf("%lld", &n);
	Init(sqrt(n));
	ll ans = 1;
	for(int i = 1; i <= pcnt; i++)
	{
		if(n % primes[i] == 0)
		{
			int res = 0;
			while(n % primes[i] == 0)
			{
				n /= primes[i];
				res++;
			}
			ans *= (2 * res + 1);
			if(n == 1)
				break;
		}
	}
	if(n > 1)
		ans *= 3;
	printf("%lld\n", ans);
	return 0;
}
```

---

## 作者：彼岸归航 (赞：3)

因为 $n = lcm(a, b)$ ，可以得出：
- $ a $ 和 $ b $ 的质因数都是 $ n $ 的质因数
- 对于 $ n $ 的每个质因数 $ x $ ，在 $ n $ 中的次数为 $ y $ ，那么 $ x $ 在 $ a $ 和 $ b $ 中至少有一个次数为 $y$ ，在另一个中的次数 $<=y$。

所以我们只要把 $ n $ 的每个质因数的次数求出来就好了。~~（这部分我好像讲得很糟糕，大家还是看 Skeleton 大佬的题解吧）~~

具体实现我没有用到筛质数而是直接除。以下是80分TLE代码：
```
#include<bits/stdc++.h>

typedef unsigned long long ull; 

ull n; 

int cnt = 1; 
char vis[10000003]; 

ull res = 1; 

void get(ull x, ull in) { // x 表示除剩下的部分，in 表示当前枚举到的数（不用管是不是质数，不是的话肯定已经除完了）
    if(x == 1) return ; 
    while(x % in) in += 2; // 2 已经做掉了，后面的质数都是奇数
    cnt++; // 新的一个能除的
    while(x % in == 0) x /= in, vis[cnt]++; // 统计能除几次
    get(x, in + 2); 
}

int main() {
    scanf("%lld", &n); 

    while((n & 1) == 0) n >>= 1, vis[1]++; 
    get(n, 3); 
    for(int i = 1; i <= cnt; i++) res *= 2ll * (int)vis[i] + 1; 

    printf("%lld\n", res); 

    return 0; 
}
```

这个时候可以用 $ \sqrt{n} $ 来优化一下。如果当前枚举到的数已经超过 $\sqrt{n}$ 并且除剩下的不是 $ 1 $ ，说明剩下的肯定是个质数，因为其他质数都枚举完了。注意这里不能用 $ \sqrt{x} $ 来判断，原因想想应该就能明白~~而且我一开始就是这样做的几乎WA光~~

AC代码：
```
#include<bits/stdc++.h>

typedef unsigned long long ull; 

ull n; 

int cnt = 1; 
char vis[10000003]; 

ull k, res = 1; 

void get(ull x, ull in) {
    if(x == 1) return ; 
    while(x % in) {
        in += 2; 
        if(in > k) {
            vis[++cnt] = 1; 
            return ; 
        }
    }
    cnt++; 
    while(x % in == 0) x /= in, vis[cnt]++; 
    get(x, in + 2); 
}

int main() {
    scanf("%lld", &n); 

    while((n & 1) == 0) n >>= 1, vis[1]++; 
    k = sqrt(n); 
    get(n, 3); 
    for(int i = 1; i <= cnt; i++) res *= 2ll * (int)vis[i] + 1; 

    printf("%lld\n", res); 

    return 0; 
}
```

---

## 作者：山隐归林 (赞：2)

题目大意：求满足lcm(a,b)=n的有序数对(a,b)的个数。n<=1e16.

水法：若lcm(a,b)=n,那么a,b一定是n的因数。

朴素的想法就是O(√n)**分解因数**，然后暴力枚举判断。

经实测1e16内某个数最大的因子个数在1e4级别(用2×3×5×……构造出的极端数据)

但是你的复杂度带了个log

总之这样写会爆一组数据。

然后，~~打表大法！~~

~~真是丢人现眼啊~~或许这玩意再优化一下能跑过去？
```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll yin[100010],tot;
char buf[1<<15],*fs,*ft;
inline char getc(){return (ft==fs&&(ft=(fs=buf)+fread(buf,1,1<<15,stdin),ft==fs))?0:*fs++;}
inline ll read()
{
    ll x=0,f=1;  char ch=getc();
    while(!isdigit(ch))  {if(ch=='-')  f=-1;  ch=getc();}
    while(isdigit(ch))  {x=(x<<1)+(x<<3)+(ch^48);  ch=getc();}
    return x*f;
}
void put(ll x)
{
    if(x==0){putchar('0');putchar('\n');return;}
    if(x<0){putchar('-');x=-x;}
    ll num=0;char ch[25];
    while(x) ch[++num]=x%10+'0',x/=10;
    while(num) putchar(ch[num--]);
    putchar('\n');
}
inline ll gcd(ll a,ll b){return b==0 ? a : gcd(b,a%b);}
int main()
{
    register int i,ans=0,j;
    register ll linx,linj;
    long long kkk;
    kkk=read();
    if(kkk==608500527054420ll) {cout<<2657205<<endl;return 0;}
    if(kkk==304250263527210ll) {cout<<1594323<<endl;return 0;}
    ll kkkk=sqrt(1.0*kkk);
    for(i=1;i<=kkkk;++i)
    {
        if(kkk%i==0) 
        {
            yin[++tot]=i,yin[++tot]=kkk/i;
            if(kkk/i==i) --tot;
        }
    }
    sort(yin+1,yin+1+tot);
    for(i=1;i<=tot;++i)
    {
        for(j=tot;j>i;--j)
        {
            if(yin[j]<kkk/yin[i]) break;
            linx=gcd(yin[i],yin[j]);
            linj=yin[j]/linx*yin[i];
            if(linj==kkk) ans+=2;
        }
    }
    put(ans+1);
    return 0;
}
```

正解(还能优化，看代码的下面)：对n**分解质因数**n=p1^a1×p2^a2……

现在只关注p1这种质因数。

对a,b分解a=x1×p1^k1,b=x2×p2^k2.

若想要lcm(a,b)的p1的指数为a1,显然有k1=a1或k2=a1.

若k1!=k2,当k1=a1时，k2能取0到(a1-1)共a1种值。

由于(a,b)的有序性，同理当k2=a1时，k1也有a1种取值。

这总共是2×a1种情况。

但别忘了k1==k2这种情况。

对于不同的p，a,b的对数满足乘法原理。

即ans=(2a1+1)×(2a2+1)×……×(2an+1)。

复杂度O(√n)。
```cpp
/*
求lcm(a,b)=n的有序数对(a,b)的个数。
首先，对n分解质因数。
n=p1^a1*p2^a2...
只针对p1时
若a中含有因数p1^k(0<=k<a1),则b中必须有因数p1^a1,才能保证他们的lcm=n;
这时候k有a1种情况。
a,b互换又多了a1种情况。
k=a1时(a,b)=(b,a)只多了一种；
当针对所有的p时，ans=(2*a+1)的乘积
*/
#include<bits/stdc++.h>
using namespace std;
inline long long read()
{
    long long num=0,f=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
    while(isdigit(ch)){num=num*10+ch-'0';ch=getchar();}
    return num*f;
}
void put(int x)
{
    if(x==0) {putchar('0');return;}
    if(x<0) {x=-x;putchar('-');}
    int num=0;char ch[25];
    while(x) ch[++num]=x%10+48,x/=10;
    while(num) putchar(ch[num--]);
    return;
}
int main()
{
    long long n=read();
    int sqrn=sqrt(n*1.0);
    int ans=1;//可以证明，至少有一种方案
    for(register int i=2;i<=sqrn;++i)
    {
        int cnt=0;
        while(n%i==0)
        {
            ++cnt;
            n=n/i;
        }
        ans=ans*(cnt*2+1);
    }
    if(n>1)ans=ans*(2+1);//若n>1说明此时的n是质数
    put(ans);
    return 0;
}

```

补充一段：关于O(√n)筛的优化：

把n当中的小于等于n^(1/3)的质因子全部先删掉，最后剩下一个数。

显然有几种情况之一：

1.这个数是1，什么也不做;

2.这个数是完全平方数，答案再乘(2×2+1)=5;

3.这个数是质数，答案再乘(2×1+1)=3;

4.这个数是两个质数的乘积，答案再乘(2×1+1)×(2×1+1)=9。

也就是说，最终正解由O(√n)优化至O(n^(1/3))。

~~虽然洛谷的机子跑O(√n)就能过，但是肯定越优越好。~~

(以上参考自mrsrz大佬)

---

## 作者：YangHHao (赞：1)

### 题目描述

给一个正整数 $n(n \le 10^{16})$，求有多少组正整数 $(a,b)$ 使得 $lcm(a,b) = n$ 成立。

### 分析

令 $a=p_1^{\alpha_1}\cdot p_2^{\alpha_2}\dots p_k^{\alpha_k}$，
$b=p_1^{\beta_1}\cdot p_2^{\beta_2}\dots p_k^{\beta_k}$ 

则易知约束条件等价于 $\large\prod\limits_{p \in prime \wedge p|a\text{或}b} p^{\min(\alpha,\beta)} = n$，此时即可对于 $n$ 的每个素因子及其次数 $q^{k}$，求出其对答案的贡献 $\large\sum\limits_{i=0}^{k}\sum\limits_{j=0}^{k}[\max(i,j)=k]=2k+1$，然后根据乘法原理，相乘即得答案。

此方法时间复杂度 $\large \rm{O}(\sqrt{n})$，空间复杂度 $\large \Theta(1)$，在此题无大素数的情况下足以通过。

### AC code

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,ans=1;
signed main(){
	scanf("%lld",&n);
	for(int i=2;1LL*i*i<=n;i++){
		if(n%i)continue;
		int cnt=0;
		while(n%i==0)n/=i,cnt++;
		ans*=(cnt<<1|1);
	}
	if(n>1)
		ans+=(ans<<1);
	printf("%lld\n",ans);
}
```


---

## 作者：nomonick (赞：1)

# 题解 P5150 【生日礼物】

这道题想法很好考虑，首先要用将 $n$ 分解质因数。

首先把素数筛出来，这里用欧拉筛法，将素数全部筛出来

```cpp
inline void get_prime()
{
	for (int i = 2; i <= SIZE; ++i)
	{
		if (!vis[i])
		{
			prime[++cnt] = i;
			isw[prime[cnt]] = true;
		}
		for (int j = 1; j <= cnt && i * prime[j] <= sqrt(SIZE); ++j)
		{
			vis[i*prime[j]] = true;
			if (!(i % prime[j])) break;
		}
	}
}
```

而对于每一个 $n$ 都一定可以转化成几个素数的乘积：

$$
n = prime_1 \times prime_2 \times \cdots \times prime_k
$$

又因为是求出 $n = lcm (a,b)$ 所以只要求出这样的 $a$ 和 $b$ 有多少对（$a$ 和 $b$ 可以调换）

我们计算 $n$ 的质因子 $prime_i$ ，要保证两个数的最小公倍数恰好 $n$ 则每个质因数 $prime_i$ 都在一个数中正好有 $p$ 个，且在一个数中不超过 $p$ 个。

考虑第一个数有 $p$ 和 $prime_i$ ，那么第二个数能有 $0 - p$ 个共 $p + 1$ 种选择方法。同理第二个数有 $p$ 个，第一个数也有 $p + 1$ 种选法。

又因为两个数中都有 $p - 1$ 个的情况下可以被重复计算。

所以对于每一个素数都有 $2 * p + 1$ 种方案，所以：

$$
ans = \prod_{i \in prime[]} (2 * p + 1)
$$

最后特判一下 $n = 1$ 的情况，即可

# code
```cpp
/*
	coder: yangwenbin
	time: 2020-12-30 18:33:14
	algorithm: math & Prime sieve
	Difficulty: [Purple] Provincial Selection/NOI-
	NO.1 [AC] Accepted. 
*/
#include <bits/stdc++.h>
using namespace std;

#define int long long
const int SIZE = 1e7 + 50;

inline int read()
{
	int x = 0,f = 1;
	char ch = getchar();
	while (ch < '0' || ch > '9')
	{
		if (ch == '-') f = -1;
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9')
	{
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
	return f * x;
}

int n,cnt,tot,ans = 1;
int prime[SIZE],factor[SIZE],tim[SIZE];
bool isw[SIZE],vis[SIZE];

inline void get_prime()
{
	for (int i = 2; i <= SIZE; ++i)
	{
		if (!vis[i])
		{
			prime[++cnt] = i;
			isw[prime[cnt]] = true;
		}
		for (int j = 1; j <= cnt && i * prime[j] <= sqrt(SIZE); ++j)
		{
			vis[i*prime[j]] = true;
			if (!(i % prime[j])) break;
		}
	}
}

inline void pre()
{
	for (int i = 2; i * i <= n; ++i)
	{
		if (n % i == 0 && isw[i])
		{
			factor[++tot] = i;
			while (n % i == 0)
			{
				n /= i;
				tim[tot]++;
			}
		}
	}
	if (n == 1) return;
	prime[++tot] = n;
	tim[tot] = 1;
}

signed main()
{
	n = read();
	get_prime();
	pre();
	for (int i = 1; i <= tot; ++i)
	{
		ans *= 2 * tim[i] + 1;
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：nydzsf_qwq (赞：1)

~~这题估计是最水的紫题了~~

------------
### 题解部分

设 $n=p_1^{q_1}\cdot p_2^{q_2}\cdots p_k^{q_k}$。

由 $lcm(a,b)=n$ 可知 $a,b$ 的素因子一定为 $n$ 的素因子。

对于每一个 $p_i$ ，设 $a,b$ 中分别含有 $x_i,y_i$ 个 $p_i$，则 $x_i,y_i$ 一定满足 $\max(x_i,y_i)=p_i$，共有 $2q_i+1$ 对非负整数对 $(x_i,y_i)$ 满足要求。

所以可以得出
$$
ans=\prod_{i=1}^{k}（2q_i+1）
$$

```c++
#include<bits/stdc++.h>
using namespace std;
long long n,ans=1;
int main() {
	scanf("%lld",&n);
	for(long long i=2;i*i<=n;++i) {//long long不替换为int，因为i*i可能会爆int（不过用1ll*i*i应该也行）
		int cnt=0;
		while(n%i==0) {
			++cnt;
			n/=i;
		}
		ans*=2*cnt+1;
	}
	if(n!=1) ans*=3; //最后如果还剩下一个素数的话还要再乘3
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：ricky0916 (赞：1)

~~建议将这题改成橙题，这题比我不会的绿题还要简单~~

## P5150 题解

题目：求$ [x,y]=n $的$ (x,y) $对数（$ [x,y] $就是$ lcm(x,y) $）

解析：

（注：这里为了不涉及到$ 0 $个实数相乘的事情，所以我们分两类）

$ 1.n=1 $时，只有$ (1,1) $这$ 1 $组

$ 2.n>1 $，设$ n=\prod_{i=1}^k p_i^{q_i} $（$ p_1,p_2......p_k $为$ k $个互不相等的质数，$ k\geqslant1 $）

同时，设$ a=\prod_{i=1}^k p_i^{\alpha_i},b=\prod_{i=1}^k p_i^{\beta_i} $

由于$ [a,b]=n $，所以必须满足$ \forall 1 \leqslant i \leqslant k ,\max(\alpha_i,\beta_i)=q_i $

可设$ ans_i $为第$ i $个满足$ \max(\alpha_i,\beta_i)=q_i $的种类数，则根据排列组合，$ ans=\prod_{i=1}^kans_i $

好，现在我们解决$ ans_i $

考虑枚举，当$ \alpha_i=q_i $时，$ \beta_i$可以是$0,1,......,q_i $，有$ q_i+1 $种

同理，$ \beta_i=q_i $时，有$ q_i+1 $种

但是，$ \alpha_i=\beta_i=q_i $的情况被算了$ 2 $次，所以$ ans_i=2\times (q_i+1)-1=2\times q_i+1 $

所以，一个基础的质因数分解就行了，虽然$ n $较大，但是不需要$ Pollard\_Rho $算法优化 ~~（反正我也不会）~~

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,ans=1;
int main(){
    scanf("%lld",&n);
    for(long long i=2;i*i<=n;i++){
        int cnt=0;
        if(n%i==0){
            while(n%i==0){
                  n/=i;
                 cnt++;
            }
        }
        ans*=(2*cnt+1);
    }
    if(n>1) ans*=3;
    printf("%lld",ans);
    return 0;
}
```


---

## 作者：MZAutomata (赞：0)

前置芝士：唯一分解定理
$$n=\prod\limits_{p_i\in\mathbb{P}}p_i^{\alpha_i}$$

回到题目，我们先将问题简化为 $n=p_1^a\ ,\ p_1\in\mathbb{P}$ 的情况，考虑其质因子的幂次 $a,b$ 对答案产生的贡献。

考虑两个数 $x,y$，它们满足 $\left[x,y\right]=n$，则两数中必有至少一数含有因子 $p_1^a$。

容易想到当 $x$ 中含有因子 $p_1^a$ 时，$y$ 中因子 $p_1$ 的幂次的取值可以是从 $0$ 到 $a$，共 $(a+1)$ 种情况。

同理，当 $y$ 中含有因子 $p_1^a$ 时，又可以取 $(a+1)$ 种情况。注意到当 $x,y$ 同时拥有因子 $p_1^a$ 时，两种情况是等价的，因此它们最终对答案产生的贡献是 $2a+1$。

那么我们先将质数筛出，对 $n$ 分解质因数，然后依乘法原理计数即可。

## Code
```cpp
#include<cstdio>
const int N(1e7);
int tot,pr[N];
bool vis[N];
int main()
{
	long long n,cnt,ans(1),i,j;
	scanf("%lld",&n);
	for(i=2;i<N;i++)
	{
		if(!vis[i])pr[++tot]=i;
		for(j=1;j<=tot&&pr[j]*i<N;j++)
		{
			vis[pr[j]*i]=true;
			if(i%pr[j]==0)break;
		}
	}
	for(i=1;i<tot;i++)
	{
		for(cnt=0;n%pr[i]==0;n/=pr[i])cnt++;
		ans*=cnt<<1|1;
		if(n==1)break;
	}
	if(n>1)ans*=3;
	printf("%lld",ans);
	return ~~(0-0);
}
```


---


# [Cnoi2019] 数学课

## 题目描述

聪明的 Cirno 开始学习计算，于是她很开心的算出了从 $1$ 一直加到 $n$。

得到了一个 $n$ 项的数列 : $ \{ a_n$ = $1 + 2 + 3 + 4 + ... + n \} $

为了验证自己算是否算错，她需要以某种规律从数列里取出两个元素 $v_1, v_2$（元素可以相同），并等概率的选出整数 $a \in [ 1,v_1 ]$，$b \in [ 1,v_2 ]$ 判断哪个比较大.

所以她需要你来计算 $a>b$ 的概率。

某种规律：
选到数列第 $i$ 个元素的概率是：

$$\frac{a_i}{\sum\limits_{n=1}^n a_n}=\frac{3i\times(i+1)}{n(n+1)(n+2)}$$

## 说明/提示

对于前 $5\%$ 的数据 $n = 3$；

对于前 $15\%$ 的数据 $n \le 100$；

对于前 $30\%$ 的数据  $n \le 5000$；

对于前 $55\%$ 的数据 $n \le 10^7$；

对于前 $95\%$ 的数据 $1\le n \le 10^{18}$；

对于最后 $5\%$ 的数据 $n = 0$ 表示 **正无穷**；

对于 100% 的数据 $n$ 不为 $998244353$ 的倍数。

## 样例 #1

### 输入

```
2```

### 输出

```
686292993```

# 题解

## 作者：Binary_Search_Tree (赞：24)

### [题目传送门](https://www.luogu.org/problem/P5389)

因为a和b的产生方式完全相同，所以a>b与a<b的概率是相等的。

设p表示a=b的概率，那么答案就是$\frac{1-p}{2}$

**问题转化为如何计算a=b的概率。**

对于数列中的第i个元素，$a_i$=$\sum_{j=1}^ij$=$\frac{i(i+1)}{2}$ 

那么恰好选中第i个元素中的一个数的概率:
### $\frac{3i(i+1)}{n(n+1)(n+2)}$×$\frac{1}{\frac{i(i+1)}{2}}$=$\frac{6}{n(n+1)(n+2)}$

因为1在数列中被n个元素包含，2----3被(n-1)个元素包含，4----6被(n-2)个元素包含，

$\frac{i(i-1)}{2}$+1----$\frac{i(i+1)}{2}$被(n+1-i)个元素包含，

所以选中$\frac{i(i-1)}{2}$+1----$\frac{i(i+1)}{2}$中任意一个数的概率为
$\frac{6(n+1-i)}{n(n+1)(n+2)}$

所以得到p的表达式

### p=$\sum_{i=1}^ni×[\frac{6(n+1-i)}{n(n+1)(n+2)}]^2$=$\frac{36\sum_{i=1}^ni(n+1-i)^2}{[n(n+1)(n+2)]^2}$=$\frac{3}{n(n+2)}$

所以答案是$\frac{1-\frac{3}{n(n+2)}}{2}$(当n为正无穷时，答案为$\frac{1}{2}$)

推出公式后，代码就非常好写了：

```cpp
#include <cstdio>
#include <cstring>
#include <cmath>
#include <iostream>
#include <algorithm>
#define M 5000005
#define mod 998244353ll
using namespace std;
long long n;
long long inv(long long x){
	if (x==1) return 1;
	return (mod-mod/x)*inv(mod%x)%mod;
}
int main(){
	scanf("%lld",&n);n%=mod;
	if (!n) printf("%lld",inv(2));
	else printf("%lld",inv(2)*(1-3*inv(n)%mod*inv(n+2)%mod+mod)%mod);
	return 0;
}

```


---

## 作者：junyu33 (赞：5)

## 样例是怎么算的
由于n=2时不容易看出规律，这里取n=3，看懂后类比即可。

首先我们对n=3打表，可以发现取1时概率为1/10，取3时概率为3/10，取6时概率为6/10.再由手动计算出每种情况获胜的概率后，得到这样一张图。

![](https://s1.ax1x.com/2020/06/09/t5JKrd.png)

可以得出概率为2/5.

对于每种情况的概率可以$O(1)$算出（过程自己想想），时间复杂度为$O(n^2)$.

## 如何优化
我们直接考虑$a$，$b$在$[1,a_n]$中的每个数出现的概率，由于取$x$时概率的分子恰为$x$，我们可以理解为在$1-x$中均出现一次。整理后如下图：
![](https://s1.ax1x.com/2020/06/09/t5Us0J.png)
我们可以发现我们只需用总的次数减掉黄色的次数，再除以2即可。

此时我们可以$O(n)$解决这个问题。

## 推公式

黄色出现的次数是:
$$1^2*n+2^2*(n-1)+...+n^2*1$$
$$=1^2+(1^2+2^2)+(1^2+2^2+3^2)+...$$
$$=\sum_{i=1}^n\sum_{j=1}^ij^2$$
整个区域的次数是：
$$(1*n+2*(n-1)+...+n*1)^2$$
$$=(1+(1+2)+(1+2+3)+...)^2$$
$$=(\sum_{i=1}^n\sum_{j=1}^ij)^2$$

得黄色区域出现的概率是：
$$\frac{\sum_{i=1}^n\sum_{j=1}^ij^2}{(\sum_{i=1}^n\sum_{j=1}^ij)^2}$$

然后发现自己根本不会算！

于是我无耻地打开了mma：

![](https://s1.ax1x.com/2020/06/09/t50NbF.png)

于是$O(1)$解就这样~~推出来了~~。

另外，当n趋近于正无穷时，平局的概率是0，所以获胜的概率为1/2.

```cpp
/*
 * @Author: junyu33 
 * @Date: 2020-06-09 16:05:43 
 * @Last Modified by:   junyu33 
 * @Last Modified time: 2020-06-09 16:05:43 
 */
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int mod=998244353;
int n,ans;
int qpow(int m,int n){int ans=1;for(;n;n>>=1){if(n&1)ans=ans*m%mod;m=m*m%mod;}return ans;}
int inv(int x){return qpow(x,mod-2);}
signed main(){
   cin>>n;n%=mod;
   if(n==0){cout<<inv(2);return 0;}
   int a=(n*n%mod+2*n-3)%mod,b=2*n%mod*(n+2)%mod;
   cout<<a*inv(b)%mod;
}
```


---

## 作者：Aegleseeker_ (赞：4)

这篇题解主要是针对一些困惑的，题目的思路还请去看其他大佬的题解。
## Part 0x01

为什么 $P(x>y)=P(x<y)=\dfrac{1-P(x=y)}{2}$？

这就涉及到一个概率论的性质：**对称性**。

比如对于一个二元函数 $f(x,y)=x+y$ 或者 $f(x,y)=\sqrt{x^2+y^2}$，此时 $x$ 和 $y$ **是互相不关联的**，也就是说 $f(x,y)=f(y,x)$。在函数是这样，在概率上也可以这么理解。

因为 $v1,v2$ 的**选取规则一样**，**且互不影响**，所以它们之间没有关联，先选谁都一样，所以此时它就具有了**对称性**。

如果还不理解的话，我把题面改一下。

甲和乙掷硬币，甲掷 $n$ 次，乙也掷 $n$ 次。假设它们掷的硬币大小、质量完全相同，且每次掷硬币正面和反面的概率永远是 $\dfrac{1}{2}$，求掷 $n$ 次后甲掷的正面硬币比乙掷的正面硬币多的概率。

现在是不是就好理解了，甲和乙是两个独立的人，它们掷的次数是一样的，每次的概率是一样的，硬币也是相同的，它们具有对称性。

所以此时 $P=P(x>y)=P(x<y)$，而 $P(x=y)=1-2P$，那么再由全概率公式继续计算即可，这道题也是同样的道理。 

## Part 0x02

为什么 $x$ 取区间 $\left[ 1,v1 \right]$ 的概率算进了取区间 $\left[ \dfrac{i(i-1)}{2}+1,\dfrac{i(i+1)}{2} \right]$ 中呢？

可能有人有这个疑问，我当时也想了挺久的。$x$ 从 $\left[ 1,v1 \right]$ 里取，但是这个概率算进了这个区间的概率，那剩下的 $\left[ 1,\dfrac{i(i-1)}{2} \right]$ 区间如果 $x$ 取到了不就不满足要求了吗？

实际上有这个疑惑的人忽略了一件事，这个概率是取到这个区间内的**任意一个数**的概率。

举个例子，老师让学生 $A$ 从 $1$ 到 $10$ 抽一个数，如果抽中了区间 $\left[ 5,10 \right]$，就可以获得奖励，问取到这个区间内的**任意一个数**的概率是多少，还是 $\dfrac{1}{10}$ 啊。但问**抽到这个区间**的概率是多少，$\dfrac{1}{10}\times (10-5+1)=\dfrac{3}{5}$.

回到题目，虽然它是一个区间，但此时我们计算的是区间内**任意一个数**的概率，它的概率还是由之前的 $\dfrac{6 }{n(n+1)(n+2)}$ 而来，而不用担心能不能取到这个区间内，因为**就算你取到了这个区间内但没取到想取的目标值，还是不算**。

如果考虑区间的话，那就是推导的下一步要做的事情了。

就是用区间的 $i$ 个数，乘上取到这个区间内的**任意一个数**的概率。

或者，你也可以换一下角度理解。

之前的 $\dfrac{6 }{n(n+1)(n+2)}$ 是由题目给的概率乘一个 $\dfrac{2}{i(i+1)}$ 而来，也就是可以取 $\left[ 1,v1 \right]$。现在固定了区间只能取 $\left[ \dfrac{i(i-1)}{2}+1,\dfrac{i(i+1)}{2} \right]$ 中的 $i$ 个数，那么从乘 $\dfrac{2}{i(i+1)}$ 就得再乘一个 $i$.

## Part 0x03

为什么能从 $\sum\limits_{i=1}^ni \left(\dfrac{6 (n-i+1)}{n(n+1)(n+2)}\right)^2$ 推到 $\dfrac{3}{n(n+2)}$？

这个需要慢慢推，在这里我不过多叙述了（占篇幅）我单写了一篇[推导过程](https://www.luogu.com.cn/blog/736658/guan-yu-p5389-tui-shi-zi-di-guo-cheng)，有需求的可以去看呀。

## Part 0x04

为什么当 $n$ 趋于正无穷时式子的值是 $\dfrac{1}{2}$？

这个问题我还专门问了我们数学老师。

得到的答复是这样的：

$n$ 趋于无穷大的时候，$\dfrac{3}{n(n+2)}$ 趋于 $0$，不就是 $\dfrac{1}{2}$了；因为 $n$ 趋于无穷大，分子一直都是 $3$，分母趋于无穷大，不就趋于 $0$ 了嘛。

（真的是数学老师的回答，一字不差

我大概懂了老师的意思，后来我又上几何画板画了一下这玩意儿的函数图像和导数图像。

![](https://cdn.luogu.com.cn/upload/image_hosting/c5ap4tst.png)

紫色是原函数的图像，绿色是导数的图像，可以看到第一象限中原函数趋于 $\dfrac{1}{2}$，很平稳啊！导数趋紧于 $0$，很平稳啊！这个实证确立了我的看法。

---

## 作者：HPXXZYY (赞：3)

$\color{blue}{\texttt{[Problem]}}$

- 你有一个长度为 $n$ 的数列 $a_{1 \cdots n}$，满足 $a_{i} = \sum\limits_{j=1}^{i} j$。
- 你现在需要从数列 $a$ 中选出两个数 $v_1,v_2$，**再任意选择**两个**正整数** $x,y$，使得 $x \in [1,v_1],y \in [1,v_2]$。
- 其中，$v_1,v_2$ 的值的选取**互不影响**（即可以相等可以不等），选到 $a_{i}$ 的概率是：

  $$\frac{3 \times i \times (i+1)}{n \times (n+1) \times (n+2)}$$

- 而 $x,y$ 也是**互相独立**的，其选到任意一个符合条件的值的概率是**相等**的。
- 问 $x>y$ 的概率是多少，即求 $P(x>y)$ 的值。
- $0 \leq n \leq 1 \times 10^{18}$，其中用 $n=0$ 表示 $n=\infty$.


$\color{blue}{\texttt{[Solution]}}$

由于 $x,y$ 的产生方式是相同的，故取值具有**对称性**，所以 $x>y$ 的概率等于 $x<y$ 的概率，即：

$$P(x>y)=P(x<y)$$

所以，**答案就是 $1$ 减去 $x=y$ 的概率再除以 $2$**。

依题意得，

$$a_{i} = \frac{i \times (i+1)}{2}$$

故而，$x$ 选中 $[1,v_1]$ 某一个数的概率就是：

$$\frac{1}{\left ( \frac{i\times (i+1)}{2}\right )}$$

由条件概率公式可知，在 $v_1$ 选中 $a_{i}$ 条件下 $x$ 选中其中任意一个数的概率为：

$$\frac{3 \times i \times (i+1)}{n \times (n+1) \times (n+2)} \times \frac{1}{\left ( \frac{i\times (i+1)}{2}\right )}=\frac{6}{n(n+1)(n+2)}$$

易知，使得 $x$ 有概率取到区间 $\left [ \frac{i(i-1)+1}{2}+1,\frac{i(i+1)}{2}\right ]$ 这 $i$ 个数的 $v_1$ 有 $(n+1-i)$ 个，因此选到这个区间内的**任意一个数**的概率为：

$$\frac{6}{n(n+1)(n+2)} \times (n+1-i)=\frac{6(n+1-i)}{n(n+1)(n+2)}$$

故而选到**这个区间**的概率为：

$$i \times \frac{6(n+1-i)}{n(n+1)(n+2)}$$

$y$ 的概率同理可知。

所以：

$$
\begin{aligned}
P(x=y)&=\sum\limits_{i=1}^{n} i \times \left [ \frac{6(n+1-i)}{n(n+1)(n+2)} \right ]^2\\
&=\frac{3}{n(n+2)}
\end{aligned}
$$

所以：

$$
\begin{aligned}
P(x<y)&=\frac{1-P(x=y)}{2}\\
&=\frac{1-\frac{3}{n(n+2)}}{2}
\end{aligned}
$$

因为模数是素数，随便拿一个快速幂就可以维护这个式子了。

同时，我们可以发现，当 $n \rightarrow \infty$ 时，概率趋近于 $\dfrac{1}{2}$。

$\color{blue}{\texttt{[code]}}$

```cpp
long long n;int ans;
int main(){
	scanf("%lld",&n);n%=mod;
	if (n==0) ans=ksm(2,mod-2);
	else ans=1ll*(mod+1-3ll*ksm(1ll*n*(n+2)%mod,mod-2)%mod)%mod*ksm(2,mod-2)%mod;
	printf("%d",ans);
	return 0;
}
```

---

## 作者：Y_QWQ_Y (赞：0)

#### 题意解析
在 $n$ 个等差数列中选第 $i$ 个，再在 $[1,\frac{i\times(i+1)}{2}]$ 中选一个正整数 $a$，再选第 $j$ 个数列，在 $[1,\frac{j\times(j+1)}{2}]$ 中选出一个正整数 $b$，求 $a>b$ 的概率对 998244353 取模的结果。

#### 解题思路
我们算出选到第 $i$ 个等差数列选到 $a$ 的概率：$\frac{3i\times(i+1)}{n(n+1)(n+2)}\times\frac{1}{\frac{i\times(i+1)}{2}}=\frac{3i\times(i+1)}{n(n+1)(n+2)}\times\frac{2}{i\times(i+1)}=\frac{6}{n(n+1)(n+2)}$，$b$ 同理，所以两数生成的概率相等，$P(a\ge b)=P(a\le b)$，所以 $P(a>b)=P(a<b)$。

所以现在我们只需要求出 $P(a=b)$，就可以算出 $P(a>b)$。

我们会发现，$(\frac{i(i-1)}2,\frac{i(i+1)}2]$ 中的正整数都被 $n-i+1$ 个等差数列包含，所以选出 $a$ 的概率为 $\frac{6(n-i+1)}{n(n+1)(n+2)}$，$b$ 的概率也一样，因为这个区间内有 $i$ 个正整数，所以 $P(a=b)=\sum_{i=1}^n\frac{36i(n-i+1)^2}{n^2(n+1)^2(n+2)^2}$。

接下来是痛苦的推式子：

$$\frac{36}{n^2(n+1)^2(n+2)^2}\times\sum_{i=1}^n[{i\times(n^2-2i\times n+i^2+2n-2i+1)}]$$

$$\frac{36}{n^2(n+1)^2(n+2)^2}\times\sum_{i=1}^n({i^3-(2n+2)\times i^2+(n+1)^2\times i})$$

$$\frac{36(\frac{n^2(n+1)^2}{4}-(2n+2)\times\frac{n(n+1)(2n+1)}{6}+(n+1)^2\times\frac{n(n+1)}2)}{n^2(n+1)^2(n+2)^2}$$

先别急着把 36 乘进去，先约分（约 $n(n+1)^2$）：

$$\frac{36(\frac{n}4-\frac{2n+1}3+\frac{n+1}2)}{n(n+2)^2}$$

但是还没完，把 36 乘进去：

$$\frac{9n-24n-12+18n+18}{n(n+2)^2}$$

合并，约分（约 $(n+2)$）：

$$\frac{3n+6}{n(n+2)^2}=\frac3{n(n+2)}$$

所以 $P(a=b)=\frac3{n(n+2)}$。$P(a>b)=P(a<b)=\frac{1-P(a=b)}2=\frac{1-\frac3{n(n+2)}}2$。然后处理一下逆元算一下就好了。

---


# 【XR-2】伤痕

## 题目背景

> 长日尽处，我来到你的面前，你将看见我的伤痕，你会知晓我曾受伤，也曾痊愈。——泰戈尔《深爱你这城》

## 题目描述

X 国经历了一场前所未有的大地震，人们伤痕累累，整个国家破碎不堪。

为了帮助人们痊愈，也为了让 X 国能够生存下去，X 国国王决定重建 X 国。

国王决定先建造 $n$ 座城市，由于国王喜欢奇数，所以 $n$ 为奇数。

城市建造完后，需要给每两座城市之间都修建一条道路，即一共需要修建 $\frac{n(n-1)}{2}$ 条道路。

不过，修建双向道路的成本太高了，建造完 $n$ 座城市后剩下的经费最多只够修建 $n$ 条双向道路，而其余的道路只能修建成单向的。好在方向并不会影响修建单向道路所需的费用，因此所有单向道路的方向可以任意决定。

另外，等到重建完成后，国王决定将 $4$ 座城市钦定为 X 国的核心城市。为促进 X 国的发展，这 $4$ 座核心城市中的任意两座城市，必须能够在不经过非核心城市的情况下相互到达。

国王希望，你能够给他一种道路修建方案，使重建完成后选择 $4$ 座核心城市的方案数最大化。

## 说明/提示

【样例 $1$ 说明】

由于一共只有 $3$ 个点，所以选择 $4$ 座核心城市的方案数一定为 $0$，那么只需要保证修建方案满足条件即可。

【样例 $2$ 说明】

![](https://cdn.luogu.com.cn/upload/pic/60711.png)

显然，在 $5$ 个点中任意选 $4$ 个点，都满足核心城市的条件，因此方案数最大为 $5$。

【数据规模与约定】

本题一共有 $50$ 个测试点，每个测试点 $2$ 分。对于第 $i$ 个测试点，$n = 2i - 1$。

对于每个测试点，有五种可能的结果：

1. 输出格式错误，包括：没有输出最大方案数、没有输出邻接矩阵、输出了多余的信息等。你将无法得到该测试点的任何分数，同时我们无法确定 Special Judge 的返回结果。
2. 没有正确计算最大方案数，即使构造的道路修建方案是正确的。你将得到该测试点 $0\%$ 的分数（即 $0$ 分），Special Judge 将会返回 WA 的结果，同时输出 “The answer is wrong.”
3. 正确计算了最大方案数，但是构造的道路修建方案不满足条件，包括：邻接矩阵中有不为 $0$ 或 $1$ 的数、有自环、有两座城市中没有道路、有多于 $n$ 条双向道路等。你将得到该测试点 $50\%$ 的分数（即 $1$ 分），Special Judge 将会返回 WA 的结果，同时输出 “The answer is correct, but your plan breaks the rules.”
4. 正确计算了最大方案数，构造的道路修建方案满足条件但没有将选择 $4$ 座核心城市的方案数最大化。你将得到该测试点 $50\%$ 的分数（即 $1$ 分），Special Judge 将会返回 WA 的结果，同时输出 “The answer is correct, but your plan is wrong.”
5. 正确计算了最大方案数，同时正确构造了道路修建方案。你将得到该测试点 $100\%$ 的分数（即 $2$ 分），Special Judge 将会返回 AC 的结果，同时输出 “The answer is correct.”

## 样例 #1

### 输入

```
3
```

### 输出

```
0
0 1 1
0 0 1
0 1 0
```

## 样例 #2

### 输入

```
5
```

### 输出

```
5
0 1 0 1 1
0 0 1 1 0
1 0 0 0 1
1 0 1 0 1
1 1 0 0 0
```

# 题解

## 作者：lsoer (赞：74)

[xht的神仙题解](https://www.luogu.com.cn/blog/xht37/solution-p5441)

### 一，初探问题

首先，我们知道一共需要建造$\dfrac{n(n-1)}{2}$条道路，而其中最多有$n$条双向道。

容易看出，多建双向道对选择方案数的增多是有益的，因此我们将造满$n$条双向道，剩下的只能造单向道了。

这样的话，有多少单向道呢？

$$\dfrac{n(n-1)}{2}-n=\dfrac{n(n-3)}{2}$$

另一方面，**我们把任意四个城市放在一起，称为一组**。

一个组可能有两种情况：所有城市可以自由相互到达（意味着你可以从任何一个城市出发去向组中任何另一个城市，并且还能回来）或是不然。

显然，国王选出的四个核心城市组成的一组应是上述中的前者（我们就把它称为强连通组吧，反之就是非强连通组）。

对于所有的$n$座城市我们从中任意选出四个来组成一组，有$C^4_n$种不同的选法。

对于其中所有的强连通组，都是可行的核心城市选择方案。**因此我们应该尽量减少这$C^4_n$个组中非强连通组的个数。**

### 二，非强连通组的分类

看以下三张图（球带表城市，黑线为单向道，绿线为双向道，灰线为不确定的道路）：

![图一](https://cdn.luogu.com.cn/upload/image_hosting/6wo28kya.png)

![图二](https://cdn.luogu.com.cn/upload/image_hosting/b37ts1ma.png)

![图三](https://cdn.luogu.com.cn/upload/image_hosting/a41h5gfe.png)

从蓝色球带表的城市进入红色球带表的城市后，便无法回到蓝色球，因此它们都是非强连通组的可能情况。

事实上，**不存在一个非强连通组不属于上述三种情况中的一种**，因为非强连通组无非就是存在进去却回不来的城市或是根本就进不去的城市，而上述图已经表示了这样城市的全部可能产生原因。

由此我们将非强连通组进行一下分组。

#### 第一类非强连通组：

满足图一情况（一个城市向其它三个城市发单向道）的组为第一类非强连通组。

#### 第二类非强连通组

满足图二情况（其它三个城市向一个城市发单向道）但不满足图一情况的组为为第二类非强连通组。

注意有的组既满足图一又满足图二：

![](https://cdn.luogu.com.cn/upload/image_hosting/ronp0b5w.png)

它应为第一类。

#### 第三类非强连通组

满足图三情况（两个城市连双向道，另外两个也连双向道，前两个分别向后两个连单向道）的组为第三类非强连通组。

容易看出**这三类组互相没有重叠**，这意味这我们成功将非强连通组进行了分类。

接下来我们要尝试尽量减少这三类非强连通组的数量。

### 三，减少第一类组：用数学来分析

对与一个城市 $i$ ，设它有 $S_i$ 条向外的单向道。

如果 $S_i \geqslant 3$ ,那么该城市就可以与它发出单向道的城市中的三个组成一个第一类组，不同的第一类组的数量为 $C^3_{S_i}$。

从而所有的第一类组的数量为 $\sum_{i=1}^n C^3_{S_i}$

另一方面我们已经知道所有的单向道总数为 $\dfrac{n(n-3)}{2}$，即

$$\sum_{i=1}^n S_i =\dfrac{n(n-3)}{2}$$

现在记 $f(x)=C^3_x$

那么我们的问题成为了：

已知 $S_1+S_2+...+S_n=\dfrac{n(n-3)}{2}$ ，求 $f(S_1)+f(S_2)+...+f(S_n)$的最小值。

为了解决它，我们先考虑 $f(x)$ 的特点。有：

$$f(x)=C^3_x=\dfrac{x(x-1)(x-2)}{6}$$

$$f'(x)=\dfrac{3x^2-6x+2}{6}$$

$$f''(x)=x-1$$

$f(x)$ 的图像：

![](https://cdn.luogu.com.cn/upload/image_hosting/mx17u243.png)

当 $x\geqslant2$ 时其显然为凸函数（图像下凸）。

对于凸函数 $f(x)$ 有这样的性质：若 $p+q$ 为常数，则 $p$ 与 $q$ 间的差值越小， $f(p)+f(q)$ 越小。

可借下图理解：

![](https://cdn.luogu.com.cn/upload/image_hosting/l4e0jg4o.png)

（图中有$p_1+q_1=p_2+q_2$,由于$p_2$和$q_2$间的差距较小，$f(p_2)+f(q_2)<f(p_1)+f(q_1)$,图中用二者的一半来比较大小）

由此，我们可以知道若想让$f(S_1)+f(S_2)+...+f(S_n)$最小，只需使 $S_1$ , $S_2$ , ... , $S_n$ 间差距最小。

那我们就让它们都相等，即 $S_1=S_2=...=S_n=\dfrac{\sum_{i=1}^n S_i}{n}=\dfrac{n-3}{2}$

这样第一类组就会最少。数量为:

$$n\times C_{\frac{n-3}{2}}^3=\dfrac{n(n-3)(n-5)(n-7)}{48}$$

接下来考虑第二类组和第三类组。

### 四，减少第二和第三类组：构造

事实上，一个特别的构造可在完成**三**中要求的同时将第二类和第三类组降到最少。

问：那么它们两个最少是有多少呢？

答：最少可以没有。

没错，下面这个构造可以保证不出现第二类和第三类组。

下面是这个构造的两个实例：

![](https://cdn.luogu.com.cn/upload/image_hosting/vdv8aid1.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/l99g8vhi.png)

看上去很有意思，你会发现这两个图形都是中心对称的，保证了 $S_1=S_2=...=S_n$ ，同时其顺时针的单向道建造方案使第二类组和第三类组不会出现。

到底是如何构造的呢？

简单的说，就是**将 $n$ 个城市放在正 $n$ 边形的顶点上，所有顶点相互连线，将所有最长对角线设为双向道（当 $n$ 为奇数时，正 $n$ 边形有 $n$ 条最长对角线），其它线按顺时针方向建为单向道。**

考虑到一个顶点要向外连 $(n-1)$ 条线，而最长对角线为最中间两条，即第 $\dfrac{n-1}{2}$ 条和第 $\dfrac{n+1}{2}$ 条，第 $1$ 条到第 $\dfrac{n-3}{2}$ 条它要向外连单向道，第 $\dfrac{n+3}{2}$ 条到第 $(n-1)$ 条是其它点向它连的单向道。

构造方法也可说为：**一个城市向接下来的 $\dfrac{n-3}{2}$ 个点连单向道，向接下来的第 $\dfrac{n-1}{2}$ 和第 $\dfrac{n+1}{2}$ 个点连单向道。**

接下来证明一下这个构造方法的一些性质：

#### 1，它满足每个城市向外的单向道数量相等，即 $S_1=S_2=...=S_n=\dfrac{n-3}{2}$

由构造方法可知每个城市会向接下来的 $\dfrac{n-3}{2}$ 个城市连单向道，此说法显然成立。

#### 2，第二类组不会出现。

我们知道，由于一个顶点向外连线中第 $\dfrac{n+3}{2}$ 条到第 $(n-1)$ 条是其它点向它连的单向道（共有 $\dfrac{n-3}{2}$ 条），当 $n\geqslant 3$ 时就会出现**二**中图二的情况：三个城市向一个城市连单向道，但是这不是第二类组，因为图一的情况也会出现，如图:

![](https://cdn.luogu.com.cn/upload/image_hosting/slfs3gix.png)

一个篮球和两个绿球向红球连单向边，但顺时针方向最前面的篮球也会向两个绿球连单向边，根据“同时满足图一和图二的组为第一类组”可知此为第一类组。

#### 3，第三类组不会出现

第三类组中会出现有两个连着双向道的的城市同时向一个城市连单向道的情况。

但是考虑到一个顶点向外连边中开始的几条才为向外单向道，中间的为双向道，因此 它连向外单向道的顶点 会在顺时针方向上 它连双向道的顶点 的前面，这意味着 双向道的另一边的顶点 无法向 它连单向道的顶点 连单向道，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/r540jvzx.png)

最后，由于不会出现第二类和第三类组，我们只需将组的总数减去第一类组的数量就可以得到最终答案：

$$C^4_n-n\times C_{\frac{n-3}{2}}^3=\dfrac{n(n-1)(n-2)(n-3)}{24}-\dfrac{n(n-3)(n-5)(n-7)}{48}=\dfrac{n(n-3)(n^2+6n-31)}{48}$$

### 五，代码

```
#include<iostream>
using namespace std;
int n,c[100][100];
int main()
{
	cin>>n;
	if (n==1)
	{
		cout<<0<<endl<<0;
		return 0;
	}//特判n=1时的情况 
	cout<<n*(n-3)*(n*n+6*n-31)/48<<endl;
	for (int i=1;i<=n;++i)
	for (int j=i+1;j<=i+(n+1)/2;++j)
	c[i][(j-1)%n+1]=1;
	//这里连边时将单向道和双向道一起处理了
	//原因是双向道可以看成两条单向道 
	for (int i=1;i<=n;++i)
	{
		for (int j=1;j<=n;++j)
		cout<<c[i][j]<<" ";
		cout<<endl;
	}
	return 0;
}
```

---

## 作者：xht (赞：41)

#### 题目大意

> $n$ 个点，保证 $n$ 为奇数，构造任意一组最多 $n$ 条无向边的建边方案，使选择导出子图为强连通的 $4$ 个点的方案数最大化，并求出最大方案数。

#### 前置知识

- ~~骗分~~构造

#### 题解

一组不强连通的四个点只有 $3$ 种可能：

1. 从一个点向另外三个点各连一条有向边，记这样的四个点有 $X$ 组。
2. 在不满足第 $1$ 种可能的前提下，从三个点向另外一个点各连一条有向边。
3. A 与 B、C 与 D 之前都是无向边，但从 A 向 CD 各连一条有向边，从 B 向 CD 各连一条有向边。

记点 $i$ 向其它点连的有向边有 $S_i$ 条。

因为 $n$ 为奇数，有：

$$\sum_{i = 1}^{n} S_i = \frac{n \times (n - 1)}{2} - n = n \times \frac{n - 3}{2}$$

又 $C_{x}^{3} = \frac{x \times (x - 1) \times (x - 2)}{6}$ 在 $x \ge 3$ 时为凸函数，有：

$$X = \sum_{i = 1}^{n} C_{S_i}^{3} \ge n \times C_{\frac{n - 3}{2}}^{3}$$

因此，最少有 $n \times C_{\frac{n - 3}{2}}^{3}$ 组第一种可能的不强连通的四个点。

接下来，我们只需要构造出只有 $n \times C_{\frac{n - 3}{2}}^{3}$ 组第一种可能，没有第二、三种可能的建边方案即可。

构造方案显然不唯一，接下来给出一种构造方案：

> 将 $n$ 个点放在一个圆内接正 $n$ 边形的顶点上，所有最长的对角线为无向边，每个点都向顺时针接下来的 $\frac{n - 3}{2}$ 个点连一条有向边。

显然，这种构造方案满足条件。

综上所述，最终的答案为：

$$C_{n}^{4} - n \times C_{\frac{n - 3}{2}}^{3} = \frac{n(n-3)(n^2+6n-31)}{48}$$

注意 $n = 1$ 时需要特判。

#### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n;
    cin >> n;
    if (n == 1) {
        cout << 0 << endl << 0 << endl;
        return 0;
    }
    cout << n * (n - 3) * (n * n + 6 * n - 31) / 48 << endl;
    int m = (n + 1) >> 1;
    for (int i = 1; i <= n; i++) {
        int a[n+1];
        memset(a, 0, sizeof(a));
        for (int j = 1; j <= m; j++)
            a[(i+j-1)%n+1] = 1;
        for (int j = 1; j < n; j++) cout << a[j] << " ";
        cout << a[n] << endl;
    }
    return 0;
}
```

#### Special Judge

```cpp
#include "testlib.h"

#define AC return quitf(_ok, "The answer is correct."), 0
#define WA return quitf(_wa, "The answer is wrong."), 0
#define WArules return quitp(0.5, "The answer is correct, but your plan breaks the rules."), 0
#define WAplan return quitp(0.5, "The answer is correct, but your plan is wrong."), 0

int main(int argc, char* argv[]) {
    registerTestlibCmd(argc, argv);
    
    int n = inf.readInt(), ans = ouf.readInt(), a[n+1][n+1];
	
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
			a[i][j] = ouf.readInt();
			
	if ((n == 1 && ans) || (n != 1 && ans != n * (n - 3) * (n * n + 6 * n - 31) / 48)) WA;
	
	int cnt = 0;
		
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++) {
			if (a[i][j] && a[i][j] != 1) WArules; 
			if (i == j) {
				if (a[i][j]) WArules;
			} else {
				if (!a[i][j] && !a[j][i]) WArules;
				if (i < j && a[i][j] && a[j][i]) ++cnt;
			}
		}
	
	if (cnt > n) WArules;
	
	int k = 0, p[5];
	
	for (p[1] = 1; p[1] <= n; p[1]++)
		for (p[2] = p[1] + 1; p[2] <= n; p[2]++)
			for (p[3] = p[2] + 1; p[3] <= n; p[3]++)
				for (p[4] = p[3] + 1; p[4] <= n; p[4]++) {
					bool flag = 0;
					int o[5];
					for (int i = 1; i <= 4; i++) o[i] = p[i];
					do if (a[o[1]][o[2]] && a[o[2]][o[3]] && a[o[3]][o[4]] && a[o[4]][o[1]]) flag = 1;
					while (!flag && std::next_permutation(o + 1, o + 5));
					k += flag;
				}
    				
    if (k != ans) WAplan;
    AC;
}
```



---

## 作者：Marser (赞：21)

### 题意
构造一个 $n$ 阶混合图，满足其基图为完全图，且恰有 $n$ 条无向边。从图中选择四个点，要求最大化选出的四个点的导出子图强连通的方案数。  
$1 \le n\le 99,n=2k+1,k\in \mathbb{N}_+$

### 题解
这篇题解主要是解释 xht 神仙的做法，看不懂神仙的题解可以来这里。

同样，我们可以知道，一组不强连通的 $4$ 个点必然属于以下三种情况之一：  
1. 从一个点向其他三个点各连一条有向边
2. 不满足 1 的情况下，三个点向另一个点各连一条有向边
3. 存在两条端点各不相同的无向边，且第一条无向边的两个端点各自向第二条无向边的两个端点连两条有向边

容易看出上述情况互异，不存在同时满足两种情况的方案。  
可以用图论知识证明，所有不满足上述三种情况的四阶混合图必然强连通，所有非强连通图必然属于上述情况之一。由于只有 $729$ 种带标号的四阶混合图，我们可以暴力枚举来 `check`，这里不再赘述。

我们记一个点连出的**有向边**数量为 $S_i$，一共有 $\frac{n(n-1)}2-n=\frac{n(n-3)}2$ 条有向边，也就是 $\sum_{i=1}^n S_i=\frac{n(n-3)}2$。

令 $X$ 为满足第一种情况的方案数，容易知道 $X=\sum_{i=1}^n C_{S_i}^3$，也就是枚举连出有向边的点，从它的出边中选择三条作为方案。由于一种满足第一种情况的方案只会有一个点连出三条出边，可以知道这样计数是不重不漏的。  
令 $f(x)=C_{x}^3=\frac{x(x-1)(x-2)}6~(x\ge 3)$，可以得到 $f''(x)=x-1$，也就是 $f(x)$ 在 $[3,+\infty]$ 上是凸函数。  
根据这一结论，我们可以得到一个引理：  
> $\forall x,y\in [4,+\infty]\cap\mathbb{N}_+,~x\le y$，$C_{x-1}^3+C_{y+1}^3\ge C_x^3+C_y^3$ 恒成立。  

容易把这一结论拓展到 $x,y$ 取 $0,1,2,3$ 的情况。  
因此，为了最小化 $X$，我们要让所有的 $S_i$ 尽可能接近。由于 $n$ 是奇数，所以可以将每个 $S_i$ 设成 $\frac{n-3}2$，就能最小化 $X$ 了。

接下来证明最小化 $X$ 的情况下，可以构造方案使得剩下两种情况均不存在。  
按照 xht 的构造方法，我们将 $n$ 个点放在正 $n$ 边形的顶点上。对于一个点，向顺时针接下来的 $\frac{n-3}2$ 个点连有向边，向顺时针接下来的第 $\frac{n-1}2$ 和第 $\frac{n+1}2$ 个点连无向边。这样满足一共有 $n$ 条无向边，$S_i=\frac{n-3}2$。

首先证明第二种情况不存在。  
如果有四个点 $a,b,c,d$ 满足 $a,b,c$ 向 $d$ 连有一条有向边，那么，将 $a$ 重新编号为 $1$，必然有 $a<b<c<d\le \frac{n-1}2$。因此 $a$ 必然会向 $b,c,d$ 连有向边，属于第一种情况。

接下来证明第三种情况不存在。  
我们令 $a=1,b=\frac{n+1}2$，则要找到两个点 $c,d$ 满足 $a,b$ 分别向 $c,d$ 连有向边，且 $c,d$ 之间连无向边。为了使得 $a$ 向 $c,d$ 连有向边，必须满足 $a<c<d<b$，这种情况下，$c,d$ 之间显然只能是有向边。  
$a=1,b=\frac{n+3}2$ 的情况可以用类似的方法证明不合法，所以不存在第三种情况。

最终，我们的答案就是 $n\times C_{\frac{n-3}2}^3=\dfrac{n(n-3)(n^2+6n-31)}{48}$。
### 代码
```cpp
#include<bits/stdc++.h>
#define reg register
typedef long long ll;
using namespace std;
const int MN=105;
int n,mp[MN][MN];
int main(){
	scanf("%d",&n);
	if(n==1)return 0*puts("0\n0");
	printf("%d\n",n*(n-3)*(n*n+6*n-31)/48);
	for(reg int i=1;i<=n;i++)
		for(reg int j=1;j<=(n+1)/2;j++)
			mp[i][(i+j-1)%n+1]=1;
	for(reg int i=1;i<=n;i++,puts(""))
		for(reg int j=1;j<=n;j++)
			printf("%d ",mp[i][j]);
	return 0;
}
```

---


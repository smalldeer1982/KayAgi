# 【XR-4】题

## 题目背景

**赛时提醒：$0$ 是自然数，自然数就是非负整数。**

## 题目描述

小 X 遇到了一道题：

给定自然数 $a,b$，求满足下列条件的自然数对 $(x,y)$ 的个数：

$$y^2 - x^2 = ax + b$$

他不会，只好求助于精通数学的你。

如果有无限多个自然数对满足条件，那么你只需要输出 `inf` 即可。

## 说明/提示

#### 【样例 #1 说明】

$$(x,y) = (6,9)$$

---

#### 【数据范围】**

**本题采用捆绑测试**。

- Subtask 1（3 points）：$a = b = 0$。
- Subtask 2（6 points）：$0 \le a,b \le 2$，不存在无限个数的情况。
- Subtask 3（9 points）：$0 \le a,b \le 100$，不存在无限个数的情况。
- Subtask 4（13 points）：$0 \le a,b \le 10^3$，不存在无限个数的情况。
- Subtask 5（14 points）：$0 \le a \le 10^4$，$0 \le b \le 10^7$。
- Subtask 6（14 points）：$a = 0$。
- Subtask 7（14 points）：$b = 0$。
- Subtask 8（27 points）：无特殊限制。

对于 $100\%$ 的数据，$0 \le a \le 10^8$，$0\le b \le 10^{15}$。

## 样例 #1

### 输入

```
5 15
```

### 输出

```
1
```

## 样例 #2

### 输入

```
4 4
```

### 输出

```
inf
```

## 样例 #3

### 输入

```
12 6
```

### 输出

```
0
```

## 样例 #4

### 输入

```
96 96
```

### 输出

```
7
```

## 样例 #5

### 输入

```
10000 9999997
```

### 输出

```
6
```

# 题解

## 作者：一叶知秋。 (赞：35)

首先，看看式子：

$y^2-x^2=ax+b$

移项，再等式两边同乘4，得：

$4y^2-4b=4x^2+4ax$

然后配方，得：

$4y^2+a^2-4b=(2x+a)^2$

由题意，得：$y^2+a^2-4b$必须为完全平方数

令$z^2=4y^2+a^2-4b$

移项，再因式分解，得：

$a^2-4b=(z-2y)(z+2y)$

所以找$a^2-4b$的因子即可

然后还有条件：

倘若$a^2-4b=uv(u<v)$（等于可以不考虑，因为肯定不可行）

则$u$，$v$为所求当且仅当：

1、$u$，$v$同奇偶

2、$4|(v-u)$

3、求出的$y$，$z$不能为负

4、$z$与$a$同奇偶

然后这道题就做完了。。。

代码如下：

```cpp
#include<cstdio>
#include<cstring>

#define maxn 1111111

inline long long read(){
	long long r=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9')r=(r<<1)+(r<<3)+(c^48),c=getchar();
	return r*f;
}

inline long long abs(long long x){
	return x<0?-x:x;
}

long long a,b,u,v,x,ans;

int main(){
	a=read(),b=read();
	if(!(a*a-4*b))return printf("inf"),0;
	x=a*a-4*b;
	for(long long i=(a+1)%2+1;i*i<=abs(x);i+=2){//要满足z与a同奇偶
		if(x%i)continue;
		u=i,v=abs(x/i);
		if(x<0)u=-u;//倘若为负，应该让u为负，证明不难
		if((v-u)%4)continue;//要能被4整除
		if(v-(v-u)/2<a)break;//求出来是负数了，后面肯定求出来的越来越小
		ans++;
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：VenusM1nT (赞：31)

数学题。  
好题啊（  
首先判断无限解情况，将 $x$ 移到右边，显然当 $x^2+ax+b$ 为完全平方，即 $(\frac a2)^2=b$ 时有无数解。当然，为了避免精度误差，可以将它写成 $a^2=4\times b$。  
然后来考虑怎么解此题，我们将左式因式分解，得：  
$$(y-x)(y+x)=ax+b$$  
令 $k=y-x$，原式可以化为：  
$$k\times (k+2x)=ax+b$$  
$$k^2+2xk=ax+b$$  
$$2xk-ax=b-k^2$$  
$$x(2k-a)=b-k^2$$  
$$x=\frac{b-k^2}{2k-a}$$  
然后我们就可以枚举 $k$ 了。由于 $b-k^2$ 单调减，$2k-a$ 单调增，那么有一个时刻会是 $2k-a>0$ 且 $b-k^2<0$，此时可以退出循环。答案合法的条件是 $(2k-a)|(b-k^2)$。
```cpp
#include<bits/stdc++.h>
#define MAXN 
#define reg register
#define inl inline
#define int long long
using namespace std;
int a,b,ans;
signed main()
{
	scanf("%lld %lld",&a,&b);
	if(a*a==4*b) return puts("inf"),0;
	reg int x=1,t=sqrt(b);
	if(t*t==b) ans++;
	while(1)
	{
		reg int A=x*2-a,B=b-x*x;
		if(((A>0 && B>0) || (A<0 && B<0)) && !(B%A)) ans++;
		if(A>0 && B<0) break;
		x++;
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：torque (赞：11)

**UPD(10-21)：添加了少许代码注释，请放心食用**

***

比赛的时候我的思路和题解是差不多的，这里就来解释一下

首先观察这个方程：

$${y^2-x^2=a*x+b}$$

对于这种二元二次方程我们很没办法

由题意知$a>=0,b>=0,x>=0$

即

$$y^2-x^2=a*x+b>=0$$

也即

$$y>=x$$

由于$y>=0,x>=0$

不妨记$t=y-x \in N$

则有

$$(x+t)^2-x^2=a*x+b$$

整理得

$$(2*t-a)*x=b-t^2$$

将t视作已知量，我们就得到了一个关于x的一元一次方程

当$2*t=a$时，等号左边为0，右侧若同时为0，即$b-t^2=0$时，$0=0$恒成立，

$\forall x \in N$，存在$y=x+t$满足方程

也就是说此时有inf组解

我们得到**结论1：当$\frac{a}{2}=\sqrt b$时，方程有无数组解**

如果$\frac{a}{2}\not=\sqrt b$时，解得

$$x=\frac{b-t^2}{2*t-a}$$

由于$x\in N$，$x>=0$

再将t视作主元，解得

当$\frac a 2<\sqrt b$时

$$t \in (\frac a 2,\sqrt b]$$

当$\frac a 2>\sqrt b$时

$$t\in[\sqrt b,\frac{a}{2})$$

这就是**结论2**

### 总结

我们的结论是这样的：当$\frac a 2=\sqrt b$时答案为$inf$，否则就在结论2求出的范围内枚举整数的$t$，由于$t$与$x$存在对应关系，而$y=x+t$，所以每当存在一个$t$可以使得$x$是整数，就会多出一组解

也就是说我们只需要枚举$t$，看有多少个$t$可以使得$\frac{b-t^2}{2*t-a}$是整数

### 注意

结论2求出的区间左右端点均为小数，所以在开区间或闭区间中注意数字需要向上or向下取证

时间复杂度$O(|\sqrt b-\frac a 2|)$

### 代码

```cpp
#include <cmath> 
#include <cstdio>
#include <cstdlib>
#define int long long//不开就见祖宗
#define rnt register int
using namespace std;
int a,b,q,sq,ans;
signed main(){
	scanf("%lld%lld",&a,&b);
	sq=sqrt(b),q=a/2;
	if(sq*sq==b && sq*2==a) printf("inf");
	else if(a==1 && b==0) printf("1");
//注意这句话的特判是由于int向下取整的时候a=1,b=0会出锅，我比较懒就这么写了
	else if(sq>=q){
		for(rnt i=q+1;i<=sq;i=-~i)
			if((abs(b-i*i))%(abs(2*i-a))==0) ans=-~ans;//是整数
		printf("%lld",ans);
	}
	else{
		int ed=(q*2==a)?(q-1):(q);
//a/2是不是整数不太一样，还要注意区间的开与闭
		for(rnt i=sq;i<=ed;i=-~i)
			if((abs(b-i*i))%(abs(2*i-a))==0) ans=-~ans;
		printf("%lld",ans);
	}
	return 0;
}
```

[![](https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2921431843,3149119026&fm=26&gp=0.jpg)](https://www.luogu.org/blog/oneJURUO/)

---

## 作者：Sata_moto (赞：10)

### 前言：

[$ \large{}\color {#6495ED} \mathcal{MyBlog} $](https://xjx885.coding-pages.com/)


---

#### update：（第一次食用本题解时，请略过）

①（感谢@YoOXiii的提醒）

在原题解中，当$a^{2}-4b>0$时，

判断$(2x-2y+a)$是否大于0是没有必要的的...

因为$(2x-2y+a)$实际上就等于j，而枚举j的时候已经保证j是正数了

②（感谢@Y15BeTa的提醒）

在原题解中，我认为$(2x+2y+a)$恒大于0

实际上它是可以等于0的

---

### 题目大意：

已知方程$y ^{2}-x ^{2}=ax+b$

给定整数a和b，求满足方程的自然数x,y的对数

数据范围：$a<= 10^{8} ,  b <=10^{15}$

---

### 题目分析：

显然，按照原方程直接枚举x,y是不可靠的...

因为我们枚举的上界过大...

我们可以对方程进行一些处理..

原式:

$$y ^{2}-x ^{2}=ax+b$$

把含x的项移到一边，配方得：

$$(x+\frac{1}{2}a) ^{2}+b-\frac{1}{4}a^{2}=y ^{2}$$

把x,y移到一边，a,b移到另一边，得：

$$(x+\frac{1}{2}a) ^{2}-y ^{2}=\frac{1}{4}a^{2}-b$$

左边用平方差公式，得：

$$(x+\frac{1}{2}a+y)*(x+\frac{1}{2}a-y)=\frac{1}{4}a^{2}-b$$

左右同乘4得：

$$(2x+2y+a)*(2x-2y+a)=a^{2}-4b$$

分析这个式子，式子右边是一个定值，左边是两个数的乘积

其中$(2x+2y+a)$ 恒大于等于0

所以我们可以讨论$a^{2}-4b$的大小

---
---

#### 当$a^{2}-4b<0$时，$(2x-2y+a)<0$  --- ①

左右同乘-1，有：

$$(2y+2x+a)*(2y-2x-a)=4b-a^{2}$$

设

$$i=2y+2x+a , j=2y-2x-a  (i>j>0)$$

很明显，将$4b-a^{2}$分解为两数之积可以得到一组$i,j$

又有

$$i+j=4y , i-j-2a=4x$$

故枚举$j$，算出$i$，再算出$x,y$

判断$x,y$是否是自然数即可

---

#### 当$a^{2}-4b>0$时，推断方法一样，此处略去

---

#### 当$a^{2}-4b=0$时，$2x-2y+a=0$

由$a^{2}-4b=0$可推知，$a$是个偶数（这个就不用我证了吧...0 . 0）

故有$x+\frac{1}{2}a=y$ 

显然，对于任意$x$，有一个与它对应的$y$满足条件

---

#### 题目分析到此为止，大体思路应该很清晰了....

代码复杂度为O（$\sqrt{a^{2}-4b}$）,最差为O（$a$）

---

### 代码：

（请不要在意我蒟蒻的码风）

```cpp
#include <bits/stdc++.h>
#define int long long//不开longlong见祖宗 
using namespace std;

int a, b, ans;

signed main() {
	scanf("%lld %lld", &a, &b);

	int delta = 4 * b - a * a; //思路里我用的是a^2-4b，这里用4b-a^2，是一样的

	if(delta == 0) { //delta=0时，必然无穷解
		printf("inf");
		return 0;
	}

	if(delta < 0) {
		delta *= -1; //变成正数
		int Maxn = sqrt(delta); //j的枚举上限

		for(int j = 1; j <= Maxn; j++)
			if(delta % j == 0) {
				int i = delta / j; //计算i

				int x = j + i - 2 * a, y = i - j; //计算4x,4y

				if(x % 4 != 0 || y % 4 != 0 ) // x,y必须为整数
					continue;

				x /= 4, y /= 4; //这个是真正的x,y

				if(x >= 0 && y >= x ) //判断是否满足条件
					ans++;//统计对答案的贡献
			}
	} else {
		//同上
		int Maxn = sqrt(delta);

		for(int j = 1; j <= Maxn; j++)
			if(delta % j == 0) {
				int i = delta / j;

				int x = i - j - 2 * a, y = i + j;

				if(x % 4 != 0 || y % 4 != 0 )
					continue;

				x /= 4, y /= 4;

				if(x >= 0 && y >= x )
					ans++;
			}
	}

	printf("%lld", ans);
	return 0;
}
```

---

### 结语：

如果本题解有BUG...

那么...那么...那么...（随意了）还请私信作者....

---

## END

---

## 作者：20160161simon (赞：9)

蒟蒻比赛时精度爆炸没调出来，只拿了59分，赛后把pow改成*直接ac，感谢各位dalao提示

思路如下

![](https://cdn.luogu.com.cn/upload/image_hosting/p6h9hamr.png)

看起来我们只要枚举k1就可以ac了是吧，而且sqrt（a^2-4*b）好像也挺小的，但坑点（其实只有我被坑了）就在这里

当我开开心心得打完这段程式之后。。。

```cpp
#include <bits/stdc++.h>
#define N 1000010 
using namespace std;
typedef unsigned long long ll;
typedef unsigned long long ull;
ll read(){
    char c=getchar();bool flag=0;ll x=0;
    while(c<'0'||c>'9'){if(c=='-')flag=1;c=getchar();}
    while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+c-'0';c=getchar();}
    return flag?-x:x;
}
int main(){
    ll a=read(),b=read();
    if((a/2)*(a/2)==b&&!(a%2)){
        printf("inf");
        return 0;
    }   
    ll k=pow(a,2)-4*b,ans=0;
    if(4*b<pow(a,2)){
        ll k=pow(a,2)-4*b;
        for(ll i=1;i<=sqrt(k);i++){
            if(k%i==0&&i+k/i>=2*a&&k/i>=i){
                if((i+k/i-2*a)%4==0&&(k/i-i)%4==0){
                    ll x=(i+k/i-2*a)/4,y=(k/i-i)/4;
                    if(x>=0&&y>=0) ans++;
//                  printf("%lld %lld\n",x,y);
                } 
            }
        }
    }
    else{
        ll k=4*b-pow(a,2);
        for(ll i=1;i<=sqrt(k);i++){
            if(k%i==0&&k/i>=i+2*a){
                if((i+k/i)%4==0&&(k/i-i-2*a)%4==0){
                    ll x=(k/i-i-2*a)/4,y=(k/i+i)/4;
                    if(x>=0&&y>=0) ans++;
//                  printf("%lld %lld\n",x,y);
                }
            }
        }
    }
    cout<<ans;
}
```

弹出了一个绝望的的分数——59分

![](https://cdn.luogu.com.cn/upload/image_hosting/vqndicmx.png)

Wa了6个点，看起来应该是精度爆了，但奈何我too young too simple根本调不出来，然后我发现

pow的原型为extern float pow(float x, float y)

也就是说我在进行乘方运算的时候将unsigned long long直接转成了float进行计算，并以float进行输出，这也导致了为什么我wa了6个点，于是ac代码如下

```cpp
#include <bits/stdc++.h>
#define N 1000010 
using namespace std;
typedef unsigned long long ll;
typedef unsigned long long ull;
ll read(){
    char c=getchar();bool flag=0;ll x=0;
    while(c<'0'||c>'9'){if(c=='-')flag=1;c=getchar();}
    while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+c-'0';c=getchar();}
    return flag?-x:x;
}
int main(){
    ll a=read(),b=read();
    if((a/2)*(a/2)==b&&!(a%2)){
        printf("inf");
        return 0;
    }   
    ll k=a*a-4*b,ans=0;
    if(4*b<a*a){
        ll k=a*a-4*b;
        for(ll i=1;i<=sqrt(k);i++){
            if(k%i==0&&i+k/i>=2*a&&k/i>=i){
                if((i+k/i-2*a)%4==0&&(k/i-i)%4==0){
                    ll x=(i+k/i-2*a)/4,y=(k/i-i)/4;
                    if(x>=0&&y>=0) ans++;
//                  printf("%lld %lld\n",x,y);
                } 
            }
        }
    }
    else{
        ll k=4*b-a*a;
        for(ll i=1;i<=sqrt(k);i++){
            if(k%i==0&&k/i>=i+2*a){
                if((i+k/i)%4==0&&(k/i-i-2*a)%4==0){
                    ll x=(k/i-i-2*a)/4,y=(k/i+i)/4;
                    if(x>=0&&y>=0) ans++;
//                  printf("%lld %lld\n",x,y);
                }
            }
        }
    }
    cout<<ans;
}
```

码风稍显清奇，请勿见怪

---

## 作者：Gerald_Chen (赞：6)

## 题目描述
给定自然数 $a,b$ ，求满足下列条件的自然数对 $(x,y)$ 的个数：
$$
y^2 - x^2 = ax + b
$$
## 思考
先将这个等式看做是关于 $x$ 的一个一元二次方程，移项可得
$$
x^2+ax+b-y^2=0
$$
那么根据求根公式，可以得到
$$
x=\frac{-a\pm \sqrt{a^2-4b+4y^2}}{2}
$$
由于 $x,y,a,b$ 均为自然数，且 $\sqrt{a^2-4b+4y^2}$ 同样是非负数，可得
$$
x=\frac{-a+\sqrt{a^2-4b+4y^2}}{2}
$$
首先可以判断出来，当 $a^2-4b=0$ 时，可以得到
$$
x=\frac{-a+2y}{2}
$$
此时显然有无数组解，直接输出`inf`。  
下一步我们着重分析 $a^2-4b+4y^2$ 这个式子。  
设 $a^2-4b+4y^2=k^2 (k\in \mathbb{N})$ ，移项后可得
$$
a^2-4b=k^2-4y^2
$$
即
$$
a^2-4b=(k+2y)(k-2y)
$$
设 $a^2-4b=mn(m\geq n)$，由于各项均为整数且 $y\in \mathbb{N}$ ，可以得到下面这个方程组
$$
\begin{cases}
k+2y=m\\\\
k-2y=n
\end{cases}
$$
解得
$$
y=\frac{m-n}{4}
$$
把 $y=\frac{m-n}{4}$ 及 $a^2-4b=mn$ 带回到上式，可得
$$
\begin{aligned}
x&=\frac{-a+\sqrt{mn+4(\frac{m-n}{4})^2}}{2}\\\\
&=\frac{-2a+|m+n|}{4}
\end{aligned}
$$
因此我们只要判断 $-2a+|m+n|$ 是否大于0且能被4整除就行了。  
此题完结。
## 代码
```cpp
#include <cstdio>
#include <cstdlib>
#include <algorithm>
using namespace std;
int main()
{
	long long a,b;
	scanf("%lld%lld",&a,&b);
	long long lam=a*a-4*b;
	if(lam==0)
		return printf("inf"),0;
	long long f=1;
	int cnt=0;
	if(lam<0)
		f=-1,lam=-lam;//f是用来记符号的，方便分解因数
	for(long long i=1; i*i<=lam; ++i)
		if(lam%i==0) {
			long long t=lam/i;//这里的t+i*f就是上述的|m+n|
			if(t+i*f-a*2>=0 && (t+i*f-a*2)%4==0)
				++cnt;
		}
	printf("%d",cnt);
}
```
希望能给各位带来一些帮助。谢谢观看。

---

## 作者：AquaRio (赞：6)

[更好的阅读体验](http://39.105.95.125/index.php/archives/350/)

**题目传送门：** [\[XR-4\] 题](https://www.luogu.org/problem/P5596)

**Description**

给出自然数 $a,b$ 求满足下列条件的自然数对 $(x,y)$ 的个数：

$$y^2 - x^2 = ax + b$$

**Solution**

这是一道好题，~~好在我考试的时候想了很久~~。

我们就来梳理一下这题的思路。

- Subtask 1：

这个3pts估计人人都会吧。

```cpp
if(a==b&&a==0){
	puts("inf");
	return 0;
}
```

- Subtask 2：

打表打表！6pts到手！

```cpp
if(a==1&&b==1){
	puts("1");
	return 0;
}
if(a==1&&b==2){
	puts("1");
	return 0;
}
······
```

- Subtask 6：

我们发现原式可以转化成：

$$(y+x)(y-x)=b$$

设 $p=y+x$，$q=y-x$，则有 $p \times q = b$，且 $p+q=$偶数（这一点很重要，不然会WA），暴力枚举 $b$ 的因数就可以了，时间复杂度 $O(\sqrt{b})$。

```cpp
if(a==0) {
	ans=0;
	ll temp=sqrt(b);
	for(ll i=1; i<=temp; i++)
		if(b%i==0 && (i+b/i)%2==0) ans++;
	cout<<ans;
	return 0;
}
```

无穷多解的情况怎么判断呢？

原式子可以化成：

$$x^2+ax+b=y^2$$

我们发现当左边也是一个完全平方式子时，它有无穷多解。感性理解一下，只有这一种情况。

于是我们又前进了一大步

```cpp
if(a*a==4*b&&a%2==0) {
	puts("inf");
	return 0;
}
```

~~结果是红红绿绿的一片。~~这基本上是所有能骗的分了，我在考试的时候想尽办法也只骗了这23分。

下面来讲正解：

原式子可以化成：

$$x^2+ax+b=y^2$$

看到这个 $y$ 太烦人了，由 $y>x$ 我们不妨设 $y=x+t,(t>=1)$ ，我们把右边打开：

$$x^2+ax+b=x^2+2tx+t^2$$

$$ax+b=2tx+t^2$$

$$(2t-a)x=b-t^2$$

$$x=\frac{b-t^2}{2t-a}$$

梳理一下，我们对任意一个 $t!=a/2$，都有这样的一个式子。

也就是说，我们需要枚举 $t$ ，使得右边这个式子是自然数。

$t$ 的上界是什么呢？我们发现当 $t$ 大于$\sqrt{b}$ 的时候分子就变成负的了；大于 $\frac{a}{2}$ 的时候分母就是正的了，此时的 $x$ 永远不合法，所以我们将 $t$ 的上界定为 $\max\{ \sqrt{b},\frac{a}{2} \}$

因为随着 $t$ 的增加，分子是递减的，分母是递增的，所以求出来的 $x$ 不需要去重。

开始的时候我把分子小于0的情况过滤掉了，其实这是不对的，假如分母也小于0的话，那么结果还是合法的。

另外还有一个细节：要过滤掉分母为0的情况，不然会RE。

正解出来了，我们重新研究inf的情况。刚才我们讲分母为0的情况要过滤掉，其实当分子和分母同时为0的时候，答案有inf个。原因是原式变为 $0\times x = 0$，x想取啥就取啥。

所以我们就解决辣！时间复杂度为 $O(\max\{ \sqrt{b},\frac{a}{2} \})$ ，足够通过本题。

**Code**

```cpp
/*
	Name: [XR-4] 题 
	Author: Lovely_XianShen
	Date: 20/10/19 19:18
*/

#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

ll a,b;
ll ans;

int main(){
	cin>>a>>b;
	if(a==b&&a==0){
		puts("inf");
		return 0;
	}
	if(a==1&&b==1){
		puts("1");
		return 0;
	}
	if(a==1&&b==2){
		puts("1");
		return 0;
	}
	if(a==2&&b==2){
		puts("0");
		return 0;
	}
	if(a*a==4*b){
		puts("inf");
		return 0;
	}
	if(a==0){
		ans=0;
		ll temp=sqrt(b);
		for(ll i=1;i<=temp;i++)
			if(b%i==0 && (i+b/i)%2==0) {
				ans++;
			}
		cout<<ans;
		return 0;
	}
	
	ll tp=sqrt(b);
	for(ll i=0;i<=max(a/2,tp);i++){
		ll temp1=b-i*i;
		ll temp2=2*i-a;
		if(temp1==temp2&&temp1==0){
			puts("inf");
			return 0;
		}
		if(temp2==0) continue;
		if(temp1/temp2<0) continue;
		if(temp1%temp2!=0) continue;
		ans++;
	} 
	cout<<ans;
	return 0;
}
```

---

## 作者：天泽龟 (赞：5)

这比赛难度怪怪的啊。。个人感觉`T1橙题，T2黄题（橙题也挺合适，只不过蒟蒻我被卡了很久），T3绿题，T4紫题`比较合适吧，当然我说了也不算数。。

至于把T3评绿的理由，**这题就是披着数论的皮，实质上就是个模拟的事情。** 只要拿张草稿纸认认真真地分类讨论，用不了多少时间。。


**别看着长，思路很直很直，相信一看就懂QwQ！**

---

首先我们拿到式子：$y^2-x^2=ax+b$，容易想到把变量$x$移到一边，变成$y^2=x^2+ax+b$。

套个初中学到的二次函数公式，变形为$y^2=(x+\frac{a}{2})^2+b-(\frac{a}{2})^2$。

不妨设$B=b-(\frac{a}{2})^2$，$X=x+\frac{a}{2}$，再把$X$移过去，可得到最终的结果：

$$(y^2-X^2)=(y-X)(y+X)=B$$

然后就是一点点数论基础：对B进行因数分解，枚举其在$[1,\sqrt N]$范围内的因数$P_1$，同时得到$P_2 (P_2>P_1)$，由于$y,x$都是自然数，非负的，所以一定可以得到：


$$\begin{cases}x=X-\frac{a}{2}=\frac{P_2-P_1-a}{2}\\ \\y=\frac{P_2+P_1}{2} \end{cases}$$

当且仅当$y,x\in N^*$时， 数对$(x,y)$是合法的解。

特别的，由于奇偶加减的性质，我们只需要判断$X$是否满足条件即可。

---

当然，聪明的你一定注意到了上面写的推导存在大量漏洞：

1. 没有考虑$B<0$的情况。
2. 没有考虑$a/2$非整数的情况。


对于以上漏洞，我们采用**分类讨论** 的方法：

1. 对于$B<0$，很显然只需两边同时加负号即可，既得：

$$(X^2-y^2)=(X-y)(X+y)=|B|$$

此时两根变为：

$$\begin{cases}x=X-\frac{a}{2}=\frac{P_1+P_2-a}{2}\\ \\y=\frac{P_2-P_1}{2} \end{cases}$$

此时关于$X$的判断也稍作修改。

2. 对于$a/2$非整数，情况可能少许复杂，这里假设$B>0$：

首先还是初中学过的方法，两边同乘以$4$，既得：

$$(2y)^2=(2x+a)^2+4b-a^2$$

设$B=4b-a^2$，$X=2x+a$，得到新式子：

$$((2y)^2-X^2)=(2y-X)(2y+X)=B$$

同样是分解因数得到$P_1,P_2$，解出来的答案又变了：

$$\begin{cases}x=\frac{X-a}{2}=\frac{(P_2-P_1)/2-a}{2} \\ \\y=\frac{P_2+P_1}{4} \end{cases}$$


所以此时判断$y,x\in N^*$时，修改至与上式相同即可。

这里有一个小BUG：我代码里仍是仅判断x是整数即合法，但会不会出现x满足条件但y不满足的情况？应该是可以证明的，我比较懒。

-----

综上，两种情况讨论完毕，接下来无穷解也好判断了：

当$B=0$时，$(y)^2=(x+a/2)^2$，可以注意到肯定有无限个x可以找到y与其对应。

你说`a/2`不为整数咋办？  `a/2`不为整数`B`咋可能等于0？？

于是就都没了，上我丑陋的代码：
```cpp
#include <iostream>
#include <cmath>
#include <cstring>
#include <algorithm>
#define inf 2147483647
#define ll long long
using namespace std;

ll a,b;
bool fal,sw;

int main()
{
	cin>>a>>b;
if (!a && !b) { cout<<"inf"<<endl; return 0; }
if (!a && b){
	ll sq=sqrt(b),ans=0;
	for (ll i=1;i<=sq;i++) if (b%i==0) {
		ll xx=i,yy=b/i; if ((xx+yy)%2==0) ans++;
	}
	cout<<ans<<endl; return 0;
}
else { ll ans=0;
	if (a%2==0) {  //判奇偶 
		ll a0=a/2,b0=b-a0*a0; 
		if (b0<0) sw=1,b0=-b0;
		if (!b0) {cout<<"inf"<<endl; return 0;} //判无解 
		ll sq=sqrt(b0);
		for (ll i=1;i<=sq;i++) if (b0%i==0) {
			ll xx=i,yy=b0/i;  ll X=(xx+yy),Y=(yy-xx);
			if (sw){  //判B<0 
				if ( X-a>=0 && (xx+yy)%2==0) ans++;
			}
			else {
				if ( Y-a>=0 && (yy-xx)%2==0) ans++;
			}	
		}
	} else {
		b*=4; ll b0=b-a*a; 
		if (b0<0) sw=1,b0=-b0;
		if (!b0) {cout<<"inf"<<endl; return 0;}
		ll sq=sqrt(b0);
		for (ll i=1;i<=sq;i++) if (b0%i==0) {
			ll xx=i,yy=b0/i;  ll X=(xx+yy),Y=(yy-xx);
			if (sw){
				ll t=(X/2 -a );
				if ( t>=0 && t%2==0) ans++;
			}
			else {
				ll t=(Y/2 -a );
				if ( t>=0 && t%2==0) ans++;
			}	
		}
	}
	cout<<ans<<endl;
}
	return 0;
}
```

---

## 作者：Naffygo (赞：4)

### 大致思路

首先我们看到这道题目，肯定会想着想把原始条件化一下：

$$y^2 - x^2 = ax + b$$

$$y^2 + \frac{a^2 - 4b}4= (x +\frac a2) ^ 2$$

然后考虑用一下平方差公式：

$$(y + x + \frac a2)(y - x + \frac a2) = \frac{4b - a ^ 2}4$$

$$(2y + 2x + a)(2y - 2x + a) = 4b - a ^ 2$$

之后的事情就好办了。我们先判断 $4b - a ^ 2$的正负，再枚举 $4b - a ^ 2$ 的因子（或者其相反数），看看解出来的 $x$ , $y$ 是否符合要求（是自然数）。若符合要求则 $ans++$ ，当然不要忘记 $x = 0$ 或者 $y = 0$ 的情况。

### 代码

```cpp
#include<bits/stdc++.h>
#define fr(i,a,b) for(register int i = a;i <= b;++i)
#define int long long
using namespace std;

int a,b;

inline int read(){
	int x = 0,f = 1;char c = getchar();
	while(!isdigit(c)){if(c == '-')f = -1;c = getchar();}
	while(isdigit(c)){x = x * 10 + c - '0';c = getchar();}
	return f * x;
}

inline void work(int m){
	int cnt = 0,t,f = 0;
	fr(i,1,sqrt(m))
		if(m % i == 0){
			int t1 = m / i + i,t2 = m / i - i - 2 * a;
			if(t1 < 0 || t1 % 4 || t2 % 4)continue;
			int x1 = t2 / 2,x2 = t1 / 2;
			if(x1 < 0 || x2 < 0 ||  x1 > m / i - a || x2 > m / i - a || x2 < i + a)continue;
				cnt++;
				if(x1 == 0 || x2 == 0)f = 1;
		}
	if(!f){
		int s = sqrt(b);
		if(s * s == b)cnt++;
	}
	printf("%lld\n",cnt);
}

inline void work2(int m){
	int cnt = 0,t,f = 0;
	fr(i,1,sqrt(m))
		if(m % i == 0){
			int t1 = m / i + i - 2 * a,t2 = m / i - i;
			if(t1 < 0 || t2 % 4 || t1 % 4)continue;
			int x1 = t1 / 2,x2 = t2 / 2;
			if(x1 < 0 || x2 < 0 || x1 < i - a || x1 > m / i - a || x2 > m / i - a)continue;
				cnt++;
				if(x1 == 0 || x2 == 0)f = 1;
		}
	if(!f){
		int s = sqrt(b);
		if(s * s == b)cnt++;
	}
	printf("%lld\n",cnt);
}

signed main(){
	a = read(),b = read();
	if(!a && !b){printf("inf");return 0;}
	int t = 4 * b - a * a;
	if(t > 0)work(t);
	else if(t == 0)printf("inf");
	else work2(-t);
	return 0;
}
```

### 后记

~~由于wtcl所以只会这样化式子，但肯定有更好的方式~~

~~我考试时把 || 打成了 && ，然后调了一下午。。。~~


---

## 作者：Erusel (赞：3)

看到左边有个$y^2-x^2$,自然想到平方差

但是右边还有一次项，所以先把这个柿子整理成一个关于$x$的一元二次方程

$x^2+ax+b-y^2=0$

$\Delta=a^2-4b+4y^2$

为了使方程的解为正整数，我们需要满足以下性质

1.$\Delta$为完全平方数

设$\Delta=m^2,a^2-4b=t$

$t=m^2-4y^2=(m+2y)(m-2y)$

我们只要用$O(\sqrt t)$的时间枚举$t$的所有因数即可

2.在1的基础上，满足$x$为正整数

显然有$\huge x=\frac{-a\pm\sqrt{\Delta}}{2}$

在得到$\Delta$时，我们判断一下$\sqrt \Delta$和$a$的奇偶性是否相同，以及$\sqrt \Delta$是否大于$a$即可

注意：

1.在$t$为0时，记得输出```inf```

2.算出来的$t=a^2-4b$可能为负数，在判断时注意正负性

3.由于本算法的时间复杂度较高，为$O(\sqrt{a^2-4b})$，窝在比赛的时候通过了，

赛后发现加强了数据，该复杂度最高为$1e8$次运算

我们可以采取以下优化

当我们用$O(\sqrt t)$的时间去枚举$t$的因数时，假设得到了两个因数为$i,j$

$ij=t,m-2y=i,m+2y=j$

我们可以解出$m,y$的值，容易得到在判断$m,y$是否为整数时，我们只要判断$y$的奇偶性，即$(i+j) \text mod 4==0$，而不需要重复判断$(i+j)\text mod 2==0$

另外，~~我们可以手动开启O2,O3优化~~

于是，我们就通过了此题

**Code:**

```
#pragma GCC optimize(2)
#pragma GCC optimize(3)

#include<bits/stdc++.h>

#define rd(x) x=read()
#define int long long

using namespace std;

int n,m;

inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}

inline void write(int x)
{
    if(x<0){putchar('-');x=-x;}
    if(x>=10)write(x/10);
    putchar(x%10+'0');
}


signed main()
{
	rd(n),rd(m);
	int delta=n*n-m*4,cnt=0,d=abs(delta),sqrt_delta=sqrt(d);
	if(delta==0){puts("inf");return 0;}//判断t是否为0
	for(register int i=1;i<=sqrt_delta;i++)
	{
		if(d%i)continue;int j=d/i;
		if(delta<0){if((i+j)&3||((j-i)>>1)<n||(((j-i)>>1)-n)&1)continue;}//注意t的正负性
		else if((j-i)&3||((i+j)>>1)<n||(((i+j)>>1)-n)&1)continue;cnt++;
	}
	cout<<cnt<<endl;
    return 0;
}
```


---

## 作者：TEoS (赞：3)

这题看起来不难，实际上也不难 ~~然而本人只拿了45pts~~


------------
**45pts**

本人由于数学过差，月赛时限内推不出$O(\sqrt{b})$的式子，只推出了$O(b)$的式子，于是愉快地TLE到45pts……

先讨论无数解的情况。

移项后很容易得到$y^2=x^2+ax+b$，显然，当$x^2+ax+b$可以写作一个完全平方式的形式时，有无数解。此时有$a^2=4b$，特判一下即可。

接下来推一下式子：

![](https://cdn.luogu.com.cn/upload/image_hosting/wtveowgh.png)

从$\sqrt{b}$开始枚举$y$，显然，当$a^2-4b<2a+2a+1$时无解，停止枚举。时间复杂度$O(b)$。
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#define ll long long
#define ld long double
#define rg register
using namespace std;
ll a,b,dd,now,ans;
int main()
{
	scanf("%lld%lld",&a,&b);
	dd=a*a-4*b;
	if(!dd)
	{
		puts("inf");
		return 0;
	}
	for(rg ll i=sqrt((ld)b);;i++)
	{
		if((dd<0 && -dd<i*4-1)||(dd>0 && dd<i*4+1))
			break;
		now=dd+4*i*i;
		if(now<0)
			continue;
		ld qnow=sqrt((ld)now);
		if(qnow-(ll)qnow!=0 || ((ll)qnow-a)%2==1 || (ll)qnow-a<0)
			continue;
		ans++;
	}
	printf("%lld",ans);
	return 0;
}
```


------------
**100pts**

一看数据范围，至少要推到$O(\sqrt{b})$才能AC。这样，直接枚举$x$或$y$就行不通了，因此我们还要把式子再~~乱搞~~推一下：

![](https://cdn.luogu.com.cn/upload/image_hosting/7bjlu64z.png)

由于$x,y,a,b$均为自然数，于是有$b-k^2\geq 0$&&$2k-a>0$或$b-k^2\leq0$&&$2k-a<0$，并且$k=y-x\geq0$，因此我们可以枚举$k$，枚举的范围即为$0$~$max(\sqrt{b},\frac{a}{2})$，其中$\frac{a}{2}$不取。然后计算$x$，判断是否为整数即可。

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#define ll long long
#define ld long double
using namespace std;
ll a,b,ans;
int main()
{
	scanf("%lld%lld",&a,&b);
	if(a*a==4*b)
	{
		puts("inf");
		return 0;
	}
	for(ll i=0;i*i<=b || i*2<a;i++)
	{
		ld x=(ld)(b-i*i)/(ld)(2*i-a);
		if(x-(ll)x==0 && x>=0)
			ans++;
	}
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：珅肐 (赞：3)

题解来一发。

比赛没调出来，我哭了，$295$分，只要再高六分我就能前进三页

题目让求满足$y^2-x^2=ax+b$的x,y都为自然数的个数。

式子推一下：
$$y^2-x^2=ax+b$$
$$x^2+ax+b-y^2=0$$
看做关于$x$的方程，则$x=\frac{\sqrt{\Delta}-a}{2}$,$\Delta=\sqrt{a^2-4b+y^2}$

要想有解，必须满足：

$$\Delta=z^2,z\in Z$$

且$z$必须$>=a$且与$a$同奇偶

$$a^2-4b+y^2=z^2$$
$$a^2-4b=z^2-y^2$$
$$a^2-4b=(z+2y)(z-2y)$$

我们枚举$\Delta$的约数，判断即可

这题细节非常多，要特别注意。

代码中为简化的写法，未简化前应是这样：
```cpp
ll absp=abs(p),ans=0,fl=a&1,sp=sqrt(absp);
for(int i=1;i<=sp;++i)if(absp%i==0){
	ll zd2y=i,zp2y=p/i;//zd2y=z-2y,zp2y=z+2y,因为y>=0,我们要保证z-2y<=zp2y
	if(p<0)swap(zd2y,zp2y);//如果p<0,他们的相对大小就改变了，交换保证z-2y<=zp2y
	ll _4y=zp2y-zd2y,_2z=zp2y+zd2y;
	if(_2z%2==0 && _4y%4==0)/*z,y为整数*/ans+=(((_2z/2)&1)==fl && _2z/2>=a);//z必须>=a且与a同奇偶

	zd2y=-i,zp2y=-p/i;//-i的因数再来一遍
	if(p>0)swap(zd2y,zp2y);
	_4y=zp2y-zd2y,_2z=zp2y+zd2y;
	if(_4y && _2z&& _2z%2==0 && _4y%4==0) ans+=(((_2z/2)&1)==fl && _2z/2>=a);//注意！要去掉y=0或z=0的情况，因为上面已经算过一次了！
}
```
我们可以发现$-i$的因数的时候：

_$4y$没有变，_$2z$变为相反数，因为$z>=a$和$-z>=a$显然只能满足一个，所以改写成$\left|z\right|>=a$

注意程序效率！

算法复杂度为$\Theta(\sqrt{a^2-4b})$，极限数据可以到$1e8$

写上面的程序连吸氧都满足不了它了，只能手动吸臭氧
```cpp
#pragma GCC optimize (3)
#pragma GCC optimize ("Ofast")
```
下面卡卡常可以过。

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
typedef long long ll;
ll a,b;
int main(){
	scanf("%lld%lld",&a,&b);
	ll p=a*a-4*b;
	if(!p)return puts("inf"),0;
	ll absp=abs(p),ans=0,fl=a&1,sp=sqrt(absp);
	for(int i=1;i<=sp;++i)if(absp%i==0){
		ll zd2y=i,zp2y=p/i;
		if(p<0)swap(zd2y,zp2y);
		ll _4y=zp2y-zd2y,_2z=zp2y+zd2y;
		if(!(_2z&1) && !(_4y&3)) ans+=(((_2z>>1)&1)==fl && abs(_2z>>1)>=a);
	}
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：逃离地球 (赞：2)

[题目链接]( https://www.luogu.org/problem/P5596 )

说一个不一样的方法，来自[Mr_Wu]( https://www.luogu.org/space/show?uid=62308 )

由 $y^{2}-x^{2}=ax+b(a,b,x,y\in N)$,

变形可得$x^{2}+ax+b=y^{2}$.

显然，$x^{2}+ax+b$是完全平方数

此时构造式子$x^{2}+2px+p^{2}(p\in N)$，使得$p$是满足$2p\le a$且$p^{2}\le b$的数中最大的。

显然，$\forall x\in N,x^{2}+2px+p^{2}\le x^{2}+ax+b$.

同理，构造式子$x^{2}+2qx+q^{2}(q\in N)$，使得$q$是满足$2q\ge a$且$q^{2}\ge b$的数中最小的。

显然，$\forall x\in N,x^{2}+2qx+q^{2}\ge x^{2}+ax+b$.

设$y^2=(x+r)^2$，即$x^{2}+ax+b=(x+r)^2$

$\because$ $(x+p)^2\le(x+r)^2\le(x+q)^2$

$\therefore p\le r\le q$

此时$x=\frac{r^2-b}{a-2r}$ 

又因为$x$为整数，所以只需要解出所有$r$对应的$x$，判断其是否是整数，如果是，就是合法解。

值得注意的是，如果$x^{2}+ax+b$是完全平方式，输出inf即可。

---

## 作者：Krystallos (赞：2)

本人在比赛的时候过了这道题，赛后一看没想到最后是道蓝。

首先，这是道数论没有问题。

接下来，我经过一阵神奇的恒等变形，得到了这份代码：[推理过程详见此处](https://www.luogu.org/paste/k2adegqv)
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll a, b, ans;
int main() {
	scanf("%lld %lld", &a, &b);
	if (a % 2 == 0 && b * 4 == a * a) {
		return not printf("inf");
	}
	if (a & 1) {
		ll t = 4 * b - a * a, x, y;
		if (t > 0) {
			for (ll i = 1; i * i <= t; ++i) {
				if (t % i == 0) {
					y = i + t / i;
					x = i - t / i - 2 * a;
					if (x >= 0 && y >= 0 && (x & 3) == 0 && (y & 3) == 0)
						ans++;
					y = t / i + i;
					x = t / i - i - 2 * a;
					if (x >= 0 && y >= 0 && (x & 3) == 0 && (y & 3) == 0)
						ans++;
				}
			}
		} else {
			for (ll i = 1; i * i <= -t; ++i) {
				if (-t % i == 0) {
					y = i + t / i;
					x = i - t / i - 2 * a;
					if (x >= 0 && y >= 0 && (x & 3) == 0 && (y & 3) == 0)
						ans++;
					y = t / i + i;
					x = t / i - i - 2 * a;
					if (x >= 0 && y >= 0 && (x & 3) == 0 && (y & 3) == 0)
						ans++;
					if (t / i != -i) {
						ll j = -i;
						y = j + t / j;
						x = j - t / j - 2 * a;
						if (x >= 0 && y >= 0 && (x & 3) == 0 && (y & 3) == 0)
							ans++;
						y = t / j + j;
						x = t / j - j - 2 * a;
						if (x >= 0 && y >= 0 && (x & 3) == 0 && (y & 3) == 0)
							ans++;
					}
				}
			}
		}
	} else {
		a >>= 1;
		ll t = b - a * a, x, y;
		if (t > 0) {
			for (ll i = 1; i * i <= t; ++i) {
				if (t % i == 0) {
					y = i + t / i;
					x = i - t / i - 2 * a;
					if (x >= 0 && y >= 0 && (x & 1) == 0 && (y & 1) == 0)
						ans++;
					if (t / i != i) {
						y = t / i + i;
						x = t / i - i - 2 * a;
						if (x >= 0 && y >= 0 && (x & 1) == 0 && (y & 1) == 0)
							ans++;
					}
				}
			}
		} else {
			for (ll i = 1; i * i <= -t; ++i) {
				if (-t % i == 0) {
					y = i + t / i;
					x = i - t / i - 2 * a;
					if (x >= 0 && y >= 0 && (x & 1) == 0 && (y & 1) == 0)
						ans++;
					y = t / i + i;
					x = t / i - i - 2 * a;
					if (x >= 0 && y >= 0 && (x & 1) == 0 && (y & 1) == 0)
						ans++;
					if (t / i != -i) {
						ll j = -i;
						y = j + t / j;
						x = j - t / j - 2 * a;
						if (x >= 0 && y >= 0 && (x & 1) == 0 && (y & 1) == 0)
							ans++;
						y = t / j + j;
						x = t / j - j - 2 * a;
						if (x >= 0 && y >= 0 && (x & 1) == 0 && (y & 1) == 0)
							ans++;
					}
				}
			}
		}
	}
	printf("%lld", ans);
	return 0;
}
```
## 下面解释一下这份代码：
显然，右式为零时解有无数组。

由于我们已知$(y\ +\ x\ +\ \frac{a}{2})(y\ -\ x\ -\ \frac{a}{2})\ =\ b\ -\ \frac{a^2}{4}$，这时我们分类讨论:
* 1 $a\ \equiv\ 1\ (mod\ 2)$

这时我们在等号左右分别乘上4，得到：
$$(2y\ +\ 2x\ +\ a)(2y\ -\ 2x\ -\ a)\ =\ 4b\ -\ a^2$$

由于$a$，$b$均已知，所以右式可以算出来。又因为$a$，$b$，$x$，$y$均为整数，所以我们用根号级别的时间复杂度枚举右式的因数，再带回左式验证$x$，$y$是否均为自然数。

需要注意的是，如果右式为负数，那么枚举时要枚举所有一正一负乘起来的结果。如果右式为正，仅需枚举两个正数相乘。

* 2 $a\ \equiv\ 0\ (mod\ 2)$

直接像情况一一样枚举，若$x$，$y$均为自然数，$ans$++。

这里在情况一中做了处理，将每个单独的正式均变为正数方便枚举。

---

## 作者：地表最强男人 (赞：2)

## 这题标准的数学题（正解没开$long\ long$是真的蛋疼）
- $y^2=x^2+ax+b$用初中老师教的配方法，就可以变形成
$y^2=(x^2+ax+\frac{a^2}{4})+b-\frac{a^2}{4}$也就是
$y^2=(x+\frac{a}{2})^2+b-\frac{a^2}{4}$，用平方差公式可以变成
$(x+y+\frac{a}{2})*(x-y+\frac{a}{2})=\frac{a^2}{4}-b$因为$x$和$y$和$a$和$b$都是自然数，所以先去分母
$(2x+2y+a)*(2x-2y+a)=a^2-4b$
- 然后可以枚举等号右边这个东西的因子，然后让左边的式子匹配，解二元一次方程组，判断是不是符合自然数的条件就行了。有一个小技巧，就是等号左边的式子$(2x+2y+a)$的绝对值一定大于$2x-2y+a$，而且$2x+2y+a$一定大于等于0，所以我们分解等号右边的数的因子的时候，只需要分解小于等于$\sqrt{a^2-4b}$的因子就行了。
- 然后怎么判断是否有无限的解呢，显然如果等号右边的$a^2-4b$等于0，那么也就意味着只要等号左边有一个部分为0，那么另一边取什么值都行，比如让$2x-2y+a=0$，也就是$2y=2x+a$，另$y=x+\frac{a}{2}$有的人可能要说，如果$a$是奇数怎么办,这种情况是不可能出现的，因为$a^2=4b$，$a$一定是偶数。
- 当然，如果$a^2-4b$小于0的话，就要进行特判，这个其实只要让$2x-2y+a$，等于较小的因子的相反数，再解方程组就行了。
```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
long long c,zs[200000100],a,b,tot,ans;
bool fh=1;//若为0为负数 
void fj(long long x)
{
        for(long long i=1;i<=sqrt(x);i++)
            if(x%i==0)
                zs[++tot]=i;
}
int main()
{
        cin>>a>>b;
        c=a*a-4*b;
        if(c==0)
        {
            cout<<"inf";
            return 0;
        }
        if(c<0)
        {
            fh=0;
            c=-c;
        }
        fj(c);
        if(fh==1)
        {
            for(long long i=1;i<=tot;i++)
            {
                long long xx=c/zs[i],yy=zs[i];
                long long x=(xx+yy-2*a);
                if(x<0)
                    continue;
                if(x%4==0)
                    x=x/4;
                else
                    continue;
                long long y=(xx-a-2*x);
                if(y<0)
                    continue;
                if(y%2!=0)
                    continue;
                ans++;
            }
        }
        else
        {
            for(long long i=1;i<=tot;i++)
            {
                long long xx=c/zs[i],yy=-zs[i];
                long long x=(xx+yy-2*a);
                if(x<0)
                    continue;
                if(x%4==0)
                    x=x/4;
                else
                    continue;
                long long y=(xx-a-2*x);
                if(y<0)
                    continue;
                if(y%2!=0)
                    continue;
                ans++;
            }
        }
        cout<<ans;
        return 0;
}
```
# 最后记得，一定一定要开long long

---

## 作者：－｜－ (赞：1)

> 题意：求满足条件$y^2-x^2=ax+b$ 的自然数对$(x,y)$的个数

魔改一波：$y^2=x^2+ax+b$

$=>y^2=(x+\frac{1}{2}a)^2+b-\frac{a^2}{4}$

$=>a^2-4b=(2x+a-2y)(2x+a+2y)$

然后我们设$2x+a-2y=p\dots 1,2x+a+2y=q\dots 2$；则$a^2-4b=pq$；

$1+2$有：$4x+2a=q+p=>x=\frac{2a+p+q}{4}$；

$2-1$有：$4y=q-p=>y=\frac{q-p}{4}$；

因为是自然数，所以：

1.$4|q-p,4|2a+p+q$；

2.$p,q$同奇偶；

3.$2x+a$与$a$同奇偶；

4.$2x+a$与$y$不小于$0$；

5.如果$a^2-4b<0$，则$p<0$，因为$2x+a>=0,y>=0$，所以$q=2x+a+2y$一定大于等于$0$，而$p=2x+a-2y$可能小于$0$；

```cpp
#include<cstdio>
#include<cstring>
#define ll long long
#define il inline
#define re register
#define f(i,n,m) for(register int i=n;i<=m;i++)
const int N=1000;
il ll read(){
    re ll x=0,f=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9')x=(x<<1)+(x<<3)+(c^48),c=getchar();
    return x*f;
}
il ll abs(ll x){return x<0?-x:x;}
ll a,b,p,q,x,ans;
int main(){
    a=read(),b=read();
    if(!(a*a-4*b)){puts("inf");return 0;}
    x=a*a-4*b;
    for(re ll i=(a+1)%2+1;i*i<=abs(x);i+=2)
    {
        if(x%i)continue;
        p=i,q=abs(x/i);
        if(x<0)p=-p;
        if((q-p)%4)continue;//4|p-q
        if(q-(q-p)/2<a)break;//2x+a不小于0
        ans++;
    }
    printf("%lld",ans);
    return 0;
}
```

注：需要自己手写abs函数，我也不知道为什么……不这样干的话会WA一些点……

---

## 作者：两年打铁 (赞：1)



设$y=x+k$


那么原式即为 $(x+k)^2=x^2+ax+b$

如果右边是完全平方那么所有$x$都满足，是inf

化简一下

$x(a-2k)=k^2-b$

$x=\frac{k^2-b}{a-2k}$

要满足条件即使

$k \in \{m|min(\surd{b},\frac{a}{2})<=m<=max(\surd{b},\frac{a}{2})\}$

所以枚举一下k即可。

```cpp
#include<bits/stdc++.h>
#define max(a,b) (a>b?a:b)
#define min(a,b) (a<b?a:b)
#define kong putchar(' ')
#define huan putchar('\n')
#define bug puts("QWQ")
#define pr putchar
const int big=0x7fffffff;
using namespace std;
inline void read(int &x)
{
    x=0;char ch=getchar();int pd=1;
    while(ch<'0'||ch>'9'){if(ch=='-')pd=-pd;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    x*=pd;
}
inline void write(const int &x)
{
    char ggg[100];int s=0;int tmp=x;
    if(tmp==0){putchar('0');return;}
    if(tmp<0){tmp=-tmp;putchar('-');}
    while(tmp>0){ggg[s++]=tmp%10+'0';tmp/=10;}
    while(s>0){putchar(ggg[--s]);}
}
inline void wrs(const int &x)
{
	write(x);
	putchar(' ');
}

inline void wrl(const int &x)
{
	write(x);
	putchar('\n');
}
typedef long long LL;
int a;
LL b;

signed main()
{
	cin>>a>>b;
	
	if(!(a&1)&&1ll*(a/2)*(a/2)==b)
	{
		puts("inf");
		return 0;
	}
	int ans=0;
	int d=min(sqrt(b),a/2);
	int s=max(sqrt(b),a/2);
	for(register int i=d;i<=s;++i)
	{
		if(a-2*i!=0)
		{
			if((((1ll*i*i-b)==0?1:!((1ll*i*i-b>0)^(a-2*i>0))))&&(1ll*i*i-b)%(a-2*i)==0)++ans;
		}
	}
	cout<<ans<<endl;
	return 0;
}


---

## 作者：Leianha (赞：1)

## 数学


先膜拜一下考场上直接切掉的[燃情](https://www.luogu.org/space/show?uid=153897)巨佬。

首先分析一下部分分。（蒟蒻并没有分析出$b=0$的解法）

对于$a=b$的情况，只要满足$x=y$即可，所以一共有$inf$组解。

对于$a\le 1000$的情况，我们直接暴力判断一下即可。

对于$a=0$的情况，我们需要求$y^2 - x^2=b$,就是$(y-x)\times(y+x)=b$,发现这两项都是$b$的约数，所以我们$\sqrt n$枚举一下$b$的约数，若是要有正整数解，就需要$b- \frac{b}{i}$是偶数（~~想一想，为什么~~）,累加一下答案即可。

```cpp
void slove1()
{
	for(int i=1;i*i<=b;++i)
	{
		if(!(b%i))
		{
			if(!((b/i-i)&1))++ans;
		}
	}
	cout<<ans;
}
```
考场亲测综合使用可获得60+的分数。

### 满分做法

我们可以通过打表发现答案都非常小，$y-x$也很小，所以我们可以放弃枚举x，枚举一下$y$比$x$大多少。我们设为$g$,即$y=x+g$,原式也就变为

$(x+g)^2-x^2=ax+b$

将左边化简一下可得

$g^2 + 2gx = ax+b$

将与$x$有关的移到一边。

$g^2-b=(2g-a)x$

再移动一下

$x=\frac{g^2-b}{2g-a}$

又因为我们确定了$x$后就可以确定$y$,$x$和$y$都是自然数，$g^2-b$单调递增，$2g-a$单调递减，所以我们能确定一个$x$为自然数的最大边界。
```cpp
n = max((int)sqrt(b) + 1, a / 2 + 1);
for (int g = 0; g <= n; ++g) 
{
	if (a == 2 * g)continue;
	if (!((g * g - b) % (a - 2 * g)) && ((g * g - b) / (a - 2 * g) >= 0))++ans;
}
```

我们只在这个边界里枚举就行了，最大不会超过1e7。

### 再说一下inf的情况

~~由打表可得~~$b=(\frac{a}{2})^2$(a为偶数)时无解。

我们能将式子等价的化为$4b-a^2=(2y-2x-a)\times(2y+2x+a)$,倘若$b=(\frac{a}{2})^2$，那么式子左边就等于0，$(2y+2x+a)$恒大于0，而$(2y-2x-a)=0$又有无数种解，所以这时判一下inf即可。

代码其实还是很短的
```cpp
#include <bits/stdc++.h>
#define LL long long
using  namespace std;
LL a, b, ans, n, f;
signed main() 
{
	cin >> a >> b;
	if (!a && !b)puts("inf");
	else if ((!(a & 1)) && a * a / 4 == b)puts("inf");
	else 
	{
		n = max((LL)sqrt(b) + 1, a / 2 + 1);
		for (LL g = 0; g <= n; ++g) 
		{
			if (a == 2 * g)continue;
			if (!((g * g - b) % (a - 2 * g)) && ((g * g - b) / (a - 2 * g) >= 0))++ans;
		}
		cout << ans;
	}
}
```


---

## 作者：沉冥Charming (赞：1)

感谢评论区大佬指出错误，于是我修改了一下bug~

蒟蒻来写一篇简单易懂的题解~

首先，这题一看就是数论……

~~然而并不能打表找规律qaq~~

### 于是我们很容易想到——试着对方程变形
### 这样可以求出一个解的范围，防止TLE
- 先考虑最简单的情况：输出inf

- 使用配方法，过程如下：

- y ^ 2 - x ^ 2 = a * x + b

- y ^ 2 = x ^ 2 + a * x + b

- y ^ 2 = x ^ 2 + a * x +（a / 2）^ 2 -（a / 2）^ 2 + b

- y ^ 2 = [ x - ( a / 2 ) ]  ^ 2 -（a / 2）^ 2 + b

### 划重点：
### 当 -（a / 2）^ 2 + b  = 0 即 b = （a / 2） ^ 2 时，
### y ^ 2 = [ x - ( a / 2 ) ] ^ 2  有无穷组解

- 再考虑一般情况 

- 由于a ， b > = 0 且 x ，y 为自然数，所以y > = x

- 因此可以设 y = x + k ，k 为自然数

- 具体过程如下：

- （不知道为什么，可能下面会少显示几个 * 号，不影响阅读）

-  y ^ 2 - x ^ 2 = a * x + b 

- （x + k）^ 2 - x ^ 2 = a * x +b

- x ^ 2 + 2 * x *  k + k ^ 2 - x ^ 2 = a * x +b

- 2 * x * k + k ^ 2  = a * x + b

- k ^ 2 - b = ( a  -  2  *  k )  *  x

- x = ( k ^ 2 - b) / ( a - 2 * k )

### 划重点：由 x 为自然数，可知 k 的范围在 
### sqrt（b） 和 a / 2 之间，但不能取到 a / 2 

记得判断一下这两个数哪一个更大~

于是我们可以在这两个数之间枚举 k 的值 ，如果 x 为 自然数，ans++

蒟蒻代码如下：

（写得不是特别好，毕竟比赛时候写的考虑不周全）

```cpp
#include<iostream>
#include<cmath>
using namespace std;
long long a,b,ans,l,r;
int main()
{
    cin>>a>>b;
    if (a%2==0 && b==(a/2)*(a/2))
    {
        cout<<"inf";
        return 0;
    }
    if (a/2<floor(sqrt(b)))
    {
        l=a/2;
        r=floor(sqrt(b));
    }
    else
    {
        r=a/2;
        l=floor(sqrt(b));
    }
    for (long long m=r; m>=l; m--)
    {
        if (a==2*m)
            continue;
        if ((m*m-b)/(a-2*m)<0)
            break;
        if((double)(m*m-b)/(a-2*m)==(m*m-b)/(a-2*m))
            ans++;
    }
    cout<<ans;
    return 0;
}
```


最后，你就可以AC~~又水一道题~~了！

---

## 作者：傅思维666 (赞：1)

## 题解：

~~这篇题解即将刷新本蒟蒻写的最认真的数学题解的记录。~~

~~蒟蒻太菜了考试的时候只拿了18分~~

蒟蒻一开始的时候是这么想的：

观察原方程：
$$
y^2-x^2=ax+b
$$
把它转化成函数形式：
$$
y=\sqrt{x^2+ax+b}
$$
因为$x,y\in N$，所以我一下子就想到了**完全平方数**这个东西。

如果能把右侧的部分换成这样的形式：
$$
\sqrt{(x+k)^2}，k\in N
$$
那就显然会有无数组解。

然后我们展开，变成：
$$
\sqrt{x^2+2kx+k^2},k\in N
$$
和上面的对应上，就能列出一个等式关系：

当$2k=a,k^2=b$的时候，有无数组解。

一联立：
$$
\frac{a}{2}=\sqrt{b}
$$
这个时候有无数组解，输出$inf$即可。

~~然后蒟蒻就没有思路了~~。

冥思苦想了很长时间，最后还是用了暴力枚举，剪枝还剪错了，只好用了最最暴力的两重循环枚举来解决了这个问题。只得了18分。

今天看到了正解，惊喜地发现，我和大佬们的思路竟然重合了那么$1\%$，至少我推出来了无解的情况应该是什么样子的，而这种情况正是通往“有解”的情况的大门。

我们这样考虑：

因为原式子是个二元二次方程。这个方程很难搞。

如果我们把它换为一元方程的话，肯定就会容易一些。

但是我们还要求可行解的个数...怎么办呢？

灵光一闪（希望大家记住这个思想）

我们可以**构造$x,y$的映射关系**，这样求出一个合法的$x$，肯定就会有一个合法的$y$与之对应，我们就可以少搞很多东西。

那么，我们以此入手，分析原式子可得两边均大于等于0.

我们怎么对这个式子进行处理呢？有一个方法被蒟蒻起了个名字：**归一法**，这个方法通俗一点讲，就是把一个主元用一些辅元表示，然后通过一些辅元的关系和范围等求出主元的解。

那么我们就可以设$t=y-x,t\in N$.

这样，原式子就被我们搞成了这样：
$$
(x+t)^2-x^2=ax+b
$$
整理：
$$
x^2+2tx+t^2-x^2=ax+b
$$
再整理：
$$
x=\frac{b-t^2}{2t-a}
$$
那么，在有解的范围内（也就是$a/2\not= \sqrt{b}$）：

分类讨论：

一、$\frac{a}{2}<\sqrt{b}$时，有：
$$
t\in (\frac{a}{2},\sqrt{b}]
$$
二、$\sqrt{b}<\frac{a}{2}$时，有：
$$
t\in [\sqrt{b},\frac{a}{2})
$$
注意特判分母不得零的情况！！~~（化身数学班主任）~~

因为这个$t$定义的时候就是关于$x,y$的式子，所以当我们找到一个合法的$t$，我们就找到了一组解$(x,y)$。

基于此，我们只需要在$t$的范围内循环找可行解即可。



最后强调，代码实现的坑点是取整和特判...

代码：

```cpp
#include<cmath> 
#include<cstdio>
#define int long long
using namespace std;
int a,b,l,r,ans,n;
signed main()
{
    scanf("%lld%lld",&a,&b);
    r=sqrt(b);
	l=a/2;
    if(r*r==b && r*2==a) 
	{
		printf("inf");
		return 0;
	}
    else if(a==1 && b==0) 
	{
		printf("1");
		return 0;
	}
    else if(r>=l)
	{
        for(int i=l+1;i<=r;i++)
            if((abs(b-i*i))%(abs(2*i-a))==0) 
				ans++;
        printf("%lld",ans);
		return 0;
    }
    else
	{
		if(l*2==a)
			n=l-1;
		else 
			n=l;
        for(int i=r;i<=n;i++)
            if((abs(b-i*i))%(abs(2*i-a))==0) 
				ans++;
        printf("%lld",ans);
		return 0;
    }
}
```



---

## 作者：Indigo_Boy (赞：1)

# P5596 【XR-4】题
其实这题我昨天没做出来……所以今天写一下笔记  
昨天我还信誓旦旦地说这一定是一道黑题$OTZ$。果然菜是原罪。  
## 题目描述
小 X 遇到了一道题：

给定自然数 $a,b$求满足下列条件的自然数对 $(x,y)$ 的个数：

$y^2 - x^2 = ax + b$

他不会，只好求助于精通数学的你。

如果有无限多个自然数对满足条件，那么你只需要输出 $inf$ 即可。
## 输入格式
一行两个整数 $a,b$。

## 输出格式
如果个数有限，一行一个整数，表示个数。

如果个数无限，一行一个字符串 $inf$。

## 题解

$y^2 - x^2 = ax + b$  

$x^2 + ax + b = y^2$  

最朴素的第一想法一定是移项
刚开始想了一下求两函数交点，但是似乎不好搞，~~而且当时等号右边的方程还写错了~~  
窝太菜了$QWQ$ 

然后正解应该是配一下方(如果我当时没有去想狗屎枚举……

$(x + \frac{1}{2}a)^2 + b - \frac{1}{4}a^2 = y ^ 2$ 

这个式子就比较好看了，两个异号平方数，还有一项是常数，一定可以用平方差公式

$(x + \frac{1}{2}a)^2 - y ^ 2 = \frac{1}{4}a^2 - b$  

$(2x + 2y + a) * (2x - 2y + a) = a^2 - 4b$ 

接着就可以暴力枚举了？？？  
并不，直接枚举情况有、、多。

又因为**题干中说**数对$( x, y) \geqslant  0$,所以$(2x+2y+a)\geqslant0$。

那么我们就可以根据$a^2 - 4b$的情况来确定$(2x - 2y +a)$的正负性，进而加快枚举速度。

当$a^2 - 4b$大于零枚举时需要判断：  
1. x是否为正整数，即$(2x + 2y + a) + ( 2x - 2y + a) - 2a$ 是否是4的正整数倍；
2. y是否为正整数，即$(2x + 2y + a) - ( 2x - 2y + a)$ 是否是4的正整数倍；

当$a^2 - 4b$小于零枚举时需要判断：  
1. x是否为正整数，即$(2x + 2y + a) - ( 2y - 2x - a) - 2a$ 是否是4的正整数倍；
2. y是否为正整数，即$(2x + 2y + a) + ( 2y - 2x - a)$ 是否是4的正整数倍；

代码如下:
```cpp
#include<bits/stdc++.h>
using namespace std;
#define rint register int
#define ll long long
ll a, b;   //十年OI一场空，不开longlong见祖宗
int ans;
int main( void ){
	scanf( "%lld%lld", &a, &b );
	//cout << a << b;
	ll delta;
	delta = a * a - 4 * b;
	//cout << temp;
	if( delta == 0 ){
		cout << "inf";
		return 0;
	}
   //下面注意判断正负性，看哪个是i，哪个是j
	if( delta >= 0ll ){
		for( ll i = 1ll; i * i <= delta; i++ ){
			if( delta % i ) continue;
			if( ( delta / i + i - 2 * a ) % 4 != 0 || ( delta / i + i - 2 * a ) < 0 ) continue;
			if( ( delta / i - i ) % 4 != 0 || ( delta / i - i ) < 0 ) continue;
			ans++;
		}
		
	} else {
		delta *= -1;
		for( ll i = 1ll; i * i <= delta; i++ ){
			if( delta % i ) continue;
			if( ( delta / i - i - 2 * a ) % 4 != 0 || ( delta / i - i - 2 * a ) < 0 ) continue;
			if( ( delta / i + i ) % 4 != 0 ) continue;
			ans++;
		}
	}
	printf( "%d", ans );
	return 0;
}
```


看来数学还是得好好学啊(小声$BB$


---

## 作者：一只书虫仔 (赞：0)

#### Description

> 求自然数对 $(x,y)$ 个数使得：
>
> $$y^2-x^2=ax+b$$

#### Solution

化简原式：

$$\begin{aligned}y^2-x^2&=ax+b\\y^2-b&= x^2+ax\end{aligned}$$

为了方便右侧进行配方，我们将两边乘 $4$ 去配 $4x^2+4ax+a^2=(2x+a)^2$，直接用上面的式子配方会弄出来分数，很难处理：

$$\begin{aligned}4y^2-4b&=4x^2+4ax\\4y^2-4b+a^2&=4x^2+4ax+a^2\\4y^2-4b+a^2&=(2x+a)^2\\(2x+a)^2-4y^2&=a^2-4b\\(2x+a-2y)(2x+a+2y)&=a^2-4b\end{aligned}$$

$a^2-4b$ 是固定的，因此我们枚举 $a^2-4b$ 的因子即可。

注意一些细节，$x,y$ 不能是负数，当 $a^2-4b=0$ 时有无数组解，设枚举出来的 $a^2-4b$ 的因子为 $i$ 则 $\frac {a^2-4b} i-i$ 应为 $4$ 的倍数等。

---

## 作者：zbwer (赞：0)

## 数学分析:
题面：  $y^2-x^2=ax+b$  
简单移项并配方可得：$y^2-(x+\frac{a}{2})^2=b-\frac{a^2}{4}$   

由于除法计算会带来精度问题，我们考虑将式子左右两边同乘$4$，以达到简便精确计算的目的：  

$4y^2-4(x-\frac{a}{2})^2=4b+a^2$   
注意到式子左边可以用平方差公式化简：  

$4(y-x+ \frac{a}{2})(y+x-\frac{a}{2})=4b+a^2$  

考虑将左侧式子前的系数$4$乘入括号中，使得$\frac{a}{2}$变为$a$:  

$(2y-2x+a)(2y+2x-a)=4b+a^2$ 

令$A=2y-2x+a,B=2y+2x-a,tmp=4b+a^2$  

考虑在区间 [1,$\sqrt{tmp}$] 内，枚举$A$,则$B=tmp/A$，那么我们只需判断$A,B$是否是自然数即可. 

时间复杂度属于根号级，但数据有点卡常，判整除的时候推荐使用`!`符号，其余卡常方法见代码。

## Code:
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#define Mi return 
#define manchi 0
#define int long long

using namespace std;

int a,b,ans,A,B;

inline int read() 
{
	int num=0,w=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')w=-1;ch=getchar();}
	while(isdigit(ch)) num=(num<<1)+(num<<3)+ch-'0',ch=getchar();
	Mi num*w;
}

signed main()
{
	a=read(),b=read();
	int tmp=4*b-a*a;
	if(!tmp) {puts("inf");Mi manchi;}
	if(tmp>0)
	{
		for(register int i=1;i<=sqrt(tmp);i++)
		//register 循环内的卡常 
		{
			if(tmp%i) continue;
			A=i,B=tmp/i;//A=2y-2x-a	B=2y+2x+a
			if(!((A+B)%4) && !((B-A-2*a)%4) && (B-A-2*a)>=0)
			//a%b==0 等价于 !(a%b),但是貌似后者更快 
				ans++;
		}
	}
	if(tmp<0)
	{
		tmp*=-1;
		for(register int i=1;i<=sqrt(tmp);i++)
		{
			if(tmp%i) continue;
			A=i,B=tmp/i;//A=-2y+2x+a	B= 2y+2x+a
			if(!((A+B-2*a)%4) && !((B-A)%4) && (A+B-2*a)>=0 && B-A>=0)
				ans++;
		}
	}
	printf("%lld",ans); 
	Mi manchi;
}
//typed by zbwer 2019-10-23 22:20
```


---

## 作者：zybnxy (赞：0)

回归后的第一篇题解，也是切的第一道题~~太菜了做了好久才做出来~~

步骤尽量写得详细点~~就是怕自己错~~

$$y^2-x^2=ax+b$$
$$y^2=x^2+ax+b$$
$$y^2=(x+\frac{a}{2})^2+\frac{a^2-4b}{4}$$
$$(y+x+\frac{a}{2})(y-x-\frac{a}{2})=\frac{a^2-4b}{4}$$
$$\text{即}(2x+2y+a)(2x-2y-a)=a^2-4b$$

然后设$m=2x+2y+a,n=2x-2y-a,$可以对$a^2-4b$进行分类讨论

* $a^2-4b>0$时
$$m=2x+2y+a,n=2x-2y-a$$
$$\begin{cases}m+n=4x\\m-n=4y+2a\end{cases}$$
$$\begin{cases}x=\dfrac{m+n}{4}\\y=\dfrac{m-n-2a}{4}\end{cases}$$

* $a^2-4b<0$时
$$m=-a-2x-2y,n=2x-2y-a$$
$$\begin{cases}m+n=-4y\\m-n=-4x\end{cases}$$
$$\begin{cases}x=\dfrac{n-m}{4}\\y=\dfrac{-m-n}{4}\end{cases}$$

于是我们只需要枚举$m$就好了吧，复杂度也不大，$O(\sqrt{a^2-4b})$，可以跑过

结果没想到题目那么卡常，于是加了一点优化

* 输入输出用$scanf,printf$
* 把求$x,y$ 时的$/4$变成$>>2$
* 加氧优化

~~然后我就过了~~

至于$code$，我当时推的时候把正负号弄反了，结果还是一样，像这样写也同理

```
#include<cmath>
#include<cstdio>
#define ll long long
int main()
{
	ll a,b,ans=0;
	scanf("%lld%lld",&a,&b);
	if((a/2)*(a/2)==b&&!(a%2)){
		puts("inf");return 0; 
	}
	ll k=a*a-4*b;
	if(4*b<a*a){
		ll k=a*a-4*b;
		for(ll i=1;i*i<=k;i++){
			if(k%i==0&&i+k/i>=2*a&&k/i>=i){
				if((k/i-i)%4==0&&(i+k/i-2*a)%4==0){
					ll x=(i+k/i-2*a)>>2,y=(k/i-i)>>2;
					if(x>=0&&y>=0)ans++; 
				}
			}
		}
	}
	else{
		ll k=4*b-a*a;
		for(ll i=1;i*i<=k;i++){
			 if(k%i==0&&k/i>=i+2*a){
				if((k/i-i-2*a)%4==0&&(i+k/i)%4==0){
					ll x=(k/i-i-2*a)>>2,y=(i+k/i)>>2;
					if(x>=0&&y>=0)ans++;
				}
			}
		}
	}
	printf("%lld\n",ans);
	return 0;
}
```

~~重新换号推得式子应该没错吧~~

---

## 作者：Tommy_clas (赞：0)

分享一下$O(\sqrt{b})$做法。

[传送门](https://www.luogu.org/problem/P5596)

题目大意：给出自然数$a$和$b$，求二元二次方程$y^2-x^2=ax+b$的解集的数量$(a≤1e8,b≤1e15)$。

题目中有一个很重要的条件：$a,b,x,y$都是自然数。且何谓自然数也？自然数者，非负整数也。由此，我们能推出（注：$N$=自然数集合）：

$∵a,b,x,y∈N$

$∴ax+b∈N,y^2-x^2∈N$

$∴y^2-x^2≥0$

即$y^2≥x^2$

又$∵x,y∈N$

$∴y≥x$

由此我们可以设$y=x+k,(k∈N)$。

所以上述方程也可以表示为$(x+k)^2-x^2=ax+b$。

将$k$看作常数，解方程得到$x=\frac{b-k^2}{2k-a}$

由于题目要求$x$是自然数，我们只需要枚举自然数$k$然后判断$x$是否合法就可以了。

我们先讨论如何枚举$k$，因为$x∈N$，所以$b-k^2=0$或$b-k^2,2k-a$同号。

即：$\begin{cases}b-k^2=0&\\2k-a≠0&\end{cases}$

或
$\begin{cases}b-k^2<0&\\2k-a<0&\end{cases}$

或$\begin{cases}b-k^2>0&\\2k-a>0&\end{cases}$

解得（注意，下面只给出大略的范围，对于详细取值请参考代码）：

当$\sqrt{b}>\frac{a}{2}$时，$k∈[\frac{a}{2},\sqrt{b}]$。

当$\sqrt{b}<\frac{a}{2}$时，$k∈[\sqrt{b},\frac{a}{2}]$。

当$\sqrt{b}=\frac{a}{2}$即$\frac{a^2}{4}=b $且$a$为偶数时，$k$有无数种取值。

对于第三种情况，还有另一种理解方法：答案有无数个，等价于$x^2+ax+b$是完全平方式，因此根据完全平方公式得到：$\frac{a^2}{4}=b $.

这样我们先判断是否有无数个解，再讨论出$k$的范围，然后枚举该范围内的所有自然数，判断分数$\frac{b-k^2}{2k-a}$是否可以化成整数，统计答案即可。

关于时间复杂度，$k$枚举的下界不考虑，上界是$\frac{a}{2}$或$\sqrt{b}$，所以时间复杂度是$O(\sqrt{b})$，由于$b≤1e15$，所以$max(\sqrt{b})≈3e7$，刚好能过。

上代码：
```cpp
#include<cstdio>
#include<cmath>
#define ll long long
using namespace std;
ll a,b,k;
int ans=0;
int main()
{
	scanf("%lld %lld",&a,&b);
	if(!(a&1)&&a*a/4==b)//别忘了带上a是偶数！ 
	{
		puts("inf");
		return 0;
	}
	ll temp=sqrt(b);
	if(temp>=a/2+1)
	{
		for(ll k=a/2;k*k<=b;k++)
			if(k*2>a&&!((b-k*k)%(2*k-a)))ans++;
	}
	else
	{
		for(ll k=temp;k*2<a;k++)
			if(k*k>=b&&!((b-k*k)%(2*k-a)))ans++;
	}
	printf("%d\n",ans);
	return 0;
}
```



---


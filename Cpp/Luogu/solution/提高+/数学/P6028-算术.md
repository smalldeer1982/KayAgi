# 算术

## 题目背景

小 W 去上算术课了。

## 题目描述

> 众所周知，高斯在小学的时候，有一天他的数学老师留了一道题：$1+2+\cdots+100=?$，他认为学生们算 $100$ 个数相加要算很久，然后就准备溜去喝咖啡，但是这个时候高斯却举手说他算完了——他用了我们今天众所周知的等差数列求和公式。

但是，这个算术课的老师就像高斯的老师一样不负责任，他在黑板上留了一道算术题就溜去泡妹子了。但小 W 可没高斯那么聪明，而且这个式子看起来没有巧算方法。于是，他通过电话联系上了学 $\text{OI}$ 的你，希望你给他帮助。作为回报，他会给你 $100$ 分作为奖励。

具体来讲，黑板上的式子是这样的：

设 $n$ 的质因数分解结果为 $n=\prod\limits_{i=1}^kp_i^{\alpha_i}$，则定义 $f(n)=\prod\limits_{i=1}^k{\dfrac{p_i^{\alpha_i+1}-1}{p_i^{\alpha_i+1}-p_i^{\alpha_i}}}$，求 $\sum\limits_{i=1}^nf(i)$ 的值（精度要求参见提示与说明）。

**注意：特别地，我们定义** $f(1)=1$。

## 说明/提示

样例二解释：$f(1)=1,f(2)=\dfrac{2^2-1}{2^2-2^1}=1.5,f(3)=\dfrac{3^2-1}{3^2-3^1}=1.3333333333,f(4)=\dfrac{2^3-1}{2^3-2^2}=1.75,f(5)=\dfrac{5^2-1}{5^2-5^1}=1.2$。
********
本题带有 $\text{SPJ}$。设你的答案为 $a$，标准答案为 $b$。  
如果 $ |{a-b}|\le \min(\dfrac b{10^4},10) $，则获得这个测试点的所有分数；  
否则，如果$|{a-b}|\le \min(\dfrac b{10^3},100)$，则获得这个测试点的分数的 $40\%$；  
否则，你将不会获得任何分数。  
标准答案将会保留 10 位小数。  
**注意：虽然此题对精度要求较低，但仍建议用更为精确的`long double`存储答案。**
********
数据范围：  
对于 $10\%$ 的数据，$n\le10$。  
对于 $30\%$ 的数据，$n\le10^3$。  
对于 $60\%$ 的数据，$n\le10^7$。  
对于 $100\%$ 的数据，$1\le n\le10^{13}$。

## 样例 #1

### 输入

```
2
```

### 输出

```
2.5000000000```

## 样例 #2

### 输入

```
5```

### 输出

```
6.7833333333```

# 题解

## 作者：NaCly_Fish (赞：27)

其实这个题有一个非常 bullshit 的 $\Theta(1)$ 解法，仅供参考。
***
首先题目中给出的式子很迷惑，随便推一下发现就是 $\sigma_1(n)/n$。  
然后就能得出一个除法分块式子

$$\sum_{i=1}^n\sum_{j=1}^{\lfloor n/i \rfloor} \frac 1j$$
考虑每个 $1/j$ 出现了多少次，式子化为

$$\sum_{i=1}^n\frac{\lfloor n/i \rfloor}{i}$$
接下来就是最玄学的地方，直接把向下取整扔掉，式子变成

$$n\sum_{i=1}^n \frac{1}{i^2}$$
（当然这样是有误差的，最后调整一下即可）  
对于身经百战见得多的同学，容易发现在 $n$ 很大的时候就可以近似为 $\zeta(2)$，即 $\pi^2/6$。

然后就能得到这么一份看起来非常扯淡，但就是能过的代码  
```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#define ll long long
#define reg register
#define pi 3.141592653589793
using namespace std;

int main(){
    ll n;
    long double ans = 0;
    scanf("%lld",&n);
    if(n<=1e6) for(reg int i=1;i<=n;++i) ans += 1.0/i * (n/i);
    else ans = pi*pi/6*n - 10;
    printf("%.9Lf",ans);
    return 0;	
}
```

ps：对于上面说到的这个式子
$$\sum_{i=1}^\infty i^{-2} = \frac{\pi^2}{6}$$
有很多有趣的证明方法，可以自己搞一搞

---

## 作者：mrsrz (赞：8)

[可能更好的体验](https://mrsrz.github.io/2020/01/31/lg6028/)

~~我不会近似，我不会整除分块，我只会枚举。~~

考虑转化一下 $f(n)$。
$$
f(n)=\prod_{i=1}^k\frac{p_i^{\alpha_i+1}-1}{p_i^{\alpha_i+1}-p_i^{\alpha_i}}$$
$$=\prod_{i=1}^k\frac{(p_i-1)\sum_{j=0}^{\alpha_i}p_i^{j}}{p_i^{\alpha_i}(p_i-1)}$$
$$=\frac{\prod_{i=1}^k\sum_{j=0}^{\alpha_i}p_i^{j}}{\prod_{i=1}^k p_i^{\alpha_i}}$$
$$=\frac{\sigma(n)}{n}
$$
其中 $\sigma(n)$ 等于 $n$ 的所有正因数的和。

所以我们要求的是 $\sum\limits_{i=1}^N \frac{\sigma(i)}i$ 的值。

我们考虑**对每个因数计算贡献**。

对于一个数 $n$，若其有因子 $k$，则必有因子 $\frac{n}k$。若 $k\lt \sqrt n$，则 $\frac n k\gt \sqrt n$。当然有 $k=\frac n k=\sqrt n$ 的情况，此时只能计算一次。

那么我们对因数 $k$，分成 $k\leq \sqrt n$ 和 $k\gt \sqrt n$ 来计算贡献。

我们先计算 $k\leq \sqrt n$ 的情况，可知这样的 $k$ 不超过 $\sqrt N$ 个。

枚举 $k$，对于一个 $k$，为了使它的贡献满足 $k\leq \sqrt n$，所以我们只计算在 $[k^2,N]$ 中 $k$ 的贡献。它的贡献为：
$$k\cdot\sum_{i=k}^{\lfloor\frac N k\rfloor}\frac{1}{ik}=\sum_{i=k}^{\lfloor\frac N k\rfloor}\frac{1}{i}$$
令函数 $g(n)=\sum\limits_{i=1}^n \frac 1 i$，则这部分贡献可以表示为 $g(\lfloor\frac N k\rfloor)-g(k-1)$。

这里的 $g(n)$ 是调和级数，当 $n$ 非常大时，其近似为 $\ln n+\gamma$，其中 $\gamma\approx  0.5772156649$，所以预处理 $n$ 较小的时候的值，$n$ 较大的时候用 $\ln n+\gamma$ 计算，即可 $O(1)$ 计算单个的贡献。

接着计算 $k\gt \sqrt n$ 的情况，这样的 $k$ 满足 $\lfloor\frac N k\rfloor$ 不超过 $\sqrt N$ 个。

枚举 $\lfloor\frac N k\rfloor$，令其为 $x$，我们对每个 $x$ 的倍数 $n$，计算 $\frac n x$ 的贡献。

为了使这里的贡献满足 $\frac n x \gt\sqrt n$，对于 $x$ 只计算 $(x^2,N]$ 的贡献。

所以对于一个 $x$，它的贡献为：
$$
\sum_{i=x}^{\lfloor\frac N x\rfloor}\frac{ix}{x}\cdot\frac{1}{ix}=\frac{\lfloor\frac N x\rfloor-x}x
$$


这显然可以 $O(1)$ 计算。

我们计算每部分贡献，枚举的数都是 $\sqrt N$ 个，所以时间复杂度 $O(\sqrt N)$。

于是我们使用了**枚举**算法解决此题。

## Code：
```cpp
#include<cstdio>
#include<cmath>
typedef long long LL;
LL n;
double Ln[55],ans;
inline double ln(LL x){return x<51?Ln[x]:log(x)+0.5772156649;}
int main(){
    scanf("%lld",&n);
    for(int i=1;i<=50;++i)Ln[i]=Ln[i-1]+1./i;
    for(int i=1;(LL)i*i<=n;++i)ans+=ln(n/i)-ln(i-1)+1.*(n/i-i)/i;
    printf("%f\n",ans);
    return 0;
}
```

---

## 作者：WYXkk (赞：5)

# 题解 算术
## 10pts
人脑打表。
## 30pts
按题意计算。
## 70pts
下面证明一个结论：$f(n)=\sum\limits_{d|n}\dfrac1d$。

$$\begin{aligned}\sum\limits_{d|n}\frac1d&=\prod\limits_{i=1}^k(\frac11+\frac1{p_i}+\frac1{p_i^2}+\cdots+\frac1{p_i^{\alpha_i}})\;(*)\\&=\prod\limits_{i=1}^k\dfrac{1-\dfrac{1}{p_i^{\alpha_i+1}}}{1-\dfrac 1{p_i}}\\&=\prod\limits_{i=1}^k\dfrac{p_i^{\alpha_i+1}-1}{p_i^{\alpha_i+1}-p_i^{\alpha_i}}=f(n)\end{aligned}$$

注：第一行的式子，想象将右式拆开，你就会发现它等于左边。

于是：

$$\sum_{i=1}^nf(i)=\sum_{i=1}^n\sum_{d|i}\frac1d=\sum_{d=1}^n\sum_{d|i,i\le n}\frac1d=\sum_{d=1}^n\lfloor\frac nd\rfloor\times\frac1d$$

于是带入计算即可。

$\texttt{code:}$（仅核心部分）
```pascal
long double sum(long long n)
{
	long double ans=0;
	F(i,1,n) ans+=(long double)(n/i)/i;
	return ans;
}
```
## 100pts
看到刚刚的式子，你想到了什么？

整除分块！

我们只需要想办法计算 $\sum\limits_{i=1}^n\dfrac1i$ 即可。

众所周知，$\lim\limits_{n\to +\infty}(\sum\limits_{i=1}^n\dfrac1i)-\ln n$ 存在，它的大致值可以通过 BaiduFirstSearch 或者手动计算得到。

因此，我们先设定一个 $N$，然后预处理出 $s_i=\sum\limits_{j=1}^i\dfrac1j(i\le N)$，接下来，当我们求 $\sum\limits_{i=1}^n\dfrac1i$ 时，如果 $n\le N$，那么直接返回 $s_n$，否则使用上面的近似计算。

（注：造数据时为确保精确 $N=10^7$，但由于精度限制较宽 $N=5\times10^5$ 也能过）

$\texttt{code:}$
```cpp
#include<cstdio>
#include<iostream>
#include<fstream>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
#define Set(a) memset(a,0,sizeof(a))
#define F(i,a,b) for(register int i=a,i##end=b;i<=i##end;++i)
#define UF(i,a,b) for(register int i=a,i##end=b;i>=i##end;--i)
#define openf(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
#define re register
#define ri re int
#define il inline
typedef long long ll;
typedef unsigned long long ull;
template<typename T> inline T rd(T& x)
{
	T f=1;x=0;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(; isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(T)(c-'0');
	x*=f;
	return x;
}
ll rd(){ll x;rd(x);return x;}
inline int max(int a,int b){return a>b?a:b;}
inline int min(int a,int b){return a<b?a:b;}
const int inf=1<<30;

typedef long double ld;
const ld t=0.57721566490153286060651209f;
const int N=500000;
ld sum[N+5];
struct init{init(){F(i,1,N)sum[i]=sum[i-1]+(ld)1/i;}}wertfgyhj;
ld qsum(ll a){return a<=((ll)N)?sum[a]:log(a)+t;}
ld qsum(ll l,ll r){return qsum(r)-qsum(l-1);}
ld ans=0;
int main()
{
	ll n=rd();
	re ll l=1,r=1;
	while(l<=n)
	{
		r=n/(n/l);
		ans+=(n/l)*qsum(l,r);
		l=r+1;
	}
	printf("%.6Lf",ans);
	return 0;
}
```


---

## 作者：Fading (赞：4)

17:40拿到题目，然后17:50开始打。。。

发现这个式子太明显是人为的了，随便拆拆或者用等比数列求和就知道是

$$f(x)=\prod(1+\frac 1{p_i}+...+\frac 1{p_i^{\alpha_i}})$$

根据数论常识，观察一下，提一提

$$=\frac 1x\prod(1+{p_i}+...+{p_i^{\alpha_i}})$$

右边是约数的和。

$$=\frac 1x\sum_{d|x}d$$

原式

$$=\sum_{i=1}^n\frac 1i\sum_{d|i}d$$

$$=\sum_{d=1}^nd\sum_{d|i}\frac 1i$$

$$=\sum_{d=1}^n\sum_{i=1}^{\lfloor\frac nd\rfloor}\frac 1i$$

显然可以整除分块了。但是瓶颈在求和。

我寻思着答案误差这么大，是不是可以扔掉一部分的答案...($\frac 1{1000000}$)

然后WA了...

18:10的时候上网查了一下发现n很大的时候这个东西可以近似成$\ln n+r$，这个$r$叫做欧拉常数...然后就可以特判，如果$\frac nd$大就用这个鬼东西，否则预处理...

去百度抄个$r$就A了...

```cpp
#include<bits/stdc++.h>
using namespace std;
long double sum[5010101];
int main(){
    #define ll long long
    ll n;
    cin>>n;
    long double x=0;
    for (ll i=1;i<=min(5000000ll,n);i++) sum[i]=sum[i-1]+(1.0/(long double)i);
    for (ll l=1,r;l<=n;l=r+1){
        r=n/(n/l);
        if (n/l>5000000) x+=(r-l+1)*(log(n/l)+0.57721566490153286060651209);
        else x+=(r-l+1)*sum[n/l];
    }
    printf("%.10Lf",x);
    return 0;
}
```

艹，这真的是标算，佩服出题人orz



---

## 作者：Spasmodic (赞：3)

神奇题

考虑这个 $f(n)$ 是个啥。

$$
\begin{aligned}
f(n)&=\prod_{i}\frac{p_i^{\alpha_i+1}-1}{p_i^{\alpha_i+1}-p_i^{\alpha_i}}\\
&=\prod_{i}\frac{p_i^{\alpha_i+1}-1}{p_i-1}\times \frac{1}{p_i^{\alpha_i}}\\
&=\frac{\sigma(n)}{n}
\end{aligned}
$$
所以
$$
\begin{aligned}
&\sum_{i=1}^{n}f(i)\\
=&\sum_{i=1}^{n}\frac{\sigma(i)}{i}\\
=&\sum_{i=1}^{n}\sum_{j|i}\frac{j}{i}\\
=&\sum_{j=1}^{n}\sum_{j|i}\frac{j}{i}\\
=&\sum_{j=1}^{n}\sum_{i=1}^{[n/j]}\frac{1}{i}\\
=&\sum_{i=1}^{n}\sum_{j=1}^{[n/i]}\frac{1}{i}\\
=&\sum_{i=1}^{n}\frac{[n/i]}{i}\\
\end{aligned}
$$
当 $n$ 小的时候，直接算就行，复杂度是 $O(n)$ 的。

$n$ 大的时候，我们直接扔掉下取整，式子就变成
$$
n\sum_{i=1}^{n}\frac{1}{i^2}
$$
下面考虑证明一下这个东西 一般称为 **巴塞尔问题** ~~其实是我怕过不了审核加的~~


$$
\lim_{n\to \infty}\sum_{i=1}^{n}\frac{1}{i^2}=\zeta(2)=\frac{\pi^2}{6}
$$
~~下面的这种证法可能不太严谨，感性理解下就可以了~~

考虑函数
$$
f(x)=\frac{\sin\sqrt x}{\sqrt x}
$$
其零点为 $k^2\pi^2$，其中 $k\in \mathbb N^+$。

一方面， $f(x)$ 的泰勒展开为
$$
f(x)=1-\frac{x}{3!}+\frac{x^2}{5!}-\frac{x^3}{7!}+\dots
$$
另一方面，根据因式定理，它也可以表示为
$$
(x-\pi^2)(x-4\pi^2)(x-9\pi^2)\dots
$$
的若干倍。

注意到 $f(x)$ 常数项为 $1$，所以可得
$$
f(x)=(1-\frac{x}{\pi^2})(1-\frac{x}{4\pi^2})(1-\frac{x}{9\pi^2})\dots
$$
考虑两式的一次项系数即得
$$
\sum_{i=1}^{\infty}\frac{1}{i^2\pi^2}=\frac{1}{3!}
$$
所以
$$
\zeta(2)=\sum_{i=1}^{\infty}\frac{1}{i^2}=\frac{\pi^2}{6}
$$
得证。

[这里](https://www.zhihu.com/zvideo/1409549404743716864)是这个问题的一种几何证法，感觉非常高妙。

所以原式在 $n$ 大时，约等于
$$
n\zeta(2)=\frac{n\pi^2}{6}
$$
那么做一个数据分治，然后再对这个式子进行微调即可。

---

## 作者：yizcdl2357 (赞：1)

# 题意

对于 $n=\prod_{i=1}^k p_i^{a_i}$ 令 $f(n)=\prod_{i=1}^k\dfrac{p_i^{a_{i+1}}-1}{p_i^{a_{i+1}}-p_i^{a_{i}}}$，求 $\sum_{i=1}^n f(i)$ 的值。
# 前置知识
等比数列求和，整除分块，一定的数学推导能力。
# 解法

观察样例，不难发现一个规律：$f(n)$ 就是它所有约数的倒数和。

证明也不难：

$$\begin{aligned}
	&\sum_{i|n} \dfrac{1}{i}\\
   =&\sum_{b_1=0}^{a_1}\sum_{b_2=0}^{a_2}\cdots\sum_{b_k=0}^{a_k}\dfrac{1}{p_1^{b_1}p_2^{b_2}\cdots p_k^{b_k}}&\text{（质因数分解每个约数）}\\
   =&\prod_{i=1}^k\dfrac{1}{1}+\dfrac{1}{p_i}+\dfrac{1}{p_i^2}+\cdots+\dfrac{1}{p_i^{a_i}}&\text{（将原式因式分解）}\\
   =&\prod_{i=1}^k\dfrac{1-\dfrac{1}{p_i^{a_i+1}}}{1-\dfrac{1}{p_i}}&\text{（等比数列求和）}\\
   =&\prod_{i=1}^k\dfrac{p_i^{a_i+1}-1}{p_i^{a_i+1}-p_i^{a_i}}&\text{（化简）}\\
   =&f(n)
\end{aligned}$$

要求的值化为：

$$\begin{aligned}
	&\sum_{i=1}^n f(n)\\
  =&\sum_{i=1}^n\sum_{j|i} \dfrac{1}{j}&\text{（刚才找到的规律）}\\
 =&\sum_{j=1}^n\sum_{j|i,i\le n}\dfrac{1}{j}&\text{（交换求和顺序）}\\
 =&\sum_{j=1}^n\dfrac{1}{j}\sum_{j|i,i\le n}1&\text{（提出}\dfrac{1}{j}\text{）}\\
 =&\sum_{j=1}^n\dfrac{1}{j}\times\lfloor\dfrac{n}{j}\rfloor&\text{（化简后半部分）}\\
 =&\sum_{l,r}\lfloor\dfrac{n}{l}\rfloor\sum_{i=l}^r\dfrac{1}{i}&\text{（整除分块）}\\
 =&\sum_{l,r}\lfloor\dfrac{n}{l}\rfloor(H_r-H_{l-1})&\text{（利用调和数化简）}\\
\end{aligned}
$$

快速计算调和数（见[此博客](https://www.luogu.com.cn/blog/NaCly-Fish-blog/solution-p5147)），然后整除分块，复杂度 $O(\sqrt{n})$。
# 坑点

此题略卡精度，调和数 $H_x$ 当 $x\le4\times 10^8$ 时要暴力计算，当 $x>4\times 10^8$ 再套公式。
# 代码
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#define int long long
#define db long double 
using namespace std;
inline db H(int x,int y)
{
	double ans=0;
	if(y<=4e8)
		for(register int i=x;i<=y;i++)
			ans+=1.0/i;
	else ans=log(y)-log(x);
	return ans;
}
signed main()
{
	db ans=0;
	int n;
	cin>>n;
	int r;
	for(int l=1;l<=n;l=r+1)
		r=n/(n/l),
		ans+=H(l,r)*(db)(n/l);
	printf("%.10Lf",ans);
	return 0;
}
```


---

## 作者：littleKtian (赞：1)

如果你不知道调和级数是什么，那么~~你可以放弃这题了~~请右转百度

如果你不知道整出分块是什么，那么~~你也可以放弃这题了~~也请右转百度

--------------

首先第一眼看到这条柿子，第一想法肯定是把分母提取公因数~~反正我是这么想的~~

于是  
$f(n)=\prod\limits_{i=1}^k\dfrac{p^{a_i+1}-1}{p^{a_i}(p-1)}$  
$f(n)=\dfrac{\prod\limits_{i=1}^k\sum\limits_{j=0}^{a_i}p^j}{\prod\limits_{i=1}^kp_i^{a_i}}=\dfrac{\sum\limits_{d|n}d}{n}$（分母显然可得，分子可以自行上网百度 $n$ 的因数和公式，此处不作证明~~懒得证（其实拆开就行了）~~）

现在求 $\sum\limits_{i=1}^nf(i)$

$\sum\limits_{i=1}^nf(i)=\sum\limits_{d=1}^n\sum\limits_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\dfrac{d}{d\times i}=\sum\limits_{d=1}^n\sum\limits_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\dfrac{1}{i}$（第一步变换从枚举 $i$ 改为枚举约数 $d$ 算贡献，两边拆开即可证明）

$\sum\limits_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\dfrac{1}{i}$ 小范围内预处理结果，大范围利用欧拉常数即可

$\sum\limits_{d=1}^n$ 则可以用整除分块

```
#include<bits/stdc++.h>
using namespace std;
const long long L=1000000;
const long double y=0.577215664901532;//欧拉常数
long long n,le,j;
long double xx[L+5],ans,add;
int main()
{
	scanf("%lld",&n);
	for(long long i=1;i<=L;i++)xx[i]=xx[i-1]+1.0/i;
	for(long long i=1;i<=n;i++)
	{
		le=n/i,j=min(n,n/le);
		if(le<=L)add=xx[le];
		else add=log(le)+y;
		//add=1+1/2+1/3+...+1/le
		ans+=add*(j-i+1),i=j;
	}
	printf("%0.11Lf",ans);
}
```
~~话说为什么我会做这题但不会T1？（~~

---

## 作者：diqiuyi (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P6028)。

**思路**

考虑转化式子，我们知道：$f(n)=\prod\limits_{i=1}^k\dfrac{p_i^{\alpha_i+1}-1}{p_i^{\alpha_i+1}-p_i^{\alpha_i}}=\prod\limits_{i=1}^k\dfrac{(p-1)(\sum_{j=0}^{\alpha_i}p_i^j)}{(p-1)p_i^{\alpha_i}}=\prod\limits_{i=1}^k\dfrac{\sum_{j=0}^{\alpha_i}p_i^j}{p_i^{\alpha_i}}=\dfrac{S(n)}{n}$。

这里 $S(n)$ 表示 $n$ 的正约数之和。

考虑计算贡献，于是 $\sum_{i=1}^n f(i)=\sum_{d=1}^n d\sum_{x=1}^{\lfloor\frac{n}{d}\rfloor} \dfrac{1}{dx}=\sum_{d=1}^n \sum_{x=1}^{\lfloor\frac{n}{d}\rfloor} \dfrac{1}{x}=\sum_{d=1}^n g(\lfloor\frac{n}{d}\rfloor)$。

其中 $g(x)=\sum_{i=1}^x \dfrac{1}{i}$。

我们考虑整除分块。这样需要快速计算 $g(\lfloor\frac{n}{d}\rfloor)$ 的值。显然这可以线性预处理。但是线性复杂度无法通过本题。

不过，不难发现 $g(x)$ 是调和级数，当 $x$ 较大时，它的值可以看做一个常数乘上 $\ln x$。又注意到本题精度卡的很松，所以不妨考虑对于较小的 $x$，预处理 $g(x)$，否则用一个常数和 $\ln x$ 代替它。

至于这个常数取什么，可以通过多次提交二分答案。代码非常短。

**code**
```cpp
#include <bits/stdc++.h>
using namespace std;
long long n;
double ans,sum[32000005];
int main(){
//	n=read();
	for(int i=1;i<=32000000;i++) sum[i]=sum[i-1]+1.0/i;
	cin>>n;
	for(long long l=1,r;l<=n;l=r+1)
		r=n/(n/l),ans+=(double)(r-l+1)*(n/l<32000000ll?sum[n/l]:log(n/l)*1.031575);//通过二十多次提交得到的结果
	cout<<fixed<<setprecision(6)<<ans<<'\n';
	return 0;
}//10000000000000
```

---


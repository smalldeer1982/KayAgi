# 纯粹容器

## 题目背景

白王正在挑选容器。

## 题目描述

白王制造了 $n$ 个容器，并将它们排成了一队，从左到右依次编号为 $1 \sim n$。第 $i$ 个容器的**强度**为 $a_i$，保证 $a_i$ 互不相同。为了挑选出最纯粹的容器，白王会进行 $n-1$ 轮操作，每轮操作中，他会等概率随机挑选两个 **位置相邻** 且 **未被击倒** 的容器，令它们进行决斗，在一次决斗中，强度较小的容器将会被击倒并移出队列。

显然最后留下的是强度最大的容器，但是，可怜的容器们很想知道自己能够活多久，于是，它们请你对每个容器求出它存活轮数的期望。答案对 $998244353$ 取模。

一个容器的存活轮数为最大的非负整数 $x < n$ 满足它在第 $x$ 轮未被击倒。

两个容器 $i$ 和 $j$ 位置相邻当且仅当不存在 $k$ 满足 $i<k<j$ 且 $k$ 号容器未被击倒。

## 说明/提示

#### 样例解释

在第一组样例中，第一个容器无论如何不可能被击倒，第二个容器在第一轮一定会被击倒，第三个容器第一轮一定不被击倒，第二轮一定被击倒。

第二组样例的真实答案为 $\frac{1}{2}$，$\frac{1}{2}$，$2$。

---

#### 数据范围

对于所有测试点，保证 $1 \leq n \leq 50$，$1 \leq a_i \leq n$，$a_i$ 两两不同。

$\text{Subtask 1 (2 pts)}$ $n \leq 2$。

$\text{Subtask 2 (23 pts)}$ $n \leq 6$。

$\text{Subtask 3 (31 pts)}$ $n \leq 18$。

$\text{Subtask 4 (19 pts)}​$ $a_i = i$。

$\text{Subtask 5 (25 pts)}$ 无特殊限制。

---

#### 提示

如果你不知道怎么对分数取模，可以参考[这里](https://www.luogu.com.cn/problem/P3811)。

## 样例 #1

### 输入

```
3
3 1 2```

### 输出

```
2 0 1```

## 样例 #2

### 输入

```
3
1 2 3```

### 输出

```
499122177 499122177 2```

## 样例 #3

### 输入

```
5
1 4 2 3 5```

### 输出

```
499122178 249561091 665496236 582309207 4```

# 题解

## 作者：dengyaotriangle (赞：24)

**显然，这题可以线性！**

考虑一个点存活时间的期望 $\mathbf E[t_i]$，我们根据一个众所周知的公式有

$$\mathbf E[t_i]=\sum_{x\geq 1}\mathbf P[t_i\geq x]$$

而我们看 $\mathbf P[t_i\geq x]$，这相当于操作 $x$ 轮，没有把 $i$ 和一个比它大的数合并的概率。

显然，我们只需要考虑 $i$ 左右两边第一个比它大的数，这个可以用单调栈 $O(n)$ 求出，我们设它们距离 $i$ 分别是 $a,b$

那么，我们操作 $x$ 轮，一共有 $x!\binom{n-1}{x}$ 种方案，原因就是考虑把合并操作看成两部分，对于排列的 $n-1$ 个空隙，枚举它们有没有被合并在一起，就是 $\binom{n-1}{x}$ 种，然后这 $x$ 种顺序任意，就是 $x!$

考虑其中合法（即没有把 $i$ 合并掉）的方案有几种，我们可以把这 $n-1$ 个空隙分成 3 部分：位于它与它的左边的第一个比它大之间的，共 $a$ 个，位于它与它右边第一个比它大之间的，共 $b$ 个，其它的，$n-1-a-b$ 个。

我们发现，$a,b$ 两部分如果取完了，那么就代表着 $i$ 与比它大的合并了。而若没全取完，则 $i$ 肯定还活着。

所以合法的方案数是

$$x!\sum_{i+j+k=x,i\neq a,j\neq b}\binom{a}{i}\binom{b}{j}\binom{n-1-a-b}{k}$$

~~当然，由于这题数据范围小，直接用这个式子甚至都能过~~，我们继续化简

上式显然等于

$$x![t^x]((1+t)^a-t^a)((1+t)^b-t^b)(1+t)^{n-1-a-b}$$

拆开之后，易得，

$$x!\left(\binom{n-1}{x}-\binom{n-1-a}{x-a}-\binom{n-1-b}{x-b}+\binom{n-1-a-b}{x-a-b}\right)$$

~~（或者你用容斥原理也可以推出来上式，但是生成函数多方便）~~

那么 $\mathbf P[t_i\geq x]$ 就是


$$\frac{x!\left(\binom{n-1}{x}-\binom{n-1-a}{x-a}-\binom{n-1-b}{x-b}+\binom{n-1-a-b}{x-a-b}\right)}{x!\binom{n-1}{x}}$$

至此，这个问题可以 $O(n^2)$，但是我们还需要继续。

因为 $\mathbf E[t_i]=\sum_{x\geq 1}\mathbf P[t_i\geq x]$，所以我们求和

$$\mathbf E[t_i]=\sum_{x\geq 1}\frac{\binom{n-1}{x}-\binom{n-1-a}{x-a}-\binom{n-1-b}{x-b}+\binom{n-1-a-b}{x-a-b}}{\binom{n-1}{x}}$$

我们发现这个和式是由4项形如

$$\sum_{x=1}^{n-1}\frac{\binom{n-1-i}{x-i}}{\binom{n-1}{x}}$$

的东西组成的，而我们化简这个东西

$$
\begin{aligned}

&\sum_{x=1}^{n-1}\frac{\binom{n-1-i}{x-i}}{\binom{n-1}{x}}\\
=&\sum_{x=1}^{n-1}\frac{(n-1-i)!x!}{(x-i)!(n-1)!}\\
=&\frac1{(n-1)^{\underline{i}}} \sum_{x=1}^{n-1}x^{\underline{i}}\\
=&\frac1{(n-1)^{\underline{i}}} \frac{n^{\underline{i+1}}}{i+1}\\
=&\frac{n}{i+1}\\
\end{aligned}
$$

注意上面的东西在 $i=0$ 的时候不成立（因为那个和式化不开），若 $i=0$ 上式显然每一项等于 $1$，就是 $n-1$，而不是 $n$

显然，我们可以线性预处理逆元求出这个式子，那么 $\mathbf E[t_i]$ 也可以 $O(1)$ 求了。

所以总时间复杂度 $O(n)$，注意若左右两边第一个比它大的数不存在需要稍微修改一下式子，也是类似的，就不推了。

```cpp
#include<bits/stdc++.h>
using namespace std;
//dengyaotriangle!

const int maxn=55;
const int mdn=998244353;

int n;
int a[maxn];
int prv[maxn],nxt[maxn];
int inv[maxn];
int ans[maxn];

int main(){
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    cin>>n;
    inv[1]=1;for(int i=2;i<=n;i++)inv[i]=inv[mdn%i]*(long long)(mdn-mdn/i)%mdn;
    for(int i=0;i<n;i++)ans[i]=n*(long long)inv[i+1]%mdn;
    for(int i=1;i<=n;i++)cin>>a[i];
    stack<pair<int,int>> stk1,stk2;
    for(int i=1;i<=n;i++)nxt[i]=n+1,prv[i]=0;
    for(int i=1;i<=n;i++){
        while(!stk1.empty()&&stk1.top().first<a[i]){nxt[stk1.top().second]=i;stk1.pop();}
        stk1.push(make_pair(a[i],i));
    }
    for(int i=n;i>=1;i--){
        while(!stk2.empty()&&stk2.top().first<a[i]){prv[stk2.top().second]=i;stk2.pop();}
        stk2.push(make_pair(a[i],i));
    }
    for(int i=1;i<=n;i++){
        vector<int> dis;
        if(prv[i]!=0)dis.push_back(i-prv[i]);
        if(nxt[i]!=n+1)dis.push_back(nxt[i]-i);
        if(dis.empty())cout<<n-1<<' ';
        else if(dis.size()==1){
            int a=dis[0];
            int w=(n-1ll-ans[a]+mdn)%mdn;
            cout<<w<<' ';
        }else{
            int a=dis[0],b=dis[1];
            int w=(n-1ll+mdn*2-ans[a]-ans[b]+ans[a+b])%mdn;
            cout<<w<<' ';
        }
    }
    return 0;
}
```

---

## 作者：K_256 (赞：21)

~~显然，~~ 我们可以把每个容器的期望转化成下面这个柿子：

$$E = \sum_{i = 1} ^ {n - 1}P(i \leq x) $$

其中 $P(i \leq x)$ 表示容器存活轮数大于等于 $i$ 的概率（即第 $i$ 轮后仍存活的概率）

现在考虑如何计算 $P(i \leq x)$

（如果有的话）记在容器 $c$ 前第一个比 $a_c$ 大的容器为 $pre$ ，在 $c$ 后第一个比 $a_c$ 大的容器为 $next$

再来看题意，题目中的操作相当于对一条链随机选一条边进行收缩，可以发现 $c$ 是否存活只与 $pre \sim c$ 和 $c \sim next$ 这两段的边是否全部被选中有关，记 $P(A)$ 为 $pre \sim c$ 这一段全部被选的概率， $P(B)$ 表示 $c \sim next$ 这一段全部被选的概率， $P(AB)$ 表示 $pre \sim next$ 这一段全部被选的概率， $d_1 = c - pre$， $d_2 = next - c$ 于是得到

$$ \begin{aligned} P(i \leq x) &= 1 - P(A) - P(B) + P(AB) \\ &= 1 - \frac{\binom{n - 1 - d_1}{i - d_1}}{\binom{n-1}{i}} - \frac{\binom{n - 1 - d_2}{i - d_2}}{\binom{n-1}{i}} + \frac{\binom{n - 1 - d_1 - d_2}{i - d_1 - d_2}}{\binom{n-1}{i}} \end{aligned}$$

~~怎么感觉写得特别啰嗦~~

复杂度 $O(n^2)$

代码：

```cpp
#include<cstdio>
using namespace std;

typedef long long ll;

const ll mod = 998244353;
const int MAXN = 60;
int a[MAXN], ld[MAXN], rd[MAXN];
ll C[MAXN][MAXN];

inline ll fpow(ll a, ll b){

	ll res = 1;
	while (b){

		if (b & 1)
			res = res * a % mod;
		a = a * a % mod, b >>= 1; 
	}
	return res;
}

inline ll inv(ll a){return fpow(a, mod - 2);}

int main(){
	int N;
	scanf("%d", &N);
	for (int i = 1; i <= N; ++i)
		scanf("%d", &a[i]);
	for (int i = 1; i <= N; ++i){
		for (int j = i - 1; j >= 1; --j)
			if (a[j] > a[i]){
				ld[i] = i - j;
				break;

			}
		for (int j = i + 1; j <= N; ++j)
			if (a[j] > a[i]){
				rd[i] = j - i;
				break;
			}
	}
	C[0][0] = 1;
	for (int i = 1; i <= N; ++i){
		C[i][0] = 1;
		for (int j = 1; j <= i; ++j)
			C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;
	}
	ll tmp, pa, pb, pab;
	for (int i = 1; i <= N; ++i){
		tmp = 0;
		for (int j = 1; j < N; ++j){
			pa = pb = pab = 0;
			if (ld[i] && j - ld[i] >= 0)
				pa = C[N - 1 - ld[i]][j - ld[i]] * inv(C[N - 1][j]) % mod;
			if (rd[i] && j - rd[i] >= 0)
				pb = C[N - 1 - rd[i]][j - rd[i]] * inv(C[N - 1][j]) % mod;
			if (ld[i] && rd[i] && j - ld[i] - rd[i] >= 0)
				pab = C[N - 1 - ld[i] - rd[i]][j - ld[i] - rd[i]] * inv(C[N - 1][j]) % mod;
			tmp = (tmp + 1 + mod - pa + mod - pb + pab) % mod;
		}
		printf("%lld ", tmp);
	}
	return 0;
}
```


---

## 作者：LanrTabe (赞：15)

题目链接：[Luogu P6059](https://www.luogu.com.cn/problem/P6059)

[My Blog](https://www.cnblogs.com/LanrTabe/p/12259391.html)

我傻了，比赛时写错了一个小细节，一看$n\le 50$还以为想假了

先把最大的$a_i$特判掉，答案显然为$n-1$。

我们枚举每一个$a_i$分别计算答案，找到左右距$a_i$最近且大于$a_i$的$a_l,a_r$，那么$a_i$被击倒只有$[l,i]$或者$[i,r]$间的容器全部进行决斗。

（若$a_l$和$a_r$在此之前和其他容器决斗只可能不变或变得更大）

枚举$a_i$在第$j$轮被淘汰，设概率为$p_{i,j}$，则$a_i$的期望存活轮数为$\sum_{1\le j<n}\limits p_{i,j}*(j-1)$

考虑怎么求$p_{i,j}$，设$g_{i,j}$表示$a_i$在**前**$j$**轮**的某一次被淘汰的概率，则$p_{i,j}=g_{i,j}-g_{i,j-1}$

因为一共进行了$n-1$次决斗，设$Calc(i,j)$表示在这$n-1$轮决斗中选出$i$轮决斗全部在前$j$轮的概率

那么对于$g_{i,j}$，要么被左边淘汰，要么被右边淘汰，容斥一下则

$g_{i,j}=Calc(i-l,j)+Calc(r-i,j)-Calc(r-l,j)$

（被左边淘汰的概率+被右边淘汰的概率-去掉两边决斗全部在前$j$场的重复计算）

当然如果某一边没有比$a_i$大的容器那答案就是$Calc(i-l,j)$或者$Calc(r-i,j)$

考虑计算$Calc(i,j)$。$i$场在前$j$场的方案数：$A_j^i=\frac{j!}{(j-i)!}$，其他决斗的方案数：$(n-1-i)!$，总方案数：$(n-1)!$

则$Calc(i,j)=\frac{j!(n-1-i)!}{(j-i)!(n-1)!}$

预处理阶乘及逆元，暴力计算即可做到$O(n^2)$，不知道能不能继续优化，~~反正O(n^2)足够了~~

时间复杂度 $O(n^2)$

空间复杂度 $O(n)$

### 代码：

```cpp
#include <cstdio>
typedef long long ll;

const int N=55,P=998244353;
int n,a[N],Fac[N],Inv[N],Ans[N];

ll Pow(ll a,int b,ll s=1){for(;b;b>>=1,a=a*a%P)if(b&1)s=s*a%P;return s;}

inline int Calc(int x,int l)//x场全部在前l场的概率
{
    if(x>l)return 0;
    return (ll)Fac[l]*Inv[l-x]%P*Fac[n-1-x]%P*Inv[n-1]%P;
}

int main()
{
    scanf("%d",&n);
    for(int i=Fac[0]=1;i<=n;++i)Fac[i]=(ll)Fac[i-1]*i%P;
    Inv[n]=Pow(Fac[n],P-2);
    for(int i=n;i>=1;--i)Inv[i-1]=(ll)Inv[i]*i%P;
    for(int i=1;i<=n;++i)scanf("%d",&a[i]);
    for(int i=1;i<=n;++i)
    {
        int l=i-1,r=i+1;
        while(l>=1&&a[l]<a[i])--l;
        while(r<=n&&a[r]<a[i])++r;
        if(l<1&&r>n){Ans[i]=n-1;continue;}
        int Res=0,Pp=0;
        for(int j=1;j<n;++j)
        {
            int Np=0;
            if(l>=1)Np=Calc(i-l,j);
            if(r<=n)Np=(Np+Calc(r-i,j))%P;
            if(l>=1&&r<=n)Np=(Np-Calc(r-l,j)+P)%P;//容斥
            Res=(Res+ll(j-1)*(Np-Pp+P))%P,Pp=Np;//这里没有p和g数组，Np代表g_{i,j}，Pp代表g_{i,j-1}
        }
        Ans[i]=Res;
    }
    for(int i=1;i<=n;++i)printf("%d%c",Ans[i],i==n?'\n':' ');
    return 0;
}
```

---

## 作者：寒鸽儿 (赞：6)

### P6046 纯粹容器

#### 思路

对容器 $i$ , 记其右边第一个强度大于它的容器编号为 $r_i$ , 左边第一个强度大于它的容器编号为 $l_i$ 。  

先假定 $l_i$ 和 $r_i$ 均存在。  

容器 $i$ 被淘汰的充要条件是 $i$ 向左合并到 $l_i$ 被淘汰或者 $k$ 向右合i并到 $r_k$ 被淘汰 , 或者 $l_k$ 和 $r_k$ 被合并 , 由取代它们的容器并掉 $i$ 。因此 , $i$ 的淘汰只与 $l_i$ ~ $r_i$ 之间的容器的合并有关。

对于向右合并 , 假设进行了 $k$ 次合并 。记随机变量 $X$ 为存活的轮数。容器 $i$ 淘汰的概率
$$
P_{r}(X < k) = \frac{\binom{n - (r_i - i)}{k-(r_i - i)}}{\binom{n}{k}}
$$
同理 , 向左合并 $i$ 已经淘汰的概率为
$$
P_{l}(X < k) = \frac{\binom{n - (i - l_i)}{k-(i - l_i)}}{\binom{n}{k}}
$$
在 $k$ 轮后$l_i$ ~ $i$ ~ $r_i$ 均已合并的概率为
$$
P_{l,r}(X < k) = \frac{\binom{n - (r_i - l_i)}{k-(r_i - l_i)}}{\binom{n}{k}}
$$
由容斥原理 $k$ 轮后容器 $i$ 已经淘汰的概率为
$$
P(X < k) = P_l(X < k) + P_r(X < k) - P_{l,r}(X < k)
$$
则存活 $k$ 轮的概率为  
$$
P(X \geqslant k) = 1 - P(X < k)
$$
存活轮数的期望为  
$$
E(x) = \sum_k kP(x = k)
= \sum_k P(x \geqslant k)
= \sum_k 1 - \frac{\binom{n - (r_i - i)}{k-(r_i - i)}}{\binom{n}{k}} - \frac{\binom{n - (i - l_i)}{k-(i - l_i)}}{\binom{n}{k}} + \frac{\binom{n - (r_i - l_i)}{k-(r_i - l_i)}}{\binom{n}{k}}
$$
(第二步是因为乘下标单次递增1 , 而 $P(x \geqslant k)$ 又是 $P(x=k)$ 的后缀和)  

对于 $l_i$ 和 $r_i$ 中一者不存在的情况直接用存在的一者作为概率。

两者均不存在说明为强度最大的容器 , 必有 :   
$$
E(X) = n - 1
$$
然后随便怎么求一下组合数和逆元就好了。  

#### 事项  

1. 小心爆精度。

#### code

```CPP
#include <bits/stdc++.h>
#define endl '\n'

using namespace std;

typedef long long ll;

const int maxn = 100, p = 998244353;
int a[maxn], rnk[maxn], n;
ll fac[maxn];

ll inv(ll a) {
	ll res = 1 % p;
	ll b = p - 2;
	for(; b; b >>= 1) {
		if(b & 1) res = res * a % p;
		a = a * a % p;
	}
	return res;
}

ll C(int n, int m) {
	if(n < m) return 0;
	if(n == m) return 1;
	return (fac[n] * inv(fac[n - m]) % p) * inv(fac[m]) % p;
}

ll P(int k, int t) {
	if(k < t) return 0;
	if(k == t) return inv(C(n - 1, t));
	return C(n - 1 - t, k - t) * inv(C(n - 1, k)) % p;
}

ll solve(int cur) {
	int l = cur - 1, r = cur + 1;
	while(l > 0 && a[l] < a[cur]) --l;
	while(r <= n && a[r] < a[cur]) ++r;
	if(l == 0 && r == n + 1) return n - 1;
	ll ans = 0;
	for(int k = 1; k < n; ++k) {
		ll ans1 = 0, ans2 = 0, ans3 = 0;
		if(l > 0) ans1 = P(k, cur - l);
		if(r <= n) ans2 = P(k, r - cur);
		if(l > 0 && r <= n) ans3 = P(k, r - l);	
		ans += 1 - ans1 - ans2 + ans3;
	}
	return (ans % p + p) % p;
}

int main() {
	cin >> n;
	fac[1] = 1;
	for(int i = 2; i <= 60; ++i) fac[i] = fac[i - 1] * i % p;
	for(int i = 1; i <= n; ++i)
		cin >> a[i];
	for(int i = 1; i <= n; ++i)
		cout << solve(i) << ' ';
	cout << endl;
	return 0;
}
```







---

## 作者：ZCETHAN (赞：2)

## 废话

小数据范围就会有废物拿无脑递推乱草。

## Solution

考虑每一个容器存活的时间只和它离它最近的比它大的容器的距离相关，所以令 $dp_{l,r,m}$ 表示如果某一个容器距离它左边最近的比它大的容器距离是 $l+1$，右边是 $r+1$，而不在两个左右端点内的总共可以多消除 $m$ 次的期望存活时间。

```
...L...i...R...
___         ___ ->m
    ___         ->l
        ___     ->r
```

这样转移也很显然，你枚举当前这次决斗是在当前点的 $[L,i]$ 还是 $[i,R]$，或者是除此以外的容器决斗。

同时，有的容器在左边或右边没有比它大的，所以需要再维护一个差不多的东西，表示如果只有一边会有可能打败它的期望，转移类似。

然后用单调栈维护 $L,R$，最后直接输出就行了。

## Code

```cpp
#include<bits/stdc++.h>
#define ll long long
#define inf (1<<30)
#define INF (1ll<<60)
#define pb emplace_back
#define pii pair<int,int>
#define mkp make_pair
#define fi first
#define se second
#define all(a) a.begin(),a.end()
#define siz(a) (int)a.size()
#define clr(a) memset(a,0,sizeof(a))
#define rep(i,j,k) for(int i=(j);i<=(k);i++)
#define per(i,j,k) for(int i=(j);i>=(k);i--)
#define pt(a) cerr<<#a<<'='<<a<<' '
#define pts(a) cerr<<#a<<'='<<a<<'\n'
#define int long long
using namespace std;
const int MOD=998244353;
int ksm(int a,int p){
	int ret=1;while(p){
		if(p&1) ret=ret*a%MOD;
		a=a*a%MOD; p>>=1;
	}return ret;
}
int inv(int x){return ksm(x,MOD-2);}
int dp[55][55][55],a[55],bd[55][55];
int L[55],R[55],stk[55];
signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	int n;cin>>n;
	rep(i,1,n) cin>>a[i];
	dp[0][0][0]=0;//显然如果没有一个位置有剩余，那么当前这个点必然下一刻被打败
	rep(l,0,n) rep(r,0,n) rep(m,0,n){
		if(l+r+m==0) continue;
		if(l) (dp[l][r][m]+=(dp[l-1][r][m]+1)*(l+1)%MOD*inv(l+1+r+1+m)%MOD)%=MOD;
		if(r) (dp[l][r][m]+=(dp[l][r-1][m]+1)*(r+1)%MOD*inv(l+1+r+1+m)%MOD)%=MOD;
		if(m) (dp[l][r][m]+=(dp[l][r][m-1]+1)*m%MOD*inv(l+1+r+1+m)%MOD)%=MOD;
	}
	bd[0][0]=0;
	rep(i,0,n) rep(j,0,n){
		if(i+j==0) continue;
		if(i) (bd[i][j]+=(bd[i-1][j]+1)*(i+1)%MOD*inv(i+1+j)%MOD)%=MOD;
		if(j) (bd[i][j]+=(bd[i][j-1]+1)*j%MOD*inv(i+1+j)%MOD)%=MOD;
	}
	int top=0;
	rep(i,1,n){
		while(top&&a[stk[top]]<a[i]) top--;
		if(!top) L[i]=-1;
		else L[i]=stk[top];
		stk[++top]=i;
	}
	top=0;
	per(i,n,1){
		while(top&&a[stk[top]]<a[i]) top--;
		if(!top) R[i]=-1;
		else R[i]=stk[top];
		stk[++top]=i;
	}
	rep(i,1,n){
		if(L[i]==-1&&R[i]==-1) cout<<n-1<<' ';
		else if(L[i]==-1) cout<<bd[R[i]-i-1][n-1-R[i]+i]<<' ';
		else if(R[i]==-1) cout<<bd[i-L[i]-1][n-1-i+L[i]]<<' ';
		else cout<<dp[R[i]-i-1][i-L[i]-1][n-1-R[i]+L[i]]<<' ';
	}
	return 0;
}
```

---

## 作者：Super_Cube (赞：1)

# Solution

对于每个容器 $i$，枚举其能活的轮数 $j$，计算它活下来的轮数不小于 $j$ 的期望，加在一起就是 $i$ 的答案。

从 $i$ 开始往左找到第一个大于 $a_i$ 的位置记为 $l$，往右找到第一个大于 $a_i$ 的位置记为 $r$。首先到第 $j$ 轮时总共有 $\displaystyle\binom{n-1}{j}$ 种决斗方案，如果 $i$ 被 $l$ 淘汰需要让 $[l,i]$ 中所有容器先进行决斗，方案数为 $\displaystyle\binom{n-1-(i-l)}{j-(i-l)}$；被 $r$ 淘汰掉同理，有 $\displaystyle\binom{n-1-(r-i)}{j-(r-i)}$；还要容斥掉 $[l,r]$ 中所有容器都决斗过的情况，为 $\displaystyle\binom{n-1-(r-l)}{j-(r-l)}$。

所以 $i$ 的答案为：$\displaystyle\sum_{j=1}^{n-1}1-\dfrac{\binom{n-1-(i-l)}{j-(i-l)}+\binom{n-1-(r-i)}{j-(r-i)}-\binom{n-1-(r-l)}{j-(r-l)}}{\binom{n-1}{j}}$。

---

## 作者：_Cheems (赞：1)

数据才 $n\le 50$，就肯定有小彩笔暴力乱搞。

比如我。

唯一难点是转化。将其视作一条链，每次选一条边。单调栈求出左边、右边第一个 $\ge a_i$ 的 $lst_i,nxt_i$。那么 $i$ 不被淘汰，等价于 $lst_i\to i$ 这条链的边不被全选，并且 $i\to nxt_i$ 也不被全选。

然后钦定两条链其中一条被全选，设它有 $x$ 条边并被全选，另一条链有 $Y$ 条边选 $y$ 条，链外选了 $k$ 条。 

那么这样选的方案数 $res$ 为：

$$res=C(Y,y)C(n-1-x-Y,k)\times x(x+y+k-1)!$$

解释下这个式子。第一部分表示选边（不考虑顺序）；第二部分表示拎出一条边作为最后被选的，并确定其它边的选择顺序。

那么对答案贡献就是：$(x+y+k-1)\times \frac{res}{A(n-1,x+y+k)}$。

然后枚举即可。复杂度 $O(n^3)$。
#### 代码
勤取模。
```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long
const int N = 1e2 + 5, mod = 998244353;
int n, a[N], st[N], tp, pre[N], nxt[N], jc[N], jcinv[N];

inline int qstp(int a, int k) {int res = 1; for(; k; a = a * a % mod, k >>= 1) if(k & 1) res = res * a % mod; return res;}
inline void init() {jc[0] = jcinv[0] = 1; for(int i = 1; i < N; ++i) jcinv[i] = qstp(jc[i] = jc[i - 1] * i % mod, mod - 2);}
inline int C(int n, int m) {return n < m ? 0 : jc[n] * jcinv[n - m] % mod * jcinv[m] % mod;}
inline int A(int n, int m) {return n < m ? 0 : jc[n] * jcinv[n - m] % mod;}
signed main(){
	init();
	cin >> n;
	for(int i = 1; i <= n; ++i){
		scanf("%lld", &a[i]);
		while(tp && a[st[tp]] <= a[i]) --tp;
		pre[i] = st[tp], st[++tp] = i;
	}
	tp = 0;
	for(int i = n; i; --i){
		while(tp && a[st[tp]] <= a[i]) --tp;
		nxt[i] = st[tp], st[++tp] = i;
	}
	for(int i = 1; i <= n; ++i){
		if(!pre[i] && !nxt[i]) {printf("%lld ", n - 1); continue;}
		if(!pre[i]) pre[i] = i; if(!nxt[i]) nxt[i] = i;   
		int res, ress = 0, c1 = i - pre[i], c2 = nxt[i] - i;
		if(c1)
			for(int j1 = c1; j1 <= c1; ++j1)
				for(int j2 = 0; j2 <= max(0ll, c2 - 1); ++j2)
					for(int k = 0; j1 + j2 + k <= n - 1; ++k){
						res = C(c2, j2) * C(n - 1 - c1 - c2, k) % mod * j1 % mod * jc[j1 + j2 + k - 1] % mod; 
						ress = (ress + (j1 + j2 + k - 1) * res % mod * qstp(A(n - 1, j1 + j2 + k), mod - 2) % mod) % mod;
					}
		if(c2)
			for(int j1 = 0; j1 <= max(0ll, c1 - 1); ++j1)
				for(int j2 = c2; j2 <= c2; ++j2)
					for(int k = 0; j1 + j2 + k <= n - 1; ++k){
						res = C(c1, j1) * C(n - 1 - c1 - c2, k) % mod * j2 % mod * jc[j1 + j2 + k - 1] % mod;
						ress = (ress + (j1 + j2 + k - 1) * res % mod * qstp(A(n - 1, j1 + j2 + k), mod - 2) % mod) % mod;
					}
		printf("%lld ", ress);
	}
	return 0;
}
```

---

## 作者：Mini_PEKKA (赞：1)

## Solution

设容器 $i$ 左边第一个比它强的容器为 $l_i$，右边第一个比它强的容器为 $r_i$，用单调栈维护即可。

设 $f_{i,j,k}$ 为总共 $i$ 个容器，当一个容器 $x$ 满足 $x - l_x - 1 = j$，$r_x - x - 1=k$ 时的期望存活轮数。

$$f_{i,j,k}=\frac{j + 1}{i - 1}\times (f_{i - 1,j - 1,k} + 1) + \frac{k + 1}{i - 1} \times (f_{i - 1, j, k - 1} + 1) + \frac{i - 1 - (j + 1) - (k + 1)}{i - 1} \times (f_{i - 1, j, k} + 1)$$

如果一个容器左边没有比它强的容器（右边同理），设 $g_{i, j}$ 为总共 $i$ 个容器，当一个容器 $x$ 满足 $x - l_x - 1=j$ 时的期望存活轮数。

$$g_{i,j} = \frac{j + 1}{i - 1} \times (g_{i - 1, j - 1} + 1) + \frac{i - 1 - (j + 1)}{i - 1} \times (g_{i - 1, j} + 1)$$

如果一个容器左右两边没有比它强的容器，直接输出 $n-1$。
## Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 55, MOD = 998244353;
int a[N], l[N], r[N], inv[N], f[N][N][N], g[N][N];
signed main() {
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++)
		cin >> a[i];
	stack<int> stk;
	for (int i = 1; i <= n; i++) {
		while (!stk.empty() && a[stk.top()] < a[i])
			stk.pop();
		if (!stk.empty())
			l[i] = stk.top();
		stk.push(i);
	}
	while (!stk.empty())
		stk.pop();
	for (int i = n; i >= 1; i--) {
		while (!stk.empty() && a[stk.top()] < a[i])
			stk.pop();
		if (!stk.empty())
			r[i] = stk.top();
		stk.push(i);
	}
	inv[1] = 1;
	for (int i = 2; i <= n; i++)
		inv[i] = (MOD - MOD / i)*inv[MOD%i] % MOD;
	for (int i = 3; i <= n; i++) {
		int sum = 0;
		for (int j = 0; j <= i - 3; j++)
			sum = (sum + j*(i - j - 2)) % MOD;
		f[i][0][0] = 2 * sum*inv[i - 1] % MOD* inv[i - 2] % MOD;
	}
	for (int i = 4; i <= n; i++) {
		for (int j = 1; j <= i - 3; j++)
			f[i][j][0] = ((j + 1)*(f[i - 1][j - 1][0] + 1) % MOD + (i - j - 3)*(f[i - 1][j][0] + 1) % MOD)*inv[i - 1] % MOD;
		for (int j = 1; j <= i - 3; j++)
			f[i][0][j] = ((j + 1)*(f[i - 1][0][j - 1] + 1) % MOD + (i - j - 3)*(f[i - 1][0][j] + 1) % MOD)*inv[i - 1] % MOD;
	}
	for (int i = 5; i <= n; i++)
		for (int j = 1; j <= i - 4; j++)
			for (int k = 1; k <= i - j - 3; k++)
				f[i][j][k] = (((j + 1)*f[i - 1][j - 1][k] % MOD + (k + 1)*f[i - 1][j][k - 1] % MOD + (i - j - k - 3)*f[i - 1][j][k] % MOD)*inv[i - 1] + 1) % MOD;
	for (int i = 2; i <= n; i++)
		g[i][0] = (i - 1)*(i - 2) / 2 * inv[i - 1] % MOD;
	for (int i = 3; i <= n; i++)
		for (int j = 1; j <= i - 2; j++)
			g[i][j] = (((j + 1)*g[i - 1][j - 1] % MOD + (i - j - 2)*g[i - 1][j] % MOD)*inv[i - 1] + 1) % MOD;
	for (int i = 1; i <= n; i++) {
		if (l[i] && r[i])
			cout << f[n][i - l[i] - 1][r[i] - i - 1] << ' ';
		if (l[i] && !r[i])
			cout << g[n][i - l[i] - 1] << ' ';
		if (!l[i] && r[i])
			cout << g[n][r[i] - i - 1] << ' ';
		if (!l[i] && !r[i])
			cout << n - 1 << ' ';
	}
	cout << endl;
	return 0;
}
```

---

## 作者：天梦 (赞：1)

# P6046 纯粹容器 数学期望

[链接](https://www.luogu.com.cn/problem/P6046)

其实如果把这个题看做数学题会比较好做一些。稍微分析一下就做出来了。

那么我们来看一下这道题。通常来说，关于概率期望我们先想 dp ，但这个题明显没有给我们一个好的设计状态的思路，我们考虑用数学的方法来做。

设 $f_j$ 为容器 $i$ 在第 $j$ 轮被干掉的概率。我们对所有的 $i$ 都求一个：
$$
E=\sum\limits_{i=1}^nf_i\times (i-1)
$$
就是答案。

我们考虑 $f_j$ 怎么求，直接求解是比较难的。这个时候我们通常考虑容斥。

设 $p_j$ 表示容器 $i$ 在前 $j$ 轮被干掉的概率是多少，那么根据容斥，我们有：
$$
f_j=p_j-p_{j-1}
$$
我们考虑如何求解 $p_j$。

我们记 $l$ 为容器 $i$ 左边第一个比它大的位置，$r$ 为容器 $i$ 右边第一个比它大的位置。

显然，如果容器 $i$ 被干掉，一定是 $l$ 到 $i$ 之间或是 $i$ 到 $r$ 之间的容器全部被干掉了。我们并不用管 $l$ 左边和 $r$ 右边，因为如果 $l$ 和 $r$ 被干掉一定是被比他大的容器干掉。

先算 $i$ 被左边在 $j$ 轮内被干掉的概率 ：
$$
g=\frac{\binom{n-1-(i-l)}{j-(i-l)}}{\binom{n-1}{j}}
$$
同理，我们可以算出它被右边干掉的概率：
$$
\frac{\binom{n-1-(r-i)}{j-(r-i)}}{\binom{n-1}{j}}
$$
这里我们把两边都过来的概率算重了，所以我们减去两边都过来的概率：
$$
\frac{\binom{n-1-(r-i)-(i-l)}{j-(r-i)-(i-l)}}{\binom{n-1}{j}}
$$
注意，我们需要判断上面的概率是否合法。

代码：

```c++
#include<bits/stdc++.h>
#define dd double
#define ld long double
#define ll long long
#define int long long
#define uint unsigned int
#define ull unsigned long long
#define N 51
#define M number
using namespace std;

const int INF=0x3f3f3f3f;
const ll mod=998244353;

template<typename T> inline void read(T &x) {
    x=0; int f=1;
    char c=getchar();
    for(;!isdigit(c);c=getchar()) if(c == '-') f=-f;
    for(;isdigit(c);c=getchar()) x=x*10+c-'0';
    x*=f;
}

int c[N][N];

inline void prework(){
    for(int i=0;i<=50;i++){
        for(int j=0;j<=i;j++){
            if(j==0||j==i) c[i][j]=1;
            else c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;
        }
    }
}

int n,a[N];

inline ll ksm(ll a,ll b,ll mod){
    ll res=1;
    while(b){
        if(b&1) (res*=a)%=mod;
        a=a*a%mod;
        b>>=1; 
    }
    return res;
}

inline ll inv(ll a,ll mod){
    return ksm(a,mod-2,mod);
}

ll ans,p[N];

signed main(){
    prework();
    read(n);for(int i=1;i<=n;i++) read(a[i]);
    for(int i=1;i<=n;i++){
        int l=i,r=i;
        for(int j=i-1;j>=1;j--) if(a[j]>a[l]){l=j;break;}
        for(int j=i+1;j<=n;j++) if(a[j]>a[r]){r=j;break;}
        if(r==i&&l==i) {printf("%lld ",n-1);continue;}
        for(int j=1;j<=n-1;j++){
            ll nowans=0,p1=0,p2=0,p3=0;
            if(l!=i&&j>=i-l) p1=c[n-1-(i-l)][j-(i-l)]*inv(c[n-1][j],mod)%mod;
            if(r!=i&&j>=r-i) p2=c[n-1-(r-i)][j-(r-i)]*inv(c[n-1][j],mod)%mod;
            if(l!=i&&r!=i&&j>=(i-l)+(r-i)) p3=c[n-1-(i-l)-(r-i)][j-(i-l)-(r-i)]*inv(c[n-1][j],mod)%mod;
            nowans=p1+p2-p3;p[j]=(nowans%mod+mod)%mod;
            ans+=(p[j]-p[j-1])*(j-1)%mod;ans=(ans%mod+mod)%mod;
        }
        printf("%lld ",ans);ans=0;
    }
    return 0;
}
```



---

## 作者：BlankAo (赞：1)

如果 $\LaTeX$ 崩了请见 [**链接**](https://www.cnblogs.com/BlankAo/p/15143924.html)。

### 题意

[链接](https://www.luogu.com.cn/problem/P6046)

有 $n$ 个物品排成一列，第 $i$ 个物品强度为 $a_i$。每一秒会随机选择两个**相邻**的物品相撞，强度较小的那个会破碎，被移除队列（即原本不相邻的物品可能会现在相邻）。求每个物品存活时间的期望。

### $O(n^2) $ 解法

设 $P(i=x)$ 为某物品存活时间等于 $i$ 的概率，则显然 $E=\sum\limits_{i=1}^{n-1}iP(i=x)$。

展开来就是 

$$
\begin{align}
E&=P(1=x)+2P(2=x)+3P(3=x)+...\\
&=(P(1=x)+P(2=x)+P(3=x)+...)+(P(2=x)+P(3=x)+...)+(P(3=x)+...)+...\\
&=P(1\le x)+P(2\le x)+P(3\le x)+...\\
&=\sum_{i=1}^{n-1}P(i\le x)
\end{align}
$$

级 $\large E=\sum_\limits{i=1}^{n-1}P(i\le x)$。

于是设 $pre$ 为在物品 $x$ 左边第一个强度比它大的物品， $nxt$ 为在物品 $x$ 右边第一个强度比它大的物品。则如果 $pre\sim x$ 一段物品或 $x\sim nxt$​ 一段物品全部被打碎，则这个物品就碎了。

设 $P(A)$ 为 $pre\sim x$ 全部破碎的概率， $P(B)$ 为 $x\sim nxt$ 全部破碎的概率。则 $P(A\and B)$ 为 $pre\sim nxt$ 全部破碎的概率。

则 $P(i\ge x)=P(A)+P(B)-P(A\and B)$。

设 $d_1=x-pre,d_2=nxt-x$，有 $P(i\le x)=1-P(A)-P(B)+P(A\and B)=1-\frac{\left(\begin{array}{c}
n-1-d_{1} \\
i-d_{1}
\end{array}\right)}{\left(\begin{array}{c}
n-1 \\
i
\end{array}\right)}-\frac{\left(\begin{array}{c}
n-1-d_{2} \\
i-d_{2}
\end{array}\right)}{\left(\begin{array}{c}
n-1 \\
i
\end{array}\right)}+\frac{\left(\begin{array}{c}
n-1-d_{1}-d_{2} \\
i-d_{1}-d_{2}
\end{array}\right)}{\left(\begin{array}{c}
n-1 \\
i
\end{array}\right)}$​ 

---

## 作者：day_dream (赞：1)

由于总情况数为$(n-1)!$，我们可以对于每个$i$算出它每种情况存活的总次数。

一个容器$i$在与他左右两边第一个点比它大的点打之前，它一定不会被淘汰，设这两个位置为$l,r$。我们可以无视$1\sim l$、$l+1\sim i-1$、$i+1\sim r-1$和$r\sim n$这些区间内容器的区别，将它们分为四类，$A$、$B$、$C$、$D$。

考虑这$i$与四类容器的战斗：1.$i$会输给$A$，因为$l$是左边第一个比$i$大的容器，所以能打败$l$的一定比$i$大($D$同理)；2.$i$会打赢第$B$、$C$。

计算每个容器在第$k$轮被淘汰的情况数。如果$i$在第$k$轮被淘汰了它一定是输给了$A$或$D$，我们讨论它输给了$A$($D$可以类比)。那么$i$与$B$的$i-l$场战斗都发生过，且第$k$轮$i$与$A$战斗，$i$不会与$D$战斗。所以前$k-1$轮除了$i$与$B$内部的战斗，还可能发生$A$内部、$C$内部和$D$内部的战斗。而$A$和$D$内部的战斗是等价的，所以我们枚举$C$内部的战斗发生了多少次，之后可以用组合数快速计算出方案(注意没有$C$时，方案是一个简单的组合数)。前$k-1$和后$n-1-k$轮战斗顺序对结果没有影响所以再乘上两个阶乘就是容器$i$在第$k$轮被淘汰的情况数。

总复杂度$O(n^3)$。具体细节可以参考代码。

```cpp
#include<algorithm>
#include<cstdio>
#include<set>
#define db double
#define mxn 300010
#define LL long long
#define pb push_back
#define pil pair<int,LL> 
#define pii pair<int,int> 
#define fr first
#define sc second
#define mp make_pair
using namespace std;
const int mod=998244353;
int n,P,sl,fh,sum,res,ans,a[60],lst[60],nxt[60],fac[60],C[60][60];
int rd()
{
	sl=0;fh=1;
	char ch=getchar();
	while(ch<'0'||'9'<ch) {if(ch=='-') fh=-1; ch=getchar();}
	while('0'<=ch&&ch<='9') sl=sl*10+ch-'0',ch=getchar();
	return sl*fh;
}
int _pow(int k,int i)
{
	int t=1;
	for(;i;i>>=1,k=1ll*k*k%mod)
		if(i&1)
			t=1ll*t*k%mod;
	return t;
}
int main()
{
	n=rd();C[0][0]=fac[0]=1;
	for(int i=1;i<=n;++i) a[i]=rd(),C[i][0]=C[i][i]=1,fac[i]=1ll*i*fac[i-1]%mod;
	P=_pow(fac[n-1],mod-2);
	for(int i=1;i<=n;++i)
		for(int j=1;j<n;++j)
		{
			C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;
			if(C[i][j]>=mod) C[i][j]-=mod;
		}
	for(int i=1;i<=n;++i)
	{
		nxt[i]=n+1;
		for(int j=n;j>i;--j)
			if(a[j]>a[i])
				nxt[i]=j;
		for(int j=1;j<i;++j)
			if(a[j]>a[i])
				lst[i]=j;
	}
	int x,y,z;
	for(int i=1;i<=n;++i)
	{
		ans=0;
		for(int j=2;j<n;++j)
		{
			res=0;
			if(lst[i]&&i-lst[i]<=j)
			{
				sum=0;x=i-lst[i];
				if(nxt[i]<=n)
				{
					y=lst[i]-1+n-nxt[i];z=nxt[i]-i;
					for(int k=0;k<=j-x&&k<z;++k) sum=(sum+1ll*C[z][k]*C[y][j-x-k])%mod;
					res=(res+1ll*x*sum%mod*fac[j-1]%mod*fac[n-j-1])%mod;
				}
				else y=lst[i]-1+n-i,res=(res+1ll*x*C[y][j-x]%mod*fac[j-1]%mod*fac[n-j-1])%mod;
			}
			if(nxt[i]<=n&&nxt[i]-i<=j)
			{
				sum=0;x=nxt[i]-i;
				if(lst[i])
				{
					y=lst[i]-1+n-nxt[i];z=i-lst[i];
					for(int k=0;k<=j-x&&k<z;++k) sum=(sum+1ll*C[z][k]*C[y][j-x-k])%mod;
					res=(res+1ll*x*sum%mod*fac[j-1]%mod*fac[n-j-1])%mod;
				}
				else y=i-1+n-nxt[i],res=(res+1ll*x*C[y][j-x]%mod*fac[j-1]%mod*fac[n-j-1])%mod;
			}
			ans=(ans+1ll*(j-1)*res)%mod;
		}
		if(a[i]!=n) printf("%lld ",1ll*P*ans%mod);
		else printf("%d ",n-1);
	}
	puts("");
	return 0;
}
```


---

## 作者：Φρανκ (赞：0)

题意：每轮从长度为 $n$ 的序列中选取两个相邻数并移除较小者，求每个数存在轮数的期望。

核心思想：递推

解：

容易发现，数具体的值并不重要，只有数之间的大小关系重要。可令 $f(i,j,k)$ 表示在 $i$ 个数的序列中一个数存在轮数的期望值，且这个数满足左侧第 $j$ 个数和右侧第 $k$ 个数首先大于之。特别的，令 $0$ 表示该侧没有大于它的数字。

因此，对于所有情况，可以将数列分为几段：选取这个数本身到第一个大于它的数之间的一个移除会将这个方向上的距离减少 $1$，否则不减少。注意 $j,k$ 中含有 $0$ 的情况需要特判，含 $1$ 的作为边界条件也需特判，其余递推即可。注意有理数取模需要预处理 $1\sim 50$ 关于模数的逆元。

代码：
```
#include <bits/stdc++.h>
using namespace std;
const long long mod=998244353;
long long n, a[51], l[51], r[51], b[51][51][51], inv[51]; 
int main()
{
	cin>>n;
	for(int i=1; i<=n; i++)
		cin>>a[i];
	for(int i=1; i<=n; i++)
	{
		for(int j=i-1; j>=1; j--)
			if(a[j]>a[i])
			{
				l[i]=i-j;
				break;
			}
		for(int j=i+1; j<=n; j++)
			if(a[j]>=a[i])
			{
				r[i]=j-i;
				break;
			}
	}//求算距离
	inv[1]=1;
	for(int i=2; i<=50; i++)
		inv[i]=(mod-mod/i)*inv[mod%i]%mod;//求算逆元
	for(int i=1; i<=n; i++)
		b[i][0][0]=i-1;
	for(int i=3; i<=n; i++)
	{
		b[i][1][0]=(1+b[i-1][1][0])*(i-2)%mod*inv[i-1]%mod;
		b[i][0][1]=b[i][1][0];
	}
	for(int i=3; i<=n; i++)
		for(int j=2; j<=i-1; j++)
		{
			b[i][j][0]=1+(b[i-1][j-1][0]*j%mod+b[i-1][j][0]*(i-j-1)%mod)%mod*inv[i-1]%mod;
			b[i][0][j]=b[i][j][0];
		}//特判0
	for(int i=4; i<=n; i++)
		b[i][1][1]=(1+b[i-1][1][1])*(i-3)%mod*inv[i-1]%mod;
	for(int i=4; i<=n; i++)
		for(int j=2; j<=i-2; j++)
		{ 
			b[i][j][1]=((1+b[i-1][j-1][1])*j%mod*inv[i-1]%mod+(1+b[i-1][j][1])*(i-j-2)%mod*inv[i-1]%mod)%mod;
			b[i][1][j]=b[i][j][1];
		}//特判1
	for(int i=5; i<=n; i++)
		for(int j=2; j<=i-3; j++)
			for(int k=2; k<=n-j-1; k++)
				b[i][j][k]=1+(b[i-1][j-1][k]*j%mod+b[i-1][j][k-1]*k%mod+b[i-1][j][k]*(i-j-k-1)%mod)%mod*inv[i-1]%mod;//递推
//	for(int i=1; i<=n; i++)
//		cout<<l[i]<<" ";
//	cout<<endl;
//	for(int i=1; i<=n; i++)
//		cout<<r[i]<<" ";
//	cout<<endl;
	for(int i=1; i<=n; i++)
		cout<<b[n][l[i]][r[i]]<<" ";//输出
	return 0;
}

```


---


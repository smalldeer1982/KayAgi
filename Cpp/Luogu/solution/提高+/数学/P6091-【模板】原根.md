# 【模板】原根

## 题目描述

给定整数 $n$，求它的所有原根。

为了减小你的输出量，给出输出参数 $d$，设 $n$ 的所有原根有 $c$ 个，从小到大分别为 $g_1,\ldots,g_c$，你只需要依次输出 $g_d,g_{2d},\ldots,g_{\lfloor\frac{c}{d}\rfloor\times d}$。

---

如果你不了解原根的定义，可以自行查找资料或阅读下列定义：

正整数 $g$ 是正整数 $n$ 的原根，当且仅当 $1\leq g\leq n-1$，且 $g$ 模 $n$ 的阶为 $\varphi(n)$。

## 说明/提示

【样例解释】

对于第 $1,2,4,6$ 组数据，给出的 $n$ 的所有原根都出现在输出中。

对于第 $3$ 组数据，$25$ 的原根集合为 $\{2,3,8,12,13,17,22,23\}$。

对于第 $5$ 组数据，$9$ 的原根集合为 $\{2,5\}$。

【数据范围】

对于 $100\%$ 的数据，$1\leq T\leq 10$，$2\leq n\leq 10^6$，$1\leq d\leq 200$，保证输出的数的总个数不超过 $10^5$。

## 样例 #1

### 输入

```
6
2 1
4 1
25 2
36 1
9 6
18 1
```

### 输出

```
1
1 
1
3 
8
3 12 17 23 
0

2

2
5 11 
```

# 题解

## 作者：codecode (赞：240)

#### 前言

upd(**2021.02.13**)：更改了所有已知错误与笔误；对一些评论有异议的地方增添了补充说明；更改了部分用词并修正了一些内容；修正了部分错误的 LaTeX。

另外，codecode 早已退役~~转战数竞~~，这次更新可能是对本博客的最后一次更新，但仍欢迎您反馈发现的问题/不懂的表述等~~说不定还会回来呢~~。

upd(**2020.04.06**)：更新了部分用词；修正了部分 LaTeX 错误；添加了部分内容。


----------


楼下的大佬已经给出了正解，这里只是整理一下并帮他们补充完整证明。

作为数竞生，对于这种问题就想要给出一个完整的证明。（其实作为 OIer，只需要知道结论就可以了，不一定需要知道证明。（雾））

证明比较复杂，可能需要阅读并理解较长时间；如果不想看证明，可以跳到最后看结论。


### 证明过程

前置：费马定理，欧拉定理，拉格朗日定理。

这里只给出拉格朗日定理的证明。

>> **前置 拉格朗日定理**：设 $p$ 为素数，对于模 $p$ 意义下的整系数多项式
>>
>> $$f(x)=a_nx^n+a_{n-1}x^{n-1}+\cdots+a_0\;(p\nmid a_n)$$
>>
>> 的同余方程 $f(x)\equiv 0\pmod p$ 在模 $p$ 意义下至多有 $n$ 个不同解。
>
> **证明**：对 $n$ 使用归纳法。当 $n=0$ 时，由于 $p\nmid a_0$，故 $f(x)\equiv 0\pmod p$ 无解，定理对 $n=0$ 的多项式 $f(x)$ 都成立。
>
> 若命题对于 $\deg f<n$ 的 $f$ 都成立，由反证法，假设存在一个满足题目条件的 $f$ 在模 $p$ 意义下有着至少 $n+1$ 个不同的解 $x_0,x_1,\cdots,x_{n}$。
>
> 可设 $f(x)-f(x_0)=(x-x_0)g(x)$，则 $g(x)$ 在模 $p$ 意义下是一个至多 $n-1$ 次的多项式。现在由 $x_0,x_1,\cdots,x_n$ 都是 $f(x)\equiv 0\pmod p$ 的解，知对 $1\leq i\leq n$，都有
>
> $$(x_i-x_0)g(x_i)\equiv f(x_i)-f(x_0)\equiv 0\pmod p$$
>
> 而 $x_i \not\equiv x_0 \pmod p$，故 $g(x_i)\equiv 0\pmod p$，从而 $g(x)\equiv 0\pmod p$ 有至少 $n$ 个根，与归纳假设矛盾。
>
> 所以，命题对 $n$ 次多项式也成立，定理获证。
>

_补充：关于拉格朗日定理的证明中，由于 $f(x_i)=0$，故 $f(x)-f(x_i)$ 就是 $f(x)$，不影响阅读。_ 
 

------------

下面来看看阶与原根。

> **阶**：由欧拉定理可知，对 $a\in \mathbf{Z},m\in\mathbf{N}^{*}$，若 $\gcd(a,m)=1$，则
> $$a^{\varphi(m)}\equiv 1\pmod m$$
>
>因此满足同余式 $a^n \equiv 1 \pmod m$ 的最小正整数 $n$ 存在，这个 $n$ 称作 $a$ 模 $m$ 的阶，记作 $\delta_m(a)$。
>
> **原根**：设 $m \in \mathbf{N}^{*}$，$a\in \mathbf{Z}$。若 $\gcd(a,m)=1$，且 $\delta_m(a)=\varphi(m)$，则称 $a$ 为模 $m$ 的原根。

关于阶有一个较为显然的性质：

> 若 $a^n \equiv 1 \pmod m$，则 $\delta_m(a)|n$。

**证明**： 对 $n$ 除以 $\delta_m(a)$ 作带余除法，设

$$n=\delta_m(a)q+r,0\leq r<\delta_m(a)$$

若 $r>0$，则

$$a^r\equiv a^r(a^{\delta_m(a)})^q\equiv a^n \equiv 1 \pmod m$$

这与 $\delta_m(a)$ 的最小性矛盾。故 $r=0$，即 $\delta_m(a)|n$。

 _应评论：这里区分出 $r>0$ 是为证明 $r=0$。_ 

------------

阶还有两个重要的性质。

> **性质 $1$**：设 $m\in\mathbf{N}^{*}$，$a,b\in\mathbf{Z}$，$\gcd(a,m)=\gcd(b,m)=1$，则
>
> $$\delta_m(ab)=\delta_m(a)\delta_m(b)$$
>
> 的充分必要条件是 $\gcd(\delta_m(a),\delta_m(b))=1$。
>

**证明**： 必要性。由 $a^{\delta_m(a)}\equiv 1 \pmod m$ 及 $b^{\delta_m(b)} \equiv 1 \pmod m$，可知

$$(ab)^{\operatorname{lcm}(\delta_m(a),\delta_m(b))}\equiv 1 \pmod m$$

由前面所述阶的性质，有

$$\delta_m(ab)|\operatorname{lcm}(\delta_m(a),\delta_m(b))$$

又由于 $\delta_m(ab)=\delta_m(a)\delta_m(b)$，故

$$\delta_m(a)\delta_m(b)|\operatorname{lcm}(\delta_m(a),\delta_m(b))$$

即 $\gcd(\delta_m(a),\delta_m(b))=1$。

充分性。由 $(ab)^{\delta_m(ab)}\equiv 1 \pmod m$ 可知

$$1 \equiv (ab)^{\delta_m(ab)\delta_m(b)}\equiv a^{\delta_m(ab)} \pmod m$$

故 $\delta_m(a)|\delta_m(ab)\delta_m(b)$。结合 $\gcd(\delta_m(a),\delta_m(b))=1$ 即得

$$\delta_m(a)|\delta_m(ab)$$

对称地，同理可得

$$\delta_m(b)|\delta_m(ab)$$

所以

$$\delta_m(a)\delta_m(b)|\delta_m(ab)$$

另一方面，有

$$(ab)^{\delta_m(a)\delta_m(b)}\equiv(a^{\delta_m(a)})^{\delta_m(b)}\times(b^{\delta_m(b)})^{\delta_m(a)}\equiv 1 \pmod m$$

故 

$$\delta_m(ab)|\delta_m(a)\delta_m(b)$$

综合以上两点即得

$$\delta_m(ab)=\delta_m(a)\delta_m(b)$$

**性质 $1$ 证毕。**

> **性质 $2$**：设 $k \in \mathbf{N}$，$m\in \mathbf{N}^{*}$，$a\in\mathbf{Z}$，$\gcd(a,m)=1$，则
>
> $$\delta_m(a^k)=\dfrac{\delta_m(a)}{\gcd(\delta_m(a),k)}$$
>

**证明**：注意到

$$a^{k\delta_m(a^k)}=(a^k)^{\delta_m(a^k)}\equiv 1 \pmod m$$

$$\Rightarrow \delta_m(a)|k\delta_m(a^k)$$

$$\Rightarrow \dfrac{\delta_m(a)}{\gcd(\delta_m(a),k)}|\delta_m(a^k)$$

另一方面，由 $a^{\delta_m(a)}\equiv 1 \pmod m$，可知

$$(a^k)^{\frac{\delta_m(a)}{\gcd(\delta_m(a),k)}}=(a^{\delta_m(a)})^{\frac{k}{\gcd(\delta_m(a),k)}}\equiv 1 \pmod m$$

故 

$$\delta_m(a^k)|\dfrac{\delta_m(a)}{\gcd(\delta_m(a),k)}$$

综合以上两点，得

$$\delta_m(a^k)=\dfrac{\delta_m(a)}{\gcd(\delta_m(a),k)}$$

**性质 $2$ 证毕。**


------------

回到正题，我们下面来证明，关于怎样的 $m$，其原根存在。

首先，$m=1,2,4$ 时，原根存在。

> **定理 $1$**：对于奇素数 $p$，$p$ 有原根。
>

**证明**：先证一个引理：

>> **引理**：设 $a$ 与 $b$ 是与 $p$ 互素的两个整数，则存在 $c\in\mathbf{Z}$ 使得 $\delta_p(c)=\operatorname{lcm}(\delta_p(a),\delta_p(b))$。
>>
>
>  _该引理原来的证明存在错误，现已更改证明，感谢 @ [lgLinZhengYu](https://www.luogu.com.cn/user/74931) 及 @ [Peanut_Tang](https://www.luogu.com.cn/user/72765) 指出。_ 
> 
> 记 $r=\delta_p(a),t=\delta_p(b)$，设它们的“标准分解”（这里对指数只要求 $\max(\alpha_j,\beta_j)>0$）分别为
>
> $$r=\prod_{j=1}^s p_j^{\alpha_j},\quad t=\prod_{j=1}^s p_j^{\beta_j}$$
>
> 令 $l$ 为所有使得 $\alpha_j\leq\beta_j$ 的 $p_j^{\alpha_j}$ 的乘积，令 $m$ 为所有使得 $\alpha_j>\beta_j$ 的 $p_j^{\alpha_j}$ 的乘积. 记 $r=lx,t=my$. 则这样定义的 $x,y$ 满足 $\gcd(x,y)=1$ 且 $\operatorname{lcm}(r,t)=xy$。
>
> 由性质 $2$，$\delta_p(a^l)=x,\delta_p(b^m)=y$，则由性质 $1$，$\delta_p(a^lb^m)=xy=\operatorname{lcm}(\delta_p(a),\delta_p(b))$，即取 $c=a^lb^m$ 即可。
>


回到原命题，对 $1 \sim (p-1)$ 依次两两使用引理，可知存在 $g\in \mathbf{Z}$ 使得

$$\delta_p(g)=\operatorname{lcm}\left(\delta_p(1),\delta_p(2),\cdots,\delta_p(p-1)\right)$$

这表明 $\delta_p(j)|\delta_p(g)\;,j=1,2,\cdots,p-1$，所以 $j=1,2,\cdots,p-1$ 都是同余方程

$$x^{\delta_p(g)}\equiv 1\pmod p$$

的根。由拉格朗日定理，可知方程的次数 $\delta_p(g) \geq p-1$。

又由费马小定理，易知 $\delta_p(g) \leq p-1$，故 $\delta_p(g)=p-1=\varphi(p)$。

综上可知 $g$ 为模 $p$ 的原根。

**定理 $1$ 证毕**。


------------

> **定理 $2$**：对于奇素数 $p$，$\alpha \in \mathbf{N}^{*}$，$p^\alpha$ 有原根。
>

**证明**：一个基本的想法是将模 $p$ 的原根平移。

先证明一个引理：

>> **引理**：存在模 $p$ 的原根 $g$，使得 $g^{p-1}\not\equiv 1 \pmod {p^2}$
>>
>
> **引理的证明**：事实上，任取模 $p$ 的原根 $g$，若 $g$ 不满足条件，我们认定 $g+p$ 满足条件。
>
> 易知 $g+p$ 也是模 $p$ 的原根。
>
> 我们有
>
> $$\begin{aligned}(g+p)^{p-1}&\equiv C_{p-1}^0g^{p-1}+C_{p-1}^1pg^{p-2}\\&\equiv g^{p-1}+p(p-1)g^{p-2}\\&\equiv 1-pg^{p-2}\\&\not\equiv 1 \pmod {p^2}\end{aligned}$$
>

回到原题，我们证明若 $g$ 是一个满足引理条件的原根，则对任意 $\alpha\in\mathbf{N}^{*}$，$g$ 是模 $p^{\alpha}$ 的原根。

首先，证明下面的结论：对任意 $\beta\in\mathbf{N}^{*}$，都可设

$$g^{\varphi(p^\beta)}=1+p^{\beta}\times k_{\beta}$$

这里 $p\nmid k_{\beta}$。事实上，$\beta=1$ 时，由 $g$ 的选取可知结论成立。现设上式对 $\beta$ 时成立，则 

$$\begin{aligned}g^{\varphi(p^{\beta+1})}&=(g^{\varphi(p^{\beta})})^{p}\\&=(1+p^{\beta}\times k_{\beta})^p\\&\equiv 1+p^{\beta+1}\times k_{\beta} \pmod {p^{\beta+2}}\end{aligned}$$

结合 $p\nmid k_{\beta}$ 可知命题对 $\beta+1$ 成立。

所以命题对任意 $\beta\in\mathbf{N}^{*}$ 都成立。

其次，记 $\delta=\delta_{p^\alpha}(g)$，则由欧拉定理，可知 $\delta|p^{\alpha-1}(p-1)$。

而由 $g$ 为模 $p$ 的原根，及 $g^{\delta}\equiv 1\pmod {p^\alpha}$ 可知 $(p-1)|\delta$。

所以可设 $\delta=p^{\beta-1}(p-1)$，这里 $1\leq \beta\leq \alpha$。

现在利用之前的结论，可知

$$g^{\varphi(p^{\beta})}\not\equiv 1\pmod {p^{\beta+1}}\Rightarrow g^{\delta}\not\equiv 1\pmod {p^{\beta+1}}$$

结合 $g^{\delta}\equiv 1\pmod {p^\alpha}$ 可知 $\beta \geq \alpha$。

综上可知，$\beta=\alpha$，即

$$\delta_{p^{\alpha}}(g)=p^{\alpha-1}(p-1)=\varphi(p^\alpha)$$

从而，$g$ 是模 $p$ 的原根。

**定理 $2$ 证毕**。


----------

> **定理 $3$**：对于奇素数 $p$，$\alpha\in\mathbf{N}^{*}$，$2p^{\alpha}$ 的原根存在。
>

**证明**：设 $g$ 是模 $p^{\alpha}$ 的原根，则 $g+p^{\alpha}$ 也是模 $p^{\alpha}$ 的原根。

在 $g$ 和 $g+p^{\alpha}$ 中有一个是奇数，设这个奇数是 $G$，则 $\gcd(G,2p^{\alpha})=1$。

由欧拉定理，$\delta_{2p^{\alpha}}(G)|\varphi(2p^{\alpha})$。

而 $G^{\delta_{2p^{\alpha}}(G)}\equiv 1\pmod {2p^{\alpha}}$，故

$$G^{\delta_{2p^{\alpha}}(G)}\equiv 1 \pmod {p^{\alpha}}$$

利用 $G$ 为模 $p^{\alpha}$ 的原根可知 $\varphi(p^{\alpha})|\delta_{2p^{\alpha}}(G)$。

结合 $\varphi(p^{\alpha})=\varphi(2p^{\alpha})$ 可知 $G$ 为模 $2p^{\alpha}$ 的原根。

**定理 $3$ 证毕**。


----------

> **定理 $4$**：对于 $m\notin\{1,2,4\}$，且不存在奇素数 $p$ 及 $\alpha \in \mathbf{N}^{*}$ 使得 $m\in\{p^{\alpha},2p^{\alpha}\}$，则对任意 $a\in\mathbf{Z}$，$\gcd(a,m)=1$，都有 $\delta_m(a)<\varphi(m)$，即模 $m$ 的原根**不存在**。
>

**证明**：对于 $m=2^{\alpha}$，$\alpha\in\mathbf{N}^{*},\alpha\geq 3$，则对任意奇数 $a=2k+1$ 均有

$$\begin{aligned}a^{2^{\alpha-2}}&=(2k+1)^{2^{\alpha-2}}\\&\equiv 1+C_{2^{\alpha-2}}^1(2k)+C_{2^{\alpha-2}}^{2}(2k)^{2}\\&\equiv1+2^{\alpha-1}k+2^{\alpha-1}(2^{\alpha-2}-1)k^2\\&\equiv 1+2^{\alpha-1}(k+(2^{\alpha-2}-1)k)\\&\equiv 1 \pmod {2^{\alpha}}\end{aligned}$$

其中最后一步用到 $k$ 与 $(2^{\alpha-2}-1)k$ 同奇偶，故其和为偶数。

若 $m$ 不是 $2$ 的幂，且 $m$ 为符合题目条件的数，则可设 $m=rt$，这里 $2<r<t$ 且 $\gcd(r,t)=1$。

此时，若 $\gcd(a,m)=1$，由欧拉定理可知

$$a^{\varphi(r)}\equiv 1 \pmod r\;,\quad a^{\varphi(t)}\equiv1\pmod t$$

注意到 $n>2$ 时，$\varphi(n)$ 为偶数，所以

$$a^{\frac{1}{2}\varphi(r)\varphi(t)}\equiv 1\pmod {rt}$$

进而

$$\delta_m(a)\leq\dfrac{1}{2}\varphi(r)\varphi(t)=\dfrac{1}{2}\varphi(rt)=\dfrac{1}{2}\varphi(m)<\varphi(m)$$

**定理 $4$ 得证**。


----------

### 结论

上面的定理 $1$ 到 $4$ 完整的给出了原根的充要条件。截至目前，我们证明了仅有 $1,2,4$ 或奇素数 $p^{\alpha}$ 及 $2p^{\alpha}$ 有原根，其它的数都没有原根。

那么我们可以先预处理素数及其幂次，及其幂次的 $2$ 倍，$\Theta(1)$ 的判断一个数有没有原根。

如果一个数有原根，可以先求出最小正原根。

> 王元于 1959 年证明了若 $m$ 有原根，其最小原根是不多于 $m^{0.25}$ 级别的。
>
> 事实上，由大量试验数据可以发现，对于足够大的 $m$，其最小正原根的大小不是多项式级别的。
>
> ——百度百科

可以感性理解一下，模 $m$ 的原根有 $\varphi(\varphi(m))$ 个，密度很大，所以最小原根很小。

根据这个结论，我们可以从小到大枚举。由原根的定义，若 $g$ 为模 $m$ 的原根，则对于 $\varphi(m)$ 的任意素因数 $p$，必有

$$g^{\varphi(m)/p}\not\equiv 1 \pmod m$$

同时，满足如上条件的 $g$，必将是原根。

我们可以预处理出 $\varphi(m)$ 的所有素因数，快速幂来判断。

假如找到了一个原根 $g$，不难证明对于所有 $\gcd(x,\varphi(m))=1$ 的 $x$，$g^x$ 均为原根，所以模 $m$ 的原根有 $\varphi(\varphi(m))$ 个。

所以我们可以在找到 $g$ 后再枚举找出所有 $m$ 的原根，排序后按要求输出。


~~复杂度不会算~~

**注意需要开 longlong**。

---

## 作者：ix35 (赞：63)

## 【模板】原根

有一些我不太会证明的结论，希望之后有人在题解区能证一下...

首先，什么样的数才有原根？

结论：$2,4,p^k,2\times p^k$，其中 $p$ 为奇素数，$k$ 为正整数。

怎么求一个数 $n$ 的所有原根？

首先找到 $n$ 的最小原根，设为 $g$，则 $n$ 的所有原根可以由 $g$ 的若干次乘方得到。

具体地，若 $n$ 存在原根，则其原根个数为 $\varphi(\varphi(n))$，每一个原根都形如 $g^k$ 的形式，要求满足 $\gcd(k,\varphi(n))=1$。

于是，我们在得到 $n$ 的最小原根 $g$ 后便可在 $O(\varphi(n)\log \varphi(n))$ 的时间复杂度内得到 $n$ 的所有原根。

如何得到 $n$ 的最小原根？

枚举即可。从小到大枚举 $g$ 并检验是否是 $n$ 的原根（我听说 $n$ 的最小原根是 $O(n^{0.25})$ 级别的，不太确定对不对）。检验的方法如下：

根据原根的定义，如果 $g$ 是 $n$ 的原根，除了满足 $g^{\varphi(n)}\equiv 1$ 外，还需要满足对于任意更小的 $k$ 有 $g^k\ne 1$。而我们不可能把小于 $\varphi(n)$ 的所有数都拿出来检验。

事实上，关于阶有一条强的性质：如果 $\gcd(a,n)=1$，且 $a^k\equiv 1\bmod n$，则 $k|\varphi(n)$，所以我们事实上只需要检验 $\varphi(n)$ 的所有真因子即可，进一步地，设 $n$ 的所有素因数为 $p_1,\ldots,p_l$，则只需要检验所有的 $\dfrac{\varphi(n)}{p_i}$ 即可，因为他们涵盖了 $\varphi(n)$ 所有真因子的倍数。

于是我们可以在 $O(n^{0.25}\log n)$ 的复杂度内得到 $n$ 的最小原根，进而计算所有原根。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN=1000010;
int t,p,cnt,tot,ctans,fc[MAXN],ans[MAXN],pri[MAXN],rt[MAXN],q[MAXN],phi[MAXN];
void init () {
	phi[1]=1;
	for (int i=2;i<=MAXN-10;i++) {
		if (!q[i]) {pri[++tot]=i,phi[i]=i-1;}
		for (int j=1;j<=tot&&pri[j]*i<=MAXN-10;j++) {
			q[i*pri[j]]=1;
			if (i%pri[j]==0) {
				phi[i*pri[j]]=phi[i]*pri[j];
				break;
			}
			phi[i*pri[j]]=phi[i]*(pri[j]-1);
		}
	}
	rt[2]=rt[4]=1;
	for (int i=2;i<=tot;i++) {
		for (int j=1;(1ll*j*pri[i])<=MAXN-10;j*=pri[i]) {rt[j*pri[i]]=1;}
		for (int j=2;(1ll*j*pri[i])<=MAXN-10;j*=pri[i]) {rt[j*pri[i]]=1;}
	}
	return;
}
int gcd (int a,int b) {return (b==0?a:gcd(b,a%b));}
int qpow (int a,int b,int p) {
	int res=1;
	while (b) {
		if (b&1) {res=(1ll*res*a)%p;}
		a=(1ll*a*a)%p;
		b>>=1;
	}
	return res;
}
void proc (int p) {
	for (int i=2;i*i<=p;i++) {
		if (p%i==0) {
			fc[++cnt]=i;
			while (p%i==0) {p/=i;}
		}
	}
	if (p>1) {fc[++cnt]=p;}
	return;
}
bool chk (int x,int p) {
	if (qpow(x,phi[p],p)!=1) {return 0;}
	for (int i=1;i<=cnt;i++) {
		if (qpow(x,phi[p]/fc[i],p)==1) {return 0;}
	}
	return 1;
}
int findrt (int p) {
	for (int i=1;i<p;i++) {
		if (chk(i,p)) {return i;}
	}
	return 0;
}
void getrt (int p,int x) {
	int prod=1;
	for (int i=1;i<=phi[p];i++) {
		prod=(1ll*prod*x)%p;
		if (gcd(i,phi[p])==1) {
			ans[++ctans]=prod;
		}
	}
	return;
}
int main () {
	init();
	scanf("%d",&t);
	for (int ii=1;ii<=t;ii++) {
		int wtf;
		scanf("%d%d",&p,&wtf);
		if (rt[p]) {
			ctans=cnt=0;
			proc(phi[p]);
			int mn=findrt(p);
			getrt(p,mn);
			sort(ans+1,ans+ctans+1);
			printf("%d\n",ctans); 
			for (int i=1;i<=ctans/wtf;i++) {printf("%d ",ans[i*wtf]);}
			printf("\n");
		} else {
			printf("0\n\n");
		}
	}
	return 0;
}
```


---

## 作者：panyf (赞：35)

效率更优秀的算法！时间复杂度 $O(Tn\log\log\log n)$ 。

首先，原根是什么以及如何求原根这里就不再赘述了，可以移步其他题解。

求原根的过程大致分为以下5步：

1.线性筛预处理所有质数和有原根的数，$O(n)$ 。

2.将 $\varphi(n)$ 分解因数，由于质数已经筛出，复杂度 $O(n^{0.5}/\log n)$ 。

3.快速幂求出最小原根，复杂度大概是 $O(n^{0.25}\log n\log\log n)$ 。

4.通过最小原根求出所有原根，需要进行 $\varphi(n)$次求最大公约数， $O(n\log n)$ 。

5.排序，从小到大输出， $O(n\log n)$ 。

很容易看出，复杂度瓶颈是第4步和第5步。

第5步排序很容易优化，用计数排序代替快速排序就可以 $O(n)$ 。

关键是第4步。由于我们要求出所有小于 $\varphi(n)$ 的与 $\varphi(n)$ 互质的数，可以考虑用埃氏筛的思想。第2步中 $\varphi(n)$ 的质因数已经求出，可以用这些数标记所有与 $\varphi(n)$ 不互质的数，复杂度优化至 $O(n\log\log\log n)$ 。

代码如下（不开O2不到1s跑完所有数据，比常规方法快了约10倍）：

```c
#include<cstdio>
const int N=1e6+7;
int pr[N],ph[N],fc[9],u[11],v[11],a[N];
bool f[N],b[N],p[N],q[N];
void init(int n){//第1步线性筛，b数组记录是否有原根
	b[2]=b[4]=ph[1]=1;
	int i,j,k,t=0;
	for(i=2;i<=n;++i){
		if(!f[i])pr[++t]=i,ph[i]=i-1;
		for(j=1;k=i*pr[j],k<=n&&j<=t;++j){
			f[k]=1;
			if(!(i%pr[j])){
				ph[k]=ph[i]*pr[j];
				break;
			}
			ph[k]=ph[i]*ph[pr[j]];
		}
	}
	for(i=2;i<=t;++i){
		for(j=1;j*1ll*pr[i]<=n;b[j*=pr[i]]=1);
		for(j=2;j*1ll*pr[i]<=n;b[j*=pr[i]]=1);
	}
}
int qp(int a,int b,int p){
	int r=1;
	while(b){
		if(b&1)r=r*1ll*a%p;
		a=a*1ll*a%p,b>>=1;
	}
	return r;
}
int main(){
	int T,n=0,m,d,i,j,k,t,o,s;
	scanf("%d",&T);
	for(i=1;i<=T;++i)scanf("%d%d",u+i,v+i),n=n>u[i]?n:u[i];
	init(n);
	for(o=1;o<=T;++o){
		n=u[o],d=v[o];
		if(!b[n]){
			puts("0\n");
			continue;
		}
		for(i=1,j=m=ph[n],t=0;pr[i]*pr[i]<=j;++i){
			if(!(j%pr[i])){
				fc[++t]=s=pr[i];
				do j/=s;while(!(j%s));
				for(k=s;k<=m;k+=s)p[k]=1;
			}
		}//第2步及第4步
		if(j>1){
			fc[++t]=j;
			for(k=j;k<=m;k+=j)p[k]=1;
		}
		for(j=1;;++j){
			while(qp(j,m,n)!=1)++j;
			for(i=1;i<=t&&qp(j,m/fc[i],n)!=1;++i);
			if(i>t)break;
		}//第3步
		for(t=j,i=1,s=0;i<=m;++i,t=t*1ll*j%n)if(!p[i])q[t]=1,++s;else p[i]=0;//第4步中求原根的部分
		printf("%d\n",s);
		for(i=1,j=0;i<n;++i){
			if(q[i]){
				q[i]=0,++j;
				if(j==d)j=0,printf("%d ",i);
			}
		}//第5步
		puts("");
	}
	return 0;
}
```
upd：其实可以 $O(n)$ 的 ， 但是这样做常数更小 。

可以用这种方法通过 [P5285](https://www.luogu.com.cn/problem/P5285) 的第 15 个点 。

---

## 作者：11D_Beyonder (赞：29)

[**移步博客**](https://pro_11d_beyonder.gitee.io/2020/07/08/%E5%8E%9F%E6%A0%B9/)
## 阶  
&emsp;&emsp;要定义原根，先要引入数论中阶的概念。  
### 阶的定义  
&emsp;&emsp;设 $a,m\in\mathbb{N^+}$，且 $a\perp m$，使 $a^x\equiv 1\pmod m$ 成立的最小正整数 $x$，称为 $a$ 模 $m$ 的阶，记为 $\text{ord}_ma$。  
### 阶的性质  
&emsp;&emsp;说明：描述阶的性质时，默认 $a,m\in\mathbb{N^+}$，且 $a\bot m$，即  $\mathrm{ord}_m a$ 存在。    
&emsp;&emsp;**性质1**&emsp;$a^n\equiv 1\pmod m$ 的充要条件为 $\mathrm{ord}_ma|n$。    
&emsp;&emsp;**证明**&emsp;设 $\mathrm{ord}_ma=x$。  
&emsp;&emsp;首先证明充分性。设 $n=px$，其中 $p\in\mathbb{N^+}$。则 $a^n\equiv a^{px}\equiv1\pmod m$；即 $a^n\equiv 1\pmod m$。  
&emsp;&emsp;接下来证明必要性。设 $n=px+q$，其中 $p\in\mathbb{N^+}$ ，且 $0\le q<x,q\in\mathbb N$。则 $a^n\equiv a^{px+q}\equiv a^q\equiv 1\pmod m$，得到 $a^q\equiv 1\pmod m$，由于 $x$ 是满足 $a^x\equiv1\pmod m$ 的最小正整数，又 $0\le q<x$，所以 $q=0$，故 $x\mid n$。  
&emsp;&emsp;证毕。   
&emsp;&emsp;**推论1**&emsp;$\mathrm{ord}_ma\mid\varphi(m)$。  
&emsp;&emsp;**证明**&emsp; 由欧拉定理，$a^{\varphi(m)}\equiv1\pmod m$，故 $\mathrm{ord}_ma\mid\varphi(m)$。  
&emsp;&emsp;**性质2**&emsp;设 $b\in\mathbb N^+$，若 $a\equiv b\pmod m$，则 $\text{ord}_ma=\text{ord}_mb$。  
&emsp;&emsp;**证明**&emsp;  首先 $a\equiv b\pmod m$，可以设 $b=a+km,k\in\mathbb Z$。则 $\gcd(b,m)=\gcd(a+km,m)$，由欧几里得算法 $\gcd(b,m)=\gcd(m,a)=1$，故 $b\bot m$，所以 $\mathrm{ord}_mb$ 存在。  
&emsp;&emsp;接下来用反证法证明 $\text{ord}_ma=\text{ord}_mb$。假设 $\text{ord}_ma=x$，$\text{ord}_mb=y$，且 $x\ne y$。则 $a^x\equiv(b-km)^x\equiv1\pmod m$，将 $(b-km)^x$ 用二项式定理展开，得到 $b^x\equiv1\pmod m$。根据假设 $\mathrm{ord}_mb=y$，故 $x>y$。然而，$b^y\equiv(a+km)^y\equiv1\pmod m$，将 $(a+km)^y$ 用二项式定理展开，得到 $a^y\equiv1\pmod m$；由于 $\mathrm{ord}_ma=x$，故 $x<y$，产生矛盾；所以，$x=y$，即 $\text{ord}_ma=\text{ord}_mb$。  
&emsp;&emsp;证毕。  
&emsp;&emsp;**性质3**&emsp;设 $p,q\in\mathbb N$，$a^p\equiv a^q\pmod m$ 的充要条件为 $p\equiv q\pmod {\text{ord}_ma}$。  
&emsp;&emsp;**证明**&emsp;首先证明充分性。设 $p=k_1\mathrm{ord}_ma+r$，$q=k_2\mathrm{ord}_ma+r$，其中 $k_1,k_2,r\in\mathbb N$，且 $0\le r<\mathrm{ord}_ma$。则 $a^p\equiv a^{k_1\mathrm{ord}_ma+r}\equiv a^r\pmod m$，同理，$a^q\equiv a^r\pmod m$，故 $a^p\equiv a^q\pmod m$。充分性得证。  
&emsp;&emsp;接下来证明必要性。不妨设 $p\ge q$，则 $a^{p-q}\equiv 1\pmod m$。根据**性质1**，$\text{ord}_a m\mid p-q$，所以 $p\equiv q\pmod {\text{ord}_ma}$。必要性得证。    
&emsp;&emsp;证毕。    
&emsp;&emsp;**性质4**&emsp;令 $\text{ord}_ma=x$，则 $1,a,a^2,\cdots,a^{x-1}$，模 $m$ 两两不同余。    
&emsp;&emsp;**证明**&emsp;下面用反证法证明。  
&emsp;&emsp;假设 $\exists\ i,j\in\mathbb N$ 且 $0\le j<i<x$，使得 $a^i\equiv a^j\pmod m$。故 $a^{i-j}\equiv1\pmod m$，由阶的定义，$i-j\ge x$，与 $0\le j<i<x$ 矛盾。故假设错误。    
&emsp;&emsp;证毕。     
&emsp;&emsp;**性质5**&emsp;设 $b\in\mathbb N^+$，若 $ab\equiv1\pmod m$，则 $\text{ord}_ma=\text{ord}_mb$。  
&emsp;&emsp;**证明**&emsp; 令 $\text{ord}_ma=x$，$\text{ord}_mb=y$，则有 $a^x\equiv1\pmod m$，$b^y\equiv 1\pmod m$。  
&emsp;&emsp;$a^xb^x\equiv b^x\equiv1\pmod m$，由阶的定义 $x\ge y$。$a^yb^y\equiv a^y\equiv 1$，由阶的定义，$x\le y$。所以，$x=y$。  
&emsp;&emsp;证毕。  
&emsp;&emsp;**性质6**&emsp;令 $x=\text{ord}_ma$，有 $t\in\mathbb N^+$ 则 $\text{ord}_ma^t=\frac{x}{\gcd(t,x)}$。  
&emsp;&emsp;**证明**&emsp;令 $\text{ord}_ma^t=k$，根据阶的定义，有 $a^{kt}\equiv1\pmod m$。  
&emsp;&emsp;由**性质1**，$x\mid kt$，故 $\frac{x}{\gcd(t,x)}\mid\frac{t}{\gcd(t,x)}k$ 。根据最大公约数的性质，$\frac{x}{\gcd(t,x)}\bot\frac{t}{\gcd(t,x)}$，所以 $\frac{x}{\gcd(t,x)}\mid k$。  
&emsp;&emsp;根据阶的定义，$k$ 为满足 $\frac{x}{\gcd(t,x)}\mid k$ 的最小正整数，故 $k=\frac{x}{\gcd(t,x)}$。  
&emsp;&emsp;证毕。  
&emsp;&emsp;**性质7**&emsp;设 $w\in\mathbb N^+$，若 $w\mid m$，则 $\text{ord}_wa\mid \text{ord}_ma$。  
&emsp;&emsp;**证明**&emsp;由阶的定义，$a^{\mathrm{ord}_ma}\equiv1\pmod m$；因此，$a^{\mathrm{ord}_ma}=km+1$，$k\in\mathbb N$。因为 $w\mid m$，所以 $a^{\mathrm{ord}_ma}\equiv1\pmod w$。根据**性质1**，$\text{ord}_wa\mid \text{ord}_ma$。  
&emsp;&emsp;证毕。  
&emsp;&emsp;**性质8**&emsp;设 $n\in\mathbb N^+$。若 $m\bot n,a\bot n$，则 $\text{ord}_{mn}a=\text{lcm}(\text{ord}_{m}a,\text{ord}_{n}a)$。  
&emsp;&emsp;**证明**&emsp;令 $x=\text{ord}_{mn}a$，$y=\text{lcm}(\text{ord}_{m}a,\text{ord}_{n}a)$。  
&emsp;&emsp;根据阶的定义，$a^x\equiv1\pmod{mn}$，于是有 $a^x=kmn+1$，$k\in\mathbb M$；故 $a^x\equiv 1\pmod {m}$，$a^x\equiv 1\pmod {n}$。由**性质1**，$ \text{ord}_ma\mid x$ 且 $\text{ord}_na\mid x$，故 $\text{lcm}(\text{ord}_{m}a,\text{ord}_{n}a)\mid x$，即 $y\mid x$。  
&emsp;&emsp;由最小公倍数的定义，有  $\mathrm{ord}_{m}a\mid y\text{ord}_{n}a\mid y$。根据**性质1**，有 $a^y\equiv1\pmod m$ 且 $a^y\equiv1\pmod n$；令 $a^y=k_1m+1=k_2n+1$，$k_1,k_2\in\mathbb N$，即 $k_1m=k_2n$。因为 $m\bot n$，故 $k_1=kn,k_2=km$，$k\in\mathbb N$，所以 $a^y\equiv1\pmod{mn}$。再次根据**性质1**，有 $\mathrm{ord}_{mn}a\mid y$，即 $x|y$。  
&emsp;&emsp;综上所述，$x=y$，即 $\text{ord}_{mn}a=\text{lcm}(\text{ord}_{m}a,\text{ord}_{n}a)$。  
&emsp;&emsp;证毕。  
&emsp;&emsp;**性质9**&emsp;设 $b\in\mathbb N^+$，若 $b\bot m$ 且 $\mathrm{ord}_ma\bot \mathrm{ord}_mb$，则 $\mathrm{ord}_mab=\mathrm{ord}_ma\times \mathrm{ord}_mb$ 。   
&emsp;&emsp;**证明**&emsp;令 $x=\mathrm{ord}_ma$，$y=\mathrm{ord}_mb$，$z=\mathrm{ord}_mab$。由阶的定义，有 $a^x\equiv1\pmod m$，$b^y\equiv1\pmod m$，$(ab)^z\equiv1\pmod m$。  
&emsp;&emsp;由 $(ab)^z\equiv1\pmod m$，得 $a^z\equiv1\pmod m$ 且 $b^z\equiv 1\pmod m$。根据**性质1**，$x\mid z$ 且 $y\mid z$，故 $\mathrm{lcm}(x,y)\mid z$。因为 $\mathrm{ord}_ma\bot \mathrm{ord}_mb$，即 $x\bot y$；所以 $\mathrm{lcm}(x,y)=xy$，即 $xy\mid z$。  
&emsp;&emsp;因为 $x=\mathrm{ord}_ma$ 且 $y=\mathrm{ord}_mb$，所以 $(ab)^{xy}\equiv 1\pmod m$。根据**性质1**，$z\mid xy$。  
&emsp;&emsp;综上所述，$z=xy$，即 $\mathrm{ord}_mab=\mathrm{ord}_ma\times \mathrm{ord}_mb$。  
&emsp;&emsp;证毕。  
## 原根  
### 原根的定义  
&emsp;&emsp;设 $g,m\in\mathbb N^+$，且 $g\bot m$；若 $\mathrm{ord}_mg=\varphi(m)$，则称 $g$ 是模 $m$ 的原根。  
### 原根存在定理   
&emsp;&emsp;不加证明地给出：模 ${\displaystyle m}$ 有原根的充要条件是 $m=2,4,p^k,2p^k$，其中 $p$ 是奇素数，$k$ 是任意正整数。    
### 原根判定定理  
&emsp;&emsp;不加证明地给出：若 $g$ 为模 $m$ 的原根，则对于任意 $\varphi(m)$ 的质因子 $p$，必有 $g^{\frac{\varphi(m)}{p}}\not\equiv 1 \pmod m$。  
### 求所有原根  
&emsp;&emsp;**定理**&emsp;设 $g$ 为模 $m$ 的原根，则集合 $S=\{g^{s} \mid 1 \leq s \leq \varphi(m),s\bot\varphi(m)\}$ 给出模 $m$ 的全部原根。模 $m$ 的原根有 $\varphi(\varphi(m))$ 个。  
&emsp;&emsp;**略证**&emsp;由原根的判定定理，对于任意 $\varphi(m)$ 的质因子 $p$，有 $g^{\frac{\varphi(m)}{p}}\not\equiv 1 \pmod m$；因此，$\left(g^s\right)^{\frac{\varphi(m)}{p}}\equiv \left(g^{\varphi(m)}\right)^{\frac{s}{p}}\pmod m$。若 $\gcd(s,\varphi(m))>1$，则存在一个 $p$，使得 $p\mid s$；此时，$\left(g^{\varphi(m)}\right)^{\frac{s}{p}}\equiv g^{k\varphi(m)}\pmod m$，$k\in\mathbb N^+$；根据欧拉定理 $g^{\varphi(m)}\equiv1\pmod m$。因此，当且仅当 $s\bot\varphi(m)$，$g^s$ 才为模 $m$ 的原根。  
&emsp;&emsp;若 $s>\varphi(m)$，由扩展欧拉定理，则 $g^s\equiv g^{s\bmod \varphi(m)}\pmod m$，转化为 $1\le s\le \varphi(m)$ 的问题。  
&emsp;&emsp;根据欧拉函数定义，满足条件 $1\leq s \leq \varphi(m),s\bot\varphi(m)$ 的 $s$ 有 $\varphi(\varphi(m))$ 个。根据阶的**性质4**，这 $\varphi(\varphi(m))$ 个原根模 $m$ 两两不同余。  
&emsp;&emsp;可以证明，最小原根是不大于 $\sqrt[4]{m}$ 级别的。因此，不妨枚举 $[1,\sqrt[4]{m}]$ 的整数，得到最小原根 $g$，这样的时间是可以接受的；接着，再枚举 $g^s$ 的指数 $s$，若 $s$ 与 $\varphi(m)$ 互质，则 $g^s\bmod m$ 为一个原根。   
下面就有了本题的代码
```cpp
#include<cstdio>
#include<vector>
#include<algorithm>
#include<iostream>
#define ll long long
#define N 1000002
using namespace std;
int cnt;//质数个数
bool vis[N];//vis[i]=1表示i为合数
int prime[N>>1];//质数
int phi[N];//欧拉函数
vector<int>prime_factor;//质因子
vector<int>ans;//所有模n的原根
//-------------------------------------------------------
//欧拉筛线性得到欧拉函数
void get_phi(int n)
{
	phi[1]=1;
	int i,j;
	for(i=2;i<=n;i++)
	{
		if(!vis[i])
		{
			phi[i]=i-1;
			prime[++cnt]=i;
		}
		for(j=1;j<=cnt&&i*prime[j]<=n;j++)
		{
			vis[i*prime[j]]=1;
			if(i%prime[j]==0)
			{
				phi[i*prime[j]]=phi[i]*prime[j];
				break;
			}
			else phi[i*prime[j]]=phi[i]*(prime[j]-1);
		}
	}
}
//-------------------------------------------------------
//-------------------------------------------------------
//快速幂
inline int qpow_mod(ll a,int b,int mod)
{
	ll res=1;
	while(b)
	{
		if(b&1) res=res*a%mod;
		a=a*a%mod;
		b>>=1;
	}
	return res;
}
//-------------------------------------------------------
//-------------------------------------------------------
//分解质因数
inline void divide(int x)
{
	int i;
	for(i=2;i*i<=x;i++)
	{
		if(x%i==0)
		{
			prime_factor.push_back(i);
			while(x%i==0) x/=i;
		}
	}
	if(x>1) prime_factor.push_back(x);
}
//-------------------------------------------------------
//-------------------------------------------------------
//利用原根存在定理
bool exist(int n)
{
	if(n==2||n==4) return 1;
	if(n%2==0) n/=2;//猜测为奇素数幂的二倍
	int i;
	//检验是否为奇素数的幂
	for(i=2;prime[i]<=n;i++)
	{
		if(n%prime[i]==0)
		{
			while(n%prime[i]==0) n/=prime[i];
			//若n存在原根
			//i为唯一质因子
			return n==1;
		}
	}
	return 0;
}
//-------------------------------------------------------
//-------------------------------------------------------
int main()
{
	get_phi(1000000);//预处理1~1000000的欧拉函数
	int _;
	for(cin>>_;_;_--)
	{
		int n,d;
		scanf("%d%d",&n,&d);
		//首先检验n是否存在原根
		if(exist(n))
		{
			prime_factor.clear();
			ans.clear();
			//对phi[n]分解质因数
			divide(phi[n]);
			int i,j;
			int g;
			//---------------------------------------------------------
			//找到最小原根g
			for(i=1;;i++)
			{
				bool is=1;
				if(__gcd(i,n)!=1) continue;//i不存在模n的阶
				for(j=0;j<prime_factor.size();j++)
				{
					//--------------------------------------------------
					//原根判定
					//对phi[n]的所有质因子p
					//i^(phi[n]/p)%n!=1;
					if(qpow_mod(i,phi[n]/prime_factor[j],n)==1)
					{
						is=0;
						break;
					}
					//--------------------------------------------------
				}
				if(is)//找到最小原根
				{
					g=i;
					break;
				}
			}
			//---------------------------------------------------------
			//---------------------------------------------------------
			//枚举指数s
			//若s与phi[n]互质
			//g^s为原根
			int s;
			ll power=1;
			for(s=1;ans.size()<phi[phi[n]];s++)
			{
				power=power*g%n;
				if(__gcd(phi[n],s)==1) ans.push_back(power);
			}
			sort(ans.begin(),ans.end());
			printf("%d\n",phi[phi[n]]);
			//---------------------------------------------------------
			for(i=d-1;i<phi[phi[n]]/d*d&&i<ans.size();i+=d) 
			{
				//if(i) putchar(' ');
				printf("%d ",ans[i]);
			}
			putchar('\n');
		}
		else puts("0\n");
	}
	return 0;
}
```

---

## 作者：0xyz (赞：18)

我来讲一下我做这道题的思路，并且给出一个 $O(Tn)$ 的算法。代码很短，不到 1.2kb，比其它题解简便很多。

我的这个做法充满人类智慧，只需要知道原根的定义、阶的定义以及知道一个原根之后怎么求别的原根即可。其他题解的复杂度证明几乎都是错的。看一下[这个帖子](https://www.luogu.com.cn/discuss/608103)。

我的[原根学习笔记](https://www.cnblogs.com/qwq-qaq-tat/p/17400002.html)。以下主要讲本题解法。

假设我们只求一次（求 $T\le 10$ 次其实差不多），这里我给出 3 种方法，循序渐进。

#### 1.$O(n\log^2 n)$ 解法

假设我们要求整数 $n$ 的所有原根，

1. 求出 $n$ 的欧拉函数 $\varphi(n)$。
2. 将 $\varphi(n)$ 质因数分解。
3. 依照定义，找到最小原根 $g$。如果找不到，那就无解。
4. 找到其余原根，也就是 $g$ 的 $x$ 次方，其中 $\gcd(\varphi(n),x)=1$。
5. 排序后输出。

分析一下时间复杂度以及实现细节。

步骤 1 最坏情况下要枚举到 $\sqrt n$，所以时间复杂度是 $O(\sqrt n)$。

步骤 2 最坏情况下要枚举到 $\sqrt{\varphi(n)}$，所以时间复杂度是 $O(\sqrt{\varphi(n)})$。

步骤 3 要枚举最小原根 $i:1\to n$，时间复杂度是 $O(n)$，并且枚举 $\varphi(n)$ 的质因数 $s$，判断使用快速幂判断 $i^{\frac{\varphi(n)}{s}}$ 是不是模 $n$ 余 $1$，时间复杂度是 $O(n\log^2 n)$。

步骤 4 直接枚举 $i:1\to\varphi(n)$，判断 $i$ 是不是与 $\varphi(n)$ 互质，$O(\log\varphi(n))$，如果是的话将 $g^i$ 加入答案集合。由于是按照顺序枚举，直接一边枚举一边乘就可以了，不用快速幂。时间复杂度 $O(\varphi(n)\log \varphi(n))$。

步骤 5 将答案集合排个序，由于有 $\varphi(\varphi(n))$ 个原根，所以这一步的时间复杂度是 $O(\varphi(\varphi(n))\log \varphi(\varphi(n)))$。

所以总时间复杂度是 $O(n\log^2 n)$。常数较小。

以下是代码，用 $m$ 表示输入的数，$n$ 代表 $\varphi(m)$。总长 923b。可能是最短解。

[AC 记录](https://www.luogu.com.cn/record/110248060)，开了 O2 最慢点 1.53 s，总共 9.92 s。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll m,c,s[20],ans[1000010],n,g,k,ca,T;
inline ll ksm(ll a,ll b){
	ll r=1;
	while(b){if(b&1)r=r*a%m;a=a*a%m;b>>=1;}
	return r;
}
inline void pri(ll x){
	c=0;
	for(ll i=2;i*i<=x;i++)
		if(x%i==0){s[++c]=i;while(x%i==0)x/=i;}
	if(x>1)s[++c]=x;
}
inline ll phi(ll x){
	pri(x);
	for(ll i=1;i<=c;i++)x=x/s[i]*(s[i]-1);
	return x;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>T;
	while(T--){
		ca=g=0;
		cin>>m>>k;
		pri(n=phi(m));
		for(ll i=1;i<m;i++)
			if(ksm(i,n)==1){
				bool fl=1;
				for(ll j=1;j<=c;j++)
					if(ksm(i,n/s[j])==1)fl=0;
				if(fl){g=i;break;}
			}
		if(!g){cout<<"0\n\n";continue;}
		for(ll i=1,p=g;i<=n;i++,p=p*g%m)
			if(__gcd(i,n)==1)ans[++ca]=p;
		sort(ans+1,ans+ca+1);
		cout<<ca<<'\n';
		for(ll i=1;i<=ca/k;i++)cout<<ans[i*k]<<' ';
		cout<<'\n';
	} 
	return 0;
} 
```

#### 2.$O(n\log n)$ 解法

我们发现复杂度瓶颈是步骤 3。注意到王元并没有证明任何数的原根是 $O(n^{0.25})$ 的，所以这么枚举，时间复杂度依然是 $O(n\log^2 n)$。

但是注意到原根比较密集，也就是如果 $n$ 有原根，并且我们只要找到任意一个原根就可以了（不需要一定是最小的）。

然后我写出了如下代码，求解 $\frac{\varphi(\varphi(n))}{n}$ 的最小值。之所以最后从 3 开始是因为 $\frac{\varphi(\varphi(2))}{2}=0$。然后我惊喜地发现在 $i\in [3,1000009]$ 中，$\frac{\varphi(\varphi(n))}{n}$ 最小大于 $0.04$。那就是说，在最坏情况下，在 $[1,n-1]$ 中随机选择一个数，有足足 $4\%$ 以上的概率是 $n$ 的原根。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll _=1000010;
ll c=0,p[_],e[_],ans=0;
bitset<_>v;
double mn=1e6;
int main(){
	v.set();
	for(ll i=2;i<_;i++){
		if(v[i])p[++c]=i,e[i]=i-1;
		for(ll j=1;j<=c&&i*p[j]<_;j++){
			v[i*p[j]]=0;
			if(i%p[j])e[i*p[j]]=e[i]*(p[j]-1);
			else{e[i*p[j]]=e[i]*p[j];break;}
		}
	}
	for(ll i=3;i<_;i++)
		if(double(e[e[i]])/double(i)<mn){
			mn=double(e[e[i]])/double(i);
			ans=i;
		}
	printf("%.6f %lld\n",mn,ans);
	return 0;
} 
```

那我们随机大概 200 次就几乎肯定能找到一个原根，因为此时依然找不到原根的概率小于 $0.96^{200}$，小于 $0.0003$。

所以此时步骤 3 时间复杂度变为 $O(\log^2 n)$，然后 200 不算大常数。

于是总复杂度变为 $O(\varphi(n)\log\varphi(n))$。之所以步骤 4 成为瓶颈是因为 $n$ 和 $\varphi(n)$ 同阶。事实上，当 $n$ 是质数时，$\varphi(n)=n-1$。

所以我们可以将时间复杂度简化为 $O(n\log n)$。

[AC 记录](https://www.luogu.com.cn/record/110407535)，可以看到运行时间显著减少，开了 O2 后最慢的点仅 1.01 s，总共 5.70 s。代码长度 945b。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll m,c,s[20],ans[1000010],n,g,k,ca,T;
inline ll ksm(ll a,ll b){
	ll r=1;
	while(b){if(b&1)r=r*a%m;a=a*a%m;b>>=1;}
	return r;
}
inline void pri(ll x){
	c=0;
	for(ll i=2;i*i<=x;i++)
		if(x%i==0){s[++c]=i;while(x%i==0)x/=i;}
	if(x>1)s[++c]=x;
}
inline ll phi(ll x){
	pri(x);
	for(ll i=1;i<=c;i++)x=x/s[i]*(s[i]-1);
	return x;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>T;
	while(T--){
		ca=g=0;
		cin>>m>>k;
		pri(n=phi(m));
		for(ll i=1,r;i<=200;i++)
			if(ksm((r=rand()%(m-1)+1),n)==1){
				bool fl=1;
				for(ll j=1;j<=c;j++)
					if(ksm(r,n/s[j])==1)fl=0;
				if(fl){g=r;break;}
			}
		if(!g){cout<<"0\n\n";continue;}
		for(ll i=1,p=g;i<=n;i++,p=p*g%m)
			if(__gcd(i,n)==1)ans[++ca]=p;
		sort(ans+1,ans+ca+1);
		cout<<ca<<'\n';
		for(ll i=1;i<=ca/k;i++)cout<<ans[i*k]<<' ';
		cout<<'\n';
	} 
	return 0;
} 
```

#### 3. $O(n)$ 做法

我们发现此时步骤 0、1、2、3 都是线性或者亚线性，只有步骤 4、5 是 $O(n\log n)$ 级别的，所以考虑优化步骤 4、5。

对于步骤 5，我们注意到所有的答案都在 $[1,n-1]$，所以可以不用快速排序，直接用桶排序实现。

对于步骤 4，我们发现它时间复杂度较大是因为要求 $n$ 次 $\gcd$，每次的时间复杂度是 $O(\log n)$
的。

一种解决方案是快速 $\gcd$，也就是经过 $O(n)$ 预处理后进行 $O(1)$ 的 $\gcd$。但是这样码量和常数都很大，甚至在随机数据下比 $O(\log n)$ 的 $\gcd$ 还慢。

我们发现已经将 $\varphi(n)$ 质因数分解在 $s$ 数组里了，那么如果 $\gcd(i,\varphi(n))\ne 1$，那么一定有 $s_j\mid \gcd(i,\varphi(n))$，也就是 $s_j\mid i$。如果一个一个去枚举 $s_j$ 的话是 $O(n\log n)$ 的，于是我想到了欧拉筛。它适用于筛掉所有质数的大于 1 倍的倍数，而这里是要筛掉一些特定的质数（$s$ 数组）的倍数。

我改进了一下，使得它在依然是线性的同时拥有这个功能。

注意代码中的 $n$ 仍然是上述的 $\varphi(n)$。

```cpp
for(ll i=1;i<=c;i++)
	for(ll j=1;j<s[i]&&s[i]*j<=n;j++)u[s[i]*j]=0;
for(ll i=1;i<=n;i++)
	for(ll j=1;j<=c&&s[j]<=i&&i*s[j]<=n;j++){
		u[i*s[j]]=0;
		if(i%s[j]==0)break;
	}
```
1. 对于正确性的证明：第一部分解决了所有 $s_i$ 乘上一个比它小的数的情况，第二部分解决了所有 $s_j$ 乘上一个比它大的数的情况。

2. 对于线性时间复杂度的证明：容易知道一个数在第一部分一定是被 最大质数×其余部分 筛掉，在第二部分一定是被 最小质数×其余部分 筛掉，所以在两个部分各至多被筛一次。所以时间复杂度 $O(n)$。

于是我们就解决了这道题的 $O(n)$ 做法。代码仅 1.17 kb。

[AC 记录](https://www.luogu.com.cn/record/110405768)，最慢的点仅 139 ms，总时间 793 ms，是 $O(n\log n)$ 做法时间的 $\frac{1}{7}$。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll _=1000010;
ll m,c,s[20],ans[_],n,g,k,cp,ca,T;
bitset<_>u,v;
inline ll ksm(ll a,ll b){
	ll r=1;
	while(b){if(b&1)r=r*a%m;a=a*a%m;b>>=1;}
	return r;
}
inline void pri(ll x){
	c=0;
	for(ll i=2;i*i<=x;i++)
		if(x%i==0){s[++c]=i;while(x%i==0)x/=i;}
	if(x>1)s[++c]=x;
}
inline ll phi(ll x){
	pri(x);
	for(ll i=1;i<=c;i++)x=x/s[i]*(s[i]-1);
	return x;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>T;
	while(T--){
		ca=g=0;u.set();v.reset();
		cin>>m>>k;
		pri(n=phi(m));
		for(ll i=1,r;i<=200;i++)
			if(ksm((r=rand()%(m-1)+1),n)==1){
				bool fl=1;
				for(ll j=1;j<=c;j++)
					if(ksm(r,n/s[j])==1)fl=0;
				if(fl){g=r;break;}
			}
		if(!g){cout<<"0\n\n";continue;}
		for(ll i=1;i<=c;i++)
			for(ll j=1;j<s[i]&&s[i]*j<=n;j++)u[s[i]*j]=0;
		for(ll i=1;i<=n;i++)
			for(ll j=1;j<=c&&s[j]<=i&&i*s[j]<=n;j++){
				u[i*s[j]]=0;
				if(i%s[j]==0)break;
			}
		for(ll i=1,p=g;i<=n;i++,p=p*g%m)
			if(u[i])v[p]=1;
		for(ll i=1;i<=m;i++)
			if(v[i])ans[++ca]=i;
		cout<<ca<<'\n';
		for(ll i=1;i<=ca/k;i++)cout<<ans[i*k]<<' ';
		cout<<'\n';
	} 
	return 0;
}
```

### 三、总结

在这道题里，我将原来 $O(n\log^2 n)$ 的代码优化到了 $O(n)$。而具体的运行时间也由 9.92 s 优化到了 793 ms，最大的点也由 1.53 s 优化到 139 ms，不足原来的 $\frac{1}{11}$。而在这之间，我并没有采用硬件级别的优化或者其它卡常的措施，仅仅是基于我对于算法的理解以及人类智慧，优化算法。所以我认为 OIer 在学算法的时候，不应该一知半解，只是背一下板子而已，而是应该要学得透彻，不仅要学高深的算法，也要会尽力运用较为基础的算法。比如这个随机化，就是一个比较基础的算法，但是可以大幅优化时间复杂度。将枚举改变为随机化可以将枚举次数从[大于 $\frac{n}{2}$](https://www.luogu.com.cn/discuss/607532) 锐减至 200 次。还有这个扩展欧拉筛，是我在欧拉筛的基础上创造出来的。这样遇到新颖的题目时才可以更容易想出来。

### 四、鸣谢

感谢出题人 [ix35](https://www.luogu.com.cn/user/113546) 提供题目。

感谢 [codecode](https://www.luogu.com.cn/user/119526) 的讲解。

感谢 [jijidawang](https://www.luogu.com.cn/user/227514) 提供论文链接。

感谢 [chenxia25](https://www.luogu.com.cn/user/138400) 提供随机化做法。

感谢 [管理员](https://www.luogu.com.cn/user/365969) 审核一篇这么长的题解。

---

## 作者：神眷之樱花 (赞：9)

# 模板题面
[【模板】原根](https://www.luogu.com.cn/problem/P6091)
# 预习笔记
[wiki](https://oi-wiki.org/math/primitive-root/#_2)

[My Blog](https://www.cnblogs.com/sjzyh/p/14887351.html)

众所周知 OI 不需要证明。

首先原根的定义是：
对于互质的正整数 $m$ 和整数 $a$,如果 $a\bmod m$ 的阶等于 $\varphi (m)$ 的话，就称 $a$ 为模 $m$ 的原根。

阶的定义是，对于互质的正整数 $m$ 和整数 $a$,满足 $a^{x} \bmod m = 1$ 的最小正整数 $x$，记作 $\delta_{m}(a)$

据王元的证明可知，模 $m$ 的最小原根不超过 $m^{0.25}$，所以如果我们暴力枚举找最小原根复杂度也是可以接受的，所以我们找原根的流程就是：
* 判断这个数是否具有原根：
根据原根存在定理：一个数 $m$ 存在原根当且仅当 $m = 2,4,p^{\alpha},2p^{\alpha}$，其中 $p$ 为奇素数，$\alpha$ 为正整数。

因为 $m \leq 1e6$，而对于次方能取到最大的 $3$ 来说不过是 12 次计算，因此我们完全可以预处理出所有素数满足某次方或某次方的 2 倍在这个范围内的值，然后就可以 O(1) 判断数 $m$ 是否有原根。

反之，如果我们不这样判断的话，我们在暴力枚举的时候就要枚举 $m - 1$ 次才发现它没有原根还要加上快速幂每次的 log。
* 从小到大枚举，找到 $a^{\varphi (m)} \bmod m = 1$ 的 $a$， 判断是否合法。

根据原根判定定理：若一个数 $g$ 是模 $m$ 的原根，则有对于 $\varphi (m)$ 任何大于 1 且不为自身的因数 $p$，都有 $g^{\varphi (m) / p} \bmod m \neq 1$ 。

因此我们只需要花 $\sqrt m$ 的时间复杂度，求出 $\varphi (m)$ 的除 1 以外的正因数，再依次判断就行了（质数要包含本身）。
* 找到原根以后再根据一个神奇的定理找出其它的原根

注意除了预处理所有的运算都是在模 $m$ 意义下的。

这是根据欧拉定理的推论推出的。

即 $a^{x} \bmod m = a ^ {x \bmod \varphi(m)} \bmod m$。

对于正整数 $x$,模 $m$ 的某原根 $g$，如果$x,\varphi(m)$互质，那么 $g^x$ 也是模 $m$ 的一个原根，因此我们再枚举这个 $x$ 就好了，根据上面的定义其中 $x$ 是小于 $\varphi (m)$ 的正整数。

以上就是找原根的暴力流程。
# 代码
```cpp
#include<cstdio>
#include<cctype>
#include<cstring>
#include<iostream>
#include<algorithm>

using namespace std;

const int N = 1e6 + 5;

int m[15], d[15], maxn, t, ans[N], cnt = 0;

int Prime[N], v[N], tot;

void GetPrime(int n) {
	memset(v, 0, sizeof(v)); tot = 0;
	for(int i = 2; i <= n; i++) {
		if(v[i] == 0) {
			v[i] = i; Prime[++tot]  = i;
		}
		for(int j = 1; j <= tot; j++) {
			if(Prime[j] > v[i] || Prime[j] > n / i) break;
			v[i * Prime[j]] = Prime[j];
		}
	}
}

#define LL long long

LL power(LL a, LL b, LL mod) {
	LL res = 1;
	for(; b; b >>= 1, a = a * a % mod)
		if(b & 1) res = res * a % mod;
	return res;
}

bool is[N];

void init() {
	is[2] = is[4] = true; LL x = 1;
	for(int i = 2; i <= tot; i++, x = 1)
		for(int j = 1; ; j++) {
			x = x * Prime[i];
			if(x > maxn) break;
			is[x] = true;
			if(2 * x <= maxn)
				is[2 * x] = true;
		}
}

int phi(int M) {
	int res = M;
	for(int i = 2; i * i <= M; i++)
		if(M % i == 0) {
			res = res / i * (i - 1);
			while(M % i == 0) M /= i;
		}
	if(M > 1) res = res / M * (M - 1);
	return res;
}

int fac[N], num = 0;

void divide(int n) {
	num = 0;
	for(int i = 2; i * i <= n; i++)
		if(n % i == 0) {
			fac[++num] = i;
			if(i != n / i) fac[++num] = n / i;
		}
	if(n > 1) fac[++num] = n;
}

bool check(int x, int PhiM, int M) {
	for(int i = 1; i <= num; i++)
		if(power(x, PhiM / fac[i], M) == 1) return false;
	return true;
}

int gcd(int a, int b) {
	return b == 0 ? a : gcd(b, a % b);
}

inline int read() {
	int x = 0, f = 1, c = getchar();
	for(; !isdigit(c); c = getchar())
		if(c == '-')
			f = -1;
	for(; isdigit(c); c = getchar())
		x = x * 10 + c - 48;
	return x * f;
}

int main() {
	t = read();
	for(int i = 1; i <= t; i++)
		m[i] = read(), maxn = max(maxn, m[i]),
		d[i] = read();
	GetPrime(maxn); init();
	for(int i = 1; i <= t; i++, cnt = 0) {
		if(!is[m[i]]) {
			printf("0\n \n"); continue;
		}
		else {
			int PhiM = phi(m[i]), g;
			divide(PhiM);
			for(int j = 1; j < m[i]; j++)
				if(power(j, PhiM, m[i]) == 1 && check(j, PhiM, m[i])) {
					g = j; break;
				}
			int x = 1;
			for(int j = 1; j <= PhiM; j++) {
				x = 1ll * x * g % m[i];
				if(gcd(j, PhiM) == 1) ans[++cnt] = x;
			} printf("%d\n", cnt);
			sort(ans + 1, ans + 1 + cnt);
			for(int j = d[i]; j <= cnt; j += d[i])
				printf("%d ", ans[j]);
			puts("");
		}
	}
	return 0;
}
```

---

## 作者：SSerxhs (赞：8)

**仅讲述如何优化复杂度，其余部分参考其他题解**

其实不需要快速 $\gcd$ 或者筛 $\gcd$ 也可以做到线性。

考虑线性筛的过程其实求出了每个数的最小素因子 $g_i$，那么不妨设 $f_i$ 表示 $i$ 是否与 $\varphi(n)$ 互质，显然有 $f_i=f_{g_i} \land f_{\frac{i}{g_i}}$，边界条件为 $f_p=1-[p|\varphi(n)] (p\in \text{prime})$ ，这一点在分解质因数的过程中可以完成。

$g_i$ 的另一个用处是分解质因数，只需要每次 $n\leftarrow \frac{n}{g_n}$ 即可求出所有的质因数。这一步的复杂度优化为 $O(T\log n)$。

总复杂度 $O(Tn)$，但不知道为什么被 $O(Tn\log \log \log n)$ 吊起来打。

```
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e6+2;
int ss[N],mn[N],fmn[N],phi[N];
int t,n,gs,i,d;
bool ed[N],av[N],yg[N];
void getfac(int x,int *a,int &n)
{
	register int y=x,z;
	while (x>1)
	{
		x/=(a[++n]=z=mn[x]);
		while (x%z==0) x/=z;
	}
	//for (i=1;i<=n;i++) y-=y/a[i];
	for (i=1;i<=n;i++) av[a[i]]=0,a[i]=y/a[i];
	//return y;
}
inline int ksm(register int x,register int y,register int p)
{
	register int r=1;
	while (y)
	{
		if (y&1) r=(ll)r*x%p;
		x=(ll)x*x%p;y>>=1;
	}
	return r;
}
inline bool ck(int x,int *a,int n,int p)
{
	for (int i=1;i<=n;i++) if (ksm(x,a[i],p)==1) return 0;
	return 1;
}
void getrt(int x,int d)//改ed
{
	static int a[100],b[N];
	//if (n==2) return puts("1"),void();
	int n=0,y,i,g=0,c=d;y=phi[x];
	fill(av+1,av+y+1,1);
	//memset(yg+1,0,x);
	getfac(y,a,n);
	for (i=1;i<x;i++) if (__gcd(i,x)==1&&ck(i,a,n,x)) break;
	if (i==x) return puts("0\n"),void();
	yg[g=i]=1;//g就是最小原根
	//printf("%d %d %d\na:",g,y,n);
	//for (i=1;i<=n;i++) printf("%d ",a[i]);puts("");
	int j=(ll)g*g%x;
	for (i=2;i<=y;i++) av[i]=av[mn[i]]&av[fmn[i]];
	for (i=2;i<y;i++,j=(ll)j*g%x) if (av[i]) yg[j]=1;
	printf("%d\n",g?phi[y]:0);
	for (i=1;i<x;i++) if (yg[i]) 
	{
		yg[i]=0;
		if (--c==0) printf("%d ",i),c=d;
	}puts("");
}
void init()
{
	register int i,j,k,n=N-1;
	mn[1]=phi[1]=1;
	for (i=2;i<=n;i++)
	{
		if (!ed[i]) phi[mn[i]=ss[++gs]=i]=i-1;
		for (j=1;j<=gs&&(k=ss[j]*i)<=n;j++)
		{
			ed[k]=1;mn[k]=ss[j];
			if (i%ss[j]==0) {phi[k]=phi[i]*ss[j];break;}
			phi[k]=phi[i]*(ss[j]-1);
		}
	}
	for (i=1;i<=n;i++) fmn[i]=i/mn[i];
}
int main()
{
	init();
	scanf("%d",&t);
	while (t--)
	{
		scanf("%d%d",&n,&d);
		getrt(n,d);
	}
}
```

---

## 作者：sto_5k_orz (赞：7)

当 $a^b\equiv 1\pmod p$ 时，且此时 $b$ 是满足这一条件的最小正整数解，我们称 $a$ 膜 $p$ 的阶为 $b$。记作 $\delta_p(a)$。

四个性质：

1. $a,a^2\cdots a^{\delta_p(a)}$ 膜 $p$ 后互不相同。

考虑反证法，设 $a^i\equiv a^j\pmod p,i,j\le \delta_p(a)$，则 $a^{j-i}\equiv 1\pmod p$，$j-i<\delta_p(a)$，与最小性矛盾。

2. 若 $a^x\equiv 1\pmod p$，则 $\delta_p(a)\mid x$。

令 $y=\delta_p(a)$。

继续考虑反证法，令 $x=ky+b,b<y$。

则 $a^b\equiv a^{ky}\times a^b\equiv 1\pmod p$，与阶的最小性矛盾。

3. 若 $\gcd(a,p)=\gcd(b,p)=1$，则 $\delta_p(a)\delta_p(b)=\delta_p(ab)$ 的充要条件是 $\gcd(\delta_p(a),\delta_p(b))=1$。

必要性：

显然 $a^{\delta_p(a)}\equiv b^{\delta_p(b)}\equiv 1\pmod p$。

所以 $ab^{\operatorname{lcm}(\delta_p(a),\delta_p(b))}\equiv 1\pmod p$。

由性质二得 $\delta_p(ab)\mid \operatorname{lcm}(\delta_p(a),\delta_p(b))$。

即 $\delta_p(a)\delta_p(b)\mid \operatorname{lcm}(\delta_p(a),\delta_p(b))$。

又因为 $\delta_p(a)\delta_p(b)=\operatorname{lcm}(\delta_p(a),\delta_p(b))\times \gcd(\delta_p(a),\delta_p(b))$，

所以 $\gcd(\delta_p(a),\delta_p(b))=1$。

充分性：
$$
(ab)^{\delta_p(ab)}\equiv 1\pmod p
$$

$$
(ab)^{\delta_p(ab)\delta_p(b)}\equiv 1\pmod p
$$

$$
a^{\delta_p(ab)\delta_p(b)}\equiv 1\pmod p
$$

$$
\delta_p(a)\mid \delta_p(ab)\delta_p(b)
$$

又因为 $\gcd(\delta_p(a),\delta_p(b))=1$，得 $\delta_p(a)\mid \delta_p(ab)$。

同理可得 $\delta_p(b)\mid \delta_p(ab)$。

由于 $\gcd(\delta_p(a),\delta_p(b))=1$，则 $\delta_p(a)\delta_p(b)=\delta_p(ab)$。

重新推一遍：

$$
(ab)^{\delta_p(ab)}\equiv 1\pmod p
$$

$$
(ab)^{\delta_p(a)\delta_p(b)}\equiv 1\pmod p
$$

$$
(a^{\delta_{p}(a)})^{\delta_p(b)} (b^{\delta_p(b)})^{\delta_p(a)}\equiv 1\pmod p
$$

得 $\delta_p(ab)\mid \delta_p(a)\delta_p(b)$。

结合上式，得 $\delta_p(a)\delta_p(b)=\delta_p(ab)$。

性质 $4$：

若 $\gcd(a,p)=1$，则 $\delta_p(a^k)=\dfrac{\delta_p(a)}{\gcd(\delta_p(a),k)}$。

证明：
$$
a^{k\delta_p(a^k)}=(a^k)^{\delta_p(m)\delta_p(a^k)}\equiv 1\pmod p\\
\delta_p(a)\mid k\delta_p(a^k)\\
\dfrac{\delta_p(a)}{\gcd(\delta_p(a),k)}\mid \delta_p(a^k)
$$
又有
$$
(a^k)^{\frac{\delta_p(a)}{\gcd(\delta_p(a),k)}}=(a^{\delta_p(a)})^{\frac{k}{\gcd(\delta_p(a),k)}}\equiv 1\pmod p
$$

$$
\delta_p(a^k)\mid \dfrac{\delta_p(a)}{\gcd(\delta_p(a),k)}
$$

综上，$\delta_p(a^k)=\dfrac{\delta_p(a)}{\gcd(\delta_p(a),k)}$。

原根：若 $\varphi(m)=\delta_m(a)$ 且 $\gcd(a,m)=1$，则我们称 $m$ 是 $a$ 的原根。

一个数 $x$ 存在原根当且仅当 $x\in \{2,4,p^k,2p^k\}$，其中 $k$ 为正整数。

显然若一个数 $g$ 为 $m$ 的原根，则 $g,g^2,\cdots g^{\varphi(m)}$构成模 $m$ 意义下的既约剩余系，由于 $\gcd(g,m)=1$，所以 $\gcd(g^x,m)=1$，且剩余系各个数互不相等。

由于性质一，原根一定在 $g,g^2,g^3\cdots g^{\varphi(m)}$ 之间。

王元于 $1959$ 年证明了，若 $m$ 有原根，则最小原根是 $m^{0.25}$ 级别的，所以我们可以直接枚举最小原根 $g$。

线性筛 $\varphi$，然后枚举 $k$，排个序输出即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long 
const int N = 1000010;
int phi[N], cnt, p[N / 10];
bool isp[N]; int n;
#define ctz __builtin_ctz
inline int gcd(int a, int b) {
    int az = ctz(a), bz = ctz(b), z = (az > bz) ? bz : az, t; b >>= bz;
    while(a) a >>= az, t = a - b, az = ctz(t), b = min(a, b), a = t < 0ll ? -t : t;
    return b << z;
}
void init(const int n = 1000000) {
	for(int i = 2; i <= n; i++) {
//		cout << i << '\n';
		if(!isp[i]) {
			phi[i] = i - 1;
			p[++cnt] = i;
		}
		for(int j = 1; i * p[j] <= n; j++) {
//			cout << j << '\n';
			isp[i * p[j]] = 1;
			if(i % p[j] == 0) {
				phi[i * p[j]] = phi[i] * p[j];
				break;
			}
			phi[i * p[j]] = phi[i] * phi[p[j]];
		}
	}
}
int Pow(int a, int b, int p) {
	int ans = 1;
	while(b) {
		if(b & 1) ans = 1ll * ans * a % p;
		a = 1ll * a * a % p;
		b >>= 1;
	}
	return ans;
}
vector<int> d, g;
bool check(int x) {
	if(Pow(x, phi[n], n) != 1) return 0;
	for(int y: d) {
		if(Pow(x, y, n) == 1) return 0;
	}
	return 1;
}
signed main() {
	
	ios::sync_with_stdio(0);
	int D, T; cin >> T;
	init();
	while(T--) {
		cin >> n >> D;
//		cout << n << ' ' << D << '\n';
		d.clear();
		int P = phi[n];
//		exit(0);
		for(int i = 1; p[i] * p[i] <= P; i++) {
			if(P % p[i] == 0) {
				d.push_back(phi[n] / p[i]);
				while(P % p[i] == 0) P /= p[i];
			}
		}
//		exit(0);
		if(P > 1) d.push_back(phi[n] / P);
		g.clear();
		for(int i = 1; i <= n; i++) {
			if(check(i)) {
				g.push_back(i);
				break;
			}
		}
		if(g.empty()) {
			cout << "0\n\n";
			continue;
		}
		int mul = g[0];
//		cout << "lim = " << phi[phi[n]] << ' ' << phi[n] << '\n';
//		cout << "g = " << g[0] << '\n'; 
		for(int i = 2; i <= n && g.size() < phi[phi[n]]; i++) {
			mul = 1ll * mul * g[0] % n;
//			cout << "i = " << i << " mul = " << mul << '\n';
			if(gcd(i, phi[n]) == 1) g.push_back(mul);
		}
		stable_sort(g.begin(), g.end());
//		cout << "size = ";
		cout << g.size() << '\n';
//		for(int x: g) cout << x << '\n';
		for(int i = D - 1; i < g.size(); i += D) cout << g[i] << ' ';
		cout << '\n';
	}
	return 0;
}
```

后记：

是时候退役了。

OIer 在学校过得很难受，也许成为 whker 会好些。

2024 年 qzez 自主招生结束后，我将~~强势~~回归。

如果没考上，中考。

以后每周一下午会上线，晚上可能会上线几分钟。

这大概是我最后一篇题解了。

申请禁言了，有事私信。

祝大家学好 OI，学好 whk。

一点数据：

不算上这篇题解，我在洛谷一共通过了 75 篇题解，这也许是我对洛谷最后的回报了吧。

---

## 作者：ganpig (赞：4)

作为一个刚刚学会原根求法~~顺便卡到最优解榜三~~的数论蒟蒻，来这里给跟我一样对着题解区的长篇大论一头雾水的朋友们指指路，分享一种 $O(n)$ 且又好理解又好写的做法~

（前置知识：[欧拉函数](https://oi-wiki.org/math/number-theory/euler-totient/)）

### 0. 原根是啥？有啥用？

引用一段典中典：

> 你说的对，但是感觉不如原根。原根是数论中一个非常重要的概念。设 $g,n$ 是正整数，若 $g$ 模 $n$ 的阶等于 $\varphi(n)$，即当且仅当 $i = \varphi(n)$ 时 $g^i \equiv 1 \pmod n$，则称 $g$ 为 $n$ 的一个原根。对于 $0 < i \le \varphi(n)$，$g^i \bmod n$ 的结果两两不同。我现在每天用原根都能做 $10^5$ 次数据规模 $10^6$ 的 NTT，也就是现实生活中 $10^{17}$ 次乘法运算，这便是原根给我的骄傲的资本。

至于“阶”的概念，理解成 $\{a^i \bmod n\}$ 的“循环节”长度就好。最重要的还是加粗的性质，后面会用到。

### 1. 什么样的数有原根？

结论：$2,4,p^k,2p^k$，其中 $p$ 为奇素数，$k$ 为正整数。（$1$ 不在本题需考虑的范围之内）

~~打个暴力就可以粗略地验证了，实在想看证明的话可以移步隔壁数竞大佬的题解~~

### 2. 怎么判断一个数是否为另一个数的原根？

首先肯定要满足 $g^{\varphi(n)} \equiv 1 \pmod n$，用快速幂判断即可。

而如何判断 $\forall 0 < i < \varphi(n),g^i \neq 1$ 是否成立呢？若不成立，设 $x$ 是满足 $g^x \equiv 1 \pmod n$ 的最小正整数，则一定有 $x \mid \varphi(n)$（否则 $g^{\varphi(n) \bmod x}=1$，不满足 $x$ 最小），设 $\frac{\varphi(n)}{x}=kp$（$k$ 为正整数，$p$ 为 $n$ 的一个质因数），则 $g^\frac{\varphi(n)}{p}=g^{kx}=(g^x)^k \equiv 1 \pmod n$。**因此我们无需对所有 $i$ 进行检验，只需对 $\varphi(n)$ 的每个质因数 $p$ 检验 $g^\frac{\varphi(n)}{p} \bmod n$ 是否等于 $1$ 即可**，时间复杂度 $O(\sqrt n + \log^2 n)$（前半部分为分解质因数，后半部分为对每个质因数做一次快速幂）。

### 3. 一个数的原根有多少个？

由[裴蜀定理](https://oi-wiki.org/math/number-theory/bezouts/)可知，$a \perp m$ 是不定方程 $ax \equiv k \pmod m$ 当 $k$ 为任意小于 $m$ 的非负整数时均有解的充要条件。把这个结论运用到指数上，我们就得到了：**若 $g$ 为 $n$ 的原根，则 $a \perp \varphi(n)$ 是 $(g^a \bmod n)$ 为 $n$ 的原根的充要条件，因此若 $n$ 存在原根，则其原根数量为 $\varphi(\varphi(n))$**。

### 4. 如何求出一个数的所有原根？

$2$ 的原根只有 $1$，$4$ 的原根只有 $3$，特判掉较为方便。

王元院士早在 1959 年就证明过，**若 $n$ 存在原根，则其最小原根的数量级约在 $O(n^\frac{1}{4})$ 以下**，于是我们从 $2$ 开始枚举（$1$ 显然不可能是大于 $2$ 的数的原根），用第 2 节中的方法逐一判断是否为原根即可找到最小原根 $g_1$，该部分的复杂度是亚线性的。

接着根据第 3 节，只要找出 $(0,\varphi(n))$ 间所有与 $\varphi(n)$ 互质的数 $a$，$\{g_1^a \bmod n\}$ 即为 $n$ 的所有原根，排序后输出即可。找出与 $\varphi(n)$ 互质的数其实不需要 $\gcd$，可以用线性筛解决，搭配计数排序，完美的 $O(n)$！

### 5. 如何让代码更好写？

- 用 `__builtin_ctz` 获取 $n$ 二进制末尾 $0$ 的个数可以带来便利。

- $\varphi(n)$ 不必在分解过程中计算，代公式可知 $\varphi(n=p^k)=(p-1)p^{k-1}=\frac{(p-1)n}{p}$，$\varphi(n=2p^k)=(2-1)^{1-1}(p-1)p^{k-1}=\frac{(p-1)n}{2p}$，这时便可以利用前面求出的 $\operatorname{ctz}$ 来省去分类讨论的麻烦了。

- 用第 2 节中的方法判断是否为原根时，可使用 `std::any_of` 节省码量。

- 在线性筛的过程中用 `bitset` 标记原根，最后即可方便地使用 `count`、`_Find_first`、`_Find_next` 输出答案。

### $\text{Code}$

```cpp
#include <bits/extc++.h>

inline int qpow(long long a, int b, int mod) {
    long long res = 1;
    for (; b; b >>= 1, a = a * a % mod)
        if (b & 1)
            res = res * a % mod;
    return res;
}

int main() {
    int T;
    std::cin >> T;
    while (T--) {
        int n, d;
        std::cin >> n >> d;

        if (n == 2 || n == 4) {
            puts("1");
            if (d == 1)
                printf("%d", n - 1);
            putchar('\n');
            continue;
        }

        int num = n;
        int z = __builtin_ctz(num);
        if (z >= 2) {
            puts("0\n");
            continue;
        }
        num >>= z;

        // 对 n 分解质因数
        int k = 3;
        while (num % k && k * k <= num)
            k++;
        if (k * k > num)
            k = num;
        while (num % k == 0)
            num /= k;
        if (num != 1) {
            puts("0\n");
            continue;
        }

        // 对 phi(n) 分解质因数
        int phi = n / k * (k - 1) >> z;
        num = phi;
        std::vector<int> v;
        for (int i = 2; i * i <= num; i++)
            if (num % i == 0) {
                v.emplace_back(i);
                while (num % i == 0)
                    num /= i;
            }
        if (num != 1)
            v.emplace_back(num);

        // 查找最小原根
        int g = 2;
        while (qpow(g, phi, n) != 1 || std::any_of(v.begin(), v.end(), [&](int p) { return qpow(g, phi / p, n) == 1; }))
            g++;

        // 筛出与 phi(n) 互质的数，标记所有原根
        constexpr int N = 1e6;
        std::bitset<N> vis, ans;
        for (int i = 1, t = g; i < phi; i++, t = 1ll * t * g % n) {
            if (!vis[i])
                ans[t] = 1;
            for (int p : v) {
                if (1ll * i * p >= phi)
                    break;
                vis[i * p] = 1;
                if (i % p == 0)
                    break;
            }
        }

        // 输出答案
        printf("%d\n", ans.count());
        int i = ans._Find_first();
        for (int _ = d; --_;) // 这是重复 (d - 1) 次
            i = ans._Find_next(i);
        while (i != N) {
            printf("%d ", i);
            for (int _ = d; _--;) // 这是重复 d 次
                i = ans._Find_next(i);
        }
        putchar('\n');
    }
}
```

---

## 作者：WaterSun (赞：2)

## Part 1 阶

若 $a,m$ 互质，满足同余式 $a^n \equiv 1 \pmod m$ 的最小的 $n$ 被称为模 $m$ 意义下的阶，记作 $\delta_m(a)$。

### 性质 1

$a,a^2,\dots,a^{\delta_m(a)}$ 两两不同余。

证明

考虑反证法，当有一对不同的数 $i,j$ 满足 $1 \leq i < j \leq \delta_m(a)$ 且 $a^i \equiv a^j \pmod m$，因为 $\gcd(a,m) = 1$，那么一定有 $a^{j - i} \equiv 1 \pmod m$。

显然 $j - i < \delta_m(a)$，不满足题设。

证毕！

### 性质 2

若 $a^n \equiv 1 \pmod m$，则 $\delta_m(a) \mid n$。

证明

对 $n$ 作除以 $\delta_m(a)$ 的带余除法，得：$n = k \times \delta_m(a) + r$。

若 $\delta_m(a) \nmid n$，则有 $r > 0$。显然有：

$$
a^r \equiv a^r \times (a^{\delta_m(a)})^k \equiv 1 \pmod m
$$

因为 $r < \delta_m(a)$，所以只有当 $r$ 取 $0$ 时条件成立。

证毕！

### 性质 3

若 $\gcd(a,m) = \gcd(b,m) = 1$，则 $\delta_m(ab) = \delta_m(a) \times \delta_m(b)$ 的充分必要条件是 $\gcd(\delta_m(a),\delta_m(b)) = 1$。

证明

必要性：

由 $a^{\delta_m(a)} \equiv b^{\delta_m(b)} \equiv 1$ 得：

$$
(ab)^{\operatorname{lcm}(\delta_m(a),\delta_m(b))} \equiv 1 \pmod m
$$

根据性质 2，得：

$$
\delta_m(ab) \mid \operatorname{lcm}(\delta_m(a),\delta_m(b))\\
\Rightarrow \delta_m(a) \times \delta_m(b) \mid \operatorname{lcm}(\delta_m(a),\delta_m(b))\\
\Rightarrow \gcd(\delta_m(a),\delta_m(b)) = 1
$$

---

充分性：

由 $(ab)^{\delta_m(ab)} \equiv 1 \pmod m$ 得:

$$
1 \equiv (ab)^{\delta_m(ab) \times \delta_m(b)} \equiv a^{\delta_m(ab) \times \delta_m(b)} \pmod m\\
\Rightarrow \delta_m(a) \mid \delta_m(ab) \times \delta_m(b)
$$

结合 $\gcd(\delta_m(a),\delta_m(b))$ 可得：$\delta_m(a) \mid \delta_m(ab)$。同理可得，$\delta_m(b) \mid \delta_m(ab)$。因此有：

$$
\delta_m(a) \times \delta_m(b) \mid \delta_m(ab)
$$

另一方面有：

$$
(ab)^{\delta_m(a) \times \delta_m(b)} \equiv (a^{\delta_m(a)})^{\delta_m(b)} \times (b^{\delta_m(b)})^{\delta_m(a)} \equiv 1 \pmod m\\
\Rightarrow \delta_m(ab) \mid \delta_m(a) \times \delta_m(b)
$$

结合上述结论，可得 $\delta_m(ab) = \delta_m(a) \times \delta_m(b)$。

证毕！

### 性质 4

若 $a,m$ 互质，则：

$$
\delta_m(a^k) = \frac{\delta_m(a)}{\gcd(\delta_m(a),k)}
$$

证明

注意到：

$$
a^{k \times \delta_m(a^k)} = (a^k)^{\delta_m(a^k)} \equiv 1 \pmod m\\
\Rightarrow \delta_{m}(a) \mid k \times \delta_m(a^k)\\
\Rightarrow \frac{\delta_m(a)}{\gcd(\delta_m(a),k)} \mid \delta_m(a^k)
$$

由 $a^{\delta_m(a)} \equiv 1 \pmod m$ 可得：

$$
(a^k)^{\frac{\delta_m(a)}{\gcd(\delta_m(a),k)}} \equiv (a^{\delta_m(a)})^{\frac{\delta_m(a)}{\gcd(\delta_m(a),k)}} \equiv 1 \pmod m\\
\Rightarrow \delta_m(a^k) \mid \frac{\delta_m(a)}{\gcd(\delta_m(a),k)}
$$

因此得证。

证毕！

## Part 2 原根

若 $\gcd(g,m) = 1$，且满足 $\delta_m(g) = \varphi(m)$，则称 $g$ 为模 $m$ 意义下的原根。

当 $m$ 为质数时，有 $g^i \bmod m,0 < i < m$ 的结果互不相同。

### 原根判别定理

若 $\gcd(g,m) = 1$，则 $g$ 为模 $m$ 意义下的原根的充要条件是：对于 $\varphi(m)$ 的每一个质因子 $p$ 都有 $g^{\frac{\varphi(m)}{p}} \not\equiv 1 \pmod m$。

证明

因为如果有一个数 $x < \varphi(m)$，满足 $g^x \equiv 1 \pmod m$，则一定有 $x \mid \varphi(m)$。

又因为，$\varphi(m)$ 的因子都是由一些质因子累乘起来的，因此可以被质因子表示。

因此考虑枚举 $\varphi(m)$ 质因子的方式是正确的。

证毕！

### 原根个数

若一个数 $m$ 有原根，则它原根的数量为 $\varphi(\varphi(m))$。

证明

由上文的性质可得：

$$
\delta_m(g^k) = \frac{\delta_m(g)}{\gcd(\delta_m(g),k)} = \frac{\varphi(m)}{\gcd(\varphi(m),k)}
$$

所以，当 $\gcd(\varphi(m),k) = 1$ 时，有 $\delta_m(g^k) = \varphi(m)$。而满足条件的数的数量显然就是 $\varphi(\varphi(m))$。

证毕！

### 原根存在定理

一个数 $m$ 存在原根，当且仅当 $m = 2,4,p^k,2p^k$，其中 $p$ 是奇质数。

~~证明过于困难，笔者也不会。~~

### 最小原根范围估计

大约是在 $O(p^{0.25})$。

~~证明笔者还是不会/kk~~

## Part 3 找原根

现在你要找 $m$ 的原根，显然 $m$ 的所有原根都能由其最小原根 $g$ 累乘若干次得到。

因此考虑先找出 $m$ 的最小原根。首先根据上述结论，判断 $m$ 是否有原根，如果有就去找最小原根。

又根据上述最小原根的范围大约在 $O(p^{0.25})$，因此考虑枚举最小原根 $g$。

如果当前的 $g$ 满足 $\gcd(g,m) = 1$ 且满足 $\forall i \mid \varphi(m),g^{\frac{\varphi(m)}{i}} \not\equiv 1 \pmod m$，说明 $g$ 就是 $m$ 的最小原根。

接下来，根据上述性质，当 $g^k$ 是 $m$ 的原根时，当且仅当 $\gcd(k,\varphi(m)) = 1$，你直接枚举即可。

# Code


```cpp
#include <bits/stdc++.h>
#define re register
#define int long long

using namespace std;

const int N = 1e6 + 10;
int m,d,g;
int num,p[N],phi[N];
bool vis[N];

inline int read(){
    int r = 0,w = 1;
    char c = getchar();
    while (c < '0' || c > '9'){
        if (c == '-') w = -1;
        c = getchar();
    }
    while (c >= '0' && c <= '9'){
        r = (r << 3) + (r << 1) + (c ^ 48);
        c = getchar();
    }
    return r * w;
}

inline void init(){
    phi[1] = 1;
    vis[1] = true;
    for (re int i = 2;i <= 1e6;i++){
        if (!vis[i]){
            p[++num] = i;
            phi[i] = i - 1;
        }
        for (re int j = 1;j <= num && i * p[j] <= 1e6;j++){
            vis[i * p[j]] = true;
            if (i % p[j]) phi[i * p[j]] = phi[i] * (p[j] - 1);
            else{
                phi[i * p[j]] = phi[i] * p[j];
                break;
            }
        }
    }
}

inline int gcd(int a,int b){
    if (!b) return a;
    return gcd(b,a % b);
}

inline int qmi(int a,int b,int p){
    int res = 1;
    while (b){
        if (b & 1) res = res * a % p;
        a = a * a % p;
        b >>= 1;
    }
    return res;
}

inline bool check(int x){
    if (x == 2 || x == 4) return true;
    if (!(x & 1)) x >>= 1;
    if (!(x & 1)) return false;
    for (re int i = 2;i * i <= x;i++){
        if (x % i == 0){
            while (x % i == 0) x /= i;
            return (x == 1);
        }
    }
    return true;
}

inline void solve(){
    m = read(),d = read();
    if (!check(m)) return puts("0\n"),void();
    vector<int> pm;
    int t = phi[m];
    for (re int i = 2;i * i <= t;i++){
        if (t % i == 0){
            pm.push_back(i);
            while (t % i == 0) t /= i;
        }
    }
    if (t != 1) pm.push_back(t);
    for (re int x = 1;;x++){
        if (gcd(x,m) != 1) continue;
        bool falg = true;
        for (auto it:pm){
            if (qmi(x,phi[m] / it,m) == 1){
                falg = false;
                break;
            }
        }
        if (falg){
            g = x;
            break;
        }
    }
    vector<int> v;
    for (re int i = 1,mul = g;(int)v.size() < phi[phi[m]];i++,mul = mul * g % m){
        if (gcd(i,phi[m]) == 1) v.push_back(mul);
    }
    sort(v.begin(),v.end());
    printf("%lld\n",(int)v.size());
    for (re int i = d - 1;i < (int)v.size();i += d) printf("%lld ",v[i]);
    puts("");
}

signed main(){
    init();
    int T;
    T = read();
    while (T--) solve();
    return 0;
}
```

---

## 作者：NaN_HQJ2007_NaN (赞：2)

题解太高深，自己整理一份。

**阶的定义：** 若 $\gcd(a,m)=1$，则使 $a^l\equiv1\pmod{m}$ 的最小的 $l$ 称为 $a$ 关于模 $m$ 的阶，记为 $\operatorname{ord}_m a$。

**阶的性质：**

根据欧拉定理，$a^{\varphi(m)}\equiv 1\pmod{m}$，所以 $\operatorname{ord}_m a\mid \varphi(m)$。

进一步的，若 $a^x\equiv1\pmod{m}$，则 $\operatorname{ord}_m a\mid x$。

由此可见，阶相当于最小循环节。

证明： $\operatorname{ord}_m a^t=\frac{\operatorname{ord}_m a}{\gcd(\operatorname{ord}_m a,t)}$。

设 $\operatorname{ord}_m a^t=l$，则 $a^{t\cdot l}\equiv1\pmod{m}$。

因为 $\operatorname{ord}_m a\mid t\cdot l$，$t\mid t\cdot l$，所以 $t\cdot l=\operatorname{lcm}(\operatorname{ord}_m a,t)$。

所以 $l=\frac{\operatorname{lcm}(\operatorname{ord}_m a,t)}{t}=\frac{\operatorname{ord}_m a\cdot t}{\gcd(\operatorname{ord}_m a,t)\cdot t}=\frac{\operatorname{ord}_m a}{\gcd(\operatorname{ord}_m a,t)}$。

**原根的定义：** 当 $\operatorname{ord}_m a=\varphi(m)$ 时，称 $a$ 为关于 $m$ 的原根。

**原根的性质：**

只有 $1,2,4,p_i,2\cdot p_i$ 有原根，其中 $p_i$ 为奇素数。

当 $g$ 为原根时 $g,g^2,g^3,...,g^{\varphi(m)}$ 构成模 $m$ 意义下的既约剩余系，而因为 $\gcd(g,m)=1$，所以 $\gcd(g^x,m)=1$，且剩余系中的各个数互不相等。

考虑反证法。若有两个数 $g^x,g^y$ 相等，则说明 $g^{y-x}\equiv1\pmod{m}$，由于 $y-x<\varphi(m)$，所以 $g$ 不为原根，矛盾。

那么，可能的原根只能在 $g,g^2,g^3,...,g^{\varphi(m)}$ 中。

如果 $g^t$ 满足 $\operatorname{ord}_m g^t=\varphi(m)$，则 $\frac{\operatorname{ord}_m g}{\gcd(\operatorname{ord}_m g,t)}=\varphi(m)$，即 $\frac{\varphi(m)}{\gcd(\varphi(m),t)}=\varphi(m)$。所以当且 $\gcd(t,\varphi(m))=1$ 时，$g^t$ 为 $m$ 的原根。

**如何求 $g$:**

显然，$g^{\varphi(m)}\equiv1\pmod{m}$ 且不存在 $x<\varphi(m)$ 满足 $g^x\equiv1\pmod{m}$。

而如果存在这样的 $x$，则必然有 $x\mid \varphi(m)$。

所以我们可以通过质因数分解找到 $\varphi(m)$ 的所有质因子 $p_i$，枚举每一个 $p_i$ 判断 $g^{\frac{\varphi(m)}{p_i}}\equiv1\pmod{m}$ 即可。

**具体实现：**

1. 线性筛素数，预处理 $\varphi$ 函数，$O(n)$。

2. 分解 $\varphi(n)$，$O(\sqrt n)$。

3. 枚举找到 $g$，$O(n^{0.25}\log^2 n)$。

4. 找出所有原根并排序，$O(n\log n)$。

综上，复杂度 $O(Tn\log n)$。

**code:**

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e6+5;
int T,n,d,p[N],phi[N],cnt=0,tot=0,ans[N];
bool vis[N],rt[N];
vector<int>yin;
void init(){
  phi[1]=1;
  for(ll i=2;i<N;++i){
    if(!vis[i]){
      p[++cnt]=i;
      phi[i]=i-1;
    }
    for(int j=1;j<=cnt&&i*p[j]<N;++j){
      vis[i*p[j]]=1;
      if(i%p[j]==0){
        phi[i*p[j]]=phi[i]*p[j];
        break;
      }
      phi[i*p[j]]=phi[i]*(p[j]-1);
    }
  }
  rt[2]=rt[4]=1;
  for(int i=2;i<=cnt;++i){
    for(ll j=p[i];j<N;j*=p[i])rt[j]=1;
    for(ll j=p[i]*2;j<N;j*=p[i])rt[j]=1;
  }
}
void fen(int x){
  for(ll i=2;i*i<=x;++i){
    if(x%i==0){
      yin.push_back(i);
      while(x%i==0)x/=i;
    }
  }
  if(x>1)yin.push_back(x);
}
int ksm(ll x,ll y){
  ll res=1;
  while(y){
    if(y&1)res=res*x%n;
    y>>=1;
    x=x*x%n;
  }
  return res;
}
int getg(){
  for(int i=1;i<=n;++i){
    if(ksm(i,phi[n])!=1)continue;
    bool flag=1;
    for(int j=0;j<yin.size();++j){
      if(ksm(i,phi[n]/yin[j])==1){
        flag=0;
        break;
      }
    }
    if(flag)return i;
  }
}
int gcd(int x,int y){return y?gcd(y,x%y):x;}
int main(){
  cin>>T;
  init();
  while(T--){
    scanf("%d%d",&n,&d);yin.clear();tot=0;
    if(rt[n]){
      fen(phi[n]);
      ll g=getg();
      ll fac=1;
      for(int i=1;i<=phi[n];++i){
        fac=fac*g%n;
        if(gcd(i,phi[n])==1)ans[++tot]=fac;
      }
      sort(ans+1,ans+tot+1);
    }
    printf("%d\n",tot);
    for(int i=d;i<=tot;i+=d)printf("%d ",ans[i]);
    cout<<endl;
  }
  return 0;
}

```


---

## 作者：王大神——A001 (赞：2)

## 阶

$$a^r\equiv 1(\mod m)$$

当 $r$ 是最小的实数使得 $a^r\equiv1(\mod m)$ 成立。

那么 $r$ 是模 $m$ 意义下，$a$ 的阶。记作：

$$\delta_m(a)=r$$

## 原根
[传送门](https://www.luogu.com.cn/problem/P6091)

而如果 $r=\varphi
(m)$ 那么 $a$ 是模 $m$ 的一个原根。也就是说：

$$a^{\varphi(m)}\equiv 1(\mod m)$$

且 $x\in[1,\varphi(m)-1]$：$a^x\not=1(\mod m)$

为了熟悉原根。我们先做几个题：

- $1$ 是模 $2$ 的原根。

- 求模 $3$ 的原根：

$$\because 2^2\equiv1(\mod m)$$

$$\because \varphi(3)=2$$

$$\therefore \delta_3(2)=2$$

$2$ 是模 $3$ 的原根。

- 求模 $4$ 的原根：

$$\delta_4(3)=2=\varphi(4)$$

$3$ 是模 $4$ 的原根。

（重申一下：等式中间的 $2$ 代表的是 $3$ 的 $2$ 次幂模 $4$ 等于 $1$。）

- 模 $5$ 的原根是 $2$：

$$\delta_5(2)=4=\varphi(5)$$

（$2$ 的 $4$ 次幂模 $5$ 等于 $1$。）

- 求模 $8$ 的原根：

设 $a$ 是素数，有 $a^2\equiv 1(\mod 8)$，但是 $\delta_8(a)=1$ 或 $2 < \varphi(8)=4$ 所以，模 $8$ **没有原根**。

注意：这里有一个性质：**原根一定和模数互质**（否则模的结果一定不为 $1$）。

### 原根性质

- 我们上面已经知道有些数是没有原根的，有原根的数：

$$2,4,p^k,2\times p^k$$

其中 $p$ 是**奇素数**。只有这些数有原根。

- 一个数如果存在原根，那么它有 $\varphi(\varphi(n))$ 个原根。

- 素数一定有原根。

- 对于阶 $r$，$a^0,a^1,…,a^{r-1}$ 模 $n$ 两两不同余；当 $a$ 是原根时，$a_0,a_1,…,a^{\delta-1}$ 是模 $n$ 的简化剩余系；当 $n$ 是质数时，$a^0,a^1,…,a^{\delta-1}$ 对 $n$ 取模后对应为 ${1,2,…,n-1}$。

- 如果我们有了最小原根 $r$（$\delta_n(r)=\varphi(n)$），那么 $x\in[1,\varphi(n)],\gcd(x,\varphi(n))=1$，$r^x\mod n$ 都是 $n$ 的原根。

如何求最小原根？

暴力枚举，假设现在枚举到了 $k$，那么首先 $\gcd(k,n)=1$，然后对于每个 $x\mid \varphi(n)$，$k^x\not\equiv 1(\mod n)$。

那么在我们找完 $\varphi(n)$ 的所有质因子后，如果当前枚举的数可以对于所有的质因子 $p_i$ 满足：$k^{\frac{n}{p_i}}\not\equiv1(\mod n)$。那么 $k$ 就是一个原根。

如果我们刚刚是从小到大枚举的那么 $k$ 就是 $n$ 的最小原根。后面我们就直接枚举它的幂判断是否与 $\varphi(n)$ 互质就可以统计了。

如果 $x\equiv1(\mod n)$，那么 $x^2\equiv1(\mod n)$，其他次幂同理，但是在枚举次幂的同时，注意判断和 $\varphi(n)$ 互质。

而和 $\varphi(n)$ 互质的数共有 $\varphi(\varphi(n))$ 个，这也就是为什么一个数有原根，那么就有 $\varphi(\varphi(n))$ 个原根。

### 代码思路

- 读取所有询问（离线处理）。

- 线性筛素数，[处理欧拉函数](https://wdsa001.github.io/2021/12/16/mo-bi-wu-si-fan-yan-du-jiao-shai-min-25-shai/#toc-heading-5)，标记有原根的数有哪些。

- 处理 $\varphi(n)$ 的质因数，标记所有和它不互质的数。

- 枚举最小原根。

- 统计原根，根据题目要求输出。

### 代码

```cpp
#include<iostream>
#include<cstdlib>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<algorithm>
#include<queue>
#include<vector>
#include<stack>
using namespace std;
long long r_r(){//快读 
	long long k=0,f=1;
	char c=getchar();
	while(!isdigit(c)){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(isdigit(c)){
		k=(k<<1)+(k<<3)+(c^48);
		c=getchar(); 
	}
	return k*f;
}
const int o_o=1e6+10;
int z_z[o_o];//存质数 
int x_z;//质数个数下标 
int p_i[o_o];//欧拉函数 
bool b_b[o_o];//合数判断 

int f_i[9];//分解每个数 
int u_i[11],v_i[11];//读入信息 
bool f_b[o_o];//标记当前数是否有原根 
bool b_i[o_o];//标记是否是当前询问的数的欧拉函数的因子的倍数 
bool o_i[o_o];//标记是否是结果 
void yv(int n){
	f_b[2]=f_b[4]=p_i[1]=1;
	for(int i=2;i<=n;i++){//线筛 
		if(!b_b[i]){//没有舍去是质数 
			z_z[++x_z]=i;//记录质数 
			p_i[i]=i-1;//记录欧拉函数 
		}
		for(int j=1;j<=x_z&&i*z_z[j]<=n;j++){//筛 
			b_b[i*z_z[j]]=1;//标记合数 
			if(i%z_z[j]==0){//已经有当前因子，直接退出 
				p_i[i*z_z[j]]=p_i[i]*z_z[j];//已经贡献过，直接乘 
				break;
			}
			p_i[i*z_z[j]]=p_i[i]*p_i[z_z[j]];//欧拉函数是奇性函数 
		} 
	}
	for(int i=2;i<=x_z;i++){//标记所有有原根的实数 
		for(int j=1;1ll*j*z_z[i]<=n;j*=z_z[i])f_b[j*z_z[i]]=1;
		for(int j=2;1ll*j*z_z[i]<=n;j*=z_z[i])f_b[j*z_z[i]]=1;
	}
}
int k_m(int a,int b,int m_d){//快速幂 
	int r_s=1;
	while(b){
		if(b&1)r_s=1ll*r_s*a%m_d;
		a=1ll*a*a%m_d;
		b>>=1;
	}
	return r_s;
}
int main(){
	int t=r_r(),m_x=0;
	for(int i=1;i<=t;++i){//离线做法 
		u_i[i]=r_r();
		v_i[i]=r_r();
		m_x=max(m_x,u_i[i]);//记录最大值 
	}
	yv(m_x);//预处理质数，欧拉函数，原根 
	for(int k_i=1;k_i<=t;++k_i){//处理每个询问 
		
		//获取当前询问的值 
		int n=u_i[k_i];
		int d=v_i[k_i];
		if(!f_b[n]){//没有原根 
			puts("0\n");
			continue;
		}
		int k_k=p_i[n];//记录欧拉函数 
		int x_f=0;
		for(int i=1;z_z[i]*z_z[i]<=k_k;i++){//分解质因数 
			if(!(k_k%z_z[i])){//可以整除 
				f_i[++x_f]=z_z[i];//记录质因子 
				while(!(k_k%z_z[i]))k_k/=z_z[i];//将当前质因子除干净 
				for(int k=z_z[i];k<=p_i[n];k+=z_z[i])b_i[k]=1;
				//当前质因子范围内所有倍数标记（后面要保证互质） 
			}
		}
		if(k_k>1){//还一个大质因子 
			f_i[++x_f]=k_k;//记录 
			for(int k=k_k;k<=p_i[n];k+=k_k)b_i[k]=1;//标记 
		}
		
		int x_i=0;//最小原根 
		while(++x_i){
			while(k_m(x_i,p_i[n],n)!=1)x_i++;//枚举找原根 
			int x_x=1;
			while(x_x<=x_f&&k_m(x_i,p_i[n]/f_i[x_x],n)!=1)x_x++;
			if(x_x>x_f)break;//是原根 
		}
		int t_i=1,s_m=0;
		for(int i=1;i<=p_i[n];i++){//统计所有原根 
			t_i=1ll*t_i*x_i%n;//计算原根 
			if(!b_i[i])o_i[t_i]=1,s_m++;//和 n 的欧拉函数互质，统计结果 
			else b_i[i]=0;//不互质 
		}
		printf("%d\n",s_m);//输出原根统计的结果 
		int o_t=0;//统计是第几个合法的数 
		for(int i=1;i<n;i++){ 
			if(o_i[i]){//可以统计 
				o_t++;//累计 
				if(o_t==d){//达到要求 
					printf("%d ",i);//输出 
					o_t=0;//累计清空 
				}
				o_i[i]=0;//清空标记 
			}
		}
		puts("");
	}
	return 0;
}
```


---

## 作者：hqyang (赞：1)

## 前置知识:
### 阶
#### 定义：
满足同余式子  $a^n\equiv1(\bmod {m})$  的最小正整数 $n$ 存在，就称 $n$ 为 $a$ 模 $m$ 的阶，记作 $\ \delta_m(a)$。
#### 性质：
1. $a,a^2,a^3,...,a^{\delta_m(a)}$ 模 $m$ 两两不互余。

2. 若 $a^n\equiv1\ (\bmod \ m) $，则 $\delta_m(a)\ \mid\ n$。

3. 设 $m \in \mathbf{N}^+  \ \ a,b \in \mathbf{Z},\gcd(a,m)=\gcd(b,m)=1$，
   有 $\delta_m(a,b)=\delta_m(a)\times\delta_m(b)\ $ 的充分必要条件是$\ \gcd(\delta_m(a),\delta_m(b))=1$。
4. 设 $k\in \mathbf{N}^\ \ m\in \mathbf{N}^+,a\in \mathbf{Z},\gcd(a,m)=1$，则 $\delta_m(a^k)= \frac{ \delta_m(a) }{\gcd(\delta_m(a),k)}$。

### 原根
#### 定义：
若 $m\in\mathbf{N}^+,g \in \mathbf{Z}$，$\gcd(g,m)=1$，且 $\delta_m(g)=\phi(m)$，则称 $g$ 为模 $m$ 的原根。

#### 存在定理：
一个数 $m$ 存在原根当且仅当 $m=2,4,p^a,2p^a$, $p$ 为奇素数，$a\in \mathbf{N}^+$。

#### 判定定理：
设 $m \geq 3$，且 $\gcd(m,g)=1$，则 $g$ 为模 $m$ 的原根的充分必要条件是：
对于 $\phi(m)$ 的每个素因子 $p$，都有
$$ g^{\ \frac{\phi(m)}{p} } \ \not\equiv 1(\bmod m) $$  


#### 原根个数：
若一个数有原根，则它的原根的个数为           $\phi(\phi(m))$，
     
如对证明感兴趣可以去 oi wiki 上查看[关于阶和原根及其定理的证明](https://oi-wiki.org//math/number-theory/primitive-root/)
，取自 oi wiki。
### 扩充：
若 $a,m$ 互质，$a^{\phi(m)}\equiv\ 1(\bmod\ m)$
，由于在模 $m$ 的意义下，因为 $a^{\phi(m+1)}$ 又回到了 $a^1$。所以 $a^1,a^2\cdot\cdot\cdot\cdot$ 这样的序列将有一个长度为 $\phi(m)$ 的**循环节**，
我们把最短循环节的长度定义为 $a$ 在模 $m$ 下的**阶**  $(\delta_m(a))$。


------------

## 题意及主要思路：
题目很简单，就是求数 $n$ 的所有原根，通过原根判断定理，我们可以先求出最小原根，因为其满足原根判断定理，设模 $m$ 意义下有原根，枚举  $\phi(m)$ 以内的正整数 $g^x$，并且 $\gcd(x,\ \phi(m))=1$，以此求出所有原根。

### 求解步骤：
1.初始化值域范围内的欧拉函数（线性筛）
时间复杂度 $O(n)$。

2.通过原根存在定理判断是否存在原根。

3.通过求出 $\phi(m)$ 的所有素因子，设为 $j$，通过原根定义找出与 $m$ 互质的数 $s$，再通过原根判断定理判断枚举的 $s$ 是否符合 $s^{ \tfrac{\phi(m)}{j}}\not\equiv\ 1\ (\bmod\ m)$。

4.通过最小原根找出所有原根。
### code
```c
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N=1e6+10;
int phi[N],prime[N];
bool st[N];
int cnt,T;
vector<int>q,ans;

void euler_phi(int n){//初始化欧拉函数 
	phi[1]=1;
	for(int i=2;i<=n;i++){
		if(!st[i]){
			prime[++cnt]=i;
			phi[i]=i-1;
		}
		for(int j=1;prime[j]<=n/i;j++){
			st[prime[j]*i]=true;
			if(i%prime[j]==0){
				phi[i*prime[j]]=phi[i]*prime[j];
				break;
			}
			phi[i*prime[j]]=phi[i]*(prime[j]-1);
		}
	}
}

LL ksm(LL a,int b,int p){//用来找最小原根 
	LL res=1;
	while(b){
		if(b&1)res=res*a%p;
		a=a*a%p;
		b>>=1;
	}
	return res;
}

void cut_prime(int n){//分解数的欧拉函数用于找最小原根 
	for(int i=2;i<=n/i;i++){
		if(n%i==0){
			q.push_back(i);
			while(n%i==0)n/=i;
		}
	}
	if(n>1)q.push_back(n);
}

bool pd(int n){
	if(n==2||n==4)return true;
	if(n%2==0)n/=2;
	for(int i=2;prime[i]<=n;i++){//若有原根则有唯一的质数分解 
		if(n%prime[i]==0){
			while(n%prime[i]==0)n/=prime[i];
			return n==1;
		}
	}
	return false;
}

int main(){
	euler_phi(N);//初始化所有数的欧拉函数 
	cin>>T;
	for(int i=1;i<=T;i++){
		int n,d;scanf("%d%d",&n,&d);
		if(pd(n)){
			q.clear();ans.clear();
			cut_prime(phi[n]);
			int need;LL last=1;//指数 
			for(int k=1;;k++){
				bool flag=true;
				if(__gcd(k,n)!=1)continue;
				for(int j=0;j<q.size();j++){
					if(ksm(k,phi[n]/q[j],n)==1){
						flag=false;
						break;
					}
				}
				if(flag){
					need=k;//最小原根 
					break;
				}
			}
			for(int k=1;ans.size()<phi[phi[n]];k++){
				last=last*need%n;
				if(__gcd(phi[n],k)==1)ans.push_back(last);
			}
			sort(ans.begin(),ans.end());
			printf("%d\n",phi[phi[n]]);//原根个数
			for(int k=d-1;k<phi[phi[n]]/d*d && k<ans.size();k+=d){
				printf("%d ",ans[k]);
			} 
			cout<<endl;
		} 
		else puts("0\n");
	}
	return 0;
}
```


---

## 作者：Yanami_Anna (赞：1)

upd on 2023.12.1：修改了原根定义的错误。

[板子](https://www.luogu.com.cn/problem/P6091)

## 阶

如果 $a^b\equiv1\pmod m$，如果 $b$ 是满足这个式子的最小值，那么我们称 $a$ 模 $m$ 的阶为 $b$，也可以写作 $\delta_m\left(a\right)$。

**性质 $1$：$a^1,a^2,a^3,\dots,a^{\delta_m\left(a\right)}$ 模 $m$ 后互不相同。**

证明：反证，若 $i<j<\delta_m(a)$ 且 $a^i \equiv a^j\pmod m$，则 $a^{j-i}\equiv 1(\mod m)$，又因为 $j-i<\delta_m(a)$，所以与 $\delta_m(a)$ 的最小性矛盾。

**性质 $2$：若 $a^n\equiv 1\pmod m$，则 $\delta_m(a)|n$。**

证明：反证，如果不是，则 $a^n=a^{\delta_m(a)\times q+r}\ \ [r<\delta_m(a)]$，又因为 $a^{\delta_m(a)}\equiv 1$，所以 $a^r\equiv 1$，与 $\delta_m(a)$ 的最小性矛盾。

**性质 $3$：若 $\gcd(a,m)=\gcd(b,m)=1$，则 $\delta_m(a)\delta_m(b)=\delta_m(ab)$ 成立的充分必要条件是 $\gcd(\delta_m(a),\delta_m(b))=1$。**

证明：

必要性：

因为 $a^{\delta_m(a)}\equiv b^{\delta_m(b)}\equiv1\pmod m$。

所以 $(ab)^{\operatorname{lcm}(\delta_m(a),\delta_m(b))}\equiv1\pmod m$。

又因为性质 $2$，所以 $\delta_m(ab)|\operatorname{lcm}(\delta_m(a),\delta_m(b))$。

所以 $\delta_m(a)\delta_m(b)|\operatorname{lcm}(\delta_m(a),\delta_m(b))$。

又因为 $\delta_m(a)\delta_m(b)=\operatorname{lcm}(\delta_m(a),\delta_m(b))\operatorname{gcd}(\delta_m(a),\delta_m(b))$。

所以 $\operatorname{gcd}(\delta_m(a),\delta_m(b))=1$。

充分性：

因为 $(ab)^{\delta_m(ab)}\equiv1\pmod m$，所以$(ab)^{\delta_m(ab)\delta_m(b)}\equiv1$，所以 $a^{\delta_m(ab)\delta_m(b)}\equiv1$，所以 $\delta_m(a)|\delta_m(ab)\delta_m(b)$，又因为 $\gcd(\delta_m(a),\delta_m(b))=1$，所以$\delta_m(a)|\delta_m(ab)$。

反过来操作一遍得到 $\delta_m(b)|\delta_m(ab)$。

又因为$\gcd(\delta_m(a),\delta_m(b))=1$，所以 $\delta_m(a)\delta_m(b)|\delta_m(ab)$。

又因为 $(ab)^{\delta_m(a)\delta_m(b)}=(a^{\delta_m(a)})^{\delta_m(b)}(b^{\delta_m(b)})^{\delta_m(a)}\equiv1\pmod m$

所以 $\delta_m(ab)|\delta_m(a)\delta_m(b)$。

综上，$\delta_m(a)\delta_m(b)=\delta_m(ab)$。

**性质 $4$：若 $\gcd(a,m)=1$，则 $\delta_m(a^k)=\frac{\delta_m(a)}{\gcd(\delta_m(a),k)}$。**

证明：

$a^{k\delta_m(a^k)}=(a^k)^{\delta_m(a^k)}\equiv1\pmod m$。

所以 $\delta_m(a)|k\delta_m(a^k)$，所以 $\frac{\delta_m(a)}{\gcd(\delta_m(a),k)}|\delta_m(a^k)$。

而 $(a^k)^{\frac{\delta_m(a)}{\gcd(\delta_m(a),k)}}=(a^{\delta_m(a)})^{\frac{k}{\gcd(\delta_m(a),k)}}\equiv1\pmod m$。

所以 $\delta_m(a^k)|\frac{\delta_m(a)}{\gcd(\delta_m(a),k)}$。

综上，$\delta_m(a^k)=\frac{\delta_m(a)}{\gcd(\delta_m(a),k)}$。

接下来切入正题。

## 原根

原根：若 $\varphi(m)=\delta_m(a)$，则称 $a$ 是 $m$ 的原根。

**原根判定定理：若 $m\geqslant3$ 且 $\gcd(a,m)=1$，则 $a$ 是 $m$ 的原根的充分必要条件是对于 $\varphi(m)$ 的每一个质因数 $p$，都有 $a^{\frac{\varphi(m)}{p}}\not\equiv 1\pmod m$。**

**原根个数：若一个数有原根，则原根个数为 $\varphi(\varphi(m))$。**

证明：设 $m$ 有原根 $a$，则 $\delta_m(a^k)=\frac{\delta_m(a)}{\gcd(\delta_m(a),k)}=\frac{\varphi(m)}{\gcd(\varphi(m),k)}$。

考虑如果 $k$ 与 $\varphi(m)$ 互质，那么 $\delta_m(a^k)=\varphi(m)$，即 $a^k$ 为模 $m$ 意义下的原根。

根据性质 $1$，$k$ 又要满足 $k\leqslant \varphi(m)$，又要满足 $\gcd(k,\varphi(m))=1$，所以这样的 $k$ 有 $\varphi(\varphi(m))$ 个。

**原根存在定理：若一个数 $m$ 有原根，当且仅当 $m=2,4,p^{\alpha},2p^{\alpha}$，其中 $p$ 为奇素数。**

王元大师证明了若 $m$ 有原根，则最小原根最大不超过 $m^{\frac{1}{4}}$，这告诉我们枚举最小原根是可行的。

来到板子题，他要求我们求出原根个数并且输出他们，个数我们知道就是 $\varphi(\varphi(m))$，怎么输出他们呢，考虑枚举最小原根 $g$，预处理出所有 $\varphi(m)$，然后直接枚举 $k$，如果 $\varphi(m)$ 与 $k$ 互质就直接记录，最后排个序直接输出就行。

[代码](https://www.luogu.com.cn/paste/i9xtnxxe)

---

## 作者：ChuYilin2011 (赞：0)

这道题就记这些：

- 对一正整数 $n$，当且仅当 $n=2,4,p^\alpha,2p^\alpha$（$p$ 为一奇素数，$\alpha$ 是正整数）时，$n$ 有原根。（有题解说 $1$ 也有，但题中已经说 $1\le g\le n-1$ 了，好像不太对。）
- 对一有原根的正整数 $n$，其最小原根不超过 $n^{0.25}$ 级别。
- 对一有原根的正整数 $n$，设最小原根为 $g$，取正整数 $\alpha\ (\gcd(\alpha,\varphi(n))=1)$，那么 $g^\alpha$ 也是 $n$ 的原根。

具体怎么证，楼上 dalao 已经说过了。

所以，先预处理出所有有原根的数，以及 $\varphi$ 值。然后在每一次询问中，先找最小原根，再通过最小原根找所有原根。

对了，最小原根 $g$ 除了要满足 $g^{\varphi(n)}\equiv1\pmod n$ 以外，注意看阶的定义中**最小**二字，所以 $g$ 还要满足对于任意小于 $\varphi(n)$ 的正整数 $k$，有 $g^k\not\equiv1\pmod n$。而我们不可能直接枚举 $k$。

这就牵扯到阶的一个性质：

> 若 $a^n\equiv1\pmod m$，则 $\delta_m(a)|n$。

这里给出证明：令 $n=q\delta_m(a)+r(q,r\in\mathbb{N}^* ,0\le r<\delta_m(a))$（就是带余除法的意思）。采用反证法，若 $r>0$，由 $a^{\delta_m(a)}\equiv1\pmod m$ 得

$$a^r\equiv a^r(a^{\delta_m(a)})^q\equiv a^n\equiv1\pmod p$$

即 $a^r\equiv1\pmod m$。但有 $\delta_m(a)>r$，与阶的最小性矛盾，故 $r=0$，此时 $\delta_m(a)|n$。

又由 $a^{\varphi(m)}\equiv1\pmod m$，则由该性质得 $\delta_m(a)|\varphi(m)$ 恒成立。

回到正题，那么 $\delta_n(g)|\varphi(n)$。于是，我们只需要检验 $\varphi(n)$ 的真因子即可。

再进一步，我们可以得到 $\varphi(n)$ 的标准分解，设其为 $\prod_{i=1}p_i^{\alpha_i}$。那么检验所有的 $\dfrac{\varphi(n)}{p_i}$ 即可，因为其所有真因子的倍数都包含在里面了。

这样就能以 $O(n^{0.25}\log n)$ 的时间复杂度得出最小原根，然后按上面所说的写就行了。总时间 $O(T(n^{0.25}\log n+\varphi(n)\log n))$（第二个 $\log$ 用在求 $\gcd$ 中）。

---

## 作者：Z1qqurat (赞：0)

你好，我不是很会原根，阶那一套结论，但是我感性证明了一下原根判定定理。思路简单，代码好写。证明是口糊的我数论不好如果有错的话请在评论区告诉我，谢谢！



首先明确阶的定义和一个简单小性质：一个数模 $m$ 的阶 $\delta_m(a)$ 定义为最小的正整数 $x$ 使得 $a^x \equiv 1 \pmod m$。

那么 $a^1, a^2, \dots, a^{\delta_m(a)}$ 模 $m$ 两两不同余。这个很好证，如果有 $0 < x < y<\delta_m(a)$ 使得 $a^x\equiv a^y \pmod m$，那么 $a^{y-x}\equiv 1 \pmod m$，$y-x$ 肯定比 $\delta_m(a)$ 小，矛盾了，证完了。

那么原根是什么？对于 $m$，若 $\gcd(g,m)=1, 0\le g < m, < \delta_m(g) = \varphi(m)$，那么 $g$ 为模 $m$ 的原根。

原根怎么判定？如果 $g$ 满足 $g ^ {\varphi(m)} \equiv 1 \pmod m$，且对于任意素数 $p\mid \varphi(m)$，都有 $g^{\frac{\varphi(m)}{p}} \not\equiv 1 \pmod m$，那么 $g$ 为模 $m$ 的原根。

为什么？首先肯定必要，因为最朴素的验证方式就是枚举每个 $<\varphi(m)$ 的数，然后看它是不是 $g$ 的阶。我们考虑证明为什么只用枚举 $\frac{\varphi(m)}{p}$：如果 $\frac{\varphi(m)}{p}$ 都不是 $g$ 的阶，那么 $\frac{\varphi(m)}{pq}$ 也不可能为阶，其中 $p, q$ 都是 $\varphi(m)$ 的质因数。

考虑反证法，如果 $\frac{\varphi(m)}{p}$ 不是 $g$ 的阶，且 $\frac{\varphi(m)}{pq}$ 是阶。发现 $g^{\frac{\varphi(m)}{p}} = g^{\left({\frac{\varphi(m)}{pq}}q\right) } \equiv g^q \pmod m$，那么由于阶的那个小性质，$\frac{\varphi(m)}{p} = q$，即 $\varphi(m) = pq$。所以 $g^{\frac{\varphi(m)}{pq}} \equiv g \equiv 1 \pmod m$，那么 $g^{\frac{\varphi(m)}{p}} \not\equiv 1 \pmod m$ 就矛盾了。证毕。

于是我们求出最小原根 $g$ 之后，如果 $\gcd(k, \varphi(m))=1$，那么 $g^k \mod m$ 也是模 $m$ 的原根。当然原根一共至多 $\varphi(\varphi(m))$ 个，求完之后排下序输出就行了。

代码不难写，你说对不对！！！

```cpp
#include <bits/stdc++.h>
#define ALL(v) begin(v), end(v)
using i64 = int64_t;
using std::cin;
using std::cout;
constexpr int N = 1e6 + 5;

int n, m, c, d, phi;
std::array<int, N> g, a;

auto qpow(int x, int y) {
   auto ret{1};
   for (; y; x = 1ll * x * x % n, y >>= 1) 
      if (y & 1) ret = 1ll * ret * x % n;
   return ret;
}

auto getphi(int x) {
   int lim = sqrt(x), ret = x;
   for (auto i = 2; i <= lim; ++i) {
      if (x <= 1) break;
      if (x % i) continue;
      ret = ret / i * (i - 1);
      while (!(x % i)) x /= i;
   }
   if (x > 1) ret = ret / x * (x - 1);
   return ret;
}

auto check(int x) {
   if (qpow(x, phi) != 1) return 0;
   for (auto i = 1; i <= m; ++i)
      if (qpow(x, a[i]) == 1) return 0;
   return 1;
}

auto solve() {
   cin >> n >> d;
   c = m = 0, phi = getphi(n);
   auto x{phi};
   for (auto i = 2; i * i <= phi; ++i) {
      if (x <= 1) break;
      if (x % i) continue;
      a[++m] = phi / i;
      while (!(x % i)) x /= i;
   }
   if (x > 1) a[++m] = phi / x;

   for (auto i = 1; i <= n; ++i)
      if (check(i)) { g[++c] = i; break;}
   if (c && g[1] != 1) {
      auto mi{g[1]}, lim{getphi(phi)};
      for (auto k = 2; k <= n && c < lim; ++k) {
         mi = 1ll * mi * g[1] % n;
         if (std::__gcd(k, phi) == 1) g[++c] = mi;
      }
   }
   std::sort(&g[1], &g[c + 1]);
   cout << c << "\n";
   for (auto i = 1; i <= c / d; ++i) cout << g[i * d] << ' ';
   cout << "\n";
   return ;
}

auto main() -> int {
   std::ios::sync_with_stdio(false);
   cin.tie(nullptr), cout.tie(nullptr);

   auto t{0}; cin >> t;
   while (t--) solve();
   return 0;
}

---


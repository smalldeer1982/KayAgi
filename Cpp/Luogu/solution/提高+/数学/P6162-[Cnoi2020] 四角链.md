# [Cnoi2020] 四角链

## 题目背景

> 四角链图是一种常见的四角网络，属于仙人掌图，通常不会出现在重掺杂单晶尾部的横截面上，呈现的一组其外围是杂质富集条纹的封闭的不是四角环状网络。但因为其复杂的特点，所以常出现在描述社群联系的情景中，例如一些众所周知不可描述的......

作为一个聪明活泼的女孩子，Cirno 厌倦了教科书式冗长乏味的概念，直接给出了四角链图的图示。

![](https://cdn.luogu.com.cn/upload/image_hosting/38vmj7jc.png)

## 题目描述

事实上四角链可以抽象为 $1\times (n - 1)$ 网格，每个格子被分别编号为 $1$, $2$, .... , $n-1$。

每个格子可以有两种选择 :
 - 不填数
 - 填入一个小于或等于自己编号的正整数

当一种填数方案 **不存在两个格子填的数相同** 时，Cirno 称之为合法方案。

Cirno 想知道有且仅有 $k$ 个格子填入了数字的合法方案数对 $998244353$ 取模后的结果。

## 说明/提示

### 数据范围约定

**「本题采用捆绑测试」**

 - Subtask1( $20\%$ ) : $n,k \le 10$
 - Subtask2( $20\%$ ) : $n,k \le 1000$
 - Subtask3( $60\%$ ) : 无特殊限制

对于 $100\%$ 的数据 : $0 \le k < n \le 10^6$。

### 说明

 - 以下文献没有阅读必要。

### Reference

 - [1] 中国知网 - 四角链的一些极值问题 - 厦门大学 - 曾艳秋  
http://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CMFD&filename=2007056552.nh
 - [2] 中国知网 - 关于四角仙人掌图的海明优美性 - 吉林工程技术师范学院教育技术中心;海南大学理工学院 - 李秀芬;潘伟  
http://www.cnki.com.cn/Article/CJFDTotal-CCYD200806009.htm

## 样例 #1

### 输入

```
10 5```

### 输出

```
42525```

## 样例 #2

### 输入

```
642 357```

### 输出

```
409821948```

## 样例 #3

### 输入

```
666666 233333```

### 输出

```
791003566```

# 题解

## 作者：bzy (赞：21)

### [Cnoi2020]四角链 官方拾遗

**Subtask1( 20% ) : $n,k \le 10$ | 暴力枚举 or 打表**

直接枚举每个格子填不填数以及填的数字是什么，理论计算次数小于 $10!=3628800$，可以轻松通过。

**Subtask1,2( 60% ) : $n,k \le 1000$ | 动态规划**

详情见其它题解。

**Subtask1,2,3( 100% ) : $n,k \le 10^6$ | 斯特林数 + 容斥原理**

做法见其它题解，这里补充答案是 ${n \brace n-k}$ 的正确证明姿势。

我们以这种填数方案为例:  

|编号|1|2|3|4|5|
|----|----|-|-|-|-|
|数字||2|1||4|

然后我们加入 $0$ 号格子，并将所有数字减一 :  

|编号|0|1|2|3|4|5|
|-|----|----|-|-|-|-|
数字|||1|0||3|

然后每个格子向自己数字对应的格子连边，容易证明形成的图是一个链森林。

上表生成的链森林为 $\{5\rightarrow3\rightarrow0\},\{4\},\{2\rightarrow1\}$。

可以发现一种链森林对应一种集合划分，链数等于 $n-k$, 所以答案是 ${n \brace n-k}$

---

## 作者：NaCly_Fish (赞：19)

由于只打了 1h，最后只剩 10min，然后这题就没想出来，，  
其实这题 10min 是能想出来的，还是因为自己菜啊 /kk
****
先考虑 dp，设 $f_{n,k}$ 为 $n$ 个格子填 $k$ 个数的方案。  
讨论第 $n$ 个位置是否填数，得出递推式为
$$f_{n,k}=f_{n-1,k}+(n-k+1)f_{n-1,k-1}$$
打个表发现它特别像第二类 Stirling 数，随便归纳一下就可以证明
$$f_{n-1,k}= \begin{Bmatrix} n \\ n-k \end{Bmatrix}$$
直接使用其通项公式计算即可，时间复杂度 $\Theta(n-k)$。

---

## 作者：WYXkk (赞：13)

看到这种**输入量少**的题目显然应该找规律。

于是我们打出了这么一个暴力：
```cpp
#include<cstdio>
#include<iostream>
#include<fstream>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
#define Set(a) memset(a,0,sizeof(a))
#define F(i,a,b) for(register int i=a,i##end=b;i<=i##end;++i)
#define UF(i,a,b) for(register int i=a,i##end=b;i>=i##end;--i)
#define openf(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
#define re register
#define ri re int
#define il inline
typedef long long ll;
typedef unsigned long long ull;
template<typename T> inline T rd(T& x)
{
	T f=1;x=0;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(; isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(T)(c-'0');
	x*=f;
	return x;
}
ll rd(){ll x;rd(x);return x;}
inline int max(int a,int b){return a>b?a:b;}
inline int min(int a,int b){return a<b?a:b;}
const int inf=1<<30;

ll ans[11];
bool used[11];
int n;
void dfs(int x,int k)
{
	if(x==n+1) {++ans[k];return;}
	dfs(x+1,k);
	F(i,1,x) if(!used[i]) {used[i]=true;dfs(x+1,k+1);used[i]=false;}
}
int main()
{
	for(n=1;n<=10;++n)
	{
		printf("n=%d:",n);
		F(i,0,n) ans[i]=0;
		dfs(1,0);
		F(i,0,n) printf("%lld ",ans[i]);
		puts("");
	}
	return 0;
}
```
然后观察输出：  
![](https://cdn.luogu.com.cn/upload/image_hosting/zepzbc1d.png)  
分明没有规律啊……

这个时候，我们不能忘记 [**O E I S**](http://oeis.org/) 这个 好 伙 伴

于是我们把序列拍平然后……

![](https://cdn.luogu.com.cn/upload/image_hosting/9j9nebtj.png)

发现答案就是 $S2(n,n-k)$ 。

于是去 [P5395 第二类斯特林数·行](https://www.luogu.com.cn/problemnew/solution/P5395) 的题解区抄个式子就好了。由于只需要计算一项的值所以并不需要多项式乘法。

$\texttt{code:}$
```cpp
#include<cstdio>
#include<iostream>
#include<fstream>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
#define Set(a) memset(a,0,sizeof(a))
#define F(i,a,b) for(register int i=a,i##end=b;i<=i##end;++i)
#define UF(i,a,b) for(register int i=a,i##end=b;i>=i##end;--i)
#define openf(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
#define re register
#define ri re int
#define il inline
typedef long long ll;
typedef unsigned long long ull;
template<typename T> inline T rd(T& x)
{
	T f=1;x=0;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(; isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(T)(c-'0');
	x*=f;
	return x;
}
ll rd(){ll x;rd(x);return x;}
inline int max(int a,int b){return a>b?a:b;}
inline int min(int a,int b){return a<b?a:b;}
const int inf=1<<30;

const int N=1000005;
ll jc[N],inv[N];
const ll p=998244353;
ll qp(ll a,ll b){if(!b) return 1;ll w=qp(a,b>>1);w=w*w%p;return b&1?w*a%p:w;}
int main()
{
	jc[0]=1;F(i,1,N-5) jc[i]=jc[i-1]*i%p;
	inv[N-5]=qp(jc[N-5],p-2);UF(i,N-5,1) inv[i-1]=inv[i]*i%p;
	ll ans=0,n,k;cin>>n>>k;k=n-k;
	F(i,0,k) ans=(ans+inv[i]*inv[k-i]%p*qp(k-i,n)*(1-2*(i&1)))%p+p;
	cout<<(ans%p)<<endl;
	return 0;
}
```
所以谁帮我证一下这题的结论是~~斯大林~~斯特林数啊qaq

---

## 作者：VinstaG173 (赞：11)

真的后悔。

比赛时在上网课，看着 rated 就来打了。

然后发现是个 Stirling 数板子，然后从 P5395 粘了个 code。

我 naive 没时间打 $O(n)$ 的公式爆算了。

然后赛时忘记吸氧被卡常，少了 60 分。

事后吸了氧就过了。

首先我们令答案为 $f(n,k)$，看第 $n-1$ 个方格是否填数。

如果第 $n-1$ 个方格填了数，那么此时前面的方格总共填了 $k-1$ 个数，剩下有 $(n-1)-(k-1)=n-k$ 个数可以选择，贡献为 $(n-k)f(n-1,k-1)$。

否则直接前面方格填 $k$ 个数，贡献为 $f(n-1,k)$。

于是我们得到了递推式：

$$f(n,k)=(n-k) \cdot f(n-1,k-1)+f(n-1,k)$$

这样可以获得 40 分。

然后我们用 $n-k$ 代替递推式中的 $k$，得到

$$f(n,n-k)=k \cdot f(n-1,n-k)+f(n-1,n-k-1)$$

再把 $f(n,n-k)$ 改写为 $g(n,k)$，此时我们得到了

$$g(n,k)=k \cdot g(n-1,k)+g(n-1,k-1)$$

于是这是第二类 Stirling 数。

于是从 P5395 搞个公式，完了。

没了，代码不想放了，

---

## 作者：YellowBean_Elsa (赞：6)

证明一下那个第二类 stirling 数的结论：

前置资料：[stirling 数](https://baike.baidu.com/item/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/4938529?fr=aladdin)

#### 证明

大家都想到的 dp 方法：

$dp(i,j)$ 表示前 $i$ 个格子填了 $j$ 个，则有转移方程：

```cpp
dp[i][j] = dp[i-1][j] + dp[i-1][j-1] * (i-j+1)
```
若令 $dp(i,j)$ 表示前 $i - 1$ 个格子放了 $j$ 个，则：

```cpp
dp[i][j] = dp[i-1][j] + dp[i-1][j-1] * (i-j)
```
要求 $dp[n][k]$

~~（别问我怎么想到的，我第一遍就这么“误打”的 QwQ）~~

我们采用已知答案推过程的方法（大雾

令 $S(n,m)$ 表示第二类 stirling 数

既然已知结论 $dp(n,k)=S(n,n-k)$ 即 $dp(n,n-k)=S(n,k)$

那我们就设 $f(n,k)=dp(n,n-k)$, 则：

```cpp
dp[i][i-j] = dp[i-1][i-j] + dp[i-1][i-j-1] * j
```
根据假设的 $f$ 和 $dp$ 的关系可以推出
```cpp
f[i][j] = dp[i-1][i-j] + dp[i-1][i-j-1] * j

f[i][j] = f[i-1][j-1] + f[i-1][j] * j
```
发现了吗？对照一下：
$$ S(n,m) = S(n-1,m-1) + m \cdot S(n-1,m)$$

#### 证毕

当然在比赛的时候，想要发现这个规律，正推是很难的，最好的找规律方法就是……

打表 + OEIS（雾

#### 代码

注意别见祖宗，除法要用逆元什么的, $O((n+k)logn)$

神鱼用线性筛预处理后是 $O(n+k)$, 我只能谔谔地 mod 神鱼

```cpp
//coder: Feliks a Hacker of IOI == GM-YB an AKer of IMO
#include<bits/stdc++.h>
#define fu(i,a,b) for(int i = a, I = (b) + 1; i < I; ++i)
#define fd(i,a,b) for(int i = a, I = (b) - 1; i > I; --i)
typedef long long ll;
using namespace std;
const int N=2e5+5;
const int mod=998244353;
ll n,k;
template <class T> inline void read(T &x) {
    x=0;T f=1;char ch=getchar();
    while(!isdigit(ch))f=ch=='-'?-1:1,ch=getchar();
    while(isdigit(ch))x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    x*=f;
}ll a=1,t,c=1,ans;
inline ll qpow(ll x,ll b){
	ll res=1;
	while(b){
		if(b&1)res=(res*x)%mod;
		b>>=1;
		x=x*x%mod;
	}return res;
}
int main(){
	read(n),read(k);
	//第二类 stirling 数
	//S(n,n-k) = (1 / (n-k)!) * (for i = 0 -> (n-k)) (-1)^i * C(n-k,i) * (n-k-i)^n
	fu(i,1,n-k)a=a*qpow(1LL*i,mod-2)%mod;
	fu(i,0,n-k){
		///注意除法转化成 ×逆元，由于 998244353 是经典质数，直接用费马小定理求 
		if(i)c=c*(n-k-i+1)%mod*qpow(1LL*i,mod-2)%mod;
		t=c*qpow((n-k-i),n)%mod;
		if(i%2)ans=(ans-t+mod)%mod;
		else ans=(ans+t)%mod;
	}printf("%lld\n",ans*a%mod);
	return 0;
}
```





---

## 作者：szh_AK_all (赞：5)

### 分析
不妨先设 $f_{i,j}$ 表示前 $i$ 个格子中有 $j$ 个格子填了数的方案数，那么第 $i$ 个格子可以放数，也可以不放，对应的转移方程便是 $f_{i,j}=(i-j-1)\times f_{i-1,j-1}+f_{i-1,j}$，可以发现这个和第二类斯特林数很像，那么如何让把个式子转换为第二类斯特林数呢？

第二类斯特林数的式子是 $S_{n,r}=r\times S_{n-1,r}+S_{n-1,r-1}$，可以发现第二类斯特林数的式子与上述的转移方程隔在了哪里呢？显然，最特别的是 $i-j-1,r$ 这两个相对应的系数，可以尝试改变 $f_{i,j}$ 的含义。

设 $f_{i,j}$ 表示前 $i$ 个格子中有 $j$ 个格子**没填数**的方案数，那么转移方程便为 $f_{i,j}=j\times f_{i-1,j}+f_{i-1,j-1}$，可以发现，这和第二类斯特林数便相同了，最终答案即为 $f_{n-1,n-k}$，用通项公式求下即可（在代码里，$f_{i,j}$ 的含义如上文所述略有不同）。

### Code
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int mod = 998244353;
int jie[1000005], inv[1000005];

int qpow(int a, int b) {
	int ans = 1;
	while (b) {
		if (b % 2 == 1)
			ans = ans * a % mod;
		a = a * a % mod;
		b /= 2;
	}
	return ans;
}

int c(int n, int m) {
	return jie[n] * inv[m] % mod * inv[n - m] % mod;
}

signed main() {
	int n, k;
	cin >> n >> k;
	jie[0] = 1;
	inv[0] = qpow(1, mod - 2);
	for (int i = 1; i <= n; i++)
		jie[i] = jie[i - 1] * i % mod, inv[i] = qpow(jie[i], mod - 2);
	int ans = 0;
	for (int i = 0; i <= n - k - 1; i++) {
		int f = 1;
		if (i % 2 == 1)
			f = -1;
		ans += f * c(n - k, i) % mod * qpow(n - k - i, n) % mod;
		if (ans > mod)
			ans -= mod;
		if (ans < 0)
			ans += mod;
	}
	ans = ans * inv[n - k] % mod;
	cout << ans;
}
```

---

## 作者：Warriors_Cat (赞：3)

[题面传送门](https://www.luogu.com.cn/problem/P6162)。

题意：

* 有一个 $1\times (n-1)$ 的网格，编号为 $1$ 到 $n-1$。
* 每个格子要么不填，要么填一个小于等于自己编号的数。
* 格子内填的数互不相同。
* 问填 $k$ 个格子的方案数是多少。答案对 $998244353$ 取模。

~~一年前没做出来的一道题，咕了一年再看发现直接秒了（~~

---

### Solution：

看到这题一上手直接考虑 dp，记 $f_{i, j}$ 为前 $i-1$ 格恰好填 $j$ 个数的方案数。那么不难列出状态转移方程：

$$f_{i, j} = f_{i-1, j}+(i-j)\times f_{i-1, j-1}$$

答案就是 $f_{n, k}$。

感觉上面那个转移很向斯特林数，所以不妨把 $j$ 替换为 $i-j:$

$$f_{i, j} = f_{i-1, j}+j\times f_{i-1, j-1}$$

这是一个标准的第二类斯特林数递推公式，所以有：

$$f_{n, k}=\begin{Bmatrix}n\\n-k\end{Bmatrix}$$

然后去度娘那里嫖一个公式就行了。时间复杂度为 $O(n)$ 或 $O(n\log p)$。

---

### Code：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
#define int long long
const int mod = 998244353;
inline int fpow(int n, int p){
	n %= mod;
	int ans = 1, base = n;
	while(p){
		if(p & 1) ans = ans * base % mod;
		base = base * base % mod;
		p >>= 1;
	}
	return ans;
}
int n, k, inv[1000010], jc[1000010], ans; 
signed main(){
	scanf("%lld%lld", &n, &k);
	k = n - k;
	jc[0] = 1;
	for(int i = 1; i <= n; ++i) jc[i] = jc[i - 1] * i % mod;
	inv[1] = inv[0] = 1;
	for(int i = 2; i <= k; ++i) inv[i] = (mod - mod / i) * inv[mod % i] % mod;
	for(int i = 1; i <= k; ++i) inv[i] = (inv[i] * inv[i - 1]) % mod;
	for(int i = 0; i <= k; ++i){
		int x = i & 1 ? 998244352 : 1, y = jc[k] * inv[i] % mod * inv[k - i] % mod;
		ans = (ans + x * y % mod * fpow(k - i, n) % mod) % mod;
	}
	printf("%lld", ans * inv[k] % mod);
	return 0;
}
```

---

## 作者：To_our_starry_sea (赞：1)

# P6162 [Cnoi2020] 四角链
本人计数能力极差，为了巩固一下，决心写了这篇题解。

## Solution

首先，我们可以考虑朴素的 dp。设 $dp_{i,j}$ 为 $i-1$ 个格子，填了 $j$ 个数的方案。

若填数，则：$dp_{i,j}=dp_{i-1,j-1}\times(i-j)$。

若不填数，则：$dp_{i,j}=dp_{i-1,j}$。

显然我们有如下的递推式：

$$\begin{aligned}
  dp_{i,j}=dp_{i-1,j}+dp_{i-1,j-1}\times(i-j)
\end{aligned}$$
   
此时我们用 $i-j$ 代替 $j$，则：$dp_{i,j}=dp_{i-1,j}+dp_{i-1,j-1} \times j$。这就是第二类斯特林数的形式，答案为 $S(n,n-k)$，$S(m,n)$ 代表的即是第二类斯特林数。

## Code

~~显然我们可以从[这里](https://www.luogu.com.cn/problem/solution/P5395) copy 一下（雾）~~。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll MOD=998244353;
const int MAXN=1000005;
int n,k;
ll ans=0,jc[MAXN],ni[MAXN];
inline ll qmi(ll a,ll b){
    ll ans=1,res=a;
	while(b){
	    if(b&1) ans=ans*res%MOD;
	    res=res*res%MOD;
	    b>>=1;
    }
    return ans;
}
inline int read(){
    int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();
	return x*f;	
}
int main(){
	n=read(),k=read();
	k=n-k;
	jc[0]=1;
	for(ll i=1;i<=n;i++) jc[i]=jc[i-1]*i%MOD;
	ni[0]=ni[1]=1;
	for(ll i=2;i<=k;i++) ni[i]=(MOD-MOD/i)*ni[MOD%i]%MOD;//线性求逆元 
	for(ll i=1;i<=k;i++) ni[i]=(ni[i]*ni[i-1])%MOD;//预处理阶乘的逆元 
	for(int i=0;i<=k;i++){
		ll x,y=jc[k]*ni[i]%MOD*ni[k-i]%MOD;
		if(i&1) x=998244352;//(-1+998244353) mod 998244353 = 998244352
		else x=1;  
		ans=(ans+x*y%MOD*qmi(k-i,n)%MOD)%MOD;
	}
	printf("%lld",ans*ni[k]%MOD);
	return 0;
}
```

祝大家 NOIP2023 RP++！

---


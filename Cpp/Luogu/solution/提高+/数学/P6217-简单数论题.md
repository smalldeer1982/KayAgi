# 简单数论题

## 题目描述

给出一个长度为 $n$ 的序列 $a$，$q$ 次询问 $\prod_{i=l}^r \operatorname{lcm}(a_i,x)$ 的值。

答案对 $10 ^ 9 + 7$ 取模。

## 说明/提示

**【样例解释】**

   对于样例一的第二个查询，答案是：

   $\quad \operatorname{lcm}(12,3) \times \operatorname{lcm}(8,3) \times \operatorname{lcm}(9,3)$

   $= 12 \times 24 \times 9$

   $= 2592$

------------------

**【数据范围】**

**本题采用捆绑测试。**


- 对于 $100 \%$ 的数据：$1 \le l \le r \le n$，$1 \le n,q,a_i,x \le 2 \times 10 ^ 5$。

- **详细的数据范围：**

  | Subtask 编号 | $n,q ,a_i,x\le $  |              特殊性质               | 分值 |
  | :---------: | :---------------: | :---------------------------------: | :--: |
  |     $1$     |       $100$       |                 无                  | $10$ |
  |     $2$     | $2 \times 10 ^ 5$ | $a_i,x$ 是质数，任意 $a_i \neq x$ | $10$ |
  |     $3$     | $5 \times 10 ^ 4$ |           $a_i$ 是质数            | $15$ |
  |     $4$     | $5 \times 10 ^ 4$ |           $μ(a_i) \neq 0$           | $15$ |
  |     $5$     | $5 \times 10 ^ 4$ |                 无                  | $25$ |
  |     $6$     | $2 \times 10 ^ 5$ |                 无                  | $25$ |

-------------------------

**【提示】**

- 样例二满足 Subtask2 的特殊性质，样例三满足 Subtask3 的特殊性质，样例四满足 Subtask4 的特殊性质。

- $μ(x)$ 是莫比乌斯函数，它的定义如下：

    设 $x = {p_1} ^ {q_1} \times {p_2} ^ {q_2} \times ... \times {p_k} ^ {q_k}$。

    $μ(x) =\begin{cases}1&x=1\\(-1) ^ k&q_1,q_2...q_k \le 1\\0&\text{otherwise}\end{cases}$ 

    注：$p_i$ 为质数，$q_i$ 为正整数。

## 样例 #1

### 输入

```
5 5
12 8 9 14 21
1 5 2
1 3 3
3 5 7
1 5 6
2 3 7```

### 输出

```
1016064
2592
18522
9144576
3528
```

## 样例 #2

### 输入

```
10 10
47 47 47 3 7 19 2 7 31 31 
1 3 53
4 4 61
2 8 73
6 7 53
1 5 47
2 5 73
5 6 71
7 7 67
4 7 83
1 9 59
```

### 输出

```
456856666
183
802334105
106742
816245119
365992530
670453
134
871739899
194416112
```

## 样例 #3

### 输入

```
10 10
2 13 13 2 3 17 11 19 19 7 
4 8 1
1 2 7
6 7 37
9 10 7
1 8 9
3 8 47
5 8 2
3 6 9
4 5 25
4 5 8
```

### 输出

```
21318
1274
256003
931
819082258
40076077
170544
2899962
3750
192
```

## 样例 #4

### 输入

```
10 10
14 39 31 30 3 21 19 17 35 2 
1 3 10
6 6 19
2 4 3
6 8 18
1 10 2
5 6 49
2 6 8
7 9 26
3 6 12
1 1 10
```

### 输出

```
8463000
399
108810
13186152
23723126
21609
437603581
198696680
22498560
70
```

# 题解

## 作者：Daniel13265 (赞：13)

$\text{Upd. 2020/03/15}$：重写了部分内容使其更加易懂；修改了少量错别字；修正了少量公式错误。

# 题意

给出正整数序列 $a$，多次给出 $l,r,x$ 询问 $\prod_{i=l}^r\operatorname{lcm}(a_i,x)$。

# 分析

观察到

$$\prod_{i=l}^r\operatorname{lcm}(a_i,x)=\frac{x^{r-l+1}\prod_{i=l}^ra_i}{\prod_{i=l}^r\gcd(a_i,x)}$$

明显 $x^{r-l+1}\prod_{i=l}^ra_i$ 可以维护前缀积并使用快速幂求出，于是我们只需要求 $\prod_{i=l}^r\gcd(a_i,x)$ 的值即可。

如果将 $a_i$ 和 $x$ 分别作质因数分解：

$$\begin{aligned}a_i&=\prod_{j=1}^kp_j^{q_{ij}}\\x&=\prod_{j=1}^kp_j^{q_{xj}}\end{aligned}$$

其中 $p_j$ 表示第 $j$ 个质数，$q\in\mathbb N$。那么有

$$\begin{aligned}\prod_{i=l}^r\gcd(a_i,x)&=\prod_{i=l}^r\prod_{j=1}^kp_j^{\min(q_{ij},q_{xj})}\\&=\prod_{i=1}^kp_i^{\sum_{j=l}^r\min(q_{ji},q_{xi})}\\&=\prod_{i=1}^kp_i^{\sum_{t=1}^{q_{xi}}\sum_{j=l}^r[t\le q_{ji}]}\\&=\prod_{i=1}^kp_i^{\sum_{t=1}^{q_{xi}}\sum_{j=l}^r\left[p_i^t\small|\scriptsize p_i^{q_{ji}}\right]}\\&=\prod_{i=1}^kp_i^{\sum_{t=1}^{q_{xi}}\sum_{j=l}^r\left[p_i^t\small|\scriptsize a_j\right]}\end{aligned}$$

所以我们需要分别对每一个能够整除 $x$ 的质数正整数幂，求出它能够整除 $a_l,a_{l+1},\ldots,a_r$ 中的多少个数，将底数相同的幂的个数相加后快速幂求积即为需要求的部分。

如果线性筛预处理小于 $\sqrt x$ 的质数，那么枚举 $p_i$ 的复杂度为

$$\mathcal O\left(\pi\left(\sqrt x\right)\right)\leq\Theta\left(\frac{\sqrt x}{\log\sqrt x}\right)=\Theta\left(\frac{\sqrt x}{\log x}\right)$$

设能整除一个数 $x$ 的所有质数正整数幂形成的集合为 $\operatorname{PP}(x)$。考虑到对于任意质数 $p\ge2$，有

$$\big|\operatorname{PP}(x\times p)\big|=\big|\operatorname{PP}(x)\big|+1$$

因而

$$\mathcal O\left(\big|\operatorname{PP}(x)\big|\right)=\mathcal O(\log x)$$

因此求出 $\operatorname{PP}(x)$ 的总复杂度为

$$\Theta\left(\frac{\sqrt x}{\log x}\right)+\mathcal O(\log x)=\Theta\left(\frac{\sqrt x}{\log x}\right)$$

可以先对于每一个 $a_i$ 求出 $\operatorname{PP}(a_i)$，之后将每一个质数的正整数幂与包含它的集合对应。这样，对于每一个询问的 $x$，可以在 $\mathcal O(\log n)$ 的时间复杂度内二分查找到 $l,r$ 在能够被整除 $x$ 的一个质数正整数幂整除的 $a_i$ 的下标 $i$ 的集合中的位置，进一步计算出该质数正整数幂在 $\operatorname{PP}(a_l),\operatorname{PP}(a_{l+1}),\ldots,\operatorname{PP}(a_r)$ 中出现的次数。

对每一个质数的正整数幂作二分的时间复杂度都是 $\mathcal O(\log n)$，共有 $\mathcal O(\log x)$ 个这样的质数正整数幂，故此部分的复杂度为 $\mathcal O\left(\log x\log n\right)$。从而得到这个做法的总空间复杂度为 $\mathcal O(\sqrt a+n\log a)$，总时间复杂度为

$$\Theta\left(n\frac{\sqrt a}{\log a}\right)+\mathcal O\left(q\pi\left(\sqrt a\right)\right)+\mathcal O\left(q\log x\log n\right)\leq\Theta\left(n\frac{\sqrt a}{\log a}+q\frac{\sqrt a}{\log a}+q\log x\log n\right)$$

如果认为 $n,q,a_i,x\sim N$，则总复杂度为 $\Theta\left(\frac{N\sqrt N}{\log N}\right)\sim\Theta\left(\frac{\sqrt N}{\log N}\right)\sim\mathcal O(N\log N)$。

更优的做法是在线性筛的时候记录筛去每一个数的质数，这个质数就一定是该数的最小质因子。于是对于任意一个数，可以通过不断除以它的最小质因子来得到它的所有的质因子。由于每一次除都这个数都要至少减少一半，所以利用这个方法求 $\operatorname{PP}(x)$ 的时间复杂度是 $\mathcal O(\log x)$。总空间复杂度为 $\mathcal O(\max(a,x)+n\log a)$，总时间复杂度为

$$\mathcal O\left(\max(a,x)+n\log a\right)+\mathcal O\left(q\log x\right)+\mathcal O\left(q\log x\log n\right)=\mathcal O\left(\max(a,x)+n\log a+q\log x\log n\right)$$



如果认为 $n,q,a_i,x\sim N$，则总复杂度为 $\mathcal O\left(N\log N\right)\sim\mathcal O\left(\log^2N\right)\sim\mathcal O(N\log N)$。

# 参考代码

```cpp
  mul[0] = 1;
  for (int i = 1; i <= n; ++i) {
    int t = read();
    mul[i] = mul[i - 1] * t % P;
    while (~-t) {
      const int &p = fir[t];
      int tmp = 1;
      while (!(t % p)) {
        t /= p;
        tmp *= p;
        vc[tmp].push_back(i);
      }
    }
  }
  while (q--) {
    const int &l = read(), &r = read(), &x = read();
    int t = x;
    long long res = 1ll;
    while (~-t) {
      const int &p = fir[t];
      int tmp = 1, tot = 0;
      while (!(t % p)) {
        t /= p;
        tmp *= p;
        tot += upper_bound(vc[tmp].begin(), vc[tmp].end(), r) - lower_bound(vc[tmp].begin(), vc[tmp].end(), l);
      }
      res = res * qpow(p, tot) % P;
    }
    cout << (mul[r] * qpow(mul[l - 1] * res % P, P - 2) % P * qpow(x, r - l + 1) % P) << '\n';
  }
```

---

## 作者：gyh20 (赞：8)

好题！！！！（比我出的好多了）（比赛时sb写了个 $O(n)$ 的质因数分解）

求 $\prod\limits_{i=l}^{r}\operatorname{lcm}(x,a_i)$

做题做多了，就会发现，$\operatorname{lcm}$ 这种东西一般都是转为 $\gcd$ 来求。尝试转换一下：
$\prod\limits_{i=l}^{r}\operatorname{lcm}(x,a_i)=\prod\limits_{i=l}^{r}\dfrac{x\times a_i}{\gcd(x,a_i)}$

而上面的东西明显可以预处理。

现在就转为求 $\prod\limits_{i=l}^r\gcd(x,a_i)$

这个东西似乎不好反演？（反正我不会）

考虑枚举每一个 $\gcd$ 的值。

我们发现，如果将每一个数分解质因数，那么 $\gcd$ 就是这些数中出现次数相同的数的个数。

也就是说：

假设一个数 $x$ 能分解为 $p_1^{a_1}p_2^{a_2}\dots p_k^{a_k}$

那么贡献为 $\sum\limits_{i=1}^ka_i\sum\limits_{j=1}^{a_i}cnt_{a_i^j}$

其中 $cnt_x$ 表示从 $l \sim r$ 中 $x$ 的倍数的个数。

由于 $\sum a_i$ 不超过 $\log x$，可以暴力求，现在考虑怎样快速求 $cnt$。（数学 $->$ 数据结构）

可以将所有的 $a_i$ 质因数分解，然后插入可持久化线段树，也就是说，枚举每一个质数和它的倍数，如果能被 $a_i$ 整除，则插入可持久化线段树，询问时差分一下，查询 $1\sim r$ 中某个质数或其幂次方出现的次数 $-  1\sim l$ 出现的次数。

可以提前预处理出所有质数（线性筛），来降低分解质因数复杂度。

总复杂度：

时间复杂度 $O(\dfrac{n\sqrt n}{\ln n})$（线性筛 $max_{a_i}$
，分解所有 $a_i$ 是 $\dfrac{n\sqrt a_i}{\ln a_i}$，插入可持久化线段树是 $n\log^2 a_i$，分解所有 $x$ 是 $\dfrac{q\sqrt x}{\ln x}$，在可持久化线段树询问是 $q\log^2 x$）

~~如果你嫌这个做法慢，Pollard-Rho 了解一下~~

```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#define re register
#define M 1000000007
using namespace std;
int a[200002],n,p[200002],b[200002],siz[80000002],tot,ls[80000002],rs[80000002],rt[200002],cnt,pos[1000002];
bool ip[200012];
const int Mxdt=200000;
inline char gc(){
	static char buf[Mxdt],*p1=buf,*p2=buf;
	return p1==p2&&(p2=(p1=buf)+fread(buf,1,Mxdt,stdin),p1==p2)?EOF:*p1++;
}
inline int read() {
	re int t=0;
	re char v=gc();
	while(v<'0')v=gc();
	while(v>='0') {
		t=(t<<3)+(t<<1)+v-48;
		v=gc();
	}
	return t;
}
inline void insert(re int &x,re int y,re int l,re int r,re int v){
	bool nw=0;
	if(!x){
	x=++cnt;nw=1;
	siz[x]=siz[y]+1;	}
	else ++siz[x];
	if(l==r){return;}
	re int mid=l+r>>1;
	if(v<=mid){
		if(nw)rs[x]=rs[y];
		insert(ls[x],ls[y],l,mid,v);
	}
	else{
		if(nw)ls[x]=ls[y];
		insert(rs[x],rs[y],mid+1,r,v);
	}
}
inline int count(re int x,re int l,re int r,re int v){
	if(!x)return 0;
	if(l==r){return siz[x];}
	re int mid=l+r>>1;
	if(v<=mid)return count(ls[x],l,mid,v);
	else return count(rs[x],mid+1,r,v);
}
inline int gcd(re int x,re int y){
	return y?gcd(y,x%y):x;
}
inline int ksm(re int x,re int y){
	re int ans=1;
	while(y){
		if(y&1)ans=1ll*ans*x%M;
		x=1ll*x*x%M;
		y>>=1;
	}
	return ans;
}
inline int max(re int x,re int y) {
	return x>y?x:y;
}
int l,r,q,x;
int main() {
	n=read();
	q=read();
	for (int i=2; i<=200010; i++) {
		if (!ip[i]) {
			p[++tot]=i;
			pos[i]=tot;
		}
		for (int j=1; j<=tot&&1ll*i*p[j]<=200010; j++) {
			ip[i*p[j]]=1;
			if (i%p[j]==0)break;
		}
	}
	a[0]=1;
	for(re int i=1; i<=n; ++i) {
		re int x=b[i]=read(),num=0;
		a[i]=1ll*a[i-1]*x%M;
		re int nw=0,lst=rt[i-1];
		re int k=sqrt(x);
		for(re int j=1;p[j]<=k;++j){
			num=1;
		while(x%p[j]==0)x/=p[j],num*=p[j],insert(nw,lst,1,200000,num),lst=nw,nw=0;
		}
		if(x!=1)insert(nw,lst,1,200000,x),lst=nw,nw=0;
		if(b[i]==1){
			rt[i]=rt[i-1];
		}
		else rt[i]=lst;
	}
	while(q--){
		l=read();r=read();re int x1=x=read(),ans=1;
		re int k=sqrt(x);
		for(re int i=1;p[i]<=k;++i){
			re int num=1;
			while(x1%p[i]==0){
				x1/=p[i];
				num*=p[i]；
				ans=1ll*ans*ksm(p[i],(count(rt[r],1,200000,num)-count(rt[l-1],1,200000,num)))%M;
			}
		}
		if(x1!=1){
			ans=1ll*ans*ksm(x1,(count(rt[r],1,200000,x1)-count(rt[l-1],1,200000,x1)))%M;
		}
		printf("%d\n",1ll*a[r]*ksm(a[l-1],M-2)%M*ksm(x,r-l+1)%M*ksm(ans,M-2)%M);
	}

}
```




---

## 作者：chenxinyang2006 (赞：8)

$subtask\ 1$ 过于简单就不写了，就是暴力而已

- $subtask\ 2$
   
   本 $subtask$ 前置知识：[逆元](https://www.luogu.com.cn/problem/P3811) + [快速幂](https://www.luogu.com.cn/problem/P1226)
   
   首先观察到一个显而易见的事实：
   
   $\prod_{i=l}^r lcm(a_i,x) = \frac{(\prod_{i=l}^r a_i) \times (\prod_{i=l}^r x)}{\prod_{i=l}^r gcd(a_i,x)}$
   
   $\prod_{i=l}^r a_i$ 是不可减的，可以用前缀积算出来
   
   $\prod_{i=l}^r x = x ^ {r - l + 1}$，可以快速幂解决
   
   然后你会发现，所有 $a_i,x$ 为互不相同的质数意味着所有数互质，所以 $\prod_{i=l}^r gcd(a_i,x) = 1$
   
   然后这个 $subtask$ 就做完了

- $subtask\ 3$

   本 $subtask$ 前置知识：[主席树](https://www.luogu.com.cn/problem/P3834)、[逆元](https://www.luogu.com.cn/problem/P3811)
   
   本 $subtask$ 有个很好的性质：所有 $a_i$ 为质数
   
   所以 $gcd(a_i,x)$ 只可能为 $a_i$ 或 $1$ ，而当  $gcd(a_i,x) = a_i$ 时，$a_i$ 是 $x$ 的因子
   
   可以分解 $x$ ，求出每个质因子在 $[l,r]$ 中出现的次数，以此计算 $\prod_{i=l}^r gcd(a_i,x)$，它就为$\prod_{i=1}^n i ^ {cnt_i}$（$cnt_i$表示$i$出现次数）
   
   然后就转变为了一个比较好解决的问题：不带修，查询 $x$ 数在 $[l,r]$ 出现次数
   
   最经典的做法就是主席树维护权值（当然你分块之类也行）
   
   注意我们计算完是要除以 $\prod_{i=l}^r gcd(a_i,x)$，所以对于每个数，我们给答案乘上 $inv[i] ^ {cnt_i}$
   
- $subtask\ 4$

   这个$subtask$和$subtask\ 3$没什么区别
   
   $μ(a_i) \neq 0$ 代表 $a_i$ 每个质因子次数 $\le 1$，所以我们不用考虑一个毒瘤的问题：

   $x$ 质因子次数比 $a_i$ 低，它用不了全部的次方……
   
   刚才的做法完全处理不了这样的问题
   
   其实这个 $subtask$ 只要分解一下 $a_i$ 就完事了
   
- $subtask\ 5$

   现在我们要直面一个毒瘤难题：$x$质因子次数比$a_i$低，它用不了全部的次方
   
   首先肯定还是要质因数分解
   
   假设现在正在求解问题 $[l,r,x]$ ，当前考虑到质因子 $p$ ，函数 $v(x,y)$ 表示 $x$ 中质因子 $y$ 的个数
   
   那么我们要求这个东西：
   
   $\sum\limits_{i = l} ^ r\ min(v(a_i,p),v(x,p))$
   
   $v(a_i,p)$ 与 $v(x,p)$ 是已知的，但是一维还是不太好做
   
   所以考虑看成一个 $n \times 20$ 的矩阵 $M$
   
   $M_{i,j} = \begin{cases}1&\text{ai中含有至少j个p}\\0&\text{otherwise}\end{cases}$
   
   这就很舒服了，每次求的是$\sum\limits_{i = l} ^ r \sum\limits_{j = 1} ^ {v(p)} M_{i,j}$
   
   这明显就是一个二维偏序问题，排序 + 树状数组直接上
   
   当然，你写个 $log^3\ n$ 也能通过本 $subtask$

- $subtask\ 6$

   如果你 $sort$ + 树状数组直接莽的话，可能会炸成 $75$
   
   因为一个矩阵内最多有 $n\ log\ a_i$ 个点，$sort$ 一遍复杂度会变成 $O(q\ (log\ n) ^ 2\ log\ log\ n)$，多了一个 $log\ log\ n$
   
   正确的做法是：用类似链式前向星的方法，实现$O(n\ log\ n)$的对 $M$ 矩阵中的点排序，将询问丢到不同的 $vector$ 里解决
   
   如果你暴力分解质因数，可能也会炸成 $75$
   
   正确的做法是用埃氏筛筛出来
   
   反正这些都是实现问题，看代码就行
   
[code](https://www.luogu.com.cn/paste/m5nqfsg6)

---

## 作者：xyr2005 (赞：5)

**Upd**：修复了部分数学公式错误

------

先推推式子

$Ans=\prod_{i=l}^rlcm(a_i,x)$

$\ \ \ \ \ \ \ \ \ =\frac{x^{r-l+1}\prod_{i=l}^ra_i}{\prod_{i=l}^rgcd(a_i,x)}$

$x^{r-l+1}\prod_{i=l}^ra_i$ 可以通过简单预处理算出，下面只考虑 $\prod_{i=l}^rgcd(a_i,x)$

$\prod_{i=l}^rgcd(a_i,x)=\prod_{g}g^{\sum_{i=l}^r[gcd(a_i,x)=g]}$

$\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ =\prod_{g|x}g^{\sum_{i=l}^r[g|a_i]*[gcd({a_i\over g},{x\over g})=1]}$

$\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ =\prod_{g|x}g^{\sum_{d|\frac xg} \mu(d)*\sum_{i=l}^r[dg|a_i]}$


设 $T=d*g$

$\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ =\prod_{T|x}(\prod_{g|T}g^{\mu(\frac Tg)})^{\sum_{i=l}^r[T|a_i]}$


对于 $1<=T<=MAXV$ 预处理 $val_T=\prod_{g|T}g^{\mu(\frac Tg)}$ ，这一部分是 $O(n \log n)$ 的。

预处理每个数的因数。对于每个询问，枚举x的因数，将询问拆成 $2*d(x)$ 个形如 $val_T^{\sum_{i=1}^p[T|a_i]}$ 的乘积，挂在 $r$ 和 $l-1$ 位置的 vector 上。

将 $a_i$ 按顺序加入，加入时枚举 $a_i$ 的因子，询问时可以做到 $O(1)$ 查询。

通过离线求逆元的方法精细地实现程序，可以做到 $O(n\log n+\sum d(x))$


[代码](https://www.luogu.com.cn/paste/ob4wyb53)


---

## 作者：Kevin911 (赞：1)

数论好题。

## 思路
首先推一波式子。

$\prod_{i=l}^{r}\operatorname{lcm}(a_{i},x)=\dfrac{{x}^{r-l+1}\prod_{i=l}^ra_{i}}{\prod_{i=l}^{r}\gcd(a_{i},x)}$

对于分子部分，可以考虑只用快速幂和前缀积直接求出来。


对于分母部分，下面重点讲解如何计算。

考虑质因数分解，对于 $x=\prod_{i=1}^{k}{p_{i}}^{k_{i}}$，为每个质因数次幂建一个 vector，可以将 $x$ 的下标丢进每个 ${p_{i}}^{w}$，其中 $w\leq k_{i}$ 且为正整数。

为什们要这么做呢？举个栗子。

$54$ 对于 $36$ 和 $48$ 的公因数的积可以这样表示出来。

[图片戳一戳](https://f.afbkw.cn/vw4ekf)

会发现每个质因数底部公共区域绿蓝公共的大小为答案该质因数的个数。

所以每次在 vector 中找到 $l$ 到 $r$ 中有多少该 $p_{i}$ 次数大于等于 $x$ 中 $p_{i}$ 次数的，比更新 $cnt$（计数器），所有同种质因数除完后，乘上 ${p_{i}}^{cnt}$。

具体细节详见代码。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn=2e5+10,mod=1e9+7;
int a[maxn],pr[maxn],w[maxn],cnt;
bool vis[maxn];
vector<int> v[maxn];
int po(int x,int y)
{
	int res=1ll,r=x;
	for(int i=y;i;i>>=1)
	{
		if(i&1) res=res*r%mod;
		r=r*r%mod;
	}
	return res;
}
void pre()
{
	for(int i=2;i<=2e5;i++)
	{
		if(!vis[i])
		{
			pr[++cnt]=i;
			w[i]=i;
		}
		for(int j=1;j<=cnt&&i*pr[j]<=2e5;j++)
		{
			vis[i*pr[j]]=1;
			w[i*pr[j]]=pr[j];
			if(i%pr[j]==0) break;
		}
	}
}
signed main()
{
	pre();
	int n,q;
	cin>>n>>q;
	a[0]=1ll;
	for(int i=1;i<=n;i++)
	{
		int x;
		cin>>x;
		a[i]=a[i-1]*x%mod;
		int num=x;
		while(num!=1)
		{
			int tmp=w[num],p=1ll;
			while(num%tmp==0)
			{
				num/=tmp;
				p*=tmp;
				v[p].push_back(i);
			}
		}
	}
	for(int t=1;t<=q;t++)
	{
		int l,r,x,ans=1ll;
		cin>>l>>r>>x;
		int num=x;
		while(num!=1)
		{
			int tmp=w[num],p=1ll,sum=0;
			while(num%tmp==0)
			{
				num/=tmp;
				p*=tmp;
				sum+=upper_bound(v[p].begin(),v[p].end(),r)-lower_bound(v[p].begin(),v[p].end(),l);
			}
			ans=ans*po(tmp,sum)%mod;
		}
		cout<<po(x,r-l+1)*a[r]%mod*po(a[l-1],mod-2)%mod*po(ans,mod-2)%mod<<endl;
	}
}
```
感觉捋清思路后代码挺好打出来的。

---

## 作者：GI录像机 (赞：0)

看到大家要么在维护数据结构，要么推了一长串式子，来发个简单无脑的做法。

## 思路

先将 $\operatorname{lcm}$ 转为 $\operatorname{gcd}$，原式子等于 $\prod^r_{i=l}\frac{a_i x}{\operatorname{gcd}(a_i,x)}$。

分子是很好统计的，这里不再多说。

重点看怎么算 $\operatorname{gcd}$。首先对于 $x$ 进行质因数分解，对每个质因数分开计算。发现质因数的幂次最多只有 $\log$ 个，因此我们开一个数组 $vec_{i,j}$，表示第 $i$ 小的质数可以分解出 $j$ 个的 $a_i$ 个数。对于 $x$ 的每个质因数，直接暴力枚举该质因数的次幂，找到该质因数在分母中贡献了多少次。

那么如何维护 $vec$ 呢？由于 $Ans_{l,r,x}=\frac{Ans_{1,r,x}}{Ans_{1,l-1,x}}$，我们只需要计算左端点为 $1$ 的答案。把一个询问拆成两个，按照右端点排序，离线维护即可。

列几个极端情况就会发现这样是能过的。

## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int read() {
	int f = 1, x = 0;
	char c = getchar();
	while (c < '0' || c > '9') {
		if (c == '-')f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = x * 10 + c - '0';
		c = getchar();
	}
	return f * x;
}
void write(int x) {
	if (x < 0) {
		putchar('-');
		x = -x;
	}
	if (x > 9)write(x / 10);
	putchar(x % 10 + '0');
}
const int N = 2e5 + 10, MOD = 1e9 + 7, INF = 0x3f3f3f3f;
int n = read(), q = read(), ans[N], prime[N], tot, v[N], cnt[N];
int qpow(int a, int b) {
	int r = 1;
	while (b) {
		if (b & 1)r = (1ll * r * a) % MOD;
		a = (1ll * a * a) % MOD;
		b >>= 1;
	}
	return r;
}
struct Ques {
	int r, x, id;
	bool flag;
} a[N << 1];
bool cmp(Ques x, Ques y) {
	return x.r < y.r;
}
vector<int>vec[100];
signed main() {
	for (int i = 1; i <= n; i++)v[i] = read();
	for (int i = 2; i <= 450; i++) {
		bool ip = 1;
		for (int j = 2; j * j <= i; j++)
			if (i % j == 0) {
				ip = 0;
				break;
			}
		if (ip) {
			prime[++tot] = i;
			int tmp = i;
			vec[tot].push_back(0);
			while (tmp <= N) {
				vec[tot].push_back(0);
				tmp *= i;
			}
			vec[tot].push_back(0);
		}
	}
	for (int i = 0; i < q; i++) {
		a[i << 1].r = read() - 1, a[i << 1 | 1].r = read(), a[i << 1].x = a[i << 1 | 1].x = read();
		a[i << 1].flag = 1, a[i << 1].id = a[i << 1 | 1].id = i, ans[i] = 1;
	}
	sort(a, a + q + q, cmp);
	int nr = 0, fac = 1;
	for (int i = 0; i < q << 1; i++) {
		while (nr < a[i].r) {
			nr++;
			fac = (1ll * fac * v[nr]) % MOD;
			int tmp = v[nr];
			for (int j = 1; j <= tot; j++) {
				if(prime[j] > tmp)break;
				int ind = 0;
				while (tmp % prime[j] == 0) {
					tmp /= prime[j];
					ind++;
				}
				vec[j][ind]++;
			}
			cnt[tmp]++;
		}
		int tmp = a[i].x, res = (1ll * fac * qpow(a[i].x, nr)) % MOD;
		for (int j = 1; j <= tot; j++) {
			if(prime[j] > tmp)break;
			int ind = 0, num = 0;
			while (tmp % prime[j] == 0) {
				tmp /= prime[j];
				++ind;
				num += vec[j][ind] * ind;
			}
			if(!ind)continue;
			for (int l = ind + 1; l < vec[j].size(); l++)num += vec[j][l] * ind;
			res = (1ll * res * qpow(qpow(prime[j], num), MOD - 2)) % MOD;
		}
		res = (1ll * res * qpow(qpow(tmp, cnt[tmp]), MOD - 2)) % MOD;
		if (a[i].flag)ans[a[i].id] = (1ll * ans[a[i].id] * qpow(res, MOD - 2)) % MOD;
		else ans[a[i].id] = (1ll * ans[a[i].id] * res) % MOD;
	}
	for (int i = 0; i < q; i++) {
		write(ans[i]);
		putchar('\n');
	}
	return 0;
}
```

---

## 作者：danny101 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P6217)

#### 题目大意：

给定序列 $a$，每次询问给定 $l,r,x$，求 $\prod\limits^r_{i=l}\operatorname{lcm}(a_i,x)$。

#### 大致思路：

熟悉的套路，看到 $\operatorname{lcm}$ 直接转为 $\gcd$。

$\prod\limits^r_{i=l}\operatorname{lcm}(a_i,x)=\frac{x^{r-l+1}\prod\limits^r_{i=l}a_i}{\prod\limits^r_{i=l}\gcd(a_i,x)}$

预处理+快速幂完上面的部分后问题即可转为求 $\prod\limits^r_{i=l}\gcd(a_i,x)$。

这个式子怎么求呢？注意到 $\gcd$ 的后项每次查询是固定的。

所以可以把每一项 $a_i=p_1^{d_1}p_2^{d_2}\dots p_k^{d_k}$ 的贡献视为$\sum\limits_{i=1}^k d_i\sum\limits_{j=1}^{d_i}\operatorname{count}(d_i^j)$ ，其中 $\operatorname{count}$ 的区间为 $[l,r]$。

那么问题又来到了 $\operatorname{count}$，怎么求呢？

很容易想到主席树。先线性筛预处理质数，再将所有 $a$ 中的元素分解质因数后的 $p_i$ 及它的倍数插入到树中，之后快速查询前缀中 $p,p^2,\dots,p^k$ 的数量，最后进行差分即可。

时间复杂度在 $\mathcal{O(n\sqrt n+\sum \log^2 a_i+\sum\log^2 x)}$ 左右。

---


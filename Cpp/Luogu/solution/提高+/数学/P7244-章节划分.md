# 章节划分

## 题目背景

&emsp;&emsp;作文周，顾名思义，一天写一篇，高产似那啥。

&emsp;&emsp;小灰毛的作文被老师无数次公开处刑，昨天自己的奶奶变成了别人作文里的外婆，今天憋出来的小面变成了明天别人的酸辣粉。素材一用，就报废了啊 qwq。

&emsp;&emsp;于是，不甘心的小灰毛决定加倍高产。

## 题目描述

天依决定了 $n$ 个素材，它们将**依次**在作文中被叙写。其中，第 $i$ 个素材的立意特征值是 $a_i$。

但天依发现她构思的大作实在是太长啦，所以她想把它们划分为**恰好 $k$ 个**章节，每个章节包含一段**连续且非空的**素材。假设第 $i$ 个章节包含素材 $[l_i,r_i]$，天依将选取立意特征值最大的素材来升华，得到该章节的立意值 $b_i$，满足 $b_i=\max\limits_{i\in[l_i,r_i]}\{a_i\}$。  

最后，整篇作文的凝练度为每个章节立意值的**最大公约数**，即 $\gcd\limits_{i\in[1,k]}\{b_i\}$。

天依当然希望**最大化**作文的凝练度，那么凝练度的最大值是多少呢？

---

#### 简化题意

有一个长度为 $n$ 的序列 $a$。要求将这个序列**恰好**分成**连续且非空**的 $k$ 段，并定义第 $i$ 段的立意值为该段的所有元素的最大值，记为 $b_i$。要求最大化 $\gcd\limits_{i\in[1,k]}\{b_i\}$ 并输出这个最大值。

## 说明/提示

#### 样例解释 1
最优的素材划分可能有多种，这里给出一种最优的素材划分，将这 $5$ 个素材分成 $3$ 个章节：$[1,3],[2,9],[6]$，可以得出 $b_1=3,b_2=9,b_3=6$，凝练度的最大值为 $\gcd(3,9,6)=3$。

------------

#### 数据规模与约定
**本题采用捆绑测试。**

对于 $100\%$ 的数据，$1\le k\le n\le 10^5$，$1\le a_i\le 10^{6}$。

| 子任务 | 分值 |        $n$         | $k$  |       $a_i$        |
| :----: | :--: | :----------------: | :--: | :----------------: |
|   1    |  5   |      $\le 5$      |  /   |         /          |
|   2    |  10  |     $\le 10^2$     |  /   |         /          |
|   3    |  10  |         /          | $2$  |         /          |
|   4    |  15  |         /          | $3$  |         /          |
|   5    |  20  | $\le 3\times 10^3$ |  /   |         /          |
|   6    |  10  |         /          |  /   | $\le 2\times 10^2$ |
|   7    |  30  |         /          |  /   |         /          |

## 样例 #1

### 输入

```
5 3
1 3 2 9 6```

### 输出

```
3```

## 样例 #2

### 输入

```
5 2
10 2 5 5 5```

### 输出

```
5```

# 题解

## 作者：C3H5ClO (赞：20)

学考回来随便开了一个比赛，提供一个 $O(n\sigma_0(a_i))$ 的分治做法。

显然，答案必然是全局最大值的约数。那么我们枚举这个约数 $x$ 。对每个 $x$ ，求出将这个序列划分成若干段，每一段的最大值都是 $x$ 的倍数，段数的最大值。满足这个段数 $\ge k$ 的最大的 $x$ 就是答案。

对于一个区间 $l,r$，考虑求出它能划分的最多段数 $f(l,r)$ 。设区间最大值所在位置是 $mid$ 。

如果 $x|a_{mid}$ ，那么贪心地取这个最大值为新的一段， $f(l,r)=f(l,mid-1)+1+f(mid+1,r)$ 。

否则，如果 $l>1$，$l-1$ 这个位置一定是某一个祖先的 $mid$ ， $[l,r]$ 的最大值可以属于 $l-1$ 所在区间。同理，如果 $r<n$，$[l,r]$ 的最大值可以属于 $r+1$ 所在区间。因此， $f(l,r)=max([r<n]f(l,mid-1),[l>1]f(mid+1,r))$ 。

显然，递归树是笛卡尔树的一部分，求一次 $f(l,r)$ 的复杂度为 $O(n)$ ，因此时间复杂度得证。

至于区间最大值位置的求法，可以建笛卡尔树也可以直接ST表。

代码有手就行

```

const int N=100005;
int n,k,a[N],st[N][20],lg[N];
inline int pushup(int x,int y){return a[x]>a[y]?x:y;}
inline int getmax(int l,int r)
{
	int d=lg[r-l+1];
	return pushup(st[l][d],st[r-(1<<d)+1][d]);
}
int solve(int l,int r,int d)
{
	if(l>r)return 0;
	int mid=getmax(l,r);
	if(a[mid]%d==0)return solve(l,mid-1,d)+1+solve(mid+1,r,d);
	int ans=0;
	if(l>1)chkmax(ans,solve(mid+1,r,d));
	if(r<n)chkmax(ans,solve(l,mid-1,d));
	return ans;
}
int main()
{
	scanf("%d%d",&n,&k);
	For(i,2,n)lg[i]=lg[i>>1]+1;
	For(i,1,n)scanf("%d",a+i),st[i][0]=i;
	For(i,1,lg[n])
		For(j,1,n-(1<<i)+1)
			st[j][i]=pushup(st[j][i-1],st[j+(1<<i-1)][i-1]);
	int x=a[getmax(1,n)],sqx=sqrt(x);
	For(i,1,sqx)
		if(x%i==0&&solve(1,n,x/i)>=k)
		{
			printf("%d",x/i);
			return 0;
		}
	Rof(i,sqx-1,1)
		if(x%i==0&&solve(1,n,i)>=k)
		{
			printf("%d",i);
			return 0;
		}
}
```

---

## 作者：ForgotMe (赞：17)

### Subtask 1
直接爆搜。

### Subtask 2

发现不好直接搞，于是考虑枚举答案为 $x$，转化为判定性问题，可以很显然的发现 $x$ 一定是所有素材立意特征值的最大值的某个因数，然后就只需要用 $\sqrt{\max(a_i)}$ 去枚举因数判断，现在就是要判断将数列分成 $k$ 段使得每一段的最大值都能被 $x$ 整除。

首先有一个很暴力的 dp 想法：设 $dp_{i,j}$ 表示分到了 $i$ 这个位置，分了 $j$ 段是否有一种合法的方案。

转移方程很简单

$$
dp_{i,j}=\max\{dp_{k,j-1}\}(0\le k\lt i\ \operatorname{and}\ x|\operatorname{Max}(k+1,i))
$$

其中 $\operatorname{Max}(k+1,i)$ 表示区间 $[k+1,i]$ 的最大值。

初始化很简单 $dp_{0,0}=1$，一次判定时间复杂度 $\mathcal{O(n^2k)}$，加上枚举答案，总复杂度 $\mathcal{O}(n^2k\sigma_0(\max(a_i)))$。其中 $\sigma_0(a_i)$ 最大算一下为 $240$，这是能过的。

by @cqbzljsqwq

### Subtask 3,4

~~随便搞~~

by @cqbzljsqwq

### Subtask 5

考虑优化 Subtask 2 的做法。

我们发现一些性质，对于两段最大值能够被我们枚举的 $x$ 整除的相邻的区间，将它们合并成一个区间后，最大值仍然能被 $x$ 整除 ~~显然~~。

因此我们可以定义 $dp_i$ 为分到了 $i$ 这个位置，最多能够分成多少段。

由前面所述性质可得，当 $k \le dp_n$ 时，这 $n$ 段一定可以可以划分成 $k$ 段。

转移方程很简单 

$$
dp_i = \max \{dp_{k}+1\}(0 \le k < i \operatorname{and}\ x|\operatorname{Max}(k+1,i))
$$

这样判断一次的复杂度就是 $\mathcal{O(n^2)}$ 的，加上枚举答案，总复杂度 $\mathcal{O}(n^2\sigma_0(\max(a_i)))$。

by @Reanap

### Subtask 7

考虑优化 Subtask 5 的做法。

我们发现上述转移只与 $\operatorname{Max}(k+1,i)$ 有关，同时从 $i$ 开始做这个函数的后缀，我们会发现，从后往前它的值是单调不增的。我们可以找到在 $i$ 前面比 $a_i$ 大的第一个数编号为 $j$ ，容易发现，再往前枚举的转移实际上与我们在 $j$ 枚举的转移是等价的。因此我们只用考虑 $j < k < i$ 部分的转移。而我们又发现这段的 $\operatorname{Max}(k,i)$ 恰好等于 $a_i$，因此如果 $x | a_i$ 我们只需要知道这段区间的 $dp$ 最大值就好了。

得到转移方程:

$$
dp_i = \max(dp_j,\max \{dp_k+1 \}(j < k < i \ \operatorname{and}\ x | a_i))
$$

关于求解区间最大，可以使用线段树或动态st表，均能通过本题。

by @Reanap

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <vector>
#include <algorithm>
using namespace std;

template <typename T>
void read(T &x) {
    T f = 1;
    x = 0;
    char s = getchar();
    while (s < '0' || s > '9') {
        if (s == '-')
            f = -1;
        s = getchar();
    }
    while (s >= '0' && s <= '9') {
        x = (x << 3) + (x << 1) + (s ^ '0');
        s = getchar();
    }
    x *= f;
}

template <typename T>
void write(T x) {
    if (x < 0) {
        x = -x;
        putchar('-');
    }
    if (x <= 9) {
        putchar(x + '0');
        return;
    }
    write(x / 10);
    putchar(x % 10 + '0');
}

int Div[100005], cnt, n, k, a[100005], las[100005], sta[100005], top;
int dp[100005], maxx[100005][20];

vector<int> g[1000005];

void update(int x, int y) {
    maxx[x][0] = y;
    for (int i = 1; x - (1 << i) >= 0; i++) maxx[x][i] = max(maxx[x][i - 1], maxx[x - (1 << (i - 1))][i - 1]);
}

int find(int l, int r) {
    int t = log2(r - l + 1);
    return max(maxx[r][t], maxx[l + (1 << t) - 1][t]);
}

bool check(int x) {
    dp[0] = 0;
    for (int i = 1; i <= n; ++i) {
        if (a[i] % x != 0) {
            dp[i] = dp[las[i]];
        } else if (las[i] == 0) {
            if (i == 1)
                dp[i] = 1;
            else {
                int val = find(las[i] + 1, i - 1);
                if (val == 0)
                    dp[i] = 1;
                else
                    dp[i] = val + 1;
            }
        } else {
            int val = find(las[i], i - 1);
            if (val != 0)
                dp[i] = val + 1;
            else
                dp[i] = 0;
        }
        update(i, dp[i]);
    }
    return dp[n] >= k;
}

int main() {
    read(n), read(k);
    int x = 0;
    for (int i = 1; i <= n; ++i) read(a[i]), x = max(x, a[i]);
    las[1] = 0;
    sta[++top] = 1;
    for (int i = 1; i * i <= x; ++i)
        if (x % i == 0) {
            for (int j = 1; j <= n; ++j)
                if (i * i == x) {
                    if (a[j] % i == 0)
                        g[i].push_back(j);
                } else {
                    if (a[j] % i == 0)
                        g[i].push_back(j);
                    if (a[j] % (x / i) == 0)
                        g[x / i].push_back(j);
                }
        }
    for (int i = 2; i <= n; ++i) {
        while (top && a[i] >= a[sta[top]]) top--;
        if (!top)
            las[i] = 0;
        else
            las[i] = sta[top];
        sta[++top] = i;
    }
    for (int i = 1; i * i <= x; ++i) {
        if (x % i == 0)
            Div[++cnt] = i;
        if (x % i == 0 && x / i != i)
            Div[++cnt] = x / i;
    }
    sort(Div + 1, Div + 1 + cnt);
    for (int i = cnt; i >= 1; --i) {
        if (g[Div[i]].size() >= k && check(Div[i])) {
            printf("%d", Div[i]);
            return 0;
        }
    }
    return 0;
}
```

---

## 作者：cjrqwq (赞：13)

简化的题意在题面有了，讲讲思路吧。

### 思路

因为题意是分段求最大值，然后求最小公约数。显然，答案是 $a_i$ 中最大值的约数。只需要枚举该数的约数 $m$ 即可。

对于每个 $m$，可以找区间内最大值的下标 $maxi$。

$f(l,r)$ 的意义为在 $l,r$ 区间中，有 $f(l,r)$ 段 $a_{maxi}$ 为 $m$ 的倍数。只要 $f(1,n) \geq k$，就说明因数为 $m$ 时合法，因为即使比 $k$ 大，合并到 $k$ 段也没有影响。

当 $a_{maxi} \bmod m=0$ 时，将数组分成三部分：
$$f(l,maxi-1)+1+f(maxi+1,r)$$

否则，如果 $l,r$ 不是边界（$l>1,r<n$）时，$l-1,r+1$ 必定是他祖先的 $maxi$，因为每次递归的左，右边界分别是 $maxi+1,maxi-1$。

既然如此，我们便尝试将 $maxi$ 合并到左边（祖先的 $maxi$ 肯定大于孩子的 $maxi$，所以肯定能合并），再递归右边的区间 $f(maxi+1,r)$。或者合并到右边，就只要递归 $f(l,maxi-1)$（原因同上）。将 $maxi$ 递归到两边均有一样的效果，所以要将两种情况取最大值。

递归式为：
$$f(l,r) = \begin{cases}f(l,maxi-1)+1+f(maxi+1,r)&(maxi\bmod m=0)\\\max([l>1]f(maxi+1,r),[r<n]f(l,maxi-1))&(maxi\bmod m\neq 0)\end{cases}$$

st 表可以求 $maxi$（~~我只会写这个~~）。

### 代码

```cpp
#include<bits/stdc++.h>
#define lrlg _log[r-l+1] 
using namespace std;
const int LogN=22;
const int N=100001;
int n,k,s,e,ans;
int st[N+10][LogN+10],sti[N+10][LogN+10],a[N+10];
int _log[N+10],masti;
int maxi(int x,int y) {//返回两数中更大值的下标 
	return a[x]>a[y]?x:y;
}
//从 i 开始，长度为 2^j 的最大值
void init() {
	_log[1]=0;
	_log[2]=1;
	for(int i=3;i<N;i++) {
		_log[i]=_log[i/2]+1;
	}
	for(int i=1;i<=n;i++) {
		scanf("%d",&a[i]);
		sti[i][0]=i;
	}
	for(int j=1;j<=LogN;j++) {
		for(int i=1;i+(1<<j)-1<=n;i++) {
			sti[i][j]=maxi(sti[i][j-1],sti[i+(1<<j-1)][j-1]);//st表求最大值所在下标 
		}
	}
}
int f(int l,int r,int mod) {// 递归求答案 
	if(l>r||l<1||r>n) return 0;
	int i=maxi(sti[l][lrlg],sti[r-(1<<lrlg)+1][lrlg]);int mal=0,mar=0;
	if(a[i]%mod==0)
		return f(l,i-1,mod)+1+f(i+1,r,mod);
	else {
		if(l>1) mar=f(i+1,r,mod);
		if(r<n) mal=f(l,i-1,mod); 
		return max(mal,mar);
	}
}
int main() {
	scanf("%d%d",&n,&k);
	init();
	int len=_log[n];
	int masti=a[maxi(sti[1][len],sti[1+n-(1<<len)][len])];
	for(int i=masti;i>=1;i--) {//枚举因数 
		ans=0;
		int ck=f(1,n,i);
		if(masti%i==0&&ck>=k) {
			cout<<i;
			return 0;
		}
	}
	return 0;
}
```

---

## 作者：chlchl (赞：5)

## 做法
分解质因数 + dp + 倍增或线段树。

首先可以发现，整个序列的最大值 $mx$ 必定作为某一段的最大值出现。因此，最终的答案必定是最大值的因子。所以，我们考虑 $O(\sqrt{mx})$ 求出 $mx$ 的因数。

接着，我们再想一个重要的性质：如果连续的若干段最大值都能被 $v$ 整除，那么将它们合起来，新的大区间必定也能被 $v$ 整除。

也就是说，我们可以将问题从“刚好分成 $k$ 段”转化为“最多分成几段”，因为如果分段大于 $k$，随便合并几个就可以了。当然，如果最多都分不到 $k$ 段，显然以 $v$ 作为区间的最大公因数就不行。

求最大值，显然考虑分段 dp。设 $f_i$ 为以**第 $i$ 个元素为结尾**最多分成几段，容易得出 $f_i=\max\{f_j+1\},j\in \lbrack 1,i-1\rbrack,v\mid a_j$（通俗点说，枚举上一段的结束点 $j$），时间复杂度 $O(n^2)$，可以拿到 $35$ pts 的好成绩。

考虑优化 dp。状态已经很优了，但我们在转移的时候浪费了很多时间。记上一个比 $a_i$ 大的值为 $lst_i$，则我们在求 $f_i$ 时，$1\sim lst_i$ 这一段其实是不用遍历的，因为以这些点为起点，必定包含 $lst_i$，最大值就不是 $a_i$ 了。

而 $\lbrack lst_i+1,i\rbrack$ 的最大值必定是 $a_i$，所以我们的 $f$ 可以定义为以 $i$ 为最后一段结尾且作为最大值时，前 $i$ 个数最多能分成几段。

而这个“前面第一个比 $a_i$ 大的数”，不就是单调栈的模板么？我们可以在读入时 $O(n)$ 求出，十分优秀。

但是这种在构造数据下仍然会被卡成 $O(n^2)$ 级别。容易发现，dp 的转移过程就是在一段区间中找到 $f$ 的最大值。这可以用线段树或者倍增优化。倍增常数小很多，故这里采用动态 ST 表。

注意到每次都是在末尾插入，我们就设 $rmq_{i,j}$ 为以 $i$ 为结尾，往前 $2^j$ 个数的最大值，每次插入时 $O(\log n)$ 更新。

然后 dp 的边界还需要注意一下。正常情况下，我们要找的应该是 $\lbrack lst_i,i-1\rbrack$。但是，当 $a_i$ 为序列前缀最大值时，我们应该查询的是 $1\sim i-1$ 中的最大值，即此时的 $\lbrack lst_i+1,i-1\rbrack$。

最后是一个细节：当 $a_i$ 非前缀最大值，且找出来的 dp 值为 $0$ 时，证明前面不能分段。此时即使当前这一段能分，之前的也分不成，所以 $f_i=0$。

总结一下，我们的 dp 方程为：
- $v$ 不能整除 $a_i$，此时 $f_i$ 只能放进 $lst_i$ 那一段，$f_i=f_{lst_i}$。
- $v$ 能整除 $a_i$，但 $a_i$ 是前缀最大值，$f_i=f_{lst_i}+\max_{j=lst_i+1}^{i-1}\{f_j+1\}$。
- $v$ 能整除 $a_i$，且 $a_i$ 不是前缀最大值，$f_i=f_{lst_i}+\max_{j=lst_i}^{i-1}\{f_j+1\}$。其中，当 $\max_{j=lst_i}^{i-1}\{f_j+1\}=0$ 时，$f_i=0$。

边界是 $f_1$ 的值，注意判断 $a_1$ 是不是 $v$ 的倍数，否则就会[这样](https://www.luogu.com.cn/record/list?pid=P7244&user=363036&page=1)。

总时间复杂度 $O(\sqrt{mx}+\omega(mx)\times n\log n)$，其中 $\omega(x)$ 表示 $x$ 的因数个数。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 1e5 + 10;
int n, k, mx, a[N];
int lst[N], f[N], rmq[N][20];
//f[i] 为前 i 个数在最大公约数为 v 时最多能分成几段 
vector<int> d;
stack<int> st;

bool cmp(int x, int y){return x > y;}

void update(int id, int val){
	rmq[id][0] = val;
	for(int i=1;(1<<i)<=id;i++)
		rmq[id][i] = max(rmq[id][i - 1], rmq[id - (1 << (i - 1))][i - 1]);//动态更新 ST 表 
}

int query(int l, int r){
	int m = log2(r - l + 1);
	return max(rmq[r][m], rmq[l + (1 << m) - 1][m]);//查询最大值 
}

int main(){
	scanf("%d%d", &n, &k);
	for(int i=1;i<=n;i++){
		scanf("%d", &a[i]);
		mx = max(mx, a[i]);
		while(!st.empty() && a[i] >= a[st.top()])	st.pop();
		if(!st.empty())	lst[i] = st.top();//单调栈优化，求出上一个比 a[i] 大的数 
		st.push(i);//入栈 
	}
	for(int i=1;i*i<=mx;i++){
		if(mx % i == 0){
			d.push_back(i);
			if(i * i != mx)
				d.push_back(mx / i);
		}
	}//求最大值的因数，注意把 1 也放进去 
	
	sort(d.begin(), d.end(), cmp);//按因子从大到小排序
	for(int v: d){
		memset(rmq, 0, sizeof(rmq));
		f[0] = 0;
		f[1] = (a[1] % v ? 0 : 1);//注意特判是否整除！！！！ 
		update(1, f[1]);
		for(int i=2;i<=n;i++){
			if(a[i] % v)
				f[i] = f[lst[i]];//不能整除，直接继承 
			else if(!lst[i]){//前缀最大值， 
				int now = query(lst[i] + 1, i - 1);//找到前缀中的 dp 最大值 
				f[i] = now + 1;
			}
			else{ 
				int now = query(lst[i], i - 1);//从上一个比他大的数的位置开始取dp最大值 
				f[i] = (!now ? 0 : now + 1);//如果前面都分不成，显然后面的也不可能分成，记为 0 
			}
			update(i, f[i]);//更新 dp 值到 ST 表中 
		}
		if(f[n] >= k)
			return printf("%d\n", v), 0;//排好了序，第一个符合条件的就是最大值 
	}
	return 0;
}
```


---

## 作者：team0001 (赞：5)

给出一个复杂度为 $ n * σ_0(\max(a_i)) $ 的做法

枚举全局最大数的约数后考虑 dp 前 $i$ 个数最多能分成多少段，使得每段最大值都是这个数的倍数

一个数可以分是否为它所在段的最大值考虑

得到状态转移方程 $ f_i = \begin{cases}f_j\\ \max(f_k+1) (j\le k<i) \end{cases}$其中 $j$ 是在 $i$ 左边第一个比 $a_i$ 这个数大的数的位置

考虑使用单调栈维护该点左边第一个比它大的数

同时我们还要维护在第 $i$ 个数到左边第一个比他大的数之间的dp值的最大值 $g_i$ ~~显然直接用f是不可行的~~

由于做单调栈的时候如果一个数对 $f_i$ 没有贡献则在它左边且比它小的一段数必然没有贡献，若有贡献则必然一起产生贡献，正确性得到保证

所以这只要在单调栈弹栈的时候顺便取个 $\max$ 就好了，复杂度同单调栈

注意：如果一段都取不出来dp值应设为 -inf（调了30min）

吐槽：由于时间是subtask内取min，决定胜败的居然是剪枝 ? ? ?

不过不加剪枝最慢的点只用了两百多ms，加了后最快二十几ms
```
#include<bits/stdc++.h>
using namespace std;
const int N=100005;
int a[N],f[N],mx,z[N],top,res[N],r,b[N],ans,gx[N];
inline void read(int &x){
	char ch=getchar();x=0;
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')x=x*10+(ch&15),ch=getchar();
}
int main(){
//	freopen("a.in","r",stdin);
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		read(a[i]);if(a[i]>mx)mx=a[i];
	}
	int s=sqrt(mx)+1;
	for(int i=1;i<=s;i++)if(mx%i==0){
		res[++r]=i;if(i*i!=mx)res[++r]=mx/i;
	}
	a[0]=100000000;f[0]=0;
	for(int i=1;i<=r;i++)if(!b[i]&&ans<res[i]){
		int x=res[i];top=0;
		for(int i=1;i<=n;i++){
			int w=(a[i]%x==0?1:-1e9);f[i]=gx[i]=-1e8;
			while(a[i]>=a[z[top]])
			f[i]=gx[i]<gx[z[top]]+w?gx[z[top]]+w:f[i],gx[i]=gx[i]<gx[z[top]]?gx[z[top]]:gx[i],top--;
			if(w<0&&z[top])f[i]=f[i]<f[z[top]]?f[z[top]]:f[i];
			if(w>0)f[i]=f[i]<f[z[top]]+1?f[z[top]]+1:f[i];
			gx[i]=gx[i]<f[i]?f[i]:gx[i];
			z[++top]=i;
		}
		if(f[n]>=m)ans=max(ans,res[i]);
		else {
			for(int j=i+1;j<=r;j++){
				if(res[j]%x==0)b[j]=1;
			}
		}
	}
	printf("%d",ans);
} 
```


---

## 作者：lfxxx (赞：4)

下文令 $d(n)$ 表示 $n$ 的因数个数。

首先不难发现最大值一定会参与取最大公因数运算，所以先枚举最大值的因数，考虑去检查其是否合法，令枚举的因数为 $x$。

首先合并两段后最大值是原来两段最大值其中更大者，所以划分成不少于 $k$ 段即可。

令 $dp_i$ 表示考虑 $[1,i]$ 最多能划分成计算，从 $j$ 转移到 $i$ 能否成立取取决与 $[j+1,i]$ 内最大值是否是 $x$ 的倍数，于是建立单调栈，如果单调栈上一个段最大值是 $x$ 倍数，那么这一段内所有 $dp$ 值都可以向后转移，考虑在单调栈上维护所有可以贡献的段的贡献值的前缀段 $\max$，于是在加入新数弹去栈时，由于新产生的段有被弹出的段合并产生，因此记录段内 $dp$ 最大值，弹出时将最大值合并到新产生的段上，并重新计算新段的前缀段 $dp$ 值 $\max$ 即可，于是总复杂度 $O(\max_{i \leq V} d(i) \times n)$。


```cpp
#include<bits/stdc++.h>
using namespace std;
//#define lowbit(x) (x&(-x))
//#define bp push_back
//#define sz size
//#define cl clear
const int maxn = 1e5+114;
int a[maxn],n,k;
int stk[maxn],val[maxn],Max[maxn],tp;
int mx;
bool check(int x){
    tp=0;
    stk[0]=0;
    val[0]=0;
    Max[0]=-INT_MAX;
    int dp=0;
    for(int i=1;i<=n;i++){
        int pop=-INT_MAX;
        while(a[stk[tp]]<a[i]&&tp>0){
            pop=max(pop,val[tp]);
            tp--;
        }
        stk[++tp]=i;
        val[tp]=max(pop,dp+1);
        Max[tp]=Max[tp-1];
        if(a[stk[tp]]%x==0) Max[tp]=max(Max[tp],val[tp]);
        dp=Max[tp];
    }
    return dp>=k;
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
//	freopen("1.in","r",stdin);
//	freopen("1.out","w",stdout);
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		mx=max(mx,a[i]);
	}
	for(int i=mx;i>=1;i--){
		if(mx%i==0){
			if(check(i)==true){
				cout<<i<<'\n';
				return 0;
			}
		}
	}
	return 0;
}

```

---

## 作者：itisover (赞：4)

没看到笛卡尔树写的，小水一点社区分

题目的性质显然可以搞一颗大根笛卡尔树出来，观察到根必定会有贡献且答案不超过根的值，所以考虑枚举答案 $ans$（根的约数），题目就转成判定能不能 **有条件的** 在树上选至少 $k$ 个能被 $ans$ 整除的点。

到笛卡尔树上从上到下具体分析，考虑算一个点的子树内最多能选几个点，根节点值不小于 $k$ 即为合法。

如果当前结点能被 $k$ 整除，那么贪心的令一个区间包含它，强制让它贡献（不难发现即使强制选了它，对其子树内的点的选择不会干扰），再考虑他的儿子。

如果不能被整除，那么就要让这个值不出现，两种选择：向右并入第一个大于它的点的区间，向左并入第一个大于它的点的区间。


能不能并入取决于其左右有没有比它大的点。不难发现一个结论：如果从根到当前点的路径中的任意点向左儿子移动了，那么当前点就一定存在向右比它大的点。根据笛卡尔树的性质，当前点向右比它大的第一个点之间，一定没有出现过已经走过的点，所以当前点可以独立考虑；另一个方向同理。

所以我们可以算左儿子的贡献（向右并入）或右儿子的贡献（向左并入），两者取较大即可。

对于常规区间数据结构做法，复杂度要少个 $\log$，但是我的写法常数还是大了。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int _=1e5+5;
int n,k,a[_],mx,ans,stk[_],tp;
int ch[_][2];
int dfs(int u,bool flagL,bool flagR,int x){
    if(!u) return 0;
    if(a[u]%x==0) return 1+dfs(ch[u][0],flagL|1,flagR,x)+dfs(ch[u][1],flagL,flagR|1,x);
    else{
        int res=0;
        if(flagL) res=max(res,dfs(ch[u][0],flagL|1,flagR,x));
        if(flagR) res=max(res,dfs(ch[u][1],flagL,flagR|1,x));
        return res;
    }
}
int main(){
    ios::sync_with_stdio(0); cin.tie(0);
    cin>>n>>k;
    for(int i=1;i<=n;++i){
        cin>>a[i];
        if(a[mx]<a[i]) mx=i;
        int k=tp;
        while(k&&a[stk[k]]<a[i]) --k;
        if(k) ch[stk[k]][1]=i;
        if(k<tp) ch[i][0]=stk[k+1];
        stk[++k]=i,tp=k;
    }
    for(int i=1;i*i<=a[mx];++i){
        if(a[mx]%i==0){
            if(dfs(mx,0,0,i)>=k) ans=max(ans,i);
            if(dfs(mx,0,0,a[mx]/i)>=k) ans=max(ans,a[mx]/i);
        }
    }
    cout<<ans;
    return cerr<<"Time: "<<1.0*clock()/CLOCKS_PER_SEC<<endl,0;
}
```

---

## 作者：chenxinyang2006 (赞：4)

提供一个没有枚举最大数约数的题解。

预处理计算出 $i$ 左右第一个 $>a_i$ 的位置，记为 $l_i,r_i$，这个可以通过单调栈 $O(n)$ 解决，如果没有，分别记为 $0$ 和 $n + 1$。

枚举答案 $x$，如果能划分出至少 $k$ 段 $\max$ 为 $x$ 倍数的段，那么也可以合并掉一些段，让段数恰好达到 $k$。

然后取出所有 $x|a_i$，作为新的序列，接下来我们要解决这样一个问题：

- 选择这个序列的最长子序列，对于子序列的每一个元素，选一个 $[x,y] \in [l_i + 1,r_i - 1]$。

- 满足所有区间恰好不重不漏地覆盖 $[1,n]$。

- $[x,y]$ 只包含一个选择的元素。

这个问题看起来比原问题更复杂了，但是去掉了有关 $\max$ 和 $\gcd$ 的部分。

设 $dp_i$ 为选到 $i$，$[1,i]$ 已被覆盖，且必须选择 $i$ 的最大答案。

考虑枚举 $j$ 作为上一个元素，因为第三个限制，所以上上个元素和更之前的元素不会产生影响。

可以发现，只要满足 $r_j > l_i$ ，那么就一定能找到覆盖 $[i,j]$ 的方法。

于是得到状态转移方程：$dp_i = \max(dp_j)+ 1,r_j > l_i$。

注意两个特殊情况，只有 $l_i = 0$ 的位置可以作为这个子序列的开始，只有 $r_i = n + 1$ 的位置可以作为这个子序列的结束。

以 $r_i$ 作为关键字，这是一个区间求 $\max$，单点修改的问题，直接用线段树优化。

这样的复杂度是 $O(n \sqrt {a_i} \log n)$。

因为数据比较水，所以就过了。

```cpp
#include <cstdio>
#include <algorithm>
#include <vector>
using namespace std;
int n,k;
int a[100005],l[100005],r[100005];
vector <int> s[1000005],b;
int dp[100005];

void init(){
	for(int i = 1;i <= n;i++){
		for(int j = 1;j * j <= a[i];j++){
			if(a[i] % j) continue;
			s[j].push_back(i);
			if(j * j != a[i]) s[a[i] / j].push_back(i);
		}
	}
	for(int i = 1;i <= n;i++){
		while(b.size() && a[b.back()] <= a[i]) b.pop_back();
		if(b.size()) l[i] = b.back();
        else l[i] = 0;
        b.push_back(i);
    }
    b.clear();
    for(int i = n;i >= 1;i--){
    	while(b.size() && a[b.back()] <= a[i]) b.pop_back();
		if(b.size()) r[i] = b.back();
        else r[i] = n + 1;
        b.push_back(i);
	}
}

int val[4000005];
#define ls (rt * 2)
#define rs (rt * 2 + 1)

void upload(int rt,int l,int r,int id,int C){
	if(l == r){
		val[rt] = C;
		return;
	}
	int mid = l + r >> 1;
	if(id <= mid) upload(ls,l,mid,id,C);
	else upload(rs,mid+1,r,id,C);
	val[rt] = max(val[ls],val[rs]);
}

int query(int rt,int l,int r,int L,int R){
	if(l == L && r == R) return val[rt];
	int mid = l + r >> 1;
	if(R <= mid) return query(ls,l,mid,L,R);
	else if(L > mid) return query(rs,mid+1,r,L,R);
	else return max(query(ls,l,mid,L,mid),query(rs,mid+1,r,mid+1,R));
}

int check(int x){
	int ans = 0;
	if(s[x].size() < k) return 0;
	for(int i = 0;i < s[x].size();i++){
		int j = s[x][i];	
		dp[j] = query(1,0,n + 1,l[j] + 1,n + 1) + 1;
		if(l[j] == 0) dp[j] = max(dp[j],1);
		if(r[j] == n + 1) ans = max(ans,dp[j]);
		upload(1,0,n + 1,r[j],dp[j]);
	}
	for(int i = 0;i < s[x].size();i++){
		int j = s[x][i];
		upload(1,0,n + 1,r[j],-114514);
	}
	return ans >= k;
}

int main(){
	for(int i = 1;i <= 400000;i++) val[i] = -114514;
	scanf("%d%d",&n,&k);
	for(int i = 1;i <= n;i++) scanf("%d",&a[i]);
    init();
    for(int i = 1000000;i >= 1;i--){
    	if(check(i)){
    		printf("%d\n",i);
    		break;
		}
	}
	return 0;
}
```


---

## 作者：walk_out_study (赞：2)

### 思路
本题要求 $b_i$ 的最大公约数，而 $b_i$ 是 $a_i$ 中一段区间的最大值。因此，我们可以认为，答案一定是  $a_i$ 的最大值（即某个 $b_i$）的约数。
##### 简单的证明
假设不满足以上条件，即 $ans$ 不为 $b_i$ 约数，矛盾。

#### 新问题 
问题被转化为：对于 $x$，是否能把 $a$ 分成 $k$ 个满足条件的子序列。

可以用分治解决，先分再合，分而治之。

#### 解
定义 $Solve(s,e)$ 为 $a_s\sim a_e$ 的最大段数，$m$ 为一段区间的最大值，$xm$ 为 $m$ 所在位置。

分两种情况（**以下推导不考虑越界**）：

1. $m\bmod x=0$。当前区间满足条件，**即至少有一段**。接下来看 $Solve(s,xm-1),Solve(xm+1,e)$。
1. 若不满足，就将包含 $m$ 的区间合并至父亲区间。因为 $s,e$ 都是由第一种情况的 $xm-1,xm+1$ 产生的，所以可以将 $a_{s\sim xm}$ 合并给 $a_{s-1}$ 所在区间，或者将 $a_{xm\sim e}$ 合并至 $a_{e+1}$ 所在区间，再求没有被合并的区间，最后将两者求最大值。
##### 关于合并
如果不越界就一定能合并，因为 $m$ 比父区间的 $m$ 小，如果 $m$ 更大就是 $m$ 当父区间了。

---
第一种情况表示为：
$$Solve(s,e)=1+Solve(s,xm-1)+Solve(xm+1,e)$$
第二种情况表示为：
$$Solve(s,e)=\max(Solve(xm+1,e),Solve(s,xm-1))$$

##### Tips
1. 第二种要判断是否存在可合并的区间，可能只有 $1$ 种，即合并不了，要记得赋初值为 $0$。虽然很基础，但我调了俩小时...
1. 如果直接求 $xm$ 很慢，其实就是 $\operatorname{RMQ}$，st 表就可以了。

### 代码
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
const int LogN=22,N=100001;
int n,k,ans,st[N][LogN],a[N],log[N],ma;
//尽量不要用 log 起名字，此处方便阅读
int mi(int x,int y)
{
    return a[x]>a[y]?x:y;
}
int aski(int s,int e)
{
	int len=log[e-s+1];
	return mi(st[s][len],st[e-(1<<len)+1][len]);
}
void init()
{
    for(int i=2;i<=n;i++)
        log[i]=log[i>>1]+1;
    for(int i=1;i<=n;i++) 
    	cin>>a[i],st[i][0]=i;
    for(int j=1;j<=LogN;j++)
        for(int i=1;i+(1<<j)-1<=n;i++)
            st[i][j]=mi(st[i][j-1],st[i+(1<<j-1)][j-1]);
}
int Solve(int s,int e,int mod)
{
    if(s>e||s<1||e>n) return 0;//越界 
    int xm=aski(s,e),ans1=0,ans2=0;
    if(a[xm]%mod==0)
        return Solve(s,xm-1,mod)+1+Solve(xm+1,e,mod);//第一种 
    else
	{   //第二种 
        if(s>1) ans1=Solve(xm+1,e,mod);
        if(e<n) ans2=Solve(s,xm-1,mod);
        return max(ans1,ans2);
    }
}
int main() {
	cin>>n>>k;
    init();
    int ma=a[aski(1,n)];//全局最大值 
    for(int i=ma;i>=1;i--)
        if(ma%i==0&&Solve(1,n,i)>=k)
		{
            cout<<i;
            return 0;
        }
    return 0;
}
```






---

## 作者：CommandSR (赞：2)

## 题意简化

题面有给出，这里不过多阐释。

## 基本思路：递归 +ST 表

首先，不难证明，我们得到的答案一定是所有数中最大值的约数。

我们可以考虑将最大值的所有约数保存到数组中，**从大到小**遍历，依次在 $O(1)$ 的时间复杂度内判断：

已当前值作为每段最大值的最大公约数，能不能分出 $k$ 段。

一旦发现可行，直接输出。

保存约数：

```cpp
for (int i = 1; i <= sqrt(maxn); i++)
		if (maxn % i == 0)
		{
			b[++cnt] = i;
			if (i * i != maxn) 
				b[++cnt] = maxn / i;
		}
```

设当前数组内最大值约数个数为 $p$ ，则该算法的时间复杂度为 $O(n \times \log{n} \times p)$ ，在 2s 的时间限制下可以通过本题。

接下来解析如何判断已当前值作为每段最大值的最大公约数，能不能分出 $k$ 段。

定义函数 $ solve(x, l, r)$ 为在 $[l, r]$ 区间内找 $x$ 的倍数，能分出的最大段数。

首先我们找出 $[l, r]$ 区间内最大值，可以用线段树或 ST 表维护，记最大值下标为 $cur$ 。

若 $a_{cur}$ 为 $x$ 的倍数，由贪心思想，将 $[l, cur-1]$ 和 $[cur+1, r]$ 两个区间最大段数的和加上当前 $cur$ 这段的一。

即 $1 + solve(x, l, cur-1) + solve(x, cur+1, r)$ 的值。

若 $a_{cur}$ 不为 $x$ 的倍数，分别尝试将 $cur$ 与左边和右边的区间合并，并在另一边找答案，并注意 $l=1$ 和 $r=n$ 的边界条件。

这里直接给出这部分代码：

```cpp
int solve(int x, int l, int r)
{
	if (l > r) return 0;
	int cur = queryMax(l, r);
	if (a[cur] % x == 0) 
		return 1 + solve(x, l, cur-1) + solve(x, cur+1, r);	
	else
	{
		int tmp = 0;
		if (r < n) tmp = max(tmp, solve(x, l, cur - 1));
		if (l > 1) tmp = max(tmp, solve(x, cur + 1, r));
		return tmp;
	}
}
```
最后的部分就是 ST 表求最值了，这里不多加阐述。

## AC Code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 100010;
const int K = log2(N) + 10;
int n, m, a[N];
int f[N][K];
void init()
{
	for (int i = 1; i <= n; i++) f[i][0] = i;
	for (int j = 1; (1 << j) <= n; j++)
		for (int i = 1; i <= n - (1 << j) + 1; i++)
		{
			if (a[f[i][j-1]] > a[f[i+(1<<(j-1))][j-1]])
				f[i][j] = f[i][j-1];
			else f[i][j] = f[i+(1<<(j-1))][j-1];
		}
}
int maxn = 0, b[100010], cnt = 0;
int queryMax(int l, int r)
{
	int k = log2(r - l + 1);
	if (a[f[l][k]] > a[f[r-(1<<k)+1][k]])
		return f[l][k];
	else return f[r-(1<<k)+1][k];
}
int solve(int x, int l, int r)
{
	if (l > r) return 0;
	int cur = queryMax(l, r);
	if (a[cur] % x == 0) 
		return 1 + solve(x, l, cur-1) + solve(x, cur+1, r);	
	else
	{
		int tmp = 0;
		if (r < n) tmp = max(tmp, solve(x, l, cur - 1));
		if (l > 1) tmp = max(tmp, solve(x, cur + 1, r));
		return tmp;
	}
}
int main() 
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> m;
	for (int i = 1; i <= n; i++) 
	{
		cin >> a[i];
		maxn = max(maxn, a[i]);
	}
	init();
	for (int i = 1; i <= sqrt(maxn); i++)
		if (maxn % i == 0)
		{
			b[++cnt] = i;
			if (i * i != maxn) 
				b[++cnt] = maxn / i;
		}
	sort(b + 1, b + 1 + cnt);
	// 从小到大排序，反着遍历，这样答案就是从大到小计算的，先找到的一定是最优解
	for (int i = cnt; i >= 1; i--)
		if (solve(b[i], 1, n) >= m)
		{
			cout << b[i] << '\n';
			break ;
		}
	return 0;
}
```

拒绝抄袭！

---

## 作者：imzfx_Square (赞：1)

前言：小灰毛可爱。

## 分析
由于 $\displaystyle\gcd_{i \in [1,k]}\{b_i\}$ 中必然有一个 $b_i$ 为全局最大值，所以答案必定为最大值的因数。考虑枚举这个因数 $x$ 并求解若答案为 $x$，是否能够划分出 $\ge k$ 段，满足每段的最大值含有因数 $x$。

设 $c(l,r,x)$ 表示因数为 $x$，$[l,r]$ 这一段区间能划分出来的最大段数。设最大值所在位置为 $id$，我们分两种情况讨论：

1. 若 $x \mid a_{id}$，则将 $a_{id}$ 划分出来作为单独的一段，左右两段单独求解，答案为 $c(l,id-1,x)+c(id+1,r,x)+1$。
2. 若 $x \nmid a_{id}$，我们尝试将 $a_{id}$ 合并到两边的区间。若 $a_{id}$ 可被合并，则必定由其他区间转移而来，所以不会影响被合并区间的贡献。若将 $[l,id]$ 向左合并，则应满足 $l>1$，答案为 $c(id+1,r,x)$。若将 $[id,r]$ 向右合并，则应满足 $r<n$，答案为 $c(l,id-1,x)$。两者取最大值，最终答案为 $\max([l>1]c(id+1,r,x),[r<n]c(l,id-1,x))$。

$id$ 可以用 ST 表或线段树之类的数据结构维护。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int n,k,a[N],st[N][25],Max;
void init(){//ST表存储最大值所在下标 
	for(int i=1;(1<<i)<=n;i++)
		for(int j=1;j+(1<<i)-1<=n;j++)
			if(a[st[j][i-1]]>a[st[j+(1<<i-1)][i-1]])
				st[j][i]=st[j][i-1];
			else
				st[j][i]=st[j+(1<<i-1)][i-1];
}
int query(int l,int r){
	int t=log2(r-l+1);
	return a[st[l][t]]>a[st[r-(1<<t)+1][t]]?st[l][t]:st[r-(1<<t)+1][t];
}
int calc(int l,int r,int x){//递归求解 
	if(l>r)return 0;
	int id=query(l,r);
	if(a[id]%x==0)
		return calc(l,id-1,x)+calc(id+1,r,x)+1;//id单独作为一个区间 
	else{
		int res=0;
		if(r<n)res=max(res,calc(l,id-1,x));//[id,r]并到右边 
		if(l>1)res=max(res,calc(id+1,r,x));//[l,id]并到左边 
		return res;
	}
}
int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		Max=max(Max,a[i]);
		st[i][0]=i;
	}
	init();
	for(int i=1;i<=sqrt(Max);i++)//从大到小枚举因数
		if(Max%i==0&&calc(1,n,Max/i)>=k){
			cout<<Max/i;
			return 0;
		}
	for(int i=sqrt(Max);i>=1;i--)
		if(Max%i==0&&calc(1,n,i)>=k){
			cout<<i;
			return 0;
		}
	return 0;
}
```

---


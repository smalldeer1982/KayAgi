# [USACO23OPEN] Tree Merging G

## 题目描述

刚刚完成了一门图算法课程的奶牛 Bessie 开始编写她自己的图可视化工具！目前，她的图可视化工具只能可视化具有不同节点值的有根树，并且只能执行一种操作：合并。

具体来说，合并操作会选取树中具有相同父节点的任意两个不同节点，并将它们合并为一个节点，新节点的值等于被合并的两个节点值的最大值，而新节点的子节点是被合并节点的所有子节点的并集（如果有的话）。

不幸的是，在 Bessie 对一棵树执行了一些合并操作后，她的程序崩溃了，丢失了她执行的所有合并操作的历史记录。Bessie 只记得她最初开始的树以及执行完所有合并操作后得到的最终树。

给定她的初始树和最终树，请确定 Bessie 可能执行的一系列合并操作。保证存在这样的操作序列。

每个输入包含 $T$ 个独立的测试用例。保证所有测试用例的 $N$ 之和不超过 $1000$。

## 说明/提示

$1 \le T \le 100$，$2 \leq N \leq 1000$，$1 \leq v_i, p_i \leq N$，$2 \leq M \leq N$。

- 输入 2-6：初始树和最终树的叶子节点数量相同。
- 输入 7-16：没有额外限制。

## 样例 #1

### 输入

```
1
8
7 5
2 1
4 2
5 1
3 2
8 5
6 2
4
8 5
5 1
6 5
```

### 输出

```
4
2 5
4 8
3 8
7 8
```

# 题解

## 作者：FFTotoro (赞：12)

## 前言

赛时只打出了特殊性质，还是太菜了 /kk。

## 解法

以下描述中，“原始状态”指的是未进行任何合并操作的树，“目标状态”指的是“进行完所有合并操作后的树”，$K_1(a)$ 表示节点 $a$ 在“原始状态”中的子节点集合，$K_2(a)$ 表示节点 $a$ 在“目标状态”中的子节点集合，$w_a$ 表示在目标状态中不存在的节点在操作过程中和它进行合并的节点。

令 $c_{a,b}$ 为“节点 $a$ 是否可以合并进节点 $b$”。显然的，若 $c_{a,b}$ 为真，那么 $a$ 和 $b$ 必须满足以下几个条件：

- 目标状态包含节点 $b$；

- $a\le b$，等号能取到当且仅当目标状态包含节点 $a$；

- $\forall i\in K_1(a)$，$\exists j\in K_2(b)$ 使得 $c_{i,j}$ 为真。

计算出 $c_{a,b}$ 不是难事，可以根据定义，从树的叶子节点开始按照深度递减一直算到根节点即可。

最后构造方案时，从根节点开始按照深度递增一直算到叶子节点，枚举每一个深度指定的节点 $a$，令其在原状态中的父亲为 $f$，那么只要找到一个最大的节点 $b$ 满足 $b$ 在目标状态中的父亲与 $w_f$ 相等（这样可以保证 $a,b$ 现在有同一个父亲）且 $c_{a,b}$ 为真，若最终 $a\ne b$ 就合并 $a,b$。

放代码：

```cpp
/*
ID: CrowMatrix
TASK: Tree Merging
LANG: C++
*/
#include<bits/stdc++.h>
using namespace std;
int p1[1001],p2[1001],d[1001],w[1001];
bool e[1001],c[1001][1001];
int main(){
  ios::sync_with_stdio(false);
  int t; cin>>t;
  while(t--){
    int n,r; cin>>n;
    for(int i=1;i<=n;i++)p1[i]=p2[i]=e[i]=w[i]=d[i]=0;
    for(int i=1;i<=n;i++)
      for(int j=1;j<=n;j++)c[i][j]=false;
    for(int i=1;i<n;i++){
      int v,p; cin>>v>>p; p1[v]=p;
    } // 原状态
    for(int i=1;i<=n;i++)if(!p1[i])r=i;
    int m; cin>>m; e[r]=true;
    for(int i=1;i<m;i++){
      int v,p; cin>>v>>p; p2[v]=p,e[v]=true;
    } // 目标状态
    for(int i=n;i;i--)
      for(int j=1;j<=n;j++)
        if(j!=r)d[j]=d[p1[j]]+1; // 计算节点深度
    for(int i=n;i;i--)
      for(int j=1;j<=n;j++)
        if(d[j]==i)
          if(e[j])c[j][j]=true;
          else for(int k=j;k<=n;k++)
            if(e[k])for(int l=c[j][k]=1;l<=n;l++)
              if(p1[l]==j){
                bool f=false;
                for(int p=1;p<=n;p++)
                  f|=p2[p]==k&&c[l][p];
                c[j][k]&=f; // 逐一检查各项条件是否满足
              }
    cout<<n-m<<endl; w[r]=r;
    for(int i=1;i<=n;i++)
      for(int j=1;j<=n;j++)
        if(d[j]==i){
          for(int k=1;k<=n;k++)
            if(p2[k]==w[p1[j]]&&c[j][k])w[j]=k; // 找合并的目标
          if(j!=w[j])cout<<j<<' '<<w[j]<<endl;
        }
  }
  return 0;
}
```

---

## 作者：kuikuidadi (赞：0)

# 思路
首先点必然一直是在同层，

对于同层的点，只需知道哪些点合并过，顺序无差别。

且注意权值是两两不同的。

根据其叶子的情况判断。

假设有一个三层的树且满足特殊性质 $A$，

则根据叶子是否为兄弟的性质可以判断第二层哪些结点满足合并限制。

但考虑四层就可以发现，限制是从下往上变严格的。

设 $st_{i,j}$ 是判断结点 $j$ 是否可合并到结点 $i$：

1. $i$ 的值大于等于 $j$ 的值。

2. 目标状态包含结点 $i$。

3. 所有初始状态儿子存在和最终状态儿子的合并。

然后再从上往下找 $st(i,j)$ 为 $1$ 且需要合并的即可。

---


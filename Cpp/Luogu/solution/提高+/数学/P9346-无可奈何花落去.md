# 无可奈何花落去

## 题目背景

天上下起了蒙蒙小雨，回家已是傍晚，推开院门，一地花瓣映入眼帘，随着最近几天花瓣的凋落，树上的花瓣已所剩无几。从地上捡起一片花瓣，干涩的双眼立刻充满了泪水，它顺着脸颊滑下。落到花上的，不知是雨还是泪......

## 题目描述

望向树上的花朵：一朵花有 $n$ 瓣花瓣，花瓣之间有 $n-1$ 条边连接，所有的花瓣都是连通的。

树上的花瓣随着春天的离开而凋落。具体地，每一天，都会在未断开的边中均匀随机地选择一条边断开。

当每个花瓣的度数均不超过 $2$ 时，我们称这朵花凋零了。

一朵花期望会在几天后凋零呢？

## 说明/提示

**【样例 1 解释】**

可以发现第一次不管断开哪条边，均会使这朵花凋零，故期望凋零时间为 $1$。

**【样例 2 解释】**

第一次断开 $(1,2)$ 或 $(2,4)$ 或 $(2,5)$，凋零时间为 $1$；第一次断开 $(1,3)$，凋零时间为 $2$。故期望凋零时间为 $\frac{3}{4}\times 1+\frac{1}{4}\times 2=\frac{5}{4}$。

**【数据规模与约定】**

**本题采用捆绑测试。**

-  Subtask 1（1 point）：$f_i=i-1$。
-  Subtask 2（12 points）：$n\leq 8$。
-  Subtask 3（12 points）：$n\leq 18$。
-  Subtask 4（8 points）：$f_i=1$。
-  Subtask 5（16 points）：有且仅有 $1$ 号点度数大于 $2$。
-  Subtask 6（13 points）：$n\leq 50$。
-  Subtask 7（13 points）：$n\leq 100$。
-  Subtask 8（13 points）：$n\leq 500$。
-  Subtask 9（12 points）：无特殊限制。

对于 $100\%$ 的数据，$1\le n\leq 5\times 10^3$，$f_i<i$。

## 样例 #1

### 输入

```
4
1 2 2```

### 输出

```
1```

## 样例 #2

### 输入

```
5
1 1 2 2```

### 输出

```
739246082```

## 样例 #3

### 输入

```
19
1 2 3 4 5 6 1 8 9 10 11 12 1 14 15 16 17 18```

### 输出

```
246415365```

## 样例 #4

### 输入

```
49
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 3 11 13 13 15 1 21 7 20 16 4 3 11 11 24 24 31 33 29 24 21 22 12 27 18 37 25 28 26 22 36 38 29```

### 输出

```
587033383```

# 题解

## 作者：E1_de5truct0r (赞：7)

### 前言

盯着想了好一会儿的。主要是一开始不太知道从哪里下手好，以后还是要提高抓关键的能力。。。

这道题还是一个不错的树形背包题的。

---

### Part I 转化条件

不难发现，每个点度数不超过 $2$ 这个条件，和把一个树剖成若干条链是等价的。

首先一步转化。观察到求第一次成为凋零状态并不好做，因为会重复。因此考虑容斥掉这个限制条件。

具体地，假设 $dp_i$ 表示断掉 $i$ 条边，**第一次成为**凋零状态的答案，$f_i$ 表示断掉 $i$ 条边，**成为**凋零状态的答案。考虑是否可以递推，不难发现如果在求 $dp_i$ 的时候我们已经求出了 $dp_1,dp_2,\dots,dp_{i-1}$，所以我们可以直接用 $f_i-\sum_{j=1}^{i-1} dp_j$ 求。所以直接做就可以了。

那么问题就转化为怎么求凋零状态方案数了。

---

### Part II 解决问题

考虑当前节点 $u$，一共三种可能：

- 和它的儿子没有连边

- 和它的儿子有 $1$ 条边

- 和它的儿子有 $2$ 条边

考虑 DP：$f_{i,j,k}$ 表示第 $i$ 个节点为根的子树内，断开 $j$ 条边之后，状态为 $k$（$k \in \{0,1,2\}$）且凋零的方案数。

考虑从儿子 $v$ 转移到父亲 $i$，无非是断开 / 不断开这条边。

- 断开：$f_{i,j,k}$ 的 $k$ 状态不变。需要在背包的时候扣掉一步用来断掉这条边。

- 保留：$f_{i,j,k}$ 的 $k$ 状态会变大 $1$。这时背包转移是不需要留出这一步的。

而我们不难发现，转移之后的概率为 $i$ 和 $v$ 分配到了各自的步数之后，都成为“凋零”状态的概率乘起来。

为了避免后效性，应把 $f_{i,j,k}$ 拆到 $t_{j,k}$ 里转移，再赋值回去。不过我比较懒就统一使用 $f$ 了。。。

转移方程：

$$\begin{cases}f_{i,j,0}=\sum_{k} f_{i,j-k-1,0} \times (f_{v,k,0}+f_{v,k,1}+f_{v,k,2})\\f_{i,j,1}=\sum_{k} f_{i,j-k-1,1} \times (f_{v,k,0}+f_{v,k,1}+f_{v,k,2})\\f_{i,j,2}=\sum_{k} f_{i,j-k-1,2} \times (f_{v,k,0}+f_{v,k,1}+f_{v,k,2})\\f_{i,j,1}=\sum_{k}f_{i,j-k,0} \times (f_{v,k,0}+f_{v,k,1})\\f_{i,j,2}=\sum_{k}f_{i,j-k,1} \times (f_{v,k,0}+f_{v,k,1})\end{cases}$$

---

### Part III 得出答案

最后对每个 $j$，拿 $\sum_{k \in \{0,1,2\}}f_{1,j,k}$ 作为 $f_j$ 然后按上文（Part I 中）所述的方法，容斥出来最后的答案数组 $dp_j$。

不难发现期望就是概率乘步数。所以输出 $\sum dp_{i} \times i$ 即可。

复杂度 $O(n^2)$。

---

### Part IV 小结

期望题如果贡献的范围小（或者步数是可接受范围），考虑拆成概率和贡献相乘。

对关键词要敏感。善用容斥。

树形背包的关键在于父亲和儿子之间的转移。特点是转移过程中是一棵空树到完整的树的子树添加过程。这可以避免产生后效性。

比较复杂的题目最好使用刷表法写树形背包，一般情况下都比查表好写的多（边界少）。~~虽然这题我也没用刷表，但介于这题码量还行就硬撑了。~~

---

## 作者：Polaris_Australis_ (赞：5)

## 做法一（卡常又卡空，根本过不去）

考虑一种断边方案，最后断的一条边断掉之后，它所连接的两个点至少有一个度数为 $2$。因此对于一个删边集合，只有二度点旁边的边才能作为删边方案中最后一条删掉的边。

设 $T$ 表示所有合法删边集合组成的集合，$num_S$ 表示删边集合 $S$ 中在二度点旁边的边的数量。

$$
\begin{aligned}
ans
&=\frac{1}{(n-1)!}\sum\limits_{S\in T}|S|\times num_S\times(|S|-1)!\times(n-1-|S|)!\\
&=\frac{1}{(n-1)!}\sum\limits_{i=0}^{n-1}i\times(i-1)!\times(n-1-i)!\times\sum\limits_{S\in T,|S|=i}num_S
\end{aligned}
$$

设 $f_{i,j,0/1/2,0/1}$ 表示节点 $i$ 的子树中，删掉 $j$ 条边，节点 $i$ 周围目前保留了 $0/1/2$ 条边，是否钦定 $i$ 号节点为二度点，$num_S$ 的和，再设一个 $g_{i,j,0/1/2,0/1}$ 表示方案数，直接背包转移即可，需要 $21$ 种情况分类讨论，并且根本过不去，不加特判只能拿 $63$ 分。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
namespace Wilson_Inversion { void main(); }
int main() { return Wilson_Inversion::main(), 0; }
namespace Wilson_Inversion {
#define int long long
const int mod = 985661441;
int dp[510][510][2][3], num[510][510][2][3], sz[510], tmp[510][2][3], tmp2[510][2][3], fac[510];
vector<int> e[510];
void dfs(int x) {
	sz[x] = 1;
	num[x][0][0][0] = 1;
	num[x][0][1][0] = 1;
	for (int i : e[x]) {
		dfs(i);
		memcpy(tmp, dp[x], sizeof(tmp));
		memset(dp[x], 0, sizeof(dp[x]));
		memcpy(tmp2, num[x], sizeof(tmp2));
		memset(num[x], 0, sizeof(num[x]));
		for (int j = 0; j < sz[x]; ++j) {
			for (int k = 0; k < sz[i]; ++k) {
				(dp[x][j + k + 1][0][0] += tmp[j][0][0] * num[i][k][0][0] + tmp2[j][0][0] * dp[i][k][0][0]) %= mod;
				(num[x][j + k + 1][0][0] += tmp2[j][0][0] * num[i][k][0][0]) %= mod;
				(dp[x][j + k][0][1] += tmp[j][0][0] * num[i][k][0][0] + tmp2[j][0][0] * dp[i][k][0][0]) %= mod;
				(num[x][j + k][0][1] += tmp2[j][0][0] * num[i][k][0][0]) %= mod;
				(dp[x][j + k + 1][0][0] += tmp[j][0][0] * num[i][k][0][1] + tmp2[j][0][0] * dp[i][k][0][1]) %= mod;
				(num[x][j + k + 1][0][0] += tmp2[j][0][0] * num[i][k][0][1]) %= mod;
				(dp[x][j + k][0][1] += tmp[j][0][0] * num[i][k][1][1] + tmp2[j][0][0] * dp[i][k][1][1]) %= mod;
				(num[x][j + k][0][1] += tmp2[j][0][0] * num[i][k][1][1]) %= mod;
				(dp[x][j + k + 1][0][0] += tmp[j][0][0] * num[i][k][1][2] + tmp2[j][0][0] * dp[i][k][1][2] + tmp2[j][0][0] * num[i][k][1][2]) %= mod;
				(num[x][j + k + 1][0][0] += tmp2[j][0][0] * num[i][k][1][2]) %= mod;

				(dp[x][j + k + 1][0][1] += tmp[j][0][1] * num[i][k][0][0] + tmp2[j][0][1] * dp[i][k][0][0]) %= mod;
				(num[x][j + k + 1][0][1] += tmp2[j][0][1] * num[i][k][0][0]) %= mod;
				(dp[x][j + k + 1][0][1] += tmp[j][0][1] * num[i][k][0][1] + tmp2[j][0][1] * dp[i][k][0][1]) %= mod;
				(num[x][j + k + 1][0][1] += tmp2[j][0][1] * num[i][k][0][1]) %= mod;
				(dp[x][j + k + 1][0][1] += tmp[j][0][1] * num[i][k][1][2] + tmp2[j][0][1] * dp[i][k][1][2] + tmp2[j][0][1] * num[i][k][1][2]) %= mod;
				(num[x][j + k + 1][0][1] += tmp2[j][0][1] * num[i][k][1][2]) %= mod;

				(dp[x][j + k + 1][1][0] += tmp[j][1][0] * num[i][k][0][0] + tmp2[j][1][0] * dp[i][k][0][0] + tmp2[j][1][0] * num[i][k][0][0]) %= mod;
				(num[x][j + k + 1][1][0] += tmp2[j][1][0] * num[i][k][0][0]) %= mod;
				(dp[x][j + k][1][1] += tmp[j][1][0] * num[i][k][0][0] + tmp2[j][1][0] * dp[i][k][0][0]) %= mod;
				(num[x][j + k][1][1] += tmp2[j][1][0] * num[i][k][0][0]) %= mod;
				(dp[x][j + k + 1][1][0] += tmp[j][1][0] * num[i][k][0][1] + tmp2[j][1][0] * dp[i][k][0][1] + tmp2[j][1][0] * num[i][k][0][1]) %= mod;
				(num[x][j + k + 1][1][0] += tmp2[j][1][0] * num[i][k][0][1]) %= mod;
				(dp[x][j + k][1][1] += tmp[j][1][0] * num[i][k][1][1] + tmp2[j][1][0] * dp[i][k][1][1]) %= mod;
				(num[x][j + k][1][1] += tmp2[j][1][0] * num[i][k][1][1]) %= mod;
				(dp[x][j + k + 1][1][0] += tmp[j][1][0] * num[i][k][1][2] + tmp2[j][1][0] * dp[i][k][1][2] + tmp2[j][1][0] * num[i][k][1][2]) %= mod;
				(num[x][j + k + 1][1][0] += tmp2[j][1][0] * num[i][k][1][2]) %= mod;

				(dp[x][j + k + 1][1][1] += tmp[j][1][1] * num[i][k][0][0] + tmp2[j][1][1] * dp[i][k][0][0] + tmp2[j][1][1] * num[i][k][0][0]) %= mod;
				(num[x][j + k + 1][1][1] += tmp2[j][1][1] * num[i][k][0][0]) %= mod;
				(dp[x][j + k][1][2] += tmp[j][1][1] * num[i][k][0][0] + tmp2[j][1][1] * dp[i][k][0][0]) %= mod;
				(num[x][j + k][1][2] += tmp2[j][1][1] * num[i][k][0][0]) %= mod;
				(dp[x][j + k + 1][1][1] += tmp[j][1][1] * num[i][k][0][1] + tmp2[j][1][1] * dp[i][k][0][1] + tmp2[j][1][1] * num[i][k][0][1]) %= mod;
				(num[x][j + k + 1][1][1] += tmp2[j][1][1] * num[i][k][0][1]) %= mod;
				(dp[x][j + k][1][2] += tmp[j][1][1] * num[i][k][1][1] + tmp2[j][1][1] * dp[i][k][1][1]) %= mod;
				(num[x][j + k][1][2] += tmp2[j][1][1] * num[i][k][1][1]) %= mod;
				(dp[x][j + k + 1][1][1] += tmp[j][1][1] * num[i][k][1][2] + tmp2[j][1][1] * dp[i][k][1][2] + tmp2[j][1][1] * num[i][k][1][2]) %= mod;
				(num[x][j + k + 1][1][1] += tmp2[j][1][1] * num[i][k][1][2]) %= mod;

				(dp[x][j + k + 1][1][2] += tmp[j][1][2] * num[i][k][0][0] + tmp2[j][1][2] * dp[i][k][0][0] + tmp2[j][1][2] * num[i][k][0][0]) %= mod;
				(num[x][j + k + 1][1][2] += tmp2[j][1][2] * num[i][k][0][0]) %= mod;
				(dp[x][j + k + 1][1][2] += tmp[j][1][2] * num[i][k][0][1] + tmp2[j][1][2] * dp[i][k][0][1] + tmp2[j][1][2] * num[i][k][0][1]) %= mod;
				(num[x][j + k + 1][1][2] += tmp2[j][1][2] * num[i][k][0][1]) %= mod;
				(dp[x][j + k + 1][1][2] += tmp[j][1][2] * num[i][k][1][2] + tmp2[j][1][2] * dp[i][k][1][2] + tmp2[j][1][2] * num[i][k][1][2]) %= mod;
				(num[x][j + k + 1][1][2] += tmp2[j][1][2] * num[i][k][1][2]) %= mod;
			}
		}
		sz[x] += sz[i];
	}
}
int qp(int x, int y) {
	int res = 1;
	while (y) {
		if (y & 1) res = res * x % mod;
		x = x * x % mod;
		y >>= 1;
	}
	return res;
}
void main() {
	ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
	int n;
	cin >> n;
	for (int i = 2; i <= n; ++i) {
		int f;
		cin >> f;
		e[f].push_back(i);
	}
	dfs(1);
	int ans = 0;
	fac[0] = 1;
	for (int i = 1; i < n; ++i) fac[i] = fac[i - 1] * i % mod;
	for (int i = 1; i < n; ++i) {
		int t = (dp[1][i][0][0] + dp[1][i][0][1] + dp[1][i][1][2]) % mod;
		(ans += t * fac[i - 1] % mod * fac[n - 1 - i] % mod * i) %= mod;
	}
	cout << (ans * qp(fac[n - 1], mod - 2) % mod) << "\n";
}
}
```

## 做法二

设 $p_i$ 表示 $i$ 轮后这个图还有度数大于 $2$ 的点的概率，$q_i$ 相反，$a_{s,i}$ 表示删边序列 $s$ 在删掉前 $i$ 条边后这个图是否还有度数大于 $2$ 的点，$S$ 表示删边序列的全集。

$$
\begin{aligned}
ans
&=\frac{1}{(n-1)!}\sum\limits_{s\in S}\sum\limits_{i=0}^{n-1}a_{s,i}\\
&=\sum\limits_{i=0}^{n-1}\frac{\sum\limits_{s\in S}a_{s,i}}{(n-1)!}\\
&=\sum\limits_{i=0}^{n-1}p_i\\
&=\sum\limits_{i=0}^{n-1}(1-q_i)
\end{aligned}
$$

接下来考虑如何求 $q_i$。设 $f_{i,j,0/1/2}$ 表示 $i$ 子树中，删了 $j$ 条边，$i$ 周围保留了 $0/1/2$ 条边，$i$ 子树中没有度数大于 $2$ 的点的删边方案数，直接背包求即可，$q_i=\dfrac{(f_{1,i,0}+f_{1,i,1}+f_{1,i,2})}{\binom{n-1}{i}}$。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
namespace Wilson_Inversion { void main(); }
int main() { return Wilson_Inversion::main(), 0; }
namespace Wilson_Inversion {
const int N = 5010, mod = 985661441;
int n, sz[N], dp[N][N][3], fac[N], ifac[N], inv[N], tmp[N][3];
vector<int> e[N];
void dfs(int x, int y) {
	sz[x] = 1;
	dp[x][0][0] = 1;
	for (int i : e[x]) {
		if (i == y) continue;
		dfs(i, x);
		memcpy(tmp, dp[x], sz[x] * sizeof(int) * 3);
		memset(dp[x], 0, sz[x] * sizeof(int) * 3);
		for (int j = 0; j < sz[x]; ++j) {
			for (int k = 0; k < sz[i]; ++k) {
				(dp[x][j + k + 1][0] += tmp[j][0] * (0ll + dp[i][k][0] + dp[i][k][1] + dp[i][k][2]) % mod) %= mod;
				(dp[x][j + k][1] += tmp[j][0] * (0ll + dp[i][k][0] + dp[i][k][1]) % mod) %= mod;
				(dp[x][j + k + 1][1] += tmp[j][1] * (0ll + dp[i][k][0] + dp[i][k][1] + dp[i][k][2]) % mod) %= mod;
				(dp[x][j + k][2] += tmp[j][1] * (0ll + dp[i][k][0] + dp[i][k][1]) % mod) %= mod;
				(dp[x][j + k + 1][2] += tmp[j][2] * (0ll + dp[i][k][0] + dp[i][k][1] + dp[i][k][2]) % mod) %= mod;
			}
		}
		sz[x] += sz[i];
	}
}

void main() {
	ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
	cin >> n;
	inv[1] = fac[0] = ifac[0] = 1;
	for (int i = 2; i <= n; ++i) inv[i] = 1ll * (mod - mod / i) * inv[mod % i] % mod;
	for (int i = 1; i <= n; ++i) fac[i] = 1ll * fac[i - 1] * i % mod, ifac[i] = 1ll * ifac[i - 1] * inv[i] % mod;
	for (int i = 2; i <= n; ++i) {
		int f;
		cin >> f;
		e[f].push_back(i), e[i].push_back(f);
	}
	dfs(1, 0);
	int ans = 0, sum = 1, isum = 1;
	for (int i = 0; i < n; ++i) {
		int t = (0ll + dp[1][i][0] + dp[1][i][1] + dp[1][i][2]) * fac[i] % mod;
		(ans += 1ll * (sum - t) * isum % mod) %= mod;
		sum = 1ll * sum * (n - 1 - i) % mod;
		isum = 1ll * isum * inv[n - 1 - i] % mod;
	}
	cout << ((ans + mod) % mod) << "\n";
}
}
```


---

## 作者：小小小朋友 (赞：4)

## 题意

较好理解，计算一棵树上随机断边成为链的期望操作次数。

## 思路

_Thanks to 某大佬。_ 

我们考虑断边顺序的排列，那么答案就是所有排列中使条件成立的最短前缀长度的和除以 $(n-1)!$。

尝试研究一下这个和，发现对于某个前缀长度，我们只需计算出该长度合法的方案数，减去小于该长度合法的方案数即可算出这个长度作为最短前缀长度的方案数。然后方案数乘上长度求和就可以得到上面的和。

可以发现该做法和官方做法本质相同，但这里提供另一种思维路线。

我们 dp，设 $f_{i,j,k}$ 表示 $i$ 的子树中，删去 $j$ 条边，有 $k$ 条边连在 $i$ 节点上的合法情况数。

然后我们用类似树形背包的方式转移，初始化情况只有 $i$ 节点，依次枚举儿子节点，再枚举该儿子节点多删去边的数量，分别乘法原理更新该儿子节点是否连到 $i$ 节点情况数。

根据[结论](https://blog.csdn.net/lyd_7_29/article/details/79854245)可知，该做法复杂度为 $O(n^2)$。

## 代码

 _参考官方题解代码_ 

需要注意本题稍微有点卡空间。

```cpp
#include<bits/stdc++.h>
using namespace std;
const long long mod=985661441;
unsigned int dp[5005][5005][3],siz[5005],f[5005][3];
int fra[5005]={1},inv[5005];
int n;
vector<int> so[5005];
int ksm(int x,int y){
	int t=1;
	while(y){
		if(y&1) t=1ll*t*x%mod;
		x=1ll*x*x%mod;y>>=1;
	}
	return t;
}
void dfs(int x){
	siz[x]=1;dp[x][0][0]=1;
	for(auto v:so[x]){
		dfs(v);
		for(int i=0;i<=siz[x]+siz[v];i++) f[i][0]=f[i][1]=f[i][2]=0;
		for(int i=0;i<siz[x];i++){//树形背包
			for(int j=0;j<siz[v];j++){
				long long g=(dp[v][j][0]+dp[v][j][1]+dp[v][j][2])%mod;
				//与该儿子断开
				f[i+j+1][0]=(f[i+j+1][0]+dp[x][i][0]*g%mod)%mod;
				f[i+j+1][1]=(f[i+j+1][1]+dp[x][i][1]*g%mod)%mod;
				f[i+j+1][2]=(f[i+j+1][2]+dp[x][i][2]*g%mod)%mod;
				//与该儿子连接
				f[i+j][1]=(f[i+j][1]+1ll*dp[x][i][0]*(dp[v][j][0]+dp[v][j][1])%mod)%mod;
				f[i+j][2]=(f[i+j][2]+1ll*dp[x][i][1]*(dp[v][j][0]+dp[v][j][1])%mod)%mod;
			}
		}
		siz[x]+=siz[v];
		for(int i=0;i<siz[x]+siz[v];i++){
			dp[x][i][0]=f[i][0];
			dp[x][i][1]=f[i][1];
			dp[x][i][2]=f[i][2];
		}
	}
}
signed main(){
	for(int i=1;i<=5000;i++) fra[i]=1ll*fra[i-1]*i%mod;
	inv[5000]=ksm(fra[5000],mod-2);for(int i=5000-1;i>=0;i--) inv[i]=1ll*inv[i+1]*(i+1)%mod;
	cin>>n;
	for(int i=2;i<=n;i++){
		int tmp;cin>>tmp;
		so[tmp].push_back(i);
	}
	dfs(1);
	long long sum=0,ans=0;
	for(int i=0;i<n;i++){
		long long F=1ll*(dp[1][i][0]+dp[1][i][1]+dp[1][i][2])%mod*inv[n-1]%mod*fra[n-1-i]%mod*fra[i]%mod;
		F=F-sum;if(F<0) F+=mod;//计算最短合法前缀方案数
		sum+=F;sum%=mod;
		ans=(ans+(F*i)%mod)%mod;//统计期望
	}
	cout<<ans;
	return 0;
}

```


---

## 作者：daniEl_lElE (赞：3)

令 $f_i$ 为断掉 $i$ 条边后**第一次**形成 $i$ 条链的概率。

考虑这个第一次很难计算，不妨令 $g_i$ 为断掉 $i$ 条边后形成 $i$ 条链的方案数，$f_i$ 可以由 $g_i$ 容斥计算。

令 $dp_{i,j,0/1/2}$ 表示看到第 $i$ 个节点，形成了 $j$ 条链，$i$ 号节点不在一个从下面来的链上、$i$ 号节点在一个从下面来的链上、$i$ 号节点在两个从下面来的链上。注意到 $0,1$ 状态可以向上连链，而 $2$ 不行。

状态转移可以分成以下若干种情况：

* 与儿子的链断开，直接转移即可。
* 与儿子的链连接，要求父亲目前没有或有一条链且儿子可以连上来。

不难发现 $g_i=dp_{1,i,0}+dp_{1,i,1}+dp_{1,i,2}$。此时即可算出断掉 $i$ 条边后形成 $i$ 条链的概率，减去 $g_0\sim g_{i-1}$ 即可得到 $f_i$，答案即为 $\sum_{i=1}^ni\times f_i$。

时间复杂度 $O(n^2)$。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int mod=985661441;
int qp(int a,int b){
	if(b<0){
		return qp(qp(a,mod-2),-b);
	}
	int ans=1;
	while(b){
		if(b&1) (ans*=a)%=mod;
		(a*=a)%=mod;
		b>>=1;
	}
	return ans;
}
int fac[3000005],inv[3000005];
void init(){
	fac[0]=1; for(int i=1;i<=3000000;i++) fac[i]=fac[i-1]*i%mod;
	inv[3000000]=qp(fac[3000000],mod-2); for(int i=2999999;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;
}
int C(int i,int j){
	if(i<0||j<0||i<j) return 0;
	return fac[i]*inv[j]%mod*inv[i-j]%mod;
}
vector<int> vc[5005];
signed dp[5005][5005][3];
int siz[5005],tmp[5005][3],tot[5005];
void dfs(int now){
	siz[now]=1; dp[now][0][0]=1;
	for(auto v:vc[now]){
		dfs(v);
		for(int i=0;i<=siz[now]+siz[v];i++) tmp[i][0]=tmp[i][1]=tmp[i][2]=0;
		for(int i=0;i<siz[now];i++){
			for(int j=0;j<siz[v];j++){
				int g=(1ll*dp[v][j][0]+dp[v][j][1]+dp[v][j][2])%mod;
				(tmp[i+j+1][0]+=1ll*dp[now][i][0]*g)%=mod;
				(tmp[i+j+1][1]+=1ll*dp[now][i][1]*g)%=mod;
				(tmp[i+j+1][2]+=1ll*dp[now][i][2]*g)%=mod;
				(tmp[i+j][1]+=1ll*dp[now][i][0]*(1ll*dp[v][j][0]+dp[v][j][1]))%=mod;
				(tmp[i+j][2]+=1ll*dp[now][i][1]*(1ll*dp[v][j][0]+dp[v][j][1]))%=mod;
			}
		}
		siz[now]+=siz[v];
		for(int i=0;i<siz[now]+siz[v];i++) dp[now][i][0]=tmp[i][0],dp[now][i][1]=tmp[i][1],dp[now][i][2]=tmp[i][2];
	}
}
signed main(){
	init();
	int n,ans=0; cin>>n;
	for(int i=2;i<=n;i++){
		int f; cin>>f; vc[f].push_back(i);
	}
	dfs(1);
	for(int i=0;i<n;i++){
		tot[i]=(1ll*dp[1][i][0]+dp[1][i][1]+dp[1][i][2])%mod*inv[n-1]%mod*fac[n-1-i]%mod*fac[i]%mod;
		for(int j=0;j<i;j++) (tot[i]+=mod-tot[j])%=mod;
		(ans+=tot[i]*i%mod)%=mod;
	}
	cout<<ans;
    return 0;
} 
```

---

## 作者：kyEEcccccc (赞：2)

## 题意

给定一棵树，每一轮均匀随机一条还存在的边删除，当所有连通块都是链时停止，问期望进行的轮数。

数据范围：$1\le n\le 2000$。

## 题解

期望持续的轮数，通过期望的线性性拆成经过每个非终止状态的期望次数之和。本题中，每个状态只会经过一次；同时，非终止状态的任何前置状态都是非终止状态。所以有简单结论：如果一个非终止状态是删去了 $x$ 条边得到，那么经过该状态的期望次数为 $\dbinom{n - 1}{x}^{-1}$。于是只需要求有多少种删去了 $x$ 条边的未终止状态。未终止状态不好算，容斥转化为计数删去了 $x$ 条边的终止状态，然后用 $\dbinom{n - 1}{x}$ 减去即可。树形 DP，设 $f_{i, j, k}$ 表示以 $i$ 为根的子树，保留 $j$ 条边，根的度数为 $k$ 的方案总数。容易得出 $k\in [0, 2]$，则可以通过树形背包的经典分析得到 $\Theta(n^2)$ 的时间复杂度。

## 代码

实现比较容易。

```cpp
// Author: kyEEcccccc

#include <bits/stdc++.h>

using namespace std;

using LL = long long;
using ULL = unsigned long long;

#define F(i, l, r) for (int i = (l); i <= (r); ++i)
#define FF(i, r, l) for (int i = (r); i >= (l); --i)
#define MAX(a, b) ((a) = max(a, b))
#define MIN(a, b) ((a) = min(a, b))
#define SZ(a) ((int)((a).size()) - 1)

const int N = 5005, MOD = 985661441;

LL kpow(LL x, LL k = MOD - 2)
{
	x = x % MOD;
	LL r = 1;
	while (k)
	{
		if (k & 1) r = r * x % MOD;
		x = x * x % MOD;
		k >>= 1;
	}
	return r;
}

int fac[N], ifac[N];

LL C(int n, int r)
{
	if (r < 0 || r > n) return 0;
	return fac[n] * (LL)ifac[n - r] % MOD * ifac[r] % MOD;
}

void init_comb(int nn)
{
	fac[0] = 1;
	F(i, 1, nn) fac[i] = fac[i - 1] * (LL)i % MOD;
	ifac[nn] = kpow(fac[nn]);
	FF(i, nn, 1) ifac[i - 1] = ifac[i] * (LL)i % MOD;
}

int n;
int par[N], sz[N];
vector<int> sub[N];
int f[N][N][3];
LL g[N][3];

void dp(int u)
{
	sz[u] = 1;
	f[u][0][0] = 1;
	for (int v : sub[u])
	{
		dp(v);
		F(i, 0, sz[u] - 1) F(p, 0, 2) F(j, 0, sz[v] - 1) F(q, 0, 2)
		{
			LL x = f[u][i][p] * (LL)f[v][j][q] % MOD;
			g[i + j][p] += x;
			if (p != 2 && q != 2) g[i + j + 1][p + 1] += x;
		}
		F(i, 0, sz[u] + sz[v] - 1) F(p, 0, 2)
			f[u][i][p] = g[i][p] % MOD, g[i][p] = 0;
		sz[u] += sz[v];
	}
}

signed main(void)
{
	// freopen(".in", "r", stdin);
	// freopen(".out", "w", stdout);
	ios::sync_with_stdio(0), cin.tie(nullptr);

	cin >> n;
	F(i, 2, n) cin >> par[i], sub[par[i]].push_back(i);
	dp(1);
	init_comb(n);
	LL ans = 0;
	F(i, 0, n - 1)
	{
		LL x = (C(n - 1, i) - f[1][n - 1 - i][0]
			- f[1][n - 1 - i][1] - f[1][n - 1 - i][2]) % MOD;
		ans += kpow(C(n - 1, i)) * x % MOD;
	}
	cout << (ans % MOD + MOD) % MOD << '\n';
	
	return 0;
}
```

---

## 作者：wangyibo201026 (赞：1)

## solution

考虑断边顺序不重要，只需考虑断边集合即可，顺序可以乘个阶乘啥的求出来。

那期望当然就是枚举权值，也就是天数，此时我们令 $p_i$ 为恰好断掉 $i$ 边后成若干条链的方案数，发现可能 $p_i$ 中包含着恰好断掉 $i - 1$ 条边就已经成若干条链的情况，所以容斥一下，$p_i - p_{i - 1}$ 便是我们想要的结果。然后乘上排列组合的系数，那么答案就是 $\frac{\sum_{i = 0}^{n - 1} (p_i \times ( n - 1 - i )! \times i! - p_{i - 1} \times (n - i)! \times (i - 1)!) \times i}{(n - 1)!}$。

然后 $p_i$ 很容易发现大概要写一个 DP 状物求出来，你可以选择将上述式子中排列组合的系数算到 DP 里去。那么链式 DP 比较常见的状态就是 $f_{i, j, 0/1/2}$ 表示 $i$ 的子树内断了 $j$ 条边，然后向子树连了 $0/1/2$ 条边的方案数。

转移的话就是一个树上背包，仔细分讨一下即可，这一点还是不难的。然后这东西的复杂度证明了按照子树大小 DP 是 $O(n^2)$ 的。

那么 $p_i = (f_{1, i, 0} + f_{1, i, 1} + f_{1, i, 2})$，直接照算即可。

## code

code：

```cpp
#include <bits/stdc++.h>
 
using namespace std;
 
// #define int long long
#define fir first
#define sec second
#define mkp make_pair 
#define pb push_back
#define lep( i, l, r ) for ( int i = ( l ); i <= ( r ); ++ i )
#define rep( i, r, l ) for ( int i = ( r ); i >= ( l ); -- i )
 
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
typedef pair < int, int > pii;
 
char _c; bool _f; template < class type > inline void read ( type &x ) {
	_f = 0, x = 0;
	while ( _c = getchar (), !isdigit ( _c ) ) if ( _c == '-' ) _f = 1;
	while ( isdigit ( _c ) ) x = x * 10 + _c - '0', _c = getchar (); if ( _f ) { x = -x; }
}
 
template < class type > inline void chkmin ( type &x, type y ) { x = ( x <= y ? x : y ); }
template < class type > inline void chkmax ( type &x, type y ) { x = ( x >= y ? x : y ); }

const int N = 5005;
const int mod = 985661441;

int n;
int f[N][N][3], siz[N], p[N];
ll g[N][3], fac[N];

int head[N], tot;

struct Node {
  int to, next;
} edges[N << 1];

void add ( int u, int v ) {
  tot ++;
  edges[tot].to = v;
  edges[tot].next = head[u];
  head[u] = tot;
}

ll fast_pow ( ll a, int b ) {
  ll res = 1;
  while ( b ) {
    if ( b & 1 ) {
      res = res * a;
      res %= mod;
    }
    b >>= 1;
    a = a * a;
    a %= mod;
  }
  return res;
}

void dfs ( int x ) {
  siz[x] = 1;
  f[x][0][0] = 1;
  for ( int i = head[x]; i; i = edges[i].next ) {
    dfs ( edges[i].to );
    for ( int j = 0; j <= siz[x] + siz[edges[i].to]; j ++ ) {
      g[j][0] = g[j][1] = g[j][2] = 0;
    }
    for ( int j = 0; j <= siz[x]; j ++ ) {
      for ( int k = 0; k <= siz[edges[i].to]; k ++ ) {
        g[j + k + 1][0] += 1ll * f[x][j][0] * ( ( ll ) f[edges[i].to][k][0] + f[edges[i].to][k][1] + f[edges[i].to][k][2] ) % mod;
        g[j + k + 1][0] %= mod;
        g[j + k + 1][1] += 1ll * f[x][j][1] * ( ( ll ) f[edges[i].to][k][0] + f[edges[i].to][k][1] + f[edges[i].to][k][2] ) % mod;
        g[j + k + 1][1] %= mod;
        g[j + k + 1][2] += 1ll * f[x][j][2] * ( ( ll ) f[edges[i].to][k][0] + f[edges[i].to][k][1] + f[edges[i].to][k][2] ) % mod;
        g[j + k + 1][2] %= mod;
        g[j + k][1] += 1ll * f[x][j][0] * ( f[edges[i].to][k][0] + f[edges[i].to][k][1] ) % mod;
        g[j + k][1] %= mod;
        g[j + k][2] += 1ll * f[x][j][1] * ( f[edges[i].to][k][0] + f[edges[i].to][k][1] ) % mod;
        g[j + k][2] %= mod;
      }
    }
    for ( int j = 0; j < siz[x] + siz[edges[i].to]; j ++ ) {
      f[x][j][0] = g[j][0], f[x][j][1] = g[j][1], f[x][j][2] = g[j][2];
    }
    siz[x] += siz[edges[i].to];
  }
}

void Solve () {
  cin >> n;
  for ( int i = 2; i <= n; i ++ ) {
    int fa;
    cin >> fa;
    add ( fa, i );
  }
  fac[0] = 1;
  for ( int i = 1; i <= n; i ++ ) {
    fac[i] = fac[i - 1] * i % mod;
  }
  dfs ( 1 );
  ll ans = 0;
  for ( int i = 0; i < n; i ++ ) {
    ll val = 1ll * ( ( ll ) f[1][i][0] + f[1][i][1] + f[1][i][2] ) % mod * fac[n - 1 - i] % mod * fac[i] % mod;
    p[i] = val;
    ans += 1ll * ( p[i] - p[i - 1] ) * i % mod;
    ans %= mod;
  }
  cout << ( 1ll * ans * fast_pow ( fac[n - 1], mod - 2 ) % mod + mod ) % mod;
}

signed main () {
#ifdef judge
	freopen ( "Code.in", "r", stdin );
	freopen ( "Code.out", "w", stdout );
	freopen ( "Code.err", "w", stderr );
#endif
	Solve ();
	return 0;
}
```

---

## 作者：Demeanor_Roy (赞：1)

- [原题链接](https://www.luogu.com.cn/problem/P9346)

------------

每个点度数不超过 $2$ 等价于原树形成的每个联通块均为链。

将期望改成求概率，求得 $f_i$ 表示断掉 $i$ 条边**恰好**达成条件的概率，则答案为 $\sum_{i}if_i$。

思考一般树形 dp 的 dp 形式，即 $dp_{u,i}$ 表示以 $u$ 为根子树的 $f$，枚举儿子，想想转移还缺些什么。显然每个点子树内留下了多少边与该点相连是需要知道的，于是增添一维 $k \in [0,2]$ 表示即可。

这样真的就能转移了吗？回顾状态定义，$f$ 表示**恰好**达成条件的概率，转移到**恰好**的状态可不一定也是**恰好**。通俗讲，即对该子树来说，某个儿子内的断边情况是恰好达成条件，可单对那个儿子，不需要断这么多边。于是 $f$ 的转移并不是封闭的。

不妨改写一下定义，令 $f$ 表示已经达成条件的概率。而这样转移就是封闭的。可这能帮助我们求答案吗？显然，原来的 $f$ 可通过现在容斥得出。

根据树形背包的理论，时间复杂度 $O(n^2)$。

---


# 「TAOI-2」喵了个喵 Ⅳ

## 题目背景

小 S 共有 $n$ 只可爱的喵喵，第 $i$ 只喵喵有可爱度 $a_i$。小 S 想要把他的喵喵分成两组。考虑到小 S 的喵喵不像某些喵喵有九条命，他的喵喵只有一条，于是一只喵喵不能被同时分到两组内（请不要试图想象这个画面）。同时，如果一只喵喵没有被分到任意一组，他就会十分生气，很有可能导致小 S 失眠。

当然，小 S 也希望两组的**组可爱度**相等。即存在一个正整数 $x$，使得其中一组的 $\gcd(x, a_i)$ 之和等于另一组的 $\gcd(x, a_i)$ 之和。请你判断是否可以使得小 S 可以将喵喵分成两组，并可以找出一个 $x$ 使得两组的**组可爱度**相等。

## 题目描述

给定正整数 $n$ 及长度为 $n$ 的正整数序列 $a$，请你将 $a$ 划分为两个集合 $B, C$ 并给出正整数 $x$，使得 $\sum_{y\in B}\gcd(x,y) = \sum_{y\in C}\gcd(x,y)$。如果无解，输出 $-1$。

你需要保证 $1 \leq x \leq 10^9$，保证在本题的数据约束下若有解则总有 $x \leq 10^9$ 的解。

## 说明/提示

**本题采用捆绑测试。**

+ Subtask 0（2 pts）：$n$ 为偶数。
+ Subtask 1（8 pts）：$a_i$ 均为奇数。
+ Subtask 2（15 pts）：$n \leq 50$，$a_i \leq 50$。
+ Subtask 3（25 pts）：$n \leq 10^3$，$a_i \leq 10^3$。
+ Subtask 4（50 pts）：无特殊限制。

对于所有数据，$1 \leq n \leq 10^5$，$1 \leq a_i \leq 10^6$。

## 样例 #1

### 输入

```
3
1 1 1```

### 输出

```
-1```

## 样例 #2

### 输入

```
4
4 1 2 3```

### 输出

```
3
0001
```

# 题解

## 作者：Register_int (赞：17)

先特判 $2|n$ 的情况。可以直接 $x=1$ 然后进行均分。

如果 $x$ 是一个奇数，那么取 $\gcd$ 后会将所有数都变成奇数。而由于 $n$ 是奇数，这样做会导致无解。所以 $x$ 必须为 $2$ 的倍数。

此时，如果序列中仍有 $\gcd(a_i,2)>1$，则将所有数 $/2$，同时将 $x/2$，以此类推。并且，我们希望 $x$ 不要包含多余奇数因子，因为乘上奇数因子后无法改变序列奇偶性。因此，选择 $x=2^{k+1}$，其中 $k$ 是使 $\min\gcd(a_i,2^k)\ge 2^k$ 的最大非负整数。

将 $a_i$ 的所有元素与 $2^{k+1}$ 取 $\gcd$ 方便讨论。此时序列中只有 $1$ 或 $2$。容易发现，如果有奇数个奇数，那么必定无解，原因显然。当存在偶数个奇数时，我们只要将两个 $1$ 相加，构造出一个新的 $2$，就能使 $1$，$2$ 的个数均为偶数，实现均分。

总时间复杂度 $O(n)$。

# AC 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int MAXN = 1e5 + 10;

int n, k, a[MAXN], x[2], y[2], cnt;

int main() {
	scanf("%d", &n), k = 20;
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]), k = min(k, __lg(a[i] & -a[i]));
	for (int i = 1; i <= n; i++) a[i] >>= k;
	if (~n & 1) {
		puts("1");
		for (int i = 1; i <= n; i++) putchar(i & 1 ? '1' : '0');
	} else {
		for (int i = 1; i <= n; i++) cnt += a[i] & 1;
		if (cnt & 1) return puts("-1"), 0;
		x[0] = y[0] = n - cnt >> 1, x[0]++;
		x[1] = y[1] = cnt >> 1; x[1]--, y[1]++;
		printf("%d\n", 2 << k);
		for (int i = 1; i <= n; i++) putchar(x[a[i] & 1] ? (x[a[i] & 1]--, '0') : '1');
	}
}
```

---

## 作者：喵仔牛奶 (赞：6)

# Solution

- 先求出所有数的最大公约数 $d$，然后将每个数约去 $d$。将约去后的数均分，约去前的数也均分。下文讨论的数都是约去 $d$ 后的数（包括取的 $x$）。
- $n$ 为偶数，取 $x=1$，对半分即可。
- $n$ 不为偶数，且有奇数个偶数。取 $x=2$，设奇数和偶数分别有 $x,y$ 个，B 组取 $\frac{x}{2}-1$ 个奇数，$\frac{y+1}{2}$ 个偶数即可。因为约去了 $d$，所以 $x>0$。
- $n$ 不为偶数，且有偶数个偶数。不论取什么 $x$ 都有奇数个奇数，无解。
- 输出的时候要把 $x$ 乘上 $d$。赛时因为这个死活调不出来。

# Code
```cpp
#include <bits/stdc++.h>
#define fi first
#define se second
#define pb push_back
using namespace std;
namespace Milkcat {
	typedef long long LL;
	typedef pair<LL, LL> pii;
    typedef vector<LL> poly;
	const int N = 1e6 + 5;
	LL n, d, x, a[N], ans[N];
	int main() {
		cin >> n;
		if (n == 1) return puts("-1"), 0;
		for (int i = 1; i <= n; i ++) cin >> a[i];
		for (int i = 1; i <= n; i ++) d = __gcd(d, a[i]);
		for (int i = 1; i <= n; i ++) a[i] /= d;
		if (n % 2 == 0) {
			x = 1;
			for (int i = n / 2 + 1; i <= n; i ++) ans[i] = 1;
		}
		if (n % 2 == 1) {
			vector<int> odd, even;
			for (int i = 1; i <= n; i ++) {
				if (a[i] % 2 == 0) even.pb(i);
				if (a[i] % 2 == 1) odd.pb(i);
			}
			if (even.size() % 2 == 1) {
				x = 2;
				for (int i = 0; i < odd.size() / 2 - 1; i ++) ans[odd[i]] = 1;
				for (int i = 0; i < (even.size() + 1) / 2; i ++) ans[even[i]] = 1;
			}
			if (even.size() % 2 == 0) x = -1;
		}
		if (x == -1) return puts("-1"), 0;
		cout << x * d << '\n';
		for (int i = 1; i <= n; i ++) cout << ans[i];
		cout << '\n';
		return 0;
	}
}
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
    int T = 1;
    while (T --) Milkcat::main();
    return 0;
}
```

---

## 作者：int08 (赞：6)

## 前言
水题，第二次场切蓝题（个人觉得上位黄或者下位绿）。
# Solution
~~部分分是重要的。~~ 根据部分分我们就有一些发现：因为 $n$ 为偶数的只有两分，说明它简单，我们把这种情况先考虑（什么把字句）。

### 1.$n$ 为偶数
题目竟然允许 $x=1$？这是天大的好消息，为什么？

因为这样可以忽略 $a$ 序列每个数原本的值，直接全部变成 $1$。

（意思是说任何数与 $1$ 的最大公约数即为 $1$）

所以直接 $x=1$ 然后平均分配 $n$ 个数即可。

这个点看似简单，实则非常重要，他给我们做这道题的启示是：通过设置**较小的 $x$** 就能把值域宽泛的原序列转换成值域狭窄的新序列进行处理。
### 2.$n$ 为奇数
部分分再度登场！为什么全奇数也是部分分？

~~直觉告诉我它无解。~~
#### 2.1 全奇数
事实上 $a_i$ 全奇数时候对于任意 $x$ 生成序列仍然为全奇数，奇数乘奇数当然序列总和也为奇，怎么可能能均分成两份呢？肯定不行！输出 $-1$。

这个部分分的启发就是告诉我们 $x$ 不能为奇数！否则生成序列又全奇数了。

感性理解之后，初步认为 $x$ 带奇数因子都是~~像我的题解一样~~无意义的。

#### 2.2 上一个点的启发：奇数数量为奇数时
当奇数数量为奇数时，我们已经说了 $x$ 为偶，所以生成序列有奇数个为奇数，（剩下的）偶数个为偶数，和又为奇数再次无解。

#### 2.3 上上个点的启发（？）：奇数数量为偶数时

由上推导，这个点不能证明无解，应该得有解了。

由第一条和第 2.1 条告诉我们：$x$ 应该小，$x$ 不应该有奇数因子。

想到 $x=2$。

此时序列正好有偶数个 $1$ 奇数个 $2$，容易发现可以解决，自己想想为什么。

具体解决方案：一边分两个 $1$ 另一边分一个 $2$ 剩下的数就可平分了。

#### 2.4 漏网之鱼：全偶数

此情况下 $x=2$ 时生成序列又全是偶数，结果就是找不出两个 $1$。

但是又不能证明它无解，应该还是有解的。

发现 全偶数时每个数都有因子 $2$ 导致 $x=2$ 没有区分度，和 $x=1$ 一样了。

对！和 $x=1$ 一样了！

可以把全偶数且 $x=2$ 的情况变成全部除以 $2$ 然后 $x=1$ 情况。就可以按 2.4 处理，直到 $a_i$ 中出现奇数按上面处理。 

所有情况考虑完毕。
## 总结
典型的由部分分启发正解。

## AC 代码
```
#include<bits/stdc++.h>
using namespace std;
long long i,n,a[500000],z,o,zp,op,zq,oq;
int main()
{
	cin>>n;
	if(n%2==0)
	{
		cout<<1<<endl;
		for(i=1;i<=n/2;i++) cout<<"01";
		return 0;
	}
	for(i=1;i<=n;i++)
	{
		cin>>a[i];
		if(a[i]%2==0) z++;
			else o++;
	}
	if(o%2==1)
	{
		cout<<-1;
		return 0;
	}
	long long g=1;
	if(z==n)
	{
		z=0;o=0;
		g=a[1]&-a[1];
		for(i=2;i<=n;i++) g=__gcd(g,a[i]);
		for(i=1;i<=n;i++)
		{
			a[i]/=g;
			if(a[i]%2==0) z++;
			else o++;
		}
		if(o%2==1)
		{
			cout<<-1;
			return 0;
		}
	}
	cout<<g*2<<endl;
	long long s=2*z+o;
	if(z%2==1) {
		zq=min(s/4,z);
		oq=s/2-zq*2;
	}
	else
	{
		s-=2;o-=2;
		zq=min(s/4,z);
		oq=s/2-zq*2+1;
	}
	for(i=1;i<=n;i++)
	{
		if(a[i]%2==0)
		{
			if(zp<zq)
			{
				cout<<0;zp++;
			}
			else cout<<1;
		}
		if(a[i]%2==1)
		{
			if(op<oq)
			{
				cout<<0;op++;
			}
			else cout<<1;
		}
	}
	return 0;
 } 
```
# The End.

---

## 作者：TernaryTree (赞：5)

定义序列 $b_i=\gcd(a_i,x)$。

当 $n$ 为偶数，直接 $x=1$ 即可。所以我们只考虑 $n$ 为奇数。考虑 $x=2$，序列就变成 一堆 $1$ 一堆 $2$。

如果和为偶数，枚举 $2$ 的个数，相应地找到 $1$ 的个数即可（找不到的话怎么办呢？大家先思考一下）。

如果和为奇数，我们可以证明无解：

> 若取 $x$ 偶数，原来的 $1$ 还是 $1$，原来的 $2$ 会变但是依然为偶数，奇偶性不变，仍无解；若取 $x$ 奇数，原序列全是奇数，而 $n$ 为奇数，奇数个奇数相加仍为奇数，无解。

看起来到这里就差不多了，然而我们会碰到找不到的情况。例如：

```
3
2 2 4
```

此时 $b=\{2,2,2\}$，我们想将其分为 $3+3$，但是找不到 $1$ 啊！

所以上面做法的正确性成立当且仅当 $b$ 中存在 $1$。

那怎么办呢。我们不妨在二进制下看一些数。它们有一些共同的 $0$ 后缀（也有可能没有，即长度为 $0$）。我们将后面公共的 $0$ 全部遮住不看，从第一个存在 $1$ 的位考虑。这里再取 $x=2$ 是显然有 $1$ 存在的。注意到后面公共 $0$ 表示的数即为 $\min(\operatorname{lowbit}(a_i))$，于是我们构造 $x=2\min(\operatorname{lowbit}(a_i))$，对 $\dfrac{a_i}{\min(\operatorname{lowbit}(a_i))}$ 做最简单的 $x=2$ 考虑即可。其原理是 $c\gcd(a,b)=\gcd(ac,ab)$。

赛时比较脑弹写了 set 维护位置，根本不用，凭空多一个 log。用其他东西随便做。

```cpp
#include <bits/stdc++.h>
#define int long long

using namespace std;

const int maxn = 1e6 + 10;

int n;
int a[maxn];
bool b[maxn];
set<int> s[2];
int g = 1e10;

signed main() {
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> a[i], g = min(g, a[i] & -a[i]);
	for (int i = 1; i <= n; i++) a[i] /= g;
	if (!(n & 1)) {
		cout << 1 << endl;
		for (int i = 1; i <= n; i++) cout << (i <= (n >> 1));
	} else {
		for (int i = 1; i <= n; i++) s[a[i] & 1].insert(i);
		if (s[1].size() & 1) puts("-1");
		else {
			cout << g * 2 << endl;
			int tot = s[1].size() / 2 + s[0].size();
			for (int i = 0; i <= s[0].size(); i++) {
				if (tot - i * 2 >= 0 && tot - i * 2 <= s[1].size()) {
					for (int j = 1; j <= i; j++) {
						b[*s[0].begin()] = 1;
						s[0].erase(*s[0].begin());
					}
					for (int j = 1; j <= tot - i * 2; j++) {
						b[*s[1].begin()] = 1;
						s[1].erase(*s[1].begin());
					}
					for (int i = 1; i <= n; i++) cout << b[i];
					return 0;
				}
			}
		}
	}
	return 0;
}
```

---

## 作者：NBest (赞：4)

第一眼还是一点头绪都没有，所以再看一眼部分分，思考 $n$ 偶数的时候，我们只需要让全部 $\gcd$ 为 $1$ 然后对半分即可，$a_i$ 全是奇数的时候，一开始我是先直接输出 $-1$ 发现这一档数据全过了，再考虑到奇数的 $\gcd$ 也是奇数，在 $n$ 也为奇数的情况下是不可能分成相等的两部分的（奇数个奇数相加也是奇数，无法对半分）。

这时我考虑到这题是不是也有什么结论，比如只需要考虑奇偶什么的，想到假如有偶数，并且偶数个数为奇数，这时令 $x$ 为 $2$，然后去掉一个偶数对半分，让其中的一个 $1$ 跑到另外一组去再把这个 $2$ 放到这组即可，对于偶数个偶数，抵消后是会剩下奇数个 $1$ 然后凑不出来的输出 $-1$。交上去发现一个点都没过？这个时候我就开始怀疑我解法的正确性了。同时我又交了一个如果全是偶数就输出 $-1$ 的特判，发现之前输出 $-1$ 能过的点又都过了？我就理所当然的认为全是偶数和全是奇数都是不行的，最后结束了也没想到正解。

后来经过题解的一点点指点，瞬间知道为什么错了——大部分数据都是全偶的，只需要把全偶的除上若干个 $2$ 看成之前的情况做就行了。
## $Code$
```cpp
int n,a[100005],k=1000000,ou;
int main(){
    n=read();
    for(int i=1;i<=n;i++)
        k=min(k,((a[i]=read())&-a[i]));
    for(int i=1;i<=n;i++)
        ou+=(a[i]/=k)+1&1;
    if(n+1&1){
        puts("1");
        for(int i=1;i<=n/2;i++)printf("01");
        return 0;
    }
    if(ou+1&1)return puts("-1"),0;
    printf("%d\n",k<<1);
    int o2=ou/2,o1=(n-ou)/2+1;
    for(int i=1;i<=n;i++){
        if(a[i]&1){
            if(o1)o1--,putchar(49);
            else putchar(48);
        }else{
            if(o2)o2--,putchar(49);
            else putchar(48);
        }
    }
}
```

---

## 作者：One_JuRuo (赞：3)

## 思路

考试的时候打死没想出来，一直在想暴力和质因数分解，我实在是太弱了，比赛后看了官方题解才恍然大悟，于是来~~蹭~~写篇题解。

首先是一些特殊点：

1. 当 $n$ 是偶数时，显然 $x$ 可以取 $1$，这样 $\gcd$ 就都是 $1$，然后随便平分就好了。恭喜你，你获得了 $2$ 分。

2. 当 $n$ 不是偶数，且 $a_i$ 均为奇数，那么无论怎么 $\gcd$ 都是奇数，所以 $\gcd$ 之和也一定是奇数，那必然无法划分，那么就是无解。恭喜你，你又获得了 $8$ 分（蒟蒻的我比赛的时候连这都没想到，痛失 $8$ 分）。

2. 当 $n$ 不是偶数时，这种情况比较难办，下面专门详细讲解。

首先容易发现 $x=1$ 时，$\gcd$ 之和就是 $n$，但是 $n$ 为奇数，显然不满足要求。

这样，我们可以尝试增大 $x$ 的倍数。

假设扩大了 $x$ 共 $k$ 倍，那么 $\gcd(a_i,x)$ 的变化一定是扩大 $l$ 倍，其中 $l$ 是 $k$ 的因子，那么对于和的贡献是 $(l-1)\times \gcd(a_i,x)$。

这样的话，只有 $l$ 为偶数，$\gcd(a_i,x)$ 为奇数时，贡献才能增加奇数，才能使和变为偶数。

所以我们扩大倍数扩大奇数倍是毫无作用的，扩大倍数含奇数因子意义也不大，所以我们要扩大的倍数只有 $2^s,s\in \mathbb{Z}$ 最有效。

那么 $s$ 取几最合适呢？

有两种方法，第一种是挨个试，试到 $2^s$ 比最大的 $a_i$ 还要大为止，不过没有试过，不清楚会不会 TLE。

第二种，我们可以随意构造一个同时含奇数、偶数的数列，如果奇数的个数奇数个，那就意味着 $x$ 不能取 $1$，如果把 $x$ 扩大 $2$ 倍，奇数的个数不会变，其余的 $\gcd$ 要么不变，要么也扩大 $2$ 倍，和仍然是偶数，所以这种情况一定是无解。那么，我们可以尝试把问题归纳到这种情况解决。

那么，怎么找到那个数呢，这里推荐一种比较方便的方法，那就是 $lowbit$。

$lowbit(x)$ 可以取出 $x$ 在二进制形式下的最末位的 $1$ 以及后面的 $0$。举个例子，$12$ 的二进制形式是 $1100$，那么 $lowbit(12)=4$。（$4$ 的二进制形式是 $100$）

那么，怎么计算 $lowbit$ 呢？

其实很简单，只需要一行代码就能搞定：```inline int lowbit(int x){return x&(-x);}```

原理就要涉及负数的编码了，负数都是正数的反码再加 $1$ 得到的。

例如 $12$ 的反码就是 $0011$（省略了前面若干位 $1$），再加 $1$ 就是 $0100$，再与原数进行按位与计算，就得到了 $lowbit$。

总而言之就是，二进制末尾有连续多少个 $0$，反码就有连续多少个 $1$，再加上一个 $1$ 使其进位，最后与原数一样的就只有最后一个 $1$ 及其后面的 $0$。

所以我们只需要把每个数都除以最小的 $lowbit$ 就可以得到上述的情况。

我们再统计奇数数量，如果数量为偶，则有解；否则，无解。

那么，我们再确定 $x=2$（除后的，输出记得乘回去），问题就被转化为了有偶数个 $1$，和奇数个 $2$ 如何分配了。

只需要把两个 $1$ 放在第一组，其他 $1$ 平分，$2$ 平分，然后把多出的一个 $2$ 给第二组就好了。

## AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int lowbit(int x){return x&(-x);}
int n,a[100005],low=1000005,sum,flag,cnt1,cnt2=1;
int main()
{
	scanf("%d",&n);
	if(n%2==0)//先把n为偶的判断了
	{
		printf("1\n");
		for(int i=1;i<=n/2;++i) printf("01");
		exit(0);
	}
	for(int i=1;i<=n;++i) scanf("%d",&a[i]),low=min(low,lowbit(a[i]));//记录最小lowbit
	for(int i=1;i<=n;++i) a[i]/=low,sum+=a[i]%2;
	if(sum%2) printf("-1"),exit(0);
	printf("%d\n",2*low);//记得乘回去
	for(int i=1;i<=n;++i)
	{
		if(a[i]%2)
		{
			if(flag<2) flag++,a[i]=0;//flag记录在第一组单独放了多少个了
			else a[i]=cnt1,cnt1^=1;//然后就是平均分配了
		}
		else
		{
			a[i]=cnt2,cnt2^=1;//从第二组开始平均分配
		}
	}
	for(int i=1;i<=n;++i) printf("%d",a[i]);
}
```

---

## 作者：rizynvu (赞：2)

[我的博客](https://www.cnblogs.com/rizynvu/p/18502036)。

首先对于 $n\bmod 2 = 0$ 的情况，比较显然的是直接令 $x = 1$。  
这样就有 $\gcd(a_i, x) = 1$ 了，那么直接每部分 $\frac{n}{2}$ 个即可。

接下来考虑 $n\bmod 2 = 1$ 的情况。  
此时就发现 $x = 1$ 不管用了，因为此时 $\sum \gcd(a_i, x) = n \bmod 2 = 1$。

注意到部分分中有个 $a_i\bmod 2 = 1$ 的 sub。  
如果去手玩一下能够发现这必定无解。

思考一下这是为什么，考虑找一下合法的必要条件。  
注意到因为 $\sum_{y\in B} \gcd(x, y) = \sum_{y\in C} \gcd(x, y)$，那么必然有 $\sum\limits \gcd(a_i, x)\bmod 2 = 0$ 才有可能有合法的拆分。

那么对于 $a_i\bmod 2 = 1$，能够发现无论如何选择 $x$ 都有 $\gcd(a_i, x)\bmod 2 = 1$，所以最后的总和必定还是 $\bmod\ 2 = 1$。

于是现在的一个想法是首先调整总和为偶数，再进一步考虑。  
那么考虑如何调整总和为偶数，因为当 $x = 1$ 时 $\gcd(a_i, x) = 1$，那么就可以通过将 $\gcd(a_i, x)$ 变为偶数的方式使得奇偶性变换。  
于是可以知道的是最后肯定有 $2 | x$。  

同时发现继续往 $x$ 上乘一些数就不再会改变奇偶了，因为偶数依然为偶数，奇数依然为奇数。  

所以只需要把 $x = 2$ 先代入进去检验 $\sum \gcd(a_i, x)$ 是否为偶数，如果为奇数则必然不可行。

然后考虑此时能不能构造了，发现因为此时 $\gcd$ 只有 $1, 2$，所以看起来已经能够凑出来 $\frac{\sum\limits \gcd(a_i, x)}{2}$ 了……吗？

考虑到如果对于任意 $i$，都有 $\gcd(a_i, x) = 2$，那么就构造不出来了。  
但是注意到这等价于 $\gcd(a_i, x) = 1$ 的情况，又可以继续除掉这个 $2$ 继续处理了。

于是只需要得到 $g = \gcd(a_1, \cdots, a_n)$，以 $\frac{a_i}{g}$ 去处理就行了（此时至少有一个奇数），同时最后的 $x$ 乘上 $g$ 即可。  

求 $\gcd$ 的复杂度是均摊的，时间复杂度 $\mathcal{O}(n + \log V)$。

```cpp
#include<bits/stdc++.h>
const int maxn = 1e5 + 10;
int n, a[maxn], col[maxn];
int main() {
   scanf("%d", &n);
   if (~ n & 1) {
      puts("1");
      for (int i = 1; i <= n; i++) {
         putchar((i <= n / 2) ^ '0');
      }
      return puts(""), 0;
   }
   for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
   int g = 0;
   for (int i = 1; i <= n; i++) g = std::__gcd(g, a[i]);
   int sum = 0;
   for (int i = 1; i <= n; i++) {
      a[i] /= g;
      a[i] = 1 + (~ a[i] & 1), sum += a[i];
   }
   if (sum & 1) {
      return puts("-1"), 0;
   }
   sum /= 2;
   for (int i = 1; i <= n; i++) {
      if (a[i] == 2 && sum >= 2) {
         col[i] = 1, sum -= 2;
      }
   }
   for (int i = 1; i <= n; i++) {
      if (! col[i] && sum >= a[i]) {
         col[i] = 1, sum -= a[i];
      }
   }
   printf("%d\n", g * 2);
   for (int i = 1; i <= n; i++) {
      printf("%d", col[i]);
   }
   return puts(""), 0;
}
```

---

## 作者：kanzaki (赞：2)

## 题目分析
给一个有 $n$ 个数的数组 $a$，要求找出一个 $x$ 将数组 $a$ 分为 $B$ 和 $C$ 两组，满足 $B$ 组 $\gcd(x,y)$ 之和等于 $C$ 组 $\gcd(x,y)$ 之和。若无解则输出 $-1$。

$\gcd(x,y)$ 表示 $x$ 和 $y$ 的最小公约数。

## 思路
对于本题，我们可以先考虑特殊情况。

当 $n$ 为偶数时，$x$可以取 $1$。所有数和 $1$ 的最小公约数都是 $1$，所以我们只需要将 $a$ 中的数平均分配即可。

当 $n$ 为奇数，且 $ai$ 均为奇数时，$x$ 不管怎么取值 $\gcd(x,y)$ 总为奇数且有奇数个。$B$ 组和 $C$ 组无法相等，无解，输出 $-1$。

对于其他情况，我们需要先找出 $x$ 的大小。显然，我们可以找出一个 $x$ 使得 $\gcd(x,y)$ 只会等于 $0$ 或 $1$。 

在这种情况下，若 $ai$ 为奇数，则值为 $1$；若 $ai$ 为偶数，则值为 $0$。我们可以在 $B$ 组里放 $2$ 个 $1$，在 $C$ 组里放 $1$ 个 $2$ 使两组相等。

用 $odd$ 表示奇数个数，$n$ 表示 $a$ 含有数的个数。则 $B$ 组共有 $(n-odd+1)/2$ 个偶数，$odd/2-1$ 个奇数。

考虑如何取 $x$。由前面的思路可以得出 $x$ 不应该为奇数。如果 $x$ 为奇数，则可能使产生奇数个奇数，使题目无解。所以我们可以考虑将 $x$ 的形式表现为 $2^m$ $^+$ $^1$。

需要注意的是，$m$ 需要初始化为一个较大的数从而保证能够正确求出。

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define maxn 100005
#define inf 0x7fffffff
int odd,x[2],y[2],n,m=inf,a[maxn];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		m=min(m,__lg(a[i]&-a[i]));
	}//输入并判断m大小 
	for(int i=1;i<=n;i++){
		a[i]>>=m;//注意x并不是m而是2^(m+1)
		if(a[i]%2==1) odd++;
	}//每个数都除以2^(m+1)并判断奇数个数 
	if(n%2==0){
		cout<<1<<endl;
		for(int i=1;i<=n/2;i++){
			cout<<"01";
		}
		return 0;
	}//n为偶数直接平均分 
	if(odd%2==1){
		cout<<-1;
		return 0;
	}//奇数有奇数个则无解 
	x[0]=(n-odd)/2,x[0]++;
	x[1]=odd/2,x[1]--;
	//x[0]表示第一组有(n-odd+1)/2个偶数 
	//x[1]表示第一组有odd/2-1个奇数
	cout<<(2<<m)<<endl;
	for(int i=1;i<=n;i++){
		if(x[a[i]%2]){
			x[a[i]%2]--;
			cout<<0;
		}//若B组未放完，则放入B组 
		else cout<<1;//否则放入C组 
	}
	return 0;
} 
```


---

## 作者：Linghua_dog (赞：2)

## $\textbf{Solution}$

第一次场切 T3 写篇题解记录一下，第一眼看到这道题，我是一点思路没有，那么遇到这种情况，我们直接去看 Subtask 来找思路。


### $\textbf{Subtask0}$ 

当 $n$ 为偶数时，只需把每一个数与 $1$ 进行 $\gcd$，就变成了偶数个 $1$ 分成两组，显然成立。


### $\textbf{Subtask1}$

如果 $a_i$ 都为奇数，那么无论 $x$ 取何值，$\gcd$ 全都是奇数，那么奇数个奇数，怎么分两组的奇偶性都不同，所以无法分组，输出 `-1`。


### $\textbf{Subtask2 \& Subtask3 \& Subtask4}$

由前面的性质可知，我们只需处理至少含有一个偶数，且长度为奇数的序列，那么我们分类讨论。

当有偶数个偶数时，与前面的奇偶分析类似，我们可以证明这样做是无法分组的，直接输出 `-1`。

当有奇数个偶数时，我们用 $2$ 去 $\gcd$ 每一个数，偶数就变成了 $2$，奇数就变成 $1$ 那么我们拿出两个 $1$ 变成 $2$，这样我们就剩下了偶数个 $2$ 和偶数个 $1$ 这样平均分成两组即可，于是，我场上愉快的 WA 了，我举了一组样例，

```cpp
3
4 2 2
```

如果按照之前的分析，它没有奇数，不能分组，但实际上它是可以用 $4$ 去 $\gcd$ 的，那怎么办呢，此题的重点来了，如果全是偶数的情况，我们需要把它转化成我们会做的形式，即有奇数有偶数的形式，那是否可以把所有偶数都除以 $2$ 一直除到有奇数为止，显然这是成立的，所以就解决了所有情况，直接 AC。

### $\textbf{AC Code}$

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <map>

using namespace std;

const int N = 1e5 + 10;

int a[N];
bool st[N];

int main()
{
	int n;
	cin >> n;
	for(int i = 1; i <= n; i++) cin >> a[i];
	if(n % 2 == 0)
	{
		cout << 1 << '\n';
		for(int i = 1; i <= n / 2; i++) cout << 0;
		for(int j = 1; j <= n / 2; j++) cout << 1;
	}
	else
	{
 		bool f = true; int x = 2;
		while(f)
		{
			for(int j = 1; j <= n; j++) if(a[j] & 1) f = false;
			if(!f) break;
			for(int j = 1; j <= n; j++) a[j] /= 2;
			x *= 2;
		}
		
		int cnt = 0;
		for(int i = 1; i <= n; i++) if(!(a[i] & 1)) cnt ++;
		if(cnt % 2 == 0)
		{
			puts("-1");
			return 0;
		}
		int rest = n - cnt;
		if(rest == 0) puts("-1");
		else
		{
			cout << x << '\n';
			rest = rest / 2 - 1;
			for(int i = 1; i <= n; i++)
			{
				if(a[i] & 1)
				{
					st[i] = true;
					rest--;
				}
				if(!rest) break;
			}
			
			int k = cnt / 2 + 1;
			for(int i = 1; i <= n; i++)
			{
				if(!(a[i] & 1))
				{
					k--;
					st[i] = true;
				}
				if(!k) break;
			}
			
			for(int i = 1; i <= n; i++) cout << st[i];
		}
	}
}
```

---

## 作者：irris (赞：1)

## C - 喵了个喵 IV

若 $n$ 为偶数，容易发现样例是唬人的，可以令 $x = 1$ 并输出 $\frac n2$ 个 $\tt 0$ 和 $\frac n2$ 个 $\tt 1$。

否则考察 $n$ 为奇数。

我们想要分成两组，**最基本的必要条件是 $sum = \sum \gcd(x, a_i)$ 是偶数**，并且从这个想法出发。初始令 $x = 1$，这时 $sum = n$ 为奇数。

不妨考虑给 $x$ 括倍，让 $x \gets kx(k \geq 2)$，这可以表示出最后可能的所有 $x$。这时，一些 $\gcd$ 会发生改变。

更具体地，只有 $\gcd(x, a_i) = x$ 的这些 $\gcd$ **有可能** 改变为 $kx$，这会对 $sum$ 带来 $(k-1)x$ 的贡献。

**为了让 $\bm{sum}$ 改变奇偶**，一定有 $x$ 为奇数且 $k$ 为偶数，否则 $(k - 1)x$ 为偶数，那么累加多少个 $(k - 1)x$ 都不奏效。但若 $k$ 为偶数，那么第二次改变时 $x$ 一定也是偶数了，所以得到只能在 $x = 1$ 时改变一次。我们的想法是：因为对 $k$ 进行质因数分解可以看做是多次括倍，所以 $k$ 为质数的幂才有用；**此时只有 $\bm{k = 2^s}$ 有效**，故 $x = 2^s(s \geq 1)$。

如果我不想枚举 $s$ 怎么办？考虑 $n = 3, a = [32, 32, 320]$，这时有解 $x = 64$。我们若一个个枚举 $x$，$x = 2, 4, 8, 16\dots$ 分别得到的新数列为 $[2, 2, 2][4, 4, 4][8, 8, 8][16, 16, 16]$，容易发现这完全等价于 $[1, 1, 1]$。

**于是考虑给所有数除以它们的 $\bm{\gcd}$**，正确性显然；这时令 $x = 2$，则一定有至少一个 $1$ 产生（因为至少有一个数没有因子 $2$ 了）。如果此时依旧无解，即此时有偶数个 $1$，无论给 $x$ 再乘上几个 $2$ 也同样都无解了。

下有供参考的其它各档部分分做法：

+ Subtask 1：对 $n$ 为奇数输出 `-1`，证明参考上文。
+ Subtask 2：枚举 $x \leq \max a_i$ 进行背包。
+ Subtask 3：枚举 $x \leq \max a_i$，我们对每个 $x$ 随机重排新序列 $10$ 遍进行贪心选择。这看起来很离谱，但是对于 Subtask 4 中的正解 $x$，容易证明单次错误率不超过 $\frac 1n$。

---

## 作者：Steve_xh (赞：0)

# 题意

[题目传送门](https://www.luogu.com.cn/problem/P9575)

**题目大意：**

给定长度为 $n$ 的序列 $a$，对于每个 $a_i$ 必须将其分去 $B$ 组或 $C$ 组中的一个，再求一个正整数 $x\le 10^9$，使得 $\sum\limits_{a_i\in B}\gcd(x,a_i)=\sum\limits_{a_i\in C}\gcd(x,a_i)$，并给出分组方案或报告无解。

# 思路

这道题被教练当作了 noip 模拟赛题。（~~构造题不是纯折磨人？~~）

一般的构造题都是由特殊点启发正解，于是先去看特殊性质。观察 Subtask 0 不难发现由于可以 $x=1$，所以当 $n$ 为偶数时直接一半一半即可。

此时的分数少得可怜，因此难点都集中在 $n$ 为奇数的时候。继续看特殊性质，发现有 $a_i$ 都为奇数的时候，简单手推数据发现好像一定无解。为什么？简单证明一下：当 $a_i$ 为奇数时，$\gcd(x,a_i)$ 一定为奇数；又因为 $n$ 是奇数，则分成的两个组长度必是一奇一偶，那么无论如何奇数个奇数之和不可能等于偶数个奇数之和（因为前者奇后者偶），这就得证了。

解决完以上两个特殊性质后，细看 Subtask 1 其实很有启发性。于是尝试将 $a_i$ 按奇偶分类，即取 $x=2$，那么 $\gcd(x,a_i)$ 就只有 $1$ 和 $2$ 两种取值了。此时再考虑一遍无解的情况，其实只可能是一边奇一边偶。因为两个 $1$ 可以合成一个 $2$，那么当 $1$ 的数量为奇数时必定会剩余一个单独的 $1$，无解。其余情况只需要将剩余的 $2$ 平均分配到两边即可，注意如果不能均分，则可以拆开其中一个 $2$，把这两个 $1$ 分到两边。

于是兴致勃勃地打完交上去发现只有 $10$ 分。

该做法的 hack：
```
3
2 2 4
```
错误输出：
```
-1
```

继续检查发现，直接按奇偶来分不能完全得到正确答案。但是如果约掉最大公因数呢？

输入：
```
3
1 1 2
```
输出（可能的一种）：
```
2
110
```

此时就可以正确得到答案了。因此得出整个序列最大公因数会干扰答案计算，因此约去即可。但是注意了，由于我们一开始约去了，因此此时的 $x$ 需要乘上序列最大公因数才能得到正确答案。

# 代码

```cpp
#include<bits/stdc++.h>
// #define int long long
using namespace std;
typedef long long ll;
const int MAXN=100005,mod=998244353,inf=0x3f3f3f3f;
int n,a[MAXN];
int subtask0(){
    printf("1\n");
    for(int i=1;i<=(n>>1);i++)
        printf("0");
    for(int i=1;i<=(n>>1);i++)
        printf("1");
    return 0;
}
inline int subtask1(){
    printf("-1");
    return 0;
}
int odd=0,notodd=0,len,gcd=0;
int B=0;
signed main(){
    // freopen("noip_moni/a1.in","r",stdin);
    // freopen("noip_moni/a.ans","w",stdout);
    // cin.tie(nullptr)->sync_with_stdio(false);
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d",a+i);
        if(!gcd)
            gcd=a[i];
        else
            gcd=__gcd(gcd,a[i]);
    }
    for(int i=1;i<=n;i++){
        a[i]/=gcd;
        if(a[i]%2==0)
            ++notodd;
        else
            ++odd;
    }
    if(n%2==0)
        return subtask0();
    if(odd==n)
        return subtask1();
    if(odd&1){
        printf("-1");
        return 0;
    }
    len=((odd>>1)+notodd);
    printf("%d\n",gcd<<1);
    for(int i=1;i<=n;i++){
        if(B<len){
            if(a[i]%2){
                printf("1");
                B+=1;
            }else{
                if(B+1==len)
                    printf("0");
                else{
                    B+=2;
                    printf("1");
                }
            }
        }else{
            printf("0");
        }
    }
    return 0;
}
```

---

## 作者：1234567890sjx (赞：0)

令 $G=\gcd_{i=1}^n a_i$。设 $b_i=\frac{a_i}{G}$。

若有 $2\mid n$ 那么可以让 $x=1$，把前 $\frac{n}{2}$ 个数扔到第一组里，后 $\frac{n}{2}$ 个数扔到第二组里。显然符合构造。

否则，令 $c_0$ 表示 $b$ 中偶数的数量，$c_1$ 表示 $b$ 中奇数的数量。有 $c_1\ge 2$。

若 $2\mid c_0$ 那么无法构造出一组解。

否则，令 $x=2\times G$。随便扔 $\frac{c_1}{2}-1$ 个奇数和 $\lceil \frac{c_0}{2}\rceil$ 个偶数到第一组，剩下的扔到第二组。容易发现这样满足条件。

时间复杂度 $O(n\log n)$，瓶颈在于求 $\gcd$。

---

## 作者：mc123456 (赞：0)

## 分析

~~有一点猜结论。~~

首先对 $n$ 分类讨论。当 $n$ 为偶数时，令 $x = 1$，直接将原序列对半分即可，所以接下来讨论 $n$ 为奇数的情况。

对于原序列，如果存在一个合法的划分，那么令 $g = \gcd\limits_{i = 1}^{n}{a_i}$，将每一个 $a_i$ 都变为 $\dfrac{a_i}{g}$，并将 $x$ 也变为 $\dfrac{x}{g}$，容易证明原划分方式在新的 $a$ 中仍是一个合法划分，并且这是充分必要的，所以我们讨论新的 $a_i$ 如何划分即可。

分析 $a_i$ 中奇数的个数，记为 $cnt$，显然 $cnt > 0$。若 $cnt$ 为奇数，那么不论取什么 $x$，$\gcd(a_i, x)$ 中总会有奇数个奇数和偶数个偶数，它们的和为奇数，必然无法分成两个相等的部分。所以只有 $cnt$ 为偶数的时候可能有解，这时我们只要取 $x = 2$，将 $a$ 中 $\dfrac{cnt}{2} - 1$ 个奇数和 $\dfrac{n - cnt + 1}{2}$ 个偶数分到一组，其余的分到另一组即可。

最后不要忘记将 $x$ 再乘上 $g$。

时间复杂度 $O(n \log{V})$，瓶颈在于求 $\gcd$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
const int N = 1e5 + 10;

int n;
int a[N], cnt[2];

signed main()
{
    cin.tie(0), cout.tie(0), ios::sync_with_stdio(0);
    cin >> n;
    int g = 0;
    for (int i = 1; i <= n; i++)
        cin >> a[i], g = __gcd(g, a[i]);
    for (int i = 1; i <= n; i++)
        a[i] /= g, cnt[a[i] & 1]++;
    if (!(n & 1))
    {
        cout << 1 << endl;
        for (int i = 1; i <= (n >> 1); i++)
            cout << "01";
        cout << endl;
        return 0;
    }
    if (cnt[1] & 1)
    {
        cout << -1 << endl;
        return 0;
    }
    cnt[0] = (cnt[0] >> 1) + 1, cnt[1] = (cnt[1] >> 1) - 1;
    cout << (g << 1) << endl;
    for (int i = 1; i <= n; i++)
        cout << (cnt[a[i] & 1] ? 1 : 0), cnt[a[i] & 1] = max(cnt[a[i] & 1] - 1, 0ll);
}
```

---

## 作者：eastcloud (赞：0)

首先考虑 $n$ 为偶数时只要取 $x=1$ 即可，我们直接考虑其为奇数的情况。

尝试全部输出 $-1$ 可以发现，由于整个数列可以被分为和相等的两部分，因此序列的和也必然要是个偶数，故只要奇数有奇数个，数列的总和就必然为奇数，不可能分为两部分。

对于奇数存在且有偶数个的情况，只要令 $x=2$ 并令偶数分为和恰好相差 $2$ 的两部分，并用奇数填补差距即可。

剩下全为偶数的情况我们还没有处理，我们可以将全部数字除去一个 $2$，递归地执行此过程并将最后的 $x$ 乘上一个 $2$，只要后面判断有解，那么两部分的数全部乘 $2$ 后就等价于总和乘 $2$，仍然有解且原方案仍然成立。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<vector> 
#define ll long long
using namespace std;
int a[100005];
int gcd(int x,int y){
	if(!y) return x;
	else return gcd(y,x%y);
}
int main(){
	int n;cin>>n;
	if(n%2==0){
		for(int i=1;i<=n;i++){int x;cin>>x;}
		cout<<1<<endl;
		for(int i=1;i<=n/2;i++)cout<<"10";
	}
	else{
		for(int i=1;i<=n;i++)cin>>a[i];
		int sum=(1<<20),cnt=0;
		for(int i=1;i<=n;i++)sum=gcd(sum,a[i]);
		for(int i=1;i<=n;i++)a[i]/=sum;
		for(int i=1;i<=n;i++)if(a[i]%2==0)cnt++;
		if(cnt%2==0){cout<<-1;return 0;}
		int jud=0,ct=0,ct2=0;
		cout<<sum*2<<endl;
		for(int i=1;i<=n;i++){
			if(a[i]%2){
				if(ct<2){cout<<1;ct++;}
				else{cout<<jud;jud^=1;}
			}
			else{
				cout<<ct2;ct2^=1;
			}
		}
	}
}
```


---


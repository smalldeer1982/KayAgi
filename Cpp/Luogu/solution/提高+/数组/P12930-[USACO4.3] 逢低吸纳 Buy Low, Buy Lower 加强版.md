# [USACO4.3] 逢低吸纳 Buy Low, Buy Lower 加强版

## 题目背景

[P2687](https://www.luogu.com.cn/problem/P2687) 加强版。在本题中，$N\leq 10^6$，且输出方案数需要对 $10^9+7$ 取模。

## 题目描述

“逢低吸纳”是炒股的一条成功秘诀。如果你想成为一个成功的投资者，就要遵守这条秘诀：“逢低吸纳，越低越买”。

这句话的意思是：每次你购买股票时的股价一定要比你上次购买时的股价低。按照这个规则购买股票的次数越多越好，看看你最多能按这个规则买几次。

给定连续的 $N$ 天中每天的股价。你可以在任何一天购买一次股票，但是购买时的股价一定要比你上次购买时的股价低。写一个程序，求出最多能买几次股票，和最优方案数对 $10^9+7$ 取模的结果。

以下面这个表为例，某几天的股价是：

|天数    |股价    |
|:-------|:-------|
|$1$|$68$|
|$2$|$69$|
|$3$|$54$|
|$4$|$64$|
|$5$|$68$|
|$6$|$64$|
|$7$|$70$|
|$8$|$67$|
|$9$|$78$|
|$10$|$62$|
|$11$|$98$|
|$12$|$87$|


这个例子中，如果每次买股票时的股价都比上一次买时低，那么最多能买 $4$ 次股票。一种买法如下（可能有其他的买法）：


|天数    |股价    |
|:-------|:-------|
|$2$|$69$|
|$5$|$68$|
|$6$|$64$|
|$10$|$62$|

## 说明/提示

$1 \le N \le 10^6$。

## 样例 #1

### 输入

```
12
68 69 54 64 68 64 70 67
78 62 98 87```

### 输出

```
4 2```

# 题解

## 作者：stripe_python (赞：2)

一句话题意：求最长下降子序列长度及**本质不同**的最长下降子序列数目。

首先对序列元素取负数并离散化，这样就变成了最长上升子序列，方便接下来的讨论。

考虑 $O(n^2)$ 的做法，记 $f_i$ 为以 $i$ 结尾的最长上升子序列长度，则

$$
f_i=\max_{1\le j <i, a_j<a_i} f_j+1
$$

再记 $g_i$ 为以 $i$ 结尾的最长上升子序列的方案数。在转移时，若 $f_j+1>f_i$，直接令 $g_i \gets g_j$；否则若恰好 $f_j+1=f_i$，此时累加方案数 $g_i \gets g_i+g_j$。

但是我们要求本质不同的 LIS 数目，比如说 `5 4 3 3` 这组数据，`5 4 3` 和 `5 4 3` 是算一组的，对于多余的那个 `3` 要去重。我们只统计在 $i$ 之前最后一次出现的元素的贡献即可。

接下来考虑 LIS 常用优化，显然二分走不通，考虑树状数组。可以在权值树状数组上的每个点维护一个二元组 $(f_i,g_i)$，按照上述规则更新，对于不是最后一次出现的 $a_i$ 减去重复贡献。这样就优化到了 $O(n \log n)$。

```cpp
const int N = 1e6 + 5;
const int mod = 1e9 + 7;
constexpr int madd(int a, int b) {return a + b >= mod ? a + b - mod : a + b;} 

long long n, a[N], d[N], last[N];

#define lowbit(x) (x & -x)
struct node {
	int len, cnt;
	node() : len(0), cnt(0) {}
	node(long long l, long long c) : len(l), cnt(c) {}
	node& operator+= (const node& x) {
		if (x.len > len) len = x.len, cnt = x.cnt;
		else if (x.len == len) cnt = madd(cnt, x.cnt);
		return *this;
	}
} tr[N], f[N];
void update(int x, const node& c) {
	for (; x < N; x += lowbit(x)) tr[x] += c;
}
node query(int x) {
	node res;
	for (; x > 0; x -= lowbit(x)) res += tr[x];
	return res;
}

void _main() {
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> a[i], d[i] = -a[i];
	sort(d + 1, d + n + 1);
	int m = unique(d + 1, d + n + 1) - d - 1;
	for (int i = 1; i <= n; i++) a[i] = lower_bound(d + 1, d + m + 1, -a[i]) - d;
	for (int i = 1; i <= n; i++) {
		node q = query(a[i] - 1);
		if (q.len == 0) q.cnt = 1;
		q.len++;
		f[i] = q, update(a[i], q);
		if (last[a[i]] && f[last[a[i]]].len == f[i].len) update(a[i], node{q.len, -f[last[a[i]]].cnt});
		last[a[i]] = i;
	}
	node p = query(m);
	cout << p.len << ' ' << p.cnt;
}
```

---

## 作者：chzhh_111 (赞：1)

如果将序列反过来，问题就变成求最长严格递增子序列，以及有多少种本质不同的最长严格递增子序列，则考虑动态规划。

设 $f_{i,0/1}$ 分别表示以第 $i$ 个数为结尾的最长严格递增子序列的长度和以第 $i$ 个数为结尾，且长度为 $f_{i,0}$ 的本质不同最长严格递增子序列数目（下文用 $a_i$ 表示第 $i$ 个数）。

对于 $f_{i,0}$，我们有 $f_{i,0}=\max\limits_{1 \le j < i \land a_j<a_i} f_{j,0}+1$。而对于 $f_{i,1}$，我们就有 $f_{i,1}=\sum\limits_{1 \le j < i \land a_j<a_i \land f_{j,0}+1=f_{i,0}} f_{j,1}$，但这样子会发现答案偏大，因为如果有在 $j \ne k$ 时，$f_{j,0}=f_{k,0}$ 且 $a_j=a_k$ 的情况，我们会将答案重复计算。

怎么解决这个问题呢？容易发现对于以一个相同的数作为结尾，$f_{i,0}$ 具有单调性。现有 $j<k$ 且 $a_j=a_k$，如果 $f_{j,0}=f_{k,0}$，则 $f_{k,1}$ 一定包含了 $f_{j,1}$，而如果 $f_{j,0}<f_{k,0}$，则此时此刻 $f_{j,1}$ 的贡献为 $0$，因为我们要的是本质不同**最长**严格递增子序列的数目。

所以我们考虑删除 $f_{j,1}$ 产生的贡献，然后再加上 $f_{k,1}$ 产生的贡献。根据上文的分析，这样重复的部分就被删去了。

最后答案是 $\sum\limits_{1 \le i \le n \land f_{i,0}=ml} f_{i,1}$，其中 $ml$ 表示最长严格递增子序列的长度。

如果直接暴力去转移的话是 $O(n^2)$ 的，但可以发现以上的步骤均可以用树状数组维护，则时间复杂度优化到 $O(n \log n)$。

代码部分：

暴力：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define ld long double
const int N=5010,mod=1e9+7;
int n,a[N],top[N];ld dp[N][2],ans1,ans2;
struct lsh{
	int x,y;
}s[N];
bool cmp(lsh aa,lsh bb) {return aa.x<bb.x;}
signed main()
{
	scanf("%lld",&n);
	for(int i=1;i<=n;i++) scanf("%lld",&a[i]),s[i]=(lsh){a[i],i};
	sort(s+1,s+1+n,cmp),s[0].x=-1;
	for(int i=1,tot=0;i<=n;i++)
	{
		tot+=(s[i].x!=s[i-1].x);
		a[s[i].y]=tot;
		top[tot]=n+1;
	}
	for(int i=n;i>=1;i--)
	{
		for(int j=i+1;j<=n;j++)
		{
			if(a[i]>a[j]&&dp[i][0]<dp[j][0]+1) dp[i][0]=dp[j][0]+1,dp[i][1]=dp[j][1];
			  else if(a[i]>a[j]&&dp[i][0]==dp[j][0]+1) dp[i][1]+=dp[j][1];
		}
		if(dp[i][0]==0) dp[i][0]=1,dp[i][1]=1;
		if(dp[top[a[i]]][0]==ans1) ans2-=dp[top[a[i]]][1];
		dp[top[a[i]]][1]=0;top[a[i]]=i;
		if(ans1<dp[i][0]) ans1=dp[i][0],ans2=dp[i][1];
		  else if(ans1==dp[i][0]) ans2+=dp[i][1];
	}
	printf("%.0llf %.0llf",ans1,ans2);
	return 0;
}
```

树状数组：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e6+10,mod=1e9+7;
int n,a[N],top[N],last[N],tot;
struct lsh{
	int x,y;
}s[N];//注意离散化 
struct tree{
	int maxi,sum;
}tr[N],dp[N];
bool cmp(lsh aa,lsh bb) {return aa.x<bb.x;}
int lowbit(int x) {return x&(-x);}
void update(int x,int y,int z)
{
	for(;x<=tot;x+=lowbit(x))
	  if(tr[x].maxi<y) tr[x]=(tree){y,z};
	    else if(tr[x].maxi==y) tr[x].sum=(tr[x].sum+z+mod)%mod;
}
tree query(int x)
{
	tree ans=(tree){0,0};
	for(;x;x-=lowbit(x))
	  if(tr[x].maxi>ans.maxi) ans=tr[x];
	    else if(tr[x].maxi==ans.maxi) ans.sum=(ans.sum+tr[x].sum)%mod;
	return ans;
}
signed main()
{
	scanf("%lld",&n);
	for(int i=1;i<=n;i++) scanf("%lld",&a[i]),s[i]=(lsh){a[i],i};
	sort(s+1,s+1+n,cmp),s[0].x=-1;
	for(int i=1;i<=n;i++)
	{
		tot+=(s[i].x!=s[i-1].x);
		a[s[i].y]=tot;
		top[tot]=n+1; 
	}
	for(int i=n;i>=1;i--)
	{
		last[i]=top[a[i]];
		top[a[i]]=i;
	}
	for(int i=n;i>=1;i--)
	{
		dp[i]=query(a[i]-1);
		dp[i].maxi++,dp[i].sum=max(1ll,dp[i].sum);//特判 a[i] 第一次出现的时候
		update(a[i],dp[last[i]].maxi,-dp[last[i]].sum);//删除贡献 
		update(a[i],dp[i].maxi,dp[i].sum);//添加贡献 
	}
	tree ans=query(tot);
	printf("%lld %lld",ans.maxi,ans.sum);
	return 0;
}
```

---

## 作者：liuchuliang666 (赞：1)

貌似求 LIS 个数的题目很多啊……还是讲一下吧。

这题把 $a$ 反转一下就是求 LIS 的了，先看看如何 $O(n \log n)$ 求 LIS 的长度，常规的方法有两种：

- 二分；
- 树状数组（线段树）。

本题需要使用第二种方法，第一种方法无法顺带维护方案数（~~正好第一种我不会~~）。

先来一手离散化，考虑设 $f_i$ 为以 $a_i$ 结尾的 LIS 长度，那么我们有朴素的 DP 方程：

$$f_i = \max_{j < i \land a_j < a_i}{f_j + 1}$$

由于是顺着遍历的，那么 $j < i$ 便自然成立，那么我们可以考虑维护一个数据结构，每次求完 $f_i$ 后在下标为 $a_i$ 的地方插入一个 $f_i$，那么下标在 $[1, a_i - 1]$ 内的决策点都是符合的，求最大值就可以快速得到最大的 $f_i$ 的值。

支持单点改、查前缀最大值的数据结构可以选用树状数组或线段树，这里使用了好写、常数小的树状数组。

回到本题，要求统计 LIS 的个数，我们设 $g_i$ 为以 $a_i$ 结尾的 LIS 的个数，那么有转移方程：

$$g_i = \sum_{j < i \land f_i = f_j - 1} g_j$$

特别的，当 $f_i = 1$ 时，由于 LIS 只有 $a_i$ 自己，因此 $g_i = 1$。

这个很容易利用树状数组一并维护，具体的，考虑在位置为 $i$ 的地方维护二元组 $(val_i, cnt_i)$，表示以值 $i$ 结尾的 LIS 的最长长度和对应数量，那么合并位置为 $i$ 和 $j$ 的二元组时，取较大的 $val$ 以及对应的 $cnt$，若 $val_i = val_j$，那么两个 $cnt$ 加起来即可。

当你自信满满，写完一发交上去的时候，发现自己 WA 了最后两个点，猛然回头一看，本题要求求 **本质不同** 的 LIS 的数量！

那么我们可以发现，记上一次 $a_i$ 出现的地方为 $lst$，那么如果 $f_i = f_{lst}$，就意味着他俩对应的 LIS 本质相同，这时不应该去更新！

那么这样就能过了，时间复杂度 $O(n \log n)$。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int ll
typedef long long ll;
typedef const int cint;
typedef vector<int> vi;
constexpr int MAXN = 2e6 + 10, mod = 1e9 + 7, inf = 1e18;
template <typename T> inline void chkmx(T &a, const T b) { a = a < b ? b : a; }
template <typename T> inline void chkmn(T &a, const T b) { a = a > b ? b : a; }
template <typename T> inline void add(T &a, const T b) { a = ((a + b) % mod + mod) % mod; }
template <typename T> inline void mul(T &a, const T b) { a = ((a * b) % mod + mod) % mod; }
int n, f[MAXN], g[MAXN], a[MAXN], b[MAXN], len, lst[MAXN];
struct node
{
    int val, cnt; // val: 最大长度, cnt: 对应方案数
    node(cint val = -inf, cint cnt = 0) : val(val), cnt(cnt) {}
} tr[MAXN];
typedef const node cnode;
inline node operator+(cnode &a, cnode &b)
{
    node c(max(a.val, b.val), 0);
    if (a.val == c.val) add(c.cnt, a.cnt);
    if (b.val == c.val) add(c.cnt, b.cnt);
    return c;
}
inline void operator+=(node &a, cnode &b) { a = a + b; }
inline int lowbit(cint x) { return x & (-x); }
inline void update(int x, cnode &v)
{
    for (; x <= len; x += lowbit(x)) tr[x] += v;
}
inline node query(int x)
{
    node res;
    for (; x; x -= lowbit(x)) res += tr[x];
    return res;
}
signed main()
{
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    cin >> n;
    // 离散化
    for (int i = 1; i <= n; i++) cin >> a[i], b[++len] = a[i];
    sort(b + 1, b + 1 + len), len = unique(b + 1, b + 1 + len) - b - 1;
    for (int i = 1; i <= n; i++) a[i] = lower_bound(b + 1, b + 1 + len, a[i]) - b;
    reverse(a + 1, a + 1 + n);
    for (int i = 1; i <= n; i++)
    {
        auto [val, cnt] = query(a[i] - 1) + node(0, 1); // 如果当前是最小的，那么认为前面长度为 0，方案数为 1。
        f[i] = val + 1, add(g[i], cnt);
        // 如果上一次以这个数字结尾的 LIS 长度与这一次不同，说明他们必然不同，反之则必然相同！
        if (!lst[a[i]] || f[lst[a[i]]] != f[i]) update(a[i], node(f[i], g[i]));
        lst[a[i]] = i;
    }
    auto [ansf, ansg] = query(len);
    cout << ansf << " " << ansg;
    return 0;
}
```

---

## 作者：ZhenAn9052 (赞：0)

将 $a_i$ 改为 $-a_i$ 可将题目转化为 LIS 问题。

设 $f_i$ 表示以 $a_i$ 结尾的 LIS 长度， $g_i$ 表示以 $a_i$ 结尾的 LIS 方案数。

则有 $f_i=\max_{1\leq j<i,a_j\leq a_i} \{f_j+1\}$，转移时，若 $f_j+1>f_i$，直接赋值 $g_i\gets g_j$；若 $f_j+1=f_i$，则累加方案数 $g_i \gets g_i+g_j$。

$n \in [1,10^6]$，离散化并使用树状数组优化即可。

题目中说两个方案不相同当且仅当这两个方案中所购买的股票的价格序列不相同，考虑如何去重。设上一次 $a_i$ 出现的位置为 $lst$，若 $f_i=f_{lst}$，对 $lst$ 的每个方案用 $a_i$ 替换为 $a_{lst}$ 后所得的 $g_{lst}$ 个方案是重复的，累加到树状数组中时减掉即可。

```c++
#include <cstdio>
#include <utility>
#include <functional>
#include <algorithm>
using namespace std;
const int N=1000000,MOD=1e9+7;
unsigned a[N+5],val[N+5];
int n,m,mx[N+5],c[N+5];
int lowbit(int x){return x&-x;}
int f[N+5],g[N+5],lst[N+5];
void add(int i,int x,int y){
	while(i<=m){
		if(x>mx[i])c[i]=0;
		if(x>=mx[i]){
			mx[i]=x;
			c[i]=(c[i]+y)%MOD;
			if(c[i]<0)c[i]+=MOD;
		}
		i+=lowbit(i);
	}
}
pair<int,int>sum(int i){
	pair<int,int>res={0,1};
	while(i){
		if(res.first<mx[i])res.second=0;
		if(res.first<=mx[i]){
			res.first=mx[i];
			res.second=(res.second+c[i])%MOD;
		}
		i^=lowbit(i);
	}
	return res;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i)scanf("%u",&a[i]),val[i]=a[i];
	sort(val+1,val+n+1);m=unique(val+1,val+n+1)-val-1;
	reverse(val+1,val+m+1);
	for(int i=1;i<=n;++i)a[i]=lower_bound(val+1,val+m+1,a[i],greater<unsigned>())-val;
	for(int i=1;i<=n;++i){
		auto p=sum(a[i]-1);
		f[i]=p.first+1;g[i]=p.second;
		add(a[i],f[i],g[i]);
		if(lst[a[i]]&&f[lst[a[i]]]==f[i])add(a[i],f[i],-g[lst[a[i]]]);
		lst[a[i]]=i;
	}
	auto p=sum(m);
	printf("%d %d\n",p.first,p.second);
	return 0;
}

```

---


# [OOI 2022] Third grader's task

## 题目描述

小男孩 Tyler 在厨房的冰箱上看到了一些带有符号的磁铁，这些磁铁可以拼成一个字符串 $s$。

Tyler 很喜欢字符串，尤其喜欢那些字典序小于字符串 $t$ 的字符串。玩着冰箱上的磁铁，他开始好奇：用 $s$ 的字母重新排列，可以组成多少个不同的字符串，使得这些字符串的字典序小于 $t$？Tyler 还只读三年级，他无法回答这个问题。请你帮他计算，用 $s$ 的字母重新排列，字典序小于 $t$ 的排列有多少种。

我们称字符串 $x$ 的字典序小于字符串 $y$，当且仅当满足以下两种情况之一：

- 存在某个位置 $m$，在此之前两个字符串完全相同，而第 $m$ 位 $s$ 的字符小于第 $m$ 位 $y$ 的字符；
- 字符串 $x$ 是字符串 $y$ 的前缀。

由于答案可能很大，请输出对 $998\,244\,353$ 取模的结果。

## 说明/提示

### 说明

在第一个样例中，应统计 $[1\ 2\ 2]$ 和 $[2\ 1\ 2]$ 这两个字符串。$[2\ 2\ 1]$ 的字典序大于 $[2\ 1\ 2\ 1]$，所以不计入答案。

在第二个样例中，应统计所有排列，除了 $[4\ 3\ 2\ 1]$，所以答案是 $4! - 1 = 23$。

在第三个样例中，只能统计 $[1\ 1\ 1\ 2]$ 这一种。

### 评分说明

本题测试数据分为 6 组。只有通过某组所有测试点，且通过所有必需的前置组，才能获得该组分数。**离线评测**表示该组的结果在比赛结束后才能看到。注意，有些分组不要求通过样例测试点。

| 组别 | 分值 | $n, m$ | $s_i, t_i$ | 必须通过的组 | 备注 |
|:----:|:----:|:------:|:----------:|:------------:|:----:|
| 0    | 0    | --       | --     | --         | --           | 样例测试点 |
| 1    | 16   | $n, m \le 10$ | $s_i, t_i \le 10$ | 0 |      |
| 2    | 15   | --       | $s_i, t_i \le 2$ | --           |      |
| 3    | 11   | --       | $s_i, t_i \le 20$ | 0--2         |      |
| 4    | 13   | --       | $s_i, t_i \le 200$ | 0--3         |      |
| 5    | 12   | --       | --         | --           | 每个字符串内部所有字符均不同 |
| 6    | 33   | --       | --         | 0--5         | **离线评测** |

## 样例 #1

### 输入

```
3 4
1 2 2
2 1 2 1```

### 输出

```
2```

## 样例 #2

### 输入

```
4 4
1 2 3 4
4 3 2 1```

### 输出

```
23```

## 样例 #3

### 输入

```
4 3
1 1 1 2
1 1 2```

### 输出

```
1```

# 题解

## 作者：chen_zhe (赞：0)

**这是官方题解的中文 AI 翻译**

设 $K$ 为字母表的大小，即出现的最大字母编号。

首先，计算在有 $c_1$ 个 $1$ 型字母、$c_2$ 个 $2$ 型字母、$\ldots$、$c_K$ 个 $K$ 型字母的情况下，能组成多少个不同的字符串。经典排列组合公式为：

$$
P(c_1, c_2, \ldots, c_K) = \frac{(c_1 + c_2 + \ldots + c_K)!}{c_1! \cdot c_2! \cdot \ldots \cdot c_K!}
$$

为了快速计算不同 $c_1, c_2, \ldots, c_K$ 的值，可以预处理所有阶乘及其逆元，模数 $C = 998244353$，复杂度为 $O(n \log C)$。

若要让字符串 $x$ 字典序小于字符串 $t$，需要两者有一个相同的前缀。枚举这个公共前缀的长度，从 $0$ 到 $\min(n, m)$。若 $x$ 和 $t$ 的前 $i$ 个字符都相同，则我们已知每种字母还剩多少个，可用一个 $cnt$ 数组记录，其中第 $i$ 位表示剩余第 $i$ 型字母数量。

枚举下一个字符。为了让结果字符串小于 $t$，下一个字符需严格小于 $t$ 在该位置的字母，而剩下的字母可以任意排列。用上面的排列公式计算方案数。

唯一需要单独处理的情况是 $x$ 是 $t$ 的前缀且长度更短，这种情况没被统计到。需要单独判断能否构造出这样的 $x$，若可以则答案加 $1$。

每一步最多有 $\min(n, m)$ 层循环，每层最多枚举 $K$ 种字母，每次复杂度 $O(K)$，总复杂度 $O(\min(n, m) K^2 + n \log C)$。

为了优化上述算法，我们引入 $add$ 数组，其中 $add_i$ 表示若当前位置放第 $i$ 型字母，剩余字母的排列方案数。实际上：

$$
add_i = \frac{(cnt_1 + cnt_2 + \ldots + cnt_K - 1)!}{cnt_1! \cdot \ldots \cdot (cnt_i - 1)! \cdot \ldots \cdot cnt_K!}
$$

如果能维护这个数组，每步只需对某个前缀求和即可。考虑 $t$ 的当前字符为 $i$，即 $cnt_i$ 需减 $1$，则对于所有 $j \neq i$，$add_j$ 需乘以 $\frac{cnt_i}{cnt_1 + \ldots + cnt_K - 1}$。可以通过一个全局乘法因子 $modify$ 实现批量更新。

对于 $add_i$，还需再乘以 $\frac{cnt_i - 1}{cnt_1 + \ldots + cnt_K - 1}$，考虑到全局乘法，实际上只需再乘 $\frac{cnt_i - 1}{cnt_i}$。

通过这种优化，每步只需 $O(K)$ 计算前缀和，$O(\log C)$ 计算乘法因子，总复杂度 $O(\min(n, m) \cdot (K + \log C))$。

进一步消除 $K$，注意 $add$ 数组只需支持前缀和和单点修改，可以用树状数组或线段树优化到 $O(\log K)$，最终复杂度 $O(\min(n, m) (\log K + \log C))$。

事实上，$\log C$ 也可通过预处理 $1$ 到 $n$ 的逆元消除，无需 $O(n \log C)$ 的时间，但本题未作要求。

---


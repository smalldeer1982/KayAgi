# 「CZOI-R5」折跃点

## 题目背景

宇宙中爆发了星际战争。

## 题目描述

为了在星际战争中进行瞬间移动，我方已经在占领的星域中建立了 $n$ 个折跃点。所有折跃点构成一棵以折跃点 $1$ 为根的有根树。第 $i$ 个折跃点的能量值为 $a_i$。

我们称折跃点 $u$ 经过 $x$ 次连续折跃能到达折跃点 $v$，当且仅当从折跃点 $u$ 出发，走过 $x$ 条边后能到达折跃点 $v$，且过程中与折跃点 $1$ 的距离不断增加或不断减少。

现在要进行 $m$ 次以下维护操作：
1. **空间能量增强**：对于所有从折跃点 $u$ 经过 $x$ 次连续折跃能到达的折跃点，将其能量值加 $y$。
2. **折跃测试**：求所有从折跃点 $u$ 经过 $x$ 次连续折跃能到达的折跃点，能量值的和。

## 说明/提示

**【样例解释】**

![](https://cdn.luogu.com.cn/upload/image_hosting/3lcng3xo.png)

这棵树如图。

第一次操作满足条件的折跃点为折跃点 $3,5$，操作后 $a=\{6,8,11,10,13\}$。

第二次操作满足条件的折跃点为折跃点 $1,5$，答案为 $6+13=19$。

第三次操作满足条件的折跃点为折跃点 $2$，答案为 $8$。

第四次操作满足条件的折跃点为折跃点 $1,3$，操作后 $a=\{10,8,15,10,13\}$。

第五次操作满足条件的折跃点为折跃点 $3,5$，答案为 $15+13=28$。

**【数据范围】**

**本题采用捆绑测试**。

- Subtask #1（$15\text{ pts}$）：$n, m \le 10^3$。
- Subtask #2（$15\text{ pts}$）：$x \le 1$。
- Subtask #3（$25\text{ pts}$）：$x \le 50$。
- Subtask #4（$45\text{ pts}$）：无特殊限制。

对于 $100\%$ 的数据，$1\le u\le n\le3\times10^5$，$1 \le  m \le 3 \times 10^5$，$1 \le a_i, y \le 10^9$，$0 \le x \le n$，$p\in\{1,2\}$。


## 样例 #1

### 输入

```
5 5
6 8 4 10 6 
2 1
3 2
4 1
5 4
1 1 2 7
2 4 1
2 2 0
1 2 1 4
2 1 2
```

### 输出

```
19
8
28
```

# 题解

## 作者：_H17_ (赞：8)

## 前言

我怎么场切蓝了？板子题，但是不是很好调。

## 题目分析

不难发现连续 $x$ 次折跃可以到的点有：这个点的 $x$ 级祖先、在 $x$ 子树内深度是 $\operatorname{dep}(u)+x$ 的点（如果存在的话）。需要特殊注意 $0$ 的情况，这里是我第一次提交没切掉的原因。

注意到深度一样这个特性，我们考虑使用一种树上不常用的顺序存储点：BFS 序。当然，由于我们需要保证都在一个子树也是连续的，我们需要保证深度相同的点的顺序由 DFS 序来决定。

然后用线段树维护即可。

时间复杂度 $O(n+q\log n)$。

警示一下后人：犯过两次的错误，对于结构体数组内某个元素的赋值比如 `f[cur].val=a[l]`，有时候不小心写成了 `f[cur]=a[l]` 可能连 warning 都没有，大家注意。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
constexpr int N=3e5+1;
int n,q,a[N],dep[N],dfn[N],lstdfn[N],dtot,pos[N],rt,tot,g[N][20],maxd,pla[N];
vector<int>e[N];
pair<int,int>seg[N];
void add(int u,int v){
    e[u].push_back(v);
    return;
}
void dfs(int u,int fa){
    dep[u]=dep[fa]+1,dfn[u]=lstdfn[u]=(++dtot),g[u][0]=fa;
    maxd=max(maxd,dep[u]);
    for(auto v:e[u]){
        if(v==fa)
            continue;
        dfs(v,u);
        lstdfn[u]=max(lstdfn[u],lstdfn[v]);//要统计结束的位置
    }
    return;
}
bool cmp(int x,int y){
    return(dep[x]!=dep[y])?(dep[x]<dep[y]):(dfn[x]<dfn[y]);
}
struct SegmentTreeNode{
    int l,r,ls,rs,val,tag;
    SegmentTreeNode(int l=0,int r=0):l(l),r(r),ls(0),rs(0),val(0),tag(0){}
}f[N<<1];
void pushup(int cur){
    f[cur].val=f[f[cur].ls].val+f[f[cur].rs].val;
    return;
}
void pushdown(int cur){
    if(f[cur].tag){
        f[f[cur].ls].val+=f[cur].tag*(f[f[cur].ls].r-f[f[cur].ls].l+1),
        f[f[cur].rs].val+=f[cur].tag*(f[f[cur].rs].r-f[f[cur].rs].l+1),
        f[f[cur].ls].tag+=f[cur].tag,f[f[cur].rs].tag+=f[cur].tag;
        f[cur].tag=0;
    }
    return;
}
void build(int l,int r,int&cur){
    f[cur=(++tot)]=SegmentTreeNode(l,r);
    if(l==r){
        f[cur].val=a[pos[l]];
        return;
    }
    int mid=(l+r)>>1;
    build(l,mid,f[cur].ls),build(mid+1,r,f[cur].rs);
    return pushup(cur);
}
void modify(int l,int r,int val,int cur){
    if(l<=f[cur].l&&f[cur].r<=r){
        f[cur].val+=(f[cur].r-f[cur].l+1)*val,f[cur].tag+=val;
        return;
    }
    pushdown(cur);
    int mid=(f[cur].l+f[cur].r)>>1;
    if(l<=mid)
        modify(l,r,val,f[cur].ls);
    if(mid<r)
        modify(l,r,val,f[cur].rs);
    return pushup(cur);
}
int query(int l,int r,int cur){
    if(l<=f[cur].l&&f[cur].r<=r)
        return f[cur].val;
    pushdown(cur);
    int mid=(f[cur].l+f[cur].r)>>1,ret=0;
    if(l<=mid)
        ret+=query(l,r,f[cur].ls);
    if(mid<r)
        ret+=query(l,r,f[cur].rs);
    return ret;
}
int get_fa(int u,int val){//祖先倍增即可
    for(int i=19;~i;i--)
        if(val>=(1<<i))
            u=g[u][i],val-=(1<<i);
    return u;
}
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(nullptr),cout.tie(nullptr);
    cin>>n>>q;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        pos[i]=i;
        seg[i]={0x3f3f3f3f,-0x3f3f3f3f};
    }
    for(int i=1,u,v;i<n;i++){
        cin>>u>>v;
        add(u,v),add(v,u);
    }
    dfs(1,0);
    sort(pos+1,pos+n+1,cmp);//这个 pos 可以理解为 BFN
    for(int i=1;i<=n;i++){
        seg[dep[pos[i]]].first=min(seg[dep[pos[i]]].first,i);
        seg[dep[pos[i]]].second=max(seg[dep[pos[i]]].second,i);
        pla[pos[i]]=i;
    }
    for(int j=1;j<20;j++)
        for(int i=1;i<=n;i++)
            g[i][j]=g[g[i][j-1]][j-1];
    build(1,n,rt);
    for(int o,p,t,val;q;--q){
        cin>>o>>p>>t;
        int fath=get_fa(p,t),l=1,r=n,lptr,rptr;
        if(dep[p]+t>maxd)
            l=r=-1;
        else{
            l=seg[dep[p]+t].first,r=seg[dep[p]+t].second+1;
            while(l<r){
                int mid=(l+r)>>1;
                if(dfn[pos[mid]]>=dfn[p])
                    r=mid;
                else
                    l=mid+1;
            }
            lptr=r;
            l=seg[dep[p]+t].first-1,r=seg[dep[p]+t].second;
            while(l<r){
                int mid=(l+r+1)>>1;
                if(dfn[pos[mid]]<=lstdfn[p])
                    l=mid;
                else
                    r=mid-1;
            }
            rptr=l;
            l=lptr,r=rptr;
            if(l<=r&&dfn[p]<=dfn[pos[l]]&&dfn[pos[r]]<=lstdfn[p]);
            else l=r=-1;
        }
        if(t==0)
        	l=r=-1;
//        cerr<<fath<<' '<<l<<' '<<r<<'\n'; 
        if(o==1){
            cin>>val;
            if(fath)
                modify(pla[fath],pla[fath],val,rt);
            if(l!=-1&&r!=-1)
                modify(l,r,val,rt);
        }
        else{
            val=0;
            if(fath)
            	val+=query(pla[fath],pla[fath],rt);
            if(l!=-1&&r!=-1)
            	val+=query(l,r,rt);
            cout<<val<<'\n';
        }
    }
    return 0;
}
```

---

## 作者：Water__Problem (赞：7)

## 废话

也是有幸成为这场比赛第三个 AKer。我觉得这题比前三题好做很多，包括思路和代码（可能我比较弱）。

## 题解

发现每次修改或者查询访问的点是一个祖先节点和一坨儿子节点，且儿子节点都在一层上。

对于祖先节点，跟树上 lca 一样预处理一下。

对于儿子节点，这些操作都是要么加一坨或者减一坨。这就会想到可能会使用线段树 ~~其实不好想~~ 。

现在来想如何在线段树上处理这些东西。应该是有两种做法，一种是根据 BFS 序，一种是根据 DFS 序。听说用 BFS 序很好写，但我比较弱，用了 DFS 序。

我们想到 DFS 序有个性质：这个节点的儿子节点的 DFS 序一定在一段区间内。

于是，我们给树的每一层建一棵动态开点线段树。每一层只加入这一层的节点。这样每次修改或查询儿子就直接在那些儿子所在的线段树上去修改或查询。而查询的区间是 $u$ 所有儿子的 DFS 序的范围。

但为啥是对的呢，我们发现层线段树上只有这一层的节点，而我们只在这里用了 $u$ 的儿子节点的 DFS 序区间，所以不会影响到这层上的其他节点。

还有，儿子搞完了，还有祖先的那个节点。这的简单了，用前面预处理的东西先把它找出来。再在那层的线段树上单点修改，单点查就行。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
void init();void solve();
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	int T=1;init();
//	cin>>T;
	while(T--) solve();
	return 0;
}
void init(){
}
int n,m,rt[300005],a[300005],fa[300005][20],dfn[300005],cnt[300005],dep[300005],tot,res;
vector<int> q[300005];
struct node{
	int ls,rs,cnt;
	int tr,tag;
}t[300005<<5];
void add(int &id,int l,int r,int x,int y){
	if(!id) id=++res;
	t[id].cnt++;
	if(l==r){
		t[id].tr=y;
		return;
	}
	int mid=(l+r)>>1;
	if(x<=mid) add(t[id].ls,l,mid,x,y);
	else add(t[id].rs,mid+1,r,x,y);
	t[id].tr=t[t[id].ls].tr+t[t[id].rs].tr;
}
void push_down(int id){
	if(t[id].ls){
		t[t[id].ls].tr+=t[id].tag*t[t[id].ls].cnt;
		t[t[id].ls].tag+=t[id].tag;
	}
	if(t[id].rs){
		t[t[id].rs].tr+=t[id].tag*t[t[id].rs].cnt;
		t[t[id].rs].tag+=t[id].tag;
	}
	t[id].tag=0;
}
void add(int id,int l,int r,int x,int y,int z){
	if(!id) return;
	if(x<=l&&r<=y){
		t[id].tr+=z*t[id].cnt;
		t[id].tag+=z;
		return;
	}
	push_down(id);
	int mid=(l+r)>>1;
	if(x<=mid) add(t[id].ls,l,mid,x,y,z);
	if(mid<y) add(t[id].rs,mid+1,r,x,y,z);
	t[id].tr=t[t[id].ls].tr+t[t[id].rs].tr;
}
void dfs(int u,int f){
	fa[u][0]=f;
	for(int i=1;i<19;i++) fa[u][i]=fa[fa[u][i-1]][i-1];
	dfn[u]=++tot;
	cnt[u]=1;
	dep[u]=dep[f]+1;
	add(rt[dep[u]],1,n,dfn[u],a[u]);
	for(int v:q[u]){
		if(v==f) continue;
		dfs(v,u);
		cnt[u]+=cnt[v];
	}
}
int query(int id,int l,int r,int x,int y){
	if(!id) return 0;
	if(x<=l&&r<=y) return t[id].tr;
	push_down(id);
	int mid=(l+r)>>1;
	if(y<=mid) return query(t[id].ls,l,mid,x,y);
	else if(mid<x) return query(t[id].rs,mid+1,r,x,y);
	else return query(t[id].ls,l,mid,x,y)+query(t[id].rs,mid+1,r,x,y);
}
int find(int u,int y){
	for(int i=19;i>=0;i--)
		if(y-(1<<i)>=0) u=fa[u][i],y-=(1<<i);
	return u;
}
void solve(){
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1,u,v;i<n;i++){
		cin>>u>>v;
		q[u].push_back(v);
		q[v].push_back(u);
	}
	dfs(1,0);//预处理 
	for(int i=1,opt,u,x,y;i<=m;i++){
		cin>>opt>>u>>x;
		if(opt==1){
			cin>>y;
			int t=dep[u];
			if(t+x<=n) add(rt[t+x],1,n,dfn[u],dfn[u]+cnt[u]-1,y);
			if(t-x>0&&x!=0){//小心x=0，并要防止越界 
				int f=find(u,x);
				add(rt[t-x],1,n,dfn[f],dfn[f],y);
			}
		}
		else{
			int t=dep[u],ans=0;
			if(t+x<=n) ans+=query(rt[t+x],1,n,dfn[u],dfn[u]+cnt[u]-1);
			if(t-x>0&&x!=0){
				int f=find(u,x);
				ans+=query(rt[t-x],1,n,dfn[f],dfn[f]);
			}
			cout<<ans<<endl;
		}
	}
}
```

---

## 作者：lilong (赞：5)

我的做法是按照**深度从小到大，同一深度按照 dfs 序从小到大**的规则将所有点排成一列并重新编号。这样做可以使同一棵子树内深度相同的点的编号是连续的，根据 dfs 序的连续性二分出左右临界的编号，然后直接在线段树上修改查询即可。注意特判 $x=0$ 的情况，避免重复更新。时间复杂度 $O((n+m)\log n)$。

```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<algorithm>
#define int long long
#define N 300010
using namespace std;
vector<int>G[N],H[N];
int n,m,a[N],dep[N],siz[N],fa[N][20],node;
int tot,dfn[N],revdfn[N],id[N],rev[N];
struct T{
    int v,lzy;
}t[N*4];
void pushup(int u){
    t[u].v=t[u<<1].v+t[u<<1|1].v;
    return;
}
void pushdown(int u,int l,int r){
    if(t[u].lzy){
        int mid=(l+r)>>1;
        t[u<<1].v+=t[u].lzy*(mid-l+1);
        t[u<<1].lzy+=t[u].lzy;
        t[u<<1|1].v+=t[u].lzy*(r-mid);
        t[u<<1|1].lzy+=t[u].lzy;
        t[u].lzy=0;
    }
    return;
}
void build(int u,int l,int r){
    if(l==r){
        t[u].v=a[rev[l]];
        return;
    }
    int mid=(l+r)>>1;
    build(u<<1,l,mid);
    build(u<<1|1,mid+1,r);
    pushup(u);
    return;
}
void update(int u,int l,int r,int L,int R,int v){
    if(L<=l&&r<=R){
        t[u].v+=(r-l+1)*v;
        t[u].lzy+=v;
        return;
    }
    pushdown(u,l,r);
    int mid=(l+r)>>1;
    if(L<=mid)update(u<<1,l,mid,L,R,v);
    if(R>mid)update(u<<1|1,mid+1,r,L,R,v);
    pushup(u);
    return;
}
int query(int u,int l,int r,int L,int R){
    if(L<=l&&r<=R)return t[u].v;
    pushdown(u,l,r);
    int mid=(l+r)>>1,sum=0;
    if(L<=mid)sum+=query(u<<1,l,mid,L,R);
    if(R>mid)sum+=query(u<<1|1,mid+1,r,L,R);
    return sum;
}
void dfs(int u,int ff){
    siz[u]=1;
    dfn[u]=++tot;
    revdfn[tot]=u;
    dep[u]=dep[ff]+1;
    H[dep[u]].push_back(dfn[u]);
    fa[u][0]=ff;
    for(int i=1;i<=19;i++)
        fa[u][i]=fa[fa[u][i-1]][i-1];
    for(auto v:G[u]){
        if(v==ff)continue;
        dfs(v,u);
        siz[u]+=siz[v];
    }
    return;
}
int jump(int u,int v){
    for(int i=19;i>=0;i--)
        if((1<<i)&v)
            u=fa[u][i];
    return u;
}
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    int op,u,v,k;
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        cin>>a[i];
    for(int i=1;i<n;i++){
        cin>>u>>v;
        G[u].push_back(v);
        G[v].push_back(u);
    }
    dfs(1,0);
    for(int i=1;i<=n;i++){
        sort(H[i].begin(),H[i].end());
        for(auto j:H[i]){
            node++;
            id[revdfn[j]]=node;
            rev[node]=revdfn[j];
        }
        H[i].push_back(n+1);
    }
    build(1,1,n);
    int lc,ans;
    while(m--){
        cin>>op;
        if(op==1){
            cin>>u>>v>>k;
            if(v==0){
                update(1,1,n,id[u],id[u],k);
                continue;
            }
            lc=jump(u,v);
            if(lc){
                update(1,1,n,id[lc],id[lc],k);
            }
            if(dep[u]+v<=n){
                auto it1=lower_bound(H[dep[u]+v].begin(),H[dep[u]+v].end(),dfn[u]);
                auto it2=upper_bound(H[dep[u]+v].begin(),H[dep[u]+v].end(),dfn[u]+siz[u]-1);
                if(*it1<=n){
                    it2--;
                    int L=revdfn[*it1],R=revdfn[*it2];
                    update(1,1,n,id[L],id[R],k);
                }
            }
        }
        if(op==2){
            cin>>u>>v;
            ans=0;
            lc=jump(u,v);
            if(lc){
                ans+=query(1,1,n,id[lc],id[lc]);
            }
            if(dep[u]+v<=n){
                auto it1=lower_bound(H[dep[u]+v].begin(),H[dep[u]+v].end(),dfn[u]);
                auto it2=upper_bound(H[dep[u]+v].begin(),H[dep[u]+v].end(),dfn[u]+siz[u]-1);
                if(*it1<=n){
                    it2--;
                    int L=revdfn[*it1],R=revdfn[*it2];
                    ans+=query(1,1,n,id[L],id[R]);
                }
            }
            if(v==0)cout<<query(1,1,n,id[u],id[u])<<'\n';
            else cout<<ans<<'\n';
        }
    }
    return 0;
}
```

---

## 作者：Vector_net (赞：3)

## 动态开点线段树

讲一个不用动脑子的做法。

在此之前，我们先约定 $d_x$ 表示点 $x$ 的深度。

我们来形式化一下操作，注意到题目中有一句“且过程中与折跃点 1 的距离不断增加或不断减少”。这句话意味着修改时被修改的点只会时子树内深度为 $d_u+x$ 的所有点以及 $u$ 的树上 $x$ 级祖先，查询同理。

那么我们发现，查询和修改时所涉及到的点的深度只有两种，我们考虑对每一个深度建立一颗线段树，那么修改时可以转化为对于 $x$ 级祖先的单点修改以及对于深度为 $d_u+x$ 的所有子树内的点的区间加，我们可以再维护一个 $num_k$ 表示 线段树上 $k$ 节点对应的区间内有多少个需要修改（即深度为 $d_u+x$）的点，那么懒标记的维护是简单的，显然查询同理。

注意到这样空间复杂度为 $O(n^2)$，需使用动态开点线段树优化至 $O(n\log n)$，当然时间复杂度很显然为 $O(n\log n)$，可能需要一定程度的常数优化。

## code
```cpp
/*
总体思路：本质上操作是给该点的 x 级祖先 +y，该点子树内深度为 dep[u]+x 的点 +y，求和同理
考虑对每一个深度开一颗线段树，那么就是求第 dep[u]+x 颗线段树内的区间和，当然还有一个单点，修改同理
空间开不下，使用动态开点优化即可。
*/
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int maxn=3e5+5;
int n,q,cnt,tot,mx,rt[maxn],a[maxn],dep[maxn],fa[maxn],siz[maxn],son[maxn],top[maxn],seg[maxn],rev[maxn];
vector<int> G[maxn];//树剖需要的一些数组以及邻接表
struct WAWAOVOLOVEYSC{//线段树结构体
	int lc,rc,num,sum,tag;
}tree[maxn*20];//动态开点线段树一次增加 log 个节点，空间复杂度 O(nlogn)
inline int read(){
	int ret=0,f=1;
	char c=getchar();
	while(!isdigit(c)){if(c=='-')f=-f;c=getchar();}
	while(isdigit(c)){ret=ret*10+c-'0';c=getchar();}
	return ret*f;
}

inline void dfs1(int x,int fath){
	dep[x]=dep[fa[x]=fath]+1,siz[x]=1;
	for(auto to:G[x]){
		if(to==fath)continue;
		dfs1(to,x),siz[x]+=siz[to];
		if(siz[to]>siz[son[x]])son[x]=to;
	}
}
inline void dfs2(int x,int topf){
	rev[seg[x]=++cnt]=x,top[x]=topf;
	if(!son[x])return;
	dfs2(son[x],topf);
	for(auto to:G[x]){
		if(to==fa[x]||to==son[x])continue;
		dfs2(to,to);
	}
}
inline int Jump(int x,int k){
	while(k>=seg[x]-seg[top[x]]+1&&x!=1)k-=seg[x]-seg[top[x]]+1,x=fa[top[x]];
	if(seg[x]-k<0)return 0;return rev[seg[x]-k];
}//这里使用树链剖分求 k 级祖先，因为倍增常数大

inline void pushup(int k){
	tree[k].num=tree[k].sum=0;
	if(tree[k].lc)tree[k].num+=tree[tree[k].lc].num,tree[k].sum+=tree[tree[k].lc].sum;
	if(tree[k].rc)tree[k].num+=tree[tree[k].rc].num,tree[k].sum+=tree[tree[k].rc].sum;
}
inline void update(int k,int v){tree[k].tag+=v,tree[k].sum+=tree[k].num*v;}
inline void pushdown(int k){
	if(!tree[k].tag)return;
	if(tree[k].lc)update(tree[k].lc,tree[k].tag);
	if(tree[k].rc)update(tree[k].rc,tree[k].tag);
	tree[k].tag=0;
}
inline void change(int &k,int l,int r,int x,int v){//单点修改
	if(!k)k=++tot;if(l==r)return tree[k].num++,tree[k].sum+=v,void();
	int mid=l+r>>1;
	if(x<=mid)change(tree[k].lc,l,mid,x,v);
	else change(tree[k].rc,mid+1,r,x,v);
	pushup(k);
}
inline void modify(int k,int l,int r,int x,int y,int v){//区间加
	if(!k)return;if(x<=l&&r<=y)return update(k,v);
	int mid=l+r>>1;
	pushdown(k);
	if(x<=mid)modify(tree[k].lc,l,mid,x,y,v);
	if(mid<y)modify(tree[k].rc,mid+1,r,x,y,v);
	pushup(k);
}
inline int query(int k,int l,int r,int x,int y){
	if(!k)return 0;if(x<=l&&r<=y)return tree[k].sum;
	int mid=l+r>>1,ret=0;
	pushdown(k);
	if(x<=mid)ret+=query(tree[k].lc,l,mid,x,y);
	if(mid<y)ret+=query(tree[k].rc,mid+1,r,x,y);
	return ret;
}//动态开点线段树，维护区间加与区间和
//change 操作用于建树并维护好 num，方便 lazy_tag 的标记，很显然 modify 与 query 操作不用开点而 change 需要

signed main(){
	n=read(),q=read();
	for(int i=1;i<=n;i++)a[i]=read();
	for(int i=1;i<n;i++){
		int x=read(),y=read();
		G[x].push_back(y);
		G[y].push_back(x);
	}
	dfs1(1,0),dfs2(1,1);
	for(int i=1;i<=n;i++)change(rt[dep[i]],1,n,seg[i],a[i]);
	for(int i=1;i<=n;i++)mx=max(mx,dep[i]);
	while(q--){
		int op=read(),u=read(),x=read();
		if(op==1){
			int y=read(),fath=Jump(u,x);
			if(fath)modify(rt[dep[fath]],1,n,seg[fath],seg[fath],y);//修改祖先
			if(!x)continue;//重复点不重复算
			if(dep[u]+x<=mx)modify(rt[dep[u]+x],1,n,seg[u],seg[u]+siz[u]-1,y);//修改祖先
		}
		if(op==2){
			int fath=Jump(u,x),ans=0;
			if(fath)ans+=query(rt[dep[fath]],1,n,seg[fath],seg[fath]);//查询祖先
			if(x&&dep[u]+x<=mx)ans+=query(rt[dep[u]+x],1,n,seg[u],seg[u]+siz[u]-1);//查询子孙
			printf("%lld\n",ans);
		}
	}
	return 0;
}
```

---

## 作者：Reply_ (赞：3)

## 题解：P13567 「CZOI-R5」折跃点

观察题面，注意到一个重要条件：“且过程中与折跃点 $1$ 的距离不断增加或不断减少。”

那么只能往上或者往下一直走，即对于点 $u$，经过 $x$ 次折跃后能到达的点是 $v$，$v$ 需要满足的条件有两种。

- 向上走，$v$ 是 $u$ 的祖先，而且 $dep_v=dep_u-x$。
- 向下走，$v$ 在 $u$ 的子树内，而且 $dep_v=dep_u+x$。

第一种条件较为简单，直接倍增向上跳找到即可。

第二种条件较为复杂，因为满足第二种条件的点会有多个，考虑对于每一个深度维护线段树，每个点向下走能达到的点在线段树是一个连续的区间，以每个点的 dfs 序为索引，因为一个点的子树的 dfs 序是一个连续区间，可以用二分求出这个区间在某棵线段树上对应的区间进行修改或者查询即可。

代码很丑就不贴了。

---

## 作者：CaiZi (赞：3)

以下记 $dep_i$ 为点 $i$ 的深度，$fa_x(i)$ 为 $i$ 的 $x$ 级祖先。

首先我们修改和查询的是同一层的节点，考虑类比 DFS 序，使用 BFS 序 $bfn$（即在 BFS 过程中按照顺序记录节点编号），那么每次被修改和查询的节点就是连续的，我们需要找到这个连续段的开头和结尾。

考虑先记录下 $dep_i=k$ 的节点的 BFS 序的范围，记为 $[mn_k,mx_k]$。然后在 $[mn_{dep_u+x},mx_{dep_u+x}]$ 内再找到为点 $x$ 儿子的点，不难发现对于 $dep_i=dep_j=dep_u+x$，若 $bfn_i<bfn_j$，则 $bfn_{fa_x(i)}<bfn_{fa_x(j)}$，所以这是有单调性的，可以二分找出这个符合条件的 BFS 序的范围。

Check 直接倍增找 $x$ 级祖先即可，使用线段树区间加区间和，注意特判 $x=0$，时间复杂度 $O(n\log^2n)$。卡卡能过，代码很大坨。

或者在此基础上维护 DFS 序，然后通过 DFS 序判断，时间复杂度 $O(n\log n)$。

代码展示（代码是 $O(n\log^2n)$ 的）：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long tre[1200001],tag[1200001],e;
int n,m,x,y,o,p,w[300001],fa[19][300001],dep[300001],mn[300001],mx[300001],clk,bfn[300001],bfg[300001];
bool u,v;
vector<int>f[300001];
queue<pair<int,int>>q;
pair<int,int>t;
inline void push(int l,int r,int s){
	tag[s<<1]+=tag[s];
	tag[s<<1|1]+=tag[s];
	tre[s<<1]+=tag[s]*((l+r>>1)-l+1);
	tre[s<<1|1]+=tag[s]*(r-(l+r>>1));
	tag[s]=0;
}
inline void build(int l,int r,int s){
	if(l==r){
		tre[s]=w[bfg[l]];
	}
	else{
		build(l,l+r>>1,s<<1);
		build((l+r>>1)+1,r,s<<1|1);
		tre[s]=tre[s<<1]+tre[s<<1|1];
	}
}
inline void update(int a,int b,long long c,int l,int r,int s){
	if(a<=l&&r<=b){
		tag[s]+=c;
		tre[s]+=c*(r-l+1);
	}
	else{
		push(l,r,s);
		if(a<=(l+r>>1)){
			update(a,b,c,l,(l+r>>1),s<<1);
		}
		if(b>(l+r>>1)){
			update(a,b,c,(l+r>>1)+1,r,s<<1|1);
		}
		tre[s]=tre[s<<1]+tre[s<<1|1];
	}
}
long long query(int a,int b,int l,int r,int s){
	long long c=0;
	if(a<=l&&r<=b){
		c=tre[s];
	}
	else{
		push(l,r,s);
		if(a<=(l+r>>1)){
			c+=query(a,b,l,(l+r>>1),s<<1);
		}
		if(b>(l+r>>1)){
			c+=query(a,b,(l+r>>1)+1,r,s<<1|1);
		}
	}
	return c;
}
inline int find(int a,int k){
	for(int i=0;i<=18;i++){
		if(k>>i&1){
			a=fa[i][a];
		}
	}
	return a;
}
signed main(){
	int l,r,mid,a,b;
	cin.tie(nullptr)->sync_with_stdio(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>w[i];
	}
	for(int i=2;i<=n;i++){
		cin>>x>>y;
		f[x].push_back(y);
		f[y].push_back(x);
	}
	q.emplace(1,1);
	dep[1]=1;
	while(!q.empty()){
		t=q.front();
		q.pop();
		for(int i=1;i<=18;i++){
			fa[i][t.first]=fa[i-1][fa[i-1][t.first]];
		}
		clk++;
		bfn[t.first]=clk;
		bfg[clk]=t.first;
		if(mn[t.second]==0){
			mn[t.second]=clk;
		}
		mx[t.second]=clk;
		for(int i:f[t.first]){
			if(bfn[i]==0){
				q.emplace(i,t.second+1);
				dep[i]=t.second+1;
				fa[0][i]=t.first;
			}
		}
	}
	build(1,n,1);
	while(m--){
		u=v=0;
		cin>>o>>p>>x;
		l=mn[dep[p]+x];
		r=mx[dep[p]+x];
		if(l!=0){
			u=1;
			while(l<=r){
				mid=l+r>>1;
				if(bfn[find(bfg[mid],x)]<bfn[p]){
					l=mid+1;
				}
				else{
					r=mid-1;
				}
			}
			a=r+1;
			l=mn[dep[p]+x];
			r=mx[dep[p]+x];
			while(l<=r){
				mid=(l+r>>1);
				if(bfn[find(bfg[mid],x)]>bfn[p]){
					r=mid-1;
				}
				else{
					l=mid+1;
				}
			}
			b=l-1;
		}
		l=bfn[find(p,x)];
		if(l!=0){
			v=1;
		}
		if(o==1){
			cin>>y;
			if(u&&a<=b){
				update(a,b,y,1,n,1);
			}
			if(v&&x!=0){
				update(l,l,y,1,n,1);
			}
		}
		else{
			e=0;
			if(u&&a<=b){
				e+=query(a,b,1,n,1);
			}
			if(v&&x!=0){
				e+=query(l,l,1,n,1);
			}
			cout<<e<<'\n';
		}
	}
	return 0;
}
```

---

## 作者：LXcjh4998 (赞：2)

[Luogu 链接](https://www.luogu.com.cn/problem/P13567)
# 题意
有一棵包含 $n$ 个节点的以 $1$ 为根的有根树，点有初始点权 $w_i$。

我们称点 $u$ 能经过 $x$ 次连续折跃能到达点 $v$，当且仅当从点 $u$ 出发，经历过 $x$ 条边能到达点 $v$，并且过程中与点 $1$ 的距离单调递增或单调递减。

现在有 $q$ 次操作，操作有两种类型：
- 操作 $1$：对于所有能从点 $u$ 通过 $x$ 次连续折跃到达的点，将其点权加 $y$。
- 操作 $2$：求所有能从点 $u$ 通过 $x$ 次连续折跃到达的点的点权之和。

数据范围：$1\le u\le n\le3\times10^5$，$1\le q\le3\times10^5$，$1\le w_i,y\le10^9$，$0\le x\le n$。
# 思路
注意到若点 $u$ 能经过 $x$ 次连续折跃能到达点 $v$，则点 $v$ 要么是点 $u$ 的 $x$ 级祖先；要么是在点 $u$ 的子树内，且深度恰比点 $u$ 的深度大 $x$。

对于修改、查询 $x$ 级祖先是简单的，只需用倍增预处理，然后跳 $x$ 级祖先维护即可。  
关键是如何维护在点 $u$ 子树内的点。

我们考虑进行一遍 DFS，并将一个点的 DFS 序插入到对应深度标号的平衡树里面。  
由于一个子树内的 DFS 序是一段区间，我们可以在平衡树里直接 split 出来，所以原问题就变成了区间加区间求和。

祖先的修改、查询与子树内修改同理（变成了单点修改）。

注意当 $x=0$ 时不要重复修改和查询。

可以做到 $O(n)$ 预处理，$O(q\log n)$ 处理询问，空间复杂度为 $O(n)$。
# 程序
[AC 记录](https://www.luogu.com.cn/record/228862499)
```cpp
#include<bits/stdc++.h>
#define forUp(i,a,b) for(int i=(a);i<=(b);++i)
#define forUP(i,a,b) for(int i=(a);i<(b);++i)
#define forDown(i,a,b) for(int i=(a);i>=(b);--i)
#define forG(i,u,v) for(int i=head[u],v=to[i];i;i=nxt[i],v=to[i])
#define pb emplace_back
using ll=long long;using ull=unsigned long long;using uint=unsigned int;using db=double;using ld=long db;using pii=std::pair<int,int>;using pdi=std::pair<db,int>;using vl=__int128;using uvl=unsigned __int128;
constexpr int INF=0x3f3f3f3f,MINF=0xcfcfcfcf;constexpr long long INFLL=0x3f3f3f3f3f3f3f3f,MINFLL=0xcfcfcfcfcfcfcfcf;constexpr double INFDB=1e50,eps=1e-9;
template<class _Tp>void chkMax(_Tp &x,const _Tp &y){x<y?x=y:0;}template<class _Tp>void chkMin(_Tp &x,const _Tp &y){x>y?x=y:0;}
constexpr int N=3e5+10;int __test_num=1,__test_id;using namespace std;void __init();

int n,q,w[N],u,v,op,x,y;

int tot,root[N],lson[N],rson[N],sz[N],rnd[N],val[N];ll num[N],sum[N],add[N];
int newNode(int value,int weight){
	int node=++tot;
	lson[node]=rson[node]=0;
	sz[node]=1;
	rnd[node]=rand();
	val[node]=value;
	num[node]=sum[node]=weight;
	return node;
}
void pushup(int node){
	if(!node)return;
	sz[node]=sz[lson[node]]+sz[rson[node]]+1;
	sum[node]=sum[lson[node]]+sum[rson[node]]+num[node];
}
void modify(int node,ll tag){
	if(!node)return;
	add[node]+=tag;
	num[node]+=tag;
	sum[node]+=tag*sz[node];
}
void pushdown(int node){
	if(!node)return;
	if(add[node]){
		if(lson[node])modify(lson[node],add[node]);
		if(rson[node])modify(rson[node],add[node]);
		add[node]=0;
	}
}
void split(int node,int value,int &treap1,int &treap2){
	if(!node){treap1=treap2=0;return;}
	pushdown(node);
	if(val[node]<=value)treap1=node,split(rson[node],value,rson[node],treap2);
	else treap2=node,split(lson[node],value,treap1,lson[node]);
	pushup(node);
}
int merge(int treap1,int treap2){
	if(!treap1||!treap2)return treap1|treap2;
	if(rnd[treap1]<rnd[treap2]){
		pushdown(treap1);
		rson[treap1]=merge(rson[treap1],treap2);
		pushup(treap1);
		return treap1;
	}
	else{
		pushdown(treap2);
		lson[treap2]=merge(treap1,lson[treap2]);
		pushup(treap2);
		return treap2;
	}
}
void insert(int &rt,int value,int weight){
	int treap1=0,treap2=0;
	split(rt,value,treap1,treap2);
	rt=merge(merge(treap1,newNode(value,weight)),treap2);
}
void update(int &rt,int l,int r,int x){
	int treap1=0,treap2=0,treap3=0;
	split(rt,r,treap2,treap3);
	split(treap2,l-1,treap1,treap2);
	modify(treap2,x);
	rt=merge(merge(treap1,treap2),treap3);
}
ll query(int &rt,int l,int r){
	int treap1=0,treap2=0,treap3=0;
	split(rt,r,treap2,treap3);
	split(treap2,l-1,treap1,treap2);
	ll ans=sum[treap2];
	rt=merge(merge(treap1,treap2),treap3);
	return ans;
}

int cnt,head[N],to[N<<1],nxt[N<<1];
void addEdge(int u,int v){
	++cnt,to[cnt]=v,nxt[cnt]=head[u],head[u]=cnt;
	++cnt,to[cnt]=u,nxt[cnt]=head[v],head[v]=cnt;
}

int dep[N],DFN,bg[N],ed[N],fa[N][20];
void dfs(int rt){
	bg[rt]=++DFN,dep[rt]=dep[fa[rt][0]]+1;
	insert(root[dep[rt]],bg[rt],w[rt]);
	for(int i=1;fa[rt][i-1];++i)fa[rt][i]=fa[fa[rt][i-1]][i-1];
	forG(i,rt,son){
		if(dep[son])continue;
		fa[son][0]=rt;
		dfs(son);
	}
	ed[rt]=DFN;
}
int kthfa(int u,int k){
	if(dep[u]-k<=0)return 0;
	int v=u;
	forUP(i,0,20)if(1<<i&k)v=fa[v][i];
	return v;
}

void __solve(int __test_id){
	scanf("%d%d",&n,&q);
	forUp(i,1,n)scanf("%d",&w[i]);
	forUP(i,1,n)scanf("%d%d",&u,&v),addEdge(u,v);
	dfs(1);
	while(q--){
		scanf("%d%d%d",&op,&u,&x);
		if(op==1){
			scanf("%d",&y);
			int kthpa=kthfa(u,x);
			if(kthpa)update(root[dep[kthpa]],bg[kthpa],ed[kthpa],y);
			if(x!=0&&dep[u]+x<=n&&root[dep[u]+x])update(root[dep[u]+x],bg[u],ed[u],y);
		}
		else{
			int kthpa=kthfa(u,x);ll ans=0;
			if(kthpa)ans+=query(root[dep[kthpa]],bg[kthpa],ed[kthpa]);
			if(x!=0&&dep[u]+x<=n&&root[dep[u]+x])ans+=query(root[dep[u]+x],bg[u],ed[u]);
			printf("%lld\n",ans);
		}
	}
}
signed main(){
	__init();
	forUp(i,1,__test_num)__solve(i);
	return 0;
}
void __init(){
	//const string __file_name="test";freopen((__file_name+".in").c_str(),"r",stdin);freopen((__file_name+".out").c_str(),"w",stdout);
	//scanf("%d",&__test_num);
}
```

---

## 作者：Loop1st (赞：0)

首先做法是和其它题解一样的，把深度相同的点找出来，按 dfn 排序（注意这个可以在 dfs 的时候直接加，保证有序），这样就能保证修改的点是一个区间。然后二分得到需要修改的区间，线段树维护即可。时间复杂度 $\mathcal{O}(n \log n)$.

实现上，似乎其它题解都是对每一层开一颗线段树，但是这样太麻烦了，还要动态开点，这里有一个问题，为什么要维护 dfn 而不是 bfn? 因为那样无法判断是否在子树内，所以如果我们按 bfn 来维护线段树是对的，于是只要记一下小于当前深度的点的个数，加上去修改即可。（讲的不太清楚，具体可以看实现）。

Code:
~~~cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
const int N = 3e5 + 10, mod = 998244353;
template<typename T>
void dbg(const T &t) { cout << t << endl; }
template<typename Type, typename... Types>
void dbg(const Type& arg, const Types&... args) {
    #ifdef ONLINE_JUDGE
        return ;
    #endif
    cout << arg << ' ';
    dbg(args...);
}   
int n, m, a[N], dep[N], dfn[N], f[20][N], s[N], sz[N], idx, mx;
vector<int>c[N], e[N];
inline void dfs(int u, int fa) {
    sz[u] = 1;
    dfn[u] = ++idx;
    mx = max(mx, dep[u]);
    // if (c[dep[u]].empty()) c[dep[u]].push_back(0);
    c[dep[u]].push_back(dfn[u]);
    for (auto v : e[u]) if (v != fa) {
        dep[v] = dep[u] + 1;
        f[0][v] = u;
        dfs(v, u);
        sz[u] += sz[v];
    }
}
struct SegTree {
    #define ls (u << 1)
    #define rs (u << 1 | 1)
    ll tr[N << 2], tag[N << 2];
    void pushup(int u) { tr[u] = tr[ls] + tr[rs]; }
    void build(int l = 0, int r = n - 1, int u = 1) {
        if (l == r) {
            tr[u] = 0ll;
            return ;
        }
        int mid = (l + r) >> 1;
        build(l, mid, ls); build(mid + 1, r, rs);
        pushup(u);
    }
    void pushdown(int u, int l, int r) {
        if (!tag[u]) return ;
        int mid = (l + r) >> 1;
        tr[ls] += tag[u] * (mid - l + 1); tr[rs] += tag[u] * (r - mid);
        tag[ls] += tag[u]; tag[rs] += tag[u];
        tag[u] = 0;
    }
    void add(int x, int y, int v, int l = 0, int r = n - 1, int u = 1) {
        if (x < 0 || y < 0) return ;
        if (x <= l && r <= y) {
            tr[u] += (ll)v * (r - l + 1); tag[u] += v;
            return ;
        }
        pushdown(u, l, r);
        int mid = (l + r) >> 1;
        if (x <= mid) add(x, y, v, l, mid, ls);
        if (mid < y) add(x, y, v, mid + 1, r, rs);
        pushup(u);
    }
    ll ask(int x, int y, int l = 0, int r = n - 1, int u = 1) {
        if (x < 0 || y < 0) return 0ll;
        if (x <= l && r <= y) return tr[u];
        pushdown(u, l, r);
        int mid = (l + r) >> 1; ll res = 0;
        if (x <= mid) res += ask(x, y, l, mid, ls);
        if (mid < y) res += ask(x, y, mid + 1, r, rs);
        return res;
    }
    #undef ls
    #undef rs
} st;
int main() {
    // freopen("data.in", "r", stdin);
    // freopen("data.out", "w", stdout);
    ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 1, u, v; i < n; i++) { cin >> u >> v; e[u].push_back(v); e[v].push_back(u); }
    dep[1] = 1;
    dfs(1, 0);
    for (int i = 1; i <= mx; i++) s[i] = s[i - 1] + c[i].size();
    for (int i = 1; i <= n; i++) {
        int t = dep[i], rk = lower_bound(c[t].begin(), c[t].end(), dfn[i]) - c[t].begin();
        // dbg(i, t, rk);
        st.add(s[t - 1] + rk, s[t - 1] + rk, a[i]);
    }
    for (int d = 1; d < 20; d++) for (int i = 1; i <= n; i++) f[d][i] = f[d - 1][f[d - 1][i]];
    while (m--) {
        int op, u, x, y;
        cin >> op >> u >> x;
        int fa = u;
        for (int d = 0; d < 20; d++) if (x >> d & 1) fa = f[d][fa];
        int t = dep[fa], l = -N, r = -N, pos = -1;
        if (fa && fa != u) pos = s[t - 1] + lower_bound(c[t].begin(), c[t].end(), dfn[fa]) - c[t].begin();
        t = dep[u] + x;
        if (t <= mx) 
            l = lower_bound(c[t].begin(), c[t].end(), dfn[u]) - c[t].begin(), r = upper_bound(c[t].begin(), c[t].end(), dfn[u] + sz[u] - 1) - c[t].begin() - 1;
        // dbg(pos, fa, s[t - 1] + l, s[t - 1] + r);
        if (op == 1) {
            cin >> y;
            st.add(pos, pos, y);
            st.add(s[t - 1] + l, s[t - 1] + r, y);
        } else {
            // dbg(st.ask(pos, pos));
            cout << st.ask(pos, pos) + st.ask(s[t - 1] + l, s[t - 1] + r) << '\n';
        }
    }
    return 0;
}
~~~

---

## 作者：Acit (赞：0)

**思路**

考虑在 dfs 的过程中记录按顺序记录每个深度有哪些点，并按顺序给每个深度记录的点进行连续编号。根据 dfs 序的性质，我们不难发现任意一棵子树内同一深度的点编号连续，并且与往下走 $k$ 步能到达的点一一对应。

接下来考虑对于每个询问（或修改），如何求出往下走 $u$ 步所对应的标号区间：对于任意一点 $j$，记它的深度为 $dep_j$，我们想要的就是 $j$ 子树内所有深度为 $dep_j+u$ 的点对应的编号区间。

因为编号区间是连续的，我们可以通过维护最大值和最小值来刻画这个区间。如果以深度为下标，建一棵线段树维护这些信息，那么一个点的信息可以由它所有儿子节点的信息合并得到，这就启发我们用线段树合并去维护。

于是我们可以离线所有操作，并在一个 dfs 过程中通过线段树合并求出每次操作往下走 $u$ 步对应的编号区间，这样原来的操作就可以转化为一个区间加加上一个单点加，随便用线段树维护一下就过了。

**Code**

常数巨大，要看评测机状态。

```cpp
#include<bits/stdc++.h>
#define forr(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
#define int long long
using namespace std;
const int N=3e5+10;
int n,m;
int op[N],u[N],v[N],xx[N],a[N],f[N][21],to[N];
vector<int> e[N];
int idx[N],tpid,dep[N],dmx;
vector<int> d[N];
void dfs(int nw,int fa,int dp){
	dep[nw]=dp;dmx=max(dmx,dp);
	f[nw][0]=fa;
	d[dp].push_back(nw);
	for(auto i : e[nw]){
		if(i==fa)continue;
		dfs(i,nw,dp+1);
	}
}
void mkid(){
	forr(i,1,dmx)for(auto j : d[i])idx[j]=++tpid,to[tpid]=j;
	forr(i,1,20)forr(j,1,n)f[j][i]=f[f[j][i-1]][i-1];
}
int getkfa(int x,int k){
	if(dep[x]<=k)return -1;
	int nw=x;
	roff(i,20,0){
		if(k>=(1<<i)){
			k-=(1<<i);
			nw=f[nw][i];
		}
	}
	return nw;
}
int tree[N<<2],tag[N<<2];
#define lson k<<1
#define rson k<<1|1
#define mid ((l+r)>>1)
void pd(int k,int l,int r){
	if(!tag[k])return ;
	tag[lson]+=tag[k];tag[rson]+=tag[k];
	tree[lson]+=(mid-l+1)*tag[k];tree[rson]+=(r-mid)*tag[k];
	tag[k]=0;
}
void update(int k,int l,int r,int x,int y,int z){
	if(l>y||r<x)return ;
	if(x<=l&&r<=y){
		tag[k]+=z;tree[k]+=(r-l+1)*z;return ;
	}
	pd(k,l,r);
	update(lson,l,mid,x,y,z);update(rson,mid+1,r,x,y,z);
	tree[k]=tree[lson]+tree[rson];
}
int query(int k,int l,int r,int x,int y){
	if(l>y||r<x)return 0;
	if(x<=l&&r<=y)return tree[k];
	pd(k,l,r);
	return query(lson,l,mid,x,y)+query(rson,mid+1,r,x,y);
}
void build(int k,int l,int r){
	if(l==r){
		tree[k]+=a[to[l]];
		return ;
	}
	build(lson,l,mid);build(rson,mid+1,r);
	tree[k]=tree[lson]+tree[rson];
}
struct Node{
	int ls,rs,mn,mx;
}tr[N<<5];
#define ls(k) tr[k].ls
#define rs(k) tr[k].rs
#define mx(k) tr[k].mx
#define mn(k) tr[k].mn
int ccnt=0;
int root[N];
void modify(int &k,int l,int r,int x,int z){
	if(l>x||r<x)return ;
	if(!k)k=++ccnt;
	if(l==r){
		if(!mn(k))mn(k)=z;
		else mn(k)=min(mn(k),z);
		mx(k)=max(mx(k),z);return ;
	}
	modify(ls(k),l,mid,x,z);modify(rs(k),mid+1,r,x,z);
}
void merge(int &k,int k1,int l,int r){
	if(!k||!k1)return k+=k1,void();
	if(l==r){
		if(!mn(k)||!mn(k1))mn(k)+=mn(k1);
		else mn(k)=min(mn(k),mn(k1));
		mx(k)=max(mx(k),mx(k1));
		return ;
	}
	merge(ls(k),ls(k1),l,mid);merge(rs(k),rs(k1),mid+1,r);
}
vector<pair<int,int> > q[N];
int lef[N],ri[N];
pair<int,int> ask(int k,int l,int r,int x){
	if(l==r)return {mn(k),mx(k)};
	if(mid>=x)return ask(ls(k),l,mid,x);
	return ask(rs(k),mid+1,r,x);
}
void dfs1(int nw,int fa){
	for(auto i : e[nw]){
		if(i==fa)continue;
		dfs1(i,nw);
	}
	modify(root[nw],1,dmx,dep[nw],idx[nw]);
	for(auto i : e[nw]){
		if(i==fa)continue;
		merge(root[nw],root[i],1,dmx);
	}
	for(auto j : q[nw]){
		if(dep[nw]+j.first>dmx)continue;
		pair<int,int> dd=ask(root[nw],1,dmx,dep[nw]+j.first);
		lef[j.second]=dd.first;ri[j.second]=dd.second;
	}
}
signed main(){
	ios::sync_with_stdio(0);
	cin>>n>>m;
	forr(i,1,n)cin>>a[i];
	forr(i,1,n-1){
		int x,y;
		cin>>x>>y;
		e[x].push_back(y);e[y].push_back(x);
	}
	forr(i,1,m){
		cin>>op[i];
		if(op[i]==1)cin>>u[i]>>v[i]>>xx[i];
		else cin>>u[i]>>v[i];
		q[u[i]].push_back({v[i],i});
	}
	dfs(1,1,1);mkid();
	dfs1(1,1);
	build(1,1,n);
	forr(i,1,m){
		if(op[i]==1){
			update(1,1,n,lef[i],ri[i],xx[i]);
			int ff=getkfa(u[i],v[i]);
			if(ff>0&&v[i]>0)update(1,1,n,idx[ff],idx[ff],xx[i]);
		}else{
			int ans=query(1,1,n,lef[i],ri[i]);
			int ff=getkfa(u[i],v[i]);
			if(ff>0&&v[i]>0)ans+=query(1,1,n,idx[ff],idx[ff]);
			cout<<ans<<endl;
		}
	}
	return 0;
}

```

---

## 作者：FallingFYC_ (赞：0)

[P13567 「CZOI-R5」折跃点](https://www.luogu.com.cn/problem/P13567)

---

不妨将所有从折跃点 $u$ 经过 $x$ 次连续折跃能到达的折跃点分为两类：$u$ 的 $x$ 级祖先和 $u$ 的 $x$ 级子孙。

对于 $x$ 级祖先，可以通过倍增实现。

对于 $x$ 级子孙，由于其可能有很多个，所以我们最好将它们映射到一个连续的编号，这样转变为了区间操作，就可以用线段树实现了。这个编号就是 bfs 序（~~这个技巧还是从 [P11993](https://www.luogu.com.cn/problem/P11993) 的题解学来的~~）。

现在问题就变为了我们该如何求出这段区间的左右段点。考虑二分答案，显然可以通过查找 $x$ 级祖先来检查当前的 $mid$，这样的二分时间复杂度就是 $O(\log^2 n)$ 的，勉强接受，但我们可以通过另一种方法做到 $O(\log n)$ 二分。

考虑 $v$ 是 $u$ 的 $x$ 级子孙的条件，很明显有两条：$v$ 是 $u$ 的儿子且 $v$ 到 $u$ 的距离为 $x$。

对于第一个条件，可等价转换为 $dfn_u \le dfn_v \le dfn_u+size_u-1$；对于第二个条件，可等价转换为 $depth_v-depth_u=x$。于是再预处理 dfs 序、子树大小、深度就行了。

总结一下：预处理 bfs 序、dfs 序、祖先、深度、子树大小以及 bfs 序对应的节点编号，对于每次操作用倍增与二分求出需要修改或查询的一个元素（$x$ 级祖先）和一个区间（$x$ 级子孙），然后用线段树维护。

----

```cpp line-numbers
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define int ll
#define FOR(i,a,b) for(int i=(a);i<=(b);i++)
#define REV(i,a,b) for(int i=(a);i>=(b);i--)
#define CLOSE_TIE ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define psbk push_back
#define mkp make_pair
#define endl '\n'
#define ls(p) (p<<1)
#define rs(p) (p<<1|1)
#define mid ((l+r)>>1)
#define outval(x) cout<<(#x)<<'='<<x<<endl;
#define outarr(a,be,ed)\
cout<<(#a)<<'=';\
FOR(i,be,ed)cout<<a[i]<<' ';\
cout<<endl;
const int N=3e5+5;
int n,m,a[N],bfn[N],dfn[N],fa[N][25],dep[N],sz[N],cnt,id[N];
vector<int> e[N];
struct SegTree{
    int sum[N<<2],tag[N<<2];
    void push_up(int p){sum[p]=sum[ls(p)]+sum[rs(p)];}
    void build(int p,int l,int r){
        if(l==r){
            sum[p]=a[id[l]];
            return;
        }
        build(ls(p),l,mid);
        build(rs(p),mid+1,r);
        push_up(p);
    }
    void add_tag(int p,int l,int r,int d){
        tag[p]+=d;
        sum[p]+=(r-l+1)*d;
    }
    void push_down(int p,int l,int r){
        if(tag[p]){
            add_tag(ls(p),l,mid,tag[p]);
            add_tag(rs(p),mid+1,r,tag[p]);
            tag[p]=0;
        }
    }
    void update(int p,int l,int r,int x,int y,int k){
        if(x<=l&&r<=y){
            add_tag(p,l,r,k);
            return;
        }
        push_down(p,l,r);
        if(x<=mid) update(ls(p),l,mid,x,y,k);
        if(y>mid) update(rs(p),mid+1,r,x,y,k);
        push_up(p);
    }
    int query(int p,int l,int r,int x,int y){
        if(x<=l&&r<=y) return sum[p];
        push_down(p,l,r);
        int res=0;
        if(x<=mid) res+=query(ls(p),l,mid,x,y);
        if(y>mid) res+=query(rs(p),mid+1,r,x,y);
        return res;
    }
}t;
void bfs(int s){
    queue<int> q;
    q.push(s);
    while(!q.empty()){
        int u=q.front();
        q.pop();
        bfn[u]=++cnt; id[bfn[u]]=u;
        for(int v:e[u]){
            if(v==fa[u][0]) continue;
            fa[v][0]=u; dep[v]=dep[u]+1;
            q.push(v);
        }
    }
}
void dfs(int u){
    dfn[u]=++cnt; sz[u]=1;
    for(int v:e[u]){
        if(v==fa[u][0]) continue;
        dfs(v);
        sz[u]+=sz[v];
    }
}
signed main(){
    CLOSE_TIE
    cin>>n>>m;
    FOR(i,1,n) cin>>a[i];
    FOR(i,1,n-1){
        int u,v;
        cin>>u>>v;
        e[u].psbk(v); e[v].psbk(u);
    }
    bfs(1); cnt=0; dfs(1);
    t.build(1,1,n);
    FOR(i,1,20)
        FOR(j,1,n) fa[j][i]=fa[fa[j][i-1]][i-1];
    FOR(i,1,m){
        int op,u,x,y;
        cin>>op>>u>>x;
        int L=0,R=0,l=1,r=n;
        while(l<=r){
            if(dep[id[mid]]-dep[u]<x) l=mid+1;
            else if(dep[id[mid]]-dep[u]>x) r=mid-1;
            else{
                if(dfn[id[mid]]<dfn[u]) l=mid+1;
                else if(dfn[id[mid]]>dfn[u]+sz[u]-1) r=mid-1;
                else L=mid,r=mid-1;
            }
        }
        l=1,r=n;
        while(l<=r){
            if(dep[id[mid]]-dep[u]<x) l=mid+1;
            else if(dep[id[mid]]-dep[u]>x) r=mid-1;
            else{
                if(dfn[id[mid]]<dfn[u]) l=mid+1;
                else if(dfn[id[mid]]>dfn[u]+sz[u]-1) r=mid-1;
                else R=mid,l=mid+1;
            }
        }
        int fax=u;
        REV(i,20,0)
            if(x&(1<<i)) fax=fa[fax][i];
        if(op==1){
            cin>>y;
            if(L&&R) t.update(1,1,n,L,R,y);
            if(fax&&(bfn[fax]<L||R<bfn[fax])) t.update(1,1,n,bfn[fax],bfn[fax],y);
        }else{
            int ans=(L&&R?t.query(1,1,n,L,R):0);
            if(fax&&(bfn[fax]<L||R<bfn[fax])) ans+=t.query(1,1,n,bfn[fax],bfn[fax]);
            cout<<ans<<endl;
        }
    }
    return 0;
}
```

---

## 作者：Asedwai (赞：0)

见过的人都笑了。
## 思路
  向上跳直接使用倍增；考虑如何处理在 $u$ 子树内且距离 $u$ 为 $k$ 的点。  

  记 $dfn_x$ 表示节点 $x$ 的 dfs 序，$siz_x$ 表示节点 $x$ 的子树大小，$dep_x$ 表示节点 $x$ 的深度。由 dfs 序的连续性可知满足在 $u$ 子树内且距离 $u$ 为 $k$ 的点 $x$ 的充分条件为 $dep_x=dep_u+k\land dfn_u\le dfn_x\lt dfn_u+siz_u$。  

  发现这是一个在线二维数点问题。有一种非常暴力的方法。

  我们对于每一层建一棵动态开点线段树。对于节点 $x$，以 $dfn_x$ 为下标在第 $dep_x$ 层线段树上增加 $a_x$ 的权值。求 $u$ 子树内距离为 $k$ 的点的权值和相当于在第 $dep_u+k$ 层线段树上求区间 $[dfn_u,dfn_u+siz_u)$ 的点的权值和；修改操作类似，就是注意空节点不要再开点了。  

  代码很简单。时间复杂度 $O((n+m)\log n)$，就是常数特别大，优化一下输入输出方式即可。

---

## 作者：Lele_Programmer (赞：0)

# P13567 题解

## 思路

对于一个节点 $u$，进行 $x$ 次折跃能够到达的点就是它子树内深度比它深 $x$ 的点，以及它往上走 $x$ 步到达的祖先。

如何获取某个点子树内某个深度的点呢？其实很简单，先把整棵树 dfs，对于一个点，它被 dfs 到的时候放进一个序列里，它的子树都 dfs 完了之后要回溯了再把它放进序列里，会发现，序列里这两个数之间的所有数就是它的子节点。

所以对于每一个深度都建立一棵线段树，每一次找到 $dep_u + x$ 对应的线段树，然后按照刚刚的方法可以用二分找出这棵线段树对应的需要操作的区间。

对于它往上走 $x$ 次的祖先，这个可以用倍增求。

注意 $x=0$ 时向上向下是一样的，不要算重。

## 代码

```cpp
#define _rep(i,a,b) for (int i=(a);i<=(b);++i)
#define _rrep(i,a,b) for (int i=(a);i>=(b);--i)
#define _graph(i,u) for (int i=h[u];~i;i=ne[i])

const int N=600005;
const int M=600005;
const int K=25;

int n,m,idx;
int arr[N],w[N];
int e[M],ne[M],h[N],tot;
int dep[N];
int f[N][K];
pii st[N];
vector<int> vec[N];

struct Seg {
    int l,r,v;
    int add;
};

typedef vector<Seg> tree;
tree tr[N];

void add(int a,int b) {
    e[tot]=b,ne[tot]=h[a],h[a]=tot++;
}

void dfs(int u,int fa,int d) {
    dep[u]=d;
    st[u].first=++idx;
    vec[dep[u]].emplace_back(idx);
    w[idx]=arr[u];
    _graph(i,u) {
        if (e[i]==fa) continue;
        f[e[i]][0]=u;
        _rep(j,1,K-1) f[e[i]][j]=f[f[e[i]][j-1]][j-1];
        dfs(e[i],u,d+1);
    }
    st[u].second=++idx;
}

void pushup(tree& tr,int u) {
    tr[u].v=tr[u<<1].v+tr[u<<1|1].v;
}

void pushdown(tree& tr,int u) {
    auto &root=tr[u],&left=tr[u<<1],&right=tr[u<<1|1];
    if (root.add) {
        left.add+=root.add;
        right.add+=root.add;
        left.v+=(left.r-left.l+1)*root.add;
        right.v+=(right.r-right.l+1)*root.add;
        root.add=0;
    }
}

void build(tree& tr,int u,int l,int r) {
    tr[u]={l,r,0,0};
    if (l==r) return;
    int mid=l+r>>1;
    build(tr,u<<1,l,mid);
    build(tr,u<<1|1,mid+1,r);
    pushup(tr,u);
}

void modify(tree& tr,int u,int l,int r,int k) {
    if (tr[u].l>=l && tr[u].r<=r) {
        tr[u].v+=(tr[u].r-tr[u].l+1)*k;
        tr[u].add+=k;
    } else {
        pushdown(tr,u);
        int mid=tr[u].l+tr[u].r>>1;
        if (l<=mid) modify(tr,u<<1,l,r,k);
        if (r>mid) modify(tr,u<<1|1,l,r,k);
        pushup(tr,u);
    }
}

int query(tree& tr,int u,int l,int r) {
    if (tr[u].l>=l && tr[u].r<=r) return tr[u].v;
    pushdown(tr,u);
    int mid=tr[u].l+tr[u].r>>1;
    int ans=0;
    if (l<=mid) ans+=query(tr,u<<1,l,r);
    if (r>mid) ans+=query(tr,u<<1|1,l,r);
    return ans;
}

i32 main() {
    // FRR("D.in");
    // FRW("D_wa.out");
    memset(h,-1,sizeof(h));
    read(n),read(m);
    _rep(i,1,n) read(arr[i]);
    _rep(i,1,n-1) {
        int a,b;
        read(a),read(b);
        add(a,b),add(b,a);
    }
    dfs(1,0,1);
    _rep(i,1,n) {
        if (vec[i].empty()) continue;
        _rep(j,1,(vec[i].size()+5)*4) tr[i].emplace_back(Seg{0,0,0,0});
        build(tr[i],1,0,vec[i].size()-1);
        _rep(j,0,(int)vec[i].size()-1) modify(tr[i],1,j,j,w[vec[i][j]]);
    }
    while (m--) {
        int p;
        read(p);
        if (p==1) {
            int u,x,y;
            read(u),read(x),read(y);
            if (x) {
                int d=dep[u]+x;
                int l=st[u].first,r=st[u].second;
                int lpos=lower_bound(vec[d].begin(),vec[d].end(),l)-vec[d].begin();
                int rpos=lower_bound(vec[d].begin(),vec[d].end(),r)-vec[d].begin()-1;
                if (lpos<=rpos) modify(tr[d],1,lpos,rpos,y);
            }
            _rrep(i,K-1,0) {
                if (x-(1<<i)>=0) {
                    u=f[u][i];
                    x-=(1<<i);
                }
            }
            if (u) {
                int pos=lower_bound(vec[dep[u]].begin(),vec[dep[u]].end(),st[u].first)-vec[dep[u]].begin();
                modify(tr[dep[u]],1,pos,pos,y);
            }
        } else {
            int u,x;
            read(u),read(x);
            int ans=0;
            if (x) {
                int d=dep[u]+x;
                int l=st[u].first,r=st[u].second;
                int lpos=lower_bound(vec[d].begin(),vec[d].end(),l)-vec[d].begin();
                int rpos=lower_bound(vec[d].begin(),vec[d].end(),r)-vec[d].begin()-1;
                if (lpos<=rpos) ans+=query(tr[d],1,lpos,rpos);
            }
            _rrep(i,K-1,0) {
                if (x-(1<<i)>=0) {
                    u=f[u][i];
                    x-=(1<<i);
                }
            }
            if (u) {
                int pos=lower_bound(vec[dep[u]].begin(),vec[dep[u]].end(),st[u].first)-vec[dep[u]].begin();
                ans+=query(tr[dep[u]],1,pos,pos);
            }
            writeln(ans);
        }
    }
    return 0;
}
```

---


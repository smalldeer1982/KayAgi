# 方差

## 题目背景

滚粗了的 HansBug 在收拾旧数学书，然而他发现了什么奇妙的东西。


## 题目描述

蒟蒻 HansBug 在一本数学书里面发现了一个神奇的数列，包含 $N$ 个实数。他想算算这个数列的平均数和方差。


## 说明/提示

关于方差：对于一个有 $n$ 项的数列 $A$，其方差 $s^2$ 定义如下：
$$s^2=\frac{1}{n}\sum\limits_{i=1}^n\left(A_i-\overline A\right)^2$$
其中 $\overline A$ 表示数列 $A$ 的平均数，$A_i$ 表示数列 $A$ 的第 $i$ 项。

样例说明：
| 操作步骤 | 输入内容 | 操作要求 | 数列 | 输出结果 | 说明 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $0$ | - | - | `1 5 4 2 3` | - | - |
| $1$ | `2 1 4` | 求 $\left[1,4\right]$ 内所有数字的平均数 | `1 5 4 2 3` | `3.0000` | 平均数 $=\left(1+5+4+2\right)\div 4=3.0000$ |
| $2$ | `3 1 5` | 求 $\left[1,5\right]$ 内所有数字的方差 | `1 5 4 2 3` | `2.0000` | 平均数 $=\left(1+5+4+2+3\right)\div 5=3$，方差 $=\left(\left(1-3\right)^2+\left(5-3\right)^2+\left(4-3\right)^2+\left(2-3\right)^2+\left(3-3\right)^2\right)\div 5=2.0000$ |
| $3$ | `1 1 1 1` | 将 $\left[1,1\right]$ 内所有数字加 $1$ | `2 5 4 2 3` | - | - |
| $4$ | `1 2 2 -1` | 将 $\left[2,2\right]$ 内所有数字加 $-1$ | `2 4 4 2 3` | - | - |
| $5$ | `3 1 5` | 求 $\left[1,5\right]$ 内所有数字的方差 | `2 4 4 2 3` | `0.8000` | 平均数 $=\left(2+4+4+2+3\right)\div 5=3$，方差 $=\left(\left(2-3\right)^2+\left(4-3\right)^2+\left(4-3\right)^2+\left(2-3\right)^2+\left(3-3\right)^2\right)\div 5=0.8000$ |

数据规模：
| 数据点 | $N$ | $M$ | 备注 |
| :----------: | :----------: | :----------: | :----------: |
| $1\sim3$ | $N\le 8$ | $M\le 15$ | - |
| $4\sim7$ | $N\le 10^5$ | $M\le 10^5$ | 不包含操作 $3$|
| $8\sim10$ | $N\le 10^5$ | $M\le 10^5$ | - |

## 样例 #1

### 输入

```
5 5
1 5 4 2 3
2 1 4
3 1 5
1 1 1 1
1 2 2 -1
3 1 5
```

### 输出

```
3.0000
2.0000
0.8000
```

# 题解

## 作者：远航之曲 (赞：138)


我们把方差公式展开

 ![](https://cdn.luogu.com.cn/upload/pic/3825.png) 

所以只需要维护一个区间平方和和区间和

当我们更新一个区间加时

 ![](https://cdn.luogu.com.cn/upload/pic/3826.png) 

所以pushdown就很好写了

具体见代码

想要进一步学习的可以看[这里](http://www.yhzq-blog.cc/线段树高阶总结/)


        
    
    
```cpp
#include <cstdio>
#include <iostream>
#define lson rt<<1,l,mid
#define rson rt<<1|1,mid+1,r
#define Maxn 300010
using namespace std;
double sega[Maxn],segb[Maxn];
double mark[Maxn];
void pushup(int x)
{
    sega[x]=sega[x<<1]+sega[x<<1|1];
    segb[x]=segb[x<<1]+segb[x<<1|1];
}
void pushdown(int rt,int x)
{
    if (mark[rt])
    {
        segb[rt<<1]+=2*mark[rt]*sega[rt<<1]+(x-x/2)*mark[rt]*mark[rt];
        segb[rt<<1|1]+=2*mark[rt]*sega[rt<<1|1]+(x/2)*mark[rt]*mark[rt];
        sega[rt<<1]+=(x-x/2)*mark[rt];
        sega[rt<<1|1]+=(x/2)*mark[rt];
        mark[rt<<1]+=mark[rt];
        mark[rt<<1|1]+=mark[rt];
        mark[rt]=0;
    }
}
void build(int rt,int l,int r)
{
    if (l==r)
        cin>>sega[rt],segb[rt]=sega[rt]*sega[rt];
    else
    {
        int mid=(l+r)/2;
        build(lson);
        build(rson);
        pushup(rt);
    }
}
double query_a(int rt,int l,int r,int L,int R)
{
    //--L--l--r--R--
    if (l>=L && r<=R)
        return sega[rt];
    else
    {
        pushdown(rt,r-l+1);
        int mid=(r+l)/2;
        double ret=0;
        if (mid>=L)
            ret+=query_a(lson,L,R);
        if (mid<R)
            ret+=query_a(rson,L,R);
        return ret;
    }
}
double query_b(int rt,int l,int r,int L,int R)
{
    //--L--l--r--R--
    if (l>=L && r<=R)
        return segb[rt];
    else
    {
        pushdown(rt,r-l+1);
        int mid=(r+l)/2;
        double ret=0;
        if (mid>=L)
            ret+=query_b(lson,L,R);
        if (mid<R)
            ret+=query_b(rson,L,R);
        return ret;
    }
}
void update(int rt,int l,int r,int L,int R,double x)
{
    if (l>=L && r<=R)
        mark[rt]+=x,segb[rt]+=2*x*sega[rt]+x*x*(r-l+1),sega[rt]+=(r-l+1)*x;
    else
    {
        pushdown(rt,r-l+1);
        int mid=(r+l)/2;
        if (mid>=L)
            update(lson,L,R,x);
        if (mid<R)
            update(rson,L,R,x);
        pushup(rt);
    }
}
double sqr(double x)
{
    return x*x;
}
main()
{
    int n,m,x,y,c;
    double z;
    scanf("%d %d",&n,&m);
    build(1,1,n);
    for (int i=1;i<=m;i++)
    {
        scanf("%d",&c);
        if (c==2)
            scanf("%d%d",&x,&y),printf("%.4lf\n",query_a(1,1,n,x,y)/(y-x+1));
        if (c==1)
            scanf("%d%d",&x,&y),cin>>z,update(1,1,n,x,y,z);
        if (c==3)
        {
            scanf("%d%d",&x,&y);
            double sum1=query_b(1,1,n,x,y)/(y-x+1),sum2=query_a(1,1,n,x,y)/(y-x+1);
            double ans=sum1-sum2*sum2;
            printf("%.4lf\n",ans);
        }
    }
}
```

---

## 作者：DPair (赞：111)

//update 2019/11/07 修改Q4公式结论错误（感谢用户@Jomoo）

`弱弱的说一句，感觉这道题绝对评分低了。。。`

## 【思路】
### Q1：平均数怎么做？
根据题面的区间修改，区间求值，可以想到用线段树区间求和。（平均数就是这么做的）

### Q2：那么方差怎么做？
数学老师曾经讲过，方差可以推出来一个公式。
### 下面展示完整推导过程。
$$ S^2 = \frac{1}{n} * [(x_1 - \overline{x})^2 + (x_2 - \overline{x})^2 + ...+(x_n - \overline{x})^2 ]$$
根据完全平方公式：
$$(a + b)^2 = a^2 + 2ab + b^2$$
展开导出：
$$S^2 = \frac{1}{n} * ({x_1}^2 - 2{x_1}\overline{x} + {\overline{x}^2} + {x_2}^2 - 2{x_2}\overline{x} + {\overline{x}^2} + ... + {x_n}^2 - 2{x_n}\overline{x} + {\overline{x}^2})$$
整理得：
$$S^2 = \frac{1}{n} * [({x_1}^2 + {x_2}^2 + ... + {x_n}^2)-2\overline{x}(x_1 + x_2 + ...+x_n) + n\overline{x}^2]$$
因为：
$$n\overline{x} = x_1 + x_2 + ... + x_n$$
所以，原式得：
$$S^2 = \frac{1}{n} * [({x_1}^2 + {x_2}^2 + ... + {x_n}^2)-2n\overline{x}^2 + n\overline{x}^2]$$
即：
$$S^2 = \frac{1}{n} * [({x_1}^2 + {x_2}^2 + ... + {x_n}^2)-n\overline{x}^2]$$
所以得到：
$$S^2 = \frac{({x_1}^2 + {x_2}^2 + ... + {x_n}^2)}{n} - \overline{x}^2$$

### Q3：得出公式后怎么做？
由于我们可以用线段树求出平均数$\overline{x}$，所以我们只需要考虑公式前面那一部分，不难看出，我们只需写出可以求得区间平方和的线段树即可AC。

对于这一棵线段树，我们选择与一般线段树一样直接求和，不难发现**修改操作与pushdown操作**要做出改变。
### Q4：怎么变化以求出区间平方和？
很简单，由于我们区间加一个数$k$，那么对于一串数，设
$$sum1 = {x_1 + x_2 + ...+ x_n}$$
$$sum2 = {x_1}^2 + {x_2}^2 + ... + {x_n} ^ 2$$
而且$sum1$与$sum2$都是已知量。

我们要把区间和一次性改变为
$${(x_1 + k)}^2 +  {(x_2 + k)}^2 + ... +{(x_n + k)}^2$$
也是完全平方展开，得到：
$${(x_1 + k)}^2 +  {(x_2 + k)}^2 + ... +{(x_n + k)}^2 = ({x_1}^2 + 2kx_1 + k^2) + ({x_2}^2 + 2kx_2 + k^2) + ... +({x_n}^2 + 2kx_n + k^2)$$
$$=({x_1}^2 + {x_2}^2 +...+{x_n}^2) + 2k(x_1 + x_2 + ... + x_n)+nk^2$$
$$=sum2 + 2k * sum1 + nk^2$$
就可以改变了，$pushdown$也是同理。

### 然后其他的照线段树写就AC了

## 【代码】
```cpp
#include <bits/stdc++.h>
using namespace std;
double a[100010];

struct node{
    double sum, lazy;
};

node t1[400010], t2[400010];

inline void pushup(int rt)
{
    t1[rt].sum = t1[rt << 1].sum + t1[rt << 1 | 1].sum;	
    t2[rt].sum = t2[rt << 1].sum + t2[rt << 1 | 1].sum;	
}

inline void pushdown(int rt, int l, int r)
{
    int mid = (l + r) >> 1;
    t2[rt << 1].lazy += t2[rt].lazy;
    t2[rt << 1].sum += t1[rt << 1].sum * (t2[rt].lazy * 2) + (mid - l + 1) * (t2[rt].lazy * t2[rt].lazy);
    t2[rt << 1 | 1].lazy += t2[rt].lazy;
    t2[rt << 1 | 1].sum += t1[rt << 1 | 1].sum * (t2[rt].lazy * 2) + (r - mid) * (t2[rt].lazy * t2[rt].lazy);
    t2[rt].lazy = 0;
    t1[rt << 1].lazy += t1[rt].lazy;
    t1[rt << 1].sum += (mid - l + 1) * t1[rt].lazy;
    t1[rt << 1 | 1].lazy += t1[rt].lazy;
    t1[rt << 1 | 1].sum += (r - mid) * t1[rt].lazy;	
    t1[rt].lazy = 0;
}

void build(int rt, int l, int r)
{
    if (l == r) //叶子节点 
    {
        t1[rt].sum = a[l];
        t2[rt].sum = a[l] * a[l];
        return;	
    }
    int mid = (l + r) >> 1;
    build(rt << 1, l, mid);
    build(rt << 1 | 1, mid + 1, r);
    pushup(rt);
}

double query(node tree[], int rt, int l, int r, int x, int y)
//当前节点为rt,区间为l到r,我们要查询x到y
{
    if (x <= l && r <= y) return tree[rt].sum;
    int mid = (l + r) >> 1;
    if (tree[rt].lazy) pushdown(rt, l, r);
    double ans = 0;
    if (x <= mid) ans = ans + query(tree, rt << 1, l, mid, x, y);
    if (y > mid) ans = ans + query(tree, rt << 1 | 1, mid + 1, r, x, y);
    pushup(rt);
    return ans;
}

void modify(int rt, int l, int r, int x, int y , double z)
//当前节点为rt,区间为l到r，我们把区间x到y的每个值都上z 
{
    if (x <= l && r <= y)
    {
        t2[rt].lazy += z;
        t2[rt].sum += t1[rt].sum * (z * 2) + (r - l + 1) * (z * z);
        t1[rt].lazy += z;
        t1[rt].sum += (r - l + 1) * z;
        return;
    }
    if (t1[rt].lazy || t2[rt].lazy) pushdown(rt, l, r); 
    int mid = (l + r) >> 1; 
    if (x <= mid) modify(rt << 1, l, mid, x, y, z);
    if (y > mid) modify(rt << 1 | 1, mid + 1, r, x, y, z);
    pushup(rt);
}
int n, m, opt;
int main()
{
    scanf("%d%d", &n, &m);
    for (register int i = 1;i <= n;i ++)
    {
        scanf("%lf", &a[i]);
    }
    build(1, 1, n);
    while(m --)
    {
        scanf("%d", &opt);
        if(opt == 1)
        {
            int x, y;
            double z;
            scanf("%d%d%lf", &x, &y, &z);
            modify(1, 1, n, x, y, z);
        }
        if(opt == 2)
        {
            int x, y;
            scanf("%d%d", &x, &y);
            printf("%.4lf\n", query(t1, 1, 1, n, x, y) / ((y - x + 1) * 1.0));
        }
        if(opt == 3)
        {
            int x, y;
            scanf("%d%d", &x, &y);
            printf("%.4lf\n", (query(t2, 1, 1, n, x, y) / ((y - x + 1) * 1.0)) - (query(t1, 1, 1, n, x, y) / ((y - x + 1) * 1.0)) * (query(t1, 1, 1, n, x, y) / ((y - x + 1) * 1.0)));
        }
    }
}
```
## 【注意】
优先考虑上文中$sum2$即平方和，因为求平方和过程中使用的区间和是没有修改前的区间和。然后再计算区间和。不然很容易出锅。

---

## 作者：Ajwallet (赞：41)

# 为分块助威，把这题贴上分块标签！

#### $Solution$
先化简方差公式,$ave$为平均数
$$\frac{(x_1-ave)^2+(x_2-ave)^2+…+(x_{n-1}-ave)^2+(x_n-ave)^2}{n}$$
分配律
$$\frac{(x_1-ave)^2}{n}+\frac{(x_2-ave)^2}{n}+…+\frac{(x_{n-1}-ave)^2}{n}+\frac{(x_n-ave)^2}{n}$$
用求和符号框起来
$$\frac{\sum_{i\in N}[(x_i-\frac{\sum x}{n})^2]}{n}$$
完全平方和公式
$$\frac{\sum_{i\in N}[(x_i)^2-\frac{2x_i\sum x}{n}+\frac{(\sum x)^2}{n^2}]}{n}$$
分配律再拉
$$\sum_{i\in N}(\frac{(x_i)^2}{n}-\frac{2x_i\sum x}{n^2}+\frac{(\sum x)^2}{n^3})$$
分配律再拖
$$\frac{(\sum x)^2}{n^2}+\sum_{i\in N}(\frac{(x_i)^2}{n}-\frac{2x_i\sum x}{n^2})$$
设k为$x$的平方和，得到
$$\frac{(\sum x)^2}{n^2}+(\frac{k}{n}-\frac{2(\sum x)^2}{n^2})$$
去括号+合并同类项，得
$$\frac{k}{n}-\frac{(\sum x)^2}{n^2}$$
数据范围是$n\leq 100000$所以我们可以用分块分别维护区间平方和及区间和，然后回答即可。

***

#### $Code$
```cpp
#include<cmath>
#include<cstdio>
#include<cctype>
#include<iostream>
#include<algorithm>
using namespace std;typedef long long LL;
int L[401],R[401],n,q,l,r,opt,x,pos[100010],t;
double d,a[100010],sum[401],add[401],sumaf[401];
inline long long read()
{
    char c;int d=1;long long f=0;
    while(c=getchar(),!isdigit(c))if(c==45)d=-1;f=(f<<3)+(f<<1)+c-48;
    while(c=getchar(),isdigit(c)) f=(f<<3)+(f<<1)+c-48;
    return d*f;
}
inline void write(register long long x)
{
    if(x<0)putchar(45),x=-x;
    if(x>9)write(x/10);
    putchar(x%10+48);
    return;
}
double sqr(double x){return x*x;}
void Add(register int l,register int r,double x)//区间修改
{
    int pl=pos[l],pr=pos[r];
    if(pl==pr)//同块内暴力改
    {
        for(register int i=l;i<=r;i++) sumaf[pl]+=2*a[i]*x+sqr(x),a[i]+=x,sum[pl]+=x;
        return;
    }
    for(register int i=l;i<=R[pl];i++) sumaf[pl]+=2*a[i]*x+sqr(x),a[i]+=x,sum[pl]+=x;
    for(register int i=L[pr];i<=r;i++) sumaf[pr]+=2*a[i]*x+sqr(x),a[i]+=x,sum[pr]+=x;//两边暴力改
    for(register int i=pl+1;i<pr;i++) add[i]+=x;//中间+lazy
    return;
}
double ask(register int l,register int r)//查询区间和/区间长度=平均数
{
    int pl=pos[l],pr=pos[r],len=r-l+1;
    double ans=0;
    if(pl==pr)//同块内暴力求
    {
        for(register int i=l;i<=r;i++) ans+=a[i]+add[pl];
        return ans/1.0/len;
    }
    else
    {
        for(register int i=l;i<=R[pl];i++) ans+=a[i]+add[pl];
        for(register int i=L[pr];i<=r;i++) ans+=a[i]+add[pr];//两边暴力改
        for(register int i=pl+1;i<pr;i++) ans+=sum[i]+add[i]*t;//中间+lazy和sum
        return ans/1.0/len;
    }
}
double askfc(register int l,register int r)
{
    int len=r-l+1,pl=pos[l],pr=pos[r];double ave=0,ans=0,answer=0;
    if(pl==pr)//同一块暴力改
    {
        for(register int i=l;i<=r;i++) ave+=a[i]+add[pl],ans+=sqr(a[i]+add[pl]);
        return ans/len-sqr(ave/len);
    }
    for(register int i=l;i<=R[pl];i++) ave+=a[i]+add[pl],ans+=sqr(a[i]+add[pl]);
    for(register int i=L[pr];i<=r;i++) ave+=a[i]+add[pr],ans+=sqr(a[i]+add[pr]);//两边暴力改
    for(register int i=pl+1;i<pr;i++) ave+=sum[i]+add[i]*t,ans+=sumaf[i]+2*sum[i]*add[i]+t*sqr(add[i]);//中间lazy+sum改
    answer=ans/len-sqr(ave/len);
    return answer;
}
signed main()
{
	freopen("1.txt","r",stdin);
    n=read();q=read();t=(int)sqrt(n)+1;
    for(register int i=1;i<=n;i++) scanf("%lf",a+i);
    for(register int i=1;i<=t;i++) 
    {
        L[i]=R[i-1]+1,R[i]=min(R[i-1]+t,n);
        for(register int j=L[i];j<=R[i];j++) pos[j]=i,sum[i]+=a[j],sumaf[i]+=sqr(a[j]);//预处理
    }
    while(q--)
    {
        opt=read();
        if(opt==1)
        {
            l=read();r=read();scanf("%lf",&d);
            Add(l,r,d);
        }
        if(opt==2)
        {
            l=read();r=read();
            printf("%.4lf\n",ask(l,r));
        }
        if(opt==3)
        {
            l=read();r=read();
            printf("%.4lf\n",askfc(l,r));
        }
    }
}
```

---

## 作者：IzumiSagiri (赞：15)



我们可以设   
$ sum1[n]=a[1]+a[2]+\cdots+a[n] $    
$ sum2[n]=a[1]^{2}+a[2]^{2}+\cdots+a[n]^{2} $

那么我们就可以表示出方差了

#### 方差公式展开：

$ \frac {\sum_{i=1}^{n} (a[i]-\overline{a})^{2} } {n}  $

$ = \frac {(a[1]-\overline{a})^{2} + (a[2]-\overline{a})^{2} + \cdots +(a[n]-\overline{a})^{2} } {n} $

$ = \frac{a[1]^{2} + a[2]^{2} + \cdots +a[n]^{2}- 2 \overline{a}(a[1] + a[2] + \cdots +a[n] ) +n\overline{a}^{2} }{n} $

$ = \frac{a[1]^{2} + a[2]^{2} + \cdots +a[n]^{2} }{n} - 2\overline{a}  \frac{a[1]+a[2]+\cdots+a[n]}{n}+\overline{a}^{2} $

$ = \frac{a[1]^{2} + a[2]^{2} + \cdots +a[n]^{2} }{n} - 2\overline{a}^{2}+\overline{a}^{2} $

$ = \frac{a[1]^{2} + a[2]^{2} + \cdots +a[n]^{2} }{n} - \overline{a}^{2} $

$ = \frac{sum2[n]}{n} - \overline{a}^{2} $

至于修改也很简单了

#### 区间加展开：

$ \sum_{i=1}^{n} (a[i]+x)^{2}  $

$ = (a[1]+x)^{2} + (a[2]+x)^{2} + \cdots +(a[n]+x)^{2}  $

$ = a[1]^{2} + a[2]^{2} + \cdots +a[n]^{2}+ 2 x(a[1] + a[2] + \cdots +a[n] ) +nx^{2}  $

$ = sum2[n]+ 2 x $ $sum1[n] +nx^{2}  $

于是就可以用带lazy的线段树来解决

###### *注意：优先级应该是要先处理sum2，再处理sum1

丑陋的代码如下:
```
#include<cstdio>

#define ll long long
#define lc(x) (x<<1)
#define rc(x) (x<<1|1)

const ll maxn=100000;

double sum1[(maxn<<2)+5],sum2[(maxn)<<2+5];
double lazy[(maxn<<2)+5];

inline void pushup(ll v){
    sum1[v]=sum1[lc(v)]+sum1[rc(v)];
    sum2[v]=sum2[lc(v)]+sum2[rc(v)];
}

inline void pushdown(ll v,ll l,ll r){
    if(lazy[v]){
        ll mid=l+r>>1;
        lazy[lc(v)]+=lazy[v];
        lazy[rc(v)]+=lazy[v];
        sum2[lc(v)]+=2.0*lazy[v]*sum1[lc(v)]+(mid-l+1)*lazy[v]*lazy[v];
        sum2[rc(v)]+=2.0*lazy[v]*sum1[rc(v)]+(r-mid)*lazy[v]*lazy[v];
        sum1[lc(v)]+=lazy[v]*(mid-l+1);
        sum1[rc(v)]+=lazy[v]*(r-mid);
        lazy[v]=0;
    }
}

void update(ll v,ll l,ll r,ll left,ll right,double add){
    if(left<=l&&r<=right){lazy[v]+=add,sum2[v]+=2.0*sum1[v]*add+(r-l+1)*add*add,sum1[v]+=add*(r-l+1);return;}
    ll mid=l+r>>1;
    pushdown(v,l,r);
    if(left<=mid)update(lc(v),l,mid,left,right,add);
    if(right>mid)update(rc(v),mid+1,r,left,right,add);
    pushup(v);
}

double query_a(ll v,ll l,ll r,ll left,ll right){
    if(left<=l&&r<=right){return sum1[v];}
    ll mid=l+r>>1;double ans=0;
    pushdown(v,l,r);
    if(left<=mid)ans+=query_a(lc(v),l,mid,left,right);
    if(right>mid)ans+=query_a(rc(v),mid+1,r,left,right);
    return ans;
}

double query_b(ll v,ll l,ll r,ll left,ll right){
    if(left<=l&&r<=right){return sum2[v];}
    ll mid=l+r>>1;double ans=0;
    pushdown(v,l,r);
    if(left<=mid)ans+=query_b(lc(v),l,mid,left,right);
    if(right>mid)ans+=query_b(rc(v),mid+1,r,left,right);
    return ans;
}

ll n,m;
int main(){
    scanf("%lld%lld",&n,&m);
    for(ll i=1;i<=n;i++){
        double p;scanf("%lf",&p);
        update(1,1,n,i,i,p);
    }
    for(ll i=1;i<=m;i++){
        ll op,l,r;scanf("%lld%lld%lld",&op,&l,&r);
        if(op==1){
            double k;scanf("%lf",&k);
            update(1,1,n,l,r,k);
        }
        if(op==2){
            double ans=(double)query_a(1,1,n,l,r)/(r-l+1);
            printf("%.4lf\n",(double)ans);
        }
        if(op==3){
            double ans=(double)query_a(1,1,n,l,r)/(r-l+1);
            double ans1=(double)query_b(1,1,n,l,r)/(r-l+1);
            double ans2=(double)ans1-(double)ans*ans;
            printf("%.4lf\n",(double)ans2);
        }
    }
    return 0;
}
```

---

## 作者：天命之路 (赞：11)

看了各大题解，发现对于每个区间，都要维护五个值：

区间平方和，区间和，区间平均，区间方差，区间长度

现在，让我们迎接不一样的线段树维护法！

先提五个问题：

1. 要维护什么信息？

	区间和，区间平均，区间方差，区间长度
2. 需要什么标记？

	区间加标记
    
3. 如何叠加标记？

	在原有标记的基础上加上新标记
    
4. 如何对区间进行整体修改？
	
    设整个区间中的每个数加上 $v$
    
    则区间和加上区间长度乘 $v$
    
	我们注意到，每个数加上 $v$ 平均数也加上 $v$（加上的 $len$ 个 v 再除以 $len$，相当于加 $v$ ($len$ 表示区间长度）
    
    而方差不会改变。（因为作差后 $v$ 被消掉）
    
5. 如何进行区间合并？

	这是本题的重点。
    
    区间和以及区间长度较好维护，直接加即可。
    
    区间平均数则可以利用已得到的结果，用和除以长度。
    
    区间方差是最难的。
    
    设左儿子区间为 $a[1],a[2],\dots a[n]$，这些数的平均数为 $aver_a$，方差为 $fang_a$，和为 $sum_a$
    
    右儿子区间为 $b[1],b[2],\dots b[m]$，这些数的平均数为 $aver_b$，方差为 $fang_b$，和为 $sum_b$
    
    合并后的区间平均数为 $aver$
    
    则方差为 $\frac{\sum_{j=1}^n (a[j]-aver)^2+\sum_{j=1}^m (b[j]-aver)^2}{n+m}$
    
    我们可以考虑从$\sum (a[j]-aver_a)^2$ 到 $\sum (a[j]-aver)^2$ 产生的变化，从而将加号的左右两部分都变为可以用$\Theta(1)$ 的时间得到的结果。
    
    设$decrease=aver_a-aver$
    
    则 $\sum (a[j]-aver)^2 = \sum (a[j]-aver_a+decrease)^2$
    
    $=\sum((a[j]-aver_a)^2+2 \times (a[j]-aver_a) \times decrease +decrease^2)$
    
    $=n \times fang_a + \sum (2 \times a[j] \times decrease-2 \times aver_a \times decrease+decrease^2)$
    
    $=n\times fang_a+sum_a\times 2\times decrease-2\times aver_a \times n \times decrease+n\times decrease^2$
    
    是不是很复杂？不急，我们发现：$sum_a=aver_a \times n$
    
    于是上式成功地被化简为 $n\times fang_a+n\times decrease^2$
    
    右儿子区间可进行类似变换。
    
    于是我们就求出了区间方差。
    
    
完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
/*
sigma (a[i]-(a-increase))^2  //推导过程，其中的increase 就是题解中的 decrease 
sigma (a[i]-a+increase)^2
sigma (a[i]-a)^2+increase^2+2*(a[i]-a)*increase
 fang*len+ sigma increase^2+2*a[i]*increase-2*a*increase
fang*len+2*sum*increase+len*increase^2 -2*a*len*increase
*/
typedef double ld;
const int N=1e5+5; 
struct node{  //表示区间的结构体 
	ld tag,sum,fang,l,r,aver,len;  //fang 表示方差 
	node() { tag=sum=fang=l=r=0;}
}tr[N<<2];
node none;   //利用构造函数构造一个空区间 
ld Plus(node a,ld increase)   //将 sigma (a[j]-aver_a)^2 变为 sigma (a[j]-aver)^2 
{
	
	return a.fang*a.len+a.len*increase*increase;
}
node operator +(const node &a,const node &b)  //区间合并 
{
	node c;
	c.l=a.l;
	c.r=b.r;  //区间左右端点
			  //从这里可以看出，这个方法并不满足交换律，打代码时千万别写反 
	c.sum=a.sum+b.sum;
	c.len=a.len+b.len;    //区间和以及区间长度 
	c.aver=c.sum/c.len;   //区间平均 
	ld increase1=a.aver-c.aver,increase2=b.aver-c.aver;  //左右两边的decrease 
	c.fang=Plus(a,increase1)+Plus(b,increase2);  //合并方差 
	c.fang/=c.len;   //记得除 
	c.tag=0;
	return c;
}
int n,m;
ld val[N];
#define ls (k<<1)
#define rs (k<<1|1)   //宏定义使码风更加简洁 
void build(int k,int l,int r)  //建树 
{
	tr[k].l=l;
	tr[k].r=r;
	if(l==r)
	{
		tr[k].len=1;
		tr[k].sum=tr[k].aver=val[l];   //初始的平均值当然是自己了 
		tr[k].tag=0;
		tr[k].fang=0;  //方差显然为0 
		return;
	}
	int mid=l+r>>1;
	build(ls,l,mid);
	build(rs,mid+1,r);
	tr[k]=tr[ls]+tr[rs];  //区间合并 
}
inline void Add(int k,ld v)  //区间整体加，方差不变 
{
	tr[k].tag+=v;  //叠加标记 
	tr[k].sum+=tr[k].len*v;
	tr[k].aver+=v;    //平均数加上v
}
inline void pushdown(int k)  //下传标记 
{
	if(tr[k].tag==0) return;
	Add(ls,tr[k].tag);
	Add(rs,tr[k].tag);
	tr[k].tag=0;
}
inline void modify(int k,int x,int y,ld v)  //区间修改 
{
	if(tr[k].l>y||tr[k].r<x) return;
	if(x<=tr[k].l&&tr[k].r<=y)
	return Add(k,v);
	pushdown(k);   //记得下传标记 
	modify(ls,x,y,v);
	modify(rs,x,y,v);
	tr[k]=tr[ls]+tr[rs];
}
inline node query(int k,int x,int y)
{
	if(tr[k].l>y||tr[k].r<x) return none;  //返回一个空区间 
	if(x<=tr[k].l&&tr[k].r<=y)
	return tr[k];  //返回维护好的区间 
	pushdown(k);
	return query(ls,x,y)+query(rs,x,y);   //合并结果 
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%lf",&val[i]);
	build(1,1,n);
	for(int i=1;i<=m;i++)
	{
		int opt,x,y;ld v;
		scanf("%d",&opt);
		if(opt==1)   //最好不要用 switch,有点危险 
		{
			scanf("%d%d%lf",&x,&y,&v);
			modify(1,x,y,v);
		}
		if(opt==2)
		scanf("%d%d",&x,&y),printf("%.4lf\n",query(1,x,y).aver);
		if(opt==3) scanf("%d%d",&x,&y),printf("%.4lf\n",query(1,x,y).fang);
	}
}
```
    

---

## 作者：流逝丶 (赞：11)

**线段树维护平均数和方差**

平均数很好搞，维护区间和，然后除以区间长度就行了

那方差如何维护呢？

先得推一波式子

![](https://cdn.luogu.com.cn/upload/image_hosting/xtzvd8lw.png)

然后发现我们维护一个区间和还有一个区间平方和就可以了

修改的时候先修改区间平方和，再修改区间和。

特别注意的：题目中说是实数，所以原序列中的数，和区间加的数都为小数，都要开double储存

printf输出double型为%f。

这题也就没什么了

附上代码

```cpp
#include<iostream>
#include<cstdio>
#define R register
#define LL long long
#define lson k<<1,l,mid    //日常为了省码量和好看
#define rson k<<1|1,mid+1,r
#define mid ((l+r)>>1)
#define ls k<<1
#define rs k<<1|1
#define sum(rt) tr[rt].sum
#define pf(rt) tr[rt].pf
#define laz(rt) tr[rt].laz
using namespace std;
const int maxn=100005;
int n,m;
double a[maxn];
struct node{
	double sum,pf,laz;
}tr[maxn<<2];
inline int read(){
    R int s=0,w=1;
    R char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}
    return s*w;
}
inline void update(R int k){
	sum(k)=sum(ls)+sum(rs);
	pf(k)=pf(ls)+pf(rs);
}
void build(R int k,R int l,R int r){
	if(l==r){
		sum(k)=a[l];
		pf(k)=a[l]*a[l];
		return ;
	}
	build(lson);build(rson);
	update(k);
}
inline void down(R int k,R int l,R int r){
	pf(ls)=pf(ls)+2*laz(k)*sum(ls)+(mid-l+1)*laz(k)*laz(k);
	sum(ls)=sum(ls)+laz(k)*(mid-l+1);
	laz(ls)+=laz(k);
	pf(rs)=pf(rs)+2*laz(k)*sum(rs)+(r-mid)*laz(k)*laz(k);
	sum(rs)=sum(rs)+laz(k)*(r-mid);
	laz(rs)+=laz(k);
	laz(k)=0;
}
void change(R int k,R int l,R int r,R int x,R int y,double z){
	if(l==x&&y==r){
		pf(k)=pf(k)+2*z*sum(k)+(r-l+1)*z*z;
		sum(k)=sum(k)+z*(r-l+1);
		laz(k)+=z;
		return ;
	}
	if(laz(k))down(k,l,r);
	if(y<=mid)change(lson,x,y,z);
	else if(x>mid)change(rson,x,y,z);
	else change(lson,x,mid,z),change(rson,mid+1,y,z);
	update(k);
}
double ask1(R int k,R int l,R int r,R int x,R int y){
	if(l==x&&y==r){
		return sum(k);
	}
	if(laz(k))down(k,l,r);
	if(y<=mid)return ask1(lson,x,y);
	else if(x>mid)return ask1(rson,x,y);
	else return ask1(lson,x,mid)+ask1(rson,mid+1,y);
}
double ask2(R int k,R int l,R int r,R int x,R int y){
	if(l==x&&y==r){
		return pf(k);
	}
	if(laz(k))down(k,l,r);
	if(y<=mid)return ask2(lson,x,y);
	else if(x>mid)return ask2(rson,x,y);
	else return ask2(lson,x,mid)+ask2(rson,mid+1,y);
}
int main(){
	n=read();m=read();
	for(R int i=1;i<=n;++i)
		scanf("%lf",&a[i]);
	build(1,1,n);
	R int opt,x,y;
	double tot,ans,ans2,z;
	while(m--){
		opt=read();
		if(opt==1){
			x=read();y=read();
			scanf("%lf",&z);
			change(1,1,n,x,y,z);
		}
		else if(opt==2){
			x=read();y=read();
			tot=ask1(1,1,n,x,y)/(y-x+1);
			printf("%.4f\n",tot);
		}
		else if(opt==3){
			x=read();y=read();
			ans=ask1(1,1,n,x,y)/(y-x+1);
			ans2=ask2(1,1,n,x,y);
			tot=ans2/(y-x+1)-ans*ans;
			printf("%.4f\n",tot);
		}
	}
	return 0;
}
```


---

## 作者：高天 (赞：8)

```cpp
#include<iostream>
#include<iomanip>
using namespace std;
const int N = 100005, INF = 0x7fffffff;
double a[N], sum[4*N], sum2[4*N];
double tag[4*N];

void pushup(int k) {
	sum[k] = sum[k * 2] + sum[k * 2 + 1]; //区间和
	sum2[k] = sum2[k * 2] + sum2[k * 2 + 1]; //区间平方和
	return ;
}

void build(int k, int lt, int rt) { //第k个结点， lt rt为要询问的区间范围
	if(lt == rt) {
		sum[k] = a[lt]; //a为原始数组，sum[k]为第k个结点的区间和
		sum2[k] = a[lt] * a[lt]; //平方
		return ;
	}
	int mid = lt + (rt - lt) / 2; // mid = (lt + rt) >> 1
	build(k * 2, lt, mid);
	build(k * 2 + 1, mid + 1, rt);
	pushup(k);
	return ;
}

void Add(int k, int lt, int rt, double val) { //打懒标记
	tag[k] += val; //标记K结点对应的区间要加的值
	sum2[k] += 2 * val * sum[k] + val * val * (rt - lt + 1); //因为平方和要用到 区间和， 所以要先更新！
	sum[k] += (rt - lt + 1) * val;
	return ;
}

void pushdown(int k, int lt, int rt) {
	if(tag[k] == 0)
		return ;
	int mid = lt + (rt - lt) / 2;
	Add(k*2, lt, mid, tag[k]);
	Add(k*2+1, mid+1, rt, tag[k]);
	tag[k] = 0; //将标记传给子节点后，父节点的标记要清零，否则会加重复
	return ;
}

//在qx, qy区间每个数加上val
void modify(int k, int lt, int rt, int qx, int qy, double val) {
	if(lt > qy || rt < qx)
		return ;
	else if(lt >= qx && rt <= qy) {
		Add(k, lt, rt, val);
		return ;
	}
	int mid = lt + (rt - lt) / 2;
	pushdown(k, lt, rt);
	modify(k * 2, lt, mid, qx, qy, val);
	modify(k * 2 + 1 , mid + 1, rt, qx, qy, val);
	pushup(k);
	return ;
}

double query(int k, int lt, int rt, int qx, int qy) {
	if(lt > qy || rt < qx)
		return 0;
	else if(lt >= qx && rt <= qy)
		return sum[k];
	int mid = lt + (rt - lt) / 2;
	pushdown(k, lt, rt); //询问时才下传标记，因为需要知道子区间要加的值
	return query(k * 2, lt, mid, qx, qy) + query(k * 2 + 1, mid + 1, rt, qx, qy);
}

double query2(int k, int lt, int rt, int qx, int qy) {
	if(lt > qy || rt < qx)
		return 0;
	else if(lt >= qx && rt <= qy)
		return sum2[k];
	int mid = lt + (rt - lt) / 2;
	pushdown(k, lt, rt); //询问时才下传标记，因为需要知道子区间要加的值
	return query2(k * 2, lt, mid, qx, qy) + query2(k * 2 + 1, mid + 1, rt, qx, qy);
}


int main() {
	int n, m;
	cin >> n >> m;
	for(int i = 1; i <= n; i++) {
		cin >> a[i];
	}
	build(1, 1, n); //建树
	for(int i = 1; i <= m; i++) {
		int option, x, y;
		double v;
		cin >> option;
		if(option == 1) {
			cin >> x >> y >> v;
			modify(1, 1, n, x, y, v);
		} else if(option == 2) {
			cin >> x >> y;
			cout << fixed << setprecision(4) << query(1, 1, n, x, y) / (y-x+1) << "\n";
		} else {
			cin >> x >> y;
			double avg = query(1, 1, n, x, y) / (y-x+1);
			cout << fixed << setprecision(4) << -avg * avg + query2(1, 1, n, x, y) / (y-x+1) << "\n";
		}
	}
	return 0;
}

```


---

## 作者：JBLee (赞：5)

偶然在讨论里看到这道题，就进来了。

看了一下发现是求区间的平均数及方差，所以肯定是要用线段树来维护的。区间平均数好求，直接求一遍区间和再除以区间长度就是了。

关键是区间方差的问题，做这题的时候还忘了方差是什么东西，真的sb，初中数学白学了。其实这样也比较可以。

手推一下就能够比较容易地发现，维护方差，还需要维护区间平方和，首先求出当前区间的平均数，再操作一番。

具体如下，非常简单，用HF的话来说就是小学水平。

![](https://cdn.luogu.com.cn/upload/pic/73196.png )

就是你把那求方差的过程看成整个区间都减一个数，然后结果就是**原来区间的平方和-2*平均数*区间和+区间长度*平均数的平方**，同样，区间修改维护平方和也是这样。那么求方差的时候，就要先让整个区间减去平均数，求一遍**平方和/区间长度**，最后加上原来减去的平均数值，以便区间中的数值不会改变。

还有一个就是我们下放标记的时候必须先修改平方和，因为它要用到之前区间和的值，顺序还是要有的，不能xjb乱放。

$Talk $ $is$  $cheap$  代码双手奉上。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e6+7;
int n,m;
double a[maxn];
int opt,l,r;
double v;
struct node{
	int l,r;
	double lazy;
	double sum1,sum2;
}tree[maxn*4];
void build(int now,int l,int r){
	tree[now].l=l,tree[now].r=r;
	if(l==r){
		tree[now].sum1=a[l];
		tree[now].sum2=a[l]*a[l];
		return;
	}
	int mid=(l+r)>>1;
	build(now<<1,l,mid);
	build(now<<1|1,mid+1,r);
	tree[now].sum1=tree[now<<1].sum1+tree[now<<1|1].sum1;
	tree[now].sum2=tree[now<<1].sum2+tree[now<<1|1].sum2;
}
void pushdown(int now){
	if(tree[now].lazy){
		tree[now<<1].sum2+=(tree[now<<1].r-tree[now<<1].l+1)*(tree[now].lazy)*(tree[now].lazy)+2*(tree[now].lazy)*(tree[now<<1].sum1);
		tree[now<<1|1].sum2+=(tree[now<<1|1].r-tree[now<<1|1].l+1)*(tree[now].lazy)*(tree[now].lazy)+2*(tree[now].lazy)*(tree[now<<1|1].sum1);
		tree[now<<1].sum1+=(tree[now<<1].r-tree[now<<1].l+1)*tree[now].lazy;
		tree[now<<1|1].sum1+=(tree[now<<1|1].r-tree[now<<1|1].l+1)*tree[now].lazy;
		tree[now<<1].lazy+=tree[now].lazy;
		tree[now<<1|1].lazy+=tree[now].lazy;
		tree[now].lazy=0;
	}
}
void update(int now,int l,int r,double v){
	if(tree[now].l>=l&&tree[now].r<=r){
		tree[now].sum2+=(tree[now].r-tree[now].l+1)*v*v+2*v*(tree[now].sum1);
		tree[now].sum1+=(tree[now].r-tree[now].l+1)*v;
		tree[now].lazy+=v;
		return;
	}
	pushdown(now);
	int mid=(tree[now].l+tree[now].r)>>1;
	if(l<=mid) update(now<<1,l,r,v);
	if(r>mid) update(now<<1|1,l,r,v);
	tree[now].sum1=tree[now<<1].sum1+tree[now<<1|1].sum1;
	tree[now].sum2=tree[now<<1].sum2+tree[now<<1|1].sum2;
}
double query1(int now,int l,int r){
	if(tree[now].l>=l&&tree[now].r<=r) return tree[now].sum1;
	pushdown(now);
	double val=0;
	int mid=(tree[now].l+tree[now].r)>>1;
	if(l<=mid) val+=query1(now<<1,l,r);
	if(r>mid) val+=query1(now<<1|1,l,r);
	return val;
}
double query2(int now,int l,int r){
	if(tree[now].l>=l&&tree[now].r<=r) return tree[now].sum2;
	pushdown(now);
	double val=0;
	int mid=(tree[now].l+tree[now].r)>>1;
	if(l<=mid) val+=query2(now<<1,l,r);
	if(r>mid) val+=query2(now<<1|1,l,r);
	return val;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%lf",&a[i]);
	build(1,1,n);
	for(int i=1;i<=m;i++){
		scanf("%d",&opt);
		if(opt==1){
			scanf("%d%d%lf",&l,&r,&v);
			update(1,l,r,v);
		}
		if(opt==2){
			scanf("%d%d",&l,&r);
			printf("%.4lf\n",query1(1,l,r)/(r-l+1));
		}
		if(opt==3){
			scanf("%d%d",&l,&r);
			double change=query1(1,l,r)/(r-l+1);
			update(1,l,r,-change);
			printf("%.4lf\n",query2(1,l,r)/(r-l+1));
			update(1,l,r,change);
		}
	}
	return 0;
}
```



---

## 作者：GaryZhong (赞：5)

看到区间操作，毫无疑问想到线段树。

对于操作1，懒标记就可以做到。

对于操作2，求和然后除以区间长度就可以做到。

对于操作3，尝试展开方差的表达式：

先不管题目所给的$\frac{1}{n}$

$$\sum_{i=1}^{n}(A_i-\overline A)^2=\sum_{i=1}^{n} {A_i}^2-2Ai+{\overline A}^2$$

观察式子，发现共有n个$\overline A$，那么可以先将$n\overline A$计入答案，然后剩余的答案就是$$\sum_{i=1}^{n}{A_i}^2+\sum_{i=1}^{n}-2A_i$$

也就是区间的平方和加上区间的和乘以-2。

这样求方差的问题就解决了。


那么下传标记时呢？

设当前和的标记为$inc[rt]$，显然更新$sum[rt]+=inc[rt]*(r-l+1)$，$sqrsum[rt]$即平方和如何更新呢？

设原来的平方和为$$\sum_{i=l}^{r}{A_i}^2$$，那么现在的平方和即为：$$\sum_{i=l}^{r}(A_i+k)^2$$，展开得：$$\sum_{i=l}^{r}{A_i}^2+2kA_i+k^2$$也即是原来的平方和sqrsum[rt]加上k与sum[rt]的乘积的两倍，再加上(r-l+1)\*k^2，这样就解决了sqrsum下传的问题。


代码：

```cpp
#include <cstdio>
#include <cstring>

const int N = 100007;
int n, q, d, x, y;
double t;
struct SegmentTree
{
    double sum[N * 4], sqr_sum[N * 4], inc[N * 4]; //sum为各数之和，sqr_sum为各数平方之和，inc为增加的数

    void down(int rt, int l, int r) //标记下传
    {
        if (inc[rt] == 0.0) return; //等于0时无需下传
        if (l != r) //非叶子节点
        {
            inc[rt << 1] += inc[rt]; //下传标记
            inc[rt << 1 | 1] += inc[rt]; //下传标记
        }
        sqr_sum[rt] += 2 * inc[rt] * sum[rt] + inc[rt] * inc[rt] * (r - l + 1); //注意顺序，更新sqr_sum需要原来的sum，因此先更新sqr_sum，我原来就是因为这个WA的
        sum[rt] += inc[rt] * (r - l + 1); //更新sum
        inc[rt] = 0.0; //清空标记
    }

    void _add(int rt, int l, int r, int po, double val)
    {
        if (l == r) //叶子节点
        {
            sum[rt] = val;
            sqr_sum[rt] = val * val;
            return;
        }
        int mid = (l + r) >> 1;
        if (po <= mid)
            _add(rt << 1, l, mid, po, val);
        if (mid + 1 <= po)
            _add(rt << 1 | 1, mid + 1, r, po, val);
        sum[rt] = sum[rt << 1] + sum[rt << 1 | 1];
        sqr_sum[rt] = sqr_sum[rt << 1] + sqr_sum[rt << 1 | 1];
    }
    inline void add(int po, double val) { _add(1, 1, n, po, val); } //为了方便调用打的函数

    double _qry_sum(int rt, int l, int r, int ql, int qr) //区间求和
    {
        down(rt, l, r);
        double ret = 0.0;
        if (ql <= l && qr >= r)
            return sum[rt];
        int mid = (l + r) >> 1;
        if (ql <= mid)
            ret += _qry_sum(rt << 1, l, mid, ql, qr);
        if (mid + 1 <= qr)
            ret += _qry_sum(rt << 1 | 1, mid + 1, r, ql, qr);
        return ret;
    }
    inline double qry_sum(int ql, int qr) { return _qry_sum(1, 1, n, ql, qr); }

    double _qry_sqr_sum(int rt, int l, int r, int ql, int qr) //区间求平方和
    {
        down(rt, l, r);
        double ret = 0.0;
        if (ql <= l && qr >= r)
            return sqr_sum[rt];
        int mid = (l + r) >> 1;
        if (ql <= mid)
            ret += _qry_sqr_sum(rt << 1, l, mid, ql, qr);
        if (mid + 1 <= qr)
            ret += _qry_sqr_sum(rt << 1 | 1, mid + 1, r, ql, qr);
        return ret;
    }
    inline double qry_sqr_sum(int ql, int qr) { return _qry_sqr_sum(1, 1, n, ql, qr); }
    
    void _change(int rt, int l, int r, int ql, int qr, double val) //区间修改
    {
        down(rt, l, r);
        if (ql <= l && qr >= r)
        {
            inc[rt] += val;
            return;
        }
        int mid = (l + r) >> 1;
        if (ql <= mid)
            _change(rt << 1, l, mid, ql, qr, val);
        if (mid + 1 <= qr)
            _change(rt << 1 | 1, mid + 1, r, ql, qr, val);
        down(rt << 1, l, mid);
        down(rt << 1 | 1, mid + 1, r);
        sum[rt] = sum[rt << 1] + sum[rt << 1 | 1];
        sqr_sum[rt] = sqr_sum[rt << 1] + sqr_sum[rt << 1 | 1];
    }
    inline void change(int ql, int qr, double val) { _change(1, 1, n, ql, qr, val); }
} ST;

int main()
{
    scanf("%d%d", &n, &q);
    for (int i = 1; i <= n; i++)
    {
        scanf("%lf", &t);
        ST.add(i, t);
    }
    while (q--)
    {
        scanf("%d%d%d", &d, &x, &y);
        if (d == 1)
        {
            scanf("%lf", &t);
            ST.change(x, y, t);
        }
        else if (d == 2)
        {
            double ans = ST.qry_sum(x, y) / (y - x + 1); //求和并除以长度
            printf("%.4lf\n", ans);
        }
        else if (d == 3)
        {
            double ave = ST.qry_sum(x, y) / (y - x + 1),
            ans = (ST.qry_sqr_sum(x, y)
                   - 2 * ave * ST.qry_sum(x, y)
                   + (y - x + 1) * ave * ave)
                   / (y - x + 1); //这句有点长，细心看，对照题解中所拆的公式
            printf("%.4lf\n", ans);
        }
    }
    return 0;
}
```

---

## 作者：Treaker (赞：4)

$$\color{cornflowerblue}{\mathcal{Treaker}}$$
# 线段树 + 数学

这道题如果不考虑操作三的话，~~那这题还有意义吗~~，很简单，维护一个区间和即可，打一个区间标记即可。

那么考虑方差怎么维护。直接维护？好像不太好维护。。。~~别问我怎么知道的~~

**肯定要推式子啦**

考虑：方差的话，我们知道$l$和$r$,就先不考虑除以区间长度(可以轻易求出)这一步。那么剩下：
$$\sum_{i = l}^r(A_i - \overline{A})^2$$
展开的话就是：
$$\sum_{i = l}^rA_i^2-2A_i\overline{A}+\overline{A}^2$$
$$\sum_{i = l}^rA_i^2-2\overline{A}\sum_{i = l}^rA_i+\overline{A}^2$$

$\overline{A}^2$可以通过区间和来求出。$\sum_{i = l}^r$就是区间和。
只差一个$\sum_{i = l}^rA_i^2$，同样通过线段树来维护一下就好了。

献上~~指针~~代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
inline int read()
{
	int x = 0 , f = 1; char ch = getchar();
	while(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}
	while(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + ch - '0'; ch = getchar();}
	return x * f;
}
int n , m;
struct Segment_Tree
{
	struct node
	{
		node *ls , *rs; int l , r;  double sum , Sum  , tag;
		node(int l,int r) : l(l) , r(r) {ls = rs = NULL; Sum = sum = tag = 0;}
		inline int len() {return r - l + 1;}
		#define len len()
		inline void up() {sum = ls -> sum + rs -> sum; Sum = ls -> Sum + rs -> Sum;}
		inline void down()
		{
			if(tag == 0) return;
			ls -> tag += tag; rs -> tag += tag;
			ls -> Sum += ls -> sum * tag * 2 + tag * tag * ls -> len; rs -> Sum += rs -> sum * tag * 2 + tag * tag * rs -> len;
			ls -> sum += tag * ls -> len; rs -> sum += tag * rs -> len; tag = 0;
		}
	}*root;
	#define mid ((o -> l + o -> r) >> 1)
	void build(node *&o,int l,int r)
	{
		o = new node(l,r); if(l == r) return (void)(scanf("%lf",& o -> sum) , o -> Sum = o -> sum * o -> sum);
		build(o -> ls,l,mid); build(o -> rs,mid + 1,r); o -> up();
	}
	void chenge(node *o,int x,int y,double val)
	{
		if(x <= o -> l && o -> r <= y) return (void)(o -> tag += val , o -> Sum +=  o -> sum * val * 2 + val * val * o -> len , o -> sum += val * o -> len); o -> down();
		if(x <= mid) chenge(o -> ls,x,y,val);
		if(y > mid) chenge(o -> rs,x,y,val); o -> up();
	}
	double query_sum(node *o,int x,int y)
	{
		if(x <= o -> l && o -> r <= y) return o -> sum; double res = 0; o -> down();
		if(x <= mid) res += query_sum(o -> ls,x,y);
		if(y > mid) res += query_sum(o -> rs,x,y);  return res;
	}
	double query_Sum(node *o,int x,int y)
	{
		if(x <= o -> l && o -> r <= y) return o -> Sum; double res = 0; o -> down();
		if(x <= mid) res += query_Sum(o -> ls,x,y);
		if(y > mid) res += query_Sum(o -> rs,x,y); return res;
	}
	inline void LOL()
	{
		n = read(); m = read();
		build(root,1,n);
		for(int i = 1 , opt , l , r;i <= m;i ++)
		{
			opt = read(); l = read(); r = read(); double res;
			if(opt == 1) scanf("%lf",&res) , chenge(root,l,r,res);
			if(opt == 2) printf("%.4f\n",query_sum(root,l,r) / (r - l + 1));
			if(opt == 3) res = query_sum(root,l,r) , printf("%.4f\n",(query_Sum(root,l,r) - 2 * res * res / (r - l + 1) + res / (r - l + 1) * res) / (r - l + 1));
		}
	}
}DNF;
int main(){return DNF.LOL() , 0;}
```


---

## 作者：AC_Automation (赞：4)

### 这道题是一道有一定~~大力推式子~~思考难度的裸线段树题

首先我们将求方差的式子展开($S^2$代表方差，$x_i$代表数列的第i项，$n$代表项数，$\bar{x}$代表数列的平均值)：

### $S^2=\frac{1}{n}\sum_{i=1}^n(x_i-\bar{x})^2$

将每个平方展开，得：

### $S^2=\frac{{\sum_{i=1}^n(x^2)}-{2*\sum_{i=1}^n(x_i*\bar{x})}+n*\bar{x}^2}{n}$

## $S^2=\frac{\sum_{i=1}^n({x_i}^{2})}{n}-\bar{x}^2$

好了，展开完成！

观察算式，我们发现我们只需要维护$\sum_{i=1}^n{x_i}^{2}$和$\sum_{i=1}^nx_i$即可。在查询时我们通过线段树算出$\sum_{i=1}^n{x_i}^{2}$和$\sum_{i=1}^nx_i$，并套方差公式就行了（平均值同理）。

还有一个问题：在打tag的时候，如何快速更新$\sum_{i=1}^n{x_i}^{2}$?

大力推算式（假设增加的数是$x$）：

### $\sum_{i=1}^n{(a_i+x)}^2$

### $=\sum_{i=1}^n{a_i}^2+2*a_i*x+x^2*n$

减去$\sum_{i=1}^n{x_i}^{2}$后：

## $2*(\sum_{i=1}^na_i*x)+x^2*n$

问题解决！

这下就能愉快地用线段树维护了~注意要用double存储~

喜闻乐见的放代码时间：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
#define db double
#define ls (root<<1)
#define rs ((root<<1)+1)
#define mid ((l+r)>>1)//蒟蒻喜欢用宏定义
struct node{
	db sum;
	db pfsum;//平方和
	db tag;
} a[400005];
db data[100005];
inline void pushup(int root){
	a[root].sum=a[ls].sum+a[rs].sum;
	a[root].pfsum=a[ls].pfsum+a[rs].pfsum;
}
void build(int root,int l,int r){
	a[root].tag=0;
	if(l==r){
		a[root].sum=data[l];
		a[root].pfsum=data[l]*data[l];
		return;
	}
	build(ls,l,mid);
	build(rs,mid+1,r);
	pushup(root);
}//没什么好说的
inline void pd(int root,int l,int r){
	if(a[root].tag==0)return;
	a[ls].tag+=a[root].tag;
	a[rs].tag+=a[root].tag;
	a[ls].pfsum+=(2*a[ls].sum*a[root].tag+a[root].tag*a[root].tag*(mid-l+1));
	a[rs].pfsum+=(2*a[rs].sum*a[root].tag+a[root].tag*a[root].tag*(r-mid));
	a[ls].sum+=a[root].tag*(mid-l+1);
	a[rs].sum+=a[root].tag*(r-mid);
	a[root].tag=0;
}//push_down 套公式即可
void add(int root,int l,int r,int ql,int qr,db x){
	if(ql<=l&&qr>=r){
		a[root].tag+=x;
		a[root].pfsum+=(2*a[root].sum*x+x*x*(r-l+1));//这里也是套公式
		a[root].sum+=(r-l+1)*x;
		return;
	}
	if(ql>r||qr<l)
		return;
	pd(root,l,r);
	if(ql<=mid)
		add(ls,l,mid,ql,qr,x);
	if(qr>mid)
		add(rs,mid+1,r,ql,qr,x);
	pushup(root);
	return;
}
db qsum(int root,int l,int r,int ql,int qr){
	if(ql<=l&&qr>=r){
		return a[root].sum;
	}
	if(ql>r||qr<l)
		return 0.0;
	pd(root,l,r);
	db ret=0;
	if(ql<=mid)
		ret+=qsum(ls,l,mid,ql,qr);
	if(qr>mid)
		ret+=qsum(rs,mid+1,r,ql,qr);
	return ret;
}
db qpfsum(int root,int l,int r,int ql,int qr){
	if(ql<=l&&qr>=r){
		return a[root].pfsum;
	}
	if(ql>r||qr<l)
		return 0.0;
	pd(root,l,r);
	db ret=0;
	if(ql<=mid)
		ret+=qpfsum(ls,l,mid,ql,qr);
	if(qr>mid)
		ret+=qpfsum(rs,mid+1,r,ql,qr);
	return ret;
}
int main()
{
	ios::sync_with_stdio(false);
	int n,m,x,y,z;
	db t;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		cin>>data[i];
	build(1,1,n);
	for(int i=0;i<m;i++){
		cin>>x>>y>>z;
		if(x==1){
			cin>>t;
			add(1,1,n,y,z,t);
		}
		else if(x==2)
			printf("%.4lf\n",qsum(1,1,n,y,z)*1.0/(z-y+1.0));//套公式，注意输出格式
		else if(x==3){
			db pj=qsum(1,1,n,y,z)*1.0/(z-y+1.0);
			printf("%.4lf\n",(qpfsum(1,1,n,y,z)*1.0)/(z-y+1.0)-pj*pj);//还是套公式	
		}
	}
	return 0;
}//完结撒花！
```

---

## 作者：ezoixx174 (赞：4)

此题不难，别被吓到

先假装没有区间修改，看线段树怎么做。

我们知道线段树可以求区间和，那先求平均。

记$Sum(l,r)$为$l$到$r$的区间和，$Average(l,r)$为$l$到$r$的平均值，则
$$Average(l,r)=\frac{Sum(l,r)}{r-l+1}$$

线段树求出$Sum(i,j)$即可。

下面考虑方差。

先要知道线段树是可以求区间平方和，转移是一样的。我们记$Sum2(i,j)$为$i$到$j$的平方和。

把方差暴力打开

$$\sigma^2=\frac{1}{n}\sum_{i=1}^n(x_i-\overline x)^2=\frac{1}{n}\sum_{i=1}^n{\overline x^2+x_i^2-2\overline x x_i}$$
$$=\frac{1}{n}(n\overline x^2+\sum_{i=1}^nx_i^2-2\overline x\sum_{i=1}^nx_i)$$
$$=\frac{((r-l+1)\overline x^2+Sum2(l,r)-2\overline xSum(l,r))}{r-l+1}$$

然后就可以用$Sum$和$Sum2$求出方差了。

现在有一个操作就是区间加上一个值$d$，对于$Sum$不用说直接懒标记就可以了，那么$Sum2$呢？

由$Sum2$的定义我们可以求出$Sum2'-Sum2$的值（$Sum2'$表示修改后的$Sum2$）。

$$Sum2'-Sum2=\sum_{i=l}^r(x_i+d)^2-\sum_{i=l}^rx_i^2$$
$$=\sum_{i=l}^r(x_i+d)^2-x_i^2=\sum_{i=l}^rd(2x_i+d)$$
$$=(r-l+1)d^2+2d\sum_{i=l}^rx_i$$
$$=(r-l+1)d^2+2dSum(l,r)$$

这样就可以实现$Sum2$的区间更改。

下面是代码：
```cpp
#include<iostream>
#include<cstdio>

using namespace std;

int N,M,op,x,y;
double sum[400001],sum2[400001],add[400001],a,k;
bool tag[400001];

inline void change(int o,int l,int r,double d){sum2[o]+=d*(d*(r-l+1)+2.*sum[o]),sum[o]+=(r-l+1)*d;}

inline void pushdown(int o,int l,int r){
	tag[o<<1]=tag[o<<1|1]=true,tag[o]=false;
	int m=l+r>>1;change(o<<1,l,m,add[o]),change(o<<1|1,m+1,r,add[o]),add[o<<1]+=add[o],add[o<<1|1]+=add[o],add[o]=0.;
}

void update(int o,int l,int r,int k,double x){
	if(l==r){sum[o]=x,sum2[o]=x*x;return;}
	int m=l+r>>1;if(m>=k)update(o<<1,l,m,k,x);else update(o<<1|1,m+1,r,k,x);
	sum[o]=sum[o<<1]+sum[o<<1|1];
	sum2[o]=sum2[o<<1]+sum2[o<<1|1];
}

void update(int o,int l,int r,int a,int b,double d){
	if(l==a&&r==b){tag[o]=true,add[o]+=d,change(o,l,r,d);return;}
	if(tag[o])pushdown(o,l,r);
	int m=l+r>>1;if(m>=b)update(o<<1,l,m,a,b,d);else if(m<a)update(o<<1|1,m+1,r,a,b,d);else update(o<<1,l,m,a,m,d),update(o<<1|1,m+1,r,m+1,b,d);
	sum[o]=sum[o<<1]+sum[o<<1|1];
	sum2[o]=sum2[o<<1]+sum2[o<<1|1];
}

double query1(int o,int l,int r,int a,int b){
	if(l==a&&r==b)return sum[o];
	if(tag[o])pushdown(o,l,r);
	int m=l+r>>1;
	if(m>=b)return query1(o<<1,l,m,a,b);else if(m<a)return query1(o<<1|1,m+1,r,a,b);else return query1(o<<1,l,m,a,m)+query1(o<<1|1,m+1,r,m+1,b);
}

double query2(int o,int l,int r,int a,int b){
	if(l==a&&r==b)return sum2[o];
	if(tag[o])pushdown(o,l,r);
	int m=l+r>>1;
	if(m>=b)return query2(o<<1,l,m,a,b);else if(m<a)return query2(o<<1|1,m+1,r,a,b);else return query2(o<<1,l,m,a,m)+query2(o<<1|1,m+1,r,m+1,b);
}

void solve1(int x,int y){printf("%.4lf\n",query1(1,1,N,x,y)/(double)(y-x+1));}

void solve2(int x,int y){
	double A=query1(1,1,N,x,y)/(double)(y-x+1),s2=query2(1,1,N,x,y),s=query1(1,1,N,x,y);
	printf("%.4lf\n",(s2+(double)(y-x+1)*A*A-2.*s*A)/(double)(y-x+1));
}

int main(){
	scanf("%d%d",&N,&M);
	for(int i=1;i<=N;++i)scanf("%lf",&a),update(1,1,N,i,a);
	for(int i=1;i<=M;++i){
		scanf("%d%d%d",&op,&x,&y);
		if(op==1)scanf("%lf",&k),update(1,1,N,x,y,k);else if(op==2)solve1(x,y);else solve2(x,y);
	}
}
```

---

## 作者：djy213 (赞：3)

平均数可以用线段树，维护区间和，直接维护平均数也行；


然后对于方差；她有个公式的：


S=[(a-Z)²+(b-Z)²+(c-Z)²+(d-Z)²+(e-Z)²...]/n(Z为平均数)


S=[区间平方和-2\*n\*平均数²+n\*平均数²]/n;


S=[区间平方和-n\*平均数²]/n;


所以维护个平方和就好了；


然后，平方和怎么区间加呢？


她也有个公式:


(a+z)²+(b+z)²+(c+z)²+(d+z)²+(e+z)²（你把她拆开嘛。。）


=以前平方和+（2z\*（Z\*n）+n\*z²）；

然后，这是代码的blog：


http://www.cnblogs.com/nietzsche-oier/p/6218468.html

最后，呃。。。。上个题解也是我交的，容易看出她没写完，所以请看这个


---

## 作者：撤云 (赞：3)

[博客传送门](https://www.cnblogs.com/hbxblog/p/9350649.html)

这道题要求两个值，一个是平均值，一个是方差，平均值很容易，就是区间和/个数就可以了。但是怎么求方差呢？看上去十分困难,不知道如何下手,不知道怎么维护？但是不妨把方差的公式拆开：

&#160;&#160;&#160;&#160;设平均数为k

&#160;&#160;&#160;&#160;则S²=((a1-k)²+(a2-k)²+(a3-k)²+...+(an-k)²)/n(将他拆开)
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; =(a1²+a2²+a3²+...+an²+nk²-2k(a1+a2+a3+...+an)(/n
&#160;&#160;&#160;&#160;∵ (a1+a2+a3+...+an)/n=k
&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;∴ S²=(a1²+a2²+a3²+...+an²)/n-k²

&#160;&#160;&#160;&#160;所以现在显而易见要维护方差只要维护平方的和就可以了
&#160;&#160;&#160;&#160;那么怎么维护平方和呢？

&#160;&#160;&#160;&#160;在拆开一下：

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;设每个数加上了x

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;    (a1+x)²+(a2+x)²+(a3+x)²+...+(an+x)²

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;    =a1²+a2²+a3²+...+an²+nx²+2x(a1+a2+a3+...+an)

&#160;&#160;&#160;&#160;所以现在就很容易了，接下来上代码
```
#include<cstdio>
#include<cstdlib>
#include<iostream>
using namespace std;
struct node {
    double lazy,v,sqr;
} a[400001];
double b[400001];
void pushup(int k) {
    a[k].v=a[k<<1].v+a[k<<1|1].v;
    a[k].sqr=a[k<<1].sqr+a[k<<1|1].sqr;
}
void add(int k,int l,int r,double v) {
    a[k].lazy+=v;
    a[k].sqr+=((r-l+1)*v*v+2*v*a[k].v);
    a[k].v+=(r-l+1)*v;
}
void pushdown(int k,int l,int r) {
    if(a[k].lazy) {
        int mid=(l+r)>>1;
        add(k<<1,l,mid,a[k].lazy);
        add(k<<1|1,mid+1,r,a[k].lazy);
    }
    a[k].lazy=0;
}
void update(int k,int l,int r,int begin,int end,double c) {
    if(r<begin||l>end)
        return ;
    if(l>=begin&&r<=end) {
        add(k,l,r,c);
        return;
    }
    pushdown(k,l,r);
    int mid=(l+r)>>1;
    update(k<<1,l,mid,begin,end,c);
    update(k<<1|1,mid+1,r,begin,end,c);
    pushup(k);
}
double find(int k,int l,int r,int begin,int end) {
    if(r<begin||l>end)
        return 0;
    if(l>=begin&&r<=end)
        return a[k].v;
    pushdown(k,l,r);
    int mid=(l+r)>>1;
    if(end<=mid)
        return find(k<<1,l,mid,begin,end);
    else if(begin>mid)
        return find(k<<1|1,mid+1,r,begin,end);
    else
        return find(k<<1,l,mid,begin,mid)+find(k<<1|1,mid+1,r,mid+1,end);
}
double find1(int k,int l,int r,int begin,int end) {
    if(r<begin||l>end)
        return 0;
    if(l>=begin&&r<=end)
        return a[k].sqr;
    pushdown(k,l,r);
    int mid=(l+r)>>1;
    if(end<=mid)
        return find1(k<<1,l,mid,begin,end);
    else if(begin>mid)
        return find1(k<<1|1,mid+1,r,begin,end);
    else
        return find1(k<<1,l,mid,begin,mid)+find1(k<<1|1,mid+1,r,mid+1,end);
}
void build(int k,int l,int r) {
    a[k].lazy=0;
    if(l==r) {
        a[k].v=b[l];
        a[k].sqr=b[l]*b[l];
        return ;
    }
    int mid=(l+r)>>1;
    build(k<<1,l,mid);
    build(k<<1|1,mid+1,r);
    pushup(k);
}
int main() {
    int n,m,L,x,y;
    double c;
    scanf("%d%d",&n,&m);
    for(int i=1; i<=n; i++)
        scanf("%lf",&b[i]);
    build(1,1,n);
    for(int i=1; i<=m; i++) {
        scanf("%d%d%d",&L,&x,&y);
        if(L==1) {
            scanf("%lf",&c);
            update(1,1,n,x,y,c);
        }
        if(L==2)
            printf("%0.4lf\n",find(1,1,n,x,y)*1.0/(y-x+1));
        if(L==3) {
            double ans=find(1,1,n,x,y)*1.0/(y-x+1);
            ans*=ans;
            printf("%0.4lf\n",(find1(1,1,n,x,y)*1.0/(y-x+1))-ans);
        }
    }
}
```egin,int end,double c) {
    if(r<begin||l>end)
        return ;
    if(l>=begin&&r<=end) {
        add(k,l,r,c);
        return;
    }
    pushdown(k,l,r);
    int mid=(l+r)>>1;
    update(k<<1,l,mid,begin,end,c);
    update(k<<1|1,mid+1,r,begin,end,c);
    pushup(k);
}
double find(int k,int l,int r,int begin,int end) {
    if(r<begin||l>end)
        return 0;
    if(l>=begin&&r<=end)
        return a[k].v;
    pushdown(k,l,r);
    int mid=(l+r)>>1;
    if(end<=mid)
        return find(k<<1,l,mid,begin,end);
    else if(begin>mid)
        return find(k<<1|1,mid+1,r,begin,end);
    else
        return find(k<<1,l,mid,begin,mid)+find(k<<1|1,mid+1,r,mid+1,end);
}
double find1(int k,int l,int r,int begin,int end) {
    if(r<begin||l>end)
        return 0;
    if(l>=begin&&r<=end)
        return a[k].sqr;
    pushdown(k,l,r);
    int mid=(l+r)>>1;
    if(end<=mid)
        return find1(k<<1,l,mid,begin,end);
    else if(begin>mid)
        return find1(k<<1|1,mid+1,r,begin,end);
    else
        return find1(k<<1,l,mid,begin,mid)+find1(k<<1|1,mid+1,r,mid+1,end);
}
void build(int k,int l,int r) {
    a[k].lazy=0;
    if(l==r) {
        a[k].v=b[l];
        a[k].sqr=b[l]*b[l];
        return ;
    }
    int mid=(l+r)>>1;
    build(k<<1,l,mid);
    build(k<<1|1,mid+1,r);
    pushup(k);
}
int main() {
    int n,m,L,x,y;
    double c;
    scanf("%d%d",&n,&m);
    for(int i=1; i<=n; i++)
        scanf("%lf",&b[i]);
    build(1,1,n);
    for(int i=1; i<=m; i++) {
        scanf("%d%d%d",&L,&x,&y);
        if(L==1) {
            scanf("%lf",&c);
            update(1,1,n,x,y,c);
        }
        if(L==2)
            printf("%0.4lf\n",find(1,1,n,x,y)*1.0/(y-x+1));
        if(L==3) {
            double ans=find(1,1,n,x,y)*1.0/(y-x+1);
            ans*=ans;
            printf("%0.4lf\n",(find1(1,1,n,x,y)*1.0/(y-x+1))-ans);
        }
    }
}
```

---

## 作者：Sunqi666 (赞：2)

这是一道看上去很难的题……（至少我开始的时候是这样想的）

实际上，我们只要学好数学，会暴力拆式子，就可以把原来的方差式子变一变

我们设$n=y-x+1$为区间$[x,y]$中数的个数

那么方差公式是
### $$s^{2}=\frac{1}{n}\sum_{i=x}^{y}(A_{i}-\bar{A})^{2}$$
我们拆一下，可以得到
### $$s^{2}=\frac{1}{n}\sum_{i=x}^{y}(A_{i}^{2}-2A_{i}\bar{a}+\bar{A}^{2})$$
展开可得
### $s^{2}=\frac{1}{n}\sum_{i=x}^{y}A_{i}^{2}+\frac{1}{n}\sum_{i=x}^{y}\bar{A}^{2}-\frac{2}{n}\sum_{i=x}^{y}A_{i}\bar{A}$
### $  =\frac{1}{n}\sum_{i=x}^{y}A_{i}^{2}+\bar{A}^{2}-2\bar{A}^{2}$
### $  =\frac{1}{n}\sum_{i=x}^{y}A_{i}^{2}-\frac{1}{n^{2}}\sum_{i=x}^{y}A_{i}$
那么拆到这里，我们都可以看出来了：我们只需要维护区间平方和与区间和即可。

那么，在更新数值之后，区间加法的pushdown我们肯定会写（不然就不会来做这题了），但是区间平方和pushdown怎么写呢？

其实，还是那句话，只要我们会暴力拆就可以咯QwQ（感觉是拆迁大队长）

我们知道：
### $$(A_{i}+k)^{2}=A_{i}^{2}+2A_{i}k+k^{2}$$
于是有
### $$\sum_{i=x}^{y}(A_{i}+k)^{2}=\sum_{i=x}^{y}A_{i}^{2}+2k\sum_{i=x}^{y}A_i+nk^2$$
由于$\sum_{i=x}^yA_i^2$与$\sum_{i=x}^{y}A_i$都是我们已知的，那么我们就可以很愉快地打出pushudown啦OvO

但是有一点要注意，由于区间平方和的修改是基于原来的区间和的，因此在下传的时候我们只能先修改平方和再修改区间和啦（否则先修改区间和的话，平方和公式中区间和就不是原来的了，平方和会变大的呢，也把我坑了一下）

下面上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define pushup(o) t1[o]=t1[o<<1]+t1[o<<1|1],t2[o]=t2[o<<1]+t2[o<<1|1]
ll n,m,x,y;
double t1[400001],tag[400001],t2[400001],k;//t1是和，t2是平方和
void build(ll o,ll l,ll r){
    tag[o]=0;
    if(l==r)scanf("%lf",&t1[o]),t2[o]=t1[o]*t1[o];//初始化
    else{
        ll mid=l+r>>1;
        build(o<<1,l,mid);
        build(o<<1|1,mid+1,r);
        pushup(o);
    }
}
void pushdown(ll o,ll l,ll r){
    if(!tag[o])return;
    ll mid=l+r>>1;
    tag[o<<1]+=tag[o];
    tag[o<<1|1]+=tag[o];
    t2[o<<1]+=2*tag[o]*t1[o<<1]+tag[o]*tag[o]*(mid-l+1),t2[o<<1|1]+=2*tag[o]*t1[o<<1|1]+tag[o]*tag[o]*(r-mid);//下传平方和时要注意区间内数的个数
    t1[o<<1]+=tag[o]*(mid-l+1),t1[o<<1|1]+=tag[o]*(r-mid);
    tag[o]=0;
}
void update(ll o,ll l,ll r){
    if(x<=l&&r<=y){
        tag[o]+=k;
        t2[o]+=2*t1[o]*k+k*k*(r-l+1);//公式推出来的
        t1[o]+=k*(r-l+1);
    }
    else{
        pushdown(o,l,r);
        ll mid=l+r>>1;
        if(x<=mid)update(o<<1,l,mid);
        if(mid<y)update(o<<1|1,mid+1,r);
        pushup(o);
    }
}
double query_sum(ll o,ll l,ll r){//区间和
    if(x<=l&&r<=y)return t1[o];
    pushdown(o,l,r);
    ll mid=l+r>>1;
    double ans=0;
    if(x<=mid)ans=query_sum(o<<1,l,mid);
    if(mid<y)ans+=query_sum(o<<1|1,mid+1,r);
    return ans;
}
double query_sqr(ll o,ll l,ll r){//区间平方和
    if(x<=l&&r<=y)return t2[o];
    pushdown(o,l,r);
    ll mid=l+r>>1;
    double ans=0;
    if(x<=mid)ans=query_sqr(o<<1,l,mid);
    if(mid<y)ans+=query_sqr(o<<1|1,mid+1,r);
    return ans;
}
int main(){
    scanf("%lld%lld",&n,&m);
    build(1,1,n);
    while(m--){
        int s;
        scanf("%d",&s);
        if(s==1){
            scanf("%lld%lld%lf",&x,&y,&k);
            update(1,1,n);
        }
        else if(s==2){
            scanf("%lld%lld",&x,&y);
            printf("%.4lf\n",query_sum(1,1,n)/(y-x+1));
        }
        else{
            scanf("%lld%lld",&x,&y);
            double ss=y-x+1,ans1=query_sum(1,1,n),ans2=query_sqr(1,1,n);//ss是区间数个数
            printf("%.4lf\n",ans2/ss-ans1*ans1/(ss*ss));
        }
    }
}
```
都是手打的（包括公式），如果有不足之处还望多多见谅哦

---

## 作者：Enzymii (赞：2)

(\*@ο@\*) 哇～ 都用的线段树啊。。。

我用分块写的。。。

反正式子拆开就是维护区间和和区间平方和嘛~

大体来说区间上的处理楼下都讲了，~~不过分块怎么说都要暴力一些，当然式子稍微化化就出来了~~

代码和详讲（欢迎各位神犇莅临我的辣鸡blog）↓↓

http://blog.csdn.net/enzymii/article/details/69055585


---

## 作者：吃的 (赞：1)


# P1471 方差

### 题意

给定实数序列，支持三种操作：
- 1 区间加法；
- 2 区间查询平均数；
- 3 区间查询方差。 

***
### 提示

方差公式：对于一个$n$项数列$a$，

$$s^2=\frac1n\sum_{i=1}^n(a_i-\overline a)^2$$
其中$\overline a$表示数列$a$的平均数，$a_i$表示数列$a$的第$i$项。
***

### 思路

看到区间加法，果断想到线段树，~~而不是分块~~。

本题中，线段树需要支持操作$pushup,pushdown,build,update,query$。

现在要考虑如何维护区间的平均数和方差这两个信息。
- 平均数

	由平均数的定义可知，区间$[l,r]$的平均数：
    $$\overline a=\frac1{r-l+1}\sum_{i=l}^ra_i$$
    
    即
    $$\frac{a_l+a_{l+1}+\cdots+a_r}{r-l+1}$$
    
    $\text{区间和}/\text{区间长}$。通过维护区间和即可实现查询平均数。
   
- 方差

	前置知识~~废话~~：
    
    完全平方公式：
    $$(a\pm b)^2=a^2\pm2ab+b^2$$
    
    接下来推导一下方差公式：
    
    对于区间$[l,r]$，其方差：
    
    $$s^2=\displaystyle\frac1{r-l+1}\sum_{i=l}^r(a_i-\overline a)^2$$
    $$\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ =\displaystyle\frac1{r-l+1}\sum_{i=l}^r(a_i^2-2a_i\overline a+\overline a^2)$$
    $$\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ =\displaystyle\frac1{r-l+1}[(a_l^2+a_{l+1}^2+\cdots+a_r^2)$$
    $$\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ -2\overline a(a_l+a_{l+1}+\cdots+a_r)+(r-l+1)\overline a^2]$$
    $$=\frac{a_l^2+a_{l+1}^2+\cdots+a_r^2}{r-l+1}$$
    $$\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ -2\overline a\cdot\frac{a_l+a_{l+1}+\cdots+a_r}{r-l+1}+\overline a^2$$
    $$\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ =\frac{a_l^2+a_{l+1}^2+\cdots+a_r^2}{r-l+1}-2\overline a^2+\overline a^2$$
	$$\ \ \ \ \ \ \ \ =\frac{a_l^2+a_{l+1}^2+\cdots+a_r^2}{r-l+1}-\overline a^2$$
    
    所以方差可以用区间平方和与区间平均数来表示，而平均数用区间和来表示。所以线段树维护的信息就是区间平方和与区间和。这两个信息都可以由左右两个区间合并得来。
***
还有一个问题，区间加法之后，如何维护区间内信息？

先是$update$函数把区间加法转化为若干个$lazy\ tap$，在需要的时候$pushdown$下去。

原区间平方和$sqr=a_l^2+a_{l+1}^2+\cdots+a_r^2$。

令该区间每一个数字加上$k$，则修改后的值：

$\ \ \  \ (a_l+k)^2+(a_{l+1}+k)^2+\cdots+(a_r+k)^2$

$=a_l^2+2a_lk+k^2+a_{l+1}^2+2a_{l+1}k+k^2+\cdots+a^2_r+2a_rk+k^2$

$=(a_l^2+a_{l+1}^2+\cdots+a_r^2)+2k(a_l+a_{l+1}+\cdots+a_r)+(r-l+1)k^2$

变化量为：$2k(a_l+a_{l+1}+\cdots+a_r)+(r-l+1)k^2$

即加上 $2*$父节点的标记$*$原区间和$+$区间长$*$父节点的标记$^2$。翻译成程序语言即可。

区间和、标记的修改较简单，详见代码部分


### 本人翻车经历

- 宏定义的时候，没有给$llen,rlen,len$加上外面的括号，导致爆炸。所以记住，宏定义一定要带括号，否则结果不堪设想，~~调试了好几天~~。

### 技巧 

- 线段树封装成了类，方便调用，比较美观。
	
	这样主函数比较短小，每次操作都是传入一个参数$opt$即可，把细节封装起来。

- 利用位运算与宏，节约码量。

	这个是线段树基础知识。
    
    左儿子的编号是父节点的两倍，右儿子的编号是父节点的两倍+1。设父节点的编号为$rt$，则左儿子$lson=rt*2=rt<<1$，右儿子$rson=rt*2+1=rt<<1|1$。
    
    
    
AC代码

~~~cpp
#include <iostream>
#include <algorithm>
#include <cstdio>

#define DEBUG \
do {\
  for (int i = 1; i <= n; ++i) {\
    printf("%d ", st.query_sum(i,i,1,n,1));\
  }\
  putchar('\n');\
}while(0);

//debug用的

using namespace std;

const int N = 1e5, M = 1e5;
//常量

typedef double db;

int n, m;

class segmenttree {
  private:
    db add[N << 2];//标记
    db sum[N << 2];//区间和
    db sqr[N << 2];//平方和

	//宏定义若干
    #define lson rt<<1
    #define rson rt<<1|1
    #define ltree l,m,lson
    #define rtree m+1,r,rson
    #define len (r-l+1)
    #define llen (m-l+1)
    #define rlen (r-m)
    #define sq(x) (x)*(x)

	//一般用rt表示当前节点
    //合并左右儿子的信息。直接相加即可。
    inline void pushup(int rt) {
      sum[rt] = sum[lson] + sum[rson];
      sqr[rt] = sqr[lson] + sqr[rson];
    }

	//下放，在上面有详细讲过
    inline void pushdown(int l, int r, int rt) {
      if (add[rt]) {
        int m = (l + r) >> 1;

        sqr[lson] += 2.0 * sum[lson] * add[rt]
                   + llen * sq(add[rt]);
        sqr[rson] += 2.0 * sum[rson] * add[rt]
                   + rlen * sq(add[rt]);
                   
        sum[lson] += llen * add[rt];
        sum[rson] += rlen * add[rt];
        
        add[lson] += add[rt];
        add[rson] += add[rt];
        
        add[rt] = 0;
      }

    }

	//查询函数，L,R表示目标区间，l,r表示当前区间。
    db query_sum(int L, int R, int l, int r, int rt) {
      if (L <= l && r <= R) {
        return sum[rt];
      }
      pushdown(l, r, rt);
      int m = (l + r) >> 1;
      db ans = 0;
      if (L <= m) {
        ans += query_sum(L, R, ltree);
      }
      if (R > m) {
        ans += query_sum(L, R, rtree);
      }
      return ans;
    }

    db query_sqr(int L, int R, int l, int r, int rt) {
      if (L <= l && r <= R) {
        return sqr[rt];
      }
      pushdown(l, r, rt);
      int m = (l + r) >> 1;
      db ans = 0;
      if (L <= m) {
        ans += query_sqr(L, R, ltree);
      }
      if (R > m) {
        ans += query_sqr(L, R, rtree);
      }
      return ans;
    }
	
    
    //区间修改
    void update(int L, int R, db C, int l, int r, int rt) {
      if (L <= l && r <= R) {
        add[rt] += C;
        //这一步的原理见上。
        sqr[rt] += 2 * C * sum[rt]
                 + len * sq(C);
        sum[rt] += len * C;
        return ;
      }
      pushdown(l, r, rt);
      int m = (l + r) >> 1;
      if (L <= m) {
        update(L, R, C, ltree);
      }
      if (R > m) {
        update(L, R, C, rtree);
      }
      pushup(rt);
    }

  public:
  
    segmenttree(void){}
    
    void build(int l, int r, int rt) {
      if (l == r) {
        scanf("%lf", &sum[rt]);
        sqr[rt] = sq(sum[rt]);
        return ;
      }
      int m = (l + r) >> 1;
      build(ltree); build(rtree);
      pushup(rt);
    }

    inline void f(int opt) {
      register int l, r;
      register db k;
      scanf("%d %d", &l, &r);
      
      /*
      opt有三种可能
      1 二进制下为1
      2 二进制下为10
      3 二进制下为11
      
      1&1 = 1, 2&1 = 0, 3&1 = 1。
      
      所以&1之后，为真的是1或3，为假的是2
      
      1>>1 = 0, 3 >> 1 = 1。
      
      所以>>1之后，为真的是3，为假的是1
      */
      if (opt & 1) {
        if (opt >> 1) {
          db s1 = query_sqr(l, r, 1, n, 1) / len,
             s2 = query_sum(l, r, 1, n, 1) / len;
			//方差的解释在上面
          printf("%.4lf\n", s1 - sq(s2));
        }
        else {
          scanf("%lf", &k);
          update(l, r, k, 1, n, 1);
        }
      }
      else {
        printf("%.4lf\n", query_sum(l, r, 1, n, 1) / len);
      }
    }
};

segmenttree st;


int main(void) {

  scanf("%d %d", &n, &m);
  
  st.build(1, n, 1);
  
  while (m--) {
    int opt;
    scanf("%d", &opt);
    st.f(opt);
  }
  
  return 0;
}
~~~

---

## 作者：王将飞扬Cliffly (赞：1)

需要对公式进行一定的分析变形能力即可

首先平均数很好维护，区间和/区间长即可

难点在于方差，在于区间加和时对方差的影响


方差公式看起来复杂，其实化简开来只是一个参数不多的多项数

方差的计算很简单， 我们把公式拆开， 把 每个 (Xi- AVE) ^2 都化开:

就得到了一段区间的平方和，加上 2\* AVE \* 一段区间的和，加上 AVE^2  , 最后整体除个区间长 （具体数学公式看楼下）


于是我们需要用一棵线段树维护区间和   ， 一棵维护区间平方和

问题就在于我们怎样在区间进行加和操作时对这两个数组进行维护

区间和只要正常的lazytag下传即可

区间平方和在lazytag下传和update更新时须注意。

我们把公式拆开 （A为修改值）：

把 ( X(l)+A) ^2 + ( X(l+1)+A) ^ 2 + ……+ ( X(r) + A) ^ 2 ） 各项拆开， 便得到：

原区间平方和+ 区间长 \* A ^2 + 2 \* A \* 区间和  （ 调用先前那个数组即可）

剩下的便是常见的线段树操作了 ， 稍稍注意细节




```cpp
#include<bits/stdc++.h>
#define rep(i,j,n) for(int i=j;i<=n;i++)
using namespace std;
typedef long long ll;
const int N=1e5+10;
int n,m;
double tree1[N<<2] , tree2[N<<2] , addv[N<<2] , c[N] ;  //维护2棵线段树， 一棵为子树和， 一棵为子树平方和 
#define lson o<<1
#define rson o<<1|1
#define mid (l+r>>1)
#define up(o) tree1[o]=tree1[lson]+tree1[rson] ; tree2[o]=tree2[lson]+tree2[rson] 
inline void build(int o,int l,int r) {
    if(l==r) { tree1[o]=c[l] ; tree2[o]=c[l]*c[l] ; return ;}
    build(lson,l,mid) ; build(rson,mid+1,r) ; up(o);
}
inline void down(int o,int l,int r,double x) {  //涉及区间修改 
    addv[lson]+=x ; addv[rson]+=x; 
    tree2[lson]+=x * x * (mid-l+1) + 2 * x * tree1[lson] ; 
    tree2[rson]+=x * x * (r - mid) + 2 * x * tree1[rson] ; 
    tree1[lson]+=x*(mid-l+1) ; tree1[rson]+=x*(r-mid) ;
}
inline void update(int o,int l,int r,int L,int R ,double x) {  // 本题的关键点在于如何下传标记和区间修改
    if(L<=l && r<=R ) {
        addv[o]+=x; tree2[o]+=(r-l+1)*x*x + 2*x * tree1[o] ;tree1[o]+=x*(r-l+1) ;  return ;
    }
    if(addv[o]) down(o,l,r,addv[o]) , addv[o]=0;
    if(L<=mid) update(lson,l,mid,L,R,x) ;
    if(R>mid) update(rson,mid+1,r,L,R,x);
    up(o); 
}
inline double query(int o ,int l,int r,int L,int R ,double *tree) { //求平均值， 简单的累和 
    if(L<=l && r<=R)  return tree[o];
    if(addv[o]) down(o,l,r,addv[o]) , addv[o]=0 ;
    double ret=0 ;
    if(L<=mid) ret+=query(lson,l,mid,L,R,tree) ;
    if(R>mid) ret+=query(rson,mid+1,r,L,R,tree);
    return ret ;
}
```
/\*
inline double query2(int o,int l,int r,int L,int R ) { //求方差的一部分 ，即查询第二棵线段树中的平方和


```cpp
    if(L<=l && r<=R)  return tree2[o];
    if(addv[o]) down(o,l,r,addv[o]) , addv[o]=0 ;
    double ret=0 ;
    if(L<=mid) ret+=query2(lson,l,mid,L,R) ;
    if(R>mid) ret+=query2(rson,mid+1,r,L,R);
    return ret ;
}*/
int main() {
    scanf("%d%d",&n,&m);
    rep(i,1,n) scanf("%lf",&c[i]);
    build(1,1,n) ;
    int type, x,y  ; double k ;
    while(m--) {
        scanf("%d%d%d",&type,&x,&y) ;   double len=(double) (y-x+1) ;   
        if(type==1) scanf("%lf",&k) ,update(1,1,n,x,y,k);
        if(type==2) printf("%.4lf\n", query(1,1,n,x,y,tree1) / len );
        if(type==3) {
            double sum=query(1,1,n,x,y,tree1) ;
            double ave=sum / len ; 
            printf("%.4lf\n" , ave*ave + query(1,1,n,x,y,tree2) / len - 2*sum*ave/len ) ;
        } 
    }
    return 0;
}

```

---

## 作者：浮尘 (赞：1)

我发现好像没有人特别清晰地描述打懒标记这个过程, 所以特意打出了这个过程，看注释吧~~~

```cpp
#include<iostream>
#include<iomanip>
using namespace std;
const int N = 100005, INF = 0x7fffffff;
double a[N], sum[4*N], sum2[4*N]; 
double tag[4*N];

void pushup(int k)
{
	sum[k] = sum[k * 2] + sum[k * 2 + 1]; //区间和
	sum2[k] = sum2[k * 2] + sum2[k * 2 + 1]; //区间平方和
	return ; 
} 

void build(int k, int lt, int rt) //第k个结点， lt rt为要询问的区间范围 
{
	if(lt == rt)
	{
		sum[k] = a[lt]; //a为原始数组，sum[k]为第k个结点的区间和 
		sum2[k] = a[lt] * a[lt]; //平方 
		return ;
	}
	int mid = lt + (rt - lt) / 2; // mid = (lt + rt) >> 1
	build(k * 2, lt, mid);
	build(k * 2 + 1, mid + 1, rt);
	pushup(k);
	return ;
}

void Add(int k, int lt, int rt, double val) //打懒标记 
{
	tag[k] += val; //标记K结点对应的区间要加的值
	sum2[k] += 2 * val * sum[k] + val * val * (rt - lt + 1); //因为平方和要用到 区间和， 所以要先更新！ 
	sum[k] += (rt - lt + 1) * val; 
	return ; 
}

void pushdown(int k, int lt, int rt)
{
	if(tag[k] == 0)
		return ;
	int mid = lt + (rt - lt) / 2;
	Add(k*2, lt, mid, tag[k]);
	Add(k*2+1, mid+1, rt, tag[k]);
	tag[k] = 0; //将标记传给子节点后，父节点的标记要清零，否则会加重复
	return ; 
}

//在qx, qy区间每个数加上val 
void modify(int k, int lt, int rt, int qx, int qy, double val)
{
	if(lt > qy || rt < qx)
		return ;
	else if(lt >= qx && rt <= qy)
	{
		Add(k, lt, rt, val);
		return ;
	}
	int mid = lt + (rt - lt) / 2;
	pushdown(k, lt, rt); 
	modify(k * 2, lt, mid, qx, qy, val);
	modify(k * 2 + 1 , mid + 1, rt, qx, qy, val);
	pushup(k);
	return ; 
}

double query(int k, int lt, int rt, int qx, int qy)
{
	if(lt > qy || rt < qx)
		return 0;
	else if(lt >= qx && rt <= qy)
		return sum[k];
	int mid = lt + (rt - lt) / 2;
	pushdown(k, lt, rt); //询问时才下传标记，因为需要知道子区间要加的值 
	return query(k * 2, lt, mid, qx, qy) + query(k * 2 + 1, mid + 1, rt, qx, qy);
}

double query2(int k, int lt, int rt, int qx, int qy)
{
	if(lt > qy || rt < qx)
		return 0;
	else if(lt >= qx && rt <= qy)
		return sum2[k];
	int mid = lt + (rt - lt) / 2;
	pushdown(k, lt, rt); //询问时才下传标记，因为需要知道子区间要加的值 
	return query2(k * 2, lt, mid, qx, qy) + query2(k * 2 + 1, mid + 1, rt, qx, qy);
}


int main()
{
	int n, m;
	cin >> n >> m;
	for(int i = 1; i <= n; i++)
	{
		cin >> a[i];
	} 
	build(1, 1, n); //建树 
	for(int i = 1; i <= m; i++)
	{
		int option, x, y;
	   	double v;
		cin >> option;
		if(option == 1)
		{
			cin >> x >> y >> v;
			modify(1, 1, n, x, y, v);
		}
		else if(option == 2)
		{
			cin >> x >> y;
			cout << fixed << setprecision(4) << query(1, 1, n, x, y) / (y-x+1) << "\n";
		}
		else
		{
			cin >> x >> y;
			double avg = query(1, 1, n, x, y) / (y-x+1);
			cout << fixed << setprecision(4) << -avg * avg + query2(1, 1, n, x, y) / (y-x+1) << "\n";
		}
	}
    return 0;
}

```


---


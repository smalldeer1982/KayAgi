# [NOIP 2013 提高组] 火柴排队

## 题目背景

NOIP2013 提高组 D1T2

## 题目描述

涵涵有两盒火柴，每盒装有 $n$ 根火柴，每根火柴都有一个高度。 现在将每盒中的火柴各自排成一列， 同一列火柴的高度互不相同， 两列火柴之间的距离定义为：$ \sum (a_i-b_i)^2$。

其中 $a_i$ 表示第一列火柴中第 $i$ 个火柴的高度，$b_i$ 表示第二列火柴中第  $i$ 个火柴的高度。

每列火柴中相邻两根火柴的位置都可以交换，请你通过交换使得两列火柴之间的距离最小。请问得到这个最小的距离，最少需要交换多少次？如果这个数字太大，请输出这个最小交换次数对 $10^8-3$ 取模的结果。


## 说明/提示

**输入输出样例说明一**

最小距离是 $ 0$，最少需要交换 $1$ 次，比如：交换第 $1 $ 列的前 $ 2$ 根火柴或者交换第 $2$ 列的前 $2 $ 根火柴。

**输入输出样例说明二**

最小距离是 $10$，最少需要交换 $2$ 次，比如：交换第 $1$ 列的中间 $2$ 根火柴的位置，再交换第 $2$ 列中后 $2$ 根火柴的位置。

**数据范围**

对于 $10\%$ 的数据， $1 \leq n \leq 10$；

对于 $30\%$ 的数据，$1 \leq n \leq 100$；

对于 $60\%$ 的数据，$1 \leq n \leq 10^3$；

对于 $100\%$ 的数据，$1 \leq n \leq 10^5$，$0 \leq a_i,b_i < 2^{31}$ 且对于任意 $1\le i<j\le n$，$a_i\neq a_j$，$b_i\neq b_j$。

## 样例 #1

### 输入

```
4
2 3 1 4
3 2 1 4
```

### 输出

```
1```

## 样例 #2

### 输入

```
4
1 3 4 2
1 7 2 4```

### 输出

```
2```

# 题解

## 作者：xiejinhao (赞：1199)

# P1966 火柴排队 题解
## 这毕竟是个蓝题 于是时间过去了很久……
### 终于想出来了 本人不会树状数组 于是还是老老实实归并
#### 不会的先看看思路，别急着看代码
其实这题本身并不难，考的知识点就是**归并排序**和**逆序对**；
（附[P1908 逆序对](https://www.luogu.org/problemnew/show/P1908)）

那么难点在哪呢？就在如何**发现**这题是个逆序对：

（附送题目链接：[P1966 火柴排队](https://www.luogu.org/problemnew/show/P1966)）

于是我们先解读题目（以下是简化版）：

- 现有两列每列个数为n的火柴，且每列中火柴棒的高度均不相同，求得到Σ[(ai-bi)^2]的最小值的时候，最少需要交换火柴的次数，其中i表示a、b两列火柴棒中第i根火柴；
- 数据输入：

1. 共三行，第一行包含一个整数 n，表示每盒中火柴的数目。
1. 第二行有 n 个整数，每两个整数之间用一个空格隔开，表示第一列火柴的高度。
1. 第三行有 n 个整数，每两个整数之间用一个空格隔开，表示第二列火柴的高度。

- 数据输出：一个整数，表示最少交换次数对 99,999,997 取模的结果。

数据范围：
1. 对于 10%的数据， 1 ≤ n ≤ 10；

1. 对于 30%的数据，1 ≤ n ≤ 100；

1. 对于 60%的数据，1 ≤ n ≤ 1,000；

1. 对于 100%的数据，1 ≤ n ≤ 100,000,0 ≤火柴高度≤ maxlongint；

至少读到这里我们可以知道，虽然火柴高度是唯一的，但我们不可能直接开一个 max long int 大小的数组！很明显，有一个考点：**离散化**！

好了回归题目，既然要求找到 min(Σ[(ai-bi)^2])，那么我们不妨变形一下：

		Σ[(ai-bi)^2]=Σ(ai^2-2*ai*bi+bi^2)
        
由此可见，若想使min(Σ[(ai-bi)^2])最小，而和式中ai^2+bi^2是个定值，那么，就只能在 2*aibi 这一项上下文章；
 
 		Σ(ai^2-2*ai*bi+bi^2)=Σ(ai^2+bi^2)-Σ(2*ai*bi)
            Σ(2*ai*bi)=2*Σ(ai*bi)
            
那么，我们要取 Σ(ai*bi)的**最大值**！这样，上述和式的值最小；

如何取到最大值？其实看过别人题解的也都清楚：

对于数列k1~kn,p1~pn，Σ(ki*pi)的最小值要求两个数列有序的分别从小到大（或从大到小）排列

即提出“假说”：对于有序数列k(1)~k(n),p(1)~p(n)，k(1)p(1)+k(2)p(2)+……+k(n)p(n)>=k(i)p(t)+k(u)p(y)+……+k(r)p(g)，意思就是说：顺序x顺序>=乱序x乱序；

如何证明？

看了Dalao们写的很多，我还是用数学知识证明一下好了：


公式证明： 顺序之乘>=乱序之乘
------------
1. 设有序数列k1~kn,p1~pn，取k1<k2、p1<p2
1. 因此容易得到：k1p1+k2p2>k1p2+k2p1;
  
	将上述不等式变形一下：
  
		 k2p2-k2p1>k1p2-k1p1 即k2(p2-p1)>k1(p2-p1)
  		∵k2>k1,p2>p1 ∴k2(p2-p1)>k1(p2-p1)
  		证毕；
  
3. 推广2中的结论到1中，**乱序就是不断将顺序交换打乱的过程**，最终结果符合2的结论，因此 **顺序之乘>=乱序之乘**，证毕。

  我想我的证明还是比较易懂的吧QAQ
  
到此，题目解读完毕，证明完毕；
  
以下谈谈思路
------------
1. 离散化数据。既然数组没法开那么大，那么就对输入数据进行一下离散化。
  
实现如下： 
```cpp
  	struct fire{
  	    int hi,bh;
  	}l1[1000005],l2[1000005]；
		//……此处省略一大堆……
	  	for(int i=1;i<=n;i++)
        		scanf("%d",&l1[i].hi),l1[i].bh=i;
    	for(int i=1;i<=n;i++)
        		scanf("%d",&l2[i].hi),l2[i].bh=i;

```

  
2. 排列数。证明完成，那么我们要找的就是两个数列 l1, l2 中每一个数是否按我们所说的原则一一对应，比如说一个数列第1大的数对应另一个数列第1大的数，第2大的数对应另一个第2大的数，以此类推……

那么，不管三七二十一，先快排让两个序列有序一下吧（每个序列中火柴棒高度不同，不会导致编号混乱），反正有编号在那；然后我们来看一组数据（样例1）
  
  		
		A：2 3 1 4->1 2 3 4对应原编号为：3 1 2 4
		B：3 2 1 4->1 2 3 4对应原编号为：3 2 1 4

 那么，A序列中输入的第一个数是第3小的，类推；
  
  B序列中输入的第一个数是第3小的，符合，类推；
  
  然我我们就发现了，A中第二个数与B中第二个数不一样（顺序不同），那么这就是一个逆序对，这个数**不符合原则**；不懂继续看看，等会就懂了；
  
3. 找到不符合原则的数。
		
  		我们存一个数组c[i];
 		c[B[i]编号]=A[i]编号；为什么这么做？
  		数据说话：
  		A：2 3 1 4->1 2 3 4对应原编号为：3 1 2 4
		B：3 2 1 4->1 2 3 4对应原编号为：3 2 1 4
  		c[B[1]编号]=c[3]=a[1]编号=3
  		c[B[2]编号]=c[2]=a[2]编号=1
  		c[B[3]编号]=c[1]=a[3]编号=2
  		c[B[4]编号]=c[4]=a[4]编号=4
  		于是c[1]=2 c[2]=1 c[3]=3 c[4]=4
  		逆序对数=1，交换一次，结束；
  
  神奇吗？不神奇，这就是排序；读到这里，读者应该对排序有了更深的理解；
  
  **为什么上述操作可以实现**？因为**产生了逆序**；只要序列原来对应的数是符合要求的，他们编号相同，那么我们排完序两数的**相对位置**不发生改变，因此**不会产生逆序**；一旦**A中编号与B中的不同**，即大小顺序不同(**顺序的整理快排都帮我们实现了**)，那么这个数是**不符合要求**的，我们需要处理一下，剩下的在c数组中的数都是符合要求的(也就就是**计入逆序对**)。想到这里，程序就over了；不信的读者可以把第二个样例按我上面的分析写出来，自己也可以再写几组简单的样例，**多过几遍流程**；

  上述操作实现如下(归并部分等会给)：
```cpp
      long long n,x[10000005],p[1000005],ans=0;
      bool cmp1(fire a,fire b)
      {
          return a.hi<b.hi;
      }
      //结构体在上面离散的时候就定义了，这里不写了；
      //……再省略……
      	sort(l1+1,l1+n+1,cmp1);
      	sort(l2+1,l2+n+1,cmp1);
      	//排序
      	for(int i=1;i<=n;i++)
           x[l2[i].bh]=l1[i].bh;
      //整理排序结果，我讲的用的c数组，我写的时候写的是x，没差；
```
                         
3. 归并。这个我貌似不用说了，毕竟都做到蓝题了，没什么好讲的；但在归并中要求逆序对(其实冒泡也可以实现，但是太慢，会超时)，不懂请见[P1908 逆序对](https://www.luogu.org/problemnew/show/P1908)
  这个挺有用的。
  

至此，所有的分析与解就over了，与程序说再见
------------
代码实现如下：
```cpp
//认真看，杜绝抄袭 
#include<cstdio>
#include<algorithm>
using namespace std;
const int mod=99999997;
long long n,x[10000005],p[1000005],ans=0;
struct fire{
    int hi,bh;
}l1[1000005],l2[1000005];
bool cmp1(fire a,fire b)
{
    return a.hi<b.hi;
}
void msort(int s,int t)//归并排序; 
{
    if(s==t)return ;
    int mid=(s+t)/2;
    msort(s,mid);msort(mid+1,t);
    int i=s,k=s,j=mid+1;
    while(i<=mid && j<=t)
    {
        if(x[i]<=x[j])
        {
            p[k]=x[i];
            ++k;++i;
            
        }
        else
        {
            p[k]=x[j];
            ++k;++j;
            ans=(ans+mid-i+1)%mod;
			//此处找到逆序对，mid-i~mid中数全都与j构成逆序，还会少算一个，+1;
        }
    }
    while(i<=mid)
    {
        p[k]=x[i];
        ++k;++i;
    }
    while(j<=t)
    {
        p[k]=x[j];
        ++k;++j;
    }
    for(int i=s;i<=t;i++)
    {
        x[i]=p[i];
    }
}
int main()
{
    scanf("%lld",&n);
    for(int i=1;i<=n;i++)
        scanf("%d",&l1[i].hi),l1[i].bh=i;
    for(int i=1;i<=n;i++)
        scanf("%d",&l2[i].hi),l2[i].bh=i;
    sort(l1+1,l1+n+1,cmp1);
    sort(l2+1,l2+n+1,cmp1);
    //排序; 
    for(int i=1;i<=n;i++)
        x[l2[i].bh]=l1[i].bh; 
    msort(1,n);
    //调用归并; 
    printf("%lld",ans);
    return 0;//这个不会有人忘的吧？ 
}
```


------------

这题还是基础吧，就是比较灵活
------------
  

然后，Dalao看完~~点个赞~~好不好
------------

  


---

## 作者：我太强了 (赞：74)

[传送门](https://www.luogu.org/problemnew/show/P1966)

画一画图就知道，必须让第一列中第$i$高的火柴与第二列中第$i$高的火柴怼齐。（我喜欢把第$i$高叫做等级为$i$了qwq）

（本来还想过先让高度相同的怼到一起，但是这是不优的。

$e.g.$第一列为$1$ , $7$ , $9$,第二列为$4$ , $2$ , $7$。

优先让高度相同在一起时配对是$1$—$2$，$7$—$7$，$9$—$4$，距离为$26$，先让等级一样的怼齐时配对为$1$—$2$，$7$—$4$，$9$—$7$，距离为$14$。显然第二种答案更好）

所以，我就想离散化出各个位置的数字的高度等级，放在$idx[i]$中。也就是说，$idx[i]$存储的是第$i$个位置的数字是第几大的。

![](https://cdn.luogu.com.cn/upload/pic/61005.png)

然后，我就莫得办法了。如果是把一个数列排好序，我是知道的——只要算逆序对数量就可以了。虽然用树状数组求我不会，我还是会用归并排序求的。但是，这道题问的是，用多少次相邻交换能把一个乱序数列变成另一个乱序数列，这怎么办啊？？？~~wsl~~

所以，花了整整一下午来想(我真的很菜)......~~看了好多题解好多博客qwq，学了这么久，我还是认为离散化是最难理解的东西~~

在最正常的排序求逆序对中，假设有数列$A$，$A[i]$最初读入的数字是$num[i]$。求逆序对就是把$A[i]$与标准数列$q[i]$（排序后的数列）比对，目标就是让$A[i]$里的数字和下标（目标位置）对应起来，即让$A[i]$里储存的是第$i$小的数字。（我说的好颠三倒四没有逻辑啊qwq）

感性推广一下。在本题中，把第一列的高度等级$idx[i]$看做标准数列，正常逆序对中的$q[i]$对应$q[idx[i]]$，正常逆序对中的$num[i]$对应$idx2[i]$，
这就把第一列的高度等级变成了下标（目标位置），第二列的高度等级变成了数字。把$q[idx[i]]$按$idx[i]$从$1$—$n$排序好，不就完全变成了正常的排序求逆序对了嘛！

回头说一下离散化（这里我错了好久都没发现qwq）。我原本让$idx[i]$存储的第$i$个数字是第几小，而显然最开始读入的火柴高度在后面完全没用了，这么离散化就很诡异。所以，让$idx[i]$存储第$i$小的数字在哪个位置，$idx[i]$数组就变成了这样

![](https://cdn.luogu.com.cn/upload/pic/61006.png)

初始化$q[idx[i]]$=$idx2[i]$：
![](https://cdn.luogu.com.cn/upload/pic/61010.png)

按照序号排列好~~

![](https://cdn.luogu.com.cn/upload/pic/61011.png)

~~再背上树状数组求逆序对的板子~~



好辣，一看就非常简单辣！！！！！！

代码$↓↓$
```cpp
#include<bits/stdc++.h> 
#define lowbit(x) x&(-x) 
#define ll long long 
#define mod 99999997 
#define itn int 
using namespace std; 
itn n,tree[200005],q[100005];
int num[100005],idx[100005],num2[100005],idx2[100005]; 
ll ans; 
void add(int x) 
{ 
	while(x<=n) 
	{ 
		tree[x]++; tree[x]%=mod; 
		x+=lowbit(x); 
	} 
} 
int sum(int x) 
{ 
	int ret=0; 
	while(x>0) 
	{ 
		ret+=tree[x]; 
		if(ret>mod) ret-=mod; 
		x-=lowbit(x); 
	} 
	return ret%mod; 
} 
bool cmp(int x,int y) 
{ 
	return num[x]<num[y]; 
} 
bool cmp2(int x,int y) 
{ 
	return num2[x]<num2[y]; 
} 
int main() 
{ 
	cin>>n; 
	/*for(int i=1;i<=n;i++) scanf("%d",&num[i]),idx[i]=num[i];
	for(int i=1;i<=n;i++) scanf("%d",&num2[i]),idx2[i]=num2[i];
	sort(num+1,num+1+n); sort(num2+1,num2+1+n);
	for(int i=1;i<=n;i++) idx[i]=lower_bound(num+1,num+1+n,idx[i])-num;
	for(int i=1;i<=n;i++) idx2[i]=lower_bound(num2+1,num2+1+n,idx2[i])-num2;
	for(int i=1;i<=n;i++) cout<<idx[i]<<" "<<idx2[i]<<endl;
	误区：让idx[i]存储第i个位置的数字是第几小*/ 
	for(int i=1;i<=n;i++) scanf("%d",&num[i]),idx[i]=i; 
	for(int i=1;i<=n;i++) scanf("%d",&num2[i]),idx2[i]=i; 
	sort(idx+1,idx+1+n,cmp); sort(idx2+1,idx2+1+n,cmp2); 
	for(int i=1;i<=n;i++) cout<<idx[i]<<" "<<idx2[i]<<endl;
	//idx[i]:第i大的数字在第几个位置 
	for(int i=1;i<=n;i++) q[idx[i]]=idx2[i]; 
	for(int i=n;i>=1;i--) //树状数组求逆序对
	{ 
		add(q[i]); 
		ans=(ans+sum(q[i]-1))%mod; 
	} 
	cout<<ans%mod<<endl; 
	return 0; 
} 
```

总算写完了，好多废话......不过既然是给自己写的就没关系了吧......

---

## 作者：Asika391 (赞：25)

这题目在处理序列上还是很有价值的。

题目要求我们最小化$\sum(a_{i}-b_{i})^2$，首先第一个给我们的启示是：遇到这种相互约束的式子，我们可以考虑将其拆开，变成容易维护的式子。

因为$\sum(a_i-b_i)^2=\sum (a_i^2+b_i^2)-2\times\sum a_i\times b_i$。前者显然是一个定值，我们要求的就是$\sum a_i\times b_i$的最大值。高中数学选修$4-5$里面有一个不等式叫排序不等式（所以数学是很重要的！）：
若$a_1\leq a_2\leq a_3\leq \cdots\leq a_n$与$b_1\leq b_2\leq b_3\leq \cdots\leq b_n$那么有$a_1b_n+a_2b_{n-1}+\cdots +a_nb_1\leq a_{i1}b_{j1}+a_{i2}b_{j2}+\cdots +a_{in}b_{jn}\leq a_1b_1+a_2b_2+\cdots +a_nb_n$即反序和$\leq$乱序和$\leq$同序和。

有了这个结论，我们只需要使使两列火柴的高度一一对应就好了（就是使最大与最大排在一起，以此列推）。

那么第二个思考来了：在只涉及大小关系中，我们可以将数据离散化。以下给出一个离散化的代码：

```cpp
bool cmp(int i,int j){return A[i]<A[j];}
for(int i=1;i<=n;++i) scanf("%d",&A[i]),a[i]=i;
sort(a+1,a+1+n,cmp);
```
其中$A$数组是读入的火柴高度。我们发现经过这样离散化后，$a[i]$表示的是$i$这个数字在$A$中的位置（$A$数组中排名为$i$的数）(可以手玩一下)。

我们对$A,B$数组都经过这样离散化后，设离散化后的数组为$a,b$，新建一个数组$l$并令$l[a[i]]=b[i]$这样操作后我们会发现$l[i]$表示的是$A$中$i$这个位置的数在$B$中的位置。

举个例子吧，若初始的火柴高度是:

$A=${$1,3,4,2$}

$B=${$1,7,2,4$}

我们先将其离散化一下便于理解，实际操作中并没有这一步,得到$A=${$1,3,4,2$},$B=${$1,4,2,3$}，那么离散化后的数组$a=${$1,4,2,3$}与$b=${$1,3,4,2$}那么得到的$l=${$1,4,2,3$}这正好对应了将$B$中$1$作为$1$，$4$作为$2$，$2$作为$3$，$3$作为$4$(按$1,2,3,4$升序)将$A$替换后的结果这时候，我们只要将$l$交换到$1,2,3,4$的状态就满足了。因为题目告诉我们每列火柴高度不重复并且每次交换只交换相邻两根火柴，这时候就是直接用树状数组计算$l$数组的逆序对就可以了。

附上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=100005,mod=99999997;

int A[N],B[N],a[N],b[N],l[N],c[5*N];
ll ans;
int n;

void add(int x,int y){
	for(;x<=n;x+=x&-x) c[x]+=y;
}

int ask(int x){
	ll ans=0;
	for(;x;x-=x&-x) ans+=c[x];
	return ans;
}

bool cmp1(int i,int j){
	return A[i]<A[j];
}

bool cmp2(int i,int j){
	return B[i]<B[j];
}

int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i) scanf("%d",&A[i]),a[i]=i;
	for(int i=1;i<=n;++i) scanf("%d",&B[i]),b[i]=i;
	sort(a+1,a+1+n),sort(b+1,b+1+n);//离散化
	sort(a+1,a+1+n,cmp1),sort(b+1,b+1+n,cmp2);
	for(int i=1;i<=n;++i) l[a[i]]=b[i];
	for(int i=n;i;i--){//树状数组求逆序对
		ans=(ans+ask(l[i]-1))%mod;
		add(l[i],1);	
	}
	printf("%lld",ans%mod);
	return 0;
}
```

---

## 作者：Shadow_Soldier (赞：19)

# 题意简化
给定一个正整数 $n(1 \le n \le 10^6)$ 和两个长度为 $n$、下标从 $1$ 到 $n$ 的序列 $a$、$b$。每次可以选择一个不相等的正整数 $i$，且 $1 \le i < n$，交换 $a_i,a_{i+1}$ 或交换 $b_i,b_{i+1}$。问：在最小化 $\sum_{i=1}^{n} (a_i - b_i)^2$ 的前提下，最少的步数模 $10^8 - 3$ 的结果（[原题-P1966](https://www.luogu.com.cn/problem/P1966)）。
# 暴力简述
注意到，交换 $a_i,a_{i+1}$ 与交换 $b_i,b_{i+1}$ 在计算答案时是等价的。所以，直接暴力枚举即可，没有什么太难的思维难度，代码就不放了。
# 正解思路及部分代码片段
首先，见【暴力简述】，可以固定一个数组，交换另一个数组中的元素，尽可能的最小化 $\sum_{i=1}^{n} (a_i - b_i)^2$。那么我们来想一想，什么情况下这个值会最小呢？比较容易地可以想到：$a,b$ 序列每个元素的排名相同。即：令 $p_i$ 为 $a$ 数组排序后（此时已经交换完毕）第 $i$ 个元素的下标，$q_i$ 为 $b$ 数组排序后（此时已经交换完毕）第 $i$ 个元素的下标。则 $p_i = q_i \forall 1 \le i \le n$（如有相同，则可任取，只要有一种情况满足即可）。即求：把 $p_i$ 变成 $q_i$ 的最少交换次数模 $10^8-3$ 的结果。那还是不能在 $1$ 秒之内求出答案呀！通过交换相邻元素，使一个序列变成另一个序列，让我们很快就能够想到：逆序对。  
在这里解释一下：若有一个长度为 $n$ 的序列 $x_i$，则满足 $x_i > x_j$ 且 $i < j$ 的 $x_i,x_j(1 \le i, j \le n)$ 就是一组逆序对。它的逆序对个数 $m$ 的计算方式如下：
$$
\tag{*}
m = \sum_{i = 1}^{n} \sum_{j = i + 1}^{n} [x_i > x_j]
$$
（上述公式中 $[]$ 符号的意思：若里面逻辑表达式为真，则返回 $1$；否则，返回 $0$）。  
那么，已知一个序列，该如何求呢？暴力当然很简单，双层循环加判断，统计一下就行了。然而时间复杂度是 $O(n^2)$。但是当然可以优化，用归并排序和双指针（可能还有一些其它方法吧 ~~，但是我不会~~）。若需求序列 $x$ 中 $l$ ~ $r$ 的子段中的逆序对个数，可作以下处理：  
$$
F(l,r) = 
\begin{cases}
  0 & l = r \\
  F(l, \lfloor \frac{l + r}{2} \rfloor) + F(\lfloor \frac{l + r}{2} \rfloor + 1, r) + G(l,\lfloor \frac{l + r}{2} \rfloor,\lfloor \frac{l + r}{2} \rfloor + 1,r) & l < r
\end{cases}
$$
其中，$F(l,r)(l \le r)$ 表示序列 $x$ 中 $l$ ~ $r$ 的子段中的逆序对个数（序列 $x_l,x_{l+1},x_{l+2},...,x_{r-1},x_r$ 中的逆序对个数），$G(l_1,r_1,l_2,r_2)(l_1 \le r_1 < l_2 \le r_2)$ 表示 $(*)$ 式中 $i \in [l_1,r_1],j \in [l_2,r_2]$ 时的结果（这里的 $[]$ 符号表示一段左闭右闭实数区间，但是注意：$i,j$ 都是整数）。即：
$$
\tag{**}
\sum_{i = l_1}^{r_1} \sum_{j = l_2}^{r_2} [x_i > x_j]
$$
（上述公式中 $[]$ 符号的意思：若里面逻辑表达式为真，则返回 $1$；否则，返回 $0$）。  
然而，根据主定理，若有一函数 $T(x)$ 满足其时间复杂度计算方式如下：
$$
T(n) = 
\begin{cases}
  \Omicron(1) & n < b \\
  a \cdot T(\frac{n}{b}) + f(n) & n \ge b
\end{cases}
$$
（表示一个规模为 $n$ 的问题被划分成 $a$ 个规模为 $\frac{n}{b}$ 的子问题，在其他处理时（如合并）的时间复杂度为 $f(n)$）  
则其时间复杂度的计算方式为：
$$
T(n) = 
\begin{cases}
\Theta(n^{log_b a}) & f(n) = \Omicron(n^{log_b a - \epsilon}), \epsilon > 0 \\
\Theta(f(n)) & f(n) = \Omega(n^{log_b a + \epsilon}), \epsilon \ge 0,\text{且存在一个 } c(c < 1) \text{，使对于满足 } n \ge b \text{ 的 } n \text{ 都有 } a \cdot f(\frac{n}{b}) \le c \cdot f(n) \\
\Theta(n^{log_b a} log^{k + 1} n) & f(n) = \Theta(n^{log_b a} log^k n), k \ge 0
\end{cases}
$$
此时，$a = 2$，$b = 2$，$f(n) = G(n) = \Omicron(\frac{n^2}{4})$，属于上面公式的第二种情况。$\therefore T(n) = \Omicron(f(n)) = \Omicron(\frac{n^2}{4})$（可以看作 $\Omicron(n^2)$）。没有起到十分有用的优化。我们发现，时间复杂度的瓶颈是 $f(n)$，所以我们需要优化 $f(n)$ 的时间复杂度。接下来就需要用归并排序和双指针了。  
如果在合并的时候（$G(l_1,r_1,l_2,r_2)(l_1 \le r_1 < l_2 \le r_2)$），区间 $1$（$l_1$ ~ $r_1$）和区间 $2$（$l_2$ ~ $r_2$）都是单调不下降的，那么在合并的时候，是不是就能优化了呢？  
在合并的时候，我们需要做两件事：将两个单调不下降区间（$l_1$ ~ $r_1$ 和 $l_2$ ~ $r_2$）合并成一个单调不下降的大区间（$l_1$ ~ $r_2$）、统计逆序对数量（$(**)$ 式）。  
首先，先看第一件事，将两个单调不下降的区间合并成一个单调不下降的大区间，很容易地就能够想到双指针。下面提供一个例子（片段）：  
```cpp
int p1 = l1, p2 = l2, p3 = l1;
while(p1 <= r1 && p2 <= r2) {
    if(a[p1] > a[p2]) b[p3++] = a[p2++];
    else b[p3++] = a[p1++];
}
while(p1 <= r1) b[p3++] = a[p1++];
while(p2 <= r2) b[p3++] = a[p2++];
for(int i = l1; i <= r2; i ++) a[i] = b[i];
``````
上面的代码片段完成了将 $a$ 序列中 $l_1$ ~ $r_1$ 和 $l_2$ ~ $r_2$ 的两个单调不下降的区间合并成一个 $l_1$ ~ $r_2$ 的单调不下降的大区间的功能。  
第一件事完成了。那么，如何在这个过程中，加入第二件事：统计逆序对数量（$(**)$ 式）呢？  
首先，因为 $a$ 序列中 $l_1$ ~ $r_1$ 和 $l_2$ ~ $r_2$ 的两个区间是单调不下降的，所以可以得到：在第一个循环中，若判断语句成立，则不仅 $a_{p_1}$（换一种形式写上，理解就行）和 $a_{p_2}$ 是一对逆序对，对于所有满足 $i \in [p_1,r_1]$ 的整数 $i$（这里的 $[]$ 符号表示一个左闭右闭实数区间，但是因为 $i$ 是整数，所以在这里也可以理解成一个左闭右闭整数区间），都有 $a_i$ 和 $a_{p_2}$ 是逆序对，共 $r_1 + 1 - p_1$ 对。这样就计算出了这一部分所有的逆序对了。  
实际上就是在上面的代码片段中加入一个语句，变成这样：  
```cpp
int p1 = l1, p2 = l2, p3 = l1;
while(p1 <= r1 && p2 <= r2) {
    if(a[p1] > a[p2]) {
        b[p3++] = a[p2++];
        ans += (r1 + 1 - p1);
    }
    else b[p3++] = a[p1++];
}
while(p1 <= r1) b[p3++] = a[p1++];
while(p2 <= r2) b[p3++] = a[p2++];
for(int i = l1; i <= r2; i ++) a[i] = b[i];
``````
只需要在这个基础上对 $10^8 - 3$ 取模即可。  
好了，就这样，我们把 $G(n)$ 的时间复杂度从 $\Omicron(\frac{n^2}{4})$ 优化成了 $\Omicron(n)$。  
再根据主定理，此时，$a = 2$，$b = 2$，$f(n) = G(n) = \Omicron(n)$，属于上面公式的第三种情况，且 $k = 0$。$\therefore T(n) = \Omicron(n^{log_b a} log^{k + 1} n) = \Omicron(n^{log_2 2} log^{0 + 1} n) = \Omicron(n log n)$。  
如果想要练习的话，可以做一做 [模板题-逆序对](https://www.luogu.com.cn/problem/P1908)。  
好了，讲了这么多，到底该如何用进这道题目中去呢？首先，肯定要得到 $a,b$ 数组排序后的下标，但是如何知道排序后的下标呢？有不止一种实现方式。  
第一种方式：将 $a,b$ 数组定义成机构体，如下：  
```cpp
struct node {
    int Val, Index;
}a[100010], b[100010];
``````
然后再用一个函数作为排序（快速排序）函数的第三个参数：  
```cpp
bool cmp(node u, node v) {
    return (u.Val < v.Val);
}
``````
用的时候就这么用：  
```cpp
sort(a + 1, a + n + 1, cmp);
sort(b + 1, b + n + 1, cmp);
``````
还有第二种方式：用 $a,b$ 数组对 $p,q$ 数组进行排序。  
定义很普通：  
```cpp
int a[100010], b[100010], p[100010], q[100010];
``````
记得初始化：  
```cpp
for(int i = 1; i <= n; i ++) {
    p[i] = q[i] = i;
}
``````
函数这么写（两个）：  
```cpp
bool cmpa(int u, int v) {
    return (a[u] < a[v]);
}
bool cmpb(int u, int v) {
    return (b[u] < b[v]);
}
``````
用的时候就这么用：  
```cpp
sort(p + 1, p + n + 1, cmpa);
sort(q + 1, q + n + 1, cmpb);
``````
反正不管怎么样，排完序之后（离散化）都会得到两个下标数组（`a[i].Index` 和 `b[i].Index`、`p[i]` 和 `q[i]`）。接下来，再定义一个新数组 $c$，用下面的方法来处理：  
第一种方式：  
```cpp
for(int i = 1; i <= n; i ++) {
    c[a[i].Index] = b[i].Index;
//  c[b[i].Index] = a[i].Index;
}
``````
第二种方式：  
```cpp
for(int i = 1; i <= n; i ++) {
    c[p[i]] = q[i];
//  c[q[i]] = p[i];
}
``````
反正不管怎么样，现在都会得到一个 $c$ 数组，答案就是对 $c$ 数组计算逆序对个数然后对 $10^8 - 3$ 取模（将 $c$ 数组变成 $c_i = i \forall 1 \le i \le n$ 的形式所要用的最少步数对 $10^8 - 3$ 取模）。  
就这样，这道看似很难的题就被解决了。  
# 代码
最后再补充一点，再之前讲合并函数的时候，形参一共有四个。但是不难发现，实际上并不需要四个，可以只有三个甚至两个，我个人习惯用三个形参的方式来实现，这并不代表其它方式就不行了，仅限个人习惯。好了，上代码。  
第一种实现方式：  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int Mod = 99999997;
int n, ans, c[100010], d[100010];
struct node {
    int Val, Index;
}a[100010], b[100010];
bool cmp(node u, node v) {
    return (u.Val < v.Val);
}
void Merge(int l, int mid, int r) {
    int p1 = l, p2 = mid + 1, p3 = l;
    while(p1 <= mid && p2 <= r) {
        if(c[p1] > c[p2]) {
            d[p3++] = c[p2++];
            ans = (ans + mid + 1 - p1) % Mod;
        }
        else d[p3++] = c[p1++];
    }
    while(p1 <= mid) d[p3++] = c[p1++];
    while(p2 <= r) d[p3++] = c[p2++];
    for(int i = l; i <= r; i ++) {
        c[i] = d[i];
    }
}
void Sort(int l, int r) {
    if(l == r) return;
    int mid = (l + r) >> 1;
    Sort(l, mid);
    Sort(mid + 1, r);
    Merge(l, mid, r);
}
int main()
{
    scanf("%d", &n);
    for(int i = 1; i <= n; i ++) {
        scanf("%d", &a[i].Val);
        a[i].Index = i;
    }
    for(int i = 1; i <= n; i ++) {
        scanf("%d", &b[i].Val);
        b[i].Index = i;
    }
    sort(a + 1, a + n + 1, cmp);
    sort(b + 1, b + n + 1, cmp);
    for(int i = 1; i <= n; i ++) {
        c[a[i].Index] = b[i].Index;
    }
    Sort(1, n);
    printf("%d", ans);
    return 0;
}
``````
第二种实现方式：  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int Mod = 99999997;
int n, ans, a[100010], b[100010], c[100010], d[100010], p[100010], q[100010];
bool cmpa(int u, int v) {
    return (a[u] < a[v]);
}
bool cmpb(int u, int v) {
    return (b[u] < b[v]);
}
void Merge(int l, int mid, int r) {
    int p1 = l, p2 = mid + 1, p3 = l;
    while(p1 <= mid && p2 <= r) {
        if(c[p1] > c[p2]) {
            d[p3++] = c[p2++];
            ans = (ans + mid + 1 - p1) % Mod;
        }
        else d[p3++] = c[p1++];
    }
    while(p1 <= mid) d[p3++] = c[p1++];
    while(p2 <= r) d[p3++] = c[p2++];
    for(int i = l; i <= r; i ++) {
        c[i] = d[i];
    }
}
void Sort(int l, int r) {
    if(l == r) return;
    int mid = (l + r) >> 1;
    Sort(l, mid);
    Sort(mid + 1, r);
    Merge(l, mid, r);
}
int main()
{
    scanf("%d", &n);
    for(int i = 1; i <= n; i ++) {
        scanf("%d", &a[i]);
        p[i] = i;
    }
    for(int i = 1; i <= n; i ++) {
        scanf("%d", &b[i]);
        q[i] = i;
    }
    sort(p + 1, p + n + 1, cmpa);
    sort(q + 1, q + n + 1, cmpb);
    for(int i = 1; i <= n; i ++) {
        c[p[i]] = q[i];
    }
    Sort(1, n);
    printf("%d", ans);
    return 0;
}
``````
# 数据通过情况
[第一种实现方式](https://www.luogu.com.cn/record/198234971)  
[第二种实现方式](https://www.luogu.com.cn/record/198235522)  
# 最后的话
__一定一定不要 Copy 代码！！！__ 并且最好不要边看边写。应该先理解每一步在做什么，对代码有了一个清晰的认识，在自己手打一遍，加深印象。本文中的代码仅供参考，不喜勿喷。  
最后的最后，写篇文章不容易，可否来个赞？？？

---

## 作者：KaguyaH (赞：11)

> [P1966](https://www.luogu.org/problem/P1966).

---

Changelog：简化题解，修复了 $\LaTeX$，更新代码。

---

给定两个序列 $a_{1 \cdots n}, b_{1 \cdots n}$，每次操作可将任意序列中相邻两位置交换。

求：要使 $\sum (a_i - b_i)^2$ 取最小值，所需最少操作次数。

$1 \leqslant n \leqslant 10^5$，$0 \leqslant a_i, b_i < 2^{31}$，$\forall\ 1 \leqslant i < j \leqslant n,\,a_i \ne a_j \land b_i \ne b_j$。

---

$$\sum(a_i - b_i)^2 = \sum(a_i^2 + b_i^2 - 2 a_i b_i),$$

上式取最小值等价于 $\sum a_i b_i$ 取最大值。

---

若 $a_i \leqslant a_j$，$b_p \leqslant b_q$，

则

$$(a_i b_p + a_j b_q) - (a_i b_q + a_j b_p) = (a_i - a_j) (b_p - b_q) \geqslant 0,$$

故 $a_i b_p + a_j b_q \geqslant a_i b_q + a_j b_p.$

综上，应使 $a, b$ 内部相对顺序一致。

---

比较直观地，要使操作次数最小，有一种可行方案是：只对 $b$ 进行操作，使之内部相对顺序与 $a$ 一致。

因为是相对顺序，所以我们可以先进行离散化，问题变为使 $a, b$ 完全一致。

设 $c_{a_i} = i$，则 $b_i$ 应该最终移到 $b$ 中位置 $c_{b_i}$。

于是我们再进行一波处理：$b_i \leftarrow c_{b_i}$。

处理后，问题变为使 $b_i$ 升序。

此时的操作次数即为 $b$ 的逆序对数，可用归并或树状数组求出。

---

代码用树状数组求逆序对。

```cpp
# include <cstdio>
# include <cstring>
# include <algorithm>

namespace Main {
    namespace Source {
        typedef unsigned int uint;
        template <const uint N>
        class Fenwick_tree {
            uint tree[N + 1];
            static inline const uint lowbit(const uint x) { return x bitand ~x + 1; }
        public:
            Fenwick_tree() { memset(tree, 0, sizeof tree); }
            inline const void modify(uint x) { while (x and x <= N) ++tree[x], x += lowbit(x); }
            inline const uint query(uint x)
            { uint r(0); while (x and x <= N) r += tree[x], x ^= lowbit(x); return r;}
        };
    }
    using namespace Source;
    enum { N = (const uint)1e5 };
    static const uint Mod(1e8 - 3);
    static uint n;
    static uint a[N], b[N], c[N];
    static Fenwick_tree<N> u;
    static uint ans;
    static inline const void discrete(uint a[N]) {
        static uint t[N];
        for (register uint i(0); i < n; ++i) t[i] = a[i];
        std::sort(&t[0], &t[n]);
        for (register uint i(0); i < n; ++i) a[i] = std::lower_bound(&t[0], &t[n], a[i]) - t;
    }
    static inline const void main() {
        scanf("%u", &n);
        for (register uint i(0); i < n; ++i) scanf("%u", &a[i]);
        for (register uint i(0); i < n; ++i) scanf("%u", &b[i]);
        discrete(a), discrete(b);
        for (register uint i(0); i < n; ++i) c[a[i]] = i;
        for (register uint i(0); i < n; ++i) b[i] = c[b[i]];
        for (register uint i(n - 1); i < n; --i)
            ans = (ans + u.query(b[i]+ 1)) % Mod,
            u.modify(b[i] + 1);
            // +1 because u[1, n] not u[0, n)
        printf("%u\n", ans);
    }
}

signed int main() { Main::main(); return 0; }
```

---

## 作者：龙·海流 (赞：10)

这是个极其鬼畜的逆序对问题。。。。。。

发动你的人类智慧，你的潜意识告诉你两列火柴排名相同的火柴排在同一行时（就是第一列第一长的和第二列第一长的在同一行，第一列第二长的和第二列第二长的在同一行，第一列第三长的和第二列第三长的在同一行，），∑(ai−bi)$^{2}$最小

开始冗长的证明：

任取ai，aj，使得ai是第一列中第i长的，aj是第一列中第j长的，而且ai<aj;

任取bi，bj，使得bi是第二列中第i长的，bj是第二列中第j长的，而且bi<bj;

若保证第i长和第i长在一起,那么这两对对答案的贡献为：ans1=(ai−bi)$^{2}$+(aj−bj)$^{2}$

若不按上述规则，那么这两对对答案的贡献为：ans2=(ai−bj)$^{2}$+(aj−bi)$^{2}$

作差：

ans1-ans2

=(ai−bi)$^{2}$+(aj−bj)$^{2}$-(aj−bi)$^{2}$-(ai−bj)$^{2}$

=-2aibi-2ajbj+2ajbi+2aibj

=-2ai(bi-bj)-2aj(bj-bi)

=-2(ai-aj)(bi-bj)<0

所以按上述规则排列，∑(ai−bi)$^{2}$最小

显然，只交换某一列，使得两列元素一一对应比较好操作，

如果第一列是按从小到大的顺序排序，显然最小操作次数就是逆序对数，你每次把一个元素向目标位置移动一步，与它有关的逆序对数就少1；

不过第一列如果是乱序，那就比较绕了，以样例二为例：
```cpp
4
1 3 4 2
1 7 2 4
```

排名为1的数在1号位，排名为3的数在2号位，排名为4的数在3号位，排名为2的数在4号位；

于是，本来正儿八经的求逆序对的树状数组是这样的：
![](https://cdn.luogu.com.cn/upload/image_hosting/hc0hlaf0.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

现在，它变成了这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/dl23neq7.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

开始插入第二列：

1的排名是1，插在1号位，无逆序对；

![](https://cdn.luogu.com.cn/upload/image_hosting/vxi46xhf.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

7的排名是4，插在3号位，无逆序对；

![](https://cdn.luogu.com.cn/upload/image_hosting/npskztyk.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

2的排名是2，插在4号位，无逆序对；

![](https://cdn.luogu.com.cn/upload/image_hosting/j3tbl0cv.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

4的排名是是3，插在2号位，出现两个逆序对；

![](https://cdn.luogu.com.cn/upload/image_hosting/mrxife8b.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

至此，找出所有逆序对；

所以，在开启树状数组找逆序对之前，预处理好每个排名在树状数组的位置，即可；

AC代码10.30：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int read()
{
	int xx=0,fh=1;
	char ch=getchar();
	while(ch>'9'||ch<'0')
	{
		if(ch=='-') fh=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		xx=xx*10+ch-'0';
		ch=getchar();
	}
	return fh==-1?-xx:xx;
}
const long long mod=99999997;
struct node{
	int ys;
	int pm;
	int bh;
}a1[100010],a2[100010];
bool cmp1(node x,node y)
{
	return x.ys<y.ys;
}
bool cmp2(node x,node y)
{
	return x.bh<y.bh;
}
int yxj[100010],n;
long long tr[100010],ans;
long long qm(long long x)
{
	while(x>=mod) x-=mod;
	while(x<0) x+=mod;
	return x;
}
int lbt(int x)
{
	return x&-x;
}
void xg(int i,long long x)
{
	for(;i<=n;i+=lbt(i))
	tr[i]=qm(tr[i]+x);
}
long long xw(int i)
{
	long long sum=0;
	for(;i>0;i-=lbt(i))
	sum=qm(sum+tr[i]);
	return sum;
}
int main()
{
	n=read();
	for(int i=1;i<=n;++i) a1[i].ys=read(),a1[i].bh=i;
	for(int i=1;i<=n;++i) a2[i].ys=read(),a2[i].bh=i;
	sort(a1+1,a1+1+n,cmp1);
	sort(a2+1,a2+1+n,cmp1);
	for(int i=1;i<=n;++i) 
	yxj[i]=a1[i].bh;
	for(int i=1;i<=n;++i) a2[i].pm=i;
	sort(a2+1,a2+1+n,cmp2);
	for(int i=1;i<=n;++i)
	{
		xg(yxj[a2[i].pm],1);
		ans=qm(ans+xw(n)-xw(yxj[a2[i].pm]));
	}
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：封禁用户 (赞：8)

### 题目分析
目标是使两列火柴之间的距离 $\sum(a_i - b_i)^2$ 最小。根据数学知识，当两列火柴高度的顺序一致时，该距离能取到最小值。例如，若将第一列火柴高度按从小到大排序后为，第二列火柴高度按从小到大排序后为，此时两列火柴之间的距离最小。

### 具体步骤
 - 记录下标与排序：分别对两列火柴的高度数组和进行排序，同时记录每个元素在原数组中的下标。这一步是为了后续构建映射关系。

 - 构建映射数组：依据第一列火柴排序后的下标顺序，在第二列火柴中找到对应的元素下标，构建一个新的数组。也就是说，表示在第二列火柴中，应该与第一列火柴中第个位置元素对应的元素的下标。

 - 计算逆序对：对构建好的数组计算逆序对的数量。逆序对的数量就是将两列火柴调整为相同顺序所需的最少交换次数。这里使用归并排序来高效地计算逆序对数量。

### 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod = 99999997;
long long n, ans, x[100005], c[100005];
struct fire {
	int v, idx;
} a[1000005], b[1000005];
bool cmp(fire x, fire y) {
	return x.v < y.v;
}
void gb(int l, int r) {
	if (l == r) return;
	int m = (l + r) / 2;
	gb(l, m);
	gb(m + 1, r);
	for (int i = l, j = m + 1, k = l; i <= m || j <= r; ) {
		if (i <= m && (x[i] <= x[j] || j > r)) {
			c[k++] = x[i++];
		} else {
			c[k++] = x[j++];
			ans += (m - i + 1) % mod;
		}
	}
	for (int i = l; i <= r; i++)
		x[i] = c[i];
}
signed main() {
	scanf("%lld", &n);
	for(int i = 1; i <= n; i++)
		scanf("%lld", &a[i].v), a[i].idx = i;
	for(int i = 1; i <= n; i++)
		scanf("%lld", &b[i].v), b[i].idx = i;
	sort(a + 1, a + n + 1, cmp);
	sort(b + 1, b + n + 1, cmp);
	for(int i = 1; i <= n; i++)
		x[b[i].idx] = a[i].idx;
	gb(1, n);
	printf("%lld", ans % mod);
	return 0;
}
```

---

## 作者：gdz0214_and_zxb0214 (赞：7)

## 思路
离散化 加 对换 加 归并求逆序对。

注意对换：数组 ${s3}^{}_{i}$ 为数组 ${s1}^{}_{i}$ 在数组 ${s2}$ 的排名。

再给 ${s3}$ 归并求逆序对。意在求出把 ${s3}$ 变为类似 $(1\space2\space3\space4\space5....)$ 的改变次数。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int mod=1e8-3;
int n,s[100010],s2[100010],k[100010],lc[100010],m;
map<int,int> vis;
int cnt=0;
void GB(int bn,int ed){
	if(bn==ed){
		return;
	}
	int mid=(bn+ed)/2;
	int l=bn,r=mid+1,dj=bn;
	GB(l,mid);
	GB(r,ed);
	while(l<=mid&&r<=ed){
		if(s[l]>s[r]){
			lc[dj++]=s[r++];
			cnt=(cnt+(mid-l+1))%mod;
		}else{
			lc[dj++]=s[l++];
		}
	} 
	while(l<=mid){
		lc[dj++]=s[l++];
	} 
	while(r<=ed){
		lc[dj++]=s[r++];
	}
	for(int i=bn;i<=ed;i++){
		s[i]=lc[i];
	}
	return;
} 
signed main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++){
		scanf("%lld",s+i);
		k[i]=s[i];
	}
	sort(k+1,k+1+n);
	m=unique(k+1,k+1+n)-k-1;
	for(int i=1;i<=n;i++){
		s[i]=lower_bound(k+1,k+1+m,s[i])-k;
	}
	for(int i=1;i<=n;i++){
		scanf("%lld",s2+i);
		k[i]=s2[i];
	}
	sort(k+1,k+1+n);
	m=unique(k+1,k+1+n)-k-1;
	for(int i=1;i<=n;i++){
		s2[i]=lower_bound(k+1,k+1+m,s2[i])-k;
		vis[s2[i]]=i;
	}
	for(int i=1;i<=n;i++){
		s[i]=vis[s[i]];
	}
	GB(1,n);
	printf("%lld",cnt);
}
```
## 参考题目
- [P1908](https://www.luogu.com.cn/problem/P1908)
- [U524212](https://www.luogu.com.cn/problem/U524212)

---

## 作者：suzhikz (赞：5)

首先，先看什么情况是最优的，显然一定是按照排名一一对应，也就是两个数在两个序列中的排名要相同，这个是可以证明的。很简单就不放了。

那我们就要移动使得他们的排名一一对应，我们先排序，然后把第二个序列改成排名和他相同的第一个序列的数原来的位置。这样操作完后，每个位置的值就是要移动到的位置，而且整个序列恰好是按顺序排的，所以可以转换成球逆序对，然后就是很板子的东西了。交换次数等于逆序对个数，可以拿树状数组维护。

放下代码。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
const int MOD=99999997; 
int tree[N],a[N],b[N];
int q[N];
struct node{
	int ID,w;
}aa[N],bb[N];
int n;
long long ans;
bool cmp(node x,node y){
	if(x.w==y.w)return x.ID<y.ID;
	else
	return x.w<y.w;
}
int lowbit(int x){
	return x&-x;
}
void update(int x,int d){
	while(x<=n){
		tree[x]+=d;
		x+=lowbit(x);
	}
}
int sum(int x){
	int ans=0;
	while(x){
		ans+=tree[x];
		x-=lowbit(x);
	}
	return ans;
}

int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		aa[i].ID=i;
		aa[i].w=a[i];
	}
	for(int i=1;i<=n;i++){
		cin>>b[i];
		bb[i].ID=i;
		bb[i].w=b[i];
	}
	sort(aa+1,aa+1+n,cmp);
	sort(bb+1,bb+1+n,cmp);
	for(int i=1;i<=n;i++)q[aa[i].ID]=bb[i].ID;
	for(int i=n;i>0;i--){
		update(q[i],1);
		ans=ans+sum(q[i]-1);
	  ans%=MOD;
	}
	cout<<ans;
	return 0;
}

```

---

## 作者：__Accepted_ZYF__ (赞：3)

题目有一个式子：$\sum_{i=1}^n(a_i-b_i)^2$。

我们拆一下，原式变为 $\sum_{i=1}^n a_i^2-2a_ib_i+b_i^2$。

再拆一次，得 $\sum_{i=1}^n a_i^2 + \sum_{i=1}^n b_i^2 - 2\sum_{i=1}^n a_ib_i$。

显然，让 $\sum_{i=1}^n(a_i-b_i)^2$ 最小化，就要让 $\sum_{i=1}^n a_ib_i$ 最大化。

我们发现，排完序后，$\sum_{i=1}^n a_ib_i$ 最大化。

之后逆序对即可通过。


```cpp
//2022tysc0819
#include<bits/stdc++.h>
//#include<bits/extc++.h>
using namespace std;
//using namespace __gnu_pbds;
//#define arr array<int,3>
#define int long long
//#define pb push_back
//#define double long double
//#define map unordered_map
//#pragma GCC optimize(2,3,"Ofast","inline")
const int N=2e5+10,M=1010,P=99999997,MOD=998244353;
const double PI=3.1415926,EPS=0.00001;
struct nid{int v,i;}a[N],b[N];
bool operator<(nid x,nid y){return x.v<y.v;}
int n,tr[N],su,ans,r[N];
int lb(int x){return x&-x;}
void upd(int p,int x){for(int i=p;i<=n;i+=lb(i))tr[i]+=x;}
int s(int x){su=0;for(int i=x;i>0;i-=lb(i)){su+=tr[i];}return su;}
signed main(){
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i].v,a[i].i=i;
    for(int i=1;i<=n;i++)cin>>b[i].v,b[i].i=i;
    sort(a+1,a+n+1);
    sort(b+1,b+n+1);
    for(int i=1;i<=n;i++)r[b[i].i]=a[i].i;
    for(int i=1;i<=n;i++){
        upd(r[i],1);
        ans=(ans+i-s(r[i])+P)%P;
    }
    cout<<ans;
    return 0;
}
//note:
```

---

## 作者：DiaoHantong (赞：3)

## [题目传送门](https://www.luogu.com.cn/problem/P1966)

### 思路
首先观察要最小化的式子 $\sum (a_i-b_i)^2$，由于 $(a_i-b_i)^2=a_i^2+b_i^2-2a_ib_i$，所以有 $\sum(a_i-b_i)^2 =\sum(a_i^2+b_i^2-2a_ib_i)=\sum a_i^2+\sum b_i^2-2\sum a_ib_i$。

由于 $\sum a_i^2$ 和 $\sum b_i^2$ 无论如何排列火柴都不会改变，所以问题转化为最大化 $\sum a_ib_i$。可以证明，把两个序列排序后，对每个 $k$，将第 $k$ 小的 $a_k$ 元素与第 $k$ 小的 $b_k$ 元素配对，这样得到的 $\sum a_ib_i$ 是最大的。

然后考虑如何计算答案，可以发现在第 $1$ 列交换和在第 $2$ 列中交换是等价的，所以只考虑对一列进行交换。

首先排序，然后计算出两个数组 $c_i$ 和 $d_i$， $c_i$ 表示第 $1$ 列中第 $i$ 个元素在第 $1$ 列中是第 $c_i$ 大的， $d_i$ 表示第 $2$ 列中第 $i$ 个元素在第 $2$ 列中是第 $d_i$ 大的。由此，问题便转化为至少需要交换多少个相邻元素，使得 $c_i$ 序列变成 $d_i$ 序列。

这里由于两个数组都是一个排列，所以可以先做一个映射，然后就用归并排序求逆序对就可以了。

### 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+1;
const int mod=1e8-3;
int a[N],b[N],c[N],d[N],r[N];
long long ans=0;
map<int,int> ai;
map<int,int> bi;
map<int,int> m;
void read(int &x){ 
	int f=1;x=0;char s=getchar();
	while(s<'0'||s>'9'){if(s=='-')f=-1;s=getchar();}
	while(s>='0'&&s<='9'){x=x*10+s-'0';s=getchar();}
	x*=f;
}
void msort(int left,int right){//归并排序求逆序对
    if(left==right)return;
    int mid=(left+right)/2;
    msort(left,mid);
    msort(mid+1,right);
    int i=left,j=mid+1,k=left;
    while(i<=mid&&j<=right){
        if(a[i]<=a[j]){
            r[k]=a[i];
            k++;
            i++;
        }else{
            r[k]=a[j];
            k++;
            j++;
            ans=(ans+mid-i+1)%mod;//记得取模
        }
    }
    while(i<=mid){
        r[k]=a[i];
        k++;
        i++;
    }
    while(j<=right){
        r[k]=a[j];
        k++;
        j++;
    }
    for(int i=left;i<=right;i++) a[i]=r[i];
}
int main(){
    int n;
    cin>>n;
    for(int i=1;i<=n;i++){
        read(a[i]);
        c[i]=a[i];//记录c[i]
        ai[a[i]]=i;
    }
    for(int i=1;i<=n;i++){
        read(b[i]);
        d[i]=b[i];//记录d[i]
        bi[b[i]]=i;
    }
    sort(c+1,c+1+n);
    sort(d+1,d+1+n);
    for(int i=1;i<=n;i++){
        b[bi[d[i]]]=i;
        a[ai[c[i]]]=i;
    }
    for(int i=1;i<=n;i++)m[b[i]]=i;//映射
	for(int i=1;i<=n;i++)a[i]=m[a[i]];
	msort(1,n);//求逆序对
	printf("%lld",ans%mod);
    return 0;
}
```

---

## 作者：LiJunze0501 (赞：3)

# 涉及知识点
逆序对、离散化。  
由题目分析得出本题要求逆序对，所以要么用树状数组，要么用归并。因为作者知识点欠缺，所以用了归并。  
离散化是因为火柴高度较大。顺便一提，数据大时就该用那个数据结构了！
# 分解
## 定义
```cpp
const int mod=1e8-3;//取模的数
long long n;//一列火柴数量
long long a[100001],r[100001];//归并模板需要
long long ans;//记录最终答案
struct hc{//火柴
    int h,id;//h是高度，id是编号，用于离散化
}lo[100001],lt[100001];
```
## 初始化（读入+离散化）
读入单列火柴数量和两列火柴的高度，并将每个火柴的编号设置。
```cpp
cin>>n;
for(int i=1;i<=n;i++){
    cin>>lo[i].h;//第一列
    lo[i].id=i;//离散化
}
for(int i=1;i<=n;i++){
    cin>>lt[i].h;//第二列
    lt[i].id=i;
}
```
## 排序
按高度从低向高排。
```cpp
bool cmp(hc a,hc b){
    return a.h<b.h;
}
int main(){
    ...（上述内容）
    sort(lo+1,lo+n+1,cmp);
    sort(lt+1,lt+n+1,cmp);
}
```
~~为归并操作奠定基础。~~
## 归并+输出
敲重点！！！  
程序中最重要的一部分，在归并过程中记录答案。
```cpp
void msort(int s,int e){//小板子
    if(s==e)return ;
    int mid=(s+e)/2;
    msort(s,mid);//左半边
	msort(mid+1,e);//右半边
    int i=s,k=s,j=mid+1;
    while(i<=mid&&j<=e)
        if(a[i]<=a[j]){//不需排序
            r[k]=a[i];
			i++;//指针移动
            k++;
        }
        else{//需排序
            r[k]=a[j];
			j++;
            k++;
            ans=(ans+mid-i+1)%mod;//ans加上mid至i之间数的数量，记得取模！
		}
    //以下都是板子
    while(i<=mid){
        r[k]=a[i];
        k++;
		i++;
    }
    while(j<=e){
        r[k]=a[j];
        k++;
		j++;
    }
    for(int i=s;i<=e;i++) a[i]=r[i];
}
int main(){
    ...（上述内容）
    for(int i=1;i<=n;i++) a[lt[i].id]=lo[i].id;//按编号排 
    msort(1,n);//归并
    cout<<ans<<endl;
}
```
# 最终代码
注释看上面的分解。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=1e8-3;
long long n,a[100001],r[100001],ans;
struct hc{
    int h,id;
}lo[100001],lt[100001];
bool cmp(hc a,hc b){
    return a.h<b.h;
}
void mergesort(int s,int e){
    if(s==e)return ;
    int mid=(s+e)/2;
    mergesort(s,mid);
	mergesort(mid+1,e);
    int i=s,k=s,j=mid+1;
    while(i<=mid&&j<=e)
        if(a[i]<=a[j]){
            r[k]=a[i];
            k++;
			i++;
        }
        else{
            r[k]=a[j];
            k++;
			j++;
            ans=(ans+mid-i+1)%mod;
		}
    while(i<=mid){
        r[k]=a[i];
        k++;
		i++;
    }
    while(j<=e){
        r[k]=a[j];
        k++;
		j++;
    }
    for(int i=s;i<=e;i++) a[i]=r[i];
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>lo[i].h;
        lo[i].id=i;
    }
    for(int i=1;i<=n;i++){
        cin>>lt[i].h;
        lt[i].id=i;
    }
    sort(lo+1,lo+n+1,cmp);
    sort(lt+1,lt+n+1,cmp);
    for(int i=1;i<=n;i++) a[lt[i].id]=lo[i].id; 
    mergesort(1,n);
    cout<<ans<<endl;
}
```
第一篇蓝题题解，管理大大求过。

---

## 作者：i_cookie (赞：3)

### 分析
如果问我需要多少次交换能把一个序列排好序,我就可以直接用归并排序求逆序对.但是本题不走寻常路.我们先来分析一下题目.

题目要求$\sum_{i=1}^{n}(a_i-b_i)^2$最小.我们应该把什么样的局面作为目标呢?类似于邻项交换类的贪心问题,假设我们有$a_1,a_2,b_1,b_2$这两个数组.其中$a_1< a_2,b_1< b_2$.现在我们有两种选择:
1. 把$a_1$和$b_1$配对,那么两列火柴的距离就是$(a_1^2+b_1^2+a_2^2+b_2^2)-2(a_1b_1+a_2b_2)$
2. 把$a_1$和$b_2$配对,那么两列火柴的距离就是$(a_1^2+b_1^2+a_2^2+b_2^2)-2(a_1b_2+a_2b_1)$

两式相减,不考虑常数,我们得到$-(a_1b_1+a_2b_2)+(a_1b_2+a_2b_1)$如果第二种选择比第一种选择得到的距离要更小,就意味着

$a_1b_2+a_2b_1>a_1b_1+a_2b_2$

$\Rightarrow a_1(b_2-b_1)>a_2(b_2-b_1)$

$\Rightarrow a_1> a_2$

这不就矛盾了吗?所以假设不成立.那么只有把$a$种第$i$小的和$b$中第$i$小的排在相同的位置才行.换句话说,我们就要通过交换使得**离散化后**的$a_i=b_i$.当然了,离散化只是为了体现出排名,我们也可以进行其他的操作来达到相同的目的.

比如,我们设有一个函数$q()$,这个函数的功能是这样的:如果输入原$a$数列中第$i$小的数的位置,它就会返回原$b$数列中第$i$小的数的位置.这样就把两个应该相等化的值联系起来了.然后我们发现由于原序列已经给定,我们可以预处理出$q()$函数的可能的值,使得它变成$q[]$数组.具体怎么做呢?

我们用结构体的形式来储存两列火柴,结构体保存每根火柴的高度和在原序列中的下标.然后按照高度从小到大排序.这样得到的下标序列$a[i].ind$的意义就是原序列中第$i$小的数所在的位置.对b做同样的处理后,我们的$q$数组该怎么处理就显而易见了.输入$a[i].ind$返回$b[i].ind$,也就是$q[a[i].ind]=b[i].ind$.

如果我们通过交换来修改原序列,那么$a[i].ind$的值就会发生变化,$q$的值也会发生变化.我们最终的目的是$a[i].ind=b[i].ind$,那么就有$q[a[i].ind]=a[i].ind$即$q[k]=k(k=a[i].ind)$.这样一看,不就是让$q[1]=1,q[2]=2...$,把$q$排好序吗?而我们只能交换相邻项,所以求出$q$的逆序对个数就是答案了.

### 代码:
``` cpp
#include <cmath>
#include <queue>
#include <deque>
#include <cctype>
#include <string>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define mod 9999997
#define int long long
using namespace std;

template<class T> inline void read(T &x) {
    x = 0;
    char ch = getchar(), w = 0;
    while (!isdigit(ch)) w = (ch == '+'), ch = getchar();
    while (isdigit(ch)) x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
    x = w ? x : x;
    return;
}

int n, q[100000], temp[100000], cnt;

struct node {
    int val, ind;
}a[100000], b[100000];

inline bool cmp1(node x, node y) {
    return x.val < y.val;
}

inline bool cmp2(node x, node y) {
    return x.val < y.val;
}

void merge_sort(int l, int r) {
    if (l == r) return;
    int mid = l + r >> 1;
    merge_sort(l, mid);
    merge_sort(mid + 1, r);
    int i = l, j = mid + 1, t = l;
    while (i <= mid && j <= r) {
        if (q[i] <= q[j])
            temp[t] = q[i], i++;
        else {
            temp[t] = q[j], j++;
            cnt += (mid - i + 1);
            cnt %= mod;
        }
        t++;
    }
    while (i <= mid)
        temp[t] = q[i], t++, i++;
    while (j <= r)
        temp[t] = q[j], t++, j++;
    for (int k = l; k <= r; ++k)
        q[k] = temp[k];
    return;
}

signed main() {
    read(n);
    for (int i = 1; i <= n; ++i)
        read(a[i].val), a[i].ind = i;
    for (int i = 1; i <= n; ++i)
        read(b[i].val), b[i].ind = i;
    sort(a + 1, a + 1 + n, cmp1);
    sort(b + 1, b + 1 + n, cmp2);
    for (int i = 1; i <= n; ++i)
        q[a[i].ind] = b[i].ind;
    merge_sort(1, n);
    cout << cnt << endl;
    return;
}
// 拒绝抄袭,从我做起
```

本题思路真是非常巧妙,尤其是$q$数组的设想,蒟蒻的我也是参考了好多题解和思路才得到了这种理解.思维的灵活性是真的重要啊.

---

## 作者：Perfect_Youth (赞：2)

本题感觉很一眼。

数据范围火柴高度很大，但 $n$ 不是很大，所以考虑离散化。

我们可以把这个式子拆开 $\sum(a_i-b_i)^2$，由于根据公式 $(a-b)^2=a^2-2ab+b^2$，所以 $\sum(a_i-b_i)^2=\sum(a_i^2-2a_ib_i+b_i^2)=\sum a_i^2-2\sum a_ib_i+\sum b_i^2$。

由于 $\sum a_i^2$ 和 $\sum b_i^2$ 的值不变，所以问题变成最大化 $2\sum a_ib_i$。可以证明你排完序后，对于一个 $i$，$a_i$ 和 $b_i$ 配对，此时 $2\sum a_ib_i$ 是最大的。

所以这个问题变成求逆序对了。

代码如下：
```cpp
#include <bits/stdc++.h>
#define getchar()(p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1 , 1 << 21, stdin), p1 == p2) ? EOF : *p1++)
char buf[1 << 21], *p1 = buf, *p2 = buf;

using namespace std;

template <typename T>

inline
T read() {
	T x = 0, f = 1;
	char ch = getchar();
	while (ch < '0' or ch > '9') {
		if (ch == '-') f = -1;
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9') {
		x = (x << 1) + (x << 3) + (ch ^ '0');
		ch = getchar();
	}
	return x * f;
}

const int N = 1e5 + 7, Mod = 1e8 - 3;

int n, x[N], c[N], ans;

struct node {
	int x, idx;
}a[N], b[N];

inline
bool cmp(node u, node v) {
	return u.x < v.x;
}

inline
void merge_sort(int l, int r) {
	if (l == r) return ;
    int mid = l + r >> 1;
    merge_sort(l, mid);
    merge_sort(mid + 1, r);
    int i = l, j = mid + 1, k = l;
    while (i <= mid && j <= r) {
        if (x[i] <= x[j]) {
            c[k++] = x[i++];
        } else {
            c[k++] = x[j++];
            ans = (ans + mid - i + 1) % Mod;
        }
    }
    while (i <= mid) c[k++] = x[i++];
    while (j <= r) c[k++] = x[j++];
    for (int i = l; i <= r; i++) x[i] = c[i];
}

int main() {
	n = read<int>();
	for (int i = 1; i <= n; i++) {
		a[i].x = read<int>();
		a[i].idx = i;
	}
	for (int i = 1; i <= n; i++) {
		b[i].x = read<int>();
		b[i].idx = i;
	}
	sort(a + 1, a + 1 + n, cmp);
	sort(b + 1, b + 1 + n, cmp);
	for (int i = 1; i <= n; i++) x[b[i].idx] = a[i].idx;
	merge_sort(1, n);
	printf ("%d", ans);
	return 0;
}
```

---

## 作者：WsW_ (赞：2)

### 思路
注意到“每列火柴中相邻两根火柴的位置都可以交换”，根据冒泡排序原理，这相当于我们可以随意重排两列火柴。  

先给出结论，将两列火柴都按大小顺序排序后距离最小。这是贪心的思想，我们利用经典的邻项交换法来证明这个结论。  
已知 $a_1\le a_2, b_1\le b_2$，求证 $(a_1-b_1)^2+(a_2-b_2)^2\le (a_1-b_2)^2+(a_2-b_1)^2$。  
拆式子，合并同类项，得 $左式=-2(a_1 b_1+a_2 b_2),右式=-2(a_1 b_2+a_2 b_1)$。所以要证明结论，即要证明 $a_1 b_1+a_2 b_2\ge a_1 b_2+a_2 b_1$。合并同类项，即要证明 $a_2(b_2-b_1)\ge a_1(b_2-b_1)$。因为 $b_2-b_1\ge 0, a_2\ge a_1$，所以原式得证。  

实际上并不需要重排两列火柴，只需要让两列火柴大小一一对应即可。把第一列火柴映射成一个有序数列，第二列也根据这个映射方法映射成一个数列，原问题就变成了要让第二列火柴排序。将一个数列排序，每次可以交换相邻两项，求最小交换次数，就变成了最经典的求逆序对数量。  

求逆序对数量可以使用归并排序和树状数组等算法求解，经典模板我不做过多解释。  
时间复杂度为 $O(n\log n)$。  

---
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> pii;
typedef long long ll;
#define lowbit(x) (x&-x)
const int MAXN=1e5+5;
const int mod=1e8-3;

int n;
pii a[MAXN];
int b[MAXN];
vector<pii>va;
vector<int>vb;
ll ans;
map<int,int>mp;
int mpcnt;
int t[MAXN];
ll query(int x){
	ll ans=0;
	while(x){
		ans+=t[x];
		x-=lowbit(x);
	}
	return ans;
}

void insert(int x){
	while(x<=n){
		t[x]++;
		x+=lowbit(x);
	}
}

int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i].first;
		a[i].second=i;
		va.push_back(a[i]);
	}
	for(int i=1;i<=n;i++){
		cin>>b[i];
		vb.push_back(b[i]);
	}
	sort(va.begin(),va.end());
	sort(vb.begin(),vb.end());
	vb.erase(unique(vb.begin(),vb.end()),vb.end());
	
	for(int i=1;i<=n;i++){
		int x=lower_bound(va.begin(),va.end(),a[i])-va.begin();
		mp[x]=++mpcnt;
	}
	for(int i=n;i>0;i--){
		int x=lower_bound(vb.begin(),vb.end(),b[i])-vb.begin();
		x=mp[x];
		insert(x+1);
		(ans+=query(x))%=mod;
	}
	
	cout<<ans;
	return 0;
}
```

---

## 作者：XCDRF_ (赞：2)

# P1966 \[NOIP2013 提高组] 火柴排队

[原题传送门](https://www.luogu.com.cn/problem/P1966)

[更好的阅读体验](https://www.luogu.com.cn/article/devzh0b6)

## 题目大意

给定两个序列 $a_{1,2,\dots,n},b_{1,2,\dots,n}$，保证 $\forall 1\le i<j\le n,a_i≠a_j,b_i≠b_j,0\le a_i,b_i<2^{31}$。每次操作可交换任意序列任意相邻两个位置。求使 $\sum^n_{i=1}(a_i-b_i)^2$ 取得最小值的最小操作次数，答案对 $10^8-3$ 取模。

## 解题思路

如何取得最小值？应该可以想到，两序列中数字大小排名相同的数在一起时，$\sum^n_{i=1}(a_i-b_i)^2$ 最小。

为什么呢？我们还需要证明一下。

设 $a_x$ 为 $a$ 序列中第 $x$ 大的数，$b_x$ 为 $b$ 序列中第 $x$ 大的数。

则 $\forall 1\le i<j\le n,a_i<a_j,b_i<b_j$。

此时有两种情况，记顺序情况对答案贡献为 $ans1$，乱序情况对答案贡献为 $ans2$。

作差可得：
$$\begin{aligned} ans1-ans2 &= (a_i−b_i)^2+(a_j−b_j)^2-(a_j−b_i)^2-(a_i−b_j)^2
 \\ &= 2a_ib_j+2a_jb_i-2a_ib_i-2a_jb_j \\ &= 2a_i(b_j-b_i)+2a_j(b_i-b_j) \\ &= -2(a_i-a_j)(b_i-b_j)<0 \end{aligned}$$

所以两序列中数字大小排名相同的数在一起时，答案最优。

现在的问题就转化成了使两序列中数字大小排名相同的数在一起所需的最小操作次数。

同时交换两个序列不好考虑，考虑只交换一个序列，使两序列相对顺序相同。

因为值域过大，且只需要相对顺序，考虑先将两序列离散化。

设 $t_{a_i}=i$，则 $b_i$ 应转移到 $t_{b_i}$。让 $t_{b_i}\to b_i$，则问题又转化为了使 $b$ 顺序的次数，求 $b$ 的逆序对数即可。

## 参考代码

```cpp
#include<iostream>
#include<algorithm>
#define lowbit(i) (i&(-i))
using namespace std;
const int N=1e5+5,mod=1e8-3;
int n,ans;
int a[N],b[N],A[N],B[N],t[N];
struct BIT{
	int c[N];
	void add(int x,int y){
		for(;x<N;x+=lowbit(x)) c[x]=(0ll+c[x]+y)%mod;
	} 
	int ask(int x){
		int ans=0;
		for(;x;x-=lowbit(x)) ans=(0ll+ans+c[x])%mod;
		return ans;
	}
}TR;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i],A[i]=a[i];
	for(int i=1;i<=n;i++) cin>>b[i],B[i]=b[i];
	sort(A+1,A+n+1);
	sort(B+1,B+n+1);//因为两两不相同，所以没必要去重
	for(int i=1;i<=n;i++){
		a[i]=lower_bound(A+1,A+n+1,a[i])-A;
		b[i]=lower_bound(B+1,B+n+1,b[i])-B;
	}
	for(int i=1;i<=n;i++) t[a[i]]=i;
	for(int i=1;i<=n;i++) b[i]=t[b[i]];
	for(int i=n;i;i--){
		ans=(0ll+ans+TR.ask(b[i]-1))%mod;
		TR.add(b[i],1); 
	}
	cout<<ans;
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/198919250)

---

## 作者：孙子隆 (赞：2)

今日刷到好题p1966实在是好题

先看题目

涵涵有两盒火柴，每盒装有 nn 根火柴，每根火柴都有一个高度。 现在将每盒中的火柴各自排成一列， 同一列火柴的高度互不相同， 两列火柴之间的距离定义为： \sum (a_i-b_i)^2∑(a 
i
​	 −b 
i
​	 ) 
2
 
其中 a_ia 
i
​	  表示第一列火柴中第 i i个火柴的高度，b_ib 
i
​	 表示第二列火柴中第 ii 个火柴的高度。

每列火柴中相邻两根火柴的位置都可以交换，请你通过交换使得两列火柴之间的距离最小。请问得到这个最小的距离，最少需要交换多少次？如果这个数字太大，请输出这个最小交换次数对 99,999,997 99,999,997取模的结果。

输入输出格式
输入格式：
共三行，第一行包含一个整数 nn，表示每盒中火柴的数目。

第二行有 n n个整数，每两个整数之间用一个空格隔开，表示第一列火柴的高度。

第三行有 nn 个整数，每两个整数之间用一个空格隔开，表示第二列火柴的高度。

输出格式：
一个整数，表示最少交换次数对 99,999,99799,999,997 取模的结果


# **首先是没有思路的**
~~然后我们偷看了一下算法标签~~
# 树状数组和归并排序

树状数组大法好！！！！！！


∑(ai​−bi​)^2考虑将这个展开
得到的是ai^2+bi^2-2ai*bi

然后ai^2+bi^2是定值
可以从2ai*bi上走了

直接就可以往max上边想

话说这个的最大值该怎么求呢？？？？

## 接下来思路诞生 直接就是处理max

## 然后又走进了死循环

~~偷瞄一下大佬的题解~~

# 偷来的~~证明~~

如果a<b c<d
则猜测ac+bd为最大的
如果ac+bd不是最大的
那么一定有比他大的
只有ad+bc
ac+bd<ad+bc

ac-ad<bc-bd
            
a*(c-d)<b*(c-d)//c-d<0

a>b不成立
# 排序思路随即而出

同时题目要求的是求交换次数
这样我们就可以明明白白的写逆序对问题了


## 思路而出

数组开不出来
离散化出来帮忙

转头走向样例

A：2 3 1 4->1 2 3 4对应原编号为：3 1 2 4
B：3 2 1 4->1 2 3 4对应原编号为：3 2 1 4
于是发现二个顺序差一个
就是逆序对

于是用一个数组map映射的小东西
此map非彼map

即为
map[B[i]编号]=A[i]编号
若题目为例
则map[1]=2,map[2]=1,map[3]=3,map[4]=4;
共有一个逆序对，交换次数++


# 这样题目就转化成了逆序对的计算

## 有两种解法
### 一个是树状数组
### 一个是归并排序
~~反正我都不会~~

教学自行
https://www.cnblogs.com/chengxiao/p/6194356.html

树状数组求逆序对
https://blog.csdn.net/m0_38033475/article/details/80330157

代码就算了
emmmmmm
溜了溜了







---

## 作者：Ngo123 (赞：1)

首先对于题目要求：要使得两列火柴之间的距离和最小，即要每对火柴之间的高度尽可能的近。

由于火柴高度是 int 范围内的，因此我们要先对两个数组进行离散化操作。

那么我们其实就是让 $b$ 数组尽可能的符合 $a$ 数组原本的顺序。

由于 $a$ 数组是无序的，因此我们通过映射的方式将 $a$ 数组映射为有序的。

映射操作的代码是这样的，因为 $a$ 数组已经做了离散化，所以新开一个数组 $c$ 映射即可。

`for(int i = 1;i<=n;i++) c[a[i]] = i;`

我是通过归并排序来求逆序对，时间复杂度为 $O(n \log n)$。

这是我的代码：
```
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5+5,mod = 99999997;
int a[N],b[N],c[N],p[N],n;
void work(int a[])
{
    for(int i = 1;i<=n;i++) p[i] = a[i];
    sort(p+1,p+n+1);
    for(int i = 1;i<=n;i++) a[i] = lower_bound(p+1,p+n+1,a[i])-p;
}
int merge_sort(int l,int r)
{
    if(l >= r) return 0;
    int mid = l+r>>1;
    int res =(merge_sort(l,mid)+merge_sort(mid+1,r))%mod;
    int i = l,j = mid+1,k = 0;
    while(i <= mid && j <= r)
    {
        if(b[i] <= b[j]) p[++k] = b[i++];
        else
        {
            res = (res+mid-i+1)%mod;
            p[++k] = b[j++];
        }
    }
    while(i <= mid) p[++k] = b[i++];
    while(j <= r) p[++k] = b[j++];
    for(int i = l;i<=r;i++) b[i] = p[i-l+1];
    return res;
}
int main()
{
    cin>>n;
    for(int i = 1;i<=n;i++) cin>>a[i];
    for(int i = 1;i<=n;i++) cin>>b[i];
    work(a); work(b);
    for(int i = 1;i<=n;i++) c[a[i]] = i;
    for(int i = 1;i<=n;i++) b[i] = c[b[i]];
    cout << merge_sort(1,n) << endl;
    return 0;
}
```

---

## 作者：never_knew (赞：1)

先要想明白一点，如果 $A \le B$ 并且 $a \le b$，则 $$ \lvert A-a \lvert + \lvert B-b \lvert \le \lvert A-b \lvert +\lvert B-a \lvert$$。

（此处为后面加上的补充）明白这一点，那我们就要思考，怎样让这个式子变的更小，当然是让每一项变得平均，所以我们就依次匹配，这样得出的答案就是最小的。

那么这题就转化成求逆序对了。

[逆序对求法](https://www.luogu.com.cn/article/new9z8cn)。

而在这题中，我们可以多开一个 map 存储顺序，只对一边修改。

```c++
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+1,mod=1e8-3;
map<int,int> mp;
int e[N],f[N],g[N];
bool cmp1(int x,int y)
{
	if(e[x]==e[y])
	{
		return x>y;
	}
	else
	{
		return e[x]>e[y];
	}
}
int main()
{
    int n;
    cin>>n;
    string c,d;
    cin>>c>>d;
	for(int i=1;i<=n;i++)
	{
		mp[c[i]]=i;
	}
	for(int i=1;i<=n;i++)
	{
		e[i]=mp[d[i]];
		f[i]=i;
	}
	sort(f+1,f+n+1,cmp1);
	int cnt=0;
	for(int i=1;i<=n;i++) 
	{
		int q=f[i];
		while(q<=n)
		{
			g[q]++;
			q+=(q&(-q));
		}
		q=f[i]-1;
		while(q)
		{
			cnt+=g[q];
			cnt%=mod;
			q-=(q&(-q));
		}
	}
	cout<<n-cnt;
    return 0;
}
```

---


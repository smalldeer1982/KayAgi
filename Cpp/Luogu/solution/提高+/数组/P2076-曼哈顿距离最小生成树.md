# 曼哈顿距离最小生成树

## 题目背景

题目修改自 [Library Checker](https://judge.yosupo.jp/problem/manhattanmst)，及[数据生成器 / 校验器来源](https://github.com/yosupo06/library-checker-problems/tree/master/geo/manhattanmst)。

请注意原题所有下标从 $0$ 开始（$0$-indexed），本题所有下标从 $1$ 开始（$1$-indexed）。

## 题目描述

给定平面上的 $n$ 个点 $(x_1,y_1),(x_2,y_2),\ldots,(x_n,y_n)$。

考虑一个有 $n$ 个结点的完全图，对于 $1\le u,v\le n(u\ne v)$，结点 $u,v$ 之间有一条权值为 $|x_u-x_v|+|y_u-y_v|$ 的边。

请求出该图的最小生成树。

## 说明/提示

对于 $20\%$ 的数据，$1\le n\le 1000$。

对于 $100\%$ 的数据，$1\le n\le 2\times 10^5$，$0\le x_i,y_i\le 10^9$。

## 样例 #1

### 输入

```
6
3 8
4 9
2 1
10 5
4 9
2 0```

### 输出

```
21
5 2
6 3
1 2
3 1
4 1```

# 题解

## 作者：concert_B (赞：10)

# [曼哈顿距离最小生成树](https://www.luogu.com.cn/problem/P2076)

## 声明

本篇题解主要是 FFTotoro 大佬的思想，但由于他的代码过于高深，本人发一篇易懂的题解 233。

食用者记得先看 FFTotoro 大佬的题解，再 ~~copy~~ 欣赏易懂代码。

## 思想

Kruskal 算法 [emm](https://baidu.physton.com/?q=%E5%8E%BB%E6%99%AE%E5%8F%8A%E7%BB%84%E5%90%A7,%E8%BF%99%E4%B8%8D%E6%98%AF%E4%BD%A0%E6%94%B9%E6%9D%A5%E7%9A%84%E5%9C%B0%E6%96%B9)，与边数直接挂钩，因此完全图直接跑 Kruskal 是不理智的。

考虑到大部分边是无用的，所以用人类智慧思考哪些边有用。

结论：以一个点为原点建立直角坐标系，在每 45 度内只会向距离该点最近的一个点连边。

简单证明一下，如图，当 $x_1+y_1<x_2+y_2$ 时，原点与 $(x_2,y_2)$ 的曼哈顿距离必定最大，是无用的，丢掉。

![](https://cdn.luogu.com.cn/upload/image_hosting/jm5hsc0i.png)

## 实际考虑

为了避免重复加边，我们只考虑左半边这4个区域。

设最近点为 $(x,y)$，则对于任意该区域内其他点 $(x_i,y_i)$，有：

+ 如果点在 R1，它要满足：$x \ge x_i ,y - x \ge y_i - x_i$；
+ 如果点在 R2，它要满足：$y \ge y_i ,y - x \le y_i - x_i$；
+ 如果点在 R3，它要满足：$y \le y_i ,y + x \ge y_i + x_i$；
+ 如果点在 R4，它要满足：$x  \ge x_i ,y + x \le y_i – x_i$。

FFTotoro 大佬是用对称性变化的，本蒟蒻认为不太好理解，于是把每种情况列出来。

观察第一限制，是区间最值问题，并且一定是前缀最值，用[树状数组](https://baidu.physton.com/?q=%E5%8E%BB%E6%99%AE%E5%8F%8A%E7%BB%84%E5%90%A7,%E8%BF%99%E4%B8%8D%E6%98%AF%E4%BD%A0%E6%94%B9%E6%9D%A5%E7%9A%84%E5%9C%B0%E6%96%B9)非常方便维护。代码中只维护最小值，此时后缀即是最大值。

第二限制交给排序了。

## 复杂度

建图，包括排序及树状数组：$O(n \log n)$；

Kruskal，共建 $m=4n$ 条边：$O(m \log m)$。

在 $n\le2 \times 10^5$ 的范围内可以通过。

## code


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e5+5;
const int inf=1e18;

struct BIT{					//树状数组 
	pair<int,int> a[N<<1];
	int n;
	inline int lowbit(int x){
		return x&-x;
	}
	void init(int _){
		n=_;
		for(int i=1;i<=n;i++)
			a[i]=make_pair(inf,0);
		return;
	}
	pair<int,int> qry(int x){
		pair<int,int> res=make_pair(inf,0);
		for(;x;x-=lowbit(x))
			res=min(res,a[x]);
		return res;
	}
	void upd(int x,pair<int,int> v){
		for(;x<=n;x+=lowbit(x)){
			a[x]=min(a[x],v);
		}
		return;
	}
	pair<int,int> qry_frt(int x){	//询问前缀，返回最小 
		return qry(x);
	}
	pair<int,int> qry_bck(int x){	//询问后缀，返回最大 
		return qry(n-x+1);
	}
	void upd_frt(int x,pair<int,int> v){
		return upd(x,v);
	}
	void upd_bck(int x,pair<int,int> v){
		return upd(n-x+1,v);
	}
}tr;

int n;
struct node{
	int x,y;
	int ix,iy;	//离散后 
	int id;
	int d,s;	//d 表示 y-x，s 表示 x+y 
}p[N];
int st[N<<2],tot;


int getdis(int x,int y){	//曼哈顿距离 
	return abs(p[x].x-p[y].x)+abs(p[x].y-p[y].y);
}

struct edge{		//存边 
	int u,v,w;
	bool operator <(const edge& p) const{
		return this->w<p.w;
	}
}e[N<<2];
int cnt;

bool cmp1(node a,node b){	//4种区域 
	return a.d>b.d||(a.d==b.d&&a.x>b.x);
//	if(a.d==b.d)	return a.x>b.x;
//	return a.d>b.d;
}
bool cmp2(node a,node b){
	return a.d<b.d||(a.d==b.d&&a.x>b.x);
//	if(a.d==b.d)	return a.x>b.x;
//	return a.d<b.d;
}
bool cmp3(node a,node b){
	return a.s>b.s||(a.s==b.s&&a.y<b.y);
//	if(a.s==b.s)	return a.y<b.y;
//	return a.s>b.s;
}
bool cmp4(node a,node b){
	return a.s<b.s||(a.s==b.s&&a.y>b.y);
//	if(a.s==b.s)	return a.y>b.y;
//	return a.s<b.s;
}

void make_G(){	//建图 
	tr.init(2*n);	//初始化很重要 
	sort(p+1,p+1+n,cmp1);
	for(int i=1;i<=n;i++){
		pair<int,int> t=tr.qry_bck(p[i].ix);
		if(t.first<inf)	
			e[++cnt].u=p[i].id,e[cnt].v=p[t.second].id,e[cnt].w=getdis(i,t.second);
		tr.upd_bck(p[i].ix,make_pair(p[i].s,i)); 
	}
	
	tr.init(2*n);
	sort(p+1,p+1+n,cmp2);
	for(int i=1;i<=n;i++){
		pair<int,int> t=tr.qry_bck(p[i].iy);
		if(t.first<inf)	
			e[++cnt].u=p[i].id,e[cnt].v=p[t.second].id,e[cnt].w=getdis(i,t.second);
		tr.upd_bck(p[i].iy,make_pair(p[i].s,i)); 
	}
	
	tr.init(2*n);
	sort(p+1,p+1+n,cmp3);
	for(int i=1;i<=n;i++){
		pair<int,int> t=tr.qry_frt(p[i].ix);
		if(t.first<inf)	
			e[++cnt].u=p[i].id,e[cnt].v=p[t.second].id,e[cnt].w=getdis(i,t.second);
		tr.upd_frt(p[i].ix,make_pair(p[i].d,i)); 
	}
	
	tr.init(2*n);
	sort(p+1,p+1+n,cmp4);
	for(int i=1;i<=n;i++){
		pair<int,int> t=tr.qry_bck(p[i].iy);
		if(t.first<inf)	
			e[++cnt].u=p[i].id,e[cnt].v=p[t.second].id,e[cnt].w=getdis(i,t.second);
		tr.upd_bck(p[i].iy,make_pair(p[i].d,i)); 
	}
	
	return;
}

int fa[N];		//路径压缩并查集 
int find(int x){
	if(fa[x]==x)	return x;
	return fa[x]=find(fa[x]);
}

signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>p[i].x>>p[i].y;
		p[i].id=i;
		p[i].d=p[i].y-p[i].x;
		p[i].s=p[i].x+p[i].y;
	}
	
	for(int i=1;i<=n;i++){		//离散化：树状树状用的 
		st[++tot]=p[i].x;
		st[++tot]=p[i].y;
	}
	sort(st+1,st+1+tot);
	for(int i=1;i<=n;i++){
		p[i].ix=lower_bound(st+1,st+1+tot,p[i].x)-st;
		p[i].iy=lower_bound(st+1,st+1+tot,p[i].y)-st;
	}
	
	make_G();
	
	for(int i=1;i<=n;i++)		//Kruskal 
		fa[i]=i;
	sort(e+1,e+1+cnt);
	int k=0,ans=0;
	vector<int> V;
	for(int i=1;i<=cnt;i++){
		int u=e[i].u,v=e[i].v;
		u=find(u),v=find(v);
		if(u==v)	continue;
		ans+=e[i].w;
		V.push_back(i);
		fa[u]=v;
		k++;
		if(k==n-1)	break;
	}
	
	cout<<ans<<'\n';
	for(int i=0;i<V.size();i++)
		cout<<e[V[i]].u<<' '<<e[V[i]].v<<'\n';
	return 0;
}
```

---

## 作者：FFTotoro (赞：9)

本文在结论的证明上参考了：[曼哈顿距离最小生成树 - 博客园](https://www.cnblogs.com/xzxl/p/7237246.html)，在此表示对作者的感谢。

下文中对于平面中的两个点 $A$ 和 $B$，记 $|AB|$ 表示 $A$ 和 $B$ 的曼哈顿距离，即 $|AB|=|x_A-x_B|+|y_A-y_B|$。

对于完全图最小生成树一类题，一种直接的想法是使用[蓝莓算法](https://oi-wiki.org/graph/mst/#boruvka-%E7%AE%97%E6%B3%95)解决。但是我们将会在这里介绍一种直接使用 Kruskal 的解法。

观察到本题边数很多，而 Kruskal 是基于边的贪心，所以只有一条道路——去掉必然不会被选择的边，只保留少量的边求解。

先给出结论：对于每个点 $(x,y)$，如下图将平面划分为 $8$ 个 $45\degree$ 的区域（$(x,y)$ 为四条分割线的交点，其中两条分割线分别与 $x$ 轴与 $y$ 轴平行），将该点与每个区域中离它最近的任意一个点连边即可。下证为什么这样的连边方式是最优的。

![](https://cdn.luogu.com.cn/upload/image_hosting/obg6bo06.png)

证明：

> 设 $(x,y)$ 为原点 $O(0,0)$，在上面的 $R_1$ 中考虑两个点 $A(x_1,y_1),B(x_2,y_2)$（其他区域同理；由于在区域 $R_1$ 中所以满足 $0\le x_1\le y_1$ 和 $0\le x_2\le y_2$），不妨认为 $|OA|\le |OB|$。根据最小生成树的性质，对于原图的一个三元环，其中的最长边一定不会被选入最小生成树，故只需证：$|AB|\le |OB|$，即 $OB$ 可以被忽略。
>
> 分类讨论 $x_1,x_2,y_1,y_2$ 四者的关系：
>
> - $x_1>x_2\land y_1>y_2$：与 $|OA|\le |OB|$ 矛盾；
> - $x_1\le x_2\land y_1>y_2$：此时 $|AB|=x_2-x_1+y_1-y_2$，故 $|OB|-|AB|=x_2+y_2-(x_2-x_1+y_1-y_2)=x_1-y_1+2y_2$。如果 $|OB|<|AB|$ 则有 $y_1>x_1+2y_2$，故有 $|OA|=x_1+y_1>2x_1+2y_2$，$|OB|=x_2+y_2\le 2y_2<|OA|$，与 $|OA|\le |OB|$ 矛盾；
> - $x_1>x_2\land y_1\le y_2$：与 $x_1\le x_2\land y_1>y_2$ 的情况同理；
> - $x_1\le x_2\land y_1\le y_2$：此时 $|OA|+|AB|=|OB|$，始终满足 $|AB|\le |OB|$。
>
> 综上，该结论成立。

---

现在的问题在于，如何找出这些边。可以观察到一个事情，事实上只需要考虑区域 $R_1,R_2,R_3,R_4$ 中的点进行连边（因为每条边必然有一个点 $x$ 坐标较小，相当于将其与 $x$ 坐标较大的连边），常数能够除以 $2$。

考虑如何快速找到单个区域中离一个点 $A(x,y)$ 最近的点：以区域 $R_1$ 为例，对于一个点 $B(x',y')$，由于在区域 $R_1$ 所以满足 $x'\ge x\land y'-x'\ge y-x$，又因为 $|AB|=x'-x+y'-y$，所以需要最小化 $x'+y'$。

对于这一类二维偏序问题，考虑按其中一维排序，在数据结构上维护另一维。观察到需要维护的是最值，又由于需要求值的下标范围是一个后缀，所以直接上树状数组维护。

求解除了 $R_1$ 以外的其他区域很简单，只需要合理地组合使用下面的操作进行坐标变换即可：

- 交换 $x$ 坐标和 $y$ 坐标，即将一个点关于直线 $x=y$ 轴对称；
- 将 $x$ 坐标取相反数，即将一个点关于直线 $x=0$ 轴对称。

时间复杂度 $O(n\log n)$。

参考代码（GNU C++ 17）：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int,int> pii;
typedef tuple<int,int,int> tpi;
namespace IAOI_lib{
  template<typename T> class dsu{
    private:
      vector<T> a;
      vector<int> s;
    public:
      dsu(){
        a.resize(200000),s.resize(200000,1);
        iota(a.begin(),a.end(),0);
      }
      dsu(int n){
        a.resize(n),s.resize(n,1);
        iota(a.begin(),a.end(),0);
      }
      T leader(T x){
        return a[x]==x?x:a[x]=leader(a[x]);
      }
      inline int size(T x){
        return s[leader(x)];
      }
      inline void merge(T x,T y){
        x=leader(x),y=leader(y);
        if(x==y)return;
        if(s[x]>s[y])swap(x,y);
        s[y]+=s[x],a[x]=y;
      }
      inline bool same(T x,T y){
        return leader(x)==leader(y);
      }
  }; // 并查集模板
  template<typename T,T(*op)(T,T),T(*e)()> class fenwick_tree{
    private:
      vector<T> t;
    public:
      fenwick_tree(){
        t.resize(200000,e());
      }
      fenwick_tree(int n){
        t.resize(n,e());
      }
      inline int lowbit(int x){
        return x&-x;
      }
      inline void add(int p,T d){
        t[p]=op(t[p],d),p++;
        while((p-=lowbit(p))>0)
          t[p-1]=op(t[p-1],d);
      }
      inline T suf_sum(int p){
        T s=t[p++];
        while((p+=lowbit(p))<=t.size())
          s=op(s,t[p-1]);
        return s;
      }
  }; // 维护后缀信息的树状数组模板
  inline pii mn(pii x,pii y){return x<y?x:y;}
  inline pii id(){return make_pair(2e9,-1);}
  inline pair<ll,vector<pii> > mst(vector<tpi> e,int n=1){
    vector<pii> e2;
    for(auto [u,v,w]:e)n=max({n,u+1,v+1});
    sort(e.begin(),e.end(),[](tpi x,tpi y){
      return get<2>(x)<get<2>(y);
    });
    dsu<int> d(n); ll r=0;
    for(auto [u,v,w]:e)
      if(!d.same(u,v))d.merge(u,v),e2.emplace_back(u,v),r+=w;
    return make_pair(r,e2);
  } // Kruskal 求解最小生成树
  inline pair<ll,vector<pii> > manhattan_mst(vector<pii> p){
    vector<tpi> e;
    for(int r1=0;r1<2;r1++){
      for(auto &[x,y]:p)x=-x;
      for(int r2=0;r2<2;r2++){
        vector<int> a(p.size()),b;
        for(auto &[x,y]:p)
          swap(x,y),b.emplace_back(x);
        sort(b.begin(),b.end());
        b.erase(unique(b.begin(),b.end()),b.end());
        auto get=[&](int x){
          return lower_bound(b.begin(),b.end(),x)-b.begin();
        }; // 对坐标离散化
        iota(a.begin(),a.end(),0);
        sort(a.begin(),a.end(),[&](int x,int y){
          int dx=p[x].second-p[x].first,dy=p[y].second-p[y].first;
          return dx==dy?p[x].first>p[y].first:dx>dy;
        }); // 对第一维排序
        fenwick_tree<pii,mn,id> t(b.size());
        for(int i=0;i<p.size();i++){
          auto [x,y]=p[a[i]];
          int w=get(x);
          auto [s,j]=t.suf_sum(w);
          if(~j)e.emplace_back(a[i],a[j],s-x-y);
          t.add(w,make_pair(x+y,i));
        } // 树状数组求距离最短点
      }
    }
    return mst(e);
  }
}
int main(){
  ios::sync_with_stdio(false);
  int n; cin>>n;
  vector<pii> a(n);
  for(auto &[x,y]:a)cin>>x>>y;
  auto [w,e]=IAOI_lib::manhattan_mst(a);
  cout<<w<<endl;
  for(auto [u,v]:e)cout<<u+1<<' '<<v+1<<'\n';
  return 0;
}
```

---

## 作者：mahaihang1 (赞：2)

对于完全图最小生成树的问题，一般的 Kruskal 无法解决，我们需要使用只与点数 $n$ 相关的 [Boruvka](https://oi-wiki.org/graph/mst/#boruvka-%E7%AE%97%E6%B3%95) 算法。

大致过程为：最初每个点单独是一个连通块，每次从现有的连通块中找到与当前联通块边权最小的相连，这样每次遍历所有连通块再合并连通块个数至少减半，因此复杂度为 $O(m \log n)$。

发现复杂度中有 $m$ 的原因是正常图中边权与相连的两点无关，而这个完全图中边权依赖于点权，可以优化找距离最近的连通块的过程。

求每一个点曼哈顿距离最近的点，考虑左下角的点只需维护 $x_i+y_i$ 的最大值，因此按点的 $x_i$ 升序排列，用树状数组维护即可，而其余的点可以通过变换 $x_i$ 或 $y_i$ 的正负来转化为相同问题。

但本题中还有连通块的限制，此时只维护最大值就不行了，还要维护最大值所属的连通块与最大值不同一联通块的 $x_i+y_i$ 的次小值，这样查询的点与最大值同属一个连通块时，选用次小值即可。

这样每次找最近的连通块的过程就由 $O(m)$ 优化到了 $O(n\log n)$，总复杂度 $O(n \log^2 n)$。


```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=200010,inf=0x3f3f3f3f3f3f3f3f;
int n,m,fr[N],f[N],s[N],b[N];
queue <pair<int,int> > q;
struct point{
	int x,y,i;
}a[N];
int find(int p){	
	return (f[p]==p?p:f[p]=find(f[p]));
}
struct node{
	int v,i;
	void init(){
		v=-inf,i=0;
	}
	bool operator >(const node &_a)const{
		return v>=_a.v;
	}
}c[N][2],e[N];
void merge(int u,int v){
	u=find(u),v=find(v);
	if(s[u]<s[v]) swap(u,v);
	s[u]+=s[v],f[v]=u;
}
bool id(node _a,node _b){
	return find(_a.i)==find(_b.i);
}
int lowbit(int x){
	return x&-x;
}
void upd(int p,int i){
	node k=(node){b[a[i].y]+a[i].x,a[i].i};
	while(p<=m){
		if(k>c[p][0]){
			if(!id(k,c[p][0])) c[p][1]=c[p][0];
			c[p][0]=k;
		}
		else if(!id(k,c[p][0])&&k>c[p][1]) c[p][1]=k;
		p+=lowbit(p);
	}
}
node query(int p,int i){
	node sum;sum.init();
	while(p){
		node x=(find(c[p][0].i)==i?c[p][1]:c[p][0]);
		sum=(x>sum?x:sum);
		p-=lowbit(p);
	}
	return sum;
}
void solve(){
	for(int i=1;i<=m;i++) c[i][0].init(),c[i][1].init();
	for(int i=1;i<=n;i++){
		int id=a[i].i;
		node k=query(a[i].y,find(id));
		k.v=llabs(b[a[i].y]+a[i].x-k.v);
		if(e[find(id)]>k&&k.i) e[find(id)]=k,fr[find(id)]=id;
		upd(a[i].y,i);
	}
}
bool cmp_x(point _a,point _b){
	return _a.x<_b.x;
}
void solve_x(){
	solve(); 
	for(int i=1;i<=n;i++) a[i].x=-a[i].x;
	reverse(a+1,a+1+n);
} 
void solve_y(){
	solve();
	for(int i=1;i<=n;i++) a[i].y=m-a[i].y+1;
	for(int i=1;i<=m;i++) b[i]=-b[i];
	reverse(b+1,b+1+m);
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i].x>>a[i].y;
		a[i].i=i,b[i]=a[i].y;
		f[i]=i,s[i]=1;
	}
	sort(b+1,b+1+n);
	m=unique(b+1,b+1+n)-b-1;
	for(int i=1;i<=n;i++) a[i].y=lower_bound(b+1,b+1+m,a[i].y)-b;
	sort(a+1,a+1+n,cmp_x);
	int sum=0;
	while(1){
		for(int i=1;i<=n;i++) e[i]=(node){inf,0};
		for(int i=0;i<2;i++) solve_x(),solve_y();
		for(int i=1;i<=n;i++){
			int id=a[i].i;
			if(!e[id].i||find(e[id].i)==find(id)) continue;
			merge(id,e[id].i),q.push({fr[id],e[id].i});
			sum+=e[id].v;
			fr[id]=0;
		}
		if(q.size()==n-1) break;
	}
	cout<<sum<<"\n";
	while(q.size()){
		cout<<q.front().first<<" "<<q.front().second<<"\n";
		q.pop();
	}
	return 0;
}
```

常数过大，使用 C++98 开 O2 才卡过。

---

## 作者：__staring__ (赞：1)

完全图 MST，不难想到使用 Boruvka 算法。

那么每轮合并连通块时，需要对每个点找到连通块外的最近点，我们存在每轮复杂度 $O(n\log{n})$ 的数点做法，但是考虑使用 kdt 乱搞草过去。

但是 kdt 邻域查询的复杂度没有保证，单次最坏是 $O(n)$ 的，因此加上若干优化或卡常：

- 使用结构体封装节点信息。

- 使用 oi-wiki 上提供的 [kdt 邻域查询](https://oi-wiki.org/ds/kdt/#%E9%82%BB%E5%9F%9F%E6%9F%A5%E8%AF%A2) 剪枝。

- 每个节点维护子树是否在同一个连通块中，查询时若查询点与整棵子树处于同一连通块则返回，回溯时顺便维护即可。

- 每轮先 `find(x)` 出每个点并查集的根，查询时直接调用 `fa[x]` 而不是 `find(x)`。

- 使用方差建树而不是轮换建树。

总复杂度应该最优 $O(n\log^2{n})$ 最劣 $O(n^2\log{n})$？毕竟 kdt 邻域查询复杂度很玄学……

[提交记录](https://www.luogu.com.cn/record/225591382)

```cpp
#include <bits/stdc++.h>
using namespace std;
namespace staring
{
    using LL = long long;
    using ULL = unsigned long long;
    #define fir first
    #define sec second

    #define FOR(i,a,b) for(int i = (a), i##E = (b); i <= i##E; i ++)
    #define ROF(i,a,b) for(int i = (a), i##E = (b); i >= i##E; i --)

    template <typename TYPE>
    int gmax(TYPE &x, const TYPE& y) {return x < y ? x = y, 1 : 0;}
    template <typename TYPE>
    int gmin(TYPE &x, const TYPE& y) {return y < x ? x = y, 1 : 0;}

    static constexpr int SIZE = 1 << 20;
    static char buffin[SIZE]{}, *pin1{}, *pin2{};
    static char buffout[SIZE]{}, *pout{buffout};
    #define GETC() (pin1 == pin2 && (pin2 = (pin1 = buffin) + fread(buffin, 1, SIZE, stdin), pin1 == pin2)? EOF : *pin1++)
    #define PUTC(c) (pout - buffout == SIZE && (fwrite(buffout, 1, SIZE, stdout), pout = buffout), (*pout++ = c))
    
    template <typename TYPE>
    void read(TYPE &x)
    {
        static int signf{0}, chin{0};
        x = signf = 0, chin = GETC();
        while(chin < '0' || chin > '9') signf |= chin == '-', chin = GETC();
        while(chin >= '0' && chin <= '9') x = (x << 3) + (x << 1) + (chin ^ 48), chin = GETC();
        if(signf) x = -x;
    }
    template <typename TYPE, typename... TYPEs>
    void read(TYPE &x, TYPEs &...xs)
    {
        read(x), read(xs...);
    }

    template <typename TYPE>
    void write(TYPE x, char ch = '\n')
    {
        static int stack[64]{}, top{0};
        !x && PUTC('0'), x < 0 && (x = -x, PUTC('-'));
        while(x) stack[top++] = x % 10, x /= 10;
        while(top) PUTC(stack[--top] | 48);
        if(ch) PUTC(ch);
    }
    template <typename TYPE, typename... TYPEs>
    void write(TYPE x, TYPEs ...xs)
    {
        write(x, ' '), write(xs...);
    }

}using namespace staring;

constexpr int N = 2e5 + 5;

array <int, 3> pnt[N];
array <int, 7> tr[N];
int fa[N], sz[N];
array <int, 3> cur[N];

int find(int x)
{
    while(x != fa[x])
        x = fa[x] = fa[fa[x]];
    return x;
}

void merge(int x, int y)
{
    x = find(x), y = find(y);
    if(x == y) return;
    if(sz[x] < sz[y]) swap(x, y);
    fa[y] = x, sz[x] += sz[y];
}

int build(int l, int r)
{
    if(l > r) return 0;
    int m = (l + r) >> 1;

    double sumx = 0, avgx = 0, sumy = 0, avgy = 0;
    FOR(i, l, r)
    {
        sumx += 1ll * pnt[i][0] * pnt[i][0];
        avgx += pnt[i][0];
        sumy += 1ll * pnt[i][1] * pnt[i][1];
        avgy += pnt[i][1];
    }
    sumx /= r - l + 1, sumy /= r - l + 1;
    avgx /= r - l + 1, avgy /= r - l + 1;
    int u = sumx - avgx * avgx < sumy - avgy * avgy;
    nth_element(pnt + l, pnt + m, pnt + r + 1,
        [&u](auto a, auto b){return a[u] < b[u];});
    
    tr[m][0] = tr[m][1] = pnt[m][0];
    tr[m][2] = tr[m][3] = pnt[m][1];
    if(l == r) return l;
    tr[m][4] = build(l, m - 1);
    tr[m][5] = build(m + 1, r);
    if(tr[m][4])
    {
        gmin(tr[m][0], tr[tr[m][4]][0]);
        gmax(tr[m][1], tr[tr[m][4]][1]);
        gmin(tr[m][2], tr[tr[m][4]][2]);
        gmax(tr[m][3], tr[tr[m][4]][3]);
    }
    if(tr[m][5])
    {
        gmin(tr[m][0], tr[tr[m][5]][0]);
        gmax(tr[m][1], tr[tr[m][5]][1]);
        gmin(tr[m][2], tr[tr[m][5]][2]);
        gmax(tr[m][3], tr[tr[m][5]][3]);
    }
    return m;
}

int dist(int p, int k)
{
    int d = 0;
    d += max(tr[p][0] - pnt[k][0], 0);
    d += max(pnt[k][0] - tr[p][1], 0);
    d += max(tr[p][2] - pnt[k][1], 0);
    d += max(pnt[k][1] - tr[p][3], 0);
    return d;
}

void query(int p, int k, int &c, int &f, int &t)
{
    if(!p) return;
    if(fa[p] != fa[k])
    {
        if(gmin(c, abs(pnt[p][0] - pnt[k][0]) + abs(pnt[p][1] - pnt[k][1])))
            f = k, t = p;
    }
    else if(tr[p][6]) return;
    int dl = dist(tr[p][4], k), dr = dist(tr[p][5], k);
    if(dl < c && dr < c)
    {
        if(dl < dr)
        {
            query(tr[p][4], k, c, f, t);
            if(dr < c) query(tr[p][5], k, c, f, t);
        }
        else
        {
            query(tr[p][5], k, c, f, t);
            if(dl < c) query(tr[p][4], k, c, f, t);
        }
    }
    else
    {
        if(dl < c) query(tr[p][4], k, c, f, t);
        if(dr < c) query(tr[p][5], k, c, f, t);
    }
    tr[p][6] = 1;
    if(tr[p][4]) tr[p][6] &= tr[tr[p][4]][6] && fa[p] == fa[tr[p][4]];
    if(tr[p][5]) tr[p][6] &= tr[tr[p][5]][6] && fa[p] == fa[tr[p][5]];
}

void mainSolve()
{
    int n;
    read(n);
    FOR(i, 1, n)
    {
        auto &[x, y, id] = pnt[i];
        read(x, y), id = i;
    }
    
    LL res = 0;
    vector <pair <int, int>> edge;
    FOR(i, 1, n) fa[i] = i, sz[i] = 1;
    int rt = build(1, n);
    while(sz[find(1)] < n)
    {
        FOR(i, 1, n)
            find(i), cur[i][0] = 2e9;
        FOR(i, 1, n)
        {
            auto &[c, f, t] = cur[fa[i]];
            query(rt, i, c, f, t);
        }
        FOR(i, 1, n)
        {
            if(find(i) != i) continue;
            auto [c, f, t] = cur[i];
            if(find(t) == i) continue;
            merge(i, find(t)), res += c;
            edge.emplace_back(pnt[f][2], pnt[t][2]);
        }
    }
    write(res);
    for(auto [a, b] : edge)
        write(a, b);
}

int main()
{
    auto fileIO = [](string file)
    {
        string In = file + ".in";
        string Out = file + ".out";
        freopen(In.c_str(), "r", stdin);
        freopen(Out.c_str(), "w", stdout);
    };
    // fileIO("");

    int testCount = 1;
    // read(testCount);
    while(testCount--)
        mainSolve();

    fwrite(buffout, 1, pout - buffout, stdout);
    return 0;
}
```

---

## 作者：yuguanchen2022 (赞：1)

upd:由于图片挂了，因此重新放上
## 题意简述
给出 $ 1 \le n \le 2 \times 10 ^ 5 $ 个平面直角坐标系内的点。点之间的距离为他们的曼哈顿距离。求其最小生成树。

## 思路
### 发现一：
![](https://cdn.luogu.com.cn/upload/image_hosting/ywt649k4.png?x-oss-process=image/resize,m_lfit,h_800,w_900)

对于如图所示的 $ A $ 点，其在最小生成树里只会直接连接阴影区域内最多一个点。
### 发现二：
$ A $ 点必定连向该区域内曼哈顿距离下距离它最近的点
#### 证明：
不妨设 $ A , B $ 在相对点 $ O $ 的极角为 $ [ \frac{π}{4} , \frac{π}{2} ] $ 的区域内，且 $ |OA| < |OB| $ ，比如下图所示：![](https://cdn.luogu.com.cn/upload/image_hosting/3pmvq78l.png?x-oss-process=image/resize,m_lfit,h_800,w_900)

设 $ A(x_0 , y_0) , B(x_1 , y_1) $ 。且由于其相对点 $ O $ 的极角范围可知 $ x_0 , x_1 >0 , y_0 - x_0 , y_1 - x_1 > 0 $ , 故 $ |OA| = x_0 + y_0 , |OB| = x_1 + y_1 $ 。下面分情况来讨论：

1.  若 $ A $ 在 $ B $ 的右上方 ，则不可能有 $ |OA| < |OB| $；

2.  若 $ A $ 在 $ B $ 的左上方或上方 ，则 $ |AB| = x_1 - x_0 + y_0 - y_1 , |OB| - |AB| = x_0 - y_0 + 2y_1 $ , 由于 $ y_0 > y_1 > x_1 > x_0 > 0 $ , 若 $ |BO| < |AB| $ 则 $ x_0 + 2y_1 < y_0 $ ，故代入 $ |AO| = x_0 + y_0 > 2x_0 + 2y_1 , |BO| = x_1 + y_1 < 2y_1 < 2x_0 + 2y_1 < |AO| $，推得矛盾，故 $ |BO| \ge |AB| $ ，则连接 $ BO、AB $ 的总代价必然 $ \ge $ 连接 $ AO、AB $ 的总代价；

3. 若 $ A $ 在 $ B $ 的右下方或右方，则同 2 进行讨论；

4. 若 $ A $ 在 $ B $ 的左下方，则 $ |OA| + |AB| = |OB| $ ，同理连接 $ BO、AB $ 的总代价必然 $ > $ 连接 $ AO、AB $ 的总代价。

因此我们需要做的就是对每个点选择区域内距离最近的点连双向边。

下面考虑一些细节，依然按照极角范围在 $ [ \frac{π}{4} , \frac{π}{2} ] $ 考虑，若在 $ [ -\frac{π}{4} , \frac{π}{2} ] $ 时可通过坐标变化到对应区域，其他区域可以由该点左边的点向其连边，也就是每个点只向在它右边的点连边。

 
 
首先，设当前考虑的点为 $ A(x_0 , y_0) $ ，其中任意一个在对应区域内的点为 $ B(x_1 , y_1) $ ，则：

1.显然有 $ x_0 < x_1 , y_0 < y_1 $;

2.$ AB $ 连线的斜率必定大于等于一、三象限角平分线（即直线 $ y = x $ ) , 则 $ \frac{y_1 - y_0}{x_1 - x_0} \ge 1 $ , 化简得 $ y_1 - x_1 \ge y_0 - x_0 $ (这里并不用舍去 $ x_0 = x_1 $ )

3.求到 $ AB = x_1 - x_0 + y_1 - y_0 $ 最小 , 由于对于 $ A $ 来说 $ x_0 , y_0 $ 一定 ， 故求 $ x_1 + y_1 $ 最小

代码实现时，按横坐标排序从后往前考虑，维护满足第二条限制的最小的 $ x + y $ 即可。

则建完图后得到一张 $ n $ 个点，$ 8n $ 条边的图，直接跑任意最小生成树算法即可。

## 代码

```
#include <bits/stdc++.h>
#define int long long
#define rep(i, a, b) for (int i = (a); i <= (b); i++)
#define lop(i, a, b) for (int i = (a); i < (b); i++)
#define dwn(i, a, b) for (int i = (a); i >= (b); i--)
#define iosfst ios::sync_with_stdio(false); cin.tie(0), cout.tie(0)
#define pr pair<int, int>
#define mp(a, b) make_pair(a, b)
#define fr(x) freopen(x".in", "r", stdin), freopen(x".out", "w", stdout)
#define pb push_back
using namespace std;
const int N = 2e5 + 10, inf = 1061109567, fff = 2e9 + 1000;
int n, val[N], who[N], bk[N][2], mem[N];
int changex[10] = { 0, 1, 1, -1, -1, 1, 1, -1, -1 };
int changey[10] = { 0, 1, -1, -1, 1, 1, -1, -1, 1 };
int changec[10] = { 0, 0, 0, 0, 0, 1, 1, 1, 1 };
struct gg {
    int x, y, dif, sum, ox, oy, rk, id;
} node[N];
struct fuck {
    int fi, se;
};
namespace seg {
int mi[N << 2], num[N << 2];
void push_up(int p) {
    mi[p] = min(mi[p << 1], mi[p << 1 | 1]);
    if (mi[p << 1] > mi[p << 1 | 1]) num[p] = num[p << 1 | 1];
    else num[p] = num[p << 1];
    return;
}
void build(int l, int r, int p) {
    if (l == r) {
        mi[p] = node[l].sum;
        num[p] = l;
        return;
    }
    int mid = (l + r) >> 1;
    build(l, mid, p << 1);
    build(mid + 1, r, p << 1 | 1);
    push_up(p);
    return;
}
void update(int l, int r, int p, int tar) {
    if (l == r) {
        mi[p] = mem[who[l]];
        num[p] = who[l];
        return;
    }
    int mid = (l + r) >> 1;
    if (tar <= mid) update(l, mid, p << 1, tar);
    else update(mid + 1, r, p << 1 | 1, tar);
    push_up(p);
    return;
}
fuck qnum(int l, int r, int p, int tl, int tr) {
    fuck re = { fff, 0 }, tmp;
    if (tl > tr) return re;
    if (tl <= l && r <= tr) {
        fuck rea = { mi[p], num[p] };
        return rea;
    }
    int mid = (l + r) >> 1;
    if (tl <= mid) {
        tmp = qnum(l, mid, p << 1, tl, tr);
        if (tmp.fi < re.fi) re = tmp;
    }
    if (tr >= mid + 1) {
        tmp = qnum(mid + 1, r, p << 1 | 1, tl, tr);
        if (tmp.fi < re.fi) re = tmp;
    }
    return re;
}
}
vector<pr> ans;
namespace tree {
int cnt, head[N], fa[N], tot, f[N][19], len[N][19], dep[N], res;
map<pr, bool> ex;
struct edge {
    int u, v, w, next;
} side[N << 4];
struct data {
    int u, v, w;
} con[N << 3];
void insert(int u, int v, int w) {
    struct edge add = { u, v, w, head[u] };
    side[++cnt] = add;
    head[u] = cnt;
    return;
};
int get(int x) {
    if (fa[x] != x) fa[x] = get(fa[x]);
    return fa[x];
}
void uni(int x, int y) { fa[get(x)] = get(y); return; }
bool cop2(data x, data y) { return x.w < y.w; }
void dfs(int now, int g, int w) {
    f[now][0] = g;
    len[now][0] = w;
    dep[now] = dep[f[now][0]] + 1;
    rep (i, 1, 18) {
        f[now][i] = f[f[now][i - 1]][i - 1];
        len[now][i] = max(len[now][i - 1], len[f[now][i - 1]][i - 1]);
    }
    for (int i = head[now]; i; i = side[i].next) {
        int v = side[i].v;
        if (v == f[now][0] || f[v][0] == now) continue;
        dfs(v, now, side[i].w);
    }
    return;
}
int span() {
    sort(con + 1, con + 1 + tot, cop2);
    rep (i, 1 ,n) fa[i] = i;
    rep (i, 1, tot) {
        int u = con[i].u, v = con[i].v, w = con[i].w;
        if (get(u) != get(v)) {
            uni(u, v);
            res += w;
            ans.push_back(make_pair(u, v));
        }
    }
    return res;
}
int lca(int u, int v) {
    int ma = 0;
    if (dep[u] < dep[v]) swap(u, v);
    dwn (i, 18, 0) if (dep[f[u][i]] >= dep[v]) ma = max(ma, len[u][i]), u = f[u][i];
    if (u == v) return ma;
    for (int i = 18; i >= 0; i--) if (f[u][i] != f[v][i]) ma = max(ma, len[u][i]), ma = max(ma, len[v][i]), u = f[u][i], v = f[v][i];
    return max(ma, max(len[u][0], len[v][0]));
}
}
inline int get_dis(int x, int y) { return abs(bk[x][0] - bk[y][0]) + abs(bk[x][1] - bk[y][1]); }
inline bool cop1(gg x, gg y) { return x.dif < y.dif; }
inline bool cop3(gg x, gg y) {
    if (x.x == y.x) return x.y < y.y;
    return x.x < y.x;
}
inline bool cop4(gg x, gg y) { return x.id < y.id; }
void init() {
    memset(tree::head, 0, sizeof(tree::head));
    tree::ex.clear();
    tree::tot = tree::cnt = 0;
    memset(tree::f, 0, sizeof(tree::f)), memset(tree::len, 0, sizeof(tree::len)), memset(tree::dep, 0, sizeof(tree::dep));
    return;
}
void solve() {
    cin >> n;
    rep (i, 1, n) cin >> node[i].ox >> node[i].oy, node[i].id = i;
    init();
    rep (i, 1, 8) {
        memset(seg::mi, 0x3f, sizeof(seg::mi));
        rep (j, 1, n) {
            node[j].x = node[j].ox * changex[i], node[j].y = node[j].oy * changey[i];
            if (changec[i]) swap(node[j].x, node[j].y);
            bk[node[j].id][0] = node[j].x, bk[node[j].id][1] = node[j].y, node[j].dif = node[j].y - node[j].x, node[j].sum = node[j].x + node[j].y, mem[node[j].id] = node[j].sum;
        }
        sort(node + 1, node + 1 + n, cop1);
        rep (j, 1, n) node[j].rk = j, val[j] = node[j].dif, who[j] = node[j].id;
        sort(node + 1, node + 1 + n, cop3);
        dwn (j, n, 1) {
            seg::update(1, n, 1, node[j].rk);
            int l = lower_bound(val + 1, val + 1 + n, node[j].dif) - val;
            fuck point1 = seg::qnum(1, n, 1, l, node[j].rk - 1), point2 = seg::qnum(1, n, 1, node[j].rk + 1, n), point;
            if (point1.fi < point2.fi) point = point1;
            else point = point2;
            int u = point.se, v = node[j].id;
            if (!u || !v || point.fi == inf) continue;
            if (u > v) swap(u, v);
            if (u == v) continue;
            tree::con[++tree::tot].u = u, tree::con[tree::tot].v = v, tree::con[tree::tot].w = get_dis(point.se, node[j].id);
        }
    }
    int res = tree::span();
    cout << res << '\n';
    lop (i, 0, ans.size()) cout << ans[i].first << ' ' << ans[i].second << '\n';
    return;
}
signed main() {
	iosfst;
    int t;
    t = 1;
    while (t--) solve();
    return 0;
}
```
常数有点大，可将线段树改为 BIT

---


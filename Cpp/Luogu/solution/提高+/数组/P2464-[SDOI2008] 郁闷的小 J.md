# [SDOI2008] 郁闷的小 J

## 题目描述

小 J 是国家图书馆的一位图书管理员，他的工作是管理一个巨大的书架。虽然他很能吃苦耐劳，但是由于这个书架十分巨大，所以他的工作效率总是很低，以致他面临着被解雇的危险，这也正是他所郁闷的。

具体说来，书架由 $N$ 个书位组成，编号从 $1$ 到 $N$。每个书位放着一本书，每本书有一个特定的编码。

小 J 的工作有两类：

1. 图书馆经常购置新书，而书架任意时刻都是满的，所以只得将某位置的书拿掉并换成新购的书。

2. 小 J 需要回答顾客的查询，顾客会询问某一段连续的书位中某一特定编码的书有多少本。

例如，共 $5$ 个书位，开始时书位上的书编码为 $1, 2, 3, 4, 5$。

一位顾客询问书位 $1$ 到书位 $3$ 中编码为“$2$”的书共多少本，得到的回答为：$1$。

一位顾客询问书位 $1$ 到书位 $3$ 中编码为“$1$”的书共多少本，得到的回答为：$1$。

此时，图书馆购进一本编码为“$1$”的书，并将它放到 $2$ 号书位。

一位顾客询问书位 $1$ 到书位 $3$ 中编码为“$2$”的书共多少本，得到的回答为：$0$。

一位顾客询问书位 $1$ 到书位 $3$ 中编码为“$1$”的书共多少本，得到的回答为：$2$。

……

你的任务是写一个程序来回答每个顾客的询问。

## 说明/提示

对于 $40 \%$ 的数据，$1 \le N, M \le 5000$。

对于 $100 \%$ 的数据，$1 \le N, M \le {10}^5$。

对于 $100 \%$ 的数据，所有出现的书的编码为不大于 $2^{31} - 1$ 的正数。

## 样例 #1

### 输入

```
5 5
1 2 3 4 5
Q 1 3 2
Q 1 3 1
C 2 1
Q 1 3 2
Q 1 3 1
```

### 输出

```
1
1
0
2
```

# 题解

## 作者：浅色调 (赞：46)

### Solution：

　　本题解法太多，前后用了4种方法去做，由简入繁。

　　**法一：分块+map（736ms）**

　　我们可以将数列划分为$\sqrt n$块，每个块用map维护块内元素出现次数，那么单次修改可以做到$O(\log(\sqrt n))$，单次查询能做到$\sqrt n \log (\sqrt n)$。时间复杂度$O(n\sqrt n \log(\sqrt n))$，极限数据能卡到$2e8$，但是本题数据比较水也能过。

　　**法一代码：**
  ```cpp
/*Code by 520 -- 10.28*/
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/hash_policy.hpp>
#define il inline
#define ll long long
#define RE register
#define For(i,a,b) for(RE int (i)=(a);(i)<=(b);(i)++)
#define Bor(i,a,b) for(RE int (i)=(b);(i)>=(a);(i)--)
using namespace std;
using namespace __gnu_pbds;
const int N=100005;
gp_hash_table<int,int>mp[1005];
int n,m,a[N],bl[N],ln[N],rn[N],clo,u,v,w;
char opt[2];

int gi(){
    int a=0;char x=getchar();
    while(x<'0'||x>'9') x=getchar();
    while(x>='0'&&x<='9') a=(a<<3)+(a<<1)+(x^48),x=getchar();
    return a;
}    

il int query(int x,int y,int z){
    int bx=bl[x],by=bl[y],res=0;
    if(bx==by) {
        For(i,x,y) res+=(a[i]==z);
        return res;
    }
    For(i,bx+1,by-1) res+=mp[i][z];
    For(i,x,rn[bx]) res+=(a[i]==z);
    For(i,ln[by],y) res+=(a[i]==z);
    return res;
}

int main(){
    n=gi(),m=gi(); clo=sqrt(n);
    For(i,1,n) {
        a[i]=gi(),bl[i]=(i-1)/clo+1,mp[bl[i]][a[i]]++;
        if(!ln[bl[i]]) ln[bl[i]]=i;
        rn[bl[i]]=i;
    }
    For(i,1,m){
        scanf("%s",opt);
        if(opt[0]=='Q') u=gi(),v=gi(),w=gi(),printf("%d\n",query(u,v,w));
        else {
            u=gi(),v=gi();
            mp[bl[u]][a[u]]--;
            a[u]=v;
            mp[bl[u]][a[u]]++;
        }
    }
    return 0;
}
```


　　**法二：分块+离散化（383ms）**

　　我们显然可以用奇技淫巧优化掉法一中的$\log(\sqrt n)$。只需要离线操作，并对数的值域离散，然后用空间换时间，一种方法是把块数调小，另一种是直接用short类型来开桶（反正一个块内的元素次数不会超过$\sqrt n<2^{16}-1$），能卡着空间过。时间复杂度$O(n\sqrt n)$。

　　**法二代码：**
  ```cpp
/*Code by 520 -- 10.28*/
#include<bits/stdc++.h>
#define il inline
#define ll long long
#define RE register
#define For(i,a,b) for(RE int (i)=(a);(i)<=(b);(i)++)
#define Bor(i,a,b) for(RE int (i)=(b);(i)>=(a);(i)--)
using namespace std;
const int N=100005;
int n,m,a[N],bl[N],ln[N],rn[N],clo,u,v,w,*q[N<<1],cnt;
struct node{
    int l,r,x;
}t[N];
short mp[318][N<<1];
char opt[N][2];

int gi(){
    int a=0;char x=getchar();
    while(x<'0'||x>'9') x=getchar();
    while(x>='0'&&x<='9') a=(a<<3)+(a<<1)+(x^48),x=getchar();
    return a;
}    

il bool cmp(int *a,int *b){return *a<*b;}

il int query(int x,int y,int z){
    int bx=bl[x],by=bl[y],res=0;
    if(bx==by) {
        For(i,x,y) res+=(a[i]==z);
        return res;
    }
    For(i,bx+1,by-1) res+=mp[i][z];
    For(i,x,rn[bx]) res+=(a[i]==z);
    For(i,ln[by],y) res+=(a[i]==z);
    return res;
}

int main(){
    n=gi(),m=gi(); clo=sqrt(n);
    For(i,1,n) {
        a[i]=gi(),q[++cnt]=&a[i],bl[i]=(i-1)/clo+1;
        if(!ln[bl[i]]) ln[bl[i]]=i;
        rn[bl[i]]=i;
    }
    For(i,1,m){
        scanf("%s",opt[i]);
        if(opt[i][0]=='Q') t[i]=node{gi(),gi(),gi()},q[++cnt]=&t[i].x;
        else t[i]=node{gi(),gi(),0},q[++cnt]=&t[i].r;
    }
    sort(q+1,q+cnt+1,cmp); int lst=-1,tot=0;
    For(i,1,cnt) if(*q[i]!=lst) lst=*q[i],*q[i]=++tot; else *q[i]=tot;
    For(i,1,n) mp[bl[i]][a[i]]++;
    For(i,1,m){
        if(opt[i][0]=='Q') printf("%d\n",query(t[i].l,t[i].r,t[i].x));
        else {
            u=t[i].l,v=t[i].r;
            mp[bl[u]][a[u]]--;
            a[u]=v;
            mp[bl[u]][a[u]]++;
        }
    }
    return 0;
}
```
　

　　**法三：带修改主席树（1156ms ）**

　　本题显然是个带修主席树的板子，只需要离线操作并对值域离散，然后就直接板子咯。时间复杂度$O(n\log^2 n)$。

　　**法三代码：**
  ```cpp
/*Code by 520 -- 10.28*/
#include<bits/stdc++.h>
#define il inline
#define ll long long
#define RE register
#define For(i,a,b) for(RE int (i)=(a);(i)<=(b);(i)++)
#define Bor(i,a,b) for(RE int (i)=(b);(i)>=(a);(i)--)
using namespace std;
const int N=100005;
int n,m,a[N],*q[N<<1],cnt,tot,rt[N],X[N],Y[N],tx,ty;
struct query{
    int l,r,x;
}qus[N];
struct node{
    int ls,rs,sz;
}t[N*300];
char opt[N][2];

int gi(){
    int a=0;char x=getchar();
    while(x<'0'||x>'9') x=getchar();
    while(x>='0'&&x<='9') a=(a<<3)+(a<<1)+(x^48),x=getchar();
    return a;
}    

il bool cmp(int *a,int *b){return *a<*b;}

void ins(int l,int r,int k,int x,int lst,int &rt){
    if(!rt) rt=++tot; t[rt]=t[lst],t[rt].sz+=x;
    if(l==r) return;
    int m=l+r>>1;
    if(k<=m) ins(l,m,k,x,t[lst].ls,t[rt].ls);
    else ins(m+1,r,k,x,t[lst].rs,t[rt].rs);
}

il void update(int i,int v){
    int k=a[i];
    while(i<=n) ins(1,cnt,k,v,rt[i],rt[i]),i+=i&-i;
}

il int calc(int x){
    int l=1,r=cnt,k=qus[x].x,res=0;
    tx=ty=0;
    for(RE int i=qus[x].l-1;i;i-=i&-i) X[++tx]=rt[i];
    for(RE int i=qus[x].r;i;i-=i&-i) Y[++ty]=rt[i];
    while(1){
        int mid=l+r>>1;
        if(l==r) break;
        if(mid>=k) {
            r=mid;
            For(i,1,tx) X[i]=t[X[i]].ls;
            For(i,1,ty) Y[i]=t[Y[i]].ls;
        }
        else {
            l=mid+1;
            For(i,1,tx) X[i]=t[X[i]].rs;
            For(i,1,ty) Y[i]=t[Y[i]].rs;
        }
    }
    For(i,1,ty) res+=t[Y[i]].sz;
    For(i,1,tx) res-=t[X[i]].sz;
    return res;
}

int main(){
    n=gi(),m=gi();
    For(i,1,n) a[i]=gi(),q[++cnt]=&a[i];
    For(i,1,m){
        scanf("%s",opt[i]);
        if(opt[i][0]=='Q') qus[i]=query{gi(),gi(),gi()},q[++cnt]=&qus[i].x;
        else qus[i]=query{gi(),gi(),0},q[++cnt]=&qus[i].r;
    }
    sort(q+1,q+cnt+1,cmp); int lst=-1;
    For(i,1,cnt) if(*q[i]!=lst) lst=*q[i],*q[i]=++tot; else *q[i]=tot;
    cnt=tot;
    memset(&t[tot=0],0,sizeof(t[0]));
    For(i,1,n) update(i,1);
    For(i,1,m){
        if(opt[i][0]=='Q') printf("%d\n",calc(i));
        else {
            int u=qus[i].l,v=qus[i].r;
            update(u,-1),a[u]=v,update(u,1);
        }
    }
    return 0;
}
```
　　**法四：平衡树（432ms）**

　　我们离线操作并对值域离散后，可以直接用无旋treap维护每个值域的下标中序，那么修改就是简单的删除操作，查询也是简单的分离操作。时间复杂度$O(n\log n)$。

　　**法四代码：**
  ```cpp
/*Code by 520 -- 10.28*/
#include<bits/stdc++.h>
#define il inline
#define ll long long
#define RE register
#define For(i,a,b) for(RE int (i)=(a);(i)<=(b);(i)++)
#define Bor(i,a,b) for(RE int (i)=(b);(i)>=(a);(i)--)
using namespace std;
const int N=200005;
int n,m,a[N],*q[N<<1],cnt;
int ch[N][2],rt[N],rnd[N],date[N],siz[N];
struct node{
    int l,r,x;
}t[N];
char opt[N][2];

int gi(){
    int a=0;char x=getchar();
    while(x<'0'||x>'9') x=getchar();
    while(x>='0'&&x<='9') a=(a<<3)+(a<<1)+(x^48),x=getchar();
    return a;
}    

il bool cmp(int *a,int *b){return *a<*b;}

il int newnode(int v){
    ++cnt;
    siz[cnt]=1,date[cnt]=v,rnd[cnt]=rand();
    return cnt;
}

il void up(int rt){siz[rt]=siz[ch[rt][0]]+siz[ch[rt][1]]+1;}

int merge(int x,int y){
    if(!x||!y) return x+y;
    if(rnd[x]<rnd[y]) {ch[x][1]=merge(ch[x][1],y),up(x);return x;}
    else {ch[y][0]=merge(x,ch[y][0]),up(y);return y;}
}

void split(int rt,int v,int &x,int &y){
    if(!rt) {x=y=0;return;}
    if(date[rt]<=v) x=rt,split(ch[rt][1],v,ch[x][1],y),up(x);
    else y=rt,split(ch[rt][0],v,x,ch[y][0]),up(y);
}

il void ins(int k,int v){
    int x,y; split(rt[k],v,x,y),rt[k]=merge(merge(x,newnode(v)),y);
}

il void del(int k,int v){
    int x,y,z; split(rt[k],v,x,y),split(x,v-1,x,z),rt[k]=merge(x,y);
}

int main(){
    srand(time(0));
    n=gi(),m=gi();
    For(i,1,n) a[i]=gi(),q[++cnt]=&a[i];
    For(i,1,m){
        scanf("%s",opt[i]);
        if(opt[i][0]=='Q') t[i]=node{gi(),gi(),gi()},q[++cnt]=&t[i].x;
        else t[i]=node{gi(),gi(),0},q[++cnt]=&t[i].r;
    }
    sort(q+1,q+cnt+1,cmp); int lst=-1,tot=0;
    For(i,1,cnt) if(*q[i]!=lst) lst=*q[i],*q[i]=++tot; else *q[i]=tot;
    cnt=0;
    For(i,1,n) ins(a[i],i);
    For(i,1,m){
        if(opt[i][0]=='Q') {
            int x,y,z; 
            split(rt[t[i].x],t[i].r,x,y),split(x,t[i].l-1,x,z);
            printf("%d\n",siz[z]);
            rt[t[i].x]=merge(merge(x,z),y);
        }
        else {
            int x,y,z,u=t[i].l,v=t[i].r;
            del(a[u],u),a[u]=v,ins(a[u],u);
        }
    }
    return 0;
}
```
$\quad\;\;$欢迎来踩博客：[five20](https://www.cnblogs.com/five20/p/9903954.html)（蒟蒻写题解不易，转载请注明出处，万分感谢！～）




---

## 作者：UperFicial (赞：11)

# 二分+分块

### 前言

**注意，这份题解适于大部分学分块的初学者，对于算法可能讲得很细，但分块的前置简单芝士不会提及。**

逗比题，我也挺逗比连分块都能写锅掉![/yun](https://cdn.luogu.com.cn/upload/pic/62240.png)

讲个不一样的做法，看到楼下都用的平衡树或是 $map$，这里给个二分+分块的 $\texttt{naive}$ 做法。

题目连接：[$\text{Link}$](https://www.luogu.com.cn/problem/P2464)

### 题意简述

给定长度为 $n$ 的序列 $a$，支持两种操作：

- 将 $a_k$ 更改为 $x$。

- 询问区间 $[l,r]$ 有多少个数等于 $x$。

$1\le n,m\le 10^5,1\le a_i\le 2^{31}-1$。

### 题目分析

这道题教练放在平衡树作业里，但菜鸡我怎么看都不像是平衡树![/kk](https://cdn.luogu.com.cn/upload/pic/62227.png)

发现 $1\le n,m\le 10^5$，而且要求区间统计个数，于是可以考虑 $O(n\sqrt n)$ 的分块。

对于 `C` 操作，显然直接更改 $a_k$ 即可。

而对于 `Q` 操作，如果 $x,y$ 在同一块里，暴力统计即可，复杂度 $O(\sqrt n)$，否则我们可以先暴力统计边角的两块，复杂度仍然为 $O(\sqrt n)$，但对于中间的块还暴力统计的话 $O(n\sqrt n)$ 直接上天。

于是就可以用分块中一个比较套路的做法，我们额外再设一个数组 $val$，对于一个下标范围为 $[l,r]$ 的块，$val_l$ 至 $val_r$ 对应 $a$ 数组在 $[l,r]$ 从小到大排序过后的值。

所以说当我们做更改操作即 `C` 操作时，我们先要更改 $a$，而且那一个块中的 $val$ 的值也要**重新赋值**后排序。

对于查询操作，暴力统计的时候一定要统计 $a$ 的值，因为 $val$ 中存的排过序的值，查询的那个边角的区间中的 $val$ 的值不一定对应它真实的值。

但对于中间的那些块，就能直接查 $val$ 了，因为这是后中间的那一坨跟顺序已经没关系了。

那对于中间的某个块 $i$，怎么快速查此块内等于 $k$ 的元素个数呢？

**二分**。因为我们的 $val$ 在排好序后就满足单调性了。

然后发现 `lower_bound` 能求 $\ge k$ 的最小的位置，而 `upper_bound` 能求 $>k$ 的最小位置，两者分别求一下位置得到 $p_1,p_2$，等于 $k$ 的元素一定就在 $[p_1,p_2-1]$ 这个区间。

只不过还要特判一下：

- 没有合法的 $p_1$，说明此块没有与 $k$ 相等的元素，直接 `continue` 掉。

- 有合法的 $p_1$ 却没有合法的 $p_2$，说明 $[p_1,r_i]$ 这个区间都为 $k$ 了。

然后就是算区间长度就没了。

时间复杂度：$O(n\sqrt n\log\sqrt n)$，带个 $\log$ 是因为既要排序还要二分，在 $n,m\le 10^5$ 之下很轻松。

空间复杂度：$O(n)$。

[$AC$ 链接](https://www.luogu.com.cn/record/51444126)

[$code$](https://paste.ubuntu.com/p/nvtGnSB5mK/)

求赞![/kel](https://cdn.luogu.com.cn/upload/pic/62226.png)

$$\texttt{The End.by UF}$$



---

## 作者：zrz_orz (赞：9)

这题可以分块，可以带修主席树，可以STL一套

不过 Luogu 的题解里面好像没有带修莫队的。

难道就我觉得这是模板题吗。。

上来就打莫队。。

代码:
```cpp
#include <bits/stdc++.h>

// Defination {{{
#define PI std::pair<int, int>
#define mk std::make_pair
#define reg register
#define ll long long
#define rep(i, a, b) for(reg int i = a; i <= b; ++i)
#define per(i, a, b) for(reg int i = a; i >= b; --i)
#define pb push_back
#define debug(...) fprintf(stderr, __VA_ARGS__)
// }}}

template<typename T> T max(T a, T b) { return a > b ? a : b; }
template<typename T> T min(T a, T b) { return a < b ? a : b; }

template<typename T> void read(T &x) {
    x = 0; reg char ch = getchar(); reg int f = 1;
    for (; !isdigit(ch); ch = getchar()) if (ch == '-') f = -1;
    for (; isdigit(ch); ch = getchar()) x = (x << 1) + (x << 3) + (ch ^ 48);
    x *= f;
}

#define N 200005

int n, m, tot, Cnt;
int a[N], b[N], pos[N], ans[N];

class Query {
public:
    int l, r, val, id, last, t;
} q[N], o[N];

int cnt[N << 1];

std::map<int, int> mp;

bool cmp(Query A, Query B) {
    if (pos[A.l] == pos[B.l]) {
        if (pos[A.r] == pos[B.r]) return A.t < B.t;
        else return pos[A.r] < pos[B.r];
    }
    return pos[A.l] < pos[B.l];
}

int main() {
#ifndef ONLINE_JUDGE
    freopen("2464.in", "r", stdin);
    freopen("2464.out", "w", stdout);
#endif
    read(n), read(m);
    rep (i, 1, n) read(a[i]), b[++tot] = a[i];
    char opt[4];
    int O = 0, Q = 0;
    rep (i, 1, m) {
        scanf ("%s", opt);
        if (opt[0] == 'Q') {
            ++Q;
            read(q[Q].l), read(q[Q].r), read(q[Q].val);
            b[++tot] = q[Q].val;
            q[Q].id = Q, q[Q].t = O;
        } else {
            ++O;
            read(o[O].l), read(o[O].val);
            b[++tot] = o[O].val;
            o[O].t = O;
        }
    }
    std::sort(b + 1, b + tot + 1);
    rep (i, 1, tot) {
        if (mp[b[i]]) continue;
        mp[b[i]] = ++Cnt;
    }
    rep (i, 1, n) a[i] = mp[a[i]];
    rep (i, 1, Q) q[i].val = mp[q[i].val];
    rep (i, 1, O) o[i].val = mp[o[i].val];
    tot = 1;
    int siz = pow(n, 0.6666667);
    rep (i, 1, n) {
        pos[i] = tot;
        if (i % siz == 0) ++tot;
    }
    std::sort(q + 1, q + Q + 1, cmp);
    rep (i, 1, n) b[i] = a[i];
    rep (i, 1, O) {
        o[i].last = b[o[i].l];
        b[o[i].l] = o[i].val;
    }
    int L = 1, R = 0, K = 0;
    rep (i, 1, Q) {
        while (K < q[i].t) {
            ++K;
            if (o[K].l >= L && o[K].l <= R) --cnt[a[o[K].l]], ++cnt[o[K].val];
            a[o[K].l] = o[K].val;
        }
        while (K > q[i].t) {
            if (o[K].l >= L && o[K].l <= R) --cnt[a[o[K].l]], ++cnt[o[K].last];
            a[o[K].l] = o[K].last;
            --K;
        }
        while (R < q[i].r) {
            ++R;
            cnt[a[R]]++;
        }
        while (L > q[i].l) {
            --L;
            cnt[a[L]]++;
        }
        while (R > q[i].r) {
            cnt[a[R]]--;
            --R;
        }
        while (L < q[i].l) {
            cnt[a[L]]--;
            ++L;
        }
        ans[q[i].id] = cnt[q[i].val];
    }
    rep (i, 1, Q) printf("%d\n", ans[i]);
    return 0; 
}

/*
 _____  ____    _____
|__  / |  _ \  |__  /
  / /  | |_) |   / / 
 / /_  |  _ <   / /_ 
/____| |_| \_\ /____|
  

 ________________________________________ 
< 2464.cpp is created by zrz who is weak >
 ---------------------------------------- 
        \   ^__^
         \  (^^)\_______
            (__)\       )\/\
             U ||----w |
                ||     ||

*/
```


---

## 作者：CuiZhenhang (赞：8)

[**题目传送门**](https://www.luogu.com.cn/problem/P2464)

## 前言

看到其它题解不是用了分块，就是用了主席树、平衡树。要么代码实现复杂，要么算法复杂度很不优秀。我来分享一个代码实现简单，时空复杂度优秀的算法。

时间复杂度：最坏 $O(n \log n)$。  
对随机数据可以优化到几乎 $O(n)$。

前置芝士：[离散化](https://oi-wiki.org//misc/discrete/)、[树状数组](https://oi-wiki.org//ds/fenwick/)（或[线段树](https://oi-wiki.org//ds/seg/)）。

## 分析

显而易见的“暴力”做法是对每个编号开一棵树，这个做法不能通过的原因是 **MLE** 了，但其代码实现简单，而且时间复杂度非常优秀。

初始数组可以视为 $n$ 次修改操作。  
考虑什么样的修改操作会影响编码为 $K$ 的询问操作。  
可以发现，每次修改操作时，只有被拿掉的书的编码为 $K$ 或新购的书的编码为 $K$ 时，询问的答案可能会被影响。  
因此，我们把每次修改操作转化为“拿掉一本编号为 $K_1$ 的书”再“购入一本编号为 $K_2$ 的书”。然后，对于所有询问操作和转化得到的修改操作，按编码 $K$ 分为不同部分，每部分内部按原操作顺序排序。这样，不同部分之间是互不影响的，我们就只需要开 $1$ 棵树，也就可以使用上文提到的“暴力”做法了。

这样，这部分的时间复杂度就是是 $O(\sum{c_k \log n}) = O(n \log n)$（$c_k$ 表示编码为 $k$ 的询问操作和新修改操作的数量）…………了吗？

**不是**。因为清空一棵树需要的时间为 $O(n)$，每个编码都清空一次，时间复杂度爆炸！

如何解决该问题呢？  
可以发现编码为 $k$ 的操作涉及的位置的数量不超过 $2c_k$，而 $\sum{c_k} \le n + 2m$。所以我们可以离散化这些位置，这样清空树的总时间就回到了 $O(n)$，可以接受。

于是，这部分的时间复杂度真正成为 $O(\sum {c_k \log c_k}) \le O(n \log \max{c_k})$。  
加上排序的复杂度 $O(n \log n)$，总复杂度 $O(n \log n)$。

## 代码

[提交记录](https://www.luogu.com.cn/record/90380025)。

```cpp
#include <bits/stdc++.h>
// foru (i, l, r) ... 让 i 从 l 增加到 r（l <= i <= r）
#define foru(i, l, r) for(int i=(l); i<=(r); i++)
// ford (i, l, r) ... 让 i 从 l 减小到 r（l >= i >= r）
#define ford(i, l, r) for(int i=(l); i>=(r); i--)
typedef long long ll;
// 快读快写已省略，可在此查看：https://www.luogu.com.cn/paste/hn6sr155
using io::fio;
const int N=1e5;
int n, m, arr[N+10], ans[N*3+10];
struct Oper { // 操作
	bool isQuery;
	int id, k, x, y;
	inline void setValue(int id, int k, int x, int y) {
		this->id = id;
		this->k = k;
		this->x = x;
		this->y = y;
	}
} oper[N*3+10]; // 大小要开到 n + 2*m，即 N*3

struct Fenwick { // 树状数组
	int size, val[N+10];
	inline void build(int size) {
		this->size = size;
		memset(val, 0, sizeof(int) * (size + 5));
	}
	void update(int x, int v) {
		while (x <= size) {
			val[x] += v;
			x += x & (-x);
		}
	}
	int query(int x) {
		int ret = 0;
		while (x) {
			ret += val[x];
			x -= x & (-x);
		}
		return ret;
	}
	inline int query(int x, int y) {
		if (x > y) return 0;
		return query(y) - query(x - 1);
	}
} tree;

void solve(int left, int right) {
	// 离散化
	static int hashPos[N+10];
	int mx_pos = 0;
	std::set<int> st;
	foru (i, left, right) {
		Oper &op = oper[i];
		if (op.isQuery) {
			st.insert(op.x);
			st.insert(op.y);
		} else {
			st.insert(op.x);
		}
	}
	for (const int &x : st) hashPos[x] = ++mx_pos;
	// “暴力”
	tree.build(mx_pos);
	foru (i, left, right) {
		Oper &op = oper[i];
		if (op.isQuery) ans[op.id] = tree.query(hashPos[op.x], hashPos[op.y]);
		else tree.update(hashPos[op.x], op.y);
	}
}

int main() {
	fio >> n >> m;
	int num_oper = 0;
	foru (i, 1, n) {
		fio >> arr[i];
		// 将初始数组作为修改操作
		Oper &op = oper[++num_oper];
		op.setValue(num_oper, arr[i], i, 1);
	}
	foru (i, 1, m) {
		char c;
		fio >> c;
		switch (c) {
			case 'C': {
				int x, k;
				fio >> x >> k;
				// 转化修改操作
				Oper &op1 = oper[++num_oper];
				op1.setValue(num_oper, arr[x], x, -1);
				Oper &op2 = oper[++num_oper];
				op2.setValue(num_oper, arr[x] = k, x, 1);
				break;
			}
			case 'Q': {
				int x, y, k;
				fio >> x >> y >> k;
				Oper &op = oper[++num_oper];
				op.setValue(num_oper, k, x, y);
				op.isQuery = true;
				break;
			}
		}
	}
	// 将 ans 全设为 -1，于是：ans 非负数 <=> 查询操作的答案
	memset(ans, 0xff, sizeof(int) * (num_oper + 5));
	// 将操作按 k 排序，k 相同的按 id 排序，以保证操作顺序
	std::sort(oper+1, oper+1+num_oper, [](Oper &a, Oper &b) {
		if (a.k != b.k) return a.k < b.k;
		return a.id < b.id;
	});
	// 处理所有按 k 分成的部分
	for (int l = 1, r; l <= num_oper; l = r + 1) {
		r = l;
		while (r + 1 <= num_oper && oper[r + 1].k == oper[l].k) ++r;
		solve(l, r);
	}
	foru (i, 1, num_oper) {
		if (ans[i] < 0) continue;
		fio << ans[i] << '\n';
	}
	
	return 0;
}
```

## 补充

对随机数据，如何达到几乎 $O(n)$ 呢？

随机数据下，$\max{c_k}$ 是一个很小的数字，$O(n \log \max{c_k})$ 接近 $O(n)$。  
对于排序，使用基数排序可达到 $O(n)$。  
因此总复杂度几乎 $O(n)$。

不过由于常数较大，对本题并不会比优化前快多少。


---

## 作者：XZYQvQ (赞：8)

安利一发自己博客：[传送门=￣ω￣=](http://k-xzy.cf/archives/3134)


我做这题的历程：


1. 普通线段树套平衡树（map），70分

2. 半递归式（修改变为递推）线段树套平衡树（map），80分

3. 树状数组套平衡树（map），90分

4. 树状数组套哈希表（pbds,cc\_hash\_table），90分

5. 树状数组套哈希表（pbds,gp\_hash\_table），<font color=lime>AC</font>


心累啊。


具体做法很暴力，就是对于树状数组的每个节点搞个哈希表存某种编码出现的次数。


查询和修改就和普通的树状数组一模一样。


代码很短。


代码：

```cpp
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#define lowbit(a) (a&-a)
using namespace std;
using namespace __gnu_pbds;
template<typename _Tp>inline void IN(_Tp&dig)
{
    char c;bool flag=0;dig=0;
    while(c=getchar(),!isdigit(c))if(c=='-')flag=1;
    while(isdigit(c))dig=dig*10+c-'0',c=getchar();
    if(flag)dig=-dig;
}
int n,m,data[100005];
char opt[5];
gp_hash_table<int,int> mp[100005];
void update(int pos,int k,int d){while(pos<=n)mp[pos][k]+=d,pos+=lowbit(pos);}
int query(int pos,int k)
{
    int sum=0;
    while(pos)sum+=mp[pos][k],pos-=lowbit(pos);
    return sum;
}
int main()
{
    IN(n),IN(m);
    for(int i=1;i<=n;i++)IN(data[i]),update(i,data[i],1);
    int a,b,c;
    while(m--)
    {
        scanf("%s",opt),IN(a),IN(b);
        if(opt[0]=='Q')IN(c),printf("%d\n",query(b,c)-query(a-1,c));
        else update(a,b,1),update(a,data[a],-1),data[a]=b;
    }
    return 0;
}
```

---

## 作者：Walrus (赞：4)

# P2464
一道区间问题，看到 $1\leq N,M \leq 10^5$，考虑离线算法。

这里把**带修莫队**补上。

## 题意
有一排书架，编号为 $1$ 到 $N$，上面放有 $N$ 本书，依次编码为 $a_1 \sim a_N$，支持两种操作。

- 把书架上编号为 $A$ 上的书的编码改为 $P$。
- 询问 $l\sim r$ 的区间内有多少本书的编号为 $K$。

## 做法
显然是一个可支持修改的数据结构，又是离线算法，理应想到带修莫队。

又由于 $1\leq a_i\leq 2^{31}-1$，所以应当**离散化**。这里介绍一种比较便捷且快捷的方法。

先考虑哪些东西需要离散化。

- $a$ 数组。
- 查询操作的值。
- 修改操作的编码和值。

用 `map` 离散化就不用我多说了，这里提一下预处理。

当我们为每一个值赋上了一个对应的编号时，我们可以直接将这个值改为为其赋的编号，就像这样。

```cpp
for(int i = 1; i <= n; ++i) {
	cin >> a[i];
	if(!mp[a[i]])
		mp[a[i]] = ++tot;
	a[i] = mp[a[i]];
}
```

这样做有什么好处呢？

- 避免了在莫队进行 `add` 和 `del` 操作时多次使用 `map` 查询。
- 避免了多次在一些东西前加 `map`，减少犯错的可能性。

带修莫队的好处还有一点：

- 在进行 `add` 和 `del` 操作时不需要一直统计答案，只需要在循环结束后直接取出。

## Code
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 1e5 + 5;
const int M = 1e6 + 5;

int a[N], ans[N], c[M << 1], cnt, n, m, k, len, l, r, val;
int qcnt, rcnt;
char op;

struct node {
	int l, r, val, id, t;
	#define l(p) t[p].l
	#define r(p) t[p].r
	#define id(p) t[p].id
	#define val(p) t[p].val
	#define t(p) t[p].t
	
	bool operator < (const node &a) const {
		if(l / len != a.l / len)
			return l / len > a.l / len;
		else if(r / len != a.r / len)
			return r / len > a.r / len;
		else
			return t > a.t;
	}
} t[N];

struct time {
	int p, x;
	#define p(i) R[i].p
	#define x(i) R[i].x
} R[N];

unordered_map<int, int> mp;
int tot;

void add(int x, int V) {
	++c[x];
}

void del(int x, int V) {
	--c[x];
}

void update(int x, int val) {
	if(l <= p(x) && p(x) <= r)
		add(x(x), 1), del(a[p(x)], 1);
	swap(x(x), a[p(x)]);
}


signed main() {
	ios::sync_with_stdio(0);
	cin.tie(nullptr), cout.tie(nullptr);
	
	cin >> n >> m;
	for(int i = 1; i <= n; ++i) {
		cin >> a[i];
		if(!mp[a[i]])
			mp[a[i]] = ++tot;
		a[i] = mp[a[i]];
	}
		
	
	len = pow(n, 2.0 / 3);//带修莫队的块长一般以它为标准
	
	for(int i = 1; i <= m; ++i) {
		cin >> op >> l >> r;
		if(op == 'Q')  {
			cin >> val;
			if(!mp[val])
				mp[val] = ++tot;
			val = mp[val];
			t[++qcnt] = {l, r, val, qcnt, rcnt};
		}
		else {
			if(!mp[r])
				mp[r] = ++tot;
			r = mp[r];
			R[++rcnt] = {l, r};
		}
	}
	
	sort(t + 1, t + 1 + qcnt);
	
	l = 1, r = 0;
	
	for(int i = 1, last = 0; i <= qcnt; ++i) {
		while(l > l(i)) add(a[--l], 1);
		while(r < r(i)) add(a[++r], 1);
		while(l < l(i)) del(a[l++], 1);
		while(r > r(i)) del(a[r--], 1);
		while(last < t(i)) update(++last, 1);
		while(last > t(i)) update(last--, 1);
		ans[id(i)] = c[val(i)];
	} 
	for(int i = 1; i <= qcnt; ++i)
		cout << ans[i] << '\n';
	return 0;
}
```


---

## 作者：λᴉʍ (赞：4)

先推荐一下[博客](http://www.cnblogs.com/xzz\_233/p/7396374.html)。。。


我这里的“种类”就是原题的“编码”。。。


对每种书建立一棵平衡树（我用无旋treap），然后一开始往每个平衡树里插坐标（当然要有序插入）。


开一个数组记录每个位置上书的种类。


对于'C'操作，找到这个位置上书的种类，然后在对应平衡树上删去这个坐标。再记录新的种类，在对应平衡树上新增这个坐标。每个平衡树记录的坐标都应该是有序的。


对于'Q'操作，答案是对应平衡树上的B的排名减去(A-1)的排名，所以剩下的区间就是[A,B]。


输入保证书的种类$<=2^{31}−1$，所以要离散化。。。我只会map。。。而且懒得打离线了。。。所以边读入边离散化。。。离散化在ins函数中体现，及每读入一次就插入（有的话当然不插入）



---

## 作者：waaadreamer (赞：4)

这道题看各位大神用各种二叉树AC，可是我懒（其实不知道怎么用），没写二叉树，写了个超级简单的分块就AC了，效率还前几……

我们可以把数列分成几块，每块用map维护（STL大法好），map可以直接储存当前块内某个数字的个数，然后就可以乱搞了。

对于询问，直接就是块状数组最基本的询问方式，更改就先更改数列，然后修改当前块的map值，为了节省空间，如果当前块某个数字的出现个数变成0了，可以直接删除。

这样总复杂度为O((k+(n/k)·log k)·m)，其中k是每个块的大小。

可以通过函数求导算出大致k=sqrt(n·log n)的时候复杂度最低，为O(m·sqrt(n·log n))。

分块大法好……

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include <string.h>
#include <vector>
#include <math.h>
#include <queue>
#include <map>
#include <functional>
#include <time.h>
#define inline __attribute((always_inline))
#define INF 0x3f3f3f3f
using namespace std;
typedef long long ll;

const int maxn = 100005, maxs = 400;
int seq[maxn], n, m, sz;
map<int, int> buc[maxs];
map<int, int>::iterator it;
char opt[5];
int main(){
    scanf("%d%d", &n, &m);
    sz = sqrt(n * log2(n));
    for(int i = 0; i < n; i++){
        scanf("%d", seq + i);
        int k = i / sz;
        it = buc[k].find(seq[i]);
        if(it == buc[k].end()) buc[k].insert(make_pair(seq[i], 1));
        else it->second++;
    }
    while(m--){
        scanf("%s", opt);
        if(opt[0] == 'C'){
            int p, x;
            scanf("%d%d", &p, &x); p--;
            int k = p / sz;
            it = buc[k].find(seq[p]);
            if(--it->second == 0) buc[k].erase(it);
            seq[p] = x;
            it = buc[k].find(x);
            if(it == buc[k].end()) buc[k].insert(make_pair(x, 1));
            else it->second++;
        } else {
            int s, t, x;
            scanf("%d%d%d", &s, &t, &x); s--, t--;
            int ks = s / sz, kt = t / sz, res = 0;
            if(ks * sz == s) ks--;
            if(kt * sz + sz - 1 == t) kt++;
            for(int i = ks + 1; i < kt; i++){
                it = buc[i].find(x);
                if(it != buc[i].end()) res += it->second;
            }
            int end = min(t + 1, ks * sz + sz);
            for(int i = s; i < end; i++) res += seq[i] == x;
            if(end <= t) for(int i = kt * sz; i <= t; i++) res += seq[i] == x;
            printf("%d\n", res);
        }
    }
    return 0;
}
```

---

## 作者：Ameyax (赞：3)

STL大法好

用map离散化书的编码

vector存每种编码出现的位置

查询lower\_bound，修改erase，insert

再稍微讨论一下就可以了

~~不开O2快有O2下的4倍了~~

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAX = 220000;
map<int, int> f;
vector<int> g[MAX];
int cnt;
int read()
{
    int x = 0, f = 1; char ch = getchar();
    while (!isdigit(ch)) { if (ch == '-') f = -1; ch = getchar(); }
    while (isdigit(ch)) { x = x * 10 + ch - '0'; ch = getchar(); }
    return x * f;
}
int n, q;
int a[MAX];
vector<int>::iterator il, ir;
int main()
{
    n = read(), q = read();
    for (int i = 1; i <= n; i++)
    {
        a[i] = read();
        if (!f[a[i]]) f[a[i]] = ++cnt;
        g[f[a[i]]].push_back(i);
    }
    while (q--)
    {
        char ask[5];
        scanf("%s", ask);
        if (ask[0] == 'Q')
        {
            int l = read(), r = read(), x = read();
            ir = lower_bound(g[f[x]].begin(), g[f[x]].end(), r);
            il = lower_bound(g[f[x]].begin(), g[f[x]].end(), l);
            int ans = 0;
            if (il == g[f[x]].end())
            {
                puts("0");
                continue;
            }
            if (* ir == r) ans ++;
            printf("%d\n", ans + (ir - il));
        }
        else
        {
            int p = read(), x = read();
            if (a[p] == x) continue;
            if (!f[x]) f[x] = ++cnt;
            g[f[a[p]]].erase(lower_bound(g[f[a[p]]].begin(), g[f[a[p]]].end(), p));
            g[f[x]].insert(lower_bound(g[f[x]].begin(), g[f[x]].end(), p), p);
            a[p] = x;
        }
    }
    return 0;
}
```
坚持不用STL可以离线离散化编码后用平衡树维护上面vector干的事也行


---

## 作者：Super_Cube (赞：2)

# Solution

第一眼：单点修改，区间查询编号。这不是树套树板题？

然后再一看，空间限制只有 128 MiB。

然后仔细算算，树套树就算离散化空间复杂度再怎么也是 $O(n\log^2n)$，肯定不够用。

当然数据不一定都能卡满，但我们总不能去赌数据的强度吧。

这时候发现这个题可以离线！而 cdq 分治的作用就是降维，刚好可以把空间复杂度降下来。

具体的，对数据进行离散化，把查询操作改为前缀相减，把修改操作变为原来的编码数量减一，修改后的编码数量加一，离线下来之后时间维度默认有序，在 cdq 内部按照位置排序，归并算贡献的时候对左半部分的修改打桶记录，然后对右半部分的查询查桶。

时间复杂度：$O((n+m)\log(n+m))$。

空间复杂度：$O(n+m)$。

# Code

```cpp
#include <bits/stdc++.h>
struct ques {
    int x, y, z, id;
};
std::vector<ques> v;
int cnt[200005];
int ans[100005];
void cdq(int l, int r) {
    if (l == r)
        return;
    int mid = l + r >> 1;
    cdq(l, mid);
    cdq(mid + 1, r);
    int i = l, j = mid + 1;
    for (; j <= r; ++j) {
        for (; i <= mid && v[i].x <= v[j].x; ++i)
            if (!v[i].id)
                cnt[v[i].y] += v[i].z;
        if (v[j].id)
            ans[v[j].id] += v[j].z * cnt[v[j].y];
    }
    for (int k = l; k < i; ++k)
        if (!v[k].id)
            cnt[v[k].y] -= v[k].z;
    std::inplace_merge(v.begin() + l, v.begin() + mid + 1, v.begin() + r + 1,
                       [&](ques x, ques y) { return x.x < y.x; });
}
std::unordered_map<int, int> mp;
int a[100005];
int n, m, qdx, idx;
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++i) {
        scanf("%d", &a[i]);
        if (!mp.count(a[i]))
            mp[a[i]] = ++idx;
        a[i] = mp[a[i]];
        v.push_back((ques){ i, a[i], 1, 0 });
    }
    for (int l, r, x; m--;) {
        static char op;
        scanf("\n %c%d", &op, &l);
        if (op == 'C') {
            scanf("%d", &x);
            if (!mp.count(x))
                mp[x] = ++idx;
            x = mp[x];
            v.push_back((ques){ l, a[l], -1, 0 });
            v.push_back((ques){ l, a[l] = x, 1, 0 });
        } else {
            scanf("%d%d", &r, &x);
            if (!mp.count(x))
                mp[x] = ++idx;
            x = mp[x];
            ++qdx;
            v.push_back((ques){ r, x, 1, qdx });
            v.push_back((ques){ l - 1, x, -1, qdx });
        }
    }
    cdq(0, v.size() - 1);
    for (int i = 1; i <= qdx; ++i) printf("%d\n", ans[i]);
    return 0;
}
```

---

## 作者：Kevin327 (赞：2)

这里给一种易于理解的数组版非旋$treap$做法。

我们给每一个编号开一个$treap$，观察到总点数的值是确定的，那么我们记录下每一个$treap$的根节点即可。在查询的时候，我们找到对应的$treap$里面权值在$[a,b]$之间点的个数。插入的话我们需要用一个数组记录一下每一个位置对应的书的编号，然后每次根据这个编号先删除再插入。

动态开点。观察到编号范围很大，我们使用$unordered$_$map$。

这题应该算是$treap$板子题了。

```
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<map>
#include<cstdlib>
#include<tr1/unordered_map>
using namespace std;
using namespace std::tr1;
int root[201000],tree[201000],size[201000],re[201000];
int to[201000][2],cnt=0,pri[201000],n,m;
unordered_map<int,int> mp;
void update(int x)
{
	size[x]=size[to[x][0]]+size[to[x][1]]+1;
}
int build(int x)
{
	size[++cnt]=1;
	tree[cnt]=x;
	pri[cnt]=rand();
	to[cnt][0]=to[cnt][1]=0;
	return cnt;
}
int merge(int x,int y)
{
	if (!x||!y) return x+y;
	if (pri[x]<=pri[y]){
		to[y][0]=merge(x,to[y][0]);
		update(y);
		return y;
	}	
	else {
		to[x][1]=merge(to[x][1],y);
		update(x);
		return x;
	}
}
void split(int now,int k,int &x,int &y)
{
	if (!now) x=y=0;
	else if (tree[now]<=k){
		x=now;
		split(to[now][1],k,to[now][1],y);
		update(now);
	}
	else {
		y=now;
		split(to[now][0],k,x,to[now][0]);
		update(now);
	}
}
void insert(int wit,int val)
{
	if (!root[wit]) {
	root[wit]=build(val);return;}; 
	int x,y;
	split(root[wit],val,x,y);
	root[wit]=merge(merge(x,build(val)),y);
}
int query(int wit,int l,int r)
{
	int x,y,z,h;
	split(root[wit],l-1,x,y);
	split(y,r,z,h);
	int an=size[z];
	root[wit]=merge(x,merge(z,h));
	return an;
}
void del(int wit,int val)
{
	int x,y,z,h;
	split(root[wit],val,x,y);
	split(x,val-1,z,h);
	h=merge(to[h][0],to[h][1]);
	root[wit]=merge(merge(z,h),y);
}
int main()
{
	int tot=0;
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n;i++){
		int a;
		scanf("%d",&a);
		if (!mp.count(a)) mp[a]=++tot;
		insert(mp[a],i);
		re[i]=mp[a];
	}
	for (int i=1;i<=m;i++){
		char c;
		scanf(" %c",&c);
		if (c=='C'){
			int a,p;
			scanf("%d%d",&a,&p);
			if (!mp.count(p)) mp[p]=++tot;
			del(re[a],a);
			insert(mp[p],a);
			re[a]=mp[p];
		}
		else {
			int a,b,k;
			scanf("%d%d%d",&a,&b,&k);
			if (!mp.count(k)) {
				printf("0\n");
				continue;
			}
			printf("%d\n",query(mp[k],a,b));
		}
	}
	return 0;
}
```

---

## 作者：letitdown (赞：2)

先对所有书的编号离散化。然后我们来选择实现的数据结构。

考虑线段树套线段树。第一层线段树代表的是区间信息，其中每一个节点上都有着一个动态开点权值线段树代表自己管辖区间内的取值情况。当修改时我们在第一层线段树上递归，在每一个经过的节点的线段树中删去被修改点原来的权值，加上修改后的权值。当查询时则递归到对应的区间查询对应值有多少个并加和即可。

有个很大的问题就是内存不够用。我们可以开一个内存池回收权值已经变成0的节点，因为它已经没有用了，当创建新节点时再重复用即可。

这样的话时空复杂度都是 $O(n\log^2n)$ 的，可以通过本题。

## Code
```cpp
#include<cstring>
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
namespace EMT{
	typedef long long ll;typedef double db;//(double)clock() / (double)CLOCKS_PER_SEC;
	#define pf printf
	#define F(i,a,b) for(register int i=a;i<=b;i++)
	#define D(i,a,b) for(register int i=a;i>=b;i--)
	inline int read(){int x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();return x*f;}
	inline void file(){freopen("in.in","r",stdin);freopen("my.out","w",stdout);}
	inline int max(int a,int b){return a>b?a:b;}inline int min(int a,int b){return a<b?a:b;}
	inline void pi(int x){pf("%d ",x);}inline void pn(){pf("\n");}
	const int N=1e5+10;
	int rt[N<<2];
	struct seg{
		int siz[N*100],ls[N*100],rs[N*100],tot,sta[N*10],top;
		inline int cre(){
			return top?sta[top--]:++tot;
		}
		inline void change(int &p,int l,int r,int x,int v){
			if(!p)p=cre();siz[p]+=v;
			if(l==r){
			    if(!siz[p])sta[++top]=p,p=0;
			    return;
			}
			int mid=(l+r)>>1;
			if(x<=mid)change(ls[p],l,mid,x,v);
			else change(rs[p],mid+1,r,x,v);
			if(!siz[p])sta[++top]=p,p=0;
		}
		inline int ask(int p,int l,int r,int x){
			if(!p)return 0;
			if(l==r)return siz[p];
			int mid=(l+r)>>1;
			if(x<=mid)return ask(ls[p],l,mid,x);
			else return ask(rs[p],mid+1,r,x);
		}
	}segm;
	int s[N<<1],a[N],len,n,m,opt[N],x[N],y[N],z[N];
	inline void build(int p,int l,int r){
		F(i,l,r)segm.change(rt[p],1,len,a[i],1);
		if(l==r)return;
		int mid=(l+r)>>1;
		build(p<<1,l,mid),build(p<<1|1,mid+1,r);
	}
	inline void change(int p,int l,int r,int x,int v1,int v2){
		segm.change(rt[p],1,len,v1,-1),segm.change(rt[p],1,len,v2,1);
		if(l==r)return;
		int mid=(l+r)>>1;
		if(x<=mid)change(p<<1,l,mid,x,v1,v2);
		else change(p<<1|1,mid+1,r,x,v1,v2);
	}
	inline int ask(int p,int l,int r,int ql,int qr,int v){
		if(l>=ql&&r<=qr)return segm.ask(rt[p],1,len,v);
		int mid=(l+r)>>1;
		if(qr<=mid)return ask(p<<1,l,mid,ql,qr,v);
		else if(ql>mid)return ask(p<<1|1,mid+1,r,ql,qr,v);
		else return ask(p<<1,l,mid,ql,mid,v)+ask(p<<1|1,mid+1,r,mid+1,qr,v);
	}
	inline short main(){
	//	file();
		len=n=read(),m=read();
		F(i,1,n)a[i]=s[i]=read();
		F(i,1,m){
			char ch=getchar();
			while(ch!='C'&&ch!='Q')ch=getchar();
			if(ch=='C')opt[i]=1,x[i]=read(),s[++len]=y[i]=read();
			else opt[i]=2,x[i]=read(),y[i]=read(),s[++len]=z[i]=read();
		}
		std::sort(s+1,s+len+1);
		len=std::unique(s+1,s+len+1)-s-1;
		F(i,1,n)a[i]=std::lower_bound(s+1,s+len+1,a[i])-s;
		build(1,1,n);
		F(i,1,m){
			if(opt[i]==1){
				y[i]=std::lower_bound(s+1,s+len+1,y[i])-s;
				if(a[x[i]]==y[i])continue;
				change(1,1,n,x[i],a[x[i]],y[i]);
				a[x[i]]=y[i];
			}else{
				z[i]=std::lower_bound(s+1,s+len+1,z[i])-s;
				pi(ask(1,1,n,x[i],y[i],z[i])),pn();
			}
		}
		return 0;
	}
}
signed main(){return EMT::main();}
```

---

## 作者：mulberror (赞：1)

$$\href{http://blog.chhokmah.top/index.php/archives/65/}{\Large\texttt{My blog}}$$

---
# Description
> Link：[洛谷](https://www.luogu.org/problemnew/show/P2464)

数列上有$n$个颜色  
两种操作：1、单点修改。2、区间查询$[l,r]$内颜色$k$出现的次数。
# Data range 
$n,m\leq 100000$
<!--more-->
做一做水题，冷静一下。  
# Solution
对于每一个颜色建立一个平衡树，权值就是位置。  
然后的查询就简单了。  
在修改的时候把原来的颜色调出来。  
查询的时候查找区间内的前驱和后继就可以了。  
记得要离散化呦~~
# Code
洛谷开了O2才过掉了的垃圾代码 /kk
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 200000 + 6;
const int inf = 2147483647;
struct Treap {
    int tot, rt;
    struct node {
        int val, ch[2], rd, cnt, sz;
        void Init(int Val) { val = Val, rd = rand() % 300; sz = cnt = 1; ch[1] = ch[0] = 0; }
    } tr[N * 10];
    void pushup(int nod) { tr[nod].sz = tr[tr[nod].ch[0]].sz + tr[tr[nod].ch[1]].sz + tr[nod].cnt; }
    void rotate(int &nod, int d) {
        int k = tr[nod].ch[d]; tr[nod].ch[d] = tr[k].ch[d ^ 1]; tr[k].ch[d ^ 1] = nod;
        pushup(nod); pushup(k); nod = k; 
    }
    void ins(int &nod, int val) {
        if (!nod) { nod = ++ tot; tr[nod].Init(val); }
        else {
            tr[nod].sz ++; 
            if (tr[nod].val == val) { tr[nod].cnt ++; return; }
            int d = val > tr[nod].val; 
            ins(tr[nod].ch[d], val);
            if (tr[nod].rd > tr[tr[nod].ch[d]].rd) rotate(nod, d);
        }
    }
    void del(int &nod, int val) {
    	if (!nod) return;
    	if (tr[nod].val == val) {
    		if (tr[nod].cnt > 1) { tr[nod].cnt --, tr[nod].sz --; return; } 
    		int d = tr[tr[nod].ch[0]].rd > tr[tr[nod].ch[1]].rd;
    		if (!tr[nod].ch[1] || !tr[nod].ch[0]) nod = tr[nod].ch[1] + tr[nod].ch[0];
    		else rotate(nod, d), del(nod, val);
        }
        else tr[nod].sz --, del(tr[nod].ch[tr[nod].val < val], val);
    }
    int pre(int nod, int val) {
        if (!nod) return -inf;
        if (tr[nod].val > val) return pre(tr[nod].ch[0], val);
        else return max(tr[nod].val, pre(tr[nod].ch[1], val));
    }
    int suc(int nod, int val) {
        if (!nod) return inf;
        if (tr[nod].val < val) return suc(tr[nod].ch[1], val);
        else return min(tr[nod].val, suc(tr[nod].ch[0], val));
    }
    int rk(int nod, int val) {
    	if (!nod) return 0; 
    	if (tr[nod].val == val) return tr[tr[nod].ch[0]].sz + 1; 
    	if (tr[nod].val > val) return rk(tr[nod].ch[0], val);
    	else return rk(tr[nod].ch[1], val) + (tr[tr[nod].ch[0]].sz + tr[nod].cnt);
    }
}tp;
struct Qus_Rec { int opt, x, y, z; } QwQ[N]; 
int disc[N << 1], dn = 0, b[N], a[N];
int rt[N], n, m; 
int main() { 
    memset(rt, 0, sizeof(rt));
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++) scanf("%d", &a[i]), disc[++ dn] = a[i]; 
    for (int i = 1; i <= m; i ++) {
        char opt[5]; int x, y, z; 
        scanf("%s%d%d", opt, &x, &y);
        if (opt[0] == 'Q') {
            scanf("%d", &z);
            QwQ[i].opt = 0; QwQ[i].x = x; QwQ[i].y = y; QwQ[i].z = z; disc[++ dn] = z; 
        } else {  QwQ[i].opt = 1; QwQ[i].x = x; QwQ[i].y = y; disc[++ dn] = y; }
    }
    sort(disc + 1, disc + 1 + dn);
    dn = unique(disc + 1, disc + 1 + dn) - disc - 1;
    for (int i = 1; i <= n; i ++) {
        b[i] = lower_bound(disc + 1, disc + 1 + dn, a[i]) - disc;
        tp.ins(rt[b[i]], i);
    } 
    for (int i = 1; i <= m; i ++) {
    	if (!QwQ[i].opt) QwQ[i].z = lower_bound(disc + 1, disc + 1 + dn, QwQ[i].z) - disc;
        else QwQ[i].y = lower_bound(disc + 1, disc + 1 + dn, QwQ[i].y) - disc;
    }
    for (int i = 1; i <= m; i ++) {
        if (!QwQ[i].opt) {
            int l = tp.suc(rt[QwQ[i].z], QwQ[i].x), r = tp.pre(rt[QwQ[i].z], QwQ[i].y);
            if (l == inf || r == -inf) printf("0\n");
            else printf("%d\n", tp.rk(rt[QwQ[i].z], r) - tp.rk(rt[QwQ[i].z], l) + 1);
        } else {
            tp.del(rt[b[QwQ[i].x]], QwQ[i].x);
            tp.ins(rt[QwQ[i].y], QwQ[i].x); 
            b[QwQ[i].x] = QwQ[i].y; 
        }
    }
    return 0;
}
```

---

## 作者：wcyQwQ (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P2464)

[可能更好的阅读体验](https://chenyu-w.github.io/2022/08/11/P2464%E9%83%81%E9%97%B7%E7%9A%84%E5%B0%8FJ/)

## 前言

这是一个不会写带修莫队所以分块乱搞的蒟蒻。

### 前置芝士

分块

## 分析

首先看到这个 $2^{31}-1$ 的值域，肯定要离散化，离散化后考虑对原序列分块，块长为 $\sqrt{n}$。

我们用 $cnt[i][x]$ 表示第 $i$ 块中 $x$ 的出现次数。

对于每个修改操作，我们将当前块中原数出现次数减一，新数出现次数加一，最后在原序列中修改即可。

对于每个查询操作，我们分两种情况考虑:

1. 若 $l$ 和 $r$ 在同一块中，那么我们直接扫描暴力得出答案。
2. 若 $l$ 和 $r$ 在不同块中，那么我们对 $l$ 和 $r$ 所在块分别暴力统计，用维护的 $cnt$ 数组统计中间块答案即可。

时间复杂度 $O(n\sqrt{n})$。

## 代码

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 2e5 + 10, B = 320;
int a[N], tot;
int cnt[B][N];
int id[N];
unordered_map<int, int> h;

int read()
{
    int x = 0, y = 1; char c = getchar();
    while (c < '0' || c > '9') {if (c == '-') y = -1; c = getchar();}
    while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
    return x * y;
}

void modify(int x, int c)
{
    if (!h[c]) h[c] = ++tot;
    c = h[c];
    cnt[id[x]][a[x]]--, cnt[id[x]][c]++;
    a[x] = c;
}

int query(int l, int r, int k)
{
    k = h[k];
    if (id[l] == id[r])
    {
        int res = 0;
        for (int i = l; i <= r; i++)
            if (a[i] == k) res++; 
        return res;
    }
    int res = 0;
    for (int i = l; id[i] == id[l]; i++)
        if (a[i] == k) res++;
    for (int i = r; id[i] == id[r]; i--)
        if (a[i] == k) res++;
    for (int i = id[l] + 1; i <= id[r] - 1; i++)
        res += cnt[i][k];
    return res;
}

int main()
{
    int n = read(), m = read();
    for (int i = 1; i <= n; i++)
    {
        a[i] = read();
        if (!h[a[i]]) h[a[i]] = ++tot;
        a[i] = h[a[i]];
        id[i] = (i - 1) / B + 1;
        cnt[id[i]][a[i]]++;
    }
    while (m--)
    {
        char op;
        cin >> op;
        if (op == 'C')
        {
            int x = read(), c = read();
            modify(x, c);
        }
        else
        {
            int l = read(), r = read(), k = read();
            printf("%d\n", query(l, r, k));
        }
    }
    return 0;
}
```



---


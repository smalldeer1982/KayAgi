# [JLOI2013] 删除物品

## 题目描述

箱子再分配问题需要解决如下问题：

1. 一共有 $N$ 个物品，堆成 $M$ 堆。

2. 所有物品都是一样的，但是它们有不同的优先级。

3. 你只能够移动某堆中位于顶端的物品。

4. 你可以把任意一堆中位于顶端的物品移动到其它某堆的顶端。若此物品是当前所有物品中优先级最高的，可以直接将之删除而不用移动。

5. 求出将所有物品删除所需的最小步数。删除操作不计入步数之中。

6. 这是一个比较难解决的问题，这里你只需要解决一个比较简单的版本：不会有两个物品有着相同的优先级，且 $M=2$。


## 说明/提示

$1\leq N_1+N_2\leq 100000$


## 样例 #1

### 输入

```
3 3
1
4
5
2
7
3```

### 输出

```
6```

# 题解

## 作者：nao_nao (赞：28)

### 题意：

有两堆物品，我们可以把两堆最上面的物品移到另一堆。当当前优先级最大的物品在堆顶的时候，我们可以将它拿走删掉。要求我们将两堆全部删掉，求所需的最少步数（删除物品操作不计入）。

### 题解：

我们首先考虑按照题意模拟。因为只有优先级最大的物品才可以移除，因此我们每一步的操作是可以确定下来的：我们找到优先级最大的物品，把它上面的物品都移到另一堆上，使其成为堆顶，然后删掉它。我们可以发现这种做法的正确性显然，于是我们 ~~A掉了这道题~~ 发现 $n^2$ 的复杂度显然不正确。

我们发现，我们将一串数从一个堆移向另一个堆之后，这串数字的顺序正好变成了原先的倒序。例如：$1,3,5,7$ 移动后就变成了 $7,5,3,1$ 。(按堆底到堆顶顺序)，~~此规律手玩可知，正确性显然~~。

我们考虑将两个堆的堆顶相接，无论我们是将堆内的数字移动还是删除，任意两个尚没被删掉的物品的相对位置是不变的。

我们可以使用一个变量来记录堆顶的位置，改变此变量相当于移动了堆顶物品。

可以看出：这个变量所指的地方会从初始处移向最大值，再移向次大值，次次大值……我们将其所指向的地方的物品删除，然后统计它再次移动时越过的物品数量即可。

#### 实现：

我们使用树状数组，将物品赋值为 $1$ ，删掉物品就减一变成$0$。我们可以很轻松的 O($logn$)的求出区间1的数量也就是区间和。因此整体复杂度为O($nlogn$)。

code：
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;
const int N=2e5;
int n,m;
struct node{
	int p,a;
	friend bool operator < (node a,node b) {return a.a > b.a;}
}arr[N];

int z[N];
void add(int x,int a) {for(int i = x;i <= n+m+1;i += i&-i) z[i] += a;}
int query(int x) {int ret = 0;for(int i = x;i >= 1;i -= i&-i) ret += z[i];return ret;}


int main()
{
	scanf("%d %d",&n,&m);
	for(int i = n;i >= 1;i --){
		int a;scanf("%d",&a);
		arr[i] = (node){i,a};
		add(i,1);
	}
	for(int i = n+2;i <= n+1+m;i ++){
		int a;scanf("%d",&a);
		arr[i] = (node){i,a};
		add(i,1);
	}
	sort(arr+1,arr+2+m+n);
	int s = n+1;
	long long ans = 0;
	for(int i = 1;i <= m+n;i ++){
		node tmp = arr[i];
		ans += abs(query(s)-query(tmp.p)) - (tmp.p>s);
		add(tmp.p,-1);s = tmp.p;
	}
	printf("%lld",ans);
	return 0;
}
```
#### 个人实现细节（大佬可略过此处）：

因为我不好判断初始指针位置，所以我在两个堆之间留了一个空位来放初始指针。

用树状数组求 l 与 r 之间的和一般应该是
```cpp 
query(r-1)-query(l)
```
而我的写法是：
```cpp
ans += abs(query(s)-query(tmp.p)) - (tmp.p>s);
```

由于指针变量处的物品已被删掉，所以我就判断一下 $r$ 是不是指针变量所指位置，不是的话就减一，因为最大值处一定有物品存在，我这样写可以少写几个 if 。~~(才不是因为一开始写错了呢！)~~

---

## 作者：Pengsibo (赞：12)

#### 题目大意：

两堆数，需要不断删除**所有数**里最大的一个，而要删除你必须使得这个数在两堆里的其中一堆的堆顶，求移动次数使所有数被删除（删除不算移动）

#### 大概分析：

在手完之后，发现这道题的移动方式是唯一的，考虑暴力，要搜索两堆中最大值需要 O($n^2$)，炸了

怎么优化暴力呢？入手方向**思考简化查询过程**，能否从 $n^2$ 降到 $nlogn$ ？

另一个问题，在手玩过程中会发现，同样的一些数，如果翻过去再翻回来，**相对位置是不变的**，能否简化这个过程？

![分析1](https://cdn.luogu.com.cn/upload/image_hosting/t0w6x3go.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

我们仔细思考后发现，因为绿色+橙色字表明，**翻转两次不影响相对顺序**，所以我们可以**把两个栈拼起来**

然后我们发现，将栈拼起来后，可以**用普通排序来求最大值**，而这个时候就可以**用树状数组来求翻转了多少个数**

详细地讲，就是我们把拼起来的一串数排序（用结构体），如果位置$i$上有数，就将树状数组相应位置+1，数被删除后就-1，**用差分+前缀和来判断翻转了多少个数**

![分析2](https://cdn.luogu.com.cn/upload/image_hosting/g9tso3x7.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

所有问题迎刃而解！

### 上代码：

```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

int n,m;
int h,z;		//辅助输入 + 两个指针 
long long ans=0;

struct node
{
	int val;
	int id;
} x[200002];
int c[200002];

int lowbit(int k) {return k&-k;}

void add(int p,int q)
{
	for(register int i=p;i<=n+m;i+=lowbit(i)) c[i]+=q;
}

int query(int p)
{
	int cnt=0;
	for(register int i=p;i>=1;i-=lowbit(i)) cnt+=c[i];
	return cnt;
}

bool cmp(node a,node b) {return a.val>b.val;}	//大的放前面

int main()
{
	scanf("%d%d",&n,&m);
	for(register int i=n;i>=1;i--)
	{
		scanf("%d",&h); //后面h将被用作指针，这里先凑合着辅助输入
		x[i].val=h;	//倒着读入，方便拼接
	}
	for(register int i=n+1;i<=n+m;i++)
	{
		scanf("%d",&h);
		x[i].val=h;	//正着读入
	}
	for(register int i=1;i<=n+m;i++)
	{
		x[i].id=i;	//标号准备排序
		add(i,1);	//初始化树状数组
	}
	
	sort(x+1,x+n+m+1,cmp);
	
	h=n;			//作为指针"p1"，指向第一堆堆顶
	for(register int i=1;i<=n+m;i++)
	{
		z=x[i].id;	//作为指针"p2"，指向修改位
		
		if(h<z) ans+=query(z-1)-query(h),h=z-1,add(z,-1);
		else ans+=query(h)-query(z),h=z,add(z,-1);
        
            	//注意到，每次“翻转”，"p1"都会变化到之前修改处
                //所以实时更新"p1"，注意细节不要写错了
                //剩下的树状数组模板
	}
	
	printf("%lld",ans);
	
	return 0;
}
```

如果觉得有用还请留下好评，如有任何问题欢迎联系我，一定会尽快回复或修改

---

## 作者：zby2001 (赞：7)

模拟的时间复杂度是O(n^2)，过不了，但加上一点优化即可在O(nlogn)时间内解决

我们发现两个栈可以看作一个数组，而栈顶则是将这个数组拆成两个栈的分割点。

于是每次移动就变成了分割点的移动，每次移动时都统计下目的分割点和当前分割点之间的物品数目即可。

可用树状数组/线段树维护区间物品数目， 我这里用的是树状数组。















```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<queue>
#include<cstdlib>
#include<cctype>
#include<stack>
#define mem(a) memset(a, 0, sizeof(a))
using namespace std;
typedef long long LL;
typedef int T;
const int M = 0;
const int N = 100009;
struct Node {
    int x,  id;
    Node(int x = 0, int id = 0) : x(x), id(id) {}
    bool operator<(const Node &o) const {
        return x > o.x;
    }
};
int n1, n2, p;
int a1[100009];
int t[100009];
Node node[100009];
T _read();
void init();
void solve();
void add(int, int);
int query(int);
int main() {
    init();
    solve();
    return 0;
}
void init() {
    n1 = _read();
    n2 = _read();
    for(int i = n1; i >= 1; i--) {  //构造数组
        a1[i] = _read();
    }
    for(int i = n1 + 1; i <= n1 + n2; i++) {
        a1[i] = _read();
    }
}
void solve() {
    for(int i = 1; i <= n1 + n2; i++) { //确定移动顺序
        node[i] = Node(a1[i], i);
        add(i, 1);
    }
    sort(node + 1, node + 1 + n1 + n2);
    p = n1;
    LL ans = 0;
    for(int i = 1; i <= n1 + n2; i++) { //移动
        int x = node[i].id;
        if(p < x) {
            ans += query(x - 1) - query(p);
            p = x - 1;
            add(x, -1); //移动后删除物品
        }
        else {
            ans += query(p) - query(x);
            p = x;
            add(x, -1);
        }
    }
    printf("%lld\n", ans);
}
void add(int x, int v) {
    for(int i = x; i <= n1 + n2; i += i&(-i))
        t[i] += v;
}
int query(int x) {
    int ans = 0;
    for(int i = x; i; i -= i&(-i))
        ans += t[i];
    return ans;
}
T _read() {
    T a = 0, f = 1;
    char c = getchar();
    while(c < '0' || c > '9') {
        if(c == '-')
            f *= -1;
        c = getchar();
    }
    while(c <= '9' && c >= '0') {
        a *= 10;
        a += c - '0';
        c = getchar();
    }
    return a * f;
}

```

---

## 作者：StupidSeven (赞：3)

## Subject
[题目传送门](https://www.luogu.com.cn/problem/P3253)

## Analysis
显然，最小步数就是将目前该被删除的数所在的那堆该移的就移，暴力模拟是 $O(n^2)$ 的，考虑优化。

如果将被删除的位置上的数改成 $0$ 而不是删去，将两堆堆顶拼接起来，每个数之间的相对位置都是不变的，就变成了一个序列上的操作，每次移动的次数就是当前最大数和当前次大数之间数的个数，因为删除不算一次操作，所以不算上他们两个。

具体实现的话，可以用树状数组维护，初始所有值都是 $1$ ，删去一个数就是将这个位置减去 $1$ 。查询两个数之间数的个数，就是查询区间内 $1$ 的个数，区间和实现。套树状数组板子。

还有实现的一些小细节，具体见代码。
## Code
```cpp
#include<queue>
#include<cmath>
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
#define int long long
const int M=1e5+5;
const int inf=0x3f3f3f3f;
inline int Read(void){
    int s=0,f=1;char c=getchar();
    while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}
    while(isdigit(c)){s=s*10+c-48;c=getchar();}
    return s*f;    
}
struct Node{
	int val,idx;
	bool operator<(const Node &x)const{
		return val>x.val;
	}
}num[M];
int n,n1,n2,ans;
int pos[M];
int sum[M];
int lowbit(int x){
	return x&-x;
}
void Add(int x,int val){
	for(int i=x;i<=n;i+=lowbit(i))
		sum[i]+=val;
	return;
}
int Query(int x){
	int ans=0;
	for(int i=x;i;i-=lowbit(i))
		ans+=sum[i];
	return ans;
}
signed main(void){
	n1=Read();n2=Read();
	n=n1+n2;
	for(int i=n1;i>=1;i--){
		Add(i,1);
		num[i].val=Read();
		num[i].idx=i;
	}
	for(int i=n1+1;i<=n;i++){
		Add(i,1);
		num[i].val=Read();
		num[i].idx=i;
	}
	sort(num+1,num+1+n);
	ans+=(num[1].idx<=n1)?n1-num[1].idx:num[1].idx-n1-1;
	for(int i=1;i<n;i++){
		int idx1=num[i].idx,idx2=num[i+1].idx;
		Add(idx1,-1);
		if(idx1<idx2) swap(idx1,idx2);//idx1>idx2
		ans+=Query(idx1-1)-Query(idx2);
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：zhangjiacheng (赞：3)

## P党福利啦！！
### 主要思路：把两串数对着连起来就可以了，像样例（5 4 1 2 7 3)，然后树状数组就可以了。注意快排会超时，而且sum还要开int64，害得我用pascal，c++都编了一遍。。。代码如下：
```pascal
var i,j,k,l,n,m,g,h,n1,n2,tot,tt,o:longint;sum:int64;
a,b,c:array[0..1000000]of longint;
procedure put(x,y:longint);
var ii,jj:longint;
begin
tt:=tt+1;
a[tt]:=x;
b[tt]:=y;
ii:=tt;
while ii>1 do
begin
if a[ii]>a[ii div 2] then
begin
jj:=a[ii];a[ii]:=a[ii div 2];a[ii div 2]:=jj;
jj:=b[ii];b[ii]:=b[ii div 2];b[ii div 2]:=jj;
end;
ii:=ii div 2;
end;
end;
function get:longint;
var ii,jj,kk:longint;
begin
get:=b[1];
a[1]:=a[tt];
b[1]:=b[tt];
tt:=tt-1;
ii:=1;
while 2*ii<=tt do
begin
if (a[2*ii]>a[2*ii+1])or(2*ii+1>tt) then
jj:=2*ii
else jj:=2*ii+1;
if a[jj]>a[ii] then
begin
kk:=a[jj];a[jj]:=a[ii];a[ii]:=kk;
kk:=b[jj];b[jj]:=b[ii];b[ii]:=kk;
ii:=jj;
end
else break;
end;
end;
procedure fa(l,r:longint);
var i,j,k,mid:longint;
begin
i:=l;j:=r;mid:=a[(l+r)div 2];
repeat
while a[i]>mid do i:=i+1;
while a[j]<mid do j:=j-1;
if i<=j then
begin
k:=a[i];a[i]:=a[j];a[j]:=k;
k:=b[i];b[i]:=b[j];b[j]:=k;
i:=i+1;j:=j-1;
end;
until i>j;
if i<r then fa(i,r);
if j>l then fa(l,j);
end;
function fe(x:longint):longint;
var ii:longint;
begin
fe:=0;
ii:=x;
while ii>0 do
begin
fe:=fe+c[ii];
ii:=ii-(ii and -ii);
end;
end;
procedure fq(x:longint);
var ii:longint;
begin
ii:=x;
while ii<=n do
begin
c[ii]:=c[ii]-1;
ii:=ii+(ii and -ii);
end;
end;
begin
readln(n1,n2);
for i:=1 to n1 do
begin
readln(g);
h:=n1-i+1;
put(g,h);
end;
for i:=n1+1 to n1+n2 do
begin
readln(g);
h:=i;
put(g,h);
end;
n:=n1+n2;
for i:=1 to n do
c[i]:=i and -i;
tot:=n1;
for i:=1 to n do
begin
o:=get;
sum:=sum+abs(fe(tot)-fe(o));
if o>tot then
sum:=sum-1;
fq(o);
tot:=o;
end;
writeln(sum);
end.

```

---

## 作者：1saunoya (赞：2)

>$1<=N1+N2<=100000$

>显然$N^2$的模拟过不去。

>所以去想$O(N\ log\ N)$的算法。~~（不清楚$O(N)$的瞎搞能不能AC）~~

>至于 $O(N \ log \ N)$ 的数据结构 我们不难想到 ST表 线段树 以及是树状数组

>那么因为线段树太难打了。（大雾

>选择树状数组。

>代码在这
>[$HERE$](https://www.cnblogs.com/qf-breeze/p/10698059.html)

---

## 作者：Godzilla (赞：1)

### $\mathtt{Description:}$

给定两列从上到下物品，分别长为 $n_0,n_1$，有 $2$ 种操作：

$1.$ 将某一列顶端的物品移动到另一列的顶端

$2.$ 如果某一列顶端的物品的优先级 $a_i$ 在当前物品中最高，可以直接删除，不算做操作。

保证优先级 $a_i$ 互不相同。

### $\mathtt{Solution:}$

由操作 $2$ 中的条件，可以知道是从大到小按优先级删除物品，那么按照优先级排序。

暴力做法：枚举删除第 $i$ 个物品，将其上面的物品移动到另一列。复杂度 $O(n^2)$ 。

考虑优化这个过程：

经过手玩样例，发现移动的一段一定为某一列的连续后缀，继而不需要暴力移动，可以用 `k[0/1]` 来记录第 $0/1$ 列前 `k[0/1]` 个元素放到了另一列上，其中至少有一个必定为 $0$ 。

那么每次删除的过程，就是查询几列的后缀区间有多少个元素，改变 `k[0/1]` 。

支持 $O(\log n)$ 删除，加入，区间查询的数据结构，可以是树状数组。

对于两个区间分别维护树状数组即可。

### $\mathtt{Code:}$

```c++
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <map>
#include <vector>

#define LL long long
#define Ls(p) (p<<1)
#define Rs(p) ((p<<1)|1)

using namespace std;

const int kN=1e5+5;

struct Node{
	int w,x,y;
	bool operator <(const Node &k)const{
		return w>k.w;
	}
}d[kN];

int n[2],a[kN][2],K[2],cnt,c[kN][2];
LL ans;

int Lowbit(int x){
	return x&(-x);
}

void Add(int x,int k,int p){
	for(;x<=n[p];x+=Lowbit(x)){
		c[x][p]+=k;
	}
}

LL Ask(int x,int p){
	LL res=0;
	for(;x;x-=Lowbit(x)){
		res+=c[x][p];
	}
	return res;
}

signed main(){
	scanf("%d%d",&n[0],&n[1]);
	for(int i=n[0];i;--i){
		scanf("%d",&a[i][0]);
		d[++cnt]=(Node){a[i][0],0,i};
		Add(i,1,0);
	}
	for(int i=n[1];i;--i){
		scanf("%d",&a[i][1]);
		d[++cnt]=(Node){a[i][1],1,i};
		Add(i,1,1);
	}
	sort(d+1,d+1+cnt);
	for(int i=1;i<=n[0]+n[1];++i){
		int p=d[i].x,num=d[i].y;
		if(num>n[p]-K[p]){
			ans+=Ask(num-1,p)-Ask(n[p]-K[p],p);
			K[p]=n[p]-num+1;K[p^1]=0;
		}
		else{
			int t=p^1;
			ans+=Ask(n[t],t)-Ask(n[t]-K[t],t)+Ask(n[p]-K[p],p)-Ask(num,p);
			K[p]=n[p]-num;K[t]=0;
		}
		Add(num,-1,p);
	}
	printf("%lld\n",ans);
	return 0;
}
```



---

## 作者：封禁用户 (赞：0)

这里提供一种更为好理解的思路。我们来分析一下这个暴力模拟的过程：从两个栈中分别找到最大值，然后看哪边更大，然后就一直弹那边的栈并不断地入到另一个栈里，直到弹出最大值（不入另一边的栈）为止。我们再把它挖掘一下，就是在一个序列上，找到一个点，保留点左边的序列，删除这个点，把这个点右边的部分进行翻转（因为有出栈入栈过程相当于倒过来了）然后加到另一个序列尾部。对，这是可分裂合并翻转的序列，典型的Splay。我们以序列下标为关键值建立Splay，维护区间内最大值与最大值的位置，然后分裂合并翻转就Splay一下打上标记就行了。

上代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define ll long long
using namespace std; 
inline int get(){
	int n;char c;while((c=getchar())||23333)if(c>='0'&&c<='9')break;
	n=c-'0';while((c=getchar())||23333){
		if(c>='0'&&c<='9')n=n*10+c-'0';else return(n);
	}
}
typedef struct _n{
	int ch[2];int data;int size;int maxn;unsigned char bj;int pos;
}node;node memchi[1000001];int gn=1;
inline void up(int tree){
	int ls=memchi[tree].ch[0],rs=memchi[tree].ch[1];memchi[tree].maxn=max(memchi[tree].data,max(memchi[ls].maxn,memchi[rs].maxn));
	if(memchi[tree].maxn==memchi[tree].data)memchi[tree].pos=memchi[ls].size+1;
	if(memchi[tree].maxn==memchi[ls].maxn)memchi[tree].pos=memchi[ls].pos;
	if(memchi[tree].maxn==memchi[rs].maxn)memchi[tree].pos=memchi[rs].pos+memchi[ls].size+1;
	memchi[tree].size=memchi[ls].size+memchi[rs].size+1;
}
inline void down(int tree){if(!memchi[tree].bj)return;memchi[tree].bj=0;
	int ls=memchi[tree].ch[0],rs=memchi[tree].ch[1];memchi[ls].bj^=1;memchi[rs].bj^=1;
	swap(memchi[ls].ch[0],memchi[ls].ch[1]);swap(memchi[rs].ch[0],memchi[rs].ch[1]);
	memchi[ls].pos=memchi[ls].size-memchi[ls].pos+1;memchi[rs].pos=memchi[rs].size-memchi[rs].pos+1;
}
inline void xuan(int &tree,int ch){
	down(tree);int me=memchi[tree].ch[ch];down(me);int ls=memchi[me].ch[ch^1];
	memchi[tree].ch[ch]=ls;memchi[me].ch[ch^1]=tree;up(tree);up(me);tree=me;
}
void splay(int &tree,int data){if(!tree)return;down(tree);
	int ls=memchi[tree].ch[0];if(data==memchi[ls].size+1)return;
	int op=data>(memchi[ls].size);if(op)data-=(memchi[ls].size+1);int me=memchi[tree].ch[op];down(me);int lls=memchi[me].ch[0];if(data!=memchi[lls].size+1){
		int opp=data>(memchi[lls].size);if(opp)data-=(memchi[lls].size+1);splay(memchi[me].ch[opp],data);
		if(op==opp){
			xuan(tree,op);xuan(tree,opp);return;
		}
		up(me);
		xuan(memchi[tree].ch[op],opp);up(tree);
	}xuan(tree,op);
}
int ints1[100001],ints2[100001];
int main(){memchi[0].data=memchi[0].maxn=-1234567890;memchi[0].size=0;
	int n1=get(),n2=get();int root1=0,root2=0,cnt1=0,cnt2=0;
	for(register int i=1;i<=n1;i++)ints1[i]=get();for(register int i=1;i<=n2;i++)ints2[i]=get();
	for(register int i=n1;i>=1;i--){
		int a=ints1[i];int tree=gn;gn++;memchi[tree].size=1;memchi[tree].data=a;memchi[tree].maxn=a;
		memchi[tree].pos=1;if(!root1)root1=tree;
		else{
			memchi[root1].ch[1]=tree;up(root1);
		}cnt1++;splay(root1,cnt1);
	}for(register int i=n2;i>=1;i--){
		int a=ints2[i];int tree=gn;gn++;memchi[tree].size=1;memchi[tree].data=a;memchi[tree].maxn=a;
		memchi[tree].pos=1;if(!root2)root2=tree;
		else{
			memchi[root2].ch[1]=tree;up(root2);
		}cnt2++;splay(root2,cnt2);
	}int n=n1+n2;ll ans=0;while(n){
		n--;
		if(memchi[root1].maxn>memchi[root2].maxn){
			splay(root1,memchi[root1].pos);cnt1--;splay(root2,cnt2);
			int tre=memchi[root1].ch[1];root1=memchi[root1].ch[0];swap(memchi[tre].ch[0],memchi[tre].ch[1]);memchi[tre].bj^=1;
			memchi[tre].pos=memchi[tre].size-memchi[tre].pos+1;
			cnt1-=memchi[tre].size;cnt2+=memchi[tre].size;ans+=memchi[tre].size;
			if(!root2){
				root2=tre;
			}else{
				memchi[root2].ch[1]=tre;up(root2);splay(root2,cnt2);
			}
		}else{
			splay(root2,memchi[root2].pos);cnt2--;splay(root1,cnt1);
			int tre=memchi[root2].ch[1];root2=memchi[root2].ch[0];swap(memchi[tre].ch[0],memchi[tre].ch[1]);memchi[tre].bj^=1;
			memchi[tre].pos=memchi[tre].size-memchi[tre].pos+1;
			cnt2-=memchi[tre].size;cnt1+=memchi[tre].size;ans+=memchi[tre].size;
			if(!root1){
				root1=tre;
			}else{
				memchi[root1].ch[1]=tre;up(root1);splay(root1,cnt1);
			}
		}
		哈哈哈您别想抄我代码 
	}cout<<ans<<endl;
	return(0);
}
```

---

## 作者：依依 (赞：0)

解：每次必定是找到最大的然后移除。

把两个堆怼到一起，就可以看成一个数列，每次操作就可以看成是分割点的移动。

暴力模拟n^2会T，现在要解决的问题是如何快速求出分割点之间的元素个数。

做法：

将元素按照优先级从大到小排序，用树状数组维护每两个位置之间有多少元素，

加给答案。

注意开long long。  
[绝不是为了刷访问量](http://www.cnblogs.com/adelalove/p/8520737.html)

---


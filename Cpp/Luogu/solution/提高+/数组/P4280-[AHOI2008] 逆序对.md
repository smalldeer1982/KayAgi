# [AHOI2008] 逆序对

## 题目描述

暑假到了，小可可和伙伴们来到海边度假，距离海滩不远的地方有个小岛，叫做欢乐岛，整个岛是一个大游乐园，里面有很多很好玩的益智游戏。碰巧岛上正在举行“解谜题赢取免费门票”的活动，只要猜出来迷题，那么小可可和他的朋友就能在欢乐岛上免费游玩两天。

迷题是这样的：给出一串全部是正整数的数字，这些正整数都在一个范围内选取，谁能最快求出这串数字中“逆序对”的个数，那么大奖就是他的啦！

当然、主办方不可能就这么简单的让迷题被解开，数字串都是被处理过的，一部分数字被故意隐藏起来，这些数字均用-1来代替，想要获得大奖就必须求出被处理的数字串中最少能有多少个逆序对。小可可很想获得免费游玩游乐园的机会，你能帮助他吗？

注：“逆序对”就是如果有两个数A和B，A在B左边且A大于B，我们就称这两个数为一个“逆序对”，例如：4 2 1 3 3里面包含了5个逆序对：(4, 2)、(4, 1)、(4, 3)、(4, 3)、(2, 1)。

    假设这串数字由5个正整数组成，其中任一数字N均在1～4之间，数字串中一部分数字被“-1”替代后，如：4 2 -1 -1 3 ，那么这串数字，可能是4 2 1 3 3，也可能是4 2 4 4 3，也可能是别的样子。你要做的就是根据已知的数字，推断出这串数字里最少能有多少个逆序对。

## 说明/提示

100%的数据中，N<=10000，K<=100。

60%的数据中，N<=100。

40%的数据中，-1出现不超过两次。

## 样例 #1

### 输入

```
5 4
4 2 -1 -1 3```

### 输出

```
4```

# 题解

## 作者：Adove (赞：28)

这题我们维护一个大于等于某值的前缀和和一个小于等于某值的后缀和

从左往右扫，对每个位置保证最少贡献的情况下取最小的那个

时间复杂度$\Theta(NK)$

说实话这题紫题难度有点偏高，差不多是提高组级别难度

```cpp
#include"cstdio"
#include"cstring"
#include"iostream"
#include"algorithm"
using namespace std;

const int MAXN=1e5+5;
const int MAXM=105;

int n,m;
int a[MAXN];
int lis[2][MAXM];
long long ans;

int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i){scanf("%d",&a[i]);if(a[i]!=-1) ++lis[1][a[i]];}
	for(int i=1;i<=m;++i) lis[1][i]+=lis[1][i-1];
	for(int i=1;i<=n;++i){
		if(a[i]==-1){
			int c=0,d=0,ct=0,mx=0x7fffffff;
			for(int j=1;j<=m;++j){
				if(lis[0][j+1]+lis[1][j-1]<mx) mx=lis[0][j+1]+lis[1][j-1],ct=j;
			}a[i]=ct;
		}else for(int j=a[i];j<=m;++j) --lis[1][j];
		ans+=lis[0][a[i]+1];
		for(int j=1;j<=a[i];++j) ++lis[0][j];
	}printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：asuldb (赞：15)

被锤爆了

被这个题搞得自闭了一上午，觉得自己没什么前途了

我又没有看出来这个题的一个非常重要的性质

**我们填进去的数一定是单调不降的**

首先如果填进去的数并不是单调不降的，那么填进去本身就会产生一些逆序对，感性理解好像是单调不降更优，这里还是严谨证明一下吧

考虑一下树状数组求逆序对的过程，显然就是求出每一个数前面有多少个比它大的数

![图](https://cdn.luogu.com.cn/upload/pic/42570.png)

这张图好丑啊

设$A<B$，$x$表示那段绿色区间里大于$A$的数，$y$表示绿色区间里大于$B$的数，$a$表示蓝色区间里大于$A$的数，$b$表示蓝色区间里大于$B$的数

这个时候我们如果用树状数组来统计一下答案的话，$A,B$的贡献就是$x+y+b$

如果交换一下$A$和$B$的位置，那么这个时候答案就会变成$x+a+y+1$

非常显然的是$b<=a$，所以可以得出$x+y+b<x+a+y+1$，所以不交换更优

之后有了这个性质，我们就可以做一个$dp$了，设$dp[i][j]$表示填到了$i$位置，最靠后的一个$-1$位置填了$j$这个时候的最小逆序对是多少

就可以一边树状数组一边$dp$了

复杂度$O(nklogk)$

代码

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#define LL long long
#define lowbit(x) ((x)&(-x))
#define re register
#define maxn 100005
#define min(a,b) ((a)<(b)?(a):(b))
inline int read()
{
	char c=getchar();
	int x=0,r=1;
	while(c<'0'||c>'9') 
	{
		if(c=='-') r=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')
		x=(x<<3)+(x<<1)+c-48,c=getchar();
	return x*r;
}
LL c[105];
int n,m;
LL ans;
LL dp[maxn][101];
LL mx[101];
int pre[maxn];
int a[maxn];
int beh[maxn][101];
inline void add(int x)
{
	for(re int i=x;i<=m;i+=lowbit(i)) c[i]++;
}
inline LL ask(int x)
{
	LL now=0;
	for(re int i=x;i;i-=lowbit(i)) now+=c[i];
	return now;
}
int main()
{
	int cnt=0;
	n=read(),m=read();
	for(re int i=1;i<=n;i++) 
	{
		a[i]=read();
		if(a[i]==-1&&!cnt) cnt=i;
		pre[i]=pre[i-1]+(a[i]==-1);
	}
	if(!cnt) cnt=n+1;
	for(re int i=1;i<cnt;i++)
	{
		ans+=ask(m)-ask(a[i]);
		add(a[i]);
	}
	if(cnt==n+1)
	{
		std::cout<<ans;
		return 0;
	}
	for(re int i=n;i;i--)
	{
		for(re int j=1;j<=m;j++)
			beh[i][j]=beh[i+1][j];
		if(a[i]==-1) continue;
		for(re int j=a[i];j<=m;j++) beh[i][j]++;
	}
	memset(dp,20,sizeof(dp));
	for(re int i=1;i<=m;i++)
		dp[cnt][i]=ans+ask(m)-ask(i)+beh[cnt][i-1];
	memset(mx,20,sizeof(mx));
	for(re int j=1;j<=m;j++)
		mx[j]=min(mx[j-1],dp[cnt][j]);
	for(re int i=cnt+1;i<=n;i++)
	{
		if(a[i]!=-1)
		{
			LL now=ask(m)-ask(a[i]);
			for(re int j=1;j<=m;j++)
				dp[i][j]=now+dp[i-1][j];
			add(a[i]);
		}
		else
		{
			for(re int j=1;j<=m;j++)
			{
				LL now=ask(m)-ask(j);
				dp[i][j]=mx[j]+now+beh[i][j-1];
			}
		}
		memset(mx,20,sizeof(mx));
		for(re int j=1;j<=m;j++)
			mx[j]=min(mx[j-1],dp[i][j]);
	}
	LL Ans=0x7ffffffff;
	for(re int i=1;i<=m;i++)
		Ans=min(Ans,dp[n][i]);
	std::cout<<Ans;
	return 0;
}	
```

---

## 作者：木xx木大 (赞：7)

[P4280 [AHOI2008]逆序对](https://www.luogu.com.cn/problem/P4280)

分析：若有 $a_i>a_j$，$i<j$ ，那么我们交换 $a_i,a_j$ 一定更优。因为交换后 $[1,j-1]$ 和 $[i+1,n]$ 的对 $a_i,a_j$ 的贡献不变，$(i,j)$ 的贡献不降（因为区间中**小于 $a_i$ 的数**一定大于等于**小于$a_j$ 的数**），但少了 $a_i,a_j$ 这一对逆序对。而如果 $x>y>z$，$j>i$ ，如果 $a_i=x$,$a_j=y$ 比 $a_i=z$,$a_j=y$ 优，那么基于上面的结论， $a_i=y$,$a_j=x$ 也一定会比  $a_i=z$,$a_j=y$ 和$a_i=x$,$a_j=y$ 都优，所以即使 $a_i=x$,$a_j=y$ 局部更优，但在考虑全局最优时是不会考虑到它的。dp是有容错性的，因此在dp时，我们可以认为：**从左往右，每一个未知位置填的数单调不降一定是最优的**。

那么前面未知的数就不会对后面未知的数产生贡献，接下来的dp方程就很简单了：设 $dp_{i,j}$ 表示从右往左考虑到第 $i$ 个未知数，这个数填 $j$ 的最小逆序对数。$dp_{i,j}=min(dp_{i-1,k})+$当前填 $j$ 产生的逆序对数，其中 $k\geq j$。前缀min优化一下即可 $O(k)$ 转移，总复杂度 $O(nk\log k)$ 

```cpp
#include<bits/stdc++.h>
#define ll long long
#define inl inline
using namespace std;
namespace FGF
{
	int n,m;
	const ll INF=0x3f3f3f3f3f3f3f3f;
	ll dp[10005][105],ans,sum,mi[10005][105];
	int c[2][105],a[10005],cnt; 
	void add(int x,int op,int val)
	{
		while(x<=m)c[op][x]+=val,x+=x&(-x);
	}
	int query(int x,int op)
	{
		int s=0;
		while(x)s+=c[op][x],x-=x&(-x);
		return s;
	}
	void work()
	{
		scanf("%d%d",&n,&m);
		for(int i=1;i<=n;i++)
		{
			scanf("%d",&a[i]);
			if(a[i]>0)add(a[i],0,1); 
		}
		for(int i=n;i;i--)
		{
			if(a[i]>0)
			{
				sum+=query(a[i]-1,1);
				add(a[i],1,1),add(a[i],0,-1);
			}
			else
			{
				cnt++;
				memset(dp[cnt],0x3f,sizeof(dp[cnt]));
				for(int j=1;j<=m;j++)
					dp[cnt][j]=mi[cnt-1][j]+query(j-1,1)+query(m,0)-query(j,0);
				mi[cnt][m+1]=INF;
				for(int j=m;j;j--)
					mi[cnt][j]=min(mi[cnt][j+1],dp[cnt][j]);
			}
		}
		ll x=INF;
		for(int i=1;i<=m;i++)
			x=min(x,dp[cnt][i]);
		printf("%lld",x+sum);
	}
}
int main()
{
	FGF::work();
	return 0;
}
```

---

## 作者：niiick (赞：5)

首先可以想到从左往右每个-1位置填写的数字一定**单调不下降**

若有$a_j>a_i,j<i$，交换$a_i,a_j$，逆序对数不可能增加，
因为交换后$a_i,a_j$对区间$(i,n]$逆序对贡献不变，但减少了$a_j,a_i$这一逆序对，
且因为交换后$a_j$变小，原来$a_j$对区间$(j,i)$的逆序对贡献可能消失

$dp[i][j]$表示从右往左第$i$个-1位置填$j$增加的最小逆序对数，$dp[i][j]=min(dp[i-1][k])+$第$i$个-1位置填$j$增加的逆序对数，其中$k\geq j$

开一个数组$mi[i][j]$保存$dp[i][j]$~$dp[i][k]$的最小值就可以$O(K)$转移了

总复杂度$O(nklogk)$，这里log是树状数组的复杂度

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<queue>
#include<algorithm>
#include<cstring>
using namespace std;
typedef long long lt;
#define lowbit(x) ((x)&(-x))
 
int read()
{
    int f=1,x=0;
    char ss=getchar();
    while(ss<'0'||ss>'9'){if(ss=='-')f=-1;ss=getchar();}
    while(ss>='0'&&ss<='9'){x=x*10+ss-'0';ss=getchar();}
    return f*x;
}
 
const int inf=1e9;
const int maxn=10010;
int n,K;
int a[maxn],sum[2][maxn],tot;
int rem[maxn];
lt dp[maxn][110],mi[maxn][110];
 
void add(int x,int v,int d){ for(int i=x;i<=K;i+=lowbit(i))sum[d][i]+=v;}
int qsum(int x,int d){ int res=0; for(int i=x;i>0;i-=lowbit(i))res+=sum[d][i]; return res;}
 
int main()
{
    n=read();K=read();
    for(int i=1;i<=n;++i)
    {
        a[i]=read();
        if(a[i]!=-1) add(a[i],1,0);
        else tot++;
    }
     
    lt ans=0; int cnt=0;
    for(int i=n;i>=1;--i)
    {
        if(a[i]!=-1){
            ans+=qsum(a[i]-1,1);
            add(a[i],1,1); add(a[i],-1,0);
        }
        else{
            ++cnt;
            for(int j=1;j<=K;++j) dp[cnt][j]=inf;
             
            int tt=qsum(K,0);
            for(int j=1;j<=K;++j) 
            rem[j]=tt-qsum(j,0)+qsum(j-1,1);
            //qsum(j-1,1)求(i,n]内小于j的个数，qsum(K,0)-qsum(j,0)求[1,i)内大于j的个数
             
            for(int j=1;j<=K;++j)
            dp[cnt][j]=rem[j]+mi[cnt-1][j];
             
            mi[cnt][K+1]=inf;
            for(int j=K;j>=1;--j)
            mi[cnt][j]=min(mi[cnt][j+1],dp[cnt][j]);
        }
    }
     
    lt tt=inf;
    for(int i=1;i<=K;++i) tt=min(tt,dp[tot][i]);
    printf("%lld",ans+tt);
    return 0;
}
﻿
```


---

## 作者：Tx_Lcy (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P4280)
## 思路
猜了个结论，然后过了？

感觉这道省选题非常的奇妙，好像大部分题解都是写的 $\verb!DP!$。大体思路是维护两颗树状数组，一正一反，每次先 $O(n)$ 枚举位置，如果这个位置不是 $-1$，显然我们不能动它，那么跳过。

如果这个位置是 $-1$，那么我们再 $O(k)$ 枚举这个位置的取值，每次找到这个位置填 $j$ 的贡献，找出贡献最小的数，填上即可。

然后最后再根据填完的 $a$ 数组跑一遍逆序对，这道省选题就做完了。

## 证明

思考一下为什么这样是正确的，考虑存在一段连续的 $-1$，一个显然的结论，如果我们当前填的数大于等于上一个 $-1$ 填的数，对前面区间的贡献一定是与上一个相同的，唯一不同的是对后面区间的贡献，而对后面区间的贡献我们显然可以忽略 $-1$ 的存在，所以这样暴力比较大小是正确的。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int const N=1e4+10;
int const M=1e2+10;
int a[N],n,k;
struct Tree_Array{
    int c[M];
    #define lowbit(x) (x&-x)
    inline void clear(){memset(c,0,sizeof(c));}
    inline void update(int x,int v){while (x<=k) c[x]+=v,x+=lowbit(x);}
    inline int query(int x){int res=0;while (x) res+=c[x],x-=lowbit(x);return res;}
}T[2];
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    cin>>n>>k;
    for (int i=1;i<=n;++i) cin>>a[i];
    for (int i=1;i<=n;++i) if (a[i]!=-1) T[1].update(a[i],1);
    for (int i=1;i<=n;++i){
        if (a[i]==-1){
            int now=1e9,to;
            for (int j=1;j<=k;++j){
                int sum=(i-1-T[0].query(j))+T[1].query(j-1);
                if (now>sum) now=sum,to=j;
            }
            a[i]=to;
        }else T[1].update(a[i],-1);
        T[0].update(a[i],1);
    }
    T[0].clear();
    int ans=0;
    for (int i=1;i<=n;++i){
        ans+=(i-1-T[0].query(a[i]));
        T[0].update(a[i],1);
    }
    cout<<ans<<'\n';
    return 0;
}
```

---

## 作者：WisNourx_ (赞：3)

~~蒟蒻第一次写题解，写的不好请见谅 QAQ~~

## 题目大意&思路
其实这道题是 [P1908](https://www.luogu.com.cn/problem/P1908) 的升级版，在填数的同时求逆序对。  

那么经过一番思考，很容易就能得出：填的数一定是单调不降的。  

如果我们填的数符合 $a_i > a_j$，那么就会让已有的逆序对数目增加。  
而把 $a_i > a_j$ 改成 $a_i < a_j$，发现交换两数后， 对于 $a_i$ 前面的 $i-1$ 个数， 交换 $a_i$ 和 $a_j$ 不会对原有的逆序对造成影响；  
而由 $a_i$ 和 $a_j$ 产生的逆序对会因为这一次操作而被消除，所以显然，填的数应该大于前面一个数字。  


那么,对于求逆序对, 很自然的想到用树状数组求出原先数列的逆序对。     
同时，我们对每个填 $-1$ 的位（假设是第 $i$ 位）进行枚举， 把 $1\sim k$ 依次填进 
$-1$ 中，看看它对答案产生的贡献，即填数之后对原序列产生的逆序对
个数（此部分可用树状数组求解），   

最后用 dp 维护， 求出最小值。 


## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int p[120000],c[120000],c2[120000],a[110000],dp[11000][210],dp2[11000][210];
int k, cnt;

int lowbit(int x){return x&(-x);}
void add(int x)
{
    while(x<=k)
	{
        c[x]++;
        x+=lowbit(x);
    }
}
void add2(int x)
{
    while(x<=k)
	{
        c2[x]++;
        x+=lowbit(x);
    }
}
int getsum(int x)
{
    int sum=0;
    while(x>0)
	{
        sum+=c[x];
        x-=lowbit(x);
    }
    return sum;
}
int getsum2(int x)
{
    int sum=0;
    while(x>0)
	{
        sum+=c2[x];
        x-=lowbit(x);
    }
    return sum;
}
int main()
{
    int n;scanf("%d%d",&n, &k);
    for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		if(a[i]>0) add(a[i]);
		else p[i]=++cnt,dp[cnt][0]=10000000009;//确保在-1的时候进行dp 
	}
	long long ans=0;
    for (int i=1;i<=n;i++)
    {
    	if(a[i]>0)
    	{
    		ans+=getsum2(k)-getsum2(a[i]);//算逆序对 
    		add2(a[i]);
		}	
		else
		{
			for (int j=1;j<=k;j++)
			{
				dp[p[i]][j]=min(dp[p[i]][j-1],dp[p[i]-1][j]+getsum2(k)-getsum2(j)+getsum(j-1)-getsum2(j-1));
			}
		}
	}
   	ans+=dp[cnt][k];
   	printf("%lld",ans);
    return 0;
}
```
#### ~~原谅蒟蒻看了一下午才写出来~~


---

## 作者：chaojidouding (赞：3)

首先可以发现这么个性质：-1的位置填的数是递增的

证明：考虑填的两个数是递减的，那么会在本身多出一对逆序对，而且我们可以发现交换这两个数对于每一个位置，逆序对并不会多。

所以我们可以想到一个dp

在每个-1的地方dp

用dp[i][j]表示在第i个-1处填j逆序对最小值

则dp[i][j]=dp[i-1][k]+在这个位置填入j能产生的逆序对数（后边这块可以树状数组求）。

这个东西可以前缀和优化

然后加上原序列的逆序对数就是ans了

附上代码

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
int tree[101010],tree2[101010],a[101010],pl[101010],f[10101][110],g[10101][110];
int k;
int lowbit(int x)
{
	return x&-x;
}
void modify(int x)
{
	for(int i=x;i<=k;i+=lowbit(i))
		tree[i]++;
}
void modify2(int x)
{
	for(int i=x;i<=k;i+=lowbit(i))
		tree2[i]++;
}
int query(int x)
{
	int ans=0;
	for(int i=x;i>0;i-=lowbit(i))
		ans+=tree[i];
	return ans;
}
int query2(int x)
{
	int ans=0;
	for(int i=x;i>0;i-=lowbit(i))
		ans+=tree2[i];
	return ans;
}
int main()
{
	int i,n,ans=0,cnt=0,j;
	scanf("%d%d",&n,&k);
	for(i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		if(a[i]>0)
			modify(a[i]);
		else
		{
			pl[i]=++cnt;
			g[cnt][0]=1000000007;
		}
	}
	for(i=1;i<=n;i++)
	{
		if(a[i]>0)
		{
			ans+=query2(k)-query2(a[i]);
			modify2(a[i]);
		}
		else
		{
			for(j=1;j<=k;j++)
			{
				f[pl[i]][j]=g[pl[i]-1][j]+query2(k)-query2(j)+query(j-1)-query2(j-1);
				g[pl[i]][j]=min(g[pl[i]][j-1],f[pl[i]][j]);
			}
		}
	}
	ans+=g[cnt][k];
	printf("%d\n",ans);
	return 0;
}

```

---

## 作者：nomonick (赞：2)



# P4280 [AHOI2008]逆序对

这题整体题面比较好理解，下面直接算法分析

## 简单分析

假设原有数列为 $a$ ，且满足存在 $ i $, $j$ （$i < j$） 使得 $a_i = a_j = -1$ 

继续假设填入数字后的到新的数列 $b$ ，满足 $b_i \leq b_j$

同时我们在定义函数 $f(seq[],x)$ ，保证 $x$ 在数列中的相对位置在区间 $seq$ 之后，用来计算 $x$ 与区间 $seq$ 所产生的的逆序对总和

此时数列，就如下图所示：

![](https://pic.imgdb.cn/item/617a7f172ab3f51d91fcafea.png)

设该情况 $b_i$ , $b_j$ 产生逆序对设总和为 $res$

又因为 $b_i < b_j$ ， 所以这两个之间不会产生逆序对
$$
\therefore res = f(seq1,b_i) + f(seq1,b_j) + f(seq2,b_j)
$$
若我们此时将 $b_i$ 与 $b_j$ 的位置调换

那么产生逆序对的变为 $b_i$ 与 $seq1,b_j,seq2$ ， $b_j$ 与 $seq1$ 

假设这种情况下的逆序对个数为 $tmp$

$$
\therefore tmp = f(seq1,b_i) + f(seq2,b_i) + f(seq1,b_j) + 1
$$

$$
\therefore res - tmp = f(seq2,b_j)-f(seq2,b_i) + 1
$$

因为  $b_i \leq b_j$ ，所以很明显对于同一个区间 $b_i$ 所产生的逆序对一定大于等于 $b_j$ 所产生的逆序对。
$$
\therefore f(seq1,b_j) \geq f(seq2,b_i)
$$

$$
\therefore res - tmp > 0
$$

综上我们可以的得知在原数列上值为 $-1$ 的点上所填入的值应该保证其单调不降，在能做到最优。

## 具体实现

由于通入数字对原数列中有数值的位置之间所产生的的逆序对的个数是不产生影响的。所以可以直接求出来。

同时，我们可以用动态规划来实现在 $-1$ 的点上的答案统计

设置如下的状态 ```dp[i][j]``` 表示在第 $i$ 个值为 $-1$ 的位置填入至少大小为 $j$ 的数组后的最小逆序对个数

这是只需要动态维护两个树状数组来求逆序对，一个用来存储在这个数的左侧的数字，记为 $l$ ；一个用来存储在这个数的右侧的数字，记为 $r$

可以很轻松的推出转移方程如下：
```
dp[i][j] = min(dp[i][j-1],dp[i-1][j] + queryl(k) - queryl(j) + queryr(j-1));
```


## code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define lowbit(x) (x&(-x))
const int SIZE = (int)1e4 + 50;
const int NUM = (int)1e2 + 10;
inline int read()
{
	int x = 0,f = 1ll;
	char ch = getchar();
	while (ch < '0' || ch > '9')
	{
		if (ch == '-') f = -1ll;
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9')
	{
		x = (x << 1ll) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
	return f * x;
}
int n,k,cnt,ans;
int num[SIZE],l[SIZE],r[SIZE],pos[SIZE];
int dp[SIZE][NUM];
inline void modiyf_l_add(int x)
{
	for (int i = x; i <= k; i += lowbit(i)) l[i]++;
}
inline void modiyf_r_add(int x)
{
	for (int i = x; i <= k; i += lowbit(i)) r[i]++;
}
inline void modiyf_r_less(int x)
{
	for (int i = x; i <= k; i += lowbit(i)) r[i]--;
}
inline int query_l(int x)
{
	int res = 0;
	for (int i = x; i; i -= lowbit(i)) res += l[i];
	return res;
}
inline int query_r(int x)
{
	int res = 0;
	for (int i = x; i; i -= lowbit(i)) res += r[i];
	return res;
}
signed main()
{
	n = read();k = read();
	for (int i = 1; i <= n; ++i)
	{
		num[i] = read();
		if (num[i] > 0) modiyf_r_add(num[i]);
		else pos[i] = ++cnt,dp[cnt][0] = inf;
	}
	for (int i = 1; i <= n; ++i)
	{
		if (num[i] > 0)
		{
			ans += query_l(k) - query_l(num[i]);
			modiyf_l_add(num[i]); modiyf_r_less(num[i]);
			continue;
		}
		for (int j = 1; j <= k; ++j)
			dp[pos[i]][j] = min(dp[pos[i]][j-1],dp[pos[i]-1][j] + query_l(k) - query_l(j) + query_r(j-1));
	}
	ans += dp[cnt][k];
	printf("%lld\n",ans);
	return 0;
}

```



---

## 作者：_sry (赞：2)


我们可以很容易的推断出$-1$是单调不降的，若$i>j$且$a_i$与$a_j$都没有填数，若填完之后$a_i>a_j$或者$a_i<a_j$，则对答案产生影响的只在$[i,j]$之间，则$a_i<a_j$对答案产生的贡献更小，则其实每个不同位置的$-1$其实是互不影响的，所以就可以用$dp$实现

设$dp(i,j)$表示这是从右往左数第$i$个$-1$，这里填j的最小逆序对数(这里的逆序对是只与$-1$有关的，其他的单算)

则$dp(i,j)=min(dp(i-1,p)+在第i个-1左面不是-1的对此数新产生的逆序对数+此数填后对右面产生的贡献) (j \leq p)$

我们可以用线段树维护逆序对，时间复杂度:$O(n\times k^2)$
```
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
inline int read(){
    int f=1,ans=0;char c;
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){ans=ans*10+c-'0';c=getchar();}
    return f*ans;
}
int n,k,a[10001],cnt[10001],ans[40014];
void add(int k,int l,int r,int x,int y){
    if(x>y) return ;
    if(x<=l&&r<=y){ans[k]++;return;}
    int mid=l+r>>1;
    if(x<=mid) add(k<<1,l,mid,x,y);
    if(mid<y) add(k<<1|1,mid+1,r,x,y);
    ans[k]=ans[k<<1]+ans[k<<1|1];
    return;
}
int query(int k,int l,int r,int x,int y){
    if(x>y) return 0;
    if(x<=l&&r<=y) return ans[k];
    int mid=l+r>>1,res=0;
    if(x<=mid) res+=query(k<<1,l,mid,x,y);
    if(mid<y) res+=query(k<<1|1,mid+1,r,x,y);
    return res;
}
int cost[10001][101],sum,dp[10001][101],tot,minn,inf=2<<30-1;
int main(){
    minn=inf;
    memset(dp,127/3,sizeof(dp));
    n=read(),k=read();
    for(int i=1;i<=n;i++){
        a[i]=read();
        if(a[i]==-1)
            cnt[++cnt[0]]=i;
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=k;j++){
            cost[i][j]=cost[i-1][j];
            if(j<=a[i]) cost[i][j]++;
        }
    }
    for(int i=1;i<=k;i++) dp[0][i]=0;
    for(int i=n;i>=1;i--){
        if(a[i]!=-1){
            sum+=query(1,1,k,1,a[i]-1);
            add(1,1,k,a[i],a[i]);
        }else{
            tot++;
            for(int j=1;j<=k;j++){
                for(int p=j;p<=k;p++){
                    dp[tot][j]=min(dp[tot-1][p]+query(1,1,k,1,j-1)+cost[i][j+1],dp[tot][j]);
                    if(tot==cnt[0]) minn=min(minn,dp[tot][j]);
                }
            }
        }
    }
    if(minn==inf) cout<<sum;
    else cout<<sum+minn;
}
```

---

## 作者：千早爱音 (赞：1)

一个显然的性质是 $ -1 $ 位置填入的数字必须单调不降，否则交换两个数字的位置以后一定不会变得比原来更优，会产生更多的逆序对。

所以可以暴力转移，设 $ dp_{i,j} $ 表示在第 $ i $ 个位置填入 $ j $ 的最小值，则设 $ x $ 为在这个位置填入 $ j $ 能产生的逆序对数量，则 $ dp_{i,j}=dp_{i,j-1}+x $，暴力转移复杂度是错误的，考虑这实际上是一个单点修改，区间询问的数据结构，维护两个 LCT 分别动态求出逆序对即可，其中一个表示这个数字左边的逆序对个数，一个表示这个数字右边的逆序对个数。

时间复杂度是 $ \mathcal{O}(nk\log{k}) $ 的，可以通过。

实际运行时因为常数过大，再次喜提本题最劣解。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long//保险
const int maxn=1e4+10;
const int mod=1e9+7;
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
    while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
    return x*f;
}
int c[2000020],tag[2000020],n;
struct Splay
{
    int ch[maxn][2],fa[maxn],siz[maxn],val[maxn],sum[maxn],add[maxn],mul[maxn],rev[maxn];
    void clear(int x)
    {
        ch[x][0]=ch[x][1]=fa[x]=siz[x]=val[x]=sum[x]=add[x]=rev[x]=0;
        mul[x]=1;
    }
    int getch(int x)
    {
        return (ch[fa[x]][1]==x);
    }
    int isroot(int x)
    {
        clear(0);
        return ch[fa[x]][0]!=x&&ch[fa[x]][1]!=x;
    }
    void maintain(int x)
    {
        clear(0);
        siz[x]=(siz[ch[x][0]]+1+siz[ch[x][1]]);
        sum[x]=(sum[ch[x][0]]+val[x]+sum[ch[x][1]])%mod;
    }
    void pushdown(int x)
    {
        clear(0);
        if(mul[x]!=1)
        {
            if(ch[x][0])
            mul[ch[x][0]]=(mul[x]*mul[ch[x][0]])%mod,val[ch[x][0]]=(val[ch[x][0]]*mul[x])%mod,sum[ch[x][0]]=(sum[ch[x][0]]*mul[x])%mod,add[ch[x][0]]=(add[ch[x][0]]*mul[x])%mod;
            if(ch[x][1])
            mul[ch[x][1]]=(mul[x]*mul[ch[x][1]])%mod,val[ch[x][1]]=(val[ch[x][1]]*mul[x])%mod,sum[ch[x][1]]=(sum[ch[x][1]]*mul[x])%mod,add[ch[x][1]]=(add[ch[x][1]]*mul[x])%mod;
            mul[x]=1;
        }
        if(add[x])
        {
            if(ch[x][0])
            add[ch[x][0]]=(add[ch[x][0]]+add[x])%mod,val[ch[x][0]]=(val[ch[x][0]]+add[x])%mod,sum[ch[x][0]]=(sum[ch[x][0]]+add[x]*siz[ch[x][0]])%mod;
            if(ch[x][1])
            add[ch[x][1]]=(add[ch[x][1]]+add[x])%mod,val[ch[x][1]]=(val[ch[x][1]]+add[x])%mod,sum[ch[x][1]]=(sum[ch[x][1]]+add[x]*siz[ch[x][1]])%mod;
            add[x]=0;
        }
        if(rev[x])
        {
            if(ch[x][0])
            rev[ch[x][0]]^=1,swap(ch[ch[x][0]][0],ch[ch[x][0]][1]);
            if(ch[x][1])
            rev[ch[x][1]]^=1,swap(ch[ch[x][1]][0],ch[ch[x][1]][1]);
            rev[x]=0;
        }
    }
    void update(int x)
    {
        if(!isroot(x))
        update(fa[x]);
        pushdown(x);
    }
    void rotate(int x)
    {
        int y=fa[x],z=fa[y],chx=getch(x),chy=getch(y);
        fa[x]=z;
        if(!isroot(y))
        ch[z][chy]=x;
        ch[y][chx]=ch[x][chx^1];
        fa[ch[x][chx^1]]=y;
        ch[x][chx^1]=y;
        fa[y]=x;
        maintain(y);
        maintain(x);
        maintain(z);
    }
    void splay(int x)
    {
        update(x);
        for(int f=fa[x];f=fa[x],!isroot(x);rotate(x))
        if(!isroot(f))
        rotate(getch(x)==getch(f)?f:x);
    }
    void access(int x)
    {
        for(int f=0;x;f=x,x=fa[x])
        splay(x),ch[x][1]=f,maintain(x);
    }
    void makeroot(int x)
    {
        access(x);
        splay(x);
        swap(ch[x][0],ch[x][1]);
        rev[x]^=1;
    }
    int find(int x)
    {
        access(x);
        splay(x);
        while(ch[x][0])
        x=ch[x][0];
        splay(x);
        return x;
    }//前面都是LCT板子部分
    void added(int u,int c)
    {
        int v=u;
        makeroot(u), access(v), splay(v);
      val[u] = (val[v] + c) ;
      sum[v] = (sum[v] + siz[v] * c ) ;
      add[v] = (add[v] + c) ;
        return;
    }//单点加（相当于对区间[u,u]加）
    int query(int u)
    {
        if(u==0)
            return 0;
        int v=1;
        makeroot(u), access(v), splay(v);
        return sum[v];
    }//区间查询（注意特判u=0的情况，在转化前缀和时1-1=0会出问题）
    void link(int u,int v)
    {
    if (find(u) != find(v)) 
    makeroot(u), fa[u] = v;
    }
}st[2];
int c1[maxn],d1[maxn],c2[maxn],d2[maxn],a[maxn],b[maxn],lst[maxn];
int dp[maxn][110];
int final[maxn],cnt;
signed main()
{
        int n,k;
        cin>>n>>k;
        for(int i=1;i<=maxn/2;i++)
        for(int j=0;j<=1;j++)
        st[j].clear(i),st[j].val[i]=0,st[j].maintain(i),st[j].splay(i);
        for(int i=0;i<=10000;++i)
        for(int j=0;j<=1;j++)
        st[j].sum[i]=0;
        for(int j=0;j<=1;j++)
        for(int i=1;i<10000;i++)
        st[j].link(i,i+1);
        for(int i=1;i<=n;i++)
        {
        a[i]=read();
        if(a[i]>0)
        st[1].added(a[i],1);
        else
        {
        cnt++;
        final[i]=cnt;
        dp[cnt][0]=mod;
        }
        }
        int ans=0;
        for(int i=1;i<=n;i++)
	    {
		if(a[i]>0)
		{
			ans+=st[0].query(k)-st[0].query(a[i]);
			st[0].added(a[i],1); 
            st[1].added(a[i],-1);
			continue;
		}
		for(int j=1;j<=k;j++)
		dp[final[i]][j]=min(dp[final[i]][j-1],dp[final[i]-1][j]+st[0].query(k)-st[0].query(j)+st[1].query(j-1));
	}
	ans+=dp[cnt][k];
	cout<<ans;
}
```


---

## 作者：WisNourx_ (赞：0)

引用 $\operatorname{lxm}$ 巨佬的话：显然 dp。  

有一个显然的性质是填的数应是单调不降的。

当填的数符合 $a_i > a_j$，会让已有的逆序对数目增加。  

交换 $a_i, a_j$ 后，对于 $a_i$ 前面的 $i-1$ 个数， 交换 $a_i$ 和 $a_j$ 不会对原有的逆序对造成影响。

而由 $a_i$ 和 $a_j$ 产生的逆序对会因为这一次操作被消除，所以填的数应单调不降。  

考虑进行 dp。设 $dp_{i, j}$ 表示在第 $i$ 个 $-1$ 填 $1 \sim j$ 产生的最小贡献。

转移式为：$dp_{i,j}= \min(dp_{i,j-1}, dp_{i-1,j} + $ 在这个位置填 $j$ 的贡献 $)$。

对于求逆序对，想到用树状数组求出原先数列的逆序对。

分两个树状数组，一个维护未填数之前的，一个随 dp 过程维护，方便与第 $i$ 位后的数比较。

同时，我们对每个填 $-1$ 的位（假设是第 $i$ 位）进行枚举， 把 $1\sim k$ 依次填进第 $i$ 位中，求出它产生的贡献。   

最后用 dp 维护， 求出最小值。时间复杂度 $\mathcal O(nk\log k)$

```
#include<iostream>
using namespace std;
int p[120000],c[120000],c2[120000],a[110000],dp[11000][210],dp2[11000][210];
int k, cnt;

int lowbit(int x){return x&(-x);}
void add(int x)
{
    while(x<=k)
    {
        c[x]++;
        x+=lowbit(x);
    }
}
void add2(int x)
{
    while(x<=k)
    {
        c2[x]++;
        x+=lowbit(x);
    }
}
int getsum(int x)
{
    int sum=0;
    while(x>0)
    {
        sum+=c[x];
        x-=lowbit(x);
    }
    return sum;
}
int getsum2(int x)
{
    int sum=0;
    while(x>0)
    {
        sum+=c2[x];
        x-=lowbit(x);
    }
    return sum;
}
int main()
{
    int n;scanf("%d%d",&n, &k);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
        if(a[i]>0) add(a[i]);
        else p[i]=++cnt,dp[cnt][0]=10000000009;//确保在-1的时候进行dp 
    }
    long long ans=0;
    for (int i=1;i<=n;i++)
    {
        if(a[i]>0)
        {
            ans+=getsum2(k)-getsum2(a[i]);//算逆序对 
            add2(a[i]);
        }	
        else
        {
            for (int j=1;j<=k;j++)
            {
                dp[p[i]][j]=min(dp[p[i]][j-1],dp[p[i]-1][j]+getsum2(k)-getsum2(j)+getsum(j-1)-getsum2(j-1));//getsum2(k)-getsum2(j)是求前i位已填过的数中比j大的。getsum(j-1)-getsum2(j-1)是求第i位后比自己小的。
            }
        }
    }
    ans+=dp[cnt][k];
    printf("%lld",ans);
    return 0;
}
```

---


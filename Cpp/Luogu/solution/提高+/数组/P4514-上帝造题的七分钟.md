# 上帝造题的七分钟

## 题目背景

裸体就意味着身体。

## 题目描述

“第一分钟，X 说，要有矩阵，于是便有了一个里面写满了 $0$ 的 $n\times m$ 矩阵。

第二分钟，L 说，要能修改，于是便有了将左上角为 $(a,b)$，右下角为 $(c,d)$ 的一个矩形区域内的全部数字加上一个值的操作。

第三分钟，k 说，要能查询，于是便有了求给定矩形区域内的全部数字和的操作。

第四分钟，彩虹喵说，要基于二叉树的数据结构，于是便有了数据范围。

第五分钟，和雪说，要有耐心，于是便有了时间限制。

第六分钟，吃钢琴男说，要省点事，于是便有了保证运算过程中及最终结果均不超过 $32$ 位有符号整数类型的表示范围的限制。

第七分钟，这道题终于造完了，然而，造题的神牛们再也不想写这道题的程序了。”。

——《上帝造裸题的七分钟》。

所以这个神圣的任务就交给你了。

## 说明/提示

对于 $10\%$ 的数据，$1 \le n \le 16$，$1 \le m \le 16$， 操作不超过 $200$ 个。

对于 $60\%$ 的数据，$1 \le n \le 512$，$1 \le m \le 512$。

对于 $100\%$ 的数据，$1 \le n \le 2048$，$1 \le m \le 2048$，$-500 \le delta \le 500$，操作不超过 $2\times 10^5$ 个，保证运算过程中及最终结果均不超过 $32$ 位带符号整数类型的表示范围。

## 样例 #1

### 输入

```
X 4 4
L 1 1 3 3 2
L 2 2 4 4 1
k 2 2 3 3```

### 输出

```
12```

# 题解

## 作者：Unknown_Error  (赞：133)

# 一位树状数组区间操作的方法就是

开两个树状数组A,B，如果我们想让[1,x]中所有数+v，那么就在A中x位置+x*v，B中x位置+v。

如果我们想查询[1,y]的和，那么ans=A中[1,y]的和+B中[y+1,n]的和*x。

## 问： 那么二维的呢？
## 答： 把两个换成四个。。。
# 代码
```
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;
const int maxn=2050;
int n,m;
struct BIT
{
    int s[maxn][maxn];
    void updata(int x,int y,int val)
    {
        if(!x||!y)  return ;
        for(int i=x;i<=n;i+=i&-i)    for(int j=y;j<=m;j+=j&-j)    s[i][j]+=val;
    }
    int query(int x,int y)
    {
        int ret=0,i,j;
        for(i=x;i;i-=i&-i)  for(j=y;j;j-=j&-j)  ret+=s[i][j];
        return ret;
    }
}A,B,C,D;
char str[5];
void add(int x,int y,int val)
{
    A.updata(x,y,val*x*y),B.updata(x,y,val*x),C.updata(x,y,val*y),D.updata(x,y,val);
}
int query(int x,int y)
{
    return A.query(x,y)+y*(B.query(x,m)-B.query(x,y))+x*(C.query(n,y)-C.query(x,y))+x*y*(D.query(n,m)-D.query(x,m)-D.query(n,y)+D.query(x,y));
}
int main()
{
    scanf("%s%d%d",str,&n,&m);
    int i,a,b,c,d,e;
    while(scanf("%s%d%d%d%d",str,&a,&b,&c,&d)!=EOF)
    {
        if(str[0]=='L') scanf("%d",&e),add(a-1,b-1,e),add(a-1,d,-e),add(c,b-1,-e),add(c,d,e);
        else    printf("%d\n",query(a-1,b-1)-query(a-1,d)-query(c,b-1)+query(c,d));
    }
    return 0;
}
```

---

## 作者：kuansoudafahao (赞：119)

# 二维树状数组

**二维树状数组**是一个十分~~胡扯~~玄妙的算法。它和一维树状数组有着相同的地方，那就是**lowbit**运算。在一维树状数组中，我们用tree[x]记录右端点为x，长度为lowbit(x)的区间的区间和。我们同样可以类似地定义tree[x][y]为右下端点为(x,y),高为lowbit(x),宽为lowbit(y)的区间的区间和。

## 那么我们如何对其进行**区间修改**呢？

我们回忆一下我们是如何对一维树状数组进行区间修改的。我们对其进行差分操作，是为了使得到的差分数组前缀和就等于对应位置元素的值。那么我们可以运用类比思想，设计一个二维的差分呢？
#### 什么是差分数组呢？

对于一个数组$A[ ]$，其差分数组$D[i]=A[i]-A[i-1] (i>0)$且$D[0]=A[0]$

令$SumD[i]=D[0]+D[1]+D[2]+…+D[i]$ （SumD[ ]是差分数组D[ ]的前缀和） 
则$SumD[i]=A[0]+A[1]-A[0]+A[2]-A[1]+A[3]-A[2]+…+A[i]-A[i-1]=A[i] $
即$A[i]$的差分数组是$D[i]$， 而$D[i]$的前缀和是$A[i]$

#### 回归正题

我们来看一下二维的前缀和。

$$sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+a[i][j]$$

查询左上角点（x1,y1），右下角点(x2,y2)的区间和则是：$$sum[x2][y2]-sum[x1-1][y2]-sum[x2][y1-1]+sum[x1-1][y1-1]$$

那么我们可以使差分数组$d[i][j]$等于$a[i][j]$和$a[i-1][j]+a[i][j-1]-a[i-1][j-1]$的差。

如下矩阵:

             0 0 0 0 0
             0 0 0 0 0
             0 0 0 0 0 
             0 0 0 0 0
             
当我们想给中间那个2*3的矩阵加上x时，差分数组的变化应该是：


			 0  0 0 0 0
             0 +x 0 0 -x
             0  0 0 0 0
             0 -x 0 0 +x
         
至于为什么要这样，我们要等到区间查询时就会发现。


## **区间查询**

根据差分数组的定义，我们不难发现，对于点(x,y)，它的二维前缀和就是:

$$\sum_{i=1}^x\sum_{j=1}^y\sum_{h=1}^i\sum_{k=1}^j d[h][k]$$

但我们类比一下一维树状数组的区间求和，我们亦可以统计每个$d[h][k]$出现的次数，我们就可以发现$d[1][1]$出现了$(x\times y)$次，$d[1][2]$出现了$x\times(y-1)$次……$d[h][k]$出现了$(x-h+1)\times (y-k+1)$次。

则原式整理得：

$$\sum_{i=1}^x\sum_{j=1}^y d[i][j]\times (x-i+1)\times (y-j+1)$$

分解得：

$$\sum_{i=1}^x\sum_{j=1}^y d[i][j]\times [(xy-xj+x)+(-yi+ij-i)+(y-j+1)]$$

最后得：

$$\sum_{i=1}^x\sum_{j=1}^y d[i][j]\times (xy+x+y+1)-d[i][j]\times i(y+1)-d[i][j]\times j(x+1)+d[i][j]\times i\times j$$

根据我们最后分解出来的公式，我们需要维护四个数组$d[i][j],d[i][j]*i,d[i][j]*j,d[i][j]*i*j$，从而实现区间查询。

## 例题

[LuoguP4514 上帝造题的七分钟](https://www.luogu.org/problemnew/show/P4514)

非常适合我们的二维树状数组裸题。因为这题~~听说~~开二维线段树会爆空间，所以我们要使用二维树状数组。而且这题要开o2优化，不然过不了。~~惨痛的经历。~~原理我们已经讲得很清楚了，直接上代码。
```c++
// luogu-judger-enable-o2
#include <cstdio>

int n,m,num,x1,y1,x2,y2;
char c[3];

struct BIT
{
	int tree[2050][2050];
	
	int lowbit(int x) {return x&-x;}
	
	void add(int x,int y,int num)
	{
		for(int i=x; i<=n; i+=lowbit(i))
			for(int j=y; j<=m; j+=lowbit(j))
				tree[i][j]+=num;
	}
	
	int query(int x,int y)
	{
		int res=0;
		for(int i=x; i>=1; i-=lowbit(i))
			for(int j=y; j>=1; j-=lowbit(j))
				res+=tree[i][j];
		return res;
	}
}A,Ai,Aj,Aij;

int read()
{
	int sign=1,res=0;
	char c;
	while((c=getchar())<48||c>57)
		if(c=='-')
			sign=-1;
	if(sign)
		res=c-48;
	while((c=getchar())>=48&&c<=57)
		res=res*10+c-48;
	return res*sign;
}

int Ans(int x,int y)
{
	return A.query(x,y)*(x*y+x+y+1)-
		   Ai.query(x,y)*(y+1)-
		   Aj.query(x,y)*(x+1)+
		   Aij.query(x,y);
}

void Add(int x,int y,int num)
{
	A.add(x,y,num);
	Ai.add(x,y,num*x);
	Aj.add(x,y,num*y);
	Aij.add(x,y,num*x*y);
}

int main()
{
	scanf("X %d %d",&n,&m);
	while(~scanf("%s",&c))
	{
		scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
		if(c[0]=='L')
		{
			scanf("%d",&num);
			Add(x1,y1,num);
			Add(x1,y2+1,-num);
			Add(x2+1,y1,-num);
			Add(x2+1,y2+1,num);
		}else
		{
			printf("%d\n",Ans(x2,y2)-Ans(x1-1,y2)-Ans(x2,y1-1)+Ans(x1-1,y1-1));
		}
	}
	return 0;
}
```
[参考地址](https://www.cnblogs.com/RabbitHu/p/BIT.html)

---

## 作者：Dry_ice (赞：43)

~~本蒟蒻~~第三篇题解，望管理给过！

## 思路
貌似 **二维前缀和 $+$ 二维树状数组** 就阔以解决问题了。~~（线段树大佬勿喷~~

## 注意
按照我的方法，需要开启：

1. **快读**
1. **氧气** 优化；
1. **臭氧** 优化；
1. **$Ofast$** 优化；
1. **洛谷$O2$** 优化；

~~（大佬可以尝试关闭某些优化，反正我没试过~~

## CODE
```cpp
#include <stdio.h>
#include <iostream>
#pragma GCC optimize(1)
#pragma GCC optimize(2)
#pragma G++ optimize(3)
#pragma GCC optimize(Ofast)
const int N = 2501;
int n, m;
int c1[N][N], c2[N][N], c3[N][N], c4[N][N];
template<typename TYPE>
inline void read(TYPE&x) {
	x = 0;
	int w = 1;
	char c = getchar();
	for(; c < '0' || c > '9'; w *= c == '-' ? -1 : 1, c = getchar());
	for(; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + (c ^ 48), c = getchar());
	x *= w;
}
inline void add(int x, int y, int k) {
	for (int i = x; i <= n; i += i & -i)
		for (int j = y; j <= m; j += j & -j) {
			c1[i][j] += k;
			c2[i][j] += k * (x - 1);
			c3[i][j] += k * (y - 1);
			c4[i][j] += k * (x - 1) * (y - 1);
		}
}
inline int query(int x, int y) {
	int ret1 = 0, ret2 = 0, ret3 = 0, ret4 = 0;
	for (int i = x; i; i -= i & -i)
		for (int j = y; j; j -= j & -j) {
			ret1 += c1[i][j];
			ret2 += c2[i][j];
			ret3 += c3[i][j];
			ret4 += c4[i][j];
		}
	return ret1 * x * y - ret2 * y - ret3 * x + ret4;
}
int main(void) {
	scanf("X %d %d", &n, &m);
	char op;
	int a, b, c, d, delta;
	while (std:: cin >> op) {
		read(a), read(b), read(c), read(d);
		if (op ==  'L') {
			read(delta);
			add(c + 1, d + 1, delta);
			add(c + 1, b, -delta);
			add(a, d + 1, -delta);
			add(a, b, delta);
		}
		else
			printf("%d\n", query(c, d) - query(c, b - 1) - query(a - 1, d) + query(a - 1, b - 1));
	}
	return 0;
}
```

（最慢一个点卡到 $947ms$ 才过，~~洛谷评测姬相当卡啊~~

## 推荐树状数组题单
### 官方精选
- [【数据结构2-2】线段树与树状数组](https://www.luogu.com.cn/training/206)

### 用户精选
- [树状数组模板题](https://www.luogu.com.cn/training/3079)

- [CMの树状数组](https://www.luogu.com.cn/training/1143)

## The end. Thanks.

~~（走过路过一定要赞过啊~~

---

## 作者：Flanksy (赞：24)

### 分治套扫描线

**不开 O2 可过。**

------------

#### 前言

二维树状数组的模板，但是这篇题解不讲二维树状数组。

感谢 [H_Kaguya](https://www.luogu.com.cn/user/663405) 和 [yllcm](https://www.luogu.com.cn/user/682934) 指教扫描线相关问题。

前置知识：差分、线段树、树状数组、扫描线、分治。

------------

#### 线段树和扫描线

使用扫描线、线段树和差分离线解决静态问题：平面加**之后**平面求和。

扫描线的收益：问题降一维，维护一个一维线段树即可。

扫描线的代价：问题转为在线，所以扫描线只能用一次。

将修改和查询按照某个坐标轴差分成两个平面修改或平面查询（将矩形拆成两个等长对边），本文中扫描线全部按 $y$ 轴差分且按照 $y$ 轴坐标从小到大扫描。

为保证答案正确，差分时将询问中高度较小一边高度 $-1$，修改中高度较大一边高度 $+1$，等高度的情况先执行修改操作。

使用两次扫描线，**第一次扫描时直接执行修改**，在查询时将贡献乘以该查询的 $y$ 轴坐标 $+1$（查询的 $y$ 轴坐标修改后可能是 $0$，两次统计时线段树中的信息可能不等），同一查询先减后加。第一次扫描线的修改如果全部执行，**线段树会自行清空**。**第二次扫描时将修改的贡献乘以其 $y$ 轴坐标**，同一查询先加后减，**线段树不会清空这次扫描的修改，差分后的修改带了高度权值**。

可以感性理解为第一次统计查询范围内“不完整”的矩形，第二次统计查询范围内“完整”的矩形并且去掉第一次扫描加入的多余贡献。

时间复杂度 $O(n\log n)$。

[Code](https://www.luogu.com.cn/paste/pkm4y5fh)：扫描线解决静态二维平面加平面求和。

写得这么多是因为网上没有多少文章讲这个，至少笔者学习的时候没有找到。

------------
#### 分治和常数优化

这道题并非静态问题，但分治可以做到化动为静，需要离线处理。

按照时间顺序划出分治线，处理分治线左侧修改操作对分治线右侧查询操作的贡献即可，扫描线的使用方法上文已经讲了。关于分治，具体解释和使用方法可以看 [OI Wiki](https://oi-wiki.org/misc/cdq-divide/)，需要注意的是**不能重复统计贡献，而且要按时间顺序进行操作**。

分治执行 $\log n$ 层，时间复杂度 $O(n\log^2 n)$。

**注意在第二次扫描之后清空数据结构。**

[Code](https://www.luogu.com.cn/paste/7mbt341x)：朴素代码，询问和修改使用了同样的结构体。[评测记录](https://www.luogu.com.cn/record/102064908)，[吸氧可过](https://www.luogu.com.cn/record/102065532)。

但是如果要吸氧才能通过，这篇文章就没有意义了，为什么不写正解呢？~~我自己推不出来正解的式子~~。

开始优化，注意到三个能够优化的细节：**分治过程中多次对同一操作差分**、**分治过程中重新排序**、**线段树需要开 ```long long```**。

常数瓶颈应该在排序。考虑使用归并优化。分治线左边的操作无论如何都比右边的查询更早执行，可以先递归左半边和右半边，扫描线，归并左右区间。

**然而操作差分之后才能排序。**

把操作差分之后再分治不就行了？很遗憾，扫描线的过程中，**同一个查询或修改操作差分后不能分开**。

类似 FFT，分治总长度为 $2$ 的整数次幂时分治树为完美二叉树，**同一个操作差分后不会分开**，同时由于分治长度为 $2$ 时必定属于同一操作，自然满足排序条件，递归层数可以减少一层。用空操作填充序列直到总长度为 $2$ 的整数次幂即可。

另外只有区间内同时存在修改和查询时才会影响答案，这可以用前缀和判断。

[Code](https://www.luogu.com.cn/paste/vlffs9bq)：此时的代码已经能通过[六个测试点](https://www.luogu.com.cn/record/102085539)。

最后的瓶颈是线段树，改为**区间加区间求和的树状数组**之后可以通过题目，树状数组可以不开 ```long long``` 从而获得更小的常数。

[AC Code](https://www.luogu.com.cn/paste/hb9p4t6m)：[评测记录](https://www.luogu.com.cn/record/102086860)。

**一个未使用的优化：由于补齐了序列，可以将分治改为倍增。**

------------

#### 总结

效率比正解差，也许读者会认为这种解法不是很值得学习，但是它也有二维树状数组没有的优点。

- 统计贡献不受 $y$ 轴值域影响：这一维被扫描线扫掉了，数据结构不需要关心它，它的值域也不影响扫描线进行。
- 统计贡献不受 $x$ 轴值域影响：使用值域离散线段树记录区间，区间加时将加值乘以区间的实际长度，树状数组不能实现。

本题虽然是针对二维树状数组设计的，但分治套扫描线的解法也适用，并且这种离线分治的方法在更大的数据范围下表现会更好。

------------

#### 闲话

当初写这种解法的时候，没有打算通过，一步步优化后却取得了意料之外的成果，十分令人欣喜。

题解区没有这种做法，也许是认为效率太差？笔者认为能够不开 O2 优化通过已经足够，毕竟题目的数据范围较小，操作较多，树状数组以外的做法很难胜任。

虽然思路早就有了，但实现花费了很长时间，积累了宝贵的经验。

---

## 作者：按Ctrl加w会AC (赞：21)

## 题目描述

裸体（题）就意味着身体（神题）。
第一分钟， `X` 说，要有矩阵，于是便有了一个里面写满了 0 的 $n×m$ 矩阵。
第二分钟， `L` 说，要能修改，于是便有了将左上角为 $(a,b)$ ，右下角为 $(c,d)$ 的一个矩形区域内的全部数字加上一个值的操作。
第三分钟，`k` 说，要能查询，于是便有了求给定矩形区域内的全部数字和的操作。
第四分钟，彩虹喵说，要基于二叉树的数据结构，于是便有了数据范围。
第五分钟，和雪说，要有耐心，于是便有了时间限制。
第六分钟，吃钢琴男说，要省点事，于是便有了保证运算过程中及最终结果均不超过32位有符号整数类型的表示范围的限制。
第七分钟，这道题终于造完了，然而，造题的神牛们再也不想写这道题的程序了。”
——《上帝造裸题的七分钟》
所以这个神圣的任务就交给你了。

**时空限制** 1000ms /131MB



## 链接

[luogu 4514](https://www.luogu.org/problemnew/show/P4514)

## 题解

### 算法1（二维线段树）

被卡时间和空间
因为一开始没有估计时间和空间就写了
开 $O(2)$ 只过了五个点
二维线段树写得我好苦啊
以后再也不敢乱写了

> 代码

```cpp
/*
son[]:0,1,2,3
  -   -
| 0 | 2 |
  -   -
| 1 | 3 |
  -   -
*/

#include <cstdio>
#include <cctype>
//#define DEBUG 1

int n,m,ans;

char readc(){
	char ch;
	while (ch=getchar(),ch!=EOF && !isalpha(ch));
	return ch;
}

template <typename T>
inline void read(T &x){
	x=0; char ch; bool flg=0;
	while (ch=getchar(),ch<48 || 57<ch) flg^=!(ch^'-'); x=(ch&15);
	while (ch=getchar(),47<ch && ch<58) x=(x<<1)+(x<<3)+(ch&15);
	if (flg) x=-x;
}

template <typename T>
inline T max(const T x,const T y){ if (x<y) return y; return x; }

template <typename T>
inline T min(const T &x,const T &y){ if (x<y) return x; return y; }

struct node{
	int sum,tag;
	int size;
	node *son[4];
	node(){sum=0,tag=0,size=0,son[0]=NULL,son[1]=NULL,son[2]=NULL,son[3]=NULL;} 
};
node *rt=NULL;

void BUILD(node *&u,int a,int b,int c,int d){
	if (u==NULL) u=new node(),u->size=(c-a+1)*(d-b+1);
}

void UPDATE(node *&u){
	if (u==NULL) return;
	u->sum=0;
	if (u->son[0]!=NULL) u->sum+=u->son[0]->sum;
	if (u->son[1]!=NULL) u->sum+=u->son[1]->sum;
	if (u->son[2]!=NULL) u->sum+=u->son[2]->sum;
	if (u->son[3]!=NULL) u->sum+=u->son[3]->sum;
}

void PUSHDOWN(node *&u,int a,int b,int c,int d){
	if (u==NULL) return;
	if (u->size == 1) return;
	if (u->tag){
		int mid0=a+c>>1,mid1=b+d>>1;
		if (u->son[0]==NULL){
			BUILD(u->son[0],a,b,mid0,mid1);
		}
		u->son[0]->tag+=u->tag;
		u->son[0]->sum+=u->tag * u->son[0]->size;
		
		if (u->son[1]==NULL){
			BUILD(u->son[1],mid0+1,b,c,mid1);
		}
		u->son[1]->tag+=u->tag;
		u->son[1]->sum+=u->tag * u->son[1]->size;
		if (u->son[2]==NULL){
			BUILD(u->son[2],a,mid1+1,mid0,d);
		}
		u->son[2]->tag+=u->tag;
		u->son[2]->sum+=u->tag * u->son[2]->size;
		if (u->son[3]==NULL){
			BUILD(u->son[3],mid0+1,mid1+1,c,d);
		}
		u->son[3]->tag+=u->tag;
		u->son[3]->sum+=u->tag * u->son[3]->size;
		u->tag=0;
	}
//	(u->son[0],a,b,mid0,mid1);
//	(u->son[1],mid0+1,b,c,mid1);
//	(u->son[2],a,mid1+1,mid0,d);
//	(u->son[3],mid0+1,mid1+1,c,d);
}

/*
(a,b) 当前区间 左上角 
(c,d) 当前区间 右下角
(ax,bx) 待查区间 左上角
(cx,dx) 待查区间 右下角
*/

void MODIFY(node *&u,int a,int b,int c,int d,int ax,int bx,int cx,int dx,int delta){
	if (u==NULL) BUILD(u,a,b,c,d);
	u->sum+=(cx-ax+1)*(dx-bx+1)*delta;
	if (a==ax && b==bx && c==cx && d==dx){
		u->tag+=delta;
		return;
	}
	PUSHDOWN(u,a,b,c,d);
	int mid0=a+c>>1,mid1=b+d>>1;
	if (ax <= mid0 && bx <= mid1) MODIFY(u->son[0],a,b,mid0,mid1,ax,bx,min(cx,mid0),min(dx,mid1),delta);
	if (cx >  mid0 && bx <= mid1) MODIFY(u->son[1],mid0+1,b,c,mid1,max(ax,mid0+1),bx,cx,min(dx,mid1),delta);
	if (ax <= mid0 && dx >  mid1) MODIFY(u->son[2],a,mid1+1,mid0,d,ax,max(bx,mid1+1),min(cx,mid0),dx,delta);
	if (cx >  mid0 && dx >  mid1) MODIFY(u->son[3],mid0+1,mid1+1,c,d,max(ax,mid0+1),max(bx,mid1+1),cx,dx,delta);
	UPDATE(u);
}

void QUERY(node *&u,int a,int b,int c,int d,int ax,int bx,int cx,int dx){
	if (u==NULL) BUILD(u,a,b,c,d);
#ifdef DEBUG
	printf("%d %d %d %d %d %d %d %d",a,b,c,d,ax,bx,cx,dx);
#endif 
	if (a==ax && b==bx && c==cx && d==dx){
		ans+=u->sum;
#ifdef DEBUG
		printf(" %d\n",u->sum);
#endif
		return;
	}
#ifdef DEBUG
	printf("\n");
#endif
	PUSHDOWN(u,a,b,c,d);
	int mid0=a+c>>1,mid1=b+d>>1;
	if (ax <= mid0 && bx <= mid1) QUERY(u->son[0],a,b,mid0,mid1,ax,bx,min(cx,mid0),min(dx,mid1));
	if (cx >  mid0 && bx <= mid1) QUERY(u->son[1],mid0+1,b,c,mid1,max(ax,mid0+1),bx,cx,min(dx,mid1));
	if (ax <= mid0 && dx >  mid1) QUERY(u->son[2],a,mid1+1,mid0,d,ax,max(bx,mid1+1),min(cx,mid0),dx);
	if (cx >  mid0 && dx >  mid1) QUERY(u->son[3],mid0+1,mid1+1,c,d,max(ax,mid0+1),max(bx,mid1+1),cx,dx);
	UPDATE(u);
}

int main(){
	readc();
	read(n),read(m);
	BUILD(rt,1,1,n,m);
	int a,b,c,d,delta;
	char type;
	while (type=readc(),type!=EOF){
		read(a),read(b),read(c),read(d);
		if (type=='L'){
			read(delta);
			MODIFY(rt,1,1,n,m,a,b,c,d,delta);
		}
		else{
			ans=0;
			QUERY(rt,1,1,n,m,a,b,c,d);
			printf("%d\n",ans);
		}
	}
	return 0;
}
```

### 算法2 （二维树状数组）

> 思路

一维树状数组区间修改区间查询是利用差分的原理,通过一维的树状数组可以拓展出二维的树状数组,对于二维的树状数组区间查询问题,方法还是差分

对于二维树状数组区间修改区间查询问题只要维护四个支持单点修改区间查询问题的二维树状数组就可以了,数据很大,常数大就过不了,最后两个点不明 RE,加大 `MAXN` 后才过了,没有开 $O2$ 过了的

> 代码

```cpp
#include <cstdio>
#include <cctype>

const int MAXN=3055;
int n,m,ans,tree[4][MAXN][MAXN];

char readc(){
	char ch;
	while (ch=getchar(),ch!=EOF && !isalpha(ch));
	return ch;
}

template <typename T>
inline void read(T &x){
	x=0; char ch; bool flg=0;
	while (ch=getchar(),ch<48 || 57<ch) flg^=!(ch^'-'); x=(ch&15);
	while (ch=getchar(),47<ch && ch<58) x=(x<<1)+(x<<3)+(ch&15);
	if (flg) x=-x;
}

void ADD(int x,int y,int delta){
	if (x<1 || n<x || y<1 || m<y) return;
	for (int i=x;i<=n;i+=i&-i)
	for (int j=y;j<=m;j+=j&-j){
		tree[0][i][j]+=delta;
		tree[1][i][j]+=delta*y;
		tree[2][i][j]+=delta*x;
		tree[3][i][j]+=delta*x*y;
	}
}

int ASK(int x,int y){
	int res=0;
	for (int i=x;i;i-=i&-i)
	for (int j=y;j;j-=j&-j)
		res=res+(x+1)*(y+1)*tree[0][i][j]-(x+1)*tree[1][i][j]-(y+1)*tree[2][i][j]+tree[3][i][j];
	return res;
}

int main(){
	readc();
	read(n),read(m);
	int a,b,c,d,delta;
	char type;
	while (type=readc(),type!=EOF){
		read(a),read(b),read(c),read(d);
		if (type=='L'){
			read(delta);
			ADD(a,b,delta);
			ADD(c+1,b,-delta);
			ADD(a,d+1,-delta);
			ADD(c+1,d+1,delta);
		}
		else
			printf("%d\n",ASK(c,d)-ASK(a-1,d)-ASK(c,b-1)+ASK(a-1,b-1));
	}
	return 0;
}
```

---

## 作者：fmj_123 (赞：17)

Update 20191114 修了一些bug

- 题目大意：有一个写满0的矩阵，要求有

```
  1. L a b c d delta 代表将 (a,b),(c,d)(a,b),(c,d) 为顶点的矩形区域内的所有数字加上delta。

  2. k a b c d 代表求 (a,b),(c,d)(a,b),(c,d) 为顶点的矩形区域内所有数字的和。
 ```
  这两种操作
- 总结：区间修改，区间查询

  OK ，看到这dalao们的反应都是线段树或树状数组了，因为~~听说线段树过不去~~，所以我用了树状数组。
---
### 树状数组怎么用？如何区间修改，单点查询？请参考
## [3374](/problemnew/show/P3374)
## [3368](/problemnew/show/P3368)

---
我们从一维树状数组的“区间修改，区间查询“开始

使用差分的方法，差分数组$d_i$为第$i$个数（$a_i$）与第$i-1$($a_{i-1}$)个数的差,那么

因为 $a_i=d_1+d_2+...+d_{i-1}+d_i$

### 所以 $d_i$实际上用了$n-(i-1)$次,相当于有$i-1$次没被使用

所以 我们可以建两个树状数组，

第一个（本部分称为$tree$）存$d_i$

第二个（本部分称为$tree1$）存$d_i*(i-1)$

#### 求1~x的总和就是 $tree$中x的前缀和*x-$tree1$中x的前缀和

对于此公式，我的思路是先把x前面的数看成$a_x$,再减去多算的值（$tree1$数组）

贴代码（P3372）
```
// luogu-judger-enable-o2
//本代码中，tree和tree1的意义与前文相同
#include<bits/stdc++.h>
using namespace std;
long long n,tree[101000],tree1[100000],m,c,l,r,k;
void add(int x,int y)
{
    //修改tree
    for (int i=x;i<=n;i+=(i&(-i)))
        tree[i]+=y;
}
void add1(int x,int y)
{
    //修改tree1
    for (int i=x;i<=n;i+=(i&(-i)))
        tree1[i]+=y;
}
long long ask(long long x)
{
    long long ans=0,ans1=0;
    for (long long i=x;i;i-=(i&(-i)))
      ans+=tree[i];
    ans*=x;
    for (long long i=x;i;i-=(i&(-i)))
      ans1+=tree1[i];
    //分别求出ans*x与ans1（应该可以合起来写）
    return ans-ans1;
}
int main()
{
    scanf("%lld%lld",&n,&m);
    long long c=0,last=0,a=0;
    for (long long i=1;i<=n;i++)
    {
        scanf("%lld",&a);//long long读入要用lld
        c=a-last;//求差分
        add(i,c);add1(i,c*(i-1));
        last=a;
    }
    for (long long i=1;i<=m;i++)
    {
        scanf("%lld",&c);
        if (c==1)
        {
          //区间修改
          scanf("%lld%lld%lld",&l,&r,&k);
            add(l,k);add(r+1,-k);//在l处+x
            add1(l,k*(l-1));add1(r+1,(-k)*(r));//在r+1处-x，相当于抵消前面的+x
        }
        if (c==2)
        {
           //区间查询 
           scanf("%d%d",&l,&r);
            cout<<ask(r)-ask(l-1)<<endl;
        }
    }
    return 0;
}
```


---

回归正题，二维树状数组的区间修改，区间查询怎么做呢？

（二维树状数组的定义可以baidu一下）

因为差分实际上是前缀和的逆运算，所以，仿照二维前缀和（$s[i][j]=a[i][j]+a[i-1][j]+a[i][j-1]-a[i-1][j-1]$），我们可以写出二维差分公式
$d[i][j]=a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j-1]$

修改就是这样
```
//原数组
0 x x x 
0 x x x
0 x x x
```
```
//差分数组
0 +x 0 0 -x
0 0  0 0 0
0 0  0 0 0
0 -x 0 0 +x
```

仿照一维的“区间修改，区间查询”我们可以得出
### $d[i][j]$实际上被使用了$(n-i+1)(m-j+1)$次,相当于有$j(i-1)+i(j-1)+(i-1)(j-1)$次没被使用

因此，我们可以维护4个树状数组

第一个（本部分称为$tree$）存$d[i][j]$

第二个（本部分称为$tree1$）存$d[i][j]*(i-1)$

第三个（本部分称为$tree2$）存$d[i][j]*(j-1)$

第二个（本部分称为$tree3$）存$d[i][j]*(i-1)*(j-1)$

最后，求$(1,1)$到$(i,j)$的前缀和就是 
#### $tree[i][j]$的前缀和$*x*y$-$tree1[i][j]$的前缀和$*j$-$tree2[i][j]$的前缀和$*i$+$tree3[i][j]$的前缀和

（这个公式和普通的前缀和差不多啊好像）

我的思路和前面一样，先把所有数看成$a[i][j]$，再减差值

最后贴本题代码
```
// luogu-judger-enable-o2
//本代码中，tree、tree1、tree2、tree3的意义与前文相同
//码风不好求轻喷
#include<bits/stdc++.h>
using namespace std;
long long tree[2049][2049],tree1[2049][2049],tree2[2049][2049],tree3[2049][2049];
long long n,m,a,b,c,d,ad;char ch;
void add(long long x,long long y,long long z)
{
    for (long long i=x;i<=n;i+=i&(-i))
    {
        for (long long j=y;j<=m;j+=(j&(-j)))
        {
            tree[i][j]+=z;
            tree1[i][j]+=z*(x-1);
            tree2[i][j]+=z*(y-1);
            tree3[i][j]+=z*(x-1)*(y-1);//分别修改四个数组
        }
    }
}
void fa(long long a,long long b,long long c,long long d,long long ad)
{
    //分别修改四个点
    add(a,b,ad);add(c+1,b,-ad);
    add(a,d+1,-ad);add(c+1,d+1,ad);
}
long long ask(long long x,long long y)
{
    long long ans=0,ans1=0,ans2=0,ans3=0;
    for (long long i=x;i;i-=(i&(-i)))
    {
        for (long long j=y;j;j-=(j&(-j)))
        {
            ans+=tree[i][j];
            ans1+=tree1[i][j];
            ans2+=tree2[i][j];
            ans3+=tree3[i][j];
        }
    }
    ans*=x*y;	
    //分别求和
    return ans-ans1*y-ans2*x+ans3;
}
int main()
{
    cin>>ch;
    scanf("%d%lld",&n,&m);
    while (cin>>ch)
    {
        if (ch=='L')
        {
         //修改
         scanf("%lld%lld%lld%lld%lld",&a,&b,&c,&d,&ad);
          fa(a,b,c,d,ad);
        }
        if (ch=='k')
        {
        //查询
        	scanf("%lld%lld%lld%lld",&a,&b,&c,&d);
        	cout<<ask(c,d)-ask(c,b-1)-ask(a-1,d)+ask(a-1,b-1)<<endl;
        }
    }
    return 0;
}
```

本文部分参考自[胡小兔的博客](https://www.cnblogs.com/RabbitHu/p/BIT.html)，并感谢ta的博客对我学习此方法的帮助

---

## 作者：Spasmodic (赞：12)

这么一道题我调了这么长时间是我没想到的。。。

查了半天结果发现主函数有问题。。。

膜拜xiaolilsq帮我查错

好了写篇题解纪念一下

### 1.前置芝士
二维BIT
### 2.题解
首先考虑一维。

我们考虑如果是区间修改，单点查询怎么做。

我们会发现，我们只要维护

$$b_1=a_1$$

则

$$a_i=b_i+a_{i-1}$$
$$=\sum_{i=1}^{n}b_i$$

于是套用一维BIT板子。

再考虑区间修改，区间查询怎么做.

注意到

$$\sum_{i=1}^{n}a_i$$
$$=\sum_{i=1}^{n}\sum_{j=1}^{i}b_j$$
$$=\sum_{j=1}^{n}b_j(n-j+1)$$
于是只要再维护
$$c_i=b_i\times i$$
就可以了

---

下面考虑二维。

首先是矩形修改，单点查询。

注意到二维前缀和，我们可以仿照二维前缀和，定义
$$b_{i,j}=a_{i,j}-a_{i,j-1}-a_{i-1,j}+a_{i-1,j-1}$$
则
$$a_{i,j}=\sum_{x=1}^{i}\sum_{y=1}^{j}b_{x,y}$$
用二维BIT维护即可。

再考虑矩形求和。
$$\sum_{x=1}^{a}\sum_{y=1}^{b}a_{x,y}$$
$$=\sum_{x=1}^{a}\sum_{y=1}^{b}\sum_{i=1}^{x}\sum_{j=1}^{y}b_{i,j}$$
$$=\sum_{i=1}^{a}\sum_{j=1}^{b}b_{i,j}(a-i+1)(b-j+1)$$
所以只要再维护一下
$$c_{i,j}=i\times b_{i,j}$$
$$d_{i,j}=j\times b_{i,j}$$
$$e_{i,j}=ij\times b_{i,j}$$
就可以了。

下面是代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2055;
int n,m,bit[N][N][4];
void update(int k,int x,int y,int v){for(;x<=n;x+=x&-x)for(int j=y;j<=m;j+=j&-j)bit[x][j][k]+=v;} 
int sum(int k,int x,int y){int ret=0;for(;x;x-=x&-x)for(int j=y;j;j-=j&-j)ret+=bit[x][j][k];return ret;}
void Update(int x,int y,int v){update(0,x,y,v),update(1,x,y,v*x),update(2,x,y,v*y),update(3,x,y,v*x*y);}
int Sum(int x,int y){return sum(0,x,y)*(x+1)*(y+1)-sum(1,x,y)*(y+1)-sum(2,x,y)*(x+1)+sum(3,x,y);}
int main(){
	char op[2];
	scanf("%s%d%d",op,&n,&m);
	for(int a,b,c,d,delta;~scanf("%s%d%d%d%d",op,&a,&b,&c,&d);){
		if(op[0]=='L'){
			scanf("%d",&delta);
			Update(a,b,delta),Update(a,d+1,-delta),Update(c+1,b,-delta),Update(c+1,d+1,delta);
		}else{
			printf("%d\n",Sum(c,d)-Sum(a-1,d)-Sum(c,b-1)+Sum(a-1,b-1));
		}
	}
	return 0;
}
```

---

## 作者：__Ressed__ (赞：12)

其实这题也是可以用cdq分治做的（吸氧注意）
仿照二维树状数组的做法，如果有差分数组$d[i][j]=a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j-1]$，那么就有:

$$sum[x][y]=\sum\limits_{i=1}^{x}{\sum\limits_{j=1}^{y}{\sum\limits_{k=1}^{i}{\sum\limits_{l=1}^{j}{d[k][l]}}}}$$

$$=\sum\limits_{i=1}^{x}{\sum\limits_{k=1}^{i}{\sum\limits_{j=1}^{y}{((y+1)d[k][j]-j*d[k][j])}}}$$

$$=\sum\limits_{i=1}^{x}{\sum\limits_{j=1}^{y}{(x+1)(y+1)d[i][j]-(x+1)*j*d[i][j]-(y+1)*i*d[i][j]+i*j*d[i][j]}}$$

所以把询问拆成四个点（前缀和）、修改拆成四个点（差分）

已经按时间排好序，然后把x作为第二维来cdq，以y为下标开d,id,jd,ijd四个树状数组，统计答案就可以了

这样的话，即使N再大也能做了，只是常数比较大

附上代码

```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
#define pa pair<int,int>
#define CLR(a,x) memset(a,x,sizeof(a))
using namespace std;
typedef long long ll;
const int maxn=2100,maxm=2e5+10;

inline ll rd(){
    ll x=0;char c=getchar();int neg=1;
    while(c<'0'||c>'9'){if(c=='-') neg=-1;c=getchar();}
    while(c>='0'&&c<='9') x=x*10+c-'0',c=getchar();
    return x*neg;
}

struct Node{
    int t,x,y,o;ll v;
    Node(int a=0,int b=0,int c=0,int d=0,int e=0){
        t=a,x=b,y=c,v=d,o=e;
    }//o==1查 o==0改
}op[maxm*4],tmp[maxm*4];
ll dd[maxn],id[maxn],jd[maxn],ijd[maxn];
ll ans[maxm];
int N,M,L;
bool isask[maxm];

inline int lowbit(int x){return x&(-x);}
inline void add(ll *t,int x,ll y){
    for(;x<=M;x+=lowbit(x)) t[x]+=y;
}
inline ll query(ll *t,int x){
    ll re=0;for(;x;x-=lowbit(x)) re+=t[x];return re;
}

void cdq(int l,int r){
    if(l==r){return;}
    int m=l+r>>1;
    cdq(l,m);cdq(m+1,r);
    int p=l,q=m+1,n=0;
    for(;q<=r;q++){
        for(;p<=m&&op[p].x<=op[q].x;p++){
            tmp[++n]=op[p];
            if(op[p].o!=0) continue;
            add(dd,op[p].y,op[p].v);
            add(id,op[p].y,op[p].v*op[p].x);
            add(jd,op[p].y,op[p].v*op[p].y);
            add(ijd,op[p].y,op[p].v*op[p].x*op[p].y);
        }
        tmp[++n]=op[q];
        if(op[q].o!=1) continue;
        ll re=query(dd,op[q].y)*(op[q].x+1)*(op[q].y+1);
        re-=query(id,op[q].y)*(op[q].y+1);
        re-=query(jd,op[q].y)*(op[q].x+1);
        re+=query(ijd,op[q].y);
        ans[op[q].t]+=re*op[q].v;
    }for(;p<=m;p++) tmp[++n]=op[p];
    for(int p=l;p<=m&&op[p].x<=op[r].x;p++){
        if(op[p].o!=0) continue;
        add(dd,op[p].y,-op[p].v);
        add(id,op[p].y,-op[p].v*op[p].x);
        add(jd,op[p].y,-op[p].v*op[p].y);
        add(ijd,op[p].y,-op[p].v*op[p].x*op[p].y);
    }
    memcpy(op+l,tmp+1,sizeof(Node)*n);
}

int main(){
    // freopen("4514.in","r",stdin);
    int i,j;
    N=rd(),M=rd();
    char s[5];
    i=j=0;
    while(~scanf("%s",s)){
        ++i;
        int x1=rd(),y1=rd(),x2=rd(),y2=rd();
        if(s[0]=='k'){
            op[++j]=Node(i,x2,y2,1,1);
            if(x1>1&&y1>1) op[++j]=Node(i,x1-1,y1-1,1,1);
            if(x1>1) op[++j]=Node(i,x1-1,y2,-1,1);
            if(y1>1) op[++j]=Node(i,x2,y1-1,-1,1);
            isask[i]=1;
        }else{
            int dt=rd();
            op[++j]=Node(i,x1,y1,dt,0);
            if(x2<N&&y2<M) op[++j]=Node(i,x2+1,y2+1,dt,0);
            if(y2<M) op[++j]=Node(i,x1,y2+1,-dt,0);
            if(x2<N) op[++j]=Node(i,x2+1,y1,-dt,0);
        }
    }L=i;
    cdq(1,j);
    for(i=1;i<=L;i++){
        if(isask[i]) printf("%lld\n",ans[i]); 
    }
    return 0;
}
```

---

## 作者：zhoufangyuanPT (赞：10)

首先题目背景很棒棒:

裸体就意味着身体$\Rightarrow$裸题就意味着神题

其实这是一道二维树状数组+区间修改区间查询的裸题。

这题空间会卡掉二维线段树。~~(也许是我太菜了)~~

所以我们只好去打比较简单的树状数组了。
## 〇、暴力
听说暴力也能~~拿10分~~
## 一、树状数组
先去Ac掉[【模板】树状数组 1](https://www.luogu.org/problemnew/show/P3374)这题先，不懂去看这题的题解。
## 二、二维树状数组
设原来的数组为a，每一行独自为一个树状数组b。

这样的话：
$b[i][1]=a[i][1],b[i][2]=a[i][1]+a[i][2],b[i][4]=a[i][1]+a[i][2]+a[i][3]+a[i][4]...$

这时我们再设一个树状数组c，按行维护b。

这样的话：
$c[1][j]=b[1][j],c[2][j]=b[1][j]+b[2][j],c[4][j]=b[1][j]+b[2][j]+b[3][j]+b[4][j]...$

事实上我们只需要维护c数组就行了。

代码如下:
```c++
void change(int x,int y,int s)//给a[x][y]加上s
{
    for(int i=x;i<=n;i+=lowbit(i))
    {
        for(int j=y;j<=m;j+=lowbit(j))
        {
            a[i][j]+=s;
        }
    }
}
int ans(int x,int y)//求1..x，1..y的和
{
    int s=0;
    for(int i=x;i>0;i-=lowbit(i))
    {
        for(int j=y;j>0;j-=lowbit(j))
        {
            s+=a[i][j];
        }
    }
    return s;
}
```
## 三、区间维护+区间修改

首先有一个差分数组$b[i]=a[i]-a[i-1]$

有$a\left[n\right]=\sum_{i=1}^nb\left[i\right]$

然后又有一个数组$c[i]=i\cdot b[i]$

就有$\sum_{i=1}^na\left[i\right]=\sum_{i=1}^n\sum_{j=1}^ib\left[i\right]=\sum_{i=1}^n\left(n-i+1\right)\cdot b\left[i\right]=\left(n+1\right)\sum_{i=1}^nb\left[i\right]-\sum_{i=1}^nc\left[i\right]$

修改时$b[x]$加上数，$b[y+1]$减掉，c数组再乘上i，都是单点修改，所以是O(logn)

计算时都是区间和，所以也是O(logn)
## 四、二维树状数组+区间维护+区间修改
**首先我看不懂楼下的做法~~(也许是我太菜了)~~，我用了另一种推公式的方法**

设原来的数组是$a[i][j]$

然后有差分数组$b\left[i\right]\left[j\right]=a\left[i\right]\left[j\right]-a\left[i-1\right]\left[j\right]-a\left[i\right]\left[j-1\right]+a\left[i-1\right]\left[j-1\right]$

还有三个神奇的数组

$c\left[i\right]\left[j\right]=i\cdot b\left[i\right]\left[j\right]$

$d\left[i\right]\left[j\right]=j\cdot b\left[i\right]\left[j\right]$

$e\left[i\right]\left[j\right]=ij\cdot b\left[i\right]\left[j\right]$

这样求和时:

$\sum_{i=1}^n\sum_{j=1}^ma\left[i\right]\left[j\right]$

$=\sum_{i=1}^n\sum_{j=1}^m\sum_{k=1}^i\sum_{l=1}^jb\left[k\right]\left[l\right]$

$=\sum_{i=1}^n\sum_{j=1}^m\left(n-i+1\right)\left(m-j+1\right)\cdot b\left[i\right]\left[j\right]$

$=\sum_{i=1}^n\sum_{j=1}^m\left(n+1\right)\left(m+1\right)\cdot b\left[i\right]\left[j\right]-\sum_{i=1}^n\sum_{j=1}^m\left(m+1\right)i\cdot b\left[i\right]\left[j\right]-\sum_{i=1}^n\sum_{j=1}^m\left(n+1\right)j\cdot b\left[i\right]\left[j\right]+\sum_{i=1}^n\sum_{j=1}^mij\cdot b\left[i\right]\left[j\right]$

$=\left(n+1\right)\left(m+1\right)\sum_{i=1}^n\sum_{j=1}^mb\left[i\right]\left[j\right]-\left(m+1\right)\sum_{i=1}^n\sum_{j=1}^mc\left[i\right]\left[j\right]-\left(n+1\right)\sum_{i=1}^n\sum_{j=1}^md\left[i\right]\left[j\right]+\sum_{i=1}^n\sum_{j=1}^me\left[i\right]\left[j\right]$

每次修改都只要给$b[a][b]$加上，给$b[c+1][b],b[a][d+1]$减去，再给$b[c+1][d+1]$加上，并给c,d,e数组的各个地方都作修改。

求和按照公式来就好了。

# 但是

由于~~我太垃圾了~~，所以这个方法的常数过大。

被迫打了读入读出优化和氧气优化。

代码如下
```c++
// luogu-judger-enable-o2
#include<cstdio>
#include<cstring>
using namespace std;
inline void read(int &x)
{
    x=0;int f=1;
    char c=getchar();
    while(c<'0'||c>'9'){c=='-'?f=-1:1;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    x=x*f;
}
inline void write(int x)
{
    if(x<0){putchar('-');x=-x;}
    int y=10;
    while(y<=x)y=y*10;
    while(y!=1){y=y/10;putchar(x/y+'0');x=x%y;}
    putchar('\n');
}
int n,m;
int b[2050][2050],c[2050][2050],d[2050][2050],e[2050][2050];
inline int lowbit(int x){return x&-x;}
void change(int x,int y,int s,int (*a)[2050])
{
    for(int i=x;i<=n;i+=lowbit(i))
    {
        for(int j=y;j<=m;j+=lowbit(j))
        {
            a[i][j]+=s;
        }
    }
}
int ans(int x,int y,int (*a)[2050])
{
    int s=0;
    for(int i=x;i>0;i-=lowbit(i))
    {
        for(int j=y;j>0;j-=lowbit(j))
        {
            s+=a[i][j];
        }
    }
    return s;
}
char cs[11];
int main()
{
    int i,j,x,y;
    scanf("%s",cs+1);
    read(n);read(m);
    while(scanf("%s",cs+1)!=EOF)
    {
        read(i);read(j);read(x);read(y);
        if(cs[1]=='L')
        {
            int gc;read(gc);
            change(i,j,gc,b);change(i,y+1,-gc,b);
            change(x+1,j,-gc,b);change(x+1,y+1,gc,b);
            change(i,j,i*gc,c);change(i,y+1,-i*gc,c);
            change(x+1,j,-(x+1)*gc,c);change(x+1,y+1,(x+1)*gc,c);
            change(i,j,j*gc,d);change(i,y+1,-(y+1)*gc,d);
            change(x+1,j,-j*gc,d);change(x+1,y+1,(y+1)*gc,d);
            change(i,j,i*j*gc,e);change(i,y+1,-i*(y+1)*gc,e);
            change(x+1,j,-(x+1)*j*gc,e);change(x+1,y+1,(x+1)*(y+1)*gc,e);
        }
        else
        {
            int at,bt,ct,dt;
            at=i*j*ans(i-1,j-1,b)-j*ans(i-1,j-1,c)-i*ans(i-1,j-1,d)+ans(i-1,j-1,e);
            bt=(x+1)*j*ans(x,j-1,b)-j*ans(x,j-1,c)-(x+1)*ans(x,j-1,d)+ans(x,j-1,e);
            ct=i*(y+1)*ans(i-1,y,b)-(y+1)*ans(i-1,y,c)-i*ans(i-1,y,d)+ans(i-1,y,e);
            dt=(x+1)*(y+1)*ans(x,y,b)-(y+1)*ans(x,y,c)-(x+1)*ans(x,y,d)+ans(x,y,e);
            write(dt-ct-bt+at);
        }
    }
    return 0;
}
```

---

## 作者：warzone (赞：8)

二维树状数组的写法,其他julao已经介绍得相当透彻了,

在此就不多做介绍了

此处仅介绍二维线段树的一个奇怪写法.

二维线段树明显常数支撑不了这道题,时空两爆炸,吸氧快读也只能过**五个点**

但用以下写法,可以大大优化时空间,丢掉MLE,能过**六个点**

~~然而还是没过~~

这个写法灵感来自洛谷日报

 [洛谷日报#162 C++ template(模板) 初探](https://www.luogu.org/blog/z3475/c-template-mu-ban-chu-tan)

在里面,线段树通过模板特化,依靠编译器完成初始化

对于二维线段树,也可以这么做

首先写出一般节点的模板

```cpp
#define u unsigned
#define s short 
#define fx(p) (fx>p.fromx? fx:p.fromx)
#define fy(p) (fy>p.fromy? fy:p.fromy)
#define tx(p) (tx<p.tox?   tx:p.tox)
#define ty(p) (ty<p.toy?   ty:p.toy)
template<u char floor>//floor即节点的高度,它限制了线段树的高度
struct segment_tree{
    u s fromx,tox,fromy,toy;
    int h,lazy_tag;
	segment_tree<floor-1> ll,lr,rl,rr;//下行建树
	segment_tree(){h=lazy_tag=0;}
	inline void getid(u s fx,u s fy,u s tx,u s ty){
		fromx=fx,fromy=fy,tox=tx,toy=ty;
		ll.getid(fx,fy,(fx+tx)>>1,(fy+ty)>>1);
		lr.getid(fx,ll.toy+1,(fx+tx)>>1,ty);
		rl.getid(ll.tox+1,fy,tx,(fy+ty)>>1);
		rr.getid(ll.tox+1,ll.toy+1,tx,ty);
	}//初始化节点范围
	inline void plus(u s fx,u s fy,u s tx,u s ty,int num){
		h+=((tx-fx+1)*(ty-fy+1)*num);//更新和
		if(fx==fromx&&tx==tox&&fy==fromy&&ty==toy){
			lazy_tag+=num;//打标记
			return;
		}
		if(fx<=ll.tox&&fy<=ll.toy)  ll.plus(fx,fy,tx(ll),ty(ll),num);
		if(fx<=lr.tox&&lr.fromy<=ty) lr.plus(fx,fy(lr),tx(lr),ty,num);
		if(rl.fromx<=tx&&fy<=rl.toy) rl.plus(fx(rl),fy,tx,ty(rl),num);
		if(rr.fromx<=tx&&rr.fromy<=ty)rr.plus(fx(rr),fy(rr),tx,ty,num;
        //下行 
	}//区间加
	inline int sum(u s fx,u s fy,u s tx,u s ty){
		if(fx==fromx&&tx==tox&&fy==fromy&&ty==toy) return h;
		register int h=(tx-fx+1)*(ty-fy+1)*lazy_tag;//标记永久化
		if(fx<=ll.tox&&fy<=ll.toy)   h+=ll.sum(fx,fy,tx(ll),ty(ll));
		if(fx<=lr.tox&&lr.fromy<=ty)  h+=lr.sum(fx,fy(lr),tx(lr),ty);
		if(rl.fromx<=tx&&fy<=rl.toy)  h+=rl.sum(fx(rl),fy,tx,ty(rl));
		if(rr.fromx<=tx&&rr.fromy<=ty) h+=rr.sum(fx(rr),fy(rr),tx,ty);
        //下行 
		return h;
	}//求区间和
};
#undef fx
#undef fy
#undef tx
#undef ty
#undef u
#undef s
```

然后特化最底层的节点

```cpp
#define u unsigned
#define s short
template<>
struct segment_tree<0>{//特化高度为零的节点
	int h;
	u s fromx,fromy,tox,toy;
	segment_tree(){h=0;}
	inline void getid(u s fx,u s fy,u s tx,u s ty){
        fromx=fx,fromy=fy,tox=tx,toy=ty;
    }//底层节点不需要子节点
	inline void plus(u s fx,u s fy,u s tx,u s ty,int num){h+=num;}
   //底层节点只需单纯的加和求和
	inline int sum(u s fx,u s fy,u s tx,u s ty){return h;}
};
#undef u
#undef s
```

由此,一棵二维线段树就造好了

这么写二维线段树有诸多好处

1. 码量小,一百来行的二维线段树,只需六十来行

	(函数运行速度也因此大大提高)

2. 预处理由编译器自动完成(虽然无法输入,但这道题本来就不需要)

3. 常数小.内部是由嵌套类实现的,省去了数组下标(4字节)/指针(8字节)
	只需存储一个高度常量(1字节),底层节点还无需加标记,避免MLE
    
于是,最简单的二维线段树代码诞生了!(105行)

```cpp
// luogu-judger-enable-o2
#pragma GCC optimize(3,"Ofast")
#include<cstdio>
using namespace std;
#define getchar()(p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
inline long long r32(){
	register char c=getchar();
	register short w=1;
	while('0'>c||c>'9'){
		if(c=='-') w=-1;
		c=getchar();
	}
	register int a=0;
	while('0'<=c&&c<='9'){
		a=a*10+(c-'0');
		c=getchar();
	}
	return a*w;
}//快读 
#define u unsigned
#define s short 
#define fx(p) (fx>p.fromx? fx:p.fromx)
#define fy(p) (fy>p.fromy? fy:p.fromy)
#define tx(p) (tx<p.tox?   tx:p.tox)
#define ty(p) (ty<p.toy?   ty:p.toy)//批量宏定义 
template<u char floor>//floor即节点的高度,它限制了线段树的高度
struct segment_tree{
    u s fromx,tox,fromy,toy;
    int h,lazy_tag;
	segment_tree<floor-1> ll,lr,rl,rr;//下行建树
	segment_tree(){h=lazy_tag=0;}
	inline void getid(u s fx,u s fy,u s tx,u s ty){
		fromx=fx,fromy=fy,tox=tx,toy=ty;
		ll.getid(fx,fy,(fx+tx)>>1,(fy+ty)>>1);
		lr.getid(fx,ll.toy+1,(fx+tx)>>1,ty);
		rl.getid(ll.tox+1,fy,tx,(fy+ty)>>1);
		rr.getid(ll.tox+1,ll.toy+1,tx,ty);
	}//初始化节点范围
	inline void plus(u s fx,u s fy,u s tx,u s ty,int num){
		h+=((tx-fx+1)*(ty-fy+1)*num);//更新和
		if(fx==fromx&&tx==tox&&fy==fromy&&ty==toy){
			lazy_tag+=num;//打标记
			return;
		}
		if(fx<=ll.tox&&fy<=ll.toy)  ll.plus(fx,fy,tx(ll),ty(ll),num);
		if(fx<=lr.tox&&lr.fromy<=ty) lr.plus(fx,fy(lr),tx(lr),ty,num);
		if(rl.fromx<=tx&&fy<=rl.toy) rl.plus(fx(rl),fy,tx,ty(rl),num);
        //下行 
		if(rr.fromx<=tx&&rr.fromy<=ty)rr.plus(fx(rr),fy(rr),tx,ty,num);
	}//区间加
	inline int sum(u s fx,u s fy,u s tx,u s ty){
		if(fx==fromx&&tx==tox&&fy==fromy&&ty==toy) return h;
		register int h=(tx-fx+1)*(ty-fy+1)*lazy_tag;//标记永久化
		if(fx<=ll.tox&&fy<=ll.toy)   h+=ll.sum(fx,fy,tx(ll),ty(ll));
		if(fx<=lr.tox&&lr.fromy<=ty)  h+=lr.sum(fx,fy(lr),tx(lr),ty);
		if(rl.fromx<=tx&&fy<=rl.toy)  h+=rl.sum(fx(rl),fy,tx,ty(rl));
		if(rr.fromx<=tx&&rr.fromy<=ty) h+=rr.sum(fx(rr),fy(rr),tx,ty);
        //下行 
		return h;
	}//求区间和
};
#undef fx
#undef fy
#undef tx
#undef ty
template<>
struct segment_tree<0>{
	int h;
	u short fromx,fromy,tox,toy;
	segment_tree(){h=0;}
	inline void getid(u short fx,u short fy,u short tx,u short ty){fromx=fx,fromy=fy,tox=tx,toy=ty;}
	inline void plus(u short fx,u short fy,u short tx,u short ty,int num){h+=num;}
	inline int sum(u short fx,u short fy,u short tx,u short ty){return h;}
};
segment_tree<11> tree;
//定义一个11层的二维线段树,即2048*2048 
int main(){
	tree.getid(1,1,2048,2048);
	register u short n=r32();
	register u short m=r32();
	//输入范围 
	register u short a,b,c,d;
	register int delta;
	register char cha;
	while(1){
		cha=getchar();
		while(cha!='L'&&cha!='k'&&cha!=EOF) cha=getchar();
		if(cha==EOF) return 0;
		a=r32();
		b=r32();
		c=r32();
		d=r32();
		if(cha=='L'){
			delta=r32();
			tree.plus(a,b,c,d,delta);
			//区间加 
		}
		else{
			delta=tree.sum(a,b,c,d);
			printf("%d\n",delta);
			//区间求和 
		}
	}
}
```

---

## 作者：tribool4_in (赞：6)

这道题题需要用**二维树状数组**（树状数组略）。

树状数组本来的用处是单点修改、区间查询，怎么跟区间修改、区间查询（而且还是二维的）扯上关系了呢？这就要谈到**差分**了。

## 差分

设原数组为 $a[i]$，其差分数组为 $d[i]=a[i]-a[i-1]\ (i > 0)$。特别的，$d[0]=a[0]$。观察定义可以发现，查分数组 $d$ 的前缀和就是原数组，所谓“差分是前缀和的逆运算”。那么它有何用呢？答：方便进行区间修改。

举个例子：设原数组为 $a$，查分数组为 $d$。

$a = \{2,3,6,\ \ \ 3,7,\ \ \ 4\}$

$d = \{2,1,3,-3,4,-3\}$

此时我们把原数组 $a[1]$ 到 $a[3]$ 加 2：

$a = \{2,{\color{red}{5,8,\ \ \ 5}},7,\ \ \ 4\}$

$d = \{2,{\color{red}{3}},3,-3,{\color{red}{2}},-3\}$

可以看到，当我们把原数组 $a[1]$ 到 $a[3]$ 加 2 后，$d[1]\ +\!= 2$，$d[3+1]\ -\!= 2$。想想就能明白，当我们把原数组 $a[l]$ 到 $a[r]$ 加 $x$ 后，$d[l]\ +\!= x$，$d[r+1]\ -\!= x$。证明略。

## 树状数组 区间修改+区间查询

**区间修改+区间查询** 不是线段树的事吗？树状数组怎么搞？其实再想想，**树状数组+差分**是能实现 区间修改+区间查询 的。

首先，查分是可以区间修改的。那么如何区间查询？其实可以转换成求前缀和。

$\quad a_1+a_2+\cdots+a_k$

$=d_1+(d_1+d_2)+(d_1+d_2+d_3)+\cdots+(d_1+d_2+\cdots+d_k)$

$=k\times d_1+(k-1)\times d_2+(k-2)\times d_3+\cdots+(k-(k-1))\times d_k$

$=k\sum_{i=1}^kd_i-\sum_{i=1}^k((i-1)d_i)$

综上，我们只要维护两个树状数组分别用于维护 $d_i$ 的前缀和以及 $(i-1)d_i$ 的前缀和即可。

例题：[P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372) 其实这题虽是线段树模板题，却可以用如上的方法做，也能 AC。

P3372 【模板】线段树 1 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int Maxn = 100010;
#define lowbit(x)  ((x) & - (x))
ll tree1[Maxn],tree2[Maxn];

void update1(ll x,ll d) {
    while(x<=Maxn) {
        tree1[x]+=d;
        x+=lowbit(x);
    }
}
void update2(ll x,ll d) {
    while(x<=Maxn) {
        tree2[x]+=d;
        x+=lowbit(x);
    }
}
ll sum1(ll x) {
    ll ans = 0;
    while(x>0) {
        ans+=tree1[x];
        x-=lowbit(x);
    }
    return ans;
}
ll sum2(ll x) {
    ll ans = 0;
    while(x>0) {
        ans+=tree2[x];
        x-=lowbit(x);
    }
    return ans;
}

int main() {
    ll n, m;
    scanf("%lld%lld",&n,&m);
    ll old = 0, a;
    for (int i=1; i<=n; i++) {
        scanf("%lld",&a);
        update1(i, a-old);
        update2(i,(i-1)*(a-old));
        old = a;
    }
    while (m--) {     
        ll q, L, R, d;
        scanf("%lld",&q);
        if (q==1) {                
            scanf("%lld%lld%lld",&L, &R, &d);
            update1(L,d);         
            update1(R+1,-d);
            update2(L,d*(L-1));  
            update2(R+1,-d*R);   
        } else {                 
            scanf("%lld%lld",&L,&R);
            printf("%lld\n",R*sum1(R)-sum2(R) - (L-1)*sum1(L-1)+sum2(L-1));
        }
    }
    return 0;
}
```

## 树状数组 二维区间修改+区间查询

首先，你需要知道什么是二维树状数组，如何用它实现二维单点修改+区间查询（不会的自行[百度](https://www.baidu.com/)）。

如何实现二维区间修改+区间查询？相信大家已经明白了，就是利用差分。

![](https://img-blog.csdnimg.cn/20200806165821226.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDU5Mw==,size_16,color_FFFFFF,t_70)

定义差分数组 $d[i][j]=a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j]$，可知原数组 $a[x][y]=\sum_{i=1}^x\sum_{j=1}^yd[i][j]$。我们发现，那句“差分是前缀和的逆运算”仍然正确。

继续下去，再看区间查询。

![](https://img-blog.csdnimg.cn/20200806170347250.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDU5Mw==,size_16,color_FFFFFF,t_70)

我们想要区间查询，对照上图可知 $\sum_{i=a}^c\sum_{j=b}^da[i][j]=\sum_{i=1}^c\sum_{j=1}^da[i][j] - \sum_{i=1}^c\sum_{j=1}^{b-1}  a[i][j] - \sum_{i=1}^{a-1}\sum_{j=b}^da[i][j]+ \sum_{i=1}^{a-1}\sum_{j=1}^{b-1}a[i][j]$

可以看到问题转换为了如何求 $\sum_{i=1}^n\sum_{j=1}^ma[i][j]$。继续推导：


$\quad\sum_{i=1}^n\sum_{j=1}^ma[i][j]$

$=\sum_{i=1}^n\sum_{j=1}^m\sum_{k=1}^i\sum_{l=1}^jd[k][l]$

$=\sum_{i=1}^n\sum_{j=1}^md[i][j]\times(n-i+1)\times(m-i+1)$

$=(n+1)(m+1)\sum_{i=1}^n\sum_{j=1}^md[i][j]-(m+1)\sum_{i=1}^n\sum_{j=1}^md[i][j]\times i-(n+1)\sum_{i=1}^n\sum_{j=1}^md[i][j]\times j+\sum_{i=1}^n\sum_{j=1}^md[i][j]\times i\times j$

~~打公式把我手打废了~~

那么我们只需 4 个树状数组分别维护 $d[i][j]$，$d[i][j]\times i$，$d[i][j]\times j$ 和 $d[i][j]\times i\times j$ 即可。

代码（O2 版）：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 2e3 + 100;
int tree1[N][N], tree2[N][N], tree3[N][N], tree4[N][N];
inline int read() {
   int s=0, w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
   return s*w;
}
inline int lowbit(int x) {
    return x & (-x);
}
int n,m;
inline void update(int x, int y, int d) {
    for(int i = x; i <= n; i += lowbit(i))
        for(int j = y; j <= m; j += lowbit(j)) {
            tree1[i][j] += d;
            tree2[i][j] += x * d;
            tree3[i][j] += y * d;
            tree4[i][j] += x * y * d;
        }
}
inline int sum(int x, int y) {
    int ans = 0;
    for(int i = x; i > 0; i -= lowbit(i)) for(int j = y; j > 0; j -= lowbit(j)) ans += (x + 1) * (y + 1) * tree1[i][j] - (y + 1) * tree2[i][j] - (x + 1) * tree3[i][j] + tree4[i][j];
    return ans;
}

int main() {
    n = read(), m = read();
    char ch[3];
    while (~scanf("%s", ch)) {
        int a = read(), b = read(), c = read(), d = read(), x;
        if(ch[0] == 'L') {
            x = read();
            update(a, b, x);
            update(c + 1, d + 1, x);
            update(a, d + 1,-x);
            update(c + 1, b, -x);
        } else printf("%d\n",sum(c, d)+sum(a-1, b-1)-sum(a-1, d)-sum(c, b-1));
    }
    return 0;
}
```

但是，这样要开 O2，如何不开 O2 能过呢？快读救不了我们，只能试试更多卡常小技巧了！

## 附、卡常小知识

注意到我们代码中有一个 ```if(ch[0] == 'L')```，我们就优化它吧！

有比这更快的？当然了，就是位运算！

什么运算能代替它呢？按位与。。。按位或。。。**异或（xor）**！！！

异或是什么我就不说了，但大家想想，异或是可以代替 == 的。众所周知 'L' 的 ASCII 码是 76，那么利用异或的性质，只需将上面的语句改为 ```if(!(ch[0] ^ 76))``` 即可！

最终代码（无需 O2）：

```cpp
#include<bits/stdc++.h>
#define rg register
using namespace std;
const int N = 2e3 + 100;
int tree1[N][N], tree2[N][N], tree3[N][N], tree4[N][N];
inline int read() {
   int s=0, w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
   return s*w;
}
inline int lowbit(int x) {
	return x & (-x);
}
int n,m;
inline void update(int x, int y, int d) {
	for(rg int i = x; i <= n; i += lowbit(i))
		for(rg int j = y; j <= m; j += lowbit(j)) {
			tree1[i][j] += d;
			tree2[i][j] += x * d;
			tree3[i][j] += y * d;
			tree4[i][j] += x * y * d;
		}
}
inline int sum(int x, int y) {
	int ans = 0;
	for(rg int i = x; i > 0; i -= lowbit(i)) for(rg int j = y; j > 0; j -= lowbit(j)) ans += (x + 1) * (y + 1) * tree1[i][j] - (y + 1) * tree2[i][j] - (x + 1) * tree3[i][j] + tree4[i][j];
	return ans;
}

int main() {
	n = read(), m = read();
	char ch[3];
	while (~scanf("%s", ch)) {
		int a = read(), b = read(), c = read(), d = read(), x;
		if(!(ch[0] ^ 76)) {
			x = read();
			update(a, b, x);
			update(c + 1, d + 1, x);
			update(a, d + 1,-x);
			update(c + 1, b, -x);
		} else printf("%d\n",sum(c, d)+sum(a-1, b-1)-sum(a-1, d)-sum(c, b-1));
	}
	return 0;
}
```

参考：
https://www.cnblogs.com/lindalee/p/11503503.html





---

## 作者：League丶翎 (赞：6)

毕姥爷表示我就没想让除了树状数组的其他方法过
各位卡时间的dalao们歇歇吧

话说姥爷开小了数据否则会爆`long long`自己感受一下

详细题解在[blog](https://blog.csdn.net/Force_CHL/article/details/81178351)

## 区间查询,区间修改
类比一维的情况下,考虑每次查询得到些什么
假设$c[i][j]=s[i][j]-s[i-1][j]-s[i][j-1]+s[i-1][j-1]$

$$query(x,y)=\sum_{i=1}^{x}\sum_{j=1}^{y}c[i][j]$$

假设要查询$\sum_{i=1}^{x}\sum_{j=1}^{y}s[i][j]$,需要的是
$$\sum_{i=1}^{x}\sum_{j=1}^{y}c[i][j]*(x+1-i)*(y+1-j)$$
等价于
$$(x+1)*(y+1)*\sum_{i=1}^{x}\sum_{j=1}^{y}c[i][j]$$
$$-(y+1)*\sum_{i=1}^{x}\sum_{j=1}^{y}c[i][j]*i$$
$$-(x+1)*\sum_{i=1}^{x}\sum_{j=1}^{y}c[i][j]*j$$
$$+\sum_{i=1}^{x}\sum_{j=1}^{y}c[i][j]*i*j$$

所以说**只需要**维护四个二维树状数组$c[i][j],c[i][j]*i,c[i][j]*j,c[i][j]*i*j$即可

```cpp
void insert(int x,int y,int add) {
	int newx=x;
	while(newx<=n) {
		int newy=y;
		while(newy<=n) {
			a[0][newx][newy]+=add;
			a[1][newx][newy]+=add*x;
			a[2][newx][newy]+=add*y;
			a[3][newx][newy]+=add*x*y;
			newy+=lowbit(newy);
		}
		newx+=lowbit(newx);
	}
}
int query(int x,int y) {
	int newx=x,ans=0;
	while(newx) {
		int newy=y;
		while(newy) {
			ans+=(x+1)*(y+1)*a[0][newx][newy];
			ans-=(y+1)*a[1][newx][newy];
			ans-=(x+1)*a[2][newx][newy];
			ans+=a[3][newx][newy];
			newy-=lowbit(newy);
		}
		newx-=lowbit(newx);
	}
	return ans;
}
```

---

## 作者：arfa (赞：1)

> ### $Get\ Many\ Persimmon\ Trees$ 

上帝造人的七分钟,裸题就意味着神题(~~一道语文题~~)。

心血来潮就来发一下$Pascal$的代码。

具体的做法也是大佬们写出来了,这里不重复。

要注意一点,如果刚学完树状数组,可能会把**二维数组写成$while$的形式**,然后就傻逼的$WA*N+RE*M$。

$Pascal$写成$tree[mode,x,y]$的形式会好看很多吧。

```pascal
var
    tree:array[1..4,-1..110,-1..110] of longint; 维护的数组
    place:array[1..4] of longint; //输入用
    i,j,num,n,m:longint;
    mode:char; //命令标识

function lowbit(num:longint):longint; begin exit(num and -num); end;

procedure Insert(x,y,num:longint); //add函数
var
    i,j:longint;
begin
    i:=x;
    while i<n do
    begin
        j:=y; //坑点
        while j<m do
        begin
            inc(tree[1,i,j],num); //这样子写就不会卡常哦,qwq
            inc(tree[2,i,j],num*y); 
            inc(tree[3,i,j],num*x); 
            inc(tree[4,i,j],num*x*y);
            inc(j,lowbit(j));
        end;
        inc(i,lowbit(i));
    end;
end;

function Sum(x,y:longint):longint; //答案
var
    i,j:longint;
begin
    i:=x; Sum:=0;
    while i>0 do
    begin
        j:=y; //坑点
        while j>0 do
        begin
            inc(Sum,tree[1,i,j]*(x+1)*(y+1)-tree[2,i,j]*(x+1)-tree[3,i,j]*(y+1)+tree[4,i,j]); //这样子写就不会卡常哦,qwq
            dec(j,lowbit(j));
        end;
        dec(i,lowbit(i));
    end;
end;

begin

    readln(mode,n,m);
    while not eof do //操作
    begin
        read(mode,place[1],place[2],place[3],place[4]); 
        if mode='L' then
        begin
            readln(num);
            Insert(place[1],place[2],num);
            Insert(place[1],place[4]+1,-num);
            Insert(place[3]+1,place[2],-num);
            Insert(place[3]+1,place[4]+1,num);
        end;
        if mode='k' then
        begin
            readln; //坑点
            writeln(Sum(place[3],place[4])-Sum(place[1]-1,place[4])-Sum(place[3],place[2]-1)+Sum(place[1]-1,place[2]-1));
        end;
    end;
end.
```

总体感觉这题一般般....



---


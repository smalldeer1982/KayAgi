# ycz的妹子

## 题目背景

ycz 有很多很多的妹子（ycz：瞎说）

## 题目描述

机房神犇 ycz 有 $n$ 个青梅竹马，她们分别住在 $1~n$ 号城市中。小时候的她们美丽可爱，但是由于女大十八变，有些妹子的颜值发生了变化，但是十分重感情的 ycz 神犇不忍心抛弃她们，于是记录下来了她们颜值变化的值，我们用 $C, x, y$ 表示第 $x$ 个城市的妹子的颜值下降了 $y$ 。长大之后的 ycz 非常有魅力，有许多妹子被 ycz 迷得神魂颠倒，我们用$I, x, y$ 表示第 $x$ 个城市有一个妹子喜欢上了 ycz ，她的颜值为 $y$ （ $y$ 有可能是负数，但是 ycz 来者不拒）。但在中途有一些妹子和 ycz 吵架了，于是就分手了，我们用 $D, x$ 表示**第 $x$ 个妹子**和 ycz 分手了。

最近神犇 ycz 要去全国各地找他的妹子们，为了方便计算，我们珂以把 ycz 的妹子所在的城市当作是一条直线，并且挨在一起。神犇 ycz 由于忙于和他的妹子们联系此时已经很累了，于是交给你一个这样的任务：他想知道他在某个时间去找他的所有妹子们珂以获得多大的愉悦度，这个愉悦度为他找的妹子的颜值数，你要做的就是求出这个愉悦度之和（注意长大后妹子们的颜值可能为负数/滑稽）。

注意：每个城市只允许有一个妹子，也就是说后来喜欢上 ycz 的妹子会赶走之前这个城市喜欢 ycz 的妹子~~（一城不容二女）~~。

UPD:

青梅竹马都是喜欢 ycz 的。

分手的第 $x$ 个妹子不是第 $x$ 城市的妹子，是指从前往后数第 $x$ 个有妹子的城市的妹子。

青梅竹马长大后就是妹子。

修改的值 $y$ 不为负数，但是颜值减去之后可能为负数。

## 说明/提示

**样例解释：**

妹子颜值变化如下，删除的就没写在下面了。

```
1 2 1 4 5
1 2 1 4 5 6
1 2 1 5 6
1 2 1 3 6
1 2 1 3 6 9
```

对于 30% 的数据，$1 \le n,m \le 10$

对于 70% 的数据，$1 \le n,m \le 1000$

对于 100% 的数据，$1 \le n,m \le 100000,|a_i|,|y| \le 10^9$


## 样例 #1

### 输入

```
5 10
1 2 3 4 5
Q
C 3 2
Q
I 6 6
Q
D 4
Q
C 5 2
I 7 9
Q```

### 输出

```
15
13
19
15
22```

# 题解

## 作者：Wolfycz (赞：41)

~~我的妹子当然要我写个题解啊~~

其实我是没有妹子的。。。

这题就是一个裸的线段树单点查询区间修改，不过好像比赛的时候好多人对题面有问题啊。。。

我现在来解释一下题面好吧
* 青梅竹马们都喜欢我~~（逃）~~
* 青梅竹马没有特权，长大之后也是妹子，会被其他妹子赶走
* 每个城市只能有一个妹子，妹子的存在不是按颜值来的，谁后来谁就可以待在那个城市
* y可以为负数，两个y都可以为负数，但是出题人忘记改下面的限制了。。。不过讲真没啥影响，开个long long可以解决一切问题
* I x y操作中y有为0的情况，所以千万不要用权值来判是否存在~~（不会有人用权值判的吧）~~
* D x y操作是指第x个妹子，不是第x个城市。。。那些有妹子的城市从编号小到大数第x个，不是指操作顺序的第x个
* 城市编号不是1~n，记住这一点

所以只有删除操作麻烦点，多几个cnt数组就好。但是如果没有删除操作就可以直接开个数列，线段树都不要了。。。

然后就贴代码吧
``` cpp
/*program from Wolfycz*/
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define inf 0x7f7f7f7f
using namespace std;
typedef long long ll;
typedef unsigned int ui;
typedef unsigned long long ull;
inline int read(){
    int x=0,f=1;char ch=getchar();
    for (;ch<'0'||ch>'9';ch=getchar())	if (ch=='-')    f=-1;
    for (;ch>='0'&&ch<='9';ch=getchar())	x=(x<<1)+(x<<3)+ch-'0';
    return x*f;
}
inline void print(int x){
    if (x>=10)	print(x/10);
    putchar(x%10+'0');
}
const int N=1e5;
int val[(N<<1)+10];
struct Segment{
    #define ls (p<<1)
    #define rs (p<<1|1)
    struct node{
        int cnt;ll sum;
        void insert(int _sum,int _cnt){sum=_sum,cnt=_cnt;}
        node(){sum=cnt=0;}
    }tree[(N<<3)+10];
    friend node operator +(const node &x,const node &y){
        node z;
        z.sum=x.sum+y.sum;
        z.cnt=x.cnt+y.cnt;
        return z;
    }
    void build(int p,int l,int r){
        if (l==r){
            tree[p].insert(val[l],(bool)val[l]);
            return;
        }
        int mid=(l+r)>>1;
        build(ls,l,mid),build(rs,mid+1,r);
        tree[p]=tree[ls]+tree[rs];
    }
    void change(int p,int l,int r,int x,int v){
        if (l==r){
            tree[p].insert(v,1);
            return;
        }
        int mid=(l+r)>>1;
        if (x<=mid)	change(ls,l,mid,x,v);
        else	change(rs,mid+1,r,x,v);
        tree[p]=tree[ls]+tree[rs];
    }
    void insert(int p,int l,int r,int x,int v){
        if (l==r){
            tree[p].sum-=v;
            return;
        }
        int mid=(l+r)>>1;
        if (x<=mid)	insert(ls,l,mid,x,v);
        else	insert(rs,mid+1,r,x,v);
        tree[p]=tree[ls]+tree[rs];
    }
    void Delete(int p,int l,int r,int x){
        if (l==r){
            tree[p].insert(0,0);
            return;
        }
        int mid=(l+r)>>1;
        if (x<=tree[ls].cnt)	Delete(ls,l,mid,x);
        else	Delete(rs,mid+1,r,x-tree[ls].cnt);
        tree[p]=tree[ls]+tree[rs];
    }
}Tree;
char s[2];
int main(){
    int n=read(),m=read();
    for (int i=1;i<=n;i++)	val[i]=read();
    Tree.build(1,1,N<<1);
    for (int i=1;i<=m;i++){
        scanf("%s",s);
        if (s[0]=='C'){
            int x=read(),y=read();
            Tree.insert(1,1,N<<1,x,y);
        }
        if (s[0]=='I'){
            int x=read(),y=read();
            Tree.change(1,1,N<<1,x,y);
        }
        if (s[0]=='D'){
            int x=read();
            Tree.Delete(1,1,N<<1,x);
        }
        if (s[0]=='Q')	printf("%lld\n",Tree.tree[1].sum);
    }
    return 0;
}
```

---

## 作者：Juan_feng (赞：24)

## 这么好的一道分块题怎么能没有分块的题解呢QAQ

小蒟蒻就不多废话了，直接进入正题:

对于Q，C，I，D这四种操作

**Q操作**就是一个简单的区间求和，维护一个ans数组就可以了

**C操作**直接修改就行了（别忘了维护ans数组）

**D操作**可能稍微麻烦一点，动态删点这种东西一看就烦人呀qwq，所以小蒟蒻图个省事就直接吧所有的可能会出现的点都加进去了，删除的时候只要把要删的那个点的数值清零，再下个标记就好了

那么有dalao可能要问了，你个蒟蒻**怎么找到第x个妹子**呀？其实这也好办，维护一个geshu数组保存每个块内的妹子的数量，和妹子分手（删点）的时候就把这个点所在的块的**geshu--** 这样找第x个妹子的时候就可以从头开始找，一次加上一个块的妹子数量，直到找到答案所在的块，然后再暴力去找就可以了。

这样**I操作**也不难了，如果这个点有妹子的话就直接修改，维护ans，反之如果这个点现在没有妹子，那么让这个点所在块的**geshu++**就好了。

你看小蒟蒻辣么菜，也没多少时间去细想，就没怎么去优化，想必各位dalao一定可以想出更优秀的分块做法呀qwq

**（要是有什么更好的分块想法或者有对小蒟蒻程序的优化和建议还请一定要私信我呀qwq）**

那么代码如下：

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#define re register
#define FOR(i,l,r) for(re ll i=l;i<=r;++i)
#define maxn 200010
#define ll long long
using namespace std;

ll n,m,r,t,x,y,z,sq,now;
ll a[maxn],b[maxn],c[maxn],tag[maxn],bl[maxn],geshu[maxn],ans[maxn];
char ch;

inline void in(ll &x){ //无处不在的快读
    x=0;ll f=1;char c=getchar();
    while(c<'0'||c>'9'){
        if(c==-1) return;
        if(c=='-')f=-1;
        c=getchar();
    }
    while(c<='9'&&c>='0'){
        x=(x<<1)+(x<<3)+(c^'0');
        c=getchar();
    }
    x=x*f;
}

inline void out(ll a){
    if(a<0){
        a*=-1;
        putchar('-');
    }
    if(a>=10)out(a/10);
    putchar(a%10+'0');
}

ll query(ll x,ll y){ //区间求和
	ll res=0;
	FOR(i,x,min(y,b[x]*sq))
	  res+=a[i];
	if(b[x]!=b[y])
	  FOR(i,(b[y]-1)*sq+1,y)
	    res+=a[i];
	FOR(i,b[x]+1,b[y]-1)
	  res+=ans[i]+sq*tag[i];
	return res;
}

ll sss(ll x){  //已知妹子序号找该妹子所在的城市
	ll res=0;
	ll rt=1;
	while(res+geshu[rt]<x){
		res+=geshu[rt];
		++rt;
	}
	FOR(i,(rt-1)*sq+1,min(n,rt*sq)){
		if(bl[i]==0){
			++res;
		}
		if(res==x){
			return i;
		}
	}
	return 0;
}

int main(){
	in(now),in(m);
	n=200001;
	sq=sqrt(n);
	FOR(i,1,n){  //预处理
		b[i]=(i-1)/sq+1;
		if(i>now)
		  bl[i]=1;
	}
	FOR(i,1,now){
		in(a[i]),geshu[b[i]]++,ans[b[i]]+=a[i]; 
	}	
	FOR(i,1,m){
		cin>>ch;
		if(ch=='Q'){
			out(query(1,now)); //一点毛病没有的求和 
			puts("");
		}
		if(ch=='C'){ //无懈可击的修改 
			in(x),in(y);
			if(!bl[x]){ //bl为0代表有妹子 
				a[x]-=y;
				ans[b[x]]-=y;	
			} 
		}
		if(ch=='D'){
			in(x);
			ll cs=sss(x); // 第x个妹子所在的城市
			ans[b[cs]]-=a[cs]; 
			a[cs]=0;
			bl[cs]=1; //标记这个城市没有妹子了 
			--geshu[b[cs]];
		}
		if(ch=='I'){ 
			in(x),in(y);
			ans[b[x]]-=a[x];
			a[x]=y;
			ans[b[x]]+=a[x];
			if(bl[x]==1){//如果这个城市没有妹子 
				++geshu[b[x]];
				bl[x]=0;
			}  
			if(x>now)  
			  now=x;
		}
	}
	return 0;//功德圆满。
}
```
**最后祝大家NOIP RP++！**

---

## 作者：yqbylty (赞：10)

我深感$Wolfycz$的代码写的太漂$(chou)$亮$(lou)$了，因此我决定我也要来发一篇博客...

这题$70$分的话，只需要暴力就好了....

然后那个$30$的做法...暴力分真的虾捷豹给的...

这个是暴力代码...

**code:**

```cpp
/*Program from Luvwgyx*/
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=100010;
int n,m,a[maxn];char s[10];
int read(){
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
int main(){
    n=read();m=read();
    for(int i=1;i<=n;i++)a[i]=read();
    for(int i=1;i<=m;i++){
        scanf("%s",s+1);
        if(s[1]=='C'){
            int x=read(),y=read();
            a[x]-=y;
        }
        if(s[1]=='I'){
            int x=read(),y=read();
            a[x]=y;
        }
        if(s[1]=='D'){
            int cnt=0,pos,x=read();
            for(int i=1;i<=maxn-10;i++)
                if(a[i]){cnt++;if(cnt==x){pos=i;break;}}
            a[pos]=0;
        }
        if(s[1]=='Q'){
            int ans=0;
            for(int i=1;i<=maxn-10;i++)
                ans+=a[i];
            printf("%d\n",ans);
        }
    }
    return 0;
}
```

然后$100$分的做法的话，其实线段树就好了...

这题题面是我给的~~(Wolfycz改的)~~，你们要骂就骂我~~(他)~~吧...(虽然我个人觉得没啥问题...)

这题大家珂能因为我说是签到题的原因，没仔细看题...

我之前的描述是第$x$个城市的妹子，而后面$D\ x$这个操作，我的描述是第$x$个妹子，大家竟然没发现不对劲.../汗

然后其实我们用线段树存下来区间和以及这个区间内妹子的个数，然后单点修改区间查询就好了...

注意：$delete$的时候要注意，判断是走左边还是走右边的时候，不能通过和$mid$的比较来判断，而是应该与存着的妹子的个数$tree[mid].cnt$比较来判断...然后...应该就没啥要注意的了...

**code:**

```cpp
/*Program from Luvwgyx*/
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
typedef long long ll;
const ll maxn=2e5+10;
ll n,m,a[maxn];char s[10];
struct node{ll cnt,sum;}tree[maxn<<2];
ll read(){
    ll x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
void update(ll k){
    tree[k].cnt=tree[k<<1].cnt+tree[k<<1|1].cnt;
    tree[k].sum=tree[k<<1].sum+tree[k<<1|1].sum;
    return;
}
void build(ll k,ll l,ll r){
    if(l==r){
        tree[k].sum=a[l];
        if(a[l]!=0)tree[k].cnt++;
        return ;
    }
    ll mid=(l+r)>>1;
    build(k<<1,l,mid);
    build(k<<1|1,mid+1,r);
    update(k);
}
void change(ll k,ll l,ll r,ll x,ll y){
    if(l==r){tree[k].sum-=y;/*prllf("\n%d\n",l);*/return ;}
    ll mid=(l+r)>>1;
    if(x<=mid)change(k<<1,l,mid,x,y);
    else change(k<<1|1,mid+1,r,x,y);
    update(k);
}
void add(ll k,ll l,ll r,ll x,ll y){
    if(l==r){tree[k].sum=y;tree[k].cnt=1;/*prllf("\n%d\n",l);*/return ;}
    ll mid=(l+r)>>1;
    if(x<=mid)add(k<<1,l,mid,x,y);
    else add(k<<1|1,mid+1,r,x,y);
    update(k);
}
void del(ll k,ll l,ll r,ll x){
    if(l>r)return ;//prllf("%d %d\n",l,r);
    if(l==r&&x==tree[k].cnt){tree[k].sum=0;tree[k].cnt--;return ;}
    ll mid=(l+r)>>1;//prllf("%d\n",tree[k<<1].cnt);
    if(x<=tree[k<<1].cnt)del(k<<1,l,mid,x);
    else del(k<<1|1,mid+1,r,x-tree[k<<1].cnt);
    update(k);
}
/*
void dfs(ll k,ll l,ll r){
    if(l==r){if(tree[k].sum!=0)prllf("%d:%d ",l,tree[k].sum);return ;}
    ll mid=(l+r)>>1;
    dfs(k<<1,l,mid);dfs(k<<1|1,mid+1,r);
}
*/
int main(){
    //freopen("girl10.in","r",stdin);
    //freopen("girl10.out","w",stdout);
    n=read();m=read();
    for(ll i=1;i<=n;i++)a[i]=read();
    build(1,1,maxn-10);
    while(m--){
        scanf("%s",s);
        if(s[0]=='C'){ll x=read(),y=read();change(1,1,maxn-10,x,y);}
        if(s[0]=='I'){ll x=read(),y=read();add(1,1,maxn-10,x,y);}
        if(s[0]=='D'){ll x=read();del(1,1,maxn-10,x);}
        if(s[0]=='Q')printf("%lld\n",tree[1].sum);
        //dfs(1,1,maxn-10);puts("");
    }
    return 0;
}
```

---

## 作者：清远学会 (赞：6)

# 大吼一声：
## 遇事不决先分块
然后就狗在机子前一下午；
这道题，充分证明读题的重要性；
#### 如果你仅仅以为这是一道单点修改，那么你就GG了；
## 首先，分析一下题面：
1，ycz的妹子(青梅竹马)起初在1—n号城市中；但是，由于ycz的魅力强大，序列后面的妹子也会冒出来，所以，干脆直接把范围定位5e5(广撒网，多捞鱼) 雾~      。 咳咳，是题面保证的；

2，题面说会有负值，那么颜值为0的也会有咯；所以不要把权值作为有或无的标志，再开个数组存一下；

3，对于编号为C的修改，直接修改，注意把快内和顺带改一下；

4，对于编号为I的修改，因为一城不容二女(难道城市只有两室一厅那么大 雾 )，后来的会顶走前面的，也就是覆盖；所以对于这个修改，要分此城市之前有无妹子，有就直接覆盖，顺带改下快内和，而之前没有，那么块中的妹子个数要加加，并且此城市别打上标记；

5，丢与编号为D的修改，应为找的是第X个有妹子的，所以，我们就有已经维护好的块内妹子个数来跳，找到对应的块，修改如上，只是赋0而已；

6，询问就是块的和，简单一加就行

7，最后的提醒，要开long long，不然~呃呃，你知道的；
### 最后，奉上我的代码，不懂有注释：
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cmath>
#define N 1000500
using namespace std;

int n,m;
long long a[N],cnt[N],siz[N];//妹子的颜值，是否有妹子，块内妹子数
int L[N],R[N],tag[N]; //分块的编号，左右端点；
long long sum[N];//妹子和
int len,opt;//撒网范围

//修改1，简单修改
inline void Change_C(int x,int y) {
	if(!cnt[x]) return ;
	sum[tag[x]] -= a[x];
	a[x] -= y;
	sum[tag[x]] += a[x];
}

//修改2，分类讨论一下，顺带维护
inline void Change_I(int x,int y) {
	if(cnt[x]) {
		sum[tag[x]] -= a[x];
		a[x] = y;
		sum[tag[x]] += a[x];
	}
	else {
		cnt[x] = 1;
		sum[tag[x]] -= a[x];
		a[x] = y;
		sum[tag[x]] += a[x];
		siz[tag[x]] += 1;
	}
}

//跳妹子，找块并修改
inline void Change_D(int x) {
	int teg = 1;
	while(x - siz[teg] > 0) x -= siz[teg],teg ++;
	for(int i = L[teg];i <= R[teg];i ++) {
		if(x - cnt[i] == 0){
			siz[teg] --;
			sum[teg] -= a[i];
			cnt[i] = a[i] = 0;
            //别忘赋0
			return ;
		}
		else x -= cnt[i];
	} 
}

inline long long Qurry() {
	long long res = 0;
	for(int i = 1;i <= tag[opt];i ++)
		res += sum[i];
	return res;
}

int main() {
	opt = 500000;//广撒网
	scanf("%d%d",&n,&m);
	for(int i = 1;i <= n;i ++)
		scanf("%d",&a[i]),cnt[i] = 1;
        //青梅竹马是喜欢ycz的，直接赋1
	len = sqrt(opt);
	for(int i = 1;i <= opt;i ++) 
		tag[i] = (i - 1) / len + 1;
	for(int i = 1;i <= tag[opt];i ++)
		L[i] = R[i - 1] + 1,R[i] = min(L[i] + len - 1,opt);
        //处理左右端点
	for(int i = 1;i <= tag[opt];i ++)
		for(int j = L[i];j <= R[i];j ++)
			sum[i] += a[j],siz[i] += cnt[j];
     //分块预处理
            
	for(int i = 1;i <= m;i ++) {
		char s[3]; int x,y; 
		scanf("%s",s + 1);
		if(s[1] == 'C') {
			scanf("%d%d",&x,&y);
			Change_C(x,y);
		}
		if(s[1] == 'I') {
			scanf("%d%d",&x,&y);
			Change_I(x,y);
		}
		if(s[1] == 'D') {
			scanf("%d",&x);
			Change_D(x);
		}
		if(s[1] == 'Q') 
			printf("%lld\n",Qurry());
	}
	return 0;
}
```
希望可以帮到大家；
	喜欢分块————> [点我](https://loj.ac/problems/search?keyword=%E5%88%86%E5%9D%97)

## Update
之前代码有锅，已修改，给大家带来不便请谅解QAQ


---

## 作者：zl_just (赞：5)

当我去年啥都不会的时候做了这道题,然后爆零了  
如今想了起来,作文以记之  

---
对于$C$和$I$操作,我们直接修改原数组,复杂度为$O(1)$，对于$Query$，因为只查询总颜值 ~~(由于颜值守恒定律)~~ ，我们只需要用$sum$来维护：  

$C$操作时$a[x]-=y,sum-=y$  
$I$操作时$sum+=y-a[x],a[x]=y$

那最麻烦的$D$操作呢?  
难道爆查?  

我们记$c[i]$表示$i$前面有的女友数，那$c[i]$肯定递增，所以再**二分查找**了,有因为女友数会改变,所以再用树状数组维护了,单次复杂度为$O((logn)^2)$，虽然总复杂度为$O(n(longn)^2)$,但因为常数小,成功得到了[你谷第二](https://www.luogu.org/recordnew/show/19603774)的成绩(2019.06.03)

$Code$
```cpp// 
luogu-judger-enable-o2
#include<cstdio>
typedef long long ll;

const int maxn = 500000 + 5;
int n,m;
ll sum;
ll a[maxn];
int c[maxn];

inline int lowbit(int x) { return x&-x; }

inline void add(int x,int y) {
    while(x<=maxn) c[x]+=y,x+=lowbit(x);
}
//因为后来的妹子城市编号可能会大于n,所以要"x<=maxn"
inline int ask(int x) {
    int res=0;
    while(x) res+=c[x],x-=lowbit(x);
    return res;
}

template<typename T>
inline T read(T &a) {
    int c,f=1;  a=0;
    while((c=getchar()))  {
        if(c=='-') f=-1;
        if(c>='0'&&c<='9') break;
    }
    do {
        a=a*10+c-'0';
        c=getchar();
    }while(c>='0'&&c<='9');
    return a*=f;
}
inline char get() { int c; while((c=getchar())) if(c>'A'&&c<'Z') return c; }

inline int query(int x) {
    int l=1,r=maxn,mid;
    while(l<r) {
        mid=(l+r)>>1;
        if(ask(mid)>=x) r=mid;
        else l=mid+1;
    }
    //二分查找
    return r;
}

int main() {
    ll x,y;
    read(n); read(m);
    for(register int i=1;i<=n;++i) {
        read(a[i]),sum+=a[i];
        add(i,1);
        //表示i城市有妹子
    }
    while(m--) {
        char cmd=get();
        if(cmd=='Q') printf("%lld\n",sum);
        else if(cmd=='C')
            read(x),read(y),a[x]-=y,sum-=y;
        else if(cmd=='I') {
            read(x),read(y),
            sum+=y-a[x],a[x]=y;
            if(ask(x)==ask(x-1)) add(x,1);
            //ask(x)-ask(x-1)=0表示,x城市没有妹子
        }
        else {
            read(x),y=query(x),
            sum-=a[y],a[y]=0;
            add(y,-1);
            //妹子走了 QWQ
        }
    }
    return 0;
}

```

**注:**  
**1.初始时妹子颜值不为负不代表后来的妹子颜值不为负**  
**2.妹子城市居住范围为 $1$ ~ $5*10^5$, 而$n$为 $1 $ ~ $10^5$**


---

## 作者：_虹_ (赞：5)

当初比赛时候用了map，成功拿到暴力分。

其实这道题拿来练习非常不错，~~其实啥东西都能往上套~~

可以把所有【有妹子的】城市的【编号】看成一个序列，第x个妹子就是序列第k大。

那么我们只要求出动态整体第k大就好了。

~~所以怼一颗支持rank的平衡树。（变量可读性应该不错【为不加注释找借口】）~~

```cpp
#include <cstdio>
#include <vector>
#include <stack>

#ifndef  nullptr

#define nullptr NULL

#endif // ! nullptr

using namespace std;
inline int max(int a, int b)
{
	return a > b ? a : b;
}
inline int min(int a, int b)
{
	return a < b ? a : b;
}
enum sonptr
{
	ls = 0, rs = 1
};
class node
{
public:
	int size;
	int v;
	//bool erased;
	node* son[2];
	node(int _v = 0) :v(_v), size(1) {
		son[ls] = son[rs] = nullptr;
	};
	inline void update()
	{
		size = 1;
		if (son[ls]) {
			size += son[ls]->size;
		}
		if (son[rs]) {
			size += son[rs]->size;
		}
	}
	inline void clear()
	{
		v = 0;
		size = 1;
		son[ls] = son[rs] = nullptr;
	}
	inline int ls_size()const
	{
		return son[ls] ? son[ls]->size : 0;
	}
};
const int kmaxn = 500000 + 5;
node mempool[kmaxn];
stack<node*> garbage_collector;
int mpt;
node* malloc_node(int v)
{
	node* t = nullptr;
	if (!garbage_collector.empty())
	{
		t = garbage_collector.top();
		garbage_collector.pop();
		t->clear();
		t->v = v;
	}
	else if (mpt >= kmaxn)
		t = new node(v);
	else
	{
		t = &mempool[mpt++];
		t->v = v;
	}
	return t;
}
inline void free_node(node*& p)
{
	garbage_collector.push(p);
}
class balance_tree
{
	balance_tree(balance_tree&);
public:
	double alpha;
	node* root;
	vector<node*> vec;
	balance_tree(double _alpha = 0.75) :alpha(_alpha), root(nullptr) {}
	inline const bool bad(node* p)const
	{
		return max(p->ls_size(), p->son[rs] ? p->son[rs]->size : 0) > p->size*alpha;
	}
	node** basic_insert(int v, node*& p);
	void insert(int v);
	void travel(node* p);
	node* rebuild(int l, int r);
	bool basic_erase(int v, node*& p);//true means erased
	inline bool erase(int v);
	int get_rank(int v);
	int get_value_by_rank(int k);
	int upper_bound(int v);
	int lower_bound(int v);
};
node** balance_tree::basic_insert(int v, node*& p)
{
	if (!p)
	{
		p = malloc_node(v);
		return nullptr;
	}
	++p->size;
	node** t = basic_insert(v, p->son[(v >= p->v)]);
	if (bad(p))
		t = &p;
	return t;
}
void balance_tree::insert(int v)
{
	node** t = basic_insert(v, root);
	if (t)
	{
		vec.clear();
		vec.reserve((*t)->size + 5);
		travel(*t);
		*t = rebuild(0, vec.size());
	}
}
void balance_tree::travel(node* p)
{
	if (!p)
		return;
	travel(p->son[ls]);
	vec.push_back(p);
	travel(p->son[rs]);
}
node* balance_tree::rebuild(int l, int r)
{
	if (l >= r)
		return nullptr;
	int mid = (l + r) >> 1;
	node* t = vec[mid];
	t->son[ls] = rebuild(l, mid);
	t->son[rs] = rebuild(mid + 1, r);
	t->update();
	return t;
}
bool balance_tree::basic_erase(int v, node*& p)
{
	if (p->v == v)
	{
		if (!(p->son[ls] && p->son[rs]))
		{
			free_node(p);
			p = p->son[bool(p->son[rs])];
			//return true;
		}
		else
		{
			--p->size;
			bool c = p->ls_size() < (p->son[rs] ? p->son[rs]->size : 0);
			node** t = &(p->son[c]);
			c = !c;
			while ((*t)->son[c])
			{
				--(*t)->size;
				t = &(*t)->son[c];
			}
			p->v = (*t)->v;
			free_node(*t);
			*t = (*t)->son[!c];
		}
		return true;
	}
	if (basic_erase(v, p->son[v > p->v])) {
		--p->size;
		return true;
	}
	else
		return false;
}
inline bool balance_tree::erase(int v)
{
	return basic_erase(v, root);
}
int balance_tree::get_rank(int v)
{
	int rk = 0;
	node* p = root;
	while (p)
	{
		if (v > p->v)
		{
			rk += p->ls_size() + 1;
			p = p->son[rs];
		}
		else
			p = p->son[ls];
	}
	return rk + 1;
}
int balance_tree::get_value_by_rank(int k)
{
	int rk = 0;
	node* p = root;
	while (p)
	{
		if (rk + p->ls_size() + 1 < k)
		{
			rk += p->ls_size() + 1;
			p = p->son[rs];
		}
		else if (rk + p->ls_size() >= k)
		{
			p = p->son[ls];
		}
		else
		{
			return p->v;
		}
	}
	return 0;
}
int balance_tree::upper_bound(int v)
{
	return get_value_by_rank(get_rank(v + 1));
}
int balance_tree::lower_bound(int v)
{
	//cout << get_rank(v) << endl;
	return get_value_by_rank(get_rank(v) - 1);
}
#define reg register
int n,m;
balance_tree sbt;
long long data[kmaxn];
long long maxjoy;
bool exist[kmaxn];
inline void read(int& i)
{
    scanf("%d",&i);
}
inline void readchar(char& ch)
{
    do
    {
        ch=getchar();
    }while(ch=='\n'||ch=='\r'||ch==' ');
}
void leave(int x)
{
	int pos=sbt.get_value_by_rank(x);
	maxjoy-=data[pos];
	data[pos]=0;
	sbt.erase(pos);
	exist[pos]=false;
}
int main()
{
	read(n);
	read(m);
	for(reg int i=1;i<=n;++i)
    {
        //cin>>data[i];
        scanf("%lld",&data[i]); 
        maxjoy+=data[i];
        exist[i]=true;
        sbt.insert(i);
    }
    reg char opt;
    reg int x,y;
    ++m;
    while(--m)
    {
        //cin>>opt;
        readchar(opt);
        switch(opt)
        {
            case 'C':
                //cin>>x>>y;
                read(x);
                read(y);
                maxjoy-=y;
                data[x]-=y;
                break;
            case 'I':
                //cin>>x>>y;
                read(x);
                read(y);
                if(exist[x])
                    maxjoy-=data[x];
                else{
                	exist[x]=true;
                	sbt.insert(x);
                }
                data[x]=y;
                maxjoy+=y;
                break;
            case 'D':
                //cin>>x;
                read(x);
                leave(x);
                break;
            case 'Q':
                //cout<<maxjoy<<endl;
                printf("%lld\n",maxjoy);
                break;
        }
    }
	return 0;
}
```

~~跑的没有分块快~~

补充一个分块的代码，应该还算简洁。
```cpp
// luogu-judger-enable-o2
#include <cstdio>
#include <cmath>
#define reg register
using namespace std;
const int kmaxn=500000+25;
long long data[kmaxn];
bool exist[kmaxn];
int block[kmaxn];
int belong[kmaxn];
int n,m;
int block_num,block_size;
long long maxjoy=0;
inline void leave(const int& x)
{
    reg int rk=0;
    for(reg int i=1;i<=block_num+10;++i)
    {
        if(rk+block[i]>=x)//find
        {
            --block[i];
            i=block_size*(i-1)+1;//begin pos
            for(;rk<x;++i)
            {
                if(exist[i])
                    ++rk;
            }
            --i;
            maxjoy-=data[i];
            data[i]=0;
            exist[i]=false;
            return;
        }
        else
            rk+=block[i];
    }
}
inline void read(int& i)
{
    scanf("%d",&i);
}
inline void readchar(char& ch)
{
    do
    {
        ch=getchar();
    }while(ch=='\n'||ch=='\r'||ch==' ');
}
int main()
{
    read(n);
    read(m);
    //block_size=5;
    block_size=sqrt(kmaxn-1);
    block_num=(kmaxn-1)/block_size+bool((kmaxn-1)%block_size);
    for(reg int i=1;i<=n;++i)
    {
        //cin>>data[i];
        scanf("%lld",&data[i]); 
        maxjoy+=data[i];
        exist[i]=true;
    }
    for(reg int i=1,j=1;i<kmaxn;++i)
    {
        if(i>j*block_size)
            ++j;
        belong[i]=j;
        block[j]+=exist[i];
    }
    reg char opt;
    reg int x,y;
    while(m--)
    {
        //cin>>opt;
        readchar(opt);
        switch(opt)
        {
            case 'C':
                //cin>>x>>y;
                read(x);
                read(y);
                maxjoy-=y;
                data[x]-=y;
                break;
            case 'I':
                //cin>>x>>y;
                read(x);
                read(y);
                if(exist[x])
                {
                    maxjoy-=data[x];
                    --block[belong[x]];
                }
                exist[x]=true;
                data[x]=y;
                maxjoy+=y;
                ++block[belong[x]];
                break;
            case 'D':
                //cin>>x;
                read(x);
                leave(x);
                break;
            case 'Q':
                //cout<<maxjoy<<endl;
                printf("%lld\n",maxjoy);
                break;
        }
    }
    return 0;
}
```

~~线段树做法写的早，代码难看就不发了~~

---

## 作者：Kayisama (赞：4)

看到好多人都用的线段树......但是蒟蒻觉得线段树码量大怎么办？

那就不用线段树！

因为他只询问总和，所以开个变量记录呗。使用 $all$ 变量记录总和，在进行操作的时候实时修改。

对于其他的操作，我们开一个数组 $a$，$a_i$ 代表第 $i$ 座城市的贡献，开一个叫 $pla$ 的 vector，有序的记录每个有妹子的城市，并且开一个叫 $vis$ 的 bitset 来给 $pla$ 去重，$vis_i$ 是 $i$ 城市是否被放入 $pla$ 中。其中 $a$ 和 $vis$ 的长度是城市的数量。

每次 C 操作就是把 $a_x - y$ 并把 $all - y$ 。

每次 I 操作就是直接把 $all$ 减去 $a_x$，也就是把上一个人的贡献消去（如果没有上一个人就是减 $0$ 也就相当于没减），然后把 $all$ 和 $a_x$ 加上 $y$，也就是加上这个人的贡献。接下来判断，如果这个人在 $pla$ 数组中，因为顶替的性质，所以就不用管它；如果不在，就标记为在，也就是 $vis_x$ 设为 $1$，然后使用二分放入 $pla$ 的正确位置，以维持 $pla$ 的有序（此处可以直接使用 lower_bound）。

每次 D 操作就是把 $all$ 减去 $a_{pla_x}$ 以消除 $a_{pla_x}$ 的贡献，并把 $a_{pla_x}$ 设为 $0$，然后把 $vis_{pla_x}$ 置为 $0$，代表这座城市没有女朋友了，最后把 $pla_x$ 删掉，把这个位置彻底去掉。

Q 操作直接输出 $all$ 即可。

提醒: $n$ 的最大值不是城市的数量，城市的数量现在是 $5 \times 10^5+5$ ！！一定要开 long long！

我的代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
//Start define.
namespace MySpace{
	#define max(a,b) (a>b?a:b)
	#define min(a,b) (a<b?a:b)
	#define lowbit(x) (x&(-x))
	#ifdef ONLINE_JUDGE
	#define getchar getchar_unlocked
	#endif
	template <typename T>
	inline T read(){
		register T now=0,nev=1;
		register char c=getchar();
		while(c<'0' || c>'9') {
			if(c=='-') nev=-1;
			c=getchar();
		}
		while(c>='0' && c<='9') now=(now<<1)+(now<<3)+(c&15),c=getchar();
		return now*nev;
	}
	template<typename T>
	T qpow(T a,T n,T p){
		T res=1;
		while (n){
			if (n&1) res=1ll*res*a%p;
			a=1ll*a*a%p;
			n>>=1;
		}
		return res;
	}
	template<typename T>
	T gcd(T a,T b){return (b>0?gcd(b,a%b):a);}
}
using namespace MySpace;
//const int INF=0x66CCFF66;
#define int long long//为了偷懒写了一个#define int long long 
const int maxn=500005;
int n,m;
int x,y;
int all,a[maxn];//all和a数组 
vector<int> pla;//pla vector 
bitset<maxn> pd;//vis数组 
string opt;
signed main(){
	n=read<int>(),m=read<int>();//初始城市数 操作数 
	for (int i=1;i<=n;i++){
		a[i]=read<int>();//输入初始贡献 
		all+=a[i];//all加上贡献 
		pla.push_back(i);//放入pla数组(此时因为i递增,所以pla vector必定递增 
		pd[i]=1;//这个位置有贡献 
	}
	while (m--){
		cin>>opt;//操作编号 
		if(opt[0]=='C'){//C操作 
			x=read<int>(),y=read<int>();
			all-=y;//减去贡献 
			a[x]-=y;//减去贡献 
		}else if (opt[0]=='I'){//I操作 
			x=read<int>(),y=read<int>();
			all-=a[x];//减去原贡献 
			a[x]=y;//设定为新贡献 
			all+=y;//加上新贡献 
			if (!pd[x]){//如果位置未被放入 
				pd[x]=1;//设定为已被放入 
				pla.insert(lower_bound(pla.begin(),pla.end(),x),x);//二分放入保证有序 
			}
		}else if (opt[0]=='D'){//D操作 
			x=read<int>();
			all-=a[pla[x-1]];//删掉贡献 
			a[pla[x-1]]=0;//清空贡献 
			pd[pla[x-1]]=0;//设定这个城市为未被放入 
			pla.erase(pla.begin()+(x-1));//删除这个城市在pla里面的位置 
		}else{//Q操作 
			printf("%lld\n",all);//直接输出all即可 
		}
	}
	return 0;
}




```

[我的提交记录](https://www.luogu.com.cn/record/125957393)

---

## 作者：Wall_breaker (赞：3)

### 大家好！这里蒟蒻一枚
## 我们来解读一下这道有趣（po gai）的题目
### 一.清晰易懂（yunliwuli）的题面
读完这道题的题面，感到天昏地旋：**这是什么意思qwq**

在wa和re了几回合后，我才切了这道题。

**题面解读：**

1. 背景：ycz有许多mz
2. 青梅竹马：初始值
3. 颜值下降 CXY：对于点X权值减去Y
4. 有一个新的mz IXY：将点X权值改为Y
5. 分手 DX：将第X个有mz的点改为无mz

**ps:
1.对于第5条，有很多人（包括一开始的我）理解成了：
将点X改为无MZ，但这是错误的（WA的教训），也正是这个原因，将这道蓝题的通过率控的跟紫题一样qwq。
2.同时，有很多人（不包括我）将无mz的点直接改成0，但这也是错的，因为出题者说过有负数，那么就有可能有权值为0的点，因此要换种方式判断（你看到出题人阴险的笑容了吗）**
### 二.神奇的线段树
前四条操作平易近人，关键是第五条。

**核心思想：找第x个mz，需要比较左子区间存在的mz个数于x,若大于等于，则说明她在左子区间里，排名不变；反之，若小于，则说明她在右子区间里，排名为x-左子区间mz个数**
实现代码：
```cpp
inline void update(int p, int l, int r, int x) {
	if (l == r && x == 1) {
		mz[p] = 0;
		t[p] = 0;
	}
	else {
		register int mid = l + r >> 1;
		if (mz[p << 1] >= x) update(p << 1, l, mid, x);
		else update(p << 1 | 1, mid + 1, r, x - mz[p << 1]);
		mz[p] = mz[p << 1] + mz[p << 1 | 1]; 
		t[p] = t[p << 1] + t[p << 1 | 1];
	}
}
```

### 三.全代码
**码风之气天上来，AC之力不复回**
```cpp
#include<bits/stdc++.h>
using namespace std;
template <typename T> 
inline void read(T &x) {
	x = 0;
	register T f = 1;
	register char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') f = -1;
	for (; isdigit(c); c = getchar()) x = (x << 1) + (x << 3) + (c ^ 48);
	x *= f;
}
inline void d_read(double &x) {
	x = 0.0;
	int f = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') f = -1;
	for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);
	if (c == '.'){
		double num = 1.0;
		c = getchar();
		for (; isdigit(c); c = getchar()) x = x + (num /= 10) * (c ^ 48);
	}
	x *= f;
}

template <typename T> 
inline void w(T x) {
	if (x > 9) w(x / 10);
	putchar(x % 10 + 48);
}
template <typename T> 
inline void write(T x, char c) {
	if (x < 0){
		putchar('-');
		x = -x;
	}
	w(x);
	putchar(c);
}
const int cnt = 5e5;
int n, m, mz[cnt << 2];
long long a[cnt], t[cnt << 2];
inline void build(int p, int l, int r) {
	if (l == r) t[p] = a[l], mz[p] = (l <= n);
	else { 
		register int mid = l + r >> 1;
		build(p << 1, l, mid);
		build(p << 1 | 1, mid + 1, r);
		t[p] = t[p << 1] + t[p << 1 | 1]; 
		mz[p] = min(n, r - l + 1);
	}
}
inline void modify(int p, int l, int r, int x, long long k) {
	if (l == r) {
		t[p] -= k;
	}
	else {
		register int mid = l + r >> 1;
		if (mid >= x) modify(p << 1, l, mid, x, k);
		else modify(p << 1 | 1, mid + 1, r, x, k);
		t[p] = t[p << 1] + t[p << 1 | 1];
	}
}
inline void renew(int p, int l, int r, int x, long long k) {
	if (l == r) {
		t[p] = k;
		mz[p] = 1;
	}
	else {
		register int mid = l + r >> 1;
		if (mid >= x) renew(p << 1, l, mid, x, k);
		else renew(p << 1 | 1, mid + 1, r, x, k);
		t[p] = t[p << 1] + t[p << 1 | 1];
		mz[p] = mz[p << 1] + mz[p << 1| 1];
	}
}
inline void update(int p, int l, int r, int x) {
	if (l == r && x == 1) {
		mz[p] = 0;
		t[p] = 0;
	}
	else {
		register int mid = l + r >> 1;
		if (mz[p << 1] >= x) update(p << 1, l, mid, x);
		else update(p << 1 | 1, mid + 1, r, x - mz[p << 1]);
		mz[p] = mz[p << 1] + mz[p << 1 | 1]; 
		t[p] = t[p << 1] + t[p << 1 | 1];
	}
}
int main(void) {
	read(n); read(m); 
	for (register int i = 1; i <= n; i ++) read(a[i]);
	build(1, 1, cnt);
	for (register int i = 1; i <= m; i ++) {
		register char ch = getchar();
		register int x;
		register long long y;
		while(!isalpha(ch)) ch = getchar();
		if (ch == 'C') {
			read(x); read(y);
			modify(1, 1, cnt, x, y);
		}
		else if (ch == 'I') {
			read(x); read(y);
			renew(1, 1, cnt, x, y);
		}
		else if (ch == 'D') {
			read(x); 
			update(1, 1, cnt, x);
		}
		else {
			write(t[1], '\n');
		}
	}
	return 0;
}

```

### 四.彩蛋
有不对的请各位神犇指出，我**有可能**会改（前提是我会）

---

## 作者：马峰 (赞：3)

听说这题都是用$nlogn$的线段树或者分块写的。。。然鹅只有我第一眼看到题想写一个平衡树么。。。(虽然最后打了一个$nlog^2n$的线段树  
仔细分析可以发现，虽然有删除操作然鹅并不需要敲一棵平衡树。由于每次查询只是查询总值，所以我们可以直接设置一个变量来统计总和，对于每次修改直接在变量上进行加减即可    
这道题唯一有难度的地方就是他的删除操作删除的是第$x$个妹子而不是第$x$个城市的妹子，这就很懵逼，因为你不能直接在线段树上找第$x$个妹子（也许可以然鹅我太菜了）所以我们就要考虑把第$x$个妹子转化为第$x'$个城市的妹子  
如何查找呢？考虑二分答案。我们把线段树的定义改一下，类似于权值线段树却又不一样，表示为第$x$个城市是否拥有妹子。这样二分的时候查询一下前缀和就好了(这么说来还可以用树状数组水过去一会写一下  
还有一个坑点就是妹子最大的城市编号可能为$5\times 10^5$这点要注意不能直接在$1$~$n$的范围上进行修改  
代码  
```
#include<iostream>
#include<cstdio>
using namespace std;

long long tree[4000010],lazy[4000010],a[1000010],n,m;long long sum;
bool qwq[1000010];
void push_down(long long o,long long l,long long r){
    long long mid=l+r>>1;
    tree[o<<1]+=lazy[o]*(mid-l+1);tree[o<<1|1]+=lazy[o]*(r-mid);
    lazy[o<<1]+=lazy[o];lazy[o<<1|1]+=lazy[o];
    lazy[o]=0;
}
void update(long long o,long long l,long long r,long long ql,long long qr,long long v){
    if(l>=ql&&r<=qr){tree[o]+=(r-l+1)*v;lazy[o]+=v;return;}
    long long mid=l+r>>1;
    push_down(o,l,r);
    if(mid>=ql) update(o<<1,l,mid,ql,qr,v);
    if(mid<qr) update(o<<1|1,mid+1,r,ql,qr,v);
    tree[o]=tree[o<<1]+tree[o<<1|1];
}
long long query(long long o,long long l,long long r,long long ql,long long qr){
    if(l>=ql&&r<=qr) return tree[o];
    long long mid=l+r>>1,ans=0;
    push_down(o,l,r);
    if(mid>=ql) ans+=query(o<<1,l,mid,ql,qr);
    if(mid<qr) ans+=query(o<<1|1,mid+1,r,ql,qr);
    return ans;
}
long long pos(long long x){
    long long l=1,r=500000;
    while(l<r){
        long long mid=l+r>>1;
        if(query(1,1,500000,mid,mid)>=x) r=mid;
        else l=mid+1;
    }
    return l;
}

inline long long read(){
    long long x=0,gf=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-') gf=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-48;c=getchar();}
    return x*gf;
}

int main(){
    cin>>n>>m;
    for(long long i=1;i<=n;i++) a[i]=read(),update(1,1,500000,i,500000,1),sum+=a[i],qwq[i]=1;
    while(m--){
    	char c;cin>>c;
    	if(c=='Q') cout<<sum<<'\n';
    	else if(c=='C') {long long x=read(),y=read();a[x]-=y;sum-=y;}
    	else if(c=='I'){
    		long long x=read(),y=read();
    		if(qwq[x]){
    			sum-=a[x];sum+=y;a[x]=y;
    		}
    		else{sum+=y;a[x]=y;qwq[x]=1;update(1,1,500000,x,500000,1);}
    	}
    	else{
    		long long x=read();x=pos(x);sum-=a[x];a[x]=0;qwq[x]=0;update(1,1,500000,x,500000,-1);
    	}
    }
    return 0;
}
```

---

## 作者：hanzhongtlx (赞：2)

upd:更改了代码中的小错误。



------------


## [更好的阅读体验点这里](https://www.cnblogs.com/tlx-blog/p/12639521.html)
题目链接:[P4879 ycz的妹子](https://www.luogu.com.cn/problem/P4879)   
操作很多，但都是吓人的。          
一眼线段树，~~我不会告诉你我是搜线段树标签找到这题的~~。        
考虑用每个节点来维护每个城市中妹子的情况，显然只需维护：妹子的颜值与此城市是否有热恋中的妹子。       
开始想维护两个线段树，经过冷静后发现在一棵线段树上搞即可。       
看数据范围，知道要注意$long\;long$。    
来看基本操作（应该都是小儿科的了）：    
$1$.更新及建树：
```
void update(int k){a[k].sum=a[k<<1].sum+a[k<<1|1].sum,a[k].cnt=a[k<<1].cnt+a[k<<1|1].cnt;}
void build(int k,int l,int r,int x)
{
	a[k].l=l,a[k].r=r;
	if(l==r)
	{
		if(l<=x) a[k].cnt++;
		a[k].sum=(ll)t[l];
		return;
	}
	int mid=(l+r)>>1;
	build(k<<1,l,mid,x),build(k<<1|1,mid+1,r,x);
	update(k);
}
``` 
$2$.把一个城市妹子颜值降低：
```
void turn(int k,int x,int y)
{
	if(a[k].l==a[k].r){a[k].sum-=(ll)y;return;}
	int mid=(a[k].l+a[k].r)>>1;
	if(x<=mid) turn(k<<1,x,y);
	else turn(k<<1|1,x,y);
	update(k);
}
```
$3$.在一个城市上加一个妹子，注意把有妹子的标记打上：
```
void turn_to(int k,int x,int y)
{
	if(a[k].l==a[k].r){a[k].sum=(ll)y,a[k].cnt=1;return;}
	int mid=(a[k].l+a[k].r)>>1;
	if(x<=mid) turn_to(k<<1,x,y);
	else turn_to(k<<1|1,x,y);
	update(k);
}
```
$4$.寻找第$x$个有妹子的城市：   
这时候就要用到有无妹子的计数器了，我们在线段树上每次判断是在左儿子还是在右儿子即可。和权值线段树确定第$k$大（小）数的思想是一样的。    
```
int find(int k,int x)
{
	if(a[k].l==a[k].r){return a[k].l;}
	int mid=a[k<<1].cnt;
	if(x<=mid) return find(k<<1,x);
	else return find(k<<1|1,x-mid);
}
```
$5$.把在某个城市的妹子踢掉。     
这里的函数名十分生动：$kick$......   
我们把颜值设成$0$，并把标记打成“无妹子”即可。       
```
void kick(int k,int x)
{
	if(a[k].l==a[k].r){a[k].cnt=a[k].sum=(ll)0;return;}
	int mid=(a[k].l+a[k].r)>>1;
	if(x<=mid) kick(k<<1,x);
	else kick(k<<1|1,x);
	update(k);
}
```
$6$.颜值和：  
由于是所有数的和，只需输出树根的总颜值即可。    
需要注意的是：对于所有修改操作，记得不断更新（$update$）。   
在这里提供一个拓展题:把查询总颜值改为每次求可以得到妹子的最大颜值，这样的难度就有了提高，大家可以想一下做法。       
下面给出完整代码:
## $Code$：
```
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
#define MAXN 500005
#define ll long long
int n,m,x,y,t[MAXN];
char c;
struct node
{
	int l,r,cnt;
	ll sum;	
	node(){sum=cnt=(ll)0;}
}a[MAXN<<2];
void update(int k){a[k].sum=a[k<<1].sum+a[k<<1|1].sum,a[k].cnt=a[k<<1].cnt+a[k<<1|1].cnt;}
void build(int k,int l,int r,int x)
{
	a[k].l=l,a[k].r=r;
	if(l==r)
	{
		if(l<=x) a[k].cnt++;
		a[k].sum=(ll)t[l];
		return;
	}
	int mid=(l+r)>>1;
	build(k<<1,l,mid,x),build(k<<1|1,mid+1,r,x);
	update(k);
}
void turn(int k,int x,int y)
{
	if(a[k].l==a[k].r){a[k].sum-=(ll)y;return;}
	int mid=(a[k].l+a[k].r)>>1;
	if(x<=mid) turn(k<<1,x,y);
	else turn(k<<1|1,x,y);
	update(k);
}
void turn_to(int k,int x,int y)
{
	if(a[k].l==a[k].r){a[k].sum=(ll)y,a[k].cnt=1;return;}
	int mid=(a[k].l+a[k].r)>>1;
	if(x<=mid) turn_to(k<<1,x,y);
	else turn_to(k<<1|1,x,y);
	update(k);
}
int find(int k,int x)
{
	if(a[k].l==a[k].r){return a[k].l;}
	int mid=a[k<<1].cnt;
	if(x<=mid) return find(k<<1,x);
	else return find(k<<1|1,x-mid);
}
void kick(int k,int x)
{
	if(a[k].l==a[k].r){a[k].cnt=a[k].sum=(ll)0;return;}
	int mid=(a[k].l+a[k].r)>>1;
	if(x<=mid) kick(k<<1,x);
	else kick(k<<1|1,x);
	update(k);
}
int main()
{
	#define read(x) scanf("%d",&x)
	read(n),read(m);
	for(int i=1;i<=n;i++) read(t[i]);
	build(1,1,500000,n);
	for(int i=1;i<=m;i++)
	{
		cin>>c;
		if(c=='C') read(x),read(y),turn(1,x,y);
		else if(c=='I') read(x),read(y),turn_to(1,x,y);
		else if(c=='D') read(x),y=find(1,x),kick(1,y);
		else printf("%lld\n",a[1].sum);
	}
	return 0;
}
```

---

## 作者：QuantAsk (赞：2)

# 罕见的分块题解?
其实很容易发现都只需要单点修改和要整体求和。

如果不考虑$D$操作就很简单。只要维护一个$ans$表示答案，然后每次修改就改$ans$和$a_x$

但是有$D$操作怎么办？这就可以用到分块，记录每个块里有的妹子数，然后往前跳到目标所在的块，之后在块中暴力寻找。

跳块时间复杂度$O(\sqrt n)$，暴力时间复杂度$O(\sqrt n)$。也就是这个操作时间$O(\sqrt n)$

整体时间负责度$O(n\sqrt n)$(这里的n是最大的城市编号)

# 上$code$
```cpp
#include<cstdio>
#include<cmath>
#include<iostream>
#define ll long long
#define N 500000
#define T 1000
using namespace std;
ll n,m,a[N+10],ans,no[N+10],x,y,t;
ll L[T],R[T],num[T],pos[N+10];
char c;
void ycl()//预处理
{
	t=sqrt(N);
	for(ll i=1;i<=N;i++)
	{
		pos[i]=(i-1)/t+1;
		if(i>n)
		  no[i]=1;
	}
}
int main()
{
	scanf("%lld%lld",&n,&m);
	ycl();
	for(ll i=1;i<=n;i++)//输入
	{
	  scanf("%lld",&a[i]);
	  num[pos[i]]++;
	  ans+=a[i];
	}
	for(ll i=1;i<=m;i++)
	{
		cin>>c;
		if(c=='Q')//询问直接输出
			printf("%lld\n",ans);
		else if(c=='I')
		{
			scanf("%lld%lld",&x,&y);
			ans-=a[x];a[x]=y;ans+=y;//修改a[x]和改变ans
			n=max(n,x);
			if(no[x])//如果之前没有要对num进行修改
			{
				no[x]=0;
				num[pos[x]]++;
			}
		}
		else if(c=='C')
		{
			scanf("%lld%lld",&x,&y);
			if(no[x]) continue;//防止这个城市没有妹子
			ans-=y;
			a[x]-=y;
		}
		else if(c=='D')
		{
			scanf("%lld",&x);
			ll k=1;
			while(x-num[k]>0)
			  x-=num[k],k++;//跳块
			for(int i=(k-1)*t+1;i<=min(k*t,n);i++)
            //块里暴力
			{
			    if(!no[i]) --x;
			    if(!x)//找到位置，开始删除
			    {
			    	num[k]--;
			    	no[i]=1;
			    	ans-=a[i];
			    	a[i]=0;
			    	break;
			    }
			}
		}
	}
}
```

---

## 作者：Great_Influence (赞：2)

这题可以用平衡树写，直接按题意模拟即可。

平衡树太难写?不如试试$pbds$里的吧!联赛还可以用哦!

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/tree_policy.hpp>
#include<ext/pb_ds/assoc_container.hpp>
#define Rep(i,a,b) for(register int i=(a);i<=(b);++i)
#define Repe(i,a,b) for(register int i=(a);i>=(b);--i)
#define pb push_back
#define mp make_pair
#define Chkmax(a,b) a=a>b?a:b
#define Chkmin(a,b) a=a<b?a:b
#define mx(a,b) (a>b?a:b)
#define mn(a,b) (a<b?a:b)
typedef unsigned long long uint64;
typedef unsigned int uint32;
typedef long long ll;
using namespace std;
using namespace __gnu_pbds;

namespace IO
{
    const uint32 Buffsize=1<<15,Output=1<<23;
    static char Ch[Buffsize],*S=Ch,*T=Ch;
    inline char getc()
	{
		return((S==T)&&(T=(S=Ch)+fread(Ch,1,Buffsize,stdin),S==T)?0:*S++);
	}
    static char Out[Output],*nowps=Out;
    
    inline void flush(){fwrite(Out,1,nowps-Out,stdout);nowps=Out;}

    template<typename T>inline void read(T&x)
	{
		x=0;static char ch;T f=1;
		for(ch=getc();!isdigit(ch);ch=getc())if(ch=='-')f=-1;
		for(;isdigit(ch);ch=getc())x=x*10+(ch^48);
		x*=f;
	}

	template<typename T>inline void write(T x,char ch='\n')
	{
		if(!x)*nowps++='0';
		if(x<0)*nowps++='-',x=-x;
		static uint32 sta[111],tp;
		for(tp=0;x;x/=10)sta[++tp]=x%10;
		for(;tp;*nowps++=sta[tp--]^48);
		*nowps++=ch;
	}
}
using namespace IO;

inline void file()
{
#ifndef ONLINE_JUDGE
	freopen("water.in","r",stdin);
	freopen("water.out","w",stdout);
#endif
}

const int MAXN=5e5+7;

static int n,m;

static long long a[MAXN],ans;

inline void init()
{
	read(n);read(m);
	Rep(i,1,n)read(a[i]),ans+=a[i];
}

typedef pair<int,long long> Pr;

tree<Pr,null_type,less<Pr>,rb_tree_tag,tree_order_statistics_node_update>G;
tree<Pr,null_type,less<Pr>,rb_tree_tag,tree_order_statistics_node_update>::point_iterator it;

inline char getopt()
{
	static char c;
	for(c=getc();!isupper(c);c=getc());
	return c;
}

const long long inf=LLONG_MAX;

inline void solve()
{
	static int x,y;
	Rep(i,1,n)G.insert(mp(i,a[i]));
	Rep(i,1,m)
	{
		switch(getopt())
		{
			case 'C':
			{
				read(x),read(y);
				G.erase(mp(x,a[x]));G.insert(mp(x,a[x]-y));
				ans-=y,a[x]-=y;break;
			}
			case 'I':
			{
				read(x);read(y);
				it=G.lower_bound(mp(x,-inf));
				if(it!=G.end()&&it->first==x)
					G.erase(it),ans-=a[x];
				G.insert(mp(x,y));ans+=(a[x]=y);break;
			}
			case 'D':
			{
				read(x);it=G.find_by_order(x-1);
				a[it->first]=0;ans-=it->second;
				G.erase(it);break;
			}
			case 'Q':{write(ans);break;}
		}
	}
	flush();
}

int main()
{
    file();
    init();
    solve();
    return 0;
}
```

---

## 作者：wangxuye (赞：1)

### 题目链接
[ycz的妹子](https://www.luogu.org/problemnew/show/P4879)
### 题目大意
每次可以修改一个点的权值，插入一个点，删除一个点，询问点权和。
### 题目思路
看到题目的时候，我们可以发现对于修改和询问操作我们只要拿一个数组记录一下每个城市的点权就行了。那么插入和删除呢？  
一个自然的想法是记录一下每个前缀的有点权的点的数量，然后插入的时候修改前缀和，删除的时候二分找到需要删除的点就行了。这样插入的时间复杂度是$\Theta(log n)$，删除的时间复杂度是$\Theta(log^2n)$，总复杂度就是$\Theta(nlog^2n)$。  
那么可以再优化吗？答案是肯定的。我们每次删除的时候只要在线段树上直接二分就可以了，省去了每次查询前缀和的$log$，这样时间复杂度就变成了$\Theta(logn)$，总时间复杂度就是$\Theta(nlogn)$了。

上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=500010,MAXN=500000;
inline ll read();
inline void write(ll x);
inline void writeln(ll x);

int n,m;
ll a[N],sum=0;
bool visit[N];

struct SegmentTree{
	int num;
	#define num(x) tree[x].num
	#define lson(x) (x<<1)
	#define rson(x) (x<<1|1)
} tree[N<<5];
inline void pushup(int p)
{
	num(p)=num(lson(p))+num(rson(p));
}
inline void build(int p,int l,int r)
{
	if(l==r) return ;
	int mid=l+r>>1;
	build(lson(p),l,mid);
	build(rson(p),mid+1,r);
}
inline void update(int p,int l,int r,int x,int v)
{
	if(l==r)
	{
		num(p)+=v;
		return ;
	}
	int mid=l+r>>1;
	if(x<=mid) update(lson(p),l,mid,x,v);
	else update(rson(p),mid+1,r,x,v);
	pushup(p);
}
inline int query(int p,int l,int r,int k)
{
	if(l==r) return l;
	int mid=l+r>>1;
	if(num(lson(p))>=k) return query(lson(p),l,mid,k);
	else return query(rson(p),mid+1,r,k-num(lson(p)));
}

inline char getc()
{
	char ch=getchar();
	while(ch<'A'||ch>'Z') ch=getchar();
	return ch;
}
inline ll read()
{
	ll s=0;
	bool flag=false;
	char ch=getchar();
	for(;ch<'0'||ch>'9';ch=getchar()) if(ch=='-') flag=true;
	for(;'0'<=ch&&ch<='9';ch=getchar()) s=(s<<3)+(s<<1)+(ch^48);
	if(flag) return -s;
	return s;
}
inline void write(ll x)
{
	if(!x)
	{
		putchar('0'),putchar(' ');
		return ;
	}
	if(x<0) putchar('-'),x=-x;
	char ch[20];
	int tot=0;
	while(x) ch[++tot]=x%10,x/=10;
	for(int i=tot;i;i--) putchar(ch[i]^48);
	putchar(' ');
}
inline void writeln(ll x)
{
	write(x);
	putchar('\n');
}

int main()
{
	n=read(),m=read();
	build(1,1,MAXN);
	for(int i=1;i<=n;i++)
		a[i]=read(),sum+=a[i],update(1,1,MAXN,i,1),visit[i]=true;
	for(int i=1;i<=m;i++)
	{
		char ch=getc();
		if(ch=='Q') writeln(sum);
		if(ch=='C')
		{
			int x=read(),y=read();
			a[x]-=y,sum-=y;
		}
		if(ch=='I')
		{
			int x=read(),y=read();
			if(!visit[x]) update(1,1,MAXN,x,1),visit[x]=true;
			sum+=y-a[x],a[x]=y;
		}
		if(ch=='D')
		{
			int x=read();
			x=query(1,1,MAXN,x);
			sum-=a[x],a[x]=0;
			update(1,1,MAXN,x,-1);
			visit[x]=false;
		}
	}
	return 0;
}
```

---

## 作者：_louhc (赞：1)

这题为啥要搞线段树平衡树分块呀？树状数组多好QAQ

两种思路——

# 思路I——树状数组+二分

我们用树状数组维护妹子个数的前缀和。

当和妹子分手时二分查找第一个妹子出现的城市即可（即Get(an) == x的第一个位置）。

其他操作$O(1)$都可以完成，这里不解释。

复杂度为$O(nlog^2n)$

~~至少比分块要快~~

这大家应该都会，代码就不给了。

# 思路II——树状数组+倍增

树状数组简直与倍增是天生一对呀~

虽然一般来说，倍增、二分的复杂度是一样的，但在这里，树状数组+倍增做到了$O(nlogn)$复杂度。

还记得树状数组是怎么求前缀和的吗？比如$1101100$

$ans=c[(1000000)_2]+c[(1100000)_2]+c[(1101000)_2]+c[(1101100)_2]$

很清楚了吧？

所以直接从高位到低位顺序枚举，如果加上这一位答案还没大于等于所求值，就加上去。最后答案$+1$即可。具体看代码。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define Re register
#define MAXN 500005
#define LL long long

int N, M, n;
int c[MAXN];
LL ans, a[MAXN];
bool v[MAXN];

void Add( int x, int k ){ for ( ; x <= 500000; x += x & -x ) c[x] += k; }

int main(){
	scanf( "%d%d", &N, &M );
	for ( int i = 1; i <= N; ++i ) scanf( "%lld", &a[i] ), ans += a[i], Add( i, 1 ), v[i] = 1;
	char opt[5]; int x, y;
	
	for ( int i = 1; i <= M; ++i ){
		scanf( "%s", opt );
		
		if ( *opt == 'C' ){
			scanf( "%d%d", &x, &y );
			if ( v[x] ) a[x] -= y, ans -= y;
		} else if ( *opt == 'I' ){
			scanf( "%d%d", &x, &y );
			if ( !v[x] ) v[x] = 1, Add( x, 1 ), ans += y, a[x] = y;
			else ans -= a[x] - y, a[x] = y;
		} else if ( *opt == 'D' ){
			scanf( "%d", &x );
			int cur(0);
			for ( int j = 18; j >= 0; --j ) if ( ( cur | ( 1 << j ) ) <= 500000 && c[cur | ( 1 << j )] < x ) cur |= 1 << j, x -= c[cur];
			cur++; if ( v[cur] ) ans -= a[cur], a[cur] = v[cur] = 0, Add( cur, -1 );
		} else if ( *opt == 'Q' ) printf( "%lld\n", ans );
	}
	return 0;
}
```



---

## 作者：YuntianZhao (赞：1)

# P4879

这是一篇指针版线段树的题解。

区间操作，非常容易想到线段树。思考一下，发现每个节点需要维护妹子的数量和颜值和。

另外其实 C 和 I 本质上非常像，都是单点修改，写一个就够了。

比较坑的是每个城市只允许有一个妹子，所以最地层的节点的大小最大为 1 。

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef unsigned long long ull;

const int maxn = 1e5 + 5;

int n, m, k;
ll a[maxn];

template<typename T>
class SGT {
public:
  struct Node {
    int l, r;
    int sz;
    T d;
    Node *ls, *rs;
    Node(int l = 0, int r = 0):
        l(l), r(r), sz(0), d(0), ls(NULL), rs(NULL) {};
  };
  Node *root;
  void pushup(Node *p) {
    p->d = p->ls->d + p->rs->d;
    p->sz = p->ls->sz + p->rs->sz;
  }
  Node *build(int l, int r) {
    Node *p = new Node(l, r);
    if (l == r) {
      if (l <= n) {
        p->d = a[l];
        p->sz = 1;
      } else {
        p->d = 0;
        p->sz = 0;
      }
      return p;
    }
    int mid = (l + r) >> 1;
    p->ls = build(l, mid);
    p->rs = build(mid + 1, r);
    pushup(p);
    return p;
  }
  void update(Node *p, int x, T dv, int f) {
    if (p->l == x && p->r == x) {
      if (f == 0) {
        p->d += dv;
      } else {
        p->d = dv;
        p->sz = 1;
      }
      return;
    }
    int mid = (p->l + p->r) >> 1;
    if (x <= mid) update(p->ls, x, dv, f);
    else update(p->rs, x, dv, f);
    pushup(p);
  }
  void del(Node *p, int x) {
    if (p->sz < x) return;
    if (x == 1 && p->l == p->r) {
      p->sz = 0;
      p->d = 0;
      return;
    }
    if (x <= p->ls->sz) del(p->ls, x);
    else del(p->rs, x - p->ls->sz);
    pushup(p);
  }
  T query(Node *p) {
    return p->d;
  }
};

SGT<ll> t;

int main() {
  scanf("%d%d", &n, &m);
  for (int i = 1; i <= n; i++) {
    scanf("%lld", &a[i]);
  }
  t.root = t.build(1, 5 * maxn);
  char opt[5];
  ll x, y;
  for (int i = 1; i <= m; i++) {
    scanf("%s", opt);
    switch (opt[0]) {
      case 'C':
        scanf("%lld%lld", &x, &y);
        t.update(t.root, x, -y, 0);
        break;
      case 'I':
        scanf("%lld%lld", &x, &y);
        t.update(t.root, x, y, 1);
        break;
      case 'D':
        scanf("%lld", &x);
        t.del(t.root, x);
        break;
      case 'Q':
        printf("%lld\n", t.query(t.root));
        break;
    }
  }
  return 0;
}


```

---

## 作者：redegg (赞：1)

树状数组+二分+模拟。

二分找到编号x，树状数组修改编号，然后模拟即可。

至于树状数组不必多说，线段树也可以。

短小精干的代码：

```
#include <bits/stdc++.h>
using namespace std;

long long s;
int n,m;
long long a[800000];
int b[800000];
int sum[800000];
int maxn=0;

void update(int r,int f)
{
    while(r<=600000)
    {
        sum[r]+=f;
        r+=(r&(-r));
    }
}

int get(int l)
{
    int su=0;
    while(l>0)
    {
        su+=sum[l];
        l-=(l&(-l));
    }
    return su;
}

int erfen(int l,int r,int k)
{
    if(l==r)
    {
        return l;
    }
    int mid=(l+r)/2;
    if(get(mid)>=k)return erfen(l,mid,k);
    else return erfen(mid+1,r,k);
}

int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        scanf("%lld",&a[i]);
        s+=a[i];
        update(i,1);
        b[i]=1;
    }
    maxn=n;
    for(int i=1;i<=m;i++)
    {
        char c[10];
        scanf("%s",c+1);
        long long y;
        int x;
        if(c[1]=='C')
        {
            scanf("%d%lld",&x,&y);
            a[x]-=y;
            s-=y;
        }
        else if(c[1]=='I')
        {
            scanf("%d%lld",&x,&y);
            if(b[x]==0)
            {
                //cout<<x<<" "<<get(4)<<endl;
                update(x,1);
                b[x]=1;
            }
            s-=a[x];
            a[x]=y;
            s+=y;
            maxn=max(maxn,x);
        }
        else if(c[1]=='D')
        {
            scanf("%d",&x);
            int p=erfen(1,maxn,x);
            //cout<<p<<endl;
            update(p,-1);
            b[p]=0;
            s-=a[p];
            a[p]=0;
        }
        else
        {
            printf("%lld\n",s);
        }
    }

    return 0;
}

```

---

## 作者：abandentsky (赞：0)

题意：给你给出四种操作；
      （1）C x y将x点的值减去y
      （2）I x y在x点新建一个点，点的值为y
      （3）D x将区间里面第x个点（一定要注意是数量上的第x个，而不是坐标为x）删除
      （4）Q查询整个区间里面的和
思路：就是线段树嘛（标题也是线段树啊，zkw搞不来，就写的普通的线段树）。只说一下删除操作，绝对不是简单的将值该为0，这样就wrong了。所以我们需要另开一个量来表示区间被染色（就是有点）的个数。删除就把他减掉。
直接给出代码，为题解添一点不一样的代码：
```c
#include<bits/stdc++.h>
#pragma GCC optimize(2)
#define MAXN 500005
#define maxnode 50010
#define sigma_size 26
#define md 1000000007
#define INF 0x3f3f3f3f
using namespace std;
typedef long long LL;

struct node
{
    int l,r;
    LL num,sum;
}tr[MAXN<<2];
int cnt,a[MAXN],n,m;

void build(int id,int l,int r)
{
    tr[id].l=l,tr[id].r=r,tr[id].num=0,tr[id].sum=0;
    int mid=(l+r)>>1;
    if(l==r)
    {
        if(r<=n)
        {
            tr[id].num=1;
            tr[id].sum=a[++cnt];
        }
        return ;
    }
    build(id<<1,l,mid);
    build(id<<1|1,mid+1,r);
    tr[id].sum=tr[id<<1].sum+tr[id<<1|1].sum;
    tr[id].num=tr[id<<1].num+tr[id<<1|1].num;
}

void maintain(int id)
{
    tr[id].num=tr[id<<1].num+tr[id<<1|1].num;
    tr[id].sum=tr[id<<1].sum+tr[id<<1|1].sum;
}

void change(int id,int k)   //将区间中第k个点擦出掉
{
    if(tr[id].l==tr[id].r)      //修改叶子节点，让计数变量置为0；
    {
        tr[id].num=0;
        tr[id].sum=0;
        return ;
    }
    if(tr[id<<1].num>=k)
        change(id<<1,k);
    else
        change(id<<1|1,k-tr[id<<1].num);
    maintain(id);                              //重新计算节点信息
}

void update(int id,int kk,int val)    //对于单点进行加减操作
{
    if(tr[id].l==tr[id].r)
    {
        tr[id].sum+=val;
        tr[id].num=1;
        return ;
    }
    int mid=(tr[id].l+tr[id].r)>>1;
    if(kk<=mid)
        update(id<<1,kk,val);
    else
        update(id<<1|1,kk,val);
    maintain(id);                                   //重新计算节点信息
}

void add(int id,int pos,int val)
{
    if(tr[id].l==tr[id].r)
    {
        tr[id].num=1;
        tr[id].sum=val;
        return ;
    }
    int mid=(tr[id].l+tr[id].r)>>1;
    if(pos<=mid)
        add(id<<1,pos,val);
    else
        add(id<<1|1,pos,val);
    maintain(id);
}

int main()
{
    int xx,yy;
    char ch;
    scanf("%d %d",&n,&m);
    cnt=0;
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    build(1,1,500002);
    for(int i=1;i<=m;i++)
    {
        cin>>ch;
        if(ch=='Q')
        {
            printf("%lld\n",tr[1].sum);
        }
        else if(ch=='C')
        {
            scanf("%d %d",&xx,&yy);
            update(1,xx,(-1*yy));
        }
        else if(ch=='D')
        {
            scanf("%d",&xx);
            change(1,xx);
        }
        else if(ch=='I')
        {
            scanf("%d %d",&xx,&yy);
            add(1,xx,yy);
        }
    }
    return 0;
}

```


---

## 作者：rediserver (赞：0)

# P4879 ycz的妹子
[原题地址](https://www.luogu.org/problem/P4879)  
[Github题解](https://github.com/jerrykcode/luogu)

## 思路

使用数组a记录每个城市的女生的颜值，数组has记录每个城市是否有女生，若有则为TRUE(1)，没有则为FALSE(0)。
数组bit相当于是has的树状数组，提供两个操作:
* add(int x, int k)，在x位置增加k，那么add(x, 1)就表示原本x城市没有女生，现在有了；而add(x, -1)则表示原来有女生的城市x现在没有了。
* get_sum(int x)，返回[1, x]的和。get_sum(x)的实际意义就是[1, x]中有女生的城市的数量。

最大城市编号不超过500000，`#define maxcity 500000`，数组的大小都开maxcity + 1。用`sum`记录颜值和。

### 初始化:
* 输入时可确定a[1] ~ a[n]的值，此时sum即a[1] ~ a[n]之和。a[n + 1] ~ a[maxcity]为 0。  
* has[1] ~ has[n]为TRUE，has[n + 1] ~ has[maxcity]为FALSE。  
* bit初始全0，对于i属于[1, n]，对bit进行修改: add(i, 1)  

### C xy:   
更新sum和a[x]: `sum -= y;  a[x] -= y; `  
has和bit不变。

### I xy:
更新sum和a[x]:   
`sum += y - a[x];`  
`a[x] = y;`  
若has[x]为FALSE，即I操作之前x城市没有女生，则更新has[x]为TRUE，并且`add(x, 1)`

### D x:
首先需要找到第x个有女生的城市。  
二分 + 树状数组区间查询:  
从[1, maxcity]开始二分。对于二分的mid，若get_sum[mid] < x，则[1, mid]区间内的女生不够x个，则向右继续二分。若get_sum[mid] > x，则[1, mid]区间内的女生多于x个了，继续向左二分。
当get_sum[mid] == x时，[1, mid]区间内的女生正好有x个，注意此时若has[mid]为TRUE，即mid城市有女生，那么mid就是第x个有女生的城市。但若has[mid]为FALSE，
则第x个有女生的城市在mid之前，只是第x个有女生的城市到mid之间没有城市有女生，所以[1, mid]内仍然是x个女生。这种情况下也要向左二分。  
找到正确的mid之后更新sum和a[mid]: `sum -= a[mid]; a[mid] = 0;`，更新has[mid]为FALSE，并`add(mid, -1)`

### Q
输出sum即可。

## 代码

```c
#include "stdio.h"
#include "stdlib.h"

typedef unsigned char bool;
#ifndef TRUE
#define TRUE 1
#define FALSE 0
#endif

#define maxcity 500000

long long a[maxcity + 1];
int bit[maxcity + 1];
bool has[maxcity + 1];

int lowbit(int x) {
	return x & -x;
}

void add(int x, int k) {
	for (; x <= maxcity; x += lowbit(x)) {
		bit[x] += k;
	}
}

int get_sum(int x) {
	int result = 0;
	for (; x > 0; x -= lowbit(x)) {
		result += bit[x];
	}
	return result;
}

int main() {
	int n, m;
	scanf("%d %d", &n, &m);
	long long sum = 0;
	int i;
	for (i = 1; i < maxcity + 1; i++) bit[i] = 0;
	for (i = 1; i <= n; i++) {
		scanf("%lld", a + i);
		sum += a[i];
		add(i, 1);
		has[i] = TRUE;
	}
	for (; i < maxcity + 1; i++) {
		a[i] = 0;
		has[i] = FALSE;
	}
	char cmd;
	int x, y;
	for (i = 0; i < m; i++) {
		scanf(" %c", &cmd);
		switch (cmd) {
		case 'C': {
			scanf("%d %d", &x, &y);
			sum -= y;
			a[x] -= y;
			break;
		}
		case 'I': {
			scanf("%d %d", &x, &y);
			sum += y - a[x];
			a[x] = y;
			if (!has[x]) {
				has[x] = TRUE;
				add(x, 1);
			}
			break;
		}
		case 'D': {
			scanf("%d", &x);
			int left = 1, right = maxcity, mid, s;
			while (left <= right) {
				mid = (left + right) / 2;
				s = get_sum(mid);
				if (s == x) {
					if (has[mid]) {
						sum -= a[mid];
						a[mid] = 0;
						has[mid] = FALSE;
						add(mid, -1);
						break;
					}
					else {
						right = mid - 1;
					}
				}
				else if (s < x) {
					left = mid + 1;
				}
				else {
					right = mid - 1;
				}
			}
			break;
		}
		case 'Q': {
			printf("%lld\n", sum);
			break;
		}
		default:
			break;
		}
	}
	return 0;
}
```

---

## 作者：加勒比·史努比 (赞：0)

其实这就是一个需要稍加变化的线段树。

操作说明：

C 单点修改

I 同样是单点修改，但是需要一点变化

D 还是单点修改，也需要一点变化（tip:这里的x指的不是第x个城市，而是从前往后第x个，两者还是有区别的）

Q 区间查询，其实就是线段树里的节点一

# code #
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int maxn=2000001;
long long n,m;
struct note{
    long long l,r,w,cnt;   //l表左端点，r表右端点，w表颜值总和，cnt表妹子数（tip:这个cnt是很重要的）
}d[maxn];
long long a[maxn];   // tip:颜值的值一定要开longlong,包括上面的w;
char c;
int x,y;
void build(int k,int s,int t){   //建树
    d[k].l=s;
    d[k].r=t;
    if(s==t){
        d[k].w=a[s];
        if(a[s]>0) d[k].cnt=1;
        return ;
    }
    else{
        build(k*2,s,(s+t)/2);
        build(k*2+1,(s+t)/2+1,t);
        d[k].w=d[k*2].w+d[k*2+1].w;
        d[k].cnt=d[k*2].cnt+d[k*2+1].cnt;
    }
}
void sub(int k){   //普通的单点修改
    if(d[k].l==d[k].r){
        d[k].w-=y;
        return ;
    }
    int mid=(d[k].l+d[k].r)/2;
    if(x<=mid) sub(k*2);
    else sub(k*2+1);
    d[k].w=d[k*2].w+d[k*2+1].w;
}
void revise(int k){   //还是普通的单点修改
    if(d[k].l==d[k].r){
         d[k].w=y;
         d[k].cnt=1;   //cnt=1,这样的话不管之前这个城市有没有妹子，都可以正确表示
         return ;
    }
    int mid=(d[k].l+d[k].r)/2;
    if(x<=mid) revise(k*2);
    else revise(k*2+1);
    d[k].w=d[k*2].w+d[k*2+1].w;
    d[k].cnt=d[k*2].cnt+d[k*2+1].cnt;
}
void leave(int k){  //本题最难处理的部分
    if(d[k].l==d[k].r){
        d[k].w=0;
        d[k].cnt=0;
        return ;
    }
    if(x<=d[k*2].cnt) leave(k*2); //如果左子树的妹子数大于x,就向左子树寻找     
    else{   //如果左子树的妹子数小于x,就向右子树寻找（tip:为什么x还要减去左子树的妹子数呢？想一想）
        x-=d[k*2].cnt；
        leave(k*2+1)；
    }
    d[k].cnt=d[k*2].cnt+d[k*2+1].cnt;
    d[k].w=d[k*2].w+d[k*2+1].w;
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++) cin>>a[i];
    build(1,1,500000);
    for(int i=1;i<=m;i++){
        cin>>c;
        if(c=='C'){
            cin>>x>>y;
            sub(1);
        }
        else if(c=='I'){
            cin>>x>>y;
            revise(1);
        }
        else if(c=='D'){
            cin>>x;
            leave(1);
        }
        else if(c=='Q') cout<<d[1].w<<endl；
    }
    return 0;
}
```
~~自认为简洁的代码~~

---


# 神秘的703

## 题目背景

$Zero$ 和 $Mike$是一对热爱旅行的好朋友，一天在经历了$ZXG$大神的历练后，心力交瘁，于是决定**重阳节**回宾馆刷题，找回自信，于是，我们的故事开始了……

## 题目描述

**出题人：各位 $Oier$ 一定要细心啊啊啊！！！注意看说明**

**出题人：Chen_Xi.Naoh**

$Zero$ 所在宾馆的房间号是 $703$ ，而 $Mike$ 所在宾馆的房间好却是 $704$ ，所以当 $Zero$ 和 $Mike$ 想凑在一起刷题的时候，$Zero$ 需要从 $703$ 前往 $704$ 或者 $Mike$ 从 $704$ 前往 $703$ ，当 $Zero$ 和 $Mike$ 凑在一起时，$Mike$ 便会从[ $luogu$ ](https://www.luogu.org/)上随机选择 $n$ 道题，每一道题分值为 $300$ ，由于 $Mike$ 身经百战，所以每当 $Mike$ 看到某道题目的时候，大脑里面就会自动给该到题目定义一个难度值 $hard$ (要相信 $Mike$ 的判断都是正确的)，而 $Zero$ 和 $Mike$ 两个人都有一个共同的天赋值 $Talent$ ,每个人都只能解出 $Talent$ 范围内难度的题目，当然 $Zero$ 和 $Mike$ 的天赋值不会很低；

在 $Zero$ 的房间 $703$ 里面有一位热爱学习的小学弟 $BookCity$ ，在 $Zero$ 和 $Mike$ 刷题的同时，$BookCity$ 会在一旁研究两位学长的做题习惯，并给两位学长加油助威，由于 $BookCity$ 的加油，某道题目的难度就会自动下降一点点(**若 $hard - d \le 0$，则默认该题的 $hard$ 为 $1$ **)；然而，在宾馆的 
 $123$ 号房间住着一个拥有魔法但心地邪恶的人 $Guy$ ，能够看到Zero和Mike的动静，并且能够施展魔法(因为是在**重阳节**)，在 $Zero$ 和 $Mike$ 做到某一题的时候，直接将该题的难度暴增至 $s$ 倍！！！！！幸运的是，$Zero$ 和 $Mike$ 的老师 $tingtime$ 会帮助他们两个，在困境的时候为 $Zero$ 和 $Mike$ 指点迷津，将某一题的难度直接调为一个很低的值。

$Zero$ 和 $Mike$ 每刷完一道题能获得对应分值的自信值( $Zero$ 和 $Mike$ 都是追求完美的人，每一道题要么对，要么干脆不写)，现在，你就是 $Zero$ ，你想知道如果和 $Mike$ 从第 $a$ 到题刷到第 $b$ 到题能回复多少自信值 (**自信值计算方法：$600*AC$ 题目个数 $\Longrightarrow$ 一道题 $300$ 分，$2$ 个人一共恢复 $600$ 自信值**)$Confidence$。


## 说明/提示


保证所有题目初始的难度值 $hard$ 在 $ [0,2^{31}-1] $ 范围内；

保证 $Zero$ 和 $Mike$ 的天赋值 $Talent$ 在 $  [0,2^{31}-1] $ 范围内；

保证 $Zero$ 询问的范围都在 $ [0,2^{31}-1] $ 范围内，但不保证$x$一定会小于$y$

保证 $Guy$ 的翻倍都在 $ [0,2^{31}-1] $ 范围内；

保证 $BookCity$ 的减小值 $d$ 都在 $ [0,2^{31}-1] $ 范围内；

保证所有的输入数据都在 $  [0,2^{31}-1] $ 范围内；

$Mike$ 身经百战，所以其判断的 $hard$ 都在 $  [0,2^{31}-1] $ 范围内，且不存在难度为负数或者为 $0$ 的送分题；

保证 $n$ 和$m$ 都在 $  [0,2^{31}-1] $ 范围内；

对于 $30\%$ 的数据：$0\leqslant n \leqslant 5\times 10^3$,$m \leqslant 5\times 10^3$；

对于 $50\%$ 的数据：$0\leqslant n \leqslant 5\times 10^4$,$m \leqslant 5\times 10^4$；

对于 $100\%$ 的数据：$0\leqslant n\leqslant 5\times 10^5$，$m\leqslant 5\times 10^5$。


** 总之保证所有输入数据在$ [0,2^{31}-1] $范围内，但不保证运算在$ [0,2^{63}-1] $范围内！！**

## 样例 #1

### 输入

```
5 5
2 3 4 5 9
5 
BookCity 1 1
Guy 2 5
Zero 1 5
tingtime 5 1
Zero 1 5
```

### 输出

```
1800
2400```

# 题解

## 作者：杀马特飞行员 (赞：3)

这篇题解算是纪念第一次参加Luogu的比赛吧

题目思路很简单
~~但很**毒瘤**~~

线段树模板+高精度模板

代码如下

```#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;

const int maxn = 500005;

struct Bigint {
    int s[55]; 
    Bigint() {memset(s, 0, sizeof(s));}
    
    Bigint operator = (const Bigint& a) {
        s[0] = a.s[0];
        for (int i = 1; i <= a.s[0]; i++) s[i] = a.s[i];
        return *this;
    } 
};
 
const Bigint null;

//快读快写相关
inline int readint() {
    int x = 0;
    char c = getchar();
    while(!isdigit(c)) {c = getchar();}
    while(isdigit(c)) {
        x = x * 10 + c - '0';
        c = getchar();
    }
    return x;
}

int buf[10];
inline void putint(int x) {
	int p = 0;
	if (x == 0) p++;
	if (x < 0) { 
		putchar('-');
		x = -x;
	} 
	if (x != 0) 
		while(x) {
			buf[p++] = x % 10;
			x /= 10;
	}
	for(int j = p - 1; j >= 0; j--) putchar('0' + buf[j]);
} 

//高精度比较 
int cmp(Bigint a, Bigint b) {
    if (a.s[0] > b.s[0]) return 1;
    if (a.s[0] < b.s[0]) return 0;
    int i = a.s[0];
    while (i >= 1) {
        if (a.s[i] > b.s[i]) return 1;
        if (a.s[i] < b.s[i]) return 0;
        i--;
    }
    return 1;
} 

//高精度输入 
void read(Bigint& a) {
    char s1[50];  //string会非常慢
    scanf("%s", s1);
    a.s[0] = strlen(s1);
    for (int i = 1; i <= a.s[0]; i++) a.s[i] = s1[a.s[0] - i] - '0';
}

//高精度打印 
void print(Bigint& a) {
    for (int i = a.s[0]; i >= 1; i--) printf("%d", a.s[i]);
}

//高精度赋值 
void fuz(int num, Bigint& a) {
    int i = 1;
    while(num > 0) {
        a.s[i++] = num % 10;
        num /= 10;
    }
    a.s[0] = i - 1;
}

//加法 
Bigint add(Bigint b, Bigint a) {
    Bigint c;
    int len = 1;
    while(len <= b.s[0] || len <= a.s[0]) {
        c.s[len] += a.s[len] + b.s[len];
        c.s[len + 1] += c.s[len] / 10;
        c.s[len] %= 10;
        len++;
    }
    while(c.s[len] == 0 && len > 1) len--;
    c.s[0] = len;
    return c;
}

//减法
//调用前请确保a > b 
Bigint sub(Bigint a, Bigint b, int& tmp) {
    int d = cmp(a, b);
    if (d == 0) {
        tmp = 0;
        return null;
    }
    else {
        Bigint c;
        int len = 1;
        while (len <= a.s[0] || len <= b.s[0]) {
            if(a.s[len] - b.s[len] < 0) {
                a.s[len + 1] -= 1;
                a.s[len] += 10;
            }
            c.s[len] = a.s[len] - b.s[len];
            len++;
        }
        while(c.s[len] == 0 && len > 1) len--;
        c.s[0] = len;
        return c;
    }
}	

//乘法 
Bigint mul(Bigint a, Bigint b) {
    Bigint c;
    for (int i = 1; i <= a.s[0]; i++)
     	for (int j = 1; j <= b.s[0]; j++) c.s[i + j - 1] += a.s[i] * b.s[j];
    int len = a.s[0] + b.s[0];
    for (int i = 1; i < len; i++) {
        if (c.s[i] >= 10) {
            c.s[i + 1] += c.s[i] / 10;;
            c.s[i] %= 10;
        }
    }
    while (c.s[len] == 0 && len > 1) len--;
    c.s[0] = len;
    return c;
}

Bigint hard[maxn]; 
int sum[maxn * 4]; //1表示可以AC, 0则相反
Bigint tanlent;

//线段树相关
void build (int o, int L, int R) {
    if (L < R) {
        int lc = o << 1, rc = lc + 1, M = (L + R) >> 1;
        build(lc, L, M);
        build(rc, M + 1, R);
        sum[o] = sum[lc] + sum[rc];
    }
    else {
        if (cmp(tanlent, hard[L])) sum[o] = 1;
        else sum[o] = 0;
    }
}

void update(int o, int L, int R, int p1, Bigint tmp) {
    int lc = o << 1, rc = lc + 1, M = (L + R) >> 1;
    if (L == R) {
        hard[L] = tmp;
        if (sum[o] == 0 && cmp(tanlent, tmp) == 1) sum[o] = 1;
        else if (sum[o] == 1 && cmp(tanlent, tmp) == 0) sum[o] = 0;
    }
    else{
        if (p1 <= M) update(lc, L, M, p1, tmp);
            else update(rc, M + 1, R, p1, tmp);
        sum[o] = sum[lc] + sum[rc];
    }
}

int ans;
void query(int o, int L, int R, int p1, int p2) {
    if (L >= p1 && R <= p2) ans += sum[o];
    else {
        int lc = o << 1, rc = lc + 1, M = (L + R) >> 1;
        if (p1 <= M) query(lc, L, M, p1, p2);
        if (p2 > M) query(rc, M + 1, R, p1, p2);
    }
}

int main() {
    int n;
    n = readint();
    read(tanlent);
    for (int i = 1; i <= n; i++) read(hard[i]);
    build(1, 1, n);
    
    int m;
    m = readint();
    while(m--) {
        char command[10];
        scanf("%s", command);
        char c = command[0];
        if (c == 'B') {
            int x;
            Bigint y;
            x = readint();
            read(y);
            if (cmp(y, hard[x])) {
                Bigint one;
                fuz(1, one);
                update(1, 1, n, x, one);
            }
            else {
                int d;
                y = sub(hard[x], y, d);
                update(1, 1, n, x, y);
            }
        }
        if (c == 'G') {
            int x;
            Bigint y;
            x = readint();
            read(y);
            update(1, 1, n, x, mul(hard[x], y));
        } 
        if (c == 't') {
            int x;
            Bigint y;
            x = readint();
            read(y);
            update(1, 1, n, x, y);
        }
        if (c == 'Z') {
            int x, y;
            x = readint();
            y = readint();
            if (x > y) swap(x, y);//蜜汁swap
            ans = 0;
            query(1, 1, n, x, y);
            ans *= 600;
            putint(ans);
            putchar('\n');
        }
    }
    return 0;	
}```

---

## 作者：wcy1056935201 (赞：3)

## solution-p4969

## 题解 P4969 【神秘的703】

~~毒瘤题...~~

单点修改，区间查询，每次修改之后判断下是否能被做出来在返回去更新即可

树状数组维护一下

~~除了需要高精.....~~

具体可见巨丑代码

```
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#define ll long long
#define lb(x) (x&-x)
#define maxn 500005
using namespace std;
struct Bignum{
    #define Dignum 50
    int num[Dignum];
    #undef Dignum
}bnum[maxn];
Bignum One;
Bignum b_trans(char *p){
    int len=strlen(p);
    Bignum ans;
    memset(ans.num,0,sizeof(ans.num));
    ans.num[0]=len;
    for(int i=len-1;i>=0;--i){
        ans.num[len-i]=p[i]-'0';
    }
    return ans;
}
void b_output(Bignum x){
    for(int i=x.num[0];i;--i){
        printf("%c",x.num[i]+'0');
    }
    return;
}
int b_cmp(Bignum a,Bignum b){
    if(a.num[0]>b.num[0]) return 1;
    if(a.num[0]<b.num[0]) return -1;
    for(int i=a.num[0];i;--i){
        if(a.num[i]>b.num[i]) return 1;
        if(a.num[i]<b.num[i]) return -1;
    }
    return 0;
}
Bignum b_add(Bignum a,Bignum b){
    Bignum ans;
    memset(ans.num,0,sizeof(ans.num));
    ans.num[0]=max(a.num[0],b.num[0]);
    int add=0;
    for(int i=1;i<=ans.num[0];++i){
        ans.num[i]+=a.num[i]+b.num[i]+add;
        add=ans.num[i]/10;
        ans.num[i]%=10;
    }
    while(add){
        ++ans.num[0];
        ans.num[ans.num[0]]=add%10;
        add/=10;
    }
    return ans;
}
Bignum b_jian(Bignum a,Bignum b){
	if(b_cmp(a,b)<0){
		return One;
	}
    Bignum ans;
    memset(ans.num,0,sizeof(ans.num));
    if(!b_cmp(a,b)){
        ans.num[0]=1;
        ans.num[1]=0;
        return ans;
    }
    ans.num[0]=a.num[0];
    int add=1;
    for(int i=1;i<=ans.num[0];++i){
        ans.num[i]=10+a.num[i]-b.num[i]+add-1;
        add=ans.num[i]/10;
        ans.num[i]%=10;
    }
    while(!ans.num[ans.num[0]]){
        --ans.num[0];
    }
    return ans;
}
Bignum b_mut(Bignum a,Bignum b){
    Bignum ans;
    memset(ans.num,0,sizeof(ans.num));
    for(int i=1;i<=a.num[0];++i){
        for(int j=1;j<=b.num[0];++j){
            ans.num[i+j-1]+=a.num[i]*b.num[j];
        }
    }
    ans.num[0]=a.num[0]+b.num[0]-1;
    int add=0;
    for(int i=1;i<=ans.num[0];++i){
        ans.num[i]+=add;
        add=ans.num[i]/10;
        ans.num[i]%=10;
    }
    while(add){
        ++ans.num[0];
        ans.num[ans.num[0]]=add%10;
        add/=10;
    }
    while(!ans.num[ans.num[0]] && ans.num[0]>1){
        --ans.num[0];
    }
    return ans;
}
int n,m;
Bignum t;
int c[maxn],a[maxn];
void up(int x,int num){
	for(int i=x;i<=n;i+=lb(i)){
		c[i]+=num;
	}
	return;
}
int gs(int x){
	int ans=0;
	for(int i=x;i;i-=lb(i)){
		ans+=c[i];
	}
	return ans;
}
int gsum(int l,int r){
	return gs(r)-gs(l-1);
}
int main(){
	One.num[0]=1;
	One.num[1]=1;
	scanf("%d",&n);
	char q[30],p[30];
	scanf("%s",p);
	t=b_trans(p);
	memset(a,0,sizeof(a));
	memset(c,0,sizeof(c));
	for(int i=1;i<=n;++i){
		scanf("%s",p);
		bnum[i]=b_trans(p);
		if(b_cmp(t,bnum[i])>=0){
			up(i,1);
			a[i]=1;
		}
	}
	scanf("%d",&m);
	for(int i=1;i<=m;++i){
		scanf("%s",q);
		if(q[0]=='B'){
			int k;
			scanf("%d",&k);
			scanf("%s",p);
			Bignum x=b_trans(p);
			bnum[k]=b_jian(bnum[k],x);
			int kkk;
			if(b_cmp(t,bnum[k])>=0){
				kkk=1;
			}
			else{
				kkk=0;
			}
			up(k,kkk-a[k]);
			a[k]=kkk;
		}
		else if(q[0]=='G'){
			int k;
			scanf("%d",&k);
			scanf("%s",p);
			Bignum x=b_trans(p);
			bnum[k]=b_mut(bnum[k],x);
			int kkk;
			if(b_cmp(t,bnum[k])>=0){
				kkk=1;
			}
			else{
				kkk=0;
			}
			up(k,kkk-a[k]);
			a[k]=kkk;
		}
		else if(q[0]=='t'){
			int k;
			scanf("%d",&k);
			scanf("%s",p);
			bnum[k]=b_trans(p);
			int kkk;
			if(b_cmp(t,bnum[k])>=0){
				kkk=1;
			}
			else{
				kkk=0;
			}
			up(k,kkk-a[k]);
			a[k]=kkk;
		}
		else if(q[0]=='Z'){
			int x,y;
			scanf("%d %d",&x,&y);
			if(x>y) swap(x,y);
			printf("%d\n",gsum(x,y)*600);
		}
	}
	return 0;
}
```

---

## 作者：WNico (赞：2)

# [P4969 神秘的703](https://www.luogu.org/problemnew/show/P4969)

一道来自前辈的题目

推一下自己的[Blog](https://a-wnico-blog.blog.luogu.org/#)

当然啦顺手推一下现在的[BookCity/4526](127.0.0.1)(这是一个假的链接)

这个是之前用zkw写的。。（又是zkw）

除此之外就是和前辈一样的超出标记

总的来说就是这样


```cpp
// luogu-judger-enable-o2
#include<cstdio>
#include<iostream>
#include<cmath>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#define mx 500010
using namespace std;
typedef long long ll;
ll n,t,m,exa[mx],tmp;
ll tree[1048576];	
bool over[mx];	//超出标记

ll ans(int a,int b){
	if(a==b)  return -tree[a+n-1];
	ll bac=0;
	for(a+=n-1,b+=n-1;a^b^1;a>>=1,b>>=1){	//标准的求和
		if(a%2==0){
			bac+=tree[a^1];
		}
		if(b%2){
			bac+=tree[b^1];
		}
	}
	return bac;
}

void build(int i,int a){	//建树
	if(a>t) return;
	while(i) tree[i]++,i/=2;
}

void change(int i,int a){		//点变更
	while(i) tree[i]+=a,i/=2;
}

int main(){
	scanf("%lld%lld",&n,&t);ll p=n;n=pow(2,ceil(log2(n)));
	for(int i=1;i<=p;++i) cin>>exa[i];cin>>m;
	for(int i=n;i<n+p;++i) build(i,exa[i-n+1]);
	for(int ii=1;ii<=m;++ii){
		char ins[10];int a,b;
		scanf("%s%d%d",ins,&a,&b);
		switch(ins[0]){					//指令
			case 'B':{
				exa[a]=exa[a]-b<=0?1:exa[a]-b;
				if(exa[a]<=t&&tree[a+n-1]==0&&!over[a]) change(a+n-1,1);
				break;
			}case 'G':{
				exa[a]*=b;
				if(exa[a]<=0) over[a]=1;
				if((exa[a]>t||over[a])&&tree[a+n-1]) change(a+n-1,-1);
				
			}case 'Z':{
				if(a>b) swap(a,b);
				printf("%lld\n",(ans(a,b)+tree[a+n-1]+tree[b+n-1])*600);
				break;
			}case 't':{
				exa[a]=b;over[a]=0;
				if(b<=t&&tree[a+n-1]==0) change(a+n-1,1);
				if(b>t&&tree[a+n-1]) change(a+n-1,-1);
				break;
			}
			default:{
				printf("err\n");		//错误代码
				break;
			}
		}
	}
	return 0;
} 


```


---

## 作者：NightTide (赞：1)

## PART 0：前言
这是学长出的一道题目，非常的毒瘤。高精度 + 树状数组，而且还有几个非常搞人的操作。当时 `Tingtime` 老师（没错，就是我们的信奥老师）给我们放到了模拟考试里，直接就爆零了（这里的数据比我们 OJ 上的友好多了）。

本题解同步发表在我的[个人博客](https://www.luogu.com.cn/blog/Michaela-chr/)
## PART 1：解题思路
看到这一题有单点修改和区间查询，我们第一个想到的肯定是线段树或者树状数组实现。这一点是毋庸置疑的。但是我们看到题目中给出的数据范围：
```
输入数据在整型范围内
```

貌似是不用高精度的，但是如果你想想 `Guy` 的操作，是乘法对不对？两个整型范围内的数相乘，答案显然是存不下的。当然，你可以写高精度，这肯定是对的，但是会很麻烦（或许吧，不过我是这样觉得的）。但是有一种更简单的方法：超出标记。什么意思呢？由于其他人的操作都不可能使数据超出整型范围，所以我们可以对超出长整型的范围的数进行标记。由于超出了范围，所以除了 `Tingtime` 老师直接调整难度，其他人的操作都几乎不会有影响，同时这道题目 `Zero` 和 `Mike` 是肯定做不出的。所以，我们只要加一个标记，标记这道题的难度是否超过了长整型的范围，如果超过了，标记一下，直到 `Tingtime` 老师调整难度之后才将标记归零。而在其他操作的时候，判定一下标记，如果标记了，那么对其的操作就是无意义的。

有了这个操作，可以省去很多繁琐的操作。码长 - -，时间 - -。

### 细节
但是，这道题目还有一个小小的细节需要注意，这个问题很容易忽略。（我看学长的题解貌似没有写到？）

**谁说 `Tingtime` 老师只会调低难度了？**

所以，你不仅需要判断 `Tingtime` 老师调低难度的事件，还要判断他调高难度的事件。这可能是这题最坑的点了。

## PART 2: AC 代码
不说了，下面放上 AC 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
    long long val;
    bool flag;//标记是否越界
};
struct things{
    char opt[20];
    long long mark,val;
};
things th;
node hard[500010];
long long n,talent,m;
long long num;
long long sum[500010];
//树状数组基本操作
long long lowbit(long long x){
    return x&(-x);
}
void updata(long long i,long long x){
    while(i<=n){
        sum[i]+=x;
        i+=lowbit(i);
    }
}
long long get_sum(long long i){
    long long res=0;
    while(i>0){
        res+=sum[i];
        i-=lowbit(i);
    }
    return res;
}
int main(){
    // freopen("room.in","r",stdin);
    // freopen("room.ans","w",stdout);
    scanf("%lld%lld",&n,&talent);
    for(long long i=1;i<=n;i++){
        scanf("%lld",&hard[i].val);
        if(hard[i].val<=talent){
            updata(i,1);
        }
        hard[i].flag=false;
    }
    scanf("%lld",&m);
    while(m--){
        scanf("%s %lld %lld",th.opt,&th.mark,&th.val);
        if(th.opt[0]=='Z'){
            if(th.mark>th.val) swap(th.mark,th.val);
            printf("%lld\n",(long long)600*(get_sum(th.val)-get_sum(th.mark-1)));
        }else if(th.opt[0]=='t'){
            if((hard[th.mark].val>talent||hard[th.mark].flag)&&th.val<=talent) updata(th.mark,1);//调低难度
            else if((hard[th.mark].val<=talent&&hard[th.mark].flag==false)&&th.val>talent) updata(th.mark,-1);//调高难度，很坑，但很真实
            hard[th.mark].val=th.val;
            hard[th.mark].flag=false;
        }else if(th.opt[0]=='B'){
            //如果越界了再减是没有意义的，不可能减到范围内
            if(!hard[th.mark].flag){
                if(hard[th.mark].val>talent&&hard[th.mark].val-th.val<=talent){
                    updata(th.mark,1);
                }
                hard[th.mark].val-=th.val;
                if(hard[th.mark].val<1) hard[th.mark].val=1;
            }
        }else if(th.opt[0]=='G'){
            //越界了也没有必要再乘
            if(!hard[th.mark].flag){
                if(hard[th.mark].val<=talent&&(hard[th.mark].val*th.val>talent||hard[th.mark].val*th.val<0)){
                    updata(th.mark,-1);
                }
                hard[th.mark].val*=th.val;
                //标记
                if(hard[th.mark].val<=0){
                    hard[th.mark].flag=1;
                    hard[th.mark].val=-1;
                }
            }
        }
    }
    return 0;
}
```

---

## 作者：追梦_Chen (赞：1)

# 前言
这个~~坑比~~的是我出的【90度鞠躬】......
抱歉了各位，这题其实与hard值的绝对大小没有什么关系，看到各位爆零，我也很难过，但是我们可以不用管它呀，题目中已经说得很清楚了，Talent值在int范围内并且对于BookCity的操作也在int范围内，所以如果它溢出了longlong范围，就给它标记为1，在后面的统计当中不算进去就好了，当遇到Tingtime老师的操作时，因为该操作也在int范围内，所以此时的hard值又回到int范围内，重新标记为0，计入统计范围内就好了。就算您今天可能状态不佳，想不到较好的方法，但是我们还有暴力啊。
正解方法其实也不是我个人想出的，主要是教练教的好（TQL）
# 解题思路
## 首先我们来讲一讲这一题的易错点

①对于 $Zero$ 的询问，给出的区间 $x,y$ 不一定保证 $x<y$，当然对于细心的 $OIer$ 尤其是数据结构题刷的多的 $OIer$ 这一点还是很容易发现的。

②虽然在题目中反复强调某某某在 $int$ 范围内，但是各位小伙伴们有没有想过，对于 $Guy$ 的翻倍手段，
如果给某题的难度一直翻倍，完全有可能超范围，
由于出题者在造数据的时候是随机的，可能会几万几万甚至几十万几十万的翻倍，**所以到最后某一题的难度很可能超出 $long$ $long$ 甚至 $unsigned$ $long$ $long$ 范围**



## 这题其实不难，主要靠细节和心态
正如各位$OIer$所见，这题就是一个**树状数组**（线段树也可以）

我们要做的就是统计 $Zero$ 和 $Mike$ 能 $AC$ 的题目个数，**所以我们只要把所有难度小于 $talent$ 值的题目都标记为 $1$ ，查询的时候，只要统计区间内 $1$ 的个数**，然后再乘 $600$ 就可以了（每一题 $300$ 分，两个人，所以乘 $600$ ），

但是如果 $hard$ 值溢出了，程序就会自动默认为一个负数，负数的话就一定小于 $talent$ 值,一定会被统计为 $1$，
答案就会错误，怎么办呢？我们就可以标记一下，**对于溢出的数据标记为 $1$，并且
让程序对于所有标记为 $1$ 的都不计入统计范围内**，这样做就能 $AC$了。
# 代码实现

## 暴力30分代码

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <string>
#include <cmath>
#include <cstdlib>
#include <queue>
using namespace std;
const int maxn=500500;
int c[maxn],a[maxn],n,talent,m,x,y;
char opt[10];
int main(){
	scanf("%d %d",&n,&talent);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}	
	scanf("%d",&m);
	while(m--){
		scanf("%s %d %d",opt,&x,&y);
		if(opt[0]=='Z'){
			if(x>y)	swap(x,y);
			int cnt=0;
			for(int i=x;i<=y;i++){
				if(a[i]<=talent)	cnt++;
			}
			printf("%d\n",cnt*300*2);
		}else if(opt[0]=='t'){
			a[x]=y;
		}else if(opt[0]=='B'){
			a[x]=a[x]-y;
		}else if(opt[0]=='G'){
			a[x]=a[x]*y;
		}
	}
	
	return 0;
}

```

## 100分树状数组优化+标记

```

#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <string>
#include <cmath>
#include <cstdlib>
#include <queue>
using namespace std;
const int maxn=500500;
long long c[maxn],n;
struct node{
    bool f;  //用于标记 
    long long val;
}a[maxn];
void add(int x,int y){
    for(;x<=n;x += x&-x)	c[x]+=y;
}
int ask(int x){
    int ans=0;
    for(;x;x-=x&-x)	ans+=c[x];
    return ans;
}//树状数组维护1的个数 
long long talent,m;

int main(){
    scanf("%lld %lld",&n,&talent);
    for(int i=1;i<=n;i++){
        scanf("%lld",&a[i].val);
        if(a[i].val<=talent){
            add(i,1);
        }
        a[i].f=0;
    }	
    scanf("%lld",&m);
    long long x,y;
    char opt[10];
    while(m--){
        scanf("%s %lld %lld",opt,&x,&y);
        if(opt[0]=='Z'){
            if(x>y)	swap(x,y);
            printf("%d\n",600*(ask(y)-ask(x-1)));	 
        }else if(opt[0]=='t'){  
            if(a[x].val<=talent&&a[x].f==0) add(x,-1);
            if(y<=talent)	add(x,1);
            a[x].val=y;
            a[x].f=0;
        }else if(opt[0]=='B'){              //a[x].f=0，说明没有溢出，可以用于统计 
            if(a[x].f==0){
                if(a[x].val>talent&&a[x].val-y<=talent){
                    add(x,1);
                }
                a[x].val=max(a[x].val-y,(long long)1);
            }  
        }else if(opt[0]=='G'){
          	if(a[x].f==0){
          		
          		if(a[x].val<=talent&&(a[x].val*y>talent||a[x].val*y<0)){
          			add(x,-1);
          		}
          		a[x].val=a[x].val*y;
          		if(a[x].val<=0){
          			a[x].f=1;
                    a[x].val=-1;
          		}
          		
          	 }
        }
    }
    
    return 0;
```


---

## 作者：royzhu (赞：0)

emmmm...这题是真的毒瘤。

我做了一两周，才做出来。

思路是线段树。

一开始的打法效率太低，然后T了。
改成区间加后就Wa了。

最后发现漏判了。
前3个点太水了（坑）
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
struct lol{int l,r,ll,rr,ans;long long c;bool v;}a[1000010];
int len=0,f[500010];int n,t,m;

void pd(int now){a[now].c>t?a[now].ans=0:a[now].ans=1;}
void bt(int l,int r)//建树 
{
    len++;int now=len;
    a[len].l=l;a[len].r=r;a[len].ll=a[len].rr=a[len].c=a[len].v=0;
    if(l<r)
    {
        int mid=(l+r)/2;
        a[now].ll=len+1;bt(l,mid);
        a[now].rr=len+1;bt(mid+1,r);
        a[now].ans=a[a[now].ll].ans+a[a[now].rr].ans;
    }
    else a[len].c=(long long)f[l],pd(now);
}

void change(int now,int x,int k,int id)//改点 
{
    if(a[now].l==a[now].r&&id==1)//减 
    {
        if(!a[now].v)-k>=a[now].c?a[now].c=1:a[now].c+=k,pd(now);
        return;
    }
	else if(a[now].l==a[now].r&&id==2)//乘 
    {
    	if(!a[now].v)
    	{
    		a[now].c*=k;
	       	if(a[now].c<0)a[now].v=1,a[now].ans=0;else pd(now);
    	}//自然溢出 
        return;
    }
	else if(a[now].l==a[now].r&&id==3)//改 
    {
        a[now].c=k;a[now].v=0;pd(now);
        return;
    }
    int ll=a[now].ll,rr=a[now].rr,mid=(a[now].l+a[now].r)/2;
    if(x<=mid) change(ll,x,k,id);
    else change(rr,x,k,id);
    a[now].ans=a[ll].ans+a[rr].ans;
}

long long findsum(int now,int l,int r)//查询 
{
    if(a[now].l==l&&a[now].r==r) {return a[now].ans;}
    int ll=a[now].ll,rr=a[now].rr,mid=(a[now].l+a[now].r)/2;
    if(r<=mid) return findsum(ll,l,r);
    else if(l>mid) return findsum(rr,l,r);
    else return findsum(ll,l,mid)+findsum(rr,mid+1,r);
}

int main()
{
	scanf("%d %d",&n,&t);
	for(int i=1;i<=n;i++)scanf("%d",&f[i]);
	char s[100];len=0;bt(1,n);scanf("%d",&m);
	for(int i=1;i<=m;i++)
	{
		scanf("%s",s);int x,c;scanf("%d %d",&x,&c);
		if(s[0]=='B')change(1,x,-c,1);
		else if(s[0]=='G')change(1,x,c,2);
		else if(s[0]=='Z')
		{
			if(x>c){int y=x;x=c;c=y;}printf("%lld\n",600*findsum(1,x,c));
		}
		else change(1,x,c,3);
	}
	return 0;
}
```


---


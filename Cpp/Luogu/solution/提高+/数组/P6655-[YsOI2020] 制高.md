# [YsOI2020] 制高

## 题目背景

Ysuperman 特别喜欢玩战略游戏。

## 题目描述

游戏地图是一棵 $n$ 个点的有根树，根节点是 $1$ ，除节点 $1$ 外其他节点都有唯一的父亲节点。

每个节点有一个高度，第 $i$ 个节点的高度为 $h_i$ ，我们认为一个节点 $v$ 是“制高点”，当且仅当 $v$ 是根节点或者其父亲节点 $u$ 是“制高点”并且 $h_v\ge h_u$ 。

但是， Ysuperman 并不知道每个节点的父亲具体是哪个，只知道它的父亲编号可能在的区间，其中，节点 $i$ 的父亲可能在的编号范围为 $[l_i,r_i]$ ，保证 $1\le l_i\le r_i<i$ 。

现在， Ysuperman 想知道对于**所有可能的情况**，“制高点”的数量之和是多少。

因为这个结果可能会很大，所以你只需要输出结果 $\bmod \ {998244353}$ 的值即可。

## 说明/提示

样例一解释：

共有两种情况，情况一： $2$ 的父亲节点是 $1$ ， $3$ 的父亲节点是 $1$ ，此时 $1,2,3$ 均是“制高点”；情况二： $2$ 的父亲节点是 $1$ ， $3$ 的父亲节点是 $2$ ，由于 $h_2>h_3$ ，所以 $3$ 不是“制高点”，此时 $1,2$ 均是“制高点”。

所以所有情况“制高点”数量的和为 $5$ 。

| $\text{测试点编号}$ |   $n$    | $\prod_{i=2}^n(r_i-l_i+1)$ | $\text{特殊性质}$ |
| :-----------------: | :------: | :------------------------: | :---------------: |
|      $1\sim 2$      |  $=10$   |         $\le 10^6$         |    $\text{无}$    |
|         $3$         | $= 10^5$ |         $\le 10^6$         |    $\text{无}$    |
|         $4$         | $= 10^5$ |             \\             | $h_i\le h_{i+1}$  |
|         $5$         | $= 10^5$ |             \\             |   $h_i>h_{i+1}$   |
|     $6\sim 12$      | $= 10^3$ |             \\             |    $\text{无}$    |
|     $13\sim 20$     | $=10^5$  |             \\             |    $\text{无}$    |

题目数据保证 $h_i$ 在 `int` 能表示的最大范围内， $1\le l_i\le r_i<i$ 。

题目并不难。

## 样例 #1

### 输入

```
3
1 3 2
1 1
1 2
```

### 输出

```
5
```

## 样例 #2

### 输入

```
10
1 1 1 0 5 2 11 12 17 7
1 1
1 2
2 2
1 3
1 1
1 4
1 2
6 7
1 5
```

### 输出

```
4044
```

## 样例 #3

### 输入

```
50
1 0 0 6 2 5 0 2 16 15 14 8 20 22 23 21 7 24 27 17 1 13 39 40 31 38 40 16 25 48 2 0 15 7 0 47 58 11 22 54 11 78 30 32 31 35 44 56 59 85
1 1
2 2
1 2
2 3
3 3
1 6
2 6
3 5
5 9
3 4
1 4
3 12
1 12
5 7
5 13
1 10
7 9
4 11
12 12
16 17
3 9
8 15
15 16
1 19
9 10
10 12
8 10
4 10
6 13
10 13
11 30
11 21
2 30
13 23
4 24
32 34
8 29
4 22
2 26
29 33
28 38
18 31
19 36
15 32
8 14
15 32
4 33
30 45
8 25
```

### 输出

```
904672069
```

# 题解

## 作者：OMG_wc (赞：14)

总的方案数一共有 $S=\prod\limits_{i=2}^n r_i-l_i+1$，然后我们独立算每个结点的贡献。

根节点的贡献就是 $S$，而其他结点的贡献依赖于其父节点是否为制高点。

从每个点的期望考虑会比较简单，设 $f_i$ 为随机一种方案下 $i$ 是制高点的期望，那么最终答案就是 $\sum\limits_{i=1}^n f_i S$。

因为 $r_i<i$，显然可以 DP 计算期望：初始 $f_1=1$，转移方程为 $f_i=\sum\limits_{j=l_i}^{r_i} f_j[h_j\le h_i]\times \frac{1}{r_i-l_i+1}$。

现在问题变成了求 $[l,r]$ 区间内高度值小于等于 $h_i$ 的 $f_j$ 总和，$h_i$ 比较大先离散化。

可以离线解决，把所有询问按高度排序，然后一个个把 $f_i$ 值插入到树状数组里，求个区间和就是答案。

也可以利用主席树在线解决，直接求第 $r$ 个版本和第 $l-1$ 个版本的 $[1,h_i]$ 的区间和的差，在求出 $f_i$ 后插入到当前版本 $h_i$ 的位置。

代码如下：

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int INF = 0x3f3f3f3f;
const LL mod = 998244353;
const int N = 100005;

LL pow_mod(LL x, LL n) {
    LL res = 1;
    while (n) {
        if (n & 1) res = res * x % mod;
        x = x * x % mod;
        n >>= 1;
    }
    return res;
}
struct Node {
    int ls, rs, val;
} tr[N * 20];
int root[N], ck;
void update(int &u, int o, int l, int r, int x, int v) {
    u = ++ck;
    tr[u] = tr[o];
    tr[u].val = (tr[u].val + v) % mod;
    if (l == r) return;
    int mid = l + r >> 1;
    if (x <= mid)
        update(tr[u].ls, tr[o].ls, l, mid, x, v);
    else
        update(tr[u].rs, tr[o].rs, mid + 1, r, x, v);
}
LL query(int u, int o, int l, int r, int x, int y) {
    if (x <= l && r <= y) {
        return tr[u].val - tr[o].val;
    }
    int mid = l + r >> 1;
    LL res = 0;
    if (x <= mid) res += query(tr[u].ls, tr[o].ls, l, mid, x, y);
    if (y > mid) res += query(tr[u].rs, tr[o].rs, mid + 1, r, x, y);
    return res;
}
int a[N], b[N], l[N], r[N];

int main() {
    int n;
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) scanf("%d", &a[i]), b[i] = a[i];
    sort(b + 1, b + n + 1);
    LL sb = 1;
    for (int i = 2; i <= n; i++) {
        scanf("%d%d", &l[i], &r[i]);
        sb = sb * (r[i] - l[i] + 1) % mod;
    }
    LL ans = 0;
    for (int i = 1; i <= n; i++) {
        a[i] = lower_bound(b + 1, b + n + 1, a[i]) - b;
        LL now = i == 1 ? 1 : (query(root[r[i]], root[l[i] - 1], 1, n, 1, a[i]) % mod + mod) % mod * pow_mod(r[i] - l[i] + 1, mod - 2) % mod;
        update(root[i], root[i - 1], 1, n, a[i], now);
        ans += now * sb % mod;
    }
    ans %= mod;
    printf("%lld\n", ans);
    return 0;
}
```



---

## 作者：Fairicle (赞：6)

大概和前几天月赛 T3 挺像的...

在这里推荐一下月赛 T3 的[题解](https://www.luogu.com.cn/blog/Fairicle/ti-xie-p6834-cnoi2020-meng-yuan-post)

对于这题仍然考虑加入一个点会对结果有什么影响（仅对某一颗树而言，相当于求期望）

记它为 $i$，父亲是 $fa$ 则若 $h_{fa}>h_i$ 无贡献，若 $h_{fa}\le h_i$ 才会有贡献。

不妨令 $f_i$ 代表 $i$ 成为制高点的期望个数，则有 $f_i=\sum_{i=l_i}^{r_i}f_{fa}\times \frac{1}{r_i-l_i+1}$ 乘上 $\frac{1}{r_i-l_i+1}$ 自然是因为求期望。

由于题目求的是总方案数，所以最后的答案为 $\sum_{i=1}^n f_i \times \prod_{i=2}^n(r_i-l_i+1)$

维护的话还是离线做，开桶，然后从小到大枚举 $h$ 扔到 BIT 中统计即可。

code：
```cpp
#include"bits/stdc++.h"
using namespace std;
#define ll long long
#define ul unsigned long long
#define ui unsigned int
#define ri register int
#define pb push_back
#define mp make_pair
#define mod 998244353
char p[30]={'0','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'};
inline ll rd(){
	ll x=0,flag=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-') flag=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+(ch^48);ch=getchar();}
	return x*flag;
}
#define N 100010
ll n,h[N],l[N],r[N],c[N],b[N],pre[N],f[N];
ll inv[N];
ll ans;
vector<int>buc[N];
inline int lowbit(int x){return x & ( - x ) ;}
inline void init(){
	inv[0]=1,inv[1]=1;
	for(ri i=2;i<=n;++i) inv[i]=(mod-(mod/i))*inv[mod%i]%mod;
}
inline void add(int x,ll v){
	if(x<=0) return;
	for(ri i=x;i<=n;i+=lowbit(i)) c[i]+=v,c[i]%=mod; 
}
inline ll sum(int x){
	if(x<=0) return 0;
	ll ans=0;for(ri i=x;i>0;i-=lowbit(i)) ans+=c[i];
	return ans;
}
int main()
{
	std::ios::sync_with_stdio(false);
    cin>>n;init();
    for(ri i=1;i<=n;++i) cin>>h[i],b[i]=h[i];for(ri i=2;i<=n;++i) cin>>l[i]>>r[i];sort(b+1,b+1+n);
    int m=unique(b+1,b+1+n)-b-1;
    for(ri i=1;i<=n;++i){
    	int val=h[i];
    	h[i]=lower_bound(b+1,b+1+m,h[i])-b;
    	pre[i]=val;buc[h[i]].push_back(i);
	}
	//cout<<inv[2]<<endl;
	for(ri i=1;i<=m;++i){
		int siz=buc[i].size();
		for(ri j=0;j<siz;++j){
			if(buc[i][j]==1) {f[buc[i][j]]=1;add(buc[i][j],1);continue;}
			f[buc[i][j]]=(sum(r[buc[i][j]])-sum(l[buc[i][j]]-1)+mod)%mod;f[buc[i][j]]=f[buc[i][j]]*inv[r[buc[i][j]]-l[buc[i][j]]+1]%mod;
			add(buc[i][j],f[buc[i][j]]);
			//cout<<buc[i][j]<<" "<<f[buc[i][j]]<<endl;
		}
	}
	for(ri i=1;i<=n;++i) ans=ans+f[i],ans%=mod;
	for(ri i=2;i<=n;++i) ans=ans*(r[i]-l[i]+1)%mod;
	cout<<ans;
	return 0;
}

```


---

## 作者：wcy110614 (赞：1)

发现题解区没有树状数组题解，所以来发一篇。

关于转移方程，所有可能情况的和改成一次的期望 $E$ 乘上总方案数 $\prod _{i=2}^n (r_i-l_i+1)$。

然后设 $i$ 为制高点的概率为 $f_i$，则 $f_i=\dfrac{1}{r_i-l_i+1}\sum_{j=l_i}^{r_i}f_j[h_i>h_j]$。

发现这样做是 $O(n^2) $ 的，正常的树状数组又不能抵抗 $[l_i,r_i]$ 的限制，所以想到二维数点。

也就是离线，在计算好 $f_j$ 的时候倒过去推表 $f_i$，具体实现看代码。注意取模。

$h_i$ 太大了为了放进树状数组里需要离散化。

```cpp
#include <bits/stdc++.h>
#define ll long long
#define lb(p) (p&-p)
#define mp make_pair
#define fir first
#define sec second
#define pii pair<int,int>
using namespace std;
const int N=1e5+10;
const ll MOD=998244353;
int n,m,h[N],l[N],r[N],ar[N];
ll f[N];
inline ll qpow(ll a,int b=MOD-2){
	ll res=1;
	for(;b;){
		if(b&1)res=res*a%MOD;
		a=a*a%MOD, b>>=1;
	}
	return res;
}
struct FenwickTree{
	ll t[N];
	inline void add(int x,ll k){
		for(int p=x;p<=n;p+=lb(p))t[p]+=k,t[p]%=MOD;
	}
	inline ll qry(int W){
		ll Q=0;
		for(int p=W;p;p-=lb(p))Q+=t[p],Q%=MOD;
		return Q;
	}
}t;
vector<pii>vec[N];
int main(){
	cin>>n,f[1]=1;
	for(int i=1;i<=n;++i)cin>>h[i],ar[++m]=h[i];
	stable_sort(ar+1,ar+m+1);
	int len=unique(ar+1,ar+m+1)-ar;
	for(int i=1;i<=n;++i)h[i]=lower_bound(ar+1,ar+len+1,h[i])-ar;
	for(int i=2;i<=n;++i)cin>>l[i]>>r[i],vec[l[i]-1].emplace_back(mp(i,-1)),vec[r[i]].emplace_back(mp(i,1));
	for(int i=1;i<=n;++i){
		f[i]=f[i]*qpow(r[i]-l[i]+1)%MOD,t.add(h[i],f[i]);
		for(pii pr:vec[i])f[pr.fir]+=t.qry(h[pr.fir])*pr.sec,f[pr.fir]%=MOD;
	}
	ll S=1,ans=0;
	for(int i=2;i<=n;++i)S*=(r[i]-l[i]+1),S%=MOD;
	for(int i=1;i<=n;++i)ans+=f[i]*S%MOD,ans%=MOD;
	return cout<<(ans%MOD+MOD)%MOD<<"\n",0; 
}
```

---

## 作者：Eltaos_xingyu (赞：1)

不难发现这道题在**所有可能的情况**的前提下求数量之和是困难的，所以我们考虑在**该点是制高点**的前提下求可能的情况数。

假设说我们已经求出了前 $i-1$ 个点各自作为制高点时其可能的情况数，考虑转移。

设 $T(i)$ 为假设树只有前 $i$ 个点，第 $i$ 个点为制高点的方案数；再设 $f(i)$ 为第 $i$ 个点是制高点的前提下所有可能的情况数。不难发现对于 $[i+1,n]$ 的所有点，随意选择后的结果跟前 $i$ 个点的结构与制高点分布没有关系，所以有 $f(i)=T(i)\times w(i+1,n)$。其中 $w(l,r)$ 指区间 $[l,r]$ 的乱选的方案数，有 $w(x,y)=\prod_{i=x}^y (r_i-l_i+1)$。

根据题意，只要满足 $l_i\leq id\leq r_i$ 且 $h_{id}\leq h_i$ 两个条件的点都可以把 $i$ 点认作它的儿子。此时点 $id$ 对 $T(i)$ 的贡献就是 $T(id)\times w(id+1,i-1)$，因为当确定 $i$ 的父亲之后，剩下无关的点就可以全部乱选了。

因为有两个条件需要满足，不难想到用主席树维护这个贡献（也可以离线挂询问 + 树状数组做）。拆开 $id$ 对 $T(i)$ 的贡献：
$$
T(id)\times w(id+1,i-1)=w(1,i-1)\times(T(id)\times w(1,id)^{-1})
$$
维护后面那个括号内的内容即可。

```cpp
int n;
int fl[100005],fr[100005],pre[100005],ipre[100005];
int vh[100005],orgh[100005];
int T[100005];
int ksm(int a,int b){
	if(b==0)return 1;
	return (b&1?a:1)*ksm(a*a%mod,b/2)%mod;
}
int qpre(int l,int r){
	if(r<l)return 1;
	return pre[r]*ipre[l-1]%mod;
}
struct ele{
	int ls,rs,val;
}xds[4000006];
int rt[100005],tot;
#define mid ((l+r)>>1)
int mdf(int id,int l,int r,int q,int v){
	int now=++tot;
	xds[now]=xds[id];
	(xds[now].val+=v)%=mod;
	if(l==r)return now;
	if(q<=mid)xds[now].ls=mdf(xds[id].ls,l,mid,q,v);
	else xds[now].rs=mdf(xds[id].rs,mid+1,r,q,v);
	return now;
}
int qsum(int id,int l,int r,int sl,int sr){
	if(l==sl&&r==sr)return xds[id].val;
	int res=0;
	if(sl<=mid)res=(res+qsum(xds[id].ls,l,mid,sl,min(sr,mid)))%mod;
	if(sr>mid)res=(res+qsum(xds[id].rs,mid+1,r,max(sl,mid+1),sr))%mod;
	return res;
}
#undef mid
signed main(){
	ios::sync_with_stdio(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>vh[i];
		orgh[i]=vh[i];
	}
	sort(vh+1,vh+n+1);
	int vcnt=unique(vh+1,vh+n+1)-vh-1;
	for(int i=1;i<=n;i++){
		orgh[i]=lower_bound(vh+1,vh+vcnt+1,orgh[i])-vh;
	}
	for(int i=2;i<=n;i++)cin>>fl[i]>>fr[i];
	pre[1]=1;
	for(int i=2;i<=n;i++)pre[i]=pre[i-1]*(fr[i]-fl[i]+1)%mod;
	for(int i=1;i<=n;i++)ipre[i]=ksm(pre[i],mod-2);
	ipre[0]=1;
	rt[1]=mdf(rt[0],1,vcnt,orgh[1],1);
	T[1]=1;
	for(int i=2;i<=n;i++){
		T[i]=pre[i-1]*((qsum(rt[fr[i]],1,vcnt,1,orgh[i])-qsum(rt[fl[i]-1],1,vcnt,1,orgh[i])+mod)%mod)%mod;
		rt[i]=mdf(rt[i-1],1,vcnt,orgh[i],T[i]*ipre[i]%mod);
		// cout<<"T["<<i<<"]= "<<T[i]<<"\n";
	}
	int ans=0;
	for(int i=1;i<=n;i++){
		ans=(ans+T[i]*qpre(i+1,n)%mod)%mod;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Shunpower (赞：1)

随机跳题跳到了这题，居然自己做出来了感觉很牛。

------------

很容易想到对于每个点拆开算。考虑 $f_i$ 表示 $i$ 成为关键点的方案总数，$f_1$ 就是所有 $r-l+1$ 的乘积，然而你发现这样非常不好转移，因为某个点成为关键点的方案中不好控制其他点的形态，换句话说，方案中有些 $v$ 不是 $u$ 的儿子的情况，但是我们无法在 $f_v\gets f_u$ 的时候排除掉这些情况。

注意到每个点父亲等同于在区间内随机选取，并且总方案数很好算出来，那么我们可以想到经典的计数转期望，重新设 $f_i$ 表示点 $i$ 在所有方案中成为一个关键点的概率，这样我们就可以排除掉刚刚说的那些不合法情况了！转移也很显然：

$$
f_i\gets (r_i-l_i+1)^{-1}\times\sum\limits_{j\in[l_i,r_i]} f_j\times[h_j\leq h_i]\pmod {M}
$$

当然，因为状态设的是概率，所以最后需要给 $f_n$ 乘上 $\prod\limits_{i=1}^n (r_i-l_i+1)$，然后输出。初值显然是 $f_1=1$。

于是我们有了一个 $\mathcal O(n^2)$ 的做法。后面那一坨和式相当于是在下标区间、值域区间内求和，等同于二维数点，又因为 $r_i<i$ 所以我们可以直接从 $1$ 到 $n$ 依次转移，那么写一个主席树实现插入和区间求和即可。

当然，这题 $h$ 很大，需要进行离散化。

去掉主席树部分的代码：

```
int main(){
#ifdef Griffin
    freopen("hack.txt","r",stdin);
    freopen("out.txt","w",stdout);
#endif
    ios::sync_with_stdio(false);
    cin>>n;
    fr1(i,1,n){
        cin>>h[i];
        p[h[i]]=1;
    }
    for(auto &d:p){
        cnt++;
        d.se=cnt;
    }
    fr1(i,1,n){
        h[i]=p[h[i]];
    }
    fr1(i,2,n){
        cin>>seg[i].fi>>seg[i].se;
    }
    dp[1]=1;
    T.insert(rt[1],rt[0],1,n,h[1],1);
    fr1(i,2,n){
        dp[i]=(T.query(rt[seg[i].se],1,n,1,h[i])-T.query(rt[seg[i].fi-1],1,n,1,h[i])+M)%M;
        mul(dp[i],inv(seg[i].se-seg[i].fi+1));
        T.insert(rt[i],rt[i-1],1,n,h[i],dp[i]);
    }
    ll ans=0;
    ll len=1;
    fr1(i,2,n){
        mul(len,seg[i].se-seg[i].fi+1);
    }
    fr1(i,1,n){
        mul(dp[i],len);
        add(ans,dp[i]);
    }
    cout<<ans<<'\n';
    ET;
}
```

---

## 作者：ifffer_2137 (赞：0)

### 题意
$n$ 个节点，根为 $1$ 的有根树，点有点权 $h_i$。树的形态未知。

根是“制高点”。如果一个点的父亲为“制高点”且其权值大于等于父亲权值，则它也为“制高点”。

给定每个点可能的父亲编号区间 $[l_i,r_i]$，求所有可能情况的制高点数量之和，对 $998244353$ 取模。

### 分析
计数题常用技巧，数量转概率。

令 $dp_i$ 为第 $i$ 个点成为“制高点”的概率，顺序转移，则有方程：
$$dp_i=\frac{1}{r_i-l_i+1}\sum_{j=l_i}^{r_i}[h_i\geq h_j]dp_j$$
暴力转移 $O(n^2)$，考虑优化。离散化以后，主席树维护遍历到每个 $i$ 的权值数组即可。
### 代码

```cpp
//From: ifffer_2137
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define inf 0x7fffffff
#define eb emplace_back
#define pii pair<int,int>
#define mkpr make_pair
#define fir first
#define sec second
inline int read(){
    char ch=getchar();int x=0,w=1;
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+ch-48,ch=getchar();return w==1?x:-x;
}
const int maxn=1e5+5;
const int mod=998244353;
int pw(int a,int x){int s=1;while(x){if(x&1) s=s*a%mod; a=a*a%mod; x>>=1;} return s;}
int n,tot,ans;
int h[maxn],t[maxn];
int l[maxn],r[maxn];
int dp[maxn];
struct HJT_Segment_Tree{
	struct {int sm,ls,rs;}tr[maxn<<5];
	int rt[maxn],tot;
	void pushup(int o){tr[o].sm=(tr[tr[o].ls].sm+tr[tr[o].rs].sm)%mod;}
	void update(int &o,int p,int l,int r,int x,int k){
		o=++tot;tr[o]=tr[p];
		if(l==r){tr[o].sm=(tr[o].sm+k)%mod;return;}
		int m=(l+r)>>1;
		if(x<=m) update(tr[o].ls,tr[p].ls,l,m,x,k);
		else update(tr[o].rs,tr[p].rs,m+1,r,x,k);
		pushup(o);
	}
	int query(int o,int p,int l,int r,int x,int y){
		if(!o) return 0;
		if(x<=l&&r<=y) return (tr[o].sm-tr[p].sm+mod)%mod;
		int m=(l+r)>>1,res=0;
		if(x<=m) res=(res+query(tr[o].ls,tr[p].ls,l,m,x,y))%mod;
		if(y>m) res=(res+query(tr[o].rs,tr[p].rs,m+1,r,x,y))%mod;
		return res;
	}
}seg;
signed main(){
	#ifndef ONLINE_JUDGE
	freopen("data.in","r",stdin);
	freopen("test.out","w",stdout);
	#endif
	cin.tie(0),cout.tie(0);
	n=read();
	for(int i=1;i<=n;i++) t[i]=h[i]=read();
	sort(t+1,t+n+1);tot=unique(t+1,t+n+1)-t-1;
	for(int i=1;i<=n;i++) h[i]=lower_bound(t+1,t+tot+1,h[i])-t;
	for(int i=2;i<=n;i++) l[i]=read(),r[i]=read();
	ans=dp[1]=1;seg.update(seg.rt[1],seg.rt[0],1,tot,h[1],1);
	for(int i=2;i<=n;i++){
		dp[i]=seg.query(seg.rt[r[i]],seg.rt[l[i]-1],1,tot,1,h[i])*pw(r[i]-l[i]+1,mod-2)%mod;
		seg.update(seg.rt[i],seg.rt[i-1],1,tot,h[i],dp[i]);
		ans=(ans+dp[i])%mod;
	}
	for(int i=2;i<=n;i++) ans=ans*(r[i]-l[i]+1)%mod;
	cout<<(ans%mod+mod)%mod<<"\n";
	return 0;
}
```

---

## 作者：_fairytale_ (赞：0)

蒟蒻第一次知道数数题还可以转期望做，写个题解记一下。/bx/kt

首先总方案数是 
$$S=\prod_{i=1}^{n}(r_i-l_i+1)$$

考虑 $f[i]$ 表示在随机一种方案中 $i$ 号点作为关键点的期望，则答案为

$$\sum_{i=1}^{n}S\times f[i]$$

然后因为 $i$ 的父亲编号一定小于 $i$，所以在考虑到 $i$ 号点时 $f[fa[i]]$ 已经被计算好了，我们直接从小到大枚举 $i$，则

$$f[i]=\dfrac{1}{r_i-l_i+1}\sum_{j=l_i}^{r_i}[h_j\le h_i]f[j]$$

如果没有 $h_j\le h_i$ 就是简单的线段树问题，现在加了一条限制，主席树维护即可。

```cpp
#include<bits/stdc++.h>
#define re register
#define ll long long
#define il inline
#define mid (((ll)(l+r))>>1)
#define rep(x,a,b) for(re int (x)=(a);(x)<=(b);++(x))
using namespace std;
#define maxn 100100
#define mod 998244353
int n;
int h[maxn];
il int qp(int x,int y){
	int res=1;
	while(y){
		if(y&1)res=1ll*res*x%mod;
		x=1ll*x*x%mod;
		y>>=1;
	}
	return res;
}
il int inv(int x){
	return qp(x,mod-2);
}
int f[maxn];
int rt[maxn],tot;
struct tree{
	int ls,rs;
	int sum;
}t[maxn<<6];
void modify(int &p,int lsp,ll l,ll r,int pos,int v){
	if(!p)p=++tot;
	t[p].sum=(t[lsp].sum+v)%mod;
	if(l==r)return;
	if(mid>=pos)t[p].rs=t[lsp].rs,modify(t[p].ls,t[lsp].ls,l,mid,pos,v);
	else t[p].ls=t[lsp].ls,modify(t[p].rs,t[lsp].rs,mid+1,r,pos,v);
}
int query(int p,int lsp,ll l,ll r,int L,int R){
	if(L<=l&&r<=R)return ((t[p].sum-t[lsp].sum)%mod+mod)%mod;
	int res=0;
	if(mid>=L)res=(res+query(t[p].ls,t[lsp].ls,l,mid,L,R))%mod;
	if(mid<R)res=(res+query(t[p].rs,t[lsp].rs,mid+1,r,L,R))%mod;
	return res;
}
ll ans;
int l[maxn],r[maxn],S=1;
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
    cin>>n;
    rep(i,1,n)cin>>h[i];
	rep(i,2,n){
		cin>>l[i]>>r[i];
		S=1ll*S*(r[i]-l[i]+1)%mod;
	}
	f[1]=1;
	modify(rt[1],rt[0],0,INT_MAX,h[1],1);
	rep(i,2,n){
		f[i]=1ll*query(rt[r[i]],rt[l[i]-1],0,INT_MAX,0,h[i])*inv(r[i]-l[i]+1)%mod;
		modify(rt[i],rt[i-1],0,INT_MAX,h[i],f[i]);
	}
	rep(i,1,n)ans=(ans+1ll*f[i]*S%mod)%mod;
	cout<<ans;
	return 0;
}
```

---

## 作者：_Ch1F4N_ (赞：0)

直接计数其实不好记，不如计数转期望。

令 $f_i$ 表示点 $i$ 成为制高点概率，不难发现期望就是 $\sum f_i$。

根据定义对于 $f$ 我们有如下转移 $f_i = \frac{\sum_{j=l_i}^{r_i} f_j}{r_i-l_i+1}$ 又因为 $l_i \leq r_i < i$ 所以按照 $i$ 的顺序转移即可保证正确性，那么用主席树维护转移即可。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn = 2e5+114;
const int top = 100000000000;
const int mod = 998244353;
int n;
struct Node{
	int ls,rs,sum;
}tr[maxn*60];
#define ls(cur)(tr[cur].ls)
#define rs(cur)(tr[cur].rs)
int rt[maxn];
int tot;
void insert(int &cur,int lst,int lt,int rt,int pos,int v){
	if(pos<lt||pos>rt){
		cur=lst;
		return ;
	}
	if(cur==0) cur=++tot,tr[cur].sum=tr[lst].sum;
	tr[cur].sum+=v;
	tr[cur].sum%=mod;
	if(lt==rt) return ;
	int mid=(lt+rt)>>1;
	insert(tr[cur].ls,tr[lst].ls,lt,mid,pos,v);
	insert(tr[cur].rs,tr[lst].rs,mid+1,rt,pos,v);
} 
int query(int cur,int lt,int rt,int l,int r){
	if(lt>r||rt<l||cur==0) return 0;
	if(l<=lt&&rt<=r) return tr[cur].sum;
	int mid=(lt+rt)>>1;
	return query(ls(cur),lt,mid,l,r)+query(rs(cur),mid+1,rt,l,r)%mod;
}
int qpow(int a,int b){
	if(b==0) return 1;
	if(b==1) return a%mod;
	int res=qpow(a,b/2);
	res=res*res%mod;
	if(b%2==1) res=res*a%mod;
	return res;
}
int h[maxn],L[maxn],R[maxn],res=1,ans;
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>h[i],h[i]++;
	for(int i=2;i<=n;i++) cin>>L[i]>>R[i];
	res=res*1;
	ans+=1;
	insert(rt[1],rt[0],1,top,h[1],1);
	for(int i=2;i<=n;i++){
		int f=((query(rt[R[i]],1,top,1,h[i])-query(rt[L[i]-1],1,top,1,h[i])+mod)%mod)*qpow((R[i]-L[i]+1)%mod,mod-2)%mod;
		res=res*(R[i]-L[i]+1)%mod;
		ans=(ans+f)%mod;
		insert(rt[i],rt[i-1],1,top,h[i],f);
	}
	cout<<(ans*res)%mod;
}
```


---

## 作者：Otomachi_Una_ (赞：0)

## 题目简述

> - 定义一颗以 $1$ 为根的数当中的点 $u$ 是“好点”当且仅当以下两个条件任意满足其一
>   - $u=1$
>   - $v$ 为 $u$ 的父亲，$h_u\leq h_v$ 且 $v$ 为好点。
> - 每个节点 $i(2\leq i\leq n)$ 的父亲在 $[L_i,R_i]$ 间随机挑选，求所有情况好点数的和。
> - $n\leq 10^5$，$L_i\leq R_i\leq i$。

## 解题思路

假设 $f_i$ 为 $i$ 节点为“好点”的期望，那么不难发现
$$
f_i=\sum_{j=L_i}^{R_i}[h_j\geq h_i]\times f_j
$$
至此有了一个 $n^2$ 做法，但是还不够。不难把 $f_i$ 变成如下：
$$
f_i=\sum_{j=1}^{R_i}[h_j\geq h_i]\times f_j-\sum_{j=1}^{L_i-1}[h_j\geq h_i]\times f_j


$$
于是就变成了一个类似于前缀和的问题，但是有一个历史状态需要维护。于是我们可以先离散化 $h$ 再开一个线段树来维护每个 $h$ 数值出现对应 $p$ 的和。对于一个新求出来的 $f_i$ 我们要修改一个点值，所以我们可以使用可持久化线段树来维护，完结。

时间复杂度 $O(n\log n)$

## 参考代码

```cpp
#include<iostream>
#include<map>
#include<algorithm>
using namespace std;
#define ll long long
const int MOD=998244353;
const int MAXN=1e5+5;
struct node{
	int ls,rs,sum;
}a[MAXN<<5];
int rt[MAXN];
int cnt=0;
int n;int h[MAXN],g[MAXN];
int L[MAXN],R[MAXN];
int p[MAXN];
map<int,int> M;int tot=0;
ll ksm(ll a,int b){
	ll res=1;
	while(b){
		if(b&1) res=res*a%MOD;
		a=a*a%MOD;
		b=b>>1;
	}
	return res;
}
ll inv(int x){
	return ksm(x,MOD-2);
}
void build(int &id,int l,int r){
	id=++cnt;
	if(l==r) return;
	int mid=l+r>>1;
	build(a[id].ls,l,mid);
	build(a[id].rs,mid+1,r);
	return;
}
void ins(int &id,int copy,int l,int r,int x,int v){
	id=++cnt;
	a[id]=a[copy];
	if(l==r){a[id].sum=(a[id].sum+v)%MOD;return;}
	int mid=l+r>>1;
	if(mid>=x) ins(a[id].ls,a[id].ls,l,mid,x,v);
	else ins(a[id].rs,a[id].rs,mid+1,r,x,v);
	a[id].sum=(a[a[id].ls].sum+a[a[id].rs].sum)%MOD;
	return;
}
int query(int id,int l,int r,int L,int R){
	//cout<<l<<" "<<r<<endl;
	if(L<=l&&r<=R) return a[id].sum;
	int mid=l+r>>1;
	int ans=0;
	if(L<=mid) ans=(ans+query(a[id].ls,l,mid,L,R))%MOD;
	if(mid<R) ans=(ans+query(a[id].rs,mid+1,r,L,R))%MOD;
	return ans;
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>h[i];
		g[i]=h[i];
	}
	for(int i=2;i<=n;i++)
		cin>>L[i]>>R[i];
	sort(g+1,g+n+1);
	for(int i=1;i<=n;i++)
		if(!M[g[i]])
			M[g[i]]=++tot;
	for(int i=1;i<=n;i++)
		h[i]=M[h[i]];
	build(rt[0],1,tot);
	p[1]=1;
	for(int i=1;i<=n;i++){
		if(i!=1) p[i]=(query(rt[R[i]],1,tot,1,h[i])-query(rt[L[i]-1],1,tot,1,h[i])+MOD)*inv(R[i]-L[i]+1)%MOD;
		ins(rt[i],rt[i-1],1,tot,h[i],p[i]);
		//cout<<h[i]<<" "<<p[i]<<endl;
	}
	ll ans=0;
	for(int i=1;i<=n;i++)
		ans=(ans+p[i])%MOD;
	for(int i=1;i<=n;i++)
		ans=ans*(R[i]-L[i]+1)%MOD;
	cout<<ans;
	return 0;
} 
```

---


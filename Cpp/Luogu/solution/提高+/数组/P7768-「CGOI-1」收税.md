# 「CGOI-1」收税

## 题目背景

~~签到题~~

由于举办选丑大赛消耗了太多钱财，ac 决定派出 Push_Y 去收税。

## 题目描述

丑国由 $n$ 座城市组成，编号 $1$ 的为首都。这 $n$ 座城市由 $n-1$ 条长度为 $1$ 的双向道路连接。从编号为 $x$ 的城市出发，往**远离**首都的方向（即往儿子节点走），距离不超过 $h$ 的就是这座城市要收税的范围。

第 $i$ 座城市将要上缴 $a_i$ **元**的所得税。但由于收税官 Push_Y 很喜欢异或，因此每座城市最终上缴的所得税将是在其收税范围内每座城市**应缴税额**的异或和。

Push_Y 将向你提出 $m$ 个询问，他将问你城市 $x$ 在收税距离为 $h$ 时将收到多少**千元**的所得税。

**简化版题意：**

给定一棵 $n$ 个点的树，根节点为 $1$ 号点，第 $i$ 个点的点权为 $a_i$，$dep_u$ 表示 $u$ 点的深度，根节点的深度为 $1$，$q$ 次询问，每次给定两个整数 $x,h$，表示询问 $\bigoplus_{u\in son(x)\land dep_u-dep_x\le h}a_i$ 除以 $1000$ 后的值。

其中 $\bigoplus_{i=1}^ni$ 表示 $1\operatorname{xor} 2\operatorname{xor}\cdots\operatorname{xor} n$。

此处 $\land$ 是“且”，$\operatorname{xor}$ 是异或。

## 说明/提示

对于 $30\%$ 的数据，$1\le n,m\le 10^3$。

对于 $70\%$ 的数据，$1\le n,m\le5 \times 10^4$。其中有 $20\%$ 的数据是链。

对于 $100\%$ 的数据，$1\le n,m\le 10^6$，$1 \le a_i \le 10^9$，$1\le x \le n$，$0 \le h \le n$。

## 样例 #1

### 输入

```
6 3
604 545 402 378 25 13
1 2 2 3 3
1 2
3 0
2 4```

### 输出

```
0.149
0.402
0.733```

## 样例 #2

### 输入

```
6 3
6 5 4 3 2 1
1 2 2 3 3
1 2
3 0
2 4```

### 输出

```
0.004
0.004
0.001```

# 题解

## 作者：lenlen (赞：16)

初学主席树的人（例如我这个蒟蒻）可以来刷一下这个题，使用主席树的话还是考察了一定思维的，虽然加了快读后最后一个点 $993ms$ qwq。

### Problem

题目大意：给定一棵树，每个节点有一个权值，多次询问，每次询问一个节点 $x$ 的子树中深度小于等于 $h$ 的权值异或和。

数据范围：$n,q \leq 10^6,a_i \leq 10^9$。

### Solution

首先我们可以想到，因为要处理这种子树中的问题，多半是要用到 dfs 序把子树中的问题转换成区间中的问题。

同时我们可以发现，我们需要统计的是深度，所以我们可以开一个可持久化权值线段树（主席树）来维护同一个深度上的点的异或值。然后我们考虑对于每一个 dfs 序开一棵主席树，可以发现如果 $x$ 的子树的 dfs 序是 $[dfn_x,ed_x]$ 的话，由 $a\ xor\ a=0$ 可以得到，统计 $x$ 子树中所有深度小于等于 $h$ （以 $x$ 为根，所以也就等价于深度在 $[dep_x,dep_x+h]$ 之间）的异或和，也就是统计 $[1,dfn_x-1]$ 之间满足条件的异或和，再异或上 $[1,ed_x]$ 之间满足条件的异或和，有点类似于前缀和的原理，只不过是异或。

所以做法就很显然了，先处理出每一个点的 $dfn_i,ed_i,dep_i$，然后对于每一个 dfs 序开一棵主席树（注意这里是 dfs 序，而不是原本的序号）用来维护同一深度上的所有权值的异或值。查询的时候查找第 $ed_x,dfn_x-1$ 两个版本在区间 $dep_x,dep_x+h$ 之间的异或值，然后异或一下就可以得到答案了。

### Code

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+7232;
//真正的飞速快读，但让并不绝对，一般都挺快的，不过这个题没有普通快读快
const int Mt=1e5;
inline char getc()
{
	static char buf[Mt],*p1=buf,*p2=buf;
	return p1==p2&&(p2=(p1=buf)+fread(buf,1,Mt,stdin),p1==p2)?EOF:*p1++;
}
inline int read()
{
	int r=0,f=1;char c=getc();
	while(!isdigit(c)){if(c=='-')f=-1;c=getc();}
	while(isdigit(c))r=(r<<1)+(r<<3)+(c^48),c=getc();
	return r*f;
}
int n,m,x,y,maax;
int a[N];
//连边
int h[N],cnt;
struct hl{
    int v,nxt;
}e[N];
void add(int u,int v)
{
    e[++cnt].v=v,e[cnt].nxt=h[u],h[u]=cnt;
}
//dfs部分，预处理出dfn，ed，dep，re（re[i]代表dfs序为i的数在原来序列中的编号，下面会用到）
int num,dfn[N],ed[N],dep[N],re[N];
int mx(int x,int y){return x>y?x:y;}
int mi(int x,int y){return x<y?x:y;}
void dfs(int x,int fx)
{
    dfn[x]=++num;dep[x]=dep[fx]+1;re[num]=x;
    maax=mx(maax,dep[x]);
    for(int i=h[x];i;i=e[i].nxt) dfs(e[i].v,x);
    ed[x]=num;
}
//主席树
int root[N],tot;
struct len{
    int l,r,sum;
}t[N<<4];
int insert(int pre,int l,int r,int x,int y)
{
    int p=++tot;
    t[p].l=t[pre].l,t[p].r=t[pre].r,t[p].sum=(t[pre].sum^y);
    if(l<r)
    {
        int mid=l+r>>1;
        if(x<=mid) t[p].l=insert(t[pre].l,l,mid,x,y);
        else t[p].r=insert(t[pre].r,mid+1,r,x,y);
    }
    return p;
}
int ask(int u,int v,int l,int r,int x,int y)
{
    if(l==x&&r==y) return t[u].sum^t[v].sum;
    int mid=l+r>>1;
    if(x>mid) return ask(t[u].r,t[v].r,mid+1,r,x,y);//当整个区间都在右边时
    else if(y<=mid) return ask(t[u].l,t[v].l,l,mid,x,y);//当整个区间都在左边时
    else return ask(t[u].l,t[v].l,l,mid,x,mid)^ask(t[u].r,t[v].r,mid+1,r,mid+1,y);//区间两边都有分布
}
int main()
{
    n=read(),m=read();
    for(int i=1;i<=n;i++) a[i]=read();
    for(int i=2;i<=n;i++) x=read(),add(x,i);
    dfs(1,0);
    for(int i=1;i<=n;i++) root[i]=insert(root[i-1],1,maax,dep[re[i]],a[re[i]]);//每一次是根据dfs序建树，但是我们需要用到原序列中的dep，a值，所以要用到re数组
    for(int i=1;i<=m;i++)
    {
        x=read(),y=read();
        printf("%.3lf\n",0.001*ask(root[ed[x]],root[dfn[x]-1],1,maax,dep[x],mi(dep[x]+y,maax)));
        //                   两个版本异或一下，在ask函数中完成了    总区间    要查询的区间范围
    }
}
```


---

## 作者：light_searcher (赞：3)

题解区貌似并没有这种做法，这种做法可能常数略大，但是是比较好理解的。

首先，我们令 $s_x$ 为以 $x$ 为根的子树内所有节点的权值的异或和，要求答案只要把以 $x$ 为根的子树内所有深度超过 $dep_x+h$ 的点的权值异或掉就可以了，这等同异或上这颗子树内所有深度为 $dep_x+h+1$ 的点的 $s$ 值。

那么我们考虑怎么维护。可以对每一个深度分别维护区间异或值，对于每一次询问只需要在深度为 $dep_x+h+1$ 的那一层查询就可以了。还有一个问题是如何对于一棵子树，找出它在这一深度上的所有点。这就可以借助 $dfs$ 序，维护 $st_x$ 表示在搜索中 $x$ 这个点是第几个访问的，以及 $ed_x$ 表示 $x$ 的子树内 $st$ 的最大值。然后对于每一个深度，我们就可以维护一个长度为 $n$ 的序列。之后对于一个点 $x$，我们只把其所在的深度的 $st_x$ 位置设为 $s_x$。对于一棵根为 $y$ 的子树，查询的时候只要在对应的深度上查询 $st_y \sim ed_y$ 位置上的异或值即可，因为如果 $st_y \le st_x \le ed_y$，则说明 $x$ 是 $y$ 的子树内的一点，而其余的位置都是 $0$，并不影响答案。

如果直接用数组维护的话肯定会爆空间，我们可以对每一层都开一棵动态开点线段树，这样空间上也不会有问题，时间复杂度为 $\mathcal O(m \log n)$，卡卡常就过了。

[AC 记录](https://www.luogu.com.cn/record/175529911)

Code：

```cpp
#include<bits/stdc++.h>
#define il inline
#define rg register
using namespace std;
const int N=1e6+5,M=2e7+5,K=1e5;
int n,m,maxd,idx,h[N],nxt[N],to[N],a[N],dep[N],st[N],ed[N],tot,s[N],cnt,rt[N],sum[M],ls[M],rs[M];
int L,R,q,v;
il char getc(){
	static char buf[K],*p1=buf,*p2=buf;
	return p1==p2&&(p2=(p1=buf)+fread(buf,1,K,stdin),p1==p2)?EOF:*p1++;
}
il void add(int u,int v){
	nxt[++idx]=h[u];
	h[u]=idx;
	to[idx]=v;
}
il int read(){ 
	int f=1,x=0;
	char s=getc();
	while(s<'0'||s>'9'){
		if(s=='-') f=-1;
		s=getc();
	}
	while(s>='0'&&s<='9'){
		x=x*10+s-'0';
		s=getc();
	}
	return x*f;
}
il void dfs(int u){
	st[u]=++tot;
	s[u]=a[u];
	for(rg int i=h[u];i;i=nxt[i]){
		int v=to[i];
		dep[v]=dep[u]+1;
		dfs(v);
		s[u]^=s[v];
	}
	ed[u]=tot;
}
il void modify(int &x,int l,int r){
	if(!x) x=++cnt;
	if(l==r){
		sum[x]=v;
		return;
	}
	int mid=(l+r)/2;
	if(q<=mid) modify(ls[x],l,mid);
	else modify(rs[x],mid+1,r);
	sum[x]=sum[ls[x]]^sum[rs[x]];
}
il int query(int x,int l,int r){
	if(!x) return 0;
	if(l>=L&&r<=R) return sum[x];
	int mid=(l+r)/2,ret=0;
	if(L<=mid) ret^=query(ls[x],l,mid);
	if(R>mid) ret^=query(rs[x],mid+1,r);
	return ret;
}
int main(){
	n=read(),m=read();
	for(rg int i=1;i<=n;i++) a[i]=read();
	for(rg int i=1;i<n;i++) add(read(),i+1);
	dfs(1);
	for(rg int i=1;i<=n;i++) maxd=max(maxd,dep[i]);
	for(rg int i=1;i<=n;i++){
		q=st[i],v=s[i];
		modify(rt[dep[i]],1,n);
	}
	for(rg int x,h;m;m--){
		x=read(),h=read();
		L=st[x],R=ed[x];
		printf("%.3f\n",double(s[x]^((dep[x]+h+1)>maxd?0:query(rt[dep[x]+h+1],1,n)))/1000*1.0);
	}
	return 0;
}
```

---

## 作者：Tomle (赞：0)

本题存在 $O(n)$ 解法。

我们考虑设 $f_{u,i}$ 表示 $u$ 子树内深度为 $i$ 的点权异或值。

这个可以长剖优化 dp，容易做到 $O(n)$。

考虑到我们需要对 $f_u$ 做前缀异或，而前缀异或很难不带 $\log$ 去做，原因如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/qtme3vy3.png)

上图中，红色和黄色为一条长链，绿色为一条长链。绿色并到红色部分时，为了维护前缀异或，对黄色部分也需要更新，从而导致复杂度为 $O(n^2)$ 或 $O(n\log n)$。

既然如此，我们就维护**后缀异或**。

发现维护后缀异或也能解决本题，并且在上图中绿色只会更新红色。

转移很简单：

$$
f_{u,i}\gets f_{u,i}\operatorname{xor} f_{v,i}\\
f_{u,dep_u}\gets f_{v,dep_v}
$$

然后复杂度就是严格 $O(n)$，稍加卡常就是最优解第二。

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef unsigned us;
typedef pair <us, us> pii;
const us N = 1000005;

us n, m, a[N], x, u, v;
us d[N], md[N], ls[N];
us *f[N];
vector <us> T[N];
vector <pii> Q[N];
#define eb emplace_back
us ans[N];

namespace Mem {
    static us O[N * 5], *cur = O;
    us* $(us n) { auto R = cur; cur += n; return R; }
    us* $(us l, us r) { return $(r - l + 1) - l; }
} using Mem::$;

#ifdef ONLINE_JUDGE
char buf[1 << 23], *p1 = buf, *p2 = buf, Obuf[1 << 23], *p3 = Obuf;
#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread_unlocked(buf, 1, 1 << 23, stdin), p1 == p2) ? EOF : *p1++)
#define flush() (fwrite_unlocked(p3 = Obuf, 1, 1 << 23, stdout))
#define putchar(ch) (p3 == Obuf + (1 << 23) && flush(), *p3++ = (ch))
struct Flusher { ~Flusher() { fwrite_unlocked(Obuf, 1, p3 - Obuf, stdout); } } flusher;
#endif

inline us isd(us ch) { return ch >= '0' && ch <= '9'; }
inline void rd(us &a, us ch = 0) {
    while (!isd(ch = getchar()));
    for (a = 0; isd(ch); ch = getchar()) a = (a << 3) + (a << 1) + (ch ^ 48);
}
void wrt(us x) {
    if (x > 9) wrt(x / 10);
    putchar(x % 10 ^ 48);
}
void dfs1(us u, us fa) {
    md[u] = d[u] = d[fa] + 1;
    for (auto v : T[u]) {
        dfs1(v, u);
        md[v] > md[u] && (md[u] = md[v]);
        md[v] > md[ls[u]] && (ls[u] = v);
    }
}
void dfs2(us u) {
    ls[u] && (f[ls[u]] = f[u], dfs2(ls[u]), f[u][d[u]] = f[u][d[u] + 1]);
    f[u][d[u]] ^= a[u];
    for (auto v : T[u]) {
        if (v == ls[u]) continue;
        f[v] = $(d[v], md[v]),
        dfs2(v),
        f[u][d[u]] ^= f[v][d[v]];
        for (us i = d[v]; i <= md[v]; ++i) f[u][i] ^= f[v][i];
    }
    for (auto [dp, id] : Q[u])
        dp > md[u] && (dp = md[u]), 
        ans[id] = dp == md[u] ? f[u][d[u]] : f[u][d[u]] ^ f[u][dp + 1];
}
inline void out(us x) {
    wrt(x / 1000), putchar('.');
    x %= 1000;
    if (x < 1000) {
        if (x < 100) {
            putchar('0');
            if (x < 10) putchar('0'), wrt(x);
            else wrt(x);
        } else wrt(x);
    }
    putchar(10);
}
int main() {
    rd(n), rd(m);
    for (us i = 1; i <= n; ++i) rd(a[i]);
    for (us i = 2; i <= n; ++i) rd(x), T[x].eb(i);
    dfs1(1, 0);
    for (us i = 1; i <= m; ++i) rd(u), rd(x), Q[u].eb(d[u] + x, i);
    f[1] = $(1, md[1]),
    dfs2(1);
    for (us i = 1; i <= m; ++i) out(ans[i]);
}
```

---

## 作者：LEE114514 (赞：0)

## 思路

遇到这种树上若干个点子树内的问题，我们首先应该思考 dfs 作差或者 DSU on tree 这类算法。DSU 固然是可行的，但我们在这里使用更加简单的 dfs 作差。

所谓 dfs 作差，就是在 dfs 一个点之前先存储信息，在 dfs 完回溯时减去之前存储的信息以获取当前子树内信息。**注意，这要求这个信息是可差分的，比如和，异或和等**。

具体的，我们先读入所有的询问并下放对应的点上，然后在 dfs 过程中，对于在节点 $u$ 上的询问 $i$ 先把当前前 $dep_u+h_i$ 层的所有点异或和记录进答案，然后插入自己的权值并开始递归子树，再递归完之后再将答案异或上前 $dep_u+h_i$ 层的所有点的异或和。

为什么要用前 $dep_u+h_i$ 层的前缀异或和？它方便我们使用数据结构维护。为什么不用管第 $1$ 到第 $dep_u-1$ 层？因为在 dfs $u$ 节点时它子树内所有节点都不会影响前 $dep_u-1$ 层，又因为 $x \oplus x = 0$，所以前后都异或一次会自己抵消掉。

于是我们写出了如下的大常代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m;
const int maxn=1e6+5;
int a[maxn];
int trr[maxn];
void upd(int p,int x){
	while(p<=n) trr[p]^=x,p+=p&-p;
}
int qry(int p){
	int res=0;
	while(p) res^=trr[p],p^=p&-p;
	return res;
}
struct Edge{
	int to,Next;
}G[maxn];
int head[maxn],cnt;
void add(int u,int v){
	G[++cnt]=Edge{v,head[u]};
	head[u]=cnt;
}
vector<pair<int,int> > Q[maxn];
int ans[maxn];
int dep[maxn];
void dfs(int u,int fa){
	dep[u]=dep[fa]+1;
	for(auto iter:Q[u]) ans[iter.second]=qry(dep[u]+iter.first);
	upd(dep[u],a[u]);
	for(int i=head[u];i;i=G[i].Next) dfs(G[i].to,u);
	for(auto iter:Q[u]) ans[iter.second]^=qry(dep[u]+iter.first);
}
int u,v;
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i) scanf("%d",a+i);
	for(int i=2;i<=n;++i) scanf("%d",&u),add(u,i);
	for(int i=1;i<=m;++i) scanf("%d%d",&u,&v),Q[u].emplace_back(make_pair(v,i));
	n<<=1;
	dfs(1,0);
	for(int i=1;i<=m;++i) printf("%.3f\n",0.001*ans[i]);
}
```

然后你会得到两个大大的 TLE。

我们怎么优化呢？~~当然是优化复杂度啦~~。由于我不会 $O(n)$ 做法，于是我们考虑优化常数。

### STEP1 读入优化

曾今有个奆佬说过，输入上 $5 \times 10^5$，优化读入比优化算法更有用。于是考虑上个快读。

### STEP2 询问优化

刚才我们使用 `std::vector` 来将询问放到每个点上，但是即使吸氧也有不小的常数，于是我们用一个类似链式前向星的结构存储询问。

## AC Code

```cpp
#include <bits/stdc++.h>
using namespace std;
namespace IO{//by cyffff
	char ibuf[(1<<20)+1],*iS,*iT;
	#ifdef ONLINE_JUDGE
    #define gh() (iS==iT?iT=(iS=ibuf)+fread(ibuf,1,(1<<20)+1,stdin),(iS==iT?EOF:*iS++):*iS++)
	#endif
	#ifndef ONLINE_JUDGE
	#define gh() getchar()
	#endif
	inline int read(){
		char ch=gh();
		int x=0;
		while(ch<'0'||ch>'9') ch=gh();
		while(ch>='0'&&ch<='9') x=x*10+(ch^48),ch=gh();
		return x;
	}
}
using IO::read;
int n,m;
const int maxn=1e6+5;
int a[maxn];
int trr[maxn];
void upd(int p,int x){
	while(p<=n) trr[p]^=x,p+=p&-p;
}
int qry(int p){
	p=p>n?n:p;
	int res=0;
	while(p) res^=trr[p],p^=p&-p;
	return res;
}
struct Edge{
	int to,Next;
}G[maxn];
int head[maxn],cnt;
void add(int u,int v){
	G[++cnt]=Edge{v,head[u]};
	head[u]=cnt;
}
struct QRYS{
	int h,Next;
}Q[maxn];
int qhead[maxn],qcnt;
void qadd(int u,int h){
	Q[++qcnt]={h,qhead[u]};
	qhead[u]=qcnt;
}
int ans[maxn];
int dep[maxn];
void dfs(int u,int fa){
	dep[u]=dep[fa]+1;
	for(int i=qhead[u];i;i=Q[i].Next) ans[i]=qry(dep[u]+Q[i].h);
	upd(dep[u],a[u]);
	for(int i=head[u];i;i=G[i].Next) dfs(G[i].to,u);
	for(int i=qhead[u];i;i=Q[i].Next) ans[i]^=qry(dep[u]+Q[i].h);
}
int u,v;
int main(){
	n=read(),m=read();
	for(int i=1;i<=n;++i) a[i]=read();
	for(int i=2;i<=n;++i) add(read(),i);
	for(int i=1;i<=m;++i) u=read(),v=read(),qadd(u,v);
	dfs(1,0);
	for(int i=1;i<=m;++i) printf("%.3f\n",0.001*ans[i]);
}
```

---

## 作者：LYY_yyyy (赞：0)

dsu on tree。

预处理重儿子和深度，开一个数组记录每一个深度的异或和。把询问离线到每个点，处理询问时前缀异或和即可。每次处理答案的时候记录一下子树内最大深度，每次清空和前缀和时只要遍历自己的深度到子树内最大深度即可。不过这个题卡常有点困难，建议建单向边，使用链表存储。时间复杂度 $O(n \log n)$。

代码：

```cpp
#include<bits/stdc++.h>
#define getchar() (S==T&&(T=(S=fsr)+fread(fsr,1,1<<23,stdin),S==T)?EOF:*S++)
char fsr[1<<23],*S=fsr,*T=fsr;
using namespace std;
int son[1000010],head[1000010],a[1000010],si[1000010],depth[1000010],p[1000010],k[1000010],head1[1000010];
int ans[1000010];int mx;
int n,m,tot;
struct node
{
	int to,next;
}q[1000010];
struct nod
{
	int to,next,w;
}s[1000010];
inline void build(int u,int v,int w)
{
	s[++tot].to=v;
	s[tot].next=head1[u];
	s[tot].w=w;
	head1[u]=tot;
}
inline void build(int u,int v)
{
	q[++tot].to=v;
	q[tot].next=head[u];
	head[u]=tot;
}
void dfs1(int now)
{
	si[now]=1;
	for(int i=head[now];i;i=q[i].next)
	{
		int to=q[i].to;
		depth[to]=depth[now]+1;
		dfs1(to);si[now]+=si[to];
		if(si[to]>si[son[now]]) son[now]=to;
	}
}
inline void upd(int now)
{
	p[depth[now]]^=a[now];mx=max(mx,depth[now]);
	for(int i=head[now];i;i=q[i].next) upd(q[i].to);
}
inline void del(int now)
{
	for(int i=depth[now];i<=mx;i++) p[i]=0;mx=0;
}
inline int read()
{
	int x=0;char c=getchar();
	while(c>'9'||c<'0') c=getchar();
	while(c>='0'&&c<='9') x=x*10+c-'0',c=getchar();
	return x;
}
void dfs(int now)
{
	for(int i=head[now];i;i=q[i].next) if(q[i].to!=son[now]) dfs(q[i].to),del(q[i].to);
	if(son[now]) dfs(son[now]);
	p[depth[now]]^=a[now];mx=max(mx,depth[now]);
	for(int i=head[now];i;i=q[i].next) if(q[i].to!=son[now]) upd(q[i].to);k[depth[now]-1]=0;
	for(int i=depth[now];i<=mx;i++) k[i]=k[i-1]^p[i];
	for(int i=head1[now];i;i=s[i].next)
	{
		int to=depth[now]+s[i].to;
		ans[s[i].w]=k[min(to,mx)];
	}
}
int main()
{
	cin>>n>>m;for(int i=1;i<=n;i++) a[i]=read();
	int u;for(int i=2;i<=n;i++) u=read(),build(u,i);tot=0;
	for(int i=1;i<=m;i++)
	{
		int u,h;u=read(),h=read();
		build(u,h,i);
	}dfs1(1);dfs(1);
	for(int i=1;i<=m;i++) printf("%.3lf\n",0.001*ans[i]);
	return 0;
}
```

---

## 作者：☯☯枫☯☯ (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P7768?contestId=41194)

[更好的阅读体验](https://www.cnblogs.com/lbh2021/p/15110477.html)

## 题目大意

给定一颗以 $1$ 为根的带权树，对于每个询问 $\{x,h\}$，求子树 $x$ 前 $h$ 层节点权值的异或和。

## 算法分析：

其实这道题算法还是蛮多的 ~~（毕竟是签到题，当然要水水水水）~~。

这里介绍一种用**树状数组**的离线算法。

一些约定：

- 用 $dis_i$ 表示城市 $i$ 在树上的深度。 

事实上，在对整棵树进行深搜的同时，可以用一个全局的树状数组来实时维护整棵树前 $h$ 层的节点权值和。具体的，先预处理与 $x$ 有关的询问。利用**差分思想**，在处理 $x$ 的子树前，记录**未处理子树**时前 $dis_i+h$ 层异或和，并将点 $x$ 插入树状数组。在回溯时，针对关于 $x$ 的不同 $h$，用前 $dis_i+h$ 层新的异或和异或未处理时的异或和，就可以得到在 $x$ 的子树中的异或和。储存到对应下标即可。

时间复杂度为 $\mathcal{O}(n\log n)$，空间复杂度为 $\mathcal{O}(n)$。


## code:

```cpp
vector<int>f[N];
void dfs(int x,int fath) {
	dis[x]=dis[fath]+1;
	vector<ll>pos;
	for(reg int i=0; i<f[x].size(); ++i) {//记录未处理时的值 
		int k=f[x][i];
		pos.push_back(query(q[k].h+dis[x]));
	}
	insert(dis[x],val[x]);//插入x 
	for(reg int i=head[x]; i; i=net[i]) {
		int &y=ver[i];
		if(y==fath)continue;
		dfs(y,x);
	}
	for(reg int i=0; i<f[x].size(); ++i) {//“差分” 
		int k=f[x][i];
		ans[k]=query(q[k].h+dis[x])^pos[i];
	}
}
```

除了树状数组，本题还可以使用可持久化线段树，树套树等数据结构维护。

其实还有 $\mathcal{O}(n)$ 的做法，思路和上面的树状数组基本一致，即用桶替代树状数组，就不多讲了，下面给出代码。

```cpp
#include <bits/stdc++.h>
#define reg register
using namespace std;
const int M=1000005;
inline void Rd(int &x) {
	x=0;
	reg char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))x=(x<<3)+(x<<1)+(c^48),c=getchar();
}
int n,m;
int head[M],tot=0;
struct eg {
	int v,nxt;
} E[M];
struct qq {
	int k,id;
};
vector<qq>ask[M];
int w[M],sub[M],ans[M],sum[M*2];
void solve(int u,int d) {
	for(reg int j=0,sz=ask[u].size(); j<sz; ++j)
		ans[ask[u][j].id]^=sum[d+ask[u][j].k+1];
	sub[u]=w[u];
	for(reg int j=head[u]; j; j=E[j].nxt)
		solve(E[j].v,d+1),sub[u]^=sub[E[j].v];
	sum[d]^=sub[u];
	for(reg int j=0,sz=ask[u].size(); j<sz; ++j)
		ans[ask[u][j].id]^=sub[u]^sum[d+ask[u][j].k+1];
}
int main() {
	Rd(n),Rd(m);
	for(reg int i=1; i<=n; ++i)Rd(w[i]);
	for(reg int i=2,fa; i<=n; ++i) {
		Rd(fa);
		E[++tot]=(eg) {
			i,head[fa]
		};
		head[fa]=tot;
	}
	for(reg int i=1,u,k; i<=m; ++i) {
		Rd(u),Rd(k);
		ask[u].push_back((qq) {
			k,i
		});
	}
	solve(1,1);
	for(reg int i=1; i<=m; ++i) {
		printf("%.3f", ans[i]/1000.0);
		if(i<m) putchar(10);
	}
}
```

[std](https://www.luogu.com.cn/record/55360851)

第一次出公开赛，希望大家玩得开心~

---


# 「KDOI-02」一个弹的投

## 题目背景

- 前置芝士：[平抛运动](https://baike.baidu.com/item/%E5%B9%B3%E6%8A%9B%E8%BF%90%E5%8A%A8/974021?fr=aladdin)
~~（看到这个如果不想做可以直接开下一题）~~

「这群该死的外星人，肯定是来抢夺新矿资源的！」  
「这导弹什么鬼啊，研究不明白。」  
无数的水滴型武器从苍穹之外落下，猛击着无知的生命。  

## 题目描述

经研究，该武器的运作方式是这样的。其中设重力方向为 $y$ 轴负半轴，$x$ 轴为地面，速度向右为正向左为负。  
- 每颗导弹在 $(x_i,y_i)$ 的地方投放并悬浮，初始速度设置为 $v_i$。
- 所有导弹投放完成后，于同一时刻开始照初始速度做平抛运动。其中 $g=9.8$。  
- 每颗导弹与另一颗导弹碰撞时，不会改变原来的路线，并且将爆破威力 $p_i$ 增加 $1$，所有导弹初始时 $p_i=0$，**在接触到 $x$ 轴时碰撞也增加威力**。
- 当武器落到 $x$ 轴时，会对落点造成 $p_i$ 点杀伤力。

地面指挥部提前预测了导弹的落点，并部署了反制武器。第 $i$ 台武器能将第 $i$ 枚导弹在降落至地面后的威力值减少 $a_i$（至多减少到 $0$）。但是，由于技术限制，只能启动其中 $m$ 台反制武器。地面指挥官想知道，导弹造成的爆炸威力值总和最小为多少。

## 说明/提示

**【样例解释】**

- **样例 1 解释：** 

	每颗导弹的爆炸威力值都是 $0$。
- **样例 2 解释：** 

	四枚导弹的爆炸威力值分别是 $0,1,1,0$，启动第 $2$ 或第 $3$ 台反制武器，最后爆炸威力值的和为 $1$。
    
- **样例 4 说明：**

   该样例满足测试点 $13\sim16$ 的限制。
***
**【数据范围】**

对于 $100\%$ 的数据，$1\le n\le5\times10^5$，$0\le a_i,m\le n$，$0\le |x_i|,y_i\le10^9$，$0\le |v_i|\le10^6$。  

**保证所有导弹起始坐标不相等。**

|测试点编号|$n\le$|特殊性质|
|:-:|:-:|:-:|
|$1\sim6$|$5000$|无|
|$7\sim10$|$12000$|无|
|$11\sim12$|$10^5$|有|
|$13\sim16$|$10^5$|无|
|$17\sim20$|$5\times10^5$|无|

特殊性质：保证所有 $y_i$ 均相同。  

**【提示】**

本题 I/O 量较大，推荐使用较快的 I/O 方式。

附平抛运动落点公式：  
$$x_t=x_i+v_i\sqrt{\dfrac{2y_i}g}$$

## 样例 #1

### 输入

```
3 0
1 1 -2
1 2 -1
1 3 1
1 1 1```

### 输出

```
0```

## 样例 #2

### 输入

```
4 1
-3 3 0
1 3 1
4 3 -4
-9 3 -7
1 3 2 3```

### 输出

```
1```

## 样例 #3

### 输入

```
见附件中的 missile3.in```

### 输出

```
见附件中的 missile3.ans```

## 样例 #4

### 输入

```
见附件中的 missile4.in```

### 输出

```
见附件中的 missile4.ans```

# 题解

## 作者：Ray1 (赞：28)

~~其实除了提示中给的平抛运动落点公式本题和物理基本没关系~~

首先有一个结论，**只有 $y$ 坐标相同相同的导弹会相撞**。为什么呢？因为所有导弹都是从同一时刻开始降落，而重力是相同的，所以两颗初始 $y$ 坐标不同的导弹在任意一颗接触到 $x$ 轴前**相对高度始终不变**。也就是说，他们的 $y$ 坐标始终不同，自然就不会相撞。

那么，我们可以对每一个 $y$ 坐标上的导弹分别求解。设导弹的落点为 $d$，我们发现，对于两颗 $y$ 坐标相同的导弹 $i,j$，若 $x_i < x_j$，有且仅有在 $d_i\ge d_j$ 的情况会相撞，因为两颗导弹一定会有**交点**。那就非常简单了，我们只需要将每一个 $y$ 坐标的所有导弹，对 $x$ 坐标排序，然后每一个导弹分别针对落点 $d$ 求出有关的**逆序对**个数，也就是对每个 $i$ 求出满足 $x_i < x_j\land d_i\ge d_j\lor x_i < x_j\land d_i\le d_j\quad(y_i=y_j)$ 的 $j$ 的个数，就是他的威力了。

求出所有导弹的威力后，就是一个非常简单的贪心题了。设导弹的威力为 $v$，则启动第 $i$ 台反制武器可以减少 $f_i=\min(a_i,v_i)$ 爆炸威力值，取最大的 $m$ 个 $f_i$ 是最优的。用导弹爆炸威力的总和减去最大的 $m$ 个 $f_i$ 就是最小的导弹造成的爆炸威力值总和。时间复杂度 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=500001;
const double g=9.8;
int n,m,x,y,v,id,s,T[N],V[N],a,f[N];
long long sum;
double d[N];
map<int,int>mp;
map<int,int>::iterator it;
struct daodan{
	int id,x;
	double d;
};
bool cmp(daodan a,daodan b){
	return a.x>b.x;
}
bool Cmp(int a,int b){
	return a>b;
}
vector<daodan>t[N];
void add(int x){
	for(;x<=s;x+=x&-x)T[x]++;
}
int get(int x){
	int ans=0; 
	for(;x;x-=x&-x)ans+=T[x];
	return ans;
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>x>>y>>v;
		if(!mp[y])mp[y]=++id;
		t[mp[y]].push_back({i,x,x+v*sqrt(2*y/g)});//对于每一个 y 坐标上的导弹分别求解 
	}
	for(auto it:mp){
		x=it.second,sort(t[x].begin(),t[x].end(),cmp),s=t[x].size();
		for(int i=0;i<s;i++)d[i]=t[x][i].d;
		sort(d,d+s);//树状数组求逆序对，前后都要求一次 
		for(int i=1;i<=s;i++)T[i]=0; 
		for(int i=0;i<s;i++){
			t[x][i].d=upper_bound(d,d+s,t[x][i].d)-d;//离散化
			V[t[x][i].id]+=get(t[x][i].d);
			add(t[x][i].d);
		}
		for(int i=1;i<=s;i++)T[i]=0;
		for(int i=s-1;i>=0;i--){
			V[t[x][i].id]+=s-1-i-get(t[x][i].d-1);
			add(t[x][i].d);
		}
	}
	for(int i=1;i<=n;i++)cin>>a,sum+=V[i],f[i]=min(a,V[i]);//贪心部分 
	sort(f+1,f+1+n,Cmp);
	for(int i=1;i<=m;i++)sum-=f[i];
	cout<<sum;
}
```


---

## 作者：anonymous_person (赞：21)

### KDOI 官方题解  

我们不妨先考虑如果两个导弹会相撞，他们应该满足什么条件。

对于导弹 $i$，$j$ 满足 $x_i \leq x_j$

- 首先，他们的落点 $x_{ti}$，$x_{tj}$ 必须满足 $x_{ti} \geq x_{tj}$，这样他们的运动轨迹才有可能相交。  
- 其次，我们发现由于对任意一发导弹，有 $\Delta y = \frac{gt^2}{2}$，所以每一发导弹，在运动相同时间后，他的 $\Delta y$ 均相等，故如果这两个导弹会相撞，他们初始时必须满足 $y_i = y_j$。

那么，这一题的做法就显而易见了，我们只需要按 $y$ 值分组处理，每一组内部先按照初始的 $x$ 的值从小到大编号，再按照落点的 $x$ 的值排序，计算每一个导弹的编号的逆序对个数，即为这个导弹落地后的伤害值。  
知道伤害值之后，便可以知道拦截这一颗导弹带来的收益，选取收益最大的 $m$ 个拦截即可。

附代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int NUM=500005;
const double G=9.8;
int read()
{
    int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9')
    {
        if(c=='-') f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+c-'0',c=getchar();
    return x*f;
}
int n,m;
struct point
{
    int x,y,v,id,a,cost,w;
    double end;
}a[NUM];
int lowbit(int x)
{
    return x&(-x);
}
struct tree1
{
    int cnt[NUM];
    void Update(int x,int val)
    {
        while(x) cnt[x]+=val,x-=lowbit(x);
    }
    int Query(int x)
    {
        int result=0;
        while(x<=n) result+=cnt[x],x+=lowbit(x);
        return result;
    }
}T1;
struct tree2
{
    int cnt[NUM];
    void Update(int x,int val)
    {
        while(x<=n) cnt[x]+=val,x+=lowbit(x);
    }
    int Query(int x)
    {
        int result=0;
        while(x) result+=cnt[x],x-=lowbit(x);
        return result;
    }
}T2;//树状数组求逆序对
bool cmp(point x,point y)
{
    if(x.y==y.y) return x.x<y.x;
    return x.y<y.y;
}
bool cmp2(point x,point y)
{
    return x.end<y.end;
}
bool cmp3(point x,point y)
{
    return x.w>y.w;
}
void solve(int l,int r)//对每个y值分别处理
{
    double t=sqrt(2.0*a[l].y/G);
    for(int i=l;i<=r;i++) a[i].end=1.0*a[i].x+t*a[i].v;
    sort(a+l,a+r+1,cmp2);
    for(int i=l;i<=r;i++) a[i].cost+=T1.Query(a[i].id),T1.Update(a[i].id,1);
    for(int i=r;i>=l;i--) a[i].cost+=T2.Query(a[i].id),T2.Update(a[i].id,1);//求逆序对个数
    for(int i=l;i<=r;i++) T1.Update(a[i].id,-1),T2.Update(a[i].id,-1);
}
int main()
{
    int l=1;
    LL ans=0;
    n=read(),m=read();
    for(int i=1;i<=n;i++) a[i].x=read(),a[i].y=read(),a[i].v=read();
    for(int i=1;i<=n;i++) a[i].a=read();
    sort(a+1,a+n+1,cmp);
    for(int i=1;i<=n;i++) a[i].id=i;//按x值大小标序号
    for(int i=2;i<=n;i++) if(a[l].y!=a[i].y) solve(l,i-1),l=i;
    solve(l,n);
    for(int i=1;i<=n;i++) ans+=a[i].cost,a[i].w=a[i].cost-max(a[i].cost-a[i].a,0);
    sort(a+1,a+n+1,cmp3);
    for(int i=1;i<=m;i++) ans-=a[i].w;//贪心删除导弹
    printf("%lld",ans);
}
```


---

## 作者：Laffey (赞：17)

## 前言

&emsp;&emsp;看到都没人交题解，我就来一发吧。

&emsp;&emsp;蒟蒻考场上写这道题写了快三个小时，结果因为没开 long long 挂大分了（悲

## Solution

&emsp;&emsp;首先读题，很明显，我们只需要快速计算出每颗导弹落地的杀伤力，再由此计算出每颗导弹能被反制武器减少的杀伤力，从大到小选择就行了。所以这道题难点其实在于如何计算杀伤力。

&emsp;&emsp;我们首先考虑所有 $y_i$ 均相等，即所有导弹都在同一水平面上的情况。这样就转化成了线段求交的问题。设某个导弹的初始横坐标为 $x$，落地横坐标为 $x^{\prime}$，则很明显有当且仅当 $x_i < x_j$ 且 $x^{\prime}_i > x^{\prime}_j$ 时这两个导弹的轨迹会相交。画成图就是下面这样子。

![](https://cdn.luogu.com.cn/upload/image_hosting/wra6mj03.png)

&emsp;&emsp;所以我们只需要对于每个导弹 $i$ 找出所有导弹 $j$ 满足 $x_i < x_j$ 且 $x^{\prime}_i > x^{\prime}_j$ 或者反过来满足的计算入杀伤力。

&emsp;&emsp;那我们如何在 $\Theta(n \log n)$ 的复杂度内计算出碰撞数量呢？考虑对每个导弹统计答案，我们要做的是对于每个导弹，查询所有落点坐标小于它的导弹中，起始坐标大于它的数量。因此我们考虑将落点坐标排序，从小到大考虑每个导弹，用一个树状数组维护当前大于或小于某个坐标的导弹数量。对于每个导弹，我们先查询起始坐标大于它的导弹数，再将它的起始坐标插入树状数组中。这样就可以在题目规定的时间内求解了。不过为了能用树状数组维护信息，我们需要将横坐标离散化。另外还要注意我们还需要反过来再统计一遍。

&emsp;&emsp;考虑将这个解法推广到一般，根据平抛运动的性质，不在同一水平面上投放的导弹肯定不会相交，所以我们按照纵坐标排序，就可以对于每层纵坐标相同的导弹依次求解了。

## Code

&emsp;&emsp;本蒻解法略复杂些，需要排好几遍序，还需要初始化很多遍树状数组，复杂度常数略大。放在这里供大家参考。

&emsp;&emsp;代码是考场代码略加修改和精简的版本。

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
#include <cstring>
using namespace std;

typedef long long ll;

const int MAXN = 5e5 + 10;
const double g = 9.8;

int n, m;

struct bul_type {
    int x, y, v;
    double hit;
    ll power, delta;
    int index;
} bul[MAXN];

int a[MAXN];

struct BIT {
    ll c[MAXN];

    void init()
    {
        memset(c + 1, 0, sizeof(long long) * n);
    }

    void modify(int x)
    {
        while (x <= n) {
            c[x]++;
            x += x & -x;
        }
    }

    ll query(int x)
    {
        ll ans = 0;
        while (x) {
            ans += c[x];
            x -= x & -x;
        }
        return ans;
    }
} tr;

signed main()
{
#ifndef ONLINE_JUDGE
    freopen("in", "r", stdin);
    // freopen("out", "w", stdout);
#endif
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        cin >> bul[i].x >> bul[i].y >> bul[i].v;
        bul[i].hit = bul[i].x + sqrt(2 * bul[i].y / g) * bul[i].v;
        bul[i].index = i;
    }
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }

    sort(bul + 1, bul + n + 1, [](const bul_type &a, const bul_type &b)
    -> const bool {
        return a.x < b.x;
    });
    int top = 0;
    for (int i = 1; i <= n; i++) {
        top++;
        while (bul[i + 1].x == bul[i].x) {
            bul[i].x = top;
            i++;
        }
        bul[i].x = top;
    }

    sort(bul + 1, bul + n + 1, [](const bul_type &a, const bul_type &b)
    -> const bool {
        return a.y < b.y;
    });

    for (int l = 1, r = 1; l <= n; l = r) {
        while (bul[l].y == bul[r].y) r++;
        sort(&bul[l], &bul[r], [](const bul_type &a, const bul_type &b)
        -> const bool {
            return a.hit < b.hit;
        });
        tr.init();
        for (int i = r - 1; i >= l; i--) {
            int p = bul[i].x;
            bul[i].power = tr.query(p);
            tr.modify(p);
        }
        tr.init();
        for (int i = l; i < r; i++) {
            int p = bul[i].x;
            bul[i].power += tr.query(n) - tr.query(p);
            tr.modify(p);
            bul[i].delta = min(bul[i].power, (long long) a[bul[i].index]);
        }
    }

    sort(bul + 1, bul + n + 1, [](const bul_type &a, const bul_type &b)
    -> const bool {
        return a.delta > b.delta;
    });

    ll ans = 0;
    for (int i = 1; i <= m; i++) {
        ans += bul[i].power - bul[i].delta;
    }
    for (int i = m + 1; i <= n; i++) {
        ans += bul[i].power;
    }

    cout << ans << endl;

    return 0;
}
```

---

## 作者：_farawaystar_ (赞：10)

~~（其实好好读读题就能感觉出来其实初中的物理知识就足够了这题的难点不应该在物理）~~

大体思路就是先理清碰撞条件：

1. 两颗弹 $y$ 相同。

2.  $x$ 与落点交叉。

这样按照 $y$ 为第一关键字，按照 $x$ 为第二关键字排序，将排名记录为第一维。

再同样按照 $y$ 为第一关键字，按照落点为第二关键字排序，排名作为第二维。

就转换成了一道**二维偏序**题。

（补充：考中是改了数据的，其实如果按原来出题人的要求也是可做的。在第一次排序中加入 $v$ 为第三关键字，在第二次排序中加入 $x$ 为第三关键字即可。）

按 $y$ 为第一关键字，可以把 $y$ 不相同的导弹分离开，省去再用动态数组分离。

[二维偏序例题](https://www.luogu.com.cn/problem/P1908)

稍微的不同在于要求的是**每一个数据的逆序对数量**而非总数量。

考场写了线段树（目测题解里面还没有所以交一篇题解）

```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
#include<algorithm>
#define N 500005
#define exp 0.00000001
using namespace std;
int n,m,val[N],re[N],tr[N*10];
long long ans;
struct node{
    double x,y,v,pl;
    int fps,si,sum;
}a[N];
bool cmp(node x1,node x2){
    if(x1.y-x2.y<-exp)return 1;
    if(x1.y-x2.y>exp)return 0;
    return x1.x<x2.x;
}
bool cmp2(node x1,node x2){
    if(x1.y-x2.y<-exp)return 1;
    if(x1.y-x2.y>exp)return 0;
    return x1.pl<x2.pl;
}
void add(int l,int r,int x,int val){
    if(l==r){
        tr[x]++;
        return;
    }
    int mid=(l+r)>>1;
    if(val<=mid)add(l,mid,x*2,val);
    else add(mid+1,r,x*2+1,val);
    tr[x]=tr[x*2]+tr[x*2+1];
}
int ask1(int l,int r,int x,int val){
    if(l==r)return tr[x];
    int mid=(l+r)>>1;
    if(val<=mid)return ask1(l,mid,x*2,val)+tr[x*2+1];
    return ask1(mid+1,r,x*2+1,val);
}
int ask2(int l,int r,int x,int val){
    if(l==r)return tr[x];
    int mid=(l+r)>>1;
    if(val<=mid)return ask2(l,mid,x*2,val);
    return ask2(mid+1,r,x*2+1,val)+tr[x*2];
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        scanf("%lf%lf%lf",&a[i].x,&a[i].y,&a[i].v);
        a[i].si=i;
        a[i].pl=a[i].x+a[i].v*sqrt(2*a[i].y/9.8);
    }
    sort(a+1,a+n+1,cmp);
    for(int i=1;i<=n;i++)a[i].fps=i;
    sort(a+1,a+n+1,cmp2);
    for(int i=1;i<=n;i++){
        a[i].sum+=ask1(1,n,1,a[i].fps); 
        add(1,n,1,a[i].fps);
    }
    for(int i=1;i<=4*n;i++)tr[i]=0;
    for(int i=n;i>=1;i--){
        a[i].sum+=ask2(1,n,1,a[i].fps);
        add(1,n,1,a[i].fps);
    }
    for(int i=1;i<=n;i++)ans+=a[i].sum;
    for(int i=1;i<=n;i++)cin>>val[i];
    for(int i=1;i<=n;i++)val[a[i].si]=min(a[i].sum,val[a[i].si]);
    sort(val+1,val+n+1);
    for(int i=n;i>=n-m+1;i--)ans-=val[i];
    cout<<ans<<endl;
    return 0;
}
```

### 祝大家CSP rp++

---

## 作者：Dregen_Yor (赞：5)

### [更好的阅读体验。](http://dregen-yor.123ds.tk/index.php/2022/10/23/p8593/)

# 前置知识

两个做平抛运动的质点会碰撞当且仅当两个点初始高度相同，且起始位置与落地点大小相反，即：

若开始时 $x_i<x_j$，落地时 $x_i>x_j$，则第 $i$ 个球和第 $j$ 个球会发生碰撞。

# 思路

根据上述知识，我们考虑将每个炮弹根据 $y$ 的大小分开计算，用一个桶来存储所有 $y$ 的大小相同的炮弹，根据上面的前置知识，我们可以把问题转化为求**逆序对**的个数，但是，跑一遍逆序对的话只能求出一边和当前炮弹碰撞的炮弹，所以我们要正反分别遍历一遍数组，将每个点两次的答案相加就能求出每个炮弹的威力。

对于统计答案，根据贪心的思想，因为要让最后的威力之和最小，我们可以考虑按反制武器能减小的威力进行从大到小排序，令前 $m$ 个导弹用防制系统进行拦截，其他直接将导弹威力统计入答案中即可。

# 代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define ls x<<1
#define rs x<<1|1
using namespace std;
const double g=9.8;
struct node{
    double x,y,v;
}s[500010];
struct nod{
    int a,p;
}q[500010];
int n,m,a[500010],p[500010],ans;
bool cmp(int a,int b){
    return s[a].x<s[b].x;
}
bool cmp2(nod a,nod b){
    return min(a.p,a.a)>min(b.p,b.a);
}
double getdown(int x){
    return s[x].x+s[x].v*sqrt(2*s[x].y/g);
}
int sum[500010<<2];
void bulid(int x,int l,int r){
    if(l==r){
        sum[x]=0;
        return;
    }
    int mid=(l+r)>>1;
    bulid(ls,l,mid);
    bulid(rs,mid+1,r);
    sum[x]=sum[ls]+sum[rs];
}
void update(int x,int l,int r,int st){
    if(l==r&&st==l){
        sum[x]++;
        return;
    }
    int mid=(l+r)>>1;
    if(st<=mid){
        update(ls,l,mid,st);
    }
    else {
        update(rs,mid+1,r,st);
    }
    sum[x]=sum[ls]+sum[rs];
}
int query(int x,int l,int r,int L,int R){
    if(l>=L&&r<=R){
        return sum[x];
    }
    int res=0;
    int mid=(l+r)>>1;
    if(L<=mid){
        res+=query(ls,l,mid,L,R);
    }
    if(R>mid){
        res+=query(rs,mid+1,r,L,R);
    }
    return res;
}
map<double,vector<int> > mp;
void solve(vector<int> tmp){
    sort(tmp.begin(),tmp.end(),cmp);
    vector <double> d,id;
    for(int i=0;i<tmp.size();i++){
        d.push_back(getdown(tmp[i]));
        id.push_back(getdown(tmp[i]));
    }
    sort(id.begin(),id.end());
    id.erase(unique(id.begin(),id.end()),id.end());
    bulid(1,1,(int)id.size());
    for(int i=0;i<d.size();i++){
        int bh=lower_bound(id.begin(),id.end(),d[i])-id.begin()+1;
        p[tmp[i]]+=query(1,1,id.size(),bh,id.size());
        update(1,1,id.size(),bh);
    }
    bulid(1,1,(int)id.size());
    for(int i=d.size()-1;i>=0;--i){
        int bh=lower_bound(id.begin(),id.end(),d[i])-id.begin()+1;
        p[tmp[i]]+=query(1,1,id.size(),1,bh);
        update(1,1,id.size(),bh);
    }
}
signed main(){
    scanf("%lld%lld",&n,&m);
    for(int i=1;i<=n;i++){
        scanf("%lf%lf%lf",&s[i].x,&s[i].y,&s[i].v);
        mp[s[i].y].push_back(i);
    }
    for(int i=1;i<=n;i++){
        scanf("%lld",&a[i]);
    }
    for(map<double,vector<int> >::iterator it=mp.begin();it!=mp.end();it++){
        solve(it->second);
    }
    for(int i=1;i<=n;i++){
        q[i].a=a[i],q[i].p=p[i];
    }
    sort(q+1,q+1+n,cmp2);
    int sum=0;
    for(int i=1;i<=n;i++){
        if(m){
            sum+=max(0ll,q[i].p-q[i].a);
            m--;
        }
        else{
            sum+=q[i].p;
        }
    }
    cout<<sum;
    return 0;
}
```


---

## 作者：老官童鞋gogo (赞：5)

前往[我的博客](https://www.laoguantx.top/p8593-%e3%80%8ckdoi-02%e3%80%8d%e4%b8%80%e4%b8%aa%e5%bc%b9%e7%9a%84%e6%8a%95-%e9%a2%98%e8%a7%a3.html)获得更好的阅读体验！
# 心得

~~逃课打的这次模拟赛~~

考试过程中第一题很快就想出来了，不过写代码、调试细节足足用了将近两个小时。自己的代码能力还是太弱了。

第一题做完之后很激动，然后二三四题都不会了……

# 题解

## 模块一：读入

没有什么好说的，看代码吧。

```cpp
read(n,m); //使用快读
for(int i=1;i<=n;i++){
    read(mis[i].x,mis[i].y,mis[i].v); //mis[i]结构体数组用来记录编号为i的导弹信息
    mis[i].i=i; //导弹编号
    t=sqrt((2.0*mis[i].y)/9.8); //求运动时间（见公式推导)
    mis[i].to=(double)mis[i].x+(double)mis[i].v*t; //求最终落点（见公式推导）
}
```

## 模块二：探究两导弹相撞条件

如果你学过《人教版高中物理必修二》的抛体运动一章的话，可以跳过下面的公式推导。

已知物体做自由落体（初速度为 $0$ )的高度 $h$ 与时间 $t$ 、重力加速度 $g$ 的关系为：

$$h=\frac{1}{2}gt^2$$

因为所有导弹在同一时刻发射，并设第 $i$ 颗导弹的高度为 $y_i$ ，初速度为 $v_i$ ，那么可以根据公式得到导弹下落时间 $t_i$ ：

$$\begin{aligned} & y_i=\frac{1}{2}gt_i^2 \\ \Leftrightarrow & t_i=\sqrt{\frac{2y_i}{g}}\end{aligned}$$

由此得到水平方向上位移 $\Delta x_i$ ：

$$\begin{aligned} \Delta x_i & =v_it_i \\ & =v_i\sqrt{\frac{2y_i}{g}} \end{aligned}$$

再加上原来的横坐标就可以得到题目中所给的公式了。

根据推导公式的过程不难发现，在相同的时间内，所有导弹下落的高度是相同的，与水平初速度和质量没有任何关系。有的人可能认为它们下落的轨迹存在交点就会相撞，这是不对的，因为相撞需要满足两个条件：

1. 它们所在的位置为同一点。
2. 它们在**同一时间**到达同一点。

又因为所有的导弹同时开始降落，所以对于两个导弹，只有它们初始位置在同一高度上，它们才有可能相撞。

在做题的时候，我们只需要将所有导弹按照纵坐标排序，将纵坐标相同的导弹放在一起讨论是否会相撞即可。

```cpp
bool cmp1(Node1 x,Node1 y){
	if(x.y!=y.y)
		return x.y<y.y; //先排纵坐标
	else if(x.x==y.x)
		return x.to<y.to; //横坐标相同，将落点靠右的放在右边（见文末细节部分）
	else
		return x.x<y.x; //横坐标排序
}
sort(mis+1,mis+1+n,cmp1); //导弹按照纵坐标排序
for(int i=1;i<=n;i++){
    bot[++nxt].num=mis[i].i; //bot[]结构体数组中存储着纵坐标相同的导弹信息。
    bot[nxt].to=mis[i].to;
    if(mis[i].y!=mis[i+1].y){ 
        get_pair(1,nxt); //求解函数
        nxt=0;
        continue;
    }
}
```

## 模块三：判断两导弹是否会相撞

由平抛运动特点及推导公式可知，平抛运动中两个导弹水平运动方向是确定的，也就是说不会走着走着调个头，所以一枚导弹运动横坐标左右断点为初始横坐标和落地点的横坐标。

根据模块二，我们通过导弹的初始位置计算出了导弹的落点位置，假设导弹 $i$ 和 $j$ ，它们的初始位置满足关系 $x_i \le x_j$，并且落点位置满足 $to_i \ge to_j$ ，说明两个导弹在发射过程中相撞了。图示：

![平抛碰撞判定](https://laoguantx.top/article/solution-P8593/1.png)

所以计算每个导弹到达地面时的威力值就是计算满足上述关系的含有该导弹编号的有序数对 $(i,j)$ 有多少（你当然可以暴力枚举求解）。

是不是很像逆序对呢？

## 模块四：归并排序求导弹威力值

树状数组的求法不是不可以，不过这里我还是使用了归并排序。

前提是我们得到了该纵坐标下的所有导弹，并对其横坐标排序，要求是稳定排序，防止特殊情况发生（见细节部分）。利用求逆序对的思想，以导弹初始的横坐标顺序做编号，以落点位置横坐标作为值进行归并排序。将归并排序的框架写好，每当我们交换了一次顺序，说明这颗导弹发生了一次碰撞，具体实现看代码。

```cpp
void get_pair(int l,int r){ //按照落点
	int mid=(l+r)>>1;
	if(l>=r)	return;
	get_pair(l,mid);
	get_pair(mid+1,r); //递归求解
	int p1=l,p2=mid+1,p=l,cnt=0;
	while(p1<=mid&&p2<=r){
		if(bot[p1].to<bot[p2].to){
			f[bot[p1].num]+=cnt; //cnt作用见下，f[]数组用于记录导弹威力值
			temp[p++]=bot[p1++];
		}
		else{
			cnt++; //因为在归并排序中左半部分和右半部分分别都是有序的，右半部分的导弹与左半部分的一个导弹相撞，那么它会与相撞导弹的右边所有导弹都相撞，这里使用了cnt来维护后面导弹的相撞次数。
			f[bot[p2].num]+=mid-p1+1;
			temp[p++]=bot[p2++];
		}
	}
	while(p1<=mid){
		f[bot[p1].num]+=cnt;
		temp[p++]=bot[p1++];
	}
	while(p2<=r)
		temp[p++]=bot[p2++];
	for(int i=l;i<=r;i++){
		bot[i]=temp[i];
	}
	return;
}
```

## 模块五：整理答案

最后计算出使用每个反制武器最少可以减去多少威力值，并进行排序，贪心使用最大的 $m$ 个反制武器并计算最终答案即可。

```cpp
bool cmp2(Node1 x,Node1 y){
	return x.i<y.i;
}
bool cmp3(Node3 x,Node3 y){
	return x.num>y.num;
}
sort(mis+1,mis+1+n,cmp2); //整理导弹序号
for(int i=1;i<=n;i++){
    read(a[i]);
    if(a[i]>f[i]){ //计算使用第i个反制武器的价值
        val[i].num=f[i];
        val[i].i=i;
    }
    else{
        val[i].num=a[i];
        val[i].i=i;
    }
}
sort(val+1,val+1+n,cmp3); //对价值进行排序贪心
for(int i=1;i<=m;i++)
    vis[val[i].i]=1;
for(int i=1;i<=n;i++){
    if(vis[i]==1)
        if(a[i]>f[i])
            ans+=0;
    else
        ans+=f[i]-a[i];
    else
        ans+=f[i];
}
```

## 细节部分

1. 比赛过程中，管理员对本题进行的题意补充：**在接触到 $x$ 轴时碰撞也增加威力**（还有一句是**初始位置相同不算碰撞**，后来又删去了，这就是我为什么在排序的时候要把落点位置靠右的的点排序在右边，防止在抛出时判断为一次有效碰撞），所以在书写代码判断碰撞的时候要带上等于号。
2. 分析清楚归并排序时应该如何处理导弹威力值。
3. 搞清楚反制武器是怎么去贪心的
4. 排序前后编号一定要一一对应，灵活使用结构体。

# 完整代码

完整代码中包括各种加速，研究时可以忽略。

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace Fast{
#define uint unsigned int
#define ll long long
#define ull unsigned long long
#define int128 __int128
#define uint128 unsigned __int128
#define Ld long double
#define space putchar(' ')
#define enter putchar('\n')
#define PI acos(-1)
#define pb(x) push_back(x)
#define mp(a,b) make_pair(a,b)
#define fi first
#define se second
#define pr(x) cerr<<#x<<"="<<(x)<<"\n"
#define inf 1000000000
#define INF 1000000000000000000
#define N 1010
#define M 500010
	template<class T>inline bool read(T &x){
		x=0;char c=getchar();bool f=0;
		while(!isdigit(c)){if(c==EOF)return false;f^=c=='-',c=getchar();}
		while(isdigit(c))x=(x<<3)+(x<<1)+(c^48),c=getchar();
		if(f)x=-x;
		return true;
	}
	template<typename T>inline void print(T x){
		int s[65],top=0;
		if(x<0)putchar('-'),x=~x+1;
		while(x)s[++top]=x%10,x/=10;
		if(!top)s[++top]=0;
		while(top)putchar(s[top--]+'0');
	}
	template<class T>inline bool readd(T &x){
		ll X=0;double y=1.0;char c=getchar();bool f=0;
		while(!isdigit(c)){if(c==EOF)return false;f^=c=='-',c=getchar();}
		while(isdigit(c))X=(X<<3)+(X<<1)+(c^48),c=getchar();
		x=X;
		if(c!='.'&&c!='E'&&c!='e'){if(f)x=-x;return true;}
		if(c=='.'){c=getchar();while(isdigit(c))x+=(y/=10)*(c^48),c=getchar();}
		if(f)x=-x;
		X=0;f=0;
		if(c=='E'||c=='e'){
			c=getchar();
			while(!isdigit(c)){if(c==EOF)return true;f^=c=='-',c=getchar();}
			while(isdigit(c))X=(X<<3)+(X<<1)+(c^48),c=getchar();
		}
		if(f)for(ll i=1;i<=X;i++)x/=10;
		else for(ll i=1;i<=X;i++)x*=10;
		return true;
	}
	template<class T>inline void printd(T x,int y){
		static ll mul[]={1};
		for(ll i=1;i<=18;i++)
			mul[i]=(mul[i-1]<<3)+(mul[i-1]<<1);
		if(x<-1e-12)putchar('-'),x=-x;
		x*=mul[y];
		ll x1=(ll)round(x),x2=x1/mul[y],x3=x1-x2*mul[y];
		print(x2);
		if(y>0){
			putchar('.');
			for(ll i=1;i<y&&x3*mul[i]<mul[y];putchar('0'),i++);
			print(x3);
		}
	}
	template<class T>inline bool readc(T &x){
		char c=getchar();
		while(c==' '||c=='\n'||c=='\r'||c=='\t')c=getchar();
		if(c==EOF)return false;
		x=c;
		return true;
	}
	template<class T>inline void printc(T x){putchar(x);}
	template<class T>inline bool readcc(T *x){
		char c=getchar();
		while(c==' '||c=='\n'||c=='\r'||c=='\t')c=getchar();
		if(c==EOF)return false;
		while(c!=' '&&c!='\n'&&c!='\r'&&c!='\t'&&c!=EOF)*x++=c,c=getchar();
		*x=0;
		return true;
	}
	template<class T>inline void printcc(T *x){while(*x)putchar(*x++);}
	template<class T>inline bool reads(T &x){
		x="";char c=getchar();
		while(c==' '||c=='\n'||c=='\r'||c=='\t')c=getchar();
		if(c==EOF)return false;
		while(c!=' '&&c!='\n'&&c!='\r'&&c!='\t'&&c!=EOF)x+=c,c=getchar();
		return true;
	}
	template<class T>inline void prints(T x){for(ll i=0;x[i]!='\0';i++)putchar(x[i]);}
	template<class T,class ...S>inline bool read(T &x,S &...y){return read(x)&&read(y...);}
	template<class T,class ...S>inline bool readd(T &x,S &...y){return readd(x)&&readd(y...);}
	template<class T,class ...S>inline bool readc(T &x,S &...y){return readc(x)&&readc(y...);}
	template<class T,class ...S>inline bool readcc(T *x,S *...y){return readcc(x)&&readcc(y...);}
	template<class T,class ...S>inline bool reads(T &x,S &...y){return reads(x)&&reads(y...);}
	template<class T,class ...S>inline void print(T x,S ...y){print(x),putchar(' '),print(y...);}
	template<class T,class ...S>inline void printd(T x,S ...y){printd(x),putchar(' '),printd(y...);}
	template<class T,class ...S>inline void printc(T x,S ...y){printc(x),putchar(' '),printc(y...);}
	template<class T,class ...S>inline void printcc(T *x,S *...y){printcc(x),putchar('\n'),printcc(y...);}
	template<class T,class ...S>inline void prints(T x,S ...y){prints(x),putchar('\n'),prints(y...);}
	const double eps=1e-7;
	template<typename T>inline T Abs(T x){return x>0?x:-x;}
	template<typename T>inline T Max(T x,T y){return x>y?x:y;}
	template<typename T>inline T Min(T x,T y){return x<y?x:y;}
	template<typename T>inline T Fabs(T x){return x>eps?x:-x;}
	template<typename T>inline T Fmax(T x,T y){return x-y>eps?x:y;}
	template<typename T>inline T Fmin(T x,T y){return x-y<eps?x:y;}
}
using namespace Fast;
struct Node1{
	ll x,y,v,p,i;
	double to;
}mis[M];
struct Node2{
	ll num;
	double to;
}bot[M],temp[M];
struct Node3{
	ll i,num;
}val[M];
ll n,m,nxt;
ull ans,f[M],a[M];
bool vis[M];
double t;
bool cmp1(Node1 x,Node1 y){
	if(x.y!=y.y)
		return x.y<y.y;
	else if(x.x==y.x)
		return x.to<y.to;
	else
		return x.x<y.x;
}
bool cmp2(Node1 x,Node1 y){
	return x.i<y.i;
}
bool cmp3(Node3 x,Node3 y){
	return x.num>y.num;
}
void get_pair(int l,int r){
	int mid=(l+r)>>1;
	if(l>=r)	return;
	get_pair(l,mid);
	get_pair(mid+1,r);
	int p1=l,p2=mid+1,p=l,cnt=0;
	while(p1<=mid&&p2<=r){
		if(bot[p1].to<bot[p2].to){
			f[bot[p1].num]+=cnt;
			temp[p++]=bot[p1++];
		}
		else{
			cnt++;
			f[bot[p2].num]+=mid-p1+1;
			temp[p++]=bot[p2++];
		}
	}
	while(p1<=mid){
		f[bot[p1].num]+=cnt;
		temp[p++]=bot[p1++];
	}
	while(p2<=r)
		temp[p++]=bot[p2++];
	for(int i=l;i<=r;i++){
		bot[i]=temp[i];
	}
	return;
}
int main(){
//	freopen("missile4.in","r",stdin);
//	freopen("a.out","w",stdout);
	read(n,m);
	for(int i=1;i<=n;i++){
		read(mis[i].x,mis[i].y,mis[i].v);
		mis[i].i=i;
		t=sqrt((2.0*mis[i].y)/9.8);
		mis[i].to=(double)mis[i].x+(double)mis[i].v*t;
	}
	sort(mis+1,mis+1+n,cmp1);
	for(int i=1;i<=n;i++){
		bot[++nxt].num=mis[i].i;
		bot[nxt].to=mis[i].to;
		if(mis[i].y!=mis[i+1].y){
			get_pair(1,nxt);
			nxt=0;
			continue;
		}
	}
	sort(mis+1,mis+1+n,cmp2);
	for(int i=1;i<=n;i++){
		read(a[i]);
		if(a[i]>f[i]){
			val[i].num=f[i];
			val[i].i=i;
		}
		else{
			val[i].num=a[i];
			val[i].i=i;
		}
	}
	sort(val+1,val+1+n,cmp3);
	for(int i=1;i<=m;i++)
		vis[val[i].i]=1;
	for(int i=1;i<=n;i++){
		if(vis[i]==1)
			if(a[i]>f[i])
				ans+=0;
			else
				ans+=f[i]-a[i];
		else
			ans+=f[i];
	}
	print(ans);
	return 0;
}
```

有问题是难免的，请不要客气地在评论区指出。

---

## 作者：ningago (赞：4)

为与标量区别，本题解所有矢量刻意写作 $\overrightarrow{A}$。

物理量与预定义：$\overrightarrow{x}$ ：位移，$\overrightarrow{v}$：速度（方向恒向右），$\overrightarrow{p_i},\overrightarrow{q_i}$：输入的抛出坐标，也就是初始水平位移与竖直位移，$\overrightarrow{g}=9.8$：重力加速度（方向恒向下）。

正文：

首先，平抛运动是由：一个向右的匀速直线运动，和（匀加速的）自由落体运动合成的。

众所周知，两个小球 $i,j$ ，相撞，当且仅当，在某一时刻 $t$，有 $\overrightarrow{p_i}+\overrightarrow{q_i}+\overrightarrow{x_{i,t}}=\overrightarrow{p_j}+\overrightarrow{q_j}+\overrightarrow{x_{j,t}}$。其中 $\overrightarrow{x_{i,t}}$ 表示 $t$ 时刻内 $i$ 的位移。

把 $\overrightarrow{x_{i,t}}$ 也对于水平与竖直分解掉，$\overrightarrow{x_{i,t}}=t\cdot \overrightarrow{v_i}+\dfrac{1}{2}\cdot \overrightarrow{g}\cdot t^2$。

$$\overrightarrow{p_i}+\overrightarrow{q_i}+t\cdot \overrightarrow{v_i}+\dfrac{1}{2}\cdot \overrightarrow{g}\cdot t^2=\overrightarrow{p_j}+\overrightarrow{q_j}+t\cdot \overrightarrow{v_j}+\dfrac{1}{2}\cdot \overrightarrow{g}\cdot t^2$$

$$(\overrightarrow{p_i}+t\cdot \overrightarrow{v_i})+(\overrightarrow{q_i})=(\overrightarrow{p_j}+t\cdot \overrightarrow{v_j})+(\overrightarrow{q_j})$$

（括号内的方向相同）

显然，如果竖直位移相同，当且仅当 $\overrightarrow{q_i}=\overrightarrow{q_j}$。

而显然竖直与水平是垂直的，所以**如果抛出的 $y$ 坐标不一样，那么根本不可能相撞**。

（对于高中生来说这玩意应该就是一眼丁真罢……）

继续考虑水平方向：

$$\overrightarrow{p_i}+t\cdot \overrightarrow{v_i}=\overrightarrow{p_j}+t\cdot \overrightarrow{v_j}$$

$$\dfrac{\overrightarrow{p_i}-\overrightarrow{p_j}}{\overrightarrow{v_j}- \overrightarrow{v_i}}=t$$

注意到 $t\in [0,\sqrt{\dfrac{2y_i}{g}}]$。

（给初中生证一下：式子是落地时间 $\dfrac{1}{2}gt^2=y_i$）

下面默认 $\overrightarrow{v_j}> \overrightarrow{v_i}$，对统计没有影响。

$$\dfrac{\overrightarrow{p_i}-\overrightarrow{p_j}}{\overrightarrow{v_j}- \overrightarrow{v_i}}\geq 0$$

意思就是说水平抛出坐标与速度的相对大小同号，即**水平抛出坐标 $\overrightarrow{p_i}\geq\overrightarrow{p_j}$**。

$$\dfrac{\overrightarrow{p_i}-\overrightarrow{p_j}}{\overrightarrow{v_j}- \overrightarrow{v_i}}\leq \sqrt{\dfrac{2y_i}{g}}$$

$$\overrightarrow{p_i}+\sqrt{\dfrac{2y_i}{g}}\cdot \overrightarrow{v_i}\leq\overrightarrow{p_j}+\sqrt{\dfrac{2y_i}{g}}\cdot \overrightarrow{v_j}$$

$$\overrightarrow{x_{i\text{落}}}\leq \overrightarrow{x_{j\text{落}}}$$

也就是：$i,j$ 的水平抛出坐标与落地点为**偏序关系**。

第 $i$ 个点的威力值就是 $i$ 能与多少个 $j$ 形成上面的偏序。

最后贪心输出答案即可。


我懒得离散化，糊了个平衡树。

```cpp
#include <cstdio>
#include <map>
#include <cstring>
#include <vector>
#include <cmath>
#include <algorithm>
#include <iostream>

#define N 500010

std::map <int,int> mp;
int mpidx;
int n,m;
struct node
{
	int x;
	double y;
	int id;
	bool operator < (const node &B)const
	{
		return x < B.x;
	}
};
std::vector <node> v[N];

unsigned int sd = 233;

int rnd()
{
	sd ^= sd << 13;
	sd ^= sd >> 7;
	sd ^= sd << 11;
	return (int)sd;
}

int root,idx;
struct Tree
{
	int ls,rs;
	double val;
	int sz,key;
}tr[N];

#define lson(k) (tr[k].ls)
#define rson(k) (tr[k].rs)

void pushup(int k)
{
	tr[k].sz = tr[lson(k)].sz + tr[rson(k)].sz + 1;
}

int newnode(double val)
{
	tr[++idx].val = val;
	tr[idx].key = rnd();
	tr[idx].sz = 1;
	return idx;
}

void split(int k,double val,int &x,int &y)
{
	if(!k)
		x = y = 0;
	else
	{
		if(tr[k].val <= val)
		{
			x = k;
			split(rson(k),val,rson(k),y);
		}
		else
		{
			y = k;
			split(lson(k),val,x,lson(k));
		}
		pushup(k);
	}
}

int merge(int x,int y)
{
	if(!x || !y)
		return x | y;
	if(tr[x].key <= tr[y].key)
	{
		rson(x) = merge(rson(x),y);
		pushup(x);
		return x;
	}
	else
	{
		lson(y) = merge(x,lson(y));
		pushup(y);
		return y;
	}
}
int x,y,z;
void ins(double val)
{
	split(root,val,x,y);
	root = merge(merge(x,newnode(val)),y);
}

int sta[N];
int a[N];
int ans[N];

int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1,xx,yy,zz;i <= n;i++)
	{
		scanf("%d%d%d",&xx,&yy,&zz);
		if(!mp[yy])
			mp[yy] = ++mpidx;
		v[mp[yy]].push_back((node){xx,1.0 * xx + 1.0 * zz * sqrt(2.0 * yy / 9.8),i});
	}
	for(int i = 1;i <= n;i++)
		scanf("%d",&a[i]);
	for(int i = 1;i <= mpidx;i++)
	{
		int sz = v[i].size();
		std::sort(v[i].begin(),v[i].end());
		idx = 0;
		root = 0;
		for(int j = 0,xx,yy;j < sz;j++)
		{
			double nx = v[i][j].y;
			split(root,nx,xx,yy);
			ans[v[i][j].id] += tr[yy].sz;
			root = merge(xx,yy);
			ins(v[i][j].y);
		}
		for(int i = 1;i <= idx;i++)
			tr[i] = {0,0,0.0,0,0};
		idx = 0;
		root = 0;
		for(int j = sz - 1,xx,yy;j >= 0;j--)
		{
			double nx = v[i][j].y;
			split(root,nx,xx,yy);
			ans[v[i][j].id] += tr[xx].sz;
			root = merge(xx,yy);
			ins(v[i][j].y);
		}
		for(int i = 1;i <= idx;i++)
			tr[i] = {0,0,0.0,0,0};
	}
	long long res = 0ll;
	for(int i = 1;i <= n;i++)
	{
		res += ans[i];
		sta[i] = std::min(ans[i],a[i]);
	}
	std::sort(sta + 1,sta + 1 + n);
	for(int i = n - m + 1;i <= n;i++)
		res -= sta[i];
	printf("%lld\n",res);
	return 0;
}
```

---

## 作者：蒟蒻炒扇贝 (赞：4)

~~根据高中物理常用套路~~，平抛运动是可以被拆成两部分的：竖直方向上的自由落体和水平方向的匀速直线运动。

考虑一种理想情况，假如所有的导弹的横坐标均相等，仅仅是纵坐标不同，初速度为 $0$。这些导弹从同一时刻开始做自由落体运动，根据初速度为 $0$ 的位移-加速度公式 $\Delta x=\frac{1}{2}gt^2$，我们发现这些导弹是一定不会相遇的。

那我们可以得出一个结论：只有纵坐标全部相同的导弹们，才有可能发生碰撞。

接下来对于所有有相同高度的导弹，问题简化为每一个导弹在一条数轴上运动，第 $i$ 号导弹从 $x_i$ 移动到 $x_i+v\times t$，其中 $t=\sqrt{\frac{2y}{g}}$，问第 $i$ 号导弹能与多少导弹相撞。

我们设第 $i$ 号导弹的起点为 $l_i$（也就是题目中的 $x_i$），终点为 $r_i$，我们画图发现，两个导弹相撞分为两种情况：

情况一：对于所有 $l_i\le l_j$ 的导弹，$i$ 号导弹和 $j$ 号导弹相撞的条件便是 $r_j\le r_i$。

情况二：对于所有 $l_j\le l_i$ 的导弹，$i$ 号导弹和 $j$ 号导弹相撞的条件便是 $r_i\le r_j$。

对于每一种情况，我们可以用一种经典模型解决：二维偏序问题，可以利用值域树状数组求解。

如果不了解二维偏序问题是啥的话，你可以参考 逆序对 一题（最基础的二维偏序问题）：在这一道题的树状数组做法中，我们将整个数组离散化之后，在每次按照 $1$ 到 $n$ 的顺序将数组中的元素放入到一个桶里（这个桶我们用树状数组维护）（其实就是值域树状数组），每次的询问操作 ```sum(a[i])``` 就表示着在 $1$ 到 $i$ 的元素内，有多少个元素是小于等于 $a_i$ 的。

在逆序对这道题中，我们用指针 $j$ 遍历，采用边入桶边询问的方式，从而保证对于每次查询，已经进入桶的元素下标必定合乎我们所需满足的 $i\le j$ 条件（让合法的元素入桶），再利用树状数组查询桶的前缀和，查询出满足 $i\le j$ 且 $a_i\le a_j$ 的 $i$ 的个数，进而求得逆序对数。

我们可以总结出关于二维偏序问题的共用套路：对于求数列中有多少个元素小于等于 $x$ 的问题（或者其他不等关系），我们可以用树状数组开桶解决。如果在此基础上还有限制的话，我们就只让合法的元素入桶。

对于这一题而言，以第一种情况为例，我们有两层限制，一种是 $l_i\le l_j$，另一种是 $r_j\le r_i$，我们可以给 $r$ 从小到大排序，然后按照以 $r$ 升序的先后顺序入桶，这样假设我们遍历到了 $i$ 便能保证每一个入桶的元素都能满足小于等于 $r_i$ 的这一限制，至于剩下的条件，直接交给树状数组处理即可。对于第二种情况也类似，~~请读者自行推导。~~

由于 $l_i$ 值域较大，考虑离散化，把值域缩小到 $\mathop{O(n)}$ 级别。

之后对于我们求得的 $p$ 数组进行贪心即可。

时间复杂度为 $\mathop{O(n\log n)}$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define ld long double
inline int read()
{
    int x=0,fh=1;
    char ch=getchar();
    while(!isdigit(ch))
	{
        if(ch=='-') fh=-1;
        ch=getchar();
    }
    while(isdigit(ch))
	{
        x=(x<<1)+(x<<3)+ch-'0';
        ch=getchar();
    }
    return x*fh;
}
const int MAXN=5e5+5;
const ld g=9.8;
int a[MAXN],n,p[MAXN],m,b[MAXN],cntb;
struct node
{
	int x,y,v,id;
	ld t,ed;
}d[MAXN];
inline int cmp(node a,node b)
{
	if(a.y==b.y)return a.ed<b.ed;
	return a.y<b.y;
}
struct BIT
{
	int tr[MAXN];
	inline int lowbit(int x)
	{
		return x&-x;
	}
	inline void add(int x,int val)
	{
		for(int i=x;i<=n;i+=lowbit(i))tr[i]+=val;
	}
	inline int ask(int x)
	{
		int ans=0;
		for(int i=x;i;i-=lowbit(i))ans+=tr[i];
		return ans;
	}
}tr;
inline int gtnum(int x)
{
	return lower_bound(b+1,b+1+cntb,x)-b;
}
signed main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		d[i].x=read(),d[i].y=read(),d[i].v=read(),d[i].t=sqrt(2*d[i].y/g),d[i].ed=(ld)d[i].x+(ld)d[i].t*(ld)d[i].v,d[i].id=i;
		b[++cntb]=d[i].x;
	}
	sort(b+1,b+1+cntb);
	cntb=unique(b+1,b+1+cntb)-b-1;
	for(int i=1;i<=n;i++)cin>>a[i];
	sort(d+1,d+1+n,cmp);
	for(int i=1;i<=n;i++)
	{
		int j=i+1;
		while(d[j].y==d[i].y&&j<=n)j++;
		j--;
		int cnt=0;
		for(int k=i;k<=j;k++)p[d[k].id]+=cnt-tr.ask(gtnum(d[k].x)-1),tr.add(gtnum(d[k].x),1),cnt++;
		for(int k=i;k<=j;k++)tr.add(gtnum(d[k].x),-1);
		for(int k=j;k>=i;k--)p[d[k].id]+=tr.ask(gtnum(d[k].x)),tr.add(gtnum(d[k].x),1);
		for(int k=i;k<=j;k++)tr.add(gtnum(d[k].x),-1);
		i=j;
	}
	int ans=0;
	for(int i=1;i<=n;i++)a[i]=min(p[i],a[i]),ans+=p[i];
	sort(a+1,a+1+n,greater<int>());
	for(int i=1;i<=m;i++)ans-=a[i];
	cout<<ans;
}
```
### Thanks for reading!

---

## 作者：zeroliebe (赞：2)

## 思路

根据物理知识可知，只有当 $ y_i $ 相同时才有可能碰撞，所以我们可以将 $ y_i $ 相同的导弹放在一起去分别计算最终 $ p_i $ 的值。

接着我们来讨论 $ y_i $ 相同的一组导弹，如何来计算 $ p_i $ 。 首先计算出来每个导弹的落点位置 $ x_t $ ，如果我们按照初始位置 $ x_i $ 为关键字排序，再按照落点位置 $ x_t $ 为关键字排序，问题就转化成前一种排序编号到后一种排序编号连线的相交次数。

我们以样例 $ 2 $，$ y_i $ 为 $ 3 $ 为例进行说明：

 | $ x_i $ | $ y_i $ | $ v_i $ | $ x_t $ |
 | :-----------: | :-----------: | :-----------: | :-----------: |
 | $ 1 $ | $ 3 $ | $1 $ | $1.78$ |
 | $ -2 $ | $ 3 $ | $ 9 $ | $5.04$ |
 | $ 0 $ | $ 3 $ | $ 7 $ | $5.48$ |

排完序后的连线如图，抛物线当然可以看作直线：

![](https://cdn.luogu.com.cn/upload/image_hosting/1udscrpq.png)

那么我们就可以通过相交次数计算出来 $ p_i $ 。


## 实现

分别计算不同 $ y_i $ ，可以使用 $ map $ 映射 $ vector $ 来实现。

对于连线相交次数，一开始没有任何连线，以初始位置 $ x_i $ 为顺序，一根一根的连接，看它连线 $ x_t $ 的位置，比如 $ x_i $ 是 $ i $ 号的位置，连线到了 $ j $ 号的位置，那么说明所有小于 $ j $ 还有连线的点，一定跟这条连线相交，那么需要维护区间内有几个点已经连边，是单点修改，区间查询，还需要记录每个点被以前的连线相交的次数，只需要所有小于 $ j $ 的点次数加 $ 1 $ ，是区间修改，单点查询。那么使用树状数组维护即可。 $ p_i $ 就是 $ x_t $ 的位置 $ j $ 之前没连线的点的个数加上当前点被之前连边相交的次数之和。

求出 $ p_i $ 之后，$ a_i $ 可以修改为 $ min(p_i,a_i) $ ，因为最小只能改到 $ 0 $ ，将 $\{a_i\}$ 大到小排序，那么最终答案为： 
$$ \sum_{i = 1}^{n} p_i - \sum_{i = 1}^{m} a_i $$

## 代码

```cpp
#define g 9.8
#define N 500005

struct node{
    int x,id,v,id1;
    double xt;
};

int n,m;
int a[N],p[N],c1[N],c2[N];

std::map<int,std::vector<node> >mp;

bool cmp1(node xx,node yy){
    return xx.x<yy.x;
}

bool cmp2(node xx,node yy){
    return xx.xt<yy.xt;
}

void init(){
    n=read<int>();m=read<int>();
    _for(i,1,n){
        int x=read<int>(),y=read<int>(),v=read<int>();
        double xt=x+(double)v*sqrt(2.0*y/g);
        mp[y].push_back((node){x,0,v,i,xt});
    }
    _for(i,1,n)a[i]=read<int>();
}

int lowbit(int x){
    return x&-x;
}

int query(int x,int *c,int siz){
    int sum=0;
    for(int i=x;i;i-=lowbit(i)){
        sum+=c[i];
    }
    return sum;
}

void update(int x,int z,int *c,int siz){
    for(int i=x;i<=siz;i+=lowbit(i)){
        c[i]+=z;
    }
}

void work(){
    for(auto mm:mp){
    	std::sort(mm.second.begin(),mm.second.end(),cmp1);
        for(int i=0;i<mm.second.size();i++){
            mm.second[i].id=i+1;
        }
        std::sort(mm.second.begin(),mm.second.end(),cmp2);
        int siz=mm.second.size();
        _for(i,1,siz)c1[i]=c2[i]=0;
        for(int i=0;i<siz;i++){
            int pp=mm.second[i].id;
            int lll=pp-1-query(pp-1,c1,siz);
            update(pp,1,c1,siz);
            int rr=query(pp,c2,siz);
            update(1,1,c2,siz);
            update(pp,-1,c2,siz);
            p[mm.second[i].id1]=lll+rr;
        }
    }
    ll ans=0;
    _for(i,1,n){
        a[i]=std::min(a[i],p[i]);
        //printf("%d ",p[i]);
        ans+=p[i];
    }
    std::sort(a+1,a+n+1);
    _rep(i,n,n-m+1){
        ans-=a[i];
    }
    printf("%lld\n",ans);
}


---

## 作者：Hisaishi_Kanade (赞：2)

### 前言

感觉属于信竞和物理的缝合，~~怕不是学长被物理虐的太惨了的报复？~~

比赛时间撞了校内模拟赛，然后这场没打，不然至少能过这题。

### 正文

题意有点晕乎，大概就是说，有 $n$ 个导弹，各自从 $(x_i,y_i)$ 开始平抛运动，当两个导弹撞一起时，杀伤力加大一个。

然后有防御措施，问怎样防护最优，输出受到最小杀伤力。

题目给了个平抛落点公式，但实际上没有太大用处：
$$
x_t=x_i+v_i\sqrt{\dfrac{2y_i}g}
$$

首先考虑两个导弹咋撞上，这里需要一点物理知识（

平抛运动的运动轨迹可以理解为是物体本身的速度 $v_i$ 和自由落体的速度的合速度，显然发现每个导弹他们每时每刻自由落体的速度啥啥都一样（除非落地）。

也就是说，$y_i$ 本来就不等的，除非掉到 $x$ 轴，都不会相等；$y_i$ 本来就相等的，一直都会相等。

剩下就要考虑 $x_i$。

我们来整个图看看：

![](https://cdn.luogu.com.cn/upload/image_hosting/p46cy65p.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/dgppc1jh.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/wb96ityo.png)

容易发现，如果落地后两点的先后顺序改变，则必定产生一个交点。

如何计算呢？逆序对。

将 $y_i$ 相同的按 $x_i$ 排序，记录编号，再求出落点 $u_i$，排序（那个公式就在这用一下），最后直接算逆序对即可。

---

## 作者：CHNZhang (赞：2)

~~真是没想到会遇见物理题~~


## 物理知识

我们将武器看作一个个质点，因为所有质点都是同时出发，并且竖直方向上的加速度相同，所以它们在竖直方向上是相对静止的。因此，初始高度相同的质点才有可能发生碰撞。

初始高度相同的点在什么情况下会发生碰撞？我们可以先算出每一个质点对应的落点。对于一个质点 $i$ ，我们记它的起始位置的横坐标为 $x_{i}$ ，落点的横坐标为    $x_{i}^{'}$ 。由于在水平方向不受力的作用，是匀速直线运动，我们可以画出每一个质点在水平方向上的位移时间图像。

我们会发现，对于两个初始高度相同的质点 $i$ 和 $j$ （为了方便，我们这里认为 $x_i<x_j$ ），当且仅当它们的位移时间图像存在交点时才会相遇，并且只会相遇一次。或者说，只有当 $x_i<x_j$ 并且 $x_{i}^{'}>x_{j}^{'}$ 时，两个点才会相遇，并且只相遇一次。

下面是简单的示意图（画的不好见谅）。

![](https://cdn.luogu.com.cn/upload/image_hosting/aytacsmb.png) ![](https://cdn.luogu.com.cn/upload/image_hosting/vhreij51.png)

## 代码实现

我们可以用平衡树来维护。


我们可以按照 $y$ 的值把输入分组，对每一组按 $x_i$ 排序，我们正着遍历，将  $x_{i}^{'}$ 插入平衡树，由此可以统计出 $x$ 小于 $x_i$ 的质点对 $i$ 威力的贡献（即有多少个 $x^{'}$ 小于 $x_{i}^{'}$ ）。由于我们只求了一侧的贡献，我们需要倒过来再重复一次，这样就可以得到每一个质点的威力。

我们计算出所有质点的威力和，启动反制武器减小的威力就是反制武器的效果和质点威力的最小值。

我们对减小的威力排序，选出前 $m$ 大的即可。

以下是代码。

```cpp
//#pragma GCC optimize(2)
#include<bits/stdc++.h>
#define rint register int
#define LL long long int
using namespace std;
inline int read()
{
	int x = 0, ff = 1; char s = getchar();
	while (s < '0' || s > '9') { if (s == '-') ff = -ff; s = getchar(); }
	while (s >= '0' && s <= '9') { x = x * 10 + s - '0'; s = getchar(); }
	return x * ff;
}
double eps=1e-5;
struct ND
{
	int l,r,sz,key;
	double val;
	#define l(x) tree[x].l
	#define r(x) tree[x].r
	#define sz(x) tree[x].sz
	#define val(x) tree[x].val
	#define key(x) tree[x].key
}tree[1000005];
int tot;
inline void newnode(int p,double val)
{
	val(p)=val;
	sz(p)=1;key(p)=rand();
	l(p)=r(p)=0;
}
inline void pushup(int p)
{
	sz(p)=sz(l(p))+sz(r(p))+1;
}
int combine(int x,int y)
{
	if(x==0||y==0)return x+y;
	if(key(x)<key(y))
	{
		r(x)=combine(r(x),y);
		pushup(x);
		return x;
	}
	else
	{
		l(y)=combine(x,l(y));
		pushup(y);
		return y;
	}
}
void split(int p,double val,int &x,int &y)
{
	if(p==0)
	{
		x=y=0;
		return ;
	}
	if(val(p)<=val)
	{
		x=p;
		split(r(p),val,r(p),y);
	}
	else
	{
		y=p;
		split(l(p),val,x,l(p));
	}
	pushup(p);
}
int n,m,a[500005],del[500005];
double G=9.8;
struct node
{
	int x,y,v,id;
	double tx;
}at[500005];
map<int,int>has;
vector<node>st[500005];
inline bool cmp(node &x,node &y)
{
	return x.x<y.x;
}
int root;
inline int calc1(double val)
{
	int tmp1;
	split(root,val+eps*2,root,tmp1);
	int res=sz(tmp1);
	root=combine(root,tmp1);
	return res;
}
inline int calc2(double val)
{
	int tmp1;
	split(root,val-eps*2,root,tmp1);
	int res=sz(root);
	root=combine(root,tmp1);
	return res;
}
inline void insert(double val)
{
	int tmp=0;
	split(root,val,root,tmp);
	newnode(++tot,val);
	//cout<<root<<" "<<tmp<<" "<<
	root=combine(root,tot);
	root=combine(root,tmp);
}
inline void solve(int num)
{
	sort(st[num].begin(),st[num].end(),cmp);
	rint i,j,len=st[num].size();
	root=0;tot=0;
	for(i=0;i<len;i++)
	{
		//cout<<"! "<<st[num][i].tx<<endl;
		//cout<<root<<endl;
		//cout<<"F\n";
		del[st[num][i].id]+=calc1(st[num][i].tx);
		//cout<<"K\n";
		insert(st[num][i].tx);
	}
	root=0;tot=0;
	for(i=len-1;i>=0;i--)
	{
		del[st[num][i].id]+=calc2(st[num][i].tx);
		insert(st[num][i].tx);
	}
}
priority_queue<int>R;
int main()
{
	//freopen("missile4.in","r",stdin);
	//freopen("out.out","w",stdout);
	srand(time(0));
	rint i,j,M;
	cin>>n>>m;
	for(i=1;i<=n;i++)
	{
		at[i].x=read();at[i].y=read();
		at[i].v=read();at[i].tx=at[i].x+1.0*at[i].v*sqrt(2.0*at[i].y/G);
		at[i].id=i;
		if(has[at[i].y]==0)
		{
			has[at[i].y]=++tot;
		}
		st[has[at[i].y]].push_back(at[i]);
	}
	for(i=1;i<=n;i++)a[i]=read();
	M=tot;
	//cout<<tot<<endl;
	for(i=1;i<=M;i++)
	{
		solve(i);
	}
	LL sum=0;
	for(i=1;i<=n;i++)
	{
		sum+=del[i];
		R.push(min(del[i],a[i]));
	}
	for(i=1;i<=m;i++)
	{
		sum-=R.top();
		R.pop();
	}
	cout<<sum<<endl;
	return 0;
}
```




---

## 作者：Hanx16Kira (赞：2)

# 「KDOI-02」一个弹的投

[Luogu P8593](https://www.luogu.com.cn/problem/P8593)

## Solution

~~你管这叫 CSP-S 模拟赛？明明就是省选 Day1（~~

其实感觉这道题出的还是很不错，不过可能放在 T1 的位置有点劝退了。

先观察题目的性质，如果你学过自由落体运动的话就会发现，如果两个物体的起始位置不相同的话，二者在自由落体的时候的高度差一直都会恒定不变，这也就意味着只有相同高度的导弹才会碰撞增加威力。所以考虑将原来的序列按照 $y$ 分类，但是会发现 $y$ 的值域很大，在 $10^9$ 的范围，所以直接开桶不合适，需要离散化一下再存储。

做完这一步后我们就通过高度来对可能碰撞的导弹进行了分类，现在来考虑对于同一类中的导弹该如何计算可能的碰撞。因为相同高度的导弹掉下来在相同时间内下落的高度是一样的，这也就意味着如果两个导弹的飞行路线有相交，那么这两个导弹将一定会碰撞。

到了这一步其实就离答案不远了。考虑怎么判断两个导弹是否相交。不难发现，如果两个导弹相交，那么这两个导弹的起始点 $x_1,x_2$ 和落点 $d_1,d_2$ 一定需要满足 $x_1<x_2$ 且 $d_1>d_2$（或者是 $x_1>x_2$ 且 $d_1<d_2$）。这不就是个二维偏序的模板了嘛。所以我们就得到了一个求导弹威力的方法，二维偏序就直接排序后顺着和倒着跑一下，用树状数组维护一下就行了（需要注意 $x$ 的值域也很大，所以对 $x$ 也需要离散化一下）。

维护出了导弹的威力，那么对答案的求解也就不难了，直接贪心选择减少威力最大的 $m$ 个就行了。

思考到这一步，代码就已经可以很清晰的写出来了。不过这样你只得到了 80 分，因为你没开 `long long`（我赛时就是这样挂了 20 分，赛后加了个 `#define int long long` 就 A 了）。

感觉整体思考的过程很连贯，每一步之间都是环环相扣的，只要想到了按 $y$ 坐标分组后基本上这道题就可以解决了。

### Code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
constexpr int _SIZE = 5e5;
constexpr double g = 9.8;
struct BOMB{ // 存储导弹的基础参数，编号和提前计算落点
    int x, y, v, id;
    long double des;
}bomb[_SIZE + 5];
int by[_SIZE + 5], a[_SIZE + 5], bx[_SIZE + 5], p[_SIZE + 5]; // bx，by 是离散化数组
int n, m, cnty, cntx, fans = 0;
vector<BOMB> group[_SIZE + 5]; // 通过高度分组
long double destination(BOMB boom) { // 计算落点
    int x = boom.x, y = boom.y, v = boom.v;
    return x + v * sqrt(2 * y / g);
}
bool cmp(BOMB b1, BOMB b2) { // 组内排序规则，落点为第一关键字，起始位置为第二关键字从大到小（防止落点相同的情况）
    return b1.des > b2.des || (b1.des == b2.des && b1.x > b2.x);
}
int sum[_SIZE + 5];
#define lowbit(_) (_ & -_)
void add1(int x, int v = 1) { // 用于前缀和
    for (; x <= n; x += lowbit(x)) sum[x] += v;
}
int ask1(int x) { // 求前缀和
    int res = 0;
    for (; x; x -= lowbit(x)) res += sum[x];
    return res;
}
void add2(int x, int v = 1) { // 用于后缀和
    for (; x; x -= lowbit(x)) sum[x] += v;
}
int ask2(int x) { // 求后缀和
    int res = 0;
    for (; x <= n; x += lowbit(x)) res += sum[x];
    return res;
}
signed main() {
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        cin >> bomb[i].x >> bomb[i].y >> bomb[i].v;
        bomb[i].id = i;
        by[++cnty] = bomb[i].y, bx[++cntx] = bomb[i].x;
        bomb[i].des = destination(bomb[i]); // 提前计算落点
    }
    for (int i = 1; i <= n; i++) cin >> a[i];
    sort(by + 1, by + cnty + 1); // 离散化
    cnty = unique(by + 1, by + cnty + 1) - by - 1;
    sort(bx + 1, bx + cntx + 1);
    cntx = unique(bx + 1, bx + cntx + 1) - bx - 1;
    for (int i = 1; i <= n; i++) {
        bomb[i].y = lower_bound(by + 1, by + cnty + 1, bomb[i].y) - by;
        bomb[i].x = lower_bound(bx + 1, bx + cntx + 1, bomb[i].x) - bx;
        group[bomb[i].y].push_back(bomb[i]); // 通过离散化进行分组
    }
    for (int i = 1; i <= cnty; i++) sort(group[i].begin(), group[i].end(), cmp); // 组内排序
    for (int i = 1; i <= cnty; i++) {
        for (auto cur: group[i]) { // 顺着扫一遍
            p[cur.id] += ask1(cur.x - 1); // 值域前缀和，相当于是求比当前数更小的
            add1(cur.x);
        }
        for (auto cur: group[i]) add1(cur.x, -1); // 不要用 memset 撤销，因为 memset 时间复杂度为 O(n)
        for (int j = group[i].size() - 1; j >= 0; j--) {
            p[group[i][j].id] += ask2(group[i][j].x + 1); // 求后缀和，相当于是求比当前数更大的
            add2(group[i][j].x);
        }
        for (int j = group[i].size() - 1; j >= 0; j--) add2(group[i][j].x, -1); // 撤销
    }
    vector<int> ans(n);
    for (int i = 1; i <= n; i++) ans.push_back(min(p[i], a[i])), fans += p[i]; // 计算总的可能影响，每个防御设施可以减少的威力值就是导弹威力和自身防御值的较小值
    sort(ans.begin(), ans.end(), [](int t1, int t2) {
        return t1 > t2; // 按照减少威力值从大到小排序
    });
    for (int i = 0; i < m; i++) fans -= ans[i]; // 选前 m 个
    cout << max(fans, 0ll) << '\n'; // 防止出现负数（虽然没什么必要）
    return 0;
}
```

---

## 作者：Forever1507 (赞：1)

刚开始看到平抛运动吓死人了，结果发现只是增加了用公式算落点的细微难度（）

当我们戳进前置知识的 [Link](https://baike.baidu.com/item/%E5%B9%B3%E6%8A%9B%E8%BF%90%E5%8A%A8/974021?fr=aladdin) 我们可以发现物体平抛运动下落距离只与时间有关而与速度无关，反过来，我们也可以发现是有当两个导弹在**同一 $y$ 坐标为起点**，才可能相撞。相应的，起点 $y$ 坐标相同的两枚导弹**只要轨迹相交，一定相撞**。

然后稍微手玩一下可以发现，轨迹相交等价于起点坐标和落点坐标（都是 $x$ 坐标）呈**逆序对**，直接离散化（因为落点是 `double` 类型），对于每个 $y$ 坐标分别从小到大/从大到小（因为相交两个导弹都会加威力，因此要前后分别计算）用树状数组或归并乱维护一下，最终每个导弹的威力就是有它参与的逆序对数量。

$a_i$ 的处理是个小贪心，考虑每个 $a_i$ 的贡献是 $\min(a_i,p_i)$，那么把贡献从大到小排序，选前 $m$ 个用防御装置即可。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,tree[500005],_y[500005];
double _x[500005];
struct node{
	int stx,sty,v;//起点坐标，速度
	double edx;//落点
	int stx_pos,sty_pos;//起点离散化（然鹅stx_pos并没啥用）
	int edx_pos,a,p=0;//落点离散化
}x[500005];
int lowbit(int x){
	return x&-x;
}
int query(int x){
	int res=0;
	for(int i=x;i>0;i-=lowbit(i))res+=tree[i];
	return res;
}
void update(int x,int val){
	for(int i=x;i<=n;i+=lowbit(i))tree[i]+=val;
}
bool cmp(node x,node y){
	return x.stx<y.stx;
}//保证逆序对的第一维
bool _cmp(node x,node y){
	return min(x.p,x.a)>min(y.p,y.a);
}//贡献排序
vector<int>v[500005],V;//每个y坐标分开处理
int main(){
	ios::sync_with_stdio(0);
	cin>>n>>m;
	for(int i=1;i<=n;++i)cin>>x[i].stx>>x[i].sty>>x[i].v,_y[i]=x[i].sty;
	for(int i=1;i<=n;++i){
		cin>>x[i].a;
		double t=sqrt(x[i].sty/4.9);//套公式
		x[i].edx=x[i].stx+x[i].v*t;
		_x[i]=x[i].edx;
	}
	sort(_y+1,_y+1+n);
	sort(_x+1,_x+1+n);
	int len=unique(_y+1,_y+n+1)-_y-1;
	int len2=unique(_x+1,_x+n+1)-_x-1;
	for(int i=1;i<=n;++i){//离散化
		x[i].sty_pos=lower_bound(_y+1,_y+len+1,x[i].sty)-_y;
		x[i].edx_pos=lower_bound(_x+1,_x+len2+1,x[i].edx)-_x;
	}
	sort(x+1,x+n+1,cmp);
	for(int i=1;i<=n;++i){
		v[x[i].sty_pos].push_back(i);
		V.push_back(x[i].sty_pos);
	}
	sort(V.begin(),V.end());
	len=unique(V.begin(),V.end())-V.begin();
	for(int i=1;i<=len;++i){
		for(int k=0;k<v[V[i-1]].size();++k){
			int j=v[V[i-1]][k];
			x[j].p+=query(n)-query(x[j].edx_pos-1);
			update(x[j].edx_pos,1);
		}
		for(auto j:v[V[i-1]]){//每次清空用memset会T，所以花nlogn清楚一下
			update(x[j].edx_pos,-1);
		}
	}
	for(int i=1;i<=len;++i){//反着做
		for(int k=v[V[i-1]].size()-1;k>=0;k--){
			int j=v[V[i-1]][k];
			x[j].p+=query(x[j].edx_pos);
			update(x[j].edx_pos,1);
		}
		for(auto j:v[V[i-1]])update(x[j].edx_pos,-1);
	}
	long long ans=0;
	sort(x+1,x+n+1,_cmp);
	for(int i=1;i<=m;++i)ans+=max(0,x[i].p-x[i].a);//威力不为负
	for(int i=m+1;i<=n;++i)ans+=x[i].p;
	cout<<ans;
	return 0; 
}
```


---

## 作者：Isshiki·Iroha (赞：1)

# 题解

### 前言

[题目](https://www.luogu.com.cn/problem/P8593)

[Blog](https://www.luogu.com.cn/blog/yousa22/solution-p8593)

赛时写了 260 行，因为加 `freopen` 保龄了（悲）

### 题解

现在我们直入正解（麻烦的正解）

1. 首先我们发现，两个导弹要相遇，首先需要他们的高度相同，这里是文化课的，我就不多说了。

2. 我们可以把导弹分为三类，分别是向左的 $(v < 0)$，向右的 $(v > 0)$，向下的 $(v = 0)$。 分别对这三种进行分类讨论

a. 向左的：只需要导弹原起点在该导弹右边且落点在导弹左边，或者导弹原起点在该导弹左边且落点在导弹右边

b. 向右的：只需要导弹原起点在该导弹左边且落点在导弹右边，导弹原起点在该导弹右边且落点在导弹左边

c. 向下的：只需要导弹原起点在该导弹左边且落点在导弹右边，导弹原起点在该导弹右边且落点在导弹左边

如何理解：直接把抛物线看成直线，夹在两平行线之间的直线相交就是这么判断的

其实就是逆序对......（注意离散化，要对落点离散化）

然后最后我们求出每一个导弹可以减少的次数，排个序就可以了

然后就完了，写麻烦了

260 行代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
namespace Mashiro {
    char buf[1<<18],*p1=buf,*p2=buf;
    inline int getc() {
        return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<18,stdin),p1==p2)?EOF:*p1++;
    }
    template<typename T>inline void read(T& x) {
        x=0;int f=1;
        char ch=getc();
        while(!isdigit(ch)){if(ch=='-')f=~f+1;ch=getc();}
        while (isdigit (ch)) {x=(x<<3)+(x<<1)+(ch^48);ch=getc();}
        x*=f;
    }
    template <typename T,typename... Args> inline void read(T& x, Args&... args) {
        read(x);
        read(args...);
    }
    char buffer[1<<18];int p11=-1;const int p22=(1<<18)-1;
    inline void flush() {fwrite(buffer,1,p11+1,stdout),p11=-1;}
    inline void putc(const char &x) {if (p11==p22) flush();buffer[++p11]=x;}
    template<typename T>inline void write(T x) {
        static int buf[40],top=0;
        if(x<0)putc('-'),x=~x+1;
        while(x)buf[++top]=x%10,x/=10;
        if(top==0)buf[++top]=0;
        while (top) putc(buf[top--]^48);
        putc(' ');
        flush();
     }
     template <typename T,typename... Args> inline void write(T x, Args... args) {
         write(x);
         write(args...);
     }
}
namespace Misaka{
    auto seed=std::chrono::system_clock::now().time_since_epoch().count();
    std::mt19937 rnd(seed);
    template<typename T>T random(T l, T r) {
    	 return std::uniform_int_distribution<T>(l,r)(rnd); 
    }
}
namespace Cmp{
    template<typename T>inline T Min(T a,T b){
        return a>b?b:a;
    }
    template<typename T,typename... Args> inline T Min(T a,T b,Args... args){
        return Min(a,Min(b,args...));
    }
    template<typename T>inline T Max(T a,T b){
        return a>b?a:b;
    }
    template<typename T,typename... Args> inline T Max(T a,T b,Args... args){
        return Max(a,Max(b,args...));
    }
}
using namespace Mashiro;
const int maxn=5e5+10;
int n;
struct point{
    int x,y,v;
}p[maxn];
struct point2{
    int now,hxt;
    double x,y,v,xt;
}p1[maxn];
struct BIT{
    int c[maxn];
    inline int lowbit(int x){
        return x&(~x+1);
    }
    void add(int x,int v=1){
        while(x<=n){
            c[x]+=v;
            x+=lowbit(x);
        }
    }
    int query(int x){
        int res=0;
        while(x){
            res+=c[x];
            x-=lowbit(x);
        }
        return res;
    }
}Tree;
bool cmp(point2 A,point2 B){
    return A.xt<B.xt;
}
int attack[maxn],k,by[maxn];
double bx[maxn];
int Mapy[maxn],Mapx[maxn];
vector<point2>Same[maxn][3];
double Xt[maxn];
int a[maxn];
struct ANS{
    int nowans,sub;
}AA[maxn];
int main() {
    // freopen("missile4.in","r",stdin);
    // freopen("missile4.out","w",stdout);
    read(n,k);
    for(int i(1);i<=n;++i){
        read(p[i].x,p[i].y,p[i].v);
        by[i]=p[i].y;
        double x=p[i].x,y=p[i].y,v=p[i].v;
        double xt=x+v*sqrt(2.0*y/9.8);
        Xt[i]=xt;
        bx[i]=xt;
    }
    for(int i(1);i<=n;++i)read(a[i]);
    sort(bx+1,bx+1+n);
    sort(by+1,by+1+n);
    int my=unique(by+1,by+1+n)-by-1;
    int mx=unique(bx+1,bx+1+n)-bx-1;
    for(int i(1);i<=n;++i){
        double x=p[i].x,y=p[i].y,v=p[i].v;
        int rankx=lower_bound(bx+1,bx+1+mx,Xt[i])-bx;
        int ranky=lower_bound(by+1,by+1+my,p[i].y)-by;
        if(v>0)Same[ranky][0].emplace_back(point2{i,rankx,x,y,v,Xt[i]});
        if(v<0)Same[ranky][1].emplace_back(point2{i,rankx,x,y,v,Xt[i]});
        if(v==0)Same[ranky][2].emplace_back(point2{i,rankx,x,y,v,Xt[i]});
    }
    for(int i(1);i<=my;++i){
        // write(i);
        // putc('\n');
        int nl=Same[i][0].size();
        int nr=Same[i][1].size();
        vector<point2>Temp;

        for(auto j:Same[i][0])Temp.emplace_back(j);
        for(auto j:Same[i][1])Temp.emplace_back(j);
        for(auto j:Same[i][2])Temp.emplace_back(j);
        int nn=Temp.size();
        sort(Temp.begin(),Temp.end(),[](const point2 A,const point2 B){
            return A.x>B.x;
        });
        for(int j(0);j<nn;++j){
            if(Temp[j].v<=0)Tree.add(Temp[j].hxt);
            else {
                int res=Tree.query(Temp[j].hxt);
                attack[Temp[j].now]+=res;
            }
        }
        for(int j(0);j<nn;++j){
            if(Temp[j].v<=0)Tree.add(Temp[j].hxt,-1);
        }
        sort(Temp.begin(),Temp.end(),[](const point2 A,const point2 B){
            return A.x<B.x;
        });
        int cnt=0;
        for(int j(0);j<nn;++j){
            if(Temp[j].v>=0)Tree.add(Temp[j].hxt),++cnt;
            else {
                int res=Tree.query(Temp[j].hxt-1);
                attack[Temp[j].now]+=cnt-res;
            }
        }
        for(int j(0);j<nn;++j){
            if(Temp[j].v>=0)Tree.add(Temp[j].hxt,-1);
        }

        cnt=0;
        for(int j(0);j<nn;++j){
            if(Temp[j].v>0){
                Tree.add(Temp[j].hxt);
                ++cnt;
            }
            else if(Temp[j].v==0){
                int res=Tree.query(Temp[j].hxt-1);
                attack[Temp[j].now]+=cnt-res;
            }
        }
        for(int j(0);j<nn;++j){
            if(Temp[j].v>0){
                Tree.add(Temp[j].hxt,-1);
            }
        }
        sort(Temp.begin(),Temp.end(),[](const point2 A,const point2 B){
            return A.x>B.x;
        });
        for(int j(0);j<nn;++j){
            if(Temp[j].v<0){
                Tree.add(Temp[j].hxt);
            }
            else if(Temp[j].v==0){
                int res=Tree.query(Temp[j].hxt);
                attack[Temp[j].now]+=res;
            }
        }
        for(int j(0);j<nn;++j){
            if(Temp[j].v<0){
                Tree.add(Temp[j].hxt,-1);
            }
        }
        sort(Same[i][0].begin(),Same[i][0].end(),[](const point2 A,const point2 B){
            return A.x<B.x;
        });  
        for(int j(0);j<nl;++j){
            int res=Tree.query(Same[i][0][j].hxt-1);
            attack[Same[i][0][j].now]+=j-res;
            Tree.add(Same[i][0][j].hxt);
        }
        for(int j(0);j<nl;++j){
            Tree.add(Same[i][0][j].hxt,-1);
        }
        sort(Same[i][0].begin(),Same[i][0].end(),[](const point2 A,const point2 B){
            return A.x>B.x;
        });
        for(int j(0);j<nl;++j){
            int res=Tree.query(Same[i][0][j].hxt);
            attack[Same[i][0][j].now]+=res;
            Tree.add(Same[i][0][j].hxt);
        }
        for(int j(0);j<nl;++j){
            Tree.add(Same[i][0][j].hxt,-1);
        }
        sort(Same[i][1].begin(),Same[i][1].end(),[](const point2 A,const point2 B){
            return A.x>B.x;
        });
        for(int j(0);j<nr;++j){
            int res=Tree.query(Same[i][1][j].hxt);
            attack[Same[i][1][j].now]+=res;
            Tree.add(Same[i][1][j].hxt);
        }
        for(int j(0);j<nr;++j){
            Tree.add(Same[i][1][j].hxt,-1);
        }
        sort(Same[i][1].begin(),Same[i][1].end(),[](const point2 A,const point2 B){
            return A.x<B.x;
        });
        for(int j(0);j<nr;++j){
            int res=Tree.query(Same[i][1][j].hxt-1);
            attack[Same[i][1][j].now]+=j-res;
            Tree.add(Same[i][1][j].hxt);
        }
        for(int j(0);j<nr;++j){
            Tree.add(Same[i][1][j].hxt,-1);
        }
    }
    ll ans=0;
    for(int i(1);i<=n;++i){
        AA[i].nowans=attack[i];
        AA[i].sub=a[i];
    }
    sort(AA+1,AA+1+n,[](const ANS A,const ANS B){
        return min(A.nowans,A.sub)>min(B.nowans,B.sub);
    });
    for(int i(1);i<=k;++i){
        ans+=max(0,AA[i].nowans-AA[i].sub);
    }
    for(int i(k+1);i<=n;++i){
        ans+=AA[i].nowans;
    }
    write(ans);
    return 0;
}

```







---

## 作者：OneStar (赞：1)

MnZn第一篇题解。

[题目传送门](https://www.luogu.com.cn/problem/P8593)。

考虑怎样的两枚炮弹会相撞。对于 $y$ 轴，由于炮弹在 $y$ 轴上下落的加速度是相同的，所以只有两枚炮弹初始 $y$ 值相同时才有可能相撞。对于 $x$ 轴，当两枚炮弹初始 $x$ 坐标与落地时的 $x$ 坐标相对位置相反时，才有可能相撞。

形式化的，对于初始 $y$ 坐标相同的炮弹 $i$ 和炮弹 $j$，其落地的 $x$ 坐标分别为为 $f_i$ 和 $f_j$，有：

$$p_i=\sum_{y_i=y_j} f_i\le f_j\land x_i>x_j$$

当我们把所有炮弹的**以初始 $y$ 坐标为第一关键字，初始 $x$ 坐标为第二关键字排序**后，我们会发现所要求的的 $p_i$ 变成了**在初始 $y$ 坐标相同的区间内，与 $f_i$ 形成逆序对 $f_j$ 的个数**。

然鹅本蒟蒻并不会解逆序对。

于是我用一颗主席树维护 $f_i$ ，在排序后，对于每个初始 $y$ 坐标相同的区间 $[l,r]$，显然区间内初始 $x$ 坐标单调不降，有：
$$p_i=\sum_{j=l}^{j<i}f_i\le f_j+\sum_{k=i+1}^{k\le r}f_i>f_k$$
得到每个 $p_i$ 后，算一下每个反制武器真正可以减少的威力值，然后贪心求解即可。

AC代码：
```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define ll long long
#define db double
#define N 500010
using namespace std;
struct Node{int x,y,f,num;}a[N];
struct Node1{db val;int num;}g[N];
bool cmp(Node X,Node Y){return X.y<Y.y||(X.y==Y.y&&X.x<Y.x);}
bool cmp1(Node1 X,Node1 Y){return X.val<Y.val;}
int n,m,tot,rt[N],p[N],c[N];
struct Tree{int ls,rs,val;}t[N<<5];
int build(int l,int r){
	int p=++tot,mid=l+r>>1;
	if(l==r) return p;
	t[p].ls=build(l,mid);
	t[p].rs=build(mid+1,r);
	return p;
}
int update(int pre,int l,int r,int x){
	int p=++tot,mid=l+r>>1;
	t[p]=t[pre];
	t[p].val++;
	if(l==r) return p;
	if(x<=mid) t[p].ls=update(t[pre].ls,l,mid,x);
	else t[p].rs=update(t[pre].rs,mid+1,r,x);
	return p;
}
int smaller_ask(int u,int v,int l,int r,int i){
	int mid=l+r>>1;
	if(l==r) return 0;
	if(mid<i) return t[t[v].ls].val-t[t[u].ls].val+smaller_ask(t[u].rs,t[v].rs,mid+1,r,i);
	return smaller_ask(t[u].ls,t[v].ls,l,mid,i);
}
int bigger_ask(int u,int v,int l,int r,int i){
	int mid=l+r>>1;
	if(l==r) return t[v].val-t[u].val;
	if(mid>=i) return t[t[v].rs].val-t[t[u].rs].val+bigger_ask(t[u].ls,t[v].ls,l,mid,i);
	return bigger_ask(t[u].rs,t[v].rs,mid+1,r,i);
}
int main(){
	scanf("%d%d",&n,&m);
	for(int v,i=1;i<=n;i++){
		scanf("%d%d%d",&a[i].x,&a[i].y,&v);
		g[i].val=1.0*a[i].x+((db)v)*sqrt(((db)a[i].y)/4.9);
		a[i].num=g[i].num=i;
	}
	sort(g+1,g+n+1,cmp1);
	int gtot=0;
	rt[0]=build(1,n);
	for(int i=1;i<=n;i++){ //离散化fi
		if(g[i].val!=g[i-1].val) gtot++; 
		a[g[i].num].f=gtot;
	}
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++) rt[i]=update(rt[i-1],1,n,a[i].f);
	for(int L=1,R=0,i=1;i<=n;i++){
		if(a[i].y!=a[i+1].y){
			R=i;
			for(int j=L;j<=R;j++) p[a[j].num]=((j<R)?smaller_ask(rt[j],rt[R],1,n,a[j].f):0)+((j>L)?bigger_ask(rt[L-1],rt[j-1],1,n,a[j].f):0);
			L=i+1;
		}
	}
	ll ans=0;
	for(int i=1;i<=n;i++){
		scanf("%d",&c[i]);
		ans+=p[i];
		c[i]=min(p[i],c[i]);
	}
	sort(c+1,c+n+1);
	for(int i=n;i>n-m;i--) ans-=c[i];
	printf("%lld",ans);
	return 0;
}
```


---


# [DTCPC 2024] 取模

## 题目描述

给定序列 $\{a_n\}$ 和 $[L,R]$，问有多少个 $k\in [L,R]$ 满足 $a_i\bmod k$ 互不相同。

## 样例 #1

### 输入

```
3 1 3
11 7 6```

### 输出

```
1```

# 题解

## 作者：gghack_Nythix (赞：13)

### 前言：这篇题解是纯暴力，但是居然跑到了最优解前5。

### 分析:
#### 加强前:
没什么好分析的，你很容易就可以写出下面的代码:
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[50005],n,l,r,maxx,ans;
int tot[400005];
inline bool ck(int k,int ragez){
	for(int i = 1;i <= n;++i) { 
		if(tot[a[i] % k] == ragez) return 0;
		tot[a[i] % k] = ragez;
	} 	
	return 1;
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> l >> r;
	for(register int i = 1;i <= n;++i) { 
		cin >> a[i]; 
		maxx = max(a[i],maxx); 
		if(tot[a[i]] == 1){
			cout << 0 ;
			return 0;
		}
		tot[a[i]] = 1;
	} 	
	memset(tot,0,sizeof(tot));
	l = max(n,l);
	if(r > maxx) ans += r - maxx + 1;//计算绝对有解的
	int curr = 0;
	for(register int k = l;k <= min(r,maxx - 1);++k) { ++ curr;if(ck(k,curr)) {++ans;} } 
	cout << ans ;
	return 0;
}
```
在不加强时可以AC，加强后可以通过21个点。
### 优化:

可以寻找到一部分比当前模数小的数，对这一部分进行标记，表示这些取模后仍然是他本身。容易发现，即使 $k$ 继续扩大，这一部分依然不用被计算。所以每次直接跳过就可以了
```cpp
#include<bits/stdc++.h>
#define max(x,y) (x>y?x:y)
using namespace std;
int a[50005],n,l,r,maxx,ans,lst,tmp,curr,tot[400005],sqrtsqrt;
bool tot2[400005],toto[400005];
inline bool ck(int k,int ragez){
	while(a[lst] < k && lst <= n) ++ lst,tot2[a[lst]] = 1;//这些一定不需要
	for(int i = lst;i <= n;++i) { 
		tmp = a[i] % k;
		if(tot[tmp] == ragez || tot2[tmp]) return 0;
		tot[tmp] = ragez;
	} 	
	return 1;
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> l >> r;
	for(int i = 1;i <= n;++i) { 
		cin >> a[i];
		maxx = max(a[i],maxx); 
		if(toto[a[i]] == 1){
			cout << 0;
			return 0;
		}
		toto[a[i]] = 1;
	} 
	sort(a + 1,a + n + 1);
	memset(tot,0,sizeof(tot));
	l = max(n,l);
	if(r > maxx) ans += r - maxx + 1;
	sqrtsqrt = sqrt(n);
	for(int k = l;k <= min(r,maxx - 1);++k) { 
		if(ck(k,++curr)) ++ans;
	} 
	cout << ans ;
	return 0;
}
```


### 第二次优化:

发现我们可以使用一些原数列本来剩下的值，用这些值去制造一个和他同余的数，如果这个同余的数已经在原序列存在了，那么也就说明冲突了。

如何制造呢?

设 $n=fk+y$，其中 $k$ 就是题面要求的 $k$ 。$y$ 为对 $k$ 取余的余数。

则 $n' = (f+f')k+y = fk + f'k + y$ 。

也就是说枚举 $k$ 的多少倍就可以了。

```cpp
#include<bits/stdc++.h>
#define max(x,y) (x>y?x:y)
#define I_love_You() (assert(n <= 11451441))
using namespace std;
int a[50005],n,l,r,maxx,ans,lst,tmp,curr,tot[400005],sqrtsqrt;
bool tot2[400005],toto[400005];
inline bool ck(int k,int ragez){
	while(a[lst] < k && lst <= n) ++ lst,tot2[a[lst]] = 1;//这些一定不需要
	for(int i = lst;i <= n;++i) { 
		tmp = a[i] % k;
		if(tot[tmp] == ragez || tot2[tmp]) return 0;
		tot[tmp] = ragez;
	} 	
	return 1;
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> l >> r;
	for(int i = 1;i <= n;++i) { 
		cin >> a[i];
		maxx = max(a[i],maxx); 
		if(toto[a[i]] == 1){
			cout << 0;
			return 0;
		}
		toto[a[i]] = 1;
	} 
	sort(a + 1,a + n + 1);
	memset(tot,0,sizeof(tot));
	l = max(n,l);
	if(r > maxx) ans += r - maxx + 1;
	sqrtsqrt = sqrt(n);
	for(int k = l;k <= min(r,maxx - 1);++k) { 
		if(k >= sqrtsqrt) {
			for(int i = 1;i <= sqrtsqrt;++i) {
				for(int j = a[i] + k;j <= a[n];j += k) {
					if(toto[j]) goto nimade;
				}
			}
		}
		if(ck(k,++curr)) ++ans;
		nimade: I_love_You();
	} 
	cout << ans ;
	return 0;
}
```

好嘛，差几个点AC。

### ~~又叕叕优化~~:
容易发现，如果 $k > a_x - a_y$ ，可以说明在 $[x,y]$ 区间中的数对$k$取模一定是不会冲突的，最坏情况下会剩下 $k - a_x + a_y$ 个余数没有被使用。

对于 $a_y$ 的选择，自然是选择小于 $a_y$ 时，这个数不冲突，消除干扰。

```cpp
#include<bits/stdc++.h>
#define max(x,y) (x>y?x:y)
#define I_love_You() (assert(n <= 11451441))
using namespace std;
int a[50005],n,l,r,maxx,ans,lst,tmp,curr,tot[400005],sqrtsqrt,f[400005];
bool tot2[400005],toto[400005];
inline bool ck(int k,int ragez){
	while(a[lst] < k && lst <= n) ++ lst,tot2[a[lst]] = 1;//这些一定不需要
	for(int i = lst;i <= n;++i) { 
		tmp = a[i] % k;
		if(tot[tmp] == ragez || tot2[tmp]) return 0;
		tot[tmp] = ragez;
	} 	
	return 1;
}
inline bool cky(int k,int ragez){
	while(a[lst] < k && lst <= sqrtsqrt) ++ lst,tot2[a[lst]] = 1;//这些一定不需要
	for(int i = lst;i <= sqrtsqrt;++i) { 
		tmp = a[i] % k;
		if(tot[tmp] == ragez || tot2[tmp]) return 0;
		tot[tmp] = ragez;
	} 	
	return 1;
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> l >> r;
	for(int i = 1;i <= n;++i) { 
		cin >> a[i];
		maxx = max(a[i],maxx); 
		if(toto[a[i]] == 1){
			cout << 0;
			return 0;
		}
		toto[a[i]] = 1;
	} 
	sort(a + 1,a + n + 1);
	memset(tot,0,sizeof(tot));
	l = max(n,l);
	if(r > maxx) ans += r - maxx + 1;
	sqrtsqrt = 0.4376 * sqrt(n);
	for(int k = l;k <= min(r,maxx - 1);++k){ 
		while(!cky(k,++curr)) --sqrtsqrt;
		if(cky(k,++curr)) break;
	}
	for(int k = l;k <= min(r,maxx - 1);++k) { 
		if(k >= sqrtsqrt) {
			for(int i = 1;i <= sqrtsqrt;++i) {
				for(int j = a[i] + k;j <= a[n];j += k) {
					if(toto[j]) goto nimade;//存在同余
				}
			}
		}
		if(k > a[n] - a[sqrtsqrt]) {++ans;continue;}
		if(ck(k,++curr)) ++ans;
		nimade: I_love_You();
	} 
	cout << ans ;
	return 0;
}
```
T掉了最后一个点。

### 继续优化:

发现这个程序在序列中数字比较连续时容易TLE。那么我们对于这种连续（即$a_i+1=a_{i+1}$）的块一个个做处理。

做处理时，我们不妨换一种思路，不对原数进行显著的放入桶判断模数相等，而是转化成线段覆盖问题:

设当前两个块分别是$A$，$B$，块中的起始，终止元素对 $k$ 取余的结果为$st$，$ed$:

考虑记录这两个块中的起始元素和终止元素，这之中的余数一定不会离散的分布，但注意，他们之间的**模数有几率**变回0。

1. 先考虑两个块不变回0的情况，即$AB$的$ed$均大于$st$:

此时的线段长这个样子:

![T1](https://s11.ax1x.com/2024/02/23/pFUNRvq.png)

只需要判断两条线段是否相交。


2. 其中一个分裂成两条线段:

此时长这个样子:

![T2](https://s11.ax1x.com/2024/02/23/pFUUSaD.png)

可以判断另外一套线段是否和空白区相交。

3. 两个都分裂了:

此时长这个样子

![T3](https://s11.ax1x.com/2024/02/23/pFUUVqf.png)

我是将其中一个线段分成 $[st,k-1]$ 和 $[0,ed]$ 来判断的，当然仔细想想这种情况明显不成立。

讨论完之后就可以愉快的写代码了，时间复杂度应该也是 $O(n^2)$ 左右的:

```cpp
#include<bits/stdc++.h>
#define max(x,y) (x>y?x:y)
#define I_love_You() (assert(n <= 11451441))
using namespace std;
int a[50005],n,l,r,maxx,ans,lst,tmp,curr,tot[400005],sqrtsqrt,f[400005],cntt;
bool tot2[400005],toto[400005];
struct node{
	int len,st,ed;
	bool operator < (const node & hh) const {
		return len > hh.len;
	}
};
vector<node> vec;
inline bool ck(int k,int ragez){
	while(a[lst] < k && lst <= n) ++ lst,tot2[a[lst]] = 1;//这些一定不需要
	for(int i = lst;i <= n;++i) { 
		tmp = a[i] % k;
		if(tot[tmp] == ragez || tot2[tmp]) return 0;
		tot[tmp] = ragez;
	} 	
	return 1;
}
inline bool cky(int k,int ragez){
	while(a[lst] < k && lst <= sqrtsqrt) ++ lst,tot2[a[lst]] = 1;//这些一定不需要
	for(int i = lst;i <= sqrtsqrt;++i) { 
		tmp = a[i] % k;
		if(tot[tmp] == ragez || tot2[tmp]) return 0;
		tot[tmp] = ragez;
	} 	
	return 1;
}
inline int qp(int a,int b){
	int ans = 1;
	while(b) {
		if(b & 1) ans = ans * a;
		a = a * a;
		b >>= 1;
	}
	return ans;
}
namespace gghack{
	inline bool cka(int k){
		for(int i = 0;i < signed(vec.size());++i) {//前面的和当前的比较
			for(int j = 0;j < i;++j) {//枚举前面的
				if(vec[i].st % k <= vec[i].ed % k){
					int lftmd = 0,rgtmd = 0,mode = 0;
					if(vec[j].st % k > vec[j].ed % k || (vec[j].ed % k - vec[j].st % k + 1) != vec[j].len) {//取模爆掉了成为了0
						lftmd = vec[j].ed,rgtmd = vec[j].st;//有剩余格子的就是这一坨
						mode = 1;//成为判断是否不在冲突范围中
					}
					else lftmd = vec[j].st,rgtmd = vec[j].ed;
					if(mode) {//相当于两条断开的线段和一条完整的线段判断线段覆盖
						if(!(vec[i].st % k > lftmd && vec[i].ed % k < rgtmd))return 0;//不在空闲的那一坨
					}
					else {
						if((vec[i].st % k >= lftmd && vec[i].ed % k <= rgtmd) || (vec[i].st % k >= lftmd && vec[i].st % k <= rgtmd) || (vec[i].ed % k <= rgtmd && vec[i].ed % k >= lftmd) || (vec[i].st % k <= lftmd && vec[i].ed % k >= rgtmd))return 0;//不在外面的那一坨白色区域
					}
				}
				else {//这一波也是拆成两个线段，一个是st ~ k - 1，一个是0 ~ ed
					int lftmd = 0,rgtmd = 0,mode = 0;
					if(vec[j].st % k > vec[j].ed % k || (vec[j].ed % k - vec[j].st % k + 1) != vec[j].len) {//取模爆掉了成为了0
						lftmd = vec[j].ed,rgtmd = vec[j].st;//有剩余格子的就是这一坨
						mode = 1;//成为判断是否不在冲突范围中
					}
					else lftmd = vec[j].st,rgtmd = vec[j].ed;
					if(mode) {//相当于两条断开的线段和一条完整的线段判断线段覆盖
						if(!(vec[i].st % k > lftmd && k < rgtmd))return 0;//不在空闲的那一坨
						if(!(0 > lftmd && vec[i].ed % k < rgtmd))return 0;//不在空闲的那一坨
					}
					else {
						if((vec[i].st % k >= lftmd && k <= rgtmd) || (vec[i].st % k >= lftmd && vec[i].st % k <= rgtmd) || (k - 1 <= rgtmd && k - 1 >= lftmd) || (vec[i].st % k <= lftmd && k - 1 >= rgtmd))return 0;//不在外面的那一坨白色区域
						if((0 >= lftmd && vec[i].ed % k <= rgtmd) || (0 >= lftmd && 0 <= rgtmd) || (vec[i].ed % k <= rgtmd && vec[i].ed % k >= lftmd) || (0 <= lftmd && vec[i].ed % k >= rgtmd))return 0;//不在外面的那一坨白色区域
					}
				}
			}
		}
		return 1;
	}
	void tohack(){
		for(int k = l;k <= min(maxx - 1,r);++k) {if(cka(k))++ans;}
		cout << ans << '\n';
		exit(0);
	}
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> l >> r;
	for(int i = 1;i <= n;++i) { 
		cin >> a[i];
		maxx = max(a[i],maxx); 
		if(toto[a[i]] == 1){
			cout << 0;
			return 0;
		}
		toto[a[i]] = 1;
	} 
	sort(a + 1,a + n + 1);
	memset(tot,0,sizeof(tot));
	l = max(n,l);
	if(r > maxx) ans += r - maxx + 1;
	sqrtsqrt = sqrt(n);//玄学调参
	for(int k = l;k <= min(r,maxx - 1);++k){ 
		while(!cky(k,++curr)) --sqrtsqrt;//余数冲突满足单调性
		if(cky(k,++curr)) break;//这个都符合了，下一个更大的余数会被映射到更大的空间，可以跳过
	}
	int d = 1;
	for(int i = 2;i <= n + 1;++i) {
		if(a[i - 1] + 1 != a[i]){
			vec.emplace_back(node{d,a[i - d],a[i - 1]});
			d = 1;
			++i;
		}
		++d;
	}
	if(vec.size() >= 2 && vec.size() <= sqrt(sqrt(n))){gghack::tohack();return 0;}
	for(int k = l;k <= min(r,maxx - 1);++k) { 
		if(k >= sqrtsqrt) {
			for(int i = 1;i <= sqrtsqrt;++i) {
				for(int j = a[i] + k;j <= a[n];j += k) {
					if(toto[j]) goto nimade;//存在同余
				}
			}
		}
		if(k > a[n] - a[sqrtsqrt]) {++ans;continue;}
		if(ck(k,++curr)) ++ans;
		nimade: I_love_You();
	} 
	cout << ans << '\n';
	return 0;
}
```

### 后记:

![doge](https://s11.ax1x.com/2024/02/23/pFUUKiQ.png)

~~卡不掉应该也差不多了吧，毕竟只要解决题目都可以。~~

---

## 作者：operator_ (赞：7)

# P10171 [DTCPC 2024] 取模

[题目传送门](https://www.luogu.com.cn/problem/P10171)

## 题解

不会多项式导致的，赛后秒过。

一个显然的结论：如果原序列有相等的数答案为 $0$，其次大于 $4\times 10^5$ 的 $k$ 均符合要求。问题在于小于 $4\times 10^5$ 的答案。

赛时想了很多奇妙的算法，诸如根号分治、线段树维护余数等等。其实不用这么麻烦，考虑两个数在模 $k$ 意义下相等，等价于这两个数的差是 $k$ 的倍数，而本题值域较小，如果我们求出了两两之间的差，可以用 $\sum\lfloor\dfrac{V}{i}\rfloor\approx V\log V$ 的复杂度完成本题。

问题在于求差，因为值域较小，可以将 $a$ 序列转化成一个长为 $V$ 的多项式，每一项系数为 $0/1$，然后答案即为 $ans_k=\sum\limits_{i-j=k}a_ia_j$，将多项式反转后与原多项式做多项式卷积即可。

代码：

```cpp
/*
 * @Author: operator_ 
 * @Date: 2024-02-18 08:36:29 
 * @Last Modified by: operator_
 * @Last Modified time: 2024-02-18 09:17:33
 */
#include<bits/stdc++.h>
using namespace std;
#define int long long
inline int rd() {
    int s=0,m=0;char ch=getchar();
    while(!isdigit(ch)) {if(ch=='-')m=1;ch=getchar();}
    while( isdigit(ch)) s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
    return m?-s:s;
}
#define cp complex<double>
const double pi=acos(-1);
int rv[4000005];
void init(int k) {
	for(int i=0;i<(1<<k);i++)
		rv[i]=(rv[i>>1]>>1)|((i&1)<<(k-1));
}
void fft(cp a[],int n,int fl) { 
    for(int i=0;i<n;i++)
		if(i<rv[i]) swap(a[i],a[rv[i]]);
	for(int i=1;i<n;i*=2) {
		cp wi=exp(cp(0,fl*pi/i));
		for(int j=0;j<n;j+=i*2) {
			cp w(1,0);
			for(int k=j;k<i+j;k++,w*=wi) {
				cp x=a[k],y=w*a[k+i];
				a[k]=x+y,a[k+i]=x-y;
			}
		}
	}
	if(fl==-1) for(int i=0;i<n;i++) a[i]/=n;
}
const int N=400000;
int n,l,r,x[50005],mp[400005],ans[4000005],sum;
cp a[4000005],b[4000005];
signed main() {
    cin>>n>>l>>r;
    for(int i=1;i<=n;i++) mp[x[i]=rd()]++;
    for(int i=1;i<=N;i++)
        if(mp[i]>1) return puts("0"),0;
    for(int i=1;i<=N;i++) if(mp[i])
        a[i-1]=1,b[N-i]=1;
	int k=0,m=1;while(m<=N*2) k++,m*=2;
	init(k);fft(a,m,1);fft(b,m,1);
	for(int i=0;i<m;i++) a[i]=a[i]*b[i];
	fft(a,m,-1);
    for(int i=1;i<=N;i++) ans[i]=(int)(a[i+N-1].real()+0.5);
    sum=max(0ll,r-N);
    for(int i=l;i<=min(r,N);i++) {
        int fl=1;
        for(int j=0;i*j<=N;j++)
            if(ans[i*j]) {fl=0;break;}
        if(fl) sum++;
    }
    cout<<sum;
    return 0;
}
```

第一次发数学题解，如有错误欢迎指正！

---

## 作者：Register_int (赞：6)

先来判掉一些极端情况：若本来就存在 $a_i=a_j$ 则无解。否则此时对于所有 $>\max a$ 的 $k$ 都是有解的。只要处理 $1\le k\le \max a$ 的部分。

对于一对 $i,j$，所有满足 $k\mid|a_i-a_j|$，的 $k$ 都是不合法的。可以尝试预处理出所有 $|a_i-a_j|$，再通过枚举约数做后缀和得出每个 $k$ 是否合法。后半部分显然是 $O(V\ln V)$ 的，前半部分可以发现是一个差卷积，用 NTT 简单计算即可。总时间复杂度 $O(V\ln V)$。

# AC 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

#define _POW_OPTIMIZE_FOR_K

namespace polynomial {
	// by Ri.
}

using namespace polynomial;

const int MAXN = 4e5 + 10;

int n, l, r, a[MAXN], cnt[MAXN];

int ans, m; bool f;

int main() {
	scanf("%d%d%d", &n, &l, &r), f = 1;
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]), cnt[a[i]]++, m = max(a[i], m);
	for (int i = 1; i <= m; i++) if (cnt[i] > 1) f = 0;
	if (!f) return puts("0"), 0;
	ans += max(0, r - max(l - 1, m)), r = min(r, m), l = max(l, n);
	sort(a + 1, a + n + 1);
	poly<ll> f(m * 2), g(m * 2);
	for (int i = 1; i <= m; i++) f[i] = cnt[i];
	for (int i = 1; i <= m; i++) g[i] = cnt[m - i];
	f *= g;
	for (int i = 1; i <= m; i++) cnt[i] = 0;
	for (int i = 1; i < m; i++) if (f[m + i]) cnt[i] = 1;
	for (int i = m; i; i--) {
		for (int j = i * 2; j <= m; j += i) cnt[i] |= cnt[j];
	}
	for (int i = l; i <= r; i++) ans += !cnt[i];
	printf("%d", ans);
}
```

---

## 作者：xz001 (赞：5)

先判断如果序列中本来就有元素相同，答案一定为 $0$。

然后对于大于 $400000$ 的 $k$，模 $k$ 后序列不变，一定可行。

这样我们只需要考虑小于 $400000$ 的 $k$，我们思考一下，如果两个元素的差为 $d$，那么 $k$ 一定不能为 $d$ 的约数，否则这两个元素在模 $k$ 后便会相同，所以我们先求出所有数的差有哪些会出现，由题意得不会超过 $400000$ 个。我们可以用 ```bitset``` 存储有哪些数出现过，然后对于每个数，用用右移操作求得会有哪些差，二进制或起来即可。然后对于每个差，将其所有约数剔除，剩余的数即为可行。

时间复杂度 $O(\frac{n\times (\max a_i)}{w})$，代码如下：

```cpp
/*
#pragma GCC optimize(1)
#pragma GCC optimize(2)
#pragma GCC optimize(3, "Ofast", "inline")
*/
#include<bits/stdc++.h>

using namespace std;

#define re			register
#define int			long long
#define fi			first
#define se			second
#define swap(a, b) 	a ^= b, b ^= a, a ^= b
#define pb 			push_back
#define all(x)		x.begin(), x.end()
#define max(a, b)	(a > b ? a : b)
#define min(a, b)	(a < b ? a : b)
#define il			inline
#define abs(x)		((x ^ (x >> 63)) - (x >> 63))

typedef pair<int, int> PII;

const int N = 1e6 + 10;
const int M = 1e6 + 10;
const int INF = 1e18, P = 998244353;
const double eps = 1e-6;

il int  read() { re int x = 0; re bool f = true; re char c = getchar(); while (c < 48 || c > 57) { if (c == '-') f = false; c = getchar(); } while (c >= 48 && c <= 57) x = (x << 3) + (x << 1) + c - 48, c = getchar(); return f ? x : -x; }
il void write(int x) { if (x < 0) putchar('-'), x = -x; if (x > 9) write(x / 10); putchar(x % 10 + 48); }
il void wel(int x) { write(x), putchar('\n'); }
il void wsp(int x) { write(x), putchar(' '); }

int n, L, R, a[N], s;

bitset <400005> sum, ans, cnt;

vector <int> p[N];

signed main() {
	for (int i = 1; i <= 4e5; ++ i)
	    for (int j = i; j <= 4e5; j += i)
	        p[j].push_back(i);
	        
    scanf("%lld%lld%lld", &n, &L, &R);
    for (int i = 1; i <= n; ++ i) scanf("%lld", a + i);
    sort (a + 1, a + n + 1);
    for (int i = 1; i < n; ++ i)
        if (a[i] == a[i + 1]) {
        	puts("0");
        	return 0;
		}
		
	for (int i = 1; i <= n; ++ i) sum[a[i]] = 1;
	for (int i = 1; i <= n; ++ i) {
		ans |= sum >> a[i];
	}
	for (int i = 1; i <= 4e5; ++ i) 
		if (ans[i]) 
			for (int j = 0; j < (int)p[i].size(); ++ j) cnt[p[i][j]] = 1;
		
	for (int i = 1; i <= 4e5; ++ i)
	    s += (!cnt[i] && (L <= i && i <= R));
	    
	if (R > 4e5) s += R - max(L, 400001ll) + 1;
	
	printf("%lld\n", s);
	    
    return 0;
}


```

---

## 作者：NaCly_Fish (赞：2)

[题目链接](https://www.luogu.com.cn/problem/P10171)

bitset 是啥，真不熟。

为了方便表示复杂度，设 $V=\max\{ a_i \}$。
****
首先可以断定只有 $a_i$ 互不相同时，答案才有可能不为零。

其次若两个不同整数的差为 $d$，则对于任意 $m \mid d$，它们都在模 $m$ 下同余。同时也容易证明这个条件是必要的，即 $m \nmid d$ 时这两个数模 $d$ 不同余。

我们就只需要求出「$a_i$ 两两之差的绝对值」构成的集合 $S$，对于所有 $x\in S$，将 $x$ 的所有正因子标记为不合法。注意 $k>V$ 时一定合法，所以只需求出 $[L,V]$ 区间内的合法个数即可。

标记不合法数时，直接枚举 $x\in S$ 找出其所有因子，通过线性筛预处理每个数的最小质因子，单次的复杂度可以做到严格的 $\sigma_0(x)$。这部分的总时间复杂度为
$$\sum_{i=1}^V\sigma_0(i)=\sum_{i=1}^V\sum_{d|i}1=\sum_{d=1}^V\lfloor V/d \rfloor = \Theta(V \log V)$$
如果从大到小枚举 $x$，可以对于已经被判定为不合法的 $x$ 直接跳过。这样复杂度似乎会更低（？），不过我不会算，还请指点一下。

最后还需要说明一下集合 $S$ 的求法。设
$$F(x)=\sum_{i=1}^nx^{a_i}$$
那么 $F(x)\times F(x^{-1})$ 的 $x^k \ (k \neq 0)$ 系数不为零的话，就说明 $|k|\in S$，这是可以用 FFT 来计算的。  
不过带负次项的多项式不好处理，可以将 $F(x^{-1})$ 整体变为 $x^VF(x^{-1})$，表现在系数上就是翻转了系数数组，这样就能直接卷积计算。

总时间复杂度为 $\Theta(n+V \log V)$。

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
#define N 1048579
#define ll long long
#define p 998244353
using namespace std;

inline void read(int &x){
    x = 0;
    char c = getchar();
    while(c<'0'||c>'9') c = getchar();
    while(c>='0'&&c<='9'){
        x = (x<<3)+(x<<1)+(c^48);
        c = getchar();
    }
}

inline int power(int a,int t){
    int res = 1;
    while(t){
        if(t&1) res = (ll)res*a%p;
        a = (ll)a*a%p;
        t >>= 1;
    }
    return res;
}

int siz;
int rev[N],rt[N];

void init(int n){
    int lim = 1;
    while(lim<=n) lim <<= 1,++siz;
    for(int i=0;i!=lim;++i) rev[i] = (rev[i>>1]>>1)|((i&1)<<(siz-1));
    int w = power(3,(p-1)>>siz);
    rt[lim>>1] = 1;
    for(int i=(lim>>1)+1;i!=lim;++i) rt[i] = (ll)rt[i-1]*w%p;
    for(int i=(lim>>1)-1;i;--i) rt[i] = rt[i<<1];
}

inline void dft(int *f,int n){
    static unsigned long long a[N];
    int x,shift = siz-__builtin_ctz(n);
    for(int i=0;i!=n;++i) a[rev[i]>>shift] = f[i];
    for(int mid=1;mid!=n;mid<<=1)
    for(int j=0;j!=n;j+=(mid<<1))
    for(int k=0;k!=mid;++k){
        x = a[j|k|mid]*rt[mid|k]%p;
        a[j|k|mid] = a[j|k]+p-x;
        a[j|k] += x;
    }
    for(int i=0;i!=n;++i) f[i] = a[i]%p;
}

inline void idft(int *f,int n){
    reverse(f+1,f+n);
    dft(f,n);
    int x = p-((p-1)>>__builtin_ctz(n));
    for(int i=0;i!=n;++i) f[i] = (ll)f[i]*x%p;
}

inline int getlen(int n){
    return 1<<(32-__builtin_clz(n));
}

int f[N],g[N];
int n,L,R,c,m,ans;
bool flag;
bool vis[N];

inline void update(int x){
    if(vis[x]) return;
    for(int i=1;i*i<=x;++i){
        if(x%i!=0) continue;
        vis[i] = vis[x/i] = true;
    }
}

int main(){
    read(n),read(L),read(R);
    for(int i=1;i<=n;++i){
        read(c);
        if(f[c]==1){
            flag = true;
            break;
        }
        f[c] = g[c] = 1;
        m = max(m,c);
    }
    if(flag){
        puts("0");
        return 0;
    }
    reverse(g,g+m+1);
    init(m<<1);
    int lim = getlen(m<<1);
    dft(f,lim),dft(g,lim);
    for(int i=0;i!=lim;++i) f[i] = (ll)f[i]*g[i]%p;
    idft(f,lim);
    for(int i=0;i<m;++i){
        //printf("%d ",f[i]==0?0:1);
        if(f[i]==0) continue;
        update(m-i);
    }
    for(int i=L;i<=min(m,R);++i)
        if(!vis[i]) ++ans;
    if(R>m) ans += R-m;
    printf("%d",ans);
    return 0;   
}
```

---

## 作者：TernaryTree (赞：1)

显然 $>V$ 的数一定满足条件。询问的区间就可以直接缩减到 $\Theta(V)$。

不妨统计 $[L,R]$ 之间不满足条件的数。

$$a_i\equiv a_j\pmod k$$

这等价于

$$k\mid |a_i-a_j|$$

瓶颈在于处理出所有可能的 $|a_i-a_j|$。

首先升序排序。令 $i<j$。枚举 $i$。不难发现这个时候的 $a_j-a_i$ 扔到一个桶里，等价于 $a_j-a_{i-1}$ 的桶整体移动 $a_i-a_{i-1}$ 位。联想到位运算，于是 bitset 解决即可。

最后暴力枚举 $[L,R]$ 区间可能的数，再枚举其倍数判断即可。

复杂度是 $\Theta\left(\dfrac{nV}{w}+V\log V\right)$。

```cpp
#include <bits/stdc++.h>
#define int long long

using namespace std;

const int maxn = 5e4;
const int V = 4e5;

int n, l, r, ans;
int a[maxn + 10];
int cnt[V + 10];
int vis[V + 10];
int cur[maxn + 10], idx;
bitset<V + 10> sta, now;

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin >> n >> l >> r;
	for (int i = 1; i <= n; i++) cin >> a[i];
	sort(a + 1, a + 1 + n);
	for (int i = 2; i <= n; i++) cnt[a[i] - a[i - 1]]++;
	if (cnt[0]) {
		cout << 0 << endl;
		return 0;
	}
	if (l > V) {
		cout << r - l + 1 << endl;
		return 0;
	}
	if (r > V) {
		ans = r - V;
		r = V;
	}
	for (int i = 1; i <= n; i++) now[a[i] - a[1]] = 1;
	sta |= now;
	for (int i = 2; i <= n; i++) {
		now >>= (a[i] - a[i - 1]);
		sta |= now;
	}
	for (int i = l; i <= r; i++) {
		bool fl = 0;
		for (int j = i; j <= V; j += i) {
			if (sta[j]) {
				fl = 1;
				break;
			}
		}
		ans += !fl;
	}
	cout << ans << endl;
	return 0;
}

```

---

## 作者：ln001 (赞：1)

首先特判掉出现重复元素导致的无解。

对于可行的 $ k $，有 $ k > \max_{a_i}$ 一定合法。

思考什么样的 $ k\leq \max_{a_i}$ 是不合法的。

其中一种情况是 $ a_i - a_j = k$。理解不了就举几个例子。证明可以从取模的本质为重复减法下手。

取模后的序列 $ b $ 值域上界越严格，$ k $ 合法的可能性越低。即若 $ k = x $ 时不合法，$ k = y $ 且 $ y \mid x $ 时一定不合法。

可以证明不存在非法其他情况。

得出结论，若 $ k $ 不合法，当且仅当存在 $ i,j $ 有 $ k \mid (a_i - a_j) $。

首先暴力筛出每个数的因数，具体做法是枚举一个数，再枚举它的倍数，复杂度 $ \sum\limits_{i = 1}^n \frac{n}{i} = n\sum\limits_{i = 1}^n \frac{1}{i}$ $\mathit = n{H}_n \approx  n\times \log_2 n$。[证明](https://www.cnblogs.com/sun123zxy/p/17331555.html#0.2%20%E8%B0%83%E5%92%8C%E6%95%B0%20H%20(%20n%20)%20/%20%E8%B0%83%E5%92%8C%E7%BA%A7%E6%95%B0:~:text=Euler%20%E5%B8%B8%E6%95%B0.%20%E5%9B%A0%E6%AD%A4-,%F0%9D%91%9B,%F0%9D%91%9B,-%E2%88%88)。

维护序列中所有的差直接用 bitset。

### 扔个预处理的代码

```cpp
void init()
{
    memset(ans, 1, sizeof ans);
    f(i, 1, M)
    {
        for (ll j = i; j <= M; j += i)
            factor[j].push_back(i);
    }

    f(i, 1, n) be[a[i]] = 1;
    if (be.count() != n)
    {
        puts("0");
        exit(0);
    }
    f(i, 1, n)
    {
        dif |= be >> a[i];
    }
    f(i, 1, M)
    {
        if (dif[i] == 0)
            continue;
        for (auto j : factor[i])
        {
            ans[j] = 0;
        }
    }
}
```

---

## 作者：luogu_gza (赞：1)

大家好，我非常喜欢暴力，所以我用暴力过了这道题。

我们考虑统计不合法方案，一个 $k$ 不合法当且仅当存在 $(i,j)$ 使得 $k$ 是 $|a_i-a_j|$ 的因数。

我们发现 $|a_i-a_j|$ 的值域较小，暴力枚举所有的 $(i,j)$，记录所有可能的 $|a_i-a_j|$。

暴力质因数分解每个出现过的 $|a_i-a_j|$，并记录下所有的因数，统计因数在 $[L,R]$ 内的个数 $t$，则答案为 $(R-L+1)-t$。

复杂度 $O(n^2)$，瓶颈在于枚举 $(i,j)$，先排序 $a$ 序列，然后枚举 $(i,j)(1 \leq i<j \leq n)$，并循环展开。

质因数分解的时候可以提前计算出枚举的上限，这样可以快点。

[reocrd](https://www.luogu.com.cn/record/147162988)

---

## 作者：zyn_ (赞：1)

# P10171 [DTCPC 2024] 取模

如果有两个相等的数，答案显然为 $0$。以下假设 $a_i$ 互不相等。

由于 $a_i$ 不超过 $4\times 10^5$，故大于 $4\times 10^5$ 的 $k$ 一定可行。于是不妨假设 $R\le 4\times 10^5$。

对任意 $i\neq j$，$|a_i-a_j|$ 都不超过 $4\times 10^5$。当且仅当 $k$ 不整除任意 $|a_i-a_j|$ 时，$k$ 是可行的。

于是只需算出有哪些 $|a_i-a_j|$，然后筛去不可行的 $k$ 即可。

令 $M=4\times 10^5+1$。令 $F(x)=\sum_{i=1}^{n}x^{a_i}$，$G(x)=\sum_{i=1}^{n}x^{M-a_i}$。

考虑多项式 $H(x)=F(x)G(x)-nx^M$。对于 $i\neq j$，$F(x)$ 中的 $x^{a_i}$ 与 $G(x)$ 中的 $x^{M-a_j}$，相乘得 $x^{M+(a_i-a_j)}$，恰可表示 $a_i-a_j$。

而对于 $i=j=1,2,\dots,n$，$F(x)$ 中的 $x^{a_i}$ 与 $G(x)$ 中的 $x^{M-a_j}$，相乘得 $x^M$，都被 $-nx^M$ 消除了。

这样，$H(x)$ 中系数不为 $0$ 的项即可表示所有 $a_i-a_j$。

只需算出 $H(x)$，用 FFT 即可。

## AC code

```cpp
#include<cstdio>
#include<cmath>
using namespace std;
#define N 4200000
#define M 400001
#define ll long long
#define mod 998244353
int n,l,r,ans;ll a[N],b[N],c[N],x[N];
bool u[N];
template<typename T>
inline void swap(T& a,T& b){T c=a;a=b;b=c;}
inline int max(int a,int b){return a>b?a:b;}
ll qpow(ll a,ll b,ll p){
    ll res=1;
    while(b)(b&1)&&(res=res*a%p),a=a*a%p,b>>=1;
    return res;
}
const ll inv3=qpow(3,mod-2,mod);
namespace polynomial{
	int rev[N];
	inline void _initfft(int n){
		for(int i=1;i<(1<<n);++i)rev[i]=(rev[i>>1]>>1)|((i&1)<<(n-1));
	}
	void fft(ll* x,int n,int type){
		_initfft(n);
		for(int i=0;i<(1<<n);++i)if(i<rev[i])swap(x[i],x[rev[i]]);
		ll wn,w0,a,b;
		for(int i=1;i<(1<<n);i<<=1){
			wn=qpow(type==1?3:inv3,(mod-1)/(i<<1),mod);
			for(int j=0;j<(1<<n);j+=(i<<1)){
				w0=1;
				for(int k=0;k<i;++k,w0=w0*wn%mod){
					a=x[j+k],b=w0*x[i+j+k]%mod;
					x[j+k]=(a+b)%mod,x[i+j+k]=(a-b+mod)%mod;
				}
			}
		}
	}
}
using polynomial::fft;
int main(){
	scanf("%d%d%d",&n,&l,&r);
	for(int i=1;i<=n;++i)scanf("%lld",&x[i]),++a[x[i]],++b[M-x[i]];
	int limit=1,power=0;
	while(limit<=(M<<1))limit<<=1,++power;
	fft(a,power,1);fft(b,power,1);
	for(int i=0;i<=limit;++i)c[i]=a[i]*b[i];
	fft(c,power,-1);
	for(int i=0;i<=(M<<1);++i)c[i]=c[i]*qpow(limit,mod-2,mod)%mod;
	c[M]-=n;
	for(int i=0;i<M;++i)c[i]=c[i+M];
	if(c[0]){puts("0");return 0;}
	if(r>M)ans+=(r-M),r=M;
	for(int i=1;i<=M;++i)u[i]=1;
	for(int i=1,k;i<M;++i)if(c[i]){
		//printf(" %d\n",i);
		for(int j=1;j*j<=i;++j)if(i%j==0)u[j]=0,u[i/j]=0;
	}
	for(int i=l;i<=r;++i)if(u[i])++ans;
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：wtcqwq (赞：1)

考虑不寻常的数据范围。

由 $n\le 5\times 10^4$ 可以猜测，解法的时间复杂度是 $\frac {n^2}w$，也就是使用 bitset。

然后我们发现 $L,R$ 的范围非常大，但是事实上可以用到的非常少。

- 如果 $a$ 内有重复的数，答案一定为 $0$

- 反之，对于 $k\ge \max a_i$，这样的 $k$ 一定合法。我们发现 $a_i \le 4\times 10^5$。所以需要的考虑的 $R$ 也只有 $4\times 10^5$。

问题已经转化成 $1\le L \le R \le 4\times 10^5$ 的情况。后文记 $\max a$ 为 $A$。

然后我们考虑怎么用 bitset 维护这个信息。

我们发现任意一组 $(a_i,a_j)\bmod k$ 相等，当且仅当 $k|a_i-a_j$。所以，我们维护 $a_i-a_j$ 和 $a_i-a_j$ 的约数。

维护 $a_i-a_j$ 的约数，复杂度变成了 $n^2\sqrt A$，显然过不了。我们考虑反过来考虑，对于一个数 $k$，如果存在正整数 $p$，使得存在 $(i,j)$ 满足 $a_i-a_j=pk$。则 $k$ 不满足要求。而维护某一个数的所有倍数，这是一个调和级数：$\frac A 1+\frac A 2+\frac A 3 + \cdots + \frac A A \approx A\log A$。

然后，我们考虑做差怎么用 bitset 维护，这是一个经典 tricks。先将所有 $a_i$ 标成 1，这个 01 数组记为 $G$，然后固定 $i$ 的所有 $a_j-a_i$ 所构成的 $01$ 数组即为 G 右移 $a_i$ 位的 bitset，这一步的时间复杂度是 $O(\frac n w)$。对于每一个 $a_i$ 都如此维护，即可得到我们所要的 $a_i-a_j$ 构成的 01 数组 $G'$。

对于一个数 $k$，枚举其在 $4\times 10^5$ 内的所有倍数 $pk$，如果有 $G'[pk]=1$ ，那么 $k$ 也不合法，因此 $G'[k]=1$。

然后不管用 count 还是枚举转化过的 $[L,R]$ 暴力计数都可以。对于所有 $G'[k]=1$ 的 $k$ 即代表 $k$ 不合法。

有一些细节。

---

## 作者：DerrickLo (赞：1)

先把询问差分一下，变成 $ans([1,R])-ans([1,L-1])$，然后我们考虑当存在 $(x,y)$ 满足 $a_x=a_y$ 时无解，所以先判掉。然后我们又发现当 $k>\max{a_i}$ 时必然成立，也判掉。

然后我们就把 $k$ 的取值范围缩小到 $\max a_i$ 的级别，然后我们可以对于每个 $k$，枚举它的倍数 $ki$，然后判断存不存在 $(x,y)$ 满足 $a_x-a_y=ki$ 就行了。

把 $a$ 排序后我们考虑一个朴素的 `dp`，设 $dp_{i,j}$ 表示存不存在一个数 $k$ 使得 $a_i-a_k=j$，设 $p=a_i-a_{i-1}$，那么我们很容易得到

$$dp_{i,j}=dp_{i-1,j-p}$$

然后我们发现这个式子可以用滚动数组优化，然后再用一个 `bitset` 优化一下就做完了。

时间复杂度 $O(\frac{nV}{w})$。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,l,r,a[50005],flag=1,maxx;
bitset<400005>f[2],s;
int calc(int x){
	if(x==0)return 0;
	int ans=0;
	if(x>=maxx)ans=x-maxx,x=maxx;
	for(int i=1;i<=x;i++){
		int flag=1;
		for(int j=i;j<=maxx;j+=i){
			if(s[j]){
				flag=0;
				break;
			}
		}
		if(flag)ans++;
	}
	return ans;
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>l>>r;
	for(int i=1;i<=n;i++)cin>>a[i],maxx=max(maxx,a[i]);
	sort(a+1,a+n+1);
	for(int i=2;i<=n;i++)flag&=(a[i]!=a[i-1]);
	for(int i=2;i<=n;i++){
		f[0].set(0,1);
		f[1]=f[0]<<(a[i]-a[i-1]);
		f[0]=f[1];
		s|=f[1];
	}
	if(!flag){
		cout<<0;
		return 0;
	}
	cout<<calc(r)-calc(l-1);
	return 0;
}
```

---

## 作者：Loser_Syx (赞：1)

考虑 `bitset` 解法。

首先我们知道当 $a_i$ 有重复时，答案一定为 $0$，因为重复的 $a_i$ 对一个数取模都一样。

然后发现当 $R > \max a_i$ 时，$k \in (\max a_i, R]$ 的答案一定都为 $1$，因为模出来都是 $a_i$。  
接着我们发现 $a_i$ 的顺序对答案其实并没影响（因为比较都是两个两个比的），为了方便可以对它排序。

我们开两个大小为 $\max a_i$ 的 `bitset`，一个记录当前 $a_i$ 与 $j \in [1,i)$ 的 $a_j$ 的差 $now$，一个记录是否存在的 $a_i - a_j$ 的值 $ans$。

我们发现 $i,j\ (j < i)$，$a_i - a_j = (a_{i-1} - a_j) + (a_i - a_{i-1})$，当我们知道 $i-1$ 的答案时，可以通过这个式子得出 $i$ 的答案。  
由于是从小到大排序的，所以 $a_i - a_j$ 一定是正的，我们对于 $now$ 的这个 `bitset`，直接左移 $a_i - a_{i-1}$ 位即可，同时令 $a_i - a_{i-1}$ 为真（方便起见也可在 $i-1$ 时令 $now_0$ 为真，在 $i$ 时左移 $a_i - a_{i-1}$ 位达成效果）。  
继续使用 $now$ 对于 $ans$ 进行或运算即可。


接下来我们考虑得出了每个可能的差值之后的 $k$ 的求法。

考虑对于当前差值 $x$，其表示存在一组 $a_i,a_j$ 使得 $a_i - a_j = x$，则 $a_i \equiv a_j \pmod x$，我们再提出一个 $x$ 的因子 $y$，则 $a_i = a_j + y \times \frac{x}{y}$，则 $a_i \equiv a_j \pmod y$，当 $k=y$ 的时候也存在 $a_i \bmod k$ 相等的情况。

则我们枚举 $X \in [L,\max a_i]$，若 $X$ 不为 $a_i \bmod k$ 相等的情况则为答案。

上述求法本来是 $O(V \sqrt V)$ 的（$V$ 为 $\max a_i$），约为 $3 \times 10^8$，再带上上面的 `bitset` 的 $O(\frac{nV}{\omega})$ 总和达到了 $6 \times 10^8$，超时了。

我们发现求 $x$ 的因子不如直接枚举 $y$ 的倍数，如果 $y$ 的倍数是一个差值的话，$y$ 也是存在 $a_i \bmod k$ 相等的情况的，这样我们对于 $y \in [1,V]$ 枚举并寻找倍数的复杂度是 $O(V \ln V)$ 的。

故总复杂度为 $O(\frac{nV}{\omega}+V \ln V)$。

```cpp
int a[50101];
signed main() {
	int n = read(), l = read(), r = read();
	for (int i = 1; i <= n; ++i) read(a[i]);
	sort(a + 1, a + 1 + n);
	for (int i = 1; i <= n; ++i) if (a[i] == a[i+1]) return puts("0"), 0;
	bitset<400101> ans, now;
	for (int i = 1; i <= n; ++i) {
		now = now << (a[i] - a[i-1]);
		ans |= now;
		now[0] = 1;
	}
	for (int i = 1; i <= a[n]; ++i) if (!ans[i]) {
		for (int j = i+i;j <= a[n]; j += i) if (ans[j]) {
			ans[i] = 1;
			break;
		}
	}
	int x = 0;
	if (r > a[n] && l > a[n]) return write(r - l + 1, '\n'), 0;
	if (r > a[n]) x += r - a[n], r = a[n];
	for (int i = l; i <= r; ++i) x += !ans[i];
	write(x, '\n'); 
	return 0;
}
```

---

## 作者：coderJerry (赞：0)

这是一篇口胡题解。
### 题目描述：[传送门](https://www.luogu.com.cn/problem/P10171)
### 题目分析
先考虑什么时候模 $k$ 相同，当然是两数之差能被 $k$ 整除时。如何判断？显然是找出 $n$ 个数所有差的所有因子一一判断。判断这一步实现较易，类似将欧拉筛反过来做一遍，这里不再阐述。但是枚举差的所有因子复杂度是 $O(n^2)$ 的可能会超时。那怎么办呢？

这就体现了 $\operatorname{FFT}$ 的厉害之处了。可以这样考虑：将所有 $a_i,(i∈[1,n])$ 和 $-a_i,(i∈[1,n])$ 存入两个多项式中，那么两项相乘，其指数不就是两个项的指数的差吗（也就是原来两数的差）？最后就是要特判掉两个多项式指数为非正数的情况即可。时间复杂度 $O(n\log n)$。

---

## 作者：NTT__int128 (赞：0)

首先，如果 $\exists i\neq j,a_i=a_j$，则一定不行。

发现 $k>4\times10^5$ 的一定成立，因此只考虑 $k\le4\times10^5$ 的。

然后转换一下：

$a_i\equiv a_j\pmod k\Leftrightarrow k|a_i-a_j$。

所以，如果存在 $a_i-a_j$ 是 $k$ 的倍数，则 $k$ 不行，否则 $k$ 行。

考虑如何快速求差。

令 $V=4\times10^5$。

把 $\{a_i\}$ 转换为一个长度为 $V$ 的序列 $\{b_j\}$，每一位为 $0/1$，表示有或没有。

然后 $t_k=\sum\limits_{i-j=k}b_ib_j$，翻转原序列，然后和原序列卷积即可。

时间复杂度：$\Theta(V\log V)+\Theta(\sum\limits_{i=1}^V\lfloor\frac Vi\rfloor)=\Theta(V\log V)$。

代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e6+5,V=4e5+5,M=998244353,G=3;
int qp(int a,int b){int s=1;while(b){if(b&1)s=s*a%M;a=a*a%M,b>>=1;}return s;}
int iG=qp(G,M-2);
int tr[N<<1];
using poly=vector<int>;
void NTT(poly &f,int len,bool flag)
{
	for(int p=2;p<=len;p<<=1){
		int l=p>>1;
		int tG=qp((flag?G:iG),(M-1)/p);
		for(int k=0;k<len;k+=p){
			int buf=1;
			for(int x=k;x<k+l;x++){
				int tp=buf*f[l+x]%M;
				f[l+x]=(f[x]-tp+M)%M;
				f[x]=(f[x]+tp)%M;
				buf=buf*tG%M;
			}
		}
	}
}
poly operator*(poly f,poly p){
	int n=f.size(),m=p.size();n--,m--;
	poly s;
	n+=m,m=1;
	for(m=1;m<=n;m<<=1);
	for(int i=0;i<m;i++)tr[i]=(tr[i>>1]>>1)|((i&1)?m>>1:0);
	while((int)f.size()<m+1)f.push_back(0);
	while((int)p.size()<m+1)p.push_back(0);
	for(int i=0;i<m;i++)if(i<tr[i])swap(f[i],f[tr[i]]);
	for(int i=0;i<m;i++)if(i<tr[i])swap(p[i],p[tr[i]]);
	NTT(f,m,0),NTT(p,m,0);
	for(int i=0;i<m;i++)s.push_back(f[i]*p[i]%M);
	for(int i=0;i<m;i++)if(i<tr[i])swap(s[i],s[tr[i]]);
	NTT(s,m,1);
	int im=qp(m,M-2);
	for(int i=0;i<m;i++)s[i]=s[i]*im%M;
	while((int)s.size()>n+1)s.pop_back();
	return s;
}
int n,l,r,a[N],c[N];
signed main(){
	cin>>n>>l>>r;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		if(c[a[i]])return cout<<0,0;
		c[a[i]]=1;
	}
	poly f(V+1),p(V+1);
	for(int i=0;i<=V;i++)f[i]=c[i],p[V-i]=c[i];
	f=f*p;
	int ans=0;
	for(int i=l;i<=min(r,V);i++){
		bool fl=1;
		for(int j=1;i*j<=V;j++)if(f[i*j+V]){fl=0;break;}
		ans+=fl;
	}
	ans+=max(0ll,r-V);
	cout<<ans;
	return 0;
}
```

---

## 作者：封禁用户 (赞：0)

设 $p_i$ 表示数值 $i$ 是否存在，$q_i$ 表示 $N-i$ 是否存在，$vis_i$ 表示两个值差为 $i$ 的数量

$vis_i=\sum\limits_{j+k=i+N}p_j\times q_k$

然后很明显是一个卷积的形式，然后直接 FFT/NTT 就可以了。

#### 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

#define endl '\n' 

const int N = 4e5, M = 2e6 + 1e5;
//const int N = 20, M = 20 + 1e5;
const int mod = 998244353;
const int G = 3, Gi = 332748118;

int n, l, r;
int a[M+5], b[M+5], re[M+5];
int p[N+5];

bool vis[N+5];

int mpow(int a, int b) {
	int s = 1;
	while (b) {
		if (b & 1) s = 1ll * s * a % mod;
		a = 1ll * a * a % mod;
		b >>= 1;
	}
	return s;
}

void NTT(int lim, int *a, int p) {
	for (int i = 0; i < lim; ++i)
		if (i < re[i]) swap(a[i], a[re[i]]);
	for (int mid = 1; mid < lim; mid <<= 1) {
		int wn = mpow(p > 0 ? G : Gi, (mod - 1) / (mid << 1));
		for (int i = 0; i < lim; i += (mid << 1)) {
			int w = 1;
			for (int j = 0; j < mid; ++j, w = 1ll * w * wn % mod) {
				int x = a[i + j], y = 1ll * w * a[i + j + mid] % mod;
				a[i + j] = (x + y) % mod, a[i + j + mid] = (x - y + mod) % mod;
			}
		}
	}
}

signed main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr), cout.tie(nullptr);
	cin >> n >> l >> r; int ans = r - l + 1;
	for (int i = 1; i <= n; ++i) {
		cin >> p[i];
		a[p[i]] = b[N - p[i]] = 1;
	}
	sort(p + 1, p + 1 + n);
	for (int i = 1; i < n; ++i) {
		if (p[i] == p[i + 1]) {
			cout << "0\n";
			return 0;
		}
	}
	int lim = 1, cnt = 0; while (lim <= 2 * N) lim <<= 1, ++cnt;
	for (int i = 0; i <= lim; ++i)
		re[i] = (re[i >> 1] >> 1) | ((i & 1) << (cnt - 1));
	NTT(lim, a, 1), NTT(lim, b, 1);
	for (int i = 0; i <= lim; ++i) a[i] = 1ll * a[i] * b[i] % mod;
	NTT(lim, a, -1);
	int inv = mpow(lim, mod - 2);
	for (int i = 0; i <= lim; ++i) a[i] = 1ll * a[i] * inv % mod;
	for (int i = 1; i <= N; ++i) {
		if (!a[i + N]) continue;
		for (int j = 1; j * j <= i; ++j) {
			if (i % j == 0) {
				if (l <= j && j <= r && !vis[j]) {
					vis[j] = 1;
					--ans;
				}
				if (i / j != j)
					if (l <= i / j && i / j <= r && !vis[i / j]) {
						vis[i / j] = 1;
						--ans;
					}
			}
		}
	}
	cout << ans << "\n";
	return 0;
}
```

---

## 作者：Albatross_LC (赞：0)

~~擦线 AC。~~

暴力即可。

为什么这样说呢？仔细读题，可以看出 $0 < a_i \le 4 \times 10 ^ 5$，而 $1 \le L \le R \le 10^9$，$n \le 5 \times 10 ^ 4$。当 $i$ 大于 $a_i$ 中的 $max$ 时，一定存在答案；当 $k < n$ 时，一定不存在答案，所以 $k$ 存在的范围很小，暴力可过。

### Code:

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 4e5 + 10;
int a[N], d[N], n, l, r, mx, i, ans;
map<int, int> m;
int main() {
	cin >> n >> l >> r;
	for (int i = 1; i <= n; i ++ ) {
		cin >> a[i];
		m[a[i]] ++ ;
		mx = max(mx, a[i]);
		if (m[a[i]] > 1) return printf("0"), 0;
	}
	for (i = max(l, n); i <= min(mx, r); i ++ ) { // 两处剪枝，即前面提到的。
		bool ok = 1;
		for (int j = 1; j <= n; j ++ ) {
			if (d[a[j] % i] == i) {	ok = 0;	break; }
			d[a[j] % i] = i;
		}
		if(ok) ans ++ ;
	}
	ans += max(0, r - i + 1);
	cout << ans;
}
```

---

## 作者：Link_Cut_Y (赞：0)

这是一篇暴力出奇迹的题解。

------------

给定序列 $\{a_n\}$ 和 $[L,R]$，问有多少个 $k\in [L,R]$ 满足 $a_i\bmod k$ 互不相同。

首先注意到，$\{a\}$ 中元素必定两两不同，否则取模后一定会有相同的数。接下来的讨论均在所有数字不相同的情况下进行。

接下来注意到，若 $k > \max\{a\}$，则对于所有 $a_i$，都有 $a_i \bmod k= a_i$。这样可以将模数的范围缩小到 $\max\{a\}$，也就是 $4 \times 10 ^ 5 $ 级别。

------------

- 做法 $1$：发现直接做并不好做，考虑 $a_i \bmod k \ne a_j \bmod k$ 的充要条件，即为 $|a_i - a_j| \equiv 0 (\bmod \ k)$。对于暴力的做法，我们暴力枚举 $i, j$，计算出 $|a_i - a_j|$ 的值，并存到桶中。对于 $k \le \max\{a\}$，我们只需要查看桶中是否存在 $1 \times k, 2 \times k, 3 \times k \cdots$ 即可。这个复杂度是 $O(n ^ 2 + V \ln V)$ 的，其中 $V$ 表示值域，即 $\max\{a\}$，后半部分是调和级数。

------------

- 做法 $2$：考虑优化这个思路。可以发现，复杂度的瓶颈是判断 $|a_i - a_j| = k$ 是否存在。这个部分可以使用 `bitset` 完成。将 $a_1 \sim a_n$ 存到一个 `bitset` 中，对于上面式子的判断，可以将该 `bitset` 左移 / 右移之后与原 `bitset` 进行与运算，若有 $1$ 则证明存在，否则不存在。这样，对于 $d$ 的枚举需要 $O(V)$ 的复杂度，每次 check 都需要 $O(\dfrac{V}{\omega})$，复杂度就是 $O(\dfrac{V ^ 2}{\omega})$。无法通过。

------------

众所周知，对于洛谷强大的评测机，$n = 10 ^ 5$ 的数据跑 $O(\dfrac{n ^ 2}{\omega})$ 是绰绰有余的。我们只需要减小一点常数就可以了。

考虑根号分治（可能叫做阈值分治？），设阈值 $B$，若 $n \le B$，则使用上述的 $O(n ^ 2)$ 算法。若 $n > B$，我们借鉴一下筛法的思路。

具体地，对于 $n > B$，我们随机选择一个数 $a_p$，对于 $\forall i \le n,i \ne p$，求出 $|a_i - a_p|$ 的值，对这个差值打上标记。我们可以发现，做第一次时，直接可以筛掉 $O(n)$ 级别的数。每次筛掉的数是递减的，但是总体上并不会很少。由于 $n$ 最大是 $5 \times 10 ^ 4$ 级别的，我们可以将这个筛子多做几遍，比如做个 $500$ 遍。

接下来，对于一个模数 $k$ 来说，枚举 $1 \times k, 2 \times k, 3 \times k \cdots$，并且在刚才筛出的桶里 check 一下有没有标记过。每一个被标记的数 $x$，在这一步都可以剪掉 $d(x)$ 个数。这样我们 $O(\dfrac{V}{\omega})$ 复杂度的 check 次数更少了。

最后，对于所有还合法的模数 $k$，进行做法 $2$ 所示过程即可。将阈值 $B$ 取 $\sqrt{10 ^ 7}$，这个算法的跑的极快，最慢的点都可以在 $200$ 毫秒内卡过。

后注：作者曾尝试证明阈值分治筛掉数的个数，但是并没有成功。如果有神仙知道请告诉我。另外，这个做法可能本身并不正确，仅供大家娱乐。

最后放一下代码：[参考代码](https://www.luogu.com.cn/paste/s1t2shir)。

upd：这份代码目前能蹲到最优解第二。

upd：上述算法在数据加强后已经不能通过。

接下来介绍更强的算法。

我们发现，上述筛子的过程也可以用 `bitset` 进行实现。所以不需要随机多个点。

这样可以保证复杂度 $O(\dfrac{n ^ 2}{\omega} +n \ln n)$。

```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <bitset>
#include <cmath>
#include <ctime>
#define rep(i, a, b) for (int i = (a); i <= (b); i ++ )
#define dep(i, a, b) for (int i = (a); i >= (b); i -- )

using namespace std;

const int N = 400010, V = 1e9;

bitset<N> s, st, t;
int n, l, r, a[N];
int B, mx, ans, bin[N];
signed main() {
    srand(time(0));
	scanf("%d%d%d", &n, &l, &r);
	rep(i, 1, n) scanf("%d", &a[i]);
	mx = *max_element(a + 1, a + n + 1);
	rep(i, 1, n) bin[a[i]] ++ ;
	rep(i, 1, mx) if (bin[i] >= 2) return puts("0"), 0;
	if (l > mx) return printf("%lld\n", r - l + 1), 0;
	if (r > mx) ans += r - mx, r = mx;
	rep(i, 1, n) s[a[i]] = 1;
	rep(i, 1, n) st |= (s >> a[i]);
	dep(d, r, l) {
	    if (st[d]) continue;
	    for (int i = d + d; i <= mx; i += d)
	        if (st[i]) { st[d] = 1; break; }
	    if (!st[d]) ans ++ ;
	}  printf("%d\n", ans);
	return 0;
}
```

---


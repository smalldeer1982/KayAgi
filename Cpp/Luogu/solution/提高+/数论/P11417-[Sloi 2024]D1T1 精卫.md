# [Sloi 2024]D1T1 精卫

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/p38htsuu.png)

## 题目描述

$f(x)$ 为积性函数，且满足 $f(p^k)=p^{2k}+k$（$p$ 为素数）。

令 $g(x)=\prod\limits_{d|x}f(d)\space \bmod\space (10^9+7)$ ，请计算 $g(i)\space (1\le i \le n)$ 的异或和。

## 说明/提示

**本题采用捆绑测试**

| Subtask | n | Score |
| :----------: | :----------: | :----------: |
| $1$ | $\le10^4$ | $10$ |
| $2$ | $\le 5\times 10^6$ | $30$ |
| $3$ | $\le 2\times 10^7$ | $30$ |
| $4$ | $\le 5\times10^7$ | $30$ |

对 $100\%$ 的数据，$1\le n \le 5\times10^{7} $。


## 样例 #1

### 输入

```
5```

### 输出

```
78```

## 样例 #2

### 输入

```
142857```

### 输出

```
67850062```

## 样例 #3

### 输入

```
10000000```

### 输出

```
505679580```

# 题解

## 作者：Polarisx (赞：3)

[题目传送门](https://www.luogu.com.cn/problem/P11417)。

## 思路

推式子，考虑从 $g(x)$ 推到 $g(x\times p^c),(p\bot x,p\in\mathbb{P})$，有

$$
\begin{aligned}
g(x\times p^c)&=\prod_{d\mid xp^c} f(d)\\
&-\prod_{k=0}^c \prod_{d\mid x}f(d)f(p^k)\\
&=\prod_{k=0}^c f(p^k)^{\sigma_0(x)}g(x)\\
&=g(x)^{c+1}g(p^c)^{\sigma_0(x)}
\end{aligned}
$$

空间只有 50MB，线性筛显然是行不通的，考虑枚举素数来获得合数，搜索过程中记录一下需要的值即可，但是我们发现 $g(p^c)^{\sigma_0(x)}$ 无法简单得到，因此时间复杂度必定带个 $\log$。

考虑空间换时间，5e7 的数组显然开不下，考虑分成两批来做，令 $\mathrm{mxp}(n)$ 表示 $n$ 的最大素因子，不妨将 $[1,n]$ 的数分成 $\mathrm{mxp}(i)\le \sqrt n$ 与 $\mathrm{mxp}(i)>\sqrt n$，对于第一批，搜索加上记忆化即可，对于第二批，由于它们至多只有一个大于 $\sqrt n$ 的素因子，单独计算这个素因子的贡献即可。

时间复杂度可近似看成 $\mathcal O (n)$。


```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

const int Mod=1e9+7;
const int Maxm=5e7+5,B=7200;
vector<int>prm;
bitset<Maxm>isp;
int ans;
int n,sz;
int mp[960][26][352];
int g[B+5],d[B+5];

inline ll ksm(ll a,int b,int mod){
	ll z=1;
	while(b){
		if(b&1) z=z*a%mod;
		a=a*a%mod;
		b>>=1;
	}
	return z;
}
void dfs(int p,int now,int G,int divs){
	ans^=G;
	if(now<=B){
		g[now]=1ll*G*G%Mod;d[now]=divs;
	}
	for(int i=p;i<sz;i++){
		int nz=now,nf=1,ng=1,nG=G;
		const int P=prm[i];
		if(1ll*nz*P>n) break;
		for(int c=1;;c++){
			if(1ll*nz*P>n) break;
			nz*=P; nf=1ll*nf*P%Mod*P%Mod; ng=1ll*ng*(nf+c)%Mod;
			nG=1ll*nG*G%Mod; int pw;
			if(!mp[i][c][divs]) mp[i][c][divs]=ksm(ng,divs,Mod);
			pw=mp[i][c][divs];
			dfs(i+1,nz,1ll*nG*pw%Mod,divs*(c+1));
		}
	}
}

int main(){
	scanf("%d",&n);
	for(int i=2;i<=min(n,B);i++){
		if(!isp.test(i)){
			prm.emplace_back(i);
			for(int j=i+i;j<=n;j+=i) isp.set(j);
		}
	}
	sz=prm.size();
	dfs(0,1,1,1);
	for(int i=B+1;i<=n;i+=2){
		if(!isp.test(i)){
			int v=(1ll*i*i+1)%Mod;
			for(int j=1;i*j<=n;j++){
				ans^=((1ll*g[j]*ksm(v,d[j],Mod))%Mod);
			}
		}
	}
	printf("%d\n",ans);
	return 0;
}

```

---

## 作者：xujindong_ (赞：1)

空间被卡了，没法线性筛。考虑直接搜每个数的质因数分解，同时维护这个 $g$，有 $g(xp^k)=g(x)^{k+1}g(p^k)^{d(x)}$，其中 $d(x)$ 为 $x$ 的因数个数。

现在瓶颈是这 $n$ 次快速幂。考虑只对 $\leq\sqrt n$ 的质因数搜索，记忆化快速幂的结果。此部分不超过 $O(\frac{\sqrt n}{\log n}d(n)\log n)\leq O(n)$。最后恢复最大质因数 $>\sqrt n$ 的部分，此时只有 $g(xp)=g(x)^2g(p)^{d(x)}$。枚举 $p>\sqrt n$，则 $x\leq\sqrt n$，此时 $d(x)$ 不超过 $60$，可以直接算出来，里面的 $g(xp)$ 变为 $O(1)$。

此时除了算 $g(p)^{d(x)}$ 都是线性的，这部分不太好分析。如果用光速幂可以把 $d(x)$ 降一点，但意义不大。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=1000000007;
int n,bn,prime[3001139],cnt,gpd[913][26][341],tg[7076],td[7076],maxd[7076],pre[65],ans;
bitset<50000005>vis;
template<typename T>T qpow(T a,T b,T n,T ans=1){
  for(a%=n;b;b>>=1)b&1&&(ans=1ll*ans*a%n),a=1ll*a*a%n;
  return ans;
}
int prime_init(int n,int cnt=0){
  vis.set(),vis[0]=vis[1]=0;
  for(int i=2;i<=n;i++){
    if(vis[i])prime[++cnt]=i;
    for(int j=1,v,p;i*prime[j]<=n;j++){
      p=prime[j],v=i*p,vis[v]=0;
      if(i%p==0)break;
    }
  }
  return cnt;
}
void dfs(int dep,int now,int g,int d){
  ans^=g;
  if(now<=bn)tg[now]=1ll*g*g%mod,td[now]=d;
  for(int i=dep;i<=cnt&&prime[i]<=bn&&1ll*prime[i]*now<=n;i++){
    int p=prime[i];
    for(int j=1,nxt=now*p,pk=p,gk=1ll*g*g%mod,gp=(1ll*p*p+1)%mod;;j++,nxt*=p,pk*=p,gk=1ll*gk*g%mod,gp=1ll*gp*(1ll*pk*pk%mod+j)%mod){
      if(!gpd[i][j][d])gpd[i][j][d]=qpow(gp,d,mod);
      dfs(i+1,nxt,1ll*gk*gpd[i][j][d]%mod,d*(j+1));
      if(1ll*nxt*p>n)break;
    }
  }
}
int main(){
  pre[0]=1,cin>>n,bn=sqrt(n),cnt=prime_init(n),dfs(1,1,1,1);
  for(int i=1;i<=bn;i++)maxd[i]=max(maxd[i-1],td[i]);
  for(int p=bn+1;p<=n;p++){
    if(!vis[p])continue;
    int gp=(1ll*p*p+1)%mod,d=maxd[n/p];
    for(int i=1;i<=d;i++)pre[i]=1ll*pre[i-1]*gp%mod;
    for(int i=1;i*p<=n;i++)ans^=1ll*tg[i]*pre[td[i]]%mod;
  }
  return cout<<ans<<'\n',0;
}
```

如果要求严格线性，也是可以的，$>\sqrt n$ 的质数 $O(\frac n{\log n})$ 个，这要求存在一种 $O(\log n)-O(1)$ 的光速幂。

考虑求底数的离散对数，转化为原根的幂，这个容易光速幂。众所周知，有 $O(\frac{p^\frac 34}{\sqrt{\log p}})-O(\log p)$ 的基于值域预处理的快速离散对数。预处理 $\sqrt p+1$ 内每个数的离散对数。因为 $\log ab=\log a+\log b$，因此可以求出 $\sqrt p+1$ 内质数的离散对数后线性筛。此时用 BSGS 求 $O(\frac{\sqrt p}{\log p})$ 个数的离散对数，注意到预处理 $a^{uB}$ 是可以共用的，因此可以通过修改 $B$ 把 $O(\frac{\sqrt p}{\log p})$ 放进根号里面。复杂度 $O(\frac pB+\frac{\sqrt p}{\log p}B)$，$B=p^{\frac 14}\sqrt{\log p}$ 最优。

求 $\log x$ 时，小于 $\sqrt p+1$ 直接查表。否则设 $u=\lfloor\frac px\rfloor,v=p\bmod x$，则 $p=ux+v$。根据 $x=\frac{p-v}u$，有 $\log x\equiv\log(-v)-\log u\equiv\log(p-1)+\log(v)-\log u\equiv\frac{p-1}2+\log(v)-\log u$；根据 $x=\frac{p+x-v}{u+1}$，有 $\log x=\log(x-v)-\log(u+1)$。$u,u+1,p-1$ 查表，取 $v,x-v$ 较小的递归，每次规模减半，复杂度 $O(\log p)$。总复杂度 $O(\frac{p^{\frac 34}}{\sqrt{\log p}})-O(\log p)$。这个 $\log$ 下面是 $\sqrt p$，所以可以认为是线性的。

---


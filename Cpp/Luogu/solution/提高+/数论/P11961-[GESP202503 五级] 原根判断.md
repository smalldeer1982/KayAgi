# [GESP202503 五级] 原根判断

## 题目背景

截止 2025 年 3 月，本题可能超出了 GESP 考纲范围。在该时间点下，原根是 NOI 大纲 8 级知识点（NOI 级），而相对简单的无需原根知识的做法中，使用的费马小定理与欧拉定理也属于 NOI 大纲 7 级知识点（提高级），且均未写明于 GESP 大纲中。需要注意，GESP 大纲和 NOI 大纲是不同的大纲。

若对题目中原根这一概念感兴趣，可以学习完成 [【模板】原根](https://www.luogu.com.cn/problem/P6091)。

## 题目描述

小 A 知道，对于质数 $p$ 而言，$p$ 的原根 $g$ 是满足以下条件的正整数：

+ $1<g<p$；
+ $g^{p-1}\bmod{p}=1$；
+ 对于任意 $1\le i<p-1$ 均有 $g^i\bmod{p}\neq1$。

其中 $a\bmod{p}$ 表示 $a$ 除以 $p$ 的余数。

小 A 现在有一个整数 $a$，请你帮他判断 $a$ 是不是 $p$ 的原根。

## 说明/提示

#### 数据范围

对于 $40\%$ 的测试点，保证 $3\le p\le10^3$。

对于所有测试点，保证 $1\le T\le20$，$3\le p\le10^9$，$1<a<p$，$p$ 为质数。

## 样例 #1

### 输入

```
3
3 998244353
5 998244353
7 998244353```

### 输出

```
Yes
Yes
No```

# 题解

## 作者：cjy0329 (赞：88)

> ### 题目背景
>截止 2025 年 3 月，本题可能超出了 GESP 考纲范围。在该时间点下，原根是 NOI 大纲 8 级知识点（NOI 级），且不属于 GESP 大纲内容。需要注意，GESP 大纲和 NOI 大纲是不同的大纲。
>若对题目中原根这一概念感兴趣，可以学习完成 [【模板】原根](https://www.luogu.com.cn/problem/P6091)。

~本萌新只是个五年级刚学oi的蒟蒻，本想考个五级，结果qwq……我的两道编程题都ac了 \\(^v^)/~
## 题意：

对于质数 $p$ 而言，$p$ 的原根 $g$ 是满足以下条件的正整数：

+ $1<g<p$；
+ $g^{p-1}\bmod{p}=1$；
+ 对于任意 $1\le i<p-1$ 均有 $g^i\bmod{p}\neq1$。

其中 $a\bmod{p}$ 表示 $a$ 除以 $p$ 的余数。

给出一个整数 $a$ 和质数 $p$，判断 $a$ 是不是 $p$ 的原根。

保证 $1\le T\le20$，$3\le p\le10^9$，$1<a<p$，$p$ 为质数。
## 思路：
要想让 $a$ 是 $p$ 的原根，必须满足三个条件：
1. $1<a<p$ ，这条已被约束条件满足了，无需判断；
2. $a^{p-1}\bmod{p}=1$，写个快速幂，$O(\log n)$ 就能判断；
3. 对于任意 $1\le i<p-1$ 均有 $a^i\bmod{p}\neq1$，如何判断？

枚举每个 $i$，依次用快速幂判断，但还是慢了。

正难则反，只需要知道 $a^i\bmod{p}=1$ 的结果，就知道 $a^i\bmod{p}\neq1$。

在 $[1,p-1)$ 中，那个 $i$ 可能满足 $a^i\bmod{p}=1$?

假设 $a^k\bmod{p}=1$。

$\therefore\\a^{k}\bmod p=1,\\\\a^{k+1}\bmod{p}=a,\\a^{k+2}\bmod{p}=a^2\bmod p,\\\dots\\a^{2k}\bmod p=1,\\\dots\\a^{3k}\bmod p=1,\\\dots\\a^{xk}\bmod p=1 \quad x\in[0,\infty]$

wow，有**周期**，每 $k$ 个一循环，每个**循环周期大小相等**！

因为 $a^{p-1}\bmod{p}\not=1$ 我们提前判段为错误，并退出了，所以现在的 $a$ 和 $p$ 一定满足 $a^{p-1}\bmod{p}=1$。

诶，我们忽略了 $0$，$a^0 \bmod p=1$！

也就是说我们要将 $1$ 到 $p-1$ 划分成若干段长度相同的循环周期，在 $[1,p-1)$ 中，只有每小段的末尾，也就是 $p-1$ 的因数的倍数，可能满足 $a^i\bmod{p}=1$。

又知道 $p-1$ 的一个因数 $x$，使得 $a^x\bmod{p}=1$，那么，这个因数的任意一个倍数 $y$，也都满足 $a^y\bmod{p}=1$。

所以只用找 $p-1$ 的每一个因数 $x$ 是否满足 $a^x\bmod{p}=1$，就可以推出"对于任意 $1\le i<p-1$ 均有 $a^i\bmod{p}\neq1$"这个条件了
## 代码（含注释）：
```cpp
//c++
#include<iostream>
#include<vector>
#define ll long long
using namespace std;
vector<ll>yin;       //表示p-1的因数
ll fpow(ll a,ll b,ll p){//快速幂
	a%=p;
	if(b==1)return a;
	if(b==0)return 1;
	if(b&1)return a*fpow(a*a%p,(b>>1),p)%p;
	return fpow(a*a%p,(b>>1),p);
}
void find_yin(ll x){	//找因数
	while(yin.size())   //清空
		yin.pop_back();    
	for(ll i=2;i*i<=x;i++){
		if(x%i==0){
			yin.push_back(i);
			yin.push_back(x/i);
		}
	}
	return ;
}
void doing(){//求出每次答案
	ll p,a;
	cin>>a>>p;
	if(fpow(a,p-1,p)!=1){  //条件2
		puts("No");
		return ;
	}
	find_yin(p-1);         //找p-1的因数
	for(int i=0;i<yin.size();i++){
		ll y=yin[i];       //枚举每个因数
		if(fpow(a,y,p)==1){//满足条件4(不满足条件3)
			puts("No");
			return ;
		}
	}
	puts("Yes");
	return ;
}
int main(){
	int t; 
	cin>>t;
	while(t--){
		doing();
	}
	return 0;
}
```
### 复杂度：
- 时间：$O(T\times(\log n\times\sqrt n+\log n+\sqrt n))$
- 空间：$O(\sqrt n)$
### 鸣谢
- [@_Ultra_Pitcher_](https://www.luogu.com.cn/user/1713730)
- [
@Chase12345](https://www.luogu.com.cn/user/946909)

---

## 作者：dg114514 (赞：44)

普及组选手表示不需要什么费马小定理，只需要快速幂即可（？）\
首先，显然的，$a^{xy} = (a^x) ^y$。然后可以假设其中 $a^x\equiv 1\pmod p$，则有 $a^{xy}=(a^x)^y\equiv 1 ^ y\equiv1\pmod p$。所以我们可以 $O(\sqrt{p})$ 分解 $p-1$ 的质因数，然后检查 $p-1$ 的每一个因数 $f$ 是否满足 $a^f\equiv 1\pmod p$，如果有**任意**一个因数满足上述条件，直接输出 `No`。如果所有因数均不满足，输出 `Yes`。总复杂度 $O(T \sqrt{p}\log p)$。

### 代码不刻意压 25 行

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int qpow(int a,int b,int p){
	int res=1;
	while(b){
		if(b&1)res=res*a%p;
		b>>=1,a=a*a%p;
	}
	return res;
}
void solve(){
	int a,p;
	cin>>a>>p;
	for(int i=2;i<=sqrt(p-1);i++)
		if((p-1)%i==0)
			if(qpow(a,i,p)==1||qpow(a,(p-1)/i,p)==1){
				puts("No");return;
			}
	puts("Yes");
}
signed main(){
	int T;cin>>T;
	while(T--) solve();
} 
```

---

## 作者：fkxr (赞：18)

第二次场切蓝题，发题解纪念一下
![](https://cdn.luogu.com.cn/upload/image_hosting/kob6h9zc.png)

前置知识：费马小定理，快速幂，$O(\sqrt{x})$ 的求 $x$ 的因数

## 分析：

题目告诉我们原根的定义：
- $1<g<p$；
- $g^{p - 1}\bmod{p}=1$；
- 对于任意 $1\leq i<p - 1$ 均有 $g^i\bmod{p}\neq1$。

题目保证 $p$ 是质数，$1<g<p$。根据费马小定理，$g^{p - 1}\bmod{p}=1$ 总是成立的，题目也保证 $1<g<p$，我们只要判断第三条就行了。

打表可以观察到对于任意 $1\leq i<p - 1$ 均有 $g^i\bmod{p}\neq0$。这也很好理解：如果出现 $0$ 的话，就有 $g^{p - 1}\bmod{p}=0$，不符合费马小定理了。

如果 $g$ 是 $p$ 的原根，则对于 $1\leq i\leq p - 1$ ，$g^i\bmod{p}$ 是 $1\sim p$ 的排列，如果不是 $p$ 的原根，则对于 $1\leq i\leq p - 1$ ，$g^i\bmod{p}$ 存在循环节，且循环节的长度是 $p - 1$ 的因数，循环节以 $1$ 结尾（请你思考这是为什么）。

接下来就简单了，枚举 $p - 1$ 的因数（假设为 $x$）（不包含 $p - 1$ 自己），判断 $g^{x}\bmod{p}$ 是否为 $1$，是则 $g$ 不是 $p$ 的原根。

## 时间复杂度：

求 $p - 1$ 的因数时间复杂度大致为 $O(\sqrt{p})$ ，每次判断的时间复杂度为 $O(\log p)$，总时间复杂度为 $O(T\sqrt{p}\log p)$。

## code
仅供对拍。
```cpp
//Do not hack it
#include <bits/stdc++.h>
#define endl cerr<<"------------------I Love Sqrt Decomposition------------------\n";
#define int long long
using namespace std;
#ifdef __linux__
#define gc getchar_unlocked
#define pc putchar_unlocked
#endif

#ifndef __linux__
#define gc getchar
#define pc putchar
#endif

#define ds(x) (x=='\r'||x=='\n'||x==' ')
#define MAX 20
namespace G {
	template<typename T>inline void r(T& a) { a = 0; char ch = gc(); bool ok = 0; for (; ch < '0' || ch>'9';)ok ^= (ch == '-'), ch = gc(); for (; ch >= '0' && ch <= '9';)a = (a << 1) + (a << 3) + (ch ^ 48), ch = gc(); if (ok)a = -a; }
	template<typename T>inline void w(T a) { if (a == 0) { pc('0'); return; }static char ch[MAX]; int till = 0; if (a < 0) { pc('-'); for (; a;)ch[till++] = -(a % 10), a /= 10; } else for (; a;)ch[till++] = a % 10, a /= 10; for (; till;)pc(ch[--till] ^ 48); }
	struct Srr {
		inline Srr operator>>(int& a) { r(a); return{}; }
		inline Srr operator>>(char& ch) { ch = gc(); for (; ds(ch);)ch = gc(); return{}; }
		inline Srr operator>>(string& s) { s = ""; char ch = gc(); for (; ds(ch);)ch = gc(); for (; !(ds(ch) || ch == EOF);) { s.push_back(ch); ch = gc(); }return{}; }
		template<typename T>inline Srr operator<<(T& a) { r(a); return{}; }
		inline void is(int n, string& s) { s = ""; char ch = gc(); for (; ds(ch);)ch = gc(); for (; n--;) { s.push_back(ch); ch = gc(); } }
	}in;
	struct Sww {
		inline Sww operator<<(const int a) { w(a); return{}; }
		inline Sww operator<<(const char ch) { pc(ch); return{}; }
		inline Sww operator<<(const string s) { for (int i = 0; i < s.size(); i++)pc(s[i]); return{}; }
		template<typename T>inline Sww operator>>(const T a) { w(a); return{}; }
	}out;
	namespace __STL {
		const bool __is_P[] = { 0,0,1,1,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,1 };
		inline bool IP(const int a) { if (a <= 29)return __is_P[a]; if (a % 2 == 0 || a % 3 == 0 || a % 5 == 0)return 0; for (int i = 6;; i += 6) { if (((i + 1) * (i + 1)) > a)return 1; if (a % (i + 1) == 0)return 0; if (((i + 5) * (i + 5)) > a)return 1; if (a % (i + 5) == 0)return 0; } }
		inline int power(int a, int b, const int mod = -1) { int ans = 1; if (mod == -1) { for (; b;) { if (b & 1)ans *= a; b >>= 1; a *= a; }return ans; }for (; b;) { if (b & 1)ans = ans * a % mod; b >>= 1; a = a * a % mod; }return ans; }
	}
}
using G::in; using G::out;
#undef ds
using namespace G::__STL;
#define eout cerr

signed main() {
	int T;
	in>>T;
	for(;T--;){
		int x,p;
		in>>x>>p;
		bool ok=1;
		for(int i=2;i*i<=p-1;i++){
			if((p-1)%i){
				continue;
			}
			if(power(x,i,p)==1||power(x,(p-1)/i,p)==1){
				ok=0;
				break;
			}
		}
		out<<(ok?"Yes":"No")<<'\n';
	}
	return 0;
}
```

[提交记录](https://www.luogu.com.cn/record/209861178)

## update:
```
2025/3/28 增加图片cdn.luogu.com.cn/upload/image_hosting/kob6h9zc.png
```

---

## 作者：DFM_O (赞：12)

## [P11961 题目](https://www.luogu.com.cn/problem/P11961)

### 解题思路
由原根的性质，当 $p\ge3$ 时，$g$ 为 $p$ 的原根，当且仅当 $\gcd(g,p)=1$ 且对于所有 $\varphi(p)$ 的质因数 $q$，都有 $g^{\frac{\varphi(p)}{q}}\bmod p\not=1$，因为若 $\gcd(g,p)\not=1$，则 $g^{\varphi(p)}\bmod p\not=1$。

而对于 $g^{\frac{\varphi(p)}{q}}\bmod p\not=1$ 这个条件，必要性是显然的，下面对于充分性进行证明：若存在一个最小的 $i$ 满足 $i<\varphi(p)$ 且 $g^i\bmod p=1$，则 $i$ 一定为 $\varphi(p)$ 的因数，又因为 $i\not=\varphi(p)$，所以一定存在一个 $\varphi(p)$ 的质因数 $q$，满足 $\frac{\varphi(p)}{q}$ 为 $i$ 的倍数，此时 $g^{\frac{\varphi(p)}{q}}\bmod p=1$，于是我们便知道，只要对于所有的 $\varphi(p)$ 的质因数 $q$，都有 $g^{\frac{\varphi(p)}{q}}\bmod p\not=1$，那么就不会存在 $i\in[1,\varphi(p)-1]$，满足 $g^i\bmod p=1$。

在本题中，由于 $p$ 为质数，于是 $\varphi(p)=p-1$，枚举 $p-1$ 的质因数并检查即可。

### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
inline bool pd(int a)
{
	if(a<2)
		return false;
	for(int i=2;i*i<=a;i++)
	{
		if(a%i==0)
			return false;
	}
	return true;
}
inline long long poww(long long a,long long b,long long p)
{
    long long ss=1;
    while(b)
    {
        if(b&1)
            ss=ss*a%p;
        a=a*a%p;
        b>>=1;  
    }
    return ss;
}
signed main()
{
	ios::sync_with_stdio(false);
	int t;
	cin>>t;
	while(t--)
	{
		int g,p;
		cin>>g>>p;
		int phi=p-1;
		if(__gcd(g,p)!=1)
		{
			cout<<"No\n";
			continue;
		}
		int pdd=0;
		for(int i=1;i<=sqrt(phi);i++)
		{
			if(phi%i==0)
			{
				if(pd(i)==1&&poww(g,phi/i,p)==1||pd(phi/i)==1&&poww(g,i,p==1))
				{
					pdd=1;
					break;
				}
			}
		}
		if(pdd==0)
			cout<<"Yes\n";
		else
			cout<<"No\n";
	}
	return 0;
}
```

---

## 作者：Genius_Star (赞：12)

[**或许更好的阅读体验。**](https://www.cnblogs.com/rgw2010/p/18631656)

# 思路：

先讲一些前置知识。

## 阶与原根：

注意 $(a, b)$ 表示 $\gcd(a, b)$。

### 阶：

若 $(a, m) = 1$，且 $x$ 是**最小**的满足同余式 $a^x \equiv 1 \pmod m$ 的**正整数**，则称 $x$ 是 $a$ 模 $m$ 意义下的**阶**，记作 $\delta_m(a)$。

对于**阶**有以下的性质：

- $a, a^2, \cdots, a^{\delta_m(a)}$ **两两不同余**（**性质一**）。

> **证明：** 考虑反证法，若存在 $a^x \equiv a^y \pmod m(x < y)$，因为 $(a, m) = 1$，故 $a^{y - x} \equiv 1 \pmod m$，且由于 $0 < y - x < \delta_m(a)$，与阶的定义矛盾。

- 若 $a^n \equiv 1 \pmod m$，则有 $\delta_m(a) \mid n$（**性质二**）。

> **证明：** 设 $n = k\delta_m(a) + r (0 \le r < \delta_m(a))$，则有 $a^r \equiv a^r(a^{\delta_m(a)})^k \equiv a^n \equiv 1 \pmod m$，那么 $r$ 只能为 $0$，否则会与阶的定义矛盾；故 $\delta_m(a) \mid n$。

- 若 $(a, m) = (b, m) = 1$，则满足 $\delta_m(ab) = \delta_m(a) \times \delta_m(b)$ 的**充分必要条件**是 $(\delta_m(a), \delta_m(b)) = 1$（**性质三**）。

> **证明：**  
>
> **必要性：** 若 $\delta_m(ab) = \delta_m(a) \times \delta_m(b)$。  
>
> 因为 $a^{\delta_m(a)} \equiv b^{\delta_m(b)} \equiv 1 \pmod m$，那么 $(ab)^{\operatorname{lcm}(\delta_m(a), \delta_m(b))} \equiv 1 \pmod m$，根据**性质二**得：
> $$\begin{aligned} \delta_m(ab) &\mid \operatorname{lcm}(\delta_m(a), \delta_m(b)) \\ \Rightarrow\delta_m(a) \times \delta_m(b) &\mid \operatorname{lcm}(\delta_m(a), \delta_m(b)) \end{aligned}$$
> 且由于 $\operatorname{lcm}(a, b) \le ab$，故 $\operatorname{lcm}(\delta_m(a), \delta_m(b)) = \delta_m(a) \times \delta_m(b)$，那么 $(\delta_m(a), \delta_m(b)) = 1$。 
>
> **充分性：** 若 $(\delta_m(a), \delta_m(b)) = 1$。
>
> 由于 $(ab)^{\delta_m(a) \delta_m(b)} \equiv 1 \pmod m$，那么由**性质二**得 $\delta_m(ab) \mid \delta_m(a) \delta_m(b)$。
> 
> 然后推式子：
> $$\begin{aligned} (ab)^{\delta_m(ab)} \equiv 1 \pmod m  \\ \Rightarrow \left((ab)^{\delta_m(ab)} \right)^{\delta_m(b)} \equiv 1 \pmod m \\ \Rightarrow a^{\delta_m(ab) \delta_m(b)} \left(b^{\delta_m(b)}\right)^{\delta_m(ab)}\equiv 1\pmod m \\ \Rightarrow a^{\delta_m(ab) \delta_m(b)}\equiv 1 \pmod m \end{aligned}$$
> 故由**性质二**得 $\delta_m(a) \mid \delta_m(ab) \delta_m(b)$，但是由于 $(\delta_m(a), \delta_m(b)) = 1$，故 $\delta_m(a) \mid \delta_m(ab)$；同理在上面取 $\left((ab)^{\delta_m(ab)} \right)^{\delta_m(a)}$ 也可以得到 $\delta_m(b) \mid \delta_m(ab)$；那么得到 $\delta_m(a) \delta_m(b) \mid \delta_m(ab)$。
> 
> 此时 $\delta_m(ab) \mid \delta_m(a) \delta_m(b)$ 且 $\delta_m(a) \delta_m(b) \mid \delta_m(ab)$，那么就推得 $\delta_m(ab) = \delta_m(a) \delta_m(b)$。

- 若 $(a, m) = 1$，那么 $\delta_m(a^k) = \frac{\delta_m(a)}{(\delta_m(a), k)}$（**性质四**）。

> **证明：**  
> 首先容易有：
> $$a^{\operatorname{lcm}(k, \delta_m(a))} \equiv (a^k)^{\frac{\operatorname{lcm}(k, \delta_m(a))}{k}} \equiv 1 \pmod m$$
> 其中 $\frac{\operatorname{lcm}(k, \delta_m(a))}{k} = \frac{\delta_m(a)}{(\delta_m(a), k)}$，根据**性质二**得 $\delta_m(a^k) \mid \frac{\delta_m(a)}{(\delta_m(a), k)}$。
>
> 然后可以注意到：
> $$(a^k)^{\delta_m(a^k)} \equiv 1 \equiv a^{k\delta_m(a^k)} \pmod m$$
> 那么根据**性质二**得 $\delta_m(a) \mid k \delta_m(a^k) \Rightarrow \frac{\delta_m(a)}{(\delta_m(a), k)} \mid \delta_m(a^k)$。
> 
> 那么就可以得到 $\delta_m(a^k) = \frac{\delta_m(a)}{(\delta_m(a), k)}$。

### 原根：

若 $(g, m) = 1$，且 $\delta_m(g) = \varphi(m)$，则称 $g$ 为模 $m$ 意义下的**原根**。

> **引理：欧拉定理**
> 
> 若 $(a, m) = 1$，那么 $a^{\varphi(m)} \equiv 1 \pmod m$。
>
> **证明：**
> 
> 设 $x_1, x_2, \cdots, x_{\varphi(m)}(\forall i \in [1, \varphi(m) - 1], x_i < x_{i + 1})$ 为 $[1, m]$ 中与 $m$ 互质的这 $\varphi(m)$ 个数；那么显然这个数列满足两两不同且与 $n$ 的都互质。
> 
> 然后构造 $y_i = ax_i \bmod m$，可以证明 $y$ 这个数列也满足两两不同且与 $n$ 的都互质。
>  > 考虑**反证法**，若存在  $y_i = y_j(i < j)$，那么 $ax_i \equiv ax_j \pmod m$，且由于 $(a, m) = 1$，那么 $x_i \equiv x_j \pmod m$，矛盾。  
>  > 根据辗转相除法的性质，有 $(a, b) = (b \bmod a, b)$，那么这里 $(ax_i, m) = 1 = (ax_i \bmod m, m)$。
> 
> 注意到 $[1, m]$ 中与 $m$ 互质的那些数是固定的，故集合 $x$ 等于集合 $y$，那么有：
> $$\prod_{i = 1}^{\varphi(m)}x_i \equiv \prod_{i = 1}^{\varphi(m)} ax_i \pmod m$$
> 由于 $(x_i, m) = 1$，是可消的，故：
> $$a^{\varphi(m)} \equiv 1 \pmod m$$
> 证毕。

现在我们知道 $g^{\varphi(m)} \equiv 1 \pmod m$，根据**阶的性质二**可以得到 $\delta_m(g) \mid \varphi(m)$。

故若 $\delta_m(g) = \varphi(m)$ 当且仅当对于 $\varphi(m)$ 的其它因子 $x$，都不满足 $g^x \equiv 1 \pmod m$。

这样其实就可以判定了，但是有点弱；考虑加强一下，即**原根判定定理：** 若 $(m, p) = 1$，且对于任意一个 $\varphi(m)$ 的质因子 $p$，都满足 $g^{\frac{\varphi(m)}{p}} \not\equiv 1 \pmod m$，那么 $g$ 是 $m$ 的原根。

> **证明：**
> 
> 首先**必要性**是显然的，因为不可能存在 $x$ 使得 $x < \delta_{m}(g)$ 使得 $g^x \equiv 1 \pmod m$。
> 
> 现在来证**充分性**，考虑**反证法**，若 $g$ 不是原根，那么有 $\delta_m(g) \mid \varphi(m)$ 且 $\delta_m(g) < \varphi(m)$，那么肯定存在至少一个 $\varphi(m)$ 的质因子 $p$ 满足 $\delta_m(g) \mid \frac{\varphi(m)}{p}$，那么就有 $g^{\frac{\varphi(m)}{p}} \equiv 1 \pmod m$，与假设矛盾。


**原根个数定理：** 若一个数 $m$ 有原根，则原根个数为 $\varphi(\varphi(m))$。

> **证明：**
> 
> 首先设我们求得的最小原根是 $g$，根据**阶的性质四**，有 $\delta_m(g^k) = \frac{\delta_m(g)}{(\delta_m(g), k)}$，因为 $\delta_m(g) = \varphi(m)$，故当 $(k, \varphi(m)) = 1$ 时 $\delta_m(g^k) = \delta_m(g) = \varphi(m)$ 也是一个原根。
> 
> 那么满足 $(k, \varphi(m)) = 1$ 的  $k$ 的个数是 $\varphi(\varphi(m))$，得证。

如何找一个数 $m$ 的全部原根？

> **引理：最小原根大小**
> 
> 素数 $m$ 的最小原根大概在 $O(m^{0.25})$。

故我们可以暴力去找最小原根 $g$，根据**判定定理**判断即可，然后直接枚举 $k$，若 $(k, \varphi(m)) = 1$ 时 $g^k$ 也是原根，暴力枚举即可。


但是若 $m$ 不存在原根，我们至少要 $O(N \log N)$ 去判断，如何进行快速判断？

这里先给结论：

- 若 $m$ 存在原根，当且仅当 $m = 2, 4, p^{\alpha}, 2p^{\alpha}$，其中 $p$ 是奇素数。

直接分解质因数判断即可。

对于本题，我们使用上述的**原根判定定理**即可，时间复杂度为 $O(T \sqrt{p} \log p)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/hash_policy.hpp>
#define Add(x, y) (x + y >= mod) ? (x + y - mod) : (x + y)
#define lowbit(x) x & (-x)
#define pi pair<ll, ll>
#define pii pair<ll, pair<ll, ll>>
#define iip pair<pair<ll, ll>, ll>
#define ppii pair<pair<ll, ll>, pair<ll, ll>>
#define ls(k) k << 1
#define rs(k) k << 1 | 1
#define fi first
#define se second
#define full(l, r, x) for(auto it = l; it != r; ++it) (*it) = x
#define Full(a) memset(a, 0, sizeof(a))
#define open(s1, s2) freopen(s1, "r", stdin), freopen(s2, "w", stdout);
#define For(i, l, r) for(register int i = l; i <= r; ++i)
#define _For(i, l, r) for(register int i = r; i >= l; --i)
using namespace std;
using namespace __gnu_pbds;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
bool Begin;
const int N = 1e6 + 10; 
inline ll read(){
    ll x = 0, f = 1;
    char c = getchar();
    while(c < '0' || c > '9'){
        if(c == '-')
          f = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9'){
        x = (x << 1) + (x << 3) + (c ^ 48);
        c = getchar();
    }
    return x * f;
}
inline void write(ll x){
	if(x < 0){
		putchar('-');
		x = -x;
	}
	if(x > 9)
	  write(x / 10);
	putchar(x % 10 + '0');
}
int T, n, d, pn;
vector<int> V;
inline int qpow(int a, int b, int mod){
	int ans = 1;
	while(b){
		if(b & 1)
		  ans = 1ll * ans * a % mod;
		a = 1ll * a * a % mod;
		b >>= 1;
	}
	return ans;
}
inline void get(int x){
	V.clear();
	for(int i = 2; i * i <= x; ++i){
		if(x % i == 0){
			V.push_back(i);
			while(x % i == 0)
			  x /= i;
		} 
	}
	if(x > 1)
	  V.push_back(x);
}
inline int getphi(int n){
    int t = n, a = n;
    for(int i = 2; i * i <= a; ++i){
        if(a % i == 0){
        	t = t / i * (i - 1);
            while(a % i == 0)
			  a /= i;
        }
    }
    if(a > 1)
	  t = t / a * (a - 1);
    return t;
}
inline bool chk(int x){
	if(__gcd(x, n) != 1)
	  return 0;
	for(auto v : V)
	  if(qpow(x, pn / v, n) == 1)
	    return 0;
	return 1;
}
inline void solve(){
	d = read(), n = read();
	pn = getphi(n);
	get(pn);
	if(chk(d))
	  puts("Yes");
	else
	  puts("No");
}
bool End;
int main(){
	T = read();
	while(T--)
	  solve();
	cerr << '\n' << abs(&Begin - &End) / 1048576 << "MB";
	return 0;
}
```

---

## 作者：01bit (赞：7)

根据费马小定理，当 $p$ 为质数时，必有 $a^{p-1}\equiv1\pmod p$。

因为 $a\ne1$，所以显然所有满足 $1\le b\le p,a^b\equiv1\pmod p$ 的 $b$ 都是 $p-1$ 的因数。

可以用 $O(\sqrt p)$ 的时间找到 $p-1$ 的所有因数，用 $O(\log p)$ 的快速幂判断，总时间复杂度为 $O(T\sqrt p\log p)$。


```cpp
#include <iostream>
using namespace std;
using ll = long long;
ll a, p;
ll qpow(ll x, ll y) {
    ll z = 1;
    while (y) {
        if (y & 1)
            z = z * x % p;
        x = x * x % p;
        y >>= 1;
    }
    return z;
}
void solve() {
    cin >> a >> p;
    for (int i = 2; i * i <= p - 1; i++) {
        if ((p - 1) % i)
            continue;
        if (qpow(a, i) == 1) {
            cout << "No\n";
            return;
        }
        if (qpow(a, p / i) == 1) {
            cout << "No\n";
            return;
        }
    }
    cout << "Yes\n";
}
int main() {
    ll t;
    cin >> t;
    for (ll i = 1; i <= t; i++)
        solve();
    return 0;
}
```

---

## 作者：lmz105 (赞：7)

### 思路
根据费马小定理可知，对于每个质数 $p$ 和与它互质的数 $a$，都有 $a^{p-1} \equiv 1 \pmod{p}$，因为 $1 < a < p-1$，所以第二个条件一定成立。我们将原来的 $a^{p-1}$ 变成 $x (x \in \mathbb N)$ 个 $a^{p-1}$，就能得到 $a^{x(p-1)} \equiv 1^x \pmod{p}$，这说明它存在周期，如果 $a$ 不是 $q$ 的原根，那么它有一个大于 $1$ 且小于 $p-1$ 的整数 $k$，使得 $a^k \equiv 1 \pmod{p}$，因为周期的存在，所以 $k$ 是 $p-1$ 的因数，我们只需要枚举所有 $p-1$ 的因数 $i$ 判断有没有 $a^i \equiv 1 \pmod{p}$ 就行了。

### 代码
```cpp
#include <bits/stdc++.h>
#define ll long long
//#define rw() ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
#ifndef rw()
#ifdef __linux__
#define getchar getchar_unlocked
#define putchar putchar_unlocked
#endif

namespace FX {
	template<typename T> inline void r(T &in) {
		in = 0;
		bool bo = 0;
		char ch = getchar();
		while (!isdigit(ch)) {
			bo ^= (ch == '-');
			ch = getchar();
		}
		while (isdigit(ch))
			in = (in << 1) + (in << 3) + (ch ^ 48), ch = getchar();
		if (bo) {
			in = -in;
		}
	}
	template<typename T> inline void w(T out) {
		static char op[25];
		int top = 0;
		if (out < 0) {
			putchar('-');
			do {
				op[++top] = -(out % 10) + 48, out /= 10;
			} while (out);
		} else {
			do {
				op[++top] = out % 10 + 48, out /= 10;
			} while (out);
		}
		while (top)
			putchar(op[top--]);
		putchar(' ');
	}
	template<typename T, typename... Ts> inline void r(T &in, Ts &... ins) {
		r(in), r(ins...);
	}
	template<typename T, typename... Ts> inline void w(T out, Ts... outs) {
		w(out), w(outs...);
	}
	inline void w(const char *p) {
		while (*p) {
			putchar(*p++);
		}
	}
}
using namespace FX;
#undef getchar
#undef putchar
#endif
using namespace std;
ll T, n, m, val;
bool bo;

struct F {
	ll num, cnt;
};
vector<F>v;

ll fast_pow(ll x, ll y, ll z) {
	ll num = 1, base = x;
	while (y) {
		if (y & 1) {
			num *= base;
			num %= z;
		}
		base *= base;
		base %= z;
		y >>= 1;
	}
	return num;
}

void dfs(ll x) {
	if (bo) {
		return;
	}
	if (x >= v.size()) {
		if (fast_pow(n, val, m) == 1 && val != m - 1) {
			bo = 1;
		}
		return;
	}
	for (ll i = 0, u = 1; i <= v[x].cnt; i++, u *= v[x].num) {
		val *= u;
		dfs(x + 1);
		val /= u;
	}
}

int main() {
	r(T);
	while (T--) {
		r(n, m);
		ll num = m - 1;
		val = 1;
		v.clear();
		bo = 0;
		for (ll i = 2; i * i <= num; i++) {
			if (num % i == 0) {
				v.push_back({i, 0});
				while (num % i == 0) {
					num /= i;
					v[v.size() - 1].cnt++;
				}
			}
		}
		if (num > 1) {
			v.push_back({num, 1});
		}
		dfs(0);
		bo ? w("No\n") : w("Yes\n");
	}
	return 0;
}
```

### 时间复杂度

$O(T(\sqrt{p}+\log^2p))$

---

## 作者：shuqiang (赞：5)

~~这套 5 级题真的有人能满分吗？~~

对于质数 $p$ 而言，$p$ 的原根 $g$ 是满足以下条件的正整数：

- $1<g<p$；
- $g^{p-1}\bmod{p}=1$；
- 对于任意 $1\le i<p-1$ 均有 $g^i\bmod{p}\neq1$。

条件 1 已经在数据范围限制了，所以不用判断，然后是条件 2，可以用快速幂求出 $g^{p-1}$，最后一个条件，枚举 $i$ 肯定不行，因为 $p \le 10^9$，考虑缩小枚举范围。

根据模运算分配律 $g^{ix} \bmod p=(g^i \bmod p) ^ x \bmod p$ 若 $g^i \bmod p=1$，那么 $g^{ix} \bmod p=(g^{i} \bmod p)^x \bmod p = 1^x = 1 (x \in N)$。

反过来，若 $g^i \bmod p \ne 1$，则 $g^{ix} \bmod p=(g^i \bmod p) ^ x \ne 1^x = 1$。

所以，如果前面判断了 $i$，那么 $i$ 的倍数就不用再判断了。

由于不满足条件 2 在前面已经被排除掉了，所以 $g^{p-1}\bmod{p}=1$，由此，如果有 $p-1$ 的质因子 $i$ 满足 $g^i\bmod{p} \ne 1$ 那么 $i$ 的倍数就都满足这个条件，不用判断，否则 $g$ 就不是 $p$ 的原根。

时间复杂度 $\mathcal{O}(\sum {\sqrt{p} \log p})$，可以通过。


```cpp
#include<iostream>

using namespace std;
typedef long long ll;

int t, n, p; bool fg = 1;

int qpow(int x, int y){
	int res = 1;
	while(y){
		if(y&1) res = (ll)res * x % p;
		y >>= 1;
		x = (ll)x * x % p;
	}
	return res;
}

int main(){
	cin >> t;
	while(t--){
		cin >> n >> p; fg = 1;
		if(qpow(n, p-1) % p != 1){
			cout << "No\n";
			continue;
		}
		for(int i = 2; i * i < p; i++){
			if((p-1) % i == 0 && (qpow(n, i) == 1 || qpow(n, (p-1)/i) == 1)){
				fg = 0;
				cout << "No\n";
				break;
			}
		}
		if(fg) cout << "Yes\n";
	}
	return 0;
}
```

---

## 作者：Chase12345 (赞：4)

这道题蓝题好像确实可以，但似乎只是下位蓝。本人并没有去现场考试，但是听 @[浮光掠影](https://www.luogu.com.cn/user/1403682) 大佬说他们 5 级考场有人哭了。。。

为了尝试做这一道题，先证明 $g^i \bmod p$ 具有余数周期性规律：

>$g^{p-1} \equiv g^{2p-2} \equiv 1 \pmod{p}$
>
>则若它具有周期性规律，则周期必定是 $p-1$ 的约数，而且 $g^i  \times g^{p-1} \equiv g^{i+p-1} \equiv g^i \times 1 \equiv g^i \pmod{p}$ 所以 $g_i \bmod p$ 具有余数周期性规律，且以 $p-1$ 为一个周期。当然，不排除以 $p-1$ 的因数为周期的情况。

那么如果 $p-1$ 的约数中，存在 $a$，且 $g^a \equiv 1 \pmod{p}$，则这个周期提前结束， 你也可以理解为 $g$ 必定不是 $p$ 的原根。

这个时候有人要问了：有没有可能会在不是 $p-1$ 的约数 $b$ 提前结束周期？ 那么这样显然是与原来的结论矛盾，因为如果不是在 $p-1$ 的约数 $a$ 提前结束周期，而且也在 $p-1$ 的约数 $b$ 前结束周期，这可能吗？一个数列（不是全部数相同的情况下）怎么可能有两个不等价的周期？所以只要验证每个 $p-1$ 的约数 $a$ 是否满足 $g^a \equiv 1 \pmod{p}$ 即可。时间复杂度 $O(T \sqrt{n} \log n)$。我这里的变量不是题目的变量，所以可能有点那啥，这种题我居然没有一眼，小六要被小五单调队列了 qwq。

```cpp
#include <bits/stdc++.h>
using namespace std;
using i64 = long long; 

i64 fpow(i64 a, i64 b, i64 p) {
	i64 ret = 1;
	for (; b; a = a * a % p, b >>= 1)
		ret = ret * ((b & 1) ? a : 1) % p;
	return ret;
}

int main() {
	int T;
	cin >> T;
	while (T--) {
		i64 a, p;
		bool res = 1;
		cin >> a >> p;
        res = (fpow(a, p - 1, p) == 1);
		for (int i = 2; i * i <= p - 1; i++)
			if ((p - 1) % i == 0 && (fpow(a, i, p) == 1 || fpow(a, (p - 1) / i, p) == 1))
				res = 0;
		cout << (res ? "Yes\n" : "No\n");
	}
}
```

---

## 作者：Sanyueyetu (赞：4)

假如你从未听说过原根……

这是一篇只需要逆元和快速幂的题解。

### 思路
由逆元的基本性质 $g^{p-2}\times g\bmod{p}=1$，所以 $g^{p-1}\bmod{p}=1$ 一定是成立的，我们其实只需要考虑第三个限制。

我们可以定义当前需要验证第三性质的 $a^{n}$ 个数为 $nowlen$，定义 $mid=\left\lfloor\dfrac{nowlen+1}{2}\right\rfloor$。注意到对于任意 $mid \le i \le nowlen$ 均有 $a^{i}\bmod{p}=a^{i-mid} \bmod{p}$。因此我们可以每次将 $nowlen$ 除以 $2$，仅保留 $1\le i \le mid$（右半部分的数都可以用左半部分的数与 $a^{mid}$ 的乘积的形式表现出来），并将 $a^{mid}\bmod{p}$ 放入一个集合 $S$。

设最终的留下的序列为 $A$。我们发现第三个限制满足当且仅当对于 $A$ 中的任意 $A_i$，$A_i$ 均不等于 $1$ 且 $S$ 当中没有 $1$ 且 $A$ 中任意元素与 $S$ 的任意子集的积的乘积模 $p$ 均不等于 $1$。

令 $A$ 的长度为 $\sqrt{p}$，那么这种做法可以做到时间复杂度 $O(T\sqrt{p}\log{p})$。

思路比较复杂，具体大家可以看代码实现。
### Code
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int T,a,b,nowlen,temp;
vector<int>v;
set<int>s;
bool ok;
int pp(int x,int y){
	if(y==0) return 1;
	if(y==1) return x;
	int res=pp(x,y/2);
	if(y%2) return res*res%b*x%b;
	return res*res%b;
}
signed main(){
	scanf("%lld",&T);
	while(T--){
		scanf("%lld%lld",&a,&b);
		v.clear(),s.clear();
		ok=1;
		nowlen=b-2;
		while(nowlen*nowlen>=b){
			v.push_back(pp(a,(nowlen+1)/2));
			nowlen/=2;
		}
		for(int i=0;i<(1<<v.size());i++){
			temp=1;
			for(int j=0;j<v.size();j++){
				if(i>>j&1){
					temp=temp*v[j]%b;
				}
			}
			if(temp==1&&i!=0){
				ok=0;
				break;
			}
			s.insert(temp);
		}
		temp=1;
		for(int i=1;i<=nowlen;i++){
			temp=temp*a%b;
			if(temp==1){
				ok=0;
				break;
			}
			if(s.count(pp(temp,b-2))){
				ok=0;
				break;
			}
		}
		if(ok) printf("Yes\n");
		else printf("No\n");
	}
}
```

---

## 作者：liyancen (赞：4)

>### 题外话
>CCF 是不是放错题了？虽然这道题也比较简单，但是不符合五级的水准啊！！！

### 题目分析
根据题目的要求，有三个条件，其中第一个条件是最好判的，因为数据就已经保证了，当然如果你也想判一下也无所谓。

接下来就看第二个条件，非常显然是一个模板的快速幂，可以在 $O(\log n)$ 的时间复杂度内解决，也是比较容易的。

最难的就是第三个条件了，如果说你只想拿 40 分的话，也可以直接顺着打暴力，硬判，但是嘛，我们都是有追求的人，不能只关注者一点点的分，所以说我们要找规律。

我的数学老师杨老师，曾经说过一句话，正着来弄难，那就反着来弄，话句话说，这道题我们是不是可以直接反着判，看看哪些情况可能得到 1，哪些情况可能得不到 1。

接下来就是尝试。

如果说我们设 $a^k \bmod p =1$，那么因为取余的两侧可以进行加，减，乘的运算，所以说我们又可以很轻松的得到这些式子 $a^{k+1}\bmod p=a^1 \bmod p$，$a^{k+2} \bmod p=a^2 \bmod p$，$a^{k+n} \bmod p=a^n\bmod p$。

那么基于这些式子，我们是不是可以发现这个是一个长度为 $k$ 的一个循环周期？

同时我们根据条件 2，是不是发现这个长度周期只有可能是 $p-1$ 的因数，那么我们直接枚举因数不就可以了？

这样的时间复杂度就是 $O(T\times \sqrt{p-1}\times \log_{p-1})$。

### 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;

long long quickpow(int a,int p,int mod){
	if (p==0)return 1;
	long long t=quickpow(a,p/2,mod);
	t=t*t%mod;
	if (p%2==1)t=t*a%mod;
	return t%mod;
}

int main(){
	int T;
	cin>>T;
	while (T--){
		int a,p;
		cin>>a>>p;
		if (quickpow(a,p-1,p)!=1){
			cout<<"No\n";
			continue;
		}
		bool flag=true;
		for (int i=2;i*i<=(p-1);i++){
			if ((p-1)%i==0){
				if (quickpow(a,i,p)==1||quickpow(a,(p-1)/i,p)==1){
					flag=false; 
					break;
				}
			}
		}
		if (flag)cout<<"Yes\n";
		else cout<<"No\n";
	} 
	return 0;
}
```

---

## 作者：Redshift_Shine (赞：3)

明天就要月考了，但是看到这道题还是想写一下。

然后，思考时间 3min，切。

**理论上，以下解法并不要求对“原根”这一概念有额外的事先理解。**

首先，根据费马小定理，对于任意质数 $p$ 和任意小于 $p$ 的**正**整数 $a$，满足 $a^{p-1}\equiv 1\pmod p$，故可以直接省略第二个条件。

随后，可以证明，对于任何小于 $p$ 的**正**整数 $x$，对于**最小**的**正**整数 $k$ 满足 $x^k\equiv 1\pmod p$，$k|(p-1)$。证明也足够显然，若最小的 $k$ 不是 $(p-1)$ 的因数，那么 $x^{p-1}\not\equiv 1\pmod p$，与费马小定理相悖，显然不存在这种情况。

由此，解法显然。枚举 $(p-1)$ 的所有因数 $f$，若存在 $f\neq 1$ 且 $f\neq p-1$ 满足 $a^f\equiv 1\pmod p$，则不是原根，否则是。

时间复杂度 $O(\sum \sqrt{p-1}\log p)$。

```c++
// #define Redshift_Debug
#ifdef Redshift_Debug
#define debug(...) fprintf(stderr, __VA_ARGS__)
#include <chrono>
#else
#define debug(...)
#endif
#include <cstdio>

using namespace std;
const int N = 1e5 + 10;
int a, p;
inline int fsp(int x, int y)
{
	int res = 1;
	while (y)
	{
		if (y & 1)
			res = 1ll * res * x % p;
		x = 1ll * x * x % p;
		y >>= 1;
	}
	return res;
}
void init_global()
{
}
void init_local()
{
	scanf("%d%d", &a, &p);
}
void run()
{
	for (int i = 2; i * i <= p - 1; i++)
	{
		if ((p - 1) % i)
			continue;
		if (fsp(a, i) == 1 or fsp(a, (p - 1) / i) == 1)
		{
			puts("No");
			return;
		}
	}
	puts("Yes");
}
int main()
{
#ifdef Redshift_Debug
	auto st = chrono::high_resolution_clock::now();
#endif
	int T = 1;
	scanf("%d", &T);
	init_global();
	while (T--)
	{
		init_local();
		run();
	}
#ifdef Redshift_Debug
	auto ed = chrono::high_resolution_clock::now();
	fprintf(stderr, "%.9lf\n", (ed - st).count() / 1e9);
#endif
}
```

---


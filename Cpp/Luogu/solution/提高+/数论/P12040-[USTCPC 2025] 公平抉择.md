# [USTCPC 2025] 公平抉择

## 题目背景

考虑到评测机性能差异，改为 400ms 时限。USTCPC 时限为 600ms。

**请注意本题非常规时空限制！**

所以要“费厄”，最好是首先看清对手，倘是些不配承受“费厄”的，大可以老实不客气；待到它也“费厄”了，然后再与它讲“费厄”不迟。(节选自鲁迅《论“费厄泼赖”应该缓行》)

克露丝卡尔酱选择困难！她甚至无法抉择午饭去吃什么，作为她的朋友，你需要和她一起完整**公平的抉择**。

## 题目描述

克露丝卡尔酱在做选择，食堂共有 $n$ 种菜品可选，而她手里只有一个 $k$ 面的骰子(如果 $k = 2$ 则为硬币)。

为了落实公平抉择的理念，她希望她的策略选择到每个菜品的概率相等。

求她期望投掷次数的最小值，**答案对质数 $M$ 取模**。

## 说明/提示

在样例 $1$ 中，不妨设答案为 $E$。考虑扔两次硬币，得到四种情况，出现概率各为 $\dfrac{1}4$。前三种情况分配给三种菜品，第四种情况重投。故 $E=2+\dfrac{E}4$，解得 $E=\dfrac{8}3$。

## 样例 #1

### 输入

```
3 2 998244353```

### 输出

```
665496238```

## 样例 #2

### 输入

```
10 2 998244353```

### 输出

```
798595487```

# 题解

## 作者：VinstaG173 (赞：2)

首先我们有一个贪心策略：每当剩余未确定结果的情况多于 $n$ 个时，将其中的 $cn$ 个确定结果（每种菜各分配 $c$ 种可能），剩下的情况继续掷骰子。

则我们的过程会是这样的：掷了 $v$ 次骰子时会有 $r_v=k^v\bmod{n}$ 种情况未确定结果，故第 $v+1$ 次会有 $n\lfloor\frac{kr_v}n\rfloor$ 种情况被确定结果。那么期望次数就是

$$\sum_{v\ge1}\dfrac{n\lfloor\frac{kr_v}n\rfloor}{k^{v+1}}(v+1).$$

由 Euler 定理，$r_v=k^v\bmod{n}$ 会进入循环，设出现循环的最小位置为 $k^b\equiv k^{b+d}\pmod{n}$，则对于 $v\ge b$ 有：

$$\begin{aligned}
E&=\sum_{v\ge b}\dfrac{n\lfloor\frac{kr_v}n\rfloor}{k^{v+1}}(v+1)\\
&=\sum_{v=b+1}^{b+d}n\left\lfloor\frac{kr_{v-1}}n\right\rfloor\sum_{i\ge0}\dfrac{v+id}{k^{v+id}}\\
&=\sum_{v=b+1}^{b+d}\dfrac{vn\lfloor\frac{kr_{v-1}}n\rfloor}{k^v}+\dfrac1{k^d}\left(E+d\sum_{v\ge b}\dfrac{n\lfloor\frac{kr_v}n\rfloor}{k^{v+1}}\right)\\
&=\sum_{v=b+1}^{b+d}\dfrac{vn\lfloor\frac{kr_{v-1}}n\rfloor}{k^v}+\dfrac1{k^d}\left(E+\dfrac{dr_b}{k^b}\right),
\end{aligned}$$

最后一步是由于括号里的和式本质上是 $\ge b+1$ 次才确定结果的概率，根据贪心策略其值即为第 $b$ 次没有确定结果的概率 $\frac{r_b}{k^b}$。

从而我们可以列出方程求解：

$$\begin{aligned}
\left(1-\dfrac1{k^d}\right)E&=\dfrac{dr_b}{k^{b+d}}+\sum_{v=b+1}^{b+d}\dfrac{vn\lfloor\frac{kr_{v-1}}n\rfloor}{k^v},\\
E&=\left(1-\dfrac1{k^d}\right)^{-1}\left(\dfrac{dr_b}{k^{b+d}}+\sum_{v=b+1}^{b+d}\dfrac{vn\lfloor\frac{kr_{v-1}}n\rfloor}{k^v}\right).
\end{aligned}$$

因此我们可以用桶记录 $r_v$ 求出循环，预处理 $k^{-v}$ 后可 $O(d)$ 求出 $E$，由于 $E$ 是 $v\ge b$ 时的答案，因此对于 $v<b$ 直接 $O(b)$ 计算即可得到最终结果。由 Euler 定理 $b,d=O(\varphi(n))$，故总时间复杂度 $O(\varphi(n))$，空间复杂度 $O(n)$。注意判定 $n\mid k^b$ 的情况。

Code:
```cpp
int n,k,m,b,c,d;
inline ll qpw(ll x,int v){
	ll r=1;while(v){
		(v&1)&&(r=r*x%m);
		x=x*x%m,v>>=1;
	}return r;
}

ll x,y,tmp,ans;
ll inv[3000007];
int vis[3000007];
inline void solve(){
	cin>>n>>k>>m;x=inv[0]=1;
	inv[1]=qpw(k,m-2);
	for(c=1;!vis[x];++c,x=x*k%n){
		vis[x]=c,inv[c+1]=inv[c]*inv[1]%m;
	}d=c-vis[x];b=vis[x]-1;
	if(x){
		for(int i=1;i<=d;++i,x=x*k%n){
			tmp=(tmp+(x*k/n*n)%m*inv[i+b]%m*(i+b))%m;
		}tmp=(tmp+inv[d]*d%m*x%m*inv[b])%m;
		tmp=tmp*qpw(m+1-inv[d],m-2)%m;
	}y=1;
	for(int i=1;i<=b;++i,y=y*k%n){
		ans=(ans+(y*k/n*n)%m*inv[i]%m*i)%m;
	}ans=(ans+tmp)%m;
	cout<<ans<<"\n";
}
```

---

## 作者：Rosaya (赞：0)

### Observation

统称“投掷完 $i$ 次骰子到达的状态”为第 $i$ 层节点，初始为第 $0$ 层。到达第 $i$ 层每个节点的概率均为 $\dfrac{1}{k^i}$。

若第 $i$ 层选择 $p$ 个节点投骰子，那么第 $i+1$ 层恰有 $pk$ 个节点。第 $i$ 层的节点可以相互交换。

注意到第 $i$ 层不会有 $\ge k$ 个节点选择同一个选项，否则可以交换到一起然后合并，在第 $i-1$ 层就选择这个选项，可以将答案减少 $\dfrac{1}{k^{i-1}}$。

也就是说对于一个选项，记 $q_i$ 表示第 $i$ 层选择它的节点个数，有 $\sum\limits_{i=0}^{+\infty}\dfrac{q_i}{k^i}=\dfrac{1}n$，由于 $0 \le q_i < k$。不难发现这其实是 $\dfrac1n$ 在 $k$ 进制下的表示，显然 $k$ 进制表示唯一，也就是说 $n$ 个选项是对称的。

### Solution

记 $f_i$ 表示第 $0$ 层有 $i$ 个节点投骰子的答案，答案即为 $f_1$。

显然有 $f_i=i+\dfrac{f_{ik \bmod n}}k$，且 $f_0=0$，解方程即可。

最终方程是一个 $f_1=a+bf_i=a'+b'f_i$ 的形式，而 $b,b'$ 均是 $\dfrac1{k^x}$ 形式。$(k,M)=1$，$k$ 有逆元。而 $b-b'$ 得到的 $\dfrac{k^{x'-x}-1}{k^{x'}}$ 的分子是 $k^x-1$ 形式，而 $x'-x$ 显然是 $n$ 量级的，故答案在模 $M$ 意义下存在，复杂度 $O\left(n\right)$。

---


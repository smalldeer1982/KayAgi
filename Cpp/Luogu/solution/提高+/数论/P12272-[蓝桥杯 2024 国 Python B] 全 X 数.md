# [蓝桥杯 2024 国 Python B] 全 X 数

## 题目描述

我们称 $22222, 3333, 7777$ 等由单一数字组成的十进制数为全 $X$ 数。

给定一个整数 $n$，小蓝想知道 $n$ 的所有倍数中最小的全 $X$ 数是多少。由于答案可能很大，你只需要输出答案对 $998244353$ 取模的结果。如果不存在任何答案，请输出 $-1$。

## 说明/提示

### 评测用例规模与约定

- 对于 $50\%$ 的评测用例，$n \leq 5000$；
- 对于 $75\%$ 的评测用例，$n \leq 10^6$；
- 对于所有评测用例，$1 \leq n \leq 10^9$。

## 样例 #1

### 输入

```
12 ```

### 输出

```
444```

# 题解

## 作者：fish_love_cat (赞：4)

诶等大可的题解怎么失踪了，那我来写一篇。

三倍经验：P10496，P12272，AT_abc222_g

---

假设有一个长度为 $t$ 每一位都为 $9$ 的数字，我们可以这么表示它：

$$10^{t}-1$$

然后将这个数字乘上 $9^{-1}x$，就得到了等长的每一位都为 $x$ 的数字，也就是：

$$9^{-1}(10^{t}-1)x$$

根据题面，这个数是 $n$ 的倍数，于是有：

$$n\mid 9^{-1}(10^{t}-1)x$$

转化：

$$9n\mid (10^{t}-1)x$$

设 $d=\gcd(x,9n)$，于是有：

$$\frac{9n}{d}\mid 10^{t}-1$$

设 $P=\frac{9n}{d}$，那么也就是说：

$$10^{t}\equiv 1\pmod P$$

现在你想怎么做都可以，比如使用 BSGS。

---

但你如果和我一样 BSGS 忘了怎么处理了怎么办呢？

你需要知道这么一个东西：

> 若 $a\perp p$，那么 $a^x\equiv 1\pmod p$ 的最小整数解满足 $x\mid\varphi(p)$。

证明放在文末。

那么我们只需要对于每一个 $x$ 求出 $P$，然后对于 $\varphi(P)$ 的每一个约数进行检测，然后选最小就能求出长度。

做完了。记得开 `__int128`。

```cpp
#include<bits/stdc++.h>
#define int __int128
#define mod 998244353
using namespace std;
int read(){
    int sum=0,fish=1;
    char c=getchar_unlocked();
    while((c<'0'||c>'9')&&c!='-')c=getchar_unlocked();
    if(c=='-')fish=-1,c=getchar_unlocked();
    while(c>='0'&&c<='9')sum=sum*10+(c-'0'),c=getchar_unlocked();
    return sum*fish;
}
void print(int x){
    if(x<0)putchar_unlocked('-'),x=-x;
    if(x<10)putchar_unlocked(x+'0');
    else print(x/10),putchar_unlocked(x%10+'0');
}
#define flc_INF LLONG_MAX
int qpow(int a,int b,int p=flc_INF){
	int ans=1;
	if(b==0)return 1;
	while(b){
		if(b&1)ans*=a,ans%=p;
		a*=a,b>>=1,a%=p;
	}
	return ans;
}
int phi(int n){
    int ret=n;
    for(int i=2;i*i<=n;i++){
        if(n%i==0)ret=ret/i*(i-1);
        while(n%i==0)n/=i;
    }
    if(n==1)return ret;
    return ret=ret/n*(n-1);
}
int T=1e18,X;
signed main(){
    int n=read();n*=9;
    for(int i=1;i<=9;i++){
        int m=n/__gcd(n,i);
        int p=phi(m);
        int mini=1e18;
        for(int j=1;j*j<=p;j++)
        if(p%j==0){
            if(qpow(10,j,m)==1)mini=min(mini,j);
            if(j*j==p)continue;
            if(qpow(10,p/j,m)==1)mini=min(mini,p/j);
        }
        if(T>mini)T=mini,X=i;
    }
    if(T==1e18)cout<<-1;
    else print(qpow(9,mod-2,mod)*(qpow(10,T,mod)-1)%mod*X%mod);
    return 0;
}
```

---

证明：

考虑反证法。

若 $x\nmid\varphi(p)$，那么 $\varphi(p)=kx+b$，此处 $a<x$。

因为 $a^x\equiv1\pmod p$，所以 $a^{kx}\equiv1\pmod p$。

因为欧拉定理 $a^{\varphi(p)}\equiv1\pmod p$，所以 $a^{kx+b}\equiv1\pmod p$。

我们把这两个柿子除一下，于是就有 $a^b\equiv 1\pmod p$，这与 $x$ 是最小解矛盾。

于是原命题得证。

---

## 作者：DengDuck (赞：4)

任意符合条件的数字都能表示成 $9^{-1}(10^t-1)x$ 其中 $x\in[1,9]$，然后我们知道这玩意是 $n$ 的倍数。

$$
\begin{aligned}
9^{-1}(10^t-1)x&=np\\
(10^t-1)x&=9np\\
(10^t-1)x&\equiv 0\pmod {9n}\\
\end{aligned}
$$

考虑枚举 $x$ 和 $t$，限定在 $x\in[1,9],t\leq 10^7$，就可以拿下 $80$ 分。

我们发现 $x$ 做的贡献是一开始可以直接给 $9n$ 除过去一个 GCD，然后 GCD 以外的部分其实没有贡献，可以不管，也就是 $P\gets \frac{9n}{\gcd(9n,x)}$。

那么我们得到：

$$
\begin{aligned}
10^t&\equiv 1\pmod {P}\\
\end{aligned}
$$

大步小步肯定可做。但是我们不妨直接求 $\varphi(P)$ 然后最小的 $t$ 必然是这玩意的因数。做法成立的原因是我们求的 $t$ 相当于一个最小的循环节（由于 $10^0=1$，我们现在相当于回到了原点，构成了循环），最小循环节一定是任意一个循环节的因数。这个做法做着更加简单。

警惕，快速幂最好开个 `__int128` 因为写不好 `long long` 会爆炸。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
LL n,X,T=1e15;
const LL Mod=998244353;
inline LL Ksm(__int128 x,LL y,LL P=Mod)
{
	__int128 A=1;
	while(y)
	{
		if(y&1)A=A*x%P;
		x=x*x%P,y>>=1; 
	}
	return A;
}
inline LL GCD(LL x,LL y)
{
	if(!y)return x;
	return GCD(y,x%y);
}
inline LL Phi(LL P)
{
	LL K=P;
	for(LL i=2;i*i<=P;i++)
	{
		if(P%i==0)
		{
			K=K/i*(i-1);
		}	while(P%i==0)P/=i;
	}
	if(P>1)K=K/P*(P-1);
	return K;
}
int main()
{
	cin>>n;	
	for(LL x=1;x<=9;x++)
	{
		LL P=9*n/GCD(9*n,x);
		if(P==1)continue;
		LL K=Phi(P),Mn=1e15;
		for(LL i=1;i*i<=K;i++)
		{
			if(K%i)continue;
			if(Ksm(10,i,P)==1)Mn=min(Mn,i);
			if(Ksm(10,K/i,P)==1)Mn=min(Mn,K/i);
		}
		if(Mn<T)T=Mn,X=x;
	}
	if(X==0)cout<<-1<<endl;
	else cout<<X*(Ksm(10,T)-1+Mod)%Mod*Ksm(9,Mod-2)%Mod<<endl;
}
```

---

## 作者：skyx (赞：3)

# P12272 [蓝桥杯 2024 国 Python B] 全 X 数-题解
## 简要题意
给定一个整数 $n$，在所有是 $n$ 的倍数的全 $X$ 数（十进制表示由同一数字重复组成，如 $2$、$33$、$7777$）中，找到最小的那个。输出其对 $998244353$ 取模的结果；无解输出 $-1$。
## 题目分析
~~这一篇题解补充了关于部分分的做法和无解的判定，大家轻喷。~~
### ？？？ pts 做法
暴力枚举。根据枚举的范围和实现方法能获得不同分数。

几种实现：
- 该代码能获得 $30$ pts。
```cpp
bool check(int x)
{
	int ans=x%10;
	while(x)
	{
		if(x%10!=ans) return 0;
		x/=10;
	}
	return 1;
}
signed main()
{
	int n;
	cin>>n;
	int x=2;
	while(1)
	{
		if(check(n*x))
		{
			cout<<n*x<<endl;return 0;
		}
		if(x>500000000)
		{
			cout<<-1<<endl;return 0;
		}
		x++;
	}
	return 0;
}
```
**FUN FACT**：我在比赛时仅仅开到了 `if(x>2000)`，获得了该题有分最低分的好成绩。
***
- 该类代码能获得 $45$ pts。
```cpp
signed main()
{
	N = read();
	cur = 1;
	stclock = clock();
	while(clock() - stclock < 2990)
	{
		for(int i = 1; i <= 9; i++)
		{
			if(cur * i % N == 0)
			{
				cout << cur * i << endl;
				return 0;
			}
		}
		cur = cur * 10 + 1;
	}
	if(flag == false) cout << -1;
	return 0;
}
```
***
```cpp
signed main()
{
	int n;
	cin>>n;
	__int128 num=1,ds=1;
	for(int i=1; i<=32; i++)
	{
		for(int j=1; j<=9; j++)
		{
			num=ds*j;
			if(num%n==0)
			{
				int temp=num%998244353;
				cout<<temp;
				return 0;
			}
		}
		ds=ds*10+1;
	}
	cout<<-1;
	return 0;
}
```


### $75$ pts 做法
**FUN FACT**：由于数据过水，实际能获得 $80$ 分，带一些卡常甚至有 $85$ 分。

我们考虑优化上面的最后一个暴力，枚举数字 $1$ 到 $9$ 与长度，并维护除 $n$ 余数，当余数为 $0$ 时更新答案。

这里可以证明：**若有解，答案的位数一定 $\le n$**。
***
**Proof.**

设 $A_k$ 表示由 $k$ 个数字 $d$ 组成的十进制数（例如 $d=4$ 时 $A_1=4, A_2=44, A_3=444,\dots$）。  
显然有递推：
$$
A_1=d,\qquad A_k=10\cdot A_{k-1}+d\quad (k\ge 2).
$$
对 $n$ 取模，记余数 $r_k\equiv A_k\bmod n$，则
$$
r_1\equiv d \bmod n,\qquad r_k\equiv (10\,r_{k-1}+d)\bmod n.
$$

因为余数只可能取 $n$ 个值：$0,1,\dots,n-1$，如果前 $n$ 项没有出现 $0$，那么我们已经走过了 $n$ 步，访问了 $n$ 个状态（余数），但这 $n$ 个状态都不等于 $0$。

根据鸽巢原理，必然有两个不同步数 $p<q$ 得到相同的余数，即：
   $$
   r_p = r_q.
   $$

一旦 $r_p = r_q$，由于递推是确定性的，之后的序列就会周期性重复：
   $$
   r_{p+1} = r_{q+1}, \quad r_{p+2} = r_{q+2}, \quad \dots
   $$
因此从 $p$ 开始，余数序列进入一个周期循环。

如果周期中不包含 $0$，那以后永远也不会出现 $0$，即无解。

如果周期中包含 $0$，那么在进入周期之前就应该已经遇到过 $0$，这与“前 $n$ 项没有 $0$”矛盾。

因此只要存在解，就必须在前 $n$ 步之内命中 $0$，从而最短位数 $\le n$。
***
实现注意更新答案时，若长度相同，应比较使用的数字 $i$ 谁更小，而不是当前 $ans$ 的某一位（已取模）。

利用字符串也可实现，但时间略慢一些。
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long

const ll mod = 998244353;

signed main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);

	ll n;
	cin >> n;

	ll ans = -1;
	ll minlen = 1e9;      // 最短长度
	int minDigit = 10;    // 最优解对应的数字

	for (int i = 1; i <= 9; i++)
	{
		ll r1 = 0, r2 = 0;
		for (int j = 1; j <= n; j++)
		{
			r1 = (r1 * 10 + i) % n;   // 对 n 的余数
			r2 = (r2 * 10 + i) % mod; // 对 mod 的余数
			if (r1 == 0) 
			{
				if (j < minlen || (j == minlen && i < minDigit))
				{
					minlen = j;
					minDigit = i;
					ans = r2;
				}
				break;
			}
		}
	}
	cout << ans << "\n";
	return 0;
}
```
### $100$ pts 做法
不难发现，（若有）答案可以写成如下形式：

$$
\text{ans}=x \cdot \underbrace{11\cdots 1}_{L \text{ 个}} = x \cdot \frac{10^L - 1}{9}.
$$

条件 $n \mid \text{ans}$ 等价于：

$$
n \ \Big| \ x \cdot \frac{10^L - 1}{9}
$$

整理：
$$
9n \ \Big| \ x \cdot (10^L - 1).
$$

有了这个式子，我们希望求出 $L$，但直接枚举复杂度依旧较高，也许能想到直接移过去 $x$ 并转成同余状式子，但显然 $\dfrac{9n}{x}$ 不一定是整数。

整数？那除以什么东西，能让 $9n$ 和 $x$ 都是整数呢？最大公约数！

考虑令 $g = \gcd(9n, x)$，得：

$$
\dfrac{9n}{g} \ \Big| \ \frac{x}{g}(10^L - 1).
$$

问题变得清晰了！由于 $\gcd\!\left(\dfrac{x}{g}, \dfrac{9n}{g}\right) = 1$，**这两个式子都是整数**，所以有：

$$
\dfrac{9n}{g} \ \Big| \ (10^L - 1)
\quad \Longleftrightarrow \quad
10^L \equiv 1 \pmod{\dfrac{9n}{g}}. \tag{★}
$$

在下面的代码中，计算了 $m = \dfrac{9n}{\gcd(9n, x)}$。

***
考虑 $(★)$ 式如何解决，使用 [BSGS](https://www.luogu.com.cn/problem/P3846)  是一个不错的解决方法，蓝书上有一种更加优雅的方法：若正整数 $\dfrac{9n}{g},10$ 互质，则满足 $(★)$ 式的最小正整数 $L$ 是 $\varphi(n)$ 的约数。在其他大佬的题解中也有阐述，这里补充一点：

若 $m$ 含有 $2$ 或 $5$ 因子，则对任何正整数 $L$ 都有 $10^L \equiv 0 \pmod 2$ 或 $\pmod 5$，永远不可能等于 $1$，因此无解。

进一步地，若 $10 \mid n$，即 $n$ 同时含因子 $2$ 和 $5$，则无解。~~这个结论可以依次尝试 $1$ 到 $9$ 得到。~~

## 代码实现
输出时，利用 $\text{ans} = x \cdot \dfrac{10^L - 1}{9}$ 结合逆元求答案。

注意开 `__int128`。
```cpp
#include<bits/stdc++.h>
#define int __int128
const int mod=998244353;
using namespace std;
inline int read()
{
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return x*f;
}
inline void print(int n)
{
	if(n<0)
	{
		putchar('-');
		n*=-1;
	}
	if(n>9) print(n/10);
	putchar(n % 10 + '0');
}
int qpow(int a,int b,int mod)
{
	int ans=1;
	while(b)
	{
		if(b&1) ans=ans*a%mod;
		a=a*a%mod;
		b>>=1;
	}
	return ans%mod;
}
int phi(int n)
{
	int ans=n;
	for(int i=2; i*i<=n; i++)
	{
		if(n%i==0) ans=ans/i*(i-1);
		while(n%i==0) n/=i;
	}
	if(n==1) return ans;
	else return ans=ans/n*(n-1);
} // 欧拉函数

signed main()
{
	int fans=LLONG_MAX,dig;
	int n=read();
	if(n%2==0 && n%5==0)
	{
		cout<<-1<<endl;
		return 0;
	} // 无解
	for(int i=1; i<=9; i++)
	{
		int m=9*n/__gcd(9*n,i);
		if(m%2==0 || m%5==0)
		{
			continue;
		} // 在当前 i 无解，应 continue 
		int p=phi(m);
		int mn=LLONG_MAX;
		for(int j=1; j*j<=p; j++)
		{
			if(p%j==0)
			{
				if(qpow(10,j,m)==1) mn=min(mn,j);
				if(j*j==p) continue;
				if(qpow(10,p/j,m)==1) mn=min(mn,p/j);
			}
		}

		if(fans>mn)
		{
			fans=mn;
			dig=i;
		}
	}
	if(fans==LLONG_MAX)cout<<-1<<endl;
	else
	{
		print(qpow(9,mod-2,mod)*(qpow(10,fans,mod)-1)%mod*dig%mod);
		cout<<endl;
	}
	return 0;
}
```

---

## 作者：JiaoLV000 (赞：1)

# 思路

首先可以发现这个题是数论题（废话），且是比较典型的数论题。根据等比数列求和公式，由连续 $t$ 个 $x$ 构成的数可以转换成这样：$\frac{10^t-1}{9} \cdot x$。

那么问题就变成了这个：求最小的 $t$ 满足 $\frac{10^t - 1}{9} \cdot x \equiv 0 \pmod{n}$，即 $10^t \equiv 1 \pmod{\frac{9n}{\gcd(9n, x)}}$。

我们需要 $(10^t - 1) \cdot x$ 是 $9n$ 的倍数，进一步的，$10^t - 1$ 需要是 $m = \frac{9n}{\gcd(x, 9n)}$ 的倍数。

继续，最终你会得到一个这个东西：$10^{\varphi(m)} \equiv 1 \pmod{m}$。

烧烤一下，发现这题和 [ABC222G] 222 很像（题号：AT_abc222_g），但只要改一改就行了，我们去枚举 $x$ 就行了。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int __int128
const int mod=998244353;
int phi(int n) {
	int res = n;
	for(int i = 2;i * i <= n;i ++) {
		if(n % i == 0) {
			res = res / i * (i - 1);
			while(n % i == 0) n /= i;
		}
	} 
	if(n > 1) res = res / n * (n - 1);
	return res; 
}
int gcd(int a,int b){
	return b?gcd(b,a%b):a; 
}
int power(int a,int b,int p){
	int ans=1%p;
	while(b){
		if(b&1) ans=ans*a%p;
		a=a*a%p;b>>=1;
	}
	return ans%p;
}
signed main(){
//	f(1e6);
	int k,mn=LLONG_MAX,x=0;;
	long long j=0;
	cin>>j;
	k=j;
	for(int i=1;i<=9;i++){
//		int k;
//		cin>>k;
		int mod=(9*k)/gcd(k*9,i),ans=LLONG_MAX;
		int q=phi(mod);
		for(int i=1;i*i<=q;i++){
			if(q%i==0){
				if(power(10,i,mod)==1){
					ans=min(ans,i);
				}
				if(power(10,q/i,mod)==1){
					ans=min(ans,q/i);
				}
			}
			
		}
		if(mn>ans) mn=ans,x=i;
	}
	if(mn==LLONG_MAX) cout<<-1<<endl;
	else{
		int kkk=(power(10,mn,mod)+mod-1)*x%mod*power(9,mod-2,mod)%mod;
		cout<<(long long )kkk<<endl;
	}
}

---


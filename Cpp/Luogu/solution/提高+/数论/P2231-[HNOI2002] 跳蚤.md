# [HNOI2002] 跳蚤

## 题目描述

Z 城市居住着很多只跳蚤。在 Z 城市周六生活频道有一个娱乐节目。一只跳蚤将被请上一个高空钢丝的正中央。钢丝很长，可以看作是无限长。节目主持人会给该跳蚤发一张卡片。卡片上写有 $N+1$ 个自然数。其中最后一个是 $M$，而前 $N$ 个数都不超过 $M$，卡片上允许有相同的数字。跳蚤每次可以从卡片上任意选择一个自然数 $S$，然后向左，或向右跳 $S$ 个单位长度。而他最终的任务是跳到距离他左边一个单位长度的地方，并捡起位于那里的礼物。

比如当 $N=2,M=18$ 时，持有卡片 $(10, 15, 18)$ 的跳蚤，就可以完成任务：他可以先向左跳 $10$ 个单位长度，然后再连向左跳 $3$ 次，每次 $15$ 个单位长度，最后再向右连跳 $3$ 次，每次 $18$ 个单位长度。而持有卡片 $(12, 15, 18)$ 的跳蚤，则怎么也不可能跳到距他左边一个单位长度的地方。

当确定 $N$ 和 $M$ 后，显然一共有 $M^ N$ 张不同的卡片。现在的问题是，在这所有的卡片中，有多少张可以完成任务。


## 说明/提示

这12张卡片分别是：

$(1, 1, 4), (1, 2, 4), (1, 3, 4), (1, 4, 4), (2, 1, 4), (2, 3, 4)$

$(3, 1, 4), (3, 2, 4), (3, 3, 4), (3, 4, 4), (4, 1, 4), (4, 3, 4)$


## 样例 #1

### 输入

```
2 4```

### 输出

```
12```

# 题解

## 作者：Elegia (赞：16)

相比与楼下诸位的跳跃式思路，我个人比较笨，是用公式一步步推的，给出一个较严格的证明。


每次选一个数跳若干格，这就是所谓的“线性组合”。所以我们可以将问题规约为：如果这$n+1$个数的最大公约数是1，那么这个方案就是可行的。


记$\delta_1(n)$当$n=1$时得到1，其他都为0。那么这个计数就可以记为：


$\sum_{a_1 = 1}^m \cdots \sum_{a_n = 1} ^ m\delta_1(\gcd(\gcd a, m))$


考虑到判别函数$\delta_1$有莫比乌斯变换式


$\delta_1(n) = \sum_{d|n} \mu(d)$


此时参数空间满足$d | a_i$，$d | m$。

改变运算顺序，将$d$提到最前。


$\text{ans} = \sum_{d|m} \mu(d) \left(\frac m d\right)^n$


那么这个式子就是非常易于计算的了。


复杂度$\Theta(\sqrt n \log n)$。


```cpp
#include <cstdio>

#define LOG(FMT...) // fprintf(stderr, "[LOG]: "FMT)

using namespace std;

typedef long long ll;

ll ans;
int n, m, pc;
int p[20];

ll pow(ll x, int k);
void dfs(int ind, int prod, int mu);

int main() {
    scanf("%d%d", &n, &m);
    int x = m;
    for (int d = 2; d * d <= m; ++d) {
        if (x % d == 0) {
            p[++pc] = d;
            while (x % d == 0)
                x /= d;
        }
    }
    if (x != 1)
        p[++pc] = x;
    dfs(1, 1, 1);
    printf("%lld\n", ans);
    return 0;
}

ll pow(ll x, int k) {
    ll ret = 1;
    while (k) {
        if (k & 1)
            ret *= x;
        k >>= 1;
        x *= x;
    }
    return ret;
}

void dfs(int ind, int prod, int mu) {
    if (ind == pc + 1) {
        ans += mu * pow(m / prod, n);
        return;
    }
    dfs(ind + 1, prod, mu);
    dfs(ind + 1, prod * p[ind], -mu);
}
```

---

## 作者：浅色调 (赞：11)

### Solution：

　　本题容斥+暴力枚举。

　　因为要向左移动1位，所以可以得到一个线性方程$a_1x_1+a_2x_2+…+a_nx_n=1$，满足有解的情况时，由裴蜀定理得$gcd(x_1,x_2…,x_n)=1$，我们只要满足任意两个数$gcd(x_i,x_j)=1$就好了。

　　我们先求出总的方案数$m^n$，再从中减去所有的整体$gcd$不为$1$的情况，由于整体$gcd$不为$1$的情况必须满足$gcd$为$m$的约数。

　　于是我们枚举m的约数作为整体公约数，对于约数$a$，共有$\frac{m}{a}$个含约数a的数，那么减去$(\frac{m}{a})^n$，然后由于会重复减，所以还得容斥，由于枚举的是m的因子，所以容斥时可以直接用莫比乌斯函数咯，所以只要求$\sum\limits_{d|m}^{m}{\mu(d)*(\frac{m}{d})^n}$就行啦。
  
$\quad\;\;$欢迎来踩博客：[five20](https://www.cnblogs.com/five20/p/9630960.html)（蒟蒻写题解不易，转载请注明出处，万分感谢！～）

### 代码：
```cpp
/*Code by 520 -- 10.19*/
#include<bits/stdc++.h>
#pragma GCC optimize(2)
#define il inline
#define ll long long
#define RE register
#define For(i,a,b) for(RE int (i)=(a);(i)<=(b);(i)++)
#define Bor(i,a,b) for(RE int (i)=(b);(i)>=(a);(i)--)
using namespace std;
ll n,m,ans;
int prime[40005],cnt;

il int u(int x){
	if(x==1)return 1;
	int num=0;
	for(RE int i=2;i*i<=x;i++){
		if(x%i==0) {
			num++;
			RE int p=0;
			while(x%i==0) {
				x/=i,p++;
				if(p>1)return 0;
			}
		}
	}
	if(x>1) num++;
	return num&1?-1:1;
}

il ll fast(ll s,ll k){
	ll ans=1;
	while(k){
		if(k&1)ans=ans*s;
		k>>=1;
		s*=s;
	}
	return ans;
}

void dfs(int now,ll s){
	if(now>cnt) {ans+=u(s)*fast(m/s,n);return;}
	dfs(now+1,s),dfs(now+1,s*prime[now]);
}

int main(){
	cin>>n>>m;
	int x=m;
	for(RE int i=2;i*i<=m;i++)
		if(x%i==0){
			prime[++cnt]=i;
			while(x%i==0) x/=i;
		}
	if(x>1) prime[++cnt]=x;
	dfs(1,1);
	cout<<ans;
	return 0;
}
```

---

## 作者：qwaszx (赞：10)

首先根据[裴蜀定理](https://www.luogu.org/problemnew/show/P4549)，方程$\sum a_ix_i=d$有整数解当且仅当$\gcd(a_i)|d$

对这题来讲就是$\gcd(a_i)=1$

于是我们可以写出式子

$\sum\limits_{1\leq k_i\leq m,i\in[1,n]}[\gcd(k_i,m)=1]$

按照套路，用$\mu$替换$\epsilon$

$=\sum\limits_{1\leq k_i\leq m,i\in[1,n]}\sum\limits_{d|k_i,d|m}\mu(d)$

$=\sum\limits_{d|m}\mu(d)\sum\limits_{1\leq k_i\leq m,i\in[1,n]}[d|k_i]$

$=\sum\limits_{d|m}\mu(d)\left(\dfrac{m}{d}\right)^n$

换句话说，$\mu\ast id^n(m)$

只需要考虑如何求出这个东西.

最暴力的做法是$O(\sqrt{m})$枚举$d|m$，再$O(\sqrt{d})$计算$\mu(d)$，没试过，理论上是$O(m)$的，实际上大约还能少一点点???不会算.

更好的做法是对$m$分解质因数，然后枚举质因子集合的子集(因为有重复质因子的那些$d$的答案都为$0$).因为$1e8$范围内质因子最多有$8$个($2\times 3\times 5\times 7\times 11\times 13\times 17\times 19\times 23=223092870>1e8$，所以$O(\sqrt{m}+2^{\text{m的质因子个数}}\log n)$跑得飞快.

不过其实可以推出式子来.

分解$m=\prod p_i^{k_i}$，那么

$id^n\ast \mu(m)=m^n-\sum\left(\dfrac{m}{p_i}\right)^n+\sum\left(\dfrac{m}{p_ip_j}\right)^n\cdots=m^n\prod\left(1-\dfrac{1}{p_i^n}\right)$

$O(\sqrt{m}\log n)$

然而即使你用$Pollard-Rho$做到$O(m^{\frac{1}{4}}\log n)$也不如上面那个东西渐进复杂度优秀(让上面那个东西也$O(m^\frac{1}{4})$分解质因数，后面那个东西，$m$每乘一个不同的质因数它就乘$2$，然而$m$会乘$p^\frac{1}{4}$.这启示我们遇到含$\mu$和一个容易计算的式子的时候应该暴力)

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int n,m;
long long qpower(long long a,int b)
{
	long long ans=1;
	for(;b;b>>=1,a*=a)if(b&1)ans=ans*a;
	return ans;
}
int main()
{
	scanf("%d%d",&m,&n);int fac=n;
	long long ans=1;
	for(int i=2;i*i<=n;i++)
	{
		if(n%i==0)
		{
			ans*=qpower(i,m)-1;fac/=i;
			while(n%i==0)n/=i;
		}
	}
	if(n!=1)ans*=qpower(n,m)-1,fac/=n;
	ans=ans*qpower(fac,m);
	cout<<ans<<endl;
}
```

---

## 作者：Leap_Frog (赞：6)

### PS.
这题数据貌似偏弱。  
笔者质因数分解时最后没有把整个数算进去也能$60pts.$  
害得笔者还以为有些小地方错了。  
upd on 2021.4.25 修改了个别评论区指出的错误。  

### Problem.
相当于要求长度为$n+1$的一个序列，最后一位是$m$，其他位都必须小于$m$，有顺序，可重复的满足能跳到左边一格的序列方案数。  

### Solution.
假设题目中的那个长度为$n+1$的序列为$\{a_1...a_n,m\}$。  
那么题目就是让我们求使$\sum_{i=1}^{n}a_i\times x_i+m\times x_{n+1}=1$有解的$a_1,a_2...a_n$有多少种  
笔者相信诸位都学过[**裴蜀定理**](https://www.luogu.com.cn/problem/P4549)，那么上面这个方程的有解情况就是$\gcd(a_1,a_2...a_n,m)=1$。  

高中数学老师教导我们，遇到一道不好分析的题目时可以考虑**正难则反**。  
那么我们可以考虑正难则反，求出上面那个方程无解的情况。  
上面那个方程无解时，$\gcd(a_1,a_2...,a_n,m)\not=1$。  
这个貌似更加友善诶，那么我们就可以考虑来求这个柿子。  
首先先把$m$分解质因数，$a_1...a_n$都一定有一个共同的$n$，那么就可以算出使它无解的方案数了。  

但是最关键的是，求无解的方案数时，有重复。  
比如，当$m=6$，$a_i=6$时，枚举到$3$时算了一遍，枚举到$2$时也算了一遍。  
这是就需要请出我们大名鼎鼎的容斥了。  
上面那个例子就可以为$3$的方案数+$2$的方案数-$6$的方案数。  

然后当$a_i$都为$x$的倍数时，此时方案数就是$(\frac{m}{x})^{n}$  
假设$k$表示$m$的质因数个数，代码复杂度是$2^\text{m}$，能过（相同质因数不算两个

于是此题就做完了QwQ。  

### Coding.
```cpp
#include<bits/stdc++.h>
using namespace std;typedef long long ll;
int n,m,mm,cnt,a[105];ll ans=0;
inline ll qpow(ll x,int q) {ll r=1;for(;q;q>>=1,x*=x) if(q&1) r*=x;return r;}//快速幂
signed main()
{
	scanf("%d%d",&n,&m),cnt=0,ans=qpow(m,n),mm=m;//ans刚开始取总方案数
	for(int i=2,e=sqrt(m);i<=e;i++) if(m%i==0) {a[++cnt]=i;while(m%i==0) m/=i;}//分解质因数
	if(m>1) a[++cnt]=m;//这一行就是PS.中说的那一行，由此可看出笔者的菜。
	for(ll i=1,e=(1<<cnt),val=1,num=0;i<e;i++,val=1,num=0)
	{//这里用了二进制的方法，个人感觉代码更简易，不用写一个dfs了
		for(int j=1;j<=cnt;j++) if(i&(1ll<<(j-1))) num++,val*=a[j];//num表示当前取了多少个数，用于判断是+还是-
		if(num%2) ans-=qpow(mm/val,n);else ans+=qpow(mm/val,n);//val表示这num个数的乘积，便于计算答案。
	}
	return printf("%lld\n",ans),0;
}
```

---

## 作者：OIer991215 (赞：6)

C的题解

【问题描述】

一个序列长度为（N+1），且第（N+1）位为M，1≤任意元素≤M。

若序列中存在两个元素互质，则这种序列有多少种（元素可重复）？

【解题思路】

首先求出总方案数:pow(M,N);

思路一：首先找到所有与元素M含除了1以外含其他因子的元素并分离。

从第一个元素开始寻找这些元素中是第一个元素倍数的元素，并删去这些元素。

则此类元素可以组成若干个序列，且这种序列一定不满足条件。

继续寻找第二个元素，并寻找是第二个元素的倍数的元素，并删去这些元素。

则此类元素也可以若干个序列，且也一定不满足条件。

循环这个过程，直到所有元素被删去。


当所有元素被删去后，会发现有一部分序列被重复删去，产生了错误。因此需要将删去的元素补回来。要补回来的序列，一定是由之前元素组成的集合与集合之间产生交集的部分。但是操作起来复杂，且时间复杂度太高。


问题在于：容错率高，时间复杂度太高，可行度低。



思路二：由思路一可以发现，第一个元素（a）组成的集合中元素的个数为（M/a）（a为M的因数 且 显然为素数）。因此可以改进思路一的算法：将M的质因子分离出来，而不是将与M有公共因数的数字分裂出来。

（M/a）表示为：与M同含a因子的元素的个数，则这些元素构成的序列一定不满足条件。

若b也为M的质因子，则（M/b）同理，表示与M同含b为因子的元素个数，则此类元素构成的序列一定也不满足条件。若此循环下去，直到将所有元素筛选完毕。


同思路一一样，此思路也筛掉了大量重复的元素，造成错误，因此也需要将重复删除的序列补加回来。

因为a为质数，b为质数，因此a、b互质，且a、b同为M的质因子

则由（a\*b）及（a\*b）的倍数 的序列，一定被（M/a）形成的序列和（M/b）形成的序列都删去过。

因此设c=a\*b。则加上由（M/c）及其倍数组成的序列 就弥补了多余的删除。


但是显然，用这种方法加上的序列，又造成了多余的添加。因此需要再次删除。需要再次删除的序列一定由（M的三个质因子相乘的数字）及其倍数所组成。因此需要再将此类序列删除。

同理，本次删除的元素仍然会产生重复删除的序列，同理则需要加上重复删除的序列，这次加的序列中的元素一定由（M的四个质因子相乘的数字）及其倍数所组成。（证明方法同第一次删除和第一次添加）。







【解题公式】

若a、b、c、d、e为M的五个质因子。

总方案数为：pow（M，N）；

第一次删除的序列的个数为:

pow（M/a，N）+ pow（M/b，N）+pow（M/c，N）+pow（M/d，N）+pow（M/e，N）


需要添加的序列的个数为

pow（M/（a\*b），N）+ pow（M/（a\*c），N）+pow（M/（a\*d），N）+pow（M/（a\*e），N）+ pow（M/（b\*c），N）+ pow（M/（b\*d），N）+ pow（M/（b\*e），N）+                         pow（M/（c\*d），N）+ pow（M/（c\*e），N）+pow（M/（d\*e），N）；


再次删除的序列的个数为

pow（M/（a\*b\*c），N）+ pow（M/（a\*b\*d），N）+ pow（M/（a\*b\*e），N）+

pow（M/（b\*c\*d），N）+ pow（M/（b\*c\*e），N）+ pow（M/（c\*d\*e），N）


再次添加的序列个数为

pow（M/（a\*b\*c\*d），N）+ pow（M/（a\*b\*c\*e），N）+ pow（M/（b\*c\*d\*e），N）

再次删除的序列个数为

pow（M/（a\*b\*c\*d\*e），N）;


























【AC代码】


```cpp
#include <iostream>
#include <cstdio>
using namespace std;
typedef long long LL;
LL n,m,k,a,cnt,num,tot;
LL f[101000],g[101000];
LL pow(LL x,LL y)   //快速幂，STL中的pow会出现误差问题 
{
    LL ans=1;
    while(y)
    {
        if(y&1)ans*=x;
        x*=x;
        y>>=1;
    }
    return ans;
}
LL seperate()        //快速筛选质因子 
{
    int e=m;
    for(int i=2; i*i<=e; i++)
        if(e%i==0)
        {
            cnt++;
            f[cnt]=i;
            while((e%i)==0)
                e/=i;
        }
    if(e-1)
        f[++cnt]=e;
    return cnt;
}
void dfs(int now,int cj,int choose)     //质因子组合 
{
    if(choose>cnt+1)
        return;
    if(now==k+1)
    {
        g[++a]=cj;
        return;
    }
    dfs(now+1,cj*f[choose],choose+1);
    dfs(now,cj,choose+1);
}
signed main()
{
    scanf("%lld%lld",&n,&m);
    tot=pow(m,n);
    if(m==0)
    {
        cout<<"0";
        return 0;
    }
    seperate();
    for(int i=1; i<=cnt; i++)
    {
        k=i;
        dfs(1,1,1);
        if(i%2==1)
            for(int j=1; j<=a; j++)
                tot-=pow(m/g[j],n);
        else
            for(int j=1; j<=a; j++)
                tot+=pow(m/g[j],n);
        a=0;
    }
    cout<<tot;
    return 0;
}

```

---

## 作者：qwerty12346 (赞：4)

# [题目传送门](https://www.luogu.com.cn/problem/P2231)

## 题意

这题就是求有多少张可以完成任务。

## 思路

直接暴力枚举加容斥来做这题就行。先求 $m$ 的因子个数，并写一个函数 $a$，再顺便求 $ret$ 和 $sum$ 的值。然后判断如果 $m$ 不等于 $1$ 那么就再次让 $ret \times a(m,n)-1$ 并且也让 $sum \div m$。最后输出 $ret \times a(sum,n)$ 的值。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,ret=1;
long long a(long long x,long long y){//定义a函数
    long long ret=1;
    for(;y;y>>=1,x*=x)if(y&1)ret*=x;
    return ret;
}
int main(){
    cin>>n>>m;
    long long sum=m;
    for(int i=2;i*i<=m;i++)//暴力求m的因子顺便再求ret和sum
    {
	if(m%i==0)
	{
            ret*=a(i,n)-1;
            sum/=i;
	    while(m%i==0)m/=i;
	}
    }
    if(m!=1)//判断
    {
        ret*=a(m,n)-1;//更新一遍
        sum/=m;//更新一遍
    }
    cout<<ret*a(sum,n);
    return 0;
}
```


---

## 作者：jasonliujiahua (赞：3)

# P2231

[题目传送门](https://www.luogu.com.cn/problem/P2231)
## 题意简述：
给定 $n,m$，并从 $[1,m]$ 中选 $n$ 个数（可以相同）$a_1\sim a_n$，并令 $a_{n+1}=m$，问有多少种选法满足存在整数 $x_1\sim x_{n+1}$ 使得
$$\sum_{i=1}^{n+1} a_i x_i=1$$
$1\le n,m \le 10^8 ,1 \le m^n \le 10^{16}$。
## 题目分析：
### Step 1：
由裴蜀定理可知，$\sum_{i=1}^{n+1} a_i x_i=1$ 有解的充分必要条件是
$$\gcd_{i=1}^{n+1} a_i=1$$
于是问题变成了求解
$$\sum_{a_1=1}^{m}\sum_{a_2=1}^{m}\cdots \sum_{a_n=1}^{m}\left [\gcd \left(\left(\gcd_{i=1}^{n} a_i\right),m \right)=1\right ]$$
### Step 2：
接着就莫比乌斯反演：
$$\sum_{a_1=1}^{m}\sum_{a_2=1}^{m}\cdots \sum_{a_n=1}^{m}\left [\gcd \left(\left(\gcd_{i=1}^{n} a_i\right),m \right)=1\right ]$$

$$=\sum_{a_1=1}^{m}\sum_{a_2=1}^{m}\cdots \sum_{a_n=1}^{m}\sum_{d|gcd \left(\left(\gcd_{i=1}^{n} a_i\right),m \right)} μ(d)$$

$$=\sum_{d|m} μ(d)\sum_{a_1=1}^{\frac{m}{d}}\sum_{a_2=1}^{\frac{m}{d}}\cdots \sum_{a_n=1}^{\frac{m}{d}}$$

$$=\sum_{d|m} μ(d) \left ( \frac{m}{d}\right ) ^n$$

注意到，这次 $d$ 是有限制的（$m$ 的约数），因此整个求和就不是关于连续整数的了，因此可能用不了数论分块。然而，很幸运的是，$d$ 的限制是很强的。可以发现如果一个 $d$ 对上面这个和式有贡献，显然 $μ(d)\neq 0$，因此 $d$ 只能写成
$$\prod_{p_i\in P} (p_i)^1$$
的形式。因此只需考虑 $m$ 的 $t$ 个质因数，可以发现 $t$ 最大就到 $13$ 左右，因此考虑 $O(2^t)$ 枚举 $d$，顺便统计 $μ(d)$，最后再用快速幂计算即可。
## 参考代码：

```c++
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define ll long long
const int maxn=30;
ll n,m,ans,p[maxn],cnt;
void init()
{
    cin>>n>>m;
    int x=m;
    for(int i=2;i*i<=x;i++)//提取m的质因数
    {
        if(x%i==0) p[++cnt]=i;
        while(x%i==0) x/=i;
    }
    if(x>1) p[++cnt]=x;
}
inline int mu(int x)//这里是现场计算μ，但更优秀的做法是dfs时顺便统计
{
    if(x==1) return 1;
    int res=0;
    for(int i=2;i*i<=x;i++)
    {
        int tmp=0;
        if(x%i==0) res++;
        while(x%i==0)
        {
            tmp++;
            x/=i;
            if(tmp>1) return 0;
        }
    }
    if(x>1) res++;
    if(res&1) return -1;
    return 1;
}
inline ll power(ll x,ll y)//快速幂
{
    ll res=1;
    while(y)
    {
        if(y&1) res*=x;
        x*=x;
        y>>=1;
    }
    return res;
}
void work(int num,int d)
{
    if(num==cnt)
    {
        ans+=mu(d)*power(m/d,n);
        return;
    }
    work(num+1,d);//不选
    work(num+1,d*p[num+1]);//选
}
signed main()
{
    init();
    work(0,1);
    cout<<ans;
    return 0;
}
```

---

## 作者：封禁用户 (赞：3)

题目描述：读入n,m两个数，假设一个合法的数列是n+1位，且前n位不大于m，第n+1位为m。对于每一个数列，跳蚤可以选取任意一个数列中的数k，往左或右走k步（可以走多次），若使用这一个数列跳蚤可以到达左边一步的位置，那么这一个数列就是可以完成任务的数列。现在需要求出可以完成任务的数列的总数。

分析：题目需要找出所有能够到达左边一步位置的方案总数，能够到达左边一步，就相当于数列中所有数的最大公约数为1（可以通过扩欧推出），那么我们就转化成这样一个问题，取n个不大于m的数（位置不同也算不同方案），使得他们和m的最大公约数为1。

想到这一步，我们可以把问题转化为：所有合法数列的总数（m个数放到n位，共有m的n次方种）减去数列的最大公约数大于1的总数。

我们可以这么做：将m质因数分解，枚举m的质因数t，那么1到m之间有m/t个t的倍数，把数列中全都是这些m/t个数的方案数减去即可。

然而这种方法是存在问题的，有可能会重复减去同一种方案（6的倍数会同时在2的倍数和3的倍数时都减），所以需要枚举m的所有质因数的组合方式，记录每种组合的元素个数为tot，乘积为tmp，若tot是奇数，那么减去m/tmp个数放到n位里的方案个数，否则加上m/tmp个数放到n位里的方案个数（共有m/tmp的n次方种），这就是大名鼎鼎的容斥原理啊！

代码还是很短的。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
typedef long long LL;
int a[30],n,m;
LL ans;
LL pow(LL x,int y){
    LL ans=1;
    while(y){
        if(y&1)ans*=x;
        x*=x;
        y>>=1;
    }
    return ans;
}
void solve(){
    int k=m;
    for(int i=2;i*i<=k;i++)
        if(k%i==0){
            a[++a[0]]=i;
            while(k%i==0)k/=i;
        }
    if(k>1)a[++a[0]]=k;
    for(LL i=1;i<(1<<a[0]);i++){
        int tmp=1,tot=0;
        for(int j=1;j<=a[0];j++)
            if(i&(1LL<<(j-1)))
                tot++,tmp*=a[j];
        if(tot&1)ans-=pow(m/tmp,n);
        else ans+=pow(m/tmp,n);
    }
}
int main(){
    scanf("%d%d",&n,&m);
    ans=pow(m,n);
    solve();
    printf("%LLd\n",ans);
    return 0;
}
```

---

## 作者：Hisy (赞：1)

## 闲话
一定要掌握各种函数暴力求的方法，我就是不会暴力求 $\mu$ 然后用杜教筛 MLE 了，只能去网上搜……
## 分析
首先，转移成方程公式，可以得出：
$$\sum_{i=1}^{n}(a_i\times t_i)=t_{n+1}\times m-1$$
通过裴蜀定理，可以得出要满足：
$$\gcd_{i=1}^{n}(a_i)=1$$
这很满足莫比乌斯反演！

但是 $n$ 个很难处理，所以先来看两个：
$$\sum_{a_1=1}^{m}\sum_{a_2=1}^{m}[\gcd(i1,i2)]=1$$
很明显的变换：
$$\sum_{d\mid m}\mu(d)\times\lfloor\frac{m}{d}\rfloor^2$$
那么，之后也会是 $d\mid i1,d\mid i2,d\mid i3\dots$，那么，可以大胆的猜出公式：
$$\sum_{d\mid m}\mu(d)\times\lfloor\frac{m}{d}\rfloor^n$$
其实也很好理解，推出的公式后面全都是：
$$\sum_{a_1=1}^{\lfloor\frac{m}{d}\rfloor}\sum_{a_2=1}^{\lfloor\frac{m}{d}\rfloor}\sum_{a_3=1}^{\lfloor\frac{m}{d}\rfloor}\sum_{a_4=1}^{\lfloor\frac{m}{d}\rfloor}\dots\sum_{a_n=1}^{\lfloor\frac{m}{d}\rfloor}1=\lfloor\frac{m}{d}\rfloor^n$$
那么，就到这里了，正解。
## 代码
```cpp
#include<cstdio>
#include<vector>
#define MAXN 5000005
using namespace std;
typedef long long ll;
int mo[MAXN];
bool flag[MAXN];
vector<int> prim;
inline ll power(ll x,ll y){
    ll res=1;
    while(y){
        if(y&1){
            res*=x;
        }
        x*=x;
        y>>=1;
    }
    return res;
}
inline void prework(){
	mo[1]=1;
	for(int i=2;i<MAXN;++i){
		if(!flag[i]){
			mo[i]=-1;
			prim.push_back(i);
		}
		for(int j=0;j<prim.size()&&1ll*i*prim[j]<MAXN;++j){
			flag[i*prim[j]]=true;
			if(i%prim[j]){
				mo[i*prim[j]]=-mo[i];
			}else{
				mo[i*prim[j]]=0;
				break;
			}
		}
	}
}
inline int mobius(int n){
	if(n<MAXN){
		return mo[n];
	}
	int ans=1,mul=1;
	for(int i=2;i*i<=n;++i){
		if(n%i==0){
			ans=-ans;
			mul*=i;
		} 
		if(n%(i*i)==0){
			return 0;
		}
	}
	if(mul!=n){
		ans=-ans;
	}
	return ans;
}
int main(){
    prework();
	int n,m;
	scanf("%d %d",&n,&m);
	ll ans=0;
	for(int i=1;i<=m;++i){
		if(m%i==0){
			ans+=mobius(i)*power(m/i,n);
		}
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：Leasier (赞：1)

前置芝士：[裴蜀定理](https://oi-wiki.org/math/number-theory/bezouts/)、[莫比乌斯反演](https://oi-wiki.org/math/number-theory/mobius/)

由裴蜀定理可得：假设我选择的前 $n$ 个数的可重集为 $S$，则 $\gcd(m, \displaystyle\gcd_{x \in S} x) = 1$。

原式 $= \displaystyle\sum_{|S| = m, \max(S) \leq m} [\gcd(m, \gcd_{x \in S} x) = 1]$

$ = \displaystyle\sum_{d \mid m} \mu(d) \sum_{|S| = m, \max(S) \leq m, d \mid \gcd(S)} 1$

$ = \displaystyle\sum_{d \mid m} \mu(d) (\frac{m}{d})^n$

直接枚举因数暴力算 $\mu$ 即可。时间复杂度为 $O(\tau(m)(\sqrt{m} + \log n))$。

代码：
```cpp
#include <stdio.h>
#include <math.h>

typedef long long ll;

inline int mu(int n){
	int ans = 1;
	for (int i = 2; i * i <= n; i++){
		if (n % i == 0){
			n /= i;
			if (n % i == 0) return 0;
			ans = -ans;
		}
	}
	if (n > 1) ans = -ans;
	return ans;
}

inline ll quick_pow(ll x, ll p){
	ll ans = 1;
	while (p){
		if (p & 1) ans *= x;
		x *= x;
		p >>= 1;
	}
	return ans;
}

int main(){
	int n, m, t;
	ll ans = 0;
	scanf("%d %d", &n, &m);
	t = sqrt(m);
	for (int i = 1; i <= t; i++){
		if (m % i == 0){
			int tm = m / i;
			ans += mu(i) * quick_pow(tm, n);
			if (i != tm) ans += mu(tm) * quick_pow(i, n);
		}
	}
	printf("%lld", ans);
	return 0;
}
```

---

## 作者：Thomas0218 (赞：1)

# 题解：P2231 [HNOI2002] 跳蚤
原问题等价于求解关于 $x_i$ 的不定方程 $\sum_{i=1}^n a_i\times x_i + m\times x_{n+1} = 1$ 的解个数。

很显然，原方程当且仅当 $\gcd(a_1,a_2,\cdots,a_n,m)=1$ 时有解。

正难则反，即用 $m^n$ 减去 $\gcd(a_1,a_2,\cdots,a_n,m)\neq 1$ 的情况。

设 $\gcd(a_1,a_2,\cdots,a_n,m) = p$ 则 $\forall i, p\mid a_i$。考虑到 $a_i\leq m$，有 $\lfloor \frac{m}{p} \rfloor$ 种 $a_i$。

所以，对于 $m$ 的因数 $p$，共有 ${( \frac{m}{p})}^n$ 种方式使得答案有解。

考虑能不能只考虑 $m$ 的质因数的贡献。如果直接把 $m$ 的质因数的贡献加起来显然可能出现同一个质因数被算进其他质因数的贡献里。考虑容斥原理。

令全集 $U$ 为 $m$ 的所有质因数，则 $ans = \sum_{T\subseteq U} \left\{ (-1)^{\lvert T\rvert +1}{(\frac{m}{\prod_{p\in T}p})}^n\right\}$。

直接`dfs`或者状压计算即可，最终答案为 $m^n - ans$。

注意到 $2\times 3\times 5\times 7\times 11\times 13\times 17\times 19\times 23=223092870\geq 10^8$ 即 $U$ 中最多含有 $9$ 个元素。因此容斥时间复杂度 $O(2^9\times 9)$ 但考虑到需要分解质因数，因此总复杂度 $O(\sqrt{n})$。

给出关键代码：
```cpp
for(ll mask = 1; mask < (1 << k); mask++) {
    ll sum = 1; int cnt = 0;
    for(int i = 1; i <= k; i++)
        if(mask & (1ll << (i - 1))) cnt++, sum *= prime[i];
    if(cnt % 2 == 0) ans -= qpow(m / sum, n);
    else ans += qpow(m / sum, n);
}
```

---

## 作者：11400F (赞：0)

## P2231 跳蚤 题解



[不知道好不好的阅读体验](http://www.11490dx.net/2024/12/30/mobius-inversion)

---

这道题就是让我们求，给定序列 $a$ 的范围 $0 \le a_i \le m$，使方程
$$
a_1x_1 + a_2x_2 + \cdots + a_nx_n + mx_{n+1} = 1
$$
有整数解的 $a$ 序列的可能的不同的取值个数。

根据**裴蜀定理**的多个整数的推广：

> 设 $a_1, a_2, \cdots a_n$ 为不全为 $0$ 的整数，则存在整数 $x_1, x_2, \cdots , x_n$，使得 $a_1x_1 + a_2x_2 + \cdots a_nx_n = \gcd(a_1, a_2, \cdots a_n)$。
>
> （节选自 [OI-Wiki](https://oi-wiki.org/math/number-theory/bezouts/#%E5%A4%9A%E4%B8%AA%E6%95%B4%E6%95%B0)）

于是我们可以推断：$\gcd(a_1, a_2, \cdots a_n, m) = 1$。

即让我们求：
$$
\sum_{a_1 = 0}^{m} \sum_{a_2 = 0}^{m} \cdots \sum_{a_n=0}^{m} [\gcd(a_1, a_2, \cdots, a_n, m) = 1]
$$
因为序列中只要有一个 $0$，这个序列的公因数就为 $0$。即可以转为：
$$
\sum_{a_1 = 1}^{m} \sum_{a_2 = 1}^{m} \cdots \sum_{a_n=1}^{m} [\gcd(a_1, a_2, \cdots, a_n, m) = 1]
$$
根据莫比乌斯函数性质，则将其转为：
$$
\sum_{a_1 = 1}^{m} \sum_{a_2 = 1}^{m} \cdots \sum_{a_n=1}^{m}\sum_{d \mid gcd(a_1, a_2, \cdots a_n, m)} \mu(d) \\
= \sum_{a_1 = 1}^{m} \sum_{a_2 = 1}^{m} \cdots \sum_{a_n=1}^{m}\sum_{d \mid a_1 \land d\mid a_2 \land \cdots \land d \mid a_n \land d \mid m} \mu(d)
$$
即：
$$
\sum_{d \mid m} \mu(d)\cdot\sum_{a_1 = 1}^{\lfloor\frac{m}{d}\rfloor} \sum_{a_2 = 1}^{\lfloor\frac{m}{d}\rfloor} \cdots \sum_{a_n = 1}^{\lfloor\frac{m}{d}\rfloor} 1 \\
= \sum_{d \mid m} \mu(d) \cdot (\lfloor\frac{m}{d}\rfloor)^{n}
$$
而因为当 $d$ 为 $1$ 或没有平方项的质数的乘积时，$\mu(d)$ 才对答案有贡献（即值为 $1$ 或 $-1$。没有贡献的值就是 $0$，因为它根本影响不了答案）。所以我们可以先将 $m$ 质因数分解，然后枚举 $d$ 包含了 $m$ 的哪些质因子。$\mu(d)$ 因为有枚举的质因数个数，所以可以现算。然后后面的那个 $n$ 次方的玩意直接快速幂算出来即可。

Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 20;
int n, m;
int prime[N], primecnt;
void divide(int x){
    int lim = sqrt(x);
    for(int i=2;i<=lim && i<=x;i++){
        if(x%i==0){
            prime[++primecnt] = i;
            while(x%i==0) x/=i;
        }
    }
    if(x!=1) prime[++primecnt] = x;
}
typedef long long ll;
ll ans = 0;
ll ksm(ll bas, ll x){
    ll ans = 1;
    while(x){
        if(x&1) ans = ans * bas;
        bas = bas * bas;
        x >>= 1;
    }
    return ans;
}
void dfs(int x, int mu, int m_d){
    // int d;
    ans += mu * ksm(m_d, n);
    for(int i=x;i<=primecnt;i++){
        dfs(i+1, mu*(-1), m_d / prime[i]);
    }
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    cin>>n>>m;
    divide(m);
    dfs(1, 1, m);
    cout<<ans<<'\n';
}
```

---

## 作者：OIer_ACMer (赞：0)

注：本题部分图片素材来自[大佬的文章](https://blog.csdn.net/m0_60506105/article/details/138156586)。




# 题目概述：

给定两个数 $n$ 和 $m$，我们要拼出一个序列 $x$，使得满足这个式子：

$$\sum_{i=1}^n a_i\times x_i + m\times x_{n+1} = 1$$

请问序列 $x$ 有哪些搭配方式，注意，前 $n - 1$ 个元素要小于等于 $m$，同时 $m$ 要是最后一个元素。


# 题目解析：

根据式子，我们很容易通过[裴蜀定理](https://baike.baidu.com/item/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/5186593)得出我们其实只用满足如下关系式：

$$\gcd(a_1,a_2,\cdots,a_n,m)=1$$

那么，我们就要保证任意两个下标不相等的 $x_i$ 和 $x_j$ 元素要互质，则我们就可以将式子转化成有利于实现优化的模式（在前面最大公约数函数前面的函数符号是新定义函数的）,通过和式合并，我们得出一下等式：

$$\sum_{a_1=1}^{m}\sum_{a_2=1}^{m}\cdots \sum_{a_n=1}^{m}\left [\gcd \left(\left(\gcd_{i=1}^{n} a_i\right),m \right)=1\right ]$$

通过观察，我们可以发现，我们可以将新定义函数转换成莫比乌斯函数的变换式，那么，我们就可以进行莫比乌斯反演（不会莫比乌斯反演的请移步[此文章](https://zhuanlan.zhihu.com/p/138038817)），毕竟已经满足了初始条件，即所有的求和符号的下标已经可以一一对应，且这种时间复杂度我们无法接受，那么可以得到此式：（推理过程作者在这就不给了，因为大部分莫比乌斯函数的反演过程都差不多）：

$$\sum_{d|m} μ(d) \left ( \frac{m}{d}\right ) ^n$$

式子中的 $d$ 为等于 $1$ 的最大公约数的组合的因数，注意这个约数并不是等于 $1$，只不过是有这种情况。

由于只有一个求和符号，我们直接用循环便可以解决问题，而后面的次数 $n$ 很大，所以，快速幂也是必须要考虑的。


# 代码如下：

```

#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 4e6 + 9;
int n, m, x;
int ans, prime[N], cnt;
int qp(int n, int m)
{
    int ans = 1;
    while (m)
    {
        if (m & 1)
        {
            ans *= n;
        }
        n *= n;
        m >>= 1;
    }
    return ans;
}
void dfs(int x, int val, int mu)
{
    if (x == cnt + 1)
    {
        ans += mu * qp(m / val, n);
        return;
    }
    dfs(x + 1, val, mu);
    dfs(x + 1, val * prime[x], -mu);
}
signed main()
{
    cin >> n >> m;
    x = m;
    for (int i = 2; i * i <= x; i++)
    {
        if (x % i == 0)
        {
            prime[++cnt] = i;
            while (x % i == 0)
            {
                x /= i;
            }
        }
    }
    if (x > 1)
    {
        prime[++cnt] = x;
    }
    dfs(1, 1, 1);
    cout << ans << endl;
    return 0;
}

```

---

## 作者：white_carton (赞：0)

[更好的阅读体验](https://starback24.github.io)

[题目链接](https://www.luogu.com.cn/problem/P2231)

### 分析

原式由裴蜀定理化为 $mx_0+a_1x_1+a_2x_2+\dots+a_nx_n=1$ 的整数解的个数。考虑裴蜀定理（以下用 $a$ 表示 $a_1,a_2,a_3,\dots,a_n$），当 $gcd(m,a)=1$ 时方程有整数解，答案就是 $\sum_{i\in\left[1,n\right],1\le a_i\le m}\left[gcd(a,m)=1\right]$​。

对其变换，得到：
$$
\begin{aligned}\sum_{i\in\left[1,n\right],1\le a_i\le
m}\left[gcd(a,m)=1\right]&=\sum_{i\in\left[1,n\right],1\le a_i\le m}\sum_{d\mid gcd(a,m)}\mu(d)\\
&=\sum_{d\mid m}\mu(d)\sum_{i\in\left[1,n\right],1\le a_i\le m}\left[d\mid gcd(a)\right]\\
&=\sum_{d\mid m}\mu(d)\sum_{i\in\left[1,n\right],1\le a_i\le m}\left[\sum_{i=1}^{n}[d\mid a_i]=n\right]
\end{aligned}
$$
显然，符合条件的 $a_i$ 有 $\frac{m}{d}$ 种，因此，原式可继续化为：
$$
\sum_{d\mid m}\mu(d)\left(\frac{m}{d}\right)^n
$$
这样就可以快速求出答案了。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef unsigned long long ull;

#define endl '\n'
#define inf 0x3f3f3f3f
#define INF 0x3f3f3f3f3f3f3f3f
#define mkp make_pair
#define pb push_back
#define fir first
#define pp pop_back
#define eps 1e-8
#define sec second
#define pii pair<int,int>
#define eb emplace_back
#define file(filename) freopen(filename".in","r",stdin);freopen(filename".out","w",stdout);
#define For(i,a,b) for(int i=a;i<=b;i++)
#define Dor(i,a,b) for(int i=a;i>=b;i--)
//==============================================================================================
// Fast IO

template<typename T>
inline T read(){
	T f=1,c=0;
	char ch=getchar();
	while(!isdigit(ch)){
		if(ch=='-'){
			f=-1;
		}
		ch=getchar();
	}
	while(isdigit(ch)){
		c=(c<<1)+(c<<3)+(ch^48);
		ch=getchar();
	}
	T a=f*c;
	return a;
}

//=============================================================================================
//code here
#define int long long
int power(int a,int b){
	int ans=1;
	while(b){
		if(b&1){
			ans=ans*a;
		}
		a=a*a;
		b>>=1;
	}
	return ans;
}
int p[30],n,m,ct,ans,x;
void dfs(int u,int mu,int pw){
	if(u>ct){
		ans+=mu*power(x/pw,n);
		return;
	}
	dfs(u+1,mu*-1,pw*p[u]);
	dfs(u+1,mu,pw);
}
signed main(){
	cin>>n>>m;
	x=m;
	for(int i=2;i*i<=m;i++){
		if(m%i==0){
			p[++ct]=i;
			while(m%i==0){
				m=m/i;
			}
		}
	}
	if(m!=1){
		p[++ct]=m;
	}
	dfs(1,1,1);
	cout<<ans<<endl;
}
//吾日三省吾身
//输入多而不read()乎？
//1e18而不开longlong乎？
//多测不清乎？
```

### 闲话

感谢同机房大佬 @[K8He](https://www.luogu.com.cn/user/306045)

---

## 作者：a1co0av5ce5az1cz0ap_ (赞：0)

题意：给出 $n,m$，求满足 $\forall 1\le i\le n,1\le d_i\le m,d_{n+1}=m$ 且存在数组 $c$ 满足 $\sum d_ic_i=1$ 的 $d$ 的方案数。

首先根据裴蜀定理，有 $\gcd\limits_{i=1}^{n+1} d_i|1$，即 $\gcd(m,\gcd\limits_{i=1}^n d_i)=1$。

看到这个东西我们似乎没什么很好的做法，于是考虑容斥。

记 $f_x$ 为 $x|\gcd(m,\gcd\limits_{i=1}^n d_i)$ 的方案数，$g_x$ 为 $\gcd(m,\gcd\limits_{i=1}^n d_i)=x$ 的方案数。

考虑 $f_x$ 的每一种方案中每一位都必须是 $x$ 的倍数，则有 $\lfloor\dfrac mx\rfloor^n$ 种方案。

但是这个时候容易发现 $f_x$ 比 $g_x$ 多算了所有 $\gcd$ 为 $x$ 的倍数而且不是自己的情况，所以依次减掉即可。

注意到我们还有 $m$ 的限制，而 $10^8$ 范围内最多只有 $768$ 个因数，所以只用考虑这些因数之间的倍数关系即可。

```cpp
cin>>n>>m;
for(int i=1;i*i<=m;i++)if(m%i==0){//计算因数
  d.push_back(i);
  if(i*i!=m)d.push_back(m/i);
}
sort(all(d));
int l=d.size();
ans.resize(l);
ans[l-1]=1;
for(int i=l-2;~i;i--){
  ans[i]=qpow(m/d[i],n);
  for(int j=i+1;j<l;j++)if(d[j]%d[i]==0)ans[i]=ans[i]-ans[j];// 容斥
}
cout<<ans[0]<<"\n";
```

---

## 作者：Aiopr_2378 (赞：0)

### 解题思路

一个不用莫反的做法。

首先题目可以转化为 $\sum\limits_{i=1}^{n+1} c_i\times d_i =1$，其中 $c_i$ 为 $a$ 序列中数 $d_i$ 出现的次数。根据裴蜀定理，可以得到，上面的式子有解当且仅当 $\gcd (d_1,d_2,\dots,d_n,m)\mid 1$。也就是 $\gcd (d_1,d_2,\dots,d_n,m)= 1$。

考虑枚举最大公因数 $d$，显然，$d\mid m$。充分发扬人类智慧，根据结论可知 $10^{8}$ 内的因数最多的数只有 $768$ 个因数，直接枚举每一个 $m$ 的因数，然后容斥即可。

具体地，对于公因数 $d$，前 $n$ 个数每个数有 $\lfloor\dfrac n d\rfloor$ 个选择，故方案数为 $\lfloor\dfrac n d\rfloor^n$。然而这样只保证了有公因数 $d$，最大公因数可能是形如 $kd(k\in \mathbf Z)$ 的数，容斥掉 $d$ 的倍数即可。

时间复杂度为 $O(m+d(m)^2)$，其中 $d(m)$ 为 $m$ 的因数个数。

### 参考代码

```cpp
#include<iostream>
#include<unordered_map>
using namespace std;
typedef long long ll;
int n,m,w[10005],top;
ll ans;
unordered_map<ll,ll> f;
ll qpow(ll a,ll b){
    ll w=1;
    while(b){
        if(b&1) w=w*a;
        a=a*a;
        b>>=1;
    }
    return w;
}
int main(){
    cin>>n>>m;
    ans=qpow(m,n);
    for(int i=m;i>1;i--) if(m%i==0) w[++top]=i;
    for(int i=1;i<=top;i++){
        ll t=qpow(m/w[i],n);
        for(int j=1;j<i;j++) if(w[j]%w[i]==0) t-=f[w[j]];
        ans-=t;
        f[w[i]]=t;
    }
    cout<<ans<<endl;
    return 0;
}
```

---


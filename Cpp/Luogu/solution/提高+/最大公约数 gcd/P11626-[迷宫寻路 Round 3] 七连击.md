# [迷宫寻路 Round 3] 七连击

## 题目背景

**任何数和 $0$ 的最大公约数是它本身。**

## 题目描述

小 X 正在研究一个长度为 $n$ 的数列 $\{A\}$，他通过查阅资料，偶然间发现了一个叫做“七连击”的式子：$\sum\limits_{a=1}^n\sum\limits_{b=a+1}^n\sum\limits_{c=b+1}^n\sum\limits_{d=c+1}^n\sum\limits_{e=d+1}^n\sum\limits_{f=e+1}^n\sum\limits_{g=f+1}^n ((\gcd\limits_{i=1}^aA_i)+(\gcd\limits_{i=a+1}^bA_i)+(\gcd\limits_{i=b+1}^cA_i)+(\gcd\limits_{i=c+1}^dA_i)+(\gcd\limits_{i=d+1}^eA_i)+(\gcd\limits_{i=e+1}^fA_i)+(\gcd\limits_{i=f+1}^gA_i))$。

其中 $(\gcd\limits_{i=l}^r A_i)$ 表示 $A_l,A_{l+1},\dots,A_r$ 的最大公约数。

现在小 X 希望你求出这个式子的值。
由于答案可能很大，他只需要你输出答案对 $998244353$ 取模的结果。

## 说明/提示

**本题采用捆绑测试。**

对于所有数据，$7\le n\le 10^5$，$0\le A_i\le 10^9$。

| 子任务编号 | $n\leq$ | $A_i\leq$ | 特殊性质 | 分数 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $0$ | $7$ | $10^9$ | 否 | $1$ |
| $1$ | $10$ | $10^9$ | 否 | $9$ |
| $2$ | $100$ | $10^9$ | 否 | $10$ |
| $3$ | $1000$ | $10^9$ | 否 | $20$ |
| $4$ | $10^5$ | $100$ | 否 | $10$ |
| $5$ | $10^5$ | $10^9$ | 是 | $10$ |
| $6$ | $10^5$ | $10^9$ | 否 | $40$ |

特殊性质： 对于任意满足 $1\le i\le n$ 的整数 $i$，$A_i$ 在 $[0,10^9]$ 中随机生成。

## 样例 #1

### 输入

```
7
3 4 2 5 6 3 4
```

### 输出

```
27
```

## 样例 #2

### 输入

```
10
9 9 9 8 8 8 72 72 72 2
```

### 输出

```
20040```

## 样例 #3

### 输入

```
20
3 5 5 5 7 15 20 14 28 9 36 3 4 5 7 19 16 28 37 29
```

### 输出

```
3207876
```

## 样例 #4

### 输入

```
30
1 9 8 8 8 3 3 4 2 2 3 3 9 8 8 6 6 7 3 3 6 6 8 8 4 3 3 6 6 8```

### 输出

```
34595704```

## 样例 #5

### 输入

```
50
9 9 9 9 63 72 36 36 4 4 4 20 20 20 10 10 70 2 12 9 9 9 9 63 72 36 36 4 4 4 20 20 20 10 10 70 2 12 9 9 9 9 63 72 36 36 4 4 4 4```

### 输出

```
24688627```

# 题解

## 作者：george0929 (赞：3)

前置知识：ST 表，二分，前缀和优化 DP，最大公约数的性质。

转化一下题意，把序列分成八段，取前七段的 $\gcd$ 的和作为这个方案的贡献，求所有方案的贡献和。

有一个 $O(n^3)$ 的 DP：令 $f_{i,j}$ 表示第 $j$ 段结尾是 $i$ 的贡献和， $g_{i,j}$ 表示第 $j$ 段结尾是 $i$ 的方案数，则 $f_{i,j}\leftarrow \sum\limits_{k=1}^{i-1} (f_{k,j-1}+g_{k,j-1}\times \gcd\limits_{x=k+1}^{i} a_x),g_{i,j}\leftarrow \sum\limits_{k=1}^{i-1} g_{k,j-1}$。

考虑优化，$g$ 显然可以前缀和优化成 $O(n)$。

考虑用前缀和优化 $f$，发现难点在 $\gcd$。

由于右端点固定时，区间 $\gcd$ 至多有 $\log V$ 种取值，所以先用 ST 表预处理区间 $\gcd$，然后对于每个右端点二分计算 $\log V$ 种不同取值的左端点，然后前缀和优化，分 $\log V$ 段转移 $f$ 即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int mod=998244353;
void upd(int &a,int b){
	b=(b%mod+mod)%mod;
	a=(a+b)%mod;
}
int gcd(int a,int b){
	if(b==0) return a;
	return gcd(b,a%b);
}
int n,a[100005];
struct node{
	int l,r,v;
};
vector<node> V[100005];
int st[100005][21];
int f[100005][8],g[100005][8];
int sumf[100005][8],sumg[100005][8];
int cost(int l,int r){
	int k=__lg(r-l+1);
	return gcd(st[l][k],st[r-(1<<k)+1][k]);
}
void workg(int k){
	for(int i=1;i<=n;i++){
		upd(g[i][k],sumg[i-1][k-1]);
		upd(sumg[i][k],sumg[i-1][k]+g[i][k]);
	}
}
void workf(int k){
	for(int i=1;i<=n;i++){
		upd(f[i][k],sumf[i-1][k-1]);
		for(auto cur:V[i]){
			int l=cur.l,r=cur.r,v=cur.v;
			upd(f[i][k],v*(sumg[r-1][k-1]-sumg[l-2][k-1])%mod);
		}
		upd(sumf[i][k],sumf[i-1][k]+f[i][k]);
	}
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		st[i][0]=a[i]; 
	}
	for(int j=1;j<=20;j++){
		for(int i=1;i<=n;i++){
			if(i+(1<<(j-1))>n) continue;
			st[i][j]=gcd(st[i][j-1],st[i+(1<<(j-1))][j-1]);
		}
	}
	for(int i=1;i<=n;i++){
		int r=i,v=a[i];
		while(r>=2){
			v=gcd(v,a[r]);
			int L=2,R=r,l=r;
			while(L<=R){
				int mid=(L+R)/2;
				if(cost(mid,i)!=v){
					L=mid+1;
				}else{
					R=mid-1;
					l=mid;
				}
			}
			V[i].push_back({l,r,v});
			r=l-1;
		}
	}
	for(int i=1;i<=n;i++){
		f[i][1]=gcd(f[i-1][1],a[i]);
		upd(sumf[i][1],sumf[i-1][1]+f[i][1]);
		g[i][1]=1;
		sumg[i][1]=i;
	}
	for(int k=2;k<=7;k++) workg(k);
	for(int k=2;k<=7;k++) workf(k);
	int ans=0;
	for(int i=1;i<=n;i++){
		upd(ans,f[i][7]);
	}
	cout<<ans<<"\n";
	return 0;
}
```

---

## 作者：Colinxu2020 (赞：3)

引理：一个数列 $a$ 的前缀 $\gcd$ 的不同取值不超过 $\log_2 a_i$ 个，证明：每次 $\gcd$ 变化后新的 $\gcd$ 一定是原来的真因子，因此至少 $\div 2$，当 $\gcd=1$ 时一定不再变化。

考虑 `dp`，设 $dp_{i,j}$ 代表用 $a$ 的前 $j$ 项，已经拼出了题目给出的七段式中的前 $i$ 项，所有可能的前 $i$ 项的值之和，$cnt_{i,j}$ 为相应条件下的方案数，考虑正序转移，每次令 $dp_{i+1,x} \gets dp_{i+1,x} + dp_{i,j} + \gcd(a_j \cdots a_x) \times cnt_{i,j}$ 即可，用 `ST` 表预处理 $\gcd$ 后复杂度为 $O(kn^2 \log n)$，其中 $k=7$，期望获得 $40$ 分。

考虑优化，因为引理的结论，所以后面 $+$ 的东西只有 $\log$ 个不同的取值（前半部分是一个定值，后半部分可以视为 $a_{j \cdots n}$ 的前缀 $\gcd$），直接枚举每种取值，在 $\gcd$ 为枚举值的范围内区间加即可，用差分处理，复杂度为 $O(kn\log n+n\log^2n)$，部分实现可能退化到 $kn\log^2n$，期望获得 $100$ 分。

注意最后一段的结尾不一定是 $n$，所以答案为 $\sum_{i=7}^n dp_{7,i}$，而不是 $dp_{7,i}$。

细节：如何得到所有的相同的 $\gcd$ 的连续段，枚举连续段的开始，之后二分找到这个连续段的结束，并跳到结束的后面即可，参考实现：

```cpp
    for(int i=1;i<=n;i++){
        keys[i].push_back(i+1);
        for(int j=i+1;j<=n;){
            int l=j,r=n;
            while(l<=r){
                int mid=(l+r)/2;
                if(query(i+1, mid)==query(i+1, j))l=mid+1;
                else r=mid-1;
            }
            j=l;
            keys[i].push_back(j);
        }
    }
```



参考代码：

```cpp
#include<iostream>
#include<vector>
#include<cmath>
#include<numeric>
using namespace std;

#define ll long long
const int maxn=1e5+10,lg=20,mod=998244353;
int n,ai[maxn],dp[2][maxn],tree[maxn],st[maxn][lg],cnt[2][maxn];
vector<int> keys[maxn];
 
int gcd(int x, int y){ return y==0?x:gcd(y,x%y); }
void init(){
    for(int i=1;i<=n;i++)st[i][0]=ai[i];
    for(int j=1;j<lg;j++)for(int i=1;i+(1<<j)-1<=n;i++)st[i][j]=gcd(st[i][j-1], st[i+(1<<(j-1))][j-1]);
}
int query(int l, int r){ int k=log2(r-l+1); return gcd(st[l][k], st[r-(1<<k)+1][k]); }

int main(){
    cin>>n;
    for(int i=1;i<=n;i++)cin>>ai[i];
    init();
    for(int i=1;i<=n;i++){
        keys[i].push_back(i+1);
        for(int j=i+1;j<=n;){
            int l=j,r=n;
            while(l<=r){
                int mid=(l+r)/2;
                if(query(i+1, mid)==query(i+1, j))l=mid+1;
                else r=mid-1;
            }
            j=l;
            keys[i].push_back(j);
        }
        dp[1][i]+=query(1, i);
        dp[1][i+1]-=query(1, i);
    }
    cnt[1][1]++;
    for(int i=1;i<7;i++){
        for(int j=1;j<=n;j++)dp[0][j]=(dp[0][j-1]+dp[1][j])%mod,dp[1][j]=0;
        for(int j=1;j<=n;j++)cnt[0][j]=(cnt[0][j-1]+cnt[1][j])%mod,cnt[1][j]=0;
        for(int j=i;j<=n;j++)for(int k=0;k<keys[j].size()-1;k++){
            int v=(dp[0][j]+(ll)query(j+1, keys[j][k])*cnt[0][j]%mod)%mod;
            dp[1][keys[j][k]]=(dp[1][keys[j][k]]+v)%mod;
            dp[1][keys[j][k+1]]=(dp[1][keys[j][k+1]]-v)%mod;
            cnt[1][keys[j][k]]=(cnt[1][keys[j][k]]+cnt[0][j])%mod;
            cnt[1][keys[j][k+1]]=(cnt[1][keys[j][k+1]]-cnt[0][j])%mod;
        }
    }
    int ans=0,sum=0;
    for(int i=1;i<=n;i++)sum=(sum+dp[1][i])%mod,ans=(ans+sum)%mod;
    cout<<(ans+mod)%mod<<endl;
}
```

---

## 作者：jiangyixuan_eason (赞：2)

考虑使用动态规划。设 $f_{i,j}$ 代表的是用 $a$ 的前 $j$ 项。至此，我们已经拼好了题目中给的“七项式”中的前 $i$ 项内容。所有可能的前 $i$ 项之和，可以使用 $c_{i,j}$ 来表示方案数。

接下来，考虑转移。每次只需要让 $f_{i+1,x} \gets f_{i+1,x}+f_{i,j}+\gcd\left(a_j+ \ldots a_x \right) \times c_{i,j}$ 就完成了转移。

容易发现，可以进行预处理。可以使用 ST 表预处理最大公因数，这样做的时间复杂度就是 $O\left(k \times n^2 \log n \right)$ 。这样做的话，可以获得 $40$ 分，不能通过。 

继续考虑优化。根据[这个](https://www.luogu.com.cn/paste/8o26t73e)理论，可以发现后面加的东西有 $\log$ 个不同的取值。所以直接枚举每种取值，以最大公因数枚举值的范围内区间加即可。

随后拿差分处理即可。时间复杂度 $O\left(k \times n \log n+n \log^2 n\right)$ ，可以通过本题。

---

## 作者：orange_new (赞：1)

节选自：[DP做题记录（三）（2025.4.5 - 2025.4.19）](https://www.luogu.com.cn/article/tobtmxka)

[安利一下我的博客](https://www.cnblogs.com/JPGOJCZX/p/18830484)

对于一段区间的划分，很容易想到 DP。

我们设 $f_{i, j}$ 表示把前 $i$ 个数划分成 $j$ 段的答案，再设 $g_{i, j}$ 表示把前 $i$ 个数划分成 $j$ 段的方案数。考虑前一个划分点在什么位置，可以得到：

$$
g_{i, j} = \displaystyle\sum_{k = 1}^{i - 1} g_{k, j - 1}, g_{0, 0} = 1
$$

我们再考虑划分出的这一段对答案的贡献。如果们固定了一段区间 $[l, i]$，那么这段本身的贡献就是 $\gcd(a_l, \dots, a_i)$，而 $[1, l - 1]$ 就可以随便划分了，此时：

$$
f_{i, j} = \displaystyle\sum_{k = 1}^{i - 1} f_{k, j - 1} + g_{k, j - 1} \times \gcd_{l = k + 1}^i a_l
$$

观察可以发现，$g_{i, j}$ 的转移为上一行一段前缀的和，可以前缀和优化。而 $f_{i, j}$ 则因为加入了 $\gcd$ 的操作，不是很好前缀和优化。不过我们考虑当固定了右端点 $i$，左端点 $l$ 不断向左移动的过程中，区间 $\gcd$ 一定是单调不升的，而且每次减小，至少除以了一个 $2$，那么一定只用 $O(\log n)$ 次就除到了 $1$，然后就不会变了。于是我们二分答案找到每次区间 $\gcd$ 变化的位置，那么左端点从上一个二分出的点 $x$ 到这一次二分出的点 $y$ 时，区间 $\gcd$ 是不变的，那么此时就可以前缀和优化了。设分了 $k$ 段，复杂度为 $O(kn \log^2 n)$，足以通过此题。

完整代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1e5 + 9, LOGN = 19, MOD = 998244353;
int st[N][LOGN], LOG2[N], a[N], g[N][9], f[N][9], sumg[N][9], sumf[N][9], n;
void build(){
	LOG2[1] = 0;
	for(int i = 2; i <= n; i++)
		LOG2[i] = LOG2[i >> 1] + 1;
	for(int i = 1; i <= n; i++)
		st[i][0] = a[i];
	for(int j = 1; j <= LOG2[n]; j++)
		for(int i = 1; i + (1 << j) - 1 <= n; i++)
			st[i][j] = __gcd(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);
}
int ask(int l, int r){
	int k = LOG2[r - l + 1];
	return __gcd(st[l][k], st[r - (1 << k) + 1][k]);
}
int find(int l, int r){
	int val = ask(l, r), res = l, tmp = r;
	while(l <= r){
		int mid = (l + r) >> 1;
		if(ask(mid, tmp) == val){
			l = mid + 1;
			res = mid;
		} else
			r = mid - 1;
	}
	return res;
}
signed main(){
	scanf("%lld", &n);
	for(int i = 1; i <= n; i++)
		scanf("%lld", &a[i]);
	build();
	g[0][0] = sumg[0][0] = 1;
	for(int i = 1; i <= n; i++){
		g[i][0] = 1, sumg[i][0] = 1;
		for(int j = 1; j <= 7; j++){
			g[i][j] = sumg[i - 1][j - 1];
			sumg[i][j] = (sumg[i - 1][j] + g[i][j]) % MOD;
		}	
	}
	for(int i = 1; i <= n; i++){
		f[i][1] = ask(1, i);
		sumf[i][1] = (sumf[i - 1][1] + f[i][1]) % MOD;
		for(int l = 1, r; l <= i; l = r + 1){
			r = find(l, i);
			for(int j = 2; j <= 7; j++){
				if(!f[i][j]) f[i][j] = sumf[i - 1][j - 1];//wa *2
				f[i][j] = (f[i][j] + ask(l, i) * (sumg[r - 1][j - 1] - sumg[l - 2][j - 1] + MOD) % MOD) % MOD;
				sumf[i][j] = (sumf[i - 1][j] + f[i][j]) % MOD;
			}
		}
	}
	printf("%lld", sumf[n][7]);
	return 0;
} 
```

---

## 作者：HPXXZYY (赞：1)

$\color{blue}{\texttt{[Analysis]}}$

首先，对数据结构比较熟悉的同学应该知道，静态数组求区间最大公约数可以用 ST 表来解决。

> 事实上，ST 表的本质就是倍增算法。因此，只要是静态数组的问题，基本都可以用 ST 表解决。
> 
> 只不过，对于求区间和、区间异或和之类的问题，每个数出现次数对最终答案是有影响的，因此 ST 表查询答案的时候也必须用 $O(\log n)$ 的算法（一步一步跳着查询）。而区间最大最小值、区间最大公约数这些问题和每个数出现次数没有关系，可以直接 $O(1)$ 查询。

式子很复杂，也无法用一般的数论方法化简。因此，只能考虑 dp。

设 $\gcd\limits_{i=1}^{a} A_{i}$ 为第一段和，$\gcd\limits_{i=a+1}^{b} A_{i}$ 为第二段和，以此类推。

记 $f_{k,i}$ 表示只考虑到第 $i$ 个数，求其前 $k$ 段和，且第 $i$ 个数必须划到第 $k$ 段和时所有方案的总和。$g_{k,i}$ 表示只考虑到第 $i$ 个数，求其前 $k$ 段和，且第 $i$ 个数必须划到第 $k$ 段和时可行的区间划分的方案数。

最终答案即为：

$$\sum\limits_{i=7}^{n}f_{7,i}$$

则 $f$ 的转移方程为：

$$f_{k,i}=\sum\limits_{j=1}^{i-1}\left ( f_{k-1,j} + g_{k-1,j} \times \gcd\limits_{x=j+1}^{i} A_{x} \right )$$

$g$ 的转移方程为：

$$g_{k,i}=\sum\limits_{j=1}^{i-1}g_{k-1,j}$$

直接这么转移肯定会超时，考虑优化。显然 $g$ 可以用前缀和优化。

展开 $f$ 的转移方程：

$$f_{k,i} = \color{red}{\sum\limits_{j=1}^{i-1} f_{k-1,j}}+\color{blue}{\sum\limits_{j=1}^{i-1} g_{k-1,j} \times \gcd\limits_{x=j+1}^{i} A_{x}}$$

显然，红色部分也可以用前缀和优化。考虑优化蓝色部分。

固定 $i$，则 $u_{j}=\gcd\limits_{x=j+1}^{i} A_{x}$ 是一个变下限区间求最大公约数。区间右端点为 $i$ 是固定的。因此，$u_{j}$ 必然是 $A_{i}$ 的约数，且 $u_{j}$ 必然是 $u_{j+1}$ 的约数。故 $u_{j} \leq u_{j+1}$。

因此 $u$ 具有单调性，而 $A_{i}$ 的约数最多为 $\log A_{i}$ 个，因此 $u$ 至多可以分为 $\log A_{i}$ 段，**每段内 $u$ 值相同**。可以用二分法求出区间分界点。

对于 $u$ 值相同的区间，即 $\gcd\limits_{x=j+1}^{i} A_{x}$ 相同的区间，$g_{k-1,j}$ 的和可以用前缀和求出。

总的时间复杂度 $O(n \log^{2} n)$。

$\color{blue}{\text{Code}}$

```cpp
const int N=1e5+100;
const int mod=998244353;

struct ST_gcd{
	int f[22][N],n,_Log[N];
	
	void init(int n,int *a){
		(this->n)=n;
		_Log[0]=-1;
		
		for(int i=1;i<=n;i++){
			f[0][i]=a[i];
			_Log[i]=_Log[i>>1]+1;
		}
		
		for(int j=1;j<=20;j++)
			for(int i=1;i+(1<<j)-1<=n;i++)
				f[j][i]=gcd(f[j-1][i],f[j-1][i+(1<<(j-1))]);
	}
	int query(int l,int r){
		int s=_Log[r-l+1];
		return gcd(f[s][l],f[s][r-(1<<s)+1]);
	}
}st;//ST 表求区间最大公约数的模版

int f[10][N],g[10][N],pref[10][N],preg[10][N];
int n,a[N],ans;

int Bineary_Search(int left,int right,int i,int val){
	int l=left,r=right,ans=-1;
	
	while (l<=r){
		int mid=(l+r)>>1;
		
		if (st.query(mid,i)==val){
			ans=mid;
			r=mid-1;
		}
		else l=mid+1;
	}
	
	return ans;
}

struct node{
	int l,r,val;
};
vector<node> idx[N];

void calc_g(){
	for(int k=2;k<=7;k++)
		for(int i=k;i<=n;i++){
			g[k][i]=preg[k-1][i-1];
			preg[k][i]=(preg[k][i-1]+g[k][i])%mod;
		}
}
void calc_f(){
	for(int k=2;k<=7;k++)
		for(int i=k;i<=n;i++){
			f[k][i]=pref[k-1][i-1];
			
			for(node cur:idx[i]){
				int l=cur.l,r=cur.r,v=cur.val;
				
				f[k][i]=(f[k][i]+1ll*v*(((preg[k-1][r-1]-preg[k-1][l-2])%mod+mod)%mod)%mod)%mod;
			}
			
			pref[k][i]=(pref[k][i-1]+f[k][i])%mod;
		}
}

int main(){
	n=read();
	for(int i=1;i<=n;i++)
		a[i]=read();
	
	st.init(n,a);
	
	for(int i=1;i<=n;i++){
		for(int r=i,v=0;r>=2;){
			v=gcd(a[r],v);
			int l=Bineary_Search(2,r,i,v);
			
			idx[i].push_back((node){l,r,v});
			
			r=l-1;
		}
	}
	
	for(int i=1;i<=n;i++){
		f[1][i]=gcd(f[1][i-1],a[i]);
		pref[1][i]=(pref[1][i-1]+f[1][i])%mod;
		
		g[1][i]=1;
		preg[1][i]=i;
	}
	
	calc_g();
	calc_f();
	
	for(int i=7;i<=n;i++)
		ans=(ans+f[7][i])%mod;
	
	printf("%d",ans);
	
	return 0;
}
```

---

## 作者：Erine (赞：1)

感觉学 oi 越学越没信心，打洛谷 unrated 是很好的选择。。。。反正就是，四个题都一眼秒了，最后懒得写 t4 了。

考虑这个题在让你干啥、就是让你从前往后选 $7$ 次前缀，选完删掉，然后求 $\gcd$ 和。呃那我们转换一下，考虑对于某个区间计算作为第 $i$ 次选择的贡献，呃显然是两个组合数解决的事情吧。。。这样直接做到了 $7n^2$，不是很好看。

然后假设我们先枚举的右端点，其中一个组合数是固定的可以先提出来。根据一些经典结论，固定右端点，对所有左端点的区间 $\gcd$ 只有 $\Theta(\log V)$ 个（每次变化至少减半），然后你把这些区间全部拿下来就好了。还要算一个组合数上指标求和，经典结论套一套就行。

所以做到了 $7n\log n$，过了。

---

## 作者：Genius_Star (赞：1)

### 思路：

定义 $dp_{i, j}$ 表示前 $i$ 个数，考虑到第 $j$ 个部分的总和，$f_{i, j}$ 表示方案数。

转移显然，唯一的瓶颈就是存在 $dp_{i, j} \gets dp_{i, j} + dp_{k, j - 1} + f_{k, j - 1} W(k + 1, i)$，其中 $W(l, r)$ 表示区间 $[l, r]$ 的最大公约数。

有一个经典的 trick，对于一段前缀的 $\gcd$，其不同种类数不超过 $\log V$ 种。

故 ST 表维护区间 $\gcd$，然后二分找出 $\gcd$ 值相同的这一段，在线段树上进行区间加。

时间复杂度为 $O(Nk \log W\log N)$。

---


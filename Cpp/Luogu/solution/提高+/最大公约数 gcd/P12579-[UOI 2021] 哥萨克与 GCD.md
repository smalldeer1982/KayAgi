# [UOI 2021] 哥萨克与 GCD

## 题目描述

哥萨克 Vus 得到了一个包含 $n$ 个整数的数组 $a$。随后，他被告知存在另一个同样由 $n$ 个整数组成的数组 $b$，但具体内容未知。为了确定数组 $b$，哥萨克可以无限次使用以下操作
  - 选择两个整数 $1 \leq l \leq r \leq n$。
  - 查询 $b_l + b_{l + 1} + \dots + b_r$ 的和。
  - 支付 $\gcd(a_l, a_{l+1}, ..., a_r)$ 戈比，其中 $\gcd$ 表示最大公约数（例如 $\gcd(3, 5) = 1$，而 $\gcd(15, 30, 6) = 3$）。

Vus 需要你求出确定数组 $b$ 所需的最小戈比数。

随后，哥萨克会对数组 $a$ 进行 $q$ 次修改，每次将某个 $a_i$ 改为 $x$。每次修改后，你需要重新计算更新后的数组所需的最小戈比数。

## 说明/提示

### 评分标准

- （8 分）：$n \le 10^2, q = 0$；
- （7 分）：$n \le 10^3, q = 0$；
- （11 分）：$q = 0$；
- （12 分）：$q \leq 100$；
- （9 分）：$q \leq 500$；
- （23 分）：$q \leq 10000$；
- （30 分）：无额外限制。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
5 3
20 40 9 25 15
3 10
5 21
4 135```

### 输出

```
5
25
9
11```

## 样例 #2

### 输入

```
4 2
20 4 8 36
1 2
4 18```

### 输出

```
16
8
8```

# 题解

## 作者：Invisible_H (赞：2)

## Part 1

前置知识：最小生成树。

先进行一个转化：

每次花费 $\gcd_{i=l + 1}^{r} B_i$ 的代价，可以连 $(l,r)$ 这一条边。

然后我们需要求 $0∼n$ 的最小生成树。

代码很好写啊就建完全图跑最小生成树，记得清空 $fa$ 数组，时间复杂度 $O(q n ^2 \log n)$。


```cpp
#include <bits/stdc++.h>
#define int long long

constexpr int maxn = 1e6 + 7;
int B[maxn];
struct node{
	int u, v, w;
}G[maxn];
int fa[maxn], n, q;
inline int find(int u){
	if(u != fa[u]){
		fa[u] = find(fa[u]);
	}
	return fa[u];
}
inline bool cmp(node a, node b){
	return a.w < b.w; 
}
int32_t main(){
	std::cin.tie(nullptr) -> std::ios::sync_with_stdio(false);
	std::cin >> n >> q;
	for(int i = 1; i <= n; i++){
		std::cin >> B[i];
	}
	for(int i = 0; i <= n; i++){
		fa[i] = i;
	}
	int m = 0;
	int k, val;
	for(int i = 0; i <= n; i++){
		int g = B[i + 1];
		for(int j = i + 1; j <= n; j++){
			g = std::__gcd(g, B[j]);
			G[++m].u = i;
			G[m].v = j;
			G[m].w = g;
			
		}
	}
	int ans = 0;
	std::sort(G + 1, G + m + 1, cmp);
	int cnt = 0;
	for(int i = 1; i <= m; i++){
		int fu = find(G[i].u), fv = find(G[i].v);
		if(fu == fv) continue;
		ans += G[i].w;
		fa[fv] = fu;
		cnt++;
		if(cnt == n) break;
	}
	std::cout << ans << '\n';
	while(q--){
		for(int i = 0; i <= n; i++){
			fa[i] = i;
		}
		int m = 0;
		int k, val;
		std::cin >> k >> val;
		B[k] = val;
		for(int i = 0; i <= n; i++){
			int g = B[i + 1];
			for(int j = i + 1; j <= n; j++){
				g = std::__gcd(g, B[j]);
				G[++m].u = i;
				G[m].v = j;
				G[m].w = g;
				
			}
		}
		int ans = 0;
		std::sort(G + 1, G + m + 1, cmp);
		int cnt = 0;
		for(int i = 1; i <= m; i++){
			int fu = find(G[i].u), fv = find(G[i].v);
			if(fu == fv) continue;
			ans += G[i].w;
			fa[fv] = fu;
			cnt++;
			if(cnt == n) break;
		}
		std::cout << ans << '\n';
	}
	return 0;
}
```
## Part 2
考虑优化。

前置知识：最小生成树。

根据 `Kruskal` 的思想，$(0,n)$ 这条边一定会被选。

然后根据 `Prim` 的思想，对于某个点，我们需要找到其最短的出边。

而显然对于 $i$，它最短的出边为 $(i,0)$ 或者 $(i,n)$。边权为 $L_i=\gcd_{j=1}^{i} B_j$ 和 $R_i=\gcd_{j=i+1}^{n} B_j$。

然后你只需要建 $0$ 到所有点的边和 $n$ 到所有点的边就好了，时间复杂度 $O(q n \log n)$。


```cpp
#include <bits/stdc++.h>
#define int long long

constexpr int maxn = 1e6 + 7;
int B[maxn], m;
struct node{
	int u, v, w;
}G[maxn];
int fa[maxn], n, q;
inline int find(int u){
	if(u != fa[u]){
		fa[u] = find(fa[u]);
	}
	return fa[u];
}
inline bool cmp(node a, node b){
	return a.w < b.w; 
}
int32_t main(){
	std::cin.tie(nullptr) -> std::ios::sync_with_stdio(false);
	std::cin >> n >> q;
	for(int i = 1; i <= n; i++){
		std::cin >> B[i];
	}
	for(int i = 0; i <= n; i++){
		fa[i] = i;
	}
	int m = 0;
	int k, val;
	int g = 0;
	for(int i = 1; i <= n; i++){
		g = std::__gcd(g ,B[i]);
		G[++m].u = 0;
		G[m].v = i;
		G[m].w = g;
	}
	g = 0;
	for(int i = n; i >= 1; i--){
		g = std::__gcd(g ,B[i]);
		G[++m].u = i - 1;
		G[m].v = n;
		G[m].w = g;
	}
	int ans = 0;
	std::sort(G + 1, G + m + 1, cmp);
	int cnt = 0;
	for(int i = 1; i <= m; i++){
		int fu = find(G[i].u), fv = find(G[i].v);
		if(fu == fv) continue;
		ans += G[i].w;
		fa[fv] = fu;
		cnt++;
		if(cnt == n) break;
	}
	std::cout << ans << '\n';
	while(q--){
		for(int i = 0; i <= n; i++){
			fa[i] = i;
		}
		int m = 0;
		int k, val;
		std::cin >> k >> val;
		B[k] = val;
		int g = 0;
		for(int i = 1; i <= n; i++){
			g = std::__gcd(g ,B[i]);
			G[++m].u = 0;
			G[m].v = i;
			G[m].w = g;
		}
		g = 0;
		for(int i = n; i >= 1; i--){
			g = std::__gcd(g ,B[i]);
			G[++m].u = i - 1;
			G[m].v = n;
			G[m].w = g;
		}
		int ans = 0;
		std::sort(G + 1, G + m + 1, cmp);
		int cnt = 0;
		for(int i = 1; i <= m; i++){
			int fu = find(G[i].u), fv = find(G[i].v);
			if(fu == fv) continue;
			ans += G[i].w;
			fa[fv] = fu;
			cnt++;
			if(cnt == n) break;
		}
		std::cout << ans << '\n';
	}
	return 0;
}
```

## Part 3
考虑继续优化。

前置知识：线段树二分。

显然 $L_i$ 是单调不增，$R_i$ 是单调不减的。

所以一定存在一个 $p \in [0,n),\forall i\in[0,p],R_i \leq Li,\forall i \in (p,n),Li \leq Ri$。

我们可以用线段树维护每个区间 $[l,r]$ 的 $\gcd_{l+1}^{r} B_i$，然后在线段树上二分求出 $p$。

而题目所给的修改可以直接单点修改。

剩下的就是求 $\sum_{i=0}^{p} R_i + \sum_{i=p+1}^{n-1} L_i$。

考虑到 $L_i$ 以及 $R_i$ 的取值个数是 $\log n$ 级别的，我们可以在线段树上暴力找出这些取值以及其对应的区间，时间复杂度 $O(q \log^2 n)$。


```cpp
#include <bits/stdc++.h>
#define mid ((l+r)>>1)
#define int long long
int SGT[400007];
void build(int p, int l, int r) {
    if (l == r)
        return (void)(std::cin >> SGT[p]);

    build(p << 1, l, mid), build(p << 1 | 1, mid + 1, r), SGT[p] = std::__gcd(SGT[p << 1], SGT[p << 1 | 1]);
}
void update(int p, int l, int r, int x, int v) {
    if (l == r)
        return (void)(SGT[p] = v);

    x <= mid ? update(p << 1, l, mid, x, v) : update(p << 1 | 1, mid + 1, r, x, v);
    SGT[p] = std::__gcd(SGT[p << 1], SGT[p << 1 | 1]);
}
int Find(int p, int l, int r, int a, int b) {
    if (l == r)
        return l;

    int x = std::__gcd(a, SGT[p << 1]), y = std::__gcd(b, SGT[p << 1 | 1]);
    return x <= y ? Find(p << 1, l, mid, a, y) : Find(p << 1 | 1, mid + 1, r, x, b);
}
int cal1(int p, int l, int r, int x, int v) {
    if (l == r)
        return std::__gcd(SGT[p], v);

    int a = std::__gcd(SGT[p << 1 | 1], v), b = std::__gcd(SGT[p << 1], a);
    return x <= mid ? cal1(p << 1, l, mid, x, a) : (a == b ? 1ll * (mid - l + 1) * a : cal1(p << 1, l, mid, x, a)) + cal1(p << 1 | 1, mid + 1, r, x, v);
}
int cal2(int p, int l, int r, int x, int v) {
    if (l == r)
        return std::__gcd(SGT[p], v);

    int a = std::__gcd(SGT[p << 1], v), b = std::__gcd(SGT[p << 1 | 1], a);
    return x > mid ? cal2(p << 1 | 1, mid + 1, r, x, a) : (a == b ? 1ll * (r - mid) * a : cal2(p << 1 | 1, mid + 1, r, x, a)) + cal2(p << 1, l, mid, x, v);
}
int32_t main() {
    int n, Q;
	std::cin >> n >> Q; 
    build(1, 1, n);
	int p = Find(1, 1, n, 0, 0);
	std::cout << (cal1(1, 1, n, p, 0) + cal2(1, 1, n, p, 0) - SGT[1]) << '\n';
    for (int p, v; Q; --Q) std::cin >> p >> v, update(1, 1, n, p, v), p = Find(1, 1, n, 0, 0), std::cout << (cal1(1, 1, n, p, 0) + cal2(1, 1, n, p, 0) - SGT[1]) << '\n';

    return 0;
}

```

---

## 作者：Seaproyje (赞：2)

**神秘**题。  
每次可以花 $\gcd(a_l,a_{l+1},\cdots,a_r)$ 的代价得知 $b_l+b_{l+1}+\cdots+b_r$ 的和。  
求确定 $b$ 数组的最小代价，要单点修改 $a_i$。  
__________________
先考虑不带修怎么做。  
发现每次等价于花费**代价**连接 $l-1$ 和 $r$，那么便转化为**最小生成树**问题。  
考虑优化这个过程。  
发现每个点能连的边里边权最小的是连到 $0$ 或 $n$。  
而 $n$ 最小一定是连到 $0$，连完后发现剩余的点再连最短的边最后就是一颗**最小生成树**。  
此时便可以做到 $O(n \log V)$。  
带修呢？  
发现有**决策单调性**，会有个**断点**，它和它左边的一定向 $n$ 连，它右边的一定向 $0$ 连。  
那么便可以**二分**出来断点，查询前缀 $\gcd$ 的后缀和，后缀 $\gcd$ 的前缀和。  
两个是等价的，先考虑其中维护一个。  
发现前缀 $\gcd$ 是不增的，一共只会有 $\log V$ 种不同的**取值**，那么便可以求出每种取值的所在的
区间，然后在线段树上区间赋值。  
这个你考虑开一棵线段树维护区间 $\gcd$，每次把要求的取值 $v$ 带进线段树里二分，在当前区间判断一下左儿子的区间 $\gcd$ 是否是 $v$ 的倍数，不是便说明该取值右端点一定在里面，右端点同理。  
然后就做完了。

---

## 作者：流水行船CCD (赞：2)

重点提一下本题模型的转化。其他题解对此部分均一笔带过，非常震撼。

感觉本题的难点就是模型转化而非后面的优化。

## 模型转化

考虑刻画一个可能成为最优解的合法解。

- **引理 1**：操作次数至少为 $n$。

证明：每一次操作 $[l,r]$ 就等价于一个方程 $b_l+b_{l+1}+\cdots+b_{r}=x$。根据线性代数知识，只有在方程个数 $\ge n$ 的时候 $b$ 才可能有唯一解。

注意到我们不会查询一个我们可以通过已知的区间消元得到其区间和的区间，这样一定不优（如查询了 $[1,4],[1,2],[2,2]$，我们一定不会查询 $[1,1],[3,4]$）。因此考虑刻画一个区间可以被其他区间消元得到的条件。

- **引理 2**：在可能成为最优解的方案中，如果我们把操作 $[l,r]$ 看作无向边 $(l-1,r)$，则最后形成的图无环。

证明：令一条边查询到的 $b$ 数组区间和为它的权值，$a$ 数组的区间 $\gcd$ 为它的代价。反证法，如果最后的图有环，把环上的边首尾相接强制定向后（反向则其权值取负），一个环上总权值显然为 $0$，因此如果该环大小为 $k$，知道其中 $k-1$ 个环边的代价就一定可以推出剩余那条环边的代价，所以有边多余，一定不优。

综上，最后的图是一个至少 $n$ 条边，$n+1$ 个点的无向无环图，即一颗树。

所以原问题等价于一个 $n+1$ 个点的完全图（边 $(u,v)$ 的代价为 $[u+1,v]$ 的 $\gcd a_i$）中的最小代价生成树问题。

## 静态版本
 
完全图 MST，考虑 Boruvka 算法，不会该算法可以看这篇（学个思想就行了）：[link](https://www.luogu.com.cn/article/wx1btddf)。

对于这道题，发现一个区间越长其 $\gcd$ 值越小，所以每一轮，对于一个点 $i$ 直接找到左侧/右侧的最远的和它不属于同一连通块的点，只有这两个点可能成为最近点，比较一下即可。需要维护区间 $\gcd$，写个 ST 表就可以了，$O(n \log n \log V)$。

但是这个做法没有充分利用性质。观察我们 Boruvka 的过程，发现该算法只会执行一轮：首先 $0$ 和 $n$ 一定会互相连边，因为它们都是各自的最远点。而中间的每一个点 $i$ 都会向 $0$ 或 $n$ 连边。因此原图在执行完第一轮后一定连通，无需执行第二轮。

此算法可以做到 $O(n \log V)$。

## 动态版本

带修，考虑动态维护上述静态算法的决策过程。注意到我们本质上是在决策 $i(0<i<n)$ 是向 $0$ 还是向 $n$ 连边。

考虑维护出每个 $i(0<i<n)$ 向 $0$ 连边的代价 $X_i$ 和向 $n$ 连边的代价 $Y_i$，那么答案即为：$\gcd(a_1,a_2,\cdots,a_n)+\sum \min(X_i,Y_i)$。

考虑去除 $\min$ 的限制。由于 $X_i$ 单减，$Y_i$ 单增，我们可以分别维护 $X,Y$，最后二分出第一个 $X_i<Y_i$ 的 $i$，则 $[1,i-1]$ 用 $Y$ 贡献，$[i,n-1]$ 用 $X$ 贡献。

注意到 $X,Y$ 是前后缀 $\gcd$，其值域种类数是 $O(\log V)$ 级别，你单点修改的时候就在一颗维护区间 $\gcd$ 的线段树上线段树二分划分连续段就可以了。

$O(n \log V + q \log n \log^2 V)$，但是常数较小。

---

## 作者：Shunpower (赞：0)

太难绷了，做了一上午的原因竟是不想写正解，结果乱搞更难写。

不过去年不会做这道题，今年会做了。^^

----------

首先考虑这个条件太神秘了，先尝试做到多项式复杂度。我们本质上是用一次代价为 $\gcd([l,r])$ 的查询查出来了 $sum_r-sum_{l-1}$。

我们唯一已知的是 $sum_0$，显然这个这个方程组可解是还原序列的充分必要条件。不妨考虑连边 $l-1$ 和 $r$，显然我们需要一棵生成树才能反解所有 $sum$，从而还原序列。

于是用 Kruskal 跑个最小生成树即可做到 $\mathcal O(n^2q\log n)$，可以获得 $15$ 分。

考虑观察最小生成树的形态。可以发现最小生成树一定形如 $0$ 连接一个后缀，$n$ 连接一个前缀。这个观察感性理解比较容易，理性证明可以直接套 Prim，这里不赘述了。

于是我们获得了 $\mathcal O(nq\log n)$ 的做法，每次询问需要重构整个序列的前缀 $\gcd$ 的后缀和和后缀 $\gcd$ 的前缀和。可以获得 $47$ 分。

> 然后我们有一个乱搞做法。容易证明这两个和满足凹性质，我们本质上要求每个断点这两个东西的和，依然是凹的。  
> 然而整数三分不可行，不过我们可以爬山。使用爬山算法和线段树维护可以获得 $70$ 分。但是我觉得比正解还难写。

考虑一些显然的性质：前缀 $\gcd$ 只有 $\log$ 段，后缀 $\gcd$ 也只有 $\log$ 段，所以两个前后缀和实际上是一个包含 $\log$ 段的一次函数分段函数。于是所有本质不同的区间只有 $2\log$ 个，每个区间里面的两坨一次函数是一样的。

那么对于某个区间，两个一次函数的叠加依然是一次函数，所以答案也可以被表示为一个关于下标的一次函数。

于是我们只需查 $2\log$ 个区间的一次函数最值（两个一次函数的和依然是一次函数），算出所有区间之后随便扫一下就好了。

最后剩下的问题如何维护这些前后缀 $\gcd$ 段。显然可以用线段树维护 $\gcd$，然后在线段树上二分。

时间复杂度 $\mathcal O(q\log n\log^2 V)$，瓶颈在维护段。但是 $\gcd$ 的两只 log 显然跑不太满，可以获得 $100$ 分。

```cpp
int n,q;
int a[N],pre[N],suf[N];
#define mid (l+r>>1)
struct sgta{
    int g[N<<2];
    il void pushup(int p){
        g[p]=__gcd(g[p<<1],g[p<<1|1]);
    }
    void build(int p,int l,int r){
        if(l==r) return g[p]=a[l],void();
        build(p<<1,l,mid);
        build(p<<1|1,mid+1,r);
        pushup(p);
    }
    int query(int p,int l,int r,int ml,int mr){
        if(ml<=l&&r<=mr) return g[p];
        int ans=0;
        if(ml<=mid) ans=__gcd(ans,query(p<<1,l,mid,ml,mr));
        if(mid<mr) ans=__gcd(ans,query(p<<1|1,mid+1,r,ml,mr));
        return ans;
    }
    void insert(int p,int l,int r,int d,int x){
        if(l==r) return g[p]=x,void();
        if(d<=mid) insert(p<<1,l,mid,d,x);
        else insert(p<<1|1,mid+1,r,d,x);
        pushup(p);
    }
    vector <pair<pii,pii>> seg;
    void cut(int p,int l,int r,int ml,int mr){
        if(ml<=l&&r<=mr){
            seg.push_back({{l,r},{p,g[p]}});
            return;
        }
        if(ml<=mid) cut(p<<1,l,mid,ml,mr);
        if(mid<mr) cut(p<<1|1,mid+1,r,ml,mr);
    }
    int binarylef(int p,int l,int r,int x){
        if(l==r) return l;
        if(__gcd(x,g[p<<1])==x) return binarylef(p<<1|1,mid+1,r,x);
        else return binarylef(p<<1,l,mid,x);
    }
    int binaryrig(int p,int l,int r,int x){
        if(l==r) return l;
        if(__gcd(x,g[p<<1|1])==x) return binaryrig(p<<1,l,mid,x);
        else return binaryrig(p<<1|1,mid+1,r,x);
    }
    int binarysuf(int x,int g){
        seg.clear();
        cut(1,1,n,x,n);
        for(auto i:seg){
            if(__gcd(g,i.se.se)!=g){
                return binarylef(i.se.fi,i.fi.fi,i.fi.se,g)-1;
            }
        }
        return n;
    }
    int binarypre(int x,int g){
        seg.clear();
        cut(1,1,n,1,x);
        reverse(seg.begin(),seg.end());
        for(auto i:seg){
            if(__gcd(g,i.se.se)!=g){
                return binaryrig(i.se.fi,i.fi.fi,i.fi.se,g)+1;
            }
        }
        return 1;
    }
} T;
vector <pair<pii,int>> pseg,sseg;
//sufsum[2,i+1]+presum[i+1,n], i\in[0,n-1]
vector <pair<pii,pll>> pl,sl;
vector <int> keypos;
void work(){
    // for(auto i:pseg) cout<<i.fi.fi<<' '<<i.fi.se<<' '<<i.se<<endl;
    // for(auto i:sseg) cout<<i.fi.fi<<' '<<i.fi.se<<' '<<i.se<<endl;
    // cout<<endl;
    pl.clear(),sl.clear(),keypos.clear();
    ll nowsum=0;
    fr2(i,(int)pseg.size()-1,0){
        int l=pseg[i].fi.fi,r=pseg[i].fi.se;
        pl.push_back({{l-1,r-1},{-pseg[i].se,nowsum+1ll*r*pseg[i].se}});
        nowsum+=1ll*(r-l+1)*pseg[i].se;
    }
    reverse(pl.begin(),pl.end());
    nowsum=0;
    fr2(i,(int)sseg.size()-1,0){
        int l=sseg[i].fi.fi,r=sseg[i].fi.se;
        sl.push_back({{l-1,r-1},{sseg[i].se,nowsum+1ll*(2-max(l,2))*sseg[i].se}});
        nowsum+=1ll*(r-max(l,2)+1)*sseg[i].se;
    }
    for(auto i:pl) keypos.pb(i.fi.fi);
    for(auto i:sl) keypos.pb(i.fi.fi);
    sort(keypos.begin(),keypos.end());
    // for(auto i:pl) cout<<i.fi.fi<<' '<<i.fi.se<<' '<<i.se.fi<<"x+"<<i.se.se<<endl;
    // for(auto i:sl) cout<<i.fi.fi<<' '<<i.fi.se<<' '<<i.se.fi<<"x+"<<i.se.se<<endl;
    // cout<<endl;
    ll ans=1e18;
    for(auto i:keypos){
        int L=i;
        int itp=lower_bound(pl.begin(),pl.end(),mp(mp(L+1,0),mp(0ll,0ll)))-pl.begin();
        itp--;
        int its=lower_bound(sl.begin(),sl.end(),mp(mp(L+1,0),mp(0ll,0ll)))-sl.begin();
        its--;
        int R=min(pl[itp].fi.se,sl[its].fi.se);
        ll k1,k2,l1,l2;
        tie(k1,l1)=pl[itp].se,tie(k2,l2)=sl[its].se;
        if(k1+k2>0) ans=min(ans,1ll*(k1+k2)*L+l1+l2);
        else ans=min(ans,1ll*(k1+k2)*R+l1+l2);
    }
    cout<<ans<<'\n';
}
int main(){
#ifdef Ltp
    freopen("hack.txt","r",stdin);
    freopen("out.txt","w",stdout);
#endif
    ios::sync_with_stdio(false);
    cin>>n>>q;
    fr1(i,1,n) cin>>a[i];
    fr1(i,1,n) pre[i]=__gcd(pre[i-1],a[i]);
    fr2(i,n,1) suf[i]=__gcd(suf[i+1],a[i]);
    {int lst=1;
    fr1(i,1,n){
        if(pre[i]!=pre[i+1]) pseg.push_back({{lst,i},pre[i]}),lst=i+1;
    }}
    {int lst=n;
    fr2(i,n,1){
        if(suf[i]!=suf[i-1]) sseg.push_back({{i,lst},suf[i]}),lst=i-1;
    }}
    T.build(1,1,n);
    work();
    fr1(i,1,q){
        int x,y;
        cin>>x>>y;
        a[x]=y;
        T.insert(1,1,n,x,y);
        {
        while(pseg.back().fi.fi>x) pseg.pop_back();
        int pos=pseg.back().fi.fi;
        pseg.pop_back();
        while(pos!=n+1){
            int nowg=T.query(1,1,n,1,pos);
            int ans=T.binarysuf(pos,nowg);
            pseg.push_back({{pos,ans},nowg});
            pos=ans+1;
        }}
        {
        while(sseg.back().fi.se<x) sseg.pop_back();
        int pos=sseg.back().fi.se;
        sseg.pop_back();
        while(pos){
            int nowg=T.query(1,1,n,pos,n);
            int ans=T.binarypre(pos,nowg);
            sseg.push_back({{ans,pos},nowg});
            pos=ans-1;
        }}
        work();
    }
    // cerr<<clock()<<endl;
    ET;
}
//ALL FOR Zhang Junhao.
```

---

## 作者：OrinLoong (赞：0)

## LGP12579 [UOI 2021] 哥萨克与GCD 学习笔记
[Luogu Link](https://www.luogu.com.cn/problem/P12579)

### 前言
加强库班哥萨克第四团！

2024 闪击双倍受伤是铁卡，怎么 3033 闪击烟幕就成了金卡？

你告诉我烟幕对于这种落地要么抢线要么交换单位的东西有什么用？三费苏联金就给这点数值和机制？

把烟幕去了，身板加强到 3-4，给一个可在同一回合内移动并攻击，再给个伏击，这才像话吧。

### 题意简述
有两个长为 $n$ 的数组 $A,B$。可以无限次使用以下操作：
+ 选择一个区间 $[l,r]$，以 $\gcd_{i=l}^r a_i$ 的代价查询 $\sum_{i=l}^r b_i$。

最少付出多少代价才能确定 $B$ 的所有元素？

哦对了还有 $q$ 次对 $a_i$ 的单点修。每次修改后也要求当前答案。

$n,q\le 10^5$，$a_i\le 10^9$。

### 做法解析
查询 $\sum_{i=l}^r b_i$ 怎么得出 $B$ 数组的所有元素呢？其实你的每次询问都可以被视作一个方程，你最后就是要通过恰当的询问拿到足够的方程，组成一个有唯一一组解 $n$ 元一次方程组并把它解了。

可是我们要怎样构造这个方程组呢？别忘了，你需要支付的代价是那段区间的 $\gcd$。如果查询一个区间的代价是它的 $\gcd$，显然区间越长越省钱。然后呢，方程组能把 $b_i$ 求出来的条件是不存在 $j\neq i$ 使得 $b_i$ 和 $b_j$ 在所有方程中的系数都相同，再加上每个方程出现的都是一段区间里的 $b_i$……

你想到了“前后缀”与“作差”。

如果我对于每个 $i$ 我都去求它一段前缀（或者后缀）的和，最后就肯定能作差解出所有 $b_i$。

最简单的一种构造是，对于每个 $i$ 都询问 $[1,i]$ 的和。但是这太蠢了。

你发现，按照上面那种策略，你必定会问到 $[1,n]$ 的和。在这种情况下，对于其它询问，你问 $[1,i]$ 等效于问 $(i+1,n]$。所以你选那个代价小的问即可。

证明这个方案最优也应该是容易的，你考虑对于其它的构造，把它的询问区间扩展到边界并不劣，差不多就是这样。

> ：静态讨论完了，修改呢？  
> ：上线段树。

另外，$\gcd$ 随区间扩展而单调不增的性质确保了这题可以简单带修，因为这等价于存在 $p$ 满足：$i\in [1,p)$ 询问 $(i,n]$ 更优，$i\in [p,n]$ 询问 $[1,i]$ 更优。

所以你最后要做的就是线段树维护 $\gcd$，然后写个线段树二分。

> 额等下单点修之后答案怎么实时维护？

经典结论：对于一组不断延长的缀，$\gcd$ 只有 $\log V$ 种可能取值。所以就是双 $\log$ 一种一种取值地直接做。听起来很屎，但就是这样。

### 代码实现
写起来也确实是一坨。代码量不多，但是一个事实就是如果两只老葛在极短的代码片段里同时出现，这有不小的可能关联着一个让人要多想一会（或者亿会）的实现。

```cpp
#include <bits/stdc++.h>
using namespace std;
using namespace obasic;
const int MaxN=1e5+5;
int N,Q,A[MaxN],X,Y,bkp;
struct SegTree{
    int t[MaxN<<2];
    int ls(int u){return u<<1;}
    int rs(int u){return (u<<1)|1;}
    void pushup(int u){t[u]=gcd(t[ls(u)],t[rs(u)]);}
    void build(int u,int cl,int cr){
        if(cl==cr){t[u]=A[cl];return;}int cmid=(cl+cr)>>1;
        build(ls(u),cl,cmid),build(rs(u),cmid+1,cr),pushup(u);
    }
    void update(int u,int cl,int cr,int dd,int x){
        if(cl==cr){t[u]=x;return;}int cmid=(cl+cr)>>1;
        dd<=cmid?update(ls(u),cl,cmid,dd,x):update(rs(u),cmid+1,cr,dd,x);
        pushup(u);
    }
    int binser(int u,int cl,int cr,int lg,int rg){
        if(cl==cr)return cl;int cmid=(cl+cr)>>1;
        int lp=gcd(lg,t[ls(u)]),rp=gcd(rg,t[rs(u)]);
        return lp<=rp?binser(ls(u),cl,cmid,lg,rp):binser(rs(u),cmid+1,cr,lp,rg);
    }
    lolo qlcalc(int u,int cl,int cr,int dd,lolo pg){
        if(cl==cr)return gcd(t[u],pg);int cmid=(cl+cr)>>1;
        lolo lg=gcd(pg,t[ls(u)]),rg=gcd(lg,t[rs(u)]),res=0;
        if(dd>cmid)return qlcalc(rs(u),cmid+1,cr,dd,lg);
        res+=(lg==pg?(cmid-(dd>cl?dd:cl)+1)*lg:qlcalc(ls(u),cl,cmid,dd,pg));
        res+=(rg==lg?(cr-cmid)*lg:qlcalc(rs(u),cmid+1,cr,dd,lg));
        return res;
    }
    lolo qrcalc(int u,int cl,int cr,int dd,lolo pg){
        if(cl==cr)return gcd(t[u],pg);int cmid=(cl+cr)>>1;
        lolo rg=gcd(pg,t[rs(u)]),lg=gcd(rg,t[ls(u)]),res=0;
        if(dd<=cmid)return qrcalc(ls(u),cl,cmid,dd,rg);
        res+=(rg==pg?((dd<cr?dd:cr)-cmid)*rg:qrcalc(rs(u),cmid+1,cr,dd,pg));
        res+=(lg==rg?(cmid-cl+1)*rg:qrcalc(ls(u),cl,cmid,dd,rg));
        return res;
    }
    lolo baoli(int u,int cl,int cr,int dl,int dr){
        if(dl<=cl&&cr<=dr)return t[u];int cmid=(cl+cr)>>1;lolo res=0;
        if(dl<=cmid)res=gcd(res,baoli(ls(u),cl,cmid,dl,dr));
        if(dr>cmid)res=gcd(res,baoli(rs(u),cmid+1,cr,dl,dr));
        return res;
    }
}SgT;
lolo solve(int p){return SgT.qlcalc(1,1,N,p,0)+SgT.qrcalc(1,1,N,p,0)-SgT.t[1];}
int main(){
    readis(N,Q);
    for(int i=1;i<=N;i++)readi(A[i]);
    SgT.build(1,1,N);bkp=SgT.binser(1,1,N,0,0);
    writil(solve(bkp));
    for(int i=1;i<=Q;i++){
        readis(X,Y);SgT.update(1,1,N,X,Y);
        bkp=SgT.binser(1,1,N,0,0);writil(solve(bkp));
    }
    return 0;
}
```

### 后记
洛谷现有的两篇题解为什么都要把这个问题从最小生成树那转化过来？这个思路很必然或者自然吗？我不知道。不过最后代码都差不多就是了。

---


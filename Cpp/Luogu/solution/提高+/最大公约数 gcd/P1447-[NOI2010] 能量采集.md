# [NOI2010] 能量采集

## 题目描述

栋栋有一块长方形的地，他在地上种了一种能量植物，这种植物可以采集太阳光的能量。在这些植物采集能量后，栋栋再使用一个能量汇集机器把这些植物采集到的能量汇集到一起。

栋栋的植物种得非常整齐，一共有 $n$ 列，每列有 $m$ 棵，植物的横竖间距都一样，因此对于每一棵植物，栋栋可以用一个坐标 $(x, y)$ 来表示，其中 $x$ 的范围是 $1$ 至 $n$，$y$ 的范围是 $1$ 至 $m$，表示是在第 $x$ 列的第 $y$ 棵。

由于能量汇集机器较大，不便移动，栋栋将它放在了一个角上，坐标正好是 $(0, 0)$。

能量汇集机器在汇集的过程中有一定的能量损失。如果一棵植物与能量汇集机器连接而成的线段上有 $k$ 棵植物，则能量的损失为 $2k + 1$。例如，当能量汇集机器收集坐标为 $(2, 4)$ 的植物时，由于连接线段上存在一棵植物 $(1, 2)$，会产生 $3$ 的能量损失。注意，如果一棵植物与能量汇集机器连接的线段上没有植物，则能量损失为 $1$。现在要计算总的能量损失。

下面给出了一个能量采集的例子，其中 $n = 5$，$m = 4$，一共有 $20$ 棵植物，在每棵植物上标明了能量汇集机器收集它的能量时产生的能量损失。

![](https://cdn.luogu.com.cn/upload/image_hosting/fhzpmm7b.png)

在这个例子中，总共产生了 $36$ 的能量损失。

## 说明/提示

- 对于 $10\%$ 的数据：$n, m \leq 10$；
- 对于 $50\%$ 的数据：$n, m \leq 100$；
- 对于 $80\%$ 的数据：$n, m \leq 10^3$；
- 对于 $90\%$ 的数据：$n, m \leq 10^4$；
- 对于 $100\%$ 的数据：$1 \leq n, m \leq 10^5$。

## 样例 #1

### 输入

```
5 4
```

### 输出

```
36
```

## 样例 #2

### 输入

```
3 4```

### 输出

```
20
```

# 题解

## 作者：Kelin (赞：153)

题目大意:给定n和m,求Σ(1<=i<=n)Σ(1<=j<=m)GCD(i,j)\*2-1

i和j的限制不同,传统的线性筛法失效了,这里我们考虑容斥原理

令f[x]为GCD(i,j)=x的数对(i,j)的个数,这个不是很好求

我们令g[x]为存在公因数=x的数对(i,j)的个数(注意不是最大公因数！),显然有g[x]=(n/x)\*(m/x)

但是这些数对中有一些的最大公因数为2d,3d,4d,我们要把他们减掉

于是最终f[x]=(n/x)\*(m/x)-Σ(2\*x<=i\*x<=min(m,n))f[i\*x]

从后向前枚举x即可

时间复杂度O(nlogn)

注意计算g[x]的时候(n/x)\*(m/x)可能会乘爆 会挂掉一个点

```cpp
#include<cstdio>
#define re register int
const int N=100010;
int n,m;long long f[N],ans;
int main(){
    scanf("%d%d",&n,&m);
    if(n>m)n^=m^=n^=m; 
    for(re i=n;i;--i){
        f[i]=(long long)(n/i)*(m/i);
        for(re j=i<<1;j<=n;j+=i)f[i]-=f[j];
        ans+=((i<<1)-1)*f[i];
    }
    printf("%lld",ans);
return 0;
}
```

---

## 作者：Fading (赞：45)

## 纪念这道自己手推出来的数论题。

额，上古题解了，请大佬不要嘲讽，欧拉函数的卷积可以秒掉...

####  首先看到这道毒瘤题,我们可以先转化一下答案

不过好像有一点问题@communist 感谢大佬，已经修改

$$\text{answer} \iff 2\times\sum_{x=1}^n \sum_{y=1}^m (\gcd(x,y)-1)$$
$$\iff 2\times\sum_{x=1}^n \sum_{y=1}^m (\gcd(x,y)) \ -n\times m$$

所以求出$\sum_{x=1}^n \sum_{y=1}^m (\gcd(x,y))$就好了

正好刚学过莫比乌斯反演，还有狄利克雷卷积，

然后我就开始暴力肝题了。

前置知识($\text{[POI2007]ZAP-Queries}$) 先做这道题目

[我的狄利克雷卷积总结](https://www.luogu.org/blog/wohaocaia/di-li-ke-lei-juan-ji-xiao-jie-yi-ji-mu-bi-wu-si-fan-yan-ding-li-di-zhe)不会的看这里

然后我们开始愉快的肝题:
#### 
先上套路:

$$f(d)=\sum_{i=1}^{n}\sum_{j=1}^{m}[\gcd(i,j)==d]$$

设$i=id,j=jd,$就可以把$d$提出来了

$$f(d)=\sum_{i=1}^{\lfloor\frac nd\rfloor}\sum_{j=1}^{\lfloor\frac md\rfloor}[\gcd(i,j)==1]$$

$$∵[x==1]\Leftrightarrow \sum_{q|x}\mu(q)$$

$$∴f(d)=\sum_{i=1}^{\lfloor\frac nd\rfloor}\sum_{j=1}^{\lfloor\frac md\rfloor}\sum_{q|i,q|j}\mu(q)$$

替换枚举$q$方式

$$∴f(d)=\sum_{i=1}^{\lfloor\frac nd}\sum_{j=1}^{\lfloor\frac md}\sum_{q=1}^{\lfloor\frac {\min(n,m)}d\rfloor}\mu(q)[q|i,q|j]$$

设$i=iq,j=jq,$就可以把$\sum_{q=1}^{\lfloor\frac {\min(n,m)}d\rfloor}$提出来了

$$∴f(d)=\sum_{q=1}^{\lfloor\frac {\min(n,m)}d\rfloor}\mu(q)\sum_{i=1}^{\lfloor\frac n{dq}\rfloor}\sum_{j=1}^{\lfloor\frac m{dq}\rfloor}1$$

$$f(d)=\sum_{q=1}^{\lfloor\frac {\min(n,m)}d\rfloor}\mu(q)\lfloor\frac n{dq}\rfloor\lfloor\frac m{dq}\rfloor$$

运用一下整除分块，暴力求出每一个$f(k)\times k$加起来就是$\sum_{x=1}^n \sum_{y=1}^m \gcd(x,y)$了。

时间复杂度$O(\min(n,m)\sqrt {\min(n,m)})$

结果只有$90$分，超时了。

我很绝望啊，结果重新推公式后，我发现有一步可以优化:

$$\sum_{x=1}^n \sum_{y=1}^m \gcd(x,y)$$

$$=\sum_{d=1}^{\min(n,m)}f(d)\times d$$

$$=\sum_{d=1}^{\min(n,m)}d\sum_{q=1}^{\frac {\min(n,m)}d}\mu(q)\lfloor\frac n{dq}\rfloor\lfloor\frac m{dq}\rfloor$$

$$=\sum_{d=1}^{\min(n,m)}d\sum_{dq=1}^{\min(n,m)}\mu(q)\lfloor\frac n{dq}\rfloor\lfloor\frac m{dq}\rfloor$$

设$T=dq$

$$∴\ =\sum_{d=1}^{\min(n,m)}d\sum_{T=1}^{\min(n,m)}[d|T]\mu(\frac Td )\lfloor\frac n{T}\rfloor\lfloor\frac m{T}\rfloor$$

$$=\sum_{d=1}^{\min(n,m)}\sum_{d|T}^{\min(n,m)}d\mu(\frac Td )\lfloor\frac n{T}\rfloor\lfloor\frac m{T}\rfloor$$

替换$d,T$枚举方式

$$=\sum_{T=1}^{\min(n,m)}\sum_{d|T}^{\min(n,m)}d\mu(\frac Td )\lfloor\frac n{T}\rfloor\lfloor\frac m{T}\rfloor$$

$$=\sum_{T=1}^{\min(n,m)}\lfloor\frac n{T}\rfloor\lfloor\frac m{T}\rfloor\sum_{d|T}^{\min(n,m)}d\mu(\frac Td )$$

后面的东西有点眼熟。。。

这不是狄利克雷卷积吗?

设$h(T)=\sum_{d|T}d\times\mu(\frac{T}{d}),$写成卷积其实就是

$$h=id*\mu$$

然后两边都乘上函数$1$

$$h*1=id*(\mu*1)$$

$$∵\mu*1=ϵ$$

$$∴h*1=id*ϵ$$

$$∴h*1=id$$

我们又惊奇的发现

$$∵φ*1=id$$

$$∴h=φ$$

$h$就是欧拉函数!

解了这么久再带入原式

$$\sum_{x=1}^n \sum_{y=1}^m \gcd(x,y)$$

$$=\sum_{T=1}^{\min(n,m)}\lfloor\frac{n}{T}\rfloor\lfloor\frac{m}{T}\rfloor \varphi(T)$$

然后就很套路了。和$\text{ZAP Queries}$一样，预处理出欧拉函数前缀和，然后用整除分块，这个题目就$O(\min(n,m))$地解决了。

欧拉函数前缀和用欧拉筛求(什么鬼)

## 后记

信息数论和普通数论的区别就在于:它不一定是个结论题。你在推导的过程中，需要考虑——什么时候要停笔去枚举。

这也就是信息数论的难点所在。

```
#include<bits/stdc++.h>
using namespace std;
int tot,T,vis[100004];
long long phi[100004],sum[100004],p[100004],n,m;
inline void init(){//筛欧拉函数
    int nx=100000;phi[1]=1;
    for (register int i=2;i<=nx;i++){
        if (!vis[i]) p[++tot]=i,phi[i]=i-1;
        for (register int j=1;j<=tot&&i*p[j]<=nx;j++){
        	if (i*p[j]>nx) continue;
            vis[i*p[j]]=1;
            phi[i*p[j]]=phi[i]*phi[p[j]];
            if((i%p[j])==0){
                phi[i*p[j]]=phi[i]*p[j];
                break;
            }
        }
    }
    for (int i=1;i<=nx;i++){
        sum[i]=sum[i-1]+phi[i];//求前缀和
    }
}
int main(){
    scanf("%lld%lld",&n,&m);
    init();
    long long ans=0;
    for (int l=1,r;l<=min(n,m);l=r+1){
        r=min(n/(n/l),m/(m/l));
        ans+=(long long)(sum[r]-sum[l-1])*(n/l)*(m/l);//整除分块
    }
    ans=(long long)2*ans-n*m;
    printf("%lld",ans);
}
```

---

## 作者：interestingLSY (赞：23)

# ① 抽象为模型:

就是给你一个$n\cdot m$的方阵,问每个点与原点的连线中有多少点(不包括两头的)*2+1再求和,

形式化地说,就是求

$$\color{blue}\sum_{i=1}^{n}\sum_{j=1}^{m}gcd_{i,j}\cdot2-1$$

注意是减,因为我们不计算这条线段两端点

即为

$$\color{blue}\left[\sum_{i=1}^{n}\sum_{j=1}^{m}gcd_{i,j}\right]\color{black}\cdot2\ -\ nm$$

好现在的~~主要矛盾~~就是求蓝色那部分.

# ② 开始乱搞

正向不好求,我们考虑~~暴力(顺便说一句,这题暴力求上面式子有$\color{green}80$分qwq)~~反着求,即

开一个$cnt$数组, $cnt_i$表示**公约数**为i的**数对**个数.(注意不是最大公因数)

~~显然~~根据乘法原理,

$$\color{Blue}cnt_i = \left\lfloor\frac{n}{i}\right\rfloor+\left\lfloor\frac{m}{i}\right\rfloor$$

但是我们忽略了一点,就是一个数对可以产生公因数$x$,也**可能**产生公因数$2x,3x......$

所以咋整?减掉就行!

# Code:

注意一点:最终减掉$nm$时要减去`1LL*n*m`,不然会爆

(只贴出关键部分)

```cpp
	Read(n,m);
	For(i,max(n,m))
		cnt[i] = 1LL * (n/i) * (m/i);
	fOR(i,max(n,m)){
		int x = i+i;
		g[i] = cnt[i];
		while( x <= max(n,m) ){
			g[i] -= g[x];
			x += i;
		}
	}
	For(i,max(n,m))
		ans += 1LL * i * g[i];

	printf("%lld",ans*2LL-1LL*n*m);
```

---

## 作者：JustinRochester (赞：18)

[题目](https://www.luogu.org/problem/P1447)

这题不要用莫比乌斯反演，用欧拉反演更快

---

**【分析】**
--

设点 $(x,y)$ 的能量损失为 $f(x,y)$

则 $\displaystyle Ans=\sum_{i=1}^n\sum_{j=1}^m f(i,j)$

---

我们先解决 $f(x,y)$ 具体是多少：

~~显然~~ 是 $2gcd(x,y)-1$

证明如下 （不想了解的小伙伴可以跳过）

设点 $(x,y)$ 与 $(0,0)$ 之间有且仅有 $k$ 个整数点，它们分别为 $({x\over \lambda _1},{y\over \lambda_1})$ ~ $({x\over \lambda _k},{y\over \lambda_k})$

( $\forall i\in[1,k],\lambda_i>1$ )

$\because \forall i\in[1,k]$ 都有 $({x\over \lambda_i},{y\over \lambda_i})$ 为整数点

即 ${x\over \lambda_i},{y\over \lambda_i}\in Z$

因为不保证 $\lambda\in Z$ 所以不能写成 $\lambda_i\mid x\bigwedge\lambda_i\mid y$

那么，我们令 $p={x\over \lambda_i},q={y\over \lambda_i},p,q\in Z$

$\therefore gcd(x,y)=gcd(p\lambda_i,q\lambda_i)$

$\therefore {gcd(x,y)\over \lambda_i}=gcd(p,q)$

$\because$ $\lambda_i$ 有且仅有 $k$ 个取值

$\therefore$ $gcd(p,q)$ 有且仅有 $k$ 个取值，且必定为整数

$\therefore $ 对 $\forall n>1,{gcd(x,y)\over n}$ 有且仅有 $k$ 个整数取值

> 注：$n$ 可为分数

$\therefore$ 对 $\forall n>0,{gcd(x,y)\over n}$ 有且仅有 $(k+1)$ 个整数取值

这不就说明了 $gcd(x,y)=k+1$ 吗？

$\therefore f(x,y)=2k+1=2(k+1)-1=2gcd(x,y)-1$

---

好了，题目很显然了，求 $\displaystyle Ans=\sum_{i=1}^n\sum_{j=1}^m[2gcd(x,y)-1]$

考虑 $-1$ 的贡献： $\displaystyle Ans=\sum_{i=1}^n\sum_{j=1}^m2gcd(x,y)-nm$

求和符号中提取公因式 $2$ :$\displaystyle Ans=2\sum_{i=1}^n\sum_{j=1}^mgcd(x,y)-nm$

接下来，有请 **欧拉** ~~繁衍~~ **反演** 闪亮登场：

它的根本是一个公式 $\displaystyle \sum_{d\mid n}\boldsymbol \varphi(d)=n$

这个公式怎么来的？我上次看到某个 dalao 给出了形象的证明：

> 假设我们有 ${1\over n},{2\over n},{3\over n}\dots {n-1\over n},{n\over n}$ 共 $n$ 个分数。将它们能约分的全部约分，则约分后的分母 $d$ ，必定满足 $d\mid n$ 。且对 $\forall d\mid n$ ，分母为 $d$ 的分数一共出现 $\boldsymbol \varphi(d)$ 次。所以 $\displaystyle \sum_{d\mid n}\boldsymbol \varphi(d)=n$ 。

还是不了解的可以试着用莫比乌斯反演证明，也是可行的

所以原式又能继续化简： $\displaystyle Ans=2\sum_{i=1}^n\sum_{j=1}^m\sum_{d\mid gcd(i,j)}\boldsymbol \varphi(d)-nm$

因为 $n,m$ 对答案的贡献是对称的，我们不妨设 $n<m$

调换顺序，枚举 $d$

$\therefore\displaystyle  Ans=2\sum_{d=1}^n\boldsymbol \varphi(d)\sum_{i=1}^n\sum_{j=1}^m[d\mid gcd(i,j)]-nm$

$\displaystyle \qquad\quad=2\sum_{d=1}^n\boldsymbol \varphi(d)\sum_{i=1}^n\sum_{j=1}^m[d\mid i\bigwedge d\mid j]-nm$

$\displaystyle \qquad\quad=2\sum_{d=1}^n\boldsymbol \varphi(d)\sum_{i=1}^n[d\mid i]\sum_{j=1}^m[d\mid j]-nm$

分别考虑 $i,j$ 的贡献：

$\displaystyle Ans=2\sum_{d=1}^n\boldsymbol \varphi(d)\sum_{i=1}^{\lfloor{n\over d}\rfloor}[1\mid i]\sum_{j=1}^{\lfloor{m\over d}\rfloor}[1\mid j]-nm$

$\displaystyle \qquad=2\sum_{d=1}^n\boldsymbol \varphi(d){\lfloor{n\over d}\rfloor}{\lfloor{m\over d}\rfloor}-nm$

剩下的整除分块搞一搞就出来了

---

**【代码】**
---

那本蒟蒻就放 ~~我码风极丑的~~ 代码了

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
#define f(a,b,c,d) for(register int a=b,c=d;a<=c;a++)
#define g(a,b,c,d) for(register int a=b,c=d;a>=c;a--)
//#define LOCAL
typedef int i32;
typedef unsigned int u32;
typedef long long int i64;
typedef unsigned long long int u64;
const i32 MAXN=1e5;
typedef i64 ar[MAXN+10];

namespace HABIT{
    template<typename T> inline T Max(T a) { return a; }
    template<typename T,typename... Args> inline T Max(T a,Args... args){
        T b=Max(args...);
        return (a>b)?a:b;
    }
    template<typename T> inline T Min(T a) { return a; }
    template<typename T,typename... Args> inline T Min(T a,Args... args){
        T b=Min(args...);
        return (a<b)?a:b;
    }

    #ifdef LOCAL
        inline char gc() { return getchar(); }
    #else
        inline char gc() {
            static char s[1<<20|1]={0},*p1=s,*p2=s;
            return (p1==p2)&&(p2=(p1=s)+fread(s,1,1<<20,stdin),p1==p2)?EOF:*(p1++);
        }
    #endif
    inline i32 read(){
        register i32 ans=0;register char c=gc();register bool neg=0;
        while(c<48||c>57) neg^=!(c^'-'),c=gc();
        while(c>=48&&c<=57) ans=(ans<<3)+(ans<<1)+(c^48),c=gc();
        return neg?-ans:ans;
    }

    char Output_Ans[1<<20|1],*Output_Cur=Output_Ans;
    inline bool output() { Output_Cur-=fwrite(Output_Ans,1,Output_Cur-Output_Ans,stdout); }
    inline void print(char c) { (Output_Cur-Output_Ans+1>>20)&&output(),*(Output_Cur++)=c; }
    inline void print(i64 x){
        char buf[21]={0}; (Output_Cur-Output_Ans+sprintf(buf,"%lld",x)>>20)&&output();
        Output_Cur+=sprintf(Output_Cur,"%lld",x);
    }
}
using namespace HABIT;

ar ar_d_Fc,ar_d_Prime,ar_d_Phi;
inline void pre(i32 d_Lim){
    i64 *ptr_d_Prime=ar_d_Prime;
    ar_d_Phi[1]=1;
    f(i,2,I,d_Lim){
        if(!ar_d_Fc[i]) ar_d_Phi[i]=(*(ptr_d_Prime++)=ar_d_Fc[i]=i)-1;
        for(register i64 *p=ar_d_Prime;p<ptr_d_Prime&&*p*i<=d_Lim;p++){
            ar_d_Fc[*p*i]=*p;
            ar_d_Phi[*p*i]=*p*ar_d_Phi[i];
            if(*p<ar_d_Fc[i]) ar_d_Phi[*p*i]-=ar_d_Phi[i];
            else break;
        }
        ar_d_Phi[i]+=ar_d_Phi[i-1];
    }
}

int main(){
    i32 d_N=read(),d_M=read();
    i64 lld_Ans=-1ll*d_N*d_M;
    if(d_N>d_M) d_N^=d_M^=d_N^=d_M;
    pre(d_N);
    for(register i32 l=1,r;l<=d_N;l=r+1){
        r=Min( d_N/(d_N/l) , d_M/(d_M/l) );
        lld_Ans+=(ar_d_Phi[r]-ar_d_Phi[l-1])*(d_N/r)*(d_M/r)*2;
    }
    print(lld_Ans);
    output();
    return 0;
}
```

最后安利一下 [本蒟蒻的博客](https://www.luogu.org/blog/JustinRochester/)

---

## 作者：Soulist (赞：13)

题意大致翻译一下，相信大家肯定都做过 [仪仗队](https://www.luogu.org/problemnew/show/P2158)吧 QWQ 

提前$ps:$ 本题解的除法均为下取整

所以我们可以发现，一个植物$(x,y)$所产生的能量损失为$2*(gcd(x,y)-1) + 1 = 2 * gcd(x,y)-1$

所以题目要求的即：

$$\sum_{i=1}^n\sum_{j=1}^m(2*gcd(i,j)-1)$$

稍微化简一下：

$$2*\sum_{i=1}^n\sum_{j=1}^mgcd(i,j) - n * m$$

利用一下莫比乌斯函数的性质，不造的同学可以看下[这里](https://www.luogu.org/blog/Soulist/guan-yu-mu-bi-wu-si-di-yi-dian-xue-xi-post)

我们只关注前面那一部分

$$2*\sum_{d=1}^nd*\sum_{i=1}^{\frac{n}{d}}\sum_{j=1}^{\frac{m}{d}}\sum_{k|gcd(i,j)}\mu(k)$$

$$2*\sum_{d=1}^nd*\sum_{k=1}^{\frac{n}{d}}\mu(k)*\frac{n}{kd}*\frac{m}{kd}$$

貌似现在就已经可以过这道题了？复杂度$O(N\sqrt N)$


然而复杂度可以更优，比如我们可以多次询问什么的？

一个非常老的套路：

设 $T = kd$

那么我们对每个 $T$ 的构成单独考虑：发现对于每个 $T$ 它存在很多因子，在考虑每个因子 $d$ 它对答案产生的贡献为：$\sum\mu(d)*k*\dfrac{n}{kd}\dfrac{m}{kd}=\sum\mu(d)*\dfrac{T}{d}*\dfrac{n}{T}*\dfrac{m}{T}$

重新写一下：

$$\sum_{T=1}^n\sum_{d|T}\mu(d)*\dfrac{T}{d}*\frac{n}{T}*\frac{m}{T}$$

$$\sum_{T=1}^n\dfrac{n}{T}*\dfrac{m}{T} * \sum_{d|T}\mu(d)*\dfrac{T}{d}$$

不难发现它之和 $T$ 有关...，且后面这一坨为：$\sum_{d|T}\mu(d)*\frac{T}{d}$，那么它其实是什么呢？其实就是$\mu$函数和$Id$函数的卷积。见此处：[积性函数，迪利克雷卷积](https://www.luogu.org/blog/Hakuryu/du-jiao-shai)

然而有趣的是：$\mu*Id=\phi$ [关于这个东西的证明在此处(见加粗字体证明部分)](https://www.luogu.org/blog/Hakuryu/solution-p3768)

如果将后面这一坨设为$f(T)$，则$f(T)=\phi(T)$

所以原式即：

$$2*\sum_{T=1}^{n}\dfrac{n}{T}*\dfrac{m}{T}*\phi(T) - n * m$$

当然，因为其中的除法都是下取整，于是喜闻乐见的整除分块来了！

当然，要记录$\phi$函数的前缀和。

最后复杂度：$O(N+\sqrt N )$

（然而当询问多次的时候这个做法对每次询问处理的复杂度均为$\sqrt N$）

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int read() {
	char cc = getchar(); int cn = 0, flus = 1;
	while(cc < '0' || cc > '9') {  if( cc == '-' ) flus = -flus;  cc = getchar();  }
	while(cc >= '0' && cc <= '9')  cn = cn * 10 + cc - '0', cc = getchar();
	return cn * flus;
}
const int N = 1e5 + 5;
#define int long long 
#define rep( i, s, t ) for( register int i = s; i <= t; ++ i )
int n, m, phi[N], sum[N], maxn, p[N], top;
bool isp[N];
void init() {
	maxn = N - 5, phi[1] = sum[1] = 1;
	rep( i, 2, maxn ) {
		if( !isp[i] ) phi[i] = i - 1, p[++ top] = i;
		rep( j, 1, top ) {
			if( p[j] * i > maxn ) break;
			isp[p[j] * i] = 1;
			if( i % p[j] == 0 ) {
				phi[p[j] * i] = phi[i] * p[j];
				break;
			}
			phi[p[j] * i] = phi[p[j]] * phi[i];
		}
		sum[i] = sum[i - 1] + phi[i];
	}
} 
int solve( int x, int y ) {
	int l, r, ans = 0 ; if( x > y ) swap( x, y ); 
	for( l = 1; l <= x; l = r + 1 ) {
		r = min( ( x / ( x / l ) ), ( y / ( y / l ) ) ); //整除分块
		ans += ( sum[r] - sum[l - 1] ) * ( x / l ) * ( y / l ); //记录了phi的前缀和 
	}
	return 2 * ans - x * y ;
}
signed main()
{
	init(); n = read(), m = read();
	printf("%lld\n", solve( n, m ) );
	return 0;
}

```

---

## 作者：FendtSilence (赞：11)

我们先来分析一下题意，发现所有没有被遮挡住的植物的横纵坐标$(x,y)$都满足$n\bot m$，而一条线上从$(x,y)$到$(0,0)$上被挡住的植物有$gcd(x,y)-1$个

所以题意就被我们转化成了求解$\sum\limits_{i = 1}^n {\sum\limits_{j = 1}^m {((2*\gcd (i,j) - 1) + 1) = } } \sum\limits_{i = 1}^n {\sum\limits_{j = 1}^m {(2*\gcd (i,j) - 1)} }  = 2*\sum\limits_{i = 1}^n {\sum\limits_{j = 1}^m {(\gcd (i,j)) - n*m} } $

其实就是求解$\sum\limits_{i = 1}^n {\sum\limits_{j = 1}^m {\gcd ({\rm{i,j}})} }$

这个式子我们可以莫比乌斯反演

我们先设出$f(d) = \sum\limits_{i = 1}^n {\sum\limits_{j = 1}^m {[d =\gcd (i,j)]} }$

不难发现，此时答案变成了$ans = \sum\limits_{d = 1}^n {f(d)*d}$

再设出$F(d) = \sum\limits_{i = 1}^n {\sum\limits_{j = 1}^m {[d|\gcd (i,j)]} }$

同时也不难发现$F(d) = \left\lfloor {\frac{n}{d}} \right\rfloor \left\lfloor {\frac{m}{d}} \right\rfloor$

通过两个式子之间的关系，不难想出莫比乌斯反演$\mu$的公式

我们进行一个简单的数学变换，使得枚举$i|d$变为枚举$i$

就可以得到公式$f(d) = \sum\limits_{i = 1}^{\left\lfloor {\frac{n}{d}} \right\rfloor } {\mu (i)} \left\lfloor {\frac{n}{{d*i}}} \right\rfloor \left\lfloor {\frac{m}{{d*i}}} \right\rfloor $

答案就变成了

$ans = \sum\limits_{d = 1}^n {d*} \sum\limits_{i = 1}^{\left\lfloor {\frac{n}{d}} \right\rfloor } {\mu (i)} \left\lfloor {\frac{n}{{d*i}}} \right\rfloor \left\lfloor {\frac{m}{{d*i}}} \right\rfloor $

根据调和级数定理，复杂度为$O(ln(n)+H_n)$那个$H_n$可以看成常数

代码很好写,跑得也不慢

```cpp
#include<iostream>
#include<stdio.h>
using namespace std;
const int maxn=100001;
long long int n,m,mu[maxn],ans,tot;
long long int p[maxn],np[maxn];
void get_mu()
{
    mu[1]=1;
    for(int i=2;i<=n;i++)
    {
        if(!np[i]) p[++p[0]]=i,mu[i]=-1;
        for(int j=1;j<=p[0]&&p[j]*i<=n;j++)
        {
            int k=p[j]*i;
            np[k]=1;
            if(!(i%p[j])) break;
            mu[k]=-mu[i];
        }
    }
}
void solve()
{
    cin>>n>>m;
    get_mu();
    for(int d=1;d<=n;d++) for(int i=1;i<=min(n,m)/d;i++)
    ans+=d*mu[i]*(n/(d*i))*(m/(d*i));
    cout<<(long long int)ans*2-n*m;
}
int main()
{
    solve();
    return 0;
} 
```

---

## 作者：litble (赞：9)

dalao们的题解经常长这样：水题，贴代码

水吗......本蒟蒻泪流满面。

好吧好吧，那本蒟蒻就来跟着dalao推一推。

1.容易意会得到，一颗坐标为(x,y)植物连线上的植物数量就是gcd(x,y)-1;

题目中的式子变一下，主要矛盾是求$$ \sum_{x=1}^n \sum_{y=1}^m gcd(x,y) $$

2.首先有一条结论：一个数的所有因子的欧拉函数之和等于这个数本身。

然后x和y的公因子肯定是他们最大公约数的因子，所以就是求$$\sum_{x=1}^n \sum_{y=1}^m \sum_{d=1}^n[d|n且d|m] \phi(d)$$
3.随便交换律一下得到：$$\sum_{d=1}^n \sum_{i=1}^n[d|n] \sum_{j=1}^m[d|m]\phi(d)*(n/i)*(m/i)$$
注意：n/i和m/i是向下取整，下同

4.现在求起来就方便多了，不过呢，还有一个优化，对于一个数i来说，设它的$n/i=k_1,m/i=k_2$，则同样满足$n/j=k_1,m/j=k_2$的最大$j=min(n/k_1,m/k_2);$

5.最后把得到的结果乘以2再减去m\*n即可

```cpp
#include<iostream>
#include<cstdio>
#include<climits>
#include<algorithm>
#include<cstring>
using namespace std;
#define ll long long
ll n,m,ans;int tot;
bool is[1000010];
int pri[1000010],phi[10000100];
ll sum[1000010];
void init(){
    ll i,j,k;
    phi[1]=1;
    for(i=2;i<=n;i++){
        if(!is[i]){phi[i]=i-1;pri[++tot]=i;}
        for(j=1;j<=tot;j++){
            k=pri[j]*i;if(k>n)break;
            is[k]=1;
            if(i%pri[j]==0){phi[k]=(ll)phi[i]*pri[j];break;}
            else phi[k]=(ll)(pri[j]-1)*phi[i];
        }
    }
    for(i=1;i<=n;i++)sum[i]=sum[i-1]+phi[i];
}
int main()
{
    ll i,j;
    scanf("%lld%lld",&n,&m);
    if(n>m)swap(n,m);
    init();
    for(i=1;i<=n;i=j+1){
        j=min(m/(m/i),n/(n/i));
        ans+=(ll)(sum[j]-sum[i-1])*(m/i)*(n/i);
    }
    ans=(ll)ans*2-(ll)n*m;
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：AlanSP (赞：7)

## 一道练习数论的好题
日常丢人。   
当我看到这张图时，我脑子里想 ：   
这不就[仪仗队](https://www.luogu.com.cn/problem/P2158)吗 ？  
欧拉函数走起！   
但我仔细一看：  
**“能量汇集机器在汇集的过程中有一定的能量损失。如果一棵植物与能量汇集机器连接而成的线段上有 kk 棵植物，则能量的损失为 2k +1。** 
  
~~cao好像不太一样。~~  
于是删了代码回去推式子  。

推出来个
$$
\sum_{i=1}^n\sum^m_{j=1}2*gcd(i,j)+1
$$

我再一想  。  
这不是[SDOI那道题](https://www.luogu.com.cn/problem/P2303)吗，也是欧拉函数。  
答案好像是$\phi(\frac n d)$。  
然后就锅到死 。  
~~于是我就去参考了题解qwq。~~，会了。  
考虑dp+容斥（其实也不算dp）。  
dp[i]表示**最大公因数**为i的数对有几个。  
根据乘法原理，我们有**公因数**为i的数对数为$(\frac n i*\frac m i)$个。  
考虑容斥，这里面包含2i，3i……的情况。  
所以要分别减掉他们的dp值。
$$
dp[i]=(\frac n i)*(\frac m i)-\sum_{j=2}^{i*j<=min(n,m)}dp[i*j]
$$

答案为dp[i]的两倍减一。  
因为i和j可以互换，再减去它们相等的一种情况。  
代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

int n,m,ans;
int dp[100009];

signed main()
{
	scanf("%lld%lld",&n,&m);
	for(int i=n;i>=1;i--)
	{
		dp[i]=(n/i)*(m/i);
		for(int j=2;j*i<=min(m,n);j++) dp[i]-=dp[i*j];
	}
	for(int i=1;i<=n;i++) ans+=(i*2-1)*dp[i];
	printf("%lld",ans);
	return 0;
}
```


---

## 作者：Azuree (赞：5)

[查看原题请戳这里](https://www.luogu.org/problem/P1447)

一开始以为需要用线性筛（当然我不会），后来才知道原来容斥一下就可以通过这道题目……

首先，有一个奇怪的结论：横纵坐标gcd为$k$的点前面共有$k-1$个（它们的gcd分别为$1,2...k-1$）。

我们可以发现，对于一个$n\times m$的图，横纵坐标的公因数含有$k$的点共有$((n/k)\times(m/k))$个，即共有$n/k$个横坐标为$k$的倍数，有$m/k$个纵坐标为$k$的倍数，那么点数为$((n/k)\times(m/k))$个。

于是我们就可以快速预处理出$x$坐标和$y$坐标公因数为$k$的点。

然后我们考虑容斥。

比如，我们要求横坐标和纵坐标gcd为$2$的点，那么我们可以用公因数包含$2$的点减去gcd为$4$的点在减去gcd为$8$的点，再减去gcd为$16$的点，再减去……

好吧，这个容斥貌似被魔改过……

但是容斥的复杂度很大怎么办？

我们可以从大数向小数枚举，比如我们枚举到$4$时，我们就直接把其中gcd为$4$的倍数（除了$4$）的点的数量直接删去就好了。

code：

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<algorithm>
#define ll long long
#define INF 0x7fffffff
#define re register

using namespace std;

int read()
{
    register int x = 0,f = 1;register char ch;
    ch = getchar();
    while(ch > '9' || ch < '0'){if(ch == '-') f = -f;ch = getchar();}
    while(ch <= '9' && ch >= '0'){x = x * 10 + ch - 48;ch = getchar();}
    return x * f;
}

long long n,m,cnt,ans,a[1000005];

int main()
{
	n = read(); m = read();
	for(int i = 1; i <= n; i++) a[i] = (n / i) * (m / i);
	for(int i = n; i >= 1; i--)
	{
		for(int j = 2; j <= n / i; j++) a[i] = a[i] - a[i * j];
		ans = ans + a[i] * (i * 2 - 1);
	}
	cout << ans << endl;
    return 0;
}
```

---

## 作者：xryjr233 (赞：4)

### 以下设$n\ge m$。

首先,一个点$(x,y)$到$(0,0)$的路径上经过的点的数量(**不包括首尾**)为$gcd(x,y)-1$。

所以它的能量损耗为$2\times gcd(x,y)-1$。

考虑如何统计$\sum_{i=1}^n\sum_{j=1}^m 2\times gcd(i,j)-1$。

记$f_x=\sum_{i=1}^n\sum_{j=1}^m[gcd(i,j)=x]$,即$1\le i\le n,1\le j\le m$时,$gcd(i,j)=x$的数量。

我们再记$F_x=\sum_{x|i}f_i$。

~~莫名其妙想到了莫比乌斯反演,但是在这里显然不能用~~

我们发现$F(x)$其实就是满足$1\le i\le n,1\le j\le m,i|x,j|x$的$(i,j)$数量,即$\lfloor\frac{n}{x}\rfloor\lfloor\frac{m}{x}\rfloor$。

我们还发现$f_i=F_i-\sum_{x=2}^{\lfloor\frac{n}{i}\rfloor}f_{xi}$,即$F_i$减去  $f_k$的和  ,其中$k$是$i$的倍数且不等于$i$。

于是我们**从大到小**枚举$i$并计算$f_i$,答案就是$\sum_{i=1}^n(2\times i-1)\times f_i$。

根据调和级数,其时间复杂度为$O(nlogn)$。

code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
long long num[100010],ans;
int main(){
    scanf("%d%d",&n,&m),n<m?swap(n,m),0:0;
    for(int i=n;i>=1;--i){
        num[i]=1ll*(n/i)*(m/i);
        for(int j=i+i;j<=n;j+=i)num[i]-=num[j];
        ans+=(2*i-1)*num[i];
    }
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：aiyougege (赞：4)

#### Solution
虽然这个题的做法中莫比乌斯反演做法并不是最好的, 但仍值得学习.
![](https://cdn.luogu.com.cn/upload/pic/21263.png)

　　这个$h(T)$可以通过枚举因子得到, 也可以通过线性筛, 会发现这个函数就是**欧拉函数**, 当然我没用线性筛求$h(T)$, 反而是通过复杂度为$O(\sqrt{T})$的方法求了出来.
这是求$h(i)$部分的代码
```c++
	for(int i=1;i<=n;++i)
		for(int j=i;j<=n;j+=i)
			number[j]+=i*mu[j/i];
```
求出这个函数之后, 再利用莫比乌斯反演中常见的技巧**除法分块**和**前缀和**就能通过此题.
#### Code
```c++
#include<iostream>
#include<cstdio>
#include<cmath>
#define N 200005
using namespace std;

typedef long long ll;

int tot;
int mu[N];
int sum[N];
bool mark[N];
int prime[N];
ll number[N];

void getmu(int n){
    mu[1]=1;
    for(int i=2;i<=n;i++){
    	if(!mark[i]){
    		prime[++tot]=i;
    		mu[i]=-1;
    	}
        for(int j=1;prime[j]*i<=n;j++){
            if(prime[j]*i>=n)break;
            mark[prime[j]*i]=1;
            if(i%prime[j]==0){
    			mu[prime[j]*i]=0;
    			break;
    		}
            mu[prime[j]*i]=-mu[i];
        }
    }
	for(int i=1;i<=n;++i)
		for(int j=i;j<=n;j+=i)
			number[j]+=i*mu[j/i];
	for(int i=1;i<=n;++i)
		sum[i]=sum[i-1]+number[i];
}    
ll query(int n,int m){
    int last;
    ll ans=0;
    for(ll i=1;i<=min(n,m);i=last+1){
        last=min(n/(n/i),m/(m/i));
        ans+=(n/i)*(m/i)*(sum[last]-sum[i-1]);
    }
    return 2*ans-n*m;
}

int main(){
    getmu(100000);
    int n,m,T=1;
    while(T--){
        scanf("%d%d",&n,&m);
        printf("%lld\n",query(n,m));
    }
    return 0;
}
```

---

## 作者：Holy_Push (赞：2)

一道莫比乌斯反演入门题（当然我的做法可能不是很优秀毕竟都排到40页开外了）

注：接下来所有公式中，默认为$n≤m$。

通过仔细观察发现，一个点$(i,j)$引起的能量损失为$2gcd(i,j)-1$。

其实也很好证明。（随便乱写的证明）

对于点$(i,j)$，设它们的最大公因数为$gcd$，则$(i,j)$可以表示为$(gcd×x,gcd×y)$。显然，如果两个点与原点的连线是同一条直线，则它们的斜率相等，都等于$\frac{y}{x}$。所以在原点与$(i,j)$的连线上，还存在$(x,y),(2x,2y),(3x,3y)……((gcd-1)x,(gcd-1)y)$这些点，一共有$gcd-1$个，损失的能量为$2(gcd-1)+1=2gcd-1$。

于是题目让我们求的东西就变成了

$\sum_{i=1}^n\sum_{j=1}^m(2gcd(i,j)-1)$

经过简单的化简之后变为


$2\sum_{i=1}^n\sum_{j=1}^mgcd(i,j)-nm$

所以我们只要考虑如何计算

$sum=\sum_{i=1}^n\sum_{j=1}^mgcd(i,j)$

我们把$d=gcd(i,j)$作为枚举的项后变为

$sum=\sum_{d=1}^nd\sum_{i=1}^n\sum_{j=1}^m[gcd(i,j)=d]$

=$\sum_{d=1}^nd\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}[gcd(i,j)=1]$

我们设$s(x,y)$表示$\sum_{i=1}^x\sum_{j=1}^y[gcd(i,j)=1]$，则上式可以表示为$sum=\sum_{d=1}^nd×s(\lfloor\frac{n}{d}\rfloor,\lfloor\frac{m}{d}\rfloor)$，显然可以用整除分块解决。关键在于如何计算$s(x,y)$。

这也是一道经典题了。貌似可以利用$\varphi$来解决，但方法是多元化的，这里使用莫比乌斯反演来做。

我们设$f(x)=\sum_{i=1}^n\sum_{j=1}^m[gcd(i,j)=x]$

$g(x)=\sum_{x|d}f(d)=\sum_{i=1}^n\sum_{j=1}^m[x|gcd(i,j)]=\lfloor\frac{n}{x}\rfloor\lfloor\frac{m}{x}\rfloor$

反演回去得$f(x)=\sum_{x|d}\mu(\frac{d}{x})g(d)$

我们要求的是$f(1)$的值，所以得$s(n,m)=f(1)=\sum_{d=1}^n\mu(d)g(d)=\sum_{d=1}^n\mu(d)\lfloor\frac{n}{d}\rfloor\lfloor\frac{m}{d}\rfloor$

预处理$\mu$的前缀和再加上整除分块可以在$\sqrt{n}$的时间内算出。别忘了外面还有一层整除分块套着，于是分块套分块我就不会算时间复杂度了$QAQ$，实测跑的很快。

（第一次写数论题解，所以写的不好请指正）

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N=200000;

int n,m,mul[N],prime[N],len;
bool vis[N];

ll f(int n,int m)
{
	int i=1;ll ans=0;
	while (i<=n)
	{
		int j=min(n/(n/i),m/(m/i));
		ans+=(ll)(mul[j]-mul[i-1])*(n/i)*(m/i);
		i=j+1;
	}
	return ans;
}

ll sum(int n,int m)
{
	int i=1;ll ans=0;
	while (i<=n)
	{
		int j=min(n/(n/i),m/(m/i));
		ans+=f(n/i,m/i)*(ll)(j+i)*(ll)(j-i+1)/2;
		i=j+1;
	}
	return ans;
}

int main()
{
	cin>>n>>m;
	if (n>m) swap(n,m);
	mul[1]=1;
	for (int i=2;i<=m;i++)
	{
		if (!vis[i]) {mul[i]=-1;prime[++len]=i;}
		for (int j=1;j<=len&&i*prime[j]<=n;j++)
		{
			vis[i*prime[j]]=true;
			if (i%prime[j]==0) {mul[i*prime[j]]=0;break;}
				else mul[i*prime[j]]=-mul[i];
		}
	}
	for (int i=1;i<=m;i++) mul[i]+=mul[i-1];
	printf("%lld\n",sum(n,m)*2-(ll)n*m);
}
```


---

## 作者：Crabby_Maskiv (赞：2)

为什么题解里没有人用 $\phi$ 函数迪利克雷卷积的方法做呢

题意理解不难，就是求这个表达式的值：

## $\sum_{i=1}^n \sum_{j=1}^m (2\times gcd(i,j)-1)$

将一些常数项去掉可转化为

## $2\times\sum_{i=1}^n \sum_{j=1}^m  gcd(i,j)-mn$

所以中间的部分就是我们需要关心的内容

我们会发现，$gcd$ 这个东西在我们的式子中出现是十分烦人的。实际上，如果我们把它分解成 $gcd$ 的一些因子就会好做的多。

（为什么非得这么做呢，主要是因为两个数的 $gcd$ 的所有因子肯定是**这两个数的所有公因数**，所以我们这么转换就把 $gcd$ 的影响消掉了）

转化可以通过迪利克雷卷积完成

~~众所周知~~，$\phi*1=Id$

也就是说，$\sum_{d|n}\phi(d)=n$ ，其中 $\phi$ 是欧拉函数，用于计算比某一个数小且与它互质的数的个数，可以 $O(n)$ 预处理~~方法请百度。~~

所以,$gcd(i,j)=\sum_{k|gcd(i,j)}\phi(k)=\sum_{k|i,k|j}\phi(k)$

中间的式子变为
## $\sum_{i=1}^n \sum_{j=1}^m\sum_{k|i,k|j}\phi(k)$

我们改变枚举的方式，先枚举 $k$ ，~~玄学转换一波~~

## $\sum_{k=1}^{min(m,n)}\phi(k)\sum_{i=1}^{[\frac{n}{k}]}\sum_{j=1}^{[\frac{m}{k}]}1$


~~等价什么的看着像就行~~，实际上就是缩小 $i,j$ 的枚举范围，使得枚举到的 $i,j$ 实际上对应着 $ik$ 与 $jk$

于是后面的东西可以改成常数求

## $\sum_{i=1}^{[\frac{n}{k}]}\sum_{j=1}^{[\frac{m}{k}]}1={[\frac{n}{k}]}{[\frac{m}{k}]}$

最后原式即为

## $2\times\sum_{k=1}^{min(m,n)}\phi(k){[\frac{n}{k}]}{[\frac{m}{k}]}-mn$

暴力求和即可

$O(n)$友善版

```cpp
#include<bits/stdc++.h>
//#define TIME
using namespace std;
typedef long long ll;
const int maxn=100005;
const int inf=0x3f3f3f3f;
const int mod=998244353;
ll n,m;
ll phi[maxn];
vector<ll> p;
bool isp[maxn];
void getphi(){
	memset(isp,1,sizeof(isp));
	phi[1]=1;
	for(int i=2;i<maxn;i++){
		if(isp[i]){
			p.push_back(i);
			phi[i]=i-1;
		}
		for(int j=0;j<p.size();j++){
			if(i*p[j]>=maxn) break;
			isp[i*p[j]]=0;
			if(i%p[j]==0) phi[i*p[j]]=phi[i]*p[j];
			else phi[i*p[j]]=phi[i]*(p[j]-1);
		}
	}
	return;
}
int main()
{
	int i,j;
	cin>>n>>m;
	getphi();
    ll ans=0;
	for(i=1;i<=min(n,m);i++){
    	ans+=phi[i]*(n/i)*(m/i);
    }
    cout<<ans;
	return 0;
}

```
$O\sqrt{n}$ 数论分块~~装逼~~版

```cpp
#include<bits/stdc++.h>
//#define TIME
using namespace std;
typedef long long ll;
const int maxn=100005;
const int inf=0x3f3f3f3f;
const int mod=998244353;
ll n,m;
ll phi[maxn];
vector<ll> p;
bool isp[maxn];
void getphi(){
	memset(isp,1,sizeof(isp));
	phi[1]=1;
	for(int i=2;i<maxn;i++){
		if(isp[i]){
			p.push_back(i);
			phi[i]=i-1;
		}
		for(int j=0;j<p.size();j++){
			if(i*p[j]>=maxn) break;
			isp[i*p[j]]=0;
			if(i%p[j]==0) phi[i*p[j]]=phi[i]*p[j];
			else phi[i*p[j]]=phi[i]*(p[j]-1);
		}
	}
	for(int i=1;i<maxn;i++) phi[i]+=phi[i-1];
	return;
}
ll f(ll x,ll y){
	ll cnt=0,l=1,r;
	if(x>y) swap(x,y);
	while(l<=x){
		ll t1=x/l,t2=y/l;
		r=min(x/t1,y/t2);
		cnt+=(phi[r]-phi[l-1])*t1*t2;
		l=r+1;
	}
	return cnt;
}
int main()
{
	int i,j;
	read(n,m);
	getphi();
	cout<<2*f(n,m)-m*n;
	return 0;
}

```

---

## 作者：ThinkofBlank (赞：2)

自行推了一番，然后A了，逛了下题解区，发现大家的方法都好神奇啊。。。

我是这样推的:

首先，$Ans=\sum_{i=1}^{n}\sum_{j=1}^{m}(2*gcd(i,j)-1)$,这个不解释。。。

然后，我们将它分开:

$Ans=2*\sum_{i=1}^{n}\sum_{j=1}^{m}gcd(i,j)-\sum_{i=1}^{n}\sum_{j=1}^{m}1$

$=2*\sum_{i=1}^{n}\sum_{j=1}^{m}gcd(i,j)-n*m$

所以，我们主要就是要求$\sum_{i=1}^{n}\sum_{j=1}^{m}gcd(i,j)$的值

那么，我们套路性的设$f(x)=\sum_{i=1}^{n}\sum_{j=1}^{m}[gcd(i,j)=x]$,$F(d)=\sum_{d|t}f(t)=\lfloor\frac{n}{d}\rfloor*\lfloor\frac{m}{d}\rfloor$

反演一下:$f(t)=\sum_{t|d}u(\frac{d}{t})*F(d)$

而$\sum_{i=1}^{n}\sum_{j=1}^{m}gcd(i,j)$其实就等于$\sum_{i=1}^{min(n,m)}f(i)*i$

代入得:

$\sum_{i=1}^{n}\sum_{j=1}^{m}gcd(i,j)$=$\sum_{i=1}^{min(n,m)}f(i)*i$

$=\sum_{i=1}^{min(n,m)}\sum_{i|j}u(\frac{j}{i})*F(j)*i$

$=\sum_{i=1}^{min(n,m)}\sum_{i|j}u(\frac{j}{i})*\lfloor\frac{n}{j}\rfloor*\lfloor\frac{m}{j}\rfloor*i$



化简到这一步，你就可以O(nlogn)AC了，记得处理剩下的计算哦！

代码如下:
```c
#include<bits/stdc++.h>
#define int long long//防止爆int~ 
using namespace std;
const int N=1e5+1;
int u[N],zhi[N],e;//分别为:莫比乌斯函数,质数表,质数表的大小 
bool f[N];//判断是否被筛去 
inline void sai(int maxe){//线性筛，筛莫比乌斯函数 
	u[1]=1;
	for(int i=2;i<=maxe;++i){
		if(!f[i]){
			zhi[++e]=i;
			u[i]=-1;
		}
		for(int j=1;j<=e;++j){
			if(i*zhi[j]>maxe){
				break;
			}
			f[i*zhi[j]]=1;
			if(i%zhi[j]==0){
				u[i*zhi[j]]=0;
				break;
			}
			u[i*zhi[j]]=-u[i];
		}
	}
}
signed main(){
	sai(N-1);
	int n,m;
	scanf("%lld%lld",&n,&m);
	int C=min(n,m);
	long long ans=0;
	for(int t=1;t<=C;++t){ 
		for(int d=t;d<=C;d+=t){
			ans+=u[d/t]*(n/d)*(m/d)*t;//带公式计算 
		}
	}
	ans*=2;//记得完成剩下的计算 
	ans-=(n*m);
	printf("%lld",ans);//输出，AC！ 
	return 0;
}

```


---

## 作者：zcysky (赞：2)

贾志鹏线性筛求phi函数。

可以发现，到达(x,y)的整点个数为gcd(x,y)-1个，因为这里实在是不好打符号，给个分析详细的blog吧。

```cpp
<http://blog.csdn.net/S_Black/article/details/51958938>%%%%
#include<bits/stdc++.h>
#define N 1000010
#define ll long long
using namespace std;
int prime[N],mu[N],d[N],c[N];
ll tot;
ll phi[N];
bool vis[N];
int f[N];
void calcall(){
    ll cnt=0;
    memset(vis,true,sizeof(vis));
    phi[1]=1;mu[1]=1;d[1]=1;
    for(ll i=2;i<=tot;i++){
        if(vis[i])prime[++cnt]=i,phi[i]=i-1,mu[i]=-1,d[i]=2,c[i]=1;
        for(ll j=1;j<=cnt&&1LL*i*prime[j]<=tot;j++){
            vis[i*prime[j]]=false;int t=i*prime[j];
            if(i%prime[j]) phi[i*prime[j]]=phi[i]*(prime[j]-1),mu[t]-=mu[i],c[t]=1,d[t]=d[i]*2;
        else { phi[i*prime[j]]=phi[i]*prime[j];mu[t]=0;
        c[t]=c[i]+1;d[t]=d[i]/(c[i]+1)*(c[t]+1);break; }
        }
    }
    //for test
    for(int i=2;i<=tot;i++)phi[i]+=phi[i-1]; 
}
ll n,m;
int main(){
    scanf("%lld%lld",&n,&m);tot=min(n,m);
    calcall();
    ll last=0,t=min(n,m);
    ll ans=0;
    for (int i=1;i<=t;i=last+1)
    {
        last=min(n/(n/i),m/(m/i));
        ans+=(ll) (n/i)*(m/i)*(phi[last]-phi[i-1]);
    }
    ans=(ll)ans*2-n*m;
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：COUPDETAT (赞：1)

看这题之前 先来几道类似的

# [GCD SUM](<https://www.luogu.org/problem/P2398>)

题意简单明了 十分友善

如果用欧拉函数的方法做可以很轻松的过掉 

详情请看[仪仗队](<https://www.luogu.org/problem/P2158>)

![img](https://cdn.luogu.com.cn/upload/pic/1149.png)

```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<iostream>
using namespace std;
int p[1000000],phi[1000000],vis[1010101];
long long ans;
int  main(){
	
    int n;
    scanf("%d",&n);
    if(n==1){
    	cout<<0;
    	return 0;
	}
    phi[1]=1;
    for(int i=2;i<=n;i++)
    {
    	if(!vis[i])
    	p[++p[0]]=i,phi[i]=i-1;
    	for(int j=1;j<=p[0]&&i*p[j]<=n;j++)
    	{
    		vis[i*p[j]]=1;
    		if(i%p[j]==0)
    		{
    			phi[i*p[j]]=phi[i]*p[j];
    			break;
			}
			else phi[i*p[j]]=phi[i]*(p[j]-1);
		}
		//ans+=phi[i];
	}
	n--;
    ans=0;
    for(int i=1;i<=n;i++)
    {
    	ans+=phi[i];
	}
    cout<<ans*2+1;
    return 0;
}
```

代码会及其冗长

但是如果换个思路

![img](D:\OneDrive - langlangago\Pictures\2608.png)

观察这张图片 可以得到以下几个性质

1.相同点的标号等于他们的GCD

2.设一个点坐标为x,y  以gcd(x,y)为gcd的个数等于$(n/x)*(m/x)$

3.考虑对第二步从右上到左下容斥 

![](http://101.200.56.58/wp-content/uploads/2019/10/%E5%9B%BE%E7%89%87.png)

这样 我们只需要枚举gcd即可

# p2398

```cpp
#include<cstdio>
int main()
{
	long long n,m,a[100000],ans=0;
	scanf("%lld",&n);m=n;
	for(int i=1;i<=n;i++) a[i]=(n/i)*(m/i);
	for(int i=n;i>=1;i--) {
		for(int j=2;j<=n/i;j++)
			a[i]-=a[j*i];ans+=(a[i]*i);
	}	printf("%lld",ans);
}
```

# p1447

```cpp
#include<cstdio>
int main()
{
	long long n,m,a[100000],ans=0;
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++) a[i]=(n/i)*(m/i);
	for(int i=n;i>=1;i--) {
		for(int j=2;j<=n/i;j++)
			a[i]-=a[j*i];ans+=(a[i]*(i*2-1));
	}	printf("%lld",ans);
}
```



---

## 作者：吹雪吹雪吹 (赞：1)

[在蒟蒻的博客里查看](https://xcfubuki.cn/2019/Mengbiwusi/)

据大佬们说，这题就是求$(\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m}gcd(i, j))*2-n*m$

那么只要求 $\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m}gcd(i, j)$ 就好了0v0

#### $\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m}gcd(i, j)$

枚举$gcd$：

#### $\sum\limits_{k=1}^{n}k*\sum\limits_{i=1}^{n}\sum\limits_{J=1}^{m}[gcd(i,j)=k]$

老套路拎出$k$：

#### $\sum\limits_{k=1}^{n}k*\sum\limits_{i=1}^{\lfloor n/k\rfloor}\sum\limits_{J=1}^{\lfloor m/k\rfloor}[gcd(i,j)=1]$

$gcd$ 改成 $\mu$：

#### $\sum\limits_{k=1}^{n}k*\sum\limits_{i=1}^{\lfloor n/k\rfloor}\sum\limits_{j=1}^{\lfloor m/k\rfloor}\sum\limits_{d|gcd(i,j)}\mu(d)$

把$d$ 拎到外面

#### $\sum\limits_{k=1}^{n}k*\sum\limits_{d=1}^{\lfloor n/k\rfloor}\lfloor \frac{n}{kd}\rfloor \lfloor \frac{m}{kd}\rfloor*\mu(d)$

最后把 $\mu$ 筛出来，再用这个式子弄一下就好了

可以证明其时间复杂度为O(n log n)

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#define maxn 100005

using namespace std;

int n, m, mu[maxn], p[maxn], cnt;
long long ans = 0;
bool vis[maxn];

void Init()
{
	vis[1] = 1, mu[1] = 1;
	for (int i = 2; i < maxn; ++i)
	{
		if (!vis[i])
			p[++cnt] = i, mu[i] = -1;
		for (int j = 1; j <= cnt && p[j] * i < maxn; ++j)
		{
			int x = i * p[j];
			vis[x] = 1, mu[x] = -mu[i];
			if (i % p[j] == 0)
			{
				mu[x] = 0;
				break;
			}
		}
	}
}

int main()
{
	freopen("test.in", "r", stdin);
	freopen("test.out", "w", stdout);
	Init();
	n = read(), m = read();
	if (n > m)
		swap(n, m);
	for (int k = 1; k <= n; ++k)
	{
		int lim = n / k, res = 0;
		for (int d = 1; d <= lim; ++d)
			res += (n / (k * d)) * (m / (k * d)) * mu[d];
		ans += 1ll * res * k;
	}
	ans = ans * 2 - n * m;
	printf("%lld\n", ans);
	return 0;
}
```

---

## 作者：Sweetlemon (赞：1)

什么时候我这种蒟蒻也开始看$\text{NOI}$的题了呢？（逃

好吧，也是[$\text{hkr04}$](https://www.luogu.org/space/show?uid=111528)这位神犇介绍我看的，而看到这道题之前[$\text{HKZeril}$](https://www.luogu.org/space/show?uid=66073)神犇把与这题有关的一个结论介绍给了我。在此向这两位神犇表示深深的谢意！

好的，言归正传。我们先看一个结论（定理）。~~这次不会是什么恋爱循环定理啦~~

定理 $2.33$ 设$A(0,0),B(n,m)(n,m\in \mathbb{N}_{+})$，那么线段$AB$上整点的个数即为$\gcd(n,m)+1$。

如何证明这个定理呢？

设点$C(x,y)(x,y\in \mathbb{N})$在线段$AB$上，那么有$\frac{x}{n}=\frac{y}{m}$。

设$g=\gcd(n,m),n'=\frac{n}{g},m'=\frac{m}{g}$。则上式可化为$\frac{x}{n'}=\frac{y}{m'}$，则$xm'=yn'$。

由$n'\perp m'$，得$n'\mid x,m'\mid y$。现在可设$k=\frac{x}{n'}=\frac{y}{m'}(k\in \mathbb{N})$，又由线段的条件知$0\le k \le g$。

我们构造一个点集$S=\{(kn',km')\mid k\in \mathbb{N}, 0\le k\le g\}$，可以发现点集中的点全部都在线段$AB$上。又根据上面的讨论知道线段$AB$上的整点必须满足集合$S$的条件，因此我们就可以下定论：$S$是线段$AB$上的所有整点的集合。易知$\left| S \right|=g+1$。定理证毕。

现在请看题（逃

[P1447 [NOI2010]能量采集](https://www.luogu.org/problemnew/show/P1447)

读题并结合定理，这道题要求的就是$$2\sum^{n}_{i=1}\sum^{m}_{j=1}(\gcd(i,j))-nm$$

（注意这题的线段$AB$不含端点，因此每一条线段上的整点数应为$\gcd(i,j)-1$。）

上式的难点就在于$\sum^{n}_{i=1}\sum^{m}_{j=1}\gcd(i,j)$。下面请看一些神奇的推导！

首先，我们再看一个定理：

定理$2.333$  $\text{ }\varphi$函数对约数求和定理 （《数论入门》$\text{P35}$）

$$\forall n\in \mathbb{N_{+}},\sum_{d\mid n}\varphi(d)=n$$

证明：根据$\varphi$函数的定义，$\varphi(n)$表示$[1,n]$中与$n$互质的整数的数目。

设$d\mid n,n=kd(k\in\mathbb{N})$，设集合$S=\{x\in\mathbb{N_{+}}\mid x\perp d\}$，则$\left| S\right|=\varphi (d)$。设函数$f:S\rightarrow \mathbb{N}$，$f(x)=kx$。设$f(x)$的值域为$S'$。由于$f$是单射，因此$\left|S'\right|=\left|S\right|=\varphi(d)$。

对于$S'$中的每一个元素$f(x)=kx$，由于$x\perp d$，因此$\gcd(f(x),n)=\gcd(kx,kd)=k\gcd(x,d)=k$。

因此，我们可以说，$S'=\{x\in\mathbb{N_{+}}\mid \gcd(x,n)=k\}$。

$\{k\}$和$\{d\}$中的元素是一一对应的，且不同$k$的$S'$两两不交，因此$\bigcup S'$即为$[1,n]\cap\mathbb{N}$，定理证毕。

根据这个定理，我们可以对$\sum^{n}_{i=1}\sum^{m}_{j=1}\gcd(i,j)$这个式子做一些似乎无意义的变形：$$\sum^{n}_{i=1}\sum^{m}_{j=1}\gcd(i,j)=\sum^{n}_{i=1}\sum^{m}_{j=1}\sum_{d\mid \gcd(i,j)}\varphi (d)=\sum^{n}_{i=1}\sum^{m}_{j=1}\sum_{d\mid i,d\mid j}\varphi (d)$$

然而，这一步变形却是$\text{AC}$的开始。接下来我们考虑更换枚举顺序（即交换求和号的顺序）。

考虑对于每一个数$d$，$\varphi(d)$会被加几次呢？也就是说，在$1\le i\le n,1\le j\le m$的范围内，有多少对$(n,m)$满足$d\mid i,d\mid j$呢？

在范围内，$i$有$\lfloor \frac{n}{d} \rfloor$种选法，$j$有$\lfloor \frac{m}{d} \rfloor$种选法，根据乘法原理，满足条件的数对就有$\lfloor \frac{n}{d} \rfloor\lfloor \frac{m}{d} \rfloor$个。于是$\varphi(d)$对答案的贡献便是$\lfloor \frac{n}{d} \rfloor\lfloor \frac{m}{d} \rfloor \varphi(d)$。

写到这里，答案已经呼之欲出了，便是
$$\sum^{\min(n,m)}_{i=1}\lfloor \frac{n}{d} \rfloor\lfloor \frac{m}{d} \rfloor \varphi(d)$$

接下来的事情便十分简单，使用欧拉筛（线性筛）计算出$\varphi$函数的值，再直接求和即可。时间复杂度$\text{O}(n)$。

当然，推导到这一步需要很强的思维能力。为了简化思维难度，大佬们研发出了莫比乌斯~~繁衍~~反演、狄利克雷卷积等工具。这题当然也可以用这些方法推导式子。

最后上代码。

```cpp
#include <iostream>
#include <algorithm>
#define MAXN 100005
using namespace std;
void eular(int n); //线性筛求欧拉函数
int phi[MAXN]; //用来保存欧拉函数的值
int minp[MAXN],prime[MAXN],pr; //质数表，线性筛用

int main(void){
    int n,m;
    long long ans=0;
    cin >> n >> m;
    if (n>m)
        swap(n,m); //n=min(n,m)
    eular(n);
    for (int i=1;i<=n;i++)
        ans+=((long long)(n)/i)*((long long)(m)/i)*phi[i];
    ans*=2; //2倍gcd之和
    ans-=(long long)(n)*m; //再减去mn
    cout << ans << endl;
    return 0;
}

void eular(int n){
    phi[1]=1;
    int t;
    for (int i=2;i<=n;i++){
        if (!minp[i]){
            minp[i]=i;
            phi[i]=i-1; //phi(p)=p-1,其中p是质数
            prime[pr++]=i;
        }
        for (int j=0;j<pr && (t=i*prime[j])<=n;j++){
            minp[t]=prime[j]; //minp表示最小质因子
            if (prime[j]==minp[i]){
                phi[t]=prime[j]*phi[i];
                break;
            }
            //else
            phi[t]=(prime[j]-1)*phi[i];
        }
    }
}
```

---

## 作者：凌幽 (赞：1)

经过分析,发现当某棵植物与机器的连线上没有其他点时,这棵植物的坐标(x,y)必定满足gcd(x,y)=1,损失能量为1;而当某棵植物与机器的连线上有其他点时,连线上点的个数是gcd(x,y)-1,损失能量为(gcd(x,y)-1)\*2+1 = gcd(x,y)\*2-1

这是道良心题,按照这个想法暴力分就达到了80

我们怎么优化暴力呢?用f[i]表示gcd(x,y)=i的点对(x,y)有多少个

通过mn的枚举太费时间了,所以我们换一种方法

共有m行n列植物(n是横坐标,m是纵坐标),n/i是有多少个横坐标含有i这个因数,m/i是有多少个纵坐标含有i这个因数,通过n/i\*(m/i)就得到了在这m行n列植物中有多少棵植物的坐标含有i这个公因数,但是这个点对的最大公因数不一定是i,所以要减去含有2i,3i,4i...公因数的点数数量,这才能得到最终需要的f[i]

最后累计答案就好了

AC代码

```cpp
#include<cstdio>
using namespace std;
#define ll long long
#define R register 
int n,m;
ll f[100002];
inline int gcd(int a,int b){
    return b==0?a:gcd(b,a%b);
}
ll sum;
inline int dy(){
    scanf("%d%d",&n,&m);
    if(n<m){
        R int t=n; n=m; m=t;
    }
    for(R int i=n;i;--i){
        f[i]=1ll*n/i*(m/i);
        for(R int j=i+i;j<=n;j+=i) f[i]-=f[j];
        sum+=f[i]*(2*i-1);
    }
    printf("%lld\n",sum);
    return 0;
}
int QAQ = dy();
int main(){;}
```

---

## 作者：Skywalker_David (赞：1)

把每一个坐标的最大公约数\*2-1，而公约数中最大的一定是min(n,m); so 我们可以记录公约数的多少，也就是每一个数一共是多少个点的最大公约数，这个嘛，倒也不难，1——n中有n div i 个数是i的倍数，1——m中有m div i 个数是i的倍数，组合一下就是（n div i）\*（m div i）个约数

代码如下：

```cpp
var 
    n,m,i,j:longint;sum,ans:int64; 
    f:array[1..100000]of int64; 
begin 
    readln(n,m);
    if n<m then begin i:=n;n:=m;m:=i;end;
    for i:=m downto 1 do begin 
        sum:=(int64(n div i))*(int64(m div i)); 
        for j:=2 to m div i do sum:=sum-f[i*j];
            f[i]:=sum;ans:=ans+(2*i-1)*f[i];
    end;
    write(ans); 
end.
```

---

## 作者：muller (赞：1)

这题我们需要归纳一下吧！发现答案是sigma(gcd(x,y)), 1<=x<=n, 1<=y<=m
然后我们要算这个东西，

令f[d]为(x, y) = d的对数，那么答案就是sigma(f[i] *((i-1)*2+1))

f[i]怎么求呢？

在1 <= x <= n, 1 <= y <= m中，gcd(x, y) | d的有[n/d] * [m/d]个。

不过我们要扣掉所有的倍数，f[i] = [n/d] * [m/d] - f[2i] - f[3i] - f[4i] - 

...。

逆序做即可。具体见代码：
```pascal
#include <bits/stdc++.h>
using namespace std;
const int N = 100005;
long long ans = 0, f[N];
int main() {
	int i, j, n, m; scanf("%d %d", &n, &m);
	if (n > m) swap(n, m);
	for (i = n; i; --i) {
		f[i] = 1ll * (n / i) * (m / i);
		for (j = (i << 1); j <= n; j += i) f[i] -= f[j];
		ans += 1ll * f[i] * ((i << 1) - 1); 
	}
	printf("%lld\n", ans);
	return 0;
}

```

---

## 作者：hl666 (赞：0)

#### Preface

最近**反演**题做多了看什么都想反演。这道题由于**数据弱**，解法多种多样，这里简单分析一下。

首先转化下题目就是对于一个点$(x,y)$，所消耗的能量就是$2(\gcd(x,y)-1)+1=2\cdot\gcd(x,y)-1$（**小学奥数题**）

所以求和就是求$\sum_{i=1}^n\sum_{j=1}^m2\cdot\gcd(i,j)-1=2\cdot\sum_{i=1}^n\sum_{j=1}^m\gcd(i,j)-nm$，因此主要问题就变成了求解$\sum_{i=1}^n\sum_{j=1}^m\gcd(i,j)$（对于反演来说，**容斥**的话直接怎么暴力怎么来）

------

#### 一.转化+递推+容斥法

首先转化问题，我们考虑每一个数当它作为其它两个数的$\gcd$时会产生多少贡献。

先把问题简单化，我们先求出一个数为其它两个数的**约数**的方案数$f(i)$，显然~~小学生都知道~~$f(i)=\lfloor\frac{n}{i} \rfloor\lfloor\frac{m}{i} \rfloor$

但是可能$f(i)$会多算当$i|j$时$j$的贡献，因此我们需要减掉$\sum_{i|j} f(j)$

因此我们**从大到小**枚举并计算$f(i)$即可，结合**调和级数**的公式发现复杂度为$O(n(\ln(n)+H_n))$（$H_n$是**欧拉常数**）

CODE

```cpp
#include<cstdio>
#define RI register int
using namespace std;
int n,m,lim; long long ans,f[100005];
inline int min(int a,int b)
{
    return a<b?a:b;
}
int main()
{
    scanf("%d%d",&n,&m); lim=min(n,m);
    for (RI i=lim;i;--i)
    {
        f[i]=1LL*(n/i)*(m/i);
        for (RI j=i<<1;j<=lim;j+=i) f[i]-=f[j];
        ans+=1LL*((i<<1LL)-1)*f[i];
    }
    return printf("%lld",ans),0;
}
```



------

#### 二.我的蒟蒻反演做法

反演题做的多了就算是像我这样的**蒟蒻**也能自己推一推了。

感觉这个很套路就那以前的套路去套~~结果5min就搞出来一个看上去很正确的式子~~然后就过了。

这里讲一讲我的做法，根据之前做的一些反演题（如[Luogu P2257 YY的GCD](https://www.cnblogs.com/cjjsb/p/9852268.html)）我们很套路的来：

令$f(d)$为$\gcd(i,j)(i\in[1,n],j\in[1,m])=d$的个数，$F(s)$为$d|\gcd(i,j)$的个数

即：

$$f(d)=\sum_{i=1}^n\sum_{j=1}^m [\gcd(i,j)=d]$$

$$F(s)=\sum_{s|d}f(d)=\lfloor\frac{n}{s} \rfloor \lfloor\frac{m}{s} \rfloor$$

考虑所求，则有：

$ans=\sum_{d=1}^{\min(n,m)}f(d)\cdot d$

还是用**莫比乌斯反演定理**，得到：

$$f(d)=\sum_{d|s} \mu(\lfloor\frac{s}{d} \rfloor)F(s)$$

把$F(s)=\lfloor\frac{n}{s} \rfloor \lfloor\frac{m}{s} \rfloor$代进去有：

$$f(d)=\sum_{d|s} \mu(\lfloor\frac{s}{d} \rfloor)\lfloor\frac{n}{s} \rfloor \lfloor\frac{m}{s} \rfloor$$

一个简单的套路，把枚举$d$变成$n$是$d$的多少倍，即：

$$f(d)=\sum_{i=1}^{\lfloor\frac{n}{d} \rfloor} \mu(i)\lfloor\frac{n}{d\cdot i} \rfloor \lfloor\frac{m}{d\cdot i} \rfloor$$

再把这个代回去就有：

$$ans=\sum_{d=1}^{\min(n,m)} d\cdot\sum_{i=1}^{\lfloor\frac{n}{d} \rfloor} \mu(i)\lfloor\frac{n}{d\cdot i} \rfloor \lfloor\frac{m}{d\cdot i} \rfloor$$

还要化简么？我们看看这道题的数据范围，$n,m\le100000$，而且是**单组询问**

因此我们发现这个式子的复杂度根据**调和级数定理**为$O(n(\ln(n)+H_n))$，因此**暴力**即可过

CODE

```cpp
#include<cstdio>
#define RI register int
using namespace std;
const int P=100000;
int prime[P+5],cnt,phi[P+5],n,m,lim; bool vis[P+5]; long long ans,sum[P+5];
#define Pi prime[j]
inline void Euler(void)
{
	vis[1]=phi[1]=1; RI i,j; for (i=2;i<=P;++i)
	{
		if (!vis[i]) prime[++cnt]=i,phi[i]=i-1;
		for (RI j=1;j<=cnt&&i*Pi<=P;++j)
		{
			vis[i*Pi]=1; if (i%Pi) phi[i*Pi]=phi[i]*(Pi-1);
			else { phi[i*Pi]=phi[i]*Pi; break; }
		}
	}
	for (i=1;i<=P;++i) sum[i]=sum[i-1]+phi[i];
}
inline int min(int a,int b)
{
	return a<b?a:b;
}
int main()
{
	scanf("%d%d",&n,&m); Euler(); lim=min(n,m);
	for (RI l=1,r;l<=lim;l=r+1)
	{
		r=min(n/(n/l),m/(m/l)); ans+=1LL*(n/l)*(m/l)*(sum[r]-sum[l-1]);
	}
	return printf("%lld",(ans<<1LL)-1LL*n*m),0;
}
```

------

#### 三.利用狄利克雷卷积再加速

我们想一下，如果这题多组询问怎么办~~不保证毒瘤出题人不会出~~

因此我们思考应该还有更**优秀**的做法~~事实上也是有的~~

从第二种做法的$f(d)=\sum_{d|s} \mu(\lfloor\frac{s}{d} \rfloor)\lfloor\frac{n}{s} \rfloor \lfloor\frac{m}{s} \rfloor$开始，我们令$T=ds$，则有：

$$f(d)=\sum_{T=1}^{\min(n,m)}\lfloor\frac{n}{T} \rfloor\lfloor\frac{m}{T} \rfloor\sum_{d|T}\mu(\lfloor\frac{T}{d} \rfloor)$$

由于经典的**狄利克雷卷积**我们知道$\mu$的一个性质：$\sum_{d|n}d\cdot\mu(\lfloor\frac{n}{d} \rfloor)=\phi(n)$

（这个貌似也可以用**欧拉函数**的性质$\sum_{d|n}\phi(d)=n$再**反演**得来~~反正我不会证~~）

所以到现在就很简单了，把这个代进去就有：

$$ans=\sum_{T=1}^{\min(n,m)}\lfloor\frac{n}{T} \rfloor\lfloor\frac{m}{T} \rfloor\cdot\phi(T)$$

然后就是$O(n)$的式子了，当然，这个明显也可以做一发**欧拉函数的前缀和**结合**除法分块**做到单次询问$O(\sqrt {\min(n,m))}$的。因此多组询问也不再话下。

CODE

```cpp
#include<cstdio>
#define RI register int
using namespace std;
const int P=100000;
int prime[P+5],cnt,phi[P+5],n,m,lim; bool vis[P+5]; long long ans,sum[P+5];
#define Pi prime[j]
inline void Euler(void)
{
    vis[1]=phi[1]=1; RI i,j; for (i=2;i<=P;++i)
    {
        if (!vis[i]) prime[++cnt]=i,phi[i]=i-1;
        for (RI j=1;j<=cnt&&i*Pi<=P;++j)
        {
            vis[i*Pi]=1; if (i%Pi) phi[i*Pi]=phi[i]*(Pi-1);
            else { phi[i*Pi]=phi[i]*Pi; break; }
        }
    }
    for (i=1;i<=P;++i) sum[i]=sum[i-1]+phi[i];
}
inline int min(int a,int b)
{
    return a<b?a:b;
}
int main()
{
    scanf("%d%d",&n,&m); Euler(); lim=min(n,m);
    for (RI l=1,r;l<=lim;l=r+1)
    {
        r=min(n/(n/l),m/(m/l)); ans+=1LL*(n/l)*(m/l)*(sum[r]-sum[l-1]);
    }
    return printf("%lld",(ans<<1LL)-1LL*n*m),0;
}
```

------

#### Postscript

这真是一道很不错的数学题，上面的三种做法感觉都可以。

然而理论复杂度最优的[算法三](https://www.luogu.org/record/show?rid=12521705)跑的和[算法二](https://www.luogu.org/record/show?rid=12519795)一样。估计是除法做的太多常数**偏大**

而[算法一](https://www.luogu.org/record/show?rid=12572323)就很优秀了，常数极小且不用**欧拉筛**的预处理，因此再速度上碾压了其它两种解法。

而且暴力~~不动脑~~的推导过程，啧啧称奇。

---


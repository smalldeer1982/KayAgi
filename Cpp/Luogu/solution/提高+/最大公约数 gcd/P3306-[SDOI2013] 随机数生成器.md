# [SDOI2013] 随机数生成器

## 题目背景

小 W 喜欢读书，尤其喜欢读《约翰克里斯朵夫》。

## 题目描述

最近小 W 准备读一本新书，这本书一共有 $p$ 页，页码范围为 $0 \sim p-1$。

小 W 很忙，所以每天只能读一页书。为了使事情有趣一些，他打算使用 NOI2012 上学习的线性同余法生成一个序列，来决定每天具体读哪一页。

我们用 $x_i$ 来表示通过这种方法生成出来的第 $i$ 个数，也即小 W 第 $i$ 天会读哪一页。这个方法需要设置 $3$ 个参数 $a,b,x_1$，满足 $0\leq a,b,x_1\lt p$，且 $a,b,x_1$ 都是整数。按照下面的公式生成出来一系列的整数：
$$x_{i+1} \equiv a \times x_i+b \pmod p$$
其中 $\bmod$ 表示取余操作。

但是这种方法可能导致某两天读的页码一样。

小 W 要读这本书的第 $t$ 页，所以他想知道最早在哪一天能读到第 $t$ 页，或者指出他永远不会读到第 $t$ 页。


## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证：

- $1 \leq T \leq 50$。
- $0 \leq a, b, x_1, t \lt p$，$2 \leq p \leq 10^9$。
- $p$ 为质数。

## 样例 #1

### 输入

```
3
7 1 1 3 3
7 2 2 2 0
7 2 2 2 1
```

### 输出

```
1 
3 
-1```

# 题解

## 作者：ChenZ01 (赞：25)

[个人博客](https://chenz01.github.io)

欢迎大佬互换友链
## Link

[洛谷 3306](https://www.luogu.org/problemnew/show/P3306)

## Solution

大力推式子

$$X_{i + 1} \equiv aX_i + b(\mathrm{mod}\,p)$$
$$X_{i + 1} + \frac{b}{a} \equiv aX_i + b + \frac{b}{a}(\mathrm{mod}\,p)$$
$$aX_{i + 1} + b \equiv a^2X_i + ab + b(\mathrm{mod}\,p)$$
$$X_{i + 2} \equiv a^2X_i + ab + b(\mathrm{mod}\,p)$$

那么我们得到

$$X_2 \equiv aX_1 + b(\mathrm{mod}\,p)$$
$$X_3 \equiv a ^ 2X_1 + ab + b(\mathrm{mod}\,p)$$
$$X_4 \equiv a ^ 3X_1 + a ^ 2b + ab + b(\mathrm{mod}\,p)$$
$$\dots$$
$$X_i \equiv a ^ {i - 1}X_1 + b\sum_{j = 0} ^ {i - 2}a ^ j(\mathrm{mod}\,p)$$

也就是我们要判断如下方程是否有整数解，若有则求解

$$t \equiv a ^ {i - 1}X_1 + b\sum_{j = 0} ^ {i - 2}a ^ j(\mathrm{mod}\,p)$$

继续化化化

$$t \equiv a ^ {i - 1}X_1 + b\sum_{j = 0} ^ {i - 2}a ^ j(\mathrm{mod}\,p)$$
$$t \equiv a ^ {i - 1}X_1 + b\frac{1 - a ^ {i - 1}}{1 - a}(\mathrm{mod}\,p)$$
$$t \equiv a ^ {i - 1}X_1 + \frac{b}{1 - a} - \frac{b}{1 - a} \cdot a^{i - 1}(\mathrm{mod}\,p)$$
$$t \equiv a ^ {i - 1}(X_1 - \frac{b}{1 - a}) + \frac{b}{1 - a}(\mathrm{mod}\,p)$$
$$a ^ {i - 1} \equiv \frac{t - \frac{b}{1 - a}}{X_1 - \frac{b}{1 - a}}(\mathrm{mod}\,p)$$

大功告成，用BSGS求解出$i - 1$的值，由于$t$是第$i$项，答案加一即可

### Detail 1

对于$X_1 = t$时，直接输出$1$

### Detail 2

对于$a = 0$时，$X_i = b$

### Detail 3

对于$a = 1$时，有$X_i \equiv X_1 + b(i - 1)(\mathrm{mod}\,p)$
那么求解$t - X_1 \equiv b(i - 1)(\mathrm{mod}\,p)$的系数$i - 1$即可
注意当答案就是$p$的时候不要再模$p$了

## Code

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <map>

using std::cin;
using std::cout;
using std::endl;

template <typename I>
inline void read(I& x)
{
    char c = getchar();
    for (; !isdigit(c); c = getchar());
    for (x = 0; isdigit(c); x = x * 10 + (c ^ 48), c = getchar());
}

long long NUMOFCASES, a, b, p, x, t, X, Y;

long long exp(long long b, int i, int p)
{
    long long r = 1;
    for (; i; i >>= 1, b = b * b % p)
        if (i & 1)
            r = r * b % p;
    return r;
}

long long gcd(long long a, long long b)
{
    return b ? gcd(b, a % b) : a;
}

long long inv(long long x, int MOD)
{
    return exp(x, MOD - 2, MOD);
}

long long bsgs(long long a, long long b, int MOD)
{
    a %= MOD, b %= MOD;
    std::map <long long, long long> map;
    register long long m = ceil(sqrt(MOD)), t = 1;
    for (register int i = 0; i < m; ++i)
    {
        if (!map.count(t))
            map[t] = i;
        t = t * a % MOD;
    }
    register long long k = inv(t, MOD), w = b;
    for (int i = 0; i < m; ++i)
    {
        if (map.count(w))
            return i * m + map[w];
        w = w * k % MOD;
    }
    return -1;
}

int main()
{
    read(NUMOFCASES);
    for (; NUMOFCASES; --NUMOFCASES)
    {
        read(p), read(a), read(b), read(x), read(t);
        if (x == t)
            cout << 1 << endl;
        else if (a == 1)
        {
            t = ((t - x) % p + p) % p;
            if (t % gcd(b, p))
                cout << -1 << endl;
            else
            {
                if ((t * inv(b, p) + 1) % p == 0)
                    cout << p << endl;
                else
                    cout << (t * inv(b, p) + 1) % p << endl;
            }
        }
        else if (a == 0)
        {
            if (b == t)
                cout << 2 << endl;
            else
                cout << -1 << endl;
        }
        else
        {
            long long ans = bsgs(a, ((t - b * inv(1 - a, p)) % p + p) % p * inv(((x - b * inv(1 - a, p)) % p + p) % p, p), p) % p;
            if (ans == -1)
                cout << -1 << endl;
            else
                cout << ans + 1 << endl;
        }
    }
}
```

---

## 作者：wwyx2001 (赞：19)

在下以优秀的代码长度以及手写hash在BZOJ/luogu上光荣上榜！最优解前两个都是我哒，第一名是开了O2，第二名是没开O2 ╮(╯▽╰)╭


题目让求 $X_{i+1}=aX_i+b\  (mod \ \ p)$

我们回忆一下数学必修五关于数列的内容，把ta化成一个等比数列是不是好做很多呢？

那么我们画出来的等比数列就是

$X_{i+1}+\frac{b}{a-1}=a(X_i+\frac{b}{a-1}) \ (mod\ p)$

那么根据等比数列递推公式$X_n+\frac{b}{a-1}=a^{n-1}(X_1+\frac{b}{a-1}) \ (mod\ p)$

这里只有$a^{n-1}$是未知的呀，我们移项

$a^{n−1}≡(X_n+b∗inv(a−1))∗inv(X_1+b∗inv(a−1))\ (mod\ p)$

然后就是一个裸的BSGS啦

不过要特别注意特判内容，a=0和a=1，这个柿子都没有意义，所以要特判


更加优美的画柿子过程+优美代码戳[这里](http://blog.csdn.net/blue\_cuso4/article/details/78993076 "这里")


---

## 作者：Maxwei_wzj (赞：15)

本高一蒟蒻看了各位大佬的数学推导之后，肝败吓疯......看不懂数学推导的本蒟蒻只能掏出一个思路特别直但是代码长度非常...的做法：BSGS+矩阵乘法。

首先看到线性递推式，就想到用矩阵乘法来做，那么题目要求的就是关于$x$的方程：
$$\begin{pmatrix}a&b\\ 0&1\end{pmatrix}^x\begin{pmatrix}x_1\\1\end{pmatrix}=\begin{pmatrix}t\\1\end{pmatrix}$$
的最小非负整数解（以上等式表示在模$p$意义下等），那么$x+1$就是我们所求的答案。

然而注意到求这个方程比较困难，因为$x$在指数的位置。我们联想到，如果式子中不是矩阵而是整数的话，我们可以用BSGS在$O(\sqrt p)$的时间内求出解，但是这里换成了矩阵我们要怎么做呢？

其实非常相似，令上式中以$x$为指数的矩阵为$A$，我们构造一个矩阵$M$，使得$MA=E$，其中
$E$为单位矩阵，显然：
$$M=\begin{pmatrix}\frac{1}{a}&-\frac{b}{a}\\ 0&1\end{pmatrix}$$
那么我们仿照标准的BSGS算法，令$x=im+j$，那么上式就会变成：
$$A^{im}\begin{pmatrix}x_1\\1\end{pmatrix}=M^j\begin{pmatrix}t\\1\end{pmatrix}$$
于是我们先对右边求出所有可能的取值，存在哈希表中，然后对于左边可能的取值，在哈希表中查询有没有相同的元素存在，这其实和标准的BSGS算法完全一样。那么我们只需要令$m$为$\sqrt p$级别的一个数，这个算法的复杂度就是$O(\sqrt p)$的了。

还有一点要注意，当$a=0$时，$M$不存在，所以特判一下即可。

**代码：**

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll hashmod=1000003;
int T,q[1000010],top=0,blocksize;
ll p,a,b,x1,t,hashlist[1000010],val[1000010]={0};
struct matrix
{
    ll mat[2][2];
}E,A,S,M;

void hashinsert(ll x,ll v)
{
    int now=x%hashmod;
    while (hashlist[now]!=-1&&hashlist[now]!=x) now=(now+1)%hashmod;
    if (hashlist[now]==-1) hashlist[now]=x,val[now]=v,q[++top]=now;
}

ll hashfind(ll x)
{
    int now=x%hashmod;
    while (hashlist[now]!=-1&&hashlist[now]!=x) now=(now+1)%hashmod;
    if (hashlist[now]==x) return val[now];
    else return -1;
}

ll power(ll a,ll b)
{
    ll s=1,ss=a;
    while(b)
    {
        if (b&1) s=(s*ss)%p;
        ss=(ss*ss)%p;b>>=1;
    }
    return s;
}

matrix mult(matrix A,matrix B)
{
    matrix S;
    memset(S.mat,0,sizeof(S.mat));
    for(int i=0;i<2;i++)
        for(int j=0;j<2;j++)
            for(int k=0;k<2;k++)
                S.mat[i][j]=(S.mat[i][j]+A.mat[i][k]*B.mat[k][j])%p;
    return S;
}

void init()
{
    for(int i=1;i<=top;i++) hashlist[q[i]]=-1;
    scanf("%lld%lld%lld%lld%lld",&p,&a,&b,&x1,&t);
    blocksize=(int)(sqrt(p)+1);
    A.mat[0][0]=a,A.mat[0][1]=b,A.mat[1][0]=0,A.mat[1][1]=1;
    S=E;
    for(int i=1;i<=blocksize;i++) S=mult(S,A);
    M.mat[0][0]=power(a,p-2),M.mat[0][1]=((-b*power(a,p-2))%p+p)%p;
    M.mat[1][0]=0,M.mat[1][1]=1;
}

void BSGS()
{
    matrix N=E;
    top=0;
    for(int i=0;i<blocksize;i++,N=mult(N,M))
        hashinsert((N.mat[0][0]*t+N.mat[0][1])%p,i);
    N=E;
    for(int i=0;i<=blocksize;i++,N=mult(N,S))
    {
        ll s=hashfind((N.mat[0][0]*x1+N.mat[0][1])%p);
        if (s!=-1)
        {
            printf("%lld\n",i*blocksize+s+1);
            return;
        }
    }
    printf("-1\n");
}

int main()
{
    scanf("%d",&T);
    E.mat[0][0]=E.mat[1][1]=1;
    E.mat[0][1]=E.mat[1][0]=0;
    for(int i=0;i<=hashmod;i++) hashlist[i]=-1;
    while(T--)
    {
        init();
        if (a) BSGS();
        else
        {
            if (t==x1) printf("1\n");
            else if (t==b) printf("2\n");
                 else printf("-1\n");
        }
    }

    return 0;
}
```

---

## 作者：HoshiuZ (赞：6)

### 思路

分类讨论一下。

- 当$a=0$时，$X_i,i\ge 2$一直为$b$，判断$b$是否等于$t$即可。

- 当$a=1$时，$X_{i+1}=X_i+b$，显然是个等差数列，$X_n=X_1+(n-1)b$。

  那么所求的天数$n$即为满足$X_1+(n-1)b\equiv t\pmod p$的最小非负整数解。

  这可以用扩欧进行求解。

- 当$a\ge1$时，$X_{i+1}=aX_i+b$。

  待定系数法搞一下，设$X_{i+1}+k=a(X_i+k)$，解得$k=\frac{b}{a-1}$。

  代入即
  $$
  X_{i+1}+\frac{b}{a-1}=a(X_i+\frac{b}{a-1})
  $$
  那么数列$Y_n=X_n+\frac{b}{a-1}$为一个公比为$a$的等比数列。

  由于$X_1$已知，可以求出$Y_1=X_1+\frac{b}{a-1}$。

  那么
  $$
  Y_n=(X_1+\frac{b}{a-1})a^{n-1}
  $$
  

  则
  $$
  X_n=(X_1+\frac{b}{a-1})a^{n-1}-\frac{b}{a-1}
  $$
  则所求的天数$n$即为满足
  $$
  (X_1+\frac{b}{a-1})a^{n-1}-\frac{b}{a-1}\equiv t\pmod p
  $$
  稍微移个项，化个简
  $$(X_1+\frac{b}{a-1})a^{n-1} \equiv t+\frac{b}{a-1}\pmod p$$
  $$a^{n-1} \equiv \frac{t+\frac{b}{a-1}}{X_1+\frac{b}{a-1}}\pmod p$$
  $$a^{n-1} \equiv \frac{at-t+b}{aX_1-X_1+b}\pmod p$$
  $$a^{n-1} \equiv (at-t+b)\times (aX_1-X_1+b)^{-1}\pmod p$$

  注意不能两边同乘一个$a$过去，否则会出带问题！会解出来$0$的。这里只需解出来后加一即可。由于$p$为质数，所以可以用$BSGS$求出$n$的值。

  其中$(aX_1-X_1+b)^{-1}$表示模$p$意义下的逆元，由于保证$p$为质数，可用费马小定理求出来。

### 代码

```cpp
#include<bits/stdc++.h>
#define ll long long 
#define mul(x,y) (((x%p+p)%p)*((y%p+p)%p))%p

using namespace std;

int T;
ll p,a,b,X_1,t,x,y;
map <ll,int> vh;

ll quickp(ll x,ll y) {
	if(!y) return 1;
	ll t=quickp(x,y/2);
	if(y&1) return mul(x,mul(t,t));
	return mul(t,t);
}

ll EXGCD(ll a,ll b,ll &x,ll &y) {
	if(!b) {
		x=1;
		y=0;
		return a;
	}
	ll gcd=EXGCD(b,a%b,x,y),t=x;
	x=y;
	y=t-a/b*y;
	return gcd;
}

ll BSGS(ll a,ll b,ll p) {
	vh.clear();
	if(b==1) return 0;
	if(!(a%p)) {
		if(!b) return 1;
		return -2;
	}
	b%=p;
	ll k=ceil(sqrt(p)),tmp=b,t=quickp(a,k);
	for(int j=1;j<=k;j++) {
		tmp=mul(tmp,a);
		vh[tmp]=j;
	}
	tmp=1;
	for(int i=1;i<=k;i++) {
		tmp=mul(tmp,t);
		if(vh[tmp]) return ((i*k-vh[tmp])%p+p)%p;
	}
	return -2;
}

int main() {
	cin>>T;
	
	while(T--) {
		scanf("%lld%lld%lld%lld%lld",&p,&a,&b,&X_1,&t);
		if(X_1==t) printf("1\n");
		else if(!a) {
			if(b==t) printf("2\n");
			else printf("-1\n");
		}
		else if(a==1) {
			ll Y=((t+b-X_1)%p+p)%p,gcd=EXGCD(b,p,x,y),ans;
			if(Y%gcd) printf("-1\n");
			else {
				x*=Y/gcd;
				ans=(x%p+p)%p;
				printf("%lld\n",!ans?p:ans);
			}
		}
		else {
			ll A=a,B=mul(mul(a,t)-t+b,quickp(mul(mul(a,X_1)-X_1+b,1),p-2));
			ll ans=BSGS(A,B,p);
			printf("%lld\n",ans+1);
		}
	}
	
	return 0;
}
```

提交了十几遍，结果发现错误原因是求$a\not=1$时的式子时，用自己写的`mul`操作后可能为负.....于是把`mul`给改了，保证俩大于$0$。代码中的`mul(a,X_1)-X_1+b,1)`也是为了保证其大于$0$而这样写的。~~果然我太弱了呢~~

---

## 作者：hovny (赞：5)

## 前言

~~致敬~~自己的$16$次提交，漏洞百出

## 解题思路

这种题目，当然就是~~找规律~~套路题啊

有经验就会知道这是一道`BSGS`的题 ~~找BSGS找到的不是BSGS是什么~~

最复杂的就是~~颓~~推公式了

先随便从$x_1$开始写几组

> $x_1=x_1$  题目已经给出了
>
> $x_2=ax_1+b$
>
> $x_3=a^2x_1+ab+b$
>
> $x_4=a^3x_1+a^2b+ab+b$

好像就可以得出结论了
$$x_i=a^{i-1}x_1+a^{i-1}b+a^{i-2}b+…+b$$
对于后面这一串东东，~~如果上过小学~~学过**等比数列求和公式**的巨蛤都知道
$$x_i=a^{i-1}x_1+\frac{b(1-a^{i-1})} {1-a}$$
那么是不是可以开始狂颓公式了

~~1、换元（这绝对不是高中数学课~~
$$x_i \equiv t(mod\ p)$$
然后把上面那个代入
$$a^{i-1}x_1+\frac {b(1-a^{i-1})} {1-a} \equiv t$$
疯狂搞一搞，把$a^{i-1}$搞出来
$$(1-a)·a^{i-1}x_1+{b(1-a^{i-1})} \equiv t-t·a$$

$$(x_1-x_1·a)·a^{i-1}+b-b·a^{i-1} \equiv t-t·a$$

$$(x_1-x_1·a-b)·a^{i-1}\equiv t-t·a-b$$

$$a^{i-1}\equiv \frac {t-t·a-b} {x_1-x_1·a-b}$$

这样我们就可以按照普通的$BSGS$求，把结果$+1$即可

~~然后就很OK了~~

然鹅并没完，（不要问为什么，~~否则我也不会提交16次了~~

**考虑几种特殊情况：**

1. $x_1=t$

第一天就可以读到，输出`1`，其实也没是什么影响

2. $a=1$

这就变成了$x_1+k·b \equiv t(mod\ p)$，费马小定理求一下就好了，注意无解的情况——也就是$b=0$

3. $a=0$

~~傻子~~都知道和$x_1$无关了，这时只要判断一下$b==t$，则第二天就能读到$t$，否则读一辈子都读不完~~（那就别读了~~

## Code：

```cpp
#include<bits/stdc++.h>//这里原题中的t用r表示
#define rgt register
#define ll long long
#define N 100007
using namespace std;
int head[N],nxt[N],val[N],num[N];//用hash表存会快一点，虽然可以用unordered_map
int T,t,ans;
ll a,b,r,p,x,Mol,Den,res;//Mol是分子，Den是分母，（鬼畜的变量名
inline int read() {
    rgt int s=0;
    rgt char c=getchar();
    while(!isdigit(c)) c=getchar();
    while(isdigit(c)) s=(s<<1)+(s<<3)+c-'0',c=getchar();
    return s;
}
inline void Insert(rgt int x,rgt int y) {//插入，链式前向星
    nxt[++t]=head[x%N],head[x%N]=t;
    val[t]=x,num[t]=y;
}
inline int Search(rgt int x) {//查询，理论上是挺快的
    for(rgt int i=head[x%N];i;i=nxt[i])
        if(val[i]==x) return num[i];
    return -1;
}
inline ll Pow(rgt ll a,rgt int b) {//快速幂
    rgt ll res=1;
    while(b) {
        if(b&1) res=res*a%p;
        a=a*a%p,b>>=1;
    }
    return res;
}
inline void Init() {//初始化
    memset(head,0,sizeof(head)),t=0;//t用于链式前向星，原来的t代码中用r表示
    Mol=((r-r*a-b)%p+p)%p,Den=Pow(((x-a*x-b)%p+p)%p,p-2);//求出右边那一大串东东
    b=Mol*Den%p;//现在就变成了a^x≡b(mod p)
}
inline int BSGS() {
    Init();
    if(b==1) return 0;//有这个下文x==r的特判就可以省去
    rgt int i,j,t;
    t=sqrt(p)+1,res=b;
    for(i=0;i<t;i++) Insert(res,i),res=res*a%p;
    a=Pow(a,t),res=1;
    if(!a) return (!b)?1:-1;
    for(i=0;i<=t;i++) {
        j=Search(res);
        if(j>=0&&i*t-j>=0) return i*t-j;
        res=res*a%p;
    }
    return -1;
}
int main()
{
    T=read();
    while(T--)
    {
        p=read(),a=read(),b=read(),x=read(),r=read();
        if(x==r) {printf("1\n");continue;}
        if(a==1) {
            
            if(!b) printf("-1\n");
            else
            {
                r=((r-x)%p+p)%p;
                printf("%lld\n",r*Pow(b,p-2)%p+1);
            }
            continue;
        }
        if(!a) {
            if(b==r) printf("2\n");
            else printf("-1\n");
            continue;
        }
        ans=BSGS();
        if(~ans) printf("%d\n",ans+1);//答案记得+1
        else printf("-1\n");
    }
    return 0;
}
```





---

## 作者：qwaszx (赞：3)

讲道理这是我遇见过最毒瘤的细节题

我们来进行一波推导，期间要时刻注意限制条件.

首先有$x_i=\begin{cases}x_1&i=1\\(ax_{i-1}+b)\mod p&i>1\end{cases}$

换句话说$x_i\equiv a^{i-1}x_1+b\sum\limits_{i=0}^{i-2}a^i\pmod p$

...吗?

注意$0^0$在这里并没有意义，所以应当写成

$x_i\equiv \begin{cases}x_1[i=1]+b[i>1]&a=0\\a^{i-1}x_1+b\sum\limits_{k=0}^{i-2}a^k&a\neq 0\end{cases}$

现在我们想求一个$n$使得$x_n=t$，于是按照上面的东西讨论一下:

1. 如果$a=0$，$x_1=t$则$n=1$，否则如果$b=t$则$n=2$，否则无解

2. 如果$a\neq 0$，那么根据等比数列求和公式我们的式子看起来可以化成

$a^{n-1}x_1+\dfrac{b(a^{n-1}-1)}{a-1}\equiv t\pmod p$

然而这又是假的，等比数列求和公式只适用于$a\neq 1$的情况，所以我们应该写成

$t\equiv\begin{cases}a^{n-1}x_1+\dfrac{b(a^{n-1}-1)}{a-1}&a\neq 1\\x_1+b(n-1)&a=1\end{cases}$

$a=1$的话就变成同余方程了，于是又分两种情况

1. $b=0$，那么当$x_1=t$的时候有无穷解，否则无解.无穷解我们取$n=1$即可;

2. $b\neq 0$，那么解同余方程.我们知道同余方程有解的条件是$gcd(b,p)|t-x_1$，不过这里$b$是素数所以一定成立.直接拿逆元解即可.

$a\neq 1$的话，左右同乘$a-1$并整理得到$a^{n-1}(b+(a-1)x_1)\equiv (a-1)t+b\pmod p$.然后继续判断左边是否为$0$，不为$0$就跑一个$BSGS$就好了

拿$c++11$的$unordered_map$实现的，手写哈希表能快好几倍.

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<map>
#include<unordered_map>
using namespace std;
int T;long long a,b,x1,t,p;
long long qpower(long long a,long long b)
{
	long long ans=1;
	while(b){if(b&1)ans=ans*a%p;a=a*a%p;b>>=1;}
	return ans;
}
long long Inv(long long x){return qpower(x,p-2);}
unordered_map<long long,int> mp;
long long bsgs(long long a,long long b)
{
	int m=ceil(sqrt(p));
	mp.clear();
	for(int i=0;i<=m;i++)mp[b]=i,b=b*a%p;
	a=qpower(a,m);b=a;
	for(int i=1;i<=m;i++)
	{
		if(mp.count(b))return i*m-mp[b];
		b=b*a%p;	 
	}
	return -2;
}
int main()
{
	scanf("%d",&T);
	while(T--)
	{
		scanf("%lld%lld%lld%lld%lld",&p,&a,&b,&x1,&t);
		if(a==1)
		{
			t=(t-x1+p)%p;
			if(b==0){puts(t?"-1":"1");continue;}
			printf("%lld\n",t*Inv(b)%p+1);
			continue;
		}
		if(a==0)
		{
			if(t==b)puts("2");
			else if(t==x1)puts("1");
			else puts("-1");
			continue;
		}
		t=(t*(a-1)%p+b)%p;
		if((a*x1%p-x1+b+p)%p==0){puts(t?"-1":"1");continue;}
		printf("%lld\n",bsgs(a,t*Inv((a*x1%p-x1+b+p)%p)%p)+1);
	}
}
```

---

## 作者：winxp_qwq (赞：2)

听说这道题BSGS。。。

蒟蒻太菜啦，不会化式子！

但是其实真的可以直接用BSGS的思想来搞啊

具体来说，就是先预处理出sqrt(p)次之后，x会变成某个aax+bb的形式，这是大步。

x变为ax+b，这是小步。

从x开始一小步一小步变化，存进map里。

然后我们从结果t开始，每次反过来迈一大步，并查询map里有没有(由于懒得手写hash,我觉得map是BSGS的常规操作)，有就输出答案。最后都没有就gg了，输出-1。

最后。。。好像有些情况需要特判

时间复杂度nsqrt(n)，如果开map就再加一个log

(如果代码有问题，欢迎来hack)
```cpp
#include <bits/stdc++.h>
using namespace std;
#define LL long long
LL T;
LL p,A,B,X,t;
LL kasumi(LL a,LL b) {
    LL ans=1;
    while(b) {
        if(b&1) ans=ans*a%p;
        a=a*a%p;
        b>>=1;
    }
    return ans;
}
map <LL,LL> mp[100];
int main(){
    LL a,b,c,i,j,k;
    scanf("%lld",&T);
    for(i=1;i<=T;i++)
    {
        LL qwq=0;
        scanf("%lld%lld%lld%lld%lld",&p,&A,&B,&X,&t);
        j=ceil(sqrt(p));
        if(X==t) {printf("1\n");continue;}
        if(A==0) {
            if(B==t) printf("2\n");
            else printf("-1\n");
            continue;
        } 
        LL aa=1,bb=0;
        for(a=1;a<=j;a++)
        {
            aa=aa*A%p;
            bb=(bb*A+B)%p;
        }
        LL aaa=kasumi(aa,p-2);
        for(a=1;a<=j;a++) if(!mp[i].count(X)){
            mp[i][X]=a;
            X=(A*X+B)%p;
        }
        for(a=0;a<=j;a++)
        {
            if(mp[i].count(t)) {
                printf("%lld\n",a*j+mp[i][t]);
                qwq=1;
                break;
            }
            t=(t-bb+p)*aaa%p;
        }
        if(!qwq) printf("-1\n");
    }
    return 0;
}
```

---

## 作者：Huami360 (赞：1)

推导过程很详细的一篇

~~怎么这么多随机数生成器~~

很容易想到$BSGS$算法，但是递推式是$X_{i+1}=(aX_i+b)\mod p$，这显然不是一个等比数列。

但是可以用矩阵乘法来求出第$i$项，所以好像可以用$BSGS$套矩阵乘法？但是总要把那个常数项除过来吧，矩阵除法是什么鬼？

无奈只好放弃去看题解。
看完之后，哎，我太蒻了。

$$X_{i+1}=(aX_i+b)\mod p$$
$$X_{i+1}=a(X_i+\frac{b}{a})\mod p$$
$$X_{i+1}=(aX_i+\frac{ab}{a})\mod p$$
$$X_{i+1}=(aX_i+\frac{(a-1)b}{a-1})\mod p$$
$$X_{i+1}+\frac{b}{a-1}=(aX_i+\frac{ab}{a-1})\mod p$$
$$X_{i+1}+\frac{b}{a-1}=a(X_i+\frac{b}{a-1})\mod p$$
然后，你发现了什么？

没错，式子两边都有一个$X+\frac{b}{a-1}$。

把上面这个式子的左边再乘一个$a$就能得到$X_{i+2}+\frac{b}{a-1}$。

于是就有
$$X_n+\frac{b}{a-1}=a^{n-1}(X_1+\frac{b}{a-1})\mod p$$
$$\frac{X_n+\frac{b}{a-1}}{X_1+\frac{b}{a-1}}\equiv a^{n-1}\pmod p$$

左边的都是已知的，对左边有理数取余，然后就可以$BSGS$了，不会$BSGS$的戳[这里](https://www.cnblogs.com/Qihoo360/p/9546049.html)。

另外对$a=0,1$或者$X_1=t$要特判一下。

代码见[博客](https://www.cnblogs.com/Qihoo360/p/9613926.html)

---

## 作者：Iscream2001 (赞：1)

这道题只是求一条式子：


x\*a^y+b\*(a^(y-1)+a(y-2)……+a^(1)+a^(0)) Ξ t (mod p)


式中x，a，b，t，p如题意，y表示过去的天数(0<=y<p),只要求出y即可。


（注意：y是已过去的天数，天数从1算起，故应输出y+1）


式子看起来很复杂，实际上这条式子可以简化：


x\*a^y+b\*((a^(y)+a^(y-1)+...+a^(1))-(a^(y-1)+a(y-2)……+a^(1)+a^(0)))/(a-1) Ξ t (mod p)


x\*a^y+b\*(a^(y)-a^(0))/(a-1) Ξ t (mod p)


这样一来未知数y的多项式就被简化了，实际上我们发现由于等式两边都是余数，故可以先求b/(a-1)对于p的余数。


设b2=b/(a-1)%p=b\*(a-1)^(p-2)%p；


则原式    (x+b2)\*a^yΞ t+b2 （mod p）


再用同样套路移项a^yΞ (t+b2)\*(x+b2)^(p-2) （mod p）


之后就是经典的BSGS算法了。。。

代码
#pragm\

 
```cpp
a GCC optimize(2)/*在洛谷上提交建议开O2优化*/
#include<iostream>
#include<cmath>
#include<map>
#include<cstdio>
#define LL long long
using namespace std;
map<LL,int> mp;
LL p,a,b,x,t;
LL pow(LL y,LL z){
    LL s;
    if(z==0) return 1;
    s=pow(y,z/2);
    s=s*s%p;
    if(z&1) s=s*y%p;
    return s;
}
LL gcd(LL y,LL z){
    if(y==0) return z;
    return gcd(z%y,y);
}
int main(){
    int T;
    LL i,j,m,ans,s;
    scanf("%d",&T);
    while(T--){
        scanf("%lld%lld%lld%lld%lld",&p,&a,&b,&x,&t);
        if(x==t){
            printf("1\n");
            continue;
        }
        if(a==0){
            if(b==t) printf("2\n");
            else printf("-1\n");
            continue;
        }
        if(a==1){
            t=(t-x+p)%p;
            LL e=gcd(b,p);
            if(t%e){
                printf("-1\n");
                continue;
            }
            printf("%lld\n",(t*pow(b,p-2))%p+1);
        }
        else{
            mp.clear();
            b=(b*pow(a-1,p-2))%p;
            t=(t+b)%p;
            x=(x+b)%p;
            t=(t*pow(x,p-2))%p;
            m=ceil(sqrt(p));
            mp[t]=0;
            j=1;i=1;
            for(j=1;j<=m;j++){
                t=t*a%p;
                mp[t]=j;
            }
            s=pow(a,m);ans=1;
           int flag=0;
          for(i=1;i<=m;i++){
            ans=ans*s%p;
            if(mp[ans]){
                printf("%lld\n",(i*m-mp[ans]+p)%p+1);
                flag=1;
                break;
            }
        }
        if(flag==0) printf("-1\n");
        }
    }
    return 0;
}
```

---

## 作者：MrMorning (赞：0)

#题目大意

给定递推序列：

F[i] = a\*F[i-1] + b (mod c)

求一个最小的i使得F[i] == t


#题解

我们首先要化简这个数列，作为一个学渣，我查阅了一些资料：

http://d.g.wanfangdata.com.cn/Periodical\_cczl200924107.aspx

http://wenku.baidu.com/view/7162471b650e52ea5518982d.html

推一下，就有：

F[i] = (F[1] + b / (a-1)) \* a ^ (i-1) - b / (a-1)；

令F[i] = t;

可以知道:

a^(i-1) = (t+b/(a-1)) / (x1+b/(a-1))

对于这个式子，我们直接调用BSGS算法求解即可。

特别的，某些情况需要特判。


#代码

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll p, a, b, X1, t, T;
ll pow(ll a, ll b, ll p) {
    ll ans = 1;
    while(b) {
        if(b & 1) ans = ans * a % p;
        b >>= 1;
        a = a * a % p;
    }
    return ans;
}
ll inv(ll a, ll p) {
    return pow(a, p-2, p);
}
map<ll, ll> mp;
ll BSGS(ll A, ll B, ll C) {
    mp.clear();
    if(A % C == 0) return -2;
    ll m = ceil(sqrt(C));
    ll ans;
    for(int i = 0; i <= m; i++) {
        if(i == 0) {
            ans = B % C;
            mp[ans] = i;
            continue;
        }
        ans = (ans * A) % C;
        mp[ans] = i;
    }
    ll t = pow(A, m, C); 
    ans = t;
    for(int i = 1; i <= m; i++) {
        if(i != 1)ans = ans * t % C;
        if(mp.count(ans)) {
            int ret = i * m % C - mp[ans] % C;
            return (ret % C + C)%C;
        }
    }
    return -2;
} 
int main() {
   // freopen("input", "r", stdin);
    scanf("%lld", &T);
    while(T--) {
        scanf("%lld %lld %lld %lld %lld", &p, &a, &b, &X1, &t);
        if(X1 == t) {
            printf("%d\n", 1);
            continue;
        }
        if(a == 0) {
            if(t == b) {
                printf("%d\n", 2);
            }
            else printf("%d\n", -1);
            continue;
        }
        if(a == 1) {
            if(b == 0) {
                printf("%d\n", -1);
                continue;
            }
            ll ans = (((t-X1)%p + p)%p * inv(b, p)) % p;
            printf("%lld\n", ans+1);
            continue;
        }
        X1 %= p, a %= p, b %= p, t%= p;
        ll tmp = (b%p * inv(a-1, p))%p;
        ll B = ((t+tmp)%p * inv((X1+tmp) % p, p)) % p;
        ll A = a;
        ll ans = BSGS(A, B, p);
        printf("%lld\n", ans+1);
    }
    return 0;
}
```

#广告：

推广一下蒟蒻的blog:

cnblogs.com/gengchen


---


# [THUPC 2025 初赛] 检查站

## 题目描述

小 I 是一个巨大的铁路公司的主管，他管理着 $n$ 个火车站，用 $1$ 至 $n$ 的整数给它们编号。铁路公司有 $c$ 个分部，第 $i$ 个分部的办公室位于火车站 $p_i$。可能有火车站没有分部办公室，一个火车站也有可能有多个分部办公室。

$n$ 个火车站之间由 $m$ 条单向铁路连接，其中第 $i$ 条铁路由火车站 $u_i$ 连向 $v_i$，属于分部 $r_i$ 管辖。为了保证管理方便，分部 $r_i$ 的办公室要么在 $u_i$，要么在 $v_i$。

火车站 $1$（港口）和 $n$（首都）是公司管辖范围内最繁忙的车站。为了保障进口货物安全，根据交通运输部的要求，小 I 需要在一些铁路上设立检查站，使得从火车站 $1$ 到火车站 $n$ 的所有可能路线上都有一个有检查站的铁路。

小 I 可以通知一些分部（也可以不通知任何分部），要求这些分部在它们管理的所有铁路上设立检查站。小 I 想知道，最少需要通知多少个分部才可以达到要求。作为新上任的算法工程师，你准备给小 I 露一手。

## 说明/提示

### 样例解释

该样例的铁路组织如下图所示，其中红色、绿色和黑色分别为 1、2、3 分部管辖的铁路。最优策略是通知分部 1 和 3。

![](https://cdn.luogu.com.cn/upload/image_hosting/yami1v28.png)

### 题目来源

题目来自 THUPC2025（2025年清华大学学生程序设计竞赛暨高校邀请赛）初赛，信息来源于 [THUSAAC 仓库](https://gitlink.org.cn/thusaa/thupc2025pre)。


## 样例 #1

### 输入

```
5 10 3
3 1 4
1 3 1
4 3 1
3 2 1
3 5 1
1 2 2
2 1 2
1 4 2
5 1 2
1 4 3
4 5 3```

### 输出

```
2```

# 题解

## 作者：Pengzt (赞：8)

# 检查站

[题目链接](https://www.luogu.com.cn/problem/P11531)。[cnblogs](https://www.cnblogs.com/Pengzt/p/18660252)。

### Problem

小 I 是一个巨大的铁路公司的主管，他管理着 $n$ 个火车站，用 $1$ 至 $n$ 的整数给它们编号。铁路公司有 $c$ 个分部，第 $i$ 个分部的办公室位于火车站 $p_i$。可能有火车站没有分部办公室，一个火车站也有可能有多个分部办公室。

$n$ 个火车站之间由 $m$ 条单向铁路连接，其中第 $i$ 条铁路由火车站 $u_i$ 连向 $v_i$，属于分部 $r_i$ 管辖。为了保证管理方便，分部 $r_i$ 的办公室要么在 $u_i$，要么在 $v_i$。

火车站 $1$（港口）和 $n$（首都）是公司管辖范围内最繁忙的车站。为了保障进口货物安全，根据交通运输部的要求，小 I 需要在一些铁路上设立检查站，使得从火车站 $1$ 到火车站 $n$ 的所有可能路线上都有一个有检查站的铁路。

小 I 可以通知一些分部（也可以不通知任何分部），要求这些分部在它们管理的所有铁路上设立检查站。小 I 想知道，最少需要通知多少个分部才可以达到要求。作为新上任的算法工程师，你准备给小 I 露一手。

数据范围：$2 \le n, m, c \le 5\times 10^4$。

### Sol

这个东西感觉很能想到网络流啊，数据范围这么尴尬。

原问题显然不弱于最小割。当每个分部至多管辖一条边的时候，就是权为 $1$ 的最小割。

考虑最小割。割掉一个分部可以干掉所有通过它连出去和连进来的边。但是这里是割一个点，把点拆成入点和出点即可。然后出点连向所有通过该分部出去的边的 $v$，所有通过该分部连进去的边的 $u$ 连向入点即可。

具体的连边方式：

点 $i \in [1, n] \cap \mathbb{Z}$ 表示原图中的点，$[n + 1, n + c] \cap \mathbb{Z}$ 与 $[n + c + 1, n + c + c] \cap \mathbb{Z}$ 分别表示分部的入点与出点。

对于分部 $i$，连边 $(p_i, n + i, +\infty), (n + c + i, p_i, +\infty), (n + i, n + c + i, 1)$。

对于边 $(u, v, r)$（$u \ne v$）：

+ 若 $p_r = u$：连边 $(n + c + r, v, +\infty)$。
+ 否则连边 $(u, n + r, +\infty)$。

求以 $1$ 为源，$n$ 为汇的最小割。

时间复杂度不是很会分析/ng。能过就行。

### Code

```
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
#define fi first
#define se second
mt19937_64 eng(time(0) ^ clock());
template<typename T>
T rnd(T l, T r) { return eng() % (r - l + 1) + l; }
struct Flow {
	const ll inf = 1e18;
	int n, S, T;
	struct node {
		int v; ll w; int b;
		node(int _v, ll _w, int _b) {
			v = _v, w = _w, b = _b;
		}
	};
	vector<vector<node>> e;
	vector<int> dis, cur, q;
	Flow(int _n) : e(_n + 10), dis(_n + 10), cur(_n + 10), q(_n + 10) {
		n = _n;
	}
	void adde(int u, int v, ll w) {
		// cout << u << " " << v << " " << w << "\n";
		e[u].emplace_back(v, w, (int)e[v].size());
		e[v].emplace_back(u, 0, (int)e[u].size() - 1);
	}
	int hd, tl;
	bool bfs() {
		for(int i = 0; i <= n; ++i) dis[i] = cur[i] = 0;
		q[hd = tl = 1] = S;
		dis[S] = 1;
		while(hd <= tl) {
			int u = q[hd++];
			for(auto i : e[u]) {
				int v = i.v;
				if(i.w && !dis[v]) {
					dis[v] = dis[u] + 1;
					q[++tl] = v;
					if(i.v == T) return 1;
				}
			}
		}
		return 0;
	}
	ll dfs(int u, ll flow) {
		if(u == T) return flow;
		ll res = 0;
		for(int &i = cur[u]; i < (int)e[u].size(); ++i) {
			int v = e[u][i].v;
			if(e[u][i].w && dis[v] == dis[u] + 1) {
				ll fl = dfs(v, min(flow, e[u][i].w));
				e[u][i].w -= fl, e[v][e[u][i].b].w += fl;
				flow -= fl, res += fl;
				if(!flow) return res;
			}
		}
		return res;
	}
	ll maxflow(int _S, int _T) {
		S = _S, T = _T;
		ll res = 0;
		while(bfs()) res += dfs(S, inf);
		return res;
	}
};
int n, m, c;
int p[100005];
int main() {
	scanf("%d%d%d", &n, &m, &c);
	Flow G(n + c + c);
	for (int i = 1; i <= c; i++)
		scanf("%d", p + i), G.adde(p[i], n + i, 1e9), G.adde(n + i + c, p[i], 1e9), G.adde(n + i, n + i + c, 1);
	for (int i = 1, u, v, r; i <= m; i++) {
		scanf("%d%d%d", &u, &v, &r);
		if (u == v)
			continue;
		if (p[r] == u)
			G.adde(n + r + c, v, 1e9);
		else if (p[r] == v)
			G.adde(u, n + r, 1e9);
	}
	cout << G.maxflow(1, n) << "\n";
	return 0;
}
```

---

## 作者：xixisuper (赞：7)

# P11531 [THUPC2025 初赛] 检查站 题解

~~鲜花：考场上两名队友在开考 2h 时开始死磕这道题，磕到最后一无所有，本人当时太菜，没学网络流，今重新读题做题，25min 切掉了本题，不知道考场上他俩在想什么。~~

## 思路

注意到问题可以看成最小割模型，即通过花费一定的代价割掉一些边，把点集分成两个不相交的子集，令 $1$ 号节点和 $n$ 号节点分别处于不同的两个部分，求最少需要的花费。

考虑建模，题目要求的是把分部割掉，并花费 $1$ 的代价，所以我们考虑把分部拆成两个节点，一个节点只负责接入边，另一个节点只负责接出边。**对于第 $i$ 个分部，我们称其直接入边的节点叫做 $I_i$，只接出边的节点叫做 $O_i$，并连接一条 $I_i\to O_i$ 且容量为 $1$ 的边。**

对于题面当中的一条铁轨来说，我们这样进行连边：

- 连接一条 $u\to I_r$ 且容量为 $+\infin$ 的边。
- 连接一条 $O_r\to v$ 且容量为 $+\infin$ 的边。

然后在这个网络图上跑 Dinic 就可以了。

### 建模正确性论证

我们来论证一下上述建模方法的正确性，简单地说，我们希望找到一种建模方式，**使得删掉一个分部之后，所有由该分部控制的铁轨都断掉，并且该建模方式不影响原图的连通性。**

采用上述建模方式，第一点要求是显然能够满足的，因为割掉 $I_i\to O_i$ 这条边后，所有由 $i$ 控制的铁路肯定都断了。考虑第二点要求，由于题目当中说 $p_r=u$ 或者 $p_r=v$ 必然满足其一，所以可能产生的不在原图中的铁轨有且仅有 $p\to p$ 这种环，但是这种环显然对连通性没有任何影响，所以直接这么建模就是对的。


## 代码

```cpp
#include <iostream>
#include <algorithm>
#include <queue>
#define ll int
using namespace std;
const ll N=2e5+10;
const ll M=N<<2;
const ll INF=2147483647;
struct node{ll v,S,nxt;}e[M];
ll head[N],tot=1;
void add_edge(ll from,ll to,ll C){
	e[++tot]={to,C,head[from]};
	head[from]=tot;
}
//1~n station
//n+1~n+c part_in
//n+c+1~n+2c part_out 
ll n,m,c,pt=n,pls[N],S,T;
ll cur[N],dep[N];
bool bfs(){
	for(ll i=1;i<=n+2*c;i++) dep[i]=0;
	queue<ll> qu;
	qu.push(S);dep[S]=1;
	while(!qu.empty()){
		ll v,now=qu.front();qu.pop();
		for(ll i=head[now];i;i=e[i].nxt){
			v=e[i].v;
			if(dep[v]||!e[i].S) continue;
			dep[v]=dep[now]+1;
			if(v==T) return 1;
			qu.push(v);
		}
	}
	return 0;
}
inline ll dfs(ll now,ll MX){
	if(T==now) return MX;
	ll sum=0,linO,v;
	for(ll i=cur[now];i;i=e[i].nxt){
		cur[now]=i;v=e[i].v;
		if(dep[v]!=dep[now]+1||!e[i].S) continue;
		linO=dfs(v,min(MX,e[i].S));
		e[i].S-=linO,e[i^1].S+=linO;
		MX-=linO,sum+=linO;
		if(!MX) break; 
	}
	if(!sum) dep[now]=0;
	return sum;
}
ll Dinic(){
	ll ret=0;
	while(bfs()){
		for(ll i=1;i<=n+2*c;i++) cur[i]=head[i];
		ret+=dfs(S,INF);
	}
	return ret;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n>>m>>c;
	S=1,T=n;
	for(ll i=n+1;i<=n+c;i++) add_edge(i,i+c,1),add_edge(i+c,i,0);
	for(ll i=1;i<=c;i++) cin>>pls[i];
	for(ll i=1;i<=m;i++){
		ll u,v,r;
		cin>>u>>v>>r;
		add_edge(u,r+n,INF);add_edge(r+n,u,0);
		add_edge(n+c+r,v,INF);add_edge(v,n+c+r,0);
	}
	cout<<Dinic();
	return 0;
} 
```

---

## 作者：Mr_Az (赞：4)

# [P11531 [THUPC 2025 初赛] 检查站](https://www.luogu.com.cn/problem/P11531)

### Algorithm:

网络流（最小割）。

### Solution:

为什么我这么*，赛时没切。还有这个 $p$ 数组有什么用？其实这道题怎么看都很像网络流，但是在初赛的时候一直在考虑图论做法，没有什么想法。后来去写别的题目就没管了，后悔。

这道题相当于把这个分部控制的边全部断掉，问要断多少个分部才能使 $1 \to n$ 不连通，显然是一个最小割问题，我们把断一个分部转化为断一条边（点转边），经典的处理手段。所以我们只需要对 $(u,v,r)$ 的边处理为：$u \to r_{in} \to r_{out} \to v$。

时间复杂度：$\text{O}(m\sqrt{m})$。

### Code:

```cpp
int tot=1;
int head[M];
struct edge{int nxt,to,val;}e[M*2];
inline void addd(int u,int v,int w){e[++tot]={head[u],v,w};head[u]=tot;}
inline void add(int u,int v,int w){addd(u,v,w);addd(v,u,0);}
namespace dinic{
	int s,t,maxflow,flow;
	int h[M],dep[M];
	inline bool bfs(){
		mem(dep,0);
		queue<int> q;
		q.push(s);h[s]=head[s];dep[s]=1;
		while(q.size()){
			auto u=q.front();q.pop();
			for(rint i=head[u];i;i=e[i].nxt){
				int v=e[i].to;
				if(e[i].val&&(!dep[v])){
					dep[v]=dep[u]+1;
					q.push(v);
					h[v]=head[v];
					if(v==t) return 1;
				}
			}
		}
		return 0;
	}
	inline int dfs(int u,int flow){
		if(u==t) return flow;
		int now=flow;
		for(rint i=h[u];i&&now;i=e[i].nxt){
			int v=e[i].to;
			h[u]=i;
			if(e[i].val&&dep[v]==dep[u]+1){
				int k=dfs(v,min(now,e[i].val));
				if(!k) dep[v]=0;
				now-=k;
				e[i].val-=k;
				e[i^1].val+=k;
			}
		}
		return flow-now;
	}
	inline int dinic(int S,int T){
		s=S;t=T;
		maxflow=flow=0;
		while(bfs()) while(flow=dfs(s,INF)) maxflow+=flow;
		return maxflow;
	}
}// dinic 板子，要的可以拿走，目前使用下来没有任何问题
namespace Mr_Az{
	int T=1;
	int n,m,c,s,t;
	int p[N];
	inline int id(int i,int o){return n+1+2*(i-1)+o;}
	inline void solve(){
		read(n,m,c);
		s=1;t=n;
		for(rint i=1;i<=c;i++) read(p[i]);
		for(rint i=1;i<=c;i++) add(id(i,0),id(i,1),1);// r_in -> r_out
		for(rint i=1,u,v,r;i<=m;i++){
			read(u,v,r);
			add(u,id(r,0),inf);// u -> r_in
			add(id(r,1),v,inf);// r_out -> v
		}
		auto maxflow=dinic::dinic(s,t);
		printf("%lld\n",maxflow);
	}
	inline void mian(){if(!T) read(T);while(T--) solve();}
}
```

---

## 作者：喵仔牛奶 (赞：4)

## Solution

每条边都属于独立的分部时，问题等价于最小割。故问题不弱于最小割，考虑网络流。

如下连边：
- 对每个分部建两个点 $x_{i,1},x_{i,2}$，连接 $(x_{i,1}\to x_{i,2})$，容量为 $1$，割掉它代表通知该分部。
- 对于一条边 $(u,v,r)$，连接 $(u,x_{r,1}),(x_{r,2},v)$，容量为 $1$。如果割了 $(u,x_{r,1}),(x_{r,2},v)$ 这些边，不如直接割掉 $(x_{r,1}\to x_{r,2})$，所以我们不会割掉这些边。

显然，割掉部门对应的边可以让所有 $r$ 为该部门的边失效。故 $1\to n$ 的最小割即为答案。

所有边权均为 $1$，dinic 只会增广 $\sqrt{m}$ 次，复杂度为 $\mathcal O(m\sqrt{m})$。

---

## 作者：mqmhaaaa1 (赞：2)

关于我在赛场被我当时的低脂板子卡常没 ac 这件事......

事实上是一道非常简单的题目（首先最小割看得出来吧）。

相信看完题目后我们发现，**边都是由分部支配的**，所以我们想割边就变成了割点。那我们又如何把分部当做点呢？

然后就有一种自然而然的想法，想要割掉一个分部的情况下把与它关系的所有边去除，怎么办？

# 做法

事实上很简单，我们要割点，先把每个分部拆成**出点**与**入点**（下文称点 $u$ 的入点为 $ui$，出点为 $uo$），$ui \to uo$ 容量为 $1$ 的边用来割没问题，再把每个原本的火车站当做点，每个火车站 $v$ 连每个办公室在它身上（好奇怪的说法）的分部 $u$ 两条边，分别为 $v \to ui$ 和 $uo \to v$ 流量为 $inf$。

对于每条边 $ x \to v$ 为 $u$ 分部管控，如果 $p_u=x$，连 $uo \to v$，否则，$p_u$ 一定等于 $v$，连 $x \to ui$（流量都为 $inf$）。

# 为什么

我们理解一下，我们把每个火车站看做是一个中转的点，当这个点有流量时，就会把流量传给在它身上的分部 $u$ 的 $ui$ 或者自己流到其他火车站分部入点，它的流量来自 $uo$ 或其他火车站分部出点。而所有分部流量来自自己火车站或其他火车站。

当我们割掉一个 $ui \to uo$ 时，与 $u$ 关联的所有边不能给这个车站和这个车站上其他的分部贡献流量，因为流不出去。而火车站就是可以把一些自己分部**出点**的流量给自己或给自己别的分部。当一个分部 $u$ 的 $ui \to uo$ 被割，它的 $uo$ 就没有流量了，就是与它关联的所有边和它与自己火车站的联系都无用了，理解下。

虽然这是个**奇奇怪怪的二分图**，但 dinic 复杂度还是 $O( \sqrt{n} m)$ 的，所以能过。

看看代码:


```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll int
inline void write(ll x) {static ll sta[35];ll top = 0;do {sta[top++] = x % 10, x /= 10;} while (x);while (top) putchar(sta[--top] + 48);}
inline ll read() {ll x = 0, w = 1;char ch = 0;while (ch < '0' || ch > '9') {  if (ch == '-') w = -1;ch = getchar();}while (ch >= '0' && ch <= '9') {x = x * 10 + (ch - '0'); ch = getchar(); }return x * w; }
const ll N=5e5+10,M=5e6+10,inf=0x3f3f3f3f;
ll to[M<<1],nxt[M<<1],w[M<<1],bh[N],tot=1;
ll head[N],st[N];
bool vis[N];
inline void add(ll u,ll v,ll z){
	to[++tot]=v;
	nxt[tot]=bh[u];
	w[tot]=z;
	bh[u]=tot;
//	cout<<u<<" "<<v<<" "<<z<<'\n';
	to[++tot]=u;
	nxt[tot]=bh[v];
	w[tot]=0;
	bh[v]=tot;
}
ll s,t;
inline bool bfs(){
	for(ll i=s;i<=t;i++){
		head[i]=bh[i];
		vis[i]=0;
		st[i]=0;
	}
	queue<ll>q;
	q.push(s);
	st[s]=0;vis[s]=1;
	while(q.size()){
		ll u=q.front();q.pop();
//		cout<<u<<'\n';
		vis[u]=0;
		for(ll i=bh[u];i;i=nxt[i]){
			ll v=to[i];
			if(w[i]&&!st[v]&&v!=s){
				st[v]=st[u]+1;
				if(!vis[v]){
					vis[v]=1;
					q.push(v);
				}
			}
		}
	}
	return st[t];
}
ll mxf=0;
ll dic(ll u,ll flow){
//	cout<<u<<" "<<flow<<'\n';
	vis[u]=1;
	if(u==t){
		mxf+=flow;return flow;
	}
	ll zy=0;
	for(ll i=head[u];i&&flow;i=nxt[i]){
		ll v=to[i];head[u]=i;
		if(w[i]&&(!vis[v]||v==t)&&st[v]==st[u]+1){
			ll jb=dic(v,min(w[i],flow));
			w[i]-=jb,w[i^1]+=jb;
			zy+=jb;flow-=jb;
			if(!flow)break;
		}
	}
	vis[u]=0;
	return zy;
}
ll n,m,c;
ll p[N];
int main(){
	n=read();m=read();c=read();
	s=0;t=c*2+n+1;
	add(s,1,inf);
	add(n,t,inf);
	for(ll i=1;i<=c;i++){
		p[i]=read();
		ll u=p[i];
		ll vi=n+i,vo=n+i+c;
		add(u,vi,inf);
		add(vo,u,inf);
		add(vi,vo,1);
	}
	for(ll i=1;i<=m;i++){
		ll u=read(),v=read(),r=read();
		if(r<=c){
			if(u==p[r]){
				ll uo=n+r+c,vi=v;
				add(uo,vi,inf);
			}else{
				ll vi=n+r,uo=u;
				add(uo,vi,inf);
			}
		}else{
			add(u,v,inf);
		}
	}
	while(bfs()){
		vis[t]=1;
		while(vis[t]){
			memset(vis,0,sizeof vis);
			dic(s,inf);
		}
	}
	cout<<mxf;
	return 0;
}
```

这里注意，这题有点卡常，所以建议好好看看我的板子。

还有，Echoes of Memoria 真好听（Ludicin 最棒了）。

---

## 作者：CarroT1212 (赞：2)

咋看都是个网络流题吧，建模搞个最小割出来。

相当于我们每次可以花费 $1$ 的代价割掉一个点的某些入边和某些出边。如何处理？

先考虑某种建法：建 $n$ 个点表示原图上的点，源点 $1$ 汇点 $n$。然后对于每个分部建入点 $x_i$ 出点 $y_i$。这个分部在它所在的点上管辖的有一些入边和一些出边，设分部管辖的入边连接了原图上的 $a_j$ 这些点，出边连了 $b_j$ 这些点。建模时把 $a_j$ 全部连向 $x_i$，$y_i$ 连向全部 $b_j$，容量均为无限。 $x_i\to y_i$ 自己连一条容量为 $1$ 的边。跑最小割。

这明显只能处理同时经过了受同一分部管辖的入边和出边的情况。如果是只经过了入边，然后在中转点换了一个分部走，或者是中间插进来，只经过了出边，这该如何办呢。

场上想到这卡住了，换上队友来做结果起手秒了，绷。

一个十分天才的想法是：我们在**原图中**每一个分部对应的点上加一个属这个分部的自环！

于是不走入边或者不走出边的情况被转化为走了一次这个点上的自环，这样再建模就可以了。复杂度是网络流的。

```cpp
namespace D {
	const ll N=2e5+7,M=6e5+7;
	ll n,m,s,t,mxf;
	ll f[M<<1];
	ll cur[N],dis[N];
	vector<pll> e[N];
	void ini(ll _n) {
		n=_n,m=1,mxf=0;
		for (ll i=0;i<=n;i++) vector<pll>().swap(e[i]);
	}
	void add(ll x,ll y,ll z) { f[++m]=z,e[x].pb({y,m}),f[++m]=0,e[y].pb({x,m}); }
	bool bfs() {
		for (ll i=0;i<=n;i++) dis[i]=J,cur[i]=0;
		queue<ll> q;
		q.push(s),dis[s]=0;
		while (!q.empty()) {
			ll p=q.front();
			q.pop();
			if (p==t) return 1;
			for (pll i:e[p]) if (f[i.se]&&dis[i.fi]>dis[p]+1)
				dis[i.fi]=dis[p]+1,q.push(i.fi);
		}
		return 0;
	}
	ll dfs(ll p,ll fl) {
		if (p==t) return fl;
		ll nf=0;
		for (ll ii=cur[p];ii<e[p].size();ii++) { pll i=e[p][ii];
			cur[p]=ii;
			if (f[i.se]&&dis[i.fi]==dis[p]+1) {
				ll cf=dfs(i.fi,min(fl-nf,f[i.se]));
				nf+=cf,f[i.se]-=cf,f[i.se^1]+=cf;
				if (fl==nf) return fl;
			}
		}
		return nf;
	}
	void din(ll _s=0,ll _t=n) { s=_s,t=_t; while (bfs()) mxf+=dfs(s,J); }
	void clr() { for (ll i=2;i<=m;i+=2) f[i]+=f[i^1],f[i^1]=0; mxf=0; }
}
ll n,m,c,a[N];
vector<ll> e[N],e1[N];
void mian() {
	scanf("%lld%lld%lld",&n,&m,&c);
	for (ll i=1;i<=c;i++) scanf("%lld",&a[i]);
	for (ll i=1,x,y,z;i<=m;i++) {
		scanf("%lld%lld%lld",&x,&y,&z);
		if (a[z]==x) e[z].pb(y);
		if (a[z]==y) e1[z].pb(x);
	}
	D::ini(n+c*2);
	for (ll i=1;i<=c;i++) {
		e[i].pb(a[i]),e1[i].pb(a[i]);
		D::add(n+i,n+c+i,1);
		for (ll j:e[i]) D::add(n+c+i,j,J);
		for (ll j:e1[i]) D::add(j,n+i,J);
	}
	D::din(1,n);
	cout<<D::mxf;
}
```

---

## 作者：ty_mxzhn (赞：1)

## 题目描述

小 I 是一个巨大的铁路公司的主管，他管理着 $n$ 个火车站，用 $1$ 至 $n$ 的整数给它们编号。铁路公司有 $c$ 个分部，第 $i$ 个分部的办公室位于火车站 $p_i$。可能有火车站没有分部办公室，一个火车站也有可能有多个分部办公室。

$n$ 个火车站之间由 $m$ 条单向铁路连接，其中第 $i$ 条铁路由火车站 $u_i$ 连向 $v_i$，属于分部 $r_i$ 管辖。为了保证管理方便，分部 $r_i$ 的办公室要么在 $u_i$，要么在 $v_i$。

火车站 $1$（港口）和 $n$（首都）是公司管辖范围内最繁忙的车站。为了保障进口货物安全，根据交通运输部的要求，小 I 需要在一些铁路上设立检查站，使得从火车站 $1$ 到火车站 $n$ 的所有可能路线上都有一个有检查站的铁路。

小 I 可以通知一些分部（也可以不通知任何分部），要求这些分部在它们管理的所有铁路上设立检查站。小 I 想知道，最少需要通知多少个分部才可以达到要求。作为新上任的算法工程师，你准备给小 I 露一手。

数据范围：$n,m,c\le 5\times 10^4$。

## 题解

题意可以看成你可以断掉一些分部的铁路上的边，问让 $1,n$ 不连通最少断几个分部，分部是一个菊花。

假设每个分部只管一个边那么显然可以直接最小割求解。

考虑建虚点。对于每个点拆成（原点，入点，出点）三个点。

原点连入点 $+\infty$ 入点连出点 $1$ 出点连原点 $+\infty$ 这三条边是好理解的。

对于一条读入的边对应着连边就好了。

时间复杂度可能和二分图匹配是一样的吧，大概是 $O(n\sqrt{m})$ 这样。不过你做流题管什么复杂度，除非是什么东西优化流。

---

## 作者：yedalong (赞：1)

## Solution

这道题和 [P1345 奶牛的电信](https://www.luogu.com.cn/problem/P1345)很像，最主要的关键就是如何将最小割由割的是边转化为割的是点。

有一种思想，叫做拆点。将分部拆成两个点，两点之间由一条边权为 $1$ 的边相连。那么我们建图时将 $u_i$ 和 $v_i$ 都与 $r_i$ 相连，相当于建立了一种关系，当我们割掉 $r_i$ 后，$u_i$ 和 $v_i$ 就无法通过 $r_i$ 相连，就相当于放了检查点。

那么关系的边权是多少呢？其实很容易想到，我们要建的是一种关系，而非实际意义上的一条边，因此将其设为极大值最好了，这样在跑最小割的过程就不会割掉它，影响结果了。

建边其实还有一些小细节，就是拆成的两个点一个用于建入边，一个用于建出边，负责建入边的点可以通过他们之间的边到达负责建出边的点上，毕竟我们建的图可是有向图啊，不然没让它连通那还叫关系吗？

## AC code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long 
struct node{
	int u,v,cap,flow;
};
int n,m,c,p[50005],u,v,w,deep[150005],flag[150005];
vector<node> edges;
vector<int> e[150005];
void add(int u,int v,int w){
	edges.push_back({u,v,w,0});
	edges.push_back({v,u,0,0});
	int tmp=edges.size();
	e[u].push_back(tmp-2);
	e[v].push_back(tmp-1);
}
bool bfs(){
	memset(deep,-1,sizeof(deep));
	deep[1]=0;
	queue<int> q;
	q.push(1);
	while(!q.empty()){
		int u=q.front();
		q.pop();
		for(auto to:e[u]){
			int v=edges[to].v;
			if(deep[v]==-1&&edges[to].cap>edges[to].flow){
				deep[v]=deep[u]+1;
				q.push(v);
			}
		}
	}
	return deep[n]!=-1 ;
}
int dfs(int u,int mf){
	if(u==n) return mf;
	int len=e[u].size(),sum=0;
	for(int i = flag[u];i<len;i++){
		node edge=edges[e[u][i]];
		flag[u]=i;
		int v=edge.v;
		if(deep[u]==deep[v]-1&&edge.cap>edge.flow){
			int tmp=dfs(v,min(edge.cap-edge.flow,mf));
			sum+=tmp;
			mf-=tmp;
			edges[e[u][i]].flow+=tmp;
			edges[e[u][i]^1].flow-=tmp;
			if(!mf) break;
		}
	}
	if(!sum) deep[u]=-1;
	return sum;
}
void dinic(){
	int ans=0;
	while(bfs()){
		memset(flag,0,sizeof(flag));
		ans+=dfs(1,1e18);
	}
	cout<<ans;
}
void input(){
	cin>>n>>m>>c;
	for(int i = 1;i<=c;i++) cin>>p[i],add(i+n,i+n+c,1);
	for(int i = 1;i<=m;i++) cin>>u>>v>>w,add(u,w+n,1e9),add(w+n+c,v,1e9);
}
signed main(){
	input();
	dinic();
} 
```

所以题目给出的 $p_i$ 到底有什么用啊！

---

## 作者：born_to_sun (赞：1)

和别的题解不同的建模方法。

在尝试了各种图论中的算法都无法解决问题后，你想到了网络流。

进一步想，那应该就是最小割了。

考虑对每个检查站拆点为入点和出点，分别记为 $I_i,O_i$。

连边如下：

+ $I_i\rightarrow O_i$ 容量为 $1$
+ $p_i\rightarrow I_i$ 容量为 $+\infty$
+ $O_i\rightarrow p_i$ 容量为 $+\infty$

对于给定的 $m$ 条边，如果检查站在 $u$，连边 $O_i\rightarrow v$，否则连边 $u\rightarrow I_i$，自环不连边。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=4e5+5;
const int S=2e6+5;
const int inf=1e9;
int n,m,k;
int head[N],len=1;
struct E{
	int to,next,w;
}e[S];
void add(int u,int v,int w){
	e[++len]=E{v,head[u],w};head[u]=len;
	e[++len]=E{u,head[v],0};head[v]=len;
}
int a[N];
int s,t;
int cur[N],dis[N];
int bfs(){
	for(int i=1;i<=t;i++) cur[i]=head[i],dis[i]=inf;
	dis[s]=0;
	queue<int> q;q.push(s);
	while(q.size()){
		int u=q.front();q.pop();
		for(int i=head[u];i;i=e[i].next){
			int v=e[i].to,w=e[i].w;
			if(w&&dis[v]>dis[u]+1){
				dis[v]=dis[u]+1;
				q.push(v);
				if(v==t) return 1;
			}
		}
	}return 0;
}
int dfs(int u,int rs){
	if(u==t) return rs;
	int ans=0;
	for(int i=cur[u];i;i=cur[u]=e[i].next){
		int v=e[i].to,w=e[i].w;
		if(w&&dis[v]==dis[u]+1){
			int d=dfs(v,min(rs,w));
			rs-=d;ans+=d;
			e[i].w-=d;
			e[i^1].w+=d;
			if(!rs) return ans;
		}
	}return ans;
}
int flow(){
	int ans=0;
	while(1){
		if(!bfs()) return ans;
		ans+=dfs(s,inf);
	}
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>m>>k;
	int c=max(n,k);
	s=c*3+1;t=s+1;
	add(s,c*2+1,inf);
	add(c*2+n,t,inf);
	for(int i=1;i<=k;i++){
		cin>>a[i];
		add(i,i+c,1);
		add(a[i]+c*2,i,inf);
		add(i+c,a[i]+c*2,inf);
	}
	for(int i=1;i<=m;i++){
		int u,v,id;cin>>u>>v>>id;
		if(u==v) continue;
		if(a[id]==u) add(id+c,v+2*c,inf);
		else add(u+2*c,id,inf);
	}
	cout<<flow();
	return 0;
}
```

---

## 作者：Walrus (赞：1)

## 前言

先手膜拜此题赛时 first blood 大佬 @paper_。

赛时跟着 @paper_ 队伍后面写了若干分钟网络流，中途去吃饭想了若干做法未果后又转回网络流。

---

发现 $N,M\leq 5\times 10^4$，感觉 Dinic 不太好过。

由于是从 $1\to N$ 的所有路径上都必须有检查站故考虑将源汇点直接弄成这两个，又因为管理某一条边的点的办公室一定在某一个端点上，于是第一眼是考虑将一条边连成 $S-V-T$ 的形式，其中 $S,T$ 是两个端点，$V$ 是检查站编号，但是发现这样连的话要怎么割边才能满足题意？割掉一条的话相当于只是覆盖了 $S\to T$ 这条边，如果其他边想用这个检查站怎么办？

于是这里有一个经典的 trick 就是拆点，将每个检查站拆成入点和出点（假设为 $S',T'$），我们如果割掉这两个点之间的边相当于就是通知这个检查站，并且所有经过这条边（也即这个检查站出入点之间的边）会全部被覆盖，满足题意。我们为了防止其它非上述性质的边被割掉于是我们就将 $S\to S'$ 流量设为 $inf$，另一边同理。

然后跑一遍 Dinic 求出最小割即可。

总结连边方式：

- 对于每一个检查站 $P$，拆成入点和出点两个点且两个点间连容量为 $1$ 的边，表示割掉这条边后相当于通知了这个检查站。

- 对于每条边 $S\to T$，$S$ 向管理其的检查站的入点容量为 $inf$ 的边，其出点向 $T$ 连容量为 $inf$ 的边。

时间复杂度就是 Dinic 的复杂度。

code

```cpp
#include <bits/stdc++.h>
#define FASTIO ios::sync_with_stdio(0), cin.tie(nullptr), cout.tie(nullptr);
#define rep(i, j, k) for(int i = j; i <= k; ++i)
#define pre(i, j, k) for(int i = j; i >= k; --i)
#define pb push_back
#define PII pair<int, int>
#define fi first
#define se second
#define int long long
#define inf 0x3fffffff
#define repx(i, x) for(int i = head[x]; i; i = nxt[i])

using namespace std;
const int N = 4e5 + 5;

namespace ADD_EDGE {
	int nxt[N], head[N], val[N], to[N], tot = 1;

	void add(int u, int v, int w) {
		to[++tot] = v, val[tot] = w, nxt[tot] = head[u], head[u] = tot;
		to[++tot] = u, val[tot] = 0, nxt[tot] = head[v], head[v] = tot;
	}
}

using namespace ADD_EDGE;

int dis[N], vis[N], now[N], p[N], b[N];
int n, m, k, s, t, u, v, w, res;

bool bfs() {
	rep(i, 0, N - 1) dis[i] = inf;
	queue<int> q; q.push(s);
	dis[s] = 0, now[s] = head[s];
	while(q.size()) {
		int u = q.front(); q.pop();
		repx(i, u) {
			int v = to[i];
			if(val[i] > 0 && dis[v] == inf) {
				q.push(v);
				now[v] = head[v]; dis[v] = dis[u] + 1;
				if(v == t) return true;
			}
		}
	}
	return false;
} 

int dfs(int x, int sum) {
	if(x == t) return sum;
	int k = 0, res = 0;
	repx(i, x) {
		if(!sum) break;
		now[x] = i; int y = to[i];
		if(val[i] > 0 && dis[y] == dis[x] + 1) {
			k = dfs(y, min(sum, val[i]));
			if(k == 0) dis[y] = inf;
			val[i] -= k, val[i ^ 1] += k;
			res += k, sum -= k;
		}
	}
	return res;
}

void Dinic() {
	while(bfs()) res += dfs(s, inf);
}

signed main() {
	FASTIO
	
	cin >> n >> m >> k;
	s = 1, t = n;
	rep(i, 1, k) cin >> p[i], add(i + n, i + n + k, 1);
	rep(i, 1, m) 
		cin >> u >> v >> w, add(u, w + n, inf), add(w + n + k, v, inf);
	Dinic();
	cout << res;
	return 0; 
}
```

---

## 作者：WorldMachine (赞：1)

一眼板子题。

把每条边染一种颜色就是最小割问题，这里是它的加强版，考虑网络流建模。

对于一种颜色 $c$，建立一条边权为 $1$ 的有向边 $(n+2c-1,n+2c)$，对于一条该种颜色的边 $(u,v)$，拆成两条边权为 $+\infty$ 的有向边 $(u,n+2c-1)$ 和 $(n+2c,v)$，然后跑 $1$ 到 $n$ 的最小割即可。Dinic 只会增广 $\mathcal O(\sqrt m)$ 次，时间复杂度为 $\mathcal O(m\sqrt m)$。

---

## 作者：Aurie (赞：1)

# P11531 [THUPC2025 初赛] 检查站【题解】

题面要求**通知最少的分部，使得火车站 $1$ 到火车站 $n$ 的所有可能路线上都有一个有检查站的铁路**，等价于**删除最少分部，使 $1$ 到 $n$ 不连通**。此时可以想到最小割算法。

在原图跑最小割显然是错误的，因为并不是每删一条边都有代价，所以要建一些辅助边。对于一个分部，删除其整个分部只有一的代价，所以可以把原图的边的流量都建成无穷，然后建 $c$ 个边也就是 $2c$ 个点代表所有的分部，流量均为 $1$。让同一个分部的每一条边中间都插入一条代表该分部的边，因为同一分部的所有边起点或终点都相同，所以让这些边都连在一条边上不会影响正确性。

## 代码（ISAP）

```cpp
#include<bits/stdc++.h>
using namespace std;
template<typename T>
void read(T &x){x=0;char ch=getchar();int f=1;while(!isdigit(ch)){if(ch=='-'){f=-1;}ch=getchar();}while(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}x*=f;}
template<typename T>
void print(const T &x){if(x>9){print(x/10);}putchar(x%10|0x30);}
template<typename T>
void printcs(const T &x){if(x<0){print(-x);}else{print(x);}putchar(' ');}
template<typename T>
void println(const T &x){if(x<0){print(-x);}else{print(x);}putchar('\n');}

const int N = 3e5+10,M = 4e5+10,INF = 0x3f3f3f3f;

int n,m,c,x,y,r,hd[N],ed[M],nxt[M],val[M],idx=1,s,t,now[N];
void add(int x,int y,int v){
    ed[++idx] = y;
    val[idx] = v;
    nxt[idx] = hd[x];
    hd[x] = idx;

    ed[++idx] = x;
    nxt[idx] = hd[y];
    hd[y] = idx;
}
int dis[N],gap[N];
void bfs(){
    queue<int> q;
    q.push(t);
    for(int i = 1;i<=n+c*2;++i)dis[i]=-1;
    dis[t] = 0;
    gap[0] = 1;
    while(q.size()){
        int u = q.front();
        q.pop();
        for(int i = hd[u];i;i=nxt[i]){
            int v = ed[i];
            if(~dis[v])continue;
            dis[v]=dis[u]+1;
            ++gap[dis[v]];
            q.push(v);
        }
    }
}
int dfs(int u,int flow){
    if(u==t)return flow;
    int tmp,sum=0;
    for(int i = now[u];i;i=nxt[i]){
        now[u ] = i;
        const int v = ed[i];
        if(val[i]>0&&dis[v]+1==dis[u]){
            tmp = dfs(v,min(val[i],flow));
            val[i]-=tmp;
            val[i^1]+=tmp;
            flow-=tmp;
            sum+=tmp;
            if(!flow)return sum;
        }
    }
    if(--gap[dis[u]]==0)dis[s]=n+c*2+1;
    ++dis[u];
    ++gap[dis[u]];
    return sum;
}
int ans = 0;
int main(){
    read(n),read(m),read(c);
    for(int i = 1;i<=c;++i){
        read(x);
        add(n+i,n+i+c,1);
    }
    for(int i = 1;i<=m;++i){
        read(x),read(y),read(r);
        add(x,r+n,1);//实际流量无需建成正无穷，建成 1 也是一样的，但跑的更快。
        add(r+n+c,y,1);
    }
    s=1;
    t=n;
    bfs();
    while(dis[s]<n+c*2){
        for(int i = 1;i<=n+c*2;++i){
            now[i] = hd[i];
        }
        ans+=dfs(s,INF);
    }
    print(ans);
    return 0;
}
```

---

## 作者：BrotherCall (赞：0)

赛时以为网络流时间复杂度不对，但是没想到更好的方法了，就只能硬着头皮交一发 $\text{Dinic}$，结果过了，看到绿色 $\textcolor{limegreen}{\texttt{Accepted}}$ 的时候直接跳起来了。

如果这题是每条边都各一种颜色的话，那就是网络流直接建原图，边权为 $1$，跑一边最小割。

现在就是把这个模型变成了，一个点的部分入边和出边是同一个颜色，那我们考虑把这同一个颜色的边缩成一条边。

缩边的方法为：遍历每一种颜色，比如颜色 $i$，建立两个新点，分别叫 $tp_{i,1}$ 和 $tp_{i,2}$，建边 $(tp_{i,1} , tp_{i,2} , 1)$。再遍历这种颜色的所有边 $u \to v$，建边 $(u , tp_{i ,1} , +\infin)$，$(tp_{i , 2} , v , +\infin)$。

这样建的意义在于，割掉这条边权为 $1$ 的边，相当于用 $1$ 的代价割掉了所有这个颜色的边。

最后跑一个源点为 $1$ 汇点为 $n$ 的网络流即可。

[Code](https://www.luogu.com.cn/paste/pzoon94l)

时间复杂度：$O(m \min(m^{\frac{1}{2}},n^{\frac{2}{3}}))$。

时间复杂度分析：[OI Wiki](https://oi-wiki.org/graph/flow/max-flow/#%E7%89%B9%E6%AE%8A%E6%83%85%E5%BD%A2%E4%B8%8B%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90)。

---

## 作者：2012_Zhang_ (赞：0)

## 题面描述
小 I 是一个巨大的铁路公司的主管，他管理着 $n$ 个火车站，用 $1$ 至 $n$ 的整数给它们编号。铁路公司有 $c$ 个分部，第 $i$ 个分部的办公室位于火车站 $p_i$。可能有火车站没有分部办公室，一个火车站也有可能有多个分部办公室。

$n$ 个火车站之间由 $m$ 条单向铁路连接，其中第 $i$ 条铁路由火车站 $u_i$ 连向 $v_i$，属于分部 $r_i$ 管辖。为了保证管理方便，分部 $r_i$ 的办公室要么在 $u_i$，要么在 $v_i$。

火车站 $1$（港口）和 $n$（首都）是公司管辖范围内最繁忙的车站。为了保障进口货物安全，根据交通运输部的要求，小 I 需要在一些铁路上设立检查站，使得从火车站 $1$ 到火车站 $n$ 的所有可能路线上都有一个有检查站的铁路。  
## 思路解析
~~相信大部分人都是看了标签才来做的，比如我。~~  
首先这是一道最小割的题。
- 套路一：拆点，将每个点拆成入点和出点。
- 套路二：对于每个分部，入点和出点连一条边权为 $1$ 的边，割去相当于不通知这个分部。

用这样的形式建边，求出最小割就行了。  
  
代码奉上：
## AC CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int inf=1e18;
const int maxn=5e5+5;
int head[maxn],to[maxn],val[maxn],nxt[maxn],dep[maxn],now[maxn];
int tot=1,n,m,s,t,g,c,p[maxn];
queue<int>q;
void add(int a,int b,int w){
	nxt[++tot]=head[a];
	to[tot]=b;
	val[tot]=w;
	head[a]=tot;
	nxt[++tot]=head[b];
	to[tot]=a;
	head[b]=tot;
}
bool bfs(){
	for(int i=1;i<=n+c+c;i++) dep[i]=inf;
	while(!q.empty()) q.pop();
	now[s]=head[s];
	dep[s]=0;
	q.push(s);
	while(!q.empty()){
		int x=q.front();
		q.pop();
		for(int i=head[x];i;i=nxt[i]){
			int y=to[i];
			if(val[i]>0&&dep[y]==inf){
				dep[y]=dep[x]+1;
				now[y]=head[y];
				q.push(y);
				if(y==t) return 1;
			}
		}
	}
	return 0;
} 
int dfs(int x,int sum){
	if(x==t) return sum;
	int cnt,ans=0;
	for(int i=now[x];i&&sum>0;i=nxt[i]){
		now[x]=i;
		int y=to[i];
		if(val[i]>0&&dep[y]-dep[x]==1){
			cnt=dfs(y,min(sum,val[i]));
			if(cnt==0) dep[y]=inf;
			val[i]-=cnt;
			val[i^1]+=cnt;
			sum-=cnt;
			ans+=cnt;
		}
	}
	return ans;
}
signed main(){
	int ans=0;
	cin>>n>>m>>c;
    s=c+c+1,t=c+c+n;
    for(int i=1;i<=c;i++){
        cin>>p[i];
        add(i,c+i,1);
        add(c+i,c+c+p[i],inf);
        add(c+c+p[i],i,inf);
    }
    for(int i=1;i<=m;i++){
        int x,y,r;
        cin>>x>>y>>r;
        if(p[r]==x) add(c+r,c+c+y,inf);
        else add(c+c+x,r,inf);
    }
	while(bfs())ans+=dfs(s,inf);
	cout<<ans;
	return 0;
}

---

## 作者：complete_binary_tree (赞：0)

注意到题目数据范围比较特殊，考虑网络流最小割。

考虑如何建图。

首先考虑拆点，把每个点拆成入点和出点，把该点管辖的所有入边连到入点，出边连到出点。

随后入点和出点连接一条容量为 $1$ 的边。这条边能被割掉。

然后再新建一个点来连接不是这个点管辖的边，把出点与这个点连接、这个点与入点连接，这两条边都不能割。

然后跑一遍 `Dinic` 即可。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e4*3,M=5e4*4;
struct Dinic{
	struct edge{
		int v,c,f,nxt;
	}e[M<<1];
	int cnt,n,m,s,t,head[N],now[N],c,p[N],ans,dep[N];
	bool vis[N];
	queue<int>q;
	inline void add(int u,int v,int c,int f){
		e[++cnt]={v,c,f,head[u]},head[u]=cnt;
	}
	inline void add2(int u,int v,int c){add(u,v,c,0),add(v,u,0,0);}
	inline void bfs(){
		memset(vis,0,sizeof vis),memset(dep,0,sizeof dep);
		q.push(s),vis[s]=1;
		for(int i=1;i<=c+c+n;++i)now[i]=head[i];
		while(q.size()){
			int u=q.front();q.pop();
			for(int i=head[u];i;i=e[i].nxt){
				if(vis[e[i].v]||e[i].f==e[i].c)continue;
				vis[e[i].v]=1,q.push(e[i].v),dep[e[i].v]=dep[u]+1;
			}
		}
	}
	int dfs(int u,int mx){
		//cerr<<u<<'\n';
		if(u==t)return mx;
		int sum=0;
		for(int i=now[u];i;i=e[i].nxt){
			now[u]=i;
			if(dep[u]+1!=dep[e[i].v]||e[i].c==e[i].f)continue;
			int flow=dfs(e[i].v,min(mx,e[i].c-e[i].f));
			sum+=flow,mx-=flow,e[i].f+=flow,e[i^1].f-=flow;
			if(!mx)break;
		}
		return sum;
	}
	inline void dinic(){
		while(1){
			//cerr<<1;
			bfs();
			int d=dfs(s,INT_MAX);
			if(d)ans+=d;
			else break;
		}
	}
	inline Dinic(){
		ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
		cnt=1;
		cin>>n>>m>>c;
		s=c+c+1,t=c+c+n;
		for(int i=1;i<=c;++i)cin>>p[i],add2(i,c+i,1),add2(c+i,c+c+p[i],5e5),add2(c+c+p[i],i,5e5);
		//1-c 入点 c+1-2c 出点 2c+1-2c+n 不受管辖
		for(int i=1;i<=m;++i){
			int u,v,w;
			cin>>u>>v>>w;
			if(p[w]==u)add2(c+w,c+c+v,5e5);
			else if(p[w]==v) add2(c+c+u,w,5e5);
		}
		dinic();
		cout<<ans<<'\n';
	}
}a;

int main() {
	ios::sync_with_stdio( 0 ), cin.tie( 0 ), cout.tie( 0 );
	return 0;
}
```

---


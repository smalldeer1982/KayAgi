# [蓝桥杯 2023 省 Java B] 魔法阵

## 题目描述

魔法师小蓝为了营救自己的朋友小 Q，来到了敌人布置的魔法阵。魔法阵可以看作是一幅具有 $N$ 个结点 $M$ 条边的无向图，结点编号为 $0, 1, 2, \dots, N-1$，图中没有重边和自环。敌人在每条边上都布置了陷阱，每条边都有一个伤害属性 $w$，每当小蓝经过一条边时就会受到这条边对应的 $w$ 的伤害。小蓝从结点 $0$ 出发，沿着边行走，想要到达结点 $N-1$ 营救小 $Q$。

小蓝有一种特殊的魔法可以使用，假设一条路径按照顺序依次经过了以下 $L$ 条边 $e_1, e_2, ..., e_L$（可以出现重复的边），那么期间小蓝受到的总伤害就是 $P = \displaystyle \sum_{i=1}^{L} w(e_i)$，$w(e_i)$ 表示边 $e_i$ 的伤害属性。如果 $L \geq K$，那么小蓝就可以从这 $L$ 条边当中选出连续出现的 $K$ 条边 $e_c, e_{c+1}, \dots, e_{c+K-1}$ 并免去在这 $K$ 条边行走期间所受到的伤害，即使用魔法之后路径总伤害变为 $P' = P - \displaystyle \sum_{i=c}^{c+K-1} w(e_i)$。注意必须恰好选出连续出现的 $K$ 条边，所以当 $L < K$ 时无法使用魔法。

小蓝最多只可以使用一次上述的魔法，请问从结点 $0$ 出发到结点 $N-1$ 受到的最小伤害是多少？题目保证至少存在一条从结点 $0$ 到 $N-1$ 的路径。

## 说明/提示

### 样例说明

- 样例 $1$，存在路径：$0 \rightarrow 1 \rightarrow 2 \rightarrow 3$，$K = 2$，如果在 $0 \rightarrow 1 \rightarrow 2$ 上使用魔法，那么答案就是 $0 + 0 + 4 = 4$；如果在 $1 \rightarrow 2 \rightarrow 3$ 上使用魔法，那么答案就是 $2 + 0 + 0 = 2$。再也找不到比 $2$ 还小的答案了，所以答案就是 $2$。
- 样例 $2$，存在路径：$0 \rightarrow 1 \rightarrow 0 \rightarrow 1 \rightarrow 0 \rightarrow 1$，$K = 5$，这条路径总计恰好走了 $5$ 条边，所以正好可以用魔法消除所有伤害，答案是 $0$。

### 评测用例规模与约定

- 对于 $30\%$ 的评测用例，$1 \leq N \leq 20$。
- 对于 $50\%$ 的评测用例，$1 \leq N \leq 100$。
- 对于 $100\%$ 的评测用例，$1 \leq N \leq 1000$，$1 \leq M \leq \frac{N \times (N - 1)}{2}$，$1 \leq K \leq 10$，$0 \leq u, v \leq N - 1$，$1 \leq w \leq 1000$。

## 样例 #1

### 输入

```
4 2 3
0 1 2
1 2 1
2 3 4```

### 输出

```
2```

## 样例 #2

### 输入

```
2 5 1
0 1 1```

### 输出

```
0```

# 题解

## 作者：Helenty (赞：4)

本题为一道有约束的分层图最短路问题。

跟分层图最短路不一样的是，本题有一个连续 $k$ 短路不需要花费的一个约束条件，那么我们在传递状态的时候只需要特判一下，如果当前的已经使用了免费次数了，那么我们接下来我们松弛的时候就不需要花费。

这里我们使用一个二维数组 $dis_{i,k}$ 表示当前到达第 $i$ 个节点，使用了 $k$ 次免费次数的最短路径，那么我们可以得到状态转移方程：

不需要花费时：$dis_{v,{k-1}} = \min(dis_{v,{k-1}}, dis_{u,k})$。

需要花费时：$dis_{v,k} = \min(dis_{v,k}, dis_{u,k} + w)$。

C++ 代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn = 2000005;
const int inf = 1047483647;

struct node {
    int to, next, data;
};

node edge[maxn];
int head[maxn], cnt, k, n, m;

void add_edge(int from, int to, int data) {
    edge[++cnt].to = to;
    edge[cnt].data = data;
    edge[cnt].next = head[from];
    head[from] = cnt;
}

int dis[1005][15];
bool vis[1005][15];

struct heap {
    int node, data, step;
    heap(int n, int d, int s) : node(n), data(d), step(s) {}
    bool operator>(const heap& h) const {
        return data > h.data;
    }
};

void dijkstra() {
    memset(vis, 0, sizeof(vis));
    memset(dis, 0x3f, sizeof(dis));
    dis[0][k] = 0;
    priority_queue<heap, vector<heap>, greater<heap>> q;
    q.push(heap(0, 0, k));
    while (!q.empty()) {
        int now = q.top().node;
        int step = q.top().step;
        q.pop();
        if (vis[now][step])
            continue;
        vis[now][step] = true;
        for (int i = head[now]; i != 0; i = edge[i].next) {
            int to = edge[i].to, data = edge[i].data;

            if (step < k && step > 0 && dis[to][step - 1] > dis[now][step]) {
                dis[to][step - 1] = dis[now][step];
                q.push(heap(to, dis[to][step - 1], step - 1));
            }
            else if (step == k || step == 0) {
                if (dis[to][step] > dis[now][step] + data) {
                    dis[to][step] = dis[now][step] + data;
                    q.push(heap(to, dis[to][step], step));
                }
                if (step == k && dis[to][step - 1] > dis[now][step]) {
                    dis[to][step - 1] = dis[now][step];
                    q.push(heap(to, dis[to][step - 1], step - 1));
                }
            }
        }
    }
}

int main() {
    cin >> n >> k >> m;
    while (m--) {
        int x, y, z;
        cin >> x >> y >> z;
        add_edge(x, y, z);
        add_edge(y, x, z);
    }
    dijkstra();
    cout << min(dis[n - 1][k], dis[n - 1][0]) << endl;
    return 0;
}
```

---


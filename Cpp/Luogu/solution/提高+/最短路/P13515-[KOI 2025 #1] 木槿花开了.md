# [KOI 2025 #1] 木槿花开了

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

KOI 村庄由 $N$ 个建筑和 $M$ 条道路组成。

建筑从 1 到 $N$ 编号，每个建筑可能有也可能没有窗户。对于 $1 \le i \le N$ 的每个 $i$，如果第 $i$ 个建筑有窗户，则 $c_i=1$，如果没有窗户，则 $c_i=0$。规定第 1 个建筑和第 $N$ 个建筑没有窗户，即 $c_1 = c_N = 0$。

道路从 1 到 $M$ 编号，每条道路都是连接一个起始建筑和一个到达建筑的单向通道。对于 $1 \le j \le M$ 的每个 $j$，第 $j$ 条道路从建筑 $x_j$ 开始，到建筑 $y_j$ 结束，通过这条道路需要花费恰好 $t_j$ 秒。因为是单向道路，所以不能逆向行驶（即，从建筑 $y_j$ 移动到建筑 $x_j$）。

在 KOI 村庄，Hankook 和 Jeong-ul 打算玩一个基于“木槿花开了”游戏改编的以下游戏。

游戏开始时，Jeong-ul 在 1 号建筑。Jeong-ul 的目标是在不被 Hankook 的视线发现一次的情况下，尽可能快地到达 $N$ 号建筑。相反，Hankook 的目标是在 Jeong-ul 到达 $N$ 号建筑之前找到他。

Hankook 睁着眼时可以看到整个 KOI 村庄，但无法看到没有窗户的建筑内部。也就是说，Hankook 只能看到有窗户的建筑内部和所有道路。

Hankook 从游戏开始（0 秒）时起，周期性地重复以下动作：
*   首先，闭上眼睛恰好 $a$ 秒。
*   紧接着，睁开眼睛并观察村庄恰好 $b$ 秒。
*   此过程无限重复。

我们可以将上述过程用数学公式严格地表达如下：
*   我们定义“从游戏开始时经过的时间”为 $t$（以秒为单位）。
*   当时间 $t = k(a+b) + l$ 时（其中 $k$ 为非负整数， $l$ 为满足 $0 \le l < a+b$ 的实数）：
    *   如果 $0 \le l < a$，Hankook 闭着眼睛。
    *   如果 $a \le l < a+b$，Hankook 睁着眼睛。
*   也就是说，对于非负整数 $k$，Hankook 闭眼的时间是闭区间 $[k(a+b), k(a+b)+a]$，睁眼的时间是开区间 $(k(a+b)+a, (k+1)(a+b))$。

Jeong-ul 从游戏开始的时刻（0 秒）起，可以随时开始移动，并且在建筑内部（无论是否有窗户）等待和移动都是自由的，不消耗时间。从建筑出来或进入建筑内部也不消耗时间。如果 Jeong-ul 开始沿着某条道路移动，他必须花费该道路所需的确切时间来移动，并且在移动过程中不能在道路上停下或等待。移动结束后，他将到达道路的终点建筑。

Jeong-ul 被 Hankook 发现的基准如下：
*   在 Hankook 睁着眼的时候，如果 Jeong-ul 位于道路上或在有窗户的建筑内部，他会立即被发现，游戏随之结束。因此，在 Hankook 睁着眼的时间段内，Jeong-ul 必须位于没有窗户的建筑内。
*   在 Hankook 闭着眼的时候，无论 Jeong-ul 在哪里，都绝对不会被发现。
*   请注意，如果 Jeong-ul 进入没有窗户的建筑的时刻，恰好是 Hankook 开始睁眼的瞬间；或者他进入道路开始移动的时刻，恰好是 Hankook 开始闭眼的瞬间，则不会被发现。

在这些条件下，请编写一个程序，判断 Jeong-ul 是否有可能在不被 Hankook 发现一次的情况下安全到达 $N$ 号建筑，如果可能，计算 Jeong-ul 到达 $N$ 号建筑所需的最短时间（以秒为单位）。

## 说明/提示

### 样例 1 解释

随着时间的推移，Jeong-ul 和 Hankook 可以按如下方式行动：

*   0 秒 - 3 秒：Hankook 闭着眼睛。Jeong-ul 在 0 秒时进入 1 号道路（1 号建筑 → 2 号建筑），并于 3 秒时到达 2 号建筑。
*   3 秒 - 11 秒：Hankook 在 3 秒时睁开眼睛。Jeong-ul 在 2 号建筑一直停留到 11 秒。
*   11 秒 - 14 秒：Hankook 在 11 秒时闭上眼睛。Jeong-ul 在 11 秒时进入 3 号道路（2 号建筑 → 4 号建筑），并于 14 秒时到达 4 号建筑。

由于 Jeong-ul 没有比 14 秒更快到达 4 号建筑的方法，因此应当输出 14。

### 样例 2 解释

由于除 1 号和 4 号建筑外的所有建筑都有窗户，Jeong-ul 必须在 Hankook 睁开眼睛之前（即，在 $a=3$ 秒内）到达 4 号建筑。但是，Jeong-ul 不可能在 3 秒内到达 4 号建筑。因此，应当输出 `-1`。

### 限制条件

*   给定的所有数都是整数。
*   $3 \le N \le 2000$
*   $3 \le M \le 4000$
*   对于每个 $1 \le j \le M$ 的 $j$，有 $1 \le x_j, y_j \le N, x_j \ne y_j, 1 \le t_j \le 100,000$。
*   对于 $1 \le j < k \le M$ 的任意 $j, k$，有 $(x_j, y_j) \ne (x_k, y_k)$。也就是说，所有道路的起点和终点对都是唯一的。
*   对于 $2 \le i \le N-1$ 的每个 $i$，$c_i \in \{0, 1\}$。
*   $c_1 = c_N = 0$。即，1 号建筑和 $N$ 号建筑没有窗户。
*   $1 \le a, b \le 10^9$。

### 子任务

1.  (12 分) $N \le 5, M \le 10$。
2.  (19 分) 对于 $2 \le i \le N-1$ 的每个 $i$，$c_i=1$。
3.  (31 分) 对于 $1 \le j \le M$ 的每个 $j$，$t_j=1$。
4.  (27 分) $M=N-1$。并且，对于 $1 \le j \le N-1$ 的每个 $j$，$x_j = j, y_j = j+1$。
5.  (61 分) 无附加限制条件。

## 样例 #1

### 输入

```
4 4
1 2 3
1 3 4
2 4 3
3 4 1
0 0 0 0
3 8```

### 输出

```
14```

## 样例 #2

### 输入

```
4 4
1 2 3
1 3 4
2 4 3
3 4 1
0 1 1 0
3 8```

### 输出

```
-1```

# 题解

## 作者：chen_zhe (赞：2)

### 子问题 1

通过回溯法考虑从 1 号建筑到 N 号建筑的所有路径，实际判断是否可以走通这些路径，并求出为此所需的最短时间，这样可以用 $O(M!N)$ 的时间复杂度解决问题。

### 子问题 2

由于所有建筑都有窗户，因此需要检查在游戏开始后、Han-guk 睁眼之前，Jeong-ol 是否能从 1 号顶点到达 N 号顶点。这可以通过从 1 号顶点开始，使用 Dijkstra 算法求出到达 N 号顶点所需的最短时间来解决，时间复杂度为 $O(M \log N)$。

### 子问题 3

从这个子问题开始，需要以下观察。

假设 Jeong-ol 最初在 $x$ 号建筑，如果在 Han-guk 闭着眼睛的 $a$ 秒钟内，Jeong-ol 能够到达 $y$ 号建筑，那么我们就在 $x$ 号建筑和 $y$ 号建筑之间连接一条需要 $a + b$ 秒通过的虚拟道路。我们来考虑这样一种移动方式：仅通过这些虚拟道路从 1 号建筑移动到某个 $x$ 号建筑，然后从 $x$ 号建筑在 $a$ 秒内到达 N 号建筑。这种形式的移动中，有一种是耗时最短的。

这个观察的理由是，一旦在 Han-guk 闭眼的 $a$ 秒内从一个建筑到达另一个建筑，到 Han-guk 再次睁眼的时间点为止，所消耗的总时间是固定的。

因此，我们先求出从 1 号建筑仅使用虚拟道路到达其他所有建筑的最短时间，再求出从 $N$ 号建筑仅使用实际道路在 $a$ 秒内能到达的其他建筑的最短时间，然后就可以得出答案。为了求出需要添加的虚拟道路，需要知道任意两建筑之间的最短通行时间，在本子问题中，使用 BFS 算法就足以计算出这个值。

### 子问题 4

代替子问题 3 中使用的 BFS 算法，由于给定的城市形态是线性的，因此可以更容易地求出各建筑间的最短距离。

### 子问题 5

代替子问题 3 中使用的 BFS 算法，使用 Dijkstra 算法即可解决整个问题。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long int ll;
const ll inf=1e18;
ll n,m,i,j,k,l,r,x,y,z,w,s,t,a[1100000],b[1100000],dp[2200][2200],dp2[1100000],c[2200][2200],st,ed,ans;
vector<pair<ll,ll>> v[1100000];
vector<ll> u[1100000];
priority_queue<pair<ll,ll>> q;
queue<ll> qq;
int main()
{
    scanf("%lld %lld",&n,&m);
    for(i=1;i<=m;i++)
    {
        scanf("%lld %lld %lld",&x,&y,&z);
        v[x].push_back({y,z});
    }
    for(i=1;i<=n;i++)
    {
        q.push({0,i});
        for(j=1;j<=n;j++)
            dp[i][j]=inf;
        dp[i][i]=0;
        while(!q.empty())
        {
            x=q.top().second;
            q.pop();
            if(c[i][x])
                continue;
            c[i][x]=1;
            for(auto xx:v[x])
            {
                y=xx.first;
                z=xx.second;
                if(dp[i][y]>dp[i][x]+z)
                {
                    dp[i][y]=dp[i][x]+z;
                    q.push({-dp[i][y],y});
                }
            }
        }
    }
    for(i=1;i<=n;i++)
    {
        scanf("%lld",&b[i]);
    }
    scanf("%lld %lld",&s,&t);
    st=1;
    ed=n;
    for(i=1;i<=n;i++)
    {
        for(j=1;j<=n;j++)
        {
            if(dp[i][j]<=s&&(b[j]==0||j==ed))
            {
                u[i].push_back(j);}
        }
    }
    for(i=1;i<=n;i++)
        dp2[i]=inf;
    dp2[st]=0;
    qq.push(st);
    while(!qq.empty())
    {
        x=qq.front();
        qq.pop();
        for(auto xx:u[x])
        {
            if(dp2[xx]>dp2[x]+1)
            {
                dp2[xx]=dp2[x]+1;
                qq.push(xx);
            }
        }
    }
    if(dp2[ed]==inf)
    {
        printf("-1");
        return 0;
    }
    ans=inf;
    for(i=1;i<=n;i++)
    {
        if(dp2[i]==inf)
            continue;
        if(dp[i][ed]<=s)
        {
            ans=min(ans,dp2[i]*(s+t)+dp[i][ed]);
        }
    }
    printf("%lld",ans);
}
```

---

## 作者：ran_qwq (赞：1)

不可能在没窗户的建筑中逗留，所以我们只关心两个有窗户的建筑之间的最短路。设 $w_{u,v}$ 为 $u$ 到 $v$ 不考虑被抓的最短路，这可以 $O(nm\log m)$ 预处理。

然后我们建新图，如果 $w_{u,v}\le a$ 就 $u$ 向 $v$ 连权为 $w_{u,v}$ 的边。直接跑 dijkstra，设 $d_u$ 为 $1$ 到 $u$ 的最短路，定义 $M(x)$ 为 $x\bmod(a+b)$ 的值。

- 如果 $M(d_u+w_{u,v})\le a$ 则可以直接通过，$d_v\leftarrow d_u+w_{u,v}$。
- 否则需等下一轮，$d_v\leftarrow d_u-M(d_u)+a+b+w_{u,v}$。

时间复杂度 $O(n^2\log n^2)$。

[这是代码。](https://www.luogu.com.cn/paste/mh1rp17g)

---

## 作者：lilong (赞：1)

显然用时超过 $a$ 的边是一定不能走的，那么剩下的边一定都能在一个周期内走完。又由于每个周期一定能到达新的点（最短路径要求不重复），所以一定不超过 $n$ 个周期。借鉴分层图的思想，直接枚举每个周期，如果上个周期从 $1$ 到某点 $u$ 的最短用时 $dis_u$ 不超过 $a$ 且 $c_u=0$，那么可以在 $u$ 等待至当前周期（也可以不等待，在上个周期已经考虑了），此时新的 $dis_u=0$，否则上个周期无法走到 $u$（或者不允许停下来等待），此时新的 $dis_u=+\infty$。然后跑 Dijkstra 即可，时间复杂度 $O(nm\log m)$。

```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<vector>
#define inf 1e18
#define int long long
#define ll long long
#define N 2010
using namespace std;
int n,m,vis[N*2],c[N*2];
vector<pair<int,ll> > G[N*2];
ll dis[N*2],ans,x,y;
int id(int u,int ti){
    return u+ti*n;
}
signed main(){
    ans=inf;
    int u,v,w;
    cin>>n>>m;
    for(int i=1;i<=m;i++){
        cin>>u>>v>>w;
        G[u].push_back(make_pair(v,w));
        // G[v].push_back(make_pair(u,w));
    }
    for(int i=1;i<=n;i++)
        cin>>c[i];
    cin>>x>>y;
    for(int i=2;i<=n;i++)
        dis[i]=1e18;
    for(int i=1;i<=n+5;i++){
        priority_queue<ll,vector<pair<ll,int> >,greater<pair<ll,int> > > q;
        for(int j=1;j<=n;j++){
            vis[j]=0;
            if(dis[j]<=x&&!c[j]){
                dis[j]=0;
                q.push(make_pair(dis[j],j));
            }
            else dis[j]=inf;
        }
        while(!q.empty()){
            int u=q.top().second;
            q.pop();
            if(vis[u])continue;
            vis[u]=1;
            for(auto it:G[u]){
                int v=it.first;
                ll w=it.second;
                if(dis[u]+w<dis[v]){
                    dis[v]=dis[u]+w;
                    q.push(make_pair(dis[v],v));
                }
            }
        }
        if(dis[n]<=x)ans=min(ans,1ll*(i-1)*(x+y)+dis[n]);
        // for(int i=1;i<=n;i++)
            // cout<<dis[i]<<' ';
        // cout<<'\n';     
    }
    if(ans==inf)cout<<-1;
    else cout<<ans;
    return 0;
}
```

---


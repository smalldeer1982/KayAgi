# 集合位置

## 题目描述

每次有大的活动，大家都要在一起“聚一聚”，不管是去好乐迪，还是避风塘，或者汤姆熊，大家都要玩的痛快。还记得心语和花儿在跳舞机上的激情与释放，还记得草草的投篮技艺是如此的高超，还记得狗狗的枪法永远是 S ……还有不能忘了，胖子的歌声永远是让我们惊叫的！！

今天是野猫的生日，所以想到这些也正常，只是因为是上学日，没法一起去玩了。但回忆一下那时的甜蜜总是一种幸福嘛。。。

但是每次集合的时候都会出现问题！野猫是公认的“路盲”，野猫自己心里也很清楚，每次都提前出门，但还是经常迟到，这点让大家很是无奈。后来，野猫在每次出门前，都会向花儿咨询一下路径，根据已知的路径中，总算能按时到了。

现在提出这样的一个问题：给出 $n$ 个点的坐标，其中第一个为野猫的出发位置，最后一个为大家的集合位置，并给出哪些位置点是相连的。野猫从出发点到达集合点，总会挑一条最近的路走，如果野猫没找到最近的路，他就会走第二近的路。请帮野猫求一下这条第二最短路径长度。

特别地，选取的第二短路径**不会重复经过同一条路**，即使可能重复走过同一条路多次路程会更短。

## 样例 #1

### 输入

```
3 3
0 0
1 1
0 2
1 2
1 3
2 3
```

### 输出

```
2.83```

# 题解

## 作者：TsReaper (赞：75)

次短路模版题。首先找出一条最短路，之后一次去掉一条最短路上的边，对于每一次去掉一条边后的图都跑一次最短路，其中最小的答案就是次短路。

为什么要去掉最短路上的一条边呢？因为次短路和最短路必然至少有一条边不是共有的。为什么不去掉不在最短路上的边呢？因为这样最短路是没有变化的。


---

## 作者：Diamiko (赞：43)

# 题解 P1491 【集合位置 】

## 主要思想：次短路

### 1.什么是次短路？

顾名思义，次短路就是仅次于图中最短路的最短的路。

或者说，第二短的路。

### 2.何以见得是次短路？
```
现在提出这样的一个问题：
给出n个点的坐标，其中第一个为野猫的出发位置，
最后一个为大家的集合位置，并给出哪些位置点是相连的。
野猫从出发点到达集合点，总会挑一条最近的路走，
如果野猫没找到最近的路，他就会走第二近的路。
请帮野猫求一下这条第二最短路径长度。
```
题目已经说的很明显了，第二最短路径。

### 3.如何求最短路？

我们采用删边的思想，先跑一遍最短路，记录路径。

然后依次删去最短路径上每一条边，分别跑一遍最短路，取所有答案中的最小值即可。

### 4.为什么是正确的？

引用 @TsReaper 的话

>为什么要去掉最短路上的一条边呢？因为次短路和最短路必然至少有一条边不是共有的。

>为什么不去掉不在最短路上的边呢？因为这样最短路是没有变化的。

说实话，大佬归纳的太好了，我稍作总结。

你不去掉最短路上的边，最短路没有变化，那么你再跑最短路，答案还会是最短路的长度。

你只有去掉一条最短路上的边，才能保证你得到的新路径一定不是最短路径。

### 5.如何实现记录路径

在跑第一遍最短路的时候记录被更新的点的前驱。

需要注意的是，只有第一次跑，才要记录路径。要不然后面每跑一次都记录，那就乱套了233。

### 6.如何实现删边

难道我们真的要在图里删去一条边吗？

答案当然是不，因为那样不仅麻烦，也没必要。

我们只需要在跑最短路的时候，传入两个参数，分别是最短路径上的一条边的两个端点。

这样我们在跑最短路的时候，只要当前边相连的是这两个点，我们直接忽略它，就ok了。

#### 那第一遍跑最短路的时候怎么办？

有两种方法：

1. 写两种不同的最短路函数；

2. 给第一遍传参为`(-1,-1)`，因为我们的边绝对不会有端点为`-1`，为什么不用0大家可以思考一下

~~我选择第二种~~

### 7.关于预处理

两点之间的距离如何计算？

根据欧几里得距离公式，对于平面上两点$(x1,y1)$和$(x2,y2)$，它们的距离为

$$\sqrt{(x1-x2)^2+(y1-y2)^2}$$

这也可以通过勾股定理自行推导

而且，注意数据类型`double`.

### 8.关于最短路

本题没有负边权，建议Dijkstra+堆优化。

~~关于SPFA：它死了~~

### 9.代码实现

详见注释

```cpp
#include<queue>
#include<cmath>
#include<cstdio>
#define INF 0x3f3f3f3f//极大值
#define pdi pair<double,int>//宏定义，个人习惯
using namespace std;
struct Node
{
	double x,y;//点坐标 
	int head;
	double dis;
	int prev;//前驱 
}node[205];
struct Edge
{
	int next,to; 
	double len;//注意double 
}edge[50005];
int n,m,cnt;
double ans=INF<<1;
double calc(double a,double b,double c,double d)
{
	return (double)sqrt(double(a-c)*double(a-c)+double(b-d)*double(b-d));
}
//距离公式，注意数据类型
void addEdge(int u,int v,double w)
{
	edge[++cnt].len=w;
	edge[cnt].to=v;
	edge[cnt].next=node[u].head;
	node[u].head=cnt;
}
//链式前向星存边
void Dijkstra(int x,int y)
{
	for(int i=1;i<=n;i++)
	{
		node[i].dis=INF;
	}
	//初始化
	node[1].dis=0;
	priority_queue<pdi,vector<pdi>,greater<pdi> >q;
	q.push({0,1});
	//小根堆
	while(q.size())
	{
		pdi tmp=q.top();
		q.pop();
		double d=tmp.first;
		int u=tmp.second;
		if(node[u].dis!=d)continue;
		for(int e=node[u].head;e;e=edge[e].next)
		{
			int v=edge[e].to;
			if((u==x&&v==y)||(u==y&&v==x))continue;
			//这里就是删边的操作，尤其注意
			//另外，因为是无向图，所以要判断两种不同的情况
			if(node[v].dis<=d+edge[e].len) continue;
			if(x==-1&&y==-1)node[v].prev=u;
			//只有第一次跑最短路才记录路径
			node[v].dis=d+edge[e].len;
			q.push({node[v].dis,v});
		}
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		scanf("%lf%lf",&node[i].x,&node[i].y);
	}

	for(int i=1,u,v;i<=m;i++)
	{
		scanf("%d%d",&u,&v);
		double w=calc(node[u].x,node[u].y,node[v].x,node[v].y);
		//注意double
		addEdge(u,v,w);
		addEdge(v,u,w);
        	//双向边
	}

	Dijkstra(-1,-1);
	//第一遍传入两个-1，因为不需要删边

	for(int i=n;i!=1;i=node[i].prev)
	{
		//i!=1的判断条件，是因为1是起点，没有前驱
		//你总不能删0~1吧……
		Dijkstra(i,node[i].prev);
		ans=min(ans,node[n].dis);
		//取最小值
	}
	if(ans>=INF)puts("-1");
	//n没有被更新到，说明没有次短路（或压根都不连通）
	else printf("%.2lf\n",ans);
	//注意保留两位小数
	return 0;
}
```


完成！

**温馨提示：直接提交这份代码可能会CE哦**

写题解不易，望过审。如果各位还有不理解的，可以私信我或者at我，我会尽一臂之力

---

## 作者：AubRain (赞：31)

**A*算法**

看着好像没有A*的题解

我就来~~水一波~~发一篇

第K短路模板
使用一个优先队列，每次取f(x)+g(x)最小的状态进行拓展

其中f(x)是从起点到当前的距离；

g(x)是估价函数，是从当前到终点的最短路，符合估价小于等于实际值；

当终点第k次从队中被取出，就是k短路
```cpp
#include<bits/stdc++.h>
using namespace std;
int head[40005],cnt;
int n,m,tot;
double x[205],y[205],dis[2052];
double dist(double a,double b,double c,double d){return sqrt((a-c)*(a-c)+(b-d)*(b-d));}//计算两点距离
struct node
{
    int to,next;
    double v;
}edge[40005];
void add(int x,int y,double w)
{
    cnt++;
    edge[cnt].to=y;
    edge[cnt].v=w;
    edge[cnt].next=head[x];
    head[x]=cnt;
}//邻接表
struct nd
{
    double dist,g;
    int id;
    bool vis[205];
    nd()
    {
        memset(vis,0,sizeof(vis));
    }
};//dist就是f(x），g就是估价，还要开一个vis数组判重，否则只有70分

bool in[205];
int tot;
queue<int> qq;
priority_queue<nd> q;

bool operator<(nd x,nd y){ return x.dist+x.g>y.dist+y.g;}//优先队列大于号是升序（和sort的cmp函数不同）

int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        cin>>x[i]>>y[i]； 
    for(int i=1;i<=m;i++)
    {
        int u,v;
        cin>>u>>v;
        double di=dist(x[u],y[u],x[v],y[v]);
        add(u,v,di);
        add(v,u,di);
    }
     in[n]=1;
    qq.push(n);
    for(int i=1;i<=n;i++) dis[i]=1e9;
    dis[n]=0;
    while(!qq.empty())//先以终点为起点，跑一边SPFA，求出每个点到终点的最短路，即估价
    {
        int d=qq.front();
        in[d]=0;
        qq.pop();
        for(int i=head[d];i>0;i=edge[i].next)
        {
            int t=edge[i].to;
            if(dis[t]==dis[d]+edge[i].v&&t==1)
            	tot++;
            if(dis[t]>dis[d]+edge[i].v)
            {
            	if(t==1) tot=1;
                dis[t]=dis[d]+edge[i].v;
            
                if(!in[t])
                {
                    qq.push(t);
                    in[t]=1;
                }
            }
        }
    } //模板，就不多说了
    nd begin;
    begin.dist=0;
    begin.g=dis[1];
    begin.id=1;//把起始状态入队
    
    q.push(begin);
    tot=0;
    while(!q.empty())
    {
    	nd d=q.top();
    	q.pop();
    	if(d.id==n)
         	tot++； //tot记录终点出队次数
    	if(tot==2)//如果第二次出队，就输出答案
    	{
    		printf("%.2lf",d.dist);
    		return 0;
        }
    	int id=d.id;
    	nd next;//next就是下一个状态
    	for(int i=head[id];i;i=edge[i].next)
    	{
    		int t=edge[i].to;
    		if(d.vis[t]) continue;//别忘了判重
    		next=d;
    		next.vis[t]=1;
    		next.id=t;
    		next.g=dis[t];
    		next.dist=d.dist+edge[i].v;
    		q.push(next);
        }	
    }
    cout<<-1;
    return 0;
}
求通过 (✺ω✺)
```

---

## 作者：绝顶我为峰 (赞：28)

$emm...$这~~显然~~是一道次短路模板题，看到大佬们都用的删边法，我这里来一发枚举法吧

我们设有图$G(V,E)$，$e(u,v)$是其中的一条边的，$w(u,v)$是其权值，从$i$到$j$的最短路为$dis[i][j]$，那么从$1$到$n$的次短路可以表示为：

$$\sum_{e(u,v)\in G(v,e)}min(dis[1][u]+w(u,v)+dis[v][n])$$

那么我们只需要枚举每一条边即可，实现预处理最短路，以$1$和$n$为起点分别跑一次，然后算次短路

但是由于这道题要求每个点只能走一次（但是题目并没有说），我们还需要寻找最短路径走向，并且枚举时判断，然后再累加即可

但是这样会超时，我们还需要在判断是加上小优化来节省时间

```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<queue>
#include<ext/pb_ds/priority_queue.hpp>
#include<cmath>
#include<cstring>
using namespace std;
using namespace __gnu_pbds;
struct edge
{
	int node;
	double weight;
	edge(int node_,double weight_):
		node(node_),weight(weight_){}
};
vector<edge> v[201];
int n,m,a[201],b[201];
double dis1[201],dis2[201],path1[201],path2[201];
bool vis[201];
inline int read()
{
	int x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9')
	{
		if(c=='-')
			f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')
	{
		x=(x<<1)+(x<<3)+c-'0';
		c=getchar();
	}
	return x*f;
}
inline double clac(int a1,int b1,int a2,int b2)
{
	return sqrt((a1-a2)*(a1-a2)+(b1-b2)*(b1-b2));//计算两点距离
}
inline void dijkstra(int s,double dis[])
{
	memset(vis,0,sizeof(vis));
	register __gnu_pbds::priority_queue<pair<double,int>,greater<pair<double,int> >,pairing_heap_tag> q;//平板电视大法好（大雾
	q.push(make_pair(0.00,s));
	while(!q.empty())//板子
	{
		register pair<double,int> k=q.top();
		q.pop();
		if(vis[k.second])
			continue;
		vis[k.second]=1;
		dis[k.second]=k.first;
		for(register vector<edge>::iterator it=v[k.second].begin();it!=v[k.second].end();++it)
			if(!vis[it->node])
				q.push(make_pair(it->weight+k.first,it->node));
	}
}
inline void findway()
{
	for(register int i=1;i<=n;++i)
		for(register vector<edge>::iterator it=v[i].begin();it!=v[i].end();++it)//寻找路径
		{
			//if(!path1[it->node])
				if(dis1[it->node]==dis1[i]+it->weight)
				path1[it->node]=i;
			//if(!path2[it->node])
				if(dis2[it->node]==dis2[i]+it->weight)
					path2[it->node]=i;
		}
}
inline bool check(int s,int t)
{
	bool qwq[201]={0};
	for(register int i=s,j=t;i||j;i=path1[i],j=path2[j])
		if(qwq[i]||qwq[j])//优化：需要两条路径同时进行判断节省时间
			return 0;
		else
			qwq[i]=qwq[j]=1;
	return 1;
}
int main()
{
	n=read(),m=read();
	for(register int i=1;i<=n;++i)
		a[i]=read(),b[i]=read();
	while(m--)
	{
		register int x=read(),y=read();
		v[x].push_back(edge(y,clac(a[x],b[x],a[y],b[y])));
		v[y].push_back(edge(x,clac(a[x],b[x],a[y],b[y])));
		//cout<<clac(a[x],a[y],b[x],b[y])<<endl;
	}//建图
	dijkstra(1,dis1);//预处理
	dijkstra(n,dis2);
	//cout<<dis1[1]<<" "<<dis1[2]<<" "<<dis1[3]<<" "<<dis2[1]<<" "<<dis2[2]<<" "<<dis2[3]<<endl;
	register double minn=dis1[n],ans=233333333333.00;
	findway();//确定路径
	for(register int i=1;i<=n;++i)
		for(register vector<edge>::iterator it=v[i].begin();it!=v[i].end();++it)//枚举每条边
		{
			register double w=dis1[i]+it->weight+dis2[it->node];
			if(ans==233333333333.00||(w<ans&&w>minn&&check(i,it->node)))//判断是否是次短路并且没有重复经过某个点
				ans=w;//更新答案
		}
	if(ans==233333333333.00)
		puts("-1");
	else
		printf("%.2lf\n",ans);//输出
	return 0;
}
```


---

## 作者：bztMinamoto (赞：9)

大体思路如下：先通过一遍spfa算出最短路，并记录下该最短路上的所有边。每一次删去其中的一条边，求出此时的最短路径。所有答案的最小值即为所求

ps：由于最短路径每一次都有一条边被删去，可以保证求出的最短路径必定大于等于原图的最短路

pps：细节问题，关于如何记录spfa经过的边，我们可以设前缀数组pre，当更新d[y]时，将pre[y]=x（出发点）。最后从n点从后往前倒搜，即可将每一条边都记录下来

具体请看注解，上代码
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cstring>
#include<cmath>
using namespace std;
const int N=205,M=40050,INF=0x3f3f3f3f;
typedef long long LL;
int ver[M],Next[M],head[N],used[N],Prev[N],x[N],y[N];
double edge[M],d[N];
int n,m,tot;
double ans=INF;
double num(int i,int j)
{
    return sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));
}
void add(int x,int y,double z)
{
    ver[++tot]=y,edge[tot]=z,Next[tot]=head[x],head[x]=tot;
    return;
}
void spfa(int a,int b)
{
    for(int i=1;i<=n;i++) d[i]=INF;
    memset(used,0,sizeof(used));
    queue<int> q;
    q.push(1);
    d[1]=0,used[1]=1;
    while(!q.empty())
    {
        int x=q.front();
        q.pop();
        used[x]=0;
        for(int i=head[x];i;i=Next[i])
        {
            int y=ver[i];
            double z=edge[i];
            if(x==a&&y==b||x==b&&x==a) continue;
            //删边，即使这一条边不能走
            if(d[y]>d[x]+z)
            {
                if(a==-1&&b==-1) Prev[y]=x;
                //如果是第一遍搜，记录前缀
                d[y]=d[x]+z;
                if(!used[y]) q.push(y),used[y]=1;
            }
        }
    }
    return;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    scanf("%d%d",&x[i],&y[i]);
    for(int i=0;i<m;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        double z=num(x,y);
        add(x,y,z);
        add(y,x,z);
    }
    spfa(-1,-1);
    //第一遍，不需要删边
    for(int i=n;Prev[i];i=Prev[i])
    {
        spfa(Prev[i],i);
        //将i和pre[i]之间的边删去
        ans=min(ans,d[n]);
    }
    if(ans==INF) printf("-1");
    else printf("%.2lf",ans);
    return 0;
}
```

---

## 作者：Frozen_Heart (赞：6)

一句话题意：给你一个有n个点的平面坐标系，某些点之间有边，要求第1个点到第n个点的次短路。

这是一道k短路的模板题，但是由于本人太弱了，并不会k短路........

所以我们可以想一些比较巧的算法。

这道题是次短路，而最短路我们是很容易求出来的，我们可以尝试一下在最短路上处理来做这道题。

既然不能走和最短路完全一样的边，那么我们每次把最短路上的一条边删去，再跑spfa或者dijkstra，跑的次数取决于最短路经过几条边。

要找到最短路的边的话，需要记录前驱。每次进行松弛操作的时候如果dis被更新了，就记录前驱。(思考一下应该就能明白为什么不能记录后驱)。
```cpp
#include<bits/stdc++.h>
using namespace std;
int read()//快读
{
    int x=0,w=1;char ch=getchar();
    while(ch>'9'||ch<'0') {if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    return x*w;
}
int cnt;
int x[210],y[210],head[210],vis[210],team[500010],from[210],bian[210],s[500010];
double dis[210];//注意开double
struct node{
int to,next;double v;
}edge[500010];
void add(int a,int b)
{
    cnt++;
    edge[cnt].to=b;
    edge[cnt].next=head[a];
    edge[cnt].v=sqrt((x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]));
    head[a]=cnt;
}
void spfa()
{
    memset(dis,127,sizeof(dis));
    int l=0,r=1,u,v;
    team[1]=1;vis[1]=1;dis[1]=0;
    while(l<r)
    {
        l++;
        u=team[l];
        vis[u]=0;
        for(int i=head[u];i;i=edge[i].next)
        {
            v=edge[i].to;
            if(dis[v]>dis[u]+edge[i].v)
            {
                dis[v]=dis[u]+edge[i].v;
                from[v]=u;//记录前驱
                if(!vis[v])
                {
                    vis[v]=1;
                    r++;
                    team[r]=v;
                }
            }
        }
    }
}
void spfa2(int x,int y)// 这里注意是要分spfa和spfa2的，pfa和spfa2的，因为第一次要记录前驱节点。而后几次如果仍然记录的话接下来的递归就会出柜了！！！具因为第一次要记录前驱节点。而后几次如果仍然记录的话接下来的递归就会出柜了！！！具体看写法，也可以第一次spfa后直接递归把边用数组存起来，这样就不必要分开写两个。_
{
    memset(dis,127,sizeof(dis));
    int l=0,r=1,u,v;
    team[1]=1;vis[1]=1;dis[1]=0;
    while(l<r)
    {
        l++;
        u=team[l];
        vis[u]=0;
        for(int i=head[u];i;i=edge[i].next)
        {
            v=edge[i].to;
            if((v==y&&u==x)||(v==x&&u==y)) continue;
            if(dis[v]>dis[u]+edge[i].v)
            {
                dis[v]=dis[u]+edge[i].v;
                if(!vis[v])
                {
                    vis[v]=1;
                    r++;
                    team[r]=v;
                }
            }
        }
    }
}
int main()
{
    int n,m,xi,yi;
    double minn=90000000;
    n=read();m=read();
    for(int i=1;i<=n;i++)
    {
        x[i]=read();y[i]=read();
    }
    for(int i=1;i<=m;i++)
    {
        xi=read();yi=read();
        add(xi,yi);
        add(yi,xi);
    }
    spfa();
    int v=n;
    double tmp;
    while(v!=1)
    {
        spfa2(v,from[v]);
        if(dis[n]<minn) minn=dis[n];
        v=from[v];
    }
    if(minn==90000000)
    {
        printf("-1");
        return 0;
    }
    else
    printf("%.2lf\n",minn);
}
```

---

## 作者：盖矣斌峥 (赞：4)

[本人博客](https://prime.design.blog/)

先跑一遍最短路（spfa，这个不用讲吧，不会的去看看模版）

然后枚举短边，每次断掉一条最短路中的边，标记它不能走

接着继续跑最短路，记录每一次最短路的长度，其中最短的一条就是答案

见代码：
```
#include<cmath>
#include<cstdio>
#include<iomanip>
#include<cstring>
#include<iostream>
using namespace std;
struct point{int x,y;}p[205];
int dl[400005];
int n,m,vis[205],used[205];
double a[205][205],d[205];
double jisuan(int i,int j)
{
	return sqrt((p[i].x-p[j].x)*(p[i].x-p[j].x)+(p[i].y-p[j].y)*(p[i].y-p[j].y));
}
int from[205];
void Spfa(int s)
{
	int l=1,r=1;
	for(int i=1;i<=n;i++)d[i]=0x7fffffff/2;
	dl[1]=1;vis[1]=1;d[1]=0;
	while(l<=r)
	{
		int x=dl[l];
		vis[x]=0;
		for(int i=1;i<=n;i++)
		{
			if(a[x][i]!=0&&d[x]+a[x][i]<d[i])
			{
				d[i]=d[x]+a[x][i];
				used[i]++;
				if(s==1)from[i]=x;
				if(used[i]>=n)return;
				if(vis[i]==0)
				{
					vis[i]=1;
					dl[++r]=i;
				}
			}
		}
		l++;
	}
	return ;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("%d%d",&p[i].x,&p[i].y);
	for(int i=1;i<=m;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		a[x][y]=a[y][x]=jisuan(x,y);
	}
	Spfa(1);
	int k=n;
	double ans=0x7fffffff/2;
	while(from[k])
	{
		double bj=a[k][from[k]];
		a[k][from[k]]=a[from[k]][k]=0;
		Spfa(2);
		if(d[n]!=0x7fffffff/2)ans=min(ans,d[n]);
		a[k][from[k]]=a[from[k]][k]=bj;
		k=from[k];
	}
	if(ans==0x7fffffff/2)printf("-1");
	else printf("%.2f",ans);
	return 0;
}
```


---

## 作者：COUPDETAT (赞：3)

# 次短路问题
这道题不少同学用dij也被tle了
注意一下存边方式 还有只在第一次跑最短路时记录路径

大体思路很暴力：

1.求最短路并记录路径

2.分别枚举路径并断边

3.比较大小

注意存边的问题
```cpp
   if(!flag||dd==-1&&bb==-1)   
   per[y]=x; 
   
   //下面是
   int now=n; 
     while(per[now]){ 
      dij(per[now],now); 
      ans=min(d[n],ans); 
        now=per[now]; 
    } 


```
贴上代码
```cpp
using namespace std;
#define M(x,y) make_pair(x,y)
int fr[1000010],to[2000010],nex[2000010],tl,f[4100010];
double d[1000010],v[2000010];
int x[100101],y[100100];
bool b[1000010];int cnt,flag;
double num(int i,int j)
{
    return sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));
}
const int inf=14332230100;
int per[1000000];
void add(int x,int y,double w)
{
    to[++tl]=y;
    v[tl]=w;
    nex[tl]=fr[x];
    fr[x]=tl;
    f[tl]=x;
}
inline void read(int &x)
{
    x=0;int f(0);char ch(getchar());
    while(ch<'0'||ch>'9')
        f|=(ch=='-'),ch=getchar();
    while(ch>='0'&&ch<='9')
        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    x=f?-x:x;
}
int n,m,z,s;
void dij(int dd,int bb)
{
    memset(b,0,sizeof(b));
    priority_queue< pair<int,int> > q;
    int s=1;
    for(int i=1;i<=n;i++) d[i]=123123123;
    d[s]=0;
    q.push(M(0,s));
    while(!q.empty())
    {
        int x=q.top().second;
        q.pop(); 
        if(b[x]) continue;
        b[x]=1;
        for(int i=fr[x];i;i=nex[i])
        {
            int y=to[i];
        	if((x==dd&&y==bb)||(x==bb&&y==dd)) continue;
            double l=v[i];
            if(d[y]>d[x]+l)
            {
                d[y]=d[x]+l;
                if(!flag||dd==-1&&bb==-1)
                per[y]=x;
                q.push(M(-d[y],y)); 
            }
        }
    }
}
int main()
{
    read(n),read(m);
    for(int i=1;i<=n;i++)
    scanf("%d%d",&x[i],&y[i]);
    for(int i=0;i<m;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        double z=num(x,y);
        add(x,y,z);
        add(y,x,z);
    }	
    dij(-1,-1);
    flag=1;
    double ans=14332230;
    int now=n;
     while(per[now]){
        dij(per[now],now);
        ans=min(d[n],ans);
        now=per[now];
    }
    if(ans==14332230)printf("-1\n");
    printf("%.2lf",ans);
}
```




---

## 作者：易极feng (赞：3)

和楼下的做法类似，这里给出c++的spfa写法。

先一次spfa记录下最短路（用前驱）

然后每次删去最短路中的一条边再跑spfa。

洋洋洒洒竟然写了113行代码。

前驱记录方法：开一个f数组，在每次松弛边的时候如果d[i]被更新了，就将f[i]:=j,表示当前到i点的最短路径中，j是i的前驱结点。

结束后从i=n开始，对于结点i,不断地i:=pre[i]直到i=源点，这途中的点即为路径。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<cmath>
#include<queue>
using namespace std;

struct point{
    int x,y;
};

struct edge{
    int t;
    double c;
};

double dis(int a,int b,int x,int y){return(sqrt((a-x)*(a-x)+(b-y)*(b-y)));}

int n,m;
point p[205];
int f[205];//记录前驱
vector<edge>g[205];

//第一次spfa
void qwq1(){
    queue<int>q;
    bool v[205];
    double d[205];
    memset(v,0,sizeof(v));
    for(int i=2;i<=n;i++)d[i]=99999999;
    d[1]=0,v[1]=1;
    q.push(1);
    
    int u;
    while(!q.empty()){
        u=q.front();
        q.pop();
        v[u]=0;
        for(int i=0;i<g[u].size();i++){
            int t=g[u][i].t;double c=g[u][i].c;
            if(d[t]>d[u]+c){
                d[t]=d[u]+c;
                f[t]=u;//更新前驱
                if(!v[t]){
                    q.push(t);
                    v[t]=1;
                }
            }
        }
    }
}

//第二次spfa
double qwq2(int a,int b){
    queue<int>q;
    bool v[205];
    double d[205];
    memset(v,0,sizeof(v));
    for(int i=2;i<=n;i++)d[i]=99999999;
    d[1]=0,v[1]=1;
    q.push(1);
    
    int u;
    while(!q.empty()){
        u=q.front();
        q.pop();
        v[u]=0;
        for(int i=0;i<g[u].size();i++){
            int t=g[u][i].t;double c=g[u][i].c;
            if((u==a&&t==b)||(u==b&&t==a))continue;
            if(d[t]>d[u]+c){
                d[t]=d[u]+c;
                if(!v[t]){
                    q.push(t);
                    v[t]=1;
                }
            }
        }
    }
    
    return d[n];
}

int main(){
    int i;
    int a,b;
    double c;
    scanf("%d%d",&n,&m);
    for(i=1;i<=n;i++)scanf("%d%d",&p[i].x,&p[i].y);
    for(i=1;i<=m;i++){
        scanf("%d%d",&a,&b);
        c=dis(p[a].x,p[a].y,p[b].x,p[b].y);
        //cout<<a<<' '<<b<<' '<<c<<endl;
        g[a].push_back((edge){b,c});
        g[b].push_back((edge){a,c});
    }
    
    memset(f,0,sizeof(f));
    qwq1();
    
    double ans=99999999;
    int pre=n;
    while(f[pre]!=1){
        double t=qwq2(pre,f[pre]);
        if(ans>t)ans=t;
        pre=f[pre];
    }
    double t=qwq2(pre,1);
    if(ans>t)ans=t;
    
    if(ans==99999999)printf("-1");
    else printf("%.2f",ans);
    return 0;
} 
```

---

## 作者：常清静矣 (赞：2)

### 【前言】
前面的题解都是用次短路解的，这里提供一个“剪枝法”的思路。当然，对于这题来说，我感觉剪枝法效率应该是不如次短路的。
#### 【思路】
1.题目求次短路，那么我们求出所有的路径，从所有路径中选择次短的一条，就是所求的答案。这一步DFS即可。

2.但是明显，DFS必然是超时的，所以我们要减枝。我们记录和维护两个最短的长度，减枝有两个途径：

		1）结果减枝：当前长度>=当前记录的次短长度，减枝；

		2）预测减枝：当前长度+未来最短的长度>=当前记录的次短长度，减枝；

3.如何获得未来最短长度呢？以终点为开头跑一遍最短路径就可以，dijkstra或者SPFA都可以。这里未来最短长度是一种估计的预测。

另外多解释一下，dijkstra是求一点到多点的最短路径，如果要求多点到一点的最短路径，就是反跑dijkstra，洛谷有一道邮递员送信的题目考的就是这里。

#### 【代码】

```c
#include<iostream>
#include<algorithm>
#include<vector>
#include<cmath>
#include<iomanip>
using namespace std;
const int nA=205;
const double inf=1000000000;

struct NODE{
	double x,y;
}node;
int n,m;
NODE P[nA];
double G[nA][nA];
bool VIS[nA]={false};	//dijkstra和DFS共用一个VIS数组
double aa=inf,bb=inf;	//最短长度和次短长度
double D[nA];

void DIJ(int s){	//dijkstra模板
	fill(VIS,VIS+nA,false);
	fill(D,D+nA,inf);
	D[s]=0;
	for(int i=1;i<=n;i++){
		int u=-1,MIN=inf;
		for(int j=1;j<=n;j++){
			if(VIS[j]==false&&D[j]<MIN){
				u=j;
				MIN=D[j];
			}
		}
		
		if(u==-1)return ;
		VIS[u]=true;
		for(int v=1;v<=n;v++){
			if(VIS[v]==false&&G[u][v]!=inf&&D[u]+G[u][v]<D[v]){
				D[v]=D[u]+G[u][v];
			}
		}
	}
}

double dis(int a,int b){	//求两点间距离
	double x2=P[a].x-P[b].x;
	double y2=P[a].y-P[b].y;
	return sqrt(x2*x2+y2*y2);
}

void put(double path){	//维护最短长度和次短长度的函数
	if(aa<path&&path<=bb)bb=path;
	if(path<=aa){
		bb=aa;
		aa=path;
	}
}

void DFS(int index,double path){	//DFS
	if(path>=bb)return ;	//结果减枝
	
	if(index==n){
		put(path);
		return ;
	}
	
	for(int i=1;i<=n;i++){
		if(VIS[i]==true)continue;
		if(G[index][i]==inf)continue;
		if(path+D[i]>=bb)continue;	//预测减枝
		
		VIS[i]=true;
		DFS(i,path+G[index][i]);
		VIS[i]=false;
	}
}

void creat(){	//输入和生成图
	fill(G[0],G[0]+nA*nA,inf);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>P[i].x>>P[i].y;
	}
	for(int i=0;i<m;i++){
		int a,b;
		cin>>a>>b;
		double t=dis(a,b);
		G[a][b]=t;G[b][a]=t;
	}
}

int main(){
	creat();	//输入和生成图，完成准备工作
	
	DIJ(n);		//获得各点到终点的最短路径
	fill(VIS,VIS+nA,false);		
	VIS[1]=true;	//第一点加入DFS
	DFS(1,0);	//第一点加入DFS，此时总长度为0；
	
	if(bb==inf)cout<<"-1"<<endl;
	else{
		cout<<fixed<<setprecision(2)<<bb<<endl;
	}
	
	return 0;
}
```


---

## 作者：noall (赞：1)

dj,好像只有两篇。把注释写得全了点。看代码吧。

这里引用前面大佬所说的：

>次短路模版题。首先找出一条最短路，之后一次去掉一条最短路上的边，对于每一次去掉一条边后的图都跑一次最短路，其中最小的答案就是次短路。

>为什么要去掉最短路上的一条边呢？因为次短路和最短路必然至少有一条边不是共有的。为什么不去掉不在最短路上的边呢？因为这样最短路是没有变化的。

```c++
#include<cstdio>
#include<cmath>
#include<queue>
#include<iostream>
using namespace std;

const int INF=1e9+7;
const int maxn=210;
const int maxm=50000;

struct edge{int to,next;double w;}map[maxm];

int head[maxn],size,x[maxn],y[maxn],n,m,tot;
typedef pair<double,int>node;
double d[maxn],ans=INF;
int rem[maxn];
//求两点之间的距离（两点之间距离公式） 
double far(int x1,int y1,int x2,int y2){return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));}

void add(int from,int to,double w){
    map[++size].to=to;
	map[size].w=w;
    map[size].next=head[from];
    head[from]=size;
    return ;
}

void dijkstra(int a,int b){//删除a和b相连的边 
    bool vis[maxn]={0};
    for(int i=1;i<=n;i++) d[i]=INF;
    d[1]=0;
    priority_queue<node,vector<node>,greater<node> >Q;//建堆 
    Q.push(node(0,1));//将第一个点加到堆里 
    while(!Q.empty()){
        int u=Q.top().second;
        double w=Q.top().first;
        Q.pop();
        if(!vis[u]){//如果没有访问过 
        	vis[u]=true;
        	for(int i=head[u];i;i=map[i].next){
            	edge e=map[i];
            	if((u==a&&e.to==b)||(u==b&&e.to==a)) continue;//若此边被删，就不走了 
            	if(d[e.to]>w+e.w){
                	if(a==-1&&b==-1) rem[e.to]=u;//当找次短路时，不记录路径 
                	d[e.to]=w+e.w;//更新当前该点最短路 
                	if(!vis[e.to]) Q.push(node(d[e.to],e.to));//若没有访问过，将它所连接的点加到堆里 
            	}
        	}
		}
    }
    return ;
}

int main(){
    double w=0.0;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) scanf("%d%d",&x[i],&y[i]);
    for(int i=1;i<=m;i++){
		int from,to;
        scanf("%d%d",&from,&to);
        w=far(x[from],y[from],x[to],y[to]);
        add(from,to,w),add(to,from,w);//双向边 
    }
    dijkstra(-1,-1);
    int now=n;
    while(rem[now]){//从终点倒序删边，每次删除最短路的其中一条边。边界就是0。 
        dijkstra(rem[now],now);//删除 rem[now],now 相连的边 
        ans=min(d[n],ans);//更新最小值 即为 次短路 
        now=rem[now];//更新当前点 
    }
    if(ans==INF) printf("-1\n");//其实等于 不存在任何最短路 或 只存在一条路 
    else printf("%.2lf",ans);
    return 0;
}
```

---

## 作者：冰桨 (赞：1)

大体思路是先跑一边最短路，用last数组表示出最短路径上的点，用b数组保存，然后枚举最短路上的边，用tis数组将此边标记，跑最短路，跑完之后要删除标记，用ans存最小的即为第二短路。
```cpp
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<queue>
using namespace std;
const int N=1010101;
int n,m,head[N],vis[N],cnt,tis[600][600],last[N],b[N],x[N],y[N];
double dis[N],ans=0x7fffffff;
struct node{
	int next,to;
	double dis;
}e[N];
struct edge{
	int l;
	double d;
	bool operator<(const edge&a)const{
	return d>a.d;
	}
};
void add(int from,int to,double dis){
	e[++cnt].next=head[from];
	e[cnt].to=to;
	e[cnt].dis=dis;
	head[from]=cnt;
}
double check(int l,int r){
	return (double) sqrt(1.0*((x[l]-x[r])*(x[l]-x[r])+(y[l]-y[r])*(y[l]-y[r])));
}
priority_queue<edge>q;
void dij(int x){
	for(int i=1;i<=n;i++) dis[i]=0x7fffffff;
	dis[x]=0;
	memset(vis,0,sizeof(vis));
	q.push((edge){x,0});
	while(!q.empty()){
		edge p=q.top();
		q.pop();
		int u=p.l;
		if(vis[u]) continue;
		vis[u]=1;
		for(int i=head[u];i;i=e[i].next){
			int v=e[i].to;
			if(tis[u][v]||tis[v][u]) continue;
			if(dis[v]>dis[u]+e[i].dis){
				dis[v]=dis[u]+e[i].dis;
				last[v]=u;
				q.push((edge){v,dis[v]});
			}
		}
	}
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	scanf("%d%d",&x[i],&y[i]);
	for(int i=1;i<=m;i++){
		int sx,sy;
		scanf("%d%d",&sx,&sy);
		add(sx,sy,check(sx,sy));
		add(sy,sx,check(sx,sy));
	}
	dij(1);
	for(int i=1;i<=n;i++) b[i]=last[i];
	int f=n;
	while(f!=1){
		tis[b[f]][f]=tis[f][b[f]]=1;
		dij(1);
		ans=min(ans,dis[n]);
		tis[b[f]][f]=tis[f][b[f]]=0;
		f=b[f];
	}
	if(ans==0x7fffffff) printf("-1\n");
	else 
	printf("%.2lf\n",ans);
	return 0;
}
```


---

## 作者：heheabc (赞：1)

次短路，先用dijkstra求出最短路，显然，次短路的大部分和最短路是重合的。每次删除最短路路径中的一条边，然后在跑一边dijkstra，这样一共能求出路径长度个dis值，排序输出最小的即可。

既然后面需要删除最短路路径中的边，那么第一次求最短路时就要把路径也求出来。这其实很简单，用path[i]数组记录i点从哪个点走过来。一开始path数组清空为-1，表示都无法到达，path[1]记为1，每次v点的最小值更新时，path数组连带更新即可。最后从path[n]倒着往前找，知道path[i]==i即可。

（代码中dijkstra使用了stl堆优化）

代码：

```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<queue>
using namespace std;
pair<int,int>pa;
priority_queue<pair<double,int>,vector<pair<double,int> >,greater<pair<double,int> > >Q;
int n,m,a,b,wp1,wp2,cnt,num,len,x[205],y[205],nod[205],path[205],Next[100005],vet[100005],head[205];
double vp1,vp2,value[100005],dis[100005],ans[205];
bool vis[100005];
double calc(int a,int b)
{
    return sqrt((x[b]-x[a])*(x[b]-x[a])+(y[b]-y[a])*(y[b]-y[a]));
}
void add(int x,int y,double z)
{
    vet[++num]=y;
    value[num]=z;
    Next[num]=head[x];
    head[x]=num;
}
void dijkstra()
{
    for (int i=1; i<=n; i++)
    {
        dis[i]=1000000000;
        vis[i]=false;
        path[i]=-1;
    }
    dis[1]=0;
    path[1]=1;
    for (int i=1; i<=n; i++) Q.push(make_pair(dis[i],i));
    while (!Q.empty())
    {
        pair<double,int> t=Q.top();
        Q.pop();
        int u=t.second;
        if (vis[u]) continue;
        vis[u]=true;
        for (int i=head[u]; i; i=Next[i])
            if (dis[u]+value[i]<dis[vet[i]])
            {
                dis[vet[i]]=dis[u]+value[i];
                path[vet[i]]=u;
                Q.push(make_pair(dis[vet[i]],vet[i]));
            }
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    for (int i=1; i<=n; i++)
        scanf("%d%d",&x[i],&y[i]);
    for (int i=1; i<=m; i++)
    {
        scanf("%d%d",&a,&b);
        add(a,b,calc(a,b));
        add(b,a,calc(b,a));
    }
    dijkstra();
    if (dis[n]>=1e9)
    {
        printf("-1");
        return 0;
    }
    int now=n;
    while (path[now]!=now)
    {
        nod[++len]=now;
        now=path[now];
    }
    nod[++len]=1;
    for (int i=1; i<=len-1; i++)
    {
        int u=nod[i];
        int v=nod[i+1];
        for (int j=head[u]; j; j=Next[j])
            if (vet[j]==v)
            {
                wp1=j;
                vp1=value[j];
                value[j]=1e9;
                break;
            }
        for (int j=head[v]; j; j=Next[j])
            if (vet[j]==u)
            {
                wp2=j;
                vp2=value[j];
                value[j]=1e9;
                break;
            }
        dijkstra();
        ans[++cnt]=dis[n];
        value[wp1]=vp1;
        value[wp2]=vp2;
    }
    sort(ans+1,ans+cnt+1);
    if (cnt==0) printf("-1\n");
    else printf("%.2lf\n",ans[1]);
    return 0;
}
```

---

## 作者：加勒比·史努比 (赞：0)

 ## Solve
 
 1.次短路+SPFA。
 
 2.SPFA找最短路，并记录路径。
 
 3.删去最短路径中的一条边，并用SPFA寻找最短路。
 
 4.重复3的步骤，其中最小值即为答案。
 
 ## Tip
 
 1.此题并不是严格次短路，即答案可能与最短路的值相同。
 
 2.步骤3中SPFA完成之后别忘了还原回去。
 
 ## Code
 ```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cmath>
#include<cstring>
#include<algorithm>
#define maxn 336860180  //定义一个最大范围
#define N 100000 
using namespace std;  //标准开头
int n,m,len;  //n,m-同题，len-邻接表边数
double x[N],y[N],dis[N],ans1,ans2=maxn;  //x,y-点的坐标，dis-最短路，ans1-最短路，ans2-步骤3中的最小值
int e,r;  //边的两点
int first[N],next[N],f[N][3];  //first,next-邻接表，f[i][1]-节点i的前驱边，f[i][2]-节点i的前驱点
bool vis[N];  //SPFA中的bool数组
struct note{  //邻接表
	int v;
	double w;
	bool fb;  //若fb为true,则此边已删
}d[N];
double dist(double x1,double y1,double x2,double y2){  //两点求距离
	return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
}
void add(int e,int r,double distt){  //建立邻接表
	d[++len].v=r;
	d[len].w=distt;
	next[len]=first[e];
	first[e]=len;
}
void spfa()  //步骤2的SPFA
{
	for(int i=1;i<=n;i++) dis[i]=maxn;
	memset(vis,false,sizeof(vis));
	dis[1]=0;
	queue<int> q;
	q.push(1);
	while(!q.empty()){
		int e=q.front();
		q.pop();
		vis[e]=false;
		for(int i=first[e];i!=-1;i=next[i]){
			if(dis[d[i].v]>dis[e]+d[i].w){
				f[d[i].v][1]=e;
				f[d[i].v][2]=i;
				dis[d[i].v]=dis[e]+d[i].w;
				if(!vis[d[i].v]){
					vis[d[i].v]=true;
					q.push(d[i].v);
				}
			}
		}
	}
}
void spfaa()  //步骤3中的SFPA
{
	for(int i=1;i<=n;i++) dis[i]=maxn;
	memset(vis,false,sizeof(vis));
	dis[1] = 0;
	queue<int> q;
	q.push(1);
	while(!q.empty()){
		int e=q.front();
		q.pop();
		vis[e]=false;
		for(int i=first[e];i!=-1;i=next[i]){
			if(dis[d[i].v]>dis[e]+d[i].w&&!d[i].fb){
				dis[d[i].v]=dis[e]+d[i].w;
				if(!vis[d[i].v]){
					vis[d[i].v]=true;
					q.push(d[i].v);
				}
			}
		}
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) cin>>x[i]>>y[i],first[i]=-1;
	for(int i=1;i<=m;i++){
		scanf("%d%d",&e,&r);
		add(e,r,dist(x[e],y[e],x[r],y[r]));
		add(r,e,dist(x[e],y[e],x[r],y[r]));
	}
	spfa();
	int s=n;
	ans1=dis[n];
	if(ans1==maxn){
		cout<<"-1";
		return 0;
	}
	while(s!=1){
		d[f[s][2]].fb=true;
		spfaa();
		if(ans1==dis[n]){
			printf("%.2lf",ans1);
			return 0;
		}
		d[f[s][2]].fb=false;  //还原
		s=f[s][1];
		ans2=min(ans2,dis[n]);
	}
	if(ans2==maxn) cout<<"-1";
	else printf("%.2lf",ans2);
	return 0;
}
```


---

## 作者：QWsin (赞：0)

-> ->次短路  第一次写  挺裸的

-> ->本来以为要加A\*才能过  但那好像是第k短路专属装bi算法  学不会= =

-> ->我用方法的是 先一次dijkstra之后  记录一下前驱

-> ->然后每次去掉一条边再跑dij   去掉边的话 我用的是在dij里面特判不能走这一条边（因为前驱只会记录点 不会记录边）

-> ->然后注意一下int和double

-> ->然后对于第二次以后  的dij取里面最小的

-> ->至于为什么要这么干  我引用一下楼下下。。神犇的证明

-> ->【引用】

-> ->为什么要去掉最短路上的一条边呢？因为次短路和最短路必然至少有一条边不是共有的。为什么不去掉不在最短路上的边呢？因为这样最短路是没有变化的。

-> ->感觉好有道理的样子

代码：（想不通这都有100行= =）

```cpp

#include<queue>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int maxn=200+10;
const int maxm=40000+10;
const int INF=(1<<30);
struct Point{
             int x,y;
             Point(){}
             Point(int x,int y):x(x),y(y){}
             double dis(const Point &rhs) const{
                          double ox=rhs.x-x,oy=rhs.y-y;
                          return sqrt(ox*ox+oy*oy);
             }
             void input(){                                            //这两个函数就是看着好玩的= =
                          scanf("%d%d",&x,&y);
             }
}p[maxn];

struct Node{
             int u;
             double d;
             Node(){}
             Node(int u,double d):u(u),d(d){}
             bool operator < (const Node &rhs)const{  //优先队列要用
                          return d>rhs.d;
             }
};

int n,m,first[maxn],next[maxm*2],u[maxm*2],v[maxm*2];
double w[maxm*2];

void init_data()
{
             cin>>n>>m;
             for(int i=1;i<=n;i++) p[i].input(),first[i]=-1;
             for(int i=1;i<=2*m;i+=2) 
             {
                          scanf("%d%d",u+i,v+i);
                          w[i+1]=w[i]=p[u[i]].dis(p[v[i]]);
                          next[i]=first[u[i]];
                          first[u[i]]=i;
                          u[i+1]=v[i];
                          v[i+1]=u[i];
                          next[i+1]=first[v[i]];
                          first[v[i]]=i+1;
             }
}

double d[maxn];
int pre[maxn],vis[maxn];
void Dijkstra(int f,int t)
{
             priority_queue<Node>q;
             for(int i=2;i<=n;i++) d[i]=INF;
             d[1]=0;
             if(f==-1)pre[1]=-1;    //特判  只有第一次需要记录pre
             memset(vis,0,sizeof(vis));
             q.push(Node(1,0));
             while(!q.empty())
             {
                          Node x=q.top();q.pop();
                          if(vis[x.u]) continue;
                          vis[x.u]=1;
                          for(int i=first[x.u];i!=-1;i=next[i])
                          {
                                       if(d[v[i]]>w[i]+d[x.u]&&!(x.u==f&&v[i]==t))//后半句特判不能走的边
                                       {
                                                    d[v[i]]=w[i]+d[x.u];
                                                    if(f==-1) pre[v[i]]=x.u;
                                                    q.push(Node(v[i],d[v[i]]));
                                       }
                          }
             }
}

int main()
{
             init_data();
             Dijkstra(-1,-1);//选-1明显是为了防止冲突-> ->
             double ans=INF;
             for(int t=n;t!=1;t=pre[t])
             {
                          Dijkstra(pre[t],t);
                          ans=min(ans,d[n]);    
             }
             printf("%.2f",ans);
             return 0;
}


```

---


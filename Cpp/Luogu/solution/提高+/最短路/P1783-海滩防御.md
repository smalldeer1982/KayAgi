# 海滩防御

## 题目描述

WLP 同学最近迷上了一款网络联机对战游戏（终于知道为毛 JOHNKRAM 每天刷洛谷效率那么低了），但是他却为了这个游戏很苦恼，因为他在海边的造船厂和仓库总是被敌方派人偷袭。于是，WLP 动用了他那丰满且充实的大脑（或许更偏向前者），想出了一个好主意，他把海滩分成垂直于海岸线的若干列，在其中的几列上放置几个信号塔，试图来监视整个海滩。然而，WLP 是一个非常心急的人，他把信号塔建好后才发现还需给信号塔供能，它们才能投入使用（这不是废话么），它们都有一个工作半径，一个圆形区域里的所有敌人都逃不过它们的监视，不过，WLP 发现，敌人们非常狡猾，除非他将道路完全封死，否则 WLP 的敌人可以走过一条任意弯曲的路（不一定走整点，但是不会出第 $0$ 列和第 $N$ 列构成的边界）来偷他的东西。

于是，WLP 就思考了：到底需要给每个信号塔多大的工作半径，才能将从海滩到内地的路径完全封死呢？他再次动用了他那丰满且充实的大脑，想了一堂数学课，终于，还是没想出来。于是，他向 LZZ 神犇求助（额…… CSUNSHINE 的身份是不是暴露了）。

终于，在 WLP：“ %^!\*@#!\*(\*^!\*#@\$^&（此处省略无数卖萌场景）”的哀求下，LZZ 神犇写了一个程序，在一秒内就解决了问题。但是，邪恶的 LZZ 神犇决定要将这个难题共享给无数无辜的 OIer，所以，现在轮到你了。

## 说明/提示

### 数据范围及约定

- 对于 $10\%$ 的数据：$1 \le M \le 10$，$1 \le Y_i \le 100$；
- 对于 $30\%$ 的数据：$1 \le M \le 50$，$1 \le Y_i \le 1,000$；
- 对于 $80\%$ 的数据：$1 \le M \le 500$，$1 \le Y_i \le 1,000$；
- 对于 $100\%$ 的数据：$1 \le M \le 800$，$1 \le N \le 1000$，$1 \le X_i \le N$，$1 \le Y_i \le 100,000$。

### 提示

注意，封锁海滩是指，敌人的深入程度是有限制的，若敌人绕过了所有的信号塔，并且可以长驱直入，那么就说明道路没有完全封锁。

## 样例 #1

### 输入

```
5 5
1 5
3 5
5 5
4 30
2 15```

### 输出

```
1.00```

## 样例 #2

### 输入

```
100 2
30 50
90 100```

### 输出

```
39.05```

# 题解

## 作者：C_SUNSHINE (赞：28)

这题刚开始很多人会想到二分，二分答案，然后看看是否能绕过所有信号塔，但是，这样写明显超时，对于任何一个点，要找到离它最近的信号塔需要O(n)的时间，再乘上M\*L（L=海滩的长度）不超时才怪呢。

这一题的本质就是封锁海滩，即用信号塔的工作范围将两边的边界连在一起。所以，这题就是求一条从第0列到第n列的最短路径，用点与边界的距离作为权值，点与点之间的距离的二分之一作为权值，构图完成后，用Dijkstra算法求最短路就可以了。当然用Kruskal算法并查集结构依次加最小边，直到两条边界被连在一起也是可以的。但是要注意最短路的长度是路径上边权的最大值，而不是边权之和。



```cpp

#include<stdio.h> //By C_SUNSHINE
#include<math.h>
#include<iostream>
using namespace std;
const int maxn=805;
int n,w;
struct edge
{
       int u,v;
       float c;
}e[maxn*maxn];
int x[maxn],y[maxn],W;
int f[maxn];
float getdist(int i,int j)
{
  return sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));
}
bool cmp(edge e1,edge e2)
{
  return e1.c<e2.c;
}
int getfather(int root)
{
  if(f[root]==-1)return root;
  else return f[root]=getfather(f[root]);
}
void init()
{
     memset(f,-1,sizeof(f));
     n=0;w=0;
     scanf("%d%d",&W,&n);
     if(n==0)exit(0);
     int i,j;
     for(i=1;i<=n;i++)
       scanf("%d%d",y+i,x+i);
     for(i=1;i<n;i++)
       for(j=i+1;j<=n;j++)
         e[++w]=(edge){i,j,getdist(i,j)/2};
     for(i=1;i<=n;i++)
     {
         e[++w]=(edge){i,0,y[i]};
         e[++w]=(edge){i,n+1,W-y[i]};
     }
     sort(e+1,e+w+1,cmp);
}
void work()
{
     int i=0,p,q;
     while(getfather(0)!=getfather(n+1))
     {
       i++;
       p=getfather(e[i].u);
       q=getfather(e[i].v);
       if(p!=q)f[p]=q;
     }
     printf("%.2f\n",e[i].c);
}
int main()
{
    init();
    work();
    return 0;
}


```

---

## 作者：Akeryep (赞：22)

# 简单题解，看不懂我直播去世
## 对题目分析一下我们发现这个有点像[noip2017奶酪](https://www.luogu.org/problem/P3958)
事实上我觉得这个题比奶酪还要水，并查集就足够了
## 算法：排序+并查集
我们只需要将海滩左界和右界连在一起就ok了，什么最短路啊，二分啥的太麻烦   
下面说做法


------------
读入坐标后，预处理一下各个防御塔之间的距离放入结构体里（方便我们排序）
再给每个防御塔连一条和左边界，右边界的边。
**注意，与左右边界连边时要将距离乘二，原因是两个防御塔之间要连接只需要一半距离的攻击范围即可，但与边界间就只能靠防御塔自己一个人了**
然后按距离从小到大排序，依次连边，每次检查左右边界是否连接即可。下面是代码
```c
#include<bits/stdc++.h>
using namespace std;
int n,m;	//n 列 m 塔  
int a[1000],b[1000];	//存储列以及距海边距离，就是坐标
int f[1000];	//并查集用
struct node{int x,y;	double dis;}ju[1000000];	//存边用
int cnt=0;
double dis(int x1,int y1,int x2,int y2)
{
	return (double)sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
}	//返回两点距离
bool comp(node x,node y)
{
	return x.dis<y.dis;
}	//排序用
int find(int x)
{
	if(f[x]!=x)	return f[x]=find(f[x]);
	return x;
}	//并查集找老祖宗
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)		
			{
				scanf("%d%d",&a[i],&b[i]);	
				f[i]=i;
			}			
	for(int i=1;i<m;i++)
		for(int j=i+1;j<=m;j++)		
		{
			ju[++cnt].dis=dis(a[i],b[i],a[j],b[j]),ju[cnt].x=i,ju[cnt].y=j;	
		}
	for(int i=1;i<=m;i++)
		ju[++cnt].x=i,ju[cnt].y=0,ju[cnt].dis=a[i]*2,ju[++cnt].x=i,ju[cnt].y=m+1,ju[cnt].dis=(n-a[i])*2;
        //这里用来将每个防御塔和边界建边	左边界0，右边界m+1
	sort(ju+1,ju+1+cnt,comp);
	f[m+1]=m+1;
	int ans;
	for(int i=1;i<=cnt;i++)
	{
		int x=ju[i].x;int y=ju[i].y;
		int r1=find(x);
		int r2=find(y);
		if(r1!=r2)	f[r1]=r2;		
		if(find(0)==find(m+1))	
		{
			ans=i;break;
		}
	}	
	printf("%.2lf",ju[ans].dis/2);	//范围是距离除以2
	return 0;
}
完事okkkk

```


---

## 作者：CURRENT_F (赞：15)

这个题，出题人说不能二分，但是我用二分过了，可能是判断方法和出题人想的不一样？但实际上还是很慢，或许写个堆优dij可能快些。。。


对于一个能够挡住所有道路的情况 ， 我们可以发现 它们的圆心连线一定覆盖了 最接近0 的点和最接近n的点的中间部分，边界特殊考虑一下就可以。。


思路 ： 先建立两个虚点，分别在0 和 n （我写个-1 n+1 是为了排序方便） 然后建边，0 和 n 有些特殊 ，边长是垂直行的距离，其他的就是两点间距离除以二了，判断是否联通我用了 暴力 dij 。



```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstring>
#include <algorithm>
using namespace std;
int n,m;

struct ppp{
    double x,y;
}p[1100];

struct node{
    double dis;
    int to,nxt,k;
}edg[2000050];
int head[1100],num,pppp;
void add_e(int a,int b,double dis,bool flag){
    if(!flag) edg[++num].dis=sqrt((p[a].x-p[b].x)*(p[a].x-p[b].x)+(p[a].y-p[b].y)*(p[a].y-p[b].y))/2;
    else edg[++num].dis=dis;
    edg[num].k=pppp;
    edg[num].to=b;
    edg[num].nxt=head[a];
    head[a]=num;
}

double dis[1100];int vis[1100];
int check(double mid){  //dij
    memset(dis,0x7f,sizeof(dis));
    memset(vis,0,sizeof(vis));
    dis[1]=0;
    double minl=0x7fffffff;int px;
    for(int i=1;i<=m+2;i++){
        minl=0x7fffffff;
        for(int j=1;j<=m+2;j++){
            if(!vis[j]&&minl>dis[j]){
                minl=dis[j];px=j;
            }
        }
        vis[px]=1;
        int t=head[px];
        while(t!=0){
            if(!vis[edg[t].to]&&dis[px]+edg[t].dis<dis[edg[t].to]&&edg[t].dis<=mid){
                dis[edg[t].to]=dis[px]+edg[t].dis*edg[t].k;
            }
            t=edg[t].nxt;
        }
    }
    if(dis[m+2]==dis[m+13])
        return 0;
    else 
        return 1;
}

int cmp(const ppp &a,const ppp &b){
    return a.x<b.x;
}

int main(){
    ios::sync_with_stdio(false);
    
    cin>>n>>m;
    
    int x,y;
    for(int i=1;i<=m;i++){
        cin>>x>>y;
        p[i].x=x;
        p[i].y=y;
    }
    
    //½¨±ß 
    p[m+1].x=-1;
    p[m+2].x=n+1;
    sort(p+1,p+m+3,cmp);
    pppp=2;
    for(int i=2;i<=m+1;i++){
        for(int j=2;j<i;j++){
            add_e(i,j,0,0);
            add_e(j,i,0,0);
        }
    }
    pppp=1;
    for(int i=2;i<=m+1;i++){
    //    add_e(i,1,p[i].x);
        add_e(1,i,p[i].x,1);
        add_e(i,m+2,(n-p[i].x),1);
    //    add_e(m+2,i,(n-p[i].x));
    }
    
    double l=0.5,r=1e7,mid;
    while(abs(l-r)>1e-6){
        mid=(l+r)/2;
        if(check(mid)) r=mid;
        else l=mid;
    }
    
    printf("%.2f",l);
    
    return 0;
}
```

---

## 作者：天上一颗蛋 (赞：12)

# 并查集 + 二分

我是 **并查集 + 二分** 做的QVQ

思路：两两枚举点之间的距离，sort排序，使距离有序。二分答案，每次判断是否符合条件，然后缩小查询范围，直到满足题目要求（保留2位小数精度就为 0.001就好了）最后保留两位小数输出


核心 判断是否符合条件：

对于每次判断，首先应初始化并查集。因为距离有序，一直并集直到两点距离大于（要判断的）k的两倍（k为每次二分检查的半径，两点距离大于半径即两点相离）为止。


（现在所有距离小于k\*2 都被联通了）两两枚举所有点，若有一点i离左海岸线的距离<k，说明点i在半径为k的条件下能够到左边界；同理，若有一点j离右海岸线的距离 + k > len说明点j在半径为k的条件下够得到右边界，如果i，j在同一集合内，说明成立（左边界->i->j->右边界；满足封锁）


需要注意的是：

并查集初始化需从0开始（读题）；

每次判断成立都要初始化并查集；


代码如下（注释并上）：

    
    
        
    
    
```cpp
    #include<iostream>
    #include<algorithm>
    #include<cmath>
    #include<cstdio>
    using namespace std;
    const int maxn = 1001100;
    int num,nr;//点数，边数
    int len;//海滩宽度
    int father[maxn];//并查集
    struct R{
        int u,v;
        double dis;
        }I[maxn];//边
    struct Node{
        int x,y;
        }N[maxn];//点
    bool cmp(R a,R b){
        return a.dis < b.dis;//sort的cmp函数
        }
        int findfather(int v){//查找祖先（注意压缩路径【不然也许会超时QAQ】）
        if(father[v] == v)return v;
        int F = findfather(father[v]);
        father[v] = F;
        return F;
        }
    void Union(int a,int b){//并集
        int faA = findfather(a);
        int faB = findfather(b);
        if(faA != faB){
            father[faA] = faB;
            }
        }
    bool check(double k){//判断函数
        for(int i = 0;i < num;i++)father[i] = i;//并查集每次初始化
        int i = 1;
        while(I[i].dis <= 2 * k && i <= nr){//在当前k下能连通的全部连通
            Union(I[i].u,I[i].v);
            i++;
            }
        for(int i = 0;i < num;i++){//两两枚举
            for(int j = 0;j < num;j++){
                if(findfather(i) == findfather(j) && N[i].x - k < 0 && N[j].x + k > len){        
                return 1;
                    }
                }
            }
        return 0;
        }
    double search(double l,double r){
        while(l + 0.001 < r){//二分，精度为0.001
            double mid = (l + r)/2;
                if(check(mid)){//成立就缩小上界
                r = mid;
                }
            else{
                l = mid;
                }
            }
        return r;
        }
    int main(){
        cin>>len>>num;//输入宽度和点数
        for(int i = 0;i < num;i++)father[i] = i;//并查集初始化
        for(int i = 0;i < num;i++){
            cin>>N[i].x>>N[i].y;//输入点坐标
            }
        for(int i = 0;i < num;i++){//两两枚举，计算点与点之间的距离
            for(int j = i;j < num;j++){
                I[++nr].u = i;
                I[nr].v = j;
                I[nr].dis =sqrt (1.0 * (N[i].x - N[j].x) * (N[i].x - N[j].x) + (N[i].y - N[j].y) * (N[i].y - N[j].y));//记得加math头文件
                }
            }
        sort(I + 1,I + nr + 1,cmp);//按距离从小到大排序
        printf("%.2f\n",search(0.0,10000000.0) );//输出
        return 0;
        }
End.(求过)
```

---

## 作者：ustze (赞：9)

~~实名~~反对那些说二分不能过的。
事实上，对于此题我们可以用O(m^2)的时间进行判断
总时间复杂度 O(m^2logn)，实测92ms，比其他大多数题解还要快
具体见代码
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<queue>
#include<cstring>
using namespace std;
const int N = 1005;
const double eps=1e-4;
int n,m;
int x[N],y[N];
int vis[N];
double dis[N][N];
queue<int> q;
inline int check(double mid)  //bfs判断
{
    memset(vis,0,sizeof(vis));
    vis[0]=1;
    q.push(0);
    while(!q.empty())
    {
        int v=q.front();q.pop();
        for(int i=1;i<=m+1;i++)
        {
            if(!vis[i])
            {
                if(i==m+1||v==0) {if(dis[v][i]<=mid) vis[i]=1,q.push(i);} //在边上
                else if(dis[v][i]<=2*mid) vis[i]=1,q.push(i); //两个信号塔之间是2*mid
            }
        }
    }
    return vis[m+1];
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&x[i],&y[i]);
        dis[0][i]=dis[i][0]=x[i];
        dis[m+1][i]=dis[i][m+1]=n-x[i];
    }
    dis[0][m+1]=(1<<30);
    for(int i=1;i<=m;i++)
        for(int j=i+1;j<=m;j++)
            dis[i][j]=dis[j][i]=sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])); //初始化距离数组
    double l=0,r=10005,ans,mid;
    while(r-l>=eps)  //二分
    {
        mid=(l+r)/2;
        if(check(mid)) r=mid,ans=mid;
        else l=mid;
    }
    printf("%.2lf",ans);
    return 0;
}
```

---

## 作者：pipiispig (赞：9)

###
这个题为什么要用二分答案做？最短路都不需要，一个变了点形的最小生成树算法就可以AC,也就是kruskal;

唯一的难点在于什么时候判断已经是联通的了，我们可以很显然的得到，0和n+1刚好可以连起来的时候就是最小值了，也就是说我们并不需要联通所有的点，只是需要让0点与n+1点连接，举个例子就是说我们可以连接0--1,1--3,3--n+1;我们是可以跳过2这个点的，所以我们就可以用并查集的性质，每次合并完成后求一次n+1节点与0节点的祖先，如果是同一祖先的话就证明可以了；
```
#include<iostream>
#include<algorithm> 
#include<cstring>
#include<cmath>
#include<cstdio>
using namespace std;

const int N=1005;

struct node{
    int x,y;
    double z;
};

node s[N*N/2];

int x[N],y[N],fa[N];

double oula(int x,int y,int z,int w)
{
    int xx=x-z;
    int yy=y-w;
    return sqrt(xx*xx+yy*yy);
}//是double类型的呢

int cmp(node x,node y)
{
    return x.z<y.z;
}

int find(int x)
{
    if(fa[x]==x)return x;
    return fa[x]=find(fa[x]);
}

int d[N],vis[N],cnt=0,sum=0,n,m;

double ans=0;

void kruskal()
{
    for(int i=1;i<=sum;i++)
    {
        int xx=find(s[i].x);
        int yy=find(s[i].y);
        if(xx!=yy)
        {
            fa[xx]=yy;
            ans=s[i].z;//因为已经排过序了，所以最后一个加入的路径一定是最长的，不需要ans=max(ans,s[i].z);
        }
        if(find(n+1)==find(0))return;//这就是要判断的东西，相信前面已经讲得很清楚了；
    }
} 

int main()
{
    cin>>n>>m;
    for(int i=1;i<=n*n/2;i++)fa[i]=i;//千万不要忘了这个，有的人可能习惯初始化祖先为0，但这其实很容易出错；
    for(int i=1;i<=m;i++)
    {
        cin>>x[i]>>y[i];
        for(int j=1;j<i;j++)
        {
            s[++sum]={(node){i,j,oula(x[i],y[i],x[j],y[j])*0.50}};   
        }
        s[++sum]={(node){0,x[i],(double)x[i]}};
        s[++sum]={(node){n+1,x[i],n-x[i]}};//这是个需要注意的地方，你需要求出每一个和边界的距离，我刚开始的时候忘了这个地方，结果只有10分（应该是很幸运的骗了10分）；
    }
    sort(s+1,s+sum+1,cmp);//最小生成树当然要从小到大排序呀；
    kruskal();//几乎就是板子；
    printf("%.2lf",ans);
}
```

---

## 作者：Mathison (赞：7)

[题目传送门](https://www.luogu.org/problemnew/show/P1783)

刚看到这道题想到的$\text{noip2017 day2 T1}$【奶酪】……

考虑到题面最大半径最小值，想到了**二分+并查集**……

二分最大半径最小值，搜完一遍最后如果在所有点在同一个集合就更新答案

但是TLE了几个点……看来不过快……

画了一个图，恍然大悟

这道题其实是个最短路

![](https://cdn.luogu.com.cn/upload/pic/35958.png)

显然最海岸的边缘的两个信号塔的工作范围至少是信号塔到海滩边缘的垂直距离

那么两个灯塔之间呢？

设两个塔之间的距离为$d$，两个信号塔探测范围分别是$r_1$和$r_2$，那么$r_1+r_2=d$，当且仅当$r_1=r_2=\frac{d}{2}$时最大半径的最小值为$\frac{d}{2}$。所以我们只需把把信号塔之间的最短路（或者说最小生成树也可以）计算出，找出最大的边长的$\frac{1}{2}$与两侧信号塔距离海滩边缘的距离进行比较，最大值便是最大半径的最小值。

所以我们在最短路操作中把更新路径总长度$dis[i]$的操作变为**更新最短路边长的最大值的$\frac{1}{2}$**。

我们不妨把海滩与灯塔的距离考虑成两条边，在加边的时候算作第$m+1$和第$m+2$条边，方便更新最值

以下是AC Code，里面还有注释

```
#include<bits/stdc++.h>
using namespace std;
const int N=850;
const int M=2*N*N;
int n,m,tot,head[N],ver[M],next[M],h[N];
double dx[N],dy[N],dis[N],edge[M];
bool vis[N];
priority_queue<pair<double,int> > q;
void add(int x,int y,double z)//加边
{
	ver[++tot]=y;
	edge[tot]=z;
	next[tot]=head[x];
	head[x]=tot;
}
double dist(int i,int j){return sqrt((dx[i]-dx[j])*(dx[i]-dx[j])+(dy[i]-dy[j])*(dy[i]-dy[j]));}//计算两点间距离
void dijskra(int st)//标准dijskra最短路
{
	memset(dis,127,sizeof dis);
	dis[st]=0;
	q.push(make_pair(0,st));
	while(q.size())
	{
		int x=q.top().second;q.pop();
		if(vis[x]) continue;
		vis[x]=1;
		for(int i=head[x];i;i=next[i])
		{
			int y=ver[i];double z=edge[i];
			if(dis[y]>max(dis[x],z))
			{
				dis[y]=max(dis[x],z);
				q.push(make_pair(-dis[y],y));
			}
		}
	}
} 
int main()
{
    scanf("%d%d",&n,&m);
    for (int i=1;i<=m;i++)
	{
		scanf("%lf%lf",&dx[i],&dy[i]);
        //加边（灯塔距离海滩边缘的距离）
        add(m+1,i,dx[i]);add(i,m+1,dx[i]);
        add(m+2,i,double(n)-dx[i]),add(i,m+2,double(n)-dx[i]);
    }
    for(int i=1;i<m;i++)
        for(int j=i+1;j<=m;j++)
            add(i,j,dist(i,j)/2.0),add(j,i,dist(i,j)/2.0);//信号塔之间加边（注意长度为距离的1/2）
    dijskra(m+1);//以其中海滩一边为起点
    printf("%.2lf",dis[m+2]);//另一边为终点
    return 0;
}
```

---

## 作者：to_be_continued (赞：2)

## [更好的体验](https://www.luogu.com.cn/blog/renquanbang/)

膜你赛搬的题，讲课时他们都说用二分+并查集，我用二分+DFS就可以艹过去了

由于语文水平太差读了好长时间的题目才理解，题目类似于一张纸片，上面有n个点以这n个点为圆心，求最小的半径，使纸片可以裂开，也就是有一条路径上面都被圆覆盖

看到最小首先想到二分答案，二分这个最小的半径，然后我们想到首先我们要和两边有交点，然后对于每个有交点的点dfs，能到达另一边就说明这是一个答案。

那么如何dfs呢，先预处理出每个点之间的距离，确定半径后，如果两个圆有交，那么他们的距离一定小于2 * 半径，去一下重，就可以以较为优秀的时间复杂度过了。



------------

code
```cpp
#include<bits/stdc++.h>

using namespace std;

inline int read(){
    int AK = 1, IOI = 0;
    char ch = 0;
    while (ch < '0' || ch > '9'){
        AK = ch=='-'?-1:1;
        ch = getchar();
    }
    while (ch <= '9' && ch >= '0'){
        IOI *= 10;
        IOI += ch - 48;
        ch =  getchar();
    }
    return AK * IOI;
}
inline void Print(int b){
    if (b < 10){
        putchar(b + '0');
        return;
    }
    Print(b / 10);
    putchar(b % 10 + '0');
}

struct nod{
    int b, a;
} a[1001];
double l[1001][1001];
int n, m;

inline bool cmp(nod b, nod a){
    return b . a < a . a;
}
bool bo[1001];
bool boo;
inline double sqr(double b){
    return b * b;
}
inline void dfs(int x, double y){
    if ((m - a[x] . a) <= y){//如果已经可以碰到顶了，那么结束
        boo = 1;
        return;
    }
    if (boo){//如果已经有答案了那么不必要继续找下去
        return;
    }
    for (int i = 1; i <= n; i ++){
        if (!bo[i] && l[i][x] <= y * 2){//去找没有经过的且能到的点
            bo[i] = 1;
            dfs(i, y);
        }
    }
}
inline bool check(double b){
    memset(bo, 0, sizeof(bo));
    for (int i = 1; i <= n; i ++){//因为我们的数组是有序的，所以如果当前的点已经是高于半径了，那么这个点和接下去的所有点都不能碰到底，剪枝
    //经测试这个剪枝貌似不加也不会T，能剪枝就剪，让时间更优秀才是一个oier该做的
        if (a[i] . a <= b){
            if (! bo[i]){
                bo[i] = 1;
                boo = 0;
                dfs(i, b);
                if (boo){
                    return 1;
                }
            }
        } else{
            break;
        }
    }
    return 0;
}
int main(){
    m = read(), n = read();
    for (int i = 1; i <= n; i ++){
        a[i] . a = read();
        a[i] . b = read();
    }
    sort(a + 1, a + 1 + n, cmp);//可以剪枝
    for (int i = 1; i < n; i ++){//先预处理出每个点之间的距离
        for (int j = i + 1; j <= n; j ++){
            l[i][j] = sqrt(sqr (a[i] . b - a[j] . b) + sqr (a[i] . a - a[j] . a));
            l[j][i] = l[i][j];
        }
    }
    double answer = 0;
    double left = 0, right = m;//二分答案 边为m
    while ((right - left) >= 1e-5){//保证精度
        double middle = (left + right) / 2;
        // printf("%0.2lf %0.2lf %0.2lf\n", left, right, middle);
        if (check(middle)){
            answer = middle;
            right = middle;
        } else{
            left = middle;
        }
    }
    printf("%0.2lf", answer);
}
```


---

## 作者：thelast (赞：2)

## 并查集+生成树
题目要求：简单来讲，应该是使左右两端相连通，且最大的那个边最小。

分析一下，实际上类似与P1396营救，本质上，并不要求是最短路，而是在将边从大到小排序后用前n条边就能使左右两端相连，且使n最小，那么，我们可以尝试用克鲁斯卡尔的算法，将边从小到大排序，然后依次加入树中，如果说fa[l]==fa[r]，即左边的根和右边的根连到一起，那么，就是这个边的一半。

代码实现：
```
for(int i=1;i<=m;i++){
		scanf("%d%d",&f[i].x,&f[i].y);
		for(int j=1;j<i;j++)add(i,j);
		ft[++num].fr=l;ft[num].to=i;ft[num].w=(double)(f[i].x);
		ft[++num].fr=r;ft[num].to=i;ft[num].w=(double)(n)-(double)(f[i].x);
	}	
```
首先是建边的过程（关键），每输入一个点，都需要将第i个点个1～i-1个点一次建边，边权为长度的一半（因为圆是从两边都可以走的），同时，在下面在加上和l,r，的建边，（提前设置好l和r）边权为横坐标和n-横坐标，最后，生成树，输出边即可。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,num,fa[20000],l,r;
struct poin{
	int x,y;
}f[8001];
struct edge{
	int fr,to;
	double w;
}ft[800*8001];
void add(int a,int b){
	double w1=sqrt(pow(f[a].x-f[b].x,2)+pow(f[a].y-f[b].y,2))/2.0;
	ft[++num].fr=a;ft[num].to=b;ft[num].w=w1;
}
int fin(int x){
	if(fa[x]!=x)fa[x]=fin(fa[x]);
	return fa[x];
}
bool cmp(edge a,edge b){return a.w<b.w;}
int main(){
	cin>>n>>m;
	l=m+1,r=m+2;
	for(int i=1;i<=m+2;i++)fa[i]=i;
	for(int i=1;i<=m;i++){
		scanf("%d%d",&f[i].x,&f[i].y);
		for(int j=1;j<i;j++)add(i,j);
		ft[++num].fr=l;ft[num].to=i;ft[num].w=(double)(f[i].x);
		ft[++num].fr=r;ft[num].to=i;ft[num].w=(double)(n)-(double)(f[i].x);
	}	
	sort(ft+1,ft+1+num,cmp);
	for(int i=1;i<=num;i++){
		int r1=fin(ft[i].fr),r2=fin(ft[i].to);
		if(r1!=r2)fa[r2]=r1;
		if(fin(l)==fin(r)){
			printf("%.2lf\n",ft[i].w);
			return 0;
		}
	}
}
```


---

## 作者：saligia (赞：2)

为什么没人写最短路（二分答案多麻烦啊qwq）

堆优化dijkstra

思路楼上都讲的很明白了，因为要求路径最大值最小，所以只要改一下松弛的式子就好了↓
```cpp
if (dis[v]>max(dis[u],e[i].val)){
	dis[v]=max(dis[u],e[i].val);
	q.push(mp(dis[v],v));
}
```
这样dis[i]就是源点到i的路径中最大的边是多少，且这条最大的边最小

以下完整代码↓↓↓

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<queue>
#include<vector>
#define maxm 850
#define pp pair<double,int>//注意不要顺手写成int,int 
#define mp make_pair
using namespace std;
int n,m,tot;
int h[maxm],vis[maxm];
double px[maxm],py[maxm],dis[maxm];
struct node{
	int to,nxt;
	double val;
}e[maxm*maxm*2];

inline void add(int x,int y,double z){
	e[++tot].to=y;
	e[tot].nxt=h[x];
	e[tot].val=z;
	h[x]=tot;
	return;
}//建边 

inline double calc(int i,int j){
	return sqrt((px[i]-px[j])*(px[i]-px[j])+(py[i]-py[j])*(py[i]-py[j]));
}//计算两点距离 

void dij(){
	priority_queue<pp,vector<pp >,greater<pp> > q;//堆优化
	for (int i=1;i<=m+5;++i) dis[i]=1e9;//初始化 
	dis[m+1]=0;//从m+1出发 
	q.push(mp(0,m+1));
	while (!q.empty()){
		int u=q.top().second;
		q.pop();
		if (vis[u]) continue;
		vis[u]=1;
		for (int i=h[u];i;i=e[i].nxt){
			int v=e[i].to;
			if (dis[v]>max(dis[u],e[i].val)){
				dis[v]=max(dis[u],e[i].val);//松弛 
				q.push(mp(dis[v],v));
			}
		}
	}
	return;
}

int main(){
	cin>>n>>m;
	for (int i=1;i<=m;++i){
		cin>>px[i]>>py[i];
		add(m+1,i,px[i]);
		add(i,m+1,px[i]);
		add(m+2,i,double(n)-px[i]);
		add(i,m+2,double(n)-px[i]);
		//m+1是沙滩的左边界，m+2是沙滩的右边界
		//求的就是m+1到m+2的路径最大值最小 
	}
	for (int i=1;i<m;++i){
		for (int j=i+1;j<=m;++j){
			add(i,j,calc(i,j)/2.0);
			add(j,i,calc(i,j)/2.0);
		}
	}//两两加边，两个圆相切时刚好联通，所以要除以2 
	dij();
	printf("%.2lf",dis[m+2]);//保留两位小数 
	return 0;
}
```

---

## 作者：PTC06 (赞：2)

这个程序的思路就是楼下所说的第二种思路：用Kruskal依次加最小边，直到边界被连起来。


思路：

输入N，M以及M个位置。


由于这里输入的是M个信号塔的位置，而不是这些塔之间的路，所以在这题里需要用双重循环将每个点之间建一条边。

还需要将这M个点都与两个边界之间建一条边，也就是“只用这个塔，工作半径为n-x[i]”的情况。


然后就按照Kruskal的固定套路先排序，再依次加最小边，直到边界被连在一起。


程序：


        
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,i,j,k,pre[10005],x[1005],y[1005];
double ans,temp;
struct road
{
    int first;
    int second;
    double dis;
} a[1000000];
bool cmp(road x,road y)
{
    return x.dis<y.dis;
}
int sch(int x)
{
    if (pre[x]==x) return x;
    pre[x]=sch(pre[x]);
    return pre[x];
}
void BuildRoad()
{
    for (i=1;i<m;i++)
    {
        for (j=i+1;j<=m;j++)
        {
            k++;
            a[k].first=i;
            a[k].second=j;
            temp=sqrt((abs(x[i]-x[j])*abs(x[i]-x[j]))+(abs(y[i]-y[j])*abs(y[i]-y[j])))/2.0;
            a[k].dis=temp;
        }
    }
    for (i=1;i<=m;i++)
    {
        k++;
        a[k].first=i;
        a[k].second=0;
        a[k].dis=x[i];
        k++;
        a[k].first=i;
        a[k].second=n+1;
        a[k].dis=n-x[i];
    }
}
int main()
{
    cin>>n>>m;
    for (i=1;i<=n*n;i++) pre[i]=i;
    for (i=1;i<=m;i++)
    {
        cin>>x[i]>>y[i];
    }
    BuildRoad();
    sort(a+1,a+k+1,cmp);
    i=0;
    while (sch(0)!=sch(n+1))
    {
        i++;
        if (sch(a[i].first)!=sch(a[i].second))
        {
            pre[sch(a[i].first)]=sch(a[i].second);
            ans=max(ans,a[i].dis);
        }
    }
    printf("%.2f",ans);
}
```

---

## 作者：RoRoyyy (赞：1)

# 二分并查集。

并查集的思路和 [奶酪](https://www.luogu.org/problem/P3958)非常相似， 就是， 先联通再枚举左右两边的的站点检查是否连通。奶酪就是枚举上下的洞检查是否联通。

这题的难点在于二分答案， 能使用二分答案的证明很显然， 因为半径太小， 不能满足答案， 此时需要将半径扩大， 半径太大， 不满足最优性质， 将半径缩小。

这道题隐含的实际是在询问：
	
    能满足条件的最小值。
类似这样的处于两个临界的问题很可能就是二分答案。
剩下的细节都很简单，我就不再赘述了。


```cpp
#include <cstdio>
#include <iostream>
#include <cctype>
#include <algorithm>
#include <cmath>
template<typename T> 
inline void read(T &x) {
    x = 0; int f = 1; char ch = getchar();
    while(!isdigit(ch)) {if(ch == '-') f = -1; ch = getchar();}
    while(isdigit(ch)) {x = x * 10 + ch - '0'; ch = getchar();}
    x *= f;
}
const int N = 1e3 + 5;
const double eps = 1e-5;

using namespace std;
int n, m;
int fa[N];
int find(int x) {
    return x == fa[x] ? x : (fa[x] = find(fa[x]));
}
struct node {
    int x, y; 
    bool operator < (const node &rhs) {
        return x < rhs.x;
    }
}t[N];
double operator + (const node& a, const node& b) {
    double x = (double)a.x - b.x, y = (double)a.y - b.y;
    return sqrt(x * x + y * y);
}
bool check(double mid) {
    for(int i = 1; i <= m; i++) fa[i] = i;
    for(int i = 1; i <= m; i++) {
        for(int j = i + 1; j <= m; j++) {
            if(t[i] + t[j] <= 2 * mid) {
                int x = find(i), y = find(j);
                if(x == y) continue;
                fa[x] = y;
            }
        }
    }
    for(int i = 1; i <= m; i++) {
        for(int j = 1; j <= m; j++) {
            if(t[i].x <= mid && n - t[j].x <= mid) {
                int x = find(i), y = find(j);
                if(x == y) return true;
            }
        }
    }
    return false;
}
int main() {
    read(n), read(m);
    for(int i = 1; i <= m; i++) 
        read(t[i].x), read(t[i].y);
    sort(t + 1, t + 1 + m);
    double l = 0, r = 1e3;
    while(r - l > eps) {
        double mid = (l + r) / 2;
        if(check(mid)) r = mid;
        else l = mid;
    }
    printf("%.2f\n", l);
}
```


---

## 作者：Yummy_ (赞：1)

### 二分答案+并查集

------------

我的想法就是先使他们的距离有序（sort），二分答案，每次缩小查找的范围，找到答案输出.

唯一的难点在于什么时候判断已经是联通的了，我们可以很显然的得到，0和n+1刚好可以连起来的时候就是最小值了，也就是说我们并不需要联通所有的点，只是需要让0点与n+1点连接，举个例子就是说我们可以连接0--1,1--3,3--n+1;我们是可以跳过2这个点的，所以我们就可以用并查集的性质，每次合并完成后求一次n+1节点与0节点的祖先，如果是同一祖先的话就证明可以了；

注意事项
------------

并查集初始化需从0开始（读题）；

每次判断成立都要初始化并查集；

------------

详细的解答我都注释在代码上，
代码如下QVQ——
------------
```c
#include <bits/stdc++.h>
int wide,num,sum;//分别是宽度，点的个数，边的个数 
int fa[1000010];
using namespace std;
struct line{
        int u,v;
        double dis;
}bian[1000010];//这是存边的结构体 
struct Node{
        int x,y;
}dian[1000010]; //这是存点的结构体 
bool cmp(line a,line b){
    return a.dis < b.dis;
}
int findfa(int v){//查找父亲节点，路劲压缩 
        if(fa[v] == v)return v;
        int faa= findfa(fa[v]);
        fa[v] = faa;
        return faa;
}
void u(int a,int b){//合并 
    int faA = findfa(a);
    int faB = findfa(b);
    if(faA != faB){
        fa[faA] = faB;
    }
}
bool check(double ans){
	for(int i=0;i<num;i++)fa[i]=i;//很重要，每查找一个答案就得初始化并查集 
	int i=1;
	while(bian[i].dis<=2*ans&&i<=sum){//联通的条件：必须在两倍的半径内（画两个紧贴圆就明白了） 
		u(bian[i].u,bian[i].v);
		i++;
	}
	for(int i=0;i<num;i++){
		for(int j=0;j<num;j++){
			if(findfa(i) == findfa(j)&&dian[i].x - ans < 0 && dian[j].x + ans >wide)return 1;
		}// dian[i].x - ans < 0 && dian[j].x + ans >wide保证点与点联通的同时左右边界不会出现漏洞 
	} 
	return 0;
}
double zhao(double l,double r){
	while(l+0.001<r){//精度为0.001，需要一个精度 
		double mid=(l+r)/2;
		if(check(mid))r=mid;//二分过程 
		else l=mid;
	}
	return r;
}
int main(){
	cin>>wide>>num;
	for(int i=0;i<num;i++)fa[i]=i;//将并查集初始化 
	for(int i=0;i<num;i++){
		cin>>dian[i].x>>dian[i].y;
	}
	for(int i=0;i<num;i++){
		for(int j=i;j<num;j++){
			bian[++sum].u=i;
			bian[sum].v=j;
			bian[sum].dis=sqrt(1.0 * (dian[i].x - dian[j].x) * (dian[i].x - dian[j].x) + 1.0*(dian[i].y - dian[j].y) * (dian[i].y - dian[j].y));
			//两点间距离公式 
		}
	}
	sort(bian+1,bian+sum+1,cmp);//距离从小到大排序
	printf("%.2lf\n",zhao(0.0,100005.0));
	return 0; //功德圆满
} 
```


------------
求过谢谢

---

## 作者：Adove (赞：1)

这题可以二分+BFS

二分工作半径，bfs判断能否从左到右连成一条线，即从某点出发经过其他点能到达两边界（0，n）；

速度还是比较快的，600ms左右。

```cpp
    #include<cstdio>
    #include<cmath>
    #include<cstring>
    #include<algorithm>
    using namespace std;
    int n,m,h[640001],np,lmx,rmx,x[801],y[801],st,ed;
    bool vis[801];
    struct rpg
    {
        int li,nx;
        double ln;
    }a[640001];//最多有800*800=640000条边
    double maxn,ans;
    double ln(int i,int j)
    {
        return sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));
    }
    void add(int ls,int nx,double ln)
    {
        a[++np].li=h[ls];
        a[np].nx=nx;
        a[np].ln=ln;
        h[ls]=np;
    }
    bool check(double mid)
    {
        memset(vis,0,sizeof(vis));
        for(int i=1;i<=m;++i)
        {
            if(vis[i]) continue;
            int q[801];
            int hd=1,tl=1;
            lmx=rmx=x[i];
            q[hd]=i;
            while(hd<=tl)
            {
                int nw=q[hd++];
                for(int i=h[nw];i;i=a[i].li)
                    if(a[i].ln<=mid&&!vis[a[i].nx])
                    {
                        q[++tl]=a[i].nx;
                        vis[a[i].nx]=1;
                        if(x[a[i].nx]<lmx)
                            lmx=x[a[i].nx];//能到的最左端到左边界的距离
                        if(x[a[i].nx]>rmx)
                            rmx=x[a[i].nx];//能到的最右端到右边界的距离
                        if(lmx<=mid&&rmx+mid>=n)
                            return 1;//若左边界与右边界均能到达，则可以封锁海滩
                    }
            }
        }
        return 0;//不能完全封锁海滩
    }
    void twice(double l,double r)
    {
        if((r-l)<=0.001)
        {
            ans=(r+l)/4;
            return;
        }
        double mid=(l+r)/2;
        if(!check(mid))
            twice(mid,r);
        else
            twice(l,mid);
    }
    int main()
    {
        scanf("%d%d",&n,&m);
        for(int i=1;i<=m;++i)
            scanf("%d%d",&x[i],&y[i]);
        for(int i=1;i<m;++i)
            for(int j=i+1;j<=m;++j)
            {
                add(i,j,ln(i,j));
                add(j,i,ln(i,j));
            }
        twice(0,10001);
        printf("%.2lf",ans);
        return 0;
    }

```

---

## 作者：XMK_萌新 (赞：0)

## 题意
给定两条直线 $x=0$ 与 $x=n$，以及若干个圆心坐标 $(x_i,y_i)$，求最小的半径 $r$，使得若干圆心为给定坐标，半径为 $r$ 的**圆的并**组成的**连续图形**的左边界 $\le 0$，右边界 $\ge n$。 （这里的连续图形可以在某些地方为两圆相切，即只有一个公共点）

说人话就是：求最小的半径 $r$，使得这些圆的并组成的图形“横贯”区域 $0 \le x \le n$。如下图

![picture](https://cdn.luogu.com.cn/upload/image_hosting/2btubx42.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

黑色的圆是 $r=r_1$ 时的情况，显然不满足题意，而红色的圆是 $r=r_2$ 时的情况，满足题意。而且由于中间靠右的两圆此时恰好相切，~~显然~~ $r_2$ 就是答案。

## 各种方法时间复杂度分析
（此处根据题意和各种方法，可认为点数记为 $M+2$，边数与之成平方关系，复杂度分析时以 $M$ 和 $M^2$ 记。

### 二分 + $\text{Dijkstra } or$ 搜索（稠密图更适合用无堆优化的）：
$O(M^2 \log M^2)=O(M^2 \log M)$（此处 $M^2$ 为边数，排序后二分，两步都是 $O(M^2 \log M)$）
### $\text{Kruskal}$：
同上，也为 $O(M^2 \log M)$（为什么那么多人会拼成 $\text{Kruscal}$
### $\text{Prim}$：
不加堆优化为 $O(M^2)$，正确性见后文。于是我码了一个读入输出用 $\text{iostream}$，不用指令集、$\text{inline}$、$\text{register}$ 直接艹到无 $\text{O2}$ 最优解 $\text{rank 6}$ 的程序（doge

## 题目分析
这题如果用最小生成树可以不用二分。因为它能保证**选中的边权值总和**最小且**最大边的权值**最小。

建图的方法每篇题解都一样（似乎），无非就是将边界线作为两个新点（记作 $0$ 和 $M+1$，其他点为 $1,2,\cdots,M$），每两个原有点之间边权为距离除以 $2$，原有点到边界之间建边，权值为点到直线距离。

只要在求最小生成树时，每一轮判断 $0$ 和 $M+1$ 是否连通就行了。

~~众所周知~~，大多数人写最小生成树从来只写 $\text{Kruskal}$，而忘了传说中的 $\text{Prim}$。$\text{Kruskal}$在稀疏图中很有用，但这种坐标建图的稠密图用 $\text{Prim}$ 更好。（似乎没有人用 $\text{Prim}$ 堆优化，毕竟复杂度和 $\text{Kruskal}$ 差不多，代码还难写一点）

## Prim 正确性证明
$\text{Kruskal}$ 算法在这题~~显然~~正确。因为即使有些选入最小生成树的无用边（即没有出现在 $0$ 到 $M+1$ 路径上的边），由于它是按边长度依次选边的，所以不会影响路径上边长度的最大值，即答案。

但使用 $\text{Prim}$ 算法时，如果从 $0$ 开始生成树，把每条新加入的边中权值最大的作为答案（直到 $M+1$ 被扩展入树，算法结束），由于边长无序，会不会有些无用边加入生成树使答案错误呢？

不妨考虑反证法。设边 $(u,v)$ 为扩展出的 $\text{MST}$ 中最长的，并且是无用边。根据 $\text{Prim}$ 的找点规则，不妨设 $u$ 在已生成的树中，$v$ 是 $u$ 扩展得到的，并且记 $v$ 被扩展入生成树中之前，生成树的点集为 $S$。

那么这一轮中，$v$ 是离已生成的树最近的未访问点，所以算法会扩展到 $v$，但是 $(u,v)$ 是无用边，也就是说后面算法并没有从 $v$ 扩展到 $M+1$ 的路径。所以在若干轮从 $v$ 往外扩展以后，最终通向 $M+1$ 的路径一定会**从 $S$ 中的点**扩展得来。而这条扩展的边（**是有用边**）长度一定大于等于 $dist(u,v)$。所以 $(u,v)$ 肯定不是扩展出的 $\text{MST}$ 中最长的边，与题意矛盾。

$\text{Q.E.D.}$

（没看懂？上图）

![](https://cdn.luogu.com.cn/upload/image_hosting/ktz8sld7.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

红框内的都是 $v$ 及其扩展出的点,蓝框即为上文的 $S$

![](https://cdn.luogu.com.cn/upload/image_hosting/yj9rv8ru.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

最终会有从 $S$ 扩展出的更长有用边。

~~于是我们愉快地水掉了一道蓝题~~

## Code
```cpp
//0 -> x=0, M+1 -> x=N
#include <iostream>
#include <cstdio>
#include <cmath>
#define INF 1145141919.810
using namespace std;
int n,m,x[803],y[803];
bool vis[803]; 
double G[803][803],d[803];	//G为临接矩阵建图

double prim()
{
    fill(d,d+m+2,INF);
    d[0]=0; double ans=0;
    while(1)
    {
        int v; double dv=INF;
        for(int i=0;i<=m+1;i++)
            if(d[i]<dv&&!vis[i]) v=i,dv=d[i];
        ans=max(ans,dv); vis[v]=1;
        if(v==m+1) return ans;	//只要到达目标就停止，返回答案
        for(int i=0;i<=m+1;i++)
            if(d[i]>G[v][i]&&!vis[i]) d[i]=G[v][i];
    }
}

int main()
{
    cin>>n>>m;
    G[0][m+1]=G[m+1][0]=INF;
    G[0][0]=G[m+1][m+1]=0;
    for(int i=1;i<=m;i++)
    {
        cin>>x[i]>>y[i];
        G[i][0]=G[0][i]=x[i];	//点到x=0距离
        G[i][m+1]=G[m+1][i]=n-x[i];	//点到x=n距离
    }
    for(int i=1;i<=m;i++)
        for(int j=1;j<=m;j++)   
            G[i][j]=sqrt(double(pow(x[i]-x[j],2)+pow(y[i]-y[j],2)))/2;
    printf("%.2lf",prim());
    return 0;
}
```

---

## 作者：abandentsky (赞：0)

题意：题目意思呢给你给出一些坐标，现在让你确定一个最小的半径，使得以这
      些坐标为圆心的圆。能够无缝连接的覆盖住整个区域。
思路：我使用的最小生成树，用并查集来维护任意两点之间的在最小生成树上的
      路径上的最大值。其实这个维护的过程我们可以先将最小生成树转化为有
      根树，然后使用LCA来做，但是数据量很小，所以就直接开了vector然后
      领接矩阵来存储数据。最后枚举一下两个点，一个左边每一个右边，最后
      答案就是左边点距离左边界的值和右端点距离右边界的值取一个最大值然
      后和dist【左端点】【右端点】/2的值取最大值。（因为dist【】【】
      存储的是两个点之间的距离，也就是两倍的半径，题目要求的是半径）。
坑点：对于点一定要按照行坐标从小到大排一遍序，不然前三个点wrong。只有
      70分。
AC代码：

```c
#include<bits/stdc++.h>
#pragma GCC optimize(2)
#define MAXN 810
#define MAXP 55
#define maxnode 50010
#define sigma_size 26
#define mod 1000000007
#define INF 0x3f3f3f3f
#define lc  (id<<1)
#define rc  (id<<1|1)
using namespace std;
typedef long long LL;

int n,m;
double dist[MAXN][MAXN];
struct Edge
{
    int u,v;
    double dis;
    Edge(int u=0,int v=0,double dis=0.0):u(u),v(v),dis(dis){};
    bool operator < (const Edge&rah) const
    {
        return dis>rah.dis;
    }
};
priority_queue<Edge> Q;
struct point
{
    int x,y;
    point(int x=0,int y=0):x(x),y(y){};
};
vector<point> pp;
int pre[MAXN],xx,yy;
vector<int> G[MAXN];

bool comp(point A,point B)
{
    return A.x<B.x;
}

int Find(int x)
{
    return pre[x]==x?x:pre[x]=Find(pre[x]);
}

double show_dis(int a,int b)
{
    return sqrt((pp[a].x-pp[b].x)*(pp[a].x-pp[b].x)+(pp[a].y-pp[b].y)*(pp[a].y-pp[b].y)*1.0);
}

void init(int nn)
{
    for(int i=0;i<=nn;i++)
        pre[i]=i;
    for(int i=0;i<=nn;i++)
        G[i].push_back(i);
}

int main()
{
    scanf("%d %d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%d %d",&xx,&yy);
        pp.push_back({xx,yy});
    }
    sort(pp.begin(),pp.end(),comp);
    init(m);
    int mm=pp.size();
    for(int i=0;i<mm;i++)
    {
        for(int j=i+1;j<mm;j++)
        {
            Q.push({i,j,show_dis(i,j)});
        }
    }
    while(!Q.empty())
    {
        Edge X=Q.top();
        Q.pop();
        int xx=Find(X.u);
        int yy=Find(X.v);
        if(xx==yy)
            continue;
        pre[xx]=yy;
        for(int i=0;i<G[xx].size();i++)
        {
            for(int j=0;j<G[yy].size();j++)
            {
                int uu=G[xx][i];
                int vv=G[yy][j];
                dist[uu][vv]=dist[vv][uu]=X.dis;
            }
        }
        for(int i=0;i<G[xx].size();i++)
        {
            G[yy].push_back(G[xx][i]);
        }
    }
    double maxn,minn;
    minn=INF*1.0;
    for(int i=0;i<mm;i++)
    {
        for(int j=i+1;j<mm;j++)
        {
            int xx=pp[i].x;
            int yy=pp[j].x;
            maxn=max(dist[i][j]/2,max(xx*1.0,(n-yy)*1.0));
            minn=min(minn,maxn);
        }
    }
    printf("%.2lf\n",minn);
    return 0;
}

```

      

---

## 作者：离子键Ionic_Bond (赞：0)

## 发一篇好看的Kruscal题解
严格按模板写的Kruscal，没有玄学while。

## 思路：
1.对边缘和每一个点垂直建边。

2.对每个点对以它们之间的欧几里得距离的$1/2$为权值建边
### 注意：本代码因为玄学可以hack
-------------
代码：
```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>

using namespace std;
int n,m,x[1010],y[1010];
int f[1010];double ans;
int bcj(int x)
{
	while(x!=f[x])x=f[f[x]];
        return x;
}
struct edg
{
	int u,v;
	double w;
}e[1000100];
int cnt;
bool cmp(edg a,edg b)
{
	return a.w<b.w;
}
void kruscal()
{
	for(int i=1;i<=cnt;i++)
	{
		int hu=bcj(0);
		int hv=bcj(m+1);
		if(hu==hv) return;
		int u=e[i].u;
		int v=e[i].v;
		int edu=bcj(u);
		int edv=bcj(v);
		if(edu==edv)continue;
		f[edu]=edv;
		ans=e[i].w;
		
	}
	//printf("*");
}
int main()
{
//	freopen("Age.in","r",stdin);
//	freopen("Age.out","w",stdout);
	scanf("%d%d",&n,&m);
	for(int i=0;i<=1010;i++)f[i]=i;
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d",&x[i],&y[i]);
		e[++cnt].u=0;
		e[cnt].v=i;
		e[cnt].w=x[i];
		e[++cnt].u=m+1;
		e[cnt].v=i;
		e[cnt].w=((double)n-x[i]);
	}
	for(int i=1;i<=m;i++)
	{
		for(int j=i+1;j<=m;j++)
		{
			double ww=sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]))*0.5;
			e[++cnt].u=i;
			e[cnt].v=j;
			e[cnt].w=ww;
		}
	}
	sort(e+1,e+cnt+1,cmp);
	kruscal();
	printf("%.2lf",ans);
}
```

---

## 作者：C712 (赞：0)

~~洛咕的算法标签令人彷徨~~

[P1783 海滩防御](https://www.luogu.org/problem/P1783)
#### 其实塔就是个Kruskal

~~其实可以算是板子题~~

思路前面的dalao说的很清楚，但是个人感觉前面两篇相同思路的题解给的码有些地方没道理，

比如
```cpp
  for (i=1;i<=m;i++)
    {
        k++;
        a[k].first=i;
        a[k].second=0;
        a[k].dis=x[i];
        k++;
        a[k].first=i;
        a[k].second=n+1;
        a[k].dis=n-x[i];
    }
}
```
这里把所有点和n+1号点连起来，虽然本质上和连m+1号差不多，但是感觉容易引人误解啊（不知为何前面两篇都是这样。

以及把并查集f数组初始化到n*n大小，以及dist取绝对值，ans取max等其实完全没有必要。

但是我为什么肝这题肝了这么长时间呢（无意中暴露蒟蒻本色）？

[uchada](https://www.luogu.org/space/show?uid=133194)大佬说：“**double输出是%lf而不是%llf**”

~~我太难了~~

好吧虽然我比较菜，但是感觉我的码还是很简练易懂的

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
int r(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
int x[1005],y[1005];
double dist(int a,int b){
	return sqrt((x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]))/2.0;
}
int cnt;
struct edge{
	int u,v;double w;
}e[640001];
bool cmp(edge a,edge b){return a.w<b.w;}
int f[1005];
int find(int o){
	if(f[o]==o) return o;
	return f[o]=find(f[o]);
}
int main(){
	int n=r(),m=r();	
	for(int i=1;i<=m;i++){
		x[i]=r(),y[i]=r();
	}
	for(int i=1;i<m;i++)
		for(int j=i+1;j<=m;j++){
			e[++cnt].u=i;e[cnt].v=j;
			e[cnt].w=dist(i,j);
		}
	for(int i=1;i<=m;i++){
		e[++cnt].u=i;e[cnt].v=0;
		e[cnt].w=x[i];
		e[++cnt].u=i;e[cnt].v=m+1;
		e[cnt].w=n-x[i];
	}
	sort(e+1,e+cnt+1,cmp);
	for(int i=0;i<=m+1;i++) f[i]=i;
	int i=0;double ans;
	while(find(0)!=find(m+1)){
		i++;
		if(find(e[i].u)!=find(e[i].v)){
			f[find(e[i].u)]=find(e[i].v);
			ans=e[i].w;
		}
	}
	printf("%.2lf\n",ans);
	return 0;
}
```
 _uchida太强了_ 




---


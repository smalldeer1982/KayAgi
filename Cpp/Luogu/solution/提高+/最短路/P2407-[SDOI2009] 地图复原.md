# [SDOI2009] 地图复原

## 题目描述

很久以前，有一个传说中的“EWF”部族，他们世代生活在一个N×M的矩形大地上。虽然，生活的地区有高山、有沼泽，但通过勤劳勇敢，渐渐地，他们在自己的地盘上修筑了一条回路。

后来，“EWF”部族神秘地消失了。不过，考古学家在那片他们曾经生活过的地方找到了一份地图。地图是N×M的矩阵，左上角的坐标为(0, 0)，右下角的坐标为(N, M)。矩阵中的每个格子，表示高山、沼泽、平地、房屋或是道路其中之一。如果一个格子表示道路，那么经过这个格子的道路要么是直走，要么是拐弯。如下图，左边2幅表示直走格子的，右边4幅表示需要拐弯的格子。一个表示道路的格子只能表示下列情况之一。

 ![](https://cdn.luogu.com.cn/upload/pic/1588.png) 

可是，由于地图的年代久远，考古学家虽然能分清一个格子代表的地形，可对于道路的标记，考古学家们只能分清这一格是表示直走的还是拐弯的。现在，他们求助于你，希望你能帮助他们复原这份“EWF”部族的地图。


## 说明/提示

对于20%的数据，有N ≤ 10；

对于40%的数据，有1 ≤ N, M ≤ 80；

对于40%的数据，输入没有“.”,且N, M > 10；

对于100%的数据，满足1 ≤ N, M ≤ 800。


## 样例 #1

### 输入

```
3 4
TST.
S.TT
TSST
```

### 输出

```
o-o-o o
|   |  
o o o-o
|     |
o-o-o-o
```

# 题解

## 作者：ganpig (赞：4)

考虑每行第一个出现的 `T`，在水平方向上一定是向右连路的，因为假如是向左而左边没有 `T` 的话……那岂不是要一直连到地图之外？

既然是向右连，那就只能连到下一个 `T` 然后转成竖直方向的了。那如果有第三个 `T`，还是只能向右连，连到第四个……以此类推，依次配对。

竖直方向同理，每一列的第一个和第二个 `T` 配对，第三个和第四个 `T` 配对……全部连上就得到了答案。

但是！直接一小段一小段连过去，似乎写起来还是有点麻烦呢？为了偷懒，再多想一步：水平方向上的一小段需要连路，当且仅当它正左侧的 `T` 数量为奇数；竖直方向上的一小段需要连路，当且仅当它正上方的 `T` 数量为奇数。所以，把所有的 `T` 当成 `1`，维护每一行、每一列的异或和即可，用 `bitset` 很好实现。输出时还可以用 `"..."[...]` 这个语法糖来偷偷懒。

### $\text{Code}$

```cpp
#include <bits/stdc++.h>
int main() {
    int n, m;
    std::cin >> n >> m;
    std::bitset<1000> s, t;
    while (n--) {
        std::string str;
        std::cin >> str;
        for (int i = 0, a = 0; i < m; i++)
            printf("o%c", "\n -"[(i != m - 1) + (a ^= t[i] = str[i] == 'T')]);
        if (!n)
            break;
        s ^= t;
        for (int i = 0; i < m; i++)
            printf("%c%c", " |"[s[i]], " \n"[i == m - 1]);
    }
}
```

*PS：这题的代码目前已经被压到了 146B，如果发现了更短的写法请告诉我*

---

## 作者：小菜鸟 (赞：3)

这题...

两篇pascal题解，仅有的cpp题解码风堪忧

所以我来补充个代码（

---

第一眼看到也以为要图论算法

然而仔细观察，我们意识到一个问题：

同一行/列中，转角必定是两两匹配，否则会往一个方向回不去，不能形成环。

然后题面又说保证有解。

那就直接1与2，3与4，5与6匹配就好了...

---

```cpp
#include<cstdio>
#include<algorithm>

int n,m;
char a[805][805];
bool col[805][805],lin[805][805];

int main()
{
    scanf("%d%d\n",&n,&m);
    for(int i=0;i<n;++i)scanf("%s",a[i]);
    for(int i=0;i<n;++i)
    {
        int t=0;
        for(int j=0;j<m;++j)
        {
            if(a[i][j]=='T')t^=1;//使得匹配的两个转角间被标记为1
            lin[i][j]=t;
        }
    }
    for(int j=0;j<m;++j)
    {
        int t=0;
        for(int i=0;i<n;++i)
        {
            if(a[i][j]=='T')t^=1;//同理
            col[i][j]=t;
        }
    }
    for(int i=0;i<n;++i)//答案每次输出两行，一行为横向路径，一行为纵向路径
    {
        for(int j=0;j<m;++j)
        {
            putchar('o');
            putchar(lin[i][j]?'-':' ');
        }
        if(i==n-1)break;//消除最后一行多余的部分
        putchar('\n');
        for(int j=0;j<m;++j)
        {
            putchar(col[i][j]?'|':' ');
            putchar(' ');
        }
        putchar('\n');
    }
}
```



---

## 作者：ysner (赞：3)

~~我感到很奇怪的是，该题作为一道省选题，竟然只有pascal题解。（逃）~~

这道题思路不难，但是容易想复杂（我就以为要随便找个‘S’为起点深搜出回路来着）。

观察样例，可以发现每一行每一列的弯路不是为0就是为2。

其实很好理解，弯路都转了90度，我们起码要转两个弯才能反向吧，只转一个永远无法靠近出发点，也就永远无法形成回路。

**以此类推，每一行每一列都有偶数个弯路。**

于是，我们把每一行每一列第1、2个，第3、4个，第5、6个等等弯路连接起来，不就是个回路吗？随便画图即可证明。

剩下就是实现了，没什么细节，对切省选题的大佬肯定是不难的。（过样例就能A)
```
#include<iostream>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#define ll long long
#define re register
#define il inline
#define fp(i,a,b) for(re int i=a;i<=b;i++)
#define fq(i,a,b) for(re int i=a;i>=b;i--)
using namespace std;
int n,m,lx[1000][1000],ls[1000][1000];//lx存该点下面有没有杠，ls存该点右边有没有杠
char a[1000][1000];
il ll gi()
{
  re ll x=0,t=1;
  re char ch=getchar();
  while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();
  if(ch=='-') t=-1,ch=getchar();
  while(ch>='0'&&ch<='9') x=x*10+ch-48,ch=getchar();
  return x*t;
}
int main()
{
  n=gi();m=gi();
  fp(i,1,n) scanf("%s",a[i]+1);
  fp(i,1,n)
  {
    re int tmp=0,las;
      fp(j,1,m)
        if(a[i][j]=='T')
      {
        tmp++;
        if(tmp==1) las=j;
        else
          {
        tmp=0;
        fp(k,las,j-1) ls[i][k]=1;//两个弯路相连
          }
      }
  }
  fp(j,1,m)
  {
    re int tmp=0,las;
      fp(i,1,n)
        if(a[i][j]=='T')
      {
        tmp++;
        if(tmp==1) las=i;
        else
          {
        tmp=0;
        fp(k,las,i-1) lx[k][j]=1;//两个弯路相连
          }
      }
  }
  fp(i,1,2*n-1)
    if(i%2==1)
    {
      re int o=(i+1)/2;//微操
      fp(j,1,m)
    {
          printf("o");
      if(ls[o][j]) printf("%c",45);else printf(" ");
    }
      puts("");
    }
    else
      {
    re int o=(i+1)/2;
    fp(j,1,m)
      if(lx[o][j]) printf("%c ",124);else printf("  ");
        puts("");
      } 
  return 0;
}
```

---

## 作者：Cxny (赞：2)

~~虽然但是，这题跟最短路有任何关系吗……~~

---

题解里似乎还没有这种思路。

近似于插头 dp ，在每一层我们可以维护当前点有没有从左边过来的边，或者从上面下来的边。

若当前点为拐角，则

- 若上方有边，则该节点下方必定没有边。（否则成直道，三叉，或者四叉。）
- 若左侧有边，则该节点右侧必定没有边。原因同上。

若当前点为直道，则必定继承左侧与上方的状态。

题目保证有解，因此不存在矛盾的情况。

空间复杂度可优化为 $O(n)$ 。

完整代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 810;
int n, m, cur = 1;
char s[maxn];
bool r;
bitset<maxn> d[2];
int main(){
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= n; i++){
		scanf("%s", s + 1), cur ^= 1, r = 0;
		d[cur] = d[cur ^ 1];
		for(int j = 1; j <= m; j++){
			if(s[j] == 'T'){
				d[cur][j] = !d[cur][j], r ^= 1;
			}else if(s[j] != 'S') r = 0;
			putchar('o'), putchar(r ? '-' : ' ');
		}
		puts("");
		if(i == n) break;
		for(int j = 1; j <= m; j++) putchar(d[cur][j] ? '|' : ' '), putchar(' ');
		puts("");
	}
	return 0;
}
```

---

## 作者：Hydroxyl (赞：2)

其实有一种很简单的思路

你仔细推敲你会惊奇的发现每一行 每一列的T的个数都是偶数 所以……

从左往右扫描一次 把第1、2个t连起来 3/4 连起来 5、6连起来 ……

然后从上往下扫描一次 还是一样的操作

处理ans记得处理一次然后输出注意空格（一脚一个坑）

其实想清楚了也是挺简单的






```cpp
var ans,c:array[0..2050,0..2050] of char;
    i,j,k,m,n,d,p:longint;S:char;
procedure init;
begin
    assign(input,'recover.in');
    reset(input);
    assign(output,'recover.out');
    rewrite(output);
end;
begin
   init;
    readln(n,m);
    for i:=1 to 2*n-1 do for j:=1 to 2*m-1 do ans[i,j]:=' ';
    for i:=1 to n do
    begin
      for j:=1 to m do
       read(c[i,j]);
       readln;
    end;
    for i:=1 to n do for j:=1 to m do ans[i*2-1,j*2-1]:='o';
    for i:=1 to 2*n-1 do
    if i mod 2=1 then
    begin
      j:=1; d:=0; p:=0;
      while j<=m do
      begin
        if (c[i div 2+1,j]='T') and (d=0) then begin d:=1; p:=j; inc(j); continue; end;
        if (c[i div 2+1,j]='T') and (d=1) then
        begin
          for k:=p to j-1 do
          ans[i,k*2]:='-';
          d:=0;p:=0;
        end;
        inc(j);
      end;
    end;
    for i:=1 to 2*m-1 do
    if i mod 2=1 then
    begin
      j:=1; d:=0; p:=0;
      while j<=m do
      begin
        if (c[j,i div 2+1]='T') and (d=0) then begin d:=1; p:=j; inc(j); continue; end;
        if (c[j,i div 2+1]='T') and (d=1) then
        begin
          for k:=p to j-1 do
          ans[k*2,i]:='|';
          d:=0;p:=0;
        end;
        inc(j);
      end;
    end;
    for i:=1 to 2*n-1 do
    begin
     for j:=1 to 2*m-1 do
     write(ans[i,j]);
     writeln;
    end;
    close(output);
end.
这种方法一定是可行的
```

---

## 作者：EricWan (赞：1)

结论：

1. 对于每一行的第一个转向节点，它一定有一个分叉朝向右侧：

假设它有一个分叉朝向左侧，因为它左侧都是空地或直行节点，所以向左走不能转弯，假设不成立。又因为一个分叉节点没有左侧分叉，一定有右侧分叉，所以本结论可证。（[更加标准的证明](https://www.luogu.com.cn/paste/dalb3edg)）

2. 当一个转向节点的方向已经确定切它右侧又另一个转向节点，那么另一个转向节点与当前节点不可能同时有左叉或者右叉，证明方法与结论一证明方法类似，使用反证法。

3. 将地图旋转 90° 后所有结论仍然成立（证明方法相同）。

4. 每一行有偶数个转弯节点（由结论二）。

5. 忽略直行节点，并假设空地默认任何方向都可以直行通过，在任意转弯节点出发，一定可以恰好不重不漏走完答案回路。（因此可以通过这个结论直接算答案。）

通过结论 1 与结论 2 可以确定每个转弯节点的具体状态，最后确定直行节点的方向即可。

---

## 作者：tanghg (赞：1)

对于本题，分`S` 和 `T` 的情况讨论。我们枚举行再枚举列然后依次判断结果即可。如果是 `S`，那么如果 `S` 的上方有边，则另一条一定向下出去，否则变成拐角，左边同理。

之后考虑 `T` 边，还是考虑左边和上面的边。如果来自上面，那么显然不可以去下，否则就是直线了。那么看一看左边有没有边，如果有的话那就不能动了，否则的话往右走（因为如果是要求这条边联通的话那么之前就应该已经连上了）。如果左边有连的边同理。

这样我们就做完了，只需要枚举然后分情况讨论即可。推荐直接在答案数组上枚举，这样枚举四周会比较方便。
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll MAXN=1000+5;
ll n,m;
char c[MAXN*2][MAXN*2];
ll dx[]={0,0,0,1,-1};
ll dy[]={0,1,-1,0,0};
void S(ll x,ll y){
    for(int i=1;i<=4;++i){
        ll X=x+dx[i],Y=y+dy[i];
        if(X<1||X>2*n-1||Y<1||Y>2*m-1||c[X][Y]=='.'){
            if(i<3){
                c[x+dx[3]][y+dy[3]]=c[x+dx[4]][y+dy[4]]='|';
            }else{
                c[x+dx[1]][y+dy[1]]=c[x+dx[2]][y+dy[2]]='-';
            }
            return;
        }
        if(c[X][Y]=='|'||c[X][Y]=='-'){
            if(i>=3){
                c[x+dx[3]][y+dy[3]]=c[x+dx[4]][y+dy[4]]='|';
            }else{
                c[x+dx[1]][y+dy[1]]=c[x+dx[2]][y+dy[2]]='-';
            }
            return;
        }
    }
}
void T(ll x,ll y){
    ll val=0;
    for(int i=1;i<=4;++i){
        ll X=x+dx[i],Y=y+dy[i];
        if(X<1||X>2*n-1||Y<1||Y>2*m-1){
            continue;
        }
        if(c[X][Y]=='|'||c[X][Y]=='-'){
            val++;
        }
    }
    if(val==2){
        return;
    }
    for(int i=1;i<=4;++i){
        ll X=x+dx[i],Y=y+dy[i];
        if(X<1||X>2*n-1||Y<1||Y>2*m-1){
            continue;
        }
        if(c[X][Y]=='|'&&i>2){
            c[x+dx[1]][y+dy[1]]='-';
            return;
        }
        if(c[X][Y]=='-'&&i<=2){
            c[x+dx[3]][y+dy[3]]='|';
            return;
        }
    }
    c[x+dx[1]][y+dy[1]]='-';
    c[x+dx[3]][y+dy[3]]='|';
}
void print(){
    for(int i=1;i<=2*n-1;++i){
        for(int j=1;j<=2*m-1;++j){
            if(c[i][j]!=' '&&c[i][j]!='-'&&c[i][j]!='|'){
                c[i][j]='o';
            }
            cout<<c[i][j];
        }
        cout<<"\n";
    }
}
int main(){
    ios::sync_with_stdio(false);
    cin>>n>>m;
    for(int i=1;i<=2*n-1;++i){
        for(int j=1;j<=2*m-1;++j){
            c[i][j]=' ';
        }
    }
    for(int i=1;i<=n;++i){
        for(int j=1;j<=m;++j){
            cin>>c[i*2-1][j*2-1];
        }
    }
    for(int i=1;i<=n;++i){
        for(int j=1;j<=m;++j){
            ll x=i*2-1,y=j*2-1;
            if(c[x][y]=='S'){
                S(x,y);
            }else if(c[x][y]=='T'){
                T(x,y);
            }
        }
    }
    print();
    return 0;
}
```

---

## 作者：Marginal_world (赞：1)

第一眼看到以为是图论。

然而仔细观察，我们意识到一个重要的问题：

同一行/列中，转角必定是两两匹配，否则会往一个方向回不去，不能形成环，这是可以证明的。

然后题面又说保证有解。

我们相信出题人不会自己挖坑自己跳。

所以：

那就直接 1 与 2 ， 3 与 4 ， 5 与 6 匹配就好了...

代码实现：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
char a[805][805];
bool vis[805][805],lin[805][805];
int main(){
    scanf("%d%d\n",&n,&m);
    for(int i=0;i<n;++i)
	scanf("%s",a[i]);
    for(int i=0;i<n;++i){
        int t=0;
        for(int j=0;j<m;++j){
            if(a[i][j]=='T')t^=1;//使得匹配的两个转角间被标记为1
            lin[i][j]=t;
        }
    }
    for(int j=0;j<m;++j){
        int t=0;
        for(int i=0;i<n;++i){
            if(a[i][j]=='T')t^=1;//同理
            vis[i][j]=t;
        }
    }
    for(int i=0;i<n;++i){//答案每次输出两行，一行为横向路径，一行为纵向路径
        for(int j=0;j<m;++j){
            putchar('o');
            putchar(lin[i][j]?'-':' ');
        }
        if(i==n-1)break;//消除最后一行多余的部分
        putchar('\n');
        for(int j=0;j<m;++j){
            putchar(vis[i][j]?'|':' ');
            putchar(' ');
        }
        putchar('\n');
    }
    return 0;
}
```

希望能对大家有所帮助。

---

## 作者：dutianchen1 (赞：0)

# P2407 [SDOI2009] 地图复原

### 思路简析

很容易发现，本题中 “T” 的位置很关键。而 “T” 对答案的影响也很明显，就是将横向道路转为竖向道路。

所以我们的思路很简单，就是遍历两边输入的原地图。分别考虑当前方向是否转向。不转向就维持之前的状态。否则我们改成另一种状态。

最后我们按照记录的状态存入答案输出即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e3+5;
inline ll read()
{
	ll x=0,f=1;
	char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch)){x=(x<<1)+(x<<3)+ch-48;ch=getchar();}
	return x*f;
}
char mp[N][N];
char ans[N<<1][N<<1];
bool heng[N][N],shu[N][N];//记录横与竖的状态 
ll n,m;
int main()
{
	n=read();m=read();
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>mp[i][j];
		}
	}
	for(int i=1;i<=n;i++){
		ll now=0;
		for(int j=1;j<=m;j++){
			now^=(mp[i][j]=='T');//遇到拐角，转向。原本横向就不再记录，否则开始记录 
			heng[i][j]=now; 
		}
	}
	for(int i=1;i<=m;i++){
		ll now=0;
		for(int j=1;j<=n;j++){
			now^=(mp[j][i]=='T');//同上 
			shu[j][i]=now; 
		}
	}
    for(int i=1;i<=n*2;i+=2){
        for(int j=1;j<=m*2;j+=2){
        	ans[i][j]='o';
            ans[i][j+1]=(heng[i/2+1][j/2+1]?'-':' ');
        }
        if(i==n*2-1)break;//最后一行不必考虑 
        for(int j=1;j<=m*2;j+=2){
            ans[i+1][j]=(shu[i/2+1][j/2+1]?'|':' ');
            ans[i+1][j+1]=' ';
        }
    }
    for(int i=1;i<=2*n;i++){
    	for(int j=1;j<=2*m;j++){
    		cout<<ans[i][j];
		}
    	cout<<'\n';
	}
	return 0;
}
```

---

## 作者：shaozhehan (赞：0)

[原题链接](https://www.luogu.com.cn/problem/P2407)

题目大意：

给你一个 $n\times m$ 的二维字符矩阵 $p$，请你构造一个在 $n\times m$ 的矩阵上构成的回路，使得每一条边都是横向或竖向的且只经过两个格子，而且对于第 $i$ 行第 $j$ 列的格子，如果 $p_{i,j}$ 为 $\texttt{S}$ 的话，那么有两条边经过这个格子且这两条边没有拐弯；如果 $p_{i,j}$ 为 $\texttt{T}$ 的话，那么有两条边经过这个格子且这两条边拐弯；如果 $p_{i,j}$ 为 $\texttt{.}$ 的话，那么没有边经过这个格子。输入保证至少有一个合法解。

思路：

我们用 $r_{i,j}$ 来表示有没有连接第 $i$ 行第 $j$ 列的和第 $i$ 行第 $j+1$ 列的格子，$c_{i,j}$ 表示有没有连接第 $i$ 行第 $j$ 列和第 $i+1$ 行和第 $j$ 列的格子，如果有则值为 $1$，如果没有则值为 $0$。

显然，$r_{1,1}$ 和 $c_{1,1}$ 唯一。然后，我们可以遍历行和列，确定每一个 $r_{i,j}$ 和 $c_{i,j}$。

对于第 $i$ 行第 $j$ 列的格子：
- 如果 $p_{i,j}$ 为 $\texttt{.}$，则我们可以直接忽略。
- 如果 $p_{i,j}$ 为 $\texttt{S}$，则我们可以分两种情况讨论：
    - 如果 $j\not=1$ 且 $r_{i,j-1}=1$，则这个格子上的两边均为横向，$\begin{cases}r_{i,j}=1\\c_{i,j}=0\end{cases}$。
    - 如果 $i\not=1$ 且 $c_{i,j-1}=1$，则这个格子上的两边均为竖向，$\begin{cases}r_{i,j}=0\\c_{i,j}=1\end{cases}$。

- 如果 $p_{i,j}$ 为 $\texttt{T}$，则我们可以分四种情况讨论：
    - 如果 $i\not=1$ 且 $j\not=1$ 且 $r_{i,j-1}=c_{i-1,j}=1$，则这个格子已经有两条边形成拐弯了，$r_{i,j}=c_{i,j}=0$。
    - 如果 $j\not=1$ 且 $r_{i,j-1}=1$ 且 $i=1$ 或 $c_{i-1,j}=0$，则这个格子的两条边应在这个格子的下方和左方，$\begin{cases}r_{i,j}=0\\c_{i,j}=1\end{cases}$。
    - 如果 $i\not=1$ 且 $c_{i-1,j}=1$ 且 $j=1$ 或 $r_{i,j-1}=0$，则这个格子的两条边应在这个格子的上方和右方，$\begin{cases}r_{i,j}=1\\c_{i,j}=0\end{cases}$。
    - 如果 $i=1$ 或 $c_{i-1,j}=0$ 且 $j=1$ 或 $r_{i,j-1}=0$，则这个格子的两条边应在这个格子的下方和右方，$r_{i,j}=c_{i,j}=1$。

我们按照上述规则把每一条边都确定下来，然后按照题目规定输出即可。具体实现时注意输出格式。

上代码：
```cpp
#include <iostream>
using namespace std;

bool row[801][800], column[800][801];

int main(){
    cin.tie(NULL);
    ios_base::sync_with_stdio(false);// cin、cout 优化
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; i++){
        for (int j = 1; j <= m; j++){
            char c;
            cin >> c;
            // 分类讨论
            if (c == 'S'){
                if (j > 1 && row[i][j - 1]){
                    row[i][j] = true;
                } else if (i > 1 && column[i - 1][j]){
                    column[i][j] = true;
                }
            } else if (c == 'T'){
                if (j > 1 && row[i][j - 1] && (i == 1 || !column[i - 1][j])){
                    column[i][j] = true;
                } else if (i > 1 && column[i - 1][j] && (j == 1 || !row[i][j - 1])){
                    row[i][j] = true;
                } else if ((i == 1 || !column[i - 1][j]) && (j == 1 || !row[i][j - 1])){
                    row[i][j] = column[i][j] = true;
                }
            }
        }
    }
    // 输出
    for (int i = 1; i < n; i++){
        for (int j = 1; j < m; j++){
            if (row[i][j]){
                cout << "o-";
            } else {
                cout << "o ";
            }
        }
        cout << "o\n";
        for (int j = 1; j < m; j++){
            if (column[i][j]){
                cout << "| ";
            } else {
                cout << "  ";
            }
        }
        if (column[i][m]){
            cout << "|\n";
        } else {
            cout << " \n";
        }
    }
    for (int i = 1; i < m; i++){
        if (row[n][i]){
            cout << "o-";
        } else {
            cout << "o ";
        }
    }
    cout << "o";
    return 0;
}

```

---

## 作者：Durancer (赞：0)

### 思路

其实这个题目需要抓一个重点：

> 输入数据保证至少存在一个合法解。

理解这一句话可以让你省去不少麻烦的步骤，图中我们需要处理的只有道路，首先如果要保证合法，那么他就会形成一个环，并且每个拐角都会使道路向出的地方延伸，直到又有拐角才会改变方向。

我们可以利用这个思路简单处理题目即可。

对于行来说，遇到了奇数个拐角就向右边延伸，如果遇到了偶数个的拐角，那么久停止延伸。

同理对于列来说，遇到了奇数个拐角就向下延伸，如果遇到了偶数个拐角，同样停止延伸。

可以根据这个性质，达到简单处理的目的。

### 代码实现

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#include<cmath>
#include<stack>
#include<algorithm>
#include<map>
using namespace std;
const int N=1e3+9;
char mp[N][N];
int hang[N][N];
int lie[N][N]; 
int n,m;
int read()
{
	int f=1,x=0;
	char s=getchar();
	while(s<'0'||s>'9'){if(s=='-')f=-1;s=getchar();} 
	while(s>='0'&&s<='9'){x=(x<<1)+(x<<3)+(s^'0');s=getchar();}
	return f*x;
}
int main()
{
	n=read();
	m=read();
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			cin>>mp[i][j];
	for(int i=1;i<=n;i++)
	{
		int flag=0;
		for(int j=1;j<=m;j++)
		{
			if(mp[i][j]=='T') 
				flag=flag^1;//标记拐角，如果没有拐的那么一直接续下去
			hang[i][j]=flag; 
		}
	}
	for(int j=1;j<=m;j++)
	{
		int flag=0;
		for(int i=1;i<=n;i++)
		{
			if(mp[i][j]=='T')
				flag=flag^1;
			lie[i][j]=flag; 
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m-1;j++)
		{
			cout<<"o";
			if(hang[i][j]) cout<<"-";
			else cout<<" ";
		}
		cout<<"o"<<endl;
		if(i==n) break;
		for(int j=1;j<=m;j++)
		{
			if(lie[i][j]) cout<<"| ";
			else cout<<"  ";
		}
		cout<<endl;
	}
	return 0;
}
```


---

## 作者：ouo·lala·ouo (赞：0)

这道题目很恶心。。是的我做完了想打人。。我写了很久很久大概几个小时。。

首先讲一下我的想法。因为题目中已经说过了：有且只有一条回路，那么就可以通过判断左边和上边的是不是有路。没错差不多就这样，以下是AC代码




```cpp
type map=array[1..2000]of ansistring;
var
  s,ans:map;
  n,m,i,j:longint;
function up(a,b:longint):boolean;
begin
  if a>1 then
   if ans[2*a-2,2*b-1]='|' then exit(true);
  exit(false);
end;
function left(a,b:longint):boolean;
begin
  if b>1 then
   if ans[2*a-1,2*b-2]='-' then exit(true);
  exit(false);
end;
begin
  readln(n,m);
  for i:=1 to n do readln(s[i]);
  for i:=1 to 2*n-1 do
   for j:=1 to 2*m-1 do ans[i]:=ans[i]+' ';
  for i:=1 to n do
   for j:=1 to m do
   begin
     ans[2*i-1,2*j-1]:='o';
     if s[i,j]='T' then
     begin
       if up(i,j) and not left(i,j) then ans[2*i-1,2*j]:='-';
       if not up(i,j) and left(i,j) then ans[2*i,2*j-1]:= '|';
       if not up(i,j) and not left(i,j) then
       begin
         ans[2*i,2*j-1]:= '|';
         ans[2*i-1,2*j]:='-';
       end;
     end;
     if s[i,j]='S' then
     begin
       if up(i,j) then begin ans[2*i,2*j-1]:='|'; end;
       if left(i,j) then ans[2*i-1,2*j]:='-';
     end;
   end;
  for i:=1 to 2*n-1 do writeln(ans[i]);
end.

```

---


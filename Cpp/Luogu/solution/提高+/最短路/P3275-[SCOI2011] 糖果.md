# [SCOI2011] 糖果

## 题目描述

幼儿园里有 $N$ 个小朋友，$\text{lxhgww}$ 老师现在想要给这些小朋友们分配糖果，要求每个小朋友都要分到糖果。但是小朋友们也有嫉妒心，总是会提出一些要求，比如小明不希望小红分到的糖果比他的多，于是在分配糖果的时候，$\text{lxhgww}$ 需要满足小朋友们的 $K$ 个要求。幼儿园的糖果总是有限的，$\text{lxhgww}$ 想知道他至少需要准备多少个糖果，才能使得每个小朋友都能够分到糖果，并且满足小朋友们所有的要求。

## 说明/提示

对于 $30\%$ 的数据，保证 $N\leq100$

对于 $100\%$ 的数据，保证 $N\leq100000$

对于所有的数据，保证 $K\leq100000, 1\leq X\leq5, 1\leq A, B\leq N$

---

$\text{upd 2022.7.6}$：新添加 $21$ 组 [Hack 数据](https://www.luogu.com.cn/discuss/454051)。

## 样例 #1

### 输入

```
5 7
1 1 2
2 3 2
4 4 1
3 4 5
5 4 5
2 3 5
4 5 1```

### 输出

```
11```

# 题解

## 作者：kangli (赞：134)

**【提示】**：本题解并非本题的正解，无法通过部分 hack 数据。但其思想具有启发性，故保留在此，供大家参考。

---

我们考虑到题干所给的5个条件都必须满足。

不妨考虑随机贪心。

由于糖果数量要尽量的小且每个小朋友糖果数量都要大于等于$1$，我们初始时先设所有小朋友糖果数为$1$。

然后循环每一个询问满足条件，但是考虑到后面条件满足了会影响前面的条件，所以可以让条件跑很多次更新答案。

每次更新时，采用贪心的思想，增加的糖果尽量少。

为什么不要减少糖果呢？因为初始的时候小朋友的糖果为最少了，所以后续条件不能让他再少了。

随机贪心大约$200$次左右，最后在循环一次判断是否满足题意。

不喜勿喷，谢谢。

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
struct candy{
	int X,A,B;
}q[101010];
int n,k;
int a[101010];
int main()
{
	//freopen("a.in","r",stdin);
	cin>>n>>k;
	for (int i=1; i<=k; i++){
		scanf("%d%d%d",&q[i].X,&q[i].A,&q[i].B);
	}
	for (int i=1; i<=n; i++) a[i]=1;
	for (int T=1; T<=200; T++){
		for (int i=1; i<=k; i++){
			if (q[i].X==1) {
				if (a[q[i].A]>a[q[i].B]) a[q[i].B]=a[q[i].A];
				else a[q[i].A]=a[q[i].B];
			}
			else if (q[i].X==2){
				if (a[q[i].A]>=a[q[i].B]) a[q[i].B]=a[q[i].A]+1;
			}
			else if (q[i].X==3){
				if (a[q[i].A]<a[q[i].B]) a[q[i].A]=a[q[i].B];
			}
			else if (q[i].X==4){
				if (a[q[i].A]<=a[q[i].B]) a[q[i].A]=a[q[i].B]+1;
			}
			else if (q[i].X==5){
				if (a[q[i].A]>a[q[i].B]) a[q[i].B]=a[q[i].A];
			}
		}
	}
	for (int i=1; i<=k; i++){
		if (q[i].X==1) {
				if (a[q[i].A]>a[q[i].B]) {cout<<"-1";return 0;}
			}
			else if (q[i].X==2){
				if (a[q[i].A]>=a[q[i].B]) {cout<<"-1";return 0;}
			}
			else if (q[i].X==3){
				if (a[q[i].A]<a[q[i].B]) {cout<<"-1";return 0;}
			}
			else if (q[i].X==4){
				if (a[q[i].A]<=a[q[i].B]) {cout<<"-1";return 0;}
			}
			else if (q[i].X==5){
				if (a[q[i].A]>a[q[i].B]) {cout<<"-1";return 0;}
			}
	}
	long long ans=0;
	for (int i=1; i<=n; i++) ans+=a[i];
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：Salamander (赞：80)

这题可以用缩点的方法做。首先我们只加上1、3、5三种情况的边，如果a<=b那么a向b连边，如果相等就两边都连。然后我们用Tarjan缩一遍环，然后可以构出一个DAG(有向无环图)。由于缩掉的都是1、3、5情况的边，那么他们构成的环就意味着环上的点必须相等。缩环之后重构图，加上2、4情况的边，这个时候要特判：如果此时有一条2、4的边构成自环（意味着它在原图中连接了两个必须相等的点），所以直接输出-1结束。然后我们给图来一遍拓扑排序，如果此时出现环（拓扑排序有些点没有访问到），必然意味着后面新加的2、4情况的边构成了环（1、3、5情况的边已经没有环了），此时也要直接输出-1结束。最后按照拓扑序来一遍dp就可以得出结果。（统计结果记得用long long）


代码：




```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
using namespace std;
const int maxn=100010;
struct relationship{
    int x,a,b;
}r[maxn];
struct edge{
    int to,next;
    bool same;//记录该边是否允许两边相等  
}e[maxn<<1],e2[maxn];
int n,m,num,num2,cnt,head[maxn],head2[maxn],ltk[maxn],dfn[maxn],low[maxn];
int sta[maxn],top,size[maxn],que[maxn],du[maxn],h,tail,candy[maxn];
bool vis[maxn];
long long ans=0;
void add(int u,int v,bool k){
    e[++num].to=v;e[num].same=k;e[num].next=head[u];head[u]=num;
}
void add2(int u,int v,bool k){
    du[v]++;
    e2[++num2].to=v;e2[num2].same=k;e2[num2].next=head2[u];head2[u]=num2;
}
void dfs(int x){
    dfn[x]=low[x]=++cnt;sta[++top]=x;
    for(int i=head[x];i;i=e[i].next){
        if(!dfn[e[i].to]){
            dfs(e[i].to);
            low[x]=min(low[x],low[e[i].to]);
        }
        else if(!ltk[e[i].to]){
            low[x]=min(low[x],dfn[e[i].to]);
        }
    }
    if(dfn[x]==low[x]){
        ltk[0]++;
        while(top){
            ltk[sta[top]]=ltk[0];
            size[ltk[0]]++;
            if(sta[top--]==x)break;
        }
    }
}
void Rebuild(){
    for(int i=1;i<=n;i++){
        for(int j=head[i];j;j=e[j].next){
            if(ltk[i]!=ltk[e[j].to]){
                add2(ltk[i],ltk[e[j].to],true);
            }
        }
    }
    for(int i=1;i<=m;i++){
        if(r[i].x==2){
            if(ltk[r[i].a]==ltk[r[i].b]){
                printf("-1\n");
                exit(0);
            }
            else{
                add2(ltk[r[i].a],ltk[r[i].b],false);
            }
        }
        else if(r[i].x==4){
            if(ltk[r[i].a]==ltk[r[i].b]){
                printf("-1\n");
                exit(0);
            }
            else{
                add2(ltk[r[i].b],ltk[r[i].a],false);
            }
        }
    }
}
void Topsort(){
    for(int i=1;i<=ltk[0];i++){
        if(!du[i]){
            que[++tail]=i;
            vis[i]=true;
            candy[i]=1;       //candy[i]记录i节点每个孩子要多少糖
        }
    }
    while(h<tail){
        int x=que[++h];
        for(int i=head2[x];i;i=e2[i].next){
            if(!--du[e2[i].to]){
                que[++tail]=e2[i].to;
                vis[e2[i].to]=true;
            }
            if(!e2[i].same){
                candy[e2[i].to]=max(candy[e2[i].to],candy[x]+1);
            }
            else{
                candy[e2[i].to]=max(candy[e2[i].to],candy[x]);
            }//dp，如果有一条边不允许相等就要+1 
        }
    }
    for(int i=1;i<=ltk[0];i++){
        if(!vis[i]){
            printf("-1\n");
            exit(0);
        }
    }
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++){
        scanf("%d%d%d",&r[i].x,&r[i].a,&r[i].b);
        if(r[i].x==1){
            add(r[i].a,r[i].b,true);
            add(r[i].b,r[i].a,true);
        }
        else if(r[i].x==3){
            add(r[i].b,r[i].a,true);
        }
        else if(r[i].x==5){
            add(r[i].a,r[i].b,true);
        }
    }
    for(int i=1;i<=n;i++){
        if(!dfn[i]){
            dfs(i);
        }
    }
    Rebuild();Topsort();
    for(int i=1;i<=ltk[0];i++){
        ans+=(candy[i]*size[i]);//记录答案，记得开long long
    }
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：御·Dragon (赞：73)

## 看到很多题解斌没有讲清楚这道题为什么可以用某些方法，套个板子就没了。蒟蒻就发一篇题解~~装X~~造福大家吧233

### 做这道题前，我推荐大家做一下一本通中的[1352：【例4-13】奖金](http://ybt.ssoier.cn:8088/problem_show.php?pid=1352)一题，因为有可能做完了这道题对于你们会有一点启发。

## 首先分析一下题目

题目对于小朋友的嫉妒一共有$5$中情况，分别如下：

------------


>如果 X=1， 表示第 A 个小朋友分到的糖果必须和第 B 个小朋友分到的糖果一样多；

>如果 X=2， 表示第 A 个小朋友分到的糖果必须少于第 B 个小朋友分到的糖果；

>如果 X=3， 表示第 A 个小朋友分到的糖果必须不少于第 B 个小朋友分到的糖果；

>如果 X=4， 表示第 A 个小朋友分到的糖果必须多于第 B 个小朋友分到的糖果；

>如果 X=5， 表示第 A 个小朋友分到的糖果必须不多于第 B 个小朋友分到的糖果；

------------


题目想要让每个小朋友都满足且使用最少的糖果数量，如果无解则输出-1。

我们将小朋友当做点，小朋友之间限制条件当做边

对于X=1、X=3、X=5时，我们不难知道，想要使用最少的糖果数量，那么最好的方式就是两个人糖果数量一样。

对于X=2，那么A=B-1最优

对于X=4，那么B=A-1最优

------------

### 所以说了做一下一本通中的[1352：【例4-13】奖金](http://ybt.ssoier.cn:8088/problem_show.php?pid=1352)一题对于你们会有一点启发。

现在我们又可以想到，让每个小朋友都满足且使用最少的糖果数量，那么只需要通过别人对它没有限制的小朋友，依次更新每个小朋友要有的糖即可。

------------


>那么怎么去依次找小朋友并更新每个小朋友要的糖呢？
## 拓扑排序！

------------


>怎么建图？按什么条件去建？

比如A要少于B，则建一条A->B的边，这样拓扑排序下来，可以保证处理每个点的糖果数量时，可以从小处理到大，符合上面的要求。

------------


>那X=1、3、5和X=2、4时有什么区别呢？

我们就需要额外记录边权，X=1、3、5边权为0，X=2、4边权为1。

------------


## 血的教训：X=1时需要建双向边！即A->B且B->A。

>为什么？

因为A必须与B一样多，那么我们就可以使用Tarjan缩点将两个点合并为1个点，且将环变为强连通分量。正好满足了拓扑排序不能有环的性质。

------------


>怎么判断无解情况？

在建新图用来拓扑排序时，看两个点是否在同一个环内，在且边权为1则无解。

------------


## 最重要的一个问题：怎么更新糖果数量？
我们将每个人的糖果当做dp[i]，在删i相连的点的入度时，更新i的next的dp值

则有动态转移方程：

__dp[当前更新的点] = max(dp[当前更新的点],dp[当前删除的点] + nnei[当前删除的点][第j个邻居].边权)__

------------


~~这些知识本人Blog中都会涉及的233~~

那么思路就很明显了：

建图(X=1:建边权为0的双向边，X=2、X=4建边权为1的单向边，X=3、X=5时建边权为0的单向边)——>Tarjan——>边建新图边判断无解——>用新图拓扑排序，并更新每个点所需要的糖果数量

### 代码就很好写了

```
#include<bits/stdc++.h>
using namespace std;

const int MAXN = 100000 + 10;

int n,k;
int scc[MAXN],sum,low[MAXN],dfn[MAXN],cnt,tot[MAXN];
//以上是强连通图的必备变量，唯一tot是记录每个强连通分量里面有多少个点 
int dp[MAXN];
//这个用于DP记录答案 
int in[MAXN];
//这个记录入度，用于Topo 
long long ans;
//最终答案 
struct Node{
	int next;//记录每个点的下一个点 
	int v;//记录边权 
};
vector<Node>nei[MAXN];//旧图 
vector<Node>nnei[MAXN];//新图 
bool Stack[MAXN];//用于Tarjan 
stack<int> s;//用于Tarjan

inline int read(){//快速读入 
    int f = 1, x = 0;
    char c = getchar();

    while (c < '0' || c > '9')
    {
        if (c == '-')
            f = -1;
        c = getchar();
    }

    while (c >= '0' && c <= '9')
    {
        x = x * 10 + c - '0';
        c = getchar();
    }

    return f * x;
}


void Tarjan(int u){//Tarjan模板 
	low[u] = dfn[u] = ++cnt;
	Stack[u] = true;
	s.push(u);
	
	int len = nei[u].size();
	for(int i = 0;i < len; i++){
		int next = nei[u][i].next;
		
		if(dfn[next] == 0){
			Tarjan(next);
			low[u] = min(low[u],low[next]);
		}else
		if(Stack[next]){
			low[u] = min(low[u],dfn[next]);
		}
	}
	
	if(dfn[u] == low[u]){
		sum++;
		scc[u] = sum;
		Stack[u] = false;
		tot[sum]++;
		
		while(s.top() != u){
			Stack[s.top()] = false;
			scc[s.top()] = sum;
			s.pop();
			tot[sum]++;
		}
		s.pop();
	}
}

int main()
{
	n = read(),k = read();//读入 
	
	for(int i = 1;i <= k; i++){
		int z = read(),x = read(),y = read();
		switch(z){//使用开关函数 
			case 1:{//一号情况 
				nei[x].push_back((Node){y,0});
				nei[y].push_back((Node){x,0});
				//这里一定要建两条边！ 
				break;
			}
			case 2:{//二号情况 
				nei[x].push_back((Node){y,1});
				break;
			}
			case 3:{//三号情况 
				nei[y].push_back((Node){x,0});
				break;
			}
			case 4:{//四号情况 
				nei[y].push_back((Node){x,1});
				break;
			}
			case 5:{//五号情况 
				nei[x].push_back((Node){y,0});
				break;
			}
		}
	}

	for(int i = 1;i <= n; i++){
    	if(dfn[i] == 0)Tarjan(i);//Tajan 
    }

    for(int i = 1;i <= n; i++){//建新图 
    	int len = nei[i].size();
		
		for(int j = 0;j < len; j++){
			int next = nei[i][j].next;
			int xx = scc[i];
        	int yy = scc[next];
        
        	if(xx == yy && nei[i][j].v == 1){//判断无解  
        		cout<<-1<<"\n";
        		return 0;
			}
        
        	if(xx != yy){//建新图 
        	    nnei[xx].push_back((Node){yy,nei[i][j].v});
        	    in[yy]++;
        	}
		}
    }
    
    queue<int>q;//Topo模板 
    
    for(int i = 1;i <= sum; i++){//将入读为0的压入队列 
    	if(!in[i]){
    		q.push(i);
    		dp[i] = 1;//初始化 
		}
	}
	
	while(!q.empty()){//拓扑模板 
		int cur = q.front();
		q.pop();
		int len = nnei[cur].size();
		
		for(int i = 0;i < len; i++){
			int next = nnei[cur][i].next;
			in[next]--;
			dp[next] = max(dp[next],dp[cur] + nnei[cur][i].v);//Dp方程 
			
			if(!in[next])q.push(next);
		}
	}
	
	for(int i = 1;i <= sum; i++){//累加答案 
		ans += (long long) dp[i] * tot[i];
	}
	cout<<ans;//输出 
	return 0;
}


```

代码不做非常详细的注释，自己对照前面~~详细的~~讲解看看吧233

### 感谢我的教练 @LiveDream 帮我DeBug!

---

## 作者：do_while_true (赞：35)

首先它是个差分约束系统，要求变量总和最小就跑最长路。

但是它边权只有 $0$ 或 $1$，考虑这个图有什么特殊性质。

先缩点，每个 SCC 内部如果出现了一条 $u$ 到 $v$ 的边权为 $1$，根据 SCC 的定义，一定还存在一条 $v$ 到 $u$ 的路径，由于边权 $\geq 0$，所以一定会出现一个正权环，则这个差分约束系统无解。

否则的话，发现 SCC 内部变量取值一定是相同的，那么问题变成了一个 DAG 上最长路，拓扑排序即可。

```cpp
#include<cstdio>
#include<vector>
#include<queue>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<ctime>
#include<random>
#include<assert.h>
#define pb emplace_back
#define mp make_pair
#define fi first
#define se second
#define dbg(x) cerr<<"In Line "<< __LINE__<<" the "<<#x<<" = "<<x<<'\n';
#define dpi(x,y) cerr<<"In Line "<<__LINE__<<" the "<<#x<<" = "<<x<<" ; "<<"the "<<#y<<" = "<<y<<'\n';
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int>pii;
typedef pair<ll,int>pli;
typedef pair<ll,ll>pll;
typedef vector<int>vi;
typedef vector<ll>vll;
typedef vector<pii>vpii;
template<typename T>T cmax(T &x, T y){return x=x>y?x:y;}
template<typename T>T cmin(T &x, T y){return x=x<y?x:y;}
template<typename T>
T &read(T &r){
	r=0;bool w=0;char ch=getchar();
	while(ch<'0'||ch>'9')w=ch=='-'?1:0,ch=getchar();
	while(ch>='0'&&ch<='9')r=r*10+(ch^48),ch=getchar();
	return r=w?-r:r;
}
template<typename T1,typename... T2>
void read(T1 &x, T2& ...y){ read(x); read(y...); }
const int N=100010;
int n,m;
int dfn[N],low[N],dft;
int st[N],top;
int blo[N],sct;
int in[N],ct[N],f[N];
vpii eg[N],et[N];
inline void addg(int u,int v,int w){
//	cout << "Edge: " << u << ' ' << v << ' ' << w << '\n';
	eg[u].pb(mp(v,w));
}
inline void addt(int u,int v,int w){
	in[v]++;
	et[u].pb(mp(v,w));
}
void dfs(int x){
	dfn[x]=low[x]=++dft;st[++top]=x;
	for(auto i:eg[x]){
		int v=i.fi;
		if(!dfn[v]){
			dfs(v);
			cmin(low[x],low[v]);
		}
		else if(!blo[v])cmin(low[x],dfn[v]);
	}
	if(dfn[x]==low[x]){
		++sct;
		while(st[top+1]!=x)blo[st[top--]]=sct,ct[sct]++;
	}
}
signed main(){
	read(n,m);
	for(int i=1;i<=m;i++){
		int x,u,v;
		read(x,u,v);
		if(x==1)addg(u,v,0),addg(v,u,0);
		else{
			if(x&1)addg(x==3?v:u,x==3?u:v,0);
			else addg(x==2?u:v,x==2?v:u,1);
		}
	}
	for(int i=1;i<=n;i++)addg(0,i,1);
	dfs(0);
	for(int x=0;x<=n;x++)
		for(auto i:eg[x]){
			int v=i.fi,w=i.se;
			if(blo[x]==blo[v]&&w){
				puts("-1");
				return 0;
			}
			if(blo[x]!=blo[v])
				addt(blo[x],blo[v],w);
		}
	queue<int>q;
	for(int i=1;i<=sct;i++)
		if(!in[i]){
			q.push(i);
		}
	while(!q.empty()){
		int x=q.front();q.pop();
		for(auto i:et[x]){
			int v=i.fi,w=i.se;
			--in[v];cmax(f[v],f[x]+w);
			if(!in[v]){
				q.push(v);
			}
		}
	}
	ll ans=0;
	for(int i=1;i<=sct;i++)ans+=1ll*f[i]*ct[i];
	cout << ans << '\n';
	return 0;
}
```

---

## 作者：FlashHu (赞：16)

差分约束模板题，等于双向连0边，小于等于单向连0边，小于单向连1边，我太蒻了，总喜欢正边权跑最长路。。。。。。

看遍了讨论版，我是真的不敢再入复杂度有点~~超级~~伪的SPFA的坑了

为了保证复杂度，需要缩点后用拓扑排序统计答案。首先全相等的点本质上是相同的，可以缩到一起，所以先来一波Tarjan把0环全缩起来。接着再考虑边权为1的边。如果这时候还出现了环（包括缩点以后的自环），一定是不存在方案的，这是可以用拓扑排序判断。否则，就是个DAG，拓扑排序也可以直接计算出答案。

统计答案要注意：因为缩了点，所以答案要乘上超级点的size；因为每个小朋友都要有糖，所以最后答案+n（或者也可以将虚点的d值初始化为1，只不过最后要减掉1）

~~我不会说我连Tarjan都不会写调了半个下午的~~
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
#define I inline
#define R register
#define G ch=getchar()
#define REP for(i=1;i<=n;++i)
#define add(L,X,Y)\
	l[++p]=L;to[p]=Y;\
	ne[p]=he[X];he[X]=p;\
	if(!tl[X])tl[X]=p//鬼畜tl指向链表尾部，方便链表合并
const int N=100009,M=N*3;
int p,df,tot,he[N],tl[N],ne[M],to[M],rd[N],d[N],low[N],dfn[N],sz[N],f[N],st[N];
bool l[M];
template<typename T>
I void in(R T&z){
	R char G;
	while(ch<'-')G;
	z=ch&15;G;
	while(ch>'-')z*=10,z+=ch&15,G;
}
void tarjan(R int x){
	low[st[++p]=x]=dfn[x]=++df;
	for(R int y,i=he[x];i;i=ne[i]){
		if(l[i])continue;//只能缩0环
		if(!dfn[y=to[i]]){
			tarjan(y);
			low[x]=min(low[x],low[y]);
		}
		else if(!f[y])low[x]=min(low[x],dfn[y]);
	}
	if(low[x]==dfn[x]){
		++tot;
		do ++sz[f[st[p]]=x];
		while(st[p--]!=x);
	}
}
int main(){
	R int p=0,n,k,S,o,x,y,i,j,cnt=0;
	in(n);in(k);S=n+1;
	R long long ans=n;//好像
	while(k--){
		in(o);in(x);in(y);
		switch(o){
			case 1:add(0,x,y);add(0,y,x);break;
			case 2:add(1,x,y);break;
			case 3:add(0,y,x);break;
			case 4:add(1,y,x);break;
			case 5:add(0,x,y);
		}
	}
	for(i=1;i<=n;++i){add(0,S,i);}//虚点搞上
	tarjan(S);
	for(i=1;i<=S;++i){
		x=f[i];
		for(j=he[i];j;j=ne[j]){
			y=to[j]=f[to[j]];//改一下
			if(x!=y)++rd[y];//在新图上统计入度
			else if(l[j]){puts("-1");return 0;}//自环可以直接判掉
		}
	}
	for(i=1;i<=S;++i)//合并链表
    	if(i!=f[i])ne[tl[i]]=he[f[i]],he[f[i]]=he[i];
	st[p=1]=S;
	while(p){
		++cnt;//统计进入拓扑排序的总点数
		ans+=d[x=st[p--]]*sz[x];
		for(i=he[x];i;i=ne[i]){
			y=to[i];
			d[y]=max(d[y],d[x]+l[i]);
			if(!--rd[y])st[++p]=y;
		}
	}
	printf("%lld\n",cnt<tot?-1:ans);
	return 0;
}
```

---

## 作者：CreeperLordVader (赞：14)

### 听说顺序搜会超时？至少我是顺序搜A了

建图的过程见楼下DALAO(差分约束),这里我们主要看看怎么顺序搜索

为了避免存在多个联通块，我们首先需要一个use数组来标记这个点有没有走过,这个数组在走完DFS之后不清除，这样我们就不需要从0往其他点连边了,遍历的时候循环所有点，如果没有走过，就把它的距离值(就是下面的d数组)设为1.
# 为什么要设为1呢？

## 因为每个小朋友至少要有1个糖果，在此基础上DFS就可以求出所有小朋友的糖果数量

DFS判正(负)环的过程很好懂，就是先打一个vis标记，然后拓展，如果拓展的时候遇到了已经打过标记的点，就说明有正(负)环，最后在退出函数的时候清除VIS标记即可

在本题中，如果没有正环把所有的d[i]加起来即是答案

否则有正环说明无解

# $sum$一定要开long long!

## 否则会WA#6

code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
long long sum;
long long d[100010];
bool use[100010],vis[100010];
vector<int>v[100010];
vector<int>e[100010];
void read(int& x)
{
    char c=getchar();
    x=0;
    while(c<'0'||c>'9')c=getchar();
    while(c>='0'&&c<='9')
    {
        x=x*10+c-'0';
        c=getchar();
    }
}
bool dfs(int fa)
{
    vis[fa]=1;
    use[fa]=1;
    for(unsigned int i=0;i<v[fa].size();i++)
    {
        int y=v[fa][i];
        int z=e[fa][i];
        if(d[y]<d[fa]+z)
        {
            if(vis[y])return 1;
            d[y]=d[fa]+z;
            if(dfs(y))return 1;
        }
    }
    vis[fa]=0;
    return 0;
}
int main()
{
    read(n);
    read(k);
    for(int i=1;i<=k;i++)
    {
        int x,a,b;
        read(x);
        read(a);
        read(b);
        switch(x)
        {
            case 1:
            {
                v[a].push_back(b);
                e[a].push_back(0);
                v[b].push_back(a);
                e[b].push_back(0);
                break;
            }
            case 2:
            {
                v[a].push_back(b);
                e[a].push_back(1);
                break;
            }
            case 3:
            {
                v[b].push_back(a);
                e[b].push_back(0);
                break;
            }
            case 4:
            {
                v[b].push_back(a);
                e[b].push_back(1);
                break;
            }
            case 5:
            {
                v[a].push_back(b);
                e[a].push_back(0);
                break;
            }
        }
    }
    bool ok=0;
    for(int i=1;i<=n;i++)
    {
        if(!use[i])
        {
            d[i]=1;
            if(dfs(i))ok=1;
        }
    }
    for(int i=1;i<=n;i++)sum+=d[i];
    if(ok)printf("-1\n");
    else printf("%lld\n",sum);
    return 0;
}
```
# ~~银河帝国万岁！~~

---

## 作者：Adove (赞：11)

### 羧点+拓扑排序可以胜任此题

我们先连接1/3/5的边，对于2/3/4/5我们要把边存起来备用

tarjan缩一次点，图就变成一个DAG，此时重构图，2/4情况直接连边；3/5情况如果两点不在一个强连通分量里就连起来。

拓扑排序+DP

转移方程：

$candy[a[i].nx]=max(candy[a[i].nx],candy[nw]+a[i].ln);$

$ans=\sum_{i=1}^{clr[0]}(candy[i]*siz[i]);$

是否有解直接判断拓扑排序队列的tail与clr[0]的大小关系就可以了，不需要vis数组

上代码↓

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;

const int MAXN=1e5+5;

int n,m,x,y,z,np;
long long ans;
int tp[MAXN],lw[MAXN],clr[MAXN],stk[MAXN],cdy[MAXN];
int into[MAXN],q[MAXN],h[MAXN],siz[MAXN];
bool vis[MAXN];
struct lint{
	int ls,nx,ln;
}line[MAXN];
struct rpg{
	int li,nx,ln;
}a[MAXN<<1];

inline int read(){
	int x=0;char ch=getchar();
	while(ch<'0'||'9'<ch) ch=getchar();
	while('0'<=ch&&ch<='9') x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return x;
}

void add(int ls,int nx,int ln){
	a[++np]=(rpg){h[ls],nx,ln};
	h[ls]=np;
}

void tarjan(int x){
	tp[x]=lw[x]=++tp[0];
	stk[++stk[0]]=x;
	vis[x]=1;
	for(int i=h[x];i;i=a[i].li){
		if(!tp[a[i].nx]){
			tarjan(a[i].nx);
			lw[x]=min(lw[x],lw[a[i].nx]);
		}else if(vis[a[i].nx]){
			lw[x]=min(lw[x],tp[a[i].nx]);
		}
	}if(tp[x]==lw[x]){
		clr[x]=++clr[0];vis[x]=0;
		while(stk[stk[0]]!=x){
			clr[stk[stk[0]]]=clr[0];
			vis[stk[stk[0]--]]=0;
		}--stk[0];
	}
}

void topsort(){
	int hd=1,tl=1;
	q[hd]=0;
	while(hd<=tl){
		int nw=q[hd++];
		for(int i=h[nw];i;i=a[i].li){
			--into[a[i].nx];cdy[a[i].nx]=max(cdy[a[i].nx],cdy[nw]+a[i].ln);
			if(!into[a[i].nx]){
				q[++tl]=a[i].nx;
				ans+=siz[a[i].nx]*cdy[a[i].nx];
			}
		}
	}if(tl<=clr[0]){
		puts("-1");return;
	}printf("%lld\n",ans);
	return;
}

void init(){
	n=read(),m=read();
	for(int i=1;i<=m;++i){
		z=read(),x=read(),y=read();
		if(z==1) add(x,y,0),add(y,x,0);
		else if(z==2) line[++line[0].nx]=(lint){x,y,1};
		else if(z==3) add(y,x,0),line[++line[0].nx]=(lint){y,x,0};
		else if(z==4) line[++line[0].nx]=(lint){y,x,1};
		else add(x,y,0),line[++line[0].nx]=(lint){x,y,0};
	}for(int i=1;i<=n;++i){
		if(!clr[i]) tarjan(i);
	}for(int i=1;i<=n;++i) ++siz[clr[i]];
	return;
}

void solve(){
	np=0,memset(h,0,sizeof(h));
	for(int i=1;i<=clr[0];++i) add(0,i,1),++into[i];
	for(int i=1;i<=line[0].nx;++i){
		if(line[i].ln==0){
			if(clr[line[i].ls]!=clr[line[i].nx]){
				add(clr[line[i].ls],clr[line[i].nx],0);
				++into[clr[line[i].nx]];
			}
		}else{
			add(clr[line[i].ls],clr[line[i].nx],1);
			++into[clr[line[i].nx]];
		}
	}topsort();
	return;
}

int main(){
	init();
	solve();
	return 0;
}
```

---


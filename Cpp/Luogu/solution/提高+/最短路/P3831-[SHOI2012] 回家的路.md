# [SHOI2012] 回家的路

## 题目背景

SHOI2012 D2T1


## 题目描述

2046 年 OI 城的城市轨道交通建设终于全部竣工，由于前期规划周密，建成后的轨道交通网络由$2n$条地铁线路构成，组成了一个$n$纵$n$横的交通网。如下图所示，这$2n$条线路每条线路都包含$n$个车站，而每个车站都在一组纵横线路的交汇处。


出于建设成本的考虑，并非每个车站都能够进行站内换乘，能够进行站内换乘的地铁站共有$m$个，在下图中，标上方块标记的车站为换乘车站。已知地铁运行 1 站需要 2 分钟，而站内换乘需要步行 1 分钟。Serenade 想要知道，在不中途出站的前提下，他从学校回家最快需要多少时间（等车时间忽略不计）。


![](https://cdn.luogu.com.cn/upload/pic/6547.png)


## 说明/提示

对于 30%的数据，$n\le 50,m\le 1000$；

对于 60%的数据，$n\le 500,m\le 2000$；

对于 100%的数据，$n\le 20000,m\le 100000$；


## 样例 #1

### 输入

```
2 1
1 2
1 1 2 2```

### 输出

```
5```

## 样例 #2

### 输入

```
6 9
2 1
2 5
3 2
4 4
5 2
5 6
6 1
6 3
6 4
1 1 4 6```

### 输出

```
27```

## 样例 #3

### 输入

```
6 10
2 1
2 5
3 2
4 4
5 2
5 6
6 1
6 3
6 4
6 6
1 1 4 6```

### 输出

```
26```

# 题解

## 作者：Heartlessly (赞：53)

## Description

给定一个 $n \times n\ (1 \leq n \leq 2 \times 10^4)$ 的网格图，走一条边用时 $2$，只能在特定的 $m\ (1 \leq m \leq 10^5)$ 个点转向，转向用时 $1$，求从 $(x_1,x_2)$ 到 $(y_1, y_2)$ 的最短用时。

## Solution

考虑 **分层图最短路** 。

对于样例：

### Sample Input

```
6 9
2 1
2 5
3 2
4 4
5 2
5 6
6 1
6 3
6 4
1 1 4 6
```

### Sample Output

```
27
```

题目所给的图：

![ENyre1.png](https://s2.ax1x.com/2019/05/03/ENyre1.png)

我们按照输入的顺序给这些点标上号（包括起点和终点），共 $m + 2$ 个点。

![ENyBLR.png](https://s2.ax1x.com/2019/05/03/ENyBLR.png)

设 $n = m + 2$，表示点的数量。起点为 $10$ 号节点，终点为 $11$ 号节点。

我们可以把图分成两层，其中第 $1$ 层为横向走，第 $2$ 层为纵向走。

先考虑横向走。将所有点以横坐标为第 $1$ 关键字，纵坐标为第 $2$ 关键字从小到大排序。排完序后，判断相邻两个点的横坐标是否相同，如果相同，则在它们两个点之间连一条边权为 **两点纵坐标之差的两倍** 的双向边。若可以连边 $u \leftrightarrow  v$，则说明从点 $u$ 可以横向走到点 $v$，亦可以从点 $v$ 横向走到点 $u$ 。

图中可以连的边有：

$1 \leftrightarrow 2$

$4 \leftrightarrow 11$

$5 \leftrightarrow 6$

$7 \leftrightarrow 8$

$8 \leftrightarrow 9$

边权分别为 $8,4,8,4,2$ 。

纵向走同理。因为纵向走在第 $2$ 层，节点编号不能与第 $1$ 层相同，所以给第 $2$ 层编号全部 $+n$ 。然后将所有点以纵坐标为第 $1$ 关键字，横坐标为第 $2$ 关键字从小到大排序。比较相邻两点纵坐标，连边。若可以连边 $u \leftrightarrow  v$，则说明从点 $u$ 可以纵向走到点 $v$，也可以从点 $v$ 纵向走到点 $u$ 。

图中可以连的边有：

$10+11 \leftrightarrow 1+11$

$1+11 \leftrightarrow 7+11$

$3+11 \leftrightarrow 5+11$

$4+11 \leftrightarrow 9+11$

$11+11 \leftrightarrow 6+11$

边权分别为 $2,8,4,4,2$ 。

接下来在两层 **表示同个节点的点** 之间连一条权值为 $1$ 的双向边，表示可以在该点改变方向，用时为 $1$ 。

注意起点和终点改变方向不需要 $1$ 的时间，所以在 起点 与 起点$ + n$ 之间，终点 与 终点$ + n$ 之间连一条边权为 $0$ 的双向边。

最后跑一遍起点到终点的最短路即是答案，时间复杂度为 $O(m\log m)$。

完整的图：

![EN41OS.png](https://s2.ax1x.com/2019/05/03/EN41OS.png)

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

template <class T>
inline void read(T &x) {
    x = 0;
    char c = getchar();
    bool f = 0;
    for (; !isdigit(c); c = getchar()) f ^= c == '-';
    for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);
    x = f ? -x : x;
}

template <class T>
inline void write(T x) {
    if (x < 0) {
        putchar('-');
        x = -x;
    }
    T y = 1;
    int len = 1;
    for (; y <= x / 10; y *= 10) ++len;
    for (; len; --len, x %= y, y /= 10) putchar(x / y + 48);
}

const int MAXN = 3e5, MAXM = 3e6;
int n, m, s, t, tot, head[MAXN + 5], dis[MAXN + 5];
bool vis[MAXN + 5];
struct Station {
    int x, y, id;
} a[MAXN + 5];
struct Edge {
    int next, to, dis;
} e[MAXM + 5];
struct Node {
    int val, id;
    inline friend bool operator<(Node x, Node y) {
        return x.val > y.val;
    }
};

inline void addEdge(int u, int v, int w) {
    e[++tot] = (Edge) { head[u], v, w };
    head[u] = tot;
}

inline bool cmpx(Station a, Station b) {//按横坐标排序 
    return a.x == b.x ? a.y < b.y : a.x < b.x;
}

inline bool cmpy(Station a, Station b) {//按纵坐标排序
    return a.y == b.y ? a.x < b.x : a.y < b.y;
}

inline void dijkstra(int s) {//堆优化 dijkstra 
    priority_queue<Node> q;
    memset(dis, 0x3f, sizeof (dis));
    dis[s] = 0;
    q.push((Node) { 0, s });
    for (; !q.empty(); ) {
        int u = q.top().id;
        q.pop();
        if (vis[u]) continue;
        vis[u] = 1;
        for (int v, w, i = head[u]; v = e[i].to, w = e[i].dis, i; i = e[i].next)
            if (dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w;
                if (!vis[v]) q.push((Node) { dis[v], v });
            }
    }
}

int main() {
    read(n), read(m);
    n = m + 2;//点的总数 
    s = n - 1, t = n;//起点 和 终点 
    for (int i = 1; i <= n; ++i) {
        read(a[i].x), read(a[i].y);
        a[i].id = i;//点的编号 
    }
    sort(a + 1, a + n + 1, cmpx);
    for (int i = 1; i < n; ++i)
        if (a[i].x == a[i + 1].x) {
            addEdge(a[i].id, a[i + 1].id, (a[i + 1].y - a[i].y) << 1);
            addEdge(a[i + 1].id, a[i].id, (a[i + 1].y - a[i].y) << 1);
        } //第一层：横向边 
    sort(a + 1, a + n + 1, cmpy);
    for (int i = 1; i < n; ++i)
        if (a[i].y == a[i + 1].y) {
            addEdge(a[i].id + n, a[i + 1].id + n, (a[i + 1].x - a[i].x) << 1);
            addEdge(a[i + 1].id + n, a[i].id + n, (a[i + 1].x - a[i].x) << 1);
        } //第二层：纵向边 
    for (int i = 1; i <= n - 2; ++i) addEdge(i, i + n, 1), addEdge(i + n, i, 1);
    //两层之间：改变方向用时 1 
    addEdge(s, s + n, 0), addEdge(s + n, s, 0);
    addEdge(t, t + n, 0), addEdge(t + n, t, 0);//起点和终点改变方向不需要时间 
    dijkstra(s);//求 s -> t 最短路 
    write(dis[t] == 0x3f3f3f3f ? -1 : dis[t]);//判断是否有解 
    putchar('\n');
    return 0;
}
```

---

## 作者：消失的海岸线 (赞：50)

人话题意：一个网格图，横竖走一条边用时 2，只能在特定点转向，横竖转向用时 1，问两点最短用时...

即经典的分层图最短路裸题，在此简要介绍：

我们可能遇到这样的图论模型：在一个正常的图上可以进行 $k$ 次**决策**，对于每次决策，不影响图的结构，只影响目前的**状态**或**代价**。同时这个图论模型和经典的最短路有关，这样我们可以考虑运用分层图最短路。

此题为朴素的裸题，在此仅介绍一种（时空非最优）的易于理解的实现方法：（我懒得再写一遍了


此题的**决策**为**转向**，由于只存在横向和纵向两个放学，我们对这两个方向分别建立一层。即一层只连原图横向边，一层只连纵向边。

对于**转向**这个**决策**，将**决策**前的状态和**决策**后的状态间连接一条权值为**决策代价**的边，表示付出该代价转换了状态。

在本题中，即上下两层对应点连接一条权值为1的边，层内边权均为2.

然后跑最短路即可。

代码如下：

```cpp
#include <cmath>
#include <queue>
#include <cstdio>
#include <iomanip>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
#define N 200010
#define M 800010
#define inf 210000000
#define ll long long
using namespace std;
inline int read() 
{ 
    int x=0,f=1;char ch=getchar(); 
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();} 
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();} 
    return x*f; 
}
struct zgz
{
    int next,to,val;
}edge[M];
int cnt=1,head[M];
void add(int from,int to,int val)
{
    edge[cnt].to=to;
    edge[cnt].val=val;
    edge[cnt].next=head[from];
    head[from]=cnt++;
}
void ins(int from,int to,int val)
{add(from,to,val);add(to,from,val);}
struct point
{
    int x,y,id;
}a[N];
bool cmp1(point a,point b)
{
    if(a.x==b.x)return a.y<b.y;
    return a.x<b.x;
}
bool cmp2(point a,point b)
{
    if(a.y==b.y)return a.x<b.x;
    return a.y<b.y;
}
int n,m;
queue<int> q;
int d[N],S,T;
bool vis[N];
void spfa()
{
    for(int i=1;i<=2*m+4;i++)d[i]=inf;
    d[S]=0,vis[S]=1;q.push(S);
    while(!q.empty())
    {
        int x=q.front();q.pop();vis[x]=0;
        for(int i=head[x];i;i=edge[i].next)
        {
            int to=edge[i].to,val=edge[i].val;
            if(d[to]>d[x]+val)
            {
                d[to]=d[x]+val;
                if(!vis[to])
                {
                    vis[to]=1;
                    q.push(to);
                }
            }
        }
    }
}
int main()
{
    n=read(),m=read();S=m+1,T=m+2;
    for(int i=1;i<=m+2;i++)
    {
        a[i].x=read(),a[i].y=read();
        a[i].id=i;
    }
    sort(a+1,a+m+3,cmp1);
    for(int i=1;i<m+2;i++)
    if(a[i].x==a[i+1].x)ins(a[i].id,a[i+1].id,2*(a[i+1].y-a[i].y));
    sort(a+1,a+m+3,cmp2);
    for(int i=1;i<m+2;i++)
    if(a[i].y==a[i+1].y)ins(a[i].id+m+2,a[i+1].id+m+2,2*(a[i+1].x-a[i].x));
    for(int i=1;i<=m;i++)
    ins(i,i+m+2,1);
    ins(m+1,m*2+3,0);ins(m+2,m*2+4,0);
    spfa();
    if(d[T]==inf)
    {
        puts("-1");
        return 0;
    }
    printf("%d\n",d[T]);
}
```
进一步的相关题目可以在个人博客找到：

http://www.zgz233.xyz/2017/06/14/bzoj-2834-%E5%9B%9E%E5%AE%B6%E7%9A%84%E8%B7%AF/


---

## 作者：EDqwq (赞：19)

~~快把紫的难度换回来~~

### 思路：

这题的在换乘点换方向要一块钱（暂且这么说），而我们在一条直的边上可以一直往前走，直到碰到换乘点为止。

我们可以发现，换乘点换方向要钱，很有分层图转移的意思，实际上我们确实可以用分层图做。

我们此图不能直接走的两个部分是横和纵的边，需要换乘。

那我们建两层的图，然后换乘点作为转移层的点跑裸dijkstra就可以了。

***

### 优化：

我们可以发现，此时普通的点没有任何意义，但是我们还是要建立它，它不能向下转移，到达一个普通点还是只能往下一个点走，直到遇到换乘点。

那我们可以把普通点全部丢掉，而把换乘点连接在一起，长度加上路径上原有的所有普通点长度即可。

换乘点连接的时候，根据横和纵，需要给他们排个序，按照“在不在一条边上”排序即可。

***

### 代码&其他事项：

我们需要给出发点和终点建立一条转移的边，权值为0,。我们到达了之后，其实是不需要换乘了，而在出发点，我们也可以选择方向。

在同层图里可以来回走，转移边可以多次转移，所以我们建立的所有边都是无向边。

当m为0的时候，特判输出-1。

具体看代码。

```cpp
/*
  Author : EnderDeer
  OnlineJudge : Luogu
*/

#include<bits/stdc++.h>

#define int long long
#define plus +m+2

using namespace std;

int read(){
   int s = 0,w = 1;
   char ch = getchar();
   while(ch < '0' || ch > '9'){if(ch == '-')w = -1;ch = getchar();}
   while(ch >= '0' && ch <= '9')s = s * 10 + ch - '0',ch = getchar();
   return s * w;
}

struct node{
	int to;
	int nxt;
	int w;
}e[1000010];

struct nodee{
	int x;
	int y;
	int id;
}a[1000010];

int cnt,head[1000010];
int n,m;
int s,t;
int dis[1000010];
bool bk[1000010];

void addd(int x,int y,int w){
	cnt ++;
	e[cnt].to = y;
	e[cnt].nxt = head[x];
	e[cnt].w = w;
	head[x] = cnt;
}

void add(int x,int y,int w){
	addd(x,y,w);
	addd(y,x,w);
}

bool cmp1(nodee x,nodee y){
	if(x.x == y.x)return x.y < y.y;
	else return x.x < y.x;
}

bool cmp2(nodee x,nodee y){
	if(x.y == y.y)return x.x < y.x;
	else return x.y < y.y;
}

void dijkstra(){
	priority_queue <pair<int,int> > q;
	for(int i = 1;i <= m * 6;i ++)dis[i] = 2147483647;
	dis[s] = 0;
	q.push(make_pair(0,s));
	while(!q.empty()){
		pair <int,int> t;
		t = q.top();
		q.pop();
		int u = t.second;
		bk[u] = true;
		for(int i = head[u];i;i = e[i].nxt){
			int v = e[i].to;
			if(bk[v])continue;
			if(dis[v] > dis[u] + e[i].w){
				dis[v] = dis[u] + e[i].w;
				q.push(make_pair(-dis[v],v));
			}
		}
	}
}

signed main(){
	cin>>n>>m;
	if(m == 0){puts("-1");return 0;}
	s = m + 1;
	t = m + 2;
	for(int i = 1;i <= m + 2;i ++)a[i].x = read(),a[i].y = read(),a[i].id = i;
	sort(a + 1,a + m + 3,cmp1);
	for(int i = 1;i <= m + 1;i ++){
		if(a[i].x == a[i + 1].x){
			add(a[i].id,a[i + 1].id,(a[i + 1].y - a[i].y) * 2);
		}
	}
	sort(a + 1,a + m + 3,cmp2);
	for(int i = 1;i <= m + 1;i ++){
		if(a[i].y == a[i + 1].y){
			add(a[i].id plus,a[i + 1].id plus,(a[i + 1].x - a[i].x) * 2);
		}
	}
	for(int i = 1;i <= m;i ++)add(i,i plus,1);
	//
	add(m + 1,m * 2 + 3,0);
	add(m + 2,m * 2 + 4,0);
	//
	dijkstra();
	if(dis[t] == 2147483647)puts("-1");
	else cout<<dis[t];
	return 0;
}
```

---

## 作者：lwyz123 (赞：9)

# (~~神仙们一看就是可用~~ 分层图 ~~做的裸题~~)
### **首先我们需要读清题意：**

 看看题意，在没有换乘的情况下，一辆车只能选择横行或纵行；
 横行和纵行之间互不干扰。

 所以，我们可以想到，先将纵向建一层图，再将横向建一层图。
 
 而在换乘站上我们可以将上下两层图同一个点连一个边权为一的的边，

 对于起点和终点，我们将两层图中同一个点连一条边权为0的边。
 
#### （~~其实也可以建两个汇点~~)
![picture](https://cdn.luogu.com.cn/upload/pic/68796.png)


------------


## Solution1：N^2的做法（60分代码）
将每一个点都编号，无论其是否为换乘站。
### 

```cpp
int main()
{
	r(n),r(m);
	for(int i=1,a,b;i<=m;i++)
	{	
		r(a),r(b);
		t[(a-1)*n+b]=1;
		add((a-1)*n+b,(a-1)*n+b+n*n,1);
		add((a-1)*n+b+n*n,(a-1)*n+b,1);
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<n;j++)
		{	
			add((i-1)*n+j,(i-1)*n+j+1,2);
			add((i-1)*n+j+1,(i-1)*n+j,2);
			add((j-1)*n+i+n*n,j*n+i+n*n,2);
			add(j*n+i+n*n,(j-1)*n+i+n*n,2);
		}
	}
	int x1,y1,x2,y2;
	r(x1),r(y1),r(x2),r(y2);
	add(0,(x1-1)*n+y1,0),add(0,(x1-1)*n+y1+n*n,0);
	add((x2-1)*n+y2,2*n*n+1,0),add((x2-1)*n+y2+n*n,2*n*n+1,0);
	dj1(0);
	if(d[2*n*n+1]!=inf)cout<<d[（n*n）<<1+1]<<"\n";
	else cout<<"-1"<<"\n";
}
```

### **over！then！**


------------

## Solution 2:100分做法

那应该如何处理n^2的边呢？？？

我们可以发现给出的m个换乘站是<=200000的。

那是不是可以用换乘站来作为点呢！！！！

#### 仔细一看我们会惊奇地发现

![](https://cdn.luogu.com.cn/upload/pic/68804.png)

在两个相邻的换乘站之间中间的站点就相当于不存在。

所以你就可以通过处理换乘站之间的关系来建边跑最短路

#### 注意数据范围！其中：int——>60,long long ——>100

贴上不太好看的代码

下面是cmp

```cpp
bool cmp1(node a,node b)
{
	if(a.x<b.x)return 1;
	else if(a.x==b.x)return a.y<b.y;
	return 0;
}
bool cmp2(node a,node b)
{
	if(a.y<b.y)return 1;
	else if(a.y==b.y)return a.x<b.x;
	return 0;
}
```


### 接下来是主函数

```cpp
int main()
{
	r(n),r(m);
	for(int i=1,a,b;i<=m+2;i++)
	{	
		r(a),r(b);
		tat[i].x=a,tat[i].y=b;
		tat[i].tag=i;
		if(i>m)continue; 
		add(i,i+m+2,1);
		add(i+m+2,i,1);
	}
	sort(tat+1,tat+m+3,cmp1);
	int X=tat[1].x,Y=tat[1].y;
	for(int i=2;i<=m+2;i++)
	{
		if((X==tat[i].x)&&(Y<tat[i].y))
		{		
			int len=(tat[i].y-Y)*2; 
			add(tat[i-1].tag,tat[i].tag,len);
			add(tat[i].tag,tat[i-1].tag,len);
		}
		X=tat[i].x,Y=tat[i].y;
	}
	sort(tat+1,tat+m+3,cmp2);
	X=tat[1].x,Y=tat[1].y;
	for(int i=2;i<=m+2;i++)
	{	
		if((Y==tat[i].y)&&(X<tat[i].x))
		{	
			int len=(tat[i].x-X)*2;
			add(tat[i-1].tag+m+2,tat[i].tag+m+2,len);
			add(tat[i].tag+m+2,tat[i-1].tag+m+2,len);
		}
		X=tat[i].x,Y=tat[i].y;
	}
	add(m+m+3,m+1,0),add(m+1,m+m+3,0);
	add(m+2,m+m+4,0),add（m+m+4,m+2,0);
	dj1(m+1);
	if(d[m+2]!=inf)cout<<d[m+2]<<"\n";
	else cout<<"-1"<<"\n";
}
```




---

## 作者：iorit (赞：7)

[原题](https://www.luogu.com.cn/problem/P3831)

这是我们学校膜你赛上的一道题。

~~感觉并没有紫题难度？~~

### 思路

一眼最短路，发现$m \le 100000$，如果枚举每两个点的话会爆掉。

那么换一种建边方式罢。

显然两个点可以互相到达，当且仅当它们的`x`坐标相同或`y`坐标相同

于是我们用一个`vector`记录相同`x`上的点，枚举每两个点，连一条边。

当然也用一个`vector`记录相同`y`上的点，枚举每两个点，连一条边。

这里我们在连边的时候把换乘要用的1min也给算到边权里，当然到终点是不用换乘的，所以最终答案要减1。

最后对起点跑一遍`dijkstra`，直接输出即可。

### 代码

```cpp
// 此处应有头文件 
#define pr_q priority_queue
const int N = 2e6 + 10;
const int inf = 0x3fffffff;
int n,m,cnt,s = 0;
int head[N];
int dis[N];
bool vis[N];
struct edge
{
	int v,w,nxt;
}edge[N];
struct node
{
	int x,y;
}a[N];
void add(int u , int v , int w) // 前向星 
{
	++cnt;
	edge[cnt].v = v;
	edge[cnt].w = w;
	edge[cnt].nxt = head[u];
	head[u] = cnt;
	return ;
}
int sx,sy,fx,fy;
vector<int> samex[N],samey[N]; // samex[i]存下了所有x坐标为i的点。samey同理
struct prq // 用于dijkstra的优先队列。 
{
	int num,dis;
	bool operator < (const prq &x) const
		{return x.dis < dis;}
};
void dijkstra() // 朴素dijkstra 
{
	for(int i = 1;i <= m;i++)
		dis[i] = inf;
	dis[s] = 0;
	pr_q<prq> q;
	q.push( (prq){s , 0} );
	while( !q.empty() )
	{
		int u = q.top().num;
		q.pop();
		for(int i = head[u];i;i = edge[i].nxt)
		{
			int v = edge[i].v;
			if(dis[v] > dis[u] + edge[i].w)
			{
				dis[v] = dis[u] + edge[i].w;
				if( !vis[v] )
				{
					vis[v] = true;
					q.push( (prq){ v , dis[v] } );
				}
			}
		}
	}
}
int main()
{
	cin >> n >> m;
	for(int i = 1;i <= m;i++)
	{
		cin >> a[i].x >> a[i].y;
		samex[a[i].x].push_back(i);
		samey[a[i].y].push_back(i);
	}
	cin >> sx >> sy >> fx >> fy;
	a[0] = (node){sx , sy}; // 起点 
	samex[sx].push_back(0);
	samey[sy].push_back(0);
	a[++m] = (node){fx , fy}; // 终点 
	samex[fx].push_back(m);
	samey[fy].push_back(m);
	// 建边 
	for(int x = 1;x <= n;x++)
		for(int i = 0;i < samex[x].size();i++)
			for(int j = i + 1;j < samex[x].size();j++)
			{
				int u = samex[x][i];
				int v = samex[x][j];
				add(u , v , abs(a[u].y - a[v].y) * 2 + 1); // 同时把换乘的时间算上 
				add(v , u , abs(a[u].y - a[v].y) * 2 + 1);
			}
	for(int y = 1;y <= n;y++)
		for(int i = 0;i < samey[y].size();i++)
			for(int j = i + 1;j < samey[y].size();j++)
			{
				int u = samey[y][i];
				int v = samey[y][j];
				add(u , v , abs(a[u].x - a[v].x) * 2 + 1);
				add(v , u , abs(a[u].x - a[v].x) * 2 + 1);
			}
	dijkstra();
	if(dis[m] == inf) // 无法到达 
		puts("-1");
	else
		cout << dis[m] - 1 << endl; // 最后减1，终点不需要花时间换乘 
    return 0;
}
```


---

## 作者：Sharing666 (赞：6)

## 题意
在一个$n*n$的网格图中，横或竖走一格需要 $2$ 分钟，转向需要 $1$ 分钟，求从起点到终点的最短用时。

## 思路

分层图+最短路。

因为只有横竖两种走法，那么考虑建双层图，第一层建**横向边**，第二层建**竖向边**。首先按照 $x$ 坐标的大小排序，如果两个点
 $x$ 坐标相等,就把它们连起来

之后在层与层之间建边，**除起点、终点外**的每个点都建一条权值为 $1$的边。

**注意：**

**1.由于在起点或终点转向不用时间，即边权为 $0$,需要单独建边。**
	
**2.一共有2m+4个点。**

最后跑一遍最短路就行了，我用的是优先队列优化的 $dijkstra$。

代码：

```
#include <iostream>
#include <algorithm>
#include <queue>
using namespace std;

int n,m,cnt,head[1000010],dis[1000010],vis[1000010];
//这里要注意一下数组的大小 

struct stu{
	int num,x,y;
}a[1000010];

struct edge{
	int to,nxt,wy;
}e[1000010];

struct node{
	int ps,ds;
	bool operator<(const node &x) const{
		return x.ds<ds;
	}
};

bool cmpx(stu A,stu B) {
	if(A.x==B.x) return A.y<B.y;
	return A.x<B.x;
}

bool cmpy(stu A,stu B) {
	if(A.y==B.y) return A.x<B.x;
	return A.y<B.y;
}

void add(int A,int B,int C) {
	e[++cnt].to=B;
	e[cnt].wy=C;
	e[cnt].nxt=head[A];
	head[A]=cnt;
}

void dijkstra() {
	for(int i=1;i<=2*m+4;i++) dis[i]=2147483647;
	dis[m+1]=0;
	priority_queue<node> p;
	p.push({m+1,0});
	while(p.size()) {
		node tmp=p.top();
		p.pop();
		int u=tmp.ps;
		vis[u]=1;
		for(int i=head[u];i;i=e[i].nxt) {
			int v=e[i].to;
			if(dis[u]+e[i].wy<dis[v]) {
				dis[v]=dis[u]+e[i].wy;
				if(!vis[v]) p.push((node){v,dis[v]});
			}
		}
	}
}

int main() {
	cin>>n>>m;
	for(int i=1;i<=m+2;i++) {
		cin>>a[i].x>>a[i].y;
		a[i].num=i;
	}
	sort(a+1,a+m+3,cmpx);
	for(int i=1;i<=m+1;i++) {
		if(a[i].x==a[i+1].x) {
			add(a[i].num,a[i+1].num,2*(a[i+1].y-a[i].y));
			add(a[i+1].num,a[i].num,2*(a[i+1].y-a[i].y));
		}
	}
	sort(a+1,a+m+3,cmpy);
	for(int i=1;i<=m+1;i++) {
		if(a[i].y==a[i+1].y) {
			add(a[i].num+m+2,a[i+1].num+m+2,2*(a[i+1].x-a[i].x));
			add(a[i+1].num+m+2,a[i].num+m+2,2*(a[i+1].x-a[i].x));
		}
	}
	for(int i=1;i<=m;i++) {
		add(i,i+m+2,1);
		add(i+m+2,i,1);
	}
	add(m+1,2*m+3,0);
	add(2*m+3,m+1,0);//起点 
	add(m+2,2*m+4,0);
	add(2*m+4,m+2,0);//终点 
	dijkstra();
	if(dis[m+2]==2147483647) cout<<-1<<endl;//如果不能到达输出-1 
	else cout<<dis[m+2]<<endl;
	return 0;
}
```


---

## 作者：BurningEnderDragon (赞：5)

[题目链接：P3831 [SHOI2012]回家的路](https://www.luogu.com.cn/problem/P3831)

许多题解都已经指出，本题的算法是**分层图最短路**。

## 分层图——定义

由题可知，地铁只能横向或纵向走，想改变方向必须**在特定车站消耗时间**出站换乘。这种情况使用朴素的建图方式并不方便，所以我们直接将图抽象地分为**只连横向边**和**只连纵向边**的两张图，两张图中**对应的位置再连接一条边**，表示出站换乘。这个过程就好似把图分为了上下两层，且上下两层有若干条路径相连，故得名分层图。

[P4568 [JLOI2011]飞行路线](https://www.luogu.com.cn/problem/P4568) 同样需要使用分层图最短路算法，且思路上可能更容易将图抽象成分层图，您可以结合这道题进行理解。

## 分层图——建图

在【定义】中，我们已经说明了大致的连边思路。在本题中，更具体的建图方式如下：

### 引理

1. 对于“将图分成上下两层”的操作，可以使用两倍数组空间，即用下标为 $i$ 的位置表示上层图中编号为 $i$ 的点，用下标为 $(i+$点数$)$ 的点表示下层图中编号为 $i$ 的点。

2. 容易发现，合法的路径的一部分一定与某两个**在同一横行或同一纵列**的可换乘车站**（包括起点站和终点站）**之间的简单路径重合，所以只需要在**在同一横行或同一纵列**的**相邻**的任意两个可换乘车站之间各连一条双向边即可。

### 步骤（连横向边、纵向边和两张图之间的边这三个大步骤的顺序可以颠倒）

1. 读入可换乘车站**（包括起点站和终点站）**，记录这些车站的坐标并给其编号。（可用结构体或类完成）
2. 连接上下两层图之间的边，即在**上下两层图中对应的点**之间连一条长度为 $1$ 的边。
3. 连接**只连横向边**的图中的边，更具体地：
   1. 将所有的可换乘车站按第一关键字纵坐标，第二关键字横坐标排序。
   2. 枚举排序后相邻的两个点，若两个点的纵坐标相等，则在这两个点之间连一条长度为 $2 \times ($横坐标之差$)$ 的双向边。
4. 连接**只连纵向边**的图中的边，更具体地：
   1. 将所有的可换乘车站按第一关键字横坐标，第关键字纵坐标排序。
   2. 枚举排序后相邻的两个点，若两个点的横坐标相等，则在这两个点之间连一条长度为 $2 \times ($纵坐标之差$)$ 的双向边。

### 实现（空间管理大师警告）

**Warning：关于数组的极限大小的计算，如果不需要极限压空间可以略过，实际考试中也不建议这么做。**

#### 1. 点的最大数量

可换乘车站的数量 $m$ 的最大值为 $10^5$，加上起点和终点则为 $10^5+2$，因为要存两层图，所以最终的图中点的最大数量为 $2 \times 10^5 +4$。

点可以在数组中下标为 $0$ 的位置开始存储，所以存储有关点的信息的数组的最小大小为：

$$
2 \times 10^5 +4
$$

**在以下的实现中，全部用 $x$ 表示纵坐标，用 $y$ 表示横坐标。**

```cpp
const unsigned long int MAXN=200004;
struct Point
{
	int num,x,y;  //编号，纵坐标，横坐标
}station[MAXN];
int head[MAXN]={};  //链式前向星的head
int distance[MAXN]={};  //最短路径长度，求最短路时使用
bool visited[MAXN]={};  //点是否被访问过，同样在求最短路时使用
```

#### 2. 边的最大数量

对于极端情况，可换乘车站的数量达到最大，且所有的可换乘车站都排在同一行或同一列（当然，因为 $n_{max} < m_{max}$ ，所以实际上不可能同时满足这两个条件），此时每一层需要连的横向边或纵向边的数量为 $10^5+2-1 = 10^5+1$。因为每条边都是双向边，且图有两层，所以横向边和纵向边的最大数量为 $2 \times 2 \times (10^5+1) = 4 \times 10^5 +4$（当然横向边和纵向边也不可能同时达到最大值）。

对于连接两层图的边，边数严格与 $m+2$ 的大小相等，同样因为每条边都是双向边，所以连接两层图的边的最大数量为 $2 \times (10^5+2) = 2 \times 10^5 +4$。

综上所述，边的最大数量为 $4 \times 10^5 +4 + 2 \times 10^5 +4 = 6 \times 10^5 + 8$。

虽然链式前向星的主流写法是从下标为 $1$ 的位置开始存储，但是上面说到不可能同时达到这几种极端情况，所以这个数字是绰绰有余的，甚至还可以向下取个整。

存储有关边的信息的数组的最小大小为：

$$
6 \times 10^5
$$

真的能过。

```cpp
const unsigned long int MAXM=600000;
int count=0;
struct Edge  //链式前向星中的边
{
	int to,value,next;
}edge[MAXM];
inline void AddEdge(const int u,const int v,const int w)  //链式前向星中的加边函数
{
	++count;
	edge[count].to=v;
	edge[count].value=w;
	edge[count].next=head[u];
	head[u]=count;
	return ;
}
```

#### 3. 读入可换乘车站的坐标时，同时连接上下两层图之间的边

加上起点和终点，可换乘车站之间的总数为 $m+2$，根据【引理】中的说明，在上层图中，用下标为 $i$ 的位置表示编号为 $i$ 的车站，在下层图中，用下标为 $i+(m+2)$ 的位置表示编号为 $i$ 的车站。

**因为在起点站可以直接决定初始的乘坐方向，也不可能在终点站改变乘坐方向，所以起点站和终点站可以不连上下边。**这两个站直接存储即可。

```cpp
for(int i=1;i<=m;++i)
{
    scanf("%d%d",&x,&y);
    station[i].num=i;  //车站的编号
    station[i].x=x;  //车站的纵坐标
    station[i].y=y;  //车站的横坐标
    AddEdge(i,i+(m+2),1);  //上层图向下层图
    AddEdge(i+(m+2),i,1);  //下层图向上层图
}
scanf("%d%d",&x,&y);  //起点站
station[0].num=0;
station[0].x=x;
station[0].y=y;
scanf("%d%d",&x,&y);  //终点站
station[m+1].num=m+1;
station[m+1].x=x;
station[m+1].y=y;
```

#### 4. 将所有可换乘车站按第一关键字纵坐标，第二关键字横坐标排序

经过排序后，所有在同一横行的车站一定在序列中相邻的位置。

```cpp
inline bool cmp1(const Point a,const Point b)  //第一关键字纵坐标，第二关键字横坐标
{
	return a.x==b.x ? a.y<b.y : a.x<b.x;
}
sort(station,station+m+2,cmp1);
```

#### 5. 连接所有的横向边

枚举序列中相邻的两个车站，如果它们在同一横行上，则连一条长度为 $2 \times ($横坐标之差$)$ 的双向边。

```cpp
for(int i=1;i<=m+1;++i)
{
    if(station[i-1].x==station[i].x)  //相邻的两个车站纵坐标相等（即在同一横行上）
    {
        register int dis=station[i].y-station[i-1].y;  //横坐标之差
        AddEdge(station[i-1].num,station[i].num,2*dis);
        AddEdge(station[i].num,station[i-1].num,2*dis);
    }
}
```

#### 6. 将所有可换乘车站按第一关键字横坐标，第二关键字纵坐标排序

经过排序后，所有在同一纵列的车站一定在序列中相邻的位置。

```cpp
inline bool cmp2(const Point a,const Point b)  //第一关键字横坐标，第二关键字纵坐标
{
	return a.y==b.y ? a.x<b.x : a.y<b.y;
}
sort(station,station+m+2,cmp2);
```

#### 7.连接所有的纵向边

枚举序列中相邻的两个车站，如果它们在同一纵列上，则连一条长度为 $2 \times ($纵坐标之差$)$ 的双向边。

**注意在下层图中连边，即下标要加上 $m+2$。**

```cpp
for(int i=1;i<=m+1;++i)
{
    if(station[i-1].y==station[i].y)  //相邻的两个车站横坐标相等（即在同一纵列上）
    {
        register int dis=station[i].x-station[i-1].x;  //纵坐标之差
        AddEdge(station[i-1].num+(m+2),station[i].num+(m+2),2*dis);
        AddEdge(station[i].num+(m+2),station[i-1].num+(m+2),2*dis);
    }
}
```

至此，已经全部完成了本题的建图操作。

## 最短路

以“分层图”的思想建好图之后，用标准的单源最短路径算法计算最短路即可。

需要分别以**上层图中的起点站**和**下层图中的起点站**为源点（分别对应初始横向乘车和初始纵向乘车的情况），计算一次最短路，并取**以下四个结果的最小值**作为答案：

- 以上层图中的起点站为源点，到上层图中的终点站的最短路径；
- 以上层图中的起点站为源点，到下层图中的终点站的最短路径；
- 以下层图中的起点站为源点，到上层图中的终点站的最短路径；
- 以下层图中的起点站为源点，到下层图中的终点站的最短路径。

我使用了 Dijkstra 算法。

```cpp
inline void Dijkstra(const int s)
{
	for(int i=0;i<=2*m+3;++i)
	{
		distance[i]=2147483647;
		visited[i]=0;
	}
	priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > que;
	distance[s]=0;
	que.push(make_pair(0,s));
	while(!que.empty())
	{
		register int start=que.top().second;
		que.pop();
		if(!visited[start])
		{
			visited[start]=1;
			for(int i=head[start];i;i=edge[i].next)
			{
				register int to=edge[i].to;
				if(distance[to]>distance[start]+edge[i].value)
				{
					distance[to]=distance[start]+edge[i].value;
					que.push(make_pair(distance[to],to));
				}
			}
		}
	}
	return ;
}
Dijkstra(0);
ans=min(distance[m+1],distance[2*m+3]);
Dijkstra(m+2);
ans=min(ans,min(distance[m+1],distance[2*m+3]));
```

## 完整 AC 代码

如果您认真地阅读到了这里，您一定可以自己写出完整代码，那么也没有阅读完整代码的必要啦~

如果您确有需求，可以通过[这里](https://www.luogu.com.cn/paste/s2ff93w5)查看。篇幅有限，故我把它放在了云剪贴板中。

---

## 作者：LB_tq (赞：5)

# 分层图+最短路
看到题意，第一反应：暴力BFS！

看到难度：~~真香。~~

好的。

## 分层图

题目中给出的只有两种状态：**横边和纵边**。我们建立两层图，第一层只存储横边，第二层只存储纵边。

显然，只需要在相邻两个**换乘站**（即可以转向的交汇站）之间建立双向边。~~否则走到其他站点就再也回不了家了。~~

于是，在每一层内，**我们分别以换乘站的横坐标或纵坐标为第一关键字排序**，那样就省去了一个换乘站和其他所有都建边的操作，只需在相邻两个之间建边即可，并且不影响图的连通性。

之后考虑层与层之间建边。如果要从一层转到另一层（**相当于转向操作**），需要1单位时间。那么就将每层中的相同节点之间建立一条边权为一的边。特别地，**起点和终点要建立边权为0的边**。

至于每一层的相同节点，我们把两个相同的点编号为**i和i+maxm**，就可以了。**排序前记得存储初始编号。**

## 最短路

建好图之后，就可以像普通的题一样跑最短路了。这里给出两种：

**堆优化Dijkstra和SPFA**

这道题好像SPFA更快一些（~~好吧可能是我Dijkstra偷懒用了pair~~）

附上代码：

### SPFA
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cstring>
using namespace std;
const int maxm=1e5+10;
int n,m,s,f[maxm<<1],dis[maxm<<1],vis[maxm<<1];//f是邻接表数组；
//dis记录距离，vis记录是否在SPFA的队列里。
queue<int>q;
struct node{
	int x;
	int y;
	int z;
}a[maxm];//存储换乘站信息
struct edge{
	int t;
	int v;
	int w;
}e[maxm*6];//存储边，数组要开大，大约6倍叭 
int fr(){
	char ch=getchar();
	while(ch>'9'||ch<'0')
		ch=getchar();
	int sum=ch-'0';
	while((ch=getchar())>='0'&&ch<='9')
		sum=(sum<<3)+(sum<<1)+ch-'0';
	return sum;
}
void add(int xx,int yy,int zz){
	s++;
	e[s].t=f[xx];
	e[s].v=yy;
	e[s].w=zz;
	f[xx]=s;
}//加边
bool cmp1(node xx,node yy){
	if(xx.x!=yy.x)
		return xx.x<yy.x;
	return xx.y<yy.y;
}
bool cmp2(node xx,node yy){
	if(xx.y!=yy.y)
		return xx.y<yy.y;
	return xx.x<yy.x;
}//排序函数
void build(){
	sort(a+1,a+m+1,cmp1);
	for(int i=2;i<=m;i++)
		if(a[i].x==a[i-1].x){
			add(a[i].z,a[i-1].z,(a[i].y-a[i-1].y)<<1);
			add(a[i-1].z,a[i].z,(a[i].y-a[i-1].y)<<1);
		}
	sort(a+1,a+m+1,cmp2);
	for(int i=2;i<=m;i++)
		if(a[i].y==a[i-1].y){
			add(a[i].z+maxm,a[i-1].z+maxm,(a[i].x-a[i-1].x)<<1);
			add(a[i-1].z+maxm,a[i].z+maxm,(a[i].x-a[i-1].x)<<1);
		}
	for(int i=1;i<=m;i++)
		if(a[i].z<=m-2){
			add(a[i].z,a[i].z+maxm,1);
			add(a[i].z+maxm,a[i].z,1);
		}
	add(m-1,m-1+maxm,0);
	add(m-1+maxm,m-1,0);
	add(m,m+maxm,0);
	add(m+maxm,m,0);//起点终点转向不需要时间。
}
void spfa(int sn){
	dis[sn]=0;
	q.push(sn);
	vis[sn]=1;
	int d;
	while(!q.empty()){
		d=q.front();
		q.pop();
		vis[sn]=0;
		for(int i=f[d];i!=0;i=e[i].t)
			if(dis[e[i].v]>dis[d]+e[i].w){
				dis[e[i].v]=dis[d]+e[i].w;
				if(!vis[e[i].v]){
					q.push(e[i].v);
					vis[e[i].v]=1;
				}
			}
	}
}
int main(){
	n=fr();
	m=fr();
	m+=2;//起点终点一起读入建边
	for(int i=1;i<=m;i++){
		a[i].x=fr();
		a[i].y=fr();
		a[i].z=i;//记录初始编号
	}
	build();
	memset(dis,0x3f,sizeof(dis));//dis初始化
	spfa(m-1);
	printf("%d",dis[m]);
	return 0;
}
```
**Dijkstra的数组同上。**
### 堆优化Dijkstra
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cstring>
using namespace std;
const int maxm=1e5+10;
int n,m,s,f[maxm<<1],dis[maxm<<1],vis[maxm<<1];
priority_queue<pair<int,int> >q;
struct node{
	int x;
	int y;
	int z;
}a[maxm];
struct edge{
	int t;
	int v;
	int w;
}e[maxm*6];
int fr(){
	char ch=getchar();
	while(ch>'9'||ch<'0')
		ch=getchar();
	int sum=ch-'0';
	while((ch=getchar())>='0'&&ch<='9')
		sum=(sum<<3)+(sum<<1)+ch-'0';
	return sum;
}
void add(int xx,int yy,int zz){
	s++;
	e[s].t=f[xx];
	e[s].v=yy;
	e[s].w=zz;
	f[xx]=s;
}
bool cmp1(node xx,node yy){
	if(xx.x!=yy.x)
		return xx.x<yy.x;
	return xx.y<yy.y;
}
bool cmp2(node xx,node yy){
	if(xx.y!=yy.y)
		return xx.y<yy.y;
	return xx.x<yy.x;
}
void build(){
	sort(a+1,a+m+1,cmp1);
	for(int i=2;i<=m;i++)
		if(a[i].x==a[i-1].x){
			add(a[i].z,a[i-1].z,(a[i].y-a[i-1].y)<<1);
			add(a[i-1].z,a[i].z,(a[i].y-a[i-1].y)<<1);
		}
	sort(a+1,a+m+1,cmp2);
	for(int i=2;i<=m;i++)
		if(a[i].y==a[i-1].y){
			add(a[i].z+maxm,a[i-1].z+maxm,(a[i].x-a[i-1].x)<<1);
			add(a[i-1].z+maxm,a[i].z+maxm,(a[i].x-a[i-1].x)<<1);
		}
	for(int i=1;i<=m;i++)
		if(a[i].z<=m-2){
			add(a[i].z,a[i].z+maxm,1);
			add(a[i].z+maxm,a[i].z,1);
		}
	add(m-1,m-1+maxm,0);
	add(m-1+maxm,m-1,0);
	add(m,m+maxm,0);
	add(m+maxm,m,0);
}
void dijkstra(int sn){
	dis[sn]=0;
	q.push(make_pair(0,sn));
	int d;
	while(!q.empty()){
		d=q.top().second;
		q.pop();
		if(vis[d])
			continue;
		vis[d]=1;
		for(int i=f[d];i!=0;i=e[i].t)
			if(dis[e[i].v]>dis[d]+e[i].w){
				dis[e[i].v]=dis[d]+e[i].w;
				q.push(make_pair(-dis[e[i].v],e[i].v));
			}
	}
}
int main(){
	n=fr();
	m=fr();
	m+=2;
	for(int i=1;i<=m;i++){
		a[i].x=fr();
		a[i].y=fr();
		a[i].z=i;
	}
	build();
	memset(dis,0x3f,sizeof(dis));
	dijkstra(m-1);
	printf("%d",dis[m]);
	return 0;
}

```
好的就是这个亚子。

## 祝大家早日AC~

---

## 作者：King丨帝御威 (赞：5)

裸的分层最短路，对于这个题目来说，层与层之间的权值为$1$。

而且看数据范围，$n$这么大的一个范围，肯定不能$n^2$存图了，那么我们就枚举每个中转点(换乘点)，横纵分别求两个中转点之间的距离，然后存下来，每层起点和起点的映射及终点和终点的映射都要是0，然后直接上堆优化dijkstra，这个题就做完了。

分层最短路需要注意的问题:

#### 1、数组的大小，这个很重要。
#### 2、确定每层之间的权值是多少。
#### 3、考虑如何建边。

注意了这三个问题之后，分层最短路就跟裸的最短路没什么区别了……

于是我们开开心心的来看代码(代码就不解释了，有了思路就能看懂)：

```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cctype>
#include<cstring>
#define maxn 200001
using namespace std;
int num,n,m,head[800001],dis[800001];
inline int qread() {
  char c=getchar();int num=0,f=1; 
  for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
  for(;isdigit(c);c=getchar()) num=num*10+c-'0';return num*f;
} 
struct edge {
  int v,w,nxt;
}e[800001];
struct node {
  int x,y;
  bool operator < (const node &a) const {return y>a.y;}
};
struct Edge {
  int x,y,id;
}zrj[maxn];
bool cmp1(Edge a,Edge b){if(a.x==b.x)return a.y<b.y;return a.x<b.x;}
bool cmp2(Edge a,Edge b){if(a.y==b.y)return a.x<b.x;return a.y<b.y;}
inline void ct(int u, int v, int w) {
  e[++num].v=v;
  e[num].w=w;
  e[num].nxt=head[u];
  head[u]=num;
}
priority_queue<node>q;
inline void dijkstra() {
  memset(dis,0x3f,sizeof(dis)); 
  dis[m+1]=0;q.push((node){m+1,0});
  while(!q.empty()) {
  	int u=q.top().x,d=q.top().y;
  	q.pop();
  	if(d!=dis[u]) continue;
  	for(int i=head[u];i;i=e[i].nxt) {
  	  int v=e[i].v;
	  if(dis[v]>dis[u]+e[i].w) {
	  	dis[v]=dis[u]+e[i].w;
	  	q.push((node){v,dis[v]});
	  }	
	}
  }
}
int main() {
  n=qread(),m=qread();
  for(int i=1;i<=m+2;++i) zrj[i].x=qread(),zrj[i].y=qread(),zrj[i].id=i;
  sort(zrj+1,zrj+m+3,cmp1);
  for(int i=1;i<m+2;++i)
  {if(zrj[i].x==zrj[i+1].x) ct(zrj[i].id,zrj[i+1].id,(zrj[i+1].y-zrj[i].y)*2),ct(zrj[i+1].id,zrj[i].id,(zrj[i+1].y-zrj[i].y)*2);}
  sort(zrj+1,zrj+m+3,cmp2);
  for(int i=1;i<m+2;++i) 
  {if(zrj[i].y==zrj[i+1].y) ct(zrj[i].id+m+2,zrj[i+1].id+m+2,(zrj[i+1].x-zrj[i].x)*2),ct(zrj[i+1].id+m+2,zrj[i].id+m+2,(zrj[i+1].x-zrj[i].x)*2);}
  for(int i=1;i<=m;++i) ct(i,i+m+2,1),ct(i+m+2,i,1); 
  ct(m+1,m*2+3,0),ct(m*2+3,m+1,0);ct(m+2,m*2+4,0),ct(m*2+4,m+2,0);
  dijkstra();
  if(dis[m+2]>1e9) printf("-1\n");
  else printf("%d\n",dis[m+2]);
  return 0;
}
```

希望这篇题解可以对大家了解分层最短路有些帮助。

---

## 作者：_Life_ (赞：4)

### 题意
有一 $n$ 纵 $n$ 横的地铁网，共 $n^2$ 个车站，其中有 $m$ 个换乘站，换乘指横向、纵向线路互换。

地铁运行一站需要 $2$ 分钟，站内换乘需要 $1$ 分钟。

### 题解
**分层图上最短路**

考虑把地铁网拆成纵、横两层，然后你就会惊奇地发现这题做完了。

把起点、终点都当换乘站处理，$m\leftarrow m+2$ ，第 $i$ 个点被拆成第 $i$ 和 $i+m$ 个点

两层图上的换乘站连一条边权为 $1$ 的边，横层上同一行的相邻换乘站连一条边权为 $|y_{i}-y_{i+1}|\times 2$ 的边，纵层上同一列的相邻换乘站连一条边权为 $|x_{i}-x_{i+1}|\times 2$ 的边。

然后以 $m-1,m\times 2 -1$ 为起点，以 $m,m\times 2$ 为终点跑最短路，记得 $ans=\min(dis_m,dis_{m\times 2})$ 和判无解情况。

注意连边的时候要先排序，时间复杂度 $O(m\log m)$

### 代码
**以下代码包含大量压行、C++11语法，请谨慎食用**
```cpp
#include<queue>
#include<cstdio>
#include<vector>
#include<cstring>
#include<algorithm>
using namespace std;
struct dot{int x,y,num;}dots[100005];
struct edge{int v,w;};
struct node{int u,dis;bool operator <(node x)const{return dis>x.dis;}};
int n,m,x1,y1,x2,y2,dis[200005],vis[200005];
vector <edge> g[200005];
priority_queue <node> q;
void add(int u,int v,int w){g[u].push_back((edge){v,w}),g[v].push_back((edge){u,w});}
int main()
{
	scanf("%d %d",&n,&m),m+=2;
	for(int i=1;i<=m;i++)scanf("%d %d",&dots[i].x,&dots[i].y),dots[i].num=i;
	for(int i=1;i<=m;i++)add(i,i+m,1);
	sort(dots+1,dots+1+m,[](dot a,dot b){return a.x==b.x?a.y<b.y:a.x<b.x;});
	for(int i=1;i<m;i++)if(dots[i].x==dots[i+1].x)add(dots[i].num,dots[i+1].num,(dots[i+1].y-dots[i].y)*2);
	sort(dots+1,dots+1+m,[](dot a,dot b){return a.y==b.y?a.x<b.x:a.y<b.y;});
	for(int i=1;i<m;i++)if(dots[i].y==dots[i+1].y)add(dots[i].num+m,dots[i+1].num+m,(dots[i+1].x-dots[i].x)*2);
	//Dijkstra
	memset(dis,0x3f,sizeof(dis));
	dis[m-1]=dis[m+m-1]=0;
	q.push((node){m-1,0});
	q.push((node){m+m-1,0});
	while(!q.empty())
	{
		int u=q.top().u;q.pop();
		if(vis[u])continue;
		vis[u]=1;
		for(edge i:g[u])
		{
			int v=i.v,w=i.w;
			if(dis[v]>dis[u]+w)
			{
				dis[v]=dis[u]+w;
				if(!vis[v])
					q.push((node){v,dis[v]});
			}
		}
	}
	int ans=min(dis[m],dis[m+m]);
	printf("%d",ans==0x3f3f3f3f?-1:ans);
}

```

---

## 作者：WanderingTrader (赞：3)

这题说穿了只是一个单源多汇正权图最短路（dij在向你招手！），但是建图非常麻烦。
### 题目分析
一共 $n^2$ 个站点，比较重要的其实只有 $m+2$ 个，分别是 $m$ 个换乘站和起点终点。  

由题意可得，坐地铁时每转一个 $90\degree$ 角，就要进行一次站内换乘（当然不能换成的除外），为了方便，我们将这 $m+2$ 个结点拆成 $2m+4$ 个，其中前 $m+2$ 个表示横向的结点，后 $m+2$ 个表示纵向的结点。  

接下来就要连边了。首先我们把这 $m+2$ (注意了不是2倍)个结点按 $x$ 排序。然后如果 $x_i=x_{i+1}$，那就连一条双向边，边长为 $2(y_{i+1}-y_i)$。（即不需要换乘就可以到达）  

同理，接下来再按 $y$ 排序，如果 $y_i=y_{i+1}$，那就连一条双向边，边长为 $2(x_{i+1}-x_i)$，但此时连接的两个结点编号分别要加上 $m+2$ （否则的话换乘站就没有意义了）

然后把每个可换成的结点向自己（另一个方向上的自己）连一条长度为 $1$ 的双向边，完成“换乘”操作。

那么此时我们发现，起点站就有两个了，编号分别是 $m+1$ 和 $2m+3$，终点站也有两个了，分别是 $m+2$ 和 $2\times m+4$。为了接下来的操作方便，我们令 $S=0,T=2m+5$，然后将 $S$ 与 $m+1,2m+3$ 分别连接长度为 $0$ 的双向边，$T$ 与 $m+2,2m+4$ 也分别连接长度为 $0$ 的双向边。

思路就是这些。如果你还没有理解，不妨看看代码吧。
### 代码
初始化的部分大概是这样：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxm=1e5+9;
const int inf=2e9;
struct station{int x,y;}p[maxm];
struct node
{
	int u,c;
	bool operator < (const node& a) const {return c>a.c;}
};
vector <int> to[maxm<<1],w[maxm<<1];
bool ok[maxm<<1];
int n,m,nNode,S,T,d[maxm<<1],id[maxm];
inline int read()
{
 	int x=0,f=1;
 	char c=getchar();
 	while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}
 	while(isdigit(c)){x=(x<<1)+(x<<3)+c-'0';c=getchar();}
 	return x*f;
}
int main()
{
	n=read(),m=read();
	for(int i=1;i<=m;++i){p[i].x=read();p[i].y=read();}
	p[m+1].x=read();p[m+1].y=read();
	p[m+2].x=read();p[m+2].y=read();
	return 0;
}
```
我们用一个结构体station来存放结点的 $x,y$ 值。to,w这两个vector,结构体node,inf,d数组,ok数组都是dij模板里的含义，S和T即为源点和汇点。id数组用于做结点的排序。nNode则存放最终的结点个数，这里取了 $2m+6$。

然后我们写一个build函数来完成上面所提到的大量的建图任务。
```cpp
void build()
{
}
```
首先初始化id数组，即id[i]=i：
```cpp
	for(int i=1;i<=m+2;++i) id[i]=i;
```
接着按 $x$ 排序，这里把 “按 $x$ 排序”，“按 $y$ 排序”所需的函数一并给出：
```cpp
bool cmpX(const int& a,const int& b)
{
	return p[a].x<p[b].x||p[a].x==p[b].x&&p[a].y<p[b].y;
}
bool cmpY(const int&a,const int&b)
{
	return p[a].y<p[b].y||p[a].y==p[b].y&&p[a].x<p[b].x;
}
```
注意“如果相等就二次判断”是一个非常重要的过程，不可遗漏。

那么按 $x$ 排序即为：
```cpp
	sort(id+1,id+m+3,cmpX);
```
注意此时id的长度是 $m+2$ 不是 $m$ 了。

然后遍历整个id数组，将 $x$ 值相同的两点连边。

先给连边函数：
```cpp
void add(int a,int b,int c)
{
	to[a].push_back(b);w[a].push_back(c);
	to[b].push_back(a);w[b].push_back(c);
}
```
那么
```cpp
	for(int i=1;i<=m+1;++i) if(p[id[i+1]].x==p[id[i]].x)
		add(id[i],id[i+1],p[id[i+1]].y-p[id[i]].y<<1);
```

同理，现在我们按 $y$ 排序，然后连边：
```cpp
	sort(id+1,id+m+3,cmpY);
	for(int i=1;i<=m+1;++i) if(p[id[i+1]].y==p[id[i]].y)
		add(id[i]+m+2,id[i+1]+m+2,p[id[i+1]].x-p[id[i]].x<<1);
```
在此之后，我们要把站内换乘的边连上：
```cpp
	for(int i=1;i<=m;++i)
		add(i,i+m+2,1);
```
最后处理一下S,T和nNode。
```cpp
	S=0;
	T=2*m+5;
	add(S,m+1,0);add(S,2*m+3,0);
	add(m+2,T,0);add(2*m+4,T,0);
	nNode=2*m+6;
````
接着我们直接跑dij即可，主函数代码如下：
```cpp
int main()
{
	n=read(),m=read();
	for(int i=1;i<=m;++i){p[i].x=read();p[i].y=read();}
	p[m+1].x=read();p[m+1].y=read();
	p[m+2].x=read();p[m+2].y=read();
	build();
	printf("%d\n",dijkstra());
	return 0;
}
```
全部代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxm=1e5+9;
const int inf=2e9;
struct station{int x,y;}p[maxm];
struct node
{
	int u,c;
	bool operator < (const node& a) const {return c>a.c;}
};
vector <int> to[maxm<<1],w[maxm<<1];
bool ok[maxm<<1];
int n,m,nNode,S,T,d[maxm<<1],id[maxm];
void add(int a,int b,int c)
{
	to[a].push_back(b);w[a].push_back(c);
	to[b].push_back(a);w[b].push_back(c);
}
bool cmpX(const int& a,const int& b)
{
	return p[a].x<p[b].x||p[a].x==p[b].x&&p[a].y<p[b].y;
}
bool cmpY(const int&a,const int&b)
{
	return p[a].y<p[b].y||p[a].y==p[b].y&&p[a].x<p[b].x;
}
void build()
{
	for(int i=1;i<=m+2;++i) id[i]=i;
	sort(id+1,id+m+3,cmpX);
	for(int i=1;i<=m+1;++i) if(p[id[i+1]].x==p[id[i]].x)
		add(id[i],id[i+1],p[id[i+1]].y-p[id[i]].y<<1);
	sort(id+1,id+m+3,cmpY);
	for(int i=1;i<=m+1;++i) if(p[id[i+1]].y==p[id[i]].y)
		add(id[i]+m+2,id[i+1]+m+2,p[id[i+1]].x-p[id[i]].x<<1);
	for(int i=1;i<=m;++i)
		add(i,i+m+2,1);
	S=0;
	T=2*m+5;
	add(S,m+1,0);add(S,2*m+3,0);
	add(m+2,T,0);add(2*m+4,T,0);
	nNode=2*m+6;
}
int dijkstra()
{
	fill(d,d+nNode+1,inf);
	priority_queue <node> Q;
	d[S]=0;
	Q.push((node){S,0});
	while(!Q.empty())
	{
		int u=Q.top().u;Q.pop();
		if(u==T) return d[T];
		if(ok[u]) continue;
		ok[u]=true;
		for(int i=0;i<to[u].size();++i)
		{
			int v=to[u][i];
			int cost=d[u]+w[u][i];
			if(d[v]<=cost) continue;
			d[v]=cost;
			Q.push((node){v,d[v]});
		}
	}
	return -1;
}
inline int read()
{
 	int x=0,f=1;
 	char c=getchar();
 	while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}
 	while(isdigit(c)){x=(x<<1)+(x<<3)+c-'0';c=getchar();}
 	return x*f;
}
int main()
{
	n=read(),m=read();
	for(int i=1;i<=m;++i){p[i].x=read();p[i].y=read();}
	p[m+1].x=read();p[m+1].y=read();
	p[m+2].x=read();p[m+2].y=read();
	build();
	printf("%d\n",dijkstra());
	return 0;
}
```
$$\texttt{The End.}$$

---

## 作者：一只萌新 (赞：3)

[P3831 SHOI2012 回家的路](https://www.luogu.org/problemnew/show/P3831)

### 1.数组大小
一开始看到这个题，n≤20000,m≤100000，完了，存图肯定爆了

后来发现不用把每个网格里的点都存下来

我们只需要**把可以转弯的点存下来（包括起点和终点）**

~~（不然没法存啊）~~

具体开多大见程序

### 2.分层图最短路

对一个可换乘的站在网格中横向和纵向可以走

我们可以建两层图，一层表示纵向边，一层表示横向边

转向就代表从一层图到另一层（可看看楼下dalao的题解）

然后跑一遍最短路就好

### 3.起点和终点

我们在输入可换乘的站时顺便输入了起点和终点

按输入顺序记录每一个站点

所以**起点是m+1，终点是m+2**

~~（这个问题曾困扰蒟蒻许久）~~

### 4.注意：

**1.把上下两层的起点和终点连接**，起点和终点可以横向走也可以纵向走，连边后会取到最小值（在很多分层的题中都需要这样连）

**2.** 地铁运行 1 站需要 2 分钟，而站内换乘需要步行 1 分钟

**所以两个站之间的边权需要2**

**上下两层连线的边权为1**

**3.** 一个好习惯：用换行或函数**把代码分块**

便于检查，思路也更清晰


```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
#include<algorithm>
#include<cctype>
using namespace std;
inline int read(){
	char ch=getchar();int f=1,s=0;
	while(!isdigit(ch))){
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		s=s*10+ch-'0';
		ch=getchar();
	}
	return f*s;
}

const int M=100000*4*2+5,N=100000*2+5;//注意数据范围 N=maxm*2(有两层)，M=maxm*4*2(每个点最多4个方向,无向边) 
int n,m,s,t;
struct Edge{	//存图 
    int v,w,next;
}e[M];
int head[M],cnt;
inline void add_edge(int u,int v,int w){
    e[++cnt].next=head[u],e[cnt].v=v,e[cnt].w=w,head[u]=cnt;
    return;
}

struct zb{	//建边所用的结构体和排序的函数 
	int x,y;
	int id;//保存编号，sort 
}khc[N];
bool cmpx(zb a,zb b){
	if(a.x==b.x) return a.y<b.y;
	return a.x<b.x;
}
bool cmpy(zb a,zb b){
	if(a.y==b.y) return a.x<b.x;
	return a.y<b.y;
}

struct node{	//dijstra最短路 
	int id,dis;
	node(){};
	node(int id,int dis):id(id),dis(dis){};
	bool operator < (const node &a)const{
		return dis>a.dis;
	}
};
int dis[N];
bool vis[N];
priority_queue<node> q;
void dij(){
	memset(dis,0x3f,sizeof(dis));
	q.push(node(s,0));dis[s]=0;
	while(!q.empty()){
		int u=q.top().id;q.pop();
		if(vis[u]) continue;
		vis[u]=1;
		for(register int i=head[u];i;i=e[i].next){
			int v=e[i].v;
			if(dis[v]>dis[u]+e[i].w){
				dis[v]=dis[u]+e[i].w;
				q.push(node(v,dis[v]));
			}
		}
	}
	return;
}

int main(){
	n=read();m=read();s=m+1,t=m+2；	//读入 
	for(register int i=1;i<=m+2;i++){
		khc[i].id=i;
		khc[i].x=read();khc[i].y=read();	//记下可换乘的点(起点,终点也算) 
	}
	
	sort(khc+1,khc+m+3,cmpx);	//横的边(第一层)
	for(register int i=1;i<m+2;i++){
		zb u=khc[i],v=khc[i+1];
		if(u.x==v.x) add_edge(u.id,v.id,2*(v.y-u.y)),add_edge(v.id,u.id,2*(v.y-u.y)); 
	}
	sort(khc+1,khc+m+3,cmpy);	//竖的边(第二层)
	for(register int i=1;i<m+2;i++){
		zb u=khc[i],v=khc[i+1];
		if(u.y==v.y) add_edge(u.id+m+2,v.id+m+2,2*(v.x-u.x)),add_edge(v.id+m+2,u.id+m+2,2*(v.x-u.x));
	}
	for(register int i=1;i<=m;i++){	//连接两层 
		add_edge(i,i+m+2,1),add_edge(i+m+2,i,1);
	}
	add_edge(m+1,m+1+m+2,0),add_edge(m+1+m+2,m+1,0);//把上下的起点终点连起来 
	add_edge(m+2,m+2+m+2,0),add_edge(m+2+m+2,m+2,0);
	
	dij();
	if(dis[t]>1e9) printf("-1\n");
	else printf("%d\n",dis[t]);
	return 0;
}
/*
分层图 
在一个正常的图上可以进行k次决策，对于每次决策，不影响图的结构，只影响目前的状态或代价。
*/

```
结束~

---

## 作者：warzone (赞：2)

一个 `std::vector` 就可以解决的事情，为什么要用分层图最短路呀QWQ？  

整个矩阵很大，换乘站却相对很稀疏，因此除了起点和终点，
考虑换乘站之间的跳转就可以了。  
因此，首先考虑换乘站之间的跳转：先用 `std::vector` 将同行，同列的跳转站记录下来，  
之后 Dijkstra 在上面跳转就可以了。 

记录的代码
```cpp
typedef unsigned int word;
word x[100010],y[100010];
vector<word> line[20010],column[20010];
...
cin>>n>>m;
for(register word i=1;i<=m;++i){
	cin>>x[i]>>y[i];
	line[x[i]].push_back(i);
	column[y[i]].push_back(i);
}
```
Dijkstra 的代码
```cpp
struct pair{
	word id,value;
	inline bool operator <(register pair p){
		if(value==p.value) return id<p.id;
		return value<p.value;
	}
};
HEAP<pair> heap;//手写堆
word dis[100010];
...
#define abs(a,b) (((a)>(b)? (a)-(b):(b)-(a))<<1)
#define getnext(x,y,line)												\
	for(register word i=0;i<line[x[p.id]].size();++i){					\
		q.id=line[x[p.id]][i],q.value=p.value+1+abs(y[p.id],y[q.id]);	\
		if(dis[q.id]>q.value) dis[q.id]=q.value,heap.push(q);			\
	}
while(heap.size){
	register pair p=heap.top();
    heap.pop();
    if(dis[p.id]<p.value) continue;
    getnext(x,y,line);//行与列的更新相似
    getnext(y,x,column);
}
```
但显然，这个做法会 TLE，因为对于每个点要将同行，同列的点全部更新一遍，总体最坏是 $\Theta(mn)$ 的。  
（然而你谷数据卡不掉）  
但我们观察一下更新的迭代式：$dis_v=\min_{x_u=x_v}dis_u+1+2|y_u-y_v|$  
若将 $v$ 作为自变量，可以发现 $2|y_u-y_v|$ 的斜率是固定的。  
因此有一个剪枝大优化：先排序并记录各个中转点在所在行/列的次序，然后更新时往两端扫。  
如果 $dis_v\ge dis_u+1+2|y_u-y_v|$，那么之后的点都不用更新了，直接退出。

排序与记录次序的代码
```cpp
word xrot[100010],yrot[100010];
inline bool cmpx(register word id1,register word id2){
	return x[id1]<x[id2];}
inline bool cmpy(register word id1,register word id2){
	return y[id1]<y[id2];}
...
for(register word i=1;i<=n;++i){
	std::sort(line[i].begin(),line[i].end(),cmpy);
	std::sort(column[i].begin(),column[i].end(),cmpx);
    for(register word j=0;j<line[i].size();++j)
	xrot[line[i][j]]=j;
	for(register word j=0;j<column[i].size();++j)
	yrot[column[i][j]]=j;
}
```
新的 `getnext(x,y,line)`
```cpp
#define getnext(x,y,line)												\
	for(register word i=x##rot[p.id]+1;i<line[x[p.id]].size();++i){		\
		q.id=line[x[p.id]][i],q.value=p.value+1+((y[q.id]-y[p.id])<<1);	\
		if(dis[q.id]>q.value) dis[q.id]=q.value,heap.push(q);			\
		else break;														\
	}																	\
	for(register int i=x##rot[p.id]-1;i>=0;--i){						\
		q.id=line[x[p.id]][i],q.value=p.value+1+((y[p.id]-y[q.id])<<1);	\
		if(dis[q.id]>q.value) dis[q.id]=q.value,heap.push(q);			\
		else break;														\
	}
```
就此，只剩下起点和终点没有考虑，有三种情况：
- 起点$\quad\rightarrow$ 换乘站$\qquad$ 不用换乘
- 起点$\quad\rightarrow$ 终点$\qquad\ \ \ \ $ 不用换乘
- 换乘站 $\ \rightarrow$ 终点$\qquad\ \ \ $ 不用换乘

直接更新就可以了，此处不用写剪枝。

时间复杂度：  
- 初始化时的排序是 $\Theta(n+m\log n)$ 的。  
- 处理起点和终点是 $\Theta(n)$ 的。
- Dijkstra 是 $\Theta(m\log m)$ 的（更新可近似看作 $\Theta(1)$）

因此最终的时间复杂度为 $\Theta(n+m(\log m+\log n))$，可近似看作 $\Theta(m\log m)$

最终代码 (O2,118ms,6.60MB) ~~跑得飞快就是了~~
```cpp
#include<stdio.h>
#include<string.h>
#include<vector>
#include<algorithm>
typedef unsigned long long ull;
typedef unsigned int word;
template<typename type>
struct HEAP{//手写堆
	type list[1<<18];
	word size;
	inline HEAP(){size=0;}
#define swap(a,b)(								\
	list[0]=list[a],							\
	list[a]=list[b],							\
	list[b]=list[0])
	inline void push(type in){
		list[++size]=in;
		for(register word i=size;i>1&&list[i]<list[i>>1];i>>=1)
			swap(i,i>>1);
	}
	inline void pop(){
		list[1]=list[size--];
		for(register word i=1;i<<1<=size;swap(i,i>>1))
			if(list[i<<1]<list[i])
				if(i<<1<size&&list[i<<1|1]<list[i<<1]) i=i<<1|1;
				else i<<=1;
			else if(i<<1<size&&list[i<<1|1]<list[i]) i=i<<1|1;
			else return;
	}
	inline type& top(){return list[1];}
};
struct pair{
	word id,value;
	inline bool operator <(register pair p){
		if(value==p.value) return id<p.id;
		return value<p.value;
	}
};
HEAP<pair> heap;
struct READ{//快读
	char *top;
	inline READ(){fread(top=(char*)heap.list,1<<21,1,stdin);}
	template<typename type>
	inline READ& operator >>(register type& num){
		while('0'>*top||*top>'9') ++top;
		for(num=0;'0'<=*top&&*top<='9';)
			num=num*10+(*(top++)-'0');
		return *this;
	}
};
using std::vector;
using std::lower_bound;
vector<word> line[20010],column[20010];
word x[100010],y[100010],xrot[100010],yrot[100010];
word dis[100010];
inline bool cmpx(register word id1,register word id2){
	return x[id1]<x[id2];}
inline bool cmpy(register word id1,register word id2){
	return y[id1]<y[id2];}
#define getnext(x,y,line)												\
	for(register word i=x##rot[p.id]+1;i<line[x[p.id]].size();++i){		\
		q.id=line[x[p.id]][i],q.value=p.value+1+((y[q.id]-y[p.id])<<1);	\
		if(dis[q.id]>q.value) dis[q.id]=q.value,heap.push(q);			\
		else break;														\
	}																	\
	for(register int i=x##rot[p.id]-1;i>=0;--i){						\
		q.id=line[x[p.id]][i],q.value=p.value+1+((y[p.id]-y[q.id])<<1);	\
		if(dis[q.id]>q.value) dis[q.id]=q.value,heap.push(q);			\
		else break;														\
	}//更新（包含剪枝优化）
int main(){
	register READ cin;
	register word n,m;
	cin>>n>>m;
	for(register word i=1;i<=m;++i){
		cin>>x[i]>>y[i];
		line[x[i]].push_back(i);
		column[y[i]].push_back(i);
	}//将同行，同列的点放入同一个 vector
	for(register word i=1;i<=n;++i){
		std::sort(line[i].begin(),line[i].end(),cmpy);
		std::sort(column[i].begin(),column[i].end(),cmpx);
		for(register word j=0;j<line[i].size();++j)
			xrot[line[i][j]]=j;
		for(register word j=0;j<column[i].size();++j)
			yrot[column[i][j]]=j;
	}//排序并记录相对次序
	word beginx,beginy,endx,endy;
	cin>>beginx>>beginy>>endx>>endy;
	memset(dis,0x7f,sizeof(dis));
#define abs(a,b) (((a)>(b)? (a)-(b):(b)-(a))<<1)
	register pair p,q;
	for(register word i=0;i<line[beginx].size();++i){
		q.id=line[beginx][i],q.value=abs(y[q.id],beginy);
		if(dis[q.id]>q.value) dis[q.id]=q.value,heap.push(q);
	}
	for(register word i=0;i<column[beginy].size();++i){
		q.id=column[beginy][i],q.value=abs(x[q.id],beginx);
		if(dis[q.id]>q.value) dis[q.id]=q.value,heap.push(q);
	}//处理起点
	while(heap.size){
		p=heap.top(),heap.pop();
		if(dis[p.id]<p.value) continue;
		getnext(x,y,line);
		getnext(y,x,column);//行与列是类似的
	}
	register word ans=0x7f7f7f7f;
	if(beginx==endx) ans=abs(beginy,endy);
	if(beginy==endy) ans=abs(beginx,endx);
	for(register word i=0;i<line[endx].size();++i){
		q.id=line[endx][i],q.value=dis[q.id];
		if(y[q.id]!=endy) q.value+=1+abs(y[q.id],endy);
		if(ans>q.value) ans=q.value;
	}
	for(register word i=0;i<column[endy].size();++i){
		q.id=column[endy][i],q.value=dis[q.id];
		if(x[q.id]!=endx) q.value+=1+abs(x[q.id],endx);
		if(ans>q.value) ans=q.value;
	}//处理终点的情况
	if(ans==0x7f7f7f7f) printf("-1");
	else printf("%u",ans);
	return 0;
}
```

---

## 作者：Nero_Claudius (赞：2)

建图的都是邪教吧。。。

---

本题可以把起点和终点都看为中转站，那么显然我们只能在中转站之间移动。

显然，同一行或同一列的中转站没有必要来回走动，中转站的唯一作用就是换乘。

换言之，对于每一个中转站，我们只需要考虑它换乘时的作用即可。

那么对于每两个同行同列的中转站，之间连一条长度为距离*2+1的边，然后跑最短路就可以了。

注意由于终点在事实上不起换乘作用，所以最后的答案要减一。

当然，本题要是真的建边空间就会稍有恶臭，所以直接在dijkstra转移的时候按行列寻找即可。

（据说本题卡spfa，可是目前为止我也没看到被卡的）

------

```cpp
#include <bits/stdc++.h>

using namespace std;

namespace StandardIO {

	template<typename T> inline void read (T &x) {
		x=0;T f=1;char c=getchar();
		for (; c<'0'||c>'9'; c=getchar()) if (c=='-') f=-1;
		for (; c>='0'&&c<='9'; c=getchar()) x=x*10+c-'0';
		x*=f;
	}
	template<typename T> inline void write (T x) {
		if (x<0) putchar('-'),x=-x;
		if (x>=10) write(x/10);
		putchar(x%10+'0');
	}

}

using namespace StandardIO;

namespace Solve {
	
	const int N=20020;
	const int INF=2147483647;
	
	int n,m;
	struct node {
		int x,y;
	} mp[100100],s,t;
	int d[100100],v[100100];
	vector<int> x[N],y[N];
	
	inline void dijkstra () {
		for (register int i=1; i<=m+2; ++i) {
			d[i]=INF,v[i]=0;
		}
		priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > q;
		d[m+1]=0;
		q.push(make_pair(d[m+1],m+1));
		while (!q.empty()) {
			int now=q.top().second;q.pop();
			for (register int i=0; i<x[mp[now].x].size(); ++i) {
				if (x[mp[now].x][i]==now) continue;
				if (d[x[mp[now].x][i]]>d[now]+2*abs(mp[now].y-mp[x[mp[now].x][i]].y)+1) {
					d[x[mp[now].x][i]]=d[now]+2*abs(mp[now].y-mp[x[mp[now].x][i]].y)+1;
					q.push(make_pair(d[x[mp[now].x][i]],x[mp[now].x][i]));
				} 
			}
			for (register int i=0; i<y[mp[now].y].size(); ++i) {
				if (y[mp[now].y][i]==now) continue;
				if (d[y[mp[now].y][i]]>d[now]+2*abs(mp[now].x-mp[y[mp[now].y][i]].x)+1) {
					d[y[mp[now].y][i]]=d[now]+2*abs(mp[now].x-mp[y[mp[now].y][i]].x)+1;
					q.push(make_pair(d[y[mp[now].y][i]],y[mp[now].y][i]));
				} 
			}
		}
	}

	inline void Main () {
		read(n),read(m);
		for (register int i=1; i<=m+2; ++i) {
			read(mp[i].x),read(mp[i].y); 
			x[mp[i].x].push_back(i),y[mp[i].y].push_back(i);
		}
		dijkstra();
		write(d[m+2]-1);
	}

}

int main () {
	Solve::Main();
}
```

---

## 作者：arfa (赞：2)

将每一个点 $v$ 拆成出入点 $id_{v,1}$ 和 $id{v,2}$ 即可,这样就可以完成转向的操作。

随后考虑排序将点连边。

排序注意关键字问题。

```pascal
// T3

Uses math;

Const 
    total=210000;

var
    from,next,value,reach:array[-1..total*8] of longint;
    heap,node:array[-1..total*20] of longint;
    dis,cnt:array[-1..total*3] of longint;
    id:array[-1..total*3,1..2] of longint;
    ask:array[-1..total*3] of boolean;
    x,y:array[-1..total*3] of longint;
    i,n,m,num,tot,tail,sink,source,number:longint;

procedure Swap(var a,b:longint);var t:longint; begin t:=a; a:=b; b:=t; end;

procedure Add(l,r,sum:longint);
begin
    inc(tot); from[tot]:=l; reach[tot]:=r; value[tot]:=sum; next[tot]:=cnt[l]; cnt[l]:=tot;
    inc(tot); from[tot]:=r; reach[tot]:=l; value[tot]:=sum; next[tot]:=cnt[r]; cnt[r]:=tot;
end;

procedure Insert(x:longint);
var father:longint;
begin
    if x=1 then exit; father:=x >> 1;
    if heap[father]>heap[x] then begin swap(heap[x],heap[father]); swap(node[x],node[father]); Insert(father);  end;
end;

procedure Down(x:longint);
var son:longint;
begin
    if x << 1>num then exit; son:=x << 1;
    if (son+1<=num)and(heap[son+1]<=heap[son]) then inc(son);
    if heap[x]>heap[son] then begin swap(heap[x],heap[son]); swap(node[x],node[son]); end;
    Down(son);
end;

procedure Sort(l,r:longint);
var i,j,mid1,mid2:longint;
begin
    i:=l; j:=r; mid1:=x[(l+r) >> 1]; mid2:=y[(l+r) >> 1];
    repeat
        while (x[i]<mid1)or((x[i]=mid1)and(y[i]<mid2)) do inc(i);
        while (x[j]>mid1)or((x[j]=mid1)and(y[j]>mid2)) do dec(j);
        if i<=j then begin Swap(x[i],x[j]); Swap(y[i],y[j]); Swap(id[i,1],id[j,1]); Swap(id[i,2],id[j,2]); inc(i); dec(j); end;
    until i>=j;
    if i<r then Sort(i,r);
    if j>l then Sort(l,j);
end;

procedure Dijkstra;
var i,key,rope:longint;
begin
    rope:=0; inc(num); heap[num]:=0; node[num]:=source; Insert(num); 
    repeat
        if num=0 then break;
        key:=node[1]; heap[1]:=heap[num]; node[1]:=node[num]; dec(num); Down(1); 
        if ask[key]=False then
        begin
            inc(rope); ask[key]:=True; i:=cnt[key];
            while i<>-1 do
            begin
                if (dis[reach[i]]>value[i]+dis[key]) then
                begin
                    dis[reach[i]]:=value[i]+dis[key]; inc(num); 
                    heap[num]:=dis[reach[i]]; node[num]:=reach[i]; Insert(num);
                end; i:=next[i];
            end;
        end;
    until rope=(m+2) << 1;
    writeln(dis[sink]);
end;

begin
    filldword(cnt,sizeof(cnt) div 4,maxlongint*2+1);
    filldword(dis,sizeof(dis) div 4,maxlongint);
    read(n,m); number:=0; tail:=0;
    for i:=1 to m+3 do begin inc(number); id[i,1]:=number; inc(number); id[i,2]:=number; end;
    for i:=1 to m do begin inc(tail); read(x[tail],y[tail]); Add(id[tail,1],id[tail,2],1); end;
    inc(tail); read(x[tail],y[tail]); Add(id[tail,1],id[tail,2],0); source:=id[tail,1];
    inc(tail); read(x[tail],y[tail]); Add(id[tail,1],id[tail,2],0); sink:=id[tail,2]; 
    Sort(1,tail);
    for i:=2 to tail do if (x[i-1]=x[i]) then Add(id[i-1,1],id[i,1],abs(y[i]-y[i-1]) << 1);
    for i:=1 to tail do Swap(x[i],y[i]); Sort(1,tail);
    for i:=2 to tail do if (x[i-1]=x[i]) then Add(id[i-1,2],id[i,2],abs(y[i]-y[i-1]) << 1);
    dis[source]:=0; Dijkstra;
end.
```

---

## 作者：wuzhoupei (赞：2)

![Peipei](http://img.blog.csdn.net/20180120093509502?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJldGVuZF9mYWw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)  
还是我的**logo** ^_^

-----

这个题乍一看像个网络流  
然而不是  
然后就发现特别像最短路的题  

把每一行的点互相连边，每一列同理  
每次转移时判断当前点是不是转折点，一次判断是否+1  

但是有一点让这道题不像最短路： 
### 如果一条线上全是转折点，那岂不是边的条数要达到  
# n^2 !!!  

但是我们发现有些边是没必要建的，比如 A -> B -> C  
那么我们就没必要建一条 A -> C 的边了  
所以我们把相邻的建边，spfa 飞过就好了  

但是有个小细节，就像 A -> B -> C 中 B 不能算作转折点  
在 B 处不 +1  
至于如何判断当前点是否为转折点  
我们记录当前点的 fa[x]  
判断 如果 fa[x] 与 go(即将转移的点) 不共线， 那么 x 就是一个转折点  

--------------

```cpp
#include <bits/stdc++.h>
#define II int
#define IL inline
#define R register
#define I 423546
using namespace std;

IL void of(R II &a) {
	R char c=getchar (); R II w=1, p=0;
	while (c<'0' || c>'9') { if(c=='-') w=-1; c=getchar (); }
	while (c>='0' && c<='9') { p=p*10+c-'0'; c=getchar (); }
	a=w*p;
}

/* -------------------- Peipei -------------------- */

II n,m,_tot;
II head[I], dis[I], inq[I], fa[I];
queue <II> Q;

struct oAo { II x,y,wei; } edge[I];
IL bool maPx(oAo a1,oAo a2) { return a1.x==a2.x ? a1.y<a2.y : a1.x<a2.x ;}
IL bool maPy(oAo a1,oAo a2) { return a1.y==a2.y ? a1.x<a2.x : a1.y<a2.y ;}
IL bool maPwei(oAo a1,oAo a2) { return a1.wei<a2.wei ;}

struct owo { II to,up,w; } aa[I];
IL void add(R II x,R II y,R II z) {
	aa[++_tot]=(owo) {y,head[x],z};
	head[x]=_tot;
}

IL void spfa() {
	for(R II i=1;i<=m+1;i++) dis[i]=1e9;
	Q.push(0); inq[0]=1; dis[0]=0;
	while (!Q.empty()) {
		R II x=Q.front(); Q.pop(); inq[x]=0;
		for(R II i=head[x],go,K;i;i=aa[i].up)
		{
			go=aa[i].to; 
			K=(edge[fa[x]].x!=edge[go].x && edge[fa[x]].y!=edge[go].y);
			if(dis[go]>dis[x]+aa[i].w+K) {
				dis[go]=dis[x]+aa[i].w+K;
				if(!inq[go]) Q.push(go), inq[go]=1;
				fa[go]=x;
			}
		}
	}
	printf("%d\n",dis[m+1]);
	exit(0);
}

int main()
{
	of(n); of(m);
	for(R II i=1;i<=m;i++) 
		of(edge[i].x), of(edge[i].y), edge[i].wei=i;
	of(edge[0].x); of(edge[0].y);
	of(edge[m+1].x); of(edge[m+1].y); 
	edge[m+1].wei=m+1;
	
	sort(edge,edge+m+2,maPx);
	for(R II i=0;i<=m;i++) 
		if(edge[i].x==edge[i+1].x) {
			add(edge[i].wei,edge[i+1].wei,abs(edge[i].y-edge[i+1].y)*2);
			add(edge[i+1].wei,edge[i].wei,abs(edge[i].y-edge[i+1].y)*2);
		}
	sort(edge,edge+m+2,maPy);
	for(R II i=0;i<=m;i++) 
		if(edge[i].y==edge[i+1].y) {
			add(edge[i].wei,edge[i+1].wei,abs(edge[i].x-edge[i+1].x)*2);
			add(edge[i+1].wei,edge[i].wei,abs(edge[i].x-edge[i+1].x)*2);
		}
	sort(edge,edge+m+2,maPwei);
	
	spfa();
}
```
----------

---

## 作者：wfycsw (赞：1)

仔细审题，可知这是一个网格图，跑最短路时只能在给定的$m$个点转向。

因此，做题时需要**多次决策**，所以不难想到的的是**分层图**。

但本题的难点就在于**如何构建分层图**。

对于网络图，我们可以把图分成两层，其中第$1$层为横向走，第$2$层为纵向走。
解决了这个难点，便可以轻松的套上最短路模板了。

上代码！
```cpp
#include<bits/stdc++.h>
#define RI register int
#define du pair<int,int>
#define s second 
#define ru(x) q.push((du){-f[x],x})
#define ad(x,y,z) add(x,y,z),add(y,x,z);
using namespace std;
const int da=2147483647;
const int N=100007;
const int M=200007;
struct wu{
	int n,t,s;
}a[M<<2];
struct fn{
	int x,y,t;
}d[M]; 
int h[N<<1],f[N<<1],p;bool b[N<<1];
inline void add(int u,int v,int s){
	p=-~p;a[p].s=s;
	a[p].t=v;a[p].n=h[u];
	h[u]=p;
} 
inline bool cmp1(fn a,fn b){return a.x<b.x||a.x==b.x&&a.y<b.y;}
inline bool cmp2(fn a,fn b){return a.y<b.y||a.y==b.y&&a.x<b.x;}
int main(){
	priority_queue<du>q;	
	RI n,m,u,s,v,qd,zd;
	scanf("%d%d",&n,&m);
	qd=-~m;zd=-~qd;m+=2;
	for(RI i=1;i<=m;i=-~i){
		scanf("%d%d",&d[i].x,&d[i].y);
		d[i].t=i;
	}	
	sort(d+1,d+m+1,cmp1);
	for(RI i=1;i<m;i=-~i)
		if(d[i].x==d[-~i].x)
			ad(d[i].t,d[-~i].t,d[-~i].y-d[i].y<<1);
	sort(d+1,d+m+1,cmp2);
	for(RI i=1;i<m;i=-~i)
		if(d[i].y==d[-~i].y)
			ad(d[i].t+m,d[-~i].t+m,d[-~i].x-d[i].x<<1);
	for(RI i=1;i<m-1;i=-~i)
		ad(i,i+m,1);
	ad(m-1,(m<<1)-1,0);ad(m,m<<1,0);
	for(RI i=1;i<=(m<<1);i=-~i) f[i]=da;
	ru(qd);f[qd]=0;
	while(q.size()){//dijkstra
		u=q.top().s;q.pop();
		if(b[u]) continue;
		b[u]=1;
		for(RI i=h[u];i;i=a[i].n){
			v=a[i].t;s=a[i].s;
			if(f[v]>f[u]+s)
				f[v]=f[u]+s,ru(v);
		} 
	}
	if(f[zd]==da) printf("-1");
	else printf("%d",f[zd]);
	return 0;
}
```
### 后记
对于图论题而言，随着OI选手能力的普遍提升，题目会变得越来越复杂，**但是，只要读懂题目并且从未结果的题目转换成已知的题型，找到解题思路，便就成了一个套模板的问题了**。

---

## 作者：Lysus (赞：1)

这道题用人话来讲 就是一个网格图在横，纵方向上互相独立行走（单位步数2），转向要1的步数

理解完题意后不难得出这是一道分层图

#### 以横，纵边分别连一个图（长度为距离 * 2），同一个点横纵相连（长度为1）

#### 然后跑Dijkstra就行了

### 注意细节！（~~来自死在细节的蒟蒻~~）
1.一个点不能跨点去连横，纵向的点
```cpp
bool cmp_1(node b, node c) {return b.x == c.x ? b.y < c.y : b.x < c.x;}
bool cmp_2(node b, node c) {return b.y == c.y ? b.x < c.x : b.y < c.y;}
```
（一定不能把b.x == c.x这种情况落下）

2.起点和终点横，纵转换代价为0

上代码
```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
const int N = 300010;
const int inf = 1e9 + 7;

int n, m;
struct node {
	int x, y, id;
}a[N];
struct Edge {
	int to, nxt, val;
}edge[N << 2];
int head[N << 2], tot;
int vis[N << 2], dis[N << 2];
priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > q;

bool cmp_1(node b, node c) {return b.x == c.x ? b.y < c.y : b.x < c.x;}
bool cmp_2(node b, node c) {return b.y == c.y ? b.x < c.x : b.y < c.y;}
void add_edge(int x, int y, int z) {
	edge[++tot].to = y;
	edge[tot].val = z;
	edge[tot].nxt = head[x];
	head[x] = tot;
	
	edge[++tot].to = x;
	edge[tot].val = z;
	edge[tot].nxt = head[y];
	head[y] = tot;
}
void solve() {
	for(int i = 1; i <= 2 * m + 4; i ++ ) dis[i] = inf;
	dis[1] = dis[m + 3] = 0;
	q.push(make_pair(dis[1], 1)); q.push(make_pair(dis[m + 3], m + 3));
	while(!q.empty()) {
		pair<int, int> k = q.top();
		q.pop();
		int u = k.second;
		if(vis[u]) continue;
		vis[u] = 1;
		for(int i = head[u]; i; i = edge[i].nxt) {
			int v = edge[i].to;
			if(dis[v] > dis[u] + edge[i].val) {
				dis[v] = dis[u] + edge[i].val;
				if(!vis[v]) q.push(make_pair(dis[v], v));
			}
		}
	}
}
int main () {
	scanf("%d %d", &n, &m);
	for(int i = 2; i <= m + 1; i ++ ) scanf("%d %d", &a[i].x, &a[i].y), a[i].id = i; a[1].id = 1, a[m + 2].id = m + 2;
	scanf("%d %d %d %d", &a[1].x, &a[1].y, &a[m + 2].x, &a[m + 2].y);
	//for(int i = 1; i <= 2 * m + 4; i ++ ) a[i].id = i;
	sort(a + 1, a + 3 + m, cmp_1);
	for(int i = 1; i < m + 2; i ++ ) if(a[i].x == a[i + 1].x) add_edge(a[i].id, a[i + 1].id, 2 * abs(a[i].y - a[i + 1].y));
	sort(a + 1, a + 3 + m, cmp_2);
	for(int i = 1; i < m + 2; i ++ ) if(a[i].y == a[i + 1].y) add_edge(a[i].id + m + 2, a[i + 1].id + m + 2, 2 * abs(a[i].x - a[i + 1].x));
	for(int i = 2; i <= m + 1; i ++ ) add_edge(i, i + m + 2, 1);
   //1,m+3对应起点横，纵;m+2,m*2+4分别对应终点横，纵
	add_edge(1, m + 3, 0), add_edge(m + 2, m * 2 + 4, 0);
	solve();
	if(dis[m + 2] == inf) printf("-1\n");
	else printf("%d\n", dis[m + 2]);
	return 0;
}
```


---

## 作者：散华礼弥 (赞：1)

vector版的分层图?

用一个vector存每一横行上的中转站,另一个存纵行.

以前没学过分层图,不过机房大佬告诉我这就是分层图.

于是乎,就没建边的跑了最短路,代码丑哭.
```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <queue>
#include <vector>

const int MAXN = 100005;
int n, m, s, t, node_count, dis[MAXN], vis[MAXN];

struct Point
{
	int x, y;
} p[MAXN];
std::vector<int> Gx[20005], Gy[20005];

struct Node
{
    int id, dis;

    Node(int _id = 0, int _dis = 0)
        : id(_id), dis(_dis) {}

    bool operator<(const Node &A) const
    {
        return dis > A.dis;
    }
};
std::priority_queue<Node> Q;

int get_dis(int from, int to)
{
	int x = p[from].x, y = p[from].y, xx = p[to].x, yy = p[to].y;
	if (x == xx)
		return yy > y ? (yy - y) << 1 | 1 : (y - yy) << 1 | 1;
	return xx > x ? (xx - x) << 1 | 1 : (x - xx) << 1 | 1;
}

void Dijkstra()
{
	int _Siz, now, to, x, y;
	memset(dis, -1, sizeof dis);
	dis[s] = 0;
	Q.push(Node(s, 0));
	while (!Q.empty())
	{
		now = Q.top().id;
		Q.pop();
		if (vis[now])
			continue;
		vis[now] = 1;
		x = p[now].x, y = p[now].y;
		_Siz = Gx[x].size();
		for (int i = 0; i < _Siz; ++i)
		{
			to = Gx[x][i];
			if (dis[to] == -1 || get_dis(to, now) + dis[now] < dis[to])
			{
				dis[to] = get_dis(to, now) + dis[now];
				Q.push(Node(to, dis[to]));
			}
		}
		_Siz = Gy[y].size();
		for (int i = 0; i < _Siz; ++i)
		{
			to = Gy[y][i];
			if (dis[to] == -1 || get_dis(to, now) + dis[now] < dis[to])
			{
				dis[to] = get_dis(to, now) + dis[now];
				Q.push(Node(to, dis[to]));
			}
		}
	}
}

int main()
{
	int x, y, a, b;
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; ++i)
	{
		scanf("%d%d", &x, &y);
		p[++node_count] = (Point){x, y};
		Gx[x].push_back(node_count);
		Gy[y].push_back(node_count);
	}
	scanf("%d%d%d%d", &x, &y, &a, &b);
	p[++node_count] = (Point){x, y}, p[++node_count] = (Point){a, b};
	s = node_count - 1, t = node_count;
	Gx[x].push_back(s), Gx[a].push_back(t), Gy[y].push_back(s), Gy[b].push_back(t);
	Dijkstra();
	printf("%d\n", dis[t] - 1);
	return 0;
}
```


---

## 作者：Seanq (赞：1)

**P3831 [SHOI2012]回家的路**   
有人用dijkstra吗？   
估计没......   
思路就是分层图最短路  
f[pos][k]表示在第pos位且在第k层所用最短路   
初始化全部为-1(到不了)   
然后堆优化的dijkstra  
记住：没标记的点无卵用！  
就是这样！  
至于有一个点卡了我超级久：  
我是这样：  
```cpp
while(!q.empty()){
        node u=q.top();
        q.pop();
        used[u.pos][u.Kth]=1;
        f[u.pos][u.Kth]=u.mon;
        int U=u.pos;
        if(u.Kth==0){
            for(int i=firrrr.hed[u.pos];i;i=firrrr.nxt[i]){
                int v=firrrr.tal[i];
                int val=firrrr.val[i];
                if(!used[v][0]&&(f[v][u.Kth]==-1||f[U][u.Kth]+val<f[v][u.Kth])){
                    f[v][u.Kth]=f[U][u.Kth]+val;
                    push(v,f[v][u.Kth],u.Kth);
                }
            }
            if(f[U][1]==-1||f[U][0]+1<f[U][1]){
                f[U][1]=f[U][0]+1;
                push(U,f[U][0]+1,1);
            }
        }
        else{
            for(int i=secccc.hed[u.pos];i;i=secccc.nxt[i]){
                int v=secccc.tal[i];
                int val=secccc.val[i];
                if(!used[v][1]&&(f[U][u.Kth]+val<f[v][u.Kth]||f[v][u.Kth]==-1)){
                    f[v][u.Kth]=f[U][u.Kth]+val;
                    push(v,f[v][u.Kth],u.Kth);
                }
            }
            if(f[U][0]==-1||f[U][1]+1<f[U][0]){
                f[U][0]=f[U][1]+1;
                push(U,f[U][1]+1,0);
            }
        }
    }

```
然后：    
# 90
事实上应该：   
```cpp
while(!q.empty()){
		node u=q.top();
		
		q.pop();if(u.mon>f[u.pos][u.Kth]) continue;
		used[u.pos][u.Kth]=1;
		int U=u.pos;
		if(u.Kth==0){
			for(int i=firrrr.hed[u.pos];i;i=firrrr.nxt[i]){
				int v=firrrr.tal[i];
				int val=firrrr.val[i];
				if(!used[v][0]&&(f[v][u.Kth]==-1||f[U][u.Kth]+val<f[v][u.Kth])){
					f[v][u.Kth]=f[U][u.Kth]+val;
					push(v,f[v][u.Kth],u.Kth);
				}
			}
			if(f[U][1]==-1||f[U][0]+1<f[U][1]){
				f[U][1]=f[U][0]+1;
				push(U,f[U][0]+1,1);
			}
		}
		else{
			for(int i=secccc.hed[u.pos];i;i=secccc.nxt[i]){
				int v=secccc.tal[i];
				int val=secccc.val[i];
				if(!used[v][1]&&(f[v][u.Kth]==-1||f[U][u.Kth]+val<f[v][u.Kth])){
					f[v][u.Kth]=f[U][u.Kth]+val;
					push(v,f[v][u.Kth],u.Kth);
				}
			}
			if(f[U][0]==-1||f[U][1]+1<f[U][0]){
				f[U][0]=f[U][1]+1;
				push(U,f[U][1]+1,0);
			}
		}
	}
```
记住要少更新，会出大事！     
更新过就不更新！   
std:(甚长)  
```cpp
//emm,这是一个神奇的做法 
#include<bits/stdc++.h>
using namespace std;
const int N=100001;
const int M=1000005;
const int MAXN=1000005;
typedef long long ll;
struct node{
	int pos;
	ll mon;
	int Kth;//所在的层 
};
struct lined{
	int hed[MAXN];
	int tal[MAXN];
	int val[MAXN];
	int nxt[MAXN];
}firrrr,secccc;
ll ans=-1;
struct pointy{
	int x,y;
	int Rk;
}steam,eded,a[M],b[M];
ll f[M][2];//f[i][k]表示第编号为i的点，在第k层最短路是多少。
int num1[N]={0};//都是一些毫无卵用的建边神器 
int num2[N]={0};
int s[N];
vector<int> S1[N],S2[N];
vector<int> s1[N],s2[N];
int n,m;
int real_mmm;
int c1c=0;
int c2c=0;
bool used[M][2]={0};
priority_queue<node> q;
inline ll min(ll x,ll y){
	return x<y?x:y;
}
inline ll max(ll x,ll y){
	return x>y?x:y;
}
inline ll abs(ll x,ll y){
	if(x>y) return x-y;
	else return y-x;
}
inline void addegeX(int x,int y,int z){
	//cout << b[x].x << " " << b[y].x << endl;
	//cout << x << " " << y << " " << z<<endl;
	c1c++;
	firrrr.tal[c1c]=y;
	firrrr.val[c1c]=z;
	firrrr.nxt[c1c]=firrrr.hed[x];
	firrrr.hed[x]=c1c;
}
inline void addegeY(int x,int y,int z){
	//cout << x << " " << y << " " << z<<endl;
	c2c++;
	secccc.tal[c2c]=y;
	secccc.val[c2c]=z;
	secccc.nxt[c2c]=secccc.hed[x];
	secccc.hed[x]=c2c;
}
inline ll distr(int aa,int bb){
	return 2*abs(b[bb].y,b[aa].y);
}
inline ll distlr(int aa,int bb){
	return 2*abs(b[bb].x,b[aa].x);
}
bool cmp2(pointy x,pointy y){
	if(x.x==y.x) return x.y<y.y;
	return x.x<y.x;
}
bool cmp1(pointy x,pointy y){
	if(x.y==y.y) return x.x<y.x;
	return x.y<y.y;
}
bool kcmp2(int x,int y){
	if(a[x].x==a[y].x) return a[x].y<a[y].y;
	return a[x].x<a[y].x;
}
bool kcmp1(int x,int y){
	if(a[x].y==a[y].y) return a[x].x<a[y].x;
	return a[x].y<a[y].y;
}
bool operator<(const node &aa,const node &bb) //重载小于运算符  
{  
    return aa.mon>bb.mon;  
}  
inline void push(int pos,ll mon,int Kth)  
{  
    node x;  
    x.pos=pos,x.mon=mon,x.Kth=Kth;  
    q.push(x);  
}  
inline void ins_sort_a(int x){
	int u=S1[x].size();
	for(int i=0;i<u;i++){
		s[i]=S1[x][i];
	}
	sort(s,s+u,kcmp1);
	for(int i=0;i<u;i++){
		s1[x].push_back(s[i]);
	}
	return;
}
inline void ins_sort_b(int x){
	int u=S2[x].size();
	for(int i=0;i<u;i++){
		s[i]=S2[x][i];
	}
	sort(s,s+u,kcmp2);
	for(int i=0;i<u;i++){
		s2[x].push_back(s[i]);
	}
	return;
}
inline void preddd(){
	scanf("%d%d",&n,&m);
	real_mmm=m+2;
	for(int i=1;i<=m;i++){
		scanf("%d%d",&a[i].x,&a[i].y);
		a[i].Rk=i;
		b[i]=a[i];
		S1[a[i].x].push_back(i);
		S2[a[i].y].push_back(i);
		num1[a[i].x]++;
		num2[a[i].y]++;
	}
	scanf("%d%d%d%d",&steam.x,&steam.y,&eded.x,&eded.y);
	steam.Rk=m+1;
	eded.Rk=m+2;
	
	if(steam.x==eded.x&&steam.y==eded.y){
		printf("0\n");
		return;
	}
	a[m+1]=steam;
	a[m+2]=eded;
	b[m+1]=a[m+1];
	b[m+2]=a[m+2];
	num1[a[m+1].x]++;
	num2[a[m+1].y]++;
	num1[a[m+2].x]++;
	num2[a[m+2].y]++;
	//别忘记把起点终点弹入!
	S1[a[m+1].x].push_back(m+1);
	S2[a[m+1].y].push_back(m+1);
	S1[a[m+2].x].push_back(m+2);
	S2[a[m+2].y].push_back(m+2);
	//先对x坐标搞搞
	/*
	for(int i=1;i<=n;i++){
		ins_sort_a(i);
		ins_sort_b(i);
	}
	*/
	/*
	for(int i=1;i<=n;i++){
		if(num1[i]<2) continue;
		for(int j=0;j<num1[i];j++){
			if(j==0){
				addegeX(s1[i][j],s1[i][j+1],distr(s1[i][j],s1[i][j+1]));
			}
			else if(j==num1[i]-1){
				addegeX(s1[i][j],s1[i][j-1],distr(s1[i][j],s1[i][j-1])); 
			} 
			else{
				addegeX(s1[i][j],s1[i][j+1],distr(s1[i][j],s1[i][j+1]));
				addegeX(s1[i][j],s1[i][j-1],distr(s1[i][j],s1[i][j-1]));
			}
		}
	} 
	for(int i=1;i<=n;i++){
		if(num2[i]<2) continue;
		for(int j=0;j<num2[i];j++){
			if(j==0){
				addegeY(s2[i][j],s2[i][j+1],distlr(s2[i][j],s2[i][j+1]));
			}
			else if(j==num2[i]-1){
				addegeY(s2[i][j],s2[i][j-1],distlr(s2[i][j],s2[i][j-1])); 
			} 
			else{
				addegeY(s2[i][j],s2[i][j+1],distlr(s2[i][j],s2[i][j+1]));
				addegeY(s2[i][j],s2[i][j-1],distlr(s2[i][j],s2[i][j-1]));
			}
		}
	} //111
	*/
	sort(a+1,a+m+3,cmp2);
	for(int i=1;i<m+2;i++){
		if(b[a[i].Rk].x==b[a[i+1].Rk].x){
			addegeX(a[i].Rk,a[i+1].Rk,distr(a[i].Rk,a[i+1].Rk));
			addegeX(a[i+1].Rk,a[i].Rk,distr(a[i].Rk,a[i+1].Rk));
		}
	}
	sort(a+1,a+m+3,cmp1);
	for(int i=1;i<m+2;i++){
		if(b[a[i].Rk].y==b[a[i+1].Rk].y){
			addegeY(a[i].Rk,a[i+1].Rk,distlr(a[i].Rk,a[i+1].Rk));
			addegeY(a[i+1].Rk,a[i].Rk,distlr(a[i].Rk,a[i+1].Rk));
		}
	}
}
inline void upt(ll x,ll y){
	if(x==-1){
		if(ans==-1) ans=y; 
		else ans=min(ans,y);
		return;
	}
	else if(y==-1){
		if(ans==-1) ans=x;
		else ans=min(ans,x);
		return;
	}
	else{
		if(ans==-1) ans=min(x,y);
		else ans=min(ans,min(x,y));
		return;
	}
}
inline int numy(int x,ll y){
	int a[30],NMN=0;
	while(y){
		a[++NMN]=y%10;
		y/=10;
	}
	return a[NMN-(x-1)];
}
inline int print(ll y){
	int a[30],NMN=0;
	while(y){
		a[++NMN]=y%10;
		y/=10;
	}
	a[NMN-2]--;
	a[NMN-3]+=6;
	for(int i=NMN;i>=1;i--) printf("%d",a[i]);
	printf("\n");
}
inline void dijkstra(){
	memset(f,-1,sizeof(f));
	push(m+1,0,0);//两层都push一遍 
	push(m+1,0,1);
	f[m+1][0]=0,f[m+1][1]=0;
	memset(used,0,sizeof(used));
	while(!q.empty()){
		node u=q.top();
		
		q.pop();if(u.mon>f[u.pos][u.Kth]) continue;
		used[u.pos][u.Kth]=1;
		int U=u.pos;
		if(u.Kth==0){
			for(int i=firrrr.hed[u.pos];i;i=firrrr.nxt[i]){
				int v=firrrr.tal[i];
				int val=firrrr.val[i];
				if(!used[v][0]&&(f[v][u.Kth]==-1||f[U][u.Kth]+val<f[v][u.Kth])){
					f[v][u.Kth]=f[U][u.Kth]+val;
					push(v,f[v][u.Kth],u.Kth);
				}
			}
			if(f[U][1]==-1||f[U][0]+1<f[U][1]){
				f[U][1]=f[U][0]+1;
				push(U,f[U][0]+1,1);
			}
		}
		else{
			for(int i=secccc.hed[u.pos];i;i=secccc.nxt[i]){
				int v=secccc.tal[i];
				int val=secccc.val[i];
				if(!used[v][1]&&(f[v][u.Kth]==-1||f[U][u.Kth]+val<f[v][u.Kth])){
					f[v][u.Kth]=f[U][u.Kth]+val;
					push(v,f[v][u.Kth],u.Kth);
				}
			}
			if(f[U][0]==-1||f[U][1]+1<f[U][0]){
				f[U][0]=f[U][1]+1;
				push(U,f[U][1]+1,0);
			}
		}
	}
	if(f[m+2][0]==-1&&f[m+2][1]==-1) ans=ans;
	else upt(f[m+2][0],f[m+2][1]);
	//if(numy(3,ans)==1&&numy(4,ans)==3) print(ans);
	//else
	printf("%lld\n",ans);
}
int main(){
	preddd();
	dijkstra();
	//SPFA();
	return 0;
} 
/*
LALALALALAL
LALLA
LALLA
LALL
ALL
LA
*/
```
只有300行~

---

## 作者：gzh01 (赞：1)

这个没有某dalao的那么高效，但是对于数据较小的数据点还是可以过的。可以作为最短路的一道模板题。

思路：

可以看成每个换乘站都是一个节点的图。输入时先把所有点存在一个图里，包括起点终点。如果x相等或y相等就建边。

之后进行SPFA即可。

60分代码：

 
 
 
 
```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>
#include <queue>
using namespace std;
struct edge{
    int t;
    int dist;
};
int n,m;
int x,y;
int xb,yb;
int xd,yd;
int tail=1;
queue<int> q;
int xs[100001];
int ys[100001];
int dis[20001];
bool vis[20001];
vector<edge> g[20001];
void spfa(int s){
    for(int i=1;i<=tail;i++) dis[i]=0x7ffffff;
    for(int i=1;i<=tail;i++) vis[i]=false;
    dis[s]=0;
    q.push(s);
    while(not(q.empty())){
        int u=q.front();
        q.pop();
        vis[u]=false;
        for(int i=0;i<g[u].size();i++){
            int v=g[u][i].t;
            int w=g[u][i].dist;
            if(dis[u]+w+1<dis[v]){
                dis[v]=dis[u]+w+1;
                if(vis[v]==false){
                    q.push(v);
                    vis[v]=true;
                }
            }
        }
    }
}
int main(int argv,char* argc[]){
    scanf("%d%d",&n,&m);
    while(m--){
        scanf("%d%d",&x,&y);
        xs[tail]=x;
        ys[tail++]=y;
    }scanf("%d%d%d%d",&xb,&yb,&xd,&yd);
    xs[tail]=xb;
    ys[tail++]=yb;
    xs[tail]=xd;
    ys[tail++]=yd;
    for(int i=1;i<=tail;i++) for(int j=1;j<=tail;j++) if((i)not_eq(j))
        if(xs[i]==xs[j])      g[i].push_back((edge){j,abs(ys[i]-ys[j])*2});
        else if(ys[i]==ys[j]) g[i].push_back((edge){j,abs(xs[i]-xs[j])*2});
    spfa(tail-2);
    if(dis[tail-1]==0x7ffffff)    printf("-1");
    else                        printf("%d",dis[tail-1]-1);
}
```

---

## 作者：BDFCL (赞：0)

**Solution**

由于题目中有向一个方向一直走、转向两种走法，不难想到拆点后跑最短路

具体的说，我们将一个格点$a_{i,j}$拆成两个$a_{i, j, 0}, a_{i, j, 1}$，分别表示横向走与纵向走，此时的点数是$N^2$级别的，考虑优化

显然，有用的只有那些可以转向的边与起点终点，所以我们只保留这些点，一次标号为$v_{1..m+2,0/1}$，其中$1$~$m$为输入给定的可以转向的点，$m+1$与$m+2$为起点与终点，根据题意，我们连如下边：
$$
\begin {aligned}
v_{i, 0} &\longleftrightarrow v_{j, 0} | row_i == row_j&\quad(weight = (col_i - col_j) \times 2)\\
v_{i, 1} &\longleftrightarrow v_{j, 1} | col_i == col_j&\quad(weight = (row_i-row_j)\times 2) \\
v_{i, 0} &\longleftrightarrow v_{i, 1} &\quad (weight = 1)

\end {aligned}
$$
其中$row_i$表示$i$在原来网格图中的行号，$col_i$表示$i$在原来网格图中的列号

显然，为了优化建图，我们只将$i$向离他最近的$j$连边即可

然后在建立一个超级起点$S$，连边：
$$
S \to v_{m+1, 0/1} \quad (weight = 0)
$$
然后从超级起点跑一边$dijkstra$，最后的答案为$min (dis[v_{m+2, 0}], dis[v_{m+2, 1}])$

复杂度大概是$O(M\log M)$

**Code**

```c++
#include <bits/stdc++.h>

#define INF 0x3f3f3f3f
#define N (int) 1e6

using namespace std;
int input () {
    int x = 0, f = 0;
    char c = getchar ();
    while (c < '0' || c > '9') f = c == '-', c = getchar ();
    while (c >= '0' && c <= '9') x = (x << 1) + (x << 3) + (c ^ 48), c = getchar ();
    return f ? - x : x;
}

int n, m;
pair <int, int> a[N];
vector <int> r[N], c[N];

bool cmpr (const int & x, const int & y) {
    return a[x].second < a[y].second;
}
bool cmpc (const int & x, const int & y) {
    return a[x].first < a[y].first;
}

struct Edge {
    int v, w, next;
} edge[N];
int fst[N], ecnt;
void add_edge (int u, int v, int w) {
    edge[ecnt].v = v, edge[ecnt].w = w, edge[ecnt].next = fst[u], fst[u] = ecnt ++;
}
void init_e () {
    memset (fst, -1, sizeof (fst));
}

int dis[N];
int vis[N];
struct Node {
    int u, dis;
    friend bool operator < (const Node & x, const Node & y) {
        return x.dis > y.dis;
    }
    Node (int _u, int _dis) : u (_u), dis (_dis) {}
};
void dij () {
    memset (dis, INF, sizeof (dis));
    memset (vis, 0, sizeof (vis));
    priority_queue <Node> pq;

    pq.push (Node (1, 0));
    dis[1] = 0;
    while (! pq.empty ()) {
        int u = pq.top ().u;
        pq.pop ();
        if (vis[u]) continue;
        vis[u] = true;
        for (int e = fst[u]; e != -1; e = edge[e].next) {
            int v = edge[e].v, w = edge[e].w;
            if (dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w;
                pq.push (Node (v, dis[v]));
            }
        }
    }
}

int main () {
    init_e ();

    n = input (), m = input ();

    for (int i = 1; i <= m+2; i ++) {
        a[i].first = input (), a[i].second = input ();
        r[a[i].first].push_back (i);
        c[a[i].second].push_back (i);
        add_edge (i<<1, i<<1|1, 1);
        add_edge (i<<1|1, i<<1, 1);
    }

    for (int i = 1; i <= n; i ++) {
        sort (r[i].begin (), r[i].end (), cmpr);
        sort (c[i].begin (), c[i].end (), cmpc);
        for (int j = 1; j < r[i].size (); j ++) {
            int u = r[i][j-1] << 1, v = r[i][j] << 1, w = (a[r[i][j]].second-a[r[i][j-1]].second)<<1;
            add_edge (u, v, w);
            add_edge (v, u, w);
        }
        for (int j = 1; j < c[i].size (); j ++) {
            int u = c[i][j-1] << 1|1, v = c[i][j] << 1|1, w = (a[c[i][j]].first-a[c[i][j-1]].first)<<1;
            add_edge (u, v, w);
            add_edge (v, u, w);
        }
    }

    add_edge (1, (m+1)<<1, 0), add_edge (1, (m+1)<<1|1, 0);
    
    dij ();

    int ans = min (dis[(m+2)<<1], dis[(m+2)<<1|1]);

    cout << (ans == INF ? -1 : ans) << endl;

    return 0;
}
```

**Conclusion**

* 拆点（好像也叫分层图）
* 建立虚点
* 最短路

---

## 作者：Piwry (赞：0)

作为为数不多的写过的分层图题还是发篇题解

## \* 分层图简介

主要是将在图上的决策也转化为边，并赋予边权，从而可以用一般的图算法解决含决策的图上问题

基本上分层图题 dp 也能做，最优复杂度是一样的（毕竟 dijkstra 也是一种 dp）。不过分层图的优点在于便于直观理解

## 解析

其中换站的决策很麻烦

一种思路是将决策的贡献直接加到边权上，例如在某行或某列上有元素 $\{v_1, v_2, \cdots v_i\}$，**我们对它们两两连边**，边权为 乘车时间 $+1$

显然这样作出的图边数很多，建图也很慢

考虑把横向走的分为一层图，纵向走的分为一层图，横/纵向走的层只连原图上横/纵铁路的边，且只在相邻的结点间连。如若有轴上的顺序三个点 $u_1, u_2, u_3$，我们只连 $(u_1, u_2), (u_2, u_3)$，这是因为 $w(u_1, u_3)=w(u_1, u_2)+w(u_2, u_3)=w(p(u_1, u_3))$（因为没有换站，因此不用对边权动手脚）

两层结点一一对应，设为 $u_i, v_i$，在每个 $u_i, v_i$ 间连权值为 $1$ 的边，即换站决策的消耗

大概这样：

![div-map](https://cdn.luogu.com.cn/upload/image_hosting/9lgg8xrw.png)

（我代码中还有个 “超级起点/终点"，图中没画，应该挺好理解）

然后直接跑最短路即可

## CODE

注意将输入给出的起点终点也视为站点放入分层图

然后设一个 “超级起点/终点"，分别对两层的起点/终点连一条边权为 $0$ 的边

```cpp
#include <cstdio>
#include <queue>
#include <cstring>
#include <algorithm>
#define ll long long
using std::priority_queue;
using std::vector;
using std::pair;
using std::sort;
typedef pair<int, int> pad;

/*------------------------------Map------------------------------*/

const int MAXN =1e5+50;

int n, m;
vector<pad> E[MAXN<<1];
int dist[MAXN<<1];
bool vis[MAXN<<1];
struct elm{
	int to, dist;
	elm(int tt, int d):to(tt), dist(d){}
	bool operator < (const elm &B) const{ return dist > B.dist; }
};

inline void addedge(int u, int v, int w){
	E[u].push_back(pad(v, w)), E[v].push_back(pad(u, w));
}

priority_queue<elm, vector<elm> > que;

inline int dijkstra(int s, int t){
	memset(dist, 0x3f, sizeof(dist));
	dist[s] =0;
	que.push(elm(s, 0));
	while(que.size()){
		elm u =que.top();
		que.pop();
		if(vis[u.to]) continue;
		if(u.to == t)
			return dist[t];
		vis[u.to] =1;
		for(pad v:E[u.to]){
			if(!vis[v.first] && dist[u.to]+v.second < dist[v.first]){
				dist[v.first] =dist[u.to]+v.second;
				que.push(elm(v.first, dist[u.to]+v.second));
			}
		}
	}
	return -1;
}

/*------------------------------Main------------------------------*/

inline int read(){
	int x =0; register char c =getchar();
	while(c < '0' || c > '9') c =getchar();
	while(c >= '0' && c <= '9') x = (x<<3) + (x<<1) + (48^c), c =getchar();
	return x;
}

vector<pad> line[(int)2e4+50], row[(int)2e4+50]/*行、列*/;

int main(){
	n =read(), m =read();
	for(int i =1; i <= m+2; ++i){
		int x =read(), y =read();
		line[x].push_back(pad(y, i));
		row[y].push_back(pad(x, m+2+i));
	}
	for(int i =1; i <= n; ++i){
		sort(line[i].begin(), line[i].end());
		sort(row[i].begin(), row[i].end());
		for(int k =1; k < (int)line[i].size(); ++k)
			addedge(line[i][k].second, line[i][k-1].second, 2*(line[i][k].first-line[i][k-1].first));
		for(int k =1; k < (int)row[i].size(); ++k)
			addedge(row[i][k].second, row[i][k-1].second, 2*(row[i][k].first-row[i][k-1].first));
	}
	for(int i =1; i <= m; ++i)
		addedge(i, m+2+i, 1);
	int s =2*(m+2)+1, t =2*(m+2)+2;
	addedge(s, m+1, 0), addedge(s, (m+2)+m+1, 0);
	addedge(t, m+2, 0), addedge(t, (m+2)+m+2, 0);
	printf("%d", dijkstra(s, t));
}
```

## \* 更多例题

[2018 ACM-ICPC 南京](https://blog.csdn.net/monochrome00/article/details/82289394)

[P4822 [BJWC2012]冻结](https://www.luogu.com.cn/problem/P4822)

[P4568 [JLOI2011]飞行路线](https://www.luogu.com.cn/problem/P4568)

[P2939 [USACO09FEB]Revamping Trails G](https://www.luogu.com.cn/problem/P2939)

---

## 作者：resftlmuttmotw (赞：0)

### 思路

很简单 分层图 + $SPFA$


### 坑点

我提交了$10+$次 全部$90pts$

希望各位大佬不会跟我犯一样的错误

**空间大小不要开错了**

不然会$WA$ 而不是$RE$ 半天差不出来错的那种（第二个点一直错）

点 开 $3e5 + 10$

边开 $3e6 + 10$


这题没有卡$SPFA$

不用堆优化 （374ms）在题解中算挺快的

不用开$long long$

### $Code$

```cpp
#include <stack>
#include <queue>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
#define reg register int
#define isdigit(x) ('0' <= x&&x <= '9')
template<typename T>
inline T Read(T Type)
{
	T x = 0,f = 1;
	char a = getchar();
	while(!isdigit(a)) {if(a == '-') f = -1;a = getchar();}
	while(isdigit(a)) {x = (x << 1) + (x << 3) + (a ^ '0');a = getchar();}
	return x * f;
}
const int MAXN = 3e5 + 10,MAXM = 3e6 + 10;
struct node
{
	int x,y,num;
}sta[MAXN];
bool cmp1(node a,node b)
{
	if(a.x < b.x) return 1;
	if(a.x == b.x) return (a.y < b.y?1:0);
	return 0;
}
bool cmp2(node a,node b)
{
	if(a.y < b.y) return 1;
	if(a.y == b.y) return (a.x < b.x?1:0);
	return 0;
}
inline int cost(int a,int b) {return (a - b > 0?a - b:b - a) * 2;}
struct EDGE
{
	int u,v,w,next;
}edge[MAXM];
int n,m,cnt,head[MAXN];
inline void addedge(int u,int v,int w)
{
	edge[++cnt].u = u;
	edge[cnt].v = v;
	edge[cnt].w = w;
	edge[cnt].next = head[u];
	head[u] = cnt;
}
inline void add(int u,int v,int w) {addedge(u,v,w),addedge(v,u,w);}
inline void buildgraph()
{
	sort(sta + 1,sta + 3 + m,cmp1);
	for(reg i = 2;i <= m + 2;i++)
		if(sta[i].x == sta[i - 1].x) 
			add(sta[i].num,sta[i - 1].num,cost(sta[i - 1].y,sta[i].y));
	sort(sta + 1,sta + 3 + m,cmp2);
	for(reg i = 2;i <= m + 2;i++)
		if(sta[i].y == sta[i - 1].y) 
			add(sta[i].num + m + 2,sta[i - 1].num + m + 2,cost(sta[i - 1].x,sta[i].x));
	for(reg i = 1;i <= m + 2;i++)
		add(sta[i].num,sta[i].num + m + 2,(sta[i].num > m?0:1));
}
bool vis[MAXN];
int d[MAXN];
inline int dijkstra(int s,int t)
{
	queue<int> q;
	q.push(s);
	vis[s] = 1;
	memset(d,0x7f7f7f,sizeof(d));
	d[s] = 0;
	while(!q.empty())
	{
		int tp = q.front();q.pop();
		vis[tp] = 0;
		for(reg e = head[tp];e;e = edge[e].next)
		{
			int v = edge[e].v,w = edge[e].w;
			if(d[tp] + w < d[v])
			{
				d[v] = d[tp] + w;
				if(!vis[v]) q.push(v);
				vis[v] = 1;
			}
		}
	}
	return (d[t] < 0x7f7f7f?d[t]:-1);
}
int main()
{
	n = Read(1),m = Read(1);
	for(reg i = 1;i <= m + 2;i++)
		sta[i].x = Read(1),sta[i].y = Read(1),sta[i].num = i;
	buildgraph();
	int ans = dijkstra(m + 1,m + 2);
	printf("%d",ans);
	return 0;
}
```

---

## 作者：chihik (赞：0)

这道题显然是最短路，但是似乎转向时不好处理，于是我们要用到分层图。

实现很简单，建立两层图，第一层记录横向边，第二层记录纵向边，相同的关键点两层图连一条费用为1的边。

还有，这道题只需要在关键点之间连边（非关键点无法转向，连了也没用），路径长度为坐标差*2。

对于起点和终点，我们把它也当作关键点，但转向只需0的费用。

```cpp
#include <cstdio>
#include <cstring>
#include <queue>
#include <iostream>
#include <algorithm>
using namespace std;
#define INF 0x3f3f3f3f

const int MAXM = 100005;
int n , m;
struct Point{
    int x , y , id;
}imp[ MAXM + 5 ];
bool cmpx( const Point &a , const Point &b ) {
    return a.x < b.x || ( a.x == b.x && a.y < b.y );
}
bool cmpy( const Point &a , const Point &b ) {
    return a.y < b.y || ( a.y == b.y && a.x < b.x );
} 
bool cmpi( const Point &a , const Point &b ) {
	return a.id < b.id;
}

struct node{
    int v , w;
    bool operator > ( const node &x ) const {
        return w > x.w;
    }
};
vector< node > Graph[ 8 * MAXM + 5 ];
int dist[ 2 * MAXM + 5 ];
bool vis[ 2 * MAXM + 5 ];
int Dijkstra( int s , int t ) {
    priority_queue< node , vector< node > , greater< node > > Que;
    memset( dist , INF , sizeof( dist ) );
    memset( vis , 0 , sizeof( vis ) );

    Que.push( { s , dist[ s ] = 0 } );
    while( !Que.empty( ) ) {
        int u = Que.top( ).v; Que.pop( );
        
        if( vis[ u ] ) continue;
		vis[ u ] = 1;
		
        for( int i = 0 ; i < Graph[ u ].size( ) ; i ++ ) {
            int v = Graph[ u ][ i ].v , w = Graph[ u ][ i ].w;
            if( dist[ v ] > dist[ u ] + w ) {
                dist[ v ] = dist[ u ] + w;
                Que.push( { v , dist[ v ] } );
            }
        }
    }
    return dist[ t ] == INF ? -1 : dist[ t ];
}

int main( ) {
    scanf("%d %d",&n,&m);
    for( int i = 1 ; i <= m ; i ++ )
        scanf("%d %d", &imp[ i ].x , &imp[ i ].y ) , imp[ i ].id = i;
    m ++ , scanf("%d %d", &imp[ m ].x , &imp[ m ].y ) , imp[ m ].id = m;
    m ++ , scanf("%d %d", &imp[ m ].x , &imp[ m ].y ) , imp[ m ].id = m;

    sort( imp + 1 , imp + m + 1 , cmpx );
    for( int i = 1 ; i <= m ; i ++ ) {
        int dex1 = imp[ i ].id , dex2 = imp[ i + 1 ].id;
        if( imp[ i ].x != imp[ i + 1 ].x ) continue;
        Graph[ dex1 ].push_back( { dex2 , 2 * ( imp[ i + 1 ].y - imp[ i ].y ) } );
        Graph[ dex2 ].push_back( { dex1 , 2 * ( imp[ i + 1 ].y - imp[ i ].y ) } );
    }
    
    sort( imp + 1 , imp + m + 1 , cmpy );
    for( int i = 1 ; i <= m ; i ++ ) {
        int dex1 = imp[ i ].id + MAXM , dex2 = imp[ i + 1 ].id + MAXM;
        if( imp[ i ].y != imp[ i + 1 ].y ) continue;
        Graph[ dex1 ].push_back( { dex2 , 2 * ( imp[ i + 1 ].x - imp[ i ].x ) } );
        Graph[ dex2 ].push_back( { dex1 , 2 * ( imp[ i + 1 ].x - imp[ i ].x ) } );
    }
    
	sort( imp + 1 , imp + m + 1 , cmpi );
    for( int i = 1 ; i <= m ; i ++ ) {
        int f = ( i <= m - 2 ) , dex1 = imp[ i ].id , dex2 = imp[ i ].id + MAXM;
        Graph[ dex1 ].push_back( { dex2 , f } );
        Graph[ dex2 ].push_back( { dex1 , f } );
    }
    printf("%d", Dijkstra( m - 1 , m ) );
    return 0;
}
```


---

## 作者：cheating_dictator (赞：0)

~~蒟蒻来水题解~~

将每个车站看作一个节点，很明显的最短路,正权图用dijkstra

### 怎么存图？

一开始重新建了个图——对于每两个节点，如果在一条线上就建边

T了，60pts

其实可以把横向的和竖向的分别存一个图。

（邻接表）vec1[i]表示第i行的节点，vec2[i]表示第i列的节点

dijkstra时把vec1和vec2都遍历一遍即可

### dis数组怎么存？

dis[i][j]表示第i行第j列的距离

$n\le20000$,$n^2$的二维数组会MLE

STL提供了容器unordered_map,用法和map差不多，内部是hash

```cpp
#include<unordered_map>
unordered_map<int,unordered_map<int,int> > dis;
```

### 怎么处理换乘的时间？

将每条边+1，输出答案时-1（植树问题）

### code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
vector<int> vec1[100030];//横向图
vector<int> vec2[100030];//竖向图
unordered_map<int,unordered_map<int,int> > dis;
int xx1,yy1,xx2,yy2;//起点和终点
struct node{
	int x,y,cost;//坐标、距离
};
inline bool operator<(const node& a,const node& b{
	return a.cost>b.cost;
}
priority_queue<node> que;
void dij(){
	que.push({xx1,yy1,0});
	dis[xx1][yy1]=0;
	while(!que.empty()){
		node temp=que.top();
		que.pop();
		if(temp.cost!=dis[temp.x][temp.y])continue;
		for(auto it:vec1[temp.x]){//遍历横向图
			if(it==temp.y)continue;
			if(dis[temp.x][it]==0&&(temp.x!=xx1||it!=yy1)||dis[temp.x][it]>temp.cost+2*abs(temp.y-it)+1){//每条边都+1
				dis[temp.x][it]=temp.cost+2*abs(temp.y-it)+1;
				que.push({temp.x,it,dis[temp.x][it]});
			}
		}
		for(auto it:vec2[temp.y]){//遍历纵向图
			if(it==temp.x)continue;
			if(dis[it][temp.y]==0&&(it!=xx1||temp.y!=yy1)||dis[it][temp.y]>temp.cost+2*abs(temp.x-it)+1){
				dis[it][temp.y]=temp.cost+2*abs(temp.x-it)+1;
				que.push({it,temp.y,dis[it][temp.y]});
			}
		}
	}
}
int main(){
	ios::sync_with_stdio(0);
	cin>>n>>m;
	for(int i=1;i<=m+2;++i){
		int x,y;
		cin>>x>>y;
		if(i==m+1){//m+1表示起点
			xx1=x;
			yy1=y;
		}
		if(i==m+2){//m+2表示终点
			xx2=x;
			yy2=y;
		}
		vec1[x].push_back(y);
		vec2[y].push_back(x);
	}
	dij();
	cout<<dis[xx2][yy2]-1<<endl; //记得-1
} 
```


---


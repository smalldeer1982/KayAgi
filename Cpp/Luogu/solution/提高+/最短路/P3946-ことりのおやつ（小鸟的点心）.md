# ことりのおやつ（小鸟的点心）

## 题目描述

这是2017年的冬天。（又到了白色相簿的季节2333）

![滑雪鸟](https://db.loveliv.es/png/navi/476/0)

滑完雪之后，ことり突然想吃点心啦！于是她去了甜品店。

日本的冬天经常下雪。不幸的是，今天也是这样，每秒钟雪的厚度会增加q毫米。

秋叶原共有n个地点，编号从1到n。每个地点在开始的时候的积雪高度为hi。

有m条**双向**道路连接这些地点，它们的长度分别为wi米。

雪太大，公共交通系统已经停摆了，所以ことり得走路回家。她走路的速度是1m/s。

为了方便地图的绘制，秋叶原的道路规划使得每条道路严格地连接两个不同的地点，并且不会有两条道路连接的地点相同。

每个地点都有一个极限雪高li，单位是毫米，如果到达这个地点的时候，这里的雪的高度高于li则会被困在这个点走不出去，无法成功地走到ことり家。

点心店这个地点的编号是s，ことり家的编号是t。

不考虑点心店和ことり家的雪。

ことり想在g秒内回到家吃点心，越快越好。如果在g秒之内，ことり无法到家，或者她被困在路上了，那么ことり会把wtnap变成她的点心( ・ 8 ・ )


## 说明/提示

对于0%的数据，与样例一模一样；  
对于40%的数据，q = 0。  
对于上一行中50%的数据，所有wi < li。  
对于100%的数据，1 ≤ s, t ≤ n;  0 ≤ g, q ≤ 10^9; 0 ≤ wi ≤ li ≤ 10^9。

![](https://cdn.luogu.com.cn/upload/pic/9826.png)


## 样例 #1

### 输入

```
2 1 1 2 10 1
1 10
3 10
1 2 6```

### 输出

```
6```

## 样例 #2

### 输入

```
5 6 2 5 10 1
1 10
1 10
1 10
1 10
1 10
1 5 9
1 3 9
2 4 1
2 5 9
3 4 1
3 5 6```

### 输出

```
8```

## 样例 #3

### 输入

```
5 6 2 5 10 1
1 10
1 10
10 10
1 10
1 10
1 5 9
1 3 9
2 4 1
2 5 11
3 4 1
3 5 6
```

### 输出

```
wtnap wa kotori no oyatsu desu!```

# 题解

## 作者：TLE自动机 (赞：4)

spfa。先把时间预处理一下，【tt】为最早封路的时间，只需在spfa更换路径的时候再加个判断，很容易想到。

有一个坑的地方，在到终点的时候不用考虑雪的深度，特判一下就好。

```cpp
#include<bits/stdc++.h>//变量名跟题目中一模一样哦，不需要注释了吧
#define inf 1e9
using namespace std;
int n,m,s,t,g,q,l[1000001],head[1000001],h[1000001],cnt=1,ans,dis[1000001],vis[1000001],tt[1000001];
string no_answer="wtnap wa kotori no oyatsu desu!";
struct node{
	int next,v,w;
}edge[1000001];
void add(int from,int to,int w){
	edge[cnt].w=w;
	edge[cnt].v=to;
	edge[cnt].next=head[from];
	head[from]=cnt;
	cnt++;
}
bool spfa(){
	queue<int>q;
	for(int i=1;i<=n;i++){
		dis[i]=inf;
		vis[i]=0;
	}
	q.push(s);
	vis[s]=1;
	dis[s]=0;
	while(!q.empty()){
		int now=q.front();
		q.pop();
		vis[now]=0;
		for(int i=head[now];i;i=edge[i].next){
			int next=edge[i].v;
			if((dis[next]>dis[now]+edge[i].w&&dis[now]+edge[i].w<tt[next]&&next!=t)||(dis[next]>dis[now]+edge[i].w&&next==t)) 
			{
				dis[next]=dis[now]+edge[i].w;
				if(!vis[next]){
					vis[next]=1;
					q.push(next);
				}
			}
		}
	}
	ans=dis[t];
	if(ans==inf) return 0;
	else return 1;
}
int main(){
	cin>>n>>m>>s>>t>>g>>q;
	for(int i=1;i<=n;i++){
		cin>>h[i]>>l[i];
	}
	int u,v,w;
	for(int i=1;i<=m;i++){
		cin>>u>>v>>w;
		add(u,v,w);
		add(v,u,w);
	}
	for(int i=1;i<=n;i++){
		if(q==0) {
			tt[i]=inf+1;
			continue;
		}
		tt[i]=int((double)(l[i]-h[i])/(double)(q));
	}
	if(spfa()&&ans<=g) cout<<ans;
	else cout<<no_answer;
	return 0;
}
```

~~偷偷抱走南小鸟~~

---

## 作者：dunko (赞：3)

## **题目**
[点这里](https://www.luogu.org/problemnew/show/P3946)
## **思路**
看完了题，这不就是最短路吗？

怀着对SPFA的热爱之心去码了一遍，一遍AC！！！（这竟然没卡SPFA）

这里就是在松弛之后，向队列加点时加一点判断，看看此时这点的雪是否太厚而被困住，如果不会就加入队列，否则不加。

## **代码**
话不多说，代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=500001;
int n,m,s,t,g,q,h[maxn],l[maxn],cnt,head[maxn],dis[maxn];
bool vis[maxn];
struct node{
	int nxt,to,w;
}edge[maxn<<2];
void add(int x,int y,int w){
	edge[++cnt]=(node){head[x],y,w};
	head[x]=cnt;
}
void SPFA(){
	memset(dis,63,sizeof(dis));//离出发点一开始都设为一个很大的数
	dis[s]=0; vis[s]=1;//SPFA基本操作
	queue<int>que; que.push(s);
	while(que.size()){
		int d=que.front();que.pop();vis[d]=0;//别忘了标记去掉
		for(int i=head[d];i;i=edge[i].nxt){
			int y=edge[i].to;
			if(dis[y]>dis[d]+edge[i].w){//松弛操作
				dis[y]=dis[d]+edge[i].w;
				if(!vis[y]&&l[y]>=h[y]+dis[y]*q) que.push(y),vis[y]=1;
                //就是在这里加判断，从出发开始到这里的这段时间中下的雪加上原来的雪是否大于限制
			}
		}
	}
}
int main(){
	scanf("%d%d%d%d%d%d",&n,&m,&s,&t,&g,&q);
	for(int i=1;i<=n;i++) scanf("%d%d",&h[i],&l[i]);
	int x,y,z;
	for(int i=1;i<=m;i++){
		scanf("%d%d%d",&x,&y,&z);
		add(x,y,z),add(y,x,z);//注意这里是双向边
	}
	SPFA();
	if(dis[t]<=g) cout<<dis[t]<<endl;//如题意，输出
	else cout<<"wtnap wa kotori no oyatsu desu!"<<endl;
	return 0;
}
```
这题就是这样，谢谢浏览。


---

## 作者：VenusM1nT (赞：2)

$\text{Dijkstra}$。有句老话说得好，“十年 $\text{OI}$ 一场空，数组开小见祖宗”，而今天，我也体会了一把“见祖宗”的快感。

这题非常简单，只需要在 $\text{Dijkstra}$ 增广的过程中判断一下到达时刻积雪是否大于 $lim[v]$ 即可，但是不知道为什么，我半年前用基本一样的思想写的 $\text{Spfa}$ 一直过不去，一直 $\text{WA}$ 的 $\text{\#16}$，于是我在半年之后终于想起来，并且写了一个 $\text{Dijkstra}$，但是没想到因为数组开小了，结果一直 $\text{WA\#20}$，数组调大就 $\text{AC}$ 了。

至于为什么会开小？你有体验过把 $\text{MAXN}$ 和 $\text{MAXM}$ 写混的感受吗？

```cpp
#include<bits/stdc++.h>
#define MAXN 200005
#define MAXM 500005
#define ll long long
using namespace std;
struct Node
{
    int u;
    ll dis;
    bool operator < (const Node &x) const
    {
        return x.dis<dis;
    }
};
priority_queue <Node> q;
int cnt,fst[MAXN],nxt[MAXM<<1],to[MAXM<<1];
int n,m,S,T;
ll Q,g,w[MAXM<<1],hei[MAXN],lim[MAXN],dis[MAXN];
bool fg;
void AddEdge(int u,int v,ll c)
{
    to[++cnt]=v;
    nxt[cnt]=fst[u];
    fst[u]=cnt;
    w[cnt]=c;
}
void Dijkstra()
{
    memset(dis,60,sizeof(dis));
    q.push((Node){S,0});
    dis[S]=0;
    while(!q.empty())
    {
        Node now=q.top();
        q.pop();
        int u=now.u;
        ll d=now.dis;
        if(d!=dis[u]) continue;
        for(int i=fst[u];i;i=nxt[i])
        {
            int v=to[i];
            ll len=dis[u]+w[i];
            if(dis[v]>dis[u]+w[i] && (hei[v]+len*Q<=lim[v] || v==S || v==T))
            {
                if(v==T) fg=1;
                dis[v]=dis[u]+w[i];
                q.push((Node){v,dis[v]});
            }
        }
    }
}
int main()
{
    scanf("%d %d %d %d %lld %lld",&n,&m,&S,&T,&g,&Q);
    for(int i=1;i<=n;i++) scanf("%lld %lld",&hei[i],&lim[i]);
    for(int i=1;i<=m;i++)
    {
        int x,y;
        ll z;
        scanf("%d %d %lld",&x,&y,&z);
        AddEdge(x,y,z);
        AddEdge(y,x,z);
    }
    if(S==T) return puts("0"),0;
    Dijkstra();
    if(!fg || dis[T]>g) puts("wtnap wa kotori no oyatsu desu!");
    else printf("%lld\n",dis[T]);
    return 0;
}
```

---

## 作者：Aoki_灏 (赞：2)

~~蒟蒻快NOIP想练习一下一向很差的图论，随便翻了翻题就找到了这个一看就很想做的题，本人拉拉人~~

这题裸的spfa，思路很简单，注意几个特别判定点就行，因为一遍A了就来发个题解

~~感觉算不上蓝题吧，绿题封顶~~

## - 注意事项


           一开始输入时判定积雪已经满的情况，此时这个点相当于无效点可以直接忽略，打个标记
           再是在bfs最短路时加入特殊判定，
           (h[v]+(dis[u]+edge[i].w)*qq<=l[v]||v==ed)
           不需要特判q=0的情况
           然后就是普通的spfa()，于是就一遍A了
 ```
#include <bits/stdc++.h>

using namespace std;
const int N =1000010 ;
int n,m,st,ed,dis[N],vis[N],flag[N],t[N],g,qq,head[N],cnt,h[N],l[N];
inline int read()
{
    int x=0,f=1;char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
struct node
{
    int nt=-1,w,to;
}edge[N*2];
void add(int x,int y,int z)//这些都不用解释
{
    cnt++;
    edge[cnt].to=y;
    edge[cnt].w=z;
    edge[cnt].nt=head[x];
    head[x]=cnt;
}
void spfa()//普通spfa操作
{
    for(int i=1;i<=n;i++)dis[i]=(1<<30);
    queue<int>q;
    q.push(st);
    dis[st]=0;
    vis[st]=1;//入队
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        vis[u]=0;
        for(int i=head[u];i!=-1;i=edge[i].nt)
        {
            int v=edge[i].to;
            if(!flag[v]&&dis[v]>dis[u]+edge[i].w)//注意判定无效点和更新dis
            {
                if(h[v]+(dis[u]+edge[i].w)*qq<=l[v]||v==ed)//dis[u]+edge[i].w从开始到v点经历的时间*q就是增加的积雪
                {//注意不用考虑终点时的积雪，这需要特判一下，然后就没什么了
                    dis[v]=dis[u]+edge[i].w;
                    if(!vis[v])
                    {
                        vis[v]=1;
                        q.push(v);
                    }
                }

            }
        }
    }
}
int main()
{
    n=read();m=read();st=read();ed=read();g=read();qq=read();
    for(int i=1;i<=n;i++)
    {
       h[i]=read();l[i]=read();
        if(h[i]==l[i])flag[i]=1;//注意判定无效点
    }
    for(int i=1;i<=m;i++)
    {
        int x,y,z;
       x=read();y=read();z=read();
        add(x,y,z);add(y,x,z);
    }
    spfa();
    if(dis[ed]>g)printf("wtnap wa kotori no oyatsu desu!");//话说这句话啥意思喵喵喵，是wtnap被小鸟吃了？？
    //这里讨论了两种情况，一是dis[ed]=(1<<30),就是没有走到ed的情况和dis[ed]>g的情况，发现都满足dis[ed]>g就合在一起了
    else printf("%d",dis[ed]);

    return 0;
}

```
           


         

---

## 作者：pantw (赞：2)

题目&数据by @Pantw +\_+


题解：


首先，如果q为0，那么本题就是裸的最短路，将h[i]>l[i]的点去掉即可。


考虑q不为0的情况。设到达点i的距离为dist[i]那么能从该点走出去的充要条件是：



h[i] + dist[i]\*q <= l[i]

我们只需要在计算最短路时将走不出去的点停止拓展即可。 具体实现细节如有疑问详见题目页面下端的标程。


WA 19可能是因为没有忽略终点的雪。


~~比赛时RE 20是出题人的锅，题面写的数据范围是m<=2e5但#20的m=5e5。~~


QAQ（~~好像卡了无数人的AC？~~）


大家不要打我啊emmm


---

## 作者：黄汝鹏 (赞：0)

题目总结：一个人要选择最短路，并且要避免雪灾

算法总结：SPFA+特判+小技巧

分析：首先看到数据，让我想起了已死的SPFA，但是比平常的SPFA不同的是，在松弛判断语句中，要看一下这条路在走的时候有没有被雪掩,可以用一个数组进行预处理，用雪还可上涨高度除以上涨速度得出上涨时间，在与走这条路时的总共用时进行比较，能否安全通过。

     但众所周知，用除法是有精度误差的，我们先来看一例
     (li-hi)/q>du+cost;
     相等于 li-hi>(di+cost)*q
     所以可以设一数组k[i]=l[i]-h[i],然后用【k[i]>(d[u]+cost)*q】
     (点睛之笔），这样就避免了误差
     
     附上代码
     


------------
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=500000+10;
const int MAXN=100000+10;
const int oo=1e9;
int n,m,s,t,g,q2,num;
int head[MAXN],v[MAXN],d[MAXN],k[MAXN],h[MAXN],l[MAXN]; 

struct edge{
	int to,next,cost;
}e[maxn*2];

void Add(int from,int to,int cost)
{
	num++;
	e[num].to=to;
	e[num].cost=cost;
	e[num].next=head[from];
	head[from]=num;
}

void spfa()
{
	queue<int> q;
	for(int i=1;i<=n;i++) d[i]=oo;
	memset(v,0,sizeof(v));
	d[s]=0;v[s]=1;
	q.push(s);
	while(q.size())
	{
		int u=q.front();
		q.pop();
		v[u]=0;
		for(int i=head[u];i;i=e[i].next)
		{
			int to=e[i].to;
			int cost=e[i].cost;
			if((d[to]>d[u]+cost&&(d[u]+cost)*q2<k[to]&&to!=t)||(d[to]>d[u]+cost&&to==t)) 
			{
				d[to]=d[u]+cost;
				if(!v[to])
				{
					q.push(to);
					v[to]=1;
				}
			}
		}
	}
}

int main()
{
	cin>>n>>m>>s>>t>>g>>q2;
	for(int i=1;i<=n;i++)
	{
		cin>>h[i]>>l[i];
		if(q2==0) k[i]=oo+1;
        else k[i]=l[i]-h[i];
	}
	for(int i=1;i<=m;i++)
	{
		int a,b,c;
		cin>>a>>b>>c;
		Add(a,b,c);
	    Add(b,a,c);
	}
	spfa();
	if(d[t]<oo&&d[t]<=g) cout<<d[t];
	else cout<<"wtnap wa kotori no oyatsu desu!";
	return 0;
}
```
这是久别重逢的一片题解，望通过


---

## 作者：Reanap (赞：0)

# Dijkstra 模板题

由题意易知，我们只用判断到达目的地的最短时间是否超限。

限制一共有两个：

1、在走到某一个点的时候雪已经多到不能走了，对于这种情况我们只需要判断

在哪个时间点后不能通行，如果到那个点超过该时间点，则置为无法到达

2、最终时间点，只用在跑完之后判断一次

因为spfa有概率被卡，所以我们使用更稳定的Dijkstra

备注：注意q=0的情况，避免RE

见代码：

```cpp
#include <cstdio>
#include <vector>
#include <queue>
#include <cstring>
#include <algorithm>
using namespace std;
typedef long long LL;
struct node {
	LL v , w;
	node() {}
	node(LL V , LL W) {
		v = V;
		w = W;
	}
};
struct place {
	LL h , l , _max;
}p[1000005];
LL dp[1000005] , n , r , cnt , _minsec[1000005];
vector <node> G[1000005];
bool vis[1000050];
void read(LL &x) {
	LL f = 1;x = 0;char s = getchar();
	while(s < '0' || s > '9') {if(s == '-') f = -1;s = getchar();}
	while(s >= '0' && s <= '9') {x = x * 10 + s - '0'; s = getchar();}
	x *= f;
}
struct cmp1 {
	bool operator() (node &x , node &y) {
		return x.w > y.w;
	}
};
priority_queue <node , vector <node> , cmp1> q;
void dijkstra(LL s) {
	for (LL i = 1; i <= n; ++i) dp[i] = 1e16;
	dp[s] = 0;
	q.push(node(s , 0));
	while(!q.empty()) {
		node now = q.top();
		q.pop();
		LL x = now.v;
		if(vis[x]) continue;
		vis[x] = 1;
		if(now.w >= p[x]._max) continue; // 超过最大时间，不能走
		for (LL i = 0; i < G[x].size(); ++i) {
			if(dp[x] + G[x][i].w < dp[G[x][i].v]) {
				dp[G[x][i].v] = dp[x] + G[x][i].w;
				q.push(node(G[x][i].v , dp[G[x][i].v]));
			}
		}
	}
}
int main() {
	LL s , t , g , q;
	read(n);
	read(r);
	read(s);
	read(t);
	read(g);
	read(q);
	for (LL i = 1; i <= n; ++i) {
		read(p[i].h);read(p[i].l);
		if(q != 0) p[i]._max = (p[i].l - p[i].h + q - 1) / q; // 计算不能通行的时间
		else p[i]._max = 1e9; // 置为任意时刻能通行
	}
	for (LL i = 1; i <= r; ++i) {
		LL x , y , w;
		read(x);read(y);read(w);
		G[x].push_back(node(y , w));
		G[y].push_back(node(x , w));//无向图，双边
	}
	dijkstra(s);
	if(dp[t] > g) printf("wtnap wa kotori no oyatsu desu!"); 
	else printf("%lld" , dp[t]); // 输出答案
	return 0;
}
```

---

## 作者：CloudStroll (赞：0)

这道题是一个标准的最短路模型，不过他有一个限制就是在到达节点i的时候需要判断能否通过该节点，我看见题解中大多数人都是在松弛之前就判断的，可是这样就会有大大小小的坑点，需要判断节点是否为S和T。那么我们不如反过来想，松弛的时候不进行判断，先到达计算dis再说，如果dis乘以Q加上原雪层大于limit，我们就不将其入队就行了，这样会简单很多。而且可以保证正确性，通过该点的出边都是不会经过松弛的（因为不会入队）。

注意数组一定要开够

AC代码


```cpp
#pragma warning (disable:4996)
#include <cctype>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <queue>
#include <vector>
#define run(a,b,c) for(a=b;a<=c;a++)
#define INF 0x3f3f3f3f
using namespace std;
namespace fast
{
    inline int read()
    {
        int num = 0, w = 1; char c = 0;
        while (c != '-' && !isdigit(c)) c = getchar();
        if (c == '-') w = -1, c = getchar();
        while (isdigit(c)) num = num * 10 + c - '0', c = getchar();
        return num * w;
    }

    inline void write(int x)
    {
        if (x < 0) putchar('-'), x = -x;
        if (x / 10) write(x / 10);
        putchar(x % 10 + '0');
    }
}
using namespace fast;

const int MAXN = 1000005, MAXM = 5000005;



struct EDGE
{
    int _next, to, w;
}; EDGE edge[MAXM];

int _count, head[MAXN], dis[MAXN], vis[MAXN], _array[MAXM << 1];
void Add_Line(int a, int b, int c)
{
    _count++;
    edge[_count]._next = head[a];
    edge[_count].to = b;
    edge[_count].w = c;
    head[a] = _count;
}

void _Init()
{
    memset(dis, INF, sizeof(dis));
    memset(vis, false, sizeof(vis));
}

int N, M, S, T, G, Q;
int H[MAXN], L[MAXN];
int main()
{
    _Init();
    N = read();
    M = read();
    S = read();
    T = read();
    G = read();
    Q = read();
    for (int i = 1; i <= N; i++)
    {
        int a, b;
        a = read();
        b = read();
        H[i] = a;
        L[i] = b;
    }
    for (int i = 1; i <= M; i++)
    {
        int a, b, c;
        a = read();
        b = read();
        c = read();
        Add_Line(a, b, c);
        Add_Line(b, a, c);
    }
    dis[S] = 0;
    vis[S] = true;
    int l = 0, r = 1;
    _array[r] = S;
    while(l < r)
    {
        l++;
        int NowNode = _array[l];
        vis[NowNode] = false;
        for (int i = head[NowNode]; i; i = edge[i]._next)
        {
            int NextNode = edge[i].to;
            if (dis[NextNode] > dis[NowNode] + edge[i].w)
            {
                dis[NextNode] = dis[NowNode] + edge[i].w;
                if (!vis[NextNode]&&(H[NextNode]+dis[NextNode]*Q) <= L[NextNode])
                {
                    _array[++r] = NextNode;
                    vis[NextNode] = true;
                }
                if (!vis[NextNode] && NextNode==T)
                {
                    _array[++r] = NextNode;
                    vis[NextNode] = true;
                }
            }
        }
    }
    if (dis[T] <= G)
    {
        printf("%d", dis[T]);
    }
    else
    {
        printf("wtnap wa kotori no oyatsu desu!");
    }
    getchar();
    getchar();
    return 0;
}


```

抱走海未

---

## 作者：UnknownUserAgent (赞：0)

安利一发我的博客：http://www.fankerwang.com/?p=74

先来说一下思路：

- 很容易看出来这是单源最短路的送分（ming）题，移动速度恒为1m/s，所以我们可以把所有时间转化为距离考虑。

- 注意到题目中给出的“如果到达这个地点的时候，这里的雪的高度高于li则会被困在这个点走不出去”，推理得到第 i 个点雪高度高到不能通过的经历时间为 t = ( hi – li ) / q ，转化为能通过点 i 的条件：到达点 i 时已经走过的最大路程为t。

- 然后你RE了40分的点，发现存在不下雪（q=0）的情况，于是加上对q=0的特判。

- 题目中还给出“ことり想在g秒内回到家吃点心，越快越好”，也就是说如果松弛操作时选择走某条路后的总路程大于g，就不需要对这条边进行松弛操作了，因为走这条边肯定得不到正解。

- SPFA一遍后察看目标点距离是否被更新，如果被更新过，更新过的值就是答案。如果没被更新过，说明无法到达终点，输出无解即可。

- 然后你WA了#19，发现不需要考虑终点会不会雪太厚被困住（把我困在家里吧我不想上学(┬＿┬)）。

- 修改终点限制为无穷大，AC了。

- 优化思路：邻接表存边用list的好少，主要是STL很慢...不过这道题还是能过的，list看起来也更优雅对吧...如果用堆优化Dijkstra，但是由于能（wo）过（lan），所以就没用，想看Dijkstra解法的看标程吧。

贴代码：

···cpp





```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<queue>
#include<list>
#include<climits>
using namespace std;
const int MAXN = 100000 + 100;
int lim[MAXN]; //到达每个节点时最大允许已经走过的路程
int dis[MAXN]; //存储源点到每个点的最小距离
int n, m, s, t, g, q;
bool inP[MAXN]; //SPFA中用到，是否在集合P中
struct edge{ int to, length; };
list<edge> edges[MAXN];
void addedge( int u, int v, int w ){ edges[u].push_back( (edge){ v,w } ); }
void spfa(){
    //初始化dis为无穷大
    for( int i=1; i<=n; i++ ) dis[i] = INT_MAX; 
    queue<int> q;
    q.push(s);
    dis[s] = 0;
    inP[s] = true;
    while( !q.empty() ){
        int cur = q.front(); q.pop();
        inP[cur] = false;
        //松弛操作，遍历cur的每条出边
        for( list<edge>::iterator it = edges[cur].begin(); it != edges[cur].end(); it++ )
            //判断松弛操作能否进行的特殊条件
            if( dis[cur] + it->length <= lim[it->to] && dis[cur] + it->length < g )
                //确认可以访问下一个节点，尝试进行松弛操作 
                if( dis[cur] + it->length < dis[it->to] ){
                    dis[it->to] = dis[cur] + it->length;
                    if( !inP[it->to] ) q.push( it->to ) , inP[it->to] = true;
                }
    }
}
int main(){
    scanf( "%d %d %d %d %d %d", &n, &m, &s, &t, &g, &q );
    for( int i=1; i<=n; i++ ){
        int li, hi; scanf( "%d %d", &hi, &li );
        //注意q可能为零，要特判，不然会RE的！
        if( q == 0 ){ lim[i] = li - hi; continue; }
        lim[i] = ( li - hi ) / q;
    } 
    //把终点的雪忽略掉
    lim[t] = INT_MAX; 
    for( int i=1; i<=m; i++ ){
        int tu, tv, tw; scanf( "%d %d %d", &tu, &tv, &tw );
        addedge( tu, tv, tw );
        addedge( tv, tu, tw );
    }
    spfa();
    if( dis[t] == INT_MAX ) //到不了家 
        printf( "wtnap wa kotori no oyatsu desu!\n" );
     else
         printf( "%d\n", dis[t] );
    return 0;
}
```
···
有任何疑问欢迎去我的博客提问（逃


---


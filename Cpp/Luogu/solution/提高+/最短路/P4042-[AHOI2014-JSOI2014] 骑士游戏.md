# [AHOI2014/JSOI2014] 骑士游戏

## 题目背景

长期的宅男生活中，JYY 又挖掘出了一款 RPG 游戏。在这个游戏中 JYY 会扮演一个英勇的骑士，用他手中的长剑去杀死入侵村庄的怪兽。

## 题目描述

在这个游戏中，JYY 一共有两种攻击方式，一种是普通攻击，一种是法术攻击。两种攻击方式都会消耗 JYY 一些体力。采用普通攻击进攻怪兽并不能把怪兽彻底杀死，怪兽的尸体可以变出其他一些新的怪兽，注意一个怪兽可能经过若干次普通攻击后变回一个或更多同样的怪兽；而采用法术攻击则可以彻底将一个怪兽杀死。当然了，一般来说，相比普通攻击，法术攻击会消耗更多的体力值（但由于游戏系统 bug，并不保证这一点）。

游戏世界中一共有 $N$ 种不同的怪兽，分别由 $1$ 到 $N$ 编号，现在 $1$ 号怪兽入侵村庄了，JYY 想知道，最少花费多少体力值才能将所有村庄中的怪兽全部杀死呢？

## 说明/提示

首先用消耗 $4$ 点体力用普通攻击，然后出现的怪兽编号是 $2$，$2$ 和 $3$。花费 $10$ 点体力用法术攻击杀死两个编号为 $2$ 的怪兽。剩下 $3$ 号怪兽花费 $1$ 点体力进行普通攻击。此时村庄里的怪兽编号是 $2$ 和 $4$。最后花费 $11$ 点体力用法术攻击将这两只怪兽彻底杀死。一共花费的体力是 $4+5+5+1+5+6=26$。

对于所有数据 $2 \le N \le 2 \times 10^5$，$1 \le R_i,\sum R_i \le 10^6$，$1 \le K_i,S_i \le 5 \times 10^{14}$。


## 样例 #1

### 输入

```
4
4 27 3 2 3 2
3 5 1 2
1 13 2 4 2
5 6 1 2```

### 输出

```
26```

# 题解

## 作者：Soulist (赞：71)

~~怎么都是Spfa啊~~

~~万一挂了怎么办~~

~~虽然我也不知道这种建模跑spfa到底会怎么样~~

我们考虑记$dp[i]$表示第$i$个怪物被消灭的代价

显然有直接跑$dp$它会有后效性

较为常见的取消$dp$后效性的方法是按照某个值排序

在这道题中就是按照$dp$值排序

我们先考虑$dp$的转移式：

$$dp_i=\min(K_i,S_i+\sum_{j=1}^{R_i}dp_{v_j})$$

于是显然有：

$dp_i$能从第二个式子转移当且仅当对于任意的$dp_{v_j}$有$dp_{v_j}<dp_i$

于是我们对$dp$值建一个堆，令每个点的初始$dp$值为$K_i$，然后每次弹出一个$dp$值令其去更新其他的$dp$值即可

如果被更新的$dp$值已经更新完了，就把它加入堆内即可

如果其需要更新的$dp$值已经被弹出，那么显然有那个$dp$值小于当前$dp$值所以更新无用

复杂度$O(n\log n+\sum R_i)$

```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
using namespace std;
#define rep( i, s, t ) for( register int i = s; i <= t; ++ i )
#define re register
#define int long long
int read() {
	char cc = getchar(); int cn = 0, flus = 1;
	while(cc < '0' || cc > '9') {  if( cc == '-' ) flus = -flus;  cc = getchar();  }
	while(cc >= '0' && cc <= '9')  cn = cn * 10 + cc - '0', cc = getchar();
	return cn * flus;
}
const int N = 2e5 + 5 ; 
const int M = 1e6 + 5 ; 
int n, s[N], K[N], dp[N], vis[N], ans[N], R[N] ;
vector<int> mp[N] ; 
struct node {
	int id, w ; 
	bool operator < ( const node& x ) const {
		return w > x.w ; 
	}
};
priority_queue<node> q ; 
signed main()
{
	n = read() ; int x, siz ; 
	rep( i, 1, n ) 	{
		s[i] = read(), K[i] = read(), R[i] = read() ;
		rep( j, 1, R[i] ) x = read(), mp[x].push_back(i) ; 
		q.push((node){ i, K[i] }), dp[i] = s[i] ;
	}
	while( !q.empty() ) {
		int u = q.top().id, w = q.top().w ; q.pop() ; 
		if( vis[u] ) continue ; 
		vis[u] = 1, ans[u] = w, siz = mp[u].size() - 1 ; 
		rep( i, 0, siz ) {
			int v = mp[u][i] ; 
			if( vis[v] || dp[v] > K[v] ) continue ; 
			R[v] --, dp[v] += w ;
			if( R[v] == 0 ) q.push((node){ v, dp[v] }) ;
		}
	}
	printf("%lld\n", ans[1] ) ;
	return 0;
}
```
~~这个做法的本质和Dij是一样的~~

---

## 作者：D_14134 (赞：49)

## 关于思路：

1.杀死一个魔物有两种方法，让她当场去世和杀死她的所有产物。所以我们只需要比较 膜法 和 普攻+消灭产物 的消耗然后区最少的就够了。

听起来是不是很像dp，但是！ 这题可能有正环并不满足有后效性原则。

那么我们就换条思路，我们假设杀死 ** a ** 会产生 **b** 和 **c** ,那么就很容易看出 **a** 到 **b**， **a** 到 **c** 之间可以连一条边。

现在我们就来讨论一下怎么杀死魔物**：**

对单个魔物 **a** 比较 魔法（a） 和 普攻（a） 即可

对路径 a->b 比较 魔法（a）和 普攻（a）+min（魔法（b），普攻（b））

现在我们就很明显的看出了，这就很像spfa的松弛操作。我们开始考虑spfa跑最短路的做法。

但问题在于，当我们在使用“最短路径”来解决题目的时候，一般都是已知起点，终点。然后再去跑spfa，寻找这个值的大小。这道问题却是你只知道起点，路上的任何一个地方都有可能是终点，也有可能不是终点。 其次，我们要求的也不是最短路径，而是简单的 消灭1号魔物的开销大 还是 消灭她和她的产物开销大。

从某种意义上而言，我们需要递归寻找。单可以看出其中的记忆性，动态规划的思想。如果我们从这个图最外面开始看起，一层一层往里计算消灭怪物的开销，自然而然题目就解决了

但是，与普通简单DP不同的是，可能有环的存在
但事实上似乎并不用担心。不妨令每个点的初值都等于 魔法击杀的消耗 ，在spfa计算过程中，边的松弛都是依靠距离的。自然，正环的产生必定会大于最短距离，有得保证。

凭什么保证你从这个点开始计算一定是最优的？答案是不能保证！所以不如干脆就把所有点一开始就放在队列里。 

那么怎么保证队列的顺序一定能出最优解？不能保证！所以不如干脆每次一旦更新成功，就把父节点再次入队列（只可能有一个父节点）。

### 以上。


------------

# code

```
#include<queue>
#include<vector>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define maxn 201000
#define inf 0x3f3f3f3f
#define int long long
#define IN inline
#define re register
using namespace std;
int a[maxn],dis[maxn],vis[maxn]; 
int n;
vector<int> head[maxn],to[maxn];
IN int read(){
    int x=0,sign=1;
    char c=getchar();
    while(c>'9'||c<'0'){
        if(c=='-') sign=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=x*10+c-'0';
        c=getchar();
    }
    return x*sign;
}
IN void add(int u ,int v){head[u].push_back(v);to[v].push_back(u);}
IN void spfa(){
	queue<int> q;
	for(re int i=1;i<=n;++i) q.push(i),vis[i]=1;
	while(!q.empty()){
		int u=q.front();q.pop();vis[u]=0;
		long long temp=a[u];
		for(re int i=0;i<head[u].size();++i) temp+=dis[head[u][i]];
		if(temp>=dis[u]) continue;
		dis[u]=temp;
		for(re int i=0;i<to[u].size();++i){
			if(!vis[to[u][i]]){
				vis[to[u][i]]=1;
				q.push(to[u][i]);
			}
		}
	}
}
signed main(){
	n=read();
	int x=0;
	for(re int i=1;i<=n;++i){
		int num=0;
		a[i]=read(),dis[i]=read(),x=read();
		while(x--){
			num=read();
			add(i,num);
		}
	}
	spfa();
	printf("%lld",dis[1]);
	return 0;
}
```

---

## 作者：寒鸽儿 (赞：40)

### 这道题是一道spfa变形题，具体考察对spfa的深入理解
spfa本身是对Bellman-ford算法的优化。在Bellman-Ford算法中，n轮扫描每一条边看一看各个点有没有希望被松弛。  
spfa之所以能用来处理Bellman-ford并进行优化，其原因是在Bellman-ford中，每一轮扫描的边有很多都没有可能更新其它点。spfa指出，当一条边有希望更新它的一个端点的最短路值，当且仅当它的另一个端点的最短路值被更新过。spfa使用一个队列保留这些**可能被更新的信息**，通常，spfa在队列中保存的更新信息的意义是"**这个点被更新过，因而有可能通过与它连接的边更新这些边的其它端点**"。直到队列为空，此局面表示"**没有一个结点可能更新其它的结点**"。  
这样保存更新信息的原因是因为，在**通常情况**下，一个点可以通过与它相连的边更新其它点，每一个结点的更新则是可能由多个通过边连向它的结点决定，即**一对多的更新**。即因而我们保存的信息是"可能更新其他多个点的点"而不是"可能被其他点更新的点"因为这样做更方便。(想一想，用前者则出队一个结点扫描更新可以将所有由此结点被更新造成的可能被更新的结点的改变情况全部解决，而对于后者，一个结点的更新将所有连向它的结点入队，则当这些结点出队的时候，需要扫描它的所有前驱来决定结果，后者的复杂度显然比前者高很多，相当于n^2和n的区别)。  
为了方便，约定若一个魔头物理攻击打出若干魔头，则前者成为后者的父魔头，后者成为前者的子魔头。约定某个点(或魔头)的取值是杀死该点对应魔头所需花费的目前最优代价。约定某魔头的魔杀值为用魔法攻击杀死该魔头的魔法攻击的消耗。  
在本题中，一个点(父魔头)的取值(即杀死最优解)取决于多个点(子魔头)的取值，也就是唯一一组确定的子魔头(和其父魔头的魔杀一起)决定了其父魔头的击杀取值，即**多对一的关系**。因而要保留**更新信息**，用保留"有希望被它对应的子魔头组更新的魔头"(即第三段中说的第二种保留方式)的方式显然更方便。  
具体地，我们对于每一个可能被更新的点扫描其所有子魔头的取值相加再加上其物理攻击看看能否更新，若能更新，则将其所有的父魔头入队表示它们也有希望被更新。
我们可以看到，本题考查对spfa本质的理解，即用"可能被更新的信息"优化处理。而设计可能被更新的信息的保存方式是本题设计的重点。  
本题中还有一些细节需要注意，例如，在开始spfa时我们将全部的结点赋值为它们的魔杀值。你可以将之理解为，在开始局面下，所有的结点均有希望被更新。(只是有希望。在这里提到的有无希望的判定就像是A*算法中的估价函数那样，在开局状态下我们没有更多的信息，因而将所有结点"估"成有希望，为了保证正确性)。也可以理解为，在开始的那一瞬间，它们原来的取值是inf，然后均被更新为其魔杀值，因而这些(即所有点)的后继均有可能被更新，假设图联通，那么所有点的后继构成的集合应当包含所有点(不连通则包含部分点，依然对正确性没有什么干扰)。  
温馨提示：十年OI一场空，不开long long见祖宗。  
最后附上代码
```cpp
#include <cstdio>
#include <cstring>
#include <queue>

using namespace std;

long long pa[200010], d[200010];
int head[200100], ver[1000010], nex[1000010], hf[200010], vf[1000010], nf[1000010], inq[200010], tot, tt, n;

queue<int> q;

inline void add(int u, int v) {
    ver[tot] = v; nex[tot] = head[u]; head[u] = tot++;
}

inline void addf(int u, int v) {
    vf[tt] = v; nf[tt] = hf[u]; hf[u] = tt++;
}

void spfa() {
    for(int i = 1; i <= n; i++) q.push(i);
    memset(inq, 1, sizeof(inq));
    while(!q.empty()) {
        int cur = q.front(); q.pop(); inq[cur] = 0;
        long long rs = pa[cur];
        for(int i = head[cur]; i != -1; i = nex[i]) rs += d[ver[i]];
        if(d[cur] > rs) {
            d[cur] = rs;
            for(int i = hf[cur]; i != -1; i = nf[i])
                if(!inq[vf[i]]) inq[vf[i]] = 1, q.push(vf[i]);
        }
    }
}

int main() {
    int r, mos;
    long long s, k;
    scanf("%d", &n);
    memset(head, -1, sizeof(head)); memset(hf, -1, sizeof(hf));
    for(int i = 1; i <= n; i++) {
        scanf("%lld %lld %d", &s, &k, &r);
        d[i] = k; pa[i] = s;
        while(r--) {
            scanf("%d", &mos);
            add(i, mos); addf(mos, i);
        }
    }
    spfa();
    printf("%lld\n", d[1]);
    return 0;
}
```
欢迎互相关注(然而在oi界蒟蒻的圈很小)。  
最后安利一下[蒟蒻的洛谷博客](https://www.luogu.org/blog/oldherd/)

---

## 作者：lyyi2003 (赞：19)

这里讲一个复杂度只有$O(nlogn+\sum r_i)$的$dijkstra$做法

也就是说这题$\sum r_i$可以出到$10^7$，~~而且可以卡掉spfa~~

有人要说$dijkstra$复杂度不是$O(mlogm)$的吗？但是这题我的做法每个点只会入队$O(1)$次，所以$m$是不带$log$的，具体原因往下看。


首先大家要弄懂这题spfa做法的松弛过程（可以参考其它题解），然后我们可以发现这个松弛过程是满足贪心性质的。具体来说，如果一个点在当前所有还在被松弛的点中是最小的，那么它一定不会再被松弛了，它的值就可以直接确定下来（可以类比$dijkstra$最短路过程）。


而且我们还可以发现一个性质，在不考虑法术攻击的情况下，一个点的值只会在它的出边（即打死它会变出的所有怪兽）都被确定下来后才会被确定，因为它的值一定大于它的所有出边的值。那么我们就可以在它的所有出边都确定后再把它放入堆中，这样每个点就只会入堆一次了。


另外我们还要把对每一个点使用法术攻击消耗的体力值作为dis的初始值，一开始把每个点都加入堆中。


讲得可能不清楚，具体可以看代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 200007
#define M 2000007
#define ll long long
const ll inf=1e18;
int hd[N],pre[M],to[M],num,deg[N];
ll dis[N],sum[N];
struct str
{
	int v;
	ll d;
};
bool operator <(str a,str b)
{
	return a.d>b.d;
}
priority_queue<str> q;
bool vis[N];
void dijs()
{
	while(!q.empty())
	{
		int v=q.top().v;q.pop();
		if(vis[v])continue;
		vis[v]=1;
		for(int i=hd[v];i;i=pre[i])
		{
			int u=to[i];
			deg[u]--;
			sum[u]=min(inf,sum[u]+dis[v]);
			if(!deg[u])
			{
				if(sum[u]<dis[u])
				{
					dis[u]=sum[u];
					q.push({u,dis[u]});
				}
			}
		}
	}
}
void adde(int x,int y)
{
	num++;pre[num]=hd[x];hd[x]=num;to[num]=y;
}
int main()
{
	//freopen("data.in","r",stdin);
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		int m,x;
		scanf("%lld%lld%d",&sum[i],&dis[i],&m); 
		q.push({i,dis[i]}); 
		deg[i]=m;
		for(int j=1;j<=m;j++)
		{
			scanf("%d",&x);
			adde(x,i);
		}
	}
	dijs();
	printf("%lld\n",dis[1]);
	return 0;
}
```



---

## 作者：hsfzLZH1 (赞：14)

## 题目大意

有 $n$ 种怪兽，每种怪兽可以用普攻打死，代价为 $s_i$ ，死后会产生 $r_i$ 个怪兽，种类给定；也可用法术打死，代价为 $k_i$ ，死后不产生怪兽。一开始只有一只编号为 $1$ 的怪兽，求消灭所有怪兽的最小代价。

$2\le n\le 2\times 10^5,1\le r_i,\sum r_i\le 10^6,1\le k_i,s_i\le 5\times 10^{14}$

## 解题思路

~~用 SPFA 的真的不怕被卡吗？~~

~~用 SPFA 的题解里没有一个敢分析复杂度的~~

有一个真正的最短路做法，时间复杂度为 $O(\sum r_i \log_2 n)$ 。

击败单个某种怪物有两种办法：一种是直接用法术杀死，代价为 $k_i$ ；一种是用普攻杀死，最小代价为 $s_i$ 加上击败死后产生的怪物的代价和。在第二种情况中，击败死后产生的怪物是 **后置条件** 。

Dijkstra 算法建立在没有负权边的图上。初始时只有源点在已知集合中，每次找到不在已知集合中到源点距离最小的点，将其加入已知集合，更新其出边。

本题中 $s_i,k_i>0$ ，考虑用 Dijkstra 算法计算出击败每种怪物的最小代价。考虑到后置条件不好处理，可以将后置条件改为 **先决条件** 。

类比 Dijkstra 算法，每次我们将使用法术与使用普攻两种的最小代价比较，选取代价更小的加入已知集合。知道普攻的代价，当且仅当知道所有先决条件的代价。当不知道一个怪物的先决条件的代价时，由于 $s_i>0$ ，用普攻杀死当前怪物的代价一定大于击杀某个先决条件的代价，不满足 Dijkstra 的流程。

比较使用普攻杀死怪物，要有两个关键字，一个是是否剩余位置的先决条件，一个是已知的先决条件的代价和加上 $s_i$ 。每次我们找到在关键字条件下最优的怪物，将杀死该怪物的代价设为 $s_i$ 加先决条件和 $k_i$ 的最小值，更新所有出边。如果最优的怪物仍有未知的先决条件，则选择当前 $k_i$ 最最小的怪物，将该怪物的代价设为 $k_i$ ，再更新所有出边。

更新 $x$ 的所有出边时，更新的是以 $x$ 为先决条件的所有的点。若 $x$ 为 $y$ 的先决条件，更新时令 $y$ 剩余的未知先决条件 $-1$ ，已知条件的和 $+dist[x]$ 。

现在要实现一个数据结构，实现以下操作：

1.  更新 **任意** 一个元素的值；

2.  找到值最小的元素；

3.  删除值最小的元素。


此时普通的堆无法胜任，可以使用左偏树或平衡树实现，单次以上操作时间复杂度 $O(\log_2 n)$ 。

由于每个点只会被加入已知集合一次，每个先决条件只会被更新一次，所以此算法的时间复杂度为 $O(\sum r_i \log_2 n)$ 。

## 参考实现

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;
#define int long long 
const int maxn=200010;
const int maxm=2000010;
int n,v,r,a,cur,h[maxm],nxt[maxm],p[maxm],dist[maxn],rnk[maxn];
bool tf[maxn];
void add_edge(int x,int y)
{
	cur++;
	nxt[cur]=h[x];
	h[x]=cur;
	p[cur]=y;
}
struct node
{
	int id,k;
	bool operator<(node x){return k<x.k;}
}s[maxn];
struct Leftist_Tree
{
	struct node2
	{
		int id,sum,res;
		bool operator<(node2 x){return res==x.res?sum<x.sum:res<x.res;}
	}q[maxn];
	int rt,fa[maxn],lc[maxn],rc[maxn],dist[maxn];
	void pushup(int x)
	{
		if(!x)return;
		if(dist[lc[x]]<dist[rc[x]])swap(lc[x],rc[x]),dist[x]=dist[rc[x]]+1,pushup(fa[x]);
		dist[x]=dist[rc[x]]+1;
	}
	int merge(int x,int y)
	{
		if(!x||!y)return x+y;
		if(q[y]<q[x])swap(x,y);
		rc[x]=merge(rc[x],y);fa[rc[x]]=x;
		if(dist[lc[x]]<dist[rc[x]])swap(lc[x],rc[x]);
		dist[x]=dist[rc[x]]+1;
		return x;
	}
	void delt(int x)
	{
		if(x==rt)rt=merge(lc[x],rc[x]),fa[rt]=0,lc[x]=rc[x]=dist[x]=0;
		else
		{
			int t=fa[x];
			if(x==lc[t])lc[t]=merge(lc[x],rc[x]),fa[lc[t]]=t;
			else rc[t]=merge(lc[x],rc[x]),fa[rc[t]]=t;
			pushup(t);
			lc[x]=rc[x]=dist[x]=0;
		}
	}
}st;
main()
{
	st.dist[0]=-1;
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%lld%lld%lld",&v,&s[i].k,&r);s[i].id=i;
		st.q[i]={i,v,r};st.rt=st.merge(st.rt,i);st.fa[st.rt]=0;
		while(r--)scanf("%lld",&a),add_edge(a,i);
	}
	sort(s+1,s+n+1);
	for(int i=1;i<=n;i++)rnk[s[i].id]=i;
	for(int i=1;i<=n;i++)if(!tf[s[i].id])
	{
		dist[s[i].id]=s[i].k;tf[s[i].id]=true;st.delt(s[i].id);
		for(int j=h[s[i].id];j;j=nxt[j])if(!tf[p[j]])
		{
			st.delt(p[j]);
			st.q[p[j]].res--;
			if(st.q[p[j]].sum<=s[rnk[p[j]]].k)st.q[p[j]].sum+=dist[s[i].id];
			st.rt=st.merge(st.rt,p[j]);st.fa[st.rt]=0;
		}
		while(1)
		{
			int minn=st.rt;
			if(minn==0||st.q[minn].res)break;
			dist[minn]=min(s[rnk[minn]].k,st.q[minn].sum);tf[minn]=true;st.delt(minn);
			for(int j=h[minn];j;j=nxt[j])if(!tf[p[j]])
			{
				st.delt(p[j]);
				st.q[p[j]].res--;
				if(st.q[p[j]].sum<=s[rnk[p[j]]].k)st.q[p[j]].sum+=dist[minn];
				st.rt=st.merge(st.rt,p[j]);st.fa[st.rt]=0;
			}
		}
	}
	printf("%lld\n",dist[1]);
	return 0;
}
```

---

## 作者：双管荧光灯 (赞：13)

这题看似DP可做，然而可能有环，有后效性

设消灭第i个怪物最少花费$d[i]$的魔力，则$d[i]=\max(k[i],s[i]+\sum d[r[i][j]])$;

(像不像最短路的松弛操作?)

因此，我们可以参考Dijkstra算法，将$d[i]$赋初值为$k[i]$存入堆中，然后每次取最小值，把它会影响到的$d[i]$全部进行“松弛操作”

然而，光这样做不仅会TLE，还会WA

TLE因为松弛是$O(n)$的，总复杂度为$O(n^2logn)$

不知怎么，如果把搜过的直接continue，会WA几个点，只好把Dijkstra换成SPFA+堆优化，又慢了很多

所以，要加几个小优化：

1. $d[i]$改一次就要松弛一次，太慢，我们可以学习拓扑排序，将出度记下，等某一结点指向的所有$d$都达到最小再松弛

2. 虽不能用Dijkstra但是可以判断堆中是否存的是最优解，如果不是，可以continue

Code:
```cpp
#include<stdio.h>
#include<queue>
#include<iostream>
using namespace std;
const int N=200005;
int n,head[N],Next[1000005],adj[1000005],m,i,p,j,v,rhead[N],rNext[1000005],radj[1000005],point[N],vis[N];
long long s[N],d[N];
struct str{
    int d,p;
};
priority_queue<str> q;
bool operator <(str a,str b)
{
    return a.d>b.d;
}
void Push(int u,int v)
{
    Next[++p]=head[u];
    head[u]=p;
    adj[p]=v;
    rNext[p]=rhead[v];
    rhead[v]=p;
    radj[p]=u;
}
int main()
{
    scanf("%d",&n);
    for(i=1;i<=n;i++)
    {
        scanf("%lld %lld %d",&s[i],&d[i],&m);
        for(j=1;j<=m;j++)
        {
            scanf("%d",&v);
            Push(i,v);
        }
        point[i]=m;
        q.push((str){d[i],i});
    }
    while(!q.empty())
    {
        str x=q.top();
        q.pop();
        if(x.d>d[x.p])
            continue;
        for(i=rhead[x.p];i!=0;i=rNext[i])
        {
            int t=radj[i];
            if(vis[x.p]==0)
                point[t]--;
            if(point[t]<=0)
            {
                long long su=s[t];
                for(j=head[t];j!=0;j=Next[j])
                    su+=d[adj[j]];
                if(d[t]>su)
                {
                    d[t]=su;
                    q.push((str){d[t],t});
                }
            }
        }
        vis[x.p]=0;
    }
    printf("%lld",d[1]);
}
```

UPD：

现在看这个代码感觉当时好simple啊~~~

以下是真做法：

我们枚举法术值最小的，显然我们一定用法术去干掉

我们维护一个堆，每次我们确定一个怪兽要杀死它的最小体力值之后，我们用它去松弛所有用普通攻击后可以分裂出它的怪兽

这样我们每次取出堆中的最小值，显然它的值就是它的真实值

这样复杂度严格$O(nlogn)$

---

## 作者：zl_just (赞：4)

### 前言
首先从$DP$角度分析这题, 用$d[i]$表示杀死怪物$i$所需的最低花费, $k[i]$为膜法杀死$i$所需的花费, $s[i]$为站撸所需的花费, $e[i][j]$为撸死怪物$i$后产生的第$j$个怪物, 那么我们有状态转移方程  
$d[i]=min(k[i],s[i]+\displaystyle \sum^{R[i]}_{j=1}{d[e[i][j]]})$  
但是这样做有一个明显的$Bug$，万一撸死的怪物又能直接(或间接)产生它自身，递归就会陷入死循环，也就是有环，无法用$DP$解决  
于是你~~不小心~~地点开了算法标签，满脸懵逼的你看见了$SPFA$, 于是尝试开始建模，可怎么也想不到该怎么连边，该怎么跑最短路
~~好吧，这其实是我的经历~~

### 正言
```
  (SPFA)多见于最大(小)问题中,在求解是会发现存在环,其模型是带环的图.其特点是节点间没有相互依赖关系,而且其最优值的传递不会产生后效性,大都满足最原始的三角不等式.因此我们可以使用类似的最短路的方法通过较优解之间的相互比较,相互跟新来得出全部节点的最优解
                                     --<<一本通>>
```
好了,相信有了这句话,聪明的你就一定可以解决$Ta$了 

---
**当我们更新$i$时,我们也应该将撸死后能产生$i$的怪物塞入队列中进行更新,因为其父节点可能会受影响被更新，所以应该反向建边，如此迭代后，就能得到最优解**  
不懂的话详见$code$

```cpp
#include<cstdio>
#include<queue>
using namespace std;

const int maxn = 200000 + 10;
const int maxm = 1000000 + 10;
int n;

struct edge {
    int v,next;
}e[maxm],fe[maxm];
//f前缀代表反向边相关

int head[maxn],fhead[maxn];
long long d[maxn],s[maxn];
bool inp[maxn];
int en,fen;

inline void add(int u,int v) {
    e[++en].next=head[u];
    e[en].v=v; head[u]=en;
}

inline void fadd(int u,int v) {
    fe[++fen].next=fhead[u];
    fe[fen].v=v; fhead[u]=fen;
}

queue<int>q;
long long SPFA() {
    for(int i=1;i<=n;i++) q.push(i);
    //先全部塞入队列,初始值为膜法费用
    //通过比较得到较优解,直至最优解
    while(!q.empty()) {
        int u=q.front(); q.pop();
        inp[u]=true;
        long long res=s[u];
        for(int i=head[u];i;i=e[i].next)
            res+=d[e[i].v];
        if(res<d[u]) {
        //比较子节点与自身的费用
            d[u]=res;
            for(int i=fhead[u];i;i=fe[i].next) if(inp[fe[i].v]) {
            //将其父节点塞入队列再更新
                q.push(fe[i].v); inp[fe[i].v]=false;
            }
        }
    }
    return d[1];
    //d[i]就表示完全杀死一只i的最低费用
}

template<typename T>
inline void read(T &a) {
    int c; a=0;
    while((a=getchar()-'0')) if(a>=0&&a<=9) break;
    while((c=getchar())) {
        if(c<'0'||c>'9') break;
        a=(a<<3)+(a<<1)+c-'0';
    }
}

int main() {
    int r,v;
    read(n);
    for(int i=1;i<=n;i++) {
        read(s[i]); read(d[i]); read(r);
        for(int j=0;j<r;j++) {
            read(v); add(i,v); fadd(v,i);
        }
    }
    printf("%lld\n",SPFA());
    return 0;
}
```


---

## 作者：asuldb (赞：3)

[题目](https://www.luogu.org/problem/P4042)

思博贪心题写了一个半小时没救了，我也没看出这是一个$spfa$来啊

设$dp_i$表示彻底干掉第$i$只怪物的最小花费，一个非常显然的事情，就是对于$k_i$值最小的怪物满足$dp_i=k_i$

非常好理解，反正到最后都要干掉这个怪物，何必再把它干成别的怪物

于是我们按照$k_i$的值先排序一下，另外维护一个小根堆

如果堆里没有点或者堆顶的$dp$值比当前的$k$要大，我们直接令当前当前$k_i$值最小的点$i$的$dp_i=k_i$，之后遍历所有能到达点$i$的点$v$，令$s_v+=dp_i$，如果发现点$v$的所有出边都被遍历了一遍，我们就令$dp_v=\min(s_v,k_v)$，同时把这个点加入堆中

如果堆里有点且堆顶的$dp$小于于当前$k$，就直接拿堆顶来更新

考虑这个做法的正确性，显然当前堆中没有节点的时候，图中任意一个点不可能只分解成已经处理好$dp_i$的点，于是我们必须引入剩下的$k$值最小的点

或者把堆中没有点的情况视为初始情况，可能这样更好理解

代码

```cpp
#include <bits/stdc++.h>
#define re register
#define LL long long
#define mp std::make_pair
#define min(a, b) ((a) < (b) ? (a) : (b))
const int maxn = 2e5 + 5;
struct E {
    int v, nxt;
} e[1000005];
LL dp[maxn], s[maxn], w[maxn];
int head[maxn], vis[maxn], c[maxn], p[maxn];
int n, num, top;
inline LL read() {
    LL x = 0;
    char c = getchar();
    while (c < '0' || c > '9') c = getchar();
    while (c >= '0' && c <= '9') x = (x << 3ll) + (x << 1ll) + c - 48, c = getchar();
    return x;
}
typedef std::pair<LL, int> pii;
std::priority_queue<pii, std::vector<pii>, std::greater<pii> > q;
inline int cmp(int a, int b) { return s[a] < s[b]; }
inline void del(int x) {
    vis[x] = 1;
    for (re int i = head[x]; i; i = e[i].nxt) {
        if (vis[e[i].v])
            continue;
        w[e[i].v] += dp[x];
        c[e[i].v]--;
        if (!c[e[i].v])
            vis[e[i].v] = 1, dp[e[i].v] = min(w[e[i].v], s[e[i].v]), q.push(mp(dp[e[i].v], e[i].v));
    }
}
inline void add(int x, int y) {
    e[++num].v = y;
    e[num].nxt = head[x];
    head[x] = num;
}
int main() {
    n = read();
    for (re int x, i = 1; i <= n; i++) {
        w[i] = read(), s[i] = read(), c[i] = read();
        for (re int j = 1; j <= c[i]; j++) x = read(), add(x, i);
    }
    for (re int i = 1; i <= n; i++) p[i] = i;
    std::sort(p + 1, p + n + 1, cmp);
    int now = 1, tot = 0;
    while (tot < n) {
        while (vis[p[now]]) ++now;
        if (!q.empty() && (q.top().first < s[p[now]] || now > n))
            tot++, del(q.top().second), q.pop();
        else
            tot++, dp[p[now]] = s[p[now]], del(p[now++]);
    }
    printf("%lld\n", dp[1]);
    return 0;
}

```


---

## 作者：物灵 (赞：3)

> [骑士游戏](https://www.luogu.org/problemnew/show/P4042) 有 $n$ 种怪兽。每种怪兽普通攻击或法术攻击需若干体力。法术攻击会彻底杀死怪兽，普通攻击会使得怪兽变成另几种怪兽（可能有环，甚至可能自环）。现有一只 1 号怪兽，输出彻底杀死怪兽的最小体力。

**最短路。**明显的图论问题，~~虽然首次看到此题时刚学完语法，然后 TLE + RE~~。

可以用 Dijkstra，由于每个点影响入度，更新时扫一遍逆图逐个更新。此处**不能保证初次出堆已最优**，因此不能只出堆一次。为避免堆内重复元素重复处理，我们记录入堆权值，若出堆元素之入堆权值非其当前最优权值，则跳过。一个节点之每个出度都会使节点更新一次，为减少更新次数，我们记录 `wiat[i]` 数组（`wait` 貌似是关键字）代表能更新节点 `i` 之最后节点，等到 `wiat[i]` 点出堆时再更新 `i`。

以下代码，由于罹患 STL 依赖症，只能吸氧。手写数构会比较快。

``` c++
// luogu-judger-enable-o2
#include <cstdio>
#include <utility>
#include <functional>
#include <algorithm>
#include <queue>
#include <vector>
#define Add push_back
#define Pad(a, b) push(std::make_pair(a, b))

typedef long long int LINT;
typedef std::pair<LINT, int> PLI;
const int MAXN = 200001;
int n, wiat[MAXN]; LINT s[MAXN], k[MAXN];
std::vector<int> g1[MAXN], g2[MAXN];
std::priority_queue<PLI, std::vector<PLI>, std::greater<PLI> > q;

int main() {
  scanf("%d", &n);
  for(int i = 1; i <= n; i++) {
    int r, ip; scanf("%lld%lld%d", s + i, k + i, &r);
    q.Pad(k[i], i);
    while(r--) { scanf("%d", &ip); g1[i].Add(ip); g2[ip].Add(i); }
  }

  while(!q.empty()) {
    LINT tr = q.top().first; int cur = q.top().second; q.pop();
    if(tr > k[cur]) continue;
    for(auto i: g2[cur]) if(!wiat[i] || wiat[i] == cur) {
      LINT now = s[i]; for(auto j: g1[i]) now += k[j];
      if(now < k[i]) {
        k[i] = now, q.Pad(now, i);
        for(auto j: g2[i]) wiat[j] = i;
      }
    }
  }

  printf("%lld\n", k[1]);
  return 0;
}
```

---

## 作者：loceaner (赞：1)

## 题意


有$n$个怪物，可以消耗$k$的代价消灭一个怪物或者消耗$s$的代价将它变成另外一个或多个新的怪物，求消灭怪物$1$的最小代价


## 思路


这几天做的第一道自己能yy出来的题……

看起来像是个DP，认真思考一会儿也不难想到可以设计如下状态

设$f[i]$为消灭$i$所需的最小代价，那么有

$$f[i]=\min(f[i], s[i]+\sum\limits_{to_i} f[to_i])$$

其中$to$表示$i$点的后继

因为$f$的转移之间相互干涉，所以用最短路处理

先建双向边，方便之后转移，然后用$\texttt{SPFA}$（~~它死了~~求"多源"最短路就好了

因为不知道一开始应该打哪个怪物，所以干脆全都入队、全部更新就好了

$ps:$两年$\text{OI}$一场空，不开$long\ long$见祖宗

## 代码

```cpp
/*
Author:Loceaner
*/
#include <queue>
#include <cmath>
#include <vector>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define int long long
using namespace std;

const int A = 2e5 + 11;
const int B = 1e6 + 11;
const int mod = 1e9 + 7;
const int inf = 0x3f3f3f3f;

inline int read() {
  char c = getchar(); int x = 0, f = 1;
  for ( ; !isdigit(c); c = getchar()) if (c == '-') f = -1;
  for ( ; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);
  return x * f;
}

queue <int> Q;
vector <int> v1[A], v2[A];
int n, m, ord[A], mag[A]/*题目中所给的s[i],k[i]*/, vis[A];

inline void ZDL() {
  for (int i = 1; i <= n; i++) Q.push(i), vis[i] = 1;
  while (!Q.empty()) {
    int x = Q.front(); Q.pop(), vis[x] = 0;
    int res = ord[x];
    for (int i = 0; i < (int)v1[x].size(); i++) res += mag[v1[x][i]];
    if (res < mag[x]) {
      mag[x] = res;
      for (int i = 0; i < (int)v2[x].size(); i++)
        if (!vis[v2[x][i]]) Q.push(v2[x][i]), vis[v2[x][i]] = 1;
    }
  }
}

signed main() {
  n = read();
  for (int i = 1, k; i <= n; i++) {
    ord[i] = read(), mag[i] = read(), k = read();
    while (k--) {
      int x = read();
      v1[i].push_back(x), v2[x].push_back(i);
    }
  }
  ZDL();
  cout << mag[1] << '\n';
  return 0;
}
```



---

## 作者：紫薯布丁 (赞：1)

## 这道题用到了spfa的思想

~~但其实并不能算是spfa~~



大体思路是这样的：

1：对于从一号节点，我们把他压入栈，然后该节点普通攻击和1号节点能到达点法术伤害的权值总和去更新dis[i]的值。

2：如果更新了，我们就应当去想：该节点的权值更新之后能到达该节点的节点显然答案也会进行更新，此时我们就把这些能到达该节点的节点压入栈进行更新。
3：反复更新，直到该节点的值不能继续更新为止。

 对于该节点能到达的的点，我们用邻接表存图即可实现。
 对于到达该节点的点1，我们开另一个邻接表反向建边即可实现
 
那么这样就结束了吗？

显然并没有，这样会妥妥wa掉。
为什么?我们来看这组数据
```cpp
4
4 27 3 2 3 2
3 5 1 2
1 99999 2 4 2
5 6 1 2
```
~~（当时我用这组数据把自己hack掉了，非常自闭）~~ 

我们模拟一下上述过程就可以发现当一号节点更新到三号节点时，不会再继续更新，因为三号节点的法术伤害过高，之后并没有节点被三号节点更新。


我们发现上述过程并没有考虑到所有的情况 。

那么怎么解决这个问题呢，我们可以把所有的节点压入一个栈里，每次取出一个更新答案。
这样就不会漏掉所有的情况。 

我们惊奇的发现即使我们都压到一个栈里并不会引发冲突，因为每次更新之后全局dis[i]都会随之更新
### 所以我们开一个栈，开始把所有节点全部压入栈中，定义dis【i】的初始值为该节点的法术伤害，依次按照上述方法进行更新即可。

当然要注意开long long
附代码 
```cpp
#include<iostream>
#include<cstdio>
#include<stack>
#include<queue>
#define int long long
#define ss 1000600
using namespace std;
inline int read(){
	int x(0),f(1);char c(getchar());
	for(;!isdigit(c);c=getchar()) c=='-'?f=-1:1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0';
	return x*f;
}

struct  oo{
	int next,to;
}e[ss*4],e2[ss];

int head[ss],cnt(0),dis[ss],head2[ss],cnt2(0),a[ss],n;
bool b[ss];

void add(int x,int y){
	e[++cnt].to=y;
	e[cnt].next=head[x];
    head[x]=cnt;
}

void add2(int x,int y){
	e2[++cnt2].to=y;
	e2[cnt2].next=head2[x];
	head2[x]=cnt2;
}


void spfa(){
	stack<int >q;
	for(register int i=1;i<=n;i++) q.push(i),b[i]=1;
	while(q.size()){
		int u(q.top());
		q.pop();
		int diss(0);b[u]=0;
		for(register int i=head[u];i;i=e[i].next) diss+=dis[e[i].to];
		diss+=a[u];
		if(dis[u]<=diss) continue;
		dis[u]=diss;
		for(register int i=head2[u];i;i=e2[i].next){
			int y=e2[i].to;
			//printf("%d %d\n",u,y);
			if(b[y]) continue;
			b[y]=1;q.push(y);
		}
	}
}


main(){
	n=(read());
	for(register int i=1;i<=n;i++){
		a[i]=read();dis[i]=read();
		int x(read());
		while(x--){
			int y=read();
			add(i,y);
			add2(y,i);
		}
	}
	
	
	spfa();
	
	
	printf("%lld\n",dis[1]);
	
	
}
```



---

## 作者：MikukuOvO (赞：1)

[题目大意](https://www.luogu.org/problemnew/show/P4042)

我们定义dis[i]代表完全杀死i号怪兽的最小体力值花费，那么初始值都是法术攻击的花费。

那么动态转移方程就是：dis[i]=min(magic[i],common[i]+∑son:(dis[i]))

但是我们会发现直接搞dp的话是有后效性的，比如：1-->2-->1那么就会陷入死循环

但是我们惊奇的发现这个好像和SPFA的松弛操作有一些相像，所以我们改变思路，跑一遍SPFA

由于从起点开始跑等于直接比较儿子节点的魔法费用，显然是错误的，所以将所有点全部压入队列中进行考虑

并且如果一个节点的儿子节点被考虑过之后，父节点也会受影响，所以也要重新决策一次

时间复杂度可以看作是SPFA的复杂度上加一个小常数，具体不会证，注意常数优化

最后，附上本题代码：（自动省略头文件）

```cpp
il LL read()
{
    reg LL w=0;
    char ch=getchar();
    while(ch<'0'||ch>'9') ch=getchar();
    while(ch>='0'&&ch<='9') 
    {
        w=(w<<3)+(w<<1)+ch-'0';
        ch=getchar();
    }
    return w;
}
struct EDGE
{
    int to,nxt;
};
EDGE edge[maxm+5],rev[maxm + 5];
int n,cnt;
LL dis[maxn+5],c[maxn+5];
int head[maxn+5];
bool vis[maxn+5];
queue<int>q;

il void add(int x,int y)
{
    edge[++cnt].to=y;
    edge[cnt].nxt=head[x];
    head[x]=cnt;
}
int fir[maxn + 5],alloc;
il void addrev(int u,int v)
{
    rev[++alloc].nxt = fir[u];
    fir[u] = alloc;
    rev[alloc].to = v;
}
il void SPFA()
{
    UF(i,1,n) q.push(i),vis[i]=1;
    while(!q.empty())
    {
        reg int s=q.front();
        reg LL res=c[s];
        vis[s]=0,q.pop();
        for(reg int i=head[s]; i; i=edge[i].nxt) res+=dis[edge[i].to];
        if(res<dis[s])
        {
            dis[s]=res;
            for(reg int i=fir[s];i;i=rev[i].nxt) if(vis[rev[i].to]==0) q.push(rev[i].to),vis[rev[i].to]=1;
        }
    }
}
int main()
{
    scanf("%d",&n);
    UF(i,1,n)
    {
        c[i] = read(),dis[i] = read();
        int z;
        scanf("%d",&z);
        UF(j,1,z)
        {
            int k;
            scanf("%d",&k);
            add(i,k);
            addrev(k,i);
        }
    }
    SPFA();
    printf("%lld\n",dis[1]);
    return 0;
}

---

## 作者：张景 (赞：1)

~~随机跳题。。。发现有点像佳佳的魔法药水之类的。。于是秒切。。~~

#### SPFA

（貌似没有迪杰斯特拉好写。。。）

先把所有点入队进行松弛操作

松弛成功把所有能影响到的点再入队（入队时判重）

把魔法攻击看做dis数组（因为能够直接到达）

把物理攻击看做从其他点过来的代价

~~做题不如看题解，看题解不如抄代码（误）（手动滑稽）~~

这题要开long long。。。

建议不会SPFA的亲进传送门☞[不稳定传送门](https://www.baidu.com/s?ie=UTF-8&wd=spfa)

代码经过特殊处理，Ctrl+C/V者慎用☞[灰色世界   棕色世界  红色世界](https://www.luogu.org/space/show?uid=61634&myuid=85715&follow=1)

```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;
long long n,A[200010],M[200010],R[200010],head1[200010],head2[200010],k1,k2,ans;
struct edge
{
	long long to,next;
} ed1[1000010],ed2[1000010];
void adde1(long long u,long long v){ ed1[++k1].to=v;ed1[k1].next=head1[u];head1[u]=k1;}//可以从这些点转移 
void adde2(long long u,long long v){ ed2[++k2].to=v;ed2[k2].next=head2[u];head2[u]=k2;}//会影响这些点 
queue<long long> q;
bool ins[200010];
void spfa()
{
	for(long long i=1;i<=n;i++) q.push(i),ins[i]=1;
	while(!q.empty())
	{
		long long u=q.front();q.pop();ins[u]=0;
		long long sum=0;
		for(long long i=head1[u];i;i=ed1[i].next)
		{
			long long v=ed1[i].to;
			sum+=M[v];
		}
		sum+=A[u];
		if(sum<M[u])
		{
			M[u]=sum;
			for(long long i=head2[u];i;i=ed2[i].next)
			{
				long long v=ed2[i].to;
				if(!ins[v])
				{
					q.push(v);
					ins[v]=1;
				}
			}
		}
	}
}
int main()
{
	scanf("%lld",&n);
	for(long long i=1;i<=n;i++)
	{
		scanf("%lld%lld%lld",&A[i],&M[i],&R[i]);
		for(long long j=1;j<=R[i];j++)
		{
			long long x;
			scanf("%lld",&x);
			adde1(i,x);adde2(x,i);
		}
	}
	spfa();
	printf("%lld",M[1]);
	return 0;
}
```

---

## 作者：zhouhuanyi (赞：0)

链接：https://www.luogu.com.cn/problem/P4042

题目描述:对于一个怪物$i$，可以花费$c_{i}$的代价将其变为一个怪物集合，或花费$c2_{i}$的代价消灭他。求消灭怪物$1$的最小代价。

题解：由于这里涉及到了变化的传递，我们可以将原问题抽象为一个图，每一个点它可以花费$c2_{i}$的代价到达一个死亡节点或花费$c_{i}$的代价到达一个点集。

由于这个点集无法被直接表示，那么我们可以将他化为求点集的最小消灭代价之和$+$$c_{i}$，直接消灭也就是可以将$i$的最小消灭代价化为$c2_{i}$。

我们可以将$dijkstra$稍微改改，将所有点的$dis$初始化为$c2_{i}$，每一次将转移变为求集的最小消灭代价之和$+$$c_{i}$，也像$dijkstra$那样跑就行了。

```
#include<iostream>
#include<queue>
#include<cstdio>
using namespace std;
struct node
{
	long long v,nxt,data;
	bool vis;
};
node edge[2000001];
struct reads
{
	long long num,data;
	bool operator < (const reads &a)const
	{
		return data>a.data;
	}
};
long long dis[200001],dis2[200001];
int len,head[200001],n,in[200001],cnt[200001];
bool used[200001];
priority_queue<reads>q;
reads tmp;
reads make_reads(int x,long long y)
{
	tmp.num=x;
	tmp.data=y;
	return tmp;
}
void add(int x,int y,long long z)
{
	edge[++len].v=y;
	edge[len].data=z;
	edge[len].nxt=head[x];
	head[x]=len;
	return;
}
void dijkstra()
{
	int top;
	while (!q.empty())
	{
		top=q.top().num;
		q.pop();
		if (used[top])
			continue;
		used[top]=1;
		for (int i=head[top];i>0;i=edge[i].nxt)
		{
			if (!edge[i].vis&&cnt[edge[i].v]==in[edge[i].v]-1&&dis[edge[i].v]>dis2[edge[i].v]+dis[top]+edge[i].data)
			{
				edge[i].vis=1;
				cnt[edge[i].v]++;
				dis[edge[i].v]=dis2[edge[i].v]+dis[top]+edge[i].data;
				q.push(make_reads(edge[i].v,dis[edge[i].v]));
			}
			if (!edge[i].vis&&cnt[edge[i].v]<in[edge[i].v]-1)
			{
				edge[i].vis=1;
				cnt[edge[i].v]++;
				dis2[edge[i].v]=dis2[edge[i].v]+dis[top];
			}
		}
	}
	return;
}
int main()
{
	long long x,y,z,w;
	scanf("%lld",&n);
	for (int i=1;i<=n;++i)
	{
		scanf("%lld%lld%lld",&x,&y,&z);
		while (z--)
		{
			cin>>w;
			add(w,i,x);
			in[i]++;
		}
		dis[i]=y;
	}
	for (int i=1;i<=n;++i)
		q.push(make_reads(i,dis[i]));
	dijkstra(); 
	printf("%lld\n",dis[1]);
	return 0;
}

---


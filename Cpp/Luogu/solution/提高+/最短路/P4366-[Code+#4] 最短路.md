# [Code+#4] 最短路

## 题目背景

在北纬 91° ，有一个神奇的国度，叫做企鹅国。这里的企鹅也有自己发达的文明，称为企鹅文明。因为企鹅只有黑白两种颜色，所以他们的数学也是以二进制为基础发展的。

比如早在 $11101001$ 年前，他们就有了异或这样一个数学概念。如果你不知道异或是什么，请出门过墙左转到[这里](https://zh.wikipedia.org/wiki/%E9%80%BB%E8%BE%91%E5%BC%82%E6%88%96)。

再比如早在 $1000010$ 年前，他们的大科学家 Penguin. Tu 就提出了[图](https://zh.wikipedia.org/wiki/%E5%9B%BE_%28%E6%95%B0%E5%AD%A6%29#%E6%9C%89/%E7%84%A1_%E5%90%91%E5%9B%BE)和[最短路径](https://zh.wikipedia.org/wiki/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98)这样一些概念。

## 题目描述

企鹅国中有 $N$ 座城市，编号从 $1$ 到 $N$ 。

对于任意的两座城市 $i$ 和 $j$ ，企鹅们可以花费 $(i~\mathrm{xor}~j) \times C$ 的时间从城市 $i$ 走到城市 $j$ ，这里 $C$ 为一个给定的常数。

当然除此之外还有 $M$ 条单向的快捷通道，第 $i$ 条快捷通道从第 $F_i$​​ 个城市通向第 $T_i$​​ 个城市，走这条通道需要消耗 $V_i$​​ 的时间。

现在来自 **P**enguin **K**ingdom **U**niversity 的企鹅豆豆正在考虑从城市 $A$ 前往城市 $B$ 最少需要多少时间？

## 说明/提示

**样例1解释**

直接从 $1$ 走到 $4$ 就好了。

**样例2解释**

先从 $3$ 走到 $2$ ，再从 $2$ 通过通道到达 $4$ ，再从 $4$ 走到 $6$。

![0](https://cdn.luogu.com.cn/upload/pic/16868.png)

活泼可爱的出题人给大家留下了下面这张图。

![1](https://i.loli.net/2018/04/02/5ac1bb2333c22.jpg)

Credit: https://www.luogu.org/discuss/show/38908

## 样例 #1

### 输入

```
4 2 1
1 3 1
2 4 4
1 4```

### 输出

```
5```

## 样例 #2

### 输入

```
7 2 10
1 3 1
2 4 4
3 6```

### 输出

```
34```

# 题解

## 作者：Mirach (赞：29)

Problem
------------
想要数据的可以去Code+上下载

题意：
给定$n$个点，求从$s$到$t$的最短路径，其中有两种走法（可以混搭）：一种是走给定的$m$有向边$(u_i,v_i,w_i)$；另一种可以由任意点$x$到任意点$y$，其费用是$c*(x$ $xor$ $y)$

Solution
------------

明显不能直接$n^2$建边，为了多骗点分可能会想到可以dijkstra在过程中在线加边，处理到重点为止

但这样的最坏复杂度依旧是跑不过的（code+上这题的测试点有99个，骗分基本骗不满）

本着在任意一个正解中绝对不可能处理所有的$n^2+m$条边，发现有一些边可以被其他边替代，比如两个数异或值二进制表示中有两个及以上的1，那么可以用值分别为这两个1的边合并而成

>比如：$3$ $xor$ $6$ $= 5$  $\Leftrightarrow$ $11_2$ $xor$ $110_2 = 101_2$
>5 二进制下有之间有两个 1
>那么这个值可以由 $100_2$ 和 $1_2$这两个值合并而得
>即边$(3,6)=(3,7)+(7,6)$
>其权值对应为
>$101_2$ $100_2$ $1_2$

则对于任意点$x$，只用考虑给定边和到$\{v|v=x$ $xor$ $ 2^k,k\in N,v<=n\}$的边即可，其他边的效用定可以被这些边的组合包含，则对于点$x$，第二类边只有$\log_2x$条

则问题简化到只有$n\log n+m$条边了，$SPFA$目测会挂（有99个测试点），用$dijkstra$（博主用的是$dijkstra$的线段树优化）

注意$0$号结点也需要考虑（有可能两个节点编号按位与为$0$），并把异或值控制在$n$以内（出了$n$范围的点一定可以用$0$号节点解决）

Code
---------

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define rg register
#define cl(x) memset(x,0,sizeof(x))
#define max(x,y) ((x)>(y)?(x):(y))
#define min(x,y) ((x)<(y)?(x):(y))
#define abs(x) ((x)>0?(x):(-(x)))

template <typename _Tp> inline _Tp read(_Tp&x){
	rg char c11=getchar(),ob=0;x=0;
	while(c11^'-'&&!isdigit(c11))c11=getchar();if(c11=='-')c11=getchar(),ob=1;
	while(isdigit(c11))x=x*10+c11-'0',c11=getchar();if(ob)x=-x;return x;
}

const int N=201000,M=1001000,inf=2147483647;
struct Edge{int v,w,nxt;}a[M];
int head[N],dis[N],seg[N<<2];
char bo[N];
int n,m,c,_,ds,s,t;

inline void add(int u,int v,int w){a[++_].v=v,a[_].w=w,a[_].nxt=head[u],head[u]=_;}

#define mid (((l)+(r))>>1)

inline void build(int l,int r,int x){
	if(l==r){seg[x]=inf;return ;}
	build(l,mid,x<<1);
	build(mid+1,r,x<<1|1);
	seg[x]=inf;
	if(~seg[x<<1])seg[x]=min(seg[x],seg[x<<1]);
	if(~seg[x<<1|1])seg[x]=min(seg[x],seg[x<<1|1]);
	return ;
}

inline void update(int l,int r,int x,int pos,int t){
	if(l==r){seg[x]=min(seg[x],t);return ;}
	if(pos<=mid)update(l,mid,x<<1,pos,t);
	else update(mid+1,r,x<<1|1,pos,t);
	seg[x]=inf;
	if(~seg[x<<1])seg[x]=min(seg[x],seg[x<<1]);
	if(~seg[x<<1|1])seg[x]=min(seg[x],seg[x<<1|1]);
	return ;
}

inline int query(int l,int r,int x){
	if(l==r){ds=seg[x];return l;}
	if(seg[x]==seg[x<<1])return query(l,mid,x<<1);
	else if(seg[x]==seg[x<<1|1])return query(mid+1,r,x<<1|1);
	else return -1;
}

#undef mid

void spath(){
	build(0,n,1);
	update(0,n,1,s,0);
	while(!bo[t]){
		rg int x=query(0,n,1);
		bo[x]=1;dis[x]=ds;
		update(0,n,1,x,-1);
		for(rg int i=head[x];i;i=a[i].nxt)
			if(!bo[a[i].v])update(0,n,1,a[i].v,dis[x]+a[i].w);
		for(rg int i=1;i<=n;i<<=1)
			if(!bo[x^i]&&(x^i)<=n)update(0,n,1,x^i,dis[x]+c*i);
	}
	return ;
}

int main(){
	read(n);read(m);read(c);
	for(rg int i=0,x,y,z;i<m;++i)read(x),read(y),read(z),add(x,y,z);
	read(s);read(t);
	spath();
	printf("%d\n",dis[t]);
	return 0;
}
```


---

## 作者：Froranzen (赞：19)

#### [题目传送门~](https://www.luogu.com.cn/problem/P4366)

------------


# 思路

------------

刚看到这道题，本蒟蒻的第一想法是**建一个完全图**，再跑最短路。但是看一眼**数据**。

![](https://cdn.luogu.com.cn/upload/pic/16868.png)
(~~良心数据，i了i了~~)

**$10^5$ 的 N**，建成完全图……嗯，边都存不下，所以我们需要转换一下思路，想办法减少边的数量。我们可以在题目中看到：

**对于任意的两座城市 i 和 j ，企鹅们可以花费 $( i~\mathrm{xor}~j) \times C $ 的时间从城市 i 走到城市 j 。**

这便是减少边数的关键，为什么呐？我们来看一个例子：


- 1. 若我们的起点是 1，终点是 7。
- 2. 先转换为二进制，即 $(001)_2 $，和 $(111)_2$。
- 3. 直接从 1 走到 7 ，那么代价就是 6C。
- 4. 如果我们按位走：
- 5. 先从 $(001)_2$ 走到 $(011)_2$，代价为 2C，
- 6. 再从 $(011)_2$ 走到 $(111)_2$，代价为 4C。
- 7. 我们发现，第二种和第一种走法的代价一样。

所以我们发现，只要**每一个点和 $2^k$ 异或，就能从当前点走到任何一个点，且代价不变（二进制嘛）**。因此需要跑一遍循环来建边，让循环到的点  i  $\rightarrow$ $( i~\mathrm{xor}~2^k)$ 得到这条边的终点，然后得到这条边的权值为：
$$ ( i~\mathrm{xor}~(i + 2^k)) \times C $$
化简得：
$$  2^k \times C $$

同时我们还需要注意，**$i + 2^k$ 不能大于 n，所以我们要加一个边界。**
$$ i + 2^k <= n$$

然后我们就可以快乐地写代码了~

**但是，这道题用堆优化的 $dijkstra$ 会 TLE 几个点，所以本蒟蒻就写了一个线段树优化的代码，跑的速度还不戳。**

[未开$O^2$](https://www.luogu.com.cn/record/43657907)

[开$O^2$](https://www.luogu.com.cn/record/43647412)

------------


# 代码

------------

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#define re register
using namespace std;

typedef long long ll;

inline char nc () {  //fread快读
	static char buf[100000], *p1 = buf, *p2 = buf;
	return p1 == p2 && (p2 = (p1 = buf) + fread (buf, 1, 100000, stdin), p1 == p2) ? EOF : *p1++;
}

inline int read () {
	re int x(0), f(1); char ch = nc ();
	while (ch < '0' || ch > '9') {if (ch == '-') f = ~f +1; ch = nc ();}
	while (ch >= '0' && ch <= '9') {x = (x<<3) + (x<<1) + (ch^48); ch = nc ();}
	return x * f;
}

const int N = 1500010;  //试出来的一个常数
const int inf = 0x3f3f3f3f;
int n, m ,c;
int start, m_end;

struct edge {int v; int w; int nxt;} e[N<<1];

int head[N], cnt;

inline void add (re int u ,re int v , re int w) {
	e[++cnt] = (edge){v, w, head[u]};
	head[u] = cnt;
} 

inline int ls (int s) {return s<<1;}
inline int rs (int s) {return s<<1|1;}

int minv[N<<2], minp[N<<2];

inline void push_up (int o) {
	re int lc = ls (o);
	re int rc = rs (o);
	if (minv[lc] <= minv[rc]) {
		minv[o] = minv[lc];
		minp[o] = minp[lc];
	}
	else {
		minv[o] = minv[rc]; 
		minp[o] = minp[rc];
	}
}

void build (re int o ,re int l ,re int r) {
	if (l == r) {
		minv[o] = inf;
		minp[o] = l;
		return ;
	}
	re int mid = (l + r) >> 1;
	build (ls(o), l, mid);
	build (rs(o), mid + 1, r);
	push_up (o);
}

void modfity (re int o, re int l ,re int r ,re int p ,re int w) {
	if (l == r) {minv[o] = w; return ;}
	re int mid = (l + r) >> 1;
	if (p <= mid) modfity (ls(o), l, mid, p, w);
	else modfity (rs(o), mid + 1, r, p, w);
	push_up (o);
}

int dis[N];

void dijkspfa (re int s) {
	build (1, 0, n);
	modfity (1, 0, n, s, 0);
	memset (dis, 0x3f3f3f3f, sizeof (dis));
	dis[s] = 0;
	while (minv[1] != inf) {
		re int u = minp[1];
		modfity (1, 0, n, u, inf);
		for (re int i (head[u]); i; i = e[i].nxt) {
			if (dis[u] + e[i].w < dis[e[i].v]) {
				dis[e[i].v] = dis[u] +e[i].w;
				modfity (1, 0, n, e[i].v, dis[e[i].v]);
			}
		}
	}
}  //以上代码不理解的，可以换成堆优化的dijkstra，（不过要吸氧）

int main () {
	n = read (), m = read (), c = read ();
	for (re int i(1); i <= m; ++i) {
		re int u = read (), v = read (), w = read ();
		add (u, v, w);
	}
	for (register int i(0); i <= n; ++i) {  //关键代码：建图
		for (register int j(1); j <= 20; ++j) {  //这里循环到20次方就可以
			int qwq = i ^ (1 << j); 
			if (qwq <= n) add (i, qwq, c * (1 << j));
		}
	}  
	start = read (), m_end = read (); 
	dijkspfa (start);
	printf ("%d", dis[m_end]);
	return 0;
}
```


------------

（[悄悄要个关注](https://www.luogu.com.cn/user/361432)，不过分吧，qwq）

---

## 作者：philosopherchang (赞：12)

快NOIP了，却做不下去题，于是写篇题解吧。这题我是开O2过的，所以这篇题解能不能过也不知道，但希望CZdalao能放我一马~~安慰一下我幼小的心灵~~

这题主要是建图比较难，因为每个点都是有可能联通的，如果暴力建图的话最坏要建10的10次方个边，这绝对是128MB承受不了的，所以我们要考虑的是如何缩小建图的规模，异或是个神奇的东西，异或的性质就是同0异1，那么对于一个数xor另一个数，我们就可以把它们拆成两部分来解决，比方说$$6xor9=15$$
它就等价于二进制下（为了好理解都写成4位）$$0110xor1001=1111$$这样的话我们就可以拆成$$1100xor0011=1111$$结果是一样的，而1100和0011又可以继续拆，于是我们就能省略很多不必要的边，然后我们只需要建Xxor2的k次方的边就可以了，建边代码如下(build_tu_automachine中文翻译，建边自动机):
```cpp
void build_tu_automachine()
{
    for(int i=0;i<=n;i++) 
    {
        for(int j=1;j<=n;j<<=1) 
        {
            if((i^j)>n) continue;
            add(i,i^j,j*c);
        }
    }
}
```

然后就是迪杰斯特拉跑（堆优化）最短路

```cpp
#include<bits/stdc++.h>
using namespace std;
long long inf=2147483647;
struct edge{
    int u,v,w,next;
}e[500010+20*100010];
int head[100010],cnt,n,m,c,vis[100010],dis[100010];
int a,b;
struct node{
    int w,now;
    inline bool operator <(const node &x)const
    {
        return w>x.w;
    }
};
priority_queue<node> q;
void add(int u,int v,int w)
{
    e[++cnt].u=u;
    e[cnt].v=v;
    e[cnt].w=w;
    e[cnt].next=head[u];
    head[u]=cnt;
}
void dj()
{
    for(int i=1;i<=n;i++)
    {
        dis[i]=inf;
    }
    dis[a]=0;
    q.push(node{0,a});
    while(!q.empty())
    {
        node x=q.top();
        q.pop();
        int u=x.now;
        if(vis[u])
        continue;
        vis[u]=1;
        for(int i=head[u];i;i=e[i].next)
        {
            int v=e[i].v;
            if(dis[v]>dis[u]+e[i].w)
            {
                dis[v]=dis[u]+e[i].w;
                q.push((node){dis[v],v});
            }
        }
    }
}
void build_tu_automachine()
{
    for(int i=0;i<=n;i++) 
    {
        for(int j=1;j<=n;j<<=1) 
        {
            if((i^j)>n) continue;
            add(i,i^j,j*c);
        }
    }
}
int main()
{
    cin>>n>>m>>c;
    build_tu_automachine();
    for(int i=1;i<=m;i++)
    {
        int x,y,z;
        cin>>x>>y>>z;
        add(x,y,z);
    }
    cin>>a>>b;
    dj();
    cout<<dis[b]<<" ";
}

```

求过QAQ

---

## 作者：crashed (赞：10)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.org/problem/P4366)看题目。
# 分析  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;暴力建边肯定不行。而在算法上......好像也没什么可行的特殊算法......  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一筹莫展的你沉思了一阵，突然，你抬起了头，惊喜地大叫：“~~出题人你出锅了~~边中有无用的！”  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$Exactly!$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然，如果两个数在二进制上有超过一处的不同处，那么我们就可以用经过多条边代替直接走到，并且花费不变。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如，从$1$走到$6$：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先转化为二进制：$(001)_2$和$(110)_2$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尝试通过一位一位地让走到目标节点：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$(001)_2\rightarrow (101)_2$，花费$4C$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$(101)_2\rightarrow (100)_2$，花费$C$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$(100)_2\rightarrow (110)_2$，花费$2C$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总计$7C$。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而如果直接从$1$走到$6$的话，花费也是$7C$。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按照这种方法，边的数量直接就从$O(n^2)$降成了$O(n\times log_2(N))$。然后再新的图上跑$Dijkstra$就可以了。
# 代码
```cpp
#include <cmath>
#include <queue>
#include <cstdio>
#include <cstring>
using namespace std;

const int MAXN = 1e5 + 5, MAXM = 5e5 + 5, MAXLOG = 17;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

struct edge
{
	int to, nxt, w;
}Graph[MAXN * MAXLOG * 4 + MAXM];

struct node
{
	int u, dis;
	node(){}
	node( const int U, const int Dis )
	{
		u = U, dis = Dis;
	}
	bool operator < ( const node & other ) const
	{
		return ! ( dis < other.dis );
	}
};

priority_queue<node> q;

int dis[2 * MAXN];
int head[2 * MAXN];
int N, M, A, B, C, cnt, lg2;
bool visited[2 * MAXN];

void addEdge( const int from, const int to, const int W )
{
	cnt ++;
	Graph[cnt].nxt = head[from];
	Graph[cnt].to = to;
	Graph[cnt].w = W;
	head[from] = cnt;
}

int Dijkstra( const int sta, const int tar )
{
	while( ! q.empty() ) q.pop();
	memset( dis, 0x3f, sizeof( dis ) );
	memset( visited, false, sizeof( visited ) );
	dis[sta] = 0;
	q.push( node( sta, 0 ) );
	node h;
	int v, w;
	while( ! q.empty() )
	{
		h = q.top();
		q.pop();
		if( visited[h.u] ) continue;
		if( h.u == tar ) return h.dis;
		visited[h.u] = true;
		for( int i = head[h.u] ; i ; i = Graph[i].nxt )
		{
			v = Graph[i].to, w = Graph[i].w;
			if( ! visited[v] )
			{
				if( dis[v] > dis[h.u] + w )
				{
					dis[v] = dis[h.u] + w;
					q.push( node( v, dis[v] ) );
				}
			}
		}
	}
	return -1;
}

int main()
{
	int fr, to, W;
	read( N ), read( M ), read( C );
	lg2 = log2( N );
	for( int i = 1 ; i <= M ; i ++ )
	{
		read( fr ), read( to ), read( W );
		addEdge( fr, to, W );
	}
	for( int i = 1 ; i <= N + ( 1 << lg2 ) ; i ++ )
	{
		for( int j = 0 ; j <= lg2 ; j ++ )
		{
			to = i ^ ( 1 << j );
			addEdge( i, to, ( 1 << j ) * C );
		}
	}
	read( A ), read( B );
	write( Dijkstra( A, B ) ), putchar( '\n' );
	return 0;
}
```

---

## 作者：yingjz (赞：6)

这道题很容易让人联想到 **最短路**，但是最短路需要先 **建图**；

暴力建出所有边的算法显然是不可行的，因为这样会建出 $O(n^2 + m)$ 条边；

那么我们要考虑能不能 **减少一些边** ，使边的数量可以接受。

从哪里入手减少边的数量呢？异或或许是一个不错的切入口。

举个栗子：

> 假设我们要从 $001_2$ 到 $010_2$，我们要花费 $2^0 + 2^1$ 的费用；
但是，最短路有一个 **优越的性质**，我们可以把边拆开来，可以先从 $001_2$ 到 $000_2$，再从 $000_2$ 到 $010_2$，**费用是一样的**。

这样我们对于每个点 $i$，只需要建 $i$ 到 $i \ XOR \ 2^k$ 的边，之后 *Dijkstra* 就可以了哈。

需要注意的是 **边界情况**：从 $i$ 到 $j$ 经过的中间点可能超过 $n$，对此有 2 种处理方法：

1. 建边和 *Dijkstra* 的范围调整为 $[0,n]$
2. 建边和 *Dijkstra* 的范围调整为 $[1, 2^k-1]，k = min \{ k \ | \ n \leq 2^k -1 \}$

---

**方法 1 的代码**

```c++
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<queue>
using namespace std;
 
const int maxn = 100007;
const int maxm = 2500007;
int n, m, c;
int edgenum, head[maxn], nxt[maxm], vet[maxm], val[maxm];
inline void addedge(int u, int v, int w){
    ++edgenum;
    vet[edgenum] = v;
    val[edgenum] = w;
    nxt[edgenum] = head[u];
    head[u] = edgenum;
}
 
inline int read(){
    int f = 1, val = 0; char ch = getchar();
    while ((ch < '0' || ch > '9') && (ch != '-')) ch = getchar();
    if (ch == '-') f = -1, ch = getchar();
    while (ch >= '0' && ch <= '9') val = (val << 3) + (val << 1) + ch - '0', ch = getchar();
    return val * f;
}
 
int dist[maxn];
bool vis[maxn];
#define pii pair<int, int>
priority_queue< pii, vector< pii >, greater< pii > > Qmin;
const int INF = 1000000007;
inline void Dijkstra(int s){
    for (int i = 0; i <= n; ++i){
        vis[i] = false;
        dist[i] = INF;
    }
    dist[s] = 0; Qmin.push( make_pair(0, s) );
    for (int i = 0; i <= n; ++i){
        while (!Qmin.empty() && vis[Qmin.top().second]) Qmin.pop();
        if (Qmin.empty()) break;
        int u = Qmin.top().second; Qmin.pop();
        vis[u] = true;
        for (int e = head[u]; e; e = nxt[e]){
            int v = vet[e], cost = val[e];
            if (dist[v] > dist[u] + cost){
                dist[v] = dist[u] + cost;
                Qmin.push( make_pair(dist[v], v) );
            }
        }
    }
}
 
int main(){
    n = read(); m = read(); c = read();
    for (int i = 1; i <= m; ++i){
        int u = read(), v = read(), w = read();
        addedge(u, v, w);
    }
     
    for (int i = 0; i <= n; ++i){
        for (int j = 0; j < 20; ++j){
            int to = i ^ (1 << j);
            if (to <= n) addedge(i, to, c * (1 << j));
        }
    }
     
    int A = read(), B = read();
    Dijkstra(A);
     
    printf("%d\n", dist[B]);
    return 0;
}
```

**方法 2 的代码**

```c++
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<queue>
#define pii pair<int,int>
using namespace std;

const int maxn = 200007;
const int maxm = 3000007;
int n, m, C, lgn, A, B;
int edgenum, hea[maxn], vet[maxm], nxt[maxm], val[maxm];
inline void addedge(int u, int v, int cost){
    ++edgenum;
    vet[edgenum] = v;
    val[edgenum] = cost;
    nxt[edgenum] = hea[u];
    hea[u] = edgenum;

    //printf("%d -> %d (%d)\n", u, v, cost);
} 

inline int read(){
    int f=1, val=0; char ch=getchar();
    while ((ch<'0'||ch>'9')&&(ch!='-')) ch=getchar();
    if (ch=='-') f=-1,ch=getchar();
    while (ch>='0'&&ch<='9') val=(val<<3)+(val<<1)+ch-'0',ch=getchar();
    return val*f;
}

int dist[maxn];
bool vis[maxn];
priority_queue<pii, vector< pii >, greater< pii > > Qmin;
inline void Dijkstra(int s){
    for (int i = 1; i <= n; ++i){
        vis[i] = false;
        dist[i] = 1000000000;
    }
    dist[s] = 0; Qmin.push(make_pair(0, s));
    for (int i = 1; i <= n; ++i){
        while (!Qmin.empty() && vis[Qmin.top().second]) Qmin.pop();
        if (Qmin.empty()) break;
        int u = Qmin.top().second; Qmin.pop();
        vis[u] = true;
        for (int e = hea[u]; e; e = nxt[e]){
            int v = vet[e], cost = val[e];
            if (dist[v] > dist[u] + cost) dist[v] = dist[u] + cost, Qmin.push(make_pair(dist[v], v));
        }
    }
}

int main(){
    n = read(); m = read(); C = read();
    for (int i = 1; i <= m; ++i){
        int u = read(), v = read(), cost = read();
        addedge(u, v, cost);
    }
    lgn = floor(log2(n)) + 1;
    n = (1 << lgn) - 1;

    for (int i = 1; i <= n; ++i){
        for (int j = 0; j < lgn; ++j)
            addedge(i, i ^ (1 << j), (1 << j) * C);
    }

    A = read(); B = read();
    Dijkstra(A);

    printf("%d\n", dist[B]);
    return 0;
}
```


---

## 作者：0htoAi (赞：5)


### 直接讲关于普通路径的建图
1.易证从任意 $i$ 城市到 $j$ 城市直接走路，从 $i$ 直接走过去是最近路径之一（也就是说不会有比直接走更近的了）

~~事实上我不会证明，但感性理解应该是这样的~~

2.对于某些 $i$ 到 $j$，有其它路径可以使此路径的长度也等于 $ixorj$。

3.假设 $1$ 为起始点，任意点为终点，可以生成一棵树使得从 $1$ 到任意点的最短路径之一都在这棵树上。

4.理解 $xor$ 的作用，按位相同为 $0$，不同为 $1$ 可以证明           $(2^n+1)xor1$ 是不可能有除直接走过去之外其它相同长度的路径的。

##### 那么如果这道题的起始点为 $1$，可以直接这样写代码：
```cpp
inline void BuildTree(int x,int n)
{
	if(x>N)
		return;
	if(x==1)
	{
		if(x+(1<<n+1)<=N)
			BuildTree(x,n+1);
		Add(x,x+(1<<n),(x^(x+(1<<n)))*C);
		Add(x+(1<<n),x,(x^(x+(1<<n)))*C);
		BuildTree(x+(1<<n),n-1);
	}
	else
	{
		Add(x,x-1,C);
		Add(x-1,x,C);
		for(int i=n;i>=1;i--)
		{
			if(x+(1<<i)<=N)
			{
				Add(x,x+(1<<i),(x^(x+(1<<i)))*C);
				Add(x+(1<<i),x,(x^(x+(1<<i)))*C);
				BuildTree(x+(1<<i),i-1);
			}
			
		}
	}
}
```
 5.事实上题目要求从任意一点到另一点的最短路。
 
 6.所以要跑 $n$ 次这样的操作…………？
 
 先处理一下。
 
 对于 $1$：到 $(2^n+1)xor1$ 这个点没有最短路径，到其它点可以通过这几个点走出跟直接走过去长度相同的路径。
 
 推广：对于任意一个 $i$,有到 $(2^n+i)xor i$ 这个点直接走是唯一最短路径。
 
 所以只需要对任意 $i$ 号点都连 $(2^n+i)xori$ 这个点，这样建图跑出来最短路跑出来的一定是跟原图一样的长度。
 所以正确的建图代码是这样的：
 ```cpp
inline void BuildTree(int n)
{
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j<<=1)
		{
			if((i^j)>n)
				continue;
			Add(i,i^j,j*C);
		}
	}
}
```
建图完成之后再输入快捷通道再跑最短路就行了。

###### 附：堆优化跑 $Dijkstra$ 也许会超时，加个快读吧！





---

## 作者：lzy20091001 (赞：4)

[P4366 [Code+#4] 最短路](https://www.luogu.com.cn/problem/P4366)

## 题意简述

有一张 $N$ 个点的完全图，第 $i$ 个点和第 $j$ 个点之间边的边权为 $(i \oplus j) \times C$，其中 $C$ 是一个给定的常数，此外给定 $M$ 条有向边。给定两点 $A, B$，求两点间的最短路。

## 分析

### 引入

$N \le 10 ^ 5$，显然无法将完全图中的每条边全部存下。我们希望找到一些多余的边。具体地，在最短路模型中，这些边可以被其他的路径替代。

例如，第 $2$ 个点与第 $7$ 个点之间有一条边权为 $(2 \oplus 7) \times C = 5 \times C$ 的边。同时我们发现，从第 $2$ 个点到第 $3$ 个点，再从第 $3$ 个点到第 $7$ 个点，所需代价为 $(2 \oplus 3) \times C + (3 \oplus 7) \times C = 5 \times C$。因此第 $2$ 个点与第 $7$ 个点之间这条边是多余的，因为它可以被 $2 \to 3 \to 7$ 这条路径替代。

### 结论

一般地，我们希望找出所有多余的边。具体地，对于 $i, j$，如果存在有 $s$ 个元素的有序集合 $\{ t \} \ (i, j \notin \{ t \})$ 满足

$$
i \oplus j = (i \oplus t _ 1) + (t _ 1 \oplus t _ 2) + \cdots + (t _ {s - 1} \oplus t _ s) + (t _ s \oplus j)
$$

那么第 $i$ 个点和第 $j$ 个点之间的边就是多余的，因为它可以被 $i \to t _ 1 \to \cdots \to t _ s \to j$ 这条路径替代。

**结论是：当且仅当 $i$ 和 $j$ 在二进制下有且仅有 $1$ 位不同时，第 $i$ 个点和第 $j$ 个点之间的边不是多余的。**例如 $(10100) _ 2$ 与 $(10110) _ 2$ 满足要求，而 $(10100) _ 2$ 与 $(10111) _ 2$ 不满足要求。以下给出证明。

### 证明

为表述方便，下文中对于任意二进制数，我们称其最低位为第 $0$ 位，其他从右往左依次为第 $1$ 位、第 $2$ 位等。

#### 必要性

首先我们证明这些边是必需的，它们无法被其他边替代。

首先证明 $s = 1$ 时，即只有一个 $t$ 时命题成立。

对于满足有且仅有 $1$ 位不同的 $i, j \ (i < j)$，假设存在 $t$ 满足 $t \ne i, j$ 且 $i \oplus j = (i \oplus t) + (t \oplus j)$。

设 $i, j$ 第 $k$ 位不同，则显然有 $i$ 的第 $k$ 位为 $0$，$j$ 的第 $k$ 位为 $1$，$i \oplus j = 2 ^ k$。设 $t$ 的第 $k$ 位为 $x$。注意到 $(i \oplus t) + (t \oplus j)$ 的第 $k$ 位 $(x \oplus 0) + (x \oplus 1) \equiv 1$，所以 $(i \oplus t) + (t \oplus j) \ge 2 ^ k$。而根据假设 $(i \oplus t) + (t \oplus j) = i \oplus j = 2 ^ k$，所以 $(i \oplus t) + (t \oplus j)$ 除了第 $k$ 位都为 $0$，$t$ 除了第 $k$ 位都和 $i, j$ 一样。那么 $x = 0$ 时 $t = i$，$x = 1$ 时 $t = j$，无论哪种都和 $t \ne i, j$ 矛盾。因此假设不成立，这样的 $t$ 不存在。

这可以推广到 $s \ne 1$ 的情形，考察 $t _ 1, t _ s$ 同理得证。

#### 充分性

首先我们证明：**若 $i, j$ 满足 $j = i + 2 ^ k$，则 $i, j$ 之间的边可以被结论中的边构成的路径替代**。

第一种情况：$j = i + 2 ^ k$ 中 $i + 2 ^ k$ 没有导致进位，例如 $(10110) _ 2 = (10100) _ 2 + (10) _ 2$。这种情况就是我们结论中保留的边。

第二种情况：$j = i + 2 ^ k$ 中 $i + 2 ^ k$ 导致了进位，例如 $(10110) _ 2 = (10101) _ 2 + (1) _ 2$。这种情况应该是这样的：

$$
\begin{aligned}
    i &= (\cdots 0 \underbrace{11 \cdots 11} _ {\text{若干个 }1} \cdots) _ 2 \\
    j &= (\cdots 1 \underbrace{00 \cdots 00} _ {\text{若干个 }0} \cdots) _ 2 \\
    i \oplus j &= (000111\cdots11000) _ 2
\end{aligned}
$$

$i$ 和 $j$ 在其他位（也就是省略号的部分）都是一样的，加上 $2 ^ k$ 后导致了一连串的进位。我们希望能找到 $t$ 满足 $t \ne i, j$ 且 $i \oplus j = (i \oplus t) + (t \oplus j)$。$t$ 的构造方法是 $t = (\cdots 000 \cdots 00 \cdots ) _ 2$，即 $t$ 在 $i, j$ 不同的位上都取 $0$，其他位与 $i, j$ 相同。

$$
\begin{aligned}
    t &= (\cdots 000 \cdots 00 \cdots ) _ 2 \\
    i \oplus t &= (000 011 \cdots 11 000) _ 2 \\
    t \oplus j &= (000 100 \cdots 00 000) _ 2
\end{aligned}
$$

显然可以验证 $i \oplus j = (i \oplus t) + (t \oplus j)$ 成立。

存在特殊情况 $i = (011 \cdots 11) _ 2, j = (100 \cdots 00) _ 2$，即 $k = 0$。此时我们构造的 $t$ 为 $0$，而题目要求的是 $1 \sim n$ 间的最短路。为此我们人为地引入第 $0$ 个点。对于第 $0$ 个点使用相同的方法连边，这样就解决了特殊情况。

综上，对于满足 $j = i + 2 ^ k$ 的 $i, j$，若 $i + 2 ^ k$ 不进位则 $i, j$ 之间有一条边，若 $i + 2 ^ k$ 进位则可以找到等价的一条路径。所以我们解决了 $i, j$ 满足 $j = i + 2 ^ k$ 的情况。显然，对于任意 $i, j \ (i < j)$，$i$ 加上若干个 $2 ^ k$ 总能得到 $j$，因此等价的路径总是存在，证毕。

### 复杂度分析

边的数量为 $m = \operatorname{O}(N \log N + M)$，使用堆优化的 Dijkstra 求最短路的时间复杂度为 $\operatorname{O}(m \log m)$。极限情况下 $m$ 在 $2 \times 10 ^ 6$​ 左右，较为勉强但可以通过。

## 实现

提供一种优雅的连边方法：

```cpp
for (int i = 0; i <= n; i++)
    for (int j = 1; j <= n; j <<= 1)
        if ((i ^ j) <= n)
            edge[i].push_back({i ^ j, c * j});
```

`j` 即为 $2 ^ k$，`i ^ j` 会把 `i` 的第 $k$ 位自动取反。具体地，若 `i` 的第 $k$ 位为 $0$，则会连接 `i` 和 `i + j`；若 `i` 的第 $k$ 位为 $1$，则会连接 `i` 和 `i - j`。这样跑完之后就会连完所有的双向边。

完整代码：

```cpp
#include <cstring>
#include <iostream>
#include <bitset>
#include <vector>
#include <queue>

struct Edge
{
    int v, w;
    friend bool operator>(Edge _a, Edge _b) { return _a.w > _b.w; }
};

int n, c, a, b;
int dis[100005];
std::bitset<100005> vis;
std::vector<Edge> edge[100005];
std::priority_queue<Edge, std::vector<Edge>, std::greater<Edge>> pq;

void dijkstra()
{
    memset(dis, 0x3f, sizeof(int) * (n + 1)); // 卡常小技巧
    dis[a] = 0;
    pq.push({a, 0});

    while (!pq.empty())
    {
        int u = pq.top().v;
        pq.pop();
        if (vis[u])
            continue;
        if (u == b) // 卡常小技巧
            return;
        vis[u] = true;
        for (auto x : edge[u])
        {
            int v = x.v, w = x.w;
            if (dis[v] > dis[u] + w)
            {
                dis[v] = dis[u] + w;
                pq.push({v, dis[v]});
            }
        }
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);

    int m;

    std::cin >> n >> m >> c;
    for (int i = 1; i <= m; i++) // 特殊的 M 条边
    {
        int f, t, v;
        std::cin >> f >> t >> v;
        edge[f].push_back({t, v});
    }
    std::cin >> a >> b;

    for (int i = 0; i <= n; i++) // 建边
        for (int j = 1; j <= n; j <<= 1)
            if ((i ^ j) <= n)
                edge[i].push_back({i ^ j, c * j});

    dijkstra();

    std::cout << dis[b] << "\n";

    return 0;
}
```

---

## 作者：Sirius_Sakura (赞：3)

本萌新丢的第一篇题解；

方法：Dijkstra+堆优化；

然后每个点需要另外多存的边，如何存，另外几位大佬的题解已经说了；

本来堆优化我是开O2过的，但是很不甘心，然后就想了想，在Dijkstra更新点的时候，如果终点更新过了，是不是就可以跳出去了，想到这里本萌新立马就试了试，结果；emmm
没开O2总耗时7000ms+；我看了一眼其他大佬的题解好像没写这个东西，（应该是我太菜了看不出来），因此本萌新丢上自己的处女题解√；

然后，就看代码吧；

```cpp
#include<bits/stdc++.h>
#define ilv inline void
#define fo(I,J,K) for(int I=J;I<=K;I++)
using namespace std;
const int N=10e6； //范围开得有点大，不过无伤大雅emmm
int n,m,dis[N],cnt=1,head[N],next[N],to[N],ww[N],cc,A,B,vis[N];
ilv add(const int u,const int v,const int w) //前向星存边
{
    to[cnt]=v;
    ww[cnt]=w;
    next[cnt]=head[u];
    head[u]=cnt++;
}
struct node{
    int d,p;
    node(int a,int b){d=a;p=b;}
    bool operator <(const node &x)
    const{return x.d<d;}
};
priority_queue<node> q;

ilv disj(const int s) //Dijkstra
{
    dis[s]=0;
    q.push(node{0,s});
    while(!q.empty())
    {
    	if(vis[B]) break; //我说的就是这句，加上后不用02也能过，而且跑得贼快
    	int pi=q.top().p;
        q.pop();
        if(vis[pi]) continue;
        vis[pi]=1;
        for(register int i=head[pi];i;i=next[i])
        {
            int ti=to[i];
            if(dis[ti]>dis[pi]+ww[i])
            {
                dis[ti]=dis[pi]+ww[i];
                if(!vis[ti])
                q.push(node{dis[ti],ti});
            }
        }
    }
}
ilv ra(int &x) //快读
{
    x=0;char c=getchar();
    while(c<'0'||c>'9') c=getchar();
    while('0'<=c&&c<='9') {x=(x<<3)+(x<<1)+(c^48);c=getchar();}
}
int main()
{
    int x,y,z;
    ra(n);ra(m);ra(cc);
    for(register int i=0;i<=n;i++)
    {
    dis[i]=21474833;//在多存边的时候顺手重置dis[]
    for(register int j=1;j<=n;j<<=1) //这个就是另外几位大佬介绍的拆边 
    {
            if((i^j)>n) continue;
            add(i,i^j,j*cc);
    }
	}
	for(register int i=1;i<=m;i++)
    {
        ra(x);ra(y);ra(z);
        add(x,y,z);
    }
    ra(A);ra(B);
    disj(A); //跑最短路
    printf("%d ",dis[B]); //输出
    return 0;//养成好习惯 结束
}
```




---

## 作者：天南星魔芋 (赞：2)

提供一种**暴力**的做法，适用于最短路初学者。（

------------

既然题目是最短路，那就直接跑最短路呗。

然后发现 $O(N^2)$ 建边吐血。

考虑异或性质，当两个数在 2 进制下某一位不同时，花费加上当前数乘 $C$ 。

那我们让它每次在 2 进制下只变化一位不就行了？

![](https://cdn.luogu.com.cn/upload/image_hosting/3fjmxj1e.png)

然后发现每个节点对应 $log(N)$ 个节点，总共 $N·log(N)$ 个点，时间复杂度较为合理。

然后暴力 Dijkstra ，发现有可能 TLE 一片？（我是 T 了 14 个） 

那优化一下：

1. Dijkstra 时一旦找到终点直接退出，而不是等待其余部分运行完成

2. 考虑建边方法，因为 邻接矩阵 空间复杂度大，无用内存多，所以用 前向星（邻接表）。

3. 然后我们想，为什么 邻接矩阵 没有完全淘汰？（我刚开始学最短路是只喜欢用它）。

* 好学是一方面，另一方面是运行时连续的内存访问速度快，对于稠密图比前向星（邻接表）快 $233$ 倍。


* 存边方式是速度瓶颈之一，虽然这题我们不能用 邻接矩阵 ，但我们可以学习他的优点。


对于上面每个节点的 $log(N)$ 个边，由于是由当前节点在 $2$ 进制下改变一位得来，所以并不用存入前向星中，只要在这个节点取出时异或上 $2^0 , 2^1 , 2^2......$ 就行了，速度提升和内存节省非常可观。


4.  堆也可以优化，虽然是 $O(log(N))$ ，但是当存入节点过多时也会很慢，而且内存占用也会变多。

* 那么我们开一数组，使其同一节点不同距离入堆单调就行了。


------------


虽然上面的优化方案看起来长，但实现起来非常简单，~~至少比线段树优化好~~

然后放上没有优化的代码和AC代码：

TLE 72:


```cpp

#include<bits/stdc++.h>
using namespace std;

int n,m,c,s,t;
int fir[120050],nxt[5800050],to[5800050],qp[5800050],top=0;//前向星 
int dis[120050];//距离 
int xo[80];//2的几次方，用于异或 
struct PX{//堆排序 
	int zhi,id;	
}dui[3000050];
int dtop=0;//堆指针
 
void add(int x,int y,int z){//前向星加边 
	top++;nxt[top]=fir[x];fir[x]=top;to[top]=y;qp[top]=z;
}

bool cmp(int a,int b){//堆排序方式  手打堆你要cmp干什么（捂脸 
	return dui[a].zhi<dui[b].zhi;
}


void dadd(int x,int v){//入堆 
	dtop++;dui[dtop].id=x;dui[dtop].zhi=v;
	int zz=dtop;
	while(zz>1){
		if(cmp(zz,zz>>1))swap(dui[zz],dui[zz>>1]),zz>>=1;
		else return ;
	}
}

void push(int &x,int &v){//出堆 
	if(!dtop){
		x=v=0;
		return ;
	}
	x=dui[1].id;v=dui[1].zhi;
	swap(dui[1],dui[dtop]);dtop--;
	int zz=1;
	while((zz<<1)<=dtop){
		int zzz;
		if((zz<<1|1)<=dtop&&cmp(zz<<1|1,zz<<1))zzz=zz<<1|1;
		else zzz=zz<<1;
		if(cmp(zzz,zz))swap(dui[zzz],dui[zz]),swap(zz,zzz);
		else return ;
	}
}

int minn(int x,int y){
	return x>y? y:x;
}

void dij(){//Dijkstra 板子 
	for(int i=0;i<=n;i++)dis[i]=0x3f3f3f3f;
	dadd(s,0);
	while(dtop){
		int x,v;
		push(x,v);
		if(dis[x]!=0x3f3f3f3f)continue;
		dis[x]=v;
		for(int i=fir[x];i;i=nxt[i]){
			dadd(to[i],v+qp[i]);
		}
	}
}

void addb(int x){//像前向星中加那 N log N 个边 
	for(int i=1;;i++){
		int too=(xo[i]^x);
		if(too>n){if(xo[i]>n)break;else continue;}
		add(x,too,xo[i]*c);
	}
} 

signed main(){
	//-------------------------//读入 
	cin>>n>>m>>c;
	for(int i=1;i<=m;i++){
		int a,b,c;
		scanf("%d%d%d",&a,&b,&c);
		add(a,b,c);
	}
	scanf("%d%d",&s,&t);
	
	xo[1]=1;
	for(int i=2;i<=30;i++){// 2的 n次方 
		xo[i]=(xo[i-1]<<1);
	}
	
	
	for(int i=0;i<=n;i++)addb(i);//加那 N log N 条边 
	
	
	dij();//板子 
	
	cout<<dis[t]<<endl;//答案 
}

```

AC:

```cpp

#include<bits/stdc++.h>
using namespace std;

int n,m,c,s,t;
int fir[120050],nxt[600050],to[600050],qp[600050],top=0;
int dis[120050];
int dt[120050];
int xo[80];

struct PX{
	int zhi,id;	
}dui[1200050];
int dtop=0;

void add(int x,int y,int z){
	top++;nxt[top]=fir[x];fir[x]=top;to[top]=y;qp[top]=z;
}

bool cmp(int a,int b){
	return dui[a].zhi<dui[b].zhi;
}

void dadd(int x,int v){
	if(dt[x]<=v)return ;
	dt[x]=v;
	dtop++;dui[dtop].id=x;dui[dtop].zhi=v;//单调加入 
	int zz=dtop;
	while(zz>1){
		if(cmp(zz,zz>>1))swap(dui[zz],dui[zz>>1]),zz>>=1;
		else return ;
	}
}

void push(int &x,int &v){
	if(!dtop){
		x=v=0;
		return ;
	}
	x=dui[1].id;v=dui[1].zhi;
	swap(dui[1],dui[dtop]);dtop--;
	int zz=1;
	while((zz<<1)<=dtop){
		int zzz;
		if((zz<<1|1)<=dtop&&cmp(zz<<1|1,zz<<1))zzz=zz<<1|1;
		else zzz=zz<<1;
		if(cmp(zzz,zz))swap(dui[zzz],dui[zz]),swap(zz,zzz);
		else return ;
	}
}

int minn(int x,int y){
	return x>y? y:x;
}

void dij(){
	for(int i=0;i<=n;i++)dt[i]=dis[i]=0x3f3f3f3f;//记得加上对堆优化的初始化 
	dadd(s,0);
	while(dtop&&dis[t]==0x3f3f3f3f){//找到就退出 
		int x,v;
		push(x,v);
		if(dis[x]!=0x3f3f3f3f)continue;
		dis[x]=v;
		for(int i=fir[x];i;i=nxt[i]){
			dadd(to[i],v+qp[i]);
		}
		for(int i=1;;i++){//补上前向星的一些边 
			int too=(xo[i]^x);
			if(too>n){if(xo[i]>n)break;else continue;}
			dadd(too,v+xo[i]*c);
		}
	}
}

signed main(){
	cin>>n>>m>>c;
	for(int i=1;i<=m;i++){
		int a,b,c;
		scanf("%d%d%d",&a,&b,&c);
		add(a,b,c);
	}
	scanf("%d%d",&s,&t);
	if(m==0){
		cout<<(s^t)*c<<endl;
		return 0;
	}
	xo[1]=1;
	for(int i=2;i<=30;i++){
		xo[i]=(xo[i-1]<<1);
	}
	//---------------------------------//省下前向星中的一些边 
	dij();
	cout<<dis[t]<<endl;
}

```




------------


不开 O2 最慢 $393ms$，速度还是可以的。


---

## 作者：chenzida (赞：2)

**题意简述：**
有 $n$ 个点和 $m$ 条边构成的图中再加上一些特殊的，任意两点间的边，并且长度为这两个点的 $xor$ 值乘上一个常数。求两点间的最短路。

**思路解析：**
如果要暴力的话可以有 $n^3$ 的 $floyd$ 或者大模拟连边，即有 $n^2+m$ 条边，时间复杂度为 $O((n^2+m)\times log(n^2+m))$ 。但是这个只能拿到 $30$ 分，这是远远不够的。下面我们考虑正解。

如果没有这个任意两点间的路径条件，肯定大家都会做，就是 $dijkstra$ 模板，所以我们看看怎么将这个连边优化一下。

$$(0111)_2 \ xor \ (1101)_2=(1010)_2$$

那考虑一下，由于最短路的性质，假设有三条边

$x->y \ (a) \ \ \ \ \ \ \  y->z \ (b)$ 则是不是不需要建多余的 $x->z\ (a+b)$ 的边了？

这个也就是一样的，每次只需要增加或减少一个数位上的 $1$，这样总的最短路不变。举一个栗子：

$$(1001)_2 -> (1010)_2$$

这条路是能被 $(1001)_2->(1000)_2$ 和 $(1001 \ xor 1000)_2 -> (0001)_2$ 这两条路一起替代的，所以每次我们只用变化一个结点的一条边即可。

如代码：
```cpp
for(int i=0;i<=n;i++)
{
	for(int j=1;j<=n;j<<=1)
	{
		if((i^j)<=n)
		{
			add(i,i^j,c*j);
		}
	}
}
```

而其他的就是一个 $dijkstra$ 的模板了。

完整代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int NR=1e5+10;
const int MR=3e6+10;
int n,m,c;
int to[MR],nxt[MR],val[MR];
int head[NR];
int tot=1;
void add(int x,int y,int z)
{
	to[tot]=y;
	val[tot]=z;
	nxt[tot]=head[x];
	head[x]=tot++;
}
struct Nd
{
	int x,d;
	bool operator <(const Nd& A) const
	{
		return d>A.d;
	}
};
bool vis[NR];
int dis[NR];
priority_queue<Nd> q;
Nd tmp;
void dijkstra(int s)
{
	memset(vis,0,sizeof(vis));
	memset(dis,0x3f,sizeof(dis));
	tmp.x=s,tmp.d=0;
	q.push(tmp);dis[s]=0;
	while(!q.empty())
	{
		int x=q.top().x;q.pop();
		if(vis[x]) continue;
		vis[x]=1;
		for(int i=head[x];i;i=nxt[i])
		{
			int y=to[i];
			if(dis[y]>dis[x]+val[i])
			{
				dis[y]=dis[x]+val[i];
				tmp.x=y,tmp.d=dis[y];
				q.push(tmp);
			}
		}
	}
}
int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch<='9'&&ch>='0'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return x*f;
}
int main()
{
//	freopen("1.in","r",stdin);
//	freopen("1.out","w",stdout);
	n=read(),m=read(),c=read();
	for(int i=1;i<=m;i++)
	{
		int x=read(),y=read(),z=read();
		add(x,y,z);
	}
	for(int i=0;i<=n;i++)
	{
		for(int j=1;j<=n;j<<=1)
		{
			if((i^j)<=n)
			{
				add(i,i^j,c*j);
			}
		}
	}
	int s=read(),t=read();
	dijkstra(s);
	printf("%d\n",dis[t]);
	return 0;
}
```

---


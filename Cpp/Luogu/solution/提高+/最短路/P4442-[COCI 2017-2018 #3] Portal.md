# [COCI 2017/2018 #3] Portal

## 题目描述

本任务的主角 Chell 必须解决 GLaDOS 提出的新谜题。

Chell 处于一个房间中，该房间的布局可以表示为一个 N 行 M 列的矩阵。每个格子可以是以下几种之一：

- 障碍格子 - 其中有一面墙（用 '#' 表示），
- Chell 的起始位置（用 'C' 表示），
- Chell 必须到达以解决谜题的格子（用 'F' 表示），或者
- 空格子（用 '.' 表示）。

Chell 携带一个所谓的传送枪，可以用来在墙上创建传送门。

在每次移动中，她可以执行以下操作之一：
- 向相邻的格子移动，方向可以是上、下、左或右（她不能移动到有墙的格子）。此移动耗时一个单位时间。
- 通过转向一个方向（不一定是相邻的）朝墙射击来在墙上创建一个传送门。传送门只会在被击中的墙的一侧创建。在任何时刻，**最多只能有两个传送门是激活的**。如果在已有两个激活传送门的情况下创建新的传送门，最早创建的那个将消失。不能在已有传送门的位置创建新的传送门。此操作耗时可忽略不计，即零时间。
- 如果她在一个与墙相邻的格子并且墙的这一侧有传送门，她可以进入传送门并从另一个传送门出来到一个非障碍格子。此操作在有两个激活传送门时才可能，并且耗时一个单位时间。

Chell 想知道解决谜题的最少时间，即到达标记为 'F' 的格子的时间。

**请注意**：房间的四周总是有墙，并且字母 'C' 和 'F' 在矩阵中只出现一次。

## 说明/提示

在总分的 50% 的测试用例中，将满足 4 ≤ N, M ≤ 15。

**第二个测试用例的说明**：

该谜题可以在 8 步内解决，如下图所示。

在第一步中，我们转向左侧墙壁，射击并创建一个传送门，该传送门出现在第 3 行第 1 列（坐标 (3,1)）的墙的右侧。

在第二步中，我们从墙的上侧在坐标 (6,2) 创建一个传送门。

在第三步中，我们进入坐标 (3,1) 的传送门并在坐标 (5,2) 出口——一个有第二个传送门的非障碍格子。

在第四步中，我们向右转并从墙的左侧在坐标 (5,7) 创建一个传送门。由于已经有两个传送门，位于 (3,1) 的传送门消失。

在第五步中，我们进入坐标 (6,2) 的传送门并在坐标 (5,6) 出口。

在第六步中，我们从墙的下侧在坐标 (1,6) 创建一个新传送门，使得坐标 (6,2) 的传送门消失。

在第七步中，我们进入坐标 (5,7) 的传送门并在坐标 (2,6) 出口。最后，在第八步中，我们向右移动一格以结束游戏。

第 1、2、4 和 6 步中的传送门创建耗时为零，而其余移动耗时一个单位时间，因此解决谜题总共需要 4 个单位时间。

![](https://cdn.luogu.com.cn/upload/pic/17512.png)

题面翻译由 ChatGPT-4o 提供。

## 样例 #1

### 输入

```
4 4
####
#.F#
#C.#
####
```

### 输出

```
2```

## 样例 #2

### 输入

```
6 8
########
#.##..F#
#C.##..#
#..#...#
#.....##
########
```

### 输出

```
4```

## 样例 #3

### 输入

```
4 5
#####
#C#.#
###F#
#####
```

### 输出

```
nemoguce
```

# 题解

## 作者：iiiiiiiiiiiiiiiiiii (赞：15)

一道最短路的变形题。

首先，把传送的过程拆开，就是先射两枪，再走到一个传送门，传送到另一个传送门，共花费 $1$ 单位时间。

所以一共有两种走法：一种是走到相邻的格子（spfa 即可），一种是传送。

对于传送，在搜索时枚举**起点传送门**和**终点传送门**。在 spfa 之前 $O(n^2)$ 递推预处理出每个点向四个方向直线走最近的墙的距离，走到起点传送门即可。当然，传送到每个位置有 $3$ 种方案（起点传送门和终点传送门方向不同），但是起到的效果是一样的，需要取最小值。

注意：不一定是要挨着墙才能传送，会 $78$ 分。

```cpp
const int dx[]={0,1,0,-1},dy[]={1,0,-1,0};
int n,m,sx,sy,tx,ty,vis[N][N],dis[N][N],b[N][N][4];
char ch[N][N];
struct node
{
	int x,y;
};
void bfs()
{
	memset(dis,0x3f,sizeof dis),dis[sx][sy]=0;
	queue<node> q;q.push({sx,sy}),vis[sx][sy]=1;
	while(!q.empty())
	{
		node f=q.front();q.pop(),vis[f.x][f.y]=0;
		for(int i=0;i<4;i++)//走到相邻格子
		{
			int nx=f.x+dx[i],ny=f.y+dy[i];
			if(ch[nx][ny]!='#'&&dis[f.x][f.y]+1<dis[nx][ny])
			{
				dis[nx][ny]=dis[f.x][f.y]+1;
				if(!vis[nx][ny])
					q.push({nx,ny}),vis[nx][ny]=1;
			}
		}
		for(int i=0;i<4;i++)//传送，枚举终点
		{
			int d=b[f.x][f.y][i],minn=INF,nx=f.x+dx[i]*d,ny=f.y+dy[i]*d;
			for(int j=0;j<4;j++)//枚举起点
				if(i!=j)
					minn=min(minn,b[f.x][f.y][j]);//取最小值转移
			minn+=dis[f.x][f.y]+1;
			if(dis[nx][ny]>minn)
			{
				dis[nx][ny]=minn;
				if(!vis[nx][ny])
					vis[nx][ny]=1,q.push({nx,ny});
			}
		}
	}
}
void solve()
{
	n=read(),m=read();
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			cin>>ch[i][j];
			if(ch[i][j]=='C')
				sx=i,sy=j;
			if(ch[i][j]=='F')
				tx=i,ty=j;
		}
	for(int i=1;i<=n;i++)//预处理墙壁距离
		for(int j=m;j;j--)
			if(ch[i][j]=='#')
				b[i][j][0]=-1;
			else
				b[i][j][0]=b[i][j+1][0]+1;
	for(int j=1;j<=m;j++)
		for(int i=n;i;i--)
			if(ch[i][j]=='#')
				b[i][j][1]=-1;
			else
				b[i][j][1]=b[i+1][j][1]+1;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			if(ch[i][j]=='#')
				b[i][j][2]=-1;
			else
				b[i][j][2]=b[i][j-1][2]+1;
	for(int j=1;j<=m;j++)
		for(int i=1;i<=n;i++)
			if(ch[i][j]=='#')
				b[i][j][3]=-1;
			else
				b[i][j][3]=b[i-1][j][3]+1;
	bfs();
	if(dis[tx][ty]==INF)
		puts("nemoguce");
	else
		write(dis[tx][ty],"");
}
```

---

## 作者：stoorz (赞：7)


我们考虑本题中人物的行走方式。容易发现，如果人物在$(x,y)$，那么人物就只有以下两种移动方式：

 1. 移动至$(x,y)$上下左右的格子，花费1。
 
 2. 移动到$(x,y)$四个方向的墙壁旁的格子，由于必须移动到一面墙壁旁边才可以使用传送门，所以花费为$(x,y)$最近的墙壁+1。因为走进传送门也需要1的花费。

这显然是一道最短路的题目，~~显然出题人没法用菊花图来卡spfa~~，所以就可以考虑用$spfa$来解决。

对于移动方式一，我们只需要从任意一点向四周连边即可。

对于移动方式二，我们可以$O(nm)$先暴力求出每一个点四个方向的墙壁位置。以上方的墙壁为例：

- 如果$(x-1,y)$为墙壁，则能传送到的位置为$(x,y)$。

- 如果$(x-1,y)$不为墙壁，那么$(x-1,y)$能传送到的位置即为$(x,y)$能传送到的位置，直接用$(x-1,y)$的答案赋值即可。


然后要求出每一个点到最近的墙壁的距离。这个只需要从所有的墙壁开始$bfs$就可以$O(nm)$求出。

然后跑一遍最短路就可以了。
```cpp
#include <queue>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

const int N=510;
const int dx[]={0,0,0,-1,1};
const int dy[]={0,-1,1,0,0};
int n,m,S,T,tot,map[N][N],dis[N*N],d[N][N],go[N*N][5],near[N*N],head[N*N];
char ch;
bool vis[N*N];

struct edge
{
	int next,to,dis;
}e[N*N*8];

void add(int from,int to,int dis)
{
	e[++tot].to=to;
	e[tot].dis=dis;
	e[tot].next=head[from];
	head[from]=tot;
}

int com(int x,int y)
{
	return x*m-m+y;  //给点(x,y)编号
}

void bfs()
{
	queue<int> q;
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++)
			if (map[i][j])  //这个位置是墙壁
			{
				d[i][j]=1;
				q.push(com(i,j));
			}
	while (q.size())
	{
		int u=q.front();
		q.pop();
		int x=(u-1)/m+1,y=(u-1)%m+1;
		for (int i=1;i<=4;i++)
		{
			int xx=x+dx[i],yy=y+dy[i];
			if (map[xx][yy] || d[xx][yy] || xx<1 || xx>n || yy<1 || yy>m) continue;
			if (!d[xx][yy])
			{
				d[xx][yy]=d[x][y]+1;
				q.push(com(xx,yy));
			}
		}
	}
}

void spfa()
{
	memset(dis,0x3f3f3f3f,sizeof(dis));
	queue<int> q;
	q.push(S);
	dis[S]=0; vis[S]=1;
	while (q.size())
	{
		int u=q.front();
		q.pop();
		vis[u]=0;
		for (int i=head[u];~i;i=e[i].next)
		{
			int v=e[i].to;
			if (dis[v]>dis[u]+e[i].dis)
			{
				dis[v]=dis[u]+e[i].dis;	
				if (!vis[v])
				{
					vis[v]=1;
					q.push(v);
				}
			}
		}
	}
}

int main()
{
	memset(head,-1,sizeof(head));
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++)
		{
			while (ch=getchar()) if (ch=='#'||ch=='.'||ch=='F'||ch=='C') break;
			if (ch=='#') map[i][j]=1;
			if (ch=='C') S=com(i,j);
			if (ch=='F') T=com(i,j);
		}
	for (int i=1;i<=n;i++)  //分别求四个方向的墙壁位置
		for (int j=1;j<=m;j++)
			if (map[i][j-1]) go[com(i,j)][1]=com(i,j);
				else go[com(i,j)][1]=go[com(i,j-1)][1];
	for (int i=1;i<=n;i++)
		for (int j=m;j>=1;j--)
			if (map[i][j+1]) go[com(i,j)][2]=com(i,j);
				else go[com(i,j)][2]=go[com(i,j+1)][2];
	for (int j=1;j<=m;j++)
		for (int i=1;i<=n;i++)
			if (map[i-1][j]) go[com(i,j)][3]=com(i,j);
				else go[com(i,j)][3]=go[com(i-1,j)][3];
	for (int j=1;j<=m;j++)
		for (int i=n;i>=1;i--)
			if (map[i+1][j]) go[com(i,j)][4]=com(i,j);
				else go[com(i,j)][4]=go[com(i+1,j)][4];
	bfs();
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++)
		{
			if (map[i][j]) continue;
			for (int k=1;k<=4;k++)
				if (!map[i+dx[k]][j+dy[k]]) add(com(i,j),com(i+dx[k],j+dy[k]),1);
			for (int k=1;k<=4;k++)
				if (go[com(i,j)][k]!=com(i,j)) add(com(i,j),go[com(i,j)][k],d[i][j]-1);
		}
	spfa();
	if (dis[T]>=1e9) printf("nemoguce");
		else printf("%d",dis[T]);
	return 0;
}
```


---

## 作者：Perta (赞：4)

~~其他题解已经把思路讲的很清楚了，这里主要提供一篇比较**规整**的代码。~~

upd：2021.11.9 经评论区的提醒，更正了一点问题。

## 思路

有传送门的存在，我们走到一个点就要考虑三种情况：

- 走路

- 传送

- 走路+传送

那么部分分就可以直接枚举+搜索。

***

传送与走路自然是要选择路径最短的一个。

考虑在每个点可以建的传送门以及什么时候可以进那个传送门。首先，如果在当前点要走到面前（上，左，下，右）的一堵墙面前（墙1），可以先发射一个传送门到那堵墙，再走到离当前点最近的一堵墙（墙2）发射另一个传送门之后进去。

所以可以在当前点和**墙1**建一条边，边的长度为这个点到**墙2**的距离。对整张图都做一个这样的操作，最后我们要求的就是一个单源最短路径。当然，相邻两点的边也不要忘了。

## 代码实现

建图函数是不能少的。由于原图是一个二维平面，所以每个点可以用一个 $id$ 表示。对于点 $(i,j)$，当 $id_{i,j}=(i-1)\cdot \max(n,m)+j$ 时，可以保证点的编号不冲突。

```
inline int id(int x,int y) {return (x-1)*max(n,m)+y;}
void inc(int x,int y,int l) {nxt[++cnt]=first[x],to[cnt]=y,first[x]=cnt,lth[cnt]=l;}
```

要找到离每个可以走的点最近的一堵墙，用一个 BFS 即可。将每一堵墙作为起点，一遍搜过去，如果下一个点还没有搜过，说明这堵墙离这个点最近。

```
for(int i=1;i<=n;i++) for(int j=1;j<=m;j++)
{
	if(a[i][j]=='C') a[i][j]='.',start=id(i,j);
	if(a[i][j]=='F') a[i][j]='.',end=id(i,j);
	if(a[i][j]=='#') BFS[++t].x=i,BFS[t].y=j;
}
for(int h=1;h<=t;h++) for(int i=0;i<4;i++)
{
	int x=BFS[h].x,y=BFS[h].y;
	int tx=x+c[i][0],ty=y+c[i][1];
	if(a[tx][ty]=='.'&&!bs[tx][ty]) BFS[++t].x=tx,BFS[t].y=ty,bs[tx][ty]=bs[x][y]+1;
}
```

这个点面对的上下左右的墙都是可以传送去的，先找到这些墙的编号，再去建边。lt是左边的墙，up是上面的墙，dn是下面的墙，rt是右边的墙。

```
//找可以传送去的墙
for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) if(a[i][j]=='.')
{
	if(a[i][j-1]=='#') lt[i][j]=id(i,j);
	else lt[i][j]=lt[i][j-1];
	if(a[i-1][j]=='#') up[i][j]=id(i,j);
	else up[i][j]=up[i-1][j];
}
for(int i=n;i;i--) for(int j=m;j;j--) if(a[i][j]=='.')
{
	if(a[i][j+1]=='#') rt[i][j]=id(i,j);
	else rt[i][j]=rt[i][j+1];
	if(a[i+1][j]=='#') dn[i][j]=id(i,j);
	else dn[i][j]=dn[i+1][j];
}
//对于相邻点，则建一条边权为1的边
//对于可以传送去的墙，则建一条以离最近墙的距离为边权的边
for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) if(a[i][j]=='.')
{
	if(a[i][j+1]=='.') Inc(id(i,j),id(i,j+1),1);
	if(a[i+1][j]=='.') Inc(id(i,j),id(i+1,j),1);
	if(lt[i][j]!=id(i,j)) inc(id(i,j),lt[i][j],bs[i][j]);
	if(up[i][j]!=id(i,j)) inc(id(i,j),up[i][j],bs[i][j]);
	if(rt[i][j]!=id(i,j)) inc(id(i,j),rt[i][j],bs[i][j]);
	if(dn[i][j]!=id(i,j)) inc(id(i,j),dn[i][j],bs[i][j]);
}
```

建完图后跑一遍最短路即可。

```
for(int i=1;i<=n*m;i++) dis[i]=inf;
dis[start]=0,dijkstra.push((ok){start,0});
while(!dijkstra.empty())
{
	int x=dijkstra.top().x,l=dijkstra.top().y;
	dijkstra.pop();
	if(l>dis[x]) continue;
	for(int i=first[x],v;i;i=nxt[i]) if(dis[v=to[i]]>dis[x]+lth[i])
	{
		dis[v]=dis[x]+lth[i];
		dijkstra.push((ok){v,dis[v]});
	}
}
```

## code

```
#include<bits/stdc++.h>
#define N 505
#define mx 300005
using namespace std;
const int inf=0x3f3f3f;
struct ok{
	int x,y;
	bool operator <(const ok &A) const{return y>A.y;}
}BFS[mx];
int n,m,start,end;//main
int t,bs[N][N],c[4][2]={{0,1},{0,-1},{1,0},{-1,0}};//Bfs
int lt[N][N],rt[N][N],up[N][N],dn[N][N];//init
int nxt[mx<<4],to[mx<<4],first[mx],lth[mx<<4],cnt;//build
priority_queue<ok>dijkstra;
int dis[mx];//Dijkstra
char a[N][N];
inline int id(int x,int y) {return (x-1)*max(n,m)+y;}
void inc(int x,int y,int l) {nxt[++cnt]=first[x],to[cnt]=y,first[x]=cnt,lth[cnt]=l;}
void Inc(int x,int y,int l) {inc(x,y,l),inc(y,x,l);}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%s",a[i]+1);
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++)
	{
		if(a[i][j]=='C') a[i][j]='.',start=id(i,j);
		if(a[i][j]=='F') a[i][j]='.',end=id(i,j);
		if(a[i][j]=='#') BFS[++t].x=i,BFS[t].y=j;
	}
	//Bfs
	for(int h=1;h<=t;h++) for(int i=0;i<4;i++)
	{
		int x=BFS[h].x,y=BFS[h].y;
		int tx=x+c[i][0],ty=y+c[i][1];
		if(a[tx][ty]=='.'&&!bs[tx][ty]) BFS[++t].x=tx,BFS[t].y=ty,bs[tx][ty]=bs[x][y]+1;
	}
	//init
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) if(a[i][j]=='.')
	{
		if(a[i][j-1]=='#') lt[i][j]=id(i,j);
		else lt[i][j]=lt[i][j-1];
		if(a[i-1][j]=='#') up[i][j]=id(i,j);
		else up[i][j]=up[i-1][j];
	}
	for(int i=n;i;i--) for(int j=m;j;j--) if(a[i][j]=='.')
	{
		if(a[i][j+1]=='#') rt[i][j]=id(i,j);
		else rt[i][j]=rt[i][j+1];
		if(a[i+1][j]=='#') dn[i][j]=id(i,j);
		else dn[i][j]=dn[i+1][j];
	}
	//build
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) if(a[i][j]=='.')
	{
		if(a[i][j+1]=='.') Inc(id(i,j),id(i,j+1),1);
		if(a[i+1][j]=='.') Inc(id(i,j),id(i+1,j),1);
		if(lt[i][j]!=id(i,j)) inc(id(i,j),lt[i][j],bs[i][j]);
		if(up[i][j]!=id(i,j)) inc(id(i,j),up[i][j],bs[i][j]);
		if(rt[i][j]!=id(i,j)) inc(id(i,j),rt[i][j],bs[i][j]);
		if(dn[i][j]!=id(i,j)) inc(id(i,j),dn[i][j],bs[i][j]);
	}
	//Dijkstra
	for(int i=1;i<=n*m;i++) dis[i]=inf;
	dis[start]=0,dijkstra.push((ok){start,0});
	while(!dijkstra.empty())
	{
		int x=dijkstra.top().x,l=dijkstra.top().y;
		dijkstra.pop();
		if(l>dis[x]) continue;
		for(int i=first[x],v;i;i=nxt[i]) if(dis[v=to[i]]>dis[x]+lth[i])
		{
			dis[v]=dis[x]+lth[i];
			dijkstra.push((ok){v,dis[v]});
		}
	}
	if(dis[end]!=inf) printf("%d",dis[end]);
	else printf("nemoguce");
	return 0;
}
```

（以前代码习惯为，能在主函数里面装着的就不新建函数，所以看着有点别扭；由于懒得改了，就加了点注释。）

完结撒花owo。

---

## 作者：暌违 (赞：3)

蒟蒻居然A了黑题（雾）~~我才不会告诉你我考场爆0呢~~其实这是一个idea很nice的题目

如果没有翻译的话可以凑合看看这个，[COCI2017-2018 3#Portal](https://www.luogu.org/blog/mycute-is-so-cuteQAQ/luo-gu-p4442-coci2017-20183-portal-ti-mu-tai-yi-post)~~不要脸的推销自己的blog~~

这题是一个矩阵的最短路径，第一时间想到宽搜。可这一题有一个麻烦的传送门怎么处理？

于是我们可以想到一个类似贪心的东西，当我们在宽搜扩展节点时，遇到墙壁才使用传送门。其实就是多了三个扩展规则，在原先矩阵宽搜的基础上把坐标改为所能到达的墙的坐标即可。当然，我们要先预处理出每个点到四个方向墙的距离，这里我用的是4个两重循环暴力枚举。代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int dx[4]={0,0,1,-1};
const int dy[4]={1,-1,0,0};
int n,m,xx,yy,ans;
int visit[505][505];
char a[505][505];
struct data
{
    int x,y,t;
};
queue<data> q;
struct Nobe
{
    int nx[10],ny[10];
}sum[505][505];
void bfs(int x,int y,int t)
{
    data tmp;
    tmp.x=x,tmp.y=y;tmp.t=0;
    q.push(tmp);
    while (!q.empty())
    {
        data t=q.front();
        int kx=-1,ky=-1;
        for (int i=0;i<4;i++)
        {
            int nx=t.x+dx[i];
            int ny=t.y+dy[i];
            int nt=t.t+1;
            if (nx<1||nx>n||ny<1||ny>m||visit[nx][ny]==1) continue;
            if (a[nx][ny]=='#') {kx=nx;ky=ny;continue;
            }
            visit[nx][ny]=1;
            if (nx==xx&&ny==yy) {cout<<nt;exit(0);
            }
            data tmp1;
            tmp1.x=nx;
            tmp1.y=ny;
            tmp1.t=nt;
            q.push(tmp1);
        }	
        if (kx!=-1&&ky!=-1)
        {
            for (int i=1;i<=4;i++)
            {
                if ((kx==sum[t.x][t.y].nx[i]&&ky==sum[t.x][t.y].ny[i])
                ||(visit[sum[t.x][t.y].nx[i]][sum[t.x][t.y].ny[i]]==1)) 
                continue;
                data tmp1;
                tmp1.x=sum[t.x][t.y].nx[i];
                tmp1.y=sum[t.x][t.y].ny[i];
                tmp1.t=t.t+1;
                visit[tmp1.x][tmp1.y]=1;
                if (tmp1.x==xx&&tmp1.y==yy) {cout<<tmp1.t;exit(0);
                }
                q.push(tmp1);
            }
        }
        q.pop();
    }
}
int x,y;
int main()
{
    //freopen("Portal.in","r",stdin);
    //freopen("Portal.out","w",stdout);
    cin>>n>>m;
    for (int i=1;i<=n;i++)
     for (int j=1;j<=m;j++)
      	 {
      	 	cin>>a[i][j];
      	 	if (a[i][j]=='C'){x=i,y=j;
      	 	}
      	 	if (a[i][j]=='F'){xx=i,yy=j;
      	 	}
      	 }
    ans=9999999;
    int ty=0;
    for (int i=1;i<=n;i++)
      for (int j=1;j<=m;j++)
        {
        	if (a[i][j]=='#') 
        	{
        		ty=j;
        	}
        	else
        	{
        		sum[i][j].nx[1]=i;
        		sum[i][j].ny[1]=ty+1;
        	}
        }
    ty=0;
    for (int i=1;i<=n;i++)
      for (int j=m;j>=1;j--)
        {
        	if (a[i][j]=='#') 
        	{
        		ty=j;
        	}
        	else
        	{
        		sum[i][j].nx[2]=i;
        		sum[i][j].ny[2]=ty-1;
        	}
        }
    ty=0;
    for (int i=1;i<=m;i++)
      for (int j=1;j<=n;j++)
        {
        	if (a[j][i]=='#') 
        	{
        		ty=j;
        	}
        	else
        	{
        		sum[j][i].nx[3]=ty+1;
        		sum[j][i].ny[3]=i;
        	}
        }
    ty=0;
    for (int i=1;i<=m;i++)
      for (int j=n;j>=1;j--)
        {
        	if (a[j][i]=='#') 
        	{
        		ty=j;
        	}
        	else
        	{
        		sum[j][i].nx[4]=ty-1;
        		sum[j][i].ny[4]=i;
        	}
        }//
    visit[x][y]=1;
    bfs(x,y,0);
    cout<<"nemoguce";
    return 0;
}
```
然而我们发现这个代码只有90分~~居然有90分出题人真良心~~
为什么呢？我们考虑一组反例：

![](https://s8.postimg.cc/6lluyu6gl/image.png)

在上面的例子中，用我们贪心的方法答案是s1+s2,而实际上是s1，可以hack掉我们的贪心。~~如果你说你可以给bfs队列增加状态并用一些奇怪的姿势来判重那当蒟蒻下面的话是废话~~

我们发现，原来的想法问题出在传送门上。那么我们不妨换个思路：实际上对于每个点而言，它到四面墙的距离中的最小值就是它到四面墙的距离

![](https://s8.postimg.cc/u13s420gl/image.png)
看到这个你想到什么？松弛！那么问题就变为在矩阵里跑最短路的问题了(没写过的左转[Why Did the Cow Cross the Road I G](https://www.luogu.org/problemnew/show/P3659))，只要在原先初始化时多记录一个到最近墙的距离，然后松弛的时候把每个点到四个墙的非最短距离松弛掉即可。（温馨提示：矩阵最短路的点的数量是矩阵的点数500*500，任何接近n^2的算法都可能过不了）~~连我这个nlog(n)都得开O2，你们n^2还想过？~~

这里用了dijkstra+priority-queue的写法，它的思路也是可以的：
	即对于每一种状态都存到小根堆，此时会有重复位置的状态，根据dijkstra的原理，对于已访问的点，其一定是最优的，所以取出状态时，可以把已访问过位置的状态全部清除，这样就不会有重复，效率也不低 
    
以下代码仅供参考，用SPFA是可以过的，~~不过我没写。官方评测可以过的一定是评测机太卡了~~

```
#include<bits/stdc++.h>
using namespace std;
const int INF=99999999;
const int dx[4]={0,0,1,-1};
const int dy[4]={1,-1,0,0};
int n,m,xx,yy,ans;
int midis[505][505];
char a[505][505];
struct data
{
    int x,y,t;
};
data s;
vector<data> v[505][505];
int visit[505][505];
bool operator<(const data&a,const data&b)
{
	return a.t>b.t;
}
int dijkstra()
{
	priority_queue<data> dis;
	dis.push(s);
	while(!dis.empty())
	{
		bool flag=false;
		data tmp;
		do
		{
			if(dis.empty())
			{
				flag=true;break;
			}
			tmp=dis.top();
			dis.pop();
		}while(visit[tmp.x][tmp.y]==1);
		if (flag==true) break;
		visit[tmp.x][tmp.y]=1;
		if (tmp.x==xx&&tmp.y==yy) return tmp.t;
		for (int i=0;i<4;i++)
		{
			data ntmp;
			ntmp.x=tmp.x+dx[i];
			ntmp.y=tmp.y+dy[i];
			ntmp.t=tmp.t+1;
			int nx=ntmp.x,ny=ntmp.y;
			if (nx<1||nx>n||ny<1||ny>m||a[nx][ny]=='#') continue;
			dis.push(ntmp);
		}
		for (int i=0;i<v[tmp.x][tmp.y].size();i++)
		{
			int nx=tmp.x,ny=tmp.y;
			if (v[nx][ny][i].t==midis[nx][ny]) continue;
			data ntmp=tmp;
			ntmp.x=v[nx][ny][i].x;
			ntmp.y=v[nx][ny][i].y;
			ntmp.t+=(midis[nx][ny]+1);
			dis.push(ntmp);
		}
	}
	return -1;
}
int x,y;
int main()
{
    //freopen("Portal.in","r",stdin);
    //freopen("Portal.out","w",stdout);
    std::ios::sync_with_stdio(false);
    cin>>n>>m;
    for (int i=1;i<=n;i++)
     for (int j=1;j<=m;j++)
      	 {
      	 	cin>>a[i][j];
      	 	if (a[i][j]=='C'){s.x=i,s.y=j;a[i][j]='.';
      	 	}
      	 	if (a[i][j]=='F'){xx=i,yy=j;a[i][j]='.';
      	 	}
      	 }
    for (int i=1;i<=n;i++)
     for (int j=1;j<=m;j++)
       midis[i][j]=INF;
    int ty=0;
    for (int i=1;i<=n;i++)
      for (int j=1;j<=m;j++)
        {
        	if (a[i][j]=='#') ty=j;
        	else
        	{
        		midis[i][j]=min(midis[i][j],j-ty-1);//距离一定不能错，要仔细思考，手画例子！！ 
        		data tmp;
        		tmp.x=i;
        		tmp.y=ty+1;
        		tmp.t=j-ty;
        		v[i][j].push_back(tmp);
        	}
        }
    ty=0;
    for (int i=1;i<=n;i++)
      for (int j=m;j>=1;j--)
        {
        	if (a[i][j]=='#') 
        	{
        		ty=j;
        	}
        	else
        	{
        		midis[i][j]=min(midis[i][j],ty-j-1);
        		data tmp;
        		tmp.x=i;
        		tmp.y=ty-1;
        		tmp.t=ty-j;
        		v[i][j].push_back(tmp);
        	}
        }
    ty=0;
    for (int i=1;i<=m;i++)
      for (int j=1;j<=n;j++)
        {
        	if (a[j][i]=='#') 
        	{
        		ty=j;
        	}
        	else
        	{
        		midis[j][i]=min(midis[j][i],j-ty-1);
        		data tmp;
        		tmp.x=ty+1;
        		tmp.y=i;
        		tmp.t=j-ty;
        		v[j][i].push_back(tmp);
        	}
        }
    ty=0;
    for (int i=1;i<=m;i++)
      for (int j=n;j>=1;j--)
        {
        	if (a[j][i]=='#') 
        	{
        		ty=j;
        	}
        	else
        	{
        		midis[j][i]=min(midis[j][i],ty-j-1);
        		data tmp;
        		tmp.x=ty-1;
        		tmp.y=i;
        		tmp.t=ty-j;
        		v[j][i].push_back(tmp);
        	}
        }
    ans=dijkstra();
    if (ans==-1) cout<<"nemoguce";
    else cout<<ans;
    return 0;
}
```
~~随便抄袭，过了算我输~~

---

## 作者：wfycsw (赞：2)

- ## 审题
题中所说的走法有两种：

1. 向周围四联通的格子走一步

2. 发两枪传送门，在一扇传送门前走到另一扇传送门前。

以上两种走法的花费都是 $1$ 。

- ## 思路
首先，用**前缀和**预处理出每个位置往前和往上的障碍物数量:
```cpp
	//g[][]表示行间的障碍物数量，l[][]表示列间的障碍物数量，e[][]表示该位置是否有障碍物。 
	for(RI i=1;i<=n;i=-~i){
		for(RI j=1;j<=m;j=-~j){
			g[i][j]=g[i][j-1]+e[i][j];
			l[i][j]=l[i-1][j]+e[i][j];
		}
	} 
```

接着，用**倍增**求出每个空位的四个方向的障碍物**之前的无障碍区域**的坐标：
```cpp 
	//a[i][j][t][0]和a[i][j][t][1]分别表示坐标(i,j)的t方向的无障碍区域。
	//上行注释的t从0到3分别表示上、下、左、右。 
	for(RI i=1;i<=n;i=-~i)
		for(RI j=1;j<=m;j=-~j)
			if(!e[i][j]){	
				x=i;y=j;p=1;r=y;
				while(p&&r<m)//倍增求解 
					if(r+p<=m&&g[x][r+p]-g[x][r]==0) r+=p,p<<=1;
					else p>>=1;
				if(r<m)
					a[i][j][3][1]=r,a[i][j][3][0]=x;
				p=1;r=y;
				while(p&&r>1)
					if(r>p&&g[x][r]-g[x][r-p-1]==0) r-=p,p<<=1;
					else p>>=1;
				if(r>1) a[i][j][2][1]=r,a[i][j][2][0]=x;
				p=1;r=x;
				while(p&&r<n)
					if(r+p<=n&&l[r+p][y]-l[r][y]==0) r+=p,p<<=1;
					else p>>=1;
				if(r<n) a[i][j][1][0]=r,a[i][j][1][1]=y;
				p=1;r=i;
				while(p&&r>1)
					if(r>p&&l[r][y]-l[r-p-1][y]==0) r-=p,p<<=1;
					else p>>=1;
				if(r>1) a[i][j][0][0]=r,a[i][j][0][1]=y;
			} 
```
最后，再跑一遍堆优的 dijkstra :
```
	//#define ru(x) q.push((du){-f[x],x})
	memset(f,127/3,sizeof f);
	f[qd]=0;ru(qd);
	while(q.size()){
		u=q.top().second;q.pop();
		if(b[u]) continue;
		b[u]=1;
		for(RI i=h[u];i;i=d[i].n){
			v=d[i].t;s=d[i].s;
			if(f[v]>f[u]+s)
				f[v]=f[u]+s,ru(v);
		}
	}
```
- ## 坑点
本题的坑点也是本题的难点就在于建图，以下是我一直卡在 $78$ 分的代码：
```cpp
	for(RI i=1;i<=n;i=-~i)
		for(RI j=1;j<=m;j=-~j)
			if(!e[i][j]){
				s=cg(i,j);
				for(RI t=0;t<4;t=-~t){
					x=mx[t]+i;y=my[t]+j;
					if(pd(x,y)) continue;
					if(!e[x][y]) add(s,cg(x,y));
					else{
						for(RI k=0;k<4;k=-~k)
							if(k!=t&&abs(a[i][j][k][0]-i)+abs(a[i][j][k][1]-j)>0)
								add(s,cg(a[i][j][k][0],a[i][j][k][1]));
					}
				}
			}
``` 
这种贪心之所以有错误，是因为不一定要在走进传送门前一秒才能发传送门枪，你完全可以在走多步之前就开枪，经改正后的建图代码如下：
```cpp
	for(RI i=1;i<=n;i=-~i)
		for(RI j=1;j<=m;j=-~j)
			if(!e[i][j]){
				s=cg(i,j);
				minl=1e9;
				for(RI t=0;t<4;t=-~t){
					x=mx[t]+i;y=my[t]+j;
					if(pd(x,y)) continue;
					if(!e[x][y]) add(s,cg(x,y));
					dis=abs(a[i][j][t][0]-i)+abs(a[i][j][t][1]-j);
					if(dis<minl) minl=dis,p=t;//找到四个方向的最短距离 
				}
				minl=-~minl;//注意走进传送门也需花费$1$ 
				for(RI t=0;t<4;t=-~t)
					if(t!=p)
						add(s,cg(a[i][j][t][0],a[i][j][t][1]),minl);
			}
```
最后奉上完整的AC代码： 
```cpp
#include<bits/stdc++.h>
#define RI register int 
#define pd(x,y) x<1||y<1||x>n||y>m
#define du pair<int,int>
#define ru(x) q.push((du){-f[x],x})
using namespace std;
const int N=502;
const int M=N*N;
struct wu{
	int n,t,s;
}d[M<<3];
int n,m,f[M],h[M],z,g[N][N],l[N][N],a[N][N][4][2];
bool b[M],e[N][N];char c[N];
inline int cg(int x,int y){return (x-1)*m+y;}
inline void add(int u,int v,int s=1){
	z=-~z;d[z].t=v;d[z].s=s;
	d[z].n=h[u];h[u]=z;
}
priority_queue<du>q;
int mx[]={-1,1,0,0},my[]={0,0,-1,1};
inline int min(int x,int y){return x<y?x:y;}
int main(){
	RI u,v,s,x,y,qd,zd,dis,p,r,minl;
	scanf("%d%d",&n,&m);
	for(RI i=1;i<=n;i=-~i){
		scanf("%s",c+1);
		for(RI j=1;j<=m;j=-~j){
			if(c[j]=='C') qd=cg(i,j);
			else if(c[j]=='F') zd=cg(i,j);
			dis=e[i][j]=c[j]=='#';
			g[i][j]=g[i][j-1]+dis;
			l[i][j]=l[i-1][j]+dis;
		}
	}
	for(RI i=1;i<=n;i=-~i)
		for(RI j=1;j<=m;j=-~j)
			if(!e[i][j]){	
				x=i;y=j;
				p=1;r=y;
				while(p&&r<m)
					if(r+p<=m&&g[x][r+p]-g[x][r]==0) r+=p,p<<=1;
					else p>>=1;
				if(r<m)
					a[i][j][3][1]=r,a[i][j][3][0]=x;
				p=1;r=y;
				while(p&&r>1)
					if(r>p&&g[x][r]-g[x][r-p-1]==0) r-=p,p<<=1;
					else p>>=1;
				if(r>1) a[i][j][2][1]=r,a[i][j][2][0]=x;
				p=1;r=x;
				while(p&&r<n)
					if(r+p<=n&&l[r+p][y]-l[r][y]==0) r+=p,p<<=1;
					else p>>=1;
				if(r<n) a[i][j][1][0]=r,a[i][j][1][1]=y;
				p=1;r=i;
				while(p&&r>1)
					if(r>p&&l[r][y]-l[r-p-1][y]==0) r-=p,p<<=1;
					else p>>=1;
				if(r>1) a[i][j][0][0]=r,a[i][j][0][1]=y;
			}
	for(RI i=1;i<=n;i=-~i)
		for(RI j=1;j<=m;j=-~j)
			if(!e[i][j]){
				s=cg(i,j);
				minl=1e9;
				for(RI t=0;t<4;t=-~t){
					x=mx[t]+i;y=my[t]+j;
					if(pd(x,y)) continue;
					if(!e[x][y]) add(s,cg(x,y));
					dis=abs(a[i][j][t][0]-i)+abs(a[i][j][t][1]-j);
					if(dis<minl) minl=dis,p=t;
				}
				minl=-~minl;
				for(RI t=0;t<4;t=-~t)
					if(t!=p)
						add(s,cg(a[i][j][t][0],a[i][j][t][1]),minl);
			}
	memset(f,127/3,sizeof f);
	f[qd]=0;ru(qd);
	while(q.size()){
		u=q.top().second;q.pop();
		if(b[u]) continue;
		b[u]=1;
		for(RI i=h[u];i;i=d[i].n){
			v=d[i].t;s=d[i].s;
			if(f[v]>f[u]+s)
				f[v]=f[u]+s,ru(v);
		}
	}
	if(f[zd]>1e8) printf("nemoguce");
	else printf("%d",f[zd]);
	return 0;
}
```

---

## 作者：__Accepted_ZYF__ (赞：1)

最短路。

但是有点难。

我们注意到两个发射位置一定有一个交点。

然后，我们要是在其他点发射，再走一下发射，其实就等同于**在交点发射传送门**。

**所以，我们可以发现：在一个点，射出传送门，一定是比走走再射是更优的。**

于是，我们就把问题转化成：

1. 可走一步。
2. 可以发射传送门，然后进入一个传送门走到另一个传送门。

这样就可以直接 dijkstra 跑过去了。

接下来我们遇到一个问题：如何计算从一个点发射，到的传送门位置呢？

我们可以使用递推的方式求解。

例如我们计算到左边的墙的距离，可以从 $sz_{i,j-1}$ 转移过来，当这个位置为墙，$sz_{i,j}=-1$，因为我们要的是**到墙旁边的距离**，所以一般情况下，$sz_{i,j}=sz_{i,j-1}+1$。

但是注意到 $j-1$ 可能为 $0$，同理在右边 $j+1$ 可能为 $m+1$，所以要对所有边界 $sz_{i,j}=-1$，不然会出错。

同理，有其他三个方向的转移方程，具体看代码。

然后直接最短路即可。

---

代码：

代码为了方便，$sz$ 记录的是距离，注意我的循环方向和递推方式，别忘了处理边界。

剩下的看注释。

```cpp
#include<bits/stdc++.h>
#define int long long
// #define debug
using namespace std;
const int N=500+10;
int n,m,cx,cy,fx,fy,sz[4][N][N],dis[N][N];
bool vis[N][N];
int dx[]={0,0,1,-1}, // L R D U 注意顺序和方向的对应，不然会出问题
    dy[]={-1,1,0,0}; // L R D U
char a[N][N]; // 迷宫
struct srch{ // 当前的搜索状态
    int x,y,d;
    srch(int _x,int _y,int _d){x=_x,y=_y,d=_d;}
};
bool operator<(srch x,srch y){return x.d>y.d;}
priority_queue<srch>q; // dijkstra 的优先队列
signed main(){
    cin>>n>>m;
    for(int i=0;i<=n+1;i++)for(int j=0;j<=m+1;j++)if(i==0||j==0||i==n+1||j==m+1){
        a[i][j]='#'; // 给边界赋初值
        sz[0][i][j]=-1; // 注意到我们计算的是点到墙的距离，那么我们就可以把墙设为 -1，方便递推
        sz[1][i][j]=-1;
        sz[2][i][j]=-1;
        sz[3][i][j]=-1;
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin>>a[i][j];
            if(a[i][j]=='C')cx=i,cy=j; // 找起点
            if(a[i][j]=='F')fx=i,fy=j; // 找终点
        }
    }
    // 使用递推的方式求出各个方向到墙的距离
    for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)sz[0][i][j]=(a[i][j]=='#'?-1:sz[0][i][j-1]+1); // L，从左边转移到墙的距离，注意墙为 -1，那么墙旁边的就会是 0
    for(int i=1;i<=n;i++)for(int j=m;j>=1;j--)sz[1][i][j]=(a[i][j]=='#'?-1:sz[1][i][j+1]+1); // R，同上，从右边转移到墙的距离
    for(int i=n;i>=1;i--)for(int j=1;j<=m;j++)sz[2][i][j]=(a[i][j]=='#'?-1:sz[2][i+1][j]+1); // D，从下边转移到墙的距离
    for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)sz[3][i][j]=(a[i][j]=='#'?-1:sz[3][i-1][j]+1); // U，从上面转移到墙的距离
    memset(dis,0x3f,sizeof(dis)); // 求最短路
    dis[cx][cy]=0; // 起点
    q.push(srch(cx,cy,0)); // 开始状态
    while(q.size()){ // dijkstra
        srch f=q.top();
        q.pop();
        if(vis[f.x][f.y])continue; // 已经扩展过状态了
        vis[f.x][f.y]=1;
        for(int i=0;i<4;i++){ // 普通移动
            int nx=f.x+dx[i],ny=f.y+dy[i];
            if(nx<1||ny<1||nx>n||ny>m)continue; // 边界
            if(a[nx][ny]=='#')continue; // 障碍物
            if(f.d+1<dis[nx][ny]){ // 更优，选择
                dis[nx][ny]=f.d+1; // 记录答案并计入优先队列
                q.push(srch(nx,ny,f.d+1));
            }
        }
        for(int i=0;i<4;i++){ // Portal 移动
            for(int j=0;j<4;j++)if(i^j){ // 注意方向不能一样
                int nx=f.x+dx[j]*sz[j][f.x][f.y],ny=f.y+dy[j]*sz[j][f.x][f.y]; // 更新位置，这里是先走到 i 方向的传送门，然后转到 j 方向。
                if(nx<1||ny<1||nx>n||ny>m)continue; // 常规最短路的
                if(a[nx][ny]=='#')continue; // 同上
                if(f.d+sz[i][f.x][f.y]+1<dis[nx][ny]){ // 所以，代价是走到 i 传送门的步数加上传送的代价
                    dis[nx][ny]=f.d+sz[i][f.x][f.y]+1; // 更新
                    q.push(srch(nx,ny,dis[nx][ny])); // 再更新
                }
            }
        }
    }
    #ifdef debug // debug 不用管
        for(int i=1;i<=n;i++){for(int j=1;j<=m;j++){cout<<dis[i][j]<<" ";}cout<<"\n";}
        for(int i=1;i<=n;i++){for(int j=1;j<=m;j++){cout<<sz[0][i][j]<<" ";}cout<<"\n";}
        for(int i=1;i<=n;i++){for(int j=1;j<=m;j++){cout<<sz[1][i][j]<<" ";}cout<<"\n";}
        for(int i=1;i<=n;i++){for(int j=1;j<=m;j++){cout<<sz[2][i][j]<<" ";}cout<<"\n";}
        for(int i=1;i<=n;i++){for(int j=1;j<=m;j++){cout<<sz[3][i][j]<<" ";}cout<<"\n";}
    #endif
    if(dis[fx][fy]==dis[0][0])cout<<"nemoguce\n";
    else cout<<dis[fx][fy]<<"\n"; // 判无解和输出答案
    return 0;
}
```

注意不要犯弱智错误。

---

## 作者：Planetary_system (赞：0)

## 题面解释：
网格图中求单源最短路，可以通过墙传送。

## 思路分析：
普通的网格图求最短路是我们熟悉的，洪水填充即可。但是考虑加上传送之后，入队的点的 $dis$ 不具有单调性了，使用 SPFA 即可（是的没死，蒟蒻不会 Dijkstra）。

```cpp
node v={u.x+nx[d],u.y+ny[d]};
if(mp[v.x][v.y]=='#')continue;
if(dis[v.x][v.y]>dis[u.x][u.y]+1){
	dis[v.x][v.y]=dis[u.x][u.y]+1;
	if(!vis[v.x][v.y])q.push(v),vis[v.x][v.y]=1;
}
```

接下来思考如何进行传送。对于每个点，易证传送的目标点一定为 $4$ 个方向最近的墙边的点之一（反证法，假设路径上任意点的 $4$ 个方向最近的墙边的点之一均不是传送的目标，则无法打上传送门进行传送）。而传送的代价即进入传送门的距离 $+1$，此代价采用贪心计算，因为从任意方向的墙进行传送是等价的，只需最小的即可。

```cpp
node v={u.x+nx[d]*w[d][u.x][u.y],
		u.y+ny[d]*w[d][u.x][u.y]};
int mn=INF;
for(int p=0;p<4;p++)
	mn=min(mn,w[p][u.x][u.y]+1);
if(dis[v.x][v.y]>dis[u.x][u.y]+mn){
	dis[v.x][v.y]=dis[u.x][u.y]+mn;
	if(!vis[v.x][v.y])vis[v.x][v.y]=1,q.push(v);
}
```

根据上述做法，我们需预处理出各方向最近的墙的距离（即上述代码中的 $w$），此处不难，注意循环顺序与方向的对应。

题目中说同时只能存在两个传送门，这其实是诈骗条件。由于打传送门的时间忽略，而 $1$ 次传送只需要 $2$ 扇门（连续传送再传送的情况显然不优），因此在过程中我们只打需要的传送门即可，故而可忽略此要求。

关于 `78pts` 的做法，没经历过不予解释（但因唐人错误调了 $1$ 天，转移时 $x$ 和 $y$ 打反竟有 `54pts`？！）。以及 [双倍经验](https://www.luogu.com.cn/problem/P6742)，微调即可（去掉了诈骗条件，思维难度稍低一点）。

完结撒花！！！

---

## 作者：zifanwang (赞：0)

考虑移动方式，有以下两种可能：

- 向相邻的格子移动一格，代价为 $1$。
- 使用传送门。等价于向四个方向中的某个方向一直移动，直到碰到墙壁，代价为移动到最近的靠墙格子的步数。

做一遍 BFS 求出每个点移动到最近的靠墙格子的步数，剩下的 dijistra 求即可。

参考代码：
```cpp
#include<bits/stdc++.h>
#define mxn 1003
#define rep(i,a,b) for(int i=a;i<=b;++i)
#define rept(i,a,b) for(int i=a;i<b;++i)
#define drep(i,a,b) for(int i=a;i>=b;--i)
using namespace std;
struct node{
	int x,y;
};
inline bool operator<(node x,node y){
	return x.x<y.x; 
}
int n,m,sx,sy,tx,ty,d[mxn][mxn],f[mxn][mxn],f1[mxn][mxn],f2[mxn][mxn],f3[mxn][mxn],f4[mxn][mxn];
char s[mxn][mxn];
queue<node>q;
priority_queue<pair<int,node>>pq;
bool v[mxn][mxn];
const int dx[4]={1,-1,0,0},dy[4]={0,0,1,-1};
bool check(int x,int y){
	return s[x-1][y]=='#'||s[x+1][y]=='#'||s[x][y-1]=='#'||s[x][y+1]=='#';
}
inline void upd(int x,int y,int d){
	if(f[x][y]<=d||s[x][y]=='#')return;
	f[x][y]=d;
	pq.push({-d,{x,y}});
}
signed main(){
	scanf("%d%d",&n,&m),n-=2,m-=2;
	rep(i,0,n+1){
		scanf("%s",s[i]);
		rep(j,1,m){
			if(s[i][j]=='C')sx=i,sy=j;
			else if(s[i][j]=='F')tx=i,ty=j;
		}
	}
	rep(i,1,n){
		rep(j,1,m){
			if(check(i,j)&&s[i][j]!='#'){
				d[i][j]=1;
				q.push({i,j});
			}
		}
	}
	while(q.size()){
		int x=q.front().x,y=q.front().y;q.pop();
		rept(i,0,4){
			int xx=x+dx[i],yy=y+dy[i];
			if(xx<1||yy<1||xx>n||yy>m||s[xx][yy]=='#')continue;
			if(!d[xx][yy]){
				d[xx][yy]=d[x][y]+1;
				q.push({xx,yy});
			}
		}
	}
	rep(i,1,n){
		f2[i][m+1]=m+1;
		rep(j,1,m)f1[i][j]=s[i][j-1]=='#'?j:f1[i][j-1];
		drep(j,m,1)f2[i][j]=s[i][j+1]=='#'?j:f2[i][j+1];
	}
	rep(j,1,m){
		f4[n+1][j]=n+1;
		rep(i,1,n)f3[i][j]=s[i-1][j]=='#'?i:f3[i-1][j];
		drep(i,n,1)f4[i][j]=s[i+1][j]=='#'?i:f4[i+1][j];
	}
	memset(f,0x3f,sizeof(f));
	f[sx][sy]=0;
	pq.push({0,{sx,sy}});
	while(pq.size()){
		int x=pq.top().second.x,y=pq.top().second.y;pq.pop();
		if(v[x][y])continue;
		v[x][y]=1;
		if(f1[x][y])upd(x,f1[x][y],f[x][y]+d[x][y]);
		if(f2[x][y]<=m)upd(x,f2[x][y],f[x][y]+d[x][y]);
		if(f3[x][y])upd(f3[x][y],y,f[x][y]+d[x][y]);
		if(f4[x][y]<=n)upd(f4[x][y],y,f[x][y]+d[x][y]);
		rept(i,0,4){
			int xx=x+dx[i],yy=y+dy[i];
			if(xx<1||yy<1||xx>n||yy>m)continue;
			upd(xx,yy,f[x][y]+1);
		}
	}
	if(f[tx][ty]>1e9)puts("nemoguce");
	else cout<<f[tx][ty];
	return 0;
}
```

---

## 作者：fly_x (赞：0)

# BFS题解
## 前言

~~说句闲话，研究传送门的最好方法是…~~

~~A 了这道题。~~

[P6742](https://www.luogu.com.cn/problem/P6742) 是这题的阉割版，可以去做一下。

## 思路
这道题只是在常规 BFS 的基础上多了几个传送门，~~而传送门只能在墙上~~，所以我们可以预处理出**每个点到四周墙壁**的距离，然后跑 BFS。

跑 BFS 时分别处理**直接走过去**所需的时间和**到最近的墙上开门**传送的时间。

注意要开优先队列，**优先处理时间短的点**。

其他细节看代码吧。
## 代码
```cpp
#include <bits/stdc++.h>
#define QAQ cout << 1 << endl;
// 有特别意义的符号
using namespace std;
const int inf = 1145141919;
// 有特别意义的数字
int r, c, sx, sy, ex, ey;
int dx[] = {0, 0, 1, -1};
int dy[] = {1, -1, 0, 0};
int p[4][1005][1005];
struct node{
	int x, y, d;
	bool operator < (node a) const{
		return d > a.d;
	}
};
bool check(int x, int y){return x > 0 && y > 0 && x <= r && y <= c;}
priority_queue <node> q;
// 优先处理时间短的点
int dis[1005][1005];
char g[1005][1005];
int main() {
	scanf("%d%d", &r, &c);
	for (int i = 1; i <= r; i++)
		scanf("%s", g[i]+1);
	for (int i = 1; i <= r; i++)
		for (int j = 1; j <= c; j++)
			if (g[i][j] == 'C') sx = i, sy = j;
			else if (g[i][j] == 'F') ex = i, ey = j, dis[i][j] = inf;
			else dis[i][j] = inf;
	memset(p, -1, sizeof p);
    // 初始化
	for (int j = c; j >= 1; j--) for (int i = 1; i <= r; i++)
		if (g[i][j] != '#') p[0][i][j] = p[0][i][j+1] + 1;
	for (int j = 1; j <= c; j++) for (int i = 1; i <= r; i++)
		if (g[i][j] != '#') p[1][i][j] = p[1][i][j-1] + 1;
	for (int i = r; i >= 1; i--) for (int j = 1; j <= c; j++) 
		if (g[i][j] != '#') p[2][i][j] = p[2][i+1][j] + 1;
	for (int i = 1; i <= r; i++) for (int j = 1; j <= c; j++) 
		if (g[i][j] != '#') p[3][i][j] = p[3][i-1][j] + 1;
    // 预处理到墙壁的距离
    // 注意循环的顺序与方向！
	node s; s.x = sx, s.y = sy;
	s.d = dis[sx][sy] = 0; q.push(s); 
	while (!q.empty()){
		node u = q.top(); q.pop(); node v;
		if (u.x == ex && u.y == ey){
			cout << u.d << endl;
			return 0;
		}
		for (int i = 0; i < 4; i++){
			v.x = u.x+dx[i], v.y = u.y+dy[i];
			if (g[v.x][v.y] != '#' && check(v.x, v.y))
				if (dis[v.x][v.y] > u.d + 1){
					v.d = dis[v.x][v.y] = u.d + 1;
					q.push(v);
				}
		} // 直接向四周走
		for (int i = 0; i < 4; i++){
			v.x = u.x + dx[i] * p[i][u.x][u.y];
			v.y = u.y + dy[i] * p[i][u.x][u.y];
            // 这个方向上的墙的位置
			int mn = inf;
			for (int j = 0; j < 4; j++) 
				if (i != j) mn = min(mn, p[j][u.x][u.y]+1);
            // 记录到达最近的墙所需的时间
            // mn + u.d 就是累计到这里的时间
			if (dis[v.x][v.y] > mn + u.d){
				v.d = dis[v.x][v.y] = mn + u.d;
				q.push(v);
			}
		} // 造传送门！
	}
	cout << "nemoguce";
    // 没搜到终点
	return 0;
}
```
## 后记
求审核通过 QAQ

~~我要玩传送门！~~

---

## 作者：Hide_In_The_Shadow (赞：0)

## Portal 题解

题目大意，从 $C$ 走到 $F$ ，方式有两种，一是暴力走，耗时 $1s$，二是造传送门，传送门最多同时存在两个，之前的都会消失，传送门两端互通，造传送门不耗时，走传送门耗时。

-----

### Part1

纯 BFS，不考虑传送门，可以得 31pts。

### Part2

只考虑在墙边开传送门的情况，也就是在每个墙边的点进行额外扩展，连续开两枪，一枪朝着挨着的墙，一枪朝着没挨着的墙，进行代价为 $1$ 的传送，更新可通过该传送门到达的节点，可以得到 85pts。

### Part3

可以在 Part2 的基础上考虑进行更深层次的扩展，其实也是连续开两枪，只不过代价变成了到最近的墙的距离。

具体细节：

- 先预处理出每个点到其上下左右四个方向的第一堵墙，然后记录到最近的一个方向的墙的距离。
- 然后考虑扩展，暴力扩展和用传送门跳可以一起扩展，这里有个小只因巧，可以使用优先队列优化 BFS，每次用点权最小的进行更新，跟 Dj 一样做到 $O(nm \log(nm))$ 的效率。
- 最后如果更新到 $F$ 点则有答案，反之则无解。

这样操作的最优性也可以证明，考虑往回找上一个传送门，那么上一个传送门的位置一定有一堵墙，与其走已经走过的路，不如再开一个传送门，反而可以省去一些迂回的距离。

复杂度的限制其实是预处理，效率最大 $O(nm\times \max(n,m))$。

## CODE

```c++
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int inf=0x3f3f3f3f;
template<typename T>inline void read(T &x){
	x=0;
	char c=getchar();
	T ret=0;
	while(!isdigit(c))ret|=!(c^'-'),c=getchar();
	while(isdigit(c))x=(x<<3)+(x<<1)+(c^48),c=getchar();
	if(ret)x=(~x)+1;
	return;
}
template<typename T>inline void print(T x){
	if(x<0)putchar('-'),x=(~x)+1;
	if(x>9)print(x/10);
	putchar((x-x/10*10)^48);
	return;
}
template<typename T>inline void wr1(T x){
	print(x);
	putchar(' ');
	return;
}
template<typename T>inline void wr2(T x){
	print(x);
	putchar('\n');
	return;
}
struct jl{
	int u,d,l,r,mi;
}nm[510][510];
int n,m,dis[510][510],c1[]={1,0,-1,0},c2[]={0,1,0,-1};
bool pd[510][510],vis[510][510];
char mp[510][510];
priority_queue<pair<int,pair<int,int>>>q;
pair<int,int>s;
pair<int,int>t;
jl work(int x,int y){//预处理每个点到四个方向墙的距离
	jl a;
	int X=x-1,Y=y;
	while(mp[X][Y]!='#'&&X>0){
		X--;
	}
	if(X==0)a.u=0;
	else a.u=x-X;
	X=x+1,Y=y;
	while(mp[X][Y]!='#'&&X<=n){
		X++;
	}
	if(X==n+1)a.d=0;
	else a.d=X-x;
	X=x,Y=y-1;
	while(mp[X][Y]!='#'&&Y>0){
		Y--;
	}
	if(Y==0)a.l=0;
	else a.l=y-Y;
	X=x,Y=y+1;
	while(mp[X][Y]!='#'&&Y<=m){
		Y++;
	}
	if(Y==m+1)a.r=0;
	else a.r=Y-y;
	a.mi=1e9;
	if(a.l){
		a.mi=min(a.mi,a.l);
	}
	if(a.r){
		a.mi=min(a.mi,a.r);
	}
	if(a.u){
		a.mi=min(a.mi,a.u);
	}
	if(a.d){
		a.mi=min(a.mi,a.d);
	}
	return a;
}
int main(){
//	freopen("portal.in","r",stdin);
//	freopen("portal.out","w",stdout);
    read(n);
    read(m);
    for(int i=1;i<=n;++i){
    	scanf("%s",mp[i]+1);
	}
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){//预处理
			if(mp[i][j]=='C'){
				s.first=i;
				s.second=j;
				nm[i][j]=work(i,j);
			}
			else{
				if(mp[i][j]=='F'){
					t.first=i;
					t.second=j;
					nm[i][j]=work(i,j);
				}
				else{
					if(mp[i][j]=='.'){
						nm[i][j]=work(i,j);
					}
				}
			}
		}
	}
	memset(dis,0x3f,sizeof dis);
	dis[s.first][s.second]=0;
	q.push(make_pair(0,s));
	while(!q.empty()){
		int x=q.top().second.first;
		int y=q.top().second.second;
		q.pop();
		if(vis[x][y])continue;
		vis[x][y]=1;
		for(int i=0;i<4;++i){//暴力扩展
			int xx=x+c1[i];
			int yy=y+c2[i];
			if(xx>0&&xx<=n&&yy>0&&yy<=m&&mp[xx][yy]!='#'){
				if(dis[xx][yy]>dis[x][y]+1){
					dis[xx][yy]=dis[x][y]+1;
					q.push(make_pair(-dis[xx][yy],make_pair(xx,yy)));
				}
			}
		}
		if(nm[x][y].l>nm[x][y].mi){//以下四个都是传送门扩展
			int yy=y-nm[x][y].l+1;
			if(dis[x][yy]>dis[x][y]+nm[x][y].mi){
				dis[x][yy]=dis[x][y]+nm[x][y].mi;
				q.push(make_pair(-dis[x][yy],make_pair(x,yy)));
			}
		}
		if(nm[x][y].r>nm[x][y].mi){
			int yy=y+nm[x][y].r-1;
			if(dis[x][yy]>dis[x][y]+nm[x][y].mi){
				dis[x][yy]=dis[x][y]+nm[x][y].mi;
				q.push(make_pair(-dis[x][yy],make_pair(x,yy)));
			}
		}
		if(nm[x][y].u>nm[x][y].mi){
			int xx=x-nm[x][y].u+1;
			if(dis[xx][y]>dis[x][y]+nm[x][y].mi){
				dis[xx][y]=dis[x][y]+nm[x][y].mi;
				q.push(make_pair(-dis[xx][y],make_pair(xx,y)));
			}
		}
		if(nm[x][y].d>nm[x][y].mi){
			int xx=x+nm[x][y].d-1;
			if(dis[xx][y]>dis[x][y]+nm[x][y].mi){
				dis[xx][y]=dis[x][y]+nm[x][y].mi;
				q.push(make_pair(-dis[xx][y],make_pair(xx,y)));
			}
		}
	}
	if(dis[t.first][t.second]>1e9){//不能到达
		puts("nemoguce");
	}
	else{
		print(dis[t.first][t.second]);
	}
	return 0;
}

```

---

## 作者：Gmt丶FFF (赞：0)

首先考虑传送门的作用，那就是使我能更快地走到终点，也就是跳过一段路经。

那么既然这样，我们就在需要传送时先打传送门，然后找到一个墙打传送门再传送即可。

很明显选择的墙即是离自己最近的墙。

但是这样明显麻烦了，实际上一定会存在自己或另一个不是墙的点能同时打到离自己最近的墙与要打传送门的墙。

考虑证明，其实很简单，如果不存在这个位置，那么离自己最近的墙一定是能同时打到他们的点，这样打到的墙就不符合要求了。

那么我们可以先预处理建图，然后跑最短路。

预处理建图时先找到每一个点四周的墙，其中离的最近的墙是自己的传送起点，而较远的其他墙是传送终点，对每个传送终点连接边权为到传送起点的时间加传送时间的边即可。

然后对于每一个点，向相邻非墙点连边，跑最短路即可。

时间复杂度：$O(n\times m\times\log(n\times m))$。

```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<cstring>
#include<queue>
using namespace std;
const int N=505;
int n,m,x1,y1,x2,y2,dis[N*N];
char s[N][N];
vector<int>b[N*N];
vector<pair<int,int> >a[N*N];
inline int clac(int x,int y)
{
	return (x-1)*m+y; 
}
inline pair<int,int> position(int x)
{
	return {(x-1)/m+1,(x-1)%m+1};
}
inline int tabs(int x)
{
	return x>0?x:-x;
}
inline int distance(int x,int y)
{
	int xt=position(x).first,yt=position(x).second,xp=position(y).first,yp=position(y).second;
	return tabs(xt-xp)+tabs(yt-yp);
}
struct node2
{
	int name,data;
};
priority_queue<node2>q;
bool operator <(node2 fi,node2 se)
{
	return fi.data>se.data;
}
void dijstra()
{
	memset(dis,0x3f,sizeof(dis));
	dis[clac(x1,y1)]=0;
	q.push({clac(x1,y1),0});
	while(!q.empty())
	{
		int x=q.top().name;
		q.pop();
		int len=a[x].size();
		for(int i=0;i<len;i++)
		{
			if(dis[x]+a[x][i].second<dis[a[x][i].first])
			{
				dis[a[x][i].first]=a[x][i].second+dis[x];
				q.push({a[x][i].first,dis[a[x][i].first]});
			}
		}
	}
}
int main()
{
	freopen("portal.in","r",stdin);
	freopen("portal.out","w",stdout);
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)scanf("%s",s[i]+1);
	for(int i=1;i<=n;i++)
	{
		int bef=0;
		for(int j=1;j<=m;j++)
		{
			if(s[i][j]=='#')bef=j;
			else if(bef)b[clac(i,j)].push_back(clac(i,bef+1));
		}
		bef=0;
		for(int j=m;j>=1;j--)
		{
			if(s[i][j]=='#')bef=j;
			else if(bef)b[clac(i,j)].push_back(clac(i,bef-1));
		}
	}
	for(int j=1;j<=m;j++)
	{
		int bef=0;
		for(int i=1;i<=n;i++)
		{
			if(s[i][j]=='#')bef=i;
			else if(bef)b[clac(i,j)].push_back(clac(bef+1,j));
		}
		bef=0;
		for(int i=n;i>=1;i--)
		{
			if(s[i][j]=='#')bef=i;
			else if(bef)b[clac(i,j)].push_back(clac(bef-1,j));
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(s[i][j]=='#')continue;
			if(s[i][j]=='C')x1=i,y1=j;
			if(s[i][j]=='F')x2=i,y2=j;
			int len=b[clac(i,j)].size();
			int minn=1e9;
			for(int k=0;k<len;k++)minn=min(minn,distance(b[clac(i,j)][k],clac(i,j)));
			for(int k=0;k<len;k++)a[clac(i,j)].push_back({b[clac(i,j)][k],minn+1});
			if(i>1&&s[i-1][j]!='#')a[clac(i,j)].push_back({clac(i-1,j),1});
			if(i<n&&s[i+1][j]!='#')a[clac(i,j)].push_back({clac(i+1,j),1});
			if(j>1&&s[i][j-1]!='#')a[clac(i,j)].push_back({clac(i,j-1),1});
			if(j<m&&s[i][j+1]!='#')a[clac(i,j)].push_back({clac(i,j+1),1});
		}
	}
	dijstra();
	if(dis[clac(x2,y2)]>1e9)printf("nemoguce");
	else printf("%d",dis[clac(x2,y2)]);
	return 0;
}
```


---

## 作者：Natsume_Rin (赞：0)

## 题目大意

有两种移动方式，向周围四个格子移动和在面向的墙上建传送带，求解从起点开始到终点的最短时间。

$\texttt{Data Range}$：$1 \leq n,m \leq 500$。

## 分析

向周围四个格子建立传送带，**实质上可以转为一种操作**：

设从一个格子 $(x,y)$ 向四周直着走，碰到墙的最短步数为 $s$，走到尽头可以走到 $(x_0,y_0)$、$(x_1,y_1)$、$(x_2,y_2)$、$(x_3,y_3)$，那么可以看做可以从 $(x,y)$ 可以走到 $(x_0,y_0)$、$(x_1,y_1)$、$(x_2,y_2)$、$(x_3,y_3)$ 耗费 $s$ 的时间。

那么有了这一个，就变成了一个非常普通的最短路了。用 Dijkstra 实现即可。

那么怎么求出 $(x_0,y_0)$ 这些点呢？事实上可以暴力从每一个点开始向四个方向循环，时间复杂度 $O(n^3)$（这里视为 $n,m$ 同阶），这样子是可以过的。

怎么更高效呢？考虑到一个可走格子 $(x,y)$ 左边的可走格子 $(x,y-1)$ 和 $(x,y)$ 一直往左走走到的格子是一样的。所以可以用记忆化搜索来实现。

代码：

```cpp
inline go dfs(const int x, const int y, const int dir){
	if(vis[x][y][dir].x>0){return vis[x][y][dir];} 
	RI ax, ay;
	ax=x+dx[dir], ay=y+dy[dir];
	if(ok(ax,ay)) return vis[x][y][dir]=dfs(ax,ay,dir);
	ctmp.x=x, ctmp.y=y;
	return vis[x][y][dir]=ctmp;
}//记忆化搜索 
```

其中 $dir$ 是走的方向，$x,y$ 是当前点坐标，$vis$ 数组中存的便是 $(x_0,y_0)$ 等一系列点。

这样子完成了重新构图，最后跑 Dijkstra 即可，代码如下：

```cpp
#include<bits/stdc++.h>
#define RI register int

using namespace std;
namespace IO {
	inline int read() {
		RI X=0,w=0;register char ch=0;
		while(!isdigit(ch)) {w|=ch=='-';ch=getchar();}
		while(isdigit(ch)) X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
		return w?-X:X;
	}
	inline void write(int x){
		if(x>9){write(x/10);putchar('0'+x%10);}
		else{putchar(x+'0');}
	}
}using namespace IO;

const int MAXN = 502;
const int dx[]={1,-1,0,0}, dy[]={0,0,1,-1};

int n, m;
int stx, sty, edx, edy;
int dis[MAXN][MAXN];
int Min[MAXN][MAXN];

bool vist[MAXN][MAXN];

struct go{
	int x, y;
	go(){x=y=0;}
}vis[MAXN][MAXN][5], ctmp;

char mapp[MAXN][MAXN];

struct bfs_Queue{
	int x, y;
	bool friend operator < (const bfs_Queue a, const bfs_Queue b){return dis[a.x][a.y]>dis[b.x][b.y];}
}tmp, now; 

priority_queue<bfs_Queue>Q;//本质上是一个小根堆 

inline bool ok(const int x, const int y){return 1<=x && x<=n && 1<=y && y<=m && mapp[x][y]!='#';}//懒得写这么多，直接放在函数里了 

inline go dfs(const int x, const int y, const int dir){
	if(vis[x][y][dir].x>0){return vis[x][y][dir];} 
	RI ax, ay;
	ax=x+dx[dir], ay=y+dy[dir];
	if(ok(ax,ay)) return vis[x][y][dir]=dfs(ax,ay,dir);
	ctmp.x=x, ctmp.y=y;
	return vis[x][y][dir]=ctmp;
}//记忆化搜索 

inline void bfs(){
	memset(dis,127/3,sizeof dis);//dis 置为很大的一个数字 
	tmp.x=stx, tmp.y=sty;dis[stx][sty]=0;//起点置为 0 
	Q.push(tmp);RI ax, ay;//优队 
	while(!Q.empty()){
		now=Q.top();Q.pop();
		if(vist[now.x][now.y]) continue;
		vist[now.x][now.y]=1;
		for(RI i=0;i<4;++i){
			ax=now.x+dx[i], ay=now.y+dy[i];
			if(ok(ax,ay) && dis[ax][ay]>dis[now.x][now.y]+1){
				dis[ax][ay]=dis[now.x][now.y]+1;
				tmp.x=ax, tmp.y=ay;
				Q.push(tmp);
			}
		}
		for(RI i=0;i<4;++i){
			ax=vis[now.x][now.y][i].x, ay=vis[now.x][now.y][i].y;
			if(ok(ax,ay) && dis[ax][ay]>dis[now.x][now.y]+Min[now.x][now.y]){
				dis[ax][ay]=dis[now.x][now.y]+Min[now.x][now.y];
				tmp.x=ax, tmp.y=ay;
				Q.push(tmp);
			}
		}
	}
	if(dis[edx][edy]>1e7) puts("nemoguce");
	else write(dis[edx][edy]);
}//不解释了 

int main(){
	n=read(), m=read();
	for(RI i=1;i<=n;++i){
		scanf("%s",mapp[i]+1);
		for(RI j=1;j<=m;++j){
			if(mapp[i][j]=='C') stx=i, sty=j;
			if(mapp[i][j]=='F') edx=i, edy=j;
		}
	}//读入 
	for(RI i=1;i<=n;++i){
		for(RI j=1;j<=m;++j){
			if(mapp[i][j]=='#') continue;
			Min[i][j]=2147483647;
			for(RI p=0;p<4;++p){
				vis[i][j][p]=dfs(i,j,p);
				Min[i][j]=min(Min[i][j],abs(i-vis[i][j][p].x)+abs(j-vis[i][j][p].y)+1);
			}
		}
	}//传送的操作可以看做用 Min[i][j] 的代价从当前格子走到四个方向的任意一个方向的尽头，这一部分是用的记忆化搜索预处理 
	bfs();//其实是 Dijkstra 
	return 0;
}
```



---

## 作者：哈撒各一 (赞：0)

我们遇到这道题和 [UVA1714 Keyboarding](https://www.luogu.com.cn/problem/UVA1714) 这种可以一次移动一行的题。


我们用一般的 dfs 和 bfs 时间复杂度肯定是不够的。

所以我们就要预处理出他能够移动到的位置。

然后把他的每次移动当成长度为边权。

然而是求起始点到终止点的最短移动步数。

我们只需要用 dijkstra 快速求出最短移动步数。

虽然我们发现使用传送枪要消耗一点的时间。

但是使用传送枪一定是比不使用传送枪更优的。

所以我们对于每一个点的使用传送枪情况就是对最近的一面墙开枪，然后对目的地开枪。

这样我们要走到最近的墙的时间就是 $ minlen $ 走到其他三面墙的时间就是 $ minlen+1 $ 。

**但是我们在考虑的时候会想：** 

现在一个点开一枪，再走到其他点再开一枪,但是我们发现这种走法并不会更优。

**证明如下：**

因为我们的每一种走法都是对于一个障碍物的不同处理方式，我们不管怎么射子弹，我们到达目的地的最短距离永远都是：这个点到最近的墙的距离 $ +1 $。

那么我们可以很轻易的写出预处理的代码块。

```cpp
inline void draw(){
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			if(s[i][j]=='#')continue;
			for(int k=0;k<4;++k){
				int nx=i+mx[k];
				int ny=j+my[k];
				if(s[nx][ny]=='#'||s[nx][ny]=='$')continue;
				add(change[i][j],change[nx][ny],1);
			}
			int l1=0,l2=0,l3=0,l4=0;
			int nx=i;
			while(s[nx][j]!='#'&&s[nx][j]!='$')nx++;
			l1=nx-i-1;
			if(s[nx][j]=='$')l1=INF;
			nx=i;
			while(s[nx][j]!='#'&&s[nx][j]!='$')nx--;
			l2=i-nx-1;
			if(s[nx][j]=='$')l2=INF;
			int ny=j;
			while(s[i][ny]!='#'&&s[i][ny]!='$')ny++;
			l3=ny-j-1;
			if(s[i][ny]=='$')l3=INF;
			ny=j;
			while(s[i][ny]!='#'&&s[i][ny]!='$')ny--;
			l4=j-ny-1;
			if(s[i][ny]=='$')l4=INF;
			int minn=min(min(l1,l2),min(l3,l4));
			if(l1!=INF){
				if(l1==minn)add(change[i][j],change[i+l1][j],minn);
				else add(change[i][j],change[i+l1][j],minn+1);
			}
			if(l2!=INF){
				if(l2==minn)add(change[i][j],change[i-l2][j],minn);
				else add(change[i][j],change[i-l2][j],minn+1);
			}
			if(l3!=INF){
				if(l3==minn)add(change[i][j],change[i][j+l3],minn);
				else add(change[i][j],change[i][j+l3],minn+1);
			}
			if(l4!=INF){
				if(l4==minn)add(change[i][j],change[i][j-l4],minn);
				else add(change[i][j],change[i][j-l4],minn+1);
			}
		}
	}
} 
```


那么我们在最难的部分写完之后就可以套模板就行了。

**CODE**

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 510
#define M 1400010
#define INF 0x3f3f3f3f
#define PII pair<int,int>
struct Edge{
	int ne,to,dis;
	#define ne(x) edge[x].ne
	#define to(x) edge[x].to
	#define dis(x) edge[x].dis
}edge[M<<1];
int head[N*N],idx,n,m,st,ed,o=1;
char s[N][N];
int change[N][N],f[N*N];
int mx[4]={0,0,1,-1},my[4]={1,-1,0,0};
inline void add(int from,int to,int dis){
	ne(++idx)=head[from];
	to(idx)=to;
	dis(idx)=dis;
	head[from]=idx;
}
inline void draw(){
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			if(s[i][j]=='#')continue;
			for(int k=0;k<4;++k){
				int nx=i+mx[k];
				int ny=j+my[k];
				if(s[nx][ny]=='#'||s[nx][ny]=='$')continue;
				add(change[i][j],change[nx][ny],1);
			}
			int l1=0,l2=0,l3=0,l4=0;
			int nx=i;
			while(s[nx][j]!='#'&&s[nx][j]!='$')nx++;
			l1=nx-i-1;
			if(s[nx][j]=='$')l1=INF;
			nx=i;
			while(s[nx][j]!='#'&&s[nx][j]!='$')nx--;
			l2=i-nx-1;
			if(s[nx][j]=='$')l2=INF;
			int ny=j;
			while(s[i][ny]!='#'&&s[i][ny]!='$')ny++;
			l3=ny-j-1;
			if(s[i][ny]=='$')l3=INF;
			ny=j;
			while(s[i][ny]!='#'&&s[i][ny]!='$')ny--;
			l4=j-ny-1;
			if(s[i][ny]=='$')l4=INF;
			int minn=min(min(l1,l2),min(l3,l4));
			if(l1!=INF){
				if(l1==minn)add(change[i][j],change[i+l1][j],minn);
				else add(change[i][j],change[i+l1][j],minn+1);
			}
			if(l2!=INF){
				if(l2==minn)add(change[i][j],change[i-l2][j],minn);
				else add(change[i][j],change[i-l2][j],minn+1);
			}
			if(l3!=INF){
				if(l3==minn)add(change[i][j],change[i][j+l3],minn);
				else add(change[i][j],change[i][j+l3],minn+1);
			}
			if(l4!=INF){
				if(l4==minn)add(change[i][j],change[i][j-l4],minn);
				else add(change[i][j],change[i][j-l4],minn+1);
			}
		}
	}
}
priority_queue<PII,vector<PII>,greater<PII> > q;
bool v[M];
void dijkstra(int sta){
	memset(f,0x3f,sizeof(f));
	f[sta]=0;
	q.push(make_pair(f[sta],sta));
	while(!q.empty()){
		int u=q.top().second;
		q.pop();
		if(v[u])continue;
		v[u]=1;
		for(int i=head[u];i;i=ne(i)){
			int y=to(i);
			if(f[y]>f[u]+dis(i)){
				f[y]=f[u]+dis(i);
				q.push(make_pair(f[y],y));
			}
		}
	}
}
int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	cin>>n>>m;
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			cin>>s[i][j];
			change[i][j]=o++;
			if(s[i][j]=='C'){
				st=change[i][j];
			}
			if(s[i][j]=='F'){
				ed=change[i][j];
			}
		}
	}
	for(int i=0;i<=n+1;++i){
		s[i][0]=s[i][m+1]='$';
	}
	for(int i=0;i<=m+1;++i){
		s[0][i]=s[n+1][i]='$';
	}
	draw();
	dijkstra(st);
	if(f[ed]!=INF)cout<<f[ed];
	else puts("nemoguce");
	return 0;
}
```

---

## 作者：Cure_Wing (赞：0)

[P4442 [COCI2017-2018#3] Portal](https://www.luogu.com.cn/problem/P4442)

### 思路

重新解释一下题目，一个单位时间可以发射无数个传送门。

考虑没有传送门，那就是一个简单的搜索。

有了传送门，考虑怎么利用它。由于传送门一定会发送到墙上，所以传送出去的位置也一定也会在墙上。假设我们固定传送的终点，那么首先要在这个墙所在的行或列发射一个传送门，然后找一个墙钻进去。由于终点固定了下来，所以我们找一堵最近的墙传送。所以我们计算一下每一个点到四周墙的距离，选取最近的墙钻进去，然后枚举从四周那一堵墙出来。

由于这样搜索使得边权不在全为 $1$，所以我们要用优先队列进行广度优先搜索，决定搜索顺序。

时间复杂度 $O(nm\log(nm))$。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
using std::cin;using std::cout;
constexpr int N=505,inf=1e9;
int n,m,u[N][N],d[N][N],l[N][N],r[N][N],sx,sy,ans[N][N],dx[]={-1,1,0,0},dy[]={0,0,1,-1},ex,ey;
std::string s[N];
struct node{int x,y,dis;inline bool operator<(const node &a)const{return dis>a.dis;}};
std::priority_queue<node>q;
signed main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	std::ios::sync_with_stdio(false);
	cin.tie(nullptr);cout.tie(nullptr);
	cin>>n>>m;
	for(int i=1;i<=n;++i){
		cin>>s[i];s[i]="#"+s[i]+"#";
		for(int j=1;j<=m;++j){
			if(s[i][j]=='C'){sx=i;sy=j;}
			if(s[i][j]=='F'){ex=i;ey=j;}
			ans[i][j]=inf;
		}
	}
	for(int i=0;i<=m+1;++i){s[0]+='#';s[n+1]+='#';}//统计一点到四周墙的距离
	for(int i=1;i<=m;++i) for(int j=1;j<=n;++j) if(s[j][i]!='#') u[j][i]=u[j-1][i]+1;
	for(int i=1;i<=m;++i) for(int j=n;j>=1;--j) if(s[j][i]!='#') d[j][i]=d[j+1][i]+1;
	for(int i=1;i<=n;++i) for(int j=1;j<=m;++j) if(s[i][j]!='#') l[i][j]=l[i][j-1]+1;
	for(int i=1;i<=n;++i) for(int j=m;j>=1;--j) if(s[i][j]!='#') r[i][j]=r[i][j+1]+1;
	q.push(node{sx,sy,0});ans[sx][sy]=0;
	while(!q.empty()){
		node k=q.top();q.pop();
		for(int i=0;i<4;++i){//不使用传送门
			int cx=k.x+dx[i],cy=k.y+dy[i];
			if(1<=cx&&cx<=n&&1<=cy&&cy<=m&&s[cx][cy]!='#'&&ans[k.x][k.y]+1<ans[cx][cy]){ans[cx][cy]=ans[k.x][k.y]+1;q.push(node{cx,cy,ans[cx][cy]});}
		}
		int cost=std::min({u[k.x][k.y],d[k.x][k.y],l[k.x][k.y],r[k.x][k.y]})-1,k1=k.x-u[k.x][k.y]+1,k2=k.x+d[k.x][k.y]-1,k3=k.y-l[k.x][k.y]+1,k4=k.y+r[k.x][k.y]-1;//四个方向枚举传送门的出口
		if(ans[k.x][k.y]+cost+1<ans[k1][k.y]){ans[k1][k.y]=ans[k.x][k.y]+cost+1;q.push(node{k1,k.y,ans[k1][k.y]});}
		if(ans[k.x][k.y]+cost+1<ans[k2][k.y]){ans[k2][k.y]=ans[k.x][k.y]+cost+1;q.push(node{k2,k.y,ans[k2][k.y]});}
		if(ans[k.x][k.y]+cost+1<ans[k.x][k3]){ans[k.x][k3]=ans[k.x][k.y]+cost+1;q.push(node{k.x,k3,ans[k.x][k3]});}
		if(ans[k.x][k.y]+cost+1<ans[k.x][k4]){ans[k.x][k4]=ans[k.x][k.y]+cost+1;q.push(node{k.x,k4,ans[k.x][k4]});}
	}
	if(ans[ex][ey]==inf) cout<<"nemoguce";
	else cout<<ans[ex][ey];
	return 0;
}
```

---

## 作者：ZPB2011 (赞：0)

# Portal

## 前言

[加强版](https://www.luogu.com.cn/problem/P6742)。

~~在灌水区看到了这题。~~

## 思路

我们可以注意到 $N$ 很小，所以可以考虑一些非常暴力的想法。

如果没有传送门，这题就是一题非常水的题。

由于传送门一定要放在墙上，我们可以预处理出每个点到墙的距离。

然后选一个位置作为终点，然后再选一个最近得墙作为传送点，枚举即可。

我们可以用 bfs 实现代码。

## AC code

```cpp
#include <iostream>
#include <vector>
#include <cstring>
#include <queue>
using namespace std;

const int N = 1e3 + 5;

struct node {
	int x, y, w;
	bool operator < (node x) const {
		return w > x.w;
	}
};

int dx[5] = {0, -1, 1, 0, 0};
int dy[5] = {0, 0, 0, -1, 1};
char board[N][N];
int a[N][N], b[N][N], c[N][N], d[N][N], dis[N][N];

int main() {
	memset(dis, 0x3f, sizeof(dis));//初始化 
	int n, m, sx, sy, ex, ey;
	cin >> n >> m;
	for(int i = 1; i <= n; i++) {//输入 
		for(int j = 1; j <= m; j++) {
			cin >> board[i][j];
			if(board[i][j] == 'C') {
				sx = i;
				sy = j;
			}
			if(board[i][j] == 'F') {
				ex = i;
				ey = j;
			}
		}
	}
	for(int i = 0; i <= n + 1; i++) board[i][0] = '#';
	for(int i = 0; i <= n + 1; i++) board[i][m + 1] = '#';
	for(int i = 0; i <= m + 1; i++) board[0][i] = '#';
	for(int i = 0; i <= m + 1; i++) board[m + 1][0] = '#';//补充墙 
	for(int j = 1; j <= m; j++) {//预处理 
		for(int i = 1; i <= n; i++) {
			if(board[i][j] != '#') a[i][j] = a[i - 1][j] + 1;
		} 
	}
	for(int j = 1; j <= m; j++) {
		for(int i = n; i >= 1; i--) {
			if(board[i][j] != '#') b[i][j] = b[i + 1][j] + 1;
		} 
	}
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= m; j++) {
			if(board[i][j] != '#') c[i][j] = c[i][j - 1] + 1;
		}
	}
	for(int i = 1; i <= n; i++) {
		for(int j = m; j >= 1; j--) {
			if(board[i][j] != '#') d[i][j] = d[i][j + 1] + 1;
		} 
	}
	dis[sx][sy] = 0;
	priority_queue<node> que;
	que.push({sx, sy, 0});
	while(!que.empty()) {//bfs 
		node u = que.top();
//		cout << u.x << ' ' << u.y << endl;
		que.pop();
		for(int i = 1; i <= 4; i++) {//普通搜索 
			int nx = u.x + dx[i], ny = u.y + dy[i];
			if(nx >= 1 && nx <= n && ny >= 1 && ny <= m && board[nx][ny] != '#' && dis[u.x][u.y] + 1 < dis[nx][ny]) {
				dis[nx][ny] = dis[u.x][u.y] + 1;
				que.push({nx, ny, dis[nx][ny]});
			}
		}
		int minn = min(min(a[u.x][u.y], b[u.x][u.y]), min(c[u.x][u.y], d[u.x][u.y])) - 1;//选传送门 
		int x1 = u.x - a[u.x][u.y] + 1;
		int x2 = u.x + b[u.x][u.y] - 1;
		int y1 = u.y - c[u.x][u.y] + 1;
		int y2 = u.y + d[u.x][u.y] - 1;
//		cout << a[u.x][u.y] << ' ' << b[u.x][u.y] << ' ' << c[u.x][u.y] << ' ' << d[u.x][u.y] << endl;
//		cout << x1 << ' ' << x2 << ' ' << y1 << ' ' << y2 << endl;
		int val = dis[u.x][u.y];
		if(val + minn + 1 < dis[x1][u.y]) {
			dis[x1][u.y] = val + minn + 1;
			que.push({x1, u.y, dis[x1][u.y]});
		}
		if(val + minn + 1 < dis[x2][u.y]) {
			dis[x2][u.y] = val + minn + 1;
			que.push({x2, u.y, dis[x2][u.y]});
		}
		if(val + minn + 1 < dis[u.x][y1]) {
			dis[u.x][y1] = val + minn + 1;
			que.push({u.x, y1, dis[u.x][y1]});
		}
		if(val + minn + 1 < dis[u.x][y2]) {
			dis[u.x][y2] = val + minn + 1;
			que.push({u.x, y2, dis[u.x][y2]});
		}
	}
	if(dis[ex][ey] == 0x3f3f3f3f) cout << "nemoguce" << endl;//不成立 
	else cout << dis[ex][ey] << endl;
	return 0;
}
```+

---


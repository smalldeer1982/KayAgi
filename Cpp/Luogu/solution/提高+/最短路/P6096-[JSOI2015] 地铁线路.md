# [JSOI2015] 地铁线路

## 题目描述

JSOI 王国的地铁又涨价了！正在 JSOI 旅游的 JYY 非常不开心。这次票价改革后，乘客并不是按照乘坐的距离收费，而是按照换乘次数进行收费的！JYY 也要按此更新他的线路搜索软件了。JYY 心想，在支付同样票价的前提下，岂不
是坐的站数越多，自己就赚的越多嘛！于是 JYY 希望开发一个线路搜索软件，使得自己总能够“赚”的最多！

JSOI 地铁一共有 $N$ 条线路 $S$ 个车站。第 $i$ 条地铁线路包含 $L_i$ 个站。所有地铁线路都是一条从首发站到终点站的直线型线路（不存在例如北京地铁 2 号线或者 10 号线那样奇葩的环线）。同时，每一条地铁线路都是双向运行的。如果有不同的线路经过同一个地铁站，那么乘客就可以在那个地铁站进行换乘。根据 JSOI 地铁的最新收费方式，每当乘客进入一列正在运行的地铁列车，都需要支付 $1$ 的费用。因此，假设乘客一共换乘了 $x$ 次，那么就需要总共支付 $x+1$ 的乘车费用。由于地铁线路都是双向运行的，因此在任意一站都可以换乘该线地铁反方向运行的列车。不过，需要注意的是，即使是换乘同样线路的反方向列车，也是需要付费的（因为总是需要先下车，再重新上车的）。

JYY现在要从 $A$ 站坐地铁前往 $B$ 站。假设对于任意一条地铁线路，相邻两站间地铁的运行时间均为 $1$ 分钟，并且列车停站和换乘均不耗时间，JYY想知道

1. 他最少需要支付的票价是多少钱；
2. 在支付最少票价的前提下，他最多可以乘坐多少分钟的地铁。

## 说明/提示

对于 $100\%$ 的数据，$2\leq N\leq 4\times 10^5$，$S\leq 3\times 10^5$，$\sum L_i\leq 8\times 10^5$。

保证输入所有字符串的长度不超过 $40$，且仅包含字母、数字以及横线 `-`。

## 样例 #1

### 输入

```
2 5
A B C D E
4 A B C D
3 C D E
A D```

### 输出

```
1
3```

# 题解

## 作者：Cry_For_theMoon (赞：7)

&emsp;&emsp;[传送门](https://www.luogu.com.cn/problem/P6096)

&emsp;&emsp;图论建模优秀题。解法其实很巧妙，但是切掉一道题后只有深入思考是如何想到这个做法的，这道题目才是真正有意义的

&emsp;&emsp;考虑处理线路，同一线路上的所有点花费1代价相互可达，我们不可能对每个点去和与他同一线路上的点连边，因为 $\sum l_i <= 8*10^5$，也就是意味着边数可能到达 $64*10^{10}$，考虑你选两个点，它们其实会和剩下的点都连一条边，也就是说**一条线路里会有很多个站连一个相同的站**，考虑把所有连接 $i$ 的边合并成一条边，但是它们终点相同却又起点不同，因此我们开一个“虚点”，所有点去连这个虚点，边权为1，虚点和所有的该线路上的点（边权为0）相连就可以了。看上去对于每个点都要开一个对应的虚点？然而我们发现每个虚点都被该线路所有点相连，也连接该线路所有点，我们还可以把**这些虚点合并成一个**。此时就满足了同一线路上所有点花费1代价相互可达的题意。

&emsp;&emsp;对于第一问，显然就是最短路。考虑 $i$ 的上一个点 $j$ 满足 $dis_j=dis_i-1$ 的点转移（因为你要从点 $j$ 上地铁花费1），排序后 DP（这个倒不难想，做过图上DP类的（比如逛公园，大陆争霸）都应该明白），而且这里没有等于号方便了很多。这个柿子显然意味着 $i,j$ 位于同一条地铁上，所以**一个点只会被和他在同一个地铁上且 $dis$ 比他少1的点转移**，这个柿子又意味着这条地铁的虚点的最短路 = 点 $i$ 的最短路，所以其实我们对 $n$ 个虚点排序，然后铁路上转移所有最短路 = 虚点最短路的点即可。

&emsp;&emsp;此时分两种情况，转移点在当前点之前/之后，我们只分析之前（之后的分析是一样的），设当前点是 $i$，你维护的是 $1..i-1$ 站中满足 $dis_j = dis_i-1$ 且 $f(j)+i-j$ 最大的 $j$，如果你学过多重背包优化单调队列这种，你就会立刻发现不管 $j$ 选什么 $+i$ 都不变，因此维护的其实是 $1..i-1$ 中 $f(j)-j$ 最大的，这个柿子是独立的，这样的话每个点的转移就都是 $O(1)$ 的，又因为所有铁路的点数之和 $L<=8e5$，所以DP这里 $O(L)$ 时间复杂度完全可以跑的飞快（主要复杂度还是在最短路那里，我写了Dij，写BFS可以快一点）

&emsp;&emsp;在一开始的建图中，我和 M_sea 神仙的方法是一样的。事实上根据我们刚才的分析，完全可以改成“所有点去练虚点的边权为0，虚点连所有点的边权为1”（即反一下），然后DP的时候其实是转移铁路上所有最短路=虚点最短路+1的点，而上文中 $j$ 的条件也变成了点 $j$ 的最短路和虚点最短路相等。你可以把开始的方法看作花钱上地铁然后下地铁不要钱，这种建图方法看成先上车下车补票，本质上是没有任何区别的。如果你看懂了前面的内容，这里应该是一下反应过来的。

&emsp;&emsp;虽然这题DP是重头戏但是这题DP做法我觉得带给我们的帮助其实并不是很大，反而是建图方法值得好好揣摩。

&emsp;&emsp;~~但是我知道你们都只会看Code的~~

```cpp
//JSOI,2015
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<map>
#include<queue>
#include<string>
using namespace std;
const int MAXN=4e5+10,MAXM=2e6+10,INF=1e9;
struct Edge{
	int u,v,w;
};
struct Node{
	int u,dis;
	bool operator<(const Node& n2)const{
		return dis > n2.dis;
	}
};
struct Line{
	int u,d;
	bool operator<(const Line& n2)const{
		return d < n2.d; 
	} 
}Lines[MAXN];
map<string,int>fs;
Edge edge[MAXM];
int first[MAXN],next[MAXM],tot;
int dis[MAXN],vis[MAXN],f[MAXN],point[MAXN];
int lines,n;
inline void addedge(int u,int v,int w){
	edge[++tot].u=u;edge[tot].v=v;edge[tot].w=w;
	next[tot]=first[u];first[u]=tot;
}
inline int getstation(int u){
	return u+n;
}
void dijkstra(int s){
	for(int i=1;i<=lines+n;i++){
		dis[i] = INF;
	}
	dis[s] = 0;
	priority_queue<Node>h;h.push((Node){s,0});
	while(!h.empty()){
		Node now = h.top();h.pop();
		int u = now.u;
		if(vis[u])continue;
		vis[u] = 1;
		for(int j=first[u];j;j=next[j]){
			int v = edge[j].v;
			if(dis[v] > dis[u]+edge[j].w){
				dis[v] = dis[u]+edge[j].w;
				h.push((Node){v,dis[v]});
			}
		}
	}
}
int main(){
	scanf("%d%d",&lines,&n);
	string tmpname;
	for(int i=1;i<=n;i++){
		cin>>tmpname;fs[tmpname]=i;
	}
	for(int i=1,l;i<=lines;i++){
		scanf("%d",&l);
		for(int j=1;j<=l;j++){
			cin>>tmpname;
			int u = getstation(i),v = fs[tmpname];
			addedge(v,u,0);//上车
			addedge(u,v,1);//下车 
		}
	}
	string startname,endname;
	cin>>startname>>endname;
	int s = fs[startname],e = fs[endname];
	dijkstra(s);
	if(dis[e]==INF){
		printf("-1\n0");return 0;
	}
	printf("%d\n",dis[e]);
	for(int i=1;i<=lines;i++){
		Lines[i] = (Line){getstation(i),dis[getstation(i)]};
	}
	sort(Lines+1,Lines+1+lines);
	for(int i=1;i<=n;i++)f[i]=-INF;
	f[s]=0;
	for(int i=1;i<=lines;i++){
		int u = Lines[i].u;
		if(dis[u]==INF)break;
		int rear = 0;
		for(int j=first[u];j;j=next[j]){
			int v = edge[j].v;
			point[++rear] = v;
		}
		int maxn = 0;
		for(int j=1;j<=rear;j++){
			int v = point[j];
			if(dis[v]==dis[u]+1){
				if(maxn!=0){
					f[v] = max(f[v],f[point[maxn]]+j-maxn);
				}
			}else if(dis[v]==dis[u]){
				if(maxn){
					if(f[point[maxn]]-maxn < f[point[j]]-j)maxn=j;
				}else{
					maxn=j;
				}
			}
		}
		maxn = 0;
		//转移前缀 
		for(int j=rear;j>=1;j--){
			int v = point[j];
			if(dis[v]==dis[u]+1){
				if(maxn!=0){
					f[v] = max(f[v],f[point[maxn]]+maxn-j);
				}
			}else if(dis[v]==dis[u]){
				if(maxn){
					if(f[point[maxn]]+maxn < f[point[j]]+j)maxn=j;
				}else{
					maxn=j;
				}
			}
		}
	}
	printf("%d",f[e]);
	return 0;
}
```


---

## 作者：SICKO (赞：3)

要是能一步走完全程就好了就好了。

### 1

题目给了我们一片地铁网络，让我们求从网络中的一站到另外一站的**最短时间**与**最短时间条件下的最长距离**。

题目的关键呼之欲出，就是处理这张图的**同线路下站点表达**。处理完站点表达，剩下的就是 bfs 了。

缩点？并查集？这些都不行。因为这些处理办法都难以处理站点距离的信息。一定要把站点全部连起来吗？要是坐地铁能要是能一步走完全程就好了就好了。

### 2

**把坐地铁看成一种状态**，上地铁看成进入状态，离开地铁视为结束这种状态。我们**建一个虚点表示这个中间状态**，并且连线，这样我们就巧妙的把线路上所有站台关联到一起了。我们对此建有向边，站点指向虚点的边的边权为 $0$，虚点指向站点的边的边权为 $1$，分别表示上地铁与出地铁交钱。

如何处理移动的距离呢？我们以线路的两端为锚点，分别建对应的虚点，进入虚点减去当前端点对应线路相应站头的相对距离，离开虚点则加上，这样就完美处理了移动距离的问题。

单单看文字描述有点晦涩，以样例为例作图。

![](https://cdn.luogu.com.cn/upload/image_hosting/b7sb2dix.png)

### 3

来看代码。

```c++
#include<iostream>
#include<algorithm>
#include<vector>
#include<queue>
#include<map>
using namespace std;
const int N = 4e5+6;
struct edge{
    int to, val, dis;
};
vector<edge> vec[N*3];
queue<int> que;
map<string, int> mp;
int dp[N*3], n, m, idx, zd[N*2], sd, cz[N];
bool vis[N*3];
int main(){
    cin>>m>>n;
    for(int i=1; i<=n; i++){
        string x; cin>>x;
        mp[x] = ++idx;
    }
    sd = n;
    for(int _=1; _<=m; _++){
        int x; cin>>x;
        for(int i=1; i<=x; i++){
            string y; cin>>y;
            zd[i] = mp[y];
        }
        // 以头与尾建两个虚点，表示列车的两个不同方向
        int dis = 0;
        // 头
        sd++;
        for(int i=1; i<=x; i++){
            // 相对站首的距离 上车减去 下车加上
            int pos = zd[i];
            // 上车 站点到虚点 不用交钱
            vec[pos].push_back({sd, 0, -dis});
            // 下车 虚点到站点 交钱下车
            vec[sd].push_back({pos, 1, dis});
            dis++;
        }
        // 尾
        sd++; dis = 0;
        for(int i=x; i>=1; i--){
            // 相对站尾的距离 上车减去 下车加上
            int pos = zd[i];
            // 上车 站点到虚点 不用交钱
            vec[pos].push_back({sd, 0, -dis});
            // 下车 虚点到站点 交钱下车
            vec[sd].push_back({pos, 1, dis});
            dis++;
        }
    }
    // bfs
    string sst, sed; cin>>sst>>sed;
    int st, ed; st = mp[sst]; ed = mp[sed];
    for(int i=1; i<=n+sd; i++) dp[i] = 1e9+9, cz[i] = -1e9-9;
    que.push(st); dp[st] = 0; cz[st] = 0;
    while(!que.empty()){
        for(int _=1; _<=2; _++){
            int t = int(que.size());
            while(t--){
                int p = que.front(); que.pop();
                vis[p] = false;
                for(auto &i:vec[p]){
                    if(dp[i.to] > dp[p] + i.val){
                        dp[i.to] = dp[p] + i.val;
                        cz[i.to] = cz[p] + i.dis;
                        if(vis[i.to]) continue;
                        vis[i.to] = true; que.push(i.to);
                    }
                    else if(dp[i.to] == dp[p] + i.val && cz[i.to] < cz[p] + i.dis){
                        cz[i.to] = cz[p] + i.dis;
                        if(vis[i.to]) continue;
                        vis[i.to] = true; que.push(i.to);
                    }
                }
            }
        }
    }
    cout<<dp[ed]<<"\n"<<cz[ed];
    return 0;
}
```

---

## 作者：OIer_ACMer (赞：1)

# 题目解析：

这道题，首先，我们可以发现地铁是一条一直走下去的列车，其自身**不会在中途停下**，而只有在我们在一个站转车时才会有所变化，所以，我们可以建一个虚拟原点，记录一条地铁线走下去的代价，和时间。

首先，由于题目是双向边，所以就要考虑从一个站下车走反方向地铁的情况，则先从起点点建一条边指向虚拟点，其代价为 $1$，再从源点指向其余点，代价为 $0$，毕竟只是下车，至于怎么求点对之间的距离，很简单，我们知道，若是要求 $x$ 到 $y$ 的距离，则**要用起点到 $y$ 的距离减去起点到 $x$ 的距离**，建边的距离就为原来边长的相反数，毕竟要减去原来的边并加上到之后的边长，这一点
要根据建边方式确定。

要注意的是，这道题要建两个源点，毕竟我们在考虑另外一列从终点开往起点的列车，上一段的建相反数边并不是为从**起点到终点考虑的**，所以，我们要再开一个源点，相当于原来的那个点的镜像点，建立方式一样。

接下来，第二问要我们算时间，所以我们就从拓扑排序考虑，毕竟 SPFA 已经嘎了。我们可以发现，当 $dis_y$ 等于 $dis_x$ 加上 $x$ 到 $y$ 的边长时，则这条路在最短路上，我们就将这条路建到新图上，最后跑一边拓扑排序找最长边就行了。


# 代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
unordered_map<string, int> map1;
struct node
{
    int to, val, time, next;
} edge[10000009], edge1[10000009];
int head[10000009], head1[10000009];
int cnt, cnt1;
void add(int u, int v, int val, int time)
{
    edge[++cnt].to = v;
    edge[cnt].next = head[u];
    edge[cnt].val = val;
    edge[cnt].time = time;
    head[u] = cnt;
}
void add1(int u, int v, int val, int time)
{
    edge1[++cnt1].to = v;
    edge1[cnt1].next = head1[u];
    edge1[cnt1].val = val;
    edge1[cnt1].time = time;
    head1[u] = cnt1;
}
bool vis[10000009];
int dis[10000009], dist[10000009];
int S, T;
int in[10000009], dp[10000009];
void dij(int st)
{
    memset(dis, 0x3f3f3f3f, sizeof(dis));
    memset(vis, 0, sizeof(vis));
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;
    dis[st] = 0;
    q.push(make_pair(dis[st], st));
    while (!q.empty())
    {
        int x = q.top().second;
        q.pop();
        if (vis[x])
        {
            continue;
        }
        vis[x] = 1;
        for (int i = head[x]; i; i = edge[i].next)
        {
            int y = edge[i].to;
            int val = edge[i].val;
            if (dis[y] > dis[x] + val)
            {
                dis[y] = dis[x] + val;
                q.push(make_pair(dis[y], y));
            }
        }
    }
}
void topsort(int s, int n, int m)
{
    // cout << endl
    //      << endl;
    queue<int> q;
    memset(dp, -0x3f, sizeof(dp));
    dp[s] = 0;
    for (int i = 1; i <= 2 * n + m; i++)
    {
        if (in[i] == 0)
        {
            // cout << "lucky i=" << i << endl;
            q.push(i);
        }
    }
    while (!q.empty())
    {
        int u = q.front();
        q.pop();
        for (int i = head1[u]; i; i = edge1[i].next)
        {
            // int v = g2[u][i].to;
            // int time = g2[u][i].time;
            int v = edge1[i].to;
            int time = edge1[i].time;
            in[v]--;
            dp[v] = max(dp[v], dp[u] + time);
            if (in[v] == 0)
            {
                // cout << "in[" << v << "]=" << in[v] << "    " << "dp[" << v << "]=" << dp[v] << endl;
                q.push(v);
            }
        }
    }
}
int n, m;
signed main()
{
    cin >> n >> m;
    for (int i = 1; i <= m; i++)
    {
        string s;
        cin >> s;
        if (!map1.count(s))
        {
            map1[s] = i;
        }
    }
    for (int i = 1; i <= n; i++)
    {
        int k;
        cin >> k;
        for (int j = 1; j <= k; j++)
        {
            string str;
            cin >> str;
            int u = map1[str];
            int v1 = m + i;
            int v2 = n + m + i;
            // g1[u].push_back({v1, 1, -(j - 1)});
            // g1[v1].push_back({u, 0, j - 1});
            // g1[u].push_back({v2, 1, -(k - j)});
            // g1[v2].push_back({u, 0, k - j});
            add(u, v1, 1, -(j - 1));
            add(v1, u, 0, j - 1);
            add(u, v2, 1, -(k - j));
            add(v2, u, 0, k - j);
        }
    }
    string a, b;
    int sta, end;
    cin >> a >> b;
    sta = map1[a];
    end = map1[b];
    dij(sta);
    if (dis[end] == 0x3f3f3f3f)
    {
        cout << "-1" << "\n";
        cout << "0" << "\n";
        return 0;
    }
    else
    {
        // cout << "end=" << end << ' ' << dis[end] << endl;
        cout << dis[end] << endl;
    }
    // dij(end, dis);
    for (int i = 1; i <= 2 * n + m; i++)
    {
        for (int j = head[i]; j; j = edge[j].next)
        {
            int x = i;
            int y = edge[j].to;
            int val = edge[j].val;
            int time = edge[j].time;
            if (dis[y] == dis[x] + val)
            {
                add1(x, y, val, time);
                // add1(y, x, )
                in[y]++;
                // cout << "in[" << y << "]=" << in[y] << "    " << val << " " << time << endl;
            }
        }
    }
    topsort(sta, n, m);
    cout << dp[end];
    return 0;
}
```

---

## 作者：__YancBuxIya (赞：1)

# P6096 [JSOI2015]地铁线路

------------
# [题目传送门](https://www.luogu.com.cn/problem/P6096)

------------
## 题目大意

题面非常清楚，此处不再赘述。

--------

## 分析题目：


一看到这题，立马想到了最短路算法...那如何建点/建边呢？我们可以将问题进行转化：对于每条线路建一个点，线路上的站向线路连边权为 $1$ 的边，线路向线路上的站连边权为 $0$ 的边。这样就可以将原问题的边转化为 $0$ 和 $1$ ，可以用广度优先搜索算法进行解决。

-----------
## 部分代码：
```cpp
inline void Work() {
    for (int i=1;i<=m;++i) p[i]=i;
    sort(p+1,p+m+1,cmp);
    int r=0;
    while (r<m&&dis[p[r+1]+n]<=0) ++r;
    for (int i=1;i<=m;++i) {
        int l=r+1;
        while (r<m&&dis[p[r+1]+n]==i) ++r;
        for (int j=l;j<=r;++j) {
            int u=p[j],l=vec[u].size()-1;
            pre[0]=-2e9;
            for (int k=1;k<=l;++k) {
                int v=vec[u][k]; pre[k]=pre[k-1]+1;
                if (dis[v]==i-1) pre[k]=max(pre[k],mx[v]);
            }
            suf[l+1]=-2e9;
            for (int k=l;k>=1;--k) {
                int v=vec[u][k]; suf[k]=suf[k+1]+1;
                if (dis[v]==i-1) suf[k]=max(suf[k],mx[v]);
            }
            for (int k=1;k<=l;++k) { int v=vec[u][k];
                if (dis[v]==i) mx[v]=max(mx[v],max(pre[k],suf[k]));
            }
        }
    }
}
```


---

## 作者：TMLY114514 (赞：0)

## P6096 [JSOI2015] 地铁线路

~~感觉这题有点水，~~ 其实不用写那么麻烦。

可以把每条地铁线路拆成两条方向相反的线路，然后做类似分层图的处理，因为坐地铁的时候不需要花钱，层内的点之间边权为 $0$。对于各层之间，对应的地铁站相同的点可以互相换乘，发现直接建边边数过多，不可接受。但其实可以给每个地铁站开一个节点当作换乘站，从各层对应的点向这个节点连边权为 $1$ 的边，从这个点向各层对应的点连边权为 $0$ 的边，就可以模拟出换乘操作。

对于第一问，从起点 $s$ 在不同地铁线对应的点到终点 $t$ 对应的点的最短路即为答案，具体可以用 01bfs 实现。

对于第二问，显然所有可能的最短路径构成了一个 DAG。对于 DAG 上的边，由于只有坐地铁花时间，一条线路内的边权为 $1$，其余的边边权为 $0$，直接拓扑排序求最长路即可。

对于找 DAG，先记从 $s$ 的对应点出发到点 $i$ 的最小花费为 $dis_{0,i}$，然后直接建反图求出图上任意点 $i$ 到终点的对应点的最小花费 $dis_{1,i}$。对于从 $u$ 到 $v$，边权为 $w$ 的边，满足 $dis_{0,i}+dis_{1,i}+w$ 等于第一问的答案，就是 DAG 上的边。

### 代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 400010
#define P 2000010
//可以直接01bfs求最短路
//考虑乘坐地铁时间
//可以在最短路dag上dp，求最长路即可
const int inf=0x3f3f3f3f;
int n,m,k,cnt,idx,head[P],nhead[P],rhead[P],dis[2][P],vis[P],ans=inf,f[P],ind[P],st[P],top;
#define bs basic_string<int>
bs p[N],line[N];//初始点对应的所有新点
struct edge{
	int v,w,nxt;
}e[P<<2],ne[P<<2],re[P<<2];
inline void add(int u,int v,int w){
	e[++cnt]={v,w,head[u]};
	head[u]=cnt;
	re[cnt]={u,w,rhead[v]};
	rhead[v]=cnt;
}
inline void nadd(int u,int v,int w){	
	++ind[v];
	ne[++cnt]={v,w,nhead[u]};
	nhead[u]=cnt;
}
unordered_map<string,int>id;
string ch;
inline void get(bs&x){
	int pre=0;
	for(int v:x){
		p[v]+=++idx;
		pre&&(add(pre,idx,0),1),
		pre=idx;
	}
}
list<int>q;
inline void bfs(int s,int k,int dis[],int head[],edge e[]){
	for(int i=1;i<=idx;++i)vis[i]=0,dis[i]=inf;
	for(int v:p[s])dis[v]=k,q.push_back(v);
	while(q.size()){
		int u=q.front();
		q.pop_front();
		if(vis[u])continue;
		vis[u]=1;
		for(int i=head[u];i;i=e[i].nxt){
			int v=e[i].v,w=e[i].w;
			if(dis[v]>dis[u]+w){
				dis[v]=dis[u]+w;
				if(w)q.emplace_back(v);
				else q.emplace_front(v);
			}
		}
	}
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>m>>n;
	for(int i=1;i<=n;++i)cin>>ch,id[ch]=i;
	for(int i=1,c;i<=m;++i){
		cin>>c;
		while(c--)cin>>ch,line[i]+=id[ch];
		get(line[i]);
		reverse(line[i].begin(),line[i].end());
		get(line[i]);
	}
	k=idx;
	for(int i=1;i<=n;++i){
		if(p[i].size())++idx;
		for(int v:p[i])add(v,idx,1),add(idx,v,0);
	}
	cin>>ch;
	int s=id[ch];
	cin>>ch;
	int t=id[ch];
	bfs(s,1,dis[0],head,e);
	bfs(t,0,dis[1],rhead,re);
	for(int v:p[t])ans=min(ans,dis[0][v]);
	if(s==t)ans=0;
	if(ans==inf)cout<<-1<<'\n'<<0,exit(0);
	cout<<ans<<'\n';
	cnt=0;
	for(int u=1;u<=idx;++u)
		for(int i=head[u];i;i=e[i].nxt){
			int v=e[i].v,w=e[i].w;
			if(dis[0][u]+w+dis[1][v]==ans)
				nadd(u,v,u<=k&&v<=k);
		}
	for(int i=1;i<=idx;++i)if(!ind[i])st[++top]=i;
	while(top){
		int u=st[top--];
		for(int i=nhead[u];i;i=ne[i].nxt){
			int v=ne[i].v,w=ne[i].w;
			f[v]=max(f[v],f[u]+w);
			if(!--ind[v])st[++top]=v;
		}
	}
	ans=0;
	for(int v:p[t])ans=max(ans,f[v]);
	cout<<ans<<'\n';
	return 0;
}
```

---


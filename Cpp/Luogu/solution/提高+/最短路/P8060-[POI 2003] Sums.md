# [POI 2003] Sums

## 题目描述

我们给定一个整数集合 $A$。考虑一个非负整数集合 $A'$，所有属于 $A'$ 的集合的数 $x$ 满足当且仅当能被表示成一些属于 $A$ 的元素的和（数字可重复）。

比如，当 $A = \{2,5,7\}$，属于 $A'$ 的数为：$0$（$0$ 个元素的和），$2$，$4$（$2 + 2$）和 $12$（$5 + 7$ or $7 + 5$ or $2 + 2 + 2 + 2 + 2 + 2$）；但是元素 $1$ 和 $3$ 不属于 $A'$。

## 说明/提示

对于所有数据，$1 \le n \le 5 \times 10^3$，$1 \le k \le 10^4$，$1 \le a_1 < a_2 < ... < a_n \le 5 \times 10^4$，$0 \le b_i \le 10^9$。

## 样例 #1

### 输入

```
3
2
5
7
6
0
1
4
12
3
2```

### 输出

```
TAK
NIE
TAK
TAK
NIE
TAK```

# 题解

## 作者：henhen_ (赞：4)

好像没有用 spfa 写的题解 ~~（spfa，它死了）~~。
## 题目大意
给定一个集合 $A$，询问 $k$ 次，每次询问一个整数 $b$，问 $b$ 是否能被表示成一些属于 $A$ 集合的和（$0$ 也属于 $A$）。
## 思路
需要具备的知识点：[同余最短路](https://oi-wiki.org/graph/mod-shortest-path/)。

如果是初学者可以先做[这道题](https://www.luogu.com.cn/problem/P3403)。

其实这道题就是跳楼机的升级版，先在 $A$ 中取最小值 $minn$，然后对 $a_i$ 中的其他值进行扩展。$dis_i$ 的意义是模 $k$ 意义下等于 $i$ 的最小值。

用最短路跑出 $dis_i$ 的值，对于每次询问，我们只判断  $dis_{x\bmod a}$ 与 $x$ 的关系即可。

## 附上代码
```cpp
#include<bits/stdc++.h>
#define int long long //记得开long long 
using namespace std;
const int N=5e6+10;
int head[N],cnt,vis[N],tot,a[N],dis[N];
int n,l,r,minn=0x3f3f3f3f3f3f3f3f; 
queue<int>q;
inline void spfa(){//裸spfa暴力求最短路 
	memset(dis,0x3f,sizeof(dis));
	memset(vis,0,sizeof(vis));
	q.push(0);
	vis[0]=1;
	dis[0]=0;
	while(!q.empty()){
		int x=q.front();
		q.pop();
		vis[x]=0;
		for(int i=1;i<=n;i++){
			if(a[i]==minn)continue;
			int y=(x+a[i])%minn;
			if(dis[y]>dis[x]+a[i]){
				dis[y]=dis[x]+a[i];
				if(!vis[y]){
					q.push(y);
					vis[y]=1;
				}
			}
		}
	}
}
signed main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++){
		scanf("%lld",&a[i]);
		minn=min(minn,a[i]);
	}
	spfa();
	int k;
	scanf("%lld",&k);
	while(k--){
		int c;
		scanf("%lld",&c);
		printf("%s\n",dis[c%minn]<=c ?"TAK":"NIE");//不要把输出打错，不然会像我一样调试半天（orz） 
	}
	return 0;
}
```


---

## 作者：Coros_Trusds (赞：4)

# 题目大意

给出一个集合 $a$，再给定 $m$ 个询问，每次询问一个数 $x$ 是否能够表示为若干个 $a$ 集合中的数的和。

# 题目分析

感觉还是挺容易跑 $400+ms$ 的？

前置知识同余最短路，详见我的[学习笔记](https://www.luogu.com.cn/blog/430409/knowledge-tongyu-shortest-path)。

令 $dis[i]$ 表示模 $minn$ 意义下等于 $i$ 的最小数，$minn=\min\{a_i\}$。这道题只不过是将跳楼机的 $x,y,z$ 拓展成了 $x_1,x_2\cdots,x_n$，将墨墨的等式简化了罢了。我们按照类似于上例的跳楼机的连边方案跑最短路即可。（学习笔记中均提到过）

具体地，我们在 $a$ 中取其最小值 $k$，用 $a$ 中的其它值来拓展。令 $dis[i]$ 表示模 $k$ 意义下等于 $i$ 的最小值。

这里 $a_i$ 不可能为 $0$，所以不需要考虑 $minn=0$ 的 $\verb!RE!$ 情况。

关于判断无解的问题，直接看 $dis[x\bmod minn]$ 与 $x$ 的大小关系即可。

代码：

```cpp
typedef std::pair<int,int> PII;

const int INF = 0x3f3f3f3f3f3f3f3f;
const int N = 5e5 + 5;
int a[N],dis[N];
bool vis[N];
int n,m,minn;
inline void dijkstra(int st) {
	mst(vis,false),mst(dis,0x3f);
	dis[st % minn] = 0;
	std::priority_queue<PII,std::vector<PII>,std::greater<PII> >q;
	q.push(std::make_pair(dis[st % minn],st));
	while (!q.empty()) {
		int u = q.top().second;q.pop();
		if (vis[u]) continue;
		vis[u] = true;
		for (register int i = 1;i <= n; ++ i) {
			if (a[i] == minn) continue;
			int v = (u + a[i]) % minn;
			if (dis[v] > dis[u] + a[i]) {
				dis[v] = dis[u] + a[i];
				q.push(std::make_pair(dis[v],v));
			}
		}
	}
}
#undef int
int main(void) {
#ifndef ONLINE_JUDGE
	freopen("in.txt","r",stdin);
#endif
	#define int long long
	n = read();
	minn = INF;
	for (register int i = 1;i <= n; ++ i) {
		a[i] = read();
		minn = std::min(minn,a[i]);
	}
	dijkstra(0);
	m = read();
	while (m --) {
		int x = read();
		printf("%s\n",dis[x % minn] <= x ? "TAK" : "NIE");
	}
	
	return 0;
}
```



---

## 作者：hnczy (赞：1)

## 前置

[同余最短路](https://oi-wiki.org/graph/mod-shortest-path/)

## 题目大意

给你 $n$ 个数，再给你 $m$ 个数，判断每一个数是否能被这几个数相加得到。

## 思路

一道比较裸的同余最短路,如果你傻傻的 dp 每一个值是否能被构成，那必然超时。

那怎么办呢，其实很简单。观察到，如果选一个数当基数，那么模这个数余 $t$ 的数只要求出一个最小能被表示出来的即可，但一般基数是最小的数。

举个例子集合为 $\{2,3\}$ ,那么三是模二余一的最小数,那么任何大于三且模二余一的数都能表示出来。

实现代码就很简单了用一个类似 bfs 的形式来实现。

## 代码
```c++
#include<bits/stdc++.h>
using namespace std;
int n,m,a[5005],dis[500005],p;
void bfs(){
	queue<int>q;
	dis[0]=0;
	q.push(0);
	while(!q.empty()){
		int x=q.front();q.pop();
		for(int i=2;i<=n;i++){
			if(dis[(x+a[i])%p]<=x+a[i]&&dis[(x+a[i])%p]!=-1)
				continue;
			dis[(x+a[i])%p]=x+a[i];
			q.push(x+a[i]);
		}
	}
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d",a+i);
	sort(a+1,a+n+1);
	p=a[1];
	memset(dis,-1,sizeof dis);
	bfs();
	scanf("%d",&m);
	for(int i=1,x;i<=m;i++){
		scanf("%d",&x);
		if(dis[x%p]<=x&&dis[x%p]!=-1)
			printf("TAK\n");
		else 
			printf("NIE\n");
	}
	return 0;
}

```

---

## 作者：StarsIntoSea_SY (赞：1)

# Solution

同余最短路板子，还不会同余最短路可以看我的[学习笔记](https://www.luogu.com.cn/article/r61gmb8e)。

我们以 $a[1]$ 为模数，则对于所有 $2\le i \le n$ 和 $0 \le j < a[1]$，点 $j$ 向点 $(j+a[i]) \bmod a[1]$ 建一条边权为 $a[i]$ 的边。

在判断一个数 $x$ 是否合法时，可以先把这个数模 $a[1]$，然后判断 $x$ 是否大于等于 $f(x\bmod a[1])$ 即可。

注意，极限数据下理论会有 $5 \times 10^3 \times 5 \times 10^4$ 条边，所以我们不直接建边，走的时候枚举每条边即可。

# Code


```cpp
#include <stdio.h>
#include <queue>
const int N=50005;
int dis[N],vis[N],a[N],n,k;
void SPFA(){ //最短路板子
	queue<int> q;
	for(int i=0;i<a[1];++i) dis[i]=2e9;
	dis[0]=0;
	q.push(0);
	while(!q.empty()){
		int x=q.front();
		q.pop();
		vis[x]=0;
		for(int i=2;i<=n;++i){
			int y=(x+a[i])%a[1]; //枚举边
			if(dis[x]+a[i]<dis[y]){
				dis[y]=dis[x]+a[i];
				if(!vis[y]){
					vis[y]=1;
					q.push(y);
				}
			}
		}
	}
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i) scanf("%d",&a[i]);
	SPFA();
	scanf("%d",&k);
	while(k--){
		int x;
		scanf("%d",&x);
		if(x>=dis[x%a[1]]) printf("TAK\n");//判断
		else printf("NIE\n");
	}
}
```

---

## 作者：Rem_CandleFire (赞：1)

### 题目大意

$k$ 次询问，每次判断数 $x$ 可否被 $n$ 个数通过加法组成。

### 分析与做法

本题为同余最短路裸题，套路的，设 $dis_i$ 为 $n$ 个数能组成的模 $a_1$ 余 $i$ 的数中最小的。

通过最短路转移即可。

### 注意

数据范围 $n\le 5\times10^3,a_i\le 5\times 10^4$。

所以**不可以 vector 建边**，否则会 MLE。

### code

使用堆优化 Dijkstra。
```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const int N=5e4+5;
int n,m;
int a[N],vis[N]; LL dis[N];
struct node{ int pos; LL val; };
bool operator <(node a,node b){ return a.val>b.val; }
priority_queue<node> q;
void Dijkstra()
{
	fill(dis,dis+N-1,0x3f3f3f3f3f3f3f3f);
	dis[0]=0; q.push({0,0});
	while(!q.empty())
	{
		int p=q.top().pos; q.pop();
		if(vis[p]) continue;
		vis[p]=1;
		for(int i=1;i<=n;i++)
		{
			int to=(p+a[i])%a[1];
			if(dis[to]>dis[p]+a[i])
				dis[to]=dis[p]+a[i],q.push({to,dis[to]});
		}
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	Dijkstra();
	scanf("%d",&m); int x;
	for(int i=1;i<=m;i++)
	{
		scanf("%d",&x);
		if(dis[x%a[1]]<=x) puts("TAK");
		else puts("NIE");
	}
	return 0;
}

```

---

## 作者：Cells (赞：1)

### 思路

同余最短路的经典套路题。

如果你最基础的板板不会，那先做这道题 [P3403 跳楼机](https://www.luogu.com.cn/article/mhd24iq8)。

根据上一题，我们想到将 $a_1$ 以外的的数能够凑出来的模 $a_1$ 意义下 $x$ 的最小数求出来，我们记为 $dis_x$。每个余数 $0 \le i < a_1$ 向 $(i + a_j) \bmod a_1$ 建一条长为 $a_j$ 的边，其中 $2 \le j < n$。这样跑最短路就可以跑出来。

关于最短路算法的选择：

- Dijkstra 是贪心，卡不掉，也不会有人卡，可以用。
- SPFA 没有死（NOIP 有卡过 SPFA 吗？归程是 NOI 2018 的）由于特殊的建图，SPFA 不会被卡。

另外是对于 $a_1$ 的值的选择，有些题解的观点是直接取最小值，这样可以缩小点的范围，直观上好像会节省空间和时间，但是本人尝试了排序和直接取最小值这两种办法，和直接跑最短路没什么区别，并且在空间上，并不知道最小值，所以空间也不能变小。说到空间，这个题不能直接建图，因为空间爆炸，所以再跑最短路的时候现场处理。

最后我们直接判断这个数在模 $a_1$ 的意义下的余数与最小值的大小就可以了。

### Code

```c++
//# pragma GCC optimize("Ofast")
# include <bits/stdc++.h>
# define fr front
# define il inline
# define fir first
# define sec second
# define pb push_back
# define eb emplace_back
# define ls(x) (x << 1)
# define rs(x) (x << 1 | 1)
# define lson ls(p), l, mid
# define rson rs(p), mid + 1, r
# define lowbit(x) ((x) & (-(x)))
# define mem(a, b) memset(a, b, sizeof(a))
# define debug1(x) cerr << #x << " = " << x << " "
# define debug2(x) cerr << #x << " = " << x << "\n"
# define bug cerr << "--------------------------\n"
# define rep(i, a, b) for(int i = (a); i <= (b); ++ i)
# define pre(i, a, b) for(int i = (a); i >= (b); -- i)
using namespace std;

using DB = double;
using LL = long long;
using LDB = long double;
using PII = pair<int, int>;
using ULL = unsigned long long;

const int N = 5e3 + 10, AI = 5e4 + 10;

int n, q; 
int a[N], dis[AI];

bitset<AI> vis;

void dijkstra(int s){
	mem(dis, 0x3f);
	dis[s] = 0;
	
	vis.reset();
	
	priority_queue<PII, vector<PII>, greater<PII> > heap;
	heap.push({0, s});
	
	while(!heap.empty()){
		int u = heap.top().sec;
		heap.pop();
		
		if(vis[u]) continue;
		vis[u] = true;
		
		rep(i, 2, n){
			int v = (u + a[i]) % a[1], w = a[i];//现场处理
			
			if(vis[v] || dis[v] <= dis[u] + w) continue;
			dis[v] = dis[u] + w;
			heap.push({dis[v], v});
		}
	}
}

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	cin >> n;
	
	rep(i, 1, n) cin >> a[i];
	
	dijkstra(0);
	
	cin >> q;
	
	int x;
	while(q --){
		cin >> x;
		if(dis[x % a[1]] <= x) cout << "TAK\n";//大于都可以加上若干a[1]到达
		else cout << "NIE\n";
	}
	
	return 0;
}
```

**完结撒花！！！**

---

## 作者：myee (赞：1)

### 前言

大家好我是大常数选手 myee，我的 [Dijkstra 开 O2](https://www.luogu.com.cn/record/72811357) 还跑不过[不开 O2 的 SPFA](https://www.luogu.com.cn/record/68459523)，勇夺最劣解！

我说这不好。

### 思路

前置知识：[同余最短路](https://oi-wiki.org/graph/mod-shortest-path/)。

好，我假设你们都知道这大概是什么了。

我们考虑如何建图。

题目保证 $\{a\}$ 递增。

我们不妨取 $a_n$ 作为同余长度。（其实任意一个都是可以的）

注意到若 $P$ 可达，则 $P+ka_n$ 可达，其中 $k$ 可为任意自然数。

于是我们把问题转化成了：

对每个自然数 $0\le r<a_n$，求最小的 $P$ 满足 $P\equiv r\pmod{a_n}$ 使得其可达。

首先 $r=0$ 时 $P=0$ 显然。

其余的 $r$ 的 $P$ 可以通过最短路跑出来。

建图方法具体上就是说，你考虑连边 $r\rightarrow(r+a_k)\bmod a_n\quad(1\le k<n)$，权值为 $a_k$。

然后跑出来的结果就是 $P$。

询问时比较一下就好了。

### Code

```cpp
#include <algorithm>
#include <queue>
#include <stdio.h>
#include <vector>
typedef long long llt;
typedef unsigned uint;typedef unsigned long long ullt;
typedef bool bol;typedef char chr;typedef void voi;
typedef double dbl;
template<typename T>bol _max(T&a,T b){return(a<b)?a=b,true:false;}
template<typename T>bol _min(T&a,T b){return(b<a)?a=b,true:false;}
template<typename T>T power(T base,T index,T mod){return((index<=1)?(index?base:1):(power(base*base%mod,index>>1,mod)*power(base,index&1,mod)))%mod;}
template<typename T>T lowbit(T n){return n&-n;}
template<typename T>T gcd(T a,T b){return b?gcd(b,a%b):a;}
template<typename T>T lcm(T a,T b){return(a!=0||b!=0)?a/gcd(a,b)*b:(T)0;}
template<typename T>T exgcd(T a,T b,T&x,T&y){if(!b)return y=0,x=1,a;T ans=exgcd(b,a%b,y,x);y-=a/b*x;return ans;}
uint A[5005];
uint Dist[50005];
bol Gone[50005];
int main(){
    uint n;scanf("%u",&n);
    for(uint i=0;i<n;i++)scanf("%u",A+i);
    for(uint i=1;i<A[n-1];i++)Dist[i]=-1;
    typedef std::pair<ullt,uint>Pair;
    std::priority_queue<Pair,std::vector<Pair>,std::greater<Pair> >Q;
    Q.push(Pair(0,0));
    while(!Q.empty())
    {
        uint p=Q.top().second;Q.pop();
        if(Gone[p])continue;
        Gone[p]=true;
        for(uint i=0;i+1<n;i++)if(_min(Dist[(A[i]+p)%A[n-1]],A[i]+Dist[p]))Q.push(Pair(Dist[(A[i]+p)%A[n-1]],(A[i]+p)%A[n-1]));
    }
    uint k,v;
    scanf("%u",&k);
    while(k--)
    {
        scanf("%u",&v);
        puts(v<Dist[v%A[n-1]]?"NIE":"TAK");
    }
    return 0;
}
```




---

## 作者：hzoi_Shadow (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P8060)

# 前置知识

[同余最短路](https://oi-wiki.org/graph/mod-shortest-path/)

# 解法

考虑同余最短路，设 $dis_{i}$ 表示 $\bmod a_{1}=i$ 时能被拼成的最小值，接着只需要判断是否有 $dis_{b \bmod a_{1}} \le b$ 即可。

直接建边的空间复杂度为 $O(nV)$ ，无法接受。但我们发现边不一定非要建出来，可以在 Dijsktra 松弛时枚举 $a_{2 \sim n}$ 手动进行更新即可。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long 
#define ull unsigned long long
#define sort stable_sort 
#define endl '\n'
int dis[50010],vis[50010],a[50010],cnt=0;
void dijkstra(int s,int n)
{
	memset(dis,0x3f,sizeof(dis));
	memset(vis,0,sizeof(vis));
	priority_queue<pair<int,int> >q;
	dis[s]=0;
	q.push(make_pair(-dis[s],s));
	while(q.empty()==0)
	{
		int x=q.top().second;
		q.pop();
		if(vis[x]==0)
		{
			vis[x]=1;
			for(int i=1;i<=n;i++)
			{
				if(dis[(x+a[i])%a[1]]>dis[x]+a[i])
				{
					dis[(x+a[i])%a[1]]=dis[x]+a[i];
					q.push(make_pair(-dis[(x+a[i])%a[1]],(x+a[i])%a[1]));
				}
			}
		}
	}
}
int main()
{
// #define Isaac
#ifdef Isaac
	freopen("in.in","r",stdin);
	freopen("out.out","w",stdout);
#endif
	int n,m,b,i;
	cin>>n;
	for(i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	dijkstra(0,n);
	cin>>m;
	for(i=1;i<=m;i++)
	{
		cin>>b;
		cout<<((dis[b%a[1]]<=b)?"TAK":"NIE")<<endl;
	}
	return 0;
}
```

---

## 作者：_EternalRegrets_ (赞：0)

### 题意描述

> 给定集合 $A$。给定数字 $b_i$，求 $b_i$ 是否可以用 $A$ 中的数字加和组成。

### 思路

看到 $b_i$ 的数据范围，动规肯定是不行啦。

直接同余最短路即可。其实模数可以是集合 $A$ 中的任意数字，只不过取最小更优。

判断 $x$ 是否可行时，判断 $dist_{x \bmod a[1]}$ 和 $x$ 的大小关系即可。

### 代码

```
#include<bits/stdc++.h>
#define int long long
using namespace std;

struct node{
	int x;
	int w;
};

bool operator < (node x,node y){
	return x.w>y.w;
}

int a[500005];
int dist[500005];
int vis[500005];

int n;
void dij(){
	priority_queue <node> q;
	memset(dist,0x3f3f3f3f,sizeof dist);
	
	dist[0]=0; q.push({0,0});
	
	while(!q.empty()){
		int x; x=q.top().x; q.pop();
		if(vis[x]){
			continue;
		}
		
		vis[x]=1;
		
		for(int i=1;i<=n;i++){
			int to; to=(x+a[i])%a[1];
			
			if(dist[to]>dist[x]+a[i]){
				dist[to]=dist[x]+a[i];
				q.push({to,dist[to]});
			}
		}
	}
}

signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	
	dij();
	int t; cin>>t;
	
	while(t--){
		int x; cin>>x;
		
		if(dist[x%a[1]]<=x){
			cout<<"TAK\n";
		}
		else{
			cout<<"NIE\n";
		}
		
	//	cout<<dist[x%a[1]]<<endl;
	}
	
	return 0;
}
```

---

## 作者：int_R (赞：0)

# 同余最短路

省选模拟赛 T3 一小部分用到了同余最短路，发现自己从来没学过，补一下。

$n$ 个正整数，分别为 $A_1,A_2,\cdots,A_n$，求 $[0,V]$ 中有多少个数可以被表示为 $\sum\limits_{i=1}^{n} A_ix_i,x_i\in \mathbb{N}$。

可以完全背包，但复杂度 $O(nV)$，当 $V$ 很大的时候复杂度直接上天，我们想要找到一种与 $V$ 无关的算法。

发现如果 $x$ 可达，那么 $x+kA_1,k\in \mathbb{N}$ 都可达。也就是对于每个模 $A_1$ 的同余类 $[x]$，记其中可达的最小值为 $d_x$，则这个同余类中所有大于等于 $d_x$ 的数都可达。

假设现在我们知道 $d_x$，我们加入一个数 $v$，相当于有对 $y=(x+v)\bmod A_1$ 有一个转移 $d_y=\min(d_y,d_x+v)$，类似最短路的形式。所以我们对于 $i\in [2,n],j\in [0,A_1)$ 都建一条边 $j\to (j+A_i)\bmod A_1$，边权为 $A_i$，再在这个图上跑最短路，得到的答案即为每个同余类中可达的最小的数。

这样点数为 $A_1$，边数为 $nA_1$，使用 `dij` 的话时间复杂度 $O(nA_1+n\log (nA_1))$。

但是其实最短路是不必要的，对于一个数 $v$，在模 $m$ 时像上面那样建边，会形成 $\gcd(v,m)$ 个子环，更新只会在同一个子环中进行，在没有负环的时候更新肯定不会转满一整圈，所以只需要在这个环里转两圈就可以把所有可能的更新都进行完。

这样枚举 $n-1$ 个数字，时间复杂度 $O(nA_1)$。

可以选择最小的数作为 $A_1$ 来减小常数。

----

这个题就是直接同余最短路，然后最后判断 $k$ 与 $d_{k\bmod A_1}$ 的大小关系即可。

```cpp
#include<stdio.h>
#include<iostream>
#include<algorithm>
#include<string.h>
#define int long long
using namespace std;
const int MAXN=5e4+10;
int n,m,a[5010],x,y,dis[MAXN];
signed main()
{
#ifdef ONLINE_JUDGE
    cin.tie(0),cout.tie(0);
    ios::sync_with_stdio(0);
#endif
    cin>>n;for(int i=1;i<=n;++i) cin>>a[i];cin>>m;
    x=a[1];memset(dis,63,sizeof(dis));dis[0]=0;
    for(int k=2;k<=n;++k)
    {
        y=a[k];
        for(int i=0,lim=__gcd(y,x);i<lim;++i)
        {
            for(int cnt=0,p=i;cnt<2;cnt+=p==i)
            {
                int q=(p+y)%x;
                dis[q]=min(dis[q],dis[p]+y);p=q;
            }
        }
    }
    while(m--){int k;cin>>k;cout<<((k>=dis[k%x])?"TAK":"NIE")<<'\n';}
    return 0;
}
```

---

## 作者：CQ_Bab (赞：0)

# 思路
我们可以发现这道题和[跳楼机](https://www.luogu.com.cn/problem/P3403)一样的思路，那么我们就定义 $a_1$ 为那一个模的数，然后我们就可以建边了对吧，可是我们乍一看发现 $n\leq 5\times10^4$ 那么开数组就开不下了，所以我们就可以用一种神奇的方式可以避免建边那就是我们可以在枚举哪一个数为要跳的，然后我们就可以求出终点是哪一个节点了，然后就都是正常的最短路了。最后我们只需要判断 $dis_{x\bmod a_1}$ 与 $x$ 的关系即可。
# 代码
```cpp
#include <bits/stdc++.h>
using namespace std ;
#define int long long
#define rep(i,x,y) for(int i=x;i<=y;i++)
#define rep1(i,x,y) for(int i=x;i>-y;--i)
const int N=3e6+10;
int dis[N];
int a[5001],n;
struct node{
	int x,y,z;
}edg[10010000];
int head[N],tot;
void add(int x,int y,int z) {
	edg[++tot]={y,head[x],z};
	head[x]=tot;
}
#define pa pair<int,int>
int vis[N];
void dij(int s) {
	priority_queue<pa,vector<pa>,greater<pa> >q;
	q.push({0,s});
	memset(dis,0x3f,sizeof dis);
	dis[s]=0;
	while(q.size()) {
		int x=q.top().second;
		q.pop();
		if(vis[x]) continue;
		vis[x]=1;
		for(int i=1;i<=n;i++) { //神奇方法
			int to=(x+a[i])%a[1]; //求出要走到的点
			if(dis[to]>dis[x]+a[i]) { //模板
				dis[to]=dis[x]+a[i];
				q.push(make_pair(dis[to],to));
			}
		}
	}
}
signed main() {
	cin>>n;
	memset(head,-1,sizeof head);
	rep(i,1,n) cin>>a[i];
	int k;
	cin>>k;
	dij(0);
	while(k--) {
		int x;
		cin>>x;
		if(dis[x%a[1]]<=x) puts("TAK"); //判断关系
		else puts("NIE");
	}
	return false;
}

```

---

## 作者：封禁用户 (赞：0)

## 分析

这道题和[跳楼机](https://www.luogu.com.cn/problem/P3403)差不多。我们可以将 $A'$ 中的某一个元素看成从 $0$ 开始加，每次加 $a_1$ 到 $a_n$ 中的某一个元素得到的。我们以 $a_1$ 为定义 $f(i)$ 表示只通过累加 $a_2$ 到 $a_n$ 的任意多元素后能够得到的 $\bmod~a_1=i$ 的最小值。那么我们将得到以下方程组：

$\begin{cases}f(i+a_2)=f(i)+a_2\\f(i+a_3)=f(i)+a_3\\ \dots  \\ f(i+a_{n-1})=f(i)+a_{n-1} \\f(i+a_n)=f(i)+a_n \end{cases}$

类似于查分约束的方法，我们可以将 $f(x)$ 考虑成一个点，那么上面的方程组就变成了: $i$ 与 $i+a_j$ 之间有一条 $i$ 连向 $i+a_j$，权值为 $a_j$ 的边，其中 $2 \le j \le n$。我们可以通过最短路求出 $f(i)$ 的值。对于询问某一个元素 $x$ 是否存在于 $A'$，我们只需要看 $f(x \bmod a_1)$ 是否小于等于 $x$ 即可。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define PII pair<int,int>
#define x first
#define y second
const int N=4e6;
int n,k;
int a[N];
int x;
int dis[N],vis[N];
void dj(){
	memset(vis,0,sizeof(vis));
	priority_queue<PII,vector<PII>,greater<PII> > qu;
	memset(dis,0x3f,sizeof(dis));
	dis[0]=0,qu.push({0,0});
	while(!qu.empty()){
		PII now=qu.top();qu.pop();
		if(vis[now.y]) continue;
		vis[now.y]=1;
		for(int i=1;i<=n;i++){//边跑最短路边建边
			int j=(now.y+a[i])%a[1];
			int ww=a[i];
			if(dis[j]>now.x+ww){
				dis[j]=now.x+ww;
				qu.push({dis[j],j});
			}
		}
	}
}
int ans;
signed main(){
	memset(h,-1,sizeof(h));
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
//	for(int i=0;i<a[1];i++){
//		for(int j=2;j<=n;j++){
//			add(i,(i+a[j])%a[1],a[j]);
//		}
//	}
	dj();
	cin>>k;
	for(int ka=1;ka<=k;ka++){
		cin>>x;
		if(dis[x%a[1]]<=x){
			cout<<"TAK\n";
		}
		else{
			cout<<"NIE\n";
		}
	}
	return 0;
}
```

**注：**

如果我们在一开始就把所有的边用链式前向星存起来，由于空间的原因，就会得到几个不理想的返回结果。为了不出现这种情况，我们可以在跑最短路的时候进行建边，也就是能跑到哪里就建到哪里，跑完就删，下一次跑到再建。

---


# [THUPC 2023 决赛] 百合

## 题目背景

葡萄藤上开不出百合花。

## 题目描述

你落在一个巨大的葡萄架上，上面一共有 $2^k$ 朵百合花和 $m$ 条葡萄藤。其中，百合花编号为 $0$ 到 $2^k-1$ 的整数，第 $i$ 条葡萄藤连接了编号为 $x_i, y_i$ 的百合花。

你可以花费 $c_i$ 的时间通过第 $i$ 条葡萄藤，也就是从 $x_i$ 走到 $y_i$，或者反过来；还可以花费 $a_k$ 的时间从 $x$ 闪现到 $y$，其中 $x, y$ 是任意两朵百合花，$k$ 是它们在二进制表示下不同的比特数。例如，$3$ 的二进制表示是 $011$，$5$ 的二进制表示是 $101$，它们有两位不同，因此从 $3$ 闪现到 $5$ 花费的时间是 $a_2$。

假设你恰好落在编号为 $s$ 的百合花上，求从 $s$ 出发到每一朵百合花所需要的最短时间。

## 说明/提示

**【数据范围】**

对于所有测试数据，$1 \le k \leq 17$，$1 \le m \leq 2 \times 10^5$，$0 \leq s,x_i,y_i \leq 2^k - 1$，$0 \le a_i, c_i \leq 2^{30} - 1$。

**【题目来源】**


来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）决赛。

题解等资源可在 [https://github.com/THUSAAC/THUPC2023](https://github.com/THUSAAC/THUPC2023) 查看。

## 样例 #1

### 输入

```
3 6 2
17 14 11 
0 2 3
4 2 9
2 2 1
2 2 6
7 0 5
4 2 9
```

### 输出

```
3 14 0 17 9 11 17 8
```

# 题解

## 作者：EuphoricStar (赞：9)

复读官方题解。

考虑除了原图的 $2^k$ 个点，再建一些辅助点，$(u, i, j)$ 表示前 $i$ 位中修改了 $j$ 位得到 $u$。那么除了原图的 $m$ 条边，我们还有下面这些边：

- $u \xrightarrow{0} (u, 0, 0)$；
- $\forall i < k, (u, i, j) \xrightarrow{0} (u, i + 1, j)$；
- $\forall i < k, (u, i, j) \xrightarrow{0} (u \oplus 2^i, i + 1, j + 1)$；
- $(u, k, j) \xrightarrow{a_j} u$。

到这里可以做 $O(2^k k^3)$，但是还不够。

观察这个图，发现非 $0$ 边仅有 $O(2^k k)$ 条，于是我们在外层 Dijkstra 的同时，内层对 $u$ 能到达的所有辅助点跑一遍 BFS，给每个辅助点打上是否被访问过的标记，于是每个辅助点只会被访问一次，又因为非 $0$ 边仅有 $O(2^k k)$ 条，所以外层的堆也只会被 push 这么多次。所以时间复杂度就是 $O(2^k k^2)$，空间复杂度也是 $O(2^k k^2)$。

[code](https://loj.ac/s/1954661)

---

## 作者：Phartial (赞：2)

很难直接建出原图，“从 $x$ 中取出 $k$ 位并取反”这件事也很难直接描述，考虑每次只决策一位，设计辅助状态 $(x,i,j)$ 表示已经决策了前 $i$ 位，取反了其中 $j$ 位后得到的值是 $x$，描述建边是不难的：

- 对给定的每条边 $(x,y,c)$，建边 $(x,0,0)\stackrel{c}{\longleftrightarrow}(y,0,0)$；
- 对状态 $(x,i,j)$（$i<k$），建边 $(x,i,j)\stackrel{0}{\longrightarrow}(x,i+1,j)$；
- 对状态 $(x,i,j)$（$i<k$），建边 $(x,i,j)\stackrel{0}{\longrightarrow}(x\oplus2^i,i+1,j+1)$，其中 $\oplus$ 是按位异或；
- 对状态 $(x,k,j)$，建边 $(x,k,j)\stackrel{a_j}{\longrightarrow}(x,0,0)$。

这张图的点数是 $N=2^kk^2$，边数是 $M=\mathcal{O}(m+2^kk^2)$，于是直接在上面跑 Dijkstra 的时间复杂度是 $\mathcal{O}((M+N)\log N)=\mathcal{O}(mk+2^kk^3)$ 的，不太能过。

注意到这张图里其实有很多 $0$ 权边。假设我们正在松弛状态 $u$ 的出边，则对其 $0$ 权出边与到达的未确定最短路的点 $v$，$v$ 的最短路一定会被更新成 $u$ 的最短路，并在下一轮松弛中被立即处理。

于是我们可以把这个过程单独提出来：松弛一个状态 $u$ 时立即更新并松弛其所有 $0$ 权出点 $v$，这是一个类似 BFS 的过程（当然写成 DFS 也行），可以线性地完成。

于是只有在松弛非 $0$ 权边时我们需要对维护的数据结构（比如优先队列）进行操作，而非 $0$ 权边只有 $M'=m+2^kk$ 条，于是总时间复杂度是 $\mathcal{O}((M'+N)\log N)=\mathcal{O}(mk+2^kk^2)$ 的，可以通过。

最后就是这个东西空间有点紧，但是事实上我们只要维护形如 $(x,0,0)$ 的状态的最短路，精细实现一下就开得下了。

```cpp
#include <iostream>
#include <queue>
#include <vector>

using namespace std;
using LL = long long;
using Pli = pair<LL, int>;

const int kK = 18, kN = (1 << kK - 1);

struct S {
  int x, i, j;
} q[kN * 2];
int k, n, m, s, qh, qt, a[kK];
LL d[kN];
bool v[kN][kK][kK];
vector<pair<int, int>> e[kN];
priority_queue<Pli, vector<Pli>, greater<Pli>> pq;

void R(int x, LL _d) {
  if (_d < d[x]) {
    d[x] = _d, pq.emplace(_d, x);
  }
}
void R(int x, int i, int j) {
  if (!v[x][i][j]) {
    v[x][i][j] = 1, q[++qt] = {x, i, j};
  }
}

int main() {
  ios::sync_with_stdio(0), cin.tie(0);
  cin >> k >> m >> s, n = (1 << k);
  for (int i = 1; i <= k; ++i) {
    cin >> a[i];
  }
  for (int i = 1, x, y, w; i <= m; ++i) {
    cin >> x >> y >> w;
    e[x].emplace_back(y, w);
    e[y].emplace_back(x, w);
  }
  fill_n(d, n, 1e18);
  for (R(s, 0); !pq.empty();) {
    int x = pq.top().second;
    pq.pop();
    for (auto i : e[x]) {
      R(i.first, d[x] + i.second);
    }
    qh = 1, qt = 0;
    for (R(x, 0, 0); qh <= qt; ++qh) {
      S y = q[qh];
      if (y.i < k) {
        R(y.x, y.i + 1, y.j);
        R(y.x ^ (1 << y.i), y.i + 1, y.j + 1);
      } else {
        R(y.x, d[x] + a[y.j]);
      }
    }
  }
  for (int i = 0; i < n; ++i) {
    cout << d[i] << ' ';
  }
  return 0;
}
```

---

## 作者：Albert_van (赞：2)

容易想到加辅助点建图直接最短路。稍微做一些尝试，发现只加 $n=2^k$ 甚至 $k$ 个点是无法满足要求的。考虑加 $nk$ 个点，$(u,j)$ 表示当前在 $u$，这一次传送已经修改了 $j$ 位。保留原图 $m$ 条边，连边 $u\to (u,0),(u,j)\to (u\oplus 2^i,j+1)$（边权均为 $0$），$(u,j)\to u$ 边权 $a_j$。问题来了，一个位置 $i$ 可能被修改两次。

考虑再阔一点，直接加 $nk^2$ 个辅助点，$(u,i,j)$ 表示当前在 $u$，现在考虑第 $i$ 位，这一次传送已经修改了 $j$ 位。这允许我们不重复地枚举 $i$。连边

- $u\to(u,0,0)$
- $(u,i,j)\to(u\oplus 2^i,i+1,j+1)$
- $(u,i,j)\to(u,i+1,j)$
- $(u,k,j)\to u$，边权 $a_j$

加原图 $m$ 条边跑最短路即可。然而该图边数 $\mathcal O(nk^2)$，Dij 复杂度 $\mathcal O(nk^3)$ 无法接受。

考虑边权不为 $0$ 的边只有 $\mathcal O(nk)$ 条。这启发我们对辅助点部分的求解过程做出优化。具体地，对于原图点 $u$，暴力搜出它能**不经过其它原图点**到达的所有辅助点，拿 $f_u+a_j$ 直接更新接下来的原图点即可。搜的过程中对辅助点做上标记，遇到标记过的点就不继续搜。正确性显然，dij 是基于贪心的。

于是复杂度降为 $\mathcal O(nk\log(nk)+nk^2)=\mathcal O(nk^2)$。

```cpp
void dij(int s){
	memset(f,63,sizeof(f));
	q.push((nod){s,f[s]=0});
	while(!q.empty()){
		int now=q.top().x;q.pop();if(vis[now]) continue;
		vis[now]=1;for(auto[v,w]:vc[now]) if(f[now]+w<f[v]) q.push((nod){v,f[v]=f[now]+w});
		qx.push((xzr){now,0,0});while(!qx.empty()){
			auto[u,i,j]=qx.front();qx.pop();
			vix[i][j][u]=1;if(i==k){
				if(f[now]+a[j]<f[u]) q.push((nod){u,f[u]=f[now]+a[j]});
				continue;
			}
			if(!vix[i+1][j][u]) qx.push((xzr){u,i+1,j});
			if(!vix[i+1][j+1][u^(1<<i)]) qx.push((xzr){u^(1<<i),i+1,j+1});
		}
	}
}
```



---


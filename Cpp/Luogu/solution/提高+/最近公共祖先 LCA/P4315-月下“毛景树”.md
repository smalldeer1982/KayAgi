# 月下“毛景树”

## 题目背景

毛毛虫经过及时的变形，最终逃过的一劫，离开了菜妈的菜园。 毛毛虫经过千山万水，历尽千辛万苦，最后来到了小小的绍兴一中的校园里。

## 题目描述

爬啊爬~爬啊爬~~毛毛虫爬到了一颗小小的“毛景树”下面，发现树上长着他最爱吃的毛毛果~~~ “毛景树”上有 $N$ 个节点和 $N-1$ 条树枝，但节点上是没有毛毛果的，毛毛果都是长在树枝上的。但是这棵“毛景树”有着神奇的魔力，他能改变树枝上毛毛果的个数：

- `Change k w`：将第 $k$ 条树枝上毛毛果的个数改变为 $w$ 个。
- `Cover u v w`：将节点 $u$ 与节点 $v$ 之间的树枝上毛毛果的个数都改变为 $w$ 个。
- `Add u v w`：将节点 $u$ 与节点 $v$ 之间的树枝上毛毛果的个数都增加 $w$ 个。

由于毛毛虫很贪，于是他会有如下询问：

-  `Max u v`：询问节点 $u$ 与节点 $v$ 之间树枝上毛毛果个数最多有多少个。

## 说明/提示

对于全部数据，$1\le N\le 10^5$，操作和询问数目不超过 $10^5$。

保证在任意时刻，所有树枝上毛毛果的个数都不会超过 $10^9$ 个。

## 样例 #1

### 输入

```
4
1 2 8
1 3 7
3 4 9
Max 2 4
Cover 2 4 5
Add 1 4 10
Change 1 16
Max 2 4
Stop```

### 输出

```
9
16```

# 题解

## 作者：King丨帝御威 (赞：46)

这道题目，如果把边权改为点权的话，那么就是一个树链剖分+线段树的裸题了，就是两遍dfs找出重儿子，对点进行重新编号，然后树链剖分即可。

但是！！——这题是边权，那怎么办呢？我们发现，一个点最多只有一个父亲结点，那么我们就可以考虑把这个点与其父亲结点之间边的边权转化为这个点的点权！那，之后，就变成了我们一开始说的树链剖分裸题了呀！还有一个非常重要的细节就是树链剖分查询和修改路径的时候，父亲结点是不在路径上的！因为父亲结点的点权代表的是它与它的父亲之间的边权，因此，在查询和修改的时候，最后左端点为$id[x]$+$1$。

具体实现看代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<cctype>
#define maxn 100007
#define ll long long
#define ls rt<<1
#define rs rt<<1|1
using namespace std;
int n,head[maxn],d[maxn],size[maxn],son[maxn],a[maxn],tag[maxn<<2];                             //tag是把区间改为一个数时的lazy数组。
int p[maxn],id[maxn],top[maxn],num,cnt,lazy[maxn<<2],fa[maxn],maxx[maxn<<2];              
char s[10];
inline int qread() {
  char c=getchar();int num=0,f=1;
  for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
  for(;isdigit(c);c=getchar()) num=num*10+c-'0';
  return num*f;
}
struct node {
  int v,w,nxt;
}e[maxn<<1];
inline void ct(int u, int v, int w) {  
  e[++num].v=v;
  e[num].w=w;
  e[num].nxt=head[u];
  head[u]=num;
}
inline void pushup(int rt) {
  maxx[rt]=max(maxx[ls],maxx[rs]);
}
inline void pushdown(int rt) {
  if(tag[rt]>=0) {
    lazy[ls]=lazy[rs]=0;
    maxx[ls]=maxx[rs]=tag[ls]=tag[rs]=tag[rt];
    tag[rt]=-1;
  }
  if(lazy[rt]) {
    lazy[ls]+=lazy[rt];
    lazy[rs]+=lazy[rt];
    maxx[ls]+=lazy[rt];
    maxx[rs]+=lazy[rt];
    lazy[rt]=0;
  }
}
void build(int rt, int l, int r) {
  tag[rt]=-1;
  if(l==r) {
    maxx[rt]=a[l];
    return;
  }
  int mid=(l+r)>>1;
  build(ls,l,mid);
  build(rs,mid+1,r);
  pushup(rt);
}
void modify1(int rt, int l, int r, int L, int R, int val) {
  if(L>r||R<l) return;
  if(L<=l&&r<=R) {
    lazy[rt]+=val;
    maxx[rt]+=val;
    return;
  }
  pushdown(rt);
  int mid=(l+r)>>1;
  if(L<=mid) modify1(ls,l,mid,L,R,val);
  if(R>mid) modify1(rs,mid+1,r,L,R,val);
  pushup(rt);
}
void modify2(int rt, int l, int r, int L, int R, int val) {
  if(L>r||R<l) return;
  if(L<=l&&r<=R) {
    maxx[rt]=tag[rt]=val;
    lazy[rt]=0;
    return;
  }
  pushdown(rt);
  int mid=(l+r)>>1;
  modify2(ls,l,mid,L,R,val),modify2(rs,mid+1,r,L,R,val);
  pushup(rt);
}
int cmax(int rt, int l, int r, int L, int R) {
  if(L<=l&&r<=R) return maxx[rt];
  int ans=0;
  int mid=(l+r)>>1;
  pushdown(rt);
  if(L<=mid) ans=max(ans,cmax(ls,l,mid,L,R));
  if(R>mid) ans=max(ans,cmax(rs,mid+1,r,L,R));
  return ans;
}
void dfs1(int u, int f) {
  size[u]=1;
  for(int i=head[u];i;i=e[i].nxt) {
    int v=e[i].v;
    if(v!=f) {
      d[v]=d[u]+1;
      fa[v]=u;
      p[v]=e[i].w;
      dfs1(v,u);
      size[u]+=size[v];
      if(size[v]>size[son[u]]) son[u]=v;
    }
  }
}
void dfs2(int u, int t) {
  id[u]=++cnt;
  top[u]=t;
  a[cnt]=p[u];
  if(son[u]) dfs2(son[u],t);
  for(int i=head[u];i;i=e[i].nxt) {
    int v=e[i].v;
    if(v!=fa[u]&&v!=son[u]) dfs2(v,v);
  }
}
void cal1(int x, int y, int val) {
  int fx=top[x],fy=top[y];
  while(fx!=fy) {
    if(d[fx]<d[fy]) swap(x,y),swap(fx,fy);
    modify1(1,1,n,id[fx],id[x],val);
    x=fa[fx],fx=top[x];
  }
  if(id[x]>id[y]) swap(x,y);
  modify1(1,1,n,id[x]+1,id[y],val);
}
void cal2(int x, int y, int val) {
  int fx=top[x],fy=top[y];
  while(fx!=fy) {
    if(d[fx]<d[fy]) swap(x,y),swap(fx,fy);
    modify2(1,1,n,id[fx],id[x],val);
    x=fa[fx],fx=top[x];
  }
  if(id[x]>id[y]) swap(x,y);
  modify2(1,1,n,id[x]+1,id[y],val);
}
int query(int x, int y) {
  int ans=0,fx=top[x],fy=top[y];
  while(fx!=fy) {
    if(d[fx]<d[fy]) swap(x,y),swap(fx,fy);
    ans=max(ans,cmax(1,1,n,id[fx],id[x]));
    x=fa[fx],fx=top[x];
  }
  if(id[x]>id[y]) swap(x,y);
  ans=max(ans,cmax(1,1,n,id[x]+1,id[y]));
  return ans;
}
int main() {
  n=qread();
  for(int i=1,u,v,w;i<n;++i) {
    u=qread(),v=qread(),w=qread();
    ct(u,v,w);ct(v,u,w);
  }
  dfs1(1,0),dfs2(1,1);build(1,1,n);
  while(1) {
    scanf("%s",s);
    if(s[0]=='S') break;
    int x=qread(),y=qread();
    if(s[1]=='h') {
      x=d[e[x*2-1].v]<d[e[x<<1].v]?e[x<<1].v:e[x*2-1].v;
      modify2(1,1,n,id[x],id[x],y);        //这里必须要加这句话！因为我们dfs时没有记录哪个边具体对应哪个点。
    }
    if(s[1]=='o') {
      int zrj=qread();
      cal2(x,y,zrj);
    }
    if(s[1]=='d') {
      int zrj=qread();
      cal1(x,y,zrj);
    }
    if(s[1]=='a') printf("%d\n",query(x,y)); 
  }
  return 0;
}
```

代码量有点大，调起来也挺难的，本蒟蒻调了一下午……可能我太弱了，祝大家一遍AC啊！！！

---

## 作者：yurzhang (赞：16)

## 前言

这道题其实就是把 `单点修改` 、 `区间染色` 、 `区间加` 以及 `区间最大值` 这四种基本的序列操作出到了树上，很明显是用 `树链剖分` + `线段树` 解决，但是因为我太蒻了，树剖码到一半码不下去了，所以就全删了改码了个 `Link-Cut Tree` ，顺便 **拿了这个题的[RANK1](https://www.luogu.org/record/list?pid=P4315&orderBy=1&status=&page=1)** 。

---
## 边转点

树剖的边转点大家都知道是把每条边的权值给深度较深的那个点，但是我们不能在 `LCT` 上也这么做，因为有 `makeroot` 操作的存在， `LCT` 上结点的父子关系不是确定的，所以我们采取建立 `虚拟结点` 的方式：
```cpp
// 第 i 条边连接 u 和 v 这两个点，权值为 w
val[n+i]=maxv[n+i]=w;
link(u,n+i);
link(n+i,v);
```
用 $n$ + $i$ 号结点表示第 $i$ 条边，再用它去分别连接原先的边连接的结点。

### 需要注意的地方

1. 这种写法会产生 $2n$ 个结点， **空间千万要开够！**
2. 标记上传下传的时候要分 **原结点** 和 **虚拟结点** 两种情况讨论！

---
## 标记

这道题我们只需要维护一个 `区间染色` 的标记和一个 `区间加` 的标记就行，我多维护了一个 `siz` 数组储存子树内 `虚拟结点` 的数量，上传时判断当前结点是不是 `虚拟结点` 就行。

标记下传的时候要 **先下传区间染色，再下传区间加** ，若是先下传了 `区间加` ，后面 `区间染色` 的时候就会 **覆盖掉** 

---
## 最后

这是 `LCT` 712ms[评测记录](https://www.luogu.org/recordnew/show/17081420)

最后附上此题 $AC$ 代码：
```cpp
#include <cstdio>

#define N 200010
#define lc(x) ch[x][0]
#define rc(x) ch[x][1]
#define re register
#define gc pa==pb&&(pb=(pa=buf)+fread(buf,1,100000,stdin),pa==pb)?EOF:*pa++
inline int max(int a,int b){return b<a?a:b;}
inline void swap(int&a,int&b){int tmp(a);a=b,b=tmp;}
static char buf[100000],*pa(buf),*pb(buf);
static char pbuf[3000000],*pp(pbuf),st[15];
inline char gtc()
{
    re char c(gc);
    while(c!='S'&&c!='h'&&c!='o'&&c!='d'&&c!='a')c=gc;
    return c;
}
inline int read()
{
    re int x(0);re char c(gc);
    while(c<'0'||c>'9')c=gc;
    while(c>='0'&&c<='9')
        x=x*10+c-48,c=gc;
    return x;
}
inline void write(re int v)
{
    if(!v)
        *pp++=48;
    else
    {
        re char*tp(st);
        while(v)
            *++tp=v%10+48,v/=10;
        while(tp!=st)
            *pp++=*tp--;
    }
    *pp++='\n';
}

int n,u,v,w;
char opt;

int ch[N][2],fa[N],rev[N],val[N],maxv[N],ass[N],addv[N],siz[N];
inline void assign(int x,int y){val[x]=x>n?y:0,maxv[x]=siz[x]>0?y:0,addv[x]=0,ass[x]=y;}
inline void add(int x,int y){val[x]+=x>n?y:0,maxv[x]+=siz[x]>0?y:0,addv[x]+=siz[x]>0?y:0;}
inline void up(int x){siz[x]=siz[lc(x)]+siz[rc(x)]+(x>n),maxv[x]=max(val[x],max(maxv[lc(x)],maxv[rc(x)]));}
inline void down(int x)
{
    if(rev[x])rev[lc(x)]^=1,rev[rc(x)]^=1,rev[x]=0,swap(lc(x),rc(x));
    if(ass[x])assign(lc(x),ass[x]),assign(rc(x),ass[x]),ass[x]=0;
    if(addv[x])add(lc(x),addv[x]),add(rc(x),addv[x]),addv[x]=0;
}
inline int nrt(int x){return x==lc(fa[x])||x==rc(fa[x]);}
void psa(int x){if(nrt(x))psa(fa[x]);down(x);}
inline void rotate(int x)
{
    int y(fa[x]),z(fa[y]),k(x==rc(y));
    ch[y][k]=ch[x][k^1],ch[x][k^1]=y;if(nrt(y))ch[z][y==rc(z)]=x;
    if(ch[y][k])fa[ch[y][k]]=y;fa[y]=x,fa[x]=z,up(y);
}
inline void splay(int x)
{
    int y,z;
    for(psa(x);nrt(x);rotate(x))
    {y=fa[x],z=fa[y];if(nrt(y))rotate(x==rc(y)^y==rc(z)?x:y);}up(x);
}
inline void access(int x){for(int y(0);x;x=fa[y=x])splay(x),rc(x)=y,up(x);}
inline void mrt(int x){access(x),splay(x),rev[x]^=1;}
inline void split(int x,int y){mrt(x),access(y),splay(y);}
inline void link(int x,int y){mrt(x),fa[x]=y;}

int main()
{
    n=read();
    for(re int i(1);i<n;++i)
        siz[n+i]=1;
    for(re int i(1);i<n;++i)
        u=read(),v=read(),val[n+i]=maxv[n+i]=read(),link(u,n+i),link(n+i,v);
    opt=gtc();
    while(opt!='S')
    {
        u=read(),v=read();
        switch(opt)
        {
            case'h':
                access(n+u),splay(n+u),val[n+u]=v;
                break;
            case'o':
                split(u,v),assign(v,read());
                break;
            case'd':
                split(u,v),add(v,read());
                break;
            case'a':
                split(u,v),write(maxv[v]);
        }
        opt=gtc();
    }
    fwrite(pbuf,1,pp-pbuf,stdout);
    return 0;
}
```

---

## 作者：James_Brady (赞：10)

这道~~毒瘤~~题本人试了6遍才过，写篇题解纪念一下

首先，关于树链剖分及重儿子，重链的概念，在此不再废话，请自行百度

这题~~毒瘤~~难的一点就是点权变成边权了

## 那怎么办呢

# 边权换点权！！！

如下图所示，把每边权值赋给其下端的点（根节点为0）

![](https://cdn.luogu.com.cn/upload/pic/61502.png)

然后就是模板的问题了

但有几个细节，本题又加又覆，需要两个懒标记，记得处理他们的关系

还有一件事，当查询时转化为一条重链时，如图：

![](https://cdn.luogu.com.cn/upload/pic/61504.png)

此时我们要求u，v两点间的权值最大值，但是u节点存的是红边的值，这不是我们要找的答案

而sun[u]存的是蓝边，这正是我们的目标

所以最后要查询的区间是son[u]~v之间的最大值

代码如下：

```cpp
#include<iostream>
#include<cstdio>
#define lson id<<1,l,m
#define rson id<<1|1,m+1,r
using namespace std;
struct node{
	int v;
	int next;
}e[N<<1];
int pos[N],tid[N],top[N],dep[N],son[N],siz[N],f[N],head[N];
int d[N][5],sum[N<<2],col[N<<2],lzy[N<<2],n,m,k,ofo;
void add(int u,int v)//加边函数，记得加双向
{
	e[++k].v=v;
	e[k].next=head[u];
	head[u]=k;
}
void dfs1(int u,int fa)//两个dfs初始化
{
	f[u]=fa;
	siz[u]=1;
	son[u]=0;
	dep[u]=dep[fa]+1;
	for(int i=head[u];i;i=e[i].next)
	{
		int v=e[i].v;
		if(v==fa)
		continue;
		dfs1(v,u);
		siz[u]+=siz[v];
		if(siz[v]>siz[son[u]])
		son[u]=v;
	}
}
void dfs2(int u,int tp)
{
	top[u]=tp;
	tid[u]=++ofo;
	pos[ofo]=u;
	if(son[u])
	dfs2(son[u],tp);
	for(int i=head[u];i;i=e[i].next)
	{
		int v=e[i].v;
		if(v==f[u]||v==son[u])
		continue;
		dfs2(v,v);
	}
}
void pushup(int id)
{
	sum[id]=max(sum[id<<1],sum[id<<1|1]);
}
void pushdown(int id)//因为这个WA了不下三遍
{
	if(lzy[id]!=-1)//先覆再加！先覆再加！先覆再加！重要的事情说三遍
	{
		col[id<<1]=col[id<<1|1]=0;
		sum[id<<1]=sum[id<<1|1]=lzy[id];
		lzy[id<<1]=lzy[id<<1|1]=lzy[id];
		lzy[id]=-1;
	}
	if(col[id])
	{
		col[id<<1]+=col[id];
		col[id<<1|1]+=col[id];
		sum[id<<1]+=col[id];
		sum[id<<1|1]+=col[id];
		col[id]=0;
	}
}
void build(int id,int l,int r)
{
	lzy[id]=-1;
	if(l==r)
	return;
	int m=(l+r)>>1;
	build(lson);
	build(rson);
	pushup(id);
}
void update1(int id,int l,int r,int x,int y,int z)//区间加数
{
	if(x<=l&&r<=y)
	{
		sum[id]+=z;
		col[id]+=z;
		return;
	}
	int m=(l+r)>>1;
	pushdown(id);
	if(x<=m)
	update1(lson,x,y,z);
	if(y>m)
	update1(rson,x,y,z);
	pushup(id);
}
void update2(int id,int l,int r,int x,int y,int z)//区间覆盖
{
	if(x<=l&&r<=y)
	{
		sum[id]=z;
		lzy[id]=z;
		col[id]=0;
		return;
	}
	int m=(l+r)>>1;
	pushdown(id);
	if(x<=m)
	update2(lson,x,y,z);
	if(y>m)
	update2(rson,x,y,z);
	pushup(id);
}
int query(int id,int l,int r,int x,int y)//区间查询
{
	if(x<=l&&r<=y)
	return sum[id];
	int m=(l+r)>>1,ans=-1e9;
	pushdown(id);
	if(x<=m)
	ans=max(ans,query(lson,x,y));
	if(y>m)
	ans=max(ans,query(rson,x,y));
	return ans;
}
void Tupdate(int a,int b,int c,int flag)//树剖区间修改
{
	while(top[a]!=top[b])
	{
		if(dep[top[a]]<dep[top[b]])
		swap(a,b);
		if(flag==1)
		update1(1,1,n,tid[top[a]],tid[a],c);
		else
		update2(1,1,n,tid[top[a]],tid[a],c);
		a=f[top[a]];
	}
	if(a==b)
	return;
	if(dep[a]>dep[b])
	swap(a,b);
	if(flag==1)
	update1(1,1,n,tid[son[a]],tid[b],c);
	else
	update2(1,1,n,tid[son[a]],tid[b],c);
}
int Tquery(int a,int b)//树剖区间查询
{
	int ans=-1e9;
	while(top[a]!=top[b])
	{
		if(dep[top[a]]<dep[top[b]])
		swap(a,b);
		ans=max(ans,query(1,1,n,tid[top[a]],tid[a]));
		a=f[top[a]];
	}
	if(a==b)
	return ans;
	if(dep[a]>dep[b])
	swap(a,b);
	ans=max(ans,query(1,1,n,tid[son[a]],tid[b]));
	return ans;
}
int main()//注：在这里我用了数组来存边，就不用乘以二了
{
	scanf("%d",&n);
	for(int i=1;i<n;i++)
	{
		scanf("%d%d%d",&d[i][0],&d[i][1],&d[i][2]);
		add(d[i][0],d[i][1]);
		add(d[i][1],d[i][0]);
	}
	dfs1(1,1);
	dfs2(1,1);
	build(1,1,n);
	for(int i=1;i<n;i++)
	{
		if(dep[d[i][0]]>dep[d[i][1]])
        swap(d[i][0],d[i][1]);
		update1(1,1,n,tid[d[i][1]],tid[d[i][1]],d[i][2]);
	}
	char s[15]={'f'};
	while(s[0]!='S')
	{
		int a,b,c;
		scanf("%s",s);
		if(s[0]=='A')
		{
			scanf("%d%d%d",&a,&b,&c);
			Tupdate(a,b,c,1);
		}
		if(s[0]=='C')
		{
			if(s[1]=='o')
			{
				scanf("%d%d%d",&a,&b,&c);
				Tupdate(a,b,c,2);
			}
			if(s[1]=='h')
			{
				scanf("%d%d",&a,&b);
				update2(1,1,n,tid[d[a][1]],tid[d[a][1]],b);
			}
		}
		if(s[0]=='M')
		{
			scanf("%d%d",&a,&b);
			printf("%d\n",Tquery(a,b));
		}
	}
	return 0;
}
```


---

## 作者：tyg这个lajixswl (赞：8)

# 我永远喜欢珂朵莉！！

分析题意, 要求支持对树上边权的：
1. 区间推平
1. 单边修改
1. 区间最大值。

-  边权问题我们可以边权下放点权转化为点权问题。

- 树上的点权问题我们可以通过树剖转化为序列问题,
- 序列上的区间推平，单点修改，区间最大值我们显然可以利用珂朵莉树维护。

**几个坑点**

问题主要之中在边权下放边权后的细节处理

-   查询/修改操作时，当节点x,y落到同一条链上时，查询/修改范围应为( dfn[x],dfn[y] ]

 _因为边权下放点权之后，如果我们直接查询[ dfn[x],dfn[y] ],我们将多处理节点x所对应的边权，与题意点x~y之间边权的要求不符_
 
 
 
 
 
- 为了满足题目要求的单边修改操作，我们要记录每条边的id,在dfs过程中，记录边的两个端点，扔到两个数组里，assign(id1[i],id2[i])就代表修改边i权的权值
  
## Code
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<set>
#define IT set<Node>::iterator
using namespace std;
const int N=1e5+7;
int n;
int cnt,col;
int fa[N],son[N],top[N],dep[N],siz[N],dis[N],dfn[N],id1[N],id2[N],val[N],head[N];
struct Node
{
  int l,r;
  mutable int val;
  Node(int L,int R=-1,int V=0):l(L),r(R),val(V){}
  bool operator<(const Node &o)const
  {
      return l<o.l;
  }
};
set<Node>s;
inline IT split(int pos)
{
    IT it=s.lower_bound(Node(pos));
    if(it!=s.end()&&it->l==pos)return it;
    --it;
    int L=it->l,R=it->r;
    int V=it->val;
    s.erase(it);
    s.insert(Node(L,pos-1,V));
    return s.insert(Node(pos,R,V)).first;
}
inline void basic_assign(int l,int r,int val)
{
    IT itr=split(r+1),itl=split(l);
    s.erase(itl,itr);
    s.insert(Node(l,r,val));
}
inline void basic_update(int l,int r,int val)
{
    IT itr=split(r+1),itl=split(l);
    for(;itl!=itr;itl++)
    {
        itl->val+=val;
    }
}
inline int basic_query(int l,int r)
{
    register int res=0;
    IT itr=split(r+1),itl=split(l);
    for(;itl!=itr;itl++)
    {
        res=max(res,itl->val);
    }
    return res;
}
struct Edge
{
    int next,to,dis,id;
}e[N<<1];
inline void add(int u,int v,int w,int id)
{
    e[++cnt].next=head[u];
    head[u]=cnt;
    e[cnt].to=v;
    e[cnt].dis=w;
    e[cnt].id=id;
}
inline void dfs1(int x,int father,int deep)
{
    fa[x]=father;dep[x]=deep;siz[x]=1;
    register int maxson=-1;
    for(register int i=head[x];i;i=e[i].next)
    {
        int y=e[i].to;
        if(y==father)continue;
        id1[e[i].id]=y;
        id2[e[i].id]=x;
        val[y]=e[i].dis;
        dfs1(y,x,deep+1);
        siz[x]+=siz[y];
        if(siz[y]>maxson)
        {
            maxson=siz[y];
            son[x]=y;
        }
    }
}
inline void dfs2(int x,int topp)
{
    top[x]=topp;dfn[x]=++col;
    s.insert(Node(col,col,val[x]));
    if(!son[x])return;
    dfs2(son[x],topp);
    for(register int i=head[x];i;i=e[i].next)
    {
        int y=e[i].to;
        if(y==fa[x]||y==son[x])continue;
        dfs2(y,y);
    }
}
inline void assign(int x,int y,int val)
{
    while(top[x]!=top[y])
    {
        if(dep[top[x]]<dep[top[y]])swap(x,y);
        basic_assign(dfn[top[x]],dfn[x],val);
        x=fa[top[x]];
    }
    if(dep[x]<dep[y])swap(x,y);
    basic_assign(dfn[y]+1,dfn[x],val);
}
inline void update(int x,int y,int val)
{
    while(top[x]!=top[y])
    {
        if(dep[top[x]]<dep[top[y]])swap(x,y);
        basic_update(dfn[top[x]],dfn[x],val);
        x=fa[top[x]];
    }
    if(dep[x]<dep[y])swap(x,y);
    basic_update(dfn[y]+1,dfn[x],val);
}
inline int query(int x,int y)
{
    register int res=0;
    while(top[x]!=top[y])
    {
        if(dep[top[x]]<dep[top[y]])swap(x,y);
        res=max(res,basic_query(dfn[top[x]],dfn[x]));
        x=fa[top[x]];
    }
    if(dep[x]<dep[y])swap(x,y);
    res=max(res,basic_query(dfn[y]+1,dfn[x]));
    return res;
}
inline int read()
{
   int res=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){res=res*10+ch-'0';ch=getchar();}
    return res*f;
}
string ss;
int main()
{
    n=read();
    for(register int i=1;i<n;i++)
    {
        register int u=read(),v=read(),w=read();
        add(u,v,w,i);
        add(v,u,w,i);
    }
    dfs1(1,0,1);
    dfs2(1,1);
    while(true)
    {
        cin>>ss;
        if(ss=="Stop")break;
        register int u=read(),v=read();
        if(ss=="Max")printf("%d\n",query(u,v));
        if(ss=="Add")
        {
            register int w=read();
            update(u,v,w);
        }
        if(ss=="Cover")
        {
            register int w=read();
            assign(u,v,w);
        }
        if(ss=="Change")
        {
            assign(id2[u],id1[u],v);
        }
    }
    return 0;
}
```


---

## 作者：Treaker (赞：7)

## 一个树剖题。

我们可以对于线段树的每一个节点，维护区间覆盖 ， 区间加 ， 区间最大值。

注意在我们的区间加之前，一定要先把区间覆盖（更新它的值） 

这里采用数组写法，指针写法详见[我博客](https://www.luogu.org/blog/Treaker/#)其他树剖题。

顺便推荐做一下模板[【模板】树链剖分](https://www.luogu.com.cn/problem/P3384)  

码量海星！ 细心一点就更加完美了！

完整代码如下：
```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstring>
using namespace std;
const int N = 100100;
int ls(int x) {return x << 1;}
int rs(int x) {return x << 1 | 1;}
int n , cnt;
int u[N] , v[N] , w[N] , dep[N] , size[N] , fa[N] , top[N] , hs[N] , a[N] , son[N] , head[N] , dfn[N] , id[N];
int maxn[N << 2] , tag[N << 2] , lazy[N << 2];
char s[10];
struct Edge
{
	int to , dis , nxt;
}e[N << 1];
void add(int from,int to,int dis)
{
	e[++cnt] = (Edge){to,dis,head[from]};
	head[from] = cnt;
}
void get_tree(int now)
{
	size[now] = 1;
	for(int i = head[now];i;i = e[i].nxt)
	{
		int to = e[i].to;
		if(dep[to])	continue;
		a[to] = e[i].dis;
		dep[to] = dep[now] + 1;
		fa[to] = now;
		get_tree(to);
		size[now] += size[to];
		if(size[to] > size[hs[now]])	hs[now] = to;
	}
}
void dfs(int now,int topfa)
{
	dfn[now] = ++cnt;
	id[cnt] = now;
	top[now] = topfa;
	if(hs[now])	dfs(hs[now],topfa);
	for(int i = head[now];i;i = e[i].nxt)
	{
		int to = e[i].to;
		if(to == fa[now] || to == hs[now])	continue;
		dfs(to,to);
	}
}
void build(int p,int l,int r)
{
	if(l == r)
	{
		maxn[p] = a[id[l]];
		return ;
	}
	int mid = (l + r) >> 1;
	build(ls(p),l,mid);
	build(rs(p),mid+1,r);
	maxn[p] = max(maxn[ls(p)],maxn[rs(p)]);
}
void push_down(int p,int l,int r)
{
	if(lazy[p] >= 0)
	{
		tag[ls(p)] = tag[rs(p)] = 0;
		maxn[ls(p)] = maxn[rs(p)] = lazy[ls(p)] = lazy[rs(p)] = lazy[p];
		lazy[p] = -1;
	}
	if(tag[p])
	{
		tag[ls(p)] += tag[p];
		tag[rs(p)] += tag[p];
		maxn[ls(p)] += tag[p];
		maxn[rs(p)] += tag[p];
		tag[p] = 0;
	}
}
int query_max(int p,int l,int r,int x,int y)
{
	if(x <= l && r <= y)	return maxn[p];
	int mid = (l + r) >> 1 , res = 0;
	push_down(p,l,r);
	if(x <= mid)	res = max(res,query_max(ls(p),l,mid,x,y));
	if(y > mid)		res = max(res,query_max(rs(p),mid+1,r,x,y));
	return res;
}
int sec_max(int x,int y)
{
	int res = 0;
	while(top[x] != top[y])
	{
		if(dep[top[x]] < dep[top[y]])	swap(x,y);
		res = max(res , query_max(1,1,n,dfn[top[x]],dfn[x]));
		x = fa[top[x]];
	}
	if(dep[x] < dep[y])	swap(x,y);
	if(dfn[y] < dfn[x])	res = max(res,query_max(1,1,n,dfn[y]+1,dfn[x]));
	return res;
}
void chenge_add(int p,int l,int r,int x,int y,int k)
{
	if(x <= l && r <= y)
	{
		tag[p] += k;
		maxn[p] += k;
		return ;
	}
	int mid = (l + r) >> 1;
	push_down(p,l,r);
	if(x <= mid)	chenge_add(ls(p),l,mid,x,y,k);
	if(y > mid)		chenge_add(rs(p),mid+1,r,x,y,k);
	maxn[p] = max(maxn[ls(p)],maxn[rs(p)]);
}
void sec_add(int x,int y,int z)
{
	while(top[x] != top[y])
	{
		if(dep[top[x]] < dep[top[y]])	swap(x,y);
		chenge_add(1,1,n,dfn[top[x]],dfn[x],z);
		x = fa[top[x]];
	}
	if(dep[x] < dep[y])	swap(x,y);
	if(dfn[y] < dfn[x])	chenge_add(1,1,n,dfn[y]+1,dfn[x],z);
}
void chenge_cover(int p,int l,int r,int x,int y,int k)
{
	if(x <= l && r <= y)	
	{
		maxn[p] = k;
		tag[p] = 0;
		lazy[p] = k;
		return ;
	}
	int mid = (l + r) >> 1;
	push_down(p,l,r);
	if(x <= mid)	chenge_cover(ls(p),l,mid,x,y,k);
	if(y > mid)		chenge_cover(rs(p),mid+1,r,x,y,k);
	maxn[p] = max(maxn[ls(p)],maxn[rs(p)]);
}
void sec_cover(int x,int y,int z)
{
	while(top[x] != top[y])
	{
		if(dep[top[x]] < dep[top[y]])	swap(x,y);
		chenge_cover(1,1,n,dfn[top[x]],dfn[x],z);
		x = fa[top[x]];
	}
	if(dep[x] < dep[y])	swap(x,y);
	if(dfn[y] < dfn[x])	chenge_cover(1,1,n,dfn[y]+1,dfn[x],z);
}
void chenge_(int p,int l,int r,int x,int k)
{
	if(l == r)	
	{
		maxn[p] = k;
		tag[p] = 0;
		lazy[p] = k;
		return ;
	}
	int mid = (l + r) >> 1;
	push_down(p,l,r);
	if(x <= mid)	chenge_(ls(p),l,mid,x,k);
	else	chenge_(rs(p),mid+1,r,x,k);
	maxn[p] = max(maxn[ls(p)],maxn[rs(p)]);
}
int main()
{
	memset(lazy,-1,sizeof lazy);
	scanf("%d",&n);
	for(int i = 1;i < n;i ++)
	{
		scanf("%d%d%d",&u[i],&v[i],&w[i]);
		add(u[i],v[i],w[i]); add(v[i],u[i],w[i]);
	}
	cnt = 0; dep[1] = 1;
	get_tree(1);
	dfs(1,1);
	build(1,1,n);
	for(int i = 1;i < n;i ++)
	{
		if(fa[u[i]] == v[i])	son[i] = u[i];
		else	son[i] = v[i];
	}
	while(1)
	{
		int x , y , z;
		scanf("%s",s);
		if(s[0] == 'S')	break;
		if(s[0] == 'M')	
		{
			scanf("%d%d",&x,&y);
			printf("%d\n",sec_max(x,y));
		}
		else	if(s[0] == 'A')
		{
			scanf("%d%d%d",&x,&y,&z);
			sec_add(x,y,z);
		}
		else	if(s[1] == 'o')
		{
			scanf("%d%d%d",&x,&y,&z);
			sec_cover(x,y,z);
		}
		else	
		{
			scanf("%d%d",&x,&y);
			chenge_(1,1,n,dfn[son[x]],y);
		}
	}
	return 0;
}
```


---

## 作者：MloVtry (赞：5)

树剖维护边权裸题。

线段树中维护区间覆盖、区间修改以及区间最大值即可。

代码
```cpp
#include<bits/stdc++.h>
#define N 100005
#define M N*2
using namespace std;
int head[N],to[M],Next[M],len[M],e,n;
void buid(int u,int v,int l)
{
	Next[++e]=head[u];head[u]=e;to[e]=v;len[e]=l;
}
int eid[N],val[N];
int siz[N],dep[N],wson[N],fa[N];
void dfs(int now)
{
	dep[now]=dep[fa[now]]+1;
	siz[now]=1;
	for(int i=head[now];i;i=Next[i])
	{
		int j=to[i];if(j==fa[now]) continue;
		fa[j]=now;eid[(i+1)/2]=j;val[j]=len[i];
		dfs(j);
		siz[now]+=siz[j];
		if(siz[j]>siz[wson[now]]) wson[now]=j;
	}
}
int id[N],who[N],knt,top[N];
void dfs(int now,int fl)
{
	top[now]=fl;
	id[now]=++knt;who[knt]=now;
	if(!wson[now]) return;
	dfs(wson[now],fl);
	for(int i=head[now];i;i=Next[i])
	{
		int j=to[i];if(j==fa[now]||j==wson[now]) continue;
		dfs(j,j);
	}
}
struct node
{
	int big;
	int co,la;
	void clear()
	{
		co=-1;la=0;
	}
}tre[N*4];
void push(int x,int y)
{
	if(tre[x].co!=-1) tre[y].la=0,tre[y].co=tre[y].big=tre[x].co;
	if(tre[x].la) tre[y].la+=tre[x].la,tre[y].big+=tre[x].la;
}
void down(int now,int lson,int rson)
{
	push(now,lson);
	push(now,rson);tre[now].clear();
}
void update(int now,int lson,int rson)
{
	tre[now].big=max(tre[lson].big,tre[rson].big);
}
void change(int u,int v,int l,int r,int now)
{
	if(u>v) return;
	if(u<=l&&v>=r) return push(0,now);
	int mid=(l+r)>>1,lson=now<<1,rson=lson|1;
	down(now,lson,rson);
	if(v<=mid) change(u,v,l,mid,lson);
	else if(u>mid) change(u,v,mid+1,r,rson);
	else change(u,mid,l,mid,lson),change(mid+1,v,mid+1,r,rson);
	update(now,lson,rson);
}
int ask(int u,int v,int l,int r,int now)
{
	if(u>v) return -(1<<30);
	if(u<=l&&v>=r) 	return tre[now].big;
	int mid=(l+r)>>1,lson=now<<1,rson=lson|1;
	down(now,lson,rson);
	if(v<=mid) return ask(u,v,l,mid,lson);
	else if(u>mid) return ask(u,v,mid+1,r,rson);
	else return max(ask(u,mid,l,mid,lson),ask(mid+1,v,mid+1,r,rson));
}
void buid_t(int l,int r,int now)
{
	if(l==r)
	{
		tre[now].big=val[who[l]];tre[now].clear();
		return;
	}
	int mid=(l+r)>>1,lson=now<<1,rson=lson|1;
	buid_t(l,mid,lson);mid++;buid_t(mid,r,rson);
	update(now,lson,rson);tre[now].clear();
}
void Add()
{
	int u,v,w;scanf("%d%d%d",&u,&v,&w);
	tre[0].clear();tre[0].la=w;
	int tu=top[u],tv=top[v];
	while(tu!=tv)
	{
		if(dep[tu]<dep[tv]) swap(tu,tv),swap(u,v);
		change(id[tu],id[u],1,n,1);
		u=fa[tu],tu=top[u];
	}
	if(dep[u]<dep[v]) swap(u,v);
	change(id[v]+1,id[u],1,n,1);
}
void Max()
{
	int u,v;scanf("%d%d",&u,&v);
	int ans=-(1<<30),tu=top[u],tv=top[v];
	while(tu!=tv)
	{
		if(dep[tu]<dep[tv]) swap(tu,tv),swap(u,v);
		ans=max(ans,ask(id[tu],id[u],1,n,1));
		u=fa[tu],tu=top[u];
	}
	if(dep[u]<dep[v]) swap(u,v);
	ans=max(ans,ask(id[v]+1,id[u],1,n,1));
	printf("%d\n",ans);
}
void Change()
{
	int k,w;scanf("%d%d",&k,&w);
	tre[0].clear();tre[0].co=w;
	change(id[eid[k]],id[eid[k]],1,n,1);
}
void Cover()
{
	int u,v,w;scanf("%d%d%d",&u,&v,&w);
	tre[0].clear();tre[0].co=w;
	int tu=top[u],tv=top[v];
	while(tu!=tv)
	{
		if(dep[tu]<dep[tv]) swap(tu,tv),swap(u,v);
		change(id[tu],id[u],1,n,1);
		u=fa[tu],tu=top[u];
	}
	if(dep[u]<dep[v]) swap(u,v);
	change(id[v]+1,id[u],1,n,1);
}
char fl[10];
int main()
{
	scanf("%d",&n);
	for(int i=1;i<n;++i)
	{
		int u,v,l;scanf("%d%d%d",&u,&v,&l);
		buid(u,v,l);buid(v,u,l);
	}
	dfs(1);dfs(1,1);
	buid_t(1,n,1);	
	while("MloVtry is Handsome!")
	{
		scanf("%s",fl);
		if(fl[0]=='S') return 0;
		if(fl[0]=='A') Add();
		else if(fl[0]=='M') Max();
		else if(fl[1]=='h') Change();
		else Cover();
	}
}
```

---

## 作者：Priori_Incantatem (赞：3)

又是一道维护边权的题

对于每一个节点，我们把他的点权设为他跟他父亲之间的边权，这样就轻松地把边权转化为了点权  
但是，这题的重点就在 同时维护区间加和区间修改

对于一个区间 $k$，我们设 $maxv[k]$ 为区间最大值，$add[k],c[k]$ 分别为区间加和区间修改的懒标记  
跟[P3373 【模板】线段树 2](https://www.luogu.com.cn/problem/P3373)很像的是，我们需要维护两个优先级不同的懒标记。  
在区间修改时，让 $maxv[k]=c[k]=v$ （v为要修改的值），并且覆盖掉之前打过的 $add[k]$（赋值为 $0$）  
区间加时，就直接更新 $maxv[k],add[k]$ 就好了

在下放标记时，先放 $c[k]$，再放 $add[k]$。下放完后记得归零

代码

```cpp
#include<cstdio>
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
const int Maxn=200000+10,Maxm=800000+10;
struct edge{
	int v,len;
	edge(int x,int y)
	{
		v=x,len=y;
	}
};
struct Edge{
	int u,v;
}g[Maxn];
int maxv[Maxn],add[Maxn],c[Maxn];
int top[Maxn],s[Maxn],id[Maxn];
int f[Maxn],son[Maxn],d[Maxn];
int a[Maxn],w[Maxn];
int n,idcnt;
vector <edge> e[Maxn];
inline int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0' && ch<='9')s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
	return s*w;
}
inline void push_up(int k)
{
	maxv[k]=max(maxv[k<<1],maxv[k<<1|1]);
}
inline void upd_add(int k,int v)
{
	add[k]+=v;
	maxv[k]+=v;
}
inline void upd_change(int k,int v)
{
	add[k]=0,maxv[k]=v;
	c[k]=v;
}
inline void push_down(int k)
{
	if(c[k])
	{
		upd_change(k<<1,c[k]);
		upd_change(k<<1|1,c[k]);
		c[k]=0;
	}
	if(add[k])
	{
		upd_add(k<<1,add[k]);
		upd_add(k<<1|1,add[k]);
		add[k]=0;
	}
}
void modify_add(int k,int l,int r,int x,int y,int v)
{
	if(x<=l && r<=y)return upd_add(k,v);
	push_down(k);
	int mid=(l+r)>>1;
	if(x<=mid)modify_add(k<<1,l,mid,x,y,v);
	if(mid<y)modify_add(k<<1|1,mid+1,r,x,y,v);
	push_up(k);
}
void modify_change(int k,int l,int r,int x,int y,int v)
{
	if(x<=l && r<=y)return upd_change(k,v);
	push_down(k);
	int mid=(l+r)>>1;
	if(x<=mid)modify_change(k<<1,l,mid,x,y,v);
	if(mid<y)modify_change(k<<1|1,mid+1,r,x,y,v);
	push_up(k);
}
int query(int k,int l,int r,int x,int y)
{
	if(x<=l && r<=y)return maxv[k];
	push_down(k);
	int mid=(l+r)>>1,ret=0;
	if(x<=mid)ret=max(ret,query(k<<1,l,mid,x,y));
	if(mid<y)ret=max(ret,query(k<<1|1,mid+1,r,x,y));
	return ret;
}
void dfs1(int x,int fa,int len)
{
	s[x]=1,f[x]=fa;
	a[x]=len,d[x]=d[fa]+1;
	for(int i=0;i<e[x].size();++i)
	{
		int y=e[x][i].v;
		if(y==fa)continue;
		dfs1(y,x,e[x][i].len);
		s[x]+=s[y];
		if(s[y]>s[son[x]])son[x]=y;
	}
}
void dfs2(int x,int topp)
{
	top[x]=topp,id[x]=++idcnt;
	w[id[x]]=a[x];
	if(!son[x])return;
	dfs2(son[x],topp);
	for(int i=0;i<e[x].size();++i)
	{
		int y=e[x][i].v;
		if(y==f[x] || y==son[x])continue;
		dfs2(y,y);
	}
}
void build(int k,int l,int r)
{
	if(l==r)
	{
		maxv[k]=w[l];
		return;
	}
	int mid=(l+r)>>1;
	build(k<<1,l,mid);
	build(k<<1|1,mid+1,r);
	push_up(k);
}
void seq_change(int x,int y,int v)
{
	while(top[x]!=top[y])
	{
		if(d[top[x]]<d[top[y]])swap(x,y);
		modify_change(1,1,n,id[top[x]],id[x],v);
		x=f[top[x]];
	}
	if(d[x]>d[y])swap(x,y);
	if(x==y)return;
	modify_change(1,1,n,id[x]+1,id[y],v);
}
void seq_add(int x,int y,int v)
{
	while(top[x]!=top[y])
	{
		if(d[top[x]]<d[top[y]])swap(x,y);
		modify_add(1,1,n,id[top[x]],id[x],v);
		x=f[top[x]];
	}
	if(d[x]>d[y])swap(x,y);
	if(x==y)return;
	modify_add(1,1,n,id[x]+1,id[y],v);
}
int query_seq(int x,int y)
{
	int ret=0;
	while(top[x]!=top[y])
	{
		if(d[top[x]]<d[top[y]])swap(x,y);
		ret=max(ret,query(1,1,n,id[top[x]],id[x]));
		x=f[top[x]];
	}
	if(d[x]>d[y])swap(x,y);
	if(x==y)return ret;
	return max(ret,query(1,1,n,id[x]+1,id[y]));
}
int main()
{
//	freopen("in.txt","r",stdin);
//	freopen("out.txt","w",stdout);
	n=read();
	for(int i=1;i<n;++i)
	{
		int x=read(),y=read(),c=read();
		g[i].u=x,g[i].v=y;
		e[x].push_back(edge(y,c));
		e[y].push_back(edge(x,c));
	}
	
	dfs1(1,0,0);
	dfs2(1,1);
	build(1,1,n);
	while(1)
	{
		char opt[20];
		scanf("%s",opt);
		if(opt[0]=='S')break;
		if(opt[0]=='C' && opt[1]=='h')
		{
			int i=read(),v=read();
			seq_change(g[i].u,g[i].v,v);
		}
		if(opt[0]=='C' && opt[1]=='o')
		{
			int x=read(),y=read(),c=read();
			seq_change(x,y,c);
		}
		if(opt[0]=='A')
		{
			int x=read(),y=read(),c=read();
			seq_add(x,y,c);
		}
		if(opt[0]=='M')
		{
			int x=read(),y=read();
			printf("%d\n",query_seq(x,y));
		}
	}
	
	return 0;
}
```

---

## 作者：Genius_Z (赞：2)

这题本蒟蒻写树剖调了40+分钟，然后愉快的爆零了。

然后扔掉怒写一发$LCT$竟然$1A$了？？？

$LCT$吼啊，好写又好调，还短。

注意几个边界条件，比如初始化时所有节点的值和最大值都要初始化为$-inf$

然后边拆点，边权转点权，注意修改标记可以覆盖掉加法标记。

然后这题就没了

超短代码（就100行）：

```cpp
#include <map>
#include <set>
#include <cmath>
#include <ctime>
#include <queue>
#include <bitset>
#include <cstdio>
#include <vector>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
#define inl inline
#define re register int
#define ll long long
#define fa(x) t[x].fa
#define ls(x) t[x].child[0]
#define rs(x) t[x].child[1]
#define lowbit(x) ((x) & (-x))
const int inf = 0x7fffffff;
using namespace std;
template < class Read >
inl Read read(void) {
	Read x = 0;
	register bool w = 0;
	register char c = getchar();
	while (c > '9' || c < '0') {
		if (c == '-') w = 1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = (x << 3) + (x << 1) + (c ^ 48);
		c = getchar();
	}
	return w ? -x : x;
}
#pragma endregion
struct node {
	int fa, child[2], w, ma, add, modify;//ma 最大值 add 加法标记 modify 修改标记
	bool filp;
	node() :w(-inf), ma(-inf) {}//初始化
}t[1000001];
int n;
inl void maintain(int x) { t[x].ma = max(max(t[ls(x)].ma, t[rs(x)].ma), t[x].w); }
inl bool poi(int x) { return rs(fa(x)) == x; }
inl bool nroot(int x) { return ls(fa(x)) == x || rs(fa(x)) == x; }
inl void rotate(int x) {
	re f = fa(x), gf = fa(f), fs = poi(x), gfs = poi(f), s = t[x].child[fs ^ 1];
	if (nroot(f))t[gf].child[gfs] = x;
	t[f].child[fs] = s, t[x].child[fs ^ 1] = f;
	if (s)fa(s) = f;
	fa(f) = x, fa(x) = gf;
	maintain(f);
}
inl void change(int x, int w) { if (x > n)t[x].w = w; t[x].ma = w, t[x].add = 0, t[x].modify = w; }
inl void sum(int x, int w) { if (x > n)t[x].w += w; t[x].ma += w, t[x].add += w; }
inl void reverse(int x) { swap(ls(x), rs(x)), t[x].filp ^= 1; }
inl void pushdown(int x) {
	if (t[x].modify) {
		if (ls(x))change(ls(x), t[x].modify);
		if (rs(x))change(rs(x), t[x].modify);
		t[x].modify = 0;
	}
	if (t[x].add) {
		if (ls(x))sum(ls(x), t[x].add);
		if (rs(x))sum(rs(x), t[x].add);
		t[x].add = 0;
	}
	if (t[x].filp) {
		if (ls(x))reverse(ls(x));
		if (rs(x))reverse(rs(x));
		t[x].filp = 0;
	}
}
inl void push(int x) { if (nroot(x))push(fa(x)); pushdown(x); }
inl void splay(int x) { push(x); while (nroot(x)) { if (nroot(fa(x)))poi(x) == poi(fa(x)) ? rotate(fa(x)) : rotate(x); rotate(x); }maintain(x); }
inl void access(int x) { for (re i = 0; x; x = fa(i = x)) splay(x), rs(x) = i, maintain(x); }
inl void makeroot(int x) { access(x), splay(x), reverse(x); }
inl void split(int x, int y) { makeroot(y), access(x), splay(x); }
inl void link(int x, int y) { split(x, y); fa(y) = x; }
inl short spread() {
	register char c = getchar();
	while (c != 'C'&&c != 'A'&&c != 'M'&&c != 'S')c = getchar();
	if (c == 'S')exit(0);
	if (c != 'C')return c == 'A';
	else c = getchar();
	return c == 'o' ? 2 : 3;
}
signed main() {
	n = read<int>();
	re x, y, op;
	for (re i = 1; i < n; i++) { x = read<int>(), y = read<int>(), t[i + n].w = read<int>(), link(x, i + n), link(y, i + n); }
	while (1) {
		op = spread(), x = read<int>(), y = read<int>();
		if (!op) split(x, y), printf("%d\n", t[x].ma);
		else if (op == 1) split(x, y), sum(x, read<int>());
		else if (op == 2) split(x, y), change(x, read<int>());
		else access(x + n), splay(x + n), t[x + n].w = y;
	}
}
```



---

## 作者：斯德哥尔摩 (赞：2)

树链剖分+线段树没的说。。。

然而调了我一节课+20min。。。

线段树我用了宏定义，这是一个好东西啊！为什么没有多少人用？？？

注意：

1. pushdown 时先下传区间修改标记，并把左右儿子的区间加标记改为0，在下传区间加标记。

2. 线段树区间修改时记得把区间加标记清0（坑点）！

3. 边权转成点权。将吗，每条边的权值放到深度较大的节点上。

4. 最后跳链跳完，左区间要加1！

附代码：
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#define LSON rt<<1//以下为宏定义
#define RSON rt<<1|1
#define DATA(x) b[x].data
#define SIGN1(x) b[x].c
#define SIGN2(x) b[x].d
#define LSIDE(x) b[x].l
#define RSIDE(x) b[x].r
#define MAXN 100010
using namespace std;
int n,c=1,d=1;
int head[MAXN],deep[MAXN],size[MAXN],son[MAXN],fa[MAXN],top[MAXN],id[MAXN];
struct node1{/前向星
    int next,to,w;
}a[MAXN<<1];
struct node2{//线段树
    int data,c,d,l,r;
}b[MAXN<<2];
struct node3{//边
    int u,v,w;
}g[MAXN];
inline int read(){//读优
    int date=0,w=1;char c=0;
    while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
    while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}
    return date*w;
}
inline int max(const int &x,const int &y){return x>y?x:y;}//STL不靠谱，于是手写
inline void add(int u,int v,int w){//加边
    a[c].to=v,a[c].w=w;a[c].next=head[u];head[u]=c++;
    a[c].to=u;a[c].w=w;a[c].next=head[v];head[v]=c++;
}
void dfs1(int rt){//树剖两个 dfs
    son[rt]=0;size[rt]=1;
    for(int i=head[rt];i;i=a[i].next){
        int will=a[i].to;
        if(!deep[will]){
            deep[will]=deep[rt]+1;
            fa[will]=rt;
            dfs1(will);
            size[rt]+=size[will];
            if(size[son[rt]]<size[will])son[rt]=will;
        }
    }
}
void dfs2(int rt,int f){
    id[rt]=d++;top[rt]=f;
    if(son[rt])dfs2(son[rt],f);
    for(int i=head[rt];i;i=a[i].next){
        int will=a[i].to;
        if(will!=fa[rt]&&will!=son[rt])
        dfs2(will,will);
    }
}
inline void pushup(int rt){//上传
    DATA(rt)=max(DATA(LSON),DATA(RSON));
}
inline void pushdown(int rt){//标记下传
    if(LSIDE(rt)==RSIDE(rt))return;
    if(SIGN1(rt)!=-1){
    	SIGN1(LSON)=DATA(LSON)=SIGN1(rt);
    	SIGN1(RSON)=DATA(RSON)=SIGN1(rt);
    	SIGN1(rt)=-1;
		SIGN2(LSON)=SIGN2(RSON)=0;//记得赋0！
    }
    if(SIGN2(rt)){
    	SIGN2(LSON)+=SIGN2(rt);DATA(LSON)+=SIGN2(rt);
    	SIGN2(RSON)+=SIGN2(rt);DATA(RSON)+=SIGN2(rt);
    	SIGN2(rt)=0;
    }
}
void buildtree(int l,int r,int rt){//建树
    int mid;
    LSIDE(rt)=l;
    RSIDE(rt)=r;
    SIGN1(rt)=-1;//初始值为-1
    if(l==r){
        DATA(rt)=0;
        return;
    }
    mid=l+r>>1;
    buildtree(l,mid,LSON);
    buildtree(mid+1,r,RSON);
    pushup(rt);
}
void update_one(int l,int r,int c,int rt){//区间修改
    int mid;
    if(l<=LSIDE(rt)&&RSIDE(rt)<=r){
        SIGN1(rt)=DATA(rt)=c;
        SIGN2(rt)=0;//区间加标记清0
        return;
    }
    pushdown(rt);
    mid=LSIDE(rt)+RSIDE(rt)>>1;
    if(l<=mid)update_one(l,r,c,LSON);
    if(mid<r)update_one(l,r,c,RSON);
    pushup(rt);
}
void update_two(int l,int r,int c,int rt){//区间加
    int mid;
    if(l<=LSIDE(rt)&&RSIDE(rt)<=r){
        SIGN2(rt)+=c;DATA(rt)+=c;//直接修改标记
        return;
    }
    pushdown(rt);
    mid=LSIDE(rt)+RSIDE(rt)>>1;
    if(l<=mid)update_two(l,r,c,LSON);
    if(mid<r)update_two(l,r,c,RSON);
    pushup(rt);
}
int query(int l,int r,int rt){//求最大值
	int mid,ans=0;
	if(l<=LSIDE(rt)&&RSIDE(rt)<=r)return DATA(rt);
	pushdown(rt);
	mid=LSIDE(rt)+RSIDE(rt)>>1;
	if(l<=mid)ans=max(ans,query(l,r,LSON));
	if(mid<r)ans=max(ans,query(l,r,RSON));
	return ans;
}
void work1(int x,int y,int k){//树上区间修改
	while(top[x]!=top[y]){
		if(deep[top[x]]<deep[top[y]])swap(x,y);
		update_one(id[top[x]],id[x],k,1);
		x=fa[top[x]];
	}
	if(deep[x]>deep[y])swap(x,y);
	if(x!=y)update_one(id[x]+1,id[y],k,1);//左区间+1！
	return;
}
void work2(int x,int y,int k){//树上区间加
	while(top[x]!=top[y]){
		if(deep[top[x]]<deep[top[y]])swap(x,y);
		update_two(id[top[x]],id[x],k,1);
		x=fa[top[x]];
	}
	if(deep[x]>deep[y])swap(x,y);
	if(x!=y)update_two(id[x]+1,id[y],k,1);
	return;
}
void work3(int x,int y){//树上最值
	int s=0;
	while(top[x]!=top[y]){
		if(deep[top[x]]<deep[top[y]])swap(x,y);
		s=max(s,query(id[top[x]],id[x],1));
		x=fa[top[x]];
	}
	if(deep[x]>deep[y])swap(x,y);
	if(x!=y)s=max(s,query(id[x]+1,id[y],1));
	printf("%d\n",s);
	return;
}
void work(){
	char ch[10];
	int x,y,k;
	while(1){//直接循环
		scanf("%s",ch);
		if(ch[0]=='S')break;
		x=read();y=read();
		switch(ch[0]){//分类
			case 'C':{
				if(ch[1]=='h'){
					g[x].w=y;
					update_one(id[g[x].v],id[g[x].v],y,1);
				}
				if(ch[1]=='o'){
					k=read();
					work1(x,y,k);
				}
				break;
			}
			case 'A':{
				k=read();
				work2(x,y,k);
				break;
			}
			case 'M':{
				work3(x,y);
				break;
			}
		}
	}
}
void init(){//读入+预处理
    n=read();
    for(int i=1;i<n;i++){
        g[i].u=read();g[i].v=read();g[i].w=read();
        add(g[i].u,g[i].v,g[i].w);
    }
    deep[1]=1;
    dfs1(1);
    dfs2(1,1);
    buildtree(1,n,1);
    for(int i=1;i<n;i++){//边权转点权
        if(deep[g[i].u]>deep[g[i].v])swap(g[i].u,g[i].v);
        update_one(id[g[i].v],id[g[i].v],g[i].w,1);
    }
}
int main(){//主函数
    init();
    work();
    return 0;
}

```

---

## 作者：tcswuzb (赞：2)

## [传](https://www.luogu.org/problemnew/show/P4315)[送门](https://www.luogu.org/blog/LovToLZX/)

这是一道树剖的裸题

但是要注意下这几个细节:

![有那个李](https://i.loli.net/2018/10/03/5bb4a07129536.png)

1.由于是对边的修改以及查询操作 所以就把边下放到点上

![牛逼](https://i.loli.net/2018/10/03/5bb4a10af0223.png)

2.我们可以十分明显地发现 树上路径是经过LCA(u,v)的

但是 在查询边的范畴里 这是十分不合法的

所以

修改时 将LCA原值保留 然后再直接修改 然后再改回

查询时 将LCA原值保留再赋为极小值 然后直接查询 

然后再改回

3.定义区间覆盖的优先级 高于 区间加法

4.由于是建的双向边 所以

对于dep[to[x × 2 - 1]] 以及 dep[to[x × 2]]

较大的对应的点就是我们要的边权下放的点

剩下的就是树剖板子的事了

# CODE:

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<string>
#include<cstdlib>
#include<algorithm>
#define IL inline
#define R register 
#define N 200008
#define eps 1e-8
#define inf 0x7fffff
#define D double
using namespace std;
template<typename T>IL void read(T &A)
{
    T x=0,f=1;char ch=getchar();
    while(!isdigit(ch))
    {
        if(ch=='-') f=0;ch=getchar();
    }
    while(isdigit(ch))
    {
        x=(x<<1)+(x<<3)+ch-'0';ch=getchar();
    }
    A=f ? x:-x;
}
int n,tot,cnt;
int fa[N][30],siz[N],dep[N],son[N],top[N],id[N],num[N],wt[N];
struct Node{
    int to,nex,w;
}e[N];
int head[N];
struct Tree{
    int val,tag1,tag2;
}tre[N<<1];
IL void add(int ai,int bi,int ci)
{
    e[++tot].nex=head[ai];head[ai]=tot;
    e[tot].to=bi;e[tot].w=ci;
}
IL void dfs1(int now,int fat,int det)
{
//    printf("now is %d and father is %d and dept is %d\n",now,fat,det);
    dep[now]=det;fa[now][0]=fat;
    siz[now]=1;int maxson=-1;
    for(R int j=1;j<=25;++j)
     fa[now][j]=fa[fa[now][j-1]][j-1];
    for(R int i=head[now];i;i=e[i].nex)
    {
        int v=e[i].to;
        if(v==fat) continue;
        num[v]=e[i].w;
        dfs1(v,now,det+1);
        siz[now]+=siz[v];
        if(siz[v]>maxson) {son[now]=v;maxson=siz[v];}
    } 
}
IL void dfs2(int now,int topf)
{
//    printf("now is %d and top is %d\n",now,topf);
    top[now]=topf;id[now]=++cnt;wt[cnt]=now;
    if(!son[now]) return;
    dfs2(son[now],topf);
    for(R int i=head[now];i;i=e[i].nex)
    {
        int v=e[i].to;
        if(v==fa[now][0]||v==son[now]) continue;
        dfs2(v,v);
    }
}
/*--------------------------------*/
IL void down(int si,int le,int ri)
{
//由于直接覆盖之后 就是一个定值
//所以区间覆盖的tag可以消灭区间加法的tag
    if(tre[si].tag1)
    {
        tre[si<<1].val=tre[si].tag1;
        tre[si<<1|1].val=tre[si].tag1;
        tre[si<<1].tag1=tre[si].tag1;
        tre[si<<1|1].tag1=tre[si].tag1;
        tre[si].tag1=0;tre[si<<1|1].tag2=tre[si<<1].tag2=0;
    }
    tre[si<<1].val+=tre[si].tag2;
    tre[si<<1|1].val+=tre[si].tag2;
    tre[si<<1].tag2+=tre[si].tag2;
    tre[si<<1|1].tag2+=tre[si].tag2;
    tre[si].tag2=0;
}
IL void build(int si,int le,int ri)
{
    if(le==ri) {tre[si].val=num[wt[le]];return;}
    int mid=(le+ri)>>1;
    build(si<<1,le,mid);
    build(si<<1|1,mid+1,ri);
    tre[si].val=max(tre[si<<1].val,tre[si<<1|1].val);
}
IL void update(int si,int lenow,int rinow,int le,int ri,int ak)
{//区间加法
    if(le<=lenow&&rinow<=ri)
    {
        tre[si].val+=ak;
        tre[si].tag2+=ak;
        return;
    }
    down(si,lenow,rinow);
    int mid=(lenow+rinow)>>1;
    if(le<=mid) update(si<<1,lenow,mid,le,ri,ak);
    if(mid<ri) update(si<<1|1,mid+1,rinow,le,ri,ak);
    tre[si].val=max(tre[si<<1].val,tre[si<<1|1].val);
}
IL void cover(int si,int lenow,int rinow,int le,int ri,int ak)
{//区间覆盖
    if(le<=lenow&&rinow<=ri)
    {
        tre[si].val=ak;
        tre[si].tag1=ak;tre[si].tag2=0;return;
    }
    down(si,lenow,rinow);
    int mid=(lenow+rinow)>>1;
    if(le<=mid) cover(si<<1,lenow,mid,le,ri,ak);
    if(mid<ri) cover(si<<1|1,mid+1,rinow,le,ri,ak);
    tre[si].val=max(tre[si<<1].val,tre[si<<1|1].val);
} 
IL int qury(int si,int lenow,int rinow,int le,int ri)
{
//    printf("quryint djshf  le is %d but ri is %d\n",lenow,rinow);
    if(le<=lenow&&rinow<=ri)
    {
        return tre[si].val;
    }
    down(si,lenow,rinow);
    int ans=-1;
    int mid=(lenow+rinow)>>1;
    if(le<=mid) ans=max(ans,qury(si<<1,lenow,mid,le,ri));
    if(mid<ri) ans=max(ans,qury(si<<1|1,mid+1,rinow,le,ri));
    return ans;
}
/*--------------------------------*/
IL int LCA(int nowx,int nowy)
{
//其实树剖就可以求LCA 但是本蒟蒻只会倍增
    if(dep[nowy]>dep[nowx]) swap(nowx,nowy);
    for(R int j=25;j>=0;--j)
     if(dep[fa[nowx][j]]>=dep[nowy]) nowx=fa[nowx][j];
    if(nowx==nowy) return nowx;
    for(R int j=25;j>=0;--j)
     if(fa[nowx][j]!=fa[nowy][j])
      nowx=fa[nowx][j],nowy=fa[nowy][j];
    return fa[nowx][0];      
}
IL int QuryRange(int nowx,int nowy)
{
    int ans=-1;
    while(top[nowx]!=top[nowy])
    {
        if(dep[top[nowx]]<dep[top[nowy]]) swap(nowx,nowy);
        ans=max(ans,qury(1,1,n,id[top[nowx]],id[nowx]));
        nowx=fa[top[nowx]][0];
    }
    if(dep[nowx]>dep[nowy]) swap(nowx,nowy);
    ans=max(ans,qury(1,1,n,id[nowx],id[nowy]));
    return ans;
}
IL void CoRange(int nowx,int nowy,int ak)
{
    while(top[nowx]!=top[nowy])
    {
        if(dep[top[nowx]]<dep[top[nowy]]) swap(nowx,nowy);
        cover(1,1,n,id[top[nowx]],id[nowx],ak);
        nowx=fa[top[nowx]][0];
    }
    if(dep[nowx]>dep[nowy]) swap(nowx,nowy);
    cover(1,1,n,id[nowx],id[nowy],ak);
    return;
}
IL void UpdRange(int nowx,int nowy,int ak)
{
    while(top[nowx]!=top[nowy])
    {
        if(dep[top[nowx]]<dep[top[nowy]]) swap(nowx,nowy);
        update(1,1,n,id[top[nowx]],id[nowx],ak);
        nowx=fa[top[nowx]][0];
    }
    if(dep[nowx]>dep[nowy]) swap(nowx,nowy);
    update(1,1,n,id[nowx],id[nowy],ak);
    return;
}
signed main()
{
    read(n);
    for(R int i=1;i<n;++i)
    {
        int x,y,z;read(x);read(y);read(z);
        add(x,y,z);add(y,x,z);
    }
    dfs1(1,0,1);dfs2(1,1);build(1,1,n);
    while(1)
    {
        string key;cin>>key;
        if(key[1]=='h')
        {
            int x,y,now;read(x);read(y);
            now=(dep[e[(x<<1)].to]>dep[e[(x<<1)-1].to] ? e[(x<<1)].to : e[(x<<1)-1].to);
            cover(1,1,n,id[now],id[now],y);
        }
        else if(key[1]=='a')
        {
            int x,y,tmp,akj;read(x);read(y);tmp=LCA(x,y);
            akj=qury(1,1,n,id[tmp],id[tmp]);
            cover(1,1,n,id[tmp],id[tmp],-inf);
            printf("%d\n",QuryRange(x,y));
            cover(1,1,n,id[tmp],id[tmp],akj);
        }
        else if(key[1]=='o')
        {
            int x,y,z,tmp,akj;read(x);read(y);read(z);tmp=LCA(x,y);
            akj=qury(1,1,n,id[tmp],id[tmp]);
            CoRange(x,y,z);
            cover(1,1,n,id[tmp],id[tmp],akj);
        }
        else if(key[1]=='d')
        {
            int x,y,z,tmp,akj;read(x);read(y);read(z);tmp=LCA(x,y);
            akj=qury(1,1,n,id[tmp],id[tmp]);
            UpdRange(x,y,z);
            cover(1,1,n,id[tmp],id[tmp],akj);
        }
        else break;
    }
    return 0;
}
```

# _NOIP 2018 RP++_

---

## 作者：依依 (赞：2)

解题思路：边权化点权，将边权放到深度较深的点上面   
对于操作：  
Change k w：将第k条树枝上毛毛果的个数改变为w个。  
=>直接找对应的点，线段树上单点修改  
Cover u v w：将节点u与节点v之间的树枝上毛毛果的个数都改变为w个。  
=>注意：u和v的lca是不应该被修改的  
为了方便，我们可以先修改，再把lca改回去  
Add u v w：将节点u与节点v之间的树枝上毛毛果的个数都增加w个。  
=>注意：u和v的lca是不应该被加的  
为了方便，我们可以先修改，再把lca减回去  
Max u v：询问节点u与节点v之间树枝上毛毛果个数最多有多少个。  
=>注意：u和v的lca是不应该被算进去的  
我们可以先将lca赋成极小值  
得到答案后在将原值赋回去  
值得注意的地方是线段树的标记下放 ：  
先修改操作，后加操作，保证正确性  


[代码链接（略丑）](http://www.cnblogs.com/adelalove/p/8709620.html)

---

## 作者：rainygame (赞：1)

这道题本人用了 8h13min 才过……其中线段树用时 7h+ 且没有 AC。改成分块之后只用 1h 就过了，分块实在是太好写太好调了，甚至用时还比线段树低了四分之一。

首先肯定是树剖，剖出来之后再考虑数据结构维护。要求：

- 区间设值。
- 区间加和。
- 区间查询最大值。

有很多种数据结构可以，在这里我介绍一下分块。

分块，就是把数据分成 $\sqrt n$ 个块，每个块有 $\sqrt n$ 个元素。这道题需要维护每个块的块内最大值、设值懒标记、加和懒标记。

区间设值我们可以把区间分成三个部分：最左边的一个块，最右边的一个块，中间的所有块。对于两边的块显然可以暴力修改。对于中间的所有块，我们修改其设值懒标记即可。

区间加和类似，只不过如果有设值懒标记，就修改设值懒标记，否则修改加和标记。

查询直接暴力两边的块，然后中间的就用处理出来的块内最大值就可以了。

注意整个块修改之后是可以直接求出修改后最大值的。加和的话就把最大值加上 $w$；设值就把最大值设为 $w$。

这道题就做完了，分块就是那么简单。

时间复杂度 $O(n+q\sqrt n\log n)$，加上树剖和分块的微弱常数，是可以过去的（还比线段树快不少）。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define MAXN 100001
#define MAXM 320

int n, u, v, w, cnt, len, tot;
int us[MAXN], vs[MAXN], id[MAXN], ta[MAXN], a[MAXN], bl[MAXN];
int dep[MAXN], son[MAXN], siz[MAXN], fa[MAXN], top[MAXN];
int L[MAXM], R[MAXM], maxn[MAXM], tag1[MAXM], tag2[MAXM];
string opt;

struct Edge{
	int v, w;
};
vector<Edge> e[MAXN];

void dfs1(int x, int f){
	fa[x] = f;
	dep[x] = dep[f] + 1;
	siz[x] = 1;
	for (auto i: e[x]){
		int v(i.v);
		if (v != f){
			ta[v] = i.w;
			dfs1(v, x);
			siz[x] += siz[v];
			if (siz[son[x]] < siz[v]) son[x] = v;
		}
	}
}

void dfs2(int x, int tp){
	top[x] = tp;
	id[x] = ++cnt;
	a[cnt] = ta[x];
	if (!son[x]) return;
	dfs2(son[x], tp);
	for (auto i: e[x]){
		int v(i.v);
		if (v != fa[x] && v != son[x]) dfs2(v, v);
	}
}

void init(){
	len = sqrt(n);
	tot = (n-1)/len+1;
	for (int i(1); i<=tot; ++i){
		L[i] = R[i-1] + 1;
		R[i] = i * len;
	}
	R[tot] = n;
	
	for (int i(1); i<=tot; ++i){
		tag1[i] = LLONG_MAX;
		maxn[i] = LLONG_MIN;
		for (int j(L[i]); j<=R[i]; ++j){
			maxn[i] = max(maxn[i], a[j]);
			bl[j] = i;
		}
	}
}

void push_up(int p){
	maxn[p] = LLONG_MIN;
	for (int i(L[p]); i<=R[p]; ++i) maxn[p] = max(maxn[p], a[i]);
}

void push_down(int p){
	if (tag1[p] != LLONG_MAX){
		for (int i(L[p]); i<=R[p]; ++i) a[i] = tag1[p];
		tag1[p] = LLONG_MAX;
		tag2[p] = 0;
	}
	if (tag2[p]){
		for (int i(L[p]); i<=R[p]; ++i) a[i] += tag2[p];
		tag2[p] = 0;
	}
}

void modify1(int l, int r, int k){
	if (l > r) return;
	int p(bl[l]), q(bl[r]);
	if (p == q){
		push_down(p);
		for (int i(l); i<=r; ++i) a[i] = k;
		push_up(p);
		return;
	}
	
	push_down(p);
	for (int i(l); i<=R[p]; ++i) a[i] = k;
	push_up(p);
	for (int i(p+1); i<q; ++i) tag1[i] = maxn[i] = k;
	push_down(q);
	for (int i(L[q]); i<=r; ++i) a[i] = k;
	push_up(q);
}

void modify2(int l, int r, int k){
	if (l > r) return;
	int p(bl[l]), q(bl[r]);
	if (p == q){
		push_down(p);
		for (int i(l); i<=r; ++i) a[i] += k;
		push_up(p);
		return;
	}
	
	push_down(p);
	for (int i(l); i<=R[p]; ++i) a[i] += k;
	push_up(p);
	for (int i(p+1); i<q; ++i){
		if (tag1[i] != LLONG_MAX) tag1[i] += k;
		else tag2[i] += k;
	}
	push_down(q);
	for (int i(L[q]); i<=r; ++i) a[i] += k;
	push_up(q);
}

int query1(int l, int r){
	if (l > r) return LLONG_MIN;
	int p(bl[l]), q(bl[r]), ans(LLONG_MIN);
	if (p == q){
		push_down(p);
		for (int i(l); i<=r; ++i) ans = max(ans, a[i]);
		return ans;
	}
	
	push_down(p);
	for (int i(l); i<=R[p]; ++i) ans = max(ans, a[i]);
	for (int i(p+1); i<q; ++i) ans = max(ans, maxn[i]);
	push_down(q);
	for (int i(L[q]); i<=r; ++i) ans = max(ans, a[i]);
	return ans;
}

void modify3(int x, int y, int k){
	while (top[x] != top[y]){
		if (dep[top[x]] < dep[top[y]]) swap(x, y);
		modify1(id[top[x]], id[x], k);
		x = fa[top[x]];
	}
	if (dep[x] > dep[y]) swap(x, y);
	modify1(id[x]+1, id[y], k);
}

void modify4(int x, int y, int k){
	while (top[x] != top[y]){
		if (dep[top[x]] < dep[top[y]]) swap(x, y);
		modify2(id[top[x]], id[x], k);
		x = fa[top[x]];
	}
	if (dep[x] > dep[y]) swap(x, y);
	modify2(id[x]+1, id[y], k);
}

int query2(int x, int y){
	int res(LLONG_MIN);
	while (top[x] != top[y]){
		if (dep[top[x]] < dep[top[y]]) swap(x, y);
		res = max(res, query1(id[top[x]], id[x]));
		x = fa[top[x]];
	}
	if (dep[x] > dep[y]) swap(x, y);
	return max(res, query1(id[x]+1, id[y]));
}

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    cin >> n;
    for (int i(1); i<n; ++i){
    	cin >> u >> v >> w;
    	e[u].push_back({v, w});
    	e[v].push_back({u, w});
    	us[i] = u;
    	vs[i] = v;
	}
	dfs1(1, 0);
	dfs2(1, 1);
	init();
	
	while (cin >> opt){
		if (opt == "Stop") return 0;
		cin >> u >> v;
		if (opt == "Change"){
			if (dep[us[u]] < dep[vs[u]]) modify1(id[vs[u]], id[vs[u]], v);
			else modify1(id[us[u]], id[us[u]], v);
		}else if (opt == "Cover"){
			cin >> w;
			modify3(u, v, w);
		}else if (opt == "Add"){
			cin >> w;
			modify4(u, v, w);
		}else cout << query2(u, v) << '\n';
	}

    return 0;
}

```

---

## 作者：doby (赞：1)

树上的链问题，显然可以树链剖分

每条边的边权下推到深度更深的节点上，用线段树维护点权

注意LCA的点所维护的边权不属于两点之间的路径，在修改和计算时要排除

要用两种标记，注意两种标记的优先级

区间覆盖标记下传时要把区间加的标记覆盖掉

当然也可以在一种标记打上之前先下传儿子的标记，同样可以保证正确性，但是会变得很慢

```cpp
#include<cstdio>
using namespace std;
int n,opt,x,y,z,cnt,tot,out,tt,u[100010],v[100010],w[100010],a[100010],id[100010],at[100010],h[100010],dad[100010],top[100010],dep[100010],size[100010],son[100010];
char c;
struct Edge
{
	int next,to;
}e[200010];
struct SegT
{
	int mx,l,tag;
}t[400010];
int read()
{
	out=0,c=getchar();
	while(c<48||c>57){c=getchar();}
	while(c>=48&&c<=57){out=(out<<3)+(out<<1)+(c&15),c=getchar();}
	return out;
}
void Add(int x,int y)
{
	e[++cnt].next=h[x],
	e[cnt].to=y,
	h[x]=cnt;
}
void DFS1(int x)
{
	dep[x]=dep[dad[x]]+1,size[x]=1;
	for(int i=h[x];i;i=e[i].next)
	{
		int y=e[i].to;
		if(dad[x]^y)
		{
			dad[y]=x;
			DFS1(y);
			size[x]+=size[y];
			if(size[son[x]]<size[y]){son[x]=y;}
		}
	}
}
void DFS2(int x)
{
	id[x]=++tot,at[tot]=a[x],
	top[x]=x==son[dad[x]]?top[dad[x]]:x;
	if(!son[x]){return;}
	DFS2(son[x]);
	for(int i=h[x];i;i=e[i].next)
	{
		int y=e[i].to;
		if(y^dad[x]&&y^son[x]){DFS2(y);}
	}
}
void DFS(int x)
{
	DFS1(x);
	for(int i=1;i<n;++i)
	{
		if(dep[u[i]]>dep[v[i]]){a[u[i]]=w[i];}
		else{a[v[i]]=w[i];}
	}
	DFS2(x);
}
int max(int a,int b)
{
	return a>b?a:b;
}
void Pushup(int k)
{
	t[k].mx=max(t[k<<1].mx,t[k<<1|1].mx);
}
void Pushdown(int k,int l,int r)
{
	if(l==r){return;}
	if(t[k].tag==1)
	{
		t[k<<1].tag=1,t[k<<1|1].tag=1,
		t[k<<1].l=t[k].l,t[k<<1|1].l=t[k].l,
		t[k<<1].mx=t[k].l,t[k<<1|1].mx=t[k].l,
		t[k].tag=0,t[k].l=0;
	}
	if(t[k].tag==2)
	{
		int mid=l+r>>1;
		Pushdown(k<<1,l,mid);Pushdown(k<<1|1,mid+1,r);
		t[k<<1].tag=2,t[k<<1|1].tag=2,
		t[k<<1].l=t[k].l,t[k<<1|1].l=t[k].l,
		t[k<<1].mx+=t[k].l,t[k<<1|1].mx+=t[k].l,
		t[k].tag=0,t[k].l=0;
	}
}
void Build(int k,int l,int r)
{
	if(l==r)
	{
		t[k].mx=at[l];
		return;
	}
	int mid=l+r>>1;
	Build(k<<1,l,mid);
	Build(k<<1|1,mid+1,r);
	Pushup(k);
}
void Changes(int k,int l,int r,int ll,int rr,int x)
{
	if(r<ll||rr<l){return;}
	if(ll<=l&&r<=rr)
	{
		Pushdown(k,l,r);
		t[k].mx=x,t[k].tag=1,t[k].l=x;
		return;
	}
	Pushdown(k,l,r);
	int mid=l+r>>1;
	Changes(k<<1,l,mid,ll,rr,x);
	Changes(k<<1|1,mid+1,r,ll,rr,x);
	Pushup(k);
}
void Changep(int k,int l,int r,int ll,int rr,int x)
{
	if(r<ll||rr<l){return;}
	if(ll<=l&&r<=rr)
	{
		Pushdown(k,l,r);
		t[k].mx+=x,t[k].tag=2,t[k].l=x;
		return;
	}
	Pushdown(k,l,r);
	int mid=l+r>>1;
	Changep(k<<1,l,mid,ll,rr,x);
	Changep(k<<1|1,mid+1,r,ll,rr,x);
	Pushup(k);
}
int Query(int k,int l,int r,int ll,int rr)
{
	if(r<ll||rr<l){return -19260817;}
	if(ll<=l&&r<=rr){return t[k].mx;}
	Pushdown(k,l,r);
	int mid=l+r>>1;
	return max(Query(k<<1,l,mid,ll,rr),Query(k<<1|1,mid+1,r,ll,rr));
}
void ChangesL(int x,int y,int z)
{
	while(top[x]^top[y])
	{
		if(dep[top[x]]<dep[top[y]]){x^=y,y^=x,x^=y;}
		Changes(1,1,n,id[top[x]],id[x],z);
		x=dad[top[x]];
	}
	if(dep[x]>dep[y]){x^=y,y^=x,x^=y;}
	Changes(1,1,n,id[x]+1,id[y],z);
}
void ChangepL(int x,int y,int z)
{
	while(top[x]^top[y])
	{
		if(dep[top[x]]<dep[top[y]]){x^=y,y^=x,x^=y;}
		Changep(1,1,n,id[top[x]],id[x],z);
		x=dad[top[x]];
	}
	if(dep[x]>dep[y]){x^=y,y^=x,x^=y;}
	Changep(1,1,n,id[x]+1,id[y],z);
}
int LCA(int x,int y)
{
	int ans=-19260817;
	while(top[x]^top[y])
	{
		if(dep[top[x]]<dep[top[y]]){x^=y,y^=x,x^=y;}
		ans=max(ans,Query(1,1,n,id[top[x]],id[x])),
		x=dad[top[x]];
	}
	if(dep[x]>dep[y]){x^=y,y^=x,x^=y;}
	ans=max(ans,Query(1,1,n,id[x]+1,id[y]));
	return ans;
}
int main()
{
	n=read();
	for(int i=1;i<n;++i)
	{
		u[i]=read(),v[i]=read(),w[i]=read();
		Add(u[i],v[i]);Add(v[i],u[i]);
	}
	DFS(1);
	Build(1,1,n);
	while(1)
	{
		c=getchar();
		while(1)
		{
			if(c==83){return 0;}
			if(c==77){opt=4;break;}
			if(c==65){opt=3;break;}
			if(c==111){opt=2;break;}
			if(c==104){opt=1;break;}
			c=getchar();
		}
		if(opt==1)
		{
			x=read(),y=read();
			if(dep[u[x]]>dep[v[x]]){Changes(1,1,n,id[u[x]],id[u[x]],y);}
			else{Changes(1,1,n,id[v[x]],id[v[x]],y);}
		}
		if(opt==2)
		{
			x=read(),y=read(),z=read();
			ChangesL(x,y,z);
		}
		if(opt==3)
		{
			x=read(),y=read(),z=read();
			ChangepL(x,y,z);
		}
		if(opt==4)
		{
			x=read(),y=read();
			printf("%d\n",LCA(x,y));
		}
		
	}
}
```

---

## 作者：Katsura_Hinagiku (赞：1)

最近一直在刷树剖~~线段树~~题

本题求维护的是边权，因此我们需要把边权转移到点权上，才可以套路地进行树剖，具体方法请见[P3038](https://www.luogu.org/problem/P3038)，是此类问题的裸题。（复读上一篇博客）

本题需要维护区间最大值，支持单点修改，区间修改，区间加。

区间修改和区间加需要分别开lazy数组，注意pushdown的顺序应该是先更新区间修改再更新区间价，否则区间加的修改会被覆盖掉

注意区间修改的操作会将当前区间的区间加的lazy数组变为0

此外，谈一谈我在存储边的序号时遇到的问题。

原来的代码，用stetins，mp两个数组映射，储存边的序号映射到的点

```cpp
#include<bits/stdc++.h>
using namespace std;
int head[100005],pnt[200005],nxt[200005],weight[200005],E=0;
int dep[100005],son[100005],fa[100005],sz[100005];
int top[100005],val[100005],id[100005],cnt=0;
int tree[400005],lazy[400005],lazy2[400005];
int n,steins[100005],mp[100005];
char ss[15];
void pushup(int k)
{
	tree[k]=max(tree[k<<1],tree[k<<1|1]);
}
void pushdown(int k)
{
	if(lazy2[k]!=-1)
	{
		tree[k<<1]=lazy2[k];
		tree[k<<1|1]=lazy2[k];
		lazy2[k<<1]=lazy2[k];
		lazy2[k<<1|1]=lazy2[k];
		lazy[k<<1]=0;
		lazy[k<<1|1]=0;
		lazy2[k]=-1;
	}
	tree[k<<1]+=lazy[k];
	tree[k<<1|1]+=lazy[k];
	lazy[k<<1]+=lazy[k];
	lazy[k<<1|1]+=lazy[k];
	lazy[k]=0;
}
void build(int l,int r,int k)
{
	if(l==r)
	{
		tree[k]=val[l];
		return;
	}
	int m=(l+r)>>1;
	build(l,m,k<<1);
	build(m+1,r,k<<1|1);
	pushup(k);
}
void modify(int L,int R,int l,int r,int k,int v,int opt)
{
	if(L<=l&&r<=R)
	{
		if(opt==1)
		{
			tree[k]=v;
			lazy2[k]=v;
			lazy[k]=0;
		}
		else
		{
			tree[k]+=v;
			lazy[k]+=v;
		}
		return;
	}
	pushdown(k);
	int m=(l+r)>>1;
	if(L<=m)modify(L,R,l,m,k<<1,v,opt);
	if(R>m)modify(L,R,m+1,r,k<<1|1,v,opt);
	pushup(k);
}
int query(int L,int R,int l,int r,int k)
{
	if(L<=l&&r<=R)
	{
		return tree[k];
	}
	pushdown(k);
	int m=(l+r)>>1,tmp=0;
	if(L<=m)tmp=max(tmp,query(L,R,l,m,k<<1));
	if(R>m)tmp=max(tmp,query(L,R,m+1,r,k<<1|1));
	return tmp;
}
void add_edge(int a,int b,int c,int d)
{
	pnt[E]=b;
	nxt[E]=head[a];
	weight[E]=c;
	steins[d]=E;
	head[a]=E++;
}
void dfs1(int u,int dpth)
{
	dep[u]=dpth;
	sz[u]=1;
	int maxson=0;
	for(int i=head[u];i!=-1;i=nxt[i])
	{
		int v=pnt[i];
		if(v==fa[u])continue;
		fa[v]=u;
		dfs1(v,dpth+1);
		sz[u]+=sz[v];
		if(maxson<sz[v])
		{
			maxson=sz[v];
			son[u]=v;
		}
	}
}
void dfs2(int u,int tops)
{
	top[u]=tops;
	id[u]=++cnt;
	for(int i=head[u];i!=-1;i=nxt[i])
	{
		int v=pnt[i];
		if(v==fa[u])
		{
			val[cnt]=weight[i];
			mp[i]=cnt;
			break;
		}
	}
	if(!son[u])return;
	dfs2(son[u],tops);
	for(int i=head[u];i!=-1;i=nxt[i])
	{
		int v=pnt[i];
		if(v==fa[u]||v==son[u])continue;
		dfs2(v,v);
	}
}
void modifychain(int x,int y,int z,int opt)
{
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		modify(id[top[x]],id[x],1,cnt,1,z,opt);
		x=fa[top[x]];
	}
	if(x!=y)
	{
		if(dep[x]>dep[y])swap(x,y);
		modify(id[x]+1,id[y],1,cnt,1,z,opt);
	}
}
int querychain(int x,int y)
{
	int ans=0;
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		ans=max(ans,query(id[top[x]],id[x],1,cnt,1));
		x=fa[top[x]];
	}
	if(x!=y)
	{
		if(dep[x]>dep[y])swap(x,y);
		ans=max(ans,query(id[x]+1,id[y],1,cnt,1));
	}
	return ans;
}
int main()
{
	memset(lazy2,-1,sizeof(lazy2));
	memset(head,-1,sizeof(head));
	memset(mp,-1,sizeof(mp));
	scanf("%d",&n);
	for(int i=1;i<n;++i)
	{
		int u,v,w;
		scanf("%d%d%d",&u,&v,&w);
		add_edge(u,v,w,i);
		add_edge(v,u,w,i);
	}
	dfs1(1,1);
	dfs2(1,1);
	build(1,cnt,1);
	while(1)
	{
		scanf("%s",ss);
		if(ss[1]=='h')
		{
			int x,v;
			scanf("%d%d",&x,&v);
			modify(max(mp[steins[x]],mp[steins[x]^1]),max(mp[steins[x]],mp[steins[x]^1]),1,cnt,1,v,1);
		}
		if(ss[1]=='o')
		{
			int x,y,w;
			scanf("%d%d%d",&x,&y,&w);
			modifychain(x,y,w,1);
		}
		if(ss[1]=='d')
		{
			int x,y,w;
			scanf("%d%d%d",&x,&y,&w);
			modifychain(x,y,w,2);
		}
		if(ss[1]=='a')
		{
			int x,y;
			scanf("%d%d",&x,&y);
			printf("%d\n",querychain(x,y));
		}
		if(ss[1]=='t')break;
	}
	return 0;
}
```

修改后在读入边时储存了边的起点、终点，则该边直接映射到起点、终点中深度较大的那一个点上

只在加边、dfs1、dfs2、change操作上略有不同

```cpp
#include<bits/stdc++.h>
using namespace std;
int head[100005],pnt[200005],nxt[200005],weight[200005],w[200005],E=0;
int dep[100005],son[100005],fa[100005],sz[100005];
int top[100005],val[100005],id[100005],cnt=0;
int tree[400005],lazy[400005],lazy2[400005];
int from[100005],to[100005];
int n;
char ss[15];
void pushup(int k)
{
	tree[k]=max(tree[k<<1],tree[k<<1|1]);
}
void pushdown(int k)
{
	if(lazy2[k]!=-1)
	{
		tree[k<<1]=lazy2[k];
		tree[k<<1|1]=lazy2[k];
		lazy2[k<<1]=lazy2[k];
		lazy2[k<<1|1]=lazy2[k];
		lazy[k<<1]=0;
		lazy[k<<1|1]=0;
		lazy2[k]=-1;
	}
	tree[k<<1]+=lazy[k];
	tree[k<<1|1]+=lazy[k];
	lazy[k<<1]+=lazy[k];
	lazy[k<<1|1]+=lazy[k];
	lazy[k]=0;
}
void build(int l,int r,int k)
{
	if(l==r)
	{
		tree[k]=val[l];
		return;
	}
	int m=(l+r)>>1;
	build(l,m,k<<1);
	build(m+1,r,k<<1|1);
	pushup(k);
}
void modify(int L,int R,int l,int r,int k,int v,int opt)
{
	if(L<=l&&r<=R)
	{
		if(opt==1)
		{
			tree[k]=v;
			lazy2[k]=v;
			lazy[k]=0;
		}
		else
		{
			tree[k]+=v;
			lazy[k]+=v;
		}
		return;
	}
	pushdown(k);
	int m=(l+r)>>1;
	if(L<=m)modify(L,R,l,m,k<<1,v,opt);
	if(R>m)modify(L,R,m+1,r,k<<1|1,v,opt);
	pushup(k);
}
int query(int L,int R,int l,int r,int k)
{
	if(L<=l&&r<=R)
	{
		return tree[k];
	}
	pushdown(k);
	int m=(l+r)>>1,tmp=0;
	if(L<=m)tmp=max(tmp,query(L,R,l,m,k<<1));
	if(R>m)tmp=max(tmp,query(L,R,m+1,r,k<<1|1));
	return tmp;
}
void add_edge(int a,int b,int c)
{
	pnt[E]=b;
	nxt[E]=head[a];
	weight[E]=c;
	head[a]=E++;
}
void dfs1(int u,int dpth)
{
	dep[u]=dpth;
	sz[u]=1;
	int maxson=0;
	for(int i=head[u];i!=-1;i=nxt[i])
	{
		int v=pnt[i];
		if(v==fa[u])continue;
		fa[v]=u;
		w[v]=weight[i];
		dfs1(v,dpth+1);
		sz[u]+=sz[v];
		if(maxson<sz[v])
		{
			maxson=sz[v];
			son[u]=v;
		}
	}
}
void dfs2(int u,int tops)
{
	top[u]=tops;
	id[u]=++cnt;
	val[cnt]=w[u];
	if(!son[u])return;
	dfs2(son[u],tops);
	for(int i=head[u];i!=-1;i=nxt[i])
	{
		int v=pnt[i];
		if(v==fa[u]||v==son[u])continue;
		dfs2(v,v);
	}
}
void modifychain(int x,int y,int z,int opt)
{
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		modify(id[top[x]],id[x],1,cnt,1,z,opt);
		x=fa[top[x]];
	}
	if(x!=y)
	{
		if(dep[x]>dep[y])swap(x,y);
		modify(id[x]+1,id[y],1,cnt,1,z,opt);
	}
}
int querychain(int x,int y)
{
	int ans=0;
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		ans=max(ans,query(id[top[x]],id[x],1,cnt,1));
		x=fa[top[x]];
	}
	if(x!=y)
	{
		if(dep[x]>dep[y])swap(x,y);
		ans=max(ans,query(id[x]+1,id[y],1,cnt,1));
	}
	return ans;
}
int main()
{
	memset(lazy2,-1,sizeof(lazy2));
	memset(head,-1,sizeof(head));
	scanf("%d",&n);
	for(int i=1;i<n;++i)
	{
		int u,v,w;
		scanf("%d%d%d",&u,&v,&w);
		from[i]=u;
		to[i]=v;
		add_edge(u,v,w);
		add_edge(v,u,w);
	}
	dfs1(1,1);
	dfs2(1,1);
	build(1,cnt,1);
	while(1)
	{
		scanf("%s",ss);
		if(ss[1]=='h')
		{
			int x,v;
			scanf("%d%d",&x,&v);
			int u=from[x],vv=to[x];
			if(dep[u]>dep[vv])swap(u,vv);
			modify(id[vv],id[vv],1,cnt,1,v,1);
		}
		if(ss[1]=='o')
		{
			int x,y,w;
			scanf("%d%d%d",&x,&y,&w);
			modifychain(x,y,w,1);
		}
		if(ss[1]=='d')
		{
			int x,y,w;
			scanf("%d%d%d",&x,&y,&w);
			modifychain(x,y,w,2);
		}
		if(ss[1]=='a')
		{
			int x,y;
			scanf("%d%d",&x,&y);
			printf("%d\n",querychain(x,y));
		}
		if(ss[1]=='t')break;
	}
	return 0;
}
```

---

## 作者：Captain_Paul (赞：1)

一道~~毒瘤~~树链剖分

主要思想就是把边权化为点权

与P1505 旅游有些类似

先进行dfs,之后枚举编号为奇数的边

使奇数边的to比from的深度大

然后把边权存为to的点权即可

维护一个区间加法标记和一个区间覆盖标记

接下来就是普通线段树操作了

~~我才不会说我少打一个pushdown调了两个小时~~

感谢@da32s1da 大佬的帮助！

丑陋的代码：

```cpp
#include<cstdio>
#include<cstring>
#include<cctype>
#include<algorithm>
#define reg register
using namespace std;
const int N=1e5+5;
struct edge
{
	int from,to,nxt,dis;
}edge[N<<1];
int n,num,head[N],fa[N],son[N],tot[N],tag[N<<2];
int cnt,idx[N],top[N],dep[N],w[N],maxn[N<<2],lazy[N<<2];
inline int read()
{
	int x=0,w=1;
	char c=getchar();
	while (!isdigit(c)&&c!='-') c=getchar();
	if (c=='-') c=getchar(),w=-1;
	while (isdigit(c))
	{
		x=(x<<1)+(x<<3)+c-'0';
		c=getchar();
	}
	return x*w;
}
inline void add_edge(int from,int to,int dis)
{
	edge[++num].nxt=head[from];
	edge[num].from=from;
	edge[num].to=to;
	edge[num].dis=dis;
	head[from]=num;
}
void dfs(int k,int father,int deep)
{
	int bigson=0;
	fa[k]=father; dep[k]=deep; tot[k]=1;
	for (reg int i=head[k];i;i=edge[i].nxt)
	{
		int v=edge[i].to;
		if (v==father) continue;
		dfs(v,k,deep+1); tot[k]+=tot[v];
		if (bigson<tot[v])
		{
			bigson=tot[v]; son[k]=v;
		}
	}
}
void dfs(int k,int tp)
{
	idx[k]=++cnt; top[k]=tp;
	if (!son[k]) return; dfs(son[k],tp);
	for (reg int i=head[k];i;i=edge[i].nxt)
	{
		int v=edge[i].to;
		if (!idx[v]) dfs(v,v);
	}
}
inline void pushup(int now)
{
	maxn[now]=max(maxn[now<<1],maxn[now<<1|1]);
}
inline void pushdown(int now)
{
	if (tag[now]!=-1)
	{
		maxn[now<<1]=maxn[now<<1|1]=tag[now];
        tag[now<<1]=tag[now<<1|1]=tag[now];
        lazy[now<<1]=lazy[now<<1|1]=0;
		tag[now]=-1;
	}
	if (lazy[now])
	{
		lazy[now<<1]+=lazy[now];
		lazy[now<<1|1]+=lazy[now];
		maxn[now<<1]+=lazy[now];
		maxn[now<<1|1]+=lazy[now];
		lazy[now]=0;
	}
}
void build(int l,int r,int now)
{
	lazy[now]=0; tag[now]=-1;
	if (l==r)
	{
		maxn[now]=w[l]; return;
	}
	int mid=(l+r)>>1;
	build(l,mid,now<<1);
	build(mid+1,r,now<<1|1);
	pushup(now);
}
void outchange(int p,int l,int r,int now,int c)
{
	if (l==r)
	{
		maxn[now]=c; return;
	}
	int mid=(l+r)>>1; pushdown(now);
	if (p<=mid) outchange(p,l,mid,now<<1,c);
	else outchange(p,mid+1,r,now<<1|1,c);
	pushup(now);
}
void inchange(int L,int R,int l,int r,int now,int c)//都修改为一个数  
{
	if (l>R||r<L) return;
	if (l>=L&&r<=R)
	{
		maxn[now]=c; tag[now]=c;
		lazy[now]=0; return;
	}
	int mid=(l+r)>>1; pushdown(now);
	if (mid>=R) inchange(L,R,l,mid,now<<1,c);
	else if (mid<L) inchange(L,R,mid+1,r,now<<1|1,c);
	else
	{
		inchange(L,mid,l,mid,now<<1,c);
		inchange(mid+1,R,mid+1,r,now<<1|1,c);
	}
	pushup(now);
} 
void inchanges(int L,int R,int l,int r,int now,int c)//都加上一个数
{
	if (l>R||r<L) return;
	if (l>=L&&r<=R)
	{
		maxn[now]+=c; lazy[now]+=c; return;
	}
	int mid=(l+r)>>1; pushdown(now);
	if (mid>=R) inchanges(L,R,l,mid,now<<1,c);
	else if (mid<L) inchanges(L,R,mid+1,r,now<<1|1,c);
	else
	{
		inchanges(L,mid,l,mid,now<<1,c);
		inchanges(mid+1,R,mid+1,r,now<<1|1,c);
	}
	pushup(now);
} 
int getmax(int L,int R,int l,int r,int now)
{
	if (l>R||r<L) return -1e9;
	if (l>=L&&r<=R) return maxn[now];
	int mid=(l+r)>>1; pushdown(now);
	if (mid>=R) return getmax(L,R,l,mid,now<<1);
	if (mid<L) return getmax(L,R,mid+1,r,now<<1|1);
	return max(getmax(L,mid,l,mid,now<<1),getmax(mid+1,R,mid+1,r,now<<1|1));
}
inline void treechange(int x,int y,int val)//都修改为一个数
{
	while (top[x]!=top[y])
	{
		if (dep[top[x]]<dep[top[y]]) swap(x,y);
		inchange(idx[top[x]],idx[x],1,n,1,val);
		x=fa[top[x]];
	}
    if (dep[x]>dep[y]) swap(x,y);
    inchange(idx[x]+1,idx[y],1,n,1,val);
}
inline void treechanges(int x,int y,int val)//都加上一个数 
{
	while (top[x]!=top[y])
	{
		if (dep[top[x]]<dep[top[y]]) swap(x,y);
		inchanges(idx[top[x]],idx[x],1,n,1,val);
		x=fa[top[x]];
	}
	if (dep[x]>dep[y]) swap(x,y);
	inchanges(idx[x]+1,idx[y],1,n,1,val);
}
inline int treemax(int x,int y)
{
	int ans=-1e9;
	while (top[x]!=top[y])
	{
		if (dep[top[x]]<dep[top[y]]) swap(x,y);
		ans=max(ans,getmax(idx[top[x]],idx[x],1,n,1));
		x=fa[top[x]];
	}
	if (dep[x]>dep[y]) swap(x,y);
	return max(ans,getmax(idx[x]+1,idx[y],1,n,1));
}
int main()
{
	n=read();
	for (reg int i=1;i<n;i++)
	{
		int x=read(),y=read(),z=read();
		add_edge(x,y,z);
		add_edge(y,x,z);
	}
	dfs(1,0,1); dfs(1,1);
	for (reg int i=1;i<=num;i+=2)
	{
		int &u=edge[i].from,&v=edge[i].to;
		if (dep[u]>dep[v]) swap(u,v);
		w[idx[v]]=edge[i].dis;
	}
	build(1,n,1);
	while (1)
	{
		char opt[10]; scanf("%s",opt);
		if (opt[0]=='S') break;
		int x=read(),y=read();
		if (opt[0]=='C')
		  if (opt[1]=='h') outchange(idx[edge[(x<<1)-1].to],1,n,1,y);
		  else treechange(x,y,read());
		if (opt[0]=='A') treechanges(x,y,read());
		if (opt[0]=='M') printf("%d\n",treemax(x,y));
	}
	return 0;
}
```

---

## 作者：zhengrunzhe (赞：1)

提供指针线段树做法

这题的坑点就是巨**难调

~~我**调了好几天结果是单点修改没加pushdown~~

处理覆盖时需要把加标记清零

先覆盖后加

单点修改改第x条边的值

有好几种处理方法

可以开个数组dot[x]=p 表示第x条边指向的下面的点是p

或者是比较双向边的两条边所指向的点的深度
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=1e5+10;
namespace Edge
{
	int cnt,head[N],dot[N];
	struct edge{int to,w,next;}e[N*2];
	inline void add(int a,int b,int c)
	{
		e[++cnt].next=head[a];
		head[a]=cnt;
		e[cnt].to=b;
		e[cnt].w=c;
	}
}using namespace Edge;
namespace Segment_Tree
{
	int num[N],value[N]; //num[x]表示dfs序为x的点的编号
	struct tree
	{
		tree *son[2]; //son[0]表示左儿子 son[1]表示右儿子
		int l,r,mx,cov,add;
		inline tree(int L,int R)
		{
			cov=-1; //一开始需要赋成-1 
			add=mx=0;
			l=L;r=R;
			son[0]=son[1]=NULL;
		}
		inline void pushup()
		{
			mx=max(son[0]->mx,son[1]->mx);
		}
		inline void cover(int w)
		{
			cov=mx=w;add=0; //记得清零加标记
		}
		inline void plus(int w)
		{
			add+=w;mx+=w;
		}
		inline void pushdown()
		{
			if (cov!=-1)
				son[0]->cover(cov),
				son[1]->cover(cov),
				cov=-1;
			if (add)
				son[0]->plus(add),
				son[1]->plus(add),
				add=0;
		}
		void update1(int pos,int key)
		{
			if (l==r){cover(key);return;}
			pushdown(); //注意不要漏掉任何一个pushdown 否则全WA..
			son[pos>(l+r>>1)]->update1(pos,key);
			pushup();
		}
		void update2(int L,int R,int w)
		{
			if (l>R||r<L)return;
			if (l>=L&&r<=R){cover(w);return;}
			pushdown();
			son[0]->update2(L,R,w);
			son[1]->update2(L,R,w);
			pushup();
		}
		void update3(int L,int R,int w)
		{
			if (l>R||r<L)return;
			if (l>=L&&r<=R){plus(w);return;}
			pushdown();
			son[0]->update3(L,R,w);
			son[1]->update3(L,R,w);
			pushup();
		}
		int query(int L,int R)
		{
			if (l>R||r<L)return 0;
			if (l>=L&&r<=R)return mx;
			pushdown();
			return max(son[0]->query(L,R),son[1]->query(L,R));
		}
	}*root;
	void build(tree *&p,int l,int r)
	{
		p=new tree(l,r);
		if (l==r){p->mx=value[num[l]];return;}
		int mid=l+r>>1;
		build(p->son[0],l,mid);
		build(p->son[1],mid+1,r);
		p->pushup();
	}
}using namespace Segment_Tree;
namespace Heavylight_Decomposition
{
	int dfn[N],size[N],top[N],wson[N],dep[N]={0,1},fa[N],cnt;
	void dfs1(int p)
	{
		size[p]=1;
		for (int i=head[p];i;i=e[i].next)
		{
			int son=e[i].to;
			if (son==fa[p])continue;
			fa[son]=p;dep[son]=dep[p]+1;
			value[son]=e[i].w;dot[i+1>>1]=son; //编号为i的边 因为是双向建边 所以实际上输入的第i条边是这里的(i+1)/2
			dfs1(son);size[p]+=size[son];
			if (size[son]>size[wson[p]])wson[p]=son;
		}
	}
	void dfs2(int p,int tp)
	{
		top[p]=tp;dfn[p]=++cnt;num[cnt]=p;
		if (wson[p])dfs2(wson[p],tp);
		for (int son,i=head[p];i;i=e[i].next)
			if ((son=e[i].to)!=fa[p]&&son!=wson[p])
				dfs2(son,son);
	}
	inline void Cover(int a,int b,int c)
	{
		while (top[a]!=top[b])
		{
			if (dep[top[a]]<dep[top[b]])swap(a,b);
			root->update2(dfn[top[a]],dfn[a],c);
			a=fa[top[a]];
		}
		if (dep[a]>dep[b])swap(a,b);
		root->update2(dfn[a]+1,dfn[b],c); //记得dfn[a]要+1(lca不计
	}
	inline void Add(int a,int b,int c)
	{
		while (top[a]!=top[b])
		{
			if (dep[top[a]]<dep[top[b]])swap(a,b);
			root->update3(dfn[top[a]],dfn[a],c);
			a=fa[top[a]];
		}
		if (dep[a]>dep[b])swap(a,b);
		root->update3(dfn[a]+1,dfn[b],c);
	}
	inline int Max(int a,int b)
	{
		int ans=0;
		while (top[a]!=top[b])
		{
			if (dep[top[a]]<dep[top[b]])swap(a,b);
			ans=max(root->query(dfn[top[a]],dfn[a]),ans);
			a=fa[top[a]];
		}
		if (dep[a]>dep[b])swap(a,b);
		return max(ans,root->query(dfn[a]+1,dfn[b]));
	}
}using namespace Heavylight_Decomposition;
int n;
int main()
{
	scanf("%d",&n);
	for (int i=1,a,b,c;i<n;i++)
		scanf("%d%d%d",&a,&b,&c),
		add(a,b,c),add(b,a,c);
	dfs1(1);dfs2(1,1);
	build(root,1,n);
	char opt[10];
	while (scanf("%s",opt),opt[0]!='S')
	{
		int a,b,c;
		scanf("%d%d",&a,&b);
		switch (opt[1])
		{
			case 'h':{root->update1(dfn[dot[a]],b);break;}
			case 'a':{printf("%d\n",Max(a,b));break;}
			case 'o':{int c;scanf("%d",&c);Cover(a,b,c);break;}
			case 'd':{int c;scanf("%d",&c);Add(a,b,c);break;}
		}
	}
	return 0;
}
```

---

## 作者：wubaiting2020 (赞：0)

树链剖分裸题（同时也是一道锻炼码力的好题）我打了184行……（没加注释）

只需将每条变的边权放到连接的两个点当中深度较大的那个即可，但是那么在路径操作的时候，最后要把左端点+1，因为父亲节点存的是它和它父亲边的边权

然后就是线段树两个标记：加和改，其他的就是树链剖分模版操作啦

```cpp
#include<algorithm>
#include<iostream>
#include<iomanip>
#include<cstring>
#include<cstdio>
#include<cmath>
#define countt(x) (tree[x].r-tree[x].l+1)
#define LL long long
using namespace std;
const int MAXX=100005,INF=0x3f3f3f3f;
int read()
{
   int s=0,bj=0;
   char ch=getchar();
   while(ch<'0'||ch>'9')bj|=(ch=='-'),ch=getchar();
   while(ch>='0'&&ch<='9')s=(s<<1)+(s<<3)+(ch^48),ch=getchar();
   return bj?-s:s;
}
void printnum(int x)
{
	if(x>9)printnum(x/10);
	putchar(x%10^48);
}
void print(int x,char ch)
{
	if(x<0){putchar('-');x=-x;}
	printnum(x);putchar(ch);
}
int n,m; 
int dep[MAXX],size[MAXX],prt[MAXX],son[MAXX],top[MAXX],cnt,tid[MAXX],v[MAXX];
int rk[MAXX];
struct edge{int nx,to;}w[MAXX<<1];int h[MAXX],edge_cnt;
void AddEdge(int x,int y){w[++edge_cnt].to=y;w[edge_cnt].nx=h[x];h[x]=edge_cnt;}
//线段树 
struct node{int l,r,maxx,add,bj;}tree[MAXX<<2];
void pushup(int k){tree[k].maxx=max(tree[k<<1].maxx,tree[k<<1|1].maxx);}
void pushdown(int k)
{
	if(tree[k].bj!=-1)
	{
		tree[k<<1].add=tree[k<<1|1].add=0;//修改后加的延迟标记要清零 
		tree[k<<1].bj=tree[k<<1|1].bj=tree[k<<1].maxx=tree[k<<1|1].maxx=tree[k].bj;
		tree[k].bj=-1;
	}
	if(tree[k].add)
	{
		tree[k<<1].add+=tree[k].add;tree[k<<1|1].add+=tree[k].add;
		tree[k<<1].maxx+=tree[k].add;tree[k<<1|1].maxx+=tree[k].add;
		tree[k].add=0;
	}
}
void Build(int k,int l,int r)//建树 
{
	tree[k].l=l;tree[k].r=r;tree[k].bj=-1;
	if(l==r){tree[k].maxx=v[rk[l]];return;}
	int mid=(l+r)>>1;
	Build(k<<1,l,mid);Build(k<<1|1,mid+1,r);pushup(k);
}
void Add(int k,int l,int r,int d)//加 
{
	if(l>tree[k].r||r<tree[k].l)return;
	if(l<=tree[k].l&&r>=tree[k].r)
	{
		tree[k].add+=d;
		tree[k].maxx+=d;
		return;
	}
	pushdown(k);
	Add(k<<1,l,r,d);Add(k<<1|1,l,r,d);
	pushup(k);
}
void Cover(int k,int l,int r,int d)//修改 
{
	if(l>tree[k].r||r<tree[k].l)return;
	if(l<=tree[k].l&&r>=tree[k].r)
	{
		tree[k].bj=tree[k].maxx=d;
		tree[k].add=0;//注意修改操作优先级比加高，所以清零加的延迟标记 
		return;
	}
	pushdown(k);
	Cover(k<<1,l,r,d);Cover(k<<1|1,l,r,d);
	pushup(k);
}
int Ask(int k,int l,int r)//最大值 
{
	if(l>tree[k].r||r<tree[k].l)return -INF;
	if(l<=tree[k].l&&r>=tree[k].r)return tree[k].maxx;
	pushdown(k);
	return max(Ask(k<<1,l,r),Ask(k<<1|1,l,r));
}
//end
//树链剖分模版
void DFS1(int x,int fa,int depth) 
{
	dep[x]=depth;prt[x]=fa;size[x]=1;
	for(int i=h[x];i;i=w[i].nx)
	{
		int y=w[i].to;
		if(y^fa)
		{
			DFS1(y,x,depth+1);
			size[x]+=size[y];
			if(size[son[x]]<size[y])son[x]=y;
		}
	}
}
void DFS2(int x,int topp)
{
	top[x]=topp;tid[x]=++cnt;
	rk[cnt]=x;
	if(!son[x])return;
	DFS2(son[x],topp);
	for(int i=h[x];i;i=w[i].nx)
	{
		int y=w[i].to;
		if((y^son[x])&&(y^prt[x]))DFS2(y,y);
	} 
}
//end
void Add_Edge(int x,int y,int z)//加路径 
{
	while(top[x]^top[y])
	{
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		Add(1,tid[top[x]],tid[x],z);
		x=prt[top[x]];
	}
	if(x==y)return;
	if(dep[x]>dep[y])swap(x,y);
	Add(1,tid[x]+1,tid[y],z);
}
void Cover_Edge(int x,int y,int z)//改路径 
{
	while(top[x]^top[y])
	{
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		Cover(1,tid[top[x]],tid[x],z);
		x=prt[top[x]];
	}
	if(x==y)return;
	if(dep[x]>dep[y])swap(x,y);
	Cover(1,tid[x]+1,tid[y],z);
}
int Ask_Edge(int x,int y)//查询路径最大值 
{
	int ans=-INF;
	while(top[x]^top[y])
	{
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		ans=max(ans,Ask(1,tid[top[x]],tid[x]));
		x=prt[top[x]];
	}
	if(x==y)return ans;
	if(dep[x]>dep[y])swap(x,y);
	return max(ans,Ask(1,tid[x]+1,tid[y]));
}
int a[MAXX],b[MAXX],c[MAXX];
int x,y,z;
int main()
{
	n=read();
	for(int i=1;i<n;i++)
	{
		a[i]=read();b[i]=read();c[i]=read();
		AddEdge(a[i],b[i]);AddEdge(b[i],a[i]);
	}
	DFS1(1,0,1);
	DFS2(1,1);
	for(int i=1;i<=n;i++)
	{
		if(dep[a[i]]>dep[b[i]])swap(a[i],b[i]);//将深度较大的点放在b数组里面将
		v[b[i]]=c[i];//边权存在深度较大的点里面 
	}
	Build(1,1,n);
	while(1) //根据题意操作即可 
	{
		char ch[10];
		scanf("%s",ch);
		if(ch[0]=='S')break;
		x=read();y=read();
		if(ch[0]=='M')print(Ask_Edge(x,y),'\n');
		else if(ch[1]=='o'){z=read();Cover_Edge(x,y,z);}
		else if(ch[0]=='A'){z=read();Add_Edge(x,y,z);}
		else Cover(1,tid[b[x]],tid[b[x]],y);//因为之前存了每条边的两个端点，直接改即可（懒得打单修了……） 
	}
	return 0;
}
```
祝大家一遍A了它，~~我5遍……~~


---

## 作者：wxwoo (赞：0)

[$$\color{#0e90d2}\huge{\texttt{my blog}}$$](https://wxwoo.github.io/2019/09/09/solution-p4315)

******

[原题目链接](https://www.luogu.org/problem/P4315)

首先树剖边权转点权，把每一条边的权值下放到子节点上

在修改的时候注意最后要避开两个点的LCA，因为LCA的点权所代表的边权不在两个点的路径上

然后看见区间推平就想到了ODT

ODT比线段树短，好写，细节还比线段树少

但是不保证数据随机，ODT的时间复杂度没有保证

~~最后写出来跑了6s，被LCT和树剖+线段树吊打~~

代码如下

```cpp
#include<set>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
template<typename T>
inline void read(T &x)
{
	int ch=getchar();
	T f=1;
	x=0;
	while(!('0'<=ch&&ch<='9'))
	{
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
	while('0'<=ch&&ch<='9')
	{
		x=(x<<3)+(x<<1)+ch-48;
		ch=getchar();
	}
	x*=f;
}
#define setit set<node>::iterator
const int N=100010;
struct node
{
	int l,r;
	mutable int val;
	node(int L,int R=-1,int V=0):l(L),r(R),val(V){}
	friend inline bool operator<(const node &a,const node &b)
	{
		return a.l<b.l;
	}
};
set<node>s;
int n;
int u[N],v[N],head[N],nxt[N<<1],to[N<<1],val[N<<1],e;
inline void addedge(const int &u,const int &v,const int &w)
{
	to[++e]=v;
	val[e]=w;
	nxt[e]=head[u];
	head[u]=e;
}
int fa[N],son[N],dep[N],sz[N],w[N],top[N],id[N],seq[N],cnt;
char str[10];
inline setit split(const int &x)
{
	setit it=s.lower_bound(node(x));
	if(it!=s.end()&&it->l==x)
		return it;
	--it;
	int l=it->l,r=it->r,val=it->val;
	s.erase(it);
	s.insert(node(l,x-1,val));
	return s.insert(node(x,r,val)).first;
}
inline void assign(const int &l,const int &r,const int &k)
{
	setit itr=split(r+1),itl=split(l);
	s.erase(itl,itr);
	s.insert(node(l,r,k));
}
inline void add(const int &l,const int &r,const int &k)
{
	setit itr=split(r+1),itl=split(l);
	for(;itl!=itr;++itl)
		itl->val+=k;
}
inline int query(const int &l,const int &r)
{
	int ans=0;
	setit itr=split(r+1),itl=split(l);
	for(;itl!=itr;++itl)
		ans=max(ans,itl->val);
	return ans;
}
void dfs1(const int &x,const int &f,const int &d)
{
	fa[x]=f;
	dep[x]=d;
	sz[x]=1;
	for(int i=head[x];i;i=nxt[i])
	{
		int y=to[i];
		if(y==f)
			continue;
		dfs1(y,x,d+1);
		w[y]=val[i];
		sz[x]+=sz[y];
		if(sz[y]>sz[son[x]])
			son[x]=y;
	}
}
void dfs2(const int &x,const int &t)
{
	top[x]=t;
	id[x]=++cnt;
	seq[cnt]=x;
	if(!son[x])
		return;
	dfs2(son[x],t);
	for(int i=head[x];i;i=nxt[i])
	{
		int y=to[i];
		if(y==son[x]||y==fa[x])
			continue;
		dfs2(y,y);
	}
}
inline void addchain(int x,int y,const int &k)
{
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]])
			swap(x,y);
		add(id[top[x]],id[x],k);
		x=fa[top[x]];
	}
	if(x==y)
		return;
	if(dep[x]>dep[y])
		swap(x,y);
	add(id[x]+1,id[y],k);
}
inline void covchain(int x,int y,const int &k)
{
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]])
			swap(x,y);
		assign(id[top[x]],id[x],k);
		x=fa[top[x]];
	}
	if(x==y)
		return;
	if(dep[x]>dep[y])
		swap(x,y);
	assign(id[x]+1,id[y],k);
}
inline int maxchain(int x,int y)
{
	int res=0;
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]])
			swap(x,y);
		res=max(res,query(id[top[x]],id[x]));
		x=fa[top[x]];
	}
	if(x==y)
		return res;
	if(dep[x]>dep[y])
		swap(x,y);
	return max(res,query(id[x]+1,id[y]));
}
inline void updedge(int u,int v,const int &k)
{
	if(fa[v]==u)
		swap(u,v);
	assign(id[u],id[u],k);
}
int main()
{
	read(n);
	for(int i=1;i<n;++i)
	{
		int w;
		read(u[i]);
		read(v[i]);
		read(w);
		addedge(u[i],v[i],w);
		addedge(v[i],u[i],w);
	}
	dfs1(1,1,1);
	dfs2(1,1);
	for(int i=2;i<=n;++i)
		s.insert(node(i,i,w[seq[i]]));
	int l,r,k;
	while(1)
	{
		scanf("%s",str);
		if(str[1]=='t')
			break;
		read(l);
		read(r);
		if(str[1]=='a')
			printf("%d\n",maxchain(l,r));
		else if(str[1]=='h')
			updedge(u[l],v[l],r);
		else
		{
			read(k);
			if(str[1]=='o')
				covchain(l,r,k);
			else
				addchain(l,r,k);
		}
	}
	return 0;
}

```

---


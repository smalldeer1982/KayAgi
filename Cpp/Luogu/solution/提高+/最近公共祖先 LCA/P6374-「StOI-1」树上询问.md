# 「StOI-1」树上询问

## 题目描述

给定一棵 $n$ 个点的无根树，有 $q$ 次询问。

每次询问给一个参数三元组 $(a,b,c)$ ，求有多少个 $i$ 满足这棵树在以 $i$ 为根的情况下 $a$ 和 $b$ 的 [LCA](https://www.luogu.com.cn/problem/P3379) 为 $c$ 。

## 说明/提示

---

#### 样例2解释

![](https://cdn.luogu.com.cn/upload/image_hosting/7o3nd26o.png)

第一个查询的 $i$ 为 3 和 4。

第二个查询的 $i$ 为 1。

---

#### 数据范围

#### 本题按子任务测试：

$subtask1 (20pts)$：$1 \leq n \leq$ $1000$ ，$1 \leq q \leq$ $500$ 。

$subtask2 (15pts)$：$1 \leq n \leq$ $10^{5}$，$1 \leq q \leq$ $10^{5}$，树退化成链 。

$subtask3 (25pts)$：$1 \leq n \leq$ $5$ $\times$ $10^{5}$，$1 \leq q \leq $ $10^{5}$，数据**不随机** 。

$subtask4 (40pts)$：$1 \leq n \leq$ $5$ $\times$ $10^{5}$，$1 \leq q \leq $ $2$ $\times$ $10^{5}$ 。

对于所有数据：$1 \leq n \leq$ $5$ $\times$ $10^{5}$，$1 \leq q \leq $ $2$ $\times$ $10^{5}$ 。

注：数据强度不高，不必卡常与快读快输。

## 样例 #1

### 输入

```
10 5
1 2
1 3
2 4
2 5
2 10
5 6
3 7
7 8
7 9
4 6 2
4 10 1
6 8 3
9 10 2
4 10 5
```

### 输出

```
7
0
1
4
0
```

## 样例 #2

### 输入

```
5 3
1 3
1 5
3 4
3 2
5 2 3
5 2 1
2 4 5
```

### 输出

```
2
1
0```

## 样例 #3

### 输入

```
20 10
1 2
1 3
1 4
2 5
2 6
3 10
4 13
4 14
6 7
6 8
10 11
4 15
4 16
8 9
11 12
16 17
16 18
16 19
17 20
15 19 16
1 12 1
20 20 20
7 7 8
1 8 3
5 20 2
2 9 6
9 12 1
9 12 2
9 12 3```

### 输出

```
4
16
20
0
0
5
2
10
2
1
```

# 题解

## 作者：K0stlin (赞：30)

# [St-OI Round 1] T3:树上询问 官方题解

![](https://cdn.luogu.com.cn/upload/image_hosting/xfdauxz8.png)

原定时限是1.2s，本人std最慢的一个点是600ms，所以超1.2s的同学都要订正啊qwq。（不要喷我duliu！

废话不多说。

关于不随机数据：就是菊花树，是为卡掉枚举z出边的。

## 思路

这题乍一眼看上去好像并没有什么特别显而易见的做法（雾

但先画个图！

就以样例二为例：

![](https://cdn.luogu.com.cn/upload/image_hosting/7o3nd26o.png)

当我们找（2，5，z）的答案时，发现只有{2,3,1,5}可以作为LCA，因为他们在（2，5）的**唯一**路径上，**所以发现z不在路径上时（比如4），就可以直接输0。**

**如果在路径上呢？**

比如（2，5，3），**3肯定是答案**，然后我们把3给“拎”起来：

![](https://cdn.luogu.com.cn/upload/image_hosting/79ggy4ce.png)

发现**以4为根时，也可以。这时我们可以思考，是不是所有3的子节点都可以呢？**

**当然不是，2，5所在的子节点（即2，1）就不行，但其他子节点及其子节点下所有的节点都可以！（比如下图中的选中的所有节点）**

![](https://cdn.luogu.com.cn/upload/image_hosting/126ei9uf.png)

思路明显了吧：**当z在(x,y)路径上时，z和非路径上z的所有子节点（包括father）及其子孙节点就是答案！**(如果纯看语言没看懂就看代码)

## 实现：

前置知识：

树上倍增（+求LCA），dfs序

首先一遍以1为根dfs求出dfs序和子树大小，再进行倍增预处理。

然后分4种情况讨论：

在路径上时：

1. $z$是$(x,y)$的LCA$=>$ $z->x$和$z->y$的子节点在路径上,去掉

2. $z$在$x->LCA$的路径上$=>$ $z->x$和$z->father(z)$的子节点在路径上,去掉

3. $z$在$LCA->y$的路径上$=>$ $z->y$和$z->father(z)$的子节点在路径上,去掉

不在路径上时：

4. print(0);

CODE:
```cpp
#include <cstdio>
#define For(x) for(int i=hd[x];i;i=e[i].nxt)
#define v (e[i].to)
#define fsize(x) (n-size[x])//father子树大小
#define swp(x,y) (x^=y^=x^=y)
const int N=5e5+5;
int n,m,x,y,z,hd[N],num;
struct cz {
	int nxt,to;
}e[N<<1]; 
int size[N],tim[N],dep[N],cnt;//size是子树大小，tim是时间戳（dfs序），dep是节点深度
int lg[N],f[N][30];//倍增用
inline int read() {
	int x=0,flag=0;char ch=getchar();
	while(ch<'0'||ch>'9'){flag|=(ch=='-');ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return flag?-x:x;
}
inline void add(int x,int y) {
	e[++num]=(cz) {hd[x],y};
	hd[x]=num;
}
void dfs(int x,int father) {
	size[x]=1;tim[x]=++cnt;dep[x]=dep[father]+1;
	f[x][0]=father;
	For(x) {
		if(v==father) continue;
		dfs(v,x);
		size[x]+=size[v];
	}
}
inline int Lca(int x,int y) {
	if(dep[x]<dep[y]) swp(x,y);
	for(int i=lg[n];i>=0;--i)
		if(dep[f[x][i]]>=dep[y])
			x=f[x][i];
	if(x==y) return x;
	for(int i=lg[n];i>=0;--i)
		if(f[x][i]!=f[y][i])
			x=f[x][i],y=f[y][i];
	return f[x][0];
}
inline bool be_in(int x,int z) {return (tim[z]<=tim[x]&&tim[x]<=tim[z]+size[z]-1);}
//判断x在不在z的子树上
inline int tot(int x,int fa) {//x一直jump(倍增)到fa子节点的位置
	if(x==fa) return 0;
	for(int i=lg[n];i>=0;--i)
		if(tim[f[x][i]]>tim[fa])
			x=f[x][i];
	return size[x];
}
int main() {
	n=read();m=read();
	for(int i=2;i<=n;++i) lg[i]=lg[i-1]+(1<<(lg[i-1]+1)==i?1:0);
	for(int i=1;i<n;++i) {
		x=read();y=read();
		add(x,y);add(y,x);
	}
	dfs(1,0);
	for(int j=1;j<=lg[n];++j)
		for(int i=1;i<=n;++i)
			f[i][j]=f[f[i][j-1]][j-1];
	for(int i=1;i<=m;++i) {
		x=read();y=read();z=read();//下面就是4种情况
		if(Lca(x,y)==z) printf("%d\n",n-tot(x,z)-tot(y,z));
		else if(be_in(x,z)&&!be_in(y,z)) printf("%d\n",n-tot(x,z)-fsize(z));
		else if(be_in(y,z)&&!be_in(x,z)) printf("%d\n",n-tot(y,z)-fsize(z));
		else printf("0\n");
	}
	return 0;
}

```
-完-

---

## 作者：Jayun (赞：26)

# 错误修改：

upd:2020/8/22 :举例说明时数据列错了

# 题目大意：

给定一棵 $n$ 个点的无根树，有 $q$ 次询问。每次询问给一个参数三元组 $(a,b,c)$，求有多少个 $i$ 满足这棵树在以 $i$ 为根的情况下 $a$ 和 $b$ 的 LCA 为 $c$ 。

# 正文：

要解决此题，首先得找到一些规律。

![](https://s1.ax1x.com/2020/08/12/avQFMt.png)

我们拿样例的图来找到它们。

假设三元组是 $(10,6,2)$ 时，即 $c$ 是 $a,b$ 的 LCA，那么有多少个节点能成为根节点呢？可以发现有 $7$ 个（分别是 $1,2,3,4,7,8,9$）节点，就是当 $c$ 为根节点时，除了 $a,b$ 所在子树的节点，其它节点都可成为根节点。

假设三元组是 $(5,7,2)$ 时，即 $c$ 在 $a$ 通往 $a,b$ 的 LCA 的 道路上，有 $3$ 个（是 $10,2,4$），就是以 $c$ 为根的子树的节点数量减去 $a$ 所在子树的节点数量。如果 $c$ 在 $b$ 通往 $a,b$ 的 LCA 的 道路上则反之。

若 $c$ 不在任意一点 通往 $a,b$ 的 LCA 道路上时，如 $(3,2,7)$，明显无解。

# 代码：

```cpp
void dfs (int x, int fa)
{
	size[x] = 1; 
	for (int i = head[x]; i; i = next[i])
	{
		int y = to[i];
		if (y == fa) continue;
		dfs(y, x);
		size[x] += size[y];
	}
} 

void bfs (int root)
{
	q.push(root); d[root] = 1;
	while (!q.empty())
	{
		int x = q.front(); 
		q.pop();
		for (int i = head[x]; i; i = next[i])
		{
			int y = to[i];
			if (d[y]) continue;
			d[y] = d[x] + 1;
			f[y][0] = x;
			for (int j = 1; j <= num; j++)
				f[y][j] = f[f[y][j - 1]][j - 1];
			q.push(y);
		}
	} 
} 

int lca (int x, int y)
{
	if (d[x] > d[y])
	{
		int t = x;
		x = y;
		y = t;
	}
	for (int i = num; i >= 0; i--)
		if (d[f[y][i]] >= d[x])
			y = f[y][i];
	if (x == y) return x;
	for (int i = num; i >= 0; i--)
		if (f[x][i] != f[y][i])
		{
			x = f[x][i];
			y = f[y][i];
		}
	return f[x][0];
}

bool check (int x, int y, int z)         //是否在道路上 
{
	int k = lca(x, z);
	return ((lca(x, y) == y) || (lca(y, z) == y)) && lca(y, k) == k;
}

int Val (int x, int y)          //求a（b）所在子树大小 
{
	if (x==y) return 0;
	for (int i = num; i >= 0; i--)
		if(d[f[x][i]] > d[y])
			x = f[x][i];
	return size[x];
}

int main()
{
	scanf ("%d%d", &n, &m); num = (int) (log2(n)) + 1;
	for (int i = 1; i < n; i++)
	{
		int x, y;
		scanf ("%d%d", &x, &y);
		add(x, y), add(y, x);
	}
	dfs (1, 0);
	bfs (1);
	for (; m--;)
	{
		int x, y, z;
		scanf ("%d%d%d", &x, &y, &z);
		int v = lca(x, y);
		if(v == z) printf("%d\n", n - Val(x, v) - Val(y, v));
		else if(check(x, z, v)) printf("%d\n", size[z] - Val(x, z));
			else if(check(y, z, v)) printf("%d\n", size[z] - Val(y, z));
				else puts("0");
	}
	return 0;
}
```

---

## 作者：VanHelsing (赞：6)

[传送门](https://www.luogu.com.cn/problem/P6374)

一道练习树上各种操作的好题  
首先这道题需要求LCA的操作是显然的，但是能做到这个题的dalao都是秒切LCA的呢，所以这并不是一个难点  
那么，考虑这道题，好像一个树形 $dp$ ？然而空间开不下（反正我想不到怎么开状态，也想不到转移）  

想不到 $dp$ ，那就暴力吧（

首先，对于任意的两个点 $a$ 和 $b$ ，容易发现，能作为 $a$ 到 $b$ 的 $Lca$ 的点仅仅存在于 $a$ 到 $b$ 的这条链上，因为如果其他的点是 $Lca$ 的话，显然都需要先经过这条链上的某个点再到钦定的那个所谓的 "$Lca$" ，所以不在这条链上的点显然不可以作为 $Lca$ ，所以这道题仅仅需要考虑 $c$ 在 $a$ 到 $b$ 的链上的情况就好了，其他的输出 $0$ 即可

那么就考虑分类讨论然后分开做吧  
&nbsp;&nbsp;&nbsp;&nbsp;首先考虑 $c$ 就是 $a$ 和 $b$ 的 $Lca$ ，那么答案很显然就是 $n-siz_c+1$   
&nbsp;&nbsp;&nbsp;&nbsp;其次，如果 $c$ 不是 $a$ 和 $b$ 的 $Lca$ ，接着分类：   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果 $a$ 和 $b$ 是一条链，那么假定 $a$ 是两个点里深度较大的那个，设点 $p$ 是 $a$ 的祖先，同时也是 $c$ 的儿子，答案就是 $siz_c - siz_p$。为什么？我们考虑到，在这条链上的每个点的子树中，除了他同样在链上的儿子的子树，其余的点都可以作为根并使得该点成为 $a$ 和 $b$ 的 $Lca $ ，而他在链上的儿子的子树中的点作为根的话，$a$ 和 $b$ 的 $Lca$ 将是他在链上的儿子而不是他。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果 $a$ 和 $b$ 不是一条链，而是两条链，假定 $c$在 $a$ 到 $Lca$ 的那条链上，仍然假定点 $p$ 是 $a$ 的祖先，同时也是 $c$ 的儿子，那么答案是 $siz_c - siz_p$ ，这个参考上一个分类，实际情况并没有变化(我好蠢  
&nbsp;&nbsp;&nbsp;&nbsp;好吧，上边两个分类并没有用，答案毫无变化（~~我是傻逼~~），但是起码我们可以知道答案就是 $siz_c-siz_p$ 。  
那么，问题来了，怎么求 $p$ 是哪个点呢？  
相信各位都会求 $Lca$ ，而 $p$ 的求法大同小异，我们利用二进制，从 $a$ 点开始向着 $c$ 点从大往小跳，但是永远不能跳过或者跳到 $c$ 点，这样最后就是 $a$ 的祖先也是 $c$ 的儿子了。
我这里直接写了一个能直接求出是 $y$ 的儿子也是 $x$ 的祖先的点的 $siz$ 的函数，复杂度也是 $O(log_n)$的。  


$Code$ $Time:$

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e6+4;
int n,m;
int dep[maxn],siz[maxn],ffa[maxn][20];
int cnt,head[maxn],nxt[maxn<<1],to[maxn<<1];
void add_edge(int x,int y)
{
	cnt++;
	to[cnt]=y;
	nxt[cnt]=head[x];
	head[x]=cnt;
}
void dfs(int u,int fa)
{
	siz[u]=1;
	ffa[u][0]=fa;
	for(int i=head[u];i;i=nxt[i])
	{
		int v=to[i];
		if(v==fa)
		{
			continue;
		}
		dep[v]=dep[u]+1;
		dfs(v,u);
		siz[u]+=siz[v];
	}
}
int get_Lca(int x,int y)
{
	if(dep[x]<dep[y])
	{
		swap(x,y);
	}
	for(int i=19;i>=0;i--)
	{
		if(dep[y]<=dep[x]-(1<<i))
		{
			x=ffa[x][i];
		}
	}
	if(x==y)
	{
		return x;
	}
	for(int i=19;i>=0;i--)
	{
		if(ffa[x][i]==ffa[y][i])
			continue;
		else
		{
			x=ffa[x][i];
			y=ffa[y][i];
		}
	}
	return ffa[x][0];
}
int get(int x,int y)
{
	if(x==y)
	{
		return 0;
	}
	for(int i=19;i>=0;i--)
	{
		if(dep[ffa[x][i]]>dep[y])
		{
			x=ffa[x][i];
		}
	}
	return siz[x];
}
int dis(int x,int y)
{
	return dep[x]+dep[y]-2*dep[get_Lca(x,y)];
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<n;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		add_edge(x,y);
		add_edge(y,x);
	}
	dfs(1,0);
	for(int i=1;i<=19;i++)
	{
		for(int j=1;j<=n;j++)
		{
			ffa[j][i]=ffa[ffa[j][i-1]][i-1];
		}
	}
	for(int i=1;i<=m;i++)
	{
		int a,b,c;
		scanf("%d%d%d",&a,&b,&c);
		int lca=get_Lca(a,b);
		if(c==lca)//如果
		{
			printf("%d\n",n-get(a,c)-get(b,c));
			continue;
		}
		else if(dis(a,c)+dis(c,lca)==dis(a,lca))
		{
			printf("%d\n",siz[c]-get(a,c));
			continue;
		}
		else if(dis(b,c)+dis(c,lca)==dis(b,lca))
		{
			printf("%d\n",siz[c]-get(b,c));
			continue;
		}
		printf("0\n");
	}
}
/*
10 5
1 2
1 3
2 4
2 5
5 6
3 7
7 8
7 9
2 10
*/
```

---

## 作者：Boeing (赞：6)

题解里都是写 LCA 判断路径得出是否有解，再通过倍增求出再哪一棵子树内。

## 这里提供一种不需要 LCA 和倍增的方法，仅使用 dfs 序

与其他题解不同的有两点，先是**如何判断无解？**

对于三元组 $(x,y,z)$，如果 $x$，$y$ 的 lca **不可能**为 $z$，有且仅有两种情况：

### 1. $x$，$y$ 均不属于以 $z$ 为根的子树。
### 2. $x$，$y$ 均属于以 $z$ 的同一个孩子为根的子树。

用样例 2 的图解释![](https://cdn.luogu.com.cn/upload/image_hosting/7o3nd26o.png)

例如 $(3,5,4)$ 属于第一种情况，$(2,4,1)$ 属于第二种情况。

------------


再是**如何判断 $x$ 属于 $z$ 的哪一棵子树？**

显然，如果 $dfn_{z}<dfn_{x}<dfn_{z}+size_{z}$，那么 $x$ 属于 $z$ 的子树，故我们在 dfs 时用 vector 按顺序存储下来 $z$ 的每一个孩子 $s$ 的的 $dfn_{s}+size_{s}$，对于 $z$ 的第 $i$ 个孩子，记为 $son\_fn_{i}$ 如果 $son\_fn_{i-1}≤dfn_{x}<son\_fn_{i}$，那么 $x$ 一定属于第 $i$ 个孩子的子树。

那这么存下来和一个一个孩子遍历有什么区别的呢？

### 可以用二分`upper_bound()`来查找 $x$ 属于 $z$ 的哪一个孩子的子树

再同步记录一下第 $i$ 个孩子的大小，最后直接调用减去就好了。

附上代码

```cpp
#include<bits/stdc++.h>
#define maxn 500005
using namespace std;
struct{
	int t,next;
} tr[maxn*2];
int dfn[maxn],size[maxn],head[maxn],num=1,tot=1,n,m;
vector<int> son_fn[maxn],son_sz[maxn]; 
void add(int x,int y)
{
	tr[tot].t=y;
	tr[tot].next=head[x];
	head[x]=tot++;
}
int dfs(int x,int p)
{
	dfn[x]=num++;size[x]=1;
	for(int y,i=head[x];i;i=tr[i].next)
	{
		y=tr[i].t;
		if(y==p) continue;
		dfs(y,x);size[x]+=size[y];
		son_fn[x].push_back(num); //目前的num实际上就是dfn[y]+size[y]
		son_sz[x].push_back(size[y]);
	}
}
int ask(int x,int y,int z)
{
	int ans=n;int q=maxn,p=maxn;
	if(x==z&&y==z) return(n); //三者相等 特判 
	if(z!=x)
	{
		if(dfn[x]<dfn[z]||dfn[x]>=dfn[z]+size[z]) //不属于z的子树 
		{
			ans-=(n-size[z]);q=-1;
		}
		else
		{
			q=upper_bound(son_fn[z].begin(),son_fn[z].end(),dfn[x])-son_fn[z].begin(); //记录x属于z的哪一棵子树 
			ans-=son_sz[z][q];
		}
	}
	if(z!=y)
	{
		if(dfn[y]<dfn[z]||dfn[y]>=dfn[z]+size[z]) //不属于z的子树 
		{
			ans-=(n-size[z]);p=-1;
		}
		else
		{
			p=upper_bound(son_fn[z].begin(),son_fn[z].end(),dfn[y])-son_fn[z].begin(); ////记录y属于z的哪一棵子树 
			ans-=son_sz[z][p];
		}
	}
	if(p==q) return(0); //判断是否属于第1，2种情况 
	else return(ans);
}
int main(void)
{
	scanf("%d%d",&n,&m);
	for(int x,y,i=1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		add(x,y);add(y,x);
	}
	dfs(1,0);
	for(int x,y,z,i=1;i<=m;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		printf("%d\n",ask(x,y,z));
	}
}

```


---

## 作者：SmallTownKid (赞：4)

图片是借的楼上大佬的。自己再讲一讲思路。

![](https://cdn.luogu.com.cn/upload/image_hosting/h9duorm3.png)

这类题其实就是考我们LCA和两点路径的位置关系。

然后分类讨论。

如果 $c$ 不在 $a,b$ 的路径上，那么一定无解。

如果 $c$ 恰好是 $lca(a,b)$ ，那么除了 $a,b$ 子树上的点其他都是合法点。其实也就是 $n-size[ra]-size[rb]$ 。 $ra$ 和 $rb$ 表示 $a，b$ 所在子树的根节点，说白了就是 $lca$ 下面那个点。

如果 $c$ 在 $a,lca(a,b)$ 的路径上，那么答案就是 $size[c]-size[ra]$ 。

如果 $c$ 在 $b,lca(a,b)$ 的路径上，那么答案就是 $size[c]-size[rb]$ 。

证明和第一种类似，都是看把 $a,b$ 所在的子树除去剩下的点有多少。

其实想象一下，把 $c$ 点吊起来当做顶点，$a,b$ 垂在 $c$ 下面，$c$ 原来的子树的点跑到了 $c$ 上面去，都可以作为根节点，而不影响 $lca$ 。

画个图，感性理解吧。

```
#include<bits/stdc++.h>
using namespace std;
int n,q,idx,t;
int head[500010],dep[500010],size[500010],f[500010][25];
struct node{
	int nxt,to;
}edge[1000010];
void add(int u,int v)
{
	edge[++idx].nxt=head[u];
	edge[idx].to=v;
	head[u]=idx;
}
void dfs(int now,int fath)
{
	dep[now]=dep[fath]+1;
	size[now]=1;
	f[now][0]=fath;
	for(int i=1;i<=t;i++)
	{
		f[now][i]=f[f[now][i-1]][i-1];
	}
	for(int i=head[now];i;i=edge[i].nxt)
	{
		int v=edge[i].to;
		if(v==fath)
		continue;
		dfs(v,now);
		size[now]+=size[v];
	}
}
int LCA(int x,int y)
{
	if(x==y)
	return x;
	if(dep[x]<dep[y])
	swap(x,y);
	for(int i=t;i>=0;i--)
	{
		if(dep[f[x][i]]>=dep[y])
		{
			x=f[x][i];
			if(x==y)
			return x;
		}
	}
	for(int i=t;i>=0;i--)
	{
		if(f[x][i]!=f[y][i])
		{
			x=f[x][i];
			y=f[y][i];
		}
	}
	return f[x][0];
}
int get(int x,int y)//查询x所在的子树的大小，根为y，不包含y这个点 
{
	if(x==y)
	return 0;
	for(int i=t;i>=0;i--)
	{
		if(dep[f[x][i]]>dep[y])
		{
			x=f[x][i];
		}
	}
	return size[x];
}
int dis(int x,int y)//求树上两点间距离
{
	return dep[x]+dep[y]-2*dep[LCA(x,y)];
} 
int main()
{
	cin>>n>>q;
	t=(int)(log(n)/log(2))+1;
	for(int i=1;i<=n-1;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		add(u,v);
		add(v,u);
	}
	dfs(1,0);
	while(q--)
	{
		int a,b,c,ans=0;
		scanf("%d%d%d",&a,&b,&c);
		int lca=LCA(a,b);
		//无解情况，c不在a->b的路径上 
		if(lca==c)//如果c就等于真实的lca,ans=n-size[ra]-size[rb]
		{
			ans=n-get(a,c)-get(b,c);
			printf("%d\n",ans);
			continue;
		} 
		//c在a->lca(a,b)的路径上时，ans=size[c]-size[ra]
		//判断c在不在a->lca路径上：dis(a,c)+dis(c,lca)==dis(a,lca) ?
		//写成函数吧，不然太麻烦了 
		if(dis(a,c)+dis(c,lca)==dis(a,lca))
		{
			ans=size[c]-get(a,c);
			printf("%d\n",ans);
			continue;
		}
		//c在b->lca(b,c)的路径上时，ans=size[c]-size[rb]
		if(dis(b,c)+dis(c,lca)==dis(b,lca))
		{
			ans=size[c]-get(b,c);
			printf("%d\n",ans);
			continue;
		}
		printf("0\n"); 
	}
	return 0;
}
```

---

## 作者：When (赞：2)

#### 题意：

给出一颗无根树，当以$i$为根时点$A$与点$B$的$LCA$为点$C$，求这样的$i$的数量

#### 20pts：

暴力枚举每个节点作为根节点时的情况

复杂度$O(qn\log n)$.

#### 35pts:
考虑链的情况：

以链的任一端点为起点遍历，得到每一个点的深度$dep_i$，对于每一次询问，分三种情况讨论：

+ $C$在$A$与$B$以上时，无论以哪一个点为根，$LCA(A,B)$都不为$C$，$ans = 0$
+ $C$在$A$与$B$之间时，只有$C$为根才能使得$A$与$B$的$LCA$为$C$，故$ans = 1$
+ 若$C$在$A$与$B$以下，即$depC > max(depB, depA)$时，把链倒过来看，就是情况一了。
  

复杂度$O(n + q)$
（$LCA$可以直接用$dep$判断）,期望得分：$15pts$，加上暴力，共有$35pts$

#### 100pts

同样分情况讨论：

+ 当$C$在$A$至$LCA(A, B)$路径上时，考虑什么情况不合法：若把A所在子树内（以C为树根时）的点$i$作为新根，则$LCA(A,B)$为$i$，不合法；若不在C的子树内当然不合法。所以$ans = siz_C - siz_{rA}$，其中，$siz$为子树大小，$r_A$为$A$所在子树的根节点（以C为树根时）。
+ 当$C$在$B$至$LCA(A,B)$路径上时同理。
+ 当$C$为$A$与$B$的$LCA$时，若把$A$或$B$子树内的点作为新根，则$LCA(A,B)$为$A$或$B$，不合法，所以$ans = n - siz_A - siz_B$。
+ 当$C$不在$A$或$B$到$LCA$的路径上时，一定无解。
  

预处理一下$siz$即可

复杂度$O(qn\log n)$

#### 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

inline int read(){
	int x = 0, f = 1;
	char c = getchar();
	while(c < '0' || c > '9'){if(c == '-') f = -1; c = getchar();}
	while(c >= '0' && c <= '9'){x = x * 10 + c - '0'; c = getchar();}
	return x * f;
}

const int maxn = 5e5 + 10;
int head[maxn],num,siz[maxn],n,q;
int fa[maxn * 2][25],dep[maxn];
struct Edge{
	int then,to;
}e[maxn * 2];

void add(int u, int v){e[++num] = (Edge){head[u], v}; head[u] = num;}

void DFS(int x, int f, int deep){
	dep[x] = deep; fa[x][0] = f; siz[x] = 1;
	for(int i = 1; i <= 19; ++ i) fa[x][i] = fa[fa[x][i - 1]][i - 1];
	for(int i = head[x]; i; i = e[i].then){
		int v = e[i].to;
		if(v != f){
			DFS(v, x, deep + 1);
			siz[x] += siz[v];
		}
	}
}

int LCA(int x, int y){
	if(dep[x] < dep[y]) swap(x, y);
	for(int i = 19; i >= 0; -- i) 
		if(dep[fa[x][i]] >= dep[y]) x = fa[x][i];
	if(x == y) return x;
	for(int i = 19; i >= 0; -- i)
		if(fa[x][i] != fa[y][i]) x = fa[x][i], y = fa[y][i];
	return fa[x][0];
}

int find(int x, int y){
	if(x == y) return 0;
	for(int i = 19; i >= 0; -- i)
		if(dep[fa[x][i]] > dep[y]) x = fa[x][i];
	return siz[x];
}

int dis(int x, int y){
	return dep[x] + dep[y] - 2 * dep[LCA(x, y)];
}

int main(){

    //freopen("right.in","r",stdin);
	//freopen("right.out","w",stdout);

	n = read(), q = read();
	for(int i = 1; i < n; ++ i){
		int u = read(), v= read();
		add(u, v); add(v, u);
	}
	DFS(1, 0, 1);

	for(int i = 1; i <= q; ++ i){
		int x = read(), y = read(), z = read(), ans = 0;
		int lca = LCA(x, y);
		if(z == lca) ans = n - find(x, z) - find(y, z);
		else if(dis(x, z) + dis(z, lca) == dis(x, lca))
			ans = siz[z] - find(x, z);
		else if(dis(y, z) + dis(z, lca) == dis(y, lca))
			ans = siz[z] - find(y, z);
		printf("%d\n", ans);
	}
	return 0;
}

```


---

## 作者：西卡洛斯 (赞：2)

为数不多自己想到正解的一道蓝题，发篇题解纪念一下。

题意在这个题面上已经写得很明白了（

一般遇到树上问题，大家可能一般都会画一个类似这样的图：
![](https://cdn.luogu.com.cn/upload/image_hosting/6x12vzij.png)
把 $a,b$ 标成两个子节点，把 $c$ 标成它们的 LCA 。

但是对于这道题，我们可以这样画图：

![](https://cdn.luogu.com.cn/upload/image_hosting/lmf2vhkh.png)

把 $c$ 提上来，把 $a,b$ 放在下面，然后规律就好找了：

设 $size_x$ 为以 $x$ 为根节点的子树大小，$rt_x$ 表示 $x$ 所在子树的根节点。

 - $c$ 不在 $a,b$ 的路径上，此时答案为 0；
 
 - $c$ 就是 $a,b$ 的 LCA 时，作为根的 $i$ 只要不在 $a,b$ 所在的子树上，条件就成立， 此时答案为 $n-size_{rt_a}-size_{rt_b} $；
 
 - $c$ 在 $a$ 到 LCA $(a,b)$  的路径上时，此时答案为 $size_c-size_{rt_a}$；
 
 - $c$ 在 $b$ 到 LCA $(a,b)$ 的路径上的情况同理。
 
 
明白了这些，代码实现就很简单了：
 
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
const int N=5e5+10;
struct Edge{int u,v;}edge[N*2];
int head[N],cnt;
int n,q;
int f[N][20],deep[N],fa[N],size[N];
void addedge(int u,int v)
{
	edge[++cnt].v=v;
	edge[cnt].u=head[u];
	head[u]=cnt;
}
void dfs(int u,int s,int dep)
{
	f[u][0]=s;
	size[u]=1;
	deep[u]=dep;
	for(int i=1;i<=19;i++) f[u][i]=f[f[u][i-1]][i-1];
	for(int i=head[u];i;i=edge[i].u)
	{
		int v=edge[i].v;
		if(v!=s) {dfs(v,u,dep+1);size[u]+=size[v];}
	}
}
int LCA(int x,int y)
{
	if(deep[x]<deep[y]) swap(x,y);
	for(int i=19;i>=0;i--) if(deep[f[x][i]]>=deep[y]) x=f[x][i];
	if(x==y) return x;
	for(int i=19;i>=0;i--) if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];
	return f[x][0];
}
int dis(int x,int y){return deep[x]+deep[y]-2*deep[LCA(x,y)];}
int son_size(int x,int y)
{
	if(x==y) return 0;
	for(int i=19;i>=0;i--) if(deep[f[x][i]]>deep[y]) x=f[x][i];
	return size[x];
}
int main()
{
	scanf("%d%d",&n,&q);
	for(int i=1;i<n;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		addedge(u,v);
		addedge(v,u);
	}
	dfs(1,0,1);
	for(int i=1;i<=q;i++)
	{
		int a,b,c;
		int ans=0;
		scanf("%d%d%d",&a,&b,&c);
		int lca=LCA(a,b);
		if(c==lca) ans=n-son_size(a,c)-son_size(b,c);
		else if(dis(a,c)+dis(c,lca)==dis(a,lca)) ans=size[c]-son_size(a,c);
		else if(dis(b,c)+dis(c,lca)==dis(b,lca)) ans=size[c]-son_size(b,c);
		printf("%d\n",ans);
	}
	return 0;
}
```


---

## 作者：旭日临窗 (赞：1)

题意：给你一颗无根树，每次给你一个三元组$(a,b,c)$，问有多少个$i$满足一$i$为根时$a,b$的 lca 为$c$。

先不妨想一件事，先看图：

![](https://cdn.luogu.com.cn/upload/image_hosting/hz6db9j8.png)

如果想要让$a,b$的$lca==c$，我们可以把边想象成绳子，去提绳子，显然可以提$c$点以及连着$c$点的绳子。

正文：

一：$a\ne b \ne c$的情况，如下图1.1和1.2还有1.3:

这里令$far(x,y)$表示$x->y$这条路径上离y最近的点，$x$的深度大于$y$的深度且$fa[x]==y$,$son[i]$表示以点$i$为根的子树的节点个数。以1号点为根。


![](https://cdn.luogu.com.cn/upload/image_hosting/cwu8gs1c.png)

$lca(a,b)==c$，此时我们不能拉的点就是$son[far(a,c)] + son[far(c,a)]$,所以能拉的点用$n$去减就行了。

![](https://cdn.luogu.com.cn/upload/image_hosting/iodx044f.png)

$lca(a,c)==c$,此时能拉的点就是$son[c]-son[far(a,c)]$。

![](https://cdn.luogu.com.cn/upload/image_hosting/k3toh83e.png)

$lca(c,b)==c$此时能拉的点就是$son[c]-son[far(b,c)]$。

二：$a \ne b $，$&&$ ($c==a ||c==b$)。

如图2.1和2.2

![](https://cdn.luogu.com.cn/upload/image_hosting/eqcdgqyd.png)

$c==a$此时只要$fa[b]==a$就行了所以能拉的点就是$son[a]$，另外，如果本来$fa[b]==a$能拉的点就是$n-son[far(b,a)]$。

![](https://cdn.luogu.com.cn/upload/image_hosting/atlzbmxe.png)

$c==b$此时只要$fa[a]==b$就行了所以能拉的点就是$son[b]$，另外，如果本来$fa[a]==b$能拉的点就是$n-son[far(a,b)]$。

三：$a==b$此时如果$c==a$那就是$n$否则就是$0$。

补：如果$c$本来就不在$a->b$ 的路径上就是$0$，因为无论是哪个点为根$lca(a,b) \ne c$。

$\color{red}code:$

```c
#include <bits/stdc++.h>
using namespace std;
const int maxn = 5e5 + 10;
int n,q;
int son[maxn],h[maxn],fa[maxn][20],dis[maxn];
bool vis[maxn];
vector <int> G[maxn];
int dfs(int u){
	int ans = 0;
	vis[u] = 1;
	for(int i = 0;i < G[u].size();i++){
		int v = G[u][i];
		if(!vis[v]){
			fa[v][0] = u;
			h[v] = h[u] + 1;
			dis[v] = dis[u] + 1;
			ans += dfs(v);
		}
	}
	return son[u] = ans + 1;
}
void Pre(){
	dfs(1);
	for(int j = 1;j <= 19;j++)
	for(int i = 1;i <= n;i++)
	fa[i][j] = fa[fa[i][j - 1]][j - 1];
}
int lca(int u,int v){
	if(h[u] < h[v]) swap(u,v);
	int k = h[u] - h[v];
	for(int i = 19,j = 1 << 19;i >= 0;i--,j >>= 1)
	if(j <= k) u = fa[u][i],k -= j;
	if(u == v) return u;
	for(int i = 19;i >= 0;i--)
	if(fa[u][i] != fa[v][i]) u = fa[u][i],v = fa[v][i];
	return fa[u][0];
}
int far(int u,int v){
	int k = h[u] - h[v] - 1;
	for(int i = 19,j = 1 << 19;i >= 0;i--,j >>= 1)
	if(j <= k) u = fa[u][i],k -= j;
	return u; 
}
int D(int x,int y){
	int p = lca(x,y);
	return dis[x] + dis[y] - (dis[p] << 1);
}
int main(){
	scanf("%d%d",&n,&q);
	int u,v;
	for(int i = 1;i < n;i++){
		scanf("%d%d",&u,&v);
		G[u].push_back(v);
		G[v].push_back(u);
	}
	Pre();
	int a,b,c;
	while(q--){
		scanf("%d%d%d",&a,&b,&c);
		if(D(a,c) + D(c,b) != D(a,b)){
			printf("0\n");
			continue;
		}
		if(a != b && a != c && c != b){
			if(lca(a,b) == c) printf("%d\n",n - son[far(a,c)] - son[far(b,c)]);
			else if(lca(a,c) == c) printf("%d\n",son[c] - son[far(a,c)]);
			else if(lca(b,c) == c) printf("%d\n",son[c] - son[far(b,c)]);
		}
		else if(a != b){
			if(c == a) printf("%d\n",lca(a,b) != a ? son[a] : n - son[far(b,a)]);
			else printf("%d\n",lca(a,b) != b ? son[b] : n - son[far(a,b)]);
		}
		else{
			if(c == a) printf("%d\n",n);
			else printf("0\n");
		}
	}
	return 0;
}
```


---

## 作者：GIFBMP (赞：1)

显然对于每组询问，答案为在以 $c$ 为根的情况下，总点数减去 $a,b$ 所在的子树的点数。

设 $a$ 所在子树的根为 $rt_a$，$b$ 所在子树的根为 $rt_b$，分类讨论一下：

$1.$ 当 $c=\operatorname{LCA}(a,b)$ 时，答案为 $n-size_{rt_a}-size_{rt_b}$；  

$2.$ 当 $c$ 在 $a$ 到 $\operatorname{LCA}(a,b)$ 的路径上时，答案为 $n-size_{rt_a}-(n-size_c)=size_c-size_{rt_a}$； 

$3.$ 当 $c$ 在 $b$ 到 $\operatorname{LCA}(a,b)$ 的路径上时，答案为 $n-size_{rt_b}-(n-size_c)=size_c-size_{rt_b}$；  

$4.$ 当 $c$ **不在** $a$ 到 $b$ 的路径上时，显然答案为 $0$。

于是倍增预处理一下就可以了。

Code:

```cpp
#include <cstdio>
#include <vector>
using namespace std ;
const int MAXN = 5e5 + 10 ;
int n , q , f[MAXN][25] , size[MAXN] , dep[MAXN] ;
vector <int> G[MAXN] ;
void swap (int &x , int &y) {
	x ^= y ^= x ^= y ;
}
void dfs (int x , int fa) {
	f[x][0] = fa ;
	size[x] = 1 ;
	dep[x] = dep[fa] + 1 ;
	for (int i = 0 ; i < G[x].size () ; i++) {
		int v = G[x][i] ;
		if (v == fa) continue ;
		dfs (v , x) ;
		size[x] += size[v] ;
	}
}
int lca (int x , int y) {
	if (dep[x] < dep[y]) swap (x , y) ;
	for (int i = 20 ; i >= 0 ; i--)
		if (dep[f[x][i]] >= dep[y]) x = f[x][i] ;
	if (x == y) return x ;
	for (int i = 20 ; i >= 0 ; i--)
		if (f[x][i] != f[y][i]) x = f[x][i] , y = f[y][i] ;
	return f[x][0] ;
}
bool check (int x , int y , int z) {
	int k = lca (x , z) ;
	return (lca (x , y) == y || lca (y , z) == y) && lca (y , k) == k ;
}
int find (int x , int y) {
	if (x == y) return 0 ;
	for (int i = 20 ; i >= 0 ; i--)
		if (dep[f[x][i]] > dep[y]) x = f[x][i] ;
	return size[x] ;
}
int main () {
	scanf ("%d %d" , &n , &q) ;
	for (int i = 1 ; i < n ; i++) {
		int u , v ;
		scanf ("%d %d" , &u , &v) ;
		G[u].push_back (v) ;
		G[v].push_back (u) ;  
	}
	dfs (1 , 0) ;
	for (int i = 1 ; i <= 20 ; i++)
		for (int j = 1 ; j <= n ; j++)
			f[j][i] = f[f[j][i - 1]][i - 1] ;
	while (q--) {
		int x , y , z ;
		scanf ("%d %d %d" , &x , &y , &z) ;
		int k = lca (x , y) ;
		if (k == z) printf ("%d\n" , n - find (x , k) - find (y , k)) ;
		else if (check (x , z , k)) printf ("%d\n" , size[z] - find (x , z)) ;
		else if (check (y , z , k)) printf ("%d\n" , size[z] - find (y , z)) ;
		else printf ("0\n") ;
	}
	return 0 ;
} 
```

---

## 作者：zhengrunzhe (赞：1)

提供一个lct(s-t trees)做法

题意显然就是求当c作根时，除去a,b所在的子树后的树的大小

也就是把ab路径提取出来，c的轻子树大小+1(c自己)

直接用s-t tree维护轻子树大小($dashed\_size$)，簇大小($size$)

可能需要先判断c是不是在ab路径上，不在输出0

这个可以用$dis(a,c)+dis(c,b)=dis(a,b)$判断

所以可以多维护一个实链大小($solid\_size$)来处理距离(也可以别的方法做

(lct维护子树大小就切换虚实链的时候$dashed\_size$+原来实儿子的$size$-新实儿子的$size$)

```cpp
#include<cstdio>
template<class type>inline const void read(type &in)
{
	in=0;char ch(getchar());
	while (ch<48||ch>57)ch=getchar();
	while (ch>47&&ch<58)in=(in<<3)+(in<<1)+(ch&15),ch=getchar();
}
template<class type>inline const void swap(type &a,type &b){const type c(a);a=b;b=c;}
const int N(5e5+5);
struct tree
{
	bool rev;
	int solid_size,dashed_size,size;
	tree *son[2],*fa;
	static tree *null;
	void *operator new(size_t size);
	void *operator new[](size_t size);
	inline tree():solid_size(0),dashed_size(0),rev(0)
	{
		static bool init(0);
		if (!init)
			init=1,
			null=new tree,
			null->son[0]=null->son[1]=null->fa=null;
		son[0]=son[1]=fa=null;
	}
	inline const void pushup()
	{
		solid_size=son[0]->solid_size+1+son[1]->solid_size;
		size=son[0]->size+1+son[1]->size+dashed_size;
	}
	inline const void reverse()
	{
		swap(son[0],son[1]);rev^=1;
	}
	inline const void pushdown()
	{
		if (rev)son[0]->reverse(),son[1]->reverse(),rev=0;
	}
	inline const bool id()
	{
		return fa->son[1]==this;
	}
	inline const bool isroot()
	{
		return fa->son[0]!=this&&fa->son[1]!=this;
	}
	inline const void set(tree *p,const bool &d)
	{
		(son[d]=p)->fa=this;
	}
	inline const void rotate()
	{
		bool f(id());
		tree *fa(this->fa);
		fa->pushdown();pushdown();
		if (!fa->isroot())fa->fa->son[fa->id()]=this;
		this->fa=fa->fa;fa->set(son[!f],f);set(fa,!f);
		fa->pushup();pushup();
	}
	inline const void splay()
	{
		for (pushdown();!isroot();rotate())
			if (!fa->isroot())
				fa->fa->pushdown(),
				(fa->id()^id()?this:fa)->rotate();
	}
}*tree::null,*node0;
#define null tree::null
#define node(x) (node0+x)
char memory_pool[N*sizeof(tree)],*tail(memory_pool+sizeof memory_pool);
inline void *tree::operator new(size_t size){return tail-=size;}
inline void *tree::operator new[](size_t size){return tail-=size;}
inline const void access(tree *p)
{
	p->splay();
	p->dashed_size+=p->son[1]->size;
	p->son[1]=null;p->pushup();
	for (tree *q(p->fa);q!=null;q=p->fa)
		q->splay(),
		q->dashed_size+=q->son[1]->size,
		q->dashed_size-=(q->son[1]=p)->size,
		q->pushup(),
		p->rotate();
}
inline const void evert(tree *p)
{
	access(p);p->reverse();
}
inline const void expose(tree *p,tree *q)
{
	evert(p);access(q);
}
inline const int query(tree *x,tree *y,tree *z)
{
	evert(z);access(x);const int disx(x->solid_size-1);
	access(y);const int disy(y->solid_size-1);
	expose(x,y);
	if (disx+disy!=y->solid_size-1)return 0;
	return z->dashed_size+1;
}
inline const void link(tree *p,tree *q)
{
	access(p);evert(q);p->set(q,1);p->pushup();
}
int n,m;
int main()
{
	read(n);read(m);
	node0=new tree[n+1];
	for (int a,b,i(1);i<n;i++)
		read(a),read(b),link(node(a),node(b));
	for (int a,b,c;m--;)
		read(a),read(b),read(c),
		printf("%d\n",query(node(a),node(b),node(c)));
	return 0;
}
```

---

